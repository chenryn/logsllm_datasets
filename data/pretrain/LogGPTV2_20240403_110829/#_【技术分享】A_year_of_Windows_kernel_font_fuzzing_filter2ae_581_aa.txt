# 【技术分享】A year of Windows kernel font fuzzing
|
##### 译文声明
本文是翻译文章，文章来源：googleprojectzero
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
****
**翻译：**[ **Ox9A82**](http://bobao.360.cn/member/contribute?uid=2676915949)
**稿费：200RMB（不服你也来投稿啊！）**
**投稿方式：发送邮件至linwei#360.cn，或登陆**[
**网页版**](http://bobao.360.cn/contribute/index) **在线投稿**
在过去这一年内，我们通过大量的Fuzzing测试发现并报告了总计16个Windows内核在处理TrueType和OpenType字体时引发的漏洞。在这篇文章中，我们首先概述一下字体漏洞的背景，然后对我们所进行的Fuzzing测试工作做一个深入解析，其中包括整体的结果和2个案例的研究。在即将到来的第二篇文章里，我们将分享项目的具体技术细节，以及我们如何最大限度地优化过程的每个部分，并且是如何颠覆了Windows内核字体Fuzzing技术的现有状态。
**背景**
对于这篇文章的大多数读者而言，字体这个攻击面的重要性已经是不言而喻。在我们日常的使用中存在着大量的文件格式，这些格式在结构和语义上都非常复杂。因此，它们相应的难以正确的被实现，而这进一步由于以下事实而被放大：当前使用的大多数字体格式可以追溯到90年代早期，并且使用C或C++这种本地语言编写。控制的字体文件也是通过各种远程渠道如：文档，网站，脱机文件等方式交付的。最后很重要的是，负责执行程序来解释TrueType和OpenType字体格式的两个强大的虚拟机已经被证明可以用来创建可靠的利用链，因为它们能够对内存中的数据执行任意的四则运算，位运算和还有一些其他操作。基于以上所有原因，字体一直是内存破坏类漏洞的具有吸引力的来源。
字体处理漏洞被许多实际攻击场合所使用，比如Duqu恶意软件的Windows内核TTF字体
0day漏洞（大量的这一类型的漏洞被紧急修复），comex通过一个FreeType类型的漏洞实现的iOS越狱，并且成功的挑战了pwn2own2015（Joshua
Drake – Java 7 SE – 2013，Keen Team – Windows内核 – 2015）。
在过去的十年中，微软单独为其字体引擎发布了几十个安全公告，其他厂商和项目在这方面并没有比微软做的更好。现在，安全会议中已经充满了关于字体Fuzzing测试、已发现漏洞的细节的讨论。从用户安全的角度来看，这是一个非常不利的情况。如果一个系列的软件这么脆弱，但却被如此广泛的部署和使用，甚至大多数的安全人员都可以很容易的找到一个易用的0day漏洞，并将其用于实际的攻击中，那么显然是什么地方出现了问题。
**解决字体程序的安全问题**
如图所示，我们意识到这个情况需要在更一般的层面上来解决，而不是在整体的记录里再添加一两个漏洞，来获得一些虚假的安全感。让我们来直接面对它，我们目前使用的字体实现不会很快就被淘汰，因为性能仍然是字体光栅化的一个重要因素，并且代码库经过多年发展已经达到了很高的成熟度。一种通用的方法是限制字体处理代码在其各自环境中的特权，例如强制执行FreeType库的沙盒，或将字体引擎移出Windows内核（这也是微软从Windows10开始尝试去做的）。然而，这些方法大多是超出我们能力范围的。
那么，什么是在我们的能力范围之内的呢？我们可以增加漏洞挖掘的成本，并且完全清除一些程序中的简单漏洞来提高在相关代码中挖掘漏洞的门槛。自2012年初以来，我们一直使用内部的Fuzzing测试工具和一些可用资源来大规模地对FreeType项目进行Fuzzing测试。直到今天，我们已经得到超过50个错误报告，其中许多是可利用的内存破坏漏洞（见Project
Zero bug列表）。一些手动的代码审计也同样发现了一些问题。我们希望这些努力已经清除了大部分或全部的通过简单的Fuzzing测试就可以发现的低级漏洞。
然而，对漏洞挖掘而言，FreeType依然是一个相对容易的目标 –
它的开源性使得可以非常方便的进行源代码审计，通过充分理解底层逻辑使得我们可以采用静态分析算法，并允许我们把它编译成任何平台的二进制文件，它具有较低的运行时间开销（与DBI相比）。例如，我们广泛使用了AddressSanitizer，MemorySanitizer和SanitizerCoverage工具，大大提高了错误检测率，并为我们提供了代码覆盖率信息，可以用于覆盖驱动的Fuzzing测试。
与之相反的是，对Windows内核及其字体实现的测试被认为是比平均目标更难的。源代码不可用，并且调试符号仅对于引擎的一部分（位图和TTF处理在win32k.sys，但是OTF处理在ATMFD.DLL中）来说是公共的。这使得任何手工工作都变得更难，因为它必须涉及对于以间接方式对字体数据进行操作的代码部分的逆向工程。此外，代码是在与图形子系统的其余部分共享的同一个模块中执行的，这使得所有类型的交互都是至关重要的。当然有办法来提高错误发现能力（例如特殊池），但同时也存在着阻碍，例如通用异常处理会潜在地掩盖一些错误。
在2015年初，我们通过手工拆开ATMFD中的Type1/CFF虚拟机，这是最完美的审计目标。完全独立，足够复杂，但又大小适中，充满了遗留的代码并且似乎在过去没有进行过适当审查
–
这是一个不可低估的混合物。该审计产生了向Microsoft报告的8个在Windows内核中漏洞，其中一些极为关键。有关该研究和最有趣的BLEND漏洞的详细描述，请看"One
font vulnerability to rule them all"这篇博客。
CharString可以作为一个整体有效地进行审计，但是同样的策略不能应用于整个win32k.sys和ATMFD.DLL中字体相关的代码库。庞大的代码量和不同的程序状态使得我们几乎不可能去理解这些代码，更不用说保持整体的思考和寻找所有潜在的漏洞了。另一个选择当然是进行Fuzz测试
–
这种方法不能让我们对代码覆盖状态具有足够的自信，但是它的效率很高，只需要在初始设置时花费一点时间就可以，并且Fuzz技术已在过去被证明是高效的。事实上，根据公开的记录我们发现，超过90％的字体漏洞都是被Fuzzing技术发现的。这带来的额外的优点是报告通过Fuzzing获得的漏洞可以提高漏洞挖掘者的门槛，因为如果他们再使用类似的简单技术，将不再能找到任何漏洞。
考虑到这一点，我们在2015年5月开始了一个Windows内核字体Fuzz测试工作，试图采取以前对这个方面已知的技术来推进整个过程整体向前，并且进行优化来试图实现最高的效率。经过大约一年的时间，对于我们现在使用的Fuzz技术而言内核已经被清理干净了，而且我们相信我们获得的结果和使用的方法对于大众来说可能是很有趣的，这一系列文章会进行总结。
**结果**
下面是在去年通过Fuzzing测试发现的Windows内核所有漏洞的列表：
错误条目的链接包括了崩溃的简要说明，启用了特殊池的Windows 7 x86中的崩溃日志样本，以及概念文件的强制性证明。
为了重现一些崩溃，可能还需要使用Microsoft提供的专用字体加载程序（但在下一篇文章中还将详细讨论）。
如表所示，崩溃通过三次迭代报告：第一次显然包含了大部分问题，因为Fuzzing工具从一开始就碰到了很多不同的状态和代码路径。第二和第三次迭代运行的时间更长，以防止漏洞被其他更频繁的崩溃所掩盖。每次运行（3-4个月）之间的时间段是Microsoft为报告的漏洞发布补丁的时间，并与Project
Zero的90天披露日期（Microsoft在所有情况下都满足）相关联。一个案例更新了报告的时间，因为我们必须告诉Microsoft复现崩溃所必需的系统设置。
漏洞存在于处理SFNT表的代码中，在处理TTF和OTF文件时产生了编程错误。绝大多数的问题可以用于进行本地权限提升（进行沙箱逃逸等），甚至可以进行远程代码执行（对于将用户控制的文件直接传递到GDI的应用程序而言），这与Microsoft对这些漏洞的危害性评估一致。虽然我们是在Windows
7上进行的Fuzzing，但是报告的所有错误几乎仍然存在于较新版本的系统中。而且值得注意的是，虽然在Windows
10中通过在具有受限特权的用户模式进程中执行字体光栅化操作，来减轻特权提升场景，但是在该过程的上下文中的RCE仍然是可行的选项（尽管这比直接危及r0的安全更好一些）。
**撞洞**
没有什么更好的检验防御性漏洞挖掘的价值的方法，比得上观察到你上报的漏洞与在实际攻击中使用的exp（针对0day攻击）出现撞洞的情况了。尽管这些漏洞及其使用在过去有很多的记录，但是新发现是否会与2015年仍然流传的漏洞相冲突的问题仍有待解决。