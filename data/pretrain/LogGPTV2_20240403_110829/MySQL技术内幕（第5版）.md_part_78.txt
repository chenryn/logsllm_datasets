8.2Perl DBI概述
315
---
## Page 336
提交和回滚等操作。在使用DBI事务机制的Perl脚本里，可以像下面这样来完成更新操作：
所示：
弄混了，需要把它们交换过来。其中，8号学生的分数变成了18，9号学生的分数变成了13，
手动方式执行与事务相关的语句。此处的场景是，你发现自己在score表里把两名学生的分
取消事务 (并在需要时报告相应的错误)。
果块语句执行成功，
InnoDB表，则可以使用下面这条语句：
语句。它也可以移植到其他支持事务的数据库系统，然而换作 SQL语句却可能无法做到。
一个事务处理抽象（用DBI方法和属性来表达的），它会自动为你调用正确的与事务有关的SQL
COMMIT和ROLLBACK语句。（与这几条语句有关的信息请参考2.12节。）不过，DBI模块提供）
8.2.12执行事务
有的属性来保证可移植性，还是要以可移植性为代价来使用这些属性，现在由你来确定！
小技巧在MySQL里可以工作，但是在其他数据库系统里却可能无法工作。
可以通过@{Ssth->(NAME}）获得各列的名字。请注意，
回任何行的情况下生成列的元数据。当像往常那样调用prepare（）和execute（）方法之后，
316
而实际情况是这两个分数应该对换一下。为修正这个问题，需要用到的两个UPDATE 语句如下
（3）当eval块执行完成时，立刻检查其终止状态。如果出现错误，则调用rollback（）来
要想使用DBI的事务机制，你的应用程序必须使用事务安全类型的表。如果它们不是事务
更多关于DBI和DBD:mysql所提供的属性的信息请参考附录H。是要避免使用MySQL特
$dbh->(AutoCommit}=0;
sdbh->(PrintError)
$dbh->(RaiseError}=1;
你很想用正确的考试分数来更新这两个行，但是必须保证它们作为一个整体同时被更新成
UPDATE
下面的这个示例实现了此方法。它基于第2章的一个场景，即如何从 mysql客户端程序以
（4）根据需要恢复自动提交模式和出错处理属性。
(2）在一个eval块内执行那些构成某个事务的语句，同时启用 RaiseError 属性，
（1）禁用（或临时挂起）自动提交模式，以便由你自己来控制何时提交SQL语句。
在DBI脚本里，事务处理遵循以下几个步骤。
eval
ALTER TABLE tbl_name ENGINE=InnoDB;
用DBI脚本来执行事务的一种办法是，显式地执行SETautocommit、STARTTRANSACTION
#执行属于事务部分的语句
$orig_ac
Sorig_pe
$orig_re=Sdbh->(RaiseError);#存储出错处理属性
$sth=$dbh-
第8章
score SET score= 13 WHERE event_id=5 AND student_id
用 Perl DBI 编写MySQL 程序
三
Sdbh->（AutoCommit）；#存储自动提交模式
Sdbh->{PrintError};
，则它内部的最后那个操作应该是，调用commit（)来提交本次事务。
WHERE event_id=
UPDATE score SET score =?
>prepare(qq(
=?AND student_id =?
直到许可时才提交
但
出错时抛出异常
手出现错误信息
，虽然这种利用“空”查询来获得列名的
便
数
用
---
## Page 337
需要某些能直接粘贴进该文档的内容。
8.3.1生成美史联盟成员名录
一份成员名单一
现。所有的目标要等到第9章才能全部完成。
建脚本，配合Web服务器一起来解决（参考8.4节）。其中的部分目标在本章的最后部分即可实
在第1章列出的众多目标当中，有几项是要求通过编写DBI脚本来实现的。
8.3
错处理属性的设置情况时，也可以这样做。
必要保存、设置和恢复那两个属性。不过，这是一种很有效的通用做法，即使在你不太确定出
PrintError。这意味着，它们已经有了执行事务所要求的那些值。因此，在上面示例里没有
块里。）
方法来取消事务。
出错信息。此时，紧跟在eval之后的那段代码会输出这条出错信息，并且会调用rollback（）
句和 commit（)方法的执行都没有出错，则se为空。否则，eval语句块失败，se将包含相应的
对于打印的成员名录，我们想要格式能更漂亮点，因此需要一种比普通文本格式更好的表
我们的目标之一是，根据美史联盟名录按不同的格式生成各种信息。最简单的格式是生成
在这些任务当中，有些可以通过编写在命令行运行的脚本来解决。而另外一些，则需要创
此刻，你已经了解了DBI程序设计的许多概念，
在本章中，DBI脚本所使用的出错处理模式基本上都启用了RaiseError，但禁用了
口对于美史联盟项目，我们想要实现以下几项任务。
口对于成绩考评项目，我们希望能够检索到任意给定考试或测验的分数。
其中，eval语句块负责执行事务，
sdbh->(PrintError}=Sorig_pe;
sdbh->(RaiseError)
sabh->(AutoCommit)
■按不同格式生成成员名录。我们想要的格式有两种。
DBI脚本实践
#
sabh->commit();
■把成员名录放到网上去。
$sth->execute（18,5,9）;
$sth->execute
■
($@)
执行回滚，
查找兴趣相投的成员。
编辑成员条目。（当他们更新成员资格时，我们还需要更新他们的到期日期。）
把那些快要到期的成员查找出来，向他们发送电子邮件，通知他们更新成员资格。
用在联盟年会分发的议程里。另一种是可用于打印的成员名录。
一它可用在打印的议程上，而这些议程会分发给那些出席联盟年会的人员。这
，（为防止因回滚操作失败而导致脚本终止，我们把回滚操作单独放在了éval
，但是使用eval来防止回滚失败
(13，
=$orig_ac;
$orig_re;
8）;
它的终止状态被保存在S@变量里。
#事务失败了吗？
#提交事务
，下面来实际处理一下我们的示例数据库。
一种是只包含成员姓名的列表，
8.3DBI脚本实践
。如果这些 UPDATE 语
317
EE
---
## Page 338
有
给出格式名称，或者给出了无效的格式名称，那么此脚本将生成一条出错信息，并会显示出所
名称。
能够处理用于表明所要格式的命令行参数：
成阶段：一个初始化函数、一个条目输出函数和一个清理函数。
出格式。对于某种给定的格式，其中的每个元素规定了，要调用哪些函数去完成各个输出的生
方
不需要特殊处理；但对于RTF版本，则需要写入某些结尾控制语言。
行初始化。但是对于RTF 版本，则必须写入某些初始控制语言。
生成不同类型的输出。此脚本的构建步骤如下所示。
就没必要为每一种格式编写不同的脚本。最后，我们只编写一个脚本 gen_dir.pl，让它可以
命令检索各成员条目，然后再用一个循环获取和格式化每一个条目。既然它们基本相似，那么
编辑器和Safari浏览器都可以正确读取我们生成的 RTF 输出。
范的一个子集，任何支持RTF的程序都应该能正确读取它。例如，在MacOSX系统上，TextEdit
这种格式。不同的字处理软件对RTF的支持程度会有所不同，但我们只会使用全套RTF技术规
处理软件都支持它。Word 当然是其中一个，但是还有许多其他的软件，如OpenOffice，也支持
318
可用的名称。如果给出格式名称有效，那么$func_hashref 将被设置为相应的开关盒条目：
下面这段代码将根据命令行上的第一个参数，选择正确的开关盒条目。如果在命令行没有
法是建立一个“开关盒”。这种“开关盒”其实是一个散列，其中的每一个元素对应着一种输
（1）在输出成员条目之前，先初始化输出格式要求。对于普通文本格式的名单，不需要进
my $formats = join ("", sort (keys (%switchbox))）;
这个开关盒的每一个元素都是以格式名称（"text"或"rtf"）作为键。我们编写的脚本要
预计将来还可能需要利用这个脚本来生成其他格式的输出，因此我们需要增强它的扩展性
生成年会人员名单（普通文本）和RTF格式名录的过程在本质上是一样的：先用一个查询
@ARGV ==1
(3）当需要按新格式生成输出时，可以执行gen_dir.pl，同时在命令行上指定那个新格式
（1）针对输出生成的不同阶段编写3个格式化函数。
照此方式建立开关盒之后，可以很容易地根据需要添加对新格式的支持。
%./gen_dir.pl text
my %switchbox
#包含每一种输出格式的格式化函数的开关盒
(3）在处理完名
(2）获取各个条目，根据输出格式要求输出它。
确保命令行指定了一个参数
rtf"=>
'text"
往开关盒里增加一个新元素，定义一个格式名称，并指向输出函数。
第8章用Perl DBI编写MySQL程序
"cleanup"
"entry"
"init"
"cleanup"
entry"
"init"
=>
各条目之后
=>
=>
\&rtf_format_entry,
undef,
\&rtf_cleanup
\&rtf_init,
undef
后，执行某些必要的清理工作，然后终止。
#RTF 格式的处理函数
#不需要初始化
普通文本格式的处理函数
，同样地，普通文本格式
---
## Page 339
和一个空格；而对于像“I”或“I”这样的姓名后缀，其前面却只有一个空格：
部分是要处理成员姓名的后缀部分。
text_format_entry（），它会接受一个对成员条目的引用，并输出成员姓名。输出成员的棘手
8.3.1.1生成普通文本格式的成员名单
来获得它想要的列值。
使用散列引l用之后；每个格式函数都可以利用sentry_ref->(col_name}语法，通过指定列名
包含列名的顺序与它们返回这些列的顺序一样）也可以达到目的，可为何要多费周折呢？因为
那么每一个格式函数就必须要知道各个列的顺序。不难想象，通过访问$sth->(NAME)属性（它
化函数，然后获取并输出条目，最后调用清除函数：
值是一个散列引用，它指向的是针对所选格式的输出函数。
有
每一个有效的格式名称，对应的开关盒条目都会指向输出函数。对于无效的格式名称，则不会
任何条目存在。这
文本输出格式不需要进行初始化或清理调用。我们只需要一个条目格式化函数
现在剩下的工作就是，为每一种输出格式编写函数，并用开关盒的条目来命名函数。
字母“T”、“V”、“X”是仅有的表示辈分的罗马数字，它们可表示第1代到第39代。我们
当在命令行上指定的格式名称有效时，上面这段代码会设置sfunc_hashref。这个变量的
MarkYork II
Bill Matthews, Sr.
Michael Alvis IV
这个条目获取循环使用fetchrow_hashref（）)是有原因的。如果这个循环获取了一个数组，
&($func_hashref->(cleanup)) if defined ($func_hashref->(cleanup));
if (defined ($func_hashref->{entry)))
&{$func_hashref->(init}) if defined ($func_hashref->[init});
#如果有初始化函数，则调用它
这段格式选择代码基于这样一个事实，即输出格式名都是%switchbox 散列里的键。对于
#如果有条目格式化函数，则获取并输出条目
defined ($func_hashref)
my $func_hashref = $switchbox{$ARGV[0]];
如果有清理函数，则调用它
#
Ssth->execute();
my $sth=$dbh->prepare(qq(
or die"Unknowm format:$ARGV[o]\nAllowable formats:$formats\n";
or die "Usage: gen_dir.pl format_type\nAllowable formats: $formats\n";
&($func_hashref->(entry))(Sentry_ref);
#通过对格式化函数的引用传递条目
}）;
：代码无需更改，便能自动检测它。
SELECT *FROM member ORDER BY last_name, first_name
这样便可以不必把格式名称硬编码在格式选择代码里，从而在往这个开关盒
下面这段代码将使用它来调用初始
8.3DBI脚本实践
319
---
## Page 340
组合理的默认值。
后面的数字表示大小单位为半个点)。没必要设置页边距，因为大多数的字处理软件都能提供-
号字体（在字体表里它被定义为Times字体）；\fs24表示把字体大小设置为12点（紧跟在\fs
可以增加更多字体信息。）
把0号字体定义成Times字体。（我们只需要一种字体，但是如果你想把文档弄得更花哨一点，
息列在一组花括号里,其中包含打头的关键字\fonttbl和字体信息。上面显示的这段代码框架，
以满足我们的需要。
档的第一个关键字必须是\rtfn，其中，n是该文档所使用的 RTF规范的版本号。版本0已足
下所示：
一些RTF 控制语言，并且在文档的开头和结尾都要加上某些控制语言。最小的 RTF文档框架如
是，每个条目都需要输出更多的信息。原因之二是，为实现格式效果，需要在每个条目上都加
8.3.1.2生成RTF格式的成员名录
成一件很容易做到的事情了：
里的代码，我们可以把它单独写成一个辅助函数：
码在后面生成RTF格式的成员名录时还会用到。因此，为了避免重复编写rtf_format_entry（）
查来决定是否需要加上逗号：
不可能使用超出这个范围的任何数字，因此我们可以根据下面这个模式，通过对姓名后缀的检
接下来的几条指令用于设置默认的格式风格：\plain表示选择普通格式；\fO表示选择