int max=array[0];
for(inti=1;imax){
13/04/2018 Page 241 of 283
max=array[i];
}
}
int time=0;
//判断位数;
while(max>0){
max/=10;
time++;
}
//建立10个队列;
List queue=newArrayList();
for(int i=0;iqueue1=new ArrayList();
queue.add(queue1);
}
//进行time次分配和收集;
for(int i=0;iqueue2=queue.get(x);
queue2.add(array[j]);
queue.set(x, queue2);
}
int count=0;//元素计数器;
//收集队列元素;
for(int k=0;k0){
ArrayListqueue3=queue.get(k);
array[count]=queue3.get(0);
queue3.remove(0);
count++;
}
}
}
}
}
13/04/2018 Page 242 of 283
21.1.5. 剪枝算法
在搜索算法中优化中，剪枝，就是通过某种判断，避免一些不必要的遍历过程，形象的说，就是
剪去了搜索树中的某些“枝条”，故称剪枝。应用剪枝优化的核心问题是设计剪枝判断方法，即
确定哪些枝条应当舍弃，哪些枝条应当保留的方法。
21.1.6. 回溯算法
回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现
已不满足求解条件时，就“回溯”返回，尝试别的路径。
21.1.7. 最短路径算法
从某顶点出发，沿图的边到达另一顶点所经过的路径中，各边上权值之和最小的一条路径叫做最
短路径。解决最短路的问题有以下算法，Dijkstra算法，Bellman-Ford算法，Floyd算法和SPFA
算法等。
21.1.8. 最大子数组算法
21.1.9. 最长公共子序算法
21.1.10. 最小生成树算法
现在假设有一个很实际的问题：我们要在 n 个城市中建立一个通信网络，则连通这 n 个城市需要
布置n-1一条通信线路，这个时候我们需要考虑如何在成本最低的情况下建立这个通信网？
于是我们就可以引入连通图来解决我们遇到的问题，n个城市就是图上的n个顶点，然后，边表示
两个城市的通信线路，每条边上的权重就是我们搭建这条线路所需要的成本，所以现在我们有n个
顶点的连通网可以建立不同的生成树，每一颗生成树都可以作为一个通信网，当我们构造这个连
通网所花的成本最小时，搭建该连通网的生成树，就称为最小生成树。
13/04/2018 Page 243 of 283
构造最小生成树有很多算法，但是他们都是利用了最小生成树的同一种性质：MST 性质（假设
N=(V,{E})是一个连通网，U 是顶点集 V 的一个非空子集，如果（u，v）是一条具有最小权值的边，
其中u属于U，v属于V-U，则必定存在一颗包含边（u，v）的最小生成树），下面就介绍两种使
用MST性质生成最小生成树的算法：普里姆算法和克鲁斯卡尔算法。
13/04/2018 Page 244 of 283
22. 数据结构
22.1.1. 栈（stack）
栈（stack）是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫做栈顶
（top）。它是后进先出（LIFO）的。对栈的基本操作只有 push（进栈）和 pop（出栈）两种，
前者相当于插入，后者相当于删除最后的元素。
22.1.2. 队列（queue）
队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的
后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为
队尾，进行删除操作的端称为队头。
22.1.3. 链表（Link）
链表是一种数据结构，和数组同级。比如，Java 中我们使用的 ArrayList，其实现原理是数组。而
LinkedList的实现原理就是链表了。链表在进行循环遍历时效率不高，但是插入和删除时优势明显。
13/04/2018 Page 245 of 283
22.1.4. 散列表（Hash Table）
散列表（Hash table，也叫哈希表）是一种查找算法，与链表、树等算法不同的是，散列表算法
在查找时不需要进行一系列和关键字（关键字是数据元素中某个数据项的值，用以标识一个数据
元素）的比较操作。
散列表算法希望能尽量做到不经过任何比较，通过一次存取就能得到所查找的数据元素，因而必
须要在数据元素的存储位置和它的关键字（可用key表示）之间建立一个确定的对应关系，使每个
关键字和散列表中一个唯一的存储位置相对应。因此在查找时，只要根据这个对应关系找到给定
关键字在散列表中的位置即可。这种对应关系被称为散列函数(可用h(key)表示)。
用的构造散列函数的方法有：
（1）直接定址法： 取关键字或关键字的某个线性函数值为散列地址。
即：h(key) = key 或 h(key) = a * key + b，其中a和b为常数。
（2）数字分析法
（3）平方取值法： 取关键字平方后的中间几位为散列地址。
（4）折叠法：将关键字分割成位数相同的几部分，然后取这几部分的叠加和作为散列地址。
（5）除留余数法：取关键字被某个不大于散列表表长 m 的数 p 除后所得的余数为散列地址，
即：h(key) = key MOD p p ≤ m
（6）随机数法：选择一个随机函数，取关键字的随机函数值为它的散列地址，
即：h(key) = random(key)
22.1.5. 排序二叉树
首先如果普通二叉树每个节点满足：左子树所有节点值小于它的根节点值，且右子树所有节点值
大于它的根节点值，则这样的二叉树就是排序二叉树。
22.1.5.1. 插入操作
首先要从根节点开始往下找到自己要插入的位置（即新节点的父节点）；具体流程是：新节点与
当前节点比较，如果相同则表示已经存在且不能再重复插入；如果小于当前节点，则到左子树中
13/04/2018 Page 246 of 283
寻找，如果左子树为空则当前节点为要找的父节点，新节点插入到当前节点的左子树即可；如果
大于当前节点，则到右子树中寻找，如果右子树为空则当前节点为要找的父节点，新节点插入到
当前节点的右子树即可。
22.1.5.2. 删除操作
删除操作主要分为三种情况，即要删除的节点无子节点，要删除的节点只有一个子节点，要删除
的节点有两个子节点。
1. 对于要删除的节点无子节点可以直接删除，即让其父节点将该子节点置空即可。
2. 对于要删除的节点只有一个子节点，则替换要删除的节点为其子节点。
3. 对于要删除的节点有两个子节点，则首先找该节点的替换节点（即右子树中最小的节点），
接着替换要删除的节点为替换节点，然后删除替换节点。
13/04/2018 Page 247 of 283
22.1.5.3. 查询操作
查找操作的主要流程为：先和根节点比较，如果相同就返回，如果小于根节点则到左子树中
递归查找，如果大于根节点则到右子树中递归查找。因此在排序二叉树中可以很容易获取最
大（最右最深子节点）和最小（最左最深子节点）值。
22.1.6. 红黑树
R-B Tree，全称是 Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每
个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。
22.1.6.1. 红黑树的特性
（1）每个节点或者是黑色，或者是红色。
（2）根节点是黑色。
（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]
（4）如果一个节点是红色的，则它的子节点必须是黑色的。
（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。
22.1.6.1. 左旋
对 x 进行左旋，意味着，将“x 的右孩子”设为“x 的父亲节点”；即，将 x 变成了一个左节点(x
成了为z的左孩子)！。 因此，左旋中的“左”，意味着“被旋转的节点将变成一个左节点”。
13/04/2018 Page 248 of 283
LEFT-ROTATE(T, x)
y ← right[x] // 前提：这里假设x的右孩子为y。下面开始正式操作
right[x] ← left[y] // 将 “y的左孩子” 设为 “x的右孩子”，即 将β设为x的右孩子
p[left[y]] ← x // 将 “x” 设为 “y的左孩子的父亲”，即 将β的父亲设为x
p[y] ← p[x] // 将 “x的父亲” 设为 “y的父亲”
if p[x] = nil[T]
then root[T] ← y // 情况1：如果 “x的父亲” 是空节点，则将y设为根节点
else if x = left[p[x]]
then left[p[x]] ← y // 情况2：如果 x是它父节点的左孩子，则将y设为“x的父节点
的左孩子”
else right[p[x]] ← y // 情况3：(x是它父节点的右孩子) 将y设为“x的父节点的右孩
子”
left[y] ← x // 将 “x” 设为 “y的左孩子”
p[x] ← y // 将 “x的父节点” 设为 “y”
22.1.6.1. 右旋
对 x 进行右旋，意味着，将“x 的左孩子”设为“x 的父亲节点”；即，将 x 变成了一个右节点(x
成了为y的右孩子)！ 因此，右旋中的“右”，意味着“被旋转的节点将变成一个右节点”。
13/04/2018 Page 249 of 283
RIGHT-ROTATE(T, y)
x ← left[y] // 前提：这里假设y的左孩子为x。下面开始正式操作
left[y] ← right[x] // 将 “x的右孩子” 设为 “y的左孩子”，即 将β设为y的左孩子
p[right[x]] ← y // 将 “y” 设为 “x的右孩子的父亲”，即 将β的父亲设为y
p[x] ← p[y] // 将 “y的父亲” 设为 “x的父亲”
if p[y] = nil[T]
then root[T] ← x // 情况1：如果 “y的父亲” 是空节点，则将x设为根节点
else if y = right[p[y]]
then right[p[y]] ← x // 情况2：如果 y是它父节点的右孩子，则将x设为“y的父节
点的左孩子”
else left[p[y]] ← x // 情况3：(y是它父节点的左孩子) 将x设为“y的父节点的左孩
子”
right[x] ← y // 将 “y” 设为 “x的右孩子”
p[y] ← x // 将 “y的父节点” 设为 “x”
22.1.6.1. 添加
第一步: 将红黑树当作一颗二叉查找树，将节点插入。
第二步：将插入的节点着色为"红色"。
根据被插入节点的父节点的情况，可以将"当节点 z 被着色为红色节点，并插入二叉树"划分为三
种情况来处理。
① 情况说明：被插入的节点是根节点。
处理方法：直接把此节点涂为黑色。
② 情况说明：被插入的节点的父节点是黑色。
处理方法：什么也不需要做。节点被插入后，仍然是红黑树。
13/04/2018 Page 250 of 283
③ 情况说明：被插入的节点的父节点是红色。这种情况下，被插入节点是一定存在非空祖父节点