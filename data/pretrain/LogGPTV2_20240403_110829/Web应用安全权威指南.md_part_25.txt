[37]{.注释编号下} 2009 年夏季以后的机型终于支持 Cookie 了。
由于第三方 Cookie[38]{.注释编号}
能够追踪用户的访问历史而造成隐私方面的问题，因此便产生了"Cookie
有害论"。但是那次事件以后，浏览器普遍都默认禁用了第三方
Cookie，所以也就没有理由连第一方 Cookie 也都禁用了。而且通常情况下将会话
ID 保存至 Cookie 中是最安全的方法，因此，如果由于厌恶 Cookie 而将会话 ID
嵌入到 URL 中，反而会使个人信息泄漏等事件更易于发生。
[38]{.注释编号下} 第三方 Cookie 不是由正在浏览的网站发行的
Cookie，而是指由横幅广告商或其他网站发行的 Cookie。
而手机方面，由于截至写作此书时大部分手机浏览器还不支持
Cookie，因此完全杜绝向 URL 中嵌入会话 ID 是非常艰难的。该问题将在第 7
章中详细讲述。
#### **对策**
为了不使用嵌入在 URL 中的会话 ID，就需要通过设置将会话 ID 保存在 Cookie
中。下面就来看一下各编程语言中将会话 ID 保存至 Cookie 的设置或编程方法。
-   **PHP**
    PHP 中进行如下设置后，就能将会话 ID 仅保存在 Cookie 中。
    ``` 代码无行号
    [Session]
    session.use_cookies = 1
    session.use_only_cookies = 1
    ```
-   **Java Servlet（J2EE）**
    J2EE 中将会话 ID 嵌入 URL（J2EE 中称为 URL 重写）需要调用
    `HttpServletResponse` 接口的 `encodeURL` 方法或 `encodeRedirectURL`
    方法来重写 URL，因此，只要保证程序中没有调用的相关方法，会话 ID
    就不会被嵌入到 URL。
-   **ASP.NET**
    ASP.NET 中默认将会话 ID 保存至 Cookie 中，但通过设置 web.config
    也能采用将会话 ID 嵌入 URL 的方式。新生成 web.config
    时可以不做任何操作，但如果要更改既有网站的设置，就需要进行以下设置将会话
    ID 保存至 Cookie。
### **4.6.4 固定会话 ID** {#text00000.html#nav_point_33}
#### **概要**
会话劫持的另一种攻击手段为从外部挟持会话
ID，这被称为会话固定攻击（Session Fixation Attack）。
会话固定攻击的流程如下。
> 1\. 取得会话 ID
>
> 2\. 强行将步骤 1 中的会话 ID 交给被害人
>
> 3\. 被害人登录攻击目标 Web 应用
>
> 4\. 攻击者使用该会话 ID 成功进入目标应用
会话固定攻击造成的影响同窃取会话 ID
一样，即通过伪装用户导致信息泄漏，以及使用被害人的权限恶意使用应用中的功能，如发布、更改或删除数据等。
应对会话固定攻击时，由于想要彻底杜绝上述的步骤 2
非常困难，因此普遍采用在用户登录时更换其会话 ID
的方法，这样就可以使攻击者无从得知用户登录后的会话 ID。
**固定会话 ID 所导致的安全隐患总览**
![{%}](Image00098.jpg)
#### **攻击手段与影响**
接下来我们将通过示例脚本来解说会话固定攻击的方法与影响。
-   **示例脚本介绍**
    为了方便会话固定攻击的实施，该示例脚本通过设置 .htaccess 使会话 ID
    同时保存在了 Cookie 和 URL 中。具体设置如下。
    > **代码清单 /463/.htaccess**
    ``` 代码无行号
    php_flag session.use_cookies On
    php_flag session.use_only_cookies Off
    php_flag session.use_trans_sid On
    ```
    示例脚本为精简后的认证页面和个人信息显示页面。页面构成如下。
    -   用户名输入页面
    -   认证页面（演示中不确认密码）
    -   个人信息显示页面（显示用户名）
    脚本的代码如下。
    > **代码清单 /463/46-010.php**
    ``` 代码无行号
        用户名 :
    ```
    > **代码清单 /463/46-011.php**
    ``` 代码无行号
         登录成功 
         个人信息 
    ```
    > **代码清单 /463/46-012.php**
    ``` 代码无行号
        当前用户名 :
    ```
    该示例脚本在正常情况下的页面跳转如下所示。
    ![{%}](Image00099.jpg)
    **图 4-54 示例页面跳转**
-   **会话固定攻击解说**
    下面我们来尝试攻击该示例脚本。攻击者使用如下 URL
    将应用的用户诱导至登录页面。进行此操作前需要先清空
    Cookie，因此请重启浏览器。
    ``` 代码无行号
    http://example.jp/463/46-010.php?PHPSESSID=ABC
    ```
    下图为用户无意中点击恶意链接后跳转至的登录页面，可以看出用户在页面上输入了用户名（此处为
    tanaka）。然后用户点击登录按钮后，认证就将在会话 ID
    被固定的状态下进行。
    ![{%}](Image00100.jpg)
    **图 4-55 在通过恶意 URL 跳转至的登录页面进行登录**
    这时，PHPSESSIS=ABC 的会话 ID
    生效，用户信息就将被存储在此会话中。攻击者在受害用户进行登录时即可伺机使用如下
    URL 访问被害人的个人信息。
    ``` 代码无行号
    http://example.jp/463/46-012.php?PHPSESSID=ABC
    ```
    攻击者查看被害人的个人信息时的情形如下图所示。为了区别于被害人的页面，这里使用了
    Google Chrome 浏览器。
    ![{%}](Image00101.jpg)
    **图 4-56 成功查看了被害人的个人信息**
    由此可见，攻击者能够成功看到被害人的个人信息。
-   **登录前的会话固定攻击**
    前面我们介绍了针对登录后的页面的会话固定攻击，而如果登录前的页面中使用了会话变量，就同样也会遭受会话固定攻击。这被称为登录前的会话固定攻击。下面我们就通过示例脚本来进行讲解。
    示例脚本代码如下。代码中包括个人信息输入、个人信息确认、个人信息注册（演示中不执行注册处理）3
    个页面。输入的字符串被保存至会话变量，点击确认画面上的"返回"链接时，用户就能看到刚才在文本框中输入的内容。
    > **代码清单 /463/46-020.php**
    ``` 代码无行号
     输入个人信息 
    姓名 :">
    邮箱地址 :">
    ```
    > **代码清单 /463/46-021.php**
    ``` 代码无行号
     确认个人信息 
    姓名 :
    邮箱地址 :
     返回 
    ```
    > **代码清单 /463/46-022.php**
    ``` 代码无行号
     注册个人信息 
    已注册 
    姓名 :
    邮箱地址 :
    ```
    正常情况下的页面跳转如下。
    ![](Image00102.jpg){.sgc-9 width="60%"}
    **图 4-57 页面跳转**