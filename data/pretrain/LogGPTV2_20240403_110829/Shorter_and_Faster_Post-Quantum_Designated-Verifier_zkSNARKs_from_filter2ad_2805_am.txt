tion over small fields compared to the Gennaro et al. construction
(see Table 1).
F ADDITIONAL BENCHMARKS
In this section, we provide additional benchmarks for our lattice-
based SNARK.
Microbenchmarks. For the setup and prover algorithms, we mea-
sure the concrete cost of each subcomponent. We show the break-
down for the construction over Fğ‘2 where ğ‘ = 213 âˆ’ 1 in Fig. 4
(the breakdown for other parameter settings are similar). For CRS
generation, the cost is dominated by the time needed to encrypt
Session 1C: Zero Knowledge I CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea232ğ’‘
Setting
213 âˆ’ 1
PQ
Classical
Size
CRS
Proof
5.3 GB 16.4 KB
5.3 GB 15.2 KB
1.9 GB 20.8 KB
1.9 GB 19.2 KB
Time
Setup Prover
2240 s
2225 s
877 s
865 s
68 s
69 s
56 s
56 s
PQ
Classical
219 âˆ’ 1
Table 4: Performance comparison of zkSNARKs instantiated using param-
eters for 128-bits of classical vs. 128-bits of post-quantum security (denoted
â€œPQâ€). For all measurements, we consider R1CS instances over Fğ‘2 with
220 constraints and compile them to zkSNARKs using linear-only vector
encryption over Fğ‘2.
speed-up over our construction with ğœ… = 40 bits of zero knowledge.
We see a 1.9Ã— reduction in proof size (from 20.8 KB to 11.1 KB)
in this setting. Working over a smaller base field, we can bring
the proof size down to just 8 KB. This is around 20Ã— shorter than
previous post-quantum candidates (see Table 1). This reduction in
proof size comes at the expense of a longer CRS (2.7 GB).
Classical vs. post-quantum security. If we instead instantiate our
scheme to provide 128-bits of classical security (instead of post-
quantum security), we obtain about a 5% reduction in proof size,
setup time, and prover time. Realizing post-quantum security re-
quires using a larger ring dimension ğ‘›, but does not affect the
modulus ğ‘. As such, the size of the CRS is unaffected (since we are
deriving the random component of each ciphertext from a PRF).
We provide more details in Table 4.
104
103
102
101
100
10âˆ’1
10âˆ’2
10âˆ’3
)
s
(
e
m
T
i
103
102
101
100
10âˆ’1
10âˆ’2
10âˆ’3
)
s
(
e
m
T
i
210 212 214 216 218 220
R1CS Instance Size
CRS Setup (Total)
Key Generation
LPCP Query Gen.
LPCP Query Enc.
210 212 214 216 218 220
R1CS Instance Size
Prover Time (Total)
LPCP Prover
CRS Expansion
Homomorphic Eval.
Figure 4: Cost breakdowns for CRS setup and prover for different R1CS
instances. Measurements are based on an instantiation with a linear PCP
and a vector encryption scheme over Fğ‘2 where ğ‘ = 213 âˆ’ 1.
the linear PCP queries. Namely, for an R1CS system with 220 con-
straints, linear PCP query encryption constitutes 99% of the CRS
generation time.
For the prover computation, we consider the cost of the linear
PCP prover (Claim A.6 and Appendix B), the time spent on CRS
expansion (i.e., deriving the random ciphertext components a âˆˆ Rğ‘›
ğ‘
from the PRF key), and the cost of the homomorphic operations
for computing the encrypted linear PCP response. The microbench-
marks show that about 40% of the time is spent on CRS expansion.
For an R1CS instance of size 220, the expanded CRS is over 80 GB,
and CRS expansion takes just under 30 s. Note that the vectors are
generated on the fly and we do not need to store the full CRS in mem-
ory. For the larger instances, the remaining prover computation is
evenly split between the homomorphic operations and computing
the coefficients of the linear PCP; specifically, each of these compo-
nents constitutes roughly 30% of the overall prover computation.
In the case of the linear PCP prover, the computation is dominated
by computing FFTs (see Appendix B). There is a jump in the cost
of the FFTs when we switch to our modified FFT procedure (Sec-
tion 4.1) for implementing the prover computation (for settings
where Fğ‘2 does not have enough primitive roots of unity to use
standard power-of-two FFTs). By extrapolating the performance,
our approach is about 7Ã— slower than the basic radix-2 FFT.10 When
considering an R1CS system over Fğ‘2 where ğ‘ = 219 âˆ’ 1 (where
there are sufficient roots of unity to invoke standard FFTs in the
linear PCP prover algorithm), the linear PCP prover, homomorphic
operations, and CRS expansion account for 6% (3.1 s), 38% (21.4 s),
and 56% (31.8 s) of the total prover cost, respectively.
Zero knowledge. We also measure the concrete performance of
our zkSNARKs for different choices of the zero-knowledge parame-
ter ğœ…. We provide the results in Fig. 5. In particular, when we work
over Fğ‘2 with ğ‘ = 219 âˆ’1, and consider the setting without provable
zero knowledge (i.e., setting ğœ… = 0), the prover time (for an R1CS
instance of size 220) is just 34 s. This represents an additional 1.6Ã—
10When ğ‘ = 213 âˆ’ 1, the field Fğ‘2 contains a 214-th root of unity, so we can use
standard radix-2 FFTs for R1CS instances with up to 214 constraints. For instances of
size 215, we use the approach from Section 4.1 and Appendix D, but directly inline
the multipoint evaluation and interpolation on two points (this coincides with an
existing implementation from libfqfft [94]). For instances larger than 215, we
use the general Bostan-Schost algorithms [39] for the multipoint evaluation and
interpolation. This introduces the 7Ã— overhead in the cost of the FFT.
Session 1C: Zero Knowledge I CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2337
6
5
4
3
2
1
0
)
B
G
(
e
z
i
S
S
R
C
0
20
40
ZK Parameter ğœ…
)
B
K
(
e
z
i
S
f
o
o
r
P
32
16
0
0
60
3,000
2,500
2,000
1,500
1,000
500
0
)
s
(
i
e
m
T
p
u
t
e
S
S
R
C
0
60
90
60
30
)
s
(
i
e
m
T
r
e
v
o
r
P
0
60
20
40
ZK Parameter ğœ…
60
20
40
ZK Parameter ğœ…
20
40
ZK Parameter ğœ…
ğ‘ = 213 + 1
ğ‘ = 219 + 1
Figure 5: Cost breakdowns as a function of the zero-knowledge parameter ğœ… (i.e., the zero-knowledge distinguishing advantage
of any poly(ğœ†) adversary is bounded by 2âˆ’ğœ…+negl(ğœ†)). All measurements taken for an R1CS instance over Fğ‘2 with 220 constraints
(and compiled using vector encryption over Fğ‘2).
Session 1C: Zero Knowledge I CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea234