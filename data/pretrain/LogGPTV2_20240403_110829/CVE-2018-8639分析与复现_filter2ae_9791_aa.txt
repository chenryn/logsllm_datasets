# CVE-2018-8639分析与复现
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
这个漏洞属于未正确处理窗口类成员对象导致的Double-free类型本地权限提升漏洞
## 复现环境
  1. Windows 7 sp1 64位操作系统
  2. 编译环境Visual Studio 2013
## 引用
[原poc](https://github.com/ze0r/CVE-2018-8639-exp "原poc")
[看雪分析](https://bbs.pediy.com/thread-251400.htm "看雪分析")
## Poc 成因分析
漏洞的成因是调用CreateWindowA函数创建窗口的过程中,接着调用ReferenceClass克隆tagCLS结构时，未另分配分页pool内存保存重新创建的tagCLS->lpszMenuName，而是直接克隆tagCLS结构指向源tagCLS>lpszMenuName地址,导致doublefree,  
我们先来看CreateWindowA函数对于tagCLS结构的克隆操作部分:
    unsigned __int16 *xxxCreateWindowEx(unsigned int a1, const __m128i *a2, __int64 a3, const __m128i *a4, ...)
    {
     ....
      while ( 1 )
      {
        if ( v4 & 0xFFFFFFFFFFFF0000ui64 )
        {
          v17 = UserFindAtom(*(_QWORD *)(v4 + 8));
          LOWORD(v347) = v17;
        }
        else
        {
          v17 = v4;
          LOWORD(v347) = v4;
        }
        if ( v17 )
        {
             //从当前线程ptiCurrent->ppi也就是tagPROCESSINFO中获取tagCLS结构对象
          pclsFrom = (tagCLS **)GetClassPtr(v17, (__int64)ptiCurrent->ppi, (__int64)v413);
          if ( pclsFrom )
            break;
        }
    LABEL_775:
        if ( v9
          || _bittest((const signed __int32 *)(*(_QWORD *)(*(_QWORD *)&gptiCurrent + 344i64) + 12i64), 0xDu)
          || (!((unsigned __int64)v5 & 0xFFFFFFFFFFFF0000ui64) ? (v342 = (wchar_t *)v5) : (v342 = (wchar_t *)v5->m128i_i64[1]),
              !(unsigned int)RegisterDefaultClass(v342)) )
        {
          UserSetLastError(1407);
          return 0i64;
        }
        v9 = 1;
      }
      pcls = *pclsFrom;
      v20 = 0;
      v21 = v403;
      if ( v403 & 1 )
        goto LABEL_785;
      if ( _bittest((const signed int *)&v21, 0x11u) )
        goto LABEL_786;
      v22 = v405;
      if ( _bittest(&v22, 0x12u) )
        goto LABEL_785;
      if ( (v405 & 0xC00000) == 0x400000 )
      {
        v20 = 1;
      }
      else if ( (v405 & 0xC00000) == 12582912 )
      {
        LOBYTE(v20) = (unsigned __int16)v415 >= 0x400u;
      }
      if ( v20 )
    LABEL_785:
        v403 |= 0x100u;
      else
    LABEL_786:
        v403 &= 0xFFFFFEFF;
      v23 = pcls->cbwndExtra + 296;
      if ( pcls->cbwndExtra >= 0xFFFFFED8 )
      {
        UserSetLastError(87);
        return 0i64;
      }
      v387 = pcls->cbwndExtra + 296;
      pwnd = (tagWND *)HMAllocObject(v346, v11, 1u, v23);
      v25 = pwnd;
      v366 = pwnd;
      if ( !pwnd )
        return 0i64;
      pwnd->pcls = pcls;
      pwnd->style = v405 & 0xEFFFFFFF;
      pwnd->ExStyle = v403 & 0xFDF7FFFF;
      pwnd->cbwndExtra = pcls->cbwndExtra;
      //调用ReferenceClass克隆tagCLS结构
      if ( !(unsigned int)ReferenceClass(pcls, pwnd) )
      {
        HMFreeObject(v25);
        v11 = v361;
        ptiCurrent = (tagTHREADINFO *)v346;
        goto LABEL_775;
      }
    ...
ReferenceClass是造成漏洞最关键的函数,现在来分析补丁更新前后函数的变化来了解漏洞的成因,补丁对比如下  
更新前:
    __int64 __fastcall ReferenceClass(tagCLS *Src, tagWND *pwnd)
    {
      tagDESKTOP *hheapDesktop; // rbx
      tagWND *pwndRef; // r12
      tagCLS *srcRef; // rbp
      tagCLS *pclsClone; // rsi
      unsigned __int64 cbName; // kr08_8
      char *lpszAnsiClassNameAlloced; // rax
      tagCLS *v9; // rdx
      char *lpszAnsiClassNameREf; // rdx
      hheapDesktop = pwnd->head.rpdesk;
      pwndRef = pwnd;
      srcRef = Src;
      if ( Src->rpdeskParent != hheapDesktop )
      {
        pclsClone = Src->pclsClone;
        if ( !pclsClone )
          goto LABEL_18;
        do
        {
          if ( pclsClone->rpdeskParent == hheapDesktop )
            break;
          pclsClone = pclsClone->pclsNext;
        }
        while ( pclsClone );
        if ( !pclsClone )
        {
    LABEL_18:
          //分配克隆对象内存
          pclsClone = (tagCLS *)ClassAlloc((__int64)hheapDesktop, (Src->CSF_flags & 8u) + Src->cbclsExtra + 160);
          if ( !pclsClone )
            return 0i64;
          //直接克隆tagCLS结构导致克隆后的对象pclsClone>lpszMenuName指向源tagCLS>lpszMenuName地址
          memmove(pclsClone, srcRef, (srcRef->CSF_flags & 8) + (signed __int64)srcRef->cbclsExtra + 160);
          cbName = strlen(srcRef->lpszAnsiClassName) + 1;
          lpszAnsiClassNameAlloced = (char *)ClassAlloc((__int64)hheapDesktop, cbName);
          pclsClone->lpszAnsiClassName = lpszAnsiClassNameAlloced;
          if ( !lpszAnsiClassNameAlloced )
          {
            if ( hheapDesktop )
              RtlFreeHeap(hheapDesktop->pheapDesktop, 0i64, pclsClone);
            else
              ExFreePoolWithTag(pclsClone, 0);
            return 0i64;
          }
          pclsClone->rpdeskParent = 0i64;
          LockObjectAssignment((void **)&pclsClone->rpdeskParent, hheapDesktop);
          v9 = srcRef->pclsClone;
          pclsClone->pclsClone = 0i64;
          pclsClone->pclsNext = v9;
          lpszAnsiClassNameREf = srcRef->lpszAnsiClassName;
          srcRef->pclsClone = pclsClone;
          memmove(pclsClone->lpszAnsiClassName, lpszAnsiClassNameREf, (unsigned int)cbName);
          pclsClone->spcur = 0i64;
          pclsClone->spicnSm = 0i64;
          pclsClone->spicn = 0i64;
          HMAssignmentLock((unsigned __int16 **)&pclsClone->spicn, (unsigned __int16 *)srcRef->spicn);
          HMAssignmentLock((unsigned __int16 **)&pclsClone->spicnSm, (unsigned __int16 *)srcRef->spicnSm);
          HMAssignmentLock((unsigned __int16 **)&pclsClone->spcur, (unsigned __int16 *)srcRef->spcur);
          pclsClone->spcpdFirst = 0i64;
          pclsClone->cWndReferenceCount = 0;
        }
        ++srcRef->cWndReferenceCount;
        ++pclsClone->cWndReferenceCount;
        pwndRef->pcls = pclsClone;
        return 1i64;
      }
      ++Src->cWndReferenceCount;
      return 1i64;
    }
更新后
    __int64 __fastcall ReferenceClass(tagCLS *Src, tagWND *pwnd)
    {
      tagDESKTOP *hheapDesktop; // rbx
      tagWND *pwndRef; // r12
      tagCLS *srcRef; // rbp
      tagCLS *pclsClone; // rsi
      unsigned __int64 cbName; // kr08_8
      __int64 lpszAnsiClassNameAlloced; // rax
      unsigned __int16 *lpszMenuNameRef; // rdi
      signed __int64 menuSizeIndex; // rcx
      bool v11; // zf
      unsigned int menuSizeIndexRet; // edi
      unsigned __int16 *lpszMenuNameCopy; // rax
      tagCLS *v14; // rdx
      char *v15; // rdx
      unsigned __int64 v16; // rcx
      unsigned int v17; // [rsp+40h] [rbp+8h]
      hheapDesktop = pwnd->head.rpdesk;
      pwndRef = pwnd;
      srcRef = Src;
      if ( Src->rpdeskParent != hheapDesktop )
      {
        pclsClone = Src->pclsClone;
        if ( !pclsClone )
          goto LABEL_25;
        do
        {
          if ( pclsClone->rpdeskParent == hheapDesktop )
            break;
          pclsClone = pclsClone->pclsNext;
        }
        while ( pclsClone );
        if ( !pclsClone )
        {
    LABEL_25:
          //分配内存
          pclsClone = (tagCLS *)ClassAlloc((__int64)hheapDesktop, (Src->CSF_flags & 8u) + Src->cbclsExtra + 160);
          if ( !pclsClone )
            return 0i64;
            //克隆对象
          memmove(pclsClone, srcRef, (srcRef->CSF_flags & 8) + (signed __int64)srcRef->cbclsExtra + 160);