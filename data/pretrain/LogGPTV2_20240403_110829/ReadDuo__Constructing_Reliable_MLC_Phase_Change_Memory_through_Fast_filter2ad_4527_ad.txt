following writes from the same sub-interval to differential
writes. When s >1, SDW converts more full-line writes
to differential writes, but relaxes tracking the last write
operation, which may slow down some ready operations. In
the experimental sections, we will study different s values
and their impacts on performance and chip lifetime.
E. Architectural Enhancement
Figure 7 presents an overview of the proposed ReadDuo
architecture. One PCM rank consists of eight data chips,
one ECC chip, and a bridge chip. The ECC chip is to
mitigate soft errors triggered by resistance drift, the same
as that in [2]. To defend hard errors, we may increase the
error correction capability of the current ECC chip, or even
add a new ECC chip if necessary. The design of hard error
mitigation schemes is orthogonal to our work. The bridge
chip is responsible for Ô¨Åne-grained PCM timing control and
device speciÔ¨Åc management, which helps to mitigate the
non-determinism in MLC PCM [9].
In Ô¨Ågure 7, the dark boxes mark the ReadDuo enhanced
architecture components that include (i) readout selection
(R/S) to switch between R-sensing and M-sensing; (ii)
scrubbing control (S/C) to scrub memory lines periodically;
(iii) BCH hardware to encode and decode the BCH-8 code
210
3&05DQN
3URFHVVRU&KLS
)ODJ %&+
,97LPLQJ
&RQWURO
56
6&
%&++:
0HPRU\
&RQWUROOHU
GDWDFKLSV
(&&FKLS
EULGJHFKLS
EDQNV
VXEDUUD\
¬´ ¬´
¬´
¬´
FHOODUUD\
U
H
G
R
F
H
G
Z
R
U

FROGHFRGHU
6$
Figure 7: An overview of ReadDuo architecture (dark boxes
show enhanced components).
attached to each memory line; (iv) the enhanced I/V and
timing control; (v) a hybrid sense ampliÔ¨Åer (S/A) that
supports both current and voltage sensing.
,ELDV
9ELDV
56
ƒª,FHOO
%/
7R6$
:/
3&0FHOO
)URP&HOO
56
5PHWULFVHQVLQJ
,9
FRQYHUWHU
9ROWDJH
6$
0PHWULFVHQVLQJ
9ROWDJH
6$
56
RXW
(a) Applying read voltage/current
(b) Sensed by current/voltage S/A
Figure 8: The details of hybrid sensing.
Within each subarray, ReadDuo integrates both the tra-
ditional R-metric based current-mode sensing logic and
the new M-metric based voltage-mode sensing logic. The
details are shown in Figure 8. Current-mode sensing [4], [5]
applies a Ô¨Åxed bias voltage Vbias to the cell and compares
the current Ô¨Çow through the bitline Icell to the reference
current generated by reference cells. It requires large die
area because current signals are converted to voltage signals
and then sensed. In contrast, M-metric reading only requires
voltage sensing sense ampliÔ¨Åer but not the I-V converter.
By applying a bias current Ibias to the cell, we sense the
voltage on the bitline and then compare it to predeÔ¨Åned
reference voltage, and Ô¨Ånally output the readout value. Other
peripheral circuits are shared, such as row decoder, column
decoder, precharger etc.
We revised NVSim [5] to model both types of sense
ampliÔ¨Åers and estimate the area overhead. Each 2GB mem-
ory bank consists of 32 mats while each mat contains 16
subarrays. At
the area occupancy of
control logic and data array are shown in Table VII. The
overall area increment is 0.27%.
the subarray level,
ReadDuo maintains a scrub register to indicate the next
Table VII: Subarray level area analysis
Table IX: Energy Model of PCM per bit access
Component
Baseline[mm2]
(current sensing)
R+M-metric[mm2]
(hybrid sensing)
R-Read M-Read Write 01 Write 11 Write 10 Write 00
10pJ
1600pJ
100pJ
400pJ
30 pJ
50pJ
Cell Array
Row Decoder
Precharger
I-V converter
Bitline Mux & Dec
S/A Mux & Dec
Mode Control
S/A
Total
2.466
0.254
0.026
0.208
0.015
0.002
0.003
X
2.974
2.466
0.254
0.026
0.208
0.015
0.002
0.006
0.005
2.982
Table VIII: Baseline ConÔ¨Åguration
CPU 4-core single issue in-order CMP, 4GHz
L1
L2
private, I/D separate, 32KB per core, 64B line
private, 256KB per core, 4-way LRU, 64B line
write back
DRAM cache, private, 8MB per core, 8-way LRU
64B line, 50ns (200-cycle) hit
16GB, 8 banks, 32-entry write queue per bank
Main
L3
Memory R-Read: 150ns [3] ,M-Read: 450ns [1]
Write: 1000ns
memory line to be scrubbed. It increments after each scrub,
i.e., increments every (S / number of memory lines) sec-
onds. In addition, each memory line keeps (k+log2k) bits
to track its last write. These bits are stored as SLC in the
ECC chip, which do not suffer from resistance drift [2].
Accessing the Ô¨Çag bits is off the critical path and incurs
negligible performance overhead.
IV. EXPERIMENTAL METHODOLOGY
To evaluate the effectiveness of ReadDuo, we simulated
a system using 4-core in-order CPU and MLC PCM based
main memory. The baseline architectural conÔ¨Åguration fol-
lows
[26]. We generated memory accesses trace through
Pintool [13], and fed it to our in-house memory system
simulator, which models the entire memory hierarchy, the
memory controller and PCM based main memory. We
also considered timing constraints including cache-memory
related bus contention, memory bank conÔ¨Çicts and DDR
scheduling constraints. Write cancellation [18] was also im-
plemented so that read operations are given highest priority.
For the memory systems, the read latency is 150ns [3] for
fast R-metric sensing, and 450ns [1] for slow M-metric
sensing. MLC write latency is set as 1000ns [2] for the
iterative based write strategy. Scrubbing needs to read a
PCM line Ô¨Årst, scan for drift errors, and re-write a line if
errors were found. The detailed system conÔ¨Åguration is in
Table VIII. Table IX lists the energy consumed to read and
write MLC cells [31].
In our experiment, we simulated 14 workloads from
SPEC2006 benchmarks. We
listed their RPKI/WPKI
(read/write operations per thousand instructions) in Table X.
Table X: Simulated Workloads
astar
bzip2
gromacs
leslie3d
mcf
sjeng
wrf
RPKI WPKI
11.35
14.12
2.83
2.83
0.49
0.49
5.21
5.14
21.15
23.23
0.39
0.39
0.90
0.90
lbm
bwaves
gemsfdtd
RPKI WPKI
9.14
17.81
9.08
9.67
11.75
17.08
libquantum 13.53
7.55
13.08
21.22
3.36
3.97
4.23
4.08
milc
sphinx
zeusmp
V. RESULTS
We implemented and compared the following schemes in
the section.
‚Ä¢ Ideal. This is the setting that assumes no resistance
drift in MLC PCM. A MLC line can be readout using
R-metric sensing in 150ns.
‚Ä¢ Scrubbing. This scheme adopts efÔ¨Åcient scrubbing
with R-metric sensing. It uses (BCH=8, S=8s, W=1).
In practice, it needs to be enhanced with W=0 to meet
LERDRAM.
‚Ä¢ M-metric. This scheme adopts M-metric sensing
only. It uses (BCH=8, S=640s, W=1).
‚Ä¢ Hybrid. This scheme implements ReadDuo-Hybrid.
It uses (BCH=8, S=640s, W=0).
‚Ä¢ LWT-k. This scheme is built on top of Hybrid and
implements ReadDuo-Hybrid-k, which partitions 640s
to k sub-intervals, and convert R-M-Read to write for
untracked memory lines.
‚Ä¢ Select-(k:s). This scheme, in addition to LWT-k,
implements ReadDuo-Select-(k:s).
A. Performance Comparison
Figure 9 reports the normalized execution time using
different schemes. We normalized the results to Ideal.
Scrubbing and M-metric introduce 21% and 25% per-
formance degradation.
The overhead of Scrubbing comes mainly from busy
memory banks. Note here we use W=1 setting, which cannot
meet our target reliability requirement. If W=0 setting is
used, the memory suffers from more scrubbing operations,
and the execution time for that case is much longer, about
2-3x over ideal.
The overhead of M-metric comes mainly from slow
memory read operations. Since read operation is on the
critical path, the execution time is prolonged signiÔ¨Åcantly.
Hybrid reduces the scrubbing frequency and also en-
ables that most read operations can be fulÔ¨Ålled by fast R-
read. The 5.8% extra execution time compared with Ideal
211

L
H
P
7
Q
R
L
W
X
F
H
[
(


P
U
R
1







,GHDO
6FUXEELQJ 0PHWULF +\EULG
/:7
6HOHFW
DVW
EZD
E]L
JHP
JUR
OEP
PLO
Figure 9: Comparing execution time.
PFI
OHV
OLE
VMH
VSK
ZUI
]HX
*01
\
J
U
H
Q
(


P
U
R
1








,GHDO
6FUXEELQJ 0PHWULF +\EULG
/:7
6HOHFW
DVW
EZD
E]L
JHP
JUR
OEP
OHV
OLE
PFI
PLO
VMH
VSK
ZUI
]HX
*01
Figure 10: Comparing the energy consumption.
comes mainly from the scrubbing overhead with W=0 set-
ting. The energy overhead comes from W=0 setting is even
more signiÔ¨Åcant.
LWT-4 implements the last write tracking on a granularity
of 1/4 of 640s, i.e, 160s sub-interval tracking. With W=1
scrubbing setting, the scrubbing overhead is reduced. By im-
plementing the R-M-read conversion for untracked memory
lines, we also lower the probability of long latency R-M-
read. We further analyze the impact of each enhancement
in next section. The LWT-4 design can lower the extra
execution time to 2.9% over ideal.
At last, the energy optimization scheme Select-4:2
will slightly increase the performance overhead, because the
probability of R-M-read will slightly increase. The extra
execution time is 3.4% over ideal.
B. Dynamic Energy Comparison