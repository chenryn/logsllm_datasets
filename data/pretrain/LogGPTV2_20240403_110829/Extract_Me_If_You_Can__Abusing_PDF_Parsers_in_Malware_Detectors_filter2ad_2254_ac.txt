Processing Termination: The point at which Adobe Reader has
successfully completed all of its initial processing associated
with opening a PDF. Any automatically executing JavaScript
must have executed before this point, and all elements on the
page must be completely rendered.
Processing Error: Before completing its initial processing of
a PDF Adobe Reader has encountered an error causing it to
abort its processing. In this case, Adobe Reader will open an
alert describing to the user the error it has encountered.
into one of
Adobe Reader’s behavior will always fall
these two cases. Aside from producing useful
information
about the sample, Adobe Reader’s reaching of one of these
cases indicates when there is no more automatically executing
JavaScript to extract. By terminating the process whenever one
of these is reached cases is reached, we can expediently process
samples.
We deﬁne the processing termination and processing error
tap points to simply be the program counters of instructions,
which when executed, indicate that Adobe Reader has reached
each of these states. In practice, we found that the program
counter alone was sufﬁcient to identify these points but calling
context can be added if needed.
Execution Trace. The identiﬁcation of the the processing
termination and processing error tap points is performed by
analyzing only the instructions executed by Adobe Reader.
Since only the execution of these tap points is used to reveal
information about the program’s state, this analysis can be
simpliﬁed by performing it on the basic blocks executed,
without loss of generality. The traces produced are thus lists
containing the addresses of the ﬁrst instruction of every basic
block executed.
In particular, sets of these traces, ETJS, ETW F and
ETM F , were collected for well-formed PDFs with JavaScript,
well-formed PDFs without JavaScript, and malformed PDFs
(i.e. those which cause Adobe Reader to produce an error),
respectively. More concretely, ETJS consists of traces col-
lected from the samples used to generate the memory traces
as well as additional malicious PDFs which were manually
identiﬁed as containing JavaScript. The traces in ETW F were
obtained from benign samples which were manually veriﬁed
to not contain JavaScript. Lastly, ETM F contains traces for
malformed samples both with and without JavaScript, and for
ﬁles which are of different formats entirely, such as PE and
DOCX.
Each trace in ETJS and ETW F was collected until Adobe
Reader had appeared to ﬁnish its initial processing of a sample,
while traces in ETM F were collected until Adobe Reader
raised the alert indicating it could not open the ﬁle.
Processing Termination. A basic block selected for the pro-
cessing termination tap point must meet three requirements:
1) the basic block is always executed once and only once
when processing well-formed PDFs; 2) it is never executed
by Adobe Reader when processing malformed PDFs; 3) it is
only executed after the JavaScript extraction tap point if the
PDF contains JavaScript.
to
compute
a
1, we
requirement
According
set
BBW F U nique which contains basic blocks common to
traces in ETW F that appear only once in each trace.
all
Based on requirement 2, we need to then exclude from
BBW F U nique all
the basic blocks executed in any trace
in ETM F . We collect these basic blocks in a set BBM F
and then exclude it: (BBW F U nique − BBM F ). Due to
requirement 3, we have to ﬁrst ﬁnd the set BBJST runc that
holds all basic blocks executed in any trace in ETJS after the
JavaScript extraction tap point is reached, and then compute
the intersection as the set of potential processing termination
tap points:(BBW F U nique − BBM F ) ∩ BBJST runc. Any of
the basic blocks in this set can be selected as the processing
termination tap point.
Processing Error. A basic block associated with the pro-
cessing error tap point must meet two requirements: 1) the
basic block is always executed once and only once when
processing malformed PDFs; 2) it is never executed by Adobe
Reader when processing well-formed PDFs. To meet these
two requirements, we compute three intermediate sets of basic
blocks. Speciﬁcally, we ﬁrst compute a set BBM F U nique that
contains all basic blocks, common to all traces in ETM F ,
which appear only once in each of these traces. Then we
exclude all basic blocks that are executed for well-formed
PDFs, both with and without JavaScript. To this end, we
collect two sets BBJS and BBW F , which represent all basic
blocks in the sets ETJS and ETM F , respectively. Thus, the
set of potential processing error tap points is computed as
BBM F U nique − (BBJS ∪ BBW F ). Again, any of the basic
blocks in this set can be used as the processing error tap point.
E. Tap Point Action
Once the tap points have been identiﬁed, Adobe Reader
needs to be modiﬁed so as to log the JavaScript produced
at the JavaScript extraction tap point and to terminate when
the processing termination and processing error tap points are
reached. If the tap point deﬁnition includes calling context,
these modiﬁcations also need to determine at runtime if
their current execution matches that context, otherwise the
program’s behavior should not be altered. By checking the
existence of the log ﬁle and examining the process’ exit code,
which is speciﬁc to each tap point, it is easy to programmat-
ically determine which tap points were reached and if any
JavaScript was extracted.
7
It is often the case that multiple JavaScript statements are
executed automatically during the initial processing of a ﬁle.
Usually we expect to catch all of them, and thus, Adobe Reader
is allowed to run until it reaches either the processing error
or the processing termination tap point. However, to handle
unexpected cases, we set a timeout every time the JavaScript
extraction tap point is reached. This conﬁgurable timeout limits
the amount of time Adobe Reader spends processing a speciﬁc
JavaScript statement by terminating the process if the time
limit is reached. A timeout of one second was chosen for our
evaluation to allow sufﬁcient time for execution while allowing
us to process a large number of samples.
We choose to perform hot patching instead of dynamic
instrumentation (e.g., Pin [27]) due to performance concerns.
The Microsoft Detours library [21] was selected to modify
the binary primarily because of its simplicity and ease of use,
but a small amount of manual effort is required to interface
this library with the tap points. In the case of the JavaScript
extraction tap point, this amounts to identifying the calling
convention and arguments of the target function. For the
processing error and processing termination tap points we do
not need to be concerned with this analysis since they cause the
process to terminate immediately. Note that Adobe Reader’s
sandbox mechanism which prevents the process which pro-
cesses PDFs from performing certain actions, such as ﬁle
creation, must ﬁrst be disabled.
IV. DIFFERENTIAL ANALYSIS
A. Experiment Setup
To evaluate the effectiveness of the reference JavaScript
extractor and to identify the limitations of existing extractors,
we produced two different extractors based on Adobe Reader
versions 9.5.0 and 11.0.08, and then compared them against
each other and several other open source tools which provide
similar functionality. The libpdfjs [7] tool is the JavaScript
extractor which utilizes the Poppler PDF rendering library and
powers the PJScan malicious PDF detector. Origami [8] is a
framework for PDF parsing, analysis, and creation which is
packaged with a JavaScript extraction tool using this frame-
work. The JavaScript unpacking tool jsunpack-n [6] attempts
to extract and analyze JavaScript from many formats, but
contains a module which speciﬁcally extracts JavaScript from
PDFs. Lastly, the PDFiD tool is not a JavaScript extractor but
merely scans a document for the appearance of certain key-
words. VirusTotal uses this tool to tag samples as containing
JavaScript or not [36], among other things, and the results
included here for this tool are those reported by VirusTotal.
All of these tools were run against a set of 163,306 PDF
ﬁles procured from VirusTotal over the month of February,
2015. Every tool evaluated was given twenty seconds to
process each sample before the tool was considered to timeout
and terminated. The Origami and jsunpack-n tools were run
on a machine with 6GB of RAM and a 2.93GHz CPU running
Ubuntu 14.04.
The most recent operating system supported by the libpdfjs
tool is Ubuntu 11.04, and so it was run in a virtual machine
running this version. The Adobe Reader tool must also be run
inside of a Windows virtual machine, which was running XP
service pack 3 speciﬁcally. Both of these virtual machines were
TABLE II: JavaScript Extractions
Total
Matches
Invalid (ben./mal.)
Zero (ben./mal.)
Inconclusive
Reference
Extractor
4397
-
-
-
-
libpdfjs
Version 9.5.0
jsunpack-n Origami
PDFiD
5053
4247
26 (10/16)
4625
3940
7 (7/0)
450 (20/430) 124 (113/11) 511 (76/435) 676 (253/423)
356
4508
3863
23 (0/23)
4398
3721
-
500
318
677
Reference
Extractor
4704
-
-
-
-
libpdfjs
Version 11.0.08
jsunpack-n Origami
PDFiD
5053
4537
16 (0/16)
4625
4269
0 (0/0)
435 (6/429) 151 (140/11) 514 (80/434) 800 (377/423)
356
4508
4167
23 (0/23)
4398
3904
-
500
318
494
Since the Adobe Reader
run on the same bare metal machine as the other extractors and
were each given 4GB of RAM. Though this is slightly less
than given the other tools, in practice, memory usage does not
appear to be a limitation for any of the extraction tools.
tool actually executes
the
JavaScript extracted from a sample, we must be careful to
prevent any potential exploit of Adobe Reader from having an
impact on the processing of future samples. In order to prevent
this, a snapshot of the virtual machine in a clean state was
taken and then restored before processing each new sample. A
list of hashes corresponding to certain sections of the results
can be found at https://goo.gl/qtbuOC with descriptions for
each.
B. Summarized Results
The total number of samples for which each tool extracts at
least one JavaScript item and the comparison of their results
against each reference extractor is listed in Table II. Notice
that in the case of PDFiD, the number of samples it identi-
ﬁes as containing JavaScript are listed. Combined, the open-
source extractors we evaluated produced JavaScript for 5250
unique samples. Our version 9.5.0 reference extractor produces
JavaScript from 4397 samples of which 2956 are benign and
1441 are malicious, and our version 11.0.08 reference extractor
produces JavaScript from 4704 samples, of which 3261 are
benign and 1443 are malicious, when considering samples with
at least 15 detections on VirusTotal as malicious. In total, all
of the extractors produced JavaScript for 5267 unique samples.
Table III shows the comparison between the two different
reference extractors. The ﬁles that each extractor could produce
JavaScript for are largely similar and all of the extractions
produced matched the similarity metric described below. Of
the extractions unique to a speciﬁc reference extractor, all but
two were benign, which were only produced by the version
11.0.08 extractor. Both of these samples are malformed in
ways which allow for multiple interpretations, and it appears
that the different versions of Adobe Reader select different
ones. The large number of extractions unique to the version
11.0.08 extractor are largely caused by samples using features
not supported by the older version of Adobe Reader and the
extractions unique to the 9.5.0 extractor are largely caused by
samples using features which are now deprecated.
It is extremely difﬁcult to verify the correctness of these
extractions due to the lack of ground truth. Therefore, we
instead attempt to identify which extractions produce at least a
partial match against the JavaScript discovered by the reference
extractor. Even though we assume the JavaScript produced by
our reference extractor is correct, it extracts only the JavaScript
code that is automatically executed upon opening a PDF, which
is possibly only a subset of the JavaScript in the document.
8
Since the other extractors attempt to produce all JavaScript
embedded in the document,
the JavaScript produced by a
reference extractor should match at least some of the JavaScript
produced by the other extractors. If such a partial match is
found for a PDF sample, we call it a “match”. If an extractor
produces nothing for a sample from which an extraction is pro-
duced by our reference extractor, we refer to this as a “zero”. If
an extractor produces an extraction which does not match the
extraction of our tool at all, and which is manually veriﬁed to
be invalid, this is considered as an “invalid extraction”. Since
PDFiD only does not actually extract JavaScript, the notion of
an invalid extraction does not apply to this tool.
To be safe, we do not reason about the validity of extrac-
tions produced for samples for which the reference extractor
produced nothing. As a result, the amount of invalid extractions
presented represents only the lower bound. We call
these
instances “inconclusive”.
To identify matched extractions, we ﬁrst look for a sub-
string match. Since different extractors produce extractions
with slight variations in whitespace, such as different end-of-
line sequences, and the existing extraction tools often have
trouble handling non-ASCII encodable characters, we do not
consider them in this search. If a substring match cannot be
found, we then use the Python difﬂib [4] library to efﬁciently
compute a similarity heuristic between the extractions. If an
extraction appears to have a least 50% in common with the
one produced by the our tool, it is considered a match.
While in majority of the samples, the JavaScript produced
by the existing extractors match that of our tool, the results
do reveal that prior extractors miss JavaScript extractions for
a signiﬁcant amount of PDF documents. On average these
extractors miss JavaScript code in 10.1% of the ﬁles and
PDFiD cannot detect the existence of JavaScript in 17.01% of
the samples when compared to the version 11.0.08 reference
extractor. The situation is even more severe for malicious
PDFs. On average, each existing extractor fails to extract
JavaScript from 22.47% of the malicious samples identiﬁed
as containing JavaScript by the reference extractor.
Note that the samples in the “invalid” and “zero” categories
for each of the extractors are broken down into benign and
malicious categories, as identiﬁed by the detectors from Virus-
Total. Many of the malicious samples analyzed from these cat-