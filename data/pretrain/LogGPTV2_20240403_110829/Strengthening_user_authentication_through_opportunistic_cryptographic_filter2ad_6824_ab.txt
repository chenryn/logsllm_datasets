### Optimized Text

**Password and Secret Questions**: Following this nomenclature, opportunistic PhoneAuth attempts to perform a protected login. If the identity assertion is not available, it reverts to an unprotected login.

**First Logins and Subsequent Protection**: The work by Czeskis et al. demonstrates that only the first login from a new device requires special protection via a second-factor device. Subsequent logins can be protected using channel-bound cookies set during the initial login. This observation highlights the usability of our scheme: users need only type their username and password, and (assuming a wireless connection between the browser and phone) bring their phone into proximity with the browser for the first login.

**TLS Channel IDs**: The security of PhoneAuth relies on the concept of TLS origin-bound certificates (OBCs), recently introduced in [13]. TLS-OBC is currently an experimental feature in Google's Chrome browser and is under consideration by the IETF as a TLS extension.

OBCs are TLS client certificates created by the browser on-the-fly without user interaction and used during the TLS handshake to authenticate the client. OBCs do not carry any user-identifying information and are not directly used for authentication. Instead, they create a TLS "channel" that persists through TLS session resets. An HTTP cookie can be bound to this TLS channel by including a TLS channel ID (a hash of the clientâ€™s OBC) in the cookie data. If the cookie is sent over a TLS channel with a different channel ID, the cookie is considered invalid.

**PhoneAuth Mechanism**: At the core of PhoneAuth, the server and browser communicate their view of the TLS channel to the user's phone. The server uses the login ticket to convey its view of the TLS channel ID to the phone, while the browser communicates the TLS channel ID directly. If a man-in-the-middle attack is present, these two TLS channel IDs will differ, causing a login failure in strict mode and an unprotected login in opportunistic mode. The phone can alert the user or send a message to the server if a cellular connection is available.

**Protocol Details**: During the protocol, we address risks such as credential reuse, protocol rollback attacks, TLS man-in-the-middle attacks, and phishing. In step 2, the user's entered username and password are sent to the server, which verifies the credentials and generates a login ticket. The login ticket includes a TLS channel ID, web origin, expiration time, whether TLS-OBC was used, the user account, and an origin protection key. The ticket is encrypted and signed using keys derived from a per-account master secret known only to the server and the user's phone.

The server sends the login ticket along with a `certauth id` to the browser. The browser then generates an assertion request, which includes the login ticket and metadata about the TLS session. This data is encrypted and authenticated using the origin protection key. The browser sends the assertion request to the user's phone, which validates the request and generates an identity assertion. The phone sends the identity assertion back to the browser, which forwards it to the webapp. The webapp validates the assertion and issues a channel-bound cookie, completing the protected login.

**Additional Security Discussion**: By including the TLS channel ID in the login ticket, the server binds the ticket to the TLS channel. The end-to-end encryption of the login ticket prevents undetectable modifications. The phone compares the TLS channel IDs from the browser and the login ticket to detect man-in-the-middle attacks. The metadata provided by the browser is encrypted and authenticated, ensuring integrity.

**Enrollment**: Before use, the user's phone must be enrolled with the server. The phone registers its public key and identifies the user(s) it will vouch for. The phone and server also agree on a master encryption key. Enrollment is a one-time process per website and phone.

**Practical Maintenance Operations**: Users can add more phones, but we suggest limiting enrollment to one phone for consistency. Replacing a phone is straightforward if the user has an active login session. The user can scan a QR code with their new phone to prove the valid session. Alternatively, a special SMS can be sent to the new phone.

**Browser and Phone Communication**: Our system uses Bluetooth for communication between the PC and phone. We modify the browser and leverage a seldom-used Bluetooth feature to bypass the discovery phase. The PC obtains the phone's Bluetooth MAC address from the server, allowing immediate communication. We use unauthenticated RFCOMM connections, but the data is end-to-end authenticated and encrypted at the application level.

**Implementation Details**: We extended the Chromium web browser to provide a JavaScript API for fetching identity assertions. The API is modeled after the BrowserID proposal and consists of three parameters: a `certauth id`, a login ticket, and a callback function. The mobile phone uses the modified Android version of the Google Authenticator app to provide identity assertions. The server-side implementation is service-oriented, with three RPCs: `RegisterDevice`, `GenerateTickets`, and `VerifyTicket`.

**Evaluation**: Using Bonneau et al.'s framework, we evaluate PhoneAuth in both strict and opportunistic modes. Both modes provide similar usability benefits to passwords and 2SV, with the strict mode requiring the phone for authentication. Opportunistic mode allows for fallback to password authentication. PhoneAuth excels in security, providing strong protection against phishing, unthrottled guessing, and physical observation. The performance impact is minimal, with the main issue being the Bluetooth communication latency.

**Conclusion**: PhoneAuth offers a robust and user-friendly solution for secure logins, outperforming traditional passwords and 2SV in many aspects.