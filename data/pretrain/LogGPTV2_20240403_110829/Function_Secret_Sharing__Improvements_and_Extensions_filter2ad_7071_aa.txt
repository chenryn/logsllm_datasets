title:Function Secret Sharing: Improvements and Extensions
author:Elette Boyle and
Niv Gilboa and
Yuval Ishai
Function Secret Sharing: Improvements and Extensions
Elette Boyle
IDC Herzliya, Israel
PI:EMAIL
Niv Gilboa
Ben Gurion University, Israel
PI:EMAIL
Yuval Ishai
Technion and UCLA
PI:EMAIL
ABSTRACT
Function Secret Sharing (FSS), introduced by Boyle et al.
(Eurocrypt 2015), provides a way for additively secret-sharing
a function from a given function family F. More concretely,
an m-party FSS scheme splits a function f : {0, 1}n → G, for
some abelian group G, into functions f1, . . . , fm, described
by keys k1, . . . , km, such that f = f1 + . . . + fm and every
strict subset of the keys hides f . A Distributed Point Func-
tion (DPF) is a special case where F is the family of point
functions, namely functions fα,β that evaluate to β on the
input α and to 0 on all other inputs.
FSS schemes are useful for applications that involve pri-
vately reading from or writing to distributed databases while
minimizing the amount of communication. These include
diﬀerent ﬂavors of private information retrieval (PIR), as
well as a recent application of DPF for large-scale anony-
mous messaging.
We improve and extend previous results in several ways:
• Simpliﬁed FSS constructions. We introduce a ten-
soring operation for FSS which is used to obtain a con-
ceptually simpler derivation of previous constructions
and present our new constructions.
• Improved 2-party DPF. We reduce the key size of
the PRG-based DPF scheme of Boyle et al. roughly
by a factor of 4 and optimize its computational cost.
The optimized DPF signiﬁcantly improves the concrete
costs of 2-server PIR and related primitives.
• FSS for new function families. We present an ef-
ﬁcient PRG-based 2-party FSS scheme for the family
of decision trees, leaking only the topology of the tree
and the internal node labels. We apply this towards
FSS for multi-dimensional intervals. We also present
a general technique for extending FSS schemes by in-
creasing the number of parties.
1 , . . . , k∗
• Veriﬁable FSS. We present eﬃcient protocols for ver-
ifying that keys (k∗
m), obtained from a poten-
tially malicious user, are consistent with some f ∈ F.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’16, October 24 - 28, 2016, Vienna, Austria
c(cid:13) 2016 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ISBN 978-1-4503-4139-4/16/10. . . $15.00
DOI: http://dx.doi.org/10.1145/2976749.2978429
Such a veriﬁcation may be critical for applications that
involve private writing or voting by many users.
Keywords: Function secret sharing, private information
retrieval, secure multiparty computation, homomorphic en-
cryption
1.
INTRODUCTION
In this work we continue the study of Function Secret
Sharing (FSS), a primitive that was recently introduced by
Boyle et al. [7] and motivated by applications that involve
private access to large distributed data.
Let F be a family of functions f : {0, 1}n → G, where G is
an abelian group. An m-party FSS scheme for F provides a
means for “additively secret-sharing” functions from F. Such
a scheme is deﬁned by a pair of algorithms (Gen, Eval). Given
a security parameter and a description of a function f ∈ F ,
the algorithm Gen outputs an m-tuple of keys (k1, . . . , km),
where each key ki deﬁnes the function fi(x) = Eval(i, ki, x).
The correctness requirement is that the functions fi add up
to f , where addition is in G; that is, for any input x ∈ {0, 1}n
we have that f (x) = f1(x) + . . . + fm(x). The security re-
quirement is that every strict subset of the keys computa-
tionally hides f . A naive FSS scheme can be obtained by
additively sharing the entire truth-table of f . The main
challenge is to obtain a much more eﬃcient solution, ideally
polynomial or even linear in the description size of f .
The simplest nontrivial special case of FSS is a Distributed
Point Function (DPF), introduced by Gilboa and Ishai [18].
A DPF is an FSS for the family of point functions, namely
functions fα,β : {0, 1}n → G for α ∈ {0, 1}n and β ∈ G,
where the point function fα,β evaluates to β on input α and
to 0 on all other inputs. Eﬃcient constructions of 2-party
DPF schemes from any pseudorandom generator (PRG),
or equivalently a one-way function (OWF), were presented
in [18, 7]. This was extended in [7] to more general func-
tion families, including the family of interval functions f[a,b]
that evaluate to 1 on all inputs x in the interval [a, b] and
to 0 on all other inputs. For m ≥ 3, the best known PRG-
the naive solution, with key size ≈ √
based DPF construction is only quadratically better than
N , where N = 2n [7].
We consider here the case m = 2 by default.
On the high end, polynomial-time FSS schemes for ar-
bitrary polynomial time functions are implied by indistin-
guishability obfuscation [7] and by variants of fully homo-
morphic encryption [7, 14]. In the present work we mainly
consider PRG-based FSS schemes, which have far better
concrete eﬃciency and are powerful enough for the appli-
cations we describe next.
1292FSS schemes are motivated by two types of applications:
ones that involve privately reading from a database held by
m servers, and ones that involve privately writing (or incre-
menting) an array which is secret-shared among m servers.
In both cases, FSS can be used to minimize the communi-
cation complexity. We illustrate two concrete application
scenarios below and refer the reader to Appendix A for a
more detailed exposition.
For a typical “reading” application, consider the problem
of 2-server Private Information Retrieval (PIR) [10, 8]. In
the basic ﬂavor of PIR, the two servers hold a database of
N strings (x1, . . . , xN ), and a client wishes to retrieve xα
without revealing α to either of the two servers. PIR in this
setting can be implemented by having the client distribute
the point function fα,1 : [N ] → Z2 between the servers.
Concretely, the client generates a pair of keys (k1, k2) which
deﬁne additive shares f1, f2 of fα,1, and sends each key to
a diﬀerent server. On input ki, server i sends back the sum
j=1 xjfi(j), where each xj is viewed as an element in Z(cid:96)
2.
The client can recover xα by taking the exclusive-or of the
two (cid:96)-bit strings it receives.
(cid:80)N
Still relying only on a standard DPF, this can be directly
generalized to private search by keywords (returning the
payload associated with a private (cid:96)-bit keyword), private
search on streaming data [27, 15, 7], and more. FSS for in-
terval functions can be used to privately search values in a
secret range. Realizing similar private search functionalities
using standard PIR protocols requires the use of suitable
data structures, which incur a signiﬁcant additional over-
head in round complexity, storage, and cost of updates [9].
In general, FSS for a function family F can be used to eﬃ-
ciently perform searches deﬁned by predicates from F.
For a typical “writing” application, consider the following
example from [7]. Suppose that we want to collect statis-
tics on web usage of mobile devices without compromising
the privacy of individual users, and while allowing fast col-
lection of real-time traﬃc data for individual web sites. A
DPF provides the following solution. An array of counters
is additively shared between 2 servers. A client who visits
URL α can now secret-share the point function f = fα,1
over a suﬃciently large group G = ZM and each server i
updates its shared entry of each URL αj by locally adding
fi(αj) to its current share of αj. Note that the set of URLs
αj used to index entries of the array does not need to in-
clude the actual URL α visited by the client, and in fact
it can include only a selected watchlist of URLs which is
unknown to the client. A diﬀerent “writing” application for
DPF was proposed in the context the Riposte system for
anonymous messaging [11]. In this system, messages from
diﬀerent clients are mixed by having each client privately
write the message to a random entry in a distributed array.
1.1 Our Contribution
Motivated by applications of FSS, we continue the study
of eﬃcient constructions that can be based on any PRG.
We improve and extend previous results from [7] in several
directions.
Simplified FSS constructions. We introduce a concep-
tually simple “tensoring” operation for FSS, which we use
both to rederive previous constructions and obtain some of
the new constructions we describe next.
Improved 2-party DPF. We reduce the key size of the
PRG-based DPF scheme of Boyle et al. roughly by a factor of
4 and optimize its computational cost. In an AES-based im-
plementation, the key size of a DPF is equivalent to roughly
a single AES key per input bit. We provide further opti-
mizations for the case of DPF with a single-bit output and
for reducing the computational cost of evaluating the DPF
of the entire domain (as needed, for instance, in the PIR ap-
plication described above). The optimized DPF can be used
to implement 2-server PIR protocols in which the communi-
cation overhead is extremely small (e.g., roughly 2.5K bits
are sent to each server for retrieving from a database with
225 records) and the computation cost on the server side is
typically dominated by the cost of computing the XOR of
half the data items. More concretely, the additional com-
putational cost of expanding the DPF key for an N -record
database consists of roughly N/64 AES operations. In the
case of private keyword search, retrieving the payload associ-
ated with an 80-bit keyword requires sending less than 10K
bits. See Table 1 for more details on the concrete eﬃciency
of our DPF construction and Appendix B for more details
on the PIR application and a comparison with alternative
approaches from the literature.
FSS for new function families. We present an eﬃcient
PRG-based 2-party FSS scheme for the family of decision
trees, leaking only the topology of the tree (i.e., the shape
of the graph) and the internal node labels (i.e., which input
variable labels each node). Our construction hides the la-
bels of edges and leaves. We apply this towards PRG-based
FSS for multi-dimensional intervals, e.g., capturing conjunc-
tion queries or search restricted to a geographical region.
We also present a general technique for extending the ex-
pressive power of FSS schemes by increasing the number of
parties. Concretely, we show how to obtain FSS schemes
for the family of all products of pairs of functions from two
given families that are realized by FSS. This can be applied
towards more eﬃcient solutions for multi-dimensional inter-
vals, though with a larger number of parties.
Verifiable FSS. In both types of applications of FSS dis-
cussed above, badly formed FSS keys can enable a malicious
client to gain an unfair advantage. The eﬀect of malicious
clients can be particularly devastating in the case of “writ-
ing” applications, where a single badly formed set of keys
can corrupt the entire data. We present eﬃcient protocols
for verifying that keys (k∗
m) are consistent with some
f ∈ F. Our techniques make black-box use of the under-
lying FSS scheme, and avoid the cost of general-purpose
secure computation techniques. Our veriﬁcation protocols
make a novel use of sublinear veriﬁcation techniques (in-
cluding special-purpose linear sketching schemes and linear
PCPs) and combine them with MPC protocols that exploit
correlated randomness from an untrusted client for better
eﬃciency. These techniques may be applicable beyond the
context of veriﬁable FSS.
Organization. Useful deﬁnitions appear in Section 2. Sev-
eral FSS constructions, including the tensor product gen-
eralization, optimized DPF and evaluating a DPF on the
entire domain are presented in Section 3. Deﬁnitions and
protocols for veriﬁable FSS are the focus of Section 4. The
appendix discusses applications of FSS and concrete perfor-
mance for one speciﬁc application – two-server PIR. Due to
lack of space, the proofs of claims in this work and additional
material are postponed to the full version of the paper.
1 , . . . , k∗
12932. PRELIMINARIES
We extend the deﬁnition of function secret sharing from [7]
by allowing a general speciﬁcation of the allowable leakage,
namely the partial information about the function that can
be revealed.
A function family is deﬁned by a pair F = (PF , EF ),
where PF ⊆ {0, 1}∗ is an inﬁnite collection of function de-
scriptions ˆf , and EF : PF×{0, 1}∗ → {0, 1}∗ is a polynomial-
time algorithm deﬁning the function described by ˆf . Con-
cretely, each ˆf ∈ PF describes a corresponding function
f : Df → Rf deﬁned by f (x) = EF ( ˆf , x). We assume
by default that Df = {0, 1}n for a positive integer n and al-
ways require Rf to be a ﬁnite Abelian group, denoted by G.
When there is no risk of confusion, we will sometimes write
f instead of ˆf and f ∈ F instead of ˆf ∈ PF . We assume
that ˆf includes an explicit description of both Df and Rf
as well as a size parameter Sf .
We let Leak( ˆf ) capture partial information about ˆf that
can be leaked. When Leak is omitted it is understood to
output Df and Rf . (This will be suﬃcient for most classes
considered in this work; for more general classes, one also
needs to leak the size Sf .)