use it to program the PMC counters to retrieve samples for the
BR_MISP_EXEC.TAKEN_INDIRECT_JUMP_NON_CALL_RET event, which is
triggered every time the target of a taken indirect jump is mispre-
dicted. PMC counters are sampled at the start of every loop and
once more at their end. BTI is successful whenever the difference
in the value of the counter is 1, given that the victim code contains
only one indirect jump.
The timed instruction sequence in the attacker consists of a
series of 42 crc32 instructions operating over randomly chosen,
nonzero values. The victim process contains an equivalent sequence
of crc32 instructions at the fall-through of the branch: given that
crc32 instructions execute exclusively on port 1, if BTI is successful
and the speculated conditional branch is not taken, the victim will
be competing for execution on port 1 with the attacker. The target of
the branch instead contains a sequence of instruction designed to be
executable on more ports (0,1,5,6) and thus display less contention
with the attacker.
We collect two sets of samples: one when the victim’s secret is set
to zero, and one where it is set to a nonzero value. Figure 4 shows
the results of the experiment on a Skylake platform (i7-6700K). As
we can see, the distributions obtained when the victim has a non-
zero secret generates more contention on port 1 and thus causes
the attacker to measure a higher time-stamp counter difference.
This is justified by the fact that a nonzero secret causes speculative
execution to be directed to the fall-through of the branch, which
we have designed with a competing sequence crc32 instructions.
In the next phase of the attack, we use the results of this ex-
periment as profiling information to read the side channel. To this
end, a bit sequence is generated and set - bit by bit - as the secret
value on the victim. Based on the results of Figure 4 we choose
a time-stamp counter difference of 89 as a threshold: if the mean
of the samples is higher than the threshold we conclude that the
secret is 1, and 0 otherwise. The experiment is run, 5 samples each
Figure 4: Probability density function (estimated using kernel den-
sity estimation) for the timing information of an attacker measur-
ing crc32 operations when running concurrently with a victim spec-
ulatively executing a SMoTher-gadget.
glibc
ssl
pthread
ld
crypto
rax
rbx
rcx
rdx
rsi
rdi
rsp
rbp
14
6
8
10
8
8
2
5
12
2
1
2
4
2
0
3
9
0
2
5
1
0
0
0
7
1
1
6
2
2
0
0
11
6
5
7
3
3
0
9
z
8
1
1
2
1
1
0
0
stdc++
Together
8
1
2
3
1
0
2
0
21
9
8
14
10
11
3
13
Table 2: Number of different leakable register bits (out of 64) us-
ing SMoTher gadgets from common system libraries, specifically
test-jxx one at a time, on multiple iterations of the victim with the
same register state.
are collected for 20, 000 secret bits. The attacker is able to correctly
guess the victim’s secret with a success rate of over 98%. The entire
experiment takes 0.83s as reported by time yeilding a sample rate
of 120,000 samples/second, and a leakage rate of 24, 000bit/s. A sim-
ilar experiment with guesses based on 1, 2, 3 and 4 samples result
in accuracies of 72%, 78%, 83%, and 90% respectively. As expected,
there is a trade-off between accuracy and leakage rate.
We repeated this experiment on a Haswell processor (i7-4790)
using the same attacker-timed sequence and victim’s SMoTher-
gadget. With a threshold of 85 cycles, the attacker was able to guess
the victim’s secret bit with an accuracy of 53%, 62%, 69%, 70% and
76% based on 1, 2, 3, 4 and 5 samples respectively. We also validated
the attack on a Broadwell processor (i3-5005u).
4.4 Discussion about SMoTher-gadgets
A SMoTher gadget is defined by two attributes: the condition on
which the jump depends and the sequences on both paths following
the jump. The latter determines whether the gadget can be used
in a SMoTherSpectre attack: the sequences must be SMoTher-
differentiable. The former determines the information leaked by
the gadget. In this section, we shall discuss some of the SMoTher-
gadgets found in real libraries, and what they can leak.
Common instructions which set the condition flags in SMoTher-
gadgets we found are cmp, test, add, sub. cmp-jxx sequences com-
pare a value in a register (or loaded from memory) against other
registers or against a constant. Each gadget reveals a constraint
on the value. test-jxx and and-jxx sequences perform a bitwise-
and of two values, setting flags based on the result. When one of
the values is a constant with a single bit set, the gadget can be
used to test whether specific bits are set in the first operand. Such
gadgets reveal the corresponding bits to the attacker. When the
second operand is not a constant, but a register whose value may
be predicted or controlled, the attacker gains the power to check
bits other than those specified by the constant gadgets.
Of the over 12,000 gadgets found in libcrypto, approximately:
• 2,800 are cmp operations
• 3,900 are test operations
• 1,500 are add operations
• 970 are or operations
There are around 350 cmp-jump gadgets which compare a value
in a register or in memory against zero. Around a 100 gadgets, which
check for greater-than/lesser-than conditions against zero, can be
used to leak whether the value is positive or negative. Another
294 gadgets compare against (the constant) one, and 807 gadgets
compare against other constants. Around 370 cmp-jump gadgets
have a memory operand of which 118 compare with non-zero con-
stants. 300+ gadgets compare with values on the stack, of which
33 are against non-zero constants. Of all cmp-jump gadgets, more
than 400 check for signed or unsigned greater-than. The number
of signed or unsigned lesser-than is about the same.
For victims running in a loop, there are cases where the regis-
ter/memory state of interest will be the same across iterations. For
example, a register/memory location storing a secret, cryptographic
key can be expected to hold the same value across multiple calls to
the encryption function. The attacker can leverage the BTI gadget
to redirect the victim to different SMoTher-gadgets on different
iterations, each time leaking different information about the secret.
Over multiple iterations, the attacker can effectively leak multiple
bits of the same secret, chaining the leaks from different SMoTher-
gadgets. In Table 2, we show how many bits we can leak from the
registers by chaining SMoTher-gadgets found in commonly used
system libraries. To illustrate this for one specific register, Appen-
dix A lists the gadgets which can be chained to leak 21 bits from
rax.
combinations of instruction sequences based on their difference in
port utilization.
BTI Gadget. The purpose of the BTI gadget is to pass the secret
through a register to an arbitrary code target in the same process.
Depending on the attack scenario, the BTI gadget is the only piece
of code that is strictly required to be present in the victim. Ideally,
it just consists of two instructions: one that moves the secret into
a register and an indirect control-flow transfer. In order to maxi-
mize the speculative execution window, the target of the indirect
control-flow transfer should be retrieved from uncached memory.
An archetype of an ideal BTI gadget is a virtual function call in C++,
with the secret value being an argument to such a function call. In
the System V x86_64 calling convention, the first six parameters of a
function are passed in registers. Further, the typical implementation
of a virtual function call uses indirection through a vtable to resolve
the binding at runtime. Since the vtable is stored in memory, the
target of the call needs to be loaded, which can cause a speculation
window of upto a few hundred (~200) cycles if the vtable has been
evicted from the cache prior to the call. We can reasonably assume
that this will happen in practice if objects are created by an early
initialisation phase and used (potentially much) later in response to
external events. Similarly, calls to functions in dynamically-loaded
ELF (Executable and Linkable Format) libraries also employ an in-
direct jump, using a pointer from the Global Offset Table (GOT)
to facilitate dynamic symbol resolution. Arguments in such calls
may contain sensitive information which can be compromised by
an attacker using these jumps as BTI gadgets.
SMoTher Gadget. A SMoTher gadget is the receiving end of
a BTI gadget. Depending on the attack scenario, it is either already
part of the victim, or can be supplied via an additional attack vector.
It starts with an instruction that compares the register to a known
value. The known value can either be a known immediate in the
code, or, more powerfully, an attacker-controlled value specified
via an additional attack vector. The next instruction needs to be a
conditional control flow transfer based on this comparison leading
to SMoTher-differentiable sequences. To maximize the chances
of SMoTher-differentiability, the instruction sequences should
each have a distinct port fingerprint such that they can be clearly
distinguished from one another. This depends on the layout of the
execution engine: on Intel Skylake, a prime example would be one
branch with a sequence of AES instructions (only port 0) and another
branch with a sequence of MMX instructions, predominantly limited
to port five. Besides, the instructions should ideally not load from or
store to memory, as potential cache misses introduce noise. Further,
the more generic the instructions in the sequence are, the more
likely it is that their execution unit does not require a warm-up
phase during which execution is slow, again introducing noise.
5 GADGET DISCOVERY
As described in Section 4.2, we require two gadgets to be present
in the victim code for SMoTherSpectre. We investigate the char-
acteristics of ideal gadgets and how to find them in a given piece
of code. We introduce port fingerprinting to summarize the port
utilization of an instruction sequence and assess the potential to be
detected using SMoTher. Port fingerprinting enables a compari-
son of the port utilization of two instruction sequences and rank
5.1 Ranking SMoTher-gadgets
The instruction sequences we consider consist of basic blocks that
start at the respective branch targets. To identify instruction se-
quences that are ideal for SMoTher and compare them against one
another, we need to measure their suitability for SMoTher. The
primary criterion is that the compare instruction operand has to
match the register that is loaded with the secret in the BTI gadget.
Further, we evaluate the instruction sequence at the branch target
combine them using the rank product RP(д) = (k
and fall-through by quantifying three properties: i) the port utiliza-
tion difference of the two branch targets (rp), ii) the difference of
the two branch targets in terms of the length of the branches (rl ),
and iii) the amount of memory operations in both branches (rm).
To compare instruction sequences based on these properties, we
i =1 rдi)1/k for
our k(= 3) properties.
To compare the port utilization, we first use Intel’s Architecture
Code Analyzer (IACA) to obtain a port fingerprint P for a given
instruction sequence. The port fingerprint is a summary that lists
the total number of cycles spent on every port for a given instruction
sequence P = p0 . . . p7. IACA internally uses a microarchitecture-
specific model of the processor to compute the cycles, taking out-
of-order execution into account. It also models the divider pipe
on Skylake, allowing port zero, which handles the complex div
instruction, to be ready for the next µop in the next cycle, while the
div is still being executed. As it cannot know better, IACA assumes
all CPU resources to be fully available prior to execution of the
sequence. An open-source alternative to IACA, OSACA [25] also
supports AMD processors.
rp =i
To compare two port fingerprints P and Q, we subtract them and
then calculate the utilization difference as the sum over the vector:
0..7(|pi − qi|). The larger rp, the higher the difference in
port utilization of the two instruction sequences. The utilization
difference will be high for long instruction sequences that do not
share a port. Such instruction sequences lend themselves well to
SMoTher.
While a ranking based on the port utilization difference already
captures the most important aspect, it has one drawback: gadgets
where the branch instruction sequences are of different length, such
as 2 instructions vs. 20 will rank high, whereas we prefer sequences
of equal length for the timing. Therefore, we also include the inverse
of the length difference rl = abs(l1 − l2) between the sequences of
a gadget in the ranking.
Finally, we also take the potential noise into account that
can be caused by memory operations. On our targeted Sky-
lake processors, the ports 2, 3, 4 and 7 are used for schedul-
ing these. We include the inverse of the sum, rm, of the cycles
spent on these ports in both branches as an additional rank-
ing for the gadget. The final rank of a gadget дi
is given by
RP(дi) = (rpi · (max(rl) − rli) · (max(rm) − rmi))1/3.
5.2 Finding Gadgets
We develop a tool to aid gadget discovery based on the popular
distorm3 disassembler and Intel’s Architecture Code Analyzer, and
use it to analyze a number of common system libraries that are likely
to be linked to a victim executable. For the analysis we only consider
gadgets with a branch length between 3 and 70 instructions, with
3 instructions being a reasonably low bound for smothering and
70 instructions being an upper bound for speculative execution.
Our search looks for valid instruction sequences starting at every
offset in the binary. Therefore, it would detect any SMoTher-gadget
resulting from an unintended sequences of bytes (starting from the
middle of an intended instruction) which might decode to valid
instructions. We show the results in Table 3, the libraries analyzed
are taken from a regular Ubuntu 18.04 LTS installation. We focus on
glibc 2.23
stdc++ 6.0
ld 2.23
pthread 2.23
z 1.2.11
crypto 1.1
ssl 1.1
RDI
1155
1040
189
209
105
46
23
23
76
24
1132
310