## Page 268
250
Linux程序设计
启动的shell里去执行。这个命令的最前面有一个“@”符号，它告诉make在执行这些规则之前
不要在标准输出上把命令本身显示出来。
要想在/usr/local/bin子目录里安装新命令，普通用户的权限就不够用了：在调用执行“make
install”之前，你可以修改这个子目录的权限，或者把白己的身份修改为root根用户（用su命令）。
下面是它的执行情况：
gc 1. Wal -ans -c maan.c
gc -1.-g -aii -ans- 3.c
qc*
1.
“g-Kal
-ans1 c 2.c
make. Nothing to be done fot *all',
Inata,ed inusr,local/bin
gec
1 mydpp main.o 2.o 3.0
Smake -f Makefile3 clean
0′go* 'u*m 
5
操作注释：
我们先把myapp和所有目标代码文件都耐除掉。make命令自已知道需要使用目标all，也就
是需要创建出myapp来。然后我们再次运行make，但因为myapp已经是最新的了，所以makef仆
么事情也没有做。接下来，我们删除掉myapp，然后执行“makeinstall"。它会重新创建出二进
制文件并把它们拷贝到安装目录里去。最后，我们执行“makeclean”删除了当前子目录里全部
的目标代码文件。
8.2.6内建规则
到目前为止，我们对制作文件里的每个操作步骤都进行了精确的定义。事实上，make本身
就带有大量内建的规则，它们可以极大地简化制作文件的编写工作，尤其是在我们有大批源文
件的情况下更能发挥作用。我们先来编写-个foo.c文件，它的内容就是传统的“HelloWorld”
程序。
sinclude 
#include 
int main()
exit (EXIT_SUCCESS):
在不指定制作文件的情况下，我们用make来编译它：
5make foo
Cr
fou, c
-0 foo
正如大家所看到的，虽然make选用了cc面不是gcc，但它还是知道应该如何去调用编译器的。
加入jaVa编程群：524621833
---
## Page 269
第8章开发工具
257
有时候，这些内建规则又被称为推导规。这些缺省的规则使用的都是宏定义，因此给宏定义
一个新的值就能改变其缺省行为。
S make CC =gcc CFLAGS =*-Ha11 g* fo0
mtoo
我们可以通过“-p”选项让make把它的内建规则都打印出来。这些内建规则实在是太多了，
根本没办法在这里把它们都列出来，所以我们只给出了GNU版make的“make·p”命令的部分输
出，它只包括很少的一部分规则：
XUTPUT_OPTION = -O S@
COMPILE.c = $ (CC)  S (CFLAGS)  S (CPPFLAGS151ARGET_ARCH)-C
C .0:
S(COMPILE.C1$.：
来定义一个通用性规则，采用这条规则新创建出来的文件保留了原来文件名的前半部分，但便
用新后缓替换掉了老后缴。
动手试试：后级规则
下面是我们制作文件的一个片段，这是一个新的通用性规则，它的作用是把“.cpp”文件转
换为“.o”文件。这个片段需要插入到文件的顶部，紧跟在“all:myapp”语句的后面。我们给
新制作文件起名为Makefile5。
.SUFFIXES:
.cpp
我们来看看新规则是怎样做的：
336
*XC+
-g -a11 -ans1 -1. -c bar.cpp
rm bar , 0)
-0 bar
操作注释：
换为一个后缀“o”文件。在写出这个依赖关系的时候我们使用了特殊的宏定义名称，因为我们
个“cpp”文件得到一个“o”文件；make已经知道怎样才能从一个目标代码文件得到一个二进
制可执行文件了。
当我们调用make命令的时候，它将使用我们的新规则通过那个bar.cpp文件得到一个bar.o文
件，然后再使用内建规则从“.o”文件得到一个二进制可执行文件。那个“-xc++”标志的作用
是告诉gcc这是一个C++源代码文件。
8.2.8用make命令管理函数库
当我们工作在一个大型项目上的时候，一种比较常见且又方便的做法是把几个编译产品用
一个函数库来管理。函数库是包含着一组目标代码文件的文件，后缀名一般是“.a”（a是英文
archive的字头，表示这是一个库文件）。make命令在函数库管理方面使用了一个特殊的语法，它
把函数库的管理工作变得非常简单。
这个语法是“lib（file.o)”，它的作用是把目标代码文件file.o添加到lib.a库里去。make命令有
一个专门用来管理函数库的内建规则，它的常见形式如下所示：
加入jaVa编程群：524621833
---
## Page 271
第8章开发工具
253
C-a:
S{AR) S(ARFLAGS) Se S*.0
$ ICC)
-C SICFLAGS} S<
宏定义“S（AR)和“S（ARFLAGS）”的缺省取值分别是ar命令和它的rv选项。这个相当简
第一条规则的作用是对源文件进行编译以生成一个日标代码；第二条规则的作用是用ar命令
把新目标代码文件添加到函数库里去。假设我们已经有一个名为fud的函数库了，血库里义包含
着一个名为bas.o的文件，则其处理过程应该是：第-·条规则里的“S”被替换为“bas.c”，第二
*
动手试试：函数库的管理
在实践中，这个语法的使用方法其实是很简单的。先对我们的软件进行修改，把文件2.0和
3.o放到一个名为mylib.a的函数库里。我们需要对制作文件做很少的几处修改，下面是Makefile6
的最终结果。（我们省略了对C++程序进行处理的规则，因为我们不再需要它们了。）
al1: myapp
CC 。 gcc
which conpiler
INSTDIR = /usr/local/bin
# where to instal1
$where are inelude files kept
INCLUDE =.
CFLAGS = =g -Wal1 -ansi
Options for development
CFLAGS=-O-Wa11-ansi
 Options for release
MYLIB = mylib.a
Local Libraries
$ (MYLIB) : $ [MYLIB) (2 .0)$ (MYLIB) (3 . 0)
2.o: 2.c a.h b.h
main.o: main.c a,h
' q 
clean:
-rm main.o 2.o 3.o $(MYLIB)
install:myapp
[IGSN11S P-]316
then\
cp myapp S(INSTDIR):1
chod a+x S(INSTDIR)/wyapp:\
chmod og-v S(INSTDIR)/myapp:\
else\
echo*Sorry.SfINSTDIR1 does not exirt*:\
fi
请注意我们是如何通过缺省规则来完成大部分工作的。现在对我们的新版制作文件进行测试。
加入jaVa编程群：524621833
---
## Page 272
254Linux程序设计
S rm -f myapp*.o mylib.a
gccg-Wal1-ansi
5make -f Hakefile6
-C main.c -o nain.o
gcc -g -Wa11 -ansi
ar rv my11b.a 2.0
-e 2.c -o 2.0
ar: creating mylib.a
gc α-a11-ansi
- , 1
61 rv mylib.a 3.o
-c 3.c -0 3.0
=o myapp main.o mylib.a
3.0
S touch c.h
Smake -f Makefile6
gccg-wal1 -ans1
dr rv cylib.a 3.0
-c 3.c -0 3.0
30
操作注释：
首先，我们删除了所有的目标代码文件和库文件，make命令会因此而重建myapp。它将先
编译并创建出函数库，然后把main.o与函数库链接在一起创建出myapp。接下来，我们对3.o的
依赖关系规则进行了测试，这条规则告诉make如果c.h改变了，就将对3.o重新进行编译。它正确
地完成了这一工作，编译了3.o并刷新了函数库，然后重新链接，最终创建出一个新的myapp可
执行文件来。
8.2.9高级论题：制作文件和下级子目录
工作在大型项目上的时候经常会出现这样的情况，即我们需要把组成一个函数库的几个文
件从那些主文件分离出来并把它们保存到一个下级子目录里去。如果使用makc命令来完成这-
工作，有两个办法可供选用。
第一个办法是：在下级子目录里编写出第二个制作文件，对下级子目录里的文件进行编译
并把它们保存到一个函数库里，然后把那个库文件拷贝到父目录里去。在父自录的主制作文件
里应该有一条制作函数库的规则，该规则的写法大致如下，其作用是调用第二个制作文件：
my11b. a:
(cd aylibdirectory: S(xAxE) }
这条规则的含义是：当make调用建立函数库的规则时，它永远会先尝试制作mylib.a。它会
切换到下级子目录mylibdirectory去，再调用一个新的make命令对函数库进行管理。为完成这-
成建立函数库工作面启动的那个shell置身于另一个不同的子目录里。括号的作用是保证所有这
些处理都是由一个shell完成的。
第二个办法是在原来的制作文件里添加一些宏定义。新添加的宏定义是通过在我们已经见
过的宏定义的尾部追加一个字母得到的，字母“D”代表子目录，字母“F”代表文件名。这样
我们就可以用下面的语句替代内建的“c.o：”后缀规则：
C,0;
$(CC)$(CFLAGS)-C S(eD)/S(<F)-O $(9D)/$(9F)
加入jaVa编程群：524621833
---
## Page 273
第8章开发工具255
后，我们将使用下面这样的依赖关系和规则在当前子目承里制作出函数库来：
nry1ib.a: rydir2.o mydir 3.0
ar ·rv pylib.a $?
在项目里到底要选用哪一种办法需要由读者自已来决定、许多项目会采取比较简单的做法，
就是避免使用下级子目录，但这样将导致出现源目录里容纳的文件数量过多的现象。通过上面
这些简短的论述，读者应该看出只需稍微增加一点复杂性，我们就可以在下级子目录里使用
make命令。
8.2.10GNU的make和gcc命令
如果读者使用的是GNU的make命令和GNU的gcc编译器，那么在我们刚才介绍过的内容以
外还将有两个有趣的选项。
第一个是make命令的“-jN”（j代表“job"，即计算机作业）选项。它允许make命令同时执
行N个命令。如果项目的不同部分能够彼此独立地进行编译，make就会同时执行几条规则。根
据你系统的配置情况，这可以大节约重新编译所需要花费的时间。如果你有许多个源文件，
和其他用户共享自已的计算机，在使用作业选项的时候就要谨慎从事。其他用户可能不喜欢你
每次编译都要启动大量进程的微法。
另一个额外的收获是gcc的“-MM”选项。它的作用是产生一个依赖关系清单，清单格式适
用于make命令。软件项目往往会有很多个源文件，而每个源文件又包含着头文件的多种组合。
要想在--个这样的项目上理出正确的依赖关系其难度可能相当大（但又非常重要）。如果只是简
单地让每一个源文件依赖于它的每一个头文件，就往往会毫无必要地对文件进行编译。而从另
一方面来看，如果你漏掉了一些依赖关系，问题将会变得更糟，因为某些需要重新编译的文件
被你漏掉了。
动手试试：“gcc-MM”命令
S gce -M main.c 2.c 3.c
2.0: 2.c a.h b.h
main.o: main.c a.h
's uq o'f og
操作注释：
gcc编译器逐行列出了软件要求的依赖关系，其格式适合直接插入到-个制作文件里去。我
们只需先把它的输出保存到-个临时文件，再把它插入到制作文件里就可以得到一个完美的依
赖关系规则集合了。如果你拥有一份gcc编译器，还出现依赖关系错误可就说不过去了！
项很相似，但它的做法是把依关系追加到给定制作文件的末尾。