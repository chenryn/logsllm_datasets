title:Static detection of malicious JavaScript-bearing PDF documents
author:Pavel Laskov and
Nedim Srndic
Static Detection of Malicious JavaScript-Bearing PDF
Documents
Pavel Laskov
University of Tübingen
Sand 1, 72076
Tübingen, Germany
PI:EMAIL
Nedim Šrndi´c
University of Tübingen
Sand 1, 72076
Tübingen, Germany
PI:EMAIL
ABSTRACT
Despite the recent security improvements in Adobe’s PDF viewer,
its underlying code base remains vulnerable to novel exploits. A
steady ﬂow of rapidly evolving PDF malware observed in the wild
substantiates the need for novel protection instruments beyond the
classical signature-based scanners. In this contribution we present
a technique for detection of JavaScript-bearing malicious PDF doc-
uments based on static analysis of extracted JavaScript code. Com-
pared to previous work, mostly based on dynamic analysis, our
method incurs an order of magnitude lower run-time overhead and
does not require special instrumentation. Due to its eﬃciency we
were able to evaluate it on an extremely large real-life dataset ob-
tained from the VirusTotal malware upload portal. Our method
has proved to be eﬀective against both known and unknown mal-
ware and suitable for large-scale batch processing.
Categories and Subject Descriptors
D.4.6 [Software]: Operating Systems—Security and Protection;
I.2.6 [Computing Methodologies]: Artiﬁcial Intelligence—Learn-
ing
Keywords
Malware detection, malicious JavaScript, PDF documents, machine
learning
1.
INTRODUCTION
Since the discovery of the ﬁrst critical vulnerability in Adobe
Reader in 20081 the Portable Document Format (PDF) has become
one of the main attack vectors used by miscreants. PDF-based at-
tacks were the most frequently used remote exploitation technique
in 2009 with a proud share of 49%. Two speciﬁc PDF-based vul-
nerabilities were ranked second and ﬁfth among all vulnerabilities
discovered in 2009 [1]. Overall, more than 50 vulnerabilities were
1collab.CollectEmailInfo (CVE-2007-5659): known, as usual, well
ahead of an exploit.
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ACSAC ’11 Dec. 5-9, 2011, Orlando, Florida USA
Copyright 2011 ACM 978-1-4503-0672-0/11/12 ...$10.00.
discovered in Adobe Reader in 2008–2010, which has led to nu-
merous security-related updates. The severity of security prob-
lems has somewhat abated with the introduction of the sandboxing
technology—which has not been compromised to date—in Adobe
Reader X (version 10). The underlying code base, however, still
remains vulnerable, and some critical patches were issued earlier
this year [2, 3].
The vulnerabilities of Adobe Reader can be classiﬁed into three
categories. The earliest—and the largest—class of vulnerabilities
arises from bugs in the implementation of the Adobe JavaScript
API. This API signiﬁcantly extends the JavaScript functionality in
the speciﬁc context of PDF documents. The second class of vul-
nerabilities is rooted in non-JavaScript features of Adobe Reader
but typically requires JavaScript for exploitation, e.g. using heap
spraying. Examples of such vulnerabilities are the JBIG2 ﬁlter (e.g.
CVE-2009-0658) and the heap overﬂow (e.g. CVE-2009-1862) ex-
ploits. Finally, the smallest class of vulnerabilities, e.g. the ﬂawed
embedded TrueType font handling (CVE-2010-0195), does not in-
volve JavaScript functionality.
Unlike other modern exploitation techniques such as drive-by-
downloads, SQL injection or cross-site scripting, the PDF-based
attacks have not received signiﬁcant attention in the research com-
munity so far. Previous work in this ﬁeld has mostly focused on
dynamic analysis techniques. For example, well-known sandboxes
JSand [7] and CWSandbox [26] have been adapted to the analysis
of malicious PDF documents. Due to their heavy instrumentation
and security risks associated with dynamic analysis, the practical
applicability of such approaches is limited to malware research sys-
tems. For the end-user systems, some early work on the detection
of potential exploits in PDF documents [13, 21] has gone largely
unnoticed, and in practice the detection of malicious PDF docu-
ments still hinges upon signatures provided by security vendors.
In this paper, we explore static analysis techniques for detection
of JavaScript-based PDF exploits. Our aim is to develop eﬃcient
detection methods suitable for deployment on end-user systems as
well as in the networking infrastructure, e.g. email gateways and
HTTP proxies. We present the tool PJScan2 that is capable of re-
liably detecting PDF attacks with operational false positive rates
in the promille range. The low computational overhead of PJScan
makes it very attractive for large-scale analysis of PDF data.
Conceptually, PJScan is closely related to static analysis tech-
niques for detection of browser-based JavaScript attacks. Similarly
to the recent work of Rieck et al. [19], our methodology is based
on lexical analysis of JavaScript code and uses machine learning to
automatically construct models from available data for subsequent
classiﬁcation of new data. The crucial diﬀerence from browser-
2The source code of PJScan and its underlying library libPDFJS
can be found at http://sf.net/p/{pjscan|libpdfjs}.
(cid:1)(cid:2)(cid:1)
based JavaScript attacks is that reliable ground truth information
is hardly available for PDF documents. It is especially diﬃcult to
identify benign JavaScript-bearing PDF documents. First, as our
study will show, such examples are indeed much more rare than
malicious ones. Second, while it is relatively easy to verify that web
content at a certain URL is benign by using Google Safe Brows-
ing3, it is much more diﬃcult to extract and analyze JavaScript code
in PDF documents. These implications necessitate a conceptual re-
design of the detection methods. In PJScan, we have to resort to
anomaly detection to learn only from malicious examples.
Reliable extraction of JavaScript code from PDF documents is it-
self a major challenge. Not only is PDF very complex, it is also rich
with features that can be used for hiding the presence of JavaScript
code. It supports compression of arbitrary objects as well as var-
ious encodings for the JavaScript content. Such features are rou-
tinely used by attackers to avoid detection by signature-based meth-
ods. In our experience, none of the previous tools for static anal-
ysis of PDF documents, e.g. PDFID4, JSUNPACK5, PDF Dissec-
tor6, were able to provide full coverage of the possible locations
of JavaScript code in PDF documents. In the preprocessing com-
ponent of the PJScan, we have developed an interface to a popular
PDF rendering library Poppler7. Using this interface, our system
is able to handle all potential locations of JavaScript known to us
from the PDF Reference.
We have evaluated the eﬀectiveness of PJScan on a large real-
world dataset comprising 3 months of data uploaded by users to
the malware analysis portal VirusTotal8. This is the ﬁrst study of
malicious PDF documents carried out at such scale. Our results
conﬁrm that there still exist malicious PDF documents that are not
recognized by any antivirus system, although the share of novel
malicious PDF documents is no longer signiﬁcant (we have found
52 such documents among more than 40,000 documents classiﬁed
by VirusTotal as benign). In our experiments, PJScan has attained
average detection rates of 85% for known and 71% for previously
unknown PDF attacks with the average operational false positive
rate of about 0.37%. Due to the diﬀerence in the nature of benign
data a direct comparison of PJScan with methods for detection of
browser-based JavaScript attacks is not possible. Wepawet9 was the
only previous detection method suitable for PDF-based JavaScript
attacks. Much to our surprise, while being perfect in terms of false
positives and very good in detection of novel PDF attacks (90%),
Wepawet has shown poor performance on known PDF attacks, for
which it only reached the detection accuracy of 63.6%. As a dy-
namic analysis tool, Wepawet has been conceived for oﬄine anal-
ysis and incurs a signiﬁcant overhead.
1.1 Contributions
In summary, this paper provides the following contributions:
1. Robust extraction of JavaScript from PDF documents.
We provide a detailed account of the mechanisms for embed-
ding of JavaScript content in PDF documents and present a
methodology for reliable extraction of JavaScript code using
the open source PDF parser Poppler.
3Google Safe Browsing API: http://code.google.com/apis/
safebrowsing/
4http://blog.didierstevens.com/programs/pdf-tools/#pdfid
5https://code.google.com/p/jsunpack-n/
6http://www.zynamics.com/dissector.html
7http://poppler.freedesktop.org/. Version 0.14.3 was used in
our implementation.
8VirusTotal, Free Online Malware Scanner,
virustotal.com/index.html
9Wepawet, http://wepawet.iseclab.org/index.php
http://www.
(cid:1)(cid:3)(cid:2)
2. Fully static detection of malicious JavaScript. We describe
a method for discrimination between malicious and benign
JavaScript instances based on lexical analysis and anomaly
detection. Unlike the previous work, the proposed method
does not require manual labeling of data. This is especially
important for PDF documents for which it is diﬃcult to ver-
ify that a certain document is benign.
3. High performance. The key advantage of static analysis is
that it allows several orders of magnitude higher processing
speed. Our system PJScan has attained the average process-
ing time of less than 50ms per ﬁle.
4. Comprehensive evaluation. We present the results of a ﬁrst
large-scale evaluation of malicious PDF detection on a real-
world dataset comprising more than 65,000 PDF documents.
PJScan has detected 85% of known malicious PDF docu-
ments compared to all 42 antivirus scanners deployed by
VirusTotal and 71% of previously unknown malicious PDF
documents (not detected by any of the VirusTotal’s scan-
ners). The promille-range false positive rate of PJScan makes
it suitable for practical deployment.
1.2 Paper Organization
The rest of this article is organized as follows. We begin with
a brief summary of the main features of PDF and its mechanisms
for embedding of JavaScript contents (Section 2). The architecture
of PJScan and the methodology used in its speciﬁc components is
presented in Section 3. In Section 4, we present the data corpus and
analyze its statistical features at diﬀerent representational levels.
Our experimental evaluation is presented in Section 5, followed
by the discussion of related work in Section 6. Limitations of our
methods and potential improvements are discussed in Section 7.
2. PDF AND JAVASCRIPT
Before presenting the technical details of our methods, we brieﬂy
summarize the main features of the Portable Document Format and
present its syntactic forms used for embedding of JavaScript. A
signiﬁcant portion of the following section contains direct citations
from the PDF Reference [15].
2.1 PDF Essentials
A PDF ﬁle consists of the following four elements10:
• A header consisting of the characters %PDF- and the version
number of the PDF standard used in the ﬁle (e.g. 1.1),
• A body containing PDF objects with the actual content of the
document,
• A cross-reference table listing indirectly referenced objects
and their location in the ﬁle,
• A trailer, containing the location of the cross-reference table
and some objects in the ﬁle body.
The parsing of a PDF ﬁle begins with checking the version number
and looking at the ﬁle trailer for information about the location of
the cross-reference table and some special objects in the ﬁle body.
10Many parsers do not strictly follow the PDF Standard. Even the
Adobe Reader is notorious for such lack of compliance, e.g.
it
ignores arbitrary symbols before the header [12] and can dispense
with the trailer and cross-references [27].
The PDF standard deﬁnes eight basic types of objects:
1. Boolean objects take values true and false.
2. Integer and real numbers.
3. Strings may be stored in two ways:
• as a sequence of literal characters enclosed in parenthe-
ses ‘(’ and ‘)’.
• as a sequence of hexadecimal numbers enclosed in an-
gle brackets ‘’.
4. Names are sequences of 8-bit characters used as identiﬁers.
5. Arrays are sequences of PDF objects, potentially of diﬀerent
type; arrays can be nested.
6. Dictionaries are collections of key-value pairs with keys be-
ing names and values being of any PDF object type. Dictio-
naries are used to describe complex objects such as pages or
actions.
7. Streams are dictionary objects followed by a sequence of
bytes between the words stream and endstream. Streams
can be used to represent large objects, such as images, in
a compact way. The content of the byte sequence may be
stored in an encoded or compressed form. A special type of
streams are object streams containing arbitrary PDF objects.
8. The null object is denoted by the keyword null.
The body of a PDF document is built as a hierarchy of these eight
basic types of objects linked together in a semantically meaning-
ful way to describe pages, multimedia, outlines, annotations, etc.
A central role in the hierarchy belongs to the Catalog dictionary
pointed to by the /Root entry of the cross-reference table. It serves
as the root of a tree-like structure describing the document content.
Objects can be assigned a unique identiﬁer consisting of an ob-
ject number and a generation number (a sort of a version number).
Objects that have a unique identiﬁer can be referenced from other
objects using an indirect reference written as a sequence of the ob-
ject number, the generation number and the capital letter ‘R’. For
example, 23 0 R refers to an object with the object number 23 and
the generation number 0. PDF allows encryption of the contents of
strings and streams.
2.2
JavaScript in PDF
PDF provides several mechanisms for inclusion of JavaScript
code. These mechanisms are important for the realization of in-
teractive features, such as forms, dynamic content or 3D rendering.
Some PDF usage scenarios relying on these features cannot be re-
alized without JavaScript.
The main indicator for JavaScript code is the presence of the
keyword /JS in some dictionary. The JavaScript source is supplied
directly as one of the two possible string types (literal or hexadeci-
mal) or stored in another object pointed to by an indirect reference.
In the latter case, it is usually stored in a compressed or encrypted
form in a stream attached to that object. Examples of typical syntax
for embedding of JavaScript code are shown in Fig. 1.
A simple search for /JS patterns in PDF ﬁles – as it was realized
in some tools for the analysis of PDF documents, e.g. PDFID –
does not suﬃce for identiﬁcation of JavaScript locations. It can be
easily evaded by placing objects containing dictionaries with the
keyword /JS into object streams. Due to stream compression the
keyword /JS is not visible in plain text. The simple search may also
1 0 obj >
>>
endobj
/Type /Catalog
/Pages 2 0 R
/OpenAction >
>>
endobj
Figure 1: Exemplary syntactic constructs for embedding of
JavaScript in PDF documents. Left: code is placed in another ob-
ject pointed to by an indirect reference (not shown). Right: code is
supplied as a literal string.
yield multiple references to identical code if diﬀerent revisions of
the same content are present.
In order to reliably extract JavaScript code, the documents must
be processed at the semantic level, i.e. considering potential uses of
JavaScript in the context of other objects in a document. In general,
the use of JavaScript code in PDF documents is bound to the so-
called action dictionaries. Such dictionaries may be tagged by a
keyword/value pair /Type/Action, but unfortunately such explicit
qualiﬁcation is optional and cannot be relied upon. A mandatory
feature of all action dictionaries is the keyword /S which may take
on 18 diﬀerent name values. Two of such values, /JavaScript
and /Rendition, are important for the search for JavaScript code.
The former must, and the latter may have a keyword /JS [15], as
shown in Fig. 1. The content associated with the keyword /JS must
use the PDFDocEncoding (as deﬁned in [15]) or the UTF-16BE
(big-endian) Unicode encoding. In the rest of this article we denote
JavaScript source code located in or referred to by one JavaScript
or Rendition action dictionary as a JavaScript entity.
JavaScript or Rendition action dictionaries can be found at the
following locations of the PDF object hierarchy:
• The Catalog dictionary’s /AA entry may deﬁne an additional
action speciﬁed by a JavaScript action dictionary.
• The Catalog dictionary’s /OpenAction entry may deﬁne an
action to be run when the document is opened.
• The document’s name tree may contain an entry ‘JavaScript’
that maps name strings to document-level JavaScript action
dictionaries executed when the document is opened.
• The document’s Outline hierarchy, referenced by means of
the ‘Outlines’ entry of the Catalog dictionary, may contain
references to JavaScript action dictionaries.
• Pages, ﬁle attachments and forms may also contain refer-
ences to JavaScript action dictionaries.
Besides being directly embedded in a PDF ﬁle, JavaScript code
may also reside in a diﬀerent ﬁle on a local machine or even be re-
trieved from a remote location using the directives /URI or /GoTo.
JavaScript also supports dynamic code execution using the eval()
function or its equivalent, setTimeOut(). Such mechanisms are
diﬃcult for static analysis; however, they are launched from an ex-
isting entry point code inside a document.
3. SYSTEM ARCHITECTURE
The architecture of our PDF scanner PJScan is shown in Fig. 2.
Conceptually, our system consists of the feature extraction and the
learning components. The feature extraction component searches
(cid:1)(cid:3)(cid:2)
(cid:6)(cid:15)(cid:12)(cid:29)(cid:30)(cid:27)(cid:15)(cid:1)(cid:5)(cid:32)(cid:29)(cid:27)(cid:12)(cid:13)(cid:29)(cid:19)(cid:24)(cid:23)
(cid:7)(cid:12)(cid:31)(cid:12)(cid:10)(cid:13)(cid:27)(cid:19)(cid:25)(cid:29)(cid:1)
(cid:5)(cid:32)(cid:29)(cid:27)(cid:12)(cid:13)(cid:29)(cid:24)(cid:27)
(cid:7)(cid:12)(cid:31)(cid:12)(cid:10)(cid:13)(cid:27)(cid:19)(cid:25)(cid:29)(cid:1)
(cid:5)(cid:23)(cid:29)(cid:19)(cid:29)(cid:33)
(cid:11)(cid:24)(cid:20)(cid:15)(cid:23)(cid:19)(cid:34)(cid:15)(cid:27)
(cid:11)(cid:24)(cid:20)(cid:15)(cid:23)(cid:1)
(cid:10)(cid:15)(cid:26)(cid:30)(cid:15)(cid:23)(cid:13)(cid:15)
(cid:11)(cid:27)(cid:12)(cid:19)(cid:23)(cid:19)(cid:23)(cid:17)(cid:1)
(cid:10)(cid:12)(cid:22)(cid:25)(cid:21)(cid:15)
(cid:11)(cid:15)(cid:28)(cid:29)(cid:1)
(cid:10)(cid:12)(cid:22)(cid:25)(cid:21)(cid:15)
(cid:8)(cid:15)(cid:12)(cid:27)(cid:23)(cid:19)(cid:23)(cid:17)
(cid:8)(cid:15)(cid:12)(cid:27)(cid:23)(cid:19)(cid:23)(cid:17)(cid:1)