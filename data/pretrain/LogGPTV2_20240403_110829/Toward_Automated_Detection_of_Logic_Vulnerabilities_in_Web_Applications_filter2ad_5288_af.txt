known logic vulnerabilities. Unfortunately, we found a
very limited number of such applications to be available,
and none of them met all of our current selection criteria
for test applications.
6 Related Work
Our work is related to several areas of active research,
such as deriving application speciﬁcations, using speciﬁ-
cations for bug ﬁnding, and vulnerability analysis of web
applications. However, due to the limited space avail-
able, in this section we will only highlight the research
that, in our opinion, is most related.
First, our approach is related to a number of ap-
proaches that combine dynamically-generated invariants
with static analysis. For example, Nimmer and Ernst ex-
plore how to integrate dynamic detection of program in-
variants and their static veriﬁcation on a set of simple
stand-alone applications using Daikon and the ESC/Java
static checker [27]. The invariants that are veriﬁed by
the static checker on all paths are determined to be the
real invariants for an application, and the invariants that
could not be statically veriﬁed are shown as warnings
to the user. The main goal of this research is to show
the feasibility of the proposed approach rather than to
ﬁnd bugs. Another work that explores beneﬁts of com-
bining Daikon-generated invariants with static analysis is
the DSD-Crasher tool by Csallner and Smaragdakis [8].
The main goal of this system is to decrease the false pos-
itives rate of a static bug-ﬁnding tool for stand-alone Java
applications. Dynamically-generated invariants are used
by the CnC tool (also based on ESC/Java) as assump-
tions on methods arguments and return values to narrow
the domain searched by the static analyzer. In Waler, in
contrast to both approaches, we do not assume that the
invariants generated by Daikon are correct, and we only
consider them to be clues for vulnerability analysis. In-
troducing our two additional techniques to differentiate
between real and spurious invariants allows us to avoid
many of the false positives due to limitations of the dy-
namic analysis step.
Our work is also related to the research on using an
application’s code to infer application-speciﬁc properties
that can be used for guided bug ﬁnding. To the best of our
knowledge, one of the ﬁrst techniques that uses inferred
speciﬁcations to search for application-speciﬁc errors is
the work by Engler et al. [10]. Their goal is similar to
ours in the sense that both works are trying to identify vi-
olations of likely invariants in applications. The way it is
achieved, though, is very different in the two approaches.
While we infer speciﬁcations from dynamic analysis and
check for possible violations in the code via symbolic ex-
ecution, Engler’s work carries out all the steps via static
analysis: a set of given templates is used to extract a set
of “beliefs” from the code. Afterward, patterns contra-
dicting these “beliefs” are identiﬁed in the code. While
some of the templates may be useful for web applica-
tions, most of the bugs they try to identify are relative to
kernel and memory-unsafe programming languages op-
erations. Moreover, we believe that having an additional
source of information (i.e., dynamic traces) for applica-
tion invariants makes our system more robust.
There is also recent work that uses statistical analysis
and program code to learn certain properties of the appli-
cation, with the goal of searching for application-speciﬁc
bugs. For example, Kremenek et al. propose a statistical
approach, based on factor graphs, to automatically infer
which program functions return or claim ownership of
a resource [21]. The AutoISES tool applies the idea of
using statically-inferred speciﬁcations to the detection of
vulnerabilities in the implementations of access control
mechanisms for OS-level code [34]. The differences be-
tween these approaches and ours are similar to the ones
with the Engler’s work. Both approaches use statistical
analysis to ﬁnd violations of properties that must hold
for all program points, and they do not require reasoning
about the values of variables.
Learning invariants through dynamic analysis has al-
ready found application security purposes, mostly in or-
der to train an Intrusion Detection System. Baliga et
al. [4] employ Daikon to extract invariants on kernel
structures from periodic memory snapshot of a non-
compromised running system. After the training phase,
these learned invariants are used to detect the presence of
kernel rootkits that may have altered vital kernel struc-
tures. A conceptually similar approach has also been ap-
plied by Bond et al. [6] to Java code through instrumen-
tation of the Java Virtual Machine. An initial learning
phase is employed to record the calling context and call
history for security-sensitive functions. Afterwards, the
collected information is used to identify function invoca-
tions with an anomalous context. An anomalous context
or history is considered an indicator of an attempt to di-
vert the intended ﬂow of the application, possibly by the
exploitation of a logic error in the code. In that case, an
alert is triggered or the execution is aborted.
Although both the techniques proposed by Baliga and
Bong share with ours an initial dynamic learning phase,
how the information is leveraged differs. For example,
unlike the two approaches above, we do not assume that
the likely invariants generated by the ﬁrst phase are real
invariants, rather we simply use them as hints for further
analysis. In addition, while in our second phase we try to
identify logic errors in the code by means of static anal-
ysis, they instead try to detect attacks being performed
on a live system. Such run-time detection imposes an
overhead, which results in the requirement for dedicated
hardware for [4] and a 2%-9% penalty in performance
for [6]. The authors of the latter work, in particular,
traded some coverage of the code (limiting to security-
related functions) in order to retain acceptable perfor-
mance. Even though they focused on logic errors, a di-
rect comparison with their evaluation environment was
not possible, because of the different targets of the anal-
ysis. More precisely, they looked for bugs in the Java
libraries triggered by Java applets, rather than bugs in
Java-based web applications.
Another direction of research deals with protection of
web service components against malicious and/or com-
promised clients. Guha et al. [15] employ static anal-
ysis on JavaScript client code in order to extract an ex-
pected client behavior as seen by the server. The server is
then protected by a proxy that ﬁlters possibly malicious
clients which do not conform to the extracted behavior.
Finally, our work is related to a large corpus of work,
such as [16, 5, 7, 17, 18, 22, 26, 30, 33, 36, 23, 29], in the
area of vulnerability analysis of web applications. How-
ever, most of these research works focus on the detec-
tion of or the protection against input-validation attacks,
which do not require any knowledge of application-
speciﬁc rules.
Among the approaches cited above, Swaddler [7] and
MiMoSA [5] are tools developed by our group that look
for workﬂow violation attacks in PHP-based web appli-
cations, using a number of different techniques (includ-
ing Daikon-generated invariants). However, Waler’s ap-
proach is more general and is able to identify any kind of
a policy violation that is either reﬂected by a check in the
application or that violates a consistency constraint.
Our work is also related to the QED tool presented
in [23]. QED uses concrete model checking (with a set
of predeﬁned concrete inputs) to identify taint-based vul-
nerabilities in servlet-based applications. The main sim-
ilarity between the two tools is that they both use a set
of heuristics to limit an application’s state space during
model checking. Heuristics used by QED, however, are
more speciﬁc to the taint-propagation problem and re-
quire an additional analysis step.
7 Conclusions
In this paper, we have presented a novel approach to the
identiﬁcation of a class of application logic vulnerabil-
ities, in the context of web applications. Our approach
uses a composition of dynamic analysis and symbolic
model checking to identify invariants that are a part of the
“intended” program speciﬁcation, but are not enforced
on all paths in the code of a web application.
16
We implemented the proposed approaches in a tool,
called Waler, that analyzes servlet-based web applica-
tions. We used Waler to identify a number of previously-
unknown application logic vulnerabilities in several real-
world applications and in a number of senior undergrad-
uate projects.
To the best of our knowledge, Waler is the ﬁrst tool
that is able to automatically detect complex web appli-
cation logic ﬂaws without the need for a substantial hu-
man (annotation) effort or the use of ad hoc, manually-
speciﬁed heuristics.
Future work will focus on extending the class of ap-
plication logic vulnerabilities that we can identify. In ad-
dition, we plan to extend Waler to deal with a number of
frameworks, such as Struts and Faces. This will require
creating “symbolic” versions of the libraries included in
these frameworks. This initial development effort will
allow us to apply our tool to a much larger set of web ap-
plications, since most large-scale, servlet-based web ap-
plications rely on one of these popular frameworks, and
the lack of their support in Waler was a serious limit-
ing factor when choosing real-world applications for the
evaluation described in this paper.
8 Acknowledgments
We want
to thank David Evans, Vinod Ganapathy,
Somesh Jha, and a number of anonymous reviewers who
gave us very useful feedback on a previous version of
this paper.
References
[1] AMMONS, G., BOD´IK, R., AND LARUS, J. Mining speciﬁca-
tions. In Proceedings of the 29th ACM SIGPLAN-SIGACT sym-
posium on Principles of programming languages (2002), ACM,
pp. 4–16.
[2] ANAND, S., PASAREANU, C., AND VISSER, W.
JPF-SE: A
Symbolic Execution Extension to Java PathFinder. In Proceed-
ings of the International Conference on Tools and Algorithms
for the Construction and Analysis of Systems (TACAS) (2007),
Springer.
[3] ANLEY, C. Advanced SQL Injection in SQL Server Applica-
tions. Tech. rep., Next Generation Security Software, Ltd, 2002.
[4] BALIGA, A., GANAPATHY, V., AND IFTODE, L. Automatic In-
ference and Enforcement of Kernel Data Structure Invariants. In
Computer Security Applications Conference, 2008. ACSAC 2008.
Annual (2008), pp. 77–86.
[5] BALZAROTTI, D., COVA, M., FELMETSGER, V., AND VIGNA,
G. Multi-module Vulnerability Analysis of Web-based Applica-
tions. In Proceedings of the ACM conference on Computer and
Communications Security (CCS) (2007), pp. 25–35.
[6] BOND, M., SRIVASTAVA, V., MCKINLEY, K., AND
SHMATIKOV, V. Efﬁcient, Context-Sensitive Detection of Se-
mantic Attacks. Tech. Rep. TR-09-14, UT Austin Computer Sci-
ences, 2009.
17
[7] COVA, M., BALZAROTTI, D., FELMETSGER, V., AND VIGNA,
G. Swaddler: An Approach for the Anomaly-based Detection of
State Violations in Web Applications. In Proceedings of the Inter-
national Symposium on Recent Advances in Intrusion Detection
(RAID) (2007), pp. 63–86.
[8] CSALLNER, C., SMARAGDAKIS, Y., AND XIE, T. Article 8 (37
pages)-DSD-Crasher: A Hybrid Analysis Tool for Bug Finding.
In ACM Transactions on Software Engineering and Methodology
(TOSEM) (April 2008).
[9] The Daikon invariant detector. http://groups.csail.
mit.edu/pag/daikon/.
[10] ENGLER, D., CHEN, D., HALLEM, S., CHOU, A., AND CHELF,
B. Bugs as deviant behavior: a general approach to inferring
errors in systems code. ACM SIGOPS Operating Systems Review
35, 5 (2001), 57–72.
[11] ERNST, M., PERKINS,
J., GUO, P., MCCAMANT, S.,
PACHECO, C., TSCHANTZ, M., AND XIAO, C. The Daikon
System for Dynamic Detection of Likely Invariants. Science of
Computer Programming 69, 1–3 (Dec. 2007), 35–45.
[12] FOSSI, M. Symantec Global Internet Security Threat Report.
Tech. rep., Symantec, April 2009. Volume XIV.
[13] FOUNDATION, T. A. S. Apache Tomcat. http://tomcat.
apache.org/.
[14] GROSSMAN, J. Seven Business Logic Flaws That Put Your
Website at Risk. http://www.whitehatsec.com/home/
assets/WP bizlogic092407.pdf, September 2007.
[15] GUHA, A., KRISHNAMURTHI, S., AND JIM, T. Using static
analysis for Ajax intrusion detection. In Proceedings of the 18th
international conference on World wide web (2009), ACM New
York, NY, USA, pp. 561–570.
[16] HALFOND, W., AND ORSO, A. AMNESIA: Analysis and Moni-
toring for NEutralizing SQL-Injection Attacks. In Proceedings of
the International Conference on Automated Software Engineer-
ing (ASE) (November 2005), pp. 174–183.
[17] HUANG, Y.-W., YU, F., HANG, C., TSAI, C.-H., LEE, D.,
AND KUO, S.-Y. Securing Web Application Code by Static
Analysis and Runtime Protection. In Proceedings of the Interna-
tional World Wide Web Conference (WWW) (May 2004), pp. 40–
52.
[18] JOVANOVIC, N., KRUEGEL, C., AND KIRDA, E. Pixy: A Static
Analysis Tool for Detecting Web Application Vulnerabilities. In
Proceedings of the IEEE Symposium on Security and Privacy
(May 2006).
[19] Java
pathﬁnder.
sourceforge.net/.
http://javapathfinder.
[20] KLEIN, A. Cross Site Scripting Explained. Tech. rep., Sanctum
Inc., June 2002.
[21] KREMENEK, T., TWOHEY, P., BACK, G., NG, A., AND EN-
GLER, D. From Uncertainty to Belief: Inferring the Speciﬁcation
Within. In Proceedings of the Symposium on Operating Systems
Design and Implementation (OSDI) (November 2006), pp. 161–
176.
[22] LIVSHITS, V., AND LAM, M. Finding Security Vulnerabilities
in Java Applications with Static Analysis. In Proceedings of the
USENIX Security Symposium (August 2005), pp. 271–286.
[23] MARTIN, M., AND LAM, M. Automatic Generation of XSS
and SQL Injection Attacks with Goal-Directed Model Checking.
In Proceedings of the USENIX Security Symposium (July 2008),
pp. 31–43.
[24] MICROSYSTEMS, S.
Java Servlet Speciﬁcation Version
http://java.sun.com/products/servlet/
2.4.
reference/api/index.html, 2003.
[35] VISSER, W., HAVELUND, K., BRAT, G., PARK, S., AND
LERDA, F. Model Checking Programs. Automated Software En-
gineering Journal 10, 2 (Apr. 2003).
[36] XIE, Y., AND AIKEN, A. Static Detection of Security Vulner-
abilities in Scripting Languages. In Proceedings of the USENIX
Security Symposium (August 2006).
Notes
1As a consequence of that, JPF includes constraints that are no
longer relevant to the current execution into the application’s state, pre-
venting it from detecting otherwise equivalent states.
2Note that by using the simple strategy of removing all constraints
that reference no longer live variables, we might potentially lose some
of the implied constraints in the PC. This can reduce the effectiveness
of the reduction of the state space, but it does not interfere with the
soundness of the analysis.
3The names of the variables are generated as explained in Sec-
tion 4.1.
4When session data is accessed on a path, the PCA records that
fact, along with the key that was used. This is done by storing the
item session. in an attribute of the memory location that holds
the reference to the object. The information is then propagated by JPF
with each bytecode instruction that accesses this memory location.
5A similar vulnerability was found by Waler in the JspCart applica-
tion. We use Jebbo as a simpler example.
6Note that our tool works on Java bytecode rather than source code.
Therefore, loop exit conditions are implicitly included, as they are im-
plemented in terms of IF opcodes.
7The code for the JspCart application is located in the SourceForge
repository under the name B2B eCommerce Project.
[25] MIDDLEWARE, O. W. O. S.
objectweb.org/.
ASM.
http://asm.
[26] NGUYEN-TUONG, A., GUARNIERI, S., GREENE, D., AND
EVANS, D. Automatically Hardening Web Applications Using
Precise Tainting. In Proceedings of the International Information
Security Conference (SEC) (May 2005), pp. 372–382.
[27] NIMMER, J., AND ERNST, M. Static veriﬁcation of dynamically
detected program invariants: Integrating Daikon and ESC/Java.
In Proceedings of RV’01, First Workshop on Runtime Veriﬁcation
(2001).
[28] OPEN SOURCE SOFTWARE.
sourceforge.net.
SourceForge.
http://
[29] PALEARI, R., MARRONE, D., BRUSCHI, D., AND MONGA, M.
On race vulnerabilities in web applications. In Proceedings of the
Conference on Detection of Intrusions and Malware & Vulnera-
bility Assessment (DIMVA) (July 2008).
[30] PIETRASZEK, T., AND BERGHE, C. V. Defending against In-
jection Attacks through Context-Sensitive String Evaluation. In
Proceedings of the International Symposium on Recent Advances
in Intrusion Detections (RAID) (2005), pp. 372–382.
[31] SELENIUM DEVELOPMENT TEAM. Selenium: Web Application
Testing System. http://seleniumhq.org.
[32] SPETT, K. Blind SQL Injection. Tech. rep., SPI Dynamics, 2003.
[33] SU, Z., AND WASSERMANN, G. The Essence of Command
In Proceedings of the
Injection Attacks in Web Applications.
Annual Symposium on Principles of Programming Languages
(POPL) (2006), pp. 372–382.
[34] TAN, L., ZHANG, X., MA, X., XIONG, W., AND ZHOU, Y.
AutoISES: Automatically Inferring Security Speciﬁcations and
In Proceedings of the USENIX Security
Detecting Violations.
Symposium (July 2008), pp. 379–394.
18