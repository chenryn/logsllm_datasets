code, these operations appear as calls to the LLVM in-
USENIX Association
26th USENIX Security Symposium    189
struct vcsd_t {
unsigned count;
type_t *args;
};
thread_local stack vcs;
thread_local map> vlm;
void pre_call(vcsd_t *arguments) {
vcs.push_back(arguments);
}
void post_call() {
vcs.pop_back();
}
void list_init(va_list *list_ptr) {
vlm[list_ptr] = { vcs.top(), 0 };
}
void list_free(va_list *list_ptr) {
vlm.erase(list_ptr);
}
void check_arg(va_list *list_ptr, type_t type) {
pair &args = vlm[list_ptr];
unsigned index = args.second++;
assert(index count);
assert(args.first->args[index] == type);
}
int add(int start, ...) {
/* ... */
va_start(list, start);
list_init(&list);
do {
check_arg(&list, typeid(int));
total += va_arg(list, int);
} while (next != 0);
va_end(list);
list_free(&list);
/* ... */
}
const vcsd_t main_add_vcsd = {
.count = 3,
.args = {typeid(int), typeid(int), typeid(int)}
};
int main(int argc, const char *argv[]) {
/* ... */
pre_call(&main_add_vcsd);
int result = add(5, 1, 2, 0);
post_call();
printf("%d\n", result);
/* ... */
}
Listing 2:
instrumented code for Listing 1.
Simpliﬁed C++ representation of
the
trinsics llvm.va_start, llvm.va_copy, and va_end. We
instrument the operations with calls to our runtime’s
list_init, list_copy, and list_free functions respec-
tively. We then proceed to identify va_arg operations.
Although the LLVM IR has a dedicated va_arg instruc-
tion, it is not used on any of the platforms we tested.
The va_list is instead accessed directly. Our identiﬁ-
cation of va_arg is therefore platform-speciﬁc. On x86-
64, our primary target, we identify va_arg by recogniz-
ing accesses to the gp_offset and fp_offset ﬁelds in the
x86-64 version of the va_list structure (see Section 2.2).
The fp_offset ﬁeld is accessed whenever the program
attempts to retrieve a ﬂoating point argument from the
list. The gp_offset ﬁeld is accessed to retrieve any other
types of variadic arguments. We insert a call to our run-
time’s check_arg function before the instruction that ac-
cesses this ﬁeld.
Listing 2 shows (in simpliﬁed C) how the code in List-
ing 1 would be instrumented by our sanitizer.
Dynamic variadic type checking. The entire runtime
is implemented in plain C code, as this allows it to be
linked into the standard C library without introducing
a dependency to the standard C++ library. The VCS is
implemented as a thread-local stack, and the VLM as
a thread-local hash map. The pre_call and post_call
functions push and pop type information onto and from
the VCS. The list_init function inserts a new entry
into the VLM, using the top element on the stack as the
entry’s type information and initializing the counter for
consumed arguments to 0.
check arg looks up the type information for the
va_list being accessed in the VLM and checks if the
requested argument exists (based on the counter of con-
sumed arguments), and if its type matches the one pro-
vided by the caller. If either of these checks fails, exe-
cution is aborted, and the runtime will generate an error
message such as the one shown in Listing 3. As a con-
sequence, the pointer to the argument is never read or
written, since the pointer to it is never dereferenced.
Error: Type Mismatch
Index is 1
Callee Type : 43 (32-bit Integer)
Caller Type : 15 (Pointer)
Backtrace:
[0] 0x4019ff  at test
[1] 0x401837  at test
[2] 0x8011b3afa  at libc.so.7
[3] 0x8011b1816  at libc.so.7
[4] 0x801200e50  at libc.so.7
[5] 0x4024ae  at test
[6] 0x4012ff  at test
Listing 3: Error message reported by HexVASAN
190    26th USENIX Security Symposium
USENIX Association
6 Evaluation
In this section we present a case study on variadic func-
tion based attacks against state-of-the-art CFI implemen-
tations. Next, we evaluate the effectiveness of Hex-
VASAN as an exploit mitigation technique. Then, we
evaluate the overhead introduced by our HexVASAN
prototype implementation on the SPEC CPU2006 in-
teger (CINT2006) benchmarks, on Firefox using stan-
dard JavaScript benchmarks, and on micro-benchmarks.
We also evaluate how widespread the usage of variadic
functions is in SPEC CPU2006 and in Firefox 51.0.1,
Chromium 58.0.3007.0, Apache 2.4.23, CPython 3.7.0,
nginx 1.11.5, OpenSSL 1.1.1, Wireshark 2.2.1, and the
FreeBSD 11.0 base system.
Note that, along with testing the aforementioned soft-
ware, we also developed an internal set of regression
tests. Our regression tests allow us to verify that our
sanitizer correctly catches problematic variadic function
calls, and does not raise false alarms for benign calls.
The test suite explores corner cases, including trying to
access arguments that have not been passed and trying to
access them using a type different from the one used at
the call site.
6.1 Case study: CFI effectiveness
One of the attack scenarios we envision is that an at-
tacker controls the target of an indirect call site. If the
intended target of the call site was a variadic function,
the attacker could illegally call a different variadic func-
tion that expects different variadic arguments than the in-
tended target (yet shares the types for all non-variadic
arguments). If the intended target of the call site was a
non-variadic function, the attacker could call a variadic
function that interprets some of the intended target’s ar-
guments as variadic arguments.
All existing CFI mechanisms allow such attacks to
some extent. The most precise CFI mechanisms, which
rely on function prototypes to classify target sets (e.g.,
LLVM-CFI, piCFI, or VTV) will allow all targets with
the same prototype, possibly restricting to the subset
of functions whose addresses are taken in the program.
This is problematic for variadic functions, as only non-
variadic types are known statically. For example, if
a function of type int (*)(int, ...) is expected to
be called from an indirect call site, then precise CFI
schemes allow calls to all other variadic functions of that
type, even if those other functions expect different types
for the variadic arguments.
A second way to attack variadic functions is to over-
write their arguments directly. This happens, for ex-
ample, in format string attacks, where an attacker can
overwrite the format string to cause misinterpretation
of the variadic arguments. HexVASAN detects both of
these attacks when the callee attempts to retrieve the
variadic arguments using the va_arg macro described
in Section 2.1. Checking and enforcing the correct
types for variadic functions is only possible at runtime
and any sanitizer must resort to run-time checks to do
so. CFI mechanisms must therefore be extended with
a HexVASAN-like mechanism to detect violations. To
show that our tool can complement CFI, we create test
programs containing several variadic functions and one
non-variadic function. The deﬁnitions of these functions
are shown below.
int sum_ints(int n, ...);
int avg_longs(int n, ...);
int avg_doubles(int n, ...);
void print_longs(int n, ...);
void print_doubles(int n, ...);
int square(int n);
This program contains one indirect call site from
which only the sum_ints function can be called legally,
and one indirect call site from which only the square
function can be legally called. We also introduce a mem-
ory corruption vulnerability which allows us to override
the target of both indirect calls.
We constructed the program such that sum_ints,
avg_longs, print_longs, and square are all address-taken
functions. The avg_doubles and print_doubles functions
are not address-taken.
Functions avg_longs, avg_doubles, print_longs, and
print_doubles all expect different variadic argument
types than function sum_ints.
Functions sum_ints,
avg_longs, avg_doubles, and square do, however, all
have the same non-variadic prototype (int (*)(int)).
We compiled six versions of
the test program,
instrumenting them with,
respectively, HexVASAN,
LLVM 3.9 Forward-Edge CFI [59], Per-Input CFI [44],
CCFI [35], GCC 6.2’s VTV [59] and Visual C++ Control
Flow Guard [37]. In each version, we ﬁrst built an attack
involving a variadic function, by overriding the indirect
call sites with a call to each of the variadic functions de-
scribed above. We then also tested overwriting the argu-
ments of the sum_ints function, without overwriting the
indirect call target. Table 1 shows the detection results.
LLVM Forward-Edge CFI allows calls to avg_longs
and avg_doubles from the sum_ints indirect call site be-
cause these functions have the same static type signa-
ture as the intended call target. This implementation of
CFI does not allow calls to variadic functions from non-
variadic call sites, however.
CCFI only detects calls to print_doubles, a function
that is not address-taken and has a different non-variadic
prototype than square, from the square call site. It allows
all of the other illegal calls.
USENIX Association
26th USENIX Security Symposium    191
Actual target
Intended target
Prototype
Variadic
Non-variadic
Same
Different
Same
Different
A.T.?
Yes
No
Yes
No
Yes
No
Yes
No
Original
Overwritten Arguments
LLVM-CFI
pi-CFI
CCFI
VTV
CFG
HexVASAN


(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)


(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)








(cid:88)



















(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
Table 1: Detection coverage for several types of illegal calls to variadic functions. (cid:88) indicates detection,  indicates
non-detection. “A.T.” stands for address taken.
GCC VTV, and Visual C++ CFG allow all of the ille-
gal calls, even if the non-variadic type signature does not
match that of the intended call target.
pi-CFI allows calls to the avg_longs function from the
sum_ints indirect call site. avg_longs is address-taken
and it has the same static type signature as the intended
call target. pi-CFI does not allow illegal calls to non-
address-taken functions or functions with different static
type signatures. pi-CFI also does not allow calls to vari-
adic functions from non-variadic call sites.
All implementations of CFI allow direct overwrites of
variadic arguments, as long as the original control ﬂow
of the program is not violated.
6.2 Exploit Detection
To evaluate the effectiveness of our tool as a real-world
exploit detector, we built a HexVASAN-hardened ver-
sion of sudo 1.8.3. sudo allows authorized users to ex-
ecute shell commands as another user, often one with
a high privilege level on the system.
If compromised,
sudo can escalate the privileges of non-authorized users,
making it a popular target for attackers. Versions 1.8.0
through 1.8.3p1 of sudo contained a format string vul-
nerability (CVE-2012-0809) that allowed exactly such a
compromise. This vulnerability could be exploited by
passing a format string as the ﬁrst argument (argv[0]) of
the sudo program. One such exploit was shown to by-
pass ASLR, DEP, and glibc’s FORTIFY SOURCE pro-
tection [20]. In addition, we were able to verify that GCC
5.4.0 and clang 3.8.0 fail to catch this exploit, even when
annotating the vulnerable function with the format func-
tion attribute [5] and setting the compiler’s format string
checking (-Wformat) to the highest level.
Although it is sudo itself that calls the format string
function (fprintf), HexVASAN can only detect the vio-
lation on the callee side. We therefore had to build hard-
ened versions of not just the sudo binary itself, but also
the C library. We chose to do this on the FreeBSD plat-
form, as its standard C library can be easily built using
LLVM, and HexVASAN therefore readily ﬁts into the
FreeBSD build process. As expected, HexVASAN does
detect any exploit that triggers the vulnerability, produc-
ing the error message shown in Listing 4.
$ ln -s /usr/bin/sudo %x%x%x%x
$ ./%x%x%x%x -D9 -A
--------------------------
Error: Index greater than Argument Count
Index is 1
Backtrace:
[0] 0x4053bf  at sudo
[1] 0x405094  at sudo
[2] 0x8015dce24  at libc.so
[3] 0x8015dac52  at libc.so
[4] 0x8015daab3  at libc.so
[5] 0x40bdaf  at sudo
[6] 0x40ada3  at sudo
[7] 0x40494f  at sudo
Listing 4: Exploit detection in sudo.
6.3 Prevalence of variadic functions
To collect variadic function usage in real software,
we extended our instrumentation mechanism to collect
statistics about variadic functions and their calls. As
shown in Table 2, for each program, we collect:
192    26th USENIX Security Symposium
USENIX Association
Call sites
Func.
Ratio
18
44
7121
4183
1085
4072
37717
1460
85
3615