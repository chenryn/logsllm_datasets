Furthermore, many Java vulnerabilities only apply to spe-
ciﬁc versions of the JVM. To be able to execute samples,
even those that are available to the analysis system together
with their external input data (i.e., the aforementioned ci-
pher keys or shellcode strings), one would need to run these
samples in diﬀerent versions of the JVM, using diﬀerent en-
vironments. Jarhead does not suﬀer from this problem since
its analysis is static and environment-independent.
Another limitation for dynamic analysis systems is that
they can only learn about the part of the program that is
executed. Usually, the code coverage for one run of a pro-
gram is not complete. Additionally, due to time constraints,
dynamic analysis systems often do not wait for even one full
program run to ﬁnish. Jarhead does not suﬀer from this
limitations and analyzes the entire code.
Java bytecode was speciﬁcally designed to be veriﬁable
and easy to parse. Static analysis, therefore, works well
on bytecode, and does not suﬀer from a lot of the limita-
tions [28] common to other binary program formats, such
as computed jumps. Furthermore, a Java program does not
have the ability to dynamically generate code at runtime,
which is usually a problem for static analysis techniques.
Thus, even when attackers make use of code obfuscation, a
static analysis approach (such as the one proposed in this
paper) can obtain suﬃcient information to correctly classify
an unknown program (as our results demonstrate).
4. FEATURE DISCUSSION
This section describes the features that we extract from a
potentially-malicious Jar ﬁle and that we use in our classi-
ﬁcation process. We categorize our features and argue why
they are diﬃcult to evade.
Our features can be divided into seven categories. The
ﬁrst three categories address obfuscation; they form the
group of the obfuscation features. The other four categories
aim at exposing the purpose of an applet by statically ex-
amining its potential behavior. These four categories form
the group of behavioral features.
4.1 Obfuscation Features
Obfuscation is an important aspect for all malware to-
day. Obfuscated code diﬀers from other code because it is
generated by obfuscation kits in an automated way. These
kits chop up string constants and introduce additional state-
ments or declarations without changing the semantics of the
original code. We use diﬀerent code metrics as features
to ﬁnd diﬀerences between obfuscated and non-obfuscated
code. Of course, obfuscation alone is not suﬃcient to iden-
tify a Java program as malicious, since obfuscation kits are
also used by benign code for legitimate purposes. How-
ever, while manually examining many Java applets collected
from the Internet, we found that obfuscation is overwhelm-
ingly used by malicious applets. Furthermore we do not
rely purely on the obfuscation features but our other fea-
tures help in distinguishing benign obfuscated applets from
malicious ones.
4.1.1 Code Metrics
We collect a number of simple metrics that look at the size
of an applet, i.e., the total number of instructions and the
number of lines of disassembled code, its number of classes,
and the number of functions per class. In addition, we mea-
sure the cyclomatic complexity of the code [27].
Cyclomatic complexity is a complexity metric for code,
computed on the control ﬂow graph (CFG). It counts the
number of linearly independent paths through the code. A
code that does not have branches has cyclomatic complexity
0. If the code has exactly one branch, the cyclomatic com-
plexity would be one; if one of the two branches contains
another branch before the two paths merge, the cyclomatic
complexity would be three, and so on. A measurement is
computed per function, and we use the average of all mea-
surements as one feature.
To ﬁnd semantically useless code, we measure the number
of dead local variables and the number of unused methods
and functions. For our analysis, a variable is dead if the
251
variable is declared and deﬁned at least once, but its value
is never read (loaded) after the deﬁnition. A method or
function is unused if it is deﬁned within the applet, but
never invoked by any code within the applet.
The code metric features measure either the size of the
applet or the quality of the code. Changing the size of the
applet will either remove parts of the applet that were specif-
ically added to guard against signature-based detection or
will increase the size of the applet, and hence, increasing the
distribution cost (bandwidth, time) for campaigns. Chang-
ing the code quality requires better code obfuscation kits
(that do not simply produce dead code and variables) or
even manual obfuscation, eﬀectively raising the bar for the
eﬀort necessary to avoid detection.
String Obfuscation
4.1.2
Strings are heavily used by both benign and malicious
applets. However, the way these strings are used diﬀers
according to their purpose. While strings in benign appli-
cations are mainly used to display text to the user, strings
in malicious applets are used for obfuscation and to store
machine-readable shellcode. Such strings are often chopped
up and stored in the data section of the applet, and then re-
constructed at run time, to be used as function arguments,
class names, function names or ﬁle names. The reason for
string obfuscation is to defend against signature-based sys-
tems. We have features to model the length of strings in
the constant pool, their number, and the fraction of strings
that contain characters that are not ASCII printable. For
the length feature, we determine the length of the shortest
and longest string in the pool as well as the average length
of all strings.
4.1.3 Active Code Obfuscation
The features in this category characterize code constructs
that are often used to thwart static code analysis. These
constructs are diﬀerent in that they do not attempt to hide
strings (or code fragments) from manual analyst or signature-
based systems, but, instead, try to mislead static analysis.
To counter code analysis techniques that check for the in-
vocation of known vulnerable library functions within the
Java library, malicious applets frequently use reﬂection, a
part of the Java language that allows for a program to mod-
ify its structure and behavior at runtime, to invoke these
functions indirectly. Other (malicious) applets use reﬂec-
tion to instantiate objects whose type cannot be determined
statically.
If an object type is not known, it is generally
impossible to statically decide which method is called on it.
Additionally, malicious applets sometimes dynamically load
parts of the exploit at runtime or use a key, passed in as
a parameter, to decrypt shellcode. To detect such activity,
we count the absolute number of times reﬂection is used in
the bytecode to instantiate objects and to call functions. In
addition, we check if the Java.io.Serializable interface is
implemented by any of the classes belonging to the applet.
The reason is that some malicious applets load a serialized
object at runtime that contains otherwise hidden parts of
the exploit.
In addition to using reﬂection, some malicious applets
avoid instantiating objects (instances) of speciﬁc types (sub-
classes) altogether. While there is some legitimate use for
instantiating instances of the base class java.lang.Object,
this is not very common in benign applets, as programmers
do not want to lose the beneﬁts of a strongly-typed language.
We check if arrays or single instances of java.lang.Object
or java.lang.Class are instantiated.
It is also possible to interpret JavaScript from within ap-
plets, via a Java library routine. This is highly uncommon
in benign applets, but used by malicious ones to carry out
general purpose computation outside the scope of most Java
analysis tools. Therefore, we check if the JavaScript inter-
face is used.
4.2 Behavioral Features
The overwhelming majority of applet malware has a spe-
ciﬁc purpose: Escaping the Java sandbox to infect the end
user’s machine and make it a member of a botnet. The
features in this section aim at statically identifying this be-
havior.
Interaction with Runtime and Security System
4.2.1
As described previously, the JVM sandbox restricts ap-
plets by limiting the accessible resources. Several vulnera-
bilities in diﬀerent versions of the Sun Java plugin have led
to exploits that bypass the sandboxing mechanisms. Most of
these exploits need to interact with the Java security mech-
anisms in diﬀerent ways to be successful. Therefore, we
collect features related to these security mechanisms. More
precisely, we check if an applet calls into the Java runtime
system (by using the Runtime class), interacts with the sys-
tem security manager, or accesses system properties. We
also check if the applet uses the System class to load addi-
tional code from the client system. Furthermore, we check
whether the applet extends the ClassLoader class in an at-
tempt to introduce its own class loader, or implements the
ClassLoaderRepository, SecurityPolicy, or Privileged-
Action interfaces. These mechanisms are used to elevate
applet privileges at runtime and can introduce code that
runs without sandbox restrictions.
Features that cover these sensitive core classes of the Java
security mechanisms allow for anomaly detection of new ex-
ploits. The reason is that it is likely that new exploits will
need to use these mechanics in some way to break out of the
sandbox.
4.2.2 Download and Execute
We characterize the download behavior of applets by check-
ing whether java.net.URL objects are instantiated or sock-
ets are used. We also check for the use of functions that are
able to write ﬁles. For a successful exploit, it is necessary
to execute a ﬁle after it has been downloaded. There exist
a number of diﬀerent ways in which the Java library API
can be used to spawn a new process from a binary, e.g., by
using the java.awt.Desktop class, or, again, the system in-
terface. We have manually inspected all classes known to us
that are able to spawn a new process and collected the API
functions implementing this functionality. Since this kind
of functionality is oﬀered only by the Java library, we con-
sulted its documentation for the relevant classes and listed
the functions. We check if any of these functions are poten-
tially used.
By detecting all known possible ways for an applet to
spawn a new process, we make it impossible for malicious
applets to achieve this without triggering the corresponding
detection feature.
252
Jar Content
4.2.3
Benign applets are usually written with the goal of dis-
playing something to the visitor of a web page or to play
audio. Typically, the ﬁles necessary to do so (media ﬁles,
images, . . . ) are included in the Jar archive. We count the
number of ﬁles in the Jar that are not Java class ﬁles. Fur-
thermore, we check all ﬁles in the archive to see if any of
them contain binary machine code, i.e., if there is an exe-
cutable or library. In addition, we use the total size of the
Jar archive in bytes as a feature.
These features characterize benign properties rather than
malicious ones. An attacker who attempts to mimic the
structure of legitimate Jar archives is forced to increase the
size of the exploit, which raises the distribution costs for
successful campaigns.
4.2.4 Known Vulnerable Functions
Finally we also compiled a set of ﬁve well known vul-
nerable components of the Java library: Three individual
functions, a combination of two functions, and one inter-
face. The ﬁrst two functions are MidiSystem.getSoundbank
and the constructor for javax.management.remote.rmi.-
RMIConnectionImpl. We will discuss the third function sep-
arately, since it needs some more explanation. The combina-
tion of functions is MidiSystem.getSequencer, and Sequencer-
.addControllerEventListener. Additionally, the javax.-
management.MBeanServer interface can be implemented by
an applet to exploit a known vulnerability.
The third, individual function that we check for is usually
used in MIDlet scams. MIDlets are applications that use
the Mobile Information Device Proﬁle (MIDP) of the Con-
nected Limited Device Conﬁguration (CLDC) for the Java
Micro Edition, typically used on cellular phones. Most of
these MIDlets implement games or display a speciﬁc web
page to the user. A vulnerability existed in certain phones
that allowed tricking the user into sending text messages to
expensive pay-per-call numbers. To this end, attackers had
to call the text message send function of Java ME: Message-
Connection.send. Note that apart from that speciﬁc vul-
nerability, there are a lot of MIDlets trying to trick the user
into sending SMS by social engineering means. Java ME is
no longer used in modern smart phones, such as the iPhone
or Android. Older phones are not very valuable targets for
infection, except for the mentioned text message scam.
Exploits that target well-known, vulnerable Java library
functions have to call the aforementioned functions to be
successful. We introduced ﬁve Boolean features, each of
which is set to true if we ﬁnd at least one call to one of the
three functions, the combination of the two functions, or a
class that implements the vulnerable interface. Of course,
these functions (and interfaces) also serve a legitimate pur-
pose. However, we found that they are rarely used by benign
applets (and our other features help in making this distinc-
tion). To assert this we looked at more than 200 benign
applets manually, we decompiled them and inspected their
source code to check for malicious behavior and whether the
description (if available) of their intended purpose matched
what we found in the code. The benign applets we looked
at were from a random crawl of the Internet, and two sites
oﬀering collections of applets. These data sets are described
in more detail in the evaluation chapter. Their rare usage
probably also indicates that they were not well-tested in the
ﬁrst place and thus the vulnerabilities were overlooked. If
more vulnerable functions were to be added to this set later
on, we would expect them again to be somewhat obscure and
rarely used by benign applets. These few functions provide
a way to break out of the sandbox without user interaction
in vulnerable Java versions.
4.3 Feature Discussion
Jarhead collects a total of 42 features: Six are numeric
(real values), ten are integers, and the remaining 26 are
Boolean values. In the following paragraphs, we argue that
our features are robust, in the sense that they make it diﬃ-
cult for an attacker to evade our analysis, while still achiev-
ing his goal. Furthermore we examine the usefulness of in-
dividual feature groups and list our top ten features.
Our features fall into two categories that capture both
the behavioral and the obfuscation aspects of malicious ap-
plets. If an attacker tries to evade the obfuscation features,
he will more likely be caught by traditional signature-based
detection systems. An eﬀort could be made to improve ob-
fuscation techniques to match the code metrics of benign
code very closely. However, in the presence of shellcode de-
tection systems [12, 14], the shellcode within the applets,
which is typically encoded in strings, needs to be well hid-
den. Furthermore, while active obfuscation techniques, such
as reﬂection, are limiting static analysis, their use is not com-
mon in benign applications and hence, might even serve as
indicators for maliciousness.