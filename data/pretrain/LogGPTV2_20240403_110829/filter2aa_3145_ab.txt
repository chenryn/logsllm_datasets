Figure 10: precision.xml 
An XSLT v1.0 associated document will report the sum of the previous values: 
Figure 11: precision.xsl (XSLT v1.0) 
The result should be the 0. However, certain processors may not be able to calculate this correctly.  
Safari, Firefox and Internet Explorer are not able to obtain the correct result. A similar situation happens 
with server side processors: 
© 2015 IOActive, Inc. All Rights Reserved.  [13] 
Figure 12: Output using server side processors  
There were no server side processors capable of providing the expected value. 
processor 
result 
server 
xalan-c (apache) 
errors 
xalan-j (apache) 
errors 
saxon 
errors 
xsltproc 
errors 
php 
errors 
python 
errors 
perl 
errors 
ruby 
errors 
client 
safari 
errors 
opera 
ok 
chrome 
ok 
firefox 
errors 
internet explorer 
errors 
© 2015 IOActive, Inc. All Rights Reserved.  [14] 
Table 3: loss of precision with large integers 
Recommendation 
Use an XSLT v1.0 processor capable of performing operations with real numbers2. It is worth noting 
that XSLT v1.0 processors that are capable of processing real numbers will not be able to process large 
integers. Another possibility is to use an XSLT v2.0 processor with the function xs:decimal to avoid 
loss of precision3.  
2 CWE-682: Incorrect Calculation (http://cwe.mitre.org/data/definitions/682.html) 
3 XML Schema Part 2: Datatypes Second Edition (http://www.w3.org/TR/xmlschema-2/#decimal) 
© 2015 IOActive, Inc. All Rights Reserved.  [15] 
Insecure Random Numbers 
Since there is no specification by the World Wide Web Consortium (W3C) about how random functions 
should be implemented, they have been developed as part of the Extensions for XSLT (EXSLT). 
Therefore, implementations have different interpretations on how to perform the same function. 
Pseudorandom values are not secure 
Xalan-C, Xalan-J and Saxon use an IV for their random function. Nevertheless, the three of them are 
using a non-secure pseudo random number generator. This is not by itself an insecure behavior as long 
as the Math:random() function is not used for security-sensitive applications. 
1. Xalan-C uses srand() from C++. The man page for srand() defines the functions as a "bad 
random number generator". Here is the random function for Xalan-C: 
Figure 13: Xalan-C random function in xalan-c-1.11/c/src/xalanc/XalanEXSLT/XalanEXSLTMath.cpp 
2. Xalan-J and Saxon use java.lang.Math.random() from Java. The Java documentation 
recommends using “SecureRandom to get a cryptographically secure pseudo-random number 
generator for use by security-sensitive applications”. Following are the random() functions 
from Xalan-J and Saxon. 
Figure 14: Xalan-J random function in xalan-j_2_7_2/src/org/apache/xalan/lib/ExsltMath.java 
© 2015 IOActive, Inc. All Rights Reserved.  [16] 
Figure 15: Saxon random function in saxon9-6-0-6source/net/sf/saxon/option/exslt/Math.java 
All XSLT implementations rely on pseudorandom numbers generators and their outputs are not to be 
used for sensitive information. 
No initialization vector (IV) 
A Pseudo Random Number Generator (PRNG) begins with a certain seed value. Libxslt does not 
implement a default seed value for its random functionality. 
The following is a sample random.xsl file, which will output a value obtained from Math:random(): 
   &#xa; 
Figure 16: random.xsl 
This is an example set of two outputs using the latest version of xsltproc: 
Figure 17: Random output using the same IV 
© 2015 IOActive, Inc. All Rights Reserved.  [17] 
Notice how the xsltproc output remains the same execution after execution. This is a result of the fact 
that the random() function always uses the same seed. If the random function is used as a Cipher 
Block Chaining (CBC), not using a random initialization Vector (IV) will cause algorithms to be 
susceptible to dictionary attacks. 
When using LXML with Python, you will obtain that same result as in the first execution. After that, the 
next results will be different than the first one. However, the same values will be produced execution 
after execution unless time is used as part of the seed.  
Recommendation 
Firstly, if cryptographically secure numbers are required4 do not use XSLT. Secondly, if different values 
are required every time the XSLT is being processed, remember to define a different IV value in case 
using libxslt5.  
4 CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator 
(http://cwe.mitre.org/data/definitions/338.html) 
5 CWE-329: Not Using a Random IV with CBC Mode (http://cwe.mitre.org/data/definitions/329.html) 
© 2015 IOActive, Inc. All Rights Reserved.  [18] 
Same-Origin Policy Bypass 
An origin is defined by the scheme, host, and port of a URL. Generally speaking, documents retrieved 
from distinct origins are isolated from each other. For example, if a document retrieved from 
http://example.com/doc.html tries to access the DOM of a document retrieved from 
https://example.com/target.html, the user agent will disallow access. The origin of the first document 
(HTTP scheme, host example.com, and port 80) does not match the scheme and port of the second 
document (HTTPS scheme, host example.com, port 443) . 
Safari is able to process XML and XHTML files, which can then be manipulated using XSLT v1.0 
functionalities. By making use of the XSLT function document(), it is possible to access well-formed 
XML documents other than the main source document. Safari permits the main document to access 
cross-origin URL addresses using their corresponding cookies. Information from third-party websites 
can be retrieved using the XSLT function document(), and then analyzed using the functions value-
of() and/or copy-of(). Finally, the information can be manipulated using JavaScript and sent back 
to an attacker.  
In the following proof of concept code, an attacker uses a local XHTML file containing an in-line XSLT 
document referencing the same document (line 3). This document defines a URL element (line 93) 
which is opened with the document() function (line 38) and the context is exposed using the functions 
value-of (line 53) and copy-of (line 66). Finally, the contents are further manipulated using 
JavaScript (lines 81-84)6. 
  2   
  3  
  4  
  5  
  6    
  7      
  8    
  9  
 10    
 11      
 12        
 13          
 22         IOActive - XOSS (Cross Origin Site Scripting) 
 23        
 24        
 25         IOActive - XOSS (Cross Origin Site Scripting) 
6 CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') 
(http://cwe.mitre.org/data/definitions/79.html ) 
© 2015 IOActive, Inc. All Rights Reserved.  [19] 
 26          
 27          
 28            
 29          
 30        
 31      
 32    
 33  
 34    
 35  
 36    
 37      
 38        
 39        
 40          
 41           URL: 
 42          
 43          
 44            
 45          
 46        
 47        
 48          
 49           &lt;xsl:value-of&gt; 
 50          
 51          
 52            
 53              
 54            
 55          
 56        
 57        
 58          
 59          &lt;xsl:copy-of&gt; 
 60          
 61          
 62            
 63              
 64               &lt;![CDATA[ 
 65              
 66              
 67              
 68              ]]&gt; 
 69              
 70            
 71          
 72        
 73        
 74          
 75           Accessing private 
 76            information from: 
 77          
 78          
 79          
 80          
 86          
 87         
© 2015 IOActive, Inc. All Rights Reserved.  [20] 
 88      
 89      
 90    
 91  
 92    
 93     http://www.bing.com/account/general 
 94    
 95  
 96  
Figure 18: cross-origin.xhtml 
The following steps will read cross-origin information from www.bing.com: 
1) 
Log in www.bing.com (if you already have a valid cookie, this step is not required) 
2) 
Open cross-origin.xhtml 
Figure 19: Reading Information from Bing 
The previous code outputs three text areas: 
• 
: a text representation of the web page 
http://www.bing.com/account/general when using the user's cookie 
• 
: an XML representation of the web page 
http://www.bing.com/account/general when using the user's cookie 
• 
Accessing private information from: the name of the user logged in bing.com 
Recommendation 
Do not allow violations to the same-origin policy. 
© 2015 IOActive, Inc. All Rights Reserved.  [21] 
Information Disclosure (and File Reading) through 
Errors 
Malformed XSLT documents will terminate an execution once they detect an error. This is the same 
behavior observed for malformed XML documents: the specification defines strict rules, and on fatal 
errors, no more data should be processed.  
Errors can provide useful information about what has gone wrong. Users or developers may find this 
information useful when working with XML and style sheets. These messages may indicate which file is 
corrupted, in which line the problem lies, and eventually what the error is. The error messages depend 
on the functionality and the application being tested. Certain functions—and applications—may be 
prone to provide more interesting information than others. Most web browsers have their own additional 
restrictions, which may not be present in XSLT processors.  
There are three functions that can be used to read files: 
• 
document(): is used to access information contained in other XML documents.  
• 
include(): allows stylesheets to be combined without changing the semantics of the stylesheets 
being combined 
• 
import(): allows stylesheets to override each other 
The following XML document references in the element file the value /etc/passwd and it will use an 
XSLT defined in the first line: 
/etc/passwd 
Figure 20: Document Containing “/etc/passwd” Reference 
The following style sheet is the one being referenced by the previous document. It contains a reference 
to the document() function and it will attempt to output its content using the value-of functionality: 
Figure 21: Style Sheet using document() 
© 2015 IOActive, Inc. All Rights Reserved.  [22] 
The previous style sheet will try to access the file /etc/passwd using the document() function. 
Since this file is not an XML document, it should not be possible. But the good thing is that it will output 
an unexpected error message. This is the output produced by xsltproc: 
Figure 22: Error Message Containing First Line of “etc/passwd” 
Once the first line of the file /etc/passwd is read, the processor stops execution after not being able 
to find a valid XML starting tag. Next, the processor outputs an error message containing the first 80 
characters of the malformed line: the encrypted root password. A similar behavior can also be observed 
when using import() or include(). 
The following example, shows Ruby (using the Nokogiri library) exposing information when using 
import(): 
If an attacker is only able to read one single line of a file, the following files may be interesting to read: 
• 
/etc/passwd: root linux password 
• 
/etc/shadow: root linux password 
• 
.htpasswd: used by Apache to store information in the form of username:password 
• 
.pgpass: used by PostreSQL to store information in the form of 
hostname:port:database:username:password 
This type of vulnerability is more potentially exploited on server side processors. When it comes to 
client side processors, only Firefox is vulnerable. However, it must be noted that it cannot read files that 
are below the directory where the XSLT is. 
processor 
document() 
import() 
include() 
server 
xalan-c (apache) 
no 
no 
no 
xalan-j (apache) 
no 
no 
no 
saxon 
no 
no 
no 
xsltproc 
yes 
yes 
yes 
php 
yes 
yes 
yes 
python 
no 
no 
no 
perl 
yes 
yes 
yes 
ruby 
no 
yes 
yes 
client 
safari 
no 
no 
no 
opera 
no 
no 
no 
chrome 
no 
no 
no 
© 2015 IOActive, Inc. All Rights Reserved.  [23] 
firefox 
no 
no 
yes 
internet explorer 
no 
no 
no 
Table 4: reading first line 
Recommendation 
Do not disclose information about files when presenting error messages, it is not required.
© 2015 IOActive, Inc. All Rights Reserved.  [24] 
About Fernando Arnaboldi 
Fernando Arnaboldi is a senior security consultant at IOActive specialized in code reviews and penetration tests. 
About IOActive 
IOActive is a comprehensive, high-end information security services firm with a long and established pedigree in 
delivering elite security services to its customers. Our world-renowned consulting and research teams deliver a 
portfolio of specialist security services ranging from penetration testing and application code assessment through to 
semiconductor reverse engineering. Global 500 companies across every industry continue to trust IOActive with 
their most critical and sensitive security issues. Founded in 1998, IOActive is headquartered in Seattle, USA, with 
global operations through the Americas, EMEA and Asia Pac regions. Visit www.ioactive.com for more information. 
Read the IOActive Labs Research Blog: http://blog.ioactive.com. Follow IOActive on Twitter: 
http://twitter.com/ioactive.