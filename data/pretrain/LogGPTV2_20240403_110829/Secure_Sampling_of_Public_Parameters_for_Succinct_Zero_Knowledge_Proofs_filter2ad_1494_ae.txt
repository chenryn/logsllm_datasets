broadcast protocol with n parties for C over G.
• T1 builds a new circuit ˜C is not much larger than C:
– depthE( ˜C) = n · depthS(C);
– size( ˜C) = O(n · size(C)); and
– size( ˜C, i) = O(size(C)) for i = 1, . . . , n.
• T2 increases the protocol’s round complexity by 1, and
preserves all time complexities up to Oλ(1) factors.
Lemma IV.3 (Evaluation protocol). Assume the existence
of commitment schemes and NIZKs. Let r be a prime
and G a group of order r. There is a secure evaluation
broadcast protocol ΠE = (Π, V, S) for CE over G such
that, for every positive integer n and circuit C in CE:
• ROUND(Πn,C) = depthE(C) + 2;
• TIME(Πn,C, i) = Oλ(size(C, i)) for i = 1, . . . , n;
• Vn,C and Sn,C run in time Oλ(size(C)).
A. Sketch of the sampling-to-evaluation reduction
We sketch the proof of Lemma IV.2. At a high level, the
two transformations T1 and T2 work as follows.
• The circuit transformation T1, given the number of par-
ties n and a circuit C in CS, outputs a circuit ˜C ∈ CE
that computes C’s output, along with other auxiliary
values, by suitably combining n multiplicative shares
of C’s input.
• The protocol transformation T2, given a secure eval-
uation protocol ΠE for ˜C, outputs a secure sampling
protocol ΠS for C by:
(i) generating random shares
for all inputs, to ensure uniform sampling; (ii) ex-
tending the protocol by one last round, to obtain a
correctly-formatted output; (iii) extending the veriﬁer,
to account for the additional round in the transcript;
and (iv) extending the simulator, to account for the
different ideal functionality, whose output excludes the
aforementioned auxiliary values (which, hence, must
be simulated).
Most of the effort goes into constructing ˜C and the
simulator of ΠS. We thus brieﬂy discuss these two.
The circuit ˜C. The circuit ˜C must compute C’s output
from n multiplicative shares of C’s input (chosen at
random). If this were the only requirement, then we
could simply set ˜C equal to the circuit that, given as
input n shares (cid:4)α(1), . . . , (cid:4)α(n) ∈ Fm, ﬁrst combines the
m ) ∈ Fm and
shares into (cid:4)α := (
then computes C((cid:4)α). Unfortunately, such a circuit is not
in the class CE, and thus we cannot invoke Lemma IV.3
to securely evaluate ˜C (and do not know how to
obtain an efﬁcient protocol that does). The difﬁculty
thus lies in constructing a circuit ˜C that computes the
same function (perhaps with some additional, though
simulatable, outputs) and that, moreover, is in CE.
j=1 α(j)
1 , . . . ,
n
j=1 α(j)
(cid:2)
(cid:2)
n
We thus take an alternative approach, which leverages
the fact that C lies in the class CS. Intuitively, instead of
combining shares at the beginning, ˜C combines shares
“on the ﬂy”, as the circuit is computed, as we now
describe.
First consider the simple case where C has no non-
trivial addition gates, i.e., all gates are either multiplica-
tion gates or addition gates that output a constant. Our
reduction then outputs a circuit ˜C that contains n copies
of C as a sub-circuit (one for each party) such that
the #inputs(C) inputs of each copy are assigned to a
separate input slot of ˜C; corresponding outputs of each
copy are then multiplied together, thereby combining the
shares, via O(n · #outputs(C)) auxiliary multiplication
gates. See Figure 3a for an example.
More generally, of course, C may include addition
gates and, in such a case, the reduction is more complex,
297297
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:02:37 UTC from IEEE Xplore.  Restrictions apply. 
10
ܽ ܾ
ܿ
 
 

ܽଵ ܾଵ ܿଵ
1
10
 
ܶଵ
 
 
 
 
 
 

ܽଶ ܾଶ
 
ܿଶ
 
 
5
ܽ
 
 
 
ܾ
ܿ
 
݀
 

5 ܽଵܾଵܿଵ݀ଵ
1
ܽଶܾଶ

ܿଶ݀ଶ
 
 
 
ܶଵ
 
 
 
 
 
1
 
 
 
 
 
(a) Example where C has only multiplication gates.
(b) Example where C has both addition and multiplication gates.
Fig. 3: Two examples of a circuit C in CS and the corresponding circuit ˜C := T1(C, n) in CE for n = 2 parties.
The blue arrows in C denote the output wires of C; the blue arrows in ˜C denote the output wires of ˜C that compute
outputs of C (while the remaining output wires carry partial computations).
because merely individually evaluating n copies of C
and then combining corresponding outputs does not
compute the correct function. The reason is not surprising:
while multiplicative sharing of inputs commutes with
multiplication, it does not commute with addition, and
thus it is hard to obtain multiplicative shares of the result
of an addition. To circumvent this problem, we break the
circuit down into components “separated” by additions,
and apply the above idea separately to each. In-between
components, before each addition, we combine shares.
In somewhat more detail, our construction works as
follows. For each multiplication gate gmul of C, we add
to ˜C a sub-circuit, consisting of O(n) multiplication
gates, that combines a value computed so far with all
the shares of gmul’s right input (which is, by deﬁnition
of CS, an input of C). For each addition gate gadd of C,
we add one addition gate to ˜C that combines the values
computed so far. Crucially, each of these sub-circuits, as
well as their combination, lies in CE. See Figure 3b.
A notable efﬁciency feature of our reduction is that
it ensures that the E-depth of ˜C, which determines the
number of rounds required to securely evaluate ˜C, is
“small”: it is bounded above by n times the S-depth
of C. Indeed, there are multiple ways to combine the
aforementioned sub-circuits, but many such ways yield
much worse efﬁciency, e.g., E-depth that is as worse as
n times the (standard) depth of C. Since the circuits
C that we encounter in this paper’s application have a
small S-depth, this feature is critical.
The simulator in ΠS. The construction of ˜C must
not only respect syntactic and efﬁciency requirements
(e.g., lie in CE, not have more than n · size(C) gates,
and so on), but must also be secure, in the sense that
the ideal functionality implemented by the evaluation
protocol ΠE for ˜C actually gives rise (with some simple
changes) to a sampling protocol ΠS that implements the
ideal functionality of C. Since our construction of ˜C
introduces additional, spurious outputs, the simulator in
ΠS must be able to reproduce the view of the adversary
when only having access to C’s output (rather than ˜C’s
output). Intuitively, this requires showing that partial
computations that carry information about a subset of
the parties’ shares do not leak additional information
beyond the outputs that incorporate every party’s share.
For an arbitrary circuit in CE such an argument cannot
be carried out. However, for the particular circuit ˜C that
is constructed from C we show that it is possible to
“back compute” the circuit: given the output of C, the
simulator can complete it into an output of ˜C by sampling
an assignment to the remaining (spurious) output wires
of ˜C, such that the simulated output is indistinguishable
from an evaluation of ˜C. This is done by taking each sub-
circuit in ˜C and computing backwards from its output.
B. Sketch of the evaluation protocol
We sketch the proof of Lemma IV.3. The evaluation
protocol ΠE = (Π, V, S) for C ∈ CE works as follows.
• In the ﬁrst round (t = 1), each party i individually
commits to each one of his own private inputs,
i.e., each party i commits to the values assigned to
wires in inputs(C, i), and proves, in zero knowledge,
knowledge of the committed values (using relation
RA of Figure 4).
• In each one of the subsequent depthE(C) rounds (t =
2, . . . , depthE(C)+1), each party i determines if there
are any gates g in gates(C) such that
(i) the E-depth
of output(g) equals the round number minus 1 (i.e,
t − 1), and (ii) if type(g) = mul then R-input(g)
depends only on inputs in inputs(C, i). If so, then party
i individually evaluates each such gate (in topological
order) and broadcasts the result, along with a zero-
knowledge proof that the evaluation was correct (using
relation RB of Figure 4). In this way, the parties prove
correct evaluation of all gates of C, ﬁrst processing
298298
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:02:37 UTC from IEEE Xplore.  Restrictions apply. 
all gates whose outputs have E-depth 1, then all those
whose outputs have E-depth 2, and so on.
• After depthE(C) such rounds,
in the last round
(t = depthE(C) + 2), party 1 consults the broadcast
messages so to gather, and broadcast in a single
message, the encoding of the value of every output
of C. The purpose of this last round is to construct
a syntactically well-formed output of the protocol;
tasking party 1 to do so is an arbitrary choice.
Since the circuit C belongs to the circuit class CE, by
deﬁnition of CE, whenever a party i is supposed to prove
correct evaluation of a gate g:
(i) if g is an addition
gate, then encodings for g’s inputs have been broadcast
in previous rounds, and (ii) if g is a multiplication gate,
an encoding for g’s left input has been broadcast in
previous rounds (or computed by i in this round) and i
knows the value for its right input. In either case, party
i can compute an encoding for g’s output, and knows a
witness to the NP statement that attests to this encoding’s
correctness. Moreover, note that, again since C belongs
to CE, every gate’s output wire is also an output wire of
C, so that broadcasting encodings of every gate’s output
does not leak information beyond what is leaked by the
output of the ideal functionality, C((cid:4)σ) · G.
The transcript of broadcast messages can be checked
by a veriﬁer V , by ensuring that input commitments carry
valid proofs and, for each gate, that the party responsible
for that gate has produced valid proofs for its evaluation
(based on suitable prior values); this ensures that the
circuit has been evaluated on the parties’ private inputs.
Moreover, the transcript can be generated by a simulator
S, having access to the encoding of the circuit’s output,
by simulating each proof of correct evaluation.
V. OPTIMIZATIONS FOR DUPLEX-PAIRING GROUPS
The use of NIZKs in Theorem IV.1 is “light”: the
sampling protocol uses NIZKs for two relations, denoted
RA and RB and deﬁned in Figure 4, that involve only
arithmetic in G and invocations of the commitment
veriﬁer COMM.Ver. While the theorem holds for any
choice of prime-order group G, we obtain a particularly-
efﬁcient instantiation when G is a duplex-pairing group
of order r; our implementation and evaluation target
this special case, which occurs, e.g., in the setting of
public-parameter generation for zk-SNARKs.
Strategy. The sampling protocol of Theorem IV.1 is
obtained in two steps: a reduction from sampling to
evaluation (Lemma IV.2), and an evaluation protocol
(Lemma IV.3). The reduction is efﬁcient, so we focus on
optimizing the evaluation protocol, by suitably instanti-
ating the commitment scheme and NIZKs for RA and
RB. This instantiation relies on random oracles.
299299
Choice of commitment scheme. We instantiate the
commitment scheme COMM with Pedersen commit-
ments [49]. Let P and Q be two generators of G,
for which there is no known linear relation (if G is
an elliptic curve group then such P and Q can be
found by applying point decompression to two random
strings, or heuristically, to SHA256(0) and SHA256(1)).
A Pedersen commitment cm for a value x is obtained
by letting cr be a random element of Fr and computing
cm := x · P + cr · Q.
Choice of NIZK for the relation RA. To prove knowl-
edge of a committed value x encoded in a commitment
cm, we use an adapted version of Schnorr’s protocol
[69] for zero-knowledge proof-of-knowledge of discrete
logarithm. In the interactive version of the protocol, the
prover ﬁrst chooses random α and β in Fr and produces
R = α·P +β·Q. The veriﬁer responds with a uniformly
sampled element c of Fr, to which ﬁnal prover message
is u := α + c · x, v := β + c · cr. The veriﬁer accepts iff
u · P + v · Q = R + c · cm. The protocol is made non-
interactive by applying Fiat–Shamir heuristic [47] (in
our concrete implementation, using SHA256 hashing).
Choice of NIZK for the relation RB. We ﬁnd that
in our implementation we only need a special case of
the relation RB. For this special case what needs to be
proved are the following two kinds of statements:
1) that a multiplicative relationship holds between a