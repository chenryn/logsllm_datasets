title:Permission Set Mining: Discovering Practical and Useful Roles
author:Dana Zhang and
Kotagiri Ramamohanarao and
Tim Ebringer and
Trevor Yann
2008 Annual Computer Security Applications Conference
2008 Annual Computer Security Applications Conference
Permission Set Mining: Discovering Practical and Useful Roles
Dana Zhang
Kotagiri Ramamohanarao
Tim Ebringer
The University of Melbourne
PI:EMAIL
The University of Melbourne
The University of Melbourne
PI:EMAIL
PI:EMAIL
Trevor Yann
CA Labs
PI:EMAIL
Abstract
Role based access control is an efﬁcient and effective
way to manage and govern permissions to a large number
of users. However, deﬁning a role infrastructure that accu-
rately reﬂects the internal functionalities and workings of
a large enterprise is a challenging task. Recent research
has focused on the theoretical components of automated
role identiﬁcation while practical applications for identify-
ing roles remain unsolved.
This research proposes a practical data mining heuristic
method that is fast, scalable and capable of identifying com-
prehensive roles and placing them into a hierarchy. Per-
mission set pattern data mining can be used to identify the
roles with partial orderings that cover the largest portion
of user permissions within a system. We test the algorithm
on real user permission assignments as well as on gener-
ated data sets. Roles identiﬁed in test sets cover up to 85%
of user permissions and analysis show the roles offer sig-
niﬁcant administrative beneﬁt. We ﬁnd interesting correla-
tions between roles and their relationships and analyse the
tradeoffs between identifying roles with complete coverage
to identifying roles that are most effective and offer signiﬁ-
cant administrative beneﬁt.
1. Introduction
Since its original formalization [6], Role Based Access
Control (RBAC) has become recommended practice for se-
curity control in large enterprise environments. In this se-
curity model, permissions are no longer assigned individu-
ally to users, but as sets of permissions through roles. This
change in how permissions are administered often reduces
the number of associations that need to be managed which
has been a key factor behind its popularity in industry [7].
However, initial implementation poses problems when
there is no concrete understanding of how best to set up the
RBAC conﬁguration. As a solution to creating a compre-
hensive framework for deﬁning the architectural structure
of RBAC, role engineering was introduced [3]. This role
engineering solution is also useful for systems that have
RBAC implemented, verifying the existing structure or of-
fering recommendations for a new structure.
Initial role engineering techniques that involve only user
analysis [5, 13, 14] are time consuming and costly. As a
result, the move has been towards more automated tech-
niques [10, 15, 17] for role identiﬁcation, reducing the
amount of user input required. Recent studies have analysed
the theoretical aspects of role engineering [4, 11, 16, 18] and
the problem of ﬁnding a minimal set of descriptive roles as
well as its variants have been shown to be NP-complete and
difﬁcult to approximate.
Finding practical solutions complements the theoretical
understanding of the problem, however, problems in ap-
plication still remains largely unsolved. Due to the nature
and computational complexity of automated role extraction,
heuristic approaches offer the best solutions for role engi-
neering. Both data mining and graph approaches have been
proposed but many open issues remain unaddressed.
Existing data mining approaches place assignment con-
straints onto roles before mining processes can proceed [10,
15, 17]. Constraints include limiting the number of roles a
user can be assigned or placing limits on the allowable per-
missions within a role. These processes often generate a
large number of candidate roles, more than would be re-
quired for a reasonable RBAC implementation. Graph algo-
rithms place users and permission as nodes and their rela-
tionships as edges into a graph [4, 18]. In certain situations,
the minimum number of roles required to represent all per-
missions assignments can be found while local minimums
for role count are extracted in most other situations. Re-
cent experimental analysis show the minimum number of
roles required to cover all permission assignments exactly
1063-9527/08 $25.00 © 2008 IEEE
1063-9527/08 $25.00 © 2008 IEEE
DOI 10.1109/ACSAC.2008.21
DOI 10.1109/ACSAC.2008.21
247
247
is often similar to the number of permissions or the number
of users [4]. This is not practical for any reasonable RBAC
implementation.
These existing approaches, both data mining and graph
based, include all permission assignments within a system
to generate candidate roles. Theoretical analysis have sug-
gested that it may be an acceptable trade-off to allow a small
portion of the permissions to be considered exceptions if a
high percentage of permissions is still covered by roles and
if doing so signiﬁcantly improves the quality of the roles
that need to be created [16]. No practical work has yet been
done in this area and to our knowledge, we will be the ﬁrst
to implement such a technique.
In this paper, we propose a Permission Set Mining
heuristic for generating roles that cover the largest portion
of user assignments. These roles are more practical and
useful as they offer signiﬁcant administrative beneﬁts. The
proposed approach uses efﬁcient search algorithms to iden-
tify candidate roles without the role to permission and user
to role constraints inherent in existing approaches. Using
the a priori principle of pattern extraction, our approach
for role extraction can produce a natural ordering on roles
to assist the hierarchy construction process that some ap-
proaches currently lack. Permission set mining is tested on
real data within an organisational environment as well as on
simulated test data. The results are analysed and interesting
correlations between roles and role relationships as well as
role signiﬁcance and role quantity are presented.
The remainder of the paper is organised as follows. Sec-
tion 2 will give background and an overview of related work
in this area. The limitations in existing applications for role
engineering drives our motivation and Section 3 proposes
our application of data mining for role engineering and how
it can be used to extract roles and deﬁne a role hierarchy.
A summary of our experimental results on real and simu-
lated data is discussed in Section 4. This is followed by
Section 5, an analysis of our approach and future improve-
ments. We discuss our ﬁndings and offer interesting insight
into automated role extraction that has not been previously
addressed. Finally, Section 6 concludes the paper by giving
an overview of our contributions and ﬁndings.
2. Background
The problem of role engineering was ﬁrst discussed by
Coyne [3] which led to the initial top down process ori-
ented approaches for role deﬁnition.
Job functionalities,
documented processes, usage scenarios as well as use cases
were used to determine access rights [5, 13, 14]. However,
user interaction based derivation of roles requires signiﬁ-
cant user input before deﬁned concepts can be aggregated
to roles.
The problem grows in complexity with the size of the
organisation, making top down approaches impracticable in
medium to large size enterprises. As a result, the focus has
now turned to bottom up role engineering that analyses ex-
isting user permission assignments to automate the extrac-
tion of roles.
The majority of bottom up approaches have used role
mining:
the application of data mining techniques for
role deﬁnition. One of the ﬁrst role mining proposals by
Kuhlmann et al. [10] was created for Security Administra-
tion Manager (SAM), an enterprise security tool for RBAC
implementation. The SAM Role Miner combined associa-
tion mining with demographic clustering to produce an in-
teractive reﬁning process for creating roles without a hier-
archy.
In consideration of automated role hierarchy generation
for more general purpose systems, Schlegelmilch et al. pro-
posed ORCA [15], a hierarchical bottom up clustering al-
gorithm on permissions. Their approach partitions permis-
sions that occur together into role clusters and uses maxi-
mum overlap between pairs of clusters to enforce a partial
ordering. A pair is chosen at random when more than one
pair has the maximum overlap and each permission can only
be found along one role path of the hierarchy.
To allow permissions to belong to more than one role,
Vaidya et al.’s RoleMiner [17] used subset enumeration to
identify candidate roles. Each set of user permissions is
used as a permission cluster with candidate roles generated
as the shared subsets between pairs of clusters. The pro-
cess is applied recursively with the newly identiﬁed clusters
until no more overlapping subsets can be found. The ﬁrst
iteration is capable of identifying the majority of roles in
simulated data if each user is only assigned one or two roles
and performs poorly when each user is assigned multiple
roles. The full algorithm is likely to be capable of extract-
ing all possible roles even when users are assigned multiple
roles, however the runtime of the full algorithm is expo-
nential. There is no method of how the proposed candidate
roles can be adapted for hierarchical RBAC and the number
of identiﬁed candidate roles is extremely large.
Graph based approaches for automated role extraction
have also been proposed. Zhang et al. [18] and Ene et al. [4]
place users, permissions and their relationships into a graph
as nodes and edges. Zhang et al.’s heuristic inserts role
nodes between users and permissions and merge roles to re-
duce the complexity of the graph structure. Optimising the
graph represents optimising the administration required for
the enterprise. Ene et al. uses heuristics and graph theory to
reduce the graph representations to ﬁnd the minimal num-
ber of roles required to cover all permission assignments.
However, graph based heuristics can terminate at local min-
imums and all graph based approaches often ﬁnd the mini-
mal number of roles to be similar to the number of users or
permissions. In some of Ene et al.’s results, only a few roles
248248
contained multiple permissions and were assigned to multi-
ple users. The majority of roles identiﬁed were permission
sets of single users. This is an important result that implies
an alternative method might be required if less role recom-
mendations are desired. These approaches also suggest the
best roles are the ones that are assigned to more users and
contain more permissions as they offer the largest amount
of administrative beneﬁt.
Theoretical analysis of the role mining problem (RMP)
by Vaidya et al. [16] and Lu et al. [11] show the problem
of ﬁnding the minimal set of descriptive roles and rela-
tionships without disturbing permission assignments is NP-
complete. Existing approaches analyse all user permission
assignments with ﬁnal candidate roles neither adding nor
removing permission assignments. Solutions that minimise
roles and role relationships under these conditions do not
produce desirable results for application. An alternative
technique discussed in theory is the idea of allowing initial
deviations in user assignments if doing so improves some
quality of the identiﬁed roles. There is yet to be an imple-
mentation to test this theory.
To address these open issues, this research aims to iden-
tify sets of roles based on a variation of the RMP that allows
for perturbations in permission assignments with the aim of
identifying more practical roles. The focus is on identiﬁca-
tion of a more practical and useful set of roles with each role
offering the most administrative beneﬁt. Our approach will
also address the issue of role constraints, not limiting how
many or which permissions can be assigned to each role and
how many roles a user can be assigned. A complimentary
hierarchy construction technique will also be presented to
assist hierarchical RBAC implementation. Finally, our re-
sults are tested and we analyse our experimental ﬁndings
and explore the effects and tradeoffs of the identiﬁed roles.
3. Permission Set Pattern Mining Approach
Instead of identifying all possible roles within a particu-
lar infrastructure, our approach identiﬁes and analyses roles
that cover the largest portion of permission assignments.
These roles offer signiﬁcant administrative beneﬁt upon im-
plementation and are strongly recommended for RBAC.
The intuition behind the proposed approach is permis-
sions that are often assigned together should be assigned
together. This collection of permissions that are usually as-
signed together implies a role. The popularity of the role as
well as the grouping of the permissions is what makes ad-
ministration easier. To identify the permission collections
that are assigned together, this research proposes frequent
pattern data mining [8] to achieve this role engineering goal.
Our technique is a two part process: 1) identiﬁcation of
possible permission sets as candidate roles and 2) placement
of these roles into a partial ordering hierarchy. Details on
the implementation of each phase is described in Section 3.2
and Section 3.3 respectively. Section 3.1 will describe the
preliminaries and deﬁnitions that will be used.
3.1. Preliminaries
Role Based Access Control RBAC is an administration
concept that reduces access control management require-
ments in large enterprise environments [6, 7]. Core ANSI
recommended RBAC components contain user u, role r and
permission p concepts [1]. The standard also allows for hi-
erarchical RBAC H≺ that place partial orderings on roles.
Roles can exist with or without separation of duty con-
straints and sessions. Our approach will focus on core RBAC
components with support for a role hierarchy.
To identify sets of permissions that are assigned to multi-
ple users, frequent itemset mining [8] is proposed. Frequent
pattern mining identiﬁes collections of items that occur to-
gether frequently, often used as a pre-processing algorithm
for other data mining techniques, predominately associa-
tion rule mining [2]. Each interesting collection of items
is known as an itemset and each transaction is a collection
of items where itemsets occur.
In our approach, each p is a permission that can be as-
signed to a user u. Each transaction is a permission set P ,
containing all the permissions p that is assigned to a user u.
A frequent itemset of p is a frequent permission set denoted
F . Each F will have a support count σ, the number of times
F occurs in our data set. F is retained if σ ≥ ξ where ξ is
a frequency threshold. Discussions on ξ and its usage will
be in Sections 3.2 and 3.3 and further analysis of its effects
are described in Sections 4 and 5. If σ ≥ ξ, F will be iden-
tiﬁed as a candidate role r. C is the set of tuples containing
candidate roles F and their frequency counts σ.
After we have identiﬁed our candidate roles, we wish to
place them into a partial ordering ≺ to represent a role hier-
archy H≺. Roles higher in the hierarchy contain a superset
of the permissions that are in related roles lower in the hi-
erarchy. That is, r ≺ r′ iff every permission in r is also in
r′.
3.2. Pattern Mining
This phase efﬁciently searches through the user permis-
sion assignments to discover sets of permissions that occur
together. There are many ways to generate frequent item-
sets. Any algorithm for frequent pattern identiﬁcation can
be used. One of the fastest implementations, and the one
we have chosen due to its optimality and ease of implemen-
tation, is Han et al.’s Frequent Pattern Tree (FP-Tree) ap-
proach without candidate itemset generation [9]. This ap-
proach requires two passes of the data to identify all item-
sets above a certain frequency threshold ξ. The initial pass
249249
creates a support count σ of each item p in each transaction
P . The second pass builds the FP-Tree using the support
count of each item and places each pattern into the tree. The
tree structure contains all the frequent patterns and mining
of the FP-Tree returns the frequent itemsets.
Algorithm 1 gives a brief overview of the required in fre-
quent permission set extraction using an FP-Tree. The al-
gorithm constructs the FP-Tree and uses the tree to identify
frequent permission sets as candidate roles.
Lines 2–5 of this algorithm constructs the FP-Tree, iden-
tifying frequent permission collections in two passes of the
transactional data.
In line 2, the ﬁrst pass of all the user
permission sets P is performed to create the f list, a list of
all frequent permissions p with their frequency count σ. In
line 3, items in the f list are then sorted in decreasing order
of frequency count σ. The f list only contains permissions
p with σ ≥ ξ. Line 4 of the algorithm sorts all permission
sets P based on the f list ordering.
In line 5, the second pass of all user permissions P is
performed. To construct the FP-tree, each permission set
is inserted into the tree as a branch with each permission
as a node. Permission nodes are inserted in order of oc-
currence. Since each P is sorted in decreasing order of
frequency, each p within P is guaranteed to be more fre-
quent than succeeding p. As a result, more frequent permis-
sion nodes will be closer to the root of the tree, creating a
more compact tree structure that is efﬁcient to traverse when
extracting frequent permission sets. More details on exact
construction technique and proof of optimality can be found
in [9].
The tree now contains all the frequent patterns of the
data. Branches of the tree are then recursively traversed to
extract frequent permission sets and placed into C with their
support counts (lines 6–8). Exact methods of how to tra-
verse the tree can be found in [9]. Finally, to assist with the
next phase, elements in C are sorted on decreasing support
and increasing permission set length in line 9. If candidate
roles have the same frequency, this ensures candidate roles
with a smaller number of permissions appear before candi-
date roles with a larger number of permissions. Reasoning
for this will be apparent in phase 2.
A ξ value can be given during the frequent permission set
extraction stage to prune the number of generated candidate
roles. Otherwise, the default value is left as 1 and pruning
can be performed in phase 2, when more information on
generated permission sets is available.
3.3 Hierarchy Construction
Algorithm 1: Frequent permission-set and support
generation
Require: all user permission sets P
begin
// Construct FP-Tree
initial read through all user permission sets P —
generate f list, the list of all frequent permissions p
with their frequency count σ
sort f list on decreasing frequency order
for each P order user permissions by frequency
using f list
second read through all user permissions P —
construct FP-Tree turning each P into a path of the
tree
// Mine FP-Tree to extract
candidate roles with support
for each frequent permission set F in FP-Tree do
add hσ, F i to candidate roles C
end
sort candidate roles C based on σ and |F |
1
2
3
4
5
6
7
8
9
10
end
process names roles in order of insertion. Roles are in-
serted into the hierarchy in order of decreasing support
and increasing permission set length in lines 3–14. C has
been sorted in the desired manner as part of the previous
phase of the algorithm so the next frequent permission set
is extracted from C each time and placed into a new role
(lines 4–6). The new role is then inserted into the role hier-
archy H≺ in line 7. Since C is sorted based on decreasing
permission set frequency as well as increasing permission
set length, candidate roles that are placed lower in the hier-
archy are guaranteed to precede related candidate roles that
are placed higher in the hierarchy. This way, placement of
partial orderings is a one way search: identiﬁcation of ex-
isting hierarchy candidate roles that are subsets of the new
candidate role.
In the special instance when a new role contains only
one permission, no relationships from this role can be cre-
ated and it is placed at the lowest level of the hierarchy.
When a role contains more than one permission, it is placed
into the hierarchy with partial orderings placed between the
new role and existing roles that are subsets of the new role
(line 9). This operation can produce role orderings that
are derivable through transitive closure which are redundant
and therefore removed in line 10. Iteration through the loop
in lines 3–14 creates the intended role hierarchy.
The ﬁnal phase of the procedure constructs a partial or-
dering on candidate roles to produce a role hierarchy H≺
(Algorithm 2). Identiﬁers of roles can be modiﬁed to more
meaningful names later in the process. For simplicity, this
Additional operations from line 15–17 can be imple-