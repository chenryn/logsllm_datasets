# Title: Permission Set Mining: Discovering Practical and Useful Roles

## Authors:
- Dana Zhang
- Kotagiri Ramamohanarao
- Tim Ebringer
- Trevor Yann

## Conference:
2008 Annual Computer Security Applications Conference

## Abstract
Role-based access control (RBAC) is an efficient and effective method for managing and governing permissions for a large number of users. However, defining a role infrastructure that accurately reflects the internal functionalities and workings of a large enterprise remains a challenging task. Recent research has focused on the theoretical aspects of automated role identification, but practical applications for identifying roles are still underdeveloped.

This research proposes a practical data mining heuristic that is fast, scalable, and capable of identifying comprehensive roles and placing them into a hierarchy. The permission set pattern mining method can identify roles with partial orderings that cover the largest portion of user permissions within a system. We tested the algorithm on real user permission assignments as well as on generated data sets. The roles identified in the test sets covered up to 85% of user permissions, and the analysis showed that these roles offer significant administrative benefits. We also found interesting correlations between roles and their relationships and analyzed the trade-offs between complete coverage and the effectiveness of the roles.

## 1. Introduction
Since its formalization [6], Role-Based Access Control (RBAC) has become a recommended practice for security control in large enterprise environments. In this model, permissions are assigned through roles rather than individually to users, which often reduces the number of associations that need to be managed, making it popular in industry [7].

However, the initial implementation of RBAC can be problematic if there is no clear understanding of how to set up the configuration. Role engineering was introduced [3] to address this issue by providing a framework for defining the architectural structure of RBAC. This solution is also useful for systems that already have RBAC implemented, as it can verify the existing structure or offer recommendations for a new one.

Initial role engineering techniques that involve only user analysis [5, 13, 14] are time-consuming and costly. As a result, the trend has shifted towards more automated techniques [10, 15, 17] for role identification, reducing the amount of user input required. Recent studies have analyzed the theoretical aspects of role engineering [4, 11, 16, 18] and have shown that finding a minimal set of descriptive roles and its variants is NP-complete and difficult to approximate.

While theoretical understanding is important, practical solutions for role engineering remain largely unsolved. Due to the computational complexity of automated role extraction, heuristic approaches offer the best solutions. Both data mining and graph-based approaches have been proposed, but many open issues remain unaddressed.

Existing data mining approaches place constraints on roles before the mining process can proceed [10, 15, 17]. These constraints include limiting the number of roles a user can be assigned or placing limits on the allowable permissions within a role. These processes often generate a large number of candidate roles, more than would be required for a reasonable RBAC implementation. Graph algorithms place users and permissions as nodes and their relationships as edges [4, 18]. In some cases, the minimum number of roles required to represent all permission assignments can be found, while local minima for role count are extracted in most other situations. Recent experimental analysis shows that the minimum number of roles required to cover all permission assignments is often similar to the number of permissions or the number of users [4], which is not practical for any reasonable RBAC implementation.

These existing approaches, both data mining and graph-based, include all permission assignments within a system to generate candidate roles. Theoretical analysis suggests that it may be acceptable to allow a small portion of the permissions to be considered exceptions if a high percentage of permissions is still covered by roles and if doing so significantly improves the quality of the roles [16]. No practical work has yet been done in this area, and to our knowledge, we will be the first to implement such a technique.

In this paper, we propose a Permission Set Mining heuristic for generating roles that cover the largest portion of user assignments. These roles are more practical and useful as they offer significant administrative benefits. The proposed approach uses efficient search algorithms to identify candidate roles without the role-to-permission and user-to-role constraints inherent in existing approaches. Using the a priori principle of pattern extraction, our approach can produce a natural ordering on roles to assist the hierarchy construction process. Permission set mining is tested on real data within an organizational environment as well as on simulated test data. The results are analyzed, and interesting correlations between roles and role relationships, as well as role significance and role quantity, are presented.

The remainder of the paper is organized as follows. Section 2 provides background and an overview of related work in this area. The limitations in existing applications for role engineering drive our motivation, and Section 3 proposes our application of data mining for role engineering and how it can be used to extract roles and define a role hierarchy. A summary of our experimental results on real and simulated data is discussed in Section 4. This is followed by Section 5, an analysis of our approach and future improvements. We discuss our findings and offer insights into automated role extraction that have not been previously addressed. Finally, Section 6 concludes the paper by giving an overview of our contributions and findings.

## 2. Background
The problem of role engineering was first discussed by Coyne [3], leading to the initial top-down process-oriented approaches for role definition. Job functionalities, documented processes, usage scenarios, and use cases were used to determine access rights [5, 13, 14]. However, user interaction-based derivation of roles requires significant user input, making it impractical for medium to large-sized enterprises.

As a result, the focus has now turned to bottom-up role engineering, which analyzes existing user permission assignments to automate the extraction of roles. Most bottom-up approaches have used role mining, applying data mining techniques for role definition. One of the first role mining proposals by Kuhlmann et al. [10] was created for Security Administration Manager (SAM), an enterprise security tool for RBAC implementation. The SAM Role Miner combined association mining with demographic clustering to produce an interactive refining process for creating roles without a hierarchy.

For automated role hierarchy generation, Schlegelmilch et al. proposed ORCA [15], a hierarchical bottom-up clustering algorithm on permissions. Their approach partitions permissions that occur together into role clusters and uses maximum overlap between pairs of clusters to enforce a partial ordering. Vaidya et al.’s RoleMiner [17] used subset enumeration to identify candidate roles. Each set of user permissions is used as a permission cluster with candidate roles generated as the shared subsets between pairs of clusters. The full algorithm is likely to be capable of extracting all possible roles even when users are assigned multiple roles, but the runtime is exponential. There is no method for adapting the proposed candidate roles for hierarchical RBAC, and the number of identified candidate roles is extremely large.

Graph-based approaches for automated role extraction have also been proposed. Zhang et al. [18] and Ene et al. [4] place users, permissions, and their relationships into a graph as nodes and edges. Zhang et al.’s heuristic inserts role nodes between users and permissions and merges roles to reduce the complexity of the graph structure. Ene et al. uses heuristics and graph theory to reduce the graph representations to find the minimal number of roles required to cover all permission assignments. However, graph-based heuristics can terminate at local minima, and the minimal number of roles is often similar to the number of users or permissions. In some of Ene et al.’s results, only a few roles contained multiple permissions and were assigned to multiple users. The majority of roles identified were permission sets of single users, implying that an alternative method might be required if fewer role recommendations are desired.

Theoretical analysis of the role mining problem (RMP) by Vaidya et al. [16] and Lu et al. [11] shows that finding the minimal set of descriptive roles and relationships without disturbing permission assignments is NP-complete. Existing approaches analyze all user permission assignments, and final candidate roles neither add nor remove permission assignments. Solutions that minimize roles and role relationships under these conditions do not produce desirable results for application. An alternative technique discussed in theory is the idea of allowing initial deviations in user assignments if doing so improves the quality of the identified roles. There is yet to be an implementation to test this theory.

To address these open issues, this research aims to identify sets of roles based on a variation of the RMP that allows for perturbations in permission assignments with the aim of identifying more practical roles. The focus is on identifying a more practical and useful set of roles, each offering the most administrative benefit. Our approach will also address the issue of role constraints, not limiting how many or which permissions can be assigned to each role and how many roles a user can be assigned. A complementary hierarchy construction technique will also be presented to assist hierarchical RBAC implementation. Finally, our results are tested, and we analyze our experimental findings and explore the effects and trade-offs of the identified roles.

## 3. Permission Set Pattern Mining Approach
Instead of identifying all possible roles within a particular infrastructure, our approach identifies and analyzes roles that cover the largest portion of permission assignments. These roles offer significant administrative benefits upon implementation and are strongly recommended for RBAC.

The intuition behind the proposed approach is that permissions that are often assigned together should be assigned together. This collection of permissions implies a role, and the popularity of the role, as well as the grouping of the permissions, makes administration easier. To identify the permission collections that are assigned together, this research proposes frequent pattern data mining [8] to achieve this role engineering goal.

Our technique is a two-part process: 1) identification of possible permission sets as candidate roles and 2) placement of these roles into a partial ordering hierarchy. Details on the implementation of each phase are described in Sections 3.2 and 3.3, respectively. Section 3.1 will describe the preliminaries and definitions that will be used.

### 3.1. Preliminaries
Role-Based Access Control (RBAC) is an administration concept that reduces access control management requirements in large enterprise environments [6, 7]. Core ANSI-recommended RBAC components contain user \( u \), role \( r \), and permission \( p \) concepts [1]. The standard also allows for hierarchical RBAC \( H \prec \) that places partial orderings on roles. Roles can exist with or without separation of duty constraints and sessions. Our approach will focus on core RBAC components with support for a role hierarchy.

To identify sets of permissions that are assigned to multiple users, frequent itemset mining [8] is proposed. Frequent pattern mining identifies collections of items that occur together frequently, often used as a pre-processing algorithm for other data mining techniques, predominantly association rule mining [2]. Each interesting collection of items is known as an itemset, and each transaction is a collection of items where itemsets occur.

In our approach, each \( p \) is a permission that can be assigned to a user \( u \). Each transaction is a permission set \( P \), containing all the permissions \( p \) that are assigned to a user \( u \). A frequent itemset of \( p \) is a frequent permission set denoted \( F \). Each \( F \) will have a support count \( \sigma \), the number of times \( F \) occurs in our data set. \( F \) is retained if \( \sigma \geq \xi \), where \( \xi \) is a frequency threshold. Discussions on \( \xi \) and its usage will be in Sections 3.2 and 3.3, and further analysis of its effects are described in Sections 4 and 5. If \( \sigma \geq \xi \), \( F \) will be identified as a candidate role \( r \). \( C \) is the set of tuples containing candidate roles \( F \) and their frequency counts \( \sigma \).

After identifying our candidate roles, we wish to place them into a partial ordering \( \prec \) to represent a role hierarchy \( H \prec \). Roles higher in the hierarchy contain a superset of the permissions that are in related roles lower in the hierarchy. That is, \( r \prec r' \) if every permission in \( r \) is also in \( r' \).

### 3.2. Pattern Mining
This phase efficiently searches through the user permission assignments to discover sets of permissions that occur together. There are many ways to generate frequent itemsets, and any algorithm for frequent pattern identification can be used. One of the fastest implementations, and the one we have chosen due to its optimality and ease of implementation, is Han et al.’s Frequent Pattern Tree (FP-Tree) approach without candidate itemset generation [9]. This approach requires two passes of the data to identify all itemsets above a certain frequency threshold \( \xi \). The initial pass creates a support count \( \sigma \) of each item \( p \) in each transaction \( P \). The second pass builds the FP-Tree using the support count of each item and places each pattern into the tree. The tree structure contains all the frequent patterns, and mining of the FP-Tree returns the frequent itemsets.

Algorithm 1 gives a brief overview of the required steps for frequent permission set extraction using an FP-Tree. The algorithm constructs the FP-Tree and uses the tree to identify frequent permission sets as candidate roles.

- **Lines 2–5**: Construct the FP-Tree, identifying frequent permission collections in two passes of the transactional data.
  - **Line 2**: The first pass of all user permission sets \( P \) is performed to create the \( f \) list, a list of all frequent permissions \( p \) with their frequency count \( \sigma \).
  - **Line 3**: Items in the \( f \) list are then sorted in decreasing order of frequency count \( \sigma \). The \( f \) list only contains permissions \( p \) with \( \sigma \geq \xi \).
  - **Line 4**: All permission sets \( P \) are sorted based on the \( f \) list ordering.
  - **Line 5**: The second pass of all user permissions \( P \) is performed. To construct the FP-Tree, each permission set is inserted into the tree as a branch with each permission as a node. Permission nodes are inserted in order of occurrence. Since each \( P \) is sorted in decreasing order of frequency, each \( p \) within \( P \) is guaranteed to be more frequent than succeeding \( p \). As a result, more frequent permission nodes will be closer to the root of the tree, creating a more compact tree structure that is efficient to traverse when extracting frequent permission sets. More details on exact construction techniques and proof of optimality can be found in [9].

- **Lines 6–8**: The tree now contains all the frequent patterns of the data. Branches of the tree are then recursively traversed to extract frequent permission sets and placed into \( C \) with their support counts.
- **Line 9**: Finally, to assist with the next phase, elements in \( C \) are sorted on decreasing support and increasing permission set length. If candidate roles have the same frequency, this ensures candidate roles with a smaller number of permissions appear before candidate roles with a larger number of permissions. Reasoning for this will be apparent in Phase 2.

A \( \xi \) value can be given during the frequent permission set extraction stage to prune the number of generated candidate roles. Otherwise, the default value is left as 1, and pruning can be performed in Phase 2, when more information on generated permission sets is available.

### 3.3. Hierarchy Construction
Algorithm 2: Hierarchy Construction
- **Lines 3–14**: Insert roles into the hierarchy in order of decreasing support and increasing permission set length. \( C \) has been sorted in the desired manner as part of the previous phase of the algorithm, so the next frequent permission set is extracted from \( C \) each time and placed into a new role. The new role is then inserted into the role hierarchy \( H \prec \). Since \( C \) is sorted based on decreasing permission set frequency as well as increasing permission set length, candidate roles that are placed lower in the hierarchy are guaranteed to precede related candidate roles that are placed higher in the hierarchy. This way, placement of partial orderings is a one-way search: identification of existing hierarchy candidate roles that are subsets of the new candidate role.

- **Special Case**: When a new role contains only one permission, no relationships from this role can be created, and it is placed at the lowest level of the hierarchy. When a role contains more than one permission, it is placed into the hierarchy with partial orderings placed between the new role and existing roles that are subsets of the new role. This operation can produce role orderings that are derivable through transitive closure, which are redundant and therefore removed. Iteration through the loop in lines 3–14 creates the intended role hierarchy.

- **Final Phase**: The final phase of the procedure constructs a partial ordering on candidate roles to produce a role hierarchy \( H \prec \). Identifiers of roles can be modified to more meaningful names later in the process. For simplicity, this additional operation is not included in the algorithm.

Additional operations from line 15–17 can be implemented to further refine the hierarchy.