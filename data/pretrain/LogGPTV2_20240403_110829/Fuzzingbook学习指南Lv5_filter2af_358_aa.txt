# Fuzzingbook学习指南Lv5
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
我们之前的fuzzing往往考虑的都是一个字符串，绞尽脑汁让这个字符串的字符发生变化进而提高某些指标，我们这次把段位上升，不在局限于怎么“美化”句子，而是如何“定义”句子。
还记得最初我们用的bc吗？如果你一味使用Lv4之前的技术，那你其实永远都是在“乱搞”，因为它其实有一套自己的逻辑，如果找到了逻辑你可以绝杀，就像是玄幻小说，掌握规则的人永远比普通修炼的牛，我们也要让我们的史莱姆掌控法则。
## 语法
我们说话写字都是有一定规则的，编写程序是这样，写数学公式也是这样，现在我们来想想到底是什么“限制”了我们呢？
  * 首先当然是范围，你也可以理解为集合当中说的定义域，简单说就是规定哪些符号你能用，哪些不能用，以只包含加减乘除的小学数学表达式为例，我们的定义域就限制在了加减乘除四个符号以及0～9十个数字罢了，你用了a你就是错了，就不是一个合格的表达式了。
  * 其次我们可以想到，是一组规则让我们不能乱写。小学数学表达式可不会出现1++这种奇奇怪怪的式子，这就说明背后有一套规则约束，而这套规则还应该是支持无限写下去的，因为按道理来说，你可以写1+1+1+···一直写下去。
如果让我们用一套规范点的方式去概括这两个方面呢？范围我们很好解决，我们可以用正则表达式来检测，不符合规则淘汰就是了，第二点我们该如何做呢？其实我们大学就学过这个问题，这其实就是个有限状态机。
所谓有限状态机，其实就是一组“状态”，它们之间互相能够进行转换。比如Linux的进程状态，那有人就要问了，你刚说了1+1+1+能无限写下出，怎么这会反而有限了呢？其实有限说的是状态是有限的，比如Linux的进程状态，满打满算就五个，但是一个进程你完全可以无限次的经历这些状态。
这两点就组成了我们的语法，我们只需要按照一定的规则，就可以轻松写出对应的语法，比如
     ::= 
     ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
首先是个start标签，标志着开始，::=这个符号表示前者可以由后者代替，而|就代表or的意思，所以上面的语句就代表，以两个数字开头，后面啥也没有，其实就是我们需要写两个0-9的数，比如00，比如12。
那你就要问了，我要是写1000个数你咋整啊，我总不能写1000个吧？其实也很简单，加一句话就完事了
      ::= 
     ::=  | 
       ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
我们引入了递归的概念来处理这个问题，用递归达到无限循环的目的。直接来看，首先我们以integer开头，而integer可以是数字，也可以是数字然后再来个integer，这就可以一直递归下去了。比如我写1，可以吗？可以，integer=digit=1即可；写23，可以吗？可以，integer=3iteger，再处理第二个integer=3即可，就得到integer
= 23，这样我们就轻松实现了无限的概念。
那又有问题了，我如何表达我的数有正负呢？也简单，在状态转换的位置加入限制即可，如下
      ::= 
     ::=  | + | -
     ::=  | 
       ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
假设我们输入的是-3，那么就是number=-integer，integer=3，number=-3，完毕。
有了上面几个例子，相信你已经会利用“解包”的思想读这些语法了，我们每次读时，如果有还不清楚的位置，那就先带着标签，然后一步步把标签给去了，这就是解包的思想，我们不仅仅读需要这种思想，写代码实现也要如此。下面我们就尝试写代码，让程序按照我们定的规则来说话。
    DIGIT_GRAMMAR = {
        "":
            ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
    }
我们用字典存储标签即可，而对于生成的过程如下：
      term = start_symbol
      expansion_trials = 0  
      while len(nonterminals(term)) > 0:
            symbol = random.choice(nonterminals(term))
            expansions = grammar[symbol]
            expansion = random.choice(expansions)
            new_term = term.replace(symbol, expansion, 1)
            if len(nonterminals(new_term))  " + expansion), term)
                expansion_trials = 0
            else:
                expansion_trials += 1
                if expansion_trials >= max_expansion_trials:
                    raise ExpansionError("Cannot expand " + repr(term))
nonterminals函数用来找非终端的标签，对于能够继续产生标签的标签，我们叫它非终端，比如start；对于只能产生最终结果不能继续生成标签的标签，就是终端，比如digit。
因为我们是一步步解包，所以首先我们得有包，他其实就是在检查当前的term是不是有包，如果有包的话，就在包里随机找一个，然后再从包中找一个标签，我们就到了新的表达式，当然，为了这个过程不会无限循环下去，我们人为定义了循环的最大值，让他不会无限循环。
这样说可能有点抽象，我们举个例子，就用我们的正负数来说：
  * nonterminals找到非终端的值，一开始就是number（节省篇幅，跳了start标签）
  * 随机选一个作为expansions ，这里只有number
  * 随机在number对应的里面选一个，假设选到了+
  * 那么新标签现在就是+
  * 找所有非终端的值，只有
  * 随机选，只能选
  * 随机在integer对应的里面选一个，假设选中了