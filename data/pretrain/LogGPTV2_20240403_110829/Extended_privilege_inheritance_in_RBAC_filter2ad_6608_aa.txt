title:Extended privilege inheritance in RBAC
author:M. A. C. Dekker and
J. G. Cederquist and
Jason Crampton and
Sandro Etalle
See discussions, stats, and author profiles for this publication at: https://www.researchgate.net/publication/221609664
Extended privilege inheritance in RBAC
Conference Paper · January 2007
DOI: 10.1145/1229285.1229335 · Source: DBLP
CITATIONS
5
4 authors:
Mendie Dekker
Windesheim University
13 PUBLICATIONS   232 CITATIONS   
SEE PROFILE
Jason Crampton
Royal Holloway, University of London
97 PUBLICATIONS   2,160 CITATIONS   
SEE PROFILE
Some of the authors of this publication are also working on these related projects:
Towards an Internet of Secure Things (INTERSECT) View project
Cryptographic Enforcement of Information Flow Policies View project
READS
51
Jan Cederquist
Technical University of Lisbon
18 PUBLICATIONS   265 CITATIONS   
SEE PROFILE
Sandro Etalle
Eindhoven University of Technology
228 PUBLICATIONS   2,502 CITATIONS   
SEE PROFILE
All content following this page was uploaded by Sandro Etalle on 22 May 2014.
The user has requested enhancement of the downloaded file.
Extended Privilege Inheritance in RBAC∗
M.A.C. Dekker†
J. Cederquist‡
J. Crampton§
S. Etalle¶
December 20, 2006
Abstract
In existing RBAC literature, administrative privileges are inherited
just like ordinary user privileges. We argue that from a security view-
point this is too restrictive, and we believe that a more ﬂexible approach
can be very useful in practice. We deﬁne an ordering on the set of adminis-
trative privileges, enabling us to extend the standard privilege inheritance
relation in a natural way. This means that if a user has a particular ad-
ministrative privilege, then she is also implicitly authorized for weaker
administrative privileges. We prove the non-trivial result that it is possi-
ble to decide whether one administrative privilege is weaker than another
and show how this result can be used to decide administrative requests in
an RBAC security monitor.
1
Introduction
Role-based access control (RBAC) [11] is a non-discretionary access control
mechanism that simpliﬁes the assignment of access rights to users. The basic
idea is that while there are many access rights and users, rights and users can be
grouped using a relatively small number of roles, ordered in a role hierarchy. In
practice however, an RBAC system in a large enterprise may involve thousands
of roles [5]. Keeping the access rights and roles up to date with changes in
the enterprise may be a too big task for a single administrator. The usual
approach to this problem is to divide the work and to allow delegation of part
of the administrator’s authority to other users. It is convenient to make this
delegation mechanism ﬂexible, in order to reduce the likelihood of bottlenecks
and (administrative) users sharing keys or passwords that should remain secret.
On the other hand, the delegation mechanism should be safe: users should not
obtain rights other than those explicitly delegated by the administrator.
2007, published by ACM press.
∗This is an extended version of a paper to be published in the proceedings of ASIA CCS
†Security group, TNO ICT, The Netherlands
‡SQIG-IT, IST, TU Lisbon, Portugal
§Information Security Group, Royal Holloway, University of London, United Kingdom
¶Distributed and Embedded Systems group, University of Twente, The Netherlands
1
Several lines of research address the problem of delegation of administrative
privileges in RBAC systems; Ferraiolo et al. [5] compare some of the diﬀerent
approaches. The main issue in these lines of research is how to model adminis-
trative privileges, as opposed to the ordinary user privileges, and to decide who
should have them. In ARBAC [10] administrative privileges are assigned to a
separate hierarchy of administrative roles and deﬁned by specifying a range of
roles that can be changed. Crampton and Loizou [4] take a more general ap-
proach, by using the same hierarchy for both the administrative privileges and
the ordinary user privileges. Using the concept of administrative scope, they
deﬁne which roles should have administrative privileges over other roles. In the
Role-Control Center [5], administrative privileges over roles are deﬁned in terms
of views, which are subsets of the role-hierarchy, and they can only be assigned
to users assigned to these roles.
In existing RBAC literature [2, 4, 5, 10, 15], administrative privileges are
inherited just like ordinary user privileges. We argue that this approach is
more restrictive than necessary for safety: consider a simple setting where an
administrator has delegated the authority to some user u to assign a user u(cid:48)
to a high role in the role-hierarchy. When user u uses this authority, user u(cid:48)
becomes assigned to the high role, and consequently u(cid:48) can also play lower roles.
There is no security motivation for not letting user u assign user u(cid:48) directly to
(one of) the lower roles. User u(cid:48) could play the lower roles anyway. However,
in standard RBAC, administrative privileges are not interpreted in this way1
In this paper, we deﬁne an ordering on the administrative privileges, en-
abling us to extend the standard privilege inheritance relation in a natural way.
This means that if a user has a particular administrative privilege, then she is
also implicitly authorized for weaker administrative privileges. Basically, this
allows for a more ﬂexible use of administrative privileges. Additionally, we show
that the new relation is tractable, and we sketch a possible implementation of
the extended inheritance relation. We argue that decentralized management of
RBAC becomes more ﬂexible with this extension.
2 Preliminaries
In this section we give some deﬁnitions about the standard RBAC model [11].
Deﬁnition 2.1 (RBAC State) Given the sets U of users, R of roles and P
of privileges, we deﬁne an RBAC state as a tuple,
(UA, RH , PA),
1It could be argued that an entry in, say, an ARBAC97 relation or the existence of a
particular administrative scope, by implication gives additional administrative privileges. This
is not, however, mentioned explicitly.
2
where,
UA ⊆ U × R
RH ⊆ R × R (a directed graph on R)
PA ⊆ R × P.
Here UA determines which users are assigned to which roles in R. The graph RH
is the so-called role-hierarchy and PA determines which privileges are assigned
to which roles. A user can play the roles to which it is assigned, and the roles
that are below them in the hierarchy. Sometimes (r, r(cid:48)) ∈ RH is written as
r > r(cid:48). Below we denote the reﬂexive transitive closure over the graph RH with
(cid:62) (also known as the partial order on RH ).
In the RBAC model [11], a user does not get all the privileges associated to
the roles it can play: The user has to start a session, in which one or more of
the user’s roles can be activated. The session gets only all the privileges of the
activated roles. Basically, this allows users to operate from sessions with less
privileges than they are entitled to, implementing the so-called principle of least
privilege. In this paper, for the sake of brevity, we will not be explicit about
sessions nor the activations of roles.
Remark 2.2 (About cycles in the role-graph) In some of the existing lit-
erature on RBAC, it is required that RH be acyclic, to avoid redundancy. For
example, if both (a, b) ∈ RH and (b, a) ∈ RH , then using the two diﬀerent names
a and b is redundant. Similarly, sometimes RH is required to be transitively
reduced; for example, the transitive reduction of {(a, b), (b, c), (a, c)} removes
the last element, because there would be a path anyway from a to c using the
other edges.
For the sake of brevity, we ignore such constraints. Actually, we do not
assume any set of constraints on RH or PA throughout this paper. The results
in this paper apply equally to acyclic and cyclic directed graphs. Moreover,
the extension of the privilege inheritance relation, to be introduced in the next
section, does not introduce extra cycles (in some cases it removes cycles).
Given an RBAC state, we say that a role r has a privilege p, if (r, p) ∈ PA.
Additionally, it is common (see below) that privileges of lower roles are available
as well, i.e. without the need to activate the lower roles ﬁrst. This is known as
privilege inheritance. See for example the RBAC state shown in Figure 1a. The
role r1 inherits the privilege p assigned to role r2. With privilege inheritance
the edge from r1 to p in Figure 1b is redundant.
Deﬁnition 2.3 (Privilege Inheritance) Given an RBAC state (UA, RH , PA),
a role r has the privilege p, denoted r (cid:195) p, only if
r (cid:62) r(cid:48) and (r(cid:48), p) ∈ PA for some r(cid:48) ∈ R.
When a user activates a role in a session, this session acquires all the privileges
of the role.
3
Figure 1: Two sample RBAC states. With privilege inheritance the extra edge
on the right is redundant.
The advantage of privilege inheritance in RBAC is that it allows users in a
high role, to also use privileges of a lower role, without activating that lower role.
This is a well-known feature of RBAC, which can be used to avoid repetitive
deﬁnitions in the RBAC state (like the edge between r1 and p).
3 A Diﬀerent View on Administrative Privileges
Privileges can be divided into user privileges and administrative privileges [11].
While user privileges allow actions on objects (such as printing ﬁles or viewing
records), administrative privileges, allow actions on the RBAC state itself, e.g.
adding an edge from one role to another. Here we assume that user privileges
form a ﬁnite set of atomic privileges, denoted by Q, that corresponds to a ﬁnite
set of actions on objects. On the other hand, the set of administrative privileges
is necessarily inﬁnite, because privileges about administrative privileges are in-
cluded as well. We formalize the full set of privileges by deﬁning a grammar
that encompasses both user privileges and administrative privileges.
Deﬁnition 3.1 (Privilege Grammar) Given the sets U of users, R of roles
and Q of user privileges, the set of all privileges P is deﬁned by the following
grammar:
p ::= q |addUser(u, r) | addEdge(r, r(cid:48)) | addPrivilege(r, p),
where u ∈ U, q ∈ Q and r, r(cid:48) ∈ R.
Each administrative privilege corresponds to an administrative action. The
privilege addUser(u, r) allows the action of adding a member u to the role r.
The privilege addEdge(r1, r2) allows the action of adding an edge from role r1 to
r2. The construct addPrivilege is a grammatical connective and consequently -
as mentioned above - the set P is inﬁnite despite the fact that the sets of users,
roles and user privileges are all ﬁnite. In the existing literature the number of
administrative levels (in other words, the number of nestings of the addPrivilege
connective) is sometimes restricted to one [11] or to two levels [15]. We agree
that administrative privileges with multiple levels of administration might not
be useful in some implementations. However, here we take a general approach,
and we let the administrators choose which administrative privileges to use. We
4
should mention also that most existing models constrain the roles that can have
administrative privileges, for example to prevent low roles obtaining privileges
to change membership of higher roles [4]. We do not make choices with respect
to such constraints.
In most existing literature on the administration of RBAC systems some
constraints are assumed that restrict which roles should have administrative
privileges over others. For example, in the original RBAC model, administrative
privileges can only be assigned to a separate set of administrative roles.
In
the RCC model [5] a role can only assign a privilege if the role itself has that
privilege. In the RHA model [4] a role only has the privilege to administer other
roles that are in its administrative scope. We do not exclude any of these choices
and we assume that, in principle, any role can be assigned any administrative
privilege. In the sequel, we focus on the inheritance of administrative privileges.
3.1 Extended Privilege Inheritance
An RBAC state is denoted by a triple (UA, RH , PA), containing the user-role
assignments, the edges between roles and the privilege assignments to roles. A
well-known feature of RBAC is privilege inheritance [11], by which a role has
the privileges to which it is explicitly assigned, and additionally, the privileges
of lower roles.
Deﬁnition 3.2 (Standard Privilege Inheritance) Let (UA, RH , PA) denote
an RBAC state and let (cid:62) denote the reﬂexive transitive closure of RH , we say
that a role r has the privilege p, denoted by r (cid:195) p, iﬀ
r (cid:62) r(cid:48) and (r(cid:48), p) ∈ PA for some r(cid:48) ∈ R.
We argue that the standard privilege inheritance is inadequate for adminis-
trative privileges. Take for example a role r with the privilege to add an edge
e from r2 to r3. The role r does not have the privilege to add an edge from r2
to any role below r3, nor the privilege to add an edge from any role above r2 to
r3. However, from a security point of view this makes no sense, because with
edge e in place there would be anyway a path to roles below r3, or a path from
roles above r2. The standard RBAC privilege inheritance however does not
capture this, and treats administrative privileges like ordinary user privileges.
In Figure 2 we show the six diﬀerent cases where administrative privileges yield
weaker administrative privileges. For example, in Figure 2a, the (administra-
tive) privilege to assign user u to role r1 (the dashed edge) is stronger than
the privilege to assign user u to role r2. In Figure 2b, the privilege to add an
edge between r1 and r2 (the dashed arrow) is stronger than the privilege to add
only user u to role r2. And so on. We formalize this ordering by the following
deﬁnition.
Deﬁnition 3.3 (Privilege Ordering) Let (UA, RH , PA) be an RBAC state,
let p, p1, p2 be privileges in P , let Q be the subset of user privileges in P , and
let r1, r2, r3, r4 be roles in R. We deﬁne the relation → as the smallest relation
satisfying:
5
Figure 2: The right to add the dashed edge is stronger than the right to add
the dotted edge.
1. p → p, if p ∈ Q
2. addUser(u, r1) → addUser(u, r2), if r1 (cid:62) r2
3. addEdge(r1, r2) → addUser(u, r3), if r2 (cid:62) r3 and (u, r1) ∈ UA
4. addEdge(r2, r3) → addEdge(r1, r4), if r1 (cid:62) r2 and r3 (cid:62) r4
5. addEdge(r2, r3) → addPrivilege(r1, p2), if r1 (cid:62) r2, r3 (cid:62) r4, (r4, p1) ∈ PA
and p1 → p2
6. addPrivilege(r2, p1) → addPrivilege(r1, p2), if r1 (cid:62) r2 and p1 → p2
The ordering → is both reﬂexive and transitive.
The ordering of privileges yields an extension of the standard privilege in-
heritance relation.
Deﬁnition 3.4 (Extended Privilege Inheritance) Let (UA, RH , PA) be an