Otherwise, it sets CRED[ ğ‘—] = cred.
We define correctness, compactness, unforgeability, dependabil-
ity and anonymity as the following experiments. We assume that,
if required, the experiment honestly generates a reference string ğœŒ
using Setup(1ğœ†) which is an implicit argument for the remaining
algorithms.
Definition A.8 (Correctness). A core/helper anonymous creden-
tials system is correct if for all ğœ† âˆˆ N, all key pairs (isk, ipk) â†$
IKGen(1ğœ†), all secret key ssk â†$ CKGen(1ğœ†), all attribute sets
Attrğ‘  âŠ† Attrğ‘œ and all nonces nonceğ‘œ, nonceğ‘  âˆˆ {0, 1}ğœ†, aidğ‘œ â†$
AIDGen(Attrğ‘œ, nonceğ‘œ), aidğ‘  â†$ AIDGen(Attrğ‘ , nonceğ‘ ), all cre-
dential requests areq â†$ HObtain(Attrğ‘œ, nonceğ‘œ, ipk, CObtain(aidğ‘œ,
Session 6D: Authentication and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2019ipk, ssk)), all showings asig â†$ HShow(Attrğ‘ , nonceğ‘ , cred,
CShow(aidğ‘ , ssk)), we have Verify(Attr, nonce, areq, ipk) = 1, where
(cred, did) â†$ Issue(Attr, nonceğ‘œ, asig, isk).
Definition A.9 (Compactness). A core/helper anonymous creden-
tials system is compact if for all ğœ† âˆˆ N, all key pairs (isk, ipk) â†$
IKGen(1ğœ†), all secret key ssk â†$ CKGen(1ğœ†), all attribute sets
Attrğ‘  âŠ† Attrğ‘œ and all nonces nonceğ‘œ, nonceğ‘  âˆˆ {0, 1}ğœ†, aidğ‘œ â†$
AIDGen(Attrğ‘œ, nonceğ‘œ), aidğ‘  â†$ AIDGen(Attrğ‘ , nonceğ‘ ), all cre-
dential requests areq â†$ HObtain(Attrğ‘œ, nonceğ‘œ, ipk, CObtain(aidğ‘œ,
ipk, ssk)), all showings asig â†$ HShow(Attrğ‘ , nonceğ‘ , cred,
CShow(aidğ‘ , ssk)), we have |asig| â‰¤ ğ‘‚(ğœ†), i.e., the size of the show-
ing token asig is independent of the attribute set |Attrğ‘ | and only
depends on ğœ†.
Definition A.10 (Unforgeability). For the core/helper anonymous
credential and adversary A we define the following experiment:
UNFA
CHAC(ğœ†)
(isk, ipk) â†$ IKGen(1ğœ†)
nonce â†$ {0, 1}ğœ†
O := {OHD, OCD, Ononce, OObtIss, OIssue, OHShow}
(Attrâˆ—, asigâˆ—) â†$ AO (ipk, nonce)
if Verify(Attrâˆ—, nonce, asigâˆ—, ipk) = 1 and âˆ€ğ‘— Attrâˆ— âŠˆ CATTR[ ğ‘—]
and (nonce) âˆ‰ MN then return 1
else return 0
A CHAC is unforgeable if for all ğ‘ƒğ‘ƒğ‘‡ adversaries A, its advantage
in the above experiment is negligible:
AdvunfA,CHAC(ğœ†) = Pr(cid:104)
CHAC(ğœ†) = 1(cid:105)
UNFA
= negl(ğœ†).
Definition A.11 (Dependability). For the core/helper anonymous
credential and adversary A we define the following experiment:
HD
CHAC(ğœ†)
, OObtIss, Ononce, OIssue, OCShow}
DEPA
(isk, ipk) â†$ IKGen(1ğœ†)
O := {O(1)
(Attrâˆ—, nonceâˆ—, asigâˆ—) â†$ AO (ipk)
aidâˆ— â†$ AIDGen(Attrâˆ—, nonceâˆ—)
if (aidâˆ—) âˆˆ SN then return 0
if Verify(Attrâˆ—, nonceâˆ—, asigâˆ—, ipk) = 1 and
âˆ€ğ‘— Attrâˆ— âŠˆ CATTR[ ğ‘—] then
return 1
else return 0
A CHAC is dependable if for all ğ‘ƒğ‘ƒğ‘‡ adversaries A, its advantage
in the above experiment is negligible:
AdvdepA,CHAC(ğœ†) = Pr(cid:104)
CHAC(ğœ†) = 1(cid:105)
DEPA
= negl(ğœ†).
Definition A.12 (Anonymity). For the core/helper anonymous
credential and adversary A we define the following experiment:
CHAC(ğœ†)
ANONA
ğ‘ â†$ {0, 1}
O := {OHD, OCD, OObtain1, OObtain2, OHShow}
( ğ‘—0, ğ‘—1, Attrâˆ—, nonceâˆ—, iskâˆ—, ipkâˆ—, st) â†$ AO (ğœ†)
ğ‘–0 â†$ I2D[ ğ‘—0]; ğ‘–1 â†$ I2D[ ğ‘—1]
if ğ‘–0, ğ‘–1 âˆ‰ HD or Attrâˆ— âŠˆ ATTR[ ğ‘—0] âˆ© ATTR[ ğ‘—1] then return 0
aidâˆ— â†$ AIDGen(Attrâˆ—, nonceâˆ—)
apsig â†$ CShow(aidâˆ—, ipkâˆ—, DSK[ğ‘–ğ‘])
asig â†$ HShow(Attrâˆ—, nonceâˆ—, CRED[ ğ‘—ğ‘], ipkâˆ—, apsig)
ğ‘âˆ— â†$ AO (asig, st)
return ğ‘âˆ— = ğ‘
A CHAC is anonymous if for all ğ‘ƒğ‘ƒğ‘‡ adversaries A, its advantage
in the above experiment is negligible:
ANONA
AdvanonA,CHAC(ğœ†) = Pr(cid:104)
CHAC(ğœ†) = 1(cid:105)
= negl(ğœ†).
Note that the adversary returns iskâˆ— which means that in our def-
inition we assume an honestly generated issuerâ€™s key. This can
be ensured using standard proof techniques, i.e. the issuer proves
knowledge of the secret key. We define anonymity this way to
simplify our construction and proofs.
B PROOFS FOR SECTION 3
B.1 Proof of Theorem 3.2
2, ğ‘”ğ‘
1 , ğ‘”ğ‘
Proof. Let (BG, ğ‘”ğ‘
1, ğ‘”ğ‘
1, ğ‘”ğ‘‘
1, ğ‘”ğ‘
SFPK
2, ğ‘”ğ‘
2, ğ‘”ğ‘‘
1, Sigâˆ—
2, Sigâˆ—
, ğ‘šâˆ—, pkâˆ—
SFPK = (Sigâˆ—
2) be an instance of the
BDDH problem. We will show that we can use any efficient adver-
sary A to solve the above problem instance. To do so, we will build
a reduction algorithm R that uses A in a black box manner.
Let ğ‘â„ the maximal number of random oracle queries made by the
adversary A and (Sigâˆ—
SFPK) be the forgery returned by
an adversary A, where Sigâˆ—
3). The reduction
choose a random index ğ‘– âˆˆ {1, . . . , ğ‘â„} and aborts the experiment in
case ğ‘šâˆ— is not the ğ‘–-th query of A to the random oracle. Note that
this means that the probability that R does not abort the experiment
at any point is 1/ğ‘â„. What is more, for the ğ‘–-th random oracle query
H(ğ‘šâˆ—) the reduction answers with ğ‘”â„ğ‘šâˆ—
To simulate the unforgeabilty experiment, the reduction first
prepares the common reference string ğœŒ by setting ğ‘Œ1 = ğ‘”ğ‘
1, ğ‘Œ2 = ğ‘”ğ‘
2.
Next R prepares the public key pkSFPK and the trapdoor ğœSFPK.
2 from the problem instance. It
For this it uses the values ğ‘”ğ‘
sets pkSFPK = (ğ‘”1, ğ‘”ğ‘
2). Moreover, the reduction
chooses ğ‘˜ğ‘¢ â†$ Zâˆ—
2) Â· ğ‘”ğ‘˜ğ‘¢2 ) and shares it
1) Â· ğ‘”ğ‘˜ğ‘¢1 , (ğ‘”ğ‘
with A.
To answer Aâ€™s signing queries for message ğ‘š and randomness
ğ‘¡ (which is equal to 1 for oracle O1), the reduction R follows the
following steps:
1 and ğ‘”ğ‘
ğ‘, sets stpub = ((ğ‘”ğ‘
1) and ğœSFPK = (ğ‘”ğ‘
1
.
ğ‘”â„ğ‘š1
(1) it first chooses ğ‘¤ğ‘¡ â†$ Zâˆ—
ğ‘,
(2) it programs the random oracle to output H(ğ‘š) = (ğ‘”ğ‘
(3) compute ğ‘¤ = ğ‘¤ğ‘¡ Â· ğ‘¡,
1)ğ‘¡Â·ğ‘˜ğ‘¢ Â· (ğ‘ˆ ğ‘¤
(4) it computes: Sig1
(5) set the pre-signature pSigSFPK := (Sig1
for some â„ğ‘š â†$ Zâˆ—
ğ‘,
SFPK = (ğ‘”ğ‘
1 )â„ğ‘š,
, ğ‘¤).
SFPK
1)âˆ’ğ‘¤âˆ’1
ğ‘¡
Â·
Session 6D: Authentication and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea20201
Â· ((ğ‘”ğ‘
1)âˆ’ğ‘¤âˆ’1 Â· ğ‘”â„ğ‘š1
1)âˆ’ğ‘¤âˆ’1 Â· ğ‘”â„ğ‘š1
, ğ‘šâˆ—, Sigâˆ—
It is easy to see that this is a valid pre-signature. Note that a valid
one is of the form (ğ‘”ğ‘Â·ğ‘Â·ğ‘¡
)ğ‘Ÿ , ğ‘¤). In this case, the
reduction has set ğ‘Ÿ = ğ‘¡ Â· ğ‘¤ Â· (ğ‘ + ğ‘˜ğ‘¢) and this means that the ğ‘”ğ‘Â·ğ‘Â·ğ‘¡
1
cancels out and the reduction does not need to compute ğ‘”ğ‘Â·ğ‘
. Note
1
that this only works because the reduction is able to program the
random oracle and does not actually know the value ğ‘Ÿ. We also
assume that if A queries a message ğ‘š prior to a query to signing
queries, the reduction answers with H(ğ‘š) = (ğ‘”ğ‘
and
retains (ğ‘¤, â„ğ‘š).
Finally, the adversary outputs the forgery (pkâˆ—
SFPK)
of A and the reduction proceeds as follows:
(1) parse Sigâˆ—
SFPK),
, Sig3
SFPK)âˆ’â„ğ‘šâˆ—
Â· H(ğ‘šâˆ—)ğ‘Ÿâˆ— Â· (ğ‘”ğ‘Ÿâˆ—
)ğ‘Ÿâˆ— Â· (ğ‘”ğ‘Ÿâˆ—
Â· (ğ‘”â„ğ‘š1
SFPK = (ğ‘”ğ‘¡âˆ—
2).
1 , ğ‘”ğ‘‘
(4) output 1 iff ğ‘’(ğ‘”ğ‘Â·ğ‘Â·ğ‘¡âˆ—
The probability that R successfully solves the bilinear decisional
Diffie-Hellman problem depends on the advantage of A and the
probability that Râ€™s simulation succeeds.
[pkSFPK]R and we have pkâˆ—
use ğ‘”ğ‘¡âˆ—
1 ,
1 )âˆ’â„ğ‘šâˆ—(cid:17) ,
1 )âˆ’â„ğ‘šâˆ—(cid:17) ,
, and since for a valid forgery then pkâˆ—
SFPK âˆˆ
1)ğ‘¡âˆ—) and R can
(cid:16)ğ‘”ğ‘Â·ğ‘Â·ğ‘¡âˆ—
(cid:16)ğ‘”ğ‘Â·ğ‘Â·ğ‘¡âˆ—
SFPK Â· (Sig
1
1
(3) parse pkâˆ—
2) = ğ‘’(ğ‘”ğ‘¡âˆ—
, ğ‘”ğ‘
(2) compute
as (Sig1
ğ‘”ğ‘Â·ğ‘Â·ğ‘¡âˆ—
1
1 , (ğ‘”ğ‘
, Sig2
= Sig
SFPK
SFPK
SFPK
SFPK
=
=
SFPK
2
1
1
â–¡
Ë†ğ‘¦âˆ— =ğœ‹ Ë†ğ‘¦+âˆ‘ï¸
Ë†ğ‘£âˆ— =ğœ‹ Ë†ğ‘£+âˆ‘ï¸
ğ‘–âˆˆ[â„“]
B.2 Proof of Lemma 3.6
Proof. We exactly follow the proof of the underlying FHS15
SPS-EQ scheme in [45] and only highlight the differences. To ease
the readability we write elements in G2 with â€œhatâ€, e.g., as Ë†ğ‘‰ instead
of ğ‘‰2, and consequently the forgery is denoted as (ğ‘, ğ‘Œ, Ë†ğ‘Œ, Ë†ğ‘‰). Now,
if the take the discrete logarithms of all available group elements in
the forgery, we get an additional Ë†ğ‘‰ âˆ— term (Ë†ğ‘£âˆ—) and need to consider
the contributions of the â„ elements (with coefficients ğœƒğ‘–) and Ë†ğ‘£ ğ‘—
elements (with coefficients ğœˆ ğ‘—) from the ğ‘ queries. So the changes
to Ë†ğ‘¦âˆ— and the additional element Ë†ğ‘£âˆ— are:
ğ‘–âˆˆ[ğ‘˜]
ğœƒ Ë†ğ‘¦,ğ‘–â„ğ‘–+âˆ‘ï¸
ğœ’ Ë†ğ‘¦,ğ‘–ğ‘¥ğ‘–+âˆ‘ï¸
ğœƒ Ë†ğ‘£,ğ‘–â„ğ‘–+âˆ‘ï¸
ğœ’ Ë†ğ‘£,ğ‘–ğ‘¥ğ‘–+âˆ‘ï¸
âˆ‘ï¸
ğ‘— âˆˆ[ğ‘]
ğœˆ Ë†ğ‘¦,ğ‘— ğ‘£ ğ‘— +âˆ‘ï¸
ğœˆ Ë†ğ‘£,ğ‘— ğ‘£ ğ‘— +âˆ‘ï¸
ğ‘— âˆˆ[ğ‘]
ğ‘— âˆˆ[ğ‘]
ğœ“ Ë†ğ‘¦,ğ‘—
ğœ“ Ë†ğ‘£,ğ‘—
1
ğ‘¦ ğ‘—
1
ğ‘¦ ğ‘—
ğ‘–âˆˆ[â„“]
ğ‘–âˆˆ[ğ‘˜]
ğ‘— âˆˆ[ğ‘]
From the forgery we know that we have
ğ‘– ğ‘¥ğ‘– = ğ‘§âˆ— Ë†ğ‘¦âˆ—
ğ‘šâˆ—
ğ‘¦âˆ— = Ë†ğ‘¦âˆ—
Ë†ğ‘£âˆ— = ğ‘¦âˆ— Ë†â„âˆ—
ğ‘–âˆˆ[â„“]