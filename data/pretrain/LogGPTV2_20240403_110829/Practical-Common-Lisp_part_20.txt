 DEFMACRO
^(if ,condition (progn ,@body)))
(when (> x 10) (print 'big)))
第8章 
 documentation string."
如何自定义宏
(condition &rest body)
www.TopSage.com
，用它保存传递给一个对foo调用的实参。但在宏展开期，
、可选文档字符串以及Lisp表达式体所构成。?但如前所
---
## Page 98
了无谓的新颖语法的宏更易于理解和使用。
数。仿照标准的DOLIST和DOTIMES宏来定义是合理的。按照已有宏的模式操作的宏比那些引人
这个循环在每个大于等于0并小于等于19的素数上分别依次执行循环体，并以变量p保存当前素
成的代码。假设你开始时想通过如下代码来表示循环：
继的素数上。这并不是一个特别有用的宏，它只是在演示该过程。
DOTIMES和DOLIST的循环构造，只是它并非选代在整数或者一个列表的元素上，而是选代在相
8.4示例宏：do-primes
其实参的下一个素数。这两种情况都可以使用简单而低效的暴力手法来解决。
轻易避免的，只要知道如何检查它们就行。8.7节将讨论具体的方法。
用环境中的代码进行交互。后面将会看到，宏只能以很少的几种方式泄漏，而所有这些都是可以
没有“泄漏”其实现细节。有漏洞的宏抽象将只适用于特定参数上，或会以预想之外的方式与调
则会是一个庞大的独立程序，它将带有配套的助手函数和数据结构。
单的宏来说，这将极其轻松一
去编写一个宏调用的示例以及该调用应当展开成的代码。.
要知道正在向何处去，然后才能期待编写代码来自动地做到这点。因此编写宏的第一步是至少应
相同的代码模式并认识到通过抽象该模式可以使代码更清晰后，才开始决定编写宏的。
编写的代码开始来编写宏的，就是说从一个示例的宏形式开始。其他时候则是在连续几次编写了
首先你需要两个工具函数：一个用来测试给定的数是否为素数，另一个用来返回大于或等于
在已经编写了代码来完成从示例调用到适当的展开式的转换以后，需要确保宏所提供的抽象
一旦有了示例调用及预想的展开式，那么就可以开始第二步了：编写实际的宏代码。对于简
无论从哪一端开始，你都需要在开始编写宏之前搞清楚另一端：既需要知道从哪里开始，又
如果没有do-primes宏，你可以用po（和前面定义的两个亡具函数）来写出下面这个
现在就可以写这个宏了。按照前面所概括的过程，至少需要一个宏调用示例以及它应当展开
为了观察这三步过程是怎样发挥作用的，下面将编写一个宏do-primes，它提供了一个类似
(3)确保宏抽象不产生“泄漏”。
(1)编写示例的宏调用以及它应当展开成的代码，反之亦然；
总结起来，编写宏的步骤如下所示：
(defun next-prime (number)
(defun primep (number)
(2)编写从示例调用的参数中生成手写展开式的代码；
(((((y xau po) do1az) 1aau (raqu aost) on z woy oy 1og doo)
((d
一编写一个反引用模板并将宏参数插入到正确的位置上。复杂的宏
www.TopSage.com
8.4示例宏：do-primes
81
---
## Page 99
式。通常，&body被用来保存一个构成该宏主体的形式的列表。
是等价的，但许多开发环境根据一个&body形参的存在来修改它们缩进那些使用该宏的代码的方
绑定到该形参列表的表达式的元素中获得其值。例如可以将var-and-range替换成一个列表
的列表结构形式。
do-primes的展开式。
都持有一个从var-and-range中提取出的值，它们随后被插入到反引用表达式中以生成
然后手工分拆该列表，类似下面这样：
出现在展开式中，三个元素被拆分开并分别放在不同的位置上。
含有循环变量的名字p及其下界0和上界19。但如果查看展开式就会发现，该列表作为整体并没有
步骤相当简单：只需定义正确的形参来保存不同的实参就可以了。
那些对象中用于计算展开式的部分。对于那些简单地将其实参直接插人到模板中的宏而言，这一
8.5
循环：
说明它的用途：
(var startend），然后这个列表的三个元素将被自动解构到三个形参上。
(destructuring）形参列表。顾名思义，
尽管如此，但并不需要“手工”分拆var-and-range，因为宏形参列表是所谓的解构
82
因此你可以通过将do-primes定义成下面这样来完成其定义,并同时向读者和你的开发工具
宏形参列表的另一个特性是可以使用&body作为&rest的同义词。&body和&rest在语义上
在解构形参列表中，简单的形参名将被替换成嵌套的形参列表。嵌套形参列表中的形参将从
稍后，将解释上述宏形式体怎样生成正确的展开式。目前只需注意变量var、start和end
可以用两个形参来定义do-primes，一个用来保存该列表，另一个&rest形参保存形式体，
由于传递给宏的实参是代表宏调用源代码的Lisp对象，因此任何宏的第一步工作都是提取出
现在就可以开始编写将前者转化成后者的代码了。
(do ((p (next-prime 0) (next-prime (1+ p))))
(defmacro do-primes ((var start end) &body body)
(defmacro do-primes (var-and-range &rest body)
宏形参
(do ((,var (next-prime ,start) (next-prime (l+ ,var))))
let{(var
第8章如何自定义宏
，@body)）)
end(third
(start
second
var
and-range)
www.TopSage.com
and
“解构”涉及分拆一个结构体，在本例中是传递给一个宏
---
## Page 100
种形式的求值结果。
列表结构就可以了。
取成(lista‘b)。语言标准并未明确指定读取器必须产生怎样的代码，只要它能生成正确的
器读到一个反引用表达式时，它将其翻译成生成适当列表结构的代码。例如，（，ab）可以被读
别简洁的方式。这种理解方式的优点是可以相当明确地看到其表象之下实际发生的事——当读取
号，其值（必须是一个列表）可被“拼接”到其所在的列表中。
接着一个“@”符号。没有这个“@”符号，逗号会导致子表达式的值被原样包含。有了“@”符
达式很相似，除了可以“解引用”（unquote）特定的值表达式，即前面加上逗号，可能其后还会
板中来得到展开式。
8.6
尽管如此，你在编写do-primes的过程中却不需要任何这些选项。
以更明确地告诉你宏调用的语法。使用最初的定义，SLIME将告诉你do-primes可以像这样来调用：
像你用太多或太少的参数调用了一个函数那样。同样，在诸如SLIME这样的开发环境中，只要输入
do-primes，Lisp可以检测到那些首参数不是三元素列表的调用，并提供有意义的错误信息，就好
表8-1给出了一些反引用表达式的范例，同时带有与之等价的列表构造代码以及其中任意一
对于像do-primes这样简单的宏，反引用语法刚好合适。回顾一下，反引用表达式与引用表
①APPEND函数尚未提及，它能够接受任意数量的列表实参并返回一个由它们拼接而成的单独列表。
（a（1ist12）c）
（a，（+12）c）
（a（+12）c）
采用另一种方式也会有助于理解反引用语法，这就是将其视为编写生成列表的代码的一种特
由于do-primes是一个相当简单的宏，在解构了参数以后，剩下的就是将它们插入到一个模
(a
解构形参列表可以含有&optional、&key和&rest形参，并且可以含有嵌套的解构列表。
但在新定义下，它可以告诉你一个调用应当看起来像这样：
除了更加简洁以外，解构形参列表还可以让你自动检查错误。通过以这种方式定义
(a
(do-primes(varstart end)&body body)
(do-primesvar-and-range &rest body)
生成展开式
,@（1ist12）c)
,（list12）c）
反引用语法
@body))
(（>，var，end）)
(append(1ist'a)(1ist12)(list'c))
(list'a(list12）'c)
(lista（1ist12)'c)
(list'a（+12）'c）
(list'a（+12）c）
表8-1
www.TopSage.com
等价的列表构造代码
反引用表达式的例子
8.6
生成展开式
a
（a(12）c）
（a(1ist12）c)
(a3c)
（a（+12）c）
12c）
结
果
---
## Page 101
abstraction)，以此来描述一种抽象：“泄露”了本该抽象的细节。由于编写宏是一种创造抽象的
8.7
MACROEXPAND-1上，并将结果“美化输出”到一个临时缓冲区上。
的开括号上，并输人C-c RET来调用Emacs函数slime-macroexpand-1，后者将把宏调用传递到
传给它一个字面的宏形式，就必须引用它。可以用它来查看前面调用的展开式。
Lisp表达式作为参数并返回做宏展开一层的结果。?由于MACROEXPAND-1是一个函数，所以为了
最初的用例键入到REPL中，你会看到它确实打印出了正确的素数序列。
也就是说，如果结果的行为是正确的，那么展开式很可能就是正确的。例如，可以将do-primes 
它至少应能适用于最初的例子。可以用两种方式来测试它。可以简单地通过使用来间接地测试，
我们可以将do-primes的反引用版本和下面的版本作比较，后者使用了显式的列表构造代码：
来do-primes是有效的。
无论怎样得到展开式，你都可以看到宏展开的结果和最初的手写展开式是一样的，因此看起
84
②如果所有宏展开被显示在一行里，这很有可能是因为变量*PRINT-PRETTY*为NIL。如果是这样，求值（Setf
①另一个函数MACROEXPAND将持续地展开结果，只要返回的展开式的第一个元素是宏的名字，它就会不断进行下
Jeol Spolsky在他的随笔“The Law ofLeaky Abstractions”里创造了术语“有漏洞的抽象”（leaky
或者，在SLIME中也可以更方便地检查一个宏的展开式：将光标放置在源代码中一个宏形式
((d  P~ 2 euxog) (61 0 d) sauTaa-op)  var end)))
(list
(do)
"~d“P))
(list (list var
www.TopSage.com
(list
(list 'next-prime start)
((((( +. as) aud-xau.
?
---
## Page 102
选代过程中改变其值。因此可以用下列定义来修复多重求值问题：
后将会用到的变量里。回想在Do循环中，用一个初始形式但没有步长形式来定义的变量并不会在
值，所以多数程序员将期待do-primes具有相似的行为。
构建在标准宏DOTIMES和DOLIST之上的，而这两个宏都不会导致其循环体之外的形式被多次求
程序员们希望他们传递给宏的形式除非必要将不会被多次求值。?更进一步，由于do-primes是
你在实现宏时应当试图遵守最少惊动原则（Principle of Least Astonishment)。而且通常情况下，
次的情况。一种堵住漏洞的方式是简单地将其定义成do-primes的行为。但这并不非常令人满意，
返回的统一分布相当不同的分布形式。
随机数时，循环才会终止。由于循环的整体次数仍然是随机的，因此它将产生一个与RANDOM所
环将不会在p大于一个初始给定的随机数时终止,而是在循环刚好生成一个小于或等于当前p值的
数。但MACROEXPAND-1的结果显示这并不是当前实现所做的事。
调用do-primes：
假设没有使用诸如19这样的字面数字，而是用像（random 100）这样的表达式在end的位置上来
出一个给定的宏是否存在着任何一种泄露方式，并修复它。
方式，故此需要确保宏不产生不必要的泄露。
这就是一种抽象中的漏洞，因为为了正确使用该宏，调用者必须注意end形式被求值超过一
②当然，特定形式其本意就是被多次求值，例如一个do-primes循环体中的形式。
① 该随笔出自 Joel Spolsky的Joel on Sofware， 你也可以查阅htp:/www.joelonsoftware.com/articles/LeakAbstactions.html
修复多重求值问题是相当容易的：只需生成代码来对end求值一次，并将其值保存在一个稍
当前的宏定义存在三种可能的宏泄露中的一种，确切地说，它会过多地对end子形式求值。