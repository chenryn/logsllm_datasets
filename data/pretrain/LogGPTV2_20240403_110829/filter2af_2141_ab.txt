压缩完成后将数据通过sendHttpResponse方法向服务器发送请求。请求完成后从服务器获取到返回结果, 然后将结果进行gzip解压缩,
解压缩后的内容为byte数组, 作为evalFunc的返回值。而test()方法就是对evalFunc方法返回的byte数组进行字符串转化,
如果转化后生成的字符串内容是ok, 则返回true。这里的evalFunc发送的请求是第二次发送的请求, 服务器返回的内容解密后就是ok：
好, 到了这里我们回到之前的testButtonClick方法：
上文我们讲述的大部分内容都是该testButtonClick方法的 this.shellContext.initShellOperation() 语句,
接下来要执行的语句就是 this.shellContext.getPayloadModel().test() 语句, 这语句在
this.shellContext.initShellOperation() 中已经执行过一次了, 也是发送一段test请求给服务器,
服务器会返回ok字符串, 这就是在burpsuite中看到的第三次请求。所以我们在burpsuite会发现第二次请求和第三次请求是一模一样的：
到了这里我们就分析完testButtonClick()方法, 也就是在哥斯拉webshell配置界面点击测试连接时的处理流程, 哥斯拉的其他请求过程类似,
大家可以自行研究, 接下来我们来对哥斯拉请求包响应包加密进行分析,
在上文我们已经知道了哥斯拉请求数据的加密统一在sendHttpResponse方法中进行处理, 因此下文的分析结果在哥斯拉其他请求中可以直接使用,
一键解密, 不单单局限于测试连接的请求加解密。
##### 哥斯拉请求包加密过程分析
接下来我们来分析哥斯拉请求包加密流程, 这里我们主要针对JAVA_AES_BASE64载荷的加密算法,
从上文我们可以找到加密统一在sendHttpResponse中调用Cryption接口encode方法进行数据加密,
在这里就是调用JavaAesBase64的encode方法, 我们进入该方法：
我们可以看到加密过程如下：
    data -> aes加密
                ->  base64编码
                        ->  url编码
                                -> 加密后的data
所以我们要对请求包加密的内容进行解密只要按照加密流程逆着来就可以了：
    加密后的data  -> url解码
                        ->  base64解码
                                -> aes 解密
                                        ->  data
我们利用该解密思路解密第一个请求包, 发现可以成功解密, 但因为该请求包原始内容是class文件的字节码, 因此转化为String类型输出后会存在乱码。
接着用同样的解密思路解密第二个请求包, 输出的内容是一段乱码, 发现事情并不简单：
从上文我们可以知道所有发送的数据请求包都是统一进行加密的, 唯一不同的就是两次请求的数据来源, 第一次请求发送的是class文件的字节码,
是直接读取class文件的内容, 而第二次与第三次发送的请求是哥斯拉客户端自己构造的数据, 猜测哥斯拉客户端可能构造了自己的数据请求格式,
我们回到哥斯拉发送数据请求的位置, 即evalFunc方法位置处：
我们可以看到传入的数据是经过gzip压缩的, 那么如果我们对解密后的数据进行gzip解压缩可以获取到真正的数据内容吗, 发现可以成功获得数据内容：
但是依旧有乱码信息, 说明解密的还不够全面, 秉持着研究的精神, 我们继续对发送的请求内容进行查看。请求的内容通过 parameter.formatEx()
方法获得, 我们进入该方法：
方法中调用serialize() 方法, 进入serialize 方法：
parameter对象通过add方法添加的键值对都存储到parameter对象的hashMap成员变量中。serialize方法实际上就是把hashMap中的键值对转化为
byte[] 返回, 这里返回的byte[] 就是哥斯拉请求所发送的原始数据。该方法对hashMap的处理方式如下:
    取出hashMap中的第一个键值对
        ->  获取键值的byte[]数组, 写入到 outputStream输出流
        ->  写入 2 的 byte值 到outputStream输出流
        ->  定义一个byte[4]数组, 大小固定为4位, 用该数组来表示键值对中值所代表的的字节数组长度, 将该byte[4]数组写入到 outputStream输出流
        ->  获取键值对中值的字节数组, 写入到 outputStream输出流
    取出hashMap中的第二个键值对
        ....
    重复操作, 直到hashMap中的键值对都写入后, 将outputStream输出流转化为byte[] 返回
因此我们通过解密获取到请求包内容后`(以byte[]方式表示)`, 要得到有效内容, 也就是仅保留键值对的内容, 将多余内容删除掉,
因此我们可以定义一个格式化函数, 用来格式化解密后的请求包内容, 该格式化函数处理数据流程如下：
    一个字节一个字节读取解密后的请求包 byte[]
        直到读出2, 在2出现之前的内容存储到一个名为key的byte[]中, 用来存储key
        将读到的2丢掉
        在2之后读取四个字节, 通过读到的四个字节来计算获得键值对的值字节长度
        读取计算得到的字节长度, 将内容存储到一个名为value的byte[]中, 用来存储value
        这就算是完成了第一个键值对的读取, 之后重复该流程, 读取其他在数据包中的键值对
将获取到的键值对以 键=值 的形式输出, 我们来运行一下结果`(gzip解压缩操作已经在该格式化函数中进行处理)`：
成功解析数据, 通过该解密流程进行工具书写：
用burpsuite抓取命令执行的流量, 进行解析, 发现可成功解析：
另外该解密思路也可以解密jspx文件请求包, jspx的命令执行请求包略有不同：
##### 哥斯拉响应包加密过程分析
接着我们来分析哥斯拉响应包加密过程。哥斯拉响应包数据加密在服务端脚本文件上进行处理, 也就是我们之前生成jsp脚本。该脚本文件分两部分代码,
上半部分用来定义加载器类和加解密算法, 下半部分则是具体的程序处理代码。
查看程序处理代码, 我们可以看到服务端对数据加密的流程也是先进行aes加密, 然后进行base64编码, 但是在数据发送之前还要经过一个步骤, 首先计算
md5( pass + xc)的值, 然后取计算值的前16位放置到加密数据的前面, 然后取计算值的后16位放置到加密数据的后面,
以此来组成真正发送的响应包数据。也就是说要对响应包进行处理的话, 首先去掉响应包数据的前16位以及后16位, 然后对剩下的数据进行 base64解码 +
aes解密, 之后gzip解压缩即可。我们可以编写程序进行尝试：
解密jspx脚本响应包加密数据
我们会发现成功解密数据。除了看服务器端如何处理之外,
我们也可以从哥斯拉客户端中查看客户端对服务端返回请求的处理方式来获取解密算法。我们以上文讲述的发送第二次请求包所调用的test方法为例：
该方法调用evalFunc方法, 进入该方法：
该方法中调用了sendHttpResponse 方法发送请求, 同时根据getResult方法来获取响应包内容, 我们进入getResult方法：
可以发现该方法直接获取result成员变量的byte[]值, 但这显然不是我们想要的, 我们需要处理该result成员变量的过程,
因此我们重新进入sendHttpResponse方法查看具体的处理过程：
重载函数, 继续进入：
重载函数, 继续进入：
我们可以看到这里 sendHttpResponse 方法调用了 sendHttpConn 方法, 我们进入该方法：
该方法返回了一个new HttpResponse(), 而之前我们获取服务端响应的getResult方法就是HttpResponse对象的方法,
我们进入该方法：
该方法调用了handleHeader方法, 该方法主要用于Cookie的处理, 如果此次请求服务端webshell没有Cookie的话,
会将服务端返回的cookie保存起来, 下次请求服务器webshell会带上该cookie, 所以我们可以看到在第一次请求之后, 第二次第三次请求,
burpsuite上面抓到的包都带有cookie：
接着我们查看ReadAllData方法：
我们可以看到在这个方法中调用了decode方法进行解密, 并将解密的结果赋值给result成员变量,
也就是说上文通过getResult获取到的result变量是在这里进行赋值的。另外这里调用decode方法也给了我们一个信息, 也就是说不单单是数据加密,
数据解密在哥斯拉客户端也是在进行统一处理的。这里调用的decode的方法, 对应于调用JavaAesBase64类的decode方法, 我们进入该方法：
我们可以看到在该方法中就写明了对服务端数据的处理过程, 和我们之前得出的结果一样, 也是先base64解码,
然后aes解密获得。但是在进行base64解码之前还需要通过findStr方法对获取到的服务端数据进行预处理, 我们进入该方法：
我们会发现该方法用到了findStrLeft 和 findStrRight, 找到这两个成员变量赋值的地方：
我们会发现这两个成员变量的值分别对应于 md5 (pass + key)
后的前16位以及后16位的内容。然后我们继续看findStr方法中调用的subMiddeStr方法：
这个subMiddleStr方法正好就是截取findStrLeft以及findStrRight字符串中间的部分,
这就和我们之前得出的去掉响应包返回内容的前16位以及后16位正好匹配上了。由此可以得出对服务端响应包的内容进行解密流程为：
    计算出 md5 (pass + key), 对响应包截取该md5后的前16位以及后16位
        对截取后的响应包内容进行 base64解码 +  aes解密  + gzip解压缩
可能有人会疑惑gzip解压缩是在那里看出来的, 我们回到最开始evalFunc方法,
我们可以看到在这里调用了gzip解压缩方法对解密后的响应包数据进行解压缩：
到了这里顺便拓展一下每次连接时的第一个请求包所发送的class类文件的字节码的作用。我们可以对该class类字节码文件进行反编译,
反编译出的java文件包含了大量的webshell服务端管理所对应的处理方法。
我们回到生成的webshell进行查看, 我们可以看到在服务端webshell对接收到的class类字节码进行加载类, 加载到session中,
之后用户请求webshell, 服务端都从用户请求所对应的session中取出该类, 初始化对象,
然后调用该类中的方法进行相关方法的调用。所以在第一次请求后服务端会返回cookie, 而之后哥斯拉客户端发送请求会带上该cookie,
该cookie就是用来给服务端进行识别并加载session中的类。
另外查看反编译出class文件, 我们可以看到对客户端发起请求的数据进行处理的方法都写在里面, 例如对解密后的客户端数据进行格式化的
formatParameter 方法：
#### 0x02 后记
  * 关于jsp服务端和客户端的其他连接请求处理, 命令执行, 文件管理等;
  * 关于哥斯拉asp、php的webshell处理相关内容等;
  * 关于冰蝎等其他类型webshell管理工具等;
后续会写对应分析文章。