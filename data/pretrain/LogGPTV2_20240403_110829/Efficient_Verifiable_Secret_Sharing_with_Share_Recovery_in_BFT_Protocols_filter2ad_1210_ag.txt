[11] I. Cascudo and B. David. 2017. SCRAPE: Scalable randomness attested by public
entities. In International Conference on Applied Cryptography and Network Security
(ACNS). Springer, 537–556.
[12] M. Castro and B. Liskov. 2002. Practical Byzantine Fault Tolerance and Proactive
Recovery. ACM Transactions on Computer Systems 20, 4 (2002).
[13] B. Chor, S. Goldwasser, S. Micali, and B. Awerbuch. 1985. Verifiable secret sharing
and achieving simultaneity in the presence of faults. In 26th IEEE Symposium on
Foundations of Computer Science (FOCS). 383–395.
[14] R. Cramer, R. Gennaro, and B. Schoenmakers. 1997. A Secure and Optimally Effi-
cient Multi-Authority Election Scheme. In Advances in Cryptology – EUROCRYPT
1997. 103–118.
[15] I. Damgård, V. Pastro, N. Smart, and S. Zakarias. 2012. Multiparty computation
from somewhat homomorphic encryption. In Advances in Cryptology – CRYPTO
2012 (LNCS), Vol. 7417. 643–662.
[16] Y. Desmedt and Y. Frankel. 1991. Shared generation of authenticators and signa-
tures. In Advances in Cryptology – CRYPTO 1991. 457–469.
[17] Y. Desmedt and S. Jajodia. 1997. Redistributing secret shares to new access structures
and its applications. Technical Report ISSE TR-97-01. George Mason University.
[18] Y. Deswarte, L. Blain, and J.-C. Fabre. 1991. Intrusion tolerance in distributed
computing systems. In IEEE Symposium on Security and Privacy. 110–121.
[] S. Duan, M. K. Reiter, and H. Zhang. 2017. Secure causal atomic broadcast, revis-
ited. In International Conference on Dependable Systems and Networks (DSN)’17.
61–72.
[19] C. Dwork, N. Lynch, and L. Stockmeyer. 1988. Consensus in the Presence of
Partial Synchrony. J. ACM 35, 2 (April 1988), 288–323.
[20] P. Feldman. 1987. A practical scheme for non-interactive verifiable secret sharing.
In 28th IEEE Symposium on Foundations of Computer Science (FOCS). 427–438.
[21] Y. Frankel, P. Gemmell, P. D. MacKenzie, and M. Yung. 1997. Optimal-resilience
proactive public-key cryptosystems. In IEEE Symposium on Foundations of Com-
puter Science (FOCS) 1997. 384–393.
[22] M. Franklin and M. Yung. 1992. Communication Complexity of Secure Computa-
tion (Extended Abstract). In ACM Symposium on Theory of Computing (STOC)
1992. 699–710.
[23] G. R. Ganger, P. K. Khosla, M. Bakkaloglu, M. W. Bigrigg, G. R. Goodson, S. Oguz,
V. Pandurangan, C. A. N. Soules, J. D. Strunk, and J. J. Wylie. 2000. Survivable
storage systems. IEEE Computer 33 (2000), 61–68. Issue 8.
[] G. G. Gueta, I. Abraham, S. Grossman, D. Malkhi, B. Pinkas, M. K. Reiter, D.-A.
Seredinschi, O. Tamir, and A. Tomescu. 2019. SBFT: a scalable and decentralized
trust infrastructure. In 49th International Conference on Dependable Systems and
Networks (DSN).
[25] M. P. Herlihy and J. D. Tygar. 1988. How to make replicated data secure. In
Advances in Cryptology – CRYPTO ’87 (LNCS), Vol. 293. 379–391.
[26] M. P. Herlihy and J. M. Wing. 1990. Linearizability: A correctness condition for
concurrent objects. ACM Transactions on Programming Languages and Systems
12 (July 1990), 463–492. Issue 3.
[27] A. Herzberg, M. Jakobsson, S. Jarecki, H. Krawczyk, and M. Yung. 1997. Proac-
tive Public Key and Signature Systems. In 4thACM Conference on Computer and
Communications Security (CCS). 100–110.
[28] A. Herzberg, S. Jarecki, H. Krawczyk, and M. Yung. 1995. Proactive Secret Sharing
Or: How to Cope With Perpetual Leakage. In Advances in Cryptology – CRYPTO
’95, Vol. 963. 339–352.
[29] A. Kate, G. M. Zaverucha, and I. Goldberg. 2010. Constant-size commitments
to polynomials and their applications. In Advances in Cryptology – ASIACRYPT
2010 (LNCS), Vol. 6477. 177–194.
[30] E. Kokoris-Kogias, E. C. Alp, S. D. Siby, N. Gailly, L. Gasser, P. Jovanovic, E. Syta,
and B. Ford. 2018. CALYPSO: Auditable Sharing of Private Data over Blockchains.
Cryptology ePrint Archive, Report 2018/209. https://eprint.iacr.org/2018/209.
[31] R. Kotla, L. Alvisi, M. Dahlin, A. Clement, and E. L. Wong. 2009. Zyzzyva:
Speculative Byzantine fault tolerance. ACM Transactions on Computer Systems
27, 4 (2009).
[32] R. Kotla, A. Clement, E. Wong, L. Alvisi, and M. Dahlin. 2008. Zyzzyva: speculative
byzantine fault tolerance. Commun. ACM 51, 11 (2008), 86–95.
[33] H. Krawczyk. 1994. Secret sharing made short. In Advances in Cryptology –
CRYPTO ’93 (LNCS), Vol. 773. 136–146.
[34] S. K. D. Maram, F. Zhang, L. Wang, A. Low, Y. Zhang, A. Juels, and D. Song.
2019. CHURP: Dynamic-Committee Proactive Secret Sharing. Cryptology ePrint
Archive, Report 2019/017. https://eprint.iacr.org/2019/017.
[35] J.-P. Martin and L. Alvisi. 2006. Fast Byzantine consensus. IEEE Transactions on
Dependable and Secure Computing 3, 3 (July 2006), 202–215.
[36] Ian Miers, Christina Garman, Matthew Green, and Aviel D Rubin. 2013. Zerocoin:
Anonymous distributed e-cash from bitcoin. In IEEE Symposium on Security and
Privacy 2013. 397–411.
[37] A. Miller, Y. Xia, K. Croman, E. Shi, and D. Song. 2016. The honey badger of BFT
protocols. In 23rd ACM Conference on Computer and Communications Security
(CCS). 31–42.
[38] M. Naor, B. Pinkas, and O. Reingold. 1999. Distributed pseudo-random functions
and KDCs. In Advances in Cryptology – EUROCRYPT ’99 (LNCS), Vol. 1592. 327–
346.
[39] V. Nikov and S. Nikova. 2005. On Proactive Secret Sharing Schemes. In Interna-
tional Workshop on Selected Areas in Cryptography 2004. 308–325.
[40] M. Nojoumian and D. R. Stinson. 2013. On dealer-free dynamic threshold schemes.
Advances in Mathematics of Communications 7, 1 (Feb. 2013), 39–56.
[41] P. S. Nordhold and M. Veeningen. 2018. Minimising communication in honest-
majority MPC by batchwise multiplication verification. In International Con-
ference on Applied Cryptography and Network Security (ACNS) 2018 (LNCS),
Vol. 10892. 321–339.
[42] T. P. Pedersen. 1992. Non-interactive and information-theoretic secure verifiable
secret sharing. In Advances in Cryptology – CRYPTO ’91 (LNCS), Vol. 576. 129–140.
[] M. K. Reiter and K. P. Birman. 1994. How to securely replicate services. ACM
Transactions on Programming Languages and Systems 16, 3 (May 1994), 986–1009.
[] T. Rocket, M. Yin, K. Sekniqi, R. van Renesse, and E. G. Sirer. 2019. Scalable and
Probabilistic Leaderless BFT Consensus through Metastability. arXiv preprint
arXiv:1906.08936 (2019).
[43] Eli Ben Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers,
Eran Tromer, and Madars Virza. 2014. Zerocash: Decentralized Anonymous
Payments from Bitcoin. In IEEE Symposium on Security and Privacy 2014. 459–
474.
[44] D. Schultz, B. Liskov, and M. Liskov. 2010. MPSS: Mobile Proactive Secret Sharing.
ACM Transactions on Information and System Security 13, 4 (Dec. 2010), 1–32.
[45] A. Shamir. 1979. How to Share a Secret. Commun. ACM 22, 11 (Nov. 1979),
612–613.
Cryptology 1 (1988), 133–138.
[46] M. Tompa and H. Woll. 1988. How to share a secret with cheaters. Journal of
[47] T. M. Wong, C. Wang, and J. M. Wing. 2002. Verifiable Secret Redistribution for
Archive Systems. In International IEEE Security in Storage Workshop 2002.
[] M. Yin, D. Malkhi, M. K. Reiter, G. G. Gueta, and I. Abraham. 2019. HotStuff:
BFT consensus with linearity and responsiveness. In 38th ACM Conference on
Principles of Distributed Computing (PODC).
[48] L. Zhou and F. B. Schneider. 2005. APSS: Proactive Secret Sharing in Asynchro-
nous Systems. ACM Transactions on Information and System Security 8, 3 (Aug.
2005), 259–286.
A Security
In this appendix, we show why our composition of VSSR along
with PBFT is secure. We do this by first observing under what
conditions the share recovery protocol will terminate. To show
linearizability and liveness, we map every execution of our modified
PBFT algorithm to the original PBFT algorithm. Thus, since the
original PBFT algorithm satisfies linearizability and liveness, so
does our modified algorithm. Then, we show privacy separately.
Share Recovery Protocol Termination. We claim that the share
recovery protocol will always terminate if f + 1 replicas have
successfully completed the sharing and the network eventually
delivers all messages. To see why, recall that a replica that is miss-
ing its share needs the output of vssRecoverContrib∗ from f + 1
replicas. If f + 1 replicas are honest, then they will faithfully call
vssRecoverContrib∗ and send the output to a replica that is miss-
ing its share. The missing share can then be recovered by using
vssRecover∗ to terminate the share recovery protocol.
In the normal case protocol, we only have
Normal Case Protocol
changed how the client constructs requests. If a client is honest,
then we can simply ignore the secrets being shared in the request
and have the client send regular requests in the original run of the
PBFT algorithm. The requests are consistent due to the binding
property of our verifiable secret sharing (VSS) scheme. If a client
is dishonest and sends an invalid share to the replica, then in the
original PBFT protocol run the client will drop the request message
to the replica. Now, when the message is dropped, the replica can
still obtain the request from another replica in the system. In the
modified protocol, this is done using the share recovery protocol so
we simply wait to deliver the request messages in the original run
until the share recovery protocol terminates. Note that if the share
recovery protocol never terminates in the modified protocol, that
means that less than f + 1 honest replicas have the request. This
means that strictly less than 2f + 1 total replicas have the request,
making it impossible for this request to be prepared. Therefore, if
the modified normal case protocol never terminates, then neither
does the original protocol. Thus, we see that liveness is unchanged
from the original PBFT protocol.
Additionally, through the binding property of our underlying
VSS scheme, we know that if a request has been committed, all
secret values must be consistently shared. Thus, we see that the lin-
earizability property also follows from linearizability in the original
protocol along with binding.
The checkpoint protocol is identical to a case
Checkpoint protocol
where the state of the replicated service contains only the commit-
ments of the secret values instead of the secret values themselves.
Thus, by the binding property of the underlying VSS scheme, we
have a one to one mapping from a run of the checkpoint protocol
for our modified PBFT algorithm and the original PBFT algorithm.
Therefore, if the original PBFT’s checkpoint algorithm provides
liveness and linearizability, then so does our modified algorithm.
The state transfer protocol can be mapped
State Transfer Protocol
back similarly to the normal case protocol. A replica receiving the
value of a key using the share recovery protocol in our modified
PBFT would have been receiving the plaintext value of the key in
the original PBFT algorithm. We simply delay the plaintext value of
the key until the share recovery protocol completes in our modified
PBFT protocol. Additionally, in the state transfer protocol, we know
that the share recovery protocol will complete since at least 2f + 1
replicas have the state at the last checkpoint. This means that at
least f + 1 honest replicas have the state, which is sufficient to
guarantee termination during periods of synchrony.
Privacy Our modified PBFT protocol achieves privacy through
the hiding property of the VSS protocol. The hiding property says
that a legitimate adversary (i.e. one that has at most f shares of
the secret) cannot do nonnegligibly better than guessing the secret
at random. Thus, privacy is satisfied unless an adversary gets at
least f + 1 shares of a value. However, this means that some correct
replica has shared the secret with the adversary which contradicts
our threshold assumption. Thus, we see that our modified PBFT pro-
tocol preserves linearizability and liveness while also guaranteeing
privacy.
B Instantiation of Pedersen VSS
We describe how to fit the secret sharing scheme from Pedersen [42]
into our framework.
• vssInit(1κ , k, n) first chooses a safe prime q = 2q′ + 1 at least
κ bits in length, for q′ a prime. Also, we let д and h be two
distinct generators of the quadratic residues QR(Z∗
q) of Z∗
q
such that logд(h) is unknown. Then, vpki is set to ⟨д, h⟩ for
all i. vski is set to ⊥ for all i. The return value of vssInit is
⟨q, {⟨vpki , vski⟩}i∈[n]⟩.
• vssShare(s, q, {vpki}i∈[n]) first extracts the public key and
gets д and h as defined in vssInit. Set sj be the coefficient
of the x j term in s and s(i) be the evaluation of s at point i.
Pick t ∈ Zq[x] to be a random polynomial of degree k − 1.
Similarly, we let tj be the coefficient of x j term in t and
t(i) be the evaluation of t at point i. Now, we set ui to be
⟨s(i), t(i)⟩. Here, all linear operations on ui values are just
done element-wise. Set c to be {дsj htj }j∈[k]. Then, vssShare
returns ⟨c, {ui}i∈[n]⟩.
• vssVerify(vpki , c, ui) first extracts {дsj htj }j∈[k] from c. Then,
s(i), t(i) is extracted from ui. We return true if дs(i)ht(i) =
j=0 (дsj htj)i j and false otherwise.
• vssReconstruct(c, {⟨vpki , ui⟩}i∈I) first calls
vssVerify(vpki , c, ui) for all i ∈ I. If all of vssVerify calls re-
turn true, then we continue. Otherwise, vssReconstruct re-
turns ⊥. Then, we extract s(i), t(i) from each ui. Finally, we
simply do a Lagrange interpolation in order to identify the
unique degree k − 1 polynomial in Zq[x] that goes through
the points (i, s(i)) for all i ∈ I and return that value.
• vssMakeSecret(q, {⟨xi , yi⟩}i∈I) is identical Kate et. al.’s [29]
instantiation described in Section 3.7.1.
• vssCombineCommitments(c, ˆc) extracts {дsj htj }j∈[k] from
c and {д ˆs jh
ˇc = {(д ˆs jh
ˆtj }j∈[k] from ˆc. Then, it returns
ˆtj)(дsj htj)}j∈[k].
k−1
C PBFT State Transfer and View Change
In this section, we describe the PBFT state transfer and view change
protocols.
C.1 View Change Protocol
The view change protocol changes the leader. The core mechanism
for transferring safe values across views is for a new leader to collect
a set P of view-change messages from a quorum of 2f + 1 replicas.
Each replica sends a view-change message containing the replica’s
local state: Its local request-log, and the commit-certificate with the
highest view number it responded to with a commit message, if
any.
The leader processes the set P as follows.
(1) Initially, it sets a leader-log G to an empty log.
(2) If any view-change message contains a valid commit-certificate,
then it selects the one with the highest view number and
copies its log to G. Share recovery is triggered for any re-
quests in G that the leader is missing its private share.
The leader sends a new-view message to all replicas. The message
includes the new view number, the set P of view-change messages
the leader collected as a leader-proof for the new view, and the
leader-log G. A replica accepts a new-view message if it is valid
and adopts the leader log. It may need to roll back speculatively
executed requests, and process new ones. As usual, processing may
entail triggering share-recovery for any requests where the replica
is missing its private share.
C.2 State Transfer Protocol
We present a modified version of the PBFT state transfer protocol
that is simpler and more suited when TCP is used for the underlying
network protocol. When a replica has fallen behind, it sends a state
transfer request along with its current sequence number to at least
f + 1 replicas. Some replica will respond with the most recent
valid checkpoint messages and the messages from the normal case
protocol that were missed by the slow replica. In addition, the
response will contain only the values of the keys that have changed
since the sequence number known to the slow replica as well as
the full requests that came after the last checkpoint.