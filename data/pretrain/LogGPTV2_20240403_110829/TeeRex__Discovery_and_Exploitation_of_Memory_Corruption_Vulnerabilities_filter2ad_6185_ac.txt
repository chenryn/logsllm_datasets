USENIX Association
results are still useful because they can lift limited exploitation
primitives (e.g., null-pointer dereference or write to an arbi-
trary address with a ﬁxed value) to full control-ﬂow hijacking
attacks (see Section 5.5 for an example).
4.3 Vulnerability Detection Components
We implemented three major vulnerability detection compo-
nents in TEEREX: (1) attacker-controlled branches (control-
ﬂow hijacking), (2) controlled writes, and (3) NULL-pointer
dereferences. To analyze an enclave, TEEREX ﬁrst reads the
ECALL table from an enclave and symbolically executes the
ECALL functions sequentially. We pass fully symbolic ar-
guments to each ECALL function and symbolically explore
its code. Our symbolic execution tool currently supports de-
tecting two major classes of exploit primitives: control-ﬂow
hijacking and controlled writes. In addition, we detect if the
enclave dereferences a NULL-pointer.
Control-Flow Hijacking. To identify control-ﬂow hijacking
vulnerabilities, TEEREX searches for program paths, where
the enclave utilizes attacker-controlled data as a jump tar-
get. To be more precise, TEEREX detects and reports uncon-
strained jumps that are encountered during symbolic execu-
tion.
Anything that is attacker-controlled (i.e., input and the
whole address-space outside of enclave memory) is marked
as an unconstrained fully symbolic value during symbolic
execution. This means that when the ECALL uses one of
its symbolic arguments as a jump target, it will jump to an
unconstrained symbolic value. Furthermore, loading the jump
target from uninitialized memory also leads to loading an
unconstrained symbolic value. On the other hand, if the en-
clave validates the jump target pointer to be within a certain
set of allowed values, then the symbolic execution engine
will gather constraints on the symbol representing the jump
target during the analysis of the validation code. The jump
target is now tightly constrained to be within a certain set of
allowed—assumed to be safe—values, which will not trigger
an alarm. However, any use of an unconstrained pointer as a
jump target results in TEEREX reporting a controlled jump,
as here no prior validation was found and the attacker has full
control over the jump target.
Controlled Write. TEEREX searches for writes to arbitrary
(unconstrained) memory addresses during symbolic explo-
ration. Therefore, we track every pointer dereference and
propagate labels similar to taint analysis [17, 66]. This makes
it possible to infer the relation of a corrupting pointer to the
input arguments. This includes the levels of indirection and
corresponding offsets. When a pointer is utilized for a mem-
ory write, TEEREX checks whether the address is related to
attacker-controlled memory. If the address was loaded based
on input arguments, the attacker can directly control the ad-
dress used in the memory write instruction. Furthermore,
TEEREX uses the solver of the symbolic execution engine to
test whether the address of a write can possibly point to an
arbitrary memory location inside of the enclave memory. If
so, we can infer that we discovered an arbitrary write gadget.
Any write to an arbitrary address must be considered as
a vulnerability regardless of whether the value written is at-
tacker-controllable. For instance, a controlled write to an ar-
bitrary address with a ﬁxed single byte value (e.g. 0x0a) is
often sufﬁcient to corrupt a pointer in enclave memory. With
complete control of the address space in the SGX setting, the
attacker can map memory pages at almost any address. As
a result, it is sufﬁcient if the attacker can partially corrupt
a pointer in enclave memory and make it point to insecure
memory, which still is a valid memory location (see exploit
in Section 5.5 for an example). As such, TEEREX reports any
memory write to an attacker controlled address, regardless of
the value written.
NULL-Pointer Dereference. On the x86 architecture, the
page at address 0 (NULL) in the virtual address space of a user
space program is a legitimate address. However, in C/C++,
pointers are typically initialized to the null-pointer and many
functions from standard libraries return the null-pointer to
indicate an error. As such, dereferencing a null-pointer is a
common problem in C/C++ code but typically not considered
critical as the null page is not mapped, i.e. the process only
crashes when trying to dereference a null-pointer. On the
contrary, in the SGX setting a null-pointer dereference is crit-
ical since the null page is typically not within trusted enclave
memory. As such, we need to consider it as controlled by the
attacker. TEEREX analyzes every memory access and checks
whether the address is pointing to the zero page mapped at
address 0 (typically < 0x1000). If this is the case, TEEREX
reports that the code is dereferencing a null-pointer.
5 Enclave Analysis Results
To evaluate the effectiveness of TEEREX on real-world en-
claves, we gathered a dataset consisting of open-source and
proprietary public enclaves. Table 1 provides an overview of
all the enclaves we analyzed with TEEREX. Our dataset con-
tains enclaves developed by well-known companies such as
Intel and Baidu. We also included SGX-protected ﬁngerprint
software that is utilized in Dell and Lenovo laptops. Note that
it was highly challenging to ﬁnd projects utilizing the SGX
technology. We assume this is due to the fact that SGX is a
rather new technology, hardware-support on client machines
is still not widely available, and as such, SGX is primarily
used in cloud settings where the enclave is simply not publicly
available.
We use the following methodology for analyzing the en-
claves in our dataset: ﬁrst, we analyze the enclaves with
TEEREX. Second, using the vulnerability report of TEEREX,
we verify the vulnerabilities, perform root-cause analysis to
USENIX Association
29th USENIX Security Symposium    847
Project Name
Intel GMP Example [34]
Rust SGX SDK’s tlsclient [22, 67]
TaLoS [2, 24]
WolfSSL Example Enclave [68]
Synaptics SynaTEE Driver
Goodix Fingerprint Driver
SignalApp Contact Discovery [48]
Analyzed
Version
9533574f95b97
1.0.9
bb0b61925347b
d330c53baff52
5.2.3535.26
2.1.32.200
1.13
Exploit
Fixed Version(s)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
×
0491317b4112b
f975a19982740
not planned
1862c108d7e3b
approx. Q3 2020
approx. Q3 2020
-
Source
Code
(cid:88)
(cid:88)
(cid:88)
(cid:88)
×
×
(cid:88)
Target
Linux amd64
Linux amd64
Linux amd64
Linux amd64
Windows amd64
Windows amd64
Linux amd64
Table 1: Dataset of public enclaves and their susceptibility to exploitation.
* One ECALL immediately branches to 75 different actions.
Number of
ECALLs
6
8
207
22
56
7
2 (76)*
identify the vulnerability, and ﬁnally construct a proof-of-
concept (PoC) exploit. In our PoC exploits, we aim to hijack
the instruction pointer while the processor is in enclave mode.
Given this capability, an attacker can utilize existing code-
reuse attack techniques to achieve arbitrary code execution [7,
57]. By constructing such a PoC exploit, we gain conﬁdence
that the issues discovered by TEEREX are indeed serious
vulnerabilities.
For our PoCs we assume the standard SGX adversary
model [18, 50] in which the attacker has full control over
the user space and operating system/hypervisor. More speciﬁ-
cally, our current PoCs assume a standard OS (Ubuntu 18.04
and Windows 10), which are conﬁgured or patched to allow
the attacker to map the page at address 0. The enclaves are
all compiled with the standard Intel SGX SDK. Note that our
PoCs do not need to bypass ASLR since the untrusted OS se-
lects the address space layout of the enclave. Our PoC exploits
attempt to get full control over the instruction pointer, which
is typically sufﬁcient to perform arbitrary code execution [7].
Using TEEREX, we identiﬁed vulnerabilities in all of our
analyzed SGX enclaves except the SignalApp contact discov-
ery service [48]. In our analysis, we observed that the ECALL
interface of this enclave is comparatively small and simple.
For each of the vulnerable enclaves, we successfully devel-
oped PoC exploits of which all enable full instruction pointer
control. We performed responsible disclosure for all vulnera-
ble enclaves listed in Table 1. All vendors have acknowledged
our ﬁndings and all vendors, except for one, developed ﬁxes
for the vulnerabilities we reported.
We also performed root-cause analysis on our ﬁndings
and identiﬁed several problematic code patterns that lead to
vulnerabilities. Table 2 shows an overview of the results of our
analysis. We identiﬁed and successfully abused all different
types of exploit primitives that TEEREX detected. Based on
our root-cause analysis we identiﬁed bug classes speciﬁc to
SGX that easily lead to vulnerabilities in enclave code. In
what follows, we discuss in detail the vulnerable enclaves and
bug classes we identiﬁed.
void e_mpz_add(mpz_t *c_unsafe,
mpz_t *a_unsafe,
mpz_t *b_unsafe) {
mpz_t a, b, c;
/* [computation code omitted] */
// mpz_set copies the underlying buffer
// of the biginteger "c" to the buffer pointer
// contained in the "c_unsafe" variable
mpz_set(*c_unsafe, c);
}
Figure 4: Excerpt of the vulnerable code in the Intel GMP
Example enclave.
Intel GMP Example
5.1
Intel provides the GNU Multiple Precision Arithmetic Library
for SGX and a corresponding demo application. The enclave
code takes two GMP big integers as parameters, performs
an arithmetic computation, and returns the result. TEEREX
identiﬁed an arbitrary write vulnerability in the enclave code,
which we used in our PoC exploit to gain arbitrary code execu-
tion. The data structure behind the GMP big integer internally
utilizes a pointer to refer to an underlying buffer that contains
the variably-sized data of the big integer. TEEREX identiﬁed
that this pointer is not sanitized allowing a memory write to
an arbitrary location. This vulnerability shows how likely it
is for SGX developers utilizing a third-party library, to miss
validating a pointer inside of opaque data structures.
The problem behind the vulnerability is that the numbers
passed to the enclave are GMP big integer objects represent-
ing arbitrary large integers. The GMP big integer data struc-
tures utilize dynamically allocated storage internally; they
contain a pointer to the underlying buffer that stores the actual
integer value. However, the enclave fails to properly validate
the pointer inside of the GMP data structure. Figure 4 shows
part of the vulnerable code: the enclave receives three big
integer parameters. The ﬁrst one, called c_unsafe, is used
as an output parameter. The enclave uses functionality of the
GMP library that is not SGX-aware: the mpz_set function.
As such, the library function simply copies the output to the
attacker-controlled underlying buffer of the c_unsafe big in-
teger. This neglects the fact that the underlying buffer of this
848    29th USENIX Security Symposium
USENIX Association
e
s
s
a
l
C
g
u
B
s P1: Passing Data-Structures with Pointers
P2: Returning pointers to enclave memory
P3: Pointers to Overlapping Memory
P4: NULL-Pointer Dereferences
P5: Time-of-Check Time-of-Use
Control-Flow Hijack
Controlled Write
NULL-pointer Dereference
e
v
i
t
i
m
t
i
o
l
p
x
E
i
r
P
M
P
R
G
x a m
E