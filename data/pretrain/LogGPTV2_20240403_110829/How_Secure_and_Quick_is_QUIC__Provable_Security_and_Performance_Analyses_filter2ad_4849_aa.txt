title:How Secure and Quick is QUIC? Provable Security and Performance Analyses
author:Robert Lychev and
Samuel Jero and
Alexandra Boldyreva and
Cristina Nita-Rotaru
2015 IEEE Symposium on Security and Privacy
2015 IEEE Symposium on Security and Privacy
How Secure and Quick is QUIC?
Provable Security and Performance Analyses
Robert Lychev
MIT Lincoln Laboratory
PI:EMAIL
Samuel Jero
Purdue University
PI:EMAIL
Alexandra Boldyreva
Georgia Institute of Technology
PI:EMAIL
Cristina Nita-Rotaru
Purdue University
PI:EMAIL
Abstract—QUIC is a secure transport protocol developed
by Google and implemented in Chrome in 2013, currently
representing one of the most promising solutions to decreasing
latency while intending to provide security properties similar
with TLS. In this work we shed some light on QUIC’s
strengths and weaknesses in terms of its provable security
and performance guarantees in the presence of attackers. We
ﬁrst introduce a security model for analyzing performance-
driven protocols like QUIC and prove that QUIC satisﬁes
our deﬁnition under reasonable assumptions on the protocol’s
building blocks. However, we ﬁnd that QUIC does not satisfy
the traditional notion of forward secrecy that is provided by
some modes of TLS, e.g., TLS-DHE. Our analyses also reveal
that with simple bit-ﬂipping and replay attacks on some public
parameters exchanged during the handshake, an adversary
could easily prevent QUIC from achieving minimal latency
advantages either by having it fall back to TCP or by causing
the client and server to have an inconsistent view of their
handshake leading to a failure to complete the connection.
We have implemented these attacks and demonstrated that
they are practical. Our results suggest that QUIC’s security
weaknesses are introduced by the very mechanisms used to
reduce latency, which highlights the seemingly inherent trade
off between minimizing latency and providing ‘good’ security
guarantees.
I. INTRODUCTION
The proliferation of mobile and web applications and their
performance requirements have exposed the limitations of
current transport protocols. Speciﬁcally, protocols like TLS
[1] have a relatively high connection establishment latency
overhead, causing user unhappiness and often resulting in
a decreased number of customers and ﬁnancial losses. As
a result, several efforts [2], [3], [4], [5] have gone into
designing new transport protocols that have low latency as
one of the major design goals, in addition to basic security
goals such as conﬁdentiality, authentication, and integrity.
One of the most promising protocols is QUIC [2], a secure
transport protocol developed by Google and implemented in
Chrome in 2013 [6]. QUIC integrates ideas from TCP, TLS,
and DTLS [7] in order to provide security functionality com-
parable to TLS, congestion control comparable with TCP,
as well as minimal round-trip costs during setup/resumption
Robert Lychev did most of his work on this paper while at Georgia
Institute of Technology.
and in response to packet loss. Some of the major design
differences from TLS are not relying on TCP in order to
eliminate redundant communication and the use of initial
keys to achieve faster connection establishment. However,
the exact security and performance advantages and disad-
vantages of QUIC are not clear when compared to existing
protocols such as TLS and DTLS. Shedding light on this
problem is the main focus of our work.
The way to assess and compare security is by providing a
provable security analysis. However, while the importance of
provable security analysis for practical protocols is gaining
wider acceptance, it is still common for a protocol to be
deployed ﬁrst and analyzed later. For example, the complete
provable security results for TLS remained elusive for many
years and have only recently been identiﬁed [8], [9], [10].
Not surprisingly, no formal guarantees of the provided
services existed for QUIC, with the exception of informal
arguments in its design speciﬁcations, before the recent
(concurrent) work by Fischlin and G¨unter [11] and our work.
Even though [11] assesses QUIC’s security, its results do
not overlap with ours and its analysis is limited to the key
exchanges rather than the entire protocol. We provide a
detailed comparison of these works in Section II.
Furthermore, even if certain security properties about a
protocol may be proven to hold, its usefulness in real-life
deployments can be undermined by attacks that prevent con-
nections from being established in the ﬁrst place, especially
in ways that are more subtle than just dropping trafﬁc, e.g.
TCP reset attacks against TLS. Such types of attacks have
gained notoriety since it became known that they have been
used for censorship by some governments to deter users from
viewing certain content on the Internet [12].
As QUIC has been deployed widely among Google
servers, and may eventually be deployed outside of Google,
it is critical to provide its provable security analysis and
to understand its performance guarantees in the presence
of attackers before it becomes more widely used. Under-
standing its performance guarantees is particularly important
considering that QUIC is envisioned mainly for web content
delivery and mobile applications.
OUR CONTRIBUTIONS. We provide the provable-security
analysis of QUIC and assess its performance guarantees in
© 2015, Robert Lychev. Under license to IEEE.
© 2015, Robert Lychev. Under license to IEEE.
DOI 10.1109/SP.2015.21
DOI 10.1109/SP.2015.21
214
214
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:06:38 UTC from IEEE Xplore.  Restrictions apply. 
the presence of attackers. Our study is suitable for a general
class of performance-driven communication protocols that
employ an initial session key to enable data exchange even
before the ﬁnal session key is set. We call such protocols
Quick Communications (QC) protocols. While QUIC is our
main focus, the recently announced version 1.3 of TLS [13]
also ﬁts the QC framework.
One of our major contributions is the security model for
QC protocols. We designed a new model since the existing
security deﬁnitions were unsuitable. The Authenticated and
Conﬁdential Channel Establishment (ACCE) model [8], [9]
which was used in proving TLS did not ﬁt QUIC for several
reasons. First, TLS and its security model use one session
key, while QUIC uses two, and the data may start being
encrypted before the ﬁnal session key is set. Therefore,
the model has to deal with key and data exchange under
multiple keys. Second, QUIC does not run on top of TCP
and implements many of the features provided by TCP itself.
This is done primarily for performance reasons, but QUIC
also adds some cryptographic protection, such as protection
against IP spooﬁng and packet re-ordering. Hence, it makes
sense to model additional attacks such as IP spooﬁng or
packet re-ordering. Also, we cannot analyze the key and data
exchange phases separately using the established security
deﬁnitions and then compose them to get a composition
result implying the security of the whole protocol, because in
QUIC these phases use common parameters (such as IV) and
can overlap (data can be exchanged while the ﬁnal session
key is being set).
Our security deﬁnition is an extension of the ACCE
deﬁnition to ﬁt QC protocols. We call our model QACCE
for Quick ACCE. We consider a very powerful attacker who
knows all servers’ public keys, can initiate and observe the
communications between honest parties, and can intercept,
drop, misorder, or modify the contents of the exchanged
packets. We also consider DoS attacks such as IP spooﬁng.
The adversary can adaptively corrupt servers and learn their
(long-term) secret keys and secret states. It can also, again
adaptively, learn parties’ initial and ﬁnal session keys. The
adversary can also have partial knowledge of the data being
exchanged by the parties. Given such strong adversarial
capabilities, the attacker should not be able to prevent the
parties from establishing session keys (without the parties
noticing that something went wrong) and using these keys
to achieve data exchange with privacy and integrity. We note
that the sender authentication can only be achieved one-way,
as only servers hold public keys.
Our security model formally captures the different levels
of security guaranteed for data encrypted under the initial
and ﬁnal session keys.1 While the attacker can cause honest
parties to agree on distinct initial keys (something which is
not possible in TLS), we still require that data exchanged
1The security goals were not formally stated in QUIC’s documentation.
under either key is protected. For the ﬁnal session keys,
the security requirement is similar to that for session keys
in TLS: if one party sets the key, it is guaranteed that the
other party sets the same key, and moreover, that the key
is “good enough” to securely exchange data. Finally, we
also consider forward secrecy. Unlike TLS-RSA, currently
the most commonly deployed mode of TLS, QUIC provides
certain forward secrecy guarantees such that corrupting a
server during one time period does not let the attacker break
the security of the data sent in previous time periods. On
the other hand, because the initial keys, used for initial
data exchange, are derived using parameters that change
only once per time period, QUIC does not provide forward
secrecy guarantees against attackers that may corrupt the
server after, but in the same time period as, the data that
was sent. Thus, QUIC’s overall forward secrecy guarantees
are not as strong as those of TLS-DHE, a TLS mode
that has recently gained popularity. However, in practice,
TLS SessionTickets [14] are often used to minimize round
trips. Their use in some sense cancels the forward secrecy
guarantees provided by TLS because the SessionTicket key,
which must be retained for sufﬁciently long periods of
time for resumption to be effective, can be used to decrypt
previous communication. In addition to the formal model,
we provide extensive explanations and discussions to help
practitioners understand the security level we target.
We then analyze the security of the cryptographic core of
QUIC, which we extracted from [2], [6], [15]. We prove that
QUIC satisﬁes our security model assuming strong unforge-
ability of the underlying signature scheme, security of the
underlying symmetric authenticated encryption scheme with
associated data, and the strong Difﬁe-Hellman assumption,
in the random oracle model. Due to lack of space we provide
the proof in the full version of this paper [16].
We also analyze QUIC’s latency goals in the presence of
attackers. We show that the very mechanisms used in QUIC
to minimize latency, such as unprotected ﬁelds on handshake
packets and the use of publicly available information on
both client and server sides, can be exploited by an adver-
sary during the handshake to introduce extra latencies and
possibly lead to DoS attacks. We implemented ﬁve attacks
against QUIC. Four of these attacks prevent a client from
establishing a connection with a server while the ﬁfth is a
DoS attack against QUIC servers. In all cases, we found the
attacks easy to implement and completely effective. In many
cases, the client is forced to wait for QUIC’s ten-second
connection establishment timeout before giving up.
Our results suggest that the techniques that QUIC uses
to minimize latency may not be useful in the presence
of malicious parties. Although these weaknesses are not
completely unexpected, they are of signiﬁcant concern to
the QUIC team at Google who have been developing a
dedicated monitoring infrastructure to try to address them
[17]. However, we have found that there may be fundamental
215215
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:06:38 UTC from IEEE Xplore.  Restrictions apply. 
limitations to effectively mitigating these weaknesses.
We note that similar types of attacks have been used
against TLS and TCP (recall that TLS runs on top of TCP).
However, TLS and TCP made no general promises about
their performance in the presence of adversaries. We ﬁnd
that even if QUIC’s performance may not be perfect, it is
not worse than that of TLS in the worst case, and is much
better in the absence of adversaries.
To summarize, our contributions are:
• A security model for QC protocols that formally cap-
tures the different levels of security guaranteed for data
encrypted under the initial and ﬁnal session keys in the
presence of a very strong adversary, Section VI;
• A provable-security analysis for QUIC under the con-
sidered security model, Section VII;
• A quantitative analysis of the performance properties
of QUIC under adversarial settings, Section VIII;
• A practicality demonstration of attacks, Section IX.
Our study has shed some light on QUIC’s security guar-
antees and weaknesses that would be useful for practitioners
and protocol developers. On a high level, our provable
security analysis study conﬁrms the soundness of QUIC’s
security protection design. And by doing so, our study
details the exact level of security the protocol provides, e.g.,
for data encrypted under the initial and ﬁnal session keys;
something which the protocol description did not specify in
sufﬁcient detail. Our performance analysis results conﬁrm
yet again that there is no free lunch: either practitioners
have to put up with the extra latencies inherent in setting
up TLS connections with TCP, or they have to ﬁgure out
how to deal with the additional security risks introduced by
the very mechanisms used to reduce those latencies. Similar
tradeoffs were observed with respect
to a performance-
driven key exchange protocol proposed in [18]. Although
in principle QUIC outperforms TLS in terms of latency
when there are no attackers, there seems to be a fundamental
tradeoff between minimizing latency and providing ‘good’
security guarantees that practitioners should keep in mind
when considering whether to deploy and/or work to improve
QUIC or other performance-driven protocols such as TLS
1.3 and TLS with SessionTicket resumption.
FUTURE DIRECTIONS. It would be interesting to see if
analyses permitting machine-checked or even automatically-
generated proofs using systems like Coq, CryptoVerif [19],
EasyCrypt [20] or a type system by Fournet et al. [21] used
in TLS analyses [22], [23] could be applied to performance-
oriented protocols such as QUIC or TLS 1.3.
II. CONCURRENT AND INDEPENDENT WORK
In (concurrent) work, Fischlin and G¨unter [11] analyze
the key exchange of QUIC. They show that QUIC’s (multi-
stage) key exchange satisﬁes a reasonable notion of security.
However, this notion does not “compose” with the notions
for data exchange, meaning that even if one uses a secure
the
authenticated encryption scheme for data exchange,
security of the QUIC protocol as a whole is not guaranteed.
For such a desirable composition to hold, QUIC has to be
slightly modiﬁed. Traditionally, it has proved very hard to
convince practitioners to change implementations unless a
serious attack has been deployed. While we believe Google
may be more agreeable to tweak the protocol to make it
suitable for modular analysis, until that happens, the security
of QUIC as a whole is not known.
Furthermore, the change proposed in [11] will not sufﬁce
because the way authenticated encryption is used in QUIC
prevents its security from generically composing with secure
key exchange. Speciﬁcally, part of the nonce IV used for
encryption is not picked at random independently from
everything else but is derived in the same way as the party’s
secret keys, ﬁxed, and not given to the adversary. To enable
a result about the composed security, Google would need
to modify its use of encryption. Although we fully support
complex protocol design that allows for modular security
treatment, we also realize that it is often done differently in
practice. So far, our analysis is the only one suitable for the
unmodiﬁed QUIC.
Another limitation of the analysis in [11] is that it does not
address packet-level attacks and IP spooﬁng. The security
model of [11] also does not consider time periods and
refreshments of the server conﬁguration. The latter is treated
as the long term secret of the server, and the communication
of the public portion of it to the client is not considered;
i.e., they do not consider 1-RTT connections. Hence, while
[11] gives a good insight
in the design of multi-stage
protocols in a way supporting modular security analyses, our
work captures more accurately the current implementation
of QUIC and the corresponding practical threats.
III. PRELIMINARIES
NOTATION AND CONVENTIONS. We denote by {0, 1}∗ the
set of all binary strings of ﬁnite length. If x, y are strings
then (x, y) denotes the concatenation of x and y from which
x and y are uniquely decodable. If κ ∈ N then 1κ denotes the
string consisting of κ consecutive “1” bits. If S is a ﬁnite set,
$← S denotes that s is selected uniformly at random
then s
from S. All algorithms are assumed to be randomized and
efﬁcient (i.e. polynomial in the size of the input). For any
n ∈ N, [n] denotes the set of integers {1, . . . , n}.
PKI. Whenever we use public keys, we also (implicitly)
assume that a public key infrastructure (PKI) is supported,
i.e. the public keys are valid, bound to users’ identities, and
publicly known. Thus, we omit certiﬁcates and certiﬁcate
checking of public keys in our analysis.
BASE PRIMITIVES AND ASSUMPTIONS.
Digital Signature Scheme. A digital signature scheme is
used in QUIC by servers to authenticate certain data, so we
deﬁne the primitive and its security here.
216216
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:06:38 UTC from IEEE Xplore.  Restrictions apply. 
A digital signature scheme SS = (Kg, Sign, Ver) with
associated message space MsgSp is deﬁned by three algo-