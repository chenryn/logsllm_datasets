31
31
32
33
36
42
43
1
Introduction
Secure Multi-Party Computation (MPC) [GMW87, CDG87, Yao82], the standard bearer problem of cryptography,
has evolved tremendously over recent years. It studies the problem of enabling a set of n parties to perform joint
computation on their private inputs, in a way that no coalition of t parties can learn more information than the
output (privacy) or affect the true output of the computation (correctness). While the vast literature in MPC has
traditionally been focused on theoretical aspects, lately, with increasing demand for efﬁcient constructions suitable
in real-time applications, there has been a growing interest to improve the concrete efﬁciency of protocols.
The domain of MPC can be broadly classiﬁed into honest majority [BGW88, RB89, BMR90, Bea91, DN07,
BFO12, BH07, BH08] and dishonest majority [GMW87, DO10, BDOZ11, DPSZ12, AJL+12, GGHR14, LPSY15]
settings. The special case of two-party (2PC) in dishonest majority setting has enjoyed overwhelming focus over
the years in terms of improving its efﬁciency [LP07, LP12, Lin13, AMPR14, NO16]. In contrast, the special cases
of honest majority setting have not been in the limelight until recently when practically efﬁcient MPC constructions
of [CGMV17, MRZ15, AFL+16, FLNW17] leveraged presence of small number of parties.
The area of MPC with small number of parties in the honest majority setting has drawn popularity partic-
ularly due to simplicity and efﬁciency of the resulting protocols. The area is worthwhile to explore due to the
following reasons. First, most real-time applications involve small number of parties. For instance, applications
such as statistical data analysis [BTW12], email-ﬁltering [LADM14], ﬁnancial data analysis [BTW12], distributed
credential encryption [MRZ15], Danish sugar beet auction [BCD+09] involve 3 parties. Additionally, the MPC
frameworks such as VIFF [Gei07], Sharemind [BLW08] have been explored with 3 parties. The recent advances
that involve MPC in privacy-preserving machine learning have exhibited applications that involve small number
of parties [MRSV17]. Second, for the instance of large-scale computation on data involving sensitive information,
it is preferable to utilize 3 or 4 servers in comparison to only two for improved fault-tolerance and performance.
Another crucial advantage over the 2-party setting is enabling stronger security goals such as fairness (corrupted
parties receive their output only if all honest parties receive output) and guaranteed output delivery (corrupted
parties cannot prevent honest parties from receiving their output) which are attainable only in the honest major-
ity setting [Cle86]. These goals are desirable in practical applications as they serve as a stimulant for parties
to be engaged in the computation. Also, having honest majority is advantageous to obtain constructions rely-
ing on weaker cryptographic assumptions and light-weight cryptographic tools. For example, the protocols of
[IKKP15, MRZ15] are built using symmetric-key primitives whereas 2PC protocols require Oblivious Transfer
(OT) [Yao82, LP07, IPS08].
In this work, we consider the honest-majority setting for small number of parties (n = 3 and n = 4) tolerating
at most one malicious corruption (t = 1). Next, we outline the relevant literature related to MPC with small
number of parties beyond the two-party case.
1.1 Related Work
The regime of MPC over small population has seen growth both in the domain of low-latency and high-throughput
protocols. Relying on garbled circuits, the unique selling point of the former is constant rounds and these serve
better in high-latency networks such as the Internet. Whereas, the added edge of the latter category is low com-
munication overhead (band-width) and simple computations. Building on secret sharing, this category however
takes number of rounds proportional to the depth of the circuit representing the function to be computed. These
primarily cater to low-latency networks.
In the domain of constant-round protocols which is the focus of this paper, [MRZ15] presents a 3-round efﬁ-
cient 3-party (3PC) protocol tolerating at most one malicious corruption and involving transmission and evaluation
of a single garbled circuit. Concurrently, in the 3-party setting, [IKKP15] achieves a 2-round protocol whose cost
is essentially that of 3 garbled circuits. However, both these protocols achieve a weaker notion of security i.e
security with selective abort (corrupt party can selectively deprive some of the honest parties of the output). In the
presence of a broadcast channel, the 3PC of [MRZ15] can additionally achieve unanimous abort (where either all
or none of the honest parties output abort), albeit for speciﬁc class of functions that give same output to all. The
3
work of [IKKP15] presents a 2-round 4-party (4PC) protocol tolerating single corruption that achieves guaranteed
output delivery in the absence of broadcast channel. Since the focus of [IKKP15] is on minimizing the number of
rounds of interaction, the protocol comprises of several parallel instances of private simultaneous message (PSMs)
which when instantiated with garbled circuit (GC) would sum upto communication of 12 GCs. The recent work
of [PR18] explores the exact round complexity of 3PC protocols under various security notions including fairness
and guaranteed output delivery. While the protocols are round-optimal, they involve a minimum of 3 GCs. The
work of [CGMV17] explores the case of 5-party with two malicious corruptions and relies on distributed garbling
approach of [BLO16] (which is more expensive than Yao’s garbling). Recent paper of [BO17], improving on the
distributed garbling techniques of [BLO16], proposes an honest majority protocol with n > 3t and shows practical
implementation for 31 parties. The results mentioned above are designed in the honest majority. [CKMZ14] stud-
ies 3PC in dishonest majority setting. In summary, the most relevant work that is close to our work efﬁciency-wise
is that of [MRZ15] which we compare with.
There have been a ﬂurry of works in the high-throughput domain recently [AFL+16, FLNW17, ABF+16,
ABF+17]. In 3-party setting, [AFL+16] and [FLNW17, GRW18] presents semi-honest and maliciously secure
protocols respectively that are extremely fast on standard hardware. [ABF+17] signiﬁcantly improves over the
protocol of [FLNW17], achieving the computation rate of 1.15 billion AND gates/second. In the 4 party setting,
the work of [GRW18] provides a construction that is secure against one malicious corruption based on the dual
execution approach. They incur communication of 1.5 bits per party per gate for boolean circuits and thus offer a
performance that is 4.5 times better than that of [ABF+17]. [GRW18] also includes protocol variants for achieving
fairness and robustness.
1.2 Our Contribution
In this paper, we present efﬁcient constant-round constructions of 3PC and 4PC achieving strong security notions
of fairness and guaranteed output delivery that tolerate one active corruption. Our constructions, all based on
symmetric-key primitives are built from GC. We outline our results below. For empirical purpose, the circuits of
AES-128, SHA-256 and MD5 are used as benchmarks.
3PC with fairness
In the minimal network setting of pairwise-private channels, our 3PC protocol with fairness
consumes four rounds and involves transmission and evaluation of a single GC. Our protocol shows a minimal
overhead of 0.06–0.16 ms, 0.03–0.8 ms, 0.21–0.5 s and 5.63–10.74 KB over the 3PC of [MRZ15], in terms of
the average computation time, LAN runtime, WAN runtime and communication, where average is taken over the
number of parties and the range is taken over the choice of benchmark circuits. The nominal overhead to trade
fairness over abort security makes our construction a better choice for practical purposes. This protocol has a
natural extension to more than 3 parties (still for one corruption) with neither inﬂating the round complexity nor
the number of GCs.
On the technical side, constructing on the ideas of [MRZ15, IKKP15], our protocol has two parties enacting
the role of the garblers and the remaining party acting as an evaluator for a GC. Contrary to [MRZ15, IKKP15], we
use a different kind of garbling scheme, namely an oblivious one that hides the circuit output when the decoding
information is withheld, in order to enforce fairness. Speciﬁcally, an evaluator gets the decoding information only
when it shares the result of the GC evaluation to its garblers. Crucial to enforce unanimity across the honest parties,
we introduce a clever ‘proof mechanism’ that allows a garbler to convince its co-garbler about the correctness of
the ﬁnal output. When the evaluator is corrupt and aids only one of its garblers to obtain the output, the technique
allows both the honest parties to conclude the same output.
4PC with guaranteed output delivery In the 4-party setting, we present an efﬁcient protocol that achieves
guaranteed output delivery in ﬁve rounds, assuming just pairwise-private channels. Our protocol involves commu-
nication of a single GC compared to the 2-round protocol of [IKKP15] that incurs a cost of 12 GCs. Our protocol
has asymmetric roles for each party involved and as a result, interestingly, our protocol gives better performance
compared to the 3PC of [MRZ15]. The protocol terminates in three rounds when no malicious behaviour takes
4
place and has minimal communication (and negligible computation) done in last two rounds. We take reading
for both 3-round run and 5-round run of the protocol. For the former, our protocol shows a gain of 0.19–2.61 ms,
0.17–2.45 ms and respectively 18.63–500.56 KB compared to the 3PC of [MRZ15] in terms of average computation
time, LAN runtime and communication. The overhead for WAN runtime is minimal and amounts to 0.02–0.31 s.
When the protocol is stretched to 5 rounds, the gains reported above remain unaffected (or witness negligible de-
crease). In terms of average WAN runtime, the overhead increases to 0.51 – 0.83 s, reﬂecting the increase in round
complexity. At the expense of one extra GC, we also present a 4-round 4PC primarily as a theoretical contribution,
which also terminates in three rounds when no malicious behaviour takes place.
On the technical side, deviating from the usual approach of appointing (n − 1) garblers and one evaluator in
the GC-based protocols of n parties [IKKP15, MRZ15, CGMV17], we explore the setting of two garblers and
one evaluator in our 5-round 4PC. The fourth party participates only to share its input among the rest. At the
heart of this protocol, lie a few neat tricks. We overlap the input commitment phase with evaluation of GC, yet
ensure computation on committed input alone by a convenient and clever use of oblivious garbling scheme. It
further banks on a technique of identifying a trusted (honest) party amongst the participants and then enabling her
to evaluate the function on clear. Speciﬁcally, the protocol looks for potential misbehaviour, identiﬁes conﬂict and
assigns the left-out third party the role of trusted-third party (TTP). The TTP, on receiving the view of any other
party, takes charge of computing the function on direct inputs and forwarding the output to all. To bring down the
round complexity to four, we present a protocol that explores the setting of two garblers and two evaluators and
leverages the guarantee of having at least one honest evaluator.
3PC with guaranteed output delivery With an additional broadcast channel, we present a 5-round 3PC proto-
cols with guaranteed output delivery at the cost of communication of a single GC. A broadcast channel is inevitable
in this regime owing to the results of [CHOR16]. We ensure that the broadcast communication is nominal and most
importantly, independent of the circuit size. Our implementation, using a physical UDP broadcast channel available
on LAN, shows that the average computation time, LAN runtime and communication overhead are 0.16–0.3 ms,
1.52–3 ms and 0.19–0.46 KB respectively over that of [MRZ15]. For the worst case run when the execution is
stretched to 5 rounds, there is negligible change in the computation and LAN runtime, but communication over-
head is witnessed to increase to a value between 0.21–0.57 KB. We do not implement the protocol in WAN as it
would require an implementation of a robust broadcast protocol. When the adversary remains semi-honest, this
protocol too terminates in 3 rounds and the extra communication and computation needed in the last two rounds is
almost nothing.
On the technical side, our construction embarks on similar idea as that of our fair 3PC protocol, except that
a garbling scheme without obliviousness works for us. Similar to our 4PC, this protocol also leverages a clever
(yet, different from the one used in 4PC) way of identifying a TTP in the face of misbehaviour and evaluating the
function on clear.
Theoretical and Empirical Comparison Our protocols put in the context of the relevant state-of-the-art proto-
cols in terms of number of GCs, rounds and security are given below. ‘god’ implies guaranteed output delivery.
Ref.
[MRZ15]
This paper
This paper
[IKKP15]
This paper
This paper
# Parties
3
3
3
4
4
4
# GCs Rounds
1
1
1
12
2
1
3
4
5
2
4
5
Broadcast
Security
selective abort 
fairness

 [CHOR16]
god
god

god

god

While elaborate experimental results appear later in the paper, we summarize the overhead or gain (indicated by
g) of our protocols compared to the 3PC of [MRZ15] in terms of average computation time, LAN runtime, WAN
5
runtime and communication cost, where the average is taken over the number of parties and the range is taken over
the choice of circuits. We show in bracket the increase in the overhead or decrease in the gain for the worst case
5-round run of our 3PC and 4PC with guaranteed output delivery. With respect to our 4-round 4PC with guaranteed
output delivery, in the worst case run, we save one round at the expense of one garbled circuit over our 5-round
4PC which amounts to a value in the range 72 KB − 1530 KB for the benchmark circuits.
Ref.
fair 3PC
4PC with god
3PC with god
Computation
( ms)
0.06 – 0.16
0.19 – 2.61 (g)
0.16 – 0.3
LAN
( ms)
0.03 – 0.8
0.17 – 2.45 (g)
1.52 – 3
WAN
( s)
0.21 – 0.5
0.02 (+.49) – 0.31 (+.52)
-
Communication
( KB)
5.63 – 10.74
18.63 (−.01) – 500.56 (−.1) (g)
0.19 (+.02) – 0.46 (+.11)
Roadmap: Our needed primitives appear in Section 2. Our efﬁcient 3PC protocols achieving fairness and guaran-
teed output delivery are presented in Section 3 and 6 respectively. The 4PC protocol with rounds 5 and 4 appear in
Section 4 and 5 respectively. The experimental results are presented in Section 7. The security model and proofs
of the four protocols appear in Appendices A, C, F, D and E.
2 Preliminaries
2.1 Model and Notations
We consider a set P of at most four parties, denoted by P1, P2, P3, P4. We assume that any two parties are
connected by pair-wise secure and authentic channels. We assume the existence of a broadcast channel only for
the 3PC protocol achieving guaranteed output delivery. Each party can be considered as a Probabilistic Polynomial
time Turing (PPT) machine. Our model assumes a PPT adversary A, who can statically and maliciously corrupt
at most one party out of the 3 or 4 parties. For any subset X of P, ind(X ) refers to the indexes of the parties. For
example, when X = {P1, P2}, then ind(X ) = {1, 2}.
We denote the computational security parameter by κ. A negligible function in κ is denoted by negl(κ). A
function negl(·) is negligible if for every polynomial p(·) there exists a value N such that for all m > N it
p(m). We denote by [x], the set of elements {1, . . . , x} and by [x, y], the set of elements
holds that negl(m)  x. For any x ∈R {0, 1}m, xi denotes the ith bit of x, i ∈ [m]. We use
||i∈[n]xi to denote concatenation of strings xi. Let S be an inﬁnite set and X = {Xs}s∈S, Y = {Ys}s∈S be the