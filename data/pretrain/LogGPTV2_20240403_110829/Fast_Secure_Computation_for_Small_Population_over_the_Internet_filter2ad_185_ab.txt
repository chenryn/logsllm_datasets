### Introduction

Secure Multi-Party Computation (MPC) [GMW87, CDG87, Yao82] is a fundamental problem in cryptography that has seen significant advancements in recent years. MPC enables a set of \( n \) parties to jointly compute a function on their private inputs in such a way that no coalition of up to \( t \) parties can learn more information than the output (privacy) or alter the true output of the computation (correctness). While the literature on MPC has traditionally focused on theoretical aspects, there has been a growing interest in improving the practical efficiency of MPC protocols for real-time applications.

MPC can be broadly classified into two settings: honest majority [BGW88, RB89, BMR90, Bea91, DN07, BFO12, BH07, BH08] and dishonest majority [GMW87, DO10, BDOZ11, DPSZ12, AJL+12, GGHR14, LPSY15]. The two-party case (2PC) in the dishonest majority setting has received considerable attention in terms of efficiency improvements [LP07, LP12, Lin13, AMPR14, NO16]. In contrast, the honest majority setting with a small number of parties has only recently gained prominence, thanks to practically efficient constructions [CGMV17, MRZ15, AFL+16, FLNW17].

The area of MPC with a small number of parties in the honest majority setting is particularly appealing due to the simplicity and efficiency of the resulting protocols. This is motivated by several factors. First, many real-time applications involve a small number of parties. For example, statistical data analysis [BTW12], email filtering [LADM14], financial data analysis [BTW12], distributed credential encryption [MRZ15], and the Danish sugar beet auction [BCD+09] all involve three parties. Additionally, MPC frameworks like VIFF [Gei07] and Sharemind [BLW08] have been explored with three parties. Recent advances in privacy-preserving machine learning also highlight the use of a small number of parties [MRSV17]. Second, for large-scale computations involving sensitive data, using three or four servers instead of just two provides better fault tolerance and performance. Moreover, the honest majority setting allows for stronger security goals such as fairness (corrupted parties receive their output only if all honest parties do) and guaranteed output delivery (corrupted parties cannot prevent honest parties from receiving their output), which are not achievable in the 2PC setting [Cle86]. These goals are desirable in practical applications as they encourage participation. Additionally, honest majority protocols can rely on weaker cryptographic assumptions and lightweight tools. For instance, the protocols in [IKKP15, MRZ15] use symmetric-key primitives, whereas 2PC protocols require Oblivious Transfer (OT) [Yao82, LP07, IPS08].

In this work, we focus on the honest-majority setting for a small number of parties (\( n = 3 \) and \( n = 4 \)) tolerating at most one malicious corruption (\( t = 1 \)). We will outline the relevant literature related to MPC with a small number of parties beyond the two-party case.

### 1.1 Related Work

The field of MPC over small populations has seen growth in both low-latency and high-throughput protocols. Low-latency protocols, often based on garbled circuits, offer constant rounds and are suitable for high-latency networks like the Internet. High-throughput protocols, built on secret sharing, have lower communication overhead and simpler computations but require a number of rounds proportional to the depth of the circuit.

In the domain of constant-round protocols, [MRZ15] presents an efficient 3-party (3PC) protocol with three rounds, tolerating at most one malicious corruption and involving the transmission and evaluation of a single garbled circuit. Concurrently, [IKKP15] achieves a 2-round 3PC protocol whose cost is equivalent to three garbled circuits. However, both these protocols achieve a weaker notion of security, i.e., security with selective abort (where a corrupt party can selectively deprive some honest parties of the output). In the presence of a broadcast channel, the 3PC protocol in [MRZ15] can achieve unanimous abort (where either all or none of the honest parties output abort) for specific functions. [IKKP15] also presents a 2-round 4-party (4PC) protocol tolerating a single corruption that achieves guaranteed output delivery without a broadcast channel. Since [IKKP15] focuses on minimizing the number of rounds, the protocol involves several parallel instances of Private Simultaneous Messages (PSMs) instantiated with garbled circuits, resulting in the communication of 12 GCs. The recent work in [PR18] explores the exact round complexity of 3PC protocols under various security notions, including fairness and guaranteed output delivery. While these protocols are round-optimal, they involve a minimum of three GCs. [CGMV17] explores the 5-party case with two malicious corruptions using a distributed garbling approach [BLO16], which is more expensive than Yao's garbling. [BO17] improves on the distributed garbling techniques of [BLO16] and proposes an honest-majority protocol for \( n > 3t \) with practical implementation for 31 parties. [CKMZ14] studies 3PC in the dishonest-majority setting. In summary, the most relevant work in terms of efficiency is [MRZ15], which we compare with.

Recent works in the high-throughput domain include [AFL+16, FLNW17, ABF+16, ABF+17]. In the 3-party setting, [AFL+16] and [FLNW17, GRW18] present semi-honest and maliciously secure protocols, respectively, that are extremely fast on standard hardware. [ABF+17] significantly improves over [FLNW17], achieving a computation rate of 1.15 billion AND gates/second. In the 4-party setting, [GRW18] provides a construction secure against one malicious corruption based on the dual execution approach, incurring communication of 1.5 bits per party per gate for boolean circuits, offering performance 4.5 times better than [ABF+17]. [GRW18] also includes protocol variants for achieving fairness and robustness.

### 1.2 Our Contribution

In this paper, we present efficient constant-round constructions of 3PC and 4PC achieving strong security notions of fairness and guaranteed output delivery, tolerating one active corruption. Our constructions, all based on symmetric-key primitives, are built from garbled circuits. We outline our results below, using AES-128, SHA-256, and MD5 circuits as benchmarks.

#### 3PC with Fairness

In the minimal network setting of pairwise-private channels, our 3PC protocol with fairness consumes four rounds and involves the transmission and evaluation of a single GC. Our protocol shows a minimal overhead of 0.06–0.16 ms, 0.03–0.8 ms, 0.21–0.5 s, and 5.63–10.74 KB over the 3PC of [MRZ15] in terms of average computation time, LAN runtime, WAN runtime, and communication. The nominal overhead to trade fairness over abort security makes our construction a better choice for practical purposes. This protocol naturally extends to more than three parties (still for one corruption) without inflating the round complexity or the number of GCs.

On the technical side, building on the ideas of [MRZ15, IKKP15], our protocol has two parties acting as garblers and the remaining party as an evaluator for a GC. Unlike [MRZ15, IKKP15], we use an oblivious garbling scheme that hides the circuit output when the decoding information is withheld, enforcing fairness. Specifically, an evaluator gets the decoding information only when it shares the result of the GC evaluation with its garblers. To enforce unanimity among the honest parties, we introduce a clever "proof mechanism" that allows a garbler to convince its co-garbler about the correctness of the final output. When the evaluator is corrupt and aids only one of its garblers to obtain the output, the technique ensures both honest parties conclude the same output.

#### 4PC with Guaranteed Output Delivery

In the 4-party setting, we present an efficient protocol that achieves guaranteed output delivery in five rounds, assuming only pairwise-private channels. Our protocol involves the communication of a single GC compared to the 2-round protocol of [IKKP15], which incurs a cost of 12 GCs. Our protocol has asymmetric roles for each party, resulting in better performance compared to the 3PC of [MRZ15]. The protocol terminates in three rounds when no malicious behavior occurs, with minimal communication (and negligible computation) in the last two rounds. We take readings for both the 3-round and 5-round runs of the protocol. For the former, our protocol shows a gain of 0.19–2.61 ms, 0.17–2.45 ms, and 18.63–500.56 KB compared to the 3PC of [MRZ15] in terms of average computation time, LAN runtime, and communication. The overhead for WAN runtime is minimal, amounting to 0.02–0.31 s. When the protocol is stretched to five rounds, the gains remain largely unaffected (or show a negligible decrease). In terms of average WAN runtime, the overhead increases to 0.51–0.83 s, reflecting the increase in round complexity. At the expense of one extra GC, we also present a 4-round 4PC primarily as a theoretical contribution, which also terminates in three rounds when no malicious behavior occurs.

On the technical side, deviating from the usual approach of appointing \( n-1 \) garblers and one evaluator in GC-based protocols of \( n \) parties [IKKP15, MRZ15, CGMV17], we explore the setting of two garblers and one evaluator in our 5-round 4PC. The fourth party participates only to share its input among the rest. At the heart of this protocol are a few neat tricks. We overlap the input commitment phase with the evaluation of the GC, yet ensure computation on committed input alone by a convenient and clever use of the oblivious garbling scheme. It further relies on a technique of identifying a trusted (honest) party among the participants and then enabling her to evaluate the function on clear. Specifically, the protocol looks for potential misbehavior, identifies conflicts, and assigns the left-out third party the role of a trusted third party (TTP). The TTP, upon receiving the view of any other party, takes charge of computing the function on direct inputs and forwarding the output to all. To reduce the round complexity to four, we present a protocol that explores the setting of two garblers and two evaluators, leveraging the guarantee of having at least one honest evaluator.

#### 3PC with Guaranteed Output Delivery

With an additional broadcast channel, we present a 5-round 3PC protocol with guaranteed output delivery, involving the communication of a single GC. A broadcast channel is inevitable in this regime due to the results of [CHOR16]. We ensure that the broadcast communication is nominal and, most importantly, independent of the circuit size. Our implementation, using a physical UDP broadcast channel available on LAN, shows that the average computation time, LAN runtime, and communication overhead are 0.16–0.3 ms, 1.52–3 ms, and 0.19–0.46 KB, respectively, over that of [MRZ15]. For the worst-case run when the execution is stretched to five rounds, there is negligible change in the computation and LAN runtime, but the communication overhead increases to a value between 0.21–0.57 KB. We do not implement the protocol in WAN as it would require a robust broadcast protocol. When the adversary remains semi-honest, this protocol also terminates in three rounds, with almost no extra communication and computation needed in the last two rounds.

On the technical side, our construction follows a similar idea to our fair 3PC protocol, except that a garbling scheme without obliviousness works for us. Similar to our 4PC, this protocol also leverages a clever (yet different from the one used in 4PC) way of identifying a TTP in the face of misbehavior and evaluating the function on clear.

#### Theoretical and Empirical Comparison

Our protocols, in the context of relevant state-of-the-art protocols, are summarized in terms of the number of GCs, rounds, and security. 'god' implies guaranteed output delivery.

| Reference | # Parties | # GCs | Rounds | Broadcast | Security |
|-----------|-----------|-------|--------|-----------|----------|
| [MRZ15]   | 3         | 1     | 3      | No        | Selective Abort |
| This Paper| 3         | 1     | 4      | No        | Fairness |
| This Paper| 3         | 1     | 5      | Yes       | god |
| [IKKP15]  | 4         | 12    | 2      | No        | god |
| This Paper| 4         | 2     | 5      | No        | god |
| This Paper| 4         | 1     | 4      | No        | god |

While detailed experimental results appear later in the paper, we summarize the overhead or gain (indicated by \( g \)) of our protocols compared to the 3PC of [MRZ15] in terms of average computation time, LAN runtime, WAN runtime, and communication cost, where the average is taken over the number of parties and the range is taken over the choice of circuits. We show in brackets the increase in overhead or decrease in gain for the worst-case 5-round run of our 3PC and 4PC with guaranteed output delivery. For our 4-round 4PC with guaranteed output delivery, in the worst-case run, we save one round at the expense of one garbled circuit over our 5-round 4PC, which amounts to a value in the range of 72 KB to 1530 KB for the benchmark circuits.

| Reference         | Computation (ms) | LAN (ms) | WAN (s) | Communication (KB) |
|-------------------|------------------|----------|---------|--------------------|
| Fair 3PC          | 0.06 – 0.16      | 0.03 – 0.8 | 0.21 – 0.5 | 5.63 – 10.74       |
| 4PC with god      | 0.19 – 2.61 (g)  | 0.17 – 2.45 (g) | 0.02 (+.49) – 0.31 (+.52) | 18.63 (−.01) – 500.56 (−.1) (g) |
| 3PC with god      | 0.16 – 0.3       | 1.52 – 3  | -       | 0.19 (+.02) – 0.46 (+.11) |

### Roadmap

- **Section 2**: Preliminaries
- **Section 3**: Efficient 3PC Protocol Achieving Fairness
- **Section 4**: 4PC Protocol with 5 Rounds
- **Section 5**: 4PC Protocol with 4 Rounds
- **Section 6**: Efficient 3PC Protocol Achieving Guaranteed Output Delivery
- **Section 7**: Experimental Results
- **Appendices A, C, F, D, E**: Security Model and Proofs of the Four Protocols

### 2.1 Model and Notations

We consider a set \( P \) of at most four parties, denoted by \( P_1, P_2, P_3, P_4 \). We assume that any two parties are connected by pairwise secure and authentic channels. We assume the existence of a broadcast channel only for the 3PC protocol achieving guaranteed output delivery. Each party can be considered a Probabilistic Polynomial Time Turing (PPT) machine. Our model assumes a PPT adversary \( A \), who can statically and maliciously corrupt at most one party out of the three or four parties. For any subset \( X \) of \( P \), \( \text{ind}(X) \) refers to the indexes of the parties. For example, when \( X = \{P_1, P_2\} \), then \( \text{ind}(X) = \{1, 2\} \).

We denote the computational security parameter by \( \kappa \). A negligible function in \( \kappa \) is denoted by \( \text{negl}(\kappa) \). A function \( \text{negl}(\cdot) \) is negligible if for every polynomial \( p(\cdot) \), there exists a value \( N \) such that for all \( m > N \), it holds that \( \text{negl}(m) < p(m) \). We denote by \( [x] \), the set of elements \( \{1, \ldots, x\} \) and by \( [x, y] \), the set of elements \( \{x, x+1, \ldots, y\} \). For any \( x \in_R \{0, 1\}^m \), \( x_i \) denotes the \( i \)-th bit of \( x \), \( i \in [m] \). We use \( ||_{i \in [n]} x_i \) to denote the concatenation of strings \( x_i \). Let \( S \) be an infinite set and \( X = \{X_s\}_{s \in S} \), \( Y = \{Y_s\}_{s \in S} \) be the corresponding sets.