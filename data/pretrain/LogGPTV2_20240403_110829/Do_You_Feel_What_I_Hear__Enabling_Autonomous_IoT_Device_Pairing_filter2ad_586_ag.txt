[69] Samsung SmartThings.
Multipurpose Sensor.
https://support.
smartthings.com/hc/en-us/articles/213496343.
[70] Yunmok Son, Hocheol Shin, Dongkwan Kim, Youngseok Park, Juhwan
Noh, Kibum Choi, Jungwoo Choi, and Yongdae Kim. Rocking drones
with intentional sound noise on gyroscopic sensors. In 24th USENIX
Security Symposium (USENIX Security 15), 2015.
[71] Ahren Studer, Timothy Passaro, and Lujo Bauer. Don’t bump, shake
on it: The exploitation of a popular accelerometer-based smart phone
exchange and its secure replacement. In ACSAC ’11: Proceedings of
the 27th Annual Computer Security Applications Conference, Decem-
ber 2011.
[72] T. Trippel, O. Weisse, W. Xu, P. Honeyman, and K. Fu. Walnut:
Waging doubt on the integrity of mems accelerometers with acoustic
injection attacks. In 2017 IEEE European Symposium on Security and
Privacy (EuroS P), 2017.
[73] Hasan S. Ulusoy, Erol Kalkan, Jon Peter B. Fletcher, Paul Friberg,
W. K. Leith, and Krishna Banga. Design and implementation of a
structural health monitoring and alerting system for hospital buildings
in the united states. In World Conference on Earthquake Engineering,
2012.
[74] Xiao Wang and Patrick Tague. Non-invasive user tracking via passive
sensing: Privacy risks of time-series occupancy measurement.
In
Proceedings of the 2014 Workshop on Artiﬁcial Intelligent and Security
Workshop, AISec ’14, 2014.
APPENDIX
This section presents the detailed descriptions of sensors in
smart home IoT devices, the Perceptio cryptographic protocol
and its security analysis, and simulation of entropy extraction.
A. Sensors in Smart Home IoT Devices
Numerous IoT devices for smart homes are already com-
mercially existing. We introduce some of the most prevalent
sensing modalities, and their use in real-world commercial
products as well as research prototypes. Table I summarizes
them. Smart speakers (e.g., Amazon Echo [7] and Google
Home [27]) and TVs [22] are equipped with with micro-
phones used for voice-activated controls. Motion detectors
850
used to monitor movements, are equipped with Passive
Infrared (PIR) sensors [55], [20], [2]. We also ﬁnd many
on-object sensing devices in the market that monitor the
status of the object it is attached to [56], [69], [1], [44],
[20], [35]. For example, when attached on a door, it monitors
events such as door open/close as well as knocking. These
devices mainly utilize accelerometers by performing simple
signal processing to output object status information. Power
meters that measure the electrical usage of the appliance
it is attached to is also gaining popularity along with the
emergence of smart grid [37], [36]. Geophones are seismic
sensors that are gaining both industry and academic attention
for their applicability in building health monitoring [73] as
well as occupant monitoring via gait detection [58], [57].
We exploit the heterogeneous sensing modalities of these
prevalent IoT device to prove that they are co-located within
a physical boundary.
B. Perceptio Protocol Details
= FAi
We present the details of the cryptographic protocol de-
scribed in Section V. In the Key Agreement Phase, A and
B generates ﬁngerprints {FAi , i = 1, . . . , p} and {FBj , j =
1, . . . , q} for the p and q observed event clusters. Device A
then encodes a randomly generated secret key ki using each
ﬁngerprint FAi, i = 1, . . . , p, to create a set of commitments
(cid:5) EN C(ki), where (cid:5) is subtraction in a
as CAi
n, equivalent to an XOR operation, and EN C(·)
ﬁnite ﬁeld, F
is the encoding operation for an error correcting code (e.g.,
Reed-Solomon). A then sends {(CAi , h(ki)), i = 1, . . . , p}
to B, where h(·) is a collision-resistant hash function, which
discloses no information about the keys ki or the ﬁngerprints
FAi. Upon receiving the set of commitments from A, device
B attempts to open the commitment to acquire any one
of the original secrets ki using its ﬁngerprints FBj . B
computes ˆ
) for all i, j pairs, where
DEC(·) is the complementary decoding function, such that
DEC(EN C(m) (cid:5) ν) = m for a bit string m whenever the
Hamming weight (l1 norm) |ν|1 is within the code’s decoding
capability t. If B ﬁnds an i, j pair such that h(ki) = h(ˆ
ki,j),
≈ FBj .
then it most likely found a ﬁngerprint match,FAi
There are many protocol variations at this point, but we
choose one in which B needs to ﬁnd only one such pair, so
not all pq values need to be computed if a match is found. At
this point, B can use a key derivation function KDF (·) [61]
to create a shared symmetric key as kAB = KDF (ˆ
ki,j),
though A is unaware of this key at this point (Figure 18
Steps 1-4).
ki,j = DEC(FBj
(cid:5) CAi
To allow A to generate the matching symmetric key kAB
and verify it actually matches the key generated by B, both
A and B further participate in the Key Conﬁrmation Phase.
B generates a random nonce nB and transmits β, where
H(ˆ
ki,j) equals to H(ki) and Mk(m) represents a keyed
message authentication code (MAC) of message m using
key k. A, upon receiving this message, ﬁrst identiﬁes the
key, ki, from H(ki). If found, A derives the shared key
as kAB = KDF (ki) for the matching i. A then performs
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:35:39 UTC from IEEE Xplore.  Restrictions apply. 
Sensor
IoT Device
Category
Microphone
Voice Recognition (Smart
Speakers [7], [27], Smart
TV [22])
PIR
Motion Detector
[55], [20], [2]
Accelerometer
Door Knock / Open / Close
Monitor [56], [69], [1], [44],
[20], [35]
Power Meter
Electricity Usage
Monitor [37], [36]
Geophone
Structural Health
Footstep
[73], [58]
/
Monitor
TABLE I: We provide a table of sensors embedded in commercial IoT products and research prototypes.
a MAC veriﬁcation with kAB and if successful,
it also
generates a nonce, nB, and transmits to B, α. B, upon
receiving α, performs MAC veriﬁcation to verify that A also
generated the same key kAB. If successful, device A and B
successfully computed a shared symmetric key for one round
(Figure 18, Steps 5- 8).
» Key Agreement Phase «
1. A
B
: FAi = extractF s(ctx, tF ); i = 1, . . . , p
= extractF s(ctx, tF ); j = 1, . . . , q
: FBj
R←− KGen(1γ)
= FAi
(cid:5) EN C(ki)
: ki
CAi
2. A
3. A → B : CA = CA1||H(k1), .., CAp||H(kp)
4. B
: ˆ
ki,j = DEC(FBj
Verify H(ki) ?= H(ˆ
Creates ˆ
kAB = KDF (ˆ
ki,j)
)
(cid:5) CAi
ki,j); Aborts if fails
» Key Conﬁrmation Phase «
5. B → A : β = H(ˆ
where nB
ki,j)||nB||MˆkAB
R←− {0, 1}η
(nB),
6. A
: Creates kAB = KDF (ki);
MˆkAB
(nB) ?= MkAB
(nB); Aborts if fails
7. A → B : α = nA||MkAB
(nB||nA),
where nA
R←− {0, 1}η
8. B
(nB||nA) ?= MˆkAB
: MkAB
Aborts if fails
(nB||nA);
Fig. 18: Details of Perceptio key agreement and conﬁrmation
protocol using contextual information
C. Security Analysis
We now present the analysis of Perceptio’s cryptographic
protocol, namely presenting how an attacker would try to
launch attacks to compromise the shared secret. Speciﬁcally,
the attacker’s goal
is to acquire ki generated by A in
Figure 18 Step 2. We analyze two types of attacks that an
attacker may launch to achieve the aforementioned goal – (1)
bruteforcing and (2) eavesdropping attacks.
(1) Bruteforcing attack. The attacker ﬁrst tries to directly
bruteforce the key, ki by attempting to perform dictionary
attack on the hash, H(ki), which is transmitted together
with CAi
in Figure 18 Step 3. As long as the length of
the cryptographic hash function (H(·)), lH(·), is longer than
lN IST bits, bruteforce attack is computationally infeasible
(i.e., lH(·) ≥ lN IST bits). We leverage the state-of-the-art
secure cryptographic hash function such as SHA-3 [19],
which is well above lN IST bits. We deﬁne lN IST = 112bits,
as recommended by NIST [10].
(2) Eavesdropping attack. A more sophisticated attacker
pretends to be a legitimate device placed within the physical
boundary by trying to open the commitment. The attacker
launches an eavesdropping attack to try to capture some
of the events by placing his/her devices just outside of the
physical boundary. Hence, these devices may capture some
of the signals, depending the transmission media as well
as the amplitude of the original signal. Hence, rather than
performing a bruteforce attack with no known information,
the attacker has more information at guessing the ﬁngerprint,
which can be decoded with DEC(·), which in turn leads to
less amount of computations to acquire ki.
We denote leaves as the number of bits of the ﬁngerprint
that the attacker knows as a result of the eavesdropping at-
tack. Hence, we denote lbf as the number of bits the attacker
needs to bruteforce in order to successfully know ltol bits in
order to succeed in the attack, such that lbf = ltol − leaves.
Hence, the attacker’s success probability is P (Adv) = 1 with
computational complexity, Cpx, as following:
Cpx = p2lbf (Ops + (cid:5) + DEC(·) + H(·) + VH(·))
≈ O(2lbf )
where p is the number of F s and VH(·) is hash veriﬁcation.
Cpx is computationally infeasible if lbf ≥ lN IST . Hence
the gain from eavesdropping, leaves should be bounded by
leaves = ltol − lN IST .
D. Evaluating Entropy Extraction
We now evaluate the required time to extract lF (i.e., length
of ﬁngerprint) to ensure sufﬁcient entropy (e.g., 128 bits). As
discussed in Section IV-B, F is created by concatenating the
time intervals of consecutive events of same cluster type (e.g.,
series of knocking events).
1) Modeling the Arrival Time: We follow the traditional
approaches of modeling event arrivals as a Poisson pro-
cess [34], [45]. We deﬁne Sn as the waiting time until
the nth event, assuming that n events yields lF bits of
ﬁngerprint. We deﬁne Ti as the sequence of inter-arrival
times for i = 1, 2, ..., which can also be described as i.i.d.
exponential random variables. Furthermore, the probability
density function of Sn has a gamma distribution with average
arrival rate λ, number of events n, and time t as depicted in
Equation 2.
n(cid:7)
Sn =
Ti, n ≥ 1,
fSn (t) = λe
−λt (λt)n−1
(n − 1)! .
(2)
i=1
851
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:35:39 UTC from IEEE Xplore.  Restrictions apply. 
n
o
i
t
1
Motion Events
i
u
b
i
r
t
s
D
a
m
m
a
G
f
o
F
D
C
0.8
0.6
0.4
0.2
0
0
#events=5
#events=10
#events=15
#events=20
8
10
2
4
6
Time (hours)
(a) Motion
n
o
i
t
1
Door Events
i
u
b
i
r
t
s
D
a
m
m
a
G
f
o
F
D
C
0.8
0.6
0.4
0.2
0
0
#events=5
#events=10
#events=15
#events=20
10
20
30
40
Time (hours)
(b) Door
Fig. 19: Cumulative probability distribution of motion and door opening events modeled after real world smart home data
collected for two months
The corresponding expected time of nth event, E(Sn), is
depicted in Equation 3. We also deﬁne bit rate which is
the effective rate of the generating the lF ﬁngerprint bits
in a time duration of E(Sn), capturing the effective rate of
generating useful ﬁngerprint bits. The bit rate is modulated by
a correction factor, ρ, which is proportional to the detection
rate of the events. We note that the units of the bit rate can be
measured in bits per second, but in many practical scenarios
it may be more meaningful to express this value in bits per
hour.
E(Sn) = n
λ
,
BitRate = lF ρ
E(Sn)
= λ lF ρ
n
(3)
2) Evaluation Using a Real-world Smart Home Dataset:
To ensure the practicality of our analysis, we analyze a real-
world smart home data set, publicly available from CASAS
online repository [24]. We analyze two sets of sensor data
collected for two months (i.e., over 1450 hours of data): a
motion detector used to monitor movement in the home, and
a door sensor to monitor door open/close activities. Speciﬁ-
cally, we extract mean arrival rate of the two events, λmotion
and λdoor,
to be 8.85 events/hour and 0.96 events/hour,
respectively. We note that the average was computed from the
users’ daily activities only. This reﬂects the practical use case
of Perceptio, as the system will not extract much entropy at
night due to stagnant event occurrences. Using these values,
we plot a cumulative probability density function (CDF)
and vary n and t. Figure 19 (a) and (b) depict the CDF
of the two types of events, respectively. The results are
intuitive as the plots demonstrate that for more number of
n events, the longer t is required to reach a high probability.
Furthermore the two ﬁgures of motion and door events depict
clear contrast, as the door events require much longer time
to reach a high probability. We note that this analysis is an
optimistic approach as we assume perfect detection accuracy
(i.e., ρ = 1) for simplicity of the analysis.
For example, assume that it takes 20 events to yield lF =
128 bits of the ﬁngerprint, then using (Equation 3), n = 20
events arrive in about 2.3 hours for motion events, as opposed
to 20.8 hours for door events. Hence, the corresponding bit
rate for the two events are BitRatemotion of 56.6 bits/hour
and BitRatedoor of 6.1 bits/hour. We note that the bit rate
would potentially increase if there were more occupants in
the house as opposed to a single resident case from this data
set. (For example, the average number of occupants in a home
in the United States is 3.14 persons [12]).
852
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:35:39 UTC from IEEE Xplore.  Restrictions apply.