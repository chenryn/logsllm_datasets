1.25
0.50
-
-
-
-
Time
18
-
12
-
-
15.00
4.24
-
-
Size
17
-
1
-
-
9.00
11.31
-
-
Crt
‚úó
-
‚úó
-
-
-
-
-
-
#Crt
1
0
2
2
2
1.40
0.89
1.40
0.89
(a) Test Group: Using Xenon
(b) Control Group: Using Iodine
Figure 13: Results of the user study. The participants were split into two equally sized groups: Test (Fig. 13a) using Xenon and Control (Fig. 13b)
using Iodine. The participants were asked to find assumptions for three of the Iodine benchmarks: ALU, FPU, and RISC-V. Both groups were
given 40 minutes to complete the three tasks. For each task, we record the time taken to complete the task in minutes (Time), the number
of annotations in the solution set (Size), and whether the solution was correct (Crt). We reject solutions for ALU and FPU if they contain
assumptions about operands, and for RISC-V, if they contain assumptions about memory or the register file. We report the average (ùúá) and
standard deviation (ùúé) of all completed runs, i.e., including those that yielded wrong solutions. ùúá‚àó and ùúé‚àó show average and standard deviation
for correct runs, only. Finally, we report the overall number of correctly completed tasks #Crt. On average, participants in the test group were
able to complete 2.6 tasks, while participants in the control group were only able to solve 1.4 within the 40 minutes trial. This indicates that
using Xenon has a very large (ùëë = 1.62), statistically significant (ùë° (8) = 2.56, ùëù = .016) positive effect on correct completion.
assumptions on traps, memory-mapped IO, and timer interrupts
do not concern external inputs, but internal pipeline state.
Secrecy Assumptions: Internal Processor State. While, in our
experience, top-level assumptions about IO behavior are relatively
easy to find, proving constant-time execution also requires harder
to find assumptions about processor internals. These assumptions
encode constraints on the kind of programs that can safely be
executed on the processor. Figure 15 shows the assumptions for
SCARV‚Äôs pipeline module. Xenon discovers the classic constant-
time assumptions stating that control-flow (Lines 4 and 5) and
memory-trace (Line 7) are secret independent. Similarly, memory
stalls (Line 9), instruction validity (Line 11), and the computed ùúáop
(Line 13) must not depend on secrets.
But Xenon also discovers systems-level assumptions that are
not commonly associated with constant-time programming. For ex-
ample, access errors for control and status (CSR) registers (Line 15)
must not depend on secrets, and the timing of when to return from
machine-mode (Line 17) and traps (Lines 21 and 22), must be pub-
lic. Finally, we may not set the configuration register of SCARV‚Äôs
leakage fence instruction (Line 19) depending on secrets. This is
necessary as different configurations flush different parts of the
pipeline and might incur different delays.
Constant-Time Subset of Instructions. The above assumptions
are satisfied, when the instructions run on SCAR-V are limited
to the arithmetic, and bitwise-logic subset of RISC-V; instructions
must be valid, i.e., properly encoded; even division is constant-time.
8 LIMITATIONS AND FUTURE WORK
We discuss some of Xenon‚Äôs limitations.
Assumptions about Data. Xenon currently only discovers se-
crecy assumptions, i.e., whether a given value is public or private.
It may be beneficial to also discover assumptions about data (e.g.,
that a certain flag is always set). In future work, we would like to
explore how to combine Xenon‚Äôs assumption synthesis method
with techniques for inferring data preconditions [38, 74].
Minimality of Assumptions. Xenon inherits the limitations of
the underlying Horn solver (¬ß 3). In particular, an assumption set
could be sufficient to ensure constant-time execution of the circuit,
but the solver may be unable to prove it. The minimality of our
assumption set (¬ß 7) is therefore relative to the solver, and could
potentially be improved with more precise solving methods‚Äîat the
cost of reduced interactivity and scalability. As future work, one
could use fast over-approximating solvers in the assumption discov-
ery phase of our verification method (¬ß 7), and then slower, more
precise solvers to minimize the assumption set after bootstrapping.
Mapping Back to Software. Xenon discovers an assumption set
that ensures constant-time execution of the verified design. But, it
leaves open the question of how to map assumptions back into proof
obligations on software. The assumption set Xenon discovered for
SCARV (¬ß 7) suggests that this might require a whole system effort
that goes beyond current practices of constant-time programming.
We hope that open-sourcing assumptions for SCARV will help
future research efforts in this direction.
Guarantees on Synthesized Circuits. Finally, we prove constant-
time at the Verilog level. This is convenient for error-localization,
but it doesn‚Äôt ensure that guarantees carry over to the generated
circuits. Proofs are guaranteed to carry over if the synthesizer
produces behavior within the Verilog standard [13], as, for example,
formalized in [50, 51]. In particular, we make no further assumptions
apart from semantics preservation. However, we leave the problem
of verifying semantics preservation in synthesis to future work.
9 RELATED WORK
Verifying Leakage Freedom. There are various techniques, such
as ct-verif [16], [22], and CT-Wasm [85], that verify constant-
time execution of software, and quantify leakage through timing
Session 2B: Formal Analysis and Verification CCS ‚Äô21, November 15‚Äì19, 2021, Virtual Event, Republic of Korea4401 src :
2
3
4 snk :
5
6
7
8
9
10
11
dmem_rdata
rng_rsp_data
dmem_req
dmem_ack
dmem_strb
imem_req
leak_fence_unc 0
rng_req_valid
rng_rsp_ready
12 pub :
13
14
15
16
17
18
19
20
21
22
# external reset
g_resetn
# data & instr . mem
dmem_error
dmem_gnt
dmem_recv
imem_error
# random generator
rng_req_ready
rng_rsp_valid
23 rng_rsp_status
24 # memory - mapped io
25 mmio_error
26 # internal trap
27 int_trap_req
28 # external interrupts
29 int_extern_cause
30 int_external
31 mie_meie
32 # global interrupts
33 mstatus_mie
34 # non - mask . interrupts
35 int_nmi
36 # software interrupts
37 int_software
38 mie_msie
39 # timer interrupts
40 ti_pending
41 mie_mtie
Figure 14: Secrecy Assumptions Synthesized by Xenon for the Toplevel Module of SCARV.
1 pub :
2
3
4
5
6
7
8
9
10
11
# control - flow
cf_req
cf_target
# dest . address
lsu_addr
hold_memory_requests
hold_lsu_req
# decoded instr valid
s1 _valid
12 #mu - op
13 s2 _uop
14 # contr - stat regs
15 csr_error
16 ret_from_mach_mode
17 exec_mret
18 # fence
19 leak_lkgcfg
20 # traps
21 trap_cpu
22 trap_int
Figure 15: Secrecy Assumptions Synthesized by Xenon for the Main-
Pipeline module of SCARV.
and cache side-channels [12, 17, 41, 65, 79, 90]. However, their anal-
yses do not directly apply to our setting: They consider straight-
line, sequential code, unlike the highly parallel nature of hardware.
There are many techniques for verifying information flow proper-
ties of hardware. Kwon et al. [64] prove information flow safety of
hardware for policies that allow explicit declassification and are ex-
pressed over streams of input data. SecVerilog [91] and Caisson [66]
use information flow types to ensure that generated circuits are
secure. GLIFT [82, 83] tracks the flow of information at the gate
level to eliminate timing channels. Other techniques such as Hyper-
Flow [45], GhostRider [67] and Zhang et al. [90] take the hardware
and software co-design approach to obtain end-to-end guarantees.
dudect [77], detects end-to-end timing variability across the stack
via a black-box technique based on statistical measurements. Io-
dine [50], like Xenon, focuses on clock-precise constant-time exe-
cution, not information flow. Unlike Xenon, none of these methods
provides help in elucidating secrecy assumptions, in case the verifi-
cation fails‚Äîa feature we found essential in scaling our analysis to
larger benchmarks. We see the techniques presented in this paper
as complementary and would like to explore their potential for
scaling existing verification methods for hardware and software.
Fault Localization. There are several approaches to help devel-
opers localize the root causes of software bugs [86]. Logic-based
fault localization techniques [31, 42, 59, 60] are the closest line of
work to ours. For example, BugAssist [59] uses a MAXSAT solver
to compute the maximal set of statements that may cause the fail-
ure given a failed error trace of a C program. Xenon is similar in
that we phrase localization as an optimization problem, allowing
the use of ILP to locate the possible cause of a non-constant-time
variable. However, Xenon focuses on constant-time, which is a re-
lational property, and hardware which has a substantially different
execution model.
Synthesizing Assumptions. Our approach to synthesizing secrecy
assumptions is related to work on precondition synthesis for mem-
ory safety. Data-driven precondition inference techniques such
as [47, 48, 72, 80, 81], unlike Xenon, require positive and nega-
tive examples to infer preconditions. Xenon‚Äôs synthesis technique
is an instance of abductive inference, which has been previously
used to triage analysis reports by allowing the user to interactively
determine the preconditions under which a program is safe or un-
safe [38] or to identify the most general assumptions or context
under which a given module can be verified safe [14, 27, 39, 40, 49].
Livshits et al. [68] infer information-flow specifications for web-
applications using probabilistic inference. Unlike these efforts, our
abduction strategy is tailored to the relational constant-time prop-
erty. Furthermore, Xenon uses information from the verifier to
ensure that the user interaction loop only invokes the ILP solver
(not the slower Horn-clause verifier), yielding a rapid cycle that
pinpoints the assumptions under which a circuit is constant-time.
In future work, we would like to see, if ideas introduced in Xenon
can be applied to localization, explanation and verification of other
classes of correctness or security properties.
Modular Verification of Software and Hardware. Xenon ex-
ploits modularity to verify large circuits by composing summaries of
the behaviors of smaller sub-components. This is a well-known idea
in verification; [78] shows how to perform dataflow analysis of large
programs by computing procedure summaries, and Houdini [46]
shows how to verify programs by automatically synthesizing pre-
and post- conditions summarizing the behaviors of individual proce-
dures. For hardware, model checkers like Mocha [18] and SMV [69]
use rely-guarantee reasoning for modular verification. Kami [30]
and [84] develops a compositional hardware verification method-
ology using the Coq proof assistant. However, the above require
the user to provide module interface abstractions. There are some
approaches that synthesize such abstractions in a counterexample
guided fashion [54, 92]. All focus on functional verification of prop-
erties of a single run, and do not support abstractions needed for
timing-channels which require relational hyper-properties [32].
ACKNOWLEDGMENTS
We thank the reviewers for their suggestions and insightful com-
ments, and our our user study participants for their effort and
feedback on Xenon. This work was supported in part by the NSF
under Grant Number CNS-1514435, CCF-1918573, and CAREER
CNS-2048262; by ONR Grant N000141512750; and, by the CONIX
Research Center, one of six centers in JUMP, a Semiconductor Re-
search Corporation (SRC) program sponsored by DARPA.
Session 2B: Formal Analysis and Verification CCS ‚Äô21, November 15‚Äì19, 2021, Virtual Event, Republic of Korea441REFERENCES
[1] [n.d.]. BearSSL - Constant-Time Crypto. https://www.bearssl.org/constanttime.
html. (Accessed on 08/19/2020).
[2] [n.d.]. fpga_mc/fpu at master ¬∑ monajalal/fpga_mc ¬∑ GitHub. https://github.com/
monajalal/fpga_mc/tree/master/fpu. (Accessed on 08/16/2020).
[3] [n.d.]. GitHub - dawsonjon/fpu: synthesiseable ieee 754 floating point library in
verilog. https://github.com/dawsonjon/fpu. (Accessed on 08/16/2020).
[4] [n.d.]. GitHub - scarv/scarv-cpu: SCARV: a side-channel hardened RISC-V plat-
form. https://github.com/scarv/scarv-cpu. (Accessed on 08/16/2020).
[5] [n.d.]. GitHub - scarv/xcrypto: XCrypto: a cryptographic ISE for RISC-V. https:
//github.com/scarv/xcrypto. (Accessed on 08/19/2020).
[6] [n.d.]. GitHub - tommythorn/yarvi: Yet Another RISC-V Implementation. https:
//github.com/tommythorn/yarvi. (Accessed on 08/16/2020).
[7] [n.d.]. GLPK - GNU Project - Free Software Foundation (FSF). https://www.gnu.
org/software/glpk/. (Accessed on 08/10/2020).
[8] [n.d.]. liquid-fixpoint: Horn Clause Constraint Solving for Liquid Types. https:
//github.com/ucsd-progsys/liquid-fixpoint. Accessed: 2018-08-29.
[9] [n.d.]. MIPS. https://github.com/gokhankici/iodine/tree/master/benchmarks/472-
mips-pipelined. (Accessed on 08/16/2020).
[10] [n.d.]. Overview :: AES :: OpenCores. https://opencores.org/projects/tiny_aes.
[11] [n.d.]. Overview :: SHA cores :: OpenCores. https://opencores.org/projects/sha_
(Accessed on 08/05/2020).
core. (Accessed on 08/16/2020).
2005.
[12] [n.d.]. TIS-CT. http://trust-in-soft.com/tis-ct/.
[13] 2005. IEEE Standard for Verilog Hardware Description Language. IEEE Std 1364-
[14] Aws Albarghouthi, Isil Dillig, and Arie Gurfinkel. 2016. Maximal specification
synthesis. In Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium
on Principles of Programming Languages, POPL 2016, St. Petersburg, FL, USA,
January 20 - 22, 2016, Rastislav Bod√≠k and Rupak Majumdar (Eds.). ACM, 789‚Äì801.