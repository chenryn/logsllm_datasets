6
20
13
4
4
7
1
4
0
0
0
0
0
0
2
5
0
1
1
3
4
7
9
15
13
7
0
0
1
0
0
6
16
0
3
2
3
1
12
8
3
11
3
10
20
11
0
16
13
5
3
12
12
16
12
1
10
16
14
9
0
0
4
0
0
2
6
0
0
3
1
3
Table 1: A detailed report of the findings in our case study on contextual factors. This table describes the relation between sensitive API categories and
contextual factors. Each row represents a API category and each column represents a Context Category, and the value represents feature importance.
The feature importance represents the predictive power a feature has in a learning problem (higher scores are better).
and in many cases represent minor implementation details or generic
program functionality.
These non-essential dependencies have significant security con-
sequences when they are used in the feature space. For example,
to work around graph-based classification, the malware developer
could insert benign routines into their malware to intentionally con-
fuse the classifier. This is effective because the resulting malware
would contain more benign behavior than suspicious behavior, by-
passing detection. In practice, like normal applications, malware
developers also rely heavily on code reuses [10], which causes a
classifier’s training dataset to contain many samples belonging to
the same family. Naturally, this will make the non-informative fea-
tures reoccur, misleading the classifier into making security-centric
decisions based on residual features that aren’t necessarily related
to the behaviors that the classifier intends to vet. Prior work has
shown that the natural redundancy that occurs in malware training
sets combined with introducing non-informative features into the
feature space leads to downstream classifiers being susceptible to
making discriminative decisions based on non-essential features [41].
Instead of including all the dependencies involved in the API in-
vocation, we argue to focus on the lightweight “backbone” of the
behavior. Through extensive evaluation, we show this lightweight
model achieves better accuracy and is more resilient to the context
confusion issue.
2.1.2 Family-Specific Signatures. Prior context-based sys-
tems add a large amount of context related to the specific app which
results in a fine-grain representation of the app’s behavior. However,
this graph essentially becomes a signature for that particular malware
family instead of a more general behavioral profile. Models catego-
rized by family-specific signatures in fact weaken the main goal of
these systems which is to rely on generic features to detect unknown
variants or zero-day attacks. AppContext [52] is a state-of-the-art
Android malware detection system that distinguishes illegitimate
and legitimate uses of sensitive behavior by tying context-factors,
such as activation events, and behavior information, to security-
sensitive behaviors. AppContext attaches these contextual factors
to a security-centric event to identify the intent behind the behavior.
This approach allows AppContext to provide a fine-grained view of
the combination of contextual factors that influenced the execution
of a security-sensitive behavior. Unfortunately, since so many pos-
sible combinations of contextual factors are possible, AppContext
requires intensive, manual labeling of sensitive behaviors before it
can be trained. Additionally, even though the authors are domain
experts, in several cases sensitive behaviors were mislabeled.
One prior approach which has been used to avoid the inten-
sive labeling process is frequency analysis [2, 53]. For example,
DroidAPIMiner [2] leverages frequency analysis to determine which
sensitive APIs are more common in malicious applications. However,
in order for frequency analysis to be effective, the features needs to
be generalizable. This is required because the discriminating factor
of frequency analysis depends on features frequently reoccurring
in the same class. Unfortunately, since AppContext uses so many
contextual factors in its decision making process, applying frequency
analysis in an straight-forward manner would be difficult. This is
because as the set of contextual dependencies grows larger, the
likelihood of it being unique increases. So, although we agree that
context is necessary to make informative decisions about an appli-
cation’s intent, it is also necessary to distinguish better information
from non-informative factors. This approach allows context-based
systems to identify the key contextual factors that make up the back-
bone of the malware’s behavior while also avoiding non-informative
dependencies in order to maintain the generality of the feature space.
2.2 Case Study: Identifying Informative Context
Factors
In this case study, we collect 54,969 labeled sensitive behaviors to
study the dependency relationships between Android sensitive APIs
and the corresponding contextual factors. We extract the contextual
factors for each behavior with a state-of-the-art, context-based sys-
tem, AppContext [52]. AppContext uses static program analysis to
capture the events and conditions that each security-centric API is
dependent on. By extracting this context, AppContext determines
under what events and conditions this security-sensitive event oc-
curred. Next, AppContext uses these contextual factors as features
212ACSAC ’18, December 3-7, 2018, San Juan, PR, USA
Figure 1: Visualization of the four stages of analysis of PIKADROID. To
classifying a unknown app. (a) PIKADROID each app first goes through
the reachability module, which identitfies the sensitive APIs invokable
from each entry point. (b) Next, the reachability results are passed into
the resolution module, where Class Hierarchy Analysis (CHA) is ap-
plied to identify what classes were extended. (c) Feature Construction
(d) PIKADROID determines if the application is malicious or benign.
to classify whether the sensitive API is used inappropriately or not.
The intuition here is that the events and conditions under which a
security-sensitive method is invoked differ in benign and malicious
applications.
In this study, we address the question: what are the informa-
tive, contextual factors that highly distinguish between legitimate
and illegitimate uses of sensitive behavior? To answer this ques-
tion, first sensitive behaviors are categorized into several sets. We
leverage the Android permission model to do the categorization.
For example, HttpClient.execute belongs to the INTERNET cate-
gory. Unguarded APIs, such as ClassLoader.loadClass, are then
placed in categories based on their functionality. For example, the
CLASS_LOADER category contains methods related to dynamic code
loading. AppContext also creates contextual categories such as lo-
cation, system, and network. Contextual categories for entrypoints
were created by grouping similar entrypoints into four categories
Activity, Service, Broadcast Receivers, UI.
After completing the categorization process, we rank each contex-
tual category based on how influential they are on determining if the
behavior is benign or malicious using Ridge Regression [23]. The
results are shown in Table 1 (the higher the percent, the more impor-
tant the feature). The remaining categories are discussed in §6.2.4.
The rank and importance of each context category implies which
contextual factors provide informative contextual information and
what factors are potentially non-informative. In almost all cases,
the ENTRYPOINT categories were ranked the highest. Following the
entrypoint category is the NETWORK category. Therefore we conclude
that the entrypoint is the strongest factor, which indicates its po-
tential in being the most discriminative and generalizable power in
classification. This finding motivates us to use it in our proposed
lightweight contextual model.
2.3 Calling for Lightweight Context Dependencies
Identifying under what circumstances a behavior occurred helps dif-
ferentiate malicious and benign applications because the additional
context helps distinguish between malicious and benign uses of sen-
sitive behavior. We develop lightweight, circumstance awareness
by identifying what entrypoint was used to execute a sensitive API.
The choice to use the entrypoint is based on the stark differences we
Entrypoint
Unconditioned on entrypoint (API only)
Activity.onDestroy
Activity.onRestart
DialogInterface.onClick
Preference.onPreferenceChange
Service.onCreate
Service.onStart
webkit.onDownloadStart
J. Allen et. al
Risk Score
0.90
15.15
14.46
3.39
1.77
6.89
6.20
1.03
Table 2: The ratio of of how frequently malicious applications executed
a HTTP Client from different entrypoints in malicious versus benign
apps as well as not conditioned on any entrypoint
find in what entrypoints malicious and benign applications use to
invoke sensitive behavior. For example, in Table 2 we provide the
likelihood of a malicious application executing a HTTP client from
different entrypoints. Despite this API being used by more benign
apps, malicious applications are 6.89 times more likely to invoke it
from the Service.onCreate entrypoint. Based on this observation,
we build a model that includes the entrypoints of the sensitive API
invocation, improving the accuracy of malware detection.
3 PIKADROID
3.1 Overview
We propose a system that uses lightweight, circumstantial aware-
ness for Android malware detection. We depict the architecture of
PIKADROID in Figure 1. First, the static module extracts sensitive
behaviors and the lightweight context in which they occur. The
output of this step is the set of all (entrypoint, target API) pairs
extracted for each app in a training set. After the static analysis is
complete, PIKADROID uses the extracted pairs to learn under what
circumstances the invocation of a sensitive API should be consid-
ered malicious. Similar to prior approaches [2], we assume pairs
that are found more in malicious applications are naturally more
malicious. This allows PIKADROID to identify when behaviors that
are commonly used by both benign and malicious applications are
being used inappropriately. After the frequency analysis is com-
pleted, a risk score, re,t , is assigned to each pair (entrypoint,target
API). The risk scores are then used to create a feature vector for
each app. Finally, PIKADROID uses the apps in the training set to
train PIKADROID’s classifier. We test several machine learning clas-
sifiers for comparison, and find that a RandomForest Classifier [29]
performs the best (refer to §6.5 for detailed performance evaluation).
After completion of the training phase, PIKADROID’s model can be
used to accurately classify benign and malicious apps.
3.2 Static Analysis Module
PIKADROID’s static module applies reachability analysis starting
from each entrypoint used by an app to a set of configurable, tar-
geted, sensitive APIs methods. The goal of the static analysis module
is to identify what sensitive behaviors are used by an application,
and under what lightweight context this behavior is invoked. To
identify what set of behaviors in the Android framework should be
considered sensitive, we leverage SUSI [39] to identify a compre-
hensive lists of sensitive source and sinks and Pscout [6] to identify
permission-guarded APIs. Additionally, the Android framework
leverages over 20,000 different callbacks that could potentially be
Static Analysis ModuleLearning ModuleFrequencyConstructionEntrypointDiscoveryReachabilityAnalysisFrequencyAnalysis ClassificationFeatureLearning?213Improving Accuracy of Android Malware Detection with Lightweight Contextual Awareness
ACSAC ’18, December 3-7, 2018, San Juan, PR, USA
/* The entrypoint invoked when an intent is received. */
protected void onHandleIntent(Intent intent) {
collectPayment();
}
...
...
if (!checkID(getApplicationContext()) {
1 public class MsgService extends IntentService {
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24 }
/* Sends premium text message. */
public void collectPayment() {
...
SmsManager.getDefault().sendTextMessage(...);
...
deviceId = telephonyManager.getDeviceId();
return deviceId.equals("000000000000000");
/* Check if this is a real device. */
public static boolean checkID(Context context) {
}
}
}
Listing 1: A sms trojan checking the device ID and only sending a pre-
mium text message if it is a real device.
next step is to use reachability analysis from each entrypoint to
identify what sensitive behavior can be invoked. For each entrypoint,
PIKADROID does reachability analysis to identify any callsite of
targetable methods. If a callsite is reachable from a particular entry-
point, a pair, (entrypoint, targetMethod), is generated for later anal-
ysis. At this stage, the entrypoint signatures are defined in application
specific classes which extend the base component classes in the An-
droid SDK. For example, in Listing 1, the MsgService class has
extended the IntentService class and defined the onHandleIntent