n Heavy use of Ajax for performing asynchronous, behind-the-scenes requests
n Increased cross-domain integration using various techniques
n Use of new technologies on the client side, including XML, JSON, and Flex
n More prominent functionality supporting user-generated content, infor-
mation sharing, and interaction
As with all changes in technology, these trends present new opportunities
for security vulnerabilities to arise. However, they do not defi ne a clear subset
of web application security issues in general. The vulnerabilities that occur in
these contexts are largely the same as, or closely derived from, types of vulner-
abilities that preceded these trends. In general, talking about “Web 2.0 Security”
usually represents a category mistake that does not facilitate clear thinking
about the issues that matter.
Browser Extension Technologies
Going beyond the capabilities of JavaScript, some web applications employ
browser extension technologies that use custom code to extend the browser’s
built-in capabilities in arbitrary ways. These components may be deployed as
bytecode that is executed by a suitable browser plug-in or may involve installing
native executables onto the client computer itself. The thick-client technologies
you are likely to encounter when attacking web applications are
n Java applets
n ActiveX controls
n Flash objects
n Silverlight objects
These technologies are described in detail in Chapter 5.
cc0033..iinndddd 6655 88//1199//22001111 1122::0033::4455 PPMM
Stuttard c03.indd V3 - 07/22/2011 Page 66
66 Chapter 3 n Web Application Technologies
State and Sessions
The technologies described so far enable the server and client components of
a web application to exchange and process data in numerous ways. To imple-
ment most kinds of useful functionality, however, applications need to track the
state of each user’s interaction with the application across multiple requests. For
example, a shopping application may allow users to browse a product catalog,
add items to a cart, view and update the cart contents, proceed to checkout, and
provide personal and payment details.
To make this kind of functionality possible, the application must maintain a
set of stateful data generated by the user’s actions across several requests. This
data normally is held within a server-side structure called a session. When a
user performs an action, such as adding an item to her shopping cart, the server-
side application updates the relevant details within the user’s session. When the
user later views the contents of her cart, data from the session is used to return
the correct information to the user.
In some applications, state information is stored on the client component
rather than the server. The current set of data is passed to the client in each
server response and is sent back to the server in each client request. Of course,
because the user may modify any data transmitted via the client component,
applications need to protect themselves from attackers who may change this
state information in an attempt to interfere with the application’s logic. The
ASP.NET platform makes use of a hidden form fi eld called ViewState to store
state information about the user’s web interface and thereby reduce overhead
on the server. By default, the contents of the ViewState include a keyed hash
to prevent tampering.
Because the HTTP protocol is itself stateless, most applications need a way to
reidentify individual users across multiple requests for the correct set of state
data to be used to process each request. Normally this is achieved by issuing
each user a token that uniquely identifi es that user’s session. These tokens may
be transmitted using any type of request parameter, but most applications use
HTTP cookies. Several kinds of vulnerabilities arise in relation to session han-
dling, as described in detail in Chapter 7.
Encoding Schemes
Web applications employ several different encoding schemes for their data. Both
the HTTP protocol and the HTML language are historically text-based, and dif-
ferent encoding schemes have been devised to ensure that these mechanisms
can safely handle unusual characters and binary data. When you are attacking
a web application, you will frequently need to encode data using a relevant
cc0033..iinndddd 6666 88//1199//22001111 1122::0033::4466 PPMM
Stuttard c03.indd V3 - 07/22/2011 Page 67
Chapter 3 n Web Application Technologies 67
scheme to ensure that it is handled in the way you intend. Furthermore, in many
cases you may be able to manipulate the encoding schemes an application uses
to cause behavior that its designers did not intend.
URL Encoding
URLs are permitted to contain only the printable characters in the US-ASCII
character set — that is, those whose ASCII code is in the range 0x20 to 0x7e,
inclusive. Furthermore, several characters within this range are restricted because
they have special meaning within the URL scheme itself or within the HTTP
protocol.
The URL-encoding scheme is used to encode any problematic characters
within the extended ASCII character set so that they can be safely transported
over HTTP. The URL-encoded form of any character is the % prefi x followed by
the character’s two-digit ASCII code expressed in hexadecimal. Here are some
characters that are commonly URL-encoded:
n %3d — =
n %25 — %
n %20 — Space
n %0a — New line
n %00 — Null byte
A further encoding to be aware of is the + character, which represents a
URL-encoded space (in addition to the %20 representation of a space).
NOTE For the purpose of attacking web applications, you should URL-
encode any of the following characters when you insert them as data into an
HTTP request:
space % ? & = ; + #
(Of course, you will often need to use these characters with their special
meaning when modifying a request — for example, to add a request parameter
to the query string. In this case, they should be used in their literal form.)
Unicode Encoding
Unicode is a character encoding standard that is designed to support all of the
world’s writing systems. It employs various encoding schemes, some of which
can be used to represent unusual characters in web applications.
16-bit Unicode encoding works in a similar way to URL encoding. For
transmission over HTTP, the 16-bit Unicode-encoded form of a character is
cc0033..iinndddd 6677 88//1199//22001111 1122::0033::4466 PPMM
Stuttard c03.indd V3 - 07/22/2011 Page 68
68 Chapter 3 n Web Application Technologies
the %u prefi x followed by the character’s Unicode code point expressed in
hexadecimal:
n %u2215 — /
n %u00e9 — é
UTF-8 is a variable-length encoding standard that employs one or more bytes
to express each character. For transmission over HTTP, the UTF-8-encoded form
of a multibyte character simply uses each byte expressed in hexadecimal and
preceded by the % prefi x:
n %c2%a9 — ©
n %e2%89%a0 — 
For the purpose of attacking web applications, Unicode encoding is primarily
of interest because it can sometimes be used to defeat input validation mecha-
nisms. If an input fi lter blocks certain malicious expressions, but the component
that subsequently processes the input understands Unicode encoding, it may
be possible to bypass the fi lter using various standard and malformed Unicode
encodings.
HTML Encoding
HTML encoding is used to represent problematic characters so that they can be
safely incorporated into an HTML document. Various characters have special
meaning as metacharacters within HTML and are used to defi ne a document’s
structure rather than its content. To use these characters safely as part of the
document’s content, it is necessary to HTML-encode them.
HTML encoding defi nes numerous HTML entities to represent specifi c literal
characters:
n &quot; — "
n &apos; — '
n &amp; — &
n &lt; — 
In addition, any character can be HTML-encoded using its ASCII code in deci-
mal form:
n &#34; — "
n &#39; — '
or by using its ASCII code in hexadecimal form (prefi xed by an x):
cc0033..iinndddd 6688 88//1199//22001111 1122::0033::4466 PPMM
Stuttard c03.indd V3 - 07/22/2011 Page 69
Chapter 3 n Web Application Technologies 69
n &#x22; — "
n &#x27; — '
When you are attacking a web application, your main interest in HTML
encoding is likely to be when probing for cross-site scripting vulnerabilities. If
an application returns user input unmodifi ed within its responses, it is prob-
ably vulnerable, whereas if dangerous characters are HTML-encoded, it may
be safe. See Chapter 12 for more details on these vulnerabilities.
Base64 Encoding
Base64 encoding allows any binary data to be safely represented using only
printable ASCII characters. It is commonly used to encode e-mail attachments
for safe transmission over SMTP. It is also used to encode user credentials in
basic HTTP authentication.
Base64 encoding processes input data in blocks of three bytes. Each of these
blocks is divided into four chunks of six bits each. Six bits of data allows for 64
different possible permutations, so each chunk can be represented using a set
of 64 characters. Base64 encoding employs the following character set, which
contains only printable ASCII characters:
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
If the fi nal block of input data results in fewer than three chunks of output
data, the output is padded with one or two = characters.
For example, here is the Base64-encoded form of TheWebApplicationHacker’s
Handbook:
VGhlIFdlYiBBcHBsaWNhdGlvbiBIYWNrZXIncyBIYW5kYm9vaw==
Many web applications use Base64 encoding to transmit binary data within
cookies and other parameters, and even to obfuscate (that is, to hide) sensitive
data to prevent trivial modifi cation. You should always look out for, and decode,
any Base64 data that is issued to the client. Base64-encoded strings can often
be easily recognized by their specifi c character set and the presence of padding
characters at the end of the string.
Hex Encoding
Many applications use straightforward hexadecimal encoding when transmit-
ting binary data, using ASCII characters to represent the hexadecimal block.
For example, hex-encoding the username “daf” within a cookie would result
in this:
646166
cc0033..iinndddd 6699 88//1199//22001111 1122::0033::4466 PPMM
Stuttard c03.indd V3 - 07/22/2011 Page 70
70 Chapter 3 n Web Application Technologies
As with Base64, hex-encoded data is usually easy to spot. You should always
attempt to decode any such data that the server sends to the client to understand
its function.
Remoting and Serialization Frameworks
In recent years, various frameworks have evolved for creating user interfaces in
which client-side code can remotely access various programmatic APIs imple-
mented on the server side. This allows developers to partly abstract away from
the distributed nature of web applications and write code in a manner that is
closer to the paradigm of a conventional desktop application. These frameworks
typically provide stub APIs for use on the client side. They also automatically
handle both the remoting of these API calls to the relevant server-side functions
and the serialization of any data that is passed to those functions.
Examples of these kinds of remoting and serialization frameworks include
the following:
n Flex and AMF
n Silverlight and WCF
n Java serialized objects
We will discuss techniques for working with these frameworks, and the kinds
of security issues that can arise, in Chapters 4 and 5.
Next Steps
So far, we have described the current state of web application (in)security, exam-
ined the core mechanisms by which web applications can defend themselves,
and taken a brief look at the key technologies employed in today’s applications.
With this groundwork in place, we are now in a position to start looking at the
actual practicalities of attacking web applications.
In any attack, your fi rst task is to map the target application’s content and
functionality to establish how it functions, how it attempts to defend itself, and
what technologies it uses. The next chapter examines this mapping process
in detail and shows how you can use it to obtain a deep understanding of an
application’s attack surface. This knowledge will prove vital when it comes to
fi nding and exploiting security fl aws within your target.
cc0033..iinndddd 7700 88//1199//22001111 1122::0033::4466 PPMM
Stuttard c03.indd V3 - 07/22/2011 Page 71
Chapter 3 n Web Application Technologies 71
Questions
Answers can be found at http://mdsec.net/wahh.
1. What is the OPTIONS method used for?
2. What are the If-Modified-Since and If-None-Match headers used for?
Why might you be interested in these when attacking an application?
3. What is the signifi cance of the secure fl ag when a server sets a cookie?
4. What is the difference between the common status codes 301 and 302?
5. How does a browser interoperate with a web proxy when SSL is being
used?
cc0033..iinndddd 7711 88//1199//22001111 1122::0033::4466 PPMM
Stuttard c03.indd V3 - 07/22/2011 Page 72
cc0033..iinndddd 7722 88//1199//22001111 1122::0033::4466 PPMM
Stuttard c04.indd V3 - 07/22/2011 Page 73
CHAPTER
4
Mapping the Application
The fi rst step in the process of attacking an application is gathering and examin-
ing some key information about it to gain a better understanding of what you
are up against.
The mapping exercise begins by enumerating the application’s content and
functionality in order to understand what the application does and how it
behaves. Much of this functionality is easy to identify, but some of it may be
hidden, requiring a degree of guesswork and luck to discover.
After a catalog of the application’s functionality has been assembled, the
principal task is to closely examine every aspect of its behavior, its core secu-
rity mechanisms, and the technologies being employed (on both the client and
server). This will enable you to identify the key attack surface that the application
exposes and hence the most interesting areas where you should target subse-
quent probing to fi nd exploitable vulnerabilities. Often the analysis exercise can
uncover vulnerabilities by itself, as discussed later in the chapter.
As applications get ever larger and more functional, effective mapping is a
valuable skill. A seasoned expert can quickly triage whole areas of functionality,
looking for classes of vulnerabilities as opposed to instances, while investing
signifi cant time in testing other specifi c areas, aiming to uncover a high-risk issue.
This chapter describes the practical steps you need to follow during application
mapping, various techniques and tricks you can use to maximize its effective-
ness, and some tools that can assist you in the process.
73
cc0044..iinndddd 7733 88//1199//22001111 1122::0044::4400 PPMM
Stuttard c04.indd V3 - 07/22/2011 Page 74
74 Chapter 4 n Mapping the Application
Enumerating Content and Functionality
In a typical application, the majority of the content and functionality can be
identifi ed via manual browsing. The basic approach is to walk through the
application starting from the main initial page, following every link, and navi-
gating through all multistage functions (such as user registration or password
resetting). If the application contains a “site map,” this can provide a useful
starting point for enumerating content.
However, to perform a rigorous inspection of the enumerated content, and
to obtain a comprehensive record of everything identifi ed, you must employ
more advanced techniques than simple browsing.
Web Spidering
Various tools can perform automated spidering of websites. These tools work
by requesting a web page, parsing it for links to other content, requesting these
links, and continuing recursively until no new content is discovered.
Building on this basic function, web application spiders attempt to achieve
a higher level of coverage by also parsing HTML forms and submitting these
back to the application using various preset or random values. This can enable
them to walk through multistage functionality and to follow forms-based navi-
gation (such as where drop-down lists are used as content menus). Some tools
also parse client-side JavaScript to extract URLs pointing to further content.
Numerous free tools are available that do a decent job of enumerating applica-
tion content and functionality, including Burp Suite, WebScarab, Zed Attack
Proxy, and CAT (see Chapter 20 for more details).
TIP Many web servers contain a fi le named robots.txt in the web root that
contains a list of URLs that the site does not want web spiders to visit or search
engines to index. Sometimes, this fi le contains references to sensitive func-
tionality, which you are certainly interested in spidering. Some spidering tools
designed for attacking web applications check for the robots.txt fi le and use
all URLs within it as seeds in the spidering process. In this case, the robots.txt
fi le may be counterproductive to the security of the web application.
This chapter uses a fi ctional application, Extreme Internet Shopping (EIS), to
provide examples of common application mapping actions. Figure 4-1 shows
Burp Spider running against EIS. Without logging on, it is possible to map out the
/shop directory and two news articles in the /media directory. Also note that
the robots.txt fi le shown in the fi gure references the directories /mdsecportal
and /site-old. These are not linked from anywhere in the application and would
not be indexed by a web spider that only followed links from published content.
TIP Applications that employ REST-style URLs use portions of the URL fi le
path to uniquely identify data and other resources used within the application
cc0044..iinndddd 7744 88//1199//22001111 1122::0044::4411 PPMM