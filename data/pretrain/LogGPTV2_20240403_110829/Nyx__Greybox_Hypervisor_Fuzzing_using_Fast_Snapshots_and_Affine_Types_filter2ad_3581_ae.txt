cursive DMA Requests. NYX uncovered a stack-overﬂow
vulnerability in QEMU’s DMA mechanism used by the
EE100Pro device emulator. The EE100Pro device relies on
the CU (Command Unit) and RU (Receive Unit) to send com-
mands and receive data from its guest. By conﬁguring the CU
base and offset register to point to its own PCI MMIO BAR
with a speciﬁc offset and a write accesses to the command
register thereafter, the device emulator will perform a DMA
write access to the same MMIO register and initiate the same
DMA access again. This will lead to stack exhaustion and a
crash, which can be exploited by a malicious guest.
Case Study: QEMU SDHCI Heap-based Buffer Over-
ﬂow. The SDHCI device performs read and write opera-
tions in blocks. The size of these blocks can be set with
the SDHC_BLKSIZE. Each read and write command moves
the data_count cursor of the data buffer fifo_buffer
forward until the blksize is reached. For larger data, the
SDHC_SYSAD command allows multi-block transfers and starts
at the data_count cursor.
When a new block size is set with the SDHC_BLKSIZE com-
mand, the data_count cursor is not reset and the block size
is also not checked against 0. This allows an attacker to ﬁrst
set a high block size, move the cursor at an arbitrary position,
then set the block size to 0 and issue a multi-block transfer.
The length is calculated as 0 - data_count, which results
in an arbitrary heap out-of-bounds write up to the size of the
uint16_t or the maximum buffer size, whatever is lower.
Coordinated Disclosure.
In total, we reported 44 bugs to
the maintainers. 7 security issues were directly reported to
and acknowledge by the QEMU security team according to
their security process. Currently, the QEMU security team
assigned four CVEs (CVE-2020-25084, CVE-2020-25085,
CVE-2020-25741, CVE-2020-25743) for ﬁxed and published
issues. While in general it is hard to evaluate the exact security
impact of bugs found without actually spending time to write
an exploit, we believe that most memory corruption issues
could be exploited under the right circumstances. Another
15 security issues in bhyve were reported to the FreeBSD
security team with pending CVEs assigned by MITRE.
Other non-critical security issues, such as assertion failures,
were publicly reported through launchpad.net for QEMU
bugs (#1883728, #1883729, #1883732, #1883733, #1883739,
#1525123, #697510, #1681439, #1810000) and the FreeBSD
bug tracker for bhyve ﬁndings.
6 Related Work
In recent years, fuzzing has shown exceptional results on un-
covering bugs in software systems. This trend was started
by a coverage-guided fuzzer named AFL [65]. To improve
upon AFL, a large number of researcher tried to improve
AFL’s input mutation algorithm [1, 2, 27, 40, 43] and its abil-
ity to identify bugs [4, 5, 31, 37, 39, 58]. Other approaches fo-
cused on improving feedback mechanism in coverage-guided
fuzzers [16,19,30,33,57]. Additionally, improved scheduling
algorithms have been researched extensively [8–11, 46, 59].
A more in depth discussion on various recent advances in
fuzzing can be found in Manès et al.’s overview [35].
Next to generic improvement over AFL’s design and imple-
mentation, some research proposed a hybrid software testing
method which combines feedback fuzzing with concolic exe-
cution [20–22, 26, 36, 50, 56, 62, 66]. Similar to the concolic
execution based approaches, others tried to improve fuzzing
by adding taint tracking [14, 45]. Lastly, various researchers
focused on improving the raw throughput of various compo-
nents of modern fuzzers [51, 61].
Snapshots were already used in the context of testing.
AFL’s fork server can be seen as a primitive ring-3 snapshot
mechanism. Dong et al. used snapshots for testing Android
apps [17]. However, their approach takes approximately nine
seconds to restore a single snapshot, rendering them infeasi-
ble for our purposes. Recently, Falk used a similar mechanism
to quickly reset the memory of VMs [18], however that im-
plementation does not support emulated devices.
To apply fuzzing to a wider set of targets, coverage-guided
fuzzers for ring-0 targets were developed [29, 41, 49, 55, 60].
Additionally, some recent research expanded the fuzzing ap-
proach into the IoT and embedded systems domain [15, 34].
Beyond ring-0, fuzzing was also applied to hypervisors [23,
28, 48, 52]. For example, VDF [28] implements a coverage-
guided hypervisor fuzzing approach. Recently, Schumilo et
al. introduced HYPER-CUBE, a blind fuzzer for hypervi-
sors [48]. Various researchers also implemented other blind
hypervisor fuzzers [12, 23, 38, 47].
7 Discussion
In this paper, we describe an approach to fuzz hypervisors us-
ing coverage guidance. The recent success of HYPER-CUBE
put the viability of coverage-guided fuzzing for hypervisors
into question. Our evaluation shows that coverage-guided
fuzzing is indeed working as expected. Consequently, the
fundamental problem behind VDF is not the overhead of
coverage-guided fuzzing per se, but their implementation. A
properly implemented and sufﬁcient optimized whole-system
fuzzer design is capable of outperforming HYPER-CUBE.
However, to this end, current fuzzers need to apply a set of
changes: ﬁrst, we need a way to obtain code coverage from
all code regardless of the protection ring it is running under.
Second, they need to handle the high non-determinism using
fast snapshot reloads. Last, the mutator needs to understand
the interactive nature of the inputs. As the authors of HYPER-
CUBE already noted, coverage-guided fuzzing adds a lot of
value when fuzzing more complex devices.
USENIX Association
30th USENIX Security Symposium    2609
While our approach is versatile and much faster and eas-
ier to use than VDF, and in many cases outperforms even
HYPER-CUBE, it also has some drawbacks: it is slightly more
complex to setup than HYPER-CUBE, as the target hypervisor
needs to run inside KVM-PT. For most hypervisors, this is not
particularly challenging, as KVM-PT fully supports nested
virtualization. However, using nested virtualization allows us
to easily recover from crashes. HYPER-CUBE needs to restart
the whole process after each crash, and typically has a very
hard time to overcome early crashes triggered by overzealous
assert statements.
Creating Speciﬁcations Additionally to running the target
hypervisor in a nested conﬁguration, the user also needs to pro-
vide a speciﬁcation. While we have demonstrated that even
the uninformed speciﬁcation that closely mirrors HYPER-
CUBE’s behavior is already quite useful, most of the times a
more precise speciﬁcation is helpful. Designing a speciﬁca-
tion is quite similar to designing a grammar for well-known
fuzzers such as NAUTILUS [1], PEACH [54], or SULLEY [44].
The biggest part of the effort is not to produce the speciﬁca-
tion, but to obtain a sufﬁcient understanding of the target. In
our case, we spent about two days on our most complex spec-
iﬁcation. Understanding the structures required to perform
VirtIO took by far the biggest amount of work. Writing the
speciﬁcation based on this understanding took only a very
small fraction of the time (around two hours).
Long-Running Interactive Fuzzing Our fuzzer still main-
tains one aspect of current coverage-guided fuzzers: each
small input is tested in isolation after a mutation. It would be
very interesting to explore long-running interactive fuzzing:
instead of generating small inputs outside of the VM, a large
stream could be generated from a given seed inside the target
VM. While the original HYPER-CUBE logic generates inter-
actions within the VM, KVM-PT would observe the coverage
from the outside until new coverage is found.
8 Conclusion
In this paper, we introduced an approach to fuzz highly com-
plex and stateful interactive targets. While this paper focuses
on hypervisor fuzzing as one example of such systems, all
the techniques introduced here work as well to fuzz any other
kind of software. We are convinced that both super fast, full
VM reloads and structured fuzzing of interactive applications
are valuable additions to current fuzzers, no matter of the
target. We have demonstrated how coverage-guided fuzzing
can beat blind fuzzing, even when the blind fuzzer is able to
produce far more interactions per second. While blind fuzzers
such as HYPER-CUBE are conceptually much simpler, and—
if implemented properly—can provide a much larger number
of such interactions, they will struggle to sufﬁciently test the
less common parts of the application. Using fast snapshots
provides near-perfect reproducibility. By using coverage guid-
ance, the hard-to-hit parts of the target are explored much
more thoroughly. As a consequence, we ﬁnd more bugs and
in most cases more coverage while using the same speciﬁca-
tion. Similarly, using our afﬁnely typed bytecode speciﬁcation
format, it becomes simple to generate much more complex
speciﬁcations for any given use case, further increasing the
coverage and number of bugs found.
Acknowledgements We would like to thank our shepherd
Byron Williams and our anonymous reviewers for their valu-
able feedback. This work was supported by the Deutsche
Forschungsgemeinschaft (DFG, German Research Founda-
tion) under Germany’s Excellence Strategy – EXC-2092
CASA – 390781972. In addition, this work was supported
by the European Union’s Horizon 2020 Research and Inno-
vation Programme (ERC Starting Grant No. 640110 (BAS-
TION) and 786669 (REACT)). The content of this document
reﬂects the views only of their authors. The European Com-
mission/Research Executive Agency are not responsible for
any use that may be made of the information it contains.
References
[1] Cornelius Aschermann, Tommaso Frassetto, Thorsten
Holz, Patrick Jauernig, Ahmad-Reza Sadeghi, and
Daniel Teuchert. Nautilus: Fishing for Deep Bugs with
Grammars. In Symposium on Network and Distributed
System Security (NDSS), 2019.
[2] Cornelius Aschermann, Sergej Schumilo, Tim Blazytko,
Robert Gawlik, and Thorsten Holz. REDQUEEN:
Fuzzing with Input-to-State Correspondence. In Sym-
posium on Network and Distributed System Security
(NDSS), 2019.
[3] Muli Ben-Yehuda, Michael D Day, Zvi Dubitzky,
Michael Factor, Abel Gordon, Anthony Liguori, Orit
Wasserman, and Ben-Ami Yassour. The Turtles Project:
Design and Implementation of Nested Virtualization. In
Symposium on Operating Systems Design and Imple-
mentation (OSDI), 2010.
[4] William Blair, Andrea Mambretti, Sajjad Arshad,
Michael Weissbacher, William Robertson, Engin Kirda,
and Manuel Egele. HotFuzz: Discovering Algorith-
mic Denial-of-Service Vulnerabilities Through Guided
In Symposium on Network and Dis-
Micro-Fuzzing.
tributed System Security (NDSS), 2020.
[5] William Blair, Andrea Mambretti, Sajjad Arshad,
Michael Weissbacher, William Robertson, Engin Kirda,
and Manuel Egele. HotFuzz: Discovering Algorith-
mic Denial-of-Service Vulnerabilities Through Guided
Micro-Fuzzing. 2020.
[6] Tim Blazytko, Cornelius Aschermann, Moritz Schlögel,
Ali Abbasi, Sergej Schumilo, Simon Wörner, and
2610    30th USENIX Security Symposium
USENIX Association
Thorsten Holz. GRIMOIRE: Synthesizing Structure
while Fuzzing. In USENIX Security Symposium, 2019.
[7] Sören Bleikertz.
https://
www.openfoo.org/blog/xen-fuzz.html. Accessed:
October 6, 2020.
XenFuzz.
[8] Marcel Böhme, Valentin JM Manès, and Sang Kil Cha.
Boosting Fuzzer Efﬁciency: An Information Theoretic
Perspective. In esec-fse, 2020.
[9] Marcel Böhme, Van-Thuan Pham, Manh-Dung Nguyen,
and Abhik Roychoudhury. Directed greybox fuzzing.
In ACM Conference on Computer and Communications
Security (CCS), 2017.
[10] Marcel Böhme, Van-Thuan Pham, and Abhik Roychoud-
hury. Coverage-based greybox fuzzing as markov chain.
In ACM Conference on Computer and Communications
Security (CCS), 2016.
[11] Sang Kil Cha, Maverick Woo, and David Brumley.
In IEEE Sym-
Program-adaptive mutational fuzzing.
posium on Security and Privacy, 2015.
[12] Amardeep Chana.
MWR-Labs: Ventures
https:
into Hyper-V - Fuzzing hypercalls.
//labs.mwrinfosecurity.com/blog/ventures-
into-hyper-v-part-1-fuzzing-hypercalls/.
Accessed: October 6, 2020.
[13] Amardeep Chana.
https://
github.com/mwrlabs/ViridianFuzzer. Accessed:
October 6, 2020.
Viridian Fuzzer.
[14] Peng Chen and Hao Chen. Angora: Efﬁcient Fuzzing
by Principled Search. In IEEE Symposium on Security
and Privacy, 2018.
[15] Abraham A Clements, Eric Gustafson, Tobias
Scharnowski, Paul Grosen, David Fritz, Christopher
Kruegel, Giovanni Vigna, Saurabh Bagchi, and Mathias
Payer. HALucinator: Firmware Re-hosting Through
In USENIX Security
Abstraction Layer Emulation.
Symposium, 2020.
[16] S. Dinesh S. Dinesh, Nathan Burow, Dongyan Xu, and
Mathias Payer. RetroWrite: Statically Instrumenting
COTS Binaries for Fuzzing and Sanitization. In IEEE
Symposium on Security and Privacy, 2020.
[17] Zhen Dong, Marcel Böhme, Lucia Cojocaru, and Abhik
Roychoudhury. Time-travel Testing of Android Apps.
In icse, 2020.
[18] Brandon Falk. Chocolate Milk. https://github.com/
gamozolabs/chocolate_milk. Accessed: October 6,
2020.
[19] Shuitao Gan, Chao Zhang, Xiaojun Qin, Xuwen Tu,
Kang Li, Zhongyu Pei, and Zuoning Chen. CollAFL:
Path Sensitive Fuzzing. In IEEE Symposium on Security
and Privacy, 2018.
[20] Patrice Godefroid, Adam Kiezun, and Michael Y Levin.
Grammar-based whitebox fuzzing. In ACM SIGPLAN
Conference on Programming Language Design and Im-
plementation (PLDI), 2008.
[21] Patrice Godefroid, Nils Klarlund, and Koushik Sen.
DART: Directed Automated Random Testing. In ACM
SIGPLAN Conference on Programming Language De-
sign and Implementation (PLDI), 2005.
[22] Patrice Godefroid, Michael Y Levin, David A Molnar,
et al. Automated whitebox fuzz testing. In Symposium
on Network and Distributed System Security (NDSS),
2008.
[23] Mikhail Gorobets, Oleksandr Bazhaniuk, Alex Ma-
trosov, Andrew Furtak, and Yuriy Bulygin. Attacking
hypervisors via ﬁrmware and hardware. Black Hat USA,
2015.
[24] Mikhail Gorobets, Oleksandr Bazhaniuk, Alex Ma-
trosov, Andrew Furtak, and Yuriy Bulygin. Attacking
hypervisors via ﬁrmware and hardware. Black Hat USA,
2015.
[25] Samuel Groß. FuzzIL: Coverage Guided Fuzzing for
JavaScript Engines. Master’s thesis, Karlsruhe Institute
of Technology, Karlsruhe, Germany, 2018.
[26] Istvan Haller, Asia Slowinska, Matthias Neugschwandt-
ner, and Herbert Bos. Dowsing for Overﬂows: A Guided
Fuzzer to Find Buffer Boundary Violations. In USENIX
Security Symposium, 2013.
[27] HyungSeok Han, DongHyeon Oh, and Sang Kil Cha.
CodeAlchemist: Semantics-Aware Code Generation to