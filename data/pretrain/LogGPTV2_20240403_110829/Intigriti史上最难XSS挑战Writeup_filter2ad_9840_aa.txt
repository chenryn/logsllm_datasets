# Intigriti史上最难XSS挑战Writeup
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 0x00 前言
Intigriti xxs challenge 0421 被官方自己被评价为目前为止 **Intigriti史上最难的 XSS 挑战**
。在有效提交期内，全球参与的 hacker、CFTer、Bugbounty hunter 仅有15人成功通过挑战拿到flag。
该挑战由@terjanq根据他在漏洞挖掘中绕过的真实场景下的waf规则所编写。挑战地址：
，以下要求：
  * 使用最新版的Firefox或者Chrome浏览器
  * 使用`alert()`弹窗`flag{THIS_IS_THE_FLAG}`
  * 利用此页面的xss漏洞
  * 不允许self-XSS 和 MiTM 攻击
  * 无需用户交互
本人也在提交期内对该挑战进行了尝试，对整个网页以及背后的waf逻辑进行了分析研究，但无奈菜狗一枚，未能在有效提交期内通关。通过赛后公布的poc，对个人思路和通关思路进行复盘，形成本WP，供共同学习交流。感兴趣的小伙伴也可以自行尝试，感受该XSS挑战的难度和乐趣！
## 0x01 代码分析
对题目网页进行分析，主要包括网页源码`(index)`和一个`waf.html`([https://challenge-0421.intigriti.io/waf.html)。](https://challenge-0421.intigriti.io/waf.html\)%E3%80%82)
（index）
          Intigriti April Challenge
                Error: something went wrong. Please try again!
               Intigriti's 0421 XSS challenge - by @terjanq
                Find a way to execute arbitrary javascript on this page and win Intigriti swag.
                Rules:
                   This challenge runs from April 19 until April 25th, 11:59 PM CET.
                      Out of all correct submissions, we will draw six winners on Monday, April 26th:
                         Three randomly drawn correct submissions
                         Three best write-ups
                   Every winner gets a €50 swag voucher for our swag shop
                   The winners will be announced on our Twitter profile.
                   For every 100 likes, we'll add a tip to announcement tweet.
                The solution...
                   Should work on the latest version of Firefox or Chrome
                   Should alert() the following flag: flag{THIS_IS_THE_FLAG}.
                   Should leverage a cross site scripting vulnerability on this page.
                   Shouldn't be self-XSS or related to MiTM attacks
                   Should not use any user interaction
                   Should be reported at go.intigriti.com/submit-solution
waf.html
    onmessage = e => {
        const identifier = e.data.identifier;
        e.source.postMessage({
            type:'waf',
            identifier,
            str: e.data.str,
            safe: (new WAF()).isSafe(e.data.str)
        },'*');
    }
    function WAF() {
        const forbidden_words = ['
代码量不大，运行逻辑也很清晰。在主页中可以看到，首先定义了一个随机值`identifier`:
可以在url中引入`error`参数进行有关输入，也能进行html injection：
输入值会通过`postMessage`传递给`waf`，该消息`e.data.indentifier`的值为先前生成的随机值，确保交互通信没有被拦截，`e.data.str`的值为我们的输入:
输入值经过waf的处理后，会对不安全的输入中的各种字符进行检查，经过处理后对`e.data.safe`打上值，认定输入是否是安全的。当`safe:true`时，通过`htmlError()`方法在页面上通过`innerHTML`
`innerText` 显示有关错误信息，可以用于payload的触发。此外，错误信息会在10秒后被删除：
此外，该页面响应头还`X-Frame-Options: DENY` ，无法通过外部的``引用：
下面，对`waf.html`进行分析。waf 规则对一些特殊标签和字符进行了限制：
    [' （4.19）First hint: find the objective!  
>  （4.20）Time for another hint! Where to smuggle data?  
>  （4.20）Time for another tip! One bite after another!  
>  （4.20）Here’s an extra tip: ++ is also an assignment  
>  （4.22）Let’s give another hint:”Behind a Greater Oracle there stands one
> great Identity” (leak it)  
>  （4.23）Tipping time! Goal   （4.24）Another hint: you might need to unload a custom loop!
这里先卖个关子，先不对hits 背后隐藏线索进行解释。感兴趣的小伙伴可以自行尝试，看看能不能通关这个XSS挑战。
结合上面的代码分析，我有了以下思路:
1.寻找一个可以绕过waf 的payload  
2.通过`postMessage` 构造合适的消息，达成触发xss的条件  
3.突破`identifier`随机值的限制
首先考虑如何绕过waf。由于通过`error`参数值作为的输入需要经过waf的检测，通过前面的分析，waf对很多标签和字符进行了禁止，用于限制恶意代码的执行，可以说规则还是很严格的，很多常用XSS
payload 构成方式都不能使用。`'` `"` ` 被禁止，所以JS字串形式无法使用，`[]` `{}` `()` `=`
被禁止，通过函数赋值的形式也无法使用。此外，`X-Frame-Options:
DENY`的限制，使得我们无法通过``外部引用执行xss，所以思路转向能能够通过输入，在网页内部嵌入一个外部的恶意站点，用来触发xss。此外，我也发现了`onXXX=`事件可以被插入到输入中，并不被禁止。沿着这两个条件分析，进行了大量的测试，最终发现如下形式的payload可以绕过waf的检测。
这里使用了``标签（不在waf的禁止范围内），它用于引入一个外部资源:
尝试插入我的头像，成功：
尝试插入一个外部网页，成功
下面，验证通过`window.postMessage`控制消息值，达到触发xss的条件。按照这个思路，验证self-xss可行性。可以看到当我们的输入经过waf处理后，`e.data.type='waf'` `e.data.identifer='(事先生成的随机值)''`
`e.data.str='payload'` `e.data.safe='true'or 'false'`：
从前面的分析可以知道，只有`safe=true`时，构造的payload才能被赋值给`div.innerHTML`。结合上述条件，这里构造消息信息如下，传递时为`e`，即可绕过waf的过滤检测：
    window.postMessage({
            type: 'waf',
            identifier: "tze8f445ssb7",
            str: '',
            safe: true
          }, '*')
通过`postMessage`触发xss的思路可行，仅在self-xss条件下可行，因为`identifier`的值是随机生成的，需要突破该限制。
截止目前，我的思路整理如下：
  * 绕过waf （构造形如``的payload可以bypass waf，同时`onXXX=`没有被禁止，可以加载外部页面 ）
  * 通过`postMessage`触发xss（self-xss验证可行，可以通过外部页面发送消息）
  * 突破`identifier`随机值的限制
为了突破`identifier`随机值的限制，我首先想到的是能不能像 **SQLi 盲注那这样通过特定的反馈，将值一位一位的试出来**
。由于`identifier`是本站生成的，如何在跨站的条件下降该值泄露出来，是关键点的思路。此外，我还发现了一些有趣的点：
`window.neme=""` 可能可以利用，通过特殊方式的将泄露出的字段写入`top.name`中。
为了能将`identifier`一位一位泄露出来，需要构造比较。它的构成只包含`0-9a-z`：
那么如何判断每一位值是多少呢，这有由于禁止`[]`，所以无法使用`identifier[i]`的形式来构造字串进行按位比较。不过我们可以利用以下的规律：
可以看到这里`identifier="tze8f445ssb7"`
第一位是`t`，当比较字符小于`t`时，均返回`false`，当比较字符为`u`时，返回`true`，由此我们可以判定第一位为`t`。保留`t`，继续构造第二位`t?`进行比较：
那么按照这个规律，构造循环进行比较，当每次返回`true`时，即可判断出当前位的值，同时还需要对前面确定的值保存，才能继续判断下一位。我的思路是通过特定的方法构造这个循环，并通过`window.neme=""`可以利用的特性，当一个中间的数据”寄存器”。
首先，为了推算`identifier`第一位，构造如下结构payload：
    error=#
这里，当`location.hash+/0/.source %26%26` `++ -->
%2b%2b`)，还需要额外添加`~`用来检测`z`：
    https://challenge-0421.intigriti.io/
    ?error=#
可以看到，该payload成功定位到`identifier`的第一位值。现在需要构造循环，通过13次上述操作（长度为13位），将`identifier`的值全部泄露出来，每个循环开始前还需要将`window.name`归零。
当我们将外部POC页面嵌入题目页面后，尝试利用POC页面获取`top.name`来控制题目页面`window.name`的时候，发现跨域拦截：