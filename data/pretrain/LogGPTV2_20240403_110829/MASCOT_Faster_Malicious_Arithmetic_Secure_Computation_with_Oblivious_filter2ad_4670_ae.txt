to achieve at least 64 bit statistical security. We observe that as k increases, the cost of inputs
scales almost exactly quadratically. For triples, k = 64 is slightly less eﬃcient as we require τ = 4
(instead of 3), whilst for larger k the cost reduces slightly as k becomes much larger than λ. Note
also that the cost of an input is much lower than a triple, as the input protocol does not require
any of the expensive sacriﬁcing or combining that we use to obtain active security with triples.
This is in contrast to the SPDZ protocol [16, 18], where creating input tuples requires complex
zero-knowledge or cut-and-choose techniques.
Comparison with a passive protocol. A passively secure (or semi-honest) version of our
protocol can be constructed by setting τ = 1 and removing the authentication step, saving 5 calls
to ΠCOPEe for every pair of parties. Note that for two parties this is essentially the same as the
protocol in ABY [19]. The communication cost of a single triple is then n(n− 1)(λk + k2) bits. For
triples where k ≥ 128, and 64-bit statistical security, the actively secure protocol achieves τ = 3,
so is just 5.5 times the cost of the passive variant.
7.2 Implementation
As part of our implementation, we have used the optimizations described below. The ﬁrst two
apply to the OT extension by Keller et al. [28].
22
Field bit length
64
128
256
512
Input cost (kbit)
4.16(n − 1)
16.51(n − 1)
65.79(n − 1)
262.66(n − 1)
Triple cost (kbit)
53.25n(n − 1)
180.22n(n − 1)
622.59n(n − 1)
2293.76n(n − 1)
Table 2: Communication cost of our protocols for various ﬁeld sizes, with n parties.
Bit matrix transposition. Asharov et al. [2] mention the bit matrix transposition as the most
expensive part of the computation for their OT extension. They propose Eklundh’s algorithm
to reduce the number of cache misses.
Instead of transposing a matrix bit by bit, the matrix
is transposed with respect to increasingly small blocks while leaving the blocks internally intact.
Keller et al. also use this algorithm.
However, for security parameter λ, the OT extension requires the transposition of a n × λ-
matrix. We store this matrix as list of λ × λ-blocks, and thus, we only have to transpose those
blocks. For λ = 128, one such block is 2 KiB, which easily ﬁts into the L1 cache of most modern
processors.
Furthermore, we use the PMOVMSKB instruction from SSE2.
It outputs a byte consisting
of the most signiﬁcant bits of 16 bytes in a 128-bit register. Together with a left shift (PSLLQ),
this allows a 16 × 8-matrix to be transposed [35] with only 24 instructions (eight of PMOVSKB,
PSLLQ, and MOV each).
Pseudorandom generator and hashing. Keller et al. [28] used AES-128 in counter mode
to implement the PRG needed for the OT extension. This allows to use the AES-NI extension
provided by modern processors. We have also implemented the hash function using AES-128 by
means of the Matyas–Meyer–Oseas construction [34], which was proven secure by Black et al. [7].
This construction uses the compression function hi = Eg(hi−1)(mi)⊕ mi, where mi denotes the i-th
message block, hi is the state after the i-th compression, and g denotes a conversion function. In
our case, the input is only one block long (as many bits as the computational security parameter
of the OT extension), and g is the identity. This gives a hash function H(m) = EIV (m) ⊕ m for
some initialization vector IV , which allows to precompute the key schedule. This precomputation
in turn allows to easily take advantage of the pipelining capabilities of AES-NI in modern Intel
processors: While the latency of the AESENC instruction is seven clock cycles, the throughput is
one per clock cycle [24]. This means that the processor is capable of computing seven encryptions
in parallel.
Inner product computation. Both ΠCOPEe and ΠTriple involve the computation of (cid:104)g, x(cid:105) for
x ∈ Flog |F|. Elements of both F
2k and Fp are commonly represented as elements of larger rings
(F2[X] and Z, respectively), and some operations involves a modular reduction (modulo an irre-
ducible polynomial or p). When computing, we defer this reduction until after computing the sum.
Furthermore, we use the mpn_* functions of MPIR [42] for the large integer operations for Fp. For
F
2k on the other hand, the computation before the modular reduction is straightforward because
addition in F2[X] corresponds to XOR.
23
In order to make optimal use of resources, we have organized the triple gener-
Multithreading.
ation as follows: There are several threads independently generating triples, and every such thread
controls n − 1 threads for the OTs with the n − 1 other players. Operations independent of OT
instances, such as ampliﬁcation and sacriﬁcing, are performed by the triple generation threads.
We found that performance is optimal if the number of generator threads is much larger than the
number of processor cores. This is an indication that the communication is the main bottleneck.
7.3 Experiments
We have tested our implementation for up to ﬁve parties on oﬀ-the-shelf machines (eight-core i7
3.1 GHz CPU, 32 GB RAM) in a local network. Fig. 9 shows our results.
F
2k, 1 thread
F
2k, 10 threads
F
2k, 100 threads
Fp, 100 threads
5,000
4,000
3,000
2,000
1,000
)
s
/
(
t
u
p
h
g
u
o
r
h
T
0
2
3
4
Number of parties
5
Figure 9: Triple generation throughput for 128-bit ﬁelds.
We could generate up to 4800 and 1000 F2128 triples per second with two and ﬁve parties,
respectively, using 100 threads. For Fp with p a 128-bit prime, the ﬁgures are the same. These
ﬁgures come close to the maximum possible throughput of the correlation steps, which is 5500 and
1400, respectively. The maximum ﬁgures are computed from the analysis above, with τ = 3 and
k = λ = 128. Assuming a 1 Gbit/s link per party and unlimited routing capacity gives the desired
result.
Using just a single thread, we can produce 2000 triples/s with two parties, which is still over
72 times faster than the single-threaded implementation of SPDZ [16].
By increasing the bandwidth to 2 Gbit/s, we could increase the throughput to 9500 and 1600
triples per seconds for two and ﬁve parties, respectively. This conﬁrms the observation that the
communication is the main bottleneck. Fig. 10 shows the throughput for two parties in various
network environments. The WAN environment was simulated over a LAN by restricting bandwidth
to 50 Mbit/s and a round-trip latency of 100 ms.
7.3.1 Vickrey Auction
To highlight the practicality of our protocol, we have implemented the Vickrey second-price auction.
Figure 11 shows the results for the oﬄine and online phase run between two parties on a local
24
1.2
1
0.8
0.6
0.4
0.2
0
)
s
/
(
t
u
p
h
g
u
o
r
h
T
·104
11,000
9,515
5,500
4,828
241
275
50Mbps WAN 1Gbps LAN 2Gbps LAN
Actual Max. possible
Figure 10: Throughput and maximum possible throughput for diﬀerent networks with two parties
network. This clearly illustrates the 200-fold performance improvement of our protocol, compared
with (actively secure) SPDZ. Now the preprocessing phase in within 2–3 orders of magnitude of
the online phase.
Acknowledgements
We thank Claudio Orlandi and the anonymous reviewers for valuable feedback that helped to
improve the presentation.
References
[1] The Sharemind project. http://sharemind.cs.ut.ee, 2007.
[2] Asharov, G., Lindell, Y., Schneider, T., and Zohner, M. More eﬃcient oblivious
transfer and extensions for faster secure computation. In Proceedings of the 2013 ACM SIGSAC
conference on Computer & communications security (2013), ACM, pp. 535–548.
[3] Baum, C., Damg˚ard, I., Toft, T., and Zakarias, R. Better preprocessing for secure
multiparty computation. IACR Cryptology ePrint Archive (2016).
[4] Beaver, D. Eﬃcient multiparty protocols using circuit randomization. Advances in Cryptol-
ogy - CRYPTO 1991 (1992).
[5] Beaver, D. Correlated pseudorandomness and the complexity of private computations.
In Proceedings of the Twenty-Eighth Annual ACM Symposium on the Theory of Computing
(1996), G. L. Miller, Ed., ACM, pp. 479–488.
25
s
d
n
o
c
e
s
n
i
e
m
T
i
104
102
100
10−2
100
101
102
103
Number of bids
SPDZ oﬄine phase
MASCOT oﬄine phase
Online phase
Figure 11: Vickrey auction run by two parties.
[6] Bendlin, R., Damg˚ard, I., Orlandi, C., and Zakarias, S. Semi-homomorphic encryp-
tion and multiparty computation. In Advances in Cryptology - EUROCRYPT 2011 (2011),
pp. 169–188.
[7] Black, J., Rogaway, P., Shrimpton, T., and Stam, M. An analysis of the blockcipher-
based hash functions from PGV. J. Cryptology 23, 4 (2010), 519–545.
[8] Bogdanov, D., J˜oemets, M., Siim, S., and Vaht, M. How the Estonian tax and customs
board evaluated a tax fraud detection system based on secure multi-party computation. In
Financial Cryptography and Data Security - 19th International Conference, FC 2015, Revised
Selected Papers (2015), pp. 227–234.
[9] Bogdanov, D., Kamm, L., Kubo, B., Rebane, R., Sokk, V., and Talviste, R. Students
IACR Cryptology
and taxes: a privacy-preserving social study using secure computation.
ePrint Archive (2015).
[10] Burra, S. S., Larraia, E., Nielsen, J. B., Nordholt, P. S., Orlandi, C., Orsini,
E., Scholl, P., and Smart, N. P. High performance multi-party computation for binary
circuits based on oblivious transfer. Cryptology ePrint Archive, Report 2015/472, 2015. http:
//eprint.iacr.org/.
[11] Canetti, R. Universally composable security: A new paradigm for cryptographic protocols.
In 42nd Annual Symposium on Foundations of Computer Science, FOCS (2001), pp. 136–145.
[12] Carter, L., and Wegman, M. N. Universal classes of hash functions. J. Comput. Syst.
Sci. 18, 2 (1979), 143–154.
26
[13] Chou, T., and Orlandi, C. The simplest protocol for oblivious transfer. In Progress in
Cryptology - LATINCRYPT 2015 - 4th International Conference on Cryptology and Informa-
tion Security in Latin America (2015), pp. 40–58.
[14] Damg˚ard, I., Damg˚ard, K., Nielsen, K., Nordholt, P. S., and Toft, T. Conﬁdential
benchmarking based on multiparty computation. In Financial Cryptography (2016).
[15] Damg˚ard, I., Keller, M., Larraia, E., Miles, C., and Smart, N. P.
Implement-
ing AES via an actively/covertly secure dishonest-majority MPC protocol. In SCN (2012),
I. Visconti and R. D. Prisco, Eds., vol. 7485 of Lecture Notes in Computer Science, Springer,
pp. 241–263.
[16] Damg˚ard, I., Keller, M., Larraia, E., Pastro, V., Scholl, P., and Smart, N. P.
Practical covertly secure MPC for dishonest majority - or: Breaking the SPDZ limits.
In
ESORICS (2013), J. Crampton, S. Jajodia, and K. Mayes, Eds., vol. 8134 of Lecture Notes in
Computer Science, Springer, pp. 1–18.
[17] Damg˚ard, I., and Orlandi, C. Multiparty computation for dishonest majority: From
passive to active security at low cost. In Advances in Cryptology - CRYPTO (2010), pp. 558–
576.
[18] Damg˚ard, I., Pastro, V., Smart, N. P., and Zakarias, S. Multiparty computation
from somewhat homomorphic encryption. In Advances in Cryptology – CRYPTO 2012 (2012),
R. Safavi-Naini and R. Canetti, Eds., vol. 7417 of Lecture Notes in Computer Science, Springer,
pp. 643–662.
[19] Demmler, D., Schneider, T., and Zohner, M. ABY - A framework for eﬃcient mixed-
In 22nd Annual Network and Distributed System
protocol secure two-party computation.
Security Symposium, NDSS (2015), The Internet Society.
[20] Frederiksen, T. K., Keller, M., Orsini, E., and Scholl, P. A uniﬁed approach to
MPC with preprocessing using OT. In Advances in Cryptology – ASIACRYPT 2015, Part
I (2015), T. Iwata and J. H. Cheon, Eds., vol. 9452 of Lecture Notes in Computer Science,
Springer, pp. 711–735.
[21] Gilboa, N. Two party RSA key generation. In Advances in Cryptology - CRYPTO (1999),
pp. 116–129.
[22] Goldreich, O., Micali, S., and Wigderson, A. How to play any mental game or A