2009-0658
2009/06/11
2010/04/02
2010/05/06
2009-0927
2009-0927
2007-5659
2009-1129
2009/10/15
2009-1862
2010/05/10
2010/01/04
2010/11/29
2010/04/28
2010/11/18
2010/10/08
2011/01/07
2009-3129
2009-4324
2009-4324
2009-0927
2008-2992
2010-0188
2010-1297
2010-2883
2010-3654
Ext
ppt
doc
doc
doc
pdf
xls
pdf
pdf
doc
pdf
pdf
pdf
ppt
pdf
xls
pdf
pdf
Stop
Files Written
YES
temp\svochost.exe
YES
temp\lsass.exe
YES
temp\svohost.exe
temp\taskmgr.exe
YES
system\32wumsvc.dll YES
YES
temp\XLS.exe
YES
Temp\1.exe
Temp\ews.exe
YES
YES
temp\svchost.exe
system32\
YES
authomal.exe
funparams.exe
temp\svchosts.exe
YES
YES
system32\dxmfnt.exe YES
system32\dxmgnt.exe
system32\
authomal.exe
temp\wuauclt.exe
temp\1.exe
c:\a.exe
YES
YES
YES
YES
pdf Microsfot\
AdobeARM.exe
java.exe
pdf
pdf
Temp\AcroRd32.exe
pdf windows\update.exe
YES
YES
YES
YES
Table 2: Live Malware Exploits/Samples Tested on a system
with CodeShield. CodeShield blocked all of the samples we
tested. For space, we only specify the last parts of the paths.
Table 2 shows an analysis of 22 different exploits and a corre-
sponding attack. We limit our reporting to a single instance per
exploit, but all instances of an exploit that we tested were blocked
successfully. We tested 175 pdf samples that utilized various ex-
ploits, we were able to trigger the attack in 141 (80%) of those
samples. Of those 141 samples, we blocked 100%. The reason
for our inability to trigger all the attacks could be due to several
things, including version differences between the exploit and our
software, patches applied to our system, or lack of network con-
nectivity on our test machine. Overall this shows the effectiveness
of CodeShield mechanism in blocking real world attacks on end
user systems.
5.3 Possibilities of Evading CodeShield
If the approach CodeShield uses is widely deployed, it would
motivate the attackers to ﬁnd ways to evade it. We now discuss
such possibilities.
Given that CodeShield adds new code that is executed during the
installation mode on the whitelist, an attacker may attempt to com-
promise an existing process, store payloads on disk and wait until
the system is in the installation mode to execute. For example, the
malicious code may keep trying to load the stored program until it
succeeds. CodeShield’s reboot-to-enter-installation design can stop
this attack. The reboot mechanism delays entering into installation
mode until the system is up, the client is connected, and the user re-
sponds. So anything that tried to load early in the boot process will
be blocked if it is not on the whitelist. To succeed, the malware has
to change the start conﬁguration ﬁles in a way that loads a malware
program with a certain delay after system reboot. If such conﬁgu-
ration changes are possible, then CodeShield needs to be enhanced
to prevent auto-loading of programs when in installation mode.
An attacker may try to compromise the private key of some
trusted vendors and sign the malware. Indeed, evidence has shown
that some vendors with legitimate certiﬁcates can be malicious,
and certiﬁcates owned by non-malicious vendors can be compro-
mised [13]. While all security mechanisms that use public keys
suffer from this threat, we point out that CodeShield’s design makes
it less vulnerable than many other mechanisms. For example, Mi-
crosoft Windows and Android use a public key infrastructure in
which a software vendor can get a certiﬁcate from one of the Cer-
tiﬁcate Authorities (CAs), often with a small payment, and then
sign its own programs. Every machine trusts any software signed
by any vendor with a valid certiﬁcate.
In essence, all machines
use the same global whitelist of certiﬁcates, and the list is often
very big. In CodeShield, each host trusts only the certiﬁcates from
which one has already installed softwares, instead of all vendor
certiﬁcates. Hence the impact of such attacks is limited unless the
attacker is able to compromise the private key of a popular vendor
(such as Microsoft or Adobe), which is a serious threat whether
CodeShield is there or not.
We note that any attack that does not need to write ﬁles to disk
to achieve its attack objective is not prevented by CodeShield, as
CodeShield is designed to prevent a persistent compromise of a
system by preventing unintended binary execution. Therefore, if an
attack ﬁrst exploits a vulnerability in the system and gains admin
privilege without loading no binary, the attack can try to disable
CodeShield.
Currently CodeShield blocks the execution of binary programs.
We focus on binary programs because today’s malware programs
come in binary form. The attacker can try to deliver malware pay-
loads using intermediate code or script code such as Jar ﬁles, .NET
CIL ﬁles, Python scripts, etc. This is a limitation for the current
implementation of CodeShield. We point out that the same limi-
tation applies to all application whitelisting approaches. Also, the
concept of preventing the loading of external code can be applied to
other forms of code. One could extend the implementation to iden-
tify the runtime environment for these types of intermediate ﬁles,
and control their loading events.
6. EXPERIENCES USING CODESHIELD
As of June 2012 CodeShield has been used on 65 machines,
many for 6 weeks, and others for several months. The longest us-
age is on the laptop of an author of the paper, which has been run-
ning different versions of CodeShield for about 11 months, with
the most recent version being used continuous for 203 days until
the time of writing this paper. Other users include friends/family
of the authors, other researchers, and 38 college students who par-
ticipated in a 6-week user study. The user study was completed in
November 2011. Among the 38 participants, 7 have been continu-
ously using CodeShield until the time of writing this paper, which
is 3 months after the study has completed. Among the 7 partic-
ipants, 5 were using a version of CodeShield where rebooting is
the only way to enter installation mode. From these experiences,
we learned that the key to the success of CodeShield is the ability
to handle software updates smoothly. If programs from software
updates can be automatically added to the whitelist, without the
need to use installation mode, then the inconvenience caused by
CodeShield is minimal. In fact, for the two longest users, one en-
tered the installation mode 8 times in 203 days, and another entered
the installation mode 13 times in 168 days. In computers used by
family/friends of the authors, we often observe the pattern of going
for weeks without the need to enter the installation mode.
Many programs that frequently update themselves digitally sign
all new binaries, resulting in a smooth experience for CodeShield
285
users. These include software from vendors such as Google,
Mozilla, Adobe, and so on. We also note that the behavior of Fire-
fox update changed at some point between March 2011 and the
summer of 2011. In March 2011, Firefox auto-updates resulted in
unsigned DLLs that were blocked by CodeShield. At ﬁrst, denying
the loading of these DLLs did not cause noticeable differences. (In
fact, a somewhat unexpected lesson we learned is that many ap-
plications can survive the block of some DLLs.) However, once
Firefox autoupdated to Firefox 4 in March 2011, failure to load
these unsigned DLLs caused Firefox to have strange appearances,
and we had to enter installation mode and run Firefox to add those
DLLs to the whitelist. Since Firefox 4 in March 2011, however,
all binary ﬁles created by Firefox auto-updater are signed. Firefox
has been updated to Firefox 10, and CodeShield handled all sub-
sequent updates seamlessly. This is one anecdotal evidence that
frequently-updated softwares are increasingly signing the updated
ﬁles.
We now discuss the experiences we have had when updates may
introduce unsigned binaries.
First, Microsoft’s automatic updates may create unsigned ﬁles.
From a security researcher at Microsoft Research, we learned that
Microsoft has an internal mechanism to verify the integrity of such
unsigned binary ﬁles, the interface is currently not available to other
developers, but may become available in the future. CodeShield
currently does not have access to such an interface. To avoid
blocking these Microsoft programs, we currently add three excep-
tion rules for wuauclt.exe, Windows auto update checker, trustedin-
staller.exe, Windows trusted installer, and drvinst.exe, which han-
dles plug and play driver installations.
Second, there are several anti-virus vendors that do not sign all
the code they distribute. It’s likely that they are also using their pro-
prietary mechanism to verify the integrity of these ﬁles; however,
CodeShield is unable to tell and will block these ﬁles. Entering in-
stallation mode on a daily basis to allow the update to occur would
cause an unacceptable overhead. The solution we chose during the
user study was to add additional trusted installers to CodeShield
for these A/V products. This allowed the A/V software to update
smoothly, and not force the users to frequently enter installation
mode. This affects our user study results. Before the study, we
emailed the participants to provide to us their A/V product name,
and test whether their update result in unsigned binary ﬁles, in
which case we need to add exceptions for them. Some users, how-
ever, did not respond to our query and did not contact us during the
study; thereby having to enter installation mode frequently to deal
with A/V updates.
The ﬁnal unexpected issue was related to gaming, which we dis-
covered only after receiving the study results. There are game ser-
vices such as Steam and EA Origin that update frequently with un-
signed ﬁles. This caused the users who played certain games to en-
ter installation mode much more frequently. This skewed the data
in both groups as it forced them to enter installation mode before
playing the game, which some users do almost every day. However
this overhead didn’t seem to effect their gaming, rather just caused
them to enter installation mode more often.
We point out that if CodeShield or something similar is inte-
grated into the OS, or a major A/V product, this can start an ecol-
ogy change towards motivating software vendors to digitally sign
all their binary programs, just like the introduction of UAC moti-
vated developers to request elevated privileges less often. Signing
all code that one distributes is feasible, as this is already done by
many vendors. Also, this is a requirement for many mobile plat-
forms already, and the next generation of Windows is heavily tilted
towards mobile platforms.
7. USABILITY EVALUATION
We have conducted a user study to evaluate the usability
of CodeShield.
In the study, participants were asked to run
CodeShield on their primary laptop for 6 weeks. We recruited 38
participants by posting multiple ﬂyers on campus and offering cash
payment for participation. The participants came from the student
population, and due to the fact that the ﬂyers were spread out in
buildings that housed different disciplines, the participants’ back-
ground were varied. They include not just engineers and scientists,
but many liberal arts students, hospitality management students,
and other non technical ﬁelds.
We divided the participants into two groups. There were 20
participants in the Reboot Only Group (reboot group); they were
given the design which made the user reboot to enter installation
mode. There were 18 participants in the Reboot or Switch Group
(switch group); they were given a version of CodeShield that had
two mechanisms to enter installation mode; reboot into installation
mode or switch directly into installation mode. We compare data
from the two groups to evaluate the design of requiring a reboot to
enter installation mode.
There were 13 training sessions across four days, each session
lasting about 30 minutes. Participants were assigned to sessions
based on when they entered the study. Participants in each session
were assigned to the same group, and we alternate the sessions be-
tween group 1 and 2 to balance the number of users in each group.
During the training session CodeShield was explained and demon-
strated, performing tasks such as installing new software, updating
existing software, and what to watch out for if an attack did occur.
The participants then installed CodeShield on their laptops, took
a brief survey, and began to use their system which was now run-
ning CodeShield. After 6 weeks a ﬁnal survey was automatically
presented and we collected their logs and survey results via online
submission through the client.
The initial survey collected basic demographic information from
the users. All but one user was between the ages of 18-25, the
other was 25-35. We asked the users to describe their technical
level, 26 stated that they are “proﬁcient with computers”, 6 use
their computer “just for email and internet, not much else”, and
3 considered themselves to be a “programmer or expert”. There
were no security experts. Laptops are for ‘personal’ and ‘school’
use, and about half of these machines are also used for ‘work’.
Regarding the age of machines, 19 laptops were more than 1 year
old, 7 were 6 months-12 months, 3 were 2 months-6 months, and 6
were less then 2 months. All but 6 of these machines were used by
a single user. 4 users admit to ignore/disabling update prompts.
The CodeShield program logged all code that was blocked, num-
ber of times that a user entered installation mode and how they en-
tered (reboot or direct switch), all major code that was executed
(just exes, not dlls), all critical writes (writes to a dll/exe/sys ﬁle),
system start and shutdown events, and what digital signatures were
trusted by CodeShield, and therefore by their system.
Two participants’ log ﬁles were deleted for unknown reasons and
were therefore useless. One other participant never submitted their
results. All three belong to the switch group. Hence we are report-
ing 35 users’ data, with 20 users in the reboot group, and 15 users
in the switch group.
Among the 15 users in the switch group, two had log data for
about four weeks, rather than six weeks. One participant terminated
the study after about one month. He reported that his laptop did
not boot, and thought it was due to CodeShield. He then reported
that the problem went away after reseating the memory chips in his
laptop; but after a few days, he decided to withdraw from the study.
He nonetheless submitted his log and completed the ﬁnal survey.
Another user dropped his laptop about one month into the study.
However, he submitted his log periodically, hence we have about
1 month of his data; he later took a separate ﬁnal survey, enabling
us to include his data. While it is unlikely that all ﬁve problem
users come from the switch group, by chance, this is exactly what
happened.
7.1 User Study Results
While we were conﬁdent about
the design philosophies of
CodeShield, and tested extensively before the user study, we were
somewhat concerned about how the actual user experiences would
turn out during the 6-week study. As discussed in Section 6,
some software updates introduce unsigned ﬁles that are blocked.
CodeShield is an intrusive security mechanism in that it can pre-
vent any binary from loading and changes how the user interacts
with the system. If unexpected events occur in the user’s behavior
or in software he or she is using, then the system could become
quite difﬁcult to interact with. So the possibility of running a busy
help desk for six weeks or dealing with potentially disastrous sys-
tem freezes existed, as it turned out however the user study ran
smoothly.
Table 3 presents the summary results for two groups. First we
note that the number of times users enter installation mode var-
ied, but users in the switch group enter installation mode much
more frequently due to the ease with which they could switch. The
max for the switch group was 41, caused by a game that frequently
writes unsigned binaries. There were several other participants in
the switch group who enter installation mode many times (e.g., 33,
28, 27). The max for the reboot group was 30; this participant failed