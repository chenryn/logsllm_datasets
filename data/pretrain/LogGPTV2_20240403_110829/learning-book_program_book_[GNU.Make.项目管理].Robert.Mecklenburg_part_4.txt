Makefile的基本语法
对make有了基本的认识之后，现在你差不多可以编写自己的makefile了。这一节我们
将会介绍makefile的基本语法和结构，让你得以开始使用make。
）
作目标（通常叫做a11）。下层工作目标用来让上层工作目标保持在最薪的状态，例如，
用来删除无用的临时文件的clean工作目标应该放在最下层。正如你所猜测的，工作目
标的名称并不一定非得是真实的文件名称不可，你可以使用任何名称。
在前面的范例中我们所看到的是经过简化的规则。下面是较完整（但可能仍然不够完整）
的规则：
target1 target2 target3:prerequisite1prerequisite2
commandl
command3
如果冒号的右边没有指定必要条件，那么只有在工作目标所代表的文件不存在时才会进
行更新的动作。更新工作目标所要执行的那组命令有时会被称为命令脚本（command
script），不过通常只被称为命令（command）。
每个命令必须以跳格符（tabcharacter）开头，这个（隐含的）语法用来要求make将
紧跟在跳格符之后的内容传给subshell来执行。如果你不经意地在非命令行
（noncommandline）的第一个字符前插入了一个跳格符，则在大多数情况下，make将
会把其后的文字作为命令来解释。如果你很幸运，这个误人歧途的跳格符将被视为语法
错误，那么你会因此收到如下的信息：
Smake
Makefile:6:***commands commence before first target.Stop
我们将会在第二章“规则”中讨论错综复杂的跳格符。
的所有文字都会被make忽略。你可以对作为注释的文本行进行缩排或前置空格。注释
字符#并不会在代表命令的文本行中引l人make的注释功能，这一整行（包括#及其后
的字符）会被传给shell来执行。这行文字的处理方式取决于你所使用的shell。
你可以使用标准的Unix转义字符（escapecharacter）一一反斜线（\），来延续过长的
文本行。反斜线一般用来延续过长的命令，也可用来延续必要条件。稍后我们将会探讨
处理过长必要条件的其他方法。
---
## Page 28
18
第一章
你现在已经有能力编写简单的makefile了。接下来我们将会在第二章探讨规则的细节，
在第三章探讨make变量以及在第五章探讨命令。所以现在你应该避免使用变量、宏以
及多行命令。
---
## Page 29
第二章
规则
前一章中，我们编写了若干规则，用来编译与链接我们的单词计数（wordcounting）程
序。我们为每个规则定义了一个工作目标，也就是一个需要更新的文件。每个工作目标
依存于一组必要条件，这组必要条件也都是文件。当你要求更新某个工作目标时，如果
必要条件中存在时间戳在工作目标的时间戳之后的文件，make就会执行相应规则里的
命令脚本。因为某个规则的工作目标可以是另一个规则的必要条件，所以这样的工作目
标和必要条件将会形成依存图（dependencygraph）。建立及处理依存图，并据此更新特
定的工作目标，就是make所要做的事情。
规则对make而言十分重要，make允许你使用各种类型的规则。具体规则（explicit
rule），就像我们在上一章所编写的规则，用来指定需要更新的工作目标：如果必要条件
中存在时间戳在此工作目标的时间戳之后的文件，make就会对它进行更新的动作。这将
会是你最常使用的规则类型。模式规则（patternrule）中所使用的是通配符（wildcard）
而不是明确的文件名称，这让make得以对与模式相符的工作目标应用该规则，进行必要
的更新动作。隐含规则（implicitrule）可以是模式规则，也可以是内置于make的后缀
规则（suffixrule）。有了这些内置于make的规则可以让makefile的编写变得更为容易，
因为对于工作目标的更新，make已经知道许多常见文件类型、后缀以及更新工作目标的
程序。至于静态模式规则（staticpatternrule），它就像正规模式规则一样，只不过它
们只能应用在一串特定的工作目标文件中。
GNUmake可作为许多其他版本的make的替代品，它特别针对兼容性提供了若干功能。
后缀规则最初是make用来编写通则（generalrule）的方法。尽管GNUmake也支持后
缀规则，不过为了更完整及更一般化，它考虑以模式规则来替换。
19
---
## Page 30
20
第二章
具体规则
你编写的规则多半会是具体规则，以特定的文件作为工作目标和必要条件。每个规则都
可以有多个工作目标。这意味着，每个工作目标所具备的必要条件可以跟其他工作目标
的一样。如果这些工作目标尚未被更新，则make将会为它们执行同一组更新动作。例如：
这代表vpath.o和variable.o与同-一组C头文件具有依存关系。这一行等效于：
vpath.o:make.h config.h getopt.h gettext.h dep.h
variable.o:make.h config.hgetopt.h gettext.hdep.h
这两个工作目标将会被分开处理。只要有任何一个目标文件尚未被更新（也就是说，任
何一个头文件的时间戳在该目标文件的之后），则make将会执行规则中所指定的命令以
使更新该目标文件。
你不必将规则一次定义完全（allatonce）。每当make看到一个工作目标，就会将该工
作目标与其必要条件加入依存图。如果make所看到的工作目标已经存在于依存图中，则
任何额外的必要条件都会被附加到该工作目标在依存图中的项目里。对较简单的应用来
说，这个特性可用来断开太长的规则以增进makefile的可读性：
vpath.o:vpath.c make.h config.h getopt.h gettext.h dep.h
vpath.o: filedef.h hash.h job.h commands.h variable.h vpath.h
对较复杂的应用来说，必要条件可以组成自看似无关的文件：
#确定vpath.c被编译之前lexer.c已经创建好了
vpath.o:1exer.c
#以特殊的标记来编译vpath.c
vpath.o:vpath.c
S(COMPILE.C)S(RULE_FLAGS)$(OUTPUT_OPTION)S<
引人另一个程序所产生的依存关系
include auto-generated-dependencies.d
第一个规则指出，每当lexer.c被更新后，vpath.o就必须被更新（这或许是因为产生
lexer.c的过程中会有其他副作用）。这个规则还可用来确保必要条件的更新动作总是在
工作目标之前被实施（注意规则的双向作用。就其正向作用而言，此规则指出，若lexer.c
已经被更新，则需要对vpath.o执行更新的动作：就其反向作用而言，此规则指出，如
果我们需要建立或使用vpath.o，首先必须确定lexer.c已经更新）。这个规则应该就近放
在lexer.c处理规则的旁边，好让开发人员能够注意到这个微妙的关系。稍后，vpath.o
的编译规则会被放到其他编译规则之中。此规则的命令用到了三个make变量。你将会看
---
## Page 31
规则
21
到更多的make变量，不过现在你只需要知道，一个变量可以是一个美元符号后面跟着单
一字符（character），也可以是一个美元符号后面跟着一个加圆括号的单词（稍后，我将
会在本章做进一步的说明，并且会在第三章做更多的说明）。最后，o文件和.h文件的
依存关系是从另一个文件（这个文件产生自外部程序）引l人到makefile的。
通配符
当你有一长串文件要指定时，为了简化此过程，make提供了通配符（wildcard），此功
能也被称为文件名模式匹配（globbing）。make的通配符如同Bourneshell的~、*、？、
[...]和[^...]。举例来说，*.*会被扩展（expand）成文件名中包含点号的所有文
件。一个问号代表任何单一字符，而[...]代表一个字符集（characterclass）。若要
取得字符集的“补集”则可以使用【~...]。
符号之后若跟着用户的名称则代表该用户的主目录。
每当make在工作目标、必要条件或命令脚本等语境（context）中看到通配符，就会自
动扩展通配符。在其他语境中，你可以通过函数的调用手动扩展通配符。如果你想创建
适应能力较强的makefile，通配符非常有用。举例来说，如果不想手动列出一个程序里
的所有文件，你就可以使用通配符（注1）：
：boxd
$(CC）-OS@S^
不过通配符的使用务必谨慎为之，因为一不小心就会有误用的危险。比如：
*.o:constants.h
这个规则的意图很明显：所有的目标文件皆依存于头文件constants.h。不过，如果工作
目录中当前并未包含任何目标文件，则通配符扩展后会变成下面这样：
:constants.h
译注1：“~”符号叉称为tilde。若“~”符号出现在西班牙文的字母上，代表它的发音是上额的
鼻音，此时tilde可以译成“额化符号”若“~”符号出现在C语言中，代表按位的逻辑
“波浪符号”，也就是将tilde作为tidal（潮汐）来看，事实上它的形状还挺像的。
注1：
在顾虑比较多的环境中，使用通配符来选取程序里的文件被视为一种坏习惯，因为这可
能会将毫无关系的源文件意外地链接进该程序。
---
## Page 32
22
第二章
这是一个合法的make表达式，而且它本身并不会产生错误信息。实现此规则的正确方
法，就是针对源文件使用通配符（因为它们总是存在的）以及将之转换成一串目标文件。
当我们在第四章讨论到make的函数时将会提到这个技巧。
最后，值得注意的是，当模式出现在工作目标或必要条件中时，是由make进行通配符的
扩展。然而，当模式出现在命令中时，是由subshell进行扩展的动作。区分这两种情况
有时会变得很重要，因为make会在读取makefile的时候立即扩展通配符，但是shell只
会在执行命令的时候扩展通配符。当有许多复杂的文件操作需要进行时，这两种文件扩
展动作将会有很大的差别。
假想工作目标
到目前为止，我们所提到的工作目标以及必要条件都会进行文件的创建和更新的动作。
尽管这是典型的用法，但是以工作目标充当标签（label）来代表命令脚本，通常会有些
用处。举例来说，稍早我们曾提到在许多makefile中，默认的首先要处理的标准工作目
标称为all。任何不代表文件的工作目标就叫作假想工作目标（phonytarget）。另一个
标准的假想工作目标称为clean：
clean:
rm-f*.olexer.c
通常，make总是会执行假想工作目标，因为对应于该规则的命令并不会创建以该工作目
标为名称的文件。
切记，make无法区分文件形式的工作目标与假想工作目标。如果当前目录中刚好出现与
假想工作目标同名的文件，make将会在它的相依图中建立该文件与假想工作自标的关
系。举例来说，如果你运行makeclean时，工作目录中刚好存在clean这个文件，那
么将会产生令人困惑的信息：
$ make clean
make:clean'is up to date
因为大多数的假想工作目标并未指定必要条件，clean工作目标总是会被视为已经更
新，所以相应的命令永远不会被执行。
为了避免这个问题，GNUmake提供了一个特殊的工作目标一一.PHONY，用来告诉
make，该工作目标不是一个真正的文件。当你要声明假想工作目标时，只要将该工作目
标指定成.PHONY的一个必要条件即可：
.PHONY:clean
clean:
rm-f*.olexer.c
---
## Page 33
规则
23
现在，即使当前自录中存在名为clean的文件，make还是会执行对应于clean的命令。
除了总是将工作目标标记为尚未更新、将一个工作目标声明为“假”之外，还会让make
知道，不应该像处理一般规则那样，从源文件来建立以工作目标为名的文件。因此，make
可以优化它的一般规则搜索程序以提高性能。
工作目标总是尚未更新，这总会使得该实际文件（工作目标）被重新建立。然而，以“假
想工作目标”作为“假想工作自标”的必要条件通常会有些用处。举例来说，a11工作
目标常会被用来指定所要编译的一串程序：
PHONY:al1
all:bash bashbug
其中，all工作目标将会创建bash（一个shell程序）以及bashbug（一个错误报告工具）。
你还可以将假想工作目标作为内置在makefile里的shell脚本来用。以假想工作目标作为
另一个工作目标的必要条件，可让make在进行实际工作目标之前调用假想工作目标所
代表的脚本。假如我们很在意磁盘空间的使用情况，因而在进行磁盘密集的工作之前，
我们会想要显示磁盘尚有多少空间可供使用，我们可能会这么做：
.PHONY:make-documentation
make-documentation:
df-k.1awk'NR==2（printf（*d available\n"，$S4）}
javadoc...
这么做的问题是，我们最后可能会在不同的工作自标下多次指定df和awk命令，这会
造成一个维护上的问题，因为如果我们在另一个系统上遇到了输出格式不同的af命令，
那么我们必须到指定df和awk命令的每一处进行修改。此时，我们可以把df那一行放
在它自己的假想工作目标里：
.PHONY:make-documentation
make-documentation:df
javadoc...
.PHONY:df
df :
df-k.|awkNR==2（printf（"d available\n",$S4）}
们的df工作目标。可以这么做是因为make-documentation也是一个假想工作目标。现
在，即使我们在其他工作目标中重复使用df，也不会造成什么维护上的问题。
假想工作目标还有许多其他的好用处。
make的输出常会把想要进行阅读以及调试的人搞糊涂。这是因为：尽管makefile的编写
---
## Page 34
24
第二章
是采用从上而下（top-down）的形式，不过make执行命令的方式却是采用从下而上
（bottom-up）的形式：此外，你根本无法判断当前正在执行哪个规则。如果能够在make
的输出中为主要工作目标加上注释，那么make的输出就会变得很容易阅读。这就是假
想工作目标可以派上用场的地方。如下所示的例子摘录自bash的makefile：
$（Program):bui1d_msg $(OBJECTS)$(BUILTINS_DEP) S(LIBDEP)
S(RM）S@
1s -1S（Program）
size S(Program)
.PHONY:bui1d_msg
build_msg:
@printf *#\n#Building S(Program)\n#\n*
因为printf位于假想工作目标之中，所以在任何必要条件被更新之前会立即输出信息。
如果以build_msg作为S（Program）命令脚本的第一个命令，那么在所有编译结果和依
存关系都产生之后才会执行该命令。切记，因为假想工作目标总是尚未更新，所以假想
工作目标build_msg会导致S（Program）被重建—即使它已经被更新。这么做似
乎是明智的扶择，所有的计算工作在编译目标文件的时候大多已经完成，因此只有最后
的链接工作一定会被执行。
假想工作目标还可用来改善makefile的“用户接口”。工作目标通常是包含目录路径元
素、额外文件名成分（比如版本编号）以及标准扩展名的复合字符串，这使得“在命令
行上指定工作目标的文件名”成为一种挑战。你只要加人一个简单的假想工作目标，并
以实际文件作为它的必要条件，就可以避免这个问题。
许多makefile多少都会包含一组标准的假想工作目标。表2-1列出了这些标准的假想工
作目标。
表2-1：标准的假想工作目标
工作目标功能
a11
执行编译应用程序的所有工作
install
从已编译的二进制文件进行应用程序的安装
clean
将产生自源代码的二进制文件删除
distclean
删除编译过程中所产生的任何文件（除了二进制文件，也包含configure所产
生的Makefile）
TAGS
建立可供编辑器使用的标记表
info