Example 5: *p:=&f; (*p)()
b1
l d R sp
t43
l d M p
t51
b2
l d R sp
t54
l d M t52
t22
t21 − 4
t25
st M t21 t24
t42
t41 + 4
t44
t43
t52
t51 + 4
t55
t54
t23
st R sp t22
t26
st pc b1
t45
st M t42 t44
t46
st P C b2
t53
st R sp t52
t56
st P C t55
Because our semantics can predict only internal operations (see
rule Prd), the translation function introduces an additional internal
operation, i.e., t22 which allows predicting the value of the load t21.
Suppose that the function f simply returns and the security pol-
icy labels all data, except the program counter, as sensitive. Œe
program is secure (at the ISA level) as it always transfers control
to f , producing the sequence of observations il a1 :: ds p :: il a2 ::
dl p :: il &f independently of the initial state.
Jump target prediction produces a diﬀerent behavior. Let σ0 be
the state containing only the translation of the instruction in a1.
Initially, predBT B (σ0) is empty since the state contains no PC up-
dates (e.g.
t12) that result from translating indirect jumps. Œe
CPU may execute and fetch t12, thus adding t21, t22, and t23 to
the set of microinstructions I .
In the resulting state predBT B is
{t22 7→ v | v ∈ V }, since t23 models an indirect jump and t22 has
not been executed. Œe CPU can therefore predict the value of t22
without waiting for the result of the load t21. If the predicted value
is the address ❕ of the instruction r1:=*(r2) the misprediction can
use ❕ as gadget to leak sensitive information.
t31
❕
l d R r2
t32
l d M r1
t33
st R r1 t32
In fact, the speculative semantics can produce the sequence of ob-
servations il a1 :: ds p :: il a2 :: dl p :: il ❕ :: dl v, where v is
the initial value of register r2. Œe last observation of the sequence
allows an aŠacker to learn sensitive data. Observe that this leak is
Instruction at a2 calls a trampoline starting at address b1 and in-
struction at a3 loops indeﬁnitely. Œe ﬁrst instruction of the tram-
poline overwrites the return address on the stack with the value at
address p and its second instruction at b2 returns.
We leverage our model to analyze the eﬀectiveness of Retpo-
line for indirect jumps. Since address b1 is known at compile time,
t26 does not trigger a jump target prediction. While executing
the trampoline, the value of t55 may be mispredicted, especially
if the load from p has not been executed and the store t45 is post-
poned. However, b2 is a ret, hence the value of t55 is predicted via
predRS B . Since there is no call between a1 and b2, then prediction
can only assign the address a3 to t55 (i.e., predRS B |t55 ⊆ {t55 →
a3}). Œerefore, the RSB entry generated by a2 is used and mispre-
dictions are captured with the inﬁnite loop in a3. Ultimately, when
the value of t55 is resolved, the correct return address is used and
the control ﬂow is redirected to the value of ∗p, as expected.
7.3 Spectre-STL
Spectre-STL [26] (Store-To-Load) exploits the CPUs mechanism to
predict load-to-store data dependencies. A load cannot be executed
before executing all the past (in program order) stores that aﬀect
the same memory address. However, if the address of a past store
has not been resolved, the CPU may execute the load in speculation
without waiting for the store, predicting that the target address of
the store is diﬀerent from the load’s address. Mispredictions cause
store bypasses leading to information leaks and access to stale data.
Œis behavior can be modeled as predST L(σ , δ , P) =
ta 7→ a |
13
a ∈ σ ∧ σ (t ′
t ′ ← c ′?ld M t ′
a ) , a
t ← c?st M ta tv ∈ str-act(σ , t ′)∧
σ (ta )↑
A prediction occurs whenever a memory store (t) is waiting an un-
resolved address (σ (ta )↑), while the address (s(t ′
a)) of a subsequent
load (t ′) has been resolved, and the load may depend on the store
(t ∈ bn(str-act(σ , t ′))). Prediction guesses that the store’s address
(ta ) diﬀers with the load’s address.
7.3.1 Hardware countermeasures to Store Bypass. Œe speciﬁ-
cation of proposed hardware countermeasures o‰entimes comes
with no precise semantics and is ambiguous. ARM introduced
the Speculative Store Bypass Safe (SSBS) conﬁguration to prevent
store bypass vulnerabilities. Œe speciﬁcation of SSBS [4] is: Hard-
ware is not permiˆed to load . . . speculatively, in a manner that could
. . . give rise to a . . . side channel, using an address derived from a regis-
ter value that has been loaded from memory . . . (L) that speculatively
reads an entry from earlier in the coherence order from that location
being loaded from than the entry generated by the latest store (S) to
that location using the same virtual address as L.
InSpectre provides a ground to formalize the behavior of these
hardware mechanisms. We formalize SSBS as follows. Let σ =
l
−→→→ σ ′, σ (t )↑, and
(I , s, C, F , δ , P) and t ← c?ld τ ta ∈ σ .
σ ′(t )↓, then for every t ′ ∈ srcs(t , σ ), if σ (t ′) , σ (ta ) then t ′ < P.
If σ
Œe reason why SSBS prevents Spectre-STL is simple. Œe rule
forbids the execution of a load t if any address used to identify the
last store aﬀecting ta has been predicted to diﬀer from ta .
7.3.2 New Vulnerability: Spectre-STL-D. Our model reveals that
if a microarchitecture mispredicts the existence of a Store-To-Load
Dependency (hence Spectre-STL-D), e.g., in order to forward tem-
porary store results, a similar vulnerability may be possible. To
model this behavior it is enough to substitute σ (t ′
a ) =
a in predST L. We consider this a new form of Spectre because the
implementation of this microarchitectural feature can be substan-
tially diﬀerent from the one required for Spectre-STL (e.g., Feiste
et al. [17] patented a mechanism to implement this feature) and
because the vulnerable programs are diﬀerent.
a ) , a with σ (t ′
Œis feature may cause Spectre-STL-D if a misspeculated depen-
dency is used to perform subsequent memory accesses. Consider
the following program:
a1 : ∗ ( ∗ b1 ) : = sec
a2 : r1 : = ∗ ( ∗ b2 )
t11
l d M b1
t21
l d M b2
t12
t11
t13
t14
st M t12 ts e c
st P C a2
t22
t23
l d M t21
st R r1 t22
If the CPU executes and fetches t14, predicts that t12 = b2 (i.e., it
mispredicts the alias *b1==*b2), executes t13, forwards the result of
t13 to t21, and executes t22 before the load t11 is retired, then the ad-
dress accessed by t22 depends on tsec . Œis can produce the secret-
dependent sequence of observations il a1 :: il a2 :: dl sec, while the
sequential semantics always produces the secret-independent se-
quence of observations il a1 :: dl b1 :: ds ∗b1 :: il a2 :: dl b2 :: dl ∗b2.
Notice that SSBS may not be eﬀective against Spectre-STL-D.
7.4 New Vulnerability: Spectre-OoO
A popular countermeasure to prevent sensitive data from aﬀect-
ing the execution time and caches is “constant time programming”,
14
also known as “data oblivious algorithms”. Œis mechanism en-
sures that branch conditions and memory addresses are indepen-
dent of sensitive data. Œe following deﬁnition formalizes “ISA
constant time” while abstracting from the speciﬁc ISA:
Deﬁnition 7.1. A program is “ISA constant time” if for every pair
of states σ1 ∼ σ2 and every pair of in-order executions of length
n, σ1 −→n σ ′
2, where
(I , s, C, F) ≈I S A (I ′
2, it is the case that σ ′
, F ′) iﬀ
1 and σ2 −→n σ ′
1 ≈I S A σ ′
, s ′
, C ′
(1) I = I ′, C = C ′, F = F ′: the sets of microinstructions,
commits and decodes are equal.
(2) If t ← c?ld M ta ∈ I or t ← c?st M ta tv ∈ I then [c]σ =
[c]σ ′, s(t )↓ = s ′(t )↓, (whenever deﬁned, guards evaluate
the same, and memory operations execute in lockstep) and
[c]σ ⇒ (σ (ta ) = σ ′(ta)) (the same values are used to ad-
dress memory)
(3) If t ← c?st P C tv ∈ I then [c]σ = [c]σ ′, s(t )↓ = s ′(t )↓,
and [c]σ ⇒ (σ (tv ) = σ ′(tv )) (the same values are used to
update the PC)
Œe following program (and its MIL translation) exempliﬁes this
policy. It loads register r1 from address b1, copies the value of r1
in r2 if the ﬂag z is set, and saves the result into b2.
a1 : r1 = ∗b1;
t11
t13
t12
l d M b1
st R r1 t11
st P C a2
a2 : cmov z, r2, r1;
t21
l d R z
t22
t24
t21 = 1
l d R r1
st P C a3
t23
t21 = 1
st R r2 t22
a3 : ∗b2 = r2;
t31
l d R r2
t32
st M b2 t31
Suppose that ﬂag z contains sensitive information and the aŠacker
observes only the data cache. Œe “conditional move” instruction
in a2 executes in constant time [27] and is used to re-write branches
that may leak information via the execution time or the instruction
cache. Œis allows the program to always access address b1 and b2
unconditionally and execute always the same ISA instructions: In
the sequential model the program always produces the sequence
of observations dl b1 :: ds b2.
Programs that are ISA constant time could be insecure in pres-
ence of speculation, as demonstrated by Spectre-PHT [31]. Per-
haps surprisingly, it turns out that ISA constant time is not se-
cure even for the OoO model, in absence of speculation. In fact,
our analysis of conditional noninterference for ISA constant time
programs in the OoO model led to the identiﬁcation of a class
of vulnerable programs, where secrets inﬂuence the existence of
data dependency between registers. Œe above program exempli-
ﬁes this problem: the data dependency between t11 and t32 exists
only if z is set. Concretely, consider two states σ0 and σ1 in which
z = 0 and z = 1, respectively. Œen, str-act(σ1, t31) = {t23} and
str-act(σ1, t23) = {t12}, while str-act(σ0, t31) is the microinstruc-
tion representing the initial value of r2. Œerefore, state σ0 may
produce the observation sequence ds b2 :: dl b1 only if the ﬂag
z = 0, thus leaking its value through the data cache.
7.4.1 MIL Constant Time. Spectre-OoO motivates the need for
a new microarchitecture-aware deﬁnition of constant time.
Deﬁnition 7.2. A program is “MIL constant time” if for every pair
of states σ1 ∼ σ2 and every pair of in-order executions of length
n, σ1 −→n σ ′
2, where
(I , s, C, F) ≈M I L (I ′
1 and σ2 −→n σ ′
, C ′
(1) (I , s, C, F) ≈I S A (I ′
(2) If t ← c?ld R ta ∈ I or t ← c?st R ta tv ∈ I then [c]σ =
1 ≈M I L σ ′
, s ′
2, it is the case that σ ′
, F ′) iﬀ
, C ′
, F ′)
, s ′
[c]σ ′, s(t )↓ = s ′(t )↓, and [c]σ ⇒ (σ (ta ) = σ ′(ta))
Notice that in addition to standard requirements of constant
time, MIL constant time requires that starting from two ∼-indistinguishable
states the program makes the same accesses to registers. MIL con-
stant time is suﬃcient to ensure security in the OoO model:
does not reﬂect the inner workings of modern CPUs, which re-
order memory stores and implement a relaxed consistency model.
Œese features are required to capture Spectre-OoO in Section 7.4.
Moreover, our model provides a clean separation between the gen-
eral speculative semantics and microarchitecture-speciﬁc features,
where the laŠer is obtained by reducing the nondeterminism of
the former. Œis enables a modular analysis of (combinations of)
predictive strategies, as in Spectre-PHT ICache in Section 7.1.3.
Cache side channels In line with prior works [11, 12, 22], our
aŠacker model abstracts away the mechanism used by an aŠacker
to proﬁle the sequence of a victim’s memory accesses, providing
a general account of trace-driven aŠacks [45]. Complementary
works [15, 20, 36, 58] show that cache proﬁling is becoming in-
creasingly steady and precise. Performance jiŠers caused by cache
usage have been widely exploited to leak sensitive data [2, 21, 32,
39, 43, 44, 59], e.g., in cryptography so‰ware. Miller [41], and Fogh
and Ertl [18] propose a taxonomy for mitigating speculative exe-
cution vulnerabilities. We refer to a recent survey by Canella et
al. [19] on cache-based countermeasures.
Spectre vs Meltdown Recent aŠacks that use microarchitec-
tural eﬀects of speculative execution have been generally distin-
guished as Spectre and Meltdown aŠacks [9]. We focus on the
former [13, 16, 23, 24, 30, 31, 34, 37, 57], which exploits specu-
lation to cause a victim program to transiently access sensitive
memory locations that the aŠacker is not authorized to read. Melt-
down aŠacks [35] transiently bypass the hardware security mech-
anisms that enforce memory isolation. Importantly, Meltdown at-
tacks can be easily countered in hardware, while Spectre aŠacks
require hardware-so‰ware co-design, which motivates our model.
We remark that the vulnerability in Section 7.3 is diﬀerent from
the recent Microarchitectural Data Sampling aŠacks [10, 48, 52],
since it only requires the CPU to predict memory aliases with no
need of violating memory protection mechanisms. Microarchitec-
tures supporting this feature have been proposed, e.g., in Feiste et
al. [17].
Tool support Several prototypes have been developed to repro-
duce and detect known Spectre-PHT aŠacks [12, 22, 53, 54]. Check-
mate [50] synthesizes proof-of-concept aŠacks by using models of
speculative and OoO pipelines. Tool support for vulnerabilities be-
yond Spectre-PHT requires dealing with a large number of possi-
ble predictions and instruction interleavings. In fact, current tools
mainly focus on Spectre-PHT ignoring OoO execution.