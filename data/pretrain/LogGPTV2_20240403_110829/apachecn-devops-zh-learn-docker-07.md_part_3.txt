default via 192.168.65.1 dev eth0 src 192.168.65.3 metric 202
10.1.0.0/16 dev cni0 scope link src 10.1.0.1
127.0.0.0/8 dev lo scope host
172.17.0.0/16 dev docker0 scope link src 172.17.0.1
...
192.168.65.0/24 dev eth0 scope link src 192.168.65.3 metric 202
```
在我让你进入本章的下一节之前，我想再次指出使用`host`网络是危险的，需要尽可能避免。
# 零网络
有时，我们需要运行一些根本不需要任何网络连接的应用服务或作业来执行任务。强烈建议您在连接到`none`网络的容器中运行这些应用。该容器将被完全隔离，因此不会受到任何外界的影响。让我们运行这样一个容器:
```
$ docker container run --rm -it --network none alpine:latest /bin/sh
```
一旦进入容器，我们就可以验证没有`eth0`网络端点可用:
```
/ # ip addr show eth0
ip: can't find device 'eth0'
```
也没有可用的路由信息，我们可以使用以下命令进行演示:
```
/ # ip route
```
这不返回任何东西。
# 在现有网络命名空间中运行
通常，Docker 会为我们运行的每个容器创建一个新的网络命名空间。容器的网络命名空间对应于我们前面描述的容器网络模型的沙箱。当我们将容器附加到网络时，我们定义了一个端点，它将容器网络命名空间与实际网络连接起来。这样，每个网络名称空间都有一个容器。
Docker 提供了一种额外的方法来定义容器运行的网络命名空间。当创建一个新的容器时，我们可以指定它应该附加到或者应该说包括在现有容器的网络命名空间中。使用这种技术，我们可以在单个网络命名空间中运行多个容器:
![](img/03a81a89-bd39-429b-b99e-045f1b643a43.png)
Multiple containers running in a single network namespace
在上图中，我们可以看到在最左边的网络名称空间中，我们有两个容器。这两个容器共享同一个名称空间，因此可以在本地主机上相互通信。网络名称空间(而不是单个容器)然后被附加到**网络 1** 。
当我们想要调试现有容器的网络而不在该容器内运行额外的进程时，这很有用。我们只需将一个特殊的实用程序容器附加到容器的网络命名空间中进行检查。Kubernetes 在创建 pod 时也使用了该功能。我们将在本书的后续章节中听到更多关于 Kubernetes 和 pods 的内容。
现在，让我们演示一下这是如何工作的。首先，我们创建一个新的桥接网络:
```
$ docker network create --driver bridge test-net
```
接下来，我们运行一个连接到该网络的容器:
```
$ docker container run --name web -d --network test-net nginx:alpine
```
最后，我们运行另一个容器，并将其连接到我们的`web`容器的网络:
```
$ docker container run -it --rm --network container:web alpine:latest /bin/sh
```
具体来说，注意我们如何定义网络:`--network container:web`。这告诉 Docker，我们的新容器将使用与名为`web`的容器相同的网络命名空间。
由于新容器与运行 Nginx 的 web 容器在同一个网络命名空间中，我们现在可以在 localhost 上访问 Nginx 了！我们可以通过使用`wget`工具来证明这一点，该工具是 Alpine 容器的一部分，用于连接到 Nginx。我们应该看到以下内容:
```
/ # wget -qO - localhost
Welcome to nginx!
...
```
请注意，为了可读性，我们缩短了输出。还请注意，运行连接到同一网络的两个容器和运行在同一网络命名空间中的两个容器之间有一个重要的区别。在这两种情况下，容器可以自由地相互通信，但是在后一种情况下，通信通过 localhost 进行。
要清理容器和网络，我们可以使用以下命令:
```
$ docker container rm --force web
$ docker network rm test-net
```
# 港口管理
既然我们知道了如何通过将容器放在不同的网络上来将它们相互隔离或防火墙，并且我们可以将一个容器连接到多个网络，那么我们就有一个问题尚未解决。*如何向外界公开一个应用服务？*想象一个容器运行一个网络服务器，托管我们以前的网络应用编程接口。我们希望来自互联网的客户能够访问这个应用编程接口。我们将其设计为一个可公开访问的应用编程接口。为了实现这一点，我们必须，形象地说，在我们的防火墙中打开一扇门，通过它我们可以将外部流量汇集到我们的应用编程接口。出于安全考虑，我们不只是想把门开得大一点，而是希望只有一个受控制的大门，让车流通过。
我们可以通过将容器端口映射到主机上的可用端口来创建这样的入口。我们还调用这个容器端口来发布一个端口。请记住，容器有自己的虚拟网络栈，主机也是如此。因此，容器端口和主机端口完全独立存在，默认情况下根本没有任何共同点。但是，我们现在可以将一个容器端口与一个免费的主机端口连接起来，并通过此链接汇集外部流量，如下图所示:
![](img/dee1611f-119c-481d-8382-8d6d29aa81ee.png)
Mapping container ports to host ports
但是现在是演示如何将容器端口映射到主机端口的时候了。这是在创建容器时完成的。我们有不同的方法:
*   首先，我们可以让 Docker 决定我们的容器端口应该映射到哪个主机端口。Docker 将选择 32xxx 范围内的一个空闲主机端口。该自动映射通过使用`-P`参数完成:
```
$ docker container run --name web -P -d nginx:alpine
```
前面的命令在容器中运行 Nginx 服务器。Nginx 正在容器内的港口`80`监听。使用`-P`参数，我们告诉 Docker 将所有暴露的容器端口映射到 32xxx 范围内的自由端口。我们可以通过使用`docker container port`命令找到 Docker 正在使用的主机端口:
```
$ docker container port web
80/tcp -> 0.0.0.0:32768
```
Nginx 容器只公开了端口`80`，我们可以看到它已经映射到了主机端口`32768`。如果打开一个新的浏览器窗口，导航到`localhost:32768`，应该会看到下面的截图:
![](img/50c741ad-dfa8-46ce-ac34-d7cdea5724c7.png)
The welcome page of Nginx
*   找出 Docker 正在为我们的容器使用哪个主机端口的另一种方法是检查它。主机端口是`NetworkSettings`节点的一部分:
```
$ docker container inspect web | grep HostPort
32768
```
*   最后，获取这些信息的第三种方法是列出容器:
```
$ docker container ls
CONTAINER ID    IMAGE         ...   PORTS                  NAMES
56e46a14b6f7    nginx:alpine  ...   0.0.0.0:32768->80/tcp  web
```
请注意，在前面的输出中，`/tcp`部分告诉我们，端口已经打开，可以与 TCP 协议通信，但不能与 UDP 协议通信。TCP 是默认的，如果我们想要指定我们想要为 UDP 打开端口，那么我们必须显式地指定它。映射中的`0.0.0.0`告诉我们，来自任何主机 IP 地址的流量现在都可以到达`web`容器的容器港口`80`。
有时，我们希望将一个容器端口映射到一个非常特定的主机端口。我们可以通过使用参数`-p`(或`--publish`)来实现。让我们看看这是如何通过以下命令完成的:
```
$ docker container run --name web2 -p 8080:80 -d nginx:alpine
```
`-p`参数的值采用`:`的形式。因此，在前面的例子中，我们将容器港口`80`映射到主机港口`8080`。一旦`web2`容器运行，我们可以通过导航到`localhost:8080`在浏览器中测试它，我们应该会收到与我们在前面的例子中看到的处理自动端口映射的相同的 Nginx 欢迎页面。
当使用 UDP 协议通过某个端口进行通信时，`publish`参数看起来像`-p 3000:4321/udp`。请注意，如果我们希望允许通过同一个端口与 TCP 和 UDP 协议进行通信，那么我们必须分别映射每个协议。
# 摘要
在本章中，我们学习了在单个主机上运行的容器如何相互通信。首先，我们看了定义容器网络需求的 CNM，然后我们看了 CNM 的几个实现，比如桥接网络。然后，我们详细研究了桥接网络是如何工作的，以及 Docker 为我们提供了哪些关于网络和连接到这些网络的容器的信息。我们还学习了从容器外部和内部采用两种不同的视角。
在下一章中，我们将介绍 Docker Compose。我们将学习如何创建由多个服务组成的应用，每个服务都在一个容器中运行，以及 Docker Compose 如何允许我们使用声明性方法轻松构建、运行和扩展这样的应用。
# 问题
要评估您的技能，请尝试回答以下问题:
1.  说出**容器网络模型** ( **CNM** )的三个核心要素。
2.  您将如何创建一个名为前端的自定义桥接网络？
3.  你将如何运行两个 nginx:连接到前端网络的高山容器。
4.  对于前端网络，获取以下信息:
    1.  所有附加容器的 IPs。
    2.  与网络关联的子网。
5.  主机网络的目的是什么？
6.  说出一两个适合使用主机网络的场景。
7.  无网络的目的是什么？
8.  在什么情况下应该使用无网络？
# 进一步阅读
以下是一些更详细描述本章主题的文章:
*   *http://dockr.ly/2sXGzQn[Docker 网络概述](http://dockr.ly/2sXGzQn)*
*   *http://dockr.ly/2HJfQKn 容器联网*
*   什么是 https://bit.ly/2HyC3Od 的桥
*   *在[http://dockr.ly/2BNxjRr](http://dockr.ly/2BNxjRr)使用桥接网络*
*   *在[http://dockr.ly/2ETjy2x](http://dockr.ly/2ETjy2x)使用 Macvlan 网络*
*   *在[http://dockr.ly/2F4aI59](http://dockr.ly/2F4aI59)使用主机网络*联网