# 10 \| 如何进行数学计算、字符串处理和条件判断？你好，我是朱晓峰。 MySQL提供了很多功能强大，而且使用起来非常方便的函数，包括数学函数、字符串处理函数和条件判断函数等。 在很多场景中，我们都会用到这些函数，比如说，在超市项目的实际开发过程中，会有这样的需求： 1.  会员积分的规则是一元积一分，不满一元不积分，这就要用到向下取整的数学函数    FLOOR()；    2.  在打印小票的时候，收银纸的宽度是固定的，怎么才能让打印的结果清晰而整齐呢？这个时候，就要用到    CONCAT() 等字符串处理函数；        3.  不同数据的处理方式不同，怎么选择正确的处理方式呢？这就会用到    IF(表达式，V1，V2)    这样的条件判断函数；        4.  ......    这些函数对我们管理数据库、提高数据处理的效率有很大的帮助。接下来，我就带你在解决实际问题的过程中，帮你掌握使用这些函数的方法。 数学函数我们先来学习下数学函数，它主要用来处理数值数据，常用的主要有 3类，分别是取整函数 ROUND()、CEIL()、FLOOR()，绝对值函数 ABS() 和求余函数MOD()。 知道了这些函数，我们来看看超市经营者的具体需求。他们提出，为了提升销量，要进行会员营销，主要是给会员积分，并以积分数量为基础，给会员一定的优惠。 积分的规则也很简单，就是消费一元积一分，不满一元不积分，那我们就需要对销售金额的数值进行取整。 这里主要用到四个表，分别是销售单明细表、销售单头表、商品信息表和会员信息表。为了方便你理解，我对表结构和数据进行了简化。 销售单明细表： ![](Images/01727242ddfea39fcc9d6c91af46bf7a.png)savepage-src="https://static001.geekbang.org/resource/image/54/93/543b4ce8c0c8b1f3bb7028c911213f93.jpeg"}销售单头表： ![](Images/fd3de43f35d5ef6a00df2e0ed66e9407.png)savepage-src="https://static001.geekbang.org/resource/image/a4/33/a4df12d3469aaf2f770fbfa8fb842c33.jpeg"}商品信息表： ![](Images/a7d49ebf07146a4608b2d77dd12da7ec.png)savepage-src="https://static001.geekbang.org/resource/image/26/03/262121b96d4ce48e310cdff37d536203.jpeg"}会员信息表： ![](Images/5e739b799f4935fa3fc7d072b4abf7e7.png)savepage-src="https://static001.geekbang.org/resource/image/10/8e/105d12853e4b09aefd96f2423613648e.jpeg"}这个场景下，可以用到 MySQL 数学函数中的取整函数，主要有 3种。 1.  向上取整 CEIL(X) 和 CEILING(X)：返回大于等于 X 的最小 INT    型整数。    2.  向下取整 FLOOR(X)：返回小于等于 X 的最大 INT    型整数。    3.  舍入函数 ROUND(X,D)：X 表示要处理的数，D    表示保留的小数位数，处理的方式是四舍五入。ROUND(X) 表示保留 0    位小数。    现在积分的规则是一元积一分，不满一元不积分，显然是向下取整，那就可以用FLOOR（）函数。 首先，我们要通过关联查询，获得会员消费的相关信息：     mysql>  SELECT        -> c.membername AS '会员',   -- 从会员表获取会员名称        -> b.transactionno AS '单号',-- 从销售单头表获取单号        -> b.transdate AS '交易时间', -- 从销售单头表获取交易时间        -> d.goodsname AS '商品名称', -- 从商品信息表获取商品名称        -> a.salesvalue AS '交易金额'        -> FROM        -> demo.transactiondetails a        -> JOIN        -> demo.transactionhead b ON (a.transactionid = b.transactionid)        -> JOIN        -> demo.membermaster c ON (b.memberid = c.memberid)        -> JOIN        -> demo.goodsmaster d ON (a.itemnumber = d.itemnumber);    +------+------------------+---------------------+----------+----------+    | 会员 | 单号             | 交易时间            | 商品名称 | 交易金额 |    +------+------------------+---------------------+----------+----------+    | 张三 | 0120201201000001 | 2020-12-01 14:25:56 | 书       |   176.22 |    | 张三 | 0120201201000001 | 2020-12-01 14:25:56 | 笔       |    24.75 |    | 李四 | 0120201202000001 | 2020-12-02 10:50:50 | 书       |   234.96 |    | 李四 | 0120201202000001 | 2020-12-02 10:50:50 | 笔       |    26.40 |    +------+------------------+---------------------+----------+----------+    4 rows in set (0.01 sec)接着，我们用FLOOR（a.salesvalue），对销售金额向下取整，获取会员积分值，代码如下：     mysql> SELECT        -> c.membername AS '会员',        -> b.transactionno AS '单号',        -> b.transdate AS '交易时间',        -> d.goodsname AS '商品名称',        -> a.salesvalue AS '交易金额',        -> FLOOR(a.salesvalue) AS '积分'  -- 使用FLOOR函数向下取整        -> FROM        -> demo.transactiondetails a        -> JOIN        -> demo.transactionhead b ON (a.transactionid = b.transactionid)        -> JOIN        -> demo.membermaster c ON (b.memberid = c.memberid)        -> JOIN        -> demo.goodsmaster d ON (a.itemnumber = d.itemnumber);    +------+------------------+---------------------+----------+----------+------+    | 会员 | 单号             | 交易时间            | 商品名称 | 交易金额 | 积分 |    +------+------------------+---------------------+----------+----------+------+    | 张三 | 0120201201000001 | 2020-12-01 14:25:56 | 书       |   176.22 |  176 |    | 张三 | 0120201201000001 | 2020-12-01 14:25:56 | 笔       |    24.75 |   24 |    | 李四 | 0120201202000001 | 2020-12-02 10:50:50 | 书       |   234.96 |  234 |    | 李四 | 0120201202000001 | 2020-12-02 10:50:50 | 笔       |    26.40 |   26 |    +------+------------------+---------------------+----------+----------+------+    4 rows in set (0.01 sec)你看，通过FLOOR()，我们轻松地获得了超市经营者需要的积分数据。 类似的，如果用户的积分规则改为"不满一元积一分"，其实就是对金额数值向上取整，这个时候，我们就可以用CEIL()函数。操作方法和前面是一样的，我就不具体解释了。 最后，我再来讲一讲舍入函数ROUND（）的使用方法。 超市经营者提出，收银的时候，应收金额可以被设定四舍五入到哪一位。比如，可以设定四舍五入到元、到角，或者到分。 按照指定的位数，对小数进行四舍五入计算，这样的场景就要用到ROUND（X,D）了。它的作用是通过四舍五入，对数值 X 保留 D位小数。 根据超市经营者的要求，我们把函数 ROUND(X,D) 中的保留小数的位数 D设置成 0、1 和 2。 如果要精确到分，我们可以设置保留 2位小数：     mysql> SELECT ROUND(salesvalue,2) -- D设置成2，表示保留2位小数，也就是精确到分    -> FROM demo.transactiondetails    -> WHERE transactionid=1 AND itemnumber=1;    +---------------------+    | ROUND(salesvalue,2) |    +---------------------+    | 176.22 |    +---------------------+    1rows in set (0.00 sec)如果要精确到角，可以设置保留 1位小数：     mysql> SELECT ROUND(salesvalue,1) -- D设置成1，表示保留1位小数，也就是精确到角    -> FROM demo.transactiondetails    -> WHERE transactionid=1 AND itemnumber=1;    +---------------------+    | ROUND(salesvalue,1) |    +---------------------+    | 176.2 |    +---------------------+    1 rows in set (0.00 sec如果要精确到元，可以设置保留 0位小数：     mysql> SELECT ROUND(salesvalue,0)-- D设置成0，表示保留0位小数，也就是精确到元    -> FROM demo.transactiondetails    -> WHERE transactionid=1 AND itemnumber=1;    +---------------------+    | ROUND(salesvalue,0) |    +---------------------+    | 176 |    +---------------------+    1 rows in set (0.00 se除了刚刚我们所学习的函数，MySQL 还支持绝对值函数 ABS（）和求余函数MOD（），ABS（X）表示获取 X 的绝对值；MOD（X，Y）表示获取 X 被 Y除后的余数。 这些函数使用起来都比较简单，你重点掌握它们的含义就可以了，下面我再带你学习下字符串函数。 字符串函数除了数学计算，我们还经常会遇到需要对字符串进行处理的场景，比如我们想要在金额前面加一个"￥"的符号，就会用到字符串拼接函数；再比如，我们需要把一组数字以字符串的形式在网上传输，就要用到类型转换函数。 常用的字符串函数有 4 个。 1.  CONCAT（s1,s2,\...）：表示把字符串    s1、s2......拼接起来，组成一个字符串。        2.  CAST（表达式 AS    CHAR）：表示将表达式的值转换成字符串。        3.  CHAR_LENGTH（字符串）：表示获取字符串的长度。        4.  SPACE（n）：表示获取一个由 n    个空格组成的字符串。        接下来我还是借助超市项目中的实际应用场景，来说明一下怎么使用这些字符串函数。 顾客交了钱，完成交易之后，系统必须要打出一张小票。打印小票时，对格式有很多要求。比如说，一张小票纸，57毫米宽，大概可以打 32 个字符，也就是 16 个汉字。用户要求一条流水打 2行，第一行是商品信息，第二行要包括数量、价格、折扣和金额 4种信息。那么，怎么才能清晰地在小票上打印出这些信息，并且打印得整齐漂亮呢？这就涉及对字符串的处理了。 首先，我们来看一下如何打印第一行的商品信息。商品信息包括：商品名称和商品规格，而且商品规格要包含在括号里面。这样就必须把商品名称和商品规格拼接起来，变成一个字符串。 这时，我们就可以用合并字符串函数CONCAT（），如下所示：     mysql> SELECT    -> CONCAT(goodsname, '(', specification, ')') AS 商品信息 -- 这里把商品名称、括号和规格拼接起来    -> FROM    -> demo.goodsmaster    -> WHERE itemnumber = 1;    +----------+    | 商品信息 |    +----------+    | 书(16开) |    +----------+    1 row in set (0.00 sec)这样，我们就得到了商品编号是 1 的商品，它的商品信息是："书（16开）"。 第二步，我们来看一下如何打印第二行。第二行包括数量、价格、折扣和金额，一共是4 种信息。 因为一行最多是 32 个字符，我们给数量分配 7 个字符，价格分配 7个字符，折扣分配 6 个字符，金额分配 9 个字符，加上中间 3 个空格，正好是32 个字符。 为啥这么分配呢？我简单解释下。 1.  数量 7 个字符，就是小数点前面给 3 位，小数点后面给 3    位，外加小数点 1 位，最大    999.999，基本满足零售的需求了。        2.  同样道理，价格给 7 位，意思是小数点前面 4 位，小数点后面 2    位，外加小数点，这样最大可以表示    9999.99。        3.  折扣 6 位，小数点后面 2 位，小数点前面 2    位，加上小数点和"%"，这样是够用的。        4.  金额 9 位，最大可以显示到    999999.99，也够用了。        分配好了各部分信息的字符串大小，我再讲一下格式处理，因为数据的取值每次都会不同，如果直接打印，会参差不齐。这里我以数量为例，来具体说明一下。因为数量比较有代表性，而且比较简单，不像金额或者折扣率那样，有时还要根据用户的需求，加上"￥"或者"%"。 第一步，把数量转换成字符串。这里我们需要用到把数值转换成字符串的CAST（）函数，如下所示：     mysql> SELECT    -> CAST(quantity AS CHAR) -- 把decimal类型转换成字符串    -> FROM    -> demo.transactiondetails    -> WHERE    -> transactionid = 1 AND itemnumber =1;    +---------------------+    | CAST(price AS CHAR) |    +---------------------+    | 2.000 |    +---------------------+    1 rows in set (0.00 sec)第二步，计算字符串的长度，这里我们要用到CHAR_LENGTH（）函数。 需要注意的是，虽然每个汉字打印的时候占 2个字符长度，但是这个函数获取的是汉字的个数。因此，如果字符串中有汉字，函数获取的字符串长度跟实际打印的长度是不一样的，需要用空格来补齐。 我们可以通过下面的查询，获取数量字段转换成字符串后的字符串长度：     mysql> SELECT    -> CHAR_LENGTH(CAST(quantity AS CHAR)) AS 长度    -> FROM    -> demo.transactiondetails    -> WHERE    -> transactionid = 1 AND itemnumber =1;    +---------------------+    | 长度 |    +---------------------+    | 5 |    +---------------------+    1 rows in set (0.00 sec)第三步，用空格补齐 7 位长度。这时，我们要用到SPACE（）函数。 因为我们采用左对齐的方式打印（左对齐表示字符串从左边开始，右边空余的位置用空格补齐），所以就需要先拼接字符串，再在字符串的后面补齐空格：     mysql> SELECT    -> CONCAT(CAST(quantity AS CHAR),    -> SPACE(7 - CHAR_LENGTH(CAST(quantity AS CHAR)))) AS 数量    -> FROM    -> demo.transactiondetails    -> WHERE    -> transactionid = 1 AND itemnumber = 1;    +----------+    | 数量 |    +----------+    | 2.000 |    +----------+    1 row in set (0.00 sec)除此以外，MySQL 还支持SUBSTR（）、MID（）、TRIM（）、LTRIM（）、RTRIM（）。我画了一张图来展示它们的含义，你可以了解一下。 ![](Images/aa524e875974e129c66be49384bb55d1.png)savepage-src="https://static001.geekbang.org/resource/image/86/d9/86f0f4ebe3055db5c112784d86aa07d9.jpg"}一般来说，关于字符串函数，你掌握这些就足够了。不过，MySQL支持的字符串函数还有很多，如果你在实际工作中，遇到了更复杂的情况，可以参考MySQL 官方的文档slate-object="inline"。 条件判断函数我们刚才在对商品信息字符串进行拼接的时候，会有一种例外的情况，那就是当规格为空的时候，商品信息会变成"NULL"。这个结果显然不是我们想要的，因为名称变成NULL，顾客会觉得奇怪，也不知道买了什么商品。我们希望，如果规格是空值，就不用加规格了。怎么实现呢？这就要用到条件判断函数了。 条件判断函数的主要作用，就是根据特定的条件返回不同的值，常用的有两种。 1.  IFNULL（V1，V2）：表示如果 V1 的值不为空值，则返回 V1，否则返回    V2。    2.  IF（表达式，V1，V2）：如果表达式为真（TRUE），则返回 V1，否则返回    V2。    我们希望规格是空的商品，拼接商品信息字符串的时候，规格不要是空。这个问题，可以通过IFNULL(specification, \'\')函数来解决。具体点说就是，对字段"specification"是否为空进行判断，如果为空，就返回空字符串，否则就返回商品规格specification的值。代码如下所示：     mysql> SELECT        -> goodsname,        -> specification,        -> CONCAT(goodsname,'(', IFNULL(specification, ''),')') AS 拼接 -- 用条件判断函数，如果规格是空，则括号中是空字符串        -> FROM        -> demo.goodsmaster;    +-----------+---------------+----------+    | goodsname | specification | 拼接     |    +-----------+---------------+----------+    | 书        | 16开          | 书(16开) |    | 笔        | NULL          | 笔()     |    +-----------+---------------+----------+    2 rows in set (0.00 sec)结果是，如果规格为空，商品信息就变成了"商品信息（）"，好像还不错。但是也存在一点问题：商品名称后面的那个空括号"()"会让客人觉得奇怪，能不能去掉呢？ 如果用IFNULL（V1，V2）函数，就不容易做到，但是没关系，我们可以尝试用另一个条件判断函数IF（表达式，V1，V2）来解决。这里表达式是ISNULL(specification)，这个函数用来判断字段\"specificaiton\"是否为空，V1是返回商品名称，V2是返回商品名称拼接规格。代码如下所示：     mysql> SELECT        -> goodsname,        -> specification,        -> -- 这里做判断，如果是空值，返回商品名称，否则就拼接规格        -> IF(ISNULL(specification),        -> goodsname,        -> CONCAT(goodsname, '(', specification, ')')) AS 拼接        -> FROM        -> demo.goodsmaster;    +-----------+---------------+----------+    | goodsname | specification | 拼接     |    +-----------+---------------+----------+    | 书        | 16开          | 书(16开) |    | 笔        | NULL          | 笔       |    +-----------+---------------+----------+    2 rows in set (0.02 sec)这个结果就是，如果规格为空，商品信息就是商品名称；如果规格不为空，商品信息是商品名称拼接商品规格，这就达到了我们的目的。 总结今天，我们学习了用于提升数据处理效率的数学函数、字符串函数和条件判断函数。 ![](Images/b32178b2608c2d05942889925bceaee5.png)savepage-src="https://static001.geekbang.org/resource/image/06/f7/06f0cb9251af48e626b81016630f9ff7.jpg"}这些函数看起来很容易掌握，但是有很多坑。比如说，ROUND（X）是对 X小数部分四舍五入，那么在"五入"的时候，返回的值是不是一定比 X大呢？其实不一定，因为当 X为负数时，五入的值会更小。你可以看看下面的代码：     mysql> SELECT ROUND(-1.5);    +-------------+    | ROUND(-1.5) |    +-------------+    |          -2 |    +-------------+    1 row in set (0.00 sec)所以，我建议你在学习的时候，**多考虑边界条件的场景，实际测试一下**。就像这个问题，对于 ROUND(X,0)，并没有指定 X是正数，那如果是负数，会怎样呢？你去测试一下，就明白了。 思考题这节课，我介绍了如何用 FLOOR（）函数来计算会员积分，那么，如果不用FLOOR（），有没有其他办法来实现会员积分的计算呢？ 欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得今天的内容对你有所帮助，也欢迎你分享给你的朋友或同事，我们下节课见。 
# 11 \| 索引：如何提高查询的速度？你好，我是朱晓峰。在我们的超市信息系统刚刚开始运营的时候，因为数据量很少，每一次的查询都能很快拿到结果。但是，系统运转时间长了以后，数据量不断地累积，变得越来越庞大，很多查询的速度就变得特别慢。这个时候，我们就采用了MySQL 提供的高效访问数据的方法------索引，有效地解决了这个问题，甚至之前的一个需要 8秒钟才能完成的查询，现在只用 0.3 秒就搞定了，速度提升了 20多倍。 那么，索引到底是啥呢？该怎么使用呢？这节课，我们就来聊一聊。索引是什么？如果你去过图书馆，应该会知道图书馆的检索系统。图书馆为图书准备了检索目录，包括书名、书号、对应的位置信息，包括在哪个区、哪个书架、哪一层。我们可以通过书名或书号，快速获知书的位置，拿到需要的书。MySQL 中的索引，就相当于图书馆的检索目录，它是帮助 MySQL系统快速检索数据的一种存储结构。我们可以在索引中按照查询条件，检索索引字段的值，然后快速定位数据记录的位置，这样就不需要遍历整个数据表了。而且，数据表中的字段越多，表中数据记录越多，速度提升越是明显。我来举个例子，进一步解释下索引的作用。这里要用到销售流水表（demo.trans），表结构如下：    mysql> describe demo.trans;    +---------------+----------+------+-----+---------+-------+    | Field         | Type     | Null | Key | Default | Extra |    +---------------+----------+------+-----+---------+-------+    | itemnumber    | int      | YES  | MUL | NULL    |       |    | quantity      | text     | YES  |     | NULL    |       |    | price         | text     | YES  |     | NULL    |       |    | transdate     | datetime | YES  | MUL | NULL    |       |    | actualvalue   | text     | YES  |     | NULL    |       |    | barcode       | text     | YES  |     | NULL    |       |    | cashiernumber | int      | YES  | MUL | NULL    |       |    | branchnumber  | int      | YES  | MUL | NULL    |       |    | transuniqueid | text     | YES  |     | NULL    |       |    +---------------+----------+------+-----+---------+-------+    9 rows in set (0.02 sec)某个门店的销售流水表有 400 万条数据，现在我要查看一下商品编号是 100的商品在 2020-12-12这一天的销售情况，查询代码如下：    mysql> SELECT    -> quantity,price,transdate    -> FROM    -> demo.trans    -> WHERE    -> transdate > '2020-12-12'    -> AND transdate  AND itemnumber = 100;    +----------+--------+---------------------+    | quantity | price | transdate |    +----------+--------+---------------------+    | 1.000 | 220.00 | 2020-12-12 19:45:36 |    | 1.000 | 220.00 | 2020-12-12 08:56:37 |    +----------+--------+---------------------+    2 rows in set (8.08 sec)可以看到，结果总共有 2 条记录，可是却花了 8秒钟，非常慢。同时，这里我没有做表的关联，这只是单表的查询，而且只是一个门店几个月的数据而已。而总部是把所有门店的数据都汇总到一起，查询速度更慢，这样的查询效率，我们肯定是不能接受的。怎么解决这个问题呢？这时，我们就可以给数据表添加索引。单字段索引MySQL支持单字段索引和组合索引，而单字段索引比较常用，我们先来学习下创建单字段索引的方法。如何创建单字段索引？创建单字段索引，一般有 3种方式： 1.       你可以通过 CREATE    语句直接给已经存在的表创建索引，这种方式比较简单，我就不多解释了；        2.       可以在创建表的同时创建索引；        3.       可以通过修改表来创建索引。        直接给数据表创建索引的语法如下：    CREATE INDEX 索引名 ON TABLE 表名 (字段);创建表的同时创建索引的语法如下所示：    CREATE TABLE 表名    (    字段 数据类型,    ….    { INDEX | KEY } 索引名(字段)    )修改表时创建索引的语法如下所示：    ALTER TABLE 表名 ADD { INDEX | KEY } 索引名 (字段);这里有个小问题要提醒你一下，给表设定主键约束或者唯一性约束的时候，MySQL会自动创建主键索引或唯一性索引。这也是我建议你在创建表的时候，一定要定义主键的原因之一。举个小例子，我们可以给表 demo.trans创建索引如下：    mysql> CREATE INDEX index_trans ON demo.trans (transdate(10));    Query OK, 0 rows affected (1 min 8.71 sec)    Records: 0 Duplicates: 0 Warnings: 0         mysql> SELECT    -> quantity,price,transdate    -> FROM    -> demo.trans    -> WHERE    -> transdate > '2020-12-12'    -> AND transdate  AND itemnumber = 100;    +----------+--------+---------------------+    | quantity | price | transdate |    +----------+--------+---------------------+    | 1.000 | 220.00 | 2020-12-12 19:45:36 |    | 1.000 | 220.00 | 2020-12-12 08:56:37 |    +----------+--------+---------------------+    2 rows in set (0.30 sec)可以看到，加了索引之后，这一次我们只用了 0.3秒，比没有索引的时候，快了 20多倍。这么大的差距，说明索引对提高查询的速度确实很有帮助。那么，索引是如何做到这一点的呢？下面我们来学习下单字段索引的作用原理。单字段索引的作用原理要知道索引是怎么起作用的，我们需要借助 MySQL 中的 EXPLAIN这个关键字。EXPLAIN 关键字能够查看 SQL语句的执行细节，包括表的加载顺序，表是如何连接的，以及索引使用情况等。    mysql> EXPLAIN SELECT    -> quantity,price,transdate    -> FROM    -> demo.trans    -> WHERE    -> transdate > '2020-12-12'    -> AND transdate  AND itemnumber = 100;    +----+-------------+-------------+------------+-------+-------------------+-------------------+---------+------+------+----------+-----------------------------------------------+    | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |    +----+-------------+-------------+------------+-------+-------------------+-------------------+---------+------+------+----------+-----------------------------------------------+    | 1 | SIMPLE | trans | NULL | range | index_trans | index_trans | 6 | NULL | 5411 | 10.00 | Using index condition; Using where; Using MRR |    +----+-------------+-------------+------------+-------+-------------------+-------------------+---------+------+------+----------+-----------------------------------------------+    1 row in set, 1 warning (0.00 sec)我来解释下代码里的关键内容。1.  type=range：表示使用索引查询特定范围的数据记录。        2.  rows=5411：表示需要读取的记录数。        3.  possible_keys=index_trans：表示可以选择的索引是    index_trans。        4.  key=index_trans：表示实际选择的索引是    index_trans。        5.  extra=Using index condition;Using where;Using MRR：这里面的信息对    SQL 语句的执行细节做了进一步的解释，包含了 3    层含义：第一个是执行时使用了索引，第二个是执行时通过 WHERE    条件进行了筛选，第三个是使用了顺序磁盘读取的策略。        通过这个小例子，我们可以发现，有了索引之后，MySQL 在执行 SQL语句的时候多了一种优化的手段。也就是说，在查询的时候，可以先通过查询索引快速定位，然后再找到对应的数据进行读取，这样就大大提高了查询的速度。如何选择索引字段？在刚刚的查询中，我们是选择transdate（交易时间）字段来当索引字段，你可能会问，为啥不选别的字段呢？这是因为，交易时间是查询条件。MySQL可以按照交易时间的限定"2020 年 12 月 12日"，在索引中而不是数据表中寻找满足条件的索引记录，再通过索引记录中的指针来定位数据表中的数据。这样，索引就能发挥作用了。不过，你有没有想过，itemnumber 字段也是查询条件，能不能用 itemnumber来创建一个索引呢？我们来试一试：    mysql> CREATE INDEX index_trans_itemnumber ON demo.trans (itemnumber);    Query OK, 0 rows affected (43.88 sec)    Records: 0 Duplicates: 0 Warnings: 0然后看看效果：    mysql> SELECT    -> quantity,price,transdate    -> FROM    -> demo.trans    -> WHERE    -> transdate > '2020-12-12'      -- 对交易时间的筛选，可以在transdate的索引中定位    -> AND transdate  AND itemnumber = 100;         -- 对商品编号的筛选，可以在itemnumber的索引中定位    +----------+--------+---------------------+    | quantity | price | transdate |    +----------+--------+---------------------+    | 1.000 | 220.00 | 2020-12-12 19:45:36 |    | 1.000 | 220.00 | 2020-12-12 08:56:37 |    +----------+--------+---------------------+    2 rows in set (0.38 sec)我们发现，用 itemnumber创建索引之后，查询速度跟之前差不多，基本在同一个数量级。这是为啥呢？我们来看看 MySQL的运行计划：    mysql> EXPLAIN SELECT    -> quantity,price,transdate    -> FROM    -> demo.trans    -> WHERE    -> transdate > '2020-12-12'    -> AND transdate  AND itemnumber = 100;                 -- 对itemnumber 进行限定    +----+-------------+-------------+------------+------+------------------------------------------------+------------------------------+---------+-------+------+----------+-------------+    | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |    +----+-------------+-------------+------------+------+------------------------------------------------+------------------------------+---------+-------+------+----------+-------------+    | 1 | SIMPLE | trans | NULL | ref | index_trans,index_trans_itemnumber | index_trans_itemnumber | 5 | const | 1192 | 0.14 | Using where |    +----+-------------+-------------+------------+------+------------------------------------------------+------------------------------+---------+-------+------+----------+-------------+    1 row in set, 1 warning (0.01 sec)我们发现，"possible_keys= index_trans,index_trans_itemnumber"，就是说 MySQL 认为可以选择的索引确实有 2 个，一个是用 transdate字段创建的索引 index_trans，另一个是用 itemnumber 字段创建的索引index_trans_itemnumber。key= index_trans_itemnumber， 说明 MySQL 实际选择使用的索引是itemnumber 字段创建的索引 index_trans_itemnumber。而rows=1192，就表示实际读取的数据记录数只有 1192 个，比用 transdate创建的索引 index_trans 的实际读取记录数要少，这就是 MySQL 选择使用itemnumber 索引的原因。**所以，我建议你在选择索引字段的时候，要选择那些经常被用做筛选条件的字段**。这样才能发挥索引的作用，提升检索的效率。组合索引在实际工作中，有时会遇到比较复杂的数据表，这种表包括的字段比较多，经常需要通过不同的字段筛选数据，特别是数据表中包含多个层级信息。比如我们的销售流水表就包含了门店信息、收款机信息和商品信息这3个层级信息。门店对应多个门店里的收款机，每个收款机对应多个从这台收款机销售出去的商品。我们经常要把这些层次信息作为筛选条件，来进行查询。这个时候单字段的索引往往不容易发挥出索引的最大功效，可以使用组合索引。现在，先看看单字段索引的效果，我们分别用 branchnumber 和cashiernumber 来创建索引：    mysql> CREATE INDEX index_trans_branchnumber ON demo.trans (branchnumber);    Query OK, 0 rows affected (41.49 sec)    Records: 0 Duplicates: 0 Warnings: 0     mysql> CREATE INDEX index_trans_cashiernumber ON demo.trans (cashiernumber);    Query OK, 0 rows affected (41.95 sec)    Records: 0 Duplicates: 0 Warnings: 0有了门店编号和收款机编号的索引，现在我们就尝试一下以门店编号、收款机编号和商品编号为查询条件，来验证一下索引是不是起了作用。    mysql> SELECT    -> itemnumber,quantity,price,transdate    -> FROM    -> demo.trans    -> WHERE    -> branchnumber = 11 AND cashiernumber = 1 -- 门店编号和收款机号为筛选条件    -> AND itemnumber = 100;    -- 商品编号为筛选条件    +------------+----------+--------+---------------------+    | itemnumber | quantity | price | transdate |    +------------+----------+--------+---------------------+    | 100 | 1.000 | 220.00 | 2020-07-11 09:18:35 |    | 100 | 1.000 | 220.00 | 2020-09-06 21:21:58 |    | 100 | 1.000 | 220.00 | 2020-11-10 15:00:11 |    | 100 | 1.000 | 220.00 | 2020-12-25 14:28:06 |    | 100 | 1.000 | 220.00 | 2021-01-09 20:21:44 |    | 100 | 1.000 | 220.00 | 2021-02-08 10:45:05 |    +------------+----------+--------+---------------------+    6 rows in set (0.31 sec)结果有 6 条记录，查询时间是 0.31秒，跟只创建商品编号索引差不多。下面我们就来查看一下执行计划，看看新建的索引有没有起作用。    mysql> EXPLAIN SELECT    -> itemnumber,quantity,price,transdate    -> FROM    -> demo.trans    -> WHERE    -> branchnumber = 11 AND cashiernumber = 1    -> AND itemnumber = 100;    +----+-------------+-------+------------+------+---------------------------------------------------------------------------+------------------------+---------+-------+------+----------+-------------+    | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |    +----+-------------+-------+------------+------+---------------------------------------------------------------------------+------------------------+---------+-------+------+----------+-------------+    | 1 | SIMPLE | trans | NULL | ref | index_trans_itemnumber,index_trans_branchnumber,index_trans_cashiernumber | index_trans_itemnumber | 5 | const | 1192 | 20.50 | Using where |    +----+-------------+-------+------------+------+---------------------------------------------------------------------------+------------------------+---------+-------+------+----------+-------------+    1 row in set, 1 warning (0.01 sec)MySQL 有 3 个索引可以用，分别是用 branchnumber 创建的index_trans_branchnumber、用 cashiernumber 创建的index_trans_cashiernumber 和用 itemnumber 创建的index_trans_itemnumber。最后，MySQL 还是选择了 index_trans_itemnumber，实际筛选的记录数是1192，花费了 0.31 秒。为什么 MySQL 会这样选呢？这是因为，优化器现在有 3种索引可以用，分别是商品编号索引、门店编号索引和收款机号索引。优化器发现，商品编号索引实际搜索的记录数最少，所以最后就选择了这种索引。所以，**如果有多个索引，而这些索引的字段同时作为筛选字段出现在查询中的时候，MySQL会选择使用最优的索引来执行查询操作**。能不能让这几个筛选字段同时发挥作用呢？这就用到组合索引了。组合索引，就是包含多个字段的索引。MySQL最多支持由 16个字段组成的组合索引。如何创建组合索引？创建组合索引的语法结构与创建单字段索引相同，不同的是相比单字段索引，组合索引使用了多个字段。直接给数据表创建索引的语法如下：    CREATE INDEX 索引名 ON TABLE 表名 (字段1，字段2，...);创建表的同时创建索引：    CREATE TABLE 表名    (    字段 数据类型,    ….    { INDEX | KEY } 索引名(字段1，字段2，...)    )修改表时创建索引：    ALTER TABLE 表名 ADD { INDEX | KEY } 索引名 (字段1，字段2，...);现在，针对刚刚的查询场景，我们就可以通过创建组合索引，发挥多个字段的筛选作用。具体做法是，我们给销售流水表创建一个由 3 个字段branchnumber、cashiernumber、itemnumber组成的组合索引，如下所示：    mysql> CREATE INDEX Index_branchnumber_cashiernumber_itemnumber ON demo.trans (branchnumber,cashiernumber,itemnumber);    Query OK, 0 rows affected (59.26 sec)    Records: 0 Duplicates: 0 Warnings: 0有了组合索引，刚刚的查询速度就更快了：    mysql> SELECT    -> itemnumber,quantity,price,transdate    -> FROM    -> demo.trans    -> WHERE    -> branchnumber = 11 AND cashiernumber = 1    -> AND itemnumber = 100;    +------------+----------+--------+---------------------+    | itemnumber | quantity | price | transdate |    +------------+----------+--------+---------------------+    | 100 | 1.000 | 220.00 | 2020-07-11 09:18:35 |    | 100 | 1.000 | 220.00 | 2020-09-06 21:21:58 |    | 100 | 1.000 | 220.00 | 2020-11-10 15:00:11 |    | 100 | 1.000 | 220.00 | 2020-12-25 14:28:06 |    | 100 | 1.000 | 220.00 | 2021-01-09 20:21:44 |    | 100 | 1.000 | 220.00 | 2021-02-08 10:45:05 |    +------------+----------+--------+---------------------+    6 rows in set (0.00 sec)几乎是瞬间就完成了，不超过 10 毫秒。我们看看 MySQL的执行计划：    mysql> EXPLAIN SELECT    -> itemnumber,quantity,price,transdate    -> FROM    -> demo.trans    -> WHERE                         -- 同时筛选门店编号、收款机号和商品编号    -> branchnumber = 11 AND cashiernumber = 1     -> AND itemnumber = 100;    +----+-------------+-------+------------+------+-----------------------------------------------------------------------------------------------------------------------+---------------------------------------------+---------+-------------------+------+----------+-------+    | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |    +----+-------------+-------+------------+------+-----------------------------------------------------------------------------------------------------------------------+---------------------------------------------+---------+-------------------+------+----------+-------+    | 1 | SIMPLE | trans | NULL | ref | index_trans_itemnumber,index_trans_branchnumber,index_trans_cashiernumber,index_branchnumber_cashiernumber_itemnumber | index_branchnumber_cashiernumber_itemnumber | 15 | const,const,const | 6 | 100.00 | NULL |    +----+-------------+-------+------------+------+-----------------------------------------------------------------------------------------------------------------------+---------------------------------------------+---------+-------------------+------+----------+-------+    1 row in set, 1 warning (0.01 sec)这个查询，MySQL 可以用到的索引有 4个： 1.  index_trans_itemnumber；        2.  index_trans_branchnumber；        3.  index_trans_cashiernumber；        4.  我们刚才用 branchnumber、cashiernumber 和 itemnumber    创建的组合索引    Index_branchnumber_cashiernumber_itemnumber。        MySQL 选择了组合索引，筛选后读取的记录只有 6条。组合索引被充分利用，筛选更加精准，所以非常快。组合索引的原理下面我就来讲讲组合索引的工作原理。**组合索引的多个字段是有序的，遵循左对齐的原则**。比如我们创建的组合索引，排序的方式是branchnumber、cashiernumber 和itemnumber。因此，筛选的条件也要遵循从左向右的原则，如果中断，那么，断点后面的条件就没有办法利用索引了。比如说我们刚才的条件，branchnumber = 11 AND cashiernumber = 1 ANDitemnumber =100，包含了从左到右的所有字段，所以可以最大限度使用全部组合索引。假如把条件换成"cashiernumber = 1 AND itemnumber =100"，由于我们的组合索引是按照 branchnumber、cashiernumber 和 itemnumber的顺序建立的，最左边的字段 branchnumber没有包含到条件当中，中断了，所以这个条件完全不能使用组合索引。类似的，如果筛选的是一个范围，如果没有办法无法精确定位，也相当于中断。比如"branchnumber\> 10 AND cashiernumber = 1 AND itemnumber =100"这个条件，只能用到组合索引中 branchnumber\>10的部分，后面的索引就都用不上了。我们来看看 MySQL的运行计划：    mysql> EXPLAIN SELECT    -> itemnumber,quantity,price,transdate    -> FROM    -> demo.trans    -> WHERE    -> branchnumber > 10 AND cashiernumber = 1 AND itemnumber = 100;    +----+-------------+-------+------------+------+-----------------------------------------------------------------------------------------------------------------------+------------------------+---------+-------+------+----------+-------------+    | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |    +----+-------------+-------+------------+------+-----------------------------------------------------------------------------------------------------------------------+------------------------+---------+-------+------+----------+-------------+    | 1 | SIMPLE | trans | NULL | ref | index_trans_itemnumber,index_trans_branchnumber,index_trans_cashiernumber,index_branchnumber_cashiernumber_itemnumber | index_trans_itemnumber | 5 | const | 1192 | 20.50 | Using where |    +----+-------------+-------+------------+------+-----------------------------------------------------------------------------------------------------------------------+------------------------+---------+-------+------+----------+-------------+    1 row in set, 1 warning (0.02 sec)果然，MySQL 没有选择组合索引，而是选择了用 itemnumber 创建的普通索引index_trans_itemnumber。因为**如果只用组合索引的一部分，效果没有单字段索引那么好**。总结这节课，我们学习了什么是索引、如何创建和使用索引。索引可以非常显著地提高数据查询的速度，数据表里包含的数据越多，效果越显著。我们应该选择经常被用做筛选条件的字段来创建索引，这样才能通过索引缩小实际读取数据表中数据的范围，发挥出索引的优势。如果有多个筛选的字段，而且经常一起出现，也可以用多个字段来创建组合索引。如果你要删除索引，就可以用：    DROP INDEX 索引名 ON 表名;当然，有的索引不能用这种方法删除，比如主键索引，你就必须通过修改表来删除索引。语法如下：    ALTER TABLE 表名 DROP PRIMARY KEY；最后，我来跟你说说索引的成本。索引能够提升查询的效率，但是建索引也是有成本的，主要有2个方面，一个存储空间的开销，还有一个是数据操作上的开销。1.  存储空间的开销，是指索引需要单独占用存储空间。        2.  数据操作上的开销，是指一旦数据表有变动，无论是插入一条新数据，还是删除一条旧的数据，甚至是修改数据，如果涉及索引字段，都需要对索引本身进行修改，以确保索引能够指向正确的记录。        因此，索引也不是越多越好，创建索引有存储开销和操作开销，需要综合考虑。思考题假如我有一个单品销售统计表，包括门店编号、销售日期（年月日）、商品编号、销售数量、销售金额、成本、毛利，而用户经常需要对销售情况进行查询，你会对这个表建什么样的索引呢？为什么？欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得今天的内容对你有所帮助，也欢迎你分享给你的朋友或同事，我们下节课见。