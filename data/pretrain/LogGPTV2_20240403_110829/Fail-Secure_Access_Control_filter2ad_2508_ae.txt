egates and revoked direct delegates, and Rnon−direct speciﬁes
which ones S must grant and deny access to. Since the PDP
must deny access to a non-direct delegate X iﬀ the PDP
fails to check that X has at least one non-revoked chain or
X has only revoked chains, Rnon−direct conﬂates ⊥ and f into
the deny decision using the (_ (cid:73) f) pattern.
Our analysis tool shows that the PDP speciﬁcation S3
does not meet FR2 because the problem
(¬cdirect) ⇒ S = Rnon−direct
is answered negatively. The tool outputs the following PDP
input:
I = { owner(piet) ← t;
piet:delegate(ann) ← t;
ann:delegate(fred) ← t;
piet:revoke(ann)@rev ← ⊥;
ann:revoke(fred)@rev ← f } .
In this scenario, Piet is the owner, and he delegates access
to Ann, who further delegates access to Fred. Furthermore,
the PDP fails to check whether Piet’s delegation to Ann
is revoked, and it succeeds in checking that Ann has not
revoked Fred; see Figure 3. The PDP must deny access
to Fred because he does not have a non-revoked delegation
chain and he is not a direct delegate. The PDP, however,
grants access to Fred, thus violating FR2. This ﬂaw stems
from the preemptive masking of failures. The adversary Fred
can exploit this ﬂaw and force an unintended grant decision
by preventing the PDP from checking whether the owner’s
delegation to Ann is revoked. To conﬁrm the attack, we
simulated the attack scenario using our BelLog interpreter;
for details see Appendix A.
Speciﬁcation 5 (S5):
To meet FR2, we modify the speciﬁcation as follows.
pol(X) ←grant(X) (cid:73)(cid:0)owner(Y ) ∧ Y :delegate(X)∧
(¬Y :revoke(X)@rev)(cid:1)
grant(X) ←owner(X)
grant(X) ←grant(Y ) ∧ Y :delegate(X) ∧ (¬Y :revoke(X)@rev)
In the original speciﬁcation S3, errors are not propagated
through delegation chains. In contrast, the speciﬁcation S5
propagates errors through delegation chains and thus denies
access to subjects who are not direct delegates and do not
have a non-revoked chain. The pseudo-code that reﬂects S5
would have to, in eﬀect, distinguish between permissions
solely due to direct delegation versus permissions due to
non-revoked chains.
Our analysis tool shows that the speciﬁcation S5 meets FR2
for all PDP inputs in a ﬁxed policy domain with eight con-
stants; the veriﬁcation takes 149.38 seconds. Our tool did
not terminate in a reasonable time for larger domains.
We remark that domain containment gives weaker secu-
rity guarantees than (general) policy containment because
the guarantees are only for the given policy domain. Hence,
domain policy containment does not account for possible
attacks in other domains. For example, domain policy con-
tainment misses the attack described in our grid example
if the policy domain has only two constants (e.g., two sub-
jects). This is because the adversary must assume the role
of a subject who is delegated access by a direct delegate, and
such a subject does not exist in a domain with fewer than
three constants.
Generic Requirements.
In addition to the aforemen-
tioned requirements, one can verify whether a PDP meets
certain generic security requirements. For example, one may
want to ensure that a PDP handles all failures, i.e. it always
evaluates requests to either grant or deny decisions. We refer
to this requirement as error-freeness, and show how it can
be checked by formulating suitable containment problems.
Let S be the PDP speciﬁcation and pol(X) be the atom
used to denote the PDP’s access decisions. We construct
a speciﬁcation R as follows. Let R = ∅. We rename the
predicate symbol pol to tmp in S’s rules and add the changed
rules to R. Finally, we add the rule
pol(X) ← tmp(X) (cid:73) f ,
to R. We formulate the containment problem as S = R. By
construction, R denies all requests that S evaluates to ⊥.
Therefore, if S evaluates a request to ⊥, then R is not equal
to S; otherwise, S is error-free. Note that one can simi-
larly verify that any atom other than pol(·) in the PDP’s
speciﬁcation is error-free.
To conclude, these examples show that our simulation
and veriﬁcation methods can reveal security ﬂaws in PDPs
that handle failures incorrectly. Our preliminary experi-
ments show that our simulation tool scales well to realistic
problems. The runtimes for our analysis tool, however, are
mixed. In our grid example the analysis tool does not termi-
nate in a reasonable amount of time for a domain with nine
constants, whereas in the web app example the tool termi-
nates in less than a minute for domains with thousands of
constants.
6. SUMMARY AND FUTURE WORK
We have initiated the study of how failure handlers af-
fect access decisions made by a PDP, and we have provided
methods and tools to analyze their eﬀects. We have given
examples from standards and existing systems that back our
arguments.
We are currently working on employing our analysis frame-
work in physical access control systems used in industry.
Addressing BelLog’s usability is a major challenge in this
context. As future work, we also plan to improve the scala-
bility of our analysis tool, and extend our system model to
multiple communicating PDPs, where PDPs themselves can
fail.
7. ACKNOWLEDGMENTS
This work was supported in part by the Zurich Infor-
mation Security and Privacy Center. We thank Andreas
Häberli and Paul Studerus from KABA AG for their feed-
back on our system model, and Sasa Radomirovic for his
comments on the paper.
8. REFERENCES
[1] Serge Abiteboul, Richard Hull, and Victor Vianu.
Foundations of Databases. Addison-Wesley, 1995.
[2] Moritz Y. Becker. Speciﬁcation and analysis of
dynamic authorisation policies. In Proceedings of the
22nd IEEE Computer Security Foundations
Symposium, pages 203–217, 2009.
[3] Moritz Y. Becker, Cédric Fournet, and Andrew D.
Gordon. SecPAL: Design and Semantics of a
Decentralized Authorization Language. Journal of
Computer Security, pages 619–665, 2010.
[4] Moritz Y. Becker, Alessandra Russo, and Nik Sultana.
Foundations of Logic-Based Trust Management. In
Proceedings of the Symposium on Security and
Privacy, pages 161–175, 2012.
[5] Moritz Y. Becker and Peter Sewell. Cassandra:
Flexible Trust Management, Applied to Electronic
Health Records. In Proceedings of the 17th Workshop
on Computer Security Foundations, pages 139–154,
2004.
[6] Nuel Belnap. A Useful Four-Valued Logic. In Modern
Uses of Multiple-Valued Logic. D. Reidel, 1977.
[7] Bob Blakley and Craig Heath. Security Design
Patterns. Technical report, The Open Group, 2004.
[8] Matt Blaze, Joan Feigenbaum, John Ioannidis, and
Angelos Keromytis. The KeyNote Trust-Management
System Version 2. RFC 2704 (Informational), 1999.
[9] Matt Blaze, Joan Feigenbaum, and Jack Lacy.
Decentralized Trust Management. In Proceedings of
the 17th Symposium on Security and Privacy, pages
164–173, 1996.
[10] Glenn Bruns and Michael Huth. Access Control via
Belnap Logic: Intuitive, Expressive, and Analyzable
Policy Composition. Transactions on Information and
System Security, pages 1–27, 2011.
[11] Network Admission Control Conﬁguration Guide
Cisco IOS Release 15MT. http://www.cisco.com/en/
US/docs/ios-xml/ios/sec_usr_nac/configuration/
15-mt/sec-usr-nac-15-mt-book.pdf.
[12] Jason Crampton and Michael Huth. An Authorization
Framework Resilient to Policy Evaluation Failures. In
Proceedings of the 15th European Conference on
Research in Computer Security, pages 472–487, 2010.
[13] John DeTreville. Binder, a Logic-Based Security
Language. In Proceedings of the Symposium on
Security and Privacy, pages 105–113, 2002.
[14] Daniel J. Dougherty, Kathi Fisler, and Shriram
Krishnamurthi. Specifying and reasoning about
dynamic access-control policies. In Ulrich Furbach and
Natarajan Shankar, editors, IJCAR, volume 4130 of
Lecture Notes in Computer Science, pages 632–646.
Springer, 2006.
[15] Kathi Fisler, Shriram Krishnamurthi, Leo A.
Meyerovich, and Michael Carl Tschantz. Veriﬁcation
and Change-impact Analysis of Access-control
Policies. In Proceedings of the 27th International
Conference on Software Engineering, pages 196–205.
ACM, 2005.
[16] Simone Frau and Mohammad Torabi Dashti.
Integrated Speciﬁcation and Veriﬁcation of Security
Protocols and Policies. In Proceedings of the Computer
Security Foundations Symposium, pages 18 –32, 2011.
[17] Deepak Garg and Frank Pfenning. Stateful
authorization logic - proof theory and a case study.
Journal of Computer Security, 20(4):353–391, 2012.
[18] Yuri Gurevich and Itay Neeman. DKAL:
Distributed-Knowledge Authorization Language. In
Proceedings of the 21st Computer Security
Foundations Symposium, pages 149–162, 2008.
[19] Arno Haase. Java Idioms: Exception Handling. In
Proceedings of the 7th European Conference on
Pattern Languages of Programs, pages 41–70, 2002.
[20] Michael Howard, David LeBlanc, and John Viega. 24
Deadly Sins of Software Security: Programming Flaws
and How to Fix Them. McGraw Hill, 2009.
[21] KABA KES-2200.
http://www.kaba.co.nz/Products-Solutions/
Access-Control/Electric-Locking/34392-32446/
electric-strikes.html.
[22] Kerberos 5, Release 1.2.8. http://web.mit.edu/
kerberos/www/krb5-1.2/krb5-1.2.8/.
[23] Vladimir Kolovski, James Hendler, and Bijan Parsia.
Analyzing Web Access Control Policies. In Proceedings
of the 16th International Conference on World Wide
Web, pages 677–686. ACM, 2007.
[24] Barbara S. Lerner, Stefan Christov, Leon J. Osterweil,
Reda Bendraou, Udo Kannengiesser, , and Alexander
Wise. Exception Handling Patterns for Process
Modeling. IEEE Transactions on Software
Engineering, pages 162–183, 2010.
[25] Ninghui Li, J.C. Mitchell, and W.H. Winsborough.
Design of a Role-based Trust-management
Framework. In Proceedings of the Symposium on
Security and Privacy, pages 114–130, 2002.
[26] Disabling Firewall Service Lockdown due to Logging
Failures. http://technet.microsoft.com/en-us/
library/cc302466.aspx.
[27] OpenSSO Enterprise 8.0, Authentication Service
Failover. http://docs.oracle.com/cd/E19681-01/
820-3885/gbarl/index.html.
[28] Red Hat 6.5, 2.8.2.1 Firewall Conﬁguration Tool.
http://access.redhat.com/site/documentation/
en-US/Red_Hat_Enterprise_Linux/6/.
[29] Jerome H. Saltzer and Michael D. Schroeder. The
Protection of Information in Computer Systems.
Proceedings of the IEEE, pages 1278–1308, 1975.
[30] Spring Security.
http://projects.spring.io/spring-security/.
[31] Herbert H. Thompson, James A. Whittaker, and
Florence E. Mottay. Software Security Vulnerability
Testing in Hostile Environments. In Proceedings of the
Symposium on Applied Computing, pages 260–264,
2002.
[32] Petar Tsankov, Srdjan Marinovic, Mohammad Torabi
Dashti, and David Basin. Decentralized Composite
Access Control. In Principles of Security and Trust,
pages 245–264, 2014.
[33] John Viega and Gart McGraw. Building Secure
Software: How to Avoid Security Problems the Right
Way. Addison-Wesley, 2002.
[34] Jeﬀrey M. Voas and Gary McGraw. Software Fault
Injection: Inoculating Programs Against Errors. John
Wiley & Sons, 1997.
[35] IBM WebSphere.
http://www-01.ibm.com/software/websphere/.
[36] eXtensible Access Control Markup Language
(XACML) Version 3.0.
http://docs.oasis-open.org/xacml/3.0/xacml-3.
0-core-spec-cd-03-en.html.
[37] XACML Failure Handling Flaw.
https://lists.oasis-open.org/archives/xacml/
200703/doc00000.doc.
[38] eXtensible Access Control Markup Language
(XACML) Version 2.0.
www.oasis-open.org/committees/tc_home.php.
APPENDIX
A. ATTACK ON THE GRID PDP
We simulate here the attack on the grid PDP module, as
discussed in §5. To do this, we ﬁrst encode the PDP module
in our interpreter using BelLog’s ASCII format:
pol(X) :- owner(X)
pol(X) :- (pol(Y) ^ grant(Y,X))
grant(X,Y) :- (delegate(X,Y) ^
((!revoke(X,Y)@rev) -bot-> owner(X)))
The ASCII encoding of a BelLog rule a ← b is a :- b. We
write the operators ¬, ∼, and ∧ with the ASCII symbols
!, ~, and ^, respectively. To ease the writing of BelLog
speciﬁcations, we have implemented several of the syntactic
shorthands presented in §4. For example, the v-override
operator v7→ is written as -v->, where v is true (t), false (f),
bot (⊥), or top (>). Our interpreter also supports BelLog’s
extension for nesting and composing rule bodies with the
operators !, ~, and ^; see for example the last rule in the
speciﬁcation given above. For the complete ASCII syntax
see www.infsec.ethz.ch/research/software/bellog.
Second, we specify the PDP input produced by our anal-
ysis tool in §5.3:
owner(piet) :- true
delegate(piet,ann) :- true
delegate(ann,fred) :- true
revoke(piet,ann)@rev :- bot
Note that we need not explicitly write the rule
revoke(ann,fred) :- false
because the default truth value assigned to any atom is
false.
Finally, we run the interpreter and verify that the attacker
gains access. We observe that the PDP grants access to Fred
because his request pol(fred) evaluates to true. This be-
havior does not conform to FR2: the PDP must deny access
to Fred because he does not have a non-revoked delegation
chain and he is not among the owner’s direct delegates.