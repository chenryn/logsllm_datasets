我们继续用买房子来举例，如果你看房时的选择标准总是以市中心、交通便利、
价格适中为指标，这样的房子风毛麟角，基本上当你看到时，都已经被人买去了。
我们不妨换一种思维，选择市郊的房子，交通尽管要差一些，但价格便宜很多，
也许房子还可以买得大一些、质量好一些，并且由于更换了选房的想法，很快就找到
了你需要的房子了。
对于我们的散列表来说，我们事先准备多个散列函数。
f（key）=RH（key）（i=1,2.,k)
这里RH就是不同的散列函数，你可以把我们前面说的什么除留余数、折叠、平
方取中全部用上。每当发生散列地址冲突时，就换一个散列函数计算，相信总会有一
个可以把冲突解决掉。这种方法能够使得关键字不产生聚集，当然，相应地也增加了
计算的时间。
8.11.3链地址法
思路还可以再换一换，为什么有冲突就要换地方呢，我们直接就在原地想办法不
可以吗？于是我们就有了链地址法。
将所有关键字为同义词的记录存储在一个单链表中，我们称这种表为同义词子
表，在散列表中只存储所有同义词子表的头指针。对于关键字集合[12,67,56,16,25,37，
22,29,15,47，48,34），我们用前面同样的12为除数，进行除留余数法，可得到如图
8-11-1结构，此时，已经不存在什么冲突换址的问题，无论有多少个冲突，都只是在
当前位置给单链表增加结点的问题。
办H
363
---
## Page 388
大语数据结构
48
2
37
25
5
29
6
7
8
56
八
10
34
—22
II
4
图8-11-1
链地址法对于可能会造成很多冲突的散列函数来说，提供了绝不会出现找不到地
址的保障。当然，这也就带来了查找时需要遍历单链表的性能损耗。
8.11.4公共溢出区法
这个方法其实就更加好理解，你不是冲突吗？好吧，凡是冲突的都跟我走，我给
你们这些冲突找个地儿待着。这就如同孤儿院收留所有无家可归的孩子一样，我们为
所有冲突的关键字建立了一个公共的溢出区来存放。
就前面的例子而言，我们共有三个关键字（37.48.34）与之前的关键字位置有冲突，
那么就将它们存储到溢出表中，如图8-11-2所示。
364
---
## Page 389
第8章查找
12
37
25
48
八
34
15
16
29
八
八
67
八
57
八
10
22
10
11
47
11
基本表
溢出表
图8-11-2
在查找时，对给定值通过散列函数计算出散列地址后，先与基本表的相应位置进
行比对，如果相等，则查找成功；如果不相等，则到溢出表去进行顺序查找。如果相
对于基本表面言，有冲突的数据很少的情况下，公共溢出区的结构对查找性能来说还
是非常高的。
8.12散列表查找实现
说了这么多散列表查找的思想，我们就来看看查找的实现代码。
8.12.1散列表查找算法实现
首先是需要定义一个散列表的结构以及一些相关的常数。其中HashTable就是散
列表结构。结构当中的elem为一个动态数组。
define sUccEss 1
365
---
## Page 390
大据数据结构
define UNSUCCESs 0
#define HASHSIZE 12
/定义散列表长为数组的长度*/
define NULLKEY -32768
typedef struct
int *elem;
数据元素存储基址，动态分配数组·/
int count;
当前数据元素个数·
)HashTable;
intm=0;
/散列表表长，全局变量*/
有了结构的定义，我们可以对散列表进行初始化。
/初始化散列表·/
Status InitHashTable（HashTable *H)
int i;
EZISHSVH=
H->count=m;
H->elem=（int·）malloc（m*sizeof（int））;
for（i=0;ielem[1]=NULLKEY;
return OK;
\
为了插入时计算地址，我们需要定义散列函数，散列函数可以根据不同情况更改
算法。
/数列函数*/
int Hash（int key）
returnkeym;/*除留余数法*/
初始化完成后，我们可以对散列表进行插入操作。假设我们插入的关键字集合就
是前面的{12,67,56,16,25,37,22,29,15,47,48,34)。
/插入关健字进散列表*/
void InsertHash(HashTable*H,int key)
int addr=Hash（key）;
1·求散列地址·/
366
---
## Page 391
第8章查找
while（H->elem[addr]！=NULLKEY）/如果不为空，则冲灾*/
1开放定址法的线性探测*/
H->elem[addr]-key]
直到有空位后插入关键半·/
代码中插入关键字时，首先算出散列地址，如果当前地址不为空关键字，则说明
有冲突。此时我们应用开放定址法的线性探测进行重新寻址，此处也可更改为链地址
法等其他解决冲突的办法。
散列表存在后，我们在需要时就可以通过散列表查找要的记录。
/数列表查找关键字*/
Status SearchHash （HashTable H,int key,int *addr)
*addr -Hash （key）:
/*求散列地址*/
while（H.elem[*addr)!=key)
/如果不为空，则冲突*/
1
*addr=（*addr+1）m
开放定址法的线性探测·
（（x）1[]）
（/如果循环回到原点·/
return UNSUCCESS;
/则说明关键字不存在*/
return SUccESS;
F
查找的代码与插入的代码非常类似，只需做一个不存在关键字的判断而已。
8.12.2散列表查找性能分析
最后，我们对散列表查找的性能作一个简单分析。如果没有冲奖，散列查找是我
们本章介绍的所有查找中效率最高的，因为它的时间复杂度为0（1）。可惜，我说的只
是“如果”，没有冲突的散列只是一种理想，在实际的应用中，冲突是不可避免的。那
么散列查找的平均查找长度取决于哪些因素呢？
1.散列函数是否均匀
散列函数的好坏直接影响着出现冲突的频繁程度，不过，由于不同的散列函数对
同一组随机的关键字，产生冲突的可能性是相同的，因此我们可以不考虑它对平均查
我长度的影响。
367
---
## Page 392
大语数据结构
2.处理冲突的方法
相同的关键字、相同的散列函数，但处理冲突的方法不同，会使得平均查找长度
不同。比如线性探测处理冲突可能会产生堆积，显然就没有二次探测法好，而链地址
法处理冲突不会产生任何堆积，因而具有更佳的平均查找性能。
3.散列表的装填因子
所谓的装填因子x=填入表中的记录个数/散列表长度。a标志着散列表的装满的程
度。当填入表中的记录越多，就越大，产生冲突的可能性就越大。比如我们前面的例
子，如图8-11-5所示，如果你的散列表长度是12，而填入表中的记录个数为11，那
么此时的装填因子a=11/12=0.9167，再填入最后一个关键字产生冲突的可能性就非常
之大。也就是说，散列表的平均查找长度取决于装填因子，而不是取决于查找集合中
的记录个数。
不管记录个数n有多大，我们总可以选择一个合适的装填因子以便将平均查找长
度限定在一个范围之内，此时我们散列查找的时间复杂度就真的是0（1）了。为了做到
这一点，通常我们都是将散列表的空间设置得比查找集合大，此时虽然是浪费了一定
的空间，但换来的是查找效率的大大提升，总的来说，还是非常值得的。
8.13总结回顾
我们这一章全都是围绕一个主题“查找”来作文章的。
首先我们要弄清楚查找表、记录、关键字、主关键字、静态查找表、动态查找表
等这些概念
然后，对于顺序表查找来说，尽管很土（简单），但它却是后面很多查找的基础，
有序查找，我们着重讲了折半查找的思想，它在性能上比原来的顺序查找有了质
的飞跃，由0（n）变成了0（ogn）。之后我们又讲解了另外两种优秀的有序查找：插值
查找和斐波那契查找，三者各有优缺点，望大家要仔细体会。
线性索引查找，我们讲解了稠密索引、分块索引和倒排索引。索引技术被广泛的
用于文件检索、数据库和搜索引擎等技术领域，是进一步学习这些技术的基础。
二叉排序树是动态查找最重要的数据结构，它可以在兼顾查找性能的基础上，让
368
---
## Page 393
第8章查找
插入和删除也变得效率较高。不过为了达到最优的状态，二叉排序树最好是构造成平
衡的二叉树才最佳。因此我们就需要再学习关于平衡二叉树（AVL树）的数据结构，
了解AVL树是如何处理平衡性的问题。这部分是本章重点，需要认真学习掌握。
B树这种数据结构是针对内存与外存之间的存取而专门设计的。由于内外存的查
找性能更多取决于读取的次数，因此在设计中要考虑B树的平衡和层次。我们讲解时
是先通过最最简单的B树（2-3树）来理解如何构建、插入、删除元素的操作，再通
过2-3-4树的深化，最终来理解B树的原理。之后，我们还介绍了B+树的设计思想。
散列表是一种非常高效的查找数据结构，在原理上也与前面的查找不尽相同，它
回避了关键字之间反复比较的烦琐，而是直接一步到位查找结果。当然，这也就带来
了记录之间没有任何关联的弊端。应该说，散列表对于那种查找性能要求高，记录之
间关系无要求的数据有非常好的适用性。在学习中要注意的是散列函数的选择和处理
冲奖的方法。
8.14结尾语
我们的“Search”技术探索之旅结束了，但也许，你们对它的探索才刚刚开始。
我们在开篇时谈到了搜索引擎改变了我们的生活，让我们获得信息的速度提升了无数
倍。可是当前像Google这样的搜索引擎，是否就完美无缺了呢？未来的搜索应该又是
什么样的？在本章的最后，我根据了解到的信息给大家做一个抛砖引玉。
目前流行的搜索引擎，都是一个搜索框可以搜索一切信息。这本是好事情，可问
题在于常常在我们输入关键词后，搜索获得的前面几十条都不是我们需要的信息，这
的确很令人沮丧。
比如说，我非常喜欢高尔夫运动，平时也经常搜索关于高尔夫的比赛、活动的新
闻等信息。有一天，我想了解老虎伍兹最近有哪些比赛，于是在搜索框中输入了“老
虎”，却得到了图8-14-1所示的结果。
369
---
## Page 394
大调数据结构
Googe搜索
2010年11月27日池次（1g1），动售，也是路地上场大的省肉动物之一+是当今
成百百科
洲流有的于食物质的内动物之一具有此物中最长的大齿
功物之神的贷的保护
ien17319.m : R世RK-表G
老氏-互动百
大的一种，是证州的持有种类·原户地主图基东北正和东用证·疾是种基营通化
），称、大生，基城纳中相的四大型强
图8-14-1
显然这并不是我所希望得到的答案。你们可能会说，那是因为你的搜索关键词不
够好造成的，应该输入“老虎伍兹”更恰当。可问题的关键在于，就算我输入了“老
虎伍兹”，搜索引擎是否知道，我最感兴趣的是高尔夫运动员比赛信息，而非他和老婆
离婚等八卦新闻呢？如图8-14-2所示。
老虎伍兹
Google
0.00时0.17岁
格：伍位，推基百科，自由的百科全书-[为满阿页]
文速克：燕格（（Edk“TgrWos，197年12月30-）·美国基尔央球手，前型
界排名前位，并提公认为史上最成的的基尔央球手之一
历wopedaong变%摄量-Hp强
泰检伍_百座百科
文进流克格（正是美国高印央球手，至2009年世界增名位，并公认为史上成功的惠
历程--间道世量门
你决球手之一·固为在周交中他的排号T的思基“货”，新以在中文中经常
taike.baiducon
/12613-同页使支
近往夫妇正式宣市离质_同基体育
2009年11月27日5以维拉情人，成丑间，小三二航包，文外值出
乘时码间24日，车辆引建毛次核色丑间个乡月后，以央旧正式富布