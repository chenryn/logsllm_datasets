## Page 111
The Checklist
检查清单
DockerUl
在继续之前，让我们看看部署管道的基本实现进行到哪一步了（见图7-3。）。
除非特别指定，否则，DockerUI会运行在我们创建的所有虚拟机上。
（7）集成容器-
（6）在生产服务器上部署容器一
（5）将容器推送到镜像库-
（4）构建容器一
（3）编译并打包代码—
（2）运行部署前测试一
（1）检出代码一
Dashboard
mages created
Containers created
Running Containers
一已完成。
一已完成。
一待完成。
图7-2Docker UI dashboard 界面
一已完成。
一已完成。
-已完成。
待完成。
Status
7.1在生产服务器上部署容器
nfc
97
---
## Page 112
98
第7章部署管道的实现——
vagrant destroy -f
exit
节省资源。在第8章将创建新的虚拟机。
无法运行集成测试。
离零停机部署又更近了一步。
稍后将讨论蓝-绿部署（blue-green deployment)过程，这会帮助我们解决此类问题，
短，这样的停机时间都会妨碍我们转向持续部署。现在先把这个问题记录下来。
使用。旧的版本需要停止，新的版本需要一些时间来启动。不论这个时间长或
来完成的。如果部署第二个发行版，则会有一段时间旧的版本与新的版本都无法
生产服务器上的操作
在CD节点上的操作
构建容器
我们将使用新的虚拟机来试验服务发现工具，
进展不断，
请注意，
家推送
（9）将测试容器推送到镜像库-
（8）运行部署后测试一
与之前章节的步骤不同，生产环境的部署是通过远端的 Docker API
，检查清单里只有三个待完成任务了。但应用还没有集成，现在还
一中间阶段
下面将继续讨论另外两个概念：服务发现和反向代理。
图 7-3基于Docker的部署管道的中间阶段
检出代码
18
待完成。
待完成。
现在运行的虚拟机将被终止以
在和之停
移集间机
除成有
旧新短
版版暂
体本的
---
## Page 113
他人知道，如图8-1所示。
该指定端口，而应该让 Docker 来随机分配。唯一的问题是需要发现端口号并让其
挑战。把那些服务所需的数据库也算上，数量会更多。因此，在部署服务时不应
同一个端口。正确地管理数百个服务所使用的所有端口的列表，这本身就是一种
使用预定义端口，服务越多，就越有可能发生冲突。毕竟两个服务无法监听
做事情花不了多少力气，真正花力气的是决定做什么。
图8-1单节点中服务部署为Docker容器
Service Discovery -
发现服务
容器
容器
节点-01
阿尔伯特·哈伯德（ElbertHubbard）
Distributed Services
容器
容器
分布式服务的关键
The Key to
第8章
---
## Page 114
100
第8章发现服务一
多。为了能定位服务，至少需要提供下面两个过程。
把 IP 地址添加到数据列表并保存在某处以供查找，如图 8-2 所示。
务自动恢复问题。而且，如果想把服务部署在运行最少容器的服务器上，就需要
带来的另一个问题是难以自动调整服务的规模，更别提因为服务器故障引起的服
量利用服务器的资源，但预定义服务运行的服务器让这一目标变得难以实现。它
杂。可以选择预定义每个服务运行的服务器，但这会带来很多问题。我们应当尽
当使用服务时，需要保存和获取（发现）服务的相关信息，这样的例子有很
当开始使用分布式系统，并在多台服务器上部署服务时，情况会变得更加复
除了这些过程，
（1）服务注册过程至少要保存服务运行的主机和端口。
容器
容器
（2）服务发现过程允许其他人发现在注册过程中保存的信息（见图8-3）。
节点-01
一分布式服务的关键
容器
容器
，还需要考虑其他几个概念。如果服务终止，
图8-2多节点与服务部署为Docker 容器
图8-3服务注册与服务发现
服务
注册
容器
容器
服务数据存储
节点-02
容器
容器
服务
发现
容器
容器
节点-03
就应该将其注销
容器
容器
---
## Page 115
Service Registration
服务注册
8.1
复服务的正常功能。第15章会更详细讨论这种场景。
据。但是，总有一些情况下服务是由于故障而停止的，需要采取额外的措施来恢
的情况会更复杂一点。如果这是计划内的活动，就应当从注册表中删除服务数
它的数据（至少是IP和端口）就应当保存在服务注册表里。服务被销毁或停止时
表）。虽然服务注册的逻辑非常简单，但其实现可能比较复杂。一旦服务被部署，
时，这些变化的信息都要保存在数据库中（我们称之为服务注册表，或者简称注册
转移到另一台服务器上，它们总是在不断地发展变化。每当服务的属性发生变化
它应该发布一些API，以便有需要的访问者可以轻松访问其数据。
要处理海量数据，但服务注册表只有相对较小的数据负荷。由于该任务的性质，
错等。本质上，服务注册表就是一个功能非常有限的数据库。其他数据库可能需
名，包括上面的两个过程)和相关的工具。它们中的大多数都支持高可用的键/值存
发现过程密切相关，它们都是第9章的主题。现在让我们只关注服务发现（常用
Service Registry
服务注册表
有好几种方法可以实现服务注册。
微服务往往是非常动态的，它们被创建和销毁，部署在一台服务器上，然后
在开始评估不同的工具之前，没有更多要介绍的了，接下来是服务注册。
服务注册表的目标非常简单，就是能够保存服务信息，要求快速、持久、容
8.1服务注册表101
---
## Page 116
102
第8章发现服务一
Self-Registration
主动注册
高。因此，我们应该考虑替代方案。
话）。
止。在这种情况下，总是能主动地注销服务是非常困难的（如果不是不可能的
划停止的，它们可能会以意想不到的方式发生故障，正在运行的进程可能会停
务按计划停止时，从注册表中删除其数据是比较简单的。然而，服务不总是按计
能力。我们增加了它们对外部资源的依赖（在这个例子里是注册库）。
务，每个服务都要包含该库，但是这种方法严重限制了创建自给自足的微服务的
个系统的情况下自由修改任何服务。另外一种方法是创建一个库来实现注册服
非常麻烦。此外，这也是我们不使用单体应用的原因之一，我们希望在不影响整
册服务耦合起来。
加上注册代码，因此增加了开发的复杂性。更重要的是，这会使服务与特定的注
是一种反模式。这种方法违背了单一职责（single concerm）原则和限界上下文
的存在，并发送相关数据。由于每个服务都要给注册表发送数据，所以这被认为
（bounded context）原则，这都是微服务中试图遵循的原则。因为需要给每个服务
尽管主动注册很常见，但对此类操作来说，这既不是最合适的，效率也不
使用主动注册（见图8-4）的概念，注销操作问题很快变得非常复杂。一个服
注册服务信息常见的方法是主动注册。当部署服务时，服务会通知注册表它
部保据务务
一分布式服务的关键
时数服服
“一旦服务的数量增加，修改所有的服务，比如改变注册表，
图8-4主动注册
服务数据存储
服务
注册
负册销务
责和的
注注服
都
---
## Page 117
Service Discovery
服务发现
Registration Service
注册服务
务），它至少需要知道服务在哪。
在微服务代码中引入不必要的耦合。
注销的过程为服务注册机，或者简称注册机（实际上，很快你会看到一种同名的产
补救操作，
为一个附加的功能，
的过程。
服务负责检查哪些微服务正在运行并相应
服务发现是服务注册的反过程。
既然已经搞清楚了服务注册过程的逻辑，
与主动注册相比，
注册服务或第三方注册是管理所有月
。注册服务应该能检测到不再存在的微服务并从注册表中删除其数据。
比如重新部署不存在的微服务、发送邮件通知等。我们称这种注册和
注服删
部保据务务
署存
务务止除
时数服服
它可以通知其他过程微服务已不存在，相应地，要执行一些
独立的注册服务是更好的选择，
图8-5注册服务
一种可行的方法是主动发现。
客户端想访问服务时（客户端可能是另一个服
发送服务信息
服务注册表
监视服务
注册机
目应地更新注册表。服务停止时也使用类似
服
服
服务的注册和注销的过程（见图8-5）。该
务
是时候来讨论服务发现了。
它往往更可靠，同时不会
每新或有注送服表
当的删服册数务
部服除务机据注
署务现时发给册
8.1服务注册表103
作
---
## Page 118
104
第8章发现服务一
Service Discovery Tools
服务发现工具
已经有很多工具了。但是，容器把对此类工具的需求提升到了一个新的高度。
命，它们需要知道每项服务在哪。这并不是什么新的概念，在 Docker 出现以前就
能够帮助我们的工具。
务所在的 IP 和端口。代理服务往往是完成此类任务的最好工具。
节。这个地址不提供任何服务，但需要能够检测到这样的请求并重定向给实际服
books-ms 提供的图书列表。注意，这里没有任何 IP、端口或其他与部署相关的细
来访问每个服务。例如，只能使用地址[DOMAIN]/api/v1/books 来访问由服务
介绍一下代理服务，第9章会做进一步的讨论。想法是通过一个或多个固定的地址
代理服务
主动注册一样。就我们现在所了解的，这是一个应该被放弃的选项。
信时才能被有效使用。这种有限的场景依然带来很多额外的问题，很多问题都与
不意味着别人能够使用它，或知道该如何使用它。主动发现只有在内部服务间通
同的后端服务发送请求。实际情况是，我们的确把信息保存在注册表中了，但这
关，与之不同，客户端和服务可能使用的主动发现超出了我们的控制范围。
要查询注册表。主动注册带来的大多数问题与服务和注册表的内部连接方式有
主动发现
例子就是运行在浏览器中的前端。前端需要向运行在不同端口或不同IP的很多不
服务发现工具的主要目的是帮助服务互相发现和互相交流。要完成这样的使
对于要实现的功能，已经有了大概的、但愿是清晰的想法，下面来看看一些
代理服务已经存在很长时间了，并多次证明了它们的价值。现在让我们简单
主动发现使用与主动注册相同的原则。
一分布式服务的关键
想要访问其他服务的客户端或服务，需
一个
---
## Page 119
能够终止服务或进行版本更新。还应当能够重新配置服务并相应地看到数据的变
节点都应当有相同的数据副本。更进一步，我们希望能够以任何顺序启动服务，
对工具的健壮性有一定要求，个节点的故障不会危及数据的安全。同时，每个
是否健康和可用，以及它的配置。因为要用多台服务器来构建分布式系统，所以
者，即消费者、代理和提供者。
稍后本书会讨论反向代理。就目前而言，重要的是要理解这个流程有三个参与
如果注册表的每次变化都会更新代理的配置，就不需要代理去查询服务注册表，
发现服务来找到提供者的信息并重定向消费者的请求。实际上，在很多情况下，
消费者总是向固定的地址请求信息，该地址属于代理服务，相应地，代理将使用
了使消费者与注册表的特定实现相分离，我们经常使用代理服务。这种情况下，
时，它会首先查询注册表，然后使用从注册表中获得的 IP 和端口调用提供者。为
供者，就要在选定的服务注册表中保存其信息。随后，当消费者试图访问提供者
服务可以用这些API来发现该服务的信息。