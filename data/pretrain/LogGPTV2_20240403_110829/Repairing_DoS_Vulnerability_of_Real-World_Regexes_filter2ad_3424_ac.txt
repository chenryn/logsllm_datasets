the string as (|aa|,Γ1) ∈ {(0,Γ0), (2,Γ1)}.
We define the size of the derivation a matching relation to
be the number of nodes in the derivation tree. Note that the
size is well defined because our rules are deterministic.
Definition III.2 (Running time). For a regex r and a string
w, we define the running time of the backtracking matching
algorithm on r and w, Time(r,w),
to be the size of the
derivation of (r,w,0, /0)(cid:59) N .
Definition III.3 (Vulnerable Regular Expressions). We say
that an expression r is vulnerable if Time(r,w) /∈ O(|w|).
Note that a regex r is vulnerable iff there exist infinitely
many strings w0, w1,. . . such that Time(r,wi) (for i ∈ N) grows
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:33:43 UTC from IEEE Xplore.  Restrictions apply. 
42063
super-linearly in |wi|. Such strings are often called attack
strings. For example, (a∗)∗ in Example III.1 and (a∗)1\1 in
Example III.3 are vulnerable because there exist attack strings
{anb | n ∈ N} on which (a∗)∗ and (a∗)1\1 respectively take
Ω(n!) and Ω(n2) time. Indeed, running an actual regex engine
such as Python’s re on these regexes with these attack strings
exhibits a super-linear behavior. By contrast, ((?=a)∗)∗ in
Example III.2 takes O(n) time on these strings and is in fact
invulnerable.
Our matching semantics captures the behavior of common
backtracking matching algorithms used in most real regex
engines, e.g., ones based on path traversal of some non-
deterministic automaton [12], [13], [17]. We remark that our
formal semantics may be less efficient than an actual regex
engine because it computes all possible runs without any
optimization. However, it is sound for defining invulnerability,
and our repair algorithm synthesizes regexes that are invul-
nerable even with respect to the inefficient formal semantics.
This implies that if a pure regex is considered vulnerable
according to the definition of vulnerability in [12] then it is
also considered vulnerable according to our definition.
It is worth noting that (a∗)∗ is incorrectly classified as
invulnerable by [12], both according to their formal definition
of vulnerability and by their vulnerability detection tool.
Although the bug is fixable by adding ε transitions to their
NFA-based definition in a certain way, this shows the subtlety
of formalizing vulnerability.
IV. RWS1U AND ITS REPAIR PROBLEM
This section presents our PBE repair algorithm. First, we
define the novel notion of real-world strong 1-unambiguity
(RWS1U) and prove it to be sound for ensuring invulnerability
(Section IV-A). Then, we define RWS1U repair problem to be
the problem of synthesizing a regex that correctly classifies the
given positive and negative examples, satisfies RWS1U, and is
syntactically close to the pre-repair regex (Section IV-B). We
prove that the RWS1U repair problem is NP-hard. Section V
presents an algorithm for solving the RWS1U repair problem.
A. Real-World Strong 1-Unambiguity
We begin by introducing some preliminary notions.
Definition IV.1 (Bracketing). The bracketing of r, r[],
is
obtained by inductively mapping each subexpression s of r
to [is]i where i is a unique index. Here, [i and ]i are called
brackets and are disjoint from the alphabet Σ of r.
Note that r[] is a regex over the alphabet Σ∪Ψ, where Ψ =
{[i, ]i|i ∈ N}. We call Ψ the bracketing alphabet of r[]. For
example, for r = ((a)∗)∗b, the bracketing is
r[] = [1[2([3([4a]4)∗]3)∗]2[5b]5]1
with the bracketing alphabet {[i, ]i | i ∈ {1,2,3,4,5}}.
Definition IV.2 (Lookaround removal). The regex r with
its lookarounds removed, rmla(r), is r but with each of its
lookaround replaced by ε.
A non-deterministic automaton (NFA) over an alphabet Σ
is a tuple (Q,δ ,q0,qn) where Q is a finite set of states, δ ⊆
Q× (Σ∪{ε})× Q is the transition relation, q0 is the initial
state, and qn is the accepting state.
Definition IV.3 (eNFAtr). For a lookaround-free regex r over
Σ, its extended NFA translation, eNFAtr(r[]), is a NFA over
Σ∪ Ψ defined by the rules shown in Figure 2 where Ψ is the
bracketing alphabet of r[].
In the translation shown in Figure 2, we maintain a global
map I from capturing group indexes to states. I is initially
empty and is updated whenever a capturing group (r)i
is
encountered so that I (i) is set to be the initial state of the NFA
constructed from r. Fst(q) is defined as follows: ρa ∈ Fst(q)
iff ρ ∈ Ψ∗, a ∈ Σ, and there is a ρa-labeled path from q.
We define ρa♮ = a, and Fst(q)♮ = {a | ρa ∈ Fst(q)}. Roughly,
Fst(q)♮ is the set of characters that r can reach without any
character consumption where q is the initial state of eNFAtr(r).
For example, for r = ab|ac|d∗e f , Fst(q)♮ = {a,d,e} where q
is the initial state of eNFAtr(r).
Our extended NFA translation may be seen as the standard
Thompson’s translation for pure regexes [35], [36] extended
to real-world regexes. However, unlike the Thompson’s trans-
lation, it does not preserve the semantics (necessarily not
so because real-world regexes are not regular even without
lookarounds). Instead, we use the translation only for the
purpose of defining RWS1U. For a pair of states q and q′
of a NFA, we write paths(q,q′) for the set of strings that take
the NFA from q to q′.
Definition IV.4 (Bps). For r a regex over Σ, Ψ the bracketing
alphabet of r[], [i∈ Ψ, a ∈ Σ, and ( ,δ ,
, ) = eNFAtr(r[]), we
define Bps(r, [i,a) to be the set below:
{ρ ∈ Ψ∗ | ∃(q j, [i, ), (ql,a, ) ∈ δ .ρ ∈ paths(q j,ql)}.
Roughly, Bps(r, [i,a) are the sequences of brackets appear-
ing in paths from the unique edge labeled [i to an edge labeled
a in the extended NFA translation of r.
Example IV.1. Figure 3 shows the extended NFA translation
of (a∗)∗ where unlabeled edges denote ε transitions. Note that
Bps((a∗)∗, [1,a) = {[1([2]2)n[2[3 | n ∈ N}.
Definition IV.5 (RWS1U). We say that a regex r sat-
isfies
(1)
|Bps(rmla(r), [i,a)| ≤ 1 for all a ∈ Σ and [i ∈ Ψ where Ψ is
the bracketing alphabet of rmla(r)[] and (2) lookarounds in r
do not contain repetitions and backreferences.
real-world strong 1-unambiguity (RWS1U)
if
Roughly, condition (1) ensures that the matching algorithm
can determine which subexpression to match next by looking
at the next character in the input string. It therefore rules
out the need for backtracking. The condition is inspired by a
notion called strong 1-unambiguity for pure regexes [27] and
can be seen as an extension of it to regexes containing back-
references. We do not impose the condition in lookarounds,
because the condition prohibits some important use patterns
of them. For instance, it will preclude any meaningful use
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:33:43 UTC from IEEE Xplore.  Restrictions apply. 
52064
eNFAtr([C]) = ({q0,q1},{(q0,a,q1) | ∀a ∈ C},q0,q1)
eNFAtr(r1r2) = (Q1 ∪ Q2,δ1 ∪ δ2 ∪{(qn1 ,ε,q02 )},q01 ,qn2 ) where (Q1,δ1,q01 ,qn1 ) = eNFAtr(r1) and (Q2,δ2,q02 ,qn2 ) = eNFAtr(r2)
eNFAtr(r1|r2) = (Q1 ∪ Q2 ∪{q0,qn},δ1 ∪ δ2 ∪{(q0,ε,q01 ), (q0,ε,q02 ), (qn1 ,ε,qn), (qn2 ,ε,qn)},q0,qn)
where (Q1,δ1,q01 ,qn1 ) = eNFAtr(r1) and (Q2,δ2,q02 ,qn2 ) = eNFAtr(r2)
eNFAtr(r∗) = (Q∪{q0,qn},δ ∪{(q0,ε,q01 ), (q0,ε,qn), (qn1 ,ε,qn), (qn1 ,ε,q01 )},q0,qn) where (Q,δ ,q01 ,qn1 ) = eNFAtr(r)
eNFAtr((r)i) = eNFAtr(r) and I = I [i (cid:55)→ q0] where eNFAtr(r) = ( ,
eNFAtr(\i) = ({q0,q1},{(q0,a,q1) | a ∈ Fst(I (i))♮}∪{(q0,ε,q1) | (r)i and ε ∈ L(r)},q0,q1)
,q0, )
Fig. 2: The extended NFA translation.
Fig. 3: The extended NFA translation of (a∗)∗.
of a positive lookahead because if the lookahead succeeds
then the subexpression immediately following the lookahead
must match the same string. Therefore, for lookarounds, we
impose the condition stipulated by (2). The condition prohibits
repetitions and backreferences to appear in a lookaround and
ensures that the matching within a lookaround finishes in
constant time. Therefore, (1) and (2) combined guarantee that
the overall matching finishes in linear time.
Example IV.2. Recall r1 = (a∗)∗, r2 = ((?=a)∗)∗, r3 = (a∗)1\1
from Examples III.1, III.2, III.3. The regex r1 does not satisfy
the RWS1U condition because as shown in Example IV.1,
|Bps(r1, [1,a)| = ℵ0 > 1. Also, r3 does not satisfy the RWS1U
condition because Bps(r3, [1,a) = {[1[2[3[4, [1[2[3]3]2[5} where
3 = [1[2([3([4a]4)∗]3)1]2 [5\1]5]1,
r[]
and so |Bps(r3, [1,a)| = 2 > 1. By contrast, r2 (trivially) sat-
isfies the RWS1U condition because rmla(r2) = (ε∗)∗ which
contains no characters.
Example IV.3. The regex r4 = a∗b∗ satisfies the RWS1U
condition because |Bps(r4, [i,a)| = |Bps(r4, [i,b)| = 1 for i ∈
{1,2,3}, and |Bps(r4, [i,a)| = 0 and |Bps(r4, [i,b)| = 1 for
i ∈ {4,5}, where r[]
4 = [1[2([3a]3)∗]2 [4([5b]4)∗]5]1. The regex
r5 = ((?=·∗)·)∗ does not satisfy the RWS1U condition because
the positive lookahead contains a repetition, violating condi-
tion (2).
We show that RWS1U is a sufficient condition for invulner-
ability.
Theorem IV.1. A regex that satisfies RWS1U is invulnerable.
The proof appears in the Appendix. We remark that while
RWS1U is a sufficient condition, it is not a necessary condition
for invulnerability. For example, a|aa is invulnerable but does
not satisfy RWS1U.
Finally, we note that a related notion called 1-unambiguity
for pure regexes (also called deterministic regexes) [24], [28],
[29] is insufficient for guaranteeing invulnerability (even for
pure regexes). For example, (a∗)∗ is 1-unambiguous, because
any character occurs at most once, but it is vulnerable as shown
in Section III-B2.
B. Repair Problem
In this section, we define the RWS1U repair problem. First,
we adapt the notion of distance between regexes from a recent
work on PBE regex repair [22]. In what follows, a regex is
identified with its abstract syntax tree (AST) representation.
For an AST r, we define its size, |r|, to be the number of
nodes of r.
Definition IV.6 (Distance). For non-overlapping subtrees r1,
. . . , rn of a regex r, an edit r[r′
n/rn] replaces each ri
i|. The distance
with r′
between r1 and r2, D(r1,r2), is the minimum cost of an edit
that transforms r1 to r2.
i. The cost of the edit is ∑i∈{1,...,n}|ri|+|r′
1/r1,··· ,r′
For example, D(a|b|c,d|c) = 4, which is realized by the edit
that replaces a|b by d. We now define the repair problem.
Definition IV.7 (RWS1U Repair Problem). Given a regex r1,
a finite set of positive examples P ⊆ Σ∗, and a finite set of
negative examples N ⊆ Σ∗ where P ⊆ L(r1) and L(r1)∩N = /0,
the real-world strong 1-unambiguity repair problem (RWS1U
repair problem) is the problem of synthesizing r2 such that
(1) r2 satisfies RWS1U, (2) P ⊆ L(r2), (3) N ∩ L(r2) = /0, and
(4) D(r1,r2) ≤ D(r1,r3) for any regex r3 satisfying (1)-(3).
Condition (1) guarantees that the repaired regex r2 is invul-
nerable. Conditions (2) and (3) assert that r2 correctly classifies
the examples. Condition (4) says that r2 is syntactically close
to the original regex r1.
We note that the repair problem is easy without the close-
ness condition (4): one can construct an invulnerable regex
that accepts just P (or Σ∗ \ N) in time linear in ∑w∈P|w|
(or ∑w∈N |w|). However, such a regex is unlikely to be one
it suffers from overfitting.
intended by the user,
Condition (4) is an important ingredient of a PBE synthesis
and repair that biases the solution toward the intended one. The
assumption is that the given regex may not be quite correct
but is close to the one user intended.
that
is,
2Further details are in Appendix E.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:33:43 UTC from IEEE Xplore.  Restrictions apply. 
62065
Algorithm 1: The repair algorithm
Input: regex r, positive examples P, negative examples N
Output: a RWS1U regex that is consistent with P and N
1: Q ← { r }
2: while Q is not empty do
3:
4:
5:
6:
7:
8:
9:
Φ ← getInvulnerableConstraint(t, P, N)
if Φ is satisfiable then
t ← Q.pop()
if P ⊆ L(t⊤) and N ∩ L(t⊥) = /0 then
return solution(t, Φ)
Q.push(expandHoles(t))
Q.push(addHoles(t))
We show that the RWS1U repair problem is NP-hard by
a reduction from EXACTCOVER which is NP-complete [37].
More formally, we consider the decision problem version of
the RWS1U repair problem in which we are asked if there is
a repair r2 of r1 satisfying conditions (1)-(3) and D(r1,r2) ≤ k
for some given k ∈ N. Note that the decision problem is no
harder than the original repair problem because the solution to
the repair problem can be used to solve the decision problem.
Theorem IV.2. The RWS1U repair problem is NP-hard.
The proof appears in the Appendix.
V. REPAIR ALGORITHM
In this section, we describe the details of our PBE repair
algorithm. As discussed in Section II, our algorithm builds
on the previous approaches that use template-based search
with search pruning [20], [22] and the SMT-based constraint
solving to find a solution within the given candidate tem-
plate [22]. Our algorithm extends the constraint generations
and the pruning techniques of the previous approaches with
the support for real-world extensions and the assertion of
RWS1U to ensure invulnerability. We give the overview of the
repair algorithm in Section V-A. The details of the constraint
generation is given in Section V-B.
A. Algorithm Overview
Algorithm 1 shows the high-level structure of the repair
algorithm. The algorithm takes a regex r, a set of positive
examples P, and a set of negative examples N as input. Its
output is a regex that satisfies the RWS1U condition and is
consistent with P and N. At a high level, our algorithm consists
of the following four key components.
Generate the initial template. The priority queue Q maintains
regex templates. A regex template t is a regex that may contain
concrete regex. Its syntax is formally the extension of that of
a hole (cid:50) denoting a placeholder that is to be replaced by a
regexes (cf. Section III) and is defined by: r ::= ··· | (cid:50). To
distinguish, we will use t to range over regex templates and
reserve r for concrete regexes.
The queue Q is initialized by pushing the input regex (line
1). Q ranks its elements by the distance defined in Section IV
so that templates closer to the input regex are placed before.
Due to this, REMEDY outputs a regex that satisfies condition
(4) of RWS1U repair problem, i.e., the regex is minimal.
Pruning by approximations. The algorithm next retrieves and
removes a template t from the head of Q (line 3), and applies
the feasibility check to the template (line 4). The feasibility
check is introduced by [20] for pure regexes. It is known
to substantially reduce the search space and is also used in