returnuint32(len(mc.Chk.Data)❷)❶
}
Listing13-11:ThecreateChunkSize()method(/ch-13/imgInject/pnglib/commands.go)
Thismethodwillobtainthelengthofthechk.DATAbyte
array❷andtype-convertittoauint32value❶.
ThecreateChunkCRC()Method
RecallthattheCRCchecksumforeachchunksegment
comprisesboththeTYPEandDATAbytes.You’llusethe
createChunkCRC()methodtocalculatethischecksum.Themethod
leveragesGo’shash/crc32package(Listing13-12).
func(mc*MetaChunk)createChunkCRC()uint32{
bytesMSB:=new(bytes.Buffer)❶
iferr:=binary.Write(bytesMSB,binary.BigEndian,mc.Chk.Type);err!=nil{
❷
log.Fatal(err)
}
iferr:=binary.Write(bytesMSB,binary.BigEndian,mc.Chk.Data);err!=nil{
❸
log.Fatal(err)
}
returncrc32.ChecksumIEEE(bytesMSB.Bytes())❹
}
Listing13-12:ThecreateChunkCRC()method(/ch-13/imgInject/pnglib/commands.go)
Priortoarrivingatthereturnstatement,youdeclarea
bytes.Buffer❶andwriteboththeTYPE❷andDATA❸bytes
intoit.Thebyteslicefromthebufferisthenpassedasan
argumenttotheChecksumIEEE,andtheCRC-32checksumvalue
isreturnedasauint32datatype.Thereturnstatement❹isdoing
alltheheavyliftinghere,actuallycalculatingthechecksumon
thenecessarybytes.
ThemarshalData()Method
Allnecessarypiecesofachunkareassignedtotheirrespective
structfields,whichcannowbemarshaledintoabytes.Buffer.
Thisbufferwillprovidetherawbytesofthecustomchunk
thataretobeinsertedintothenewimagefile.Listing13-13
showswhatthemarshalData()methodlookslike.
func(mc*MetaChunk)marshalData()*bytes.Buffer{
bytesMSB:=new(bytes.Buffer)❶
iferr:=binary.Write(bytesMSB,binary.BigEndian,mc.Chk.Size);err!=nil{
❷
log.Fatal(err)
}
iferr:=binary.Write(bytesMSB,binary.BigEndian,mc.Chk.Type);err!=nil{
❸
log.Fatal(err)
}
iferr:=binary.Write(bytesMSB,binary.BigEndian,mc.Chk.Data);err!=nil{
❹
log.Fatal(err)
}
iferr:=binary.Write(bytesMSB,binary.BigEndian,mc.Chk.CRC);err!=nil{
❺
log.Fatal(err)
}
returnbytesMSB
}
Listing13-13:ThemarshalData()method(/ch-13/imgInject/pnglib/commands.go)
ThemarshalData()methoddeclaresabytes.Buffer❶andwrites
thechunkinformationtoit,includingthesize❷,type❸,data
❹,andchecksum❺.Themethodreturnsallthechunk
segmentdataintoasingleconsolidatedbytes.Buffer.
TheWriteData()Function
Nowallyouhavelefttodoistowriteyournewchunk
segmentbytesintotheoffsetoftheoriginalPNGimagefile.
Let’shaveapeekattheWriteData()function,whichexistsina
packagewecreatednamedutils(Listing13-14).
//WriteDatawritesnewChunkdatatooffset
funcWriteData(r*bytes.Reader❶,c*models.CmdLineOpts❷,b[]byte❸){
❹offset,_:=strconv.ParseInt(c.Offset,10,64)
❺w,err:=os.Create(c.Output)
iferr!=nil{
log.Fatal("Fatal:Problemwritingtotheoutputfile!")
}
deferw.Close()
❻r.Seek(0,0)
❼varbuff=make([]byte,offset)
r.Read(buff)
❽w.Write(buff)
❾w.Write(b)
❿_,err=io.Copy(w,r)
iferr==nil{
fmt.Printf("Success:%screated\n",c.Output)
}
}
Listing13-14:TheWriteData()function(/ch-13/imgInject/utils/writer.go)
TheWriteData()functionconsumesabytes.Reader❶containing
theoriginalimagefilebytedata,amodels.CmdLineOpts❷struct
inclusiveofthecommandlineargumentvalues,andabyteslice
❸holdingthenewchunkbytesegment.Thecodeblockstarts
withastring-to-int64conversion❹inordertoobtaintheoffset
valuefromthemodels.CmdLineOptsstruct;thiswillhelpyouwrite
yournewchunksegmenttoaspecificlocationwithout
corruptingotherchunks.Youthencreateafilehandle❺so
thatthenewlymodifiedPNGimagecanbewrittentodisk.
Youusether.Seek(0,0)functioncall❻torewindtothe
absolutebeginningofthebytes.Reader.Recallthatthefirst8
bytesarereservedforthePNGheader,soit’simportantthat
thenewoutputPNGimageincludetheseheaderbytesaswell.
Youincludethembyinstantiatingabyteslicewithalength
determinedbytheoffsetvalue❼.Youthenreadthatnumberof
bytesfromtheoriginalimageandwritethosesamebytesto
yournewimagefile❽.Younowhaveidenticalheadersin
boththeoriginalandnewimages.
Youthenwritethenewchunksegmentbytes❾intothe
newimagefile.Finally,youappendtheremainderofthe
bytes.Readerbytes❿(thatis,thechunksegmentbytesfromyour
originalimage)tothenewimagefile.Recallthatbytes.Reader
hasadvancedtotheoffsetlocation,becauseoftheearlierread
intoabyteslice,whichcontainsbytesfromtheoffsettothe
EOF.You’releftwithanewimagefile.Yournewfilehas
identicalleadingandtrailingchunksastheoriginalimage,but
italsocontainsyourpayload,injectedasanewancillary
chunk.
Tohelpvisualizeaworkingrepresentationofwhatyou
builtsofar,referencetheoverallworkingprojectcodeat
https://github.com/blackhat-go/bhg/tree/master/ch-
13/imgInject/.TheimgInjectprogramconsumescommandline
argumentscontainingvaluesfortheoriginalPNGimagefile,
anoffsetlocation,anarbitrarydatapayload,theself-declared
arbitrarychunktype,andtheoutputfilenameforyour
modifiedPNGimagefile,asshowninListing13-15.
$gorunmain.go-iimages/battlecat.png-onewPNGfile--inject-offset\
0x85258--payload1234243525522552522452355525
Listing13-15:RunningtheimgInjectcommandlineprogram
Ifeverythingwentasplanned,offset0x85258shouldnow
containanewrNDmchunksegment,asshowninFigure13-4.
Figure13-4:Apayloadinjectedasanancillarychunk(suchasrNDm)
Congratulations—you’vejustwrittenyourfirst
steganographyprogram!
ENCODINGANDDECODINGIMAGE
BYTEDATABYUSINGXOR
Justastherearemanytypesofsteganography,soarethere
manytechniquesusedtoobfuscatedatawithinabinaryfile.
Let’scontinuetobuildthesampleprogramfromtheprevious
section.Thistime,you’llincludeobfuscationtohidethetrue
intentofyourpayload.
Obfuscationcanhelpconcealyourpayloadfromnetwork-
monitoringdevicesandendpointsecuritysolutions.If,for
example,you’reembeddingrawshellcodeusedforspawninga
newMeterpretershellorCobaltStrikebeacon,youwantto
makesureitavoidsdetection.Forthis,you’lluseExclusive
ORbitwiseoperationstoencryptanddecryptthedata.
AnExclusiveOR(XOR)isaconditionalcomparison
betweentwobinaryvaluesthatproducesaBooleantruevalue
ifandonlyifthetwovaluesarenotthesame,andaBoolean
falsevalueotherwise.Inotherwords,thestatementistrueif
eitherxoryaretrue—butnotifbotharetrue.Youcanseethis
representedinTable13-1,giventhatxandyarebothbinary
inputvalues.
Table13-1:XORTruthTable
x
y
x^youtput
0
1
Trueor1
1
0
Trueor1
0
0
Falseor0
1
1
Falseor0
Youcanusethislogictoobfuscatedatabycomparingthe
bitsinthedatatothebitsofasecretkey.Whentwovalues
match,youchangethebitinthepayloadto0,andwhenthey
differ,youchangeitto1.Let’sexpandthecodeyoucreatedin
theprevioussectiontoincludeanencodeDecode()function,along
withXorEncode()andXorDecode()functions.We’llinsertthese
functionsintotheutilspackage(Listing13-16).
funcencodeDecode(input[]byte❶,keystring❷)[]byte{
❸varbArr=make([]byte,len(input))
fori:=0;i<len(input);i++{
❹bArr[i]+=input[i]^key[i%len(key)]
}
returnbArr
}
Listing13-16:TheencodeDecode()function(/ch-13/imgInject/utils/encoders.go)
TheencodeDecode()functionconsumesabyteslicecontaining
thepayload❶andasecretkeyvalue❷asarguments.Anew
byteslice,bArr❸,iscreatedwithinthefunction’sinnerscope
andinitializedtotheinputbytelengthvalue(thelengthofthe
payload).Next,thefunctionusesaconditionallooptoiterate
overeachindexpositionofinputbytearray.
Withintheinnerconditionalloop,eachiterationXORsthe
currentindex’sbinaryvaluewithabinaryvaluederivedfrom
themoduloofthecurrentindexvalueandlengthofthesecret
key❹.Thisallowsyoutouseakeythatisshorterthanyour
payload.Whentheendofthekeyisreached,themodulowill
forcethenextiterationtousethefirstbyteofthekey.Each
XORoperationresultiswrittentothenewbArrbyteslice,and
thefunctionreturnstheresultingslice.
ThefunctionsinListing13-17wraptheencodeDecode()
functiontofacilitatetheencodinganddecodingprocess.
//XorEncodereturnsencodedbytearray
❶funcXorEncode(decode[]byte,keystring)[]byte{
❷returnencodeDecode(decode,key)
}
//XorDecodereturnsdecodedbytearray
❶funcXorDecode(encode[]byte,keystring)[]byte{
❷returnencodeDecode(encode,key)
}
Listing13-17:TheXorEncode()andXorDecode()functions(/ch-
13/imgInject/utils/encoders.go)
Youdefinetwofunctions,XorEncode()andXorDecode(),which
takethesameliteralarguments❶andreturnthesamevalues
❷.That’sbecauseyoudecodeXOR-encodeddatabyusing
thesameprocessusedtoencodethedata.However,you
definethesefunctionsseparately,toprovideclaritywithinthe
programcode.
TousetheseXORfunctionsinyourexistingprogram,
you’llhavetomodifytheProcessImage()logicyoucreatedin
Listing13-8.TheseupdateswillleveragetheXorEncode()
functiontoencryptthepayload.Themodifications,shownin
Listing13-18,assumeyou’reusingcommandlinearguments
topassvaluestoconditionalencodeanddecodelogic.
//EncodeBlock
if(c.Offset!="")&&c.Encode{
varmMetaChunk
❶m.Chk.Data=utils.XorEncode([]byte(c.Payload),c.Key)
m.Chk.Type=chk.strToInt(c.Type)
m.Chk.Size=chk.createChunkSize()
m.Chk.CRC=chk.createChunkCRC()
bm:=chk.marshalData()
bmb:=bm.Bytes()
fmt.Printf("PayloadOriginal:%X\n",[]byte(c.Payload))
fmt.Printf("PayloadEncode:%X\n",chk.Data)
utils.WriteData(b,c,bmb)
}
Listing13-18:UpdatingProcessImage()toincludeXORencoding(/ch-
13/imgInject/pnglib/commands.go)
ThefunctioncalltoXorEncode()❶passesabyteslice
containingthepayloadandsecretkey,XORsthetwovalues,
andreturnsabyteslice,whichisassignedtochk.Data.The
remainingfunctionalityremainsunchangedandmarshalsthe
newchunksegmenttoeventuallybewrittentoanimagefile.
Thecommandlinerunofyourprogramshouldproducea
resultsimilartotheoneinListing13-19.
$gorunmain.go-iimages/battlecat.png--inject--offset0x85258--encode\
--keygophers--payload1234243525522552522452355525--output
encodePNGfile
ValidPNGsoletuscontinue!
❶PayloadOriginal:31323334323433353235353232353532353232
343532333535353235
❷PayloadEncode:565D435C574640525D455D574046525D455A57
46
46555C455D504046
Success:encodePNGfilecreated
Listing13-19:RunningtheimgInjectprogramtoXORencodeadatachunkblock
Thepayloadiswrittentoabyterepresentationanddisplayed
tostdoutasPayloadOriginal❶.ThepayloadisthenXORedwitha
keyvalueofgophersanddisplayedtostdoutasPayloadEncode❷.
Todecryptyourpayloadbytes,youusethedecode
function,asinListing13-20.
//DecodeBlock
if(c.Offset!="")&&c.Decode{
varmMetaChunk
❶offset,_:=strconv.ParseInt(c.Offset,10,64)
❷b.Seek(offset,0)
❸m.readChunk(b)
origData:=m.Chk.Data
❹m.Chk.Data=utils.XorDecode(m.Chk.Data,c.Key)
m.Chk.CRC=m.createChunkCRC()
❺bm:=m.marshalData()
bmb:=bm.Bytes()
fmt.Printf("PayloadOriginal:%X\n",origData)
fmt.Printf("PayloadDecode:%X\n",m.Chk.Data)
❻utils.WriteData(b,c,bmb)
}
Listing13-20:Decodingtheimagefileandpayload(/ch-
13/imgInject/pnglib/commands.go)
Theblockrequirestheoffsetpositionofthechunksegment
thatcontainsthepayload❶.YouusetheoffsettoSeek()❷the
fileposition,alongwithasubsequentcalltoreadChunk()❸
that’snecessarytoderivetheSIZE,TYPE,DATA,andCRCvalues.
AcalltoXorDecode()❹takesthechk.Datapayloadvalueandthe
samesecretkeyusedtoencodethedata,andthenassignsthe
decodedpayloadvaluebacktochk.Data.(Rememberthatthisis
symmetricencryption,soyouusethesamekeytobothencrypt
anddecryptthedata.)Thecodeblockcontinuesbycalling
marshalData()❺,whichconvertsyourChunkstructtoabyteslice.
Finally,youwritethenewchunksegmentcontainingthe
decodedpayloadtoafilebyusingtheWriteData()function❻.
Acommandlinerunofyourprogram,thistimewitha
decodeargument,shouldproducetheresultinListing13-21.
$gorunmain.go-iencodePNGfile-odecodePNGfile--offset0x85258-
decode\
--keygophersValidPNGsoletuscontinue!
❶PayloadOriginal:565D435C574640525D455D574046525D455A57
4646555C455D504046
❷PayloadDecode:3132333432343335323535323235353235323234
3532333535353235
Success:decodePNGfilecreated
Listing13-21:RunningtheimgInjectprogramtoXORdecodeadatachunkblock
ThePayloadOriginalvalue❶istheencodedpayloaddataread
fromtheoriginalPNGfile,whilethePayloadDecodevalue❷is
thedecryptedpayload.Ifyoucompareyoursamplecommand
linerunfrombeforeandtheoutputhere,you’llnoticethat
yourdecodedpayloadmatchestheoriginal,cleartextvalue
yousuppliedoriginally.
Thereisaproblemwiththecode,though.Recallthatthe
programcodeinjectsyournewdecodedchunkatanoffset
positionofyourspecification.Ifyouhaveafilethatalready
containstheencodedchunksegmentandthenattempttowrite
anewfilewithadecodedchunksegment,you’llendupwith
bothchunksinthenewoutputfile.YoucanseethisinFigure
13-5.
Figure13-5:Theoutputfilecontainsboththedecodedchunksegmentandencoded
chunksegment.
Tounderstandwhythishappens,recallthattheencoded
PNGfilehastheencodedchunksegmentatoffset0x85258,as
showninFigure13-6.
Figure13-6:Theoutputfilecontainingtheencodedchunksegment
Theproblempresentsitselfwhenthedecodeddatais
writtentooffset0x85258.Whenthedecodeddatagetswrittento
thesamelocationastheencodeddata,ourimplementation
doesn’tdeletetheencodeddata;itmerelyshiftstheremainder
ofthefilebytestotheright,includingtheencodedchunk
segment,asillustratedpreviouslyinFigure13-5.Thiscan
complicatepayloadextractionorproduceunintended
consequences,suchasrevealingthecleartextpayloadto
networkdevicesorsecuritysoftware.
Fortunately,thisissueisquiteeasytoresolve.Let’stakea
lookatourpreviousWriteData()function.Thistime,youcan
modifyittoaddresstheproblem(Listing13-22).
//WriteDatawritesnewdatatooffset
funcWriteData(r*bytes.Reader,c*models.CmdLineOpts,b[]byte){
offset,err:=strconv.ParseInt(c.Offset,10,64)
iferr!=nil{
log.Fatal(err)
}
w,err:=os.OpenFile(c.Output,os.O_RDWR|os.O_CREATE,0777)
iferr!=nil{
log.Fatal("Fatal:Problemwritingtotheoutputfile!")
}
r.Seek(0,0)
varbuff=make([]byte,offset)
r.Read(buff)
w.Write(buff)
w.Write(b)
❶ifc.Decode{
❷r.Seek(int64(len(b)),1)
}
❸_,err=io.Copy(w,r)
iferr==nil{
fmt.Printf("Success:%screated\n",c.Output)
}
}
Listing13-22:UpdatingWriteData()topreventduplicateancillarychunktypes(/ch-
13/imgInject/utils/writer.go)
Youintroducethefixwiththec.Decodeconditionallogic❶.
TheXORoperationproducesabyte-for-bytetransaction.
Therefore,theencodedanddecodedchunksegmentsare
identicalinlength.Furthermore,thebytes.Readerwillcontainthe
remainderoftheoriginalencodedimagefileatthemoment
thedecodedchunksegmentiswritten.So,youcanperforma
rightbyteshiftcomprisingthelengthofthedecodedchunk
segmentonthebytes.Reader❷,advancingthebytes.Readerpastthe
encodedchunksegmentandwritingtheremainderofbytesto
yournewimagefile❸.
Voila!AsyoucanseeinFigure13-7,thehexeditor
confirmsthatyouresolvedtheproblem.Nomoreduplicate
ancillarychunktypes.
Figure13-7:Theoutputfilewithoutduplicateancillarydata
Theencodeddatanolongerexists.Additionally,runningls
-laagainstthefilesshouldproduceidenticalfilelengths,even
thoughfilebyteshavechanged.
SUMMARY
Inthischapter,youlearnedhowtodescribethePNGimage
fileformatasaseriesofrepetitivebytechunksegments,each
withitsrespectivepurposeandapplicability.Next,you
learnedmethodsofreadingandnavigatingthebinaryfile.