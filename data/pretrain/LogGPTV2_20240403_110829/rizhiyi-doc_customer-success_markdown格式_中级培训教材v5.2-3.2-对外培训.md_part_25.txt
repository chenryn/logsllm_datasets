 meta： 第一个参数meta的含义是不同告警经过用户配置后的META信息，是一个
python的字典，字典的结构与上述的插件要求的常量词典META一致。用户写插件时，
使用此信息进行自己需要的处理。
 alert：第二个参数alert的含义是告警信息本身，是一个python的字典。用户使用他来
获取当次告警所需的所有信息。
handle函数里实现此告警的执行操作，函数的返回值约定如下：
 返回值：空，无返回值。可抛出异常，在外围调用处有处理会记录一条错误信息，但当
异常发生时，并不会重试执行。有重试等其他可靠性需求，需在handle内自行处理。
content函数实现在告警预览和告警历史中，对应告警如何显示告警内容。函数可抛出异常，
在外部调用处有处理会记录一条错误信息，当异常发生时，告警预览和历史内看到的告警内
容就为一条错误信息。函数的返回值约定如下:
 返回值：String类型
execute_reply函数返回内容会在操作运行的页面上展示，其返回值约定如下:
 返回值：String类型
插件开发样例
以http_forwarder插件为例。
http_forwarder插件是将告警信息再次POST到一个用户配置的地址，用户需启动自己的服
务，随后可用完整的告警信息对告警进行再处理。
6-278
日志学院
日志记录
从实际需求考虑，三个约定函数的主处理流程大致是一致的，只是输入输出数据在变化。所
以，为了方便插件代码的编写，日志易建议使用全局变量和独立方法来统一记录插件的运行
日志。
#-*-coding:utf-8-*-
#PI:EMAIL
#2016-05-19
#Copyright2016Yottabyte
#filename:yottaweb/apps/alert/plugins/simple_email.py
#filedescription: 最简单的告警，所有客户都会带着 __author__='wu.ranbo'
importlogging
importrequests
importjson
importcopy
req_logger=logging.getLogger("django.request")
globalreply_content
reply_content=""
log_content={
logging.FATAL:re_logger.fatal,
logging.ERROR:re_logger.error,
logging.WARNING:re_logger.warning,
logging.INFO:re_logger.info,
logging.DEBUG:re_logger.debug
}
deflog_and_reply(log_level,comment):
globalreply_content
log_content.get(log_level)(comment)
reply_content='%s%s%s'%(reply_content,"\n",comment)
META
META就是一个python的字典，并无特殊之处。只要按照上述的META格式要求写就可。
内容如下:
META={
"name":"http_forwarder","version":1,
"alias":"告警转发","configs":[
{
"name":"address","alias":"http转发地址","presence":True,"value_type":"string",
"default_value":"","style":{
"rows":1,
"cols":30}
6-279
日志学院
}
]}
content
content方法就是普通的python方法。插件接口只要求此方法的入参形式和返回值为String。
此插件的content是将初始的告警信息用json格式显示出来。
defcontent(params,alert):
returnjson.dumps(alert,ensure_ascii=False,indent=4).encode("utf-8","ignore")
handle
内容为按照用户配置的http地址，将告警信息原文发送出去。
defhandle(params,alert):
try:
address=params['configs'][0]['value']
requests.post(address,data=json.dumps(alert))
log_and_reply(logging.DEBUG,("alert.plugs.http_forwardersend
to%s,data:%s.",address,origin_alert))
exceptException,e:
log_and_reply(logging.ERROR,("alert.plugins.http_forwardergotexception%s",e))
raisee
可以看到，在handle方法中，我们就使用了之前定义的 log_and_reply 方法，来记录不同
情况的日志输出，包括错误输出亦可。
execute_reply
内容为将运行过程中的输出，返回给前端展示。
defexecute_reply(params,alert):
re_logger.info("reply_contentstart")
handle(params,alert)
re_logger.info("reply_content:%s"%(reply_content))
returnreply_content
这里的 reply_content 显然就是在调用 handle 方法过程中被填充好了数据。
此外，log_and_reply 和 re_logger.XXX 的区别，在于 re_logger 只记录到服务器日志中，
并不返回给前端展现。您可以按需选择。
6-280
日志学院
插件管理
在监控首页右上侧，点击告警插件打开告警插件的列表页。列表中展示当前用户可读的推送
插件。
插件上传
点击“上传”按钮，可从本地上传插件。选择好插件后可识别是否存在同名文件，点击“确定”
即可开始上传。
新建与更新
通过 “上传”对话框，点击“确定”后，若无重名文件则直接新建一个插件，若有重名文件，系
统可取到插件的新旧版本号进行对比，并跳出提示框，指导用户更新同名的告警推送插件。
如下图：
6-281
日志学院
6.3. 查看告警记录
在启用状态的监控，一旦触发，会将触发告警的即时状态单独记录为一次告警事件，供事后
查询。在监控列表上点击运行趋势图或告警名称，即可进入该监控的告警事件历史记录页：
事件数和字段统计类型在历史页展示趋势图。其他类型只展示历史列表。
每条历史记录，可以有查看详情和搜索操作。告警详情浮层展现这条记录在触发时刻的触发
值。点击搜索按钮，则跳转到搜索页面，打开该告警关联的已存搜索语句，并自动调整过滤
时段为告警触发的开始、结束时间，您可以直接查看异常时段的事件列表或统计。
监控运行记录到单独索引 monitor 里
除了触发阈值的告警事件，日志易还会留存监控任务每次执行计划的结果，后期可以作为时
序指标使用。运行记录到单独的monitor索引里。 用户可以通过日志易manager查看是否
创建monitor索引。
也可以通过在搜索页面输入index=monitor*查看事件列表，也可以通过spl语句
index=monitoralert_name:"alert_index"|tabletimestamp,date_minute,total_hits,response，
得到图表进一步分析监控结果。
6-282
日志学院
6.4. 维护期
日志易系统支持设置【维护期】功能。当故障已经明确发生，或者即将开始计划内的调整动
作时，系统内的各种告警已经没有必要执行，因为数据肯定是没用的。维护期让用户主动指
明现在是维护期间，维护期间影响的告警分组实际不触发告警。维护结束，涉及的监控恢复
到之前的状态。
示例: 新建一个维护期，维护周期可以选择定时或单次，定时可以选择每天，每周和每月。
6-283
日志学院
可以看到维护期间，监控列表影响的监控显示‘正在维护’。
用户在维护期间不会接收到被触发的监控。另，不管是开始还是结束，登记的时间和操作的
时间，哪个晚就是那个为准。具体示例如下：
1. 用户在16:00创建一次维护期，选择维护时间为16:10-17:10;那么系统自动在16:10停止，
17:10启动。
2. 用户在16:10创建一次维护期，选择维护时间为16:00-17:10，那么系统自动在16:00停
止，17:10启动。
3. 用户在16:10创建一次维护期，选择维护时间为16:00-?，那么系统自动在16:10停止;等
到用户在17:10 再次登录，修改维护为17:00，那么系统在17:10启动。
向维护期中的分组里添加或删除告警，告警实时地生成或终止告警记录。例如正在维护
alert_fix分组，修改告警a到alert_fix分组，则告警a的告警记录停止生成。
6.5. 告警应用实例
基于日志可以方便快捷地实现以下场景的监控告警：
1、基于日志关键字实现告警：如系统出现ERROR或其他异常关键字就发出告警；
2、基于数值统计实现告警：当某一指标或累积数值达到某一阈值就发出告警；
3、基于响应率或成功率实现告警：结合SPL实现对响应率、成功率、系统健康度等实现监
控告警；
4、端口状态告警：基于日志监控，当发现端口down时发出告警，发现端口up时告警恢复；
5、机器上下线告警：基于日志监控，当发现机器下线时发出告警，发现机器上线时告警恢
复；
6、陡变告警。
实际上，在企业环境中，业务场景涉及的告警指标还有很多，如：
 交易量、实例数；
 超时、响应时间、查询时长；
 成功率、失败率、错误码、返回码、风控、EROOR日志告警、交易状态、通道状态；
 跑批、日切、批量、作业调度、批处理作业；
6-284
日志学院
 接口调用、NGINX、数据库、关键字、JAVA、下线、日志采集、服务状态、拒绝连接。
上述部分告警在6.1告警类型已经举例讲过，为深入理解监控告警在企业场景中的应用，下
面再扩展几个企业常用的监控场景。
日志陡变监控
早在3.3小节我们就提及过，指标字段的陡变是企业业务场景中的注意关注点之一。对重点
字段设置监控，易于第一时间发现业务变化，及时对变化做出反应，将企业损失降到最低。
日志陡变监控示例如下：
监控搜索内容为：
starttime="now-3m/m"endtime="now/m" index=speappname:esbtag:tranlog
|buckettimestampspan=10sasts
|statscount()as_countbyts
|movingavg_count,3asma
|evalrate_ma=todouble(format("%.3f",if(ma==0,0,(ma-_count)/ma)))
6-285
日志学院
|fieldsrate_ma,_count,ts,ma
|evalstatus=case(rate_ma>=0.4,"陡降",rate_ma<=-0.4,"陡增",default,"正常")
|wherestatus=="陡降"||status=="陡增"
|evalflag=abs(rate_ma)
|evalts=formatdate(ts,"yyyy-MM-ddHH:mm:ss")
通过移动平均值来实现日志的陡变陡增，能够快速检测出攻击或其它导致数据上下波动异常
的行为。
基线告警
如果监控是随着时间波动的，没有特定的阈值，推荐使用基线告警。
基线告警示例如下：
告警归并
生产环境中可能会遇到这样的情况：当发生A事故时，可能会牵连出其他系统问题，如系
统后台数据库故障造成前端页面无法正常访问，这时一连串告警产生，如果每次告警都发送
一条告警信息，就会发生告警风暴。此时我们可以使用指标关联的方式合并发送告警。
6-286
日志学院
某告警归并示例如下：
6-287
日志学院
告警信息：
更多监控告警相关请参考《日志易监控告警手册》；
更多API相关请参考《日志易API使用手册》部分说明。
本章习题：
1、告警信息记录到哪个索引里？
2、如何实现以下监控需求？请写出SPL语句，并说明创建告警流程。
需求描述：交易短信网关异常会导致短信平台网关日志不更新，因而需要监控日志文件的更
新，在10分钟内没有更新则触发告警。
短信平台两台服务器：192.168.1.205、192.168.1.206
短信平台网关日志：appname:TSMStag:tsms_deliver
日志路径：
/home/app/csmd/log/SmsGatewaySgip/11/deliver.log
/home/app/csmd/log/SmsGatewayCmpp/12/deliver.log
/home/app/csmd/log/SmsGatewaySmgp/13/deliver.log
注释：
11为联通网关
12为移动网关
13为电信网关
要求：任意一台服务器上的任意网关日志在10分钟内不更新，则触发告警，告警内容为：
交易短信平台（IP）xx网关异常。如：交易短信平台（192.168.1.206）联通网关异常。
思考：
什么情况下产品自带的告警插件不能满足用户使用？这种情况下应该采用什么方法解决？
6-288
日志学院
7.日志分析过程最佳实践
在我们的演示过程中，虽然仅仅接入了少量的日志，但appname和tag就已然起到了十分
重要的作用。