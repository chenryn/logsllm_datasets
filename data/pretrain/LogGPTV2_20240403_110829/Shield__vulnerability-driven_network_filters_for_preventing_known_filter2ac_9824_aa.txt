title:Shield: vulnerability-driven network filters for preventing known
vulnerability exploits
author:Helen J. Wang and
Chuanxiong Guo and
Daniel R. Simon and
Alf Zugenmaier
Shield: Vulnerability-Driven Network Filters for Preventing
Known Vulnerability Exploits
Helen J. Wang, Chuanxiong Guo, Daniel R. Simon, and Alf Zugenmaier
{helenw, t-chuguo, dansimon, alfz}@microsoft.com
Microsoft Research
ABSTRACT
Software patching has not been eﬀective as a ﬁrst-line de-
fense against large-scale worm attacks, even when patches
have long been available for their corresponding vulnerabil-
ities. Generally, people have been reluctant to patch their
systems immediately, because patches are perceived to be
unreliable and disruptive to apply. To address this prob-
lem, we propose a ﬁrst-line worm defense in the network
stack, using shields — vulnerability-speciﬁc, exploit-generic
network ﬁlters installed in end systems once a vulnerability
is discovered, but before a patch is applied. These ﬁlters
examine the incoming or outgoing traﬃc of vulnerable ap-
plications, and correct traﬃc that exploits vulnerabilities.
Shields are less disruptive to install and uninstall, easier to
test for bad side eﬀects, and hence more reliable than tra-
ditional software patches. Further, shields are resilient to
polymorphic or metamorphic variations of exploits [43].
In this paper, we show that this concept is feasible by de-
scribing a prototype Shield framework implementation that
ﬁlters traﬃc above the transport layer. We have designed
a safe and restrictive language to describe vulnerabilities as
partial state machines of the vulnerable application. The ex-
pressiveness of the language has been veriﬁed by encoding
the signatures of several known vulnerabilites. Our eval-
uation provides evidence of Shield’s low false positive rate
and small impact on application throughput. An examina-
tion of a sample set of known vulnerabilities suggests that
Shield could be used to prevent exploitation of a substantial
fraction of the most dangerous ones.
Categories and Subject Descriptors
D.4.6 [Security and Protection]:
formation ﬂow controls]
General Terms
Security, Design, Languages, Performance vspace-0.3cm
[Invasive software, In-
Keywords
Worm Defense, Patching, Vulnerability Signature, Network
Filter, Generic Protocol Analyzer
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
SIGCOMM’04, Aug. 30–Sept. 3, 2004, Portland, Oregon, USA.
Copyright 2004 ACM 1-58113-862-8/04/0008 ...$5.00.
1.
INTRODUCTION
One of the most urgent security problems facing adminis-
trators of networked computer systems today is the threat
of remote attacks on their systems over the Internet, based
on vulnerabilities in their currently running software. Par-
ticularly damaging have been self-propagating attacks, or
“worms”, which exploit one or more vulnerabilities to take
control of a host, then use that host to ﬁnd and attack other
hosts with the same vulnerability.
The obvious defense against such attacks is to prevent
the attack by repairing the vulnerability before it can be ex-
ploited. Typically, software vendors develop and distribute
reparative “patches” to their software as soon as possible
after learning of a vulnerability. Customers can then install
the patch and prevent attacks that exploit the vulnerability.
Experience has shown, however, that administrators of-
ten do not install patches until long after they are made
available — if at all [33]. As a result, attacks — including
worms, such as the widely publicized CodeRed [7], Slam-
mer [40], MSBlast [24], and Sasser [35] worms — that exploit
known vulnerabilities, for which patches had been available
for quite some time, have nevertheless been quite “success-
ful”, causing widespread damage by attacking the large co-
hort of still-vulnerable hosts. In fact, more than 90% of the
attacks today are exploiting known vulnerabilities [1].
There are several reasons why administrators may fail to
install software patches:
• Disruption:
Installing a patch typically involves re-
booting, at the very least, a particular host service,
and possibly an entire host system. An administrator
for whom system and service uptime are crucial may
therefore be unable to tolerate the required service or
system disruption.
• Unreliability: Software patches are typically released
as quickly as possible after a vulnerability is discov-
ered, and there is therefore insuﬃcient time to do more
than cursory testing of the patch. For popular software
programs, patch (regression) testing is inherently dif-
ﬁcult and involves an exponential number of test cases
due to the software’s numerous versions, and their de-
pendencies on various versions of libraries — which
depend in turn on other libraries, and so on.
In addition, a patch typically bundles a number of
software updates together with the security ﬁx, fur-
ther complicating testing.
(Such bundling is neces-
sary to prevent the number of branches in the state
of the software source code from exploding exponen-
tially.) Hence patches can have serious undetected side
Session 5: Secure Networkseﬀects in particular conﬁgurations, causing severe dis-
ruption and even damage to the host systems to which
they are applied. Rather than risk such damage, ad-
ministrators may prefer to do their own thorough and
time-consuming testing, or simply wait — accepting
the risks of vulnerability in the meantime — until the
patch has been vindicated by widespread uneventful
installation [2].
• Irreversibility: Most patches are not designed to be
easily reversible due to the ordering of changes that
have been made to the system. Once a patch is ap-
plied, there is often no easy way of uninstalling it, short
of restoring a backup version of the entire patched ap-
plication (or even the entire system). This factor ex-
acerbates the risk associated with applying a patch.
• Unawareness: An administrator may simply miss a
patch announcement for some reason, and therefore
be unaware of it, or have received the announcement
but neglected to act on it.
Because of the above drawbacks to installing patches, meth-
ods are being explored for mitigating vulnerabilities without
installing patches, or at least until a patch is determined to
be safe to install. The goal is to address the window of
vulnerability between vulnerability disclosure and software
patching. A ﬁrewall, for example, can be conﬁgured to pre-
vent traﬃc originating outside a local network from reach-
ing a vulnerable application, by blocking the appropriate
port. By doing so, it can protect an application from at-
tacks from “outside”. Of course, blocking all traﬃc to a port
is a crude measure, preventing the application from func-
tioning at all across the ﬁrewall. Exploit-signature-based
ﬁrewalls that string-match network traﬃc to known attack
patterns (using regular expressions, for example) are more
ﬂexible [41], but metamorphic or polymorphic variations [43]
of the known exploits can easily undermine such ﬁlters. Fur-
thermore, such exploit signatures can only be obtained after
the onset of the attacks themselves, and for fast-spreading
worms, it is challenging to detect, extract, and distribute
attack signatures in a timely matter [39, 42]. Ideally, pre-
vention mechanisms would be deployed well before attacks
occur, and even before the public disclosure of a vulnera-
bility, and only traﬃc that exploits the vulnerability would
be blocked, while all other traﬃc would be allowed to pass
through to the application.
In this paper, we explore the possibility of applying an
intermediate “patch” in the network stack to perform this
ﬁltering function, to delay (or perhaps in some cases even
eliminate) the need for installing the software patch that re-
moves the vulnerability. Shield is a system of vulnerability-
speciﬁc, exploit-generic network ﬁlters (shields) installed at
the end host, that examines the incoming or outgoing traﬃc
of vulnerable applications and corrects the traﬃc according
to the vulnerability signature. Shield operates at the appli-
cation protocol layer, above the transport layer. For exam-
ple, a shield (conceptually, there is one shield per vulnera-
bility) designed to protect against a buﬀer overrun vulnera-
bility would detect and drop or truncate traﬃc that resulted
in an excessively long value being placed in the vulnerable
buﬀer. Shield diﬀers from previous anti-worm strategies (see
Section 9) in attempting to remove a speciﬁc vulnerability
directly before the vulnerability disclosure time, rather than
mitigating or countering the eﬀects of its exploitation at at-
tack time.
Unlike software patches, shields are deployed in the net-
work stack of the end host. They are thus more separated
from the vulnerable application — and its wide variety of
potential environment conﬁgurations — and therefore less
likely to have unforeseen side eﬀects.
In particular, their
compatibility with normal operation is in principle relatively
easy to test: Since they operate only on network traﬃc, and
are intended only to drop attack traﬃc, they can be tested
simply by exposing them to a suitably rich collection of net-
work traﬃc — such as a long trace of past network activ-
ity, or a synthetic test suite of representative traﬃc — to
verify that they would allow it all through unaﬀected. Fur-
thermore, shields are non-disruptive and easily reversible.
Automatic installation of shields is therefore a technically
viable option.
The most eﬃcient kind of end-host Shield would be po-
sitioned at the highest protocol layer, namely the applica-
tion layer — assuming that programmatic “hooks” into that
layer are available for traﬃc interception and manipulation.
This way, any redundant message parsing would be avoided.
For example, URLScan [8] is essentially a Shield speciﬁc to
Microsoft’s IIS web server, which uses the IIS ISAPI ex-
tension package’s hooks for HTTP request interception and
manipulation. However, most applications do not oﬀer such
extensibility into their protocols. To this end, we have de-
signed a Shield framework that lies between the application
layer and the transport layer and oﬀers shielding for any ap-
plication level protocols. Being above the transport layer,
Shield does not need to deal with IPSec-encrypted traﬃc.
Encrypted traﬃc above the transport layer, such as SSL-
[13] or application-speciﬁc encrypted traﬃc, are diﬃcult for
such a framework to handle1. Nevertheless, it is sensible
to build the Shield framework to encompass commonly used
protocols such as SSL [13] and RPC [34], and the techniques
described in this paper can be readily applied to them.
In our Shield framework, we model vulnerability signa-
tures as a combination of partial protocol state machines
and vulnerability-parsing instructions for speciﬁc payloads
(Section 2). For generality, we abstract out the generic ele-
ments of application-level protocols into a generic protocol
analyzer in our Shield architecture (Section 3). For ﬂexibil-
ity and simplicity, we express vulnerability signatures and
their countermeasures in a safe, restrictive, and yet expres-
sive policy language, interpreted by the Shield framework at
runtime (Section 5). We also minimize Shield’s maintenance
of protocol and message parsing state for scalability (Sec-
tion 4.1).
In particular, Shield reconstructs vulnerability-
related application semantics by maintaining the relevant
protocol context of a communication session, and performs
application-message-based inspection rather than packet-level
inspection, as used by some Network Intrusion Detection or
Prevention Systems [41]. Packet-level inspection can be eas-
ily evaded or disturbed by attackers [32], resulting in both
false positives and false negatives. We have implemented a
preliminary Shield prototype and experimented with a num-
ber of known vulnerabilities, including the ones behind the
(in)famous MSBlast, Slammer, and CodeRed worms (Sec-
tion 7). Our evaluation provides evidence of zero false pos-
itives and manageable impact on application throughput
(Section 8). An examination of a sample set of known vul-
1Nonetheless, assuming Shield runs with root or administra-
tor privileges on end hosts, it would be possible for Shield to
obtain encryption keys and decrypt traﬃc itself. The result-
ing overhead should not be prohibitive as long as eﬃcient
symmetric ciphers are used for the encryption.
nerabilities suggests that Shield could be used to prevent
exploitation of a substantial fraction of the most dangerous
ones (Section 8.1).
2. VULNERABILITY MODELING
AND SHIELD USAGE
An essential part of the Shield design is the method of
modeling and expressing vulnerability signatures. A Shield
vulnerability signature speciﬁes all possible sequences of ap-
plication messages and speciﬁc payload characteristics that
lead to any remote exploit of the vulnerability. (Note that
not all vulnerabilities are suitable for shielding. This issue
is discussed further in Section 8.1.) For example, the signa-
ture for the vulnerability behind the Slammer worm [40] is
the arrival of a UDP packet at port 1434 with a size that
exceeds the legal limit of the vulnerable buﬀer used in the
Microsoft SQL server 2000 implementation. More sophisti-
cated vulnerabilities require tracing a sequence of messages
leading up to the actual message that can potentially exploit
the vulnerability.
Figure 1: Vulnerability Modeling
To express vulnerability signatures precisely, we have de-
veloped a taxonomy for modeling vulnerabilities, as illus-
trated in Figure 1. Each application can be considered as
a ﬁnite state machine, which we call the application state
machine. Overlaying the application state machine is the
Protocol State Machine, in which the transitions are appli-
cation message arrivals. The protocol state machine is much
smaller and simpler than the application state machine, and
the application state machine (e.g., enlarged state S2 in
the ﬁgure) can be viewed as a reﬁnement of the protocol
state machine. As a network ﬁlter, Shield is primarily con-
cerned with the protocol state machine. We deﬁne the pre-
vulnerability state as the state in the protocol state machine
at which receiving an exploitation network event could cause
damage (v4 in the ﬁgure). We call the partial protocol state
machine that leads to the pre-vulnerability state the vulner-
ability state machine, and the message that can potentially
contain an exploit, the vulnerable event.
A Shield vulnerability signature essentially speciﬁes the
vulnerability state machine and describes how to recognize
any exploits in the vulnerable event. A Shield policy for a
vulnerability includes both the vulnerability signature and
the actions to take on recognizing an exploit of the vulner-
ability. In Section 5, we detail our design of a language for
Shield policy speciﬁcation.
When a new vulnerability is discovered, a shield designer
— typically the vulnerable application’s vendor — creates a
Shield policy for the vulnerability (conceptually, there is one
Shield policy per vulnerability) and distributes it to users
running the application as in anti-virus signature distribu-
tion and installation. Using this policy, Shield intercepts
its application’s traﬃc and walks through the vulnerability
state machine; when reaching the pre-vulnerability state,
the Shield examines the vulnerable event for possible ex-
ploits and takes the speciﬁed actions to protect against the
exploits if they are present.
Shields can protect a host from potentially malicious in-
coming traﬃc in a similar fashion to a ﬁrewall, but with
much more application-speciﬁc knowledge. In addition, shields
can ﬁlter out outgoing traﬃc that triggers malicious responses
back to the host itself, or protects other hosts on the same
local network from the host’s own vulnerability-exploiting