target is a constant secret string repeatedly sent in the en-
crypted channel, it does not matter that the TLS session is
closed and that the keying material changes accross sessions.
The proof of concept was named Lucky 13, after the size of
the pseudo-header MAC’ed with the message.
6To be precise, there is a 2−16 probability to get a plain-
text ending with 01 01, a 2−24 to get 02 02 02, and so on.
To eliminate those false positives, the attacker can simply
repeat the operation with a diﬀerent random string in C (cid:63).
Hypotheses and prerequisites
• The connexion uses CBC with a timing info-leak;
• The attacker is able to intercept and modify packets;
• Multiple connections containing the same secret can
be triggered.
Proposed countermeasures
Add random delays to CBC-mode decryption step.
This would only increase the complexity of the attack (re-
quiring more samples to compute the mean value).
Implement constant-time MAC-then-Encrypt. Such
implementations counter the attack, but the code needed to
obtain eﬃcient record processing in eﬀectively constant time
is complex (the OpenSSL patch is almost 300 lines long).
Use RC4 to avoid CBC mode. As for BEAST, it
thwarts this attack but is inconsistent with other measures.
Use TLS 1.2 AEAD suites. As for BEAST, this works
but is hard to deploy reliably.
Switch to Encrypt-then-MAC. This would solve the
problem, but the speciﬁcation [16] is still young. Moreover,
it relies on an extension, which would lead to the same de-
ployment and reliability issues as TLS 1.2.
2.4 RC4 biases
RC4 is a stream cipher designed by Rivest in 1987. It is
very simple to implement and has very good performance in
software. It has thus been widely adopted in protocols (WiFi
encryption protocols WEP and WPA, or TLS for example).
Since 1995, several statistical biases have been identiﬁed in
the ﬁrst bytes of an RC4 keystream. These ﬂaws eventually
led to very eﬃcient attacks against WEP [31].
As these attacks rely on initial biases of the keystream,
it was proposed to drop the ﬁrst n bytes of the keystream,
but later ﬁndings show the existence of additional statistical
biases, even after the initial bytes [12]. In 2013, two research
teams presented practical attacks against the encryption of
the same ﬁxed sequence of plaintext using large numbers of
diﬀerent keys [18, 1], which apply to HTTPS cookies.
Here is a short description of the most eﬃcient attacks on
RC4, presented in the article by AlFardan et al. Their single-
byte bias attack relies on the fact that the ﬁrst 256 bytes
of the keystream are strongly biased. The researchers gen-
erated a lot of RC4 keystreams to observe the actual dis-
tribution of each of the 256 ﬁrst bytes. Using an empiri-
cal reference of 245 keystreams, it is possible to recover the
ﬁrst 256 bytes of a plaintext, as soon as it is encrypted a suf-
ﬁcient number of times; this number varies from 224 to 232
as a function of the byte position in the 256 bytes keystream.
Using the reference distribution and the encrypted distribu-
tion, the idea is to ﬁnd the most probable byte value, by
measuring the distance between the reference distribution
and each of the candidate keystreams.
However, the attack is hard to implement, since it requires
a lot of diﬀerent TLS connections, and only works for data
sent in the ﬁrst few bytes. To overcome these limitations, the
researchers also used long-term biases described by Fluhrer
and McGrew [12] on consecutive bytes to perform a practical
attack requiring more keystream, but which could work in
a pipelined HTTPS stream (i.e. using diﬀerent messages
within the same TLS connection). This double-byte bias
attack is more practical than the single-byte bias one, and a
proof of concept was developed to recover an HTTP cookie.
Hypotheses and prerequisites
• TLS uses RC4 to encrypt data;
• The attacker is able to observe encrypted packets;
• Multiple connections containing the same secret can
be triggered.
Proposed countermeasures
Use CBC mode to avoid RC4. This is an eﬃcient way
to counter this attack, and it can be deployed easily and
reliably. Obviously, this recommendation is in contradiction
with the Use RC4 recommendation (from Sec. 2.1 and 2.3).
Use TLS 1.2 AEAD suites. This works but leads to
deployment and reliability issues.
Use another streamcipher. ChaCha20 [5] is currently
under examination by the IETF as an alternative stream
cipher. Such a change could be easier to deploy than a pro-
tocol version switch, as the ciphersuite negotiation is usually
better supported, but it will still require some time7.
Throw away the ﬁrst bytes of the keystream. This
behavior could be speciﬁed in TLS (with a new ciphersuite
or extension) or HTTP (by padding the beginning of mes-
sages), but we know exploitable long-term RC4 biases exist.
Randomize the packet length. As for compression at-
tacks, random padding would only increase the complexity.
2.5 POODLE: another padding oracle
In October 2014, M¨oller, Duong and Kotowicz presented
POODLE (Padding Oracle on Downgraded Legacy Encryp-
tion) [22], another padding oracle targeting SSLv3 CBC
mode. The old SSL version indeed handles CBC padding
in a speciﬁc way: when n bytes are needed to pad a plain-
text, the last byte is set to n − 1 (as in TLS, described in
Sec. 2.3), but the other bytes can take any arbitrary value.
An attacker can use this liberty to get a padding oracle.
Figure 4: POODLE attack exploiting SSLv3 CBC
Padding, assuming an 8-byte blockcipher.
Let’s assume an attacker can trigger requests to the vul-
nerable site using SSLv3 and CBC mode. Since she may
7Moreover, the current draft actually speciﬁes an AEAD
suite, not a streamcipher one, which would require TLS 1.2.
alter the path fragment in the URL, she may prepare the
request in such a way that the cookie ends on a block fron-
tier. Moreover, she may include a request body of arbitrary
length after the headers, which allows her to get a plain-
text message (once the MAC is appended) whose length is
a multiple of the block size (see Fig 4). This way, a whole
block would be added in the padding phase. Such a block
has only one constraint: the last byte must be n − 1 where
n is the block length.
Once the request is sent by the browser, the attacker needs
to modify the record on the wire. She must replace the all-
padding block by the block where the last byte is to be
guessed, as shown in Fig. 4.
If the decryption of the last
blocks leads to the correct value (n−1), the rest of the block
is ignored and the record is accepted by the server. It means
k (Ci) ⊕ Cn−1 is n − 1, and that the last
−1
the last byte of E
byte of Pi is Cn−1 ⊕ Ci−1 ⊕ (n− 1). If the padding does not
end with n− 1, the decryption will need to a MAC error and
to the end of the connection. If the attacker retries, another
key will be used and Cn−1 will be randomized. Thus, each
byte can be guessed with a 2−8 probability, which results in
256 requests needed to recover each byte of the secret value.
It is interesting to note that this attack relies on the
browser using a fallback strategy, and on the server to accept
the obsolete SSLv3 version of the protocol.
Hypotheses and prerequisites
• The connection uses SSLv3 with CBC mode;
• Plaintext can be loosely controlled by the attacker;
• The attacker is able to intercept and modify packets;
• Multiple connections containing the same secret can
be triggered.
Proposed countermeasures
Use TLS 1.0. Since this powerful padding oracle is only
present in SSLv3, forbidding this deprecated version is an
eﬃcient countermeasure. Moreover, only a small portion of
the internet still relies on this version of the protocol, which
makes this measure also practical.
Use RC4 to avoid CBC mode.
Use TLS 1.2 AEAD suites.
Switch to Encrypt-then-MAC. These three countermea-
sures work, with the same reservations as before.
Anti poodle record splitting. Opera and Google’s
developper Adam Langley proposed to split SSLv3 CBC
records to counter the POODLE attack. The proposed split-
ting method is supposed to avoid whole blocks of padding.
Yet, POODLE paved the way for new SSLv3 padding oracle
attacks, which may not be blocked this way.
TLS FALLBACK SCSV. M¨oller and Langley proposed
a mechanism to avoid browser fallbacks when a higher ver-
sion is supported by both the client and the server, using a
fake signaling ciphersuite. This would indeed block down-
grade attacks and POODLE in particular, between up-to-
date parties. Yet, legacy SSLv3 stacks would still be at risk.
2.6 Comparative analysis of these attacks
To mitigate these threats, many countermeasures have
been proposed. Our analysis shows that some of them have
no real eﬀect on the attacks: throwing the ﬁrst bytes of RC4
keystream, randomizing the packet length or adding random
CiGET ...Cookie: XXX...MACPaddingPlaintextcontrolledby the attackerto choose thisblock boundarycontrolledby the attackerto choose thisblock boundaryookie: XPi =.......7Pn =CnCn-1...Encrypted record...CiCiCn-1...Tampered record...Countermeasures
Dep. Rel. HTTP Beast L 13 RC4
*IME POODLE
+
+
+
+
+
–
– –
+
Structural changes to TLS
Use TLS 1.0
+
–
Use TLS 1.1
Encrypt-then-MAC
– –
Changes related to TLS ciphersuites or compression methods
+
Use CBC mode
+
Use RC4
+
Use a new stream cipher
+
Use AEAD (TLS 1.2)
No TLS compression
+
Changes related to TLS implementations
1/n − 1 split
+
+
Constant-time CBC
Anti poodle splitting
+
Other countermeasures in related work
–
Single-use cookie
One-Time Cookies [7]
+
Countermeasures presented in this article
+
TLS scrambling
+
MCookies (server)
MCookies (client/server)
+
– –
–
– –
– –
– –
+
+
+
+
+
+
+
–
–
+
+
+
–
+
+
+
+
+
–
+
p
+
+
+
+
p
+
+
+
+
+
–
–
–
+
+
+
+
+
+
+
+
+
+
p
+
+
+
+
+
+
+
p
+
+
+
+
+
p
+
+
+
Table 1: Summary of the proposed countermeasures.
delays to CBC-mode decryption. Others require signiﬁcant
changes to the architecture of web applications and would
be hard to enforce: restricting cross-site requests or ﬁxing all
SOP/XSS bugs. The remaining countermeasures are listed
in Table 1, and compared using diﬀerent criteria:
• Dep. relates to the ease of deployment of the pro-
posed solution. In particular, studies [24, 19] shed light
on the problem of existing intolerance, e.g. new TLS
versions raising important compatibility issues;
• Reliability (Rel.) corresponds to the assurance we
have the countermeasure will not be easily bypassed
between a client and a server both implementing the
solution. The idea is to capture the possible down-
negotiation and fall-back strategies (for example issues
related to TLS version negotiation);
• HTTP assesses the compatibility of the measure with
HTTP use-case. Current web applications have to e.g.
accommodate with multi-tab browsing. Countermea-
sures should not break or limit such features;
• A set of columns state whether the countermeasure
is eﬃcient against each attack (BEAST, L13, RC4,
*IME for compression attacks, and POODLE), ”p”
meaning the measure only partially blocks the attack.
The last lines of the table describe countermeasures pro-
posed in related work (Sec. 6) and our proposals (Sec. 4).
3. ATTACKER MODEL AND THE MASK-
ING PRINCIPLE
The legitimate actors we consider are: the user agent (e.g.
Firefox), the HTTP(S) server (e.g. Apache) and the web
application (a program written in PHP or Python for exam-
ple). The web application may rely on a framework designed
to abstract the inherent complexity of web development (e.g.
Django or Zend). The attacker we consider is an active net-
work attacker, able to read, modify or delete packets be-
tween the client and the server. We also assume, as for each
of the attacks presented in Sec. 2, that a secret cookie is
repeated across diﬀerent TLS messages.
Given a TLS session, we assume the attacker is able to
retrieve some information about κ consecutive bytes of the
corresponding plaintext. Typically, κ = 1, and the attacker
is able to check whether a cleartext byte is equal to a guessed
value. Thus, by repeating the attack on constant plaintext
bytes, she can recover this part of the plaintext.
To draw a parallel with side-channel attacks [6, 15, 26],
such attacks may be called ﬁrst order attacks. To deal with