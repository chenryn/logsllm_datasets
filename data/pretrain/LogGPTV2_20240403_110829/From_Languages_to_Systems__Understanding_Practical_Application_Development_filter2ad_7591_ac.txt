and encrypted with bob’s public key (k+
bob). Then the orig-
inal body is replaced with the encrypted body along with
the encrypted, one-time key, i.e. the message body contains
bob, k). The encrypted values can be declassi-
E(k, b), E(k+
ﬁed to be visible by the server without compromising bob’s
privacy. 4) Finally, the email is sent to the SMTP server,
which in turn delivers it to the POP3 server.
Reading email Bob retrieves his email from a POP3
server using the MailReader class. 5) After connecting
to the server, the mail reader takes in each email and ex-
amines the label ﬁeld in the header (Label in the ﬁgure).
The header information can remain public, but the text of
the body must be decrypted and reclassiﬁed according to
the label ﬁeld. 6) To do this, we require Bob’s private key.
Since Bob has access to his own private key, it can be read
in from the ﬁle system, labeled as bob. If another user were
trying to impersonate Bob, the private key would not be
available and the attempted decryption would fail. 7) Since
6
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:33:30 UTC from IEEE Xplore.  Restrictions apply. 
Proceedings of the 22nd Annual Computer Security Applications Conference (ACSAC'06)0-7695-2716-7/06 $20.00  © 2006Figure 2. Sending and retrieving a message using the JPmail client.
Bob’s private key is labeled as bob, decrypting the body of
the email automatically raises the plaintext’s security level
to bob. Now that the body is safely in the conﬁnes of the
Jif sandbox, it can be decrypted without fear that it will be
leaked. 8) Finally, since the user who is running the mail
reader is bob, this email can be printed to bob’s terminal.
5 Tools
Our experience in JPmail has highlighted the need for
additional policy and application development tools. Al-
though we have focused our attention on Jif, these tools
would be necessary in any security-typed language. The
following describes the tools we developed to address areas
we found most challenging and/or time-consuming: high-
level, policy development in a distributed system and soft-
ware engineering.
5.1 Policy tools
Jif lacks a policy management infrastructure. We devel-
oped such an infrastructure consisting of two components:
a runtime policy store that provides dynamic access to prin-
cipals, and a policy compiler that automatically generates
principals and initializes the policy store. We describe the
policy language and compiler more fully and more formally
in a recent, prior work [12], including a proof of correctness
and the security property they maintain. In this work, we
have made this policy infrastructure more robust and useful
in a distributed system through binding principals to pub-
lic/private key pairs. We brieﬂy consider these tools below
and describe the new extension for cryptographic principals
and give some example usage in the context of JPmail.
principal
p ::=
declassiﬁer D ::=
delegation
trust stmt
policy stmts Stmt ::= (Del | Allow)∗
alice | bob | ...
method1 | method2 | ...
p -> p
Del ::=
Allow ::= p allows D(p) | p allows None
Figure 3. Policy language syntax.
Policy language and compiler
Jif lacks high-level pol-
icy speciﬁcation tools. We desire to automatically gener-
ate Jif policy infrastructure (code) from high level speciﬁ-
cations. To this end, we developed a policy language and
an accompanying compiler. Currently, the policy language
consists of only two types of policy statements: delegations
and declassiﬁer-allowances (implicitly, there is also the dec-
laration of the principals themselves). The syntax is given
formally in Figure 3. Recalling Observation 2 from Sec-
tion 3.2, we hold that this simple policy is complete for
capturing the global meaning of local policy labels.
Illustrated in Figure 4, policy is integrated into a Jif pro-
gram by using the policy compiler. The compiler interprets
the policy speciﬁcation, given in a separate ﬁle, and gen-
erates the associated Jif code. The created code provides
functions for the creation of principals (as identiﬁed in the
speciﬁcation) and for their insertion in the policy store. The
policy speciﬁcation also includes explicit authorizations of
all the declassiﬁers that the principals trust. Functions for
the policy initialization and principal delegations described
in the policy ﬁle are also created. Finally, this automatically
generated code is introduced into the Jif application with a
single line of Jif code.
Jif provides a Principal interface which allows for policy
to be implemented directly in dynamic principal objects. In
7
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:33:30 UTC from IEEE Xplore.  Restrictions apply. 
emailbodyemailbodyTo: bob@From: alice@Label: bob1reclassifybody andheaderemailbodyTo: bob@From: alice@Label: bobﬁlterbodybob's public keyPolicyStoreauthorizefilteredbodyTo: bob@From: alice@Label: bobSocketto SMTP ServerauthorizefilteredbodyTo: bob@From: alice@Label: bobSocket fromPOP3 ServerreclassifybodyauthorizeemailbodyTo: bob@From: alice@Label: bobAlice's terminalBob's terminalKeyStorebob's private key2345678AliceBobpublicinternetProceedings of the 22nd Annual Computer Security Applications Conference (ACSAC'06)0-7695-2716-7/06 $20.00  © 2006Figure 4. The policy compiler automatically
generates Jif policy objects from user speci-
ﬁcations.
particular, Jif Principals maintain a list of principals they
delegate to and they also allow the programmer to imple-
ment a method which is called to authorize a declassiﬁca-
tion. The Principal interface can also be implemented with
additional member data, allowing us to push public keys
(and if available, private keys) directly into dynamic prin-
cipals. Our policy compiler automatically generates a Prin-
cipal implementation for each principal given in the pol-
icy ﬁle. It automatically generates the authorization method
based on the allow-statements for the permissible declas-
siﬁcations associated with the principal. It also generates
the JifPolicy class which instantiates and initializes each
principal, establishes its delegations (according to the pol-
icy ﬁle) and loads its public and, if available, private key. Fi-
nally, it creates a policy store in which it stores all the newly
created principals (they can be looked up by name and used
in policy labels) and it returns this policy store to the calling
application. To use a policy, an application must merely re-
trieve a policy store by calling JifPolicy.setupPolicy.
As an example, a security research lab could design a
policy in which all of the members are listed in the policy
and their public keys are certiﬁed by a lab’s certiﬁcate au-
thority. Emails can be sent freely throughout the lab. Emails
destined for recipients outside the lab are handled by a sep-
arate ﬁlter that imposes the lab’s policy on external mail
(whether it be adding a disclaimer, limiting the number of
outgoing messages, auditing outgoing messages, etc.). In
Figure 5, we illustrate this lab policy. Principals begin with
lower-case letters and declassiﬁers with uppercase (public
is repeated only for clarity of reading.) The solid arrows in-
dicate delegations, the “T” arrows indicate allowances and
the dashed arrows indicate the lowest level a ﬁlter may de-
classify to. Note that this lab policy was used for the devel-
opment testing of JPmail.
Figure 5. Delegation hierarchy and declassiﬁ-
cation allowances for a sample, research lab
security policy.
Cryptographic principals Cryptography provides two
central functions within JPmail4: it is critical for ensuring
data is not leaked as it passes outside of a Jif application
and it plays an essential role in maintaining the consistency
and integrity of principals from one Jif application to an-
other. This former function is achieved via encryption of
email bodies. In the latter function, principals are uniquely
identiﬁed via an association with a public key (certiﬁcate).
We leveraged existing facilities for creating and verifying
X.509 certiﬁcates for this purpose. For certiﬁcate signing
and veriﬁcation, we created a JPmail-speciﬁc certiﬁcate au-
thority (CA).
Our use of certiﬁcates required us to bind public keys
to Jif’s principals.
In Jif, principals are created by im-
plementing a Principal interface. We created our own
KeyPrincipal by implementing the standard Principal
interface (which requires a name, closure authorization test-
ing, equivalence testing and delegation testing) and also
adding ﬁelds for a public and, if it’s available to the current
user, a private key. Before allowing a public key to be asso-
ciated with a principal, the certiﬁcate containing the public
key is validated using the public key of the trusted CA. For
sending email to users outside the system, the external
principal can be used which can be declassiﬁed with the
FilterBody declassiﬁer (this could be used to audit emails
or add a disclaimer, e.g.). In order to add a new principal to
the system, the principal’s public key certiﬁcate must be dis-
tributed and a delegation should be added by each principal
to their policy to include the new user. Because the policy
is decentralized, it could be stored on a common server and
each user could update his own policy, while possibly also
4JPmail uses the following algorithms: DES, TripleDES, AES were
used in CBC mode for all symmetric key operations, and RSA Electronic
Codebook (ECB) mode with PKCS1 padding for asymmetric key opera-
tions. We also used MD5 hashes on passwords for authentication with the
email servers according to the POP3 and SMTP protocols.
8
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:33:30 UTC from IEEE Xplore.  Restrictions apply. 
alice -> bobalice allows AES...policy compilerJif compilerAESClosure...class MailSender...AlicePrincipal...class PolicypolicyPolicy.setupPolicy();void main() {...}Jif code(auto-generated)Jif codeMailSender...policy and applicationclass ﬁlesAliceBobalicebobAES.encryptRSAself.encryptpublicSIIS labpublicexternalDeclassHdrDeclassBodypublicexternalFilterBodyAuditDelegationsAllowancesProceedings of the 22nd Annual Computer Security Applications Conference (ACSAC'06)0-7695-2716-7/06 $20.00  © 2006maintaining some mandatory requirements. These are areas
of future investigation.
In order to integrate the delegations and authorizations
deﬁned in our policy with the local ﬁle system, we had to
augment the Jif compiler’s runtime environment. By intro-
ducing a method to delegate from a NativePrincipal to
a non-native principal, we make an association between the
user running the program and one of our internal principals.
In order to authorize this association, we require that the
user can only delegate to a principal for whom the user can
provide the private key. In other words, JPmail authenti-
cates the claimed principal by checking that it has a signed
certiﬁcate from the CA with the principal’s identity and the
associated private key before it allows the user to assume
that identity. It does this by loading the private key from the
user’s key store, for which it requires the user’s password
and checking it against the JPMail-speciﬁc CA.
5.2 Practical tools for software engineering
An integrated development environment (IDE) To par-
tially address the limitations of the current development en-
vironment, we developed an IDE for Jif. This tool integrates
the Jif compiler with the open-source Eclipse5 integrated
development platform. Eclipse has been used to build IDEs
for a wide variety of languages such as C and Java. This
IDE, even in its most basic form, represented 80-100 man-
hours of work. For brevity, we discuss only the impact of
the IDE.
The main beneﬁt of the Jif IDE (so far) is that it con-
siderably reduces the edit/compile/repair development cy-
cle. As Eclipse runs the Jif compiler in the background, it
quickly tags syntax errors, missing exceptions, missing im-
port statements and even security label violations. Thus, er-
rors, especially vexing book-keeping errors, can be quickly
ﬁxed without having to switch to a terminal window and re-
compile the source. Furthermore, the integrated support for
syntax-highlighting and easy integration with version con-
trol tools such as CVS and subversion were welcome ad-
ditions to the Jif programming environment. Future devel-
opment in the Jifclipse feature will include more complex
refactoring algorithms, greater contextual awareness of la-
bels, integration with our policy tools, and a host of runtime
and development utilities.
Declassiﬁers Declassiﬁers play a key role in providing se-
curity guarantees. Because all realistic security-typed ap-
plications need to have some way of declassifying infor-
mation (since even functions like encryption and password
checks leak small amounts of information), it is valuable to
build up a collection of commonly used declassiﬁers. For
example, encryption and auditing functions can declassify
data–they expose some amount of data, but (under certain
circumstances) it is not enough to be deemed a leak. Such
5http://www.eclipse.org/
9
functions are similar to seal classes [1, 22], which provide a
declassifying ﬁlter that limits when information is released.
Libraries of common declassiﬁers can be carefully engi-
neered and formally veriﬁed to prevent unacceptable or dan-
gerous leakage (as opposed to the vanishingly small leak
from encryption or the acceptable leak from an audit or
password check). Applications can beneﬁt from this vet-
ting, and avoid declassifying through potentially dangerous
or untested interfaces [23].
We have built a library of declassiﬁers for use in Jif ap-
plications. The declassiﬁers we constructed for encryption
have widespread value and could be re-used without modi-
ﬁcation in other applications. Some of the declassiﬁers we
created are special-purpose, because they are made to han-
dle only email objects. Even these, however, are useful as
blueprints for other application developers. Because of its
extensive use of declassiﬁcation, JPmail required the explo-
ration of new features available in Jif 2.0: Closures and
the Principal interface. Our code serves as the ﬁrst ex-
plorations into the utility and ﬂexibility of these features6.
6 Evaluation
Based on our experience of implementing an email
client, we now evaluate the use of Jif to build the JPmail
application and suggest improvements to aid future devel-
opers. Some preliminary timing measurements indicate that
the overhead of Jif, especially for an I/O-bound application
like email, is not signiﬁcant [13]. The greatest slow-down
is caused by the encryption, which could possibly be im-
proved by entrusting the encryption to the operating system,
using, for example, IPsec. In this section, however, we are
primarily concerned with evaluating the security and usabil-
ity of Jif.
Jif provides a strong basis for assessing the correctness
of an security policy implementation. Recall our secu-
rity policy given in Section 2.1: “The body of an email
should be visible only to the authorized senders and re-
ceivers.” We can be sure that this policy has been cor-
rectly implemented by examining the label on emails and
cross-checking with the policy ﬁle about what information
ﬂows are possible with that label. In particular, by examin-
ing the smtp.MailSenderCrypto class and the readMes-
sage method, we ﬁnd that an email is read in from an in-
put stream which has the user’s label (the user who ran the
mail client) and consequently is also labeled with the user’s
label. Furthermore, the user provides the name of the prin-
cipal rcpt to whom he wishes to send the email. That prin-
cipal is looked up in the principal store and associated with
a Jif principal (which was created from the policy ﬁle). The
body of the email is then passed through a declassiﬁer, De-
classMsgBody which will relabel the body to {rcpt:} if
6Our code is made available at http://siis.cse.psu.edu/
jpmail.html.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:33:30 UTC from IEEE Xplore.  Restrictions apply. 
Proceedings of the 22nd Annual Computer Security Applications Conference (ACSAC'06)0-7695-2716-7/06 $20.00  © 2006rcpt is one of the allowed recipient principals, given in the
policy ﬁle. From this point, the rcpt policy governs all in-
formation ﬂows. Namely, before this email can be placed on
the public socket, it must pass through another declassiﬁer
based on rcpt’s policy. If rcpt allows for AES encryption,
then the email is encrypted as described in Section 4, using a
one-time randomly generated key (which cannot be leaked,
because it is labeled rcpt) and the principal’s public key.
We can repeat this evaluation for other sensitive data
such as keys and passwords. For these items the analysis
is even simpler, because they are not dynamically labeled
like emails (which depend on user input). The password is
given a label when a MailSenderCrypto object is created.
Checking the policy ﬁle, we can see that Strings cannot be
declassiﬁed except through an MD5 ﬁlter. Creating an MD5
hash is necessary for authentication with the mail server.
This was made clear when we tried to send the password
as plaintext over the mail server socket when establishing
a connection. This insecure practice was automatically dis-
allowed by Jif. At this point, we face a limitation in Jif’s
security analysis. Namely, the SMTP and POP3 protocols’
password authentication ensures that a nonce is used to pre-
vent replay attacks. This is not encoded in the Jif labels in
any way. Merely knowing the declassiﬁer that is used is
not enough to ensure that replay attacks are avoided—only
that the plaintext has not been leaked. We have to trust in