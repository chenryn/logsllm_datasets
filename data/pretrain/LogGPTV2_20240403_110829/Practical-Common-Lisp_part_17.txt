一之前的foo调用真的改变了全局的值。来自bar的第一次对foo的调用
13
2
www.TopSage.com
，可以重定义foo来包含一个
---
## Page 82
之前绑定上所保存的值也没有任何效果。因此，函数
法和动态绑定。?例如，为了将值10赋给变量x，可以写成这样：
改那个位置。当该位置是变量时，它展开成一个对特殊操作符SETQ的调用，后者可以访问到词
的基本形式：
的当前值。而为绑定赋予新值则要使用SETF宏一
看到的，一个符号被求值为它所命名的变量的值，因此，可以简单地通过引用这个变量来得到它
6.5赋值
些可能想改变的东西，则应转而使用DEFPARAMETER。
内联到代码中了。因此最好只用DEFCONSTANT来定义那些真正是常量的东西，例如π。而对于那
多数实现将要求对任何引用了该常量的代码进行求值以便它们能看到新值，因为老的值可能已经
式的DEFCONSTANT来重定义一个常量，但在重定义之后究竞发生什么是没有定义的。在实践上，
种程度上不像全局特殊名字的*命名约定那样流行，但也不错。?
此，许多Lisp程序员遵循了一个命名约定，用以+开始和结尾的名字来表示常量，这一约定在某
此该名字仅被用于指向常量，它不能被用作函数形参或是用任何其他的绑定形式进行重绑定。因
并且使用DEFCONSTANT定义，DEFCONSTANT的基本形式与DEFPARAMETER相似。
6.4
才使用动态变量。
下游代码可以为栈的上一级所建立的绑定赋予一个新的值。你应该只有在需要利用这两个特征时
全局变量具有两种超距效果—它可以改变下游代码的行为，并且它也开启了一种可能性，使得
②某些守旧的Lisp程序员喜欢使用SETQ对变量赋值，但现代风格倾向于将SETF用于所有的赋值操作。
①一些由语言本身所定义的关键常量并不遵循这一约定，包括但不限于T和NIL，这在偶尔有人想用t作为局部变量
正如早先所讨论的，为一个绑定赋予新值对该变量的任何其他绑定没有效果，并且它对赋值
关于DEFCONSTANT，需要注意的另一点是，尽管语言允许通过重新求值一个带有初始值形
一旦创建了绑定，就可以对它做两件事：获取当前值以及为它设置新值。正如在第4章里所
我尚未提到的另一种类型的变量是常值变量（constant variable)。所有的常量都是全局的,
(setf x 10)
因为sETF是宏，所以它可以检查它所赋值的place上的形式，并展开成适当的底层操作来修
(setf place value)
与DEFVAR和DEFPARAMETER相似，DEFCONSTANT在所使用的名字上产生了全局效果—从
动态绑定使全局变量更易于管理，但重要的是注意到它们将允许超距作用的存在。绑定一个
名时会很讨厌。另一个是PI，其含有最接近数学常量π的长浮点值。
常量
www.TopSage.com
一Common Lisp的通用赋值操作符。下面是sETF
6.5赋值
65
---
## Page 83
数据类型的语言里，=也可以设置哈希表项的值。表6-1总结了=在那些语言里的不同用法。
作符可以将新值赋给变量、数组元素和类的字段。在诸如Perl和Python这类支持哈希表作为内置
经拓展后甚至可为由用户定义的位置赋值。
来使用。总之，如果需要对位置赋值，那么几乎肯定要用到SETF。虽然在此不予介绍，但SETF
为任何位置赋值。当描述不同的复合数据结构时，我将指出哪些函数可以作为SETF的“位置”
6.6
也可写成：
新值。
将打印出20而不是10，因为传递给foo的y的值在该函数中变成了x的值，随后又被SETF设置成
即替换了作为参数传递的任何值，特别是在如下形式中：
中的sETF对于foo之外的任何值都没有效果。这个在foo被调用时所创建的绑定被设置到10，立
组、
从这个角度来说，SETF和多数源自C的语言中的赋值操作符没有区别。在那些语言里，=操
个随机值：
66
① 查看DEFSETF和DEFINE-SETF-EXPANDER以获取进一步的信息。
后续章节里将讨论那些数据结构，但就目前所讨论的赋值主题而言，你应该知道SETF可以
哈希表、列表以及由用户定义的数据结构，所有这些都含有多个可用来保存值的位置。
1
当然，变量绑定并不是唯一可以保留值的位置，Common Lisp还支持复合数据结构，包括数
SETF返回最近被赋予的值，因此也可以像下面的表达式那样嵌套调用SETF，将x和y赋予同
SETF也可用于依次对多个位置赋值。例如，与其像下面这样：
(setf x (setf y (random 10)))
(setf
(setf x 1)
(let ((y 20))
(defun foo (x)(setf x l0))
广义赋值
对象字段
哈希表项
赋值对象
(print y))
数组元素
变量
第6章 
x1y2)
变量
o.field = 10;
a[0] =10;
x = 10;
Java, C, C++
表6-1
www.TopSage.com
=在其他语言中的用法
$o->{'field'} = 10;
$hash{'key'} = 10;
$a[0] = 10;
Perl
o.field = 10 
hash['key'] = 10
a[0] = 10 
x = 10
Python
---
## Page 84
可笑：
值一次的位置。在下面这个表达式中，INCF会递增一个数组中任意元素的值，这个例子确实很
样的修改语句更加简洁。另外，修改宏所定义的方式使其可以安全地用于那些表达式必须只被求
于作用位置上的当前值来赋予该位置一个新值。修改宏的主要好处是，它们比用SETF写出的同
的特定数量对一个位置的值进行递增和递减。
但跟C风格的++x和--x相比就显得很长了。相反，可以使用宏INCF和DECF，它们以默认为1
或是像这样来递减它：
由于经常使用，因此有它们自己的操作符。例如，尽管可以像这样使用SETF来递增一个数：
6.7
Perl和Python中的行为非常相似。?
的语义：被修改的位置对之前保存在该位置上的对象没有任何影响。再次说明，这跟=在Java、
可能是一个访问某用户定义对象中名为field的成员的函数。如下所示：
6-1中赋值语句的Lisp等价形式分别为：AREF是数组访问函数，GETHASH做哈希表查找，而field
② C程序员可能将变量和其他位置看成是保存了实际对象的指针。对一个变量赋值简单地改变了其所指向的对象，
①源自Algol使用=左边的“位置”和右边的新值进行赋值的语法得到广泛使用，由此产生了术语“左值”（lvalue,
类似INCF和DECF这种宏称为修改宏（modify macro），修改宏是建立在SETF之上的宏，其基
(setf x (-x 1))
(setf x (+ x l))
尽管所有的赋值都可以用SETP来表达，
注意，当用SETF对一个作为更大对象一部分的位置进行赋值时，与赋值一个变量具有相同
SETF以同样的方式工作一
((( ua) u)  a1) o)
Slot named 'field':
Hash table:
Array:
Simple variable:
left value的缩写)，意思是可被赋值的某种东西，以及“右值”（rvalue)，意思是某种可以提供值的东西。一个编
一个到SETF表达式的幼稚转换方法可能看起来像这样：
(incf x 10) = (setf x (+ x 10))
(incf x)
理对象时，确切地说，在进行成员复制时，一的行为是相当特异的。
而对一个复合对象中的一部分赋值，则类似于重定向通向实际对象的指针。C十+程序员应该注意到在C++中当处
译器黑客将会说，
其他修改位置的方式
= (setf x (+ x 1))
(setf x
“SETE将其第一个参数视为左值”。
(setf (field o) 10)
(setf
setf
(setf x 10}
-SETF的第一个参数用来保存值的位置，而第二个参数提供了值。
 (gethash 'key hash) 10)
(aref a 0) 10)
www.TopSage.com
，但有些固定模式（比如像基于当前值来赋予新值)
6.7 其他修改位置的方式
67
---
## Page 85
他语言的特性：宏。
从左到右的顺序对每个参数仅求值一次。
将等价于如下形式。同样，不必担心副作用。
到倒数第二个参数上，而其他的值将向左移动一个，第一个参数的最初值将被简单地返回。这样，
的表达式将等价于如下形式：
将交换两个变量的值并返回NIL。由于a和b是变量并且不需要担心副作用，因此前面的ROTATEF
之间轮换它们的值。如果有两个变量a和b，那么如下调用
章在讲到如何在LiSp中表示列表时会详细地介绍它及其对应的POP和PUSHNEW是如何工作的。
值一次。
会等价于以下形式。
取出其中可能带有副作用的部分，从而确保它们仅被求值一次。在本例中，经展开后，它差不多
比，上面的INCF表达式却能产生正确的行为，因为它知道如何处理这个表达式：
取数组中一个元素的值，将其递增，然后将其作为新值保存到另一个不同的数组元素上。与之相
但它不会正常工作，因为两次对RANDOM的调用不一定能返回相同的值一
学完了CommonLisp函数和变量的基础知识以后，下面将开始介绍一个令Lisp始终区别于其
（shiftfab10)
最后有两个稍微有些难懂但很有用的修改宏，它们是ROTATEF和SHIFTF。ROTATEF在位置
在第3章那个微型数据库中曾用来向*db*变量添加元素的宏PUSH则是另一个修改宏。第12
68
ROTATEF和SHIFTF都可被用于任意多个参数，并且和所有的修改宏一样，它们可以保证以
SHIFTF与之相似，除了它将值向左侧移动而不是轮换它们——最后一个参数提供的值移动
(rotatefab)
(let（（tmpa))（setfabb10）tmp)
对于其他不同类型的位置，使用SETF的等价表达式将会更加复杂一些。
(let((tmpa))(setfabbtmp）nil)
一般而言，修改宏可以保证以从左到右的顺序，对它们的参数和位置形式的子形式每个只求
(aref *array*(random (length *array*)))
(setf（aref*array*tmp)(1+（aref*array*tmp))))
第6章变量
(1+(aref*array*(random (length*array*)))))
www.TopSage.com
一该表达式将很可能抓
---
## Page 86
将是它所提供的另一种语言扩展方式，而这将使Common Lisp成为更好的用于表达特定编程问题
硬编码到语言核心。这已经牵涉到语言本身是如何实现的，但作为--个Lisp程序员，你更关心的
和DEFPARAMETER这样的定义形式，从而使这些新语法可以作为“标准库”的一部分而不是将其
述，每个宏都定义了自己的语法，它们能够决定那些被传递的S-表达式如何转换成Lisp形式。核
个特性稍微丰富一点的C版本。类似地，在诸如Java或Smaltalk这类几乎所有有趣部分都是由
可表达性——由于所认为的“语言”很大程度上其实是一-个库，因此很容易对其进行扩展。如
例如，C的标准库就差不多可以完全用可移植的C来实现。类似地，Java的标准Java开发包（JDK）
现在先退一步，从观察各种语言支持扩展的不同方式讨论Lisp宏。
解Lisp的宏，就真的需要重新看待它，不能带有任何基于其他碰巧也叫做宏的概念所带来的成见。
试图向非Lisp程序员解释宏这种特性的伟大之处时，这种相似性导致了无休止的误解。“要想理
心语言有了宏，就有可能构造出新的语法，诸如WHEN、DOLIST和LOOP这样的控制构造以及DEFUN
何程序。
类来定义的语言里，通过定义新的类就可以扩展该语言，使其更适用于编写你正试图编写的任
果C语言中不含有所需的用来做某件事的一个函数，那就可以写出这个函数，然后就得到了一
了。只要它还没有被定义成标准库的一部分，那么这些功能就可以被任何程序员在语言之上实现，
的标准功能库——如果某些功能没有定义在标准库中，那么它们可能已经被程序员实现在语言中
在计算领域可以描述很多东西，但和Common Lisp的宏相比，它们仅大致相似。当Lisp程序员们
① 想要了解这类误解，可以在相对长期的Usenet新闻组上，以macro为主题，在comp.lang.lisp和comp.lang.*之间交叉
尽管CommonLisp支持所有这些扩展语言的方法，但宏还提供了另一种方式。如同第4章所
使用核心加上标准库的方式来定义语言的优势在于易于理解和实现。但真正的好处在于其
所有的程序员应该都熟知这么一种观点，语言的定义可能会包含一个借由“核心”语言实现
其他语言支持者：“你认为Lisp好是因为它的宏吗？！但宏是可怕和有害的，因此Lisp也一定是可怕和有害的。”
Lisp支持者：“Lisp是最强的，因为它有宏!”
投递的讨论中搜索。一
但Lisp的宏系统却始终使它保持了在语言风格上的独特性。遗憾的是，宏这个字虽然
一个大致的说法如下：
宏：标准控制构造
www.TopSage.com
---