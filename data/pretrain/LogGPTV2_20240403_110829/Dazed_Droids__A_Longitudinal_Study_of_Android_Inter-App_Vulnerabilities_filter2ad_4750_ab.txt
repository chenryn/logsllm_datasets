malCmp.detailedPaths = malPath & malPath.source = IPC
malPath.sink in SensitiveSinks }
Listing 1. Alloy speciﬁcations of Intent Hijack vulnerability in Android.
or across multiple components. COVERT analyzes the app
using static taint analysis technique to track sensitive data
(cid:104)Source, Sink(cid:105). To achieve a high precision in
ﬂow tuples
data ﬂow analysis, COVERT’s analysis is ﬂow-, ﬁeld-, and
context-sensitive, meaning that it distinguishes a variable’s
values between different program points, distinguishes be-
tween different ﬁelds of a heap object, and that in analysis of
method calls is sensitive to their calling contexts, respectively.
In the interest of scalability, the analysis, however, is not path-
sensitive. For single component taint analysis, COVERT relies
on FlowDroid [5], but for analyzing sensitive data paths across
components,
it performs a formal, compositional analysis,
discussed in Section III-A2.
Permission Extraction: To ensure the permission policies
are preserved during an inter-component communication, one
should compare the granted permissions of the caller com-
ponent against the enforced permissions at the callee com-
ponent side. Therefore,
the permissions actually used by
each component should be determined. In doing so, COVERT
relies on API permission maps available in the literature,
and in particular the PScout permission map [6], one of the
most recently updated and comprehensive permission maps
available for the Android framework. API permission maps
specify mappings between Android API calls/Intents and the
permissions required to perform those calls.
2) Formal Analyzer: COVERT relies on lightweight formal
analysis techniques, and in particular Alloy [7] for modeling
and analysis purposes. Alloy [7] is a formal speciﬁcation
language based on ﬁrst order logic, optimized for automated
analysis. The Formal Model Generator module of the Formal
Analyzer ﬁrst
translates the set of app models extracted
by Model Extractor into the Alloy speciﬁcation language.
Formal models are then combined together with a formal
speciﬁcation of the application framework, and checked as a
whole for vulnerabilities that occur due to the interaction of
apps comprising a system. For this purpose, COVERT uses the
Aluminum [8] extension of the Alloy Analyzer as the analysis
engine. The analysis is conducted by exhaustive enumeration
over a bounded scope of model instances. Here, the exact
scope of each element, such as Application and Activity, re-
quired to instantiate each vulnerability is automatically derived
from the speciﬁcation.
To perform the compositional analysis on a set of formal
models, we designed speciﬁc Alloy signatures that model a set
of security properties required to be checked. These signatures
727727727727
express properties that are expected to hold in the extracted
speciﬁcations. Listing 1, for example, expresses the Intent
Hijack signature. In short, the signature states that an implicit
Intent (vulIntent) containing sensitive data retrieved from
a sensitive source at a vulnerable component (vulCmp) could
be hijacked by a malicious component (malCmp) that leaks
this data through a sensitive sink. If a signature is satisﬁed,
the analyzer reports it as a vulnerability, along with the
information useful in ﬁnding the root cause of the violation.
Finally, the Vulnerability Model Generator module (recall
Figure 2) reﬁnes and translates the Alloy solver results to the
veriﬁcation report, which is returned to the user with the detail
speciﬁcation of each detected vulnerability. More details on
COVERT’s back-end are described in [2].
B. Front-end
In order to facilitate the end-user interactions with COVERT
back-end engine, we implemented client applications for
different platforms: Desktop Application, which is a stand-
alone tool that calls back-end components and visualizes the
generated results. Mobile and Web-based applications that
work together to analyze the installed apps in a mobile device
and show the vulnerability report on web browsers.
Desktop Client is a JavaFX [9] application that provides a
graphical user interface and enables end-users to analyze a set
of APK ﬁles, which could be downloaded from online app
stores such as Google Play or grabbed from their own mobile
devices using adb [10] tool. The features of this application,
which is available in COVERT’s web page [11], are described
in more detail at the end of this Section.
As an alternative client support, Mobile and Web-based
applications work together to analyze the installed apps in a
mobile device and generate the vulnerability report, without
the need for directly providing the app bundles to the back-
end engine. Mobile app, on the one hand, runs on a mobile
device and retrieves the information of installed apps on the
same device, including the package name, and the version
code. This information, along with the device’s identiﬁer, are
then sent to the back-end server, where the identiﬁed apps are
downloaded and analyzed. On the other hand, the user can
access the analysis results via the web-based application, by
providing the device identiﬁer as the access key.
To achieve a high level of scalability, a central repository
of app models is maintained in the back-end server. Thereby,
before extracting each app model, which is an expensive task,
COVERT ﬁrst searches the central repository for that app, by
using the combination of its (cid:104)package name, version code(cid:105) as
the key. If the app model already exists in the repository, the
existing model is reused for the analysis.
In the following, we illustrate some key features of our
tool through a real-world example. Figure 3 shows a snapshot
of COVERT’s front-end desktop application after loading the
results of back-end analysis for sample apps from our ex-
perimental collection. In part (a), the detected vulnerabilities
are categorized based on inter-component vulnerability classes
identiﬁed by prior research [1], [3]: Intent Hijack, Intent
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 07:01:10 UTC from IEEE Xplore.  Restrictions apply. 
ICSE 2015, Florence, Italy Demonstrationsnegatively affects the precision of this approach in inter-
component path matching. Moreover, DidFail
is a purely
program analysis tool, and does not
incorporate a formal
analysis technique.
V. CONCLUSION
This paper presents COVERT, a tool that analyzes Android
applications in a compositional manner to detect inter-app
and inter-component security vulnerabilities. COVERT, at its
core, consists of a back-end engine that extracts formal model
of apps and analyzes the extracted models together to ﬁnd
the vulnerabilities. On top of the core, COVERT comes with
desktop, mobile and web-based front-end applications that
facilitate the end-user interactions with the analysis engine.
The experimental results [2] corroborated its ability to reveal
inter-app vulnerabilities in real-world Android apps, many of
which were previously unknown.
ACKNOWLEDGEMENTS
This work was supported in part by awards D11AP00282
from the US Defense Advanced Research Projects Agency,
H98230-14-C-0140 from the US National Security Agency,
HSHQDC-14-C-B0040 from the US Department of Homeland
Security, and CCF-1252644 from the US National Science
Foundation.
REFERENCES
[1] L. Davi, A. Dmitrienko, A.-R. Sadeghi, and M. Winandy, “Privilege
escalation attacks on android,” in the 13th Intl. Conf. on Information
security, 2010, pp. 346–360.
[2] H. Bagheri, A. Sadeghi, J. Garcia, and S. Malek, “Covert: Compositional
analysis of android inter-app permission leakage,” IEEE Transactions on
Software Engineering (TSE), 2015.
[3] E. Chin, A. P. Felt, K. Greenwood, and D. Wagner, “Analyzing inter-
application communication in android,” in Proceedings of MobiSys,
2011, pp. 239–252.
[4] E. Bodden, “Inter-procedural data-ﬂow analysis with ifds/ide and soot,”
in Proceedings of SOAP. ACM, 2012, pp. 3–8.
[5] S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel, J. Klein,
Y. Le Traon, D. Octeau, and P. McDaniel, “Flowdroid: Precise context,
ﬂow, ﬁeld, object-sensitive and lifecycle-aware taint analysis for android
apps,” in Proceedings of PLDI, 2014, pp. 259–269.
[6] K. W. Y. Au, Y. F. Zhou, Z. Huang, and D. Lie, “Pscout: Analyzing
the android permission speciﬁcation,” in Proceedings of CCS, 2012, pp.
217–228.
[7] D. Jackson, “Alloy: a lightweight object modelling notation,” TOSEM,
vol. 11, no. 2, pp. 256–290, 2002.
[8] T. Nelson, S. Saghaﬁ, D. J. Dougherty, K. Fisler, and S. Krishnamurthi,
“Aluminum: Principled scenario exploration through minimality,” in
Proceedings of ICSE, 2013, pp. 232–241.
[9] “Javafx
-
the
Avail-
http://www.oracle.com/technetwork/java/javase/overview/javafx-
platform.”
[Online].
client
rich
able:
overview-2158620.html
debug
[10] “Android
bridge.”
[Online].
Available:
http://developer.android.com/tools/help/adb.html
[11] “Covert website,” www.sdalab.com/tools/covert.
[12] D. Octeau, P. McDaniel, S. Jha, A. Bartel, E. Bodden, J. Klein, and Y. L.
Traon, “Effective Inter-Component Communication Mapping in Android
with Epicc: An Essential Step Towards Holistic Security Analysis,” in
Proceedings of USENIX Security, 2013, pp. 543–558.
[13] L. Lu, Z. Li, Z. Wu, W. Lee, and G. Jiang, “Chex: statically vetting
android apps for component hijacking vulnerabilities,” in Proceedings
of CCS, 2012, pp. 229–240.
[14] W. Klieber, L. Flynn, A. Bhosale, L. Jia, and L. Bauer, “Android taint
ﬂow analysis for app sets,” in Proceedings of SOAP, 2014, pp. 1–6.
Fig. 3. A Snapshot of COVERT’s Desktop Client Application: (a) vulner-
ability categories (b) detail elements of vulnerabilities (c) a potential exploit
scenario (d) graphical overview of the exploit scenario (d) decompiled source
code of vulnerable component.
Spooﬁng, Inter/Intra-app data leakage, privilege escalation,
etc.. Part (b) represents the elements involved in a particular
instance of each vulnerability in a hierarchical structure. Here,
for example, the expanded vulnerability is an instance of Intent
Hijack, detected in Hesabdar app1. Parts (c) and (d) then
describe details of the detected vulnerability using both text
and graphical notations. As narrated and visualized in Fig-
ure 3(c) and (d), The Hesabdar’s TransactionsActivity
component handles user account information and sends the
information as payload of an implicit Intent to another com-
ponent. When a component sends an implicit Intent, there is
no guarantee that it will be received by the intended recipient.
A malicious application can intercept an implicit Intent simply
by declaring an Intent ﬁlter with all of the actions, data, and
categories listed in the Intent, thus stealing sensitive account
information by retrieving the data from the Intent.
Finally, to enable security analyst to inspect the vulnera-
ble apps more carefully, the decompiled source code of the
vulnerable component(s) is shown in part (e) (this tab is not
visible in the snapshot illustrated in Figure 3).
IV. RELATED WORK
Since the emergence of Android platform, dozens of se-
curity analysis tools have been developed for mobile apps.
Most related tools to COVERT are the ones with the focus on
performing static program analysis over Android applications.
Although several tools [3], [12], [13] have been developed
to identify inter-component vulnerabilities, but they do not
consider inter-app security issues. COVERT’s analysis, how-
ever, goes far beyond single application analysis, and enables
compositional analysis of the overall security posture of a
system, greatly increasing the scope of vulnerability analysis.
DidFail [14], perhaps most closely related, introduces an ap-
proach for tracking data ﬂows between Android components.
It leverages Epicc [12] for Intent analysis, but consequently
shares Epicc’s limitation of not covering data scheme, which
1Hesabdar is an accounting app for personal use and money transaction that,
among other things, manages account transactions and provides a temporal
report of the transaction history.
728728728728
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 07:01:10 UTC from IEEE Xplore.  Restrictions apply. 
ICSE 2015, Florence, Italy Demonstrations