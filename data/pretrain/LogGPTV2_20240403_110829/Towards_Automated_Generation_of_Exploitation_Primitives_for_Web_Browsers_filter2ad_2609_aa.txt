title:Towards Automated Generation of Exploitation Primitives for Web Browsers
author:Behrad Garmany and
Martin Stoffel and
Robert Gawlik and
Philipp Koppe and
Tim Blazytko and
Thorsten Holz
Towards Automated Generation of Exploitation Primitives
for Web Browsers
Behrad Garmany
Ruhr-Universität Bochum
PI:EMAIL
Philipp Koppe
Ruhr-Universität Bochum
PI:EMAIL
Martin Stoffel
Ruhr-Universität Bochum
PI:EMAIL
Robert Gawlik
Ruhr-Universität Bochum
PI:EMAIL
Tim Blazytko
Ruhr-Universität Bochum
PI:EMAIL
Thorsten Holz
Ruhr-Universität Bochum
PI:EMAIL
ABSTRACT
The growing dependence on software and the increasing complexity
of such systems builds and feeds the attack surface for exploitable
vulnerabilities. Security researchers put up a lot of effort to de-
velop exploits and analyze existing exploits with the goal of staying
ahead of the state-of-the-art in attacks and defenses. The urge for
automated systems that operate at scale, speed and efficiency is
therefore undeniable. Given their complexity and large user base,
web browsers pose an attractive target. Due to various mitigation
strategies, the exploitation of a browser vulnerability became a
time consuming, multi-step task: creating a working exploit even
from a crashing input is a resource-intensive task that can take a
substantial amount of time to complete. In many cases, the input,
which triggers a vulnerability follows a crashing path but does not
enter an exploitable state.
In this paper, we introduce novel methods to significantly im-
prove and partially automate the development process for browser
exploits. Our approach is based on the observation that an analyst
typically performs certain manual analysis steps that can be au-
tomated. This serves the purpose to propagate the bug-induced,
controlled data to a specific program location to carry out a de-
sired action. These actions include achieving write-what-where or
control over the instruction pointer primitives. These are useful to
extend control over the target program and are necessities towards
successful code execution, the ultimate goal of the adversary. We im-
plemented a prototype of our approach called PrimGen. For a given
browser vulnerability, it is capable of automatically crafting data
objects that lead the execution to a desired action. We show in our
evaluation that our approach is able to generate new and previously
unknown exploitation opportunities for real-world vulnerabilities
in Mozilla Firefox, Internet Explorer, and Google Chrome. Using
small templates, PrimGen generates inputs that conducts specific
primitives. In total, PrimGen has found 48 JavaScript inputs which
conduct the desired primitives when fed into the target browsers.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
ACSAC ’18, December 3–7, 2018, San Juan, PR, USA
© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-6569-7/18/12...$15.00
https://doi.org/10.1145/3274694.3274723
300
ACM Reference Format:
Behrad Garmany, Martin Stoffel, Robert Gawlik, Philipp Koppe, Tim Blazytko,
and Thorsten Holz. 2018. Towards Automated Generation of Exploitation
Primitives for Web Browsers. In 2018 Annual Computer Security Applications
Conference (ACSAC ’18), December 3–7, 2018, San Juan, PR, USA. ACM, New
York, NY, USA, 13 pages. https://doi.org/10.1145/3274694.3274723
1 INTRODUCTION
Software vulnerabilities pose a severe threat in practice as they
are the root cause behind many attacks we observe on the In-
ternet on a daily basis. A few years ago, attackers shifted away
from server-side vulnerabilities to client-side vulnerabilities. Nowa-
days, especially web browsers are an attractive target given their
complexity (i.e., Mozilla Firefox contains about 18 million lines of
code [25]) and large user base. Browsers incorporate many complex
features including processing of different languages (e.g., various
Markup languages, JavaScript (JS), WebGL, etc.) and interpreting
many file formats (e.g., images, audio, video or Office files). As a
result, browsers provide a large attack surface and security-critical
vulnerabilities are found continuously.
To counter such vulnerabilities, various mitigation strategies
emerged [36] and were incorporated into browsers themselves and
the underlying operating system to make exploitation of a given
vulnerability as difficult as possible. As a result, the exploitation
of a browser vulnerability became a time consuming, multi-step
task: starting from (i) discovering the vulnerability, (ii) minimizing
the crashing input, (iii) verifying exploitability, and (iv) building
upon the crashing input to gain code execution or escalate privi-
leges. Unfortunately, most of these tasks are commonly performed
manually in practice. Hence, exploiting a browser vulnerability is
nowadays a complex task and it is not uncommon that several man
months are invested into creating a working exploit [35]. This is
often necessary to prove that a given bug is indeed security-critical
and has to be eliminated before victims are compromised and suffer
financial or reputation loss, or other kinds of damages.
To explain the underlying challenges, we first need to focus on
the typical steps of a modern browser exploit. Usually, at a cer-
tain point in the exploit-development process, the developer is
confronted with a state where she controls a CPU register with a
value pointing to controlled memory. The contents of this memory
region under her control can be influenced with heap spraying. The
subsequent step is to put a lot of effort into manually debugging
the program flow to find a desired action when the bug is trig-
gered. This might be the propagation of controlled memory content
into the instruction pointer register to divert the control-flow, or
ACSAC ’18, December 3–7, 2018, San Juan, PR, USA
B. Garmany et al.
the propagation into a write instruction to alter fields of internal
browser objects. This way, the exploit gains additional capabilities
such as extended reading/writing of memory or escalated privileges
due to an altered security flag. For example, ExpLib2 is a specifically
prepared exploit plugin in form of a JavaScript (JS) library. It only
requires a single memory write in order to gain complete remote
code execution in Internet Explorer 11 [13, 14, 22]. Nonetheless,
achieving even a single, illegitimate memory write can be difficult
and time-consuming in practice.
There is a line of work on automated exploit generation methods
such as for example AEG [5] or Mayhem [12]. The general goal is to
find exploitable bugs and automatically generate exploits for them.
However, AEG focuses on simpler bug classes such as continuous,
stack-based buffer overflows and format-string vulnerabilities. Due
to improvements in software testing and exploit mitigations in the
browser context, analysts focus on use-after-free, type confusion
and uninitialized-variable bugs. Mayhem [12] also approaches au-
tomated exploit generation. It shares the limited set of bug classes
with AEG, but supports analysis of binary executables and extends
on the methods used such as hybrid symbolic. However, automated
exploit generation remains an open challenge. In many cases, the
given input, which triggers a vulnerability follows a crashing path
but does not enter an exploitable state.
Turning a crashing input of a vulnerability into an useful ex-
ploit primitive is a cumbersome and time-consuming task. Espe-
cially the size and complexity of software systems such as modern
web browsers makes this a challenging problem. In this paper, we
address this specific challenge of automatically creating exploit
primitives (e.g., attacker-controlled reads and writes) and crafting
exploitation primitive triggers for a given crashing input in web
browsers. We present an automated analysis method that takes a
JS/HTML file (i.e., template) that crashes a given browser instance
as input, and modifies the JS objects in a way that the resulting JS
file (i.e., exploitation primitive trigger) performs attacker-desired
actions (i.e., exploit primitive), such as the above mentioned mem-
ory write. We developed a binary analysis framework which in-
corporates several analysis techniques to achieve that degree of
automation. For the target binary of a browser with the to-be-
exploited vulnerability, we first derive both the control-flow and
data-flow, including def-use and points-to information of registers
and memory. Next, we use a Datalog based approach to track the
attacker-controlled data from the crashing input into sinks of inter-
est (e.g., controlled memory writes or reads) in a taint-style manner.
This analysis yields execution paths which start at the control of a
CPU register induced by the crashing input, and end in sinks where
controlled input is involved in useful actions, e.g., an arbitrary mem-
ory write or controlling the instruction pointer. These candidate
paths are symbolically evaluated to filter out unsatisfiable paths.
Although browsers are very complex binaries, our approach does
not suffer from common problems such as path explosion given that
we perform symbolic execution only on selected program paths and
not complete programs. The remaining paths are emulated with
the attacker-controlled memory from the crashing input and this
data is adjusted accordingly to be able to reach the end of the path,
i.e, the according sink. Finally, memory maps are created based on
the adjusted data. These serve as a base to generate scripts with JS
objects, which the vulnerable browser can execute. As a result, the
generated JS files perform the desired exploit primitive defined by
the sink.
To demonstrate the practical feasibility of the proposed method,
we implemented a tool called PrimGen and conducted our eval-
uation on real-world browser vulnerabilities for Mozilla Firefox,
Internet Explorer, and Google Chrome. Our tool identified 486 use-
ful exploit primitives which enhance exploits with arbitrary Write-
Where, Write-What-Where and EIP control primitives. We were able
to generate 48 JS scripts which execute these primitives.
In summary, we make the following contributions:
• We present an approach to automate the steps of developing
crashing browser inputs into the execution of different ex-
ploitation primitives. This minimizes time and effort to build
an exploit in order to successfully demonstrate exploitability
of a security issue.
• Our prototype implementation called PrimGen demonstrates
how several static and dynamic analysis methods can be com-
bined to scale to large and complex binary applications. As
a result, we are able to analyze complex software such as
modern web browsers without the need for source code.
• We evaluate PrimGen on real-world software and real-world
vulnerabilities in web browsers including Mozilla Firefox,
Internet Explorer, and Google Chrome. Our tool is able to
craft data objects leading execution to 486 exploit primitives,
for which 48 usable scripts for these browsers are generated.
2 MODEL AND ASSUMPTIONS
The goal of this paper is to present techniques that enable a high
degree of automation for exploitation of software bugs in web
browsers. It is not our goal to develop an attack to bypass recently
introduced mitigations, nor to approach new bug finding mecha-
nisms. As such, our goal is to automate a critical exploitation step,
namely the process starting from an attacker-influenced location
in the target browser binary induced by a vulnerability, to a point
where an attacker-desired action is conducted.
We assume the presence of a memory corruption vulnerability
that can be triggered by the attacker. The bug is not prepared and
provides no useful primitive. However, we assume that a heap spray
exists to provide changeable, but still unusable memory contents.
Furthermore, we assume that only the crashing input (i.e., the bug
trigger in JS) and the initial point of control is known to the attacker,
e.g., a CPU register is controlled.
We assume that the target process is protected by widely-used
defenses like stack canaries, W ⊕ X, and ASLR as deployed by
major operating systems. This work focuses on the automation
of crafting useful primitives, rather than bypassing more sophis-
ticated defenses. Thus, we consider defenses such as virtual table
verification [38], Control-Flow Integrity (CFI) [1, 11, 43, 44] and
process isolation (sandboxing) [24, 27] out of scope of this paper.
Nevertheless, bypassing most of these features is usually performed
after the attacker has already gained a sufficient amount of control
(which we attempt to automate in this paper).
2.1 Modern Vulnerability Exploitation
To better understand the exploitation process of a memory corrup-
tion vulnerability in web browsers, we divide it into several steps
301Towards Automated Generation of Exploitation Primitives for Web Browsers
ACSAC ’18, December 3–7, 2018, San Juan, PR, USA
before the vulnerability is triggered, and these preparations are
normally performed with heap spray. Heap spraying can be seen as
a black box as one heap spray usually works reliably on a browser
across (minor) version updates. Our analysis is based on a VUT
with an extended, basic heap spray as input. Starting from this state,
we aim at modifying the to-be sprayed JS objects in order to extend
attacker control from control sources to attacker sinks in the target
program flow, as we explain next.
4) Exercising an attacker primitive. At this point in the ex-
ploit development process, the attacker has a VUT which (i) triggers
the vulnerability, (ii) fosters basic control over register/memory,
and (iii) enables further execution towards yet unknown program
sinks. As soon as the vulnerable program executes beyond the initial
control point, it operates on attacker-controlled memory prepared
via, e.g., heap spray. The control flow is already illegitimately influ-
enced, and furthermore, an action of the attacker’s choice should
be exercised next. We name the program point where this spe-
cific action takes place attacker sink. The execution flow, starting
at the control point and eventually landing in the attacker sink, is
called exploitation primitive. Put differently, an exploitation primi-
tive executes from the control point, whereby controlled data from
prepared memory (e.g., heap spray) influences branches and directs
the control flow towards intended attacker sinks. Ultimately, a sink
performs the attacker’s desired action(s). We choose the following
sinks as targets for exploitation primitives, mainly because they are
necessities of subsequent steps such as arbitrary code execution:
• Write-Where (WrW): The attacker manages to propagate
controlled data into a sink with a limited-write instruction
such as an increment, decrement, arithmetic or bit-like op-
eration of controlled memory. Expressed in x86 assembly,
a popular example is inc [controlled]. Usually, this sink
is used to change a data field such as a length field of an
internal browser object. This object can then be misused to
illegitimately read, write, or corrupt memory in the address
space arbitrarily.
• Write-what-where (WWW): This sink contains instruc-
tions which allow arbitrary memory writes, in which the
attacker controls the value (val) and the destination (dst),
e.g., mov [dst], val. Similarly, this sink serves to cor-
rupt memory in order to be able to perform more malicious
computations in the target process. For example, if val is a
pointer into a shared library, this sink may serve the purpose
to create an information leak and bypass ASLR.
• Control over the Instruction Pointer (EIP): EIP sinks
allow control over the instruction pointer: an indirect call
with attacker-controlled values redirects the control flow.
This is often possible in browsers at virtual function call sites
such as for example call [controlled].
The main automation task we accomplish is to generate JS
code which triggers an exploitation primitive, i. e., the execution of
the program path between the control point and the attacker sink.
Attacker-controlled data in the form of JS objects has to be carefully
crafted such that the program executes this program path once the
vulnerability is triggered. As a result, we generate JS/HTML files
based on VUTs to perform the intended exploitation primitive. We
call these result files exploitation primitive trigger (EPT).
Figure 1: Architecture implemented by PrimGen.
that are necessary to gain control of a vulnerable browser. In the
following, we provide an overview and explicitly emphasize the
different steps we attempt to automate.
1) Vulnerability discovery. Before being able to exploit a vul-
nerability in order to prove that it is security-critical, it has to be
discovered in the first place. Nowadays, it is usually achieved with
techniques such as fuzzing [17, 42], symbolic execution [12, 31],
or manual code review. The outcome is usually an input testcase
which ideally triggers the vulnerability and allows further analyses.
We assume this as a prerequisite for our approach.
2) Vulnerability testcase preparation. Depending on the size
and complexity of the vulnerability testcase (i. e., an HTML or JS
file), it might be necessary to (manually) minimize and alter the