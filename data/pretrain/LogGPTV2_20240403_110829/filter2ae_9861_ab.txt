defaultReadFields方法中1989行会递归调用readObject0方法为对象的成员变量赋值直至完成，逻辑与前面描述相似，此处不再赘述。
图3-8
defaultReadObject方法执行完成后，代码流程回到PriorityQueue对象的readObject方法（图3-6）中，读取被transient修饰的Object数组queue（此前被赋值为两个int型的数值1），这部分可以和PriorityQueue类的writeObject方法对照着看（图3-9）。
图3-9
然后代码流程进入图3-6中173行的heapify方法，PriorityQueue本质上是一个最小堆，通过siftDown方法进行次序的调整实现堆化，之前往PriorityQueue对象中插入两个1，可以使队列的SIZE满足for循环的条件从而进入siftDown方法中。
继续跟进siftDown方法，次序的调整必然涉及比较，在这儿此前精心构造的比较器就派上用场了，跟进siftDownUsingComparator方法，在图3-11中699行调用了比较器的compare方法。
图3-11
跟进compare方法，在比较前会先通过transformer的transform方法转换一下对象。而此处的transformer正是我们此前构造的ChainedTransformer对象chain序列化成字节流后又反序列化所得（在递归调用readObject0方法时实现），如图3-12所示。
图3-12
继续跟进到ChainedTransformer的transform方法中，此时iTransformers中有ConstantTransformer对象和InstantiateTransformer对象，此处代码逻辑是将ConstantTransformer对象中transform方法的返回值作为参数传入InstantiateTransformer对象的transform方法中。
图3-13
ConstantTransformer对象中transform方法的返回iConstant变量，即com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter.class:
图3-14
InstantiateTransformer对象中transform方法反射获取构造方法后生成了TrAXFilter类的实例，通过newInstance方法进入了TrAXFilter类含参构造方法TrAXFilter(Templates
templates)中，并将TemplatesImpl实例作为参数传入，如图3-15所示。
图3-15
TrAXFilter(Templates
templates)方法代码如图3-16所示，在64行调用了TemplatesImpl对象的newTransformer方法，newTransformer方法中又调用getTransletInstance方法（图3-17中410行），恶意代码的触发便是在该方法中。
图3-16
图3-17
如图3-18所示，getTransletInstance方法中第376行调用了defineTransletClasses方法后，380行会将_class数组中的某个类实例化：
图3-18
跟进defineTransletClasses方法发现有如图3-19所示这样一段代码：
图3-19
其在for循环里遍历_bytecodes数组并通过TransletClassLoader加载字节码，其中会判断_class[i]的父类是否为`ABSTRACT_TRANSLET（”com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet”）`，这解释了为什么_bytecodes中的StubTransletPayload类要继承自AbstractTranslet类，_transletIndex变量初始化时为-1，若此处判断条件为false，`_transletIndex`的值仍为-1，则程序执行流程会进入后面`if
(_transletIndex ()`的过程，`()`是在Javac编译过程中生成字节码时被添加到语法树中。
`()`方法是编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生。——《深入理解Java虚拟机》
书中还提到虚拟机规范严格规定了有且只有四种情况必须立即对类进行初始化：
  * 遇到new、getstatic、putstatic、invokestatic这四条字节码指令时，如果类还没有进行过初始化，则需要先触发其初始化。生成这四条指令最常见的Java代码场景是：使用new关键字实例化对象时、读取或设置一个类的静态字段（static）时（被static修饰又被final修饰的，已在编译期把结果放入常量池的静态字段除外）、以及调用一个类的静态方法时。
  * 使用Java.lang.refect包的方法对类进行反射调用时，如果类还没有进行过初始化，则需要先触发其初始化。
  * 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。
  * 当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先执行该主类。
前面在通过TransletClassLoader中的defineClass方法加载类时仅将字节码装载到了JVM中，没有执行类的初始化，而fastjson的Poc中通过Class.forName()加载类时，Class.forName()方法除了将对应的类装载到JVM中，还会执行类构造器`()`对类进行初始化，从而执行static代码块。Class.forName()代码实现（JDK1.7）见图4-1：
图4-1
forName0()方法用native关键字修饰，说明这个方法是原生函数，非Java语言实现。可从forName()方法的注释中看到第二个参数决定类是否会被初始化，在forName(String
className)中默认为true。以上基本解释了我在关于注入的静态代码触发位置的疑惑。
### 总结
整个Gadget的调用栈见图5-1：
图5-1
反序列化时首先从ObjectInputStream类的readObject方法中进入到PriorityQueue类的readObject方法里，其readObject方法中会进行堆化，堆化时队列中元素大于等于2时会进行堆排序，这时会调用自定义的比较器（`TransformingComparator`），`TransformingComparator`在比较次序时会将对象进行转换。转换时使用的transformer是基于ConstantTransformer对象和`InstantiateTransformer`对象构造的ChainedTransformer对象，ChainedTransformer对象在其转换方法（`transform()`）中会依次调用`ConstantTransformer`对象和`InstantiateTransformer`对象的transform方法，并将前一个对象transform方法的返回值作为参数传入后一个对象的transform方法中，`InstantiateTransformer`对象中的transform方法会基于参数（这里即`ConstantTransformer.transform()`的返回值`com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter`）新建实例，则进入了TrAXFilter类的构造方法中，这里调用了TransformerImpl实例的newTransformer方法，又调用了getTransletInstance方法，加载`_bytecodes`中修改后的StubTransletPayload类字节码并生成实例，从而触发代码执行。
### 参考
* * *