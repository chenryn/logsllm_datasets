我们首先比较小时数，只有当它们的小时数相同的时候，我们才比较分钟，以
的下标值。这个过程类似于我们比较以小时/分钟/秒的方式所表示的时间。比较两个时间时，
虽然算法11.54 能够找到带有 0(1)次同步的所有并行性度数，它仍然存在--些缺点。第一，
现在我们给出一个简单的并行化算法。它首先把计算任务分解到尽可能多的不同循环中，
断言[i,,"i]<[,,"ja]可以写成如下的线性不等
2) [,i2,…ia]=[j,jja]；且在正文上s出现在 s2 
令s为一个嵌套在深度为 d, 的循环中的语句，而 s 嵌套
544
3）对每个 SCC 应用算法11.43，寻找出所有的无同步并行性。在每个被并行化的 SCC 的前
2）转换代码，使之按照拓扑顺序执行各个 SCC。必要时可以应用裂变转换。
一个强连通分量是原图的一个满足下列条件的最大的分量：其中的每个结点都可以到达所有
只要数据依赖关系的条件和上面的析取式中的某个子句同
i当且仅当下列条件之--成立;
1）构造程序的程序依赖图，并把语句分划为强连通分量（SCC）。回忆一下10.5.8节介绍
方法：
输出：带有固定多个同步栅障的 SPMD 代码。
输入：一个带有数组访问的程序。
(i =jA.·Aia-1=ja-1Aia<ja)
(i<ji)V(i =jAi<j)V...V
1) [i,i,.ia]<[j,·ja]，或者
在允许 0(1)次同步的情况下最大化并行性的度数。
序
图11-45 例11.53 中的程序
图11-44 例11.53 中的程序
0
”
的层次结构
的执行顺序
i=1
Prog
L3
j=】·
第11章
---
## Page 561
11.9 
11.8.511.8节的练习
手段，从而降低通信量。
如在一-个单处理器上顺序执行这个程序。在后面的各节中，我们将继续给出提高数据局部性的
的处理器之间传递很多数据。有些情况下，通信开销会使得并行化的代价太过昂贵，有时甚至不
例11.55
理器空间中的邻近处理器上。
器共享数据，但是一般只能以“局部的”方式来共享数据，数据只能从一个处理器传递到所在处
分划，使得任意两个共享数据的选代都被分配给同一个处理器上。流水线化技术允许不同处理
11.9.1什么是流水线化
易
流水线化技术。然后我们在11.9.6节中正式定义需要求解的约束，并在11.9.7节中描述一个求
品
个处理器完成了它负责的阶段后，结果就作为输入传送到流水线中的下一个处理器。
个具有n个迭代的循环可以被构造一个n阶段的流水线。每个阶段被分配给不同的处理器，当-
地被流水线化。
层的完全可交换循环(fully permutable loop）。正如 1l.9.8节中将讨论的，这样的循环可以很容
这些问题的算法。如果一个程序的时间分划约束具有多个独立解，那么就可以认为它具有：
中的被称为“连续过松弛方法”的数值算法。我们用这个例子说明在什么样的情况下可以应
并行性和局部性优化
前面我们尝试对一个循环嵌套结构进行并行化时，我们对这个循环嵌套结构中的选代进行
下面我们首先更加详细地解释流水线化的概念。然后我们在11.9.2节中给出了一个实际
for (i=0;i<100;i++)
在流水线化技术中，一个任务被分成数个阶段，各个阶段在不同的处理器上进行。比如，
练习11.8.3：把算法11.54应用到图11-48的代码上。
练习11.8.2：把算法11.54应用到图11-47的代码上。
练习11.8.1：把算法11.54应用到图11-46的代码上。
B[i] = B[i] + A[i]; 
A[i]=A[i] +x[i];/*(s1) */
流水线化技术
for
i=0;i<100;i++)
图11-47练习11.8.2的代码
考虑循环：
for (i=0; i<100; i++)
for (i=0; i<100; i++)
/（≤2）*/
A[i]
，下面给出一个简单的例子。
（j=0;
图11-46练习11.8.1的代码
for
for (i=0; i<100; i++)
for (j=0; j<100; j++)
A[i]
for
(i=0;
图11-48练习11.8.3的代码
D[i,j]’= A[i]+ B[j]; /*(s4） */
（j=0;
B[j]：
i<100；i++)
A[i]
= A[i]
j<100;
+X[i];/*(s1）*/
j++)
/*(s3)*/
/*（s2）*/
545
最
用
生
---
## Page 562
某种收敛标准为止。
在这里，数组中的一个元素的新值依赖于它的相邻元素的值。这个运算会被重复执行，直到满足
时加快收敛速度的技术。图11-50a 中显示的相对简单的模板解释了这个技术的数据访问模式。
11.9.2连续过松弛方法：一个例子
始排空，越来越多的处理器进人空闲状态，直到最后一个处理器完成最后一个任务。在稳定状态
逐渐填满，直到所有的处理器都进人忙状态。当第一个处理器完成了最后一个任务后，流水线开
到第二个处理器，同时第--个处理器开始处理第二个任务，如此继续。按照这种方式，流水线被
流水线在开始时是空的，只有第一个处理器在执行第一个阶段。在它完成处理之后，结果被传送
部性。
过按列分划(而不是按行分划)就可以提高局
而不是一行。如果Y是按列存放的，那么通
在这种情况下，每个处理器访问Y的一列，
相加，并把结果传递到下一个阶段。请注意
生成的X的--个元素，将它和Y的一个元
线
讲，内层循环的每个迭代都可以被当作流水
来获取并行性，如图 11-49 所示。更明确地
的第i行并修改X的第i个元素。
的。我们可以让每个处理器执行一个独立的求和过程，从而实现代码的并行化。处理器讠访问Y
于求和过程。因为数据依赖的原因，这个循环必须顺序执行，但是不同的求和过程之间是独立
请记住，我们没有利用加法的交换率和结合率。
，n个任务在由 n 个处理器组成的流水线中并行执行。
的一个阶段：第j个阶段获取在前一阶目
图11-50b 中显示的是关键数据依赖关系。我们没有显示能够从该图中已包含的依赖关系推
连续过松弛法（Successive Over Relaxation,SOR）是一个在使用松弛方法求解联立线性方程式
我们还可以把多个处理器组织成一个流水线来执行这个求和过程，并通过求和过程的重叠
546
把流水线技术和不同处理器处理不同任务的简单并行性进行比较是很有意思的：
这个代码把Y的第i行中的值相加，并把结果加到X的第i个元素上。其中的内层循环对应
?流水线化技术只能应用于深度至少为2的循环嵌套结构。我们可以把外层循环的每个迭
可以降低通信量，那么就应该选择这个技术。
器可以一起开始执行，而不会产生填满和排空流水线的开销。但是，如例11.55 所示，在
如果任务是独立的，那么简单的并行化方案具有较好的处理器利用率，原因是各个处理
个输人数据元素必须存放在同一个处理器内，如例11.55 所示。
务的第讠个阶段使用，不会产生通信开销。类似地，由不同任务的同一个阶段所使用的每
被存放在同一个处理器上。因此，由一个任务的第i个阶段生成的结果可以直接被后继
在一个流水线中运行的任务可以具有数据依赖关系。属于各个任务的同一个阶段的信
代当作一个任务，而把内层循环的各个迭代当作任务的各个阶段。
素
段
地
图 11-49例11.55 中的流水线化的执行过程,
时间
X[1]+=Y
3
其中 m=4，n=3 
[3,1]
处理
X
+=Y
3
X[3]+=Y[3,
第11章
3
任
息
---
## Page 563
外层的完全可交换循环，我们仅仅需要引人0(n)个同步运算，就可以得到 0(k－1)度的并行性
的余地意味着存在并行化的机会。在本节的稍后我们将说明如果一个循环嵌套结构具有k个最
调度这些运算时具有这样的自由度，说明在对程序的运算进行排序时有很大的回旋余地。调度
的相对顺序。
关系。从这个图中可以很容易看出这个重新排序保持了每一对具有数据依赖关系的访问之[
11-51c 所示。我们在图 11-51b 和图 11-51d 中分别显示了这两个程序的迭代空间和数据依
可得到图11-51a中所示代码。经过转换得到的代码是完全可交换的，交换后的版本如
射转换
计算将会在迭代[1,4］的计算之前执行，这就违反了图11-50b 中的依赖关系。
味着原来的迭代空间中的选代按照逐列(而不是逐行)的方式执行。比如，原来在迭代[2,3］中的
对代码应用某些转换(比如分块技术)来提高数据局部性。
(n是一个循环中的选代的个数）。
序的语义。一旦多个循环具有完全可交换的性质，我们可以很容易地把相应的代码流水线化，
些优化技术都是有用的。多个循环是完全可交换的条件是它们可以任意地排列而不会改变原程
11.9.3完全可交换循环
为波阵面（wave front），而这样的并行化方案被称为波阵面推进（wavefronting）。
条斜线地执行线上的迭代，从而达到并行化这个代码的目的。我们把--个斜线上的全部迭代称
它们只依赖于比较靠近原点的斜线上的迭代。因此，我们可以从原点上的斜线开始逐步向外，逐
我们应该可以找到度数为1的并行性，并在0(m+n)个时间单位内执行0(mn）运算。
楚地看出不存在无同步并行性。因为最长的依赖关系链包含了O(m+n)个边，通过引人同步，
即不断下移一步再右移两步所得到的点的序列。
然而，我们可以通过代码转换使得上面的 SOR 代码变成完全可交换的。对这个代码应用仿
我们首先介绍一下完全可交换(full permutability)的概念。这个概念对于流水线化和其他-
并行性和局部性优化
当我们交换循环时，我们极大地改变了最外层循环的各个迭代所执行的运算集合。我们在
图11-50a中给出的 S0R代码不是完全可交换的。如11.7.8节所示，交换两个循环的位置
特别地，我们看到图 11-50b 中角度为150°的斜线上的各个选代之间没有数据依赖关系。
for (i = 0; i <= m; i++)
a)原来的源代码
图11-50连续过松弛法(SOR)的例子
L1
1.
b)代码中的数据依赖关系
/盒
547
赖
图
并
---
## Page 564
执行一个迭代，并且同步运算在瞬日
器p才可以执行迭代i。
理器p-1执行了迭代i-1之后，处理
的代码。不考虑边界条件，只有在处
水线阶段。我们把第个阶段分配给处
组
一种情况下，相应迭代空间的每一列
11-51c 所示的两种可能的排列。