### 机制四：自定义流量控制 {#15.html#-}TCP 的流量控制是通过**滑动窗口协议**。QUIC 的流量控制也是通过window_update，来告诉对端它可以接受的字节数。但是 QUIC的窗口是适应自己的多路复用机制的，不但在一个连接上控制窗口，还在一个连接中的每个stream 控制窗口。还记得吗？在 TCP 协议中，接收端的窗口的起始点是下一个要接收并且 ACK的包，即便后来的包都到了，放在缓存里面，窗口也不能右移，因为 TCP 的 ACK机制是基于序列号的累计应答，一旦 ACK了一个系列号，就说明前面的都到了，所以只要前面的没到，后面的到了也不能ACK，就会导致后面的到了，也有可能超时重传，浪费带宽。QUIC 的 ACK 是基于 offset 的，每个 offset的包来了，进了缓存，就可以应答，应答后就不会重发，中间的空挡会等待到来或者重发即可，而窗口的起始位置为当前收到的最大offset，从这个 offset 到当前的 stream所能容纳的最大缓存，是真正的窗口大小。显然，这样更加准确。![](Images/81fcc82a30464b68feed4335ca325025.png){savepage-src="https://static001.geekbang.org/resource/image/a6/22/a66563b46906e7708cc69a02d43afb22.jpg"}另外，还有整个连接的窗口，需要对于所有的 stream 的窗口做一个统计。
## 小结 {#15.html#-}好了，今天就讲到这里，我们来总结一下：-   [HTTP 协议虽然很常用，也很复杂，重点记住 GET、POST、 PUT、DELETE    这几个方法，以及重要的首部字段；]{.orange}-   [HTTP 2.0    通过头压缩、分帧、二进制编码、多路复用等技术提升性能；]{.orange}-   [QUIC 协议通过基于 UDP 自定义的类似 TCP    的连接、重试、多路复用、流量控制技术，进一步提升性能。]{.orange}接下来，给你留两个思考题吧。1.  QUIC    是一个精巧的协议，所以它肯定不止今天我提到的四种机制，你知道它还有哪些吗？2.  这一节主要讲了如何基于 HTTP    浏览网页，如果要传输比较敏感的银行卡信息，该怎么办呢？欢迎你留言和我讨论。趣谈网络协议，我们下期见！![](Images/55417b60e9c8040807daf07e6bd9cb4b.png){savepage-src="https://static001.geekbang.org/resource/image/b5/fb/b5bc14cb81d3630919fee94a512cc3fb.jpg"}
# 第15讲 \| HTTPS协议：点外卖的过程原来这么复杂用 HTTP协议，看个新闻还没有问题，但是换到更加严肃的场景中，就存在很多的安全风险。例如，你要下单做一次支付，如果还是使用普通的HTTP 协议，那你很可能会被黑客盯上。你发送一个请求，说我要点个外卖，但是这个网络包被截获了，于是在服务器回复你之前，黑客先假装自己就是外卖网站，然后给你回复一个假的消息说："好啊好啊，来来来，银行卡号、密码拿来。"如果这时候你真把银行卡密码发给它，那你就真的上套了。那怎么解决这个问题呢？当然一般的思路就是**加密**。加密分为两种方式一种是**对称加密**，一种是**非对称加密**。在对称加密算法中，加密和解密使用的密钥是相同的。也就是说，加密和解密使用的是同一个密钥。因此，对称加密算法要保证安全性的话，密钥要做好保密。只能让使用的人知道，不能对外公开。在非对称加密算法中，加密使用的密钥和解密使用的密钥是不相同的。一把是作为公开的公钥，另一把是作为谁都不能给的私钥。公钥加密的信息，只有私钥才能解密。私钥加密的信息，只有公钥才能解密。因为对称加密算法相比非对称加密算法来说，效率要高得多，性能也好，所以交互的场景下多用对称加密。
## 对称加密假设你和外卖网站约定了一个密钥，你发送请求的时候用这个密钥进行加密，外卖网站用同样的密钥进行解密。这样就算中间的黑客截获了你的请求，但是它没有密钥，还是破解不了。``{=html}这看起来很完美，但是中间有个问题，你们两个怎么来约定这个密钥呢？如果这个密钥在互联网上传输，也是很有可能让黑客截获的。黑客一旦截获这个秘钥，它可以佯作不知，静静地等着你们两个交互。这时候你们之间互通的任何消息，它都能截获并且查看，就等你把银行卡账号和密码发出来。我们在谍战剧里面经常看到这样的场景，就是特工破译的密码会有个密码本，截获无线电台，通过密码本就能将原文破解出来。怎么把密码本给对方呢？只能通过**线下传输**。比如，你和外卖网站偷偷约定时间地点，它给你一个纸条，上面写着你们两个的密钥，然后说以后就用这个密钥在互联网上定外卖了。当然你们接头的时候，也会先约定一个口号，什么"天王盖地虎"之类的，口号对上了，才能把纸条给它。但是，"天王盖地虎"同样也是对称加密密钥，同样存在如何把"天王盖地虎"约定成口号的问题。而且在谍战剧中一对一接头可能还可以，在互联网应用中，客户太多，这样是不行的。
## 非对称加密所以，只要是对称加密，就会永远在这个死循环里出不来，这个时候，就需要非对称加密介入进来。非对称加密的私钥放在外卖网站这里，不会在互联网上传输，这样就能保证这个秘钥的私密性。但是，对应私钥的公钥，是可以在互联网上随意传播的，只要外卖网站把这个公钥给你，你们就可以愉快地互通了。比如说你用公钥加密，说"我要定外卖"，黑客在中间就算截获了这个报文，因为它没有私钥也是解不开的，所以这个报文可以顺利到达外卖网站，外卖网站用私钥把这个报文解出来，然后回复，"那给我银行卡和支付密码吧"。先别太乐观，这里还是有问题的。回复的这句话，是外卖网站拿私钥加密的，互联网上人人都可以把它打开，当然包括黑客。那外卖网站可以拿公钥加密吗？当然不能，因为它自己的私钥只有它自己知道，谁也解不开。另外，这个过程还有一个问题，黑客也可以模拟发送"我要定外卖"这个过程的，因为它也有外卖网站的公钥。为了解决这个问题，看来一对公钥私钥是不够的，客户端也需要有自己的公钥和私钥，并且客户端要把自己的公钥，给外卖网站。这样，客户端给外卖网站发送的时候，用外卖网站的公钥加密。而外卖网站给客户端发送消息的时候，使用客户端的公钥。这样就算有黑客企图模拟客户端获取一些信息，或者半路截获回复信息，但是由于它没有私钥，这些信息它还是打不开。
## 数字证书不对称加密也会有同样的问题，如何将不对称加密的公钥给对方呢？一种是放在一个公网的地址上，让对方下载；另一种就是在建立连接的时候，传给对方。这两种方法有相同的问题，那就是，作为一个普通网民，你怎么鉴别别人给你的公钥是对的。会不会有人冒充外卖网站，发给你一个它的公钥。接下来，你和它所有的互通，看起来都是没有任何问题的。毕竟每个人都可以创建自己的公钥和私钥。例如，我自己搭建了一个网站 cliu8site，可以通过这个命令先创建私钥。    openssl genrsa -out cliu8siteprivate.key 1024然后，再根据这个私钥，创建对应的公钥。    openssl rsa -in cliu8siteprivate.key -pubout -outcliu8sitepublic.pem这个时候就需要权威部门的介入了，就像每个人都可以打印自己的简历，说自己是谁，但是有公安局盖章的，就只有户口本，这个才能证明你是你。这个由权威部门颁发的称为**证书**（**Certificate**）。证书里面有什么呢？当然应该有**公钥**，这是最重要的；还有证书的**所有者**，就像户口本上有你的姓名和身份证号，说明这个户口本是你的；另外还有证书的**发布机构**和证书的**有效期**，这个有点像身份证上的机构是哪个区公安局，有效期到多少年。这个证书是怎么生成的呢？会不会有人假冒权威机构颁发证书呢？就像有假身份证、假户口本一样。生成证书需要发起一个证书请求，然后将这个请求发给一个权威机构去认证，这个权威机构我们称为**CA**（**Certificate Authority**）。证书请求可以通过这个命令生成。    openssl req -key cliu8siteprivate.key -new -out cliu8sitecertificate.req将这个请求发给权威机构，权威机构会给这个证书卡一个章，我们称为 \*\*签名算法。\*\*问题又来了，那怎么签名才能保证是真的权威机构签名的呢？当然只有用只掌握在权威机构手里的东西签名了才行，这就是CA 的私钥。签名算法大概是这样工作的：一般是对信息做一个 Hash 计算，得到一个 Hash值，这个过程是不可逆的，也就是说无法通过 Hash值得出原来的信息内容。在把信息发送出去时，把这个 Hash值加密后，作为一个签名和信息一起发出去。权威机构给证书签名的命令是这样的。    openssl x509 -req -in cliu8sitecertificate.req -CA cacertificate.pem -CAkey caprivate.key -out cliu8sitecertificate.pem这个命令会返回 Signature ok，而 cliu8sitecertificate.pem就是签过名的证书。CA用自己的私钥给外卖网站的公钥签名，就相当于给外卖网站背书，形成了外卖网站的证书。我们来查看这个证书的内容。    openssl x509 -in cliu8sitecertificate.pem -noout -text 这里面有个Issuer，也即证书是谁颁发的；Subject，就是证书颁发给谁；Validity是证书期限；Public-key 是公钥内容；Signature Algorithm 是签名算法。这下好了，你不会从外卖网站上得到一个公钥，而是会得到一个证书，这个证书有个发布机构CA，你只要得到这个发布机构 CA的公钥，去解密外卖网站证书的签名，如果解密成功了，Hash也对的上，就说明这个外卖网站的公钥没有啥问题。你有没有发现，又有新问题了。要想验证证书，需要 CA的公钥，问题是，你怎么确定 CA 的公钥就是对的呢？所以，CA 的公钥也需要更牛的 CA 给它签名，然后形成 CA的证书。要想知道某个 CA 的证书是否可靠，要看 CA的上级证书的公钥，能不能解开这个 CA的签名。就像你不相信区公安局，可以打电话问市公安局，让市公安局确认区公安局的合法性。这样层层上去，直到全球皆知的几个著名大CA，称为**rootCA**，做最后的背书。通过这种**层层授信背书**的方式，从而保证了非对称加密模式的正常运转。除此之外，还有一种证书，称为**Self-SignedCertificate**，就是自己给自己签名。这个给人一种"我就是我，你爱信不信"的感觉。这里我就不多说了。