own techniques to defeat Surgical repair. One of our
test rootkits uses a kernel thread to monitor the im-
proper values it writes to the kernel’s system call vector.
Whenever the VICI Agent’s Surgical repair restores the
proper values, the kernel thread writes the improper val-
ues back again, negating the repair.
Upon witnessing the failure of its Surgical repair,
the VICI Agent moves to the Core War repair action in-
spired by the classic game of Core War [9]. The Core
War repair ﬁnds the rootkit’s text by following the im-
proper pointer from the system call vector, and then
“neuters” the rootkit by re-writing its code to jump im-
mediately to the kernel’s proper function without per-
forming any of the rootkit’s malicious functionality. Al-
though control still ﬂows through the rootkit, its ma-
licious functionality is removed and the VICI Agent’s
purpose is served. Although our code-rewriting seeks
to avoid results that would accidentally crash the ker-
nel, we reserve Core War for cases in which the simpler
and safer Surgical repair action fails.
8090
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:01:14 UTC from IEEE Xplore.  Restrictions apply. 
Isolated Domain 0administrativemachineVirtual Machinefor missionapplicationsXenHypervisorInteractionswith outsideworldLearn from (2)  diagnostic       resultsVICI AgentKernel(1) Run diagnostics on kernel.(3) Repair kernelThe Hitman repair action is designed to handle even
more sophisticated rootkits that are capable of defeating
Core War. Another of our test rootkits uses a kernel
thread to keep not only its modiﬁcations to the kernel’s
system call vector in place, but also to re-write its own
instructions if it ﬁnds them neutered.
The VICI Agent turns to Hitman when it witnesses
the failure of Core War. Hitman guesses which threads
may be aiding the rootkit and kills them. Its method of
determining which threads to kill is approximate and
often includes a few innocent threads along with the
guilty. Like Core War, the Hitman repair action uses
the improper function pointer values in the kernel’s sys-
tem call vector to locate the rootkit’s malicious func-
tions in kernel memory. Hitman calculates the start and
end address of the kernel page or pages that hold those
functions. It then examines the top 64 words from each
thread’s kernel stack. If it ﬁnds a word-sized value that
falls within the address ranges of those pages, it kills
that thread.
This approach often kills kernel threads that are
aiding rootkits because they store saved instruction
pointers within the target address range near the tops
of their kernel stacks when they give up the CPU. How-
ever, this approach also kills any other threads that hap-
pen to have a matching word-sized pattern of bits on
their stack, whether it is a saved instruction pointer or
not. Although this imprecision is costly, it is still worth
attempting the Hitman repair since it may save us from
having to move on to the next two repairs which are
even more extreme and will surely cause greater loss of
useful state.
Instead,
The Checkpoint repair action is different from Core
War and Hitman in that it does not attempt to counter
a speciﬁc rootkit strategy.
if prior repairs
fail for whatever reason, the Checkpoint repair action
simply restores the virtual machine to a previously-
checkpointed state. In a deployment, we imagine ad-
ministrators might checkpoint the virtual machine peri-
odically. This repair action hopes to restore the kernel
to health by returning it to a previously checkpointed
state that predates the time of infection.
The Reboot repair action is the VICI Agent’s option
of last resort. As a deployed system is apt to have stor-
age capacity for only a ﬁnite number of checkpoints, it
is possible that repeated Checkpoint restores may even-
tually exhaust this supply. In this situation, further fail-
ures of cheaper repairs will cause the VICI Agent to
reboot the virtual machine, returning it to a very early
state that is hopefully free of infection. In our proto-
type, reboot is implemented by restoring a checkpoint
of the virtual machine meant to be taken just after op-
erating system install-time. It loses all useful applica-
tion state.
If for some reason Reboot cannot restore
the kernel to health, the VICI Agent resorts to contin-
uously rebooting the machine. Neither the rootkit nor
the system’s mission applications make progress, but
the VICI Agent has succeeded in making the presence
of the rootkit known.
The Core War and Hitman repair actions are
presently implemented only for attacks on the system
call vector. Difﬁcult attacks on other aspects of the ker-
nel’s state cause the VICI Agent to skip directly to its
Checkpoint repair action.
In a real deployment, administrators might prefer
to avoid the more expensive repair actions like Check-
point and Reboot, preferring to shutdown or call for
manual intervention instead. On the other hand, these
repairs might be appropriate for nodes in systems like
Chord [28] or MapReduce [8] that have automatic pro-
tocols in place to tolerate or recover from node failures.
5. Control and learning
The VICI Agent is designed to apply its cheapest
repairs ﬁrst, escalating to the more expensive repair ac-
tions only when the cheaper ones have failed. The di-
agram in Figure 3A represents this escalation behavior.
The diagram represents a series of VICI Agent scans as
a series of rectangles. Shaded rectangles represent scans
where the VICI Agent’s diagnostics indicate problems.
The height of the rectangles increase with the costliness
of the VICI Agent’s repair action choices.
In scan 2, we can imagine the VICI Agent detected
tampering in the kernel’s system call vector, and applied
its Surgical repair action. But in scan 3, the problem
remains and the VICI Agent escalates to its Core War
repair action. The problem still persists in scan 4, so
the VICI Agent escalates further to Hitman. Hitman
ﬁnally repairs the kernel, and scan 5 reveals a healthy
kernel. By reserving the expensive Hitman repair ac-
tion until last, and by not moving on to the even more
expensive Checkpoint and Reboot repair actions once
Hitman proved effective, the VICI Agent meets its goal
of avoiding repair cost when possible.
We say that the VICI Agent has an “anger level”.
Once it escalates to Hitman in scan 4 of the previous
example, the VICI Agent remains at that “anger level”
for a constant number of scans (10 in this example).
If the infection recurs during that interval, rather than
performing the same escalation through Surgical and
Core War to Hitman as before, the VICI Agent instead
applies Hitman immediately, as in scan 9.
In situa-
tions where the kernel is being repeatedly infected by
8191
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:01:14 UTC from IEEE Xplore.  Restrictions apply. 
Figure 3. The VICI Agent escalates its “anger level” in response to a difﬁcult rootkit infection.
Shaded bars represent scans in which the Agent detects tampering. In (A) the Agent remains esca-
lated in response to repeated re-infections. In (B) the infections cease and it eventually de-escalates.
a rootkit of sufﬁcient sophistication to require Hitman
repair, staying at an elevated anger level optimizes the
VICI Agent’s response for time by skipping the presum-
ably ineffective cheaper repairs.
When 10 scans have elapsed since the initial escala-
tion, the VICI Agent will de-escalate—that is, decrease
its anger level by one. If the infection recurs at this point
as in scans 14 and 15, the VICI Agent escalates back to
the higher level. If the infection does not recur, the VICI
Agent de-escalates back to its lowest anger level in a se-
ries of 10 scan steps, as shown in Figure 3B. The combi-
nation of escalation and de-escalation enables the VICI
Agent to provide a limited form of Cognitive Immu-
nity [23]—the ability to adjust its defenses in response
to changing attacks.
6. Control implementation
Automatic detection–repair systems like the VICI
Agent are examples of continuous or reactive planning
agents that spend their entire runtimes looping again
and again through phases of sensing, planning, and ex-
ecution. Continuous planning agents such as IPEM [1]
have used partial-order planning to map sensor reports
to appropriate actions. Reactive planning agents like
PRS [12] have used Hierarchical Task Networks. How-
ever, both of these strategies require the designer to cre-
ate internal abstract representations of the problem do-
main on which the planners will operate—a potentially
difﬁcult and error-prone task. This requirement is not
suitable for dealing with kernel-modifying rootkits, as
one mistake or bad assumption about rootkit behavior
or kernel state in this abstract representation will give
rootkits an avenue by which they can defeat the agent.
Furthermore, future advances in malicious rootkit be-
havior are difﬁcult to predict.
The “Subsumption Architecture” is an alternative
approach originally intended for the development of au-
tonomous mobile robots that exhibit insect-like behav-
ior [4, 5, 6]. Unlike the other approaches, it requires
no potentially troublesome abstract representation. In-
stead, following the maxim that “the world is its own
best representation,” the subsumption approach has the
agent’s loop continuously poll sensors to determine the
state of the world and react to their reports directly,
rather than indirectly through a model of the world that
may or may not be complete enough for the task. Sub-
sumption also permits the agent to maintain state across
loop iterations, enabling it to remember and learn from
past experiences. Subsumption-based agents have been
concisely described as “a particular kind of reﬂex agent
with state” [25].
In addition to the above advantages, the subsump-
tion architecture also permits decision-making rapid
enough to meet our goal of achieving repair within mil-
liseconds of diagnosis, and is amenable to incremental
development and easy extension as new kinds of kernel-
modifying rootkit threats come to light.
The subsumption architecture advocates imple-
menting and testing control schemes for mobile robots
incrementally in a sequence of layers: ﬁrst a layer to
avoid collisions, then a second to build upon and some-
times override the ﬁrst to make the robot wander while
avoiding collisions, and ﬁnally a third layer to shape the
lower two’s behavior into purposeful movement toward
some distant destination.
The VICI Agent adapts this architecture by imple-
menting each of its repair actions as a layer, with higher
layers observing the effectiveness of the lower ones and
applying their more expensive repairs only when the
lower layers’ cheaper ones have failed.
8292
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:01:14 UTC from IEEE Xplore.  Restrictions apply. 
1234567891110121314151617181920212223242526(A)(B)7. Related Work
The VICI Agent borrows techniques from a num-
ber of systems that use virtual machine introspection to
monitor the state of virtualized systems [11, 2, 17, 16,
22]. To their detection functionality the VICI Agents
adds fully-automated kernel repair techniques and the
automated reasoning capability needed to apply these
repairs in a way that avoids losing useful system state
and availability when possible.
The phrase “virtual machine introspection” was
coined by Garﬁnkel and Rosenblum to describe the op-
eration of their Livewire prototype which used a hyper-
visor to implement a host-based intrusion detection sys-
tem for virtual machines [11]. The hypervisor allowed
them to locate their monitor outside of the virtual ma-
chine, thereby protecting it from tampering. Livewire
detected intrusions both in the kernel and in user-mode
applications. Although it could always provide some
value, it could not operate at full effectiveness if an
adversary managed to modify the monitored system’s
kernel state to make Livewire’s operation difﬁcult. The
VICI Agent adds repair and automated reasoning fea-
tures to Livewire-like diagnostic functionality.
Building on the ideas of Livewire, several other ef-
forts have used hypervisors to monitor systems running
in virtual machines for misbehavior. Asrigo and others
have used a variety of virtualization approaches, includ-
ing the Xen hypervisor used by the VICI Agent, to in-
strument the kernels of virtualized honeypot machines
so that they produce better records of user-mode pro-
cess activity [2]. The Asrigo approach focuses on user-
mode activity rather than on the integrity of kernels, as
the VICI Agent does.
The Lycosid system [17], however, uses a
hypervisor-based monitor to detect processes hidden by
kernel-modifying rootkits—a goal closely related to the
VICI Agent’s. Lycosid uses “cross-view” validation to
detect hidden processes [29]. It gathers process-related
data from different sources within the system and com-
pares them. If a rootkit has tampered with some sources
but not others, this comparison will reveal inconsis-
tencies that indicate the presence of a hidden process.
The present VICI Agent prototype’s diagnostics focus
mainly on detecting control-ﬂow and text changes that
alter the kernel’s behavior. Although these existing di-
agnostics might discover the mechanism a rootkit puts
in place to hide processes, it seems likely that the VICI
Agent’s effectiveness could be improved by adding a
Lycosid-like diagnostic for detecting the hidden pro-
cesses themselves.
The VMwatcher system [16] uses a hypervisor
to gather information about a system running in a
virtual machine. This information is necessarily in
terms of low-level kernel abstractions (pages, regis-
ters, disk blocks). VMwatcher introduces a technique
called Guest View Casting to recast this low-level in-
formation into equivalent higher-level abstractions (pro-
cesses, ﬁles) that can be fed to traditional user-mode
host-based intrusion detection systems. VMwatcher
uses this technique to isolate a variety of commercial
user-mode malware detection programs from the vir-
tualized system they monitor, thereby protecting them
from tampering.
In addition, it also performs cross-
view validation like Lycosid.
The XenKIMONO system [22] combines rootkit
detection functionality similar to the VICI Agent’s ba-
sic diagnostics with cross-view validation similar to Ly-
cosid and VMwatcher. Unlike the VICI Agent, XenKI-
MONO also monitors the integrity of some critical
user-mode daemons. Both XenKIMONO and the VICI
Agent recognize the need to take some kind of amelio-
rative action upon detecting a rootkit infection. Admin-
istrators can conﬁgure XenKIMONO to stop or pause
an infected virtual machine and call for manual inter-
vention, or checkpoint its state for later forensic analy-
sis. Rather than wait for manual intervention, the VICI
Agent tries to repair infected kernels itself, automati-
cally and within milliseconds.
Some hypervisor-based efforts have explored intru-
sion prevention rather than detection and repair [18, 30,
26]. While these systems have demonstrated effective
prevention, those that report benchmark results show
overheads far greater than those imposed by the VICI
Agent.
The Manitou system [18] inserts special page-fault
handling code into the hypervisor that examines each
page of executable text before it is ﬁrst paged in for ex-
ecution. Manitou computes a hash of each page and
compares it to a list that contains hashes for all autho-
rized executable text pages. If the hash is not in the list,
Manitou prevents execution of the page.
The UCON system [30] uses the Bochs IA-32 em-
ulator to demonstrate an intrusion prevention technique
that could be applied to hypervisors. The emulator per-
forms an access control checks whenever it executes a
machine instruction to write memory. If the write would
violate the machine’s security policy, UCON prohibits
the write. Conﬁgured with a security policy that pro-
hibits writes to many of the same kernel data struc-
tures examined by the VICI Agent’s basic diagnostics,
UCON has prevented the installation of many common
rootkits in laboratory tests.
The SecVisor system [26] uses the Secure Virtual
Machine feature of AMD CPUs to virtualize a ma-
chine’s MMU and IOMMU and pass control of their
8393
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:01:14 UTC from IEEE Xplore.  Restrictions apply. 
operations to a very small hypervisor. The hypervisor
enforces a page protection policy that is more strict than
the one enforced by the traditional MMU. It prevents
the writing of kernel text and the execution of kernel
data by the CPU even when in kernel-mode or by de-
vices doing DMA, thereby defeating rootkits that mod-
ify kernel instructions or depend on the execution of
malicious code in the kernel’s heap. However, it does
not prevent rootkits from changing kernel behavior by
modifying data or CPU registers.
Although Manitou and UCON clearly provide use-
ful preventive functionality, there are no published mea-
surements of the their performance overheads and it is
consequently difﬁcult to compare the costs of preven-
tion to detection and repair. SecVisor’s authors report