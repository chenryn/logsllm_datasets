那么如何才能让里面的内容进行转义并执行弹窗呢，这里需要利用到XSS的一个黑魔法——“svg”，我们下文中会提及。
## URL编码
我们可以并将src或href属性中的内容进行URL编码，当HTML解析器对src或href中的字符完成HTML解码后，接下来URL解析器会对src或href中的值进行URL解码。
    xx
下面给出几个实例。
  * `test`
    test
  * ``
注意，伪协议头 `javascript:`
是不能进行编码的。这里就有一个URL解析过程中的一个细节了，即不能对协议类型进行任何的编码操作，否则URL解析器会认为它无类型，就会导致DOM节点中被编码的“javascript”没有被解码，当然不会被URL解析器识别了。就比如说
`http://www.baidu.com` 可以被URL编码为
`http://%77%77%77%2e%62%61%69%64%75%2e%63%6f%6d`，但是不能把协议也进URL编码：`%68%74%74%70%3a%2f%2f%77%77%77%2e%62%61%69%64%75%2e%63%6f%6d`
。
但是伪协议头 `javascript:` 可以进行HTML编码。
## Javascript 编码
我们可以将DOM节点中的内容转化为 Javascript 编码。当HTML解析产生DOM节点后，会根据DOM节点来做接下来的解析工作，比如在处理诸如
``、`` 这样的标签时，解析器会自动切换到JavaScript解析模式，而 `src`、 `href` 后边加入的
javascript 伪URL，也会进入 JavaScript 的解析模式。
Javascript 中可以识别的编码类型有：
  * Unicode 编码
  * 八进制编码
  * 十六进制编码
一般情况下我们使用Unicode编码的比较广泛，而八进制和十六进制只有在DOM环境或eval()等函数中才可以用。
### Unicode 编码
  * ``
  * `test`
    test
    test
但要注意，我们同样也不能对伪协议头 `javascript:` 进行 Javascript 编码。并且像圆括号、双引号、单引号这样的符号我们也不能进
Javascript 编码，但是能进行HTML编码。
### 在DOM环境中的JavaScript编码
对于八进制编码和十六进制编码，与 Unicode 编码还是有区别，像下面的XSS向量是不能直接执行的：
  * ``
  * `test`
    test
如下图，插入之后没有任何反应：
要想让他们能够执行我们要将他们放在DOM环境中，即DOM型的XSS。
测试代码：
    test
以上情况很多都是出现在你搜索后，显示你所查询的关键字，变量 `search` 是一个可控点，当我们查询一个XSS攻击向量后，变量 `search`
就会被赋值为这个XSS向量，从而插入到div标签中触发XSS，如下所示：
    test
        var search = "";
        document.getElementById('s').innerHTML = search;
此时如果过滤了 ``、`'`、`"`、`&`、`%` 等等这些字符的话，我们便可以用JavaScript编码的方法将XSS向量全部编码，即
`` 的以下编码都可以弹窗：
    // Unicode编码
    \u003C\u0069\u0066\u0072\u0061\u006D\u0065\u0020\u0073\u0072\u0063\u003D\u006A\u0061\u0076\u0061\u0073\u0063\u0072\u0069\u0070\u0074\u003A\u0061\u006C\u0065\u0072\u0074\u0028\u0027\u0078\u0073\u0073\u0027\u0029\u003E\u003C\u002F\u0069\u0066\u0072\u0061\u006D\u0065\u003E
    // 八进制编码
    \74\151\146\162\141\155\145\40\163\162\143\75\152\141\166\141\163\143\162\151\160\164\72\141\154\145\162\164\50\47\170\163\163\47\51\76\74\57\151\146\162\141\155\145\76
    // 十六进制编码
    \x3c\x69\x66\x72\x61\x6d\x65\x20\x73\x72\x63\x3d\x6a\x61\x76\x61\x73\x63\x72\x69\x70\x74\x3a\x61\x6c\x65\x72\x74\x28\x27\x78\x73\x73\x27\x29\x3e\x3c\x2f\x69\x66\x72\x61\x6d\x65\x3e
还有一种让八进制和十六进制编码的XSS攻击向量执行的方式便是将XSS向量放在某个能把字符串当做JavaScript代码来执行的函数里，比如eval()、setTimeout()、setInterval()等函数。如下示例：
  * ``
  * `test`
    test
  * ``
或者也可以直接将一整段js代码编码后放入eval()函数中执行。
## 混合编码
**混合编码就是对一个XSS向量同时进行多种编码，如下示例：**
  * `test`
    // 对javascript:进行HTML编码, 对alert("xss")进行URL编码
    test
    // 对javascript:进行HTML编码, 对alert进行Unicode编码
    test
**也可以利用解码顺序进行混合编码，如下示例：**
  * `test`
首先对“alert”进行JavaScript Unicode编码：
    test
然后再对 `\u0061\u006c\u0065\u0072\u0074` 进行URL编码：
    test
最后对标签中的 `javascript:%5c%75...%37%34("xss")` 整体进行HTML编码即可：
    test
## SVG：XSS的一个黑魔法
我们在上文HTML编码那里最后留了一个坑，即HTML的五类元素中，像 ``、``
这样的原始文本元素在这个标签内容纳的是文本，所以浏览器在解析到这个标签后，里面内容中的HTML编码并不会被认为是HTML实体引用，所以并不会被解码为相应的字符。
也就是说，向下面这样的代码，浏览器不会对其中的HTML实体字符进行解码，也就不会执行并触发XSS了：
那如何绕过HTML原始文本元素进而执行HTML实体解码呢，这涉及到了 ``
的魔力，那是一种特殊的触发效果，单纯script标签内加载html实体编码，只会当做文本，没有任何触发结果，如下图：
但是当在前面加上 `` 后，却成功弹窗了：
这是为什么呢？
是因为 `` 标签属于HTML五大元素中的外部元素，可以容纳文本、字符引用、CDATA段、其他元素和注释，也就是说在解析到``
标签时，浏览器就开始使用一套新的标准开始解析后面的内容，直到碰到闭合标签``。而在这一套新的标准遵循XML解析规则，在XML解析中，实体编码会自动解码成相应的字符，重新来一遍标签开启状态，此时就会执行XSS了。如下图，弹窗后我们查看页面源码。发现原本不能被HTML解码的内容被
`` 标签自动解码了：
[[CISCN2019
华东北赛区]Web2](https://whoamianony.top/2020/11/30/Web%E5%AE%89%E5%85%A8/XSS%E4%B8%8ECSRF%E7%B1%BBCTF%E4%BE%8B%E9%A2%98/#CISCN2019-%E5%8D%8E%E4%B8%9C%E5%8C%97%E8%B5%9B%E5%8C%BA-Web2%EF%BC%88%E8%8E%B7%E5%8F%96%E7%AE%A1%E7%90%86%E5%91%98cookie%EF%BC%89)
这道题运用的就是这个知识点。
# XSS 测试流程思路
下面让我们来看一下XSS绕过的测试流程。
现实中，大多数的场所是用的黑名单来做XSS过滤器的，有三种方式绕过黑名单的测试：
  1. 暴力测试（输入大量的payload，看返回结果）
  2. 根据正则推算
  3. 利用浏览器bug
## 初步测试
（1）尝试插入比较正常的HTML标签，例如：``、``、``、``
等，来看一下返回页面的情况是怎样的，是否被HTML编码了，或者标签被过滤了。
（2）尝试插入不闭合的标签，例如：``、`u>`、`<img` 等，然后看一下返回响应，是否对开放的标签也有过滤。
（3）然后测试几种常见的XSS向量：