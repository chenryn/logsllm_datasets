### 优化后的文本

#### 2. 数据包划分与兴趣发布
设 \( W_2 = (b_{m+1}, \ldots, b_{2m}) \) 等。接收方（Rcv）随后发布对 \( C(1, W_1), C(2, W_2), \ldots, C(\ell, W_\ell) \) 的兴趣，其中 \( W_i \) 被用作相应位字符串的整数表示。因此，发送方（Snd）可以使用 \( \left\lceil \frac{n}{m} \right\rceil \) 个兴趣来发布一个 n 位的消息。

为了检索消息 M，Rcv 发布对 Y 中所有内容数据包的兴趣。设 \( C_{i,j} \) 为 Y 中第 i 行的内容数据包，且其往返时间（RTT）在 \( C_{i,1}, \ldots, C_{i,2m} \) 中最小。Rcv 将 \( W_i \) 设为 j，并将 M 设置为 \( W_1 | \ldots | W_\ell \)。因此，Rcv 检索 M 的成本是指数级的。实践中，合理的 m 值介于 1 和 5 之间。（注意，当 m = 1 时，该技术对应于 TDP。）

### 5. 基于公共前缀的隐蔽通信
利用之前的技术，隐蔽消息只能由单个接收者检索。消息在被 Rcv 读取后会自动“删除”。这在只有一个预期接收者的情况下是理想的。然而，当有多个接收者时，Snd 必须为每个接收者创建单独的“实例”消息。本节中，我们提出了一种称为基于公共前缀的隐蔽通信（CPC）的技术，允许 Snd 一次发布消息，并让多个接收者检索它。类似于之前的技术，使用 CPC 发布的隐蔽消息也是短暂的。

CPC 依赖于 NDN 的最长前缀匹配特性，而不是 RTT 测量。这使得它能够抵御缓存隐私技术 [1]，这些技术可能会破坏第 4 节中介绍的 CEC 技术。

CPC 通信的工作原理如下：Snd 和 Rcv 同意两个共享公共名称前缀的内容数据包 \( C_0 \) 和 \( C_1 \)，例如 /common/prefix/C0 和 /common/prefix/C1。选择的公共命名空间应确保在此下发布的数据包不受欢迎，即不在 Rt 的缓存中。为了传输一个比特，Snd 只需请求 \( C_b \)。为了接收 b，Rcv 发布对 /common/prefix/ 的兴趣。\( C_0 \) 和 \( C_1 \) 都匹配 Rcv 的兴趣。因此，Rt 将返回 \( C_0 \) 或 \( C_1 \) 中仍在其缓存中的一个数据包——或在其 PIT 中，如果 Snd 和 Rcv 的兴趣时间间隔很短（见下面的时间约束）。这样就将 b 传递给了 Rcv。

这种技术对网络条件变化非常稳健。特别是，由于不使用时间来设置或确定 b，瞬时的 RTT 波动不会引入通信错误：无论等待多长时间，Rcv 只会收到 \( C_b \)。此外，与之前的技术不同，当 Rcv 的兴趣被丢弃（或 \( C_b \) 在响应 Rcv 的兴趣时被丢弃）时，Rcv 可以重新发布其兴趣，因为这个过程不会影响 \( C_b \)。

基于公共前缀的隐蔽通道适合向一组（可能是大量）接收者分发单一消息。每个接收者对 /common/prefix/ 发布的兴趣都会“刷新”Rt 缓存中的 \( C_b \)，使其可用时间更长。一旦接收者停止检索 \( C_b \)，它就会从所有相关路由器的缓存中“消失”，从而有效地擦除 b。另一种方法是，Snd 或其中一个接收者可以请求 \( C_{\neg b} \)，以达到类似的效果。

使用 CPC 交换的消息在从所有缓存中移除时过期。

**时间约束**：为了成功检索 b，Rcv 必须在 Snd 对 \( C_b \) 的兴趣到达 Rt 之后发布对 /common/prefix/ 的兴趣。如果 Rcv 的兴趣在 \( C_b \) 返回给 Rcv 之前到达，则通过 Rt 的 PIT 实现 Snd 和 Rcv 之间的通信。否则，使用 Rt 的缓存来交换 b。Snd 的兴趣也必须在 \( C_b \) 从缓存中移除之前到达 Rt。

**5.1 多比特传输**
由于这种技术不易受到 RTT 波动和数据包丢失的影响，使用它发送和接收多个比特的数据不会引入显著错误。我们的实验（第 7 节）证实了这一点。

**使用单个兴趣传输多个比特**：Snd 和 Rcv 可以同意矩阵 Y 中的内容数据包，附加要求是对于 \( i \in [1, \ell] \)，行 i 中的内容数据包共享相同的公共前缀 pref i。Snd 将 M 分成 \( W_1, \ldots, W_\ell \)，并对每个 i 发布一个对 \( C_{i, W_i} \) 的兴趣。

Rcv 只需要为每个单词（即每行矩阵）发布一个兴趣，请求来自 pref i 的内容数据包。因此，Snd 和 Rcv 可以使用 \( \left\lceil \frac{n}{m} \right\rceil \) 个兴趣/内容数据包来交换一个 n 位的消息。

实际上，m 的限制仅取决于包含足够数量内容数据包的不受欢迎命名空间的可用性。

### 6. 错误与错误处理
比特错误可能由 Snd（写入错误）和 Rcv（读取错误）引入。根据所使用的通信技术，错误可能因不同原因而注入 M，并可以通过不同的方式检测和处理。写入错误发生在 Snd 请求的内容数据包未添加到 Rt 的缓存或 PIT 中时。读取错误发生在正确写入后、过期前消息比特的不正确检索。

**基于延迟-缓存**：我们考虑以下两种常见原因导致写入错误：
1. 数据包丢失（无论是兴趣还是内容数据包）。Snd 发出的兴趣可能在到达 Pr 的过程中被丢弃。同样，Pr 发出的内容数据包可能在到达 Rt 之前被丢弃。在这两种情况下，没有内容数据包添加到 Rt 的缓存中，因此发送操作失败。然而，Snd 可以通过重新发布未收到内容数据包的兴趣来检测这种情况。
2. 转发的内容数据包未添加到 Rt 的缓存中。这可能是由于 Rt 上的元缓存算法引起的。Snd 只能通过重新请求其消息中设置为 1 的所有比特，并比较第一次请求和第二次请求的 RTT 来检测这种情况。

我们确定了以下导致读取错误的原因：
1. RTT 波动。由于检索消息依赖于正确识别缓存命中和未命中，Rcv 和 Rt 以及 Rcv 和 Pr 之间的 RTT 重叠可能导致读取错误。这些错误无法检测，也不能通过简单地重新发送兴趣来解决。
2. 其他消费者的兴趣。一些消费者可能请求与消息中设置为 0 的比特相对应的内容数据包，并将其添加到 Rt 的缓存中。我们假设这种情况发生的概率很小，因为 Snd 和 Rcv 使用的是不受欢迎的一组内容数据包进行消息交换。
3. 数据包丢失（内容数据包）。如果内容数据包在从 Pr 到 Rt 的路径上被丢弃，Rcv 可以安全地重新请求而不改变原始消息。但是，如果它在从 Rt 到 Rcv 的途中被丢弃，相应的消息比特将被设置为 1，无论其原始值如何。只有当 b 读取为 0 时，Rcv 才能区分这两种情况并确定相应消息比特 b 的正确值。
4. 数据包丢失（兴趣）。当 Rcv 发出的兴趣在到达 Rt（如果相应的数据包在 Rt 的缓存中）或 Pr（如果不在）的过程中被丢弃时，Rcv 无法检索相应的比特。在这种情况下，Rcv 可以重新发布相同的利益而不改变原始消息，因为没有任何内容数据包被添加到 Rt 的缓存中。然而，由于兴趣丢失与内容数据包丢失无法区分，Rcv 可能无法从这种错误中恢复。
5. Rt 重启。这会导致 Rt 缓存中的所有内容数据包被删除，从而“擦除”Snd 的所有消息。如果 Rcv 知道 M ≠ 0n，则可以检测到这种情况。

Rcv 可以通过在兴趣中使用“范围”字段来减少由 RTT 波动引起的错误，前提是 Rt 是其第一跳路由器。此字段类似于 IP TTL 字段。当范围设置为 2 时，兴趣最多转发一跳。（不允许大于 2 的值 [7]。）如果 Rcv 的第一跳无法满足兴趣，它只需丢弃兴趣。这样，Rcv 不需要测量缓存命中和未命中的延迟差异，因为只有缓存命中才会返回内容。此外，这允许在数据包丢失的情况下重新发送兴趣，因为将范围设置为 2 可以防止 Rcv 的兴趣将任何新内容添加到缓存中。我们认为，然而，设置范围字段会使 Rcv 的活动更容易被检测到。

**基于延迟-PIT**：与前面的技术类似，写入错误对应于 Snd 发送但未添加到 Rt 的 PIT 的兴趣。写入错误的主要原因是 Snd 到 Rt 的兴趣丢失。Snd 无法及时检测到这种情况，因为在 Snd 收到相应的数据包之前，Rcv 必须发出相同的兴趣。

在接收方一侧，错误可能有以下原因：
1. RTT 波动。与前面的技术类似，RTT 的显著波动可能引入读取错误。
2. 数据包丢失（无论是兴趣还是内容数据包）。在数据包丢失的情况下，Rcv 将无法获得关于隐蔽消息中相应比特的任何信息。此外，重新发送兴趣可能无法提供有用的信息，因为此时与 Snd 的原始兴趣对应的 PIT 条目（如果有）将已过期或被移除。
3. 其他消费者的兴趣。其他消费者可能会发出 Snd 和 Rcv 用于隐蔽交换信息的相同兴趣。然而，这种情况发生的概率很小，因为：(1) 用于隐蔽发布消息的内容数据包是非热门的；(2) 其他消费者必须在 Rcv 发出兴趣前几毫秒内发出兴趣。
4. Snd 和 Rcv 之间的同步不足。根据拓扑结构，Snd 和 Rcv 必须紧密同步，即大约在 Snd 和 Pr 之间的半 RTT 内。同步不足可能导致高读取错误率。
5. 消息过期。尽管从技术上讲这不是读取错误，但由于严格的定时要求，Rcv 可能无法及时检索部分消息。

与之前一样，可以在 Rcv 的兴趣中设置范围字段以降低错误率。

**TDP**：写入错误的原因及可检测性与基于延迟-缓存技术的写入错误相同。同样，读取错误的原因与基于延迟-单比特缓存技术相同。然而，内容数据包对提供了更高的鲁棒性，以应对 RTT 波动和数据包丢失。由于每个消息比特都测量了两次连续的 RTT（一次对应缓存命中，一次对应缓存未命中），随机 RTT 波动导致的错误概率大大降低。对于数据包丢失，至少有一个与单个消息比特对应的内容数据包将以相对较高的概率返回。相关的 RTT 仍然允许 Rcv 估计它是否来自 Rt 的缓存——尽管准确性较低。

**基于公共前缀的隐蔽通信**：使用这种技术，写入错误可能由与基于延迟-单比特缓存技术相同的原因触发的数据包丢失事件引起。至于读取错误，这种技术比以前的技术更稳健，因为：(1) 它不依赖于时间测量，因此不受 RTT 波动的影响；(2) 在数据包丢失（影响兴趣或数据包）的情况下，Rcv 可以简单地重新发出其兴趣，而不影响隐蔽消息。然而，当其他消费者请求 Snd 和 Rcv 使用的命名空间中的内容时，可能会引入读取错误。

**6.1 错误校正**
为了处理潜在的读/写错误，Snd 可以使用纠错码与 CEM 结合。例如，可以使用 Reed-Solomon 纠错码 [24]。我们不再进一步研究这一点，因为本文的目标是评估通道的可行性及其相应的错误率。

### 7. 评估
我们实现了一个原型 CEC 系统来评估我们的协议。本节中我们将展示实验结果。该原型基于 CCNx [6]，这是一个开源的 NDN 实现，作为 IP 之上的覆盖层运行。我们在两种拓扑结构上进行了实验：
- **局域网（LAN）**：由 Snd、Rcv、Rt 和 Pr 组成，它们都在同一个广播域内。每个节点运行一个独立的 CCNx 实例。
- **NDN 测试床** [22]：其中 Snd 和 Rcv（位于欧洲）连接到 UCLA NDN 枢纽（充当 Rt），Pr 通过 UCI 枢纽连接到测试床。UCLA 和 UCI 枢纽相隔一个 NDN 跳。