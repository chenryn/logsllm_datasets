W2 = (bm+1, . . . , b2m), etc.). Rcv then issues interests for
C(1,W1), C(2,W2), . . . , C((cid:96),W(cid:96)), where Wi is used as integer
representation of the corresponding bit string. Thus, Snd
can publish an n-bit message using (cid:100)n/m(cid:101) interests.
To retrieve M , Rcv issues interests for all content pack-
ets in Y . Let Ci,j be the content packet on the i-th row
of Y such that the RTT of Ci,j is the smallest across all
Ci,1, . . . , Ci,2m . Rcv sets Wi = j, and M = W1| . . .|W(cid:96). The
cost of retrieving M for Rcv is therefore exponential in m. In
practice, reasonable values for m are between 1 and 5. (Note
that when m = 1, this technique corresponds to TDP.)
5. COMMON-PREFIX-BASED COVERT
COMMUNICATION
Using previous techniques, a covert message can be re-
trieved only by a single receiver. Message is automatically
“deleted” after it is “read” by Rcv. This is desirable when a
CEM has only one intended recipient. However, when the
CEM has multiple recipients, Snd must create a separate “in-
stance” of the message for each. In this section, we propose
a technique – called Common-Preﬁx-Based Covert Commu-
nication (CPC) – that allows Snd to publish a message once,
and have multiple parties to retrieve it. Similarly to previous
techniques, CEMs published using CPC are ephemeral.
CPC relies on NDN’s longest preﬁx matching feature, in-
stead of RTT measurements. This makes it robust against
cache privacy techniques [1], which could defeat CEC tech-
niques introduced in Section 4.
Communication via CPC works as follows. Snd and Rcv
agree on two content packets C0, C1 which share a common
name preﬁx, e.g., /common/prefix/C0, and /common/prefix/
C1. 4 The common namespace is selected such that content
packets published under it are not popular, i.e., not in Rt’s
cache. In order to transmit a single bit, Snd simply requests
Cb. To receive b, Rcv issues an interest for /common/prefix/.
Both C0 and C1 match Rcv’s interest. Therefore, Rt will re-
turn one content packet among C0 and C1 that is still in its
4Common preﬁx can be
chil-
dren namespaces, e.g., /common/prefix/foo/C0 and /com-
mon/prefix/yet /another/prefix/C1.
followed by diﬀerent
cache – or in its PIT, if Snd and Rcv’s interests are closely
spaced (see timing constraints below). This communicates
b to Rcv.
This technique is very robust against changing network
conditions. In particular, since timing is not used to either
set or determine b, transient changes in RTT do not intro-
duce communication errors: Rcv receives only Cb, regardless
of how long it waits. Moreover, in contrast with previous
techniques, when Rcv’s interest is dropped (or, similarly Cb
in response to Rcv’s interest is dropped) Rcv can re-issue its
interest, since this process does not aﬀect Cb.
Common-preﬁx-based covert channels are suitable for dis-
tributing a single message to a (possibly large) set of re-
ceivers. Each interest for /common/prefix/ issued by a re-
cipient has the side-eﬀect of “refreshing” Cb in Rt’s cache,
making b available longer. After recipients stop retrieving
Cb, it “fades away” from all involved routers’ caches, eﬀec-
tively erasing b. As an alternative, Snd or one of the recipi-
ents can request C¬b which achieves a similar result.
A message exchanged using CPC expires when it is re-
moved from all caches.
Timing Constraints. In order to successfully retrieve b,
Rcv must issue an interest for /common/prefix/ such that
the interest is received by Rt after the interest for Cb from
Snd. If the interest from Rcv is received before Cb is returned
to Rcv, communication between Snd and Rcv is implemented
through Rt’s PIT. Otherwise, Rt’s cache is used to exchange
b. Snd’s interest must also be received by Rt before Cb is
removed from the cache.
5.1 Multiple-Bit Transmission
Since this technique is less susceptible to RTT ﬂuctuations
and packet loss, using it for sending and receiving multiple
bits in bursts does not introduce signiﬁcant errors. This is
conﬁrmed by our experiments, in Section 7.
Transmitting Multiple Bits with a Single Interest.
Snd and Rcv can agree on content packets in matrix Y with
the additional requirements that for i ∈ [1, (cid:96)], content pack-
ets in row i share the same common preﬁx pref i. Snd splits
M in W1, . . . , W(cid:96), and – for each i – issues one interest for
Ci,Wi .
Rcv needs to issue only one interest per word (i.e., per
matrix row), requesting a content packet from pref i. For
this reason, Snd and Rcv can exchange an n-bit message
using (cid:100)n/m(cid:101) interests/content packets each.
In practice,
m is limited only by availability of un-popular namespaces
containing a suﬃcient number of content packets.
SndtRcv[ I : Snd → Rt ][ I : Rt → Pr ][ C : Pr → Rt ][ I : Rcv → Rt ][Exp][ I : Rcv → Rt ]SndtRcv[ I : Snd → Rt ][ I : Rt → Pr ][ C : Pr → Rt ][ I : Rcv → Rt ][ I : Rcv → Rt ]196. ERRORS AND ERROR HANDLING
Bit errors may be introduced by both Snd (write errors)
and Rcv (read errors). Depending on the technique used
to communicate, errors may be injected in M for diﬀerent
reasons and may be detected and dealt with in diﬀerent
ways. A write error occurs when a content packet requested
by Snd is not added to Rt’s cache or PIT. A read errors
occurs as a result of an incorrect retrieval of a message bit
after it has been correctly written, and before it is expired.
Delay-Based: Cache. We consider the following two is-
sues as common causes for write errors:
1. Packet loss (either interests or content packets). Inter-
ests from Snd may be dropped along their way to Pr.
Similarly, content packets from Pr may be dropped be-
fore they reach Rt. In both cases, no content packets
added to Rt’s cache, and therefore the send operation
fails. This, however, can be detected by Snd, who sim-
ply re-issues interests for which it does not receive con-
tent packets.
2. Forwarded content packets not added to Rt’s cache.
This can be caused, for example, by meta-cache algo-
rithms on Rt. Snd can detect this only by re-requesting
all bits set to 1 in its messages and, for each compar-
ing the RTT of the ﬁrst request with the RTT of the
second.
We identify the following causes for read errors:
1. RTT ﬂuctuations. Since retrieving a message relies on
correctly identifying cache hits and misses, any overlap
in the RTT between Rcv and Rt and between Rcv and
Pr could cause a read error. These errors are not de-
tectable, and cannot be addressed by simply re-sending
interests.
2. Interests from other consumers. Some consumers may
request a content packet that correspond to a bit in the
message set to 0, and have it added to Rt’s cache. We
assume that this happens with negligible probability,
since Snd and Rcv exchange messages using a set of
content packets that are not popular.
3. Packet loss (content packets).
If a content packet is
dropped on the path from Pr to Rt, it can be safely
be re-requested by Rcv without altering the original
message. However, if it is dropped on its way from Rt
to Rcv, the corresponding message bit will be set to
1 regardless of its original value. Rcv can only distin-
guish between the two cases – and determine the cor-
rect value of the corresponding message bit b – when
b is read as 0.
4. Packet loss (interests). When interests are dropped on
their way from Rcv to Rt (if the corresponding content
packet is in Rt’s cache) or to Pr (if it is not), Rcv cannot
retrieve the corresponding bit. In this case, Rcv can
re-issue the same interest without altering the original
message, since no content packets have been added to
Rt’s cache. However, since loss of interest cannot be
distinguished from loss of content packet, Rcv may not
be able to recover from this error.
5. Rt is rebooted. This causes all content packets in Rt’s
cache to be deleted, hence “erasing” all messages from
Snd. This can be detected if Rcv knows that M (cid:54)= 0n.
Rcv can reduce errors induced by RTT ﬂuctuations using
the “scope” ﬁeld in interests, when Rt is its ﬁrst-hop router.
This ﬁeld works similarly to the IP TTL ﬁeld. When scope is
set to 2, interests are forwarded for up to one hop. (Values
If the Rcv’s ﬁrst hop
higher than 2 are not allowed [7]).
cannot satisfy the interests, it simply drops it. This way,
Rcv does not need to measure any diﬀerence in the delay
of cache hits and misses, since only cache hits will result
in returned content. Moreover, this would allow interest
retransmission in case of packet loss, since setting scope to
2 would prevent Rcv’s interests from adding any new content
into the cache. We argue that, however, setting the scope
ﬁeld would make Rcv’s activity easier to detect.
Delay-Based: PIT. As in to the previous technique, write
errors correspond to interests sent by Snd and are not added
to Rt’s PIT. The main cause for write errors is loss of the
interest from Snd to Rt. This cannot be detected on time by
Snd, since the same interest must be issued by Rcv before
the corresponding content packet is received by Snd.
On the receiver side, errors may have the following causes:
1. RTT ﬂuctuations. Similarly to the previous technique,
signiﬁcant ﬂuctuations of RTT can introduce read er-
rors.
2. Packet loss (either interests or content packets). In case
of packet loss, Rcv will learn no information about the
corresponding bit in the covert message. Moreover,
re-transmitting an interest may provide no useful in-
formation, since by then the PIT entry corresponding
to the original interest from Snd, if any, will be either
expired or removed.
3. Interests from other consumers. Other consumers may
issue the same interests that Snd and Rcv are using to
covertly exchange information. However, this happens
with negligible probability, because: (1) content pack-
ets used to covertly publish messages are non-popular,
and (2) interests from other consumers must be issues
a few milliseconds before Rcv issues its interests.
4. Lack of synchronization between Snd and Rcv. Depend-
ing on the topology, Snd and Rcv must be tightly syn-
chronized, i.e., roughly within half RTT between Snd
and Pr. Lack of synchronization may lead to a high
rate of read errors.
5. Message expiration. Even though this technically is
not a read error, it may happen that Rcv cannot re-
trieve part of the message on time due to the strict
timing requirements.
As before, the scope ﬁeld can be set in Rcv’s interest to
reduce error rate.
TDP. Write errors have the same causes, as well as de-
tectability, as the write errors in delay-based cache tech-
nique.
Similarly, read errors have the same causes as with delay-
based, single-bit cache. However, content packet-pairs pro-
vide more robustness against RTT ﬂuctuations and packet
loss. Since two subsequent RTTs – one corresponding to a
cache hit, and one for a cache miss – are measured for each
message bit, the probability of error associated with ran-
dom RTT ﬂuctuations is greatly reduced. With respect to
packet loss, at least one of the content packets correspond-
ing to a single message bit will be returned with relatively
high probability. The associated RTT will still allow Rcv to
estimate whether it is coming from Rt’s cache – although
less accurately.
Common-preﬁx-based Covert Communication. Us-
ing this technique, write errors may be introduced by the
20same events that trigger packet loss in delay-based, single
bit cache. With respect to read errors, this technique is sig-
niﬁcantly more robust than the previous ones because: (1)
it does not rely on timing measurements, and is therefore
immune to RTT ﬂuctuations; and (2) in case of packet loss
(aﬀecting either interests or data packets), Rcv can simply
re-issue its interest, without aﬀecting the covert message.
Read errors can, however, be introduced by interests from
other consumers, when they request content from the names-
paces used by Snd and Rcv.
6.1 Error Correction
To address potential read/write errors, Snd can use error-
correction codes with CEM. For example, Reed-Solomon er-
ror correction codes [24] could be used. We do not investi-
gate this any further, since the goal of this paper is to assess
feasibility of the channel and the corresponding error rate.
7. EVALUATION
We implemented a prototype CEC system to evaluate our
protocols. In this section we present the results of our exper-
iments. The prototype is based on CCNx [6], an open-source
implementation of NDN which runs as an overlay on top of
IP. We performed experiments on the two topologies:
• LAN, composed of Snd, Rcv, Rt and Pr within the
same broadcast domain. Each party runs a separate
instance of CCNx.
• NDN testbed [22], where Snd and Rcv (located in Eu-
rope) are connected to the UCLA NDN hub (which
acts as Rt), and Pr is connected to the testbed through
the UCI hub. UCLA and UCI hubs are one NDN hop