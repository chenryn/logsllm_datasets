logical communication requirements for DPASA clients
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:13:22 UTC from IEEE Xplore.  Restrictions apply. 
Policy
Policy Rules Required
VPN
ADF
CSA
SELinux
JVM
VPN to EB [EA]
VPN from EA [EBi ]
VPG from A to B for c [A, Bi]
Allow access from A for c [B1, B4]
Allow access from A for c [B2, B3]
Allow access to Bi for c [A]
Allow access from A for c [Bi]
Allow access to Bi for c [A]
Table 1. Policies affected by one logical net›
work communication rule to allow communi›
cation c from client A to core B
and only one quad of the DPASA core. In this case,
CLIENT actually represents a dozen client hosts. Of
the other nodes, each node starting with ‘q1’ is a single
host, but nodes (other than CLIENT) without this pre-
(cid:12)x represent collectively the corresponding hosts in the
three other quads. For example, the ADF Policy Server
in quad 1, or q1adfps, engages in policy server replica-
tion services (PSReplication) with the Policy Servers
(collectively named PS) in each other quad.
The next section describes our (cid:12)rst step for man-
aging this complexity: de(cid:12)ning properties for shared
policy elements.
3. Properties
Practical experience suggests that managing mul-
tiple policies, each containing redundant information,
increases the risk of overlooked updates that will be dis-
covered later by a developer, who is unaware of those
updates, and will waste time trying to debug the policy.
An example is when a key value, such as the port num-
ber for a required network service, is changed in some
policies but not in others. To minimize this risk, we
separated functional roles from actual identities when
specifying policies. For example, in each quad a dif-
ferent host(identity) (cid:12)lls the role of an Access Proxy.
The identities are calculated as the policy for each host
or application is generated. In addition, this allows us
to easily change the allocation of roles per host when
moving DPASA software to new network addresses and
environments.
Identities and application information were placed
in a master property (cid:12)le that contained two sections:
a mapping of a (cid:12)lename to a (cid:12)le identi(cid:12)cation number
in the (cid:12)rst section and in the second section a collec-
tion of role=identity pairs followed by three hyphens,
a (cid:12)le identi(cid:12)cation number or numbers, and optionally
a hyphen and quad speci(cid:12)er. An example is shown
below.
_file_1=../../sm/conf/sm.prp
_file_2=../../proxies/conf/psqproxy.prp
PSQ_server0=192.168.4.34:8296 --- 1,2 - q4
rmi_host=192.168.4.14 --- 2
In this case, PSQ server0=192.168.4.34:8296 was
placed in sm.prp and psqproxy.prp, (cid:12)les 1 and 2. This
guaranteed that the speci(cid:12)ed role had a consistent
identity in the speci(cid:12)ed (cid:12)les. The q4 su(cid:14)x declared
that this binding was good only for quad 4. The other
declaration was not speci(cid:12)c to a quad and the su(cid:14)x
was omitted.
4. Application Layer Policy
Once the identities were speci(cid:12)ed in this structured
way, they were associated with their roles in the JVM
policies using policy templates. These templates were
essentially JVM policies containing variables that were
(cid:12)lled in using the master property (cid:12)le to create a single
JVM policy for each application. Whenever we needed
an IP address or port from the con(cid:12)guration (cid:12)le we
would place a variable of the following form in the pol-
icy: name (cid:12)leNumber.
The following example lines shows a network per-
mission in a JVM template:
permission java.net.SocketPermission \
":", "connect";
and the corresponding (cid:12)nal product:
permission java.net.SocketPermission \
"192.168.4.14:7183", "connect";
This scheme worked well when each policy template
mapped to a policy on a single deployment host. How-
ever, some DPASA components were implemented on
multiple hosts. Those applications each needed a policy
to allow them to contact services bound to the IP ad-
dress of that host. That would have required a di(cid:11)erent
policy template for each host, di(cid:11)ering in only the iden-
tity variable placed there. To avoid such duplication,
we added meta-variables to the top of each template
to change the variable values used when generating the
policies. Each combination of meta-variables generated
a unique policy (cid:12)le. An example is shown below where
each client is allowed to communicate with a registry
on its own host.
// metavar=CLIENT_IP ->c1_ip__13,c2_ip__13
permission java.net.SocketPermission \
":", \
"connect"; // ,Rmi
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:13:22 UTC from IEEE Xplore.  Restrictions apply. 
CLIENT
Alerts
HeartBeats
RmiDcProxy
TimeSvc
LcRmi
Registration
SurvDelRmi
PubSub
TS
q1ap
q1psq
HeartBeats
PsqSessionChecking
Rmi
RmiReg
LcControl
RmiClientProxy
RmiReg
TimeSvc
TimeSvc
PubSub
PubSub
HeartBeats
LcControl
RmiReg
Rmi
RmiReg
PSQ
RmiReg
Advice
RmiReg
JbossSecDb
PubSub
webAdmin
q1dc
Alerts
Alerts
Alerts
q1nids
Alerts
Rmi
RmiReg
Advice
LcControl
RmiReg
HeartBeats
q1sm
Spread
Spread
HeartBeats
RmiReg
Rmi
LcControl
RmiReg
RmiPs
SM
RmiPs
PsConnect
HeartBeats
AlertDisplay
RmiReg
Advice
RmiReg
Alerts
RmiPs
RmiPs
RmiPs
PsConnect
RmiPs
PsConnect
Alerts
PSReplication
PSReplication
q1adfps
q1cor
PS
Figure 3. DPASA network communication requirements
In the above case two policy (cid:12)les are generated, one
for each of the two client hosts. Wherever the meta-
variable - -CLIENT IP- - is found, it is replaced with
one of the speci(cid:12)ed variables. The policy (cid:12)le names
generated in this way are pre(cid:12)xed with the variable
name, or names in the case of multiple meta-variables,
used to create them so they are easily distinguished.
Using the properties, meta-variables, and JVM tem-
plates, we were able to generate JVM policies for our
components as the system was packaged for deploy-
ment.
To help validate the components protected by these
JVM security policies, the generated JVM network per-
missions were used to automatically create network
fuzzers, which would send random/malicious tra(cid:14)c be-
tween two end-points in the network in an attempt to
(cid:12)nd a vulnerability. Each sending or receiving per-
mission generated a matching fuzzer. These fuzzers
were collected together to represent a faulty applica-
tion. This ensured that there was always a set of faulty
clients or servers that could be used to test what would
happen when a component behaved incorrectly. Using
these fuzzers we could test the response of a component
to authorized but incorrect or malicious tra(cid:14)c.
5. Process Layer Policy
Proper process behavior was enforced using SELinux
on a majority of the DPASA hosts, and CSA on the
Windows and Solaris hosts. While the two technolo-
gies served similar purposes, their policies and the ap-
proaches for constructing them were very di(cid:11)erent.
For example, SELinux policies are very (cid:12)ne-grained
and detailed, requiring signi(cid:12)cant e(cid:11)ort to con(cid:12)gure
and maintain, especially in a multi-host environment
like DPASA. To ease multi-host policy construction,
we extended the SELinux policy construction tools
to generate policies for multiple hosts simultaneously.
CSA’s policy management interface, on the other hand,
worked very nicely in multi-host environments, but its
browser-based interface made management of detailed
policies very tedious. Also, CSA, unlike all of the other
technologies we used, assumed that a privilege was au-
thorized unless speci(cid:12)cally denied, so we had to exer-
cise caution when specifying rules. Finally, SELinux
and CSA both included tools to generate policy rules
directly from observed alerts, but we found the results
were often opaque and di(cid:14)cult to maintain, so we cre-
ated the deployed policies without using those tools.
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:13:22 UTC from IEEE Xplore.  Restrictions apply. 
5.1. SELinux Policy
The SELinux policies operated at a much (cid:12)ner level
of granularity (individual system calls) than the JVM
policies, and we made no attempt to directly translate
from one to the other. However, the properties that
were used to (cid:12)ll in the JVM templates were very use-
ful when generating SELinux policies. Each port and
IP address had a unique SELinux type in the policies,
and these types needed to be bound to the correct IP
addresses and ports for each host. Since these changed
periodically, manual maintenance was not an attractive
option.
A useful level of automation was achieved through a
modi(cid:12)ed policy construction process. The source (cid:12)les
for SELinux policies are normally prepared with the
m4 macro preprocessor before being processed by the
policy compiler. Three additional (cid:12)les were included
in the preparation in order to help automate the bind-
ing of network details. First, the host IP address and
port number de(cid:12)nitions were converted from the mas-
ter property (cid:12)le into m4 macro de(cid:12)nition statements.
Then two (cid:12)les were created to bind the DPASA IP and
port symbols to the SELinux type symbols. The nor-
mal source (cid:12)le for network binding, net contexts, was
then modi(cid:12)ed to include the new (cid:12)les in correct places.
Additional macros were de(cid:12)ned and used to perform
modi(cid:12)cations such as extracting the port or IP part
of a combined IP and port speci(cid:12)cation. A \quad"