时候都是已知的，那么这个“新”的事实应该在第讠－1轮进行同样的常量替换时就已经被发现了。
成刚刚在第讠-1轮发现的新事实。这个论断的证明如下：如果子目标中的所有事实在第-2 轮的
现的条件如下：它是对某一个规则进行常量替换后的结果，并且其中至少有一个子目标经过变换变
12.3.5Datalog 程序的增量计算
于 2i-1的路径。
为8的路径，并且--般来说，在第i轮之后，path(αa,b)为真当且仅当有--个从α到b且长度不大
以把长度不大于2的路径连接起来找到所有长度不大于4 的路径。在第四轮，我们发现最大长度
美合。如果p是--个 IDB 断言，我们将计算得
-条是在上一轮中发现的。
1）把程序的规则修改为上面描述的增量
这个想法将在算法12.18中正式描述。在此之
为了利用这个性质，我们为每个IDB 断言p引人一个断言 newP，该断言只对上一轮中新发现
有一个可行的方法可以提高算法12.15 的效率。请注意，--个新的 IDB 事实只能在第i轮被发
588
方法：对于程序中的每个断言p，令 R,
输出：各个 IDB 断言的事实集合。
输入：一个 Datalog 程序和各个 EDB 断言
4）把所有 newX关系表设置为空，准备进行下.-
3）把这些 neuP的事实加人到 p 中。
1）应用新的规则对 neuP 断言求值。
像算法 12.15 那样，对应于每个 IDB 断言 p 的关系累积了所有的p 的事实。在每--轮中，我们
2
然后从 newP 中减去 p，保证 neuP 中的事实确实是新的。
Datalog 程序的增量求值。
表
口
repeat{
for（每个IDB断言P）{
}until(所有 Rncup 都为空）;
for(每个断言p）
f（某个替换方案使得一个规则的规则体为真）
规则体的所有子目标都为真；
考虑对所有规则中的变量的所有常量替换方案；
图12-17
图12-18
2b)
newPath(X,Y)
newPath(X,Y)
 P
h是该规则的头的断言；
newPath(X, Y)
Datalog 程序 path 的增量式规则
 Datalog 程序的求值
:-newPath(X,Z)&
path(X,Z)&
path(Z,Y)
newPath(Z,Y)
edge(X, Y)
第12章
对
口
---
## Page 605
为子目标 NOT p(1)为假。类似地，第三次迭代说p(1)为真，第四次迭代说它是假，如此往复。
例12.20
则，我们就可以用算法12.15 或算法12.18从低到高地对各个层次求值。首先处理处理较低层
q（.）的子目标，那么α要么是一个EDB，要么是一个层次低于p的 IDB断言。只要满足这个规
在比较式中。结果是只要r( X)为假且 Y不同于 X，p 对于无穷多个二元组(X，Y)为真。
是不安全的。原因有两个：变量X只出现在否定的子目标r(X)和比较表达式X≠Y中；Y只出现
例12.19
符中的情况。制定这个策略是为了避免那些可能使我们推导出无穷多个事实的规则。
必须是一个普通 IDB 或 EDB 原子。我们不能接受一个变量只出现在一个否定原子中或比较运算 
迭代告诉我们 p(1)为假。也就是说，在这个规则中，把X替换为1不会令我们推导出p(1），因
真。"但是，因为e(1)和 NOT p(1)都为真，所以第一次迭代时推导出p(1)。但是，之后的第二次
(即p本身)的否定形式，且这个 IDB(即 p)所在的层次当然不会比 p 的层次更低。
假设e是一-个 EDB断言，并且只有e(1)为真。那么 p(1)为真吗？
如下面的例子所示，迭代算法可能无法收敛。
的IDB，在处理较高层次时把低层次上的IDB 当作EDB。但是，如果我们违反了这个规则，那
法必须限定这个变量只能取那些出现在 EDB 中的值。
险是：
12.3.6有问题的 Datalog 规则
新事实更加容易。
位向量的实现方式已经非常高效了。--般来说，直接计算整个向量要比决定--个事实是否为
计算中出现在IN[B]中。我们之所以没有尝试以增量的方式来解决这样的数据流问题，因
中，只有当--个定值刚被发现在基本块B的前驱p的 OUT[P]中时，这个定值才能够在本次
1）不安全规则：这些规则的头中有--个变量没有以适当的方法出现在规则体中。正确的方
过程间分析
如果我们应用上面的迭代算法，我们从R，=0开始，因此开始时的答案是“不；P(1)不为
这个程序是不可分层的。不管我们把p放在哪一层，它的规则中有一个子目标是某个 IDB
2）不可分层的程序：一-组规则之间存在涉及否定形式的循环定义。
有些Dalalog 规则，或者说程序，在技术上没有任何意义，因此不应该使用。两种最严重的风
为了让一个程序有意义，递归定义和否定形式必须分开。正式要求如下。我们必须能够把
可分层的Datalog 程序
出现在某个规则头的任何变量都必须出现在规则体中。不仅如此，这个变量所在的子目标
我们将详细讨论这两个风险。
2）执行图12-18 中的算法。
安全规则
以增量的方式来解决基于集合理论的数据流问题也是可行的。比如，在到达定值问题
考虑下面的由单个规则构成的 Datalog程序：
规则
p(x, Y) :- q(Z) & NOT r(X) & X≠Y 
p(X) :- e(X) & NOT p(X)
集合表示法的增量求值 
589
为
公
次
口
---
## Page 606
求值策略。给出每一轮中找出的 path 的事实。
给出每一轮中找到的 path 事实。
序是可分层的吗？
概念中的哪些概念依赖于哪些其他概念？这些依赖关系中哪些是否定形式的？得到的Datalog 程
gen 和kill信息)，并且使用这些 EDB 断言和这六个概念中的其他概念定义了每个概念。这六个
设一个断言use(1，X)表示语句I使用了变量 X。
log 程序来计算活跃变量。除了断言 defines 之外，假
是表达式中的运算符，例如+。
言说明语句I使得表达式XOY被求值。这里
之外，再加上一个断言eual(I,X,0,Y）。这个断
Datalog 程序来计算可用表达式。除了断言 defines
语句Ⅱ的开始处。
out 变成了带有三个参数的断言。例如,in(I, D,X)表示在语句 D 上对X的(可能的)定值到达了
个二元组(D，X)，其中 D是一个语句，X是一个可能被D定值的变量。这样做的结果是，n 和
赋值运算。在这种情况下，defines(I，X)对多个不同的 X和一个丫成立。--个定值最好表示为-
合中。规则3是普通的传递函数。因为1可以有多个前驱，所以规则4表示了交汇运算的情况。
算到达定值的常用算法。
头和结尾。请注意，一个定值实际上是一个语句的编号。图 12-19 是--个 Datalog 程序，它表示计
所定值的变量为 X。我们将使用 IDB 断言 in(I, D)和 out(I,D）分别表示定值 D 到达语句I的开
定值。EDB 断言 pred(I,J)表示语句I是语句J的--个前驱。EDB 断言 defines（I，X）表示语句 
问题。假设每个语句本身就是一个基本块，并且－-开始的时候假设每个语句对且只对一个变量
12.3.7 12.3 节的练习
我们断定这个不可分层的程序是无意义的，也不能把它看作一-个正确的程序。
2）在这个数据上模拟执行图 12-17 中的 Dalalog 程序。该程序实现了算法 12.18 中的增量式
练习12.3.4：在9.5节中，我们定义了一个涉及六个概念的数据流计算，这些概念包括：预
练习 12.3.2：编写—个和图12-19 类似的
练习12.3. 3：编写-个和图 12-19 类似的 Data-
你要解决的问题是修改这些规则来处理常见的二义性定义的情况，比如通过一个指针进行
请注意，规则1是说明一个语句杀死了它自己，但是规则2保证-一个语句总是在它自己的输出集
590
练习12.3.6：下面的规则
1）指出这个规则的头、规则体和各个子目标。
是一个较大的 Datalog 程序 P的一部分。
1）使用算法12.15 中的简单求值策略，在这个数据上模拟运行例子 12.12 中的 Datalog 程序。
edge(4,1) edge(4,5)
edge(1,2)
练习12.3.5：假设EDB 断言edge(X，Y)包含下面的事实：
edge(2,3)
p(X, Y) :- g(x, Z) &r(Z, W) & NOT p(W, Y)
edge(5,6)
edge(3,4)
0
kill(I.D)
图 12-19
in(J, D)
omut(1. D)
out(I, 1)
析的 Datalog 程序
一个简单的到达定义分
out(J, D) & pred(J, I)
in(I, D)& NOT kill(I,D)
defines(I, X)
defines(I,X) & defines(D, X)
第12章
口
---
## Page 607
得更加精确的结果，也可以大大减少分析所需时间。
针指向信息动态地构造调用图，就可以得到更加精确的结果。更加精确的调用图不仅仅可以获
型，然后把分析范围限定在这些类型中。但是，如果我们可以在做指针指向分析的同时，利用指
析把范围精确地缩小到在 String 中声明的方法。
“hashCode”的所有方法都当作可能的调用目标。知道o指向--个 String 对象将会使过程间分
这里被声明为－-个 Object。如果不分析指向什么，我们必须把在各个类中声明的名为
例12.21
在编译时刻准确地确定x的类，从而准确知道m 指向哪个方法。
调
个函数指针指向哪里。显然，在分析被调用的函数之后，我们会发现这个函数指针可能指向更多
调
改变反
只能指向一个对象的开头。
变
12. 4.1 为什么指针分析有难度 
个指针可能指向同一个对象，那么它们可能互为别名。
语言来说，因为方法常常很小，所以控制流相关性和上下文相关性相比就不是那么重要。
处理方法，然后再给出上下文相关的方法。控制流相关会增加很多复杂性，并且对于 Java 这样的
被分析程序中没有过程调用。我们将在以后各节中说明如何处理过程，首先给出上下文无关的
12.4一个简单的指针分析算法 
法。我们对×的实际类型了解得越精确，我们的调用图也就越精确。在理想情况下，我们可以
方
用一个解引用的函数指针来实现函数的间接调用。在分析被调用函数之前，我们需要知道这
量的别名。Java 中的指针称为引用，对它们的分析要简单得多。它不支持算术运算，并且指针
序可以读入一个整数并把它赋给一个指针，这么做会使得这个指针成为程序中所有其他指针
过程间分析
也可以使用近似的方法来减少目标的数量。比如，我们可以静态地确定被创建的对象的类
用。
虽然
支持间接函数调用的语言对指针别名分析提出了另一个挑战。在C语言中，人们可以通过
指针别名分析必须是过程间分析。没有过程间分析，我们就必须假设任何方法调用都可能
指针指向分析是很复杂的。它不是“简单的”数据流问题，在这类问题中我们只需要模拟单
对C 语言程序进行指针别名分析特别困难，因为C程序可以对指针进行任何运算。实际上
在指针别名分析中，我们希望了解的基本问题是一对给定的指针是否可能互为别名。回答
在本节中，我们开始讨论一个非常简单的控制流无关的指针别名分析技术。这个技术假设
5）P是可分层的吗？
3）！
2）哪些断言一-定是程序 P的 IDB 断言？
:o 45afa0
所有可被它访问的指针变量所指向的内容，造成所有过程内的指针别名分析非常低效。
练习12.3.7：把图12-14中的规则转换成为增量形式。
4）
 = o.hashCode();
给定-个Java 程序中的调用x. m(），对象x可能属于很多个类，这些类都具有名为 m 的
然C语言中的大部分函数是被直接调用的，但是Java中的虚方法使得很多调用成为间接
，因此这个过程需要迭代进行。
这个规则安全吗？
哪些断言--定是 P 的 EDB 断言？
new String();
考虑下面的Java 语句序列：
口