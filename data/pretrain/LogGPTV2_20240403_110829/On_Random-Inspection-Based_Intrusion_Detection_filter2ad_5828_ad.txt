gzip gcc
make gcc
 1200
 1000
 2200
Inspection freq (in number of instr between inspections)
 1800
 1400
 1600
 2000
 2400
Fig. 1. Performance overhead of WindRain at diﬀerent inspection frequency: y-axis
is the overhead in %, x-axis gives the inspection frequency in number of instructions
executed before an inspection occurs
180
S.P. Chung and A.K. Mok
the overhead caused by WindRain at the inspection frequency being tested. The
results of our experiments is shown in Fig. 1.
From the results in Fig. 1, we see that the performance overhead drops quite
signiﬁcantly as the inspection frequency decreases. This shows a signiﬁcant trade-
oﬀ between detection rate and performance overhead. Such tradeoﬀ once again
highlights the value of obfuscation techniques that lengthen the VVP of future in-
jected code. Consider an obfuscation technique that guarantees any injected code
will spend at least 2000 instructions locating the needed library functions. With
such guarantee, we can perform an inspection every 2000 instructions and still
guard against optimized injected code at an overhead of around 20%. Otherwise,
we will have to guard against these future attacks by increasing the inspection fre-
quency at the cost of higher performance penalty. However, even when perform-
ing random inspection once every 800 instructions, the performance overhead of
WindRain still compares favorably against many system-call-based IDS. Accord-
ing to [8, 27], system-call-based systems typically incur more than 100% overhead
in the interposition of system calls alone, unless the kernel is modiﬁed for the task.
To study how much overhead is contributed by the random-inspection process
alone, we studied the performance overhead of a system that performs random
inspection without the PC-value checking. We compared the performance over-
head of both WindRain and the “empty” system at three inspection frequencies:
once every 800, 1600 and 2400 instructions respectively. Due to space limitation,
we omit the raw data of our experiments and simply report our ﬁndings below.
We ﬁnd that a large proportion of the overhead (more than 89% in all our
experiments) comes from performing random inspection. On the other hand, the
checking of PC values obtained from random inspections only slightly increases
the overhead. This result demonstrates the feasibility of performing more so-
phisticated checking at each inspection point. For example, one would expect
the checking of the return address of the current stack frame to incur very small
extra overhead. This ﬁnding also allows us to conclude that the overhead is
mainly contributed by the side eﬀect of random inspection, instead of perform-
ing the PC checking. This side eﬀect includes the ﬂushing of pipelines and the
consumption of extra instruction cache. We have also measured the eﬀect of
random inspection on diﬀerent cache miss rate and the paging rate. Our exper-
iments show no signiﬁcant increase in these measures while performing random
inspection. As a result, we strongly believe that the ﬂushing of pipeline caused
by the frequent performance-counter overﬂow and subsequent interrupt handling
is the major cause of the high overhead. Pipeline ﬂushing is also identiﬁed as a
major cause of overhead in system-call interposition systems.
6 Conclusions and Future Work
In this paper, two problems of system-call-based anomaly detection systems
are discussed: its inherent vulnerability to mimicry attacks and its being non-
portable for the widely deployed Windows systems. These weaknesses have their
roots in monitoring at the system-call interface and the predictability thereof
On Random-Inspection-Based Intrusion Detection
181
to the attacker. Since this monitoring mechanism is shared by all system-call-
based systems, it is diﬃcult to completely overcome these diﬃculties without
having an alternative and complementary mechanism. We propose random in-
spection as an alternative monitoring mechanism. We demonstrated that ran-
dom inspection can be implemented on Windows without requiring knowledge
or modiﬁcation of the Windows kernel. Furthermore, owing to its random na-
ture, random-inspection-based intrusion detection is inherently less susceptible
to mimicry attacks. Random-inspection-based intrusion detection is a strong
complement to the more traditional system-call-based intrusion detection sys-
tems. Together these two types of IDS require attackers to deal with two con-
ﬂicting constraints. In order to evade detection by random-inspection-based sys-
tems, the attacks need to be short. On the other hand, to evade detection by
system-call-based IDS, attacks must be more complicated and therefore take
longer to execute. Random-inspection-based systems also provide a second line
of defense for systems that depend on obfuscation/diversiﬁcation as the main
line of defense. With our random-inspection-based detection as a complement,
even obfuscation/diversiﬁcation techniques that are susceptible to reversal by
an attacker can become very useful defense mechanisms. In particular, random-
inspection-based detection will make the design of obfuscation techniques easier.
In reciprocal, both traditional system-call-based systems and obfuscation tech-
niques can complement random-inspection-based systems by forcing intruders
to lengthen the attacks. This will allow random inspection to be performed at
lower frequency while still maintaining a very high detection rate and a lower
frequency implies a lower performance overhead.
To demonstrate the usefulness of random-inspection-based detection, we have
implemented a working prototype: the WindRain intrusion detection tool. Our
prototype performs random inspection on the PC value of the instruction being
executed. If the inspected PC value corresponds to a region of memory that
contains data, WindRain will mark it as an intrusion. Despite being a very
simple system, our analysis shows that WindRain can detect most of the in-
jected code attacks with a very high probability. We have tested several attacks
against WindRain (namely, MSBlast, Welchia, Sasser, Code Red and SQLSlam-
mer, all famous attacks against Windows systems). We found that WindRain
can detect all the attempted attacks very eﬀectively. This is even true with
the lowest inspection frequency tested. In terms of false positive, we found that
WindRain generates few false alarms for all but two applications we have tested,
the Java compiler and the JVM. Furthermore, WindRain was found to work
well with all the Windows system processes without raising any false positive.
This makes WindRain very suitable for system-wide protection. In terms of
performance overhead, WindRain compares favorably against many other in-
trusion detection systems, even when performing inspections at a very high
frequency.
We consider our work in this paper as an illustration of the usefulness of
random-inspection-based intrusion detection systems. There is a lot of interesting
182
S.P. Chung and A.K. Mok
work to be done in both enhancing the idea of random-inspection-based detection
and extending the capability of WindRain.
For the improvement of WindRain, we are working on solutions that allow
WindRain to work with dynamically-generated/self-modifying code (like those
generated by JVM). We believe the approach outlined in the Sect. 5.2 is very
promising. We are also interested in ways to turn oﬀ WindRain for non-critical
processes so that only critical processes incur the performance overhead from
WindRain. A possible direction would be to capture Windows context switch
and reconﬁgure WindRain accordingly. We have some preliminary evidence of
success on this. We note that the software approach we take allows us to attack
these problems in ways that the inﬂexibility of hardware-based technology such
as NX would have a much harder time to emulate.
In terms of the development of random-inspection-based systems, we are inter-
ested in studying what kind of information is available at the random-inspection
points, and how to make use of it. An interesting direction of research is to
design proﬁle-based intrusion detection systems under the random-inspection
mechanism. The proﬁle-based approach will allow us to protect programs that
use dynamically generated code without generating too many false positives. It
is also a promising approach to tackle existing code attacks. We believe our work
has opened up new directions for research of obfuscation techniques that can be
used as defensive mechanisms. With the complement of random-inspection-based
systems, new obfuscation techniques do not have to thwart attacks directly. They
only need to make attacks signiﬁcantly more complicated and visible to random-
inspection-based detection. The work in [2] about address obfuscation is a very
good example in this direction. Another interesting example is to reproduce the
harsh Windows environment (where the kernel interface is unknown) on Linux.
This can be achieved by randomizing the mapping between the system-call num-
ber and the corresponding kernel service. If we obfuscate the kernel interface,
we can avoid injected code from making direct calls to the kernel. As a result,
injected code will have to go through the long library-function-locating process
as on Windows. Thus this obfuscation technique will allow injected code attacks
to be detected easily by random-inspection-based systems like WindRain.
References
1. Elena Gabriela Barrantes, David H. Ackley, Stephanie Forrest, Trek S. Palmer,
Darko Stefanovic and Dino Dai Zovi, Randomized instruction set emulation to dis-
rupt binary code injection attacks, 10th ACM International Conference on Com-
puter and Communications Security (CCS), pp. 272 - 280. October 2003.
2. Sandeep Bhatkar, Daniel C. DuVarney, and R. Sekar, Address Obfuscation: An Eﬃ-
cient Approach to Combat a Broad Range of Memory Error Exploits, 12th USENIX
Security Symposium, 2003.
3. F. Buchholz, T. Daniels, J. Early, R. Gopalakrishna, R. Gorman, B. Kuperman,
S. Nystrom, A. Schroll, and A. Smith, Digging For Worms, Fishing For Answers,
ACSAC 2002.
4. Sung-Bae Cho, and Sang-Jun Han, Two Sophisticated Techniques to Improve
HMM-Based Intrusion Detection Systems, RAID 2003.
On Random-Inspection-Based Intrusion Detection
183
5. Scott Coull, Joel Branch, Boleslaw K. Szymanski, and Eric Breimer, Intrusion
Detection: A Bioinformatics Approach, ACSAC 2003.
6. Crispin Cowan, Calton Pu, and Heather Hinton, Death, Taxes, and Imperfect Soft-
ware: Surviving the Inevitable, theNew Security Paradigms Workshop 1998
7. Dorothy E. Denning, An intrusion detection model, IEEE Transactions on Software
Engineering, 13-2:222, Feb 1987.
8. Henry H. Feng, Oleg Kolesnikov, Prahlad Fogla, Wenke Lee, and Weibo Gong,
Anomaly Detection Using Call Stack Information, IEEE Symposium on Security
and Privacy, 2003.
9. S. Forrest, S. Hofmeyr, A. Somayaji, and T. Longstaﬀ, A sense of self for UNIX
processes, IEEE Symposium on Security and Privacy, 1996.
10. S. Forrest, A. Somayaji, and D. Ackley, Building Diverse Computer Systems, Pro-
ceeding: 6 workshop on Hot Topics in Operating Systems, IEEE Computer Society
Press, pp. 67-72.
11. Tal Gar nkel, Traps and pitfalls: Practical problems in in system call interposition
based security tools, Proc. Network and Distributed Systems Security Symposium,
February 2003.
12. Anup K. Ghosh, Christoph Michael, and Michael Schatz, A Real-Time Intrusion
Detection System Based on Learning Program Behavior, RAID 2000.
13. Jonathon T. Giﬃn, Somesh Jha, and Barton P. Miller, Detecting manipulated re-
mote call streams, 11th USENIX Security Symposium, 2002.
14. Jonathon T. Giﬃn, Somesh Jha, and Barton P. Miller, Eﬃcient context-sensitive
intrusion detection, 11th Network and Distributed System Security Symposium,
2004.
15. S. A. Hofmeyr, A. Somayaji, and S. Forrest, Intrusion detection using sequences of
system calls, Journal of Computer Security, Vol. 6, 1998, pp. 151–180.
16. Ruiqi Hu and Aloysius K. Mok, Detecting Unknown Massive Mailing Viruses Using
Proactive Methods, RAID 2004.
17. A. Jones and S. Li, Temporal Signatures of Intrusion Detection, ACSAC 2001.
18. Gaurav S. Kc, Angelos D. Keromytis, and Vassilis Prevelakis. Countering Code-
Injection Attacks With Instruction-Set Randomization. 10th ACM International
Conference on Computer and Communications Security (CCS), pp. 272 - 280.
October 2003.
19. V. Kiriansky, D. Bruening, and S. Amarasinghe, Secure execution via program
shepherding, 11th USENIX Security Symposium, 2002.
20. C. Ko, Logic Induction of Valid Behavior Speciﬁcations for Intrusion Detection,
IEEE Symposium on Security and Privacy, 2000.
21. C. Kruegel, D. Mutz, F. Valeur ,and G. Vigna, On the Detection of Anomalous Sys-
tem Call Arguments, 8th European Symposium on Research in Computer Security
(ESORICS), 2003.
22. Christopher Kruegel, Darren Mutz, William Robertson, and Fredrik Valeur,
Bayesian Event Classiﬁcation for Intrusion Detection, ACSAC 2003.
23. Lap Chung Lam and Tzi-cker Chiueh, Automatic Extraction of Accurate
Application-Speciﬁc Sandboxing Policy, RAID 2004.
24. T. Lane and C. Brodley, Temporal Sequence Learning and Data Reduction for
Anomaly Detection, ACM Trans. Info. and Sys. Security, 1999.
25. W. Lee and S. Stolfo, Data Mining Approaches for Intrusion Detection, 7th
USENIX Security Symposium, 1998.
26. p62 wbo PI:EMAIL, Jamie Butler, and p62 wbo PI:EMAIL,
Bypassing 3rd Party Windows Buﬀer Overﬂow Protection, Phrack, Issue #62, of
July 10, 2004
184
S.P. Chung and A.K. Mok
27. R. Sekar, M. Bendre, D. Dhurjati, and P. Bollineni, A Fast Automaton-based
Method for Detecting Anomalous Program Behaviors, Proceedings of the 2001 IEEE
Symposium on Security and Privacy.
28. R. Sekar, A. Gupta, J. Frullo, T. Shanbhag, A. Tiwari, H. Yang, and S. Zhou, Spec-
iﬁcation based anomaly detection: a new approach for detecting network intrusions,
ACM Computer and Communication Security Conference, 2002.
29. skape, Understanding Windows Shellcode,
http://www.hick.org/code/skape/papers/win32-shellcode.pdf
30. A. Somayaji, S. Forrest, Automated Response Using System-Call Delays, 9th Usenix
Security Symposium, 2000.
31. Kymie M. C. Tan, and Roy A. Maxion, “Why 6?” Deﬁning the Operational Limits
of Stide, an Anomaly-Based Intrusion Detector, IEEE Symposium on Security and
Privacy 2002.
32. Kymie M. C. Tan, Kevin S. Killourhy, and Roy A. Maxion, Undermining an
Anomaly-Based Intrusion Detection System Using Common Exploits, RAID 2002
33. Thomas Toth, Christopher Krugel, Accurate Buﬀer Overﬂow Detection via Ab-
stract Payload Execution, RAID 2002.
34. P. Uppuluri and R. Sekar, Experiences with Speciﬁcation-Based Intrusion Detec-
tion, RAID 2001
35. D. Wagner and P. Soto, Mimicry Attacks on Host-Based Intrusion Detection Sys-
tems, ACM Conference on Computer and Communications Security, 2002.
36. D. Wagner and D. Dean, Intrusion Detection via Static Analysis, IEEE Symposium
on Security and Privacy, 2001.
37. Christina Warrender, Stephanie Forrest, and Barak Pearlmutter, Detecting intru-
sions using system calls: alternative data models, IEEE Symposium on Security
and Privacy, 1999.
38. A. Wespi, M. Dacier and H. Debar, Intrusion detection using variable-length audit
39. Matthew M. Williamson, Throttling Viruses: Restricting propagation to defeat ma-
trail patterns, RAID, 2000.
licious mobile code, ACSAC 2002.
40. Haizhi Xu, Wenliang Du and Steve J. Chapin, Context Sensitive Anomaly Moni-
toring of Process Control Flow to Detect Mimicry Attacks and Impossible Paths,
RAID 2004.