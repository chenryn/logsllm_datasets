# 通过混淆命名空间绕过DOMPurify实现XSS
|
##### 译文声明
本文是翻译文章，文章原作者 MICHAŁ BENTKOWSKI，文章来源：securitum
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
## 0x00 前言
在本文中，我将与大家分享如何绕过[DOMPurify](https://github.com/cure53/DOMPurify/)。DOMPurify是一款常用的HTML过滤库，可以处理（来自用户的）不受信任的HTML片段，删除可能导致XSS的所有元素及属性。
简而言之，最终的绕过方法如下：
以上代码没有任何冗余元素。为了理解具体的绕过原理，我们需要了解一下HTML规范中的一些有趣功能。
## 0x01 DOMPurify用法
我们先从基础开始，看一下DOMPurify的通常用法。假设我们在`htmlMarkup`中包含一段不可信的HTML，并且需要将其赋值给某个`div`，此时我们可以使用DOMPurify来过滤这段内容，赋值给`div`：
    div.innerHTML = DOMPurify.sanitize(htmlMarkup)
在解析、序列化HTML以及处理DOM树时，这行代码背后实际上会执行如下操作：
1、`htmlMarkup`被解析成DOM树；
2、DOMPurify过滤DOM树（简而言之，这个过程中DOMPurify会遍历DOM树中的所有元素以及属性，删除不在允许列表中的所有节点）；
3、DOM树被序列化回HTML内容；
4、赋值给`innerHTML`后，浏览器会再次解析HTML内容；
5、经过解析的DOM树会被附加到文档的DOM树中。
来看个简单例子。假设我们初始的内容的`AB`。在第1个步骤中，该片段会被解析成如下树结构：
随后，经过DOMPurify过滤后，得到如下DOM树：
序列化后的结果为：
    AB
这也是`DOMPurify.sanitize`的返回结果。随后这段内容会由浏览器再次解析，赋值给`innerHTML`：
DOM树与DOMPurify处理的DOM树一致，随后会被附加到目标文档中。
因此，以上过程可以按顺序简单总结成：解析->序列化->解析。大家从直觉上会认为DOM树经过序列化、再次解析后，应该会返回初始的DOM树，但事实并非如此。在HTML规范中，关于序列化HTML片段方面有如下警告信息：
>
> 这种算法（序列化HTML）的输出结果如果交给HTML解析器进行解析时，则可能不会返回原始的树结构。HTML解析器本身也有可能输出经过序列化、重解析操作后无法复原的树结构，虽然这种情况下通常不符合要求。
这里要划重点的是，这种序列化、重新解析的往复操作并不一定能返回原始的DOM树（这也是造成mutation
XSS（突变型XSS）的根源）。通常情况下，这类情况由某些解析器、序列化器的错误而导致，但有两种情况比较特殊，符合上述警告信息所描述的场景。
## 0x02 嵌套FORM元素
其中有种场景与FORM元素有关。这是HTML中非常特殊的一个元素，该元素无法嵌套到自身中。在HTML规范中，[明确说明](https://html.spec.whatwg.org/#the-form-element)FORM元素不可以是某个FORM元素的后继：
我们可以使用如下标记语言，通过各种浏览器来验证：
    INSIDE_FORM1
    INSIDE_FORM2
这个片段会生成如下DOM树：
第2个`form`在DOM树中会被完全忽略，就像从来没存在过一样。
接下来是比较有趣的部分。如果我们继续阅读HTML规范，会发现其中给出了一个示例，通过较不规范以及错误嵌套的标记成功创建了一个嵌套式表单。如下所示（直接摘抄自规范文档）：
结果会生成如下DOM树，其中包含一个嵌套式表单元素：
这并不是特定浏览器的bug，直接来自于HTML规范，在解析HTML的算法中也有描述。通常的原理为：
1、当我们打开``标签时，浏览器需要使用表单元素指针（标准中就是这么称呼）来记录该标签已被打开。如果该指针不为`null`，那么`form`元素就无法被创建。
2、当我们结束``标签时，表单元素指针始终会设置为`null`。
因此，回到这个片段：
首先，表单元素指针会指向`id="outer"`的元素，然后开始解析`div`，碰到``结束标签后，表单元素指针会被设置为`null`。由于指针为`null`，因此`id="inner"`的下一个表单可以被创建。由于目前我们位于`div`内，因此可以成功创建一个嵌套式`form`。
现在，如果我们尝试序列化生成的DOM树，会得到如下标记语言：
需要注意的是，这次其中并没有包含任何错误嵌套的标记。当这个片段再次被解析时，会创建如下DOM树：
以上可以表明，经过序列化、重解析后，我们并不一定能返回原始的DOM树。更有趣的是，这是符合标准的一种突变情况。
当我发现到这一点后，意识到有可能滥用这种特性来绕过HTML过滤器。经过长时间思索后，我偶然发现了在HTML规范中存在另一个异常点。在继续讨论这个问题前，我们先来聊聊HTML规范中我最喜欢的一个潘多拉魔盒：外部内容（foreign
content）。
## 0x03 外部内容
外部内容就像一把瑞士军刀，可以用来破坏解析器及过滤器。我之前曾在[DOMPurify的绕过方式](https://research.securitum.com/dompurify-bypass-using-mxss/)以及[Ruby过滤库的绕过方式](https://research.securitum.com/html-sanitization-bypass-in-ruby-sanitize-5-2-1/)中用过这种方法。
HTML解析器可以使用3个命名空间元素来创建DOM树：
  * HTML命名空间（[http://www.w3.org/1999/xhtml）](http://www.w3.org/1999/xhtml%EF%BC%89)