 7 ; function prologue. 
 8 ; save the RA and FP in the stack: 
 9 .text:00000000  
addiu  
$sp, -0x20 
10 .text:00000004  
sw   
$ra, 0x20+var_4($sp) 
11 .text:00000008  
sw   
$fp, 0x20+var_8($sp) 
12 ; set the FP (stack frame pointer): 
13 .text:0000000C  
move   
$fp, $sp 
14 ; set the GP: 
15 .text:00000010  
la   
$gp, __gnu_local_gp 
16 .text:00000018  
sw   
$gp, 0x20+var_10($sp) 
17 ; load the address of the text string: 
18 .text:0000001C  
lui   
$v0, (aHelloWorld >> 16) # "Hello, world!" 
19 .text:00000020  
addiu  
$a0, $v0, (aHelloWorld & 0xFFFF) # "Hello, world!" 
20 ; load the address of puts() using the GP: 
21 .text:00000024  
lw   
$v0, (puts & 0xFFFF)($gp) 
22 .text:00000028  
or   
$at, $zero ; NOP 
23 ; call puts(): 
24 .text:0000002C  
move   
$t9, $v0 
25 .text:00000030  
jalr   
$t9 
26 .text:00000034  
or   
$at, $zero ; NOP 
27 ; restore the GP from local stack: 
28 .text:00000038  
lw   
$gp, 0x20+var_10($fp) 
29 ; set register $2 ($V0) to zero: 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
第 3 章  Hello，world！ 
23 
30 .text:0000003C  
move   
$v0, $zero 
31 ; function epilogue. 
32 ; restore the SP: 
33 .text:00000040  
move   
$sp, $fp 
34 ; restore the RA: 
35 .text:00000044  
lw   
$ra, 0x20+var_4($sp) 
36 ; restore the FP: 
37 .text:00000048  
lw   
$fp, 0x20+var_8($sp) 
38 .text:0000004C  
addiu  
$sp, 0x20 
39 ; jump to the RA: 
40 .text:00000050  
jr   
$ra 
41 .text:00000054  
or   
$at, $zero ; NOP 
在程序的第 15 行出现了一个比较有意思的现象——IDA 识别出了 LUI/ADDIU 指令对，把它们显示为
单条的伪指令 LA(Load address)。那条伪指令占用了 8 个字节！这种伪指令（即“宏”）并非真正的 MIPS
指令。通过这种名称替换,IDA 帮助我们这对指令的作用望文思义。 
NOP 的显示方法也构成了它的另外一种特点。因为 IDA 并不会自动地把实际指令匹配为 NOP 指令，
所以位于第 22 行、第 26 行、第 41 行的指令都是“OR $AT, $ZERO”。表面上看，它将保留寄存器$AT 的
值与 0 进行或运算。但是从本质上讲，这就是发送给 CPU 的 NOP 指令。MIPS 和其他的一些硬件平台的
指令集都没有单独的 NOP 指令。 
3.5.4 栈帧 
本例使用寄存器来传递文本字符串的地址。但是它同时设置了局部栈，这是为什么呢？由于程序在调
用 printf()函数的时候由于程序必须保存 RA 寄存器的值和 GP 的值，故而此处出现了数据栈。如果此函数
是叶函数，它有可能不会出现函数的序言和尾声，有关内容请参见本书的 2.3 节。 
3.5.5 Optimizing GCC: GDB 的分析方法 
指令清单 3.22  GDB 的操作流程 
root@debian-mips:~# gcc hw.c -O3 -o hw 
root@debian-mips:~# gdb hw 
GNU gdb (GDB) 7.0.1-debian 
Copyright (C) 2009 Free Software Foundation, Inc. 
License GPLv3+: GNU GPL version 3 or later  
This is free software: you are free to change and redistribute it. 
There is NO WARRANTY, to the extent permitted by law.  Type "show copying" 
and "show warranty" for details. 
This GDB was configured as "mips-linux-gnu". 
For bug reporting instructions, please see: 
... 
Reading symbols from /root/hw...(no debugging symbols found)...done. 
(gdb) b main 
Breakpoint 1 at 0x400654 
(gdb) run 
Starting program: /root/hw 
Breakpoint 1, 0x00400654 in main () 
(gdb) set step-mode on 
(gdb) disas 
Dump of assembler code for function main: 
0x00400640 :     lui      gp,0x42 
0x00400644 :     addiu   sp,sp,-32 
0x00400648 :     addiu   gp,gp,-30624 
0x0040064C :    sw      ra,28(sp) 
0x00400650 :    sw      gp,16(sp) 
0x00400654 :    lw      t9,-32716(gp) 
0x00400658 :    lui     a0,0x40 
0x0040065c :    jalr    t9 
0x00400660 :    addiu   a0,a0,2080 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
24 
逆向工程权威指南（上册） 
0x00400664 :    lw      ra,28(sp) 
0x00400668 :    move    v0,zero 
0x0040066c :    jr      ra 
0x00400670 :    addiu   sp,sp,32 
End of assembler dump. 
(gdb) s 
0x00400658 in main () 
(gdb) s 
0x0040065c in main () 
(gdb) s 
0x2ab2de60 in printf () from /lib/libc.so.6 
(gdb) x/s $a0 
0x400820:          "hello, world" 
(gdb) 
3.6 总结 
x64 和 x86 指令的主要区别体现在指针上，前者使用 64 位指针而后者使用 32 位指针。近年来，内存
的价格在不断降低，而 CPU 的计算能力也在不断增强，当计算机的内存增加到一定程度时，32 位指针就
无法满足寻址的需要了，所以指针也随之演变为 64 位指针。 
3.7  练习题  
3.7.1  题目 1 
请描述下述 32 位函数的功能。 
main: 
     push 0xFFFFFFFF 
     call MessageBeep 
     xor  eax,eax 
     retn 
3.7.2  题目 2 
请描述 Linux 函数的功能，这里使用了 AT&T 汇编语言语法。 
main: 
     pushq   %rbp 
     movq    %rsp, %rbp 
     mov1    %2, %edi 
     call    sleep 
     popq    %rbp 
     ret 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
第
第 44 章
章    函
函数
数序
序言
言和
和函
函数
数尾
尾声
声  
函数序言（function prologue）是函数在启动的时候运行的一系列指令。其汇编指令大致如下： 
push ebp 
mov 
ebp, esp 
sub 
esp, X 
这些指令的功能是：在栈里保存 EBP 寄存器的内容、将 ESP 的值复制到 EBP 寄存器，然后修改栈的
高度，以便为本函数的局部变量申请存储空间。 
在函数执行期间，EBP 寄存器不受函数运行的影响它是函数访问局部变量和函数参数的基准值。虽然
我们也可便中 ESP 寄存器存储局部变量和运行参数，但是 ESP 寄存器的值总是会发生变化，使用起来并不
方便。 
函数在退出时，要做启动过程的反操作，释放栈中申请的内存，还原 EBP 寄存器的值，将代码控制权
还原给调用者函数(callee)。 
mov  esp, ebp 
pop  ebp 
ret  0 
借助函数序言和函数尾声的有关特征，我们可以在汇编语言里识别各个函数。 
递归调用 
函数序言和尾声都会调整数据栈受硬件 IO 性能影响，所有递归函数的性能都不太理想。 
详细内容请参见本书的 36.3 节。 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
第
第 55 章
章    栈
栈  
栈是计算机科学里最重要且最基础的数据结构之一。
①
虽然x86/x64 的栈已经很难理解了，但是ARM的栈却更为复杂。ARM的栈分为递增栈和递减栈。递减
栈（descending stack）的首地址是栈的最高地址，栈向低地址增长，栈指针的值随栈的增长而减少，如
STMFD/LDMFD、STMED/LDMED等指令都是递减栈的操作指令。而ARM的递增栈（ascending stack）的
首地址则占用栈的最低地址，栈向高地址增长，栈指针的值随栈的增长而增加，如STMFA/LMDFA、
STMEA/LDMEA等指令都是递增栈的操作指令。
从技术上说，栈就是 CPU 寄存器里的某个指针所指向的一片内存区域。这里所说的“某个指针”通常
位于 x86/x64 平台的 ESP 寄存器/RSP 寄存器，以及 ARM 平台的 SP 寄存器。 
操作栈的最常见的指令是 PUSH 和 POP，在 x86 和 ARM Thumb 模式的指令集里都有这两条指令。PUSH
指令会对 ESP/RSP/SP 寄存器的值进行减法运算，使之减去 4（32 位）或 8（64 位），然后将操作数写到上
述寄存器里的指针所指向的内存中。 
POP 指令是 PUSH 指令的逆操作：它先从栈指针（Stack Pointer，上面三个寄存器之一）指向的内存中
读取数据，用以备用（通常是写到其他寄存器里），然后再将栈指针的数值加上 4 或 8。 
在分配栈的空间之后，栈指针，即 Stack Pointer 所指向的地址是栈的底部。PUSH 将减少栈指针的数
值，而 POP 会增加它的数值。栈的“底”实际上使用的是整个栈的最低地址，即是整个栈的启始内存地址。
虽然听起来很奇怪，但是实际上确实如此。 
②
5.1  为什么栈会逆增长 
多数人想象中的“增长”，是栈从低地址位向高地址位增长，似乎这样才符合自然规律。然而研究过栈
的人知道，多数的栈是逆增长的，它会从高地址向低地址增长。 
这多数还得归功于历史原因。当计算机尚未小型化的时候，它还有数个房间那么大。在那个时候，内
存就分为两个部分，即“堆/heap”和“栈/stack”。当然，在程序执行过程中，堆和栈到底会增长到什么地
步并不好说，所以人们干脆把它们分开： 
有兴趣的读者可以查阅参考文献 RT74，其中有这样一段话： 
程序镜像（进程）在逻辑上分为 3 个段。从虚拟地址空间的 0 地址位开始，第一个段是文本段（也
称为代码段）。文本段在执行过程中不可写，即使一个程序被执行多次，它也必须共享 1 份文本段。
① 请参见 http://en.wikipedia.org/wiki/Call_stack。 
② 这些指令所对应的英文全称，分别是 Store Multiple Full Descending、Load Multiple Full Descending、Store Multiple Empty 
Descending、Load Multiple Empty Descending 、Store Multiple Full Ascending 、Load Multiple Full Ascending 、Store Multiple Empty 
Ascending、 Load Multiple Empty Ascending。其中的 Full/Empty 的区别在于：如果指针指向的地址是最新操作的值，那么它就
是 Full stack；而指针指向的地址没有值、是下一个值将写到的地址，那么这个栈就是 Empty stack。 
堆的起点 
堆 
栈 
栈的起点 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
第 5 章 栈 
27 
在程序虚拟空间中，文本段 8k bytes 边界之上，是不共享的、可写的数据段。程序可以通过调用系统
函数调整其数据段的大小。栈启始于虚拟地址空间的最高地址，它应随着硬件栈指针的变化而自动地
向下增长。 
这就好比用同一个笔记本给两门课程做笔记：第一门的笔记可以按照第一页往最后一页的顺序写；然而
在做第二门的笔记时，笔记本要反过来用，也就是要按照从最后一页往第一页的顺序写笔记。至于笔记本
什么时候会用完，那就要看笔记本有多厚了。 
5.2 栈的用途 
5.2.1 保存函数结束时的返回地址 
x86 
当程序使用 call 指令调用其他函数时，call 指令结束后的返回地址将被保存在栈里；在 call 所调用的
函数结束之后，程序将执行无条件跳转指令，跳转到这个返回地址。 
CALL 指令等价于“PUSH 返回地址”和“JMP 函数地址”的指令对。 
被调用函数里的 RET 指令，会从栈中读取返回地址，然后跳转到这个地址，就相当于“POP 返回地
址”＋“JMP 返回地址”指令。 
栈是有限的，溢出它很容易。直接使用无限递归，栈就会满： 
void f() 
{ 
          f(); 
}; 
如果使用 MSVC 2008 编译上面的问题程序，将会得到报告： 
c:\tmp6>cl ss.cpp /Fass.asm 
Microsoft (R) 32-bit C/C++ Optimizing Compiler Version 15.00.21022.08 for 80x86 
Copyright (C) Microsoft Corporation.  All rights reserved. 
ss.cpp 
c:\tmp6\ss.cpp(4) : warning C4717:’f’ : recursive on all control paths. Function will cause runtime stack overflow 
但是它还是会老老实实地生成汇编文件： 
?f@@YAXXZ PROC                                ; f 
; File c:\tmp6\ss.cpp 
; Line 2 
          push 
ebp 
          mov      ebp, esp 
; Line 3 
         call     ?f@@YAXXZ                   ; f 
; Line 4 
         pop  
ebp 
         ret      0 
?f@@YAXXZ ENDP                               
; f 
有趣的是，如果打开优化选项“/Ox”，生成的程序反而不会出现栈溢出的问题，而且还会运行得很“好”： 
?f@@YAXXZ PROC                               
; f 
; File c:\tmp6\ss.cpp 
; Line 2 
$LL3@f: 
; Line 3 
          jmp     SHORT $LL3@f 
?f@@YAXXZ ENDP                               
; f 
异步社区会员 dearfuture(15918834820) 专享 尊重版权
28 
逆向工程权威指南（上册） 
无论是否开启优化选项，GCC 4.4.1 生成的代码都和 MSVC 生成的代码相似，只是 GCC 不会发布任何警告。 
ARM 
ARM 程序也使用栈保存返回地址，只是略有不同。在 3.4 节中，我们看到“Hello, World!”程序的返
回地址保存在 LR (link register)寄存器里。但是，如果程序还会继续调用其他函数，就需要在调用函数之前
保存 LR 寄存器的值。通常，函数会在启动过程中（序言处）保存 LR 寄存器的值。我们通常在函数序言
处看到“PUSH R4-R7，LR”，并在尾声处看到“POP R4-R7，PC”。这些指令会对函数自身将要用到的寄
存器进行保护，把它们的值存放在栈中——当然，这其中也包括 LR 寄存器。 
如果一个函数不调用其他函数，它就像树上的枝杈末端的叶子那样。这种函数就叫作“叶函数（leaf 
function）”
①。叶函数的特点是，它不必保存LR寄存器的值。如果叶函数的代码短到用不到几个寄存器，
那么它也可能根本不会使用数据栈。所以，调用叶函数的时候确实可能不会涉及栈操作。这种情况下，因
为这种代码不在外部内存RAM进行与栈有关的操作，所以它的运行速度有可能超过x86 系统
②
5.2.2  参数传递 
。在没有分
配栈或者不可能用栈的时候，这类函数就会显现出“寸有所长”的优势。 
本书介绍了很多的叶函数。请参见 8.3.2 节、8.3.3 节、15.2 节、15.4 节、17.3 节、19.5.4 节、19.17 节、19.33
节中演示的程序。 
在x86 平台的程序中，最常用的参数传递约定是cdecl
③
ESP 
。以cdecl方式处理参数，其上下文大体是这个样子： 
push arg3 
push arg2 
push arg1 
call f 
add esp, 12 4*3=12 
被调用方函数（Callee functions）通过栈指针获取其所需的参数。 
在运行 f()函数之前，传递给它的参数将以以下格式存储在内存里。 