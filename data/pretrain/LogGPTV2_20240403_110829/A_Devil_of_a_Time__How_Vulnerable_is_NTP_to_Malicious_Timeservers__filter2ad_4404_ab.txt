time by x
(seconds/minutes/hours/days/months/years) requires roughly x
3
time.
To accomplish this, the attacker must have sufﬁcient pres-
ence in the set of timeservers the client syncs with. Such
attacks can be launched, e.g., by a man-in-the-middle attacker
capable of intercepting and tampering with NTP messages
between the client and (a signiﬁcant subset of the) timeservers,
or by an attacker in direct control of (a subset of) the NTP
timeservers themselves.
To attack...
TLS Certs
HSTS (see [44])
DNSSEC
DNS Caches
Change Time by...
To attack...
change time by...
years
a year
months
days
Routing (RPKI)
Bitcoin (see [4])
API authentication
Kerberos
days
hours
minutes
minutes
Table II: Impact of timeshifting attacks on different applica-
tions (taken from [24])
As shown in [24], time shifting attacks on NTP can serve as
building blocks for compromising many applications/services
of interest. Table II, taken from [24], presents several such
applications and the extent to which time at an NTP client
should be shifted needed to harm them.
C. NTP Security
To combat time-shifting (and other) attacks, NTP practi-
tioners and researchers have investigated two main approaches:
Authenticating NTP communications. While NTP supports
cryptographic authentication [7], [36], in practice NTP trafﬁc
is very rarely authenticated for various reasons [11], [34], [40].
More importantly (1) even if NTP trafﬁc is encrypted, an
3
attacker capable of delaying/dropping trafﬁc can still inﬂuence
time at the NTP client, and (2) encryption clearly does not
defend against an attacker in control of the NTP timeservers
themselves.
Client-side solutions: the Chronos NTP client. The recently
introduced Chronos NTP client [6], which is currently being
promoted at the IETF [42], reﬂects a different approach to NTP
security. Chronos distributes time queries across a large num-
ber of NTP timeservers and employs a theory-informed ap-
proximate agreement algorithm to discard outlying responses
and to update the local clock. Speciﬁcally, in Chronos, a set
of servers consisting of hundreds of timeservers is assigned to
a client and the IP addresses of these timeservers are stored
at the client. The client periodically queries a small subset
(say 10 − 15) of these servers, chosen uniformly at random.
By removing from consideration the lowest and highest time
samples gathered from the queried servers, and setting the local
time to be the average of the surviving time samples, Chronos
provably attains high time accuracy so long as the attacker
cannot inﬂuence time at “too many” of the servers assigned to
the client. We describe Chronos in more detail in Appendix B.
Intuitively (and as formalized and proven in [6]), by relying
on many timeservers for synchronization and employing a
secure methodology for computing local time from server-
reported time samples, Chronos sets a higher bar for the
attacker, forcing it
to compromise a large fraction of the
timeservers to successfully shift time at the client. However,
as our results below shall demonstrate, even if relying on
many timeservers for synchronization, unless these servers are
carefully chosen, the attacker can gain (direct or indirect)
control of a large fraction of these servers, nullifying the
security beneﬁts of such client-side solutions. We discuss our
scheme for secure assignment of timeservers to clients in
Section VI.
III. TWO ATTACK STRATEGIES
We next present a high-level overview of the two attack
strategies considered: (1) taking control of existing timeservers
and (2) injecting new timeservers into the pool. We present
empirical analyses of the described attacks in Sections III-A
and III-B, respectively.
A. Attack I: Utilizing Existing Timeservers
Recall (see Section II) that NTP timeservers in different
strata synchronize with timeservers in lower strata. This im-
plies that an attacker in control of an NTP timeserver might
potentially be able not only to inﬂuence time at a client
directly by misreporting that timeserver’s clock readings, but
also to inﬂuence time at the client indirectly by shifting time
at other timeservers (in higher strata) the client queries. We
next explain how such attacks can be launched.
Goals of the attack. We consider an opportunistic attacker
whose goal
time at many clients in a certain
geographical region R (country or even continent) so as
to harm the performance or security of a certain Internet
application/service. The term “opportunistic” here is used to
indicate that the attacker does not target speciﬁc clients, but
rather means to wreak havoc at scale. (We will later explain
is to shift
4
how targeted attacks can be facilitated by injecting new servers
into the pool.)
Threat model. The attacker is in control of a subset A
of the pool’s timeservers in region R. This encompasses a
variety of scenarios, including the following: (1) the attacker
is an organization that
legitimately hosts NTP timeservers
with which other servers synchronize, (2) the attacker is
capable of compromising a subset of the servers (e.g., by
exploiting software vulnerabilities), and (3) the attacker can
attract trafﬁc from NTP clients destined for subset A via off-
path attacks on DNS or BGP (like DNS cache poisoning or
IP preﬁx hijacking), taking advantage of the fact that NTP
communications are not authenticated to masquerade as the
timeservers in A.
The attack. By leveraging its control over timeserver subset
A, the attacker can, from some point in time onwards, respond
with inaccurate times to all queries issued to its servers by
higher strata timeservers, for the purpose of shifting time at
these servers and so, indirectly, at all clients in the region that
sync with them. We next discuss some important speciﬁcs.
•
•
is,
timeservers in region R (that
The attacker-controlled servers must be highly
inﬂuential. Clearly, if the attacker has direct control
over all
the set
A consists of all
timeservers in R), or even over
a large fraction of these, it can succeed in shifting
time at many clients across that region. Our objective,
however, is to demonstrate that gaining control of a
fairly small subset of timeservers in the region is suf-
ﬁcient. However, this requires the attacker-controlled
timeservers to be highly inﬂuential in the sense that
“many” higher strata servers crucially rely on the
attacker-controlled servers for time synchronization.
As we shall show in Section IV, small yet inﬂuential
subsets of timeservers indeed exist in many regions.
In particular, control of merely 10s of timeservers
in Europe or the US (out of thousands, and many
hundreds, respectively) is sufﬁcient for shifting time
at continent/country scale. Moreover, the methodology
employed in our empirical analyses can be leveraged
by the attacker to identify such subsets of timeservers.
• How to shift time at higher strata servers? Higher-
strata servers that synchronize with attacker-controlled
servers do so by executing NTP’s client-side protocol
for synchronizing with timeservers (see Section II).
Hence, timeshifting attacks such as those discussed in
Section II-B can be executed by the attacker-controlled
servers to inﬂuence time at other servers.
The pool’s monitor limits the harm that can be
inﬂicted by attacker. Recall that the pool’s monitor
periodically queries timeservers in the pool and, if the
gap between the responses of some timeserver and
its local time exceeds a certain threshold, the monitor
will remove that server from the pool. Timeservers
under the attacker’s direct control can evade being
spotted by the monitor simply by responding with
correct times when queried by the monitor, while con-
tinuing to report false times when queried by others.
However, this is not so for higher-strata timeservers
whose local times the attacker indirectly inﬂuences;
these will respond with erroneous times when query
by all, including the monitor. Thus, after some time
(around 12 minutes or less [20], attacker-inﬂuenced
timeservers will be removed from the pool. However,
our empirical analyses show that many clients that
synchronize with some server will continue to do so
for 10s of minutes, and even hours, after that server’s
removal from the pool. This enables the attacker to in-
directly shift time at these clients by continuing to shift
time at a timeserver after its removal. While this is
sufﬁcient for attacking some applications/mechanisms
of interest (e.g., BitCoin, API authentication, and
Kerberos), other applications (e.g., TLS certs, HSTS,
DNS caches, RPKI) [24], which require shifting time
at clients by days, weeks, or more, seem impossible
to attack using this strategy.
Ascertaining the feasibility of the attack. To demonstrate
the feasibility of this attack for the current implementations of
NTP client [2] and server software [20], as well as the current
pool monitor [20] implementation, we tested the attack on local
installations of NTP servers, the pool, and the monitor. We set
up four VMs, emulating an attacker-controlled server SA, an
(honest) higher-stratum server SH that syncs with it, the pool
P , and the pool monitor M. We then executed an attack by SA
on SH in which SA incrementally increases time at SH by 16
minutes every 5 minutes, using the attack technique presented
in [24]. When queried by M, SA was conﬁgured to respond
with its actual local time (so as to evade being detected by
the monitor). We veriﬁed that this resulted, as expected, in SA
succeeding to shift time at SH, and in SH being removed from
the pool P by M (and SA not being removed). We repeated
the same experiment, only this time both SA and SH were
registered into the actual NTP server pool, to verify that the
behaviors of the actual pool and monitor (in terms of server
removal) are as expected.
B. Attack II: Injecting New Timeservers
Entering a new timeserver into the timeserver pool is easy;
the attacker need only register as a timeserver and provide
an IP address and an e-mail address. The legitimacy of a
registered timeserver depends only on its availability and time
accuracy, which are monitored by the pool and are required
to be above very easy to pass thresholds [14], [20]. Indeed, in
our experiments, we were able to successfully register 10s of
new timeservers into the pool at various regions. In addition,
she/he entering the timeserver into the pool, and operating that
timeserver, is trusted to provide truthful information regarding
the server stratum, and so an attacker can always specify the
server stratum for its injected timeservers as 1. Somewhat
surprisingly, however, as we shall show in Section V, we
ﬁnd that this type of “lie” does not really aid the attacker.
We identify, however, a much more effective strategy for the
attacker: manipulating the netspeed parameter.
The netspeed parameter. The speciﬁed “netspeed” of a
timeserver in the NTP pool is correlated with the volume
of NTP clients directed to the timeserver by the pool, with
higher netspeed yielding higher probability that the timeserver
be assigned to a client by the pool. As shall be discussed in
Section V, by setting the netspeed for its registered server to
be the maximum possible value, the attacker can increase the
chances that its injected server is assigned to any client by
orders of magnitude. This can enable the attacker to attain
critical mass in some regions with relatively few injected
servers.
Goals of the attack. We consider both opportunistic attackers,
who aim to shift time at many clients, as in Section IV, and
strategic attackers that wish to shift time at speciﬁc clients.
Threat model. As in Section III-A, the attacker is in direct
control of a subset A of the pool’s timeservers in region R,
which were all injected into the pool by the attacker. Note that,
unlike the attack in Section V, the attacker does not attempt to
shift time at other timeservers. Instead, the attacker’s mission
is to shift local time at clients by directly interacting with these
clients.
The attack. The attacker ﬁrst creates new timeservers and reg-
isters these in the pool. Since the pool geolocates timeservers
to assign them to speciﬁc zones, to impact time at a client
located in a certain zone, the attacker’s injected timeservers
must be in that region. This is simple to do by leveraging
public clouds. In our experiments, for instance, Amazon AWS
was used to set up servers at multiple locations and register
these into the pool. When registering a timeserver, the attacker
conﬁgures the netspeed to the maximum value. Importantly,
there is no limit on the number of timeservers the attacker can
inject into the pool and so the attacker can arbitrarily increase
the probability that servers are assigned to a client in a certain
region by simply adding more servers in that region to the
pool. To determine how many servers should be added to the
pool, the attacker can employ our methodology in Section V.
Since the attacker is in direct control of the timeservers, it can
always report accurate times to the monitor (to prevent the
removal of its timeservers from the pool). In addition, it can
report accurate times to some clients and inaccurate times to
others, facilitating targeted attacks against speciﬁc clients. To
stealthily shift time at a client, the attacker can employ the
attack technique from [6], [24] to repeatedly increase/decrease
time by 16 minutes. Observe that since the monitor cannot
detect misdeeds by the attacker’s servers, the attack can persist
for as long as needed. Thus, unlike the attack in Section III-A,
this class of attacks enables arbitrary time shifts and so impacts
many more applications/mechanisms [24].
Ascertaining the feasibility of the attack. We report
in
Section V on our experimentation with injecting new servers
into the actual server pool and interacting with real NTP clients
to which our injected timeservers have been assigned by the
pool.
IV. EMPIRICAL ANALYSIS OF ATTACKS EXPLOITING
INTER-SERVER DEPENDENCIES
We empirically quantify to what extent an attacker that
gains control of existing NTP timeservers can inﬂuence time
in its region. However, as discussed in Section III, the answer