the  signed  root,  which  can  be  easier  detected.  Finally, 
longer  and  therefore  probably  stronger  keys  can  be  used. 
An effective CVT implementation can be based on a B2,3-
tree, for example. Some experimental results on this topic 
can be found in [10]. Table 2 compares the average costs 
of  the  different  freshness  schemes.  As  one  can  see  the 
costs of CVT and CRS2 are very similar.  
The  very  good  performance,  the enhanced security and 
the  simplicity  of  implementation  convinced  us  to  realize 
PAMINA on the basis of CVTs. However, there are some 
problems  with  this  CVT  design  that  are  discussed  in  the 
next section. 
4 Improved Certification Verification Tree 
A problem with the proposed CVTs described above is 
the following: When a verifier requests some set of certifi-
cates,  for  example  all  certificates  issued  for  a  particular 
user,  the  directory  storing  the  CVT  can  not  prove  that  it 
actually  delivers  all  of  those  certificates.  Processing  the 
certification  paths  a  verifier  can  easily  check  the  validity 
of received certificates, but he cannot know whether he got 
all valid certificates. In other words, a malicious directory 
could disclaim the existence of a certificate. This means in 
the case of authorization certificates that a user might not 
be able to utilize all privileges that he or she was actually 
assigned by the issuing authority. Buldas et al. showed in 
[11] that one can not generate an undeniable non-existence 
proof  using  the  proposed  CVTs.  The  issuing  authority 
could construct an incorrectly sorted tree and provide one 
verifier with a certificate and a second verifier with a con-
tradicting  “proof”  for  the  non-existence  of  the  same  cer-
tificate.  Therefore  the  structure  of  a  CVT  should  be  im-
proved in such a way that it is possible to provide an un-
deniable  proof  of  non-existence  if  the  directory  does  not 
deliver a requested certificate.  
Therefore,  we  construct  Improved  Certification  Veri-
fication Trees (I-CVTs) that are very efficient and more 
trustworthy. The underlying data structure of an I-CVT is 
a variant of a balanced search tree (B-tree), a so called B+-
tree.  A  B+-tree  differs  in  that  way  from  a  B-tree  that  all 
data is stored in the leaves (see Fig. 1). A B+-tree of order 
m  satisfies  the  following  properties  [12].  Every  internal 
node of the tree has at least ém/2ù and at most m children. 
The root node has at least 2 children. A non-leaf node with 
k children contains k-1 keys. Leaves of the tree contain at 
least  ém/2ù-1 and at most m-1 keys and as many pointers 
to data records (e.g., certificate statements). The leaves of 
the tree are linked which optimizes sequential access to the 
data records. In order to store certificates in a B+-tree, an 
order  of  the  certificates  must  be  defined,  e.g.  a  unique 
serial  number  or  a  certificate  hash  value  can  be  used  (s. 
below). B+-trees have the following advantageous proper-
ties for certificate management: 
•  Each path from a certificate to the root has the same 
length.  Therefore,  the  certification  paths  have  the 
same size and the communicational and computational 
costs are similar for all certificates stored in the tree.  
•  The  operations  insertion,  deletion  and  searching  are 
very efficient in a B+-tree, because they can be done in 
O(logém/2ù n) where n is the number of records (certifi-
cates) in the tree [13]. 
•  B+-trees  can  be  optimized  for search, insertion, dele-
tion and also certification path length by choosing the 
parameter m properly. 
•  Easy and efficient search and sequential access to the 
certificates.  
For certificate management purposes we extend the B+-
tree to a Merkle hash-tree. The signature on the root along 
with  a  properly  constructed  hash-path  attests  that  a given 
certificate is stored in the tree and therefore valid. 
In [1] the so-called certification path is defined as “the 
path  from  the  leaf  containing  the  certificate  statement  to 
the  root,  along  with  the  hash  values  necessary  to  verify 
that path. This includes the hash values for all siblings of 
nodes  along  that  path”.  If  the  certification  path  and  the 
signature on the root hash value are both valid, it is shown 
that the certificate is stored in the CVT and thus valid.  
H[8]
63
H[6]
27 
34
H[2]
H[3]
34 
41 63
H[1] 
13  27 
H[7]
71
H[5]
78 82
H[4]
64 71
CS1  CS2 
CS3
CS4 CS5
CS6 CS7
CS8 CS9
Figure 1: Improved CVT based on a B+-tree (here m=3) 
Since trust placed on the database storing and publishing 
the  certificates  should  be  minimized,  it  is  important  that 
the database must deliver also a proof of non-existence if it 
does  not  deliver  a  requested  certificate.  Otherwise  the 
database could simply deny the existence of a certificate as 
mentioned  above.  If  the  system  also  provides  non-
existence  proofs,  the  verifier  does  not  have  to  “blindly” 
trust in the database. The results of Buldas et al. show that 
in  order  to  provide  an  undeniable  proof  for  the  non-
existence of a certificate, information about the order and 
internal structure of the tree has to be added to the hash-
path. They have also pointed out that in CVTs as proposed 
in [1] this kind of information is missing.  
Therefore  we  add  information  about  the  structure  and 
the order of the a B+-tree to construct I-CVT (see Fig. 1). 
The values H[i] are the hash values that are stored in the 
nodes  of  the  tree.  Each  hash-value  is  computed  from  the 
search keys of the particular node and the hash values of 
its children. For example, the value H[1], which is stored 
in the leftmost leaf of the I-CVT in Fig. 1, is computed as 
follows: H[1] = h(13, 27, h(CS1), h(CS2)), where h must be 
a collision resistant hash function. 
Also the search keys - that are stored in the nodes on the 
path from the leaf with the certificate to the root - are in-
cluded in our certification path as follows:  
Certification  path  cp  =  sequence  of  (sequence  of  keys, 
sequence of sibling hash values) + signature on root of the 
tree  
cp = (l0, l1, ... , ln-1) + root signature,  
where li = ((ki0, ki1, … kit), (hi0, hi1, ... hit)) 
Example 1: certification path for the certificate statement 
with ID 27 (see Fig. 1) 
cp(27) = ((13, 27; h(CS1), h(CS2)); (27,34; H[2], H[3]); 
               (63; H[7])) + signature on H[8]. 
The  proof  of  non-existence  of  a  certificate  is  simply  the 
certification path for the leaf that would contain the certifi-
cate if it were in the I-CVT.  
Example  2:  Non-existence  proof  for  the  certificate  state-
ment with ID 42 (see Fig. 1)  
cp(42) = ((41,63; h(CS4), h(CS5)); (27,34; H[1], H[2]); 
               (63; H[7])) + signature on H[8] 
Note that the latter certification path can also be used as a 
certification path for the certificates with ID 41 and ID 63. 
The hash value of the nodes on the path to the root and 
the positions within their siblings can be omitted, since the 
hash value of a node is determined by the hash values of 
its  children  and  its  position  within  its  siblings  by  the 
search keys of its parent node. Fig. 2 shows the algorithm 
for creating certification paths.  
Input: Identifier ID of a certificate, I-CVT 
Output: Certification path or proof for the non-existence 
of certificate ID in the I-CVT 
cp ← empty certification path 
n ← leaf node which (should) contain(s) certificate id 
finished ← false 
while not finished 
k ← sequence of keys that are stored in n 
h ← sequence of hashes that are stored in n 
if n is not a leaf 
add (k,h) to cp 
pos ← position of ID in k 
(such that ki (pos-1) < ID ≤ ki pos) 
delete hash value at position pos in h 
n ← parent node of n 
if n is not the root node 
else 
finished ← true 
return cp and the signature on hash(k, h) (=hash value of 
the root node) 
Fig. 2: Algorithm for creating a certification path 
One  can  show  that  this  certification  path  is  an  undeni-
able attester as defined in [11]. This way the problems of 
CVTs we described above are solved. It can also be shown 
that we get the minimal certification path length for a B+-
tree with m=3 (i.e. a B+
2,3-tree), but we expect to get faster 
search,  insertion  and  deletion  times  for  bigger  m.  This 
leaves  some  scope  to  optimize  the  data  structure  for  a 
specific implementation.  
In order to make the system flexible and suitable for dif-
ferent  scenarios,  we  want  to  enable  that  an  authority  can 
issue  more  than  one  certificate  for  a  particular  user  and 
store them in its I-CVT. A verifier should be able to check 
that  he  gets  all  certificates  issued  for  this  user,  to  make 
sure that access is not denied if the user has the required 
privileges.  Therefore  the  certificates  in  the  I-CVT  are 
sorted by the pair (user–ID, serial number) which is unique 
since the serial number has to be unique in an I-CVT. The 
user-ID is the more significant part and the serial number 
is the less significant part, i.e. all certificates are sorted by 
user-ID and all certificates of a specific user are sorted by 
their serial numbers. This way all certificate statements of 
a particular user are adjacent and form a closed sequence. 
Verifiers  get  the  certification paths for each certificate of 
this  sequence  and  additionally for the certificates directly 
before and after it. As a result, the verifier can be sure that 
he got all certificates issued for a particular user.  
5 Architecture of PAMINA 
Due to the requirements that we defined and the results 
of the analysis of different competing approaches, we have 
decided to design PAMINA to support the pull model and 
to use separate certificates for privilege management. The 
cost  analysis  shows  that  CVTs  guarantee  a  very  good 
performance. In addition, this scheme has enhanced secu-
rity  properties.  In  order  to  reduce  the  trust  placed  on  the 
database storing CVTs and to make the scheme more effi-
cient, we developed I-CVTs. We believe that I-CVT is an 
enabling technology for the realization of open directories 
storing  certificates  issued  by  one  authority.  However, 
PAMINA  is  basically  designed  for  environments  where 
delegation  of  privileges  as  well  as  confidential  manage-
ment  of  ACs  are  needed.  Enabling  privilege  delegation 
implies  the  coexistence  of  many  I-CVTs  that  should  be 
accessible for applications. Due to this fact we develop a 
central  database  storing  all  I-CVTs  of  the  system.  Of 
course, the system can support simpler scenarios, too. 
At  first,  we  describe  the  components  of  PAMINA  and 
their  relationships.  Fig.  3  shows  the  subjects  and  compo-
nents  of  the  system  including  the  most  important  data 
flows. 
•  Resource:  Like any other privilege management sys-
tem  PAMINA  maintains  authorization  information 
used for controlling access to different objects, the re-
sources.  Each  resource  is  owned  by  one  or  more 
PMAs,  and  each  PMA  can  own  one  or  more  re-
sources.  For  example,  PMA2  owns  resource  RB  and 
RC (see Fig. 3). 
•  User: From PAMINAs point of view, users are hold-
ers of one or more ACs. Users cannot issue ACs. We 
assume  that  each  user  has  a  unique  identifier  (name, 
public-key)  which  associates  her/him  with  the  privi-
leges stored in her/his ACs.  
•  Client: In our approach a client is an application that 
represents  a  remote  user.  Since  access  control  deci-
sions can only be made if the requesting user’s iden-
tity is available, the client system has to insert identi-
fication information of the authenticated user in its re-
quest messages. 
•  Privilege  Management  Authority  (PMA):  PMAs 
are basically issuers of ACs, they represent organiza-
tional units, such as companies or divisions of a com-
pany.  Each  PMA  owns  and/or  controls  one  or  more 
resources.  PMAs  are  autonomous;  they  can  manage 
privileges in accordance to their own policies. PMAs 
can delegate privileges to other PMAs in a controlled 
manner (see below in section 5.2). As shown in Fig. 3 
resource RC is owned by PMA2, which has delegated 
some  of  its  privileges  to  PMA3.  One  can  see  that 
PMA3 itself does not own any resources, but this way 
it  can  authorize  its  users  to  access  RC.  Each  PMA 
maintains exactly one signed I-CVT in which all cer-
tificates issued by that particular PMA are stored. We 
assume  that  the  public  (signing)  key  of  the  PMA  is 
managed by an external PKI. 
•  Privilege  Database  (P-DB):  The  P-DB  is  a  central, 
non-trusted database storing the I-CVTs of registered 
PMAs.  In  this  context  non-trusted  means  that  a veri-
fier obtaining ACs can always be sure that the P-DB 
can  neither  manipulate  the  ACs,  nor  it  can  disclaim 
the  existence  of  a  given  AC.  These  properties  are 
guaranteed  by  the  digitally  signed  I-CVTs.  PMAs 
must  periodically  send  updated  I-CVTs to the P-DB, 
according to their own update policy. The P-DB con-
trols  neither  the  validity,  nor  the  freshness  of  the  I-
CVTs; it just stores them. ACs can be downloaded by 
verifiers, which are owned by registered PMAs. In or-
der  to  avoid  performance  and  availability  problems 
the P-DB can be replicated. 
•  Verifier: In PAMINA a verifier is owned by at least 
one  PMA.  Verifiers  control  only  access  to  resources 
that  are  owned  by  their  owner  PMAs.  For  example, 
VPMA2 is owned by PMA2 as shown in Fig. 3. PMAs 
state  this  ownership  with so called policy certificates 
(see below in section 5.1). Verifiers make access con-
trol  decisions  on  the  basis  of  the  ACs  downloaded 
from the P-DB. A verifier is a program which runs di-
rectly on the targeted system itself, or it is an external 
service  used  by  server-sided  applications,  for  exam-
ple. In Fig. 3 client C, that was authorized by PMA3, 
wants to use resource RC controlled by verifier VPMA2. 
RA
RA
RB
RB
owns
owns
RC