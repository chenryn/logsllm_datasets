data can be sent to or received from outside, sometimes the data
connection can abnormally stall for a long time, incurring annoying
user experience. This phenomenon is termed as Data_Stall [5] in
Android. In detail, when there have been over 10 outbound TCP
segments but not a single inbound TCP segment during the last
minute (the statistics are made by the Linux kernel in its network
protocol stack), a Data_Stall failure is reported to both relevant
system services and user-space apps. In addition, there are other
types of failures we do not elaborate here but will mention when
necessary in the remaining parts.
For all the abovementioned failure events, Android currently pro-
vides basic notiﬁcation interfaces with which the relevant system
services can register themselves as the event listeners. Nevertheless,
only a part of the interfaces (including the Data_Stall notiﬁer and
Out_of_Service checker) are exposed to user-space apps, and some
interfaces are inaccessible even with root privileges. Therefore, we
are unable to capture all the concerned failure events by simply
developing an Android app. To make the matter worse, some of the
abovementioned failure events are in fact not true failures. For ex-
ample, a data connection setup request may be rejected by a nearby
BS which is currently overloaded; in this case, a Data_Setup_Error
event will be reported but does not imply a true failure. Additionally,
the event-related information reported by Android is often insufﬁ-
cient for in-depth analysis. In fact, Android typically only reports
DisconnectDisconnectActivatingActivatingInactiveInactiveRetryingRetryingActiveActiveConnection SetupSetup CompletionSetup ErrorExceeding Max Number of RetriesSetup CompletionDisconnect InitiationDisconnect CompletionConnection Setupdetected, this component checks the states of network stack and
Internet connectivity by simultaneously sending an ICMP message
to the local IP address (127.0.0.1), as well as sending an ICMP
message and a DNS query (for our dedicated test server’s domain
name) to each of the user device’s assigned DNS server(s). If the
ICMP message intended for the local IP address reaches a timeout
(empirically conﬁgured as one second as suggested by the ICMP pro-
tocol [46]), we know that the problem lies at the system side rather
than the network side (hence a false positive case). In practice, such
false positives typically involve erroneous ﬁrewall conﬁgurations,
problematic proxy settings, and modem driver failures. Otherwise, if
all the DNS queries reach a timeout (empirically conﬁgured as ﬁve
seconds as suggested by the DNS protocol [22]), we know the prob-
lem lies at the network side. However, if timeouts only occur to the
DNS queries but not to the ICMP messages sent to the DNS servers,
we ﬁgure out that the problem is induced by the unavailability of
DNS resolution service (also a false positive case).
The above probing process needs at most ﬁve seconds, given
the one-second timeout for the ICMP message deliveries and ﬁve-
second timeout for the DNS queries. If the probing results indicate
that Data_Stall has not been ﬁxed, we will initiate a new probing
process; otherwise, we add up the duration values recorded in all the
previous probing processes (since the beginning of this Data_Stall
failure) to approximate the actual duration of this Data_Stall failure.
Thus, our measurement error is at most ﬁve seconds (<< 1 minute).
Furthermore, to avoid excessive network overhead, if a Data_Stall
failure lasts for longer than 1200 seconds (in few than 10% cases,
as illustrated later in §3.1), we will multiplicatively increase the
timeout values by a factor of two in the next probing process to
balance the incurred error and overhead. Finally, if either timeout
value grows to longer than one minute, we will revert to Android’s
original detection mechanism to estimate the Data_Stall duration.
All in all, our modiﬁcations to Android involve system-level
information logging (primarily through existing interfaces) and light-
weight network probing activities. For even a low-end Android
phone at the moment, Android-MOD only incurs <2% CPU utiliza-
tion, <40 KB of memory usage, and <100 KB of storage space;
the network usage per month is <100 KB. Note that here the CPU
utilization is measured by the portion of additional CPU overhead
induced by our monitoring infrastructure within the duration of de-
tected failures, rather than during the entire measurement process.
As a matter of fact, in daily usages without cellular failures, our
monitoring infrastructure is dormant at the client side and thus does
not incur additional CPU overhead.
On the other hand, we do notice that for a small fraction (<1%)
of user devices, they experience as many as 40,000+ failures (as to a
single user) in a month. Even so, the incurred CPU, memory, and
storage overheads are still acceptable: <8% CPU utilization, <2 MB
of memory usage, and <20 MB of storage space; the network usage
per month can reach 20 MB, so the recorded data are uploaded to
our backend server only when there is WiFi connectivity.
Finally, the network overhead incurred by our measurement is
fairly low even in a cumulative sense. For all the 70M users that
participated in our study, the aggregate network overhead per second
on the entire cellular networks of the three involved ISPs was below
500 KB, and thus had negligible inﬂuence on the performance,
availability, and reliability of the studied cellular networks.
2.3 Large-Scale Deployment
With the continuous monitoring infrastructure, in Dec. 2019 we
invited all the users of Xiaomi to participate in our measurement
study of cellular reliability by installing Android-MOD on their
phones. Note that the installation is a lightweight update that will not
affect their installed apps, existing data, and OS version. Eventually,
70,965,549 users opted in and collected data for us for eight months
(Jan.–Aug. 2020). All data are compressed and uploaded to our
backend server for centralized analysis.
Ethical Concerns. All analysis tasks in this study comply with the
agreement established between Xiaomi and its users. The users who
participated in the study opted-in as volunteers with informed con-
sent, the analysis was conducted under a well-established IRB, and
no personally identiﬁable information (e.g., phone number, IMEI,
and IMSI) was collected. We never (and have no way to) link col-
lected information to users’ true identities.
3 MEASUREMENT RESULTS
In this section, we ﬁrst present the general characteristics of our
collected measurement data (§3.1). Then, to systematically describe
cellular failures and their underlying causes in a more readable
manner, we present our data analysis results from the viewpoints of
Android phones (§3.2) and ISPs/BSes (§3.3), respectively.
3.1 General Statistics
With the crowdsourcing help from 70,965,549 Android-MOD user
devices with 34 different phone models (as listed in Table 1), we
record the system-level traces with regard to 2,315,314,213 cellu-
lar failures, involving 16,183,145 user devices, 3 mobile ISPs and
5,273,972 base stations. To the best of our knowledge, this is so far
the largest dataset regarding cellular failures in the wild.
First of all, we are concerned with the prevalence and frequency
of cellular failures: the former denotes the fraction of devices that
experience at least one cellular failure, and the latter is the average
number of cellular failures experienced per phone. Our measurement
results reveal that cellular failures occur prevalently on all the 34
studied phone models. As indicated in Table 1 and Figure 2, on
different models of phones the prevalence varies from 0.15% to 45%
and averages at 23%. More notably, as many as 33 cellular failures
occur to a phone on average during our 8-month measurement (see
Figure 3), and the average number of cellular failures happening to
a speciﬁc model varies from 2.3 to 90.2 (see Table 1). In a nutshell,
while the majority (77%) of phones do not report cellular failures
during the measurement, the maximum number of cellular failures
happening to a single phone can reach 198,228 (see Figure 3).
Apart from prevalence and frequency, we are also concerned with
the duration of cellular failures. As shown in Figure 4, the average
duration of cellular failures is as long as 188 seconds (= 3.1 minutes).
This is an astonishing value in case of emergency, considering that a
victim user is expected to be out of contact for 3.1 minutes. In detail,
the duration distribution is highly skewed—while 70.8% cellular
failures last for less than 30 seconds, the maximum duration can
reach 91,770 seconds (= 25.5 hours). Closer examination reveals
that such long-duration failures typically occur in remote regions
Figure 2: Prevalence of cellular failures
on each model of phones.
Figure 3: Number of cellular failures hap-
pening to a single phone.
Figure 4: Duration of our recorded cellu-
lar failures.
Table 1: Hardware conﬁgurations of our studied 34 phone mod-
els, generally ordered from low-end to high-end. The rightmost
ﬁve columns correspond to the phone’s 5G capability (5G), An-
droid version (Version), user percentage (Users), fraction of de-
vices that experience at least one cellular failure (Prevalence),
and average number of cellular failures experienced per phone
(Frequency) during our measurement, respectively.
Model
CPU
Memory
Storage
5G
Version
Users
Prevalence
Frequency
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
1.8 GHz
1.95 GHz
2 GHz
2 GHz
2 GHz
2 GHz
2 GHz
2 GHz
2 GHz
2.2 GHz
1.8 GHz
2 GHz
2.05 GHz
2.2 GHz
2.2 GHz
2.2 GHz
2.2 GHz
2.2 GHz
2.2 GHz
2.2 GHz
2.2 GHz
2.2 GHz
2.4 GHz
2.4 GHz
2.45 GHz
2.45 GHz
2.8 GHz
2.8 GHz
2.8 GHz
2.8 GHz
2.84 GHz
2.84 GHz
2.84 GHz
2.84 GHz
2 GB
2 GB
2 GB
3 GB
3 GB
3 GB
3 GB
3 GB
3 GB
4 GB
4 GB
4 GB
6 GB
6 GB
4 GB
4 GB
6 GB
6 GB
6 GB
6 GB
6 GB
6 GB
6 GB
6 GB
6 GB
6 GB
6 GB
6 GB
6 GB
6 GB
6 GB
6 GB
8 GB
8 GB
16 GB
16 GB
16 GB
32 GB
32 GB
32 GB
32 GB
32 GB
32 GB
32 GB
64 GB
64 GB
64 GB
64 GB
128 GB
128 GB
64 GB
64 GB
64 GB
64 GB
64 GB
128 GB
64 GB
128 GB
64 GB
64 GB
64 GB
64 GB
64 GB
128 GB
64 GB