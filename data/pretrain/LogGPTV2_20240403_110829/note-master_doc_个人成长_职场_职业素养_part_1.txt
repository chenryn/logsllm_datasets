# 专业素养
**关心你的技艺 思考你的作为**
## 专业主义
专业主义意味着担当责任
- **提供各种选择 不要找蹩脚的借口**
说明做不到之前 给出所能给出的最好方案以尝试挽回
### 损害
软件出现bug 就是在损坏软件功能
编写测试 让它自动化跑出起来 测试越多 你对自己的代码越有信心
牺牲结构来修改软件 后果是得不偿失 软件的特点就在于软 如果修改难以进行 就代表设计出现了问题 留着这些破窗户只会导致破窗越来越大 **不要容忍破窗户**
当软件的熵越来越大时 软件也就越来越无序了 称之为软件腐烂
使用无情重构的方式来避免代码慢慢腐烂 但重构的前提是完备的测试 测试是软件质量的保障
**留意环境 警惕那些软件腐败的小细节**
### 职业道德
专业人士应舍得投入时间不断提升自己 变得更加专业
似乎软件开发这个领域出现知识大爆炸 感慨学不过来 但目前这些所谓的流行技术 绝大部分都是来得快去得快 那些来之不易的理念 绝大部分在今天仍然十分有价值 在学习时 应该把重点放在这边
- 设计模式 设计原则
- 开发方法
- 软件工程实践
- 不会过时的工具
- ...
持续学习才不至于落伍 不写代码的架构师必然遭殃
这个行业的知识更新迭代的速度十分快, 你需要像金融投资那样经营你的知识资产：
- 定期投资让你不至于你的知识一成不变 落伍
- 多元化 知道的不同的事情越多 越有价值
- 管理风险 新兴知识的投资高回报高风险 不要把所有的技术鸡蛋放在同一个篮子
- 需要时 对投资进行重新评估与选择
**批判分析读到和听到的**
练习能让你的技艺保持熟悉 什么样的练习 刷题?
与他人合作能从彼此身上学到很多东西
费曼学习法
技术人员应付出相当的努力来认识业务领域，既然拿了公司的钱，就要熟悉公司的内部技术达到一个说得过去的水平
站在雇主角度开发软件 **使质量称为需求问题**, 有时候需要在尽早交付与完美软件之前权衡 编程就像绘画 需要知道何时止步 一昧求精只会导致损毁掉你的程序
不必故作谦逊 摔了跟头大不了一笑了之
## 说不
面对艰难决定 直接面对是最好的办法
对于非技术人员 ”为什么“只是个技术细节 对它们俩说 并不重要
合适的时机说不 意味着团队精神 意味着对团队负责
客户所要的任何一项功能 一旦写起来 总是远比它刚开始时说的要复杂许多
## 说是
模糊不清的词是缺乏承诺的征兆
使用具体时间来承诺 那么就要为承诺负起全部责任
- 只能承诺自己能完全掌握的事情
- 即使无法完成目标 也该努力前进 离目标更近
- 如果无法兑现承诺 应及时发布预警
如何说是：
- 试试看意味着不确定感 对于明确有着不确定的任务 应该表达出不确定感
- 同时仍需要坚守原则 作为一个专业人士
### 主观能动性
- 完成需求并不够，还需要深层次满足用户的需求
交付思维：理解用户需求背后真正想要的东西，然后努力向这个目标发展
注意时间：精益求精的同时在规定的时间内完成优先级更高
### 责任边界
1. 对安排的工作负责：除了保质保量完成之外，还要提早暴露风险，抛给上一层的人做决定
2. 对工作时间负责：解决问题时在线、准时参加会议
## 编码
**你不可能写出完美的软件**
防御式编程不仅仅防御别人的代码 还要防御自己
传统的瀑布模型一旦进入编码阶段 就是机械地将设计转为可执行语句 这种没有任何创造性的编码或许是造成软件结构糟糕 低效的原因
出错感知能力能帮助你更快速地从错误中学习
准备：
- 编码前必须要理解解决的是什么问题以及该如何解决
- 确保代码能解决客户的问题 而非完成需求
- 新的代码应能完美适应当前系统
- 写下的代码应该具有可读性
疲劳与心烦意乱下的产出 最终只能回头返工
一味追求速度可能会导致思考角度边狭隘 从而做出一些以后不得不推到再来的决策
编程时被中断再回来会导致上下文成本切换很高：
- 结对编程的伙伴可以帮助维护上下文
- TDD失败的测试也可以快速让你回到状态
心情/精神等因素会阻塞你的创造性输出 相反 一些创造性输入可以激励你产出
调试时间的多少与专业程度成反比 向着零调试时间前进
难以解决的困难不妨放一放 等待灵感的到来
冲刺可以解决进度延迟问题 但不一定会成功 需要准备后备预案
只有通过验收测试 某个特性才能称之为完成
帮助他人 接收他人的帮助
### 合约式编程
DBC:
- 前条件：调用程序前 必须为真的条件
- 后条件：程序保证会做的事
- 类不变项：确保从调用者的角度看 总是为真的条件
实现方式：
- 断言 但是无法继承
- 部分语言内置支持 但是大部分语言不支持 通过使用预处理器来实现它
**早崩溃**：
通过检查前置条件 早一点暴露错误 调试就会容易许多
尽早崩溃比造成破坏是更好的选择 Java中的运行时异常采用了这一哲学
不变项：
- 循环不变项：循环的边界很容易出错 通过定义一个不变项来证明结果有效
- 语义不变项：定义一个合约来表达不可违反的需求
动态合约与代理：合约可以发生变化
### 断言式编程
**如果它不可能发生 用断言确保它不会发生**
不要关掉断言 这世界很危险 程序很容易出错
### 异常的使用
异常不应该是程序正常流程的一部分 而是留给意外事件
不支持异常的编程语言只能使用错误处理器 c语言可以通过使用goto的方式来实现全局异常处理
### 资源的使用
- **有始有终** 分配资源的程序应该负责回收资源
资源的分配：
- 以资源分配的反序释放资源 这样就不会造成资源被遗弃
- 分配同一组资源的时候 总是以相同的顺序进行分配 这可以降低死锁发生的可能性
资源的释放：
- 递归回收 顶层对象一旦被释放 就递归地释放子资源
- 顶层回收 就直接遗弃所有子资源
- 如果顶层含有子资源 在所有子资源释放前 拒绝释放顶层
### 靠巧合编程
编程时 依赖着许多假定的条件 有时候这些条件也许存在 从而你的程序能偶尔可以工作正确 但更多地 它会在你未来的某一天崩掉
### 算法速率
使用大O表示法**估算你的算法**
### 重构
**早重构 常重构 重构必无情**
何时重构：
- 重复
- 非正交设计
- 过时的知识
- 为了性能
### 易于测试的代码
**为测试而设计** 使用合约式编程来清晰测试
### 谨慎代码生成器的使用
**不要使用你不理解的代码代码生成器** 这些代码未来可能会跟你你编写的代码柔和在一起 如果不理解它们 未来就是一个定时炸弹
## 注重实效
### 重复
系统中的每一项知识都必须具有单一 无歧义 权威的表示
**不要重复你自己**
- 强加的重复
好像让开发者没得选择 必须写重复的文档 做重复的编码 如根据规约写出代码 但只需要动用一点小才智 就能让这个过程自动化
把低级的知识放在代码中 把注释留给高级的知识
- 无意的重复
这种重复一般是设计的错误 需要从根源解决问题
- 无耐性的重复
就跟提到的赶工期取消单元测试一样 编码一时爽 维护火葬场
- 开发者的重复
这个问题似乎在2020年的今天已经不存在 开源社区的繁荣促使开发者代码**复用变得十分容易**
### 正交
**消除无关事务之间的影响**
正交在几何中表示的是如果两条线称直角 则就称之为正交
对应到计算机世界 就是解耦 一个模块的变化不会影响到另外一个模块
正交的好处：
- 提高生产率
  - 小模块的编写总比大模块容易
  - 促进复用
- 降低风险
  - 有问题的代码会被隔离
  - 改动影响的范围有限
  - 测试更容易
在团队中：正交性差的团队成员职责边界不清晰
在设计中：分层的方法是设计正交系统的强大途径
引入第三方库时 是否需要对已有代码进行改动 如果是 那么就不是正交的
每次编写编码 都有系统降低正交性的风险 几个原则来维持正交性：
- 保持代码解耦 避免不必要的数据暴露 使用OOP来封装
- 避免全局变量
- 使用设计模式
正交也适用于文档 正交文档表现形式与内容分离 比如markdown
### 可撤销
如果某个想法是唯一的想法 那就太危险了
总需要保持代码的灵活性来避免变动带来的返工
**不存在最终决策**
### 曳光弹
小步快跑 快速迭代 帮助用户明确需求
小段代码的惯性很小 改变起来很容易