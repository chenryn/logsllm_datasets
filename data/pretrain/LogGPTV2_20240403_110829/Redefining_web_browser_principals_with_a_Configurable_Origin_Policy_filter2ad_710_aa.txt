title:Redefining web browser principals with a Configurable Origin Policy
author:Yinzhi Cao and
Vaibhav Rastogi and
Zhichun Li and
Yan Chen and
Alexander Moshchuk
Redeﬁning Web Browser Principals with a
Conﬁgurable Origin Policy
Yinzhi Cao, Vaibhav Rastogi, Zhichun Li†, Yan Chen and Alexander Moshchuk††
Northwestern University
†NEC Labs America
††Microsoft Research
Abstract—With the advent of Web 2.0, web developers have
designed multiple additions to break SOP boundary, such as
splitting and combining traditional web browser protection
boundaries (security principals). However, these newly gen-
erated principals lack a new label to represent its security
property. To address the inconsistent label problem, this paper
proposes a new way to deﬁne a security principal and its labels
in the browser. In particular, we propose a Conﬁgurable Origin
Policy (COP), in which a browser’s security principal is deﬁned
by a conﬁgurable ID rather than a ﬁxed triple . The server-side and client-side code of a web application
can create, join, and destroy its own principals. We perform
a formal security analysis on COP to ensure session integrity.
Then we also show that COP is compatible with legacy web
sites, and those sites utilizing COP are also compatible with
legacy browsers.
I.
INTRODUCTION
Web browsers have traditionally used the same-origin
policy (SOP) to deﬁne protection boundaries between dif-
ferent web applications. According to SOP, a web site origin
in the form of  serves as a label for
the browser’s security principals (isolated security domains).
Each origin is protected from other origins in terms of
resource access and usage.
With the advent of Web 2.0, modern web sites place new
demands on browser’s security that SOP was never designed
to handle. Indeed, while intuitively simple, using web site
origins to label browser principals has its limitations. Some-
times, SOP is too ﬁne-grained. For example, contents from
different web site origins (such as Gmail and Google Docs)
may require unrestricted access to each other’s resources, but
SOP prevents browsers from rendering them as one principal.
Other times, SOP is too coarse-grained. For example, it does
not let browsers isolate logically different instances of web
applications hosted on the same server, i.e., when one site
hosts many distinct mashups, blogs, or user proﬁles, and
it does not enable sites such as an email provider to run
multiple, isolated sessions of the application in the same
browser.
Faced with inﬂexibility of same-origin policy, web devel-
opers have worked around its limitations with a multitude of
ad-hoc approaches to merge or separate a browser’s security
principal. For example, subdomains may merge with each
other by setting document.domain to a common sufﬁx, a
practice prone to security problems [1]. MashupOS [2] pro-
poses a sandbox tag together with a veriﬁable-origin policy to
separate content from the same web site’s security principal,
which is particularly useful for mashups. Various cross-origin
communication protocols are proposed [3]–[5] to break SOP
for AJAX’s XMLHttpRequest. However, while recent works
[2]–[6] have studied ways of breaking SOP, they do not deﬁne
different labels for those newly generated principals, which
leads to a mismatch between principals and their origins
(security labels). By utilizing the mismatch, an attack can
camouﬂage the identity of a merged or separated principal
and fool another server or client with the old SOP origin,
the whole process of which is deﬁned as an origin spooﬁng
attack.
In this paper, we study a new way to label browser se-
curity principals. We propose a Conﬁgurable Origin Policy
(COP), in which a browser’s security principal is deﬁned by
a conﬁgurable ID speciﬁed by client browsers rather than a
ﬁxed triple . Drawing inspiration from
resource containers [7], we let the applications themselves
manage their deﬁnition of an origin. That is, COP allows
server-side and client-side code of a web application to create,
join, destroy, and communicate with its own principals. In our
scheme, one browser security principal can involve multiple
traditional (SOP) web site origins, and various content from
one traditional web site origin may render as multiple differ-
ent principals. Fundamentally, COP origins break the long-
standing dependence of web client security on domain names
of servers hosting web content, and offer several compelling
advantages:
• Flexibility. COP-enabled web applications can specify ex-
actly which content from different domains can interact
with one another on the client web browser. For example,
Google may wish to let gmail.com and docs.google.com
access each other’s resources on the client. Moreover, with
COP, we can disable many ad-hoc, error-prone and po-
tentially incoherent workarounds for SOP limitations [1],
such as subdomain communication via document.domain,
while still allowing sites to function correctly. COP also
supports many scenarios that required a separate security
mechanism, such as sandboxing mashups [2], and those
that are not well supported by existing browsers, such as
allowing a site to run different isolated web sessions in the
same browser, all under one uniform framework.
• Consistency. COP-based browser principal deﬁnes a new
security label, a conﬁgurable ID, to represent its property.
By examining the new label, other web clients and servers
can easily differentiate the principal from old SOP-based
browser principals and other new COP-based principals.
• Compatibility. Because we change the web’s central secu-
rity policy, we undoubtedly face the challenges of deploy-
ment and backward compatibility. To address compatibility,
978-1-4799-0181-4/13/$31.00 ©2013 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:53:23 UTC from IEEE Xplore.  Restrictions apply. 
TABLE I.
Flexibility
Consistency
Compatibility
Lightweight-ness
Security
SOP+Additions
Other Non-SOPs
COMPARING COP WITH EXISTING APPROACHES.
COP
Yes
Yes
Yes
Yes
High
SOP
No
Yes
Yes
Yes
Low
No
Yes
Yes
Low
Partial
Yes
No
Yes
No
Medium
we design SOP to be a special case of our new origin proto-
col, which makes COP compatible and secure with legacy
web sites. COP-enabled web sites also remain compatible
with existing browsers, since we convey our new design in
existing protocols.
• Lightweight-ness. Our modiﬁcation of WebKit to support
COP is lightweight (327 lines), and our evaluation shows
it has little overhead (less than 3%). Our modiﬁcations on
web servers are also small. In examples we studied, less
than ten lines were required to be inserted into existing
server-side programs. To ease deployment, we also built a
proxy that simulates modiﬁcations to web application code,
and evaluated COP.
• Security. COP mitigates SOP speciﬁc attacks such as cross-
site request forgery [8], and recently-discovered cross-origin
CSS attacks [9]. For COP speciﬁc attacks, such as leaking
the conﬁgurable ID (COP security label) through a care-
less programmer’s mistake or an open HTTP connection,
we adopt two corresponding defense mechanisms, i.e., de-
faulting safe behaviors and transmitting IDs in an HTTPs
channel. We also show that even if an attacker sniffs the
conﬁgurable ID through an open HTTP connection, he
cannot make additional damages through a COP design.
Furthermore, we perform a formal security analysis by
adopting and modifying an Alloy [10] web security model
proposed and written by Akhawe et al [11]. The session
integrity is ensured given the scope and the attack model.
All details are in Section V.
Contributions. We are making the following contributions:
• Conﬁgurable Origin Framework (COF, referring to mod-
iﬁcations necessary to support COP on web clients and
servers) is the ﬁrst uniﬁed framework to merge and sepa-
rate web browser principals at both client and server side.
No other approaches can achieve both functionalities at the
same time.
• We are the ﬁrst to propose and solve origin spooﬁng
attacks. We deﬁne a new label in COF so that there is no
confusing label for a merged or separated principal.
• COF is with low overhead compared with existing ap-
proaches in combining principals [12]. For example, when
addressing the sub-domain communication problem [1], in
which two domains completely trust each other, COF with
native object access is 2X faster than libraries built upon
postMessage channel [12].
A. Same-Origin Policy
The same-origin policy (SOP) is an access control pol-
icy deﬁned in a client web browser, which allows only re-
sources from the same  origin to access
each other. Although SOP has been a good model with well-
understood security properties, it has been inﬂexible for many
modern Web 2.0 applications in the following two main sce-
narios.
• Lack of Principal Cooperation. SOP makes it very difﬁ-
cult for multiple domains to be “combined” into one single
principal as shown in the following two cases. (i) Several
domains, like mail.google.com and docs.google.com, may
be controlled by a single owner who may want to allow
sharing among the domains the owner controls. (ii) Since
AJAX requests obey SOP, web applications cannot retrieve
a URL from a different origin via XMLHttpRequest.
• Lack of Principal Isolation. SOP makes it very difﬁcult for
one domain to be “split” into different principals as shown
in the following two cases. (i) A web site may require
multiple isolated web sessions in one client browser. For
example, a user may want to log in to multiple email
accounts on the same provider site. (ii) To enrich users’
experiences, many web sites embed third-party gadgets in
iframes, such as Google Gadgets, Microsoft Widgets, and
Facebook applications.
B. Existing Additions to Same-Origin Policy
To overcome such well-recognized SOP inﬂexibility, web
sites resort to a multitude of different approach to “patch”
SOP. They can be classiﬁed into three categories.
• Splitting One Single Principal. Various approaches [6,
13]–[17] create a separated environment to isolate differ-
ent web sessions or third-party content at one client. New
iframe tag in HTML5 [18] also supports a sandbox prop-
erty to prevent access from the same origin.
• Combining Multiple Principals at Server Side. Many pro-
posals [3]–[5] have been made to support cross-origin re-
source sharing (CORS). To support more ﬁne-grained server-
side merging, Content Security Policies (CSP) [19] and
CSP-like mechanisms, such as SOMA [20], speciﬁes ac-
cess control policies at server side through HTTP headers
or manifest ﬁles. Client browsers will be modiﬁed to en-
force those speciﬁed policies.
• Combining Multiple Principals at Client Side. Since doc-
ument.domain, which disobeys least-privilege principle, is
insecure [1], Gazelle [21] disables document.domain and
proposes that sites use these existing cross-principal com-
munication channels, such as postMessage. Other work,
such as Object Views [12], layers complexity on top of
cross-principal communication channels to facilitate easier
object sharing.
II. MOTIVATION AND RELATED WORK
The work is motivated in this section. We present SOP,
SOP plus all the additions, and other non-SOPs, together with
their limitations, in Section II-A, Section II-B, and Section
II-C. A high-level comparison is also shown in Table I.
Limitations of Existing Additions to SOP. Fundamentally,
all these approaches together ﬁx ﬂexibility problems in SOP,
and thus we are showing the limitations of all existing ad-
ditions to SOP as follows: inconsistency, heavyweight-ness,
and insecurity.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:53:23 UTC from IEEE Xplore.  Restrictions apply. 
	

 
 	
























Fig. 1. Origin Spooﬁng Attack for CORS (A has full access to B through
a JavaScript
this new combined
principal can still send requests as B. What if C - benign.com, trusts B
but not A?).
library over postMessage channel. But
1) Inconsistency: After existing approaches split or merge
different SOP principals, unlike traditional SOP principals
with the ﬁxed triple () as security labels,
those newly created principals do not own such labels. When
browsers or servers check the security label of a principal,
they can only inspect the old SOP label, which we call a mis-
match between the principal and its security label (origin). In
particular, an attacker can utilize the mismatch to camouﬂage
a principal’s identity and then fool a server or a browser
with SOP origin, which is deﬁned as an origin spooﬁng
attack. We present the mismatch and its corresponding origin
spooﬁng attack from two scenarios, namely, for a separated
principal and a merged one.

First, there is a mismatch between a separated principal
and its origin. For example, as supported by the new iframe
feature in HTML5 [18], a.com can be separated into a gadget
G1 (a.com/benign) and another gadget G2 (a.com/malicious)
by specifying a sandbox property. In this case, G1 and G2
shares the same SOP origin but have different security prop-
erties from a.com.
A concrete origin spooﬁng attack utilizing this HTML5
feature is shown below. Say, for example, three frames, In-
tegrator I (top), Attacker Frame A (middle) and Gadget G1
(bottom), are nested. Barth et al. [22] shows that if G1 sends a
message to I, the attack frame A can navigate its child frame
G1 to a malicious one to receive the reply from A. Therefore,
all the up-to-date browsers check SOP origin of target frame
in postMessage. However, after the HTML5 feature splits
one single principal a.com into G1 and G2, the attacker can
navigate the benign gadget G1 to a malicious one G2 in the