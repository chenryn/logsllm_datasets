# Redefining Web Browser Principals with a Configurable Origin Policy

**Authors:**
- Yinzhi Cao
- Vaibhav Rastogi
- Zhichun Li†
- Yan Chen
- Alexander Moshchuk††

**Affiliations:**
- Northwestern University
- †NEC Labs America
- ††Microsoft Research

## Abstract
With the advent of Web 2.0, web developers have designed multiple additions to break the Same-Origin Policy (SOP) boundaries, such as splitting and combining traditional web browser protection boundaries (security principals). However, these newly generated principals lack a new label to represent their security properties. To address this inconsistency, this paper proposes a new way to define a security principal and its labels in the browser. Specifically, we introduce a Configurable Origin Policy (COP), where a browser’s security principal is defined by a configurable ID rather than a fixed triple. The server-side and client-side code of a web application can create, join, and destroy its own principals. We perform a formal security analysis on COP to ensure session integrity. Additionally, we show that COP is compatible with legacy websites, and those sites utilizing COP are also compatible with legacy browsers.

## I. Introduction
Web browsers have traditionally used the Same-Origin Policy (SOP) to define protection boundaries between different web applications. According to SOP, a web site origin in the form of `<scheme>://<host>:<port>` serves as a label for the browser’s security principals (isolated security domains). Each origin is protected from other origins in terms of resource access and usage.

With the advent of Web 2.0, modern websites place new demands on browser security that SOP was not designed to handle. While intuitively simple, using website origins to label browser principals has its limitations. Sometimes, SOP is too fine-grained. For example, content from different website origins (such as Gmail and Google Docs) may require unrestricted access to each other’s resources, but SOP prevents browsers from rendering them as one principal. Other times, SOP is too coarse-grained. For example, it does not allow browsers to isolate logically different instances of web applications hosted on the same server, i.e., when one site hosts many distinct mashups, blogs, or user profiles, and it does not enable sites such as an email provider to run multiple, isolated sessions of the application in the same browser.

Faced with the inflexibility of SOP, web developers have worked around its limitations with various ad-hoc approaches to merge or separate a browser’s security principal. For example, subdomains may merge with each other by setting `document.domain` to a common suffix, a practice prone to security problems [1]. MashupOS [2] proposes a sandbox tag together with a verifiable-origin policy to separate content from the same website's security principal, which is particularly useful for mashups. Various cross-origin communication protocols have been proposed [3]–[5] to break SOP for AJAX’s XMLHttpRequest. However, while recent works [2]–[6] have studied ways of breaking SOP, they do not define different labels for those newly generated principals, leading to a mismatch between principals and their origins (security labels). By utilizing this mismatch, an attack can camouflage the identity of a merged or separated principal and fool another server or client with the old SOP origin, a process defined as an origin spoofing attack.

In this paper, we propose a new way to label browser security principals. We introduce a Configurable Origin Policy (COP), where a browser’s security principal is defined by a configurable ID specified by client browsers rather than a fixed triple. Drawing inspiration from resource containers [7], we allow the applications themselves to manage their definition of an origin. That is, COP allows server-side and client-side code of a web application to create, join, destroy, and communicate with its own principals. In our scheme, one browser security principal can involve multiple traditional (SOP) website origins, and various content from one traditional website origin may render as multiple different principals. Fundamentally, COP origins break the long-standing dependence of web client security on domain names of servers hosting web content and offer several compelling advantages:

- **Flexibility:** COP-enabled web applications can specify exactly which content from different domains can interact with one another on the client web browser. For example, Google may wish to let `gmail.com` and `docs.google.com` access each other’s resources on the client. Moreover, with COP, we can disable many ad-hoc, error-prone, and potentially incoherent workarounds for SOP limitations [1], such as subdomain communication via `document.domain`, while still allowing sites to function correctly. COP also supports many scenarios that required a separate security mechanism, such as sandboxing mashups [2], and those that are not well supported by existing browsers, such as allowing a site to run different isolated web sessions in the same browser, all under one uniform framework.
- **Consistency:** COP-based browser principal defines a new security label, a configurable ID, to represent its property. By examining the new label, other web clients and servers can easily differentiate the principal from old SOP-based browser principals and other new COP-based principals.
- **Compatibility:** Because we change the web’s central security policy, we face the challenges of deployment and backward compatibility. To address compatibility, we design SOP to be a special case of our new origin protocol, making COP compatible and secure with legacy websites. COP-enabled websites also remain compatible with existing browsers, as we convey our new design through existing protocols.
- **Lightweight-ness:** Our modification of WebKit to support COP is lightweight (327 lines), and our evaluation shows it has little overhead (less than 3%). Our modifications on web servers are also small; in the examples we studied, less than ten lines were required to be inserted into existing server-side programs. To ease deployment, we also built a proxy that simulates modifications to web application code and evaluated COP.
- **Security:** COP mitigates SOP-specific attacks such as Cross-Site Request Forgery (CSRF) [8] and recently-discovered cross-origin CSS attacks [9]. For COP-specific attacks, such as leaking the configurable ID (COP security label) through a careless programmer’s mistake or an open HTTP connection, we adopt two corresponding defense mechanisms: defaulting to safe behaviors and transmitting IDs in an HTTPS channel. We also show that even if an attacker sniffs the configurable ID through an open HTTP connection, they cannot make additional damages through COP design. Furthermore, we perform a formal security analysis by adopting and modifying an Alloy [10] web security model proposed and written by Akhawe et al. [11]. Session integrity is ensured given the scope and attack model. All details are in Section V.

### Contributions
- **Configurable Origin Framework (COF):** Referring to modifications necessary to support COP on web clients and servers, COF is the first unified framework to merge and separate web browser principals at both the client and server side. No other approaches can achieve both functionalities simultaneously.
- **Origin Spoofing Attacks:** We are the first to propose and solve origin spoofing attacks. We define a new label in COF so that there is no confusing label for a merged or separated principal.
- **Low Overhead:** COF has low overhead compared to existing approaches in combining principals [12]. For example, when addressing the sub-domain communication problem [1], in which two domains completely trust each other, COF with native object access is 2X faster than libraries built upon postMessage channels [12].

### A. Same-Origin Policy
The Same-Origin Policy (SOP) is an access control policy defined in a client web browser, which allows only resources from the same origin to access each other. Although SOP has been a good model with well-understood security properties, it has been inflexible for many modern Web 2.0 applications in the following two main scenarios:
- **Lack of Principal Cooperation:** SOP makes it very difficult for multiple domains to be “combined” into one single principal. For example, several domains, like `mail.google.com` and `docs.google.com`, may be controlled by a single owner who may want to allow sharing among the domains they control. Additionally, since AJAX requests obey SOP, web applications cannot retrieve a URL from a different origin via XMLHttpRequest.
- **Lack of Principal Isolation:** SOP makes it very difficult for one domain to be “split” into different principals. For example, a website may require multiple isolated web sessions in one client browser, such as a user wanting to log in to multiple email accounts on the same provider site. To enrich users’ experiences, many websites embed third-party gadgets in iframes, such as Google Gadgets, Microsoft Widgets, and Facebook applications.

### B. Existing Additions to Same-Origin Policy
To overcome the recognized inflexibility of SOP, websites resort to a multitude of different approaches to “patch” SOP. These can be classified into three categories:
- **Splitting One Single Principal:** Various approaches [6, 13]–[17] create a separated environment to isolate different web sessions or third-party content at one client. The new `iframe` tag in HTML5 [18] also supports a sandbox property to prevent access from the same origin.
- **Combining Multiple Principals at Server Side:** Many proposals [3]–[5] support Cross-Origin Resource Sharing (CORS). To support more fine-grained server-side merging, Content Security Policies (CSP) [19] and CSP-like mechanisms, such as SOMA [20], specify access control policies at the server side through HTTP headers or manifest files. Client browsers will be modified to enforce these specified policies.
- **Combining Multiple Principals at Client Side:** Since `document.domain`, which disobeys the least-privilege principle, is insecure [1], Gazelle [21] disables `document.domain` and proposes that sites use existing cross-principal communication channels, such as `postMessage`. Other work, such as Object Views [12], layers complexity on top of cross-principal communication channels to facilitate easier object sharing.

## II. Motivation and Related Work
This section motivates the work and presents SOP, SOP plus all the additions, and other non-SOPs, along with their limitations. A high-level comparison is shown in Table I.

### Limitations of Existing Additions to SOP
Fundamentally, all these approaches fix flexibility problems in SOP, and thus we highlight the limitations of all existing additions to SOP as follows:
- **Inconsistency:** After existing approaches split or merge different SOP principals, unlike traditional SOP principals with the fixed triple (`<scheme>://<host>:<port>`) as security labels, those newly created principals do not own such labels. When browsers or servers check the security label of a principal, they can only inspect the old SOP label, leading to a mismatch between the principal and its security label (origin). An attacker can utilize this mismatch to camouflage a principal’s identity and then fool a server or a browser with SOP origin, which is defined as an origin spoofing attack. We present the mismatch and its corresponding origin spoofing attack from two scenarios: for a separated principal and a merged one.
- **First, there is a mismatch between a separated principal and its origin.** For example, as supported by the new `iframe` feature in HTML5 [18], `a.com` can be separated into a gadget G1 (`a.com/benign`) and another gadget G2 (`a.com/malicious`) by specifying a sandbox property. In this case, G1 and G2 share the same SOP origin but have different security properties from `a.com`.
- **A concrete origin spoofing attack utilizing this HTML5 feature is shown below.** Suppose three frames, Integrator I (top), Attacker Frame A (middle), and Gadget G1 (bottom), are nested. Barth et al. [22] show that if G1 sends a message to I, the attack frame A can navigate its child frame G1 to a malicious one to receive the reply from A. Therefore, all up-to-date browsers check the SOP origin of the target frame in `postMessage`. However, after the HTML5 feature splits one single principal `a.com` into G1 and G2, the attacker can navigate the benign gadget G1 to a malicious one G2, causing the benign gadget to send messages to the attacker-controlled frame.