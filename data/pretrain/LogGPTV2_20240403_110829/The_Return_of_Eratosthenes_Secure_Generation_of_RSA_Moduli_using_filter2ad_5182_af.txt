1.188
[7]
2048
910
74.52
Ours
2048
243.30
1.99
Table 2: Communication per party (two parties). For [7] the
cost of the semi-honest protocol is based on the use of the OT
extension of Keller et al. [27]. We consider this to be a fair com-
parison, as the sampling protocol is the major bottleneck and
can be implemented using SilentOT. In our case the underly-
ingMPCengineforsamplingalsousedthesameOTextension.
Scheme
𝜅
SH (GB)
ML (GB)
[7]
1024
2.09
1020
Ours
1024
4.34
68.8
[7]
1536
6.24
4734
Ours
1536
12.17
153.20
[7]
2048
13.65
8100
Ours
2048
25.23
281.91
𝜅
𝑛
1024
2
16
2
1536
16
2
2048
16
per-phase cost for one instance (Megabits)
Sieving
BP test
Check
0.36
0.004
46.14
51.2
0.03
4344
0.5
0.006
68.42
73.5
0.04
8166
0.68
0.008
93.4
95.7
0.06
13185
expected cost to sample a biprime (GBytes)
E[Iter.]
E[Total]
3607
0.64
3607
68.8
7251
1.18
7251
153.2
11832
1.99
11832
281.91
Table 4: Communication per party: malicious case. The GCD
test is included in E[Total], as that is an one-time cost. Check
step happens 𝜎 times.
𝜅
𝑛
1024
2
16
2
1536
16
2
2048
16
Table 3: Communication per party malicious case (16 parties).
For [7] the cost of the semi-honest protocol is based on the
use of the OT extension of Keller et al. [27].
Sieving
BP test
per-phase cost for one instance (kilobits)
152.44
82.97
4.096
8.192
118.10
6.144
13175
49.152
9391
32
16784
65.536
expected cost to sample a biprime (megabytes)
We present the detailed per-phase cost for 2 and 16 parties, and
for 𝜆 = {1024,1536,2048} in Table 4 for the malicious case, and in
Table 5 for the semi-honest case.
Reducing the number of Input calls in generating bounded
randomness. In the maBit protocol designed in [35], each random
bit(cid:74)𝑏(cid:75) produced in the main MPC engine producing randomness
𝑘=02𝑘𝑏( 𝑗)
bit inputs at once, they can call FMPC.Input(15
is later fed into the other MPC engines by every party calling Input
command on a different sharing of 𝑏. By plugging their method
directly into our Rand2k protocol, in order to generate 𝑛𝐵 shared
bits with 𝑛 parties shared across ℓ engines will require 𝑛𝐵·𝑛 Input
calls to each of the ℓ 128 bit prime MPC engines.
We can reduce the number of input calls by a factor of
∼128−(𝜎+log2𝑚), where 𝑚 is the batch size for generating maBits.
The key insight is for parties to batch their bit shares instead of
inputting them one by one. For example, if they want to batch 16
mod 𝑚𝑖),
where 𝑏( 𝑗)
would be party 𝑃 𝑗’s share of the 𝑘𝑡ℎ bit in the maBit
protocol. We need to take into account now that the random linear
combination at the end is done over slightly larger secrets (16 bits in-
stead of a single one), so we need to increase the random coefficients
by 16 bits in order for the security reduction to go through easily. The
proof of this small optimization is relatively straightforward, since
one can use this as an oracle to solve the MSSP problem described
in [35] by simply scaling the random coefficients. To fit everything
in a 128-bit prime MPC engine, we pack 16 inputs together, while
maintaining a maBit batch of 215 bits produced at once.
The honest majority case with active security. Since our
protocol works with any actively secure protocol, where the secret
reconstruction is linear, we can instantiate it with the most efficient
protocols for MPC for large field arithmetic [9]. The cost analysis
of such an instantiation can be seen in Table 6.
𝑘
𝑘
3607
41.68
3607
4346
11832
E[Iter.]
E[Total]
25230
Table 5: Communication per party: semi-honest case.
7251
116.55
7251
12173
11832
243.3
𝜅
megabytes
1024
107.62
1536
227.41
2048
408.57
Table 6: Communication per party: malicious honest majority
case (3 parties).
ACKNOWLEDGEMENTS
We thank Ivan Damgård and Muthu Venkitasubramaniam for
their helpful discussions and the anonymous reviewers for their
comments and observations. This work has been supported in part
by ERC Advanced Grant ERC-2015-AdG-IMPaCT, by the Defense
Advanced Research Projects Agency (DARPA) under contract
No. HR001120C0085, and by CyberSecurity Research Flanders
with reference number VR20192203. Any opinions, findings and
conclusions or recommendations expressed in this material are
those of the authors and do not necessarily reflect the views of the
ERC, DARPA, the U.S. Government or Cyber Security Research
Flanders. The U.S. Government is authorized to reproduce and
distribute reprints for governmental purposes notwithstanding any
copyright annotation therein.
REFERENCES
[1] Joy Algesheimer, Jan Camenisch, and Victor Shoup. 2002. Efficient Computation
Modulo a Shared Secret with Application to the Generation of Shared Safe-Prime
Products. In CRYPTO 2002 (LNCS, Vol. 2442), Moti Yung (Ed.). Springer, Heidelberg,
Session 2D: Secure Multiparty Computation CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea605417–432. https://doi.org/10.1007/3-540-45708-9_27
[2] Toshinori Araki, Jun Furukawa, Yehuda Lindell, Ariel Nof, and Kazuma Ohara.
2016. High-Throughput Semi-Honest Secure Three-Party Computation with
an Honest Majority. In ACM CCS 2016, Edgar R. Weippl, Stefan Katzenbeisser,
Christopher Kruegel, Andrew C. Myers, and Shai Halevi (Eds.). ACM Press,
805–817. https://doi.org/10.1145/2976749.2978331
[3] Carsten Baum, Daniele Cozzo, and Nigel P. Smart. 2019. Using TopGear in
Overdrive: A More Efficient ZKPoK for SPDZ. In SAC 2019 (LNCS, Vol. 11959),
Kenneth G. Paterson and Douglas Stebila (Eds.). Springer, Heidelberg, 274–302.
https://doi.org/10.1007/978-3-030-38471-5_12
[4] Dan Boneh, Joseph Bonneau, Benedikt Bünz, and Ben Fisch. 2018. Veri-
fiable Delay Functions. In CRYPTO 2018, Part I (LNCS, Vol. 10991), Hovav
Shacham and Alexandra Boldyreva (Eds.). Springer, Heidelberg, 757–788.
https://doi.org/10.1007/978-3-319-96884-1_25
[5] Dan Boneh and Matthew K. Franklin. 1997. Efficient Generation of Shared RSA
Keys (Extended Abstract). In CRYPTO’97 (LNCS, Vol. 1294), Burton S. Kaliski Jr.
(Ed.). Springer, Heidelberg, 425–439. https://doi.org/10.1007/BFb0052253
[6] Lennart Braun, Daniel Demmler, Thomas Schneider, and Oleksandr Tkachenko.
2020. MOTION - A Framework for Mixed-Protocol Multi-Party Computation.
Cryptology ePrint Archive, Report 2020/1137. https://eprint.iacr.org/2020/1137.
[7] Megan Chen, Ran Cohen, Jack Doerner, Yashvanth Kondi, Eysa Lee, Schuyler
Rosefield, and abhi shelat. 2020. Multiparty Generation of an RSA Modulus. In
CRYPTO2020,PartIII (LNCS,Vol.12172),DanieleMicciancioandThomasRistenpart
(Eds.). Springer, Heidelberg, 64–93. https://doi.org/10.1007/978-3-030-56877-1_3
[8] Megan Chen, Carmit Hazay, Yuval Ishai, Yuriy Kashnikov, Daniele Micciancio,
Tarik Riviere, Abhi Shelat, Muthuramakrishnan Venkitasubramaniam, and Ruihan
Wang. 2020. Diogenes: Lightweight Scalable RSA Modulus Generation with a
Dishonest Majority. IACR Cryptol. ePrint Arch. 2020 (2020), 374.
[9] Koji Chida, Daniel Genkin, Koki Hamada, Dai Ikarashi, Ryo Kikuchi, Yehuda
Lindell, and Ariel Nof. 2018.
Fast Large-Scale Honest-Majority MPC for
Malicious Adversaries. In CRYPTO 2018, Part III (LNCS, Vol. 10993), Hovav
Shacham and Alexandra Boldyreva (Eds.). Springer, Heidelberg, 34–64.
https://doi.org/10.1007/978-3-319-96878-0_2
[10] Anders P. K. Dalskov, Claudio Orlandi, Marcel Keller, Kris Shrishak, and Haya
Shulman. 2020. Securing DNSSEC Keys via Threshold ECDSA from Generic
MPC. In ESORICS 2020, Part II (LNCS, Vol. 12309), Liqun Chen, Ninghui Li,
Kaitai Liang, and Steve A. Schneider (Eds.). Springer, Heidelberg, 654–673.
https://doi.org/10.1007/978-3-030-59013-0_32
[11] Ivan Damgård, Marcel Keller, Enrique Larraia, Valerio Pastro, Peter Scholl, and
Nigel P. Smart. 2013. Practical Covertly Secure MPC for Dishonest Majority
- Or: Breaking the SPDZ Limits. In ESORICS 2013 (LNCS, Vol. 8134), Jason
Crampton, Sushil Jajodia, and Keith Mayes (Eds.). Springer, Heidelberg, 1–18.
https://doi.org/10.1007/978-3-642-40203-6_1