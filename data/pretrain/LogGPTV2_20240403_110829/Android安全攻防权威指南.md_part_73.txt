用这一技术：http:/www.sourceware.org/ml/binutil/2004-01/msg00070.html。这个补丁标志着一种
新的缓解技术诞生，即只读重定位表（Read-OnlyRelocations，relro）。使用编译参数
-Wl，-z，relro，编译器生成的二进制文件就会启用这一保护。可以用readelf工具来判断某
个二进制文件是否已经使用了这一缓解措施，如下所示：
dev:~/android $ # cat binary from Android 1.5
dev:~/android $ readelf -h cat-g1 | grep RELRO
dev:~/android $  cat binary from Android 4.2.1
---
## Page 329
12.11增强源代码313
dev:-/android S readelf -h cat-gn-takju Igrep RELRO
GNU_RELRO
0x01d334 0x0001e3340x0001e3340x00cce 0x00ccc Rf0x4
然面，仅仅使用参数-Wl，-z，relro还不够；此时得到的是部分relro，GOT还是可写的。
要发挥这种缓解技术的最大能力，达到完全relro，还需要一个-W1，-z，now参数。下面的代码展
示了如何检查relro是否完全：
dev:~/android S readelf -d cat-gn-takju 1 gzep sO
0x0000001e(FLAGS)
0x6ftftftb (FLAGs_1)
BIND_NOW
F1ag8: NOW
增加新的参数后，linker会在程序启动时加载其所有依赖库（面不是延迟按需加载）。因为所
有依赖库都已经得到解析，所以linker不再需要更新GOT。这样，在该程序接下来的执行期间，
GOT就可以被标记为只读。由于这片内存区域是只读的，在不改变其权限的情况下无法写人数
据，因此任何试图写入GOT的行为都会导致该进程崩溃，从而使漏洞利用失败。
Android在2012年4月加人了这一缓解措施，将其作为4.1.1版的一部分发布。它使用了上
面这两个必需的参数，准确地实现了只读的GOT区域。相关的AOSPcommitid是233d460。NDK
则从8b版开始启用这个机制。此后，所有的AOSP和NDK都默认启用这个编译器选项。与格式
化字符申保护一样，用老版本NDK编译的源代码可能会存在此类漏润，开发者需要用新的NDK
重新编译。使用这个保护机制后，攻击者就无法再改写GOT或者执行其中保存的数据了。
12.10沙盒
自从Google Chrome发布以来，沙金已经在短短5年间成为一种非常流行的缓解技术。沙
盒的主要目的是进一步实现最小特权原则，主要方法是降低程序中部分代码的特权并减少其功
能。有一些代码由于质量较低或者面对不可信数据的暴露面更广，本身就有更高的风险。在受
限的环境中运行这些高风险代码，有助于防止攻击取得成功。例如，即便攻击者已经可以执行
任意代码，沙盒也可以防止攻击者访问敏感数据或者损害系统。目前Windows系统中的一些流
行软件都在一定程度上使用了沙盒技术，如 Microsoft Office、Adobe Reader、Adobe Flash Player
和Google Chrome等。
从第一版开始，Android就使用了某种形式的沙盒。第2章介绍了Android使用不同的用户
身份来隔离不同的进程。虽然这种形式的沙盒相当粗糙，但还算是一种有效的沙盒。此后，Android
4.1加人了隔离服务特性，允许应用程序创建使用不同用户ID的另一个隔离进程。基于这一特性，
Chrome for Android在运行Jelly Bean 的设备上使用的沙盒比之前版本 Android上的稍强一些。
Android的未来版本可能还会对此进行进一步加固，具体例子参阅12.18.1节。
12.11增强源代码
12
2004年，Linux 的长期贡献者JakubJelinck创建了源码增强缓解机制，用于防止一般性的缓
冲区溢出缺陷被利用。这个机制由两部分构成，分别在编译器和操作系统的C语言库中。如果在
---
## Page 330
314第12章漏洞利用缓解技术
编译源代码时启用优化，并传人-D_FORTIFY_SOURCE，编译器就会在传统易出错的函数周围包
裹另一层代码。C语言库中的这些包裹函数会以多种方式验证在运行时传人原始函数的参数。例
如，将传递给strcpy的目标缓冲区尺寸大小与源字符串的长度进行比较。如果试图复制的字节
超出目标缓冲区的大小，会导致验证错误和程序终止
strcpy只是许多被包裹起来的函数之一。哪些函数会被增强则取决于具体的实现。在Ubuntu
12.04的GCC编译器和C语言库中，有70多个函数被包裹起来。这种修改危险函数的通用性技
术非常强大，用处并不仅限于检查缓冲区溢出。事实上，如果将宏的值定义为2，就可以启用更
多的检查，包括一些对格式化字符串攻击利用的防御。
下面是在Ubuntu12.04x86_64机器上使用 FORTIFY_SOURCE的—个例子：
dev:~/android $ cat bof-test1.c
#inc1ude 
#inc1ude 
int main(int argc, char *argv[1) (
strepy (buf, argv[1]) ;
char buf [256]:
return 0;
dev:~/android $ gcc -D_poRrIFY_souacE=1 -O2 -fno-stack-protector -0 1
dev:~/android $ ,/test *ruby -e *puta *A* * 512*
test bof-test.c
+** buffer overflow detected ***;./test terminated
="....= Backtrace: *........
上面的测试程序是一个简单的人为构造示例，其中存在一个缓冲区溢出漏洞。尝试向缓冲区
复制过多字节时，程序检测到了即将发生的内存错误，然后终止了运行。
Android在4.2的开发过程中加人了对FORrIFY_SOURCE的实现。遗博的是，AndroidNDK
现在还没有支持它。Android对BionicC运行时库进行了一系列修改（commitid分别为0a23015、
71a18dd、cffdf66、9b549c3、8df49ad、965dbc6、f3913b5以及260bf8c），—共增强了15个最容
易犯错的函数。下面的代码检查了Android4.2.2的 libe.so库，用UbuntuCompilerFlags帮助页面
（https:/wikiubuntu.com/ToolChain/CompilerFlags）的一条命令得出这个统计结果：
dev:~/android/source $ arm-eabi-readelf -a \
]egrep.pumc._chk（ee]1s）·\
out/target/product/maguro/systen/1ib/1ibc.so
5//。/8t5//。/sB//s（\+[6-0]）/s，az-pes
egrep ^.*_chks*\
sed -re *8/~//g: 8/_chks//g*\
sort 1
15
在Android4.4之前，只有FORTIFY_SOURCE缓解技术的第1级（即值为1）得到了实现，
其中包含对缓冲区溢出的检查，但是没有实现对格式化字符串攻击的保护。Android的实现中甚
至加人了一些专门针对Bionic的扩展，比如检查传递给strlen函数以及strcpy和strlcat
---
## Page 331
12.12访问控制机制
315
这两个BSD风格函数的参数。Android4.4则实现了FORTIFY_SOURCE缓解的第2级。
在运行 Android 4.2.2的 Galaxy Nexus 设备上执行测试程序，来验证 FORTIFY_SOURCg 的效
果。编译环境是在一台Ubuntux86_64开发机上检出的AOSP代码库，标签号是android-4.2.2_r1。
下面的输出显示了测试的结果；
dev:~/android/soarce $ . bui1d/envsetup .h
dev:~/android/source $ 1unch fu11_maguro-userdebug
dev:~/android/source $ tar zxf -/ahh/bof-test.tgz
[... build proceeds ...]
out/target/product/maguro/syatem/bin/bof-test /data/loca1/tmp
dev:~/android/source $ adb push \
121 KB/s (5308 bytes in 0.042s)
dev:~/android/source $ adb she11
shel1@android:/ $ myvar=′busybox seq 1 260 1 busybox 8ed *8/ ,*/./* \
3- on xoqenq 1xenAes u- oqoe s /iptoxpuettoqs
1 busybox tr -d *\n*
sbe11eandroid:/ $ /data/loca1/tmp/bof-test Smyvar &
shel19android: / $
[1]   29074
[1] +Segmentation fault /data/1oca1/tmp/bof-test Sayvar
shell6android:/ S logcat -d | grep buffer
F/11bc
(29074):**·strcpy buffer overflow detected ***
这里使用了AOSP的构建系统来编译该程序，以验证FORTIFY_SOURCE是否为默认的编译
项。可以看到，程序再一次检测到即将出现的内存破坏，并且终止了运行。Android没有使用命
令行终端的输出界面，面是通过标准的1ogcat机制输出了这个错误。
尽管源代码增强技术非常强大，但并非没有缺点。首先，只有对于编译器已知大小的缓冲区，
FORTIFY_SOURCE才能生效。如果传给strCPY的目的指针指向可变大小的缓冲区，就无法验
证其长度了。其次，由于这一缓解机制需要在编译时使用特殊的参数，所以无法保护只有二进制
文件的旧组件。即便如此，FORTIFY_SOURCE依然是一个非常有用的缓解技术，可以有效防止
许多bug被利用。
12.12访问控制机制
使用访问控制技术，系统管理员可以限制其他用户在计算机系统中的行为。该技术主要有两
种类型：分布式访问控制（DiscretionaryAccessControl，DAC：又称自主访问控制）和集中式访
问控制（MandatoryAccess Control，MAC；又称强制访问控制）。还有一种机制叫作基于角色的
访问控制（Role-Based Access Control，RBAC），它与DAC和MAC类似，但是灵活性更好，可
12
以使用DAC和MAC中的要素。这些机制都能用于防止低权限用户访问有价值的系统资源或者
其无需访问的资源。
MAC和DAC虽然都用于保护资源不被访间，但是在控制方式上有很大区别：DAC允许用
---
## Page 332
316第12章漏洞利用缓解技术
户自已修改访问策略，而MAC的策略则完全由系统管理员控制。DAC的最佳例子是UNIX文件
系统权限：普通用户不需要系统管理员的授权就可以更改自己所拥有文件和目录的访问权限，从
面允许其他用户访问。MAC的相关例子是SELinux，系统管理员必须对每个人的访问权限进行
定义和维护。
从 2012 年到 2013 年年初，Stephen Smalley、Robert Craig、Kenny Root、Joshua Brindle 和
William Roberts 将SELinux移植到了Android。2013年4月，三星在Galaxy S4设备中实现了
SELinux。SELinux有 3种实施模式：disabled、permissive 和 enforcing。在 disabled 模式下,SELinux
存在但不发挥作用：在permissive模式下，SELinux会将违反策略的行为记录下来，但并不会阻
止这些行为；面enforcing模式会严格地实施所有策略，拒绝所有违反策略的访间。在GalaxyS4
上，默认的实施模式是permissive。三星在KNOX企业安全产品以及后来更新的Galaxy S4固件
版本中使用了enforcing模式。谷歌宣布了在Android4.3中对SELinux的官方支持，但是只采用
了permissive 模式。Android 4.4是第一个使用enforcing模式的官方版本。
SELinux并不是目前Android设备中唯一的访问控制解决方案。日本市场中的LGOptimusG
设备还使用了一种名为TOMOYO的MAC实现方案。在设备启动时，由ccs-init加载的TOMOYO
策略会防止 shell以root权限运行。此外，东芝的Excite平板电脑中有一个名为 sealime.ko的内核
模块，似乎是将SELinux移植到Android上的准备工作。
与其他缓解技术一样，MAC方案也有一定的不足。首要问题是，恰当的配置通常非常困难。
一般情况下，策略的开发需要将MAC设置成学习模式，然后进行被允许的操作供其学习。另一
种方法是，策略制定者花费很长时间针对所有被允许的情况人工制定规则。这两种方法都很容易
出错，因为总有一些得到允许的操作被忽略，或者作出不正确的假设。在审核基于访问控制机制
的系统安全性时，对这些策略进行评估最为重要。只要配置得当，无论使用的是哪种实现，MAC
都能让攻击者感到极其头痛。
12.13保护内核
多年来，许多研究人员（如PaX团队成员和 Brad Spengler）都致力于加固Linux内核。除
了（本章前面提到的）用户空间方面的工作，还有为了阻止内核本身被漏洞利用的工作。然面，
他们无法让自己的代码修改成功进人官方内核源代码，只有极少数研究人员（尤其是KeesCook、
DanRosenberg和Eric Paris）取得了有限的胜利。也就是说，说服内核维护者实现针对特定安全
问题的加固机制依然非常具有挑战性。从Kees和Eric的经历来看，要实现这些机制，首先开发
出针对某个Linux发行版的补丁文件很有帮助。本节接下来介绍Android设备中使用到的Linux
内核加固机制。
12.13.1指针和日志限制
kptr_restrict和dmesg_restrict是用于防止本地普通用户获得敏感内核内存地址信
息的内核设置。此前的内核漏洞利用通过读取虚拟文件系统来获得地址信息，这些信息的输出就
---
## Page 333
12.13保护内核
317
来自内核空间。漏洞利用的开发者可以在运行期间实时解析这些信息，从而不需要将地址硬编码
到利用代码中，这样编写的利用代码可以直接用于多种不同的系统。
kptr_restrict对内核的修改主要针对printk函数。具体来说，这些修改让内核开发者
可以在输出敏感内核指针值时使用epK这个特殊的格式化符。在printk函数内部，对于不同的
kptr_restrict值，这个格式化符的行为也不同。当kptr_restrict被设置成0时，这些值
会被直接输出；设置成1时，除非当前用户有CAP_SYSLOG权限，否则这些值会被替换为全0；
设置成2时，这些值总是会被替换为全0。如果一个进程试图访间sysfs和procfs文件系统中的条
目，例如/proc/kallsyms文件，这个保护措施就会运作起来。下面的输出来自运行Android4.2.1
的 Galaxy Nexus 设备：
she11eandroid:/ $ grep s1ab_a11oe /proe/ka11ayms
00000000 t __slab_a11oc.isra. 40.constprop .45
可以看到，地址没有被准确地打印出来，面是显示为8个0。
与此类似，dmesg_restrict可以阻止普通用户使用dmesg命令或klogctl函数访问内
核回环缓冲区（kemelringbuffer）。下面这段话来自提交给Linux内核邮件列表（LKML）的原
始补丁文件：
比起修改数百（甚至数千）条printk语句并砍掉有用的调试功能，创建一个阻止
普通用户读取syslog的选项要容易得多。
与持续维护可能泄露的敏感指针值相比，直接保护对内存回环缓冲区的访问确实更加轻松高
效。此外，有一些Linux内核开发者十分反对实现kptr_restrict所引起的改变。