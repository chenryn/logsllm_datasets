借助于一系列的CORS请求，攻击者就可以窃取用户钱包的加密备份，然后立即展开离线蛮力破解，就能得到该钱包的密码了。如果用户的密码强度不高的话，他们的比特币就会轻而易举地被攻击者收入囊中。
更加要命的是，这种特殊的错误配置非常常见——只要你肯找，就肯定能找到。实际上，只要选用`null`关键字，这就注定要出问题的，因为在某些应用程序中，如果没有配置源白名单的话，就会导致……
    Access-Control-Allow-Origin: null
这……
#### Breaking parsers
我们知道，大多数网站都是通过基本的字符串操作来验证Origin头部的，但有些网站却会将其解析为URL。这项研究最初发布三年后，[Bitwis3](https://twitter.com/fasthm00)发表了一种攻击解析器漏洞的技术，该技术利用了Safari对域名中非常规字符（unusual
characters）的容忍度。对于Safari来说，这面是一个有效的URL：
    http://example.com%60.hackxor.net/static/cors.html
并且，发自该URL的CORS请求将包含：
    Origin: http://example.com`.hackxor.net/
如果一个站点选择解析这个头部，它可能会认为这个主机名是`example.com`并反射它，这样的话，我们就能够攻击Safari用户——即使该站点使用的是受信任主机名的白名单。在收到Bitwis3提供的[tipoff](https://twitter.com/fasthm00/status/1168844190702161920)之后，我亲自在野外试用了这种技术，事实证明它是非常有效的。
#### Breaking HTTPS
在这项研究中，我还发现了另外两个流行的白名单在实现方面存在的漏洞，并且这些漏洞通常都是伴生的。其中，第一个漏洞是轻率地将所有子域都列入白名单所致——甚至包括根本就不存在的子域。许多公司的子域名都会指向由第三方托管的应用程序，而这些应用程序的安全性一般都很令人担忧。如果天真地认为这些程序中没有XSS漏洞，并且将来也不会有的话，那么，这就只能怪自己太幼稚了。
第二个常见漏洞是无法限制源协议。如果一个网站是通过HTTPS访问的，同时还乐于接受来自`http://wherever`的CORS交互的话，那么攻击者一旦发起主动中间人（MITM）攻击，那么就可以完全绕过该站点的HTTPS。并且，HTTP
Strict Transport
Security功能和cookie的`secure`属性在防止这种攻击方面的作用几乎可以忽略不计。对于这种攻击的具体过程，请参阅我的演讲文稿。
#### Abusing CORS without credentials
我们已经看到，启用凭证后，CORS将变得非常危险。如果没有凭证，许多攻击将无计可施；这意味着，无法使用用户的cookie，这样的话，让用户的浏览器发送请求，与自己发送请求一样，根本无法获得更多的优势。即使是令牌固定攻击也是行不通的，因为浏览器会忽略对cookie进行的任何重设。
一个值得注意的例外是，当受害者的网络位置作为一种身份验证的时候。这种情况下，您可以使用受害者的浏览器作为代理来绕过基于IP的身份验证，进而得以访问Intranet应用程序。就危害程度来说，这种漏洞与DNS重新绑定类似，但要攻击过程要更加费劲一些。
#### Vary: origin
如果您仔细阅读CORS规范中的“实现方面的注意事项”部分就会发现，它要求开发人员在动态生成`Access-Control-Allow-Origin`头部时，同时指定HTTP头部`Vary: Origin`。
这听起来可能很简单，但是很多人都忘了下面这句涉及W3C自身的[名言](https://lists.w3.org/Archives/Public/public-webappsec/2016Jun/0057.html)：
> 我必须说，即使W3C都没能正确配置其服务器，所以，我很难相信会有更多网站迅速支持CORS。
>
>   * Reto Gmür
>
如果我们忽视这个忠告，结果会怎样呢？大多数情况下，人们就是这样做的。然而，在适当的情况下，它可能导致一些相当严重的攻击。
#### Client-Side cache poisoning
有时候，我们会遇到含有反射型XSS漏洞的页面，并且该漏洞位于自定义HTTP头部中。假设该网页并没有对响应该自定义头部的内容进行编码：
    GET / HTTP/1.1\
    Host: example.com\
    X-User-id: 
    HTTP/1.1 200 OK\
    Access-Control-Allow-Origin: *\
    Access-Control-Allow-Headers: X-User-id\
    Content-Type: text/html\
    ...\
    Invalid user: 
如果不借助CORS的话，该漏洞是无法利用的，因为没有办法让某人的浏览器跨域发送`X-User-id`头部。使用CORS后，我们就可以让他们发送这种请求。当然，就其本身来说，这是无用的，因为包含我们注入的JavaScript代码的响应是不会被呈现的。但是，如果未指定`Vary：Origin`的话，那么，该响应可以存储到浏览器的缓存中，并在浏览器导航到相关的URL时立即显示。我已经创建了一个fiddle，用来演示[针对您选择的URL进行攻击](https://jsfiddle.net/3gk8u8wu/3/)。由于这种攻击使用了客户端缓存，因此，它非常可靠。
#### Server-side cache poisoning
当万事俱备的时候，我们就能通过HTTP头部注入技术，利用服务器端缓存中毒来创建存储型XSS漏洞了。
如果应用程序会响应`Origin`头部，并且不检查它是否为`\r`之类的非法字符的话，那么，我们实际上就获得了一个针对IE/Edge浏览器用户的HTTP头部注入漏洞，因为Internet
Explorer和Edge浏览器会将`\r\n（0x0d）`视为有效的HTTP头部终止符：
    GET / HTTP/1.1\
    Origin: z[0x0d]Content-Type: text/html; charset=UTF-7`
    Internet Explorer将该响应视为： 
    `HTTP/1.1 200 OK\
    Access-Control-Allow-Origin: z\
    Content-Type: text/html; charset=UTF-7
不过，这个漏洞是无法直接利用的，因为攻击者无法让某人的网络浏览器发送这种畸形的头部；然而，我们可以利用Burp
Suite手动构造这种请求，然后，服务器端缓存很可能会保存相应的响应，并将其提供给其他人。我们使用的payload会将页面的字符集改为`UTF-7`，这一招对构造XSS漏洞来说非常有用。
#### Good intentions and bad results
最初，我并没想到动态生成`Access-Control-Allow-Origin`头部的网站的数量是如此之多。之所以出现这种情况，可能是CORS的两个主要限制所致——既不允许在单个头部中指定多个域，也不允许使用通配符指定子域。这使得许多开发人员别无选择，只能动态生成相应的头部，这样一来，就不得不面对以上讨论的各种实现方面容易出现的漏洞了。在我看来，如果规范得作者和浏览器允许使用源列表和部分通配符的话，动态头部生成和相关漏洞的数量将会直线下降。
浏览器的另一个可改进的地方在于，不妨将通配符+凭证异常应用于域为`null`的情形。目前，使用`null`的域的危险性要远甚于使用通配符的域，尽管很多人会对此感到非常惊讶，但是事实的确如此。
其他浏览器也可以尝试阻止我发明的“反向混合内容”攻击——HTTP站点使用CORS从HTTPS站点窃取数据。不过，我还不是很清楚这会造成什么样的后果。
简单性和安全性原本是可以相辅相成的，但是，由于浏览器不支持声明多个域，从而将复杂性直接转移到了开发人员那里，从而带来了严重的恶果。我认为，这主要归咎于规范的设计以及实现的难度方面。
#### Conclusion
CORS是一种功能强大技术，使用时需要格外谨慎，因为，危险的攻击方法并不总是需要精湛的技能和错综复杂的攻击链——通常情况下，只需要对规范有基本的了解和一点点的专注就足够了。如果您想图省劲的话，这里告诉您一个好消息，目前Burp
Suite的扫描器已经能够识别并报告文中讨论的所有缺陷了。