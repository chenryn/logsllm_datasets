10
V11
V12
V13
272
---
## Page 297
第7章图
adjvex
0v。
宜
一
4
v
2△
2V
9
5△
13
2△
2v
53V
2
一
8△]
61V
2V,
2v]
9
v
自
101V
2V
121V
△
132VuA
图7-8-2
在拓扑排序算法中，涉及的结构代码如下。
typedef struct EdgeNode
边表结点*/
int adjvex;
/都接点域，存储该顶点对应的下标·/
int weight;
/用于存储权值，对子非网图可以不需要*/
structEdgeNode*next;/·链域，指向下一个都接点*/
)EdgeNode;
typedef struct VertexNode
顶点表结点/
int in;
1顶点入度
int data;
/顶点城，存储顶点信息·
/边表头指针/
)VertexNode,AdjList[MAXVEX];
typedef struct
AdjList adjList;
int numVertexes,numEdges;
图中当前项点数和边数*/
lgraphAdjList,*GraphAdjList:
在算法中，我还需要辅助的数据结构一栈，用来存储处理过程中入度为0的顶
273
---
## Page 298
大调数据结构
点，目的是为了避免每个查找时都要去遍历顶点表找有没有入度为0的顶点。
现在我们来看代码，并且模拟运行它。
/*拓扑排序，若GL无回路，则输出拓扑排序序列并返图OK，若有回路返回ERROR*/
1
Status TopologicalSort(GraphAdjList GL)
EdgeNode*ei
int i,k,gettop;
5
inttop=0；/用子栈指针下标*/
6
intcount=0：/*用于统计输出顶点的个数*/
7
int*stack;/*建栈存储入度为0的项点·/
8
stack-（int*）malloc（GL->numVertexes·sizeof（int））;
9
for（i=0;inumVertexes;i++）
10
if （GL->adjList[i].in==0)
11
stack[++top]-i;
/将入度为0的顶点入栈*/
12
while（top1=0）
13
14
gettop=atack[top--];/出栈·/
15
（[]-adjList[gettop].firstedge;e;e=e->next)
18
1/·对此顶点强表通历·/
19
k=e->adjvex;
20
t（！（--GL->adjLiat[k].in））/*将k号项点邻接点的入度减1*/
21
stack[++top]-k/*若为0则入栈，以使于下次循环输出*/
22
23
24
if（countnumVertexes）/·如果count小于项点数，说明存在环*/
25
return ERROR;
26
else
27
return OK;
281
1.程序开始运行，第3~7行都是变量的定义，其中stack是一个栈，用来存储整
型的数字。
2.第8~10行，作了一个循环判断，把入度为0的顶点下标都入栈，从图7-8-3
的右图邻接表可知，此时stack应该为：{0，1，3}，即ve、V1、v的顶点入
274
---
## Page 299
第7章图
度为0，如图7-8-3所示。
V3
1A
Vo
stack
图7-8-3
3.第12~23行，whil循环，当栈中有数据元素时，始终循环。
4.第14~16行，Vs出栈得到gettop=3。并打印此顶点，然后count加1。
5.第17~22行，循环其实是对vs顶点对应的弧链表进行遍历，即图7-8-4中的
灰色部分，找到v连接的两个顶点v2和V13，并将它们的入度减少一位，此
时v2和vi3的in值都为1。它的目的是为了将vs顶点上的弧删除。
此入度改为1
22v十
6
30V,
132V
此入度改为1
V3
V1
Vo
tacl
图7-8-4
6.再次循环，第12~23行。此时处理的是顶点v1。经过出栈、打印、count=2
后，我们对v到v2、V4、Vg的弧进行了遍历。并同样减少了它们的入度数，
此时v2入度为0，于是由第20~21行知，v2入栈，如图7-8-5所示。试想，
如果没有在顶点表中加入in这个入度数据域，20行的判断就必须要是循环，
275
---
## Page 300
大语数据结构
这显然是要消耗时间的，我们利用空间换取了时间。
此入度改为0，因此入栈
2△
2|1v
9
十9
2
此入度改为1
V2
Vo
stack
图7-8-5
7.接下来，就是同样的处理方式了。图7-8-6展示了v2V6VoV4VsV的打印删除
过程，后面还剩几个顶点都类似，就不图示了。
V6
H
图4
276
---
## Page 301
第7章图
V
V
图5
图6
图7-8-6
8.最终拓扑排序打印结果为3->1->2->6->0->4->5->8->7->12->9->10->13->11。
当然这结果并不是唯一的一种拓扑排序方案。
分析整个算法，对一个具有n个顶点e条弧的A0V网来说，第8~10行扫描顶
点表，将入度为0的顶点入栈的时间复杂为0（n），面之后的while循环中，每个顶点
进一次栈，出一次栈，入度减1的操作共执行了e次，所以整个算法的时间复杂度为
O[n+e)。
7.9关键路径
拓扑排序主要是为解决一个工程能否顺序进行的问题，但有时我们还需要解决工
程完成需要的最短时间问题。比如说，造一辆汽车，我们需要先造各种各样的零件、
部件，最终再组装成车，如图7-9-1所示。这些零部件基本都是在流水线上同时生产
的，假如造一个轮子需要0.5天时间，造一个发动机需要3天时间，造一个车底盘需
要2天时间，造一个外壳需要2天时间，其他零部件时间需要2天，全部零部件集中
到一处需要0.5天，组装成车需要2天时间，请问，在汽车厂造一辆车，最短需要多
少时间呢？
图7-9-1
277
---
## Page 302
大语数据结构
有人说时间就是全部加起来，这当然是不对的。我已经说了前提，这些零部件都
是分别在流水线上同时生产的，也就是说，在生产发动机的3天里，可能已经生产了
6个轮子，1.5个外壳和1.5个底盘，面组装车是在这些零部件都生产好后才可以进
行。因此最短的时间其实是零部件中生产时间最长的发动机3天+集中零部件0.5天+
组装车的2天，一共5.5天完成一辆汽车的生产。
因此，我们如果要对一个流程图获得最短时间，就必须要分析它们的拓扑关系，
并且找到当中最关键的流程，这个流程的时间就是最短时间。
因此在前面讲了AOV网的基础上，我们来介绍一个新的概念。在一个表示工程的
带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续
时间，这种有向图的边表示活动的网，我们称之为AOE网（AcivityOnEdge
Network）。我们把AOE网中没有入边的顶点称为始点或源点，没有出边的顶点称为
终点或汇点。由于一个工程，总有一个开始，一个结束，所以正常情况下，AOE网只
有一个源点一个汇点。例如图7-9-2就是一个AOE网。其中vo即是源点，表示一个
工程的开始，V9是汇点，表示整个工程的结束，顶点Vo，V1，，V9分别表示事
件，弧，，.….，都表示一个活动，用ao，a1，..…，a12表
示，它们的值代表着活动持续的时间，比如弧就是从源点开始的第一个活动
ao，它的时间是3个单位。
源点
V
汇点
V2
V8
图7-9-2
既然AOE网是表示工程流程的，所以它就具有明显的工程的特性。如有在某顶点
所代表的事件发生后，从该顶点出发的各活动才能开始。只有在进入某顶点的各活动
都已经结束，该顶点所代表的事件才能发生。
尽管AOE网与AOV网都是用来对工程建模的，但它们还是有很大的不同，主要
体现在AOV网是顶点表示活动的网，，它只描述活动之间的制约关系，而AOE网是用
边表示活动的网，边上的权值表示活动持续的时间，如图7-9-3所示两图的对比。因
278
---
## Page 303
第7章图
此，AOE网是要建立在活动之间制约关系没有矛盾的基础之上，再来分析完成整个工
程至少需要多少时间，或者为缩短完成工程所需时间，应当加快哪些活动等问题。
AOV网
造外壳
造发动机
开始
造轮子
集中组装完成
造底盘
其它零部件
AOE网
外壳完成
发动机完成
开始
轮子完成5
部件集中到位）
组装完成
（底盘完成
（其它零部件）
我们把路径上各个活动所持续的时间之和称为路径长度，从源点到汇点具有最大
长度的路径叫关键路径，在关键路径上的活动叫关键活动。显然就图7-9-3的A0E网