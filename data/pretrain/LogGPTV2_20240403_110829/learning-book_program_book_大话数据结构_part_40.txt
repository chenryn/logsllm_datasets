## 第七章 图

### 7.8 拓扑排序

#### 7.8.1 数据结构定义
在拓扑排序算法中，涉及的主要数据结构如下：

```c
typedef struct EdgeNode {
    int adjvex;  // 邻接点域，存储该顶点对应的下标
    int weight;  // 权值域，对于非网图可以不需要
    struct EdgeNode* next;  // 链域，指向下一个邻接点
} EdgeNode;

typedef struct VertexNode {
    int in;  // 顶点入度
    int data;  // 顶点域，存储顶点信息
    EdgeNode* firstedge;  // 边表头指针
} VertexNode, AdjList[MAXVEX];

typedef struct {
    AdjList adjList;  // 邻接表
    int numVertexes, numEdges;  // 图中当前顶点数和边数
} GraphAdjList, *LGraphAdjList;
```

在算法中，还需要辅助的数据结构——栈，用来存储处理过程中入度为0的顶点，以避免每次查找时都要遍历顶点表。

#### 7.8.2 算法实现
以下是拓扑排序的代码实现，并附上运行模拟：

```c
Status TopologicalSort(GraphAdjList GL) {
    EdgeNode* e;
    int i, k, gettop;
    int top = 0;  // 用于栈指针下标
    int count = 0;  // 用于统计输出顶点的个数
    int* stack;  // 建栈存储入度为0的顶点
    stack = (int*)malloc(GL->numVertexes * sizeof(int));

    for (i = 0; i < GL->numVertexes; i++) {
        if (GL->adjList[i].in == 0)
            stack[++top] = i;  // 将入度为0的顶点入栈
    }

    while (top != 0) {
        gettop = stack[top--];  // 出栈
        printf("%d -> ", gettop);  // 打印此顶点
        count++;

        for (e = GL->adjList[gettop].firstedge; e; e = e->next) {
            k = e->adjvex;
            if (--GL->adjList[k].in == 0)  // 将k号顶点邻接点的入度减1
                stack[++top] = k;  // 若为0则入栈，以便下次循环输出
        }
    }

    if (count < GL->numVertexes)  // 如果count小于顶点数，说明存在环
        return ERROR;
    else
        return OK;
}
```

**运行模拟：**

1. **初始化：**
   - 第3~7行定义了变量，其中`stack`是一个栈，用来存储整型数字。
   - 第8~10行通过一个循环判断，将入度为0的顶点下标入栈。例如，从图7-8-3的右图邻接表可知，此时`stack`应为 `{0, 1, 3}`，即`V0, V1, V3`的顶点入度为0。

2. **主循环：**
   - 第12~23行是一个`while`循环，当栈中有数据元素时，始终循环。
   - 第14~16行，`V3`出栈得到`gettop=3`，并打印此顶点，然后`count`加1。
   - 第17~22行，对`V3`顶点对应的弧链表进行遍历，找到`V3`连接的两个顶点`V2`和`V13`，并将它们的入度减少一位。此时`V2`和`V13`的`in`值都为1。目的是删除`V3`顶点上的弧。

3. **后续处理：**
   - 再次循环，处理顶点`V1`。经过出栈、打印、`count=2`后，对`V1`到`V2`、`V4`、`V8`的弧进行了遍历，并减少了它们的入度数。此时`V2`入度为0，于是`V2`入栈。
   - 接下来，继续同样的处理方式。最终拓扑排序打印结果为 `3 -> 1 -> 2 -> 6 -> 0 -> 4 -> 5 -> 8 -> 7 -> 12 -> 9 -> 10 -> 13 -> 11`。

**时间复杂度分析：**
- 对于具有`n`个顶点和`e`条弧的AOV网，第8~10行扫描顶点表的时间复杂度为`O(n)`。
- 而之后的`while`循环中，每个顶点进一次栈，出一次栈，入度减1的操作共执行了`e`次，所以整个算法的时间复杂度为`O(n + e)`。

### 7.9 关键路径

拓扑排序主要解决工程能否顺序进行的问题，但有时我们还需要解决工程完成所需的最短时间问题。例如，在汽车制造中，我们需要先造各种零部件，再组装成车。这些零部件基本都是在流水线上同时生产的。因此，最短的时间其实是零部件中生产时间最长的部分加上集中零部件和组装车的时间。

#### 7.9.1 AOE网
在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间。这种有向图称为AOE网（Activity On Edge Network）。AOE网中没有入边的顶点称为始点或源点，没有出边的顶点称为终点或汇点。正常情况下，AOE网只有一个源点和一个汇点。

#### 7.9.2 关键路径
路径上各个活动所持续的时间之和称为路径长度，从源点到汇点具有最大长度的路径叫关键路径，在关键路径上的活动叫关键活动。显然就图7-9-3的AOE网来说，关键路径决定了工程的最短完成时间。

通过分析AOE网的关键路径，我们可以确定哪些活动是关键活动，从而优化工程流程，缩短完成工程所需的时间。