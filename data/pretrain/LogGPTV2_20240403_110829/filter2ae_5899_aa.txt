# 邮件伪造组合拳
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
作者：Imanfeng
## 0x00 前言
此前进行邮件伪造，主要使用近似域名或者使用Smtp2go来进行发信绕过。上个月发现一个邮件伪造工具
[espoofer](https://github.com/chenjj/espoofer)，通过对工具和相关Paper的学习本文将以涉及的相关技巧展开。
  * Black Hat USA 2020 slides (PDF): [You have No Idea Who Sent that Email: 18 Attacks onEmail Sender Authentication](http://i.blackhat.com/USA-20/Thursday/us-20-Chen-You-Have-No-Idea-Who-Sent-That-Email-18-Attacks-On-Email-Sender-Authentication.pdf)
  * USENIX security 2020 paper (PDF): [Composition Kills: A Case Study of Email Sender Authentication](https://www.usenix.org/system/files/sec20fall_chen-jianjun_prepub_0.pdf)
由于某项目的开始月初搁置了文章整理，近日发出来与大家分享学习。
## 0x01 邮件传输
SMTP协议是基于TCP协议，也要进行三次握手
  1. 建立连接
  2. 传输数据
  3. 断开连接
在邮件传输过程中会提到的两个From：
① MAIL FROM：在SMTP认证中代表是谁发的，后面统称Smtp.From；  
② Message FROM：定义在邮件内容Header中，呈现给收件人的From字段，在后面统称Message.From
一个完整的发信简图如下，可以发现在原生SMTP整个过程中并没有任何身份校验的机制，HELO/MAIL FROM（Smtp.From）
以及From（Message.From）均是可控可定义的。
## 0x02 邮服防护
###  SPF
主要作用是校验发信服务器IP地址，防止发件人欺骗
假设b.com邮件服务器收到了一封邮件，发送主机的 IP
是1.2.3.4，并且声称自己的Smtp.From字段为[PI:EMAIL](mailto:PI:EMAIL)。为了确认发件人不是伪造的，邮件服务器b.com会去查询a.com的
SPF 记录。如果该域不存在SPF即随便伪造；如果存在 SPF 记录并且设置允许 IP 为1.2.3.4的主机发送邮件，则服务器就认为这封邮件是合法的，如果
IP 不在允许范围内，则大多数情况会显示为代发标识
###  DKIM
主要作用是校验邮件标头签名信息，防止邮件内容篡改
在a.com的DNS上设置DKIM公钥，假设通过a.com发送邮件，邮件服务器使用提前配置的私钥加密邮件相对应内容，生成DKIM-Signature签名及相关信息插入到邮件标头中；当b.com邮件服务器收到了邮件时，通过DNS查询获得此前配置的对应公钥，验证邮件DKIM签名的有效性，从而确认在邮件发送的过程中邮件是否篡改  
DKIM签名结构如下所示：
      DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
          d=anxus.top; l=1850; s=selector; t=1452769712;
          h=date:from:from:to:message-id:subject:mime-version;
          bh=yCbsFBJJ9k2VYBxKGgyNILalBP3Yzn1N8cMPQr92+zw=;
          b=bnuXrH/dSnyDR/kciZauK4HTgbcDbSFzmHR78gq+8Cdm20G56Ix169SA...
a：签名算法  
c：用于对标头和正文的[算法规范化](https://tools.ietf.org/html/rfc4871#section-3.4)，simple&relaxed  
d：是这一个域的签名。在DMARC检查签名中的域是否和发送者的域相匹配中用到  
q：定义用于检索DKIM公钥的查询方法。它不必存在，默认为“ dns / txt”  
s：在DNS中寻找RSA密钥的参数  
h：应该包含在签名中的邮件头字段列表  
bh：邮件正文的hash  
b：是签名本身的核心，包括’h’给出的字段，以及DKIM-Signature头本身(视b=为空)
> public_key = dkim_find_key(q_val, d_val, s_val)
###  DMARC
只有SPF与DKIM其实并不能真正对邮件的发件人进行身份验证：因为SPF只能对Smtp.From进行来源IP的验证，DKIM只能保证对应内容不被篡改，但收信人真正看见的字段是定义在邮件头中的Message.From，两者无法保证该字段是真实的。
故在2015年3月发布的文档[RFC
7489](https://tools.ietf.org/html/rfc7489)定义了DMARC，其中引入标识符对齐机制（Identifier
Alignment）：作用是确保通过SPF/DKIM校验的域名与Message.From发件人地址可以对齐匹配，从而保证最终用户看到的来源地址是真实可信的。
DMARC有两种对齐匹配机制：严格模式和宽松模式
  * 严格模式，两个域必须相同才能彼此对齐，例如SPF标识符对齐Demo：  
Smtp.From为：
        [PI:EMAIL](mailto:PI:EMAIL)
邮件头内容为：
        From: [PI:EMAIL](mailto:PI:EMAIL)
    Date: Fri, Feb 15 2002 16:54:30 -0800
    To: [PI:EMAIL](mailto:PI:EMAIL)
    Subject: Hi!
例如DKIM标识符对齐DEMO：
        d=360.cn
邮件头内容为：
        From: [PI:EMAIL](mailto:PI:EMAIL)
    Date: Fri, Feb 15 2002 16:54:30 -0800
    To: [PI:EMAIL](mailto:PI:EMAIL)
    Subject: Hi!
  * 宽松模式，两个组织域（主域名）相同时两个域即对齐，例如SPF表示符对齐Demo：  
Smtp.From为
        [PI:EMAIL](mailto:PI:EMAIL)
邮件头内容为
        From: [PI:EMAIL](mailto:PI:EMAIL)
    Date: Fri, Feb 25 2019 03:14:20 -1200
    To: [PI:EMAIL](mailto:PI:EMAIL)
    Subject: Hi!
例如DKIM标识符对齐DEMO：
        d=lintonlab.360.cn
邮件头内容为
        From: [PI:EMAIL](mailto:PI:EMAIL)
    Date: Fri, Feb 25 2019 03:14:20 -1200
    To: [PI:EMAIL](mailto:PI:EMAIL)
    Subject: Hi!
DMARC除了进行对齐校验外，还可以配置处理的策略，如下图所示：
    p：用于告知收件方，当检测到某邮件存在伪造发件人的情况，收件方要做出什么处理：reject为拒绝该邮件；none为不作任何处理；quarantine为将邮件标记为垃圾邮件
    sp：规定子域的处理策略
    rua：发送综合反馈的邮件地址
    ruf：发送消息详细故障信息的邮件地址
    dkim：要求dmarc对于dkim的对齐标准
    aspf：要求dmarc对于spf的对齐标准
邮件通过DMARC检测的流程如下图所示：
1.邮件发送  
2.接收方从邮件中取出字段Message.From的domain  
3.使用domain字段与SPF/DKIM的上述domain经过对齐校验（默认为宽松对齐）  
4.SPF/DKIM均通过校验并且其domain通过对齐校验  
5.通过DMARC校验，收到邮件
## 0x03 邮件绕过
正常发收件​​​​认证流程如下：
1.Alice定义内容发送邮件  
2.SPF校验发送ip是否在DNS记录ip范围【HELO&MAIL FROM】  
3.DKIM查询DNS中的公钥校验邮件头签名准确性【签名校验】  
4.DMARC对齐校验【domain】  
5.Bob收到邮件
**_最核心的思想就是利用不同组件传递过程中的差异性进行绕过_**
###  Ⅰ.校验歧义性绕过
**① 不存在子域差异性**
关于SPF以及DMARC官方有特殊定义：
1.SMTP定义了身份标识符有HELO 和 MAILFROM(Smtp.From)  
2.SPF同时检测HELO 和 MAILFROM，有一个失败即SPF校验失败  
3.DMARC校验SPF时默认使用MAILFROM进行对齐，当MAILFROM为空会使用HELO进行对齐校验
利用流程（Espoofer – server_a1）：
1.HELO及MAIL FROM恶意字段如上图所示；  
2.MAIL
FROM的域名字段是子域名并没有配置SPF，故进行SPF校验时是查询不到，但查询不到并不会被判断为SPF校验失败！与此同时HELO是可以通过SPF判断，故SPF通过；  
3.DMARC优先使用Smtp.From的domain与Message.From的domain进行对齐，此时是可以通过宽松模式对齐的，故DMARC通过（没有强制要求严格模式对齐的情况下）。
这种绕过情况下由于Smtp.From与Message.From不一致，部分邮件接收方会进行一个代发提示，如下图所示：
此时可利用场景为，将子域名定义为mail、office等进行官方发件的伪装，前提是子域不存在SPF记录。apple.com的子域一直可以解析到spf记录，故此方法是无法绕过的
**② MAIL FROM置空差异性**
该利用点在于不同校验组件对”空”的Smtp.From字段处理方式不同（Espoofer – server_a2）：
1.部分SPF组件会将“([PI:EMAIL](mailto:PI:EMAIL)”视为空的Smtp.From，那么就会转向对HELO进行SPF校验并且顺利通过；  
2.到后面DMARC组件并不认为它是空地址，故会继续使用Smtp.From=legitimate.com与Message.From=legitimate.com进行对齐校验，故存在绕过SPF&DMARC的可能。
**③ 解析截断差异性**
该利用点在于不同校验组件会存在解析截断，从而造成差异性绕过：
利用流程（Espoofer – server_a3）：
1.攻击者在attack.com解析中添加公钥，构造DKIM头通过私钥加密需要加密的信息进行发送；  
2.邮件服务器原本公钥构造应该为 **attack.com.\x00.any._domainkey.bank.com**
（s+[._domainkey.]+d）；  
3.由于部分语言如C在解析过程中会存在\x00截断，导致接收方服务器处理后获取公钥的地址直接为attack.com，该内容可控故存在绕过。