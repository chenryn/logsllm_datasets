212: end while
end if
breakpoint;
loc ← loc + 1;
else if key = ‘↓’ then
loc ← loc − 1;
else if key = ‘↑’ then
(a) A toy game client . . .
(b) . . . instrumented to run sym-
bolically
Figure 1. Example game client
For example, consider the toy game client in Figure 1(a).
This client reads a keystroke from the user and either incre-
ments or decrements the value of the location variable loc
based on the key that was read. The new location value is
then sent to the server, and the client loops to read a new key
from the user. Although a toy example, one can imagine it
forming the basis for a Pong client.
To prepare for symbolic execution, we modify the pro-
gram slightly, as shown in Figure 1(b). First, we initialize
the variable key not with a concrete input value read from
the user (line 103) but instead as an unconstrained symbolic
variable (line 203). We then replace the instruction to send
output to the server (line 111) with a breakpoint in the sym-
bolic execution (line 211). Finally, we create a new sym-
bolic state variable, prev loc (line 200), which will repre-
sent the game state up to this point in the execution. The
state variable loc will be initialized to this previous state
(line 201).
Symbolically executing this modiﬁed program, we see
that there are four possible paths through the main loop that
the client could take in any given round. In the ﬁrst pos-
sible path, key is ESC, and the game ends. Note that this
branch never reaches the breakpoint. The second and third
possible paths are taken when key is equal to ‘↑’ and ‘↓’, re-
spectively. The ﬁnal path is taken when key is none of the
aforementioned keys. These last three paths all terminate at
the breakpoint.
Via symbolic execution, the veriﬁer can obtain the con-
straints for all symbolic variables at the time each path
reached the breakpoint. Because we artiﬁcially created
prev loc during the instrumentation phase, it remains an
unconstrained symbolic variable in all three cases. The state
variable loc, however, is constrained differently on each of
the three paths. In the case when key is equal to ‘↑’, sym-
bolic execution reports loc = prev loc + 1 as the only con-
straint on loc. When key is equal to ‘↓’, the constraint is
that loc = prev loc − 1. And when key is not ‘↑’, ‘↓’, or
ESC, the constraint is that loc = prev loc.
Therefore, there are three possible paths that can lead to
a message being sent to the server. If the server receives
a message from a client — and the client is a valid client
— then the client must have taken one of these three paths.
Since each path introduces a constraint on the value of loc
as a function of its previous value, the veriﬁer can take the
disjunction of these constraints, along with the current and
previous values of loc (which the server already knows) and
see if they are all logically consistent. That is, the veriﬁer
can check to see if the change in values for loc match up to
a possible path that a valid game client might have taken.
If so, then this client is behaving according to the rules of
a valid game client. The disjunction of round constraints in
this case is:
(loc = prev loc + 1) ∨
(loc = prev loc − 1) ∨
(loc = prev loc)
(1)
For example, suppose the veriﬁer knows that the client
reported on its previous turn that its loc was 8. If the client
were to then report its new location as loc = 9, the veriﬁer
could simply check to see if the following is satisﬁable:
(prev loc = 8) ∧ (loc = 9) ∧ [ (loc = prev loc + 1) ∨
(loc = prev loc − 1) ∨
(loc = prev loc)
]
Of course, it is satisﬁable, meaning that the new value loc =
9 could in fact have been generated by a valid game client.
Suppose, though, that in the next turn, the client reports his
new position at loc = 12. Following the same algorithm,
the veriﬁer would check the satisﬁability of
(prev loc = 9)∧(loc = 12)∧[ (loc = prev loc + 1) ∨
(loc = prev loc − 1) ∨
(loc = prev loc)
]
Because these round constraints are not satisﬁable, no valid
game client could have produced the message loc = 12 (in
this context). Therefore, the veriﬁer can safely conclude
that the sender of that message is running an incompatible
game client — is cheating.
There are also constraints associated with the variable
key. We have omitted these here for clarity, showing only
the constraints on loc. We have also omitted the constraints
generated by the preamble of the loop, which in this case are
trivial (“loc = 0”) but in general would be obtained by ap-
plying symbolic execution to the preamble separately. Had
there been any random coin ﬂips or reading of the current
time, the variables storing the results would also have been
declared symbolic, and constraints generated accordingly.
While ﬁle input (e.g., conﬁguration ﬁles) could also be de-
clared symbolic, in this paper we generally assume that such
input ﬁles are known to the veriﬁer (e.g., if necessary, sent
to the server at the beginning of game play), and so treat
these as concrete.
4.3 Accumulating Constraints
While the branches taken by a client in each round may
not be visible to the veriﬁer, the veriﬁer can keep a set of
constraints that represent possible client executions so far.
Speciﬁcally, the veriﬁer forms a conjunction of round con-
straints that represents a sequence of possible paths through
the client’s loop taken over multiple rounds; we call this
conjunction an accumulated constraint and denote the set
of satisﬁable accumulated constraints at the end of round i
by Ci. This set corresponds to the possible paths taken by a
client through round i.
The veriﬁer updates a given set Ci−1 of accumulated
constraints upon receiving a new client message msg i in
round i. To do so, the veriﬁer ﬁrst combines the values
given in msg i with each round constraint for round i, where
each symbolic variable in the round constraint represents
client state for round i, and the round constraint character-
izes those variables as a function of the variables for round
i − 1. The veriﬁer then combines each result with each ac-
cumulated constraint in Ci−1 and checks for satisﬁability.
For example, let us parameterize the round constraints
for the toy example in §4.2 with the round number j:
G(j) = { locj = locj−1 + 1 ,
locj = locj−1 − 1 ,
locj = locj−1
}
Note that each member of G(j) corresponds to a disjunct
in (1). If in round i = 2 the server receives the message
msg 2 = 9 from the client, then it generates the constraint
M = “loc2 = 9”, because the value “9” in the message
represents information corresponding to the variable loc in
the client code. Then, combining M with each G ∈ G(2)
gives the three constraints:
loc2 = 9 ∧ loc2 = loc1 + 1
loc2 = 9 ∧ loc2 = loc1 − 1
loc2 = 9 ∧ loc2 = loc1
for C ∈ Ci−1 do
300: Ci ← ∅
301: M ← msgToConstraint(msg i)
302: for G ∈ G(i) do
303:
304:
305:
306:
307:
308:
309: end for
C ′ ← C ∧ G ∧ M
if isSatisﬁable(C ′) then
Ci ← Ci ∪ {C ′}
end if
end for
Figure 2. Construction of Ci from Ci−1 and msg i
2 above) as well as including the speciﬁc values given in the
client message at that round (i.e., loc2 = 9 above).
These three round constraints each represent a possible
path the client might have taken in the second round. The
veriﬁer must therefore consider each of them in turn as if it
were the correct path. For example, if C1 = {loc1 = 8},
then the veriﬁer can use each round constraint to generate
the following possible accumulated constraints:
loc1 = 8 ∧ [loc2 = 9 ∧ loc2 = loc1 + 1]
loc1 = 8 ∧ [loc2 = 9 ∧ loc2 = loc1 − 1]
loc1 = 8 ∧ [loc2 = 9 ∧ loc2 = loc1]
Since the second and third constraints are not satisﬁable,
however, this reduces to
C2 = {loc1 = 8 ∧ [loc2 = 9 ∧ loc2 = loc1 + 1]}
= {loc1 = 8 ∧ loc2 = 9}
The basic algorithm for constructing Ci from Ci−1
and msg i is thus as shown in Figure 2.
In this ﬁgure,
msgToConstraint simply translates a message to the con-
straint representing what values were sent in the message.
It is important to note that while |Ci| = 1 for each i in
our toy example, this will not generally be the case for a
more complex game. In another game, there might be many
accumulated constraints represented in Ci−1, each of which
would have to be extended with the possible new round con-
straints to produce Ci.
4.4 Constraint Pruning
Every accumulated constraint in Ci is a conjunction C =
c1 ∧. . .∧cn (or can be written as one, in conjunctive normal
form). In practice, constraints can grow very quickly. Even
in the toy example of the previous section, the accumulated
constraint in C2 has one more conjunct than the accumulated
constraint in C1. As such, the veriﬁer must take measures to
avoid duplicate constraint checking and to reduce the size
of accumulated constraints.
Note that the combination of the client message with each
round constraint involves both instantiation (e.g., using j =
First, the veriﬁer partitions the conjuncts of each new ac-
cumulated constraint C ′ (line 304) based on variables (e.g.,
loc2) referenced by its conjuncts. Speciﬁcally, consider the
undirected graph in which each conjunct ck in C ′ is repre-
sented as a node and the edge (ck, ck′ ) exists if and only if
there is a variable that appears in both ck and ck′ . Then,
each connected component of this graph deﬁnes a block in
the partition of C ′. Because no two blocks for C ′ share vari-
able references, the veriﬁer can check each block for satisﬁ-
ability independently (line 305), and each block is smaller,
making each such check more efﬁcient. And, since some
accumulated constraints C ′ will share conjuncts, caching
proofs of satisﬁability for previously-checked blocks will
allow shared blocks to be conﬁrmed as satisﬁable more ef-
ﬁciently.
Second, because round constraints refer only to variables
in two consecutive rounds — i.e., any G ∈ G(j) refers only
to variables for round j and j − 1 — the formulas G and
M in line 304 will refer only to variables in rounds i and
i − 1. Therefore, if there are blocks of conjuncts for C ′ in
line 304 that contain no references to variables for round
i, then these conjuncts cannot be rendered unsatisﬁable in
future rounds. Once the veriﬁer determines that this block
of conjuncts is satisﬁable (line 305), it can safely remove
the conjuncts in that block from C ′.
4.5 Server Messages
Round constraints are not a function of only user inputs
(and potentially random coin ﬂips and time readings), but
also messages from the server that the client processes in
that round. We have explored two implementation strategies
for accounting for server messages when generating round
constraints:
• Eager: In this approach, eager round constraints are
generated with the server-to-client messages marked
symbolic in the client software, just like user inputs.
Each member of G(i) is then built by conjoining an eager
round constraint with one or more conjuncts of the form
“svrmsg = m”, where svrmsg is the symbolic variable
for a server message in the client software, and m is
the concrete server message that this variable took on
in round i. We refer to this approach as “eager” since it
enables precomputation of eager round constraints prior
to veriﬁcation, but in doing so also computes them for
paths that may never be traversed in actual game play.
• Lazy: In this approach, lazy round constraints are gen-
erated from the client software after it has been instanti-
ated with the concrete server-to-client messages that the
client processed in that round; these round constraints
for round i then constitute G(i) directly. Since the server
messages are themselves a function of game play, the
lazy round constraints cannot be precomputed (as op-
posed to eager round constraints) but rather must be
computed as part of veriﬁcation. As such, the expense
of symbolic execution is incurred during veriﬁcation,
but only those paths consistent with server messages ob-
served during game play need be explored.
In either case, it is necessary that the server log the mes-
sages it sent and that the veriﬁer know which of these mes-
sages the client actually processed (versus, say, were lost).
In our case study in §5, we will discuss how we convey this
information to the server, which it records for the veriﬁer.
As discussed above, the eager approach permits sym-
bolic execution to be decoupled from veriﬁcation, in that
eager round constraints can be computed in advance of
game play and then augmented with additional conjuncts
that represent server messages processed by the client in
that round. As such, the generation of round constraints
in the eager approach is a conceptually direct application
of a tool like KLEE (albeit one fraught with game-speciﬁc
challenges, such as those we discuss in §5.4.1). The lazy
approach, however, tightly couples the generation of round
constraints and veriﬁcation; below we brieﬂy elaborate on
its implementation.
To support the lazy approach, we extend KLEE by build-
ing a model of the network that permits it access to the
log of messages the client processed (from the server) in
the current round i and any message the client sent in that
round. Below, we use the term active path to refer to an
individual, symbolically executing path through the client
code. Each active path has its own index into the message
log, so that each can interact with the log independently.
To handle server-to-client messages from the log, we in-
tercept the recv() system call and instead call our own
replacement function. This function ﬁrst checks to see that
the next message in the network log is indeed a server-to-
client message. If it is, we return the message and advance
this active path’s pointer in the log by one message. Other-
wise, this active path has attempted more network reads in
round i than actually occurred in the network log prior to
reaching the breakpoint corresponding to a client-message
send. In this case, we return zero bytes to the recv() call,
indicating that no message is available to be read. Upon an
active path reaching the breakpoint (which corresponds to a
client send), if the next message in the log is not a client-
to-server message, then this active path has attempted fewer
network reads than the log indicates, and it is terminated as
invalid. Otherwise, the round constraint built so far is added
to G(i) and the logged client message is used to instantiate
the new conjunct M in line 301 of Figure 2.
4.6 Scaling to Many Clients
Implementing our technique on a real-world online game
with a large user base might require its own special imple-
mentation considerations. As we will see in §5, our eager
and lazy implementations are not yet fast enough to per-
form validation on the critical path of game play. So, the
game operator must log all the messages to and from clients
that are needed to validate game play ofﬂine. That said, the
need for logging will not be news to game operators, and
they already do so extensively:
LOG EVERYTHING, and offer a robust system
forreviewingthe logs. When huntingdownbugs
and/or reviewing player cries of foul, nothing
makes the job of the GM easier than knowing
that he/she has perfect information and can state
with 100% accuracy when a player isn’t telling
thewholetruth. [32]
As such, our approach introduces potentially little ad-
ditional logging to what game operators already perform.
Nevertheless, to minimize this overhead, game operators
might use a log-structured ﬁle system [30]. Such ﬁle sys-
tems write data sequentially in a log-like structure and are
optimized for small writes (as would be the case when log-
ging client and server messages). Log-structured ﬁle sys-
tems have been implemented for NetBSD and Linux, for
example.
Once the messages are logged, they can be searched later
to extract a speciﬁc game trace to be checked (e.g., for a
winning player). The checking itself can be parallelized
extensively, in that the trace of a player can be checked
independently of others’, and even blocks within accumu-
lated constraints C ′ (see §4.4) can be checked in parallel.
Traces can also be partially checked, by starting in the mid-
dle of a trace, say at round i with client-to-server mes-
sage msg i, and checking from that point forward (i.e., with
Ci−1 = {true}). Of course, while such a partial check can
validate the internal consistency of the part of the trace that
is checked, it will not detect inconsistencies between the
validated part and other parts.
5 Case Study: XPilot
In our ﬁrst case study, we apply our technique to XPilot,
an open-source multiplayer game written in about 150,000
lines of C code. XPilot uses a client-server architecture that
has inﬂuenced other popular open source games. For ex-
ample, the authors of Freeciv used XPilot’s client-server ar-
chitecture as a basis for the networking in that game. XPilot
was ﬁrst released over 15 years ago, but it continues to enjoy
an active user base. In fact, in July 2009, 7b5 Labs released
an XPilot client for the Apple iPhone and Apple iPod Touch
(see http://7b5labs.com/xpilotiphone), which
is the most recent of several forks and ports of the XPilot
code base over the years. We focus on one in particular
called XPilot NG (XPilot Next Generation).
5.1 The Game
The game’s style resembles that of Asteroids, in which
the player controls an avatar in the form of a spaceship,
which she navigates through space, avoiding obstacles and
battling other ships. But XPilot adds many new dimen-
sions to game play, including computer-controlled players,
several multiplayer modes (capture the ﬂag, death match,
racing, etc.), networking (needed for multiplayer), better
physics simulation (e.g., accounting for fuel weight in ac-
celeration), and updated graphics. In addition, XPilot is a
highly conﬁgurable game, both at the client and the server.
For example, clients can set key mappings, and servers can
conﬁgure nearly every aspect of the game (e.g., ship mass,
initial player inventory, probability of each type of power-
up appearing on the map, etc.).
As we have discussed, developers of today’s networked
games design clients with little authoritative state in order to
help address cheating. In keeping with that paradigm, XPi-
lot was written with very little such state in the client itself.
Despite this provision, there are still ways a malicious user
can send invalid messages in an attempt to cheat. In XPi-
lot, there are some sets of keys that the client should never
report pressing simultaneously. For example, a player can-
not press the key to ﬁre (KEY FIRE SHOT) while at the same
time pressing the key to activate his shield (KEY SHIELD). A
valid game client will ﬁlter out any attempts to do so, deac-
tivating the shield whenever a player is ﬁring and bringing
it back online afterward. However, an invalid game client
might attempt to gain an advantage by sending a keyboard
update that includes both keys. As it happens, the server
does its own (manually conﬁgured) checking and so the
cheat fails in this case, but the fact that the client behavior
is veriﬁably invalid remains. There are numerous examples
of similar cheats in online games that servers fail to catch,
either because of programming errors or because that par-
ticular misuse of the protocol was unforeseen by the game
developers. In our evaluations, we conﬁrmed that our tech-
nique detects this attempt to cheat in XPilot, as expected.
This detection was a direct result of the logic inherent in the
game client, in contrast to the manually programmed rule in
the XPilot server.
At the core of the architecture of the XPilot client is a
main loop that reads input from the user, sends messages to
the server, and processes new messages from the server. In
§5.3 and §5.4, we describe the veriﬁcation of XPilot client
behavior by generating lazy round constraints and eager
round constraints for this loop, respectively. However, we
ﬁrst describe modiﬁcations we made to XPilot, in order to
perform veriﬁcation.
5.2 Game Modiﬁcations
Message acknowledgments Client-server communication
in XPilot uses UDP trafﬁc for its timeliness and decreased
overhead — the majority of in-game packets are relevant
only within a short time after they are sent (e.g., informa-
tion about the current game round). For any trafﬁc that must
be delivered reliably (e.g., chat messages between players),
XPilot uses a custom layer built atop UDP. Due to XPilot’s
use of UDP and the fact that it can process arbitrary num-
bers of messages in a single client loop, we added to XPilot
an acknowledgement scheme to inform the server of which
inbound messages the client processed in each loop iteration
and between sending its own messages to the server. The
server logs this information for use by the veriﬁer. There are
many possible efﬁcient acknowledgement schemes to con-
vey this information; the one we describe in Appendix A
assumes that out-of-order arrival of server messages is rare.
These acknowledgments enable the server to record a log
of relevant client events in the order they happened (as re-
ported by the client). For each client-to-server message that
the server never received, the veriﬁer simply replaces the
constraint M implied by the missing message (see line 301
of Figure 2) with M = true.
XPilot, like most games of
Floating-point operations
even moderate size, includes an abundance of ﬂoating-point
variables and math. However, it is not currently possible to
generate constraints on ﬂoating-point numbers with KLEE.
Therefore, we implement XPilot’s ﬂoating-point operations
using a simple ﬁxed-point library of our own creation. As
a result, symbolic execution on the XPilot client produces
constraints from this library for every mathematical opera-
tion in the client code involving a symbolic ﬂoating-point
number. This, in turn, inﬂates the veriﬁcation speeds re-
ported in §5.4, in particular.
Client trimming The XPilot client, like presumably any
game client, contains much code that is focused on enhanc-
ing the user gaming experience but that has no effect on the
messages that the client could send to the server. To avoid
analyzing this code, we trimmed much of it from the game