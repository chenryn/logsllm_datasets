6
L→*R.
 =←S
R→L.
SR
L→id.
√
→·L
→L=·R
第 4 章
(4.49)
考
一
---
## Page 179
们不会在这里证明这个定理，但我们将给出一个例子。
应的项集就是的有效项集。实质上，有效项集包含了所有能够从栈中收集到的有用信息。
LR(O）自动机中从初始状态开始沿着标号为某个可行前缀的路径到达一个状态，那么该状态对
行前缀的有效项的集合。实际上，LR 语法分析理论的核心定理是：如果我们在某个文法的
都可以得到解决。
节中的方法来解决，但是我们不应该认为将LR方法应用于任意文法所产生的语法分析动作冲突
不同的事情。有些这样的冲突可以通过查看下一个输入符号来解决，还有一些冲突可以通过4.8
我们应该按照这个产生式进行归约。当然，可能会有两个有效项要求我们对同一个可行前缀
还没有被全部移人到栈中，因此我们应该选择移人。如果β2=∈，那么看起来 A→β 就是句柄
时，这些信息可以帮助我们决定是进行归约还是移人。特别是,如果β2≠e，那么它告诉我们句柄
行前缀有效。
到一个最右句型。
最右句柄的右端。根据这个定义，我们总是可以在一-个可行前缀之后增加一些终结符号来得
fx)。它们的定义如下：一个可行前缀是一个最右句型的前缀，并且它没有越过该最右句型的
(E)是句柄，语法分析器必须在移入*之前将它归约为F。
柄。比如，假设
始符号 S 的归约序列。用推导的方式表示就是S=αx。
析器，该文法的LR(O)自动机可以刻画出可能出现在分析器栈中的文法符号串。栈中内容一
4.6.5可行前缀
时，一般都可以避免使用这样的文法。
构造方法都会产生带有语法分析动作冲突的语法分析动作表。幸运的是，在处理程序设计语言
的文法类型，包括文法(4.49）。然而请注意，存在一-些无二义性的文法使得每种LR语法分析器
器应该对输入=采取什么动作。接下来讨论的规范LR 方法和LALR 方法将可以成功地处理更大
强大，不能记住足够多的上下文信息。因此当它看到一个可归约为L的串时，不能确定语法分析
=上存在移人/归约冲突。
约R→L”。因为在ACTION[2，=］中既存在移入条目又存在归约条目，所以状态2 在输人符号
包含=（考虑推导过程 S=L=R=R=R即可知原因），第二个项将 ACTION[2，=］设置为“归
对于可能出现在LR 语法分析栈中的各个可行前缀，我们可以很容易地计算出对应于这些可
语法分析
项A→β·β2对 αβ:有效的事实可以告诉我们很多信息。当我们在语法分析栈中发现 αβ
那么在语法分析的不同时刻，栈中存放的内容可以是（、（E和（E），但不会是（E）＊，因为
然而，不是所有的最右句型的前缀都可以出现在栈中，因为语法分析器在移人时不能越过句
为什么可以使用LR(O)自动机来做出移入－归约决定？对于一个文法的移人－归约语法分
文法(4.49)不是二义性的。产生移人/归约冲突的原因是构造 SLR 分析器的方法功能不够
考虑项集I2。这个项集中的第一-个项使得 ACTION[2，=］是“移入6”。因为FOLLOW（R)
E→F * id =(E)*id
163
穿
定
口
---
## Page 180
是 LL(1)的，但不是 SLR(1)的。
出这个文法的语法分析表。这个文法是 SLR 文法吗？
4.6.6 4.6节的练习
事实。
说明了F→·id是有效的。可以证明E+T＊没有其他的有效项，但我们并不会在这里证明这个
状态7中包含了项
串E+T＊是该文法的--个可行前缀。图4-31中的自动机在读人E+T＊之后将位于状态7上。
例 4.50
集构造方法应用于以项作为状态的 NFA N 并构造出 DFA 的过程。
这个 DFA 中状态I在符号X上的转换。从这个角度看,图 4-33 中的过程 items（G）就是将子
NFA 状态集合的∈闭包。由NFA N通过子集构造法可以得到--个 DFA。GOTO（I,X)给出了
为ε的转换。那么项（N的状态)的集合1的CLOSURE(I)恰恰就是3.7.1节中定义的一个
从 A→α·Xβ 到A→αX·β有--个标号为 X 的转换,并且从 A-→α·Bβ到 B-→·有--个标号
164
练习4.6.5：说明下面的文法
3）如果存在 SLR 语法分析表，构造出这个语法分析表。
2）指出你的项集中的所有动作冲突。
1）构造 SLR 项集和它们的 GOTO 函数。
练习4.6.4：对于练习4.2.2(1）～（7)中的各个(增广)文法：
练习 4.6.3：利用练习 4.6.2得到的语法分析表,
练习4.6.2：为练习4.2.1中的(增广)文法构造 SLR项集。计算这些项集的 GOTO 函数。给
！3）练习4.2.2(3)的文法S→S（S）丨∈。
！ 2）练习 4.2.1 的文法S-→S S+！S S＊i α
1）练习 4.2.2(1)的文法S→0 S11 0 1。
练习4.6.1：描述下列文法的所有可行前缀：
第一个推导说明 T→T＊·F是有效的，第二个推导说明F→·（E）是有效的，第三个推导
它们恰恰就是E+T＊的有效项。为了说明原因，考虑如下三个最右推导：
如果将项本身看作状态,我们就可以构造出一个识别可行前缀的不确定有穷自动机 N。
让我们再次考虑增广表达式文法。该文法的项集和 GOTO 函数如图 4-31所示。显然
E + T
将项看作一个 NFA 的状态
B->E
A-→E
S--→A α A bI B b B a
=E + T*（E)
F-→·id 
F→·(E)
T-→T *
，给出处理输人αa*α+时的各个动作。
第4章
口
---
## Page 181
4.7.1规范LR(1)项
洁的 LR 语法分析表。
表大。在很多情况下，LALR 方法是最合适的选择。
法处理的文法比使用 SLR 方法时处理的文法更多，同时构造得到的语法分析表却不比 SLR 分析
分析器相比，它的状态要少很多。通过向LR(O)项中小心地引入向前看符号，我们使用LALR 方
方法：
4.7
冲突时不确定地选择一-个可能的动作。给出处理输人αbab 时的所有可能的动作序列。
表，必然会存在某些冲突动作。都有哪些冲突动作？假设我们使用这个语法分析表，并且在出现
该文法的 LR(O)项集。
了一个很大的项集，称为LR(1)项集。
的LR(O)项集相比有什么关系？
(NFA)。
4.2.1的文法S-→SS+丨SS*”α：
-个确定有穷自动机的状态（见 4.6.5 节中的“将项看作一个 NFA 的状态"部分）。对于练
2）“向前看LR",或称为“LALR”方法。
2）将子集构造算法(算法3. 20)应用于在(1)部分构造得到的 NFA。得到的 DFA 和这个文法
在介绍了这两种方法之后，我们将在本节的结尾讨论如何在一个内存有限的环境中建立简
1）“规范LR”方法，或直接称为“LR”方法。它充分地利用了向前看符号。这个方法使用
！！3）说明在任何情况下，将子集构造算法应用于--个文法的有效项的 NFA所得到的就是
1）根据“将项看作一个NFA 的状态"部分中的规则，画出这个文法的有效项的转换图
语法分析
现在我们将给出最通用的为文法构造LR 语法分析表的技术。回顾一下，在 SLR 方法中，如
在本节中，我们将扩展前面的LR语法分析技术，在输入中向前看一个符号。有两种不同的
构造出这个文法的规范 LR(O)项集族。如果我们试图为这个文法构造出－-个 LR语法分析
！练习4.6.9：下面是一个二义性文法：
关于LR语法分析器的大小，这个分析结果说明了什么？
3）
2）
1） G,有2n²-n个产生式。
说明：
！！练习4.6.7：考虑按照下面方式定义的文法族G,：
是 SLR(1)的，但不是 LL(1)的。
练习4.6.6：说明下面的文法
更强大的LR语法分析器
G,是 SLR(1)的。
Gn,有 2"+n²+n.个 LR(0)项集。
A;-→a;A;1 aj
S-→A; b;
A-→S A Ia
S→A S1b
A-→u
S-→S A I A 
 它基于LR(0)项集族。和基于LR(1)项的典型语法
其中l≤i,j≤n且i≠j
其中1≤i≤
165
---
## Page 182
S8Aax=8αBβax，其中=α。假设 βax 推导出终结符号串 by,那么对于某个形如 B→n 的产生
某些可行前缀有效的项集合中的一个形如［A→α·Bβ,a］的项,那么必然存在一个最右推导
改两个过程：CLOSURE和GOTO。
4.7.2构造 LR(1)项集
该文法有个最右推导 SaBab aaaBab。在上面的定义中，令=αa，A=B，w=ab，α=α且
例4.52
个真子集。
A→α进行归约。这样的α的集合总是FOLLOW(A)的子集，而且如例 4.51所示，它很可能是一
行归约。因此，只有当栈顶状态中包含一个LR(1)项[A→α·，α］，我们才会在输人为α时按照
结符号或右端结束标记$。我们称这样的对象为LR(1)项。其中的1指的是第二个分量的长度。
为一个终结符号。项的一般形式变成了[A→α·β，α］，其中 A→αβ 是一个产生式,而α是一个终
以跟在句柄α的后面，从而使α可能被归约成为 A。
时，我们可以通过分裂某些状态，设法让LR 语法分析器的每个状态精确地指明哪些输入符号可
实际上不应该执行从L到 R的归约。
作)。然而，例4.48的文法没有以R=·开头的最右句型。因此状态2只和可行前缀I对应，
态为2 时要求按照 R→L进行归约（因为状态2 中还包含项S→L·=R，它同时还要求执行移人动
A一→α,而和α对应的是 FOLLOW(R)中的符号=。因此，SLR 语法分析器在下一个输人为=且状
中α 都不可能跟在 βA 之后,那么当输人为α时不应该按照 A-→α 进行归约。
行归约。然而在某些情况下，当状态i出现在栈顶时，栈中的可行前缀是 βα 且在任何最右句型
果项集I;包含项[A→α·］，且当前输人符号α在 FOLLOW（A)中，那么状态i就要按照 A→α进
当然可以使用长度大于1的向前看符号串。但是这里我们不考虑这样的向前看符号串。
为了理解 CLOSURE 操作的新定义，特别是理解为什么b 必须在 FIRST(βa）中，我们考虑对
构造有效 LR(1)项集族的方法实质上和构造规范 LR(0)项集族的方法相同。我们只需要修
2）要么α是w的第一个符号，要么w为∈且α等于s。
正式地讲，我们说LR(1)项[A→α·β、α]对于－个可行前缀有效的条件是存在一个推导
如果在状态中包含更多的信息，我们就可能排除掉一些这样的不正确的 A→α 归约。在必要
166
1)=8α，且
将这个额外的信息加人状态中的方法是对项进行精化，使它包含第二个分量，这个分量的值
让我们考虑文法
B-→α B Ib 
S→B B
第4章
口
它
---
## Page 183
会推导出空串，所以 FIRST(C $）=FIRST(C)。因为 FIRST(C)包含终结符号c和d，所以我们
增加[S→·CC，$]。
包中。对于当前的文法，B→ 就是S-→>CC，并且因为β是∈且α是$，b只能是$。因此，我们
SURE 中的项[A→α·Bβ，α］相匹配。也就是说,A=S'，α=∈，B=S，β=∈和α= $。函数 CLO-
例4.54
算法4.53
LR(1)项集的构造方法。
数。请注意，x不可能包含 by 的第一个终结符号，因此 FIRST(βax）=FIRST(βa）。现在我们给出
这两种情况，我们说b 可以是 FIRST(Bax）中的任意终结符号，其中FIRST 是在4.4 节中定义的函
得到的第一个终结符号，也可能在βαx by 的推导过程中β 推导出了e，因此6也可能是α。总结
S→·CC，$]和[A→α·Bβ，α]相匹配，我们有A=S，α=∈，B=C,β=C且α= $。因为 C
SURE 告诉我们,对于每个产生式B→和FIRST(βa)中的终结符号b，将项[B→·，6]加入到闭
我们继续计算闭包，对于在FIRST(C$）中的b，加人所有的项[C→·，6］。也就是说，将
语法分析
我们首先计算［S"→·S，$］}的闭包。在求闭包时，我们将项[S"→·S，$］和过程 CLO-
方法：过程CLOSURE 和 GOTO，以及用于构造项集的主例程 items 见图 4-40。
输出：LR(1)项集族，其中的每个项集对文法G'的一-个或多个可行前缀有效。