OR
neutral
down
up
select t1 suspend down
412
A. Kamra and E. Bertino
Let the role r2 be assigned to the user u1. To determine the ﬁnal state of the select
privilege on the table t1 for the user u1, we evaluate priv states(u1 , select , t1 ) as
follows:
priv states(u1, select, t1)
= priv states(SU1, u1, select, t1) ∪
priv states(SU2, u1, select, t1)
= priv states(SU1, r2, select, t1) ∪
priv states(SU2, r2, select, t1)
= {taint} ∪
{grant} ∪ {suspend}
= {taint, grant, suspend}
The ﬁnal state is determined using the PSD state() function as follows:
P SD state(taint, grant, suspend) = suspend
3 Implementation and Experiments
In this section, we present the details on how to extend a real-world DBMS with PSAC.
We choose to implement PSAC in the PostgreSQL 8.3 open-source object-relational
DBMS [5]. In the rest of the section, we use the term PSAC:PostgreSQL to indi-
cate PostgreSQL extended with PSAC, and BASE:PostgreSQL to indicate the ofﬁcial
PostgreSQL 8.3 release. The implementation of PSAC:PostgreSQL has to meet two
design requirements. The ﬁrst requirement is to maintain backward compatibility of
PSAC:PostgreSQL with BASE:PostgreSQL. We intend to release PSAC:PostgreSQL
for general public use in the near future; therefore it is important to take into account
the backward compatibility issues in our design. The second requirement is to mini-
mize the overhead for maintaining privilege states in the access control mechanism. In
particular, we show that the time taken for the access control enforcement code in the
presence of privilege states is not much higher than the time required by the access
control mechanism of BASE:PostgreSQL. In what follows, we ﬁrst present the design
details of PSAC:PostgreSQL, and then we report experimental results showing the efﬁ-
ciency of our design.
3.1 PSAC:PostgreSQL
Access control in BASE:PostgreSQL is enforced using access control lists (ACLs).
Every DBMS object has an ACL associated with it. An ACL in BASE:PostgreSQL is a
one-dimensional array; the elements of such an array have values of the ACLItem data
type. An ACLItem is the basic unit for managing privileges of an object. An ACLItem is
implemented as a structure with the following ﬁelds: granter, the user/role granting the
privileges; grantee, the user/role to which the privileges are granted; and privs, a 32 bit
integer (on 32 bit machines) managed as a bit-vector to indicate the privileges granted
Privilege States Based Access Control for Fine-Grained Intrusion Response
413
31  30     (cid:171)(cid:171)(cid:171)(cid:171)(cid:171)(cid:171)(cid:171)(cid:171).      17   16   15   14    (cid:171)(cid:171)(cid:171)(cid:171)(cid:171)(cid:171)(cid:171)(cid:171).       1     0
GRANT OPTION BITS
PRIVILEGE BITS
Fig. 5. ACLItem privs ﬁeld
to the grantee. A new ACLItem is created for every unique pair of granter and grantee.
There are 11 pre-deﬁned privileges in BASE:PostgreSQL with a bit-mask associated
with each privilege [6]. As shown in Figure 5, the lower 16 bits of the privs ﬁeld are
used to represent the granted privileges, while the upper 16 are used to indicate the
grant option4. If the kth bit is set to 1 (0 ≤ k < 15), privilege pk is granted to the
user/role. If the (k + 16)th bit is also set to 1, then the user/role has the grant option
on privilege pk.
Design Details. There are two design options to extend BASE:PostgreSQL to support
privilege states. The ﬁrst option is to extend the ACLItem structure to accommodate
privilege states. The second option is to maintain the privilege states in a separate data
structure. We chose the latter option. The main reason is that we want to maintain back-
ward compatibility with BASE:PostgreSQL. Extending the existing data structures can
introduce potential bugs at other places in the code base that we want to avoid. In
BASE:PostgreSQL, the pg class system catalog is used to store the metadata informa-
tion for database objects such as tables, views, indexes and sequences. This catalog also
stores the ACL for an object in the acl column that is an array of ACLItems. We extend
the pg class system catalog to maintain privilege states by adding four new columns
namely: the acltaint column to maintain the tainted privileges; the aclsuspend column
to maintain the suspended privileges; the acldeny column to maintain the denied priv-
ileges; and the aclneut column to indicate if the privilege is in the neutral orientation
mode. Those state columns and the aclneut column are of the same data type as the
acl column, that is, an array of ACLItems. The lower 16 bits of the privs ﬁeld in those
state and aclneut columns are used to indicate the privilege states and the orientation
mode respectively. This strategy allows us to use the existing privilege bit-masks for
retrieving the privilege state and orientation mode from these columns. The upper 16
bits are kept unused. Table 3 is the truth table capturing the semantics of the privs ﬁeld
bit-vector in PSAC:PostgreSQL.
Authorization Commands. We have modiﬁed the BASE:PostgreSQL GRANT and
REVOKE authorization commands to implement the privilege state transitions. In ad-
dition, we have deﬁned and implemented in PSAC:PostgreSQL three new authorization
commands, that is, the DENY, the SUSPEND, and the TAINT commands. As discussed
in the Section 2, the DENY command moves a privilege to the deny state, the SUS-
PEND command moves a privilege to the suspend state, and the TAINT command
moves a privilege to the taint state. The default privilege orientation mode for these
4 Recall that the grant option is used to indicate that the granted privilege may be granted by the
grantee to other users/roles.
414
A. Kamra and E. Bertino
Table 3. Privilege States/Orientation Mode Truth Table for the privs Field in PSAC:PostgreSQL
acl
acl
pk
acl
taint suspend deny neut state
acl
acl
kth bit kth bit kth bit kth bit kth bit
0
1
0
0
0
0
0
0
0
0
1
0
0
1
0
0
0
0
0
1
0
0
1
0
0
0
0
0
1
0
0
1
0
0
0
0
0
1
1
1
unassign/up
grant/up
taint/down
suspend/down
deny/down
taint/neutral
suspend/neutral
deny/neutral
Rest all other combinations are not allowed by the system.
Table 4. New Authorization Commands in PSAC:PostgreSQL
TAINT {privilege name(s) | ALL} ON {object name(s)}
SUSPEND {privilege name(s) | ALL} ON {object name(s)}
DENY {privilege name(s) | ALL} ON {object name(s)}
TO {user/role name(s) | PUBLIC} [NEUT ORNT]
TO {user/role name(s) | PUBLIC} [NEUT ORNT]
TO {user/role name(s) | PUBLIC} [NEUT ORNT]
commands is the down mode with the option to override that by specifying the neutral
orientation mode. The administrative model for these commands is similar to that of
the SQL-99 GRANT command, that is, a DENY/SUSPEND/TAINT command can be
executed on privilege p for object o by a user u iff u has the grant option set on p for o
or u is the owner of o. The syntax for the commands is reported in Table 4. Note that
in the current version of PSAC:PostgreSQL, the new commands are applicable on the
database objects whose metadata are stored in the pg class system catalog.
Access Control Enforcement. We have instrumented the access control enforcement
code in BASE:PostgreSQL with the logic for maintaining the privilege states and
orientation modes. The core access control function in BASE:PostgreSQL returns a
true/false output depending on whether the privilege under check is granted to the user
or not. In contrast, the core access control function in PSAC:PostgreSQL returns the
ﬁnal state of the privilege to the calling function. The calling function then executes a
pre-conﬁgured action depending upon the state of the privilege. As a proof of concept,
we have implemented a re-authentication procedure in PSAC:PostgreSQL when a
privilege is in the suspend state. The re-authentication procedure is as follows:
that when a privilege is in the suspend
Re-authentication Procedure. Recall
state, further negotiation with the end-user must be satisﬁed before the user-request is
executed by the DBMS. In the current version of PSAC, we implement a procedure that
re-authenticates the user if a privilege, after applying the PSD relationship, is found in
Privilege States Based Access Control for Fine-Grained Intrusion Response
415
the suspend state. The re-authentication scheme is as follows. In BASE:PostgreSQL,
an authentication protocol is carried out with the user whenever a new session is
established between a client program and the PostgreSQL server. In PSAC:Postgresql,
the same authentication protocol is replayed in the middle of a transaction execution
when access control enforcement is in progress, and a privilege is found in the suspend
state. We have modiﬁed the client library functions of BASE:PostgreSQL to implement
such protocol in the middle of a transaction execution. If the re-authentication protocol
fails, the user request is dropped. If it succeeds, the request proceeds as usual, and
no changes are made to the state of the privilege. Note that such re-authentication
procedure scheme is implemented as a proof-of-concept in PSAC:Postgresql. More
advanced forms of actions such as a second-factor of authentication can also be
implemented.
Access Control Enforcement Algorithm. The pseudo-code for the access con-
trol enforcement algorithm in PSAC:PostgreSQL is presented in the Listing 1. The
function aclcheck() takes as input a privilege in priv - whose state needs to be
determined, a database object in object - that is the target of a request, and a user
in user - the user exercising the usage of in priv. The output of the algorithm is
the state of the in priv. The algorithm proceeds as follows. Since we deﬁne a total
order on the privilege states, it is sufﬁcient to check each state in the order of its
rank in the PSD relation (cfr. Section 2). Thus, we ﬁrst check for the existence of
in priv in the deny state, followed by the suspend state, the taint state, and then the
grant state. The function for checking the state of in priv (function check priv()) in
an Acl is designed to take into account all the roles that are directly and indirectly
(through a role hierarchy) assigned to the in user. Note that most expensive operation
in the check priv() function is the run-time inheritance check of roles, that is, to check
whether the user role is an ancestor or descendant of the acl role (lines 58 and 62).
We make such check a constant time operation in our implementation by maintaining
a cache of the assigned roles for every user/role in the DBMS. Thus, the running time
of the access control enforcement algorithm is primarily dependent upon the sizes of
various Acls.
If the privilege is not found to be in the above mentioned states, the unassign state is
returned as the output of the access check algorithm.
e x e c u t i n g t h e command
: The u s e r
: T a r g e t d a t a b a s e o b j e c t
: P r i v i l e g e
1 −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
2 I n p u t
3 i n u s e r
4 i n o b j e c t
5 i n p r i v
6
7 O u t p u t
8 The p r i v i l e g e
9 −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
10 f u n c t i o n a c l c h e c k ( i n u s e r ,
11 {
t o check
s t a t e
i n o b j e c t ,
i n p r i v )
r e t u r n s
s t a t e
12
13
/ / Get
NeutACL = g e t n e u t o r n t ( i n o b j e c t ) ;
t h e n e u t r a l o r i e n t a t i o n ACL f o r
i n o b j e c t
416
A. Kamra and E. Bertino
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
i f
i n u s e r has
/ / Deny
DenyACL = g e t d e n y s t a t e a c l ( i n o b j e c t ) ;
i f
i n p r i v
i n DENY s t a t e
( c h e c k p r i v ( i n p r i v , DenyACL , i n u s e r , NeutACL ,DENY) == t r u e )
r e t u r n DENY;
/ / Suspend i f
SuspendACL = g e t s u s p e n d s t a t e a c l ( i n o b j e c t ) ;
i f
i n u s e r has
i n p r i v
i n SUSPEND s t a t e
( c h e c k p r i v ( i n p r i v , SuspendACL , i n u s e r , NeutACL , SUSPEND) ==
t r u e )
r e t u r n SUSPEND;
i f
/ / T a i n t
TaintACL = g e t
i f
i n u s e r has
i n p r i v
i n TAINT s t a t e
t a i n t
s t a t e a c l ( i n o b j e c t ) ;
( c h e c k p r i v ( i n p r i v , TaintACL , i n u s e r , NeutACL , TAINT ) == t r u e
)
r e t u r n TAINT ;
i f
i n u s e r has
/ / Grant
GrantACL = g e t g r a n t s t a t e a c l ( i n o b j e c t ) ;
i f
i n p r i v
i n GRANT s t a t e
( c h e c k p r i v ( i n p r i v , GrantACL , i n u s e r , NeutACL ,GRANT) == t r u e
)
r e t u r n GRANT ;
/ / E l s e r e t u r n UNASSIGN s t a t e
r e t u r n UNASSIGN;
36
37 }
38 −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
39 f u n c t i o n c h e c k p r i v ( i n p r i v , AclToCheck , i n u s e r , NeutACL ,
s t a t e t o c h e c k )
40 r e t u r n s b o o l e a n
41 {
/ / F i r s t , p e r f o r m t h e
i n e x p e n s i v e
s t e p o f c h e c k i n g t h e
p r i v i l e g e s d i r e c t l y a s s i g n e d t o t h e
i n p r i v i n AclToCheck )
( i n u s e r h a s
i f
i n u s e r
r e t u r n t r u e ;
/ / Get a l l
u s e r
t h e
r o l e s d i r e c t l y a s s i g n e d t o i n u s e r