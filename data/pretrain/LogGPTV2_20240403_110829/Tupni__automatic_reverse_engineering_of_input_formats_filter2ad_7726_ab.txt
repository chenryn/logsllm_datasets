Line 5 reads the input into a sufﬁciently large buffer (input).
Line 6 reads the ﬁrst four bytes of input into num_records,
which tells the application how many records it needs to process.
Each iteration of the following loop (lines 7 to 14) processes one
record. Lines 7 and 8 exit the loop after the last record has been
processed (i == num_records). Lines 9 and 10 read the type
ﬁeld and the length ﬁeld of the record. Line 11 calls the handler
function for the given record type. We assume that the function
pointer array record_hdlr has been initialized with a handler
function for each record type. These handler functions are part of
the application, but not displayed in Figure 3 to keep the example
manageable. Finally, line 12 sets offset to the beginning of the
next record, and line 13 increments the index variable that counts
how many records have been processed.
The execution trace of running this program on the example in-
put is 5,6,7,...,14,7,...,14,7, 8,15. That is, after ex-
ecuting lines 5 and 6, the trace contains two full iterations of the
loop. Each segment 7,...,14 contains the instructions of the
handler function between lines 11 and 12.
3.3 Field Identiﬁcation
This ﬁrst step partitions the input into short sequences of consec-
utive bytes that are likely to correspond to basic ﬁelds in the input
format. Typically, several consecutive input bytes will be mapped
to a larger ﬁeld such as a 32-bit integer. We deduce this mapping by
observing the operands of CPU instructions. Given an operand of a
CPU instruction in the execution trace, we call the longest sequence
of tainted bytes from contiguous offsets contained in the operand
a chunk. Our algorithm identiﬁes all chunks in the execution trace
by stepping through the trace and inspecting the operands of each
instruction for taint. We ignore move instructions as they do not
process the operand and contain little information about ﬁeld sizes.
Any byte of the input that is read by the application will be con-
tained in at least one chunk. In general, a chunk may be accessed by
multiple instructions. We keep track of this by assigning a weight
w(c) to each chunk c. The weight of a chunk is simply the number
of instructions in the execution trace that access the chunk (ignor-
ing move instructions).
In this way, by observing the operands of x86 instructions, we
can identify chunks contained in 8-, 16-, 32- and 64-bit integer
operands as well as ﬂoating point chunks. We can also recognize
big-endian integers if we see a chunk with reversed bytes. Cur-
rently we track input chunks at byte granularity; we believe it takes
only engineering efforts to reﬁne this to bit granularity.
Running Example.
The ﬁrst time the application reaches line 7, the second operand
of the cmp instruction is tainted with the ﬁrst four bytes of the in-
put. This causes Tupni to create a chunk [0, 3] for offsets 0 to 3 and
to assign it weight 1. Note that the mov instruction in line 6 does
not create a chunk. It simply propagates taint into num_records.
Analogous statements apply to lines 9 and 10.
The next chunk [4, 5] is created in line 11 because record_type
is tainted with offsets 4 and 5. The instructions executed by the
record handler function called in line 11 will typically create further
chunks for the offsets inside the record. Since our simple example
does not specify handler functions, we ignore this part of the exe-
cution trace. Line 12 creates the chunk [6, 7] since record_size
is tainted with offsets 6 and 7.
In the second loop iteration, line 7 increases the weight of [0, 3]
to 2, and lines 11 and 12 act as in the previous iteration, creating
chunks [17, 18] and [19, 20], respectively. Finally, the third exe-
cution of line 7 raises the weight of [0, 3] to 3. The ﬁnal set of
chunks is [0, 3], [4, 5], [6, 7], [17, 18] and [19, 20]; plus any chunks
generated by the handler functions.
3.3.1 Error Correction
The next step is to map chunks to ﬁelds. A general difﬁculty is
that, during the course of its execution, an application may access
the same offset using different operand types. Thus, an offset may
be contained in different chunks. The most common application
behavior that gives rise to such inconsistencies includes (a) bulk
accesses (memory copies, checksums, etc.) in which the applica-
tion reads a part of the input without concern for ﬁeld boundaries
and (b) optimized string processing code that uses 32-bit (or larger)
operations to process an ASCII or unicode string.
The goal is to ﬁnd a consistent subset S of chunks such that we
can identify each chunk in S with a ﬁeld. Tupni has to ﬁnd a subset
S of chunks such that all chunks in S are disjoint and the combined
weight of the chunks in S is maximized. This is an instance of the
weighted Maximum k-Set Packing problem. While it is intractable
to even approximate the optimal solution under worst-case analy-
sis [21], the problem instances we obtain from real-world execution
traces are quite simple with little overlap among chunks. We use
the greedy algorithm [7] to compute S and identify the chunks in S
with input ﬁelds. Based on our evaluation (Section 4), this simple
algorithm seems sufﬁcient.
In general, the ﬁelds we have found may not cover the entire
input. In many cases, the application never accesses certain parts
of the input. Thus, observing the application reveals no information
about these parts. All Tupni can do is to mark the contiguous gaps
between ﬁelds as virtual ﬁelds.
In our simple example, all chunks are disjoint. Thus, Tupni pro-
motes all chunks into ﬁelds. Again, ignoring the handler functions,
offsets [8, 16] and [21, 26] are gaps between ﬁelds. Tupni adds
[8, 16], [21, 26] as virtual ﬁelds.
3.3.2 Strings
We consider strings as regular record sequences. Thus, we have
no string ﬁelds. Given a string, Tupni will recognize the string
characters as ﬁelds. The next section will describe how Tupni infers
that these character ﬁelds form a string as part of the more general
framework for recognizing record sequences.
A special problem arises for strings because many applications
use optimized string processing code that uses 32-bit rather than 8-
bit or 16-bit instructions to access strings. This could cause string
characters to be misclassiﬁed as 32-bit integers. Fortunately, the
optimized string processing code is easy to recognize. All instances
we have observed on Windows and Linux involve boolean and
comparison operations with two or three speciﬁc constants. If we
recognize optimized string processing code, we ignore the corre-
sponding instructions in the calculation of chunk weights.
3.4 Identiﬁcation of Record Sequences
This section describes how we identify record sequences. As
deﬁned in Section 2.2, a record sequence covers a contiguous se-
quence of offsets in the input. Our algorithm is based on the obser-
vation that applications have to use a loop or recursive calls to pro-
cess an unbounded sequence of records. We have developed Tupni
for the common case of loops. We believe that similar techniques
can be used to handle recursive calls.
The algorithm proceeds in the following three steps: (a) Identify
all loops that are executed in the execution trace; (b) For each loop,
ﬁnd the relevant input ﬁelds that are accessed in each loop iteration;
(c) For each loop that processes relevant input ﬁelds, identify the
record boundaries. The rest of the section describes each of the
three steps in detail.
3.4.1 Loop Identiﬁcation
The ﬁrst problem is to ﬁnd loops in the application. The solution
is to search for cycles in the control ﬂow graph (e.g., [3]). This
method yields a complete list of loops and their relationship. We
only consider loops with a single entry point.
The next task is to map the loop information to the execution
trace. Given a loop (a cycle in the control ﬂow graph), we can map
each instruction in that cycle to the program counter (EIP) value
at which the instruction was stored when the execution trace was
created. This makes use of the information about loaded binaries
mentioned in Section 3.1. For each loop, we maintain a compact
representation of the set of EIP values of the instructions in the
loop. We also store the EIP of the unique entry point of each loop.
Tupni tests for each position in the trace and for each loop whether
the EIP value at that position is contained in the set of EIP values
of the loop. The result of this process is the list of all subsequences
of the execution trace that correspond to the execution of a loop
(labeled with an identiﬁer for that loop).
Finally, we identify the individual loop iterations within each
subsequence. We mark the beginning of an iteration at the points
where the execution trace hits the (unique) entry point of the loop.
Running Example.
The code in Figure 3 has a single loop (cycle in the control ﬂow
graph) in lines 7 to 14. Line 7 is the only entry point of this loop.
Let A be a label for this loop. There may be further loops in the
handler functions. Those would be recognized as nested within
loop A. Since the execution trace in Section 3.2 uses line numbers
rather than EIP values, there is no mapping to be done. Otherwise,
we would have to look up at what base address the application bi-
nary was loaded when the execution trace was created. Comparing
the line numbers in the execution trace in Section 3.2 with the line
numbers of our loop (7 to 14), we ﬁnd that the subsequence that
starts at the third instruction in the trace and ends right before the
last instruction corresponds to the execution of loop A.
Tupni identiﬁes iterations by looking for the entry point of loop
A (line 7) within the subsequence.
It ﬁnds three occurrences of
line 7 in the subsequence (at the very beginning, toward the middle
and at the end. Thus, Tupni splits the subsequence into three itera-
tions at these three positions. The third iteration contains only lines
7 and 8.
3.4.2 Identifying Relevant Fields
In the following, we will also use the term loop as a shorthand
for “a subsequence of the execution trace labeled by a loop iden-
tiﬁer”. Most loops executed by applications do not process record
sequences from the input. We are only interested in those loops
that iterate over multiple input ﬁelds. In this step, we identify such
loops.
Consider a loop l and let n be the number of iterations that were
executed. We deﬁne sets Ii (1 ≤ i ≤ n) as follows: An instruction
(identiﬁed by its instruction pointer (EIP) value) is contained in Ii
if the instruction accesses a ﬁeld during the i-th loop iteration that
it does not access in any other iteration of l.
If In is empty then we treat the loop as if it had only n − 1
iterations. This special case is necessary since the last iteration of a
loop is often not a true iteration, but only a check of the termination
// number of loop iterations
// iteration dependent instructions for each loop iteration
for ( j from 1 to n ) {
if ( sj == −1 )
then sj = min{ Offset( Field( inst ) ) : inst ∈ Ij }
I = { inst∈ Ij : Offset( Field( inst ) ) = sj }
for ( i from j + 1 to n )
if ( I ∩ Ii (cid:4)= {} )
si = min{ Offset( Field( inst ) ) : inst ∈ Ii ∩ I}
for ( j from 1 to n ) sj = −1; // mark start of record j as unknown
IN n,
IN (I1, . . . , In),
FindRecordBoundaries(
1.
2.
3. OUT (s1, . . . , sn),// start offset of each record
4. OUT (e1, . . . , en) )// end offset of each record
5.
6.
7.
8.
9.
10.
11.
12.
13.
14.
15. }
16.
17. for ( j from 1 to n − 1 ) ej = sj+1 − 1;
18. en = max{ Offset( Field( inst ) ) +
sizeof( Field( inst ) ) : inst ∈ In}
Figure 4: Identiﬁcation of record boundaries
S
We call
condition (as in our example, where the third iterations consists
only of lines 7 and 8).
i Ii the set of iteration dependent instructions. We call
a loop iteration dependent if Ii (cid:3)= {} for all i ∈ {1, . . . , n − 1}.
We compute the sets Ii for all loops identiﬁed in the previous
step. At the end of this analysis, we obtain the list of iteration
dependent loops in the execution trace and, for each iteration de-
pendent loop, the sets Ii of its iteration dependent instructions.
Running Example.
I1 = {9, 10, 11} and I2 = {9, 10, 11}. Thus, the loop is itera-
tion dependent. For example, line 9 accesses ﬁeld [4, 5] in the ﬁrst
iteration and only in the ﬁrst iteration. Thus, it belongs to I1, It
also accesses ﬁeld [17, 18] in the second iteration and in no other
iteration. Thus, it also belongs to I2. On the other hand, line 7
is not iteration dependent. It accesses the same ﬁeld ([0, 3]) in all
iterations.
3.4.3 Identifying Record Boundaries
In this step, we group ﬁelds into records and identify the record
boundaries. We make use of the fact that, given the deﬁnitions
of Section 2.2, a record is a contiguous sequence of ﬁelds and a
record sequence consists of contiguous records. Furthermore, we
assume that the loop processes records in the order in which they
appear in the input. Loops that do not satisfy this assumption are
ignored. However, we can handle loops whose iterations access
ﬁelds in records outside the record currently being processed.
Our algorithm is shown in Figure 4. Tupni calls this algorithm
for every iteration dependent loop. For ease of presentation, the
ﬁgure assumes that each iteration dependent instruction inst ac-
cesses only one ﬁeld (Field(inst)). This assumption has no
fundamental importance. Its only purpose is to remove tedious de-
tails from Figure 4.
For any ﬁeld f, let Offset(f) denote the offset in the input of
the ﬁrst byte of f. The algorithm sets the start of the ﬁrst record to
min{ Offset(f)}, where the minimum is taken over all ﬁelds
that are accessed by iteration dependent instructions in the ﬁrst it-
eration of the loop (line 10). Next, in line 11, it identiﬁes the set
I of iteration dependent instructions that access the ﬁeld at the be-
ginning of the ﬁrst record in the ﬁrst iteration. The scheme now
uses the heuristic that the instructions in I are likely to access the
beginning of a record whenever they appear. Thus, it looks for in-
structions from I in each iteration (line 13) and sets the start of
the corresponding record accordingly (line 14). The process is re-
peated (line 8) for the case that an iteration does not use any in-
struction from I. Finally, the end of each record is set to the offset
immediately before the start of the next record (line 17). The end of
the last record is set to the last input byte accessed by any iteration
dependent instruction in the last iteration (line 18). This procedure
is performed for all iteration dependent loops. A loop is ignored if
the computed record start addresses are not increasing.
Running Example.
The algorithm sets s1 = 4 (line 10), since I1 = {9, 10, 11},
Field(9) = [4, 5] and Offset([4, 5]) = 4. That is, 4 is the
smallest offset accessed by instructions in I1. Line 11 sets I =
{9, 11} since both instructions accessed ﬁeld [4, 5] in the ﬁrst iter-
ation. Next, it sets s2 = 17 since instructions 9 and 11 access ﬁeld
[17, 18] in the second iteration. Line 17 sets e1 = s2 − 1 = 16. Fi-
nally, line 18 sets e2 = 20 the largest offset accessed by an instruc-
tion from I2. While all other values are correct, e2 is somewhat too
small. This is primarily the result of the fact that we have ignored
the handler functions called in line 11 of the example application.
3.4.4 Length Determination
We also output for each record sequence how its length is de-
termined. We consider the following three cases: (a) The length
is determined by a termination record (e.g., null terminated ASCII
strings); (b) The length is determined by a separate length ﬁeld;
(c) The length is ﬁxed and implicitly determined by the protocol
speciﬁcation.
Tupni identiﬁes case (a) (termination record) by checking all
equality comparisons between a constant and the value of a ﬁeld ac-
cessed by an iteration dependent instruction. We classify the record
sequence as case (a) if we observe a constant for which there is such
an equality check that evaluates to false in each iteration (up to but
not including the last iteration) and if the last iteration contains an
equality check with the same constant that succeeds. For case (b)
(length ﬁelds), we use a technique from Polyglot [6]: We iden-
tify ﬁelds that are accessed to compute the termination condition of
loops. If we do not recognize case (a) or (b), we classify the record
sequence as case (c) (implicit length).
3.5 Record Type Identiﬁcation
Typical formats specify record sequences such that records come
from a small set of classes (the record types of Section 2.2). So far,
we have identiﬁed record sequences, found out how the length of
the record sequence is determined and found the boundaries of the
individual records in a sequence. In this step, Tupni tries to ﬁnd the
record type for each record. More precisely, Tupni considers two
records as belonging to the same record type if the loop iterations
that process the records execute “mostly” the same instructions.
This is based on the observation that applications typically have a
separate handler function for each record type.
The problem is complicated by the fact that record sequences
may be nested. That is, there are sequences whose records contain
other sequences. If a record contains a child record sequence then
the instructions that process it may depend heavily on the particu-
lar instance of the child record sequence it contains. Thus simply
looking for similar instruction sequences will not solve the prob-
lem.
Let l be an iteration dependent loop, and let r be the record
sequence l processes. Let n be the number of records in r. For
i ∈ {1, . . . , n}, we deﬁne Qi to be the subset of instructions from
Ii that access ﬁelds in the i-th record of r. We compute the sets Qi
for every record sequence we have identiﬁed in the previous step.