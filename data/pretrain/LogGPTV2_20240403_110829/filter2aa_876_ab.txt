As the Nt and Zw functions are meant to call the same kernel functions (see here,
here and here for why they exist), we can safely ignore one them, so we’ll cut off
the Zw functions. I myself am not too familiar with the thread pool manager, so I’ll
drop the Tp functions as well, which leaves us with a much smaller set of
potentially interesting functions:
Sample selection of ALPC function
Once again the goal here is not to select a specic set of functions, but instead just
making a selection based on something. It’s always a good idea to select things you
know or that sound familiar and cycle down a learning path from there…
The upper list of the no-component ALPC functions does have a lot of function
names containing the words “CompletionList”, which might or might not sound
familiar to you. The bottom list of Nt ALPC functions on the other hand appears
quite heterogeny and based on the Nt component naming convention I would
assume that these functions are meant to be gateway functions from user-land to
kernel-land. We’ve drilled down this far so let’s take one these functions and start
the reversing job. 
There is no right and wrong in picking one, you can be lucky and pick a function
that is meant to be used during the early stage of an ALPC setup, which has further
hints on how to use ALPC, or one might unknowingly pick a function that is only
meant for special ALPC scenarios… the joy of undocumented stuff… 
At this point we can’t know which function is a good starting point, so let’s choose
one that at least sounds like its meant to be used at the start of a process, like
something with Create in its name:
Selected function: NTAlpcCreatePort
I obviously already know that this function is going to be useful, so forgive me the “let’s
pick something randomly”-dance.
Let’s re up Ghidra and have a look at the NtAlpcCreatePort  function within
ntdll.dll :
NtAlpcCreatePort in Ghidra
Ok… this is not increadibly helpful… and also looks odd. A syscall is made with no
arguments and the function then returns the integer 0x79… 
Double checking this decompiled code with the actual instructions displayed right
next to the decompiled window, does show a different picture:
From User to Kernel Land
NtAlpcCreatePort in Ghidra with assembly code
The actual code instructions show that the integer value 0x79 is moved into EAX
and then the syscall is made. Quickly double checking this with IDA Free to be sure:
NtAlpcCreatePort in IDA Free
Yep, okay that makes more sense. First take away here is: Ghidra is a really great
tool, the decompilation feature can be aky (even for simple functions), but on the
other hand: Automated decompilation is a massive feature that is handed out for
free here, so no hard feelings about some errors and manual double checking effort.
We gured the NtAlpcCreatePort  function within ntdll.dll  is pretty much
calling into kernel mode right away using the syscall number 0x79  (121 in
decimal). 
From here we got three options to continue:
>> Head to the kernel straight away and look for a function with a similar name
and hope that we get the right one (ntdll and kernel function names are often
very similar) - This is the least reliable method.
>> Lookup the syscall number (0x79) online to nd the corresponding kernel
function.
>> Manually step through the process of getting and resolving the syscall
number on your host system - This is the most reliable method.
Let’s skip lazy option 1 (least reliable) and check out options two and three.
Lookup Syscall number online 
One of the best (and most known) resources to lookup syscall numbers is
https://j00ru.vexillium.org/syscalls/nt/64/ (x86 syscalls can be found here).
Syscall reference from https://j00ru.vexillium.org/syscalls/nt/64/
For my Windows 10 20H2 system this great online resource directly points me to a
kernel function named “NtAlpcCreatePort”.
Stepping through the syscall manually 
I’ve learned and applied the process from www.ired.team, all credits and kudos go to
ired.team !
We can use WinDbg to manually extract the corresponding kernel function from our
debugged host systems. There are 6 steps involved here:
1. Setting a breakpoint in ntdll at ntdll!NtAlpcCreatePort  to jump into the
function. This can be done through the following WinDbg command: 
kd:> bp ntdll!NtAlpcCreatePort
2. Verify our breakpoint is set correctly, via: kd:> bl
List breakpoints in WinDbg
3. Let the debuggee run until this breakpoint in ntdll is hit: kd:> g
4. Ensure we are at the correct location and have the syscall right ahead: kd:>
u .  (unassemble the next following instructions)
Disassembled syscall in WinDbg
5. Lookup the offset in the SSDT (System Service Descriptor Table) for the syscall
number, 0x79: kd:> dd /c1 kiservicetable+4*0x79 L1
6. Checking the address of the syscall function using the SSDT offset: kd:> u
kiservicetable + (02b62100>>>4) L1
All these steps can be found in the screenshot below:
Dispatching a syscall in WinDbg
Using either of these three methods we would have come to the result that
ntdll!NtAlpcCreatePort  calls into the kernel at nt!NtAlpcCreatePort
Now we’ve gured that we end up calling the kernel in nt!NtAlpcCreatePort , so
let’s have a look at this. 
We can re up IDA Free (Ghidra would’ve been just as ne), open up ntoskrnl.exe
from our system directory, e.g. C:\Windows\System32\ntoskrnl.exe, load Microsoft’s
public symbols, and we should be able to nd the function call
NtAlpcCreatePort . From there on we can browse through the functions that are
called to get a rst idea of what’s going on under the hood for this call.
NtAlpcCreatePort in IDA Free
Following the rst few function calls will route us to a call to ObCreateObjectEx ,
which is an ObjectManager (Ob) function call to create a kernel object. That sounds
like our ALPC object is created here and IDA also tells us what type of object that is,
two lines above the marked call in the window on the right, a
AlpcPortObjectType . At this point I’d like to try to get a hold of such an object to
get a better understanding and insight of what this actually is. As the function
ObCreateObjectEx  will create the object the plan here is to switch back to
Hunting An ALPC Object
WinDbg and set a breakpoint right after this call to nd and inspect the created
object.
NtAlpcpCreatePort breakpoint in WinDbg
After placing this breakpoint we hit g  to let WinDbg run and once it hits we check
if we can nd the created object being referenced somewhere. The reliable method
for this is to follow the object creation process in ObCreateObjectEx  and track
where the object is stored once the function nishes (the less reliable option is to
check the common registers and the stack after the function nishes). 
In this case we can nd the created ALPC object in the RCX register once we hit our
breakpoint.
ALPC port object in WinDbg
Sweet we found a newly created ALPC port object. At this point the !object
command can tell us the type of the object, the location of its header and its name,
but it can’t add additional detail for this object, because it does not now its internal
structure. We do not know either, but we could check if there is a matching public
structure inside the kernel that we can resolve. We’ll try that with kd:> dt
nt!*Alpc*Port …
Resolved _ALPC_PORT structure in WinDbg
We once again used wildcards combined with the information we obtained so far,
which are: We’re looking for a structure inside the kernel module (nt) and we’re
looking for a structure that matches an object that we knew is of type
AlpcPortObjectType. The naming convention in Windows often names structures with
a leading underscore and all capital letters. The rst hit ntkrnlmp!_ALPC_PORT
looks like a promising match, so let’s stuff our captured ALPC port object in this
structure:
Applied _ALPC_PORT structure in WinDbg
That does indeed look like a match, however some attributes, that one would
expect to be set, are empty, for example the “OwnerProcess” attribute. Before we
throw our match in the bin, let’s remember we’re still in the breakpoint right after
ObCreateObjectEx , so the object has just been created. Walking back through
functions we’ve traversed in IDA, we can nd that there are a couple more functions
to be called within the AlpcpCreateConnectionPort  function, such as
AlpcpInitializePort , AlpcpValidateAndSetPortAttributes  and others.
Sounds like there is more to come that we want to catch.
Right now, we’re in some process that created an ALPC port (so far we didn’t even
bother to check which process that is) and we want to jump to a code location after
all the initialization functions are completed and check what our ALPC port
structure looks like then, so here’s a rundown of what we want we want to do:
1. We want to note down the address of our ALPC object for later reference.
2. We want to nd the end of the AlpcpCreateConnectionPort  function.
3. We want to jump to this location within the same process that we currently
are in,
4. We want to load our noted ALPC object into the ntkrnlmp!_ALPC_PORT
structure to see what it looks like.
And here’s how to do that…
1. Noting down the ALPC object address… Done: ffffac0e27ab96e0
Noting down the ALPC Port object reference
2. Finding the end of AlpcpCreateConnectionPort … Done jumping to
0xfffff803733823c9
Finding the end of the AlpcpCreateConnectionPort function
3. Jump to this address within the same process can be done using this
command kd:> bp /p @$proc fffff803733823c9  
Note: I’m also checking in which process I am before and after the call just to be
on the safe side
Jumping to the located address
4. Check ALPC Objet structure again…
Re-applied _ALPC_PORT structure in WinDbg
That looks more complete and we could walk through an all setup ALPC object from
here as easy as using the links provided by WinDbg to inspect what other structures
and references are linked to this object. 
Just for the sake of providing an example and to double conrm that this ALPC Port
object is indeed owned by the svchost.exe process that we identied above, we can
inspect the _EPROCESS structure that is shown at ntkrnlmp!_ALPC_PORT + 0x18 :
_EPROCESS structure of the owning process in WinDbg
We nd the ImageFileName of the owning process of the ALPC object that we’ve
caught to be “svchost.exe”, which matches with the process we’re currently in.
At this point we’ve found an all setup ALPC port object that we could further dissect
in WinDbg to explore other attributes of this kernel object. I’m not going any deeper
here at this point, but if you got hooked on digging deeper feel free to continue the
exploration tour. 
If you’re following this path, you might want to explore the ALPC port attributes
assigned to the port object you found, which are tracked in the
nt!_ALPC_PORT_ATTRIBUTES  structure at nt!_ALPC_PORT + 0x100  to check the
Quality of Service (QOS) attribute assigned to this object ( nt!_ALPC_PORT + 0x100
+ 0x04 ).
If you found an ALPC port object with an (QOS) impersonation level above
SecurityIdentication, you might have found an interesting target for an
impersonation attack, detailed in my previous post Offensive Windows IPC Internals
3: ALPC.
_SECURITY_QUALITY_OF_SERVICE structure of the identied ALPC port object in WinDbg
In this case, it’s only SecurityAnonymous, well…
By now you should be all set up to explore and dig into ALPC. The rst steps are
obviously going to be slow and you (and I) will take a few wrong turns, but that is
part of everyone’s learning experience.
If I could add a last note to aid in getting on a joyful ride it’s this: I personally enjoy
reading good old, paperback books, to learn, dig deeper and to improve my skillset
with Windows internals. If you are of similar kind, you might as well enjoy these
book references (if you not already have them on your desk):
>> Windows Internals Part 1
>> Windows Internals Part 2
>> Inside Windows Debugging
>> Windows Kernel Programming 
There already is a published 1st edition of this, but if you want the latest and
greates you might want to wait for @zodiacon’s new release.
… Enjoy your ride ;) …
Other Posts
Offensive Windows IPC Internals 3: ALPC 24 May 2022
Offensive Windows IPC Internals 2: RPC 21 Feb 2021
Offensive Windows IPC Internals 1: Named Pipes 10 Jan 2021