Program terminated with signal SIGSEGV, Segmentation fault.
#0 0x5655559b in main ()
gdb-peda$ info frame
Stack level 0, frame at 0x41414141:
eip = 0x5655559b in main; saved eip = 
Outermost frame: Cannot access memory at address 0x4141413d
Arglist at 0x41414141, args:
Locals at 0x41414141, Previous frame's sp is 0x41414141
Cannot access memory at address 0x4141413d
调用约定
函数调用约定是对函数调用时如何传递参数的一种约定。关于它的约定有许多种，
下面我们分别从内核接口和用户接口介绍 32 位和 64 位 Linux 的调用约定。
内核接口
35
1.3 Linux 基础
x86-32 系统调用约定：Linux 系统调用使用寄存器传递参数。 eax 为
syscall_number， ebx 、 ecx 、 edx 、 esi 、 ebp 用于将 6 个参数传递给
系统调用。返回值保存在 eax 中。所有其他寄存器（包括 EFLAGS）都保留在
int 0x80 中。
x86-64 系统调用约定：内核接口使用的寄存器
有： rdi 、 rsi 、 rdx 、 r10 、 r8 、 r9 。系统调用通过 syscall 指令
完成。除了 rcx 、 r11 和 rax ，其他的寄存器都被保留。系统调用的编号必
须在寄存器 rax 中传递。系统调用的参数限制为 6 个，不直接从堆栈上传递任何
参数。返回时， rax 中包含了系统调用的结果。而且只有 INTEGER 或者
MEMORY 类型的值才会被传递给内核。
用户接口
x86-32 函数调用约定：参数通过栈进行传递。最后一个参数第一个被放入栈中，直
到所有的参数都放置完毕，然后执行 call 指令。这也是 Linux 上 C 语言函数的方
式。
x86-64 函数调用约定：x86-64 下通过寄存器传递参数，这样做比通过栈有更高的
效率。它避免了内存中参数的存取和额外的指令。根据参数类型的不同，会使用寄
存器或传参方式。如果参数的类型是 MEMORY，则在栈上传递参数。如果类型是
INTEGER，则顺序使用 rdi 、 rsi 、 rdx 、 rcx 、 r8 和 r9 。所以如果
有多于 6 个的 INTEGER 参数，则后面的参数在栈上传递。
环境变量
环境变量字符串都是 name=value 这样的形式。大多数 name 由大写字母加下画
线组成，一般把 name 部分叫做环境变量名，value 部分则是环境变量的值，而且
value 需要以 "/0" 结尾，环境变量定义了该进程的运行环境。
分类
按照生命周期划分
永久环境变量：修改相关配置文件，永久生效。
临时环境变量：使用 export 命令，在当前终端下生效，关闭终端后失
效。
36
1.3 Linux 基础
按照作用域划分
系统环境变量：对该系统中所有用户生效。
用户环境变量：对特定用户生效。
设置方法
在文件 /etc/profile 中添加变量，这种方法对所有用户永久生效。如：
# Set our default path
PATH="/usr/local/sbin:/usr/local/bin:/usr/bin"
export PATH
添加后执行命令 source /etc/profile 使其生效。
在文件 ~/.bash_profile 中添加变量，这种方法对当前用户永久生效。其
余同上。
直接运行命令 export 定义变量，这种方法只对当前终端临时生效。
常用变量
使用命令 echo 打印变量：
$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/lib/jvm/default/bin
:/usr/bin/site_perl:/usr/bin/vendor_perl:/usr/bin/core_perl
$ echo $HOME
/home/firmy
$ echo $LOGNAME
firmy
$ echo $HOSTNAME
firmy-pc
$ echo $SHELL
/bin/bash
$ echo $LANG
en_US.UTF-8
使用命令 env 可以打印出所有环境变量：
37
1.3 Linux 基础
$ env
COLORFGBG=15;0
COLORTERM=truecolor
...
使用命令 set 可以打印处所有本地定义的 shell 变量：
$ set
'!'=0
'#'=0
...
使用命令 unset 可以清楚环境变量：
unset $变量名
LD_PRELOAD
该环境变量可以定义在程序运行前优先加载的动态链接库。在 pwn 题目中，我们可
能需要一个特定的 libc，这时就可以定义该变量：
LD_PRELOAD=/path/to/libc.so ./binary
一个例子：
$ ldd /bin/true
linux-vdso.so.1 => (0x00007fff9a9fe000)
libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f1c083d90
00)
/lib64/ld-linux-x86-64.so.2 (0x0000557bcce6c000)
$ LD_PRELOAD=~/libc.so.6 ldd /bin/true
linux-vdso.so.1 => (0x00007ffee55e9000)
/home/firmy/libc.so.6 (0x00007f4a28cfc000)
/lib64/ld-linux-x86-64.so.2 (0x000055f33bc50000)
38
1.3 Linux 基础
注意，在加载动态链接库时需要使用 ld.so 进行重定位，通常被符号链接到
/lib64/ld-linux-x86-64.so 中。动态链接库在编译时隐式指定 ld.so 的搜
索路径，并写入 ELF Header 的 INTERP 字段中。从其他发行版直接拷贝已编译的
.so 文件可能会引发 ld.so 搜索路径不正确的问题。相似的，在版本依赖高度
耦合的发行版中(如 ArchLinux)，版本相差过大也会引发 ld.so 的运行失败。
本地同版本编译后通常不会出现问题。如果有直接拷贝已编译版本的需要，可以对
比 interpreter 确定是否符合要求，但是不保证不会失败。
上面的例子中两个 libc 是这样的：
$ file /lib/x86_64-linux-gnu/libc-2.23.so
/lib/x86_64-linux-gnu/libc-2.23.so: ELF 64-bit LSB shared object
, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter
/lib64/ld-linux-x86-64.so.2, BuildID[sha1]=088a6e00a1814622219f
346b41e775b8dd46c518, for GNU/Linux 2.6.32, stripped
$ file ~/libc.so.6
/home/firmy/libc.so.6: ELF 64-bit LSB shared object, x86-64, ver
sion 1 (GNU/Linux), dynamically linked, interpreter /lib64/ld-li
nux-x86-64.so.2, BuildID[sha1]=088a6e00a1814622219f346b41e775b8d
d46c518, for GNU/Linux 2.6.32, stripped
都是 interpreter /lib64/ld-linux-x86-64.so.2 ，所以可以替换。
而下面的例子是在 Arch Linux 上使用一个 Ubuntu 的 libc，就会出错：
$ ldd /bin/true
linux-vdso.so.1 (0x00007ffc969df000)
libc.so.6 => /usr/lib/libc.so.6 (0x00007f7ddde17000)
/lib64/ld-linux-x86-64.so.2 => /usr/lib64/ld-linux-x86-6
4.so.2 (0x00007f7dde3d7000)
$ LD_PRELOAD=~/libc.so.6 ldd /bin/true
Illegal instruction (core dumped)
39
1.3 Linux 基础
$ file /usr/lib/libc-2.26.so
/usr/lib/libc-2.26.so: ELF 64-bit LSB shared object, x86-64, ver
sion 1 (GNU/Linux), dynamically linked, interpreter /usr/lib/ld-
linux-x86-64.so.2, BuildID[sha1]=458fd9997a454786f071cfe2beb2345
42c1e871f, for GNU/Linux 3.2.0, not stripped
$ file ~/libc.so.6
/home/firmy/libc.so.6: ELF 64-bit LSB shared object, x86-64, ver
sion 1 (GNU/Linux), dynamically linked, interpreter /lib64/ld-li
nux-x86-64.so.2, BuildID[sha1]=088a6e00a1814622219f346b41e775b8d
d46c518, for GNU/Linux 2.6.32, stripped
一个在 interpreter /usr/lib/ld-linux-x86-64.so.2 ，而另一个在
interpreter /lib64/ld-linux-x86-64.so.2 。
environ
libc 中定义的全局变量 environ 指向环境变量表。而环境变量表存在于栈上，所
以通过 environ 指针的值就可以泄露出栈地址。
40
1.3 Linux 基础
gdb-peda$ vmmap libc
Start End Perm Name
0x00007ffff7a1c000 0x00007ffff7bcf000 r-xp /usr/lib/libc-2.
27.so
0x00007ffff7bcf000 0x00007ffff7dce000 ---p /usr/lib/libc-2.
27.so
0x00007ffff7dce000 0x00007ffff7dd2000 r--p /usr/lib/libc-2.
27.so
0x00007ffff7dd2000 0x00007ffff7dd4000 rw-p /usr/lib/libc-2.
27.so
gdb-peda$ vmmap stack
Start End Perm Name
0x00007ffffffde000 0x00007ffffffff000 rw-p [stack]
gdb-peda$ shell nm -D /usr/lib/libc-2.27.so | grep environ
00000000003b8ee0 V environ
00000000003b8ee0 V _environ
00000000003b8ee0 B __environ
gdb-peda$ x/gx 0x00007ffff7a1c000 + 0x00000000003b8ee0
0x7ffff7dd4ee0 : 0x00007fffffffde48
gdb-peda$ x/5gx 0x00007fffffffde48
0x7fffffffde48: 0x00007fffffffe1da 0x00007fffffffe1e9
0x7fffffffde58: 0x00007fffffffe1fd 0x00007fffffffe233
0x7fffffffde68: 0x00007fffffffe25f
gdb-peda$ x/5s 0x00007fffffffe1da
0x7fffffffe1da: "COLORFGBG=15;0"
0x7fffffffe1e9: "COLORTERM=truecolor"
0x7fffffffe1fd: "DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/10
00/bus"
0x7fffffffe233: "DESKTOP_SESSION=/usr/share/xsessions/plasma"
0x7fffffffe25f: "DISPLAY=:0"
procfs
procfs 文件系统是 Linux 内核提供的虚拟文件系统，为访问系统内核数据的操作提
供接口。之所以说是虚拟文件系统，是因为它不占用存储空间，而只是占用了内
存。用户可以通过 procfs 查看有关系统硬件及当前正在运行进程的信息，甚至可以
通过修改其中的某些内容来改变内核的运行状态。
41
1.3 Linux 基础
/proc/cmdline
在启动时传递给内核的相关参数信息，通常由 lilo 或 grub 等启动管理工具提供：
$ cat /proc/cmdline
BOOT_IMAGE=/boot/vmlinuz-4.14-x86_64 root=UUID=8e79a67d-af1b-420
3-8c1c-3b670f0ec052 rw quiet resume=UUID=a220ecb1-7fde-4032-87bf
-413057e9c06f
/proc/cpuinfo
记录 CPU 相关的信息：
42
1.3 Linux 基础
$ cat /proc/cpuinfo
processor : 0
vendor_id : GenuineIntel
cpu family : 6
model : 60
model name : Intel(R) Core(TM) i5-4210H CPU @ 2.90GHz
stepping : 3
microcode : 0x24
cpu MHz : 1511.087
cache size : 3072 KB
physical id : 0
siblings : 4
core id : 0
cpu cores : 2
apicid : 0
initial apicid : 0
fpu : yes
fpu_exception : yes
cpuid level : 13
wp : yes
flags : fpu vme de pse tsc msr pae mce cx8 apic sep mt
rr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss
ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon
pebs bts rep_good nopl xtopology nonstop_tsc cpuid aperfmperf p
ni pclmulqdq dtes64 monitor ds_cpl vmx est tm2 ssse3 sdbg fma cx
16 xtpr pdcm pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline
_timer aes xsave avx f16c rdrand lahf_lm abm cpuid_fault epb inv
pcid_single pti ibrs ibpb stibp tpr_shadow vnmi flexpriority ept
vpid fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid xsave
opt dtherm ida arat pln pts
bugs : cpu_meltdown spectre_v1 spectre_v2 spec_store_
bypass
bogomips : 5788.66
clflush size : 64
cache_alignment : 64
address sizes : 39 bits physical, 48 bits virtual
power management:
...
43
1.3 Linux 基础
/proc/crypto
已安装的内核所使用的密码算法及算法的详细信息：
$ cat /proc/crypto
name : ccm(aes)
driver : ccm_base(ctr(aes-aesni),cbcmac(aes-aesni))
module : ccm
priority : 300
refcnt : 2
selftest : passed
internal : no
type : aead
async : no
blocksize : 1
ivsize : 16
maxauthsize : 16
geniv : 
...
/proc/devices
已加载的所有块设备和字符设备的信息，包含主设备号和设备组（与主设备号对应
的设备类型）名：
$ cat /proc/devices
Character devices:
1 mem
4 /dev/vc/0
4 tty
4 ttyS
5 /dev/tty
5 /dev/console
...
/proc/interrupts
44
1.3 Linux 基础
X86/X86_64 系统上每个 IRQ 相关的中断号列表，多路处理器平台上每个 CPU 对
于每个 I/O 设备均有自己的中断号：
$ cat /proc/interrupts
CPU0 CPU1 CPU2 CPU3
0: 15 0 0 0 IR-IO-APIC 2
-edge timer
1: 46235 1277 325 156 IR-IO-APIC 1
-edge i8042
8: 0 1 0 0 IR-IO-APIC 8
-edge rtc0
...
NMI: 0 0 0 0 Non-maskable
interrupts
LOC: 7363806 5569019 6138317 5442200 Local timer i
nterrupts
SPU: 0 0 0 0 Spurious inte
rrupts
...
/proc/kcore
系统使用的物理内存，以 ELF 核心文件（core file）格式存储：
$ sudo file /proc/kcore
/proc/kcore: ELF 64-bit LSB core file x86-64, version 1 (SYSV),
SVR4-style, from 'BOOT_IMAGE=/boot/vmlinuz-4.14-x86_64 root=UUID
=8e79a67d-af1b-4203-8c1c-3b670f0e'