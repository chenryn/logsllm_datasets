误。当你做一个修改，你随即运行测试程序套件。如果通过，你可
以有理由相信你没有破坏系统的其他部分。这种方式不仅可用于提
交代码的阶段，也可以用在开发代码的阶段：做一个小的改动，运
行测试，再作大一点的改动，再次运行测试。如果某次修改导致测
试失败，那么立即取消这次改动。
这使得Python维护一个稳定构建的理念：如果测试通过，你便可以从
头签出代码并获得一个可运行的Python。这种稳定性对Python的普及
是十分必要的。为了保持这一理念，Python利用了多种测试方式（静
态测试和动态测试），组合它们使人们确信测试套件将捕获到大部
分错误。此外，错误修复必须伴随一个测试程序，这个测试程序必
须是在老的代码上运行失败，但在修复后的代码上运行成功。这是
规则，虽然它并不是一直都被遵循，但是我们发现它是一个宝贵经
验，并会争取坚持下去。
1942
---
## Page 1944
Python社区发现这个测试过程非常重要，以致他们正在采用一种预提
交系统。预提交系统使提交者将无法提交代码直到所有测试都通
过。这表明，测试套件的存在不只纯粹是为了防止没有经验的新手
可能造成的编码错误。随着Python在大小、规模、复杂性上的增长，
测试套件甚至可以捕捉到有经验的核心开发员所引入的错误。这是
受到几个核心Python开发人员的影响，他们运用了一个预提交系统。
当我们感受到了这种策略带来的好处，我们确信这将对Python非常有
益。
测试套件在Python语言开发中的作用超出了仅仅测试Python代码库本
身。任何Python语言的修改都可能意外地破坏其兼容性（因为我们更
新了测试）。如果Python应用程序有全面的测试系列，那么这些测试
套件很大程度上成为Python语言本身的测试套件。这样，Python的测
试套件的作用超越仅测试它本身的代码库，而是延展到测试每一个
用Python编写的应用软件。
[1] http://www.python.org/dev/peps/pep-0020/
[2] http://www.python.org/.
[3] http://www.valgrind.org/.
[4] http://www.coverity.com/.
[5] http://www.klocwork.com/.
[6] http://www.python.org/devlcommitters.
[Z] http://www.vimeo.com/1093745.
确保正确性
显而易见的是，测试的主要目的（尽管不是唯一的）是要找到错
误。首先，每个开发人员运行大部分测试套件，然后提交。为什么
只是“大部分”？整个测试套件，包括所有选择，需要一个多小时才
能运行完毕。大多数开发人员不会等那么久才提交代码。我们要
求开发人员运行②最多7分钟长度的测试套件，七分钟是一段大部
分开发人员愿意等待的时间。我们宁愿让他们每次都运行轻量级测
试套件，而不要求他们运行完整的测试套件，这是因为怕他们不想
运行全套测试而干脆什么测试都不运行了。但是，由于完整的测试
套件的确能在冒烟测试（smoketest）之上提供价值，我们需要找适
当的方式来运行它们。
Buildbot系统
1943
---
## Page 1945
Buildbot系统3可以在许多平台上测试检查每一个代码提交。它可
以在所有活动的代码分支上运行（目前2.6、主干[2.7]、3.1和
py3k[3.2]）[±]，Buildbot系统可以在大约15～20不同的体系结构上运
行测试。而且我们要增加更多的系统。[运行测试的机器都是人们
捐赠的。我们一直在寻求多样性。当任何buildbot构建或测试失败
时，它会发送电子邮件给Python-checkins邮件组。]理论上提交代
码后开发人员要格外关注他的电子邮箱，看他的提交是否引起任何
问题。
由于大多数开发员在x86机器运行Linux或MacOSX，并且用gcc编译
器编译，[Zl这有助于确保Windows和其他少数平台保持稳定。我们]
有一组“稳定"的平台，我们不会发布Python，直到buildbot通过所有
测试。
有时buildbot能够捕捉很微妙问题，这些问题会给用户造成真正的麻
烦。早在2008年1月，[引进：
char sign=reverse?-1: 1;
到mmap.rfindO的执行过程中。在大多数平台上，这不会出问题，但
是那些字符属于unsigned的平台上，它会出错。很少的开发员会使用
这样的平台，这样人们很可能发现不了这样的问题，直到它给用户
造成错误。幸运的是，buildbot运行在一些字符属于unsigned类型的
平台，测试程序在这些系统上的确失败了。经过了一些摸索，凹我
们成功地发现错误所在并修改它，一周后的r60346生成了。10因为
我们知道buildbot开始失败，只有少数的代码修改可能造成这样的问
题。如果我们等待用户发现问题，那么此人要汇报一个bug，并发人
员很可能将不得不作二分搜索来发现错误代码，整个过程将很长也
很痛苦。使用buildbot的早期预警系统，我们知道自己在哪里查找问
题，用户则不必承受错误带来的麻烦。
引用泄漏（refleak）测试
Python解释器主要是用C编写的，这意味着它需要一些方法来释放内
存。Python用引用计数ll]来管理内存，并具有循环垃圾收集器。如
果C代码递增了一个对象的引用但没有去递减，那么你会遇到一个特
1944
---
## Page 1946
定类型的内存泄漏，我们称之为一个引用泄漏或"refleak"。要发现此
情况，Python的调试版本[12]跟踪引用总计数。调试版本是一种特殊
的方式编译的Python，它用来辅助不同类型的调试。调试版本包括了
更多的信息和断言，这些信息不会出现在正式发布版本中。这些额
外信息使得调试版本运行缓慢，消耗更多的内存。
因为调试版本跟踪引用数，测试套件可以连续运行每个测试程序两
三遍来比较引用总数。即使没有任何引用泄漏，引用数可能在第一
次运行和第二次运行时会有所上开，这是因为缓存的对象，但如果
引用数经过多次运行有增无减，特别是如果它每次运行都上开相同
数量，那么一定出现了引用泄漏。
在此模式下，我们每天运行两次测试套件来发现新出现的refleak。
但愿我们能更多地运行它，因为refleak往往比较容易被发现，如果
你确切知道是什么代码变化导致的。但是refleak运行测试套件的时
间是普通测试套件的9倍，这样一天两次是一个合理的妥协。
当前的结果在http://docs.python.org/dev/results/make-test-refleak.out
各模式测试套件的脚本在
文件测试
Python的文档是用重组建文本（reST）[3]写的，然后转换为
HTML，错误格式的reST可能生成错误HTML。像其他任何构建，我
们需要确保建立正确的文档。我们每天两次自动在同一脚本运行测
试套件。最新版本的文档在http://docs.python.org/dev/。有一个更新的
文档往往带来额外的好处：许多用户在开发版的文档中发现的问
题。一旦我们开始每晚更新在线文档，文档错误能在没有正式发布
前被发现和修改。总体而言，用户能够获得更准确的文档，也更加
满意了。和代码一样，Python的文档也要被管理来确保其稳定性。我
们努力确保开发版本的文档总是产生适当的文件。为了避免用户偶
尔遇到的问题，总是有黄金发布版的文档提供给用户使用。这个文
件版本总是检查过的并在已知的良好状态。
发布测试
1945
---
## Page 1947
最后，总有些错误没能被自动测试套件检测到。为了发现这些错
误，在发布Python的主要版本之前，我们会发布一系列的Alpha版
本、Beta版本和正式发布的候选版本。[L4]根据经验，你会发现在每
个用户数量级的增长中，相同数量的错误被发现。Alpha版本发布之
前，很少人（除了核心开发人员）使用该版本的Python。随着Alpha
测试版发布，喜欢冒险的用户试用，报告错误。更多的人会使用
Beta试用版，之后许多人尝试正式发布的候选版本。
在没有疏远那些想要一个更稳定产品人群的情况下，每一个发布阶
段都能发现许多问题，表9-1列出了下载数量
(http://www.python.org/webstats/)。
表9-1：Python下载数字
版本
发布日期
下载数
2.6a1
01-Mar-2008
19377
2.6a2
03-Apr-2008
19746
2.6a3
08-May-2008
37466
2.6b1
18-Jun-2008
26 434
2.6b2
17-Jul-2008
56137
2.6b3
20-Aug-2008
25916
2.6rc1
12-Sep-2008
28831
2.6rc2
17-Sep-2008
26312
2.6 release
01-Oct-2008
2722887
2.6.1release
04-Dec-2008
2869104
2.6.2release
15-Apr-2009
51194
bug修复版本（例如，2.6.1和2.6.2）在没有加入新功能的情况下，也
经过了严格的测试。在微型版本的发布中，只允许bug修复。[L5]
动态分析
1946
---
## Page 1948
Valgrind是一个动态的分析[6]工具。这意味着它能在应用程序运行
同时分析程序。memcheck工具，即Valgrind的一部分，能检测内存泄
漏和错误，包括无效的内存读取和写入。动态分析工具的能力是非
常强大的，因为它可以探测到很难发现的问题。例如，某个内存访
问在100万次中只发生一次，并不总是导致明显的问题。这样的问题
用Valgrind可以不费力就能捕捉到。
Python使用动态分析工具的历史已超过10年，旨在减少内存泄露数
量。内存泄漏对应用程序是非常不利的，因为它们可以有效地制造
一个拒绝服务（DoS）的问题。虽然Python不能完全防正这样的危
害，它肯定可以争取不泄漏自己结构的内存。如果内存泄漏频繁出
现在一个长时间运行的服务器上，即使是很小的泄漏也可以成为灾
难性的。
在任何情况下，Python解释器不应该崩溃，要想提供了一个稳定的运
行时，避免安全隐患，防止非法内存操作是重要步骤。
第一次运行动态分析工具时，它报告了许多错误。随着时间的推
移，我们修复所有这些问题。在每次发布前，我们在动态分析工具
环境里运行标准Python测试套件，通常有少量新的错误会出现，这和
Python的开发方式有关。一般来说，新加的功能，在运用动态分析工