points ﬂow into one shellcode copy. Under this situation, there are
no obvious anomalies in statistics compared to benign heap blocks,
and it is very hard for methods like NOZZLE to detect this kind of
attack without a high false positive rate.
As a consequence, to detect Heap Taichi under 64k memory
alignment is as hard as to detect four shellcode copies in a 1M-
byte heap object in real time. This could be a real challenge, and
there is no practical solution which achieve both low false negative
and low false positive so far.
6. RELATED WORK
6.1 Heap spraying with ASLR and DEP
The Address Space Layout Randomization(ASLR) technique [22,
33,40,44] is widely used in recent Windows versions such as Win-
dows Vista and Windows 7. Analyses [40, 44] show that the ran-
domization of heap area is quite weak. For each heap memory
block, the system creates a ﬁve bit random number (between 0 and
31) and multiplies it with 64K, and then adds the product to the ini-
tial allocation base. This technique affects heap-spraying attacks,
because it creates unpredictable gaps between the memory blocks.
But attackers can deal with it by allocating a huge memory block
and structure it carefully, so that the risk of landing in the gaps
would be signiﬁcantly reduced.
The ASLR-based defense is not effective on the new attack dis-
cussed in this paper. Because of the Windows memory allocation
granularity, heap blocks are still aligned to 64K boundaries even
after randomization. That means, the relative landing positions
in each heap object is unchanged. As long as attackers can spray
enough memory area using the heap region, the attack can still have
a high success rate.
Data Execution Prevention (DEP) [1] is complementary to ASLR.
It is an effective scheme to prevent an application or service from
executing code from a non-executable memory region. Since shell-
code is injected into non-executable memory region, most code in-
jection attacks cannot work anymore when both DEP and ASLR are
turned on. However, the attack techniques that can bypass DEP and
ASLR are continually proposed. For example, Nenad Stojanovski
et al. [41] showed that initial implementation of the software for
DEP in Windows XP is actually not at all secure, and many at-
tacks (such as return-to-libc like attack) can bypass DEP protec-
tion. Furthermore, Alexander Sotirov and Mark Dowd [39] imple-
mented several exploitation techniques to bypass the protections
and reliably execute remote code on Windows Vista. Dion Blaza-
kis [15] illustrated two novel techniques (i.e., pointer inference and
JIT spraying) to Windows Vista with IE8. Recently, during the
PWN2OWN hacking contest 2010 [10], both IE 8 and Firefox 3
web browsers running on the Windows 7 system (both DEP and
ASLR enabled) were successfully compromised. We believe that
the attacks against DEP and ASLR cannot be completely avoided
due to the vulnerabilities in operating systems or security-critical
applications.
6.2 Heap-spraying attack and detection
Our approach is closely related to existing work on heap be-
havior manipulation, heap-spraying detection, as well as x86 ex-
ecutable code detection.
Heap behavior manipulation. A successful heap-spraying
attack requires attackers to be able to predict the heap organiza-
tion and, more importantly, locations of allocated heap objects.
Sotirov [38] introduced a technique to use JavaScript to manipu-
late browser heap’s layout, and implemented this technique into
a JavaScript library for setting up heap state before triggering a
vulnerability. Daniel et al. [19] developed a technique to reliably
position a function pointer after a heap buffer that is vulnerable to
buffer overﬂow. In this paper, we leverage a weakness on Windows
heap allocation due to the large memory allocation granularity en-
forced on Windows systems, which makes heap allocation more
predictable for attackers.
Executable code detection. Recent researches such as [28,
37] have proved that detecting arbitrary shellcode by static code
features is difﬁcult and even infeasible. In the context of network
packets, several solutions [11,30,42] can detect executable code in
the payload, but they cause high false positives in the context of
heap objects [32], which makes them unsuitable for heap-spraying
detection. In section 2.2, we have discussed several detection meth-
ods in detail.
6.3 Memory exploit detection and prevention
Note that heap spraying itself cannot directly cause the malicious
payload to be executed. A successful attack needs another vulner-
ability to trigger the change of control ﬂow to the sprayed heap.
Detecting and preventing such vulnerabilities can stop heap spray-
ing.
Buffer overﬂow is the common vulnerability exploited to redirect
victim process’s control ﬂow. Traditional buffer overﬂow attacks
target the pointer variables on stack or heap. A large number of
solutions [45] have been proposed to address this problem. Among
these efforts, address space layout randomization (ASLR) [2, 13,
14] provides general protection against memory exploits by ran-
domizing the location of memory objects. It is now widely adopted
in major operating systems. Note that address space layout ran-
domization makes the location of memory objects, including heap
objects, unpredictable, thus forcing heap-spraying attacks to in-
ject a huge amount of heap objects containing code to increase the
chance of success. This forms the basis for existing heap-spraying
detection solutions.
Another common vulnerability exploited in browsers is integer
overﬂow. Many integer overﬂow vulnerabilities are disclosed in
recent years, and some integer overﬂow detection and prevention
methods are proposed [16,43]. Integer overﬂow leads to heap over-
ﬂow in many cases, and heap spraying could construct step stones
when exploiting these vulnerabilities.
In practice, it is very hard to eliminate all such vulnerabilities.
Also, the runtime overhead prevents many of these approaches from
being deployed widely. Therefore, the solution from this paper
complements the approaches in memory exploit prevention.
7. CONCLUSION
Heap-spraying code injection attacks are commonly used in web-
sites with exploits and drive-by downloads. This technique pro-
vides the attacker an easy-to-use code injection method which can
be implemented in many type-safe languages. Since traditional
heap spraying attacks require large number of NOP sled to increase
the possibility of successful attacks, existing detection solutions
mainly check for large amount of executable instructions on the
heap.
By analyzing the operating systems’ memory allocation mech-
anism, we found that the large amount of NOP sled is not neces-
sary for heap spraying attacks if the memory alignment size is large
enough. We introduced a new technique to launch heap-spraying
attack, which only injects a little amount of executable instruction,
making it undetectable by existing approaches. We discussed the
four basic types of attack modes and provide insight into the re-
lationship between memory alignment size and heap spraying at-
tack surface areas. We veriﬁed the technique by a proof-of-concept
implementation. Even when the alignment size is 32 bytes, our
attack can evade existing detection techniques. As a solution, we
propose to enforce ﬁner memory allocation granularity at memory
managers of all levels, trading a limited amount performance for
better security.
Acknowledgments The authors would like to thank the anony-
mous reviewers for their valuable comments. This work was sup-
ported in part by National Natural Science Foundation of China
under the grant No. 61003216, National Development and Reform
Commission under the project "A monitoring platform for web safe
browsing", and Singapore Ministry of Education under the NUS
grant R-252-000-367-133.
8. REFERENCES
[1] Microsoft Corporation. Data execution prevention. http:
//technet.microsoft.com/enus/library/cc738483.aspx.
[2] The PaX team. http://pax.grsecurity.net.
[3] Why is address space allocation granularity 64k? http://blogs.msdn.
com/oldnewthing/archive/2003/10/08/55239.aspx.
[4] Microsoft Internet Explorer .ANI ﬁle “anjh” header BoF exploit, 2004.
http://skypher.com/wiki/index.php?title=www.edup.
tudelft.nl/~bjwever/details_msie_ani.html.php.
[5] Microsoft Internet Explorer DHTML object handling valuerabilities
(MS05-20), 2004.
http://skypher.com/wiki/index.php?title=www.edup.
tudelft.nl/~bjwever/advisory_msie_R6025.html.php.
[6] Microsoft Internet Explorer IFRAME src&name parameter BoF remote
compromise, 2004.
http://skypher.com/wiki/index.php?title=www.edup.
tudelft.nl/~bjwever/advisory_iframe.html.php.
[7] Microsoft Internet Explorer javaprxy.dll COM object vulnerability, 2005.
http://www.frsirt.com/english/advisories/2005/0935.
[8] Microsoft Internet Explorer “msdds.dll” remote code execution, 2005.
http://www.frsirt.com/english/advisories/2005/1450.
[9] libemu - shellcode detection, 2007. http://libemu.carnivore.it.
[10] Pwn2own 2010, 2010. http://dvlabs.tippingpoint.com/blog/
2010/02/15/pwn2own-2010.
[11] P. Akritidis, E. P. Markatos, M. Polychronakis, and K. Anagnostakis. STRIDE:
Polymorphic sled detection through instruction sequence analysis. In Security
and Privacy in the Age of Ubiquitous Computing, 2005.
[12] C. Anley, J. Heasman, F. Lindner, and G. Richarte. The Shellcoder’s Handbook:
Discovering and Exploiting Security Holes. Wiley, 2004.
[13] S. Bhatkar, D. C. DuVarney, and R. Sekar. Address obfuscation: An efﬁcient
approach to combat a broad range of memory error exploits. In Proceeding of
12th USENIX Security Symposium, 2003.
[14] S. Bhatkar, R. Sekar, and D. C. DuVarney. Efﬁcient techniques for
comprehensive protection from memory error exploits. In Proceedings of 14th
USENIX Security Symposium, 2005.
[15] D. Blazakis. Interpreter exploitation: Pointer inference and jit spraying. In
Blackhat, USA, 2010.
[16] D. Brumley, T. Chiueh, R. Johnson, H. Lin, and D. Song. RICH: Automatically
protecting against integer-based vulnerabilities. In Proceedings of the 14th
Annual Network and Distributed System Security Symposium (NDSS), 2007.
[17] C. Collberg, C. Thomborson, and D. Low. Manufacturing cheap, resilient, and
stealthy opaque constructs. In POPL ’98: Proceedings of the 25th ACM
SIGPLAN-SIGACT symposium on Principles of programming languages, 1998.
[18] CVE, 2007. http://www.cve.mitre.org/cgi-bin/cvename.
cgi?name=CVE-2007-0038.
[19] M. Daniel, J. Honoroff, and C. Miller. Engineering heap overﬂow exploits with
JavaScript. In Proceedings of the 2nd USENIX Workshop on Offensive
Technologies, 2008.
[20] T. Detristan, T. Ulenspiegel, and Yann_malcom. Polymorphic shellcode engine
using spectrum analysis. Phrack 11,57-15 (2001).
[21] M. Egele, P. Wurzinger, C. Kruegel, and E. Kirda. Defending browser against
drive-by downloads: Mitigating heap-srpaying code injection attacks. In
Proceedings of the 6th Conference on Detection of Intrusions and Malware &
Vulnerability Assessment (DIMVA), 2009.
[22] M. E.Russinovich and D. A.solomon. Microsoft Wndows Internals, Fourth
Edition: Microsoft Windows Server 2003, Windows Xp, and Windows 2000.
Microsoft Press, 2008.
[23] J. Evans. A scalable concurrent malloc(3) implementation for freebsd. In
BSDCan conference, 2006.
[24] P. Fogla and W. Lee. Evading network anomaly detection systems: formal
reasoning and practical techniques. In CCS ’06: Proceedings of the 13th ACM
conference on Computer and communications security, 2006.
[25] D. R. Hanson. Fast allocation and deallocation of memory based on object
lifetimes. Softw. Pract. Exper., 20(1):5–12, 1990.
[26] C. Kil, J. Jun, C. Bookholt, J. Xu, and P. Ning. Address space layout
permutation (aslp): Towards ﬁne-grained randomization of commodity
software. In ACSAC’06: Proceedings of the 22th Annual Computer Security
Applications Conference, 2006.
[27] C. Linn and S. Debray. Obfuscation of executable code to improve resistance to
static disassembly. In CCS ’03: Proceedings of the 10th ACM conference on
Computer and communications security, 2003.
[28] J. Mason, S. Small, F. Monrose, and G. MacManus. English shellcode. In CCS
’09: Proceedings of the 16th ACM conference on Computer and
communications security, 2009.
[29] M. Polychronakis, K. Anagnostakis, and E. Markatos. Emulation-based
detection of non-self-contained polymorphic shellcode. In Proceedings of the
10th International Symposium on Recent Advances in Intrusion Detection
(RAID), 2007.
[30] M. Polychronakis, K. G. Anagnostakis, and E. P. Markatos. Network-level
polymorphic shellcode detection using emulation. In Proceedings of the 3rd
Conference on Detection of Intrusions and Malware & Vulnerability
Assessment (DIMVA), 2006.
[31] I. V. Popov, S. K. Debray, and G. R. Andrews. Binary obfuscation using signals.
In SS’07: Proceedings of 16th USENIX Security Symposium on USENIX
Security Symposium, Berkeley, CA, USA, 2007.
[32] P. Ratanaworabhan, B. Livshits, and B. Zorn. NOZZLE: A defense against
heap-spraying code injection attacks. In Proceedings of the 18th USENIX
Security Symposium, 2009.
[33] J. Richter and C. Nasarre. Windows via C/C++ 5th edition. Microsoft Press,
2008.
[34] RIX. Writing ia32 alphanumeric shellcodes. Phrack 11,57-15 (2001).
[35] P. M. Sanjay Ghemawat, 2005. http:
//goog-perftools.sourceforge.net/doc/tcmalloc.html.
[36] SecurityFocus. Mozilla Firefox 3.5 ‘TraceMonkey’ component remote code
execution vulnerability, 2009.
http://www.securityfocus.com/bid/35660.
[37] Y. Song, M. E. Locasto, A. Stavrou, A. D. Keromytis, and S. J. Stolfo. On the
infeasibility of modeling polymorphic shellcode. In CCS ’07: Proceedings of
the 14th ACM conference on Computer and communications security. ACM,
2007.
[38] A. Sotirov. Heap feng shui in JavaScript. In Blackhat, USA, 2007.
[39] A. Sotirov. Bypassing browser memory protections in windows vista. In
Blackhat, USA, 2008.
[40] A. Sotirov and M. Dowd. Bypassing browser memory protections. In BlackHat,
USA, 2008.
[41] N. Stojanovski, M. Gusev, D. Gligoroski, and Svein.J.Knapskog. Bypassing
data execution prevention on microsoftwindows xp sp2. In The Second
International Conference on Availability, Reliability and Security (ARES), 2007.
[42] T. Toth and C. Kruegel. Accurate buffer overﬂow detection via abstract payload
execution. In Proceedings of the 5th International Symposium on Recent
Advances in Intrusion Detection (RAID), 2002.
[43] T. Wang, T. Wei, Z. Lin, and W. Zou. IntScope: Automatically detecting integer
overﬂow vulnerability in x86 binary using symbolic execution. In Proceedings
of the 16th Annual Network and Distributed System Security Symposium
(NDSS), 2009.
[44] O. Whitehouse. An analysis of address space layout randomization on windows
vista™. In Symantec Advanced Threat Research, 2007.
[45] Y. Younan, W. Joosen, and F. Piessens. Code injection in C and C++ : A survey
of vulnerabilities and countermeasures. Technical Report CW386, Department
of Computer Science, Katholieke Universiteit Leuven, 2004.
[46] A. Young and M. Yung. Cryptovirology: Extortion-based security threats and
countermeasures. In SP ’96: Proceedings of the 1996 IEEE Symposium on
Security and Privacy, page 129, Washington, DC, USA, 1996. IEEE Computer
Society.
[47] J. Zhuge, T. Holz, C. Song, J. Guo, X. Han, and W. Zou. Studying malicious
websites and the underground economy on the chinese web. In Proceedings of
the 7th Workshop on the Economics of Information Security (WEIS’08), 2008.