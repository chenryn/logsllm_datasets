We have presented a lightweight static analysis tool for 
detecting  buffer  overflow  vulnerabilities.    It  is  neither 
sound  nor  complete;  hence,  it  misses  some  vulnera-
bilities and produces some spurious warnings.  Despite 
this, our experience so far indicates that it is useful.  We 
were able to find both known and previously unknown 
buffer  overflow  vulnerabilities  in  wu-ftpd  and  BIND 
with a reasonable amount of effort using our approach.  
Further,  the  process  of  adding  annotations  is  a  con-
structive and useful step for understanding of a program 
and improving its maintainability. 
We  believe  it  is  realistic  (albeit  perhaps  optimistic)  to 
believe  programmers  would  be  willing  to  add  annota-
tions  to  their  programs  if  they  are  used  to  efficiently 
and clearly detect likely buffer overflow vulnerabilities 
(and other bugs) in their programs.  An informal sam-
pling  of  tens  of  thousands  of  emails  received  from 
LCLint users indicates that about one quarter of LCLint 
users  add  the  annotations  supported  by  previously 
released versions of LCLint to their programs.  Perhaps 
half of those use annotations in sophisticated ways (and 
occasionally  in  ways  the  authors  never  imagined).  
Although 
the  annotations  required  for  effectively 
detecting  buffer  overflow  vulnerabilities  are  somewhat 
more  complicated,  they  are  only  an  incremental  step 
beyond  previous  annotations.    In  most  cases,  and 
certainly for security-sensitive programs, the benefits of 
doing so should far outweigh the effort required. 
These  techniques,  and  static  checking  in  general,  will 
not provide the complete solution to the buffer overflow 
problem.    We  are  optimistic,  though,  that  this  work 
represents a step towards that goal. 
Availability 
LCLint  source  code  and  binaries  for  several  platforms 
are available from http://lclint.cs.virginia.edu. 
Acknowledgements 
We  would  like  to  thank  the  NASA  Langley  Research 
Center  for  supporting  this  work.    David  Evans  is  also 
supported by an NSF CAREER Award.  We thank John 
Knight,  John  McHugh,  Chenxi  Wang,  Joel  Winstead 
and  the  anonymous  reviewers  for  their  helpful  and 
insightful comments. 
References 
[Aiken99] Alexander Aiken.  Introduction to Set 
Constraint-Based Program Analysis.  Science of 
Computer Programming, Volume 35, Numbers 2-
3.  November 1999. 
[AlephOne96] Aleph One.  Smashing the Stack for Fun 
and Profit.  BugTraq Archives.  
http://immunix.org/StackGuard/profit.html. 
[Andrews01] Mark Andrews. Personal communication, May 
2001. 
[BST00] Arash Baratloo, Navjot Singh and Timothy 
Tsai.  Transparent Run-Time Defense Against 
Stack-Smashing Attacks.  9th USENIX Security 
Symposium, August 2000.  
[Collins88] William J. Collins.  The Trouble with For-
Loop Invariants.  19 th SIGCSE Technical 
Symposium on Computer Science Education, 
February 1988.  
[Coolbaugh99] Liz Coolbaugh. Buffer Overflow 
Protection from Kernel Patches.  Linux Weekly 
News, http://lwn.net/1999/1230/security.php3. 
[Cousot77] Patrick Cousot and Radhia Cousot. Abstract 
Interpretation: A Unified Lattice Model for Static 
Analysis of Programs by Construction or 
Approximation of Fixpoints.  Fourth  ACM 
Symposium on Principles of Programming 
Languages, January 1977. 
[CPMH+98] Crispin Cowan, Calton Pu, David Maier, 
Heather Hinton, Peat Bakke, Steve Beattie, Aaron 
Grier, Perry Wagle and Qian Zhang.  Automatic 
Detection and Prevention of Buffer-Overflow 
Attacks.  7th USENIX Security Symposium, 
January 1998. 
[CBDP+99] Crispin Cowan, Steve Beattie, Ryan Finnin 
Day, Calton Pu, Perry Wagle and Erik 
Walthinsen.  Protecting Systems from Stack 
Smashing Attacks with StackGuard.  Linux Expo.  
May 1999.  (Updated statistics at 
http://immunix.org/StackGuard/performance.html) 
[CWPBW00] Crispin Cowan, Perry Wagle, Calton Pu, 
Steve Beattie and Jonathan Walpole.  Buffer 
Overflows: Attacks and Defenses for the 
Vulnerability of the Decade.  DARPA Information 
Survivability Conference and Exposition.  January 
2000. 
[DLNS98] David Detlefs, K. Rustan M. Leino, Greg 
Nelson and James B. Saxe.  Extended Static 
Checking.  Research Report, Compaq Systems 
Research Center.  December 18, 1998. 
[DRS01] Nurit Dor, Michael Rodeh and Mooly Sagiv.  
Cleanness Checking of String Manipulations in C 
Programs via Integer Analysis.  8th International 
Static Analysis Symposium.  To appear, July 
2001. 
[ES99] Úlfar Erlingsson and Fred B. Schneider. SASI 
Enforcement of Security Policies: A Retrospective. 
New Security Paradigms Workshop.  September 
1999. 
[ES00] Ulfar Erlingsson and Fred B. Schneider.  IRM 
Enforcement of Java Stack Inspection.  IEEE 
Symposium on Security and Privacy.  May 2000. 
[ECGN99] Michael D. Ernst, Jake Cockrell, William G. 
Griswold and David Notkin.   Dynamically 
Discovering Likely Program Invariants to Support 
Program Evolution.  International Conference on 
Software Engineering.  May 1999. 
[EGHT94] David Evans, John Guttag, Jim Horning and 
Yang Meng Tan. LCLint: A Tool for Using 
Specifications to Check Code. SIGSOFT 
Symposium on the Foundations of Software 
Engineering.  December 1994. 
[McHugh84] John McHugh.  Towards the Generation 
of Efficent Code form Verified Programs.  
Technical Report 40, Institute for Computing 
Science, University of Texas at Austin PhD 
Thesis, 1984. 
[Evans96] David Evans.  Static Detection of Dynamic 
Memory Errors.  SIGPLAN Conference on 
Programming Language Design and 
Implementation.  May 1996. 
[Necula97] George C. Necula.  Proof-Carrying Code.  
24th ACM SIGPLAN-SIGACT Symposium on 
Principles of Programming Langauges, January 
1997. 
[ET99] David Evans and Andrew Twyman.  Flexible 
Policy-Directed Code Safety.  IEEE Symposium on 
Security and Privacy.  May 1999. 
[Evans00a] David Evans.  Policy-Directed Code Safety.  
MIT PhD Thesis.  February 2000. 
[Evans00b] David Evans.  Annotation-Assisted 
Lightweight Static Checking.  First International 
Workshop on Automated Program Analysis, 
Testing and Verification.  June 2000. 
[Evans00c] David Evans.  LCLint User’s Guide, 
Version 2.5.  May 2000. 
http://lclint.cs.virginia.edu/guide/ 
[FBF99] Timothy Fraser, Lee Badger and Mark 
Feldman.  Hardening COTS Software with Generic 
Software Wrappers. IEEE Symposium on Security 
and Privacy.  May 1999.  
[GWTB96] Ian Goldberg, David Wagner, Randi 
Thomas and Eric A. Brewer.  A Secure 
Environment for Untrusted Helper Applications: 
Confining the Wily Hacker.  6th USENIX Security 
Symposium. July 1996. 
[GH93] John V. Guttag and James J. Horning, editors, 
with Stephen J. Garland, Kevin D. Jones, Andrés 
Modet and Jennette M. Wing.  Larch: Languages 
and Tools for Formal Specification.  Springer-
Verlag.  1993. 
[IS97] A. Ireland and J. Stark.  On the Automatic 
Discovery of Loop Invariants. 4th NASA Langley 
Formal Methods Workshop.  September 1997.  
[ISO99] ISO/IEC 9899 International Standard.  
Programming Languages – C.  December 1999.  
Approved by ANSI May 2000.  
[LHSS00] David Larochelle, Yanlin Huang, Avneesh 
Saxena and Seejo Sebastine.  Static Detection of 
Buffer Overflows in C using LCLint.  Unpublished 
report available from the authors.  May 2000. 
[Luckin01] Bob Luckin.  Personal communication, 
April 2001. 
[Lundberg01] Gregory A Lundberg.  Personal 
communication, April 2001. 
[NL96] George C. Necula and Peter Lee. Safe Kernel 
Extensions Without Run-Time Checking. 2nd 
Symposium on Operating Systems Design and 
Implementation, October 1996. 
[Orcero00] David Santo Orcero.  The Code Analyzer 
LCLint.  Linux Journal.  May 2000. 
[Pethia00] Richard D. Pethia.  Bugs in Programs.  
Keynote address at SIGSOFT Foundations of 
Software Engineering.  November 2000.  
[PG00] Pramode C E and Gopakumar C E.  Static 
Checking of C programs with LCLint. Linux 
Gazette Issue 51.  March 2000. 
[RE89] Jon Rochlis and Mark Eichin.  With Microscope 
and Tweezers: the Worm from MIT’s Perspective.  
Communications of the ACM.  June 1989. 
[Snow99] Brian Snow.  Future of Security.  Panel 
presentation at IEEE Security and Privacy.  May 
1999. 
[Spafford88] Eugene Spafford.  The Internet Worm 
Program: An Analysis.  Purdue Tech Report 832.  
1988. 
[SI98] J. Stark and A. Ireland. Invariant Discovery Via 
Failed Proof Attempts. 8th International 
Workshop on Logic Based Program Synthesis and 
Transformation.  June 1998. 
[Torvalds98] Linus Torvalds.  Message archived in 
Linux Weekly News. August 1998.  
http://lwn.net/980806/a/linus-noexec.html 
[VBKM00] John Viega, J.T. Bloch, Tadayoshi Kohno 
and Gary McGraw. ITS4 : A Static Vulnerability 
Scanner for C and C++ Code. Annual Computer 
Security Applications Conference. December 
2000. 
[WFBA00] David Wagner, Jeffrey S. Foster, Eric A. 
Brewer and Alexander Aiken.  A First Step 
Towards Automated Detection of Buffer Overrun 
Vulnerabilities.  Network and Distributed System 
Security Symposium.  February 2000.  
[Wagner00] David Wagner.  Static Analysis and 
Computer Security: New Techniques for Software 
not  guarantee  that  a  null  character  is  added; 
strncat appends  n characters to the buffer and a 
null  character.    The  ensures  clauses  reveal  these 
differences clearly.   
The full specifications for malloc and calloc also 
include null annotations on the result that indicate 
that  they  may  return  NULL.    Existing  LCLint 
checking  detects  dereferencing  a  potentially  null 
pointer. 
implicit  actual 
postcondition for malloc is maxSet(result) == size ∨ 
result  ==  null.    LCLint  does  not  support  general 
disjunctions,  but  possibly  NULL  values  can  be 
handled straightforwardly. 
  As  a 
result, 
the 
Assurance.  University of California, Berkeley, 
PhD Thesis, 2000. 
[WLAG93] Robert Wahbe, Steven Lucco, Thomas E. 
Anderson and Susan L. Graham.  Efficient 
Software-Based Fault Isolation.  14th ACM 
Symposium on Operating Systems Principles, 
1993.  
[Wegbreit75] Ben Wegbreit. Property Extraction in 
Well-Founded Property Sets. IEEE Transactions 
on Software Engineering, September 1975. 
[WSJ01] The Wall Street Journal. Researchers Find 
Software Flaw Giving Hackers Key to Web Sites.  
January 30, 2001. 
A.  Annotated Selected C Library Functions 
char *strcpy (char *s1, char *s2)
/*@requires maxSet(s1) >= maxRead(s2)@*/
/*@ensures maxRead(s1) == maxRead (s2)
/\ result == s1@*/;
char *strncpy (char *s1, char *s2,
size_t n)
/*@requires maxSet(s1) >= n – 1@*/
/*@ensures maxRead (s1) = (maxRead(s1)
+ maxRead(s2))@*/
/*@ensures
maxRead(s1) == maxRead(s1)
+ maxRead(s2)
/\ result == s1@*/;
strncat (char *s1, char *s2, int n)
/*@requires maxSet(s1)
>= maxRead(s1) + n@*/
/*@ensures maxRead(result)
>= maxRead(s1) + n@*/;
extern size_t strlen (char *s)
/*@ensures result == maxRead(s)@*/;
void *calloc (size_t nobj, size_t size)
/*@ensures maxSet(result) == nobj@*/;
void *malloc (size_t size)
/*@ensures maxSet(result) == size@*/;
These annotations were determined based on ISO 
C  standard  [ISO99].    Note  that  the  semantics  of 
strncpy  and  strncat  are  different  –  strncpy 
writes exactly  n characters to the buffer but does