### DataStore Lookup

**Figure 7: Loading Time for the Like Button with and without SafeButton**
Even when the total number of "likes" is not available in the X-Cache, SafeButton loads 2.8 times faster. The requests take a similar amount of time from placement to the first response byte, but they differ by two orders of magnitude in terms of the total transfer time. Even if Facebook optimizes its own plugins in the future, we expect SafeButton's rendering speed to be comparable in case of an X-Cache miss and significantly faster in case of an X-Cache hit.

### 5.4 Effectiveness

As described in Section 3, we use a set of heuristics to match the target URL of each supported social plugin, intercepting and processing them to protect user privacy. To evaluate the effectiveness and accuracy of our approach, we conducted the following experiment: Using `tcpdump`, we captured a network trace of all outgoing communication from a test PC in our lab while browsing the web for a week through Firefox equipped with SafeButton. Inspection of the trace revealed that no cookies were transmitted in any HTTP communication with `facebook.com` or its subdomains.

This result was achieved through a "fail-safe" approach. In addition to recognizing the signatures of supported social plugins, SafeButton inspects all communication with `facebook.com` and strips any cookies from requests initiated by third-party pages. We then performed the reverse experiment: using the same browser with SafeButton, we browsed `www.facebook.com` and interacted with the site’s functionality without any issues. Careful inspection of the log generated by SafeButton confirmed that no in-Facebook communication was hindered at any time.

**Figure 8: Privacy-Preserving Social Plugins Serviced by a SNS**
Here, the loading of a social plugin on a third-party page. The code of the social plugin agent is always fetched from a secondary domain to avoid leaking cookies set by the primary domain of the SNS. The URL of the target page is passed via a fragment identifier, ensuring it is never transmitted to the SNS. The agent synthesizes and renders the personalized content of the social plugin.

### 6. Privacy-Preserving Social Plugins as a Service: A Pure JavaScript Design

Many users are unaware of the privacy issues associated with social plugins and are unlikely to install browser extensions for protection. For example, NoScript [27], a Firefox add-on that blocks untrusted JavaScript code, has only about 2 million downloads, and AdBlock [1], which prevents advertisement domains from loading, has been downloaded 14 million times. Given that Firefox has 450 million active users [24], the adoption rates of these security add-ons are 0.4% and 3.1%, respectively. Therefore, we present a pure JavaScript implementation of privacy-preserving social plugins that can be employed by social networking services themselves to protect their members.

The use case remains similar: web developers embed an IFRAME element to load the social plugin from the SNS. However, instead of serving a traditional social plugin, the SNS serves a JavaScript implementation of a social plugin agent, as described in Section 3. The agent fetches personalized information from the browser’s local storage, requests non-personalized information from the SNS, and renders the synthesized content according to the specified social plugin. This design is feasible with existing web technologies like IndexedDB [19], which provides a JavaScript API for managing a local database, similar to the DataStore used in SafeButton.

**Figure 9: Securely Communicating the User’s Session Identifier to the Social Plugin Agent**
When logging in on the SNS, the login page contains a hidden IFRAME loaded through HTTPS from the secondary domain hosting the social plugin agent. The login page communicates the session identifier to the agent’s IFRAME using the `postMessage` function. The IFRAME stores the identifier locally, allowing the agent to place authenticated requests for accessing the user’s profile information.

The most challenging aspect of this implementation is preventing the leakage of user-identifying information during the loading of a social plugin. If the IFRAME of the social plugin agent is hosted on the same (sub)domain as the SNS, the request for fetching its JavaScript code would also transmit the user’s cookies for the SNS. To address this, the URL of the embedding page should not be passed as a parameter to the initial request. Instead, it can be passed through a fragment identifier, which is never transmitted to the server. For example, instead of `www.socialnetwork.com/sp-agent.js?url=`, the URL can be `www.socialnetwork.com/sp-agent.js#`.

However, the URL of the embedding page is usually transmitted in the HTTP Referer header. To overcome this, the social plugin agent can be hosted on a secondary domain, such as `socialnetwork-cdn.net`, different from the primary domain of the SNS. This prevents the browser from appending the user’s cookies, as the IFRAME will be served from a different domain than the one for which the cookies were set.

To issue authenticated requests, the social plugin agent must have access to the user’s session identifier. This can be achieved using the `postMessage` JavaScript API. When the user logs in, the login page communicates the session identifier to the agent’s IFRAME, which stores it locally. The agent can then read the session identifier and place authenticated requests towards the SNS for accessing the user’s profile and synchronizing the required information.

For multiple users per browser instance and protecting locally stored personal information, encryption can be used to shield sensitive data. The SNS can communicate a user-specific cryptographic key to the social plugin agent, which can then encrypt sensitive information locally. The key is kept only in memory, and each time the plugin agent loads, it spawns a child IFRAME to the social networking site, which can communicate the encryption key back to the agent.

### 7. Discussion

**Strict Mode of Operation**
Although SafeButton does not send any cookies to the SNS, it still needs to make non-authenticated requests to fetch public information for some social plugins. These requests expose the user’s IP address to the SNS. Some users may be uncomfortable with this, as the SNS could correlate the IP address with other information to identify the user. For such privacy-conscious users, we consider a "paranoid" mode where SafeButton does not retrieve any public information, rendering some social plugins with only locally available personalized information. Alternatively, SafeButton can use an anonymous communication network like Tor [38] to carry out these queries, minimizing the impact on the browsing experience.

**Potential Challenges with Future Social Plugins**
While SafeButton currently supports all Facebook social plugins and is extensible to handle other SNS plugins, two potential challenges exist. First, future personalization might include social information from second-degree friends or rely on the analysis of data from the entire user population. Second, such personalization could involve proprietary algorithms not available to the client-side at runtime. We believe our approach can adapt to these developments, as the extended analysis can be done offline, and the results can be stored and used in real-time during content personalization.

**Profile Management**
Users may require a practical way to use SafeButton across multiple devices. While installing SafeButton on each browser is sufficient, this results in separate synchronization of locally stored information with the SNS. In future work, we will consider using cloud storage for fully-encrypted copies of the local DataStore and X-Cache, synchronized across all the user’s browser instances, similar to existing settings and bookmark synchronization features of popular browsers [29, 14].

**Security in Multi-user Environments**
In a multi-user environment where multiple users share the same browser instance, sharing the same browser is generally a bad security practice. SafeButton retrieves private information when users are logged into the SNS and stores it locally even after they log out. Multiple users are supported by monitoring the current cookies for the SNS domain and serving personalized content only for the currently logged-in user. Local entries belonging to a user ID that does not match the one currently logged in are never returned. Users sharing the same OS account can access each other’s locally stored data unless they opt for encrypted data.

**Shortcomings of the Graph API**
Throughout this paper, we have mentioned some obstacles related to the Facebook API, particularly in protecting user privacy while maintaining full functionality for social plugins. Here, we summarize these issues:

- **User Activity Updates through the API:** The Facebook API [10] offers access to the social graph but does not provide updates or "diffs" when changes occur. For example, while we can retrieve a friend’s "likes," we cannot receive notice when a friend "unlikes." A "friend activity" or "history" function would aid in keeping an accurate local store.
- **Accuracy of Provided Information:** Sometimes, the API calls and documentation differ slightly from the actual behavior of a plugin, creating a challenge for developers.
- **Support for All Social Information:** It is reasonable for the API to provide access to information accessible via social plugins or user profile pages. For instance, there is no API call to access the comments of a specific user, although they appear on the user’s profile page. Scraping is not ideal, so we resort to practices that reduce accuracy, such as anonymously retrieving a sample of comments and placing the comments of a user’s friends at the top if present in the sample.

### 8. Related Work

**Do Not Track [5]**
Do Not Track is a browser technology that enables users to signal, via an HTTP header, that they do not wish to be tracked by websites they do not explicitly visit. However, there are no guarantees that the receiving site will honor this request.

**Krishnamurthy et al. [46]**
Krishnamurthy et al. studied privacy leaks in online social networking services, identifying the presence of embedded content from third-party domains in user interactions with the SNS.