DataStore lookup
Figure 7: Loading time for Like button with and without
SafeButton. Even when the total number of “likes” is not
available in the X-Cache, SafeButton is 2.8 times faster.
requests need a similar amount of time from the moment
they are placed until the ﬁrst response byte is received
from the server, they differ by two orders of magnitude in
terms of the time required to complete the transfer. Even
if Facebook optimizes its own plugins in the future, we
expect the rendering speed of SafeButton to be compara-
ble in case of an X-Cache miss, and still much faster in
case of an X-Cache hit.
5.4 Effectiveness
As presented in Sec. 3, we rely on a set of heuristics
that match the target URL of each supported social plu-
gin to intercept and treat them accordingly so as to pro-
tect the user’s privacy. To evaluate the effectiveness and
accuracy of our approach, we carried out the follow-
ing experiment. Using tcpdump, we captured a network
trace of all outgoing communication of a test PC in our
lab while surﬁng the web for a week through Firefox
equipped with SafeButton. We then inspected the trace
and found that no cookie was ever transmitted in any
HTTP communication with facebook.com or any of its
sub-domains.
This was a result of the following “fail-safe” ap-
proach. Besides the signatures of the supported so-
cial plugins, SafeButton inspects all communication with
facebook.com and strips any cookies from requests ini-
tiated by third-party pages. Next, we performed the
reverse experiment: using the same browser equipped
with SafeButton, we surfed www.facebook.com and inter-
acted with the site’s functionality without any issues for
a long period. Careful inspection of the log generated by
SafeButton proved that no in-Facebook communication
was hindered at any time.
Figure 8: Privacy-preserving social plugins serviced by
a SNS. Here: the loading of a social plugin in a third-
party page. The code of the social plugin agent is always
fetched from a secondary domain to avoid leaking cook-
ies set by the primary domain of the SNS. The URL of
the target page is passed via a fragment identiﬁer, so it is
never transmitted to the SNS. The agent synthesizes and
renders the personalized content of the social plugin.
6 Privacy-preserving Social Plugins as a
Service: A Pure JavaScript Design
As many users are typically not aware of the privacy
issues of social plugins, they are not likely to install
any browser extension for their protection. For instance,
NoScript [27], a Firefox add-on which blocks untrusted
JavaScript code from being executed, has roughly just 2
million downloads, and AdBlock [1], an add-on which
prevents advertisement domains from loading as third
parties in a web page, has been downloaded 14 million
times. At the same time, Firefox has 450 million active
users [24], which brings the adoption rate of the above
security add-ons to 0.4% and 3.1%, respectively. For
this reason, in this section we present a pure JavaScript
implementation of privacy-preserving social plugins that
could be employed by social networking services them-
selves for the protection of their members.
The use case would not be much different from now:
web developers would still embed an IFRAME element
that loads the social plugin from the SNS. However,
instead of serving a traditional social plugin, the SNS
serves a JavaScript implementation of a social plugin
agent in respect to the design presented in Sec. 3. The
agent then fetches personalized information from the
browser’s local storage, requests non-personalized infor-
mation from the SNS, and renders the synthesized con-
Figure 9: Privacy-preserving social plugins serviced by
a SNS. Here: securely communicating the user’s session
identiﬁer to the social plugin agent when logging in on
the SNS. Although the agent is hosted on a secondary
domain, it receives and stores the identiﬁer from the pri-
mary domain through the postMessage function, allow-
ing it to place asynchronous authenticated requests for
accessing the user’s proﬁle information.
tent according to the speciﬁed social plugin. The feasi-
bility of the above design is supported by existing web
technologies such as IndexedDB [19], which provide a
JavaScript API for managing a local database, similar to
the DataStore used in SafeButton.
The most challenging aspect of this implementa-
tion is to prevent the leakage of user-identifying in-
If
formation during the loading of a social plugin.
the IFRAME of the social plugin agent
is hosted
on the same (sub)domain as the SNS itself
(e.g.,
socialnetwork.com), then the request for fetching its
JavaScript code would also transmit the user’s cookies
for the SNS. At the same time, the agent would need to
know the URL of the embedding page for which it has
personalized the social plugin’s content. If the URL is
passed as a parameter to that initial request, the situation
is obviously as problematic as in current social plugins.
A solution would be to leave out the URL of the page
from the request for loading the social plugin agent.
However, there should be a way to communicate this in-
formation to the agent once its JavaScript code has been
loaded by the browser. This can be achieved through
a fragment identiﬁer [32] in the URL from which the
agent is loaded. Fragment identiﬁers come as the last
part of a URL, and begin with a hash mark (#) char-
acter. According to the HTTP speciﬁcation [18], frag-
ment identiﬁers are never transmitted as part of a re-
quest to a server. Thus, during the loading of a social
plugin in a third-party page, instead of passing an ex-
plicit parameter with the URL of the embedding page, as
in www.socialnetwork.com/sp-agent.js?url=, it
can be passed through a fragment identiﬁer, as in www.
socialnetwork.com/sp-agent.js#. The informa-
tion about the URL of the visited page never leaves the
browser, and remains accessible to the JavaScript code of
the agent, which can then parse the hypertext reference
of its container and extract the fragment identiﬁer.
Unfortunately, this approach is still not secure in prac-
tice. The URL of the embedding page is usually also
transmitted as part of the HTTP Referer [sic] header
by most browsers. Therefore, even if we omit the tar-
get URL from the HTTP parameters of the request, the
server will receive it anyway, allowing the SNS to cor-
relate this information with the user’s cookies that are
transmitted as part of the same request.
To overcome this issue, the social plugin agent can
be hosted on a secondary domain, different than the
primary domain of the SNS, as also proposed by Do
Not Track [5]. For instance, in this design the agent
could be hosted under socialnetwork-cdn.net instead
of socialnetwork.com, as shown in Fig. 8. This prevents
the browser from appending the user’s cookies whenever
a social plugin is encountered (step 2), since its IFRAME
will be served from a different domain than the one for
which the cookies were set. The rest of the steps are
analogous to Fig. 3.
Still, the social plugin agent must be able to issue au-
thenticated requests towards the SNS for accessing the
user’s proﬁle and retrieving the necessary private social
information that must be maintained locally. This re-
quires access to the user’s cookies, and speciﬁcally to
the identiﬁer of the authenticated session that the user
has with the SNS.
A solution to this problem can be achieved by taking
advantage of the windows.postMessage [22] JavaScript
API, which allows two different origins to communicate.
When the user logs in on the SNS, the login page con-
tains a hidden IFRAME loaded through HTTPS from
the secondary domain on which the social plugin agent
is hosted, as shown in Fig. 9 (step 2). The login page
then communicates to the agent’s IFRAME the session
identiﬁer of the user through postMessage (step 3). The
IFRAME executes JavaScript code that stores locally the
user identiﬁer under its own domain, making it acces-
sible to the plugin agent. The agent can then read the
session identiﬁer from its own local storage, and place
authenticated requests towards the SNS for accessing the
user’s proﬁle (step 4) and synchronizing the required in-
formation with the locally stored data. When the user ex-
plicitly logs out from the social networking site, the log
out page follows a similar process to erase the identiﬁer
from the local storage of the agent.
In respect to supporting multiple users per browser in-
stance and protecting the personal information stored lo-
cally, encryption can be employed to shield any sensi-
tive information, such as the names or identiﬁers of a
user’s friends.
In accordance with the communication
of the session identiﬁer described above, a user-speciﬁc
cryptographic key can be communicated from the SNS
to the social plugin agent. The plugin can then use this
key to encrypt sensitive information locally. The key
is kept only in memory. Each time the plugin agent
loads, it spawns a child IFRAME towards the social net-
working site. The request for the child IFRAME will
normally have the user’s cookies appended. Finally,
that child IFRAME, once loaded, can communicate via
postMessage the encryption key back to the plugin agent.
7 Discussion
Strict Mode of Operation Although SafeButton does
not send any cookies to the social networking service,
it still needs to make non-authenticated requests towards
the SNS to fetch public information for some social plu-
gins (e.g., for Facebook plugins, the information shown
in column “Public Content” in Table 1). These requests
unavoidably expose the user’s IP address to the SNS.
Some users might not feel comfortable with exposing
their IP address to the SNS (even when no cookies are
sent), as this information could be correlated by the SNS
with other sources of information, and could eventually
lead to the exposure of the users’ true identity. For such
privacy-savvy users, we consider a “paranoid” mode of
operation in which SafeButton does not reveal the user’s
IP address to the social networking service when en-
countering a social plugin in a third-party page, by sim-
ply not retrieving any public information about the page.
Unavoidably, some social plugins are then rendered us-
ing solely the locally available personalized information,
e.g., for the Like button, the total number of “likes” for
the page will be missing.
Alternatively, given the very low trafﬁc incurred by
SafeButton’s non-authenticated queries to the SNS, these
can be carried out transparently by SafeButton through
an anonymous communication network such as Tor [38].
Given that social plugins are loaded in parallel with the
rest of the page’s elements, this would minimally affect
the browsing experience (compared to browsing solely
through Tor).
Potential Challenges with Future Social Plugins. Al-
though SafeButton currently supports all social plugins
offered by Facebook, and our approach is extensible so
as to handle the plugins of other social networking ser-
vices, we consider two potential challenges with future
plugins [44]. First, future personalization functionality
could include social information from a user’s second de-
gree friends, i.e., the friends of his friends, or rely on the
analysis of data from the entire user population of the so-
cial network. Second, this type of personalization could
involve proprietary algorithms not available to the client-
side at run-time.
We believe that our approach could be adapted to sup-
port such developments. We ﬁnd it realistic that such
extended analysis will take place ofﬂine, and result in
the calculation of a product that will be stored and taken
into account in real-time during content personalization.
Therefore, it will not be necessary to have at the client
side neither the analysis algorithms nor the entire dataset.
The stored outcome of the analysis, e.g., some extra
weight on the social graph or additional meta-data, could
be available to through the developer’s API, and be taken
into account by SafeButton during content personaliza-
tion. At the same time, the social networking service is
not deprived of the data necessary to carry out such anal-
ysis. Our approach protects user privacy when accessing
the “view” functionality of social plugins, but when users
explicitly interact with them, their actions and any corre-
sponding data are transmitted to the SNS.
Proﬁle Management As users may access the web via
more than one devices, it reasonable to assume that they
will require a practical way to use SafeButton in all of
them. Although installing SafeButton on each browser
should be enough, this will result to the synchronization
of the locally stored information with the SNS for each
instance separately.
In our future work, we will con-
sider the use of cloud storage for keeping fully-encrypted
copies of the local DataStore and X-Cache, and synchro-
nizing them across all the user’s browser instances, in
the same spirit as existing settings and bookmark syn-
chronization features of popular browsers [29, 14].
Keeping a local copy of private information that is nor-
mally accessible only through the social networking ser-
vice might be considered a security risk, as it would be
made readily available to an attacker that gains unautho-
rized access to the user’s system. At that point, though,
the attacker would already have access to the user’s cre-
dentials (or could steal them by installing a keylogger on
the compromised host) and could easily gather this infor-
mation from the SNS anyway.
In any case, users could opt-in for keeping the DataS-
tore encrypted, although this would require them to pro-
vide a password to SafeButton (similarly to the above
mentioned settings synchronization features). For the
pure JavaScript implementation, though, as discussed in
Section 6, the cryptographic key can be supplied by the
SNS upon user login, making the process completely
transparent to the user.
Security in Multi-user Environments We now con-
sider the operation of SafeButton in a multi-user environ-
ment where more than one users share the same browser
instance. In general, sharing the same browser instance is
a bad security practice, because after users are done with
a browsing session they may leave sensitive information
behind, such as stored passwords, cookies, and browsing
history. Ideally, users should maintain their own browser
instance or accounts in the operating system.
SafeButton retrieves private information when users
are logged in the SNS, and stores it locally even after
they log out, as it would be inefﬁcient to erase it every
single time. Multiple users are supported by monitor-
ing the current cookies for that domain of the SNS, and
serving personalized content only for the user that is cur-
rently logged in. Local entries that belong to a user ID
that does not match the one currently logged in are never
returned. Obviously, users that share the same OS ac-
count can access each other’s locally stored data, since
they are contained in the same DataStore instance, un-
less they have opted in for keeping their data encrypted,
as discussed earlier.
Shortcomings of the Graph API Throughout this pa-
per we have brieﬂy mentioned some obstacles we have
encountered, namely shortcomings in the developer API
provided by Facebook, in respect to our objective of pro-
tecting the user’s privacy while maintaining full func-
tionality for the social plugins. We summarize these is-
sues here and discuss how the social networks in general
could support us.
User Activity Updates through the API. Currently the
Facebook API [10] offers access to the social graph but
there is no way to receive updates or “diffs” when some-
thing changes. For instance, we retrieve a friend’s “likes”
through the API, we are also able to fetch only new
“likes” from a point forward, but are unable to receive
notice when that friend “unlikes.” A friend “activity” or
“history” function could signiﬁcantly aid our implemen-
tation in keeping an accurate local store.
Accuracy of the Provided Information. Sometimes, the
API calls and documentation offered to developers differ
slightly from the actual behavior of a plugin when it is of-
fered by the SNS itself [11]. This creates a predicament
for developers wishing to replicate the functionality.
Support for All Social Information that is Otherwise Ac-
cessible. We consider it reasonable for the API to pro-
vide access to information that is accessible via the so-
cial plugins offered by the SNS itself or via the proﬁle
pages of its users. For instance, there is no API call to
access the comments of a speciﬁc user, although they ap-
pear in the user’s proﬁle page. Scrapping could retrieve
them, but this practice is not ideal. Therefore, in our case,
we have to resolve to practices that result in reduced ac-
curacy, such as anonymously retrieving a sample of the
comments of a page and placing the comments of a user’s
friends at the top, if present in the sample. Retrieving the
entire set of comments could be inefﬁcient for pages with
too many comments.
Alternatively, Facebook could provide a call for re-
trieving just the user IDs of all the commenters, and an-
other call for specifying a set of IDs for which to retrieve
the actual comments. In that case, we could hide the IDs
of a user’s friends among a group of k strangers and re-
quest their comments for that page [56].
8 Related Work
Do Not Track [5] is a browser technology which enables
users to signal, via an HTTP header, that they do not wish
to be tracked by websites they do not explicitly visit. Un-
fortunately there are no guarantees that such a request
will be honored by the receiving site or not.
Krishnamurthy et al. [46] studied privacy leaks in on-
line social networking services. They identiﬁed the pres-
ence of embedded content from third-party domains in
the interactions of a user with the SNS itself and stress