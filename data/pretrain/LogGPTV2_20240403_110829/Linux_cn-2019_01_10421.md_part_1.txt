---
author: Konstantin Ryabitsev
category: 技术
comments_data: []
count:
  commentnum: 0
  favtimes: 2
  likes: 0
  sharetimes: 0
  viewnum: 7250
date: '2019-01-07 00:09:00'
editorchoice: false
excerpt: 我们继续我们的 PGP 实践系列，来看看签名标签的标签和提交，这可以帮你确保你的仓库没有被篡改。
fromurl: https://www.linux.com/blog/learn/pgp/2018/3/protecting-code-integrity-pgp-part-6-using-pgp-git
id: 10421
islctt: true
largepic: /data/attachment/album/201901/07/000946kbvjmw5aj6q38qr8.jpg
permalink: /article-10421-1.html
pic: /data/attachment/album/201901/07/000946kbvjmw5aj6q38qr8.jpg.thumb.jpg
related:
- displayorder: 0
  raid: 10415
- displayorder: 0
  raid: 10432
reviewer: wxy
selector: ''
summary: 我们继续我们的 PGP 实践系列，来看看签名标签的标签和提交，这可以帮你确保你的仓库没有被篡改。
tags:
- PGP
- git
thumb: false
title: 用 PGP 保护代码完整性（六）：在 Git 上使用 PGP
titlepic: true
translator: qhwdw
updated: '2019-01-07 00:09:00'
---
> 
> 我们继续我们的 PGP 实践系列，来看看签名标签的标签和提交，这可以帮你确保你的仓库没有被篡改。
> 
> 
> 
![](/data/attachment/album/201901/07/000946kbvjmw5aj6q38qr8.jpg)
在本系列教程中，我们提供了一个使用 PGP 的实用指南，包括基本概念和工具、生成和保护你的密钥。如果你错过了前面的文章，你可以查看下面的链接。在这篇文章中，我们谈一谈在 Git 中如何集成 PGP、使用签名的标签，然后介绍签名提交，最后添加签名推送的支持。
* [第一部分：基本概念和工具](/article-9524-1.html)
* [第二部分：生成你的主密钥](/article-9529-1.html)
* [第三部分：生成 PGP 子密钥](/article-9607-1.html)
* [第四部分：将主密钥移到离线存储中](/article-10402-1.html)
* [第五部分：将子密钥移到硬件设备中](/article-10415-1.html)
Git 的核心特性之一就是它的去中心化本质 —— 一旦仓库克隆到你的本地系统，你就拥有了项目的完整历史，包括所有的标签、提交和分支。然而由于存在着成百上千的克隆仓库，如何才能验证你下载的仓库没有被恶意的第三方做过篡改？你可以从 GitHub 或一些貌似官方的位置来克隆它们，但是如果有些人故意欺骗了你怎么办？
或者在你参与的一些项目上发现了后门，而 “Author” 行显示是你干的，然而你很确定 [不是你干的](https://github.com/jayphelps/git-blame-someone-else)，会发生什么情况？
为解决上述问题，Git 添加了 PGP 集成。签名的标签通过确认它的内容与创建这个标签的开发者的工作站上的内容完全一致来证明仓库的完整性，而签名的提交几乎是不可能在不访问你的 PGP 密钥的情况下能够假冒你。
#### 清单
* 了解签名的标签、提交和推送（必要）
* 配置 git 使用你的密钥（必要）
* 学习标签如何签名和验证（必要）
* 配置 git 总是签名带注释标签（推荐）
* 学习提交如何签名和验证工作（必要）
* 配置 git 总是签名提交（推荐）
* 配置 gpg-agent 选项（必要）
#### 考虑事项
git 实现了 PGP 的多级集成，首先从签名标签开始，接着介绍签名提交，最后添加签名推送的支持。
##### 了解 Git 哈希
git 是一个复杂的东西，为了你能够更好地掌握它如何集成 PGP，你需要了解什么是”哈希“。我们将它归纳为两种类型的哈希：树哈希和提交哈希。
###### 树哈希
每次你向仓库提交一个变更，对于仓库中的每个子目录，git 都会记录它里面所有对象的校验和哈希 —— 内容（blobs）、目录（trees）、文件名和许可等等。它只对每次提交中发生变更的树和内容做此操作，这样在只变更树的一小部分时就不必去重新计算整个树的校验和。
然后再计算和存储处于顶级的树的校验和，这样如果仓库的任何一部分发生变化，校验和将不可避免地发生变化。
###### 提交哈希
一旦创建了树哈希，git 将计算提交哈希，它将包含有关仓库和变更的下列信息：
* 树哈希的校验和
* 变更前树哈希的校验和（父级）
* 有关作者的信息（名字、email、创作时间）
* 有关提交者的信息（名字、email、提交时间）
* 提交信息
###### 哈希函数
在写这篇文章时，虽然研究一种更强大的、抗碰撞的算法的工作正在进行，但 git 仍然使用的是 SHA1 哈希机制去计算校验和。注意，git 已经包含了碰撞防范程序，因此认为对 git 成功进行碰撞攻击仍然是不可行的。
#### 带注释标签和标签签名
在每个 Git 仓库中，标签允许开发者标记特定的提交。标签可以是 “轻量级的” —— 几乎只是一个特定提交上的指针，或者它们可以是 “带注释的”，它自己将成为 git 树中的项目。一个带注释标签对象包含所有下列的信息：
* 成为标签的提交的哈希的校验和
* 标签名字
* 关于打标签的人的信息（名字、email、打标签时间）
* 标签信息
一个 PGP 签名的标签是一个带有将所有这些条目封装进一个 PGP 签名的带注释标签。当开发者签名他们的 git 标签时，他们实际上是向你保证了如下的信息：
* 他们是谁（以及他们为什么应该被信任）
* 他们在签名时的仓库状态是什么样：
	+ 标签包含的提交的哈希
		- 提交的哈希包含了顶级树的哈希
		- 顶级树哈希包含了所有文件、内容和子树的哈希
		- 它也包含有关作者的所有信息
		- 包含变更发生时的精确时间
当你克隆一个仓库并验证一个签名的标签时，就是向你以密码方式保证：仓库中的所有内容、包括所有它的历史，与开发者签名时在它的计算机上的仓库完全一致。
#### 签名的提交
签名的提交与签名的标签非常类似 —— PGP 签名的是提交对象的内容，而不是标签对象的内容。一个提交签名也给你提供了开发者签名时开发者树上的全部可验证信息。标签签名和提交的 PGP 签名提供了有关仓库和它的完整历史的完全一致的安全保证。
#### 签名的推送
为了完整起见，在这里包含了签名的推送这一功能，因为在你使用这个功能之前，需要在接收推送的服务器上先启用它。正如我们在上面所说过的，PGP 签名一个 git 对象就是提供了开发者的 git 树当时的可验证信息，但不提供开发者对那个树意图相关的信息。
比如，你可以在你自己复刻的 git 仓库的一个实验分支上尝试一个很酷的特性，为了评估它，你提交了你的工作，但是有人在你的代码中发现了一个恶意的 bug。由于你的提交是经过正确签名的，因此有人可能将包含有恶意 bug 的分支推入到 master 分支中，从而在生产系统中引入一个漏洞。由于提交是经过你的密钥正确签名的，所以一切看起来都是合理合法的，而当 bug 被发现时，你的声誉就会因此而受到影响。
在 `git push` 时，为了验证提交的意图而不仅仅是验证它的内容，添加了要求 PGP 推送签名的功能。
#### 配置 git 使用你的 PGP 密钥
如果在你的钥匙环上只有一个密钥，那么你就不需要再做额外的事了，因为它是你的默认密钥。
然而，如果你有多个密钥，那么你必须要告诉 git 去使用哪一个密钥。（`[fpr]` 是你的密钥的指纹）：
```
$ git config --global user.signingKey [fpr]
```
注意：如果你有一个不同的 `gpg2` 命令，那么你应该告诉 git 总是去使用它，而不是传统的版本 1 的 `gpg`：
```
$ git config --global gpg.program gpg2
```
#### 如何使用签名标签
创建一个签名的标签，只要传递一个简单地 `-s` 开关给 `tag` 命令即可：
```
$ git tag -s [tagname]
```
我们建议始终对 git 标签签名，这样让其它的开发者确信他们使用的 git 仓库没有被恶意地修改过（比如，引入后门）：
##### 如何验证签名的标签
验证一个签名的标签，只需要简单地使用 `verify-tag` 命令即可：