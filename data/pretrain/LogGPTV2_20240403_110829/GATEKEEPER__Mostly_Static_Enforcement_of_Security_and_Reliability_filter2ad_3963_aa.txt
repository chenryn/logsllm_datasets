title:GATEKEEPER: Mostly Static Enforcement of Security and Reliability
Policies for JavaScript Code
author:Salvatore Guarnieri and
V. Benjamin Livshits
GATEKEEPER: Mostly Static Enforcement of Security and
Reliability Policies for JavaScript Code
Salvatore Guarnieri
University of Washington
PI:EMAIL
Benjamin Livshits
Microsoft Research
PI:EMAIL
Abstract
The advent of Web 2.0 has lead to the proliferation of
client-side code that is typically written in JavaScript.
This code is often combined — or mashed-up — with
other code and content from disparate, mutually untrust-
ing parties, leading to undesirable security and reliability
consequences.
This paper proposes GATEKEEPER, a mostly static ap-
proach for soundly enforcing security and reliability poli-
cies for JavaScript programs. GATEKEEPER is a highly
extensible system with a rich, expressive policy language,
allowing the hosting site administrator to formulate their
policies as succinct Datalog queries.
The primary application of GATEKEEPER this paper ex-
plores is in reasoning about JavaScript widgets such as
those hosted by widget portals Live.com and Google/IG.
Widgets submitted to these sites can be either malicious
or just buggy and poorly written, and the hosting site has
the authority to reject the submission of widgets that do
not meet the site’s security policies.
To show the practicality of our approach, we de-
scribe nine representative security and reliability policies.
Statically checking these policies results in 1,341 veriﬁed
warnings in 684 widgets, no false negatives, due to the
soundness of our analysis, and false positives affecting
only two widgets.
1
Introduction
JavaScript is increasingly becoming the lingua franca of
the Web, used both for large monolithic applications and
small widgets that are typically combined with other code
from mutually untrusting parties. At the same time, many
programming language purists consider JavaScript to be
an atrocious language, forever spoiled by hard-to-analyze
dynamic constructs such as eval and the lack of static
typing. This perception has lead to a situation where code
instrumentation and not static program analysis has been
the weapon of choice when it comes to enforcing security
policies of JavaScript code [20, 25, 29, 35].
As a recent report from Finjan Security shows, widget-
based attacks are on the rise [17], making widget secu-
rity an increasingly important problem to address. The
report also describes well-publicised vulnerabilities in the
Vista sidebar, Live.com, and Yahoo! widgets. The pri-
mary focus of this paper is on statically enforcing secu-
rity and reliability policies for JavaScript code. These
policies include restricting widget capabilities, making
sure built-in objects are not modiﬁed, preventing code in-
jection attempts, redirect and cross-site scripting detec-
tion, preventing global namespace pollution, taint check-
ing, etc. Soundly enforcing security policies is harder
that one might
if we
want to ensure a widget cannot call document.write
because this construct allows arbitrary code injection,
we need to either analyze or disallow tricky con-
structs like eval("document" + ".write(’...’)"),
or var a = document[’wri’ + ’te’]; a(’...’);
which use reﬂection or even
think at ﬁrst.
For instance,
var a = document;
var b = a.write;
b.call(this, ’...’)
which uses aliasing to confuse a potential enforcement
tool. A na¨ıve unsound analysis can easily miss these
constructs. Given the availability of JavaScript obfusca-
tors [19], a malicious widget may easily masquerade its
intent. Even for this very simple policy, grep is far from
an adequate solution.
JavaScript relies on heap-based allocation for the ob-
jects it creates. Because of the problem of object alias-
ing alluded to above in the document.write example
where multiple variable names refer to the same heap
object, to be able to soundly enforce the policies men-
tioned above, GATEKEEPER needs to statically reason
about the program heap. To this end, this paper proposes
the ﬁrst points-to analysis for JavaScript. The program-
ming language community has long recognized pointer
analysis to be a key building block for reasoning about
object-oriented programs. As a result, pointer analy-
Figure 1: GATEKEEPER deployment. The three principals are: the user, the widget host, and the widget developer.
ses have been developed for commonly used languages
such as C and Java, but nothing has been proposed for
JavaScript thus far. However, a sound and precise points-
to analysis of the full JavaScript language is very hard
to construct. Therefore, we propose a pointer analysis
for JavaScriptSAFE, a realistic subset that includes proto-
types and reﬂective language constructs. To handle pro-
grams outside of the JavaScriptSAFE subset, GATEKEEPER
inserts runtime checks to preclude dynamic code intro-
duction. Both the pointer analysis and nine policies we
formulate on top of the points-to results are written on top
of the same expressive Datalog-based declarative analysis
framework. As a consequence, the hosting site interested
in enforcing a security policy can program their policy in
several lines of Datalog and apply it to all newly submit-
ted widgets.
In this paper we demonstrate that, in fact, JavaScript
programs are far more amenable to analysis than previ-
ously believed. To justify our design choices, we have
evaluated over 8,000 JavaScript widgets, from sources
such as Live.com, Google, and the Vista Sidebar. Unlike
some previous proposals [35], JavaScriptSAFE is entirely
pragmatic, driven by what is found in real-life JavaScript
widgets. Encouragingly, we have discovered that the use
of with, Function and other “difﬁcult” constructs [12]
is similarly rare.
In fact, eval, a reﬂective construct
that usually foils static analysis, is only used in 6% of
our benchmarks. However, statically unknown ﬁeld ref-
erences such a[index], dangerous because these can be
used to get to eval through this[’eval’], etc., and
innerHTML assignments, dangerous because these can be
used to inject JavaScript into the DOM, are more prevalent
than previously thought. Since these features are quite
common, to prevent runtime code introduction and main-
tain the soundness of our approach, GATEKEEPER inserts
dynamic checks around statically unresolved ﬁeld refer-
ences and innerHTML assignments.
This paper contains a comprehensive large-scale exper-
imental evaluation. To show the practicality of GATE-
KEEPER, we present nine representative policies for se-
curity and reliability. Our policies include restricting
widgets capabilities to prevent calls to alert and the
use of the XmlHttpRequest object, looking for global
namespace pollution, detecting browser redirects lead-
ing to cross-site scripting, preventing code injection, taint
checking, etc. We experimented on 8,379 widgets, out of
which 6,541 are analyzable by GATEKEEPER 1. Checking
our nine policies resulted in us discovering a total of 1,341
veriﬁed warnings that affect 684, with only 113 false pos-
itives affecting only two widgets.
1.1 Contributions
This paper makes the following contributions:
• We propose the ﬁrst points-to analysis for JavaScript
programs. Our analysis is the ﬁrst to handle a
prototype-based language such as JavaScript. We
also identify JavaScriptSAFE, a statically analyzable
subset of the JavaScript language and propose light-
weight instrumentation that restricts runtime code in-
troduction to handle many more programs outside of
the JavaScriptSAFE subset.
• On the basis of points-to information, we demon-
strate the utility of our approach by describing nine
representative security and reliability policies that
are soundly checked by GATEKEEPER, meaning no
false negatives are introduced. These policies are ex-
pressed in the form of succinct declarative Datalog
queries. The system is highly extensible and easy
to use: each policy we present is only several lines
of Datalog. Policies we describe include restricting
widget capabilities, making sure built-in objects are
not modiﬁed, preventing code injection attempts, etc.
• Our experimental evaluation involves in excess of
eight thousand publicly available JavaScript widgets
from Live.com, the Vista Sidebar, and Google. We
ﬂag a total of 1,341 policy violations spanning 684
widgets, with 113 false positives affecting only two
widgets.
1Because we cannot ensure soundness for the remaining 1,845 wid-
gets, we reject them without further policy checking.
submit widgetGATEKEEPER policy checks pass ?yes: deployno: reject and output detailed warningsuserwidget hostdeveloper1.2 Paper Organization
The rest of the paper is organized as follows. Section 2
gives an overview of our approach and summarizes the
most signiﬁcant analysis challenges. Section 3 provides
a deep dive into the details of our analysis; a reader in-
terested in learning about the security policies may skip
this section on the ﬁrst reading. Section 4 describes nine
static checkers we have developed for checking security
policies of JavaScript widgets. Section 5 summarizes the
experimental results. Finally, Sections 6 and 7 describe
related work and conclude.
2 Overview
As a recent report from Finjan Security shows, widget-
based attacks are on the rise [17]. Exploits such as those
in a Vista sidebar contacts widget, a Live.com RSS wid-
get, and a Yahoo! contact widget [17, 27] not only affect
unsuspecting users, they also reﬂect poorly on the hosting
site. In a way, widgets are like operating system drivers:
their quality directly affects the perceived quality of the
underlying OS. While driver reliability and security has
been subject of much work [7], widget security has re-
ceived relatively little attention.
Just like with drivers,
however, widgets can run in the same page (analogous
to an OS process) as the rest of the hosting site. Because
widget ﬂaws can negatively impact the rest of the site, it
is out aim to develop tools to ensure widget security and
reliability.
While our proposed static analysis techniques are much
more general and can be used for purposes as diverse as
program optimization, concrete type inference, and bug
ﬁnding, the focus of this paper is on soundly enforcing se-
curity and reliability policies of JavaScript widgets. There
are three principals that emerge in that scenario: the wid-
get hosting site such as Live.com, the developer submit-
ting a particular widget, and the user on whose computer
the widget is ultimately executed. The relationship of
these principals is shown in Figure 1. We are primarily in-
terested in helping the widget host ensure that their users
are protected.
2.1 Deployment
We envision GATEKEEPER being deployed and run by the
widget hosting provider as a mandatory checking step in
the online submission process, required before a widget
is accepted from a widget developer. Many hosts already
use captchas to ensure that the submitter is human. How-
ever, captchas say nothing about the quality and intent of
the code being submitted. Using GATEKEEPER will en-
sure that the widget being submitted complies with the
policies chosen by the host. A hosting provider has the
authority to reject some of the submitted widgets, instruct-
ing widgets authors to change their code until it passes the
policy checker, not unlike tools like the static driver veri-
ﬁer for Windows drivers [24]. Our policy checker outputs
detailed information about why a particular widget fails,
annotated with line numbers, which allows the widget de-
veloper to ﬁx their code and resubmit.
2.2 Designing Static Language Restrictions
To enable sound analysis, we ﬁrst restrict the input to be
a subset of JavaScript as deﬁned by the EcmaScript-262
language standard. Unlike previous proposals that sig-
niﬁcantly hamper language expressiveness for the sake
of safety [13], our restrictions are relatively minor.
In
particular, we disallow the eval construct and its close
cousin, the Function object constructor as well as func-
tions setTimeout and setInterval. All of these con-
structs take a string and execute it as JavaScript code.
The fundamental problem with these constructs is that
they introduce new code at runtime that is unseen — and
therefore cannot be reasoned about — by the static ana-
lyzer. These reﬂective constructs have the same expres-
sive power: allowing one of them is enough to have the
possibility of arbitrary code introduction.
We also disallow the use of with, a language feature
that allows to dynamically substitute the symbol lookup
scope, a feature that has few legitimate uses and signif-
icantly complicates static reasoning about the code. As
our treatment of prototypes shows, it is in fact possible
to handle with, but it is only used in 8% of our bench-
marks. Finally, while these restrictions might seem dra-
conian at ﬁrst, they are very similar to what a recently
proposed strict mode for JavaScript enforces [14].
We do allow reﬂective constructs Function.call,
Function.apply, and the arguments array.
Indeed,
Function.call, the construct that allows the caller of a
function to set the callee’s this parameter, is used in 99%
of Live widgets and can be analyzed statically with rela-
tive ease, so we handle this language feature. The preva-
lence of Function.call can be explained by a common
coding pattern for implementing a form of inheritance,
which is encouraged by Live.com widget documentation,
and is found pretty much verbatim in most widgets.
In other words, our analysis choices are driven by the
statistics we collect from 8,379 real-world widgets and not
hypothetical considerations. More information about the
relative prevalence of “dangerous” language features can
be found in Figure 3. The most common “unsafe” features
we have to address are .innerHTML assignments and sta-
tically unresolved ﬁeld references. Because they are so
common, we cannot simply disallow them, so we check
them at runtime instead.
To implement restrictions on the allowed input,
in
Figure 2: GATEKEEPER analysis architecture.
JavaScript Construct
Non-Const Index
with
arguments
setTimeout
setInterval
eval
apply
call
Function
document.write
.innerHTML
Sidebar
Affected
1,736
422
175
824
377
353
173
151
142
102
1,535
%
38.6%
9.4%
3.9%
18.3%
8.4%
7.8%
3.8%
3.4%
3.2%
2.3%
34.1%
Windows Live
%
6.5%
.1%
.2%
1.8%
.6%
.4%
1.1%
99.0%
.1%
0%
75.6%
Affected
176
2
6
49
16
10
29
2,687
4
1
2,053
Google
Affected
192
2
3
65
13
55
6
4
21
108
288
%
16.4%
.2%
.3%
5.6%
1.1%
4.7%
.5%
.3%
1.8%
9.2%
24.6%
Figure 3: Statistics for 4,501 widgets from Sidebar and 2,714 widgets from Live, and 1,171 widgets from Google.
our JavaScript parser we ﬂag the use of lexer tokens
eval, Function, and with, as well as setTimeout, and
setInterval. We need to disallow all of these con-
structs because letting one of them through is enough
for arbitrary code introduction. The feature we can-
not handle simply using lexer token blacklisting is
document.write. We ﬁrst optimistically assume that no
calls to document.write are present and then proceed to
verify this assumption as described in Section 4.3. This
way our analysis remains sound.
We consider two subsets of the JavaScript language,
JavaScriptSAFE and JavaScriptGK. The two subsets are com-
pared in Figure 4.
If the program passes the checks
above and lacks statically unresolved array accesses
and innerHTML assignments,
is declared to be in
JavaScriptSAFE. Otherwise, these dangerous accesses are
instrumented and it is declared in the JavaScriptGK lan-
guage subset. To resolve ﬁeld accesses, we run a local
dataﬂow constant propagation analysis [1] to identify the
use of constants as ﬁeld names.
In other words, in the