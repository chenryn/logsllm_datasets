table entry is never repaired, only overwritten with new, hope-
fully non-corrupted data. This only occurs when an instruc-
tion that writes its result to the corresponding register (cid:2)le en-
try commits. Many of the trials in the archrat’s Gray Area
category are due to an injection into a register alias table en-
try whose corresponding architectural register is not written
to within the simulation limit.
The Gray Area categories of the ctrl, qctrl, robptr and
valid state classi(cid:2)cations also increase in size, displacing
locked failures. This is evidence that the timeout counter
mechanism worked to (cid:3)ush and restart the pipeline, resulting
in subsequent correct execution. Unfortunately, the change in
timing due to the pipeline (cid:3)ush makes a complete state match
unlikely, pushing many trials into Gray Area.
In Figure 10, a pie chart depicting the relative contribu-
tions of each state type to failures is presented. This (cid:2)gure
is in contrast to Figure 8, from the unprotected experiment.
The failures are now dominated by transient faults affecting
the pc, ctrl, and data categories. Note that failures from the
protected elements were not completely eliminated. These
failures were the result of transient faults affecting areas that
were left unprotected for minimal cycle time impact.
Worth noting is that directly comparing the aggregate
total in Figure 9 to its counterpart in Figure 4 is not fair.
This is due to the 6-7% extra (mostly non-vulnerable) state
introduced by the various protection mechanisms. After ac-
counting for a 7% higher transient fault rate, the implemented
mechanisms reduce the known failure rate (represented by the
SDC and Terminated categories) by approximately 75%.
5. Architectural Implications
Soft errors that do not get masked in the microarchitec-
tural level propagate to the architectural level and become vis-
ible to the running application. However, masking continues
to occur, and some fraction of these errors are masked at the
insn
data
Figure 10. Relative contributions of each state
type to SDC and Terminated.
architectural (or application) level. In this section, we model
errors that have propagated to the architectural level and ob-
serve their effects.
For this set of fault injections campaigns, we use a mod-
i(cid:2)ed version of SimpleScalar’s functional simulator [4]. An
instruction from the dynamic instruction stream is selected
at random and forced to execute incorrectly. The program
is then allowed to proceed, and the simulation is monitored
for one of four outcomes: (1) Exception, (2) State OK, (3)
Output OK, and (4) Output Bad.
If the error-injected pro-
gram generates an exception, it is placed in the Exception
category. This is a (cid:147)noisy(cid:148) failure. Otherwise, if the architec-
tural state (memory, registers, program counter) completely
matches that of a non-error-injected execution of the program
prior to a system call (the form of external communication for
our applications), the trial is placed in the State OK category.
This category represents trials that resulted in software mask-
ing of faults. If the trial does not (cid:2)t in either of the (cid:2)rst two
categories, the user visible output of the application may still
be correct. To identify when this occurs, the output of the ap-
plication is compared against that of a reference simulation.
If the program outputs were identical, the trial is placed in
Output OK. Note that the Output OK category is weaker than
the State OK category. Finally, a trial that generates incorrect
user visible output is added the Output Bad category.
We use six different fault models in this experiment: (1)
a single bit (cid:3)ip targeting the lower 32 bits of the result of a
register write, (2) a single bit (cid:3)ip targeting all 64 bits, (3) re-
placing the result of a register write with 64 random bits of
data, (4) a single bit (cid:3)ip into an instruction word, (5) chang-
ing an instruction into a no operation (nop), and (6) forcing
conditional branches to (cid:3)ip direction. Fault models (1)-(4)
in particular re(cid:3)ect the failure modes seen from the microar-
chitectural fault injection experiments from Section 3, while
fault models (5) and (6) provide an additional sense of the
transient fault masking levels of software. Results of these
experiments are presented in Figure 11 as averages across
10 SPEC2000 integer benchmarks. They represent approx-
100%
90%
80%
70%
60%
50%
40%
30%
20%
10%
0%
exceptions
output bad
output ok
state ok
1bitdest32
1bitdest64
64bitdest
1bitinsn
nop
branch
average
Figure 11. Results of various fault models on
software.
imately 10,000-15,000 trials each, yielding a con(cid:2)dence in-
terval of less than 1% at a 95% con(cid:2)dence level for each fault
injection campaign.
From the results, we see that across all the injection cam-
paigns, approximately half of the trials result in complete ar-
chitectural state convergence (State OK). This indicates that
the masking levels of software are signi(cid:2)cant, and roughly
indicates that half the errors that escape the hardware layer
are eventually masked by the application. This masking ef-
fect is largely due to dead and transitively dead values in the
instruction stream.
We also note that in the (cid:2)rst (cid:2)ve fault models, a mod-
erately sized portion (10(cid:150)20%) of the trials from State OK
had divergent control (cid:3)ow when compared against a reference
execution. This means that the induced fault temporarily im-
pacted the control (cid:3)ow of the application before the fault was
completely masked. A fault model that only affected control
(cid:3)ow was used in the last experiment, and we further investi-
gated this phenomenon in [22].
6. Limitations of Results
The presented experimental results are heavily based
on our choice of fault models, microarchitecture, simulation
models, and workloads. For example, much of this work is
geared towards characterizing the effects of single bit corrup-
tions. If this fault model fails to accurately model physical
transient faults, an underlying assumption of this work is bro-
ken. The same is true of our microarchitectural model: we
only characterize the failure rates of our particular pipeline in
this paper; but we believe that there are lessons to be learned
that are more broadly applicable. For example, the general
methodology of identifying vulnerable portions of a micro-
processor and devising low overhead protection mechanisms
for those portions is a generally applicable technique.
Furthermore, implementation choices we made in the
microarchitectural and logic design process may affect the
measured masking levels. There were occasions where
we chose a simpler implementation over a more complex
and compact implementation. For example, some Program
Counter (PC) (cid:2)elds within each Reorder Buffer entry could
have been stored more ef(cid:2)ciently within a smaller separate
structure, potentially reducing the number of bits in the Re-
order Buffer and potentially reducing the masking rate. The
extent to which this has an affect on our results is unclear, but
we suspect it to be fairly small. These sorts of tradeoffs are
also made on real implementations, and some real decisions
might also increase masking rates.
While care was taken to create a detailed microarchitec-
tural experimental infrastructure, not all of the intricacies of
a modern dynamically scheduled processor were fully mod-
eled. Nonetheless, we believe that our model was created
with suf(cid:2)cient detail to provide error manifestation results ac-
curate to within 10s of percent when compared with those of
a real implementation.
7. Related Work
Czeck and Siewiorek [6] performed a similar analysis
through fault injection into selected bits of state in their simu-
lation model. Here, we use a more modern simulation model
and do a more thorough classi(cid:2)cation of the failure modes of
various types of state in a microprocessor.
Mukherjee et al. [21] introduced a method to com-
pute Architectural Vulnerability Factors for various processor
components and IA-64 software through analysis. The gen-
eral experimental results presented in this work corroborate
their analytic (cid:2)ndings.
Kim and Somani [12] injected faults into picoJava-II, a
microprocessor core developed by Sun Microsystems. Their
microarchitectural model is more accurate than the one used
in this work; however, it is less complex in terms of high-
performance microarchitectural features. Also, they only ver-
ify the architectural state of the machine. Here, trials that
result in a complete microarchitectural state match are identi-
(cid:2)ed along with architectural state failures.
Ando et al. [10] protected the data and address paths of
their SPARC64 design with parity. Gaisler [9] protected the
register (cid:2)le in his SPARC V8 implementation using a tech-
nique similar to the one used in this work. Furthermore, he
protected various (cid:3)ip-(cid:3)ops by using triple modular redun-
dancy and providing three separate clock trees. Franklin [7]
noted different modes of failure throughout the pipeline, and
proposed mechanisms to guard against them. Here, vulnera-
ble state was identi(cid:2)ed through fault injection, and protection
mechanisms to defend against a majority of transient faults
were proposed, implemented, and tested.
Other work related to the microarchitectural work pre-
sented here include higher overhead mechanisms to protect
microprocessors with various forms of redundancy in mi-
croarchitecture [15, 18, 23]. Here, arguably lower overhead
approaches are proposed, albeit with lower fault coverage.
Previous work [19, 21, 2] has also explored the compo-
sition of dynamic instruction streams for dead and silent in-
structions. This work explores the same subject through fault
injection and identi(cid:2)es a larger set of dynamically dead in-
structions. Namely, a signi(cid:2)cant portion of control instruc-
tions are dead, and thus, instructions that produce values for
these control instructions are also possibly dead.
8. Conclusion
In this work, an analysis of the effects of transient faults
on high performance processors was characterized. To ac-
complish this, a detailed microarchitectural model was cre-
ated, and a fault model was selected. The results of the en-
suing fault injection experiment were not particularly surpris-
ing: the most vulnerable parts of a processor are those that of-
ten hold architectural state. This information was taken into
account when devising lightweight protection mechanisms to
cover the majority of the failures.
To summarize our experimental (cid:2)ndings, we found that
at least 85% of injected single event upsets in our base-
line microarchitecture are masked from software. We also
found signi(cid:2)cant masking levels present in software for vari-
ous fault models. Together, the microarchitectural and archi-
tectural levels of masking hide more than 9 out of every 10
latched transient faults from affecting correct program execu-
tion. With precisely placed low overhead protection mech-
anisms, the level of masking is even higher. This gives an
idea of the underutilization of modern microprocessors and
dynamic inef(cid:2)ciencies of software.
9. Acknowledgments
We thank the other members of the Advanced Comput-
ing Systems group as well as Zbigniew Kalbarczyk, Claudio
Basile, and the anonymous referees for providing feedback
during various stages of this work. We also thank Joel Biskie
and Wojciech Magda for their respective contributions. This
work was supported by the C2S2 Marco center, NSF grant
EIA-0224453, and equipment donation from AMD.
References
[1] B. A. Gieseke et al. A 600MHz superscalar RISC micropro-
cessor with out-of-order execution.
In 1997 IEEE Interna-
tional Solid-State Circuits Conference Digest of Technical Pa-
pers, pages 176(cid:150)178, Feb. 1997.
[2] B. Fahs et al. Performance characterization of a hardware
framework for dynamic optimization. In Proceedings of the
34th Annual International Symposium on Microarchitecture,
pages 16(cid:150)27, 2001.
[3] M. Baze and S. Buchner. Attenuation of single event induced
pulses in CMOS combinational logic. IEEE Transactions on
Nuclear Science, 44(6):2217(cid:150)2223, Dec. 1997.
[4] D. Burger, T. Austin, and S. Bennett. Evaluating future mi-
croprocessors:
the simplescalar tool set. Technical Report
1308, University of Wisconsin - Madison Technical Report,
July 1996.
[5] G. Z. Chrysos and J. S. Emer. Memory dependence prediction
using store sets. In Proceedings of the 25th Annual Interna-
tional Symposium on Computer Architecture, pages 142 (cid:150) 153,
1998.
[6] E. W. Czeck and D. Siewiorek. Effects of transient gate-level
In Proceedings of the 1990 In-
faults on program behavior.
ternational Symposium on Fault-Tolerant Computing, pages
236(cid:150)243, June 1990.
[7] M. Franklin. Incorporating fault tolerance in superscalar pro-
In Proceedings of High Performance Computing,
cessors.
pages 301(cid:150)306, Dec. 1996.
[8] G. Hinton et al. The Microarchitecture of the Pentium 4 Pro-
cessor. Intel Technology Journal, Jan. 2001.
[9] J. Gaisler. A portable and fault-tolerant microprocessor based
on the SPARC V8 architecture. In Proceedings of the Inter-
national Conference on Dependable Systems and Networks,
pages 409(cid:150)415, Sept. 2002.
[10] H. Ando et al. A 1.3 GHz (cid:2)fth generation SPARC64 micro-
processor. In Design Automation Conference, pages 702(cid:150)705,
June 2003.
[11] H. Cha et al. A gate-level simulation environment for alpha-
particle-induced transient faults. IEEE Transactions on Com-
puters, 45(11):1248(cid:150)1256, Nov. 1996.
[12] S. Kim and A. K. Somani. Soft error sensitivity characteriza-
tion for microprocessor dependability enhancement strategy.
In Proceedings of the International Conference on Depend-
able Systems and Networks, pages 416(cid:150)425, Sept. 2002.
[13] S. McFarling. Combining branch predictors. Technical Report
TN-36, Digital Western Research Laboratory, June 1993.
[14] D. Meyer. AMD-K7
Technology Presentation. Advanced

Micro Devices, Inc., Sunnyvale, CA, Oct. 1998. Microproces-
sor Forum presentation.
[15] S. S. Mukherjee, M. Kontz, and S. K. Reinhardt. Detailed de-
sign and evaluation of redundant multithreading alternatives.
In Proceedings of the 29th Annual International Symposium
on Computer Architecture, pages 99(cid:150)110, May 2002.
[16] P. Lid·en et al. On latching probability of particle induced tran-
sients in combinational networks. In Proceedings of the 1994
International Symposium on Fault-Tolerant Computing, pages
340(cid:150)349, June 1994.
[17] P. Shivakumar et al. Modeling the effect of technology trends
on the soft error rate of combinational logic. In Proceedings
of the 2002 International Conference on Dependable Systems
and Networks, pages 389(cid:150)398, June 2002.
[18] E. Rotenberg. AR-SMT: A microarchitectural approach to
fault tolerance in microprocessors. In Proceedings of Fault-
Tolerant Computing Systems, pages 84(cid:150)91, June 1999.
[19] E. Rotenberg. Exploiting large ineffectual instruction se-
quences. Technical report, North Carolina State University,
Nov. 1999.
[20] S. Buchner et al. Comparison of error rates in combinational
and sequential logic. IEEE Transactions on Nuclear Science,
44(6):2209(cid:150)2216, Dec. 1997.
[21] S. S. Mukherjee et al. A systematic methodology to compute
the architectural vulnerability factors for a high-performance
microprocessor. In Proceedings of the 36th International Sym-
posium on Microarchitecture, pages 29(cid:150)40, Dec. 2003.
[22] N. Wang, M. Fertig, and S. Patel. Y-branches: When you come
to a fork in the road, take it. In Proceedings of the Interna-
tional Conference on Parallel Architectures and Compilation
Techniques, pages 56(cid:150)66, 2003.
[23] C. Weaver and T. Austin. A fault tolerant approach to micro-
processor design.
In Proceedings of the 29th Annual Inter-
national Symposium on Computer Architecture, pages 87(cid:150)98,
May 2002.