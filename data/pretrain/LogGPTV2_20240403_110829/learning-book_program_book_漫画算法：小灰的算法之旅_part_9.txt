4
5
6
---
## Page 148
二叉树非递归前序遍历的代码已经写
好了，让我们来看一看。
1./**
*二叉树非递归前序遍历
3.
*@paramroot
二叉树根节点
4.
*/
5.public static void pre0rderTraveralwithStack(TreeNode root)
6.
Stack stack = new Stack();
7.
TreeNode treeNode = root;
8.
while(treeNode!=null 1l!stack.isEmpty()){
9.
//选代访问节点的左孩子，并入栈
10.
while (treeNode != null){
11.
System.out.println(treeNode.data);
12.
stack.push(treeNode);
13.
treeNode = treeNode.leftChild;
14.
15.
//如果节点没有左孩子，则弹出栈顶节点，访问节点右孩子
16.
if(!stack.isEmpty()){
17.
treeNode = stack.pop();
---
## Page 149
18.
treeNode = treeNode.rightChild;
19.
20.
21.}
至于二叉树的中序、后序遍历的非递归实现，思路和前序遍历差不太
多，都是利用栈来进行回溯。各位读者要是有兴趣的话，可以自己尝试
用代码实现一下。
3.2.3广度优先遍历
如果说深度优先遍历是在一个方向上“一头扎到底”，那么广度优先遍历
则恰恰相反：先在各个方向上各走出1步，再在各个方向上走出第2步
第3步......一直到各个方向全部走完。听起来有些抽象，下面让我们通
过二叉树的层序遍历，来看一看广度优先是怎么回事。
层序遍历，顾名思义，就是二叉树按照从根节点到叶子节点的层次关
系，一层一层横向遍历各个节点。
3
3
5
6
5
G
上图就是一个二叉树的层序遍历，每个节点左侧的序号代表该节点的输
出顺序。
可是，二叉树同一层次的节点之间是没有直接关联的，如何实现这种层
序遍历呢？
---
## Page 150
这里同样需要借助一个数据结构来辅助工作，这个数据结构就是队列
详细遍历步骤如下。
1.根节点1进入队列。
5
1
2.
，节点1出队，输出节点1，并得到节点1的左孩子节点2、右孩子节点
3。让节点2和节点3入队。
3
3.
：节点2出队，输出节点2，并得到节点2的左孩子节点4、右孩子节点
5。让节点4和节点5入队。
---
## Page 151
34
4
节点3出队，输出节点3，并得到节点3的右孩子节点6。让节点6入
队。
3
4
5
6
5.节点4出队，输出节点4，由于节点4没有孩子节点，所以没有新节点
入队。
---
## Page 152
5
5
6
6.节点5出队，输出节点5，由于节点5同样没有孩子节点，所以没有新
节点入队。
5
6
7.节点6出队，输出节点6，节点6没有孩子节点，没有新节点入队。
---
## Page 153
5
到此为止，所有的节点都遍历输出完毕。
这个层序遍历看起来有点意思，
代码怎么写呢？
代码不难写，让我们来看一看。
1./*
2.*二叉树层序遍历
3.*@paramroot
二叉树根节点
4.
*/
---
## Page 154
5. public static void levelorderTraversal(TreeNode root){
6.
Queue queue = new LinkedList();
7.
queue.offer(root);
8.
while(!queue.isEmpty()){
9.
TreeNode node = queue.poll();
10.
System.out.println(node.data);
11.
if(node.leftChild != null){
12.
queue.offer(node.leftchild);
13.
14.
if(node.rightChild != null){
15.
queue.offer(node.rightchild);
16.
17.
18.}
基本上明白了，最后想问问，二
叉树的层序遍历可以用递归方式来实现吗？
---
## Page 155
可以，不过在思路上有一点绕。我们
把这个作为思考题，聪明的读者如果有兴趣，可以想一想层序遍历
的递归实现方法哦！
好了，有关二叉树的遍历问题，就讲
到这里，咱们下一节再见！
3.3
什么是二叉堆
3.3.1
初识二叉堆
---
## Page 156
小灰，我很喜欢一句名
言：是金子总会有发光的
这句话很有道理，即使一
个人出身很低微，只要自
身足够出色，同样可以爬
上人生的顶点。
这让我想起一种数据结
构，它可以通过白身调
整，让最大或最小的元素
移动到项点。
---
## Page 157
哦？什么数据结构这
么厉害呀？
这种神奇的数据结
构叫作二叉堆，
什么是二叉堆？
二叉堆本质上是一种完全二叉树，它分为两个类型。
1.最大堆。
2.最小堆。
什么是最大堆呢？最大堆的任何一个父节点的值，都大于或等于
它
左、右孩子节点的值。
---
## Page 158
10
8
g
5
什么是最小堆呢？最小堆的任何一个父节点的值，都小于或等于它左、
右孩子节点的值。
6
8
10
二叉堆的根节点叫作堆顶。
最大堆和最小堆的特点决定了：最大堆的堆顶是整个堆中的最大元素
；最小堆的堆顶是整个堆中的最小元素。
---
## Page 159
那么，我们如何构建一个堆呢？
这就需要依靠二叉堆的自我调整了。
3.3.2
二叉堆的自我调整
对于二叉堆，有如下几种操作。
1.插入节点。
2.删除节点。
3.构建二叉堆。
这几种操作都基于堆的自我调整。所谓堆的自我调整，就是把一个不符
合堆性质的完全二叉树，调整成一个堆。下面让我们以最小堆为例，看
一看二叉堆是如何进行自我调整的。
1.插入节点
当二叉堆插入节点时，插入位置是完全二叉树的最后一个位置。例如插
入一个新节点，值是0。
---
## Page 160
这时，新节点的父节点5比0大，显然不符合最小堆的性质。于是让新节
点“上浮”，和父节点交换位置。
h
继续用节点0和父节点3做比较，因为0小于3，则让新节点继续“上浮”。
---
## Page 161
继续比较，最终新节点0"上浮"到了堆顶位置。
0
2
10
2.删除节点
二叉堆删除节点的过程和插入节点的过程正好相反，所删除的是处于堆
顶的节点。例如删除最小堆的堆顶节点1。
---
## Page 162
这时，为了继续维持完全二叉树的结构，我们把堆的最后一个节点10临
时补到原本堆顶的位置。
10
10
接下来，让暂处堆顶位置的节点10和它的左、右孩子进行比较，如果
左、右孩子节点中最小的一个（显然是节点2）比节点10小，那么让节
点10"下沉”。
---
## Page 163
10
6
10
继续让节点10和它的左、右孩子做比较，左、右孩子中最小的是节点
7，由于10大于7，让节点10继续“下沉”。
2
3
5
10
8
10
这样一来，二叉堆重新得到了调整。
3.构建二叉堆
构建二叉堆，也就是把一个无序的完全二叉树调整为二叉堆，本质就是
让所有非叶子节点依次“下沉”。
下面举一个无序完全二叉树的例子，如下图所示。
---
## Page 164
10
首先，从最后一个非叶子节点开始，也就是从节点10开始。如果节点10
大于它左、右孩子节点中最小的一个，则节点10"下沉”。
10
接下来轮到节点3，如果节点3大于它左、右孩子节点中最小的一个，则
节点3"下沉”
---
## Page 165
然后轮到节点1，如果节点1大于它左、右孩子节点中最小的一个，则节
点1"下沉”。事实上节点1小于它的左、右孩子，所以不用改变。
接下来轮到节点7，如果节点7大于它左、右孩子节点中最小的一个，则
节点7"下沉”。
节点7继续比较，继续“下沉”。
---
## Page 166
5
6
3
8
10
经过上述几轮比较和“下沉"操作，最终每一节点都小于它的左、右孩子
节点，一个无序的完全二叉树就被构建成了一个最小堆。
小灰，你来思考一下，堆的插入、删
除、构建操作的时间复杂度各是多少？
堆的插入操作是单一节点的"上
浮”，堆的删除操作是单一节点的"下沉”，这两个操作的平均交换
次数都是堆高度的一半，所以时间复杂度是O(logn)。至于堆的构
建，需要所有非叶子节点依次“下沉”，所以我觉得时间复杂度应该
是O（nlogn)吧？
---
## Page 167
关于堆的插入和删除操作，你说的没
有错，时间复杂度确实是O(logn)。但构建堆的时间复杂度却并不是
O(nlogn)，而是O(n)。这涉及数学推导过程，有兴趣的话，你可以
自己琢磨一下哦。
这二叉堆还真有点意思，那么怎
么用代码来实现呢？
3.3.3
二叉堆的代码实现
在展示代码之前，我们还需要明确一点：二叉堆虽然是一个完全二叉
树，但它的存储方式并不是链式存储，而是顺序存储。换句话说，二叉
堆的所有节点都存储在数组中。
---
## Page 168
2xparent+2
326578910
parent
2xparent+1
在数组中，在没有左、右指针的情况下，如何定位一个父节点的左孩子
和右孩子呢？
像上图那样，可以依靠数组下标来计算。
假设父节点的下标是parent，那么它的左孩子下标就是2xparent+1；右
孩子下标就是2xparent+2。
例如上面的例子中，节点6包含9和10两个孩子节点，节点6在数组中的
下标是3，节点9在数组中的下标是7，节点10在数组中的下标是8。
那么，
7=3×2+1，
8 =3×2+2，
刚好符合规律。
有了这个前提，下面的代码就更好理解了。
1. /**
2.*“上浮"调整
---
## Page 169
3.*@param array
待调整的堆
4.
*/
5. public static void upAdjust(int[] array) {
6.
int childIndex = array.length-1;
7.
int parentIndex =(childIndex-1)/2;
8.
//temp保存插入的叶子节点值，用于最后的赋值
9.
int temp = array[childIndex];
10.
while (childIndex >θ && temp < array[parentIndex])
11.
{
12.
//无须真正交换，单向赋值即可
13.
array[childIndex]= array[parentIndex];
14.
childIndex = parentIndex;
15.
parentIndex =（parentIndex-1)/2;
16.
17.
array[childIndex]= temp;
18.}
19.
20.
21./**
22.
★"下沉"调整
23.
@param array
待调整的堆
24.
*@param parentIndex
要”下沉”的父节点
25.
*@param length
堆的有效大小
26.
*/
---
## Page 170
27. public static void downAdjust(int[] array, int parentIndex,
int length){
28.
//temp保存父节点值，用于最后的赋值
29.
int temp = array[parentIndex];
30.
int childIndex = 2* parentIndex+ 1;
31.
while (childIndex < length）{
32.
//如果有右孩子，且右孩子小于左孩子的值，则定位到右孩子
if (childIndex + 1< length && array[childIndex + 1
array[childIndex]）{
34.
childIndex++;
35.
36.
//如果父节点小于任何一个孩子的值，则直接跳出
37.
if (temp <= array[childIndex])
38.
break;
39.
//无须真正交换，单向赋值即可