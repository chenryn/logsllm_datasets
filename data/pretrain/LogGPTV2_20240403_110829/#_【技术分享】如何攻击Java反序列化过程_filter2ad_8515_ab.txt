为了利用反序列化漏洞，我们需要满足两个关键的要素：
我们需要一个入口点，通过这个入口点，我们可以将自定义的序列化对象发往目标来做反序列化处理。
我们可以通过反序列化过程操控的一个或多个代码片段。
**3.1 入口点**
为了识别入口点，我们可以查看应用的源代码，看哪里使用了“ **java.io.ObjectInputStream**
”这个类（特别是“readObject”这个方法），或者查看实现了“readObject”方法的那些可序列化的类。如果攻击者可以控制传递给ObjectInputStream的那些数据，那么这种数据也可以作为反序列化攻击的入口点。此外，如果我们无法获得Java源代码，我们可以查找存储在硬盘中的序列化数据，或者使用网络进行传输的序列化数据，只要我们知道具体要查找的内容即可。
Java序列化数据开头包含两字节的魔术数字，这两个字节始终为十六进制的0xAC ED。接下来是两字节的版本号。我只见到过版本号为5（0x00
05）的数据，但更早的版本可能也存在，并且未来可能会出现更高的版本号。这四个字节之后是一个或多个内容元素，每个内容元素的第一个字节应该在0x70到0x7E之间，用来标明内容元素的类型，以标识后续数据流所对应的具体结构。大家可以参考Oracle官方文档中关于对象序列化流协议的介绍来了解更多细节。
在识别Java序列化特征时，人们经常说要寻找4字节的特征序列： **0xAC ED 00 05**
，事实上某些IDS规则也是根据这个特征来识别此类攻击。在应邀对客户进行渗透测试时，我没有第一时间发现这四个特征字节，因为目标客户端应用在运行期间始终保持与服务端的连接，这四个特征字节只在序列化流刚创建时出现过一次。因此，IDS无法识别我的攻击行为，因为我的攻击payload没有在序列化流的头部出现，而是稍后才发送。
我们可以以ASCII形式导出数据，识别Java序列化数据，而无需依赖头部中的 **0xAC ED 00 05** 这四个特征字节。
Java序列化数据中最为明显的特征是导出数据中存在Java类名，比如“ **java.rmi.dgc.Lease**
”。在某些情况下，Java类名可能以另外一种形式出现，比如开头为“L”，结尾为“;”，并会使用斜杠来分隔命名空间以及类名（如“
**Ljava/rmi/dgc/VMID;**
”）。除了Java类名，根据序列化格式规范，还有其他一些常见的字符串可以作为特征字符串，比如“sr”可能代表某个对象（TCOBJECT），其后跟着对象的类描述（TCCLASSDESC），或者“xp”可能代表某个类的类注释的尾部（TCENDBLOCKDATA），这个类不存在对应的超类（TCNULL）。
识别出序列化数据后，我们需要识别数据中哪处偏移量能够注入我们的payload。目标需要调用“ObjectInputStream.readObject”才能反序列化及实例化某个对象（payload），也才能支持面向属性的编程，然而它可以先调用另一个ObjectInputStream方法，比如“readInt”，通过该方法从流中读取一个4字节长度的整数。readObject方法会从序列化流中读取以下内容类型：
    0x70 – TC_NULL
    0x71 – TC_REFERENCE
    0x72 – TC_CLASSDESC
    0x73 – TC_OBJECT
    0x74 – TC_STRING
    0x75 – TC_ARRAY
    0x76 – TC_CLASS
    0x7B – TC_EXCEPTION
    0x7C – TC_LONGSTRING
    0x7D – TC_PROXYCLASSDESC
    0x7E – TC_ENUM
在最简单的一种情况下，从序列化流中首先读取到的是一个对象，此时我们可以将payload直接插入4字节的序列化头部后面。我们可以检查序列化流的前5个字节，以识别这类场景。如果这5个字节的前4个字节为序列化头部（0xAC
ED 00 05），后面1个字节为上面列出的某个值，那么此时我们就可以在4字节序列化头部后发送我们的payload对象来攻击目标。
在其他情况下，4字节序列化头部后面最有可能跟着一个TCBLOCKDATA元素（0x77）或一个TCBLOCKDATALONG元素（0x7A）。前者由1个字节长的字段以及多个字节长的数据块构成，后者由4字节长的字段以及多个字节长的数据块构成。如果数据块后面跟着readObject支持的某个元素类型，那么我们就可以在数据块后面插入我们的攻击payload。
根据我在这一领域的研究成果，我编写了一个名为SerializationDumper的工具，利用这个工具，我们可以识别反序列化漏洞利用的入口点。这个工具可以解析Java序列化流，将序列化流以可视化的形式导出。如果数据流中包含readObject支持的某个元素类型，那么我们就可以使用某个payload对象来替换这一元素。工具的使用如下所示：
    $ java -jar SerializationDumper-v1.0.jar ACED00057708af743f8c1d120cb974000441424344 STREAM_MAGIC 
    - 0xac ed STREAM_VERSION 
    - 0x00 05 Contents TC_BLOCKDATA 
    - 0x77 Length - 8 
    - 0x08 Contents 
    - 0xaf743f8c1d120cb9 TC_STRING 
    - 0x74 newHandle 0x00 7e 00 00 Length - 4 
    - 0x00 04 Value - ABCD - 0x41424344
根据上面的输出结果，我们发现数据流中包含一个TCBLOCKDATA，后面跟着一个TCSTRING，我们可以将TC_STRING替换为我们的攻击payload。
序列化流中的对象在加载时会被实例化，而不是当整个流完成解析时才会被实例化。根据这个事实，我们可以将攻击payload注入到某个序列化流中，而不用考虑去矫正序列化流剩余的那些数据。当任何验证操作执行时，或者当程序尝试从序列化流中读取更多数据时，攻击payload的反序列化以及执行操作早已完成。
**3.2 POP利用点**
识别出入口点后，我们就可以提供自己构造的序列化对象，以供目标进行反序列化处理，接下来我们需要找到POP利用点。如果我们可以访问源代码，那么我们可以查找“readObject”方法，以及在调用“ObjectInputStream.readObject”之后的那些代码，以判断是否存在可利用的点。
通常情况下，我们无法访问应用程序的源代码，但这并不能阻止我们利用反序列化漏洞，因为有许多第三方库可以作为我们的攻击目标。比如Chris
Frohoff以及Gabriel
Lawrence等研究人员已经在许多库中发现了POP利用链，并且发布了一个名为“ysoserial”的工具，这个工具可以生成攻击payload。这个工具大大简化了Java反序列化漏洞的攻击过程。
ysoserial中还包括许多利用链，因此下一步我们需要探索哪些利用链可以用来攻击目标。首先我们应该探索目标应用使用了哪些第三方库，或者是否存在信息泄露问题。如果我们知道目标应用使用了哪些第三方库，那么我们就可以选择合适的ysoserial
payload来尝试攻击。不幸的是，这些信息没那么容易获取，这种情况下，我们可以小心地遍历ysoserial中各种利用链，直到我们找到可以利用的那个点。这一过程需要异常小心，因为我们可能会触发无法处理的异常点，导致目标应用崩溃。这种情况下，目标应用会变得极其不稳定，如果目标应用无法处理不在预期范围内的数据或者格式错误的数据，那么即使使用nmap来扫描目标应用的版本也可能导致目标崩溃。
如果使用某个ysoserial
payload时，目标应用的响应为“ClassNotFoundException”，这种情况下，很有可能我们选择的利用点不能用于目标应用。如果目标应用出现“java.io.IOException”，同时返回“Cannot
run program”信息，那么很有可能我们选择的利用链适用于目标应用，但尝试执行的命令无法在目标服务器上执行。
ysoserial命令执行payload属于盲payload（blind
payloads）类型，不会返回命令的输出结果。由于使用了“java.lang.Runtime.exec(String)”语句，因此还存在其他一些限制。首先是不支持shell操作符，如输出重定向以及管道。其次是传递给payload命令的参数中不能包含空格，比如，我们可以使用
    nc -lp 31313 -e /bin/sh
，但我们不能使用
    perl -e ‘use Socket;…'
，因为传递给perl的参数中包含空格。幸运的是，网上有一个非常好用的payload编码器/生成器，可以绕过这些限制，大家可以访问 来了解更多信息。
**四、亲自动手：DeserLab以及SerialBrute**
****
为了有效利用反序列化漏洞，理解序列化的原理以及反序列化漏洞利用的工作原理（如面向属性的编程原理）是非常重要的一件事情。与其他类型的漏洞相比，想做到这一点需要涉及许多方面的因素，因此找到一个可供练习的实验对象可以达到事半功倍的效果。除了发表这篇文章以外，我还发布了一个名为“DeserLab”的演示应用，该应用在Java序列化格式的基础上实现了一个自定义的网络协议。这个应用存在反序列化漏洞，大家可以根据本文介绍的技术来利用这个漏洞。
我编写了一个名为“SerialBrute”的工具，该工具由一对Python脚本构成，可以自动化使用ysoserial
payload来测试任何目标。第一个脚本为“SerialBrute.py”，可以重放TCP会话或者HTTP请求，并且能将payload注入到指定的位置；第二个脚本为“SrlBrt.py”，这是一个框架型脚本，在特殊情况下我们可以修改这一脚本来发送payload。这些脚本并没有考虑全部情况，因此需要谨慎使用，以免导致应用程序崩溃，但对我个人而言，我经常通过重放TCP会话，成功将ysoserial利用链注入目标应用中。
**五、总结**
****
感谢阅读本文。如果你对DeserLab感兴趣，欢迎多加使用。如果发现本文或我开发的工具中存在任何不足，需要进一步解释，欢迎通过推特向我反馈意见或者建议。