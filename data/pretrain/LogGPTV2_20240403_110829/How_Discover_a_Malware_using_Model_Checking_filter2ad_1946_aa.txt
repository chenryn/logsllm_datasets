title:How Discover a Malware using Model Checking
author:Fabio Martinelli and
Francesco Mercaldo and
Vittoria Nardone and
Antonella Santone
How Discover a Malware using Model Checking
Fabio Martinelli, Francesco Mercaldo
Institute for Informatics and Telematics (CNR)
National Research Council of Italy
Pisa, Italy
PI:EMAIL
Vittoria Nardone, Antonella Santone
Department of Engineering
University of Sannio
Benevento, Italy
{vnardone, santone}@unisannio.it
ABSTRACT
Android operating system is constantly overwhelmed by new so-
phisticated threats and new zero-day attacks. While aggressive
malware, for instance malicious behaviors able to cipher data ﬁles
or lock the GUI, are not worried to circumvention users by infec-
tion (that can try to disinfect the device), there exist malware with
the aim to perform malicious actions stealthy, i.e., trying to not
manifest their presence to the users. This kind of malware is less
recognizable, because users are not aware of their presence. In this
paper we propose FormalDroid, a tool able to detect silent mali-
cious beaviours and to localize the malicious payload in Android
application. Evaluating real-world malware samples we obtain an
accuracy equal to 0.94.
1.
INTRODUCTION
In recent years, more and more mobile devices are using An-
droid systems. As a result, the Android system becomes the major
attack target to the so-called smart platforms, as phone and wear-
able devices. Mobile malware has various spreading methods and
it is very able to hide itself. On the other hand, according to Antiy
security experts, more than 10% users do not even know that there
is phone malware, and more than 30% do not worry about phone
malware1.
Usually users are able to realize the infection of aggressive mal-
ware, for instance ransomware that locks the user interface and en-
crypts the data on the device [1]. Instead, the silent malware, typ-
ically able to send sensitive information and to generate network
trafﬁc, has as primary objective to be stealth. For this reason, users
do not notice if their device generates abnormal trafﬁc by sending
sensitive information or by click-jacking: this happens because the
every day user experience of the device is not signiﬁcantly differ-
ent. This type of malware is running for a long time without the
user’s awareness.
Users’ carelessness makes it much easier for malware to spread;
for this reason in the mobile malware landscape the ADRD malware
family, embodying these silent behaviors, was able to infect almost
a million users.
1http://www.antiy.net/media/reports/android_adrd_analysis.pdf
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
ASIA CCS ’17 April 02-06, 2017, Abu Dhabi, United Arab Emirates
c(cid:13) 2017 ACM. ISBN 978-1-4503-4944-4/17/04.
DOI: http://dx.doi.org/10.1145/3052973.3055157
In details, it can open several system services. It can also upload
infected phone information (i.e., IMEI, IMSI, and version) to the
control server every 6 hours and then it receives its commands. In
addition, it can obtain 30 URLs from the data server and access
them individually. Furthermore, it can download an installation
ﬁle (.apk) to a speciﬁed directory of the SD card. Infected phones
will generate lots of network trafﬁc and cause users a lot of extra
expenses.
ADRD needs to obtain the following system privileges: read the
contact data, fully access the Internet, modify/delete the contents
of the SD card, read and modify the call state, write the APN (Ac-
cess Point Name) settings, check the network and WiFi state and
auto-start. Once installed, ADRD executes itself if one of the fol-
lowing conditions is met: (i) 12 hours have passed since the OS
was started; (ii) a change in network connectivity; (iii) the device
lost ans reestablished connectivity to a network; (iv) the device re-
ceived a phone call. ADRD samples are also able to upload device-
speciﬁc information to remote servers using DES-encrypted com-
munication. Most interesting, the malware also received search pa-
rameters from a set of URLs; these parameters are used to silently
issue multiple HTTP search request. The purpose of these search
requests was to increase site rankings for a web site via fraudulent
clicks. ADRD represents the unique Android malware family in
using multiple infected devices to increase the site ranking for a
given web site: its main purpose is the search engine manipulation
and it focused on the search engine Baidu. This happens because
Baidu would pay the afﬁliate who brought them the search trafﬁc a
share of any revenue generated from clicks on the advertisements.
As explained, the ADRD malicious behaviors do not affect directly
the mobile user experience and for this reason the infection is not
easy to detect by the device end user and, unfortunately, the anti-
malware currently based on signatures are not effective in the fast
detection of new threats and zero-day attacks [2]. For these rea-
sons, in this paper we propose FormalDroid, a tool for the identiﬁ-
cation of stealth malicious behaviours in Android application. Our
tool is based on formal methods and it performs a static analysis,
i.e., it does not require the run of the application under analysis.
Our tool is not purely syntactic and it performs behavioural-based
analysis. This leads to a methodology that is also resistant to com-
mon obfuscations used by hackers. We experiment FormalDroid
on the malicious samples belonging to ADRD family, an in the wild
widespread family that exhibits stealth malicious payload, obtain-
ing encouraging results.
The paper proceeds as follows: Section 2 explains our tool, Sec-
tion 3 discusses the evaluation, ﬁnally, conclusions are drawn in
Section 4.
2. THE FORMALDROID APPROACH
902• C6: is the tool scalable?
• C7: does the tool detects Android Native Code?
Table 1: Family Android Malware detection tools.
TOOL
DroidLegacy [6]
Dendroid [7]
Apposcopy [8]
Canfora et al. [9]
DroidClone [10]
FormalDroid l
C1 C2 C3 C4 C5 C6 C7










   

  


 

   
 


  








Figure 1: The FormalDroid Workﬂow.
2. THE FORMALDROID APPROACH
A tool for the detection of malware family has been implemented.
Figure 1 shows the FormalDroid workﬂow, basically based on two
main steps. The ﬁrst step generates a Calculus of Communicat-
ing Systems (CCS) [3] speciﬁcation starting from .class ﬁles writ-
ten in Java Bytecode extracted by Android Dalvik Executable us-
ing the dex2jar tool. The Milner’s CCS is one of the most well
known process algebras and it is largely used for modeling com-
plex systems. We deﬁne a Java Bytecode-to-CCS transformation
function. This is deﬁned for each instruction of the Java Bytecode.
It directly translates the Java Bytecode instructions into CCS pro-
cess speciﬁcations. The second step aims to investigate malicious
ADRD family behaviours which are successively expressed using
mu-calculus logic [4], which is a branching temporal logic. Start-
ing from current literature and with the manual inspection of few
samples we specify the set of properties. The CCS processes ob-
tained in the ﬁrst step are then used to verify the properties. Codes
described as CCS processes are ﬁrst mapped to labelled transition
systems and a model checker is used. In our approach, we invoke
the Concurrency Workbench of New Century (CWB-NC) [5] as
formal veriﬁcation environment. When the result of the CWB-NC
model checker is true, we consider that the sample under analy-
sis belonging to the ADRD family, otherwise the sample cannot be
recognized as belonging to the ADRD family. We formulated logic
rules from following characterizing ADRD behaviours: (i) informa-
tion gathering as: device id, operator name, device model, latitude,
longitude, IMSI and IMEI and (ii) opening multiple connections to
HTTP addresses.
In order to highlight the novelty of FormalDroid we compare
our tool only with other static tools. Moreover, there are plenty