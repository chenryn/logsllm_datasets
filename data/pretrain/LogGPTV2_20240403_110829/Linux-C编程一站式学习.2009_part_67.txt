size=
Linux
 115
 1024 blocks
 akaedu akaedu 
 3 akaedu akaedu 
1024
 akaedu akaedu 
akaedu
 reserved for the super user
(log=0)
个
 (输入y回车)
akaedu
所以用1s-1看它们的属性是一模一样的，因为都是从这
，每次拷多少字节。
目录b的硬链接数是2，这两个名字分别是a目录下的b和b目录
device.
4096
4096 2008-10-25
12288
 4096 2008-10-25 16:15
。目录a的硬链接数是3，
 2008-10-25 
，而dd命令可以把一个文件的一部分拷贝成另
，它没有磁盘数据块，
16:15
16:15
，不管从哪里开始读，读出来的
 这3个名字分别是当前目
 对它进行读操作传给设
为了方便实验，我们把
录
录
---
## Page 548
查看这个分区的超级块和块组描述符表中的信息：
现在fs的大小仍然是1MB，
入y回车完成格式化。
格式化-
，mke2fs认为用户有可能是误操作了，
一个真正的分区应该指定块设备文件名，
Group 0:
Directory
Default dire
Re
2
La
Filesystem
Fragment size:
In
R
Default mount options:
Re
一
.
File
Fil
Filesystem
Inod
S
ast checked:
Free
Free blocks:
Primary
irst
neck 
eserved GDT 
eserved
lock
rrors behavior:
ilesystem
i1
Reserved GDT blocks 
extchec
unt
ast
lock
ree blocks:
node
dumpe2fs fs
od
t
Lesystem
.esystem
lesystem
write
mount
inodes
size
intel
size:
 count:
inc
count:
 inodes:
lode:
ck
d block count:
(Blocks,
`superblock at
Hash
?
rval:
flags:
n magic number:
oc
 after:
time:
 created:
 group:
OS
 features:
revision #:
UUID:
per group:
 blocks:
 type:
count:
12-128
1-1023)
(12-Jul-2007)
但不再是全0了
：
：
3
fre
ee
Inode bitmap at 7 (+6)
Fri Jun
Sun Dec 16 14:56:59 2007
6.
155520
s
C
5
Continue
clean
signed
Group descriptors at 2-2
1
00
Sun Dec 16 14:56:59 2007
L
(none)
0xEF53
inodes, 2 directories
0
8
p
L
(dynamic)
其中已经有了块组和描述信息。用dumpe2fs工具可以
000
所以给出提示，要求确认是否真的要格式化，输
 directory 
1 13 14:56:59 2008
: 16 14:56:59 2007
例如/dev/sdal,
(6 months)
hash
而这个fs是常规文件而不是块设
to override.
---
## Page 549
从000400到0007f的1KB是超级块，对照着dumpe2fs的输出信息，
从000000开始的1KB是启动块，由于这不是一个真正的磁盘分区，
其中以*开头的行表示这一段数据全是零因此省略了。下面详细分析oa输出的信息。
较，就可以很好地理解文件系统的存储布局了。
现在我们用二进制查看工具查看这个文件系统的所有字节，并且同dumpe2fs工具的输出信息相比
下面的步骤时结果可能和我写的不太一样，不过也不影响理解。
注意,
来，以确保所有的改动都保存到文件中了。
现在可以在/mnt目录下添加删除文件，
的.和..都表示根目录本身。lost+found目录由e2fsck工具使用,
当作分区格式来解释。文件系统格式化之后在根目录下自动生成三个子目
用常规文件制作而成的文件系统也可以像磁盘分区一样mount到某个目录，例如：
出吻合。
块。块位图占一个块，
动块，
根据上面讲过的知识简单计算一下，
了。默认是每8KB分配一个inode，
图 29.3.超级块
下面的实验步骤是对新创建的文件系统做的，
 apout xog syoota 9t :os 'yootq iad sapout 8 'dnoxb iad sapout 8z1!
0〇00０0０0０0０0０0０0０0０0０0０0０0０0０0０0０○○○○0
$ sudo umount /mnt
drwx------
drwxr-xr-x
S
table
cd /mnt/
sudo mount -o loop fs /mnt
LS
Z
3 akaedu akaedu
共有1024x8=8192个bit，
2
root
root
root
，块大小是1024字节，1MB的分区共有1024个块，
，这些操作会自动保存到文件fs中。然后把这个分区umount下
1024.2008-10-25 12:20
12288 2008-10-25
4096
足够表示这1023个块了
2008-08-18
 如果你在文件系统中添加删除过文件，跟着做
..表示上一级目录，
 如果在检查磁盘时发现错误,
08:54
详细分析如下：
，启动块的内容全部为零。
因此只要一个块组就够
而根目录
共1023个
，第0个块是启
549
就
---
## Page 550
信息分析如下：
从000800开始是块组描述符表，
址，存低字节。各字段的位置、长度和含义详见[ULK]。
中各字段都是按小端存储的，
超级块中从0004d0到末尾的204个字节是填充字节，
图 29.4.块组描述符
0004c0（
*
000480
000470
0004600200000001000000
000440
000430
000420
000410
00000P00000000000000000000800000
.......
Free inodes: 12-128
Inode
table
00000000000000000000000：00000000
一
002000000
2007-12-16 14:56:59
2007-12-16 14:56:59
: blocks,
free inodes=117
inodecount=128
8-23
，如果把字节在文件中的位置看作地址，那么靠近文件开头的是低地
64
last mounted on
9
117
，这个文件系统较小，只有一个块组描述符，对照着dumpe2fs的输出
47
（+5）
at
UUID
free inodes, 2 directories
(+7)
block count=1024
Inode bitmap at 7 (+6)
Group descriptors at 2-2
=0
6months
first block=1
inode=11
t m1a8 mOunt
/group=8192
count=30
00
，保留未用，
40000000000000000
bp6
00000000000000000
8e 1f 3b7a 4d 1f 41 dc
53ef
algorithm usage bitmap prealloc
size=128
reserved block count=51
magic#
OS type=Linux
上图未画出。注意，ext2文件系统
group#=0
last mounted on
volumn name
UUID
compatiblefeatures
majorrev #=1
free blocks=986
padding
---
## Page 551
符下输入help看看它都能做哪些事情：
探索文件系统还有一
第11个inode是1ost+found目录，块组描述符也指出该组有两个目录，就是根目录和1ost+found 。
的11个inode中，
001c00这一行的128位就表示了所有inode，
以后随着文件系统的使用和添加删除文件，inode位图中的1就变得不连续了。
示前11个inode已用：
块组描述符指出,
续了。
按从低位到高位的顺序来看。以后随着文件系统的使用和添加删除文件，块位图中的1就变得不连
来的位已经超出了文件系统的空间，
建的，空闲块是连续的Block 38-1023，
作
从Block 24开始就是数据块了。块组描述符中指出，
是Block 8-23。
出，inode位图是Block7，inode表是从Block 8开始的，那么inode表到哪个块结束呢？由于超级块
是Block 6，
为1-1023，
整个文件系统是1MB,
（前4个字节加最后一个字节的低5位）都是1，就表示Block1-37已用：
，例如查看信息、
debugfs: 
debugfs
000100
0818888888888888886
001c10
001810
因此中间的Block 2-5是块组描述符表，
它们全都属于Group O。
，前10个inode是被ext2文件系统保留的，
000000000000000000000000000000
2directories
空闲的inode有117个,
help
 恢复数据、修正文件系统中的错误。
一个很有用的工具debugfs，
Blockbitmap at:6
 每个块是1KB，
0
ff
 不管是0还是1都没有意义。
其中.
，应该有1024个块，除去启动块还有1023个块，
Inodebitmap at:7
，用掉了前面的Block 24-37。
80
由于文件系统是新创建的，
 Block 1是超级块，接下来的块组描述符指出，
，因此下面的行不管是0还是1都没有意义。已用
0
，它提供一个命令行界面，可以对文件系统做各种操
，空闲的数据块有986个，
，其中Block 3-5保留未用。块组描述符还指 
ff
padding
下面用debugfs打开fs文件，然后在提示
 其中第2个inode是根目录，
Inode table at:8
，可见，
 空闲的inode也是连续
从块位图中可以看出，前37位
H8
，块位图每个字节中的位应
00
由于文件系统是新创
=986
 分别编号
=117
块位图
8
接
该
---
## Page 552
把以上信息和od命令的输出对照起来分析：
按q退出这一屏，然后用quit命令退出debugfs：
出中找到006000地址，它的格式是这样：
的Blocks[0]指出，也就是第24个块，它在文件系统中的位置是24x0x400=0x6000，从od命令的输
据块。Links为3表示根目录有三个硬链接，
种文件类型的编码详见stat(2)）
在debugfs的提示符下输入stat／命令，这时在新的一屏中显示根目录的inode信息：
以Blockcount是磁盘的物理块数量，
时所指定的块大小,
注意，
图 29.6.根目录的数据块
00200000000000000000000
0020a0
002090
图29.5.根目录的inode
debugfs: 
BLOCKS:
atime:
ctime:
User:
Inode: 2
 虽然我们通常用/表示根目录，但是并没有名为/的硬链接，
0x4764cc3b
0x4764cc3b :
0x4764cc3b
1000
0000008000000000000
3b cc 6447
磁盘的最小读写单位称为扇区（Sector）
quit
Type: directory
Flags=0
Blocks[2]
 Group:．1000
mtime
User=1000
 e8 03 00 04 00 00 3b cc 64 47 3b cc 64 47
SS:
，包含了文件类型和文件权限，
Sun
 Sun
，而非分区的逻辑块数量。根目录数据块的位置由上图中
Dec
 Number: 0
 Dec
OSInformation
Dec
Size=1024
，分别是根目录下的.和...
Blocks[3]
 Size: 1024
dtime
Mode:
691891
14:56:59
0755
Group=1000