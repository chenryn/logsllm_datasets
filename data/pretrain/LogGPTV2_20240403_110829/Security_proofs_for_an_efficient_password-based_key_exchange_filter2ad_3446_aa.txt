title:Security proofs for an efficient password-based key exchange
author:Emmanuel Bresson and
Olivier Chevassut and
David Pointcheval
for an Efﬁcient Password-Based Key Exchange
Security Proofs
[Extended Abstract]
∗
Emmanuel Bresson
D´ept Cryptologie, CELAR
35174 Bruz Cedex, France
Olivier Chevassut
Ernest Orlando Lawrence
Berkeley National Laboratory
Berkeley, CA 94720, USA
David Pointcheval
CNRS– ´Ecole normale
sup´erieure
75230 Paris Cedex 05, France
ABSTRACT
Password-based key exchange schemes are designed to pro-
vide entities communicating over a public network, and shar-
ing a (short) password only, with a session key (e.g, the key
is used for data integrity and/or conﬁdentiality). The fo-
cus of the present paper is on the analysis of very eﬃcient
schemes that have been proposed to the IEEE P1363 Stan-
dard working group on password-based authenticated key-
exchange methods, but which actual security was an open
problem. We analyze the AuthA key exchange scheme and
give a complete proof of its security. Our analysis shows that
the AuthA protocol and its multiple modes of operations are
provably secure under the computational Diﬃe-Hellman in-
tractability assumption, in both the random-oracle and the
ideal-ciphers models.
Categories and Subject Descriptors
H.4.3 [Information Systems Applications]: Communi-
cations Applications
General Terms
Security, Algorithms, Design, Standardization.
Keywords
Key Exchange, Password-Based Authentication.
INTRODUCTION
1.
Problem. The need for secure authentication seems obvious
when two entities—a client and a server—communicate on
the wired-Internet, but proving an identity over a public link
is complex. The method deployed by the engineers of the Se-
cure Shell protocol (SSH) [2] to determine a client’s identity
∗
this paper
http://www.di.ens.fr/users/pointche
A full version [13] of
is available at
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’03, October 27–31, 2003, Washington, DC, USA.
Copyright 2003 ACM 1-58113-738-9/03/0010 ...$5.00.
to log him/her into another computer, execute commands
in a remote machine, and move ﬁles from one machine to
another is to ask him to type-in a password. The remote
machine maintains the association between the client name
and the password. Another method is to take advantage
of a public-key infrastructure (PKI) to check that an entity
knows the secret-key corresponding to the public-key em-
bedded in a certiﬁcate. This method was adopted by the
IETF TLS Working Group to secure the traﬃc between a
web browser and a bank server over the wired-Internet, but
work is currently under way to enrich this “transport layer”
security protocol (TLS) with password-based authentication
methods [19].
The primary raison d’ˆetre for password-based authenti-
cation is to enable clients to identify themselves to servers
through a lightweight process since no special hardwares to
carry the passwords or security infrastructures are required.
One example is when a password is used as a means to es-
tablish a secure communication channel from the computing
device a human relies on to the remote machine he wants
to talk to. This process, or password-authenticated key-
exchange as it is often termed [6, 7, 22], provides the two
computing devices with a session key to implement an au-
thenticated communication channel within which messages
set over the wire are cryptographically protected. Humans
directly beneﬁt from this approach since they only need to
remember a low-quality string (i.e. 4 decimal digits) chosen
from a relatively small dictionary rather than a high-quality
symmetric encryption key.
The fundamental security goal for password-authenticated
key exchange protocol to achieve is security against dictio-
nary attacks. One can not actually prevent the adversary
from guessing a value for the password and using this value
in an attempt to impersonate a player. If the attack fails,
the adversary can eliminate this value from the list of pos-
sible passwords. However, one would like this attack to be
the only one the adversary can mount: after n active in-
teractions with some participants the adversary should not
be able to eliminate a greater number of passwords than
n. Namely, a passive eavesdropping should be of no help
to the adversary since an oﬀ-line exhaustive search on the
password should not get any bias on the actual password.
The oﬀ-line exhaustive search is called dictionary attack.
The need for lightweight authentication processes is even
greater in the case of the wireless-Internet. Wireless nodes
are devices with particular mobility, computation and band-
width requirements (diskless base station, cellular phone,
241pocket PC, palm pilot, laptop computer, base station gate-
way) that place severe restrictions when designing crypto-
graphic mechanisms. The TLS protocol has been enriched
with elliptic-curve cipher suites to run on low-power de-
vices [8] and has within the WAP Forum evolved into a
“transport layer” security protocol to secure mobile-comm-
erce (WTLS) [23]. The Wired Equivalent Privacy (WEP)
protocol, which is part of the IEEE 802.11 standard, does
relies on high-quality symmetric encryption keys for protect-
ing the wireless local-area network (WLAN) traﬃc between
a mobile device equipped with a wireless ethernet-card and
a ﬁxed access point, but the WEP does not specify how the
keys are established [9]. Currently, the IEEE 802.11 stan-
dard does not specify any method for key exchange.
Contributions. This paper examines the security of the
AuthA password-authenticated key exchange protocol pro-
posed to the IEEE P1363 Study Group on standard spec-
iﬁcations for public-key cryptography [21]. Although Au-
thA has been conjectured cryptographically secure by its
it has still not been proven to resist dictionary
authors,
attacks [4].
In this paper we provide a complete proof of
security for the AuthA protocol. We work out our proofs
by ﬁrst deﬁning the execution of AuthA in the communica-
tion model of Bellare et al. [3] and then adapting the proof
techniques recently published by Bresson et al. [12] for the
password-based group key exchange.
We have deﬁned the execution of AuthA in Bellare et al.’s
model wherein the protocol entities are modeled through
oracles, and the various types of attacks are modeled by
queries to these oracles. This model enables a treatment of
dictionary attacks by allowing the adversary to obtain hon-
est executions of the AuthA protocol. The security of AuthA
against dictionary attacks depends on how many interac-
tions the adversary carries out against the protocol entities
rather than on the adversary’s computational power. Our
analysis shows that some of the AuthA modes of operation
achieve provable security against dictionary attacks in both
the random oracle and ideal-cipher models [3, 5] under the
computational Diﬃe-Hellman intractability assumption.
Related Work. The IEEE P1363 Standard working group
on password-based authenticated key-exchange methods [22]
has been focusing on key exchange protocols wherein clients
use short passwords in place of certiﬁcates to identify them-
selves to servers. This standardization eﬀort has its roots in
the works of Bellare et al. [3] and Boyko et al. [11], wherein
formal models and security goals for password-based key
agreement were ﬁrst formulated. Bellare et al. analyzed the
EKE protocol [6] (where EKE stands for Encrypted Key Ex-
change), a classical Diﬃe-Hellman key exchange wherein the
two ﬂows are encrypted using the password as common sym-
metric key. While they announced a security result of this
“elegant” and eﬃcient structure in both the random oracle
and ideal-cipher models, the full proof never appeared any-
where. On the other hand, Boyko et al. [11] provided such a
proof, but it was in another security model, the multi-party
simulatability model. We thus provide a complete proof in
the Bellare et al. security model, in a model where both a
random oracle and an ideal-cipher are available.
One should note that Boyko et al.’s security result [11]
holds in the random oracle model, while Bellare et al.’s
one [3] holds in both the random oracle model and the ideal-
cipher one together. More recent works provided password-
based schemes which security holds in the sole standard
model [16, 17, 18]. There are either based on general com-
putational assumptions, or on the Decisional Diﬃe-Hellman
problem (using a variant of the Cramer-Shoup encryption
scheme [15].) While relying on a strong computational as-
sumption, they are neither practical nor very eﬃcient.
These provably secure schemes in the standard model are
from a theoretical point of view very interesting, but fails to
be practical. Ideal models (i.e. random-oracle, ideal-cipher)
have thus been deﬁned to provide alternative security re-
sults. While not being formal proofs, they give strong evi-
dences that the schemes are not ﬂawed. They often rely on
weaker computational assumptions (e.g. the computational
Diﬃe-Hellman problem instead of the decisional one.)
More interestingly, EKE later evolved into the proposal
AuthA [4], which is formally modeled by the One-Encryption
Key-Exchange (OEKE) in the present paper: only one ﬂow is
encrypted (using either a symmetric-encryption primitive or
a multiplicative function as the product of a Diﬃe-Hellman
value with a hash of the password). The advantage of such
a scheme over the classical EKE, wherein the two Diﬃe-
Hellman values are encrypted,
is its easyness of integra-
tion. An OEKE cipher enables to avoid many compatibility
problems when adding password-based capabilities to exist-
ing network security protocols since the initial messages of
the security protocols do not need to be modiﬁed. This
argument in favor of OEKE was put forward when discus-
sions were under way to enrich the Transport Layer Security
(TLS) protocol with password-based key-exchange cipher
suites [19, 20].
In a TLS One-Encryption Key-Exchange
initiated by the server, the server does not need to know the
client’s name (a name is mapped to a password by the server
using a local database) to compute and send out the server’s
TLS key-exchange message, but does need it to process the
incoming client’s TLS key-exchange message. Therefore, en-
gineers embodied the client’s name in the client’s TLS key-
exchange message rather than embodying it in the client’s
TLS hello message [19]. OEKE is thus of great practical in-
terest, but none of the previous security analyses ever dealt
with it.
Our paper is organized as follows. In Section 2, we recall
the model and the deﬁnitions that should be satisﬁed by
a password-based key exchange protocol. In Section 3, we
show that OEKE, a “simpliﬁed” variant of a AuthA mode of
operation, is secure. In Section 4, we build on this result to
show that some of the AuthA modes of operation proposed
to the IEEE P1363 Study Group are secure.
2. MODEL
In this section we recall the formal model for security
against dictionary attacks where the adversary’s capabili-
ties are modeled through queries. In this model, the players
do not deviate from the protocol and the adversary is not a
player, but does control all the network communications.
2.1 Security Model
Players. We denote a server S and a user, or client, U
that can participate in the key exchange protocol P . Each
of them may have several instances called oracles involved
in distinct, possibly concurrent, executions of P . We denote
client instances and server instances by U i and Sj (or by I
when we consider any kind of instance).
The client and the server share a low-entropy secret pw
which is (uniformly) drawn from a small dictionary Password
of size N . The assumption of the uniform distribution for
the password is just to make notations simpler, but every-
thing would work with any other distribution, replacing the
probability q/N by the sum of the probabilities of the q most
probable passwords.
Abstract Interface. The protocol AuthA consists of the
following algorithm:
• The key exchange algorithm KeyExch(U i, Sj ) is an
interactive protocol between U i and Sj that provides
the instances of U and S with a session key sk.
Queries. The adversary A interacts with the participants
by making various queries. Let us explain the capability
that each query captures:
• Execute(U i, Sj ): This query models passive attacks,
where the adversary gets access to honest executions
of P between U i and Sj by eavesdropping.
• Reveal(I): This query models the misuse of the session
key by instance I. The query is only available to A if
the targetted instance actually “holds” a session key
and it releases sk to A.
• Send(I, m): This query models A sending a message to
instance I. The adversary A gets back the response I
generates in processing the message m according to the
protocol P . A query Send(U i, Start) initializes the key
exchange algorithm, and thus the adversary receives
the ﬂow the client should send out to the server.
The Execute-query may at ﬁrst seem useless since using
the Send-query the adversary has the ability to carry out
honest executions of P among parties. Yet the Execute-
query is essential for properly dealing with dictionary at-
tacks. The number qs of Send-queries directly asked by the
adversary does not take into account the number of Exe-
cute-queries. Therefore, qs represents the number of ﬂows
the adversary may have built by itself, and thus the number
of passwords it would have tried.
2.2 Security Notions
Freshness. The freshness notion captures the intuitive fact
that a session key is not “obviously” known to the adver-
sary. An instance is said to be Fresh in the current protocol
execution if the instance has accepted and neither it nor the
other instance with the same session tag have been asked
for a Reveal-query.
The Test-query. The semantic security of the session key
is modeled by an additional query Test(I). The Test-query
can be asked at most once by the adversary A and is only
available to A if the attacked instance I is Fresh. This
query is answered as follows: one ﬂips a (private) coin b and
forwards sk (the value Reveal(I) would output) if b = 1, or
a random value if b = 0.
AKE Security. The security notions take place in the con-
text of executing P in the presence of the adversary A. The
game Gameake(A, P ) is initialized by drawing a password
pw from Password, providing coin tosses to A, all oracles,
and then running the adversary by letting it asking a poly-
nomial number of queries as described above. At the end of
the game, A outputs its guess b
for the bit b involved in the
Test-query.
(cid:1)
(cid:1)
We denote the AKE advantage as the probability that
A correctly guesses the value of b; more precisely we deﬁne
] − 1, where the probability space