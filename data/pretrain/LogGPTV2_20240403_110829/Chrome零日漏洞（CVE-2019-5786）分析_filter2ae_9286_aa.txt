# Chrome零日漏洞（CVE-2019-5786）分析
##### 译文声明
本文是翻译文章，文章原作者 securingtomorrow.mcafee.com，文章来源：securingtomorrow.mcafee.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
## 1．介绍
3月1日，谷歌发布[安全公告](https://chromereleases.googleblog.com/2019/03/stable-channel-update-for-desktop.html)， 指出chrome浏览器的实现过程FileReader API存在一个use-after-free漏洞。根据谷歌威胁分析小组的[报告](https://security.googleblog.com/2019/03/disclosing-vulnerabilities-to-protect.html)，该漏洞已在野外利用，针对目标是32位的window7操作系统，漏洞利用主要分为两部分，一是在Renderer（浏览器渲染进程）进程中执行代码，二是用于完全接管破坏目标主机系统。本文是一篇技术文章，主要聚焦于该漏洞利用的第一个部分，即如何在Renderer进程中实现代码执行，并通过研究分析发现更多的技术信息。
在本文攥写时，[谷歌漏洞报告](https://bugs.chromium.org/p/chromium/issues/detail?id=936448)尚未公开。缺省安装情况，Chrome会自动更新补丁，目前最新版本的Chrome已不受该漏洞影响。请确保您的Chrome处于安全状态，可通过chrome://version命令查询，查看Chrome版本是否已是72.0.3626.121或更高版本。
## 2\. 信息收集
### 2.1 漏洞修复
大多数的Chrome代码库都基于Chromium开源项目。由于漏洞代码包含在开源代码中，因此我们可以更直接的查看更新补丁对FileReader
API做了哪些修复动作。此外，谷歌分享了其修复版本的更新日志为我们的分析工作提供了更大的便利。
我们看到更新文件中只有一个与FileReader API相关，并带有以下消息内容：
该消息暗示对同一个底层ArrayBuffer多次引用是一件非常糟糕的事情。虽然目前尚不清楚段话意味着什么，下面的工作将致力于寻找隐藏于该条信息之下的真实细节。
首先，我们可以比较[GitHub](https://github.com/chromium/chromium/commit/ba9748e78ec7e9c0d594e7edf7b2c07ea2a90449)上新旧两个版本的差异。，看看其中到底发生了哪些变化。为了便于阅读，下面展示的是补丁前后两个版本差异的具体情况。
[修复前老版本](https://github.com/chromium/chromium/blob/17cc212565230c962c1f5d036bab27fe800909f9/third_party/blink/renderer/core/fileapi/file_reader_loader.cc)：
[补丁后新版本](https://github.com/chromium/chromium/blob/75ab588a6055a19d23564ef27532349797ad454d/third_party/blink/renderer/core/fileapi/file_reader_loader.cc)：
这两个版本在GitHub上都可以找到。从图中我们可以看出，主要对ArrayBufferResult函数进行了修复。ArrayBufferResult函数在用户调用访问FileReader.result时用于响应并返回数据。
上图中，我们可以看到前后版本不同就在于对DOMArrayBuffer对象是如何处理的。在新版本中，增加了对数据尚未加载完成（finished_loading_标志）情况下对DOMArrayBuffer对象的处理。在老版本中，如果数据尚未加载完成的情况下，ArrayBufferResult函数直接调用DOMArrayBuffer::Create(raw_data_->ToArrayBuffer())函数并返回结果，在新版本中，则是调用DOMArrayBuffer::Create(ArrayBuffer::Create(raw_data_->Data(),raw_data_->ByteLength()))函数并返回结果。
我们来看补丁后的版本，因为该版本更容易理解。新版本中，DOMArrayBuffer::Create参数中包含了一个ArrayBuffer::Create函数调用。该函数包含两个参数，一个是指向数据的指针类型，一个是数据的长度（该函数在/third_party/blink/renderer/platform/wtf/typed_arrays/array_buffer.h文件中定义）。
函数定义如下图：
函数主要创建一个新的ArrayBuffer对象，将其置于scoped_refptr中并将数据复制到其中。[scoped_refptr](https://www.chromium.org/developers/smart-pointer-guidelines)在Chromium项目中用于处理引用计数，也就是跟踪一个对象被引用了多少次。当创建一个新的scoped_refptr实例，底层目标对象的引用次数会递增。当该对象退出时，该计数会递减。当引用数目为0的时候，该对象将被删除（好玩的是，当引用计数溢出后，Chrome将终止进程）。
老版本代码中则没有调用ArrayBuffer::Create，而是调用ArrayBufferBuilder::ToArrayBuffer函数并返回值。（该函数在third_party/blink/renderer/platform/wtf/typed_arrays/array_buffer_builder.cc中定义）
函数定义如下：
我们可以看到，在这可能还存在另外一个问题。根据bytes_used_值，函数将返回buffer_自身，或者只是buffer_的一部分。（即一个较小空间的ArrayBuffer，其内包含一份数据副本）
到目前为止，我们看到的所有修复的代码中，都是直接返回数据副本，而不是返回实际缓冲区地址。除非是在运行老版本代码，并且我们试图访问的缓冲区是处于“完全占用”的状态的情况下。
但是，在FileReaderLoader对象的实现过程，buffer_->ByteLength()获取的是预先分配的缓冲区大小，它对应于我们要加载的数据的大小（稍后将会相关）。
目前看来，在finished_loading标志被设置为true之前，且在数据已经完全加载之后，多次访问调用ArrayBufferBuilder::ToArrayBuffer()函数，将是利用该漏洞的唯一条件，这个时间点是漏洞触发的最佳交换时期。
为了总结代码检查这一部分，我们在看一下新老版本中都会调用的DOMArrayBuffer::Create函数，让我们感兴趣的是DOMArrayBuffer::Create(raw_data_->ToArrayBuffer())这个函数调用。该函数定义在third_party/blink/renderer/core/typed_arrays/dom_array_buffer.h头文件中。
定义如下图：
有趣的是，它调用了std::move，该函数具有所有权转换的语义。
例如，在以下代码中：
std::move函数调用后，‘b’取得属于‘a’的所有权（‘b’现在包含的内容是“hello”），而‘a’现在处于某种未定义的状态（C++
11规范以更精确的术语解释）。
当前情况下，有些事情令人感到困惑,具体请查看[链接1](https://chromium.googlesource.com/chromium/src/+/lkgr/styleguide/c++/c++.md#object-ownership-and-calling-conventions)和[链接2](https://www.chromium.org/rvalue-references)。ArrayBufferBuilder::ToArrayBuffer()返回的对象已经是一个scoped_refptr。我相信，当调用ToArrayBuffer()函数时，ArrayBuffer的引用计数将增加1，然后std::move函数又获取该引用对象实例的所有权（而非ArrayBufferBuilder拥有那个对象）。调用10次ToArrayBuffer()函数，引用计数将增加10，但所有的返回值将是有效的（与前面提到的‘a’,‘b’的例子不同，该例子中‘a’将导致无法预期的行为发生）。
如果在上面描述的最佳交换期间我们多次调用ToArrayBuffer()函数，这将会触发生成一个明显的use-after-free漏洞，ArrayBufferBuilder对象中的buffer_对象将被破坏。
### 2.2 FileReader API
我们也可以通过查看JavaScript中的API调用，看我们能否找到另一个方法找到我们所要寻找的漏洞触发的最佳交换时期。
在[Mozilla Web](https://developer.mozilla.org/en-US/docs/Web/API/FileReader)文档中，我们能获取所有的信息。其实，操作十分简单，我们可以在Blob对象或文件对象中调用诸如readAsXXX的函数，其后我们可以中断读取操作，此外，还有几个事件我们可以注册回调函数（比如onloadstart、onprogress,、onloadend
…等）。
其中onprogress处理事件听起来是最有趣的一个，它是在数据正在加载并加载完成之前被调用。如果我们查看FileReader.cc源文件，我们可以看到该事件背后的逻辑，在收到数据时，每隔50毫秒（或更长）该事件触发一次。下面，让我们来看看在一个真实的系统中它时如何表现的…
## 3\. web浏览器环境测试
### 3.1 准备工作
我们要做的第一件事是下载存在漏洞的代码版本。有一些非常有用的网络资源，在[那里](https://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html?prefix=Win_x64/612439/)我们可以获取老的版本，而无需自己再去重新编译源码获得。
资源如下图所示。
值得注意的是，图中资源还包含了一个文件名称包含‘syms’字符串的zip文件，内含.pdb调试符号文件，你可以直接导入到各调试器和反汇编软件，有助于更易分析。
### 3.2 调试器附加
Chromium是一个复杂的、支持多进程通信的软件，对其调试比较困难。最有效的调试方法是正常启动Chromium，然后将调试器附加到你要进行漏洞测试的那个进程中。我们要调试的代码运行在renderer进程中，并且关注的函数是由chrome_child.dll导出的（这些信息通过反复实验发现，比如附加到Chrome每个进程，寻找感兴趣的函数名等）
如果要在x64dbg中导入调试符号，一个可行的方法是在Symbol栏，右键选中要导入调式符号的.dll或.exe，然后选择下载调试符号。如果没有正确设置调试符号下载服务器，可能会失败，但是它仍将在x64dbg的‘symbols’目录下创建相应的目录结构，你也可以在该目录下直接放置之前已下载的.pdb文件。