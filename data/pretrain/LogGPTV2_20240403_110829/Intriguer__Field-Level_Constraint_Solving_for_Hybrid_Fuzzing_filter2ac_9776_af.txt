maximally reduced: the execution time decreased by at most 82%
(avconv) and at least 45% (ffmpeg). Interestingly, ffmpeg showed
a relatively small percentage of reduction in execution traces (20%
in ffmpeg and 51% in the third lowest objdump), but more rapid
reduction in execution time (similar rates to objdump). We observe
that ffmpeg more frequently used encoding/decoding operations
accessing a wide range of input offsets than objdump, and related
complex constraints were successfully removed.
To find out if trace reduction is effective and bugs are not missed
by the reduction of important traces, we performed 24h fuzzing
with and without trace reduction. In Table 13, we observe that
fuzzing with trace reduction found significantly more branches
and more bugs than fuzzing without trace reduction, except for
tiff2pdf. Regarding false negatives, our experiments showed that
there was no bug missed by using trace reduction in all programs;
and instead newer test cases and more bugs were found within the
same amount of time.
Based on the observation from Table 12 and 13, we see that
Intriguer successfully reduces execution time with a small
false negative. These observations allow us to positively an-
swer RQ3.
5.5 RQ4: Field Transition Tree
Intriguer performs field-level constraint solving by constructing a
field transition tree from the FL for each inferred field. To evaluate
the effectiveness of constructing the field transition trees, we per-
formed fuzz testing by dividing two cases of constraint generation,
(a) time
(b) queries
Figure 11: Field-level constraint solving done in a single execution
of Intriguer by directly feeding a seed file, with/without field transi-
tion trees. (a) Time taken for field-level constraint solving. (b) Num-
ber of queries used. In each bar, the shaded part is arithmetic con-
straints, and the solid part is branch constraints, showing that the
branch constraints are more reduced with field transition trees.
with and without constructing the trees. Note that in the latter case,
the node’s Value checking step of the tree construction phase is
unavailable, making all trace records in the FL (overly) used for
constraint solving. In addition, unlike the field transition trees that
already involve branches, the FL can only provide a form of lists.
Thus, the constraint is not generated for each branch according to
the field value. Instead, the constraint is generated by using all the
nodes executed before the current node, causing over-constraints
possibly to occur. This is one of the strong reasons why we decided
to construct field transition trees for each inferred field to avoid
the latter case.
Table 14 shows the number of branches and bugs discovered by
Intriguer with or without field transition trees in 24h fuzzing (20
runs). The results indicate that the case with field transition trees
discovers significantly more branches in all programs and more
bugs (in objdump, nm, readelf, and avconv) than the case without
trees for the same amount of time.
Figure 11 shows the time taken for constraint solving by a sym-
bolic solver in a single execution of Intriguer (without fuzzing, i.e.,
only the Execution Monitor and the Core as shaded in Figure 4)
by directly feeding a seed file, and the number of resulting queries.
Note that the field transition trees enable us to tune constraints to
uncomplicated (depth = 1) and complicated (depth > 1) constraints,
and the complicated constraints only to be solved by a symbolic
solver. The results indicate that constructing the field transition
trees helps to perform constraint solving in a shorter time and with
reduced queries; and consequently discover more branches and
bugs. Branch constraints by comparison instructions were signif-
icantly more reduced than arithmetic constraints when the field
Session 3A: Fuzzing: Methods and ApplicationsCCS ’19, November 11–15, 2019, London, United Kingdom526Table 14: The number of newly found branches and bugs when In-
triguer performs fuzzing with/without field transition trees in 24h.
Program
objdump
nm
readelf
ffmpeg
avconv
tiff2pdf
# of branches (median)
p
w/ FTT w/o FTT
3296.0
2826.5
6823.0
31432.0
18222.0
2351.0
3157.5 < 10−3
2745.5 = 0.07
6297.5 < 10−7
27108.0 < 0.002
16217.0 < 10−3
2308.5 < 0.003
# of bugs (total)
w/ FTT w/o FTT
7 (1)
3 (0)
4 (0)
2 (0)
3 (0)
1 (0)
11 (5)
4 (1)
6 (2)
2 (0)
4 (1)
1 (0)
transition tree was used. Note that more branches and bugs found
(Table 14) and less time and queries needed (Figure 11) both imply
that the field transition trees successfully suppress mistaints and
over-constraints. In addition, the field transition trees are effectively
used to tune those constraints.
Based on the observation from Table 14 and Figure 11, we
see that the field transition tree significantly increases new
branches and bugs discovered in most cases. These observa-
tions allow us to positively answer RQ4.
5.6 RQ5: Arithmetic Boundary
Instrumentation
Table 15 shows the number of new branches and bugs discovered
by Intriguer with or without arithmetic boundary instrumentation
in 24h fuzzing (20 runs). When using arithmetic boundary instru-
mentation in objdump, readelf, avconv and tiff2pdf, Intriguer
discovered bugs that were not found when not using it. Among
these, three bugs in objdump, readelf, and tiff2pdf, and two bugs
in avconv were not found by both Qsym and AFL. In objdump, we
observe that two bugs were found only when arithmetic boundary
instrumentation was not used: this result is due to more test cases
generated within the same time budget. If we enhance fuzzing time,
then it is possible to find the missed bugs when using arithmetic
boundary instrumentation; but the reverse case is unlikely because
bugs found only when using arithmetic boundary instrumentation
are hard to trigger — triggered only when a specific bug trigger
condition is met. Moreover, when using arithmetic boundary in-
strumentation, Intriguer was able to find more branches than not
using it.
Based on the observation from Table 15, we see that the
arithmetic boundary instrumentation significantly increases
new branches discovered in most cases and finds hard-to-
trigger bugs. This observation allow us to positively answer
RQ5.
6 DISCUSSION
In this paper, we aimed to present a new mutation-based hybrid
fuzzer which is efficient and effective in triggering both hard-to-
reach bugs and hard-to-trigger bugs, with optimization based on
inferred field knowledge in symbolic execution. Our field-level con-
straint solving concept is well-tuned by dynamic taint analysis and
Table 15: The number of newly found branches and bugs when In-
triguer performs fuzzing with/without arithmetic boundary instru-
mentation in 24h.
Program
objdump
nm
readelf
ffmpeg
avconv
tiff2pdf
# of branches (median)
p
w/ ABI w/o ABI
3296.0
2826.5
6823.0
31420.0
18222.0
2351.0
3140.5 < 10−3
2695.5 < 10−3
6571.0 < 10−5
25513.0 < 10−6
13062.5 < 10−7
2374.0 = 0.15
# of bugs (total)
w/ ABI w/o ABI
12 (2)
11 (1)
4 (0)
4 (0)
5 (0)
6 (1)
2 (0)
2 (0)
1 (0)
4 (3)
1 (1)
0 (0)
the minimal use of a constraint solver for truly complex constraints.
We discuss several interesting issues regarding our approach.
Intriguer introduced field-level constraint solving that efficiently
derives interesting mutation values from the reduced execution
traces of each inferred field; however, Intriguer performed field
inference by inspecting offsets recorded in the execution traces and
did not consider the association between those fields. For example,
if the same data structure is repeated in the input, the inferred fields,
Fa and Fb, could be field A of the same type in the execution traces.
Since Intriguer constructs a field transition tree for all inferred fields
if the same field A is used in multiple locations, the same field A will
be inferred at multiple offsets, therefore it will construct multiple
trees and the result in repetition. To perform field-level constraint
solving more efficiently, Intriguer can go one step further in offset-
based field inference, identifying fields of the same type through the
FL and grouping them together. In addition to identifying repeated
fields, we may infer structure from those fields and then consider
mutation strategies specific to repeated fields based on it.
Intriguer reduces the execution traces to emulate only the small
portion of the instructions that are repeatedly used to access a wide
range of input bytes. One may have two concerns regarding trace
reduction. First, excessively reduced traces may affect a constraint
solving for important branches. Although we already examined
the performance and addressed the false negative concerns in §5.4,
we could consider further steps toward this concern: it is possible
to gradually increase the threshold value of trace reduction if the
fuzzer can no longer finds new test cases when performing hybrid
fuzzing. Moreover, we could consider the context-sensitivity of
the run-time process, which was also considered in Angora [8]
and Qsym [33]. Context-sensitivity means that Intriguer will not
perform trace reduction when a program is in a different context
(e.g., different call stack). Second, the instructions can be repeatedly
used to access only a narrow range of input bytes. Note that an
execution bottleneck can also occur if the instructions are used to
repetitively access the input with specific offsets. We can address
this problem by reducing the execution traces for the instructions
that use the same offset by considering the program’s context.
Intriguer currently supports most of the x86 instruction set and a
part of x86_64 instruction set. Although it is challenging to support
all of x86_64 instructions, we can implement frequently used in-
structions to support actual program execution. Note that Intriguer
uses only reproducible traces in symbolic execution through field
transition trees, and thus it is possible to minimize the problem
Session 3A: Fuzzing: Methods and ApplicationsCCS ’19, November 11–15, 2019, London, United Kingdom527caused by unimplemented instructions, e.g., trying to solve incom-
plete constraints. Furthermore, Intriguer requires less implementa-
tion effort than other instruction-level concolic execution engines
because it does not require symbolic execution handlers for data
transfer instructions.
Since Intriguer uses DTA, taint-related problems should be dis-
cussed. Due to the large number of instructions, it is very difficult
in practice to implement handlers for all instructions and to pro-
cess highly complex instructions precisely. Accordingly, DTA is
susceptible to mistainting problems: the mistainted values and their
instructions could incur unnecessary operations and wasteful con-
straint queries in the constraint solving step. Therefore, Intriguer
addresses this problem by constructing the field transition tree as we
described in §3.3.3. Moreover, the execution monitor of Intriguer is
already developed to deal with known over-tainting problems (§C).
However, there is an over-tainting problem regarding an operand
value due to over-tainting in the execution trace: if the value is
incorrect, then the traces are removed by the field transition tree
again; but if it is correct, the traces will remain. We leave this
limitation as a future study.
Finally, in DTA, there is a case that data is indirectly propagated
(e.g., indirect and conditional jump), compared to the usual case that
data is directly propagated (e.g., data transfer instruction). Since
it is unlikely to reproduce the indirectly propagated data from
input values, the traces of indirect propagation may not be added
to field transition trees. The current version of Intriguer does not
consider the control-flow dependency, e.g., occurring from indirect
and conditional jump, and we also leave this limitation as a future
study.
7 RELATED WORK
7.1 Coverage-based Fuzzing
Fuzzing can be guided by sophisticated program analysis tech-
niques [7, 13, 15, 30]. Coverage-based fuzzers like AFL [34] attempt
to increase code coverage by prioritizing inputs that likely explore
new paths through the guidance of coverage information collected
during program execution. AFLFast [4] leverages the Markov model
based technique to prioritize low-frequency paths, and AFLGo [3]
minimizes the distance of seeds to targets. CollAFL [12] attempts to
provide more accurate coverage information. AFLFast and AFLGo
prioritize test cases and perform fuzzing longer for test cases of
higher priority.
However, they lack the penetration power: fuzzers get stuck
when encountering multibyte constraints. To resolve this problem,
program analysis techniques have been frequently used. VUzzer [27]
adopted application-aware fuzzing techniques that leverage both
static and dynamic program analysis. VUzzer is credited for im-
mediate treatment of multibyte constraints through taint tracking
and static analysis; but it incurs false positives in magic byte detec-
tion and requires many valid initial inputs. Steelix [19] leverages
light-weight static analysis and binary instrumentation to provide
not only coverage information but also comparison progress in-
formation to a fuzzer, for multibyte comparisons. Steelix is more
efficient than approaches based on taint analysis but less effective
at detecting a new execution path when complex constraints are
faced. Angora [8] combines byte-level taint tracking, shape and
type inference, and search techniques to solve path constraints fast.
These approaches are, however, limited to dealing with certain types
of constraints only, as explained in [33]. Unlike these approaches,
Intriguer queries a constraint solver, but for truly complex con-
straints only. T-Fuzz [26] removes complex constraint checks by
program transformation and runs symbolic execution to filter out
false positives. It negates interesting checks in the target program
by binary rewriting. To reproduce true bugs in the original program,
however, T-Fuzz has to filter out false positives in the transformed
program and so uses a symbolic analysis, incurring program ex-
plosion problems. We compared Intriguer with VUzzer by own
experiment and with Steelix, Angora, and T-Fuzz by reports, in the
LAVA-M benchmark dataset.
7.2 Hybrid Fuzzing
Combining both fuzzing and concolic execution is a promising
direction to addressing the problem of penetration power in fuzzing.
This hybrid fuzzing concept was introduced [6, 20, 25], and adopted
by the latest fuzzers. Driller [29] uses fuzzing and selective concolic
execution in a complementary manner to explore deeper paths by
selectively invoking concolic execution when fuzzing gets stuck.
However, previous hybrid fuzzers including Driller use general
concolic executors, and so they are slow and also susceptible to path
explosions. Qsym [33] raised the performance bottleneck problem
in symbolic emulation, and significantly improved the performance
of hybrid fuzzing by developing a scalable concolic execution engine
with instruction-level emulation and various heuristics such as
optimistic solving and basic block pruning. Qsym is remarkable in
terms of its design and implementation.
8 CONCLUSIONS
This paper presented Intriguer, which is efficient and effective in
finding both hard-to-reach bugs and hard-to-trigger bugs in pro-
grams. Intriguer’s key idea, which came from our systematic analy-
sis of hybrid fuzzing, is field-level constraint solving. Unlike existing
hybrid fuzzers, such as Driller and Qsym, Intriguer minimally uses
a solver for truly complex constraints only and significantly reduces
symbolic emulation overhead. Unlike program analysis based tech-
niques, such as VUzzer and Steelix, Intriguer leverages a constraint
solver, allowing more chances to solve complex constraints. The
practical performance of field-level constraint solving renders great
opportunities to hybrid fuzzing. Our evaluation results showed that
Intriguer outperformed Qsym and VUzzer in the LAVA-M testset;
and more importantly, found 43 new bugs in real-world programs,
including the new bug in ffmpeg that has been missed by OSS-Fuzz
for four years, and received 23 new CVEs.
ACKNOWLEDGMENTS
We thank the anonymous reviewers and our shepherd Andrew Ruef
for helpful comments and suggestions on this work. This research
was supported in part by the Institute for Information & commu-
nications Technology Promotion (IITP) grant funded by the Korea
government (MSIT) (No.2018-0-00513, Machine Learning Based
Automation of Vulnerability Detection on Unix-based Kernel).
Session 3A: Fuzzing: Methods and ApplicationsCCS ’19, November 11–15, 2019, London, United Kingdom528REFERENCES
[1] 2018. GNU Binutils. https://www.gnu.org/software/binutils/index.html
[2] 2018. Libav Open source audio and video processing tools. https://libav.org/
[3] Marcel Böhme, Van-Thuan Pham, Manh-Dung Nguyen, and Abhik Roychoudhury.
2017. Directed Greybox Fuzzing. In Proc. the ACM SIGSAC Conference on Computer
and Communications Security (CCS). ACM.
[4] Marcel Böhme, Van-Thuan Pham, and Abhik Roychoudhury. 2016. Coverage-
based Greybox Fuzzing as Markov Chain. In Proc. the ACM SIGSAC Conference
on Computer and Communications Security (CCS). ACM, 1032–1043.
[5] Juan Caballero, Heng Yin, Zhenkai Liang, and Dawn Song. 2007. Polyglot: Auto-
matic Extraction of Protocol Message Format Using Dynamic Binary Analysis.
In Proc. the ACM SIGSAC Conference on Computer and Communications Security
(CCS). ACM, 317–329.
[6] Sang Kil Cha, Thanassis Avgerinos, Alexandre Rebert, and David Brumley. 2012.
Unleashing MAYHEM on Binary Code. In Proc. the IEEE Symposium on Security
and Privacy (S&P). IEEE, 380–394.