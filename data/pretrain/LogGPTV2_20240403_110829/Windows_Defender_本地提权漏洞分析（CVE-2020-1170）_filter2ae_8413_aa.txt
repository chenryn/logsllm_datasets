# Windows Defender 本地提权漏洞分析（CVE-2020-1170）
##### 译文声明
本文是翻译文章，文章原作者 github，文章来源：itm4n.github.io
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
## 简介
在深入了解此漏洞的技术细节之前，我想简单介绍一下时间线。大概8个月前，我最初通过ZDI报告了这个漏洞。向他们发送我的报告后，我收到了一个回复，他们对收购此漏洞不感兴趣。当时，我只有几个星期的Windows安全研究经验，所以我有点依赖他们的判断，把这个发现放在一边。
5个月后，即2020年3月下旬，我再次浏览了笔记，看到了这份报告，但是这次，我的想法不同了。通过我直接发送给Microsoft其他的一些报告，我获得了一些经验。因此，我知道它可能符合潜在的条件，因此我决定花更多时间在它上面。这是一个很好的决定，因为我甚至找到了一种触发漏洞的更好方法。我在4月初向微软报告了此事，几周后得到了认可。
## 初步思考过程
你可以阅读Microsoft发布的[公告](https://portal.msrc.microsoft.com/en-us/security-guidance/advisory/CVE-2020-1170):
    Windows Defender中存在的权限提升漏洞会导致系统上任意文件的删除。
像平常一样，描述的非常笼统。你会发现它不仅仅是“ 任意文件删除 ”
我发现的问题与Windows Defender日志文件的处理方式有关。Windows
Defender使用2个日志文件MpCmdRun.log和MpSigStub.log，都位于C:WindowsTemp中，该目录是SYSTEM帐户的默认临时文件夹，但也是每个用户都具有写入访问权限的文件夹。
虽然这听起来很糟糕，但其实并没有那么糟糕，因为文件的权限设置正确，默认情况下，管理员和SYSTEM可以完全控制这些文件，而普通用户甚至无法读取它们。
下面是一个示例日志文件的摘要。正如您所看到的，它用于记录如签名更新之类的事件，但您也可以找到一些与防病毒扫描相关的条目。
签名更新会定期自动完成，但是也可以使用PowerShell命令Update-MpSignature手动触发，这并不需要任何特殊特权。因此，这些更新可以作为一个普通用户触发，如下面的截图所示。
在此过程中，我们可以看到Windows Defender 正在向C:WindowsTempMpCmdRun.log写入某些信息（如NT
AUTHORITYSYSTEM）。
这意味着，作为低权限用户，我们可以通过运行NT
AUTHORITYSYSTEM的进程触发日志文件写入操作。尽管我们无法访问该文件，也无法控制其内容。我们甚至对Temp文件夹本身都没有访问权限，因此也无法将其设置为挂载点。我现在想不出一个更无用的攻击载体了。
不过，我根据CVE-2020-0668的经验，这是Windows服务中一个微不足道的权限提升漏洞，我知道它可能不仅仅是一个日志文件写入。
仔细思考一下，每次签名更新完成时，都会向文件中添加一个新条目，该条目大约1
KB。虽然不多，但是，几个月甚至几年后，它将有多少呢？在这种情况下，通常会采用日志轮换机制，以便对旧日志进行压缩、存档或删除。因此，我想知道是否也实现了这种机制来处理MpCmdRun.log文件。如果是这样，可能存在滥用文件操作特权的地方。
## 搜索日志旋换机制
为了找到潜在的日志轮换机制，我首先逆向了MpCmdRun.exe可执行文件。在IDA中打开文件后，我要做的第一件事就是搜索MpCmdRun字符串，我最初的目标是查看如何处理日志文件，看到Strings窗户通常是一个好的开始。
不出所料，第一个结果是MpCmdRun.log，不过，这个搜索还得到了另一个非常有趣的结果：MpCmdRun_MaxLogSize。我正在寻找一种对轮换机制，该字符串等同于“
Follow the white Rabbit ”。查看Xrefsof
MpCmdRun_MaxLogSize，我发现它仅在MpCommonConfigGetValue()函数中使用。
MpCommonConfigGetValue()函数本身是从MpCommonConfigLookupDword()调用的。
最后，MpCommonConfigLookupDword()从CLogHandle::Flush()方法中调用。
CLogHandle::Flush()特别有趣，因为它负责写入日志文件。
首先，我们可以看到在GetFileSizeEx()中调用了hObject，这是指向日志文件MpCmdRun.log的句柄。此函数的结果返回在FileSize，这是一个LARGE_INTEGER结构。
    typedef union _LARGE_INTEGER {
      struct {
        DWORD LowPart;
        LONG  HighPart;
      } DUMMYSTRUCTNAME;
      struct {
        DWORD LowPart;
        LONG  HighPart;
      } u;
      LONGLONG QuadPart;
    } LARGE_INTEGER;
因为mpcmdrunk
.exe是一个64位的可执行文件，所以使用QuadPart直接获取文件大小为LONGLONG。这个值存储在v11中，然后与MpCommonConfigLookupDword()返回的值进行比较。
因此，在继续之前，我们需要获取MpCommonConfigLookupDword()的返回值。为此，我找到的最简单的方法是在这个函数调用之后设置一个断点，并从RAX寄存器获取结果。
断点命中后的样子如下：
因此，我们现在知道文件的最大大小是0x1000000，即16,777,216字节(16MB)。
接下来的问题是:当日志文件大小超过这个值时会发生什么?如前所述，当日志文件的大小超过16MB时，将调用PurgeLog()函数。根据名称，我们可以假设可能会在这个函数中找到第二个问题的答案。
调用此函数时，首先通过连接原始文件名和.bak来准备一个新文件名。然后，原始文件被移动，这意味着mpcmdrun.com
.log被重命名为mpcmdrun.com .log.bak。现在我们有了答案:确实实现了日志旋换机制。
在这里，我可以继续进行逆向分析，但是我还有其他想法。考虑到这些，我想采用一种更简单的方法。其思路是检查该机制在各种条件下的行为，并使用Procmon观察结果。
## 漏洞
以下是我们所知道的：
  * Windows Defender将一些日志事件写入C:WindowsTempMpCmdRun.log（例如：签名更新）。
  * 任何用户都可以在C:WindowsTemp中创建文件和目录。
  * 日志旋换机制通过将日志文件移动到C:WindowsTempMpCmdRun.log.bak并创建一个新文件来防止其超过16MB 。