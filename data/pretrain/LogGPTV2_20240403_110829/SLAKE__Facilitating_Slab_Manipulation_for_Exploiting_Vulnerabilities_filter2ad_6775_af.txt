After-Free. (2017). https://ssd-disclosure.com/archives/3484.
[10] Jake Edge. 2014. The kernel address sanitizer. (2014). https://lwn.net/Articles/
612153/.
[11] The FreeBSD Foundation. 2019. The FreeBSD Project. (2019). https://www.
freebsd.org/.
[12] Wolfram Gloger. 2006. Wolfram Gloger’s malloc homepage.
(2006).
http:
//www.malloc.de/en/.
[13] google. 2019. syzkaller - kernel fuzzer.
(2019). https://github.com/google/
syzkaller.
[14] Samuel Grob. 2014. Linux local root exploit for CVE-2014-0038. (2014). https:
//github.com/saelo/cve-2014-0038.
[15] S Heelan, T Melham, and D Kroening. 2018. Automatic Heap Layout Manipu-
lation for Exploitation. In Proceedings of the 27th USENIX Security Symposium
(USENIX Security).
[16] Jann Horn. 2018.
A cache invalidation bug in Linux memory man-
https://googleprojectzero.blogspot.com/2018/09/
agement.
a-cache-invalidation-bug-in-linux.html.
(2018).
[17] Ralf Hund, Thorsten Holz, and Felix C. Freiling. 2009. Return-Oriented Rootkits:
Bypassing Kernel Code Integrity Protection Mechanisms. In Proceedings of the
18th USENIX Security Symposium (USENIX Security).
[18] ianamason. 2019. Whole Program LLVM: wllvm ported to go. (2019). https:
//github.com/SRI-CSL/gllvm.
[19] Kyriakos K. Ispoglou, Bader AlBassam, Trent Jaeger, and Mathias Payer. 2018.
Block Oriented Programming: Automating Data-Only Attacks. In Proceedings of
the 2018 ACM SIGSAC Conference on Computer and Communications Security
(CCS ’18).
[20] Vasileios P. Kemerlis, Michalis Polychronakis, and Angelos D. Keromytis. 2014.
ret2dir: Rethinking Kernel Isolation. In Proceedings of the 23rd USENIX Security
Symposium (USENIX Security).
[21] Andrey Konovalov. 2017.
sockets.
exploiting-linux-kernel-via-packet.html.
(2017).
Exploiting the Linux kernel via packet
https://googleprojectzero.blogspot.com/2017/05/
[22] Andrey Konovalov. 2017. A proof-of-concept local root exploit for CVE-2017-6074.
(2017). https://github.com/xairy/kernel-exploits/blob/master/CVE-2017-6074/
poc.c.
[23] Lexfo. 2018. CVE-2017-11176: A step-by-step Linux Kernel exploitation. (2018).
https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html.
[24] Kangjie Lu, M Walter, David Pfaff, and Stefan Nürnberger and Wenke Lee and
Michael Backes. 2017. Unleashing Use-Before-Initialization Vulnerabilities in the
Linux Kernel Using Targeted Stack Spraying. In Proceedings of the 2017 Network
and Distributed System Security Symposium (NDSS).
[25] Matt Mackall. 2005. slob: introduce the SLOB allocator. (2005). https://lwn.net/
Articles/157944/.
[26] Rohit Mothe and Rodrigo Rubira Branco. 2016. DPTrace: Dual Purpose Trace for
Exploitability Analysis of Program Crashes. In Black Hat USA Briefings.
[27] Vitaly Nikolenko. 2016. CVE-2014-2851 group_info UAF Exploitation. (2016).
https://cyseclabs.com/page?n=02012016.
[28] Jon Oberheide. 2010. Linux Kernel CAN SLUB Overflow. (2010). https://jon.
oberheide.org/blog/2010/09/10/linux-kernel-can-slub-overflow/.
[29] Shankara Pailoor, Andrew Aday, and Suman Jana. 2018. MoonShine: Optimizing
OS Fuzzer Seed Selection with Trace Distillation. In Proceedings of the 27th
USENIX Security Symposium (USENIX Security).
[30] Christopher M. Penalver. 2016. How to triage bugs. (2016). https://wiki.ubuntu.
com/Bugs/Importance.
[31] Enrico Perla and Massimiliano Oldani. 2010. A Guide to Kernel Exploitation.
Elsevier.
[32] Alexander Popov. 2017. CVE-2017-2636: exploit the race condition in the n_hdlc
Linux kernel driver bypassing SMEP. (2017). https://a13xp0p0v.github.io/2017/
03/24/CVE-2017-2636.html.
[33] Android Open Source Project. 2019. Common Android Kernel Tree.
(2019).
https://android.googlesource.com/kernel/common/.
[34] LLVM Project. 2019. LLVM 6.0.0 Release Notes. (2019). http://releases.llvm.org/
6.0.0/docs/ReleaseNotes.html.
[35] Dusan Repel, Johannes Kinder, and Lorenzo Cavallaro. 2017. Modular Synthesis
of Heap Exploits. In ACM SIGSAC Workshop on Programming Languages and
Analysis for Security (PLAS).
[36] Steven Rostedt. 2009. Debugging the kernel using Ftrace. (2009). https://lwn.
net/Articles/365835/.
[37] Chris Salls. 2017. Exploiting CVE-2017-5123 with full protections. SMEP,
https://salls.github.io/
(2017).
SMAP, and the Chrome Sandbox!
Linux-Kernel-CVE-2017-5123/.
[38] Yan Shoshitaishvili, Ruoyu Wang, Christophe Hauser, Christopher Kruegel, and
Giovanni Vigna. 2015. Firmalice - Automatic Detection of Authentication Bypass
Vulnerabilities in Binary Firmware. In Proceedings of the 2015 Network and
Distributed System Security Symposium (NDSS).
[39] Yan Shoshitaishvili, Ruoyu Wang, Christopher Salls, Nick Stephens, Mario Polino,
Audrey Dutcher, John Grosen, Siji Feng, Christophe Hauser, Christopher Kruegel,
and Giovanni Vigna. 2016. SoK:(State of) The Art of War: Offensive Techniques
in Binary Analysis. In Proceedings of the 37th IEEE Symposium on Security and
Privacy (S&P).
[40] Richard M. Stallman. 2019. GNU Debugger.
(2019). https://www.gnu.org/
software/gdb/.
[41] Nick Stephens, John Grosen, Christopher Salls, Audrey Dutcher, Ruoyu Wang,
Jacopo Corbetta, Yan Shoshitaishvili, Christopher Kruegel, and Giovanni Vigna.
2016. Driller: Augmenting Fuzzing Through Selective Symbolic Execution. In
Proceedings of the 2016 Network and Distributed System Security Symposium
(NDSS).
[42] Dmitry Vyukov. 2018.
syzbot and the tale of thousand kernel bugs.
https://events.linuxfoundation.org/wp-content/uploads/2017/11/
(2018).
Syzbot-and-the-Tale-of-Thousand-Kernel-Bugs-Dmitry-Vyukov-Google.pdf.
[43] Xi Wang, Haogang Chen, Zhihao Jia, Nickolai Zeldovich, and M. Frans Kaashoek.
2012. Improving Integer Security for Systems with KINT. In Proceedings of the
10th USENIX Symposium on Operating Systems Design and Implementation
(OSDI).
[44] Yan Wang, Chao Zhang, Xiaobo Xiang, Zixuan Zhao, Wenjie Li, Xiaorui Gong,
BingChang Liu, Kaixiang Chen, and Wei Zou. 2018. Revery: From Proof-of-
Concept to Exploitable. In Proceedings of the 25nd ACM SIGSAC Conference on
Computer and Communications Security (CCS).
[45] Wei Wu, Yueqi Chen, Xinyu Xing, and Wei Zou. 2019. KEPLER: Facilitating
Control-flow Hijacking Primitive Evaluation for Linux Kernel Vulnerabilities. In
Proceedings of the 28th USENIX Security Symposium (USENIX Security).
[46] Wei Wu, Yueqi Chen, Jun Xu, Xinyu Xing, Wei Zou, and Xiaorui Gong. 2018.
FUZE: Towards Facilitating Exploit Generation for Kernel Use-After-Free Vul-
nerabilities. In Proceedings of the 27th USENIX Security Symposium (USENIX
Security).
[47] ww9210. 2019. exploit code for a bpf heap overflow vulnerability. (2019). https:
//github.com/ww9210/kernel4.20_bpf_LPE.
[48] Wen Xu, Juanru Li, Junliang Shu, Wenbo Yang, Tianyi Xie, Yuanyuan Zhang,
and Dawu Gu. 2015. From Collision To Exploitation: Unleashing Use-After-
Free Vulnerabilities in Linux Kernel. In Proceedings of the 22nd ACM SIGSAC
Conference on Computer and Communications Security (CCS).
[49] Masahiro Yamada and Jani Nikula. 2019.
kcov:code coverage for fuzzing.
(2019). https://github.com/torvalds/linux/blob/master/Documentation/dev-tools/
kcov.rst.
[50] Wei You, Peiyuan Zong, Kai Chen, XiaoFeng Wang, Xiaojing Liao, Pan Bian,
and Bin Liang. 2017. SemFuzz: Semantics-based Automatic Generation of Proof-
of-Concept Exploits. In Proceedings of the 24th ACM SIGSAC Conference on
Computer and Communications Security (CCS).
10 APPENDIX
A AUTOMATED APPROACH TO PAIRING
VULNERABILITY WITH OBJECT
We design an automated approach to pairing a kernel vulnerability
with objects. The algorithm 1 describes the detail of this automated
approach. As we can see in Algorithm 1, the input to the algorithm
includes the type of the vulnerability (T ), the name of cache for the
vulnerable object (C), a Flag (F ) indicating ś for a UAF vulnerability ś
whether it is feasible to modify the meta-header after the vulnerable
object is freed, an array Ar indicating memory regions under an
attacker’s control, and an array Ap indicating where critical data are
located. In addition, we can observe, the output for the algorithm
is a set of 3-tuple which are a spray object, a victim object, and
the offset between the vulnerable and the victim object. Here, the
offset describes desired slab layout. Considering that attackers can
move a victim object to any slots on the slab, we further define
an operation ⊕ to adjust the base address of critical data in the
victim object. For example, when a victim object is slid two slots
rightward, we modify Ap as Ap ⊕ (2 × SZ ) which adds 2 × SZ to
all pointer offets in Ap .
B DATABASE AND ITS USAGE
As is mentioned in this paper, using static and dynamic analysis, we
construct a database in which we store information useful for kernel
exploitation. In our implementation, we save these information in
a text file. Here, we specify the information stored in the database
and illustrate how to use the information to perform a slab layout
manipulation by using an example shown in Figure 5.
As we can see in the figure, fsnotify_group is a victim object
in cache kmalloc-256. Its critical data is in the offset 0x8. Its allo-
cation, free and dereference system calls are stored in the head
file fsnotify_group_fengshui.h. In this head file, fsnotify_group can be
S = ∅
for all SprO r 1, VtmO r 2 using C in database do
for all SprO r 1, VtmO r 2 using C in database do
S = MatchOOB(C , Ar )
return S
if F then
return S
S = S ∪ 
S = MatchDF(C )
else if T == OOB then
S = MatchUAF(C , Ap )
else if T == double_free then
Ar = data range in r 1
Ap = pointer in r 2
if IsMatch(Ar , Ap ) then
Ar = data range in r 1
if IsMatch(Ar , Ap ) then
S = S ∪ 
1: procedure MatchVulCap(T , C , F , Ap , Ar )
2:
3:
4:
5:
6:
7:
8:
9:
10: procedure MatchUAF(C , F , Ap )
11:
12:
13:
14:
15:
16:
17:
18:
19:
20: procedure MatchDF(C )
21:
22:
23:
24:
25:
26:
27:
28:
29:
30:
31: procedure MatchOOB(C , Ar )
32:
33:
34:
35:
36:
37:
38:
39:
40:
41:
42:
43:
44: procedure IsMatch(Ar , Ap )
45:
46:
47:
48:
49:
50:
m = length of Ar
n = length of Ap
for all i, j, 1 ≤ i ≤ m, 1 ≤ j ≤ n do
Ap = [i × S Z ]
if IsMatch(Ar , Ap ) then
S = S ∪ 
p = Ap ⊕ (i × S Z ) // slide VtmO
Ap = pointers in r 2
A′
if IsMatch(Ar , A′
p ) then
S = S ∪ 
S Z = size of slot in C
for all i, −10 ≤ i ≤ 10, i , 0 do
S = S ∪ 
p = [0]
A′
if IsMatch(Ar , A′
p ) then
S = S ∪ 
return True
return False
return S
return S
for all VtmO r 2 using C in database do
Algorithm 1 Matching Vulnerability Capability
Input: T : Vulnerability Type; C : VulO Cache;
F : Meta Flag; Ap : Pointer Array; Ar : Range Array
Output: S : Set of 3-tuple 
if T == UAF then
if Ar [i ].l ≤ Ap [j] < Ap [j] + w ≤ Ar [i ].h then
allocated by system call inotify_init1 and critical data can be derefer-
enced by system call exit. Since inotify_init1 allocates an additional
object to the cache kmalloc-256 after fsnotify_group, we record the
side effect tied to the allocation as XY where X denotes fsnotify_group
and Y indicates an irrelevant object.
To manipulate slab layout by using the database above, we search
the database under the guidance of the method introduced in Sec-
tion 4.1. We can find that fsnotify_group is a perfect match because
it can be allocated to the cache kmalloc-256 and its critical data over-
lapping with the corruption region. Since we have an annotated
PoC program in hand, demonstrating the capability of the vulnera-
bility, we can include fsnotify_group_fengshui.h to the PoC and then
insert a call to function fsnotify_group_alloc() in function alloc_vtmo
֒→ () and a call to fsnotify_group_deref() in hijack() respectively.
Using ftrace results, we however can find that the target slot is
occupied by an irrelevant object. To address this issue, we therefore
can reorganize occupied slots by following the method introduced
in Section 4.2. For this case, we can complete reorganization by
inserting (de)allocation of file in a specific order to the function
manipulate() in the annotated PoC. This is because the object file
shares the same cache with fsnotify_group and its (de)allocation
involves no side effect.
1
2
3
4
5
6
7
8
9
10
11
12
13
1
2
3
4
5
6
7
1
2
3
4
5
6
7
8
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
Name: fsnotify_group
Role: victim object
Cache: kmalloc-256
A_p: [0x8]
HeadFile:
fsnotify_group_fengshui.h
Name: file
Role: victim object
Cache: kmalloc-256
A_p: [0x28]
HeadFile:
file_fengshui.h
(a) Database
// SideEffect: XY
void fsnotify_group_alloc() {
syscall(__NR_inotify_init1, 0x800);
}
void fsnotify_group_deref() {
syscall(__NR_exit);
}
(b) fsnotify_group_fengshui.h
// SideEffect: X
void file_alloc() {
fd = syscall(__NR_open,  test0 , 0x100);
}
// SideEffect: X
void file_dealloc() {
syscall(__NR_close, fd);
}
(c) le_fengshui.h
// Vulnerability Type (T): OOB
// Cache Name (C): kmalloc-256
// Corruption Range (R): [256, 512]
// BEGIN HEAD FILE
...
// END HEAD FILE
void context_setup() {...}
void defragmentation(){...}
void manipulate(){/*TODO*/}
void alloc_vulo(){...}
void alloc_vtmo(){/*TODO*/}
void trigger_oob(){...}
void hijack(){/*TODO*/}
int main() {
context_setup();
defragmentation();
manipulate();
alloc_vulo();
alloc_vtmo();
trigger_oob();
hijack();
}
Figure 5: An example illustrating the database and its usage
(d) The PoC with Annotation