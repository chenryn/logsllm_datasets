### References

1. After-Free. (2017). [https://ssd-disclosure.com/archives/3484](https://ssd-disclosure.com/archives/3484).

2. Jake Edge. 2014. The Kernel Address Sanitizer. [https://lwn.net/Articles/612153/](https://lwn.net/Articles/612153/).

3. The FreeBSD Foundation. 2019. The FreeBSD Project. [https://www.freebsd.org/](https://www.freebsd.org/).

4. Wolfram Gloger. 2006. Wolfram Gloger’s Malloc Homepage. [http://www.malloc.de/en/](http://www.malloc.de/en/).

5. Google. 2019. Syzkaller - Kernel Fuzzer. [https://github.com/google/syzkaller](https://github.com/google/syzkaller).

6. Samuel Grob. 2014. Linux Local Root Exploit for CVE-2014-0038. [https://github.com/saelo/cve-2014-0038](https://github.com/saelo/cve-2014-0038).

7. S. Heelan, T. Melham, and D. Kroening. 2018. Automatic Heap Layout Manipulation for Exploitation. In *Proceedings of the 27th USENIX Security Symposium* (USENIX Security).

8. Jann Horn. 2018. A Cache Invalidation Bug in Linux Memory Management. [https://googleprojectzero.blogspot.com/2018/09/a-cache-invalidation-bug-in-linux.html](https://googleprojectzero.blogspot.com/2018/09/a-cache-invalidation-bug-in-linux.html).

9. Ralf Hund, Thorsten Holz, and Felix C. Freiling. 2009. Return-Oriented Rootkits: Bypassing Kernel Code Integrity Protection Mechanisms. In *Proceedings of the 18th USENIX Security Symposium* (USENIX Security).

10. ianamason. 2019. Whole Program LLVM: wllvm Ported to Go. [https://github.com/SRI-CSL/gllvm](https://github.com/SRI-CSL/gllvm).

11. Kyriakos K. Ispoglou, Bader AlBassam, Trent Jaeger, and Mathias Payer. 2018. Block Oriented Programming: Automating Data-Only Attacks. In *Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security* (CCS '18).

12. Vasileios P. Kemerlis, Michalis Polychronakis, and Angelos D. Keromytis. 2014. ret2dir: Rethinking Kernel Isolation. In *Proceedings of the 23rd USENIX Security Symposium* (USENIX Security).

13. Andrey Konovalov. 2017. Exploiting the Linux Kernel via Packet Sockets. [https://googleprojectzero.blogspot.com/2017/05/exploiting-linux-kernel-via-packet.html](https://googleprojectzero.blogspot.com/2017/05/exploiting-linux-kernel-via-packet.html).

14. Andrey Konovalov. 2017. A Proof-of-Concept Local Root Exploit for CVE-2017-6074. [https://github.com/xairy/kernel-exploits/blob/master/CVE-2017-6074/poc.c](https://github.com/xairy/kernel-exploits/blob/master/CVE-2017-6074/poc.c).

15. Lexfo. 2018. CVE-2017-11176: A Step-by-Step Linux Kernel Exploitation. [https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html](https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html).

16. Kangjie Lu, M. Walter, David Pfaff, Stefan Nürnberger, Wenke Lee, and Michael Backes. 2017. Unleashing Use-Before-Initialization Vulnerabilities in the Linux Kernel Using Targeted Stack Spraying. In *Proceedings of the 2017 Network and Distributed System Security Symposium* (NDSS).

17. Matt Mackall. 2005. slob: Introduce the SLOB Allocator. [https://lwn.net/Articles/157944/](https://lwn.net/Articles/157944/).

18. Rohit Mothe and Rodrigo Rubira Branco. 2016. DPTrace: Dual Purpose Trace for Exploitability Analysis of Program Crashes. In *Black Hat USA Briefings*.

19. Vitaly Nikolenko. 2016. CVE-2014-2851 Group Info UAF Exploitation. [https://cyseclabs.com/page?n=02012016](https://cyseclabs.com/page?n=02012016).

20. Jon Oberheide. 2010. Linux Kernel CAN SLUB Overflow. [https://jon.oberheide.org/blog/2010/09/10/linux-kernel-can-slub-overflow/](https://jon.oberheide.org/blog/2010/09/10/linux-kernel-can-slub-overflow/).

21. Shankara Pailoor, Andrew Aday, and Suman Jana. 2018. MoonShine: Optimizing OS Fuzzer Seed Selection with Trace Distillation. In *Proceedings of the 27th USENIX Security Symposium* (USENIX Security).

22. Christopher M. Penalver. 2016. How to Triage Bugs. [https://wiki.ubuntu.com/Bugs/Importance](https://wiki.ubuntu.com/Bugs/Importance).

23. Enrico Perla and Massimiliano Oldani. 2010. A Guide to Kernel Exploitation. Elsevier.

24. Alexander Popov. 2017. CVE-2017-2636: Exploit the Race Condition in the n_hdlc Linux Kernel Driver Bypassing SMEP. [https://a13xp0p0v.github.io/2017/03/24/CVE-2017-2636.html](https://a13xp0p0v.github.io/2017/03/24/CVE-2017-2636.html).

25. Android Open Source Project. 2019. Common Android Kernel Tree. [https://android.googlesource.com/kernel/common/](https://android.googlesource.com/kernel/common/).

26. LLVM Project. 2019. LLVM 6.0.0 Release Notes. [http://releases.llvm.org/6.0.0/docs/ReleaseNotes.html](http://releases.llvm.org/6.0.0/docs/ReleaseNotes.html).

27. Dusan Repel, Johannes Kinder, and Lorenzo Cavallaro. 2017. Modular Synthesis of Heap Exploits. In *ACM SIGSAC Workshop on Programming Languages and Analysis for Security* (PLAS).

28. Steven Rostedt. 2009. Debugging the Kernel Using Ftrace. [https://lwn.net/Articles/365835/](https://lwn.net/Articles/365835/).

29. Chris Salls. 2017. Exploiting CVE-2017-5123 with Full Protections: SMEP, SMAP, and the Chrome Sandbox! [https://salls.github.io/Linux-Kernel-CVE-2017-5123/](https://salls.github.io/Linux-Kernel-CVE-2017-5123/).

30. Yan Shoshitaishvili, Ruoyu Wang, Christophe Hauser, Christopher Kruegel, and Giovanni Vigna. 2015. Firmalice - Automatic Detection of Authentication Bypass Vulnerabilities in Binary Firmware. In *Proceedings of the 2015 Network and Distributed System Security Symposium* (NDSS).

31. Yan Shoshitaishvili, Ruoyu Wang, Christopher Salls, Nick Stephens, Mario Polino, Audrey Dutcher, John Grosen, Siji Feng, Christophe Hauser, Christopher Kruegel, and Giovanni Vigna. 2016. SoK: (State of) The Art of War: Offensive Techniques in Binary Analysis. In *Proceedings of the 37th IEEE Symposium on Security and Privacy* (S&P).

32. Richard M. Stallman. 2019. GNU Debugger. [https://www.gnu.org/software/gdb/](https://www.gnu.org/software/gdb/).

33. Nick Stephens, John Grosen, Christopher Salls, Audrey Dutcher, Ruoyu Wang, Jacopo Corbetta, Yan Shoshitaishvili, Christopher Kruegel, and Giovanni Vigna. 2016. Driller: Augmenting Fuzzing Through Selective Symbolic Execution. In *Proceedings of the 2016 Network and Distributed System Security Symposium* (NDSS).

34. Dmitry Vyukov. 2018. Syzbot and the Tale of Thousand Kernel Bugs. [https://events.linuxfoundation.org/wp-content/uploads/2017/11/Syzbot-and-the-Tale-of-Thousand-Kernel-Bugs-Dmitry-Vyukov-Google.pdf](https://events.linuxfoundation.org/wp-content/uploads/2017/11/Syzbot-and-the-Tale-of-Thousand-Kernel-Bugs-Dmitry-Vyukov-Google.pdf).

35. Xi Wang, Haogang Chen, Zhihao Jia, Nickolai Zeldovich, and M. Frans Kaashoek. 2012. Improving Integer Security for Systems with KINT. In *Proceedings of the 10th USENIX Symposium on Operating Systems Design and Implementation* (OSDI).

36. Yan Wang, Chao Zhang, Xiaobo Xiang, Zixuan Zhao, Wenjie Li, Xiaorui Gong, BingChang Liu, Kaixiang Chen, and Wei Zou. 2018. Revery: From Proof-of-Concept to Exploitable. In *Proceedings of the 25th ACM SIGSAC Conference on Computer and Communications Security* (CCS).

37. Wei Wu, Yueqi Chen, Xinyu Xing, and Wei Zou. 2019. KEPLER: Facilitating Control-Flow Hijacking Primitive Evaluation for Linux Kernel Vulnerabilities. In *Proceedings of the 28th USENIX Security Symposium* (USENIX Security).

38. Wei Wu, Yueqi Chen, Jun Xu, Xinyu Xing, Wei Zou, and Xiaorui Gong. 2018. FUZE: Towards Facilitating Exploit Generation for Kernel Use-After-Free Vulnerabilities. In *Proceedings of the 27th USENIX Security Symposium* (USENIX Security).

39. ww9210. 2019. Exploit Code for a BPF Heap Overflow Vulnerability. [https://github.com/ww9210/kernel4.20_bpf_LPE](https://github.com/ww9210/kernel4.20_bpf_LPE).

40. Wen Xu, Juanru Li, Junliang Shu, Wenbo Yang, Tianyi Xie, Yuanyuan Zhang, and Dawu Gu. 2015. From Collision to Exploitation: Unleashing Use-After-Free Vulnerabilities in Linux Kernel. In *Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications Security* (CCS).

41. Masahiro Yamada and Jani Nikula. 2019. kcov: Code Coverage for Fuzzing. [https://github.com/torvalds/linux/blob/master/Documentation/dev-tools/kcov.rst](https://github.com/torvalds/linux/blob/master/Documentation/dev-tools/kcov.rst).

42. Wei You, Peiyuan Zong, Kai Chen, XiaoFeng Wang, Xiaojing Liao, Pan Bian, and Bin Liang. 2017. SemFuzz: Semantics-Based Automatic Generation of Proof-of-Concept Exploits. In *Proceedings of the 24th ACM SIGSAC Conference on Computer and Communications Security* (CCS).

### Appendix

#### A. Automated Approach to Pairing Vulnerability with Object

We have designed an automated approach to pair a kernel vulnerability with objects. Algorithm 1 details this approach. The input to the algorithm includes:
- The type of the vulnerability (T)
- The name of the cache for the vulnerable object (C)
- A flag (F) indicating whether it is feasible to modify the meta-header after the vulnerable object is freed (for UAF vulnerabilities)
- An array (Ar) indicating memory regions under an attacker's control
- An array (Ap) indicating where critical data are located

The output of the algorithm is a set of 3-tuples, each consisting of a spray object, a victim object, and the offset between the vulnerable and the victim object. The offset describes the desired slab layout. Given that attackers can move a victim object to any slot on the slab, we define an operation ⊕ to adjust the base address of critical data in the victim object. For example, if a victim object is slid two slots rightward, we modify Ap as Ap ⊕ (2 × SZ), which adds 2 × SZ to all pointer offsets in Ap.

**Algorithm 1: Matching Vulnerability Capability**

```plaintext
Input: T: Vulnerability Type; C: VulO Cache; F: Meta Flag; Ap: Pointer Array; Ar: Range Array
Output: S: Set of 3-tuple (Spray Object, Victim Object, Offset)

if T == UAF then
    S = MatchUAF(C, F, Ap)
else if T == double_free then
    S = MatchDF(C)
else if T == OOB then
    S = MatchOOB(C, Ar)

return S
```

**Procedure: MatchUAF(C, F, Ap)**

```plaintext
S = ∅
for all r1, r2 using C in database do
    Ar = data range in r1
    Ap = pointers in r2
    if IsMatch(Ar, Ap) then
        S = S ∪ (r1, r2, 0)
        if F then
            for all i, −10 ≤ i ≤ 10, i ≠ 0 do
                p = Ap ⊕ (i × SZ)
                if IsMatch(Ar, p) then
                    S = S ∪ (r1, r2, i × SZ)
return S
```

**Procedure: MatchDF(C)**

```plaintext
S = ∅
for all r1, r2 using C in database do
    Ar = data range in r1
    Ap = pointers in r2
    if IsMatch(Ar, Ap) then
        S = S ∪ (r1, r2, 0)
return S
```

**Procedure: MatchOOB(C, Ar)**

```plaintext
S = ∅
for all r1, r2 using C in database do
    Ap = pointers in r2
    if IsMatch(Ar, Ap) then
        S = S ∪ (r1, r2, 0)
return S
```

**Procedure: IsMatch(Ar, Ap)**

```plaintext
m = length of Ar
n = length of Ap
for all i, j, 1 ≤ i ≤ m, 1 ≤ j ≤ n do
    if Ar[i].l ≤ Ap[j] < Ap[j] + w ≤ Ar[i].h then
        return True
return False
```

#### B. Database and Its Usage

As mentioned in the paper, we use static and dynamic analysis to construct a database containing information useful for kernel exploitation. This information is stored in a text file. Here, we specify the information stored in the database and illustrate how to use it to perform slab layout manipulation with an example shown in Figure 5.

**Figure 5: An Example Illustrating the Database and Its Usage**

1. **Database Entry: fsnotify_group**
   - **Name:** fsnotify_group
   - **Role:** Victim Object
   - **Cache:** kmalloc-256
   - **A_p:** [0x8]
   - **HeadFile:** fsnotify_group_fengshui.h

2. **fsnotify_group_fengshui.h**

   ```c
   // SideEffect: XY
   void fsnotify_group_alloc() {
       syscall(__NR_inotify_init1, 0x800);
   }

   void fsnotify_group_deref() {
       syscall(__NR_exit);
   }
   ```

3. **file_fengshui.h**

   ```c
   // SideEffect: X
   void file_alloc() {
       fd = syscall(__NR_open, "test0", 0x100);
   }

   // SideEffect: X
   void file_dealloc() {
       syscall(__NR_close, fd);
   }
   ```

4. **PoC with Annotation**

   ```c
   // Vulnerability Type (T): OOB
   // Cache Name (C): kmalloc-256
   // Corruption Range (R): [256, 512]

   // BEGIN HEAD FILE
   ...
   // END HEAD FILE

   void context_setup() {...}
   void defragmentation(){...}
   void manipulate(){/*TODO*/}
   void alloc_vulo(){...}
   void alloc_vtmo(){/*TODO*/}
   void trigger_oob(){...}
   void hijack(){/*TODO*/}

   int main() {
       context_setup();
       defragmentation();
       manipulate();
       alloc_vulo();
       alloc_vtmo();
       trigger_oob();
       hijack();
   }
   ```

To manipulate the slab layout using the database, we follow the method introduced in Section 4.1. We find that `fsnotify_group` is a perfect match because it can be allocated to the cache `kmalloc-256` and its critical data overlaps with the corruption region. With an annotated PoC program demonstrating the vulnerability, we include `fsnotify_group_fengshui.h` in the PoC and insert calls to `fsnotify_group_alloc()` and `fsnotify_group_deref()` in the appropriate functions.

Using ftrace results, we may find that the target slot is occupied by an irrelevant object. To address this, we reorganize the occupied slots by following the method in Section 4.2. For this case, we can complete the reorganization by inserting (de)allocation of `file` in a specific order in the `manipulate()` function of the annotated PoC. This is because the `file` object shares the same cache with `fsnotify_group` and its (de)allocation involves no side effects.