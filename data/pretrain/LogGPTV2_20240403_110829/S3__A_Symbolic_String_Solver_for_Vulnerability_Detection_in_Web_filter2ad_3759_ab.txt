eral usage), of which the semantics are by nature recursively de-
ﬁned. Section 5 introduces the gist of our proposal, the encodings
using recursively-deﬁned functions, on which we can incrementally
reason: by lazily unfolding them.
2. OUR CONSTRAINT LANGUAGE
We introduce the constraint language of our solver in Fig. 2. For
simplicity, we only list three primitive types: int, bool and string1.
The input formula can be of the following forms:
1Z3 supports more primitive types [11].
Assertion
Fml:bool
Term:bool
Term:int
Term:str
L:str list
true
false
contains((Term:str), (Term:str))
(Term:bool) = (Term:bool)
(Term:int) {} (Term:int)
(Term:str) = (Term:str)
(Term:str) ∈ (Term:regexpr)
¬ (Fml:bool)
(Fml:bool) {∧,∨,⇒} (Fml:bool)
::= assert ((Fml:bool))
::= (Term:bool)
|
|
|
|
|
|
::= (Var:bool)
|
|
|
::= (Var:int)
|
Number
(Term:int) {+,−,×,÷} (Term:int)
|
|
length((Term:str))
|
indexOf ((Term:str), (Term:str))
|
search((Term:str), (Term:regexpr))
|
test((Term:regexpr), (Term:str))
::= ConstString
|
|
|
|
|
|
::= match((Term:str), (Term:regexpr))
|
|
|
|
|
(Term:regexpr)(cid:63)
(Term:regexpr) · (Term:regexpr)
(Term:regexpr) + (Term:regexpr)
split((Term:str), (Term:regexpr))
exec((Term:regexpr), (Term:str))
(Var:str)
(Term:str) · (Term:str)
concat((Term:str), (Term:str))
substring((T:str), (T:int), (T:int))
replaceN((T:str),(T:regexpr),(T:str),(T:int))
replaceAll((T:str), (T:regexpr), (T:str))
Term:regexpr::= ConstString
Figure 2: The Grammar of Our Input Constraint Language
• a boolean expression;
• a comparison operation between two integer or boolean expres-
sions;
• an equation between two string expressions. S3 also supports
other common string operations. We list here only important ones;
• a membership predicate between a string expression and a regu-
lar expression, where an expression can either be a string constant,
a variable or their concatenation2, and regular expressions are con-
structed from string constants using concatenation (·), union (+)
and Kleene star ((cid:63));
• a composite formula constructed using negation and binary con-
nectives, including ∧, ∨, ⇒.
Z3-str [39] and Kaluza [28] are important existing solvers that
can support both string and non-string operations, especially the
length constraint. Compared to the constraint syntax of Z3-str, ours
can be viewed as an extension with regular expressions, member-
ship predicates, and high-level string operations that often work on
regular expressions such as search, replaceAll3, match, split, test,
exec. Our constraint language is also slightly more expressive than
Kaluza’s since we handle above string operations in its original se-
mantics — unbounded.
2We use x · y as a shorter form for concat(x, y).
3This operation is used to replace all occurrences.
A JavaScript Program
function validateFields(p1,p2) {
var re1 = /^(ab)*$/;
var re2 = /^(bc)*$/;
var t1 = re1.test(p1);
var t2 = re2.test(p2);
var t3 = p2.length > 0;
return (t1 && t2 && t3)
}
Generated Constraints
p1 ∈ (“ab”)(cid:63) ∧
p2 ∈ (“bc”)(cid:63) ∧
length(p2) > 0 ∧
res = p1 · p2 ∧
nM = “ababababababcc” ∧
res = nM
Our Internal Representation
p1 = star(“ab”,n1) ∧
p2 = star(“bc”,n2) ∧
length(p2) > 0 ∧
res = p1 · p2 ∧
nM = “ababababababcc” ∧
res = nM
Figure 3: From a JavaScript Program to the Generated Constraints
In addition, we note that our constraint language, which is nec-
essary to reason about high-level string operations in scripting lan-
guages, is beyond the class of context free languages. To illustrate,
let us look at the following constraints, in which x can be of any
string in the context-sensitive language { an·bn·cn | n≥0 }:
x = y · z · t ∧ y ∈ a(cid:63) ∧ z ∈ b(cid:63) ∧ t ∈ c(cid:63)∧
length(y)=length(z) ∧ length(z)=length(t)
Therefore, existing solvers, which only approximate strings us-
ing context free grammars, are not able to reason about the con-
straints addressed by this paper.
Finally, though it is not shown in Fig. 2, S3 is able to accom-
modate most regular expression features in JavaScript via a pre-
processing step as done in Kudzu [28]. Examples are (possibly
negated) character classes, escaped sequences, repetition operators
({n}/?/(cid:63)/+/) and sub-match extraction using capturing parentheses.
3. MOTIVATING EXAMPLES
In this Section, we present two simpliﬁed examples to position
our work against the state-of-the-art.
In Fig. 3 we start with an example of a regular-expression-based
input validation function. The ﬁrst column is the JavaScript func-
tion used to validate the two input ﬁelds, namely p1 and p2. This
function ensures that p2 is not an empty string and p1 and p2 must
belong to the regular expressions re1 and re2, respectively.
Now we want to prove that, given the inputs which have passed
the validation function, the output res, that is constructed by con-
catenating p1 with p2, is different from a speciﬁed bad string
nM = “ababababababcc”. Ultimately, the above question is reduced
to the problem of deciding the satisﬁability of the generated con-
straint formula, presented in the second column of Fig. 3. The proof
succeeds if the formula is unsatisﬁable4.
This requires reasoning about string equation res=p1·p2, mem-
bership predicates p1 ∈ (“ab”)(cid:63) and p2 ∈ (“bc”)(cid:63), and length
constraint length(p2) > 0.
In short, it becomes a complicated
problem involving strings, non-strings and their combinations (e.g.,
length constraints). Now, let us discuss how existing solvers would
deal with this particular problem.
HAMPI [22], and other solvers [10, 31, 20, 34, 2, 38, 19, 32, 13,
18], which work in the string domain only, cannot handle this ex-
ample. Since they only support string operations, they are not able
to handle non-string constraints, and particularly length constraints
that are related to both string and non-string domain and cannot be
captured in each individual one.
On the other hand, the solvers Kaluza [28], [6] and Z3-str [39]
are in the same category as ours, and can reason about strings and
non-strings simultaneously. Since [6] is similar to Kaluza in many
ways, we will just focus on Kaluza here. Kaluza is the string solver
4Otherwise, the solver should return satisfying assignments, repre-
senting a potential bug/vulnerability of the system.
used in a JavaScript dynamic test generation framework [28]. To
support a wider range of constraint types including integer, boolean
and string, it extends both STP [22] and HAMPI.
One major drawback of Kaluza is that it requires the lengths of
string variables to be known prior to being able to encode them and
query the underlying SMT solvers. In particular, before solving for
string constraints, Kaluza ﬁnds a set of satisfying solutions for each
string length. For each possible length, it encodes each string vari-
able as an array of bits and then queries a bit-vector solver. Kaluza
is unable to reuse the encodings and the result of bit-vector solver
in previous calls, which induces the overall high cost of repetitive
encoding and querying external solvers.
For the example at hand in Fig. 3, Kaluza ﬁrst needs to come
up with a set of satisfying solutions for the lengths of p1 and p2,
each denoted by a pair (cid:104)l1; l2(cid:105), where l1 is the length of p1 and l2
is the length of p2. In this case, the set of satisfying solutions for
the lengths is {(cid:104)0; 12(cid:105),(cid:104)2; 10(cid:105),(cid:104)4; 8(cid:105),(cid:104)6; 6(cid:105),(cid:104)8; 4(cid:105),(cid:104)10; 2(cid:105)}. For
each possible length solution, Kaluza encodes the string variables,
and then queries the external bit-vector solver, before ﬁnding out
that the original set of constraints is unsatisﬁable. Overall, Kaluza
needs to encode and query bit-vector solver 6 times.
Let us not have the impression that, in general, the number of
satisfying solutions for the string lengths should be of this linear
complexity. In fact, practical applications involve many string vari-
ables, Kaluza approach, i.e., generate-and-test, would easily suffer
from a combinatorial explosion.
Z3-str [39] cannot handle regular expressions, thus also cannot
handle this example. However, it can be considered the ﬁrst SMT-
based string solver. Instead of relying on other theories, it builds a
string theory for itself and allows this string theory to be plugged
into a modern and powerful solver – Z3 [11]. Thus an important
contribution of Z3-str is that string and non-string constraints are
now solved simultaneously, in an incremental manner.
Inspired by Z3-str’s design, our target is to build a string theory
that can interact with other theories via Z3. Nevertheless, we want
to support a powerful input language, which is especially demanded
for testing and analysis of practical web applications.
There are two key technical challenges: (1) how to incrementally
handle the Kleene star, which is the heart of the issue in reasoning
about regular expressions; (2) how to incrementally handle high-
level string operation such as replace, whose semantics is most
naturally deﬁned by recursive rules. Our solution therefore is to
employ, in our string theory, recursively deﬁned functions whose
semantics will be lazily unfolded during the process of incremen-
tal solving. Such approach resembles the constrain-and-generate
technique (to contrast with generate-and-test) in the literature of
constraint solving.
We elaborate later with a technical description in Section 5. But
now let us give some intuitions on how we approach this exam-
ple. Internally, we represent membership of regular expression as
equation involving a symbolic representation of the Kleene star. In
particular, p1∈(“ab”)(cid:63) is represented as p1=star(“ab”,n1) and
similarly p2∈(“bc”)(cid:63) is represented as p2=star(“bc”,n2). By
rewriting, we would derive the following equation:
star(“ab”,n1) · star(“bc”,n2) = “ababababababcc”
Since the length of p2 is positive and the RHS is a constant
string, this would force the unfolding of expression star(“bc”,n2)
to star(“bc”,n2-1) · “bc”. A conﬂict is then derived since the
LHS string ends with “bc” while the RHS string ends with “cc”.
Our system then can conclude that the input formula is UNSAT.
x = x1 · x2 ∧ z = y · z3 ∧ y = z1 · z2 ∧ z2 = “_” ∧
l1 = length(x1) ∧ l2 = length(z1) ∧ l1 = l2 + 1 ∧
x = z ∧ indexOf (y, “a”) = 3 ∧ indexOf (x1, “a”) = 4
Figure 4: A Frequent Constraint Pattern
Now let us dissect Z3-str more carefully. Fig. 4 presents an input
example for Z3-str, a pattern which is commonly found in many
benchmarks extracted from [28]’s comprehensive set of JavaScript
applications (e.g. big2). Starting with the fact that z2 is a constant
string of one character, Z3-str is able to deduce that z2 is of length
1. This constraint will be fed into the arithmetic theory. Similarly,
the arithmetic theory would receive the information that y’s length
is the sum of z1’s length and z2’s length. Since, from the input, the
length of x1 equals to the length of z1 plus 1, the arithmetic theory
can deduce that x1 and y are of the same length. However, this
information will never be passed back to the string theory.
As discussed in [39], the current design of Z3 enforces that the
plug-in theory, namely Z3-str, to be disjoint from Z3’s arithmetic
theory. Being a plug-in, however, means there is supervisory con-
trol over Z3-str which can feed length information to the arithmetic
theory so that early conﬂicts can be detected and exploited. But,
importantly, partial information derived by the arithmetic theory
will not be fed back to Z3-str. This is the source of Z3-str’s inefﬁ-
ciency in many cases.
Returning to the example, if the information that x1 and y are
of the same length is propagated back to the string theory, together
with the fact that x1 and y are preﬁxes of the two equal strings x
and z, our string theory can derive that x1 and y are equal, there-
fore proceed the search much more efﬁciently. In Section 4.2, we
discuss our new design in order to overcome this drawback, there-
fore even when restricted to the same input language as of Z3-str,
our tool, S3, does advance the concept of incremental solving to
the next level.
4. DESIGN OF S3
Here we present the design of S3. This design is inspired by
Z3-str [39], and thus inherits its two main advantages. First, we
support the primitive type of string so that there is no need to con-
vert strings to other representations, e.g., bit-vectors. As a result,
we can support string variables whose lengths can be unknown, es-
pecially in the context of static analysis. Second, we leverage the
power of Z3 in dealing with multiple theories, and this ultimately
leads to the capability of reasoning on string and non-string con-
straints simultaneously and efﬁciently. We ﬁrst give an overview
of Z3-str, focusing on how it interacts with the core of Z3. Later
we describe our design of S3, along with the improvement of the
corresponding component Z3-str-star over Z3-str.
4.1 Overview of Z3-str
Z3-str acts as a plug-in string theory for a SMT solver Z3 [11].
The architecture of Z3 is shown in the shaded box of Fig. 5. Its
Figure 5: The Design of S3
the congru-
core component consists of the following modules:
ence closure engine, a SAT solver-based DPLL layer, and several
built-in theory solvers, such as integer linear arithmetic, bit-vectors,
etc. The congruence closure engine can detect equivalent terms
and then classify them into different equivalence classes, which are
shared among all built-in theory solvers. The SAT-based DPLL
layer is responsible for handling the boolean structure of the input
formula.
assert ((e1 ∨ e2) ∧ e3 ∧ e4)
e1 : x = “abc” · m e2 : x = “ef gh”
e3 : y = “ef g” · n
e4 : x = y
Consider the assertion above. The core component cannot inter-
pret the string operations; instead it treats them as four independent
boolean variables (e1, e2, e3 and e4) and tries to assign boolean
values to them. We now walk through the process of how Z3’s core
component and the string theory solver interact.
Fact added
Eq-class
1 y=“ef g”·n {y,“ef g”·n}
{x,y}
2 x=y
{y,“ef g”·n}
{x,“abc”·m,
y,“ef g”·n}
3 x=“abc”·m
4 x=“ef gh”
{x,“ef gh”,
y,“ef g”·n}
Reduction/Action
• conﬂict detected
• backtrack and remove facts
• try another option for e1
“ef gh”=“ef g”·n ⇒ n=“h”
SAT solution: x = “ef gh”, y = “ef gh”, n = “h”
Table 2: How Z3-str Interacts with Z3 and Its Backtracking
In Table 2, initially there is no fact. The core starts by setting