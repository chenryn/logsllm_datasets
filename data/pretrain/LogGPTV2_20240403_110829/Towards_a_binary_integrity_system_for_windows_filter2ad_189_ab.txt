binaries to be loaded or executed. In these systems, signa-
ture of binaries are either embedded in the (cid:12)les themselves
or signed by a third party, such as the administrator and
stored in a secure database. Executing or loading are only
allowed if the signature can be veri(cid:12)ed.
There are three basic problems with signed binaries. First-
ly, the security relies on the trust of the signing keys. If key is
leaked, the trust is broken. For example, the Stuxnet worm
[6] uses signed drivers with real certi(cid:12)cates which are trusted
by Windows. Secondly, revocation checking is expensive as
it cannot be done locally and furthermore may not be timely.
Lastly, we cannot assume that all software vendors sign their
binaries. A more important di(cid:11)erence is that most signed
binary schemes are not intended to deal with the software
lifecycle issues which we are concerned with. Another dif-
ference is that signed binaries only ensures that the binaries
are not modi(cid:12)ed but may not prevent deletion.
Self-signed executables
3.2.1
Self-signed executables [2] is a di(cid:11)erent approach to signed
binaries which allows for software updates. In their proposal,
all binaries are embedded with their signatures signed by the
software vendor. Unlike the previous signed binary systems,
the assumption is that any binary which has been signed can
be trusted. Using the observation that binaries are usually
updated by a newer version from the same vendor as the
original, binary updating is allowed if the signature can be
veri(cid:12)ed with the same public key.
The self-signed executables system binds paths with keys.
Once bound, the key cannot be changed, even when the (cid:12)le
is removed. An attacker can also sign malware as long as it
is the (cid:12)rst software installed with that path. Alternatively,
this can constitute a denial of service attack since an attacker
binding the path (cid:12)rst would disallow future correct software
to be installed at that path. As deleted (cid:12)les leave behind a
stub, the number of stubs will monotonically increase over
time. This can lead to yet another denial of service attack
to exhaust storage.
In order to compare the signatures between the old and
new copy, semantics of (cid:12)le writing has to be changed such
505
that writing is applied on a shadow copy and later updated
atomically. This can break software that assumes normal
POSIX semantics.
4. THE BinInt SECURITY MODEL
In Sec. 3, we discussed a number of existing security mod-
els. While those models can be used to provide security
for binaries, the main drawback is that they do not cov-
er the usage spectrum across the software lifecycle nor do
they handle all the typical attack scenarios mentioned. We
now present a new security model for binaries which we cal-
l BinInt. This model combines (cid:12)le integrity together with
aspects of signed binaries and isolation to give a binary se-
curity mechanism which addresses usability in the software
lifecycle. We remark that while we focus on Windows, this
model has general applicability to other operating systems.
We are cognizant that a security mechanism should pro-
vide the desired form of protection in practice for the in-
tended system usage. Full two-way isolation protects the
host against malware in the VM but may not protect a-
gainst other attacks. More importantly, it does not protect
the software running in the VM from malware. This is why
our model combines a number of features together to provide
binary integrity. We focus solely on integrity and security
of binaries as want to preserve compatibility with existing
software (in Windows) while allowing implicit sharing. Our
model should not be considered as a sole security mechanis-
m and is meant to be used with other security mechanisms,
e.g. ACLs or MAC, IDS, etc.
Our goals are three fold. Firstly, to prevent attacks ex-
ploiting vulnerabilities which load untrusted binaries. Sec-
ondly, to ensure integrity of binaries. This both prevents
malware from being installed on the system and prevents
denial of service attacks which delete binaries. Thirdly, we
want to achieve a middle ground between usability and secu-
rity. Any changes to system usage should not be onerous and
existing software should (mostly) be able to run, including
closed source binaries. While it is impossible to guarantee
that all unmodi(cid:12)ed software can still function normally to-
gether with a security mechanism, our goal is that it should
work in practice for typical software. Thus, frequent tasks,
such as running and updating benign software, should be
(mostly) transparent. Other infrequent tasks, such as soft-
ware installation and removal, can be a little di(cid:11)erent but
should not cause much inconvenience. As the mechanism
should be applied to all processes, it should only have small
overheads especially for frequent tasks.
We now describe our BinInt model. All processes are in
one of the following execution modes: d-mode (default mod-
e), i-mode (install mode) and t-mode (temporary trusted
mode). Intuitively, d-mode corresponds to running already
installed software, while i-mode is for installing/updating
software. Special cases for running software which needs to
dynamically create and load binaries but is not a software
install are handled by t-mode, e.g. building and running
binaries in an IDE or dynamic temporary binaries as in Sys-
internals tools.
Each process and binary is labeled with a software do-
main, which relates the process or binary to a particular
installed software. The idea is that we may use the name
of a particular software or the software vendor as the soft-
ware domain. A special software domain ? denotes binaries
which do not have a valid software domain. Binaries whose
software domain is not ? are called b-valid.
We now describe the rules. Creating a binary in i-mode
sets its label to the software domain of the process and to
? otherwise in d-mode or t-mode. A binary can only be
written to or deleted in i-mode provided it has the same
software domain as the process or it is ?.
In d-mode or
t-mode, only binaries whose label is ? can be written to.
There are no restrictions on the read operation as it has no
e(cid:11)ect on binary loading and integrity.
A binary can be loaded/executed in d-mode only if it is
b-valid. As t-mode and i-mode need to use new binaries,
there are no restrictions on loading/execution. Rather the
restriction is on the privilege needed to change to t-mode or
i-mode. The mode and software domain is preserved when
In our model, except for ?, the
creating a new process.
software domain is only used in i-mode.
In order to change the mode of a process, we de(cid:12)ne a spe-
cial operation, called modetrans. Modetrans is meant to be
a privileged operation, and as such, requires user authen-
tication and appropriate privileges, i.e. similar to sudo in
Unix or UAC in Windows. As i-mode, is meant for new
software, the user (or the execution mode policy) needs to
also specify what is the (new) software domain. Note that
our model assumes all (cid:12)les are typed as binary or not, which
means that binary (cid:12)les can only be written as data (cid:12)les in
i-mode. This is not a signi(cid:12)cant restriction since binaries
have a special format and are usually created/written to in
a special context where there is an easy correspondence to
one of our modes.
It is easy to map BinInt to the scenarios in Sec 2.2. In-
stalled software normally runs in d-mode; software install/up-
date/uninstall employ i-mode; and special cases like the IDE
run in t-mode. The attacks discussed cannot run in d-mode
as the software domain would be ?. The PDF vulnerability
attack is prevented since Acrobat Reader runs in d-mode
and thus cannot execute the executable (cid:12)le created. The
DLL attacks are also prevented for the same reasons.
4.1 Using BinInt in Windows
When the system is booted, the initial process(es) run in
d-mode. We enhance BinInt with an additional execution
mode policy (de(cid:12)ned by a protected con(cid:12)guration (cid:12)le). The
execution mode policy is to simplify system usage by pre-
de(cid:12)ning special cases where the operation of modetrans can
be performed automatically. It speci(cid:12)es the path of an ex-
ecutable to have a speci(cid:12)c mode and software domain. We
require that the executable should be b-valid so it is not pos-
sible to use an arbitrary executable. If no such a mapping is
found in the policy, it inherits the mode and domain of its
parent process, e.g. d-mode and ?.
We have implemented a command-line modetrans utility
which (cid:12)rst authenticates the user, i.e. using a password. It
then executes a user-speci(cid:12)ed program in a user-speci(cid:12)ed
mode and in the case of i-mode, also the speci(cid:12)ed software
domain. One could implement a shell extension integrated
with the Windows Explorer to be more GUI friendly.
Both the execution mode policy and modetrans are used
to run an executable in a speci(cid:12)ed mode and domain. The
policy is preferred if the executable should always run in that
execution mode and software domain. For example, since
the Windows auto-updater wuauclt.exe should always run
in i-mode and with sofware domain \microsoft", the policy
should map C:\windows\system32\wuauclt.exe to i-mode
506
workload
environment
build
archive
javascript
base
d-mode
t-mode
i-mode
base
d-mode
t-mode
i-mode
base
d-mode
t-mode
i-mode
running time
59:0 (cid:6) 2:0s
58:7 (cid:6) 1:8s
59:8 (cid:6) 1:3s
60:3 (cid:6) 1:9s
41:4 (cid:6) 1:4s
40:0 (cid:6) 2:2s
42:2 (cid:6) 0:8s
46:1 (cid:6) 1:1s
1257:7 (cid:6) 21:1ms
1257:3 (cid:6) 25:2ms
1249:5 (cid:6) 26:1ms
1247:9 (cid:6) 15:8ms
overhead
(cid:0)0:5%
1:4%
2:2%
3:4%
2:0%
11:4%
(cid:0)0:0%
(cid:0)0:7%
(cid:0)0:8%
Table 1: BinInt overhead
and \microsoft" software domain.
5.
IMPLEMENTATION AND EVALUATION
We implemented a prototype of BinInt in Windows XP.
It is implemented with a kernel driver that intercepts binary
loading, (cid:12)le modi(cid:12)cation, process creation and some other
operations. We evaluate the performance of BinInt against
a baseline system with a vanilla unmodi(cid:12)ed Windows XP
SP3. The benchmarks are run in a VMWare virtual ma-
chine on a Intel Core 2 Duo 2.33GHz CPU (with one core
allocated to VMWare) and 512MB memory. We use the fol-
lowing benchmarks: software build (building putty, a SSH
client, with 86 C (cid:12)les) using the Visual Studio command
line interface; WinRAR archive extraction (extracting the
Linux kernel source code); and the SunSpider JavaScript
Benchmark in Firefox. The (cid:12)rst two benchmarks are chosen
to test process creation and (cid:12)le I/O in a realistic setting.
The last benchmark is chosen to be representative of a more
intensive CPU workload. Each benchmark is run 5 times to
obtain the runtimes (mean and standard deviation) in the
base system (without BinInt) and BinInt in all three modes.
Table 1 shows the runtimes. Except for the archive ex-
traction test in i-mode, the average overheads are small. In
most cases, the overhead is smaller than the standard devi-
ation (caused by environmental factors such as caches, etc.,
and in some others it is even negative (slightly faster)). The
results show that with the exception of the archive test, the
overhead of BinInt is negligible and within timing variation.
The 11:4% overhead in the i-mode archive benchmark
shows the overheads of i-mode when the workload is mostly
(cid:12)le creation and writing of many (small) (cid:12)les. Although the
extracted (cid:12)les are not binaries, BinInt has to check whether
or not they are binaries. As software installation should not
be a frequent task, we are less concerned with e(cid:14)ciency of
i-mode as long as it is still reasonable.
6. DISCUSSION AND CONCLUSION
BinInt focuses on binaries. However, securing only bina-
ries may not be su(cid:14)cient. For example, the attacker can
modify Java class (cid:12)les to change the behaviour of java pro-
grams. The same applies to shell scripts and con(cid:12)guration
(cid:12)les. We can generalize BinInt to protect the integrity of
any kind of (cid:12)le. The di(cid:14)culty is that data (cid:12)les are much
more dynamic than binaries. Unlike binaries which are only
changed during install, update and removal of the software,
data (cid:12)les are usually changed much more frequently. This
makes direct use of d-mode for data (cid:12)les unusable. More
(cid:12)ne grained policies can be applied for data (cid:12)les. This is
currently work in progress.
We have presented a binary security model which cater-
s to the dynamic use of binaries within the software life
cycle while protecting against attacks in default mode and
giving isolation between software domains in install mod-
e. Our prototype is e(cid:14)cient and usable while protecting
a broad range of binary loading/execution mechanisms in
Windows. We found our system to be mostly transparent in
usage on typical Windows software throughout its software
lifecycle. Thus, BinInt is a practical solution which gives a
good tradeo(cid:11) between usability and security to protect bi-
naries on Windows. Our model can also be combined with
other security mechanisms.
7. REFERENCES
[1] A. Apvrille, D. Gordon, S. Hallyn, M. Pourzandi and
V. Roy, DigSig: Run-time Authentication of Binaries
at Kernel Level, USENIX Large Installation System
Administration Conf., 2004.
[2] G. Wurster and P.C.V. Oorschot, Self-Signed
Executables: Restricting Replacement of Program
Binaries by Malware USENIX Workshop on Hot
Topics in Security, 2007.
[3] D. Stevens, Escape From PDF, http://blog.
didierstevens.com/2010/03/29/escape-from-pdf
[4] http://www.cve.mitre.org/cgi-bin/
cvename.cgi?name=CVE-2010-0483
[5] http://www.microsoft.com/technet/security/
advisory/2269637.mspx
[6] A. Matrosov, E. Rodionov, D. Harley and J. Malcho,
Stuxnet Under the Microscope,
http://www.eset.com/resources/whitepapers/
Stuxnet_Under_the_Microscope.pdf
[7] Y. Wu, R.H.C Yap and R. Ramnath, Comprehending
Module Dependencies and Sharing, Intl. Conf. on
Software Engineering, 2010.
[8] L.V. Doorn, G. Ballintijn and W.A. Arbaugh, Signed
Executables for Linux, CS-TR-4256, U. of Maryland,
2001.
[9] K. Kato and Y. Oyama, SoftwarePot: an encapsulated
transferable (cid:12)le system for secure software circulation,
Intl. Symp. on Software Security, 2003.
[10] Z. Liang, W. Sun, V. Venkatakrishnan and R. Sekar,
Alcatraz: An Isolated Environment for Experimenting
with Untrusted Software, ACM Trans. on Information
and System Security, 2009.
[11] F. Halim, R. Ramnath, Sufatrio, Y. Wu and R.H.C.
Yap, A Lightweight Binary Authentication System for
Windows, Joint iTrust and PST Conf. on Privacy,
Trust Management and Security, 2008.
[12] S. Nanda, W. Li, L.C. Lam and T.C. Chiueh, Foreign
Code Detection on the Windows/X86 Platform,
Annual Computer Security Applications Conf., 2006.
[13] Safari Carpet bomb, http://www.oreillynet.com/
onlamp/blog/2008/05/safari_carpet_bomb.html
[14] M. A. Williams, Anti-Trojan and Trojan Detection
with In-Kernel Digital Signature testing of
Executables, 2002.
507