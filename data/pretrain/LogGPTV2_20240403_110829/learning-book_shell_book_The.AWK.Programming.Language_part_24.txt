for（=i;j>1eft&6deck[j-1]39 &4card26&4card13 64card paeoi1.=sqto)
dnds = dnds "
fvcard(deck[card])
for
clbs = clbs "
*fvcard(deck[card])
funetion fvcard(i)(
if (f % 13 =0) return “A"
# compute face value of card 1
else if (i % 13 e 12) return
else if (1 % 13 ee 11) return
"K"
else if (1 x 13 =s 10) return “j*
"Q"
else return (i % 13) + 1
---
## Page 210
200
ANSWERS TO SELECTED EXERCISES
APPENDIX B
Exercise 5-5. Doing an intelligent job on this is hard. Simplest is to keep track of how
too many. Slightly more complex would be to try, in gen, only to derive the empty
string or terminals, once the derivation becomes too long. Unfortunately, this won’t
work on every grammar every time. One guaranteed method requires knowing the short-
est output each nonterminal can produce, and forcing that when the derivation becomes
too long. This requires substantial processing of the grammar, and some specialized
knowledge. 
Exercise 5-6. We add a probability to the end of each production. These probabilities
are first read into the array rhsprob. After the grammar has been read, rhsprob is
changed so that it represents the probability of this or any previous production, rather
than this production. This makes the test in gen a little simpler; otherwise the probabil-
ities would have to be be summed over and over again.
sentgen1 -randon sentence generator vith probabilities
input: grammar file; sequence of nonterminals
output: randon sentences generated by the gramear
BEGIN (read rules from graanar file
vhile （getline0)
=++lhs[s1]
rhsprob[#1,1]=sNP
count lhs
rhscnt[s1, 1] =NP-3
0 rhsprob[sym, i]; i++)
5 = rand()
randon production
for（1=1;j 0)
if（$2=*->）{
i= *+1hs[$1]
rhscnt[$1,1]=NF-2
hov many in rhs
count 1hs
for（j=3:j
rhslist[$1, 1, j-2]= s}
= 1;j--)expandxhs′s
randon production
push(rhslist[uym,1,3))
1else
(ufs*,9%。13xuxd
function push(s) ( stack[++stp] = s }
function pop()(return stack[stp--])
口
Exercise 5-9. The easiest solution is to create an initial random permutation of the
integers from 1 to nq, then ask the questions in that order. 
Exercise 5-10. The cleanest way to do case conversion in awk is with an array that
maps each letter; this is pretty clumsy, however, so if you have a choice it's better to use
a program like the Unix command tr. D
Exercise 5-13. We accumulate the words into an array. If there are cnt words to be
printed on a line, then there are cnt1 holes to fill with spaces. If there are n spaces
needed, each hole should have an average of n/(cnt=1) spaces. For cach word, the
program computes this number, then decrements the number of holes and spaces. If the
extra blanks do not distribute evenly. the surplus ones are spread alternately from the
left and from the right on successive lines, to avoid “rivers" of white space.
---
## Page 212
202
ANSWERS TO SELECTED EXERCISES
APPENDIX B
fnt.just - fornatter vith right justification
/*$/
1.1
{for（1=1;160)
printline(*yes*)
size += length(v)
line[++cnt] = v
function printline(f,
1,nb, nsp,holes）{
for (1 = 1;i 1){
printf("%s%s",line[i],1 0; i++) {
nsp=int（（nb-dir)/holes）+dir
printf(“%s%s*, 1ine[i], substr(blanks, 1, nsp))
nb == nsp
hole8-*
print line[ent]
size = cnt =0
A “no" argument to printline avoids right-justifying the last line of a paragraph. 
Exercise 5-15. It depends on whether the defective name appears anywhere else in the
document. If it does, it will be erroneously substituted away. 
Exercise 5-16.
/\.#/{printf（°(gsab(/%s/,\"%d\*)}n",$2,++count[81])
if (saw[$2])
print NR
*:redefinition of°,s2,*from line*,sav[s2]
saw[$2] = NR
END
（,u/#1/11xauzd}
口
Exercise 5-18.
/*\.#/(s[s2]=++count[s1]:next)
(for (i in s)
print
gaub(1, s[1])
The definition of a symbolic name must come before it is used. C
add a filter to the pipeline to delete rotated lines that begin with a word from the stop
list:
---
## Page 213
ANSWERS TO SELECTED EXERCISES
APPENDIXB203
avk *s11-/(alanlandbyforiflinisloflonithelto)s/*1
sort -f 1
口
Exercise 5-23. How to distinguish between a literal - and the - used as a space is a
question of style. We will use the awk escape sequence convention: \ before the charac-
ter when we want the literal character. We'll consider only *: the others are just ela-
borations in both ix.genkey and ix.format. For ~, we replace all instances of \
by some string that cannot occur, namely a tab followed by 1. No string containing a
tab can occur, because tab is the field separator. The remaining tildes are substituted
away, and the escaped ones are put back, unescaped. Thus, the first gsub in
Ix,genkey is replaced by
gsub（^-/,*\t1°,$1)
protect quoted tildes
gsub(/-/,,s1)
gsub（/\t1/,*",s1)
unprotected tildes nov becone blanks
restore protected tildes
Also, the tildes should no longer be removed from the sort key. 
Exercise 6-1. Only four lines have to be added, two in pass I and two in pass 2.
ASSEMBLER PASS 1
nextmem=0
nev
while （getline 0）(
FS = "[ \t]+"
input[nextnem]= $0
sub(/#.+/,
nev: remenber source line
syatab[$1]=nextmem
remenber label 1ocation
strip comnents
1f（$21=*"）（
print $2"\t"$3>tenpfile
save op, addr if present
nextaen++
close(tenpfile)
+
ASSEMBLER PASS 2
vhile（getline 0)(
nextmem=0
if（$21-/~[0-9）#/)1fsymbolicaddr，
$2=syatab[$2]
replace by nuneric value
mem[nextmen++]= 1000+op[$1]+$2pack into word
for（i=0;1 A[1+ 1] is essentially the invariant that is enforced
by the algorithm, so it should be true automatically. The real problem is that check
are moved outside of the proper array bounds. 
Exercise 7-3. As described briefly in Chapter 8, awk uses a hash table to store arrays.
These hash tables allow constant-time lookup of elements in small arrays, but take more
time as the arrays grow. 
Exercise 7-8. The END action inserted by makeprof is executed after any other END's
d y wd s dos p  oeo ue u ax ue os sd   e
fix is to change makeprof to print its END action before anything else. 
Exercise 7-10. Again, push the nodes onto a stack instead of printing them, then print
the stack from the bottom after the end of the input. Alternatively, reverse the roles of
$1 and $2, either in rtsort or by a separate program. 
---
## Page 215
INDEX
SAND pertor 10,3137,158
arith
46
/dev/ttyfile59
bbacksre
aay16.50
ional 52, 108,
(...} bra
nt 15,22,188
15,22,47,167,188
comparisonoperator9
62, 64
instroctioms, table of
tion81
132
187,195,197
d-line 63, 94,
112
atiation operator 15, 36,
defalt 5, 9, 21, 187
assign
39
38
o
on43,72,189
158
Alerhi,1.vi
Aho,S.vi
25, 27, 31, 37,
tlgot
 depth-first search 172.
40
nch operator 25, 27, 31,
177
1*
awk:
187
183
awk gran
awk prog
ar_148
fom o2.21.187
.regular expe
algori
qicksor160
awk program, running an 3
28,119
ANE
()regular ex
ARGC varisble 36, 63, 189
avk.parser program 149
63
expre
41.43
regularex
29.32
iers 77, 195
arith
116
145
ic functioms,
nary of
23, 169
35
1 7, 24, 35, 51
190
c funct
s, table of 39
205
---
## Page 216
206
THE AWK PROGRAMMING LANGUAGE
INDEX
sd vho 62
dank line,
9
187,195, 197
63,94,
39,70,
break statement
37
os espression, value ef
bridgeprogram
tobie ef 36
comparison, numeric 25-26, 44
ndle program 81
delete stu
213.3
calc1program
9, 44
ca1c2progm
146
p
er class 29
177
59,64
comple
39
do49
29
expre
dyn
ar expression 40,
characters,table ofs
scape 31
oon:
182
 operat
tor 40, 43,
ehmputatin of 39
prommsd 59, 181, 184,
6
oonstant,
79
n before 47
74
148
and 23, 169
65
afer,22.188
haodc
clicheprogram
112
3,2
coni
44,154,182
con: