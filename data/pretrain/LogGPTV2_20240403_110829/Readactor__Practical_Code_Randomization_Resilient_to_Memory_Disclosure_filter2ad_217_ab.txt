Trampolines
Code
page 1
⠇
Code
page n
Code-pointer hiding
Kernel with Readactor Patch
using Page Table Virtualization (EPT)
Figure 2: System overview. Our compiler generates diversiﬁed
code that can be mapped with execute-only permissions and
inserts trampolines to hide code pointers. We modify the kernel
to use EPT permissions to enable execute-only pages.
V. READACTOR DESIGN
Overview: Readactor protects against both direct and
indirect disclosure (see Section III). To handle attacks based
on direct disclosure, it leverages the virtualization capabilities
in commodity x86 processors to map code pages with execute-
only permissions at all times. Hence, in contrast to previous
related work [7], the adversary cannot read or disassemble a
code page at any time during program execution. To prevent
indirect disclosure attacks, Readactor hides the targets of all
function pointers and return addresses. We hide code pointers
by converting these into direct branches stored in a dedicated
trampoline code area with execute-only permissions. Code-
pointer hiding allows the use of practical and efﬁcient ﬁne-
grained code randomization, while maintaining security against
indirect memory disclosure.
Figure 2 shows the overall architecture of Readactor. Since
our approach beneﬁts from precise control-ﬂow information,
which binary analysis cannot provide, we opt for a compiler-
based solution. Our choice to use a compiler also improves the
efﬁciency and practicality of our solution. In particular, our
technique scales to complex, real-world software: the Chromium
web browser and its V8 JavaScript engine (see Section X).
However, diversiﬁcation could instead be done at program load-
time, protecting against theft of the on-disk representation of
the program.
As shown on the left of Figure 2, our compiler converts
unmodiﬁed source code into a readacted application. It does
so by (i) separating code and data to eliminate benign read
accesses to code pages, (ii) randomizing the code layout,
and (iii) emitting trampoline code to hide code pointers from
the adversary. The right side of Figure 2 illustrates how our
patched kernel maps all executable code pages with execute-
only permissions at runtime. We do not alter the permissions
of data areas, including the stack and heap. Hence, these are
still readable and writable.
Code-Pointer Hiding: In an ideal ﬁne-grained code ran-
domization scheme, the content and location of every single
instruction is random. Execute-only pages offer sufﬁcient protec-
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:06:24 UTC from IEEE Xplore.  Restrictions apply. 
Data pages (readable-writeable)
Function pointer 1 
Code page (execute-only)
Readactor
Trampolines
Return address
Trampoline A
Stack / Heap
Trampoline B
Code page (execute-only)
Function A:
asm_ins
asm_ins
JUMP Trampoline B
Call_Site_B:
...
Data reference to code
Code reference to code
Figure 3: Readacted applications replace code pointers in
readable memory with trampoline pointers. The trampoline
layout is not correlated with the function layout. Therefore,
trampoline addresses do not leak information about the code
to which they point.
Virtual 
Memory
CODE
Page 1
DATA
Page 2
Page
Table
read-
execute
read-write
Guest 
Physical
Memory
Page 1
…
Page 2
…
EPT
execute-
only
…
read-write
…
Host 
Physical
Memory
Page 1
…
Page 2
…
Figure 4: Relation between virtual, guest physical, and host
physical memory. Page tables and the EPT contain the access
permissions that are enforced during the address translation.
tion against all forms of memory disclosure at this granularity,
since indirect disclosure of a code address gives the adversary
no information about the location of any other instruction.
However, ideal ﬁne-grained randomization is inefﬁcient and
does not allow code sharing between processes. Hence, practical
protection schemes randomize code at a coarser granularity to
reduce the performance overhead [40]. Efﬁcient use of modern
processor instruction caches requires that frequently executed
instructions are adjacent, e.g.,
in sequential basic blocks.
Furthermore, randomization schemes such as Oxymoron [6]
that allow code pages to be shared between processes lead to
signiﬁcantly lower memory usage but randomize at an even
coarser granularity (i.e., page-level randomization).
To relax the requirement of ideal ﬁne-grained code random-
ization, we observe that indirect JIT-ROP relies on disclosing
code pointers in readable memory. The sources of code pointers
in data pages are (i) C++ virtual tables, (ii) function pointers
stored on the stack and heap, (iii) return addresses, (iv) dynamic
linker structures (i.e., the global offset table on Linux), and
(v) C++ exception handling. Our prototype system currently
handles sources (i)-(iv); protecting code pointers related to C++
exceptions is an ongoing effort requiring additional compiler
modiﬁcations which we discuss in Section VII-C.
Figure 3 illustrates our high-level technique to hide code
pointers from readable memory pages. Whenever the program
takes the address of a code location to store in readable memory,
we instead store a pointer to a corresponding trampoline.
Function pointers, for example, now point to trampolines
rather than functions. When a call is made via Function
pointer 1 in Figure 3, the execution is redirected to a
Readactor trampoline (Trampoline A), which then branches
directly to Function A.
Because trampolines are located in execute-only memory
and because the trampoline layout is not correlated with
the layout of functions, trampoline addresses do not leak
information about non-trampoline code. Hence, trampolines
protect the original code pages from indirect memory disclosure
(see Section VII-C for details). This combination allows us to
use a more practical ﬁne-grained randomization scheme, e.g.,
function permutation and register randomization, which adds
negligible performance overhead and aligns with current cache
models.
For a more detailed pictorial overview of the design
of Readactor, see Appendix A. In the following sections,
we describe each component of Readactor in detail. First,
we describe how we enable hardware-assisted execute-only
permission on code pages (Section VI). We then present
our augmented compiler that implements ﬁne-grained code
randomization and code-pointer hiding (Section VII). Finally,
in Section VIII we explain how we extended our approach to
also protect just-in-time compiled code.
VI. READACTOR – EXECUTE-ONLY MEMORY
Enforcing execute-only memory for all executable code is
one of the key components of our system. Below we discuss
the challenges of implementing hardware enforced execute-only
memory on the x86 architecture.
A. Extended Page Tables
The x86 architecture provides two hardware mechanisms to
enforce memory protection: segmentation and paging. Segmen-
tation is a legacy feature and is fully supported only in 32-bit
mode. In contrast, paging is used by modern operating systems
to enforce memory protection. While modern x86 CPUs include
a permission to mark memory as non-executable [4, 35], it
used to be impossible to mark memory as executable and non-
readable at the same time. This changed in late 2008 when
Intel introduced a new virtualization feature called Extended
Page Tables (EPTs) [35]. Modern AMD processors contain a
similar feature called Rapid Virtualization Indexing.
Readactor uses EPTs to enforce execute-only page per-
missions in hardware. EPTs add an additional abstraction
layer during the memory translation. Just as standard paging
translates virtual memory addresses to physical addresses, EPTs
translate the physical addresses of a virtual machine (VM)—the
so-called guest physical memory—to real physical addresses
or host physical memory. The access permissions of each
page are enforced during the respective translations. Hence,
the ﬁnal permission is determined by the intersection of the
permissions of both translations. EPTs conveniently allow us
to enforce (non-)readable, (non-)writable, and (non-)executable
memory permissions independently, thereby enabling efﬁcient
enforcement of execute-only code pages.
Figure 4 shows the role of the page table and the EPT during
the translation from a virtual page to a host physical page. In
this example, the loaded application consists of two pages: a
code page, marked execute-only, and a data page marked as
readable and writable. These page permissions are set by the
766
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:06:24 UTC from IEEE Xplore.  Restrictions apply. 
compiler and linker. If a code page is labeled with only execute
permission, the operating system sets the page to point to a
page marked execute-only in the EPT. Note that access control
is enforced for each translation step. Hence, a read operation
on the code page is allowed during the translation of the virtual
to the guest physical page. But, when the guest physical page is
translated to the host physical page, an access fault is generated,
because the EPT permission is set to execute-only. Similar to
the access permissions of a standard x86 page table, the EPT
permissions cannot be bypassed by software. However, EPTs
are only available when the operating system is executing as a
virtualized guest. The next section describes how we addressed
this challenge.
B. Hypervisor
Our approach can be used in two different scenarios:
software already operating inside a virtualized environment,
and software executing directly on physical hardware. For the
former case, common in cloud computing environments, the
execute-only interface can be implemented as an extension to
an existing hypervisor [43, 47, 48, 64, 66]. We chose to focus
on the second, non-virtualized scenario for two reasons: First,
while standard virtualization is common for cloud computing,
we want a more general approach that does not require the
use of a conventional hypervisor (and its associated overhead).
Many of the attacks we defend against (including our indirect
JIT-ROP attack in Section III) require some form of scripting
capability [15, 16, 20, 59] and therefore target software like
browsers and document viewers running on non-virtualized end-
user systems. Second, implementing a thin hypervisor allows us
to measure the overhead of our technique with greater precision.
Our hypervisor is designed to transparently transfer the
currently running operating system into a virtual environment
on-the-ﬂy. Our thin hypervisor design is inspired by hypervisor
rootkits that transparently switch an operating system from
executing on physical hardware to executing inside a virtual
environment that hides the rootkit [38, 54]. Unlike rootkits,
however, our hypervisor interfaces with the operating system it
hosts by providing an interface to manage EPT permissions and
to forward EPT access violations to the OS. Our hypervisor
also has the capability to revert the virtualized operating system
back to direct hardware execution without rebooting if needed
for testing or error handling. For performance and security
reasons, we keep our hypervisor as small as possible; it uses
less than 500 lines of C code.
Figure 5 shows how we enable execute-only page permis-
sions by creating two mappings of the host physical memory:
a normal and a readacted mapping. The EPT permissions for
the normal mapping allow the conventional page table to fully
control the effective page permissions. As previously mentioned,
the ﬁnal permission for a page is the intersection of the page
table permission and the EPT permission. Hence, setting the
EPT permissions to RWX for the normal mapping means that
only the permissions of the regular page table are enforced. We
set the EPT permissions for the readacted mapping to execute-
only so that any read or write access to an address using
this mapping results in an access fault. The operating system
can map virtual memory to physical memory using either of
these mappings. When a block of memory is mapped through
the readacted mapping, execute-only permissions are enforced.
Readacted App
Code 
Data 
Pages
Pages
Legacy App
Code 
Data 
Pages
Pages
Operating 
System
Hypervisor
Readacted 
mapping
Normal 
mapping
Processor
MMU
Access 
Violations
Readable-executable
Readable-writable
Execute-only
Figure 5: Readactor uses a thin hypervisor to enable the
extended page tables feature of modern x86 processors. Virtual
memory addresses of protected applications (top left) are
translated to physical memory using a readacted mapping to
allow execute-only permissions whereas legacy applications
(top right) use a normal mapping to preserve compatibility. The
hypervisor informs the operating systems of access violations.
When the normal mapping is used, executable memory is also
readable.
Our use of extended page tables is fully compatible with
legacy applications. Legacy applications can execute without
any modiﬁcation when Readactor is active, because the normal
mapping is used by default. Readactor also supports code
sharing between legacy and readacted applications. Legacy
applications accessing readacted libraries will receive an
execute-only mapping of the library, thus securing the library
from disclosure. Readacted applications that require a legacy,
un-readacted library can load it normally, but the legacy library
will still be vulnerable to information disclosure.
C. Operating System
To simplify implementation and testing, our prototype
uses the Linux kernel. However, our fundamental approach is
operating system agnostic and can be ported to other operating
systems. We keep our patches to the Linux kernel as small
as possible (the patch contains 82 lines of code and simply
supports the mapping of execute-only pages). Our patch changes
how the Linux kernel writes page table entries. When a
readacted application requests execute-only memory, we set
the guest physical address to point to the readacted mapping
rather than the normal mapping.
VII. READACTOR – COMPILER INSTRUMENTATION
To support the Readactor protections, we modiﬁed the
LLVM compiler infrastructure [41] to (i) generate diversiﬁed
code, (ii) prevent benign code from reading data residing in
code pages, and (iii) prevent the adversary from exploiting
code pointers to perform indirect disclosure attacks.
767
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:06:24 UTC from IEEE Xplore.  Restrictions apply. 
Legacy Application
Code page (readable-executable)
Readacted Application
Code page (execute-only)







