4.1.2
Inspection deﬁnitions are nearly identical to step deﬁnitions.
However, since an inspection causes the veriﬁer on the client
device to run a command (which can also generate artifacts),
there cannot be a threshold of actions. The other ﬁelds are
identical to the link metadata generated by a step.
4.1.3 Artifact rules
Artifact rules are central to describing the topology of the
supply chain by means of its artifacts. These rules behave
like ﬁrewall rules and describe whether an artifact should be
consumed down the chain, or if an artifact can be created or
modiﬁed at a speciﬁc step. As such, they serve two primary
roles: to limit the types of artifacts that a step can create and
consume; and to describe the ﬂow of artifacts between steps.
For the former, a series of rules describes the operation
within the step. A rule, such as CREATE, indicates that a
material must not exist before the step is carried out and
must be reported as a product. Other rules, such as MODIFY,
DELETE, ALLOW and DISALLOW are used to further limit
what a step can register as artifacts within the supply chain.
These rules are described in Grammar 5 (full deﬁnition in
Appendix A). An example of a simple CREATE rule can be
seen on the step deﬁnition in Listing 4.
[ CREATE | DELETE | MODIFY | ALLOW | DISALLOW ] artifact_pattern
Grammar 5: Grammar for operations within a step. artifact_pattern is a
regular expression for the paths to artifacts.
For the latter, the MATCH rule is used by project owners
to describe the ﬂow of artifacts between steps. With it, a
project owner can mandate that, e.g., a buildfarm must only
use the sources that were created during a tag-release step
or that only the right localization ﬁles are included during
a localization step. Compared to the rules above, the MATCH
rule has a richer syntax, as it needs to account for artifacts
relocated during steps (e.g,. a packaging step moving .py
ﬁles to /usr/lib/pythonX.X/site-packages/ or a build
step moving artifacts to a build directory) using the IN
clause. Grammar 6 describes this rule and the Match function
1398    28th USENIX Security Symposium
USENIX Association
describes the algorithm for processing it during veriﬁcation.
An example of a MATCH rule used to match the foo.c source
from tag into the build step is shown in Listing 4.
MATCH source_pattern [ IN prefix ]
WITH  [ IN prefix ] FROM step_name
Grammar 6: The match rule grammar. The IN clauses are optional and
source_pattern is a regular expression
function MATCH
Input: source_artifacts; destination_artifacts, rule
Output: result: (SUCCESS/FAIL)
1:
2: source_artifacts_ﬁltered = ﬁlter(rule.source_preﬁx + rule.source_pattern,
// Filter source and destination materials using the rule’s patterns
source_artifacts)
3: destination_artifacts_ﬁltered
=
ﬁlter(rule.destination_preﬁx
+
artifact.path -= rule.source_in_clause
rule.destination_pattern, destination_artifacts)
4:
// Apply the IN clauses, to the paths, if any
5: for artifact in source_artifacts_ﬁltered do
6:
7: for artifact in destination_artifacts_ﬁltered do
8:
9:
10: for artifact in source_artifacts_ﬁltered do
11:
artifact.path -= rule.destination_in_clause
// compare both sets
destination_artifact = ﬁnd_artifact_by_path(destination_artifacts,
// the artifact with this path does not exist?
if destination_artifact == NULL then
// are the ﬁles not the same?
if destination_artifact.hash != artifact.hash then
artifact.path)
return FAIL
12:
13:
14:
15:
16:
17:
18:
19: return SUCCESS
return FAIL
// all of the ﬁles ﬁltered by the source materials exist
4.2 Link metadata ﬁles
Link metadata serves as a record that the steps prescribed in
the layout actually took place. Its ﬁelds show evidence that is
used for veriﬁcation by the client. For example, the materials
and products ﬁelds of the metadata are used to ensure that
no intermediate products were altered in transit before being
used in a step.
" l i n k " ,
"" ,
"" ,
In order to determine if the executed step complies with its
corresponding metadata, several types of information need to
be gathered as evidence. A link includes the following ﬁelds:
1 { " _ t y p e "
:
2
" _name "
:
3
" command "
4
" m a t e r i a l s " : { "" :
5
" p r o d u c t s " : { "" :
6
" b y p r o d u c t s " : { " s t d i n " :
" r e t u r n −v a l u e " :
7
8
9
10 }
" " } ,
" e n v i r o n m e n t " : { " v a r i a b l e s " :
"" ,
"" , " . . . "
"" , " . . . "
" " , " s t d o u t " :
"" ,
. . . }
" f i l e s y s t e m " :
:
" " ,
:
:
" . . . " } ,
" . . . " } ,
Listing 7: Link metadata format
Name: This will be used to identify the step and to match
it with its corresponding deﬁnition inside the layout.
Material(s): Input ﬁle(s) that were used in this step, along
with their cryptographic hashes to verify their integrity.
Command: The command run, along with its arguments.
Product(s): The output(s) produced and its corresponding
cryptographic hash.
Byproduct(s): Reported information about the step.
Elements like the standard error buffer and standard
output buffer will be used.
Signature: A cryptographic signature over the metadata.
Of these ﬁelds, the name, materials, and products
ﬁelds are the counterpart of the ﬁelds within the layout
deﬁnition. This, along with a cryptographic signature used
to authenticate the functionary who carried out the step can
be used to provide a baseline veriﬁcation of the supply chain
topology (i.e., the steps performed and how do they interrelate
via their materials and products). For example, the build step
metadata described in Listing 8 shows the ﬁle foo.c used
as a material and the product foo as created in the build step.
The byproducts ﬁeld is used to include other meaningful
information about a step’s execution to further introspect into
the speciﬁcs of the step that was carried out. Common ﬁelds
included as byproducts are the standard output, standard error
buffers and a return value. For example, if a command exited
with non-zero status, then the byproduct ﬁeld be populated
with a value such as return-value: "126". In this case,
inspections can be set up to ensure that the return value of
this speciﬁc command must be 0.
1 { " _ t y p e " :
2
" name " :
3
" command " :
4
" m a t e r i a l s " : { " foo . c " : { " sha256 " :
5
" p r o d u c t s " : { " foo " : { " sha256 " :
" b y p r o d u c t s " : { " r e t u r n −v a l u e " : 0 ,
6
7
" " } ,
8
9 }
[ " gcc " , " foo . c " , "−o " , " foo "
" e n v i r o n m e n t " : {} ,
" l i n k " ,
" b u i l d " ,
" 25 c696 . . . " }}
" " , " s t d o u t " :
" s t d e r r " :
" b f f 9 5 e . . . " }} ,
] ,
Listing 8: The link for the build step
Having a software supply chain layout along with the
matching pieces of link metadata and the delivered product
are all the parts needed to perform veriﬁcation. We will
describe veriﬁcation next.
4.3 Verifying the delivered product
Veriﬁcation occurs when the link metadata and the lay-
out are received by the client and upon installing the
delivered product. A standalone or operating-system tool
will perform the veriﬁcation, as described in the function
Verify_Final_Product. To do this, the user will need an initial
public key that corresponds to the supply chain layout, as
distributed by a trusted channel or as part of the operating
system’s installation [106].
The end user starts the veriﬁcation by ensuring that the
supply chain layout provided was signed with a trusted key
(lines 2-3) and by checking the layout expiration date to make
sure the layout is still valid (lines 5-6). If these checks pass,
the public keys of all the functionaries are loaded from the
layout (line 8). With the keys loaded, the veriﬁcation routine
will start iterating over all the steps deﬁned in the layout and
make sure there are enough pieces of link metadata signed
by the right functionaries to match the threshold speciﬁed
for that role (lines 10-20). If enough pieces of link metadata
USENIX Association
28th USENIX Security Symposium    1399
return FAIL
function VERIFY_FINAL_PRODUCT
Input: layout; links; project_owner_key
Output: result: (SUCCESS/FAIL)
1: // verify that the supply chain layout was properly signed
2: if not verify_signature(layout, project_owner_key) then
3:
4: // Check that the layout has not expired
5: if layout.expiration < TODAY then
6:
7: // Load the functionary public keys from the layout
8: functionary_pubkeys = layout.keys
9: // verify link metadata
10: for step in layout.steps do
11:
return FAIL
metadata
// Obtain the functionary keys relevant to this step and its corresponding
step_links.remove(link)
if not verify_signature(link, step_keys) then
// Check there are enough properly-signed links to meet the threshold
if length(step_links) < step.threshold then
return error("Link metadata is missing!")
step_links = get_links_for_step(step, links)
step_keys = get_keys_for_step(step, functionary_pubkeys)
// Remove all links with invalid signatures
for link in step_links do
12:
13:
14:
15:
16:
17:
18:
19:
20:
21: // Apply artifact rules between all steps
22: if apply_artifact_rules(steps, links) == FAIL then
23:
24: // Execute inspections
25: for inspection in layout.inspections do
26:
27: // Verify inspections
28: if apply_artifact_rules(steps + inspections, links) == FAIL then
29:
30: return SUCCESS
inspections.add(Run(inspection))
return FAIL
return FAIL
could be loaded for each of the steps and their signatures
pass veriﬁcation, then the veriﬁcation routine will apply the
artifact rules and build a graph of the supply chain using
the artifacts recorded in the link metadata (lines 22-23). If
no extraneous artifacts were found and all the MATCH rules
pass, then inspections will be executed1 (line 25-26). Finally,
once all inspections were executed successfully, artifact
rules are re-applied to the resulting graph to check that rules
on inspection steps match after inspections are executed,
because inspections may produce new artifacts or re-create
existing artifacts (lines 28-29). If all veriﬁcations pass, the
function will return SUCCESS.
With this veriﬁcation in place, the user is sure that the
integrity of the supply chain is not violated, and that all
requirements made by the project’s maintainers were met.
4.4 Layout and Key Management
A layout can be revoked in one of two ways, the choice being
up to the project owner. One is by revoking the key that was
used to sign the layout, the other is by superseding/updating
the layout with a newer one. To update a layout, the project
owner needs to replace an existing layout with a newer layout.
This can be used to deal with situations when a public key
1Inspections are executed only after all the steps are veriﬁed to avoid
executing an inspection on an artifact that a functionary did not create.
of a misbehaving functionary needs to be changed/revoked,
because when the project owner publishes a newer layout
without that public key, any metadata from such misbehaving
functionary is automatically revoked. Updating a layout
can also be used to address an improperly designed initial
layout. The right expiration date for a layout depends on the
operational security practices of the integrator.
5 Security Analysis
in-toto was designed to protect the software supply chain as
a whole by leveraging existing security mechanisms, ensuring
that they are properly set up and relaying this information to
a client upon veriﬁcation. This allows the client to make sure
that all the operations were properly performed and that no
malicious actors tampered with the delivered product.
To analyze the security properties of in-toto, we need to
revisit the goals described in Section 2. Of these, the relevant
goals to consider are supply chain layout integrity, artifact ﬂow
integrity, and step authentication. In this section, we explore
how these properties hold, and how during partial key compro-
mise the security properties of in-toto degrade gracefully.
in-toto’s security properties are strictly dependent on an
attacker’s level of access to a threshold of signing keys for
any role. These security properties degrade depending on the
type of key compromise and the supply chain conﬁguration.
5.1 Security properties with no key compromise
When an attacker is able to compromise infrastructure or
communication channels but not functionary keys, in-toto’s
security properties ensure that the integrity of the supply
chain is not violated. Considering our threat model in
Section 2, and contrasting it to in-toto’s design which
stipulates that the supply chain layout and link metadata are
signed, we can assert the following:
An attacker cannot interpose between two consecutive
steps of the supply chain because, during veriﬁcation, the
hash on the products ﬁeld of the link for the ﬁrst step will
not match the hash on the materials ﬁeld of the link for the
subsequent step. Further, a completely counterfeit version
of the delivered product will fail validation because its
hash will not match the one contained in the correspond-
ing link metadata. Thus, artifact ﬂow integrity holds.
An attacker cannot provide a product that is missing
steps or has its steps reordered because the corresponding
links will be missing or will not be in the correct order.
The user knows exactly which steps and in what order
they need to be performed to receive the delivered
product. As such, supply chain layout integrity holds.
Finally, an attacker cannot provide link metadata for
which he does not have permission to provide (i.e., their
key is not listed as one that can sign link metadata for
a certain step). Thus, step authentication holds.
However, it is important to underline that this threat
model requires that the developer’s host systems are not
compromised. Likewise, it assumes that there are no rogue
developers wishing to subvert the supply chain. For practical
purposes, we consider a rogue functionary to be equivalent
1400    28th USENIX Security Symposium
USENIX Association
to a functionary key compromise. Hence this section frames
attacks from the standpoint of a key compromise, even when
the issue may be executed as a confused deputy problem or
a similar issue with equivalent impact.
5.2 Security properties if there is a key compromise
in-toto is not a “lose-one, lose-all” solution, in that its secu-
rity properties only partially degrade with a key compromise.
Depending on which key the attacker has accessed, in-toto’s