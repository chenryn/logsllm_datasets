### Overcoming Packed Executables in Malware Analysis

When performing disassembly and control flow extraction on unknown malware samples, we must address the challenge of packed executables. According to [18], over 40% of the samples are packed with a known packer, and this figure is likely an underestimation. To unpack these samples, we employ a simple yet effective technique.

In existing generic unpackers [15, 19], the malware is first executed in a dynamic analysis environment. Since we already execute the analyzed code in Anubis for several minutes, unpacking occurs naturally. At the end of the analysis, we take a snapshot of the memory content and perform further analysis directly on this dump. This method not only reports the results from the dynamic analysis but also identifies all dormant functionalities.

Our experience has shown that this straightforward unpacking approach works well for the malware samples in our evaluation dataset and is sufficient for most contemporary malware. However, we acknowledge that advanced packers may require alternative unpacking techniques [20, 21].

### Evaluation

The primary goal of the evaluation is to demonstrate that REANIMATOR can extract accurate and robust genotype models for various phenotypes. Additionally, we aim to show that these models can efficiently identify dormant functionalities in real-world malware.

#### A. Genotype Model Extraction

**Phenotypes:**
To extract genotype models, it is necessary to define appropriate phenotypes. We specified rules to detect nine common malware behaviors:

- **Spam:** Sending unsolicited emails, detected as SMTP traffic at the network level.
- **Scan:** Performing a port scan, detected using Anubis' existing network-level portscan detection heuristics.
- **Sniff:** Packet sniffing, detected when a program opens a socket in promiscuous mode.
- **Keylog:** Logging keystrokes, detected by invoking specific Windows API calls.
- **Rpcbind:** Exploiting a Windows DCE/RPC vulnerability over SMB/CIFS, detected using Snort signatures.
- **Killproc:** Terminating a process (e.g., an antivirus process), detected by using Windows API calls to terminate a non-spawned process.
- **Backdoor:** Opening a backdoor, detected when the program listens on a TCP port.
- **Packetflood:** Simple denial-of-service, detected by sending a high number of packets per second to a single destination.
- **Drop:** Downloading and executing a binary, detected by taint analysis observing data flow from the network to a file and subsequent execution.

**Genotypes:**
Using the defined phenotypes, we executed four malware samples in our dynamic analysis environment:

- **Rbot:** A classic IRC-based bot with available source code, allowing us to force it to connect to our IRC server and execute various actions.
- **Pushdo:** A sophisticated downloader/dropper Trojan that connects to hard-coded IP addresses over HTTP to download and install additional components.
- **Cutwail:** A template-based spam engine, often a payload of Pushdo. We used Pushdo to download and run Cutwail.
- **Allaple:** A polymorphic network worm that performs a network scan and attempts to compromise identified services.

We selected these samples because they exhibit a wide range of behaviors in the Anubis sandbox and represent a mix of classic and advanced bots and a well-known worm.

Applying REANIMATOR to the executions of these samples, we extracted ten genotype models, as shown in Table I. The table includes the size of the captured genotype in terms of lines of code (when available) and basic blocks, both in static and dynamic modes.

| Genotype Sample | Phenotype | Lines of Code | Basic Blocks (S) | Basic Blocks (D) |
|-----------------|-----------|---------------|------------------|------------------|
| rbot            | sniff     | 59            | 59               | 31               |
| rbot            | udpflood  | 60            | 51               | 41               |
| rbot            | keylog    | 84            | 59               | 49               |
| rbot            | killproc  | 65            | 42               | 27               |
| rbot            | simplespam| 392           | 302              | 236              |
| rbot            | drop      | 37            | 27               | 26               |
| pushdo          | rpcbind   | n/a           | n/a              | n/a              |
| cutwail         | packetflood| n/a          | n/a              | n/a              |
| allaple         | sniff     | n/a           | n/a              | n/a              |
| allaple         | backdoor  | n/a           | n/a              | n/a              |

#### B. Genotype Model Accuracy

To evaluate the accuracy of the extracted genotype models, we used a dataset of 208 bot programs provided by [24]. Many of these bots are variants of Rbot. We manually extracted code snippets responsible for each observed Rbot phenotype and checked the remaining 207 bot programs for similar code using MOSS, a plagiarism detection tool.

We then used REANIMATOR to match the six genotype models against the 207 bot binaries. Figure 2 shows the correlation between REANIMATOR's matches and MOSS similarity scores. On the right side, high MOSS scores indicate a high confidence in the presence of the corresponding functionality, and REANIMATOR almost invariably finds a match. On the left side, low MOSS scores result in few REANIMATOR matches.

We manually inspected cases where REANIMATOR and MOSS reported different results. In five cases where REANIMATOR found a match but MOSS reported low scores, REANIMATOR was correct, and the low MOSS scores were due to significant code modifications. In 27 cases where MOSS reported high similarity but REANIMATOR did not find a match, 13 were due to code exclusion during compilation or linking, and 14 were false negatives due to extensive code changes.

To verify the risk of false positives, we applied our ten genotype models to 1,949 files in the system32 directory of a Windows XP installation. No matches were found, confirming the specificity of our models.

#### C. Robustness

We evaluated the effects of different compilers and optimizations on REANIMATOR's accuracy. Using the same dataset of 208 bot sources, we re-compiled the bot sources with different optimization and inlining options. The results in Table II show that different compiler options have a minimal effect on REANIMATOR's results, except for the simplespam model, which is more brittle due to its small code size.

For the second test, we re-compiled ten of the 208 bot samples using different versions of the Visual Studio compiler and the Intel C++ Compiler. Table III shows that REANIMATOR is robust to different compiler versions but struggles with completely different compilers. Our results compare favorably to state-of-the-art binary clone detection methods [26], which show high false negative rates.

While malware authors could evade our tool by recompiling with different compilers, this would only generate a limited number of variants. REANIMATOR can handle this by generating a genotype model for each variant.

#### D. Genotype Matching Results

We discuss REANIMATOR's effectiveness on four real-world datasets:

- **IRC Bots:** 10,238 binaries that performed IRC traffic and were not packed with a known packer.
- **Packed Bots:** 4,523 binaries that perform IRC traffic and are likely packed.

These datasets provide a comprehensive evaluation of REANIMATOR's capabilities in real-world scenarios.