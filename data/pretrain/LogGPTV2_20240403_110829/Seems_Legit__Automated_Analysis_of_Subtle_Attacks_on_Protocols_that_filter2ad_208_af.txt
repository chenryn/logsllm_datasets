[74]
[34]
X.509 Mutual Auth
WS Request-Response
STS-MAC-fix1
STS-MAC-fix2
DRKey & OPT
ACME Draft 4
Table 3: Summary of new findings using our signature models, compared to previous analyses that used the traditional symbolic model for
signatures. The previous analyses did not discover any attack on these protocol properties. In contrast, our new approach efficiently finds
attacks, including previously unreported ones.
Authentication
Authentication
Authentication & Collusion Resistance Coll.
DNS Validation
ProVerif
F # → ProVerif
Tamarin
Tamarin
Coq
ProVerif
[38]
[25]
This paper
[6]
2006
2008
2012
2012
2014
2017
§3.1.1
§3.1.2
§5.3
§5.1
35
68
2640
53
5
§5.2
This paper
no-DEO
no-CEO
no-CEO
no-DEO
S
M1
H1
M3
D
M2
H2
The attack arises because of the ability to re-sign secret messages
under a new key. The message used to pass keys in DRKey is:
aencpkS ,t
(KH2,S), signskH2
(KH2,S , pkS ,t , S)
Here we show the message produced by H2, carrying keys intended
for S in the session using the temporary public encryption key
pkS ,t . During the DRKey protocol, the adversary as M1 can forge a
message to H2, claiming that S wishes to agree on keys for the lower
path. When M3 receives the DRKey message from H2, containing a
signature and an encrypted key, the adversary (as M3) can re-sign
the packet as if it came from M2 and pass it on to D. This is possible
even though the adversary does not know the message, and is a
behaviour not captured by traditional symbolic models. Note that
even if the DRKey implementation uses a signature scheme where
re-signing is not possible, e.g., Ed25519, the colliding signature
property can also be used to craft a signature for an unknown
message. The rest of DRKey proceeds as normal, at the end of
which S and D each hold a key they believe they share with M2, but
in fact they share this key with H2. This constitutes a UKS attack
on the DRKey Protocol.
The OPT protocol then prescribes a series of chained MACs
such that honest routers can detect maliciously-routed packets, and
that the destination can verify that the correct path was followed.
However, in the above context, S intends to route a packet via M2
but M1 can maliciously alter the route to the lower path. Because S
and D share a key with H2, that they believe they share with M2,
neither of them can detect this malicious routing1. As a consequence
of this attack, M2 could bill S for routing packets, despite in fact
offloading all of the transmission work to the unsuspecting H2.
We stress that whilst we demonstrate this attack on the exam-
ple topology described above, it applies generally to any topology
where an adversary can control two (or more) adjacent malicious
1Perhaps a simpler form of misbehaviour would be rewriting the route S → M1 →
M2 → M3 → D to S → M1 → H → M3 → D. However, this does not technically
contradict OPT’s claimed security goals, while our example violates their non-collusion
property. The malicious router M1 is necessary in order to change the route of the
packet in the first place.
routers and at least one router earlier in the chain. Besides the
double billing attack we mentioned earlier, this attack could also
be used to perform a denial of service attack on an honest router,
by forcing additional packets to pass through it, despite the fact
both source and destination believe their packets are travelling a
different route.
As DRKey is intended for use in the SCION [68] internet archi-
tecture it is still under active development. The DRKey authors
agree that the attack we found is serious and have modified their
protocol according to our proposed fix. The prototype is already
updated and this will be reflected in an extension of their work,
which is currently under submission for publication.
Our proposed fix for this protocol follows the intuition behind
STS-KDF. We do not need to change any of the messages on the
wire, instead, we apply a key derivation function which binds each
key to the identity of the party who is using it, and the party they
believe they share it with. This suffices to prevent any unknown
key share attacks on DRKey, as honest parties will only agree on
keys if they also agree on identities. Using our SVS model of digital
signatures, Tamarin verifies the fix in only 7 seconds.
5.4 Summary
In Table 3 we relate our attacks to previously published academic
papers. Notably, we have uncovered previously unknown attacks
on real world protocols that have previously undergone formal
analysis. Each attack relies on a subtle signature scheme property,
which previous analysis tools could not take into account. We have
responsibly disclosed our attacks.
We give a brief summary of the performance of our case studies
and their proposed fixes in Table 4, showing the overall tractability
of our approach. Our combined approach (verification with SVS,
attack finding with the equational model) demonstrates its utility
here: SVS is both more efficient and finer-grained where the proto-
col verifies. In contrast, when there is an attack, our attack finding
models are quickest.
In conjunction with a companion work, building symbolic mod-
els of non-prime order groups [49], we investigated some common
cryptographic libraries’ handling of Ed25519 signatures. We discov-
ered that whilst LibSodium [17], Golang’s NaCl Module [16], Project
Everest’s formally verified HACL [75] and Cloudflare’s CIRCL [14]
Session 9D: SignaturesCCS ’19, November 11–15, 2019, London, United Kingdom2177Protocol
WS-Security
WS-Security (fixed)
LE-00
LE-02
DRKey
DRKey (fixed)
Signature
Model
Traditional
no-CEO
SVS
Traditional
All in §3
SVS
Traditional
no-DEO
SVS
Traditional
All in §3
SVS
Traditional
Coll.
SVS
Traditional
All in §3
SVS
Analysis
results
✓
•◦
•◦
✓
✓
✓
✓
•◦
•◦
✓
✓
✓
✓
•◦
•◦
✓
✓
✓
Time in
seconds
3
5
12
2
12
13
1
53
98
1
2
1
240
2640
Manual
4
32
7
Table 4: Verification results on our further case studies.
✓ indicates that Tamarin successfully verified the property
•◦ indicates that Tamarin found an attack.
Manual indicates that Tamarin’s interactive mode was used to re-
construct the attack trace as Tamarin’s built in heuristics did not
terminate in a reasonable timeframe.
advertise the same API and ‘drop in’ compatibility, they are not con-
sistent in their handling of Ed25519 signatures. Notably, LibSodium
checks for and rejects ’low order points’ which are used to construct
colliding Ed25519 signatures. However, the other three libraries
accept these points, allowing colliding signatures to be crafted. We
reached out to the maintainers of each library and they have fixed
(or agreed to fix) this issue, ensuring that protocol developers are
not caught unaware.
Full sources to all of our models are available at [58].
6 OTHER RELATED WORK
In the preceding, we discussed in detail the existing literature on
symbolic models of digital signatures as we presented various as-
pects. In this section we briefly mention some alternative strands
of research aiming to tackle similar problems.
Automated Computational Verification. Computational proofs do
not rely on an abstraction of signature schemes, instead reducing
security of a protocol directly to (among other things) EUF-CMA. A
few tools aim to construct these proofs either automatically [40] or
with human assistance [28, 30]; they have the great advantage that
all behaviours of the signature scheme are by definition captured,
since the reduction is directly to its security definition. This also
means that proofs at this level are generally much more challenging
to produce, and harder to scale to more complex protocols.
Computational Soundness. Backes et al. [23] consider the compu-
tational soundness of existing symbolic models for digital signatures.
A symbolic model is computationally sound for a particular class
of protocols and properties if the existence of a symbolic proof
of a property implies the existence of a computational one. Most
computational soundness approaches in the literature require that
primitives be used in a carefully controlled fashion; for example,[23]
required that signatures verify under unique public keys and for
unique messages. While it seems that such requirements can be
enforced by mechanisms such as appropriate tagging, real-world
protocols typically do not (or cannot) meet these requirements,
thereby limiting the applicability of these approaches.
Bana et al. propose an alternative model for protocol verification
which they call the Computationally Complete Symbolic Attacker,
see, e.g., [26, 27]. Their approach is the first attempt to base a
symbolic model on adversary restrictions, rather than explicit capa-
bilities. They have not yet shown their approach can be automated
in practice. In their model, correctness is specified and then the
adversary is permitted to act freely as long as it does not violate the
axioms. Their computational soundness results apply to the proof,
so that the resulting protocol is proved secure computationally.
This approach has the potential to be very powerful, and may
provide an alternative to our verification approach. However, their
approach is in its early stages: it works only for a bounded number
of sessions and does not have tool support yet, unlike ours which is
unbounded and has full tool support. Additionally, their approach is
focused on proof finding, without support for establishing attacks.
7 CONCLUSIONS
In this work, we revisited many subtle behaviours of digital sig-
nature schemes, such as the possibility of key substitution and
malleability, and showed how they fall between the cracks: their
absence is not guaranteed by the classical EUF-CMA security defi-
nition for signatures, but at the same time their absence is assumed
by modern automated protocol analyses. Yet the presence of such
behaviours can lead, and has led, to critical attacks.
We developed a range of alternative signature models for use in
modern tools. Our models capture a wide range of these behaviours
and give a general theory for verification of their absence. We
thereby provide the first automated procedure to show the absence
or presence of attacks exploiting these subtle behaviours.
As a side effect of evaluating the effectiveness of our work, we
found two new attacks on protocols, which is remarkable for mul-
tiple reasons: the WS-Security protocols served as the basis of
globally used technologies and were therefore under close scrutiny,
and both WS-Security and DRKey were previously proven secure.
In the wider sense, our work increases the scope of attacks con-
sidered by automated analysis tools: future protocol analysis models
that include our more accurate equations will be able to find more
attacks, or show the absence of more attack types.
A more long-term question is whether it is possible to “close
the gap” between falsification and verification, showing that any
attack found in our general theory corresponds to a real attack on
the underlying signature scheme itself.
Session 9D: SignaturesCCS ’19, November 11–15, 2019, London, United Kingdom2178REFERENCES
[1] 2006. OASIS Web Services Security (WSS) TC. Retrieved Feburary 2nd, 2019
from https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=wss#
technical
[2] 2014. Oracle® Fusion Middleware: WS-Policy Reference. Retrieved Feburary 2nd,
2019 from https://docs.oracle.com/cd/E55956_01/doc.11123/user_guide/content/
ws_policies.html
[3] 2015. ACME Draft Barnes. Retrieved Feburary 2nd, 2019 from https://datatracker.
[4] 2015. ACME Draft Barnes. Retrieved Feburary 2nd, 2019 from https://datatracker.
[5] 2015. ACME Draft Barnes. Retrieved Feburary 2nd, 2019 from https://datatracker.
ietf.org/doc/draft-barnes-acme/01/
ietf.org/doc/draft-barnes-acme/03/