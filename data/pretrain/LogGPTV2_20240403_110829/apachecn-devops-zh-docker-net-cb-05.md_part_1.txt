# 五、容器链接和 Docker 域名系统
在本章中，我们将介绍以下食谱:
*   在容器内验证基于主机的 DNS 配置
*   覆盖默认名称解析设置
*   为名称和服务解析配置链接
*   利用 Docker 域名系统
*   正在创建 Docker 域名系统别名
# 简介
我在前面几章已经指出了一点，Docker 在网络领域为你做了很多事情。正如我们已经看到的，让 Docker 通过 IPAM 管理 IP 分配是一个巨大的好处，当您开始使用 Docker 时，这并不明显。Docker 为您提供的另一件事是 DNS 解析。正如我们将在本章中看到的，Docker 可以提供多种级别的名称和服务解析。随着 Docker 的成熟，提供这些类型服务的选项也越来越多。在本章中，我们将开始回顾基本的名称解析，以及容器如何知道使用哪个 DNS 服务器。然后，我们将介绍容器链接，并看看 Docker 如何告诉容器其他容器和它们所承载的服务。最后，我们将介绍随着用户定义网络的增加而带来的一些 DNS 增强功能。
# 验证容器内基于主机的 DNS 配置
您可能没有意识到这一点，但是 Docker 默认为您的容器提供了一种进行基本名称解析的方法。Docker 将名称解析选项从 Docker 主机直接传递到容器中。结果是，派生的容器可以本地解析 Docker 宿主本身可以解析的任何内容。Docker 用来在容器中实现名称解析的机制非常简单。在本食谱中，我们将介绍这是如何完成的，以及您如何验证它是否如预期那样工作。
## 做好准备
在本食谱中，我们将在单个 Docker 主机上演示配置。假设该主机安装了 Docker，并且 Docker 处于默认配置。我们将更改主机上的名称解析设置，因此您将需要根级访问权限。
## 怎么做…
让我们在主机`docker1`上启动一个新的容器，并检查该容器如何处理名称解析:
```
user@docker1:~$ docker run -d -P --name=web8 \
jonlangemak/web_server_8_dns
d65baf205669c871d1216dc091edd1452a318b6522388e045c211344815c280a
user@docker1:~$
user@docker1:~$ docker exec web8 host www.google.com
www.google.com has address 216.58.216.196
www.google.com has IPv6 address 2607:f8b0:4009:80e::2004 
user@docker1:~ $
```
看起来容器有能力解析域名。如果我们查看本地 Docker 主机并运行相同的测试，我们应该会得到类似的结果:
```
user@docker1:~$ host www.google.com
www.google.com has address 216.58.216.196
www.google.com has IPv6 address 2607:f8b0:4009:80e::2004
user@docker1:~$ 
```
此外，就像我们的 Docker 主机一样，容器也可以解析与本地域`lab.lab`关联的本地 DNS 记录:
```
user@docker1:~$ docker exec web8 host docker4
docker4.lab.lab has address 192.168.50.102
user@docker1:~$
```
您会注意到，为了解析域`lab.lab`中的主机名`docker4`，我不需要指定完全限定的域名。在这一点上，可以安全地假设容器正在从 Docker 主机接收某种智能更新，该主机向它提供关于本地 DNS 配置的相关信息。
### 注
请注意，`resolv.conf`文件通常是您定义 Linux 系统名称解析参数的地方。在许多情况下，它会被其他地方的配置信息自动更改。然而，不管它是如何改变的，它应该始终是系统处理名称解析的真实来源。
为了查看容器正在接收什么，让我们检查容器的`resolv.conf`文件:
```
user@docker1:~$ docker exec -t web8 more /etc/resolv.conf
::::::::::::::
/etc/resolv.conf
::::::::::::::
# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)
#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
nameserver 10.20.30.13
search lab.lab
user@docker1:~$
```
如你所见，容器已经得知本地 DNS 服务器为`10.20.30.13`，本地 DNS 搜索域为`lab.lab`。它从哪里得到这些信息的？解决办法相当简单。当容器启动时，Docker 为每个派生的容器生成以下三个文件的实例，并将其与容器配置一起保存:
*   `/etc/hostname`
*   `/etc/hosts`
*   `/etc/resolv.conf`
这些文件作为容器配置的一部分存储，然后装载到容器中。我们可以使用容器中的`findmnt`工具来检查挂载的来源:
```
root@docker1:~# docker exec web8 findmnt -o SOURCE
……
/dev/mapper/docker1--vg-root[/var/lib/docker/containers/c803f130b7a2450609672c23762bce3499dec9abcfdc540a43a7eb560adaf62a/resolv.conf
/dev/mapper/docker1--vg-root[/var/lib/docker/containers/c803f130b7a2450609672c23762bce3499dec9abcfdc540a43a7eb560adaf62a/hostname]
/dev/mapper/docker1--vg-root[/var/lib/docker/containers/c803f130b7a2450609672c23762bce3499dec9abcfdc540a43a7eb560adaf62a/hosts]
root@docker1:~#
```
因此，当容器认为其`/etc/`目录中有`hostname`、`hosts`和`resolv.conf`文件的本地副本时，真正的文件实际上位于 Docker 主机上的容器配置目录(`/var/lib/docker/containers/`)中。
当你告诉 Docker 运行一个容器时，它会做以下三件事:
*   它检查 Docker 主机的`/etc/resolv.conf`文件，并将其副本放入容器目录中
*   它在容器的目录中创建一个`hostname`文件，并为容器分配一个唯一的`hostname`
*   它在容器的目录中创建一个`hosts`文件，并添加相关记录，包括 localhost 和引用主机本身的记录
每次容器重启时，容器的`resolv.conf`文件都会根据 Docker 主机的`resolv.conf`文件中找到的值进行更新。这意味着每次容器重新启动时，对`resolv.conf`文件所做的任何更改都会丢失。每次重新启动容器时，`hostname`和`hosts`配置文件也会被重写，从而丢失上一次运行中所做的任何更改。
为了验证给定容器正在使用的配置文件，我们可以检查这些变量的容器配置:
```
user@docker1:~$ docker inspect web8 | grep HostsPath
“HostsPath”: “/var/lib/docker/containers/c803f130b7a2450609672c23762bce3499dec9abcfdc540a43a7eb560adaf62a/hosts”,
user@docker1:~$ docker inspect web8 | grep HostnamePath
“HostnamePath”: “/var/lib/docker/containers/c803f130b7a2450609672c23762bce3499dec9abcfdc540a43a7eb560adaf62a/hostname”,
user@docker1:~$ docker inspect web8 | grep ResolvConfPath
“ResolvConfPath”: “/var/lib/docker/containers/c803f130b7a2450609672c23762bce3499dec9abcfdc540a43a7eb560adaf62a/resolv.conf”,
user@docker1:~$ 
```
不出所料，这些是我们在容器内部运行`findmnt`命令时看到的相同装载路径。这些表示每个文件进入每个相应文件的容器`/etc/`目录的确切装载路径。
# 覆盖默认名称解析设置
Docker 用来为容器提供名称解析的方法在大多数情况下都非常有效。但是，在某些情况下，您可能希望 Docker 为容器提供 DNS 服务器，而不是 Docker 主机配置使用的服务器。在这些情况下，Docker 为您提供了几个选项。您可以告诉 Docker 服务为该服务生成的所有容器提供不同的 DNS 服务器。您也可以在容器运行时通过向`docker run`子命令提供一个 DNS 服务器作为选项来手动覆盖此设置。在本食谱中，我们将向您展示更改默认名称解析行为的选项，以及如何验证设置是否有效。
## 做好准备
在本食谱中，我们将在单个 Docker 主机上演示配置。假设该主机安装了 Docker，并且 Docker 处于默认配置。我们将更改主机上的名称解析设置，因此您将需要根级访问权限。
## 怎么做…
正如我们在本章第一个食谱中看到的，默认情况下，Docker 为容器提供了 Docker 主机本身使用的 DNS 服务器。这是以复制宿主的`resolv.conf`文件并将其提供给每个衍生容器的形式出现的。除了名称服务器设置，该文件还包括 DNS 搜索域的定义。这两个选项都可以在服务级别进行配置，以覆盖任何派生的容器，也可以在单个级别进行配置。
为了进行比较，让我们从检查 Docker 主机的 DNS 配置开始:
```
root@docker1:~# more /etc/resolv.conf
# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)
#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
nameserver 10.20.30.13
search lab.lab
root@docker1:~#
```
使用这种配置，我们可以预期在该主机上产生的任何容器都将接收相同的名称服务器和 DNS 搜索域。让我们生成一个名为`web8`的容器来验证这是否如预期的那样工作:
```
root@docker1:~# docker run -d -P --name=web8 \
jonlangemak/web_server_8_dns
156bc29d28a98e2fbccffc1352ec390bdc8b9b40b84e4c5f58cbebed6fb63474
root@docker1:~#
root@docker1:~# docker exec -t web8 more /etc/resolv.conf
::::::::::::::
/etc/resolv.conf
::::::::::::::
# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)
#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
nameserver 10.20.30.13
search lab.lab
```
正如预期的那样，容器接收相同的配置。现在让我们检查容器，看看是否定义了任何与域名系统相关的选项:
```
user@docker1:~$ docker inspect web8 | grep Dns
            “Dns”: [],
            “DnsOptions”: [],
            “DnsSearch”: [],
user@docker1:~$
```
因为我们使用的是默认配置，所以没有理由在容器中配置任何关于域名系统服务器或搜索域的特定内容。每次容器启动时，Docker 都会将主机的`resolv.conf`文件设置应用到容器的 DNS 配置文件中。
如果我们更喜欢让 Docker 给容器一个不同的 DNS 服务器或 DNS 搜索域，我们可以通过 Docker 选项做到这一点。在这种情况下，我们感兴趣的两个是:
*   `--dns=`:指定 Docker 应该向容器提供的 DNS 服务器地址
*   `--dns-search=`:指定 Docker 应该向容器提供的 DNS 搜索域
让我们配置 Docker 为容器提供一个公共 DNS 服务器(`4.2.2.2`)和一个`lab.external`的搜索域。我们可以通过将以下选项传递给 Docker systemd 插件文件来实现这一点:
```
ExecStart=/usr/bin/dockerd --dns=4.2.2.2 --dns-search=lab.external 
```
配置好选项后，重新加载 systemd 配置，重启服务加载新选项，重启我们的容器`web8`:
```
user@docker1:~$ sudo systemctl daemon-reload
user@docker1:~$ sudo systemctl restart docker
user@docker1:~$ docker start web8
web8
user@docker1:~$ docker exec -t web8 more /etc/resolv.conf
search lab.external
nameserver 4.2.2.2
user@docker1:~$
```
您会注意到，尽管这个容器最初有主机的 DNS 服务器(`10.20.30.13`)和搜索域(`lab.lab`)，但它现在有我们刚刚指定的服务级别 DNS 选项。如果您回想一下，我们看到，当我们检查这个容器时，它没有定义特定的 DNS 服务器或搜索域。由于未指定任何选项，Docker 现在使用 Docker 选项中具有优先级的设置。虽然这提供了一些级别的灵活性，但还不是真正的灵活性。此时，在该服务器上产生的任何和所有容器都将被提供相同的 DNS 服务器和搜索域。为了真正灵活，我们应该能够让 Docker 在每个容器级别上更改名称解析配置。幸运的是，这些选项也可以在容器运行时直接提供。
![How to do it…](img/B05453_05_01.jpg)
上图定义了 Docker 在决定容器启动时应用什么名称解析设置时使用的优先级。正如我们在前面章节中看到的，在容器运行时定义的设置总是优先。如果设置没有在那里定义，Docker 会查看它们是否在服务级别配置。如果设置不存在，它将返回到依赖 Docker 主机的 DNS 设置的默认方法。
例如，我们可以启动名为`web2`的容器，并提供不同的选项:
```
root@docker1:~# docker run -d --dns=8.8.8.8 --dns-search=lab.dmz \
-P --name=web8-2 jonlangemak/web_server_8_dns
1e46d66a47b89d541fa6b022a84d702974414925f5e2dd56eeb840c2aed4880f
root@docker1:~#
```
如果我们检查容器，我们将看到我们现在已经将`dns`和`dns-search`字段定义为容器配置的一部分:
```
root@docker1:~# docker inspect web8-2
......
 “Dns”: [
 “8.8.8.8”
            ],
            “DnsOptions”: [],
 “DnsSearch”: [
 “lab.dmz”
            ],
......
root@docker1:~# 
```
这确保了，如果容器重新启动，它将仍然具有第一次运行容器时最初提供的相同的 DNS 设置。让我们对 Docker 服务进行一些细微的更改，以验证优先级是否如预期的那样工作。让我们更改 Docker 选项，如下所示:
```
ExecStart=/usr/bin/dockerd --dns-search=lab.external