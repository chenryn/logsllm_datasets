        if (option & MACH_SEND_MSG) {
            ipc_space_t space = current_space();
            ipc_kmsg_t kmsg;    // 创建kmsg变量
            // 分配缓冲区并从用户态拷贝消息头到内核态
            mr = ipc_kmsg_get(msg_addr, send_size, &kmsg);
            // 转换端口，并拷贝消息体
            mr = ipc_kmsg_copyin(kmsg, space, map, override, &option);
            // 发送消息
            mr = ipc_kmsg_send(kmsg, option, msg_timeout);
        }
        if (option & MACH_RCV_MSG) {
            ...
        }
        return MACH_MSG_SUCCESS;
    }
函数`ipc_kmsg_get()`，`ipc_kmsg_t`就是内核态的消息存储结构体，拷贝过程看注释，这里基本是在处理`kmsg->ikm_header`，也就是用户态传入的消息数据
    mach_msg_return_t
    ipc_kmsg_get(
        mach_vm_address_t       msg_addr,
        mach_msg_size_t size,
        ipc_kmsg_t              *kmsgp)
    {
        mach_msg_size_t                 msg_and_trailer_size;
        ipc_kmsg_t                      kmsg;
        mach_msg_max_trailer_t          *trailer;
        mach_msg_legacy_base_t      legacy_base;
        mach_msg_size_t             len_copied;
        legacy_base.body.msgh_descriptor_count = 0;
        // 长度参数检查
        ...
        // mach_msg_legacy_base_t结构体长度等于mach_msg_base_t
        if (size == sizeof(mach_msg_legacy_header_t)) {
            len_copied = sizeof(mach_msg_legacy_header_t);
        } else {
            len_copied = sizeof(mach_msg_legacy_base_t);
        }
        // 从用户态拷贝消息到内核态
        if (copyinmsg(msg_addr, (char *)&legacy_base, len_copied)) {
            return MACH_SEND_INVALID_DATA;
        }
        // 获取内核态消息变量起始地址
        msg_addr += sizeof(legacy_base.header);
        // 直接加上最长的trailer长度，不知道接收者会定义何种类型的trailer，此处是做备用操作
        // typedef mach_msg_mac_trailer_t mach_msg_max_trailer_t;
        // #define MAX_TRAILER_SIZE ((mach_msg_size_t)sizeof(mach_msg_max_trailer_t))
        msg_and_trailer_size = size + MAX_TRAILER_SIZE;
        // 分配内核空间
        kmsg = ipc_kmsg_alloc(msg_and_trailer_size);
        // 初始化kmsg.ikm_header部分字段
        ...
        // 拷贝消息体，此处不包括trailer
        if (copyinmsg(msg_addr, (char *)(kmsg->ikm_header + 1), size - (mach_msg_size_t)sizeof(mach_msg_header_t))) {
            ipc_kmsg_free(kmsg);
            return MACH_SEND_INVALID_DATA;
        }
        // 通过size找到kmsg尾部trailer的起始地址，进行初始化
        trailer = (mach_msg_max_trailer_t *) ((vm_offset_t)kmsg->ikm_header + size);
        trailer->msgh_sender = current_thread()->task->sec_token;
        trailer->msgh_audit = current_thread()->task->audit_token;
        trailer->msgh_trailer_type = MACH_MSG_TRAILER_FORMAT_0;
        trailer->msgh_trailer_size = MACH_MSG_TRAILER_MINIMUM_SIZE;
        trailer->msgh_labels.sender = 0;
        *kmsgp = kmsg;
        return MACH_MSG_SUCCESS;
    }
函数`ipc_kmsg_copyin()`是我们这里重点分析的逻辑，整个代码我删掉了业务无关的部分，函数`ipc_kmsg_copyin_header()`跟我们要分析的逻辑无关，主要看函数`ipc_kmsg_copyin_body()`
    mach_msg_return_t
    ipc_kmsg_copyin(
        ipc_kmsg_t        kmsg,
        ipc_space_t        space,
        vm_map_t        map,
        mach_msg_priority_t override,
        mach_msg_option_t    *optionp)
    {
        mach_msg_return_t         mr;
        kmsg->ikm_header->msgh_bits &= MACH_MSGH_BITS_USER;
        mr = ipc_kmsg_copyin_header(kmsg, space, override, optionp);
        if ((kmsg->ikm_header->msgh_bits & MACH_MSGH_BITS_COMPLEX) == 0)
        return MACH_MSG_SUCCESS;
        mr = ipc_kmsg_copyin_body( kmsg, space, map, optionp);
        return mr;
    }
函数`ipc_kmsg_copyin_body()`先判断OOL数据是否满足条件，并且视情况对内核空间进行调整，最后调用关键函数`ipc_kmsg_copyin_ool_ports_descriptor()`
    mach_msg_return_t
    ipc_kmsg_copyin_body(
        ipc_kmsg_t    kmsg,
        ipc_space_t    space,
        vm_map_t    map,
        mach_msg_option_t *optionp)
    {
        ipc_object_t               dest;
        mach_msg_body_t        *body;
        mach_msg_descriptor_t    *daddr, *naddr;
        mach_msg_descriptor_t    *user_addr, *kern_addr;
        mach_msg_type_number_t    dsc_count;
        // #define VM_MAX_ADDRESS        ((vm_address_t) 0x80000000)
        boolean_t             is_task_64bit = (map->max_offset > VM_MAX_ADDRESS);
        boolean_t             complex = FALSE;
        vm_size_t            space_needed = 0;
        vm_offset_t            paddr = 0;
        vm_map_copy_t        copy = VM_MAP_COPY_NULL;
        mach_msg_type_number_t    i;
        mach_msg_return_t        mr = MACH_MSG_SUCCESS;
        vm_size_t           descriptor_size = 0;
        mach_msg_type_number_t total_ool_port_count = 0;
        // 目标端口
        dest = (ipc_object_t) kmsg->ikm_header->msgh_remote_port;
        // 内核态消息体的起始地址
        body = (mach_msg_body_t *) (kmsg->ikm_header + 1);
        naddr = (mach_msg_descriptor_t *) (body + 1);
        // 如果msgh_descriptor_count为0表示没有数据，直接返回，此处我们设置的是1
        dsc_count = body->msgh_descriptor_count;
        if (dsc_count == 0) return MACH_MSG_SUCCESS;
        daddr = NULL;
        for (i = 0; i type.type) {
                case MACH_MSG_OOL_DESCRIPTOR:
                case MACH_MSG_OOL_VOLATILE_DESCRIPTOR:
                case MACH_MSG_OOL_PORTS_DESCRIPTOR:
                    descriptor_size += 16;
                    naddr = (typeof(naddr))((vm_offset_t)daddr + 16);
                    break;
                default:
                    descriptor_size += 12;
                    naddr = (typeof(naddr))((vm_offset_t)daddr + 12);
                    break;
                }
            } else {
                descriptor_size += 12;
                naddr = (typeof(naddr))((vm_offset_t)daddr + 12);
            }
        }
        user_addr = (mach_msg_descriptor_t *)((vm_offset_t)kmsg->ikm_header + sizeof(mach_msg_base_t));
        // 判断是否需要左移，默认只有1个descriptor的大小，1个长度是16字节，我们设置的是1个，所以不需要移动
        if(descriptor_size != 16*dsc_count) {
            vm_offset_t dsc_adjust = 16*dsc_count - descriptor_size;
            memmove((char *)(((vm_offset_t)kmsg->ikm_header) - dsc_adjust), kmsg->ikm_header, sizeof(mach_msg_base_t));
            kmsg->ikm_header = (mach_msg_header_t *)((vm_offset_t)kmsg->ikm_header - dsc_adjust);
            kmsg->ikm_header->msgh_size += (mach_msg_size_t)dsc_adjust;
        }
        kern_addr = (mach_msg_descriptor_t *)((vm_offset_t)kmsg->ikm_header + sizeof(mach_msg_base_t));
        /* handle the OOL regions and port descriptors. */
        for(i = 0; i type.type) {
                case MACH_MSG_OOL_PORTS_DESCRIPTOR: 
                    user_addr = ipc_kmsg_copyin_ool_ports_descriptor((mach_msg_ool_ports_descriptor_t *)kern_addr, 
                                user_addr, is_task_64bit, map, space, dest, kmsg, optionp, &mr);
                    kern_addr++;
                    complex = TRUE;
                    break;
            }
        } /* End of loop */ 
        ...
    }
函数`ipc_kmsg_copyin_ool_ports_descriptor()`专注处理OOL数据，调用了一个关键的函数`ipc_object_copyin()`
    mach_msg_descriptor_t *
    ipc_kmsg_copyin_ool_ports_descriptor(
        mach_msg_ool_ports_descriptor_t *dsc,
        mach_msg_descriptor_t *user_dsc,
        int is_64bit,
        vm_map_t map,
        ipc_space_t space,
        ipc_object_t dest,
        ipc_kmsg_t kmsg,
        mach_msg_option_t *optionp,
        mach_msg_return_t *mr)
    {
        void *data;
        ipc_object_t *objects;
        unsigned int i;
        mach_vm_offset_t addr;
        mach_msg_type_name_t user_disp;
        mach_msg_type_name_t result_disp;
        mach_msg_type_number_t count;
        mach_msg_copy_options_t copy_option;
        boolean_t deallocate;
        mach_msg_descriptor_type_t type;
        vm_size_t ports_length, names_length;
        if (is_64bit) {
            mach_msg_ool_ports_descriptor64_t *user_ool_dsc = (typeof(user_ool_dsc))user_dsc;
            addr = (mach_vm_offset_t)user_ool_dsc->address;
            count = user_ool_dsc->count;
            deallocate = user_ool_dsc->deallocate;
            copy_option = user_ool_dsc->copy;
            user_disp = user_ool_dsc->disposition;
            type = user_ool_dsc->type;
            user_dsc = (typeof(user_dsc))(user_ool_dsc+1);
        } else {
                ...
        }
        data = kalloc(ports_length);
    #ifdef __LP64__
        mach_port_name_t *names = &((mach_port_name_t *)data)[count];
    #else
        mach_port_name_t *names = ((mach_port_name_t *)data);
    #endif
        objects = (ipc_object_t *) data;
        dsc->address = data;
        for ( i = 0; i < count; i++) {
            mach_port_name_t name = names[i];
            ipc_object_t object;
            if (!MACH_PORT_VALID(name)) {
                objects[i] = (ipc_object_t)CAST_MACH_NAME_TO_PORT(name);
                continue;
            }
            kern_return_t kr = ipc_object_copyin(space, name, user_disp, &object);
            objects[i] = object;
        }
        return user_dsc;
    }
函数`ipc_object_copyin()`包含两个函数：`ipc_right_lookup_write()`和`ipc_right_copyin()`
    kern_return_t
    ipc_object_copyin(
        ipc_space_t        space,
        mach_port_name_t    name,
        mach_msg_type_name_t    msgt_name,
        ipc_object_t        *objectp)
    {
        ipc_entry_t entry;
        ipc_port_t soright;
        ipc_port_t release_port;
        kern_return_t kr;
        int assertcnt = 0;
        kr = ipc_right_lookup_write(space, name, &entry);
        release_port = IP_NULL;
        kr = ipc_right_copyin(space, name, entry,
                      msgt_name, TRUE,
                      objectp, &soright,
                      &release_port,
                      &assertcnt);
        ...
        return kr;
    }
函数`ipc_right_lookup_write()`调用函数`ipc_entry_lookup()`，返回值赋值给`entry`
    kern_return_t
    ipc_right_lookup_write(
        ipc_space_t        space,
        mach_port_name_t    name,
        ipc_entry_t        *entryp)