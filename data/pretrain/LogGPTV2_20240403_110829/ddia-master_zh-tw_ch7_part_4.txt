1. 从资料库读时，只能看到已提交的资料（没有 **脏读**，即 dirty reads）。
2. 写入资料库时，只会覆盖已提交的资料（没有 **脏写**，即 dirty writes）。
我们来更详细地讨论这两个保证。
[^v]: 某些资料库支援甚至更弱的隔离级别，称为 **读未提交（Read uncommitted）**。它可以防止脏写，但不防止脏读。
#### 没有脏读
设想一个事务已经将一些资料写入资料库，但事务还没有提交或中止。另一个事务可以看到未提交的资料吗？如果是的话，那就叫做 **脏读（dirty reads）**【2】。
在 **读已提交** 隔离级别执行的事务必须防止脏读。这意味著事务的任何写入操作只有在该事务提交时才能被其他人看到（然后所有的写入操作都会立即变得可见）。如 [图 7-4](../img/fig7-4.png) 所示，使用者 1 设定了 `x = 3`，但使用者 2 的 `get x` 仍旧返回旧值 2 （当用户 1 尚未提交时）。
![](../img/fig7-4.png)
**图 7-4 没有脏读：使用者 2 只有在使用者 1 的事务已经提交后才能看到 x 的新值。**
为什么要防止脏读，有几个原因：
- 如果事务需要更新多个物件，脏读取意味著另一个事务可能会只看到一部分更新。例如，在 [图 7-2](../img/fig7-2.png) 中，使用者看到新的未读电子邮件，但看不到更新的计数器。这就是电子邮件的脏读。看到处于部分更新状态的资料库会让使用者感到困惑，并可能导致其他事务做出错误的决定。
- 如果事务中止，则所有写入操作都需要回滚（如 [图 7-3](../img/fig7-3.png) 所示）。如果资料库允许脏读，那就意味著一个事务可能会看到稍后需要回滚的资料，即从未实际提交给资料库的资料。想想后果就让人头大。
#### 没有脏写
如果两个事务同时尝试更新资料库中的相同物件，会发生什么情况？我们不知道写入的顺序是怎样的，但是我们通常认为后面的写入会覆盖前面的写入。
但是，如果先前的写入是尚未提交事务的一部分，使得后面的写入覆盖了一个尚未提交的值，这时会发生什么呢？这被称作 **脏写（dirty write）**【28】。在 **读已提交** 的隔离级别上执行的事务必须防止脏写，通常是延迟第二次写入，直到第一次写入事务提交或中止为止。
透过防止脏写，这个隔离级别避免了一些并发问题：
- 如果事务更新多个物件，脏写会导致不好的结果。例如，考虑 [图 7-5](../img/fig7-5.png)，以一个二手车销售网站为例，Alice 和 Bob 两个人同时试图购买同一辆车。购买汽车需要两次资料库写入：网站上的商品列表需要更新，以反映买家的购买，销售发票需要传送给买家。在 [图 7-5](../img/fig7-5.png) 的情况下，销售是属于 Bob 的（因为他成功更新了商品列表），但发票却寄送给了 Alice（因为她成功更新了发票表）。读已提交会防止这样的事故。
- 但是，读已提交并不能防止 [图 7-1](../img/fig7-1.png) 中两个计数器增量之间的竞争状态。在这种情况下，第二次写入发生在第一个事务提交后，所以它不是一个脏写。这仍然是不正确的，但是出于不同的原因，在 “[防止丢失更新](#防止丢失更新)” 中将讨论如何使这种计数器增量安全。
![](../img/fig7-5.png)
**图 7-5 如果存在脏写，来自不同事务的冲突写入可能会混淆在一起**
#### 实现读已提交
**读已提交** 是一个非常流行的隔离级别。这是 Oracle 11g、PostgreSQL、SQL Server 2012、MemSQL 和其他许多资料库的预设设定【8】。
最常见的情况是，资料库透过使用 **行锁（row-level lock）** 来防止脏写：当事务想要修改特定物件（行或文件）时，它必须首先获得该物件的锁。然后必须持有该锁直到事务被提交或中止。一次只有一个事务可持有任何给定物件的锁；如果另一个事务要写入同一个物件，则必须等到第一个事务提交或中止后，才能获取该锁并继续。这种锁定是读已提交模式（或更强的隔离级别）的资料库自动完成的。
如何防止脏读？一种选择是使用相同的锁，并要求任何想要读取物件的事务来简单地获取该锁，然后在读取之后立即再次释放该锁。这将确保在物件具有脏的、未提交的值时不会发生读取（因为在此期间，锁将由进行写入的事务持有）。
但是要求读锁的办法在实践中效果并不好。因为一个长时间执行的写入事务会迫使许多只读事务等到这个慢写入事务完成。这会影响只读事务的响应时间，并且不利于可操作性：因为等待锁，应用某个部分的迟缓可能由于连锁效应，导致其他部分出现问题。
出于这个原因，大多数资料库 [^vi] 使用 [图 7-4](../img/fig7-4.png) 的方式防止脏读：对于写入的每个物件，资料库都会记住旧的已提交值，和由当前持有写入锁的事务设定的新值。当事务正在进行时，任何其他读取物件的事务都会拿到旧值。只有当新值提交后，事务才会切换到读取新值。
[^vi]: 在撰写本文时，唯一在读已提交隔离级别使用读锁的主流资料库是 IBM DB2 和使用 `read_committed_snapshot = off` 配置的 Microsoft SQL Server【23,36】。
### 快照隔离和可重复读
如果只从表面上看读已提交隔离级别，你可能就认为它完成了事务所需的一切，这是情有可原的。它允许 **中止**（原子性的要求）；它防止读取不完整的事务结果，并且防止并发写入造成的混乱。事实上这些功能非常有用，比起没有事务的系统来，可以提供更多的保证。
但是在使用此隔离级别时，仍然有很多地方可能会产生并发错误。例如 [图 7-6](../img/fig7-6.png) 说明了读已提交时可能发生的问题。
![](../img/fig7-6.png)
**图 7-6 读取偏差：Alice 观察资料库处于不一致的状态**
Alice 在银行有 1000 美元的储蓄，分为两个账户，每个 500 美元。现在有一笔事务从她的一个账户转移了 100 美元到另一个账户。如果她非常不幸地在事务处理的过程中检视其账户余额列表，她可能会在收到付款之前先看到一个账户的余额（收款账户，余额仍为 500 美元），在发出转账之后再看到另一个账户的余额（付款账户，新余额为 400 美元）。对 Alice 来说，现在她的账户似乎总共只有 900 美元 —— 看起来有 100 美元已经凭空消失了。
这种异常被称为 **不可重复读（nonrepeatable read）** 或 **读取偏差（read skew）**：如果 Alice 在事务结束时再次读取账户 1 的余额，她将看到与她之前的查询中看到的不同的值（600 美元）。在读已提交的隔离条件下，**不可重复读** 被认为是可接受的：Alice 看到的帐户余额确实在阅读时已经提交了。
> 不幸的是，术语 **偏差（skew）** 这个词是过载的：以前使用它是因为热点的不平衡工作量（请参阅 “[负载偏斜与热点消除](ch6.md#负载偏斜与热点消除)”），而这里偏差意味著异常的时序。
对于 Alice 的情况，这不是一个长期持续的问题。因为如果她几秒钟后重新整理银行网站的页面，她很可能会看到一致的帐户余额。但是有些情况下，不能容忍这种暂时的不一致：
* 备份
  进行备份需要复制整个资料库，对大型资料库而言可能需要花费数小时才能完成。备份程序执行时，资料库仍然会接受写入操作。因此备份可能会包含一些旧的部分和一些新的部分。如果从这样的备份中恢复，那么不一致（如消失的钱）就会变成永久的。
* 分析查询和完整性检查
  有时，你可能需要执行一个查询，扫描大部分的资料库。这样的查询在分析中很常见（请参阅 “[事务处理还是分析？](ch3.md#事务处理还是分析？)”），也可能是定期完整性检查（即监视资料损坏）的一部分。如果这些查询在不同时间点观察资料库的不同部分，则可能会返回毫无意义的结果。
**快照隔离（snapshot isolation）**【28】是这个问题最常见的解决方案。想法是，每个事务都从资料库的 **一致快照（consistent snapshot）** 中读取 —— 也就是说，事务可以看到事务开始时在资料库中提交的所有资料。即使这些资料随后被另一个事务更改，每个事务也只能看到该特定时间点的旧资料。