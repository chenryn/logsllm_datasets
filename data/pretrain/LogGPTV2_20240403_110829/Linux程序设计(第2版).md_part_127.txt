（x=0,y=0;ur1[y1++x,++y}（
if （（ur1（x}=ur1[y]） =²1（
url [x]s x2e(&ur1[y+1]];
}
ur1[x] \0′;
/*this routine borrowed fron the exasples that come with the NcsA server */
statie char x2c(char *what)
register char digit;
digit▪fwhati0]>=A?(（what[0]&0xdf]-A)+10：（what[0]-01;
digit+[what[1]>=A?（（what[1]0xdf}-A'}+10:{what[11-0′}};
digit *= 16;
return(digit):
加入iava编程群
：524621833
---
## Page 684
666
Linux程序设计
我们对这个程序进行编译，然后把它拷贝到cgi-bin于口录。接下来修改我们的HTML表单，
使表单的ACTION属性指向/cgi-bin/decode1.METHOD属性为POST。新HTML文档的名字是
cgi5.html.
图20-8足我们准备提交的表单信息
Netscape:A Simple HTMLFormDocur
口X
FlleEdVlewGo
Communicator
Heip
2
国
N
Back
FowardRelead
Hone
Search
Prnt
Security
g
http://1ocalhost/blp2e/cgi4.htnl
WhaRelled
Ademonstration ofan HTMLform
Eter yourss
udxew Cre11g
pmsred p
Plaseindicatslchaets t the wer yo wold ke te vt
AAsAchAAsnaEue
Plesedicte ichaaf tedyou be
Asia
wAfica
NarAnce
SeethAmenc
Atuct:e
mAusrdess
图20-8
提交表单之后，我们将看到如图20-9所示的浏览器画间
大家可以看到，表单数据中的换行符都被保留下来了。
操作注释：
这些C语言代码可够多的，我们把它分为几个小段落进行说明。我们在程序的一开始先定义
了一个用米成对儿保存--个名/值组合的结构，然后定义了-个数组来保存这些结构。我们对数
据长度做了武断地限制，这可以使这个程序示例实现起来比较简单，也比较容易理解。-个实
用性程序可能会利用一个结点链接列表来做这件事，每个结点保存一个指针，指针指向用malloc
函数分配到的一个内存区域，而名/值对就保存在这些个内存区城里一—这就可以取消数据长度
方面的限制了。
加入jaVva编程群：524621833
---
## Page 685
第20章因特网程序设计11：CGI
667
Netscape
X口
FlleEdtView
G0
Con
Help
3
国
N
Back
Fonwars
Netscepe
Pnrt
Securty
BookmrsLocaonttp/Locahost/cg-bin/decode
WharsRetated
1doartla
W门1AA
图20-9
接下来我们调用get_inpu例程来加载name_val_pairs数组，整个操作需要好儿个步骤才能完
成。首先，我们要检查数据是采用哪种方法（POST或GET）传递过来的、再把这些数据传到由
ip（data指向的字符串里去。此时，不管是用POST方法还是用GET方法传递来的数据都将被保存
在同一个地方，而我们也就可以用间样的代码来处理这两种情况了。
第-阶段是对这一整个字符中进行分断，使我fi今后能够对“name=value”形式的各个子
字符串逐个进行处理：注意这些字符中都是以“&”字符隔开的。接下来我们对每对名/值组合
调用一次load_nv_pair，它的作用是把成对的数据项从等号“=”字符处分断开。它还会把加号
“+”字符替换为空格字符
把名字和值分为两个字符串之后，我们再替换其中的特殊字符，这些特殊字符在数据里是
工作。
x2c和unescape_url这两个例程在所有以C和C++编写的解码软件里几乎都会出现（甚至连内
容都·模一样）：就我们知道的情况来说，它们出现在随NCSAWWW服务器软件提供的程
序示例中。我们既没见过它们的版权资料，也没听说过有什么人声称拥有它。因为它们的传播
范围是那么的广，并且确实能解决问题，所以我们信得过NCSA服务器软件里的这个小东为的准
加入jaVa编程群：524621833
---
## Page 686
668Linux程序设计
确性，把它照搬照用在这里。
完成了对输人数据的处理之后，我们简单地把得到的名/值对打印出来。注意我们象往常一
样在自己的输出数据之前加上了一个“Content-type”行和一个空白行，每行输出数据都以个
回车和一个换行结束。
20.4向客户返回HTML
到目前为止，从我们的CGI程序发送到客户那里的都是些纯文本。虽然它I作起来没有问题，
但看上去可不怎么吸引人。
我们现在来看看怎样才能让CGI程序自动生成HTML，使自己的输出更象是一个普通的Wcb
页面。事实上，只要我们足够认真细致，用户根本就没有理由看出由某个服务器返回的·个静
态页面和由某个CGI程序生成的一个动态页面之间有什么区别。
因为CGI程序对发送回客户的数据有着完全的控制，所以它可以发送许多不同类型的数据而
不仅仅是文本。它是用我们前面见过的“Content-type：”控制行来完成这一工作的，这个控制行
的作用是对客户浏览器预期接收的MIME类型及其子类型进行控制。我们可以不使用MIME类型
及子类型信息textplain来发送文本，利用text/html类型同样行得通。而这将使我们能够向客户发
送HTML，浏览器对它进行解码后将象对待普通HTML页面那样把它显示出来。
我们可以简单地写出如下所示的代码：
printf (*A headings/H1>\r\n") :
但这种做法比较粗糙。更好的办法是编写一些工具性的函数来完成我们向客户发送各种
HTML标签的底层功能。下面就是一些这样的底层例程。函数html（content的作用是向客户发送
--个字符串，通知它我们将向它发送HTML，如下所示：
stat : void htm]_content (vo;d)
pr1ntf (*Content -type . Lext /htmlt'n\r′n*1
html_start函数的作用是开始发送HTML的文档标题部分，它会给客户发送去一个标题字符
串并开始HTML的文档体部分，如下所示：
static void html_start (const char *titiel
pr1ntf(=\\n*):
printf (*\r\n*);
printf (*s\r\n*. t1t1e;
p11ntf(*\r\n*)
px int f (*r\n*1 ;
我们还可以再编写两个便利的工具性函数，它们一个是负责按指定级别输出段落标题文字
的html（header，另一个是负责输出普通段落文本的html_text，下面是这两个函数的定义情况：
static void hta2_headerrint level, const char *header_text)
f(level  6) level = 6: /* force the level to a valid nunber */
printf(*ss/Hed>\r\n*. level. header_text., level):
if(!header_text)return;
加入jaVa编程群：524621833
---
## Page 687
第20章因特网程序设计11：CGI
669
: at ic vci 3 html_text (const chaz *text)
pr:nt f (*$s*r\n*, Lext:
最后是用米结束HTML页面的html_end函数。如下所示：
sta* ie void htm]_end(vcd)
printf*\n*1:
(,U\,标签，但把它的SRC（正常情况下多是.gif或jpg文件）
属性设置为--个cgi-bin程序。当客户访问基础主页的时候，它就会因看到了标签而尝试
取回一个指定的图像。如果cgi-bin程序能够即时生成图像，就可以返回一个动态剧新的图像。
对这一问题的详细讨论超出了本章的范围，但如果读者想在这一方面继续钻研的话，请设
法找到一个名为gd的的图形库，它可以帮助你从代码里生成图像。
20.5.4隐藏上下文信息
在很多情况下，服务器需要在前后表单之间传递一些信息。这可能是一个用户名、一个顾
客编号，或者是一些其他的信息。
可表单们完全是分开处理的，因此，我们需要在表单上“暗藏”一些信息。我们可以用在
这一章的前面遇到的隐藏域来做这件事情，或者可以把信息添加到URL地址上的问号“？”字符
后面。
当---个利用CGI程序生成的表单被发送给客户的时候，我们可以在其上定义一个或多个隐藏
城并给它们设置上缺省的值。通过这个办法，我们就可以把信息隐藏起来，让用户暂时看不到
它们。当用户填写好表单并把它发送回服务器的时候，CGI程序就可以使用隐藏域中的数据值提
取出上下文信息来。