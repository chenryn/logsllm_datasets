ϱ
ϯ
ϰ
Ś
Đ
Ŷ
Ğ
ď
ů
ƌ
Ğ
Ɖ
Ϭ
Ϭ
ϰ
͘
D


Ɛ
Ƶ
ƚ
Đ
Ă
Đ
͘
ϲ
ϯ
ϰ
Ě
ϯ
Ğ
ŝ
ů
Ɛ
Ğ
ů
͘
ϳ
ϯ
ϰ
Ě
ŵ
Ă
Ŷ
ϰ
ϰ
ϰ
͘
Ŭ
ŵ
ď
Ž
Ő
͘
ϱ
ϰ
ϰ
/
/
ů
Ă
Ğ
Ě
ϳ
ϰ
ϰ
͘
ů
ǆ
Ğ
Ɖ
Ž
Ɛ
͘
Ϭ
ϱ
ϰ
Ǉ
Ă
ƌ
ǀ
Ž
Ɖ
ϯ
ϱ
ϰ
͘
ǆ
ŝ
ů
Ƶ
Đ
ů
Ă
Đ
͘
ϰ
ϱ
ϰ
ƌ
Ğ
ŵ
ŵ
Ś
ϲ
ϱ
ϰ
͘
Ő
Ŷ
Ğ
ũ
Ɛ
͘
ϴ
ϱ
ϰ

d

&
Ɛ
ŵ
Ğ
'
ϵ
ϱ
ϰ
͘
^WWhϮϬϬϲĞŶĐŚŵĂƌŬƐ
ŵ
Ƶ
ƚ
Ŷ
Ă
Ƶ
Ƌ
ď
ŝ
ů
͘
Ϯ
ϲ
ϰ
ŵ
ď
ů
͘
Ϭ
ϳ
ϰ
Ž
ƚ
Ŷ
Ž
ƚ
͘
ϱ
ϲ
ϰ
Ĩ
Ğ
ƌ
ϰ
ϲ
Ϯ
Ś
ϰ
ϲ
ϰ
͘
Ɖ
Ɖ
ƚ
Ğ
Ŷ
ŵ
Ž
ϭ
ϳ
ϰ
͘
Ĩ
ƌ
͘
ǁ
ϭ
ϴ
ϰ
ƌ
Ă
ƚ
Ɛ
Ă
͘
ϯ
ϳ
ϰ
Ğ
Ő
Ă
ƌ
Ğ
ǀ
Ă
ŝ
ϯ
ǆ
Ŷ
Ś
Ɖ
Ɛ
͘
Ϯ
ϴ
ϰ
Ŭ
ŵ
ď
Đ
Ŷ
Ă
Ă
ǆ
͘
ů
ϯ
ϴ
ϰ
WĞƌĐĞŶƚŽĨŝŶƐƚƌƵĐƚŝŽŶƐŵŽǀĞĚǁŝƚŚŽƵƚĐĂůůƐŝƚĞĂŶĂůǇƐŝƐ
WĞƌĐĞŶƚŽĨŝŶƐƚƌƵĐƚŝŽŶƐŵŽǀĞĚǁŝƚŚĐĂůůƐŝƚĞĂŶĂůǇƐŝƐ;/>ZͿ
WĞƌĐĞŶƚŽĨŝŶƐƚƌƵĐƚŝŽŶƐŵŽǀĞĚǁŝƚŚĐĂůůƐŝƚĞĂŶĂůǇƐŝƐ;/>ZнͿ
Figure 9. Percent of instructions moved using ILR. Results demonstrate that ILR can randomize the location of almost all instructions within an arbitrary
binary program.
attack. Figure 10 shows how ILR affects an attacker’s ability
to mount an ROP attack. The ﬁrst bar shows the percentage
of unique gadgets that have been moved by ILR. We count
unique gadgets because typically an attacker could re-use a
gadget if needed, and any particular instance of a gadget is
likely sufﬁcient to mount an attack which used that gadget.
Over 94% are moved on average, with 483.xalancbmk
being the worst performing at only 87%. The second bar
shows the results for ROPgadget version 3.1. Even more of
the gadgets appear to be hidden; over 90% in all cases, and
96% on average. What the ﬁgure does not show, however,
is that version 3.1 located slightly more gadgets in the
ILR-protected version, but found many more gadgets in the
unprotected version, thus the overall ratio has improved,
indicating that ILR is effective at hiding most gadgets in
a program, even in the face of a better gadget identiﬁcation
framework. This result is quantiﬁed in the last bar of the
ﬁgure where we count not unique gadgets, but all gadgets
(including duplicates). On average, 99.96% of the total
gadgets have had their location randomized.
On average, only 2.48 gadgets remain in the program.
The worst performing benchmark, 483.xalancbmk, has
6 unique gadgets, versus 67 for the unprotected program.
Six gadgets is not enough to mount an attack in most
cases. Even the two very simple attack templates included
with ROPgadget require 8 and 9 gadgets. We note that
on an unprotected application,
the gadget compiler can
successfully generate an attack payload for every program.
In fact, both attacks are automatically detected as possible
on 9 of the benchmarks. On the protected program, no attack
payloads are ever successfully generated.
With ILR+ (results not shown) the probability of mount-
ing an attack is further reduced. Most ILR+ protected
applications have only one gadget (21 of 29 benchmarks).
In every case, this lone gadget is an int 0x80 sequence.
Used alone, this gadget cannot mount an attack. On average,
only 1.5 gadgets remain available with ILR+.
F. Performance Metrics
1) Run-time Overhead: Figure 11 shows the performance
overhead of the base VM (Strata), as well as the overhead of
ILR and ILR+. We see that Strata adds much of the overhead
for the applications, and applying the randomization costs
little additional overhead. On average, Strata adds only 8%
overhead, with an additional 8% used for ILR. This extra
overhead occurs in the short-running, but large code size
benchmarks, for example, 400.perlbench, 403.gcc,
579
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:49:42 UTC from IEEE Xplore.  Restrictions apply. 
Ɛ
ƚ
Ğ
Ő
Ě
Ă
'
Ŷ

ŝ

Ŷ
Ž
ŝ
ƚ
Đ
Ƶ
Ě
Ğ
Z
ϭϬϬй
ϵϴй
ϵϲй
ϵϰй
ϵϮй
ϵϬй
ϴϴй
ϴϲй
ϴϰй
ϴϮй
ϴϬй
Đ
Đ
Ő
͘
ϯ
Ϭ
ϰ
Ϯ
Ɖ
ŝ
ǌ
ď
ϭ
Ϭ
ϰ
͘
͘
Ĩ
Đ
ŵ
ϵ
Ϯ
ϰ
Ɛ
Ğ
ǀ
Ă
ǁ
ď
Ϭ
ϭ
ϰ
͘
Ɛ
Ɛ
Ğ
ŵ
Ă
Ő
͘
ϲ
ϭ
ϰ
Ś
Đ
Ŷ
Ğ
ď
ů
ƌ
Ğ
Ɖ
Ϭ
Ϭ
ϰ
͘
Đ
ů
ŝ
͘
ŵ
ϯ
ϯ
ϰ
Ɖ
ŵ
Ɛ
Ƶ
Ğ
ǌ
͘
ϰ
ϯ
ϰ
Ɛ
Đ
Ă
ŵ
Ž
ƌ
Ő
͘
ϱ
ϯ
ϰ
D


Ɛ
Ƶ
ƚ
Đ
Ă
Đ
͘
ϲ
ϯ
ϰ
Ě
ϯ
Ğ
ŝ
ů
Ɛ
Ğ
ů
͘
ϳ
ϯ
ϰ
Ě
ŵ
Ă
Ŷ
ϰ
ϰ
ϰ
͘
Ŭ
ŵ
ď
Ž
Ő
͘
ϱ
ϰ
ϰ
/
/
ů
Ă
Ğ
Ě
ϳ
ϰ
ϰ
͘
ǆ
Ğ
ů
Ɖ
Ž
Ɛ
͘
Ϭ
ϱ
ϰ
Ǉ
Ă
ƌ
ǀ
Ž
Ɖ
ϯ
ϱ
ϰ
͘
ǆ
ŝ
ů
Ƶ
Đ
ů
Ă
Đ
͘
ϰ
ϱ
ϰ
ƌ
Ğ
ŵ
ŵ
Ś
ϲ
ϱ
ϰ
͘
Ő
Ŷ
Ğ
ũ
Ɛ
͘
ϴ
ϱ
ϰ

d

&
Ɛ
ŵ
Ğ
'
ϵ
ϱ
ϰ
͘
^WWhϮϬϬϲĞŶĐŚŵĂƌŬƐ
ŵ
Ƶ
ƚ
Ŷ
Ă
Ƶ
Ƌ