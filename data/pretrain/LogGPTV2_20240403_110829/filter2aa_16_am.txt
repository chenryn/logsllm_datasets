那么其它函数就不能访问变量 buf 与 bufp，因此这两个名字不会和同一程序中的其它文件中 的相同的名字相冲突。同样，可以通过把变量 sp 与 val 声明为静态类型隐藏这两个由执行 校操作的 push 与 pop 函数使用的变量。
外部的 static 声明通常多用于变量，当然，它也可用于声明函数。通常情况下，函数 名字是全局可访问的，对整个程序的各个部分而言都可见。但是，如果把函数声明为 static 类型，则该函数名除了对该函数声明所在的文件可见外，其它文件都无法访问。
static 也可用于声明内部变量。static 类型的内部变量同自动变量一样，是某个特定 函数的局部变量，只能在该函数中使用，但它与自动变量不同的是，不管其所在函数是否被 调用，它一直存在，而不像自动变量那样，随着所在函数的被调用和退出而存在和消失。换 句话说，static 类型的内部变量是一种只能在某个特定函数中使用但一直占据存储空间的变 量。
练习 4•11             修改 getop 函数，使其不必使用 ungetch 函数。提示:可以使用一个
static 类型的内部变量解决该问题。
4.7 寄存器变量
register 声明告诉编译器，它所声明的变量在程序中使用频率较高。其思想是，将 register 变量放在机器的寄存器中，这样可以使程序更小、执行速度更快。但编译器可以 忽略此选页。
register 声明的形式如下所示:
register int x; register char c;
register 声明只适用于自动变量以及函数的形式参数。下面是后一种情况的例子:
f(register unsigned m, register long n)
{
register int i;
...
}
实际使用时，底层硬件环境的实际情况对寄存器变量的使用会有一些限制。每个函数中 只有很少的变量可以保存在寄存器中，且只允许某些类型的变量。但是，过量的寄存器声明 并没有什么害处，这是因为编译器可以忽略过量的或不支持的寄存器变量声明。另外，无论 寄存器变量实际上是不是存放在寄存器中，它的地址都是不能访问的(有关这一点更详细的 信息，我们将在第 5 章中讨论)。在不同的机器中，对寄存器变量的数目和类型的具体限制也 是不同的。
4.8 程序块结构
C 语言并不是 Pascal 等语言意义上的程序块结构的语言，它不允许在函数中定义函数。但 是，在函数中可以以程序块结构的形式定义变量。变量的声明(包括初始化)除了可以紧跟 在函数开始的花括号之后，还可以紧跟在任何其它标识复合语句开始的左花括号之后。以这 种方式声明的变量可以隐藏程序块外与之同名的变量，它们之间没有任何关系，并在与左花 括号匹配的右花括号出现之前一直存在。例如，在下面的程序段中:
if (n > 0) {
int i;              /* declare a new i */
for (i = 0; i 
/* printd:              print n in decimal */ void printd(int n)
{
if (n = right) /* do nothing if array contains */ return;              /* fewer than two elements */
swap(v, left, (left + right)/2); /* move partition elem */ last = left;              /* to v[0] */
for (i = left + 1; i 
的行都将被替换为由文件名指定的文件的内容。如果文件名用引号引起来，则在源文件所在 位置查找该文件;如果在该位置没有找到文件，或者如果文件名是用尖括号括起来的， 则将根据相应的规则查找该文件，这个规则同具体的实现有关。被包含的文件本身也可包含
#include 指令。
源文件的开始处通常都会有多个#include 指令，它们用以包含常见的#define 语句和 extern 声明，或从头文件中访问库函数的函数原型声明，比如。(严格地说，这 些内容没有必要单独存放在文件中;访问头文件的细节同具体的实现有关。)
在大的程序中，#include 指令是将所有声明捆绑在一起的较好的方法。它保证所有的 源文件都具有相同的定义与变量声明，这样可以避免出现一些不必要的错误。很自然，如果 某个包含文件的内容发生了变化，那么所有依赖于该包含文件的源文件都必须重新编译。
4.11.2.               宏替换
宏定义的形式如下:
#define 名字 替换文本
这是一种最简单的宏替换 —— 后续所有出现名字记号的地方都将被替换为 替换文本 。
#define 指令中的名字与变量名的命名方式相同，替换文本可以是任意字符串。通常情况下，
#define 指令占一行，替换文本是#define 指令行尾部的所有剩余部分内容，但也可以把一
个较长的宏定义分成若干行，这时需要在待续的行末尾加上一个反斜杠符\。#define 指令
定义的名字的作用域从其定义点开始，到被编译的源文件的末尾处结束。宏定义中也可以使
用前面出现的宏定义。替换只对记号进行，对括在引号中的字符串不起作用。例如，如果 YES
是一个通过#define 指令定义过的名字，则在 printf("YES")或 YESMAN 中将不执行替换。
替换文本可以是任意的，例如:
#define              forever              for (;;)              /* infinite loop */
该语句为无限循环定义了一个新名字 forever。 宏定义也可以带参数，这样可以对不同的宏调用使用不同的替换文本。例如，下列宏定
义定义了一个宏 max:
#define              max(A, B)              ((A) > (B) ? (A) : (B))
使用宏 max 看起来很像是函数词用，但宏调用直接将替换文本插入到代码中。形式参数(在 此为 A 或 B)的每次出现都将被替换成对应的实际参数。因此，语句:
x = max(p+q, r+s);
将被替换为下列形式:
x = ((p+q) > (r+s) ? (p+q) : (r+s));
如果对各种类型的参数的处理是一致的，则可以将同一个宏定义应用于任何数据类型， 而无需针对不同的数据类型需要定义不同的 max 函数。
仔细考虑一下 max 的展开式，就会发现它存在一些缺陷。其中，作为参数的表达式要重 复计算两次，如果表达式存在副作用(比如含有自增运算符或输入/输出)，则会出现不正确 的情况。例如:
max(i++, j++)              /* WRONG */
它将对每个参数执行两次自增操作。同时还必须注意，要适当使用圆括号以保证计算次序的 正确性。考虑下列宏定义:
#define square(x)              x * x              /* WRONG */
当用 squrare(z+1)调用该宏定义时会出现什么情况昵? 但是，宏还是很有价值的。头文件中有一个很实用的例子:getchar 与