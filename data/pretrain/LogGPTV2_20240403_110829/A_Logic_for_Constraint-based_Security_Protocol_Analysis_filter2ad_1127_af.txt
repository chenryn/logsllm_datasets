stances of preﬁx interleavings representing partial runs, in
which not every participant necessarily ﬁnishes its execu-
tion. For example, the empty trace (cid:7)(cid:9) is always output re-
gardless of the input scenario Sc0 or IK in Procedure 13.
Clearly, the empty trace does not represent an attack on the
protocol in question. We thus need to include a termination
condition T Cφ(s) which is evaluated in every resulting state
s of a run from Procedure 13 against a PS-LTL security
property φ. When T Cφ(s) holds, we know that an attack
has happened and we can then stop execution and report the
attack trace. Otherwise, execution should continue in search
for another attack. Given a state (cid:7)Sc, IK, CS, tr(cid:9), we deﬁne
T Cφ((cid:7)Sc, IK, CS, tr(cid:9)) to hold when D(π, CS) holds, for
π = T(¬φ, tr, IK) with ¬φ is a well-behaving PS-LTL for-
mula. The termination condition essentially checks whether
tr in the current execution state can be instantiated to pro-
vide a solution of ¬φ, that is, to falsify φ: by Theorem 29,
we know that D(T(¬φ, tr, IK), CS) holds iff (cid:7)tr, IK(cid:9) (cid:16)|= φ.
In that case, the procedure terminates and outputs the trace
tr that shows an attack. Otherwise, the procedure proceeds
until an attack or no attack is found.
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:51:42 UTC from IEEE Xplore.  Restrictions apply. 
Without PS-LTL With PS-LTL
RPC ﬂawed
RPC ﬁxed
0.06s
0.08s
2.48s
11.91s
Table 5. Benchmarks
Benchmarks
In Table 5 we show some benchmarks of the
implementation w.r.t. both the ﬂawed and ﬁxed version of
the Andrew RPC protocol when checking authentication (in
particular, aliveness), comparing to our old implementation
without PS-LTL. As we can see our prototype is consider-
ably slower (we plan to optimize this, see Future Work in
the next section).
5 Related Work
Our logic is related to the trace logic proposed in [9].
PS-LTL provides more powerful temporal operators (e.g.
the yesterday Y and since S operators), which in turn allows
one to write of more expressive security properties, like per-
fect forward secrecy. PS-LTL is inspired by the success-
ful and elegant NPATRL logic [30], but, as shown in sub-
sequent work [26], NPATRL is strictly less powerful than
LTL; also in that paper it is mentioned that the implemen-
tation of NPATRL to NRL Protocol Analyzer [24] presents
difﬁculties (e.g. the inability to mention several learn’s in
the same formula, a restriction we do not impose and that
is essential to specify e.g. perfect forward secrecy). Our
treatment of pure-past LTL is an adaptation of Havelund
and Rosu [19]. We provide a different semantics tailored
for security and constraint solving, but also include a differ-
ent deﬁnition for historically H, which we believe preserves
better the faithfulness to standard LTL.
Our decision procedure exploits the ability to solve
negated constraints. The idea to solve negated constraints
is based on allowing the intruder to generate constants, as
done originally in the work of K¨ahler and K¨usters [21] for
analysis of contract signing protocols in constraint solving.
Finally, we use events start, run and end to specify au-
thentication properties as correspondence assertions `a la
Gordon and Jeffrey [18].
6 Conclusions and Future Work
We propose PS-LTL, a language for specifying secu-
rity properties. Our language is based on linear tempo-
ral logic (LTL) with pure-past operators. This language
is both simple to use and expressive, as evidenced by the
ability to specify several security properties including au-
thentication [23, 12] (aliveness, weak agreement and non-
injective agreement), secrecy (standard secrecy [2] and per-
fect forward secrecy [16]) and also data freshness [9]. We
also study properties to prevent against denial of service
(DoS) [25] attacks. Having a dedicated language to spec-
ify properties allows the protocol designer to fairly separate
the protocol instances under study from the properties one
wants to check. This is useful during the veriﬁcation phase
of the protocol, as it allows to change the protocol instances
(e.g. to add more sessions) while keeping the property un-
changed.
We present a sound and complete decision procedure to
check a fragment of PS-LTL against symbolic traces, thus
integrating the PS-LTL interpreter into our protocol ver-
iﬁcation tool,providing a full veriﬁcation system This has
signiﬁcant practical value to protocol designers, as effec-
tive protocol debugging can be applied effectively during
the engineering phase of the security protocol design.
Future Work There are many possible directions for fu-
ture work. As already mentioned, we would like to study
further the speciﬁcation of denial of service properties (see
Section 3.2.3).
It is theoretically interesting to study whether a general
strategy to solve negated constraints exists (in Section 4.1
we provide a strategy to solve ¬(m : T ) in the particu-
lar case of m ground; Still, this is enough to cover all our
properties of interest). It would also be interesting to relate
negated constraints to other approaches in the literature to
solve “negative” predicates, e.g. nonunif of [3].
Another direction is to implement formula checking
for example, such an implementation
more efﬁciently:
would not recompute the translation of PS-LTL to elemen-
tary formula EF every time a property is checked, but main-
tain an internal data structure which can be optimized as the
trace gets expanded, along the lines of [19]. We are also in-
terested on enlarging the subclass Φ of PS-LTL from Sec-
tion 4.2, thus obtaining a more expressive language (e.g. to
cover stronger authentication notions like the ones in [12]).
Acknowledgements We are grateful to Pieter Hartel, Ralf
K¨usters and the anonymous reviewers (both from this con-
ference and from the FMSE2005 workshop) for their very
useful comments.
References
[1] D. Basin, S. Modersheim, and L. Vigano. Constraint differ-
entiation: A new reduction technique for constraint-based
analysis of security protocols. In Workshop on Security Pro-
tocol Veriﬁcation. CONCUR 2003, September 2003.
[2] B. Blanchet. Automatic proof of strong secrecy for secu-
rity protocols. Research Report MPI-I-2004-NWG1-001,
Max-Planck-Institut f¨ur Informatik, Stuhlsatzenhausweg 85,
66123 Saarbr¨ucken, Germany, July 2004.
[3] B. Blanchet, M. Abadi, and C. Fournet. Automated Veriﬁ-
cation of Selected Equivalences for Security Protocols. In
20th IEEE Symposium on Logic in Computer Science (LICS
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:51:42 UTC from IEEE Xplore.  Restrictions apply. 
[19] K. Havelund and G. Rosu. Testing linear temporal logic
formulae on ﬁnite execution traces. Technical Report TR
01-08, RIACS, 2001.
[20] J. Heather, G. Lowe, and S. Schneider. How to prevent
type ﬂaw attacks on security protocols. In Proceedings, 13th
Computer Security Foundations Workshop. IEEE Computer
Society Press, July 2000.
[21] D. K¨ahler and R. K¨usters. Constraint Solving for Contract-
Signing Protocols.
the 16th Inter-
national Conference on Concurrency Theory (CONCUR
2005), 2005. To appear.
In Proceedings of
[22] G. Lowe. Some new attacks upon security protocols.
In
PCSFW: Proceedings of The 9th Computer Security Foun-
dations Workshop. IEEE Computer Society Press, 1996.
[23] G. Lowe. A hierarchy of authentication speciﬁcations.
In Proceedings of 10th IEEE Computer Security Founda-
tions Workshop, 1997, pages 31–44. IEEE Computer Soci-
ety Press, 1997.
[24] C. Meadows. The NRL protocol analyzer: An overview.
Journal of Logic Programming, 26(2):113–131, 1996.
[25] C. Meadows. A formal framework and evaluation method
for network denial of service. In CSFW ’99: Proceedings of
the 1999 IEEE Computer Security Foundations Workshop,
page 4, Washington, DC, USA, 1999. IEEE Computer Soci-
ety.
[26] C. Meadows, P. F. Syverson, , and I. Cervesato. Formal
speciﬁcation and analysis of the group domain of interpreta-
tion protocol using NPATRL and the NRL protocol analyzer.
Journal of Computer Security, 12(6):893–931, 2004.
[27] J. Millen.
Constraint
solver webpage,
at http:
//www.csl.sri.com/users/millen/capsl/
constraints.html.
[28] J. Millen and V. Shmatikov. Constraint solving for bounded-
process cryptographic protocol analysis. In 8th ACM Con-
ference on Computer and Communication Security, pages
166–175. ACM SIGSAC, November 2001.
[29] M. Rusinowitch and M. Turuani. Protocol insecurity with ﬁ-
nite number of sessions is np-complete. In S. Schneider, ed-
itor, Proc. 14th IEEE Computer Security Foundations Work-
shop, 2001.
[30] P. Syverson and C. Meadows. A formal language for cryp-
tographic protocol requirements. Designs, Codes and Cryp-
tography, 7:27 – 59, 1996.
[31] F. Thayer F´abrega, J. Herzog, and J. Guttman.
Strand
spaces: Proving security protocols correct. Journal of Com-
puter Security, 7:191–230, 1999.
2005), pages 331–340, Chicago, IL, June 2005. IEEE Com-
puter Society.
[4] C. Boyd and A. Mathuria. Protocols for Authentication and
Key Establishment. Springer-Verlag, 2003.
[5] M. Burrows, M. Abadi, and R. Needham. A logic of authen-
tication. ACM Transactions on Computer Systems, 8(1):18–
36, 1990.
[6] J. Clark and J. Jacob. A survey of authentication protocol lit-
erature: Version 1.0. http://www.cs.york.ac.uk/
∼jac/papers/drareview.ps.gz, 1997.
[7] J. A. Clark and J. Jacob. A Survey of Authentication Proto-
col Literature: Version 1.0. University of York, Department
of Computer Science, November 1997.
[8] R. Corin. Analysis Models for Security Protocols. PhD the-
sis, University of Twente, 2006.
[9] R. Corin, A. Durante, S. Etalle, and P. H. Hartel. A trace
logic for local security properties. In Int. Workshop on Soft-
ware Veriﬁcation and Validation (SVV), volume 118, Mum-
bai, India, Dec 2003. Elsevier Science in Electronic Notes
in Theoretical Computer Science.
[10] R. Corin and S. Etalle. An improved constraint-based sys-
tem for the veriﬁcation of security protocols.
In M. V.
Hermenegildo and G. Puebla, editors, 9th Int. Static Analysis
Symp. (SAS), volume LNCS 2477, pages 326–341, Madrid,
Spain, Sep 2002.
[11] R. Corin, S. Etalle,
and A. Saptawijaya.
Online
at
demos.
Improved Constraint-based procedure
http://130.89.144.15/cgi-bin/show.cgi.
PS-LTL
cgi-bin/psltl/show.cgi, June 2005.
http://130.89.144.15/
demo
at
[12] C. Cremers, S. Mauw, and E. de Vink. Deﬁning authentica-
tion in a trace model. In T. Dimitrakos and F. Martinelli, ed-
itors, Fast 2003, Proceedings of the ﬁrst international Work-
shop on Formal Aspects in Security and Trust, pages 131–
145, Pisa, September 2003. IITT-CNR technical report.
A theory of dictio-
[13] S. Delaune and F. Jacquemard.
nary attacks and its complexity.
In Proceedings of
the 17th IEEE Computer Security Foundations Workshop
(CSFW’04), pages 2–15, Asilomar, Paciﬁc Grove, Califor-
nia, USA, June 2004. IEEE Computer Society Press.
[14] R. Delicata and S. Schneider. Temporal rank functions for
forward secrecy.
In Proceedings of the 18th IEEE Com-
puter Security Foundations Workshop (CSFW’05), pages
126–139, 2005.
[15] G. Delzanno and S. Etalle. Proof theory, transformations,
and logic programming for debugging security protocols. In
A. Pettorossi, editor, 11th Int. Logic Based Program Syn-
thesis and Transformation (LOPSTR), volume LNCS 2372,
pages 76–90, Paphos, Greece, Nov 2001. Springer-Verlag,
Berlin.
[16] W. Difﬁe, P. C. V. Oorschot, and M. J. Wiener. Authentica-
tion and authenticated key exchanges. Designs, Codes and
Cryptography, 2(2):107 – 125, June 1992.
[17] D. Dolev and A. Yao. On the security of public key proto-
cols. IEEE Transactions on Information Theory, 29(2):198–
208, 1983.
[18] A. D. Gordon and A. S. A. Jeffrey. Types and effects for
asymmetric cryptographic protocols. J. Computer Security,
12(3/4):435–484, 2004.
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:51:42 UTC from IEEE Xplore.  Restrictions apply.