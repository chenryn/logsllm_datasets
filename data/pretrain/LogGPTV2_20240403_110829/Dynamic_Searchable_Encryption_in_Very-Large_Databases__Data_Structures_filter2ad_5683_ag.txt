 10
 1e+08
 1e+09
 1e+10
(w,id) pairs
 1e+11
 1e+12
Fig. 6. LL SKS Pre-processing: Scaling Database Size
Measurements on query performance are shown in Figure 7
for queries CW-* databases with varying result set sizes and
for both constructions. The graph demonstrates even more
dramatic improvements for query processing compared to pre-
processing as the Π2lev construction outperforms the Πpack
one by almost two orders of magnitude for queries returning
1% of the database.Experiments with the Πpack prototype
returning 13% of the database are much slower and they were
not included in the ﬁgure to improve the visibility of the
existing curves. Experiments with OXT demonstrate similar
performance gains on conjunction queries. This illustrates that
even though OXT performance seemingly is dominated by
exponentiation costs (see [3] for the details), optimizing disk-
resident data-structures are crucial for good performance due
to the high I/O latency costs.5
5Using highly optimized (common-base) NIST P-224 exponentiation and
multi-threading, we can achieve almost 500,000 exponentiation/sec on the
mentioned test bed. The storage system provided only, depending on block
size, 500-1,500 random I/O requests/sec and single request latencies is around
10ms.
14
Figure 8 shows the execution times of two queries returning
a constant, i.e., independent of the size of the input dataset,
result set of 10 and 10,000 record ids, respectively. The gap
between the two lines corresponding to the Πpack prototype is
much larger than the gap between the lines for corresponding
to the Π2lev prototype. The difference between the disk layouts
of the two constructs help explain the difference. To retrieve
the 10 or the 10,000 ids, the Πpack prototype needs to access
one or one thousand hash table buckets, respectively, which
means it will
issue one thousand times more disk access
requests for the second query. In contrast, for the same two
queries, the Π2lev prototype needs to access one dictionary
entry in both cases and one or eleven tuple blocks, which
means it will issue only six times more disk access requests
for the second query. Πpack hash table buckets and the Π2lev
dictionary buckets and tuple blocks are all 64KB but tuple
groups store only ten tuples in this Πpack prototype while
tuple blocks store a little under one thousand tuples. Note
that since Πpack and Π2lev experiments are using SKS and
OXT, respectively, the gap between the 2L and PH plots for
experiments returning 10 tuples is explained by the initial
computational overhead of OXT.
PH: 10,000
2L: 10,000
PH: 1% of db
2L: 1% of db
2L: 13% of db
 100000
)
s
m
(
e
m
T
i
 10000
 1000
 100
 1e+08
 1e+09
Database size as total number of (w,id) pairs
 1e+10
Fig. 7. Clueweb09 SKS Query: Scaling Database Size, comparing Πpack vs
Π2lev for various result set sizes.
2L: constant  small (10) result set
2L: constant  medium-size (10,000) result set
PH: constant  small (10) result set
PH: constant  medium-size (10,000) result set
 10000
 1000
 100
 10
)
s
m
(
e
m
T
i
 1
 1e+08
 1e+09
Database size as total number of (w,id) pairs
 1e+10
Fig. 8. Clueweb09 SKS Query: Scaling Database Size, comparing Πpack vs
Π2lev for constant (10 and 10,000) result set sizes.
Lastly, to illustrate how space efﬁcient the Π2lev construc-
tion is, we achieve load-factors of 58.5% for the bucket hash
dictionary, 91.9% for the much larger array and 91.6% overall
15
for our largest LL-MC-SKS-4 database. The load-factor of
the array A is less than 100% because although all its entries
are used for tuple blocks, some of these tuple blocks store
pointers or are only partially ﬁlled with tuples.
F. Comparison with Prior Implementations
The only previous work that stores the encrypted index on
external storage is [3], which uses a construction similar to
SSE-2 in [7] but adapted to external storage. It corresponds,
roughly, to our Πpack prototype discussed in Section V-A.
The other previous works assume that the encrypted index
is stored in main memory and that access to the index data
structure is uniform (i.e., constant cost/latency). None of
these constructions admit straightforward extensions to ’block
device’-resident data structures that can be practical. This is
particularly the case for constructions using linked lists, such
as SSE-1 in [7] or its extension to dynamic SSE in [15].
Recent work by Kamara et. al in [14] discusses an ex-
tension of their main memory index to a storage-resident B-
tree. This system suffers from using a large index (worst-
case quadratic) and their achieved CPU parallelism does not
automatically translate to efﬁcient I/O parallelism given the
different characteristics of storage sub-systems. The work of
[14] does not measure implementation performance and it does
not discuss how it would address the I/O challenges faced
when building a large scalable system. In contrast, we identify
parallel I/O access from the outset as one of the most impor-
tant performance requirements for scaling to large encrypted
indexes. In addition, we also achieve excellent CPU parallelism
during search because we parallelize our application-level im-
plementation and because a large fraction of the I/O code path
is run in parallel kernel threads. We also validate our approach
with experimental results, paramount given the intricacies of
storage sub-systems. Finally, our construction does not require
a ﬁxed keyword set and is asymptotically faster by log n than
the tree construction in [14], as we use hash instead of tree
indexing.
VI. CONCLUSIONS
The tension between security and performance require-
ments for SSE systems pose non-trivial challenges for both the
cryptographic design and the data structures needed to support
this design, as well as for their implementation. Leakage
minimization calls for randomization of data locations in the
encrypted database, EDB, in order to obscure any relations
in the original clear-text database. This results in the need to
randomize access to EDB elements even when these elements
are logically correlated (e.g., the set of documents containing
a given keyword). This random-order access is affordable for
RAM-resident EDB but becomes prohibitive for disk-resident
ones; on the other hand, restricting an implementation to a
RAM-resident EDB means limiting the database sizes one
can support. Thus, much of the work reported here, both
at the abstract data structure level and the speciﬁcs of their
implementation, are driven by the need to bridge over this
security-performance conundrum, and is intended to ﬁnd a
balance between randomized ordering of data,
locality of
access and parallel processing. In particular, our two-level
scheme seems to achieve a desirable trade-off between these
competing requirements.
As a result we are able to demonstrate the practicality of
search on encrypted data for very large datasets (at terabytes-
scale and 10s of billions of record-keyword pairs) and with
strong security guarantees. Moreover, our implementation ex-
perience shows that even complex queries, as those supported
in the work of [3], that go well beyond the single-keyword
search capability of traditional SSE schemes, can be supported
in practical ways for these very large databases. The same is
true for the complex operational settings of [13] that support
delegation and authorization of queries to multiple clients as
well as providing query privacy from the data owner.
Regarding the security of our schemes, it is important to
highlight that while the leakage of our constructions compares
well with related work, there is non-trivial information being
disclosed to the server about result sets (e.g., the size of these
sets and their intersections). When the server has a priori
information on the database and queries, various statistical
attacks are plausible as illustrated, for instance, in [12]. To
mitigate such attacks one can apply various generic masking
counter-measures such as padding the sets DB(w) with dummy
elements or batching multiple updates to obfuscate update
patterns. Hopefully, future work will shed more light on the
best ways to design such masking techniques. In particular, one
confronts the hard problem of how the syntactically-deﬁned
leakage can be captured in a semantic way such that for real
world data sets and query distributions one can decide how
much and what type of masking approaches are effective.
As mentioned in the introduction, an attractive alternative
to achieve more secure solutions to the SSE problem is the use
of Oblivious RAM (ORAM) for which we have seen tremen-
dous progress recently in terms of practical performance.
However, nobody to our knowledge has yet systematically
assessed on how to implement leakage-free search algorithms
on top of ORAM servers. Even if we would tolerate the
amount of leakage equivalent to our constructions, it is not
clear whether one could achieve a similar level of performance
for ORAM when considering critical practical aspects such
as parallelism and interleaving of I/O and computation as
exploited in our approach. Furthermore, the extensibility of
ORAM-based solutions to scenarios such as multi-client poses
even further challenges.
ACKNOWLEDGMENT
Supported by the Intelligence Advanced Research Projects
Activity (IARPA) via Department of Interior National Business
Center (DoI / NBC) contract number D11PC20201. The U.S.
Government is authorized to reproduce and distribute reprints
for Governmental purposes notwithstanding any copyright
annotation thereon. Disclaimer: The views and conclusions
contained herein are those of the authors and should not
be interpreted as necessarily representing the ofﬁcial policies
or endorsements, either expressed or implied, of IARPA,
DoI/NBC, or the U.S. Government.
REFERENCES
[1] M. Bellare and P. Rogaway. Random oracles are practical: A paradigm
for designing efﬁcient protocols.
In V. Ashby, editor, ACM CCS 93,
pages 62–73, Fairfax, Virginia, USA, Nov. 3–5, 1993. ACM Press. 3
[2] D. Boneh, G. Di Crescenzo, R. Ostrovsky, and G. Persiano. Public
key encryption with keyword search. In C. Cachin and J. Camenisch,
editors, EUROCRYPT 2004, volume 3027 of LNCS, pages 506–522,
Interlaken, Switzerland, May 2–6, 2004. Springer, Berlin, Germany. 2
[3] D. Cash, S. Jarecki, C. S. Jutla, H. Krawczyk, M.-C. Rosu, and
M. Steiner. Highly-scalable searchable symmetric encryption with
support for boolean queries.
In R. Canetti and J. A. Garay, editors,
CRYPTO 2013, Part I, volume 8042 of LNCS, pages 353–373, Santa
Barbara, CA, USA, Aug. 18–22, 2013. Springer, Berlin, Germany. 1,
2, 4, 10, 11, 12, 13, 14, 15, 16
[4] Y.-C. Chang and M. Mitzenmacher.
Privacy preserving keyword
searches on remote encrypted data. In J. Ioannidis, A. Keromytis, and
M. Yung, editors, ACNS 05, volume 3531 of LNCS, pages 442–455,
New York, NY, USA, June 7–10, 2005. Springer, Berlin, Germany. 1
Structured encryption and controlled
disclosure. In M. Abe, editor, ASIACRYPT 2010, volume 6477 of LNCS,
pages 577–594, Singapore, Dec. 5–9, 2010. Springer, Berlin, Germany.
1, 2, 3, 4, 5
[5] M. Chase and S. Kamara.
[6] B. Chor, O. Goldreich, E. Kushilevitz, and M. Sudan. Private informa-
tion retrieval. Journal of the ACM, 45(6):965–981, 1998. 2
[7] R. Curtmola, J. A. Garay, S. Kamara, and R. Ostrovsky. Searchable
symmetric encryption: improved deﬁnitions and efﬁcient constructions.
In A. Juels, R. N. Wright, and S. Vimercati, editors, ACM CCS 06, pages
79–88, Alexandria, Virginia, USA, Oct. 30 – Nov. 3, 2006. ACM Press.
1, 2, 3, 4, 15
[8] M. Dietzfelbinger, M. Mitzenmacher, and M. Rink. Cuckoo hashing
with pages. Technical Report abs/1104.5111, arXiv, 2011. 11
[9] E.-J. Goh. Secure indexes. Cryptology ePrint Archive, Report 2003/216,
2003. http://eprint.iacr.org/. 1
[10] O. Goldreich and R. Ostrovsky. Software protection and simulation on
oblivious RAMs. Journal of the ACM, 43(3):431–473, 1996. 2
[11] M. T. Goodrich, M. Mitzenmacher, O. Ohrimenko, and R. Tamassia.
Oblivious ram simulation with efﬁcient worst-case access overhead. In
CCSW, pages 95–100, 2011. 3
[12] M. Islam, M. Kuzu, and M. Kantarcioglu. Access pattern disclosure
on searchable encryption: Ramiﬁcation, attack and mitigation.
In
Proceedings of the Symposium on Network and Distributed Systems
Security (NDSS 2012), San Diego, CA, Feb. 2012. Internet Society. 16
[13] S. Jarecki, C. Jutla, H. Krawczyk, M. C. Rosu, and M. Steiner.
Outsourced symmetric private information retrieval. In ACM CCS 13,
Berlin, Germany, Nov. 4–8, 2013. ACM Press. 2, 4, 10, 13, 14, 16
[14] S. Kamara and C. Papamanthou. Parallel and dynamic searchable
symmetric encryption. In A.-R. Sadeghi, editor, FC 2013, volume 7859
of LNCS, pages 258–274, Okinawa, Japan, Apr. 1–5, 2013. Springer,
Berlin, Germany. 1, 2, 3, 10, 15
[15] S. Kamara, C. Papamanthou, and T. Roeder. Dynamic searchable
symmetric encryption. In T. Yu, G. Danezis, and V. D. Gligor, editors,
ACM CCS 12, pages 965–976, Raleigh, NC, USA, Oct. 16–18, 2012.
ACM Press. 1, 2, 3, 4, 10, 14, 15
J. Katz and Y. Lindell. Introduction to Modern Cryptography (Chapman
& Hall/Crc Cryptography and Network Security Series). Chapman &
Hall/CRC, 2007. 3
[16]
[17] K. Kurosawa and Y. Ohtaki. UC-secure searchable symmetric encryp-
tion.
In A. D. Keromytis, editor, FC 2012, volume 7397 of LNCS,
pages 285–298, Kralendijk, Bonaire, Feb. 27 – Mar. 2, 2012. Springer,
Berlin, Germany. 1, 3
Project.
[18] Lemur
ClueWeb09
dataset.
http://lemurproject.org/clueweb09.php/. 14
[19] D. X. Song, D. Wagner, and A. Perrig. Practical techniques for searches
on encrypted data. In 2000 IEEE Symposium on Security and Privacy,
pages 44–55, Oakland, California, USA, May 2000. IEEE Computer
Society Press. 1, 2
[20] E. Stefanov, E. Shi, and D. X. Song. Towards practical oblivious
In NDSS 2012, San Diego, California, USA, Feb. 5–8, 2012.
RAM.
The Internet Society. 3
[21] P. van Liesdonk, S. Sedhi, J. Doumen, P. H. Hartel, and W. Jonker.
Computationally efﬁcient searchable symmetric encryption.
In Proc.
Workshop on Secure Data Management (SDM), pages 87–100, 2010.
1, 3, 10
16