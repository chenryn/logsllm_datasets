6
Runtime Provisioning
PS
1
Kernel Process Manager
PTI
1
Push to Install Service
RDR
1
Kernel SMB Redirector
RM
3
Game Mode Resource Manager
RPC
F
1
RPC Firewall Manager
RTD
S
2
Runtime Trigger Data Store
RTS
C
2
Recommended Troubleshooting Client
SBS
1
Secure Boot State
SCH
3
Secure Channel (SChannel)
SCM
1
Service Control Manager
SDO
1
Simple Device Orientation Change
SEB
61
System Events Broker
SFA
1
Secondary Factor Authentication
SHE
L
138
Shell
SHR
3
Internet Connection Sharing (ICS)
SIDX
1
Search Indexer
SIO
2
Sign-In Options
SYK
D
2
SkyDrive (Microsoft OneDrive)
SMS
R
3
SMS Router
SMSS
1
Session Manager
SMS
1
SMS Messages
SPAC
2
Storage Spaces
SPC
H
4
Speech
SPI
1
System Parameter Information
SPLT
4
Servicing
SRC
1
System Radio Change
SRP
1
System Replication
SRT
1
System Restore (Windows Recovery Environment)
SRU
M
1
Sleep Study
SRV
2
Server Message Block (SMB/CIFS)
STO
R
3
Storage
SUPP
1
Support
SYN
C
1
Phone Synchronization
SYS
1
System
TB
1
Time Broker
TEA
M
4
TeamOS Platform
TEL
5
Microsoft Defender ATP Telemetry
TET
H
2
Tethering
THM
E
1
Themes
TKB
24
Touch Keyboard Broker
N
TKB
R
3
Token Broker
TMC
N
1
Tablet Mode Control Notification
TOP
E
1
Touch Event
TPM
9
Trusted Platform Module (TPM)
TZ
6
Time Zone
UBP
M
4
User Mode Power Manager
UDA
1
User Data Access
UDM
1
User Device Manager
UMD
F
2
User Mode Driver Framework
UMG
R
9
User Manager
USB
8
Universal Serial Bus (USB) Stack
USO
16
Update Orchestrator
UTS
2
User Trusted Signals
UUS
1
Unknown
UWF
4
Unified Write Filter
VAN
1
Virtual Area Networks
VPN
1
Virtual Private Networks
VTS
V
2
Vault Service
WAA
S
2
Windows-as-a-Service
WBI
O
1
Windows Biometrics
WCD
S
1
Wireless LAN
WC
M
6
Windows Connection Manager
WDA
G
2
Windows Defender Application Guard
WDS
C
1
Windows Defender Security Settings
WEB
A
2
Web Authentication
WER
3
Windows Error Reporting
WFA
S
1
Windows Firewall Application Service
WFD
N
3
WiFi Display Connect (MiraCast)
WFS
5
Windows Family Safety
WHT
P
2
Windows HTTP Library
WIFI
15
Windows Wireless Network (WiFi) Stack
WIL
20
Windows Instrumentation Library
WNS
1
Windows Notification Service
WOF
1
Windows Overlay Filter
WOS
C
9
Windows One Setting Configuration
WPN
5
Windows Push Notifications
WSC
1
Windows Security Center
WSL
1
Windows Subsystem for Linux
WSQ
M
1
Windows Software Quality Metrics (SQM)
WUA
6
Windows Update
WW
5
Wireless Wire Area Network (WWAN) Service
AN
XBO
X
116
XBOX Services
WNF state names and storage
WNF state names are represented as random-looking 64-bit identifiers such
as 0xAC41491908517835 and then defined to a friendly name using C
preprocessor macros such as WNF_AUDC_CAPTURE_ACTIVE. In reality,
however, these numbers are used to encode a version number (1), a lifetime
(persistent versus temporary), a scope (process-instanced, container-
instanced, user-instanced, session-instanced, or machine-instanced), a
permanent data flag, and, for well-known state names, a prefix identifying the
owner of the state name followed by a unique sequence number. Figure 8-41
below shows this format.
Figure 8-41 Format of a WNF state name.
As mentioned earlier, state names can be well-known, which means that
they are preprovisioned for arbitrary out-of-order use. WNF achieves this by
using the registry as a backing store, which will encode the security
descriptor, maximum data size, and type ID (if any) under the
HKLM\SYSTEM\CurrentControlSet\Control\Notifications registry key. For
each state name, the information is stored under a value matching the 64-bit
encoded WNF state name identifier.
Additionally, WNF state names can also be registered as persistent,
meaning that they will remain registered for the duration of the system’s
uptime, regardless of the registrar’s process lifetime. This mimics permanent
objects that were shown in the “Object Manager” section of this chapter, and
similarly, the SeCreatePermanentPrivilege privilege is required to register
such state names. These WNF state names also live in the registry, but under
the HKLM\SOFTWARE\Microsoft\Windows
NT\CurrentVersion\VolatileNotifications key, and take advantage of the
registry’s volatile flag to simply disappear once the machine is rebooted. You
might be confused to see “volatile” registry keys being used for “persistent”
WNF data—keep in mind that, as we just indicated, the persistence here is
within a boot session (versus attached to process lifetime, which is what
WNF calls temporary, and which we’ll see later).
Furthermore, a WNF state name can be registered as permanent, which
endows it with the ability to persist even across reboots. This is the type of
“persistence” you may have been expecting earlier. This is done by using yet
another registry key, this time without the volatile flag set, present at
HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Notifications.
Suffice it to say, the SeCreatePermanentPrivilege is needed for this level of
persistence as well. For these types of WNF states, there is an additional
registry key found below the hierarchy, called Data, which contains, for each
64-bit encoded WNF state name identifier, the last change stamp, and the
binary data. Note that if the WNF state name was never written to on your
machine, the latter information might be missing.
Experiment: View WNF state names and data in the
registry
In this experiment, you use the Registry Editor to take a look at the
well-known WNF names as well as some examples of permanent
and persistent names. By looking at the raw binary registry data,
you will be able to see the data and security descriptor information.
Open Registry Editor and navigate to the
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control
\Notifications key.
Take a look at the values you see, which should look like the
screenshot below.
Double-click the value called 41950C3EA3BC0875
(WNF_SBS_UPDATE_AVAILABLE), which opens the raw
registry data binary editor.
Note how in the following figure, you can see the security
descriptor (the highlighted binary data, which includes the SID S-
1-5-18), as well as the maximum data size (0 bytes).
Be careful not to change any of the values you see because this
could make your system inoperable or open it up to attack.
Finally, if you want to see some examples of permanent WNF
state, use the Registry Editor to go to the
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows
NT\CurrentVersion\Notifications\Data key, and look at the value
418B1D29A3BC0C75 (WNF_DSM_DSMAPPINSTALLED). An
example is shown in the following figure, in which you can see the
last application that was installed on this system
(MicrosoftWindows.UndockedDevKit).
Finally, a completely arbitrary state name can be registered as a temporary
name. Such names have a few distinctions from what was shown so far. First,
because their names are not known in advance, they do require the
consumers and producers to have some way of passing the identifier between
each other. Normally, whoever either attempts to consume the state data first
or to produce state data instead ends up internally creating and/or using the
matching registry key to store the data. However, with temporary WNF state
names, this isn’t possible because the name is based on a monotonically
increasing sequence number.
Second, and related to this fact, no registry keys are used to encode