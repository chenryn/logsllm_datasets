cores) with 132 GB memory for the experiments in §VI-D
and §VI-F, and Intel Xeon Gold 5115 (40 cores) with 196 GB
memory for the ones in §VI-E. Both machines run Ubuntu
16.04. Note that when compared with other fuzzers that do
not natively support distributed fuzzing, we only use a single
machine in the evaluation for fairness.
Targeted engines. We evaluate the bug-ﬁnding ability
with three widely used JavaScript engines: ChakraCore [29],
JavaScriptCore [1], and V8 [16]. Note that these engines
currently operate for Microsoft Edge, Apple Safari, and Google
Chrome, which all have a large user base and are security-
critical so that they are heavily tested by OSS-Fuzz [15] and
security researchers. Also, we choose the youngest engine,
ChakraCore, as a representative in the other experiments
(i.e., evaluating aspect preserving, input validity, and code
coverage). With a design similar to other engines, ChakraCore
involves abundant complicated compiler techniques for code
optimization and also provides ﬁne-grained debug messages in
each working phase.
Collecting valid seed inputs. As DIE mutates based on the
aspects of existing test suites and PoCs, the quality and validity
of seed corpora largely affect DIE’s performance. To build the
corpus of DIE, we collect JavaScript ﬁles from two public
sources: (1) regression tests from the source repositories of
four JavaScript engines: ChakraCore, JavaScriptCore, V8, and
SpiderMonkey, and (2) js-vuln-db [18], a public repository
that collects PoCs of JavaScript engine CVEs. To alleviate
compatibility issues among different JavaScript engines, we
clariﬁed the engine-speciﬁc functions (e.g., Windows Script
Host (WScript) in ChakraCore) and then implemented wrapper
functions that perform the equivalent actions in the other
engines or eliminated them as possible to suppress unexpected
ReferenceError. Moreover, to fully utilize the seed corpus,
we further removed all the assertions from the collected ﬁles
to prevent early termination of the new inputs generated by
DIE. We eventually accumulated 14,708 unique JavaScript
ﬁles, including 158 JavaScript ﬁles from js-vuln-db used in
the following experiments 2.
2We use complete set of ﬁles from these repositories to avoid cherry-picking
or biased selection.
Version
1.11.5
1.11.5*
1.11.9
1.11.9*
2.24.2
8.0.0*
JS Engine
ChakraCore
ChakraCore
ChakraCore
ChakraCore
JavaScriptCore
V8
N: # of nodes, C: # of cores
*Canary version
# Lines
780,954
797,872
781,397
797,782
443,692
995,299
Running Time
Resource
3 days
3 days
1 week
1 week
1 week
1 week
N: 22, C: 839
N: 22, C: 839
N: 22, C: 839
N: 22, C: 839
N: 22, C: 839
N: 13, C: 388
TABLE IV: Targeted JavaScript engines, their versions and the
running time DIE runs against them.
Preserved aspect
Structure & Type
Structure-only
Total
Bug
14/28 (50.00%)
12/28 (42.86%)
22/28 (92.86%)
Crash
40/84 (47.62%)
32/84 (42.86%)
72/84 (90.48%)
TABLE V: The ratio of the crashes and bugs found by DIE in
ChakraCore that exactly borrow the aspects, indicated by both structure
and type information, or only the control ﬂow structure, from the
seed ﬁles in the starting corpus.
B. Identiﬁed Bugs Including Security Vulnerabilities
To evaluate the ability of DIE in ﬁnding new vulnerabilities,
we comprehensively ran DIE in a distributed environment,
including one master node to store and synchronize intermediate
data (e.g., coverage map) and multiple slave nodes. Table IV
describes the targeted engines, period, and used resource DIE
ran for.
As a result, DIE found 28 bugs in ChakraCore, 16 bugs in
JavaScriptCore, and four bugs in V8 for a total of 48 bugs.
Table VIII shows the unique bugs found and their description.
We counted these bugs using the following criteria: (1) found
but ﬁxed issues before we reported to the vendors, (2) semantic
bugs that have different behavior from spec and other JavaScript
engines, (3) memory corruption bugs except assertions in
release build, and (4) security bugs acknowledged by vendors.
Actually, assertion in release build can be considered a
type of bug for some vendors. For example, the vendor of
JavaScriptCore accepts reports related to assertions in release
build and was willing to ﬁx them, although they are not security-
related bugs. On the other hand, the vendor of ChakraCore
does not accept reports about assertion in release build. Thus,
we eliminated the number of assertions in release build to
conservatively count the number of bugs found.
To identify all bugs by unique root cause, we manually
analyzed every found crash, and identiﬁed 48 distinct bugs.
Among the distinct bugs, we found that 16 are related to
security based on their similarity to existing bugs previously
known as security-related bugs. Of the number of security-
related bugs, we gained 12 CVEs acknowledged by vendors
and 27K USD as bug bounty rewards. In addition, 13 of the
bugs are likely security-related, including memory corruption
bugs. Interestingly, we could identify six semantic bugs in
ChakraCore because ChakraCore provides a more detailed
debugging message than the others for misbehaved situations
including semantic bugs, so DIE could reach them.
}
if (i === 10) {
i += 0;
for (let i = start; i < end; i++) {
let arr = new Array(100);
arr.fill(1.1);
}
start++;
++start;
--start;
arr[i] = 2.3023e-320;
1 function opt(arr, start, end) {
2
3
4
5
6 +
7 +
8 +
9
10
11 + arr[start] = 2.3023e-320;
12 }
13 function main() {
14
15
16
17
18 -
19 +
20
21
22 }
23 main();
Listing 1: The difference between the PoC of CVE-2019-0990 found
by DIE and that of CVE-2018-0777 contained in the corpus. The
PoC is almost seemingly identical, yet patching these bugs requires
different measure as their root cause differs from each other.
}
opt(arr, 0, 100000);
for (let i = 0; i < 1000; i++) {
opt(arr, 0, 3);
opt(arr, 0, i);
C. Effectiveness of Leveraging Aspect
As described in §III-B, DIE leverages the aspects from
existing test cases to explore a broad input space more efﬁ-
ciently and effectively. To evaluate whether aspect-preserving
mutation enables us to reach bugs, we manually investigated
the relationship between the generated crashing inputs in §VI-B
and their corresponding seed ﬁles. First, we minimized every
crashing input into a minimal PoC that can trigger the crash.
We then inspect whether the structure or type information of
the PoC that result in the crash correspond to that of the seed
ﬁle indeed. We checked the inputs for 84 distinct crashes and
28 reasoned bugs found by DIE in ChakraCore (see §VI-B).
Table V presents the number of inputs that leverage only
structure information or both structure and type information
of the original seed ﬁle. The result shows that the aspects
borrowed from the starting corpus contribute to 90.48% of the
crashes and 92.86% of the bugs found by DIE. In particular,
47.62% of the crashes and half of the bugs share both structure
and type information with the corpus. The detailed aspects of
the found bugs are described in Table VIII.
Listing 1 presents a code difference between a bug found by
DIE (i.e., CVE-2019-0990) and its seed ﬁle (i.e., CVE-2018-
0777) to show an example of shared aspects. The original seed
corpus leads to an out-of-bounds array access (Line 9), as the
JavaScript engine fails to compute the correct bounds of the
array (i.e., arr), so a bound check for the array is incorrectly
eliminated by redundancy elimination for optimization. This is
because the array index created as an induction variable (i.e.,
i) is wrongly optimized (Line 4). Similar to the seed, the bug
found by DIE leads to an out-of-bounds array access (Line 11)
due to a wrong bound check elimination for the array. It also
uses an induction variable (i.e., start) as an array index and it is
wrongly calculated 3, so it leads to a miscalculated array bound
3Patch: https://bit.ly/2MEahCK
DIE
DIEt
65.39% 34.26%
1,422
Superion
58.26%
CodeAlchemist
40.67%
Preserved aspect
# of bytecode†
-984
† The corpus totally emits 2,551 unique bytecode statements after
normalization.
-119
412
TABLE VI: The preserved aspect rate of generated input and the
difference between the number of normalized statements in the
bytecode of the seed programs and the generated inputs by DIE,
DIEt, Superion, and CodeAlchemist.
that affects the wrong array-bound elimination. This example
shows the beneﬁt of DIE in terms of borrowing existing aspects,
wrongly calculated induction variable, and using it as an array
index to invoke a wrong redundancy elimination. The structure-
preserving supported by DIE helps to keep the environment,
which leads to a wrong redundancy elimination (e.g., for and if
statement on Line 2-5), and type-preserving mutation (e.g., i on
Line 19) helps it to iterate over the loop enough times to lead to
wrong induction variable calculation. Note that the bug is not
reproducible if the if statement (Line 3-5) is eliminated, which
means a negligible code change affects the optimization phase
in JIT sensitively, which leads to the bug. Besides, although the
difference between the two PoCs seems trivial, their root cause
differs; thus, patching these two bugs requires independent
effort. The root cause of the previous bug (CVE-2018-0777)
stems from erroneous constant folding, whereas the new bug
brings its wrong behavior due to the improper array bounds
proﬁling.
D. Evaluation of Aspect Preserving
To demonstrate that preserving a structure and type in-
formation are effective to maintain interesting aspects and
compare the performance regarding aspect preserving with
existing fuzzers, we evaluate DIE, DIE without structure-
preserving, Superion, and CodeAlchemist with a seed corpus
that only contains the JavaScript programs that triggers JIT
compilation. Note that the approach of DIE without structure-
preserving (notated as DIEt for convenience) mutates any
node in a typed AST regardless of the node’s structural
meaning. DIEt still respects the type information during
its mutation. First, we measure the rate of generated input
invoking the JIT compilation, which is considered a criterion
to show aspect-preserving. Next, we compare the number of
unique (normalized) statements in the emitted bytecode of
the generated input with the number in the seed corpus to
further demonstrate the power of aspect-preserving mutation in
exploiting existing test cases and covering deep code paths in a
JavaScript engine. When counting statements in the bytecode,
we normalize the operands (e.g., literal and register name in
arguments of bytecode) that are false noises that hinder the true
uniqueness. Last, in order to show a more ﬁne-grained effect
of preserving a structure and type information for utilizing the
aspects of an existing test case, we evaluate the ratio difference
of JIT-optimization invocations between the set of generated
inputs and the starting corpus. Note that we choose Superion
and CodeAlchemist for comparison, as they are one of the
)
%
(
e
t
a
R
n
o
i
t
a
c
o
v
n
I
n
o
i
t
a
z
i
m
i
t
p
O
200
175
150
125
100
75
50
25
0
Forward
FGPeeps
FGBuild
Backward
CaptureByteCodeRegUse
BackEnd
DeadStore
GlobOpt
Etc
Die
Diet
Superion CodeAlchemist
)
%
(
e
t
a
R
r
o
r
r
E
40
30
20
10
0
SyntaxError
ReferenceError
TypeError
RangeError
l a
l
V a n i
D i e c
D i e
r
S u p e
i o n
C o d e A l
c h e m i
z
f u n f u z
t
s
s
j
Fig. 4: The ratio difference of JIT-optimization invocations between
the generated inputs and seed ﬁles. The y-axis represents the
absolute difference between the rate, which means the number of
invoked optimization phases per JIT invocation. Based on the same