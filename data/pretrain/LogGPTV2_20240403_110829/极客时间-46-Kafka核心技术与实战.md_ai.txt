## **"消息丢失"案例**好了，理解了 Kafka是怎样做到不丢失消息的，那接下来我带你复盘一下那些常见的"Kafka消息丢失"案例。注意，这里可是带引号的消息丢失哦，其实有些时候我们只是冤枉了Kafka 而已。**案例 1：生产者程序丢失数据**Producer程序丢失消息，这应该算是被抱怨最多的数据丢失场景了。我来描述一个场景：你写了一个Producer 应用向 Kafka 发送消息，最后发现 Kafka没有保存，于是大骂："Kafka真烂，消息发送居然都能丢失，而且还不告诉我？！"如果你有过这样的经历，那么请先消消气，我们来分析下可能的原因。目前 Kafka Producer 是异步发送消息的，也就是说如果你调用的是producer.send(msg) 这个API，那么它通常会立即返回，但此时你不能认为消息发送已成功完成。这种发送方式有个有趣的名字，叫"fire andforget"，翻译一下就是"发射后不管"。这个术语原本属于导弹制导领域，后来被借鉴到计算机领域中，它的意思是，执行完一个操作后不去管它的结果是否成功。调用producer.send(msg) 就属于典型的"fire andforget"，因此如果出现消息丢失，我们是无法知晓的。这个发送方式挺不靠谱吧，不过有些公司真的就是在使用这个API 发送消息。如果用这个方式，可能会有哪些因素导致消息没有发送成功呢？其实原因有很多，例如网络抖动，导致消息压根就没有发送到Broker 端；或者消息本身不合格导致 Broker拒绝接收（比如消息太大了，超过了 Broker 的承受能力）等。这么来看，让Kafka"背锅"就有点冤枉它了。就像前面说过的，Kafka不认为消息是已提交的，因此也就没有 Kafka 丢失消息这一说了。不过，就算不是 Kafka的"锅"，我们也要解决这个问题吧。实际上，解决此问题的方法非常简单：**Producer永远要使用带有回调通知的发送 API，也就是说不要使用producer.send(msg)，而要使用 producer.send(msg,callback)**。不要小瞧这里的callback（回调），它能准确地告诉你消息是否真的提交成功了。一旦出现消息提交失败的情况，你就可以有针对性地进行处理。举例来说，如果是因为那些瞬时错误，那么仅仅让 Producer重试就可以了；如果是消息不合格造成的，那么可以调整消息格式后再次发送。总之，处理发送失败的责任在Producer 端而非 Broker 端。你可能会问，发送失败真的没可能是由 Broker端的问题造成的吗？当然可能！如果你所有的 Broker 都宕机了，那么无论Producer 端怎么重试都会失败的，此时你要做的是赶快处理 Broker端的问题。但之前说的核心论据在这里依然是成立的：Kafka依然不认为这条消息属于已提交消息，故对它不做任何持久化保证。**案例 2：消费者程序丢失数据**Consumer 端丢失数据主要体现在 Consumer 端要消费的消息不见了。Consumer程序有个"位移"的概念，表示的是这个 Consumer 当前消费到的 Topic分区的位置。下面这张图来自于官网，它清晰地展示了 Consumer 端的位移数据。![](Images/eb481c0458989f05b72fee62c9f130ac.png){savepage-src="https://static001.geekbang.org/resource/image/0c/37/0c97bed3b6350d73a9403d9448290d37.png"}比如对于 Consumer A 而言，它当前的位移值就是 9；Consumer B 的位移值是11。这里的"位移"类似于我们看书时使用的书签，它会标记我们当前阅读了多少页，下次翻书的时候我们能直接跳到书签页继续阅读。正确使用书签有两个步骤：第一步是读书，第二步是更新书签页。如果这两步的顺序颠倒了，就可能出现这样的场景：当前的书签页是第90 页，我先将书签放到第 100 页上，之后开始读书。当阅读到第 95页时，我临时有事中止了阅读。那么问题来了，当我下次直接跳到书签页阅读时，我就丢失了第96～99 页的内容，即这些消息就丢失了。同理，Kafka 中 Consumer端的消息丢失就是这么一回事。要对抗这种消息丢失，办法很简单：**维持先消费消息（阅读），再更新位移（书签）的顺序**即可。这样就能最大限度地保证消息不丢失。当然，这种处理方式可能带来的问题是消息的重复处理，类似于同一页书被读了很多遍，但这不属于消息丢失的情形。在专栏后面的内容中，我会跟你分享如何应对重复消费的问题。除了上面所说的场景，其实还存在一种比较隐蔽的消息丢失场景。我们依然以看书为例。假设你花钱从网上租借了一本共有 10章内容的电子书，该电子书的有效阅读时间是 1天，过期后该电子书就无法打开，但如果在 1 天之内你完成阅读就退还租金。为了加快阅读速度，你把书中的 10 个章节分别委托给你的 10个朋友，请他们帮你阅读，并拜托他们告诉你主旨大意。当电子书临近过期时，这10个人告诉你说他们读完了自己所负责的那个章节的内容，于是你放心地把该书还了回去。不料，在这10个人向你描述主旨大意时，你突然发现有一个人对你撒了谎，他并没有看完他负责的那个章节。那么很显然，你无法知道那一章的内容了。对于 Kafka 而言，这就好比 Consumer 程序从 Kafka获取到消息后开启了多个线程异步处理消息，而 Consumer程序自动地向前更新位移。假如其中某个线程运行失败了，它负责的消息没有被成功处理，但位移已经被更新了，因此这条消息对于Consumer 而言实际上是丢失了。这里的关键在于 Consumer自动提交位移，与你没有确认书籍内容被全部读完就将书归还类似，你没有真正地确认消息是否真的被消费就"盲目"地更新了位移。这个问题的解决方案也很简单：**如果是多线程异步处理消费消息，Consumer程序不要开启自动提交位移，而是要应用程序手动提交位移**。在这里我要提醒你一下，单个Consumer程序使用多线程来消费消息说起来容易，写成代码却异常困难，因为你很难正确地处理位移的更新，也就是说避免无消费消息丢失很简单，但极易出现消息被消费了多次的情况。
## **最佳实践**看完这两个案例之后，我来分享一下 Kafka无消息丢失的配置，每一个其实都能对应上面提到的问题。1.  不要使用 producer.send(msg)，而要使用 producer.send(msg,    callback)。记住，一定要使用带有回调通知的 send 方法。2.  设置 acks = all。acks 是 Producer    的一个参数，代表了你对"已提交"消息的定义。如果设置成    all，则表明所有副本 Broker    都要接收到消息，该消息才算是"已提交"。这是最高等级的"已提交"定义。3.  设置 retries 为一个较大的值。这里的 retries 同样是 Producer    的参数，对应前面提到的 Producer    自动重试。当出现网络的瞬时抖动时，消息发送可能会失败，此时配置了    retries \> 0 的 Producer 能够自动重试消息发送，避免消息丢失。4.  设置 unclean.leader.election.enable = false。这是 Broker    端的参数，它控制的是哪些 Broker 有资格竞选分区的 Leader。如果一个    Broker 落后原先的 Leader 太多，那么它一旦成为新的    Leader，必然会造成消息的丢失。故一般都要将该参数设置成    false，即不允许这种情况的发生。5.  设置 replication.factor \>= 3。这也是 Broker    端的参数。其实这里想表述的是，最好将消息多保存几份，毕竟目前防止消息丢失的主要机制就是冗余。6.  设置 min.insync.replicas \> 1。这依然是 Broker    端参数，控制的是消息至少要被写入到多少个副本才算是"已提交"。设置成大于    1 可以提升消息持久性。在实际环境中千万不要使用默认值 1。7.  确保 replication.factor \>    min.insync.replicas。如果两者相等，那么只要有一个副本挂机，整个分区就无法正常工作了。我们不仅要改善消息的持久性，防止数据丢失，还要在不降低可用性的基础上完成。推荐设置成    replication.factor = min.insync.replicas + 1。8.  确保消息消费完成再提交。Consumer 端有个参数    enable.auto.commit，最好把它设置成    false，并采用手动提交位移的方式。就像前面说的，这对于单 Consumer    多线程处理的场景而言是至关重要的。
## **小结**今天，我们讨论了 Kafka无消息丢失的方方面面。我们先从什么是消息丢失开始说起，明确了 Kafka持久化保证的责任边界，随后以这个规则为标尺衡量了一些常见的数据丢失场景，最后通过分析这些场景，我给出了Kafka 无消息丢失的"最佳实践"。总结起来，我希望你今天能有两个收获：-   明确 Kafka 持久化保证的含义和限定条件。-   熟练配置 Kafka 无消息丢失参数。
## **开放讨论**其实，Kafka还有一种特别隐秘的消息丢失场景：增加主题分区。当增加主题分区后，在某段"不凑巧"的时间间隔后，Producer先于 Consumer 感知到新增加的分区，而 Consumer设置的是"从最新位移处"开始读取消息，因此在 Consumer感知到新分区前，Producer 发送的这些消息就全部"丢失"了，或者说 Consumer无法读取到这些消息。严格来说这是 Kafka设计上的一个小缺陷，你有什么解决的办法吗？欢迎写下你的思考和答案，我们一起讨论。如果你觉得有所收获，也欢迎把文章分享给你的朋友。![](Images/a7d15815f9efb5693db5b2d278244658.png){savepage-src="https://static001.geekbang.org/resource/image/c8/bf/c89da43deab85fe7cb06acec867aa5bf.jpg"}
# 12 \| 客户端都有哪些不常见但是很高级的功能？你好，我是胡夕。今天我要和你分享的主题是：客户端都有哪些不常见但是很高级的功能。既然是不常见，那就说明在实际场景中并没有太高的出场率，但它们依然是很高级很实用的。下面就有请今天的主角登场：Kafka拦截器。
## **什么是拦截器？**如果你用过 Spring Interceptor 或是 ApacheFlume，那么应该不会对拦截器这个概念感到陌生，其基本思想就是允许应用程序在不修改逻辑的情况下，动态地实现一组可插拔的事件处理逻辑链。它能够在主业务操作的前后多个时间点上插入对应的"拦截"逻辑。下面这张图展示了Spring MVC 拦截器的工作原理：![](Images/39e2542551aad5003a6bec4ea93942f9.png){savepage-src="https://static001.geekbang.org/resource/image/09/c4/096831a3ba037b3f9e507e6db631d3c4.png"}图片来源：[https://o7planning.org/en/11229/spring-mvc-interceptors-tutorial](https://o7planning.org/en/11229/spring-mvc-interceptors-tutorial%5Breference_end%5D)]{.reference}拦截器 1 和拦截器 2分别在请求发送之前、发送之后以及完成之后三个地方插入了对应的处理逻辑。而Flume中的拦截器也是同理，它们插入的逻辑可以是修改待发送的消息，也可以是创建新的消息，甚至是丢弃消息。这些功能都是以配置拦截器类的方式动态插入到应用程序中的，故可以快速地切换不同的拦截器而不影响主程序逻辑。Kafka拦截器借鉴了这样的设计思路。你可以在消息处理的前后多个时点动态植入不同的处理逻辑，比如在消息发送前或者在消息被消费后。``{=html}作为一个非常小众的功能，Kafka 拦截器自 0.10.0.0版本被引入后并未得到太多的实际应用，我也从未在任何 Kafka技术峰会上看到有公司分享其使用拦截器的成功案例。但即便如此，在自己的Kafka工具箱中放入这么一个有用的东西依然是值得的。今天我们就让它来发挥威力，展示一些非常酷炫的功能。
## **Kafka 拦截器****Kafka拦截器分为生产者拦截器和消费者拦截器**。生产者拦截器允许你在发送消息前以及消息提交成功后植入你的拦截器逻辑；而消费者拦截器支持在消费消息前以及提交位移后编写特定逻辑。值得一提的是，这两种拦截器都支持链的方式，即你可以将一组拦截器串连成一个大的拦截器，Kafka会按照添加顺序依次执行拦截器逻辑。举个例子，假设你想在生产消息前执行两个"前置动作"：第一个是为消息增加一个头信息，封装发送该消息的时间，第二个是更新发送消息数字段，那么当你将这两个拦截器串联在一起统一指定给Producer 后，Producer 会按顺序执行上面的动作，然后再发送消息。当前 Kafka拦截器的设置方法是通过参数配置完成的。生产者和消费者两端有一个相同的参数，名字叫interceptor.classes，它指定的是一组类的列表，每个类就是特定逻辑的拦截器实现类。拿上面的例子来说，假设第一个拦截器的完整类路径是com.yourcompany.kafkaproject.interceptors.AddTimeStampInterceptor，第二个类是com.yourcompany.kafkaproject.interceptors.UpdateCounterInterceptor，那么你需要按照以下方法在Producer 端指定拦截器：    Properties props = new Properties();List interceptors = new ArrayList<>();interceptors.add("com.yourcompany.kafkaproject.interceptors.AddTimestampInterceptor"); // 拦截器 1interceptors.add("com.yourcompany.kafkaproject.interceptors.UpdateCounterInterceptor"); // 拦截器 2props.put(ProducerConfig.INTERCEPTOR_CLASSES_CONFIG, interceptors);……现在问题来了，我们应该怎么编写 AddTimeStampInterceptor 和UpdateCounterInterceptor 类呢？其实很简单，这两个类以及你自己编写的所有Producer 端拦截器实现类都要继承org.apache.kafka.clients.producer.ProducerInterceptor 接口。该接口是Kafka 提供的，里面有两个核心的方法。1.  onSend：该方法会在消息发送之前被调用。如果你想在发送之前对消息"美美容"，这个方法是你唯一的机会。2.  onAcknowledgement：该方法会在消息成功提交或发送失败之后被调用。还记得我在上一期中提到的发送回调通知    callback 吗？onAcknowledgement 的调用要早于 callback    的调用。值得注意的是，这个方法和 onSend    不是在同一个线程中被调用的，因此如果你在这两个方法中调用了某个共享可变对象，一定要保证线程安全哦。还有一点很重要，这个方法处在    Producer    发送的主路径中，所以最好别放一些太重的逻辑进去，否则你会发现你的    Producer TPS 直线下降。同理，指定消费者拦截器也是同样的方法，只是具体的实现类要实现org.apache.kafka.clients.consumer.ConsumerInterceptor接口，这里面也有两个核心方法。1.  onConsume：该方法在消息返回给 Consumer    程序之前调用。也就是说在开始正式处理消息之前，拦截器会先拦一道，搞一些事情，之后再返回给你。2.  onCommit：Consumer    在提交位移之后调用该方法。通常你可以在该方法中做一些记账类的动作，比如打日志等。一定要注意的是，**指定拦截器类时要指定它们的全限定名**，即 fullqualifiedname。通俗点说就是要把完整包名也加上，不要只有一个类名在那里，并且还要保证你的Producer 程序能够正确加载你的拦截器类。