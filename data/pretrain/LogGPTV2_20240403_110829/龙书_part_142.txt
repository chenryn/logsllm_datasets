线化方案分别对应于图 11-51a
11-52a 和图 11-52b 所示。这两种流水
面的 SOR 代码进行流水线化，如‘
线。
11.9.4把完全可交换循环流水线化
器i，因此每个处理器执行内层循
成一个任务，而每一行组成一个流
for (j= 0; j  max(C,i)) wait (p-1);
●对于满足下列条件的 z山中所有的i和 Zl中的所有i
partition constraint) :
分别对应于语句s和 s2的一-维分划映射和满足下面的时间分划约束（time-
使
变
置
版
和嵌套在循环结构 d2 中的语句 s2 的访问
具有依赖关系的(可能相同的)访问，比如嵌套在循环结构d;中的语句s;中的访问
执行。
迭代。如果它们被分配到同一个选代，我们都知道在此迭代中第一个运算必须在第二个之后
所有数据依赖关系，那么变换就是合法的。下面显示的“时间分划约束”就是说如果一个运算依
变换把原来的循环下标值映射到最外层循环的迭代编号上。如果这样的分配能够满足程序中的
样的转换中获取流水线化并行性的细节问题。
水线化。要点在于如果在调度运算时存在自由度，那么就存在并行性。后面将会解释如何从这
不同，但是依然满足所有的依赖关系。如果我们能够找到这样的转换，就能够把这个循环结构流
赖关系的执行序列有哪些？显然，原来的执行序列满足所有的数据依赖关系。问题是是否存在
个处理器上将执行哪些计算，而是提出了下面的根本性问题：所有可能的遵循循环中原有数据依
循环的每个选代中的运算映射？
我们知道，这个时间分划约
用=的地方，这个约束使用≤。
。也就是说，在空间分划约束
一个分划单元。我们只要求这两
量，这个约束不要求它们被映射到
反本。如果两个迭代指向同一个位
于另一个运算，那么分配给前一个运算的最外层循环的迭代必须不早于分配给第二个运算的
程序的--个仿射分划映射是一个合法的时间分划（legal-time partition）当且仅当对于任意两个
为了找出可接受的外层循环的重新排序，我们希望为每个语句找到一个一维仿射变换，这个
550
图11-54 中显示的这个约束和空间分划约束看起来非常相似。它是空间分划约束的一个放松
必然有 Ci +C≤C2i2 +2
4)Fi+f=Fi+f2
3) B2i2 +b2≥0
2)Bi+b≥0
1)i 
=
口
口
日
口
口
口
口口口
□□
□□□口
口
□口
图11-54 时间分划约束
石
口
中
口
Cai+C
Fi+f
Fi+f2
Ci+c
口
口
口口
0
口
口
时间步
口只石见
口
口
口
口
口
口
口
口
口
口
口
口
口
口
口
口
口
第11章
数组
---
## Page 567
根据定义，（i,j)。
一个动态实例的下标值。令语句 s 和 s2 的计算任务的映射分别为j”，上面的先后关系约束归约为i<i"。因此
个位置，因此j+1=j’+2，或者说j=j’+1。把j=j’+1 替换到时间约束中，我们得到
例11.58
理器上执行，又或在1～100 之间的任意多个处理器上运行，上面的论断都成立。
代码同样的顺序进行。不管全部的100个选代是在同一个处理器上执行，还是在100个不同的处
因
因为j和i及无关，所以可以取任意大的值，因此C12=0必须成立。可知，这个约束的一-个可
并行性和局部性优化
1）从写访问 X[j+1]到读访问 xX[j+2]之间的真依赖关系。因为它们的实例必须访问同一
让我们首先考虑从s,到 s2 的依赖关系所决定的时间分划约束。这样，如果i≤讠'，那么转换