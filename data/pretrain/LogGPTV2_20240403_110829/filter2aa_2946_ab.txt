### 滴水逆向课程笔记 - Win32
#### 句柄表 - 17

**7.1.2 管理内核对象**

当使用特定函数创建内核对象时，会在内核层生成一个结构体。如何管理和使用这些结构体呢？虽然可以通过直接访问内核结构体的地址来管理，但这样做存在风险：应用层代码可能因不当操作修改了内核结构体的地址，从而导致系统崩溃（例如，在Windows系统中会蓝屏）。为避免这种情况，微软不将内核结构体的地址直接暴露给应用层。

#### 句柄表 - 18

**7.2 进程句柄表**

由于不能直接管理内核对象，因此引入了句柄表的概念。每个进程都有自己的句柄表，通过句柄可以间接地控制和访问内核对象。句柄实际上是指向句柄表中的索引值，起到隔离应用层与内核层的作用。

**7.3 多进程共享一个内核对象**

- A进程通过`CreateProcess`函数创建了一个内核对象。
- B进程则通过`OpenProcess`函数打开并访问A进程中创建的对象。
- A和B进程都通过各自的句柄表中的句柄（即索引）来操作同一内核对象。
- 内核对象有一个引用计数器，只有当所有持有该对象句柄的进程均执行了`CloseHandle`函数后，且计数器归零时，该内核对象才会被释放。对于线程而言，即使其关联的进程仍在运行，也需要先关闭线程句柄才能完全终止线程。

#### 句柄表 - 19

**7.4 句柄是否"可以"被继承**

- Windows提供了另一种方式共享内核对象——通过设置句柄属性允许其被子进程继承。
- `LPSECURITY_ATTRIBUTES`参数决定了新创建的对象是否可被继承。此参数包括三个成员：结构体长度、安全描述符以及句柄继承标志。

**7.5 句柄是否"允许"被继承**

- 在`CreateProcess`函数中，`bInheritHandles`参数控制着新创建的子进程是否允许继承父进程的句柄。仅当该参数设为`TRUE`时，子进程才能继承指定的句柄。

#### 进程相关API - 21

**8.1 ID与句柄**

- 创建进程成功后，`CreateProcess`返回包含四个元素的结构体：进程ID (PID)、进程句柄、线程ID (TID) 和线程句柄。
- PID是全局唯一的标识符，而句柄则是局部于某个进程内的引用。

**8.2 TerminateProcess函数**

- 使用`TerminateProcess`函数尝试强制终止另一个进程。如果尝试失败，通常是因为传递了无效的句柄。
- 若要正确地关闭进程，需先通过`OpenProcess`获取目标进程的有效句柄。

**8.3 OpenProcess函数**

- `OpenProcess`用于根据给定的PID获取对目标进程的操作权限。一旦获得有效句柄，即可进一步调用其他API如`TerminateProcess`来进行进程管理。

**8.4 以挂起形式创建进程**

- `dwCreationFlags`参数可用于控制新进程的初始状态，例如设置为`CREATE_NEW_CONSOLE`可以让子进程拥有独立的命令行窗口。

### 创建线程 - 33

为了确保传递给线程函数的数据在其生命周期内保持有效，可以考虑将参数存储在全局变量区。

### 线程控制 - 34

**10.1 让线程停下来**

- **Sleep函数**：暂停当前线程执行一段时间。
- **SuspendThread/ResumeThread函数**：分别用来暂停或恢复指定线程的执行。注意，若线程被多次挂起，则需要相应次数的恢复操作才能使其恢复正常运行。

**10.2 等待线程结束**

- **WaitForSingleObject/WaitForMultipleObjects函数**：等待一个或多个内核对象变为信号状态。前者适用于单个对象，后者支持多对象同时监控。
- **GetExitCodeThread函数**：查询已退出线程的返回值。

**10.3 设置、获取线程上下文**

- 介绍如何使用相关API调整线程环境信息及其状态读取方法。