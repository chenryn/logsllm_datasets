滴水逆向课程笔记  –  Win32
句柄表  –  17
7.1.2 管理内核对象
当我们使用如下图所示的函数创建时，会在内核层创建一个结构体，而我们该如何管理这些结构体呢？或者说
如何使用这些结构体呢？其实很好解决，我们可以通过内核结构体地址来管理，但是这样做存在问题：应用层
很有可能操作不当导致修改啦内核结构体的地址，我们写应用层代码都知道访问到一个不存在的内存地址就会
报错，而如果访问到一个内核地址是错误的，微软系统下则直接会蓝屏。
微软为了避免这种情况的发生，所以其不会讲内核结构体的地址暴露给应用层，也就是说没法通过这种方式来
直接管理。
滴水逆向课程笔记  –  Win32
句柄表  –  18
7.2 进程句柄表
没法直接管理内核对象，这时候句柄表就诞生了，但是需要注意的是，只有进程才会有句柄表，并且每一个进
程都会有一个句柄表。
句柄本质上就一个防火墙，将应用层、内核层隔离开来，通过句柄就可以控制进程内核结构体，我们得到所谓
句柄的值实际上就是句柄表里的一个索引。
7.3 多进程共享一个内核对象
如下图所示，A进程通过CreateProcess函数创建了一个内核对象；B进程通过OpenProcess函数可以打开别人
创建好的一个进程，也就是可以操作其的内核对象；A进程想要操作内核对象就通过其对应的句柄表的句柄
（索引）来操作；B进程操作这个内核对象也是通过它自己的句柄表的句柄（索引）来操作内核对象。（需要
注意的是：句柄表是一个私有的，句柄值就是进程自己句柄表的索引）
在之前的例子中我们提到了CloseHandle这个函数是用来关闭进程、线程的，其实它的本质就是释放句柄，但
是并不代表执行了这个函数，创建的内核对象就会彻底消失；如上图中所示内核对象存在一个计数器，目前是
2，它的值是根据调用A的次数来决定的，如果我们只是在A进程中执行了CloseHandle函数，内核对象并不会消
失，因为进程B还在使用，而只有进程B也执行了CloseHandle函数，这个内核对象的计数器为0，就会关闭消
失了。
最后：注意，以上所述特性适合于除了线程以外的所有内核对象，创建进程，同时也会创建线程，如果你想把
线程关闭，首先需要CloseHandle函数要让其计数器为0，其次需要有人将其关闭，所以假设我们创建了一个IE
滴水逆向课程笔记  –  Win32
句柄表  –  19
进程打开了一个网站，如果我们只是在代码中使用了CloseHandle函数，这样IE浏览器并不会关闭，需要我们
手动点击窗口的关闭按钮才行（只有线程关闭了，进程才会关闭）。
7.4 句柄是否"可以"被继承
除了我们上述的方式可以进行共享内核对象以外，Windows还设计了一种方式来提供我们共享内核对象，我们
先来了解一下句柄是否"可以"被继承。
如下图所示（句柄表是有三列的，分别是句柄值、内核结构体地址、句柄是否可以被继承），比如说我们在A
进程（父进程）创建了4个内核对象：
这四个函数都有一个参数LPSECURITY_ATTRIBUTES lpThreadAttributes，通过这个参数我们可以判断函数是否
创建的是内核对象。
我们可以跟进看一下这个参数，它就是一个结构体：
结构体成员分别是：1.结构体长度；2.安全描述符；3.句柄是否被继承。
第一个成员我们见怪不怪了，在Windows设计下都会有这样一个成员；第二个安全描述符，这个对我们来说实
际上没有任何意义，一般留空就行，默认它会遵循父进程的来，其主要作用就是描述谁创建了该对象，谁有访
问、使用该对象的权限。
第三个成员是我们重点需要关注的，因为其决定了句柄是否可以被继承，如下图所示，我们让CreateProcess函
数创建的进程、线程句柄可以被继承：
滴水逆向课程笔记  –  Win32
句柄表  –  20
7.5 句柄是否"允许"被继承
我们可以让句柄被继承，但也仅仅是可以，要真正完成继承，或者说我们允许子进程继承父进程的句柄，这时
候就需要另外一个参数了。
我们还是以CreateProcess函数举例，其有一个参数BOOL bInheritHandles，这个参数决定了是否允许创建的子
进程继承句柄：
只有这个参数设置为TRUE时，我们创建的子进程才允许继承父进程的句柄。
滴水逆向课程笔记  –  Win32
进程相关API  –  21
8 进程相关API
8.1 ID与句柄
如果我们成功创建了一个进程，CreateProcess函数会给我们返回一个结构体，包含四个数据：进程编号
（ID）、进程句柄、线程编号（ID）、线程句柄。
进程ID其实我们早就见过了，通常我们称之为PID，在任务管理器的进程栏下就可以很清楚的看见：
每个进程都有一份私有的句柄表，而操作系统也有一份句柄表，我们称之为全局句柄表，这张表里包含了所有
正在运行的进程、线程：
PID我们就可以理解为是全局句柄表中的一个索引，那么PID和句柄的区别就很容易看出来来了，PID是全局
的，在任何进程中都有意义，都可以使用，而句柄则是局部的、私有的；PID是唯一的，绝对不可能出现重复
的存在，但是当进程消失，那么这个PID就有可能会分给另外一个进程。（PID不是句柄，但是可以通过PID获
得到全局句柄表中其对应的句柄）
8.2 TerminateProcess函数
我们可以来论证一下如上所述的概念，首先A进程打开IE浏览器，然后获取进程ID和句柄：
滴水逆向课程笔记  –  Win32
进程相关API  –  22
其次B进程使用TerminateProcess函数来终止A进程，首先使用句柄信息终止：
// TerminateProcess函数
1
BOOL TerminateProcess(
2
  HANDLE hProcess, // handle to the process 句柄
3
  UINT uExitCode   // exit code for the process 退出代码
4
);
5
滴水逆向课程笔记  –  Win32
进程相关API  –  23
TerminateProcess函数是用来终止进程的，具体的可以参考MSDN Library，在这里我们很清楚的可以看见终止
进程失败了，这个错误编号的意思就是句柄无效，那么就论证了句柄是私有的，其他进程无法根据这个句柄来
终止进程，但是我们想要真正的关闭这个进程，那就需要借助PID来获取句柄了，具体细节如下。
8.3 OpenProcess函数
了解了TerminateProcess函数后，我们想要真正的去关闭一个进程，需要借助OpenProcess函数，这个函数是用
来打开进程对象的：
HANDLE OpenProcess(
1
  DWORD dwDesiredAccess,  // access flag 你希望的访问权限
2
  BOOL bInheritHandle,    // handle inheritance option 是否可以被继承
3
  DWORD dwProcessId       // process identifier 进程ID
4
);
5
滴水逆向课程笔记  –  Win32
进程相关API  –  24
如下代码所示，我通过PID打开进程（OpenProcess函数），拥有所有权，不继承句柄表，当OpenProcess函数
执行完成之后，我就获得一个句柄，通过这个句柄我就可以终止进程：
8.4 以挂起的形式创建进程
CreateProcess函数的所有参数都需要了解一下，现在我们来看一下第六个参数DWORD dwCreationFlags：
HANDLE hProcess;
1
hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, 0x524);
2
3
if(!TerminateProcess(hProcess, 0)) {
4
    printf("终止进程失败：%d \n", GetLastError());
5
}
6
滴水逆向课程笔记  –  Win32
进程相关API  –  25
当我们创建一个控制台进程时，会发现子进程和父进程都在同一个命令行控制台中：
而如果我们想要区分的话就需要借助dwCreationFlags这个参数，将其修改为CREATE_NEW_CONSOLE即可：
BOOL CreateProcess(
1
  LPCTSTR lpApplicationName,                 // name of executable module
2
  LPTSTR lpCommandLine,                      // command line string
3
  LPSECURITY_ATTRIBUTES lpProcessAttributes, // SD
4
  LPSECURITY_ATTRIBUTES lpThreadAttributes,  // SD
5
  BOOL bInheritHandles,                      // handle inheritance option
6
  DWORD dwCreationFlags,                     // creation flags 
1
2
// 线程执行的函数有语法要求，参考MSDN Library
3
DWORD WINAPI ThreadProc(LPVOID lpParameter) {
4
    // 要执行的代码
5
    for(int i = 0; i < 100; i++) {
6
        Sleep(500);
7
        printf("++++++ %d \n", i);
8
    }
9
10
    return 0;
11
}
12
13
int main(int argc, char* argv[])
14
{
15
    // 创建线程
16
    CreateThread(NULL, NULL, ThreadProc, NULL, 0, NULL);
17
18
    // 要执行的代码
19
    for(int i = 0; i < 100; i++) {
20
        Sleep(500);
21
        printf("------ %d \n", i);
22
    }
23
    return 0;
24
25
}
26
滴水逆向课程笔记  –  Win32
创建线程  –  33
为了保证参数的生命周期，我们也可以将参数放在全局变量区：
滴水逆向课程笔记  –  Win32
线程控制  –  34
10 线程控制
10.1 让线程停下来
10.1.1 Sleep函数
Sleep函数是让当前执行到本函数时延迟指定的毫秒之后再向下走，例如：
10.1.2 SuspendThread函数
SuspendThread函数用于暂停（挂起）某个线程，当暂停后该线程不会占用CPU，其语法格式很简单，只需要
传入一个线程句柄即可：
10.1.3 ResumeThread函数
ResumeThread函数用于恢复被暂停（挂起）的线程，其语法格式也很简单，只需要传入一个线程句柄即可：
需要注意的是，挂起几次就要恢复几次。
for(int i = 0; i < 100; i++) {
1
    Sleep(500);
2
    printf("------ %d \n", i);
3
}
4
DWORD SuspendThread(
1
  HANDLE hThread   // handle to thread
2
);
3
DWORD ResumeThread(
1
  HANDLE hThread   // handle to thread
2
);
3
SuspendThread(hThread);
1
SuspendThread(hThread);
2
3
ResumeThread(hThread);
4
ResumeThread(hThread);
5
滴水逆向课程笔记  –  Win32
线程控制  –  35
10.2 等待线程结束
10.2.1 WaitForSingleObject函数
WaitForSingleObject函数用于等待一个内核对象状态发生变更，那也就是执行结束之后，才会继续向下执行，
其语法格式如下：
如果你想一直等待的话，可以将第二参数的值设置为INFINITE。
10.2.2 WaitForMultipleObjects函数
WaitForMultipleObjects函数与WaitForSingleObject函数作用是一样的，只不过它可以等待多个内核对象的状态
发生变更，其语法格式如下：
DWORD WaitForSingleObject(
1
  HANDLE hHandle,        // handle to object 句柄
2
  DWORD dwMilliseconds   // time-out interval 等待超时时间（毫秒）
3
);
4
HANDLE hThread;
1
hThread = CreateThread(NULL, NULL, ThreadProc, NULL, 0, NULL);
2
WaitForSingleObject(hThread, INFINITE);
3
printf("OK...");
4
DWORD WaitForMultipleObjects(
1
  DWORD nCount,             // number of handles in array 内核对象的数量
2
  CONST HANDLE *lpHandles,  // object-handle array 内核对象的句柄数组
3
  BOOL bWaitAll,            // wait option 等待模式
4
  DWORD dwMilliseconds      // time-out interval 等待超时时间（毫秒）
5
);
6
滴水逆向课程笔记  –  Win32
线程控制  –  36
等待模式的值是布尔类型，一个是TRUE，一个是FALSE，TRUE就是等待所有对象的所有状态发生变更，FALSE
则是等待任意一个对象的状态发生变更。
10.2.3 GetExitCodeThread函数
线程函数会有一个返回值（DWORD），这个返回值可以根据你的需求进行返回，而我们需要如何获取这个返
回结果呢？这时候就可以使用GetExitCodeThread函数，其语法格式如下：
根据MSDN Library我们可以知道该函数的参数分别是线程句柄，而另一个则是out类型参数，这种类型则可以理
解为GetExitCodeThread函数的返回结果。
HANDLE hThread[2];
1
hThread[0] = CreateThread(NULL, NULL, ThreadProc, NULL, 0, NULL);
2
hThread[1] = CreateThread(NULL, NULL, ThreadProc, NULL, 0, NULL);
3
WaitForMultipleObjects(2, hThread, TRUE, INFINITE);
4
BOOL GetExitCodeThread(
1
  HANDLE hThread,      // handle to the thread
2
  LPDWORD lpExitCode   // termination status
3
);
4
HANDLE hThread;
1
hThread = CreateThread(NULL, NULL, ThreadProc, NULL, 0, NULL);
2
3
WaitForSingleObject(hThread, INFINITE);
4
5
DWORD exitCode;
6
GetExitCodeThread(hThread, &exitCode);
7
8
printf("Exit Code: %d \n", exitCode);
9
滴水逆向课程笔记  –  Win32
线程控制  –  37
需要注意的是这个函数应该搭配着如上所学的2个等待函数一起使用，不然获取到的值就不会是线程函数返回
的值。
10.3 设置、获取线程上下文