HTML form (i.e., in the request body) is not considered at all. Due
to SOP for cookies, the CSRF cookie will always be sent by the
victim’s browser, thus the verification will always succeed, even if
the attacker does not supply any CSRF token in the HTTP request.
CakePHP. The vulnerability [94] in CakePHP exploits the HTTP
Method Override feature [59, 62] and a missing check in the routing
middleware of the framework. The problem arises from the fact
that the framework performs the CSRF token validation only if
the request method is an unsafe HTTP method [73]. Thus, if an
attacker abuses HTTP Method Override to change the request
method to anything that is not an unsafe HTTP method (even an
arbitrary string), the CSRF verification function is not invoked, and
hence, even without a CSRF token, the request reaches the targeted
endpoint, bypassing the CSRF verification.
Play. A critical vulnerability arises when the developer enables
the CORS module. The default configuration of this module sets
the ACAO HTTP header to reflect back the request’s origin via
dynamic generation [103]. Additionally, the configuration sets the
ACAC header to true [40, 68]. This combination allows an attacker
to send an authenticated GET request on behalf of the victim,
read the CSRF token from the HTTP response across origins, and
mount a CSRF attack. We also noticed a dangerous feature in Play,
bypassCorsTrustedOrigins, which is by default set to true. This
feature allows the CSRF check to be bypassed if the request’s origin
is trusted by the CORS module [68, 70].
7 DOCUMENTATION AND API ANALYSIS
In this section, we address RQ3 (Section 2.2) by presenting the
results of our documentation analysis.
379Where We Stand (or Fall): An Analysis of CSRF Defenses in Web Frameworks
RAID ’21, October 6–8, 2021, San Sebastian, Spain
7.1 Quality of the Documentation
As presented in Section 3.5, we quantify the quality of documenta-
tion using six distinct criteria, i.e., presence of CSRF defense name
or description, presence of API specifications, description of the
configuration space, presence of code examples, description of the
cryptographic guarantees, and presence of a general security con-
siderations section.
Ideally, frameworks’ documentation should fulfill all six criteria,
but only two frameworks achieve that. The next best documenta-
tion that meets at least five of the six criteria is observed in nine
frameworks (20.5%). On the other end of the spectrum, we have six
frameworks that do not mention anything about CSRF and CSRF
defenses. Additionally, seven frameworks fulfill only one out of the
six quality criteria, i.e., a total of 13 frameworks (29.6%) provide
minimal or no CSRF documentation at all.
For the remaining 22 frameworks, the documentation contains
between two to four of the quality criteria (seven, seven, and eight
frameworks, respectively). We also noticed that out of all the frame-
works that provide CSRF documentation, 12 frameworks do not
explain the implemented defense. These frameworks provide only
minimal information which is mostly focused on how to include the
CSRF token in an HTML form or activate the defense. In compari-
son, the rest of the frameworks explain the defense and available
options. Overall, our results suggest that 61.7% of the frameworks
do not meet at least half of the quality criteria. Such a result is
alarming, and it indicates that even if the frameworks support
CSRF defenses, misconceptions and usability issues may arise as de-
velopers try to use these defenses. The complete mapping between
web frameworks and documentation content is shown in Table 7
in Appendix A.
7.2 API Abstraction Analysis
Although our evaluation identified different CSRF defenses, the
vast majority of frameworks (i.e., 84%) implement a defense from
Request Unguessability category. The APIs analysis reveals a vari-
ety in the semantics and operations, diverging in the integration,
configuration, generation, and validation of CSRF tokens. Overall,
there is no established consensus in the way unguessable request
defenses are exposed to developers.
Defense Configuration. In total, 11 frameworks have the CSRF
defense enabled by default. The developers need to install an exter-
nal library or enable the defense in a configuration file for the rest
of the frameworks. We observed that 20 frameworks allow the de-
velopers to configure the CSRF defense. However, the configuration
mainly relates to the type of defense to implement (Plain Token or
Double Submit) and the cryptographic key. Other features such as
the token length, token generation method, signing/encryption of
the tokens, and HTTP methods to validate are neither explained nor
configurable. As such, developers may be forced to customize the
CSRF defense code via “monkey patching” to increase the security
guarantees of the defense.
Token Generation. Our review of the APIs show that web frame-
works provide three distinct ways to add tokens to requests. The
first option is by calling the token generation function and arbitrar-
ily placing the token in the request. The second option uses helpers
or pseudo-variables that are interpreted by a template engine when
generating the HTML code for the browser. The third option is
using framework-provided special form objects.
Looking at frameworks, first, a total of three frameworks allow
calling the token generation function directly. Then, 34 frameworks
rely on template engines to render CSRF tokens in a form. Among
these frameworks, the semantics and operations to use tokens in
templates are not uniform. For example, some frameworks require
using special keywords to generate the input field that stores the
token (e.g., @csrf in Laravel). Other frameworks require the de-
veloper to create the HTML form and input fields manually and
only replace the value attribute with a specific pseudo-variable.
Unfortunately, these pseudo-variables are not always directly in-
terpretable by the template engine. In Vert.x-Web, for example, the
developer needs to pass the pseudo-variable to the template engine
for every HTTP response so that the template engine can recognize
it. Other frameworks, e.g., Django or Flask, offer template engines
that handle this process automatically.
Finally, a total of nine frameworks offer special form objects to
add the CSRF token, out of which six add the CSRF token automati-
cally in the HTML, while for the rest, the developer needs to add
the token manually.
Token Validation. Web frameworks provide three different tech-
niques to validate the CSRF token: (1) calling the CSRF verification
function; (2) using method decorators; (3) automatic. Regardless of
the technique, the state-changing request is verified before reaching
the targeted endpoint.
8 DEVELOPERS FEEDBACK
We notified the affected frameworks about the discovered security
risks (by sharing a proof-of-concept exploit), and our findings of
the status of the documentation. The summary of our notification
campaign is in Table 9.
Overview. Out of the total 157 notifications, 55 security risks were
confirmed by the frameworks’ developers who replied to our report.
Out of 55, 27 security risks are already patched in eight frameworks
(see, e.g, [93], or [94]), and the rest of the confirmed security risks
(i.e., 28) are still in the process of being patched. Then, 24 out of 157
vulnerability reports are still in the process of being reviewed by the
eight affected frameworks (e.g., Pyramid, Hapi, or Laravel). For 17
vulnerability reports that affect four frameworks (i.e., CodeIgniter,
FuelPHP, Blade, and ServiceStack) and two external libraries (i.e.,
koa-socket for Koa and swool for Zend), the developers have not
replied to our notifications yet. Similarly, for 18 security risks that
affect four frameworks (i.e., Bottle, Zope, Nancy, and ASP.NET
Web Forms), the developers said the code is no longer maintained
or replaced by a newer option. Finally, for 43 security risks of 19
different frameworks, the frameworks’ developers decided not to
take any further action because they either did not confirm the
vulnerability, or determined that the potential impact of the issue
is low.
Inconsistent Threat Model. When looking at the developers’
feedback over the reported 14 security risks, we observe incon-
sistent responses about the threat’s validity. For 12 out of the 14
reported, we have at least one developers team who did not consider
the reported threat a valid concern. Instead, they indicated web
frameworks’ users as the ones who should address them. On the
380RAID ’21, October 6–8, 2021, San Sebastian, Spain
Xhelal Likaj, Soheil Khodayari, and Giancarlo Pellegrino
contrary, for 10 out of the 14 reported vulnerabilities, at least one
team acknowledged the threat and patched their code. Interestingly,
for six out of the 14 reported vulnerabilities, we have one team that
addressed the threat and another team that did not.
9 DISCUSSION
The overarching goal of the study of this paper is to identify possi-
ble new explanations to a two-decades-old web vulnerability, by
looking at the code and documentation of existing CSRF defenses as
implemented by web frameworks. In this section, we distill our main
findings, showing that while implementations of CSRF defenses
exist, much of their correct and secure implementation depends on
developers’ awareness about CSRF attacks, threats to defenses, and
specific behaviors of the implementations.
Who is Responsible. Both our security analysis and developers’
feedback indicate that a large fraction of threats is adequately ad-
dressed by web frameworks, showing a rather consistent threat
model across the various web frameworks. However, at the same
time, our results show that for a significant fraction of threats,
frameworks’ developers have divergent expectations about who is
responsible for addressing them. For example, when we reported
the insufficient key randomness security risk to the affected frame-
works, CakePHP and Vert.x-Web patched the issue, but other frame-
works, such as Flask and Express, questioned their responsibility
for checking the developer-provided secret keys’ randomness. An-
other example is the CSRF token verification in Hapi and Masonite,
which is disabled by default for unsafe HTTP methods. On the
one hand, Masonite decided to patch the issue. On the other hand,
Hapi argued that they expect the developer to change the default
configuration. While both frameworks acknowledge that insecure
default configurations lead to a vulnerability, they do not agree on
the responsible party to address it.
Correct Use Require Awareness. All frameworks, except for Me-
teor, requires developers to at least write additional code to protect
against CSRF attacks. Meteor does not require that, and it offers a
by-default, cookie-less CSRF defense. Even worse, for more than
60% of the CSRF defenses, developers need to enable them explicitly.
Finally, not all frameworks offer built-in defenses, and for more than
a third of the cases, developers must look for an external library
by themselves. In most of these cases, frameworks’ documenta-
tion provides pointers to libraries implementing a CSRF defense,
whereas the remaining ones do not offer such help.
Secure Defenses Require Diverse Expertise. Even when devel-
opers can correctly enable and use CSRF defenses, they need to be
well informed about the plethora of threats that might weaken or
bypass the defense building blocks. Our evaluation identified 14
treats and, while token generation is, in general, the most robust
building block, the remaining building blocks are equally exposed
to a variety of risks. We mention replay attacks, cookie tossing and
jar overflow among the most concerning ones.
Incomplete and Inconsistent Documentation. Our qualitative
evaluation of the documentation shows that most of the frameworks
and libraries have incomplete and inconsistent documentation. Is-
sues range from trivial details such as the name of the implemented
defense (e.g., double submit token) or advanced ones such as no
code examples showing correct use. Even more concerning is the
lack of details about the threats considered in this study that can
affect the implemented defense’s building blocks. In general, we
find that the documentation accompanying web frameworks and
libraries does not adequately help developers in raising awareness
nor build-up cognition about the many threats that can weaken or
bypass CSRF defenses.
Same-Site Helpful but May not Completely Cut it. SameSite
cookies are relatively new mechanisms that could help protecting
from CSRF attacks. Our evaluation shows that only ten frameworks
and libraries offer SameSite protection. However, we point out
that SameSite cookies alone may not be sufficient to protect from
CSRF attacks. For example, they are not sufficient to protect against
a newer variant of CSRF attacks that leverage on the client-side
JavaScript code [89]. Similarly, when applications mis-use GET-
based HTTP requests for sensitive state-changing operations, the
new default SameSite cookie policy (i.e., Lax) cannot mitigate CSRF
attacks [39]. Additionally, as SameSite can change the behavior of
existing web services, developers may relax it on purpose to avoid
adapting their code. Finally, SameSite cookies are not fully sup-
ported by all programming languages [91]. For example, SameSite
cookies are not supported in PHP until PHP 7.3 [65, 67].
Language-specific Results. A closer look at our results show ap-
preciable language-based differences across CSRF implementations.
For example, C#-based frameworks come with a built-in CSRF de-
fense, whereas, for the other languages, a fraction between 20%
to 70% of the frameworks do not offer a built-in defense. We also
point out that web frameworks and libraries within a language tend
to implement the same defense. For example, JavaScript and Java
frameworks mostly implement Plain Token, while Python and C#
frameworks implement Double Submit. For JavaScript, the reason is
that most of the frameworks rely only on two external libraries (i.e.,
csurf and csrf libraries). We also noticed that, in contrast to the vast
majority of the web frameworks, most Java frameworks are subject
to timing-based side-channel attacks since they use the Java’s built-
in equals function for token comparison. The default behavior of
this function does not perform a constant-time comparison (unless
overridden). These examples show that the implementation of CSRF
defenses may differ among frameworks of different languages.
10 CONCLUSION
In this work, we identified and analyzed all existing CSRF defenses
for potential security threats. We performed the first systematic
study of the implementation and security guarantees of CSRF de-
fenses in 44 top web frameworks of five popular programming lan-
guages. Our results are alarming. We identified 157 security risks
affecting 37 frameworks that can be exploited to perform a CSRF
attack. We discovered three critical vulnerabilities in CakePHP,
Vert.x-Web, and Play that allow the attacker to bypass the CSRF de-
fense. Also, a closer look at the developers’ feedback reveals that, for
a considerable fraction of security risks, frameworks have divergent
expectations about who is responsible for addressing them. Also,
we systematically reviewed the CSRF-related documentation and
API surface of CSRF defenses which showed that at least 61.4% of
the frameworks do not provide sufficient documentation regarding
the CSRF defense. Overall, our research shows that although web
frameworks provide developers with the tools to defend against
381Where We Stand (or Fall): An Analysis of CSRF Defenses in Web Frameworks
RAID ’21, October 6–8, 2021, San Sebastian, Spain
CSRF, their correct and secure implementation too often depends
on developers’ awareness and diverse expertise about CSRF attacks,
who need to overcome missing and misleading documentation as
well as insecure defaults.
REFERENCES
[1] [n.d.]. CakePHP Documentation: Routing.
[2] [n.d.]. Common CSRF prevention misconceptions. https://www.nccgroup.com/
development/routing.html#routes-configuration.
https://book.cakephp.org/3/en/
uk/about-us/newsroom-and-events/blogs/2017/september/common-csrf-
prevention-misconceptions/.
2015-9243.
2015-6728.
2015-8125.
2015-8623.
2015-4056.
2015-2206.
2014-9720.
2014-1808.
2013-2213.
2012-1598.
2010-5084.
2016-10549.
2016-10535.
[3] [n.d.]. Common Weakness Enumeration: A Community-Developed List of Software
& Hardware Weakness Types. https://cwe.mitre.org/data/definitions/352.html.
[4] [n.d.]. Cryptographic Storage Cheat Sheet. https://cheatsheetseries.owasp.org/
cheatsheets/Cryptographic_Storage_Cheat_Sheet.html.
[5] [n.d.]. CVE-2010-5084. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-
[6] [n.d.]. CVE-2012-1598. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-
[7] [n.d.]. CVE-2013-2213. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-
[8] [n.d.]. CVE-2014-1808. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-
[9] [n.d.]. CVE-2014-9720. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-
[10] [n.d.]. CVE-2015-2206. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-
[11] [n.d.]. CVE-2015-4056. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-
[12] [n.d.]. CVE-2015-6728. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-
[13] [n.d.]. CVE-2015-8125. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-
[14] [n.d.]. CVE-2015-8623. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-
[15] [n.d.]. CVE-2015-9243. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-
[16] [n.d.]. CVE-2016-10535. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-
[17] [n.d.]. CVE-2016-10549. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-
[18] [n.d.]. CVE-2016-5739. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-
[19] [n.d.]. CVE-2016-6582. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-
[20] [n.d.]. CVE-2016-6806. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-
[21] [n.d.]. CVE-2016-8615. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-
[22] [n.d.]. CVE-2017-0894. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-
[23] [n.d.]. CVE-2017-16136. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-
[24] [n.d.]. CVE-2017-9339. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-
[25] [n.d.]. CVE-2018-1000119. https://cve.mitre.org/cgi-bin/cvename.cgi?name=
[26] [n.d.]. CVE-2018-10899. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-
[27] [n.d.]. CVE-2018-6651. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-
[28] [n.d.]. CVE-2019-12659. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-
[29] [n.d.]. CVE-2019-13209. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-
[30] [n.d.]. CVE-2019-14998. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-
[31] [n.d.]. CVE-2019-15515. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-
[32] [n.d.]. CVE-2019-17654. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-
[33] [n.d.]. CVE-2020-11825. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-
[34] [n.d.]. CVE-2020-14368. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-
CVE-2018-1000119.
2017-16136.
2019-14998.
2019-15515.
2019-17654.
2020-11825.
2018-10899.
2019-12659.
2019-13209.
2016-6582.
2016-6806.
2016-8615.
2017-0894.
2016-5739.
2017-9339.
2018-6651.
2020-14368.
2020-5261.
2020-25095.
[35] [n.d.]. CVE-2020-25095. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-
[36] [n.d.]. CVE-2020-5261. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-
[37] [n.d.]. CVE-2021-23127. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-
[38] [n.d.]. CVE-2021-26296. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-
[39] [n.d.]. Defending against CSRF with SameSite cookies. https://portswigger.net/
[40] [n.d.].
https://www.
Documentation: Cross-Origin Resource Sharing.
web-security/csrf/samesite-cookies.
2021-23127.
2021-26296.
playframework.com/documentation/2.8.x/CorsFilter.
github.com/.
[41] [n.d.]. Fetch API. https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API.
[42] [n.d.]. GitHub’s Annual Report: The State of the Octoverse. https://octoverse.
[43] [n.d.]. Hackerone. https://hackerone.com.
[44] [n.d.]. HackerOne, Report 342693: CSRF and password reset token leakage via
referer. https://hackerone.com/reports/342693.
[45] [n.d.]. HackerOne, Report 426147: CORS misconfiguration lead to CSRF and account
takeover. https://hackerone.com/reports/426147.
[46] [n.d.]. HackerOne, Report 576504: Authentication bypass by abusing insecure
crypto tokens in Revive Adserver. https://hackerone.com/reports/576504.
[47] [n.d.]. HackerOne, Report 577969: CORS misconfiguration allows to steal customers
data and CSRF tokens. https://hackerone.com/reports/577969.
[48] [n.d.]. HackerOne, Report 787160: Referer leakage vulnerability in rockstargames
leads to Facebook’s OAuth token theft. https://hackerone.com/reports/787160.
[49] [n.d.]. HackerOne, Report 975983: Site-wide CSRF on Safari due to CORS miscon-
figuration. https://hackerone.com/reports/975983.
[50] [n.d.]. How do I get the parameters of a post request when using a pac4j security
filter in Spark Java? https://stackoverflow.com/questions/43240829/how-do-i-
get-the-parameters-of-a-post-request-when-using-a-pac4j-security-filter.
2016/06/23/insecure-tokens-in-kayako/.
[51] [n.d.]. HTTP State Management. https://tools.ietf.org/html/rfc6265.
[52] [n.d.]. Hypertext Transfer Protocol (HTTP/1.1). https://tools.ietf.org/html/rfc7231.
[53] [n.d.]. Insecure token generation in Kayako. https://www.sjoerdlangkemper.nl/
[54] [n.d.]. Java Documenation: Class SecureRandom. https://docs.oracle.com/javase/
[55] [n.d.]. Meteor.js and CSRF/XSS Attacks. https://stackoverflow.com/questions/
[56] [n.d.]. Microsoft Documentation: RandomNumberGenerator.Fill(Span)
https://docs.microsoft.com/en-us/dotnet/api/system.security.
8/docs/api/java/security/SecureRandom.html.
21807229/meteor-js-and-csrf-xss-attacks.
Method.
cryptography.randomnumbergenerator.fill?view=net-5.0.
[57] [n.d.]. MITRE CVE database. https://cve.mitre.org/.
[58] [n.d.].
National Vulnerability Database: CSRF statistics.
//nvd.nist.gov/vuln/search/statistics?form_type=Advanced&results_type=
statistics&query=CSRF&search_type=all.
[59] [n.d.]. NODE.JS CONNECT CSRF BYPASS ABUSING METHODOVERRIDE MID-
http://blog.nibblesec.org/2014/05/nodejs-connect-csrf-bypass-
https:
DLEWARE.
abusing.html.
[63] [n.d.].
[60] [n.d.]. Node.js Documentation: crypto.randomBytes. https://nodejs.org/api/
crypto.html#crypto_crypto_randombytes_size_callback.
[61] [n.d.]. NPM package manger. https://www.npmjs.com/.
[62] [n.d.]. Often Misused: HTTP Method Override.
https://vulncat.fortify.com/
en/detail?id=desc.dynamic.xtended_preview.often_misused\_http_method_
override.
OWASP: Cross-Site Request Forgery Prevention Cheat Sheet.
https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_
Prevention_Cheat_Sheet.html.
site-cookies.
https://owasp.org/www-
community/vulnerabilities/Insufficient_Session-ID_Length.
[64] [n.d.]. OWASP: Insufficient Session-ID Length.
[65] [n.d.]. PHP 7.3: SameSite cookie support. https://php.watch/versions/7.3/same-
[66] [n.d.]. PHP Documentation: random_bytes. https://www.php.net/manual/en/
[67] [n.d.]. PHP setcookie SameSite=Strict. https://php.watch/versions/7.3/same-site-
[68] [n.d.].
https://www.playframework.com/
function.random-bytes.php.
Play filter configurations.
documentation/2.8.x/resources/confs/filters-helpers/reference.conf.
cookies.
Predictable
token in Froxlor
the
da4ec3e1b591de96675817a009e26e05e848a6ba.
rand() method.
timestamps and
https://github.com/Froxlor/Froxlor/commit/
that uses
com/documentation/2.8.x/JavaCsrf.
[70] [n.d.]. Protecting against Cross Site Request Forgery. https://www.playframework.
[71] [n.d.]. Python: os — Miscellaneous operating system interfaces. https://docs.
[72] [n.d.]. Question: Was it intentional to validate crumb key for POST only? https:
python.org/3/library/os.html#os.urandom.
[69] [n.d.].
//github.com/hapijs/crumb/issues/4.
382RAID ’21, October 6–8, 2021, San Sebastian, Spain
Xhelal Likaj, Soheil Khodayari, and Giancarlo Pellegrino
safe.
latest/csrf.html.
2020-35217.
2020-35239.
Web/API/Window/localStorage.
page-53.
csrf-revisited.html.
api-platform-security/samesite-csrf.
43317938/spark-framework-csrf-protection.
meteor-doesnt-use-session-cookies-e988544f52c9.
https://github.com/symfony/symfony/issues/17051.
11/07/twitter-rapidly-fixes-csrf-account-control-exploit/.
Cookie. https://github.com/tornadoweb/tornado/issues/2722.
[73] [n.d.]. Safe HTTP Methods. https://developer.mozilla.org/en-US/docs/Glossary/
[74] [n.d.]. SameSite Cookies & CSRF Attacks. https://symfonycasts.com/screencast/
[75] [n.d.]. Spark Framework CSRF Protection. https://stackoverflow.com/questions/
[76] [n.d.]. Spark Framework CSRF Protection. https://bottle-utils.readthedocs.io/en/
[77] [n.d.]. Stackoverflow Tags. https://stackoverflow.com/help/tagging.
[78] [n.d.]. Symfony: [RFC] Add support for Websockets and real-time applications.
[79] [n.d.]. Test your code. https://snyk.io/test/.
[80] [n.d.]. Tornado Github Issue 2722: Misleading CSRF Docs / Bug in Setting CSRF
[81] [n.d.]. The Web Origin Concept. https://www.ietf.org/rfc/rfc6454.txt.
[82] [n.d.]. Why Meteor doesn’t use session cookies. https://blog.meteor.com/why-
[83] [n.d.]. Window.localStorage APIs. https://developer.mozilla.org/en-US/docs/
[84] 1999. Hypertext Transfer Protocol – HTTP/1.1. https://tools.ietf.org/html/rfc2616#
[85] 2009. Netflix CSRF Revisited. https://appsecnotes.blogspot.com/2009/01/netflix-
[86] 2010. Patching auto-complete vulnerabilities not enough, Cookie Eviction to the
rescue. https://blog.jeremiahgrossman.com/2010/07/patching-auto-complete-
vulnerabilities.html.
[87] 2013. Twitter CSRF account control exploit. https://www.itproportal.com/2013/
[88] 2016. OWASP Top Ten. https://owasp.org/www-project-top-ten/.
[89] 2018. Client-Side CSRF. https://www.facebook.com/notes/facebook-bug-bounty/
[90] 2019. Critical CSRF Vulnerability on Facebook. https://www.acunetix.com/blog/
[91] 2019. Developers: Get Ready for New SameSite=None; Secure Cookie Settings.
[92] 2019. Intent to implement: Cookie SameSite=lax by default and SameSite=none
only if secure. https://groups.google.com/forum/#!msg/mozilla.dev.platform/
nx2uP0CzA9k/BNVPWDHsAQAJ.
[93] 2020. CVE-2020-35217. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-
[94] 2020. CVE-2020-35239. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-
[95] 2020. SameSite cookie attribute, Chromium, Blink. https://www.chromestatus.
[96] Y. Acar, M. Backes, S. Fahl, S. Garfinkel, D. Kim, M. L. Mazurek, and C. Stransky.
2017. Comparing the Usability of Cryptographic APIs. In IEEE Symposium on
Security and Privacy (SP).
[97] Wade Alcorn, Christian Frichot, and Michele Orru. 2014. The Browser Hacker’s
Handbook. John Wiley & Sons. 268–270 pages.
[98] Scott Arciszewski. [n.d.]. Preventing Timing Attacks on String Comparison with a
Double HMAC Strategy. https://paragonie.com/blog/2015/11/preventing-timing-
attacks-on-string-comparison-with-double-hmac-strategy.
[99] Adam Barth, Collin Jackson, and John C. Mitchell. 2008. Robust Defenses
for Cross-Site Request Forgery. In Proceedings of the 15th ACM Conference on
Computer and Communications Security (Alexandria, Virginia, USA) (CCS ’08).
Association for Computing Machinery, New York, NY, USA, 75–88. https:
//doi.org/10.1145/1455770.1455782
https://blog.chromium.org/2019/10/developers-get-ready-for-new.html.
web-security-zone/critical-csrf-vulnerability-facebook/.
client-side-csrf/2056804174333798/.
com/feature/4672634709082112.
[100] Jeremiah Blatz. [n.d.]. CSRF: Attack and Defense. ([n. d.]).
[101] Stefano Calzavara, Mauro Conti, Riccardo Focardi, Alvise Rabitti, and Gabriele
Tolomei. 2019. Mitch: A Machine Learning Approach to the Black-Box Detection
of CSRF Vulnerabilities. In Proceedings of the IEEE European Symposium on
Security and Privacy.
[102] Jianjun Chen, Jian Jiang, Haixin Duan, Tao Wan, Shuo Chen, Vern Paxson,
and Min Yang. 2018. We Still Don’t Have Secure Cross-Domain Requests: An
Empirical Study of CORS. In Proceedings of the 27th USENIX Conference on
Security Symposium.
[103] Jianjun Chen, Jian Jiang, Haixin Duan, Tao Wan, Shuo Chen, Vern Paxson,
and Min Yang. 2018. We Still Don’t Have Secure Cross-Domain Requests: an
Empirical Study of CORS. In 27th USENIX Security Symposium.
[104] Alexei Czeskis, Alexander Moshchuk, Tadayoshi Kohno, and Helen J. Wang.
2013. Lightweight server support for browser-based CSRF protection. In Pro-
ceedings of the International Conference on World Wide Web.
[105] Dorothy E Denning and Giovanni Maria Sacco. 1981. Timestamps in key distri-
bution protocols. Commun. ACM 24, 8 (1981), 533–536.
attack. Unpublished manuscript (2013).
[107] Peter Leo Gorski, Yasemin Acar, Luigi Lo Iacono, and Sascha Fahl. 2020. Lis-
ten to Developers! A Participatory Design Study on Security Warnings for
[106] Yoel Gluck, Neal Harris, and Angelo Prado. 2013. BREACH: reviving the CRIME
Cryptographic APIs. In Proceedings of the 2020 Conference on Human Factors in
Computing Systems (CHI).
[108] Michael Howard and David LeBlanc. 2003. Writing secure code. Pearson Educa-
tion. 350–361 pages.
[109] Lin-Shung Huang, Alex Moshchuk, Helen J. Wang, Stuart Schechter, and Collin
Jackson. 2012. Clickjacking: Attacks and Defenses. In Proceedings of the 21st
USENIX Conference on Security Symposium.
[110] David Johansson. 2017. A Double Defeat of the Double-Submit Cookie Pattern.
(2017).
[111] Martin Johns. 2007. The three faces of CSRF. Talk at the DeepSec2007 con-
ference. (2007). https://deepsec.net/archive/2007.deepsec.net/speakers/index.
html#martin-johns.
[112] Martin Johns and Justus Winter. 2006. RequestRodeo: Client side protection
against session riding. https://www.owasp.org/images/4/42/RequestRodeo-
MartinJohns.pdf.
[116] Rich Lundeen, Jesse Ou, and Travis Rhodes. 2011. New ways im going to hack
[113] Nenad Jovanovic, Engin Kirda, and Christopher Kruegel. 2006. Preventing Cross
Site Request Forgery Attacks. In Second International Conference on Security and
Privacy in Communication Networks and the Workshops (SecureComm).
[114] Florian Kerschbaum. 2007. Simple cross-site attack prevention. In 2007 Third
International Conference on Security and Privacy in Communications Networks
and the Workshops-SecureComm 2007. IEEE, 464–472.
[115] Sebastian Lekies, Walter Tighzert, and Martin Johns. 2012. Towards stateless,
client-side driven Cross-site request forgery protection for Web applications.
SAP Research (2012).
your web app. Blackhat AD (2011), 1–11.
[117] Sreekanth Malladi, Jim Alves-Foss, and Robert B Heckendorn. 2002. On pre-
venting replay attacks on security protocols. Technical Report. IDAHO UNIV
MOSCOW DEPT OF COMPUTER SCIENCE.
[118] Jian Mao, Yue Chen, Futian Shi, Yaoqi Jia, and Zhenkai Liang. 2016. Toward
Exposing Timing-Based Probing Attacks in Web Applications. In Proceedings of
the International Conference on Wireless Algorithms, Systems, and Applications.
[119] Ziqing Mao, Ninghui Li, and Ian Molloy. 2009. Defeating Cross-Site Request
Forgery Attacks with Browser-Enforced Authenticity Protection. In 13th Inter-
national Conference on Financial Cryptography and Data Security.
[120] Kai Mindermann and Stefan Wagner. 2018. Usability and Security Effects of
Code Examples on Crypto APIs. In 16th Annual Conference on Privacy, Security
and Trust (PST).
[121] Nikhil Patnaik, Joseph Hallett, and Awais Rashid. 2019. Usability Smells: An
Analysis of Developers’ Struggle With Crypto Libraries. In Fifteenth Symposium
on Usable Privacy and Security(SOUPS).
[122] Giancarlo Pellegrino, Martin Johns, Simon Koch, Michael Backes, and Christian
Rossow. 2017. Deemon: Detecting CSRF with dynamic analysis and property
graphs. In Proceedings of the 2017 ACM SIGSAC Conference on Computer and
Communications Security.
[123] Philippe De Ryck, Lieven Desmet, Thomas Heyman, Frank Piessens, and Wouter
Joosen. 2010. CsFire: Transparent Client-Side Mitigation of Malicious Cross-
Domain Requests. In International Symposium on Engineering Secure Software
and Systems (ESSoS).
[124] Philippe De Ryck, Lieven Desmet, Wouter Joosen, and Frank Piessens. 2011.
Automatic and Precise Client-Side Protection against CSRF Attacks. In European
Symposium on Research in Computer Security (ESORICS).
[125] Christian Schneider. [n.d.]. Cross-Site WebSocket Hijacking. https://christian-
schneider.net/CrossSiteWebSocketHijacking.html.
[126] Thomas Schreiber. 2004. Session Riding-A Widespread Vulnerability in Today’s
Web Applications.(2004).
[127] Hossain Shahriar and Mohammad Zulkernine. 2010. Client-Side Detection of
Cross-Site Request Forgery Attacks. In Proceedings of the IEEE 21st International
Symposium on Software Reliability Engineering.
[128] Robin Sharma. 2017. Preventing cross-site attacks using same-site cook-
ies. https://blogs.dropbox.com/tech/2017/03/preventing-cross-site-attacks-
using-same-site-cookies/.
[129] Avinash Sudhodanan, Roberto Carbone, Luca Compagna, and Nicolas Dolgin.
2017. Large-scale analysis & detection of authentication cross-site request
forgeries. In 2017 IEEE European Symposium on Security and Privacy.
[130] Tom Van Goethem, Wouter Joosen, and Nick Nikiforakis. 2015. The Clock is
Still Ticking: Timing Attacks in the Modern Web. In Proceedings of the ACM
SIGSAC Conference on Computer and Communications Security.
[131] Mike West. 2019. Incrementally Better Cookies. (2019). https://tools.ietf.org/
html/draft-west-cookie-incrementalism-00.
[132] Chamila Wijayarathna and Nalin A. G. Arachchilage. 2018. A methodology
to Evaluate the Usability of Security APIs. In IEEE International Conference on
Information and Automation for Sustainability (ICIAfS).
[133] John Wilander. 2012. Advanced CSRF and Stateless Anti-CSRF. (2012).
[134] William Zeller and Edward W. Felten. 2008. Cross-Site Request Forgeries:
Exploitation and Prevention. In Princeton University.
383Where We Stand (or Fall): An Analysis of CSRF Defenses in Web Frameworks
RAID ’21, October 6–8, 2021, San Sebastian, Spain
A ADDITIONAL EVALUATION DETAILS
Table 7: Mapping between web frameworks and quality of
the documentation.
n
o
i
t
p