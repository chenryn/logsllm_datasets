title:Interfacing Trusted Applications with Intrusion Detection Systems
author:Marc G. Welz and
Andrew Hutchison
Interfacing Trusted Applications with Intrusion
Detection Systems
Marc Welz and Andrew Hutchison
Data Network Architectures Laboratory
Department of Computer Science
University of Cape Town
Rondebosch, 7701 South Africa
{mwelz,hutch}@cs.uct.ac.za
Abstract. In this paper we describe an interface between intrusion de-
tection systems and trusted system components. The approach presented
diﬀers from conventional intrusion detection systems which are only
loosely coupled to the components which they protect. We argue that
a tighter coupling makes an IDS less vulnerable to desynchronization at-
tacks, furnishes it with higher quality information and makes immediate
and more ﬁne grained responses feasible. Preliminary results show that
this can be achieved through an external, nonspeciﬁc, voluntary refer-
ence monitor accessible to applications through a simple API. Reasonable
performance can be maintained by moving most of the IDS functionality
into the context of the trusted application.
1 Introduction
Conventional intrusion detection systems passively intercept traﬃc between the
entities they guard and potential attackers. Such a mechanism is vulnerable to
desynchronization attacks and only oﬀers a coarse, indirect response.
We propose a direct coupling between application and IDS. The IDS assumes
the role of an external, voluntary reference monitor which the application pro-
grammer can consult for a second opinion whenever an action is taken which
has an impact on security.
Making the IDS visible to an application programmer incurs an initial ex-
pense, but has the advantages of being diﬃcult to desynchronize or bypass, and
allows ﬁne grained preventative measures, as opposed to indirect responses.
Our system is primarily intended for services and applications which have
some security function and need to defend themselves against subversion —
trusted applications in our terminology.
The next section motivates the need for access control at the application level,
section 3 sets out the methods which can be used to monitor applications and
section 4 introduces instrumentation methods. Section 5 motivates the need for
a targeted response, section 6 sets out the direct IDS to application coupling and
section 7 our implementation of this interface, IDS/A. Applications, usage and
brief results are described in sections 8, 9 and 10. Limitations of our approach
are discussed in section 11 and we ﬁnish with a section on related work and a
conclusion.
W. Lee, L. M´e, and A. Wespi (Eds.): RAID 2001, LNCS 2212, pp. 37–53, 2001.
c(cid:1) Springer-Verlag Berlin Heidelberg 2001
38
M. Welz and A. Hutchison
2 Trusted Applications
For this paper we shall deﬁne a trusted application as a user space program which
is intended to interact with more than one protection domain, while a trusting
application is deﬁned as one which operates inside a single protection domain. We
use the term application in the widest sense, web servers and database managers
are included in our deﬁnition.
Whenever an application interacts with more than one protection domain, it
becomes interesting to attackers as a subverted application can then be used to
cross into a domain previously inaccessible. Conversely, an application restricted
to one protection domain is of limited interest to an attacker, as subverting it
yields no new rights.
database server
database
user account
shell
remote  users
Trusted Application
Trusting Application
Fig. 1. Trusted applications (such as a database) straddle domains and need to control
exchanges across domains, while trusting applications (such as an interactive command
interpreter) are contained within a single domain
Like an operating system, a trusted application has to enforce access policies
and resist subversion. However, while the operating system reference monitors
have been reasonably well studied, less attention has been devoted to the access
control decisions which are made at the application level.
Assuming that the need for trusted applications will disappear if only conven-
tional operating systems were to provide suﬃciently ﬁne grained access controls
is ill-advised: Consider the example of a trusted medical database application
which allows a user to compute the percentage of individuals suﬀering from a
given disease, but not to retrieve the disease status of an individual. Diﬀerenti-
ating reliably between these two queries can not be done by the host operating
system unless it duplicates the database logic.
It is probable that trusted applications will become more signiﬁcant in the
future, as systems tend to become ever more connected and nested, resulting
in component-based applications and distributed applets which are expected
to interact seamlessly across protection domains. In many cases applications
provide their own execution environments (e.g. java virtual machines, database
Interfacing Trusted Applications with Intrusion Detection Systems
39
stored procedures, macro interpreters for word processors) making it possible to
nest applications one inside the other (e.g. a java-based tax calculator running
inside web browser). In such situations the underlying operating system access
controls have little relevance.
3 Application Monitoring
Given that applications will remain vulnerable to subversion, it is prudent to
monitor applications for signs of failure. This is the ﬁeld of intrusion detection,
with a focus on individual applications as opposed to the more common network
intrusion detection.
An application can be monitored by one of three methods:
Interception : Interception involves decoding the exchanges between the mon-
itored application and other parties by the IDS itself. Interception is trans-
parent to both the application and its peers. Most network-based intrusion
detection systems make use of this method.
Instrumentation of a third party : This approach uses audit or log mes-
sages from a party other than the monitored application. It diﬀers from
interception in that the third party, not the IDS, is responsible for decoding
messages emitted by the application, and that the third party is visible to
the application. An example of such a system would be the application layer
proxies of TIS’s ﬁrewall toolkit [19] or the audit trail of an operating system
which records the system calls made by an application.
Instrumented application : This method uses messages emitted directly by
the application to be monitored. Common interfaces for an application to
report events are the Unix system logger (syslog) or the Windows NT event
logger. Other, more complex, interfaces include the X Open Distributed Au-
diting Standard (XDAS) [23] and Event Management Service (XEMS) [24].
3rd Party
Application
3rd Party
Application
3rd Party
Application
IDS
IDS
IDS
Interception
3rd Party Instrumentation
Application Instrumentation
Fig. 2. IDS Data Acquisition Methods
Intrusion detection systems which monitor applications by interception are
by far the most common and have the advantage that they are easily deployed —
existing systems need not be modiﬁed or reconﬁgured, and since their monitoring
is passive, these IDSs are unobtrusive.
40
M. Welz and A. Hutchison
Unfortunately intercepting IDSs also have a number of disadvantages:
– Interactions between components may be stateful, and this state may be
maintained for extended periods of time. For example, hosts communicating
via TCP/IP have to allocate resources for each connection, while the UNIX
system call interface uses ﬁle descriptors to encode state. An IDS needs
to allocate duplicate resources to shadow this state — it has to remain
synchronized with the components being monitored.
– The interface between components may be underspeciﬁed, or implementa-
tions may not honour the speciﬁcations. This means that the decoding com-
ponent of the IDS may have to be signiﬁcantly more complex than the inter-
face of any individual application to cover all implementations and revisions.
– An intercepting IDS operates under severe time constraints, having to keep
up with the monitored application at all costs. Essentially the worst case
performance of the IDS has to exceed the best case performance of the mon-
itored applications for a given set of circumstances. This is a signiﬁcant
limitation: It requires that the IDS operate within hard time limits, even
though the monitored application need not. For example, an overloaded ap-
plication may be free to drop a message and wait for a retransmission, an
overloaded intercepting IDS is unable to do so.
– Communications channels between applications are ever more likely to be
secured cryptographically. These measures are explicitly designed to prevent
third parties from intercepting traﬃc — which is exactly how most intrusion
detection systems operate. Currently encryption is only widely used in net-
worked communications, but it appears likely that systems such as digital
content managers, smart card resident applications or agents participating
in electronic commerce will extend cryptographic protection to other sub-
systems.
The limitations of an intercepting IDS can be expressed slightly more for-
mally: An application can be viewed (simplistically) as a function f taking as
parameters the current application state st and some input i, and returning some
output o and the next state st+1:
(1)
Borrowing concepts from [11], we can partition the set of states S into two
nonoverlapping subsets, those states in which the application is in a safe state
s ∈ SS, and those states which denote a compromise s ∈ SC:
f(it, st) = (ot, st+1)
(2)
An intercepting intrusion detection system can be deﬁned as a function d
which will reconstruct the state of an application from the traﬃc available to it:
SS ∩ SC = ∅
(3)
Here e describes the application, p and q the observed application input and
output, while m denotes the state of the IDS and n the shadowed or mirrored
d(e, pt, qt, mt) = (mt+1, nt)
Interfacing Trusted Applications with Intrusion Detection Systems
41
state of the application. For an IDS to be eﬀective, it needs to remain synchro-
nized with the application it is protecting, n = s, as this enables it to decide if
the application has entered a compromised state.
Note that s, the state of the application itself is unavailable to the intercepting
IDS and has to be inferred.
For an arbitrary application f an intercepting IDS may become unreliable if:
– The observed inputs and outputs are unreliable or incomplete: p (cid:4)= i and
– The application state exceeds that of the IDS: |N| < |S|, allowing for state
q (cid:4)= o.
holding attacks against the IDS.
– The application description available to the IDS is underspeciﬁed or inac-
curate: ∃it ∨ ∃ot : d(e, it, ot, mt) = (mt+1, nt), f(it, st) = (ot, st+1) such that
∃u ≥ t : d(e, iu, ou, mu) = (mu+1, nu), f(iu, su) = (ou, su+1), su (cid:4)= nu.
– The initial application state s0 is unknown to the IDS preventing it from
initialising its own state m0 by some setup function b(e, s0) = m0. Crypto-
graphically secured applications are an example of this case: s0 contains a
secret which is unavailable to the IDS.
The above conditions oﬀer enough possibilities to desynchronize most non-
trivial monitoring systems.
The risk of desynchronization attacks against intercepting NIDS are rea-
sonably well understood. They have been described in [17], and tools such as
fragrouter [22] and whisker [18] make these capabilities available to the attacker
population at large.
4 Instrumentation
Instrumenting applications or other components for the purpose of monitoring
a system and detecting intruders has a higher initial cost, as it requires modi-
ﬁcations to existing components. However, as it is more tightly coupled to the
monitored entity, it is less likely to be desynchronized. Instrumentation as op-
posed to interception is the technique favoured by host-based intrusion detection
systems.
The most common form of instrumentation used by host-based intrusion
detection systems is the audit trail of the operating system which records the
sequence of system calls made by the application. It belongs to the instrumented
third party monitoring category, as the monitored entity is the application, but
the information is collected by the operating system (refer back to Fig. 2). US-
TAT [11] and ASAX [15] are examples of intrusion detection systems which
process the host audit trail.
The audit trail illustrates some of the features of instrumented third party
monitoring:
– The time constraints are less rigid than those imposed on an intercepting
IDS. For example, an operating system writes audit records regardless of
system load — generating more audit records will slow down the applica-
tion, not result in dropped messages — as a matter of fact the Solaris BSM
42
M. Welz and A. Hutchison
audit module will even suspend execution when it is unable to write new
records. Similarly an application level security proxy may drop packets un-
der load, relying on the application to retransmit them. This contrasts with
an intercepting system where even a single missed message may result in an
intrusion attempt going undetected.
– The state information maintained by the third party need not be duplicated
by the IDS. For example, a Unix operating system needs to maintain the
mapping from ﬁle descriptor to ﬁle and oﬀset within ﬁle — this mapping
need not be duplicated if made available to the IDS.1 In other words, state
information is at least partially available.
While instrumenting third parties has its merits, we believe that instrument-
ing applications directly has a number of additional beneﬁts:
– A direct instrumentation makes it possible to take advantage of the appli-
cation designer’s knowledge to perform the task of feature selection. Feature
selection is the identiﬁcation of relevant events or criteria, often performed
as a preprocessing step before submitting data to a machine learning sys-
tem (see [14] for some of the issues involving feature selection and intrusion
detection). Feature selection can reduce data volumes signiﬁcantly and con-
sequently improve system performance. Consider a system call trace — a
write() call at one stage may have minimal security implications (e.g. print
a debug message to a terminal), another write() might be critical (e.g.
update /etc/passwd). Having the application designer indicate which are
signiﬁcant simpliﬁes the task of the IDS.
– End to end cryptographic protection may extend into the application, mean-
ing that the read and write buﬀers visible to a third party in the form of a
system call trace only contain cyphertext.
– Optimized applications may precompute data or cache results, a third party