set properly. Those registers are not highly relevant
for executing our attack. Further, 1.6 (released in
2016) has been superseded by newer SDK versions.
8.2 SGX-Shield
Our attack against SGX-Shield exploits the lack of
randomization of the tRTS. We argue that simply random-
izing the SDK is not a trivial task for several reasons: ﬁrst,
ﬁne-grained randomization of the tRTS likely requires
manual intervention. Parts of the tRTS code are hand-
written assembly, which likely requires manual splitting
of the randomization units. The SDK should be made part
of the guest enclave, and randomized together with the
other guest’s code. The loader would have its own copy
of the SDK, as it is still a proper SGX enclave. The tRTS
in the SDK provides the entry point code, from which the
enclave starts executing when entered through EENTER.
Initially,
the entry point would be from the loader’s
tRTS. After the guest is loaded, the entry point has to be
switched over to the guest’s tRTS. The entry point address
is speciﬁed in the TCS, which cannot be modiﬁed after
the enclave has been initialized. Thus, SGX-Shield would
have to patch its own entry point to act as a passthrough
for the guest’s entry point before wiping out the loader.
The guest’s SDK state would also need to be properly
initialized. The cost of those extensions would be a
slightly longer startup time, as they are just additions to
the loading phase. We expect the runtime overhead of the
extra entry point indirection to be completely negligible.
Our attack also exploits the backwards-edge CFI
issues in SGX-Shield to hijack the control ﬂow. The
arms race between CFI defenses and attacks is still
ongoing [9, 10, 11]. Hence, we believe that even in the
presence of backward-edge CFI, a skilled attacker could
still be able to launch our exploit, although the reusable
code base has been reduced.
On another note, we argue that the current Software
Fault Isolation scheme deployed in SGX-Shield can
be undermined by our attack. SGX-Shield enforces an
execute-only policy on code by instrumenting memory
accesses. To do so, it keeps the so-called NRW boundary
between execute-only code and read-write data. Every
memory access is instrumented, so that code, which
is above the NRW boundary, cannot be accessed. The
boundary is kept in a ﬁxed register (r15), initialized
before launching the guest enclave. Since our attack can
control this register, the NRW boundary can be shifted,
thus disabling SFI.
8.3 Countermeasures
We now propose two complimentary mitigations to
stop our attack. On the one hand, we suggest hardening
measures for the SDK. On the other hand, we discuss
considerations for designing hardening schemes.
The ﬁrst avenue to mitigate our attack is hardening
the SDK. A common strategy to make crafting fake
structures harder is to integrate a secret value into the
structures. The secret is then checked at runtime before
performing any operation on the structure. Since the
attacker does not know the secret, she cannot craft valid
structures. This approach, however, can be defeated if the
attacker exploits an information leakage vulnerability to
read the secret from a valid structure. Moreover, in our
attack scenario, the developer has to be careful that the
check cannot be skipped by jumping over it. This method
is therefore weak and error-prone.
A better method is mangling the data within the
structure. The contents are stored combined with the
secret in a reversible way, e.g., via XOR. The attacker
would have to know the secret to craft data that, when the
mangling is reversed, produces a valid structure. Leaking
is also more difﬁcult. For example, when using XOR,
the attacker not only has to leak the mangled data, but
also know the unmangled data to recover the secret. This
method is much stronger than just embedding a secret,
and its overhead would be negligible in our case, as the
structures we target are not accessed very often.
The second mitigation avenue is taking the SDK code
base into serious consideration when designing hard-
ening schemes. Speciﬁcally, we focus on the problems
USENIX Association
27th USENIX Security Symposium    1225
we raised with SGX-Shield. The ﬁrst step would be
providing ﬁne-grained randomization for the SDK and
solving the backwards-edge CFI issue (cf. Section 7.2).
Moreover, the NRW boundary has to be stored at a less
accessible location. We propose the thread-local storage.
This memory area is accessed via a segment selector,
which cannot be altered with our attack. However,
the performance implications of this choice have to be
evaluated, as it would cause an extra memory access for
each instrumented access.
9 Conclusion and Summary
Intel Software Guard Extensions (SGX) is a promising
processor technology providing hardware-based support
to strongly isolate security-critical code inside a trusted
execution environment called enclave. Previous research
has investigated side-channel attacks against SGX or
proposed sophisticated SGX-enabled security services.
However, to our surprise, memory corruption attacks
such as return-oriented programming (ROP) are not
yet well understood in the SGX threat model.
In fact,
recently presented ROP attacks against SGX rely on a
strong adversarial setting: possessing kernel privileges,
frequently crashing enclaves, and assuming a constant
memory layout. In this paper, we systematically explore
the SGX attack surface for memory corruption attacks.
In particular, we present the ﬁrst user-space memory
corruption attack against SGX. Our attack undermines
existing randomization schemes such as SGX-Shield
without requiring any enclave crashes. To do so, we
propose two new exploitation primitives that exploit
subtle intrinsics of SGX exception handling and the in-
teraction of enclave code to its untrusted host application.
Furthermore, given a memory corruption vulnerability,
our attacks apply to any enclave developed with the Linux
or Windows Intel SDK for SGX. As we argue, building
randomization-based defenses for SGX enclaves is
challenging as it requires careful support of SDK library
code and additional protection of SGX context data.
References
[1] BAUMANN, A., PEINADO, M., AND HUNT, G. Shielding ap-
plications from an untrusted cloud with haven. In Proceedings of
the 11th USENIX conference on Operating Systems Design and
Implementation (2014), USENIX Association, pp. 267–283.
[2] BAUMANN, A., PEINADO, M., AND HUNT, G. Shielding appli-
cations from an untrusted cloud with haven. ACM Transactions on
Computer Systems (TOCS) 33, 3 (2015), 8.
[3] BITTAU, A., BELAY, A., MASHTIZADEH, A., MAZI `ERES, D.,
AND BONEH, D. Hacking blind. In Proceedings of the 35th IEEE
Symposium on Security and Privacy (2014), SP’14.
[5] BRASSER, F., CAPKUN, S., DMITRIENKO, A., FRASSETTO, T.,
KOSTIAINEN, K., M ¨ULLER, U., AND SADEGHI, A. DR.SGX:
hardening SGX enclaves against cache attacks with data location
randomization. CoRR abs/1709.09917 (2017).
[6] BRASSER, F., M ¨ULLER, U., DMITRIENKO, A., KOSTIAINEN,
K., CAPKUN, S., AND SADEGHI, A.-R. Software grand expo-
sure: SGX cache attacks are practical. In USENIX Workshop on
Offensive Technologies (2017).
[7] CHEN, S., ZHANG, X., REITER, M. K., AND ZHANG, Y. De-
tecting privileged side-channel attacks in shielded execution with
D´ej´a Vu. In Proceedings of the 2017 ACM on Asia Conference on
Computer and Communications Security (2017), ACM, pp. 7–18.
IACR
[8] COSTAN, V., AND DEVADAS, S.
Intel SGX explained.
Cryptology ePrint Archive 2016 (2016), 86.
[9] DAVI, L., LEHMANN, D., SADEGHI, A.-R., AND MONROSE,
F. Stitching the gadgets: On the ineffectiveness of coarse-grained
In Proceedings of the 23rd
control-ﬂow integrity protection.
USENIX Security Symposium (2014).
[10] EVANS, I., LONG, F., OTGONBAATAR, U., SHROBE, H., RI-
NARD, M., OKHRAVI, H., AND SIDIROGLOU-DOUSKOS, S.
Control jujutsu: On the weaknesses of ﬁne-grained control ﬂow
integrity. In ACM CCS (2015).
[11] G ¨OKTAS, E., ATHANASOPOULOS, E., BOS, H., AND POR-
TOKALIDIS, G. Out of control: Overcoming control-ﬂow in-
tegrity. In Proceedings of the 35th IEEE Symposium on Security
and Privacy (2014), SP’14.
[12] GRUSS, D., LETTNER, J., SCHUSTER, F., OHRIMENKO, O.,
HALLER, I., AND COSTA, M. Strong and Efﬁcient Cache Side-
Channel Protection using Hardware Transactional Memory.
In
26th USENIX Security Symposium (2017).
[13] GRUSS, D., MAURICE, C., WAGNER, K., AND MANGARD, S.
In International
Flush+Flush: a fast and stealthy cache attack.
Conference on Detection of Intrusions and Malware, and Vulner-
ability Assessment (2016), Springer, pp. 279–299.
[14] INTEL.
Intel R(cid:13) Software Guard Extensions SDK. https://
software.intel.com/en-us/sgx-sdk.
[15] INTEL.
Intel R(cid:13) Software Guard Extensions SDK for Linux*.
https://01.org/intel-software-guard-extensions.
[16] INTEL. Intel R(cid:13) 64 and IA-32 Architectures Software Developer’s
Manual, Volume 3D: System Programming Guide, Part 4, Decem-
ber 2017. Order Number 332831-065US.
[17] IRAZOQUI, G., EISENBARTH, T., AND SUNAR, B.
S$A:
A shared cache attack that works across cores and deﬁes vm
In Security and Privacy
sandboxing–and its application to aes.
(SP), 2015 IEEE Symposium on (2015), IEEE, pp. 591–604.
[18] KUVAISKII, D., OLEKSENKO, O., ARNAUTOV, S., TRACH, B.,
BHATOTIA, P., FELBER, P., AND FETZER, C. SGXBOUNDS:
In Proceedings of
Memory safety for shielded execution.
the Twelfth European Conference on Computer Systems (2017),
ACM, pp. 205–221.
[19] LEE, J., JANG, J., JANG, Y., KWAK, N., CHOI, Y., CHOI, C.,
KIM, T., PEINADO, M., AND KANG, B. B. Hacking in dark-
ness: Return-oriented programming against secure enclaves. In
USENIX Security (2017), pp. 523–539.
[20] LEE, S., SHIH, M.-W., GERA, P., KIM, T., KIM, H., AND
PEINADO, M. Inferring ﬁne-grained control ﬂow inside SGX en-
claves with branch shadowing. In 26th USENIX Security Sympo-
sium, USENIX Security (2017), pp. 16–18.
[4] BOSMAN, E., AND BOS, H. Framing signals - A return to portable
shellcode. In Security and Privacy (SP), 2014 IEEE Symposium
on (2014), IEEE, pp. 243–258.
[21] LIU, F., YAROM, Y., GE, Q., HEISER, G., AND LEE, R. B. Last-
level cache side-channel attacks are practical. In Security and Pri-
vacy (SP), 2015 IEEE Symposium on (2015), IEEE, pp. 605–622.
1226    27th USENIX Security Symposium
USENIX Association
[22] MCKEEN, F., ALEXANDROVICH, I., ANATI, I., CASPI, D.,
JOHNSON, S., LESLIE-HURD, R., AND ROZAS, C. Intel R(cid:13) Soft-
ware Guard Extensions (Intel R(cid:13) SGX) support for dynamic mem-
ory management inside an enclave. In Proceedings of the Hard-
ware and Architectural Support for Security and Privacy 2016
(New York, NY, USA, 2016), HASP 2016, ACM, pp. 10:1–10:9.
IRAZOQUI, G., AND EISENBARTH, T.
CacheZoom: How SGX ampliﬁes the power of cache attacks. In
International Conference on Cryptographic Hardware and Em-
bedded Systems (2017), Springer, pp. 69–90.
[23] MOGHIMI, A.,
[24] SCHUSTER, F., COSTA, M., FOURNET, C., GKANTSIDIS, C.,
PEINADO, M., MAINAR-RUIZ, G., AND RUSSINOVICH, M.
VC3: Trustworthy data analytics in the cloud using SGX. In Se-
curity and Privacy (SP), 2015 IEEE Symposium on (2015), IEEE,
pp. 38–54.
[25] SEO, J. SGX-Shield open source repository. https://github.
com/jaebaek/SGX-Shield. Commit 04b09dd, 2017-09-27.
[26] SEO, J., LEE, B., KIM, S., SHIH, M.-W., SHIN, I., HAN, D.,
AND KIM, T. SGX-Shield: Enabling address space layout ran-
domization for SGX programs. In Proceedings of the 2017 Annual
Network and Distributed System Security Symposium (NDSS), San
Diego, CA (2017).
[27] SHACHAM, H. The geometry of innocent ﬂesh on the bone:
Return-into-libc without function calls (on the x86). In Proceed-
ings of the 14th ACM conference on Computer and communica-
tions security (2007), ACM, pp. 552–561.
[28] SHIH, M.-W., LEE, S., KIM, T., AND PEINADO, M. T-SGX:
Eradicating controlled-channel attacks against enclave programs.
In Network and Distributed System Security Symposium (2017).
[29] VAN BULCK, J., WEICHBRODT, N., KAPITZA, R., PIESSENS,
F., AND STRACKX, R. Telling Your Secrets without Page Faults:
Stealthy Page Table-Based Attacks on Enclaved Execution.
In
26th USENIX Security Symposium (USENIX Security) (2017).
[30] WEICHBRODT, N., KURMUS, A., PIETZUCH, P., AND
KAPITZA, R. AsyncShock: Exploiting synchronisation bugs in
Intel SGX enclaves. In European Symposium on Research in Com-
puter Security (2016), Springer, pp. 440–457.
[31] XU, Y., CUI, W., AND PEINADO, M. Controlled-channel attacks:
Deterministic side channels for untrusted operating systems. In
IEEE Symposium on Security and Privacy (2015).
[32] YAROM, Y., AND FALKNER, K. FLUSH+RELOAD: A high res-
olution, low noise, L3 cache side-channel attack. In USENIX Se-
curity Symposium (2014), pp. 719–732.
Appendix A: Shellcode
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
( t o t a l size of s t r u c t u r e s )
area for t e m p o r a r y data
T A R G E T I N F O + R E P O R T D A T A
area to copy s t r u c t u r e s into
; I n i t i a l r e g i s t e r s t a t e :
; rax = 0 ( E R E P O R T leaf )
; rbx = E E X I T r e t u r n a d d r e s s
; rcx = 5 1 2 + 5 1 2 + 6 4
;
; rdx = w r i t a b l e 512 - byte a l i g n e d e n c l a v e
;
; rdi = w r i t a b l e 512 - byte a l i g n e d e n c l a v e
;
; rsi = a d d r e s s of a t t a c k e r ’ s K E Y R E Q U E S T +
;
; rbp = a d d r e s s of a t t a c k e r ’ s key b u f f e r
; rsp = w r i t a b l e area for s h e l l c o d e s t a c k
push rbx
push rdi
; Copy K E Y R E Q U E S T , T A R G E T I N F O ,
; R E P O R T D A T A to e n c l a v e m e m o r y
rep movsb
; E R E P O R T
lea rcx , [ rdi -64]
lea rbx , [ rcx -512]
enclu
; Copy r e p o r t ’ s I S V S V N to K E Y R E Q U E S T
pop rbx
mov ax , [ rdx +258]
mov [ rbx +4] , ax
; Copy r e p o r t ’ s C P U S V N to K E Y R E Q U E S T
vmovdqa xmm0 , [ rdx ]
vmovdqu [ rbx +8] , xmm0
; Copy r e p o r t ’ s K E Y I D to K E Y R E Q U E S T
vmovdqa ymm0 , [ rdx +384]
vmovdqu [ rbx +40] , ymm0
; E G E T K E Y
push rdx
pop rcx
mov al , 1
enclu
; Copy key to a t t a c k e r ’ s m e m o r y
movdqa xmm0 , [ rdx ]
movdqu [ rbp ] , xmm0
; E E X I T to a t t a c k e r ’ s code
pop rbx
mov al , 4
enclu
Listing 5: Shellcode for cryptographic key extraction (74
bytes).
USENIX Association
27th USENIX Security Symposium    1227