221
---
## Page 223
为0600，目录则为0700。测试具有“不正确”权限的文件表达式为：
0090 suzad-sou- pue- odf4-
对于目录，表达式为：
0020 suxad-sou-pue-p odfq-
正如上逾操作符列表中提到的，这个-and操作符能够被安全地删除，因为它是默认使用的
操作符。所以如果我们把这两个表达式连起来，就得到最终的命令：
PodA-)1o-
然而，因为圆括号对于shell有特殊含义，我们必须转义它们，来阻止shell解释它们。在
圆括号字符之前加上一个反斜杠字符来转义它们。
逻辑操作符还有另外一个特性要重点理解。比方说我们有两个由逻辑操作符分开的表达式：
在所有情况下，总会执行表达式exprl；然而操作符将决定是否执行表达式expr2。这里列
出了它是怎样工作的：
expr1的结果
操作符
expr2 is..
章
-and
总要执行
假
-and
从不执行
章
-0r
从不执行
假
-0r
总要执行
表18-5:find AND/OR逻辑
为什么这会发生呢？这样做是为了提高性能。以-and为例，我们知道如果表达式exprl的
222
---
## Page 224
结果为假，表达式exprl-andexpr2不能为真，所以没有必要执行expr2。同样地，如果我们
有表达式exprl-orexpr2，并且表达式expr1的结果为真，那么就没有必要执行expr2，因为
我们已经知道表达式exprl-orexpr2为真。好。这样会执行快一些。为什么这个很重要？它很
重要是因为我们能依靠这种行为来控制怎样来执行操作。我们会很快看到.
18.3预定义的操作
让我们做一些工作吧！执行find命令得到结果列表很有用处，但是我们真正想要做的事情是操
作列表中的某些条目。幸运地是，find命令允许基于搜索结果来执行操作。有许多预定义的操
作和几种方式来应用用户定义的操作。首先，让我们看一下几个预定义的操作：
操作
描远
-delete
删除当前匹配的文件。
-ls
对匹配的文件执行等同的Is-dils命令。并将结果发送到标
准输出。
-print
把匹配文件的全路径名输送到标准输出。如果没有指定其
它操作，这是默认操作。
mb-
一旦找到一个匹配，退出。
表18-6:几个预定义的find命令操作
和测试条件一样，还有更多的操作。查看find命令手册得到更多细节。在第一个例子里
我们这样做：
find -
这个命令输出了我们家目录中包含的每个文件和子目录。它会输出一个列表，因为会默认
使用-print操作，如果没有指定其它操作的话。因此我们的命令也可以这样表述：
find --print
我们可以使用find命令来删除符合一定条件的文件。例如，来删除扩展名为“BAK”（这
通常用来指定备份文件）的文件，我们可以使用这个命令：
223
---
## Page 225
p- ,'*, -  - - pg
在这个例子里面，用户家目录（和它的子目录）下的每个文件中搜索以.BAK结尾的文件
名。当找到后，就删除它们。
警告：当使用-delete操作时，不用说，你应该格外小心。每次都应该首先用-print操作代
替-delete测试一下命令，来确认搜索结果。
在我们继续之前，让我们看一下逻辑运算符是怎样影响操作的。考虑以下命令：
utad- ,e'*, ouu- ada- - pu
正如我们所见到的，这个命令会查找每个文件名以.BAK（-name“*.BAK)结尾的普通文件
（-typef），并把每个匹配文件的相对路径名输出到标准输出（-print）。然而，此命令按这个方式
执行的原因，是由每个测试和操作之间的逻辑关系决定的。记住，在每个测试和操作之间会默
认应用-and逻辑运算符。我们也可以这样表达这个命令，使逻辑关系更容易看出：
ut.ad- pue- ,xvg°+, oreu- pue- odfq- - put
当命令被充分表达之后，让我们看看逻辑运算符是如何影响其执行的：
测试/行为
只有.的时候，才被执行
只有-type fand-name*,BAK'为真的时候
-name ‘*BAK'
只有-typef为真的时候
-type f
总是被执行，因为它是与-and关系中的第一个测试/行为。
因为测试和行为之间的逻辑关系决定了哪一个会被执行，我们可以看出知道测试和行为的
顺序很重要。例如，如果我们重新安排测试和行为之间的顺序，让-print行为是第一个，那么
224
---
## Page 226
这个命令执行起来会截然不同：
YV8'*, oueu- pue- J adfs- pue- qurad- - put
这个版本的命令会打印出每个文件（-print行为总是为真），然后测试文件类型和指定的文
件扩展名。
18.4用户定义的行为
除了预定义的行为之外。我们也可以调用任意的命令。传统方式是通过-exec行为。这个行为
像这样工作：
exec command {};
这里的command就是指一个命令的名字，}是当前路径名的符号表示，分号是必要的分
隔符表明命令的结束。这里是一个使用-exec行为的例子，其作用如之前讨论的-delete行为：
exec rn '{}' ';'
重述一遍，因为花括号和分号对于shell有特殊含义，所以它们必须被引起来或被转义。
我们也可以交互式地执行一个用户定义的行为。通过使用-ok行为来代替-exec，在执行每
个指定的命令之前，会提示用户：
{， T-s xo-,ooy, oueu- odfq-- pu
 ? y
-rvxr-xr-x 1 me
ne 224 2007-10-29 18:44 /hone/ne/bin/foo
 ? y
rv-r---=1 me
ne 0 2008-09-19 12:53 /home/me/foo.txt
在这个例子里面，我们搜索以字符串“foo”开头的文件名，并且对每个匹配的文件执行ls
-1命令。使用-ok行为，会在ls命令执行之前提示用户。
225
---
## Page 227
18.5提高效率
当-exec行为被使用的时候，若每次找到一个匹配的文件。它会启动一个新的指定命令的实例。
我们可能更愿意把所有的搜索结果结合起来，再运行一个命令的实例。例如，与其像这样执行
命令：
1s -1 file1
1s -1 file2
我们更喜欢这样执行命令：
1s -1 file1 file2
这样就导致命令只被执行一次而不是多次。有两种方法可以这样做。传统方式是使用外部
命令xargs，另一种方法是，使用find命令自己的一个新功能。我们先讨论第二种方法。
通过把末尾的分号改为加号，就激活了find命令的一个功能，把搜索结果结合为一个参数
列表，然后用于所期望的命令的一次执行。再看一下之前的例子，这个例子中：
，,}， T- s axa-,oog, oueu- odf-- pu
rvxr-xr-x 1 me
me 224 2007-10-29 18:44 /home/me/bin/foo
rv-r--r-- 1 me
me 0 200809-19 12:53 /hone/me/foo.txt
每次找到一个匹配的文件，就会执行一次ls命令。通过把命令改为：
+,}. [- s axa-,oy, aueu- adfq-- put
rvxr-xr-x 1 me
me 224 2007-10-29 18:44 /home/me/bin/foo
rv-r-r-- 1 me
me 0 200809-19 12:53 /hone/ne/foo.txt
虽然我们得到一样的结果，但是系统只需要执行一次Is命令。
18.5.1 xargs
这个xargs命令会执行一个有趣的函数。它从标准输入接受输入，并把输入转换为一个特定命
令的参数列表。对于我们的例子，我们可以这样使用它：
226
---
## Page 228
[- 5T s8xex 1 sutzd-,ooy, oueu- odfq-- put
rVxr-xr-x 1 me
me 224 2007-10-29 18:44 /home/ze/bin/foo
rv-r--r-- 1 me
me 0 200809-19 12:53 /hone/me/foo.txt
这里我们看到find命令的输出被管道到xargs命令，之后，xargs会为ls命令构建参数列
表，然后执行ls命令。
注意：当被放置到命令行中的参数个数相当大时，参数个数是有限制的。有可能创建的命令
太长以至于shell不能接受。当命令行超过系统支持的最大长度时，xargs会执行带有最大参数
个数的指定命令，然后重复这个过程直到耗尽标准输入。执行带有-show-limits选项的xargs
命令，来查看命令行的最大值。
处理古怪的文件名
类Unix的系统允许在文件名中嵌入空格（甚至换行符）。这就给一些程序，如
为其它程序构建参数列表的xargs程序，造成了问题。一个嵌入的空格会被看作是
一个分隔符，生成的命令会把每个空格分离的单词解释为单独的参数。为了解决这
个问题，find命令和xarg程序允许使用一个可选的null字符作为参数分隔符。一
个null字符被定义在ASCII码中，由数字零来表示（相反的，例如，空格字符在
ASCII码中由数字32表示）。find命令提供的-print0行为，则会产生由null字符
分离的输出，并且xargs命令有一个-null选项，这个选项会接受由mull字符分离
的输入。这里有一个例子：
[ s [nu sSrex0uud- Sdf, aueu- ~ puy
使用这项技术，我们可以保证所有文件，甚至那些文件名中包含空格的文件，都
能被正确地处理。
18.6返回操练场
到实际使用find命令的时候了。我们将会创建一个操练场，来实践一些我们所学到的知识。
227
---
## Page 229
首先，让我们创建一个包含许多子目录和文件的操练场：
[ne@linuxbox -]$ mikdir -p playground/dir-{00{1..9),0{10. .99} ,100]
[ne@linuxbox -]$ touch playground/dir-{00{1..9} ,0{10. .99} ,100}/file-{A. .2}
惊叹于命令行的强大功能！只用这两行，我们就创建了一个包含一百个子目录，每个子目录
中包含了26个空文件的操练场。试试用GUI来创建它！
我们用来创造这个奇迹的方法中包含一个熟悉的命令（mkdir），一个奇异的shell扩展（花
括号）和一个新命令，touch。通过结合mkdir命令和-p选项（导致mkdir命令创建指定路径
的父目录），以及花括号展开，我们能够创建一百个目录。
这个touch命令通常被用来设置或更新文件的访问，更改，和修改时间。然而，如果一个文
件名参数是一个不存在的文件，则会创建一个空文件。
在我们的操练场中，我们创建了一百个名为file-A的文件实例。让我们找到它们：
Yo, oueu- adf- punoxfe[d put s[- xoqxnutgou]
注意不同于ls命令，find命令的输出结果是无序的。其顺序由存储设备的布局决定。为了
确定实际上我们拥有一百个此文件的实例，我们可以用这种方式来确认：
[- on 1 v-oty, oueu-J adf- pumofed putg s[- xoqxnutgou]
下一步，让我们看一下基于文件的修改时间来查找文件。当创建备份文件或者以年代顺序
来组织文件的时候，这会很有帮助。为此，首先我们将创建一个参考文件，我们将与其比较修
改时间：
[nedlinuxbox -]$ touch playground/tinestanp
这个创建了一个空文件，名为timestamp，并且把它的修改时间设置为当前时间。我们能够
验证它通过使用另一个方便的命令，stat，是一款加大马力的ls命令版本。这个stat命令会展
示系统对某个文件及其属性所知道的所有信息：
228
---
## Page 230
[nedlinuxbox -]$ stat playground/tinestasp
File: ‘playground/timestanp*
Size: 0 Blocks: 0 I0 Block: 4096 regular enpty file
Device: 803h/2051d Inode: 14265061 Links: 1
Access:(0644/-rv-r--r--) Uid: ( 1001/ ne) Gid: ( 1001/ me)
Access: 2008-1008 15:15:39.000000000 -0400
Modify: 2008-1008 15:15:39.000000000 -0400
Change: 2008-10-08 15:15:39.000000000 -0400
如果我们再次touch这个文件，然后用stat命令检测它，我们会发现所有文件的时间已经
更新了。
[nedlinuxbox -]$ touch playground/tinestanp
drepsouta/pumoxa(e[d sess s[- xoqxnuttoou]
File: ‘playground/timestanp'
Size: 0 Blocks: 0 I0 Block: 4096 regular enpty fi1e
Device: 803h/2051d Inode: 14265061 Links: 1
Access: (0644/-rv-r--r--) Uid: ( 1001/ ne) Gid: (1001/ ne)
Access: 2008-1008 15: 23:33.000000000 -0400
Modify: 2008-1008 15:23:33.000000000 -0400
Change: 2008-10-08 15:23:33.000000000 -0400
下一步，让我们使用find命令来更新一些操练场中的文件：
[nellinuxbox -]$ find playground =type f -nane ‘file-B' -exec touch *{}′ ;'
这会更新操练场中所有名为file-B的文件。接下来我们会使用find命令通过把所有文件与
参考文件timestamp做比较，来找到已更新的文件：
dueμsowta/pumo.x8Ke[d xonou- J odf4- pumox3fetd putz $[- xoqxnustgou]
搜索结果包含所有一百个文件file-B的实例。因为我们在更新了文件timestamp之后
229
---
## Page 231
touch了操练场中名为file-B的所有文件，所以现在它们“新于”timestamp文件，因此能被用
-newer测试条件找到。
最后，让我们回到之前那个错误权限的例子中，把它应用于操练场里：
[ne@linuxbox -]$ find playground \( =type f -not -perm 0600 \) -or \( -type d -not -perm 070 )
这个命令列出了操练场中所有一百个目录和二百六十个文件（还有timestamp和操练场本
身，共2702个），因为没有一个符合我们“正确权限”的定义。通过对运算符和行为知识的了
解，我们可以给这个命令添加行为，对实战场中的文件和目录应用新的权限。
（\,, 0090 poup soxa- 0090 urad sou-J ads-)\ pumoxfed put $[- xoqxnustgou]
（\1.{}， ooo pou axo-110 mxod-4ou-p adf-)\ xo-
在日常的基础上，我们可能发现运行两个命令会比较容易一些，一个操作目录，另一个操作
文件，而不是这一个长长的复合命令，但是很高兴知道，我们能这样执行命令。这里最重要的
一点是要理解怎样把操作符和行为结合起来使用，来执行有用的任务。
18.6.1选项
最后，我们有这些选项。这些选项被用来控制find命令的搜索范围。当构建find表达式的时
模，它们可能被其它的测试条件和行为包含，这里有一个最常被使用的选项的列表：
选项
描远
-depth
指示find程序先处理目录中的文件，再处理目录自身。当
指定-delete行为时，会自动应用这个选项。
-maxdepth levels
当执行测试条件和行为的时候，设置find程序陷入目录树
的最大级别数
mindepth levels
在应用测试条件和行为之前，设置find程序陷入目录数的
最小级别数。
pumou-
指示find程序不要搜索挂载到其它文件系统上的目录。
-noleaf
指示find程序不要基于自已在搜索Unix的文件系统的假
设，来优化它的搜索。在搜索DOS/Windows文件系统和
CD/ROMS的时候，我们需要这个选项
表18-7：f命令选项
---