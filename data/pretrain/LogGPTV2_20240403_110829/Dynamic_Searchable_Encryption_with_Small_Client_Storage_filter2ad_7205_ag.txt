time depends on prior deleted documents, which in the worst-
case may lead to O(N ) search overheads. Thus, for delete
intensive query workloads, we propose QOS which is the
most efﬁcient DSE with quasi-optimal search time, improving
previous performance of quasi-optimal DSE schemes by orders
of magnitude. For many practical scenarios, we believe that
SDd will be a better choice than QOS ; however QOS has
been a step towards achieving optimal search performance,
since it has only a logarithmic overhead compared to the
optimal search time and as we show experimentally for >80%
deletion percentage (hypothetical delete-intensive workload)
QOS becomes a better choice. Regarding future work, one
possible direction is to develop forward and backward private
schemes with optimal search time, ideally without oblivious
primitives and with small client storage.
ACKNOWLEDGEMENTS
This work was supported in part by NSF awards #1514261
and #1652259, the National Institute of Standards and Technol-
ogy, and by Hong Kong RGC grant ECS-26208318. We thank
Jeremiah Blocki for shepherding the paper and the anonymous
reviewers for their valuable suggestions and comments.
REFERENCES
[1]
[2]
[3]
[4]
“Crimes 2001 to present (city of chicago). https://data.cityofchicago.org/
public-safety/crimes-2001-to-present/ijzp-q8t2.”
“Pixek app. https://pixek.io/.”
“Tpc-h benchmark. http://www.tpc.org/tpch.”
“OpenSSL:
https://www.openssl.org/, 2003.
SSL/TLS,”
toolkit
source
open
The
for
[5] G. Amjad, S. Kamara, and T. Moataz, “Forward and backward private
searchable encryption with SGX,” in EuroSec, 2019.
[6] G. Asharov, I. Komargodski, W. Lin, K. Nayak, and E. Shi, “Optorama:
Optimal oblivious RAM,” IACR, 2018.
[7] G. Asharov, M. Naor, G. Segev, and I. Shahaf, “Searchable symmetric
encryption: optimal locality in linear space via two-dimensional bal-
anced allocations,” in STOC, 2016.
[8] D. Boneh and B. Waters, “Constrained pseudorandom functions and
their applications,” in ASIACRYPT, 2013.
[9] R. Bost, “Sofos: Forward secure searchable encryption,” in CCS, 2016.
15
[10] R. Bost, B. Minaud, and O. Ohrimenko, “Forward and backward private
searchable encryption from constrained cryptographic primitives,” in
CCS, 2017.
[11] E. Boyle, S. Goldwasser, and I. Ivan, “Functional signatures and
pseudorandom functions,” in PKC, 2014.
[12] D. Cash, J. Jaeger, S. Jarecki, C. Jutla, H. Krawczyk, M. Rosu, and
M. Steiner, “Dynamic Searchable Encryption in Very-Large Databases:
Data Structures and Implementation,” in NDSS, 2014.
[13] D. Cash, S. Jarecki, C. Jutla, H. Krawczyk, M.-C. Ros¸u, and M. Steiner,
“Highly-Scalable Searchable Symmetric Encryption with Support for
Boolean Queries,” in CRYPTO, 2013.
[14] D. Cash and S. Tessaro, “The Locality of Searchable Symmetric
Encryption,” in EUROCRYPT, 2014.
[15] Y.-C. Chang and M. Mitzenmacher, “Privacy Preserving Keyword
Searches on Remote Encrypted Data,” in ACNS, 2005.
[16] Y. Chang and M. Mitzenmacher, “Privacy preserving keyword searches
on remote encrypted data,” in ACNS 2005, 2005.
[17] M. Chase and S. Kamara, “Structured encryption and controlled disclo-
sure,” in ASIACRYPT, 2010.
[18] S. Chaudhuri and U. Dayal, “An overview of data warehousing and
olap technology,” SIGMOD, 1997.
[21]
[20]
[19] R. Curtmola, J. Garay, S. Kamara, and R. Ostrovsky, “Searchable Sym-
metric Encryption: Improved Deﬁnitions and Efﬁcient Constructions,”
in CCS, 2006.
I. Demertzis, D. Papadopoulos, and C. Papamanthou, “Searchable
encryption with optimal locality: Achieving sublogarithmic read efﬁ-
ciency,” in CRYPTO, 2018.
I. Demertzis, S. Papadopoulos, O. Papapetrou, A. Deligiannakis,
M. Garofalakis, and C. Papamanthou, “Practical private range search
in depth,” TODS, 2018.
I. Demertzis, S. Papadopoulos, O. Papapetrou, A. Deligiannakis, and
M. N. Garofalakis, “Practical private range search revisited,” in SIG-
MOD, 2016.
I. Demertzis and C. Papamanthou, “Fast Searchable Encryption With
Tunable Locality,” in SIGMOD, 2017.
I. Demertzis, R. Talapatra, and C. Papamanthou, “Efﬁcient searchable
encryption through compression,” PVLDB, 2018.
[22]
[23]
[24]
[25] M. Etemad, A. K¨upc¸ ¨u, C. Papamanthou, and D. Evans, “Efﬁcient
dynamic searchable encryption with forward privacy,” PETS, 2018.
[26] S. Faber, S. Jarecki, H. Krawczyk, Q. Nguyen, M. Rosu, and M. Steiner,
“Rich Queries on Encrypted Data: Beyond Exact Matches,” in ES-
ORICS, 2015.
[28]
[27] S. Garg, P. Mohassel, and C. Papamanthou, “TWORAM: efﬁcient obliv-
ious RAM in two rounds with applications to searchable encryption,”
in CRYPTO, 2016.
J. Ghareh Chamani, “Implementation of QOS, SDA, and SDD,”
https://github.com/jgharehchamani/Small-Client-SSE, 2019.
J. Ghareh Chamani, D. Papadopoulos, C. Papamanthou, and R. Jalili,
“New constructions for forward and backward private symmetric search-
able encryption,” in CCS, 2018.
J. Ghaareh Chamani, “Implementation of Mitra, Orion, Horus, Fides, and
Diana Del,” https://github.com/jgharehchamani/SSE, 2018.
[29]
[30]
[31] O. Goldreich, S. Goldwasser, and S. Micali, “On the cryptographic
applications of random functions,” in CRYPTO, 1984.
[32] F. Hahn and F. Kerschbaum, “Searchable encryption with secure and
efﬁcient updates,” in CCS, 2014.
[33] A. Hamlin, A. Shelat, M. Weiss, and D. Wichs, “Multi-key searchable
encryption, revisited,” in PKC, 2018.
[34] S. Kamara and T. Moataz, “Boolean searchable symmetric encryption
with worst-case sub-linear complexity,” in EUROCRYPT, 2017.
[35] S. Kamara and T. Moataz0, “Sql on structurally-encrypted databases,”
in ASIACRYPT, 2018.
[36] S. Kamara and C. Papamanthou, “Parallel and dynamic searchable
symmetric encryption,” in FC 2013, 2013.
[37] S. Kamara, C. Papamanthou, and T. Roeder, “Dynamic Searchable
Symmetric Encryption,” in CCS, 2012.
[38] A. Kiayias, S. Papadopoulos, N. Triandopoulos, and T. Zacharias, “Del-
egatable Pseudorandom Functions and Applications,” in CCS, 2013.
[39] K. S. Kim, M. Kim, D. Lee, J. H. Park, and W.-H. Kim, “Forward secure
dynamic searchable symmetric encryption with efﬁcient updates,” in
CCS, 2017.
[40] R. W. F. Lai and S. S. M. Chow, “Forward-secure searchable encryption
on labeled bipartite graphs,” in ACNS, 2017.
[41] X. Meng, S. Kamara, K. Nissim, and G. Kollios, “GRECS: graph
encryption for approximate shortest distance queries,” in CCS, 2015.
[42] T. Midorikawa, A. Tachikawa, and A. Kanaoka, “Helping johnny to
[43]
search: Encrypted search on webmail system,” in AsiaJCIS, 2018.
I. Miers and P. Mohassel, “IO-DSSE: Scaling Dynamic Searchable
Encryption to Millions of Indexes By Improving Locality,” in NDSS,
2017.
[44] M. Naveed, M. Prabhakaran, and C. A. Gunter, “Dynamic searchable
encryption via blind storage,” in IEEE SP 2014, 2014, pp. 639–654.
[45] M. H. Overmars, The Design of Dynamic Data Structures, ser. Lecture
Notes in Computer Science. Springer, 1983.
[46] M. H. Overmars and J. van Leeuwen, “Worst-case optimal insertion and
deletion methods for decomposable searching problems,” Inf. Process.
Lett., 1981.
[47] S. Patel, G. Persiano, M. Raykova, and K. Yeo, “Panorama: Oblivious
RAM with logarithmic overhead,” in FOCS 2018, 2018.
[48] D. S. Roche, A. J. Aviv, and S. G. Choi, “A practical oblivious map
data structure with secure deletion and history independence,” in IEEE
SP, 2016.
[49] C. V. Rompay, R. Molva, and M. ¨Onen, “Multi-user searchable encryp-
tion in the cloud,” in ISC 2015, 2015.
[50] C. V. Rompay, R. Molva, and M. Onen, “Secure and scalable multi-user
searchable encryption,” in SCC Workshop, 2018.
[51] D. X. Song, D. Wagner, and A. Perrig, “Practical Techniques for
Searches on Encrypted Data,” in SP, 2000.
[52] E. Stefanov, C. Papamanthou, and E. Shi, “Practical Dynamic Search-
able Encryption with Small Leakage,” in NDSS, 2014.
[53] E. Stefanov, M. Van Dijk, E. Shi, C. Fletcher, L. Ren, X. Yu, and S. De-
vadas, “Path Oram: An Extremely Simple Oblivious Ram Protocol,” in
CCS, 2013.
[54] S.-F. Sun, X. Yuan, J. K. Liu, R. Steinfeld, A. Sakzad, V. Vo,
and S. Nepal, “Practical backward-secure searchable encryption from
symmetric puncturable encryption,” in CCS, 2018.
[55] X. S. Wang, K. Nayak, C. Liu, T. Chan, E. Shi, E. Stefanov, and
Y. Huang, “Oblivious data structures,” in CCS, 2014.
[56] Y. Zhang, J. Katz, and C. Papamanthou, “All Your Queries Are Belong
to Us: The Power of File-Injection Attacks on Searchable Encryption,”
in USENIX 2016.
APPENDIX
Figure 13 shows the RealSSE and IdealSSE games for the
DSE security deﬁnition 1.
The original PiBas scheme was slightly different: entries
for each w were encrypted by a different key (pseudorandomly
generated from a master secret key). During search, this key
was sent to the server who could decrypt them and directly
return the indexes. Since we need a result-hiding scheme (in
order to get backward privacy), we modify the scheme in
the following manner. First, all entries are encrypted with
the same key. During search, the server sends the encrypted
values back and the client decrypts them locally. The scheme
is described in detail in Figure 12. It is adaptively secure
in the random oracle model with setup leakage |DB| and
search leakage |DB(w)|. The random oracle assumption can
be removed without any change in the efﬁciency of the scheme,
by replacing H with a PRF F and having the client send all the
PRF evaluations in a “streaming” manner until a stop message
has been sent by the server (see [12] for details).
16
Let RND = (KeyGen, Enc, Dec) be a semantically-
secure encryption scheme, F be a PRF, and H be a
collision-resistant hash function.
(K, EDB) ← Setup(1λ, DB)
1: Initialize an empty map T
2: Set (k, k(cid:48)) ← KeyGen(1λ)
3: for each w ∈ DB do
Set counter c ← 0
4:
(key, value) ← Map(K, w, id, c)
5:
c++
Store (key, value) to T ;
6:
7: Set K ← (k, k(cid:48)); EDB ← T
(k, k(cid:48)) ← KeyGen(1λ)
1: Choose random PRF key k for F
2: Set k(cid:48) ← RND.Enc(1λ)
(key, value) ← Map(K, w, id, c)
1: key ← H(F (k, w), c)
2: value ← RN D.Enc(k(cid:48), w, id)
DB(w) ↔ Search(K, q; EDB)
Client:
1: Send tk ← F (k, w) to server
Server:
2: Set X ← ∅;
3: while true do
4:
5:
6:
7: Send X to client
Client:
8: Decrypt entries of X with k(cid:48) and return them as
Set res ← T .get(H(tk), c)
if res = ⊥ then break
else X ← X ∪ res;
c ← 0
c++
DB(w)
Fig. 12: Static searchable encryption PiBas [12].
sketch. Building a
Theorem 1: Assuming SE is an adaptively-secure result-
hiding static searchable encryption scheme, SDa is an
adaptively-secure DSE according to Deﬁnition 1 with
LU pdt(op, w, id) = ⊥ and LSrch(w) = Updates(w).
simulator Sim is
Proof
straight-
forward, given the existence of a simulator SimSE =
{SimInitSE, SimSearchSE}. SimInit returns empty vector
EDB and initializes and update counter upd = 0. During
each update, SimU pdate computes j as the least signiﬁcant
zero bit position of upd, runs a new instance Sim(j)
SE =
{SimInit(j)
SE on input
2j, and sends the result to the adversary. It also terminates cur-
SE for i = 0, . . . , j−1, and
rently running instances of SimInit(i)
increments upd. During a search for w, let upd be the current
update counter. SimSearch receives as input Updates(w). It
then initializes values t0, . . . , t(cid:98)log upd(cid:99) to 0. For each entry
u ∈ Updates(w), it computes i as the index in which the
update with timestamp u was stored (determined by upd, u)
and increments ti by one. Finally for j = 0, . . . ,(cid:98)log upd(cid:99),
it runs SimSearch(j)
SE on input tj, and sends all the outputs
to the adversary. Assuming SE is secure and result-hiding,
SE }, executes SimInit(j)
SE , SimSearch(j)
b ← RealSSE
Adv (λ, q):
1: N ← Adv(1λ)
2: (K, σ0, EDB0) ← Initialize(1λ, N )
3: for k = 1 to q do
4:
5:
6:
(typek, idk, wk) ← Adv(1λ, EDB0, t1, . . . , tk−1)
if typek = search then