Thomas 写规则：时间戳排序协议的修改，并发程度比时间戳排序协议高，通过删除事务发出的过时的写操作来使用视图可串行性
### 基于有效性检查的协议
要求每个事务在其生命周期中按两个或三个阶段执行：
1. 读阶段：读取数据存入内存，所有的写操作都是在内存里
2. 有效性检查阶段：判断操作的数据不会与其他事务产生冲突，这点是根据事务的时间戳以及操作的数据集合来判断的，只要这两个没有重叠，那就是不会冲突
3. 写阶段：通过有效性检查，写操作可以被写入到数据库当中了
### 可串行化的快照隔离
在事务提交时，检测是否违背了串行化，若违背了，终止事务重新执行
### 多版本并发控制
MVCC（Multi-Version Concurrency Control） 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，避免了加锁操作
多版本时间戳排序: 通过为每个事务分配唯一的时间戳，以及维护每个事务的读集和写集，来确保事务隔离和一致性
多版本两阶封锁: 每个事务的写操作需要获取一个排他锁，而读操作只需要获取一个共享锁
#### 存储方式
1. Append-Only 方式，对数据每次更新记录日志，每次需要当前数据就从头跑一遍，随着历史版本增多，会导致查询速度变慢
2. Delta 方式：增量版本 + 全量版本
3. Time-Travle 方式：历史版本全量且独立存储
#### MySQL 实现
每行有两个额外字段：创建版本号、删除版本号
每个事务都拥有一个系统版本号，每次开始新的事务，版本号就会递增
1. SELECT时 满足以下两个条件的行才会被返回
	1. 行的版本号小于等于当前版本号
	2. 删除版本号为空或者大于当前版本号
2. UPDATE、DELETE、INSERT时 写入新版本号，更新数据都是先读后写的，而这个读，只能读当前的值
隐藏字段：
每条记录的一些隐式字段：
- DB_TRX_ID 最后一次修改该记录的事务ID
- DB_ROLL_PTR 指向这条记录的上一个版本
- DB_ROW_ID 隐式自增ID（没有主键时 innodb 根据这个生成聚簇索引）
- 创建版本号
- 删除版本号
undo日志：
MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中
```sql
INSERT INTO t(id, x) VALUES(1, "a");
UPDATE t SET x="b" WHERE id=1;
UPDATE t SET x="c" WHERE id=1;
```
上面的三条sql对应于三个事务
![批注 2020-03-08 203234](/assets/批注%202020-03-08%20203234.png)
ReadView：
MVCC 维护了一个 ReadView 结构，主要包含了当前系统未提交的事务列表，通过事务 ID 和链上不同版本的对比，找到一个合适的可见版本的
![批注 2020-03-08 203401](/assets/批注%202020-03-08%20203401.png)
- 当前读 ：读取记录最新版本 读取时会加锁 select for update
- 快照读：不会加锁 读取的是历史版本 select
![数据可见性算法](/assets/屏幕截图%202021-07-12%20214235.png)
![低水位为 low-limit-id，高水位为 up-id](/assets/2022712114746.webp)
#### 分布式环境下需要考虑的
1. 何保证产生单调递增事务 ID
2. 如何提供全局快照。每个事务要把自己的状态发送给一个集中点，由它维护一个全局事务列表，并向所有事务提供快照
在 PGXC 风格的分布式数据库都有一个集中点，叫做全局事务管理器
有些 NewSQL 风格的分布式数据库则是直接提供一个更高的隔离级别或者压根不提供隔离实现，当然提高隔离级别也意味着并行能力的下降
### 快照隔离
快照隔离在事务开始执行时给它数据库的一份“快照” 。然后，事务在该快照上操作，和其他并发事务完全隔离开，在事务提交时再解决与其他事务的冲突：
1. 先提交者获胜：事务在提交时探测是否有其他事务也在写相同的数据，如果有，则放弃
2. 先更新者获胜：事务在更新时先获取锁，如果获取不到锁，则放弃
但这种方式没法解决两个事务互相读取对方修改的数据，但是不进行更新的情况，为了解决这个问题，还是需要引入读锁
### 插入操作、删除操作与谓词读
删除：
- 在两阶段封锁协议下，一数据项可以删除之前，在该数据项上必须请求加排他锁
- 在时间戳排序协议下，如果有其他事务在删除之后读写数据，删除操作都要被拒绝
插入：
- 在两阶段封锁协议下，插入的数据要加排它锁
- 在时间错排序协议下，插入的数据的时间戳要设为当前的时间戳
谓词读：
对于 where a = 'xxx' 这种形式的语句，也需要进行上锁，否则会出现幻读：
- 索引封锁协议：不直接锁数据，而是锁索引
- 谓词锁：关系上的插入和删除操作都要检查是否游足谓词。若满足，则存在锁冲突，插入和删除操作要等待直到谓词锁被释放
### 实践中的弱一致性级别
1. 二级一致性：共享锁可以在任何时候释放，并且锁可以在任何时间获得，而排他锁只有在事务提交或中止后才能释放
2. 游标稳定性：对游标指向的当前记录加共享锁，对更改的数据加排它锁直至事务提交
3. 版本号乐观锁
### 索引结构中的并发
索引是争用的热点，如何解决索引访问与更新的冲突：
1. 蟹行协议：从上往下加共享锁，不断缩小锁粒度，直至找到需要的节点
2. next-key lock
### 单对象多对象事务
新型文档数据库也提供了原子性和隔离性的实现，比如通过编程语言的原子操作或者CAS操作来实现，
## 恢复系统
恢复机制负责将数据库恢复到故障发生前的一致的状态
故障分类：
- 事务故障：即软件错误，如事务的SQL有bug
- 系统崩溃：硬件故障或者整个数据库都崩溃了
- 磁盘故障：部分磁盘块损坏等
恢复过程要保证对磁盘的写要么完全成功，要么没有任何改变。同时对于事务的读，每个事务都有自己的一个缓冲区，用来提升性能，像是 MySQL 的 Buffer Pool，缓冲区到磁盘有两种操作：input与output，对应于缓冲区从磁盘读数据、写数据
### 恢复与原子性
为了达到写入的原子性的目标，数据库采用 WAL 机制，即先写日志，后再更新数据来实现
日志记录了数据库中所有的更新活动，一般有这么几个字段：
- 事务标识：执行更新操作的事务
- 数据项标识：一般是数据在磁盘上的位置
- 旧值
- 新值
undo 日志将修改的数据项设置为旧值
redo 日志将修改的数据项设置为新值
如果一个数据项被一个事务修改了，那么在该事务提交或中止前不允许其他事务修改该数据项，这可以通过排它锁来实现，也可以在快照隔离性中在事务提交时进行验证，看有没有与其他事务冲突
当事务提交，在日志中就有一个 commit 记录，这样即使发生崩溃，数据库在启动崩溃恢复时，如果发现一个事务没有 commit 日志，就可以读取之前的 undo 日志记录撤销更新
为了避免每次崩溃恢复要扫描大量日志，通过标记一个检查点，检查点之前的更新确保已经写入到磁盘，这样可以减少扫描的日志记录数量
### 恢复算法
#### 正常时的事务回滚
1. 从后往前扫描日志直至到这个事务起始记录
2. 对于每条日志记录，恢复成旧值，同时记录一条撤销操作的记录，最后写入一个 abort 标识记录
#### 崩溃后的恢复
重做阶段：以最后一个检查点开始正向地扫描日志来重放所有事务的更新，这个阶段会把没有提交成功也没有回滚成功的事务们添加到一个列表 undo-list 中
撤销阶段：从尾端开始反向扫描日志来执行回滚 undo-list 中的所有事务
![20230424211720](/assets/20230424211720.png)
以上考虑的是数据库崩溃的情况，如果考虑磁盘整个挂掉的情况，就需要定时对整个数据做备份，一旦发生磁盘故障，就可以通过备份的数据 + 日志记录的方式来进行恢复，备份的过程开销较大，其要暂停所有事务的执行，后将缓冲区的数据全部刷到磁盘
### 缓冲区管理
每次写日志都写磁盘的代价有点高，可以先记录日志到缓冲区，再统一刷到磁盘，为了避免缓冲区中的日志丢失，需要保证事务提交前，与该事务有关的日志都要写到磁盘
大多数数据库采用了非强制策略来管理对数据更新，即即使事务提交，所更新的数据也不一定马上写入磁盘，而是将多个更新聚合在一起，一起写入磁盘提升性能，由于日志机制的存在，所以不用担心丢失数据的风险，在进行数据写入时，需要采取封锁机制，避免其他事务读写该数据，一般数据库都会使用一个类似 ring buffer 的区域拉进行上述的缓冲管理，缓冲中修改的数据，但还没写到磁盘的数据称为脏块，脏块写到磁盘乎就不脏了，此时如果缓冲不足，不脏的块就可以淘汰掉
由于操作系统自己还管理着[虚拟内存](/操作系统/内存管理.md#虚拟内存)，这就意味着数据库以为写到内存的数据，实际上有可能会被写到swap中，除非数据库自己管理内存，不过这点在现代操作系统中是不可能的
### ARIES
ARIES 是一种经典的恢复算法：
1. 使用日志序列号LSN来标识日志记录，LSN存储在数据库页中，代表哪些操作已经做过
2. 物理逻辑redo
3. 使用脏页表最大限度减少恢复时不必要的redo
4. 模糊检查点
1.分析阶段：在分析阶段，ARIES算法通过日志文件中的信息，确定了在系统崩溃之前处于活动状态的事务，以及这些事务在哪个时刻提交或中止。在这个阶段，ARIES算法还会生成一个恢复数据结构，用于记录恢复的过程中需要用到的信息。
2.重做阶段：在重做阶段，ARIES算法会根据日志文件中的信息，重做所有在系统崩溃之前已经提交但数据还没落盘的事务的操作。这样可以保证数据库的一致性。在这个阶段，ARIES算法会将所有已提交事务的操作重做一遍，并且将重做的结果记录在恢复数据结构中。
3.撤销阶段：在撤销阶段，ARIES算法会撤销所有在系统崩溃之前处于活动状态的事务的操作，并将撤销的结果记录在恢复数据结构中。在这个阶段，ARIES算法会根据日志文件中的信息，找到所有处于活动状态的事务，并将这些事务的操作全部撤销。