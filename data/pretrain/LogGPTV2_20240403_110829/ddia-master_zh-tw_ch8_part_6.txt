* 如果某个节点被 NTP 伺服器的防火墙意外阻塞，有可能会持续一段时间都没有人会注意到。有证据表明，这在实践中确实发生过。
* NTP 同步只能和网路延迟一样好，所以当你在拥有可变资料包延迟的拥塞网路上时，NTP 同步的准确性会受到限制。一个实验表明，当透过网际网路同步时，35 毫秒的最小误差是可以实现的，尽管偶尔的网路延迟峰值会导致大约一秒的误差。根据配置，较大的网路延迟会导致 NTP 客户端完全放弃。
* 一些 NTP 伺服器是错误的或者配置错误的，报告的时间可能相差几个小时【43,44】。还好 NTP 客户端非常健壮，因为他们会查询多个伺服器并忽略异常值。无论如何，依赖于网际网路上的陌生人所告诉你的时间来保证你的系统的正确性，这还挺让人担忧的。
* 闰秒导致一分钟可能有 59 秒或 61 秒，这会打破一些在设计之时未考虑闰秒的系统的时序假设【45】。闰秒已经使许多大型系统崩溃的事实【38,46】说明了，关于时钟的错误假设是多么容易偷偷溜入系统中。处理闰秒的最佳方法可能是让 NTP 伺服器 “撒谎”，并在一天中逐渐执行闰秒调整（这被称为 **拖尾**，即 smearing）【47,48】，虽然实际的 NTP 伺服器表现各异【49】。
* 在虚拟机器中，硬体时钟被虚拟化，这对于需要精确计时的应用程式提出了额外的挑战【50】。当一个 CPU 核心在虚拟机器之间共享时，每个虚拟机器都会暂停几十毫秒，与此同时另一个虚拟机器正在执行。从应用程式的角度来看，这种停顿表现为时钟突然向前跳跃【26】。
* 如果你在没有完整控制权的装置（例如，移动装置或嵌入式装置）上执行软体，则可能完全不能信任该装置的硬体时钟。一些使用者故意将其硬体时钟设定为不正确的日期和时间，例如，为了规避游戏中的时间限制，时钟可能会被设定到很远的过去或将来。
如果你足够在乎这件事并投入大量资源，就可以达到非常好的时钟精度。例如，针对金融机构的欧洲法规草案 MiFID II 要求所有高频率交易基金在 UTC 时间 100 微秒内同步时钟，以便除错 “闪崩” 等市场异常现象，并帮助检测市场操纵【51】。
透过 GPS 接收机，精确时间协议（PTP）【52】以及仔细的部署和监测可以实现这种精确度。然而，这需要很多努力和专业知识，而且有很多东西都会导致时钟同步错误。如果你的 NTP 守护程序配置错误，或者防火墙阻止了 NTP 通讯，由漂移引起的时钟误差可能很快就会变大。
### 依赖同步时钟
时钟的问题在于，虽然它们看起来简单易用，但却具有令人惊讶的缺陷：一天可能不会有精确的 86,400 秒，**日历时钟** 可能会前后跳跃，而一个节点上的时间可能与另一个节点上的时间完全不同。
本章早些时候，我们讨论了网路丢包和任意延迟包的问题。尽管网路在大多数情况下表现良好，但软体的设计必须假定网路偶尔会出现故障，而软体必须正常处理这些故障。时钟也是如此：尽管大多数时间都工作得很好，但需要准备健壮的软体来处理不正确的时钟。
有一部分问题是，不正确的时钟很容易被视而不见。如果一台机器的 CPU 出现故障或者网路配置错误，很可能根本无法工作，所以很快就会被注意和修复。另一方面，如果它的石英时钟有缺陷，或者它的 NTP 客户端配置错误，大部分事情似乎仍然可以正常工作，即使它的时钟逐渐偏离现实。如果某个软体依赖于精确同步的时钟，那么结果更可能是悄无声息的，仅有微量的资料丢失，而不是一次惊天动地的崩溃【53,54】。
因此，如果你使用需要同步时钟的软体，必须仔细监控所有机器之间的时钟偏移。时钟偏离其他时钟太远的节点应当被宣告死亡，并从丛集中移除。这样的监控可以确保你在损失发生之前注意到破损的时钟。
#### 有序事件的时间戳
让我们考虑一个特别的情况，一件很有诱惑但也很危险的事情：依赖时钟，在多个节点上对事件进行排序。例如，如果两个客户端写入分散式资料库，谁先到达？ 哪一个更近？
[图 8-3](../img/fig8-3.png) 显示了在具有多主复制的资料库中对时钟的危险使用（该例子类似于 [图 5-9](../img/fig5-9.png)）。客户端 A 在节点 1 上写入 `x = 1`；写入被复制到节点 3；客户端 B 在节点 3 上增加 x（我们现在有 `x = 2`）；最后这两个写入都被复制到节点 2。
![](../img/fig8-3.png)
**图 8-3 客户端 B 的写入比客户端 A 的写入要晚，但是 B 的写入具有较早的时间戳。**
在 [图 8-3](../img/fig8-3.png) 中，当一个写入被复制到其他节点时，它会根据发生写入的节点上的日历时钟标记一个时间戳。在这个例子中，时钟同步是非常好的：节点 1 和节点 3 之间的偏差小于 3ms，这可能比你在实践中能预期的更好。
尽管如此，[图 8-3](../img/fig8-3.png) 中的时间戳却无法正确排列事件：写入 `x = 1` 的时间戳为 42.004 秒，但写入 `x = 2` 的时间戳为 42.003 秒，即使 `x = 2` 在稍后出现。当节点 2 接收到这两个事件时，会错误地推断出 `x = 1` 是最近的值，而丢弃写入 `x = 2`。效果上表现为，客户端 B 的增量操作会丢失。
这种冲突解决策略被称为 **最后写入胜利（LWW）**，它在多主复制和无主资料库（如 Cassandra 【53】和 Riak 【54】）中被广泛使用（请参阅 “[最后写入胜利（丢弃并发写入）](ch5.md#最后写入胜利（丢弃并发写入）)” 一节）。有些实现会在客户端而不是伺服器上生成时间戳，但这并不能改变 LWW 的基本问题：
* 资料库写入可能会神秘地消失：具有滞后时钟的节点无法覆盖之前具有快速时钟的节点写入的值，直到节点之间的时钟偏差消逝【54,55】。此方案可能导致一定数量的资料被悄悄丢弃，而未向应用报告任何错误。
* LWW 无法区分 **高频顺序写入**（在 [图 8-3](../img/fig8-3.png) 中，客户端 B 的增量操作 **一定** 发生在客户端 A 的写入之后）和 **真正并发写入**（写入者意识不到其他写入者）。需要额外的因果关系跟踪机制（例如版本向量），以防止违背因果关系（请参阅 “[检测并发写入](ch5.md#检测并发写入)”）。
* 两个节点很可能独立地生成具有相同时间戳的写入，特别是在时钟仅具有毫秒解析度的情况下。为了解决这样的冲突，还需要一个额外的 **决胜值**（tiebreaker，可以简单地是一个大随机数），但这种方法也可能会导致违背因果关系【53】。
因此，尽管透过保留 “最近” 的值并放弃其他值来解决冲突是很诱惑人的，但是要注意，“最近” 的定义取决于本地的 **日历时钟**，这很可能是不正确的。即使用严格同步的 NTP 时钟，一个数据包也可能在时间戳 100 毫秒（根据传送者的时钟）时传送，并在时间戳 99 毫秒（根据接收者的时钟）处到达 —— 看起来好像资料包在传送之前已经到达，这是不可能的。
NTP 同步是否能足够准确，以至于这种不正确的排序不会发生？也许不能，因为 NTP 的同步精度本身，除了石英钟漂移这类误差源之外，还受到网路往返时间的限制。为了进行正确的排序，你需要一个比测量物件（即网路延迟）要精确得多的时钟。
所谓的 **逻辑时钟（logic clock）**【56,57】是基于递增计数器而不是振荡石英晶体，对于排序事件来说是更安全的选择（请参阅 “[检测并发写入](ch5.md#检测并发写入)”）。逻辑时钟不测量一天中的时间或经过的秒数，而仅测量事件的相对顺序（无论一个事件发生在另一个事件之前还是之后）。相反，用来测量实际经过时间的 **日历时钟** 和 **单调钟** 也被称为 **物理时钟（physical clock）**。我们将在 “[顺序保证](ch9.md#顺序保证)” 中来看顺序问题。
#### 时钟读数存在置信区间
你可能能够以微秒或甚至纳秒的精度读取机器的时钟。但即使可以得到如此细致的测量结果，这并不意味著这个值对于这样的精度实际上是准确的。实际上，大机率是不准确的 —— 如前所述，即使你每分钟与本地网路上的 NTP 伺服器进行同步，几毫秒的时间漂移也很容易在不精确的石英时钟上发生。使用公共网际网路上的 NTP 伺服器，最好的准确度可能达到几十毫秒，而且当网路拥塞时，误差可能会超过 100 毫秒【57】。
因此，将时钟读数视为一个时间点是没有意义的 —— 它更像是一段时间范围：例如，一个系统可能以 95% 的置信度认为当前时间处于本分钟内的第 10.3 秒和 10.5 秒之间，它可能没法比这更精确了【58】。如果我们只知道 ±100 毫秒的时间，那么时间戳中的微秒数字部分基本上是没有意义的。
不确定性界限可以根据你的时间源来计算。如果你的 GPS 接收器或原子（铯）时钟直接连线到你的计算机上，预期的错误范围由制造商告知。如果从伺服器获得时间，则不确定性取决于自上次与伺服器同步以来的石英钟漂移的期望值，加上 NTP 伺服器的不确定性，再加上到伺服器的网路往返时间（只是获取粗略近似值，并假设伺服器是可信的）。
不幸的是，大多数系统不公开这种不确定性：例如，当呼叫 `clock_gettime()` 时，返回值不会告诉你时间戳的预期错误，所以你不知道其置信区间是 5 毫秒还是 5 年。
一个有趣的例外是 Spanner 中的 Google TrueTime API 【41】，它明确地报告了本地时钟的置信区间。当你询问当前时间时，你会得到两个值：[最早，最晚]，这是最早可能的时间戳和最晚可能的时间戳。在不确定性估计的基础上，时钟知道当前的实际时间落在该区间内。区间的宽度取决于自从本地石英钟最后与更精确的时钟源同步以来已经过了多长时间。