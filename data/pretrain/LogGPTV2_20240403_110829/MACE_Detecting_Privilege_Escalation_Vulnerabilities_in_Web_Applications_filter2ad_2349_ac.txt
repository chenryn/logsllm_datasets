ble. This happens only when the corresponding INSERT query
for the same row (shown in Listing 2) inserts the userID in the
ﬁeld author_ID. This implicit form of “ownership” needs to be
captured by MACE in the authorization context. Thus, the relation-
ship between author_ID and userID that is implicit in the code
needs to become explicit. The tool captures this information as Au-
thorization Columns for each table. Each authorization column el-
ement captures the column name and the symbolic value used to
constrain the query. Returning to our running example, the autho-
rization columns for the table tbl_articles is: [author_ID
= $_SESSION[’userID’]]
Note that, in cases where the developer did not specify col-
umn names in INSERT queries, MACE uses DB schemas, which
are automatically generated by parsing database creation ﬁles
(CREATE TABLE queries) to mark the authorization columns.
For this purpose, MACE symbolically evaluates the source-to-
sink path that leads to the query so that the relationship between
the super-global variables that eventually reach the query becomes
explicit. Symbolically executing the path that leads to the ﬁrst
Algorithm 2: Analysis of INSERT Queries
input : List of queries and their authorization contexts
output: List of Tables, Tables’ authorization contexts, Tables’ authorization
columns
1 sortSymbolicQueries();
// based on Table names
2 foreach table t do
3
4
foreach ins-q 2 getInsertQueries(t) do
authzContexts(t)+=getAuthzContext(ins-q);
authzCols+=getAuthzColumns(ins-q);
diff := compare(authzContexts(t));
if diff then
raiseWarning(INSERT_Conﬂict);
if AuthzContext(t).size > 1 then
5
6
7
8
9
10
11
12
13 return authzCols, authzContexts;
if authzCols(t).size > 1 then
diff := compare(authzCols(t));
if diff then
raiseWarning(INSERT_AuthzColumn_Conﬂict);
DELETE query in Listing 3 makes this relationship explicit. For
instance, we obtain the following symbolic query for the above ex-
ample.
DELETE FROM tbl_articles WHERE article_id =
$_GET[’article_ID’] AND author_ID =
$_SESSION[’userID’];
Notice that the query is now entirely expressed in terms of sym-
bolic super-globals such as user inputs $_GET[’post_id’] and
$_SESSION[’userID’]. Having the symbolic query for each
query location allows us to compare similar accesses to the column
authorID in the DB, and compare the authorization contexts for
similar accesses to the same table.
In addition to identifying inconsistencies, the previous steps al-
low one to see if there is a possibility of privilege escalation due to
insecure use of user-supplied parameters in authorization decisions.
User supplied parameters such as $_COOKIE can be tampered, and
therefore authorization decisions must not refer to them. Having
a symbolic query that makes any such use explicit also facilitates
MACE to identify these types of errors. At the end of this step,
MACE outputs a set of symbolic queries. These queries contain
the resources (tables) and together with the authorization context
at each resource along every path that leads to the resource. The
speciﬁc type of access (INSERT, UPDATE, DELETE) is also
available through the symbolic query. As mention earlier, paths
that lead to SELECT queries or those that do not lead to sensitive
resources are discarded.
Context Comparison The goal of this step is to compare the au-
thorization context at each resource access and identify inconsis-
tencies. To this point, we have gathered two sets of information
with respect to authorization in previous steps: 1) the authorization
Algorithm 3: Analysis of DELETE Queries
input : authzCols, authzContexts
1 foreach table t do
2
foreach del-q 2 getDeleteQueries(t) do
// Compare Authorization Contexts
if getAuthzContext(del-q) == getAuthzContext(t) then
// Compare Authorization Cols
authzClause = getAuthz(getWhereClauseCols(del-q));
if authzClause != getAuthzColumns(t) then
raiseWarning(HORIZONTAL_ESC);
else if getRole(getAuthzContext(q)) < getRole(getAuthzContext(t))
then
raiseWarning(VERTICAL_ESC);
else
3
4
5
6
7
8
9
10
// Other inconsistencies may have various
authorization vulnerabilities
raiseWarning(INCONSISTENCY);
contexts for query locations and 2) the resource access parameters
(authorization columns) for each table.
The ﬁrst step in context comparison is to group the query-path
pairs based on the table names in the query (Line 1 in Algo-
rithm 2. During symbolic execution analysis done in the previ-
ous phases, we are able to resolve the table names for static and
dynamic queries in each possible sink-path pair. Then, for each ta-
ble, we gather the authorization context and authorization columns,
which are used in table accesses. The number of distinct authoriza-
tion contexts and authorization columns may be more than one,
for different queries in different program locations. Therefore, we
need to resolve these differences and in any case report these con-
ﬂicts. Lines 7-11 in Algorithm 2 compare the contexts for INSERT
queries on a given table. The discussion about the analysis of these
conﬂicts comes in Section 4.1. After ﬁnishing all INSERT queries,
we proceed to analyze DELETE and UPDATE queries. The reason
we start this way is because ownership information is added to the
resources at their creation time, in a DAC model, which is typical
of such applications. INSERT queries show us where the owner-
ship information comes from in the program and in which column
of the table they are going to be stored.
In the next step, to analyze the rest of the queries (i.e. DELETE
and UPDATE queries) we compare their authorization contexts
shown by 1) the resource accesses (where clauses in queries) and
2) the authorization context annotations, with the information we
gathered from INSERT queries. Algorithm 3 shows the analysis
of delete queries. The analysis of UPDATE queries is done in the
same way.
The data in database tables should be changed exclusively with a
privilege level equal or more than the level speciﬁed in their autho-
rization context so that the integrity of these tables remains intact.
Lines 9 and 10 in Algorithm 3 show how we check for vertical
privilege escalation vulnerabilities in our tool.
In addition to the authorization context, we check table access
parameters (lines 4-6 in Algorithm 3) to detect horizontal privilege
escalation vulnerabilities. These attacks happen in the same privi-
lege level as the legitimate users, however, a malicious insider can
manipulate the data stored in DB tables owned by other users. This
additional check of accesses tries to prevent such attacks.
Lines 12-15 in Algorithm 3 detect any other inconsistency in
the authorization contexts. These inconsistencies are also reported
back to the user for further analysis.
4.1 Conﬂicting Contexts
During the comparison phase, both for authorization contexts
and the resource access comparisons, there may be scenarios in
which the contexts or access parameters do not match entirely. In
these cases, the authorization context or WHERE clause with more
restrictions is viewed as the stronger context / clause. This is intu-
itive – quite often, the more restrictive the context, the more speciﬁc
(or precise) it is about the access rules regarding the resource being
referred to. Below, we discuss different conﬂict scenarios and how
MACE addresses these conﬂicts.
In the case of one INSERT query present in the application for
a given resource, we assume that the authorization information ex-
tracted from the query must be present in the authorization context
of further accesses (UPDATEs or DELETEs). In case of any conﬂict
after the comparison, if the authorization context of the INSERT
query is stronger than the other query’s context, we raise a warn-
ing. Depending on the missing element in the authorization 4-tuple,
the type of the warning may vary. A missing or weaker role infor-
mation is generally an indication of a vertical privilege escalation
vulnerability caused by the current privilege role level being less
than what was present in the INSERT query’s context. A miss-
ing user element in the context, while it was present at the time of
the insert, indicates a horizontal privilege escalation vulnerability.
Relying on user provided inputs (such as GET, POST or COOKIE
variables) in the 4-tuple is an indication of a general mismanage-
ment of sessions and authorization in the application.
4.2 Precision and minimizing warnings
MACE is a ‘best effort’ tool to detect missing or inconsistent au-
thorization information. It is based on the intuition that developers
aim to get most cases right, and some occasional cases wrong. In
the rare case that the developer gets none of the cases right, then
MACE’s approach cannot detect errors.
To have a more effective tool with a better conﬁdence rate, there
are a few general steps we took in order to improve the overall
precision and lower the false positive rate.
INSERT queries with missing authorizations So far, we set au-
thorization contexts in INSERT queries as the base for consistency
analysis. If an INSERT query misses some crucial authorization in-
formation, then our tool may not report faulty DELETE or UPDATE
queries (as long as they are consistent with the faulty INSERT),
causing possible false negatives.
User-controllable query parameters. There are some applica-
tions that permit user-controlled parameter (such as those of GET,
POST, COOKIE) values in authorization decisions. Since MACE
uses data ﬂow analysis, it is able to observe these incorrect autho-
rizations and reports them (we identify and report 10 such errors
in our evaluation). In such cases of vulnerabilities, MACE does
not further proceed to analyze the queries that are impacted by
these ﬂaws, so that the number of warnings reported by the tool
is minimized. After ﬁxing these vulnerabilities, the user can re-run
MACE to identify if there are still missing authorizations.
SELECT queries. Technically speaking, it is possible for MACE
to include SELECT queries and analyze them for inconsistencies,
as the analysis required to identify authorization for a SELECT
query (e.g.
dataﬂow analysis) is no different compared to an
INSERT. However, including SELECT queries is primarily a ques-
tion of the user’s tolerance of the signal / noise ratio for an policy-
agnostic tool such as MACE. To see this, let us consider an ex-
ample of a news article website. The news articles are publicly
viewable and so at the corresponding SELECT query there would
be no authorization information, whereas the users of the website
often have to authenticated and authorized to be able to post news
articles. Comparing such SELECT queries with INSERT queries
often will lead to false alarms. Therefore, in order to eliminate
such false alarms, a user might decide to omit analyzing SELECT
queries, as we did in the evaluation of MACE. Another choice that
Application
phpns 2.1.1alpha
DCPPortal 5.1.44
DNScript
myBloggie 2.1.3
miniBloggie 1.1
SCARF 1.0
WeBid 1.0.6
Table 2: PHP Applications
# query
Locs
40
308
27
24
5
13
687
SLOC
4224
89074
1322
6261
1283
978
27803
# php
ﬁles
30
362
60
59
11
19
266
# DB
tables
13
34
7
5
2
7
47
Analysis
time (s)
8220
982
35093
373
35
54
1492
Table 3: Overview of Vulnerabilities
# query conﬂicts
FP
TP
0
7
0
46
0
0
0
6
1
0
0
11
0
0
HPE
X
X
-
X
-
X
-
VPE
X
X
-
X
X
X
-
known,
unknown
0, 7
0, 46
-
3,3
1, 0
1, 10
-
Application
phpns
DCPPortal
DNScript
myBloggie
miniBloggie
SCARF
WeBid
a user has, which involves additional manual effort, is to provide
additional annotations that identify the tables that store sensitive
data (and therefore require authorization on SELECT queries).
4.3 Other Issues
Unsupported PHP features MACE is implemented for PHP, and
makes use of the Pixy [19] tool for control ﬂow analysis. A small
set of features in PHP language are not handled by Pixy and there-
fore MACE does not deal with them. For instance, dynamic in-
clusions and certain object-oriented features of PHP are not han-
dled entirely. However, these have not limited the applicability of
MACE to the application suite that used in our evaluation. Note
that, while MACE works in the context of PHP, which is widely
used, our technique (using authorization context differentials, sym-
bolic execution, dataﬂow analysis) is independent of any platform.
Counting the number of vulnerabilities. Many vulnerable
queries might be ﬁxed by a single common authorization check at a
shared program location. However, MACE treats each query loca-
tion as an independent operation and reports and counts vulnerable
queries separately. We prefer to do so because we think each of
the reported vulnerable queries might lead to a different instance
of attack. By treating the queries in isolation, we can identify the
vulnerability type with more precision. As we see in section 5, we
may report large number of vulnerable locations because of one
single missing authorization check, but in each such case of mul-
tiple vulnerabilities due to a single reason, we explicitly indicate
so.
5. Evaluation
Implementation MACE is designed to analyze PHP Web appli-
cations. MACE is implemented in Java and is about 10K lines of
code. We use an open-source tool and library (TAPS [9]) to get the
control ﬂow graphs and enumerate execution paths for PHP appli-
cations. The experiments described in this section were performed