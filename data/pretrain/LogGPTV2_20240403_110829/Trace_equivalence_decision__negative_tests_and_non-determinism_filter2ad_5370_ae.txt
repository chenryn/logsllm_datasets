only rule that can be applied, will result in the pairs:
     ﬂ∞ﬂ∞
   ﬂ∞
  ) are obtained from  (resp.  ) by adding the
 ﬂ∞
 (resp. ﬂ∞ﬂ∞
where ﬂ∞ﬂ∞
non-deducibility constraints:
  
 ﬂ∞ﬂ∞
 ﬂ∞ﬂ∞
  
‡¢´ ‡¢ò   
‡¢ß IA?  ‡¢¥ ‡¢ß   in ﬂ∞ﬂ∞
 ;
‡¢ß IA?  ‡¢¥ ‡¢ß   in ﬂ∞ﬂ∞
  .
‡¢´ ‡¢ò   IA? 
Note that no transformation rule is applicable on this pair. It
is easy to see that symbolic equivalence holds for the Ô¨Årst pair.
Actually, symbolic equivalence also holds on the second pair taking
into account the non-deducibility constraints. However, we do not
want to solve these non-deducibility constraints. Instead, we apply
DEST internally, obtaining one leaf of the form:
‚Äû 
ﬂ∞ﬂ∞
ﬂ∞
ﬂ∞ﬂ∞
¬´

¬´
‚Äû ﬂ∞
 ﬂ∞ﬂ∞
Then, on the leaves, we check that for each column of one matrix,
there exist a column in the other matrix on which the constaint sys-
tems have the same status, i.e.  or not. Here, this test will trivially
fail on our unique leaf allowing us to conclude that the two original
sets   and   are not in symbolic equivalence.
5.3 Strategy
Applying blindly the transformation rules does not always termi-
nate (see [11] for an example). As in [11], to avoid non-terminating
behaviors, we Ô¨Åx one of the constraint system, reduce it until reach-
ing a ‚Äúpre-solved form‚Äù (distinct variables in the right-hand sides
of the deducibility constraints), and then move to the next system.
Solving the second system does preserve the property on the Ô¨Årst
one. In this way we can reach constraint systems in ‚Äúpre-solved‚Äù
form.
This is not however sufÔ¨Åcient: because of the disequations, it
might be not so easy to decide the equivalence of such sets (or
matrices) of constraint systems (see Example 8). Therefore, we
further apply some transformation rules, that allow to simplify the
disequalities. For this second phase, we only need the rules CONS,
AXIOM, EQ-RIGHT-RIGHT. CONS is restricted to the situations in
EXAMPLE 12. We consider a constraint system in ‚Äúpre-solved‚Äù
form such that:
  
‡¢ß  ‡¢¥  
‡¢ß  ‡¢≥ 
‡¢ß    
For sake of simplicity, we do not described  and . We simply
assume that the frame contains the terms  and . First, we apply
‡¢ß  ‡¢≥
AXIOM on   (with ), on one branch we will obtain 
‡¢ß
‡¢ß . Lastly, applying
‡¢ß   . Then, applying CONS twice, we obtain 

   ! ‡¢≥ 
‡¢ß  ‡¢¥  
AXIOM on ! (with ), we obtain
‡¢ß  ‡¢¥ !
‡¢ß  ‡¢¥  
getting back to the original set of disequations.
‡¢ß     ‡¢≥ 

‡¢ß 
We therefore use the following strategy:
CONS  EQ-RIGHT-RIGHT AXIOM
where the exclamation mark means ‚Äúas long as possible‚Äù. This
allows us in particular to avoid the non-terminating behavior de-
scribed in Example 12. Now, we claim that irreducible constraints
contain only disequations  ‡¢ß  where  does not contain names
or universally quantiÔ¨Åed variables and that the transformations are
terminating.
The termination argument is as follows: EQ-RIGHT-RIGHT al-
lows to ‚Äúexternalize‚Äù the disjunctions, splitting disjunctive con-
straints, each of which will appear in different matrices. Then,
CONS will allow to decrease the heights of names and universally
quantiÔ¨Åed variables. Finally, these measures may increase with
AXIOM, but then the replacement substitutes a variable with sup-
port  with terms that only contain variables, whose support is
strictly smaller than . Furthermore, all these rules will keep the
deducibility constraints in pre-solved form.
5.4 Correctness
The transformation rules yield a Ô¨Ånite tree labeled with pairs
of matrices of constraint systems. As brieÔ¨Çy explained in Exam-
ple 11, our test on the leaves consists of checking that for each
column in one matrix, there exists a column in the other matrix
such that each constraint system has the same status. We say that
A=B6AIJ ﬂ∞  JHKA when this syntaxic test holds on the leaf
 ﬂ∞. Otherwise, we say that A=B6AIJ ﬂ∞  B=IA.
PROPOSITION 2. Let  ﬂ∞
 be a pair of sets of constraint
systems obtained by applying our transformation 6H on sets of
initial constraint systems, and consider a binary tree obtained by
following the strategy described in Section 5.3.
‡¢´ soundness: If all leaves of a tree are labeled with  ﬂ∞
such that A=B6AIJ ﬂ∞  JHKA, then  ‡£à ﬂ∞
.
‡¢´ completeness: If  ‡£à ﬂ∞
labeled with  ﬂ∞ with A=B6AIJ ﬂ∞  JHKA.
, then all leaves of a tree are
The idea of the proof is to Ô¨Årst analyse the structure of the leaves
and then to show that our notion of equivalence is preserved through
application of our transformation rules: for any transformation rule,
if the two pairs of sets of constraint systems labeling the sons of a
node are respectively in symbolic equivalence, then the same prop-
erty holds for the father.
6. CONCLUSION
An Ocaml implementation of an early version of the procedure
described in this paper has already been completed. This procedure
extends [13] to set of constraints, including disequalities. Actually,
checking symbolic equivalence between sets of constraint systems
is quite efÔ¨Åcient. However, the interleaving step, that is required
for moving from symbolic equivalence to trace equivalence, is per-
formed in a naive way and it appears that this step is expensive
from the computation point of view. We tested this implementation
on the private authentication protocol and the two versions of the
e-passport protocol. Our implementation concludes within a few
minutes for the private authentication protocol and the Ô¨Çawed ver-
sion of the e-passport protocol (considering 2 sessions only). We
also tried our implementation on the Ô¨Åxed version of the e-passport
and it took more time (around 2 days).
In order to get an efÔ¨Åcient procedure, it is necessary to come
with some optimisations to reduce the search space and the num-
ber of interleavings. This problem is not speciÔ¨Åc to trace equiva-
lence and has already been studied in the context of trace properties
(e.g. [22]). However, discarding some ‚Äúsymbolic‚Äù interleavings ap-
pears to be challenging for equivalence-based properties. Finally,
we would like to extend the method to other cryptographic primi-
tives, typically blind signatures and zero-knowledge proofs.
7. REFERENCES
[1] M. Abadi and V. Cortier. Deciding knowledge in security
protocols under equational theories. Theoretical Computer
Science, 387(1-2):2‚Äì32, 2006.
[2] M. Abadi and C. Fournet. Mobile values, new names, and
secure communication. In Proc. 28th Symposium on
Principles of Programming Languages (POPL‚Äô01), pages
104‚Äì115. ACM Press, 2001.
[3] M. Abadi and C. Fournet. Private authentication. Theoretical
Computer Science, 322(3):427‚Äì476, 2004.
[4] M. Abadi and A. Gordon. A calculus for cryptographic
protocols: The spi calculus. In Proc. 4th Conference on
Computer and Communications Security (CCS‚Äô97), pages
36‚Äì47. ACM Press, 1997.
[5] M. Arapinis, T. Chothia, E. Ritter, and M. Ryan. Analysing
unlinkability and anonymity using the applied pi calculus. In
Proc. of 23rd IEEE Computer Security Foundations
Symposium (CSF‚Äô10), pages 107‚Äì121. IEEE Computer
Society Press, 2010.
[6] A. Armando et al. The AVISPA Tool for the automated
validation of internet security protocols and applications. In
Proc. 17th Int. Conference on Computer Aided VeriÔ¨Åcation
(CAV‚Äô05), volume 3576 of LNCS, pages 281‚Äì285. Springer,
2005.
[7] M. Baudet. Deciding security of protocols against off-line
guessing attacks. In Proc. 12th Conference on Computer and
Communications Security (CCS‚Äô05), pages 16‚Äì25. ACM
Press, 2005.
[8] M. Baudet. S√©curit√© des protocoles cryptographiques :
aspects logiques et calculatoires. Phd thesis, √âcole Normale
Sup√©rieure de Cachan, France, 2007.
[9] B. Blanchet. An EfÔ¨Åcient Cryptographic Protocol VeriÔ¨Åer
Based on Prolog Rules. In Proc. 14th Computer Security
Foundations Workshop (CSFW‚Äô01), pages 82‚Äì96. IEEE
Comp. Soc. Press, 2001.
[10] B. Blanchet, M. Abadi, and C. Fournet. Automated
veriÔ¨Åcation of selected equivalences for security protocols.
Journal of Logic and Algebraic Programming, 75(1):3‚Äì51,
2008.
[11] V. Cheval, H. Comon-Lundh, and S. Delaune. Automating
security analysis: symbolic equivalence of constraint
systems. In Proc. 5th International Joint Conference on
Automated Reasoning (IJCAR‚Äô10), volume 6173 of LNAI,
pages 412‚Äì426. Springer-Verlag, 2010.
[12] Y. Chevalier and M. Rusinowitch. Decidability of symbolic
equivalence of derivations. Journal of Automated Reasoning,
2011. To appear.
[13] H. Comon-Lundh and S. Delaune. The Ô¨Ånite variant
property: How to get rid of some algebraic properties. In
Proc. 16th International Conference on Rewriting
Techniques and Applications (RTA‚Äô05), LNCS, pages
294‚Äì307. Springer, 2005.
[14] V. Cortier and S. Delaune. A method for proving
observational equivalence. In Proc. 22nd Computer Security
Foundations Symposium (CSF‚Äô09), pages 266‚Äì276. IEEE
Comp. Soc. Press, 2009.
[15] S. Delaune, S. Kremer, and M. D. Ryan. Symbolic
bisimulation for the applied pi-calculus. In Proc. 27th
Conference on Foundations of Software Technology and
Theoretical Computer Science (FSTTCS‚Äô07), pages 133‚Äì145,
2007.
[16] S. Delaune, S. Kremer, and M. D. Ryan. Verifying
privacy-type properties of electronic voting protocols.
Journal of Computer Security, 17(4):435‚Äì487, July 2009.
[17] D. Dolev and A. C. Yao. On the security of public key
protocols. In Proc. 22nd Symposium on Foundations of
Computer Science (FCS‚Äô81), pages 350‚Äì357. IEEE
Computer Society Press, 1981.
[18] L. Durante, R. Sisto, and A. Valenzano. Automatic testing
equivalence veriÔ¨Åcation of spi calculus speciÔ¨Åcations. ACM
Transactions on Software Engineering and Methodology,
12(2):222‚Äì284, 2003.
[19] N. Durgin, P. Lincoln, J. Mitchell, and A. Scedrov.
Undecidability of bounded security protocols. In Workshop
on Formal Methods and Security Protocols, 1999.
[20] H. H√ºttel. Deciding framed bisimulation. In Proc. 4th Int.
Workshop on VeriÔ¨Åcation of InÔ¨Ånite State Systems
(INFINITY‚Äô02), pages 1‚Äì20, 2002.
[21] J. Millen and V. Shmatikov. Constraint solving for
bounded-process cryptographic protocol analysis. In Proc.
8th ACM Conference on Computer and Communications
Security (CCS‚Äô01). ACM Press, 2001.
[22] S. M√∂dersheim, L. Vigan√≤, and D. A. Basin. Constraint
differentiation: Search-space reduction for the
constraint-based analysis of security protocols. Journal of
Computer Security, 18(4):575‚Äì618, 2010.
[23] R. Ramanujam and S. Suresh. Tagging makes secrecy
decidable for unbounded nonces as well. In Proc. 23rd
Conference on Foundations of Software Technology and
Theoretical Computer Science (FSTTCS‚Äô03), 2003.
[24] M. Rusinowitch and M. Turuani. Protocol insecurity with
Ô¨Ånite number of sessions is NP-complete. In Proc. 14th
Computer Security Foundations Workshop (CSFW‚Äô01),
pages 174‚Äì190. IEEE Comp. Soc. Press, 2001.
[25] A. Tiu and J. E. Dawson. Automating open bisimulation
checking for the spi calculus. In Proc. 23rd IEEE Computer
Security Foundations Symposium (CSF‚Äô10), pages 307‚Äì321.
IEEE Computer Society Press, 2010.