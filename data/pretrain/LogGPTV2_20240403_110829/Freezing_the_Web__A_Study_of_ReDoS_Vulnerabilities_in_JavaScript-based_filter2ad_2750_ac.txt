### Figure 5: Modules with at least one previously unknown vulnerability

The latest release of the package includes a variety of modules, each with differing numbers of dependencies and downloads. However, it is evident that ReDoS (Regular Expression Denial of Service) vulnerabilities are present even in highly popular packages.

Given the potential damage these vulnerabilities can cause, we have taken significant steps to disclose them responsibly. For each identified vulnerability, we contacted the developers directly or through the Node Security Platform. We provided them with several months to address the issues before making the information public. As of now, 14 out of the 25 vulnerabilities have been fixed and are listed as advisories on the Node Security Platform. For the remaining vulnerabilities, some developers are still in the process of fixing them, while others have left the task to the community. The complete list of vulnerabilities, along with their current status, is available for reviewers. [Link to the list](https://docs.google.com/spreadsheets/d/1rnR8zsXeA1eccrpxeZK0_LtQOlc8j_u60IR7nnVQgbE/edit?usp=sharing).

### Section 3.3: Exploit Creation and Testing

As detailed in Section 3.3, we attempted to create exploits for the identified vulnerabilities by hypothesizing how web server implementations might use the vulnerable modules. Figure 6 illustrates the modules and usage scenarios where we successfully created an exploit. In all scenarios, we assumed the payload would be sent using a specific HTTP header. We believe that HTTP bodies, UDP packets, or WebSocket messages could also be used for similar purposes. The last column of Figure 6 provides the JavaScript implementation of the usage scenario, which we tested on our local server.

### Figure 6: Vulnerable Regular Expressions and Usage Scenarios

| ID | Module | Vulnerable Reg. Expr. | Header | Usage Scenario | JavaScript Example |
|----|--------|----------------------|--------|---------------|--------------------|
| 1  | charset | `/ (? : charset | e n c o d i n g ) \ s *=\s * [ â€™" ] ? *( [ \ w \ - ] +) / i` | Content-Type | The website uses this package to parse the content type of every request. | `require("charset")(req.headers);` |
| 2  | content | `/ ^( [ ^\/ ] +\/ [ ^\ s ; ] +)(? : (?: \ s *;\ s * b o u n d a r y =(? : "( [ ^" ] +)"|( [ ^;" ] +))) | (?: \ s *;\ s * [ ^= ] +=(? : (?: "(?: [ ^" ] +)") | (?: [ ^;" ] +))))* $ / i` | Content-Type | The website uses this package to parse the content type of every request. | `var content = require("content"); content.type(req.headers["content-type"]);` |
| 3  | fresh   | `/ * , * /` | If-None-Match | The website uses express, which by default uses this package to check the freshness of every request. | `var fresh = require("fresh"); fresh(req.headers);` |
| 4  | forwarded | `/ * , * /` | X-Forwarded-For | The website uses express and the "trust proxy" option is set. This package is then used to check which proxies a request came through. | `var forwarded = require("forwarded"); var addrs = forwarded(req);` |
| 5  | mobile-detect | `new RegExp("Dell.*Streak|Dell.*Aero|Dell.*Venue|DELL.*Venue Pro|Dell Flash|Dell Smoke|Dell Mini 3iX|XCD28|XCD35|\\b001DL\\b|\\b101DL\\b|\\bGS01\\b")` | User-Agent | The website uses this package to get information about the requester. | `var MobileDetect = require("mobile-detect"); var headers = req.headers["user-agent"]; var md = new MobileDetect(headers); md.phone();` |
| 6  | platform | `/ ^ +| + $ / g` | User-Agent | The website uses this package to get information about the requester. | `var platform = require("platform"); var headers = req.headers["user-agent"]; var agent = platform.parse(headers);` |
| 7  | ua-parser-js | `/ ip[honead]+(? : .*os\s([w]*)*\slike\smac|;opera) /` | User-Agent | The website uses this package to get information about the requester. | `var useragent = require("ua-parser-js"); var headers = req.headers["user-agent"]; var agent = useragent.parse(headers);` |
| 8  | useragent | `/ ((?:[A-z0-9]+|[A-z\-]+?)?(?:the)?(?:[Ss][Pp][Ii][Dd][Ee][Rr]|[Ss]crape|[A-Za-z0-9-]*(?:[^C][^Uu])[Bb]ot|[Cc][Rr][Aa][Ww][Ll])[A-z0-9]*)(?:(?:[/]|v)(\d+)(?:\.(\d+)(?:\.(\d+))?)?)?/` | User-Agent | The website uses this package to get information about the requester. | `var useragent = require("useragent"); var headers = req.headers["user-agent"]; var agent = useragent.parse(headers);` |

Most of the scenarios and their implementations are relatively simple, indicating that an attacker following a similar methodology could create effective exploits with minimal effort. For more targeted attacks, more complex scenarios involving multiple HTTP requests and domain-specific knowledge may be necessary. For example, the `marked` package, which provides a parser for the markdown format, could be exploited by crafting a specific markdown document to block the main loop for hours. However, deploying such an exploit requires in-depth analysis of the target website. Future work will explore these more complex scenarios. In this study, we focus on simple usage scenarios that can be triggered with a single HTTP request to the main page.

### Figure 7: Matching Time for Different Input Sizes

We measured the impact of input size on the matching time of the vulnerable expressions (Figure 7). For most exploits, the input dependency appears to be quadratic, reaching a one-second matching time within 20,000 to 40,000 characters. Two exploits show an exponential input dependency, reaching one-second matching time with fewer than 1,000 characters. All eight exploits are considered harmful due to their potential to impact website availability (Section 4.3) and assist in mounting DoS attacks (Section 5.1).

To further illustrate the effectiveness of crafted inputs, we measured the matching time for each vulnerable module with randomly generated inputs. Random string inputs of the same size as our crafted exploits resulted in much lower matching times, with a maximum of 20 milliseconds for inputs with 100,000 characters. This suggests that crafting inputs for vulnerable regular expressions is significantly more effective from an attacker's perspective than launching a brute-force DoS attack with random inputs.

### Section 4.3: Availability

We demonstrate the direct impact of regular expression matching time on web server availability. To illustrate the threat posed by ReDoS exploits, we created a simple Express application with two features: it responds with a "hello world" message when called at the "/echo" path and calls the `forwarded` module with the request headers when called at the "/redos" path. We chose this module because it appears to be the least harmful in our set of exploits, thus underestimating the negative impact on availability. We deployed this application on a machine running Node.js, provided by a commercial cloud platform [Heroku](http://heroku.com).

We set up two additional machines to concurrently send requests. One machine, called the victim, measures the time it takes to trigger 100 "hello world" requests, sending the next request only after receiving a response. The other machine, called the attacker, delivers 1,000 ReDoS payloads by triggering all 1,000 requests simultaneously. The victim machine starts its requests immediately after the attacker machine has triggered its requests.

We varied the payload size from 0 characters to 8,000 characters in increments of 1,000 characters. A zero-sized payload represents a request with an empty header, used to test if a Node.js server can be blocked using a brute-force strategy. The upper limit for the payload size was chosen based on the web server provider's default limit of 8,500 characters for header fields, although other hosting providers allow significantly larger headers.

Figure 8 shows the response times measured at the victim machine for the first 25 "/echo" requests. Payloads smaller than 4,000 characters had no significant effect on the response time. In contrast, payloads larger than 4,000 characters delayed up to eight requests with a maximum delay of 20 seconds. By increasing the payload size, an attacker can control both the number of delayed requests and their duration. For the largest payloads, we even observed request drops.

This result is particularly noteworthy because an individual payload of 4,000 characters does not take a long time to respond to. We separately measured the CPU time required to respond to one such request, finding it to take only 5.73 milliseconds on average. However, multiple requests together can delay the victim's request by up to 20 seconds, highlighting the cumulative impact of ReDoS attacks.

### Figures 9 and 10: Correlation and Payload Size

Figures 9 and 10 provide further details on the correlation between server computation time and request response time, as well as the number of characters needed to achieve specific delays in each vulnerable module. These figures underscore the importance of addressing ReDoS vulnerabilities to ensure the availability and security of web applications.