44,246
10,599
Figure 5: Modules with at least one previously unknown
vulnerability.
the latest release of the package. The packages vary in
the number of dependencies and downloads, but we can
safely conclude that ReDoS vulnerabilities are present
even in very popular packages.
Given the amount of possible damage entailed by the
vulnerabilities, we have invested signiﬁcant efforts to
disclose them in a responsible way. For each vulnera-
bility, we have contacted the developers either directly
or through the Node Security Platform6, and gave them
several months to ﬁx the problem before making it pub-
lic. 14 of the 25 have been ﬁxed by now and are listed as
advisories on the Node Security Platform. For the oth-
ers, the developers are either still in the process of ﬁxing
or decided to leave the task of ﬁxing to the community.
The complete list of vulnerabilities, along with details on
their current status is available for the reviewers.7
As explained in Section 3.3, we try to create exploits
for the vulnerabilities by hypothesizing how web server
implementations may use the vulnerable modules. Fig-
ure 6 shows the modules and usage scenarios for which
we could create an exploit. For all the scenarios we as-
sume the payload is sent using a speciﬁc HTTP header.
We believe that HTTP bodies, UDP packages or Web-
Socket messages can also be used for the same purpose.
The last column of Figure 6 shows the JavaScript imple-
mentation of the usage scenario. We run this implemen-
tation on our local server to experiment with the exploit.
6https://nodesecurity.io/advisories
7Following this link may de-anonymize the authors: https://
docs.google.com/spreadsheets/d/1rnR8zsXeA1eccrpxeZK0_
LtQOlc8j_u60IR7nnVQgbE/edit?usp=sharing
366    27th USENIX Security Symposium
USENIX Association
ID Module
Vuln. reg. expr.
Header
Usage scenario
JavaScript example
1 charset
/ (? : charset | e n c o d i n g )
\ s *=\ s * [ ’" ] ? *( [ \ w \ - ] +) / i
2 content
/ ^( [ ^\/ ] +\/ [ ^\ s ; ] +)(? : (?
: \ s *;\ s * b o u n d a r y =(? :
"( [ ^" ] +)"|( [ ^;" ] +)))|
(? : \ s *;\ s * [ ^= ] +=(? : (? : "
(? : [ ^" ] +)")|(? : [ ^;" ]
+))))* $ / i
3 fresh
/ * , * /
4 forwarded / * , * /
Content-
Type
The website uses
this
package to parse the con-
tent type of every request.
require ( " charset " )( req . headers );
var content = require ( " content " );
content . type (
req . headers [ " c o n t e n t - t y p e " ] );
var fresh = require ( " fresh " );
fresh ( req . headers );
var f o r w a r d e d = require ( " f o r w a r d e d " );
var addrs = f o r w a r d e d ( req );
Content-
Type
If-None-
Match
X-
Forwarded-
For
website
The website uses
this
package to parse the con-
tent type of every request.
The
uses
express,
by
default uses this package
to check the freshness of
every request.
The
uses
express and the “trust
proxy” option is set. This
package is then used to
check which proxies a
request came through.
which
website
5 mobile-
detect
new RegExp ( " Dell . * Streak |
Dell . * Aero | Dell . * Venue |
DELL . * Venue Pro | Dell Flash |
Dell Smoke | Dell Mini 3 iX |
XCD28 | XCD35 |\\ b001DL \\ b |
\\ b101DL \\ b |\\ bGS01 \\ b " )
6 platform / ^ +| + $ / g
7 ua-parser-
js
/ ip [ honead ] +(? : . * os \ s
( [ \ w ] +)*\ slike \ smac |;
\ sopera ) /
8 useragent
/ ((? : [ A-z0-9 ] +| [ A-z \ - ] + ?)?
(? : the )?(? : [ Ss ] [ Pp ] [ Ii ]
[ Dd ] [ Ee ] [ Rr ] | [ Ss ] crape |
[ A - Z a - z 0 - 9 - ] *(? : [ ^ C ] [ ^ Uu ] )
[ Bb ] ot | [ Cc ] [ Rr ] [ Aa ] [ Ww ]
[ Ll ] ) [ A-z0-9 ] *)(? : (? :
[ \/ ] | v )(\ d +)(? : \ . (\ d +)
(? : \ . (\ d + ) ) ? ) ? ) ? /
User-
Agent
User-
Agent
User-
Agent
User-
Agent
The website uses
this
package to get informa-
tion about the requester.
The website uses
this
package to get informa-
tion about the requester.
The website uses
this
package to get informa-
tion about the requester.
var M o b i l e D e t e c t =
require ( " m o b i l e - d e t e c t " );
var headers =
req . headers [ " u s e r - a g e n t " ] ;
var md = new M o b i l e D e t e c t ( headers );
md . phone ();
var p l a t f o r m = require ( " p l a t f o r m " );
var headers =
req . headers [ " u s e r - a g e n t " ] ;
var agent = p l a t f o r m . parse ( headers );
var u s e r a g e n t =
require ( " u a - p a r s e r - j s " );
var headers =
req . headers [ " u s e r - a g e n t " ]
var agent = u s e r a g e n t . parse ( headers );
The website uses
this
package to get informa-
tion about the requester.
var u s e r a g e n t = require ( " u s e r a g e n t " );
var headers =
req . headers [ " u s e r - a g e n t " ] ;
var agent =
u s e r a g e n t . parse ( headers );
Figure 6: Vulnerable regular expressions and usage scenarios we hypothesize the vulnerable modules to be involved
in.
Most of the scenarios and their implementations are
relatively simple. This simplicity shows that an attacker
that follows a methodology similar to ours could create
exploits that might work for a wide range of websites
with relatively little effort. For an attack targeted at a
speciﬁc website, we believe that more complex scenar-
ios could be built, e.g., involving multiple HTTP requests
and domain knowledge. For example, the marked pack-
age provides a parser for the markdown format. By craft-
ing a speciﬁc markdown document, an attacker can block
the main loop for hours. However, to deploy the exploit,
complex interactions with the server are needed. That is,
the attacker needs to ﬁgure out which part of the website
may use a markdown parser and how to provide a doc-
ument that will be processed by the parser. We believe
that such a scenario is realistic, but it requires an in-depth
analysis of each website. We leave for future work to test
this hypothesis. In this work, our goal is to assess the
effect of exploits that can be deployed at a large scale.
Therefore, we only consider very simple usage scenarios
that can be triggered with a single HTTP request made to
the main page.
To better understand the vulnerabilities, Figure 6
shows for each vulnerable module the vulnerable regu-
lar expressions. Some of the expressions are non-trivial,
making it hard for developers to focus on possible Re-
DoS attacks in addition to the correctness of the reg-
ular expression. Four of these regular expressions can
be successfully identiﬁed by a recent approach proposed
by W¨ustholz et al. [43], which targets Java applications,
though. The remaining four regular expressions cannot
be detected by their approach due to differences between
the regular expression semantics of Java and JavaScript.
USENIX Association
27th USENIX Security Symposium    367
Figure 7: Matching time for different input sizes.
4.2 Matching Time
We use the exploits to measure the inﬂuence of the size of
the input to the matching time of the vulnerable expres-
sion (Figure 7). For most of the exploits, the input depen-
dency seem to be quadratic, reaching one second match-
ing time within 20,000 to 40,000 characters. For two
exploits, the input dependency is presumably exponen-
tial, reaching one second matching time with less than
1,000 characters. We consider any of these eight exploits
to be harmful because they may impact a website’s avail-
ability (Section 4.3 and because even a non-exponential
ReDoS vulnerability may aid an attacker in mounting a
DoS attack (Section 5.1).
To further illustrate the effectiveness of inputs crafted
for a speciﬁc regular expression, we measure the match-
ing time for each vulnerable module with randomly cre-
ated inputs.
It turns out that random string inputs of
the same size as our crafted exploits cause much lower
matching times. The maximum matching time across the
eight attacks is 20 milliseconds for inputs with 100,000
characters. We conclude that crafting inputs for vulner-
able regular expressions is signiﬁcantly more effective,
from an attacker’s perspective, than launching a brute-
force DoS attack with randomly created inputs.
4.3 Availability
We now show that the matching time of a regular ex-
pression has a direct impact on the availability of a web
server. To show the threat to availability posed by ReDoS
exploits, we create a simple Express application with two
features: it replies with a ”hello world” message when
called at the ”/echo” path, and it calls the forwarded
module with the request headers when called at the ”/re-
dos” path. We choose this module because it appears in
Figure 7 to be the least harmful in our set of exploits, i.e.,
we are underestimating the negative impact on availabil-
ity. We then upload this simple application on a machine
Figure 8:
Impact of differently sized payloads on a
server’s response time. Note the logarithmic y-scale.
Payloads are plotted in increments of 1,000 characters.
running Node.js, provided by a commercial cloud plat-
form8.
We set up two other machines to concurrently send
request. One machine, called the victim, measures the
time it takes to trigger 100 requests of the ”hello world”
message. This victim machine triggers the next request
once the previous request has been responded to. At the
same time, the other machine, called the attacker, deliv-
ers 1,000 ReDoS payloads, by triggering all 1,000 re-
quests at once. The victim machine starts its requests
immediately after the victim machine has triggered its
requests.
We vary the payload size from 0 characters to 8,000
characters in increments of 1,000 characters. A zero-
sized payload is a request with an empty header instead
of one that exploits the ReDoS vulnerability. We con-
sider the zero-sized payload to check whether a Node.js
server can be blocked using a brute-force strategy. We
chose the upper limit for the payload size because, by de-
fault, the web server provider limits the size of the header
ﬁelds to 8,500 characters. Other hosting providers allow
signiﬁcantly larger headers, as we report later in this sec-
tion.
Figure 8 shows the response times measured at the vic-
tim machine for the ﬁrst 25 ”/echo” requests. Payloads
smaller than 4,000 characters have no signiﬁcant effect
on the response time of the server. In contrast, payloads
larger than this value delay as many as eight requests
with a maximum delay of 20 seconds. By increasing the
size of payloads, an attacker can control both the number
of requests we delay and their duration. For the largest
payloads we use, we even experienced dropping of re-
quests.
This result is particularly remarkable because an indi-
vidual payload of size 4,000 does not require an immense
amount of time to respond to. We separately measured
the CPU time required to respond to one such request
8http://heroku.com
368    27th USENIX Security Symposium
USENIX Association
 0 500 1000 1500 2000 0 10000 20000 30000 40000 50000 60000 70000Matching time (ms)Input size (number of characters)charsetfreshforwardedcontentmobile-detectplatformua-parser-jsuseragent101001,00010,000 0 5 10 15 20 25Response time (ms), log. scaleRequest number010002000300040005000600070008000Module
P2:
200ms
17,000
17,000
650
39
15,500
11,000
15,500
11,000
P3:
500ms
27,000
26,500
925
40
25,000
17,500
24,000
18,000
P1:
100ms
12,000
12,000
500
38
10,500
7,500
10,500
8,000
P5:
2s
fresh
53,500
forwarded
53,500
useragent
1,450
ua-parser-js
42
mobile-detect
50,500
platform
34,500
charset
48,000
content
35,500
Figure 10: Number of characters in each payload needed
to achieve a speciﬁc delay in a vulnerable module.
P4:
1s
37,500
38,000
1,150
41
36,500
25,000
34,000
25,500
Figure 9: Correlation between server computation time
and request response time.
and ﬁnd it to take only 5.73 milliseconds, on average.
However, several requests together can delay the victim’s
request by up to 20 seconds. This ﬁnding shows that