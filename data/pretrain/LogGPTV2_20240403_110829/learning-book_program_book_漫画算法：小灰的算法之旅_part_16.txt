的缓存。
假设链表的节点数量为n，则该解法的时间复杂度是0(m）。由于使用了
额外的存储空间，所以算法的空间复杂度同样是0(m)。
---
## Page 274
OK，这种方法在时间上已经是最优了。
有没有可能在空间上也得到优化？
哦，让我想想啊...
想不出来啊，怎么能让时间复杂度不
变，同时让空间复杂度降低呢？
呵呵，没关系，今天就到这里，你回家
---
## Page 275
等通知吧。
面试官说让回家等通知，
多半是面试“挂”了的意
思吧？想不到我的第一次
面试就这样结束了….
5.2.2
解题思路
小灰，你刚刚去面试了？结果怎么
样？
---
## Page 276
大黄，你给我讲讲呗，怎么能够
更高效地判断一个链表是否有环呀？
哈哈，小灰，有环链表的判断问题是
很基础的算法题，许多面试官都喜欢考查，你必须要掌握哦！
对于这道题，有一个很巧妙的方法，
这个方法利用了两个指针。
方法3：
首先创建两个指针p1和p2（在Java里就是两个对象引用），让它们同时
指向这个链表的头节点。然后开始一个大循环，在循环体中，让指针p1
每次向后移动1个节点，让指针p2每次向后移动2个节点，然后比较两个
指针指向的节点是否相同。如果相同，则可以判断出链表有环，如果不
同，则继续下一次循环。
---
## Page 277
第1步，p1和p2都指向节点5。
P1P2
第2步，p1指向节点3，p2指向节点7。
P1
P2
第3步，p1指向节点7，p2指向节点6。
P1
P2
---
## Page 278
第4步，p1指向节点2，p2指向节点1。
P2
P1
第5步，p1指向节点6，p2也指向节点6，p1和p2所指相同，说明链表有
环。
3
6
=P2
P1
学过小学奥数的读者，一定听说过数学上的追及问题。此方法就类似于
一个追及问题。
在一个环形跑道上，两个运动员从同一地点起跑，一个运动员速度快，
另一个运动员速度慢。当两人跑了一段时间后，速度快的运动员必然会
再次追上并超过速度慢的运动员，原因很简单，因为跑道是环形的。
假设链表的节点数量为n，则该算法的时间复杂度为O(n)。除两个指针
外，没有使用任何额外的存储空间，所以空间复杂度是O(1)。
---
## Page 279
那么，这个算法用代码怎么实现
呢？
代码实现很简单，让我们来看一下。
1./**
2.*判断是否有环
3.*@paramhead链表头节点
4.
*/
5. public static boolean isCycle(Node head) {
6.
Node p1 = head;
7.
Node p2= head;
8.
while (p2!=null && p2.next!=null){
9.
p1 = p1.next;
10.
p2 = p2.next.next;
11.
if(p1 == p2){
12.
return true;
---
## Page 280
13.
14.
15.
return false;
16.}
17.
18.
/ **
19.
链表节点
20.
* /
21.
private static class Node {
22.
int data;
23.
Node next;
24.
Node(int data){
25.
this.data = data;
26.
{
27.}
28.
29. public static void main(String[] args) throws Exception {
30.
Node node1 = new Node(5);
31.
Node node2 = new Node(3);
32.
Node node3 = new Node(7);
33.
Node node4 = new Node(2);
34.
Node node5 = new Node(6);
35.
node1.next = node2;
36.
node2.next = node3;
---
## Page 281
37.
node3.next = node4;
38.
node4.next = node5;
39.
node5.next = node2;
40.
41.
System.out.println(isCycle(node1));
42.}
明白了，这真是个好方法！
5.2.3
问题扩展
这个题目其实还可以扩展出许多有意
思的问题，例如下面这些。
扩展问题1：
如果链表有环，如何求出环的长度？
---
## Page 282
8
5
2
6
环长=4
扩展问题2：
如果链表有环，如何求出入环节点？
8
哎呀，这两个问题怎么解呢？
第1个问题求环长，非常简单，解法
---
## Page 283
如下。
当两个指针首次相遇，证明链表有环的时候，让两个指针从相遇点继续
循环前进，并统计前进的循环次数，直到两个指针第2次相遇。此时，
统计出来的前进次数就是环长。
因为指针p1每次走1步，指针p2每次走2步，两者的速度差是1步。当两
个指针再次相遇时，p2比p1多走了整整1圈。
因此，环长=每一次速度差×前进次数=前进次数。
第2个问题是求入环点，有些难度，
我们可以做一个抽象的推断。
首次相遇点
D
入环点
上图是对有环链表所做的一个抽象示意图。假设从链表头节点到入环点
的距离是D，从入环点到两个指针首次相遇点的距离是S：，从首次相遇
点回到入环点的距离是S²。
那么，当两个指针首次相遇时，各自所走的距离是多少呢？
指针p1一次只走1步，所走的距离是D+S1。
---
## Page 284
指针p2一次走2步，多走了n(n>=1)整圈，所走的距离是D+S；+n(S，+S1
)。
由于p2的速度是p1的2倍，所以所走距离也是p1的2倍，因此：
2(D+S)=D+S+n(S, +S2)
等式经过整理得出：
D =(n-1)(S,+S2)+S2
也就是说，从链表头结点到入环点的距离，等于从首次相遇点绕环n-1
圈再回到入环点的距离。
这样一来，只要把其中一个指针放回到头节点位置，另一个指针保持在
首次相遇点，两个指针都是每次向前走1步。那么，它们最终相遇的节
点，就是入环节点。
哇，居然这么神奇？
我们不妨用原题中链表的例子来演示
下
---
## Page 285
首先，让指针p1回到链表头节点，指针p2保持在首次相遇点。
5→3→7→26
←P2
←
P1
指针p1和p2各自前进1步。
53→7→2→6
P1
指针p1和p2第2次前进。
P2
5
P1
指针p1和p2第3次前进，指向了同一个节点2，节点2正是有环链表的入
环点。
---
## Page 286
5
P1P2
果真在入环点相遇了呢，这下明白
了！
好了，关于判断链表是否有环及其扩展的题目，我们就介绍到这
里。咱们下一节再见！
5.3最小栈的实现
5.3.1
一场关于栈的面试
---
## Page 287
小灰，又是你呀。
再介绍一下你白己
好的
blah blah blah
下面我来考查你一道算法题。
题目
实现一个栈，该栈带有出栈（pop）、入栈（push）、取最小元素
（getMin）3个方法。要保证这3个方法的时间复杂度都是O(1)。
---
## Page 288
栈底
栈顶
3
8
5
调用getMin方法，返回最小值3
哦，让我想想...
我想到啦！可以把栈中的最小元素下
标暂存起来..
小灰的思路如下。
1.创建一个整型变量min，用来存储栈中的最小元素。当第1个元素进栈
时，把进栈元素赋值给min，即把栈中唯一的元素当做最小值。
min=4
---
## Page 289
2.之后每当一个新元素进栈，就让新元素和min比较大小。如果新元素
小于min，则min等于新进栈的元素；如果新元素大于或等于min，则不
做改变。
4
9
min=4
3
min=3
3.当调用getMin方法时，直接返回min的值即可。
小灰，你有没有觉得这个思路存在什么
问题？
没有问题呀？这个解法杠杠的！
---
## Page 290
呵呵，今天面试就先到这里，回家等通
知去吧！
不要啊
5.3.2
解题思路
小灰，你刚刚去面试了？结果怎么
样？
---
## Page 291
大黄，怎么才能实现一个最小栈
呀？我采用临时变量暂存栈的最小值，究竞存在什么问题呢？
小灰，你想得太简单啦！你只考虑了
进栈场景，却没有考虑出栈场景。
哦？出栈场景有什么问题吗？
---
## Page 292
让我来给你演示一下。
原本，栈中最小的元素是3，min变量记录的值也是3。
3
min=3
这时，栈顶元素出栈了。
min=?
此时的min变量应该等于几呢？
虽然此时的最小元素是4，但是程序并不知道。
哎呀，还真是.....
---
## Page 293
所以说，只暂存一个最小值是不够
的，我们需要存储栈中曾经的最小值，作为“备胎”。
详细的解法步骤如下。
1.
设原有的栈叫作栈A，此时创建一个额外的“备胎"栈B，用于辅助栈
A。
栈A
栈B
2.当第1个元素进入栈A时，让新元素也进入栈B。这个唯一的元素是栈
A的当前最小值。
栈A
栈B
3.
之后，每当新元素进入栈A时，比较新元素和栈A当前最小值的大
小，如果小于栈A当前最小值，则让新元素进入栈B，此时栈B的栈顶元
素就是栈A当前最小值。
---
## Page 294
栈A
栈B
栈A
栈B
3
4.每当栈A有元素出栈时，如果出栈元素是栈A当前最小值，则让栈B的
栈顶元素也出栈。此时栈B余下的栈顶元素所指向的，是栈A当中原本
第2小的元素，代替刚才的出栈元素成为栈A的当前最小值。（备胎转
正。）
栈A
栈B
4
5.
当调用getMin方法时，返回栈B的栈顶所存储的值，这也是栈A的最
小值。
显然，这个解法中进栈、出栈、取最小值的时间复杂度都是0(1)，最坏
情况空间复杂度是0(n)。
---
## Page 295
这下明白了！那么代码怎么来实现
呢？
代码不难实现，让我们来看一看。
1. private Stack mainStack = new Stack();
2.private Stack minStack = new Stack();
3.
4./**
5.*入栈操作
6.
*@paramelement
入栈的元素
7.
*/
8.public void push(int element）{
9.
mainStack.push(element);
10.
//如果辅助栈为空，或者新元素小于或等于辅助栈栈顶，则将新元素压
入辅助栈
11.
if（minStack.empty()11element <= minStack.peek()）{
---
## Page 296
12.
minStack.push(element);
13.
14.}
15.
16.
/**
17.
出栈操作
18.
*/
19.
public Integer pop(）{
20.
//如果出栈元素和辅助栈栈顶元素值相等，辅助栈出栈
21.
if (mainStack.peek().equals(minStack.peek())){
22.
minStack.pop();
23.
24.
return mainStack.pop();
25.}
26.
27./**
28.
*获取栈的最小元素
29.
*/
30.
public int getMin(） throws Exception {
31.
if(mainStack.empty()){
32.