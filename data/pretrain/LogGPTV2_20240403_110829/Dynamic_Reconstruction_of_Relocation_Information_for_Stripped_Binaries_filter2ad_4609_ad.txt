l
Test (a few seconds)
Train (tens of seconds)
Ref (hundreds of seconds)
64
32
16
8
4
2
1
0
perlbench bzip2
gcc
mcf
gobmk hmmer
sjeng
h264ref omnetpp astar xalancbmk
Fig. 4. Avoiding the performance hit during the dynamic relocation discovery phase
(ﬁrst run) by gradually increasing the input size on each execution. The overall time in
this case is much less compared to running a program using large input the ﬁrst time.
executing gcc is due to the fact that it contains a high number of relocatable
oﬀset copies in dynamic data (see Table 1). Although, that overhead does dis-
appear in any consecutive execution, there is not much we can do at this point,
except asking the user to restart the execution of the program in order to take
advantage of the already discovered relocatable oﬀsets. An alternative strategy
is to ask the user to start with a very small input and progressively increase the
workload of the program during the ﬁrst few executions, until the majority of
the relocations are discovered.
To demonstrate the eﬀectiveness of that strategy, we applied it on the SPEC
CPU2006 benchmarks. These test programs come with three diﬀerent inputs: a
very small test dataset used for verifying the functionality of the programs, a
medium-sized train set used for feedback-directed optimizations and the refer-
ence dataset, which is much larger that the other two. For all the results up to
this point, we have used the reference dataset. Figure 4 shows the normalized
slowdown of applying our technique to the same SPEC programs, but while in-
creasing the workload (from test, to train and reference) this time. Also, during
each execution, we allow our prototype to use any reconstructed relocation infor-
mation that has been discovered from previous executions. The slowdown of the
reference dataset is much less compared to the one reported in Figure 3. More-
over, the overall discovery phase (which is now broken down to three executions)
is much quicker compared to Figure 3, in absolute numbers. Even though gcc
seems to have a larger slowdown with the test dataset than before, this accounts
for 22 seconds, plus a few minutes for the next two executions, compared to 48
minutes when using the large reference dataset during the ﬁrst execution.
5.3 Use Cases
The ﬁnal part of our evaluation focuses on the feasibility of applying our tech-
nique on popular, real-world applications. For this purpose, we installed older
versions of both Internet Explorer and Adobe Reader, where the relocation info
Dynamic Reconstruction of Relocation Information
83
of their EXE ﬁles was stripped. The exact versions we used were 6.0.2900.5512
and 8.1.2, respectively. In both cases, the code size of the non-relocatable EXE
was relative small, approximately 10KB. Using our prototype implementation of
our technique we were able to successfully relocate the code segments to a new
and random location, while not breaking the functionality of the applications.
The number of relocatable oﬀsets for which we reconstructed their relocation
information was 18 for Internet Explorer and 3 for Adobe Reader. Although it
is just a small number of relocations, reconstructing this information is crucial
in protecting these applications.
6 Related Work
We divide the related work into two parts. First, we review work that is related
to address space layout randomization. Reconstructing relocation information
enables or improves the accuracy of these proposals. Second, we review work
from the ﬁeld of dynamic data structure excavation, where similar techniques to
ours are used.
6.1 Code Randomization and Disassembly
As code-reuse attacks require precise knowledge of the structure and location
of the code to be reused, diversifying the execution environment or even the
program code itself is a core concept in preventing code-reuse exploits [13, 16].
Address space layout randomization [27, 29] is probably one of the most widely
deployed countermeasures against code-reuse attacks. The problem of randomiz-
ing non-relocatable executable ﬁles was identiﬁed early on, with the ﬁrst ASLR
implementations for Linux by the PaX project, and an approach based on the
interception of page faults to the original locations was proposed [31]. Our work
is based on the same core idea, but our implementation focuses on Windows
executables, we extend it with patching support to reduce runtime overhead,
and experimentally evaluate it.
In practice, however, the eﬀectiveness of ASLR is hindered by code segments
left in static locations [17,21,47], while, depending on the randomization entropy,
it might be possible to circumvent it using brute-force guessing [37]. Even if all
the code segments of a process are fully randomized, vulnerabilities that allow
the leakage of memory contents can enable the calculation of the base address
of a DLL at runtime [8, 10, 20, 23, 35, 42, 43].
To overcome the limitations of the original design, more ﬁne-grained forms of
randomization [19,28,44] have been proposed. These can be statically applied on
stripped binaries and randomize code at the instruction level (instead of random-
izing the base address only). Their accuracy and correctness, however, heavily
depends on the accuracy of disassembly and control ﬂow graph extraction, which
is improved when relocation information is available.
Control ﬂow integrity [9] is another protection scheme that conﬁnes program
execution within the bounds of a precomputed proﬁle of allowed control ﬂow
84
V. Pappas, M. Polychronakis, and A.D. Keromytis
paths. Although its original implementation depends on debug symbols for the
complete extraction of the control ﬂow graph, recent proposals have demon-
strated how more relaxed forms of the same technique can be applied on stripped
binaries [45, 46]. Again, for legacy applications, these techniques would beneﬁt
from the improved control ﬂow extraction based on the availability of relocations.
Finally, although binary rewriting is still possible in the absence of relocation
information, it relies on dynamic instrumentation for indirect calls/jumps [41].
This makes the overall runtime overhead of the technique to depend on the number
of executed indirect calls/jumps, which are very frequent in C++ applications.
6.2 Dynamic Data Structure Excavation
Another body of work that uses related techniques to ours is dynamic data
structure excavation [14, 18, 24, 39, 40]. By looking at memory access patters
dynamically at runtime, these techniques are able to infer the type of binary
data, such as data structures and arrays.
Laika [14] employs Bayesian unsupervised learning to detect data structures.
Possible object positions and sizes are identiﬁed by using potential pointers in
the process’ memory image. Although suﬃcient for cases like evaluating the
similarity between malware samples, Laika’s output is not precise enough for
debugging or reverse engineering. Similar to Laika, Rewards [24] reconstructs
type information dynamically, based on abstract structure identiﬁcation [33]. A
fundamental limitation of this approach is that it is not capable of identifying
data structures that are internal to a module. Howard [40] improves on the pre-
cision of data structure excavation by applying a set of speciﬁc rules to identify
data structures dynamically. Arrays, structure ﬁelds, etc. are recognized based
on runtime memory access patterns.
7 Conclusion
Address Space Layout Randomization (ASLR) has proven to be a very eﬀec-
tive mitigation against code reuse attacks, making successful exploitation much
harder. Unfortunately, ASLR depends on some information that is often stripped
from executable ﬁles.
As a step towards addressing this limitation, we designed and implemented a
technique to dynamically reconstruct this missing information, which eﬀectively
enables ASLR even on programs that are otherwise incompatible. The results
of our experimental evaluation focusing on performance measurements and use
cases with real-world applications clearly show the practicality of the proposed
approach.
Acknowledgements. This work was supported by the US Air Force, the Oﬃce
of Naval Research, and DARPA through Contracts AFRL-FA8650-10-C-7024,
N00014-12-1-0166 and FA8750-10-2-0253, respectively, with additional support
by Intel Corp. This material is based upon work supported by (while author
Dynamic Reconstruction of Relocation Information
85
Keromytis was serving at) the National Science Foundation. Any opinions, ﬁnd-
ings, conclusions, or recommendations expressed herein are those of the authors,
and do not necessarily reﬂect those of the US Government, the Air Force, ONR,
DARPA, NSF, or Intel.
References
1. ATMs Face Deadline
to Upgrade From Windows XP, http://www.
businessweek.com/articles/2014-01-16/atms-face-deadline-
to-upgrade-from-windows-xp
2. /ORDER (put functions in order), http://msdn.microsoft.com/en-us/
library/00kh39zz.aspx
3. Proﬁle-guided optimizations,
http://msdn.microsoft.com/en-us/library/e7k32f4k.aspx
4. SPEC CPU2006 Benchmark, http://www.spec.org/cpu2006.
5. Syzygy - proﬁle guided, post-link executable reordering, http://code.google.
com/p/sawbuck/wiki/SyzygyDesign
6. UK government pays Microsoft 5.5m to extend Windows XP support, http://
www.theguardian.com/technology/2014/apr/07/uk-government-
microsoft-windows-xp-public-sector
7. Windows, X.P.: SP3 and Oﬃce, Support Ends (April 8, 2003), http://www.
microsoft.com/en-us/windows/enterprise/endofsupport.aspx
8. MWR Labs Pwn2Own 2013 Write-up - Webkit Exploit (2013), http://labs.
mwrinfosecurity.com/blog/2013/04/19/mwr-labs-pwn2own-2013-
write-up---webkit-exploit/
9. Abadi, M., Budiu, M., Erlingsson, ´U., Ligatti, J.: Control-ﬂow integrity. In: Pro-
ceedings of the 12th ACM Conference on Computer and Communications Security,
CCS (2005)
10. Bennett, J., Lin, Y., Haq, T.: The Number of the Beast (2013), http://blog.
fireeye.com/research/2013/02/the-number-of-the-beast.html
11. Bhatkar, E., Duvarney, D.C., Sekar, R.: Address obfuscation: An eﬃcient approach
to combat a broad range of memory error exploits. In: Proceedings of the 12th
USENIX Security Symposium (2003)
12. Bhatkar, S., Sekar, R., DuVarney, D.C.: Eﬃcient techniques for comprehensive pro-
tection from memory error exploits. In: Proceedings of the 14th USENIX Security
Symposium (August 2005)
13. Cohen, F.B.: Operating system protection through program evolution. Computers
and Security 12, 565–584 (1993)
14. Cozzie, A., Stratton, F., Xue, H., King, S.T.: Digging for data structures. In: Pro-
ceedings of the 8th USENIX Conference on Operating Systems Design and Imple-
mentation, OSDI 2008, pp. 255–266. USENIX Association, Berkeley (2008)
15. Designer, S.: Getting around non-executable stack (and ﬁx), http://seclists.
org/bugtraq/1997/Aug/63
16. Forrest, S., Somayaji, A., Ackley, D.: Building diverse computer systems. In: Pro-
ceedings of the 6th Workshop on Hot Topics in Operating Systems, HotOS-VI
(1997)
17. Roglia, G.F., Martignoni, L., Paleari, R., Bruschi, D.: Surgically returning to ran-
domized lib(c). In: Proceedings of the 25th Annual Computer Security Applications
Conference, ACSAC (2009)
86
V. Pappas, M. Polychronakis, and A.D. Keromytis
18. Guo, P.J., Perkins, J.H., McCamant, S., Ernst, M.D.: Dynamic inference of abstract
types. In: Proceedings of the 2006 International Symposium on Software Testing
and Analysis (ISSTA), Portland, ME, USA, July18-20, pp. 255–265 (2006)
19. Hiser, J., Nguyen-Tuong, A., Co, M., Hall, M., Davidson, J.W.: ILR: Where’d my
gadgets go? In: Proceedings of the 33rd IEEE Symposium on Security & Privacy,
S&P (2012)
20. Hund, R., Willems, C., Holz, T.: Practical timing side channel attacks against
kernel space ASLR. In: Proceedings of the 34th IEEE Symposium on Security &
Privacy, S&P (2013)
21. Johnson, R.: A castle made of sand: Adobe Reader X sandbox. CanSecWest (2011)
22. Kil, C., Jun, J., Bookholt, C., Xu, J., Ning, P.: Address space layout permuta-
tion (ASLP): Towards ﬁne-grained randomization of commodity software. In: Pro-
ceedings of the 22nd Annual Computer Security Applications Conference, ACSAC
(2006)
23. Li, H.: Understanding and exploiting Flash ActionScript vulnerabilities.
CanSecWest (2011)
24. Lin, Z., Zhang, X., Xu, D.: Automatic reverse engineering of data structures from
binary execution. In: Proceedings of the 17th Annual Network and Distributed
System Security Symposium (NDSS 2010), San Diego, CA (February 2010)
25. Microsoft. Enhanced Mitigation Experience Toolkit, http://www.microsoft.
com/emet
26. Microsoft. Windows Debugging API, http://msdn.microsoft.com/en-us/
library/windows/desktop/ms679303v=vs.85.aspx
27. Miller, M., Burrell, T., Howard, M.: Mitigating software vulnerabilities
(July 2011), http://www.microsoft.com/download/en/details.aspx?
displaylang=en&id=26788
28. Pappas, V., Polychronakis, M., Keromytis, A.D.: Smashing the gadgets: Hindering
return-oriented programming using in-place code randomization. In: Proceedings
of the 33rd IEEE Symposium on Security & Privacy, S&P (2012)
29. PaX Team. Address
space
layout
randomization (2003), http://pax.
grsecurity.net/docs/aslr.txt
30. PaX Team. Non-executable pages design & implementation (2003), http://pax.
grsecurity.net/docs/noexec.txt
31. PaX Team. Non-relocatable executable ﬁle randomization (2003), http://pax.
grsecurity.net/docs/randexec.txt
32. Pietrek, M.: An in-depth look into the Win32 portable executable ﬁle format, part
2, http://msdn.microsoft.com/en-us/magazine/cc301808.aspx
33. Ramalingam, G., Field, J., Tip, F.: Aggregate structure identiﬁcation and its ap-
plication to program analysis. In: Symposium on Principles of Programming Lan-
guages (POPL), pp. 119–132 (1999)
34. Rescorla, E.: Security holes.. Who cares? In: Proceedings of the 12th USENIX
Security Symposium, pp. 75–90 (August 2003)
the case of
35. Serna, F.J.: CVE-2012-0769,
info leak (Febru-
ary 2012), http://zhodiac.hispahack.com/my-stuff/security/Flash_
ASLR_bypass.pdf
the perfect
36. Shacham, H.: The geometry of innocent ﬂesh on the bone: return-into-libc with-
out function calls (on the x86). In: Proceedings of the 14th ACM Conference on
Computer and Communications Security, CCS (2007)
37. Shacham, H., Page, M., Pfaﬀ, B., Goh, E.-J., Modadugu, N., Boneh, D.: On the
eﬀectiveness of address-space randomization. In: Proceedings of the 11th ACM
Conference on Computer and Communications Security, CCS (2004)
Dynamic Reconstruction of Relocation Information
87
38. Skape.: Locreate: An anagram for relocate. Uninformed, 6 (2007)
39. Slowinska, A., Stancescu, T., Bos, H.: Dde: Dynamic data structure excavation.
In: Proceedings of the 1st ACM SIGCOMM Asia-Paciﬁc Workshop on Systems
(ApSys), pp. 13–18 (2010)
40. Slowinska, A., Stancescu, T., Bos, H.: Howard: A dynamic excavator for reverse en-
gineering data structures. In: Proceedings of the Network and Distributed System
Security Symposium, NDSS (2011)
41. Smithson, M., Anand, K., Kotha, A., Elwazeer, K., Giles, N., Barua, R.: Bi-
nary rewriting without relocation information. University of Maryland, Tech. Rep.
(2010)
42. Snow, K.Z., Davi, L., Dmitrienko, A., Liebchen, C., Monrose, F., Sadeghi, A.-R.:
Just-in-time code reuse: On the eﬀectiveness of ﬁne-grained address space layout
randomization. In: Proceedings of the 34th IEEE Symposium on Security & Pri-
vacy, S&P (2013)
43. Vreugdenhil, P.: Pwn2Own (2010), Windows 7 Internet Explorer 8 exploit,
http://vreugdenhilresearch.nl/Pwn2Own-2010-Windows7-
InternetExplorer8.pdf
44. Wartell, R., Mohan, V., Hamlen, K.W., Lin, Z.: Binary stirring: Self-randomizing
instruction addresses of legacy x86 binary code. In: Proceedings of the 19th ACM
Conference on Computer and Communications Security (CCS), pp. 157–168 (Oc-
tober 2012)
45. Zhang, C., Wei, T., Chen, Z., Duan, L., Szekeres, L., McCamant, S., Song, D.,
Zou, W.: Practical control ﬂow integrity & randomization for binary executables.
In: Proceedings of the 34th IEEE Symposium on Security & Privacy, S&P (2013)
46. Zhang, M., Sekar, R.: Control ﬂow integrity for cots binaries. Presented as part of
the 22nd USENIX Security Symposium, pp. 337–352. USENIX, Berkeley (2013)
47. Zovi, D.A.D.: Practical return-oriented programming. SOURCE Boston (2010)