we consider it as the worst-case scenario. We designed the
ASIC such that all updates (including lookups) are faster than
the time between two consecutive ACTs, allowing PROTRR
to execute in parallel. In particular, the operations require V
cycles during a refresh, and B+1 cycles during an ACT. We
considered 45 ns as the minimum time between two activations,
as previously reported [19].
Static power. Although previous work showed that the energy
consumption for the mitigation logic is negligible [19], [20], we
evaluated it for completeness. The overhead for 1024 counters
is at maximum 17.44 mW for 16 banks, obtaining a total
of 139.52 mW for 8 chips. This is in line with previously
reported values [20]. For a baseline static consumption of
3 W/8 GiB [62], this leads to 4.65% static power overhead.
However, given the current technology and consumer DDR4
chips, 512 counters are enough to ensure protection in the
worst cases, leading to 2.35% static power overhead.
Area. Chips area depends on process technology, fabrication,
and the array size. For our analysis, we consider a common
density for DDR4 devices, 0.247 GB/mm2 [63]. For a chip
that uses 16 banks and 1024 counters per bank, this leads to
a maximum area overhead of 3.7%. Unfortunately, currently
deployed TRR mechanisms are kept secret and there is no
open DRAM implementation that can integrate PROTRR. For
this reason, to further confirm the feasibility of PROTRR, we
contacted a DRAM manufacturer. We obtained confirmation
that (i) up to 2K counters have already been deployed in the
past, and (ii) given PROTRR’s specifications (dimension, as
obtained from results), it is reasonable to deploy it.
D. Correctness
We tested PROTRR against FEINTING to check its implemen-
tation by running PROTRR in DRAMsim3 with memory traces.
Size
(GiB)
8
32
8
Freq.
(MHz)
2666
2666
2400
Geom.
#R., #B.
1, 16
2, 16
1, 16
TABLE II: Result of FEINTING on three DDR4 devices. We report the best
attack’s parameters (Best Params.) as: attacks duration (in tREFIs), TRR
distance, and number of victim hammer repetitions.
DIMM Mf. Date
(yy-ww)
D0
20-03
D1
20-06
D2
20-10
In all the cases with a correct configuration, PROTRR could
withstand FEINTING. Instead, in cases where PROTRR was
improperly configured, FEINTING could successfully trigger
bit flips. We also generated traces from two state-of-the-
art Rowhammer fuzzers [1], [3] and executed them against
PROTRR for three days without observing any bit flip.
Best
Params.
2048, 9, 1
2048, 9, 3
8192, 9, 4
Bit Flips
Observed
✔
✔
✔
E. FEINTING on real devices
FEINTING assumes a mitigation that counts every activa-
tion with an adequate number of counters. Existing TRR
schemes are not ideal and may employ multiple concurrent
mechanisms to catch aggressors, some completely different
from PROTRR [2]. However, we were still interested to see if
FEINTING is able to generate bit flips on devices with a deployed
counter-based mitigation. To evaluate this, we acquired three
DDR4 devices from the same manufacturer previously reported
to use a counter-based mitigation [2] (see Table II).
We conducted our experiments on an Intel i7-8700K running
on Linux with kernel 4.15.0. We adapted FEINTING based
on insights from [2] as follows: we assumed that counters
could track at most 16 rows (i.e., 18 decoys needed as part
of FEINTING-Ghost), and systematically tested different attack
durations (2048× up to 32768× tREFI) as a row could be
refreshed multiple times in a tREFW. We tested different TRR
distances (1 up to 9) and victim hammer repetitions (1 to 4)
while assuming 5 hammering repetitions for decoys.
In Table II, we show the results of running FEINTING-Ghost
on our acquired DDR4 devices. An attack trace can be seen in
Figure 16, where the duration is 8192× tREFI. Our results
show that with minor adaptations, we could successfully trigger
bit flips on all three devices using FEINTING. Further, we can see
that an attack duration shorter than a tREFW and hammering
the victim fewer times (e.g., one time for D0) can be beneficial
because sampling may happen only at specific times as reported
in previous work [1], [3]. We tested Blacksmith [3] on the
same devices, which could trigger bit flips on all of them,
while TRRespass [1] failed to obtain bit flips on DIMM D0.
VIII. DISCUSSION
We discuss how PROTRR can (i) be adapted to handle
postponing and pulling-in of refresh commands, (ii) obtain
better bounds by using subarray parallelism, and (iii) generalize
to other, yet unknown, Rowhammer effects.
Postponing and pulling-in of REFs. The DDRx standard
gives some flexibility in terms of REFs by allowing REF
postponing and pulling-in. Attackers can exploit postponing
to maximize TRR-free REFs, which reduces the number of
decoys needed for both DDR4 and DDR5. For DDR4, the
victim can be hammered more often than before, but for DDR5
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:57:04 UTC from IEEE Xplore.  Restrictions apply. 
747
a.b.# Counters (log scale)0.10.20.3Total area [mm2]123Power [mW]AreaPower# Counters (log scale)64128256512102420486412825651210242048DDR4DDR5515253545RTHRESH (x10(cid:31))Fig. 16: Trace of FEINTING-Ghost against DDR4 samples with 16 counters. The attack duration is 8192 tREFI.
nothing changes due to RFM still being sent. A more detailed
analysis of REF postponing/pulling-in is given in Appendix A.
Subarray parallelism. Subarrays enable a bank to refresh
multiple rows at each REF. PROTRR can potentially leverage
this to perform more TRRs when necessary. We provide a
detailed description of how FEINTING can be adapted to subarray
parallelism in Appendix C. In summary, each bank can perform
multiple TRRs at the same time, effectively increasing V .
However, the additional TRRs cannot target any row as each
subarray can still only refresh V rows at any given TRR event.
An adapted FEINTING can exploit this limitation by reducing
the number of required decoys to create the optimal attack.
Generalization. FEINTING provides the basis to configure
PROTRR to protect against Rowhammer. The only (implicit)
requirement for FEINTING is knowing the interaction between
an aggressor and its victims. In the case of a basic Rowhammer
attack, which we originally considered, an aggressor activation
interacts with its direct neighboring victim rows. With new
Rowhammer effects, FEINTING should be adjusted to consider
new interactions between aggressors and victims. We discuss
two of these cases next.
During the development of PROTRR, the half-double pattern
was disclosed by Google researchers [34]. To also protect
against it, we only needed to consider that on certain devices,
an aggressor activation can also interact with victim rows that
are more than one row apart (i.e., up to B rows). Currently, a
rigorous characterization of the half-double effect is missing.
For this reason, we assumed the worst-case in the design of
PROTRR, i.e., the same effect on every row in the blast diameter.
Once this relationship is better understood, future research can
adapt FEINTING accordingly to derive the optimal version of
PROTRR when B> 2.
Another concurrent discovery shows that rows that are kept
active can also influence adjacent rows [64]. PROTRR can easily
generalize to this case as well. The only new requirement is
to increase the counter for victims of the (aggressor) row that
remains active. It remains unclear, however, whether simply
keeping a row active is more effective than using the time
for additional hammering which should be characterized more
rigorously in the future.
IX. SECURITY ANALYSIS OF EXISTING SCHEMES
We first discuss a general
limitation when mitigating
Rowhammer outside of DRAM. We then present our security
analysis of state-of-the-art hardware mitigations, which resulted
in the discovery of novel vulnerabilities in four earlier proposed
schemes [16], [19], [45], [65].
Internal row remapping. Previous work has observed that
bits can flip in rows that are not adjacent to an aggressor [12],
[13], [15]. This is due to internal row remapping that does not
necessarily map logically-adjacent to physically-adjacent rows
inside the DRAM device [66]. This is a major limitation of all
existing Rowhammer mitigations that are outside of DRAM,
both hardware and software [9], [12], [15], [15]–[19], [22],
[24], [25], [45] except Blockhammer [20]. PARA [15] explicitly
requires this remapping information to be communicated from
the DRAM to the CPU, which has never been implemented. In
contrast, the in-DRAM nature of PROTRR allows it to use the
correct row mapping that is known by the DRAM chip only.
CBT [45] and CAT-TWO [16]. Both mitigations reset their
table after a tREFW period. If within this period, an aggressor
row reaches Rthresh activations, its neighbors are refreshed.
An attacker can, however, activate an aggressor Rthresh− 1
times immediately before and after the tREFW, violating the
guarantees provided by the mitigation. A second issue concerns
CAT-TWO only: it employs trees of counters distributed among
the rows of a full rank. However, these trees are blind to
victim rows that share aggressor rows across different trees. By
hammering each aggressor for Rthresh− 1 times, the victim
can exceed the threshold.
Graphene [19]. Refreshing a row with TRR has a similar
effect like an ACT, which is used while hammering rows. As a
consequence, an attacker could exploit TRRs to hammer rows.
While this could be easy to fix, it is not taken into account
in the current design of Graphene. We discuss how PROTRR
securely handles TRRs in Appendix D.
Panopticon [65]. Concurrent to our work, Panopticon is a new
in-DRAM mitigation against Rowhammer that relies on per-row
counters stored in DRAM and uses the ALERT mechanism to
request more time (from the memory controller) to TRR victim
rows that reached a threshold. While storing counters inside
DRAM itself is cheap, it is insecure as they can similarly be
affected by Rowhammer bit flips. Furthermore, overloading the
ALERT mechanism has multiple undesirable implications. First,
not all devices may support ALERT as it is optional according
to the standard, and the PHY-level errors causing them are very
rare. Second, ALERT is a signal that blocks the whole device,
likely causing significant performance degradation. Finally, it
is unclear how the memory controller can tell the difference
between a real ALERT (to retry commands) and one due to
Rowhammer activity. If counters in DRAM can be secured
(e.g., with a strong ECC), PROTRR can use these counters to
provide a better alternative.
X. RELATED WORK
We summarize existing work on Rowhammer mitigations in
Table III and compare the following properties: (i) scalability,
i.e., the optimality of resource allocation; (ii) security, i.e.,
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:57:04 UTC from IEEE Xplore.  Restrictions apply. 
748
1819181928190Row ID2...Activation o(cid:31)set in tREFi448812266Activation o(cid:31)set in tREFi448812266Activation o(cid:31)set in tREFi44882266118126Activation o(cid:31)set in tREFi44882266Activation o(cid:31)set in tREFi44882266TABLE III: Rowhammer mitigations in hardware and software.
Integration
Security
Support
Scalability
Flex. Opt. Det.
FP Vuln. DDR4 DDR5 OS CPU DRAM
—
—
—
Mitigation
PROTRR
Blockhammer [20]
CBT [45]
CAT-TWO [16]
Graphene [19]
MRLoc [17]
Panopticon [65]
PARA [15]
PRoHIT [48]
TWiCe [18]
ALIS [12]
ANVIL [22]
CATT [24]
GuardION [9]
ZebRAM [25]
d
e
s
a
b
-
W
H
d
e
s
a
b
-
W
S
— —
— —
— —
— —
— —
— —
— —
— —
— —
— —
the strength of the provided security guarantees; (iii) support,
i.e., the mitigation’s supported DRAM standards; (iv) and
integration, i.e., the solution’s required integration effort.
) or not (
) or probabilistic (
For scalability, we consider if mitigations optimally use
counters and refreshes (Opt.); and if these resources can flexibly