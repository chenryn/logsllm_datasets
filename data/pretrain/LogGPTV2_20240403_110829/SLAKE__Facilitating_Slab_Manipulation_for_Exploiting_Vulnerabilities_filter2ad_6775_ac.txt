Ar[i ] . h
Ar[i ] . l
Ap[i ]
w
w
w
w
. . .
. . .
. . .
. . .
( , h) ( , h) . . .
1
2
Ar
( , h)
i
vul/spray obj
. . .
(l, h) (l, h) . . .
( , h)
(l, h)
. . .
(l, h)
1
m
2
i
m
vtm obj
. . .
p
. . .
i
p
n
Ap p p
1 2
Ar[1] . l
Ar[1] . h
overﬂow region
Ar[1] . l
Ar[1] . h
overﬂow region
vul obj
adjacent slot
vtm obj
spray obj
vtm obj
Ap[1]
w
Ap[2]
overlap region
Ap[1]
Ap[2]
w
overlap region
(a) Vulnerability capability
(b) Kernel object property
(a) Pairing OOB write
(b) Pairing UAF/double free
Figure 2: Modeling vulnerability & object.
Figure 3: Pairing vulnerability with objects.
4.2 Adjusting Slab Layout
Using the aforementioned approach and other information in our
database, we can easily pinpoint the objects needed for slab layout
manipulation and quickly figure out what system calls we should
use to interact with the objects identified. However, as is illustrated
in Section 2.3, when leveraging a system call to tamper with slab
layout, it may involve side effects - allocate or deallocate many other
data objects. This significantly influences an attacker’s capability
in obtaining the desired slab layout. As a result, we further develop
a technical approach to systematically adjust the slab layout and
eliminate the side effects introduced by those system calls.
Adjusting unoccupied slots. As is mentioned above, no matter
which exploitation approaches one would adopt against a kernel
vulnerability, he always has to allocate a target object to a cor-
responding freed slot (e.g., overlaying a spray object on top of a
vulnerable object on a free list). In practice, it is very uncommon
that an identified system call can perfectly place the target object
to the target slot. In order to address this issue, we, therefore, ad-
just the free list chain by following the procedure below. First, we
number all the unoccupied slots on the free list chain consecutively.
Then, we identify the index of the target slot i (e.g., the slot where
an accidentally freed object is located). By invoking the correspond-
ing system calls to allocate a target object (e.g., a spray object), we
record the index of the slot j where that target object is actually
allocated. We compare the two indexes. If the index i is less than
the index j (i < j), then we allocate (j − i) objects to take over more
unoccupied slots right before invoking the corresponding system
calls to allocate the target object. Otherwise, we first allocate (i − j)
objects right before triggering the vulnerability. Second, we trigger
the vulnerability and then free the objects we allocated. Finally,
we invoke system calls to allocate the target object. With such a
design, we can adjust the free list chain to a particular state, under
which the invocation of that identified system call could perfectly
position the target object to the target slot.
− 1
− 1
i
j
+ 1
+ 1
In this work, we accomplish the aforementioned free list chain ad-
justment by using system calls and corresponding objects archived
in our database. More specifically, when allocating a certain num-
ber of objects, we first search our database and track down those
objects that can be placed in the manipulated slab. Among the ob-
jects identified, we then choose only the objects that match the
following criteria ś ❶ the system calls tied to the objects do not
Before reorganization
After reorganization
vul obj
i − 1
j + 1
1
K
irrelevant obj 
at target slot
i
j
vtm obj
i + 1
j − 1
− 1
1
K
i
vtm obj at 
target slot
i
j
i + 1
j − 1
irrelevant obj
vul obj
i − 1
j + 1
+ 1
Figure 4: Reorganizing occupied slots.
+ 1
j
− 1
introduce side effects, and ❷ the database archives the system calls
to deallocate the object without side effects.
It should be noted that we perform defragmentation [31, 48]
right before the runtime environment preparation for a kernel vul-
nerability (e.g., establishing a network connection, opening files
and mapping anonymous pages, etc). In addition, after defragmen-
tation, we trigger the corresponding vulnerability and launch our
slab manipulation immediately. With the first setup, we can force
SLAB/SLUB allocator to create a new slab, reducing instability of
our slab manipulation. With the second setup, we can minimize the
influence of other kernel threads upon the slab layout.
Reorganizing occupied slots. In most cases, by following the
procedure above, an adversary could place his target objects to the
target slots and thus obtain the slab layout of his desire for further
exploitation. However, for some vulnerabilities with an OOB write
capability, knowing the way to take over the unoccupied slots is
oftentimes not sufficient.
After defragmentation, the free list chain is sequentially orga-
nized or, in other words, the ordering of unoccupied slots perfectly
matches their physical positions. As is depicted in Figure 4, after
calling a system call to allocate a vulnerable object, the vulnerable
object takes the (i − 1)t h slot on the free list chain. By analyzing the
capability of the vulnerability, assume we discover the vulnerability
gives the attacker the ability to perform an out-of-bounds write,
which overwrites the data in its adjacent slot (i.e., the it h slot). Then,
following the exploitation approach mentioned in Section 2.2.2, we
should allocate a victim object to the it h slot. However, as is shown
in Figure 4, when allocating the vulnerable object through a corre-
sponding system call, we inevitably allocate an irrelevant kernel
object, which takes the slot of our target. Assuming the irrelevant
kernel object does not expose any critical data under the capability
of that vulnerability, it then becomes challenging for us to exploit
that vulnerability.
In order to tackle the challenge above, one instinctive reaction
is to free that irrelevant object from the target slot by using a
system call. However, such a method typically does not work simply
because the free of the irrelevant objects may always incur the
deallocation of the vulnerable objects. As a result, we develop the
following method to reorganize free list chain and thus adjust
occupied slots.
Before performing the reorganization, we first profile an unde-
sired layout as follows. First, we manually extend a PoC program
with the ability to call corresponding system calls to allocate a
victim object right after it invokes system calls to allocate the vul-
nerable object. Then, we instrument this modified PoC program
with ftrace [36] so that we can keep track of the data objects that
each system call (de)allocates. By running this instrumented PoC
program, we record the total number of objects that the PoC allo-
cates on the slab, and store the index for the victim object as well
as that for its desired slot. As is depicted in Figure 4, we assume
a PoC program allocates K kernel objects on the slab, the victim
object is located at the jt h slot, and the desired slot for this victim
object is located at it h place.
With the profiling information mentioned above, we re-order
the free list chain prior to the allocation of the vulnerable object
by following the procedure below. Using the system calls and data
objects archived in the database, we first perform defragmentation
and then allocate objects to take over K unoccupied slots on the
free list chain. Second, we deallocate these objects in the reverse
order except for swapping the order for the it h and jt h objects. As
is shown in Figure 4, following these allocation and deallocation
operations, we reshape the free list chain. When following the
same procedure above to allocate the vulnerable object and then the
victim object, we can expect all the objects are successfully allocated
at the originally slots except for the victim and that irrelevant
objects swapped.
5 IMPLEMENTATION
We implemented the aforementioned technique and named it after
SLAKE. As is mentioned above, our proposed technique involves
both static and dynamic analysis. Therefore, SLAKE contains two
major components taking responsibility for static and dynamic
analysis, respectively. In the following, we describe critical imple-
mentation details. Due to the space limit, the readers could refer
to the Appendix for more details about the database constructed
by using SLAKE. In addition, the Appendix illustrates how SLAKE
utilizes the database to assemble an exploitation template.
Static analysis. To perform static analysis, we compiled entire
kernel code by using gllvm [18]. This gives us the ability to obtain
the LLVM IR for entire Linux kernel. In this work, we developed
two LLVM passes and thus performed the aforementioned static
analysis against the Linux kernel IR. Our first LLVM pass is built for
identifying the objects and the sites of the interest. Its implemen-
tation tracks down victim objects by using the type information
preserved in LLVM IR, and gathers spray objects by searching
CallInst to kernel I/O functions such as copy_from_user(). Following
the design discussed in Section 3.1, for each identified object, this
LLVM pass also pinpoints its (de)allocation sites as well as the name
of cache holding that object. If an object contains a pointer, this
pass further identifies its dereference chain.
Our second LLVM pass is the extension of an existing tool
KINT [43], which takes the responsibility of kernel call graph con-
struction. At the high level, KINT constructs a call graph by us-
ing static field-sensitive inter-procedural taint analysis. Through
this static analysis, it could estimate the destinations for indirect
calls and thus build a kernel call graph. In our implementation, we
utilized KINT as our building block and customized it from two
perspectives. First, we trim off nodes and corresponding edges in
the call graph that pertain to functions in .init.text section. This is
because these functions are no longer invoked after kernel booting
and cannot be used to facilitate kernel exploitation. Second, we
eliminate the edges that bridge two independent kernel modules
because independent kernel modules do not have relationships be-
tween each other and the bridging edges in a call graph are false
positives. In our implementation, we employ the KConfig file to
identify such edges. To be specific, we implemented a python script
that deems two modules dependent between each other only if it
identified that pair of modules in the dependency attributes depends
֒→ on and select. In total, the two LLVM passes contain about 2,000
lines of C++ code, capable of running on LLVM 6.0 [34].
Dynamic analysis. As is mentioned in Section 3.2, considering
the need to tie deallocation and dereference system calls to the
object we intentionally allocate on the slab, we cannot directly
rely upon fuzz testing. Therefore, we do not use the plugin like
KCOV [49] to facilitate the identification of system calls because it
provides no information regarding kernel objects. Instead, we wrote
a GCC plugin responsible for implanting panic anchors into the
Linux kernel. In addition, it instruments the Linux kernel, making
it obtain the ability to store the address of each allocated object.
As is described in Section 3.2, with all of these, we can utilize fuzz
testing to explore the paths to these sites and thus facilitate the
identification of system calls pertaining to object (de)allocation as
well as function pointer dereference. In this work, we extended a
Linux kernel fuzzing tool ś Syzkaller [13] with the integration of
Moonshine[29] ś to perform fuzz testing against the instrumented
Linux kernel. To be specific, in addition to the fuzzing templates
provided by this tool, we introduced more fuzzing templates to
Syzkaller. In total, the implementation of our Syzkaller extension
along with the GCC plugin contains about 700 lines of C code.
As is described in Section 3.1, the dereference anchor sites do
not always represent the sites of function pointer dereference. In
order to truly pinpoint a function pointer dereference and ensure
the dereference of that pointer is through a victim object, we also
developed a GDB python script. Technically speaking, the GDB
python script runs a Linux kernel on QEMU and sets breakpoints
on the dereference anchors. Each time the script hits a breakpoint,
it performs single-step execution and records each of the state-
ments until the end of the current function. Since the statements
recorded indicate the execution trace from the anchor site to the
end of the current function, the python script further constructs a
use-def chain, against which it performs backward data flow anal-
ysis, checks each function pointer dereference on the chain, and
thus determine whether that function dereference is truly through
the corresponding victim object. As part of SLAKE, last but not least,
we implemented a ftrace util that instruments the programs gener-
ated by syzkaller. With the facilitation of this util, SLAKE logs slab
activities tied to each system call and thus profiles the side effects
incurred by system calls. In our implementation, the GDB script
and ftrace util contain 200 lines of python code and approximately
400 lines of C code, respectively. We plan to publicly release the
entire code space of SLAKE at the time of the acceptance of this
work.
6 EXPERIMENT
In this section, we first introduce the setup of our experiment. Then,
we evaluate how well SLAKE could identify the system calls pertain-
ing to object (de)allocation and function pointer dereference. Finally,
we showcase the effectiveness of SLAKE in exploit development.
6.1 Experiment Setup
To evaluate the effectiveness of SLAKE, we ran our experiment on
Linux kernel v4.15, the latest long-term version at the time of the
experiment. Against this version of Linux, we performed static anal-
ysis to build up an object database for core kernel (code covered
in defnoconfig) as well as 32 commonly-adopted kernel modules
pertaining to the file system, network, time management, inter-
process communication, device drivers and security mechanisms.
When compiling the Linux kernel image for dynamically exploring
sites of interest in these modules, we additionally enabled other
modules marked in defconfig plus KCOV so that kernel fuzzing
can be booted normally. For each site of our interest, we set our
kernel fuzzing for two hours. Throughout the entire experiment,
we used 3 VM instances on a machine with the following config-
uration ś Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHZ CPU and
64GB memory.
To obtain test cases for our evaluation, we reviewed previous re-
search works [20, 45, 46, 48] pertaining to Linux kernel exploitation.
Since the real-world vulnerabilities used in these works indicate a
corpus of representative test cases, we took all of their slab-related
vulnerabilities3 to form a dataset for our evaluation. In addition,
we exhaustively searched the CVE list [8] and complemented our
dataset by selecting those slab-related vulnerabilities that satisfy
the following criteria. ❶ There must be publicly available PoC pro-
grams demonstrating their capability in corrupting memory on the
slab because SLAKE takes as input a PoC program. ❷ There must be
an effective, lightweight approach to migrating these vulnerabilities
into v4.15 kernel (i.e., defconfig plus vulnerable modules). ❸ The
trigger of these vulnerabilities does not rely upon special hardware
devices because this allows us to avoid the intensive labor and high
cost for gathering various special hardware devices.
In total, we gathered 27 kernel vulnerabilities enclosed in our
dataset. We argue this dataset is representative not only because
they cover all the slab-related test cases used in the similar research
but also they include other real-world vulnerabilities. To the best
of our knowledge, this is the largest corpus of test cases used for
evaluating research pertaining to Linux kernel exploitation. We
release our code and exploits at [1] to foster future work.
3By slab-related vulnerabilities, we mean the vulnerabilities that corrupt slab/slub
memory regions. Our SLAKE is developed for this kind of kernel vulnerabilities and
therefore our test case corpus naturally excludes those non-slab-related vulnerabilities
like stack or integer overflow etc.
6.2 Evaluation of Syscall Identification
Comparison between different call graphs. As is described
in the section above, we build a kernel call graph by extending
KINT [43], and then utilize static and dynamic analysis to identify
system calls useful for exploitation. Technically speaking, in addi-
tion to our KINT-based approach, another approach to building a
kernel call graph is to leverage the prototype matching used in [50].
In Table 1, we show comparison results.
First, from the column indicated by ł# of v/sž, we can observe
that, in comparison with prototype-matching approach, our KINT-
based approach could reduce the total number of kernel objects that
can be potentially used for exploitation (128 vs 108). By manually
examining those 20 kernel objects eliminated, we discover they
are not the false positives but the kernel objects that are truly
unreachable from any of the system calls. This indicates KINT-
based call graph is more suitable for identifying kernel objects
potentially useful for exploitation.
Second, from the column of łavg. syscall #ž, we can observe
that our KINT-based call graph provides us with an extra benefit.
That is to reduce the average number of candidate system calls
reachable to the sites of our interest (257 vs 68). With this benefit,
we do not need to test all 257 system calls4 against each of the
individual kernel modules when performing fuzz testing. As is
specified in the column of łavg. timež, this significantly reduces the
time spent on dynamically finding target system calls for object
(de)allocation and function pointer dereference (34 min vs 2 min).
With this, we can pinpoint system calls tied to object (de)allocation
and function pointer dereference in a more efficient fashion. It
should be noted that, when using the prototype-matching call graph
to guide fuzzing, we observe that SLAKE identifies less number of
system calls. This does not imply that prototype-matching call
graph cannot lead to the success of system call identification but
simply means that SLAKE cannot track down corresponding system
calls in less than 2 hours. Similarly, it should also be noted that
SLAKE cannot find the paths to all the sites of our interest not
because those sites cannot be reachable through system calls but
because SLAKE needs much longer time to dynamically pinpoint
those sites.
Comparison across kernel modules. From Table 1, we can also
observe that, for some kernel modules (e.g., BLOCK and ISO9660_FS),
SLAKE fails to identify any kernel objects useful for exploitation.
This does not mean the failure of SLAKE. Rather, it is because these
kernel modules are relatively small in code space (5,463 LOC on
average), containing less structural variables among which none of
them could potentially serve as victim or spray objects. In addition,
we discover that SLAKE tracks down less number of candidate spray
objects than that of candidate victim objects (104 vs 4). Among all 32
kernel modules plus the core kernel, there are only 3 modules truly
contributing spray objects for kernel exploitation. To understand
the shortage of spray objects, we manually examine the kernel code
and explore the reason behind this observation. We discover this is
because Linux kernel developers typically store data from userland