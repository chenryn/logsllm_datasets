m
u
N
 3000
 2500
 2000
 1500
 1000
 500
 0
App UID: 10061 (malicious)
10063 (malicious)
10060 (malicious)
10059 (malicious)
10065 (benign)
79
1900
3583
Delta (microsecond)
Fig. 9. The number of suspicious IPC calls triggered by top ﬁve apps with
three different Δ.
benign app keeps triggering IPC calls with the interval between
two IPC calls varying between 0 and 100 ms. We evaluate the
impacts of choosing different Δ on the detection accuracy.
Figure 9 illustrates the top ﬁve apps that trigger the most
numbers of suspicious IPC calls with three different values of
Δ. We observe that the top four numbers of the suspicious IPC
calls triggered by the malicious apps are signiﬁcantly larger
than the ﬁfth app with the same setting of Δ. We conﬁrm
that the top four apps in the table are all malicious apps.
Though the benign app triggers a large number of IPC calls,
the number of IPC calls is still much smaller than the number
triggered by the attacks.
D. Performance Overhead
We evaluate the response delays of our defense approach
by measuring the delays of identifying attack sources. Also,
we measure the overhead incurred by recording JGR and IPC
calls. We use the Android default build as our baseline for
comparison.
1) Response Delay: We test all vulnerable IPC interfaces
among 57 vulnerable services (i.e., 54 in system services and
3 in prebuilt apps). We observe that most of detection delays
are within one second except that it takes more than one
second to detect attacks on the three vulnerable interfaces.
In particular, it takes around 3.6 seconds to detect the attacks
to MidiService.registerDeviceServer(). Figure 3 shows that the
least time duration to construct an JGRE attack is around
100 seconds, which is much larger than 3.6 seconds. Thus,
an JGRE attack cannot evade our defense.
436
2) Computation Overhead: It is important to evaluate the
impacts of the frequent operations on recording IPC calls and
adding/removing JGR operations. To evaluate the impacts on
the IPC operations, we measures the delays of IPC calls by
delivering byte array via IPC methods. In total, we conduct
500 rounds of byte array delivery. In each round of data de-
livery, the size of the array keeps increasing with 1,024 bytes.
As shown in Figure 10, our scheme incurs maximal 1.247
milliseconds for each IPC call, and the overhead increase is
about 46.7%.
We measure the overhead of recording JGR operations by
running a pair of attack app and victim app. Our scheme does
not interfere with the JGR operation when the number of JGR
entries is less than 4,000. We do not observe any obvious
delays. After the number of JGR entries reaches to 4,000, the
recording operations incur around 1 μs delay.
We apply several optimizations to reduce the overhead and
improve the performance of our defense mechanism. First,
according to Observation 1, our defense begins to interfere
with IPC calls and collect data only when the number of JNI
creation triggered by the victim processes exceeds a threshold.
Second, the JGRE Defender is triggered only when the number
of new JGR entries exceeds 12,000 to reduce the size of
recorded data for analysis. Furthermore, we leverage a segment
tree [39] data structure to implement Algorithm 1 to reduce
the memory overhead. Segment tree is a efﬁcient tree data
structure for storing intervals (or segments), which perfectly
meets our requirement that Algorithm 1 needs to store and
process various intervals such as IP CCalls and JGRAdds.
VI. DISCUSSION
This paper studies JGRE vulnerabilities that can lead to
DoS attacks against a large number of system services and
some prebuilt apps on Android, and then we develop a defense
mechanism to mitigate the JGRE attacks. Now we discuss
some limitations of our defense and point out that the root
cause of JGRE attacks may result in other security problems.
False negatives in analyzing JGRE. Similar to the traditional
static analysis approaches, our approach may incur false
negatives on not monitoring all IPC interfaces. First, though
most apps communicate with system services via Binder
based IPCs, there still exists other IPC techniques, such as
unprotected broadcast receivers, Anonymous Shared Memory
(ASHMEM), as well as IPC via Linux sockets, pipes, and
signals. Though these techniques are rarely used by system
services to provide interfaces that can be accessed by third-
party apps, they may exist and be misused to launch JGRE
attacks. Second, we compute the parameters according to
our analysis on each IPC method during the dynamic test
stage, so we cannot guarantee to ﬁnd a complete list of IPC
vulnerabilities due to the limitation of dynamic testing.
Exploiting JGRE vulnerability via multiple attack paths.
Observation 2 assumes each IPC method only has one at-
tacking path and thus the execution time is stable; however,
attackers may exploit the vulnerabilities via multiple attack
paths. Our defense scheme can still detect
this attack by
ﬁrst classifying different IPC calls triggered by the same IPC
method according to code execution paths and then counting
the total number of IPC calls in the same categories. Then the
attacks can be identiﬁed and throttled according to the number.
DoS attack towards other resources. JGR is one of the
critical resources of Android Runtime. The root cause of
JGRE attack is that the security enforcement in the current
Android system cannot prevent authorized apps from sending
excessive service requests to consume the limited resources
allocated for system services. There may exist other resource
consumption vulnerabilities related to other system resources
such as memory, ﬁle descriptor, and internal storage. Our
defense cannot be directly applied to prevent the DoS attacks
against other resources; however, it may trigger some of our
future research.
VII. RELATED WORK
JNI Security. JNI security has been well studied. Tan et
al. [45] analyze the native code in JDK 1.6 and ﬁnd some
bugs such as unexpected control ﬂows, bugger overﬂows, JNI
misusing, etc. Lee et al. [34] use state machines to detect
foreign function interface (FFI) violations. They build a bug
detection tools for JNI named Jinn to dynamically detect
constraint violation during a java program running. Qian et
al. [37] detect
information leakage by tracing information
ﬂows going through JNI in Android apps. Robusta [43]
uses software-based fault isolation (SFI) to isolate the native
code of a java program to a single sandbox. FlexDroid [40]
builds JNI sandboxing of Android apps using Hardware Fault
Isolation (HFI). It introduces two memory domains named JNI
domain and Java domain to isolate JNI code and Java code to
different spaces. NativeGuard [44] isolates the native library
of an Android app to a separate service app, and the rest of
the original app composes the client app.
DoS Attacks. A series of DoS attacks by exploiting vulner-
abilities of Android system services have been identiﬁed [24],
[33], [42]. Huang et al. [33] discover a design ﬂaw in the
concurrency control of Android system services and carry out
a series of DoS attack based on this ﬂaw. Shao et al. [42] focus
on security enforcement inconsistencies in Android frame-
work. Cao et al. [24] focus on the vulnerabilities happened
in the input validation of Android SS interfaces. In addition,
DoS attacks could also be triggered by the depletion of some
Android system resources. Lineberry et al. [35] successfully
launch a DoS attack by popping up a lot of toasts which results
in the restart of the device. This vulnerability has been ﬁxed
since Android 4.0. The use of Flash SMS can also leads to DoS
attack [21], causing the phone restart and the disconnection
of the network. The vulnerability has been ﬁxed in Android
4.4.2. Armando et al. [16] trigger DoS attacks through forking
a lot of Zygote processes. Viadyanathan et al. [22] extract
and monitor the key variables occurring in the early part of
DoS attacks. Our work focuses on the DoS attacks on the JNI
global reference resources that may be manipulated through
IPC interfaces.
Android Out Memory Management. Linux adopts out-of-
memory (OOM) killer [11] to handle low memory conditions.
However, since it
incurs signiﬁcant performance degrada-
tion [19], Android uses low memory killer (LMK) to recover
the system during low memory circumstances. LMK classiﬁes
process into different groups using oom score adj. In low
memory situation, it kills apps with a victim selection process
based on oom score adj. There are some works on predicting
apps that users may still want to use to improve the effective-
ness of LMK [48], [50]. Furthermore, Baik et al. [19] presents
a policy-extendable LMK ﬁlter framework to enhance LMK
victim selection mechanism.
Similar to LMK, our defense mechanism is also triggered
when processes or the system run short of resources (e.g.,
JGR or memory), and then attempts to ﬁnd and kill suspicious
apps based on their scores. However, there is a big difference
between LMK and our defense. In Android, it is easy to
know how many memory occupied by each process, but it
is challenging to ﬁnd how many JGR creation are triggered
by each app. Therefore, we cannot directly leverage LMK
to defend against JGRE. In particular, JGRs add entry and
remove entry interfaces are implemented in native code, while
most of the complex functional logic code of system services is
implemented in Java. Moreover, IPC calls are invoked between
two processes, which makes it extremely difﬁcult to identify
which speciﬁc JGR creation is triggered by which IPC call
and from which app. Our defense mechanism addresses these
challenges by recording and analyzing the behaviors of each
suspicious app.
Android static analysis tools. Static analysis technology
has been studied for years, and a lot of well designed tools
have been proposed [1], [17], [28]–[31]. Kirin [28] examines
the permissions of an app to determine whether the app
may contain dangerous functions. AdRisk [31] analyzes the
permissions used in ad libraries by checking the API calls in
those libraries, and then identiﬁes possible data leakage and
dangerous paths. Flowdroid [17] is a precise context, ﬂow,
ﬁeld, object-sensitive static taint analysis framework that can
be used to detect possible sensitive data leakage in Android
apps.
437
VIII. CONCLUSION
In this paper, we systematically study the JNI Global
Reference resource exhaustion vulnerabilities in Android sys-
tem. We build a toolkit to analyze IPC methods provided
by Android system services that can be accessed by third-
party apps. We discover 54 JGRE vulnerabilities in 32 system
services and three JGRE vulnerabilities in two prebuilt apps.
Android security team conﬁrmed all our ﬁndings. Furthermore,
we develop a new defense mechanism to defend against the
JGRE attacks. We implement our mechanism in Android 6.0.1
and the experimental results show that it can successfully
prevent all known JGRE attacks with small overhead.
ACKNOWLEDGMENTS
The research is supported by the National Key Re-
search and Development Program of China under Grant
2016YFB0800102, and the National Natural Science Foun-
dation of China under Grant 61572278, 61572483, and
61502468. Kun Sun’s work is supported by U.S. Ofﬁce of
Naval Research under Grant N00014-16-1-3214 and N00014-
16-1-3216. Q. Li and L. Ying are the corresponding authors.
REFERENCES
[1] Androguard. http://code.google.com/p/androguard.
[2] Code to Fix a JGRE Vulnerability in Notiﬁcation Service. https://goo.
gl/NvsMVe.
YEobmk.
[3] Code to Fix a JGRE Vulnerability in Wiﬁ Service.
https://goo.gl/
[4] Compling with Jack. https://goo.gl/o9RYX8.
[5] DDMS. http://goo.gl/J7MBC4.
[6] Dex2jar. https://goo.gl/skfQLl.
[7] Doxygen. http://goo.gl/cy0NJL.
[8] Java Native Interface Speciﬁcation. http://goo.gl/zqHp29.
[9] Javapoet. https://goo.gl/nsIHR3.
[10] JNI Functions: Registering Native Methods. http://goo.gl/DdZb0o.
[11] Linux OOM Killer. https://linux-mm.org/OOM Killer.
[12] MonkeyRunner. https://goo.gl/xcy6ha.
[13] Processes and Application Life Cycle. https://goo.gl/Vsed4i.
[14] Procfs. https://en.wikipedia.org/wiki/Procfs.
[15] Type Erasure. https://goo.gl/qJjenO.
[16] Alessandro Armando, Alessio Merlo, Mauro Migliardi, and Luca Verder-
ame. Would You Mind Forking This Process? A Denial of Service
Attack on Android (and Some Countermeasures).
In Information
Security and Privacy Research, pages 13–24. Springer, 2012.
[17] Steven Arzt, Siegfried Rasthofer, Christian Fritz, Eric Bodden, Alexan-
dre Bartel, Jacques Klein, Yves Le Traon, Damien Octeau, and Patrick
McDaniel. FlowDroid: Precise Context, Flow, Field, Object-sensitive
and Lifecycle-aware Taint Analysis for Android Apps. PLDI ’14.
[18] Kathy Wain Yee Au, Yi Fan Zhou, Zhen Huang, and David Lie. PScout:
Analyzing the Android Permission Speciﬁcation. CCS ’12.
[19] Kunhoon Baik, Jongseok Kim, and Daeyoung Kim. Policy-extendable
In Linux Symposium,
LMK Filter Framework for Embedded System.
page 49.
[20] A. Bianchi, J. Corbetta, L. Invernizzi, Y. Fratantonio, C. Kruegel, and
G. Vigna. What the App is That? Deception and Countermeasures in
the Android User Interface. S&P ’15.
[21] Bogdan. 0class2dos. http://goo.gl/BmM6rR.
[22] J. B. D. Cabrera, L. Lewis, Xinzhou Qin, Wenke Lee, R. K. Prasanth,
B. Ravichandran, and R. K. Mehra. Proactive Detection of Distributed
Denial of Service Attacks using MIB Trafﬁc Variables-A Feasibility
Study. In Proc. Symp. IEEE/IFIP Int Integrated Network Management,
pages 609–622, 2001.
[23] Liang Cai and Hao Chen. TouchLogger: Inferring Keystrokes on Touch
Screen from Smartphone Motion. HotSec’11.
[24] Chen Cao, Neng Gao, Peng Liu, and Ji Xiang. Towards Analyzing
the Input Validation Vulnerabilities Associated with Android System
Services. ACSAC’15.
[25] Erika Chin, Adrienne Porter Felt, Kate Greenwood, and David Wagner.
Analyzing Inter-application Communication in Android. MobiSys ’11.
[26] Jonathan Crussell, Clint Gibler, and Hao Chen. Attack of the Clones:
Detecting Cloned Applications on Android Markets. ESORICS’12.
[27] William Enck, Peter Gilbert, Seungyeop Han, Vasant Tendulkar, Byung-
Gon Chun, Landon P. Cox, Jaeyeon Jung, Patrick McDaniel, and
Anmol N. Sheth. TaintDroid: An Information-Flow Tracking System
for Realtime Privacy Monitoring on Smartphones. ACM Trans. Comput.
Syst., 32(2):5:1–5:29, June 2014.
On
[28] William Enck, Machigar Ongtang, and Patrick McDaniel.
Lightweight Mobile Phone Application Certiﬁcation. CCS ’09.
[29] Adam P Fuchs, Avik Chaudhuri, and Jeffrey S Foster. Scandroid: Au-
tomated Security Certiﬁcation of Android. Technical report, University
of Maryland, 2009.
[30] Michael Grace, Yajin Zhou, Qiang Zhang, Shihong Zou, and Xuxian
Jiang. RiskRanker: Scalable and Accurate Zero-day Android Malware
Detection. MobiSys ’12, 2012.
[31] Michael C. Grace, Wu Zhou, Xuxian Jiang, and Ahmad-Reza Sadeghi.
Unsafe Exposure Analysis of Mobile In-app Advertisements. WISEC
’12.
[32] Steve Hanna, Ling Huang, Edward Wu, Saung Li, Charles Chen, and
Juxtapp: A Scalable System for Detecting Code Reuse
Dawn Song.
Among Android Applications. DIMVA’12.
[33] Heqing Huang, Sencun Zhu, Kai Chen, and Peng Liu. From System
Services Freezing to System Server Shutdown in Android: All You Need
Is a Loop in an App. CCS ’15.
[34] Byeongcheol Lee, Ben Wiedermann, Martin Hirzel, Robert Grimm, and
Kathryn S. McKinley. Jinn: Synthesizing Dynamic Bug Detectors for
Foreign Language Interfaces. PLDI ’10.
[35] Anthony Lineberry, David Luke Richardson, and Tim Wyatt. These
Aren’t The Permissions You’re Looking For. DefCon, 18:2010, 2010.
[36] Long Lu, Zhichun Li, Zhenyu Wu, Wenke Lee, and Guofei Jiang.
CHEX: Statically Vetting Android Apps for Component Hijacking
Vulnerabilities. CCS ’12.
[37] C. Qian, X. Luo, Y. Shao, and A. T. S. Chan. On Tracking Information
Flows through JNI in Android Applications. DSN’14.
[38] Siegfried Rasthofer, Steven Arzt, and Eric Bodden. A Machine-learning
Approach for Classifying and Categorizing Android Sources and Sinks.
NDSS ’14.
[39] Hanan Samet. The design and analysis of spatial data structures, volume
199. Addison-Wesley Reading, MA, 1990.
[40] Jaebaek Seo, Daehyeok Kim, Donghyun Cho, Taesoo Kim, and Insik
Shin. FLEXDROID: Enforcing In-App Privilege Separation in Android.
NDSS’16.
[41] Asaf Shabtai, Yuval Fledel, Uri Kanonov, Yuval Elovici, and Shlomi
Dolev. Google Android: A State-of-the-art Review of Security Mecha-
nisms. arXiv preprint arXiv:0912.5101, 2009.
[42] Yuru Shao, Jason Ott, Qi Alfred Chen, Zhiyun Qian, and Zhuoqing Mor-
ley Mao. Kratos: Discovering Inconsistent Security Policy Enforcement
in the Android Framework. In NDSS’16.
[43] Joseph Siefers, Gang Tan, and Greg Morrisett. Robusta: Taming the
Native Beast of the JVM. CCS ’10.
[44] Mengtao Sun and Gang Tan. NativeGuard: Protecting android applica-
tions from third-party native libraries. WiSec’14.
[45] Gang Tan and Jason Croft. An Empirical Security Study of the Native
Code in the JDK. In Usenix Security Symposium, pages 365–378, 2008.
[46] Raja Vall´ee-Rai, Phong Co, Etienne Gagnon, Laurie Hendren, Patrick
Lam, and Vijay Sundaresan. Soot - a Java Bytecode Optimization
Framework. CASCON ’99.
[47] Zhi Xu, Kun Bai, and Sencun Zhu. TapLogger: Inferring User Inputs
on Smartphone Touchscreens Using On-board Motion Sensors. WISEC
’12.
[48] Tingxin Yan, David Chu, Deepak Ganesan, Aman Kansal, and Jie Liu.
Fast App Launching for Mobile Devices Using Predictive User Context.
MobiSys ’12.
[49] Wu Zhou, Yajin Zhou, Xuxian Jiang, and Peng Ning. Detecting Repack-
aged Smartphone Applications in Third-party Android Marketplaces.
CODASPY ’12.
[50] Xun Zou, Wangsheng Zhang, Shijian Li, and Gang Pan. Prophet: What
App You Wish to Use Next. In Proceedings of the 2013 ACM Conference
on Pervasive and Ubiquitous Computing Adjunct Publication, UbiComp
’13 Adjunct.
438