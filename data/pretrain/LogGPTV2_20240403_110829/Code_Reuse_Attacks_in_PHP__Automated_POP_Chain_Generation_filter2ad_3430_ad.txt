### 优化后的文本

#### 摘要
本文介绍了我们对PHP对象注入（POI）和PHP对象污染（POP）漏洞的分析结果。我们的原型实现仅需8分钟和约2GB内存即可完成给定应用程序的POI和POP分析。我们相信，使用块和函数摘要的高效概念也适用于更大的代码库，并且我们的结果明显优于手动代码分析。

#### 评估结果概述
在以下部分，我们将介绍每个应用程序中报告的PHP对象注入漏洞的评估（见4.1节）。然后，我们将研究每个应用程序中可用的gadget数量（见4.2节），以及我们的原型能够连接到新漏洞的gadget链的数量（见4.3节）。

总体而言，我们发现了30个新的漏洞和28个先前未记录的gadget链。评估结果显示，当前原型实现遗漏了两个POI漏洞和两个已知的gadget链。此外，在一个应用程序中出现了误报情况。我们在本节中讨论了这些漏报和误报的原因。

### 4.1 POI检测在面向对象编程中的应用
首先，我们验证了原型是否能检测到CVE条目中描述的POI漏洞。表1中的POI列比较了原型报告的POI漏洞数量与每个CVE中描述的漏洞数量。在10个易受攻击的应用程序中，有8个至少检测到了一个POI漏洞。对于四个应用程序，我们的原型甚至发现了至少一个新的POI漏洞，这些漏洞在CVE中没有记录。我们认为这些漏洞在手动分析时被忽略了。我们的原型没有报告任何错误的POI漏洞。

新的POI漏洞已在最新版本的LiveZilla 5.2.0.1、Contao CMS 3.2.9 和 GLPI 0.84.5 中通过替换`unserialize()`为`json_decode()`或通过清理用户输入来修复。然而，CMS Made Simple中的POI漏洞尚未在最新版本中修复，因为没有找到gadget链。我们的原型检测到了一个新的gadget链，可以删除任意文件，并已向开发者报告该问题。Joomla中的新POI漏洞也存在于最新版本3.3.0中，我们也报告了该问题。

Open Web Analytics和WordPress中的POI漏洞未能被我们的原型检测到。Open Web Analytics中漏报的根本原因是反射分析不足，这是静态分析领域的一个未解决问题[4, 14, 22]。

```php
class owa_coreAPI {
    public static function classFactory($module, $class) {
        return owa_lib::factory(OWA_BASE_DIR . '/modules/' . $module . '/classes/', $class);
    }

    public static function getRequestParam($name) {
        $service = owa_coreAPI::classFactory('base', 'service');
        return $service->request->getParam($name);
    }
}
```

简化后的代码如上所示。在Open Web Analytics中，所有对用户输入的访问都是通过静态方法`getRequestParam()`进行的，该方法通过`classFactory()`方法获取一个新对象，并调用`getParam()`方法。由于`classFactory()`方法内部使用了反射，因此我们的原型无法获取分配给`$service`的对象信息。尽管原型仍可以识别`getParam()`方法，但该方法访问的是`request`属性的属性，这些属性是在工厂动态构造对象时填充的。我们计划在未来改进对动态OOP代码的分析。

WordPress中的漏报是基于二阶数据流[7]：用户元数据存储在数据库中，并在反序列化前加载到缓存中。数据库查询是动态构建的，我们的原型无法完全重构以识别数据流。

### 4.2 可用的POP Gadget
我们让原型报告所选应用程序中声明的所有非空魔术方法，以建立基准。平均而言，每个应用程序大约有59个潜在的初始gadget。不同数量的魔术方法如表2所示。

在我们的评估中，最常见的魔术方法是`__set()`和`__get()`方法。但由于它们只是简单地实现了缺失的getter和setter方法，因此没有一个是可利用的。在可用的gadget中，`__destruct()`方法也很常见。因为它独立于上下文，提供了最高的滥用机会。上下文相关的`__toString()`方法虽然定义频繁，但通常返回对象的字符串表示形式，滥用PHP代码的机会不高。

| 软件 | call wakeup | callStatic | set state | destruct | toString | total | unset | clone | set | get | isset |
|------|-------------|------------|-----------|----------|----------|-------|-------|-------|-----|-----|-------|
| Contao CMS | 4 | 1 | 0 | 17 | 16 | 136 | 2 | 2 | 47 | 32 | 12 |
| Piwik | 8 | 0 | 0 | 21 | 23 | 111 | 8 | 3 | 11 | 19 | 9 |
| GLPI | 0 | 0 | 4 | 1 | 5 | 77 | 0 | 0 | 43 | 23 | 1 |
| Joomla | 4 | 0 | 0 | 15 | 30 | 73 | 1 | 3 | 4 | 11 | 1 |
| CubeCart | 0 | 0 | 0 | 18 | 4 | 47 | 1 | 1 | 8 | 11 | 1 |
| Wordpress | 0 | 1 | 0 | 8 | 13 | 41 | 2 | 0 | 4 | 6 | 5 |
| CMS Simple | 1 | 0 | 0 | 3 | 7 | 41 | 0 | 2 | 8 | 15 | 2 |
| OWA | 0 | 0 | 0 | 15 | 3 | 24 | 0 | 0 | 2 | 2 | 2 |
| LiveZilla | 0 | 0 | 0 | 5 | 4 | 21 | 1 | 0 | 1 | 6 | 1 |
| Vanilla | 0 | 0 | 0 | 1 | 4 | 14 | 0 | 0 | 3 | 3 | 0 |

### 4.3 新发现的漏洞类型分布
表3显示了我们检测到的不同类型的POP gadget链中的漏洞分布。

| 软件 | FD | FC | FM | SQLi | LFI | XXE |
|------|----|----|----|------|-----|-----|
| OWA | - | - | - | - | - | 1 |
| Contao | 2 | 6 | 1 | 1 | 1 | 1 |
| CMS Simple | 11 | 1 | 3 | - | - | 2 |
| CubeCart | - | - | - | - | - | 7 |
| Joomla | 3 | - | - | - | - | 3 |
| Piwik | - | - | - | - | - | - |

### 结论
通过我们的原型实现，我们能够在短时间内高效地检测和分析POI和POP漏洞。尽管存在一些漏报和误报，但我们已经确定了改进的方向。未来的工作将集中在改进对动态OOP代码的分析，以提高检测准确性。