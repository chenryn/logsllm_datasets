execution jumps into the code under analysis (or code de-
rived from it), we record the current value of the stack
pointer, together with the current thread identiﬁer. When
executing jumps out of this code, we check whether there
is a recorded stack pointer for the current thread identiﬁer,
and if so, whether this value is smaller than the current
stack pointer. If this is the case, we remove the record as
the code is not on the stack anymore. Whenever a trusted
module propagates tainted data, we check whether there is
a recorded stack pointer under the current thread identiﬁer.
If so, we consider this tainted data being propagated by the
code under analysis. Note that the current thread identiﬁer
is mapped into a well-known virtual address in Windows.
Hence, obtaining its value is straightforward.
Note that the strategy described above will detect all
taint-related action on behalf of the malicious code, given
that they are performed in the same thread context. While
this is true most of the time, there are cases in which the
actual taint propagation occurs in an asynchronous fashion.
For example, when the code calls an API function asyn-
chronously to save the tainted data to a ﬁle, the API func-
tion immediately returns to the caller. The actual action
that is requested is performed later. We have identiﬁed sev-
eral kernel API calls (dealing with ﬁlesystem and network
access) that may be used asynchronously. When such a func-
tion is invoked, we analyze the stack pointers to determine
whether both the code under analysis is calling this func-
tion and the input buﬀer is tainted. If this is the case, we
treat this tainted buﬀer as being propagated by the analyzed
sample.
3.3 Automated Testing and Taint Graph
Generation
3.3.1 Automated Testing
The test engine in Panorama allows us to perform the
analysis of samples and the detection of malicious code with-
out human intervention. It executes a number of test cases
that mimic common tasks that a user might perform, such
as editing text in an editor, visiting several websites, and
so on. The speciﬁc test cases used in our experiments will
be discussed in Section 4.1. To automatically run tests, our
test engine is equipped with scripts that execute all steps
necessary for each test case. For our current implementa-
tion, these scripts are based on the open source program
AutoHotkey [1]. Scripts can be either manually written or
automatically generated by recording user actions while a
task is performed.
Whenever the test engine executes a certain test case, it
introduces input (such as keystrokes or network packets) into
the system. To determine which part of this input should
be tainted (and with which taint label), the test engine co-
operates with the taint engine. Currently, our system de-
ﬁnes the following nine diﬀerent types of taint sources: text,
password, HTTP, HTTPS, ICMP, FTP, document, and di-
rectory, which will be discussed in Section 4.1. For example,
when editing a document in an editor, the test engine asks
the taint engine to send keystrokes to the editor, and label
them as text; when entering password in a secure web form,
the test engine asks the taint engine to send keystrokes and
label them as password. When considering these cases, it
becomes evident that the taint engine requires support from
the test engine to properly label input. In both cases, the
keystroke information enters the system. However, in the
former case, the keystroke is considered text as it is sent to
the one of the text editors.
In the latter, the recipient of
the input is a password ﬁeld and the keystroke information
is marked as password. Clearly, this information is test-
speciﬁc and not available at the hardware level. The data
received as a response to the web requests are tainted as
HTTP. The packets received in response to ping requests
are labeled ICMP. The information sent by the FTP server
are marked FTP. Finally, when listing a directory, all ac-
cessed disk blocks that hold ﬁle directory information are
tainted as directory. The communication between the test
engine and the taint engine is via an intercepted registry
writing API: the test engine writes information into a pre-
determined registry entry, and taint engine intercepts this
API call and then obtains the information.
3.3.2 Taint Graph Generation
The system-wide propagation of tainted input introduced
by the test engine forms a graph over the processes/program
modules and OS resources. For example, assume that a
keystroke is tainted as text because it is part of the input sent
to a text editor. When a user process A reads the character
that corresponds to the keystroke, this fact is recorded by
linking the text taint source to process A. When this process
later writes the character into a ﬁle F, from where it is then
read by process B, we can establish a link from process A
to the ﬁle, and subsequently from ﬁle F to process B. For
clarity, we generate one graph for each taint source with a
diﬀerent label (that is, one graph that shows the ﬂow of data
labeled as text, one for password, . . . ). For each taint source,
the taint propagation originating from this source forms a
directed graph. We call this graph a taint graph.
More formally, a taint graph can be represented as g =
(V, E), where V is a set of vertices and E is a set of directed
edges connecting the vertices, and we use g.root to represent
the root node of graph g (i.e., the taint source). A vertex
can either represent an operating system object (such as a
process or module), an OS resource (such as a ﬁle), or a
taint source (such as keyboard or network input with the
appropriate labels). An edge between two vertices v1 and
v2 is introduced when tainted data is propagated from the
entity that corresponds to v1 to the entity that corresponds
to v2.
When generating the taint graphs, the taint engine maps
the hardware-level taint propagation information to operating-
system level. For example, the taint engine determines which
process and which module (such as which dll) has per-
formed a certain operation, and it also keeps track of whether
this operation is performed on behalf of the sample under
analysis. Also, writes to disk blocks are attributed to ﬁle
objects and network operations to speciﬁc network connec-
tions. To further simplify the taint graphs, we apply the
following optimizations, without losing the dependencies be-
tween the sample under analysis and other objects: (1) we
make the vertices for system kernel modules transparent; (2)
for user-level instructions, if they are not derived from the
sample under analysis (i.e., they are trusted), they are at-
tributed to the processes they are running in, instead of the
modules they are from.3
In a taint graph, each vertex is labeled with a (type, value)
pair, where value is the unique name that identiﬁes the ver-
tex. For the root node, the type is one of the nine diﬀerent
input taint labels introduced previously. For any non-root
node, the type represents the category of the node as a OS
object, including process, module, keyboard, network, and
ﬁle. Formally, the type of a vertex can be deﬁned in a hier-
archical form, as follows:
type ::= taint_source | os_object
taint_source ::= text | password | HTTP | HTTPS| FTP
| ICMP | document | directory
os_object ::= process | module | network | file
Figure 2 shows an example of a taint graph. We use el-
lipses to represent process nodes and use shaded ellipses to
represent the module node. We use an octagon to represent
the taint source (here, a password typed on the keyboard),
3In other words, the presence of a module node in a taint
graph indicates at least one instruction of this module stems
from the sample.
password
Winlogon.exe
lsass.exe
Winlogon.exe!mscad.dll
c:\ginalog.log
Figure 2: An example of taint graph. This graph
reﬂects the procedure for Windows user authenti-
cation. While a password thief is running in the
background, it catches the password and saves them
to its log ﬁle “c:\ginalog.log”.
and a rectangle to represent the other nodes. We will give
more description of this graph in Section 4.2.
4. TAINT-GRAPH-BASED MALWARE
DETECTION AND ANALYSIS
In this section, we describe how taint graphs can be used
to detect malware, and how they help to understand the
actions of malicious code,
4.1 Taint-Graph-Based Malware Detection
Our essential observation is that numerous types of mali-
cious code, including keyloggers, password thieves, network
sniﬀers, stealth backdoors, spyware/adware, and rootkits,
exhibit anomalous information access and processing behav-
ior. Currently, we categorize three kinds of anomalous be-
havior: anomalous information access, anomalous informa-
tion leakage, and excessive information access.
Anomalous information access behavior.
For some information sources, a simple access performed
by the samples under analysis is already suspicious. We refer
to this behavior as anomalous information access behavior.
Considering the keyboard inputs, such information sources
may include the text input sent to the text editor, the com-
mand sent to the command console, and the passwords sent
to the Windows Logon dialog and secure web pages. Benign
samples do not access these inputs, whereas keyloggers and
password thieves will access these inputs. Keyloggers refer
to the malicious programs that capture keystrokes destined
for the other applications, and thus will access all these in-
puts. Password thieves, by deﬁnition, steal the password
information, and therefore will access the password inputs.
Note that password thieves can be a subset of keyloggers,
because keyloggers may also record passwords.
Similarly, some network inputs are not supposed to be
accessed by unknown samples. For example, ICMP is de-
signed for network testing and diagnosis purpose, and hence
only operating system and trusted utilities (e.g. ping.exe)
use it. For many TCP and UDP applications, the incoming
TCP and UDP traﬃc can only be accessed by their own and
the operating system. Benign samples do not interfere with
the process of these inputs. However, network sniﬀers and
stealth backdoors access these inputs for diﬀerent purposes.
Network sniﬀers eavesdrop on the network traﬃc to obtain
valuable information. Even though a network sniﬀer may
not be directly interested in these inputs, it usually has to
access them to check if they are valuable. Stealth backdoors
refer to a class of malicious programs that contact with re-
mote attackers without explicitly opening a port. To achieve
stealthiness, the stealth backdoors either use an uncommon
Test case description
1. Edit a text ﬁle and save it
2. Enter password in a GUI program password
3. Log in a secure website
4. Visit several websites
5. Log into an FTP server
6. Recursively list a directory
7. Send UDP packets into the system UDP
8. Ping a remote host
ICMP
Introduced inputs
text, document
URL, password, HTTPS
URL, HTTP
text, password, FTP
directory
Table 1: The test cases and introduced inputs.
.
protocol such as ICMP, create a raw socket, or intercept the
network stack, in order to communicate with remote adver-
saries. The ICMP-based stealth backdoors will access ICMP
traﬃc. The raw-socket-based stealth backdoor will access all
the packets with the same protocol number. For example, a
TCP raw socket will receive all TCP packets. The stealth
backdoors intercepting the network stack will behave like a
network sniﬀer.
Anomalous information leakage behavior.
For some other information sources, it is acceptable for the
samples to access them locally, but unacceptable to leak the
information to third parties. For example, spyware/adware
programs record users’ surﬁng habits and send this private
information to third parties. In contrast, benign BHOs (i.e.,
Browser Helper Objects) may access this information but
will not send it out. We consider the following as informa-
tion leakage: the sample under analysis accesses the infor-
mation and then saves it to disk or sends it over the network.
Note that saving the information to disk covers three situ-
ations: saving it to ﬁles, the registry, and even individual
disk blocks. We consider information sources like HTTP,
HTTPS, documents, and URLs fall into this category.
Excessive information access behavior.
For some information sources, benign samples may access
some of them occasionally, while malicious samples will ac-
cess them excessively to achieve their malicious intent. We
refer to it as anomalous information excessive access behav-
ior.
The directory information is such a case. Rootkits exhibit
excessive access behavior to the directory information, be-
cause they attempt to conceal their presence in the ﬁlesys-
tem by intercepting the accesses to directory information
and removing the entries that point to their ﬁles. Thus,
when recursively listing directories, we will see the rootkit
samples accessing many disk blocks that contain directory
information. A benign program may access some directory
entries, or even scan directories occasionally. However, it
is very unlikely that it accesses the same directories at the
same time while we list directories.
Test cases and policies.
According to the above discussion, we compile the follow-
ing test cases and introduce the inputs with corresponding
labels, as shown in Table 1. Speciﬁcally, we introduce text,
password, URL inputs from the keyboard, HTTP, HTTPS,
FTP, ICMP, and UDP inputs from the network, and doc-
ument and directory input from the disk. Note that in the
test case 6, to eliminate the possibility that a benign pro-
gram scans the same directory at a diﬀerent time, we clean
the taint labels of the visited directory entries after ﬁnishing
with listing the directory. After ﬁnishing all the test cases,
the test engine waits for a while (a conﬁgurable parameter)
and then shuts down the guest machine.
From the above discussion, we specify the following poli-
cies: (1) text, password, FTP, UDP and ICMP inputs cannot
be accessed by the samples; (2) URL, HTTP, HTTPS and
document inputs cannot be leaked by the samples; (3) direc-
tory inputs cannot be accessed excessively by the samples.
More formally, we show how these policies are enforced on
the taint graphs:
∀g ∈ G, (∃v ∈ g.V, v.type = module) ∧
g.root.type ∈ {text, password, FTP, UDP, ICMP}
→ V iolate(v, “No Access
(cid:2)(cid:2)
)
(1)
∃g ∈ G, (∃v ∈ g.V, v.type = module) ∧
(g.root.type ∈ {URL, HTTP, HTTPS, document}) ∧
(∃u ∈ descendants(v), u.type ∈ {file, network})
→ V iolate(v, “No Leakage!
(cid:2)(cid:2)
);
(2)
(∀g ∈ G, g.root.type = directory →