G
0
1
C
T
H
P
6
s
u
x
e
N
Device
L
X
3
l
e
x
i
P
5
Y
i
e
y
a
w
u
H
+
8
S
y
x
a
l
a
G
" " " "
X
8
r
o
n
o
H
"
8
P
i
e
a
w
u
H
1
A
M
i
s
X
e
n
o
h
p
I
B
S
U
m
o
c
o
b
i
F
"
"
"
"
"
" "
" "
"
"
"
" "
"
"
"
"
" " " "
"
"
"
" " " " "
" " "
"
"
" " " " " " " "
" " " "
" " " " " " " "
" " " "
"
"
" " " "
"
"
"
"
" " "
D
NAS
✓
✓
✓
✓
✓
RRC
U
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
Previous issues
✓
✓
(E16) Replayed sm_command [32]
(E17) Downgraded RRC_sm_command
acceptance [47]
Table 3: Deviations identified by DIKEUE. E- exploitable, I- interoperability issue, EI- both exploitable and an interoperability
issue, O- other deviating behavior, D- deviation from standards, U- underspecification
" " " "
"
"
"
"
accepts downgraded RRC_sm_command with the choice of integrity
algorithm EIA0. This makes the implementation vulnerable to Man-
in-the-Middle attacks. The attack was first identified and described
by Rupprecht et al. [47] for a Huawei USB dongle.
9 COMPARISON WITH BASELINE (RQ2)
We compare the effectiveness of DIKEUE with the conformance test-
ing framework defined in the 3GPP specification [5] and property-
guided testing by previous approaches [12, 19, 30, 32, 37].
9.1 Comparison with conformance test cases
We first compare the performance of DIKEUE with the 3GPP con-
formance test cases [5] based on two criteria: (i) test coverage; (ii)
identified deviant behavior issues. Since it is not possible to cal-
culate coverage from a black-box UE implementation, such as an
iPhone, we apply DIKEUE to srsUE [6] v20.10.1– the open-source
implementation by srsLTE [6]. We use the percentage of lines and
functions executed, which are obtained by Gcov [3], as the indi-
cator for code coverage. Since we are considering only the NAS
and RRC layers of the UE implementation, we do not compute the
percentage of lines covered with respect to the total number of
i =1 Le(fi)/m
coverage as:m
lines and functions in srsUE. Instead, we calculate the percentage of
lines covered within each function and only take into account the
functions that are related to our analysis. Therefore, let Le(f ) be
the number of lines executed of function f in the srsUE implemen-
tation and L(f ) be the total number of lines of f , we define the line
i =1 L(fi) and function coverage as: n/m
where f1, f2, . . . , fm are the functions relevant to NAS and RRC
layer and f1, f2, . . . , fn are functions executed in srsUE. For the
baseline coverage, we identify the 88 test cases related to the RRC
and NAS analysis from the 3GPP conformance test cases [5] and
run them on the srsUE implementation and calculate the line and
function coverage of all the test cases. The rationale is to compare
how DIKEUE covers compared to the standard defined test cases.
The conformance testing has line coverage of 82.58% and func-
tion coverage of 83.4375%, whereas DIKEUE performs significantly
better with 89.47% line coverage and 89.185% function coverage.
We also apply the 88 test cases to the 14 devices. In case the
same conformance test case induces different outputs in different
implementations, we note it as a deviant behavior. Through the
conformance test cases, only 2 deviating behavior can be captured,
compared to the 17 issues automatically identified by DIKEUE.
Session 4B: Wireless, Mobile, and IoT CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1092Paper
Auto-
matic
Specific-
ation
analysis
Impleme-
ntation
analysis
Under-
specificat-
ion
detection
Stateful
Approach
DIKEUE
DIKEUE w/o cache
DIKEUE w/o
optimizations
DIKEUE w/o
inconsistency
resolver
✗
✗
✗
✓
✗
✗
✗
✗
✓
✓
✗
✗
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✓
✗
✗
✗
✗
✗
✓
✓
✗
✓
✓
LTEFuzz [39]
LTEInspector [30]
5GReasoner [32]
5G-
Authentication [12]
5G-AKA [19]
ProChecker [37]
DIKUE
Table 4: Comparison with existing approaches.
9.2 Comparison with existing LTE works
Table 4 compares our approach with existing LTE testing approaches
based on several criteria such as automation, specification, imple-
mentation analysis, and stateful testing.
9.2.1 Comparison with LTEFuzz. LTEFuzz [39] is a recent approach
for dynamic testing of LTE protocol based on stateless dynamic test-
ing with pre-generated test cases. In contrast to LTEFuzz, DIKEUE
is different from few angles. First, DIKEUE not only performs dy-
namic testing but also automatically reconstructs the FSM of the
underlying UE implementation, allowing in depth analysis. Second,
DIKEUE can uncover stateful vulnerabilities, whereas the analysis
done by LTEFuzz is stateless. For instance, it is not possible for
LTEFuzz to uncover the Replayed GUTI_reallocation (discussed in
section 8.1.1) attack discovered by DIKEUE and acknowledged by
both Qualcomm and Samsung as a high-severity issue. This is be-
cause the attack is triggered only at a specific state of the protocol
implementation, not for a GUTI_reallocation packet replayed at an arbi-
trary protocol state. Therefore, the testcases generated by stateless
property guided testing of LTEFuzz will not be able to generate
such a stateful testcase that can trigger such a vulnerability.
9.2.2 Comparison with property-guided testing. Previous work [12,
19, 30, 37] has applied property-guided testing on FSMs derived
from standards [12, 19, 30, 37] or extracted from white-box anal-
ysis [37]. To compare DIKEUE with the property-guided testing
approaches, we test the properties from previous approaches and
run model checking on the FSMs derived from the implementations.
As the previous properties are all for the NAS layer only, for a
fair comparison, we only test for NAS layer property violations.
Through property-guided testing, we identify 3 deviations (E2, E5,
O9) among the 10 issues found by DIKEUE in the NAS layer.
10 COMPONENTS PERFORMANCE (RQ3)
We now evaluate the performance of DIKEUE’s main components.
10.1 FSM inference module performance
Table 2 shows the number of states and transitions in the inferred
models for 14 devices. Each model includes on an average 22 states
and around 600 transitions. There are certain notable exceptions in
the model learning phase for different devices. For instance, both
the MediaTek phones (HTC One E9+ and Huwaei Y5) require sub-
stantially more queries and time to learn the models. This is because
MediaTek phones require at most 6 alphabets (i.e., input symbols),
including RRC_sm_command and RRC_reconf in a specific sequence, to
complete the attach procedure. Consequently, it takes the learner
more time to generate this specific sequence of messages, and with-
out it none of the future procedures, i.e., GUTI reallocation, tracking
area update, service procedure, etc., can proceed.
Total
M
5756
5756
5756
5756
1416
1416
1416
1416
E
4340
4340
4340
4340
# Queries
Adapter
context-
violations
1620
1968
0
896
Read