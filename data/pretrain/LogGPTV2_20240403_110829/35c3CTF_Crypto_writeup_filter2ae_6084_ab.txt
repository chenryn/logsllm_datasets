        key = SystemRandom().getrandbits(bitlength)
        key = BitVector(size=bitlength, intVal = key)
        return key
密钥为随机生成的48bit,并构成一个向量。继续分析加密过程，在加密之前，会对输入的内容做一个编码：
    def add_encoding(self, message):
            message = int.from_bytes(message, 'big')
            message = BitVector(size=self.key_length // 3, intVal=message)
            out = BitVector(size=self.key_length)
            for i, b in enumerate(message):
                out[i*3 + 0] = b
                out[i*3 + 1] = b
                out[i*3 + 2] = b
            return out
该编码过程会把输入的２个字节先转换为长为16的比特向量，随后会将这个向量复制２次，构成一个与key等长的长为48的比特向量。比如输入的message为`b"AC"`,得到的编码结果为`000111000000000000000111000111000000000000111111`之后才会真正进行加密。
    def encrypt(self, message):
            message = self.add_encoding(message)
            columns = [
                BitVector(
                    size=self.key_length,
                    intVal=self.random.getrandbits(self.key_length)
                )
                for _ in range(self.key_length)
            ]
            # compute the noiseless mask
            y = matrix_vector_multiply(columns, self.key)
            # mask the message
            y ^= message
            # add noise: make a third of all equations false
            for i in range(self.key_length // 3):
                noise_index = self.random.randrange(inverse_error_probability)
                y[i * 3 + noise_index] ^= 1
            columns = [bitvector_to_bytes(c) for c in columns]
            columns = b"".join(columns)
            return columns + bitvector_to_bytes(y)
首先，会随机生成48个长为48比特的向量，构成矩阵columns，随后该矩阵与Key向量相乘再异或编码后的message向量。用公式描述如下：
运算完成后还会有一个`add
noise`的过程，简单来说就是对于`Y`，每3个比特中就会有一个比特被随机翻转，生成`Y'`。最后会将比特序列`columns |
Y'`转换为字节输出。密文输出的长度为`(48*48+48)/8=294=0x126`个字节。  
同时出题人还给出了解密脚本，其基本原理为，已知columns和key，可以有:
生成的`X'`中，每三个比特会有１个比特的噪音，可以从３个比特中挑选出相同的两个来去除噪音，最后获得`X`即明文。
### 解题思路
总结一下题目的已知条件
  1. 我们有flag加密后的密文
  2. 我们有解密算法，需要恢复key
  3. 我们有若干组明密文对
  4. 如果没有噪音，给我们一组明密文对`M`,`C`,w我们有如下等式
根据数学运算性质，我们有
也就是说，如果没有噪音，我们可以很方便的恢复key。那我们该如何去除噪音呢？  
一个简单的思路是加密一次共引入16个噪音，每个噪音有３个可能位置，一共有3^16^种情况。可以通过穷举来去除噪音，对恢复Key。对于每一个恢复出的key，可以用其解密后续的密文，并与对应的明文比较，来判断key是否恢复正确，需要注意的是对于一组明密文对，可能有多个满足条件的key，导致多解的出现，因此可以多挑选几组明密文对来进行检查。此外，因为爆破量较大，因此用c实现。具体思路如下:
  1. 选取某一个明密文对C,M,Cols (脚本是选的flag的开头两个字母'35'及其对应的密文)
  2. 穷举3^16^种噪音，从中挑选出一个噪音E
  3. 用噪音E对C进行去噪得到Y
  4. 用Y,M,Cols 根据公式可以恢复出Key，其中求逆矩阵通过sage完成
  5. 选取若干组明密文对（脚本选取了２组）
  6. 用恢复的Key解密这些密文，并把解密结果与明文比较
  7. 如果结果与明文存在不匹配，则恢复错误，回到第２步
  8. 如果匹配则用Key对完整的flag进行解密
  9. 对于所有解密出的flag，人工判断是否是正确解
我的脚本选取了２组明密文对对Key进行检查，运行10分钟遍历了所有的情况。最后只得到了一个解,并且这个解的确解出了正确的flag。我的脚本如下，其中部分基础函数来自于
### 解题脚本
    #include 
    #include 
    #include 
    #include 
    #include 
    void print_array(int *mask, int len) {
      for (int i = 0; i < len; i++) {
        printf("%d, ", mask[i]);
      }
      puts("");
    }
    int cols0[48][48] = {
        {0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0,
         1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0},
        {1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0,
         0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0},
        {0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1,
         1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0},
        {0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
         1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1},
        {0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1,
         0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1},
        {0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1,
         1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1},
        {1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1,
         0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0},
        {0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1,
         1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0},
        {1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1,
         1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0},
        {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1,
         1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1},
        {1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0,
         0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0},
        {0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0,
         0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0},
        {1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1,
         0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1},
        {0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0,
         1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1},
        {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0,
         0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0},
        {1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0,
         1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1},
        {0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0,
         1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0},
        {0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1,
         1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0},
        {1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1,
         1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1},