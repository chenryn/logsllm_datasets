Migrating Oracle
queries to PostgreSQL
PGConf.EU 2012
Prague, Czech Republic
October 26th
Alexey Klyukin,
Command Prompt, Inc.
Photo by flickr member Nils Rinaldi
(http://www.flickr.com/people/nilsrinaldi/)
Why?
•
Unsupported and outdated Oracle version
•
PostgreSQL is mature
•
Cost-effective
•
Query conversion is easy
Why?
•
Unsupported and outdated Oracle version
•
PostgreSQL is mature
•
Cost-effective
•
Query conversion is easy, in theory :-)
•
Oracle 8i (8.1.6) >>> PostgreSQL 9.1
•
500GB financial database
•
Oracle-specific queries and data types
•
No triggers or stored procedures
•
Automated QA for the conversion
How?
•
Data migration
•
Query migration
•
Reports
•
Results comparison
Data migration
•
CSV dump
•
Ora2Pg
•
Oracle Foreign Data Wrapper (FDW)
•
Cross-database replication
Query conversion
•
Oracle-style outer joins
•
Pseudocolumns (i.e. ROWNUM)
•
START WITH ... CONNECT BY
•
Oracle-specific functions
Outer joins
•
Oracle (+) syntax denotes the nullable side
•
FULL OUTER JOINS are only possible via a
hack in Oracle 8i and below
•
Support for ANSI style JOINS introduced in
Oracle 9i
Left outer joins
Oracle PostgreSQL
SELECT * FROM SELECT * FROM
foo, bar WHERE foo LEFT OUTER JOIN bar
foo.baz = bar.baz (+) ON (baz)
Right outer joins
Oracle PostgreSQL
SELECT * FROM SELECT * FROM
foo, bar, baz foo LEFT OUTER JOIN bar
WHERE ON (foo. id = bar.id)
foo.id = bar.id (+) AND RIGHT OUTER JOIN baz
foo.id (+) = baz.id ON (foo.id = baz.id)
Full outer joins
Oracle PostgreSQL
SELECT * FROM
foo, bar WHERE
foo.id = bar.id (+)
SELECT * FROM
UNION ALL
foo FULL OUTER JOIN bar
SELECT * FROM
ON (foo.id = bar.id)
foo, bar WHERE
foo.id (+) = bar.id AND
foo.id = NULL
Pseudocolumns
•
ROWID and ROWNUM
•
CURRVAL and NEXTVAL
•
LEVEL
Oracle ROWNUM
•
Limiting the number of rows returned by a
query
•
Enumerating rows
ROWNUM vs LIMIT
Oracle PostgreSQL
SELECT * FROM SELECT * FROM
foo foo
ORDER BY id ORDER BY id
WHERE ROWNUM <= 10 LIMIT 10
ROWNUM vs LIMIT
Oracle PostgreSQL
SELECT * FROM SELECT * FROM
foo foo
ORDER BY id ORDER BY id
WHERE ROWNUM <= 10 LIMIT 10
ORDER BY is
processed AFTER
ROWNUM
ROWNUM vs LIMIT
Oracle PostgreSQL
SELECT *
SELECT * FROM
(SELECT * FROM
foo
foo
ORDER BY id
ORDER BY id)
LIMIT 10
WHERE ROWNUM <= 10
Enumerating rows
•
In Oracle — ROWNUM:
SELECT ROWNUM, id FROM foo;
UPDATE foo SET bar = bar ||‘# ‘|| ROWNUM
•
In PostgreSQL — window functions
Enumerating rows
•
Window functions - PostgreSQL 8.4 and
above (SQL:2003 standard compliant)
•
Calculation over a set of rows
•
Like aggregates, but without grouping the
output into a single row
•
Supported in Oracle 9i and above
Enumerating rows
Oracle PostgreSQL
SELECT row_number()
SELECT ROWNUM, foo OVER (ORDER BY id) as
FROM bar ORDER BY id rownum, foo FROM bar
ORDER BY id
Row physical address
•
Oracle — ROWID
OOOOOO.FFF.BBBBBB.RRR
(OBJECT.FILE.BLOCK.ROW)
•
PostgreSQL — CTID (block no, tuple index)
•
Identify rows uniquely
•
Not persistent, not usable as a key
ROWID vs CTID
Oracle PostgreSQL
DELETE FROM duplicates
DELETE FROM duplicates
WHERE ROWID =
WHERE ctid = (SELECT
(SELECT min(ROWID)
min(ctid) FROM duplicates)
from duplicates)
CONNECT BY
•
Traverses hierarchical data
•
Supports advanced features like cycle
detections
•
Oracle-specific
CONNECT BY
CREATE TABLE staff
(id NUMBER PRIMARY SELECT name FROM staff
KEY, name START WITH name =
VARCHAR2(100), ‘John’ CONNECT BY
manager_id NUMBER) manager_id = PRIOR id
Gets all direct or indirect subordinates of John
"CONNECT BY" EXAMPLE: STEP 1
SELECT name FROM staff
START WITH name=‘John’
CONNECT BY
MANAGER_ID = PRIOR ID
ID 1 2 3 4 5
NAME John Paul Anna Peter Steve
MANAGER_ID 1 1 2 4
RESULT: (‘John’)
"CONNECT BY" EXAMPLE: STEP 2
SELECT name FROM staff
START WITH name=‘John’
CONNECT BY
MANAGER_ID = PRIOR ID
ID 1 2 3 4 5
NAME John Paul Anna Peter Steve
MANAGER_ID 1 1 2 4
RESULT: (‘John’, ‘Paul’)
"CONNECT BY" EXAMPLE: STEP 3
SELECT name FROM staff
START WITH name=‘John’
CONNECT BY
MANAGER_ID = PRIOR ID
ID 1 2 3 4 5
NAME John Paul Anna Peter Steve
MANAGER_ID 1 1 2 4
RESULT: (‘John’, ‘Paul’, ‘Peter’)
"CONNECT BY" EXAMPLE: STEP 4
SELECT name FROM staff
START WITH name=‘John’
CONNECT BY
MANAGER_ID = PRIOR ID
ID 1 2 3 4 5
NAME John Paul Anna Peter Steve
MANAGER_ID 1 1 2 4
RESULT: (‘John’, ‘Paul’, ‘Peter’, ‘Steve’)
"CONNECT BY" EXAMPLE: STEP 5
SELECT name FROM staff
START WITH name=‘John’
CONNECT BY
MANAGER_ID = PRIOR ID
ID 1 2 3 4 5
NAME John Paul Anna Peter Steve
MANAGER_ID 1 1 2 4
RESULT: (‘John’, ‘Paul’, ‘Peter’, ‘Steve’, ‘Anna’)
"CONNECT BY" EXAMPLE: FINISH
SELECT name FROM staff
START WITH name=‘John’
CONNECT BY
MANAGER_ID = PRIOR ID
ID 1 2 3 4 5
NAME John Paul Anna Peter Steve
MANAGER_ID 1 1 2 4
RESULT: (‘John’, ‘Paul’, ‘Peter’, ‘Steve’, ‘Anna’)
Recursive Common Table
Expressions (CTEs)
•
AKA ‘WITH RECURSIVE’ queries
•
Supported since PostgreSQL 8.4
•
SQL compliant way of dealing with
hierarchical data
•
Very powerful
WITH RECURSIVE
WITH RECURSIVE st (id, name, manager_id) AS
(SELECT id, name, manager_id FROM staff
where name = ‘John’
CREATE TABLE staff (id INTEGER
PRIMARY KEY, name TEXT, UNION ALL
manager_id INTEGER)
SELECT id, name, manager_id FROM staff cur, st
prev WHERE cur.manager_id = prev.id)
SELECT * FROM st
Recursive CTE EXAMPLE: STEP 1
WITH RECURSIVE st (id, name, manager_id) AS (SELECT id, name, manager_id FROM staff
where name = ‘John’
UNION ALL
SELECT id, name, manager_id FROM staff cur, st prev WHERE cur.manager_id = prev.id)
SELECT * FROM st
ID 1 2 3 4 5
NAME John Paul Anna Peter Steve
MANAGER_ID 1 1 2 4
RESULT: (‘John’)
Recursive CTE EXAMPLE: STEP 2
WITH RECURSIVE st (id, name, manager_id) AS (SELECT id, name, manager_id FROM staff
where name = ‘John’
UNION ALL
SELECT id, name, manager_id FROM staff cur, st prev WHERE cur.manager_id = prev.id)
SELECT * FROM st
ID 1 2 3 4 5
NAME John Paul Anna Peter Steve
MANAGER_ID 1 1 2 4
RESULT: (‘John’, ‘Paul’)
Recursive CTE EXAMPLE: STEP 3
WITH RECURSIVE st (id, name, manager_id) AS (SELECT id, name, manager_id FROM staff
where name = ‘John’
UNION ALL
SELECT id, name, manager_id FROM staff cur, st prev WHERE cur.manager_id = prev.id)