# 一文搞定MySQL盲注
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 0x00 前言
无论是CTF还是实战渗透测试中，SQL注入都是一个非常热门的漏洞。通常人们根据SQL注入是否有回显将其分为有回显的注入和无回显的注入，其中无回显的注入顾名思义就是大家常说的盲注了。但是盲注不像union联合查询直接注出结果那么明了，利用起来也不是简单一两行SQL代码就可以完成，因此难度更大一些。  
目前的CTF中MySQL的盲注依然是热点之一，然而盲注又被分成Like盲注、正则盲注、异或盲注等等太多类型，让新入门的萌新十分摸不到头脑。本文希望以言简意赅的语言帮助刚入门WEB
CTF的选手们快速“拿捏”MySQL盲注。
PS：其他关系型数据库(比如postgresql/sqlite)的盲注都大同小异，语法略有不同，会了MySQL然后再去看看其他数据库的语法和文档基本别的数据库就也会了。目前CTF中十有八九是MySQL，所以本文也就全部讲MySQL了。
## 0x01 盲注介绍
###  什么是盲注？
首先盲注是SQL注入的一种，SQL注入是指：WEB应用程序没有对用户的输入进行足够的安全校验，用户的输入被拼接进SQL语句并执行该SQL语句，由于用户输入了一些满足SQL语句语法的字符，拼接进SQL语句后执行最终导致数据库执行了本不应该被执行的非法操作。
举个例子（以下全文都用这个例子），一个学生信息查询系统，输入学生学号就会返回学生的姓名和专业，实际上就是执行的`SELECT name,majority
FROM student WHERE student_id = '$id';`
正常情况下用户输入的是一个学号，那么返回该学生的信息。如果用户输入的是`123' or '1'='1`，整个语句就变成了`SELECT
name,majority FROM student WHERE student_id = '123' or '1'='1';`会返回所有学生的信息。
而盲注是在SQL注入的基础上，根据SQL注入的回显不同而定义的。以上面这个例子为例，用户输入学号，WEB程序打印出该学生的姓名和专业，这个姓名和专业是数据库里存储的具体数据，而WEB程序将这个数据库里的数据原封不动的告诉
我们了，这种就叫有回显。而无回显是指，WEB程序不再告诉我们具体的数据了，可能只告诉我们说：“查询成功”、“查询失败”，甚至可能只说一句“查询完成”或者什么都不说。虽然我们并不能直接得到数据库中的具体数据，但是SQL语句的拼接发生了、非法的SQL语句也执行了，那么SQL注入就发生了，只是SQL注入的结果我们没有直接拿到罢了。
虽然是无回显的，但也并不意味着就无从下手了，盲注正是为了针对这种情况的！盲注更像是一种爆破、一种无脑测试，具体注入的时候，比如想注入数据库名，攻击者在做这样的事：
    如果"数据库名"的第1个字母是a，你就说“查询成功”，否则就说“查询失败”
    如果"数据库名"的第1个字母是b，你就说“查询成功”，否则就说“查询失败”
    如果"数据库名"的第1个字母是c，你就说“查询成功”，否则就说“查询失败”
    ...
    如果"数据库名"的第2个字母是a，你就说“查询成功”，否则就说“查询失败”
    如果"数据库名"的第2个字母是b，你就说“查询成功”，否则就说“查询失败”
    如果"数据库名"的第2个字母是c，你就说“查询成功”，否则就说“查询失败”
    ...
这样通过不断的测试，最终根据WEB程序返回的“查询成功”和“查询失败”，攻击者判断出了想注入数据的每一位是什么，那么就也能够得到这个数据的具体值了。最后补充一下，这里所说的“查询成功”和“查询失败”，是指WEB程序的回显，而这个回显基本上是由SQL语句查询是否成功（也就是SQL语句是否查询出数据）决定的，而SQL查询结构是被`WHERE`子句所控制的，所以攻击者一般就是对`WHERE`子句进行构造。
###  盲注有哪些分类？
总体来讲，盲注分为布尔型和延时型两大类。
布尔型就是上面所说的“查询成功”和“查询失败”，根据SQL语句查询的真和假，WEB程序有两种不同的回显，这两种不同的回显就被称为“布尔回显”。
延时型也就是所谓的时间盲注，即在无法通过布尔盲注判断的情况下，通过响应时长来判断。在做延时盲注时，攻击者构造的SQL语句是这样的意思：如果满足xx条件，就`sleep(5)`，否则就不sleep。数据库如果执行了`sleep()`就会延时，而WEB程序和数据库做交互就会等数据库的这个延时，用户(攻击者)和WEB程序做交互那么用户就也得等WEB页面的这个延时，所以攻击者只需要根据页面的响应时间的长短就可以判断xx条件是否满足了。而这个xx条件，可能就是“数据库名的第一位是否为a”这样的判断语句。
这里将布尔盲注又细分出了一个新的类型——报错盲注，这个报错盲注和我们通常说的报错注入是完全不同的东西，这种注入类型我们在后面再专门进行介绍。
## 0x02 盲注怎么注
###  盲注的步骤
前面一直是以抽象的中文来表示盲注的操作，这里我们使用SQL语句进行更详细的说明。
还是那个学生查询的例子：`SELECT name,majority FROM student WHERE student_id = '$id';`
其中`$id`为用户输入，假设为布尔盲注，回显为“查询成功”和“查询失败”。
**Step 1: 找注入点**
关于找注入点比较简单，学过SQL注入应该都会，如果题目给了源码就直接看着SQL语句构造就行了。
如果没有给源码，我们需要先测试字段类型是字符型还是数字型，然后看是否有回显，然后用`or
1=1#`之类的东西去测试。具体测试时，我们先想象他的SQL语句是`select xx from yy where zz = '$your_input';`
因为基本所有题的SQL语句都是这个结构，在这个SQL语句结构的基础上去测试就好了。
**Step 2: 构造condition**
所谓的condition就是某个条件，这个条件的真与假可以影响SQL语句的查询结果，进而影响WEB页面的回显。例如输入`0' or 1=1#`和`0' or
1=2#`(`#`是注释符)：
    SELECT name, mojority FROM student WHERE student_id = '0' or 1=1#'  #查询成功
    SELECT name, mojority FROM student WHERE student_id = '0' or 1=2#'  #查询失败
这里我们可以明确的知道student_id为0的学员是不可能存在的，那么上述SQL语句的查询结果就完全由`or`后面的`1=1`和`1=2`来决定了。SQL中`=`意为“是否相等”，所以`1=1`就表示`1是否等于1`,这是一个布尔表达式，它的结果只有True和False两种。
这个能直接影响整个SQL语句查询结果的`1=1`和`1=2`，也就是这个布尔条件表达式，就是我们目前Step 2要构造的condition。
**Step 3: 注数据**
现在我们只需要将Step 2构造的Condition换成具体的注入数据的语句，就可以了！
    SELECT name, mojority FROM student WHERE student_id = '0' or substr((select database()),1,1) = 'a'
    SELECT name, mojority FROM student WHERE student_id = '0' or substr((select database()),1,1) = 'b'
    ....
###  布尔盲注中的布尔回显
  1. 最常见的就是回显的内容不同，比如`查询成功`和`查询失败`，回显长度有时也可以
  2. 返回的HTTP头的不同，比如结果为真可能会返回Location头或者set-cookie
  3. 看HTTP状态码，比如结果为真则3xx重定向，为假则返回200
###  盲注脚本的编写
分析可知：
  * 针对截取的每一位，都要把字母表跑一遍来判断是否相等，因此需要两层循环，外层循环为位数，内层循环为具体值。
  * 对于注入不同的数据，只要修改内部子查询就好了，其他的部分不需要改动，因此可以把子查询写成一个单独的变量。
于是可以写出这样的注入脚本：
    # 导入所需模块
    import requests
    import string 
    # 构造字母表，根据字母表去爆破每一位的具体值
    alphabet = string.ascii_letters + string.digits + ",}{_="
    # 题目的URL
    url = "http://127.0.0.01/?student_id="
    # 注入什么数据，select变量就写什幺子查询语句
    select = "select database()" 
    select = "select group_concat(table_name) from information_schema.tables where table_schema=database()" 
    # 用来保存注入出的结果
    result = ""
    for i in range(1,100): # 外层循环，从1开始，因为截取的位数是从1开始的
        for ch in alphabet: # 内层循环，是具体需要测试的值
            # 构造SQL语句，发起请求
            payload = f"2019122001' and substr(({select}) ,{i},1) = '{ch}' %23"
            r = requests.get(url=url+payload)
            # 根据回显判断，如果得到了表示查询成功的回显，那么说明判断数据的这一位是正确的
            if "查询成功" in r.text:
                result += ch 
                print("注入成功：", result)
                break # 这一位已经跑出来了，可以break掉然后下一轮循环跑下一位数据了
            # 如果已经跑到了字母表最后一位都还没有进到上面的if然后break，说明这轮循环没跑出来正确结果，说明注入完成（或者注入payload写的有问题注入失败），脚本没必要继续跑下去了
            if ch == alphabet[-1]:
                print("注入完成")
                exit(0)
虽然每个题目的注入脚本各有不同，但是基本都是这样的结构，可以根据这个脚本的结构来写你自己的注入脚本。
## 0x03 盲注的两个基本问题
###  两个基本问题是什么
通过上面的内容，你已经能够进行简单的盲注了，然而实际的题目中会加上各种各样的过滤，为了绕过这些过滤，盲注被分成了LIKE注入、MID注入、LEFT注入、正则注入、IN注入、BETWEEN注入等各种各样的注入类型，学习起来非常不便。==这其实是完全没有必要的！==
我们来观察这个注入语句`substr((select database()),1,1) = 'a'`,你会发现他实际上就是两个部分组成的：
  1. 字符串截取，截取字符串的某一位
  2. 比较是否相等
实际上所有的盲注都需要满足这两个部分，那么我们不妨就将其称为“盲注的两个基本问题”，即：
  1. 字符串的截取
  2. 比较
###  两个基本问题的必要性
既然是基本问题，就是不可或缺的、必须具备的。那么为什么说这是盲注的基本问题呢？我们可以反向分析。
**字符串的截取**
因为盲注是一种brute
force，所以我们可以计算一下爆破所需的次数。假设我们需要注入的数据是一个7位的包含大小写字母和数字的单词，那么每一位的可能性就是：26大写字母+26小写字母+10数字=62个字符。
将其截取成每一位然后判断，每一位最多62次就可以爆破出来，那么一共最多也就是`62x7=434`次就可以爆破出来了。
如果不截取成每一位，而是直接硬着头皮去爆破，那么就是`62^7=3521614606208`种可能性，`3521614606208 / 434 =
8114319369`，所需的工作量整整多了81亿多倍！
**比较**
这个没啥可说的，如果没法比较，就没办法根据条件的真假来影响SQL语句的结果进而影响WEB页面的回显，那就没法判断了！
## 0x04 字符串截取与比较的方法
上一个部分说了，我们没有必要将盲注分成LIKE注入IN注入什么什么那么多方法，总结下来只有两个基本问题。所以说各种各样的盲注的分类其实都跑不出这两个基本问题，那么其实只要我们能掌握所有的截取和比较的方法，我们就相当于是掌握了所有的盲注方法！
以下是我总结的目前已出现的字符串截取与比较的方法，如有其他欢迎补充。这里我们测试的注入数据是`select database()`，
结果为`college`
###  字符串截取方法
**substr()**
这是最最最最基本的截取函数！
使用方法：`substr(要截取的字符串，从哪一位开始截取，截取多长)`
注意，这里截取的开始位数是从1开始数的，比如截取第一位那么就写1而不是0。`substr`和`substring`是同名函数。
**mid()**
和`substr()`用法基本一样，是`substr()`完美的替代品。
**right()**
表示截取字符串的右面几位。
使用方法：`right(截取的字符串，截取长度)`
到了`right()`函数就不太好用了，因为`substr()`和`mid()`是精确截取某一位的，而`right()`不能这样精确的截取，他只能截取某些位。
技巧：和`ascii / ord`函数一起使用，`ascii()或ord()`返回传入字符串的首字母的ASCII码。`ascii(right(所截取字符串,
x))`会返回`从右往左数的第x位的ASCII码`，例如：
另外建议能用ASCII码判断时，就不要直接用明文字符进行判断，尽量用ASCII。理由如下：①如果直接用明文字符进行判断，有一些特殊符号（单引号反斜线等）会干扰整个SQL语句的语法。②ASCII将字符转成数字，数字可以用大于小于的判断，可以二分注入，而字符基本只能用等号判断（字符其实也可以大于小于判断，但是很麻烦，可以想象一下无列名盲注）。
**left()**
表示截取字符串的左面几位。
使用方法：`left(截取的字符串，截取长度)`
和`right`一样，依然是个不能精确截取某一位的函数，但是也可以利用技巧来实现精准截取。
技巧：和`reverse()` \+ `ascii() / ord()`一起使用。`ascii(reverse(left(所截取字符串,
x)))`会返回`从左往右数的第x位的ASCII码`，例如：
**regexp**
用来判断一个字符串是否匹配一个正则表达式。这个函数兼容了截取与比较。