state templates generation; 4) Populating missing values in expected resource state templates (M. 
Fu, et al., 2016). Resource space determination and expected resource state templates generation 
are conducted offline, which means that they are conducted before the sporadic operation starts 
running  (M.  Fu,  et  al.,  2016).  Resource  state  capturing  and  populating  missing  values  in 
expected  resource  state  templates  are  conducted  during  the  execution  of  a  sporadic  operation 
and hence they are online procedures (M. Fu, et al., 2016). We present the four components of 
resource state management in POD-Recovery one by one. 
6.1  Operational Resource Space Determination 
The operation resource space is the set of manipulated resources during all steps of an operation. 
The key inputs needed for determining the resource space are cloud API call logs, which contain 
all  the  API  operations  that  were  called  in  past  operation  runs.  Different  cloud  platforms  offer 
this functionality. For instance, on AWS the respective service is called CloudTrail (CloudTrail, 
2016). Fig. 14 shows an example of AWS CloudTrail logs in JSON format: a record of a call to 
“UpdateAutoScalingGroup”.  It  specifies 
the  API  call 
time  (“eventTime”),  operation 
(“eventName”), call parameters (“requestParameters”) and response (“responseElements”). 
Fig. 14.  CloudTrail Log. 
Generating the resource space relies on the information provided by cloud logs like CloudTrail 
logs.  The  approach  for  generating  the  resource  space  is  illustrated  in  Fig.  15  (M.  Fu,  et  al., 
2016).  First,  based  on  timestamped  logs  of  an  operation  process  and  on  CloudTrail  logs,  the 
operation-related  API  calls  can  be  determined  by  correlating  the  timestamps  in  operation 
process and in cloud trail logs. Second, based on the API-resource mapping table we can obtain 
the overall set of resources changed by the operation. The mapping table lists which resources 
are  changed  by  which  API  operations  –  e.g.,  the  operation  “CreateLaunchConfiguration” 
changes  resources  of  type  “Launch  Configuration”.  We  create  this  mapping  table  manually, 
which is reasonably feasible considering the limited number of resource types and APIs in cloud. 
61 
Fig. 15.  Operation Resource Space Determination. 
Using  rolling  upgrade  as  an  example,  the  resource  space  determined  by  the  resource  space 
determination method is illustrated in Fig. 16 (M. Fu, et al., 2016). The resource space contains 
four resource types: Instance (i.e. VM), Launch Configuration (LC), Auto Scaling Group (ASG), 
and  Elastic  Load  Balancer  (ELB).  Each  resource  type  has  attributes  (e.g.  instances  have  an 
instance  id,  instance  type,  machine  image,  etc.).  The  dependency  relationships  among  those 
resources are: 1) an ASG is associated with one LC; 2) an ASG contains a (possibly empty) set 
of instances; 3) an ELB links to a (possibly empty) set of instances; 4) each instance belongs to 
at most one ASG; and 5) each instance can be linked to a (possibly empty) set of ELBs. These 
relationships  also  align  with  the  resources  dependency  relationship  specified  by  AWS 
documentation (AWS Documentation, 2016). Once determined, we use the resource space as an 
input to the resource state capturing service. This service is responsible for capturing the states 
of the resources of the target cloud system. 
Fig. 16.  Cloud Resource Determined for Rolling Upgrade. 
62 
In the experimental evaluation, we will present the determined the resource space for each type 
of  sporadic  operation  evaluated  and  we  will  also  present  the  average  time  required  for 
determining the resource space for each sporadic operation evaluated (chapter 8). 
6.2  Resource State Capturing 
The  states  of  the  resources  during  an  operation  are  captured  by  the  resource  state  capturing 
service. Unlike existing traditional checkpointing  mechanisms which capture the states for the 
whole  software  system  (E.  N.  M.  Elnozahy,  et  al.,  2002),  our  state  capturing  method  only 
captures  the  states  of  the  resources  involved  in  the  determined  resource  space  (M.  Fu,  et  al., 
2016). This increases the efficiency of state capture, especially when the system scale is large. 
The  state  capturing  algorithm  is  shown  in  Fig.  17  (M.  Fu,  et  al.,  2016).  The  state  capturing 
algorithm  captures relevant  state information  of  each resource  in the resource  space.  For  each 
cloud  resource,  it  retrieves  the  current  state  of  it  through  calling  public  cloud  APIs,  and  this 
function  is  called  “ObtainAppStateInformationOf  (Resource)”  in  the  resource  state  capturing 
algorithm.  For  AWS,  this  procedure 
includes  calling  cloud  API  functions  such  as 
“DescribeInstances” or “DescribeLoadBalancers” and recording the returned results of the cloud 
API  functions.  The  results  of  the  captured  resource  states  are  stored  in  a  variable  named 
“CapturedState”.  Finally,  the  information  about  the  captured  resource  states  as  well  as  which 
operational  step  the  captured  resource  states  belong  to  is  generated  and  saved  by  calling  the 
function of “SaveCapturedState (CapturedState, Step)”. The state capturing service is triggered 
to  capture  the  initial  state  at  each  recovery  point.  Also,  if  recovery  takes  place  for  a  recovery 
point,  the  resource  state  is  captured  after  recovery  completes  to  obtain  another  consistent 
resource state (M. Fu, et al., 2016).  
Fig. 17.  Resource State Capturing Algorithm. 
6.3  Expected Resource State Templates Generation 
While the resource state determination captures the affected resources on the level of a whole 
process, our approach requires a finer level of detail:  for all the operational steps in the process, 
63 
the expected resource state templates should capture which resources are affected and how they 
are  affected.  These  expected  state  templates  are  also  generated  from  historical  logs  of  the 
operation (M. Fu, et al., 2016).  
Fig. 18 depicts the method of generating templates for expected resource states (M. Fu, et al., 
2016). First, from the process model (with timestamps) obtained by process mining (W. V. D. 
Aalst, 2011), we obtain the start time and end time of each step in the process. Next, we obtain 
the cloud API calls and their parameters for each step, by correlating the CloudTrail log entries’ 
timestamps with the operational steps’ timestamps. Then we derive the initial resource state of 
the system before the operation starts, by reasoning over the resource state space, the affected 
resource types, and their attributes. In other words, the initial resource state of the system before 
the  operation  starts  is  generated  by  analysing  what  types  of  resources  are  included  in  the 
resource space, what their relationships are and what attributes are required by each resource in 
the resource space. The initial resource state of the system is determined in such a way because 
all the system resource states for the operational steps of the sporadic operation should follow 
the  structure  of  the  determined  resource  space  and  the  initial  system  resource  state  is  one  of 
them. An example of such an initial state is shown, in XML,  as the top part of Fig.  19. Next, 
based on  API  call  information for  each  step and  the initial  resource  state  before  the  operation 
starts,  the  expected  resource  state  template  after  each  step  is  generated.  Specifically,  the 
expected state after step 1 is the result of applying the API operations from state 1 to the initial 
state (e.g. a new LC is created), the expected state after step 2 is the result of applying the API 
operations from step 2 to the state after step 1 (e.g. ASG is updated), and so on. The generated 
resource state templates are encoded in XML format, but XML  is just one of the data formats 
that  can  be  used  to  represent  the  resource  state  templates,  and  some  other  data  formats  (e.g. 
JSON) can also be used for encoding the resource state templates as long as they  can provide 
features  to  represent  all  the  information  and  resources  dependency  relationships  within  the 
resource  states.  Various  types  of  cloud  platforms  provide  available  and  accessible  cloud  call 
history logs for determining which activities and cloud APIs are called by each operational step, 
and  hence  the  mapping  between  each  operational  step  and  its  corresponding  API  calls  is 
available for all different clouds. For example, AWS EC2 provides CloudTrail logs to trace its 
API  calls  history,  and  similarly  Windows  Azure  provides  API  Inspector  logs  to  trace  its  API 
calls  history.  This  characteristic  also  ensures  the  feasibility  of  applying  the  expected  resource 
states generation method on different types of cloud platforms.  
The  expected  resource  state  templates  generation  method  is  applicable  for  multiple  types  of 
sporadic operations on cloud because all of these sporadic operations provide the necessary API 
calls history information and operational process steps with timestamps, and we use the rolling 
64 
upgrade operation as an illustrating example to show how the expected resource state templates 
are generated using this method. Since rolling upgrade is one of the most widely and frequently 
performed  sporadic  operations  on  cloud  (T.  Dumitras  and  P.  Narasimhan,  2009)  and  it 
manipulates a good cross of cloud resources (e.g. instances, ASG, ELB, etc.), it is representative 
of all the sporadic operations on cloud, which justifies the validity of using the rolling upgrade 
operation  as  the  illustrating  example.  The  bottom  part  of  Fig.  19  shows  an  example  of  the 
expected  resource  state  templates  after  step  1  (Create  New  LC)  of  rolling  upgrade.  When  the 
operation  starts,  the  resources  are  in  the  initial  state.  Then,  after  calling  the  API  operation 
“CreateNewLaunchConfiguration”, one resource is changed. The changed resource is the “new 
LC” (in underlined bold font), and hence it evolves the initial resource state by adding the “new 
LC”.  Each  generated  resource  state  template  follows  the  structure  of  the  determined  resource 
space (M. Fu, et al., 2016). It is important for the generated resource state templates to follow 
the  structure  of  the  determined  resource  space,  because  the  process  steps  of  the  sporadic 
operation  only  need  to  manipulate  a  subset  of  the  overall  resources  provided  by  cloud,  which 
consists of the types of resources within the determined resource space. So the state transition 
based recovery actions will take less execution time, which is essential for meeting the recovery 
requirement of satisfying RTO (Recovery Time Objective).  
Fig. 18.  Expected Resource State Templates Generation. 
In the generated resource state templates, most fields have variable content. These variables are 
represented with question marks as prefix (e.g. “?newLC”) in Fig. 19. For the set of instances, it 
is unclear at design time how many instances will be in the initial state – symbolized by “[…]” 
in Fig. 19. At runtime, the actual values for variables, the number of instances, etc., need to be 
set. All of the fields in the initial state can be populated when the operation starts, by analyzing 
the relevant information in the operation’s runtime logs. In the running example, we can obtain 
65 
the ASG name from the first log line of rolling upgrade. That allows us to find the LC, the ELB, 
and all instances (and their number) associated with this ASG. Other parameters, like the ID of 
the new launch configuration in the expected resource state after Step 1, remain unknown until 
“create LC” has been executed. As the operation progresses, these variable values will be set to 
the  actual  values,  also  obtained  from  runtime  operation  logs.  We  store  the  expected  resource 
state templates for access by the runtime recovery service (M. Fu, et al., 2016). 
Fig. 19.  Sample Expected Resource State Templates. 
In  the  experimental  evaluation,  we  will  present  the  average  time  required  for  generating  the 
expected resource state templates for each sporadic operation evaluated (chapter 8). 
6.4  Populating Missing Values in Expected Resource State Templates 
The actually values of the missing properties in the generated expected resource state templates 
are later on populated at runtime during the execution of the  sporadic operation (M. Fu, et al., 
66 
2016). The  values  are  determined  by  resolving  the  generated  operation  logs  and  matching  the 
log  information  with  relevant  regular  expressions.  The  regular  expressions  are  obtained  by 
analysing the logs of the sporadic operations, and the operational logs are usually accessible by 
external  parties  (M.  Fu,  et  al.,  2016).  Taking  rolling  upgrade  as  an  example,  Table  5  below 
shows what missing values (such as New LC id) in the expected resource state templates of the 
rolling  upgrade  operation  can  be  determined  by  matching  the  content  of  the  operational  logs 
generated with which relevant regular expressions. So far, many programming frameworks such 
as .Net framework 3.5 or Java SDK 2.0 can support resolving log information and matching it 
with regular expressions to figure out the missing values (M. Fu, et al., 2016). 
Table 5.  Regular Expressions Matching 
Missing Value 
Regular Expression 
Old LC id 
New AMI id 
New LC id 
New LC AMI id 
ASG id 
Updating  launch from  (?\w+)  with 
(?\w+) into (?\w+) 
Updating  launch from  (?\w+)  with 
(?\w+) into (?\w+) 
Updating  launch from  (?\w+)  with 
(?\w+) into (?\w+) 
Updating  launch from  (?\w+)  with 
(?\w+) into (?\w+) 
Updating group (?\w+) to use launch 
config (?\w+) 
ELB Deregistered Instances id 
Deregistered  instances  (?\w+) 
from load balancer (?\w+) 
ELB id 
Deregistered  instances  (?\w+) 
from load balancer (?\w+) 
Terminated Instance id 
Terminating instance (?\w+) 
Newly Launched Instance id 
ELB Registered Instances id 
It took (?\w+) for instance 
(?\w+)  to  terminate 
and be replaced by (?\w+) 
Registered 
into load balancer (?\w+) 
instances 
(?\w+) 
67 
Chapter 7.  Recovery Actions Generation & Selection in POD-
Recovery  
In  this  chapter,  we  present  the  major  online  activities  of  POD-Recovery:  1)  Handling  false 
positives  of  error  detection;  2)  Describing  the  eight  recovery  patterns;  3)  Applicable  recovery 
patterns  filtering;  4)  Recovery  actions  generation;  5)  Applicable  recovery  actions  evaluation 
based  on  three  evaluation  metrics;  6)  Selection  of  acceptable  recovery  actions  from  recovery 
action candidates list; 7) Mapping the selected recovery actions into executable code. 
7.1  Handling False Positives of Error Detection  
As mentioned in section 1.2.4, failures and errors in sporadic operations on cloud are detected 
by the existing failure detection service called POD-Diagnosis (X. Xu, et al., 2014). Since POD-
Diagnosis relies on analysing cloud operational logs and populating cloud resources by calling 
cloud  APIs  with  uncertainty  to  detect  the  operational  failures  and  errors,  it  is  faced  with  a 
potential problem that the errors and failures detected are false positives. When false positives 
of error detection occur, the recovery service should not be triggered to perform recovery, and 
hence  the  false  positives  of  error  detection  must  be  handled.  The  false  positives  of  error 
detection service that we consider here are just very primitive false positives: the detected errors 
are just fake ones and should not be recovered from (M. Fu, et al., 2016). As mentioned before, 
POD-Recovery  is  only  interested  in  two  types  of false  positives  of  error  detection:  1) there  is 
actually no error occurred for a sporadic operation but the error detection service unexpectedly 
reports  the  error  detected;  2)  after  error  detection  reports  the  error  and  begins  to  trigger  the 
recovery service, the transient error is disappeared before recovery is actually started (M. Fu, et 
al., 2016). Since error detection triggers the recovery service, and since POD-Recovery does not 
consider any causes offered by the triggering message, we do not investigate any more complex 
false  positives  (M.  Fu,  et  al.,  2016).  By  more  complex  false  positives  of  error  detection,  we 
mean that the false positives are caused by wrong diagnosis of the causes that result in a failure 
or insufficient diagnosis for failure reasons. To reduce the false positives, the recovery service 
first  obtains  the  current  state  of  the  relevant  cloud  resources  before  actually  recovery  takes 
action.  This  current  state  of  these  resources  can  be  more  recent  than  the  erroneous  state 
identified by the error detection service so it effectively serves as a double check to reduce false 
positives  from  error  detection  (M.  Fu,  et  al.,  2016).  If  the  obtained  current  state  of  relevant 
cloud  resources  is  different  from  the  erroneous  state  identified  by  the  error  detection  service, 
then no recovery is triggered. Otherwise, recovery is triggered (M. Fu, et al., 2016). Hence, false 
positives of the error detection service are reduced. 
68 
In the experimental evaluation, we will present how the false positives of error detection can be 
handled by the error detection false positive handling mechanism in POD-Recovery (chapter 8). 
7.2  Eight Recovery Patterns 
The  recovery  patterns  we  proposed  are  a  consolidated  set  of  understanding  from  the  long 
running transaction research community (C. Colombo, et al., 2013). The recovery mechanisms 
for  long  running  transactions  are  more  focused  on  reverting  transactional  steps  to  previous  or 
future consistent states, and hence they do not cover all the possible recovery patterns that can 
be applied to recovery for sporadic operations on cloud. The eight recovery patterns proposed 
by us are on top of the recovery strategies for long running transactions and they provide more 
insights  into  how  operational  recovery  can  be  performed  in  the  context  of  cloud.  For  long 
running  transactions,  recovery  strategies  usually  involve  backward  recovery  and  forward 
recovery (C. Colombo, et al., 2013). Backward recovery first reverts the current erroneous state 
to a previous correct state before attempting to continue execution (C. Colombo, et al., 2013). 
Forward  recovery  attempts  to  correct  the  current  erroneous  state  and  then  continues  normal 
execution  (C.  Colombo,  et  al.,  2013).  One  form  of  forward  recovery  is  compensation  (C. 
Colombo,  et  al.,  2013),  which  means  to  attempt  to  correct  the  state  of  a  system  given  some 
knowledge  of the previous  actions  of the system  (C. Colombo,  et al.,  2013).  In  the context  of 
cloud, sporadic operations have some specific cloud-oriented features such as heavy reliance on 
virtual  cloud  resources  and  frequent  interactions  with  relevant  cloud  APIs.  Hence,  the  eight 
recovery  patterns  are  derived  and  determined  based  on  understanding  the  features  of  sporadic 
operations on cloud. Some activities might have alternatives which lead to the same execution 
results as the original activities, so re-executing an activity is equal to executing its alternative. 
For example, waiting for auto scaling group to launch a new instance is equivalent to attaching a 
pre-prepared new instance into the auto scaling group. As such, we have organized this body of 
knowledge and proposed eight recovery patterns that aim to cover all combinations of forward 
and  backward  recovery  types:  1)  Compensated  Undo  &  Redo;  2)  Compensated  Undo  & 
Alternative; 3) Rewind & Replay; 4) Rewind & Alternative; 5) Reparation; 6) Direct Redo; 7) 
Direct Alternative; and 8) Farther Undo & Redo (M. Fu, et al., 2015; M. Fu, et al., 2016). 
Fig. 20 illustrates the mechanisms and relationships of these eight recovery patterns (M. Fu, et 
al.,  2015;  M.  Fu,  et al.,  2016).  Suppose the  error  occurs  when  process  step  X (Step X)  of  the 
operation  is  actually  running.  After  detecting  errors,  the  recovery  is  triggered  by  the  error 
detection service. Five items of system states are the inputs to the recovery: S_err, S1, S2, C1, 
and S0. S_err is the erroneous state after Step X. S1 is the expected state before Step X and S2 
is the expected state after Step X; C1 is the captured state before Step X. S0 is the expected state 
before  the  last  step  prior  to  Step  X  which  is  Step  X-1.  Importantly,  a  step  could  have  its 
69 
alternative  which  leads  to  the  same  running  result  as  the  step  itself  (alternative  of  Step  X 
(Alternative  X)  has  the  same  running  result  as  Step  X).  For  Compensated  Undo  &  Redo,  the 
recovery flow is “S_err->S1->Step X->S2”. For Compensated Undo & Alternative, the recovery 
flow  is  “S_err->S1->Alternative  X->S2”.  For  Rewind  &  Replay,  the  recovery  flow  is  “S_err-
>C1->Step X->S2”. For Rewind &Alternative, the recovery flow is “S_err->C1->Alternative X-
>S2”. For Reparation, the recovery flow is “S_err->S2”. For Direct Redo, the recovery flow is 
“S_err->Step X->S2”. For Direct Alternative, the recovery flow is “S_err->Alternative X->S2”. 
For  Farther  Undo  &  Redo,  the  recovery  flow is  “S_err->S0->Step X-1->Step X->S2”.  During 
any recovery action, the recovery itself might fail due to reasons such as cloud APIs uncertainty 
(Q. Lu, et al., 2013) and it makes the system go into another unexpected erroneous state (S_us). 
If this case happens, the “recovery for recovery” mechanism is triggered to make the system go 
into the correct expected state from the unexpected erroneous state (M. Fu, et al., 2016). 
Fig. 20.  Eight Recovery Patterns. 
The eight recovery patterns are based on all the possible paths and associated state  transitions 
from  an  error  state  (S_err)  during  the  operation  to  the  expected state (S2).  As  such,  we  argue 
that in the eight recovery patterns there is at least one recovery pattern that can be utilised for 
operational recovery, no matter what sporadic operations on cloud are being performed. Under 
the  circumstance  where  none  of  the  eight  recovery  patterns  is  applicable,  we  deem  the 
operations or operational steps as unrecoverable and they are out of the scope of the recovery 