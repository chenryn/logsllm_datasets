# 结束语 \| 大道至简你好，我是李兵。不知不觉中专栏已经更新完了，总的来说，我写本专栏的过程是痛并快乐着。 觉得痛苦是因为写作期间每一天都能感受到多方的压力，完全没有放松的机会。在这过程中，阅读Chromium 和 V8的源代码占用了我大量的时间，因为有时候要验证文章的一些观点，或者找出一些知识点的实现逻辑，都需要通过阅读源代码来给出结论。V8的源代码还算好读，但 Chromium的源代码就过于复杂了，要看一个功能是怎么实现的就得查看几十个源文件，而且这些代码中充斥着大量的回调函数，大大增加了阅读代码的难度。 当然这个过程中，我也觉得是快乐的，因为通过本专栏我解锁了两件非常有挑战的技能。 第一件是写技术文章。通过本专栏，我对写技术文章有了比较系统性的方法论，也理解了写技术文章的核心就是**用简单的语言讲清楚一个复杂的问题**。不过要做好却并非易事，搞清楚目标群体、对这个领域有深刻的理解和洞见、组织好文章的层次结构......一样都不能少，只有这样才能做到有的放矢。 在专栏的写作过程中，我还发现了写文章和做项目的相通之处。我们知道通常做项目时需要首先确认核心需求，并快速交付一个最小可行产品，然后再根据实际的需求来迭代产品。 而在设计专栏目录时，我也有意识地将文章分为"**搭建知识架构型**"和"**深入讲解单个知识点型**"。"搭建知识架构型"文章的主要任务是将相互关联的知识点串成线、连成网，这类文章的核心任务就是做连接，但这过程中又会涉及到很多知识点，不过单个知识点是怎么工作的并不是核心，因此我会将这些细节性的知识点关进"黑盒"，你只需要了解"黑盒"起到的作用是什么就行了，并不需要关心其内部实现的细节。相反，在"深入讲解单个知识点型"这类文章中，我会拆解这些"黑盒"，并将一个个知识点分析透彻。 我解锁的第二个有挑战的技能就是专栏录音，为此我还专门学习了一些录音技巧，虽然录音效果和专业主播比起来还有些差距，但对于我个人而言，这是我迈出去的"重要的第一步"！ 如果非让我总结写作过程中的一些经验和心得，我会用四个词来概括：**大道至简，学会权衡，懂得舍弃，持续进化**。具体来讲，首先你懂得了大道，有着全局视野，才有能力去分析哪些是重要的、哪些是不重要的，这样你才有可能去化繁为简；在化繁为简的过程中，你还需要去权衡利弊，有勇气去舍弃那些不重要的或者已经花费了大量精力去做的事；完成之后，你还需要持续跟进，进行持续的重构改进！ 我特别感谢极客时间给我这次机会，在这过程中，我学习了很多，也成长了很多。也非常感谢你在留言区的反馈和意见，才让我可以持续优化本专栏。虽然这是专栏的结束语，不过本专栏还会持续优化下去，我会详细回复你的留言，并对专栏做一些勘误和结构的优化，如有必要后续我还会准备一些加餐环节。 最后，在文章的结尾处我为你准备了一份调查问卷，题目不多，希望你可以抽出两三分钟填写一下。我想认真倾听你对这个专栏的建议或意见，期待你的反馈！ ![](Images/ebfb017f027a3f839ee46c3b27bc3a9d.png)savepage-src="https://static001.geekbang.org/resource/image/9f/2e/9fc2d03a6121be800e4989ac3df63f2e.jpg"}](https://jinshuju.net/f/rtnh4J)
# 加餐一｜浏览上下文组：如何计算Chrome中渲染进程的个数？你好，我是李兵。 在留言区，经常有朋友问到如何计算 Chrome中渲染进程个数的问题，那么今天我就来完整地解答这个问题。 在前面" [04 \|导航流程  slate-object="inline""这一讲中我们介绍过了，在默认情况下，如果打开一个标签页，那么浏览器会默认为其创建一个渲染进程。不过我们在"04 \| 导航流程slate-object="inline""中还介绍了同一站点的概念，如果从一个标签页中打开了另一个新标签页，当新标签页和当前标签页属于同一站点的话，那么新标签页会复用当前标签页的渲染进程。 具体地讲，如果我从极客邦 (www.geekbang.org)的标签页中打开新的极客时间 (time.geekbang.org)标签页，由于这两个标签页属于同一站点(相同协议、相同根域名)，所以他们会共用同一个渲染进程。你可以看下面这张Chrome 的任务管理器截图： ![](Images/de48e46f51def18151d8ba1a92f6fb86.png)savepage-src="https://static001.geekbang.org/resource/image/f8/5c/f87168a79df0b87a08b243937f53545c.png"}多个标签页运行在同一个渲染进程slate-object="mark"} 观察上图，我们可以看到，极客邦官网和极客时间标签页都共用同一个渲染进程，该进程ID 是 84748。 不过如果我们分别打开这两个标签页，比如先打开极客邦的标签页，然后再新建一个标签页，再在这个新标签页中打开极客时间，这时候我们可以看到这两个标签页分别使用了两个不同的渲染进程。你可以参看下图： ![](Images/e4a8993eec0f46f5dbacace3815b90cd.png)savepage-src="https://static001.geekbang.org/resource/image/34/f9/34815ee3a8d5057d39ebb6f871fbf0f9.jpg"}多个标签页运行在不同的渲染进程中slate-object="mark"} 那么到了这里，你一定会很好奇，既然都是同一站点，为什么从 A标签页中打开 B标签页，就会使用同一个渲染进程，而分别打开这两个标签页，又会分别使用不同的渲染进程？ 标签页之间的连接要搞清楚这个问题，我们要先来分析下浏览器标签页之间的连接关系。 我们知道，浏览器标签页之间是可以通过 JavaScript脚本来连接的，通常情况下有如下几种连接方式： **第一种是通过**``**标签来和新标签建立连接**，这种方式我们最熟悉，比如下面这行代码是从极客邦标签页里面拷贝过来的：      极客时间 这是从极客邦官网中打开极客时间的链接，点击该链接会打开新的极客时间标签页，新标签页中的window.opener 的值就是指向极客邦标签页中的window，这样就可以在新的极客时间标签页中通过 opener来操作上个极客邦的标签页了。这样我们可以说，这两个标签页是有连接的。 另外， **还可以通过JavaScript 中的 window.open方法来和新标签页建立连接**，演示代码如下所示：     new_window = window.open("http://time.geekbang.org")通过上面这种方式，可以在当前标签页中通过 new_window来控制新标签页，还可以在新标签页中通过 window.opener来控制当前标签页。所以我们也可以说，如果从 A 标签页中通过 window.open的方式打开 B 标签页，那么 A 和 B标签页也是有连接的。 其实通过上述两种方式打开的新标签页，不论这两个标签页是否属于同一站点，他们之间都能通过opener 来建立连接，所以他们之间是有联系的。在 WhatWG规范中，把这一类具有相互连接关系的标签页称为**浏览上下文组 ( browsing contextgroup)。** 既然提到浏览上下文组，就有必要提下浏览上下文，通常情况下，我们把一个标签页所包含的内容，诸如window对象，历史记录，滚动条位置等信息称为浏览上下文。这些通过脚本相互连接起来的浏览上下文就是浏览上下文组。如果你有兴趣，可以参开下规范文档slate-object="inline"。 也就是说，如果在极客邦的标签页中，通过链接打开了多个新的标签页，不管这几个新的标签页是否是同一站点，他们都和极客邦的标签页构成了浏览上下文组，因为这些标签页中的opener 都指向了极客邦标签页。 **Chrome浏览器会将浏览上下文组中属于同一站点的标签分配到同一个渲染进程中**，这是因为如果一组标签页，既在同一个浏览上下文组中，又属于同一站点，那么它们可能需要在对方的标签页中执行脚本。因此，它们必须运行在同一渲染进程中。 现在我们清楚了浏览器是怎么分配渲染进程的了，接下来我们就可以来分析文章开头提的那个问题了： >  > 既然都是同一站点，为什么从 A 标签页中打开 B> 标签页，就会使用同一个渲染进程？> 而分别打开这两个标签页，又会分别使用不同的渲染进程？> > >首先来看第一种，在极客邦标签页内部通过链接打开极客时间标签页，那么极客时间标签页和极客邦标签页属于同一个浏览上下文组，且它们属于同一站点，所以浏览器会将它们分配到同一个渲染进程之中。 而第二种情况就简单多了，因为第二个标签页中并没有第一个标签页中的任何信息，第一个标签页也不包含任何第二个标签页中的信息，所以他们不属于同一个浏览上下文组，因此即便他们属于同一站点，也不会运行在同一个渲染进程之中。下面是我画的计算标签页的流程图，你可以参考下： ![](Images/d47338db55da57952167ce48caa07bba.png)savepage-src="https://static001.geekbang.org/resource/image/cb/b6/cbc89902f5ce12420101246c4a227cb6.jpg"}计算标签页使用的渲染进程数目slate-object="mark"} 一个"例外"好了，现在我们清楚了 Chrome浏览器为标签页分配渲染进程的策略了： 1.       **如果两个标签页都位于同一个浏览上下文组，且属于同一站点，那么这两个标签页会被浏览器分配到同一个渲染进程中。**        2.       **如果这两个条件不能同时满足，那么这两个标签页会分别使用不同的渲染进程来渲染。**        现在你可以想一下，如果从 A 标签页中打开 B 标签页，那我们能肯定 A标签页和 B标签页属于同一浏览上下文组吗？ 答案是"不能"，下面我们就来看个例子，在"04 \| 导航流程"的留言区中，ID为"芳华年月"的朋友就提出了这样的一个问题： >  > 请问老师，> > [https://linkmarket.aliyun.com> > > > 内新开的标签页都是新开一个渲染进程，能帮忙解释下吗?> > >我们先来复现下"芳华年月"所描述的现象，首先打开 linkmarket.aliyun.com这个标签页，再在这个标签页中随便点击两个链接，然后就打开了两个新的标签页了，如下图所示： ![](Images/df49be6498584123209f81c90d544a48.png)savepage-src="https://static001.geekbang.org/resource/image/87/44/8727a2cef7bc8bc2023a37d6368bb344.png"}"例外"情况slate-object="mark"} 我通过 A 标签页中的链接打开了两个新标签页，B 和C，而且我们也可以看出来，A、B、C三个标签页都属于同一站点，正常情况下，它们应该共用同一个渲染进程，不过通过上图我们可以看出来，A、B、C三个标签页分别使用了三个不同的渲染进程。 既然属于同一站点，又不在同一个渲染进程中，所以可以推断这三个标签页不属于同一个浏览上下文组，那么我们接下来的分析思路就很清晰了： 1.       首先验证这三个标签页是不是真的不在同一个浏览上下文组中；        2.       然后再分析它们为什么不在同一浏览上下文组。        为了验证猜测，我们可以通过控制台，来看看 B 标签页和 C 标签标签页的opener 的值，结果发现这两个标签页中的 opener 的值都是 null，这就确定了B、C 标签页和 A标签页没有连接关系，当然也就不属于同一浏览上下文组了。 验证了猜测，接下来的我们就是来查查，阿里的这个站点是不是采用了什么特别的手段，移除了这两个标签页之间的连接关系。 我们可以看看实现链接的 HTML文件，如下图所示： ![](Images/c949ffb08752add97a9453dedf8fa2a3.png)savepage-src="https://static001.geekbang.org/resource/image/ec/7e/ec3c6414a0e6eff3a04cfa7ec9486f7e.jpg"}链接使用了 rel = noopenerslate-object="mark"} 通过上图，我们可以发现，a 链接的 rel 属性值都使用了 noopener 和noreferrer，通过noopener，我们能猜测得到这两个值是让被链接的标签页和当前标签页不要产生连接关系。 通常，将 noopener 的值引入 rel属性中，就是告诉浏览器通过这个链接打开的标签页中的 opener 值设置为null，引入 noreferrer是告诉浏览器，新打开的标签页不要有引用关系。 好了，到了这里我们就知道了，通过 linkmarket.aliyun.com标签页打开新的标签页要使用单独的一个进程，是因为使用了 rel= noopener的属性，所以新打开的标签页和现在的标签页就没有了引用关系，当然它们也就不属于同一浏览上下文组了。这也同时解答了"芳华年月"所提出的问题。 站点隔离上面我们都是基于标签页来分析渲染进程的，不过我在"35｜安全沙箱"中介绍过了，目前 Chrome浏览器已经默认实现了站点隔离的功能，这意味着标签页中的 iframe也会遵守同一站点的分配原则，如果标签页中的 iframe和标签页是同一站点，并且有连接关系，那么标签页依然会和当前标签页运行在同一个渲染进程中，如果iframe 和标签页不属于同一站点，那么 iframe会运行在单独的渲染进程中。 我们先来看下面这个具体的例子吧：              站点隔离:demo                                                        在 Chrome 浏览器中打开上面这个标签页，然后观察 Chrome的任务管理，我们会发现这个标签页使用了四个渲染进程，如下图所示： ![](Images/09622a7d77fdb78b999b4a5fbb4d73c6.png)savepage-src="https://static001.geekbang.org/resource/image/47/1d/4762ab5be219271ff3e26c1f4c4f521d.png"}iframe 使用单独的渲染进程slate-object="mark"} 结合上图和 HTML 代码，我们可以发现，由于 InfoQ、极客邦两个 iframe与父标签页不属于同一站点，所以它们会被分配到不同的渲染进程中，而iframe.html和源标签页属于同一站点，所以它会和源标签页运行在同一个渲染进程中。下面是我画的计算iframe使用渲染进程数目的流程图，你可以对照着参考下： ![](Images/a1a7e579757689c5eb324ef39f704f4f.png)savepage-src="https://static001.geekbang.org/resource/image/a1/0e/a13f917f227e85102998b3bfe38b4e0e.jpg"}计算 iframe 所使用的渲染进程数目slate-object="mark"} 总结好了，本节的内容就介绍到这里，下面我来总结下本文的主要内容： 首先我们使用了两种不同的方式打开两个标签页，第一种是从 A标签页中通过链接打开了 B 标签页，第二种是分别打开 A 和 B标签页，这两种情况下的 A 和 B都属于同一站点。 通过 Chrome 的任务管理器我们发现，虽然 A 标签页和 B标签页都属于同一站点，不过通过第一种方式打开的 A 标签页和 B标签页会共用同一个渲染进程，而通过第二种方式打开的两个标签页却分别使用了两个不同的渲染进程。 这是因为，使用同一个渲染进程需要满足两个条件：首先 A 标签页和 B标签页属于同一站点，其次 A 标签页和 B标签页需要有连接关系。 接着，我们分析了一个"例外"，如果在链接中加入了 rel=noopener属性，那么通过链接打开的新标签页和源标签页之间就不会建立连接关系了。 最后我们还分析了站点隔离对渲染进程个数的影响，如果 A 标签页中的iframe 和 A 标签页属于同一站点，那么该 iframe 和 A标签页会共用同一个渲染进程，如果不是，则该 iframe会使用单独的渲染进程。 好了，到了这里相信你已经会计算渲染进程的个数了。 在最后我们还要补充下同源策略对同一站点的限制，虽然 Chrome会让有连接且属于同一站点的标签页运行在同一个渲染进程中，不过如果 A标签页和 B 标签页属于同一站点，却不属于同源站点，那么你依然无法通过opener 来操作父标签页中的DOM，这依然会受到同源策略的限制。 简单地讲，极客邦和极客时间属于同一站点，但是他们并不是同源的，因为同源是需要相同域名的，虽然根域名geekbang.org 相同，但是域名却是不相同的，一个是time.geekbang.org，一个是 www.geekbang.org，因此浏览器判断它们不是同源的，所以依然无法通过 time.geekbang.org标签页中的 opener 来操作 www.geekbang.org 中的DOM。 思考题那么今天留给你的思考题是，你认为 Chrome为什么使用同一站点划分渲染进程，而不是使用同源策略来划分渲染进程？ 欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。 ![](Images/7e91bd5c116048de87e68468f727fc3c.png)savepage-src="https://static001.geekbang.org/resource/image/3f/cb/3f4d5bec2d5c89600b4628581144d8cb.jpg"}
# 加餐三｜加载阶段性能：使用Audits来优化Web性能你好，我是李兵。作为一名前端工程师，除了需要编写功能性的代码以外，我们还需要关注 Web应用的性能问题，我们应该有能力让我们的 Web应用占用最小的资源，并以最高性能运行，这也是前端工程师进阶的必要能力。既然性能这么重要，那么我们今天要来聊聊Web 性能问题。到底什么是 Web 性能?我们看下 wiki 对 Web 性能的定义slate-object="inline"：>  > Web 性能描述了 Web> 应用在浏览器上的加载和显示的速度。> > >因此，当我们讨论 Web 性能时，其实就是讨论 Web 应用速度，关于 Web应用的速度，我们需要从两个阶段来考虑：1.  页面加载阶段；        2.  页面交互阶段。        在本文中，我们会将焦点放到第一个阶段：页面加载阶段的性能，在下篇文章中，我们会来重点分析页面交互阶段的性能。性能检测工具：Performance vs Audits要想优化 Web 的性能，我们就需要有监控 Web应用的性能数据，那怎么监控呢？如果没有工具来模拟各种不同的场景并统计各种性能指标，那么定位 Web应用的性能瓶颈将是一件非常困难的任务。幸好，Chrome为我们提供了非常完善的性能检测工具：**Performance** 和 **Audits**，它们能够准确统计页面在加载阶段和运行阶段的一些核心数据，诸如任务执行记录、首屏展示花费的时长等，有了这些数据我们就能很容易定位到Web 应用的**性能瓶颈** 。首先 Performance非常强大，因为它为我们提供了非常多的运行时数据，利用这些数据我们就可以分析出来Web应用的瓶颈。但是要完全学会其使用方式却是非常有难度的，其难点在于这些数据涉及到了特别多的概念，而这些概念又和浏览器的系统架构、消息循环机制、渲染流水线等知识紧密联系在了一起。相反，Audtis就简单了许多，它将检测到的细节数据隐藏在背后，只提供给我们一些直观的性能数据，同时，还会给我们提供一些优化建议。Perfomance 能让我们看到更多细节数据，但是更加复杂，Audits就比较智能，但是隐藏了更多细节。为了能够让你循序渐进地理解内容，所以本节我们先从简单的Audits入手，看看如何利用它来检测和优化页面在加载阶段的性能，然后在下一节我们再来分析Perfomance。检测之前准备工作不过在检测 Web的性能指标之前，我们还要配置好工作环境，具体地讲，你需要准备以下内容：1.  首先准备 Chrome Canary 版的浏览器，Chrome Canary    是采用最新技术构建的，它的开发者工具和浏览器特性都是最新的，所以我推荐你使用    Chrome Canary 来做性能分析。当然你也可以使用稳定版的    Chrome。        2.  然后我们需要在 Chrome    的隐身模式下工作，这样可以确保我们安装的扩展、浏览器缓存、Cookie    等数据不会影响到检测结果。        利用 Audits 生成 Web 性能报告环境准备好了之后，我们就可以生成站点在加载阶段的性能报告了，这里我们可以拿B 站slate-object="inline"作为分析的列子。1.  首先我们打开浏览器的隐身窗口，Windows 系统下面的快捷键是    Control+Shift+N，Mac 系统下面的快捷键是    Command+Shift+N。        2.  然后在隐身窗口中输入 B    站的网站。        3.  打开 Chrome 的开发者工具，选择 Audits    标签。    最终打开的页面如下图所示：![](Images/cd173bd884693454efe362831ea5b579.png)savepage-src="https://static001.geekbang.org/resource/image/f4/09/f47e598b2fe371e0af067c74756a8909.png"}Audits 界面slate-object="mark"}观察上图中的 Audits界面，我们可以看到，在生成报告之前，我们需要先配置Audits，配置模块主要有两部分组成，一个是**监测类型(Categories)**，另外一个是**设备类型(Device)**。**监控类型 (Categories)是指需要监控哪些内容**，这里有五个对应的选项，它们的功能分别是：1.  监测并分析 Web 性能 (        **Performance**        )；        2.  监测并分析 PWA(        **Progressive Web    App**    )    程序的性能；        3.  监测并分析 Web 应用是否采用了最佳实践策略    (    **Best    practices**        )；        4.  监测并分析是否实施了无障碍功能    (       **Accessibility**        )，        [无障碍功能            slate-object="inline"    让一些身体有障碍的人可以方便地浏览你的 Web    应用。    5.  监测并分析 Web 应用是否采实施了 SEO 搜素引擎优化    (       **SEO**        )。        本文我们只需要关注 Web 应用的加载性能，所以勾选第一个 Performance选项就可以了。再看看 **设备 (Device)部分**，它给了我们两个选项，Moblie选项是用来模拟移动设备环境的，另外一个 Desktop选项是用来模拟桌面环境的。这里我们选择移动设备选项，因为目前大多数流量都是由移动设备产生的，所以移动设备上的Web 性能显得更加重要。配置好选项之后，我们就可以点击最上面的生成报告 (Generate report)按钮来生成报告了。解读性能报告点击生成报告的按钮之后，我们大约需要等待一分钟左右，Audits就可以生成最终的分析报告了，如下图所示：![](Images/b1e46ea2bb6375b0069bb0a429f719d8.png)savepage-src="https://static001.geekbang.org/resource/image/c0/22/c0420197cc60fb91af2f38903afc8022.png"}生成的报告图slate-object="mark"}观察上图的分析报告，中间圆圈中的数字表示该站点在加载过程中的总体 Web性能得分，总分是 100 分。我们目前的得分为 46分，这表示该站点加载阶段的性能还有很大的提升空间。Audits除了生成性能指标以外，还会分析该站点并提供了很多优化建议，我们可以根据这些建议来改进Web应用以获得更高的得分，进而获得更好的用户体验效果。既能分析 Web 性能得分又能给出优化建议，所以 Audits的分析报告还是非常有价值的，那么接下来，我们就来解读下 Audits生成的性能报告。报告的第一个部分是**性能指标(Metrics)**，如下图所示：![](Images/2889e10602c3460774f82fbfc447aea6.png)savepage-src="https://static001.geekbang.org/resource/image/d2/26/d27cde1230afbabf6f914ee987c15026.png"}性能指标 观察上图，我们可以发现性能指标下面一共有六项内容，这六项内容分别对应了从Web应用的加载到页面展示完成的这段时间中，各个阶段所消耗的时长。在中间还有一个View Trace 按钮，点击该按钮可以跳转到 Performance标签，并且查看这些阶段在 Performance中所对应的位置。最下方是加载过程中各个时间段的屏幕截图。报告的第二个部分是**可优化项(Opportunities)**，如下图所示：![](Images/f07db18db2ebe5b69d86ce11ffd375b4.png)savepage-src="https://static001.geekbang.org/resource/image/27/88/275dfab0e15ccf4f59e909e352197b88.png"}可优化项 (Opportunities)slate-object="mark"}这些可优化项是 Audits 发现页面中的一些可以直接优化的部分，你可以对照Audits 给的这些提示来优化你的 Web应用。 报告的第三部分是**手动诊断(Diagnostics)**，如下图所示：![](Images/0f3023f826425503984d93d6db1330e6.png)savepage-src="https://static001.geekbang.org/resource/image/1b/82/1bd988dde8315b1d286a5d72c0244d82.png"}手动诊断 (Diagnostics)slate-object="mark"}在手动诊断部分，采集了一些可能存在性能问题的指标，这些指标可能会影响到页面的加载性能，Audits把详情列出来，并让你依据实际情况，来手动排查每一项。报告的最后一部分是**运行时设置 (RuntimeSettings)**，如下图所示：![](Images/60dd8846c96c4d3126ce1d6d29e0c931.png)savepage-src="https://static001.geekbang.org/resource/image/1a/7a/1a48f900ad3ce35371b92431d984507a.png"}运行时设置 (Runtime Settings)slate-object="mark"}观察上图，这是运行时的一些基本数据，如果选择移动设备模式，你可以看到发送网络请求时的User Agent会变成设备相关信息，还有会模拟设备的网速，这个体现在网络限速上。根据性能报告优化 Web 性能现在有了性能报告，接下来我们就可以依据报告来分析如何优化 Web应用了。最直接的方式是想办法提高性能指标的分数，而性能指标的分数是由六项指标决定的，它们分别是：1.       首次绘制 (First Paint)；        2.       首次有效绘制 (First Meaningfull    Paint)；        3.       首屏时间 (Speed Index)；        4.       首次 CPU 空闲时间 (First CPU    Idle)；    5.       完全可交互时间 (Time to    Interactive)；        6.       最大估计输入延时 (Max Potential First Input    Delay)。        那么接下来我会逐一分析六项指标的含义，并讨论如何提升这六项指标的数值。这六项都是页面在加载过程中的性能指标，所以要弄明白这六项指标的具体含义，我们还得结合页面的加载过程来分析。一图胜过千言，我们还是先看下面这张页面从加载到展示的过程图：![](Images/ae191a47dd1e6f5450820ed009d32f04.png)savepage-src="https://static001.geekbang.org/resource/image/70/99/7041b4d913a12d4d53041e8ed8b30499.png"}页面加载过程slate-object="mark"}观察上图的页面加载过程，我们发现，在渲染进程确认要渲染当前的请求后，渲染进程会创建一个空白页面，我们把创建空白页面的这个时间点称为 **FirstPaint** ，简称**FP**。然后渲染进程继续请求关键资源，我们在《25｜页面性能：如何系统地优化页面？slate-object="inline"》这节中介绍过了关键资源，并且知道了关键资源包括了JavaScript 文件和 CSS文件，因为关键资源会阻塞页面的渲染，所以我们需要等待关键资源加载完成后，才能执行进一步的页面绘制。上图中，bundle.js是关键资源，因此需要完成加载之后，渲染进程才能执行该脚本，然后脚本会修改DOM，引发重绘和重排等一系列操作，当页面中绘制了第一个像素时，我们把这个时间点称为 **First ContentPaint** ，简称**FCP**。接下来继续执行 JavaScript脚本，当首屏内容完全绘制完成时，我们把这个时间点称为 **LargestContent Paint**，简称 **LCP**。在 FCP 和 LCP 中间，还有一个 FMP，这个是首次有效绘制，由于 FMP计算复杂，而且容易出错，现在不推荐使用该指标，所以这里我们也不做过多介绍了。接下来 JavaScript 脚本执行结束，渲染进程判断该页面的 DOM生成完毕，于是触发 DOMContentLoad 事件。等所有资源都加载结束之后，再触发onload 事件。好了，以上就是页面在加载过程中各个重要的时间节点，了解了这些时间节点，我们就可以来聊聊性能报告的六项指标的含义并讨论如何优化这些指标。我们先来分析下**第一项指标 FP**，如果 FP 时间过久，那么直接说明了一个问题，那就是页面的HTML文件可能由于网络原因导致加载时间过久，这块具体的分析过程你可以参考《21｜Chrome开发者工具：利用网络面板做性能分析slate-object="inline"》这节内容。**第二项是 FMP**，上面也提到过由于 FMP计算复杂，所以现在不建议使用该指标了，另外由于 LCP的计算规则简单，所以推荐使用 LCP指标，具体文章你可以参考这里。不过是 FMP 还是LCP，优化它们的方式都是类似的，你可以结合上图，如果 FMP 和 LCP消耗时间过久，那么有可能是加载关键资源花的时间过久，也有可能是JavaScript执行过程中所花的时间过久，所以我们可以针对具体的情况来具体分析。**第三项是首屏时间 (Speed Index)，这就是我们上面提到的LCP**，它表示填满首屏页面所消耗的时间，首屏时间的值越大，那么加载速度越慢，具体的优化方式同优化第二项FMP 是一样。**第四项是首次 CPU 空闲时间 (First CPU Idle)，也称为 FirstInteractive**，它表示页面达到最小化可交互的时间，也就是说并不需要等到页面上的所有元素都可交互，只要可以对大部分用户输入做出响应即可。要缩短首次CPU空闲时长，我们就需要尽可能快地加载完关键资源，尽可能快地渲染出来首屏内容，因此优化方式和第二项FMP 和第三项 LCP 是一样的。**第五项是完全可交互时间 (Time to Interactive)，简称TTI**，它表示页面中所有元素都达到了可交互的时长。简单理解就这时候页面的内容已经完全显示出来了，所有的JavaScript事件已经注册完成，页面能够对用户的交互做出快速响应，通常满足响应速度在50 毫秒以内。如果要解决 TTI时间过久的问题，我们可以推迟执行一些和生成页面无关的 JavaScript工作。 **第六项是最大估计输入延时 (Max Potential First InputDelay）**，这个指标是估计你的 Web 页面在加载最繁忙的阶段，窗口中响应用户输入所需的时间，为了改善该指标，我们可以使用 WebWorker来执行一些计算，从而释放主线程。另一个有用的措施是重构 CSS选择器，以确保它们执行较少的计算。总结好了，今天的内容就介绍到这里，下面我来总结下本文的主要内容：本文我们主要讨论如何优化加载阶段的 Web应用的性能。要想优化 Web 性能，首先得需要有 Web应用的性能数据。所以接下来，我们介绍了 Chrome 采集 Web性能数据的两个工具：Performance 和 Audits，Performance可以采集非常多的性能，但是其使用难度大，相反，Audtis就简单了许多，它会分析检测到的性能数据并给出站点的性能得分，同时，还会给我们提供一些优化建议。我们先从简单的工具上手，所以本文我们主要分析了 Audits的使用方式，先介绍了如何使用 Audits生成性能报告，然后我们解读了性能报告中的每一项内容。大致了解 Audits 生成的性能报告之后，我们又分析 Web应用在加载阶段的几个关键时间点，最后我们分析性能指标的具体含义以及如何提高性能指标的分数，从而达到优化Web 应用的目的。通过介绍，我们知道了 Audits 非常适合用来分析加载阶段的 Web性能，除此之外，Audits还有其他非常实用的功能，比如可以检测我们的代码是否符合一些最佳实践，并给出提示，这样我们就可以根据Audits的提示来决定是否需要优化我们的代码，这个功能非常不错，具体使用方式留给你自己去摸索了。课后思考在文中我们又分析 Web 应用在加载阶段的几个关键时间点，在 Audits中，通过对这些时间点的分析，输出了文中介绍的六项性能指标，其实这些时间点也可以通过Performance 的时间线 (Timelines)来查看，那么今天留给你的任务是：提前熟悉下 Performance工具，并对照这文中加载阶段的几个时间点来熟悉下 Performance 的时间线(Timelines)，欢迎在留言区分享你的想法。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。![](Images/7e91bd5c116048de87e68468f727fc3c.png)savepage-src="https://static001.geekbang.org/resource/image/3f/cb/3f4d5bec2d5c89600b4628581144d8cb.jpg"}
# 加餐二｜任务调度：有了setTimeOut，为什么还要使用rAF？你好，我是李兵。 我们都知道，要想利用 JavaScript 实现高性能的动画，那就得使用requestAnimationFrame 这个 API，我们简称 rAF，那么为什么都推荐使用 rAF而不是 setTimeOut 呢？ 要解释清楚这个问题，就要从渲染进程的任务调度系统讲起，理解了渲染进程任务调度系统，你自然就明白了rAF 和 setTimeOut的区别。其次，如果你理解任务调度系统，那么你就能将渲染流水线和浏览器系统架构等知识串起来，理解了这些概念也有助于你理解Performance 标签是如何工作的。 要想了解最新 Chrome的任务调度系统是怎么工作的，我们得先来回顾下之前介绍的消息循环系统，我们知道了渲染进程内部的大多数任务都是在主线程上执行的，诸如JavaScript 执行、DOM、CSS、计算布局、V8的垃圾回收等任务。要让这些任务能够在主线程上有条不紊地运行，就需要引入消息队列。 在前面的《16 \| WebAPI：setTimeout是如何实现的？slate-object="inline"》这篇文章中，我们还介绍了，主线程维护了一个普通的消息队列和一个延迟消息队列，调度模块会按照规则依次取出这两个消息队列中的任务，并在主线程上执行。为了下文讲述方便，在这里我把普通的消息队列和延迟队列都当成一个消息队列。 新的任务都是被放进消息队列中去的，然后主线程再依次从消息队列中取出这些任务来顺序执行。这就是我们之前介绍的消息队列和事件循环系统。 单消息队列的队头阻塞问题我们知道，渲染主线程会按照先进先出的顺序执行消息队列中的任务，具体地讲，当产生了新的任务，渲染进程会将其添加到消息队列尾部，在执行任务过程中，渲染进程会顺序地从消息队列头部取出任务并依次执行。 在最初，采用这种方式没有太大的问题，因为页面中的任务还不算太多，渲染主线程也不是太繁忙。不过浏览器是向前不停进化的，其进化路线体现在架构的调整、功能的增加以及更加精细的优化策略等方面，这些变化让渲染进程所需要处理的任务变多了，对应的渲染进程的主线程也变得越拥挤。下图所展示的仅仅是部分运行在主线程上的任务，你可以参考下： ![](Images/dd6a530fdecd83079d774b5307c341e1.png)savepage-src="https://static001.geekbang.org/resource/image/fa/f4/fa9f5853a5dcad650aaaf39072820ef4.png"}任务和消息队列slate-object="mark"} 你可以试想一下，在基于这种单消息队列的架构下，如果用户发出一个点击事件或者缩放页面的事件，而在此时，该任务前面可能还有很多不太重要的任务在排队等待着被执行，诸如V8 的垃圾回收、DOM定时器等任务，如果执行这些任务需要花费的时间过久的话，那么就会让用户产生卡顿的感觉。你可以参看下图： ![](Images/cf73c88dbca3a845a9ec865e3e76ad05.png)savepage-src="https://static001.geekbang.org/resource/image/cc/ff/cc7c32fa82207cece9c78015e4b841ff.jpg"}队头阻塞问题slate-object="mark"} 因此，**在单消息队列架构下，存在着低优先级任务会阻塞高优先级任务的情况**，比如在一些性能不高的手机上，有时候滚动页面需要等待一秒以上。这像极了我们在介绍HTTP协议时所谈论的队头阻塞问题，那么我们也把这个问题称为消息队列的队头阻塞问题吧。 Chromium 是如何解决队头阻塞问题的？为了解决由于单消息队列而造成的队头阻塞问题，Chromium 团队从 2013年到现在，花了大量的精力在持续重构底层消息机制。在接下来的篇幅里，我会按照Chromium团队的重构消息系统的思路，来带你分析下他们是如何解决掉队头阻塞问题的。 1. 第一次迭代：引入一个高优先级队列首先在最理想的情况下，我们希望能够快速跟踪高优先级任务，比如在交互阶段，下面几种任务都应该视为高优先级的任务： 1.  通过鼠标触发的点击任务、滚动页面任务；        2.  通过手势触发的页面缩放任务；        3.  通过 CSS、JavaScript    等操作触发的动画特效等任务。        这些任务被触发后，用户想立即得到页面的反馈，所以我们需要让这些任务能够优先与其他的任务执行。要实现这种效果，我们可以增加一个高优级的消息队列，将高优先级的任务都添加到这个队列里面，然后优先执行该消息队列中的任务。最终效果如下图所示: ![](Images/1f935abb0530e96d1136ad8baa02b1a9.png)savepage-src="https://static001.geekbang.org/resource/image/03/c1/039fdf4c399d20a75d7dea9448cc8fc1.jpg"}引入高优先级的消息队列slate-object="mark"} 观察上图，我们使用了一个优先级高的消息队列和一个优先级低消息队列，渲染进程会将它认为是紧急的任务添加到高优先级队列中，不紧急的任务就添加到低优先级的队列中。然后我们再在渲染进程中引入一个**任务调度器**，负责从多个消息队列中选出合适的任务，通常实现的逻辑，先按照顺序从高优先级队列中取出任务，如果高优先级的队列为空，那么再按照顺序从低优级队列中取出任务。 我们还可以更进一步，将任务划分为多个不同的优先级，来实现更加细粒度的任务调度，比如可以划分为高优先级，普通优先级和低优先级，最终效果如下图所示： ![](Images/37333a72b4155abee395b19840b02bb1.png)savepage-src="https://static001.geekbang.org/resource/image/d7/78/d7c71113c6c13047fb79e7d120173b78.jpg"}增加多个不同优先级的消息队列slate-object="mark"} 观察上图，我们实现了三个不同优先级的消息队列，然后可以使用任务调度器来统一调度这三个不同消息队列中的任务。 好了，现在我们引入了多个消息队列，结合任务调度器我们就可以灵活地调度任务了，这样我们就可以让高优先级的任务提前执行，采用这种方式似乎解决了消息队列的队头阻塞问题。 不过大多数任务需要保持其相对执行顺序，如果将用户输入的消息或者合成消息添加进多个不同优先级的队列中，那么这种任务的相对执行顺序就会被打乱，甚至有可能出现还未处理输入事件，就合成了该事件要显示的图片。因此我们需要让一些相同类型的任务保持其相对执行顺序。 2. 第二次迭代：根据消息类型来实现消息队列要解决上述问题，我们可以为不同类型的任务创建不同优先级的消息队列，比如： 1.  可以创建输入事件的消息队列，用来存放输入事件。        2.  可以创建合成任务的消息队列，用来存放合成事件。        3.  可以创建默认消息队列，用来保存如资源加载的事件和定时器回调等事件。        4.  还可以创建一个空闲消息队列，用来存放 V8    的垃圾自动垃圾回收这一类实时性不高的事件。        最终实现效果如下图所示： ![](Images/5098f3946e7f713a1799ce01b4546ac0.png)savepage-src="https://static001.geekbang.org/resource/image/56/ce/56ec510f7f7d4738e9db83dbd51f3fce.png"}根据消息类型实现不同优先级的消息队列slate-object="mark"} 通过迭代，这种策略已经相当实用了，但是它依然存在着问题，那就是这几种消息队列的优先级都是固定的，任务调度器会按照这种固定好的静态的优先级来分别调度任务。那么静态优先级会带来什么问题呢？ 我们在《 [25 \|页面性能：如何系统地优化页面？slate-object="inline"》这节分析过页面的生存周期，页面大致的生存周期大体分为两个阶段，加载阶段和交互阶段。 虽然在交互阶段，采用上述这种静态优先级的策略没有什么太大问题的，但是在页面加载阶段，如果依然要优先执行用户输入事件和合成事件，那么页面的解析速度将会被拖慢。Chromium团队曾测试过这种情况，使用静态优先级策略，网页的加载速度会被拖慢14%。 3. 第三次迭代：动态调度策略可以看出，我们所采用的优化策略像个跷跷板，虽然优化了高优先级任务，却拖慢低优先级任务，之所以会这样，是因为我们采取了静态的任务调度策略，对于各种不同的场景，这种静态策略就显得过于死板。 所以我们还得根据实际场景来继续平衡这个跷跷板，也就是说在不同的场景下，根据实际情况，动态调整消息队列的优先级。一图胜过千言，我们先看下图： ![](Images/52b0bb0290e61781e37f8bac1e78744b.png)savepage-src="https://static001.geekbang.org/resource/image/3c/f5/3cc95247daae7f90f0dced017d349af5.png"}动态调度策略slate-object="mark"} 这张图展示了 Chromium在不同的场景下，是如何调整消息队列优先级的。通过这种动态调度策略，就可以满足不同场景的核心诉求了，同时这也是Chromium当前所采用的任务调度策略。 上图列出了三个不同的场景，分别是加载过程，合成过程以及正常状态。下面我们就结合这三种场景，来分析下Chromium 为何做这种调整。 首先我们来看看**页面加载阶段**的场景，在这个阶段，用户的最高诉求是在尽可能短的时间内看到页面，至于交互和合成并不是这个阶段的核心诉求，因此我们需要调整策略，在加载阶段将页面解析，JavaScript脚本执行等任务调整为优先级最高的队列，降低交互合成这些队列的优先级。 页面加载完成之后就进入了**交互阶段**，在介绍 Chromium是如何调整交互阶段的任务调度策略之前，我们还需要岔开一下，来回顾下页面的渲染过程。 在《 [06 \|渲染流程（下）：HTML、CSS 和JavaScript，是如何变成页面的？slate-object="inline"》和《24 \| 分层和合成机制：为什么 CSS 动画比 JavaScript高效？  slate-object="inline"》这两节，我们分析了一个页面是如何渲染并显示出来的。 在显卡中有一块叫着**前缓冲区**的地方，这里存放着显示器要显示的图像，显示器会按照一定的频率来读取这块前缓冲区，并将前缓冲区中的图像显示在显示器上，不同的显示器读取的频率是不同的，通常情况下是60HZ，也就是说显示器会每间隔 1/60秒就读取一次前缓冲区。 如果浏览器要更新显示的图片，那么浏览器会将新生成的图片提交到显卡的**后缓冲区**中，提交完成之后，GPU会将**后缓冲区和前缓冲区互换位置**，也就是前缓冲区变成了后缓冲区，后缓冲区变成了前缓冲区，这就保证了显示器下次能读取到GPU 中最新的图片。 这时候我们会发现，显示器从前缓冲区读取图片，和浏览器生成新的图像到后缓冲区的过程是不同步的，如下图所示： ![](Images/9b0f43fe91d9991fcd6743d7035c56c9.png)savepage-src="https://static001.geekbang.org/resource/image/1c/38/1c3a9d8a0f56b73331041ea603ad3738.png"}VSync时钟周期和渲染引擎生成图片不同步问题slate-object="mark"}这种显示器读取图片和浏览器生成图片不同步，容易造成众多问题。1.  如果渲染进程生成的帧速比屏幕的刷新率慢，那么屏幕会在两帧中显示同一个画面，当这种断断续续的情况持续发生时，用户将会很明显地察觉到动画卡住了。        2.  如果渲染进程生成的帧速率实际上比屏幕刷新率快，那么也会出现一些视觉上的问题，比如当帧速率在    100fps 而刷新率只有 60Hz 的时候，GPU    所渲染的图像并非全都被显示出来，这就会造成丢帧现象。        3.  就算屏幕的刷新频率和 GPU    更新图片的频率一样，由于它们是两个不同的系统，所以屏幕生成帧的周期和    VSync    的周期也是很难同步起来的。        所以 VSync和系统的时钟不同步就会造成掉帧、卡顿、不连贯等问题。为了解决这些问题，就需要将显示器的时钟同步周期和浏览器生成页面的周期绑定起来，Chromium也是这样实现，那么下面我们就来看看 Chromium具体是怎么实现的？**当显示器将一帧画面绘制完成后，并在准备读取下一帧之前，显示器会发出一个垂直同步信号（verticalsynchronization）给 GPU，简称VSync。**这时候浏览器就会充分利用好 VSync信号。 具体地讲，当 GPU 接收到 VSync 信号后，会将 VSync信号同步给浏览器进程，浏览器进程再将其同步到对应的渲染进程，渲染进程接收到VSync信号之后，就可以准备绘制新的一帧了，具体流程你可以参考下图：![](Images/c09563e653c0a2cc8dcdd0d5f3197937.png)savepage-src="https://static001.geekbang.org/resource/image/06/08/06206ed4846e9531351a0cb7d1db6208.png"}绑定 VSync时钟同步周期和浏览器生成页面周期slate-object="mark"}上面其实是非常粗略的介绍，实际实现过程也是非常复杂的，如果感兴趣，你可以参考这篇文章slate-object="inline"。好了，我们花了很大篇幅介绍了 VSync和页面中的一帧是怎么显示出来，有了这些知识，我们就可以回到主线了，来分析下渲染进程是如何优化交互阶段页面的任务调度策略的？从上图可以看出，当渲染进程接收到用户交互的任务后，接下来大概率是要进行绘制合成操作，因此我们可以设置，**当在执行用户交互的任务时，将合成任务的优先级调整到最高。**接下来，处理完成DOM，计算好布局和绘制，就需要将信息提交给合成线程来合成最终图片了，然后合成线程进入工作状态。现在的场景是合成线程在工作了，**那么我们就可以把下个合成任务的优先级调整为最低，并将页面解析、定时器等任务优先级提升。**在合成完成之后，合成线程会提交给渲染主线程提交完成合成的消息，如果当前合成操作执行的非常快，比如从用户发出消息到完成合成操作只花了8 毫秒，因为 VSync 同步周期是 16.66（1/60）毫秒，那么这个 VSync时钟周期内就不需要再次生成新的页面了。那么从合成结束到下个 VSync周期内，就进入了一个空闲时间阶段，那么就可以在这段空闲时间内执行一些不那么紧急的任务，比如V8 的垃圾回收，或者通过 window.requestIdleCallback()设置的回调任务等，都会在这段空闲时间内执行。4. 第四次迭代：任务饿死好了，以上方案看上去似乎非常完美了，不过依然存在一个问题，那就是在某个状态下，一直有新的高优先级的任务加入到队列中，这样就会导致其他低优先级的任务得不到执行，这称为任务饿死。Chromium为了解决任务饿死的问题，给每个队列设置了执行权重，也就是如果连续执行了一定个数的高优先级的任务，那么中间会执行一次低优先级的任务，这样就缓解了任务饿死的情况。总结好了，本节的内容就介绍到这里，下面我来总结下本文的主要内容：首先我们分析了基于单消息队列会引起队头阻塞的问题，为了解决队头阻塞问题，我们引入了多个不同优级的消息队列，并将紧急的任务添加到高优先级队列，不过大多数任务需要保持其相对执行顺序，如果将用户输入的消息或者合成消息添加进多个不同优先级的队列中，那么这种任务的相对执行顺序就会被打乱，所以我们又迭代了第二个版本。在第二个版本中，按照不同的任务类型来划分任务优先级，不过由于采用的静态优先级策略，对于其他一些场景，这种静态调度的策略并不是太适合，所以接下来，我们又迭代了第三版。第三个版本，基于不同的场景来动态调整消息队列的优先级，到了这里已经非常完美了，不过依然存在着任务饿死的问题，为了解决任务饿死的问题，我们给每个队列一个权重，如果连续执行了一定个数的高优先级的任务，那么中间会执行一次低优先级的任务，这样我们就完成了Chromium 的任务改造。通过整个过程的分析，我们应该能理解，在开发一个项目时，不要试图去找最完美的方案，完美的方案往往是不存在的，我们需要根据实际的场景来寻找最适合我们的方案。思考题我们知道 CSS 动画是由渲染进程自动处理的，所以渲染进程会让 CSS渲染每帧动画的过程与 VSync 的时钟保持一致, 这样就能保证 CSS动画的高效率执行。但是 JavaScript 是由用户控制的，如果采用 setTimeout来触发动画每帧的绘制，那么其绘制时机是很难和 VSync 时钟保持一致的，所以JavaScript 中又引入了 window.requestAnimationFrame，用来和 VSync的时钟周期同步，那么我留给你的问题是：你知道 requestAnimationFrame回调函数的执行时机吗？参考资料下面是我参考的一些资料：1.  [Blink Scheduler             2.  [Blink Scheduler PPT            3.  [Chrome 的消息类型            4.  [Chrome 消息优先级            5.  [无头浏览器            欢迎在留言区分享你的想法。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。![](Images/7e91bd5c116048de87e68468f727fc3c.png)savepage-src="https://static001.geekbang.org/resource/image/3f/cb/3f4d5bec2d5c89600b4628581144d8cb.jpg"}