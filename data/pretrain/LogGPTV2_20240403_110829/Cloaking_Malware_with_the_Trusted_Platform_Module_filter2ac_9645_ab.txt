domain information to one of two command servers [26].
A program without cloaked computation could use cryp-
tographic techniques [59, 18, 28] to keep search criteria
secret while being observed in memory, but their perfor-
mance currently makes them impractical.
2.2.3 Distributed denial-of-service timebomb
A common malware objective is to attack a target at a cer-
tain point in time. Keeping the time and target secret until
the attack prevents countermeasures to reduce the attack’s
impact. A cloaked computation can securely check the
day (as above), and only make the target known on the
launch day.
Malware analysis has often been important for stop-
ping distributed denial-of-service (DDoS) attacks. One
prominent example is MyDoom A. MyDoom A was ﬁrst
identiﬁed on January 26, 2004 [2]. The worm caused in-
fected computers to perform a DDoS on www.sco.com
on February 1, 2004, less than a week after the virus was
ﬁrst classiﬁed. However, the worm was an easy target for
analysts because its target was in the binary obscured only
by ROT-13 [1]. Since the target was identiﬁed prior to
when the attack was scheduled, SCO was able to remove
its domain name from DNS before a DDoS occurred [57].
www.
of
microsoft.com
windowsupdate.com [34], and Code Red’s tar-
geting of www.whitehouse.gov [22] are other
prominent examples of DDoS timebombs whose effects
were lessened by learning the target in advance of the
attack. If timebomb logic is contained in cloaked code,
then it increases the difﬁculty of detecting the time and
target of an upcoming attack. Since the target is stored
only in encrypted form locally on infected machines, the
targeting
Blaster’s
worm’s
[46],
The
Storm
of
targeting
infected machines do not have to communicate over the
network to receive the target at the time of the attack.
Not every machine participating in a DDoS coordinated
by cloaked computation must have a TPM. A one-million
machine botnet could be coordinated by one-thousand
machines with TPMs (to pick arbitrary numbers). The
TPM-containing machines would repeatedly execute a
cloaked computation, as above, to determine when to be-
gin an attack. These machines would send the target to
the rest when they detect it is time to begin the DDoS. In
the example, all million machines must receive the DDoS
target, but the topology of communication is specialized
to the DDoS task and therefore is more difﬁcult to ﬁlter
and less amenable to trafﬁc analysis than a generic peer-
to-peer system.
3 TPM background
This section describes the TPM hardware and support
software in sufﬁcient detail to understand how it can be
used to make malware more difﬁcult to analyze.
3.1 TPM hardware
TPMs are usually found in x86 PCs as small integrated
circuits on motherboards that connect to the low pin
count (LPC) bus and ultimately the southbridge of the PC
chipset. Each TPM contains an RSA (public-key) cryp-
tography unit and platform conﬁguration registers (PCRs)
that maintain cryptographic hashes (called measurements
by the TCG) of code and data that has run on the platform.
The goal of the TPM is to provide security-critical
functions like secure storage and attestation of platform
state and identity. Each TPM is shipped with a public en-
cryption key pair, called the Endorsement Key (EK), that
is accompanied by a certiﬁcate from the manufacturer.
This key is used for critical TPM management tasks, like
“taking ownership” of the TPM, which is a form of ini-
tialization. During initialization the TPM creates a secret,
tpmP roof , that is used to protect keypairs it creates.
The TPM 1.2 speciﬁcation requires PC TPMs to have
at least 24 PCRs. PCRs 0–7 measure core system com-
ponents like BIOS code, PCRs 8–15 are OS deﬁned, and
PCRs 16–23 are used by the TPM’s late launch mecha-
nism, where sensitive software runs in complete hardware
isolation (no other program, including the OS, may run
concurrently unless speciﬁcally allowed by the software).
PCRs cannot be set directly, they can only be extended
with new values, which sets a PCR so that it depends on
its previous value and the extending value in a way that is
not easily reversible. PCR state can establish what soft-
ware has been run on the machine since boot, including
the BIOS, hypervisor and operating system.
3.2 Managing and protecting TPM storage
The TPM was designed with very little persistent storage
to reduce cost. The PC TPM speciﬁcation only mandates
Concatenation of A and B
Public/private keypair for
asymmetric encryption
named name
Encryption of data with a public
key
Signing of data with a signing key
Symmetric key
Symmetric encryption of data
One-way hash (SHA-1) of data
A || B
(P Kname, SKname)
≡ (P K, SK)name
Enc(P K, data)
Sign(SK, data)
K (no P or S at front)
EncSym(K, data)
H(data)
Table 1: Notation for TPM data and computations.
1,280 bytes of non-volatile RAM (NVRAM), so most data
that the TPM uses must be stored elsewhere, like in main
memory or on disk. When we refer to an object as stored
in the TPM, we mean an object stored externally to the
TPM that is encrypted with a key managed by the TPM.
By contrast, data stored in locations physically internal to
the TPM is stored internal to the TPM.
AuthData controls TPM capabilities, which are the
ability to read, write, and use objects stored in the TPM
and execute TPM commands. AuthData is a 160-bit se-
cret, and knowledge of the AuthData for a particular capa-
bility is demonstrated by using it as a key for calculating a
hash-based message authentication code (HMAC) of the
input arguments to the TPM command. 2
Public signature and encryption key pairs created by a
TPM are stored as key blobs only usable with a particular
TPM. The contents of a key blob are shown in Figure 2. A
hash of the public portion of a key blob is stored in the pri-
vate portion, along with tpmP roof (mentioned above);
tpmP roof is an AuthData value randomly generated by
the TPM and stored internally to the TPM when someone
takes ownership. It protects the key blob from forgery by
adversaries and even the TPM manufacturer.3
In addition, a TPM user can use the PCRs to restrict use
of TPM-generated keypairs to particular pieces of soft-
ware that are identiﬁed via a hash of their code and initial
data. For example, the TPM can conﬁgure a key blob so
that it can only be used when the PCRs have certain values
(and therefore only when certain software is running).4
2Since AuthData is used as an HMAC key, it does not need to be
present on the same machine as the TPM for it to be used. For exam-
ple, a remote administrator might hold certain AuthData and use this
to HMAC input arguments and then send these across a network to the
machine containing the TPM. However, AuthData does need to be in
memory (and encrypted) when the secret is ﬁrst established for a TPM
capability as part of a TPM initialization protocol. We investigate fur-
ther the implications of this nuance in our discussions of defenses in
Section 6.
3Migratable keys are handled somewhat differently, but they are be-
yond the scope of this paper.
4Restricting a TPM-generated key to use with certain PCR values is
not the same as the TPM Seal command found in related literature. The
two are similar, but the former places restrictions on a key’s use, while
the later places restrictions on the decryption of a piece of data (which
could be a key blob).
4
Figure 1: The overall ﬂow of the attack is 1) Infecting a system with local malware capable of kernel-level exploitation to coordinate
the attack 2) Establishing a legitimate TPM-generated key usable only by the Infection Payload Loader in late launch via a multistep
protocol with a Malware Distribution Platform 3) Delivering a payload that can be decrypted using the TPM-generated key 4) Using
a late launch environment to decrypt the payload with the TPM-generated key, and running it with inputs passed into memory by
local malware 5) Retrieving output from payload, potentially repeating step 4 with new inputs. Boxes with “TPM” indicate parts of
the protocol that use the TPM.
Blob((P K, SK)ex) ≡ PubBlob((P K, SK)ex) || Enc(P Kparent, PrivBlob((P K, SK)ex))
PubBlob((P K, SK)ex) ≡ P Kex || PCR values
PrivBlob((P K, SK)ex) ≡ SKex || H(PubBlob((P K, SK)ex) || tpmP roof
Figure 2: Contents of TPM key blob for an example public/private key pair named ex that is stored in the key hierarchy under a key
named parent. For our purposes the parent key of most key blobs is the SRK. (Note that the PCR values themselves are not really
stored in the key blob. Rather the blob contains a bitmask of the PCRs whose values must be veriﬁed and a digest of the PCR values.)
TPM key storage is a key hierarchy: a single-rooted
tree whose root is the Storage Root Key (SRK), and is
created upon the take ownership operation described be-
low. The private part of the SRK is stored internal to
the TPM and never present in main memory, even in en-
crypted form. Since the public part of the SRK encrypts
the private part of descendant keys (and so on), all keys in
the hierarchy are described as “stored in the TPM,” even
though all of them, except the SRK, are stored in main
memory. Using the private part of any key in the hierar-
chy requires using the TPM to access the private SRK to
decrypt private keys while descending the hierarchy.
It is impossible to use private keys for any of the key-
pairs stored in the TPM apart from using TPM capabil-
ities: obtaining the private key for one key would entail
decrypting the private portion of a key blob, which in turn
requires the private key of the parent, and so on, up to the
SRK, which is special in that its private key is never stored
externally to the TPM (even in encrypted form). A TPM
key hierarchy is illustrated in Figure 3.
3.3 Initializing the TPM
To begin using a TPM, the user (or administrator) must
ﬁrst take ownership of it. Taking ownership of the TPM
establishes three important AuthData values: the owner
AuthData value, which is needed to set TPM policy, the
SRK AuthData value, which is needed to use the SRK,
and tpmP roof . tpmP roof is generated internal to the
TPM and stored in NVRAM. It is never present in unen-
crypted form outside the TPM.
While it is easy for a professional administrator to
take ownership of a TPM securely, taking ownership of
a TPM is a security critical operation that is exposed in
a very unfriendly way to average users. For example,
Microsoft’s BitLocker full-disk encryption software uses
the TPM. When a user initializes BitLocker, it reboots the
machine into a BIOS-level prompt where the user is pre-
sented cryptic messages about TPM initialization. Bit-
Locker performs the initial ownership of the TPM, and it
acquires privilege to do so with TPM mechanisms for as-
serting physical presence at the platform via the BIOS. An
inexperienced user could probably be convinced to agree
to allow assertion of physical presence by malware similar
to how rogue programs convince users to install malicious
software and input their credit card numbers [44]. The
function of the TPM is complicated and ﬂexible, making
a simple explanation of it for an average user a real chal-
lenge.
Furthermore, malware could also gain use of phys-
ical presence controls in BIOS by attacks that modify
5
authenticity of TPM data, and to modify PCRs to describe
platform state as it changes. Keys are created in the key
hierarchy by “loading” a parent key and commanding the
TPM to generate a key below that parent, resulting in a
new key blob. Loading a key entails passing a key blob to
the TPM to obtain a key handle, which is an integer index
into the currently loaded keys. Only loaded keys can be
used for further TPM commands. Loading a key requires
loading all keys above it in the hierarchy, so loading any
key in the key hierarchy requires loading the SRK.
The TPM can produce signed certiﬁcates of key authen-
ticity. To do so, a user speciﬁes a certifying key, and the
TPM produces a hash of the public key for the key to be
certiﬁed, along with a hash of a bitmask describing the se-
lected PCRs and those PCR values, and signs both hashes
with the selected key.
PCRs can be modiﬁed by the TPM as platform state
changes. They cannot be set directly, and are instead mod-
iﬁed by extension. A PCR with value P CR extended by
a 160-bit value val is set to value Extend(P CR, val) ≡
H(P CR || val). Late launch extends the PCRs with the
hash of the state of the program run in the late launch en-
vironment. Thus the TPM can restrict access to keys to a
particular program. Our malware protocol uses this abil-
ity to prevent analyst use of a payload decryption key.
3.6 TPM functionality evolving and best practices
unknown
Despite the widespread availability of trusted computing
technology as embodied by the TPM, its implications are
not well understood. The speciﬁcation for the TPM and
supporting software is complicated; version 1.2 of the
TPM speciﬁcation for the PC/BIOS platform with accom-
panying TCG Software Stack is over 1,500 pages [52].
Additionally, there are few guidelines for proper use of
its extensive feature set. It is quite believable that such
a complicated mechanism has unintended consequences
that undermine its security goals. In this paper, we pro-
pose such a mechanism: that the TPM can be used as a
means to thwart analysis of malware.
Key hierarchy The lack of guidance on the usage of
TPM capabilities makes it difﬁcult to determine what in-
formation an attacker might reasonably acquire. For ex-
ample, the key hierarchy has a single root. Therefore, dif-
ferent users must share at least one key, and every use of
a TPM key requires loading the SRK. Loading the SRK
requires SRK AuthData, and thus the SRK AuthData is
likely well-known, making it possible for users to imper-
sonate the TPM, as others have previously indicated [21].
EK certiﬁcates As another example of capabilities in
ﬂux, EK certiﬁcates critical to identifying TPMs as legiti-
mate are not always present, and it is not always clear how
to verify those that are. TPM manufacturers are moving
toward certifying TPMs as legitimate by including certiﬁ-
Figure 3: The part of the TPM key hierarchy relevant to our
attack. The TPM box illustrates keying material stored inter-
nal to the TPM, which is only the endorsement key (EK) and
storage root key (SRK). Part (a) shows the conceptual key hi-
erarchy, while part (b) shows how the secret keys of children
are encrypted by the public keys of their parents so keys can be