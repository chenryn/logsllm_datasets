    ConvertFrom-CIPolicy -XmlFilePath $MergedPolicyFilePath -BinaryFilePath $DeployedPolicyPath
    #>
在上面这段代码中，我生成了一个新的策略，并且指定了恶意代码的安装路径。在真实的攻击场景中，这些代码可能会存在于任何一个目录中，所以你可以在设备上生成这种新型的拒绝策略来阻止恶意代码的执行。接下来，我对该目录进行了扫描。在这一步中，你需要过滤出你所希望阻止的那部分特定代码，然后将拒绝策略和引用策略进行整合，最后重新部署新生成的策略。当你部署完成之后，你需要测试新的策略是否有效。为了进行验证，你需要确保完成了
**下列配置工作** ：
1\. 确保已经将目标代码的x86版本和x64版本都屏蔽了。
2\. 至少要屏蔽目标代码的两种版本或两种架构。
比如说，为了验证已签名的cdb.exe是否还会得到执行，你需要确保32位和64位的cdb.exe版本都已经被添加到你的拒绝规则中了。
大家可能已经发现了，为了防止这种类型的攻击，我们必须修改安全策略，并且向XML文件中手动添加目标代码的特定版本编号。所以在下一版本的Device
Guard中，微软将允许用户通过指定一个通配符来为特定代码的所有版本设定拒绝规则。与此同时，这种机制貌似是一劳永逸的。因为新的绕过方法会不断涌现，而你就可以利用这种简单的处理流程来向Device
Guard的代码完整性策略中增加相应的拒绝规则。
目前，我已经对这种缓解方式进行了大量的测试，从测试结果来看，我认为这种缓解方案不仅有效，而且实现起来也并不困难。尽管如此，但我还是希望各位安全研究人员们能够从我的理论中找出漏洞。如果你能够绕过我的缓解方案，那么请你一定要告诉我。
在此，我基于上述代码生成了一份策略文件。 **具体代码如下所示：**
      10.0.0.0
      {A244370E-44C9-4C06-B551-F6016E563076}
      {2E07F7E4-194C-4D20-B7C9-6F44A6C5A234}
          Enabled:Unsigned System Integrity Policy
          Enabled:Audit Mode
          Enabled:Advanced Boot Options Menu
          Required:Enforce Store Applications
          Enabled:UMCI
      0