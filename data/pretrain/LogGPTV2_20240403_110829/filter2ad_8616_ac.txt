## 2.4 总结
本章首先介绍了EVM的存储结构和以太坊中常用的汇编指令。之后逐行分析了智能合约编译后的汇编代码，最后反编译了智能合约的字节码，把反编译的代码和汇编代码做了对比分析。相信读完本章之后，大家基本上能够看懂智能合约的汇编代码和反编译后的代码。在下一章中，我们将介绍如何从智能合约的反编译代码中生成控制流图(control
flow graph)。
## **第三章 从反编译代码构建控制流图**
本章是智能合约静态分析的第三章，第二章中我们生成了反编译代码，本章我们将从这些反编译代码出发，一步一步的构建控制流图。
## 3.1 控制流图的概念
### 3.1.1 基本块(basic block)
基本块是一个最大化的指令序列，程序执行只能从这个序列的第一条指令进入，从这个序列的最后一条指令退出。
构建基本块的三个原则：
  1. 遇到程序、子程序的第一条指令或语句，结束当前基本块，并将该语句作为一个新块的第一条语句。
  2. 遇到跳转语句、分支语句、循环语句，将该语句作为当前块的最后一条语句，并结束当前块。
  3. 遇到其他语句直接将其加入到当前基本块。
### 3.1.2 控制流图(control flow graph)
控制流图是以基本块为结点的有向图G=(N,
E)，其中N是结点集合，表示程序中的基本块；E是结点之间边的集合。如果从基本块P的出口转向基本块块Q，则从P到Q有一条有向边P->Q，表示从结点P到Q存在一条可执行路径，P为Q的前驱结点，Q为P的后继结点。也就代表在执行完结点P中的代码语句后，有可能顺序执行结点Q中的代码语句[[2]](http://cc.jlu.edu.cn/G2S/Template/View.aspx?courseId=644&topMenuId=131469&action=view&curfolid=135637)。
## 3.2 构建基本块
控制流图是由基本块和基本块之间的边构成，所以构建基本块是控制流图的前提。接下来我们以反编译代码作为输入，分析如何构建基本块。
第二章中的反编译代码如下：
    00000: PUSH1 0x80
    00002: PUSH1 0x40
    00004: MSTORE
    00005: PUSH1 0x04
    00007: CALLDATASIZE
    00008: LT
    00009: PUSH1 0x3e
    0000b: JUMPI
    0000c: PUSH4 0xffffffff
    00011: PUSH29 0x0100000000000000000000000000000000000000000000000000000000
    0002f: PUSH1 0x00
    00031: CALLDATALOAD
    00032: DIV
    00033: AND
    00034: PUSH4 0x1003e2d2
    00039: DUP2
    0003a: EQ
    0003b: PUSH1 0x43
    0003d: JUMPI
    0003e: JUMPDEST
    0003f: PUSH1 0x00
    00041: DUP1
    00042: REVERT
    00043: JUMPDEST
    00044: CALLVALUE
    00045: DUP1
    00046: ISZERO
    00047: PUSH1 0x4e
    00049: JUMPI
    0004a: PUSH1 0x00
    0004c: DUP1
    0004d: REVERT
    0004e: JUMPDEST
    0004f: POP
    00050: PUSH1 0x58
    00052: PUSH1 0x04
    00054: CALLDATALOAD
    00055: PUSH1 0x73
    00057: JUMP
    00058: JUMPDEST
    00059: PUSH1 0x40
    0005b: DUP1
    0005c: MLOAD
    0005d: SWAP3
    0005e: ISZERO
    0005f: ISZERO
    00060: DUP4
    00061: MSTORE
    00062: PUSH1 0x20
    00064: DUP4
    00065: ADD
    00066: SWAP2
    00067: SWAP1
    00068: SWAP2
    00069: MSTORE
    0006a: DUP1
    0006b: MLOAD
    0006c: SWAP2
    0006d: DUP3
    0006e: SWAP1
    0006f: SUB
    00070: ADD
    00071: SWAP1
    00072: RETURN
    00073: JUMPDEST
    00074: PUSH1 0x00
    00076: DUP1
    00077: SLOAD
    00078: DUP3
    00079: ADD
    0007a: DUP1
    0007b: DUP3
    0007c: SSTORE
    0007d: DUP2
    0007e: SWAP1
    0007f: DUP4
    00080: GT
    00081: ISZERO
    00082: PUSH1 0x86
    00084: JUMPI
    00085: Missing opcode 0xfe
    00086: JUMPDEST
    00087: SWAP2
    00088: POP
    00089: SWAP2
    0008a: JUMP
    0008b: STOP
我们从第一条指令开始分析构建基本块的过程。`00000`地址处的指令是程序的第一条指令，根据构建基本块的第一个原则，将其作为新的基本块的第一条指令；`0000b`地址处是一条跳转指令，根据构建基本块的第二个原则，将其作为新的基本块的最后一条指令。这样我们就把从地址`00000`到`0000b`的代码构建成一个基本块，为了之后方便描述，把这个基本块命名为基本块1。
接下来`0000c`地址处的指令，我们作为新的基本块的第一条指令。`0003d`地址处是一条跳转指令，根据构建基本块的第二个原则，将其作为新的基本块的最后一条指令。于是从地址`0000c`到`0003d`就构成了一个新的基本块，我们把这个基本块命名为基本块2。
以此类推，我们可以遵照构建基本块的三个原则构建起所有的基本块。构建完成后的基本块如下图所示：
图中的每一个矩形是一个基本块，矩形的右半部分是为了后续描述方便而对基本块的命名(当然你也可以命名成自己喜欢的名字)。矩形的左半部分是基本块所包含的指令的起始地址和结束地址。当所有的基本块都构建完成后，我们就把之前的反编译代码转化成了11个基本块。接下来我们将构建基本块之间的边。
## 3.3 构建基本块之间的边
简单来说，基本块之间的边就是基本块之间的跳转关系。以基本块1为例，其最后一条指令是条件跳转指令，如果条件成立就跳转到基本块3，否则就跳转到基本块2。所以基本块1就存在`基本块1->基本块2`和`基本块1->基本块3`两条边。基本块6的最后一条指令是跳转指令，该指令会直接跳转到基本块8，所以基本块6就存在`基本块6->基本块8`这一条边。
结合反编译代码和基本块的划分，我们不难得出所有边的集合E：
    {
        '基本块1': ['基本块2','基本块3'],
        '基本块2': ['基本块3','基本块4'],
        '基本块3': ['基本块11'],
        '基本块4': ['基本块5','基本块6'],
        '基本块5': ['基本块11'],
        '基本块6': ['基本块8'],
        '基本块7': ['基本块8'],
        '基本块8': ['基本块9','基本块10'],
        '基本块9': ['基本块11'],
        '基本块10': ['基本块7']
    }
我们把边的集合E用python中的dict类型表示，dict中的key是基本块，key对应的value值是一个list。还是以基本块1为例，因为基本块1存在`基本块1->基本块2`和`基本块1->基本块3`两条边，所以`'基本块1'`对应的list值为`['基本块2','基本块3']`。
## 3.4 构建控制流图
在前两个小节中我们构建完成了基本块和边，到此构建控制流图的准备工作都已完成，接下来我们就要把基本块和边整合在一起，绘制完整的控制流图。  
上图就是完整的控制流图，从图中我们可以清晰直观的看到基本块之间的跳转关系，比如基本块1是条件跳转，根据条件是否成立跳转到不同的基本块，于是就形成了两条边。基本块2和基本块1类似也是条件跳转，也会形成两条边。基本块6是直接跳转，所以只会形成一条边。
在该控制流图中，只有一个起始块(基本块1)和一个结束块(基本块11)。当流程走到基本块11的时候，表示整个流程结束。需要指出的是，基本块11中只包含一条指令`STOP`。
## 3.5 总结
本章先介绍了控制流图中的基本概念，之后根据基本块的构建原则完成所有基本块的构建，接着结合反编译代码分析了基本块之间的跳转关系，画出所有的边。当所有的准备工作完成后，最后绘制出控制流图。在下一章中，我们将对构建好的控制流图，采用z3对其进行约束求解。
## **第四章 从控制流图开始约束求解**
在本章中我们将使用z3对第三章中生成的控制流图进行约束求解。z3是什么，约束求解又是什么呢？下面将会给大家一一解答。
约束求解：求出能够满足所有约束条件的每个变量的值。
z3： z3是由微软公司开发的一个优秀的约束求解器，用它能求解出满足约束条件的变量的值。
从3.4节的控制流图中我们不难发现，图中用菱形表示的跳转条件左右着基本块跳转的方向。如果我们用变量表示跳转条件中的输入数据，再把变量组合成数学表达式，此时跳转条件就转变成了约束条件，之后我们借助z3对约束条件进行求解，根据求解的结果我们就能判断出基本块的跳转方向，如此一来我们就能模拟整个程序的执行。
接下来我们就从z3的基本使用开始，一步一步的完成对所有跳转条件的约束求解。
## 4.1 z3的使用
我们以z3的python实现`z3py`为例介绍z3是如何使用的[[3]](https://ericpony.github.io/z3py-tutorial/guide-examples.htm)。
### 4.1.1 基本用法
    from z3 import *
    x = Int('x')
    y = Int('y')
    solve(x > 2, y 
2`, `y  5)
在z3中除了可以创建位向量变量之外，也可以创建位向量常量。下面代码中的`BitVecVal(-1, 16)`创建了一个长度为16位，值为1的位向量常量。
    from z3 import *
    a = BitVecVal(-1, 16)
    b = BitVecVal(65535, 16)
    print simplify(a == b)
### 4.1.4 求解器
    from z3 import *
    x = Int('x')
    y = Int('y')
    s = Solver()
    s.add(x > 10, y == x + 2)
    print s
    print s.check()
在上面代码中，`Solver()`创建了一个通用的求解器，之后调用`add()`添加约束，调用`check()`判断是否有满足约束的解。如果有解则返回`sat`，如果没有则返回`unsat`
## 4.2 使用z3进行约束求解
对于智能合约而言，当执行到`CALLDATASIZE`、`CALLDATALOAD`等指令时，表示程序要获取外部的输入数据,此时我们用z3中的`BitVec`函数创建一个位向量变量来代替输入数据;当执行到`LT`、`EQ`等指令时，此时我们用z3创建一个类似`If(ULE(xx,xx),
0, 1)`的表达式。
### 4.2.1 生成数学表达式
接下来我们以3.2节中的基本块1为例，看看如何把智能合约的指令转换成数学表达式。
在开始转换之前，我们先来模拟下以太坊虚拟机的运行环境。我们用变量`stack=[]`来表示以太坊虚拟机的栈，用变量`memory={}`来表示以太坊虚拟机的内存，用变量`storage={}`来表示storage。
基本块1为例的指令码如下:
    00000: PUSH1 0x80
    00002: PUSH1 0x40
    00004: MSTORE
    00005: PUSH1 0x04