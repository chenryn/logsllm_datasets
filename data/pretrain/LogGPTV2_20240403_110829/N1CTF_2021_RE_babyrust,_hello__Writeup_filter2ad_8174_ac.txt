                        16 * (v5 & 0xF) +
                        (v21 & 0xF)
                    ] + table5[
                        16 * (v6 & 0xF) +
                        (v7 & 0xF)
                    ]
                ] | (16 * table5[
                    16 * table5[
                        16 * ((unsigned __int8)v5 >> 4) +
                        ((unsigned __int8)v21 >> 4)
                    ] + table5[
                        16 * ((unsigned __int8)v6 >> 4) +
                        ((unsigned __int8)v7 >> 4)
                    ]
                ]);
                x_ptr[3] = v13;
                v14 = table4[v25 + v8];
                v15 = table4[v27 + v10];
                v16 = table4[v26 + v9];
                v17 = table4[v28 + v13];
                *x_ptr = table5[
                    16 * table5[
                        16 * (HIBYTE(v14) & 0xF) +
                        (HIBYTE(v16) & 0xF)
                    ] + table5[
                        16 * (HIBYTE(v15) & 0xF) +
                        (HIBYTE(v17) & 0xF)
                    ]
                ] | (16 * table5[
                    16 * table5[
                        16 * (v14 >> 28) +
                        (v16 >> 28)
                    ] + table5[
                        16 * (v15 >> 28) +
                        (v17 >> 28)
                    ]
                ]);
                x_ptr[1] = table5[
                    16 * table5[
                        16 * (HIWORD(v14) & 0xF) +
                        (BYTE2(v16) & 0xF)
                    ] + table5[
                        16 * (HIWORD(v15) & 0xF) +
                        (BYTE2(v17) & 0xF)
                    ]
                ] | (16 * table5[
                    16 * table5[
                        16 * ((v14 >> 20) & 0xF) +
                        ((v16 >> 20) & 0xF)
                    ] + table5[
                        16 * ((v15 >> 20) & 0xF) +
                        ((v17 >> 20) & 0xF)
                    ]
                ]);
                x_ptr[2] = table5[
                    16 * table5[
                        16 * ((v14 >> 8) & 0xF) +
                        (BYTE1(v16) & 0xF)
                    ] + table5[
                        16 * ((v15 >> 8) & 0xF) +
                        (BYTE1(v17) & 0xF)
                    ]
                ] | (16 * table5[
                    16 * table5[
                        16 * ((unsigned __int16)v14 >> 12) +
                        ((unsigned __int16)v16 >> 12)
                    ] + table5[
                        16 * ((unsigned __int16)v15 >> 12) +
                        ((unsigned __int16)v17 >> 12)
                    ]
                ]);
                j_mul_24 += 24;
                x_ptr += 4;
                j_mul_4 += 4;
                *(x_ptr - 1) = table5[
                    16 * table5[
                        16 * (v14 & 0xF) +
                        (v16 & 0xF)
                    ] + table5[
                        16 * (v15 & 0xF) +
                        (v17 & 0xF)
                    ]
                ] | (16 * table5[
                    16 * table5[
                        16 * ((unsigned __int8)v14 >> 4) +
                        ((unsigned __int8)v16 >> 4)
                    ] + table5[
                        16 * ((unsigned __int8)v15 >> 4) +
                        ((unsigned __int8)v17 >> 4)
                    ]
                ]);
            }
            while ( j_mul_24 != 96 );
        }
        func2(x);
        for ( j = 0LL; j != 16; ++j )
            x[j] = table1[256 * j + 0x9000 + x[j]];
        for ( k = 0LL; k != 16; ++k )
            a2[k] = x[k];
    }
但是还是不行，table3与table4是几乎随机的，只有table5很有规律，但是table5的嵌套变换太难逆向。
后来经同学提醒，table5是用来求异或的，也就是`table5[a][b] == a ^ b`，那就可以继续化简func1：
    void func1(unsigned __int8 *x, unsigned __int8 *a2) {
        unsigned __int8 *x_ptr; // rdx
        unsigned int v5; // er12
        unsigned int v6; // eax
        unsigned int v7; // esi
        unsigned __int8 v8; // cl
        unsigned __int8 v9; // di
        unsigned __int8 v10; // cl
        unsigned __int8 v13; // di
        unsigned int v14; // eax
        unsigned int v15; // ecx
        unsigned int v16; // esi
        unsigned int v17; // er12
        __int64 j; // rax
        __int64 k; // rax
        unsigned int v21; // [rsp+4h] [rbp-134h]
        __int64 v25; // [rsp+10h] [rbp-128h]
        __int64 v26; // [rsp+18h] [rbp-120h]
        __int64 v27; // [rsp+20h] [rbp-118h]
        __int64 v28; // [rsp+28h] [rbp-110h]
        int i; // [rsp+ECh] [rbp-4Ch]
        for ( i = 0; i != 9; ++i ) {
            func2(x);
            x_ptr = x;
            for (int j = 0; j > 24) & 0xff;
                v9 = (value >> 16) & 0xff;
                v10 = (value >> 8) & 0xff;
                v13 = value & 0xff;
                v14 = table4[v25 + v8];
                v15 = table4[v27 + v10];
                v16 = table4[v26 + v9];
                v17 = table4[v28 + v13];
                value = v14 ^ v16 ^ v15 ^ v17;
                *x_ptr = (value >> 24) & 0xff;
                x_ptr[1] = (value >> 16) & 0xff;
                x_ptr[2] = (value >> 8) & 0xff;
                x_ptr[3] =  value & 0xff;
                x_ptr += 4;
            }
        }
        func2(x);
        for ( j = 0LL; j != 16; ++j )
            x[j] = table1[256 * j + 0x9000 + x[j]];
        for ( k = 0LL; k != 16; ++k )
            a2[k] = x[k];
    }
那就很明显了，需要int空间的爆破。最终程序：
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #define __int8 char
    #define __int64 long long
    #define __int16 short
    #define _QWORD long long
    #define HIBYTE(x) (assert(sizeof(x) == 4), ((x) >> 24) & 0xff)
    #define BYTE2(x) (assert(sizeof(x) == 4), ((x) >> 16) & 0xff)
    #define BYTE1(x) (assert(sizeof(x) == 4), ((x) >> 8) & 0xff)
    #define HIWORD(x) (assert(sizeof(x) == 4), ((x) >> 16) & 0xffff)
    void* addr = NULL;
    unsigned char* table1;
    unsigned int* table3;
    unsigned int* table4;
    unsigned char* table5;
    void func2(unsigned __int8 *a1) {
      __int64 v1; // rdx
      __int64 v2; // rax
      __int64 v3; // rdx
      int v4[16]; // [rsp+0h] [rbp-68h]
      char v5[16]; // [rsp+40h] [rbp-28h]
      unsigned __int64 v6; // [rsp+58h] [rbp-10h]
      v1 = 0LL;
      v2 = 0LL;
      v4[0] = 0;
      v4[1] = 5;
      v4[2] = 10;
      v4[3] = 15;
      v4[4] = 4;
      v4[5] = 9;
      v4[6] = 14;
      v4[7] = 3;
      v4[8] = 8;
      v4[9] = 13;
      v4[10] = 2;
      v4[11] = 7;
      v4[12] = 12;
      v4[13] = 1;
      v4[14] = 6;
      v4[15] = 11;