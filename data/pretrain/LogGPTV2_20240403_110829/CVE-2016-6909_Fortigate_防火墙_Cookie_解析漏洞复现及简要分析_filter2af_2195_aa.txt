# CVE-2016-6909: Fortigate 防火墙 Cookie 解析漏洞复现及简要分析

##### 译文声明
本文为翻译文章，具体内容表达和含义以原文为准。

## 0x00. 引言
Fortigate 系列是 Fortinet（飞塔）公司旗下的防火墙产品之一。2016年，Shadow Brokers 公开了黑客组织 **Equation Group** 针对各大厂商防火墙的漏洞利用工具，其中就包括一个隐蔽的栈溢出漏洞。该漏洞在 [cve.mitre.org](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-6909) 上有详细说明：
> Buffer overflow in the Cookie parser in Fortinet FortiOS 4.x before 4.1.11, 4.2.x before 4.2.13, and 4.3.x before 4.3.9 and FortiSwitch before 3.4.3 allows remote attackers to execute arbitrary code via a crafted HTTP request, aka EGREGIOUSBLUNDER.

由于购买实体防火墙设备成本较高，笔者选择了 Fortinet 提供的虚拟机镜像版本 **FGT_VM-v400-build0482** 来进行漏洞分析。

### 漏洞影响版本
- Fortinet FortiOS 4.x 至 4.1.11
- Fortinet FortiOS 4.2.x 至 4.2.13
- Fortinet FortiOS 4.3.x 至 4.3.9
- FortiSwitch 至 3.4.3

## 0x01. 漏洞分析

### 文件提取
首先将硬盘镜像 `fortios.vmdk` 挂载到 `/mnt` 目录下：

```bash
$ sudo fdisk -l
...
Device     Boot  Start     End Sectors  Size Id Type
/dev/sdb1  *         1  262144  262144  128M 83 Linux
/dev/sdb2       262145 4194304 3932160  1.9G 83 Linux
...
$ sudo mkdir /mnt/fortios
$ sudo mount /dev/sdb1 /mnt/fortios
```

之后我们便能够在 `/mnt` 目录下查看磁盘中的文件：

```bash
$ cd /mnt/fortios
$ ll
total 23392
drwxr-xr-x 3 root root     1024 Sep 20  2011 ./
drwxr-xr-x 5 root root     4096 Aug 10 18:43 ../
-rw-r--r-- 1 root root  5182591 Sep 20  2011 datafs.tar.gz
-rw-r--r-- 1 root root      107 Sep 20  2011 extlinux.conf
lrwxrwxrwx 1 root root       12 Sep 20  2011 flatkc -> ./flatkc.smp
-rw-r--r-- 1 root root      256 Sep 20  2011 flatkc.chk
-rw-r--r-- 1 root root  1437300 Sep 20  2011 flatkc.nosmp
-rw-r--r-- 1 root root  1501003 Sep 20  2011 flatkc.smp
-r--r--r-- 1 root root    32256 Sep 20  2011 ldlinux.sys
drwx------ 2 root root    12288 Sep 20  2011 lost+found/
-rw-r--r-- 1 root root 15678360 Sep 20  2011 rootfs.gz
-rw-r--r-- 1 root root      256 Sep 20  2011 rootfs.gz.chk
```

也可以通过如下方式直接挂载镜像文件：

```bash
$ sudo modprobe nbd
$ sudo qemu-nbd -r -c /dev/nbd1 ./fortios.vmdk
$ sudo mount /dev/nbd1p1 /mnt
```

查看文件类型，我们可以发现两个内核镜像文件 `flatkc.smp` 和 `flatkc.nosmp`：

```bash
$ file *
datafs.tar.gz: gzip compressed data, last modified: Tue Sep 20 20:17:56 2011, from Unix, original size modulo 2^32 8724480
extlinux.conf: ASCII text
flatkc:        symbolic link to ./flatkc.smp
flatkc.chk:    data
flatkc.nosmp:  Linux kernel x86 boot executable bzImage, version 2.4.25 (root@build170) #2 Tue Sep 20 12:46:19 PDT 2011, RO-rootFS, Normal VGA
flatkc.smp:    Linux kernel x86 boot executable bzImage, version 2.4.25 (root@build170) #3 Tue Sep 20 12:49:39 PDT 2011, RO-rootFS, Normal VGA
ldlinux.sys:   SYSLINUX loader (version 4.00)
lost+found:    directory
rootfs.gz:     gzip compressed data, last modified: Tue Sep 20 20:17:52 2011, from Unix, original size modulo 2^32 19077120
rootfs.gz.chk: data
```

在 `extlinux.conf` 中指定了一些基本配置，包括文件系统 `rootfs.gz`：

```bash
$ cat extlinux.conf 
DEFAULT flatkc ro panic=5 endbase=0xA0000 console=tty0 root=/dev/ram0 ramdisk_size=65536 initrd=/rootfs.gz
```

解压 `rootfs.gz`：

```bash
$ tar xf ./rootfs.gz
$ ll
total 28216
drwxr-xr-x 10 arttnba3 arttnba3     4096 Sep 20  2011 ./
drwxr-xr-x  5 arttnba3 arttnba3     4096 Aug 10 18:52 ../
-rw-r--r--  1 arttnba3 arttnba3  8742988 Sep 20  2011 bin.tar.xz
drwxr-xr-x  2 arttnba3 arttnba3     4096 Sep 20  2011 data/
drwxr-xr-x  2 arttnba3 arttnba3     4096 Sep 20  2011 data2/
drwxr-xr-x  5 arttnba3 arttnba3     4096 Sep 20  2011 dev/
lrwxrwxrwx  1 arttnba3 arttnba3        8 Sep 20  2011 etc -> data/etc
lrwxrwxrwx  1 arttnba3 arttnba3        1 Sep 20  2011 fortidev -> //
drwxr-xr-x  2 arttnba3 arttnba3     4096 Sep 20  2011 lib/
-rw-r--r--  1 arttnba3 arttnba3  4424536 Sep 20  2011 migadmin.tar.xz
drwxr-xr-x  2 arttnba3 arttnba3     4096 Sep 20  2011 proc/
-rw-r--r--  1 arttnba3 arttnba3 15678360 Aug 10 18:54 rootfs.gz
drwxr-xr-x  2 arttnba3 arttnba3     4096 Sep 20  2011 sbin/
drwxr-xr-x  2 arttnba3 arttnba3     4096 Sep 20  2011 tmp/
drwxr-xr-x  8 arttnba3 arttnba3     4096 Sep 20  2011 var/
```

### 启动过程分析

#### 1. init 进程
Linux 内核载入后会启动第一个进程 `init`，程序二进制文件通常是 `/sbin/init`。该文件系统中的 `init` 文件较小，可以直接用 IDA 进行分析：

```c
int __cdecl main()
{
  char *argv[2]; // [esp+0h] [ebp-8h] BYREF
  if ( (int)sub_8049254("bin") >= 0 )
    sub_8049254("migadmin");
  unlink("/sbin/xz");
  unlink("/sbin/ftar");
  argv[0] = "/bin/init";
  argv[1] = 0;
  execve("/bin/init", argv, 0);
  return 0;
}
```

其中 `sub_8049254()` 的核心逆向结果如下：

```c
int __cdecl sub_8049254(const char *a1)
{
  //...
  snprintf(s, 0x200u, "/%s.tar.xz", a1);
  //...
  v1 = fork();
  if ( v1 )
  {
    //...
    if ( v1 > 0 )
    {
      waitpid(v1, &stat_loc, 0);
      if ( BYTE1(stat_loc) )
        goto LABEL_21;
      unlink(s);
    }
  }
  else
  {
    argv[0] = "/sbin/xz";
    argv[1] = "--check=sha256";
    argv[2] = "-d";
    argv[3] = s;
    argv[4] = 0;
    execv("/sbin/xz", argv);
  }
}
```

以上是对 `init` 进程的初步分析。接下来我们将进一步探讨漏洞的具体细节和利用方法。