（1）myFunction和myFloat被存在全局环境中（#0）。要注意的是myFunction所引用的函数对象通过内部属性[[Scope]]指向了它自己的作用域（全局作用域）。
（2）而对于执行期的myFunction('abc')，JavaScript会创建一个新的环境(#1)用来管理参数和本地变量。函数通过(从myFunction.[[Scope]]初始化出来的)外层链来引用外部的环境。由于外层环境链，使得myFunction可以访问到myFloat。
图16.1 变量的动态维度通过栈的执行上下文来控制，而其静态的维度则由环境链来控制。当前的执行上下文、环境和函数都被高亮显示。步骤1展示了myFunction(abc)调用前的数据结构。步骤2则展示了函数调用时的情况
16.10 闭包：使得函数可以维持其创建时所在的作用域
如果一个函数离开了它被创建时的作用域，它还是会与这个作用域以及其外部的作用域的变量相关联。例如：
createInc()所返回的函数并没有失去与startValue的关联——变量所提供的包含状态的函数在函数调用时一直保持着：
闭包是一个函数外加上该函数创建时所建立的作用域。闭包的名字来源于闭包“关闭”了一个函数中自由变量的访问权。我们所说的变量是自由的，是指该变量是定义在函数外部的，而非函数内部。
16.10.1 通过环境来控制闭包
提示：
 这一节我们会深入地介绍闭包的工作机制。首先你应该已经熟悉了环境（在本章稍前一些我们讨论过，可见16.9“环境：变量的管理”）。
闭包是一个代码执行完成之后离开作用域环境依旧存在的例子。要描述闭包如何工作，我们来看一下之前的createInc()函数，并将它拆解为4步（每一步中我们都会高亮标出当前的执行上下文和环境，如果函数是当前的函数，那么它也会被高亮标识）。
（1）这一步在交互之前，在createInc定义之后。createInc的入口被添加到全局的环境中(#0)并指向一个函数对象。
（2）这一步发生在函数调用createInc的执行期间。JavaScript为createInc创建了一个新的环境，并将这个环境推到栈中。它的外层环境是全局环境（即createInc.[[Scope]]）。环境中存在startValue这个变量。
（3）这一步发生在给inc赋值时。当createInc调用结束，它所指向其环境的执行上下文就从栈中被移除了，但是其环境还存在于堆当中，因为inc.[[Scope]]还引用着。inc是一个闭包（函数加上其创建时的环境）。
（4）这一步在inc(1)的执行期间。一个新的环境(#1)被创建并且一个指向它的执行上下文被推入栈中。它的外层环境是inc的[[Scope]]。外部环境使得inc可以访问到startValue。
（5）这一步在inc(1)执行之后。此时没有任何引用（执行上下文、外部域亦或是[[Scope]]）指向inc的环境等。因此这个环境不再被使用，并会被堆所移除。
16.10.2 陷阱：不经意间的环境共用
有时候你创建的函数的行为可能会受当前作用域中变量的影响。在JavaScript中，这可能会产生很多问题，因为通常来说每个函数应该配合函数创建时的变量值。然而，由于函数变成了闭包，函数总是会使用当前变量值。在for循环中，这可能会使函数的工作不符合你的预期。我们用一个例子来说明一下：
f返回了一个包含三个函数的数组。所有的函数依旧可以被f和i的环境所访问到。事实上，它们共享了同一个环境。因此，当循环结束之后，i在环境中的值为3。因此，所有的函数返回的都是3。
这并不是我们所期望的。要修正这个问题，我们要在创建每个函数之前对其所使用的索引i做一个快照。换句话说，我们在每个函数创建时将i的值包装进每个函数。因此我们要这么做：
（1）为每个函数在返回的数组中创建一个新的环境。
（2）在这个创建的新环境中存储当前的i的值。
只有函数可以创建环境，因此我们借助IIFE来完成第一步（详情可见16.6“通过IIFE引入新的作用域”）：
这个例子有一个真实的使用场景，当时在循环中给DOM元素添加事件句柄时就会产生类似的场景。
第17章 对象与继承
JavaScript中的面向对象编程（OOP）分为如下几层。
第1层：单一对象的面向对象（详见17.1“第1层：单一对象”）。
第2层：对象间的原型链（详见17.4“第2层：对象间的原型关系”）。
第3层：作为实例工厂的构造函数，类似于其他语言中的类（详见17.10“第3层：构造函数——实例工厂”）。
第4层：子类，通过继承已有的构造函数，创建新的构造函数（详见17.14“第4层：构造函数之间的继承”）。
每一层都依赖于前一层，可以让你循序渐进地学习JavaScript OOP。第1层和第2层构成了基本核心，当你对更复杂的第3层和第4层感到困惑时，可以随时回顾参考前面两层。
17.1 第1层：单一对象
笼统地说，JavaScript中所有的对象都是从字符串（string）到值（value）的映射。一个对象中的某一项（键、值）称为属性。属性的键（key）始终是文本字符串。属性的值（value）可以是任何JavaScript值，包括函数。方法是值为函数的属性。
17.1.1 属性的种类
属性可以分为3种。
（1）属性（property，或称为数据属性）
对象中的普通属性（即从字符串的键到值的映射），包括方法（method）被称为数据属性。这是到目前为止最常见的属性类型。
（2）访问器（Accessor，或称为访问器属性）
访问器是类似于读、写属性的特殊方法。属性的值存储在普通属性中，而访问器可以计算属性的值。你可以把它们看成是虚拟的属性。详见17.7“访问器（getter和setter）”。
（3）内置属性（Internal property）
只存在于ECMAScript语言规范中。它们不能用JavaScript直接访问，但也许可以用间接的方式访问。规范将内置属性的键置于方括号中。例如，[[Prototype]]持有一个对象的原型，并可以通过Object.getPrototypeOf()来访问。
17.1.2 对象字面量
JavaScript的对象字面量可以直接创建简单对象（Object的直接实例）。下面的代码使用对象字面量，把一个对象赋值给变量jane。这个对象有2个属性：name和describe。其中，describe是一个方法：
（1）在方法中使用this来指代当前对象（也被称为方法调用的接受者）。
（2）ECMAScript 5允许在对象字面量的最后一个属性之后跟一个逗号。哎，并不是所有的旧浏览器都支持。最后的逗号十分有用，因为你可以重新排列属性而不用担心哪个属性放在最后。
你可能存在这样的印象，对象只是从字符串到值的映射。但远不止这些，它们才是真正意义上的通用对象。例如，你可以使用对象间的继承（详见17.4“第2层：对象间的原型关系”），保护对象不被修改。直接创建对象的能力是JavaScript一个显著特点：你可以在没有类的情况下直接创建对象，然后进行抽象处理。例如，构造函数——创建对象的工厂（在17.10“第3层：构造函数——实例工厂”中讨论）大致类似于其他语言中的类。
17.1.3 点运算符（.）：通过固定键值访问属性
点操作符提供了一种简洁的语法访问属性。属性的键必须是标识符（参考7.6“合法标识符”）。如果你想使用任意的名称来读、写属性，那么需要使用中括号操作符（详见17.1.5“中括号操作符（[]）：通过计算出的键访问属性”）。
本节中的示例使用如下对象：
获取属性
点操作符可以“获取”一个属性（读取它的值）。下面是一些例子：
获取一个不存在的属性会返回undefined：
调用方法
点操作符也可用于调用方法：
设置属性
你可以使用赋值操作符（=）为点操作符指向的属性赋值，例如：
如果一个属性不存在，给它赋值时会自动创建该属性。如果一个属性已经存在，给它赋值时会改变该属性的值。
删除属性
delete操作符允许你从一个对象中完全移除一个属性（整个键-值对）。例如：
如果你只是把一个属性设置为undefined，这个属性仍然存在，而且这个对象仍然包含这个键：
如果你删除这个属性，它的键就不存在了：
删除只影响一个对象的直接（“自有的”，非继承的）属性。这并不涉及它的原型（详见17.4.6小节的“删除继承的属性”）。
提示：
 谨慎使用delete操作符。大多数现代的JavaScript引擎都会针对构造函数创建的实例进行性能优化，前提是这些实例没有发生“性状”改变（笼统地说，没有删除或添加属性）。但是，删除属性会破坏这种优化。
delete的返回值
如果属性是自有属性，且不能被删除，delete会返回false。其他的所有情况都会返回true。下面是一些例子。
作为准备，我们创建一个可以被删除的属性和一个不能被删除的属性（17.8.3“通过描述符获取和定义属性”阐述了Object.defineProperty()）。
delete不能删除自有属性时，返回false：
其他所有情况下删除属性，返回true：
delete操作即使没有产生任何改变，也会返回true（继承的属性不会被移除）：
17.1.4 特殊的属性键
虽然你不能使用保留字（如var和function）作为变量名，但可以使用它们作为属性的键：
在对象字面量中，数字也可以用来作为属性的键，但它们会被解析为字符串。点操作符只能访问键为标识符的属性。因此，你需要使用中括号操作符（如以下示例所示）来访问键为数字的属性：
对象字面量也可以使用任意字符串（既不是标识符也不是数字）作为属性的键，但你必须加上引号。而且你需要使用中括号操作符来访问这些属性的值：
17.1.5 中括号操作符（[]）：通过计算出的键访问属性
点操作符需要使用固定的属性键，而中括号操作符可以通过表达式引用一个属性。
通过中括号操作符获取属性
中括号操作符可以通过表达式计算得出一个属性的键：
该操作符也可以通过非标识符的键访问属性：
请注意，中括号操作符强制括号中的内容转化为字符串。例如：
通过中括号操作符调用方法
根据你的期望调用方法：
通过中括号操作符设置属性
设置属性与点操作符类似：
通过中括号操作符删除属性
删除属性也与点操作符类似：
17.2 把任意值转化为对象
虽然不多见，但有时你需要把一个任意值转化为对象。Object()作为一个函数（而不是构造函数）可以提供这种服务。它产生的结果如表17.1所示。
表17.1
值
结果
(无参数调用)
{}
undefined
{}
null
{}
布尔值 bool
new Boolean(bool)
数字 num
new Number(num)
字符串 str
new String(str)
对象 obj
obj（未改变，不需要转化）
下面是一些例子：
下面的函数检查value是否为对象：
注意，如果value不是对象，前面的函数会创建一个对象。你也可以用typeof实现相同的功能（详见9.8.1小节的“缺陷：typeof null”）。
你也可以用构造函数的方式调用Object，这和以函数的方式调用产生的结果相同。
提示：
 应该避免使用构造函数；在大多数情况下，使用一个空的对象字面量会更好：
17.3 this作为函数和方法的隐式参数
当你调用一个函数时，this总是作为一个（隐式）参数。
（1）宽松模式中的普通函数
尽管普通函数中的this没有实际用处，但它仍然作为一个特殊的变量存在，它的值总是指向全局对象（在浏览器中是window，详见16.8“全局对象”）：
（2）严格模式中的普通函数
this总是undefined：
（3）方法
this指向调用方法的对象：
在这个例子的方法中，this的值被称为方法调用的接受者。
17.3.1 在调用函数时设置this：call()，apply()和bind()
记住，函数也是对象。因此，每个函数都有自己的方法。本节介绍了辅助调用函数的三种方法。下面几节中会使用这三种方法来避开一些函数调用的陷阱。接下来的例子都会引用对象jane。
Function.prototype.call(thisValue, arg1?, arg2?, ...)
第一个参数会赋值给被调用函数内的this；剩下的参量（parameter）作为参数（argument）传入被调函数。下面的三个调用方式是等价的：
第二种调用方式，需要重复使用jane，因为call()不知道如何获得被调用函数。
Function.prototype.apply(thisValue, argArray)
第一个参数会赋值给被调函数内的this；第二个参数是一个数组，为被调用函数提供参数。下面的三个调用方式是等价的：
第二种调用方式，需要重复使用jane，因为apply()不知道如何获得被调用的函数。
17.3.2 “用于构造函数的apply()”详细阐述了如何配合构造函数使用apply()
Function.prototype.bind(thisValue, arg1?, ..., argN?)
这个方法展示了偏函数（partial function）应用——意味着它创建了一个新的函数，并用接下来的方式调用bind()的接受者：this的值是thisValue，参数从arg1到argN，紧随其后的是新函数的参数。换句话说，当调用原来的函数时，新函数将其参数追加到arg1, … , argN的后面。让我们来看一个例子：
数组方法slice用来把arguments转化为数组，有必要说明一下（这种方式会在17.14.3“类似数组的对象和泛型方法”中介绍）。bound是一个新函数，运行结果如下：
下面的三个sayHelloTo调用都是等价的：
17.3.3 用于构造函数的apply()
我们假设JavaScript有一个三点操作符（...）可以把数组转化为实际参数。这个操作符可以对数组使用Math.max()（详见21.4“其他函数”）。在这种情况下，下面的两个表达式是等价的：
对于函数，你可以通过apply()实现三点操作符的功能：
三点操作符也同样适用于构造函数：
但这里apply()并不起作用，因为它只对函数或方法调用有效，对构造函数调用无效。
为构造函数手动模拟apply()
我们可以用两步来模拟apply()。
（1）第一步
通过方法调用，把参数传给Date（虽然参数并不是数组）：
上面的代码使用bind()创建没有参数的构造函数，并通过new调用。
（2）第二步
使用apply()把数组传给bind()。因为bind()是方法调用，所以我们可以使用apply()：
上面的数组仍有多出的一个元素null，我们可以使用concat()加在前面：
方法库
前面手动解决方案的灵感来源于Mozilla发布的方法库。下面是稍加修改的版本：
使用方法：
另一种方法
前面方案的一种替代方法是，通过Object.create()创建未初始化的实例，然后通过apply()调用构造函数（作为函数）。这实际上意味着重新实现了new操作符（忽略了一些检查）：
警告：
 上面的代码对大多数内置构造函数不起作用，作为函数调用时，总会生成新的实例。换句话说，（1）行的步骤并没有如期设置inst。
17.3.4 缺陷：提取方法时丢失this
如果从一个对象中提取方法，这个方法又变成真正的函数。它与对象的连接被切断，通常不会再正常工作了。例如，下面的对象，counter：
提取inc，调用（作为函数）失败：