In
concrete implementations the internal state is considered as
a single entity, as modeled in [11] and [16]. Finally, en-
tropy accumulation in the internal state is modeled clearly
only in [16]. Therefore we use the security model of [16]
as a starting point for our analysis. Furthermore, our code
source analysis shows that in certain situations, only a par-
tial compromise of the internal state is necessary to make
the PRNG predictable. As a partial compromise of the in-
ternal state is not captured by any of these security models,
we propose a slight modiﬁcation of the security model of [16]
to capture this new adversarial potential. Our modiﬁcation
allows to identify precisely the part of the internal state that
needs to be compromised to make the output of the PRNG
predictable.
From Implementations To Security Models. Deﬁni-
tion 1 describes a PRNG as a triple of algorithms G = (setup,
refresh, next), where setup is a probabilistic algorithm that
outputs a public parameter seed for the generator. As en-
tropy needs to be extracted from the inputs used to refresh
the PRNG, a randomness extractor is needed, ensuring that
each input actually gives entropy to the PRNG. However,
it is well known that no deterministic extractor can extract
good randomness from all entropy sources and therefore a
seeded extractor is necessary (see for example [30]). The pa-
rameter seed used in the security model is the seed of the ex-
tractor, which is completely public (the only requirement is
that it is random). None of the PRNG implementations use
an explicit extractor: all of them use the SHA1 function to
mix new input into the current internal state or to generate
outputs. We therefore assume for our analysis that the SHA1
function deﬁnes a hash functions family used as an extrac-
tor, whose seed is the public parameter K = K0||K1||K2||K3,
where K0 = 5A827999, K1 = 6ED9EBA1, K2 = 8F1BBCDC,
and K3 = CA62C1D6 are the round constants deﬁned in the
speciﬁcation [28]. Hence, for all PRNGs presented in this
work, we assume that the algorithm setup always outputs
this public parameter K, of size 128 bits and the underlying
extractor is the hash function family deﬁned in the speciﬁ-
cation [28], indexed by the parameter K. We will therefore
refer to the SHA1 function in our description as HK, to iden-
tity the underlying hash function family. As a consequence,
this assumption shows that our attacks on PRNGs are inde-
pendent of the hash function used and are related to their
design.
Assumption 1 (Hash Function Family). All PRNGs use
the hash function family HK as a randomness extractor.
All implementations contain instructions that can be eas-
ily related to the refresh and next algorithms. However,
while our security model considers PRNGs that may be re-
freshed with potentially biased inputs, in most applications,
the refresh algorithm is called just one time with a single
input. Hence after this single call, the entropy contained
in S (named hereafter γ∗) is bounded by the size of the
input (named hereafter p). An attacker may gain informa-
tion about the behavior of the environment and estimate the
entropy of this single input (named hereafter c) when col-
lected by the PRNG. An example of this idea is presented
in [26], where it was discovered that the input in the An-
droid SHA1PRNG implementation actually contains very low
entropy since it was not generated by several calls to system
variables. During our analysis, we discovered vulnerabilities
that are complementary to this work, as we focus on the
global behavior of the PRNG.
3.2 An Illustrative Example
Let us illustrate our analysis. In our security model, an
attacker can compromise the internal state (partially or to-
tally) and the PRNG security game ensures that enough
entropy is accumulated in the internal state to generate out-
put. The OpenSSL PRNG has an internal state of size 1072
bytes, which contains an entropy pool of size 1023 bytes and
internal counters. The structure of S is named hereafter
1006its decomposition, which is public for OpenSSL and known
to the attacker. We show that an attacker only needs to
compromise 40 bytes of the internal state and to control
23 bytes of an input of size 1023 bytes (with a legitimate
distribution sampler, as described hereafter in Deﬁnition 2)
to predict a future output of the PRNG. Hence, this shows
that OpenSSL PRNG does not resist a single internal state
compromise.
3.3 The Security Model
As explained in Section 3.1, we propose a slight modiﬁ-
cation of the robustness security model of [16] to identify
exactly the part of S that an attacker needs to compro-
mise to attack a PRNG. To formalize this idea, we con-
sider the internal state as a concatenation of several binary
strings (named hereafter its decomposition). We model the
adversarial capacity of an attacker A with two new functions
named M-get and M-set that allow A to set or get a part
of the internal state of the PRNG deﬁned with a mask M.
We assume that the attacker A knows the decomposition of
S and is able to choose M. The only diﬀerences between
our security game and [16] is that we replace the procedures
get-state and set-state, with new procedures M-get-state and
M-set-state, allowing to the attacker to get/set a part the
internal state identiﬁed by the mask.
Deﬁnition 3 (Decomposition). A decomposition of a bi-
nary string S ∈ {0, 1}n is a sequence of disjoint binary
strings (S1,··· , Sk), such that S = [S1||···||Sk]. Two bi-
nary strings S and M have the same decomposition if |S| =
|M|, M = [M1||···||Mk] and |Si| = |Mi| for i ∈ {1,··· , k}.
Deﬁnition 4 (M-get / M-set). The function M-get takes
as input a triple (S, M, J), where S, M ∈ {0, 1}n have the
same decomposition S = [S1||···||Sk], M = [M1||···||Mk]
and J ⊂ {1,··· , k}, then M-get(S, M, J) = S, where Sj =
Mj, for j ∈ J. The function M-set takes as input a couple
(S, J), where S = [S1||···||Sk] and J ⊂ {1,··· , k}, then
M-set(S, J) = {Sj}, for j ∈ J.
These function are adversarially provided, and their goal is
to let A choose the mask M over the internal state. Note
that if the mask is too large (so that G becomes insecure),
the security game will require that new input is collected.
They model partial memory corruption of the PRNG.
Security Model. We now describe our security model.
It is adapted from the security game ROB(γ∗) of [16] that
deﬁnes the robustness of a PRNG. We describe brieﬂy the
parameters of the security game:
• Integer γ∗: Deﬁnes the minimum entropy that is re-
• Integer c: Deﬁnes the estimate of A of the amount of
• Integer λ ≤ n: Deﬁnes the size of the mask M.
• Boolean ﬂag corrupt: It is set to true if c  0 do
S∗
2 = S2[S1 mod 1023, . . . , S1 + 20 mod 1023]
U = HK([S3||S∗
S∗
2 = S∗
S1 = S1 + 20 mod 1023
S5 = S5 + 1