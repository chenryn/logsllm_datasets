the same facts as the taint analysis. The algorithm is adapted from
Smaragdakis work on Datalog-based program analysis [33, 34].
Again, we use the backward slice and track the chain of dereferences,
starting with the lowest chain. In this case we encounter edi+0x38
to be our memory cell of interest. The base operand is then attached
to a unique id that stands for the memory region. We further need
to attach a unique id to edi+0x38. With the latter setting the field
sensitivity comes into play. Whenever we encounter a memory
dereference with that id, we taint the register. This expands the facts
in our knowledge base on controllable data, which is transparently
Figure 4: Y-Axis:Number of satisfiable paths which lead to an
attacker sink; X-Axis: Path length (number of basic blocks).
We implemented our symbolic execution component on top of
angr [31], a platform-agnostic binary analysis framework. Once
we generate the paths between source and sinks, as described in
§ 3.4, we force angr’s symbolic execution engine to follow one path
at a time and check for its satisfiability. angr has support for the
Unicorn engine, an Qemu based emulator which we use for our
verification procedure. We feed a dump into angr, set the memory
values according to our memory maps, and start the emulation
process until we hit our sink. This is done for every sink and every
satisfiable path that hits the sink. If this procedure is successful,
corresponding templates are used to generate EPT scripts.
5 EVALUATION
We evaluate our system on a corpus of several CVE cases which
target the browsers Internet Explorer, Mozilla Firefox and Google
Chrome. For each test case we used an existing proof-of-concept
which we refer to as the original PoC. We used these original PoCs
as a ground truth to verify if we can trigger the same attacker sinks.
We used the VUTs to determine attacker-controlled data at the first
dereferenced move into a CPU register. PrimGen is then fed with
the VUT, the binary, and a template file. Our measurements are
performed on a machine running with Intel Xeon CPUs E5-2667 @
2.90GHz, 96GB RAM.
5.1 Exploitation Primitive Trigger (EPT)
PrimGen is able to generate several EPT scripts for all CVE case
studies. Table 2 summarizes our analysis results. Overall we found
486 ways to trigger exploitation primitives for which 48 usable
EPT scripts were generated. For CVE-2016-9079 and CVE-2014-1513,
we achieved full coverage of all attacker sinks. Note that some
EPT inputs trigger the same primitive, which explains the higher
number of EPTs in CVE-2016-9079. In this case the system generated
33 EPT scripts that reach the sinks. Since WWW primitives are
also WrW primitives, the number of sinks are equal in some case
studies.
From the specific control point we gain through its VUT, the
mshtml.dll turns out to be the most affected. We discovered that
many sinks reside deep in the interprocedural CFG, unreachable
by our path analysis to cover all of them in a reasonable time.
For the same reason, we do not reach the original PoC sink in
01020304050051015202530xul.dll46.0.1.5966chrome35.0.1916.153mshtml.dll10.0.9200.16384xul.dll50.0.1.6171308ACSAC ’18, December 3–7, 2018, San Juan, PR, USA
B. Garmany et al.
Table 2: Overview of the affected CVEs and our analysis results: The fourth column shows the number of alternative exploit
primitives (sinks) denoted as EIP/WWW/WrW. The fifth column shows the number of satisfiable paths which lead to the
attacker sinks. Among these paths, PrimGen generated EPTs, listed in the sixth column. The seventh column lists the number
of attacker sinks we cover through EPTs, denoted in the same fashion as in the fourth column. The eight column depicts if
the original PoC sink is triggered by any of our inputs. The last column shows the verification time in minutes for satisfiable
paths.
Advisory ID
CVE-2014-0322
CVE-2014-1513
CVE-2016-1960
CVE-2016-2819
CVE-2016-9079
CVE-2014-3176
Total
Binary
V ersion
mshtml .dll
mozjs.dll
xul .dll
xul .dll
xul .dll
chrome
10.0.9200.16384
27.0
44.0.2.5884
46.0.1.5966
50.0.1.6171
35.0.1916.153
Sinks
27/125/119
1/0/1
17/9/9
17/9/9
9/1/1
8/6/8
79/150/147
SAT
188
6
28
25
40
199
486
EPT
4
2
4
2
33
3
48
Sinks covered
1/3/3
1/0/1
2/2/2
0/1/1
9/1/1
0/2/1
21/12/15
PoC covered
✓
✓
✗
✗
✓
✓
−
V eri f y
16.2
3.7
5.4
4.9
24.25
18.04
72.49
Table 3: Controlled data: The second column lists the number of IL instructions that operate on controlled data. The third
column lists the number of reachable functions from the control point. The fourth column shows the number of functions
which operate on controlled data. The last column lists the timings (in seconds) for the taint analysis.
Advisory ID
CVE-2014-0322
CVE-2014-1513
CVE-2016-1960
CVE-2016-2819
CVE-2016-9079
CVE-2014-3176
Controllable IL instructions Reachable Functions
6665
85
881
897
215
1747
10655
6680
17571
15691
12154
2505
Functions touching controlled data Time
115
39
16
11
102
51
320
15
74
72
17
101
adapted by our Datalog algorithms. The result of this process is
shown in Table 2.
Table 3 indicates that among all reachable functions only a small
portion of these functions touches controlled data. This again leaves
space for tuning the procedure in the preprocessing phase. If the
analysis reaches a point where it needs a function that is not present
in the knowledge base, then the system updates the knowledge
base accordingly. The values in Table 3, however, are acquired over
all reachable functions.
Function call skips. Recall from § 3.4 that we might skip calls,
even if they touch controlled data. For mshtml.dll (CVE-2014-
0322) we encountered an interplay between user controlled buffer
and a sprayed heap buffer. Our system might generate input that
crashes before we reach the control point. In this case the system
puts the input in a queue for further processing once the validation
of all inputs is done. To find the cause of conflict, we intercept the
crash and investigate if any of our controlled data is involved in
the crash where a function skip occurred. In this case the path gen-
eration for this specific case is repeated which include the skipped
functions. To avoid the regeneration of existing path prefixes up to
the point where the function is skipped, we cache each path in a
trie datastructure (see § 3.4). The path generation starts from the
entry point of the skipped function and follows the same strategy
as discussed in § 3.4 until it reaches its call site. The paths are then
stitched with the satisfiable path prefixes.
6 DISCUSSION AND LIMITATIONS
The urge for building automated binary analysis systems that op-
erate at scale and efficacy is undeniable. One of the big open limi-
tations is practicality on large, complex applications. Fuzzing has
become an attractive and valuable instrument to pinpoint bugs
in large binaries and is gaining more and more attention in re-
search [7, 8, 29]. Again we stress that the intention of our prototype
at this point is not to find bugs, but to automate the exploitation
step that starts from an attacker-influenced point induced by a
vulnerability. Many bug classes are too complex to be exploited in
a generic manner; a human expert is still required.
In all evaluated case studies, the heap layout plays a key role
which might have a non-deterministic behavior. For CVE-2014-0322,
PrimGen needs to know how a user controlled buffer interplays
with the heaps buffer in order to succeed. Heap spray routines that
can be templated and passed to our system need the attacker’s
knowledge on how the offsets overlap with the native context.
These are interesting and challenging problems that we attempt to
approach in the future.
We argue that supporting and guiding a human expert [21, 32]
through the process of exploit development in an automated manner
309Towards Automated Generation of Exploitation Primitives for Web Browsers
ACSAC ’18, December 3–7, 2018, San Juan, PR, USA
is an important step towards automated exploitation of complex
vulnerabilities, as they can be found in web browsers. We cannot
rule out with failure runs of PrimGen that there is no way to drive
execution into an exploitable state. However, complete failure runs
indicate a more complex and difficult situation driven through the
given VUT, which might not be worth the effort. In fact, PrimGen
gives insight about the quality of a VUT and the severity posed by
the vulnerability.
Note that we do not generate fully weaponized exploits, but
extend the attacker’s control towards a successful exploit. However,
full exploits we observed are dependent on the procedures which
PrimGen provides automatically.
7 RELATED WORK
The problem of automated exploit generation has been tackled by
research in the recent past. In this section, we discuss work closely
related to ours. In many ways, binary analysis can be seen as a
search space problem. Recent research has thoroughly explored
different strategies to cope with state explosion by minimizing the
search space leading to most promising or interesting areas in the
codebase. A recent work by Trabish et al. [40] tackles this problem
in a new way. The authors propose Chopped Symbolic Execution,
a technique that leverages several on-demand static analyses to
determine code fragments which can be excluded. These fragments
also involve functions that do not touch dependent data and there-
fore are candidates to be skipped. We follow a similar intention by
our ahead-of-time path generation procedure that skips functions
not related to any controlled data.
Brumley et al. [10] proposed a method for automatic patch-based
exploit generation (APEG), a problem that was previously addressed
in a manual way. APEG uses the patched binary to identify vulnera-
bility points and indicates the conditions under which it can exploit
the unpatched binary. The authors use a dynamic approach with
static analysis by utilizing known inputs that drive the execution
close to their target spot and use static slicing to close the gap. We
believe that this might integrate well within our path generation
procedure by using the dump at the control point. AEG [5] extended
this approach and tackled the problems of finding exploitable bugs
and automatically generating exploits for mainly stack-based over-
flows and format-string vulnerabilities. AEG works solely on source
code and introduces preconditioned symbolic execution as a tech-
nique to manage the state explosion problem. Mayhem [12] again
extended AEG to binary code. The system analyzes the binary by
performing path exploration until a vulnerable state is reached. It
introduced a hybrid symbolic execution approach that alternates
between online and offline (concolic) modes of symbolic execution,
once a memory cap is reached. Mayhem uses several path priori-
tization heuristics to drive the execution towards paths that most
likely contain bugs.
Heelan [19] proposed a technique for exploit generation that
requires two parameters: a crashing input and shellcode. The crash-
ing input is used on instrumented code to pinpoint and identify
a potential vulnerability. Dynamic taint analysis is used to find
suitable buffers where the shellcode might fit in. Once the exploit
type is determined, the system generates formula constraining the
suitable memory area to the value of shellcode. This formula is
combined with a formula to build IP (instruction pointer) control
to calculate the path conditions. At the end of the analysis, a final
formula expresses the conditions of the exploit. This approach is
extended by Repel et al. [28]. The authors propose a modular system
which targets a more complex scenario, i.e., generating exploits for
heap based buffer overflow vulnerabilities. Taint analysis is mim-
icked by the process of dynamic symbolic execution where the goal
is approached to find primitives which suit the purpose of certain
exploitation techniques against Windows XP systems.
An extension to the problem of finding suitable shellcode buffers
was examined by Bao et al. [6]. In particular, the authors deal with
the shellcode transplant problem. They present ShellSwap, a tool
that modifies the original exploit of a vulnerable program to deal
with a new shellcode that carries out different actions desired by
the attacker.
Frameworks like Mayhem or AEG that deal with a fully auto-
matic generation of exploits are limited to simpler bug classes [31].
All these systems focus on generating end-to-end exploits, at the
expense of limiting their support to certain bug classes, techniques
or simpler binaries. However, they set an important stage for future
research on more complex cases. This is the stage we aim to tackle
with PrimGen by driving research towards very complex scenarios
with larger codebases as they can be found in web browsers.
8 CONCLUSION
In this paper, we demonstrated how to automate a crucial part
of the exploitation process: locating reachable exploitation primi-
tives in complex binary code such as modern browsers. In practice,
searching and finding such a primitive, analyzing the corresponding
program paths, and crafting the fields correctly is a cumbersome
and manual task. We demonstrated how all these steps can be auto-
mated based on a combination of static and dynamic binary analysis
techniques. Based on a vulnerability testcase (VUT), our prototype
implementation called PrimGen successfully generates new and
previously unknown opportunities that drive the execution into
exploitable states in different web browsers. We view this as an