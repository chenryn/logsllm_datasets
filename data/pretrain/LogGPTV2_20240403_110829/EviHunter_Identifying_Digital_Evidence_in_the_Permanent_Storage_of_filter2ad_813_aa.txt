title:EviHunter: Identifying Digital Evidence in the Permanent Storage of
Android Devices via Static Analysis
author:Chris Chao-Chun Cheng and
Chen Shi and
Neil Zhenqiang Gong and
Yong Guan
EviHunter: Identifying Digital Evidence in the Permanent
Storage of Android Devices via Static Analysis
Chris Chao-Chun Cheng, Chen Shi, Neil Zhenqiang Gong, and Yong Guan
Department of Electrical and Computer Engineering
NIST Center of Excellence in Forensic Science - CSAFE
Iowa State University
{cccheng, cshi, neilgong, guan}@iastate.edu
8
1
0
2
g
u
A
8
1
]
R
C
.
s
c
[
1
v
7
3
1
6
0
.
8
0
8
1
:
v
i
X
r
a
ABSTRACT
Crimes, both physical and cyber, increasingly involve smartphones
due to their ubiquity. Therefore, digital evidence on smartphones
plays an increasingly important role in crime investigations. Digital
evidence could reside in the memory and permanent storage of a
smartphone. While we have witnessed significant progresses on
memory forensics recently, identifying evidence in the permanent
storage is still an underdeveloped research area. Most existing
studies on permanent-storage forensics rely on manual analysis or
keyword-based scanning of the permanent storage. Manual analysis
is costly, while keyword matching often misses the evidentiary data
that do not have interesting keywords.
In this work, we develop a tool called EviHunter to automatically
identify evidentiary data in the permanent storage of an Android
device. There could be thousands of files on the permanent storage
of a smartphone. A basic question a forensic investigator often
faces is which files could store evidentiary data. EviHunter aims to
answer this question. Our intuition is that the evidentiary data were
produced by apps; and an app’s code has rich information about the
types of data the app may write to a permanent storage and the files
the data are written to. Therefore, EviHunter first pre-computes an
App Evidence Database (AED) via static analysis of a large number
of apps. The AED includes the types of evidentiary data and files
that store them for each app. Then, EviHunter matches the files on
a smartphone’s permanent storage against the AED to identify the
files that could store evidentiary data. We evaluate EviHunter on
benchmark apps and 8,690 real-world apps. Our results show that
EviHunter can precisely identify both the types of evidentiary data
and the files that store them.
CCS CONCEPTS
• Applied computing → System forensics;
KEYWORDS
Digital Forensics, Mobile Device Forensics, Static Analysis
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
CCS ’18, October 15–19, 2018, Toronto, ON, Canada
© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5693-0/18/10...$15.00
https://doi.org/10.1145/3243734.3243808
ACM Reference Format:
Chris Chao-Chun Cheng, Chen Shi, Neil Zhenqiang Gong, and Yong Guan.
2018. EviHunter: Identifying Digital Evidence in the Permanent Storage
of Android Devices via Static Analysis. In 2018 ACM SIGSAC Conference
on Computer and Communications Security (CCS ’18), October 15–19, 2018,
Toronto, ON, Canada. ACM, New York, NY, USA, 13 pages. https://doi.org/
10.1145/3243734.3243808
1 INTRODUCTION
Smartphones are playing an increasingly important role in inves-
tigating both cyber and physical crimes, as they are pervasive de-
vices and they capture both online and offline activities of their
owners. For instance, even several years ago when smartphones
were not as pervasive as today, the number of crimes that involve
mobile-phone evidence increased 10% per year on average from
2006 to 2011 [33]. In 2017, a visiting scholar at University of Illinois
Urbana-Champaign was kidnapped. Via forensic examination of the
suspect’s smartphone, FBI agents found that the smartphone owner
visited websites about “perfect abduction fantasy” and “planning
a kidnapping”, which has been used as important digital evidence
investigation [42]. Likewise, in one of the biggest poaching cases
in Washington [14], suspects took pictures and videos of killing
animals (illegally). GPS locations retrieved from these images and
videos led to dozens of kill sites where physical evidence (e.g., bul-
lets) was found, and texts retrieved from the suspects’ smartphones
were used as digital evidence to corroborate charges.
Digital evidence on a smartphone could reside in the memory or
permanent storage, e.g., flash storage, SD card. Recently, a series of
tools [37–40] have been developed to significantly advance memory
forensics. However, identifying digital evidence in the permanent
storage of a smartphone is still an underdeveloped research area.
While memory forensics can reconstruct a smartphone’s context
that is probably in a short period of time before the last use of
the smartphone, permanent-storage forensics could uncover evi-
dentiary data about the smartphone’s historical activities over a
long period of time, as some criminal cases may be planned and
conducted across a large range of dates and locations. In this work,
we focus on permanent-storage forensics. More specifically, data
are stored in files by apps on a permanent storage; and one basic
problem a forensic investigator often faces is which files, among
the possibly thousands of files on a suspect’s smartphone, could
store relevant evidentiary data (e.g., GPS locations, visited URLs,
and texts). We call this problem evidence identification problem. Af-
ter identifying such files, forensic investigators can then retrieve,
decode, or reconstruct the evidentiary data from them.
CCS ’18, October 15–19, 2018, Toronto, ON, Canada
Chris Chao-Chun Cheng, Chen Shi, Neil Zhenqiang Gong, and Yong Guan
Existing studies on this evidence identification problem mainly
rely on manual analysis [9–11, 46] or keyword-based scanning [2,
3, 7, 17]. For instance, in keyword-based scanning, a file whose file
name or content includes the keywords GPS, latitude, or longitude
is labelled as a file that could include GPS locations. Manual analysis
is time-consuming and error-prone, while keyword-based scanning
misses the files that do not include the specified keywords. Indeed,
studies [23] showed that keyword-based scanning can only identify
a small fraction of files that could store evidentiary data.
Our work: In this work, we develop EviHunter, a tool to automat-
ically identify the files on an Android device that could store the
evidentiary data of interest to forensic investigators. Our intuition
is that the files/data on a smartphone were produced by apps; an
app’s code contains rich information about 1) the types of data that
the app could write into a file system and 2) the files where the data
are written to.
Based on the intuition, EviHunter takes an offline-online ap-
proach. In the offline phase, EviHunter builds an App Evidence
Database (AED) for a large number of apps via static data flow
analysis. Specifically, for each app, the AED includes the files that
could store evidentiary data of interest and the types (e.g., location,
visited URL, text input, and time) of evidentiary data in each of
such files, where a file is represented using its complete file path
on Android. We adopt static analysis instead of dynamic analysis
to have high coverage and be less likely to miss the files that could
contain evidentiary data. In the online phase, given a smartphone,
EviHunter matches the file paths on the smartphone’s file system
against those in the AED to identify the files that could contain
evidentiary data.
Building the AED is a key challenge for EviHunter. We note
that a large number of static analysis tools–such as CHEX [30],
FlowDroid [12], AmanDroid [45], DroidSafe [21], R-Droid [13],
IccTA [28], and HornDroid [15]–have been developed to detect
sensitive data flows between sources and sinks in Android apps.
These tools were designed to detect the data that could flow from
certain sources to sinks, where a source is where data are created
and a sink is where the data ends, e.g., file system is a sink in our
problem. However, these tools did not consider the files where the
data are written to. For instance, these tools could detect that an
app will collect GPS locations and save them to the file system,
but they do not report the files where the GPS locations will be
written to. One possible reason is that these tools were designed for
security and privacy purposes; and it does not matter much which
files sensitive data are written to in terms of privacy leakage.
To address the challenge, EviHunter extends existing static data
flow analysis techniques for Android in several aspects. First, in
some existing static analysis tools, a tag is associated with a variable
to represent the types of sensitive data in the variable. We extend
the tag to include both the types of sensitive/evidentiary data and
the file path associated with a variable. Second, we extend the prop-
agation rules to spread both the types of evidentiary data and file
paths as we analyze the statements in an app. Third, we leverage
techniques developed by HornDroid [15] to partially address multi-
threading and reflection. Fourth, for complexity consideration, we
manually summarize the semantics for the commonly used system
APIs as some previous tools did [12, 30, 45]. However, we further
summarize the semantics of the system APIs for file path construc-
tion, which were not considered by previous tools. Fifth, we extend
the sources by 1) uncovering the source methods for file path con-
struction (these were not considered by previous tools), and 2)
uncovering new sources for sensitive/evidentiary data including
location, visited URL, and time (these sources were considered by
previous tools but not complete).
In implementing EviHunter, we leverage Soot to transform an
Android app to Jimple code (a three address intermediate representa-
tion), IC3 [16] to build inter-connected component communication
models, and FlowDroid [12] to build call graphs and entry points.
Then, EviHunter performs forward analysis of the Jimple code. We
evaluate EviHunter with respect to AED construction using 1) the
benchmark apps in DroidBench [1] that have file-system sinks,
2) new benchmark apps that we design to test the scenarios that
are not covered by the DroidBench apps, and 3) 8,690 real-world
apps. Our results show that EviHunter can precisely and accu-
rately find the files that could store evidentiary data for benchmark
apps. Moreover, we performed a best-efforts manual verification of
the results for 60 randomly sampled real-world apps. Our results
show that EviHunter achieves a precision of 90% and a recall of
89% at identifying the files that could contain evidentiary data. Al-
though our work does not focus on privacy leakage, our results
do have interesting privacy implications. In particular, we found
that some apps save GPS locations, visited URLs, and text inputs
on the external storage of an Android device. An app with the
READ_EXTERNAL_STORAGE permission can access these data to
track and profile the user. Finally, we use a case study to show how
a forensic investigator can use EviHunter to find evidentiary data
on a smartphone.
In summary, our contributions are as follows:
• We develop EviHunter to automatically identify the files on an
Android device that could contain evidentiary data.
• We extend existing static analysis tools for Android to detect
both types of evidentiary data an app could write to file system
and the files where the data are written to.
• We evaluate EviHunter using both benchmark apps and real-
world apps. Our results show that EviHunter achieves high
precisions and recalls.
2 BACKGROUND AND PROBLEM
FORMULATION
We first briefly introduce the Android file system used to manage
the permanent storage and then define our forensics problem.
2.1 Android File System
Directory structure: Android file system pre-defines several top-
level directories, e.g., /data/ and /sdcard/. The directory /data/ is on
the internal storage of Android, while /sdcard/ is linked to external
storage. Figure 1 shows the structure of the /data/ and /sdcard/ direc-
tories. Each app has a default directory /data/data//,
where the package name is treated as the identifier of the app. For
instance, the Facebook app’s package name is com.facebook.katana
and an Android device will create a directory /data/data/com.facebook.
katana/ after the Facebook app is installed on the device. An app’s
directory stores various data of the app. Android also pre-defines
EviHunter
CCS ’18, October 15–19, 2018, Toronto, ON, Canada
Table 1: Android APIs to get file paths.
API
getDataDirectory()
getCacheDir()
getFilesDir()
getFileStreamPath(String arg0)
openFileOutput(String arg0, int arg1)
getDataDir()
openOrCreateDatabase(String arg0, ... )
openDatabase(String arg0, ...)
getSharedPreferences(String arg0,int arg1)
getDefaultSharedPreferences(Context arg0)
getPreferences(int arg0)
getDir(String arg0, int arg1)
openOrCreateDatabase(File arg0, ... )
getExternalStorageDirectory()
getExternalStoragePublicDirectory(String arg0)
getObbDir()
getExternalCacheDir()
getExternalFilesDir(String arg0)
Description
Return File object whose path is "/data/"
Return File object whose path is "/data/data//cache/"
Return File object whose path is "/data/data//files/"
Return File object whose path is "/data/data//files/"
Return FileOutputStream object whose path is "/data/data//files/"
Return File object whose path is "/data/data//databases/"
Return SQLiteDatabase object whose path is "/data/data//databases/"
Return SQLiteDatabase object whose path is "/data/data//databases/"
Return SharedPreferences object whose path is "/data/data//shared_prefs/.xml"
Return SharedPreferences object whose path is
"/data/data//shared_prefs/_preferences.xml"
Return SharedPreferences object whose path is "/data/data//shared_prefs/1.xml"
Return File object whose path is "/data/data//app_/"
Return SQLiteDatabase object whose path is ""
Return File object whose path is "/sdcard/"
Return File object whose path is "/sdcard/", if is empty.
Return File object whose path is "/sdcard//", otherwise.
Return File object whose path is "/sdcard/Android/obb//"
Return File object whose path is "/sdcard/Android/data//cache/"
Return File object whose path is "/sdcard/Android/data//files/", if is empty.
Return File object whose path is "/sdcard/Android/data//files//", otherwise.
1  refers to an app’s environment information, such as launching activity class name and service name.
foo ( S t r i n g gpsLong , S t r i n g gpsLat ) {