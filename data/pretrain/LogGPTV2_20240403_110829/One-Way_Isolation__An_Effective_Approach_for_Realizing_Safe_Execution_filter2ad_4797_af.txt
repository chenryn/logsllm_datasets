server applications. As outlined in the introduction, all the
above approaches suffer from the difﬁculty of environment
reproduction, and also in committing the changes back to
the original system. As a result, they do not provide a help-
ful approach for the applications discussed in the introduc-
tion.
[13] was the ﬁrst approach to present a systematic devel-
opment of the concept of one-way isolation as an effective
means to isolate the effects of running processes from the
point they are compromised. They developed protocols for
realizing one-way isolation in the context of databases and
ﬁle systems. However, they do not present an implemen-
tation of their approach. As a result, they do not consider
the research challenges that arise due to the nature of COTS
applications and commodity OSes. Moreover, they do not
provide a systematic treatment of issues related to consis-
tency of committed results.
In our previous work [12], we developed a practical ap-
proach for secure execution of untrusted software based on
isolation. The focus of this effort was on developing a tool
that can be easily installed and used by ordinary users that
may not have administrative access to a computer. It is im-
plemented entirely at the user level, and does not require
any changes to the OS kernel. In order to achieve this ob-
jective, [12] compromises on performance as well as gen-
erality. In particular, the approach suffers from high over-
heads that can be over 100% in some instances. Moreover,
isolation semantics cannot be faithfully reproduced for cer-
tain operations that involve meta-data such as permissions
and ownership. For directories, isolation is achieved using
an ad-hoc approach that is hard to implement and its se-
mantics is inconsistent with that of ﬁle updates. Finally,
no systematic solution to the commit problem is provided.
The approach developed in this paper addresses all these
drawbacks by implementing isolation within the kernel at
the VFS layer. Moreover, it shows how the approach can
be generalized so that isolation can be provided for non-ﬁle
operations, e.g., certain classes of network accesses.
Recovery-oriented systems. The Recovery-Oriented
Computing (ROC) project [24] is developing techniques
for fast recovery from failures, focusing on failures due
to operator errors.
[2] presents an approach that assists
recovery from operator errors in administering a network
server, with the speciﬁc example of an email server. The
recovery capabilities provided by their approach are more
general than those provided by ours. The price to be
paid for achieving more general recovery capabilities is
that
their implementation needs to be application spe-
ciﬁc, and hence will have to be tailored for each speciﬁc
application/service. In contrast, we provide an application-
independent approach. Another important distinction is
that with our approach, consistency of system state can
be assured whenever the commit proceeds successfully.
With the ROC approach, which does not restrict network
operations, there is no way to prevent the effects of network
operations from becoming so widely distributed in the
network they cannot be fully reversed. In the case of email
service, they allow a certain level of inconsistency, e.g.,
redelivering an email that was previously read and deleted
by a client, and expect the user to manually resolve this
inconsistency. This potential for inconsistency is traded in
favor of eliminating the risk of commit failures.
File system approaches. Elephant ﬁle system [26] is
equipped with ﬁle object versioning support, and supports
ﬂexible versioning policies. [5, 23, 25, 31, 19] use check
pointing technique to provide data versioning. [16] imple-
ments VersionFS, a versatile versioning ﬁle system. They
use a stackable template ﬁle system as ours, and use a sparse
ﬁle technique to reduce storage requirements for storing
versions of large ﬁles. While all of these approaches pro-
vide the basic capability to rollback system state to a pre-
vious time, such a rollback will discard all changes made
since that time, regardless of whether they were done by a
malicious or benign process. In contrast, the one-way iso-
lation approach implemented in this paper guarantees se-
lective rollback of the actions of processes run within the
SEE without losing the changes made by benign processes
executing outside of the SEE.
Repairable File System [40, 39] makes use of version-
ing ﬁle system to bring repair facility to a compromised ﬁle
server. Fastrek [20] applies the similar approach to protect
databases. These approaches can attribute changes to mali-
cious or benign process executions, and allow a user to roll-
back changes selectively. However, since the changes made
by (potentially) compromised processes are not contained
within any environment, “cascading aborts” can become a
problem. Speciﬁcally, a benign process may access the data
produced by a compromised process, in which case the ac-
tions of the benign process may have to be rolled back, as
well as the actions of processes that used the results of such
a benign process and so on. The risk of such cascaded aborts
should be weighed against the risk of not being able to com-
mit in our approach. Thus, this approach as well as the ROC
approach mentioned above are more suitable when the like-
lihood of rollbacks is low, and commit failures cannot be
tolerated.
Loopback ﬁle system [14] can create a virtual ﬁle system
from existing ﬁle system and allow access to existing ﬁles
using alternative path name. But this approach provides no
support for versioning or isolation.
3D ﬁle system [10] provides a convenient way for soft-
ware developers to work with different versions of a soft-
ware package. In this sense, it is like a versioning ﬁle sys-
tem. It also introduces a technique called transparent view-
pathing which is based on translating ﬁle names used by a
process. It gives a union view of several directory struc-
tures thus allowing an application to transparently access
one directory through another’s path. As it is not designed
to deal with untrusted applications, it needs the cooperation
from the application for this mechanism to work. TFS [32]
is a ﬁle system in earlier distributions of Sun’s operating
system (SunOS), which allowed mounting of a writable ﬁle
system on top of a read-only ﬁle system. TFS also has a
view similar to 3DFS, where the modiﬁable layer sits on top
of the read only layers. [17] describes a union ﬁle system
for BSD, that allows “merging” of several directories into
one, with the mounted ﬁle system hiding the contents of the
original directories. The union mount will show the merger
of the directories and only the upper layer can be modi-
ﬁed. All these ﬁle systems are intended for software de-
velopment, with the UnionFS providing additional facilities
for patching read only systems. However, they do not ad-
dress the problem of securing the original ﬁle system from
untrusted/faulty programs; nor do they consider problems
such as data consistency and commit criteria.
8. Summary
In this paper, we presented an approach for realizing safe
execution environments. We showed that the approach is
versatile enough to support a wide range of applications. A
key beneﬁt of our approach is that it provides strong consis-
tency. In particular, if the results of isolated execution are
not acceptable to a user, then the resulting system state is
as if the execution never took place. On the other hand, if
the results are accepted, then the user is guaranteed that the
effect of isolated execution will be identical to that of atom-
ically executing the same program at the point of commit.
We also discussed alternative commit criteria that exploit
ﬁle semantics to reduce commit failures.
Our approach makes minimal modiﬁcations to the kernel
in the form of modules that provide ﬁle system isolation and
policy enforcement. It requires no changes to applications
themselves. Our functional evaluation illustrates the use-
fulness of the approach, while the performance evaluation
shows that the approach is efﬁcient, and incurs overheads
typically less than 10%.
References
[1] A. Acharya and M. Raje. Mapbox: Using parameterized
behavior classes to conﬁne applications. In Proceedings of
USENIX Security Symposium, 2000.
[2] A. Brown and D. Patterson. Undo for operators: Building
an undoable e-mail store. In Proceedings of USENIX An-
nual Technical Conference, 2003.
[3] P. M. Chen and B. D. Nobl. When virtual is better than real.
In Proceedings of Workshop on Hot Topics in Operating
Systems, 2001.
[4] T. Chiueh, H. Sankaran, and A. Neogi. Spout: A transpar-
ent distributed execution engine for java applets.
In Pro-
ceedings of International Conference on Distributed Com-
puting Systems, 2000.
[5] S. Chutani, O. T. Anderson, M. L. Kazar, B. W. Leverett,
W. A. Mason, and R. N. Sidebotham. The episode ﬁle sys-
tem. In Proceedings of the USENIX Winter 1992 Technical
Conference, 1992.
[6] A. Dan, A. Mohindra, R. Ramaswami, and D. Sitaram.
Chakravyuha: A sandbox operating system for the con-
trolled execution of alien code. Technical report, IBM T.J.
Watson research center, 1997.
I. Goldberg, D. Wagner, R. Thomas, and E. A. Brewer. A
secure environment for untrusted helper applications: con-
ﬁning the wily hacker. In Proceedings of USENIX Security
Symposium, 1996.
[7]
[8] S. Jajodia, P. Liu, and C. D. McCollum. Application-level
isolation to cope with malicious database users.
In Pro-
ceedings of Annual Computer Security Applications Con-
ference, 1998.
J. Katcher. Postmark: A new ﬁle system benchmark. Tech-
nical Report TR3022, Network Applicance Inc., 1997.
[9]
[10] D. G. Korn and E. Krell. A new dimension for the unix ﬁle
system. Software: Practice & Experience, 20(S1), 1990.
[11] B. W. Lampson. A note on the conﬁnement problem. Com-
munications of the ACM, 16(10):613–615, 1973.
[12] Z. Liang, V. Venkatakrishnan, and R. Sekar. Isolated pro-
gram execution: An application transparent approach for
executing untrusted programs.
In Proceedings of Annual
Computer Security Applications Conference, 2003.
[13] P. Liu, S. Jajodia, and C. D. McCollum. Intrusion conﬁne-
ment by isolation in information systems. In Proceedings
of IFIP Workshop on Database Security, 1999.
[14] Loop back ﬁle system. Unix man page.
[15] D. Malkhi and M. K. Reiter. Secure execution of java ap-
plets using a remote playground. Software Engineering,
26(12), 2000.
[17]
[16] K.-K. Muniswamy-Reddy, C. P. Wright, A. P. Himmer, and
E. Zadok. A versatile and user-oriented versioning ﬁle sys-
tem.
In Proceedings of USENIX Conference on File and
Storage Technologies, 2004.
J.-S. Pendry and M. K. McKusick. Union mounts in 4.4bsd-
lite. In Proceedings of 1995 USENIX Technical Conference
on UNIX and Advanced Computing Systems, 1995.
J. S. Pendry, N. Williams, and E. Zadok. Am-utils user
manual, 6.1b3 edition, july 2003. http://www.am-utils.org.
[19] Z. Peterson and R. Burns. Ext3cow: The design, imple-
mentation, and analysis of metadata for a time-shifting ﬁle
system. Technical Report. HSSL-2003-03, Hopkins Stor-
age Systems Lab, Department of Computer Science, Johns
Hopkins University, 2003.
[18]
[20] D. Pilania and T. Chiueh. Design, implementation, and
evaluation of an intrusion resilient database system. In Pro-
ceedings of International Conference on Dependable Sys-
tems and Networks, 2003.
[21] V. Prevelakis and D. Spinellis. Sandboxing applications.
In Proceedings of Usenix Annual Technical Conference:
FREENIX Track, 2001.
[22] N. Provos. Improving host security with system call poli-
cies. In Proceedings of USENIX Security Symposium, 2003.
[23] S. Quinlan and S. Dorward. Venti: a new approach to
In Proceedings of USENIX Conference
archival storage.
on File and Storage Technologies.
[24] Recovery-oriented computing. http://roc.cs.berkeley.edu.
[25] W. D. Roome. 3dfs: A time-oriented ﬁle server. In Pro-
ceedings of the USENIX Winter 1992 Technical Conference,
1991.
[26] D. J. Santry, M. J. Feeley, N. C. Hutchinson, and A. C.
Veitch. Elephant: The ﬁle system that never forgets.
In
Proceedings of Workshop on Hot Topics in Operating Sys-
tems, 1999.
[27] K. Scott and J. Davidson. Safe virtual execution using soft-
ware dynamic translation. In Proceedings of Annual Com-
puter Security Applications Conference, 2002.
[28] R. Sekar, Y. Cai, and M. Segal. A speciﬁcation-based ap-
proach for building survivable systems.
In Proceedings
of National Information Systems Security Conference, Oct
1998.
[29] R. Sekar and P. Uppuluri. Synthesizing fast intrusion pre-
vention/detection systems from high-level speciﬁcations. In
Proceedings of USENIX Security Symposium, 1999.
[30] K.
Sitaker.
Picturepages
software.
http://www.canonical.org/picturepages/.
[31] C. Soules, G. Goodson, J. Strunk, and G. Ganger. Metadata
efﬁciency in a comprehensive versioning ﬁle system.
In
Proceedings of USENIX Conference on File and Storage
Technologies, 2002.
[32] Translucent ﬁle system, 1990. SunOS Reference Manual,
Sun Microsystems.
[37] E. Zadok, I. Badulescu, and A. Shender. Extending ﬁle sys-
tems using stackable templates. In Proceedings of USENIX
Annual Technical Conference, 1999.
[38] M. Zalewski.
analyzer.
Lists/securityfocus/bugtraq/2004-09/0251.html.
Fakebust,
code
http://www.derkeiler.com/Mailing-
a malicious
[33] T. Tiilikainen. Rename-them-all, linux freeware version.
[39] N. Zhu.
Data
http://linux.iconet.com.br/system/preview/8622.html.
[34] P. Uppuluri. Intrusion Detection/Prevention Using Behav-
ior Speciﬁcations. PhD thesis, Stony Brook University,
2003.
[35] Webstone,
the
benchmark
for
web
servers.
http://www.mindcraft.com/webstone.
[36] A. Whitaker, M. Shaw, and S. Gribble. Denali: Lightweight
virtual machines for distributed and networked applica-
tions. In Proceedings of USENIX Annual Technical Con-
ference, 2002.
versioning
Stony
systems.
Brook
Tech-
University,
nical
http://www.ecsl.cs.sunysb.edu/tech reports.html.
report,
[40] N. Zhu and T. Chiueh. Design, implementation, and evalu-
ation of repairable ﬁle service. In Proceedings of Interna-
tional Conference on Dependable Systems and Networks,
2003.