        010c: 14 16 16 1a 1d 25 1f 1a 1b 23 1c 16 16 20 2c 20 [.....%...#... , ]
        011c: 23 26 27 29 2a 29 19 1f 2d 30 2d 28 30 25 28 29 [#&')*)..-0-(0%()]
        012c: 28                                              [(]
    JPEG DQT (65 bytes):
        0131: 01 07 07 07 0a 08 0a 13 0a 0a 13 28 1a 16 1a 28 [...........(...(]
        0141: 28 28 28 28 28 28 28 28 28 28 28 28 28 28 28 28 [((((((((((((((((]
        0151: 28 28 28 28 28 28 28 28 28 28 28 28 28 28 28 28 [((((((((((((((((]
        0161: 28 28 28 28 28 28 28 28 28 28 28 28 28 28 28 28 [((((((((((((((((]
        0171: 28                                              [(]
    JPEG SOF2 (15 bytes):
        0176: 08 01 d3 02 ee 03 01 22 00 02 11 01 03 11 01    [.......".......]
      ImageWidth = 750
      ImageHeight = 467
      EncodingProcess = 2
      BitsPerSample = 8
      ColorComponents = 3
      YCbCrSubSampling = 2 2
    JPEG DHT (26 bytes):
        0189: 00 00 01 05 01 01 01 00 00 00 00 00 00 00 00 00 [................]
        0199: 00 00 01 02 03 04 05 06 07 08                   [..........]
    JPEG DHT (24 bytes):
        01a7: 01 00 02 03 01 01 00 00 00 00 00 00 00 00 00 00 [................]
        01b7: 00 00 01 02 03 04 05 06                         [........]
    JPEG SOS
    JPEG DHT (50 bytes):
        1767: 10 00 02 01 03 02 04 05 03 04 02 02 03 01 01 00 [................]
        1777: 00 01 02 03 00 04 11 12 21 05 10 13 31 20 22 30 [........!...1 "0]
        1787: 32 33 14 23 41 06 24 34 40 35 42 15 43 25 50 60 [23.#A.$4@5B.C%P`]
        1797: 44 16                                           [D.]
    JPEG SOS
    JPEG DHT (47 bytes):
        33b1: 11 00 02 01 03 02 04 05 02 05 05 01 00 00 00 00 [................]
        33c1: 00 00 01 02 03 11 12 04 21 10 13 20 31 05 22 30 [........!.. 1."0]
        33d1: 32 41 23 51 14 33 42 43 61 15 34 40 50 71 81    [2A#Q.3BCa.4@Pq.]
    JPEG SOS
    JPEG DHT (49 bytes):
        3b9d: 11 00 02 02 01 03 02 05 03 03 03 04 03 01 00 00 [................]
        3bad: 00 01 02 00 03 11 04 12 21 10 31 13 20 22 32 41 [........!.1. "2A]
        3bbd: 05 14 51 30 33 61 23 40 43 15 24 42 71 34 81 b1 [..Q03a#@C.$Bq4..]
        3bcd: 91                                              [.]
    JPEG SOS
    JPEG DHT (57 bytes):
        46e2: 10 00 01 03 02 03 07 02 03 06 06 02 02 03 00 00 [................]
        46f2: 00 01 00 02 11 10 21 03 12 31 20 22 30 41 51 61 [......!..1 "0AQa]
        4702: 71 04 40 13 32 81 23 42 50 62 91 a1 52 60 72 73 [q.@.2.#BPb..R`rs]
        4712: 82 b1 92 c1 14 33 34 63 d1                      [.....34c.]
    JPEG SOS
    JPEG DHT (40 bytes):
        57aa: 10 00 02 02 02 02 02 01 04 02 03 01 01 01 00 00 [................]
        57ba: 00 00 01 11 21 10 31 41 51 20 61 71 30 81 91 a1 [....!.1AQ aq0...]
        57ca: b1 c1 40 d1 f0 e1 50 f1                         [..@...P.]
    JPEG SOS
    JPEG SOS
    JPEG DHT (40 bytes):
        783e: 11 01 00 02 02 02 03 00 02 01 03 04 03 00 00 00 [................]
        784e: 00 01 00 11 21 31 10 41 20 51 61 30 71 81 91 a1 [....!1.A Qa0q...]
        785e: e1 40 50 b1 c1 d1 f0 f1                         [.@P.....]
    JPEG SOS
    JPEG DHT (40 bytes):
        7f3f: 11 01 01 01 00 02 03 00 02 02 01 04 02 03 01 00 [................]
        7f4f: 00 01 00 11 21 31 10 41 51 20 61 71 81 a1 30 91 [....!1.AQ aq..0.]
        7f5f: b1 c1 40 f0 50 d1 e1 f1                         [..@.P...]
    JPEG SOS
    JPEG DHT (39 bytes):
        87d4: 10 01 00 02 02 02 02 01 04 02 03 01 01 01 00 00 [................]
        87e4: 00 01 00 11 21 31 41 51 10 61 71 20 81 91 a1 b1 [....!1AQ.aq ....]
        87f4: c1 30 d1 f0 40 e1 f1                            [.0..@..]
    JPEG SOS
    JPEG EOI
总结如下，图片来自 **图像元数据（Metadata） ——Exif信息分析** [4]
### Perl模式匹配
Perl中的一个正则表达式也称为一个模式，一共有三种模式，分别是匹配，替换和转化，这三种形式一般都和 =~ 或 !~ 搭配使用，=~ 表示相匹配，!~
表示不匹配。本文主要介绍模式匹配，定义如下：
  * `m//`
  * `//`
  * `m??`
模式匹配中有下列几种选项，位于表达式末尾：
选项 | 描述  
---|---  
i | 忽略模式中的大小写  
m | 多行模式  
o | 仅赋值一次  
s | 单行模式，"."匹配"\n"（默认不匹配）  
x | 忽略模式中的空白  
g | 全局匹配  
cg | 全局匹配失败后，允许再次查找匹配串  
这里主要介绍`g`、`m`和`s`选项，首先来看`g`选项，示例如下：
    $str = "I am superman";
    for (;;) {
        last unless $str =~ /(\S)/g;
        print pos($str).".".$1;
        print " ";
    }
代码输出结果为
    1.I 3.a 4.m 6.s 7.u 8.p 9.e 10.r 11.m 12.a 13.n 
可以看到其作用就是遍历输出每个和正则表达式相匹配的字符，并为其标号，下面就来解读下这段代码中的几个关键点：
  1. `last unless`表示其后的表达式返回0则退出循环。
  2. 使用正则模式匹配`$str =~ /(\S)/g;`来全局匹配非空格字符。
  3. `pos`函数用于查找最后匹配的子字符串的偏移量或位置。
  4. 匹配的表达式中，括号部分的匹配项内容用`$`标号表示，`$1`则表示第一个括号匹配的内容。
由于使用了`g`全局匹配，此时会匹配尽可能多的次数，所以每次进入for循环匹配到的都是下一个满足正则表达式的内容，此后分别打印了匹配的位置和内容，实现了遍历字符串。
下面来看使用`m`选项和`s`选项，看下面的示例代码：
    $str = "Topsec\nalpha\nlab";
    print '1' if $str =~ /^alpha$/m;
    print '2' if $str =~ /alpha.*lab/s;
代码将输出12
  * m选项
默认的正则开始`^`和结束`$`是对于整个字符串。如果在修饰符中加上`m`，那么开始和结束将会指字符串的每一行：每一行的开头就是`^`，结尾就是`$`。由于在字符串中使用了`\n`换行。所以使用`m`模式时会将字符串视为多行，不管是那行都能匹配。
  * s选项
一般的模式匹配中pattern指的都是单行的字符串，所以只能用于匹配换行前面，或者后面。加上模式匹配选项`s`后点号元字符将匹配所有字符，包含换行符。所以对于字符串`Topsec\nalpha\nlab`，虽然含有`\n`，但是仍然会将其作为单行的字符串，这种情况下这行中就含有`alpha`和`lab`。
## 0x03 exiftool源码调试到漏洞分析
### 环境搭建
exiftool是由perl语言编写的，所以我们只需要在ide中配置好perl环境，然后打开exiftool工程即可。exiftool源码下载地址为
**releases**
[5]。选择下载存在漏洞的对应版本即可，这里下载的是v12.23。ide选择的是Komodo。安装相关环境后点击此处打开exiftool工程目录然后打开目录下的windows_exiftool文件
点击第一行的运行按钮，如果出现报错提示忽略即可，此时弹出`Debugging Options`，在脚本参数一栏填写需要传递的参数如-ver查看版本，最后点击OK，在右下角即可查看运行输出结果。如果需要调试断点直接在指定代码行处断下即可。
### 漏洞简介
引用上一篇的部分前置知识：
> ExifTool由Phil
> Harvey开发，是一款免费、跨平台的开源软件，用于读写和处理图像（主要）、音视频和PDF等文件的元数据（metadata）。ExifTool可以作为Perl库（Image::ExifTool）使用，也有功能齐全的命令行版本。ExifTool支持很多类型的元数据，包括Exif、IPTC、XMP、JFIF、GeoTIFF、ICC配置文件、Photoshop
> IRB、FlashPix、AFCP和ID3，以及众多品牌的数码相机的私有格式的元数据。
>
> DjVu是由AT&T实验室自1996年起开发的一种图像压缩技术，已发展成为标准的图像文档格式之一，可以作为PDF的替代品。
ExifTool在xxx解析文件的时候会忽略文件的扩展名，尝试根据文件的内容来确定文件类型，其中支持的类型有DjVu。关键在于ExifTool在解析DjVu注释的`ParseAnt`函数中存在漏洞，漏洞的构造触发可以分为三步：
  1. 构造DjVu文件嵌入恶意代码到注释块`ANTa`或者`ANTz`中。
  2. 将DjVu文件以插入到jpg中的标签元数据内，标签名称是`HasselbladExif(0xc51b)`。
  3. 当exiftool解析到特定标签名`HasselbladExif(0xc51b)`时，会递归解析其中数据，最后调用`ParseAnt`，造成了ExifTool代码执行漏洞。
该漏洞存在于ExifTool的7.44版本以上，在12.4版本中修复。想知道parseAnt函数是怎么被调用的吗？下面就跟我一起进入exiftool的源码来一探究竟吧。
根据原作者文章 **ExifTool CVE-2021-22204 - Arbitrary Code Execution**
[6]在存在漏洞的ParseAnt函数(`\lib\Image\ExifTool\DjVu.pm`)中关键处打下断点
切换到windows_exiftool文件点击运行在启动参数处填入jpg文件地址
此时在右下角可以看到调用栈
我们根据调用栈的辅助来简单分析一下其中的几个关键点：
  1. exiftool是如何解析嵌入的`0xc51b(HasselbladExif)`标签。
  2. DjVu模块中的`parseAnt`函数是怎么被调用的。
### exiftool是如何解析嵌入的0xc51b标签
首先来看第一个问题，跟进调用栈中的`ExtractInfo`函数，根据其代码中定义处的注释(如下)得知该函数的作用就是从图像中提取元信息：
    # Extract meta information from image
    # Inputs: 0) ExifTool object reference
    #         1-N) Same as ImageInfo()
    # Returns: 1 if this was a valid image, 0 otherwise
    # Notes: pass an undefined value to avoid parsing arguments
    # Internal 'ReEntry' option allows this routine to be called recursively
    sub ExtractInfo($;@)
    {
    #...
    }
一步步分析调试后发现在2583行会通过`until`遍历`fileTypeList`数组，其值来自`fileTypes`，存储着已识别的文件类型，之后的处理会一个个取出成员赋值给`tpye`，并判断当前类型对应的幻数`$magicNumber{$type}`是否匹配内容`$buff`的头部进而来确定文件类型，如下图：
根据获取到type来动态调用相关处理函数，如下图：
在6495行判断内容标记为E1并且是exif开头时根据前置知识的分析会进入TIFF的目录结构解析，如下图：
在`ProcessExif`函数的5866行开始会循环遍历IFD中的所有条目，其中就包括了我们插入的hassexif（0xc51b）标签，50459为0xc51b的十进制值，调用栈和调用逻辑如下图：
现在来看看关于该标签的定义，注释为`Hasselblad
H3D`，搜索得知是一个相机品牌，关于其exif信息的处理在RawConv字段定义着一些代码，这些代码中调用到了ExtractInfo函数：
        0xc51b => { # (Hasselblad H3D)
            Name => 'HasselbladExif',
            Format => 'undef',
            RawConv => q{
                $$self{DOC_NUM} = ++$$self{DOC_COUNT};
                $self->ExtractInfo(\$val, { ReEntry => 1 });
                $$self{DOC_NUM} = 0;
                return undef;
            },
        },
继续跟进在6565行调用`FoundTag`获取该标签处理方式`RawConv`并传入标签所携带的数据，如下图：
进入FoundTag函数后发现在其中取出并执行了RawConv，如下图：
接下来进入ExtractInfo执行元数据的嵌套解析也就是0xc51b标签的内容。此时第一个疑惑exiftool是如何解析嵌入的`0xc51b(HasselbladExif)`标签已经解决。
### exiftool是如何调用parseAnt函数
现在来看DjVu模块中的`parseAnt`函数是怎么被调用的。进入ExtractInfo后会再次来到前面分析过的`until`遍历确定文件类型，如下图：
加载相应处理函数并调用，如下图：
在ProcessAIFF中判断是否DJVU文件，并加载对应标签配置表`%Image::ExifTool::DjVu::Main`，如下图：