with the DOM tree to an input channel, with security
level corresponding to the security level of the DOM
tree nodes and their values. This is a viable option, but
probably introduces quite some overhead for programs
interacting heavily with the DOM tree because of the
bookkeeping associated with input handling in secure
multi-execution. In addition, we think this choice will
result in a lower precision technique than the alterna-
tive.
The alternative solution is to incorporate the DOM
in eﬀect
tree into each Javascript execution’s state,
giving each execution its own copy of the DOM tree, as
is done for program variables. Diﬀerent executions will
not see identical copies of the DOM tree, but instead an
evaluation of the DOM tree in terms of security levels
could be used to decide what each exposed DOM
tree should look like. One could imagine a situation
where all security levels except the highest only get
to see a dummy version of the HTML document. In
mash-up applications, one could even imagine having
diﬀerent security levels each seeing only separate parts
of the real DOM tree. Care should be taken to align
this approach with the handling of DOM tree nodes
producing external side eﬀects.
We suspect the latter alternative is preferable, even
though it adds a certain memory overhead for the
additional copies of the DOM tree. This additional
memory overhead can be argued to be similar to the
general overhead of secure multi-execution for objects
manipulated by a program. In addition, if necessary,
we think optimisations can be imagined like a copy-
on-write-based sharing of the tree etc.
In this section, we have described some of the
challenges we anticipate in a real-life browser-based
implementation of secure multi-execution. We think
there is interesting further research to be done in this
direction.
B. What about Non-Noninterferent Programs?
In Section IV-C, we have proven that termination-
sensitively noninterferent programs produce the same
results as they do under normal execution,
if the
normal execution terminates for a given input. An
important question is then what results secure multi-
execution produces for interferent programs. Theo-
rem 1 in Section IV-B tells us that any program
is noninterferent under secure multi-execution. This
means that multi-execution has some way of replacing
interferent behaviour by noninterferent behaviour. In
this section, we explore how it achieves this for some
example programs.
Secure multi-execution in fact has diﬀerent ways to
block unwanted information ﬂows. The examples in
the informal overview in Section II already show how
explicit and implicit information ﬂows are handled.
The oﬀending assignments and conditional statements
will still be executed, but any data they don’t have
access to will be replaced by default data. In the
high security executions, the oﬀending statements will
be executed with the real data, but no leaks to low
security output channels will be possible.
Another mechanism in eﬀect blocking certain types
of covert ﬂows can be observed for the example in
Figure 10a. We assume that reading a value from L can
produce external side eﬀects. Under standard execu-
tion, this program will read from L iﬀ x == vdefault and is
thus clearly interferent. Under secure multi-execution,
the low execution will not read any input from L. The
high execution will try to read from L iﬀ x == vdefault,
but if it does, it will block and wait indeﬁnitely for
the low execution to read from L. This behaviour
is termination- and timing-sensitively noninterferent.
Secure multi-execution blocks the undesirable ﬂow by
making the high security thread wait indeﬁnitely in
the global waiting queue. Figure 10b shows the same
phenomenon for a termination-insensitively noninter-
ferent program.
Figure 10c shows a nonterminating termination-
sensitively noninterferent program, for which multi-
execution is not transparent using the selectlowprio
121
input x from H
if x == vdefault then skip else input x from L
(a) An interferent program.
input x from H
if x == vdefault then while true do skip else skip
input x from L
(b) A termination-insensitively noninterferent program.
output 1 to H
while true do skip;
(c) A termination-sensitively noninterferent program.
Figure 10.
haviour under multi-execution.
Example programs highlighting some interesting be-
scheduler. In this example, the high security execu-
tion will never be selected because the low-security
thread diverges. This is an unfortunate eﬀect, which
can be mitigated by using a more relaxed scheduler. An
interesting question is whether this is possible with-
out compromising timing-sensitivity in the soundness
guarantee.
The fact that secure multi-execution can enforce
noninterference for any program makes it well suited
for situations where one has little control over the code
to be executed, for example in a web browser. When
such code is interferent, secure multi-execution will
still execute it, but will modify its behaviour to be
non-interferent. For this to work well, it is important
that the modiﬁed behaviour remains as meaningful
as possible. We believe that in many situations, the
modiﬁcations that secure multi-execution makes are
as meaningful as possible without compromising non-
interference. For example, a web application which
accidentally sends private information to a website
statistics service, will be modiﬁed to send a request
based on the default values replacing the private data
in the low execution. We consider this to be desirable
behaviour in a situation where transparency conﬂicts
with noninterference.
In some situations, secure multi-execution is not
able to produce such meaningful behaviour, e.g. when
ﬁnishing execution with non-empty waiting queues. In
other situations, secure multi-execution can detect that
modiﬁcations to the behaviour have been made, e.g.
when a H execution would have sent diﬀerent data to
public outputs than the L execution. In these situation,
an implementation could issue an appropriate warning
to the user, explaining that the original program was
probably interferent and what kind of eﬀects should
be expected. To support this, we think it could be
interesting subsequent work to perform a detailed
formal analysis of the results that can be expected
for programs conforming to diﬀerent noninterference
criteria.
C. Exceptions, Concurrency and Nondeterminism
Exceptions, concurrency and nondeterminism are
programming language features which pose additional
challenges for various techniques enforcing noninter-
ference. First of all, in the context of noninterference,
concurrency and nondeterminism are diﬃcult to work
with from a theoretical perspective. Noninterference
then becomes a property one can no longer expect to
enforce, and trickier concepts like possibilistic or prob-
abilistic noninterference [20] are needed to formulate
the desired properties. In addition to this additional
challenge for researchers, exceptions and concurrency
also poses additional challenges for the techniques
themselves. For example, Smith and Volpano need to
impose considerable extra restrictions in their type
system to handle exceptions [16] and concurrency [21].
An appealing feature of secure multi-execution, is
that there is no fundamental obstacle for it to support
exceptions, concurrency or nondeterminism. The basic
idea of executing the program once on every security
level and handling input and output in each execu-
tion as described above, remains valid if we let each
separate execution handle exceptions, concurrency and
nondeterminism internally. It is intuitively still clear
that no information on higher levels can leak to an
execution on a lower level, because it simply does
not get access to the information, and has no way
of communicating with executions on higher levels.
Nevertheless, developing these ideas into a formal
proof remains a considerable challenge.
VII. Related Work
There is a vast amount of related work in the
research area of information ﬂow security. We point
the reader to the excellent survey by Sabelfeld and
Myers [20] for an overview of static techniques, and
to the PhD thesis of Le Guernic [22] for an overview
of dynamic techniques. In this related work section,
we limit our discussion to papers that propose ideas
or approaches closely related to our notion of secure
multi-execution, and to work that applies information
ﬂow analysis to Javascript.
In order to close internal timing channels [15], Russo
et al. describe an approach based on program transfor-
mation. For any conditional branching on high security
variables, they rewrite the program to execute the
122
branches in dedicated threads. In these high secu-
rity threads, they replace low security variables by
high security images (copies) and implement careful
synchronisation to avoid introducing data races. We
believe their technique can in fact be seen as a sort
of multi-execution. Their base thread is the equivalent
of a low security thread, while the high threads they
launch are in fact serialised by the added synchroni-
sation commands to the equivalent of a single high
thread. The diﬀerence comes down to the fact that
instead of executing the full program on the low
security level with fake high data, their equivalent of
the low thread skips assignments to and branches on
high security variables and forbids the use of high
security variables. Because of this, they do not need
to duplicate low variables or parts of the program
not using high variables. On the results side, secure
multi-execution seems to provide stronger guarantees
(timing- and termination-sensitive noninterference vs.
termination-insensitive noninterference). Russo et al.
do not prove any form of precision, but our impression
is that secure multi-execution is more precise than their
transformation technique.
Pottier and Simonet [23] discuss an approach to
prove noninterference using standard preservation and
progress theorems for a security type system for Core
ML. Since noninterference is not a safety property (one
needs to consider two executions to reason about non-
interference), they propose adding a pairing construct
to the language that makes it easy to reason about
two executions of a program. This pairing construct
is somewhat similar to bi-execution in our approach.
However, Pottier and Simonet use it as a theoretical
construct to reduce noninterference to subject reduc-
tion for an extended programming language.
Somewhat similarly, Barthe et al. [24] propose the
use of self-composition, another pairing construct, to
reason about noninterference in program logics. Their
goal is to support the use of (Hoare-logic like) pro-
gram veriﬁcation techniques to verify noninterference
properties.
Vogt et al. [25] describe a practical taint tracking
technique for Javascript. Their main goal is provid-
ing reliable and eﬃcient protection against cross-site-
scripting attacks. While practical and useful, their tech-
nique is not fully sound: Russo et al. [7] identify a
number of issues where the technique by Vogt et al.
is unsound. They go on to propose a provably sound
execution monitor for tracking information ﬂow in
DOM-tree like data structures, but this monitor has
not yet been implemented. The only existing approach
for tracking information ﬂow in Javascript that is
provably sound and has been implemented for full
Javascript is a technique recently proposed by Chugh
et al. [13]. They propose a framework for staging infor-
mation ﬂow intended to handle dynamically generated
Javascript. They limit attention to speciﬁc types of ﬂow
policies such that the residual checks that the browser
needs to perform can be eﬃcient. They also propose a
static instantiation of the framework using an analysis
technique based on set inclusion constraints. As any
static technique, this technique is not fully precise and
will reject programs for which secure multi-execution
can enforce noninterference transparently.
Yumerefendi et al. [26] describe a comprehensive
information ﬂow control system called TightLip, imple-
mented in the Linux kernel. In order to detect insecure
information ﬂows, TightLip will spawn a doppelganger
(look-alike) process in parallel to processes accessing
conﬁdential ﬁles. The doppelganger process inherits
most of the state of the original, but is only given access
to a scrubbed (having all conﬁdential data removed)
version of the ﬁle. All subsequent system calls of both
processes are then tracked and compared to each other.
If all of these system calls are identical, the process
is assumed to be noninterferent and its execution is
left unmodiﬁed. If a diﬀerence is detected, TightLip’s
policy module decides whether to block the system
call, kill the process, scrub output buﬀers, replace the
original process by its doppelganger, transitively mark
aﬀected ﬁles or pipes as sensitive or do nothing.
TightLip and secure multi-execution share the idea
of executing a process multiple times on diﬀerent
security levels and replacing high security input in
the low-security execution. However, Yumerefendi et
al. use this idea only to detect divergence of outputs
and thus information leaks. Because it is their original
process which produces all output, and because one
can no longer meaningfully compare system calls after
the ﬁrst diﬀerence, they have to treat all further output
as sensitive, and resort to relatively crude mitigation
techniques. They do not provide any formal results and
as they seem to recognize, their transitive marking of
ﬁles aﬀected by system calls as sensitive is unsound
because of improper ﬂow-sensitivity [27].
VIII. Conclusion
We have proposed secure multi-execution, a novel
dynamic enforcement mechanism for noninterference
policies. Secure multi-execution enjoys interesting the-
oretical properties. We have shown that it is sound
for a very strong notion of noninterference taking into
account the termination and timing covert channels,
and that it is precise in the sense that the enforcement is
transparent for all terminating runs of all termination-
sensitively noninterferent programs. We have also pro-
vided evidence that secure multi-execution can be
123
practical by reporting benchmark results on an imple-
mentation of the technique for Javascript.
IX. Acknowledgements
The idea of secure multi-execution grew from an
interesting question that Nicky Mouha raised in a
summer school lecture on information ﬂow security.
Nicky: we hope this paper ﬁnally provides a satisfac-
tory answer to your question!
We are grateful to Andrei Sabelfeld, Bart Jacobs and
Dave Clarke for interesting feedback and comments
on draft versions of this paper. This research is par-
tially funded by the Interuniversity Attraction Poles
Programme Belgian State, Belgian Science Policy, and
by the Research Fund K.U.Leuven.
References
[1] D. Volpano, C. Irvine, and G. Smith, “A sound type
system for secure ﬂow analysis,” Journal of computer
security, vol. 4, no. 2/3, pp. 167–188, 1996.
[2] N. Heintze and J. G. Riecke, “The SLam calculus: pro-
gramming with secrecy and integrity,” in POPL, 1998,
pp. 365–377.
[3] A. C. Myers, “JFlow: Practical mostly-static information
ﬂow control,” in POPL, 1999, pp. 228–241.
[4] M. Zanotti, “Security typings by abstract interpreta-
tion,” in Proc. Symposium on Static Analysis, 2002, pp.
360–375.
[12] M. Johns, “On JavaScript malware and related threats,”
Journal in Computer Virology, vol. 4, no. 3, pp. 161–178,
2008.
[13] R. Chugh, J. A. Meister, R. Jhala, and S. Lerner, “Staged
information ﬂow for javascript,” in PLDI, 2009, pp. 50–
62.
[14] S. Maﬀeis,
J. C. Mitchell, and A. Taly, “Isolating
javascript with ﬁlters, rewriting, and wrappers,” in ES-
ORICS, 2009, pp. 505–522.
[15] A. Russo, J. Hughes, D. Naumann, and A. Sabelfeld,
“Closing internal timing channels by transformation,”
in ASIAN, 2006, pp. 120–135.
[16] D. Volpano and G. Smith, “Eliminating covert ﬂows
with minimum typings,” in Computer Security Founda-
tions Workshop, 1997, pp. 156–168.
[17] “Valgrind user manual
- massif: a heap proﬁler.”
[Online]. Available: http://valgrind.org/docs/manual/
ms-manual.html
[18] F. Tip, “A survey of program slicing techniques,” Journal
of programming languages, vol. 3, no. 3, pp. 121–189, 1995.
[19] D. Devriese
F.
and
“Secure multi-
execution experiment source code.” [Online]. Avail-
able: http://www.cs.kuleuven.be/∼dominiqu/permanent/
sme-experiment.tar.gz
Piessens,
[20] A.
Sabelfeld
“Language-based
information-ﬂow security,” IEEE Journal on selected
areas in communications, vol. 21, no. 1, pp. 5–19, 2003.
and A. Myers,
[5] D. E. Denning and P. J. Denning, “Certiﬁcation of pro-
grams for secure information ﬂow,” Comm. of the ACM,
vol. 20, no. 7, pp. 504–513, 1977.
[21] G. Smith and D. Volpano, “Secure information ﬂow in
a multi-threaded imperative language,” in POPL, 1998,
pp. 355–364.
[6] G. Le Guernic, A. Banerjee, T. Jensen, and D. Schmidt,
in
conﬁdentiality monitoring,”
“Automata-based
ASIAN, 2006, pp. 75 – 89.
[7] A. Russo, A. Sabelfeld, and A. Chudnov, “Tracking in-
formation ﬂow in dynamic tree structures,” in ESORICS,
2009, pp. 86–103.
[8] N. Vachharajani, M. J. Bridges, J. Chang, R. Rangan,
G. Ottoni, J. A. Blome, G. A. Reis, M. Vachharajani, and
D. I. August, “RIFLE: An architectural framework for
user-centric information-ﬂow security,” in MICRO, 2004,
pp. 243–254.
[9] F. B. Schneider, “Enforceable security policies,” ACM
Trans. Information and System Security, vol. 3, no. 1, pp.
30–50, 2000.
[10] “Mozilla spidermonkey website.” [Online]. Available:
http://www.mozilla.org/js/spidermonkey/
[11] “Google chrome v8 benchmark suite instructions.”
http://code.google.com/apis/v8/
[Online]. Available:
benchmarks.html
124
[22] G. Le Guernic, “Conﬁdentiality enforcement using dy-
namic information ﬂow analyses,” Ph.D. dissertation,
Kansas State University, 2007.
[23] F. Pottier and V. Simonet, “Information ﬂow inference
for ML,” ACM Trans. Program. Lang. Syst., vol. 25, no. 1,
pp. 117–158, 2003.
[24] G. Barthe, P. R. D’Argenio, and T. Rezk, “Secure infor-
mation ﬂow by self-composition,” in CSFW, 2004, pp.
100–114.
[25] P. Vogt, F. Nentwich, N. Jovanovic, E. Kirda, C. Kr ¨ugel,
and G. Vigna, “Cross site scripting prevention with
dynamic data tainting and static analysis,” in NDSS,
2007.
[26] A. R. Yumerefendi, B. Mickle, and L. P. Cox, “TightLip:
Keeping applications from spilling the beans,” in NSDI,
2007.
[27] A. Russo and A. Sabelfeld, “Dynamic vs. static ﬂow-
sensitive security analysis,” 2010, unpublished.