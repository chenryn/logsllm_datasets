Otherwise, it is treated as having an empty lineage set, cor-
responding to statically initialized variables.
Identifying Input Values.
It is non-trivial to label input
values. In EXE [9], users are required to annotate input vari-
ables. We had considered such a strategy. However, since
we are working at binary level and we handle whole system
inputs such as those read from ﬁles or network packets, we
found that it was hard to adopt. We took a different path
by intercepting input relevant system calls such as system
reads and assign unique ids to each input value. More pre-
cisely, after each system read, we scan the input buffer, and
assign unique ids to each byte in the input buffer. Such an
id serves as the lineage for that input byte. The fseek-like
operations for local ﬁle read were challenges for us because
a single byte may be read multiple times due to this kind
of operations and we have to avoid generating multiple ids
for the same byte. Our solution is to intercept other sys-
tem calls besides reads such as lseek to synchronize the
state of cursors between input ﬁles and our id labeling. For
network packet, it does not have such issues since every sin-
gle byte are sequentially received/processed upon entering
the system. We should note there exist some special cases
of user-input which cannot be caught via system calls, e.g.,
the command line option inputs (i.e., argv), for which we
label all data from the bottom of stack to the frame just be-
fore main with ids upon entering function main.
An Example Of Lineage Tracing. We use the example
in Figure 2 to illustrate lineage computation. The procedure
is presented in Table 1. The ﬁrst column presents the con-
trol ﬂow trace. To disclose the complete computation, we
extend the excerpt in Figure 2 to include some code in li-
brary, labeled with pc1 and pc2. Inside the function call
fread, system call READ is ﬁrst issued to load in the gif
ﬁle to buf with the input length of size. The values in
buf is then copied to the structure imagehed.
In Table 1, the column labeled def indicates the vari-
ables that are deﬁned at the statement instance. Columns
usex and DEF(usex) represent the variables used and the
previous statement instances that deﬁne these variables, re-
spectively. The last column shows the data lineage. Accord-
ing to Equation 1, after the system call READ, each byte
is assigned a unique id at pc11. Then, at pc27,8,9,10, the
lineages of corresponding bytes are propagated to variables
wide hi, wide lo, high hi, high lo. Note that
*p points to these variables at the various instances of
pc2. At 2451, wide hi and wide lo are used to deﬁne
width, according to the equation, the lineage of width
at 2451 is the union of the lineages of wide hi and
wide lo. Eventually, at 4941, we acquire the exact lin-
eage as demonstrated earlier in Figure 2.
Efﬁcient Lineage Representation. Compared with exist-
ing techniques with similar functions such as TaintCheck
[15], in which one bit is required for one byte, we are fac-
ing a much harder space problem because we are computing
a set for each byte, which potentially has the same cardi-
nality of the entire input set. Moreover, set operations are
performed at each step of execution. Therefore, an efﬁcient
set representation is critical to the system performance. A
naive link-list based implementation may be devastating.
For example, sets with thousands of elements may have to
be traversed for the execution of a single instruction. Fortu-
nately, recent research on dynamic slicing [24] reveals that
reduced ordered Binary Decision Diagram (roBDD) [4] can
be used to achieve both space and time efﬁciency in repre-
senting sets, especially when these sets have the character-
istics of overlapping, clustering, and reappearing. Data lin-
eage possesses exactly these characteristics. For example,
the execution of statement “y=x+1” gives rise to reappear-
ing lineages because both x and y have the same lineage.
A statement like “z=y+x” introduces signiﬁcantly amount
of overlap between the lineages of x, y and z, due to the
union operation. The detailed study of these properties is
not the focus of this paper.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 13:15:55 UTC from IEEE Xplore.  Restrictions apply. 
International Conference on Dependable Systems & Networks: Anchorage, Alaska, June 24-27 20081-4244-2398-9/08/$20.00 ©2008 IEEE250DSN 2008: Lin et al.Table 1. Computation of Data Lineage
def
use0
DEF
(use0)
use1
DEF
(use1)
DL(def @si)/DL(si)
fread(...)
READ (buf,size,...)
*p = buf[i]
*p = buf[i]
*p = buf[i]
*p = buf[i]
width=...
∀0 ≤ i < size buf[i]
wide lo
wide hi
high lo
high hi
width
buf[6]
buf[7]
buf[8]
buf[9]
wide hi
pc11
pc11
pc11
pc11
pc28
wide lo
height=...
height
high hi
pc210
high lo
...width*height...
width
2451
height
pc27
pc29
2461
∀0 ≤ i < size DL(buf [i]@pc11) = get new id()∗∗∗
DL(∗p@pc27) = DL(buf [6]@pc11) = {6}
DL(∗p@pc28) = DL(buf [7]@pc11) = {7}
DL(∗p@pc29) = DL(buf [8]@pc11) = {8}
DL(∗p@pc210) = DL(buf [9]@pc11) = {9}
DL(width@2451) = DL(wide hi@pc28)
DL(height@2461) = DL(high hi@pc210)
DL(4941) = DL(width@2451) ∪ DL(height@2461)
∪DL(wide lo@pc27) = {6, 7}
∪DL(high lo@pc29) = {8, 9}
= {6, 7, 8, 9}
si
2311
pc1∗
1
pc2∗∗
7
pc28
pc29
pc210
2451
2461
4941
* pc1, pc2 are statements in libc functions.
** the input byte with offset 7, with the value “0x00”, is loaded to buf[6] by the 6th instance of pc2
*** since the input sequence starts with buf[0] and the id assignment starts at 0, DL(buf [i]@pc11) ≡ i.
As roBDD is capable of efﬁciently representing the
power set domain of a universal set (here the universal set
is the set of input values), it beneﬁts us in the following re-
spects. First, each unique lineage set is indexed by a unique
integer in roBDD. In other words, two sets are represented
by the same integer number if and only if they are identi-
cal. This is critical to our system, because instead of storing
a set for each byte in memory to represent its lineage, we
only need to store an integer. Furthermore, performing the
equivalence test on two sets can be achieved in O(1) time
by comparing the corresponding integers. Second, roBDD
also promises time efﬁciency because set operations can be
translated into roBDD operations. For instance, binary op-
erations (e.g., union) of two sets whose roBDD representa-
tions contain n and m roBDD nodes can be performed in
time O(n × m) [5]. Note that the number of roBDD nodes
is often much smaller than the number of elements in the
represented set.
Binary Instrumentation.
In order to trace lineage, we
have to instrument the binary of the program such that lin-
eage information is updated during program execution. Ac-
cording to Equation 1, we need to update the DL set of the
left hand side variable at every step of the execution and
store it somewhere. In our system, we use shadow space to
store lineage sets. Speciﬁcally, if the variable is stored at a
speciﬁc stack/heap location, a corresponding shadow mem-
ory (SM) is allocated and used to store the set associated
with the variable. Similarly, we use the shadow register
ﬁle (SRF) to store the sets for variables in registers. Both
shadow memory and shadow registers are implemented by
software.
4
Input Mutation
The lineage tracing component collects runtime informa-
tion about the random generated input (benign input). This
information is used to direct the other key component of
our system, the input mutator, to generate an exploit.
In
this paper, an exploit refers to an input that leads to unsafe
}
} else return T ;
return NULL;
dence*/
}
return NULL;
return Tx;
}
wl.add(SCD(t));
Tx = T ;
if (s is not executed with input T )
if (Tx) {
Tx = DirectedTGen (s,T , SCD);
si = the last execution instance of s;
return Search(s,si,T ,SCD);
for each p ∈ SCD(t), p is executed with T ) {
T (cid:48) = MMutate(p1, t, T, DL);
if (T (cid:48) and Tx=DirectedTGen(s,T (cid:48),SCD))
DL = TraceDL(T ); /* TraceDL () is the lineage tracing procedure*/
if (s is not executed with input T ) {
wl = {s}; /*wl is a worklist*/
while (t = wl.removeNext()) {
Algorithm 1 Input Mutation
1: Driver (s, T , SCD) /* s:suspect, T :benign input, SCD: static control depen-
2: {
3:
4:
5:
6:
7:
8:
9:
10:
11: }
12: DirectedTGen (s, T ,SCD)
13: {
14:
15:
16:
17:
18:
19:
20:
21:
22:
23:
24:
25:
26:
27: }
28: Search (s, ti, T , SCD) /*s:suspect, ti:the execution point to start search*/
29: {
30:
31:
32:
33:
34:
35:
36:
37:
38: }
39: Mutate (s, DL, T )/* s:suspect, DL:the lineage relevant to the suspect */
40: {
41:
42:
43:
44:
45:
46:
47:
48:
49:
50:
51:
52:
53:
54: }
/* Facilitated by SCD*/
pj = a predicate instance that controls the deﬁnition of ti;
if (T (cid:48)=Search (s, pj, T ,SCD)) returnT’;
return NULL;
}
/*Heuristic Two: change input lengths*/
X = DL; Threshold = 0;
while ( Threshold++ < 16) {
/*Heuristic One: change input values*/
for v in {MAXINT, ’%n’, 0, ...} {
T (cid:48)= replace DL part in T with v;
if (AttackDetected (s, T (cid:48))) return T (cid:48);
DL = TraceDL(T );
if (DL(ti) (cid:54)= φ)
return T (cid:48);
if (T (cid:48)=Mutate (s, DL(ti), T ))
X = X · X;
T (cid:48)= replace the DL part in T with X;
if (AttackDetected(s, T (cid:48))) return T (cid:48);
}
/*More heuristics*/
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 13:15:55 UTC from IEEE Xplore.  Restrictions apply. 
International Conference on Dependable Systems & Networks: Anchorage, Alaska, June 24-27 20081-4244-2398-9/08/$20.00 ©2008 IEEE251DSN 2008: Lin et al.memory writes; gaining control of the host program through
these unsafe writes is beyond the scope of this paper.
The overall procedure is illustrated by the algorithms
presented in Algorithm 1. Method Driver (line 1-11)
serves as the driver.
It checks if the program execution
with the benign input T covers the suspect s. SCD con-
tains the static control dependence information, which is
precomputed from the binary. Readers who are interested
in computing static control dependence are referred to [22].
The implementation of our SCD component is discussed in
Section 5. If s is not covered by the benign execution, the
driver calls the method DirectedTGen (line 2-27), which
is a directed input generation procedure that produces a Tx
to cover s. More details about the DirectedTGen proce-
dure will be disclosed at the end of this section.
Now, let us focus on the Search (line 28-38) method
and the Mutate (line 39-54) method. These two methods
aim to mutate the benign input that covers the suspect s to
generate an exploit. If they fail to produce one, our system
considers s innocent.
Given the suspect s and its last execution instance si in
the benign execution with input T , the Search method is
called in the Driver function to look for the lineage that
is relevant to si and then automatically mutate it to gen-
erate an exploit. The Search method ﬁrst checks if the
current search point ti has a non-empty lineage. If so, it
calls Mutate to change the DL(ti) part of input T . If not,
or the mutation is not successful, meaning the suspicious
vulnerability is not triggered, the search procedure looks