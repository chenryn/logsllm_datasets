    在你积极寻找 CSRF 时，让 Burp 在后台运行以记录与目标站点相关的其他流量。不断点击“前进”按钮，直到你遇到与状态改变操作相关的请求。例如，假设你正在测试你发现的密码更改功能是否容易受到 CSRF 的攻击。你已经在你的 Burp 代理拦截了请求。
POST /password_change
Host: email.example.com
Cookie: session_cookie=YOUR_SESSION_COOKIE
(POST request body)
new_password=abc123
    In the intercepted request, look for signs of CSRF protection mechanisms. Use the search bar at the bottom of the window to look for the string
     "csrf"
    or
     "state"
    . CSRF tokens can come in many forms besides POST body parameters; they sometimes show up in request headers, cookies, and URL parameters as well. For example, they might show up like the cookie here:
    在拦截请求中，寻找CSRF保护机制的迹象。使用窗口底部的搜索栏搜索字符串“csrf”或“state”。除了POST主体参数外，CSRF令牌还可以采用许多形式；它们有时也会出现在请求头、cookie和URL参数中。例如，在此处可能会像cookie一样显示：
POST /password_change
Host: email.example.com
Cookie: session_cookie=YOUR_SESSION_COOKIE; csrf_token=871caef0757a4ac9691aceb9aad8b65b
(POST request body)
new_password=abc123
    But even if you find a CSRF protection present on the endpoint, you could try a variety of protection-bypass techniques. I’ll talk about them later in the chapter.
    即使您在端点上发现了CSRF保护，您仍可以尝试各种保护绕过技术。我将在本章稍后讨论它们。
    Step 3: Confirm the Vulnerability
    After you’ve found a potentially vulnerable endpoint, you’ll need to confirm the vulnerability. You can do this by crafting a malicious HTML form that imitates the request sent by the legitimate site.
    在找到潜在易受攻击的端点后，您需要确认这种脆弱性。您可以通过构建恶意HTML表单来模仿合法站点发送的请求来实现这一点。
    Craft an HTML page like this in your text editor. Make sure to save it with an
     .html
    extension! This way, your computer will open the file with a browser by default:
    使用文本编辑器制作一个像这样的HTML页面。确保将其保存为.html扩展名！这样，您的计算机将默认使用浏览器打开文件：
   1
     2
     3
   4
    The
    tag specifies that you’re defining an HTML form. An HTML form’s
     method
    attribute specifies the HTML method of the request generated by the form, and the
     action
    attribute specifies where the request will be
    sent to
     1
    . The form generates a POST request to the endpoint
     https://email.example.com/password_change
    . Next are two input tags. The first one defines a POST parameter with the name
     new_password
    and the value
     abc123
     2
    . The second one specifies a
     Submit
    button
     3
    . Finally, the
    tag at the bottom of the page contains JavaScript code that submits the form automatically
     4
    .
    标签指定了HTML表单的定义。HTML表单的method属性指定了表单生成的请求的HTML方法，而action属性指定了请求将发送到的位置1。该表单生成一个POST请求到端点https://email.example.com/password_change。接下来是两个输入标签。第一个定义了一个名为new_password和值为abc123的POST参数2。第二个指定一个提交按钮3。最后，在页面底部的标签包含自动提交表单的JavaScript代码4。
    Open the HTML page in the browser that is signed into your target site. This form will generate a request like this:
    打开已登入目标站点的浏览器中的 HTML 页面。此表单将生成以下请求：
POST /password_change
Host: email.example.com
Cookie: session_cookie=YOUR_SESSION_COOKIE
(POST request body)
new_password=abc123
    Check if your password on
     email.example.com
    has been changed to
     abc123
    . In other words, check if the target server has accepted the request generated by your HTML page. The goal is to prove that a foreign site can carry out state-changing actions on a user’s behalf.
    检查您在email.example.com上的密码是否被更改为abc123。换句话说，检查目标服务器是否接受了您的HTML页面生成的请求。目标是证明外部网站可以代表用户执行状态更改操作。
    Finally, some websites might be missing CSRF tokens but still protect against CSRF attacks by checking if the referer header of the request matches a legitimate URL. Checking the referer header protects against CSRF, because these headers help servers filter out requests that have originated from foreign sites. Confirming a CSRF vulnerability like this can help you rule out endpoints that have referer-based CSRF protection.
    一些网站可能缺少CSRF令牌，但仍通过检查请求的引用来源头（referer header）是否匹配合法的URL来防止CSRF攻击。检查引用来源头可以防止CSRF攻击，因为这些头信息帮助服务器筛选出源于外部网站的请求。确认这样的CSRF漏洞可以帮助您排除具有基于引用来源头的CSRF保护的节点。
    However, it’s important for developers to remember that referer headers can be manipulated by attackers and aren’t a foolproof mitigation solution. Developers should implement a combination of CSRF tokens and
     SameSite
    session cookies for the best protection.
    然而，开发人员需要记住，引用头可以被攻击者操纵，且不是绝对可靠的缓解解决方案。开发人员应该实现CSRF令牌和SameSite会话cookie的组合，以获得最佳保护。
    Bypassing CSRF Protection
    Modern websites are becoming more secure. These days, when you examine requests that deal with sensitive actions, they’ll often have some form of CSRF protection. However, the existence of protections doesn’t mean that the protection is comprehensive, well implemented, and impossible to bypass. If the protection is incomplete or faulty, you might still be able to achieve a CSRF attack with a few modifications to your payload. Let’s talk about techniques you can use to bypass CSRF protection implemented on websites.
    现代网站变得更加安全。现在，当您检查涉及敏感操作的请求时，它们通常会有某种形式的CSRF保护。但是，保护的存在并不意味着保护是全面的，实施良好的并且不可能被绕过。如果保护不完整或有故障，您仍然可以通过对有效载荷进行一些修改来实现CSRF攻击。让我们谈谈您可以使用的绕过实施在网站上的CSRF保护的方法。
    Exploit Clickjacking
    If the endpoint uses CSRF tokens but the page itself is vulnerable to clickjacking, an attack discussed in
     Chapter 8
    , you can exploit clickjacking to achieve the same results as a CSRF.
    如果端点使用CSRF令牌，但页面本身容易受到点击劫持攻击（第8章中讨论的一种攻击），您可以利用点击劫持来实现与CSRF相同的结果。
    This is because, in a clickjacking attack, an attacker uses an iframe to frame the page in a malicious site while having the state-changing request
    originate from the legitimate site. If the page where the vulnerable endpoint is located is vulnerable to clickjacking, you’ll be able to achieve the same results as a CSRF attack on the endpoint, albeit with a bit more effort and CSS skills.
    因为在点击劫持攻击中，攻击者使用一个iframe将页面嵌入到恶意站点而将状态改变请求源自合法站点。如果存在漏洞让受攻击终端页面易于遭到点击劫持，攻击者可以在终端点上达到和CSRF攻击的同样效果，只需更多的努力与CSS技能。
    Check a page for clickjacking by using an HTML page like the following one. You can place a page in an iframe by specifying its URL as the
     src
    attribute of an
    tag. Then, render the HTML page in your browser. If the page that the state-changing function is located in appears in your iframe, the page is vulnerable to clickjacking:
    使用以下HTML页面检查点击劫持。您可以通过将页面的URL指定为标记的src属性来将页面放置在iframe中。然后，在浏览器中呈现HTML页面。如果包含状态更改函数的页面出现在您的iframe中，则该页面容易受到点击劫持攻击：
    Clickjack test page
    This page is vulnerable to clickjacking if the iframe is not blank!
    Then you could use clickjacking to trick users into executing the state-changing action. Refer to
     Chapter 8
    to learn how this attack works.
    那么你可以使用点击劫持来欺骗用户执行状态变更操作。参考第8章以了解此攻击的工作原理。
    Change the Request Method
    Another trick you can use to bypass CSRF protections is changing the request method. Sometimes sites will accept multiple request methods for the same endpoint, but protection might not be in place for each of those methods. By changing the request method, you might be able to get the action executed without encountering CSRF protection.
    您可以使用的另一种绕过CSRF保护的方法是更改请求方法。有时站点会接受相同端点的多个请求方法，但每种方法可能都没有保护措施。通过更改请求方法，您可能能够执行操作而不遇到CSRF保护。
    For example, say the POST request of the password-change endpoint is protected by a CSRF token, like this:
    例如，假设密码更改终端的POST请求由CSRF令牌保护，如下所示：
POST /password_change
Host: email.example.com
Cookie: session_cookie=YOUR_SESSION_COOKIE
(POST request body)
new_password=abc123&csrf_token=871caef0757a4ac9691aceb9aad8b65b
    You can try to send the same request as a GET request and see if you can get away with not providing a CSRF token:
    您可以尝试将相同的请求作为GET请求发送，看一下是否可以免费提供CSRF令牌：
GET /password_change?new_password=abc123
Host: email.example.com
Cookie: session_cookie=YOUR_SESSION_COOKIE
    In this case, your malicious HTML page could simply look like this:
    在这种情况下，你的恶意 HTML 页面可能看起来很简单，就像这样：
    The HTML
    tag loads images from external sources. It will send a GET request to the URL specified in its
     src
    attribute.
    HTML  标签从外部源加载图像。它将向其 src 属性中指定的 URL 发送 GET 请求。
    If the password change occurs after you load this HTML page, you can confirm that the endpoint is vulnerable to CSRF via a GET request. On the other hand, if the original action normally uses a GET request, you can try converting it into a POST request instead.
    如果在加载此HTML页面后密码更改发生，则可以通过GET请求确认该端点容易受到CSRF攻击。另一方面，如果原始操作通常使用GET请求，则可以尝试将其转换为POST请求。
    Bypass CSRF Tokens Stored on the Server
    But what if neither clickjacking nor changing the request method works? If the site implements CSRF protection via tokens, here are a few more things that you can try.
    但如果既不能进行点击劫持，也不能更改请求方法，如果网站通过令牌实现了 CSRF 保护，那么你可以尝试以下几件事情。
    Just because a site uses CSRF tokens doesn’t mean it is validating them properly. If the site isn’t validating CSRF tokens in the right way, you can still achieve CSRF with a few modifications of your malicious HTML page.
    仅仅因为一个站点使用CSRF令牌并不意味着它正确地验证了它们。如果该站点没有以正确方式验证CSRF令牌，则您仍然可以通过一些恶意HTML页面的修改来实现CSRF。
    First, try deleting the token parameter or sending a blank token parameter. For example, this will send the request without a
     csrf_token
    parameter:
    首先，尝试删除令牌参数或发送空令牌参数。例如，这将发送没有csrf_token参数的请求。
POST /password_change
Host: email.example.com
Cookie: session_cookie=YOUR_SESSION_COOKIE
(POST request body)
new_password=abc123
    You can generate this request with an HTML form like this:
    你可以使用以下 HTML 表单来生成此请求：
    This next request will send a blank
     csrf_token
    parameter:
    这个下一个请求会发送一个空的csrf_token参数。
POST /password_change
Host: email.example.com
Cookie: session_cookie=YOUR_SESSION_COOKIE
(POST request body)
new_password=abc123&csrf_token=
    You can generate a payload like this by using an HTML form like the following:
    通过使用以下HTML表单，您可以生成类似于这样的有效载荷：
    Deleting the token parameter or sending a blank token often works because of a common application logic mistake. Applications sometimes check the validity of the token only
     if
    the token exists, or if the token parameter is not blank. The code for an insecure application’s validation mechanism might look roughly like this:
    删除令牌参数或发送空令牌通常有效，因为存在常见的应用程序逻辑错误。应用程序有时仅在令牌存在或令牌参数不为空时才检查令牌的有效性。不安全应用程序的验证机制代码可能大致如下：
def validate_token():
1 if (request.csrf_token == session.csrf_token):
    pass
  else:
2 throw_error("CSRF token incorrect. Request rejected.")
[...]
def process_state_changing_action():
  if request.csrf_token:
    validate_token()
3 execute_action()
    This fragment of Python code first checks whether the CSRF token exists