25.1.1正向—使用NDK编写Native层应用
919/1144
种方法，使得Java层的方法与C/C++层的函数能够耦合起来，让调用
C/C++层的函数与调用普通Java方法一样简单。
开发的第一步需要在Java文件中声明要使用Native层的方法的名
字，方法的名字前面需要加上native参数，表明该方法是一个Native
层方法，例如，新建了如下所示的一个类，里面有一个Native方法：
public class NdkTest{
public native String getNativeString();
}
将这个文件保存为NdkTestjava，然后在同目录下，运行
javahNdkTest”命令，就会在同目录下生成NdkTest.h文件。当类在
某个包（package）里面时，需要将包的全称写清楚。
下面来看一下新生成的这个文件，文件的内容非常简单，具体如
下：
/*DO NOT EDIT THIS FILE - it is machine generated */
#include
*HeaderforclassNdkTest*/
#ifndef_Included_NdkTest
#define _Included_NdkTest
#ifdefcplusplus
extern"C”{
#endif
/*
---
## Page 920
CTF特训营：技术详解、解题方法与
25.1.1正向—使用NDK编写Native层应用
920/1144
*Class:NdkTest
*Method:getNativeString
*Signature:()Ljava/lang/String;
JNIEXPORTjstringJNICALLJava_NdkTest_getNativeString
7
(JNIEnv*,jobject);
#ifdef _cplusplus
pue#
#endif
首先是一个头文件，这个头文件中声明了NDK中JNi调用
所需的各个变量。其次声明了一个函数
Java_NdkTest_getNativeString，返回值为jstring。该函数的参数有两
个，类型分别为JNIEnv*和jobject，第一个参数为当前线程的JNIEnv
环境变量指针，第二个参数jobject为该函数所属java类实例的指针
与方法getNativeString（）没有参数不同，这两个参数JNIEnv*和jobject
是每个JNI函数必须的，如果上层的Java声明中包含了参数的话，则
INI函数的参数列表将按数量增加，类型则与声明的变量类型对应
需要注意的是，函数Java_NdkTest_getNativeString的声明前有
JNIEXPORT参数，这个参数表明该函数是导出的，即使NDK在编译
过程中关闭了符号，该符号也会存在，并且仍然是一个导出函数，因
此是可以从IDA的Exports窗口中看到的
---
## Page 921
CTF特训营：技术详解、解题方法与
25.1.1正向
一使用NDK编写Native层应用
921/1144
头文件生成后，下面进行第二步，编写相关函数的实现，一个简
单的示例代码如下：
#include "NdkTest.h”
JNIEXPORT jstring JNICALL Java_NdkTest_getNativeString(JNIEnv*env,jobject
obj)
{
return(*env)->NewStringUTF(env,“Just a test!");
}
这个函数返回了一个Java字符串“Justatest!"，更多的JNl函数
请查阅AndroidJNi调用文档
第三步修改编译参数，即新建两个文件：Android.mk
Application.mk，示例代码如下：
Android.mk
LOCAL_PATH:=$（call my-dir)
includeS（CLEARVARS)
LOCAL_MODULE
:=ndk_test
LOCAL_SRC_FILES:=NdkTest.C
include$(BUILD_SHARED_LIBRARY)
Application.mk
APP_ABl:=armeabi-v7a
APP_PIE:=true
然后使用ndk-build编译就行了，上面的LOCAL_MODULE变量指
明了生成的ib库文件的名字，例如本例中生成的库文件名为
---
## Page 922
CTF特训营：技术详解、解题方法与
25.1.1正向—使用NDK编写Native层应用
922/1144
libndk_test.so
最后一步，显式地加载lib库文件，NDK生成的库文件需要显式加
载，毕竟APK事先是不知道你要加载什么库的，加载库文件的指令一
股写在类的static学段里，例如，之前的NdkTest类可以修改为如下代
码：
public class NdkTest{
static{
System.loadLibrary("ndk_test");
public native String getNativeString()
这样，一个简单的NDKJNI调用例子就写好了，就可以像调用
Java方法一样调用C/C++函数了。
从这个步骤中不难看出，NDKJNI调用需要真备三个条件，分别
是：需要有System.loadLibrary方法显式加载lib库文件；其次Java类
中需要有native声明的方法：最后需要Native层中有带JNIEXPORT参
数的形如Java_Package_Class_method的函数。
这三个条件是形成JINI调用的充分条件，那么它们是不是必要条
件呢？答案是：前两个条件是必要条件，是所有类型的JNI调用都需
---
## Page 923
CTF特训营：技术详解、解题方法与
25.1.1正向一使用NDK编写Native层应用
923/1144
要具有的条件，但是最后一个就不一定了，因为Native函数是可以动
态注册的。接下来，我们将详细介绍Native函数动态注册的原理
---
## Page 924
CTF特训营：技术详解、解题方法与
25.1.2JNI调用特征分析
924/1144
25.1.2JNI调用特征分析
本节我们将从源码的角度分析Dalvik虚拟机加载外部lib库的执行
流程，来看一下是否有隐藏在开发者文档之外的耦合方法。
本节的源码以Android7.0.0_r1为例。想要查看Android源码的读
者可以访问这个网站（http://androidxref.com/）查看，搜索和浏览都
非常方便。
首先定位到System.loadLibraryO方法，其位于源码的/libcore
ojluni/src/main/java/java/lang/System.java路径下，该方法代码如下：
1529publicstaticvoid loadLibrary(String libname)
1530
Runtime.getRuntime().loadLibraryo(VMStack.getCallingClassLoader()
libname);
1531
}
可以看出这个方法的流程非常简单，首先调用
VMStack.getCallingClassLoader()方法获取当前的ClassLoader，然后
调用Runtime里的loadLibraryo方法。
下面来看一下loadLibraryo方法，该方法位于/libcore/ojluni/src/
---
## Page 925
CTF特训营：技术详解、解题方法与
25.1.2JNI调用特征分析
925/1144
main/java/java/lang/Runtime.java目录下，具体代码如下：
959
synchronizedvoid loadLibraryO(ClassLoaderloader,Stringlibname)
960
if (libname.indexOf（(int)File.separatorChar)I=-1){
961
throw new UnsatisfiedLinkError(
962
963
String libraryName= libname;
964
965
if （loader!=null){
966
String filename = loader.findLibrary(libraryName);
967
if （filename == null){
968
// It'snot necessarily true that theClassLoaderused
969
I/System.mapLibraryName,but the default setup does,and it's
970
971
I actually searched for"liblibMyLibrary.so.so"
972
throw newUnsatisfiedLinkError(loader +couldn't find \+
973
System.mapLibraryName(libraryName) + ""*);
974
String error= doLoad(flename, loader);
975
976
if（error|=null){
977
thrownewUnsatisfiedLinkError(error);
978
1
979
return;
980
981
982
String filename =System.mapLibraryName(libraryName);
983
Listcandidates=newArrayList();
984
String lastError=null;
985
for(String directory:getLibPaths()）{
986
String candidate=directory+filename;
987
candidates.add(candidate);
988
989
if(loUtils.canOpenReadOnly(candidate){
990
String error=doLoad(candidate,loader);
991
if (error == null){
992
return;/Wesuccessfullyloaded thelibrary.Jobdone.
993
994
lastError= error;
995
996
997
998
if (lastError!=null){
---
## Page 926
CTF特训营：技术详解、解题方法与
25.1.2JNI调用特征分析
926/1144
999
throw new UnsatisfiedLinkError(lastError);
1000
1001
throw new UnsatisfiedLinkError(Library " + libraryName +” not found; tried
"+candidates);
1002}
从上面的代码可以看出，loadLibraryo方法根据传入的
ClassLoader类型的参数值不同，会进入不同的执行流程，当
ClassLoader不为空时，会利用ClassLoader的findLibrary方法来获取lib
文件的路径，这个方法主要是对传入的ib名字补上“lib”前缀和
“.so”后缀，然后从一个路径表里查找最终的绝对路径。找到绝对路
径后将路径传入doLoad方法里继续执行。
doLoad方法仍然在这个类里面，代码如下（省略了注释的部
分）：
1031
private String doLoad(String name, ClassLoader loader){
1032
I/...
1051
StringlibrarySearchPath=null;
1052
if（loader|=null&&loaderinstanceofBaseDexClassLoader){
1053
BaseDexClassLoaderdexClassLoader=(BaseDexClassLoader)loader;
1054
librarySearchPath=dexClassLoader.getLdLibraryPath();
1055
1056
l/..
1059
synchronized (this){
1060
returnnativeLoad(name,loader,librarySearchPath);
1061
1062
---
## Page 927
CTF特训营：技术详解、解题方法与
25.1.2JNI调用特征分析
927/1144
这个方法也比较简单，首先获取LD_LIBRARY_PATH路径的值
然后将库文件名字、ClassLoader实例、LD_LIBRARY_PATH路径的
值传入nativeLoad函数中继续载入。
Java层的nativeLoad方法在Native层定义为Runtime_nativeLoad函
数，源码位于/libcore/ojluni/src/main/native/Runtime.c中，具体代码如
下：
77JNIEXPORTjstringJNICALL
78Runtime_nativeoadJNIEnv*env,jclassignored,jstringjavaFilename
79
80{
81returnJVM_NativeLoad（env,javaFilename,javaLoader
javaLibrarySearchPath);
82}
这个函数非常简单，将参数原封不动地传给了JVM_NativeLoad
函数。
JVM_NativeLoad函数位于源码的/art/runtime/openjdkjvm
OpenjdkJvm.cc路径下，具体代码如下：
322JNIEXPORTjstringJVM_NativeLoad(JNIEnv*env,
323
jstring javaFilename,
324
jobject javaLoader,
325
jstringjavaLibrarySearchPath){
326ScopedUtfCharsfilename(env,javaFilename);
---
## Page 928
CTF特训营：技术详解、解题方法与
25.1.2JNI调用特征分析
928/1144
327if（filename.C_str()==NULL){
328return NULL;
329}
330
331 std:string error_msg；
332{
333
art:JavaVMExt*vm=art:Runtime:Current()->GetJavaVM();
334
bool success=vm->LoadNativeLibrary(env,
335
filename.c_str(),
336
javaLoader,
337
javaLibrarySearchPath,
338
&error_msg);
339
if(success){
340
returnnullptr;
341}
342}
343
344 // Don't let a pending exception from JNI_OnLoad cause a CheckJNI issue with
NewStringUTF
345env->ExceptionClear()
346return env->NewStringUTF(error_msg.c_str());
347}
这个函数也不长，简单看一下，首先将ib库的路径名从jstring类
型转化为普通字符串，然后使用art:：Runtime:：Current()->GetJavaVM(）
调用获取当前的Java虚拟机指针，新建一个std:：string类型的变量
error_msg来保存返回的字符串，最后将所有的变量全部传入vm
>LoadNativeLibrary函数中。
接下来调用的函数JavaVMExt:：LoadNativeLibrary就非常长了，这
个函数也是加载ib库的核心函数，重点代码摘录如下，全部代码位
于/art/runtime/java_vm_ext.cc文件中，有兴趣的读者可以研究学习一
---
## Page 929
CTF特训营：技术详解、解题方法与
25.1.2JNI调用特征分析
929/1144
下。JavaVMExt:LoadNativeLibrary函数代码如下：
722
const std:string&path,
723
jobject class_loader,
724
jstring library_path,
725
std:string*error_msg){
726 error_msg->clear();
727
728
732SharedLibrary*library;
733/..
789 const char*path_str = path.empty()?nullptr:path.c_str();
790void*handle= android:OpenNativeLibrary（env,
791
runtime_->GetTargetSdkVersion(),
792
path_str,
793
classloader,
794
795
796/
844 sym = library->FindSymbol("JNI_OnLoad",nullptr);
845if(sym==nullptr)）{
846
VLOG(jni)<<“[NoJNI_OnLoad found in\"<<path<<"];
847
was_successful = true;
848}else{
849