593
于右边的数，它返回“-1”；两数相等返回“0”：右数大于左数则返回“1”。如下所示：
a=15.8,3.0.11
gb +sort ($a <> 5b) ea: #(0, 1, 3. 5, 8)
5.哈布表操作
最后，我们l介绍哈希表上的各种操作：最神奇的是reverse操作，它把哈希表的查找方向倒
了过来，如下所示：
Ph1*205832
phonebook;
注意不要让两个键字有相同的键值一否则其中的-个就会丢失。我们还可以用keys和
values两数把键字和键值分别提取到不同的列表里：如下所示：
@names=keys#phonelook;*BobPh1."Sara*)
umbers =values $phonebook;#["24730S*,"205832*.*226010*)
用each可以提取出键字-键值对：每调用一次each就会返回一个由两个元素组成的列表，这
两个元素分别是一个新的键字和与之对应的键值：如此循环直到全部处理完为止。如下所示：
while（(Skey.Svalue)=each$phonebook)(
print *Skey\'s phone number is $value`n*:
不要错误地认为自已把数据项放到哈希表里的顺序就是从中提取它们的顺序。Perl在返回哈
希表数据项时采用的是一种随机的顺序，事实上，甚至两遍提取操作分别得到的题序都不能保
证是一样的。
18.1.4规则表达式
规则表达式（圈里人称之为“regexps"）是Perl是强项之一。它们可以实现功能极其强大的
模板匹配和替换，它们大概称得上是Perl程序员武器库里火力最猛的武器了。熟悉sed和awk或
egrep的人们对规则表达式的基本规定都应该是比较了解的；Perl的规则表达式引擎是在sed模型
的基础上扩展而来的。
我们先来看看如何使用规则表达式来匹配字符中，然后再研究如何替换它们。
1.匹配
最基本的规则表达式就是我们想在一个字符串里查找的一小段文字。传统上习惯把规则表
达式放在两个斜线字符之间，即“/regexp/”的样子：把一个规则表达式运用到一个变量或标量
数据时要使用语法“Sscalar=~/regexp/”。如果匹配是成功的，这个做为操作符的函数将返同真
值（还有一个“！~”操作符，它类似于“=~”，但两者的结果正好相反-一只有匹配失败时“！~”
才返回真值）。我们来看-个例子：检查我们的字符串里是否包含着“jaws"，如下所示：
Ssea - *water sand Jaws swismers′:
/sm/ -=goss 1.iaate xxeus.x
加入jaVa编程群：524621833
---
## Page 612
594
Linux程序设计
不过，这两条语句打印不出什么东西，这是因为规则表达式在缺省情况下是区分大小写
的：我们可以通过限制符“i”关闭这个功能。如下所示：
print *Shark alert!* if $sea  /javs/i;
我们准备查找的表达式必须出现在字符串的开始部分。类似地，“S”代表“字符串的结尾”
即这个表达式必须出现在字符串的结尾部分。但如果只给出了“regexp/”，它就将对“S_”变
量进行测试。我们现在就可以说清楚几页前介绍“S_”的隐含使用方法时给大家看的代码了，
那条语句是这样的：
Strip lines starting with a hash
while (<>)( print unless /*3/}
把它写得明白些，就是：
while ($_=<>)(print $_ unless s_=~/^#/ }
 Strip lines starting with a hash.
这一行不是以“#”字符开始的，就把它打印出来。
接下来向大家介绍通配符：“？”匹配某个字符的0次或1次出现一也就是说它前面的字符在
匹配里是可有可无的：“*”匹配0次或多次，就像shel1里的情况一样（但要注意这样的情况：
“/q*/”永远都会得到匹配，即使字符串里根本没有“q”也是如此，因为它匹配了0次。）；“+”
匹配至少一次。表18-1是这些通配符的几个用法示例：
表18-1
/:008/
匹配“shot”或“shoot”
/sho+t?
/sho*t/
匹配“sht”、“shot”、“shoot”等等
下一组特殊字符用来匹配不同类型的字符，包括常见的巨字符，即“r”匹配制表符；“n”
）
字或“_”）字符；而“\d”匹配一个数字。这些特殊字符的大写形式等于否定形式的匹配，即
“S”是--个非空格；“\W”是一个非单词字符；“D”是一个非数字等等。最后，“”匹配任
何字符和字符串。请看表18-2里的用法示例：
麦18-2
/push\s*chair/
医配“pusb”后面有零个或多个空格或制表符，然后是“chair
/number\s*\d+\s/
匹配“number”后面有零个或多个空格，然后是一个或多个数字，最后是一个空格
/^e.*ds/
既配以字母“e”为第-个字符、字母“d”为最后一个字符的任意一行文本
/\8 /
匹配任意一行不光有空格的文本行
/\sperl\8/
匹配两头各有一个空格的字符串“Perl
最后一个用法示例最好写成“AbPerlb/”，其中的“vb”是“单词边界”巨字符，它将匹配
字符串前后的非单词字符（包括空格、标点符号等）。因此，“Ab\w+\br”将匹配一个“单词”。
加入jaVa编程群：524621833
---
## Page 613
第18章Perl程序设计语言595
如果我们想知道匹配到了什么东西该怎么办？这么办：如果我们给规则表达式里我们感兴
趣的部分加上括号，Perl就会替我们把它匹配到的东西保存起来。类似于sed里的做法，Perl将把
第一个括号中的表达式匹配到的东西保存在一个名为“S1”的变量里，下一个保存到“$2”里，
依次类推。我们就可以从中看出匹配操作是如何进行的了：
Stest = *he said she said;
-pes ous ptes。 01as st 1s p.*es)/ - 645
s1 is set to *he"
先看第～个例子。Perl水远都是从最左边开始进行匹配的，这次它返问从左边开始找到的第
一个匹配（这叫做“热心"）。再看第二个例子，Perl会尽量把第一次匹配操作中的找到的匹配保
存得时间长一些：它返回自已找到的第-个匹配并尝试使这个匹配尽可能地大（这叫做“贪婪”）。
匹配到“said”。如果我们在规则表达式里使用了多个括号，Peri会把所有匹配到的东西都放在一
个列表里返回给我们，如下所示：
Stest * *he said sho said":
@matcbes ist"he*,*said”."she′，*said°1;
matches = $test =-
(Now you can oec that split(l actually sp1ics on /\b/)
（当然，如果操作的规模比较大，这种办法会很罗嗦：我们稍后会向大家介绍另一种做法。）
可以在规则表达式里定义字符集合一它们要用方括号进行定义。比如说，“[a-z]”将匹配全体
小写字母，面“[aeiou”将匹配小写的元音字母。巨字符也可以放在字符集合里；如果在字符
任何不是字母的字符。
如果你想匹配这些特殊字符本身，包括“？"、""、“（"、“”等，就必须用一个反斜线进行
转义。“As*（*？)\V”的执行情况是：先匹配一个句号，然后是零个或多个空格，然后一个左
括号，再把文本复制到一个变量里（我们把这个变量称为“后引用”，原因稍后再解释）直到遇
见右括号为止。
2.替换
对字符串进行了匹配操作之后，我们可能想把匹配替换为其他的内容。这是通过语法
“s/regcxp/replacement/”实现的。如下所示：
$test =~ s/said/did/:  Gives *he did she said*
我们可以看到，它找到了第一个匹配，替换它，然后就结束了。要想完成全部的查找和替
换，需要使用另外一个限制符“g”（sed里也这样用，甚至vi和ed也是如此）。
Stest = g/said/didig: # Gives *he did she did*
$test = *he said she said*;
在匹配操作中也可以使用“g”限制符、如下所示：
$tst-*234567890*
array±Stestz/\b(\d+)\b/g:(123, 456.7, 890)
加入jaVa编程群：524621833
---
## Page 614
596Linux程序设计
当然，在替换操作的文本替换部分里，匹配巨字符不再有特殊的意义了、这很明显，你不
会进行变替换等操作（事实上，规则表达式也会这样做。你可以把“子规则表达式”放在变
壁里，使整个表达式更整洁）。这一部分最有价值的是“后引用”变量S1和$2等。请看下面的
例子：
Stest = *Swap this and chat.*:
做为规则表达式的最后一个例子，我们对那个用来去掉注释行的表达式做点扩展：
Strip coements, version two
while (<>] (s/#.*/ / :print if/\S/ 1
它能完成什么工作？它的工作情况是这样的：先读人个文本行并把它保存到$_变量里。
然后把升字号（#）及其后面的文字替换为空字符串。然后，如果还有东西剩下—也就是如果
这一行上还有不是空格的字符的话，就把这一行打印出来。（千方不要真的用这个表达式来清除
你Perl程序里的注释，它会把使用“S#array”语法的语句也删掉一半，还会把字符串或规则表达
式里的“#”字符串及其后面的内容都掉、再说了，留着注释总是会好一些。）
利用规则表达式匹配可以做许多许多的事情，大部分常见的用途在我们这个简单的介绍见
也都提到过了。在shell提示符处输人“perldocperlre”可以看到对匹配进行介绍的完整文档。
18.1.5控制结构和子例程
我们一路走来，已经见过一些Perl语言的控制结构了，比如while循环、if和unless的语句内
用法等，其他的控制结构都是比较容易握的了。
1.测试
Perl有--个与C语言类似的if-elsif-else语句，两者之间的惟一区别是在Perl语言里必须把语句
块放在花括号里。也就是说，你不能使用下面的语句结构：
if (/y(?:es)?/1)
else
Sanswer = 1;
Sanswer = 0;
而是必须使用下面这样的语句结构：
1f[/y(?:es)?/i)(
}else {
Sanswer = 1;
Sanswer ε 0
（当然，在实际编程的时候你是不会写出这种语句来的，但你肯定会写出“Sanswer=
（y（?es)？/i)）：这样的东西来。）Perl还允许你使用unless做为if的否定-一如果这样做能够使你的
代码更清晰的话。
2.循环
我们已经见过while循环了，Perl语言还准备了--个until循环做为与while的对立面。此外，
加入jaVa编程群：524621833
---
## Page 615
第18章Perl程序设计语言
597
还有两种for循环-一与C语言相互对应。如下所示：
for ($j=C;$i) { next. if /^/: next unles6.\S/; print }
last的作用就像C语言的break语句.它的作用是整个结束一个循环。如下所示：
+ Get the Subject of an email. then give up:
hile (<>)[
last 1f ($subj)=/*Subject: (.*)/;
print *Subject was $subj\n*:
很少使用的redo语句会再次跳转到循环的开始，但不对循环条件进行测试。你可以把它用在
下面这种情况里：
wh1le (<>)(
if (/1\s*$/) (# Line ends with a backslash - continuation
redo:
Perl语言缺少C语言里的switch（或者其他语言里的case）语句。这是一个大家普遍关心的间
题，有许多办法可以解决它；perlsyn和perlfag7文档里介绍了几个解决方案。
3.语句限定符
除了C语言语法风格的控制结构外，我们还可以在单独一条语句里通过“语句限定符”给它
施加一个控制结构，我把这种情况称为“语句内”控制结构。我们已经见过if和unless的这种用
法了：
print *Operation successful* if all_ok();
Slogfile=*output.log* unless Snologging:
你也可以把while、until和for用做语句限定符。如下所示：
Sinput .* 5_ while <>; One (bad) way of concatenating a file
main_loop(1 unti1 Scowscomehome)
14
但没有多少人会这样使用for结构。
加入jaVa编程群：524621833
---
## Page 616
598
Linux程序设计
4.子例程
在Perl语言里我们并不明确区分函数和子例程；如果愿意，你可以让它们返回一个返回值
简单的子例程是像下面这样定义的：
suh greeting {
print “Hello, worldin*;
1
）
为一个字符串的话）来调用这个子例程。参数的传递是通过“@_”数组完成的。请看下面的
例子：
sub action f
warn *Not enough parameters1*
(Sone, Stwo,$three} = θ_:
print *The $one Stwo on the $three\n*:
1
action(*cat*，*sat*,“mat*);
warn函数打印出一条错误信息但允许你的程序继续执行。另外有一个die函数、它的作用是
打印出一条错误信息并立刻停止程序的执行。
“@_”是数组操作的缺省变量，就像“S_”是标量类型的缺省变量一样。传统上是使用shift
命令来获取参数的。如下所示：
eub greeting2 {
print *Hello, Sname\n*;
Sname a shift;
F
greet ing2(*Robert*1 ;
greeting2(*wor1d*1;
我们可以用return函数返回一个返回值，既可以返回一个标量数据，也可以返回一个列表
一wantarray函数会告诉你调用者希望得到的是什么。请看下面的例子：
Sub nysub (
Do some stuff
return unless defined wantarray; #void context, go home early
if(wantarray)(e Want an array
)else {+ Just want a scalar
return @results;
Aunss uxnez
 Can't get here
Perl一般会把变量的作用范围设置为全局性的，这就意味着变量通常都是全局变量一一子例
程里进行的修改会影响到调用者。如果你真的需要局部变量，就要使用my函数。my函数声明的
变量叫做字典范围变量（在Peri文档里经常简称为“字典变量”），它们甚至对当前例程的子例程
都是不可见的：它们确实够“局部”的。如果你想让什么东西的作用范围是当前例程及其子例
程，就要使用动态全局变量。请看下面的例子：
{, Aq pa6ueuo. ± rpnAus )e qns
,opysno, = xeAus
加入jaVa编程群：524621833
---