        {
            LOGI("The last ins is thumb32. Length will be 10.");
            pstInlineHook->backUpLength = 10;
        }
        else{
            LOGI("The last ins is not thumb32. Length will be 12.");
            pstInlineHook->backUpLength = 12;
        }
        //修正：否则szbyBackupOpcodes会向后偏差1 byte
        memcpy(pstInlineHook->szbyBackupOpcodes, pstInlineHook->pHookAddr-1, pstInlineHook->backUpLength); 
        ......
    }
    bool BuildThumbJumpCode(void *pCurAddress , void *pJumpAddress)
    {
        ......
            //LDR PC, [PC, #0]对应的thumb机器码为：0xf000f8df, NOP为BF00
            if (CLEAR_BIT0((uint32_t)pCurAddress) % 4 != 0) {
                BYTE szLdrPCOpcodes[12] = {0x00, 0xBF, 0xdF, 0xF8, 0x00, 0xF0};
                memcpy(szLdrPCOpcodes + 6, &pJumpAddress, 4);
                memcpy(pCurAddress, szLdrPCOpcodes, 10);
                cacheflush(*((uint32_t*)pCurAddress), 10, 0);
            }
            else{
                BYTE szLdrPCOpcodes[8] = {0xdF, 0xF8, 0x00, 0xF0};
                //将目的地址拷贝到跳转指令缓存位置
                memcpy(szLdrPCOpcodes + 4, &pJumpAddress, 4);
                memcpy(pCurAddress, szLdrPCOpcodes, 8);
                cacheflush(*((uint32_t*)pCurAddress), 8, 0);
            }
        ......
    }
###### Thumb-2 第2步
构造stub代码。构造思路是先保存当前全部的寄存器状态到栈中。然后用BLX命令（以arm模式）跳转去执行用户自定义的Hook后的函数。执行完成后，从栈恢复所有的寄存器状态。最后（以thumb模式）跳转至第三部分备份代码处。
`细节1`：为什么跳转到第三部分要用thumb模式？因为第三部分中是含有备份的thumb代码的，而同一个顺序执行且没有内部跳转的代码段是无法改变执行模式的。因此，整个第三部分的汇编指令都需要跟着备份代码用thumb指令来编写。
`细节2`：第二部分是arm模式，但是第三部分却是thumb模式，如何切换？我在`第一步的细节2`中提到过，无论是arm还是thumb模式，每条汇编指令的地址肯定都能整除2，因为最小的thumb16指令也需要2
Bytes。那么这时候Arm架构就规定了，当跳转地址是单数时，就代表要切换到thumb模式来执行；当跳转地址是偶数时，就代表用Arm模式来执行。这个模式不是切换的概念，换句话说与跳转前的执行模式无关。无论跳转前是arm还是thumb，只要跳转的目标地址是单数就代表接下来要用thumb模式执行，反之arm模式亦然。这真的是个很不错的设定，因为我们只需要考虑接下来的执行模式就行了。这里，本人就是通过将第三部分的起始地址+1来使得跳转后程序以thumb模式执行。
`细节3`：下方的关键代码中`ldr r3, _old_function_addr_s_thumb`到`str r3,
_old_function_addr_s_thumb`就是用来给目标地址+1的。这部分代码不能按照逻辑紧贴着最后的`ldr pc,
_old_function_addr_s_thumb`来写，而是一定要写在恢复全部寄存器状态的前面，否则这里用到的r3会错过恢复从而引起不稳定。
`细节4`：那条bic指令是用来清除`_old_function_addr_s_thumb`变量的最低位的。因为如果该Hook目标会被多次调用，那每次这个`_old_function_addr_s_thumb`都会被+1。第一次没有问题，成功变成了thumb模式，而第二次会以arm模式下偏2
bytes跳转，之后偏差越来越大，模式交叉出现。因此，本人使用bic指令来清除每次Hook调用后的地址+1效果。
`细节5`：用户自定义的Hook功能函数是有一个参数的`pt_regs *regs`，这个参数就是用`mov r0,
sp`传递的，此时r0指向的这个结构就是Hook跳转前寄存器的状态。不会受到stub或者Hook功能函数的影响。使用时`regs->uregs[0]`就是R0寄存器，`regs->uregs[6]`就是R6寄存器，`regs->uregs[12]`就是R12寄存器，`regs->uregs[13]`就是SP寄存器，`regs->uregs[14]`就是LR寄存器，`regs->uregs[15]`就是PSR寄存器（而不是PC寄存器，PC寄存器不备份）。
`细节6`：保存寄存器的细节是怎么样的？栈上从高地址到低地址依次为：CPSR,LR,SP,R12,...,R0。并且在Thumb-2方案下，CPSR中的T位会先保存为第二部分所需的0，而不是原来的thumb模式下的T:1，在跳转到第三部分时，会重新把T位变成1的。具体如下图所示，图中的CPSR的第6个bit就是T标志，因此原本是0x20030030，保存在栈上的是0x20030010，最后进入第三部分时，依然能够恢复成0x20030030。`图中R0从0x1变成了0x333只是该次APP测试中自定义的User’s
Hook Stub Function中的处理内容：regs->uregs[0]=0x333;`
关键代码如下：
    _shellcode_start_s_thumb:
        push    {r0, r1, r2, r3}
        mrs     r0, cpsr
        str     r0, [sp, #0xC]
        str     r14, [sp, #8]   
        add     r14, sp, #0x10
        str     r14, [sp, #4]    
        pop     {r0}               
        push    {r0-r12}           
        mov     r0, sp
        ldr     r3, _hookstub_function_addr_s_thumb
        blx     r3
        ldr     r3, _old_function_addr_s_thumb
        bic     r3, r3, #1
        add     r3, r3, #0x1
        str     r3, _old_function_addr_s_thumb
        ldr     r3, [sp, #-0x34]
        ldr     r0, [sp, #0x3C]
        msr     cpsr, r0
        ldmfd   sp!, {r0-r12}       
        ldr     r14, [sp, #4]
        ldr     sp, [r13]
        ldr     pc, _old_function_addr_s_thumb
###### Thumb-2 第3步
第三步，构造备份代码。构造思路是先执行之前备份的X
Bytes的thumb-2代码，然后用LDR.W指令来跳转回Hook地址+Xbytes的地址处继续执行。此处先不考虑PC修复，下文会说明。
`细节1`：LDR是arm32的指令，LDR.W是thumb32的指令，作用是相同的。这里想说的是：为什么整个过程中都一直在用LDR和LDR.W，只有在第二步中有使用过BLX指令来进行跳转？原因很简单，为了保存状态。从第一步跳转到stub开始，如果跳转使用了BLX，那就会影响到lr等寄存器，而如果使用LDR/LDR.W则只会改变PC来实现跳转而已。stub中唯一的那次BLX是由于当时需要跳转到用户自己写的Hook功能函数中，这是个正规的函数，它最后需要凭借BLX设置的lr寄存器来跳转回BLX指令的下一条指令。并且这个唯一的BLX处于保存全部寄存器的下面，恢复全部寄存器的上面，这部分的代码就是所谓的“安全地带”。因此，这其中改变的lr寄存器将在之后被恢复成最初始的状态。`第二步的细节3`中提及的r3寄存器的操作要放在这个“安全区”里也是这个原因。而在stub之外，我们的跳转只能影响到PC，不可以去改变lr寄存器，所以必须使用LDR/LDR.W。
`细节2`：下面的抽象图中可以发现与arm中的不同，arm中最后是`LDR PC, [PC,
#-4]`,这是由于CPU三级流水的关系，执行某条汇编指令时，PC的值在arm下是当前地址+8，在thumb-2下是当前地址+4。而我们要跳转的地址在本条指令后的4
Bytes处，因此，arm下需要PC-4，thumb下就是PC指向的地址。
构造出来的汇编代码抽象形式如下：
    备份代码1
    备份代码2
    备份代码3
    ......
    LDR.W PC, [PC, #0]
    HOOK_ADDR + X
## 指令修复（概述）
_注：本部分内容较多且相关代码占了几乎本项目开发的一半时间，故此处仅给出概述，本人之后为这部分内容独立写一篇文章[《Android Inline
Hook中的指令修复》](https://gtoad.github.io/2018/07/13/Android-Inline-Hook-Fix/)来详细介绍以方便读者更好地学习这方面内容。_
在上文的处理中，我们很好地保存并恢复了寄存器原本的状态。那么，原本目标程序的汇编指令真的是在它原有的状态下执行的吗？依然不是。虽然寄存器的确一模一样，但是那几条被备份的指令是被移动到了另一个地址上。这样当执行它们的时候PC寄存器的值就改变了。因此，如果这条指令的操作如果涉及到PC的值，那这条指令的执行效果就很可能和原来不一样。所以，我们需要对备份的指令进行修复。在实际修复过程中，本人发现还有些指令也受影响，有如下几种：
  1. 取PC的值进行计算的指令
  2. 跳转到备份区域的指令
第一种我们已经解释过了，而第二种则是由于我们备份区域中的代码已经被替换了，如果有跳转到这个区域的指令，那接下来执行的就不试原来这个位置的指令了。我们可以再把第二类细分成两类：`从备份区域跳转到备份区域的指令`和`从备份区域外跳转到备份区域的指令`，前者本人通过计算目标代码在备份区域中的绝对地址来代替原来的目标地址从而修复，而后者由于不知道整个程序中到底有多少条指令会跳转过来，所以无法修复。不过个人认为这后者遇到的概率极小极小。因为我们使用Native
Hook前肯定已经逆向分析过了，在IDA这类软件中看到自己即将备份的区域里被打上了类似"loc_XXXXXX"的标签时，一定会小心的。
这部分的修复操作参考了`ele7enxxh`大神的博客和项目，里面修复了许多可能出现的PC相关指令的情况，从中的确启发了许多！但依然有点BUG,主要集中在BNE
BEQ这些条件跳转的指令修复上，以及CPU模式切换上容易忽略一些地址+1的问题。本项目中对这些本人已经遇到的BUG进行了修复。具体PC相关指令的修复细节本人之后会独立写一篇[《Android
Inline Hook中的指令修复》](https://gtoad.github.io/2018/07/13/Android-Inline-Hook-Fix/)，其中也会提到我之前说的那些BUG的修复与改进。本人在此中只说一下本项目中是如何处理这个环节的：
  1. 遍历备份的指令，arm32自然是一个个4 bytes的指令取走去处理就好，thumb-2则需要判断指令是thumb16还是thumb32，把它们一条条取出来处理。
  2. 对每条指令进行PC修复，根据Hook目标地址和该指令在备份代码里的偏移以及CPU的三级流水作用来计算出这条指令当时原本PC的值。从而用这个计算出来的值来代替这个指令中对当前PC的计算。
  3. 将每条备份代码修复后的代码按顺序拼接（不需要修复的就用原来的指令去拼接），并在末尾拼接上原本的LDR/LDR.W跳转指令。
于是上文第三步中构造出来的汇编代码抽象形式如下：
    备份代码1
    备份代码2
    涉及PC的备份代码3的修复代码1
    涉及PC的备份代码3的修复代码2
    涉及PC的备份代码3的修复代码3
    涉及PC的备份代码3的修复代码4
    涉及PC的备份代码3的修复代码5
    备份代码4
    涉及PC的备份代码5的修复代码1
    涉及PC的备份代码5的修复代码2
    LDR/LDR.W PC, [PC, #-4]
    HOOK_ADDR + X
#### 条件跳转的修复方式（以Thumb为例）
在ARM32、Thumb16、Thumb32中都是有条件跳转的指令的，本项目三套都修复了。下面来讲一下Thumb16下条件跳转的修复，作为整个`指令修复`的典型代表吧。
条件跳转指令的修复相比于其它种类的指令有一个明显恶心的地方，看下面两张图可以很明显看出来，先看第一张：
12
Bytes的备份代码与各自对应的修复代码自上而下一一对应，尾部再添加个跳转回原程序的LDR。这就是上文中设想的最标准的修复方式。然而当其中混入了一条条件跳转指令后：
我们发现按照原程序的顺序和逻辑去修复条件跳转指令的话，会导致条件跳转指令对应的修复指令（图中红色部分）不是完整的一部分，而且第二部分需要出现在返回原程序跳转的后面才能保持原来的程序逻辑。这时有两个问题：
  1. 图中X的值如何确定？我们是从上到下一条条修复备份指令然后拼接的，也就是说这条BLS指令下方的指令在修复它的时候还没被修复。这样这个X的值就无法确定？
  2. Thumb-2模式在备份时，12 Bytes最大是可能备份6条Thumb16指令的。也就是说，可能在备份指令中出现多条条件跳转指令，这时候会出现跳转嵌套，如下图：
为了解决第一个问题，本人先在Hook一开始的init函数中建立一个记录所有备份指令修复后长度的数组`pstInlineHook->backUpFixLengthList`，然后当修复条件跳转指令时，通过计算其后面修复指令的长度来得到X的值。这个方法一开始只是用来解决问题1的，当时还没想到问题2的情况。因为这个数组中看不出后面的指令是否存在其它条件跳转指令，所以最后的跳转嵌套时会出错。那第二个问题如何解决呢？本人开始意识到如果条件跳转指令要用这种”两段“式的修复方式的话，会使得之后的修复逻辑变得很复杂。但是按照原程序的执行逻辑顺序似乎又只能这么做...吗？不，第一次优化方案如下所示：
这个方案通过连续的三个跳转命令来缩小这个BXX结构，使其按照原来的逻辑跳转到符合条件的跳转指令去，然后再跳转一次。至此其实已经解决了当前遇到的“两段”式麻烦。但是最后本人又想到了一个新的优化方案：`逆向思维方案`，可以简化跳转逻辑并在Arm32和Thumb32下减少一条跳转指令的空间（Thumb16下由于需要补NOP所以没有减小空间占用），如下图：