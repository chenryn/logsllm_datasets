(3)
where prev(ùë†, ùëù) means all the switches in front of ùë† on the path ùëù,
next(ùë†, ùëù) represents all the switches behind ùë†, pred(ùêº) denotes all
the predecessor instructions in the instruction dependency graph,
and succ(ùêº) means all the successor instructions.
Encoding external and global variables. See Appendix B.
5.6 Encoding Resource Extensibility
To support extensibility, Lyra is able to handle the algorithm even
though it is distributed across multiple switches, e.g., splitting Con-
nTable on ToRs and Aggs in Figure 1. Because other constraints
such as the instruction dependencies and global variable constraints
are already encoded, the data can only flow from upstream to down-
stream (e.g., from Agg to ToR in a DCN). It is impossible that the up-
stream switch (e.g., Agg) requires a result generated by downstream
switches (e.g., ToR); thus, in order to encode the resource extensibil-
ity, we only consider what is the information downstream switches
require from the upstream and pass this information through.
Specifically, in a Lyra program, there are two types of informa-
tion required by the downstream: value in the local variable and
the result of a predicate. Lyra passes this information via pushing
it in the packet header, enabling the downstream switches to get
it from the parser. We call such information as extensible resources.
These resources ‚Äúbridge‚Äù the upstream and downstream switches,
and keep their ‚Äúcorrelations‚Äù. For example in Figure 1 LB program,
suppose the ConnTable and VIPTable are deployed on the Agg and


SIGCOMM ‚Äô20, August 10‚Äì14, 2020, Virtual Event, NY, USA
Gao et al.
Figure 9: Experimental results conducted on a workstation with Intel Core i7 3.7GHz 6-core CPU and 16GiB RAM.
ToR switches respectively. Given the fact that the VIPTable needs
the ConnTable‚Äôs table hit/miss information, Lyra needs to ask the
Agg switch to pack that information in the packet header, so that
the ToR switch can apply or skip the VIPTable based on the result.
Similarly, if the ConnTable is split across two switches, then Lyra
adds the first ConnTable‚Äôs entry hit/miss information to the header.
The extensible resource encoding algorithm is shown in Algo-
rithm 2. Because the program could be split at any position, the
content in the extensible resources is also dynamic. In a nutshell, the
extensible resource contains all the local variables that are not writ-
ten but read by the downstream switches. Lyra checks each local
variable and collects the instruction that writes or reads the variable.
After the SSA form conversion (step 4 in ¬ß4.2), there should be only
one write instruction ùêπùë§ and a list of read instructions Fùëü . Next,
we can calculate whether the variable is read Vùëü or written Vùë§ by
the downstream via the deployment boolean function. Finally, we
can compute the existence condition by comparing whether two
flags Vùëü and Vùë§ are different.
5.7 Translator
With a set of conditional placement constraints, i.e., the constraints
encoded in ¬ß5.2-¬ß5.6, we call an SMT solver to solve them, obtaining
a solution that presents a concrete placement plan for tables, in-
structions, and variables. We equip the back-end with different chip
language (e.g., P4 and NPL) templates; thus, we can easily trans-
late the solved plan into multiple pieces of chip-specific code. The
current Lyra prototype supports P414, P416 and NPL generation.
5.8 Control Plane Interfaces
Lyra does not synthesize the control plane programs/functions such
as installing flow table entries and configuration policies. Instead,
Lyra allows the programmers to explicitly specify the tables as ex-
ternal variables (defined in ¬ß3.4) in Lyra program without worrying
about how these tables are allocated or distributed. In other words,
the connection between the control plane and data plane supported
by Lyra is abstracted to the variables in OBP representation, so
programmers only need to fill in the control plane tables, but do not
need to know exactly how each table is mapped to target devices.
For example, Lines 36-43 in Figure 4, Lyra defines two control
plane variables, extern dict
[1024] conn_table and extern dict [1024] vip_table via the keyword extern (also ex-
plained in ¬ß3.4). After this, Lyra compiler compiles the program
into multiple pieces of chip code for distributing across the un-
derlying switches. Thus, the programmers do not need to focus
on the details such as hardware and resource constraints of these
tables across the target switches. Lyra can also generate a set of
‚Äúempty‚Äù control-plane programs for each table. For example, Lyra
also generates ‚Äúempty‚Äù Python functions (e.g., conn_table_entry_
set(key, value) and conn_table_entry_get(key)) for the pro-
grammers to easily add the code manipulating table entries. In other
words, Lyra generates P4 or NPL tables according to what the Lyra
program specifies, and these tables play a role as the ‚Äúinterfaces‚Äù
between control plane code and the synthesized data plane code.
6 OPTIMIZATION
We further propose a collection of optimization techniques to im-
prove the efficiency and resource usage, such as reducing the num-
ber of generated P4 tables and optimizing the results via diverse
metrics. Due to limited space, please see Appendix C for details.
7 EVALUATION
We have built Lyra with 7,000 lines of Python code. Lyra relies on
Z3 [18] for SMT solving. Lyra compiler can compile P414 and P416
for Tofino, and NPL for Trident-4.
Our evaluation aims to answer whether Lyra can successfully
offer portability (¬ß7.1), extensibility (¬ß7.2), and composition (¬ß7.3).
The target network for our evaluation is a fat-tree data-center
testbed consisting of eight servers and ten programmable switches:
four ToR switches (Tofino), four Agg switches (Trident-4), and
two Core switches (Tofino). All compilations were conducted on a
desktop with Intel Core i7 3.7GHz 6-core CPU and 16GiB RAM.
7.1 Portability
To evaluate the portability, we wrote Lyra programs for the state-of-
the-art network algorithms (e.g., NetCache [25], and NetChain [24]
and INT [2]), and then evaluated whether these Lyra programs can
generate P4 and NPL code runnable on Tofino and Trident-4. The
Tofino constraint is encoded according to the RMT architecture.
Figure 9 shows the comparison between our compiled chip-
specific code with the manually-written P414 code. We evaluated
Lyra in two aspects. (1) Lines of Codes: in Figure 9, LoC is the total
LoC and Logic LoC is the code ignoring the header and parser be-
cause this is a better metric to show the labor on writing a program.
(2) Resource usage: for P4, we compare the total number of tables,
actions, and registers used. For NPL, we show the number of logical
ProgramP414LyraLoC /Logic LoCTablesActionsRegistersLyra LoC / Logic LoCSynthesized P414Synthesized NPLLyraCompile TimeTablesActionsRegistersLyraCompile TimeTablesRegistersLongestCode PathIngress INT308/99980207/620.987s8700.78s409Transit INT275/66660193/460.914s5500.72s204Egress INT282/73770197/470.897s6600.73s204Speedlight453/35121236194/971.352s162060.95s9618NetCache1137/937969640372/1531.909s1214401.17s34020NetChain319/21116162177/731.530s131620.85s6218NetPaxos241/1406115150/691.158s61150.84s354flowlet_switching195/130872113/430.91s8720.70s4212simple_router101/6644072/310.852s4400.67s3010switch4924/387613136304151/256333.6s131363019.4s125053tables and logical registers, and the length of the longest code path.
All our generated code can compile on the corresponding ASICs.
First, as shown in Figure 9, Lyra can dramatically reduce the total
line of codes to implement a program. It, for example, takes only
22% of LoC to implement the logic component of NetCache [25].
This shows Lyra language can describe the program more concisely.
Second, by comparing with programs written by researchers and
engineers (e.g., NetCache, Speedlight, and INT), Lyra can reduce the
total number of tables and actions. This means we can reduce the
resource occupation in the switch. For example, we observed that
manually-written NetCache and SpeedLight programs have more
tables than the Lyra-generated ones, because the manually-written
version kept many independent tables for modularity, but Lyra
merged these independent tables into a single table.
if (nc_hdr.op == NC_READ_REQUEST) {
apply (check_cache_valid);
} else if (nc_hdr.op == NC_UPDATE_REPLY)
apply (set_cache_valid);
In the above code in the NetCache program, check_cache_valid
and set_cache_valid have no match field and only one action.
Lyra merged the tables with match field nc_hdr.op. Note that Net-
Cache is the only program for which Lyra can save 87.5% hardware
resources. For the rest of the programs, e.g., Speedlight and INT,
Lyra can save 10% ‚Äì 23% resources. For the programs posted on the
p4c [5] project, e.g., switch.p4, Lyra generates an equal P4 code.
In our experience, whether the manually-written ASIC code (e.g.,
P4 or NPL) is optimal or not totally depends on the expertise and
knowledge of the programmers. If the program is simple or the
programmer is knowledgeable enough, it is highly possible the
written code is optimal, i.e., no more resource saved by Lyra. If the
program is already optimized, Lyra can perform the same. However,
in order to write an optimized code, even the most knowledgable
programmer may need to spend tons of time and effort; on the
contrary, Lyra can reduce these efforts and burdens, so that the
programmer only needs to focus on implementing the logic itself.
7.2 Extensibility
To evaluate the extensibility, we conducted a real-world case study
similar to LB example in ¬ß2.1. Initially, we set the size of both Con-
nTable and VIPTable to one million entries, so that these two tables
can be put in the same aggregation switch. Both Tofino and Trident-
4 ASICs can hold about three million entries at most. After we
increased the size of ConnTable to 2.5 million and 4 million entries,
respectively, Lyra can intelligently generate the response solutions.
For example, if we set ConnTable‚Äôs size to 4 million entries, Lyra
generates an NPL-version ConnTable program with 2.5 million en-
tries on each aggregation switch, and a P4-version ConnTable and
VIPTable programs holding 1.5 and 1 million entries, respectively,
on each ToR switch. Lyra also generates a function that passes the
entry hit information between switches to lookup the ConnTable
on ToRs, if the ConnTable on aggregation switches misses. This en-
sures the generated distributed programs work correctly. Compared
with manually-written programs, Lyra compiles the programs for
the above two updates less than 10 seconds, which only needed the
programmer to change the size of the external variable ConnTable
in the Lyra program; on the contrary, our well-trained programmer
needed about 1.5 days to write these programs manually.
SIGCOMM ‚Äô20, August 10‚Äì14, 2020, Virtual Event, NY, USA
Figure 10: The scalability for extensibility.
Scalability. In general, the complexity of Lyra is related to the
size of the topology, the length, and resources used by the Lyra
program. To evaluate the scalability, we deployed NetCache and
stateful LB on a pod of a simulated fat tree DCN. For the LB, we set
all the switches in the pod as the scope, which means they serve
together as a single LB. For NetCache, we deployed it in two modes,
one in PER-SW mode, which means each switch has its own copy
of the program; one in MULTI-SW mode, which is the same as the
LB. We evaluated two ASICs: Tofino with the P4 and Trident-4
with the NPL, and changed the topology size by varying ùëò = 4
to ùëò = 32, where ùëò is the number of ports per switch and also
equals to the total number of switches deployed. Figure 10 shows
the result. As the topology size increases, we observe that both the
MULTI-SW algorithms compilation time increases, but Lyra is still
able to find a solution in less than 100 seconds, even in the largest
topology. For PER-SW mode NetCache, the compilation time stays
the same, because all the switches have the same program and Lyra
can generate the program for each switch in parallel. By comparing
two MULTI-SW mode algorithms, we see that the complexity of
language and ASIC matters a lot: Lyra generates NPL/Trident-4
programs 2√ó faster than P4/Tofino programs, as NPL synthesizing
needs no predicate block construction process and has shorter SMT
formulas due to language complexity.
7.3 Composition
To evaluate composition, we attempted to deploy multiple algo-
rithms into our testbed by changing the scope from eight switches
to only one switch. For the scope, smaller is more challenging,
since it evaluates whether Lyra can handle resource constraints in
the code composition. First, we wrote a Lyra program including
a classifier, firewall, gateway, LB, and scheduler, which is similar
to Dejavu [40]. Then, we compiled the Lyra program by gradually
changing the scope from the entire network to a single switch.
For either case (the entire network and single switch), Lyra spent
less than five seconds to generate P414 program that successfully
compiles on the Tofino ASIC. We also asked the programmers to
manually write a program for this goal manually. It took them about
two days (10000√ó more time than using Lyra) to compress these
programs into a single ASIC.
Lyra independently generates chip-specific code for each algo-
rithm. For example, all the generated variables and tables for al-
gorithm firewall are assigned the same prefix-name firewall. Thus,
there is no shared program-level resource between generated code.
8 DISCUSSION
This section discusses Lyra‚Äôs implementation details and limitations.
More discussions can be found in Appendix D.
Does the synthesized code always compile? It is possible that
the synthesized chip code unsuccessfully compiles on the target
 1 10 100 4 8 16 24 32Compile Time (seconds)Number of Switches DeployedLoad Balancer (MULTI-SW) TofinoNetCache (PER-SW) TofinoNetCache (MULTI-SW) Tofino Trident-4 Trident-4 Trident-4SIGCOMM ‚Äô20, August 10‚Äì14, 2020, Virtual Event, NY, USA
Gao et al.
ASICs, if some of the constraints are missing from the Lyra compiler.
For example, egress timestamp must be collected in the egress
pipeline; otherwise, the synthesized P4 code cannot compile on
Tofino ASIC or is meaningless. In Lyra, we manually check and
encode ASIC‚Äôs resource constraints based on the ASIC specifications
provided by the chip vendors. By far, while we are not aware of
any ‚Äúconstraint missing‚Äù cases, we cannot exclude such a possibility.
Thus, we offer an encoding template for the programmers to encode
the missed constraints as a plug-in patch for Lyra.
Recirculation. P4 supports recirculation and resubmission, which
allows the packet to go through the pipeline one more time. In Lyra,
the programmers need to explicitly define the recirculation, as there
is no switch concept in Lyra. Instead, Lyra uses the recirculation as
an optimization method to pack a longer program into one switch.
Copy-to-cpu. Both P4 and NPL support sending a copy of the cur-
rent packet to the switch‚Äôs CPU but in different ways. Lyra provides
a uniformed API called copy_to_cpu() to enable such a function.
This API is translated into the corresponding APIs in different lan-
guages. Similar to the control plane interface, the programmer only
needs to focus on what to do with the copied packet, rather than
taking care of which switch the packet is copied at.
Multi-pipeline support. Programmable ASICs use multiple iden-
tical pipelines to increase the throughput. For example, the Tofino
64Q model has 4 pipelines. The program deployed on each pipeline
thus is typically the same. Lyra allows the programmer to individ-
ually specify each pipeline via our OBP abstraction. Furthermore,
switches, e.g., RMT, split one above-mentioned pipeline into two:
ingress pipeline and egress pipeline. Different from the pipeline
mentioned above, these two pipelines have different capabilities:
the programmer can only designate the egress port at the ingress
pipeline because the egress pipeline is directly connected to the
physical port and cannot re-direct the packet; all the queuing infor-
mation (e.g., queue length and queuing time) must be gathered in
the egress pipeline as the queuing buffer sits between the ingress
and egress pipeline. Lyra models the two pipelines as two individual
switches and connects them via a link. Next, Lyra adds constraints
that the pipeline exclusive statements cannot be deployed in the
other pipeline. The SMT solver then allocates the statements.
Synthesizing incremental changes. Since Lyra relies on an SMT
solver to generate a feasible allocation solution, a potential chal-
lenge is an incremental change in the Lyra program may result in
a significantly different allocation plan. This may cause difficulty
in debugging or upgrading the network in practice. Currently, if
the changes are small (e.g., few lines of code), our programmers
manually modify the chip code, because such modifications may
not violate resource constraints; if the changes are significant, we
directly re-run Lyra to generate the chip code from scratch.
Unifying different ASIC libraries. Given that the programmable
ASICs from different vendors offer different chip-specific libraries,
in Lyra compiler, we hard-code a collection of functions converting
these libraries into common IR. See Appendix D for more details.
9 RELATED WORK
Abstractions for forwarding packets. Software-defined network-
ing (SDN) allows the network operators to specify the packet for-