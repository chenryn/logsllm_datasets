T/16的消息系统实际上是一个独立的网络。通过把消息系统扩展到
全世界，Guardian就可能很好地提供大范围的网络。这种实现称为
EXPAND。
从程序员的观点来看，EXPAND几乎是完全无缝的。它可以连接多
达255个系统。
1.系统名字
每个系统都有一个以反斜线符号开头的名字，例如ESSG或
FOXII，加上一个节点号。节点号不像现在的IP地址那么易懂：从
程序员的角度来看，仅仅为了给文件名编码才必须需要它们，随后
我们将看到它们。
EXPAND是消息系统的一个扩展，所以，大部分细节对程序员都是
隐藏的。唯一的问题在于速度和存取需求之间的不同。
2.FOX
完全由于实际的约束，构建一个拥有多于16个CPU的系统是困难
的；特别是硬件的约束把处理器间总线的长度限制到只有几米，所
以，实际的限制是16个CPU。除此之外，Tandem提供一种把多达14
个系统连在一起就像本地集群一样的快速光纤连接能力。在许多方
面，这是一个更高速度的EXPAND版本。
8.9文件系统
Tandem使用术语“文件系统"来表示这种可以提供数据（“读”）或接
受数据（“写”）的对系统资源的存取方式。除磁盘文件之外，文件
系统也处理设备，例如终端、打印机、磁带单元，还处理进程（进
程间通信）。
8.9.1文件命名
设备、磁盘文件和进程有一个通用的命名规则，但是很遗憾，由于
有许多例外，这个规则有点复杂。进程可以拥有名字，但只有I/O进
程和进程对才必须拥有名字。不管怎样，文件“名字"的长度为24个
1084
---
## Page 1086
字符，由分别为8字节的3个部分组成。只有第一部分是必需的；其
他两个部分只用于磁盘文件和指定的进程。
没有命名的进程只使用名字的前8个字节。未配对的系统进程（例
如监视器或内存管理器）的命名格式如图8-7所示。
CPU
PIN
0
1
2
.
图8-7：未配对系统进程的命名格式
未配对用户进程的命名格式如图8-7所示。
m
CPU
PIN
0
1
2
6
图8-8：未配对用户进程的命名格式
CPU和PIN组合在一起形成了进程ID或PID。PIN是CPU内部的进程标
识号。这就限制了每个CPU最多拥有256个进程。
真正的名字以一个"$"符号开始。设备只使用前8个字节，而磁盘文
件使用全部的三个部分。单个部分看起来像是磁盘名、目录和文
件，虽然实际上每个磁盘只有一个目录。进程可以把其他两个部分
用来相互传递信息。
表8-2中列出了一些典型的文件名字。
表8-2：典型的文件名字
STAPE
磁带驱动
SLP
打印机
$SPLS
打印缓冲进程
STERM15
终端设备
SSYSTEM
系统磁盘
SSYSTEM SYSTEMLOGFILE
SSYSTEM磁盘上的系统日志文件
SSPLS #DEFAULT
默认的打印缓冲队列
SRECEIVE
进来的消息队列，用于进程间通信
1085
---
## Page 1087
如果名字的某一部分的长度少于8个字节，就会用ASCI的空格填
补。从外表来看，名字表示为有句点的ASCII字符，例如
$SYSTEM.SYSTEM.LOGFILE和$SPLS.#DEFAULT。
在命名规则中还有较多的约定。进程的子名称必须以并号（#）开
始，而用户进程的名字（不包括设备的名字，它是实际的I/O进程的
名字）在第一部分的最后有PID（如图8-9所示）。
S!SIP
CPUPIN
+
5
图8-9：指定用户进程的命名格式
这个例子中的PID是主进程的PID。这样就把用户进程名的长度限制
到6个字符，包括起始的S。
这样似乎还不够，对于远程系统上指派的进程、磁盘文件或设备还
有一组单独的命名。在这种情况下，起始的"$"符号替换为""符
号，名字的第二个字节是系统号码，把名字的其余部分向右移一个
字节。这样，如果一个进程是网络可见的，那么，该进程的名字的
长度将限制为最多5个字符。所以，从另一个系统来看，我们先前
看到的打印缓冲进程将拥有ESSG.SSPLS这个外部名称，内部的格
式如图8-10所示。
I73SPLSCPUPIN
0123
6
7
图8-10：网络可见进程的命名格式
数字173是系统ESSG的节点数。
8.9.2异步1O
文件系统接口的重要特性之一是强调异步I/O。我们已经知道消息系
统本质上是异步的，所以，这实现起来相对简单。
进程在打开一个文件的时候可以选择同步的或异步（“不等待”）的
IO。当以不等待的方式打并一个文件时，这个I/O请求会立即反
1086
---
## Page 1088
馈，只有一些显而易见的错误会报告出来，例如，如果这个文件描
述符是不公开的。随后，用户调用awaitio来检查该请求的状态。这
引起这样一种编程方式：一个进程发起许多不等待的请求，然后进
入调用awaitio的中心循环并处理完成的请求，典型的是发起一个新
的请求。
8.9.3进程间通信
在文件系统级别，进程间通信是到消息系统的一个相对直接的接
口。这引起一个问题：消息系统是不对等的。请求者发送一个消息
并可能接收一个响应。响应文件系统的一个read命令是没有意义
的。在服务器端，服务器读取一个消息并响应它；响应一个write命
令也没有意义。
文件系统提供读和写的过程，但是读的过程只对I/O进程起作用，把
它们映射到消息系统的请求。在进程间通信级别，读过程没有用，
而且，实际上，写过程也用得不多。请求者改为调用一个名为
writeread的过程先写一个消息传给服务器，然后从服务器获得一个
响应。消息或响应都可以为空（长度为0）。
这些消息到达服务器的消息队列。在文件服务器级别，消息队列是
一个名为$RECEIVE的伪文件。服务器打开SRECEIVE并通常使用
readupdate过程来读取一个消息。随后，它可以用reply过程进行响
应。
8.9.4系统消息
系统使用sRECEIVE把消息传给进程。最重要的消息之一是startup消
息，它把参数传给新启动的进程。下面的例子是用TAL编写的，
TAL是Tandem的低级别系统编程语言（虽然这个名字表示"Tandem
ApplicationLanguage"）。TAL源自于HP的SPL，而且它类似于Pascal
和Algol。它的最不寻常的特征之一是在标识符中使用脱字符号
（^）；下划线字符（_）是不允许使用的。这个例子应该和C非常
相似，并很容易理解。它展示了这样一个进程：启动一个子服务器
进程，然后和它通信。
第一部分代码展示了父进程（请求者）：
1087
---
## Page 1089
call newprocess (program^file^name, process^name) : -start
the server process
call writeread (process^fd,startup^message, 66) : -write
startup message
while 1  do
begin
read data from terminal
call writeread (process^fd,
data, data^length, write data
 x
@reply^length) : -return real reply length
if reply^length>0
write data back to terminal
end:
接下来的代码展示了子进程（服务器）：
call open (receive,receive^fd) :
do
until startup^message=-l; -first word of startup message
i s-1 .
while 1 do
begin
Ca11
readupdate (receive^fd,message, read^count, count^read) ;
1088
---
## Page 1090
process message received, replacing buffer contents
call reply (message,reply^length) ;
end:
子进程接收到最初的消息是系统消息：子进程的父进程open给子进
程发送了一个open消息，然后，最初的writeread调用发送了启动的
消息。子进程处理这些消息并响应它们。它可以使用这个open消息
来记录请求者或接收这个文件名最后的16个字节所传过来的信息。
只有这时候这个进程才从它的父进程接收正常的消息。这时候，其
他进程也可以和这个子进程通信。同样地，当一个请求者关闭服务
器时，服务器收到一个close的系统消息。
8.9.5设备I/O
记住这很重要：设备I/O（包括磁盘文件I/O）都由I/O进程处理，所
以，“打开一个设备”实际上是打开了IO进程。还要记住，到设备的
IO和到文件的I/O的实现稍微有些不同，虽然文件系统的过程都一
样。特别地，典型的用于访问文件的程序是比较常规的读和写，而
通常的磁盘IO不是“不等待”的。
8.9.6安全
为了使时间一致，T/16不是一个绝对安全的系统。实际上，这没有