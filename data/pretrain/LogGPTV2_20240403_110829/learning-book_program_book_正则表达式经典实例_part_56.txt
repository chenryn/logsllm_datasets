## Page 303
(?。它会使正则表达式在你要查找的两个目标
单词之间匹配尽量少的单词。如果你使用目标文本word1word2word2来执行这个正则
表达式，那么它会匹配到的是word1word2，因为在这个子事中两个自标单词之间包含
了最少的（0个）单词。如果想要对目标单词之间允许的距离进行配置，那么可以把在
两个量词中的0和5修改为你想要的取值。例如，如果你把它们修改为{1，15}？>，那
么就会充许在你要查找的两个单词之间出现最多15个单词，同时要求它们之间必须有
一个其他单词作为分隔。
这里用来匹配单词字符和非单词字符的简写字符类（分别是（w>和wordl) 1(?word2))\W+(?:\w+\W+) (0, 5}?(?(w2)(?&w1) 1(?&w2))\b
正则选项：无
正则流派：PCRE7、Per15.10
在这里采用了命名捕获分组（语法是（?)））来把（word1>和（word2>的第一
个实例括了起来。这样就允许你使用子例程（subroutine）语法（?&name））来复用通
过名称来指定的子模式。这与到一个命名分组的向后引用是不一样的。命名向后引
用的格式是k）（.NET、PCRE7和Perl5.10）或(word1） 1(word2） 1(word3）1(？(1) 1（？(2) 1(？(3) 1(？!)））)\w+)\b\w*2){3
,81 
(?(1) (?(2) (?(3) 1(?!)) 1(?!))1(?!))
正则选项：不区分大小写
正则流派：.NET、PCRE、Perl
下面这个正则式把上面的原子分组（参见实例2.14）替换为了标准的非捕获分组，从
而添加了对Python的支持：
\b（？:(?: (word1) 1(word2) 1(word3) 1(?(1) 1(?(2) 1(?(3) 1(？!))))\w+)\b\w*？) {3, 8}
(? (1)(?(2)(?(3) 1(?!)) 1(?!)) 1(?!))
正则选项：不区分大小写
正则流派：.NET、PCRE、Perl、Python
单词、文本行和特殊字符289
www.TopSage.com
---
## Page 306
2个值：
[12,21}
=2种可能排列
3个值：
[123, 132,
213, 231,
312, 321 ]
=6种可能排列
4个值：
[1234, 1243, 1324, 1342, 1423, 1432,
2134, 2143, 2314, 2341, 2413, 2432,
3124, 3142,3214,3241,3412,3421,
4123, 4132, 4213, 4231, 4312, 4321 ]
=24种可能排列
阶乘：
2!=2× 1
=
2
3!=3×2×1
6
4!=4×3×2×1
2 4
5!=5×4×3×2×1
120
10!=10×9×8×7×6×5×4×3×2x1
=3628800
图5-2一个集合可能会存在多种排列方式
在这个正则表达式中的量词（{3，8}>要求必须出现3个目标单词，因此允许在它们之
间出现0～5个单词。空的否定型顺序环视（（?!)）永远都不可能产生匹配，因此
被用来阻塞正则表达式中的某些特定路径，直到一个或多个目标单词被匹配到为
止。控制这些路径的逻辑使用两个嵌套条件判断的集合来实现。第一个集合避免会
在至少-一个目标单词被匹配之前使用。而在结尾处的第二个条件判断集合则
会强制要求正则引擎在所有要求的目标单词都被匹配到之前，只能进行回溯，或者
宣告匹配失败。
上面给出的只是对其中的基本工作原理的简单介绍，与其进一步深人了解如何添加更
多的目标单词，我们先来看下面这个改进的实现，其中添加了对更多正则流派的支持，
并且涉及了一个小技巧。
利用空的向后引用。上面给的难看的解决方案虽然也是可以工作的，但是由于它非常
难于理解和管理，所以拿出去或许可以赢得一场正则式猜谜大赛。如果你在其中添加
更多的目标单词，那么只会把它变得更糟。
幸运的是，还有一个正则表达式技巧可以用来使之较为容易理解，同时还可以添加对
Java和Ruby（二者都不支持条件判断）的支持。
290
第5章
www.TopSage.com
---
## Page 307
警告
如果要把在这个小节中解释的行为真正应用于产品中，一定要非常小
心。我们在这里使用的正则表达式行为在大多数正则函数库中都是找
不到的。
\b(？:(?>word1() 1word2()|word3()I(?>\1/\21\3)\w+)\b\w*?){3, 8}\1\2\3
正则选项：不区分大小写
正则流派：.NET、Java、PCRE、Perl、Ruby
\b(？:(?:word1() 1word2() Iword3()I(？:\11\2{\3)\w+)\b\w*？){3, 8)\1\2\3
正则选项：不区分大小写
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
使用上述结构，就可以很容易添加更多的目标单词。下面的例子充许4个自标单词以
任意顺序出现，并且在它们之间可以包含最多5个其他单词：
\b(?:(?>word1() |word2() [word3()(word4() I
6（（+（11）就一定会失
败，这样就可以使用对空分组的向后引用来控制正则引擎在一个模式中所选取的路径，
它的功能与我们在前面所给的更加晦湿的条件判断是非常类似的。如果在正则引擎到
达一个向后引用的时候，与之对应的分组已经参与了匹配尝试，那么它就会匹配一个
空事，然后继续执行。
在这里的\1/2/3)分组会避免在至少匹配一个目标单词之前使用来匹配单
词。在模式结尾处的向后引用会被董复执行，从而直到所有必需的目标单词都被找到
之后，匹配才能成功完成。
Python不支持原子分组，因此上面把Python列在正则流派中的示例里，又一次把原
子分组替换为了标准的非捕获分组。虽然这样会使正则式的效率有所降低，但是它
不会改变匹配的结果。最外层的分组在任意流派中都不能是原子的，因为要想能够
达到目标，如果在模式最后的向后引用匹配失败，那幺正则引擎必须能够回溯到外
层分组中。
按照JavaScript规则的向后引I用。虽然JavaScript支持在这个模式的Python版本中
使用的所有语法，但是它包含的两条行为规则会使这个技巧无法像在其他流派中一
样工作。第一个问题是指向还没有参与匹配的捕获分组的向后引用会匹配到什么内
单词、文本行和特殊字符291
www.TopSage.com
---
## Page 308
容。JavaScript规范中说明这样的向后引用会匹配到空字符串，或者换句话说，它们