# Detecting Passive Content Leaks and Pollution in Android Applications

**Authors:**
- Yajin Zhou
- Xuxian Jiang

**Affiliation:**
- Department of Computer Science
- North Carolina State University

**Contact:**
- yajin@ncsu.edu
- xjiang@ncsu.edu

## Abstract
In this paper, we systematically investigate two vulnerabilities present in existing Android applications (or "apps"). These vulnerabilities stem from an unprotected Android component, the content provider, within vulnerable apps. Due to the lack of necessary access control enforcement, affected apps can be exploited to either passively disclose various types of private in-app data or inadvertently manipulate certain security-sensitive in-app settings or configurations, potentially causing serious system-wide side effects (e.g., blocking all incoming phone calls or SMS messages). To assess the prevalence of these vulnerabilities, we analyzed 62,519 apps collected in February 2012 from various Android markets. Our results show that 1,279 (2.0%) and 871 (1.4%) of these apps are susceptible to the passive content leak and content pollution vulnerabilities, respectively. Additionally, 435 (0.7%) and 398 (0.6%) of the vulnerable apps are available on the official Google Play, with some having over 10 million downloads. The presence of a large number of vulnerable apps in popular Android markets, along with the variety of private data at risk, underscores the severity of these vulnerabilities. We also explore and examine possible mitigation solutions.

## 1. Introduction
Smartphones are becoming increasingly popular. According to a recent Gartner report [3], worldwide smartphone sales increased by 47% in the fourth quarter of 2011. Google's Android has become the market leader, accounting for more than 50% of smartphones shipped. Mobile platform vendors and other stakeholders have created centralized marketplaces or app stores to streamline the distribution of mobile applications. As a result, the total number of apps available for download is substantial. For instance, as of September 2012, there were approximately 675,000 and 700,000 apps available on Google Play [4] and the Apple App Store [2], respectively.

In this paper, we present a systematic study of two vulnerabilities present in a large number of Android apps. Both vulnerabilities arise from a built-in Android component, the content provider, which is accessible by default to all running apps on the phone, including untrusted ones. Due to this open access, the content provider can be exploited to passively disclose various types of private in-app data and inadvertently manipulate security-sensitive in-app settings or configurations, potentially causing serious system-wide side effects (e.g., blocking all incoming phone calls or SMS messages).

To elaborate, the first vulnerability, known as a passive content leak, causes affected apps to passively disclose private in-app data. This differs from previous findings about legitimate apps (e.g., Pandora [9]) and in-app advertisement libraries [26] that may actively leak private information. Our study shows that the passive content leak vulnerability affects a significant number of mobile apps in current Android markets, including the official Google Play. Among the 62,519 Android apps we collected from various Android markets in February 2012, 2.0% suffer from this vulnerability. These vulnerable apps include popular mobile browsers, widely-used instant messengers (IMs), social network apps, and even some popular mobile security apps.

The second vulnerability, known as content pollution, can be leveraged to manipulate certain in-app data managed by these vulnerable apps. The manipulated data can include security-sensitive settings (e.g., firewall rules or job lists) that are enforced or executed by affected apps. This can cause undesirable side effects, such as allowing or denying certain phone calls and SMS messages from specific numbers chosen by attackers. Our study shows that this vulnerability is also widely present in real-world apps. Among the same set of 62,519 apps, 1.4% are affected by this vulnerability.

To systematically assess the prevalence of these vulnerabilities, we designed and implemented a tool called ContentScope. Our tool examines a given app to check if it exposes public content provider interfaces (represented as start functions). If so, it locates the Android functions or routines that operate on internal databases with private data (denoted as terminal functions). The tool then performs path-sensitive data-flow analysis along execution paths from start functions to terminal functions, automatically deriving necessary constraints and preparing appropriate inputs to evaluate the presence of content leakage or pollution vulnerabilities. These inputs are dynamically fed into the app on a real phone for confirmation.

We applied the ContentScope tool to 62,519 apps collected in February 2012 from various Android markets, including the official Google Play. Using the tool, we detected 1,456 vulnerable apps (or 2.3% of our dataset). Specifically, 1,279 apps (or 2.0%) suffer from passive content leaks, 871 apps (or 1.4%) are susceptible to content pollution, and 694 apps (or 1.1%) contain both vulnerabilities. Among these vulnerable apps, 435 (0.7%) and 398 (0.6%) were downloaded from the official Google Play.

After identifying these vulnerable apps, we further performed a breakdown to better understand them. By analyzing apps with passive content leaks, we aimed to understand the types of personal information that may be passively leaked. Our results show that the relevant personal information includes, but is not limited to, (1) incoming and/or outgoing SMS messages (268 apps); (2) contacts stored in the phone (128 apps); (3) conversations in popular IMs such as MSN (121 apps); (4) user credentials such as usernames, passwords, and authentication tokens for popular social networks like Facebook and Twitter (80 apps); (5) browser history and bookmarks (70 apps); and (6) incoming and/or outgoing phone call logs (61 apps). These vulnerable apps include popular mobile browsers, widely-used instant messengers (IMs) and social network apps, and even mobile security apps.

Similarly, when analyzing apps with the content pollution vulnerability, we aimed to understand possible side effects. Our results show that by polluting internal databases, we could effectively manipulate certain blacklists or whitelists (for outgoing/incoming phone calls and SMS messages) maintained by vulnerable apps. In other words, security-sensitive settings (such as firewall rules) can be arbitrarily changed by any app on the phone without permission. Our results further show that some vulnerable apps can be exploited to download additional unwanted apps (and other arbitrary types of files) from remote servers in the background without the user's awareness. (The downloaded app can later be automatically triggered for installation, albeit with user approval.)

Among the detected vulnerable apps, some are extremely popular, having been downloaded from Google Play more than 10 million times. Since February 2012, we have been actively reporting our findings to the corresponding developers. Some developers have taken our reports seriously and immediately followed our suggestions to fix their apps. However, we have also experienced difficulties in communicating with other developers, either due to the inability to find valid contact information or a lack of response to our reports.

Several recent works [15, 17, 19, 20, 27] have also examined potential risks and implications from unprotected interfaces of Android apps. However, our work differs by focusing exclusively on the open content provider interface of Android apps and studying potential risks that may lead to passive privacy leakage and unintended manipulation of security-sensitive data. To the best of our knowledge, our paper is the first to systematically study these issues and quantitatively report the prevalence of affected apps.

The rest of this paper is organized as follows: In Section 2, we elaborate on the threat model and assumptions of this work. We then present the overall system design in Section 3, followed by its implementation details in Section 4. After that, we report the evaluation results in Section 5. We also discuss possible solutions and improvements in Section 6. Finally, we describe related work in Section 7 and conclude the paper in Section 8.

## 2. Threat Model and Assumptions
In this paper, we assume the following adversary model. To launch the above-mentioned passive content leaks and/or pollution attacks, a malicious app needs to be installed on the same smartphone as the vulnerable app. After installation, we do not assume the malicious app will request any dangerous permissions to launch the attack. Even so, the malicious app can manage to obtain private or confidential data (such as contacts, SMS messages, or browser histories) maintained by vulnerable apps. Further, the malicious app can potentially manipulate certain in-app data that could be part of security settings or configurations, introducing unintended side effects in the running system. We note that to transport the stolen private data to a remote server under the attacker's control, the malicious app does need the corresponding INTERNET permission.

## 3. Design
To analyze these two vulnerabilities and assess their prevalence in existing apps, we designed the ContentScope system to scalably and accurately examine a large number of apps from existing Android markets. Specifically, we consider a passive content leak to occur when an app does not properly protect its internal (private) database and allows it to be freely accessible to any running apps. Similarly, content pollution happens if any app without necessary authorization or permission can manipulate another appâ€™s internal database or settings, which can be security-sensitive.

In Figure 1, we show the overall architecture of the ContentScope system, which involves several steps to determine vulnerable apps. The first step is to select candidate apps that may potentially be susceptible to these two vulnerabilities. For that purpose, we extract essential vulnerability characteristics to significantly reduce the number of apps that need to be subsequently examined. In other words, the selected candidate apps are expected to be a small portion of all existing apps. After that, the second step is to analyze candidate apps and determine whether they are indeed vulnerable. Finally, to further assess the threat level of these vulnerable apps, we examine them and present a breakdown on the types of leaked or polluted content as well as the associated side effects. In the following, we illustrate each step in detail.

### 3.1 Candidate App Selection
To select candidate apps, our strategy is to extract essential characteristics of these two vulnerabilities. Specifically, these two vulnerabilities share a similar nature of having an exploitable content provider interface. Note that the content provider interface in Android is designed to concisely encapsulate a structured set of local data (typically in the form of SQLite databases) while providing necessary mechanisms to regulate the accesses to encapsulated data. By default, this interface is open so that any app can leverage it to communicate with each other. Meanwhile, an app can protect its interface by (1) setting the `exported` property to `false` in its manifest file (or more precisely, `AndroidManifest.xml`) to ensure that the interface is only available to itself or others with the same user ID, or (2) defining custom permissions to expose them only to apps that are granted these custom permissions. Each (custom) permission has a protection level, which determines how dangerous the permission is and the way this permission can be granted to other apps. A certain protection level (i.e., `signatureOrSystem`) is reserved for pre-loaded apps in the phone firmware, while others (i.e., `normal`, `dangerous`, and `signature`) can be requested by third-party apps. If there is no protection level specified for a custom permission, the default protection level `normal` will be used.

In this paper, we focus on existing third-party apps available in various Android markets. Therefore, we mainly target custom permissions with `normal`, `dangerous`, and `signature` protection levels. It is important to note that for a permission at the `normal` protection level, any app can request it, and the Android runtime will automatically grant access without asking for the user's explicit approval. This differs from permissions at the `dangerous` level, which demand explicit approval from users, or at the `signature` level, which require apps to be signed with the same developer key.

In Figure 2, we show a manifest file that defines a content provider named `ExampleProvider`. Because it does not specify the `exported` property explicitly, this content provider is open to all apps on the phone by default. The app defines a custom permission `com.example.app.permission` to protect this content provider. However, the `protectionLevel` property of this custom permission is `normal`, meaning this permission will be automatically granted to any app that requests it.

Accordingly, to locate candidate apps, our system first parses their manifest files to determine whether any content provider component is defined. If yes, we extract the corresponding attributes. The first attribute is the `exported` property, which specifies whether the content provider is accessible by other apps. (If it is not defined, the default `true` value is assumed, meaning any app can access it.) The second attribute is to detect the presence of any custom permissions to regulate read or write accesses to the content provider. Specifically, there are three closely-related attributes: `readPermission`, `writePermission`, and `permission`. The `readPermission` and `writePermission` explicitly specify the respective permissions used to query and make changes to the data managed by the content provider. If they are missing, the `permission` attribute will be used.

In other words, our system chooses those apps as candidates if they explicitly export a content provider by setting `true` in its `exported` attribute or implicitly export this interface without specifying this attribute. Additionally, our system also selects those apps that may have custom permissions but with the corresponding protection level(s) not defined or defined at the `normal` level. For bookkeeping purposes, we further extract other attributes of the content provider component from these candidate apps, including the `name` property, which specifies the specific class implementing the content provider interface, and `authorities`, which is used by the Android runtime to locate the content provider itself. All these relevant attributes are collected along with the app information and saved into a local database for subsequent analysis.

### 3.2 Vulnerable App Determination
After selecting candidate apps, our next step is to analyze them to locate vulnerable ones. To effectively manage a structured set of data in a local SQLite database, the Android framework provides well-defined APIs to ease the creation and maintenance of content providers. Specifically, these APIs are provided in several system-wide classes, including `SQLiteDatabase` (which contains methods to create, delete, and execute SQL commands) and `SQLiteQueryBuilder` (which helps build SQL queries). In other words, content providers can leverage these methods to implement their own standardized APIs that can be invoked to query and make changes to records in local databases. To simplify our discussion, we call these Android APIs that actually manipulate local databases "terminal functions."

From another perspective, the content provider component essentially encapsulates local content and exports them.