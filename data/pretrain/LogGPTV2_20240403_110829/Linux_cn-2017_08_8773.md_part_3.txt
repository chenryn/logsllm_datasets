分布式系统需要通过消息在网络上传输进行交流，以实现其沟通基础，与之相反，事件的发出则是本地的。在底层通过发送包裹着事件的消息来搭建跨网络的事件驱动系统的做法很常见。这样能够维持在分布式环境下事件驱动编程模型的相对简易性，并且在某些特殊的和合理的范围内的使用案例上工作得很好。
然而，这是有利有弊的：在编程模型的抽象性和简易性上得一分，在控制上就减一分。消息强迫我们去拥抱分布式系统的真实性和一致性——像 局部错误   （    partial failures    ） ， 错误侦测   （    failure detection    ） ， 丢弃/复制/重排序   （    dropped/duplicated/reordered    ） 消息，最后还有一致性，管理多个并发真实性等等——然后直面它们，去处理它们，而不是像过去无数次一样，藏在一个蹩脚的抽象面罩后——假装网络并不存在(例如EJB、 [RPC](https://christophermeiklejohn.com/pl/2016/04/12/rpc.html)、 [CORBA](https://queue.acm.org/detail.cfm?id=1142044) 和 [XA](https://cs.brown.edu/courses/cs227/archives/2012/papers/weaker/cidr07p15.pdf))。
这些在语义学和适用性上的不同在应用设计中有着深刻的含义，包括分布式系统的 复杂性   （    complexity    ） 中的  弹性   （    resilience    ） 、  韧性   （    elasticity    ） 、 移动性   （    mobility    ） 、 位置透明性   （    location transparency    ） 和  管理   （    management    ） ，这些在文章后面再进行介绍。
在一个响应式系统中，特别是使用了响应式编程技术的，这样的系统中就即有事件也有消息——一个是用于沟通的强大工具（消息），而另一个则呈现现实（事件）。
### 响应式系统和架构
*响应式系统* —— 如同在《响应式宣言》中定义的那样——是一组用于搭建现代系统——已充分准备好满足如今应用程序所面对的不断增长的需求的现代系统——的架构设计原则。
响应式系统的原则决对不是什么新东西，它可以被追溯到 70 和 80 年代 Jim Gray 和 Pat Helland 在   串级系统    （    Tandem System    ） 上和 Joe aomstrong 和 Robert Virding 在 [Erland](http://erlang.org/download/armstrong_thesis_2003.pdf) 上做出的重大工作。然而，这些人在当时都超越了时代，只有到了最近 5 - 10 年，技术行业才被不得不反思当前企业系统最好的开发实践活动并且学习如何将来之不易的响应式原则应用到今天这个多核、云计算和物联网的世界中。
响应式系统的基石是 消息传递   （    message-passing    ） ，消息传递为两个组件之间创建一条暂时的边界，使得它们能够在 *时间* 上分离——实现并发性——和  空间   （    space    ）  ——实现 分布式   （    distribution    ） 与 移动性   （    mobility    ） 。这种分离是两个组件完全   隔离    （    isolation    ） 以及实现 弹性   （    resilience    ） 和 韧性   （    elasticity    ） 基础的必需条件。
### 从程序到系统
这个世界的连通性正在变得越来越高。我们不再构建 *程序* ——为单个操作子来计算某些东西的端到端逻辑——而更多地在构建 *系统* 了。
系统从定义上来说是复杂的——每一部分都包含多个组件，每个组件的自身或其子组件也可以是一个系统——这意味着软件要正常工作已经越来越依赖于其它软件。
我们今天构建的系统会在多个计算机上操作，小型的或大型的，或少或多，相近的或远隔半个地球的。同时，由于人们的生活正变得越来越依赖于系统顺畅运行的有效性，用户的期望也变得越得越来越难以满足。
为了实现用户——和企业——能够依赖的系统，这些系统必须是  灵敏的   （    responsive    ）  ，这样无论是某个东西提供了一个正确的响应，还是当需要一个响应时响应无法使用，都不会有影响。为了达到这一点，我们必须保证在错误( *弹性* )和欠载( *韧性* )下，系统仍然能够保持灵敏性。为了实现这一点，我们把系统设计为 *消息驱动的* ，我们称其为 *响应式系统* 。
### 响应式系统的弹性
弹性是与 *错误下* 的 灵敏性   （    responsiveness    ） 有关的，它是系统内在的功能特性，是需要被设计的东西，而不是能够被动的加入系统中的东西。弹性是大于容错性的——弹性无关于 故障退化   （    graceful degradation    ） ——虽然故障退化对于系统来说是很有用的一种特性——与弹性相关的是与从错误中完全恢复达到 *自愈* 的能力。这就需要组件的隔离以及组件对错误的包容，以免错误散播到其相邻组件中去——否则，通常会导致灾难性的连锁故障。
因此构建一个弹性的、 自愈   （    self-healing    ） 系统的关键是允许错误被：容纳、具体化为消息，发送给其他（担当 监管者   （    supervisors    ） ）的组件，从而在错误组件之外修复出一个安全环境。在这，消息驱动是其促成因素：远离高度耦合的、脆弱的深层嵌套的同步调用链，大家长期要么学会忍受其煎熬或直接忽略。解决的想法是将调用链中的错误管理分离，将客户端从处理服务端错误的责任中解放出来。
### 响应式系统的韧性
   韧性    （    Elasticity    ） 是关于 *欠载下的 灵敏性   （    responsiveness    ） * 的——意味着一个系统的吞吐量在资源增加或减少时能够自动地相应 增加或减少   （    scales up or down    ） （同样能够 向内或外扩展   （    scales in or out    ） ）以满足不同的需求。这是利用云计算承诺的特性所必需的因素：使系统利用资源更加有效，成本效益更佳，对环境友好以及实现按次付费。
系统必须能够在不重写甚至不重新设置的情况下，适应性地——即无需介入自动伸缩——响应状态及行为，沟通负载均衡， 故障转移   （    failover    ） ，以及升级。实现这些的就是  位置透明性   （    location transparency    ） ：使用同一个方法，同样的编程抽象，同样的语义，在所有向度中 伸缩   （    scaling    ） 系统的能力——从 CPU 核心到数据中心。
如同《响应式宣言》所述：
> 
> 一个极大地简化问题的关键洞见在于意识到我们都在使用分布式计算。无论我们的操作系统是运行在一个单一结点上（拥有多个独立的 CPU，并通过 QPI 链接进行交流）,还是在一个 节点集群   （    cluster of nodes    ） （独立的机器，通过网络进行交流)上。拥抱这个事实意味着在垂直方向上多核的伸缩与在水平方面上集群的伸缩并无概念上的差异。在空间上的解耦 [...]，是通过异步消息传送以及运行时实例与其引用解耦从而实现的，这就是我们所说的位置透明性。
> 
> 
> 
因此，不论接收者在哪里，我们都以同样的方式与它交流。唯一能够在语义上等同实现的方式是消息传送。
### 响应式系统的生产效率
既然大多数的系统生来即是复杂的，那么其中一个最重要的点即是保证一个系统架构在开发和维护组件时，最小程度地减低生产效率，同时将操作的  偶发复杂性   （    accidental complexity    ） 降到最低。
这一点很重要，因为在一个系统的生命周期中——如果系统的设计不正确——系统的维护会变得越来越困难，理解、定位和解决问题所需要花费时间和精力会不断地上涨。