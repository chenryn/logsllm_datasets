virtual address 0xFFFF8000 :: physical page 0x1669 (address 0x1669000)
$ ./diagpcpy 0x1669000 16 | strings
commpage 32-bit
$
Let us look at another example. We know that the exception vectors reside in physical memory
starting at address 0x0. We can retrieve the contents of that page and compare them with the contents
of the __interrupts section in the __VECTORS segment within the kernel executable.
$ ./diagpcpy 0x0 4096 > /tmp/phys0.out
$ hexdump -v /tmp/phys0.out | less
...
0000100 7db2 43a6 7d73 43a6 81a0 00f0 7d60 0026
0000110 2c0d 0001 4082 001c 3960 0000 9160 00f0
0000120 8080 00f4 8060 00f8 7c88 03a6 4e80 0020
...
$ otool -s __VECTORS __interrupts /mach_kernel | less
/mach_kernel:
Contents of (__VECTORS,__interrupts) section
...
00000100 7db243a6 7d7343a6 81a000f0 7d600026
00000110 2c0d0001 4082001c 39600000 916000f0
00000120 808000f4 806000f8 7c8803a6 4e800020
...
Note that the hexdump output is formatted somewhat differently from otool's output. The modern-
day hexdump program's output format can be configured through format strings. In this example, you
can make the hexdump output identical to otool's as follows:
$ echo '"%07.7_Ax\\n"\n"%07.7_ax " 4/4 "%08x " "\\n"' | \
hexdump -v -f /dev/stdin /tmp/phys0.out
...
00000100 7db243a6 7d7343a6 81a000f0 7d600026
00000110 2c0d0001 4082001c 39600000 916000f0
00000120 808000f4 806000f8 7c8803a6 4e800020
...
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh16A1.htm 20.08.2007
Chapter 6. The xnu Kernel Page 112 of 137
Finally, let us retrieve a few bytes from the physical address 0x5000 and attempt to interpret them as
a character string. We will see the reason for this string in Section 6.8.9.1.
$ ./diagpcpy 0x5000 8 | strings
Hagfish
Capturing a Screenshot of the Text Console
We earlier determined the physical base address of the boot display's framebuffer using the
diagBootScreen program. Since diagpcpy allows us to dump physical memory, we could capture a
raw screenshot of the display using these two programs. In particular, this gives us a way of capturing
a screenshot of the textual console. Let us consider the example of the display shown in Figure 641;
the relevant information is repeated here.
$ ./diagBootScreen
1280x854 pixels, 160x53 characters, 32-bit
base address 0x2f72c000, physical address 0xb8010000
5120 bytes used for display per row
Given the information dumped by diagBootScreen, we can see that our screenshot capturing on this
particular system would involve copying a certain amount of physical memory starting at physical
address 0xb8010000. Since this is a 32-bit framebuffer and there are 1280 x 854 pixels, the number of
bytes we need to retrieve is 4 x 1280 x 854, which is 4,372,480.
$ ./diagpcpy 0xb8010000 4372480 > display.dump
$ file display.dump
display.dump: data
Note that diagpcpy is not the only way to read physical memory from user space. Given the
appropriate privileges, a user program can read physical memory and kernel virtual memory through
the /dev/mem and /dev/kmem devices, respectively. The kernel functions that serve these devices are
implemented in bsd/dev/ppc/mem.c.
At this point, the display.dump file contains raw pixel dataa linear sequence of 32-bit pixel values in
row-major order. When treated as big-endian, each pixel value contains a leading pad byte followed
by 8-bit red, green, and blue components, in that order. We can convert this raw data to an image
formatsay, TIFF or JPEGby using a variety of image-processing tools. For example, we can write a
trivial Perl script to remove the padding from each pixel value to create a new raw pixel data file,
which can then be converted to easily viewable image formats. The following example uses the freely
available rawtoppm and ppmtojpeg command-line programs.
$ cat unpad.pl
#! /usr/bin/perl -w
my $PROGNAME = "unpad";
if ($#ARGV != 1) {
die "usage: $PROGNAME  \n";
}
open(I, "$ARGV[1]") or die "$!\n";
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh16A1.htm 20.08.2007
Chapter 6. The xnu Kernel Page 113 of 137
my $ibuf;
while (sysread(I, $buf, 4) == 4) {
my ($pad, $r, $g, $b) = unpack('C4', $buf);
$buf = pack('C3', $r, $g, $b);
syswrite(O, $buf, 3);
}
close(I);
close(O);
exit(0);
$ ./unpad.pl display.dump display-rgb.raw
$ rawtoppm -rgb -interpixel 1280 854 display-rgb.raw > display.ppm
$ ppmtojpeg display.ppm > display.jpg
A user program can retrieve the base address of a framebuffer using the CGDisplayBaseAddress()
Quartz Services API call. Thereafter, the program can access and modify the framebuffer memorysay,
using the read() and write() system calls. We will see an API-compliant version of the screenshot-
capturing example in Chapter 10.
6.8.9. Low-Level Kernel Tracing
In addition to the various tracing facilities we have seen so far, the Mac OS X kernel contains yet
another tracing facility used for low-level tracing. We have alluded to this facility earlier in this
chapter in the context of the CutTrace() system call, which is the means by which kernel code logs
low-level traces into a kernel buffer. The buffer can be examined from within KDB. Before we
discuss this tracing mechanism, let us look at the low-memory global (lowglo) data structures, which
also include the work area for this mechanism.
6.8.9.1. Low-Memory Global Data Structures
We have seen earlier that the first 32KB of physical memorythe low memorycontains critical kernel
data and code. For example, the PowerPC exception vectors begin at physical address 0x0. The low-
level exception filter table (xcpTable) and the first-level system call dispatch table (scTable), both
of which are implemented in osfmk/ppc/lowmem_vectors.s, also reside in low memory. Another
low-memory area instantiated in lowmem_vectors.s is lowGloa structure of type lowglo that
contains global (as opposed to per-processor) constants, data areas, and pointers. These entities are
accessed by kernel code directly using absolute addresses. Hence, they must reside in low physical
memory. The logGlo area starts at physical address 0x5000 and is a page long. The next physical
pagestarting at address 0x6000is a shared page mapped into the kernel's address space; it can be used
for low-level kernel debugging. Figure 644 shows the structure of the lowGlo area.
Figure 644. The low-memory global data area
[View full size image]
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh16A1.htm 20.08.2007
Chapter 6. The xnu Kernel Page 114 of 137
In Section 6.8.8.2, we found that memory at physical address 0x5000 contains the word Hagfish. To
be precise, it is the string "Hagfish" (with a trailing space). It is an "eyecatcher" string used as a
system verification code at the beginning of the lowGlo area. Let us use our diagpcpy program from
Section 6.8.8.2 to glean some more information from this area.
Kernel Version String
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh16A1.htm 20.08.2007
Chapter 6. The xnu Kernel Page 115 of 137
As shown in Figure 644, physical address 0x501C contains a pointer to the kernel version string.
$ ./diagpcpy 0x501C 4 | hexdump
0000000 0033 1da0
0000004
$ ./diagpcpy 0x00331da0 128 | strings
Darwin Kernel Version 8.6.0: ... root:xnu-792.6.70.obj~1/RELEASE_PPC
8.6.0
Darwin
Per-Processor Information Areas
As shown in Figure 644, physical address 0x5010 points to the start of the array containing per-
processor information entries. Each entry is a structure of type per_proc_entry, which contains a
pointer to a structure of type per_proc_info. The latter contains a variety of static and dynamic
information about a processorfor example, the hardware exception counters (struct hwCtrs). Figure
645 shows excerpts from these structures, some of which we came across in Chapter 5.
Figure 645. Data structures for holding per-processor information
// osfmk/ppc/exception.h
#pragma pack(4)
struct hwCtrs {
unsigned int hwInVains;
unsigned int hwResets;
unsigned int hwMachineChecks;
unsigned int hwDSIs;
unsigned int hwISIs;
unsigned int hwExternals;
unsigned int hwAlignments;
unsigned int hwPrograms;
...
};
#pragma pack()
typedef struct hwCtrs hwCtrs;
...
#pragma pack(4)
struct per_proc_info {
unsigned int cpu_number;
...
hwCtrs hwCtr; // begins at offset 0x800 within the structure
...
}
#pragma pack()
...
#define MAX_CPUS 256
struct per_proc_entry {
addr64_t ppe_paddr;
unsigned int ppe_pad4[1];
struct per_proc_info *ppe_vaddr;
};
extern struct per_proc_entry PerProcTable[MAX_CPUS-1];
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh16A1.htm 20.08.2007
Chapter 6. The xnu Kernel Page 116 of 137
Let us retrieve the value of a particular hardware countersay, hwProgramsusing diagpcpy. We will
do so for the first processor, in case there are multiple processors. Given the information in Figures
644 and 645, we can compute the physical address of interest using the following information.
 The address 0x5010 contains a pointer to PerProcTablewe are interested in the first entry of
PerProcTable.
 The ppe_addr field is at an offset of 12 bytesthe sum of the sizes of an addr64_t and an
unsigned int.
 Resolving the ppe_addr pointer gives us the per_proc_info structure of the processor.
 The hwCtr structure is at an offset 0x800 within the per_proc_info structure.
 The hwPrograms counter is at an offset of 28 bytesseven times the size of an unsigned
intwithin the hwCtr structure, and therefore, at an offset of 0x81c (0x800 + 28) bytes within
per_proc_info.
Let us now retrieve the value of hwPrograms.
$ ./diagpcpy 0x5010 4 | hexdump # this will give us the address of PerProcTable
00000000 0035 d000
00000004
$ ./diagpcpy 0x35d000 16 | hexdump # fourth 32-bit word is the first
# processor's ppe_vaddr
00000000 0000 0000 0035 e000 0000 0000 0035 e000
00000010
$ ./diagpcpy 0x35e81c 4 | hexdump # add 0x81c to get the address of hwPrograms
00000000 0000 0000
00000004
In this example, the counter's value is 0. Let us execute a trivial program that we know will increment
the value of this counter. For example, executing an illegal hardware instructionsay, a supervisor-only
instruction in user modewill result in a T_PROGRAM exception, which is counted by hwPrograms.
Figure 646 shows a program that causes a T_PROGRAM to be generated.
Figure 646. Causing an exception and retrieving the corresponding counter from the kernel
// gentprogram.c
#if defined(__GNUC__)
#include 
#endif
int
main(void)
{
return __mfspr(1023);
}
$ gcc -Wall -o gentprogram gentprogram.c
$ ./gentprogram
zsh: illegal hardware instruction ./gentprogram
$ ./diagpcpy 0x35e81c 4 | hexdump
00000000 0000 0001
00000004
$ ./gentprogram; ./gentprogram; ./gentprogram
zsh: illegal hardware instruction ./gentprogram
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh16A1.htm 20.08.2007
Chapter 6. The xnu Kernel Page 117 of 137
zsh: illegal hardware instruction ./gentprogram
zsh: illegal hardware instruction ./gentprogram
$ ./diagpcpy 0x35e81c 4 | hexdump
00000000 0000 0004
00000004
Figure 647 shows a portion of exception-handling code that increments various hardware exception
counters. Note that the order of counter fields within the hwCtr structure is matched with the
definition of exception numbersan exception number is the offset of the corresponding counter within
hwCtr. For example, T_PROGRAM is defined to be (0x07 * T_VECTOR_SIZE) in
osfmk/ppc/exception.h, with T_VECTOR_SIZE being 4.
Figure 647. Maintenance of hardware exception counters in the kernel
// osfmk/ppc/genassym.c
...
DECLARE("hwCounts", offsetof(struct per_proc_info *, hwCtr);
...
; osfmk/ppc/lowmem_vectors.s
.L_exception_entry:
...
xcpCommon:
...
Redrive:
...
mfsprg r2,0 ; restore per_proc (SPRG0 contains per_proc ptr)
...
la r12,hwCounts(r2) ; point to the exception count area
...
add r12,r12,r11 ; point to the count (r11 contains T_XXX)
lwz r25,0(r12) ; get the old value
...
add r25,r25,r24 ; count this one (r24 will be 1 or 0)
...
stw r25,0(r12) ; store it back
...
6.8.9.2. Low Tracing
Let us now continue our discussion of "CutTrace" low-level tracing, or simply low tracing. Figure
644 shows an area called lgTrcWork: This is the control block for low tracing. It is a structure of type
TRaceWork.
// osfmk/ppc/low_trace.h
typedef struct traceWork {
unsigned int traceCurr; // Address of next slot
unsigned int traceMask; // Types to be traced
unsigned int traceStart; // Start of trace table
unsigned int traceEnd; // End of trace table
unsigned int traceMsnd; // Saved trace mask
unsigned int traceSize; // Size of trace table
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh16A1.htm 20.08.2007
Chapter 6. The xnu Kernel Page 118 of 137
unsigned int traceGas[2];
} traceWork;
Similarly, lgdgWork is the diagnostic work areait is a structure of type diagWork, which is declared
in osfmk/ppc/Diagnostics.h. One of this structure's fields, dgFlags, stores the diagnostic flags.
The flags passed through the diag boot-time argument are stored here.
Low tracing is enabled by setting the enaExpTrace bit in the value of the diag boot-time argument. It
can be limited to a specific processor by providing the processor number through the ctrc boot-time
argument. Moreover, the size of the kernel buffer used for low tracing can be adjusted through the tb
boot-time argument. ppc_init() [osfmk/ppc/ppc_init.c] processes these arguments during early
system startup. Figure 648 shows this processing.
Figure 648. Processing of low-tracing-related boot-time arguments during system startup
// osfmk/ppc/genassym.c
...
DECLARE("trcWork", offsetof(struct lowglo *, lgTrcWork));
...
// osfmk/ppc/ppc_init.c
void
ppc_init(boot_args *args)
{
...
// Set diagnostic flags
if (!PE_parse_boot_arg("diag", &dgWork.dgFlags))
dgWork.dgFlags = 0;
...
// Enable low tracing if it is requested
if (dgWork.dgFlags & enaExpTrace)
trcWork.traceMask = 0xFFFFFFFF;
// See if tracing is limited to a specific processor
if (PE_parse_boot_arg("ctrc", &cputrace)) {
trcWork.traceMask = (trcWork.traceMask & 0xFFFFFFF0) | (cputrace & 0xF);
}
// See if we have a nondefault trace-buffer size
if (!PE_parse_boot_arg("tb", &trcWork.traceSize)) {
#if DEBUG
trcWork.traceSize = 32; // Default 32-page trace table for DEBUG
#else
trcWork.traceSize = 8; // Default 8-page trace table for RELEASE