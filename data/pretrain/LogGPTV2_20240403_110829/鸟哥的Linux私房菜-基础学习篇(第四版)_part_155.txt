你会发现 ps -l 与 ps aux 显示的项目并不相同！在 ps aux 显示的项目中，各字段的意义为：
USER：该 process 属于那个使用者帐号的？
PID ：该 process 的程序识别码。
%CPU：该 process 使用掉的 CPU 资源百分比；
%MEM：该 process 所占用的实体内存百分比；
VSZ ：该 process 使用掉的虚拟内存量 （KBytes）
RSS ：该 process 占用的固定的内存量 （KBytes）
TTY ：该 process 是在那个终端机上面运行，若与终端机无关则显示 ?，另外， tty1-tty6 是本机上面的登陆者程序，若为 pts/0 等等
的，则表示为由网络连接进主机的程序。
STAT：该程序目前的状态，状态显示与 ps -l 的 S 旗标相同 （R/S/T/Z）
START：该 process 被触发启动的时间；
TIME ：该 process 实际使用 CPU 运行的时间。
COMMAND：该程序的实际指令为何？
一般来说，ps aux 会依照 PID 的顺序来排序显示，我们还是以 14836 那个 PID 那行来说明！该行的意义为“ root 执行的 bash PID
为 14836，占用了 0.1% 的内存容量百分比，状态为休眠 （S），该程序启动的时间为 8 月 4 号，因此启动太久了， 所以没有列出实际
的时间点。且取得的终端机环境为 pts/0 。”与 ps aux 看到的其实是同一个程序啦！这样可以理解吗？ 让我们继续使用 ps 来观察一下其
他的信息吧！
范例三：以范例一的显示内容，显示出所有的程序：
[root@study ~]# ps -lA
F S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD
4 S 0 1 0 0 80 0 - 15159 ep_pol ? 00:00:01 systemd
1 S 0 2 0 0 80 0 - 0 kthrea ? 00:00:00 kthreadd
1 S 0 3 2 0 80 0 - 0 smpboo ? 00:00:00 ksoftirqd/0
....（以下省略）....
# 你会发现每个字段与 ps -l 的输出情况相同，但显示的程序则包括系统所有的程序。
范例四：列出类似程序树的程序显示：
[root@study ~]# ps axjf
PPID PID PGID SID TTY TPGID STAT UID TIME COMMAND
0 2 0 0 ? -1 S 0 0:00 [kthreadd]
2 3 0 0 ? -1 S 0 0:00 \_ [ksoftirqd/0]
.....（中间省略）.....
1 1326 1326 1326 ? -1 Ss 0 0:00 /usr/sbin/sshd -D
1326 13923 13923 13923 ? -1 Ss 0 0:00 \_ sshd: dmtsai [priv]
13923 13927 13923 13923 ? -1 S 1000 0:00 \_ sshd: dmtsai@pts/0
13927 13928 13928 13928 pts/0 18703 Ss 1000 0:00 \_ -bash
13928 13970 13970 13928 pts/0 18703 S 1000 0:00 \_ bash
13970 14830 14830 13928 pts/0 18703 S 0 0:00 \_ sudo su -
14830 14835 14830 13928 pts/0 18703 S 0 0:00 \_ su -
14835 14836 14836 13928 pts/0 18703 S 0 0:00 \_ -bash
14836 18703 18703 13928 pts/0 18703 R+ 0 0:00 \_ ps axjf
.....（后面省略）.....
看出来了吧？其实鸟哥在进行一些测试时，都是以网络连线进虚拟机来测试的，所以啰，你会发现其实程序之间是有相关性的
啦！ 不过，其实还可以使用 pstree 来达成这个程序树喔！以上面的例子来看，鸟哥是通过 sshd 提供的网络服务取得一个程序， 该程序
提供 bash 给我使用，而我通过 bash 再去执行 ps axjf ！这样可以看的懂了吗？其他各字段的意义请 man ps （虽然真的很难 man 的出
来！） 啰！
范例五：找出与 cron 与 rsyslog 这两个服务有关的 PID 号码？
[root@study ~]# ps aux | egrep '（（cron|rsyslog））'
root 742 0.0 0.1 208012 4088 ? Ssl Aug04 0:00 /usr/sbin/rsyslogd -n
root 1338 0.0 0.0 126304 1704 ? Ss Aug04 0:00 /usr/sbin/crond -n
root 18740 0.0 0.0 112644 980 pts/0 S+ 00:49 0:00 grep -E --color=auto （cron|rsyslog）
# 所以号码是 742 及 1338 这两个啰！就是这样找的啦！
除此之外，我们必须要知道的是“僵尸 （zombie） ”程序是什么？ 通常，造成僵尸程序的成因是因为该程序应该已经执行完毕，或
者是因故应该要终止了， 但是该程序的父程序却无法完整的将该程序结束掉，而造成那个程序一直存在内存当中。 如果你发现在某个程
序的 CMD 后面还接上  时，就代表该程序是僵尸程序啦，例如：
apache 8683 0.0 0.9 83384 9992 ? Z 14:33 0:00 /usr/sbin/httpd 
当系统不稳定的时候就容易造成所谓的僵尸程序，可能是因为程序写的不好啦，或者是使用者的操作习惯不良等等所造成。 如果
你发现系统中很多僵尸程序时，记得啊！要找出该程序的父程序，然后好好的做个追踪，好好的进行主机的环境最优化啊！ 看看有什么
地方需要改善的，不要只是直接将他 kill 掉而已呢！不然的话，万一他一直产生，那可就麻烦了！ @_@
事实上，通常僵尸程序都已经无法控管，而直接是交给 systemd 这支程序来负责了，偏偏 systemd 是系统第一支执行的程序， 他
是所有程序的父程序！我们无法杀掉该程序的 （杀掉他，系统就死掉了！），所以啰，如果产生僵尸程序， 而系统过一阵子还没有办法
通过核心非经常性的特殊处理来将该程序删除时，那你只好通过 reboot 的方式来将该程序抹去了！
top：：动动态态观观察察程程序序的的变变化化
相对于 ps 是撷取一个时间点的程序状态， top 则可以持续侦测程序运行的状态！使用方式如下：
[root@study ~]# top [-d 数数字字] | top [-bnp]
选项与参数：
-d ：后面可以接秒数，就是整个程序画面更新的秒数。默认是 5 秒；
-b ：以批次的方式执行 top ，还有更多的参数可以使用喔！
通常会搭配数据流重导向来将批次的结果输出成为文件。
-n ：与 -b 搭配，意义是，需要进行几次 top 的输出结果。
-p ：指定某些个 PID 来进行观察监测而已。
在 top 执行过程当中可以使用的按键指令：
? ：显示在 top 当中可以输入的按键指令；
P ：以 CPU 的使用资源排序显示；
M ：以 Memory 的使用资源排序显示；
N ：以 PID 来排序喔！
T ：由该 Process 使用的 CPU 时间累积 （TIME+） 排序。
k ：给予某个 PID 一个讯号 （signal）
r ：给予某个 PID 重新制订一个 nice 值。
q ：离开 top 软件的按键。
其实 top 的功能非常多！可以用的按键也非常的多！可以参考 man top 的内部说明文档！ 鸟哥这里仅是列出一些鸟哥自己常用的选项而
已。接下来让我们实际观察一下如何使用 top 与 top 的画面吧！
范例一：每两秒钟更新一次 top ，观察整体信息：
[root@study ~]# top -d 2
top - 00:53:59 up 6:07, 3 users, load average: 0.00, 0.01, 0.05
Tasks: 179 total, 2 running, 177 sleeping, 0 stopped, 0 zombie
%Cpu（s）: 0.0 us, 0.0 sy, 0.0 ni,100.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st
KiB Mem : 2916388 total, 1839140 free, 353712 used, 723536 buff/cache
KiB Swap: 1048572 total, 1048572 free, 0 used. 2318680 avail Mem
 /tmp/top.txt
# 这样一来，嘿嘿！就可以将 top 的信息存到 /tmp/top.txt 文件中了。
这玩意儿很有趣！可以帮助你将某个时段 top 观察到的结果存成文件，可以用在你想要在系统背景下面执行。 由于是背景下面执行，与
终端机的屏幕大小无关，因此可以得到全部的程序画面！那如果你想要观察的程序 CPU 与内存使用率都很低，结果老是无法在第一行显示
时，该怎办？我们可以仅观察单一程序喔！如下所示：
范例三：我们自己的 bash PID 可由 $$ 变量取得，请使用 top 持续观察该 PID
[root@study ~]# echo $$
14836 <==就是这个数字！他是我们 bash 的 PID
[root@study ~]# top -d 2 -p 14836
top - 01:00:53 up 6:14, 3 users, load average: 0.00, 0.01, 0.05
Tasks: 1 total, 0 running, 1 sleeping, 0 stopped, 0 zombie