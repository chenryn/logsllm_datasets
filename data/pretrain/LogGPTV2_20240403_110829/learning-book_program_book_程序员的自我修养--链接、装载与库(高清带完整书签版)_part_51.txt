程序员的自我修养一链接、装载与库
---
## Page 288
9.2符号导出导入表
265
化，使得接下来的对该DLL的调用速度与普通方式载入的DLL的速度相差无异。
9.2.5导入函数的调用
接下来我们来看看Windows PE对于导入函数是怎么调用的？_declspec(dlimport）又有
什么作用？
如果在PE的模块中需要调用个导入函数，仿照ELFGOT机制的一个办法就是使用
一个间接调用指令，比如：
CALL DWORD PTR [0x0040D11C]
我们在Windows下也入乡随俗，使用微软汇编器语法。如果你不熟悉微软汇编器语法
也没多大关系，上面这条指令的意思是间接调用0x0040D11C这个地址中保存的地址，即从
地址0x0040D1IC开始取4个字节作为目标地址（DWORDPTR表示4个字节的操作前缓），
然后调用该目标地址。面0x0040D11C这个地址刚好是IAT中的某一项，即我们需要调用的
外部函数在IAT中所对应的元素，比如TestMath.exe中，我们需要调用 Math.dll 中的 Sub 函
数，那么0x0040D11C正好对应Sub导入函数在TestMath.exe的LAT中的位置，这个过程跟
ELF通过GOT间接跳转十分类似，IAT相当于GOT（不考虑PLT的情况下）。
PEDLL的地址无关性
如果ELF调用者本身所在的模块是地址无关的，那么通过GOT跳转之前，需要计算
目标函数地址在GOT中的位置，然后再间接跳转，以实现地址无关，这个原理我们在
前面已经很详细地分析过了。但是在这个现实方法中，我们可以看到，这个
0x0040D11C是作为常量被写入在指令中。而且事实上，PE对导入函数调用的真正实
现中，它的确是这么做的，由此我们可以得出结论，PEDLL的代码段并不是地址无
关的。
那么P是如何解决装载时模块在进程空问中地址冲突的问题的呢？事实上它使用了
一种叫做重定基地址的方法，我们在后面将会详细介绍。
PE采用上面的这个方法实现导入函数的调用，但是与ELF一样存在一个间题：对于编
译器来说，它无法判断一个函数是本模块内部的，还是从外部导入的。因为对于普通的模块
内部函数调用来说，编译器产生的指令是这样的：
CALL XXXXXXXX
因为PE没有类似ELF的共享对象有全局符号介入的问题，所以对于模块内部的全局
函数调用，编译器产生的都是直接调用指令。
其中XXXXXXXX是模块内部的函数地址。这是一个直接调用指令，与上面的间接调用
程序员的自我修养—链接、装载与库
---
## Page 289
266
第9章Windows下的动态链接
指令形式不同。所以为了使得编译器能够区分函数是从外部导入的还是模块内部定义
的，MSVC引入了我们前面用过的扩展属性“_declspec（dlimport)”，一旦一个函数被声
明为“_declspec（dllimport）”，那么编译器就知道它是外部导入的，以便于产生相应的指
令形式。
在“_declspec”关键字引入之前，微软还提供了另外一个方法来解决这个间题。在这
种情况下，对于导入函数的调用，编译器并不区分导入函数和导出函数，它统一地产生直接
调用的指令。但是链接器在链接时会将导入函数的目标地址导向一小段桩代码（Stub），由
这个桩代码再将控制权交给IAT中的真正目标地址，实现如下：
CALL 0x0040100C
0x0040100C:
JMP DWORD PTR [0×0040D11C]
即对于调用函数来说，它只是产生一般形式的指令“CALLXXXXXXXX”，然后在链
接时，链接器把这个XXXXXXXX地址重定位到一段桩代码，即那条JMP指令处，然后这
条JMP指令才通过IAT间接跳转到导入函数。我们知道，链接器一般情况下是不会产生指
令的，那么这段包含JMP指令的桩代码来自何处呢？答案是来自产生DLL文件时伴随的那
个LIB文件，即导入库。
编译器在产生导入库时，同一个导出函数会产生两个符号的定义，比如对于函数foo来
说，它在导入库中有两个符号，一个是foo，另外一个是_imp_foo。这两个符号的区别是，
foo 这个符号指向 foo函数的桩代码，面_imp_foo 指向foo函数在IAT 中的位置。所以当
我们通过“_declspec(dllimport）)”来声明foo导入函数时，编译器在编译时会在该导入函数
前加上前缓“_imp_”，以确保跟导入库中的“_imp_foo”能够正确链接：如果不使用
“_declspec(dlimport)”，那么编译器将产生一个正常的foo 符号引用，以便于跟导入库中
的foo符号定义相链接。
现在的MSVC编译器对于以上两种导入方式都支持，即程序员可以通过
“_declspec(dllimpor)”来声明导入函数，也可以不使用，但我们还是推荐使用
“_declspec（dllimport）”，毕竞从性能上来讲，它比不使用该声明少了一条跳转指令。当然
它还有其他的好处，我们到后面用到时还会提起。
9.3DLL优化
我们在前面经过对DLL的分析得知，DLL的代码段和数据段本身并不是地址无关的，
也就是说它默认需要被装载到由ImageBase指定的目标地址中。如果目标地址被占用，那么
就需要装载到其他地址，便会引起整个DLL的Rebase。这对于拥有大量DLL的程序来说，
程序员的自我修养一链接、装载与库
---
## Page 290
9.3DLL优化
267
频繁的Rebase也会造成程序启动速度减慢。这是影响DLL性能的另外一个原因。
我们知道动态链接过程中，导入函数的符号在运行时需要被逐个解析，在这个解析过程
中，免不了会涉及到符号字符串的比较和查找过程，这个查找过程中，动态链接器会在目标
DLL的导出表中进行符号字符串的二分查找。即使是使用了二分查找法，对于拥有DLL数
量很多，并且有大量导入导出符号的程序来说，这个过程仍然是非常耗时的。这是影响DLL
性能的一个原因之一。
这两个原因可能会导致应用程序的速度非常慢，因为系统需要在启动程序时进行大量的
符号解析和 Rebase 工作。
9.3.1重定基地址（Rebasing）
从前面DLL的导入函数的实现，我们得出结论：PE的DLL中的代码段并不是地址无
关的，也就是说它在被装载时有一个固定的目标地址，这个地址也就是PE里面所谓的基地
址（Base Address），默认情况下，PE文件将被装载到这个基地址。一般来说，EXE文件
的基地址默认为0x00400000，面DLL文件基地址默认为0x10000000。
我们前面花了很多篇幅讨论了为什么对于一个ELF共享对象，它的代码段要做到地址
无关，并且讨论了地址无关的实现。这一点对于DLL来说也一样，一个进程中，多个DLL
不可以被装载到同一个虚拟地址，每个DLL所占用的虚拟地址区域之间都不可以重叠。
在讨论共享对象的地址冲突问题时，我们已经介绍过了，有3种方案可供选择。一个办
法是像静态共享对象那样，为每个DLL指定-一个基地址，并且人为保证同一个进程中这些
DLL的地址区域都不相互重叠，但是这样做会有很多问题，在前面介绍静态共享对象的时
候已经讨论过，这种将模块目标地址固定的做法有很多擎端，另外一个办法就是ELF所采
用的办法，那就是代码段地址无关。
WindowsPE采用了一种与ELF不同的办法，它采用的是装载时重定位的方法。在DLL
模块装载时，如果目标地址被占用，那么操作系统就会为它分配一块新的空间，并且将DLL
装载到该地址。这时候问题来了，因为DLL的代码段不是地址无关的，DLL中所有涉及到
绝对地址的引用该怎么办呢？答案是对于每个绝对地址引用都进行重定位，
当然，这个重定位过程有些特殊，因为所有这些需要重定位的地方只需要加上一个固定
的差值，也就是说加上一个目标装裁地址与实际装载地址的差值，我们来看一个例子，比如
有一个DLL的基地址是0x10000000，那么如果它的代码中有这样一条指令：
MOV DWORD PTR[0×100010001.0×100
我们假设0x10001000是该模块中一个变量foo的地址，即该变量的RVA是0x1000。如
程序员的自我修养——链接、装载与库
---
## Page 291
89Z
第9章Windows下的动态链接
果DLL在装载时，0x10000000这个地址被其他DLL占用了，Windows就会将它加载到一
个新的地址，假设是0x20000000.因为0x10001000是个绝对地址，所以我们需要对这条指
令进行重定位。这时候新的基地址是0x20000000，面RVA是不变的，所以foo的地址实际
上已经变成了0x20001000，也就是指令的地址部分要加上0x20000000-0x10000000的这个
差值。经过调整后的指令应该是：
MOV DWORD P7R [0×200010001,0×100
事实上，由于DLL内部的地址都是基于基地址的，或者是相对于基地址的RVA。那么
所有需要重定位的地方都只需要加上一个周定差值，在这个例子里面是0x10000000。所以
这个重定位的过程相对简单一点，速度也要比一般的重定位要快。PE里面把这种特殊的重
定位过程又被叫做重定基地址（Rebasing）。
PE文件的重定位信息都放在了“reloc”段，我们可以从PE文件头中的DataDirectory里
面得到重定位段的信息。重定位段的结构跟ELF中的重定位段结构十分类似，在这里就不再
详细介绍了。对于EXE文件来说，MSVC编译器默认不会产生重定位段，也就是默认情况下，
EXE是不可以重定位的，不过这也没有问题，因为EXE文件是进程运行时第一个装入到虚拟
空间的，所以它的地址不会被人抢占。面DLL则没那么率运了，它们被装载的时间是不确定
的，所以一般情况下，编译器都会给DLL文件产生重定位信息，当然你也可以使用“/FIXED”
参数米禁止DLL产生重定位信息，不过那样可能会造成DLL的装载失败。
这种重定基地址的方法导致的一个问题是，如果一个DLL被多个进程共享，且该DLL
被这些进程装载到不同的位置，那么每个进程都需要有一份单独的DLL代码段的副本。很
明显，这种方案相对于ELF的共享对象代码段地址无关的方案来说，它更加浪费内存，而
且当被重定基址的代码段需要被换出时，它需要被写到交换空间中，而不像没有重定基址的
DLL代码段，只需要释放物理页面，再次用到时可以直接从DLL文件里面重新读取代码段
即可，但是有一个好处是，它比ELF的PIC机制有着更快的运行速度。因为PE的DLL对
数据段的访问不需要通过类似于GOT的机制，对于外部数据和函数的引用不需要每次都计
算GOT的位置，所以理论上会比ELF的PIC的方案快一些。这又是一个空间换时间的案例。
改变款认基地址
前面的重定基地址过程实际上是在DLL文件装载时进行的，所以文叫做装载时重定位。
对于一个程序来说，它所用到的DLL基本是固定的（除了通过LoadLibraryO装载的以外）。
程序每次运行时，这些DLL的装载顺序和地址也是一样的。比如一个程序由程序主模块
main.exe、foo.dll和bar.dll3个模块组成，它们的大小都是64KB。于是当程序运行起来以
后进程虚拟地址空间的布局应该如表9-1所示。
程序员的自我修养一链接、装载与库
---
## Page 292
9.3DLL优化
269
表9-1
结束地址
main.exe
0x00400000
0x00410000
foo.dIl
0x10000000
0x10010000
0x10010000
0x10020000
可以看到bar.dll原先默认的基地址是0x10000000.但是它被重定基址到了0x10010000，
因为0x10000000到0x10010000这块地址被先前加载的foo.dll占用了（假设foo.dl 比bar.dl
先装载）。那么既然bar.dll每次运行的时候基地址都是0x10010000，为什么不把它的基地址
就设成0x10010000呢？这样就省掉了bar.dll每次装载时重定基址的过程，不是可以让程序
运行得更快吗？
MSVC的链接器提供了指定输出文件的基地址的功能。那么可以在链接时使用ink命
令中的“/BASE”参数为bar.dll 指定基地址：
link /BASB:0x10010000, 0x10000 /DLL bar,obj
注
这个基地址必须是64K的倍数，如果不是64K的倍数，链接器将发出错误。这里还有
一个参数0x10000是指DLL占用空间允许的最大的长度，如果超出这个长度，那么编译
器会给出警告。这个看似没用的选项实际上非常有用，比如我们的程序中用到了10个
DLL，那么我们就可以为每个DLL手工指定一块区域，以防止它们在地址空间中相互冲
突。假设我们为bar.dl指定的空间是0x10010000到0x10020000这块空间，那么在使
用“/BASE”参数时，我们不光指定bar.dll的起始地址，还指定它的最长的长度。如果
超出这个长度，它就会占用其他DLL的地址块，如果链接器能够绝出警告的话，我们就
很快能发现问题并且进行调整。
除了在链接时可以指定DLL的基地址以外，MSVC还提供了一个叫做editbin的工其（早
期版本的MSVC提供一个叫rebase.exe的工具），这个工具可以用来改变已有的DLL的基地
址。比如：
editbin /REBAS8:BASE=0x10020000 bar,d11
系统DLL
由于Windows 系统本身自带了很多系统的 DLL，比如kerel32.dll、ntdll.dll、shell32.dll、
user32.dll、msvcrt.dll 等，这些DLL基本上是Windows 的应用程序运行时都要用到的。
Windows系统就在进程空间中专门划出一块0x70000000~0x80000000区域，用于映射这些
常用的系统DLL。Windows在安装时就把这块地址分配给这些DLL，调整这些DLL的基地
址使得它们相互之间不冲突，从而在装载时就不需要进行重定基址了。比如在我的机器中，
这些DLL的基地址如表9-2所示。
程序员的自我修养一链接、装载与库
---
## Page 293
270
第9章Windows下的动态链接
表9-2
DLL
认基地置
Kermel32.dl1
7C800000 image base (7C800000 to 7C8F5FFF)
Ntdl1.dII
7C90000 image base (7C90000 to 7C9AEFFF)
Shell32.dll
7C9C0000 image base (7C9C0000 to 7D1D6FFF)
User32.dIl
7E410000imge base(7E410000 to7EAA0FFF)
Msvert.dl
77C1000 image base (77C10000 to77C67FFF)
9.3.2序号
一个DLL中每一个导出的函数都有一个对应的序号（Ordinal Number）。一个导出函数
甚至可以没有函数名，但它必须有一个唯一的序号。另一方面，当我们从一个DLL导入一
个函数时，可以使用函数名，也可以使用序号。序号标示被导出函数地址在DLL导出表中
的位置。
一般来说，那些仅供内部使用的导出函数，它只有序号没有函数名，这样外部使用者就
无法推测它的含义和使用方法，以防止误用。对于大多数WindowsAPI函数来说，它们的
函数名在各个Windows版本之间是保持不变的，但是它们的序号是在不停地变化的。所以，
如果我们导入WindowsAPI的话，绝对不能使用序号作为导入方法。
在产生一个DLL文件时，我们可以在链接器的.def文件中定义导出函数的序号。比如
对于前面的 Math.dll 的例子，假设有如下.def文件：
LIBRARY Math
Add 91
EXPORTS
Sub 2
Mu1 @3
Div 94NONAME
上面的.def文件可以用于指定Math.dl的导出函数的序号，@后面所跟的值就是每个符
号的序号值。对于Div函数，序号值后面还有一个NONAME，表示该符号仅以序号的形式
导出，即Math.dll的使用者看不到Div这个符号名，只能看到序号为4的一个导出函数：
c1 /c Math.c
1ink /DLL/D&P:Math.def Math.obj
dumpbin /ExPORT8 Math.d11
ordinal hint RVA
nane
1
0 00001000 Add
1 00001020 Mu1
Z
00001030[NONAME]
2 00001010 Sub
4
程序员的自我修养—链接、装载与库
---
## Page 294