Â· 2ğ‘›âˆ’ğ‘˜,
6.1 Proof Overview
The proof of Theorem 6.1 is based on the H-coefficient technique
(Theorem 2.2) which we apply to the augmented games described in
Figures 4 and 5. These games modify the multi-user AEAD games
shown in Figure 1 to give the adversary more information, thereby
Session 6D: Authentication and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1986capturing an even stronger notion of security, but which neverthe-
less facilitates our proof. Specifically, the adversary is given access
to an additional oracle Reveal, that it must query exactly once
as its last query, right before returning its outputâ€”which in turn
triggers the Finalize procedure.
In the real world, the Reveal oracle returns the outputs ğ‘‰ğ‘—
corresponding to all the internal calls made by the encryption or-
acle to the ChaCha20 block function and all the user keys ğ¾ğ‘–. In
the ideal world, on the other hand, the Reveal oracle returns
randomly distributed strings ğ‘‰ğ‘— and keys ğ¾ğ‘–. Note that through
{ğ‘‰ğ‘—} and {ğ¾ğ‘–}, the adversary implicitly also learns the direct out-
puts of the ideal permutation in the real world, as it can easily
reconstruct them. Since the augmented games are strictly stronger
than the original ones, we can bound any adversaryâ€™s multi-user
advantage by bounding its distinguishing advantage with respect
to the augmented games.
In the rest of this section we gradually set up all the components
needed to apply the H-coefficient technique. We start in Section 6.2
by specifying the format of transcripts with respect to the aug-
mented games. In Section 6.3 we define six sets of bad transcripts.
In Section 6.4 we bound the H-coefficient over good transcripts,
and in Section 6.5 we bound the probability of each individual set
of bad transcripts. Then plugging the two bounds into Theorem 2.2
yields the desired result.
Finally we note that the bound we obtain here is actually strong-
er than the simplified version we presented in Theorem 6.1 for
better exposition. In particular, the third and fourth terms in the
bound in Theorem 6.1 are more accurately given by
2ğ‘ Â· (ğ‘› âˆ’ ğ‘˜) ğœğ‘’
2ğ‘˜
+ 2ğ‘ğ‘£ Â· ((ğ‘› âˆ’ ğ‘˜) ğ‘ + 2ğ‘¡ ğ‘ + 2ğ‘¡ ğ‘‘)
(cid:109) and ğ‘–
(cid:108)
2ğ‘˜
,
with the shorthand notation ğ‘– ğ‘
= 0,
for any ğ‘–, ğ‘ âˆˆ N. Note that always ğ‘– ğ‘ â‰¤ ğ‘–, yielding the terms in
Theorem 6.1.
max(1,ğ‘–âˆ’log2(2ğ‘))
=
ğ‘–
0
6.2 Transcripts and Multi-Sets
In the H-coefficient technique, we only need to consider attainable
transcripts, i.e., ones that have a probability strictly greater than 0
of occuring in the ideal world. Note that here we define transcripts
slightly differently, as we include additional information beyond
the input-output pairs corresponding to the adversaryâ€™s queries.
We define them this way to facilitate the classification of good and
bad transcripts and other aspects in the proof.
Transcripts. A transcript ğœ of an adversary interacting with an aug-
mented game consists of the following entries:
â€¢ Revealed key entries: (key, ğ‘–, ğ¾ğ‘–).
Keys are returned as part of the output to the Reveal query. In
the real world, these entries correspond to the actual user keys,
whereas in the ideal world they correspond to values sampled
independently of the rest of the transcript. In the real augmented
game these are generated during initialization, whereas in the
ideal augmented game they are not sampled until Reveal is
queried.
â€¢ Ideal permutation entries: (prim, ğ‘¥, ğ‘¦,+) and (prim, ğ‘¥, ğ‘¦,âˆ’).
An entry (prim, ğ‘¥, ğ‘¦,+) corresponds to a query Prim(ğ‘¥) to the
ideal permutation oracle with answer ğ‘¦, and an entry (prim, ğ‘¥, ğ‘¦,
âˆ’) corresponds to a query Primâˆ’1(ğ‘¦) to the inverse of the ideal
permutation oracle with answer ğ‘¥.
â€¢ Encryption entries: (enc, ğ‘–, ğ‘ , ğ´ğ·, ğ‘€, ğ¶âˆ¥ğ‘‡ , ğ‘‰ (ğ‘)).
These entries contain the values specified in each encryption
query Enc(ğ‘–, ğ‘ , ğ´ğ·, ğ‘€) together with the corresponding re-
sponse ğ¶âˆ¥ğ‘‡ . They additionally include the associated list ğ‘‰ (ğ‘) of
internal ChaCha20 block function calls made by the encryption
algorithm in that encryption query. In particular, the ğ‘‰ (ğ‘) values
contain the key material used in Poly1305_Mac. Note, however,
that while in the transcript, for convenience, we include ğ‘‰ (ğ‘)
in the encryption entries they are not actually returned to the
adversary by the encryption oracle. In the augmented games
these values are only revealed to the adversary at the end in the
Reveal query. In the ideal world, ğ‘‰ (ğ‘) is instead generated at
random, as described in Figure 5, so that all good transcripts
(defined below) have a probability strictly greater than 0 of occur-
ring in the real world. This, in turn, ensures that the H-coefficient
is not zero. Intuitively, including ğ‘‰ (ğ‘) in the transcript allows
us to better define the set of bad transcripts for our proof and
thereby get a better H-coefficient ratio.
â€¢ Verification entries: (vf, ğ‘–, ğ‘ , ğ´ğ·, ğ¶âˆ¥ğ‘‡ , false).
Entries of this type correspond to verification queries Vf(ğ‘–, ğ‘ ,
ğ´ğ·, ğ¶âˆ¥ğ‘‡) which return false as an answer. In the H-coefficient
technique, we only need to be concerned with attainable tran-
scripts, and in the ideal world, verification queries always return
false as an answer.
Multi-Sets. The H-coefficient technique requires us to bound from
below the ratio of the real-world and ideal-world probabilities, for
any good transcript, to a value close to one. We accomplish this via
a counting argument. In addition to the probability of the user keys
being sampled, the probability of a transcript can be reduced to
counting the number of distinct ideal permutation calls and random
blocks generated (for encryption queries in the ideal world). If
their sum is close in either world, we obtain a good H-coefficient
ratio that is close to one. To facilitate our counting argument we
introduce the following three multi-sets (sets where elements can
repeat) and calculate their cardinality:
ğ‘†1(ğœ) = {(ğ‘¥, ğ‘¦) | (prim, ğ‘¥, ğ‘¦, Â·) âˆˆ ğœ}.
This set contains the input-output pairs, associated with the ideal
permutation ğœ‹, called during the ideal permutation queries Prim
or Primâˆ’1.
ğ‘†2(ğœ) = {(ğ‘âˆ¥ğ¾ğ‘–âˆ¥0âˆ¥ğ‘ , ğ‘‰0 (32)âˆ’ (ğ‘âˆ¥ğ¾ğ‘–âˆ¥0âˆ¥ğ‘)), . . . ,
(32)âˆ’ (ğ‘âˆ¥ğ¾ğ‘–âˆ¥â„“âˆ¥ğ‘)) |
(ğ‘âˆ¥ğ¾ğ‘–âˆ¥â„“âˆ¥ğ‘ , ğ‘‰â„“
(enc, ğ‘–, ğ‘ , ğ´ğ·, ğ‘€, ğ¶âˆ¥ğ‘‡ , ğ‘‰0âˆ¥ Â· Â· Â· âˆ¥ğ‘‰â„“) âˆˆ ğœ}.
This set contains the input-output pairs, associated to the ideal
world with the random blocks generated and in the real world with
the ideal permutation ğœ‹, that was called during the encryption
queries Enc.
ğ‘†3(ğœ) = {(ğ‘âˆ¥ğ¾ğ‘–âˆ¥0âˆ¥ğ‘) | ((vf, ğ‘–, ğ‘ , ğ´ğ·, ğ¶âˆ¥ğ‘‡ , false) âˆˆ ğœ)
âˆ§ ((ğ‘âˆ¥ğ¾ğ‘–âˆ¥0âˆ¥ğ‘ , Â·) âˆ‰ ğ‘†1(ğœ) âˆª ğ‘†2(ğœ))}.
Session 6D: Authentication and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1987Game ğº
augReal-muAE
ğ›± [ğœ‹]
augIdeal-muAE
ğ›± [ğœ‹]
Game ğº
procedure Initialize
1 : ğ‘ğ‘’ â† 0
procedure Enc(ğ‘–, ğ‘ , ğ´ğ·, ğ‘€)
1 : ğ¶ âˆ¥ğ‘‡ â†$ {0, 1}|ğ‘€|+ğ‘¡
2 : ğ‘ğ‘’ â† ğ‘ğ‘’ + 1
3 : ğ‘‰ [ğ‘ğ‘’ ] â† (ğ‘–, ğ‘ , ğ´ğ·, ğ‘€, ğ¶,ğ‘‡)
4 :
procedure Vf(ğ‘–, ğ‘ , ğ´ğ·, ğ¶)
1 :
return ğ¶ âˆ¥ğ‘‡
return false
return ğ¶ âˆ¥ğ‘‡
procedure Initialize
1 : ğ¾1, ğ¾2, Â· Â· Â· â†$ {0, 1}ğ‘˜, ğ‘ğ‘’ â† 0
procedure Enc(ğ‘–, ğ‘ , ğ´ğ·, ğ‘€)
1 : ğ¶ âˆ¥ğ‘‡ â† E(ğ¾ğ‘–, ğ‘ , ğ´ğ·, ğ‘€)
2 : ğ‘ğ‘’ â† ğ‘ğ‘’ + 1
3 : ğ‘‰ [ğ‘ğ‘’ ] â† (ğ‘–, ğ‘ , ğ´ğ·, ğ‘€, ğ¶,ğ‘‡)
4 :
procedure Vf(ğ‘–, ğ‘ , ğ´ğ·, ğ¶)
1 : ğ‘€ â† D(ğ¾ğ‘–, ğ‘ , ğ´ğ·, ğ¶)
return (ğ‘€ â‰  âŠ¥)
2 :
procedure Prim(ğ‘‹)
1 :
procedure Primâˆ’1(ğ‘Œ)
1 :
procedure Reveal
1 :
for ğ‘ = 1 to ğ‘ğ‘’ do
2 :
(ğ‘–, ğ‘ , ğ´ğ·, ğ‘€, ğ¶,ğ‘‡) â† ğ‘‰ [ğ‘]
return ğœ‹âˆ’1(ğ‘Œ)
return ğœ‹ (ğ‘‹)
// last query before Finalize
// last query before Finalize
(ğ‘–, ğ‘ , ğ´ğ·, ğ‘€, ğ¶,ğ‘‡) â† ğ‘‰ [ğ‘]
ğ‘Ÿ â†$ {0, 1}ğ‘¡ ,ğ‘Š â†$ {0, 1}ğ‘›âˆ’2ğ‘¡
ğ‘‰0 â† ğ‘Ÿ âˆ¥(ğ‘‡ (ğ‘¡)âˆ’ ğ»ğ‘Ÿ (ğ´ğ·, ğ¶)) âˆ¥ğ‘Š
ğ‘€1âˆ¥ Â· Â· Â· âˆ¥ğ‘€â„“ â† ğ‘€, ğ¶1âˆ¥ Â· Â· Â· âˆ¥ğ¶â„“ â† ğ¶
for ğ‘— = 1 to â„“ âˆ’ 1 do
return ğœ‹ (ğ‘‹)
return ğœ‹âˆ’1(ğ‘Œ)
procedure Prim(ğ‘‹)
1 :
procedure Primâˆ’1(ğ‘Œ)
1 :
procedure Reveal
1 :
for ğ‘ = 1 to ğ‘ğ‘’ do
2 :
3 :
4 :
5 :
6 :
7 :
ğ‘Š â€² â†$ {0, 1}ğ‘›âˆ’|ğ‘€â„“ |
8 :
ğ‘‰â„“ â† (ğ‘€â„“ âŠ• ğ¶â„“) âˆ¥ğ‘Š â€²
9 :
ğ‘‰ (ğ‘) â† ğ‘‰0âˆ¥ Â· Â· Â· âˆ¥ğ‘‰â„“
10 :
11 : ğ¾1, ğ¾2, Â· Â· Â· â†$ {0, 1}ğ‘˜
12 :
procedure Finalize(ğ‘)
1 :
ğ‘‰ğ‘— â† ğ‘€ğ‘— âŠ• ğ¶ ğ‘—
return ğ‘
return ğ‘‰ (1) , . . . , ğ‘‰ (ğ‘ğ‘’ ) , ğ¾1, ğ¾2, . . .
3 :
4 :
5 :
6 :
ğ‘€1âˆ¥ Â· Â· Â· âˆ¥ğ‘€â„“ â† ğ‘€
for ğ‘— = 0 to â„“ do
ğ‘‰ğ‘— â† ğœ‹ (ğ‘ âˆ¥ğ¾ğ‘– âˆ¥ ğ‘— âˆ¥ğ‘) (32)+ (ğ‘ âˆ¥ğ¾ğ‘– âˆ¥ ğ‘— âˆ¥ğ‘)
ğ‘‰ (ğ‘) â† ğ‘‰0âˆ¥ Â· Â· Â· âˆ¥ğ‘‰â„“
return ğ‘‰ (1) , . . . , ğ‘‰ (ğ‘ğ‘’ ) , ğ¾1, ğ¾2, . . .
7 :
procedure Finalize(ğ‘)
1 :
return ğ‘
Figure 4: Real Augmented Game.
Figure 5: Ideal Augmented Game.
This set contains the inputs to the ideal permutation ğœ‹ called during
verification queries Vf in the real world, if they are not also called
(or obtained) during a primitive or encryption query.
6.3 Bad Transcripts
Our overarching methodology for defining bad transcripts (i.e., the
set ğ‘‡bad) is to rule out transcripts that: 1) have a different multi-set
cardinality in the real world compared to the ideal world or 2) have
zero probability of occurring in the real world. This way we ensure
that the H-coefficient is close to one. Towards the former, we will
ensure that each entry in the first two multi-sets corresponds to a
unique and independent call to the ideal permutation ğœ‹, or a unique
and independently generated random block. In the second case,
even if the transcripts do not result in repeated multi-set entries
they may still be impossible in the real world. Thus a transcript is
in ğ‘‡bad if it satisfies one of the following:
Case 1 (ğ‘¥1, ğ‘¦1) âˆˆ ğ‘†1(ğœ) and (ğ‘¥2, ğ‘¦2) âˆˆ ğ‘†2(ğœ) where ğ‘¥1 = ğ‘¥2. In
this case, in the real world, two calls are made to the ideal
permutation on the same input, through one ideal permu-
tation query and one encryption query. This case also en-
compasses the case where ğ‘¥1 = ğ‘¥2 and ğ‘¦1 â‰  ğ‘¦2, which is
impossible in the real world. From this case, we can define
the following simplified bad transcript description (which
is the only possibility of this case happening):
Bad1: There are two entries (prim, ğ‘¥, ğ‘¦, Â·) and (enc, ğ‘–, ğ‘ ,
ğ´ğ·, ğ‘€, ğ¶âˆ¥ğ‘‡ , ğ‘‰0âˆ¥ Â· Â· Â· âˆ¥ğ‘‰â„“) such that ğ‘¥ âˆˆ {ğ‘âˆ¥ğ¾âˆ¥0âˆ¥ğ‘ , . . . ,
ğ‘âˆ¥ğ¾âˆ¥â„“âˆ¥ğ‘} and ğ¾ğ‘– = ğ¾.
Session 6D: Authentication and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1988Case 2 (ğ‘¥1, ğ‘¦1) âˆˆ ğ‘†1(ğœ) and (ğ‘¥2, ğ‘¦2) âˆˆ ğ‘†2(ğœ) where ğ‘¦1 = ğ‘¦2. In
this case, in the real world, two calls with the same output
are made to the ideal permutation, through one ideal per-
mutation query and one encryption query. This case also