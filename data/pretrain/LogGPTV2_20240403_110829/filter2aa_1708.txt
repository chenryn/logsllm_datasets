Module 1
A journey from high level languages, through 
assembly, to the running process
https://github.com/hasherezade/malware_training_vol1
Running executables: process
Process: basics
Process
• When we run an EXE file, the system creates a Process
Process
• A process is a container for all the resources that the application needs to run
• A process by itself doesn’t run code: threads execute it
• Each process has its own, private address space, that is independent from other 
processes (different processes may have different memory content at the same 
addreses)
• Has its own access token, defining its security context
Process
• Types of processes on Windows:
• System process
• Subsystem process
• Service
• User processes (our applications)
Processes on Windows
From: „Windows Kernel Programming” by Pavel Yosifovich
Process
• A process is identified by its PID (Process ID)
• unique throughout the system at the time of running
• after the process terminates, its PID may be reused by a new process
• Each process has one or more threads. They are identified by Thread IDs. 
• Thread IDs, same as process IDs, are unique throughout the system
• After the thread terminates, its ID may be reused
• Processes may access each other (via handles), if their security context allows it
HANDLE OpenProcess(
DWORD dwDesiredAccess,
BOOL  bInheritHandle,
DWORD dwProcessId // 
Process
• Contains thread(s) running the code – example:
MyApp.exe
NTDLL.DLL
Kernel32.DLL
PID = 789
Communication with the C2 
server
Injecting in the running 
processes
TID = 4278
TID = 985
TID = 223
Main thread
(started at Entry Point of 
application)
Process initialization
Process Initialization
• What happens when we create a process?
BOOL CreateProcessA(
LPCSTR                lpApplicationName,
LPSTR                 lpCommandLine,
LPSECURITY_ATTRIBUTES lpProcessAttributes,
LPSECURITY_ATTRIBUTES lpThreadAttributes,
BOOL                  bInheritHandles,
DWORD                 dwCreationFlags,
LPVOID                lpEnvironment,
LPCSTR                lpCurrentDirectory,
LPSTARTUPINFOA        lpStartupInfo,
LPPROCESS_INFORMATION lpProcessInformation
);
Process Initialization
1.
Create a new process object and allocation of the memory
2.
Map NTDLL.dll and the initial EXE into the memory (MEM_IMAGE)
3.
Create a first thread and allocate a space for it
4.
Resume the first thread: NTDLL.LdrpInitialize function is called
5.
NTDLL.LdprInitialization function:
• Load all imported DLLs -> run each’s DllMain with DLL_PROCESS_ATTACH
• Call Kernel32.BaseProcessStart
6.
Kernel32.BaseProcessStart: calls initial EXE’s Entry Point
Process Initialization
Windows Loader
CreateProcess
-
Creates process and 
allocates a virtual 
memory for its use
-
Loads the initial EXE 
and NDTLL.DLL
-
Creates a first thread 
and the stack for its 
use
Windows Loader
LdrpInitialize
-
Called when the first 
thread resumes
-
Goes through the Import 
Table, loads all required 
DLLs, and initializes them 
(calls DllMain with 
DLL_PROCESS_ATTACH) 
Windows Loader
BaseProcessStart
-
Call Entry Point of the 
original application
The run EXE
Entry Point
-
Execute the code at 
the Entry Point
Process Initialization
Windows Loader
CreateProcess
-
Creates process and 
allocates a virtual 
memory for its use
-
Loads the initial EXE 
and NDTLL.DLL
-
Creates a first thread 
and the stack for its 
use
Windows Loader
LdrpInitialize
-
Called when the first 
thread resumes
-
Goes through the Import 
Table, loads all required 
DLLs, and initializes them 
(calls DllMain with 
DLL_PROCESS_ATTACH) 
Windows Loader
BaseProcessStart
-
Call Entry Point of the 
original application
The run EXE
Entry Point
-
Execute the code at 
the Entry Point
Process Initialization
A process created in a suspended mode – 64 bit example (viewed by Process Hacker)
Before the first 
thread is run, only: 
•
the main EXE
•
NTDLL.DLL
are mapped
Process Initialization
• Notice that if we create a process as suspended, only the first part of the initialization 
process was run...
• This is important for Process Hollowing, that we will review in details later...
Threads
Thread
• Thread is an entity responsible for executing the code
Main thread
(started at Entry Point of 
application)
TID = 223
MyApp.exe
MyApp.exe
Thread
• A thread contains: Context (state of the processor), 2 stacks, TLS (Thread Local Storage), 
may also has its own security token
Main thread
(started at Entry Point of 
application)
TID = 223
Kernel Mode stack
User Mode stack
Context 
Thread Management
• Threads are executed by the processor, and managed by the Operating System (kernel 
mode):
• Scheduler: a kernel mode controler, that decides which thread gets to run for how long and 
performing the context switch
• Additionally, Windows (only 64-bit) implements also User Mode Scheduling (UMS). It is it an optimization to make the 
operation of thread switching less resource-consuming. UMS threads differ from classic threads. They can switch context 
between themselves in user mode, while from the kernel perspective, it looks like one thread is running. Due to this, 
concurrent UMS Threads cannot run on multiple processors. 
Thread Context
• Context switching:
• When the processor is switched to another thread, first its context is saved
• The thread context is a state of the processor when it was run the last time before the switch 
(saved snapshot with all the registers)
• stack space is used to save off current state of thread when context switched
• WindowsAPI allows to retrieve the thread context (but first we need to SuspendThread):
BOOL GetThreadContext(
HANDLE    hThread,
LPCONTEXT lpContext
);
Thread Context
• Example
Main thread
(started at Entry Point of 
application)
TID = 223
MyApp.exe
MyApp.exe
EPROCESS, PEB, TEB...
Stuctures for Process Management
• Process is managed by the Operating System
• To manage the process, Windows uses the following structures: 
• EPROCESS, KPROCESS, ETHREAD, KTHREAD, PEB, TEB...
Stuctures for Process Management
• EPROCESS – the basic kernel-mode structure representing a process
• Contains a linklist of all the threads belonging to the process
• Contains a pointer to the PEB (Process Environment Block) that is available from usermode
• ETHREAD - the basic kernel-mode structure representing a thread
• Contains a pointer to KTHREAD
• Links to the TEB (Thread Environment Block) that is available from usermode
Obtaining PEB
Kernel Mode
User Mode
Obtaining TEB
Kernel Mode
User Mode
Via registry:
FS (32 bit)
GS (64 bit)
PEB and TEB
• We can see PEB and TEB(s) mapped inside the process space (usually towards 
the end of the addresses)
Exercise
• Following the given instructions, walk through the PEB and TEB using WinDbg. 
Familiarize yourself with the fields.