handle = d1open(argv [1] , RTLD_NOw) :
if (handle == NULL) {
printf(*open 1ibrary ts error: $s\n*, argv[1], dlerror()] :
return -1;
func - dlsym(handle, *sin*) ;
if( {error = dlerror{)) 1= NULL 1 {
printf(*Symbo1 sin not found: @s\n*, error):
goto exit_runso;
printf( *$f\n*, fune(3.1415926 / 2) 1;
d1close (handle) :
exit_runso:
$./RunSoSimple /1ib/1ibm-2.6.1.80
1.000000
ldl表示使用 DL 库（Dynamical Loading ），它位于/lib/ibd.so.2。
7.7.5运行时装载的演示程序
或许我们都听说过Windows下有个程序叫做rundll，这个程序可以把Windows的DLL
当作程序来运行。我们知道DLL是Windows的动态链接率，原理上跟Linux下的共享对象
是一种类型的文件（我们将在后面的章节中详细介绍WindowsDLL），rundll 其实就是利用
了运行时加载的原理，将指定的共享对象在运行时加载进来，然后找到某个函数（DLL中
是DlIMain）开始执行。我们这个例子中将实现一个更为灵活的叫做runso的程序，这个程
序可以通过命令行来执行共享对象里面的任意一个函数。它在理论上很简单，基本的步骤就
是：由命令行给出共享对象路径、函数名和相关参数，然后程序通过运行时加载将该模块加
载到进程中，查找相应的函数，并且执行它，然后将执行结果打印出来。但是这里有一个很
程序员的自我修养一链接、装载与库
---
## Page 249
226
第7章动态链接
大的问题是：不同的函数有不同的参数和返回值类型，即有不同的函数签名。当我们需要运
行某个指定的函数时，仅仅知道它的地址是不够的，还必须知道它的函数签名，这些信息是
无法通过运行时加载获得的（很多高级语言（平台）如Java、.NET里面的反射功能可以实
现运行时获得函数的额外信息，包括参数、返回值类型等），因为C/C++编译器在编译时并
没有把这些信息也保存到目标文件、可执行文件或者共享对象等，我们仅仅能获得的是函数
的地址。从这一点来看，C/C++的确不能被称为“高级”语言。
对于上面无法得知函数类型的间题，我们只能通过调用者指定函数的参数和返回值类型
来实现。比如我们规定RunSo的使用方式如下：
$RunSo /lib/foobar.ao function arg1 arg2 ... return_type
为了表示参数和返回值类型，我们假设字母d表示double、i表示int、s表示char*、v
表示void，然后我们在参数之前加一个字母表示参数的类型：
$./Run8o /1ib/1ibm-2.6.1.8o sin d2.0 d
这就表示我们希望调用/ib/libm-2.6.1.so里面的 sin函数，其中第一个参数是double类型
的，参数值是2.0：最后一个字母d表示sin函数的返回值是double类型的。那么如果要调
用/ib/libfoo.so 里面一个 void bar(char* str,int i)的函数可以使用如下命令行：
$./Run8o /1ib/1ibfoo.so bar sHe11o 110 v
上面的命令相当于调用bar(“Hello"，10)。函数的类型我们已经通过手工指定可以得知
了，但在RunSo的实现上还有一个间题存在。
我们上面的例子中，sin函数的类型是程序员手工指定的，也就是我们知道数学库里面
有这样一个 sin函数，它的类型是double sin（double)，于是我们定义了一个指向这种类型的
函数指针double（*func（double）。但是如果要做到调用任意一个函数，我们不可能为每种函
数都定文相同类型的函数指针，然后去调用它，因为函数参数的组合有无数种。为了解决这
个问题，我们必须了解函数调用的约定（具体参照后面的函数调用约定），然后在调用函数
之前伪造好相应的堆栈，造成正常函数调用的假象。为了能够直接操作堆栈，我们不得不使
用嵌入汇编代码来完成相应的操作。下面这个例子就是RunSo的源代码，其中用到了一些
嵌入汇编代码和一些函数调用约定的知识，稍微有点复杂，如果你一时没有看明白可以等看
完“函数调用约定”再回来仔细研究这段代码，就会豁然开朗了。如果对嵌入汇编代码不是
很熟悉，可以再回顾一下最开始我们介绍过的嵌入汇编代码的内容，如下：
#include 
#inc1ude 
#define SETUP_STACK
1 = 2:
while(++1 < argce - 1)(
switch(argv[1][0]) (
程序员的自我修养一链接、装载与库
---
## Page 250
7.7显式运行时链接
227
case 'i':
asm volatile(*push$0*
*r*(atoi(&argv[i][1])]);
break;
e8p += 4;
case 'd′:
atof (&argv[i][1]) ;
a8m volatile(*subl $8, $esp\n*
*fstpl（esp)·）;
esp += 8;
break;
case 's':
asm volatile(*push #0*::
*r*(&argv[i][1]) :
esp += 4;
default1
break;
printf (*error argume
goto exit_runso;
mttype
#define RESTORE_STACK
asn volatile (*add $0, $tesp*::*r*(esp1)
int main(int argc, char* argv[1)
char* error:
ratpueu pto
int i;
void* func;
int esp = 0;
handle = dlopen (argv [11 , RTLD_Now) :
if (handle == 0) {
printE(*Can’t find 1ibrary: ts\n*, argv[1]);
return -1;
F
func = dlsym(handle, argv[2]);
if( (error = dlerror())
printf(*Find symbol 鲁s error: ts\n*, argv[2]。 error);
1= NULL }{
goto exit_runeo;
switch (argv[arge-1)[0]) {
case 'i':
int (*func_int) () = fune;
f()auoumg = sax au
SETUP_STACK;
printf(*ret = td\n*, ret 1;
RESTORE_STACK;
break;
case 'd':
程序员的自我修养——链接、装载与库
---
## Page 251
228
第7章动态链接
double (*func_double) (1 • func;
double ret = fune_double(1 ;
SETUP_STACK;
printf(*ret - f\n*, ret );
RESTORE_STACK;
break;
case 's′:
char* (*fune_str) () - func;
char* ret - func_str(1;
SETUP_STACK;
RESTORE_STACK;
printf(*ret = $s\n*, ret );
break;
case 'v':
void (*fune_void)(1 - func;
SETUP_STACK
func_void() ;
printf (*ret = void*);
RESTORE_STACK;
break:
} // end of switch
exit_runso:
d1c1ose (handle) :
7.8本章小结
本章我们首先分析了使用动态链接技术的原因，即使用动态键接可以更加有效地利用内
存和磁盘资源，可以更加方便地维护升级程序，可以让程序的重用变得更加可行和有效。接
着我们介绍了动态链接的基本例子，分析了动态链接中装载地址不确定时如何解决绝对地址
引用的向题。
装载时重定位和地址无关代码是解决绝对地址引用问题的两个方法，装载时重定位的缺
点是无法共享代码段，但是它的运行速度较快：而地址无关代码的缺点是运行速度稍慢，但
它可以实现代码段在各个进程之间的共享，我们还介绍了ELF的延迟绑定PLT技术。
接着我们介绍了ELF文件中的“interp”、“dyanmic”、动态符号表、重定位表等结构，
它们是实现ELF动态链接的关键结构。我们还分析了动态链接器如何实现自举、装载共享
对象、实现重定位和初始化过程，实现动态髓接。最后我们还介绍了显式动态链接的概念，
并且举例展示了如何使用显式运行时链接编写一个程序运行ELF共享库中的函数。
程序员的自我修养一—链接、装载与库
---
## Page 252
Linux共享库的组织
8.1共享库版本
8.2符号版本
8.3共享库系统路径
8.4共享库查找过程
8.5环境变量
8.6共享库的创建和安装
8.7本章小结
程序员的自我修养——链接、装载与库
---
## Page 253
230
第8章Linux共享库的组织
由于动态链接的诸多优点，大量的程序开始使用动态链接机制，导致系统里面存在数量
极为庞大的共享对象。如果没有很好的方法将这些共享对象组织起来，整个系统中的共享对
象文件则会散落在各个目录下，给长期的维护、升级造成了很大的问题。所以操作系统一般
会对共享对象的目录组织和使用方法有一定的规则，我们将在这一章介绍Linux下共享库的
管理问题，
这里先澄清一个说法，即共享库（SharedLibrary）的概念，其实从文件结构上来讲，
共享库和共享对象没什么区别，Linux下的共享库就是普通的ELF共享对象。由于共享对象
可以被各个程序之间共享，所以它也就成为了库的很好的存在形式，很多库的开发者都以共
享对象的形式让程序来使用，久面久之，共享对象和共享库这两个概念已经很模期了，所以
广文上我们可以将它们看作是同一个概念。
8.1共享库版本
8.1.1共享库兼容性
共享库的开发者会不停地更新共享库的版本，以修正原有的Bug、增加新的功能或改进
性能等。由于动态链接的灵活性，使得程序本身和程序所依赖的共享库可以分别独立开发和
更新，比如当有程序A依赖于libfoo.so，当libfoo.so的开发者宣布新版本开发完成之后，理
论上我们只需要用新的libfoo.so将旧版本的替换掉即可享用新版libfoo.so提供的一切好处。
但是共享库版本的更新可能会导致接口的更改或删除，这可能导致依赖于该共享库的程序无
法正常运行。最简单的情况下，共享库的更新可以被分为两类。
·兼容更新。所有的更新只是在原有的共享库基础上添加一些内容，所有原有的接口都
保持不变。
·不兼容更新。共享库更新改变了原有的接口，使用该共享库原有接口的程序可能不能
运行或运行不正常。
论的接口是二进制接口，即 ABl（Application Binary Interface）。共享库的 ABI跟程序语言
有着很大的关系，不同的语言对于接口的兼容性要求不同。ABI对于不同的语言来说，主要
包括一些诸如函数调用的堆栈结构、符号命名、参数规则、数据结构的内存分布等方面的规
则。那么对于一个C语言编写的共享库来说，什么样的更改会导致ABI变化呢？表8-1列
举了几种常见的更改方式。
程序员的自我修养一链接、装载与库
---
## Page 254
8.1共享库版本
231
表8-1
更改类型
兼容性
往共享库ibfoo.so里面添加一个导出符号foo2
兼容
删除共享库libfoo.so里面一个原有的导出符号foo
不兼容
将 libfoo.so给一个导出函数添加一个参数，比如原来的 foo(int a)变成了 foo(int a
int b)
不兼容
删除一个导出函数中的—个参数，如原来的 foo(int a,int b）变成了 foo(int a）
不兼容
如果一个结构类型被用于一个导出函数或导出全局变量，那么改变结构类型的长
度、内客、成员类型，如 libfoo.so 有导出函数 foo(struct bar b)，而 bar 的结构被
不兼容
践变
修正一个导出函数申的Bug，或者改进策个导出函数的性能，但是不改变导出函
数的语义、功能、行为和接口类型
兼容
修正一个导出函数中的Bug，或者改进某个导出函数的性能，但是同时改变了导
出函数的语义、功能、行为或接口类型
不兼容
导致C语言的共享库ABI改变的行为主要有如下4个：
·导出函数的行为发生改变，也就是说调用这个函数以后产生的结果与以前不一样，不
再满足旧版本规定的函数行为准则。
·导出函数被删除
·导出数据的结构发生变化，比如共享库定义的结构体变量的结构发生改变：结构成员
删除、顺序改变或其他引起结构体内存布局变化的行为（不过通常来讲，往结构体的
尾部添加成员不会导致不兼容，当然这个结构体必须是共享库内部分配的，如果是外
部分配的，在分配该结构体时必须考虑成员添加的情况）。
·导出函数的接口发生变化，如函数返回值、参数被更改。
如果能够保证上述4种情况不发生，那么绝大部分情况下，C语言的共享库将会保持
ABI兼容。注意，仅仅是绝大部分情况，要破坏一个共享库的ABI十分容易，要保持ABI
的兼容却十分困难。很多因素会导致ABI的不兼容，比如不同版本的编译器、操作系统和
硬件平台等，使得ABI兼容尤为困难。使用不同版本的编译器或系统库可能会导致结构体
的成员对齐方式不一致，从而导致了ABI的变化。这种ABI不兼容导致的问题可能非常微
妙，表面上看可能无关紧要，但是一旦发生故障，相关的Bug非常难以定位，这也是共享
库很人的一个间题。