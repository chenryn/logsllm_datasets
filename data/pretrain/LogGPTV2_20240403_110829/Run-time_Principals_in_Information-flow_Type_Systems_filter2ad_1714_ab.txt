data must be in the intersection of the reader permissions. For example, data
labeled with the two reader permissions Alice:Bob, Charles and Bob:Charles, Eve
will be readable only by Charles and Bob.1
The information-ﬂow type system described below ensures that data with a given
conﬁdentiality policy will only ﬂow to destinations with labels that are at least as
restrictive as the policy (see the discussion of the label lattice below). This label
model is decentralized in the sense that each principal may specify reader sets
independently.
The integrity part of a label consists of a set of principals that trust the data.2 For
integrity, the information-ﬂow analysis ensures that less trusted data (trusted by
fewer principals) is never used where more trusted data is necessary. For example,
data whose integrity label is the set Alice,Bob is trusted by Alice and by Bob but
not by Charles.
Collecting the descriptions above, we arrive at the following formal syntax for
reader policies c, conﬁdentiality policy sets d, and labels l. The integrity part of a
label is separated from the conﬁdentiality part by ‘!’:
c ::= p:s
d ::= ·
| c;d
l ::= {d!s}
2.2 Acts-for hierarchy
The decentralized label model also includes delegation embodied by a binary acts-
for relation (cid:22) between principals. This relation is reﬂexive and transitive, yielding
1Or, more precisely, principals that can act for Charles or Bob; see the discussion of the acts-for
hierarchy in Section 2.2.
2It would be possible to give a version of integrity fully dual to the owners–readers model by using
an owners–writers model, but there do not seem to be compelling reasons to do so [Li et al. 2003].
ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.
·
6
Stephen Tse and Steve Zdancewic
a preorder on principals. The notation p (cid:22) q indicates that principal q acts for
principal p, or, conversely, that p delegates to q.
The acts-for relation is taken into account when determining the restrictions im-
posed by a label. For example, consider the labels {Alice:!Alice} and {Bob:!Bob}.
These labels describe data readable and trusted only by Alice and Bob, respectively.
However, if the relation Alice (cid:22) Bob is in the acts-for relation, then data with label
{Alice:!Alice} will be readable by Bob—because Bob acts for Alice, Bob can read
anything that Alice can read. Bob does not trust the integrity of data with label
{Alice:!Alice}—Alice’s trust in the data does not imply Bob’s trust. Alice does
trust data with label {Bob:!Bob}, again because Bob acts for Alice, anything Bob
trusts Alice does too. Note that even though Alice does not own or read data with
label {Bob:!Bob}, her trust of such data will eﬀect the robustness of her privileged
operations (see Section 4).
Formally, an acts-for hierarchy ∆ is a set of p (cid:22) q constraints. ∆ is closed if
it contains no principal variables. To make it easier to distinguish closed acts-for
hierarchies from potentially open ones, we use the notation A rather than ∆ to
mean a closed hierarchy.
We assume the existence of a unique most powerful principal > (called top).
We write ∆ ‘ p (cid:22) q if principal q acts for principal p according to hierarchy ∆,
or formally, if the reﬂexive, transitive closure of ∆ contains p (cid:22) q, or if q = >.
Principal > acts for all other principals: for all principals p and all hierarchies ∆,
we have ∆ ‘ p (cid:22) >.
The notation ∆ ‘ s1 (cid:22) s2 extends this delegation relation to sets of principals:
the set of principals s2 can act for the set of principals s1 if for each principal p ∈ s1
there exists a principal q ∈ s2 such that ∆ ‘ p (cid:22) q. We write ∆ ‘ s1 u s2 to be the
meet of s1 and s2, that is, the largest s3 such that ∆ ‘ s3 (cid:22) s1 and ∆ ‘ s3 (cid:22) s2.
2.3 Label lattice
A label l1 is less restrictive than a label l2 according to an acts-for hierarchy ∆,
written ∆ ‘ l1 v l2, when l1 permits more readers and is at least as trusted.
Formally, this relation is deﬁned in according to these two rules (adapted from
Myers and Liskov [2000] but extended to include integrity sets):
∀c1 ∈ d1. ∃c2 ∈ d2. ∆ ‘ c1 v c2 ∆ ‘ s2 (cid:22) s1
∆ ‘ {d1!s1} v {d2!s2}
∆ ‘ p1 (cid:22) p2 ∆ ‘ s2 (cid:22) s1
∆ ‘ p1:s1 v p2:s2
We write ∆ ‘ l1 6v l2 if it is not the case that ∆ ‘ l1 v l2. This negation
is well deﬁned because the problem of determining the v relation is (eﬃciently)
decidable—it reduces to a graph reachability problem over the ﬁnite acts-for hier-
archy.
The labels of the DLM form a distributive, join-semi lattice, with join operation
given by
∆ ‘ {d1!s1} t {d2!s2} def= {d1 ∪ d2!s3}
if ∆ ‘ s1 u s2 = s3
The intuition is that the v relation describes legal information ﬂows, and the 6v
relation describes the illegal information ﬂows that should not be permitted in a
ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.
Run-time Principals in Information-ﬂow Type Systems
·
7
secure program. According to these rules, the following example label inequalities
can be derived:
· ‘ {Alice:Bob!} v {Alice:!}
· ‘ {Alice:!} 6v {Alice:Bob!}
· ‘ {!Alice, Bob} v {!Alice}
· ‘ {!Alice} 6v {!Alice, Bob}
Alice (cid:22) Bob ‘ {Alice:!} v {Bob:!}
Alice (cid:22) Bob ‘ {Bob:!} 6v {Alice:!}
∆ ‘ {!>} v l
∆ ‘ l v {>:!}
(for all ∆ and l)
(for all ∆ and l)
These inequalities show that there is a top-most label {>:!} (owned by >, read-
able and trusted by no principals) and that the bottom of the label lattice is {!>}
(completely unconstrained readers, trusted by all principals). Data with a less
restrictive label may always be treated as having a more restrictive label.
3. RUN-TIME PRINCIPALS
This section describes the language λRP, a variant of the typed λ-calculus with
information-ﬂow policies drawn from the label lattice described above. In order to
focus on run-time principals, λRP does not address several aspects of information
ﬂow. First, all programs in λRP terminate, thus it precludes termination channels.
Second, λRP does not have state, so no information channels may arise through
the shared memory. Third, the analysis presented here does not consider timing
channels. The type system could be extended to remove all of these limitations
using known techniques [Volpano et al. 1996; Agat 2000; Sabelfeld and Sands 2001;
Pottier and Simonet 2002; Zdancewic and Myers 2002].
Security types, plain types, program terms and values of the language are deﬁned
according to the grammars in Figure 1. Like in previous information-ﬂow languages,
computation in λRP is described by security types (t), which are plain types (u)
annotated with a label (l).
The unit, sum, and function types are standard [Pierce 2002]. There is only one
value, written *, of type 1. Sum values are created by tagging another value v with
either the left or right tag: inl v and inr v, respectively. The case expression
branches on the tag of a sum value. Function values, of type t1 → t2 are λ-
abstractions of the form λx : t. e, where x is the formal parameter that is bound
within expression e, the body of the function. Function application is written by
juxtaposition of expressions.
By convention, if the label is omitted from a plain type, we take it to be the
minimal label, {!>}. For example, the type 1{!>} can be written 1. We encode
def= (1 + 1)l such that true def= inl * and false def=
Booleans with label l to be booll
inr *. The expression if (e) e1 e2 is encoded as case e (λx1 : 1. e1) (λx2 : 1. e2),
for some fresh names x1 and x2.
The last two kinds of types, Pp and ∀α (cid:22) p. t, are the new features related
to run-time principals. The run-time representation of a principal such as Alice
may be a public key or some other structured data, but for now we treat these
representations as abstract. The only value of type PAlice is the constant Alice.
That is, Pp is a singleton type [Aspinall 1994]; such types have previously been
ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.
·
8
Stephen Tse and Steve Zdancewic
t ::= ul
u ::=
1
t + t
t → t
Pp
∀α (cid:22) p. t
∃α (cid:22) p. t
e ::=
v ::=
E ::=
v
x
inl e
inr e
case e v v
e e
if (e (cid:22) e) e e
e [p]
open (α, x) = e in e
*
inl v
inr v
λx: t. e
X
Λα (cid:22) p. e
pack (p (cid:22) p, v)
inl E | inr E | case E v v
| E e | v E
| E [p]
| if (E (cid:22) e) e e | if (v (cid:22) E) e e
| open (α, x) = E in e
Security types
Plain types
unit
sum
function
principal
universal
existential
Terms
value
variable
left injection
right injection
sum case
application
if delegation
instantiation
opening
Values
unit
left injection
right injection
function
principal name
polymorphism
packing
Evaluation contexts
Fig. 1. Syntax of types, terms, and values for λRP
used to represent other kinds of run-time type information [Crary et al. 2002]. A
program can perform a dynamic test of the acts-for relation between Alice and Bob
using the expression if (Alice (cid:22) Bob) e1 e2.
The type ∀α (cid:22) p. t is a form of bounded quantiﬁcation [Pierce 2002] over prin-
cipals.3 This type introduces a principal variable, and it describes programs for
3It might be useful in practice to add lower bounds or multiple bounds, but we do not investigate
them here.
ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.
Run-time Principals in Information-ﬂow Type Systems
·
9
which the static information about principal α is that the acts-for relation α (cid:22) p
holds. For example, the type t0 = ∀α (cid:22) Alice. bool{α:!} → bool{α:!} describes
functions whose parameter and return types are Booleans owned by any principal
for whom Alice may act.
Term-level expressions generalize the principal variable α using the syntax Λα (cid:22)
p. e. If f is such a function of the type t0 given above, and if the acts-for hierar-
chy establishes that Bob (cid:22) Alice, we may call f by instantiating α with Bob by
f [Bob] true. A bound of > in a polymorphic type, as in ∀α (cid:22) >. t, expresses a
policy parameterized by any principal, because all principals satisfy the constraint
p (cid:22) >. For convenience, we deﬁne the syntactic sugar ∀α. t def= ∀α (cid:22) >. t and
Λα. e def= Λα (cid:22) >. e.
This kind of polymorphism over principals, in conjunction with the singleton
principal types, provides a connection between the static type system and the pro-
gram’s run-time tests of the acts-for hierarchy. Consider the following program g,
which is similar to the printIfManager example in Section 1:
g : ∀α. Pα → (bool{α:!} → 1) → bool{M :!} → 1
g = Λα. λuser : Pα. λprint : bool{α:!} → 1.
λx : bool{M :!}. if (M (cid:22) user) (print x) *
This function is parameterized by the principal variable α. The next parameter is
a run-time principal user that has type Pα, meaning that the static name associated
with the run-time principal user is α. The next two arguments to g are a function
called print, which expects an argument owned by α, and a Boolean value x, owned
by the principal M (here abbreviating Manager). The body of g performs a run-
time test to determine whether user acts for M .
If so, the ﬁrst branch of the
conditional is taken, and the print function is applied to the secret x. Otherwise,
the unit value * is returned.
Another form of quantiﬁcation is existential types ∃α (cid:22) p. t, which are useful
for encapsulating the run-time identity of some principal.4 For example, the Java
API Runtime.getUser in Section 1 can now be given the type 1 → ∃α (cid:22) >. Pα,
which means that the value is a package containing the identity of a principal but
its static type is encapsulated and only its upper bound > is revealed.
These existential types have been traditionally used for encoding modules or
packages [Pierce 2002]. An expression pack (p1 (cid:22) p2, e) hides the principal p1