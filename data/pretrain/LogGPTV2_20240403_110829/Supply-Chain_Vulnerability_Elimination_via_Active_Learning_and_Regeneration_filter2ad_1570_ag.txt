[18] Shivam Handa and Martin C. Rinard. 2020. Inductive program synthesis over
noisy data. Proceedings of the 28th ACM Joint Meeting on European Software
Engineering Conference and Symposium on the Foundations of Software Engineering
(Nov 2020). https://doi.org/10.1145/3368089.3409732
[19] Daniel Hedin, Alexander Sjösten, Frank Piessens, and Andrei Sabelfeld. 2017. A
principled approach to tracking information flow in the presence of libraries. In
International Conference on Principles of Security and Trust. Springer, 49–70.
[20] Kihong Heo, Woosuk Lee, Pardis Pashakhanloo, and Mayur Naik. 2018. Effective
program debloating via reinforcement learning. In Proceedings of the 2018 ACM
SIGSAC Conference on Computer and Communications Security. 380–394.
[21] hugeglass. 2018. GitHub Repository for flatmap-stream.
https://git.io/Jtcdi
Accessed: 2020-12-18.
[22] Susmit Jha, Sumit Gulwani, Sanjit A Seshia, and Ashish Tiwari. 2010. Oracle-
guided component-based program synthesis. In Proceedings of the 32nd ACM/IEEE
International Conference on Software Engineering-Volume 1. ACM, 215–224.
[23] N. Jovanovic, C. Kruegel, and E. Kirda. 2006. Pixy: a static analysis tool for
detecting Web application vulnerabilities. In 2006 IEEE Symposium on Security
and Privacy (S P’06). 6 pp.–263. https://doi.org/10.1109/SP.2006.29
[24] Yoonseok Ko, Tamara Rezk, and Manuel Serrano. [n. d.]. SecureJS Compiler:
Portable Memory Isolation in JavaScript. In SAC 2021-The 36th ACM/SIGAPP
Symposium On Applied Computing.
[25] Igibek Koishybayev and Alexandros Kapravelos. 2020. Mininode: Reducing
the Attack Surface of Node.js Applications. In 23rd International Symposium on
Research in Attacks, Intrusions and Defenses ({RAID} 2020).
[26] Hyungjoon Koo, Seyedhamed Ghavamnia, and Michalis Polychronakis. 2019.
Configuration-Driven Software Debloating. In Proceedings of the 12th European
Workshop on Systems Security. 1–6.
[27] Benjamin Lamowski, Carsten Weinhold, Adam Lackorzynski, and Hermann
Härtig. 2017. Sandcrust: Automatic Sandboxing of Unsafe Components in Rust.
In Proceedings of the 9th Workshop on Programming Languages and Operating
Systems (PLOS’17). ACM, New York, NY, USA, 51–57. https://doi.org/10.1145/
3144555.3144562
[28] Tobias Lauinger, Abdelberi Chaabane, Sajjad Arshad, William Robertson, Christo
Wilson, and Engin Kirda. 2017. Thou Shalt Not Depend on Me: Analysing the
Use of Outdated JavaScript Libraries on the Web. (2017).
[29] SS Jeremy Long. 2015. OWASP Dependency Check. (2015).
[30] Michael Maass. 2016. A Theory and Tools for Applying Sandboxes Effectively. Ph.D.
Dissertation. Carnegie Mellon University.
[31] Jonas Magazinius, Daniel Hedin, and Andrei Sabelfeld. 2014. Architectures for
inlining security monitors in web applications. In International Symposium on
Engineering Secure Software and Systems. Springer, 141–160.
[32] David Mandelin, Lin Xu, Rastislav Bodík, and Doug Kimelman. 2005. Jungloid
mining: helping to navigate the API jungle. ACM Sigplan Notices 40, 6 (2005),
48–61.
[33] Marcela S Melara, David H Liu, and Michael J Freedman. 2019. Pyronia: Redesign-
ing Least Privilege and Isolation for the Age of IoT. arXiv preprint arXiv:1903.01950
(2019).
[34] Leo A Meyerovich and Benjamin Livshits. 2010. ConScript: Specifying and
enforcing fine-grained security policies for Javascript in the browser. In 2010
IEEE Symposium on Security and Privacy. IEEE, 481–496.
[35] James Mickens. 2014. Pivot: Fast, synchronous mashup isolation using generator
chains. In 2014 IEEE Symposium on Security and Privacy. IEEE, 261–275.
[36] Mark S Miller, Mike Samuel, Ben Laurie, Ihab Awad, and Mike Stay. 2009. Caja:
Safe active content in sanitized JavaScript, 2008. Google white paper (2009).
[37] Paul Miller. 2016. How an irate developer briefly broke JavaScript.
https:
//bit.ly/36CkBDI Accessed: 2020-12-10.
[38] Marius Musch, Marius Steffens, Sebastian Roth, Ben Stock, and Martin Johns. 2019.
ScriptProtect: mitigating unsafe third-party javascript practices. In Proceedings
of the 2019 ACM Asia Conference on Computer and Communications Security.
391–402.
[39] Shravan Narayan, Craig Disselkoen, Tal Garfinkel, Nathan Froyd, Eric Rahm,
Sorin Lerner, Hovav Shacham, and Deian Stefan. 2020. Retrofitting Fine Grain Iso-
lation in the Firefox Renderer. In 29th {USENIX} Security Symposium ({USENIX}
Security 20). 699–716.
[40] Nick Nikiforakis, Luca Invernizzi, Alexandros Kapravelos, Steven Van Acker,
Wouter Joosen, Christopher Kruegel, Frank Piessens, and Giovanni Vigna. 2012.
You are what you include: large-scale evaluation of remote javascript inclusions.
In Proceedings of the 2012 ACM conference on Computer and communications
security. 736–747.
[41] npm, Inc. 2018. Details about the event-stream incident. https://blog.npmjs.org/
post/180565383195/details-about-the-event-stream-incident Accessed: 2018-12-
18.
[42] npm, Inc. 2019. Malicious Package: stream-combine. https://www.npmjs.com/
[43] npm, Inc. 2019. Malicious Package: stream-combine. https://www.npmjs.com/
[44] npm, Inc. 2020. Node Package Manager. https://www.npmjs.com/search?q=
advisories/774 Accessed: 2019-01-25.
advisories/765 Accessed: 2019-01-25.
string&ranking=popularity
[45] Jarrod Overson. 2018. BadJS—Malicious JavaScript found in the wild: Event-
Stream. https://badjs.org/posts/event-stream/ Accessed: 2020-12-18.
[46] Giancarlo Pellegrino and Davide Balzarotti. 2014. Toward Black-Box Detection
of Logic Flaws in Web Applications.
[47] Nadia Polikarpova, Ivan Kuraj, and Armando Solar-Lezama. 2016. Program
synthesis from polymorphic refinement types. ACM SIGPLAN Notices 51, 6
(2016), 522–538.
[48] Mohammad Raza and Sumit Gulwani. 2018. Disjunctive Program Synthesis: A
Robust Approach to Programming by Example. In Thirty-Second AAAI Conference
on Artificial Intelligence.
[49] Martin Rinard. 2011. Manipulating program functionality to eliminate security
vulnerabilities. In Moving target defense. Springer, 109–115.
[50] Martin C. Rinard, Jiasi Shen, and Varun Mangalick. 2018. Active Learning for
Inference and Regeneration of Computer Programs That Store and Retrieve Data.
In Proceedings of the 2018 ACM SIGPLAN International Symposium on New Ideas,
Session 6B: Web Vulnerabilities CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1768New Paradigms, and Reflections on Programming and Software (Onward! 2018).
ACM, New York, NY, USA, 12–28. https://doi.org/10.1145/3276954.3276959
[51] José Fragoso Santos and Tamara Rezk. 2014. An information flow monitor-
inlining compiler for securing a core of javascript. In IFIP International Information
Security Conference. Springer, 278–292.
[52] Thomas Hunter II (Intrinsic Security). 2018. Compromised npm Package: event-
https://medium.com/intrinsic/compromised-npm-package-event-
stream.
stream-d47d08605502 Accessed: 2019-03-19.
[53] R. Sekar, V.N. Venkatakrishnan, Samik Basu, Sandeep Bhatkar, and Daniel C.
DuVarney. 2003. Model-Carrying Code: A Practical Approach for Safe Execution
of Untrusted Applications. In Proceedings of the Twenty-Fourth ACM Symposium
on Operating Systems Principles (SOSP ’03). Association for Computing Machinery,
New York, NY, USA, 15–28. https://doi.org/10.1145/945445.945448
[54] Burr Settles. 2009. Active Learning Literature Survey. Computer Sciences Technical
Report 1648. University of Wisconsin–Madison.
[55] Jiasi Shen, Martin Rinard, and Nikos Vasilakis. 2021. Automatic Synthesis of
Parallel Unix Commands and Pipelines with KumQuat. CoRR abs/2012.15443
(2021). arXiv:2012.15443 https://arxiv.org/abs/2012.15443
[56] Jiasi Shen and Martin C. Rinard. 2019. Using Active Learning to Synthesize Models
of Applications That Access Databases. In Proceedings of the 40th ACM SIGPLAN
Conference on Programming Language Design and Implementation (PLDI 2019).
ACM, New York, NY, USA, 269–285. https://doi.org/10.1145/3314221.3314591
[57] Jiasi Shen and Martin C. Rinard. 2021. Active Learning for Inference and Regen-
eration of Applications That Access Databases. ACM Trans. Program. Lang. Syst.
42, 4, Article 18 (Jan. 2021), 119 pages. https://doi.org/10.1145/3430952
[58] Kensen Shi, Jacob Steinhardt, and Percy Liang. 2019. FrAngel: component-based
synthesis with control structures. Proceedings of the ACM on Programming
Languages 3, POPL (2019), 1–29.
[59] Rishabh Singh. 2016. Blinkfill: Semi-supervised programming by example for
syntactic string transformations. Proceedings of the VLDB Endowment 9, 10 (2016),
816–827.
[60] Snyk. 2016. Find, fix and monitor for known vulnerabilities in Node.js and Ruby
packages. https://snyk.io/
[61] Ayrton Sparling et al. 2018. Event-Stream, GitHub Issue 116: I don’t know what
https://github.com/dominictarr/event-stream/issues/116 Accessed:
to say.
2018-12-18.
[62] Cristian-Alexandru Staicu, Michael Pradel, and Benjamin Livshits. 2018. Synode:
Understanding and Automatically Preventing Injection Attacks on Node.js. In
Networked and Distributed Systems Security (NDSS’18). https://doi.org/10.14722/
ndss.2018.23071
[63] Cristian-Alexandru Staicu, Daniel Schoepe, Musard Balliu, Michael Pradel, and
Andrei Sabelfeld. 2019. An empirical study of information flows in real-world
javascript. In Proceedings of the 14th ACM SIGSAC Workshop on Programming
Languages and Analysis for Security. 45–59.
[64] Trent Earl, John Wilkinson, and the Verdaccio contributors. 2018. Verdaccio—npm
Proxy Private Registry. https://verdaccio.org/ Accessed: 2020-11-10.
[65] Nikos Vasilakis, Ben Karel, Nick Roessler, Nathan Dautenhahn, André DeHon,
and Jonathan M. Smith. 2018. BreakApp: Automated, Flexible Application Com-
partmentalization. In Networked and Distributed Systems Security (NDSS’18).
https://doi.org/10.14722/ndss.2018.23131
[66] Nikos Vasilakis, Cristian-Alexandru Staicu, Grigoris Ntousakis, Konstantinos
Kallas, Ben Karel, André DeHon, and Michael Pradel. 2021. Preventing Dynamic
Library Compromise on Node.js via RWX-Based Privilege Reduction. In Pro-
ceedings of the 2021 ACM SIGSAC Conference on Computer and Communications
Security (CCS ’21). Association for Computing Machinery, New York, NY, USA,
18. https://doi.org/10.1145/3460120.3484535
[67] Jerry Wu. 2018. Using dynamic analysis to infer Python programs and convert them
into database programs. Master’s thesis. Massachusetts Institute of Technology.
[68] Navid Yaghmazadeh, Xinyu Wang, and Isil Dillig. 2018. Automated migration of
hierarchical data to relational tables using programming-by-example. Proceedings
of the VLDB Endowment 11, 5 (2018), 580–593.
[69] Serdar Yegulalp. 2016. How one yanked JavaScript package wreaked havoc.
https://bit.ly/3ofwkz2 Accessed: 2020-12-10.
[70] Heng Yin, Dawn Song, Manuel Egele, Christopher Kruegel, and Engin Kirda.
2007. Panorama: Capturing System-Wide Information Flow for Malware Detec-
tion and Analysis. In Proceedings of the 14th ACM Conference on Computer and
Communications Security (CCS ’07). Association for Computing Machinery, New
York, NY, USA, 116–127. https://doi.org/10.1145/1315245.1315261
[71] Nicholas C. Zakas and ESLint contributors. 2013. ESLint—Pluggable JavaScript
linter. https://eslint.org/ Accessed: 2018-07-12.
[72] Markus Zimmermann, Cristian-Alexandru Staicu, Cam Tenny, and Michael Pradel.
2019. Smallworld with High Risks: A Study of Security Threats in the Npm
Ecosystem. In Proceedings of the 28th USENIX Conference on Security Symposium
(SEC’19). USENIX Association, USA, 995–1010.
A PROOF SKETCHES
Definition A.1. (IO-Correctness) Given a function f , the syn-
thesized function f ′ is said to be IO-correct, if and only if, f ′ is
expressible in the Harp DSL (with constants extracted from f ) and
for all input i consistent with the input type of f , f (i) = f ′(i).
Definition A.2. (Consistentency w.r.t. function f , input set I,
and maximum program size n) A synthesized function f ′ is said
to be consistent w.r.t. a function f , input set I of size m containing
inputs consistent with the input type of f , and a maximum program
size n, if f ′ is expressible in the Harp DSL (with constants extracted
from f ) and is of size less than equal to n, and for all inputs i ∈ I:
f (i) = f
′(i)
Note that, given a function f , the IO-correct function f ′ is con-
sistent w.r.t. function f , for any input set I (consistent with the
input type of f ), and any maximum program size n greater than
the size of f ′.
Theorem A.3. (Initial State) For any function f , all functions f ′
in Pn are consistent w.r.t function f , input set I = ∅, and maximum
program size size n. Also, if there exists a function f ′ of size less than
equal to n, which is IO-correct with respect to f , then f ′ ∈ Pn.
Proof. The Harp algorithm extracts all constants from function
f and instantiates all sketches is the Harp DSL of size n. The Type T
(extracted using typeConstraints) is a sound approximation of the
actual output type of f . A function f ′ ∈ Pn if and only if f ′ of size
less than equal to n, is expressible in the Harp DSL (with constants
extracted from f ), and T is a sound approximation of f ′’s output
type. Therefore, given I = ∅, all functions in f ′ ∈ Pn are consistent
with f (input set I = ∅ and max size n).
Also, if there exists a IO-correct function f ′ of size less than
equal to n, then f ′ is consistent with respect to f (I = ∅ and max
size n) and T is a sound approximation of the output type of f ′.
Therefore, if there exists a IO-correct function f ′ of size less than
equal to n, then f ′ ∈ Pn.
□
Theorem A.4. (Consistency) Given a function f ∈ L, let I be
the set of inputs returned by the function generateInputs, Pn be the
set of programs returned by allPrograms, and P be the set of pruned
program pruneSpace. If P (cid:44) ∅ and f ′ is equal to getOpt(P),then f ′
is consistent w.r.t. function f , input set I, and maximum program size
n. Also, if the IO-correct function f ′ ∈ Pn, then f ′ ∈ P.
Proof. pruneSpace only prunes a function f ′ ∈ Pn if and only
if ∃i ∈ I, such that f ′(i) (cid:44) f (i). Therefore, all f ′ ∈ P are consistent
with respect to f (input set I and max size n). The getOpt returns
a function f ′ ∈ P, therefore if the algorithm synthesis a function
f ′ for function f , then f ′ is consistent with respect to f (input set
I and max size n).
pruneSpace will never prune out the IO-correct function f ′ as
for all inputs f (i) = f ′(i). Therefore, if f ′ ∈ Pn, then f ′ ∈ P.
□
Theorem A.5. (Convergence) Given a function f and a maxi-
mum function size n, let Fn be the set of functions in the Harp DSL
of size less than equal to n, such that, a IO-correct function f ′ ∈ Pn.
As we add more inputs to the set of inputs generated by function
generateInputs, Harp will synthesize a function f ′′, such that, f ′′
and f have the same output on an increasing set of inputs.
Session 6B: Web Vulnerabilities CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1769Proof. Pn is equal to the set returned by allPrograms(n,T).
From Theorem A.3, f ′ ∈ Pn. Let I be the set of input set con-
structed by generateInputs. Let PI be the set of programs returned
by the function pruneSpace. Note that if f ′ ∈ P, then for all I,
f ′ ∈ PI (Theorem A.4).
(as for any function f ′′ ∈ PI1
Note that, if I0 ⊆ I1, then PI1 ⊆ PI0
,
then f ′′ has the same output as f on inputs in I0).
A larger set of inputs allows Harp to prune out functions which
do not have the same output as f on this larger set of inputs. There-
fore, by adding more inputs, Harp will synthesize a function f ′′,
such that, f ′′ and f have the same output on an increasing set of
inputs.
□
B ADDITIONAL EVALUATION RESULTS
Non-string-processing Libraries: We also apply Harp on 11
libraries that were misclassified as processing strings, to evalu-
ate Harp’s --quick-abort mechanism. On these libraries, Harp
aborts ALR within 5 seconds with a warning that they contain
side-effectful computations that cannot be learned. Eight of these
libraries import built-in modules that are not supported by Harp
such as debug, http, or fs—for example, minimatch depends on
fs and is thus not inferable. One of these libraries, chalk, depends
indirectly on os and tty for checking the environment for color
ALR P(L′) C(L′)
L
string-upper 2.9s 1.3% 66.7%
2.7s 1.8% 100%
right-trim
2.6s 0.7% 100%
left-trim
lr-trim
46.7s 0.4% 100%
17.1s 0.7% 100%
repeat-text
support and thus it not inferable. Finally, ignore and attn pro-
vide their functionality by extending the runtime context with an
auxiliary value.
C/C++ Libraries: Fig. 7 sum-
marizes results of applying Harp
to 5 C/C++ libraries, including
the time to complete learning
(column ALR), the regenerated-
library performance (column P(L′)
with positive values for slowdown
and negative for speedup), and
its correctness with respect to
the original one (column C(L′), counting percentages of test cases).
These libraries export a single function and are wrapped with
Node’s NAN module [6]. (NAN is an abstraction layer meant to
simplify the development and maintenance of native add-ons over
a constantly changing V8 API.)
Fig. 7: C/C++ ALR. Harp applied
to C/C++ libraries.
Harp’s ALR ranges between 2.6–17.1s (avg.: 14.4s), driven by the
size of the regenerated library. Naturally, the performance of the
regenerated JavaScript libraries is lower that that of the original
compiled libraries, and ranges between 0.4–1.8% (avg.: 1.0%) of the
original library’s runtime performance (Col. P(L′)). Harp regener-
ated full library behavior, except string-upper’s locale-dependent
functionality.
Session 6B: Web Vulnerabilities CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1770