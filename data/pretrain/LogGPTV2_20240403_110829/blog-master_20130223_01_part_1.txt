## PostgreSQL xlog dump - pg_xlogdump 源码讲解 
### 作者               
digoal                
### 日期                
2013-02-23                                          
### 标签                                                                                                                                
PostgreSQL , redo , xlog , dump , pg_xlogdump  
----                
## 背景        
PostgreSQL 9.3 添加了 pg_xlogdump 的功能,  主要用于解析XLogRecord的信息.   
可用于学习了解XLOG.  
## 正文  
XLogRecord的数据结构如下 :   
src/include/access/xlog.h  
```  
00021 /*  
00022  * The overall layout of an XLOG record is:  
00023  *      Fixed-size header (XLogRecord struct)  
00024  *      rmgr-specific data  
00025  *      BkpBlock  
00026  *      backup block data  
00027  *      BkpBlock  
00028  *      backup block data  
00029  *      ...  
00030  *  
00031  * where there can be zero to four backup blocks (as signaled by xl_info flag  
00032  * bits).  XLogRecord structs always start on MAXALIGN boundaries in the WAL  
00033  * files, and we round up SizeOfXLogRecord so that the rmgr data is also  
00034  * guaranteed to begin on a MAXALIGN boundary.  However, no padding is added  
00035  * to align BkpBlock structs or backup block data.  
00036  *  
00037  * NOTE: xl_len counts only the rmgr data, not the XLogRecord header,  
00038  * and also not any backup blocks.  xl_tot_len counts everything.  Neither  
00039  * length field is rounded up to an alignment boundary.  
00040  */  
00041 typedef struct XLogRecord  
00042 {  
00043     uint32      xl_tot_len;     /* total len of entire record */  
00044     TransactionId xl_xid;       /* xact id */  
00045     uint32      xl_len;         /* total len of rmgr data */  
00046     uint8       xl_info;        /* flag bits, see below */  
00047     RmgrId      xl_rmid;        /* resource manager for this record */  
00048     /* 2 bytes of padding here, initialize to zero */  
00049     XLogRecPtr  xl_prev;        /* ptr to previous record in log */  
00050     pg_crc32    xl_crc;         /* CRC for this record */  
00051   
00052     /* If MAXALIGN==8, there are 4 wasted bytes here */  
00053   
00054     /* ACTUAL LOG DATA FOLLOWS AT END OF STRUCT */  
00055   
00056 } XLogRecord;  
```  
用法 :   
```  
pg_xlogdump decodes and displays PostgreSQL transaction logs for debugging.  
Usage:  
  pg_xlogdump [OPTION] [STARTSEG [ENDSEG]]   
General options:  
  -V, --version          output version information, then exit  
  -?, --help             show this help, then exit  
Content options:  
  -b, --bkp-details      output detailed information about backup blocks  
  -e, --end=RECPTR       stop reading at log position RECPTR  
  -n, --limit=N          number of records to display  
  -p, --path=PATH        directory in which to find log segment files  
                         (default: ./pg_xlog)  
  -r, --rmgr=RMGR        only show records generated by resource manager RMGR  
                         use --rmgr=list to list valid resource manager names  
  -s, --start=RECPTR     stop reading at log position RECPTR  
  -t, --timeline=TLI     timeline from which to read log records  
                         (default: 1 or the value used in STARTSEG)  
  -x, --xid=XID          only show records with TransactionId XID  
```  
输出解释, 以下条输出为例 :   
```  
rmgr: Btree       len (rec/tot):     18/  2374, tx:       1686, lsn: 0/0181D8E8, prev 0/0181CFA0, bkp: 1000, desc: insert: rel 1663/  
16385/12599; tid 1/113  
        backup bkp #0; rel 1663/16385/12599; fork: main; block: 1; hole: offset: 476, length: 5892  
```  
以上输出每个部分的详细解释 :   
1\. 该XLogRecord的资源管理器.  
```  
rmgr: Btree  
```  
取自XLogRecord.xl_rmid.   
定义在src/include/access/rmgrlist.h中可以找到. 详见本文参考部分.  
2\. 该XLogRecord的资源管理器的长度以及该XLogRecord的总长度  
```  
len (rec/tot):     18/  2374,  
```  
取自XLogRecord.xl_len和XLogRecord.xl_tot_len  
3\. 该XLogRecord的事务ID(TransactinoId)  
```  
tx:       1686,  
```  
4\. 该XLogRecord在xlog虚拟地址空间中的位置.  
将XLogRecPtr拆成2个UINT32输出. 分别表示  
```  
lsn: 0/0181D8E8,  
```  
xlog文件的命名也与xlog虚拟地址空间有关.  
参考 :   
http://blog.163.com/digoal@126/blog/static/16387704020129159590908/  
http://blog.163.com/digoal@126/blog/static/1638770402012914112949546/  
而在PageHeaderData中pd_lsn存储的是该BLOCK对应的最后一次被改变时记录的xlog虚拟地址空间中的下一个位置  
```  
pd_lsn	XLogRecPtr	8 bytes	LSN: next byte after last byte of xlog record for last change to this page.  
```  
5\. 该XLogRecord的前一条XLogRecord的位置(uint64位虚拟地址空间)  
将XLogRecPtr拆成2个UINT32输出.  
```  
prev 0/0181CFA0,  
```  
6\. 该XLogRecord的disk blocks的备份标记, 每个XLOG Record最多可以记录4个disk blocks.  
```  
00046     uint8       xl_info;        /* flag bits, see below */  
00062 /*  
00063  * XLOG uses only low 4 bits of xl_info.  High 4 bits may be used by rmgr.  
00064  */  
00065 #define XLR_INFO_MASK           0x0F  
00066   
00067 /*  
00068  * If we backed up any disk blocks with the XLOG record, we use flag bits in  
00069  * xl_info to signal it.  We support backup of up to 4 disk blocks per XLOG  
00070  * record.  
00071  */  
00072 #define XLR_BKP_BLOCK_MASK      0x0F    /* all info bits used for bkp blocks */  
bkp: 1000,  
```  
7\. 描述信息, 根据不同的资源管理器, 描述信息不同.  
例如本条记录的资源管理器为Btree.  
```  
desc: insert: rel 1663/16385/12599; tid 1/113  
```  
Btree描述信息取自 contrib/pg_xlogdump/nbtdesc.c  
```  
out_target(StringInfo buf, xl_btreetid *target)  
{  
        appendStringInfo(buf, "rel %u/%u/%u; tid %u/%u",  
                         target->node.spcNode, target->node.dbNode, target->node.relNode,  
                                         ItemPointerGetBlockNumber(&(target->tid)),  
                                         ItemPointerGetOffsetNumber(&(target->tid)));  
}  
```  
包含表空间/数据库/对象的节点信息.  
该索引数据块号码和OFFSET号.  
以下是XLogRecord中包含的备份disk block的详细信息. 每个XLogRecord中最多4条.  
数据结构如下 :   
src/include/access/xlog_internal.h  
```  
00030 /*  
00031  * Header info for a backup block appended to an XLOG record.  
00032  *  
00033  * As a trivial form of data compression, the XLOG code is aware that  
00034  * PG data pages usually contain an unused "hole" in the middle, which  
00035  * contains only zero bytes.  If hole_length > 0 then we have removed  
00036  * such a "hole" from the stored data (and it's not counted in the  
00037  * XLOG record's CRC, either).  Hence, the amount of block data actually  
00038  * present following the BkpBlock struct is BLCKSZ - hole_length bytes.  
00039  *  
00040  * Note that we don't attempt to align either the BkpBlock struct or the  
00041  * block's data.  So, the struct must be copied to aligned local storage  
00042  * before use.  
00043  */  
00044 typedef struct BkpBlock  
00045 {  
00046     RelFileNode node;           /* relation containing block */  
00047     ForkNumber  fork;           /* fork within the relation */  
00048     BlockNumber block;          /* block number */  
00049     uint16      hole_offset;    /* number of bytes before "hole" */  
00050     uint16      hole_length;    /* number of bytes in "hole" */  
00051   
00052     /* ACTUAL BLOCK DATA FOLLOWS AT END OF STRUCT */  
00053 } BkpBlock;  
```  
8\. 备份数据块的信息, 前面提到了每条XLogRecord中最多可存储4个备份disk block的信息.  从bkp 0开始编号.  
```  
backup bkp #0;    
```  
代码如下 :   
```  
        if (config->bkp_details)  
        {  
                int                     bkpnum;  
                char       *blk = (char *) XLogRecGetData(record) + record->xl_len;  
                for (bkpnum = 0; bkpnum xl_info))  
                                continue;  
                        memcpy(&bkpb, blk, sizeof(BkpBlock));  
                        blk += sizeof(BkpBlock);  
                        blk += BLCKSZ - bkpb.hole_length;  
                        printf("\tbackup bkp #%u; rel %u/%u/%u; fork: %s; block: %u; hole: offset: %u, length: %u\n",  
                                   bkpnum,  
                                   bkpb.node.spcNode, bkpb.node.dbNode, bkpb.node.relNode,  
                                   forkNames[bkpb.fork],  
                                   bkpb.block, bkpb.hole_offset, bkpb.hole_length);  
                }  
        }  
```  
9\. 该备份disk block的表空间/数据库/对象节点信息.  
```  
rel 1663/16385/12599;  
```  
10\. 该备份disk block对应的对象的fork类型, 这个不了解的话可以去看一下相关的手册.  
http://www.postgresql.org/docs/devel/static/storage.html  