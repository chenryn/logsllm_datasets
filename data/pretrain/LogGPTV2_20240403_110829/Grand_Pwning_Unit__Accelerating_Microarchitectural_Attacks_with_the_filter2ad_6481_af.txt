Unfortunately, such PMU functionalities are not available on
ARM platforms and, as a result, detecting Rowhammer events
will be very costly, if at all possible. But given the extent of
the vulnerability and the fact that we could trigger bit ﬂips in
the browser on all three phones we tried, we urgently need
software-based defenses against GPU-accelerated attacks.
As discussed in Section VIII, to exploit Rowhammer bit
ﬂips, an attacker needs to ensure that the victim rows are
reused to store sensitive data (e.g., pointers). Hence, we
can prevent an attacker from hammering valuable data by
enforcing stricter policies for memory reuse. A solution may
be enhancing the physical compartmentalization initiated by
CATT [8] to userspace applications. For example, one can
deploy a page tagging mechanism that does not allow the reuse
of pages tagged by an active WebGL context. By isolating
pages that are tagged by an active WebGL context using guard
rows [8], one can protect the rest of the browser from potential
bit ﬂips that may be caused by these contexts.
There are trade-offs in terms of complexity, performance,
and capacity with such a solution. Implementing a basic
version of such an allocator with statically-sized partitions
for WebGL contexts is straightforward, but not ﬂexible as it
wastes memory for contexts that do not use all the allocated
pages. Dynamically allocating (isolated) pages increases the
complexity and has performance implications. We intend to
explore these trade-offs as part of our future work.
XI. RELATED WORK
Olson et al. [37] provide a taxonomy of possible integrated
accelerators threats classiﬁed based on the conﬁdentiality,
integrity and availability triad. They discuss that side-channel
and fault attacks can potentially be used to thwart the con-
ﬁdentiality and integrity of the system. To the best of our
knowledge, the attacks presented in this paper are the ﬁrst
realization of these attacks that make use of timing information
and Rowhammer from integrated GPUs to compromise a
mobile phone. While there has been follow up work that
shields invalid memory accesses from accelerators [36], we
believe further research is necessary to provide protection
against microarchitectural attacks. We divide the analysis of
these microarchitectural attacks in the rest of this section.
A. Side-channel Attacks
Side channels have been widely studied when implemented
natively from the CPU [6], [18], [30], [35], [39], [40], [52].
In recent years, however, researchers have relaxed the threat
model by demonstrating remote attacks from a malicious
JavaScript-enabled website [18], [38]. All
these instances,
however, are attacks carried out from the CPU.
There is some recent work on showing possibilities of exe-
cuting microarchitectural attacks from the GPU, but they target
niche settings with little impact in practice. Jiang et al. [24],
[25] present two attack breaking AES on GPGPUs, assuming
that the attacker and the victim are both executing on a shared
GPU. Naghibijouybari et al. [34] demonstrate the possibility of
building covert-channels between two cooperating processes
running on the GPU. These attacks focus on general-purpose
discrete GPUs which are usually adopted on cloud systems,
whereas we target integrated GPUs on commodity hardware.
B. Rowhammer
Since Kim et al. [27] initially studied Rowhammer, re-
searchers proposed different implementations and exploitation
techniques. Seaborn and Dullien [45] ﬁrst exploited this hard-
ware vulnerability to gain kernel privileges by triggering bit
ﬂips on page table entries. Drammer uses a similar exploitation
technique to root ARM Android devices [48]. These imple-
mentations, however, relied on the ability of accessing memory
by bypassing the caches, either using the CLFLUSH instruction
on x86 64 or by exploiting DMA memory [48]. Our technique
does not require any of these expedient.
Dedup Est Machina [7] and Rowhammer.js [20] show
how Rowhammer can be exploited to escape the JavaScript
sandbox. These attacks rely on evicting the CPU caches in
order to reach DRAM. On the ARM architecture, eviction-
based Rowhammer is too slow to trigger Rowhammer bit ﬂips
even natively due to large general-purpose CPU caches. We
showed for the ﬁrst time how GPU acceleration allows us to
trigger bit ﬂips evicting the GPU caches. This allowed us to
trigger bit ﬂips from JavaScript on mobile devices.
XII. CONCLUSIONS
We showed that it is possible to perform advanced mi-
croarchitectural attacks directly from integrated GPUs found
in almost all mobile devices. These attacks are quite pow-
erful, allowing circumvention of state-of-the-art defenses and
advancing existing CPU-based attacks. More alarming, these
attacks can be launched from the browser. For example, we
showed for the ﬁrst time that with microarchitectural attacks
from the GPU, an attacker can fully compromise a browser
running on a mobile phone in less than 2 minutes. While we
have plans for mitigations against these attack, we hope our
efforts make processor vendors more careful when embedding
the next specialized unit into our commodity processors.
DISCLOSURE
We are coordinating with the Dutch Cyber Security Centrum
(NCSC) for addressing some of the issues raised in this paper.
ACKNOWLEDGEMENTS
We would like to thank our shepherd Simha Sethumadhavan
and our anonymous reviewers for their valuable feedbacks.
Furthermore, we want to thank Rob Clark for his precious
insights throughout the research. This work was supported
by the European Commission through project H2020 ICT-32-
2014 SHARCS under Grant Agreement No. 644571 and by
the Netherlands Organisation for Scientiﬁc Research through
grant NWO 639.023.309 VICI Dowsing.
208
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:36:05 UTC from IEEE Xplore.  Restrictions apply. 
REFERENCES
[1] “Actions required to mitigate Speculative Side-Channel Attack tech-
niques,” https://www.chromium.org/Home/chromium-security/ssca, Ac-
cessed on 20.01.2018.
[33] I. Malchev, “KGSL page allocation,” https://android.googlesource.com/
kernel/msm.git/+/android-msm-hammerhead-3.4-marshmallow-mr3/
drivers/gpu/msm/kgsl sharedmem.c#621, Accessed on 30.12.2017.
[34] H. Naghibijouybari, K. Khasawneh, and N. Abu-Ghazaleh, “Construct-
ing and Characterizing Covert Channels on GPGPUs,” in MICRO-50.
[2] “Value.h,” https://dxr.mozilla.org/mozilla-central/source/js/public/Value.
[35] M. Oliverio, K. Razavi, H. Bos, and C. Giuffrida, “Secure Page Fusion
h, Accessed on 30.12.2017.
with VUsion,” in SOSP’17.
[3] “WebGL current support,” http://caniuse.com/#feat=webgl, Accessed on
[36] L. E. Olson, J. Power, M. D. Hill, and D. A. Wood, “Border control:
30.12.2017.
[4] argp, “OR’LYEH? The Shadow over Firefox,” in Phrack 0x45.
[5] Z. B. Aweke, S. F. Yitbarek, R. Qiao, R. Das, M. Hicks, Y. Oren,
and T. Austin, “ANVIL: Software-Based Protection Against Next-
Generation Rowhammer Attacks,” in ASPLOS’16.
[6] D. J. Bernstein, “Cache-timing attacks on aes,” 2005.
[7] E. Bosman, K. Razavi, H. Bos, and C. Giuffrida, “Dedup Est Machina:
Memory Deduplication as an Advanced Exploitation Vector,” in S&P’16.
[8] F. Brasser, L. Davi, D. Gens, C. Liebchen, and A.-R. Sadeghi, “CAnt
Touch This: Software-only Mitigation against Rowhammer Attacks
targeting Kernel Memory,” in SEC’17.
[9] Y. Cao, Z. Chen, S. Li, and S. Wu, “Deterministic Browser,” in CCS’17.
[10] A. Christensen, “Reduce resolution of performance.now,” https://bugs.
webkit.org/show bug.cgi?id=146531, Accessed on 30.12.2017.
[11] Chromium, “window.performance.now does not support sub-millisecond
precision on windows,” https://bugs.chromium.org/p/chromium/issues/
detail?id=158234#c110, Accessed on 30.12.2017.
[12] J. Cong, M. A. Ghodrat, M. Gill, B. Grigorian, and G. Reinman,
“Architecture Support for Accelerator-rich CMPs,” in DAC’12.
[13] N. Corporation,
perfkit,”
nvidia-perfkit, Accessed on 30.12.2017.
“Nvidia
https://developer.nvidia.com/
[14] Esmaeilzadeh, Hadi and Blem, Emily and St. Amant, Renee and
Sankaralingam, Karthikeyan and Burger, Doug, “Dark Silicon and the
End of Multicore Scaling,” in ISCA’11.
[15] I. Ewell, “Disable timestamps in WebGL.” https://codereview.chromium.
org/1800383002, Accessed on 30.12.2017.
[16] F. Giesen, “Texture tiling and swizzling,” https://fgiesen.wordpress.com/
Sandboxing accelerators,” in MICRO-48.
[37] L. E. Olson, S. Sethumadhavan, and M. D. Hill, “Security implications of
third-party accelerators,” in IEEE Computer Architecture Letters 2016.
[38] Y. Oren, V. P. Kemerlis, S. Sethumadhavan, and A. D. Keromytis, “The
Spy in the Sandbox: Practical Cache Attacks in JavaScript and their
implications,” in CCS’15.
[39] D. A. Osvik, A. Shamir, and E. Tromer, “Cache attacks and counter-
measures: the case of AES,” in RSA’06.
[40] P. Pessl, D. Gruss, C. Maurice, M. Schwarz, and S. Mangard, “DRAMA:
Exploiting DRAM Addressing for Cross-CPU Attacks.” in SEC’16.
[41] F. Pizlo, “What Spectre and Meltdown Mean For WebKit,” https:
//webkit.org/blog/8048/what-spectre-and-meltdown-mean-for-webkit/,
Accessed on 20.01.2018.
[42] K. Razavi, B. Gras, E. Bosman, B. Preneel, C. Giuffrida, and H. Bos,
“Flip Feng Shui: Hammering a Needle in the Software Stack,” in
SEC’16.
[43] K. Sato, C. Young,
“Google Tensor Pro-
cessing Unit (TPU),” https://cloud.google.com/blog/big-data/2017/05/
an-in-depth-look-at-googles-ﬁrst-tensor-processing-unit-tpu, Accessed
on 30.12.2017.
and D. Patterson,
[44] M. Schwarz, M. Lipp, and D. Gruss, “JavaScript Zero: Real JavaScript
and Zero Side-Channel Attacks,” in NDSS’18.
[45] M. Seaborn and T. Dullien, “Exploiting the DRAM rowhammer bug to
gain kernel privileges,” in Black Hat 2015.
[46] V. Shimanskiy,
“EXT disjoint timer query,” https://www.khronos.
org/registry/OpenGL/extensions/EXT/EXT disjoint timer query.txt,
Accessed on 30.12.2017.
2011/01/17/texture-tiling-and-swizzling/, Accessed on 30.12.2017.
[47] M.
E.
[17] M. Gorman,
“Chapter
6: Physical Page Allocation,”
https:
//www.kernel.org/doc/gorman/html/understand/understand009.html,
Accessed on 30.12.2017.
[18] B. Gras, K. Razavi, E. Bosman, H. Bos, and C. Giuffrida, “ASLR on
the line: Practical cache attacks on the MMU,” in NDSS’17.
[19] K. Group, “OpenGL ES Shading Language version 1.00,” https:
//www.khronos.org/ﬁles/opengles shading language.pdf, Accessed on
30.12.2017.
[20] D. Gruss, C. Maurice, and S. Mangard, “Rowhammer.js: A remote
software-induced fault attack in JavaScript,” in DIMVA’16.
[21] D. Gullasch, E. Bangerter, and S. Krenn, “Cache games–bringing access-
based cache attacks on AES to practice,” in S&P’11.
[22] M. Hassan, A. M. Kaushik, and H. Patel, “Reverse-engineering embed-
ded memory controllers through latency-based analysis,” in RTAS’15.
[23] R. Hund, C. Willems, and T. Holz, “Practical Timing Side Channel
Attacks Against Kernel Space ASLR,” in S&P’13.
[24] Z. H. Jiang, Y. Fei, and D. Kaeli, “A Novel Side-Channel Timing Attack
on GPUs,” in GLSVLSI 2017.
[25] ——, “A complete key recovery timing attack on a GPU,” in HPCA’16.
[26] G. Key, “ATX Part 2: Intel G33 Performance Review,” https://www.
anandtech.com/show/2339/23, Accessed on 30.12.2017.
[27] Y. Kim, R. Daly, J. Kim, C. Fallin, J. H. Lee, D. Lee, C. Wilkerson,
K. Lai, and O. Mutlu, “Flipping bits in memory without accessing them:
An experimental study of DRAM disturbance errors,” in SIGARCH
2014.
[28] P. Kocher, D. Genkin, D. Gruss, W. Haas, M. Hamburg, M. Lipp,
S. Mangard, T. Prescher, M. Schwarz, and Y. Yarom, “Spectre Attacks:
Exploiting Speculative Execution,” 2018.
[29] D. Kohlbrenner and H. Shacham, “Trusted Browsers for Uncertain
Times.” in SEC’16.
[30] N. Lawson, “Side-channel attacks on cryptographic software,” in
S&P’09.
[31] M. Lipp, D. Gruss, R. Spreitzer, C. Maurice, and S. Mangard, “AR-
Mageddon: Cache Attacks on Mobile Devices,” in SEC’16.
[32] S. M.,
“How
physical
in
DRAM,”
banks
how-physical-addresses-map-to-rows-and-banks.html,
on 30.12.2017.
addresses map
and
http://lackingrhoticity.blogspot.nl/2015/05/
Accessed
rows
to
“Mitigating
Team,
attacks
side-
Ex-
in Microsoft
https://blogs.windows.com/msedgedev/2018/01/03/
channel
plorer
speculative-execution-mitigations-microsoft-edge-internet-explorer/
#b8Y70MtqGTVR7mSC.97, Accessed on 20.01.2018.
speculative
execution
Internet
Edge
and
,”
[48] V. van der Veen, Y. Fratantonio, M. Lindorfer, D. Gruss, C. Maurice,
G. Vigna, H. Bos, K. Razavi, and C. Giuffrida, “Drammer: Deterministic
Rowhammer Attacks on Mobile Platforms,” in CCS’16.
[49] G. Venkatesh, J. Sampson, N. Goulding, S. Garcia, V. Bryksin, J. Lugo-
Martinez, S. Swanson, and M. B. Taylor, “Conservation Cores: Reducing
the Energy of Mature Computations,” in ASPLOS’10.
landing
attack,”
“Mitigations
[50] L. Wagner,
tim-
ing
https://blog.mozilla.org/security/2018/01/03/
mitigations-landing-new-class-timing-attack/, Accessed on 20.01.2018.
[51] Y. Xiao, X. Zhang, Y. Zhang, and R. Teodorescu, “One bit ﬂips, one
cloud ﬂops: Cross-vm row hammer attacks and privilege escalation.” in
SEC’16.
new class
for
of
[52] Y. Yarom and K. Falkner, “FLUSH+ RELOAD: A High Resolution,
Low Noise, L3 Cache Side-Channel Attack,” in SEC’14.
[53] B. Zbarsky, “Clamp the resolution of performance.now() calls to 5us,”
https://hg.mozilla.org/integration/mozilla-inbound/rev/48ae8b5e62ab,
Accessed on 30.12.2017.
APPENDIX A
SNAPDRAGON 800/801 DRAM MAPPING
In Section VII-C, we explained that contiguity differs
from adjacency. However, we also stated that, we could
assume the congruency between these two attributes for the
Snapdragon 800/801 SoCs. Here we show how we can relax
that assumption.
As explained in Section VII-A, DRAM is organized in
channels, DIMMs, ranks, banks, rows and columns. The
CPU/GPU, however, only access DRAM using virtual ad-
dresses. After a translating a virtual address to its physical
addresses, the memory controller converts the physical address
209
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:36:05 UTC from IEEE Xplore.  Restrictions apply. 
@ 
Ã
¼Á
ÀÁ
Á¿
Â½
Fig. 8: Snapdragon 800/8011 DRAM mapping
TABLE V: Snapdragon 800/801 DRAM mapping function
Channel
DIMMs
Ranks
Banks
Bits
-
-
10
13,14,15
to a DRAM address consisting of the elements we mentioned
above. This mapping of physical addresses to DRAM ad-
dresses is undocumented, but it has been reverse engineered
for many architectures [22], [32], [51] including Snapdragon
800/801 [40], shown in Table V.
Snapdragon 800/801 does not employ multiple channels or
DIMMs and as a result no bits in the physical addresses are
assigned to their selection. Within the DIMM, we ﬁnd two
ranks and eight banks within the ranks. Bit ten of a physical
address is responsible for choosing these ranks, while bits [13-
15] are responsible for choosing the banks. As we show in
Figure 8, this conﬁguration translates to 1 KB aligned areas
of the physical address space shufﬂed over the two different
ranks (210 = 1 KB) and a change of bank every 8 KB (213 =
8 KB). Since the division among the ranks happens at a smaller
granularity than a page, it means that every row (within a bank)
is 4 KB large and stores 2 half-pages as shown in Figure 8.
Remembering the assumption we made in Section VII-C,
now it should be clear why we are allowed to simplify our
model considering two pages per row. Since we are only
interested in touching memory at page level, due to the
stride imposed by the UCHE cache (i.e., 4 KB), we can build
our model completely oblivious of the ranks. Thus, we can
consider rows of 8 KB.
210
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:36:05 UTC from IEEE Xplore.  Restrictions apply.