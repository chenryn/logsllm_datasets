\xc3:ret
\x59:popecx
因此，call+4会跳到call指令自身的最后一个字节：
\xe8\xff\xff\xff\xff=>将会跳到最后的一个\xff（将一个指向那个位置的指针入栈）。连同\xc3，
它变成“INCEBX”（\xff\xc3），在这里相当于nop指令。然后，popecx将会从栈中弹出指
针。
正如你能看到的，这个代码是7字节长，并且没有null字节。
FFFFSSSSTTTTEEEENNNNVVVV
当我们讨论shikate_ga_nai&fstenv_mov编码器的内部原理时，我们会发现一个获取
shellcode的基址的巧妙方法（基于FPU指令）。这个技术是基于这个思想：
在代码顶部执行任一个FPU（浮点）指令（你可以在Intelarchitecturemanualvolume1，
第404页得到一列FPU指令），然后执行“FSTENVPTRSS:[ESP-C]”
这两个指令的联合能够得到第一个FPU指令的地址（因此如果一个是代码的第一个指
令，你将会得到代码的基址）然后把地址写入栈中。实际上，FSTENV将会在第一条指令执
行之后保存浮点芯片的状态。第一条指令的地址保存在0xC偏移量处。一个简单的POP寄
存器将会把第一个FPU指令的地址放到寄存器中。并且这个代码的很好的一点是它不包含
null字节。的确是很巧妙的方法！
例子：
[BITS32]
FLDPI
FSTENV[ESP-0xC]
POPEBX
字节码：
"\xd9\xeb\x9b\xd9\x74\x24\xf4\x5b";
（8个字节，没有null字节）
BBBBaaaacccckkkkwwwwaaaarrrrddddccccaaaallllllll
另外一个可能的实现gettingPC的方法并且使它指向shellcode/解码器（并且跳到一个基
于这个地址的代码）的开头的方法：
[BITS32]
jmpshortcorelan
geteip:
popesi
callesi ;thiswilljumptodecoder
corelan:
callgeteip
decoder:
;decodergoeshere
shellcode:
;encodedshellcodegoeshere
（Ricardo干得很棒！--“CorelanGetPC:-）”--这个也没用null字节）
"\xeb\x03\x5e\xff\xd6\xe8\xf8\xff"
"\xff\xff";
SSSSEEEEHHHHGGGGeeeettttPPPPCCCC
（CostinIonescu）
这就是它将会做的：
一些代码+一个入栈的SEH结构（并且SEH结构指向栈上的代码）。然后强制产生一个
崩溃（指向null指针），因此SEH开始工作。
栈上的代码将会获得控制权然后从参数中得到异常地址
传递给SEH函数
在教程7中（unicode），我解释了怎样将shellcode转化成兼容unicode的shellcode，用
skylined的alpha2脚本。在这个脚本里，你需要提供一个基址寄存器（一个指向代码开始处
的寄存器）。这个的原因现在很清楚：那个unicode/字母数字的代码（事实上是解码器）没
有一个getpc程序。因此你需要告诉编码器基地址在哪里。如果你深入地看下alpha2（或者
alpha3），你可以看到有一个用seh作为基地址的选择权。这将会尝试产生一个字母数字版本
的SEHgetpc代码，并且用这个来动态决定基地址。
正如alpha2的-help输出中所陈述的那样，这个技术对unicode无效，并且也不总是对大
写字母代码有效...
seh
Thewindows"StructuredExceptionHandler"(seh)canbeusedtocalculate
thebaseaddressautomaticallyonwin32systems.Thisoptionisnotavailable
forunicode-proofshellcodesandtheuppercaseversionisn't100%reliable.
...但是，这是一个在字母数字payload里实现SEHGetPC的活生生的例子。
很不幸我还成功使用过这个技术...我用skylined的ALPHA3的编码器来产生在XPSP3下
用SEHGetPC的shellcode，但是它不工作...
使 aaaassssmmmm 代码更加通用：通常的获得指向字符串////数据的指针
在这个文件的前面一点的例子中，我们把字符串转化为字节，然后将字节入栈...这没有
什么错，但是既然我们直接用asm代码，这里有一种/可能更简单的方法来做这个。
我们看下下面的例子，和我们上面的“pushbytes”代码所做的一样：
[Section.text]
[BITS32]
global_start
_start:
jmpshortGetCaption;jumptothelocation
;oftheCaptionstring
CaptionReturn: ;Definealabeltocallsothat
;stringaddressispushedonstack
popebx ;ebxnowpointstoCaptionstring
jmpshortGetText ;jumptothelocationoftheTextstring
TextReturn:
popecx ;ecxnowpointstotheTextstring
;nowpushparameterstothestack
xoreax,eax ;zeroeax-neededforButtonType&Hwnd
pusheax ;pushnull:ButtonType
pushebx ;pushthecaptionstringontothestack
pushecx ;pushthetextstringontothestack
pusheax ;pushnull:hWnd
movebx,0x7E4507EA ;placeaddressofMessageBoxintoebx
callebx ;callMessageBox
xoreax,eax ;zerotheregisteragaintoclear
;MessageBoxreturnvalue
;(returnvaluesareoftenreturnedintoeax)
pusheax ;pushnull(parametervalue0)
movebx,0x7c81CB12 ;placeaddressofExitProcessintoebx
callebx ;callExitProcess(0);
GetCaption: ;Definelabelforlocationofcaptionstring
callCaptionReturn ;callreturnlabelsothereturnaddress
;(locationofstring)ispushedontostack
db"Corelan" ;Writetherawbytesintotheshellcode
;thatrepresentourstring.
db0x00 ;Terminateourstringwithanullcharacter.
GetText: ;Definelabelforlocationofcaptionstring
callTextReturn ;callthereturnlabelsothe
;returnaddress(locationstring)
;ispushedontostack
db"YouhavebeenpwnedbyCorelan" ;Writetherawbytesintoshellcode
;thatrepresentourstring.
db0x00 ;Terminateourstringwithnull
（例子是基于这里找到的例子here和 here）
这就是代码所做的：
开启主函数（_start）
跳到“Corelan”字符串前面的位置。一个往回的调用被执行，将将“Corelan”的地
址放入栈顶。接下来，指针放入ebx中。
对“YouhavebeenpwnedbyCorelan”字符串做同样的操作并把指向字符串的指针存
到ecx中
将eax清零
将参数入栈
调用MessageBox函数
退出进程
事实上，最大的不同时字符串是在代码中的可读格式中（因此很容易改变文本）。
在编译并转化为shellcode之后，我们得到这个：
C:\shellcode>"c:\ProgramFiles\nasm\nasm.exe"
msgbox4.asm
-omsgbox4.bin
C:\shellcode>perlpveReadbin.plmsgbox4.bin
Readingmsgbox4.bin
Read78bytes
"\xeb\x1b\x5b\xeb\x25\x59\x31\xc0"
"\x50\x53\x51\x50\xbb\xea\x07\x45"
"\x7e\xff\xd3\x31\xc0\x50\xbb\x12"
"\xcb\x81\x7c\xff\xd3\xe8\xe0\xff"
"\xff\xff\x43\x6f\x72\x65\x6c\x61"
"\x6e\x00\xe8\xd6\xff\xff\xff\x59"
"\x6f\x75\x20\x68\x61\x76\x65\x20"
"\x62\x65\x65\x6e\x20\x70\x77\x6e"
"\x65\x64\x20\x62\x79\x20\x43\x6f"
"\x72\x65\x6c\x61\x6e\x00";
Numberofnullbytes:2
代码的大小是一样的，但是跟我们直接把字节入栈比起来，很明显null字节在不同的位置
（现在更接近于代码的末尾）。
当我们看下在调试器中的shellcode，我们看到的是这样的：
按需求跳转到将字符串入栈并且在EBX和ECX中得到指针
调用PUSH指令将参数入栈
调用MessageBoxA
将EAX清零（eax包含了MessageBox的返回值）然后将参数入栈
调用ExitProcess
接下来的字节实际上被分为2块，它们是：
跳回到“mainshellcode”
接下来是给定的字符串
接下来是00
当跳回到mainshellcode的调用完后，栈顶位置指向回调的来源处（字符串的起始位置）。
因此一个pop将会把字符串的地址放到reg中。
相同的结果，不一样的技术
或者在代码里加些注释：
由于这种技术具有更好的可读性，（而且我们将会用payload编码器），我们将会把这个
作为接下来的教程部分的基础。（同样，这不意味着直接把字节入栈的方法是坏方法...只是
不一样）
提示：如果你想从避免null字节开始，那么你可以用早些提到的一些技巧中的一种（看
“sniper”）。因此，不是这样写：
db"Corelan"
db0x00
你可以这样写：
db"CorelanX"
然后，用00代替X
（假设“reg”指向字符串的开头）
xoreax,eax
mov[reg+0x07],al ;overwriteX withnullbyte
或者，你也可以编码payload来摆脱null字节。随便你。
接下来是什么？
我们知道怎样把c转化为asm，将相关的asm代码片用来构造我们的shellcode。我们也
知道怎么克服null字节和其它的字符集/坏字节限制。
但我们远非成功了。
在我们的例子里，我们假设user32.dll已经加载了，因此我们可以直接调用MessageBox
API。事实上，user32.dll的确被加载了（因此我们不用去假设那个），但是如果我们要在其
它的exploit用这个shellcode，我们不能假设它已经加载了。我们也是直接调用ExitProcess
（假设kernel32.dll加载了）。
第二，我们在shellcode中硬编码了MessageBox和ExitProcess的地址。正如早些解释的
那样，这会限制这个shellcode只能用在XPSP3。
我们今天的最终目标是克服这两个限制，使我们的shellcode动态性和可移植性。
写通用的////动态的////可移植性的 sssshhhheeeellllllllccccooooddddeeee
我们的MessageBoxshellcode能够很好的工作，那是因为user32.dll已经加载了。而且，
它包含了user32.dll和kernel32.dll中一个windowsAPI指针的硬编码。如果这些地址在不同
的操作系统中变了（很有可能），那么这个shellcode不具有可移植性。大部分的shellcode
专家认为地址硬编码是一个大错误...我猜他们在一个范围内是对的。当然，如果你知道你的
目标并且你只需要这个特定的shellcode只执行一个，那么地址硬编码没问题（当大小是个
大问题时）。
“可移植性”这个术语不仅仅指地址硬编码不能用。它还包括了shellcode在内存中能够
重定位，不管在shellcode运行之前栈是如何设置的。（当然，你需要再一个可执行的内存区
域，但这是任一个shellcode的要求）。这意味着(除了用地址硬编码是不能使用的之外），你
必须用相关调用...这意味着你不得不在内存中定位到自己的位置（因此你能用我们位置相关
的call调用）。我们已经在前面讨论过这些方法了。（看GetPC）
使shellcode可移植，你将会发现，将会大体上增加shellcode的大小。如果你想证明一个
给定的应用程序是有弱点的，能用通用的方法利用（不管它运行在什么版本上的windows
版本），那么写可移植的/通用的shellcode是一件有趣的事。
随你在可移植性和大小两者之间找到平衡，所有的都是基于你的exploit和shellcode的意
图和限制。换句话说：如果它能达到目的的话，大的shellcode包含地址硬编码也不是差的