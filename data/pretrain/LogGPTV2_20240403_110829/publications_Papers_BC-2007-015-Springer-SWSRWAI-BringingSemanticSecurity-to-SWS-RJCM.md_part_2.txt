contains either a virus or a worm.
7. Bringing Semantic Security to Semantic Web Services 11
Even after verifying that the parameters within a message are
appropriate for the operation(s), their may be malicious code present. For
example, it may be verified that a string is being passed to an operation
which then queries a SQL database. SQL injection attacks are of the string
data type. Therefore verifying that a string is being passed is not enough.
Best practices for programming disallow and check for the presence of a ‘;’
in any parameter which will be passed to a SQL database. The ‘;’ in SQL
allows for SQL commands to follow.
Ensuring that a message is well-formed is another step in Message
Validity. Since the messages are in XML, it is possible that a message
contains a circular-reference. A circular-reference may appear maliciously
or through poor programming. Circular-references cause a system to
encounter a run-out-of-memory error and shutdown [Lilly, 2002]. When
done maliciously this is know as a denial-of-service attack. Proper parsing
of a message will catch nested loops.
2.4 Authentication
Authentication can easily be described as verify to ones own level of
certainty that an entity is who they claim to be. In its simplest form,
authentication could be a username and password combination. However,
this is only possible if there is already a relationship between the requester
and provider.
Because of the distributed nature of Web services, a requester may be
previously unknown to the provider. When an unknown requester
authenticates it sends information about themselves to the provider. This
information is known as credentials. It is up to the provider to verify this
information. Now there are different degrees of verifying credentials and
this can be directly affected by the type of credential that is sent. This is
where the provider’s own degree of scrutiny comes into play. In general, the
more sensitive the information is which is being made available through a
Web service, the higher the level of certainty must be. This certainty can be
achieved through verification of the credentials. In the case of a previously
unknown requester, the highest level of certainty can usually be achieved
through a trusted authority. Trusted authorities issue certificates which can
be used for authentication. A provider can evaluate the certificate and
contact the trusted authority for verification.
12 Chapter 7
However, their may be an intermediate service contacting the provider
on behalf of the requester and once established the requester and provider
will communicate. Assuming that the intermediary has authenticated the
Requester and there is a trust relationship between the intermediary and the
provider, the provider may take the ‘word’ of the intermediary and believe
with a level of certainty that the requester is whom they claim to be. This can
be done through the use of SAML or a certificate issued by the intermediary.
Here the intermediary is providing the verification.
3. AUTHORIZATION
In organizations, highly sensitive data and information must be
protected with access control systems. These control systems allow defining
and controlling which users are authorized to access specific applications
and data but prohibit the access of unauthorized users.
Nowadays, organizations are built on heterogeneous IT infrastructure.
As a result, a variety of systems with proprietary access control mechanisms,
such as Unix, Windows, MAC, and mainframes exist and are incompatible.
In proprietary access control systems, information about resources and
attributes is stored in repositories called Access Control Lists (ACL). This is
a problem since different proprietary systems have different ACL
implementations, making it difficult to exchange and share information
between them.
Access Control
Information Control Policy
(ACI)
User Verifier Target
Figure 6 Access Control
Authorization is the granting of rights, which includes the granting of
access based on access rights. This typically takes place after authentication.
Authorization is often confused with authentication, however it is a separate
issue altogether. An access control implementation compares access control
information such as the rights of the Requester with the policies or
7. Bringing Semantic Security to Semantic Web Services 13
permissions needed to access the resource. If the rights of the Requester
dominate the control policy, then access can be granted; otherwise access is
denied. The two most common access control implementations are Access
Control Lists (ACL), and RBAC. ISO 10181-3 specifies access control
information used in making access control decisions.
3.1 ACL’s
ACL’s are often used in the Unix environment for file and directory
security. Although ACL’s offer much more granularity than pervious *nix
access control mechanisms, they can be cumbersome to implement and
manage. There are difficult to manage because of the lack of relationships
between the access control entities, i.e., resources, permissions, groups, and
users. There is an obvious relationship between users and groups, users
belong to groups and groups contain users. However, each shared resource
must have an ACL file specified for it and the associated permissions are
held within the file.
# file: documents
# owner: somebody
# group: other
user::rwx
user:jackson:rwx #effective:rwx
user:smith:rwx #effective:rwx
group:publ:rw- #effective:rw-
mask:rwx
other:---
Figure 7 ACL example
Users within groups can easily be managed, but for resources that
change frequently like those in Web services it is difficult to modify the
ACL’s for all these resources. Therefore management of a ubiquitous and
dynamic resource environment is cumbersome at best. Furthermore,
performance is affected each time ACL is accessed and inspected. A simple
example ACL is given below in Figure 4.
3.2 RBAC
In 2004 the National Institute of Standards and Technology (NIST)
published a standard [NIST, 2004] for defining the features of Role Based
Access Control. The standard was largely based on the various features
found in commercial implementations of RBAC. There are two parts to an
RBAC system. The first is the Reference Model which consists of objects,
operations, permissions, roles, and users. The second is the System and
14 Chapter 7
Administrative Functions which include system functionality, and
administrative operations and reviews [NIST, 2004]. Our approach utilized
the concepts of RBAC, so we will discuss it here. However, much has been
written about RBAC over the past decade; in an effort not to be repetitive
this is a summary-review.
RBAC contains Permissions sets. Generally speaking, Permissions
express a privilege to access a resource. Permissions are a set of one or
more objects and one or more operations. Objects refer to resources; for
example a printer or a file. Operations are the invocation or execution of
some function on a resource. An example of a Permission may be “create
file in directory etc’. In this case, ‘etc’ is the Object and ‘create file’ is the
operation.
Once Permissions are created, they may be assigned to Roles. A Role
is a job function which is performed within an organization. A job function
can be as concrete as a job title, ‘Physician’, or more general even abstract,
‘internet user’. Once Roles are defined they may be assigned to Users who
are actual people. Users may also include entire organizations, computers or
networks [NIST, 2004].
The HL7 committee has developed a simple and effective way for
creating Permissions (Object, Operation set) and Roles. They call it a
scenario driven approach. The concept is to first create scenarios for the
‘organization’. These scenarios include resources, actions taken on the
resources, and who is performing these actions, in terms of job function.
Our Detailed Scenario is an example of this approach.
Figure 5 shows the relationships between the elements of the RBAC
Reference Model. Permissions are an Object, Operation set. There is an
assignment between Permissions and Roles, and Roles and Users. These
relationships/assignments are many-to-many. There is another element
present in the figure which has a one-to-many assignment with Users. That
element is the Session Role [NIST, 2004].
A Session is the activation of one or more Roles by a User.
Simplistically and not entirely, a Session Role determines if a Users Role
should be activated. This is determined by the constraints on the Roles
assigned to the User and which Roles the User currently has active. The
RBAC Reference Model provides fine granularity for authorization of
resources. The RBAC Systems and Administrative Functions provide for
distributed decision and enforcement points.
In our approach we conceptually map elements of RBAC to elements of
Web services in order to an authorization function regarding the Web service
and a prediction function regarding the Requester. In or approach, RBAC
Operations are mapped to the action that an operation of a Web service
performs. Keeping with our example, the Web service has an operation to
review the medical history of a patient; this operation is mapped to the
RBAC element ‘read’. The RBAC element Object is mapped to the resource
7. Bringing Semantic Security to Semantic Web Services 15
which the service accesses and the parameters of the operation; i.e. the
medical history of the patient and the patient respectively.
* *
* *
*
1
* *
Figure 8 RBAC
We define an authorization function, and as mentioned in section 1.2,
there is a variable of uncertainty between what a Web service provider is
describing and what a Requester may assume the provider is describing.
This variable is caused because our ontology is an upper level ontology;
therefore each organization using the ontology must map Users, Roles, and
possibly Groups to the ontology. This mapping is independent of any other
organization; therefore there is uncertainty that a Requester and service
provider have the same mapping. Our goal is to minimize the variable to
achieve accurate results.
We define the authorization function as f:
The XACML RBAC profile also supports hierarchical RBAC, allowing
inheritance between roles. Dynamic Separation of Duty is supported by the
profile, and structural Separation of Duty can be supported via the user-role
assignment mechanism. Additional XACML policies are provided to
support system and review functions described in the ANSI RBAC standard.
Specifically, the Role PolicySet (RPS) associates holders of a given role
attribute with a Permission PolicySet. The Permission PolicySet (PPS)
describes the permissions associated with a specific role. The RPS and PPS
replace the role assignment and role specification ACs in the X.509 based
role model.
The XACML role based PMI features a rich policy language integrated
throughout the design. The concept of structural versus functional roles is
supported using a two tiered system comprised of a role attributes. That is,
users can have roles assigned to them in the request context. An entity
separate from the policy decision point can use an XACML Role
Assignment Policy or PolicySet to enable attributes within the user session.
Figure 9 illustrates a typical XACML usage scenario. A subject (e.g.,
human user, application) wants to take some action on a specific network
resource, such a file system or Web service. The subject submits its request.
The request for authorization goes to the entity protecting the resource, the
PEP (Policy Enforcement Point). The PEP uses XACML request language to
create a request based on attributes of the subject, action, resources and
sends it to the Policy Decision Point (PDP), which evaluates the request. The
PDP invoke the Policy Information Point (PIP) service to retrieve applicable
policies written in XACML that are applicable to the request. The PDP
compares the request against policies and determines whether access should
18 Chapter 7
be granted according to the XACML rules for evaluating policies. Policies
contain information about the subject, the action, and other environmental
properties. The result of the comparison can be either access granted or
denied. The answer goes back to the PEP. If there is no match, the PEP
denies user access; otherwise, it permits access by the user.
Figure 9 Typical XACML usage scenario
While there are many proprietary languages for controlling the access to
resources, XACML has advantages. The use of a standard access control
policy language can replace several proprietary languages making easier the
interoperation of applications. Programmers and administrators can work
more efficiently since they do not have to develop new policy languages and
write code to support them and only need to understand one language. The
use of a common language allows one policy to be used by many different
applications, thus making policy management easier. Policies can also be
distributed by referring to other policies stored in geographically disperse
locations. For instance, a local-specific policy may refer to an organization-
wide policy.
3.4 WS-Authorization
WS-Authorization is a proposed future specification regarding the
description and management of authorization data and policies [IBM,
Microsoft 2002]. In particular, WS-Authorization will specify a standard on
how to describe authorization claims within a security token and how the
end-point should interpret these claims. It is widely thought that this