choose a random function H and a random output B, then
1 (x, B),
run AH
that for a random j, the j-th query AH
1 makes is measured
as x′ = x. Then as long as the output of AC has collision-
entropy at least k, the advantage with which AH
1 , when
run after A0, AC as described, distinguishes (x, B) from
(x, H(x)) is at most (4 +
In other words, if we can divide our game into three
such algorithms and argue that the A1 queries H on some-
thing that collapses to x with only negligible probability,
then we can conclude that the two games are indistinguish-
able. Let A0 run the game up until just before the i th itera-
tion in the proof generation. Let AC be the process which
(i)
(i)
chooses k
3 ,
2 , View
(i)
(i)
3 and generates View
1 , View
q02−k/4 + 2q1
√
2)√
√
PC.
(i)
1 , k
(i)
2 , k
and outputs x = ke∗(i) , Viewe∗(i). (Note that this has col-
lision entropy |ke∗(i)| which is sufficient.) Let A1 be the
process which runs the rest of the proof, and then runs the
adversary on the response.
Now we just have to argue that the probability that we
make a measurement of A1’s j-th query to H and get x is
negligible. To do this, we reduce to the security of the PRG
used to generate the random tapes (and hence the views).
Note that besides the one RO query, ke∗(i) is only used
as input to the PRG. So, suppose there exists a quantum
adversary A for which the resulting A1 has non-negligible
probability of making an H-query that collapses to x. Then
we can construct a quantum attacker for the PRG: we run
the above A0, AC, but instead of choosing ke∗(i) we use the
PRG challenge as the resulting random tape, and return a
random value as the RO output. Then we run A1, which
continues the proof (which should query ke∗(i) only with
negligible probability since ks are chosen at random), and
then runs the adversary. We pick a random j, and on the
adversary’s j-th query, we make a measurement and if
it gives us a seed consistent with our challenge tape, we
output 1, otherwise a random bit. If PC is non-negligible
then we will obtain the correct seed and distinguish with
non-negligible probability.
Game 4: For each i instead of choosing random ke∗(i) and
expanding it via the PRG to get the random tape used
to compute the views, we choose those tapes directly at
random.
Note that in Game 3, ke∗(i) are now only used as seeds
for the PRG, so this follow from pseudorandomness via a
hybrid argument.
Game 5: We use the simulator to generate the views that will
be opened, i.e. j (cid:44) e∗(i) for each i. We note that now the
simulator no longer uses the witness.
19
This is identical by perfect privacy of the circuit decom-
position.
Game 6: To allow for extraction in the simulation-extractability
game we replace the random oracles with random polyno-
mials whose degree is larger than the number of queries
the adversary makes. The argument here identical to that
in [84].
(i)
1 , д
(i)
2 , д
(i)
ei +1 respectively in the description of Ver in Figure 1.
Online Extractability Before we prove online simulation-extract-
ability, we define some notation to simplify the presentation:
For any proof π = e, {b(i), д(i), z(i)}i =1...t , let hash-input(π)
(i)
= {a(i), h(i) = (д
3 )} be the values that the verifier uses as
input to Hchal in the verification of π as described in Figure 1.
For a proof π = (e, {b(i), д(i), z(i)}i =1...t), let open0(z(i)), open1(
(i)
z(i)) denote the values derived from z(i) and used to compute C
ei
and C
We say a tuple (a, j,(o1, o2)) is valid if a = (y1, y2, y3, C1, C2, C3),
Cj = Hcom(o1), Cj+1 = Hcom(o2) and o1, o2 consist of k, View pairs
for player j, j + 1 that are consistent according to the circuit decom-
position. We say (a, j,(O1, O2)) is set-valid if there exists o1 ∈ O1
and o2 ∈ O2 such that (a, j,(o1, o2)) is valid and set-invalid if not.
We first restate lemma 16 from [84] tailored to our application, in
particular the fact that our proofs do not explicitly contain the com-
mitment but rather the information the verifier needs to recompute
it.
Lemma F.1. Let qG be the number of queries to G made by the
adversary A and the simulator S in the simulation extractability game,
and let n be the number of proofs generated by S. Then the probability
that A produces x, π∗ (cid:60) simproofs where x, π∗ is accepted by VerH ,
and hash-input(π∗) =
hash-input(π ′) for a previous proof π ′ produced by the simulator, is at
most n(n + 1)/2(2−k)3t + O((qG + 1)32−k) (Call this event MallSim.)
Proof. This proof follows almost exactly as in [84].
First, we argue that G is indistinguishable from a random func-
tion exactly in [84].
(i)
j
Then, observe that there are only two ways MallSim can occur:
Let e′ be the hash value in π ′. Then either S reprograms H
sometime after π ′ is generated so that H(hash-input(π ′)) is no
longer e′, or π∗ also contains the same e as π, i.e. e = e′. S only
reprograms H if it chooses the same hash-input in a later proof - and
hash-input includes д
, i.e. a random function applied to an input
which includes a randomly chosen seed. Thus, the probability that
S chooses the same hash-input twice is at most n(n + 1)/2(2−k)3t +
O((qG + 1)32−k, where (2−k)3t is the probability that two proofs
use all the same seeds, and O((qG + 1)32−k is the probability that
two different seeds result in a collision in G, where the latter follows
from Theorem 8 in [84].
The other possibility is that hash-input(π∗) = hash-input(π ′) ,
and e = e′, but b(i), д(i), z(i) (cid:44) b′(i), д′(i), z′(i) for some i. First note,
that if e = e′ and hash-input(π∗) = hash-input(π ′), then д(i) =
д′(i) and b(i) = b′(i) for all i, by definition of hash-input. Thus, the
only remaining possibility is that z(i) (cid:44) z′(i) for some i. But since
h(i) = h′(i) for all i, this implies a collision in G, which again by
Theorem 8 in [84] occurs with probability at most O((qG + 1)32−k.
20
We conclude that MallSim occurs with probability at most n(n +
1)/2(2−k)3t + O((qG + 1)32−k. □
Here, next we present our variant of lemma 17 from [84]. Note
that this is quoted almost directly from Unruh with two modifica-
tions to account for the fact that our proofs do not explicitly contain
the commitment but rather the information the verifier needs to
recompute it, and the fact that our underlying Σ-protocol has only
3 challenges and satisfies 3-special soundness. H0 in this lemma
will correspond in our final proof to the initial state of Hchal.
Lemma F.2. Let G, Hcom be arbitrarily distributed functions, and let
H0 : {0, 1}≤ℓ → {0, 1}2t be uniformly random (and independent of
(i)
G). , Then, it is hard to find x and π such that for {a(i),(д
3 )} =
hash-input(π) and J1|| . . . ||Jt := H0(hash-input(π))
(i)
1 , д
(i)
2 , д
(i)
Ji
= G(open0(z(i))) and д
(i)
Ji +1 = G(open1(z(i))) for all i.
(i) д
(ii) (a(i), Ji ,(open0(z(i)), open1(z(i)))) is valid for all i.
(iii) For every i, there exists a j such that (a(i), j, G−1(дi, j), G−1(
дi, j+1))) is set-invalid.
(i)
2 )), (a(i), 2, G−1(д
(i)
3 )), and (a(i), 3, G−1(д
For any given value of H0, we call a tuple c = (x, {a(i)}i , {д
More precisely, if AG,H0 makes at most qH queries to H0, it outputs
3)t/2
(x, π) with these properties with probability at most 2(qH + 1)( 2
Proof. Without loss of generality, we can assume that G, Hcom are
fixed functions which A knows, so for this lemma we only treat H0
as a random oracle.
(i)
j }i, j)
a candidate iff: for each i, among the three transcripts, (a(i), 1,
(i)
G−1(д1)(i), G−1(д
2 ),
(i)
(i)
G−1(д
3 ), G−1(д
1 )) at least one is set-valid,
and at least one is set-invalid. Let ntwovalid(c) be the number of i’s
for which there are 2 set-valid transcripts. Let Evalid(c) be the set
of challenge tuples which correspond to only set-valid conversa-
tions. (Note that |Evalid(c)| = 2ntwovalid(c).) We call a candidate an
H0-solution if the challenge produced by H0 only opens set-valid
conversations, i.e. in lies in Evalid(c). We now aim to prove that AH
outputs an H0 solution with negligible probability.
For any given candidate c, for uniformly random H0, the proba-
bility that c is an H0-solution is ≤ ( 2
3)t . In particular, for candidate
c the probability is ( 2
Let Cand be the set of all candidates. Let F : Cand → {0, 1} be
a random function such that for each c F(c) is i.i.d. with Pr[F1(c) =
1] = (2/3)t .
3)t ∗ 2ntwovalid(c)−t .
Given F, we construct HF : {0, 1}∗ → Zt
3 as follows:
3 \ Evalid(c).
• For each c (cid:60) Cand, HF(c) is set to a uniformly random
y ∈ Zt
3.
• For each c ∈ Cand such that F(c) = 0, HF(c) is set to a
uniformly random y ∈ Zt
• For each c ∈ Cand with F(c) = 1, with probability 2ntwovalid−t ,
choose a random challenge tuple e from Evalid(c), and set
HF(c) := e. Otherwise HF(c) is set to a uniformly random
y ∈ Zt
Note that for each c, and e the probability of H(c) being set to e
is 3−t . Suppose AH
0 outputs an H0-solution with probability µ, then
since HF has the same distribution as H0, AHF () outputs an HF
solution c with probability µ. By our definition of HF , if c is an HF
3 \ Evalid(c).
Let SigExtFail be the event that the extractor finds a successful
Let Evi , Evii , Eviii be events denoting that A in the simulation
extractability game produces a proof satisfying conditions (i), (ii),
and (iii) from Lemma F.2 respectively.
(a, {(ν1, j , ν2, j)}j=1,2,3), but EΣ fails to produce a valid witness.
VerH accepts and (x, π) (cid:60) simproofs.
Then our goal is to prove that the w produced by the extractor
is such that (x, w) ∈ R. I.e., we want to prove that the following
probability is negligible.
Let ShouldExt denote the event that A produces x, π such that
Pr[ShouldExt ∧ (x, w) (cid:60) R]
≤ Pr[ShouldExt ∧ (x, w) (cid:60) R ∧ ¬MallSim]
+ Pr[MallSim]
= Pr[ShouldExt ∧ (x, w) (cid:60) R ∧ ¬MallSim ∧ ¬Eviii]
+ Pr[ShouldExt ∧ (x, w) (cid:60) R ∧ ¬MallSim ∧ Eviii]
+ Pr[MallSim]
≤ Pr[(x, w) (cid:60) R ∧ ¬Eviii]
+ Pr[ShouldExt ∧ (x, w) (cid:60) R ∧ ¬MallSim ∧ Eviii]
+ Pr[MallSim]
= Pr[SigExtFail]
+ Pr[ShouldExt ∧ (x, w) (cid:60) R ∧ ¬MallSim ∧ Eviii]
+ Pr[MallSim]
= Pr[SigExtFail]
+ Pr[ShouldExt ∧ (x, w) (cid:60) R ∧ ¬MallSim ∧ Evi ∧ Evii ∧ Eviii]
+ Pr[MallSim]
≤ Pr[SigExtFail]
+ Pr[Evi ∧ Evii ∧ Eviii]
+ Pr[MallSim]
Here, the second equality follows from the definition of SigExtFail
and Eviii, and the description of the extractor. The third equality
follows from the fact that ¬MallSim means that the hash function
on hash-input(π) has not been reprogrammed, and the fact that
ShouldExt means verification succeeds, which means that condi-
tions (i) and (ii) are satisfied.
Finally, by Lemmas F.3, F.2, and F.1, we conclude that this proba-
bility is negligible. □
solution, then F(c) = 1. Thus, AHF () outputs c such that F(c) = 1
with probability at least µ.
As in [84], we can simulate AHF () with another algorithm which
generates HF on the fly, and thus makes at most the same number
of queries to F that A makes to HF . Thus by applying Lemma 7
from [84], we get
µ ≤ 2(qH + 1)(2
3
)t/2.
□
Finally, as the sigma protocol underlying our proofs is only
computationally sound (because we use Hcom for our commitment
scheme), we need to argue that an extractor can extract from 3 valid
transcripts with all but negligible probability.
Lemma F.3. There exists an extractor EΣ such that for any ppt
quantum adversary A, the probability that A can produce (a, {(ν1, j ,
ν2, j)}j =1,2,3) such that (a, j,(ν1, j , ν2, j)) is a valid transcript for j =
1, 2, 3, but EΣ(a, {(ν1, j , ν2, j)}j=1,2,3) fails to extract a proof, is negli-
gible.
Proof. Recall that a = (y1, y2, y3, C1, C2, C3), and if all three tran-
scripts are valid, Cj = Hcom(ν1, j) = Hcom(ν2, j−1) for j = 1, 2, 3.
Thus, either we have ν1, j = ν2, j−1 for all j or A has found a colli-
sion in Hcom. But, Theorem 8 in [84] tells us that the probability
of finding a collision in a random function with k-bit output using
at most q queries is at most O((q + 1)32−k), which is negligible. If
ν1, j = ν2, j−1 for all j, then we have 3 kj||Viewj values, all of which
are pairwise consistent, so we conclude by the correctness of the
circuit decomposition, and the fact that (x = y, w) ∈ R iff ϕ(w) = y
that if we sum the input share in View1, View2, View3, we get a
witness such that (x, w) ∈ R. □
Theorem F.4. Our version of the Unruh protocol satisfies simulation-
extractability against a quantum adversary.
Proof. We define the following extractor:
(i)
3 )}
(i)
(1) On input π, compute hash-input(π) = {a(i), h(i) = (д
1 ,
(i)
2 , д
д
(2) For i ∈ 1, . . . , t: For j ∈ 1, 2, 3, check whether there is
(i)
a solution ν1, j ∈ G−1(д
j+1) such that
(a(i), j,(ν1, j , ν2, j)) is a valid transcript. If there is a valid
transcript for all j, output EΣ(a(i), {(ν1, j , ν2, j)}j=1,2,3) as
defined by Lemma F.3 and halt.
(3) If no solution is found, output ⊥.
), ν2, j ∈ G−1(д
(i)
j
First we define some notation, again borrowed heavily from [84]:
21