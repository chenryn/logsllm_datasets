›   n A { $  vu   9  H q ’    X    ’ H x\ j $ K   |  
在这种情况下，你需要能覆盖到足够远的地方，并且程序必须安装了一个异常处理器（它会被覆盖），如
果你能控制异常处理器的地址（存在于注册的异常结构中），那么用加载模块以外的地址覆盖它（这个地
址应该是有效的，例如操作系统模块中的地址等等），在新版操作系统中，大多数模块在编译时使用了
/safeseh，因此exploit将会失败，但是你仍然可以尝试在未启用/safeseh(正如在教程的第三部分解释
的)的dll中找到一个地址。毕竟，GS并不能保护堆栈中的 SEH域，只需要绕过SafeSEH保护，exploit
就可以成功。
在教程的第三部分，我们已经提到需要用pop/pop/ret指令的地址覆盖这个指针。（需要在nseh域上放
上一个能跳转到shellcode的指令），或者（如果你在程序的加载模块中找不到pop/pop/ret指令），你
可以观察下esp/ebp,查看下这些寄存器距离nseh的偏移，接下来就是查找这样的指令：
- call dword ptr [esp+nn]
- call dword ptr [ebp+nn]
- jmp dword ptr [esp+nn]
- jmp dword ptr[ebp+nn]
其中的nn就是寄存器的值到nseh的偏移。这些指令可能更容易找到，但它们同样可以正常工作，Immdbg
的插件pvefindaddr 可以帮你找到这种指令。
通过同时替换栈中和....ddddaaaattttaaaa 节中的ccccooooooookkkkiiiieeee 来绕过
另一种技术是通过替换加载模块.data节中的cookie值（它是可写的，否则程序就无法在运行中动态更
新cookie了）来绕过栈上的 cookie保护，并用相同的值替换栈中的 cookie，如果你有权在任意地方写
入任意值（4字节的任意写操作）-如果类似下边的指令造成访问违例，那表明可能是一个任意 4字节的
写操作。
mov dword ptr[reg1], reg2
（很明显，为了完成这个任务，你需要能控制 reg1和reg2）reg1应该包含需要写入的内存位置，reg2
应该包含你想写入这个地址的值。
利用未被保护的缓冲区来实现绕过
另外一个利用的机会是利用漏洞代码不包含字符串缓冲区（因此堆栈中就没有 cookie）这对拥有一个整
数数组或指针的函数同样有效。
[buffer][cookie][EH record][saved ebp][saved eip][arguments ]
例如：如果arguments不包含字符串缓冲区或指针，你就可以覆盖这些参数，因为事实上GS不会保护这
个函数。
通过覆盖上层函数的栈数据来绕过
当函数的参数是对象指针或结构指针时，这些对象或结构存在于调用者的堆栈中，这也能导致GS被绕过，
（覆盖对象和虚函表指针，如果你把这个指针指向一个用于欺骗的虚函数表，你就可以重定向这个虚函数
的调用，并执行恶意的代码。）。
通过猜测////计算出ccccooooooookkkkiiiieeee 来绕过
Reducing the Effective Entropy of GS Cookies
基于静态ccccooooooookkkkiiiieeee的绕过
最后，如果每次的cookie是相同/静态的，这样的话，你就可以在溢出时简单的把这个值放在堆栈的相应
位置上。
堆栈cookie保护调试及演示
为 了 证 实 堆 栈 中 cookie 的 行 为 ， 我 们 使 用 在 http://www.security-
forums.com/viewtopic.php?p=302855#302855上的一个简单的代码（在第四部分中使用过）。
如果给函数pr()传送多余500字节的数据，它将被溢出。
打 开 Visual Studio C++ 2008 （ Express 版 本 可 从 这 里 下 载
http://www.microsoft.com/express/download/default.aspx）并创建一个控制台程序。
为了让它能在VS2008中编译，我稍微修改了原来的代码。
// vulnerable server.cpp : Defines the entry point for the console application.
//
#include "stdafx.h"
#include "winsock.h"
#include "windows.h"
//load windows socket
#pragma comment(lib, "wsock32.lib")
//Define Return Messages
#define SS_ERROR 1
#define SS_OK 0
void pr( char *str)
{
char buf[500]=" ";
strcpy(buf,str);
}
void sError(char *str)
{
printf("Error %s",str);
WSACleanup();
}
int _tmain(int argc, _TCHAR* argv[])
{
WORD sockVersion;
WSADATA wsaData;
int rVal;
char Message[5000]=" ";
char buf[2000]=" ";
u_short LocalPort;
LocalPort = 200;
//wsock32 initialized for usage
sockVersion = MAKEWORD(1,1);
WSAStartup(sockVersion, &wsaData);
//create server socket
SOCKET serverSocket = socket(AF_INET, SOCK_STREAM, 0);
if(serverSocket == INVALID_SOCKET)
{
sError("Failed socket()");
return SS_ERROR;
}