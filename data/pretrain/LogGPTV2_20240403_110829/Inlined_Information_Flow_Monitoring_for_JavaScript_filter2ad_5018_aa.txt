title:Inlined Information Flow Monitoring for JavaScript
author:Andrey Chudnov and
David A. Naumann
Inlined Information Flow Monitoring for JavaScript
Andrey Chudnov
Stevens Institute of Technology
Hoboken, NJ 07030 USA
PI:EMAIL
David A. Naumann
Stevens Institute of Technology
PI:EMAIL
Hoboken, NJ 07030 USA
ABSTRACT
Extant security mechanisms for web apps, notably the “same-
origin policy”, are not suﬃcient to achieve conﬁdentiality
and integrity goals for the many apps that manipulate sen-
sitive information. The trend in web apps is “mashups”
which integrate JavaScript code from multiple providers in
ways that can undercut existing security mechanisms. Re-
searchers are exploring dynamic information ﬂow controls
(IFC) for JavaScript, but there are many challenges to achiev-
ing strong IFC without excessive performance cost or im-
practical browser modiﬁcations. This paper presents an in-
lined IFC monitor for ECMAScript 5 with web support,
using the no-sensitive-upgrade (NSU) technique, together
with experimental evaluation using synthetic mashups and
performance benchmarks. On this basis it should be possi-
ble to conduct experiments at scale to evaluate feasibility of
both NSU and inlined monitoring.
1.
INTRODUCTION
Many security issues are raised by web apps, especially
so-called mashups that integrate in a single page code from
multiple providers, including but not limited to third-party
ads. Much of the utility of integrated apps derives from
their manipulation of sensitive information including per-
sonal data and mission-critical data. Individuals and organi-
zations have security requirements including conﬁdentiality
and integrity. Such information ﬂow (IF) requirements pose
challenges both for mathematical modeling and for usable
policy speciﬁcation techniques. There are also challenges in
policy enforcement, i.e., information ﬂow control (IFC). En-
forcement is the topic of this paper. We assume that policy
is given in the form of security labels attached to inputs and
outputs, interpreted as specifying allowed dependencies, as
formalized in the standard notion of termination-insensitive
non-interference (TINI) [60].
Most client-side app code is written in JavaScript (JS), in
part because of its ﬂexible dynamic features —which exac-
erbate the diﬃculty of achieving security goals for mashups.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS’15, October 12–16, 2015, Denver, Colorado, USA.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-3832-5/15/10 ...$15.00.
DOI: http://dx.doi.org/10.1145/2810103.2813684.
JS engines are highly engineered for performance, which has
led some researchers to argue for inlined monitoring for IFC.
The main contribution of this paper is an inlined IFC mon-
itor that enforces non-interference for apps written in JS.
We present the main design decisions and rationale, together
with technical highlights and a survey of state of the art al-
ternatives. The tool is evaluated using synthetic case studies
and performance benchmarks.
On IFC. Browsers and other platforms currently provide
isolation mechanisms and access controls. Pure isolation
goes against integration of app code from multiple providers.
Access controls can be more nuanced, but it is well-known
that access control policies are safety properties whereas IF
policies are hyperproperties [19], deﬁned in terms of mul-
tiple executions. For example, TINI speciﬁes information
ﬂow using pairs of executions. Prior work showed that even
simple IF policies serve well to protect against common web
attacks (e.g. [18]), so IFC may be useful without fully solving
the problem of requirements speciﬁcation. One approach to
IFC is dynamic taint tracking, in which data is tagged with
security labels that are propagated during execution. Taint
tracking is very useful for catching bugs, misfeatures, and
malware, but it does not enforce TINI because it fails to de-
tect implicit ﬂows: state changes that would have happened
if a diﬀerent branch had been taken. Indeed, information can
also ﬂow via covert channels such as timing and power con-
sumption, but these are relatively diﬃcult to exploit in the
web setting and are outside the scope of this paper. In the
literature, works on taint tracking often use the term “in-
formation ﬂow”, emphasizing the intended purpose rather
than assured properties.
In this paper, IF and IFC refer
to TINI. Also, we focus on ﬁne-grained IFC, as opposed to
coarse grained policies which can be enforced by tagging at
the level of processes [55].
One way to enforce TINI is by static analysis, using types,
program dependence graphs, or theorem proving. Static
analysis avoids the performance cost of runtime mechanisms
and has the beneﬁt of detecting insecurities prior to program
execution. A complementary beneﬁt of dynamic enforce-
ment is that it can allow secure runs of a program even if
it has other runs that are insecure. Static analyses can be
excessively restrictive, due to conservative approximation of
heap structure etc., and some require extensive programmer-
supplied annotations. Features of JS, including eval (dy-
namically generated code), make static analysis particularly
diﬃcult. For this reason dynamic IFC is used in most work
on IFC for JS, including this paper.
629Goals and attack model for dynamic enforcement. The
conventional approach to dynamic IFC builds on tag track-
ing, i.e., instrumenting the execution in such a way that
potential ﬂows can be “observed”. Conceptually, the execu-
tion monitor performs an abstract interpretation of possible
alternate runs, in order to soundly approximate TINI [16].
Another approach, secure multi-execution (SME) [20, 26, 46,
6], achieves non-interference using simultaneous concrete ex-
ecutions of the program, one for each security level, suitably
orchestrated.
In the next paragraphs the term “monitor”
refers to any dynamic mechanism.
There are three primary correctness requirements for a
monitored program under a given policy. First, soundness
with respect to TINI: any violation of policy is detected by
the monitor. The second requirement is transparency, which
circumscribes allowed changes to behavior of the program to
be monitored. Some changes are necessary, as the monitor
must raise an alarm or halt execution when the program
is poised to output a value at level incompatible with the
level assigned by policy to that output channel. It may also
halt execution because the mechanism is unable to ensure
TINI even though there may be no actual violation. Such
“mechanism failure” is inevitable for reasons of undecidabil-
ity. Transparency has three aspects. If the monitor does not
detect a violation on a given run, then (1) the outputs are
the same as for the original program (a safety property) and
(2) all outputs do occur (a liveness property). Finally, (3)
if the monitor does detect a potential violation, this is re-
ported. In that case, outputs may be suppressed or altered
to avoid jeapardizing policy; the point is that the monitored
program does not silently diﬀer from the original’s behavior.
We call part (3) frankness. (To formalize TINI, it is conve-
nient to model a monitor as diverging silently when policy
might be violated, but this is seldom desirable in practice;
cf. [31].) The third requirement is permissiveness: to mini-
mize raising the alarm on executions that are semantically
secure.
Formalization of TINI embodies an attack model. Such
formalization is outside the scope of this paper but we sketch
a model of the attacker derived from the gadget attacker
model [1]. (AM0) The attacker does not have any special
network privileges. The only messages that she can read
are the ones directed at her own web server. (AM1) The
attacker can introduce arbitrary JS code in the web-page.
This might happen for one of the three reasons: (1) the user
directed the browser to visit the attacker’s web-site, (2) a
legitimate third-party web-site included a frame or a script
from the attacker’s web-site or (3) the attacker has injected
a script in a legitimate web-site via a cross-site scripting
vulnerability. However, code injected by the attacker should
comply to the standards of ECMAScript and HTML. We do
not support vendor-speciﬁc extension. (AM2) The attacker
cannot subvert or compromise the browser. We assume that
the client machine running the browser has not been com-
promised and cannot be inﬂuenced by the attacker outside
of injecting JS into pages. The JS engine implements correct
semantics of standards-compliant ECMAScript and does not
have vulnerabilities that allow to break the browser sand-
boxing model, or alter the semantics in any way.
(AM3)
The attacker knows the program (so they can learn from
implicit ﬂow), and they know the inliner, so their JS code
may attempt to disable or subvert the monitor. (AM4) The
attacker cannot observe power consumption and has a very
limited view of timing as aﬀorded by the API’s available to
JS programs.
In addition to the correctness requirements, deployability
and performance are important considerations. Despite en-
couraging preliminary results, it is not obvious that SME
scales well to policies with many security levels and to en-
compass APIs for web apps. In the rest of this paper, atten-
tion is focused on the conventional approach based on tag
tracking, for which we henceforth use the term monitor.
Hybrid and NSU monitoring. Monitoring can achieve high
precision, i.e., few false positives, by means of ﬂow sensitiv-
ity, meaning that the security level of a storage location
can change during execution. To achieve soundness, one ap-
proach is hybrid monitoring which depends on static analy-
sis of possible heap locations updated in branches not taken.
Based on such analysis, tags that represent an unbounded
number of such locations may need to be updated at control
ﬂow join points [44, 51, 40]. It is quite diﬃcult to imple-
ment sound static analysis for JS with acceptable precision
and performance —especially for code that uses eval, which
is ubiquitous on the web [50].
A technique that avoids the need for static analysis is no
sensitive upgrade (NSU) [62, 4] which disallows raising the
level of a location due to inﬂuences of branch conditions.
In order to track these inﬂuences eﬃciently monitors can
employ a stack of labels [51, 4], which is called a PC label
stack. Each label corresponds to the label of a branch con-
dition that has determined the path the program took to
arrive at the current point. We use this technique, adapted
to non-syntactic control-ﬂow. The key point of NSU is that
it achieves TINI without recourse to static analysis, at the
cost of some restrictiveness (mechanism failures).1 NSU can
be even more restrictive than static analyses (indeed, must
be [51]). Mitigation is possible in the form of explicit up-
grade annotations that cause the monitor to preemptively
raise the level on a location before a branch is taken.
In scenarios where legacy code is not a constraint, NSU-
based monitoring with programmer-provided upgrades has
been found viable in substantial case studies [25, 55] (albeit
for coarse grained policies). Another possibility is to infer
upgrade annotations through program testing [12]. How-
ever,
less encouraging experience with an NSU-based JS
monitor [28] led some researchers to devise a form of hybrid
monitoring in which static analysis is used dynamically to
infer upgrades; so correctness rests only on NSU but greater
permissiveness can be achieved [27].
What is not known is the extent to which NSU (with up-
grades) is compatible with existing code on the web. Several
prior works have made advances towards building practical
JS monitors, but considerable infrastructure is needed, e.g.,
to deal with many libraries, browser APIs, and obfuscated
code used in practice. And the language itself is compli-
cated and idiosyncratic. The JS interpreters in wide use
are highly engineered, using in particular complex just-in-
time (JIT) compilation of partial program traces. All JS
IFC tools known to us omit at least one major language fea-
ture, and many lack support for DOM and other standard
libraries. We report here on a new tool that should serve to
evaluate NSU at scale.
1Because raising the level on a location, due to implicit ﬂow,
would be harmless if the location would have been written
on all alternate control paths.
630Inlining and goals of this project. To date, most imple-
mentations of IFC monitoring either modify a JS interpreter
directly [11, 33, 26, 21, 59] or inject a custom interpreter
with a plug-in [6, 28]. This may facilitate ensuring trans-
parency and soundness, and it oﬀers the potential for spe-
cialized performance optimizations. However, there is an on-
going “arms race” between browsers, with fast development
of highly optimized engines, all based on JIT-compilation.
At best, a modiﬁed JS engine is only of use with the associ-
ated browser, and it may be impossible to maintain without
the assistance of the vendor. Some of the cited works on
IFC either turn oﬀ JIT compilation (interpreter modiﬁca-
tion) or incur performance penalties by running JS code in-
side a JIT-compiled interpreter (custom interpreter plug-in).
Work that does not harness JIT is doomed to have limited
practical use. We also believe that it is impractical to mod-
ify the JIT compiler directly to generate monitored code.
First, there are often several compilers working side-by-side,
each geared towards diﬀerent kinds of code. Second, the
complexity of modern tracing JIT compilers is staggering.
Previous works suggest an alternative:
inlining a moni-
In brief, the inliner
tor into the source program [17, 38].
turns a JS program into an instrumented program. The in-
strumented program runs in the context of additional JS
programs: the monitor core and API facades explained in
the sequel. Together these constitute a monitored program.
Inlining requires no browser modiﬁcation. It can be de-
ployed by an external HTML proxy, or at the server, or by
a hook in the JS interpretation/compilation pipeline [36].
An obvious advantage of inlining is portability across JS
engines. Just as importantly, inlined monitoring has the
potential to beneﬁt from JIT compilation. The engineering
and maintenance challenge is proportional to the complexity
of JS rather than the complexity of JIT compilers.
Nonetheless, the challenge is substantial. Unlike inlined
reference monitors for access control policies, IF monitoring
needs to be threaded through every execution step to track
all ﬂows. The interesting challenges include preserving the
order of evaluation, which is important since expressions can
have observable side-eﬀects, and preserving the semantics of
various kinds of references including the scope and prototype
chains in JS. Inlined monitor code is vulnerable to attacks
crafted to thwart the monitor, so the monitor operations,
label storage, etc must be tamper-resistant.
The design of our inlined monitor was guided by the fol-
lowing ﬁve primary goals. (1) Soundness and transparency.
(2) Tamper-resistance. (3) Simplicity: the inlining process
and monitored program should be as simple as possible, to
facilitate assurance of soundness, transparency, and tamper-
resistance. Formal proof of correctness is not, however, in
scope for our project.
(4) Modularity is important as we
would like to be able to modify aspects of monitoring quickly
and easily for purposes of experimentation (e.g., support
for diﬀerent response to policy and NSU violations, and
to explore variations on NSU like “permissive upgrade” [5,
10]). (5) JIT-friendliness: the transformed code should be
amenable to eﬃcient JIT compilation. An additional goal
is for the monitored program to retain the structure of the