存储项目数据定义表、商品定义表、用户数据表、日志数据表等。
水平切分(按照规则划分存储)
(cid:131) 当一个表中的数据量过大时，我们可以把该表的数据按照某种规则，例如 userID 散列，进行
划分，然后存储到多个结构相同的表，和不同的库上。
19.1.11. 两阶段提交协议
分布式事务是指会涉及到操作多个数据库的事务,在分布式系统中，各个节点之间在物理上相互独
立，通过网络进行沟通和协调。
13/04/2018 Page 220 of 283
XA 就是 X/Open DTP 定义的交易中间件与数据库之间的接口规范（即接口函数），交易中间件
用它来通知数据库事务的开始、结束以及提交、回滚等。 XA 接口函数由数据库厂商提供。
二阶段提交(Two-phaseCommit)是指，在计算机网络以及数据库领域内，为了使基于分布式系统
架构下的所有节点在进行事务提交时保持一致性而设计的一种算法(Algorithm)。通常，二阶段提
交也被称为是一种协议(Protocol))。在分布式系统中，每个节点虽然可以知晓自己的操作时成功
或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事
务的 ACID 特性，需要引入一个作为协调者的组件来统一掌控所有节点(称作参与者)的操作结果并
最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)。因此，
二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者
的反馈情报决定各参与者是否要提交操作还是中止操作。
19.1.11.1. 准备阶段
事务协调者(事务管理器)给每个参与者(资源管理器)发送 Prepare 消息，每个参与者要么直接返回
失败(如权限验证失败)，要么在本地执行事务，写本地的 redo 和 undo 日志，但不提交，到达一
种“万事俱备，只欠东风”的状态。
19.1.11.2. 提交阶段
如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，
发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过
程中使用的锁资源。(注意:必须在最后阶段释放锁资源)
19.1.11.3. 缺点
同步阻塞问题
1、 执行过程中，所有参与节点都是事务阻塞型的。
单点故障
2、 由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。
数据不一致（脑裂问题）
3、 在二阶段提交的阶段二中，当协调者向参与者发送 commit 请求之后，发生了局部网络异
常或者在发送 commit 请求过程中协调者发生了故障，导致只有一部分参与者接受到了
commit请求。于是整个分布式系统便出现了数据部一致性的现象(脑裂现象)。
二阶段无法解决的问题（数据状态不确定）
4、 协调者再发出 commit 消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那
么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道
事务是否被已经提交。
13/04/2018 Page 221 of 283
19.1.12. 三阶段提交协议
三阶段提交（Three-phase commit），也叫三阶段提交协议（Three-phase commit
protocol），是二阶段提交（2PC）的改进版本。
与两阶段提交不同的是，三阶段提交有两个改动点。
1、引入超时机制。同时在协调者和参与者中都引入超时机制。
2、在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是
一致的。也就是说，除了引入超时机制之外，3PC 把 2PC 的准备阶段再次一分为二，这样三阶段
提交就有CanCommit、PreCommit、DoCommit三个阶段。
19.1.12.1. CanCommit阶段
协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。
19.1.12.2. PreCommit阶段
协调者根据参与者的反应情况来决定是否可以继续进行，有以下两种可能。假如协调者从所有的
参与者获得的反馈都是Yes响应，那么就会执行事务的预执行假如有任何一个参与者向协调者发送
了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。
19.1.12.3. doCommit阶段
该阶段进行真正的事务提交，主要包含 1.协调这发送提交请求 2.参与者提交事务 3.参与者响应反
馈（ 事务提交完之后，向协调者发送Ack响应。）4.协调者确定完成事务。
19.1.13. 柔性事务
19.1.13.1. 柔性事务
在电商领域等互联网场景下，传统的事务在数据库性能和处理能力上都暴露出了瓶颈。在分布式
领域基于CAP理论以及BASE理论，有人就提出了 柔性事务 的概念。CAP（一致性、可用性、分
区容忍性）理论大家都理解很多次了，这里不再叙述。说一下 BASE 理论，它是在 CAP 理论的基
础之上的延伸。包括 基本可用（Basically Available）、柔性状态（Soft State）、最终一致性
（Eventual Consistency）。
通常所说的柔性事务分为：两阶段型、补偿型、异步确保型、最大努力通知型几种。
两阶段型
1、 就是分布式事务两阶段提交，对应技术上的XA、JTA/JTS。这是分布式环境下事务处理的
典型模式。
补偿型
2、 TCC型事务（Try/Confirm/Cancel）可以归为补偿型。
13/04/2018 Page 222 of 283
WS-BusinessActivity提供了一种基于补偿的long-running的事务处理模型。服务器A发起事务，
服务器B参与事务，服务器 A 的事务如果执行顺利，那么事务A就先行提交，如果事务 B也执行
顺利，则事务 B 也提交，整个事务就算完成。但是如果事务 B 执行失败，事务 B 本身回滚，这时
事务 A 已经被提交，所以需要执行一个补偿操作，将已经提交的事务 A 执行的操作作反操作，恢
复到未执行前事务 A 的状态。这样的 SAGA 事务模型，是牺牲了一定的隔离性和一致性的，但是
提高了long-running事务的可用性。
异步确保型
3、 通过将一系列同步的事务操作变为基于消息执行的异步操作, 避免了分布式事务中的同步
阻塞操作的影响。
最大努力通知型（多次尝试）
4、 这是分布式事务中要求最低的一种, 也可以通过消息中间件实现, 与前面异步确保型操作不
同的一点是, 在消息由 MQ Server 投递到消费者之后, 允许在达到最大重试次数之后正常
结束事务。
13/04/2018 Page 223 of 283
19.1.14. CAP
CAP 原则又称 CAP 定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability
（可用性）、Partition tolerance（分区容错性），三者不可得兼。
一致性（C）：
1. 在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份
最新的数据副本）
可用性（A）：
2. 在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备
高可用性）
分区容忍性（P）：
3. 以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，
就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。
13/04/2018 Page 224 of 283
20. 一致性算法
20.1.1. Paxos
Paxos 算法解决的问题是一个分布式系统如何就某个值（决议）达成一致。一个典型的场景是，
在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点执行相同的操作序列，那么
他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列，需要在每一条指令上执
行一个“一致性算法”以保证每个节点看到的指令一致。zookeeper 使用的 zab 算法是该算法的
一个实现。 在Paxos算法中，有三种角色：Proposer，Acceptor，Learners
Paxos三种角色：Proposer，Acceptor，Learners
Proposer：
只要 Proposer 发的提案被半数以上 Acceptor 接受，Proposer 就认为该提案里的 value 被选定
了。
Acceptor：
只要Acceptor接受了某个提案，Acceptor就认为该提案里的value被选定了。
Learner：
Acceptor告诉Learner哪个value被选定，Learner就认为那个value被选定。
Paxos算法分为两个阶段。具体如下：
阶段一（准leader确定 ）：
(a) Proposer选择一个提案编号N，然后向半数以上的Acceptor发送编号为N的Prepare请求。
(b) 如果一个Acceptor收到一个编号为N的Prepare请求，且N大于该Acceptor已经响应过的
所有 Prepare 请求的编号，那么它就会将它已经接受过的编号最大的提案（如果有的话）作为响
应反馈给Proposer，同时该Acceptor承诺不再接受任何编号小于N的提案。
阶段二（leader确认）：
(a) 如果Proposer收到半数以上Acceptor对其发出的编号为N的Prepare请求的响应，那么它
就会发送一个针对[N,V]提案的 Accept 请求给半数以上的 Acceptor。注意：V 就是收到的响应中
编号最大的提案的value，如果响应中不包含任何提案，那么V就由Proposer自己决定。
(b) 如果 Acceptor 收到一个针对编号为 N 的提案的 Accept 请求，只要该 Acceptor 没有对编号
大于N的Prepare请求做出过响应，它就接受该提案。
20.1.2. Zab
ZAB( ZooKeeper Atomic Broadcast , ZooKeeper 原子消息广播协议）协议包括两种基本的模
式：崩溃恢复和消息广播
13/04/2018 Page 225 of 283
1. 当整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断崩溃退出与重启等异常情
况时，ZAB就会进入恢复模式并选举产生新的Leader服务器。
2. 当选举产生了新的 Leader 服务器，同时集群中已经有过半的机器与该 Leader 服务器完成了
状态同步之后，ZAB协议就会退出崩溃恢复模式，进入消息广播模式。
3. 当有新的服务器加入到集群中去，如果此时集群中已经存在一个 Leader 服务器在负责进行消
息广播，那么新加入的服务器会自动进入数据恢复模式，找到 Leader 服务器，并与其进行数
据同步，然后一起参与到消息广播流程中去。
以上其实大致经历了三个步骤：
1.崩溃恢复：主要就是Leader选举过程
2.数据同步：Leader服务器与其他服务器进行数据同步
3.消息广播：Leader服务器将数据发送给其他服务器
说明：zookeeper章节对该协议有详细描述。
20.1.3. Raft
与Paxos不同Raft强调的是易懂（Understandability），Raft和Paxos一样只要保证n/2+1节
点正常就能够提供服务；raft 把算法流程分为三个子问题：选举（Leader election）、日志复制
（Log replication）、安全性（Safety）三个子问题。
20.1.3.1. 角色
Raft把集群中的节点分为三种状态：Leader、 Follower 、Candidate，理所当然每种状态负
责的任务也是不一样的，Raft运行时提供服务的时候只存在Leader与Follower两种状态；
Leader（领导者-日志管理）
负责日志的同步管理，处理来自客户端的请求，与Follower保持这heartBeat的联系；
Follower（追随者-日志同步）
刚启动时所有节点为Follower状态，响应Leader的日志同步请求，响应Candidate的请求，
把请求到Follower的事务转发给Leader；
Candidate（候选者-负责选票）
负责选举投票，Raft 刚启动时由一个节点从 Follower 转为 Candidate 发起选举，选举出
Leader后从Candidate转为Leader状态；
20.1.3.2. Term（任期）
在 Raft 中使用了一个可以理解为周期（第几届、任期）的概念，用 Term 作为一个周期，每
个Term都是一个连续递增的编号，每一轮选举都是一个Term周期，在一个Term中只能产生一
个Leader；当某节点收到的请求中Term比当前Term小时则拒绝该请求。
13/04/2018 Page 226 of 283
20.1.3.3. 选举（Election）
选举定时器
Raft 的选举由定时器来触发，每个节点的选举定时器时间都是不一样的，开始时状态都为
Follower某个节点定时器触发选举后Term递增，状态由Follower转为Candidate，向其他节点
发起RequestVote RPC请求，这时候有三种可能的情况发生：
1：该RequestVote请求接收到n/2+1（过半数）个节点的投票，从Candidate转为Leader，
向其他节点发送heartBeat以保持Leader的正常运转。
2：在此期间如果收到其他节点发送过来的 AppendEntries RPC 请求，如该节点的 Term 大
则当前节点转为Follower，否则保持Candidate拒绝该请求。
3：Election timeout发生则Term递增，重新发起选举
在一个 Term 期间每个节点只能投票一次，所以当有多个 Candidate 存在时就会出现每个
Candidate 发起的选举都存在接收到的投票数都不过半的问题，这时每个 Candidate 都将 Term
递增、重启定时器并重新发起选举，由于每个节点中定时器的时间都是随机的，所以就不会多次
存在有多个Candidate同时发起投票的问题。
在 Raft 中当接收到客户端的日志（事务请求）后先把该日志追加到本地的 Log 中，然后通过
heartbeat把该Entry同步给其他Follower，Follower接收到日志后记录日志然后向Leader发送
ACK，当 Leader 收到大多数（n/2+1）Follower 的 ACK 信息后将该日志设置为已提交并追加到
本地磁盘中，通知客户端并在下个 heartbeat 中 Leader 将通知所有的 Follower 将该日志存储在
自己的本地磁盘中。
20.1.3.4. 安全性（Safety）