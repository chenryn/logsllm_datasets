parsing time from the
parsing+matching time. The speedup ratio is computed as the
matching only time of sequential matching over the matching
only time of our scheme on the P4. For HTTP, we speed up the
matching by 8.8 ∼ 11.7 times. For WINRPC, we speed up the
matching by a factor of two to four although there are only 45
signatures.
Scalability: Figure 9 shows the scalability of NetShield in terms
of throughput under increasing number of rules, evaluated with an
1GB TH HTTP trace. The system throughput degrades gracefully
when increasing the number of rules. This is because the through-
put mainly depends on the number of matchers, not the number of
rules. In the beginning, including more rules will add more match-
ers, and thus increases the overhead. After about 400 rules, all
matchers have been included; thus, the throughput remains stable.
Memory Consumption
and Breakdown: There
are two types of memory
consumption:
the match-
ing data
for
ruleset
representing the
shared by all
the con-
nections and the memory
states maintained for each
connection. Table 7 shows
the memory usage of the matching data structure on 794 HTTP
vulnerability signatures and the breakdown. We only need about
DFA
NetShield
NetShield Breakdown
12.8KB
CS Matching
1.4MB
Trie
DFA
907KB
Integer Range Checking 0.3KB
Table 7: Size of matching data
structures on 794 HTTP signa-
tures.
5.29GB
2.3MB
structures
2882.3MB memory. The small memory usage is because vulnerability
signatures are deﬁned on multiple protocol ﬁelds. Thus the corre-
sponding matching data structure for each ﬁeld becomes simpler
and more memory efﬁcient. For comparison, we also calculate the
size of the combined minimized DFA on the same rule set derived
from Snort. We employ the same methodology used in [25]. The
result DFA size is 5.29GB.
Table 6 also shows the average memory usage per connection,
which is dominated by the parsing variables during the parsing. For
HTTP protocol, we need 14 bytes for parsing, 12 bytes for keeping
three individual matchers’ states (a ﬁeld can map to several match-
ers, maximum three in the HTTP case), 2 bytes (on overage) for
keeping Si, and zero byte for buffering protocol ﬁelds. For WIN-
RPC protocol, we need 15 bytes for parsing, 8 bytes for keeping
two individual matchers’ states, 4 bytes (on overage) for keeping
Si, and 5 bytes for buffering protocol ﬁelds.
Comparing With Existing Regex Approaches: While having
better accuracy than regex-based approaches, NetShield is not
slower. One of the state-of-the-art regex approaches, XFA [25, 26],
reports that, for 863 Snort HTTP rules, it needs 36 bytes/connection
and 1.08MB to store the XFA data structures. Their earlier
work [25] shows XFA can achieve 75 seconds/GB (108Mb/s) for
the Snort HTTP signatures on a 3GHz PC. Their later work [26] is
about seven times faster (Figure 9 in [26]). Therefore, we estimate
it can achieve about 756Mbps on the 3GHz PC. On the other hand,
for 973 Snort HTTP rules, NetShield needs 28 bytes/connection
and 2.3MB on shared data structures. It can achieve 1.9 ∼ 17 Gbps
for HTTP on a 3.8GHz single core P4. Due to the lack of their code,
we cannot make a direct comparison. Nevertheless, from the per-
formance metrics above, we believe the performance of NetShield
will be comparable to that of XFA. Moreover, by combining Net-
Shield with XFA, we can possibly achieve even better performance
with smaller memory requirement.
There are ﬁve reasons for NetShield to obtain similar or even
better performance comparing with regex-based approaches: (i) we
achieve fast protocol parsing; (ii) after parsing, the protocol ﬁelds
not used in signatures can be directly skipped, but regex-based ap-
proaches need to match every byte; (iii) the CS algorithm intro-
duces very little overhead; (iv) the matching operation for each
protocol ﬁeld is simple; (v) multiple regex rules can be converted
to one vulnerability signature (especially for binary protocols) to
reduce the ruleset size.
Comparing With Existing Vulnerability Signature Ap-
proaches: All existing approaches [9, 22, 29] use sequential
matching. We show our scheme speeds up 8.8 ∼ 11.7 times over
sequential matching for 794 signatures. We believe that the larger
the ruleset, the bigger the speedup ratio.
Worst Case Trafﬁc for the HTTP Ruleset: As mentioned in §4.3,
for WINRPC, we prove the CS algorithm works well even in the
worst case trafﬁc. For the HTTP ruleset, we use the greedy algo-
rithm to generate the worst case trafﬁc given the problem is NP-
Hard. We generate two synthetic traces with same trafﬁc charac-
teristics, except that one is the worst case trafﬁc but the other one
is normal. For the trace of the worst case trafﬁc, our scheme can
achieve 64.8% of the throughput of the normal one. It shows our
scheme works reasonably well even in the worst case.
7.3 Accuracy Evaluation
Previous work [9, 13, 22, 29] has already demonstrated that vul-
nerability signatures are much more accurate than existing regex-
based approaches. The results shown here are mainly to conﬁrm
that NetShield is also able to achieve good accuracy.
First, we evaluate three WINRPC vulnerabilities Snort tries to
detect: Bugtraq 8205, Bugtraq 6005 and MS08-067 (exploited by
the recent Conﬁcker worm). We ﬁnd some of the bit patterns in
Snort signature are not related to vulnerabilities. After we change
the bit pattern in the exploit code, the exploit still works, but Snort
cannot detect the attack and thus has false negatives. If we include
the bit patterns in normal requests, Snort will report the requests as
false positives. On the other hand, NetShield accurately detects all
the polymorphic variants we create from the real exploits.
Furthermore, we evaluate a 10-minute “clean” HTTP trace from
TH (1.2GB). In that period, Snort generates 42 alerts while Net-
Shield generates zero alert. We manually checked those alerts and
found they are all false positives.
8. RELATED WORK
Intrusion Detection/Prevention Systems. Snort uses the PCRE
library for regex matching guarded by a string matching based pre-
ﬁlter. However, the worst case performance is mainly decided by
the PCRE library, which is a NFA based approach and quite slow
[26]. Bro is another popular NIDS with a regex signature engine.
It can also access semantic information with an expressive policy
language, which is close to a general programming language. As
the tradeoff, it is hard to optimize its speed for detecting a large
number of vulnerabilities.
Regular Expression Matching Engines. The current research of
regex matching focuses on improving the matching speed and the
memory efﬁciency [7, 8, 17, 25, 26, 30]. However, as we men-
tioned, only relying on regexes is not enough. It is very hard to
extend these approaches to handle vulnerability signatures.
Protocol Parsing. In §5, we compare NetShield parsing with Bin-
PAC [20] and GAPA [9]. Recently, Schear et al. [22] proposed the
ﬁrst high-speed parsing design by leveraging on string matching to
locate the invariant string close to the required ﬁeld. They demon-
strated that their system works well when considering a small num-
ber of vulnerability signatures with sequential matching. On the
other hand, our goal is to design an automated parser generator that
can support a large number of vulnerability signatures.
Packet Classiﬁcation Algorithms. The SPMSM problem we for-
mulate is related to the classical packet classiﬁcation problem but is
more complex. Both problems are deﬁned on a set of matching di-
mensions, and allow wildcards. In [28], Taylor classiﬁed the packet
classiﬁcation techniques into four categories: exhaustive search,
decision tree, tuple space and decomposition. Unfortunately, none
of them can be directly applied to the SPMSM problem due to the
ﬁve characteristics of vulnerability signature matching (§ 4.1).
Ternary Content Addressable Memory (TCAM) uses brute-force
hardware parallelism to achieve fast exhaustive search for packet
classiﬁcation. However, it remains unknown how to apply TCAM
for the SPMSM problem. For example, currently there are no efﬁ-
cient ways to encode regexes used in vulnerability signatures into
TCAM. Decision tree algorithms such as HiCuts [16] and Hyper-
Cuts [24] require interleaving different dimensions (i.e., combining
them as a big tree), which is impossible when dealing with vulnera-
bility signatures since the ﬁelds arrive at different times. Moreover,
they need huge amounts of memory when being used with a large
number of wildcards. Tuple Space based algorithms [27] exploit
the fact that the ﬁve tuples in packet classiﬁcation are all integers so
that the tuple space is small. For vulnerability signatures with many
long string ﬁelds, the tuple space can be very large. Also, it cannot
handle regex matching which is required by vulnerability signa-
tures. The decomposition based approaches are not suitable either.
For example, the recursive ﬂow classiﬁcation (RFC) [15] partitions
all ﬁelds into ﬁxed-size chunks. It is remain unknown how to ex-
tend the scheme to work with variable-length string ﬁelds and reg-
ular expression matchers. Bit vector approaches [6, 18] need large
memory (O(N )) per connection and high computation overhead.
2899. DISCUSSIONS
When a vulnerability logic is deeply embedded in the applica-
tion, it is hard to directly use the protocol ﬁelds in the symbolic
predicates to describe the signature. In this case, we have to re-
cover the internal state of the application as the state variables and
use them in the symbolic predicates. We achieve this by inserting
into the protocol parser a function that partially reproduces the ap-
plication logic to compute and return the state variables. In this
way, we bear the extra computational overhead, but can detect all
possible vulnerabilities accurately. For example, Bugtraq ID 599
is a buffer overﬂow vulnerability in wu-ftpd 2.5.
If a deep FTP
path is created by making new directories recursively, the buffer
will be overﬂowed. However, neither the path nor the path length
is a protocol ﬁeld. To solve this problem, we insert a customized
function into the parser to calculate the path length, and use it in
the symbolic predicates. In all the vulnerabilities we have studied
including those mentioned in other papers [9, 10, 13, 29], there are
only a few such cases.
Another problem is that, when applying vulnerability signatures
at network level, ambiguities might arise if we do not know the
software variants running on the hosts. It is possible that a ﬂow can
trigger a vulnerability on variant A but not B. One solution is to
actively map the software variant and their versions on the enter-
prise network [23]. We argue that, even without knowing the exact
version, vulnerability signatures of popular software will not cause
false positives since normal trafﬁc will not trigger the vulnerabil-
ity; otherwise the software will crash often and cannot be popular.
Furthermore, different software variants might interpret the proto-
col slightly differently, which might cause parsing ambiguity. The
active mapping approach can help in this case as well.
10. CONCLUSIONS
In this paper, we present NetShield, the ﬁrst systematic design of
a vulnerability signature based parsing and matching engine. Es-
sentially, we propose the state machine based parsing execution
model and the CS algorithm for fast matching on a large vulner-
ability ruleset. We also implement, deploy, and release the Net-
Shield prototype. The real trace evaluation demonstrates that Net-
Shield achieves similar speed to that of the current regular expres-
sion based NIDS/NIPS while offering much better accuracy.
11. ACKNOWLEDGEMENTS
We gratefully acknowledge our shepherd, Cristian Estan, and the
anonymous reviewers for their valuable inputs on earlier versions
of this paper. We also thank Jian Chang, James West, Jim Spadaro
and Ying He for their contributions to the project. This work was
supported by US NSF CNS-0831508, and China NSFC (60625201,
60873250), 973 project (2007CB310701), 863 high-tech project
(2007AA01Z216) and Tsinghua University Initiative Scientiﬁc Re-
search Program. Opinions, ﬁndings, and conclusions are those of
the authors and do not necessarily reﬂect the views of the funding
sources.
12. REFERENCES
[1] 1998 DARPA Intrusion Detection Evaluation Data Set.
www.ll.mit.edu/mission/communications/
ist/corpora/ideval/data/1998data.html.
http://en.wikipedia.org/wiki/Conficker.
[2] Conﬁcker.
[3] DAG card.
http://www.endace.com/dag-8.1sx.html.
[4] NetShield Website. http://www.nshield.org.
[5] PRX Trafﬁc Manager. http://www.ipoque.com/
products/prx-traffic-manager.
[6] F. Baboescu and G. Varghese. Scalable packet classiﬁcation.
In proc. of ACM SIGCOMM, 2001.
[7] M. Becchi and P. Crowley. A hybrid ﬁnite automaton for
practical deep packet inspection. In Proc. of ACM CoNEXT,
2007.
[8] M. Becchi and P. Crowley. Efﬁcient regular expression
evaluation: Theory to practice. In Proc. of IEEE/ACM ANCS,
2008.
[9] N. Borisov, D. J. Brumley, H. J. Wang, J. Dunagan, P. Joshi,
and C. Guo. A generic application-level protocol analyzer
and its language. In proc. of NDSS, 2007.
[10] D. Brumley, J. Newsome, D. Song, H. Wang, and S. Jha.
Towards automatic generation of vulnerability-based
signatures. In Proc. of IEEE Security and Privacy
Symposium, 2006.
[11] B. Chazelle. Lower bounds for orthogonal range searching.
ii: The arithmetic model. Journal of the ACM,
37(3):439–463, July 1990.
[12] M. Costa, J. Crowcroft, M. Castro, A. Rowstron, L. Zhou,
L. Zhang, and P. Barham. Vigilante: End-to-end containment
of internet worms. In Proc. of ACM SOSP, 2005.
[13] W. Cui, M. Peinado, H. J. Wang, and M. Locasto. Shieldgen:
Automated data patch generation for unknown
vulnerabilities with informed probing. In proc. of IEEE
Security and Privacy, 2007.
[14] S. Dharmapurikar and V. Paxson. Robust tcp stream
reassembly in the presence of adversaries. In Proc. USENIX
Security Symposium, 2005.
[15] P. Gupta and N. McKeown. Packet classiﬁcation on multiple
ﬁelds. In proc. of ACM SIGCOMM, 1999.
[16] P. Gupta and N. McKeown. Classiﬁcation using hierarchical
intelligent cuttings. IEEE Micro, 20(1):34–41, Jan 2000.
[17] S. Kumar, S. Dharmapurikar, F. Yu, P. Crowley, and
J. Turner. Algorithms to accelerate multiple regular
expression matching for deep packet inspection. In Proc. of
ACM SIGCOMM, 2006.
[18] T. V. Lakshman and D. Stiliadis. High-speed policy-based
packet forwarding using efﬁcient multi-dimensional range
matching. In proc. of ACM SIGCOMM, 1998.
[19] Z. Li, X. Gao, Y. Chen, and B. Liu. Netshield: Matching
with a large vulnerability signature ruleset for high
performance network defense. Technical Report
NWU-EECS-08-07, Northwestern University, 2009.
[20] R. Pang, V. Paxson, R. Sommer, and L. Peterson. binpac: A
yacc for writing application protocol parsers. In proc. of
ACM IMC, 2006.
[21] V. Paxson. Bro: A system for detecting network intruders in
real-time. Computer Networks, 31, 1999.
[22] N. Schear, D. Albrecht, and N. Borisov. High-speed
matching of vulnerability signatures. In Proc. of RAID, 2008.
[23] U. Shankar and V. Paxson. Active mapping: Resisting nids
evasion without altering trafﬁc. In Proc. of IEEE Security
and Privacy, 2003.
[24] S. Singh, F. Baboescu, G. Varghese, and J. Wang. Packet
classiﬁcation using multidimensional cutting. In proc. of
ACM SIGCOMM, 2003.
[25] R. Smith, C. Estan, and S. Jha. XFA: Faster signature
matching with extended automata. In Proc. of IEEE Security
and Privacy, 2008.
[26] R. Smith, C. Estan, S. Jha, and S. Kong. Deﬂating the big
bang: Fast and scalable deep packet inspection with extended
ﬁnite automata. In Proc. of ACM SIGCOMM, 2008.
[27] V. Srinivasan, S. Suri, and G. Varghese. Packet classiﬁcation
using tuple space search. In proc. of ACM SIGCOMM, 1999.
[28] D. E. Taylor. Survey and taxonomy of packet classiﬁcation
techniques. ACM Comput. Surv., 37(3):238–275, 2005.
[29] H. J. Wang, C. Guo, D. R. Simon, and A. Zugenmaier.
Shield: Vulnerability-driven network ﬁlters for preventing
known vulnerability exploits. In Proc. of ACM SIGCOMM,
2004.
[30] F. Yu, Z. Chen, Y. Diao, T. V. Lakshman, and R. H. Katz.
Fast and memory-efﬁcient regular expression matching for
deep packet inspection. In Proc. of ANCS, 2006.
290