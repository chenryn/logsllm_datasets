1,2,5
1,2
解决面试题的思路135
1,2
1,2,3
1,2,3,5
茄
弹出数字
2
弹出数字
---
## Page 150
136
剑指Offer-
bool IsPopOrder(const int*pPush,
代码：
出序列。
都压入栈了仍然没有找到下一个弹出的数字，那么该序列不可能是一个弹
入辅助栈，直到把下一个需要弹出的数字压入栈顶为止。如果所有的数字
如果下一个弹出的数字不在栈顶，我们把压栈序列中还没有入栈的数字压
弹出序列的规律：如果下一个弹出的数字刚好是栈顶数字，那么直接弹出。
return bPossible;
if(pPush
bool bPossible=false;
形成了清晰的思路之后，我们就可以动手写代码了。下面是一段参考
总结上述入栈、出栈的过程，我们可以找到判断一个序列是不是栈的
if(stackData.empty() && pNextPop - pPop == nLength)
while(pNextPop-pPopstackData;
const
const
名企面试官精讲典型编程题（纪念版）
bPossible=true;
pNextPop ++;
stackData.pop();
if(stackData.top() != *pNextPop)
while(stackData.empty()11stackData.top()!=*pNextPop)
int*
break;
pNextPush ++;
if(pNextPush -pPush == nLength)
int*
stackData.push(*pNextPush);
break;
pNextPop=pPop;
pNextPush=pPush;
const int* pPop,int nLength)
---
## Page 151
下打印图4.5中的二叉树的过程。
下子也想不清楚遍历的过程。那面试的时候怎么办呢？我们不妨先分析-
序、中序或者后序遍历。由于我们不太熟悉这种按层遍历的方法，可能一
structBinaryTreeNode
右的顺序打印。例如输入图4.5中的二叉树，则依次打印出8、6、10、5、
面试题23：从上往下打印二叉树
9、11。
人
这道题实质是考查树的遍历算法，只是这种遍历不是我们熟悉的前
BinaryTreeNode*
int
二叉树结点的定义如下：
题目：从上往下打印出二叉树的每个结点，同一层的结点按照从左到
本题完整的源代码详见22_StackPushPopOrder项目。
本题考点：
测试用例：
源代码：
考查分析复杂问题的能力。刚听到这个面试题的时候，很多人可
特殊输入测试（输入两个NULL指针)。
考查应聘者对栈的理解。
压栈、弹出的过程，从中找出规律。
能都没有思路。这个时候，可以通过举一两个例子，一步步分析
序列)。
二个数组是或者不是第一个数组表示的压入序列对应的栈的弹出
功能测试（输入的两个数组含有多个数字或者只有1个数字，第
m_pRight;
m_pLeft;
第4章
解决面试题的思路137
---
## Page 152
3
138
9
A
为
剑指Offer-
复前面的打印操作，直至队列中所有的结点都被打印出来为止。
放到一个队列的末尾。接下来到队列的头部取出最早进入队列的结点，重
每一次打印一个结点的时候，如果该结点有子结点，则把该结点的子结点
图4.5一棵二叉树，从上往下按层打印的顺序为8、6、10、5、7、9、11
点，因此只要依次打印即可。整个打印过程如表4.4所示。
这个数据容器应该是一个队列。由于值为5、7、9、11的结点都没有子结
时又比这两个结点先取出，这就是我们通常说的先入先出，因此不难看出
值为10的结点。注意到值为10的结点比值为5、7的结点先放入容器，此
据容器中有三个结点，值分别为10、5和7。接下来我们从数据容器中取出
打印出值6之后把它的值分别为5和7的两个结点放入数据容器。此时数
就有两个结点了。按照从左到右打印的要求，我们先取出值为6的结点。
遍历到该结点时把值为6和10的两个结点保存到一个容器里，现在容器内
开始分析。为了接下来能够打印值为8的结点的两个子结点，我们应该在
5
通过上面具体例子的分析，我们可以找到从上到下打印二叉树的规律：
因为按层打印的顺序决定应该先打印根结点，所以我们从树的根结点
一名企面试官精讲典型编程题（纪念版）
8
打印结点11
打印结点9
打印结点7
打印结点5
打印结点10
打印结点6
打印结点8
操作
表4.4按层打印图4.5中的二叉树的过程
结点11
结点9、结点11
结点7、结点9、结点11
结点5、结点7、结点9、结点11
结点10、结点5、结点7
结点6、结点10
队列
---
## Page 153
优先遍历二叉树。
的一种特殊退化形式，从上到下按层遍历二叉树，从本质上来说就是广度
void PrintFromTopToBottom(BinaryTreeNode* pTreeRoot)
好的 deque（两端都可以进出的队列)。下面是用deque 实现的参考代码：
队列。实际上我们无须自己动手实现，因为 STL已经为我们实现了一个很
如何广度优先遍历一个有向图？这同样也可以基于队列实现。树是图
while(dequeTreeNode.size())
dequeTreeNode.push_back(pTreeRoot);
std::deque dequeTreeNode;
if(!pTreeRoot)
既然我们已经确定数据容器是一个队列了，现在的问题就是如何实现
本题扩展：
本题考点：
if(pNode->m_pRight)
dequeTreeNode.pop_front();
BinaryTreeNode *pNode=dequeTreeNode.front();
if(pNode->m_pLeft)
return;
考查应聘者对二叉树及队列的理解。
是解决这个问题的关键所在。
应聘者通过具体的例子找出其中的规律并想到基于队列的算法：
新概念，要在短时间内想明白遍历的过程不是一件容易的事情。
考查思维能力。按层从上到下遍历二叉树，这对很多应聘者是个
dequeTreeNode.push_back (pNode->m_pRight) ;
dequeTreeNode.push_back (pNode->m_pLeft);
第4章解决面试题的思路139
---
## Page 154
140剑指Offer-
就是一个递归的过程。对于序列5、7、6，最后一个数字6是左子树的根结点
右子树结点。
结点的左子树结点；后3个数字9、11和10都比8大，是值为8的结点的
根结点的值。在这个数组中，前3个数字5、7和6都比8小，是值为8的
点的值小；第二部分是右子树结点的值，它们都比根结点的值大。
前面的数字可以分为两部分：第一部分是左子树结点的值，它们都比根结
图4.6后序遍历序列5、7、6、9、11、10、8对应的二叉搜索树
有哪棵二叉搜索树的后序遍历的结果是这个序列，因此返回false。
图4.6二叉搜索树的后序遍历结果。如果输入的数组是{7，4,6,5}，由于没
个数字都互不相同。
历的结果。如果是则返回true，否则返回false。假设输入的数组的任意两
面试题24：二叉搜索树的后序遍历序列
全部被遍历为止。
是子结点）都依次放入队列。我们重复这个遍历过程，直到队列中的结点
的头部取出一个结点，遍历这个结点之后把从它能到达的结点（对树而言
我们把起始结点（对树而言是根结点）放入队列中。接下来每一次从队列
我们接下来用同样的方法确定与数组每一部分对应的子树的结构。这其实
以数组{5,7,6,9,11,10,8}为例，后序遍历结果的最后一个数字8就是
在后序遍历得到的序列中，最后一个数字是树的根结点的值。数组中
例如输入数组{5,7,6,9,11,10,8}，则返回true，因为这个整数序列是
9
题目：输入一个整数数组，
不管是广度优先遍历一个有向图还是一棵树，都要用到队列。第一步
8
一名企面试官精讲典型编程题（纪念版）
，判断该数组是不是某二叉搜索树的后序遍
---
## Page 155
bool VerifySquenceOfBsT(int sequence[],int length)
考代码：
4、6、5。
二叉搜索树的定义。因此不存在一棵二叉搜索树，它的后序遍历的结果是7、
但我们发现在右子树中有一个结点的值是4，比根结点的值5小，这违背了
搜索树中，根结点上是没有左子树的，数字7、4和6都是右子树结点的值。
结点，因此根结点的值是5。由于第一个数字7大于5，因此在对应的二叉
10 小，是值为10的结点的左子结点，而11则是它的右子结点。
同样，在序列9、11、10中，最后一个数字10是右子树的根结点，数字9比
的值。
return（left&& right）;
//判断右子树是不是二叉搜索树
if(i
TOOC
//在二叉搜索树中右子树的结点大于根结点
//在二叉搜索树中左子树的结点小于根结点
if(sequence == NULL Il length  root)
return false;
=i;
length
0；
true;
true;
第4章
---
## Page 156
142剑指Offer-
是应用这个思路，面试题6“重建二叉树”也是应用这个思路。
列和右子树对应的子序列，接下来再递归地处理这两个子序列。本面试题
树的根结点，再基于根结点把整棵树的遍历序列拆分成左子树对应的子序
一个数字是根结点的值。
果。
。这和前面问题的后序遍历很类似，只是在前序遍历得到的序列中，第
如果面试题是要求处理一棵二叉树的遍历序列，我们可以先找到二叉
输入一个整数数组，
本题完整的源代码详见24_SquenceOfBST项目。
举一反三：
测试用例：
源代码：
本题考点：
考查对二叉树后序遍历的理解。