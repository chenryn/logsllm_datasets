site with ahead-of-time (AOT) translation. As is described in [36],
PNaCl speeds up the loading time of PNaCl applications by caching
the translation of portable bitcode files at /
/PnaclTranslationCache. However, these caches are carried
over to the two private modes implemented: Incognito mode and
even Guest mode, hence providing potential mechanisms for web
tracking. For example, the developer can embed a PNaCl applica-
tion on his site, which sends a message to the site when it starts to
run on a user’s browser. The developer could measure the interval
between the time of HTTP request and the time of receiving the
message from the PNaCl application. If a relatively short interval is
observed, it is highly likely that the user is a returning visitor even
though he visits the site in private mode. As an illustration on the
feasibility of this inference attack, the loading time for a PNaCl app1
is about 3 seconds without cache and 0.1 seconds with cache.
Nvidia’s OpenGL cache. Similar to the PNaCl translation cache,
Nvidia’s OpenGL shader disk cache allows compiled shaders to
be cached to the system disk so that they do not need to be re-
compiled again later on, which can potentially save time by just
pulling these binaries from the disk instead. On Linux system, the
cache is usually stored at //.nv/GLCache/. These
caching data are persisted regardless of which mode the browser
is running on. Therefore, by probing the content in their cache,
it is possible to infer which website a user has visited, especially
with websites that contain rich WebGL contents. We show a simple
inference attack based on WebGL cache size only given the fact
that the cache size is highly correlated to the richness of WebGL
contents. For example, visiting a lightweight WebGL demo2 yield
a 52,911 bytes increase in cache size while a heavyweight WebGL
demo3 yield a 176,777 bytes increase in cache size. Hence, by mere
measuring the increase in cache size, we could infer whether the
webpage user visited is rich in WebGL contents. This inference is
reasonable as websites with rich WebGL contents tend to be more
gaming or video oriented, implying that the user might played a web
game in the browsing session.
3.4 Unit and Regression Testing
UVERIFIER, like other dynamic tools, requires external trigger-
ing of privacy-related features to be tested. Therefore, it makes
perfect sense for browser developers or add-on developers to inte-
grate UVERIFIER into their unit and regression testing procedures to
1available at http://gonativeclient.appspot.com/demo/
lua
2available
animation_cloth
3available
US/demos/detail/the-polar-sea/launch
http://threejs.org/examples/#webgl_
https://developer.mozilla.org/en-
at
at
Figure 4: UCOGNITO architecture and its UCOGNITO interaction with
browser and persistence layer. Upon initialization of UCOGNITO, data in
persistence layer is brought to the filesystem sandbox based on the policy
specified. In this case, a COPY policy is attached to both autofill DB and
bookmarks to allow them being transferred to the filesystem sandbox 1 , 2
while transferring of cookie DB is prohibited by a CLEAN policy, therefore, an
empty cookie DB is created. During the private browsing session, browser
services will only interact with the data in filesystem sandbox ( 3 - 8 ), which
gives the browser an impression that it is interaction with the underlying
persistence layer. Upon finishing of the browsing session, data is written
back to the persistence layer ( 9 ) if it is attached with the WRITE policy.
maximize code coverage by UVERIFIER and eliminate unintentional
mistakes that lead to privation violations.
For cautious users whose browsing habits are fairly stable, they
can employ UVERIFIER to check against privacy violation cases in
their normal browsing and add-on usage pattern.
4. UCOGNITO: NEW FRAMEWORK FOR
PRIVATE BROWSING
Designing and implementing private mode can be non-trivial as
illustrated in §2 and §3. Motivated by this, we propose UCOGNITO
that radically changes the view of private mode in browser and the
way how it should be implemented.
4.1 Overview
In UCOGNITO, we decouple private mode implementation from
browser code base, i.e., we do not consider private mode as a
browser-specific feature which, implementation-wise, is indispens-
able from the browser code base. Instead, we consider it as an
customizable overlay that will automatically provide the intended
privacy goals of private mode when put on top of any browser
implementation.
To achieve this goal, UCOGNITO abstracts out the notion of pri-
vate mode from browsers and contains all the logic related to private
mode within itself. In other words, at runtime, the browser is trans-
parent to which mode it is running in and will always uses the exact
same code and logic for both private and public mode. In this way,
private mode effectively becomes a concrete and separate module
instead of pieces of logics scattered across all features that might
persist data and UCOGNITO serves as one central point for testing
and configuring private mode.
4.2 Architecture
Filesystem sandboxing. As shown in Figure 4, UCOGNITO em-
ploys filesystem sandboxing to give browsers an impression that
it is interacting with the actual filesystem in the persistence layer
CookieServicePersistent storageBrowserUcognitoFilesystem SandboxCookie DB...Autofill DBBookmarkServiceAutofillService...r/--/-②①③④⑤⑥⑦⑧⑨Bookmarksr/wCookie DB...Autofill DBr/--/-Bookmarksr/wUser's policywhile in fact, the browser only interacts with the sandboxed filesys-
tem. Such a design creates an isolated filesystem environment for
the private browsing session and hence, all traces generated in the
session are collected and retained in the sandbox.
Policy system. Policy system kicks in at two points,
• Upon starting a private browsing session, only persistent data
that are explicitly given the "read" access are copied into the
filesystem sandbox.
• Upon finishing the private browsing session, traces collected
in the sandboxed filesystem are conditionally written back to
the filesystem in persistence layer if such data is given the
"write" access. For the traces that are not written back, they
are discarded after the session finishes as the whole filesystem
sandbox only lives in memory, which is freed after the private
browsing session.
4.3 Challenges and Solutions
The design of UCOGNITO involves two challenges. First, it needs
to respect the heterogeneity in the interpretation of private mode
by different browser vendors and users, as described in §2.1 Sec-
ond, it has to address both privacy goals defined in §2.2 and be
indistinguishable to websites as shown in §2.3.
To accommodate heterogeneity in the interpretation of private
mode, UCOGNITO employs a policy system to allow for flexible
configuration on the storing or using of each type of persistent data.
In the view of the policy system, each file in the filesystem is bundled
with two policies:
• Allow/deny write access, corresponding to whether the per-
sistent data is allowed to be stored in the file during a private
browsing session.
• Allow/deny read access, corresponding to whether persistent
data contained in this file can be used during a private brows-
ing session.
Hence, by toggling the policies bundled with each file, both users
and browser vendors can express their interpretation of private mode.
In guaranteeing the stealthiness and freshness goals, we design
the policy system to take the "whitelist" approach. To be specific,
the following logic is wired into the policy system:
• Strongest protection by default: without any policy specified,
complete isolation, i.e. deny all read/write accesses, must be
assumed.
• Conservativeness: any type of persistent data that is not ex-
plicitly agreed or expected by the user should not be left or
shared. In other words, if storing or using of persistent data is
intended, it must be mentioned as a policy.
This ensures that users have full knowledge and control on the types
of persistent data stored and used in private mode. Therefore, by
definition, both stealthiness and freshness goals are achieved
UCOGNITO also increases the indistinguishability between pri-
vate mode and public mode by eliminating attacks that rely on the
differences in browser implementation of public mode and private
mode. For example, the hyperlink attack demonstrated in [1] relies
on the fact that most browsers do not render visited link in purple
in private mode. With UCOGNITO, such attack will effectively be
mitigated.
4.4 Sandboxing Layer
To isolate the traces of a private browsing session from the system,
our general approach is to apply a filesystem sandbox on the com-
mercially off-the-shelf web browsers. We assume that the filesystem
is the only persistent storage on the system. In other words, we
ignore all in-memory components as it has already been isolated
under the process isolation mechanism on the system.
Isolation of the filesystem can be done by rewriting the path
to a contained location, in particular, by intercepting system calls
on its entrance. When the browser accesses a file with the open
system call, our sandbox hooks its entrance and changes the “path”
argument to the sandbox directory. For example, if the path is to
/home/user/.config/*, we redirect this to
/tmp/ucognito-PID/home/user/.config/*. This redirection was
originally introduced in MBox [17].
However, MBox only supports the redirection of the filesystem
to the ephemeral location (e.g. /tmp/*), and it lacks the policy to
determine which file to read or not to read, and only has manual
options to discard or commit the changes to the host filesystem from
the sandbox. In UCOGNITO, we need to support more options such
as choosing files to be included or to be cleaned, and then writing
back the configurations to the original profile. Accordingly, we add
features to MBox to support selective writing on all changes in the
filesystem. Implementation details of our sandbox is described in
section §5.1.
4.5 Policy System
To satisfy the flexibility requirement, i.e. configurable private
mode, in UCOGNITO, we provide a policy system over sandbox
isolation. The types of policies are:
original user profile to the private profile;
• CLEAN: create an empty file to prevent file-copying from the
• COPY: copy a file or sub-directory to the private profile from
• WRITE: allow data to be written back to the user profile after
existing user profile, to employ existing settings;
the session closes.
We use the CLEAN policy to support running a browser or an exten-
sion at its pristine stage (i.e. first-time execution of the browser). If
a path is specified as CLEAN, we create an empty directory and files
for its sub-directory elements and then redirect all further accesses.
Next, the COPY policy is to allow carrying of selected existing in-
formation to the sandbox. A path either from the original profile
or from a different location can be chosen to load into the sandbox
filesystem. For the WRITE policy, we memorize the original location
where it is read (i.e. from COPY), then write back the trace after the
browser instance terminates.
These policies are defined to determine which files are loaded into
the profile, and what data are committed back to the profile. COPY
and CLEAN are for “read” property, as it determines how to load a
profile into the session. WRITE is for “write” property, as it specifies
how to deal with trace data created by the session.
Enforcement of these policies are done as follows. For CLEAN
files, we create files on the sandbox location; for COPY, we copy
the file from the location to the sandbox path. After creation of the
files, we restrict the browser instance’s access (using further open,
read, write, etc.) to the file within the sandbox container. The
WRITE policy is enforced at the end of execution of the web browser
session. When exiting the sandbox, all files specified with WRITE
are written back to the original location of the filesystem with the
contents of the files in the sandbox filesystem.
The policy can be defined as INI-style file (a .cfg file); each
policy is divided into sections (e.g. [copy] and [clean]) with the
listing of files or directory entries (if ends with “/”)
Example: Chrome’s Private Browsing. We present examples of
our policy definition for the Incognito mode and Guest mode of
Google Chrome in Figure 5 and Figure 6, respectively.
In Incognito mode, Google Chrome is allowed to read: 1) brows-
ing history, 2) autofills, 3) download entries, 4) per-site preferences,
5) custom SSL certificates, 6) bookmarks, and 7) extension storage.
To support each of these, we list the files that belong to each ac-
cess at the COPY sections. Then, we mark the directory that Google
Chrome stores user profile for the normal instance in a CLEAN sec-
tion to prevent accesses to the files that are not specified in the COPY
sections. The Incognito mode of Google Chrome stores bookmarks
and extension storage that have been changed during the private
mode execution. Thus, we specify files and directories reserved for
those data at the WRITE section to store the changes when the session
terminates.
The policy definition for Guest mode of Google Chrome is quite
simple. Since it does not need to access anything from the user’s
profile except for the certificate store cert9.db, we just mark the
home directory for the user as CLEAN and add both COPY and WRITE
cert9.db. These examples show that our policy is flexible enough to
easily support existing implementation of private modes of different
web browsers.
With these two policy files, it is clear to see that the Guest mode
provides much stronger browsing privacy than the Incognito mode.
It also shows that it is easy to customize, i.e., if a user is not satisfied
with the policy for Incognito mode, he/she could easily modify it to
meet his/her own privacy needs. Implementation details of policy
are described in §5.2.
5.
IMPLEMENTATION
We implemented the sandbox, the policy, and additional UI layer
(in §5.3) on the Linux operating system, for the distribution Ubuntu
14.04 LTS that runs Linux Kernel 3.13.0. Since we utilize Com-
puting/Berkeley Packet Filter (seccomp-bpf [9]) for system call
hooking mechanism, we need the kernel version over 3.5.
Figure 7 shows that the complexity of the implementation of
UCOGNITO in terms of lines of code. We only wrote 564 lines of
code to support all three layers, which we describes in the following
subsections.
5.1 Sandboxing Layer
We implemented the sandboxing layer using the same mechanism
in a MBox filesystem sandbox [17]. Basically, the sandbox hooks all
file-related system calls, then rewrites the path argument to isolate a
file at certain path into an ephemeral location, i.e. under /tmp.
System call hooking. System call hooking is done with seccomp-
bpf, which provides an easy and fast way of intercepting system
call entry/exit. We placed hooks on 50 system calls that deal with
file path. For example, open, creat, unlink, stat, mkdir, rmdir,
symlink, readlink, etc. are the system calls that operate on an
argument that specifies a location in the filesystem.
In addition to the file-related system calls, we additionally placed
a hook on the bind system call. The reason is that when bind is
called with the AF_UNIX argument (to create a Unix Socket), the port
that the socket is bounded to is not a network location; instead, it is
a file path (e.g. /tmp/.com.google.chrome.*/SingletonSocket).
Therefore, we place a hook on bind, and on its entrance, check if it
is called for AF_UNIX. Then, we rewrite the path if it is required to
be contained in the sandbox.
Note that we do not place any hook for read, write, send, or
recv, which are very frequently called in networked applications
like web browser. Since we rewrite the “path” argument only at the
entrance of the system call, the interception happens very rarely and
the overhead of hooking is very low. See §6 for the details.
1 # copy section: copying files from the user profiles
2 [copy]
3 # Use: browsing history
4 ~/.config/google-chrome/Default/History
5 ~/.config/google-chrome/Default/History-journal
6 ~/.config/google-chrome/Default/Visited Links
7 ~/.config/google-chrome/Default/Favicons
8 ~/.config/google-chrome/Default/Favicons-journal
9 ~/.config/google-chrome/Default/Top Sites
10 ~/.config/google-chrome/Default/Top Sites-journal
11
12 # Use: autofill data
13 ~/.config/google-chrome/Default/Login Data
14 ~/.config/google-chrome/Default/Login Data-journal
15 ~/.config/google-chrome/Default/Web Data
16 ~/.config/google-chrome/Default/Web Data-journal
17
18 # Use: per-site preferences
19 ~/.config/google-chrome/Default/Preferences
20 ~/.config/google-chrome/Default/Secure Preferences
21
22 # Use: SSL certificates
23 ~/.config/google-chrome/Default/TransportSecurity
24 ~/.config/google-chrome/Default/Origin Bound Certs
25 ~/.config/google-chrome/Default/Origin Bound Certs-journal
26
27 # Use: SSL client certificates
28 ~/.pki/nssdb/cert9.db
29
30 # Use: bookmarks
31 ~/.config/google-chrome/Default/Bookmarks
32
33 # Use: extension storage
34 ~/.config/google-chrome/Default/Local Extension Settings/
35
36 # clean section: exclude files & sub-directories
37 [clean]
38 # exclude all other files in the home directory
39 ~/
40
41 # write section: write-back data to the user profile
42 [write]
43 # write-back bookmarks
44 ~/.config/google-chrome/Default/Bookmarks
45 # write-back client certificates
46 ~/.pki/nssdb/cert9.db
47 # write-back extension storages
48 ~/.config/google-chrome/Default/Local Extension Settings/
Figure 5: Policy configuration file for the private mode of Google Chrome.
1 # exclude all files in home directory
2 [clean]
3 ~/
4
5 # Use: SSL client certificates
6 [copy]
7 ~/.pki/nssdb/cert9.db
8
9 # write-back client certificates
10 [write]
11 ~/.pki/nssdb/cert9.db
Figure 6: Policy configuration file for the guest mode of Google Chrome.
Containing file access. To contain file accesses, we rewrite the
path argument on each system call entrance. For example, on open
system call, if the first argument (path) is on /home/user/.config,
then we overwrite the path into the contained location (e.g. /tmp)