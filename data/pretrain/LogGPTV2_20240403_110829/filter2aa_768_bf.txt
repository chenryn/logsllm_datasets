CPU 在将线性地址翻译为物理地址时检测到了如下情况： 
进行地址翻译所需的页表（page-table）或页目录（page-directory）表项的 P（Present）
标志为 0。P 标志为 0 表示包含操作数的页表或页不在物理内存中。 
《软件调试》补编 
- 124 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
当前程序没有足够的权限访问指定的页（比如，用户模式下的函数访问管理模式使用
的页）。 
运行在用户模式下的代码试图写只读属性的内存页。从 486 开始，如果 CR0 寄存器
的 WP（Write Protect）标志为 1，那么运行在管理模式的代码如果写只读属性的用户
态内存页也会触发页错误异常。 
取指到（fetch instruction to）一个线性内存地址时，该地址被翻译为物理地址后所在
的内存页设置了禁止执行（execute-disable）标志。 
页目录表项的一或多个保留位被设为 1。参见下面对 RSVD 错误码标志的描述。 
错误代码：处理器会向异常处理例程的堆栈压入一个特殊格式的错误码。该错误码的
格式（参见图 C-1）不同于其它异常所使用的格式（图 3-2）。 
图 C-1  页错误异常的错误码 
P 位如果为 0 则表示该异常是由于页不存在所导致的，如果为 1 则表示该异常是因为
违反访问权限或使用保留位所导致的。 
W/R 位表示导致该异常的内存访问是读（0）还是写（1）操作。 
U/S 位表示异常发生时处理器是在用户模式（1）还是内核模式（0）下执行。 
RSVD 位为 1 表示当 CR4 寄存器的 PSE 或 PAE 为 1 时，CPU 检测到页目录的 1 或多
个保留位中包含 1。如果 RSVD 位为 0，那么该异常不是由于设置保留位而导致的。 
I/D 位表示该异产是否是由于取指操作导致的（1 是，0 否）。如果 CPU 不支持禁止执
行位或者没有启用禁止执行位，那么 I/D 位保留。 
除了错误码，CPU 还提供了另一个信息供页错误异常处理例程分析异常原因。在产
生异常前，CPU 会把导致异常的 32 位线性地址加载到 CR2 寄存器中。异常处理例程可以
使用该地址来定位对应的页目录和页表表项。在执行页错误异常例程时还有可能再发生页
错误，而且每次发生页错误异常时，CPU 都会更新 CR2 寄存器，为了防止前一次异常的
线性地址被第二次异常的线性地址所覆盖，异常处理程序应该在发生第二次异常前将 CR2
寄存器的内容保存起来。 
如果页错误异常是由于违反页面级保护规则8而导致的，那么当错误发生时，CPU 会
8 从内存管理角度来看，可以把保护机制分为段级（主要通过段描述符定义的）和页级（主要通过页面属
《软件调试》补编 
- 125 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
设置页目录表项的访问标志。但是页表表项访问标志的规则是与处理器型号有关的。 
保存的程序指针：通常栈中保存的 CS 和 EIP 值指向的是产生异常的那条指令。如果
实在任务切换过程中发生的页错误异常，那么 CS 和 EIP 值指向的可能是新任务的第一条
指令。 
程序状态变化：通常不会导致程序状态变化因为导致错误的指令没有被执行。异常处
理例程可以纠正错误（比如将不在物理内存中的页面加载到内存中，这便是虚拟内存的基
本工作原理），然后恢复被中断的程序。 
但是如果实在任务切换的过程中发生了页错误异常，那么程序状态可能变化。在切换
任务时，以下任何操作都可能导致页错误异常： 
将原来任务的状态（寄存器等）写到该任务的 TSS（任务状态段）中。 
从 GDT 表中读取信任务的 TSS 的段描述符。 
读新任务的 TSS。 
读新任务中的段选择子指向的段描述符。 
读新任务的 LDT（局部描述符表）以验证保存在新任务的 TSS 中的段寄存器。 
对于最后两种情况，异常会发生在新任务的上下文中，栈中保存的 CS 和 EIP 值指向
的是新任务的第一条指令，不是导致任务切换的那条指令。 
如果页错误异常是在任务切换过程中发生的，那么它可能发生在把控制权移交给新任
务那一点之前，也可能发生在巴控制权移交给新任务之后。如果是发生在之前，那么程序
状态没有改变。如果是发生在之后，那么处理器会在产生异常前继续从新的 TSS 加载所
有状态信息（而且不再做边界、类型和存在性检查）。所以异常处理例程不能假定使用 CS、
SS、DS、ES、FS 和 GS 段寄存器中的段选择子不会再导致异常。异常处理例程应该认真
检查每个段寄存器后再恢复运行原来的程序，否则可能再次发生错误使问题更难定位和解
决。 
C.16  x87 FPU 浮点错误异常（#MF） 
向量号：16 
异常类型：错误（Fault） 
引入该异常的处理器：80286 最早引入该异常，其后的所有 IA-32 处理器都实现了该异
常。 
描述：该异常表示 x87 FPU（Floating-Point Unit）检测到当一个浮点错误。CR0 寄存
器的 NE 标志位为 1 时允许产生该异常（NE 标志为 0 的情况见下文）。 
x87 FPU 可以检测并报告 6 种浮点错误情况： 
无效运算（#I）：又包括栈溢出和下溢（underflow）（#IS）；以及无效的算术运算（#IA）。 
除零（#Z）。 
非规格化（denormalized）的操作数（#D）。 
数值溢出（#O）。 
数值下溢（#U）。 
性定义的）保护。 
《软件调试》补编 
- 126 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
结果不精确（#P），P 代表精度（Precision）。 
以上的每种错误情况对应于 x87 FPU 的一种异常类型。对每一种异常类型，x87 FPU
的状态寄存器和控制寄存器分别提供了一个标志和一个屏蔽位。如果 x87 FPU 检测到一个
浮点错误，而且控制寄存器中该异常类型的屏蔽位为 1，那么 x87 FPU 会自动处理该异常：
产生一个预先定义（缺省的）的回应然后继续执行。对于大多数浮点应用，缺省响应可以
提供合理的结果。 
如果异常类型对应的屏蔽位为 0，而且 CR0 寄存器的 NE（Numeric Error）标志位为
1，那么 x87 FPU 会采取如下动作： 
1. 
在 FPU 状态寄存器中设置必要的标志。 
2. 
如果遇到等待型 x87 FPU 指令或 WAIT/FWAIT 指令，便在执行该指令前产生一个内部信号
使 CPU 产生一个浮点错误异常。这里要说明的是如果程序中一直没有这样的指令，那么该异常
便不会被报告。 
CR0 的 NE 标志为 0 可以使 x87 FPU 使用 PC 兼容方式（PC-Style，又叫 MS-DOS 兼
容方式）来报告浮点错误：当 IGNNE#管脚的信号有效（asserted）时，忽略所有 x87 浮点
错误；当 IGNNE#管脚信号无效（deasserted）时，如果有未屏蔽的（unmasked）x87 FPU
错误发生，那么处理器会在遇到下一个等待浮点指令（WAIT 或 FWAIT）时置起（assert）
FERR#管脚信号并进入冻结状态（停止指令执行）等待中断发生。在 PC 兼容系统中，FERR#
管脚信号会被送到级联的可编程中断控制器（PIC）芯片的 IRQ13 输入端。在 FERR#信号
的作用下，PIC 会产生中断使 CPU 进入处理浮点错误的中断处理例程。 
在执行等待型 x87 FPU 指令或 WAIT/FWAIT 指令之前，x87 FPU 会检查是否有等待
报告（pending）的浮点错误异常（上面的第二步）。对于非等待型（non-waiting）x87 FPU
指令（包括 FNINIT、FNCLEX、FNSTSW、FNSTSW AX、FNSTCW、FNSTENV 和 FNSAVE），
x87 FPU 不会检查是否有等待报告的异常。在执行浮点状态管理指令（FXSAVE 和
FXRSTOR）时，x87 FPU 也会忽略等待报告的异常。 
错误代码：无，x87 FPU 的状态寄存器提供了错误信息 
保存的程序指针：栈中保存的 CS 和 EIP 值指向的是产生 x87 FPU 浮点错误异常时将
要执行的 WAIT/FWAIT 或浮点指令。不是 x87 FPU 检测到导致浮点错误的那条指令。导
致浮点错误的指令的地址被存储在 x87 FPU 的指令指针寄存器中。 
程序状态变化：程序状态通常会变化，因为浮点错误异常发生后会被延迟到遇到下一
个等待型浮点指令或 WAIT/FWAIT 指令时汇报和处理。不过，因为 x87 FPU 保存了足够
多的信息，所以大多时候还是可以从错误中恢复，如果需要可以重新执行导致错误的指令。 
如果程序中有非 x87 FPU 指令依赖 x87 FPU 指令的结果，那么可以在该指令前插入一
条 WAIT/FWAIT 指令以强迫检查是否有等待报告的浮点异常。 
C.17  对齐检查异常（#AC） 
向量号：17 
异常类型：错误（Fault） 
引入该异常的处理器：486 处理器最早引入该异常，其后所有 IA-32 处理器都实现了该
异常。 
《软件调试》补编 
- 127 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
描述：32 位处理器通常具有 32 根数据线（比如 386 和 486），因此一次可以传递 4 个
字节（32 位）。从奔腾处理器开始，IA-32 处理器的数据线从 32 根增加到 64 根，一次可
以传递 8 个字节（64 位）。为了提高访问效率和简化电路设计，32 位数据总线的 CPU 总
是从能够被 4 整除的地址访问内存（每次 4 个字节）。64 位数据总线的 CPU 总是从可以
被 8 整除的地址访问内存（每次 4 个字节）。也就是说 CPU 的地址线总是选通（呈现）是
4 或 8 整数倍的地址。例如，奔腾 4 CPU 的地址线是 A[35:3]，共 33 根，代表高 33 位地
址（低 3 位省略），可以最多寻址 64G 物理内存。也就是说，这样的地址线已经不能表示
出不是 8 的整数倍的地址。当要访问非 8 整数倍的地址，那么就选通与其最接近的 8 整数
倍地址。举例来说，如果要读取地址 4 开始的 4 个字节，那么 CPU 便通过地址线输出地
址 0，并通过字节选中信号 BE#（Byte Enable）指定需要的是高 4 字节。如果要读取地址
7 开始的 4 个字节，那么就要向输出地址 0，取最高字节，然后再输出地址 8，取低 3 字
节，最后再通过移位操作将两次得到的数据合在一起。从这两个例子看到，同样是读取 4
个字节，前一种情况只要读取一次，后一种情况则要读取两次。分析原因，前一种情况要
读取的 4 字节数据的起始地址是可以被 4 整除的，这样的地址被称为是按 4 字节边界对齐
的。而后一种情况要读取的数据的起始地址是不可以被要读取的字节数整除，这样的地址
被称为是没有对齐的。 
从上面的分析我们看到 CPU 访问满足内存对齐要求的数据可以大大提高性能。另外，
对于某些数据区，CPU 要求其起始地址一定要是内存对齐的。内存对齐异常正是为了强
制这些要求而设计的。下表列出了各种数据类型或数据的内存对齐要求。 
表 C-4  内存对齐要求 
数据/数据类型 
地址必须可以被整除 
Word（字） 
Doubleword（双字） 
单精度浮点数（32 位） 
双精度浮点数（64 位） 
扩展双精度浮点数（double extended-precision floating-point）（80 位） 
Quadword（4 字） 
Double quadword 
段选择子 
32 位长指针 
48 位长指针 
32 位指针 
GDTR、IDTR、LDTR 或任务寄存器（TR）的内容 
FSTENV/FLDENV 保存区域 
FSAVE/FRSTOR 保存区域 
Bit String 
2 
4 
4 
8 
8 
8 
16 
2 
2 
4 
4 
4 
4 或 2* 
4 或 2* 
4 或 2* 
*依赖于操作数长度（size）。 
值得注意的是仅当满足以下条件时，CPU 才会启用内存对齐检查： 
CR0 寄存器的 AM（Alignment Mask）标志为 1。 
EFLAGS 寄存器的 AC（Alignment Check）标志为 1。 
CPU 处于保护模式或虚拟 8086 模式，并且 CPL（当前权限级别）为 3。 
也就是说只有当 CPU 在用户模式下操作时才会进行内存对齐检查。缺省指向 0 特权
级的内存引用（比如加载段描述符）不会导致对齐检查，即使该操作是由于用户模式下的
内存引用所导致的。 
《软件调试》补编 
- 128 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
如果满足了内存对齐检查的条件，而且 CPU 检测到违反表 2-8 规定的情况，那么 CPU
便会产生内存对齐检查异常（#AC），但有一个例外，对于 128 位的数据类型没有按 16 字
节边界对齐的情况，CPU 会以一般性保护异常（#GP）的形式报告。 
错误代码：无 
保存的程序指针：栈中保存的 CS 和 EIP 值指向的是产生异常的那条指令。 
程序状态变化：程序状态并没有变化，CPU 报告异常前会恢复到导致异常的指令被执
行前的状态，所以当异常处理程序纠正了错误情况后可以安全的恢复执行原来的程序。 
C.18  机器检查异常（#MC） 
向量号：18 
异常类型：中止（Abort） 
引入该异常的处理器：奔腾处理器最早引入该异常，其后所有 IA-32 处理器都实现了
该异常。 
描述：该异常表示 CPU 检测到一个内部错误或总线错误，或者系统的外部主体（agent，
比如内存控制器 MCH）检测到总线错误。外部主体检测到的错误是通过专门的 CPU 管脚
通知 CPU 的。奔腾 CPU 使用的是 BUSCHK#管脚，奔腾 4、至强、和 P6 系列处理器使用
的是 BINIT#和 MCERR#管脚。 
机器检查异常的具体工作方式是与处理器型号有关的。尤其是奔腾处理器和其后的
P6 及奔腾 4 处理器在这方面有较大的差异，详见 2.9 节。 
CR4 寄存器的 MCE 标志用来启用机器检查机制。 
错误代码：无，但是专门为机器检查机制设计的 MSR 寄存器提供了错误信息。 
保存的程序指针：对于奔腾 4 和至强处理器，扩展的机器检查状态寄存器中保存了当
CPU 检测到机器检查异常时的状态信息，包括通用寄存器、标志寄存器 EFLAGS、EIP 等，
而且这些信息是与发生的机器检查异常直接相关的。 
对于 P6 系列处理器，如果 MCG_STATUS_MSR 寄存器的 EIPV 标志为 1，那么保存
的 CS 和 EIP 值是与导致机器检查异常的错误直接有关的，如果该标志为 0，那么保存的
指令指针可能与发生的错误不相关。 
对于奔腾处理器，CS 和 EIP 寄存器的值可能与发生的错误相关，也可能不相关。 
程序状态变化：对于奔腾 4、至强、P6 系列和奔腾处理器，机器检查异常总会伴有程
序状态变化，而且机器检查异常是以中止类异常报告的。当中止类异常发生后，异常处理
程序可以收集各种信息供调试使用，但是通常不能恢复程序继续运行。 
如果没有启用机器检查机制，那么机器检查错误会导致 CPU 进入关机状态。 
C.19  SIMD 浮点异常（#XF） 
向量号：19 
异常类型：错误（Fault） 
引入该异常的处理器：奔腾 III 处理器最早引入该异常，其后所有 IA-32 处理器都实现
了该异常。 
《软件调试》补编 
- 129 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
描述：该异常表示 CPU 在执行 SSE/SSE2/SSE3 SIMD 运算时检测到错误。SIMD 是
Single Instruction Multiple Data，即单指令多数据的缩写，SIMD 是 MMX（MultiMedia 
Extensions，即多媒体扩展）技术的主要内容，其核心思想是使用 64 位的 MMX 寄存器，
一次对多个整数进行算术运算。SSE 是 Streaming SIMD Extension 的缩写，即 SIMD 流扩
展。SSE 将 SIMD 技术推广到可以对单精度浮点数进行单指令多数据计算。 
与 x87 FPU 浮点异常很类似，SIMD 浮点异常也被划分成 6 个子类： 
无效运算（#I）。 
除零（#Z）。 
非规格化（denormal）的操作数（#D）。 
数值溢出（#O）。 
数值下溢（#U）。 
结果不精确（#P），P 代表精度（Precision）。 
在以上六类异常情况中，无效操作、除零和非规格化的操作数属于计算前异常，也就