### 页错误异常（Page Fault Exception）

当CPU将线性地址翻译为物理地址时，可能会遇到以下情况：

1. **页表或页目录项的P标志为0**：进行地址翻译所需的页表或页目录表项的P（Present）标志为0，表示该页不在物理内存中。
2. **权限不足**：当前程序没有足够的权限访问指定的页。例如，用户模式下的代码试图访问管理模式使用的页。
3. **写保护**：运行在用户模式下的代码试图写入只读属性的内存页。从486处理器开始，如果CR0寄存器的WP（Write Protect）标志为1，那么即使运行在管理模式下的代码写入只读属性的用户态内存页也会触发页错误异常。
4. **禁止执行**：取指令到一个线性内存地址时，该地址被翻译为物理地址后所在的内存页设置了禁止执行（execute-disable）标志。
5. **保留位设置**：页目录表项的一个或多个保留位被设为1。具体参见对RSVD错误码标志的描述。

#### 错误代码
处理器会向异常处理例程的堆栈压入一个特殊格式的错误码，其格式如下：

- **P位**：如果为0，表示该异常是由于页不存在所导致；如果为1，表示该异常是因为违反访问权限或使用保留位所导致。
- **W/R位**：表示导致该异常的内存访问是读（0）还是写（1）操作。
- **U/S位**：表示异常发生时处理器是在用户模式（1）还是内核模式（0）下执行。
- **RSVD位**：为1表示当CR4寄存器的PSE或PAE为1时，CPU检测到页目录的一个或多个保留位中包含1。如果RSVD位为0，则该异常不是由于设置保留位而导致的。
- **I/D位**：表示该异常是否是由于取指操作导致的（1是，0否）。如果CPU不支持禁止执行位或者没有启用禁止执行位，那么I/D位保留。

除了错误码，CPU还提供了另一个信息供页错误异常处理例程分析异常原因。在产生异常前，CPU会把导致异常的32位线性地址加载到CR2寄存器中。异常处理例程可以使用该地址来定位对应的页目录和页表表项。在执行页错误异常例程时还有可能再发生页错误，因此每次发生页错误异常时，CPU都会更新CR2寄存器。为了防止前一次异常的线性地址被第二次异常的线性地址覆盖，异常处理程序应该在发生第二次异常前将CR2寄存器的内容保存起来。

#### 保存的程序指针
通常，栈中保存的CS和EIP值指向的是产生异常的那条指令。如果在任务切换过程中发生了页错误异常，那么CS和EIP值可能指向新任务的第一条指令。

#### 程序状态变化
通常不会导致程序状态变化，因为导致错误的指令没有被执行。异常处理例程可以纠正错误（例如，将不在物理内存中的页面加载到内存中，这是虚拟内存的基本工作原理），然后恢复被中断的程序。

然而，如果在任务切换过程中发生了页错误异常，程序状态可能会发生变化。在切换任务时，以下任何操作都可能导致页错误异常：
- 将原来任务的状态（寄存器等）写到该任务的TSS（任务状态段）中。
- 从GDT表中读取新任务的TSS的段描述符。
- 读新任务的TSS。
- 读新任务中的段选择子指向的段描述符。
- 读新任务的LDT（局部描述符表）以验证保存在新任务的TSS中的段寄存器。

对于最后两种情况，异常会发生在新任务的上下文中，栈中保存的CS和EIP值指向的是新任务的第一条指令，而不是导致任务切换的那条指令。

如果页错误异常是在任务切换过程中发生的，那么它可能发生在把控制权移交给新任务之前，也可能发生在之后。如果是发生在之前，程序状态没有改变。如果是发生在之后，处理器会在产生异常前继续从新的TSS加载所有状态信息（并且不再做边界、类型和存在性检查）。因此，异常处理例程不能假定使用CS、SS、DS、ES、FS和GS段寄存器中的段选择子不会再导致异常。异常处理例程应该认真检查每个段寄存器后再恢复运行原来的程序，否则可能再次发生错误使问题更难定位和解决。

### x87 FPU 浮点错误异常（#MF）

**向量号**：16  
**异常类型**：错误（Fault）  
**引入该异常的处理器**：80286最早引入该异常，其后的所有IA-32处理器都实现了该异常。

**描述**：该异常表示x87 FPU（Floating-Point Unit）检测到一个浮点错误。CR0寄存器的NE标志位为1时允许产生该异常（NE标志为0的情况见下文）。

x87 FPU可以检测并报告以下六种浮点错误情况：
- **无效运算（#I）**：包括栈溢出和下溢（#IS）；以及无效的算术运算（#IA）。
- **除零（#Z）**。
- **非规格化（denormalized）的操作数（#D）**。
- **数值溢出（#O）**。
- **数值下溢（#U）**。
- **结果不精确（#P）**，P代表精度（Precision）。

每种错误情况对应于x87 FPU的一种异常类型。对每一种异常类型，x87 FPU的状态寄存器和控制寄存器分别提供了一个标志和一个屏蔽位。如果x87 FPU检测到一个浮点错误，且控制寄存器中该异常类型的屏蔽位为1，那么x87 FPU会自动处理该异常：产生一个预先定义（缺省的）的响应然后继续执行。对于大多数浮点应用，缺省响应可以提供合理的结果。

如果异常类型对应的屏蔽位为0，且CR0寄存器的NE（Numeric Error）标志位为1，那么x87 FPU会采取以下动作：
1. 在FPU状态寄存器中设置必要的标志。
2. 如果遇到等待型x87 FPU指令或WAIT/FWAIT指令，便在执行该指令前产生一个内部信号使CPU产生一个浮点错误异常。这里要说明的是，如果程序中一直没有这样的指令，那么该异常便不会被报告。

CR0的NE标志为0可以使x87 FPU使用PC兼容方式（PC-Style，又叫MS-DOS兼容方式）来报告浮点错误：当IGNNE#管脚的信号有效（asserted）时，忽略所有x87浮点错误；当IGNNE#管脚信号无效（deasserted）时，如果有未屏蔽的（unmasked）x87 FPU错误发生，那么处理器会在遇到下一个等待浮点指令（WAIT或FWAIT）时置起（assert）FERR#管脚信号并进入冻结状态（停止指令执行）等待中断发生。在PC兼容系统中，FERR#管脚信号会被送到级联的可编程中断控制器（PIC）芯片的IRQ13输入端。在FERR#信号的作用下，PIC会产生中断使CPU进入处理浮点错误的中断处理例程。

在执行等待型x87 FPU指令或WAIT/FWAIT指令之前，x87 FPU会检查是否有等待报告（pending）的浮点错误异常。对于非等待型（non-waiting）x87 FPU指令（包括FNINIT、FNCLEX、FNSTSW、FNSTSW AX、FNSTCW、FNSTENV和FNSAVE），x87 FPU不会检查是否有等待报告的异常。在执行浮点状态管理指令（FXSAVE和FXRSTOR）时，x87 FPU也会忽略等待报告的异常。

**错误代码**：无，x87 FPU的状态寄存器提供了错误信息。

**保存的程序指针**：栈中保存的CS和EIP值指向的是产生x87 FPU浮点错误异常时将要执行的WAIT/FWAIT或浮点指令。不是x87 FPU检测到导致浮点错误的那条指令。导致浮点错误的指令的地址被存储在x87 FPU的指令指针寄存器中。

**程序状态变化**：程序状态通常会变化，因为浮点错误异常发生后会被延迟到遇到下一个等待型浮点指令或WAIT/FWAIT指令时汇报和处理。不过，因为x87 FPU保存了足够多的信息，所以大多时候还是可以从错误中恢复，如果需要可以重新执行导致错误的指令。

如果程序中有非x87 FPU指令依赖x87 FPU指令的结果，那么可以在该指令前插入一条WAIT/FWAIT指令以强迫检查是否有等待报告的浮点异常。

### 对齐检查异常（#AC）

**向量号**：17  
**异常类型**：错误（Fault）  
**引入该异常的处理器**：486处理器最早引入该异常，其后所有IA-32处理器都实现了该异常。

**描述**：32位处理器通常具有32根数据线（例如386和486），因此一次可以传递4个字节（32位）。从奔腾处理器开始，IA-32处理器的数据线从32根增加到64根，一次可以传递8个字节（64位）。为了提高访问效率和简化电路设计，32位数据总线的CPU总是从能够被4整除的地址访问内存（每次4个字节）。64位数据总线的CPU总是从可以被8整除的地址访问内存（每次8个字节）。也就是说，CPU的地址线总是选通（呈现）是4或8整数倍的地址。例如，奔腾4 CPU的地址线是A[35:3]，共33根，代表高33位地址（低3位省略），可以最多寻址64G物理内存。也就是说，这样的地址线已经不能表示出不是8的整数倍的地址。当要访问非8整数倍的地址时，那么就选通与其最接近的8整数倍地址。举例来说，如果要读取地址4开始的4个字节，那么CPU便通过地址线输出地址0，并通过字节选中信号BE#（Byte Enable）指定需要的是高4字节。如果要读取地址7开始的4个字节，那么就要向输出地址0，取最高字节，然后再输出地址8，取低3字节，最后再通过移位操作将两次得到的数据合在一起。从这两个例子看到，同样是读取4个字节，前一种情况只要读取一次，后一种情况则要读取两次。分析原因，前一种情况要读取的4字节数据的起始地址是可以被4整除的，这样的地址被称为是按4字节边界对齐的。而后一种情况要读取的数据的起始地址是不可以被要读取的字节数整除，这样的地址被称为是没有对齐的。

从上面的分析我们看到，CPU访问满足内存对齐要求的数据可以大大提高性能。另外，对于某些数据区，CPU要求其起始地址一定要是内存对齐的。内存对齐异常正是为了强制这些要求而设计的。下表列出了各种数据类型或数据的内存对齐要求。

| 数据/数据类型 | 地址必须可以被整除 |
|---------------|-------------------|
| Word（字）    | 2                 |
| Doubleword（双字） | 4                |
| 单精度浮点数（32位） | 4               |
| 双精度浮点数（64位） | 8               |
| 扩展双精度浮点数（double extended-precision floating-point）（80位） | 8              |
| Quadword（4字） | 8                 |
| Double quadword | 16                |
| 段选择子 | 2                 |
| 32位长指针 | 4                 |
| 48位长指针 | 4或2*             |
| 32位指针 | 4或2*             |
| GDTR、IDTR、LDTR或任务寄存器（TR）的内容 | 4或2*           |
| FSTENV/FLDENV保存区域 | 4或2*           |
| FSAVE/FRSTOR保存区域 | 4或2*           |
| Bit String | 4或2*             |

*依赖于操作数长度（size）。

值得注意的是，仅当满足以下条件时，CPU才会启用内存对齐检查：
- CR0寄存器的AM（Alignment Mask）标志为1。
- EFLAGS寄存器的AC（Alignment Check）标志为1。
- CPU处于保护模式或虚拟8086模式，并且CPL（当前权限级别）为3。

也就是说，只有当CPU在用户模式下操作时才会进行内存对齐检查。缺省指向0特权级的内存引用（例如加载段描述符）不会导致对齐检查，即使该操作是由于用户模式下的内存引用所导致的。

如果满足了内存对齐检查的条件，而且CPU检测到违反表2-8规定的情况，那么CPU便会产生内存对齐检查异常（#AC），但有一个例外，对于128位的数据类型没有按16字节边界对齐的情况，CPU会以一般性保护异常（#GP）的形式报告。

**错误代码**：无

**保存的程序指针**：栈中保存的CS和EIP值指向的是产生异常的那条指令。

**程序状态变化**：程序状态并没有变化，CPU报告异常前会恢复到导致异常的指令被执行前的状态，所以当异常处理程序纠正了错误情况后可以安全地恢复执行原来的程序。

### 机器检查异常（#MC）

**向量号**：18  
**异常类型**：中止（Abort）  
**引入该异常的处理器**：奔腾处理器最早引入该异常，其后所有IA-32处理器都实现了该异常。

**描述**：该异常表示CPU检测到一个内部错误或总线错误，或者系统的外部主体（如内存控制器MCH）检测到总线错误。外部主体检测到的错误是通过专门的CPU管脚通知CPU的。奔腾CPU使用的是BUSCHK#管脚，奔腾4、至强和P6系列处理器使用的是BINIT#和MCERR#管脚。

机器检查异常的具体工作方式与处理器型号有关。特别是奔腾处理器和其后的P6及奔腾4处理器在这方面有较大差异，详见2.9节。

CR4寄存器的MCE标志用来启用机器检查机制。

**错误代码**：无，但是专门为机器检查机制设计的MSR寄存器提供了错误信息。

**保存的程序指针**：
- 对于奔腾4和至强处理器，扩展的机器检查状态寄存器中保存了当CPU检测到机器检查异常时的状态信息，包括通用寄存器、标志寄存器EFLAGS、EIP等，而且这些信息是与发生的机器检查异常直接相关的。
- 对于P6系列处理器，如果MCG_STATUS_MSR寄存器的EIPV标志为1，那么保存的CS和EIP值是与导致机器检查异常的错误直接有关的，如果该标志为0，那么保存的指令指针可能与发生的错误不相关。
- 对于奔腾处理器，CS和EIP寄存器的值可能与发生的错误相关，也可能不相关。

**程序状态变化**：对于奔腾4、至强、P6系列和奔腾处理器，机器检查异常总会伴有程序状态变化，而且机器检查异常是以中止类异常报告的。当中止类异常发生后，异常处理程序可以收集各种信息供调试使用，但通常不能恢复程序继续运行。

如果没有启用机器检查机制，那么机器检查错误会导致CPU进入关机状态。

### SIMD浮点异常（#XF）

**向量号**：19  
**异常类型**：错误（Fault）  
**引入该异常的处理器**：奔腾III处理器最早引入该异常，其后所有IA-32处理器都实现了该异常。

**描述**：该异常表示CPU在执行SSE/SSE2/SSE3 SIMD运算时检测到错误。SIMD是Single Instruction Multiple Data的缩写，即单指令多数据。SIMD是MMX（MultiMedia Extensions，即多媒体扩展）技术的主要内容，其核心思想是使用64位的MMX寄存器，一次对多个整数进行算术运算。SSE是Streaming SIMD Extension的缩写，即将SIMD技术推广到可以对单精度浮点数进行单指令多数据计算。

与x87 FPU浮点异常类似，SIMD浮点异常也被划分为六个子类：
- **无效运算（#I）**
- **除零（#Z）**
- **非规格化（denormal）的操作数（#D）**
- **数值溢出（#O）**
- **数值下溢（#U）**
- **结果不精确（#P）**，P代表精度（Precision）

在以上六类异常情况中，无效操作、除零和非规格化的操作数属于计算前异常。