     /*+0x42*/  wchar Name[1];         // 以Unicode方式标识的文件名  
    } FILENAME_ATTRIBUTE, *PFILENAME_ATTRIBUTE;
    // 数据流属性 ATTRIBUTE.AttributeType == 0x80   
    typedef struct _NONRESIDENT_ATTRIBUTE  
    {  
        /*+0x00*/   ATTRIBUTE Attribute;    
        /*+0x10*/   uint64 StartVcn;     // LowVcn 起始VCN  起始簇号  
        /*+0x18*/   uint64 LastVcn;      // HighVcn  结束VCN  结束簇号  
        /*+0x20*/   uint16 RunArrayOffset;    // 数据运行的偏移，非常重要 
        /*+0x22*/   uint16 CompressionUnit;   // 压缩引擎  
        /*+0x24*/   uint32  Padding0;       // 填充  
        /*+0x28*/   uint32  IndexedFlag;    // 为属性值分配大小(按分配的簇的字节数计算)  
        /*+0x30*/   uint64 AllocatedSize;   // 属性值实际大小  
        /*+0x38*/   uint64 DataSize;     // 属性值压缩大小  
        /*+0x40*/   uint64 InitializedSize;   // 实际数据大小  
        /*+0x48*/   uint64 CompressedSize;    // 压缩后大小  
    } NONRESIDENT_ATTRIBUTE, *PNONRESIDENT_ATTRIBUTE;
**对于0x30属性：**
对于MFT中的0x30属性的直观认识，如下：
黄色部分对应着上表中的ATTRIBUTE结构，红色部分对应着上表中的NONRESIDENT_ATTRIBUTE结构。选中部分对应着FILENAME_ATTRIBUTE结构内容，这里面包含了文件的各种时间属性和文件名等内容。
Petya病毒在遍历MFT时，会通过判断当前MFT的AttributeFileName属性判断是否加密该MFT。
**对于0x80属性：**
对于MFT中的0x80属性的直观认识，如下：
黄色部分对应着上表中的ATTRIBUTE结构，红色部分对应着上表中的NONRESIDENT_ATTRIBUTE结构。绿色部分对应着RUN-LIST结构内容。
80H属性是文件数据属性，该属性容纳着文件的内容，文件的大小一般指的就是未命名数据流的大小。该属性没有最大最小限制，最小情况是该属性为常驻属性。常驻属性就不做多的解释了，如下是一个非常驻的80H属性。
该属性的“Run List”值为“32 0C 1B 00 00 0C”，其具体含义如下：
Petya病毒在加密文件内容时，会通过Run List定位到文件内容所在的真正扇区加密文件，如果文件内容大于2个扇区，则只加密前两个扇区。
**恶意代码加载过程**
**1 加载代码到0x8000执行**
从第一个扇区开始，读取0x20个扇区到0x8000地址处，随后跳到0x8000处执行
循环读取0x20个扇区代码片段：
在循环里使用int 13读取磁盘内容
**2 调用函数读取硬盘参数**
读取硬盘参数
比较“FA 31 C0 8E”硬编码，判断当前的第一个扇区的内容是不是病毒写入的内容。
**3 判断加密标志**
读取0x20扇区的内容（该扇区保存了病毒的配置信息），判断该扇区的第一个字节是不是1，如果是1，表示mbr已经被加过密，就来到显示勒索界面的流程;如果不为1，表示还未对MBR和MFT进行加密，进入加密流程。
**加密过程**
**1 打印修复磁盘信息，设置加密标志**
打印出虚假的“Repairing file system on
C:”信息，读取0x20扇区中的配置信息到内存，并将读取到的配置信息的加密标志设置为1。随后，将修改过加密标志的内容写入到扇区中，为了保证写入成功，这里循环写了0x20次。
打印的磁盘修复信息如下：
****
**2 加密验证扇区**
加密验证扇区的方法为：读取0x21扇区的内容（这个扇区保存的全是0x07数据），使用从配置信息扇区读取的key与n做为加密参数，调用salsa加密该读到的0x07内容，并将加密后的内容写入到0x21扇区中
显示虚假的“CHKDSK is repairing sector”界面，实际在后台正在加密MFT数据。
**3 加密操作**
**文件遍历的原理**
Petya病毒通过解析MBR，DBR得到MFT地址。解析MFT索引为0的元文件，得到属性为DATA的属性内容，取出属性中的RUN-LIST结构中的簇数量与起始扇区，根据这两个字段遍历所有的MFT就得到了当前文件系统中所有的文件信息。
解析MBR
解析原始MBR数据的代码片段：
判断MBR中的分区类型：
判断从mbr中读取到的StartLBA字段不为空
从mbr中解析到StartLBA字段，并读取该字段对应的扇区，此扇区的内容就为DBR相关的内容：
读取到DBR后，解析出MftStartLcn字段，该字段就表示 MFT地址：
得到MFT地址后，该地址就是索引为0的MFT元文件地址,从该元文件结构中取出属性为0x80（DATA）的内容。
首先读取到$MFT的扇区内容：
解析属性，判断是不是0x80(DATA)属性类型
对$MFT属性0x80中的解析，得到下面信息：
run_data_cluster*sector/cluster + 0x20(0x20为元文件占用的扇区大小)+mbr. arg_StartLBA，作为普通
MFT扇区的起始扇区，这样是保证加密的过程中不会加密元文件扇区与mbr相关的扇区。
（run_data_num_clusters * sector/cluster）- 0x20(0x20为元文件占用的扇区大小)，做为普通MFT的扇区大小。
随后，就来到遍历用户MFT的函数：
**遍历普通MFT结构**
遍历普通MFT结构的函数在00008FA6处，该函数为病毒代码中最为主要的函数。
下面对这个函数进行详细分析:
在调试的过程中，parse_User_MFT函数的参数内容为：80 C6 5F 00 60 00 20 C6 00 00 3F 00 00 00 3F 00
60 00 08 C6 2C 67 4A 67 8B 77 52 9C 01,结合调试时传递的参数内容，对函数作出说明。
该函数主要功能为：对扇区中的MFT遍历，对不符合MFT头部标志(FILE)的扇区，会直接调用SALSA20算法进行加密该扇区，对符合MFT头部标志的扇区，判断0x30属性中的文件名判断是不是元文件，如果不是元文件名格式，则直接加密该扇区。其他情况下，判断MFT结构0x80属性中的常驻内存属性，如果是非常驻内存属性，就解析文件内容的前二个扇区，取出该扇区的内容后，使用salsa20算法进行加密。
1.先打印出“CHKDSK is repairing sector”，显示虚假的磁盘修复界面
2.对当前MFT头是不是“FILE”,如果不是”FILE”的话，则直接加密这个扇区
3.如果是FILE，接着遍历mft的各个属性：
如果属性为AttributeFileName（0x30），判断文件名字长度是不是1，如果长度为1，直接加密，如果长度不为1，则看文件名字是不是以$开头(以$开头的是NTFS文件系统的元文件)，如果是元文件，则加密当前MFT.
如果属性为AttributeData文件数据属性（0x80），则首先根据属性头判断是不是非常驻内存，如果是常驻内存属性就跳过，不进行加密。如果是非常驻内存属性，则通过RUNLIST结构遍历到存储数据的真正的扇区位置。
解析RUNLIST
根据RUNLIST中的起始簇乘以MBR中保存的每簇对应的扇区数，得到数据真正所在的扇区。
随后，判断上面计算出的文件内容对应扇区数量是不是大于2，如果大于2，只加密前2个扇区。
读取该MFT文件对应的文件内容的前两个分区，通过直接使用int 13中断从扇区读取到文件内容，使用salsa20加密后，将密文直接写入的扇区中文件中。
在动态调试时，可以看到加密了文件内容，加密文件内容前的数据
被加密后的文件内容：
**加密函数**
对文件的加密使用了SALSA20算法，该算法属于流加密，在知道key和iv的情况下，加密函数和解密函数可以为相同的函数代码。
加密函数
在密钥扩展的函数中，Petya将原始的常数“expand 16-byte k”更改成了“1nvald s3ct”
扩展密钥函数代码：
Salsa20加密时使用的key和iv来自于配置信息扇区（0x20扇区）
将明文与生成的keystream异或，实现加密
**解密过程**
在开机启动过程中，MBR引导后，加载扇区中的恶意代码后，恶意代码会判断配置信息第1个BYTE是不是1，1表示已经加密过，则进入相应的解密过程中
**1 打印勒索信息**
打印出勒索信息
也就是显示如下的内容
**2 读取用户输入的key**
清空内存，读取用户输入的key
**3 验证用户的key**
在验证KEY的过程中，首先比较输入的key的长度，必须大于0x20长度
将输入的key通过自定义算法的转换0x21次
使用转换过的key，使用salsa20算法解密0x21扇区的内容（这个扇区的内容为加密过的0x7内容），比较解密出来的内容是不是0x7，如果是则表明解密密码正确。
密码验证通过后，会使用这个key做为参数调用DecryptProc 函数(并非勒索软件作者定义的函数名)，
在DecryptProc函数中调用与加密时相同的函数进行对MFT结构进行遍历后解密，
在解密完成后，打印“Please reboot your computer!”信息
**总结**
本文对Petya变种勒索蠕虫的扇区启动代码进行了详细分析，分析显示Petya变种勒索蠕虫并不仅会加密MBR和MFT结构，也会将MFT对应的文件内容的前两个扇区进行加密。换句话说，Petya变种勒索蠕虫在系统启动时MBR中的代码执行时也会进行全盘文件的加密操作。结合RING3级别的勒索代码功能，Petya会对文件执行两次加密操作，第一次为Petya勒索蠕虫执行时，使用RSA与AES算法遍历文件系统对指定扩展名的文件加密，第二次为系统启动时，启动扇区的代码会通过遍历MFT结构定位文件内容并对文件使用salsa20算法进行加密。对于RING3级别的文件加密过程，解密密钥可以通过勒索蠕虫作者的RSA私钥进行解密获得，而启动扇区级别的文件加密过程使用了随机密码进行，启动扇区级别的文件加密无法解密。
**参考**