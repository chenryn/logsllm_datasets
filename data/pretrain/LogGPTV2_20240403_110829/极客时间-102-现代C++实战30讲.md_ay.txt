# 24 \| Boost：你需要的"瑞士军刀"你好，我是吴咏炜。我们已经零零碎碎提到过几次 Boost 了。作为 C++世界里标准库之外最知名的开放源码程序库，我们值得专门用一讲来讨论一下Boost。 Boost 概览Boost 的网站把 Boost 描述成为经过同行评审的、可移植的 C++源码库（peer-reviewed portable C++ sourcelibraries）\[1\。换句话说，它跟很多个人开源库不一样的地方在于，它的代码是经过评审的。事实上，Boost项目的背后有很多 C++ 专家，比如发起人之一的 Dave Abarahams 是 C++标准委员会的成员，也是《C++ 模板元编程》一书\[2\ 的作者。这也就使得 Boost 有了很不一样的特殊地位：它既是C++ 标准库的灵感来源之一，也是 C++ 标准库的试验田。下面这些 C++标准库就源自 Boost：1.  智能指针        2.  thread        3.  regex        4.  random        5.  array        6.  bind    7.  tuple        8.  optional        9.  variant        10. any    11. string_view        12. filesystem        13. 等等    当然，将来还会有新的库从 Boost 进入 C++标准，如网络库的标准化就是基于 Boost.Asio进行的。因此，即使相关的功能没有被标准化，我们也可能可以从 Boost里看到某个功能可能会被标准化的样子------当然，最终标准化之后的样子还是经常有所变化的。我们也可以在我们的编译器落后于标准、不能提供标准库的某个功能时使用Boost 里的替代品。比如，我之前提到过老版本的 macOS 上苹果的编译器不支持optional 和 variant。除了我描述的不正规做法，改用 Boost也是方法之一。比如，对于variant，所需的改动只是：1.  把包含 \ 改成包含    \        2.  把代码中的         `std::variant` 改成           `boost::variant`这样，就基本大功告成了。作为一个准标准的库，很多环境里缺省会提供Boost。这种情况下，在程序里使用 Boost不会额外增加编译或运行时的依赖，减少了可能的麻烦。如果我需要某个功能，在标准库里没有，在Boost 里有，我会很乐意直接使用 Boost里的方案，而非另外去查找。如果我要使用非 Boost的第三方库的话，那一般要么是 Boost 里没有，要么就是那个库比 Boost里的要好用很多了。鉴于 Boost 是一个库集合，当前版本（1.72）有 160个独立库，即使写本书也不可能完整地讨论所有的库。这一讲里，我们也就管中窥豹式地浏览几个Boost库。具体你需要什么，还是得你自己回头去细细品味。Boost 的安装在主要的开发平台上，现在你都可以直接安装Boost，而不需要自己从源代码编译了：1.  在 Windows 下使用 MSVC，我们可以使用 NuGet    安装（按需逐个安装）        2.  在 Linux 下，我们可以使用系统的包管理器（如 apt 和    yum）安装（按需逐个安装，或一次性安装所有的开发需要的包）        3.  在 macOS 下，我们可以使用 Homebrew 安装（一次性安装完整的    Boost）    如果你在某个平台上使用非缺省的编译器，如在 Windows 上或 macOS 上使用GCC，一般就需要自己编译了，具体步骤请参见 Boost 的文档。不过，很多 Boost库是完全不需要编译的，只需要把头文件加到编译器能找到的路径里就可以------如我们上一讲讨论的Boost.Multiprecision 就是这样。我们讨论 Boost库的时候，也会提一下使用这个库是否需要链接某个 Boost库------需要的话，也就意味着需要编译和安装这个 Boost库。 Boost.TypeIndexTypeIndex是一个很轻量级的库，它不需要链接，解决的也是使用模板时的一个常见问题，如何精确地知道一个表达式或变量的类型。我们还是看一个例子：    #include     #include     #include     #include     #include     using namespace std;    using boost::typeindex::type_id;    using boost::typeindex::      type_id_with_cvr;    int main()    {      vector v;      auto it = v.cbegin();      cout () ()           ()           ()        ()           ()           ()             > `*** Using typeid`>>>  > `int`>>>  > `class std::vector >`>>>  > `class std::_Vector_const_iterator > >`>>>  > `*** Using type_id`>>>  > `int`>>>  > `class std::vector >`>>>  > `class std::_Vector_const_iterator > >`>>>  > `*** Using type_id_with_cvr`>>>  > `int const`>>>  > `class std::vector > &`>>>  > `class std::vector > &&`>>>  > `class std::_Vector_const_iterator > > &`>在 GCC 下的输出为：>  > `*** Using typeid`>>>  > `i`>>>  > `St6vectorIiSaIiEE`>>>  > `N9__gnu_cxx17__normal_iteratorIPKiSt6vectorIiSaIiEEEE`>>>  > `*** Using type_id`>>>  > `int`>>>  > `std::vector >`>>>  > `__gnu_cxx::__normal_iterator > >`>>>  > `*** Using type_id_with_cvr`>>>  > `int const`>>>  > `std::vector >&`>>>  > `std::vector >&&`>>>  > `__gnu_cxx::__normal_iterator > >&`>我们可以看到 MSVC 下 `typeid` 直接输出了比较友好的类型名称，但 GCC下没有。此外，我们可以注意到：1.  `typeid` 的输出忽略了 const    修饰，也不能输出变量的引用类型。        2.  `type_id`    保证可以输出友好的类型名称，输出时也不需要调用成员函数，但例子里它忽略了        `int` 的    const 修饰，也和         `typeid`    一样不能输出表达式的引用类型。        3.  `type_id_with_cvr` 可以输出 const/volatile    状态和引用类型，注意这种情况下模板参数必须包含引用类型，所以我用了           `decltype((v))` 这种写法，而不是           `decltype(v)`。如果你忘了这两者的区别，请复习一下        [\[第 8    讲\]             的        `decltype`。        显然，除非你正在使用 MSVC，否则调试期 `typeid`的用法完全应该用 Boost 的 `type_id` 来替代。另外，如果你的开发环境要求禁用RTTI（运行时类型识别），那 `typeid` 在 Clang 和 GCC 下根本不能使用，而使用Boost.TypeIndex库仍然没有问题。当然，上面说的前提都是你在调试中试图获得变量的类型，而不是要获得一个多态对象的运行时类型。后者还是离不开RTTI 的------虽然你也可以用一些其他方式来模拟RTTI，但我个人觉得一般的项目不太有必要这样做。下面的代码展示了 `typeid` 和 `type_id`在获取对象类型上的差异：    #include     #include     #include     using namespace std;    using boost::typeindex::type_id;    class shape {    public:      virtual ~shape() {}    };    class circle : public shape {};    #define CHECK_TYPEID(object, type) \      cout () ==     \                   type_id()     \                 ? " is "              \                 : " is NOT ")         \             > `typeid(*ptr) is NOT shape`>>>  > `typeid(*ptr) is circle`>>>  > `type_id(*ptr) is shape`>>>  > `type_id(*ptr) is NOT circle`>Boost.CoreCore 里面提供了一些通用的工具，这些工具常常被 Boost的其他库用到，而我们也可以使用，不需要链接任何库。在这些工具里，有些已经（可能经过一些变化后）进入了C++ 标准，如：1.  `addressof`，在即使用户定义了        `operator&`    时也能获得对象的地址        2.  `enable_if`，这个我们已经深入讨论过了（        [\[第 14 讲\            slate-object="inline"    ）        3.  `is_same`，判断两个类型是否相同，C++11 开始在 \    中定义    4.  `ref`，和标准库的相同，我们在        [\[第 19    讲\]             讨论线程时用过        我们在剩下的里面来挑几个讲讲。boost::core::demangle`boost::core::demangle` 能够用来把 `typeid`返回的内部名称"反粉碎"（demangle）成可读的形式，看代码和输出应该就非常清楚了：    #include     #include     #include     #include     #include     using namespace std;    using boost::core::demangle;    int main()    {      vector v;      auto it = v.cbegin();      cout   > `*** Using typeid`>>>  > `i`>>>  > `St6vectorIiSaIiEE`>>>  > `N9__gnu_cxx17__normal_iteratorIPKiSt6vectorIiSaIiEEEE`>>>  > `*** Demangled`>>>  > `int`>>>  > `std::vector >`>>>  > `__gnu_cxx::__normal_iterator > >`>如果你不使用 RTTI 的话，那直接使用 TypeIndex应该就可以。如果你需要使用 RTTI、又不是（只）使用 MSVC的话， `demangle`就会给你不少帮助。boost::noncopyable`boost::noncopyable`提供了一种非常简单也很直白的把类声明成不可拷贝的方式。比如，我们 [\[第 1讲\]   里的`shape_wrapper`，用下面的写法就明确表示了它不允许被拷贝：    #include     class shape_wrapper      : private boost::noncopyable {      …    };你当然也可以自己把拷贝构造和拷贝赋值函数声明成`= delete`，不过，上面的写法是不是可读性更佳？boost::swap你有没有印象在通用的代码如何对一个不知道类型的对象执行交换操作？不记得的话，标准做法是这样的：    {      using std::swap;      swap(lhs, rhs);    }即，我们需要（在某个小作用域里）引入`std::swap`，然后让编译器在"看得到" `std::swap`的情况下去编译 `swap` 指令。根据ADL，如果在被交换的对象所属类型的名空间下有 `swap`函数，那个函数会被优先使用，否则，编译器会选择通用的`std::swap`。似乎有点小啰嗦。使用 Boost的话，你可以一行搞定：    boost::swap(lhs, rhs);当然，你需要包含头文件\。Boost.ConversionConversion 同样是一个不需要链接的轻量级的库。它解决了标准 C++里的另一个问题，标准类型之间的转换不够方便。在 C++11之前，这个问题尤为严重。在 C++11里，标准引入了一系列的函数，已经可以满足常用类型之间的转换。但使用Boost.Conversion 里的 `lexical_cast`更不需要去查阅方法名称或动脑子去努力记忆。下面是一个例子：    #include     #include     #include     #include     using namespace std;    using boost::bad_lexical_cast;    using boost::lexical_cast;    int main()    {      //  整数到字符串的转换      int d = 42;      auto d_str =        lexical_cast(d);      cout (d_str) /        4.0;      cout ("x");        cout   > `42`>>>  > `10.5`>>>  > `bad lexical cast: source type value could not be interpreted as target`>>>  > `stoi`>我觉得 GCC 里 `stoi` 的异常输出有点太言简意赅了......而 `lexical_cast`的异常输出在不同的平台上有很好的一致性。Boost.ScopeExit我们说过 RAII 是推荐的 C++ 里管理资源的方式。不过，作为 C++程序员，跟 C 函数打交道也很正常。每次都写个新的 RAII封装也有点浪费。Boost里提供了一个简单的封装，你可以从下面的示例代码里看到它是如何使用的：    #include     #include     void test()    {      FILE* fp = fopen("test.cpp", "r");      if (fp == NULL) {        perror("Cannot open file");      }      BOOST_SCOPE_EXIT(&fp) {        if (fp) {          fclose(fp);          puts("File is closed");        }      } BOOST_SCOPE_EXIT_END      puts("Faking an exception");      throw 42;    }    int main()    {      try {        test();      }      catch (int) {        puts("Exception received");      }    }唯一需要说明的可能就是 `BOOST_SCOPE_EXIT` 里的那个 `&`符号了------把它理解成 lambda 表达式的按引用捕获就对了（虽然`BOOST_SCOPE_EXIT` 可以支持 C++98的代码）。如果不需要捕获任何变量，`BOOST_SCOPE_EXIT` 的参数必须填为`void`。输出为（假设 test.cpp存在）： >  > `Faking an exception`>>>  > `File is closed`>>>  > `Exception received`>使用这个库也只需要头文件。注意实现类似的功能在 C++11里相当容易，但由于 ScopeExit 可以支持 C++98的代码，因而它的实现还是相当复杂的。Boost.Program_options传统上 C 代码里处理命令行参数会使用`getopt`。我也用过，比如在下面的代码中：https://github.com/adah1972/breaktext/blob/master/breaktext.c这种方式有不少缺陷：1.  一个选项通常要在三个地方重复：说明文本里，        `getopt` 的参数里，以及对        `getopt`    的返回结果进行处理时。不知道你觉得怎样，我反正发生过改了一处、漏改其他的错误。        2.  对选项的附加参数需要手工写代码处理，因而常常不够严格（C    的类型转换不够方便，尤其是检查错误）。        Program_options正是解决这个问题的。这个代码有点老了，不过还挺实用；懒得去找特别的处理库时，至少这个伸手可用。使用这个库需要链接boost_program_options 库。下面的代码展示了代替上面的 `getopt`用法的代码：    #include     #include     #include     #include     namespace po = boost::program_options;    using std::cout;    using std::endl;    using std::string;    string locale;    string lang;    int width = 72;    bool keep_indent = false;    bool verbose = false;    int main(int argc, char* argv[])    {      po::options_description desc(        "Usage: breaktext [OPTION]... "        " [Output File]\n"        "\n"        "Available options");      desc.add_options()        ("locale,L",         po::value(&locale),         "Locale of the console (system locale by default)")        ("lang,l",         po::value(&lang),         "Language of input (asssume no language by default)")        ("width,w",         po::value(&width),         "Width of output text (72 by default)")        ("help,h", "Show this help message and exit")        (",i",         po::bool_switch(&keep_indent),         "Keep space indentation")        (",v",         po::bool_switch(&verbose),         "Be verbose");      po::variables_map vm;      try {        po::store(          po::parse_command_line(            argc, argv, desc),          vm);      }      catch (po::error& e) {        cout     namespace hana = boost::hana;    class shape {};    class circle {};    class triangle {};    int main()    {      using namespace hana::literals;      constexpr auto tup =        hana::make_tuple(          hana::type_c,          hana::type_c,          hana::type_c);      constexpr auto no_pointers =        hana::remove_if(          tup, [](auto a) {            return hana::traits::              is_pointer(a);          });      static_assert(        no_pointers ==        hana::make_tuple(          hana::type_c,          hana::type_c));      static_assert(        hana::reverse(no_pointers) ==        hana::make_tuple(          hana::type_c,          hana::type_c));      static_assert(        tup[1_c] == hana::type_c);    }这个程序可以编译，但没有任何运行输出。在这个程序里，我们做了下面这几件事：1.  使用         `type_c` 把类型转化成        `type`    对象，并构造了类型对象的         `tuple`2.  使用         `remove_if` 算法移除了        `tup`    中的指针类型        3.  使用静态断言确认了结果是我们想要的        4.  使用静态断言确认了可以用        `reverse` 把        `tup`    反转一下        5.  使用静态断言确认了可以用方括号运算符来获取        `tup`    中的某一项        可以看到，Hana本质上以类似普通的运行期编程的写法，来做编译期的计算。上面展示的只是一些最基本的用法，而Hana的文档里展示了很多有趣的用法。尤其值得一看的是，文档中展示了如何利用Hana 提供的机制，来自己定义 `switch_`、`case_`、`default_`，使得下面的代码可以通过编译：    boost::any a = 'x';    std::string r =      switch_(a)(        case_([](auto i) {          return "int: "s +                 std::to_string(i);        }),        case_([](auto c) {          return "char: "s +                 std::string{c};        }),        default_(          [] { return "unknown"s; }));    assert(r == "char: x"s);我个人认为很有意思。内容小结本讲我们对 Boost 的意义做了概要介绍，并蜻蜓点水地简单描述了若干 Boost库的功能。如果你想进一步了解 Boost的细节的话，就得自行查看文档了。课后思考请你考虑一下，我今天描述的 Boost库里的功能是如何实现的。然后自己去看一下源代码（开源真是件大好事！），检查一下跟自己想象的是不是有出入。参考资料\[1\] Boost C++ Libraries. slate-object="mark"}https://www.boost.org/slate-object="mark"} \[2\] David Abarahams and Aleksey Gurtovoy, [[C++ TemplateMetaprogrammingslate-object="mark"} [.Addison-Wesley, 2004. 有中文版（荣耀译，机械工业出版社，2010 年） 