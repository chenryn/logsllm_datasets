It is obvious that running the developed fuzzer on a similar infrastructure for evaluation is not 
within the available resources of this research. A comprehensive comparison is therefore 
beyond the scope of this work. 
The specifications of the system used during development and for fuzzing is listed below: 
• 
Intel Xeon CPU @ 3,2 GHz (12 Cores) 
• 
32 GB RAM 
The fuzzer was started in a VirtualBox VM. Six cores and 20 GB RAM were assigned to the 
VM. The fuzzer was just started on one core on the test system. 
The v8 engine was fuzzed in version 8.1.307.28 which was released in April 2020. 
Test cases were limited to a maximum runtime of 400 milliseconds per execution. The 
average execution time was 62 milliseconds. The test period was settled to one week 
because of limited resources. In total 8,467,311 executions were performed during this test 
period. In this period 1,677 crashes were observed. Most of these crashes can be traced 
back to bugs related to native function calls in the v8 engine. These native functions are 
used during development or debugging and therefore do not pose a security risk to end-
users. Chapter 5.4.1 describes more details according an identified high-severity bug which 
is not related to native function calls. 
During the analysis of previously exploited vulnerabilities a vulnerability in Foxit Reader was 
identified. Foxit Reader internally uses the JavaScript engine of Chromium and 
vulnerabilities in v8 therefore also affect Foxit Reader. The author of this thesis developed 
together with the second supervisor a reliable exploit for the vulnerability. To trigger the 
 126 
vulnerability only a PDF file must be opened in Foxit Reader. The exploit achieves full code 
execution without crashing Foxit Reader, bypasses all in-place memory protections and is 
invisible for victims. The vulnerability was reported together with the exploit to TrendMicro’s 
Zero Day Initiative. The vulnerability is tracked as ZDI-20-933 219. The vulnerability was fixed 
on 2020-07-31. CVE-2020-15638 was assigned to this vulnerability. 
During fuzzer development manual tests were performed to test edge cases in JavaScript. 
This led to the discovery of a bug with suspended generators which yield themselves. Since 
the bug is just a NULL pointer exception, it is considered to be not exploitable. The bug was 
reported to the Chromium developer team and was fixed within one day. The bug is tracked 
as Chromium issue 1075763 220. 
5.4.1 Example of an identified high-severity security vulnerability 
The following bug was found in v8 version 8.1.307.28 during fuzzing: 
// Required v8 flags: --allow-natives-syntax --interrupt-budget=1024 
01: function func_1_() { 
02:   var var_5_ = []; 
03:   for (let var_3_ = 0; var_3_ < 2; var_3_++) { 
04:     for (let var_4_ = 0; var_4_ != 89; var_4_++) {} 
05:        for (let var_1_ = -0.0; var_1_ < 1; 
06:               var_1_ = var_1_ || 11.1,%OptimizeFunctionOnNextCall(func_1_))  
07: 
{ 
08: 
var var_2_ = Math.max(-1,var_1_); 
09: 
var_5_.fill(); 
10: 
undefined % var_2_; 
11: 
} 
12: 
} 
13: } 
14: func_1_(); 
The bug is fixed in the current v8 version. The way the bug is triggered was fixed during a 
code update 221, however, this code update did not fix the underlying root cause of the bug. 
The test case crashes with a FATAL error during handling of a NumberMax node in the sea-
of-nodes. The bug demonstrates the fuzzer’s ability to find vulnerabilities with complex pre-
conditions: 
• 
The vulnerability just triggers if the target function uses three chained loops as shown 
in line 3, 4 and 5. 
• 
The first loop must perform at least two iterations. 
• 
The second loop must perform at least 89 iterations. 
• 
The third loop must initialize the loop variable with a negative floating-point number. 
• 
The syntax in line 6 must be exactly as shown and the function optimization must be 
triggered coma separated in the loop header. Variable 1 must be re-assigned and it 
is important that the floating-point value is 11.1 or above. 
219 https://www.zerodayinitiative.com/advisories/ZDI-20-933/ 
220 https://bugs.chromium.org/p/chromium/issues/detail?id=1075763 
221 https://github.com/v8/v8/commit/a447a44f31fc153590598698d33d6efd73334be4 
 127 
• 
The loop iteration variable var_1_ must be used in a call to Math.max together with 
a negative number as shown in line 8. 
• 
The output of this call must be used in a modulo operation as shown in line 10. 
• 
Before this modulo operation but after the Math.call function invocation a call to the 
built-in Array.fill() function must be performed. 
If one of these conditions is not met, the bug does not trigger. Guessing all these conditions 
correctly in just one generation step is improbable and a traditional fuzzer would therefore 
need a huge number of executions to find this bug. 
The bug was identified by the fuzzer by applying mutations on the regression test from 
Chromium issue 1063661 222. The regression test was in the fuzzer corpus because test 
cases from Chromium are used as sources, see chapter 5.2.1. During deterministic 
preprocessing the fuzzer added a call to optimize the function in the third loop header which 
triggered the bug. The bug was found after approximately one week of fuzzing. 
The way this PoC triggered the bug is fixed since 2020-03-20, but the underlying flaw could 
still be triggered afterwards. The researcher Javier Jimenez (@n30m1nd) from SensePost 
found the same bug in a newer v8 version by using a combination of fuzzilli and AFL++. In 
this newer version the bug could be triggered with a simplified PoC: 
// Required v8 flags: --allow-natives-syntax --interrupt-budget=1024 
01: function crash() {  
02:   for (a=0;a<2;a++) 
03:     for (let i = -0.0; i < 1000; i++) {  
04:       confused = Math.max(-1, i); 
05:     }  
06:     confused[0]; 
07: } 
08: crash(); 
09: %OptimizeFunctionOnNextCall(crash); 
10: crash(); 
This simplified PoC just works in the newer v8 version and does not trigger the bug in the 
fuzzed v8 version. The bug is tracked as Chromium issue 1072171 223 and was classified as 
a high-severity security issue and resulted in a $ 7,500 award for Javier Jimenez. Jimenez 
reported the bug on 2020-04-18. The author of this thesis found the bug on 2020-07-18 
because an older v8 version was fuzzed for the thesis because the corpus was optimized 
for that version. The Chromium issue was made public on 2020-07-30. 
The root cause of the vulnerability is an incorrect compiler annotation for the built-in 
Math.max function which misses the minus zero case for the return value. This bug is an 
example of the vulnerability category described in chapter 4.5.4. 
222 https://bugs.chromium.org/p/chromium/issues/detail?id=1063661 
223 https://bugs.chromium.org/p/chromium/issues/detail?id=1072171 
 128 
6 Discussion 
The results underline the efficiency of the developed fuzzer and that the proposed approach 
can be used to identify complex and previously unknown bugs. It was possible to confirm 
the thesis hypothesis because the search space could be reduced to identify an exploitable 
bug on a home computer. 
However, to identify additional exploitable bugs more computation power is required to run 
the fuzzer over a longer period on more CPU cores. Although it is assumed that the search 
space is narrowed down, still several hundred or thousand CPU cores are required to find 
long-lived exploitable bugs. 
During the experiment, 8,467,311 test cases were generated and tested. However, already 
in 2016, the Chrome security team fuzzed Chrome and tested in 30 days 
14,366,371,459,772 test cases using 700 virtual machines, as mentioned in chapter 3. They 
used at that time a fuzzer infrastructure of 5,000 CPU cores. Nowadays, the Chrome security 
team uses more than 25,000 CPU cores to constantly fuzz Chrome. The 8,467,311 tested 
JavaScript samples are just a fraction of the test cases tested internally by the Chrome team 
every day. 
The proposed fuzzer is currently just a prototype and several mutations are not supported 
yet. Moreover, the fuzzer is not yet optimized for speed. Several improvements can still be 
implemented to increase the throughput of the fuzzer. 
The current most promising JavaScript fuzzers are fuzzilli [39], DIE [10] and Code Alchemist 
[40], as discussed in chapter 3. The developed fuzzer combines the ideas of all three fuzzers, 
but each using a different approach.  
Fuzzilli introduced coverage feedback in JavaScript fuzzing and used an IL to perform 
mutations. In the developed fuzzer coverage feedback is used to generate a corpus of code 
snippets and mutations are directly applied on JavaScript code and not on an IL. Using an 
IL has the advantage that mutations can more easily be implemented which means less 
code is required. However, the IL adds an abstraction level and the fuzzer can therefore just 
create code that can also be encoded in the IL. In this thesis, mutations are directly applied 
to JavaScript code which is more complex and error-prone, but it ensures that every possible 
code combination can be created and that mutations are more fine-grained. Moreover, it is 
faster because the IL must not be parsed during fuzzing. This is coherent with the current 
development in the field of symbolic execution. Initially, an IL was used in most symbolic 
execution engines but QSYM [26] proved that engines without an IL perform better during 
fuzzing because of the missing overhead of the IL.  
DIE uses an initial corpus generated from public regression tests and applies specific 
mutations on the corpus. The public test cases are fixed by adding missing functions that 
are available in other JavaScript engines or testing frameworks. The advantage of this 
approach is that it is not error-prone because test cases must not be mutated, only new 
 129 
functions must be added at the start of the file. The disadvantage is that it makes test cases 
bigger which means fuzzing is slower and it is harder to extract small code bricks out of the 
test case because of the additional dependencies. In this thesis, the test cases are fixed by 
rewriting the test cases and replacing the function calls with corresponding JavaScript code. 
This requires more engineering effort because test cases must correctly be parsed and 
patched, and it is more error prone. For example, the parsing function can currently not 
handle special cases with regex strings and such test cases therefore may incorrectly be 
patched. These regression tests are currently not supported by the fuzzer. However, it 
results in smaller test cases which is important for fuzzing and especially for coverage guided 
fuzzing. DIE also does not implement test case minimization. 
DIE uses five different sources to create the initial corpus. Code Alchemist uses a similar 
approach and lists five sources for the corpus. However, one of the sources is the test262 
suite which is already available in the regression tests which means the effective number of 
sources is four. Fuzzilli does not support an initial corpus. In this thesis, 12 different sources 
are used to create the corpus. 
Another difference to DIE is the handling of exceptions. The DIE fuzzer uses test cases 
which result in an exception in the corpus. This means the fuzzer can find bugs related to 
exceptions, however, every time the fuzzer generates a test cases which triggers early an 
exception, all subsequent code lines in the test case are not executed. In this thesis, 
exceptions were intentionally removed from the corpus to increase the likelihood of 
generating test cases that do not trigger exceptions.  
The DIE and Code Alchemist fuzzers extract the Abstract Syntax Tree (AST) of the test 
cases using libraries and perform mutations and analysis based on the AST. DIE uses the 
Babel library for this whereas Code Alchemist uses Esprima. In the proposed fuzzer the 
mutations and analysis steps are directly performed on the JavaScript code using self-
developed Python code. 
Code Alchemist extracts small code bricks from test cases and merges them into new test 
cases during fuzzing. Code bricks are called building blocks in this thesis. While Code 
Alchemist uses the AST to extract the code bricks, dependencies in test cases are in the 
proposed fuzzer analyzed without third party libraries. For example, if a specific line in a test 
case is identified as a code brick, this code line alone may lead to an exception in another 
test case because of dependencies. The code line could potentially reference a specific 
function or variable which is just available in the first test case. Code Alchemist uses the AST 
to identify these dependencies and then also copies these functions or variables. In this 
thesis, it is attempted to extract this information using self-developed scripts, however, this 
is error prone. One method to improve the fuzzer is therefore the integration of a library 
which can extract the AST. 
 130 
Table 3 classifies and compares fuzzilli, DIE and Code Alchemist with the developed fuzzer. 
Fuzzilli 
DIE 
Code Alchemist 
Proposed fuzzer 
Coverage Feedback 
yes 
yes 
- 
yes 
Mutations performed on 
IL 
AST (Babel) 
AST (Esprima) 
JavaScript 
Initial Corpus 
no 
yes (5 sources) 
yes (4 sources) 
yes (12 sources) 
Type System 
yes 
yes 
yes 
yes 
Code Bricks 
- 
- 
yes 
yes 
JS Callback Corpus 
- 
- 
- 
yes 
Table 3: Classification of existing fuzzers  
7 Conclusion and future work 
This work introduced a fuzzer that combines ideas of three state-of-the-art fuzzers and 
integrates newly proposed ideas extracted from analyzed vulnerabilities. The fuzzer has over 
8,000 lines of code and 5,000 comment lines. 
Chapter 4 showed that useful information can be obtained from recently exploited 
vulnerabilities which can enhance fuzzing strategies. These improvements reduce the 
search space during fuzzing and variations of already known vulnerabilities can be found 
more efficiently. 
Most of the analyzed vulnerabilities shared similar code structures or used the same building 
blocks which can be re-used during fuzzing. The analysis of previously exploited 
vulnerabilities leads to a better understanding of vulnerability classes. It was possible to 
further categorize discovered vulnerabilities into more specific vulnerability classes. The 
knowledge obtained can not only be applied during fuzzer development. It can also be used 
to identify new vulnerabilities. This was demonstrated by the identification of a previously 
unknown vulnerability in Foxit Reader. A weaponized exploit was developed for this 
vulnerability which could be used to target 560 million end-users of Foxit Reader to achieve 
remote code execution on their systems. 
The v8 JavaScript engine of Google Chrome is used by several software projects. Since 
many of these projects do not regularly update the engine, attackers almost always have 
access to full working exploits because researchers regularly publish exploitation details for 
newly discovered v8 bugs.  
The author of this thesis believes that variation analysis is an important instrument to 
enhance current state-of-the-art JavaScript fuzzers. The proposed techniques help to narrow 
down the search space to find exploitable vulnerabilities more efficiently. 
The fuzzer identified in one week on a home computer a high-severity bug in v8. This bug 
was already identified by another researcher and was therefore a bug collision.  It is assumed 
that more computational resources would be required to start the fuzzer on a larger scale to 
further prove the claimed improvements and to find long-lived vulnerabilities. 
 131 
Future work should focus on the following research areas: 
• 
The fuzzer should be tested against other JavaScript engines than v8. Especially 
the scripts to create an initial JavaScript corpus can be executed with other engines 
to calculate edge cases for them. Since edge cases in one engine are likely edge 
cases in other engines, the overall corpus could be improved by combining the 
corpus files from all engines. 
• 
Exploitable vulnerabilities should be identified for which currently no public exploits 
exist. Key learnings from the analysis of them should be integrated into the fuzzer. 
• 
The fuzzer should be improved to parse the AST of the test cases to correctly extract 
dependencies of code lines. This is important to ensure that code bricks are 
complete and do not have missing dependencies. 
• 
More mutation strategies should be implemented to further increase the coverage. 