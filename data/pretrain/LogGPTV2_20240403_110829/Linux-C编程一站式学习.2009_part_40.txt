低8位、低16位或者完整的32位，
个字节存到地址0x804a01a处的一
0x804a019,%eax表示把地址0x804a019处的一个字节存到eax寄存器中，
movz指令把字长较短的值存到字长较长的存储单元中，
前
高
三条语句从串口接收三个字节，
图所示。
，把它们当成普通的内存单元了。如果是普通的内存单元，
图19.7.eax寄存器
80483c6:
80483c4:
80483ba:
804835
·
80483bf:
80483eb:
80483e2:
80483dd:
80483db:
 buf[o] = recv;
send :
buf[2] = 
buf[l] = recv;
......-
eax
send = ~buf[2];
ah
=
ax
~buf[
a2 1b a0 
a2
a2
a2
of
f7 do
 recv;
a2
,a2
反汇编的结果就不一样了：
 18 a0 04 08
1c a0 04 08
la
b6
05
一个字节中。
5'05 1c a0 04 08
a00408
 a0 0408
而编译生成的指令显然不符合我们的意图:
04
，编译生成的指令也不符合我们的意图：
了，前两条语句形同虚设，根本不生成指令。
08
0408
另一方面，
，可以用不同的名字单独访问x86寄存器的低8位、次
，然后从寄存器al保存到buf[0］，
以后每次用到这个值就直接从寄存器读取，
分别表示单字节、两字节和四字节。比如movzbl
，存储单元的高位用0填充。
mor
mor
mov
not
，如果对一个普通的内存单元连续做三次写
只要程序不去改写它，
%al,0x804a018
%eax
%al,0x804a01c
%al,0x804a01b
%al,0x804a01a
0x804a019,%eax
%al,0x804a018
geax
%al,0x804a018
%eax
，而eax寄存器是四字节的
日：只有第一条语句从内
只有最后一条语句
后两条语句就不再
，该指令可以
，它就不会变
，这样效
321
如
---
## Page 322
时，Cache对程序员是透明的，比如执行了movzbl 0x804a019,%eax这样一条指令，我们并不知
仅这样还不够，
有了volatile限定符，
踪源代码的执行过程。
从上面的例子还可以看到，
01、-02和-03这几个选项一个比一个优化得更多，
确实每次读recv都从内存地址0x804a019读取,
然后指定优化选项-o编译，查看反汇编的结果:
也加上volatile，
值，做取反运算然后写
注意的是，
把代码的开头几行改成：
然要老老实实从内存读取，
用优化选项编译生成的指令明显效率更高，
备寄存器的代码这样优化就错了，因为设备寄存器往往具有以下特性：
应
优化的也优化了，
操作,
目标文件的尺寸而优化。具体每种选项做了哪些优化请参考gcc(1)的Man Page。
·连续多次向设备寄存器中写数据并不是在做无用功，而是有特殊意义的。
·设备寄存器中的数据不需要改写就可以自己发生变化，每次读上来的值都可能不一样。
 甚至有些源代码可能不对应任何指令，
只有最后一次的值会保存到内存单元中，
165958108
80483d9:
80483d7:
80483d1:
80483cf:
80483ca:
80483c8:
80483c2:
80483bb:
80483a2:
..................
volatile
80483a9:
，还是无法防止Cache优化对设备寄存器的访问。在访问普通的内存单元
 再优化编译，
 send = ~buf[2];
send =
buf[2] =.
buf[l] = recv;
buf[0] = 
send =
 unsigned char send;
 程序员应该明确告诉编译器哪些内存单元的访问是不能优化的，
unsigned
写下去，
，是可以防止编译器优化对设备寄存器的访问，
....
~buf[
 ~buf[o];
，如果在编译时指定了优化选项，
88
88 0d
of
Of
a2
of
每次写这个变量也仍然要老老实实写回内存，不能省略任何步骤。我们
 recv;
 recv;
，这是因为buf并没有用volatile限定，读者可以试着在buf的定义前面
 就是告诉编译器，
6
b6
1a
 b6
char 
，再查看反汇编的结果。
-01、
3 a004
 18 a0 04 08
od
05
1c
a0
recv;
19
-02、
¥08
被彻底优化掉了。
但使用不当会出错，
48
0408
80
，即使在编译时指定了优化选项，
 每次写send也都写到内存地址0x804a018了。值得
，所以前两次写操作是多余的，可以优化掉。访问设
08
08
 编译时间也更长。-o和-01相同。-0s表示为缩小
mov
movzbl 0x804a019,%eax
源代码和生成指令的次序可能无法对
。这一点在用gdb做源码级调试时尤其
%edx
%dl,0x804a018
%c1,0x804a01c
%dl,0x804a01b
%al,0x804a01a
为了避免编译器自作聪明，
但是对于有Cache的平台，
 每次读这个变量仍
...............
在C语言中可以
把不该
322
---
## Page 323
通常要先查询这些标志位再做读写操作，在这个例子中我们抓主要矛盾，忽略这些细节。
[31] 实际的串口设备通常有一些标志位指示是否有数据到达以及是否可以发送下一个字节的数据，
除了设备寄存器需要用volatile限定之外，
5.C内联汇编
也要和Cache协同工作。
通常，有Cache的平台都有办法对某一段地址范围禁用Cache，
每次读串口接收寄存器时，Cache都会把缓存的第1个字节提供给CPU执行单元。
口接收寄存器读上来缓存，
类似，
时Cache把数据写回到串口发送寄存器，只能把第3个字节发送出去，
到Cache中去了
如果串口发送寄存器的地址被Cahce缓存，
存地址被Cache缓存了
的数据。然而，
到了Cache中而暂时没有写回内存，
知道寄存器的值是真的写回内存了
甚至不需要知道Cache的存在。
不是用指令控制Cache去做的，
这个地址的数据就从Cache读，
道eax的值是真的从内存地址0x804a019读到的，
些页面允许Cache缓存，
一页
如果串口接收寄存器的地址被Cache缓存,
图19.8.串口发送和接收寄存器被Cache缓存会有什么问题
串口发送寄存器
↑
Cache
执行单
CPU
，在读写设备寄存器时Cache的存在就不容忽视了，如果串口发送和接收寄存器的内
串口发送寄存器并没有及时得到数据，
写，发送
比如信号处理函数和多线程。
会不
有什么问题呢？如下图所示。
，哪些页面不允许Cache缓存，MMU不仅要做地址转换和访问权限检查，
，然而串口接收寄存器后面收到的2、3两个字节Cache并不知道，
程序员写的指令中只有寄存器、内存地址，而没有Cache，程序员
，如果Cache没有缓存就从内存读，这些步骤都是硬件自动做的，
同样道理,
下次读0x804a01a这个地址时仍然可以从Cache中读到上次写
还是只写到了Cache中,
串口接收寄存器
1个
Cache
执行单
CPU
当一个全局变量被同一进程中的多个控制流程访问时也
，CPU执行单元对串口发送寄存器做写操作都写
m
读，接收
起始页
上一级
·CPU执行单元在读第1个字节时，
还是从Cache中读到的，
最后Cache中只保存了第3个字节，
，也就不能及时发送，CPU执行单元先后
以后再由Cache写回内存，
一般是在页表中设置的，
前两个字节就丢失了。
如果Cache已经缓存了
第 20章 链接详解
，Cache会从串
，可以设定
即使只
我们并不
因
如果
323
与此
这
发
---
## Page 325
5.虚拟内存管理
4.共享库
3.静态库
6. volatile限定符
2.定义和声明
第 20 章 链接详解 请点评
1.多目标文件的链接
4.3.共享库的命名惯例
4.2.动态链接的过程
4.1.编译、链接、运行
2.3.定义和声明的详细规则
2.2.头文件
贝
全国嵌入式人才培训基地
全国嵌入式人才培训基地
部分ⅡI. C语言本质
第 20章链接详解
起始页
1.多目标文件的链接
---
## Page 326
编译：
a和b这两个变量没有用，只是为了顺便说明链接过程才加上的。编译的步骤和以前一样，可以一步
惯都很常见。
这段程序和原来有点不同，
栈：
现在我们把例12.1“用堆栈
1.多目标文件的链接 请点评
$ gcc main.c stack.c -o main
int main(void)
int a, b = 1;
#include 
int is_empty(void)
char pop(void)
void push(char c)
int top = -1; 
char
while( !is_empty())n
return top == -l;
 return
 stack[++top] = c;
return 0;
push(
 stack[top--］;
在例12.1“用堆栈实现倒序打印"中top总是指向栈顶元素的下一个元
见倒序打印"拆成两个程序文件，stack.c实现堆栈，而main.c使用堆
1.多目标文件的链接
全国嵌入式人才培训基地
第 20 章 链接详解
326
下一页
---
## Page 327
址，如何对齐，哪个段在前，哪个段在后，哪些段合并到同一个Segment，另外链接脚本还要插入
结果正如我们所预料的，
函数都在后面呢？我们可以试试把gcc命令中的两个目标文件反过来写：
为什么在可执行文件main的每个段中来自main.o的变量或函数都在前面，
示。
含了变量a和stack，main的.data段也合并了main.o和stack.o的.data段，
我们通过readelf -a main命令可以看到，
要在程序运行时做动态链接。
文件main时可以做符号解析，
如果按照第2节“main函数和启动例程"的做法，用nm命令查看目标文件的符号表，
也分可以多步编译：
图 20.1.多目标文件的链接
bss
data
text
S
S
SiS
 gcc stack.o main.o -o main 
gcc
gcc
gcc -c main.c
main
main.o
 main.o stack.o -o main
bss
dat
text
stack.c
.......
可执行文件main的每个段中来自main.o的变量或函数都排到后面了。实际
高地址
低地址
stack
top
is_empty
dod
push
main
main
 is_empty、 putchar,
而putchar是libc的库函数，在可执行文件main中仍然是未定义的，
.bss
data
text
高地址
stack
top
pop
push
stack.o
低地址
地址
：前三个符号在stack.o中实现了
 链接脚本决定了给每个段分配什么地
，而来自stack.o的变量或
，其中包含了变
会发现main.o中
链接生成可执行
，其中包
327
---
## Page 328
较长，只列出一些片断）：
项指定链接脚本,
一些符号到最终生成的文件中，
SIZEOF_HEADERS;
ENTRY(_start)
OUTPUT_ARCH(i386)
OUTPUT_FORMAT('
/* Script for,
using internal linker script:
o
.bss
·got 
.jcr
.dtors
.ctors
(CONSTANT
.eh_frame
.fini
.rodata
.init
.rel.plt
.note.gnu.build-id
PROVIDE
 ld --verbose
edata =
. dynamic
rel.dyn
.dynstr
. dynsym
·gnu.hash
.interp
1
 gnu.version_d
 gnu.version
bss