equally well to weaker adversaries. We designate the remaining
honest party as Ph with index h.
As our protocol is built atop F (cid:4),t,n
Com, and
F RDL,n
Com-ZK, we assume secure instantiations of those functionali-
ties are available, and analyze the remaining space of attacks,
which involve corrupted parties supplying inconsistent inputs
to these functionalities and thereby either producing a signature
for an unexpected message, or learning some information about
the honest parties’ secrets. Speciﬁcally, our task will be to argue
that if inconsistent inputs are supplied to the various instances
of these functionalities, then the consistency checks fail and the
remaining honest party aborts with overwhelming probability.
To this end, we can divide the class of attacks into two main
subclasses: inconsistent inputs to the instance key exchange,
and inconsistent inputs to the secret key multiplication.
2PMul, F n
, F (cid:4)
Mul
(cid:18)(cid:17)(cid:23)(cid:18)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:46:34 UTC from IEEE Xplore.  Restrictions apply. 
Mul
• Inconsistent inputs to Instance Key Multiplication. Recall
that in their interactions with F (cid:4),t,n
, the pool of corrupted
parties are represented by an ideal adversary S P∗
Mul, which
submits to the functionality a single uniﬁed input for
the entire pool. Suppose we deﬁne kP∗ to be the ﬁrst
value in the batch supplied by S P∗
in step 2
of πt,n
ECDSA-Sign, and φP∗ to likewise be the product of
the values submitted by the corrupt parties to F n
Com in
step 1. We can then deﬁne the error value ea such that
φP∗ /kP∗ +ea is the second input in the batch supplied by
S P∗
Mul to F (cid:4),t,n
in step 2. Let uP∗ and vP∗ be the uniﬁed
(that is, summed) outputs corresponding to the ﬁrst and
second inputs in this step, respectively. This yields
Mul to F (cid:4),t,n
Mul
Mul
uh + uP∗ = kh · kP∗
φh · φP∗
kh · kP∗ + φh · ea
vh + vP∗ =
In order for the ﬁrst consistency check to pass, it must
be the case that vh · R + Γ 1
P∗ = φ · G. If and only
if ea = 0, then the adversary can compute the check
P∗ ..= vP∗ · R such that this is true. Otherwise,
message Γ 1
P∗ ..= vP∗ · R − φh · ea · R,
the adversary must compute Γ 1
where φh is uniform, and therefore φh · ea is uniform
as well. φh is revealed to the adversary only after Γ 1
P∗
must be committed, and therefore the adversary can do no
better than to guess, and with overwhelming probability
the check message will not verify, causing Ph to abort.
• Inconsistent inputs to Secret Key Multiplication. Suppose
is
that all values are deﬁned as above, and that ski
deﬁned as the correct value given Pi’s Shamir share p(i)
(itself deﬁned to be the output of the setup protocol).
Suppose furthermore that without loss of generality some
individual corrupted party P∗
i supplies as a batched input
{ski+esk, vi+ev} when invoking F (cid:4)
2PMul with Ph in step 4
i }. For
of πt,n
simplicity, we assume only one corrupted party induces an
offset in this way, though the following argument applies
equally well when this is not the case. Regardless, we
now have
ECDSA-Sign, receiving as output {wh,1
, wh,2
i
wP∗ ..= skP∗ · vP∗ +
wh,1
i + wh,2
i
(cid:2)
i∈P∗
where wP∗ is a uniﬁed (i.e. summed over the corrupt
parties) version of the output speciﬁed in step 5 of
πt,n
ECDSA-Sign. This yields the relation
sk · φ
k + esk · φh
+ ev · skh
wh + wP∗ =
In the case that esk (cid:10)= 0, the adversary can only pass
the second consistency check by computing the corrupted
parties’ values such that their sum Γ 2
P∗ is
kh
Γ 2
P∗ = vP∗ · pk + wP∗ · G − esk · φh
kh
· G
where the adversary knows Rh = kh · G, but neither
kh itself, nor φh, and both kh and φh are uniform. As
before, φh is revealed to the adversary only after Γ 2
P∗
must be committed, and therefore Ph will abort with
overwhelming probability when esk (cid:10)= 0. In the case that
ev (cid:10)= 0, the adversary can only pass the third consistency
check by computing the corrupted parties’ values such
that their sum Γ 3
P∗ is
P∗ = wP∗ · R − ev · skh · R
Γ 3
where the adversary knows
skh · G = pk −
(cid:2)
i∈P∗
ski · G
but the adversary does not know skh itself. Computing
skh·R given only R and skh·G is a direct violation of the
Computational Difﬁe-Hellman Assumption, and therefore
under that assumption Ph will abort with overwhelming
probability when ev (cid:10)= 0.
This covers every opportunity available to an adversary for
supplying inconsistent inputs, and so we conclude that if the
adversary does such a thing, then it will fail to pass at least
one of the checks, assuming that the Computational Difﬁe-
Hellman Problem is hard in the elliptic curve group G. A
formal treatment of security can be found in the full version.
Round Count. For readability, we expressed the protocol
πt,n
ECDSA-Sign in individual steps, but many of these can be
collapsed together in practice to reduce the number of rounds.
In particular, the process of committing to φi for i ∈ P is
independent of and can be performed simultaneously with the
(which realizes F (cid:4),t,n
ﬁrst round of preprocessing for π(cid:4),t,n
Mul ),
Mul
and the preprocessing for all instances of π(cid:4)
2PMul (which realizes
F (cid:4)
2PMul) can be moved forward to occur at the same time. The
round-count optimization originally described in Section III
can be applied, reducing the remaining rounds required by
π(cid:4)
2PMul to log(t). Following this, a single round is required to
complete all instances of π(cid:4)
2PMul simultaneously. The process
of committing to Ri and an associated proof of knowledge
for i ∈ P is independent of the secret key multiplication, and
thus can it can also be performed immediately after π(cid:4)
2PMul
completes. Another round is required to decommit, and two
more to commit to and then release the check messages. Finally,
the last round is used to swap shares of the signature. Thus
the total round count for ECDSA signing comes to log(t) + 6.
VI. COST ANALYSIS
In Table I we provide an accounting of the communication
costs for our ECDSA setup and signing protocols, and in
Table II we account for the costs of our multiplication protocols.
Round counts for our protocols are discussed at length in the
relevant sections. Our equations assume that elements from Zq
are represented in κ bits, and that curve points are transmitted
with point compression and thus are represented in κ + 1
bits. We assume that commitments require transmission of a
single element from Zq, that decommitments consist simply
of the committed values, and that zero-knowledge proofs of
knowledge of discrete logarithm comprise two curve points
(cid:18)(cid:17)(cid:23)(cid:19)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:46:34 UTC from IEEE Xplore.  Restrictions apply. 
Phase
Setup
Signing
Communication (Bits)
· (5κ2 + 6κ + 2) + 4κ · n + 2n
n2−n
· (9κ2 + 18κ · s + κ · κOT + 30κ + 10)
2
t2−t
2
TABLE I: Overall Communication Cost Equations for ECDSA.
The costs assume that the F η
COTe functionality is realized via the
protocol of Keller et al. [29] (which introduces an additional security
parameter, κOT) with the VSOT protocol [1] supplying base-OTs.
Ofﬂine (Setup) Costs
Protocol
π(cid:2)
2PMul
π(cid:2),t,n
Mul
π(cid:2)
2PMul
π(cid:2),t,n
Mul
Rounds
5
5
3
log(t)+ 2
Communication (Bits)
κ · (5κ + 4) + 2
· κ · (5κ + 4) + 2
n2−n
2
Online Costs
κ · (2ξ · (cid:5) + ξ + 3(cid:5) + κOT + 2)
· κ · (2ξ · (cid:5) + ξ + 3(cid:5) + κOT + 2)
t2−t
2
TABLE II: Communication Cost Equations for Subprotocols. The
costs assume that the F η
COTe functionality is realized via the protocol
of Keller et al. [29] with the VSOT protocol [1] supplying base-OTs.
In this table we do not consider the round-reducing optimization for
π(cid:2)
2PMul. Note that (cid:5) is the multiplication batch size, and ξ is the size
of the encoding used by Bob, in bits.
and a single element from Zq, along with the point for which
knowledge of discrete logarithm is to be proven.
The signing protocol πt,n
ECDSA-Sign contains one execution of
the π(cid:4)
2PMul protocol for each pair of parties with (cid:5) = 4; see
Section VII for a discussion of the optimization that allows
this, as opposed to the two executions each with (cid:5) = 2 that
would be suggested by the protocols as previously described.
In addition, each party that participates in the sigature must
broadcast commitments and decommitments to φi, Ri, a proof
of knowledge of discrete logarithm for Ri, and check messages
Γ 1
i , Γ 2
i . Finally, each party must broadcast its signature
share sigi. The commitments are coalesced such that only three
calls to F n
Com are required, each adding κ bits of communication
to the cost of the value committed.
i , and Γ 3
For the setup protocol πt,n
2PMul and (by proxy) π(cid:4),t,n
ECDSA-Setup, the bulk of the commu-
nication cost comes from the initialization of OT-extensions,
which will later be used by π(cid:4)
Mul . The
only other elements transmitted during setup are polynomial
points pj(i) from every party Pj to every Pi, and for every Pi
a commitment and decommiment to the curve point Ti and a
corresponding proof of knowledge of Ti’s discrete logarithm.
Concretely, for κ = 256, s = 80, and κOT = 128 + s
(an additional security parameter for OT-extension [29]), the
communication cost for signing is roughly 64.7 · t · (t − 1)
kilobytes, and for setup roughly 20.5 · n · (n − 1) + 0.1 · n
kilobytes. As an example, for n = 16 and t = 8, setup requires
15291 KB of communication and signing requires 3571 KB.
VII. IMPLEMENTATION
We created proof-of-concept implementations of our t-of-
n setup and signing protocols in the Rust language, which
are derived from the open source 2-of-n implementations of
Doerner et al. [1]. Our implementation uses the secp256k1
curve, as standardized by NIST [5]. Thus, for all benchmarks,
κ = 256; additionally, we chose s = 80. We instantiated the
F η
COTe functionality using the protocol of Keller et al. [29]
and set the OT-extensions security parameter κOT = 128 + s,
following their analysis. We chose, as Doerner et al. did, to
instantiate F RDL,n
Com-ZK via the Fiat-Shamir Heuristic (though we
note that this transform is not UC-secure), and to instantiate the
PRG, the random oracle H, and the commitment functionality
F n
Com via SHA-256. Consequently, our protocol uses the same
concrete hash function as speciﬁed in the ECDSA standard.
We note that while the folkloric hash-based instantiation of
F n
Com (i.e. H(m(cid:9)r) where m is the message, and r ← {0, 1}κ)
requires a random nonce to be appended to the message in
order to hide the message regardless of its distribution, in our
protocol all committed messages have sufﬁcient entropy that
the nonce can be omitted.
Unlike Doerner et al., we do not parallelize vectors of hash-
ing operations. Instead, each party parallelizes its interactions
with its counterparties (and the computations that they require),
using a number of threads equal to the number of parties,
or a speciﬁed maximum, whichever is smaller. Additionally,
the pairwise OT-extension initialization required by our setup
protocol is parallelized among an number of threads equal to
the number of parties. While we have assumed throughout this
paper that the setup protocol can parallelize key-generation
and OT-extension initialization, our implementation runs these
two phases sequentially, and thus the practical round count is
increased from ﬁve to eight.
In our signing protocol, as described in Section V, the
parties instantiate both the F (cid:4)
2PMul and F (cid:4),t,n
functionalities
Mul
with batch sizes of (cid:5) = 2. Within the π(cid:4),t,n
Mul protocol that
realizes F (cid:4),t,n
2PMul is instantiated a second time by all
pairs of parties, again with a batch size (cid:5) = 2. Observe that
the preprocessing for both sets of F (cid:4)
2PMul instances can be
performed simultaneously, and that when π(cid:4)
2PMul is used to
realize F (cid:4)
2PMul it is feasible for the parties to provide inputs
and produce outputs for each element in a batch independently.
In our implementation, we combine the batches and use only a
single instance of the π(cid:4)
2PMul protocol for each pair of parties,
with a batch size (cid:5) = 4. This allows us to perform only one OT-
extension operation, and thereby save the overhead associated
with a second.
, F (cid:4)
Mul
We benchmarked our implementation using a set of Google
Cloud Platform n1-highcpu-8 nodes, each running Ubuntu
18.04 with kernel 4.15.0. Each node of this type has four
physical cores clocked at 2.0 GHz, and is capable of executing
eight threads simultaneously. These machines are slightly
slower than those used by Doerner et al. [1], and thus the
timings we report for their protocol are slightly slower than they
report themselves. Each party participating in a benchmark was
(cid:18)(cid:17)(cid:23)(cid:20)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:46:34 UTC from IEEE Xplore.  Restrictions apply. 
n/t Range
n/t Step
Samples (Signing)
Samples (Setup)
[2, 8]
(8, 16]