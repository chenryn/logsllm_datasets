Employee # : 9601
Name : FARRELL
Job : ANALYST
Manager : 7902
Hire Date : 03-MAR-08 00:00:00
Salary : 5000
Commission :
Dept # : 40
----------------------
Added employee...
Employee # : 9602
Name : TYLER
Job : ANALYST
Manager : 7900
Hire Date : 25-JAN-08 00:00:00
Salary : 4800
Commission :
Dept # : 40
----------------------
The following SELECT command shows that employees Farrell and Tyler were
successfully added.
SELECT * FROM emp WHERE empno > 9600;
empno | ename | job | mgr | hiredate | sal | comm | deptno
-------+---------+---------+------+--------------------+---------+------+--------
9601 | FARRELL | ANALYST | 7902 | 03-MAR-08 00:00:00 | 5000.00 | | 40
9602 | TYLER | ANALYST | 7900 | 25-JAN-08 00:00:00 | 4800.00 | | 40
(2 rows)
Now, execute the following anonymous block:
BEGIN
emp_insert(9603,'HARRISON','SALESMAN',7902,'13-DEC-07',5000,3000,20);
emp_insert(9604,'JARVIS','SALESMAN',7902,'05-MAY-08',4800,4100,11);
COMMIT;
EXCEPTION
WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('SQLERRM: ' || SQLERRM);
DBMS_OUTPUT.PUT_LINE('An error occurred - roll back inserts');
ROLLBACK;
END;
Added employee...
Employee # : 9603
Name : HARRISON
Job : SALESMAN
Manager : 7902
Hire Date : 13-DEC-07 00:00:00
Salary : 5000
Commission : 3000
Dept # : 20
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 240
Database Compatibility for Oracle® Developers Guide
----------------------
SQLERRM: insert or update on table "emp" violates foreign key constraint
"emp_ref_dept_fk"
An error occurred - roll back inserts
A SELECT command run against the table yields the following:
SELECT * FROM emp WHERE empno > 9600;
empno | ename | job | mgr | hiredate | sal | comm | deptno
-------+---------+---------+------+--------------------+---------+------+--------
9601 | FARRELL | ANALYST | 7902 | 03-MAR-08 00:00:00 | 5000.00 | | 40
9602 | TYLER | ANALYST | 7900 | 25-JAN-08 00:00:00 | 4800.00 | | 40
(2 rows)
The ROLLBACK command in the exception section successfully undoes the insert of
employee Harrison. Also note that employees Farrell and Tyler are still in the table as
their inserts were made permanent by the COMMIT command in the first anonymous
block.
Note: Executing a COMMIT or ROLLBACK in a plpgsql procedure will throw an error if
there is an Oracle-style SPL procedure on the runtime stack.
3.6.3 PRAGMA AUTONOMOUS_TRANSACTION
An SPL program can be declared as an autonomous transaction by specifying the
following directive in the declaration section of the SPL block:
PRAGMA AUTONOMOUS_TRANSACTION;
An autonomous transaction is an independent transaction started by a calling program. A
commit or rollback of SQL commands within the autonomous transaction has no effect
on the commit or rollback in any transaction of the calling program. A commit or
rollback in the calling program has no effect on the commit or rollback of SQL
commands in the autonomous transaction.
The following SPL programs can include PRAGMA AUTONOMOUS_TRANSACTION:
 Standalone procedures and functions
 Anonymous blocks
 Procedures and functions declared as subprograms within packages and other
calling procedures, functions, and anonymous blocks
 Triggers
 Object type methods
The following are issues and restrictions related to autonomous transactions:
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 241
Database Compatibility for Oracle® Developers Guide
 Each autonomous transaction consumes a connection slot for as long as it is in
progress. In some cases, this may mean that the max_connections parameter in
the postgresql.conf file should be raised.
 In most respects, an autonomous transaction behaves exactly as if it was a
completely separate session, but GUCs (that is, settings established with SET) are
a deliberate exception. Autonomous transactions absorb the surrounding values
and can propagate values they commit to the outer transaction.
 Autonomous transactions can be nested, but there is a limit of 16 levels of
autonomous transactions within a single session.
 Parallel query is not supported within autonomous transactions.
 The Advanced Server implementation of autonomous transactions is not entirely
compatible with Oracle databases in that the Advanced Server autonomous
transaction does not produce an ERROR if there is an uncommitted transaction at
the end of an SPL block.
The following set of examples illustrates the usage of autonomous transactions. This first
set of scenarios show the default behavior when there are no autonomous transactions.
Before each scenario, the dept table is reset to the following initial values:
SELECT * FROM dept;
deptno | dname | loc
--------+------------+----------
10 | ACCOUNTING | NEW YORK
20 | RESEARCH | DALLAS
30 | SALES | CHICAGO
40 | OPERATIONS | BOSTON
(4 rows)
Scenario 1a – No autonomous transactions with only a final COMMIT
This first set of scenarios show the insertion of three rows starting just after the initial
BEGIN command of the transaction, then from within an anonymous block within the
starting transaction, and finally from a stored procedure executed from within the
anonymous block.
The stored procedure is the following:
CREATE OR REPLACE PROCEDURE insert_dept_70 IS
BEGIN
INSERT INTO dept VALUES (70,'MARKETING','LOS ANGELES');
END;
The PSQL session is the following:
BEGIN;
INSERT INTO dept VALUES (50,'HR','DENVER');
BEGIN
INSERT INTO dept VALUES (60,'FINANCE','CHICAGO');
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 242
Database Compatibility for Oracle® Developers Guide
insert_dept_70;
END;
COMMIT;
After the final commit, all three rows are inserted:
SELECT * FROM dept ORDER BY 1;
deptno | dname | loc
--------+------------+-------------
10 | ACCOUNTING | NEW YORK
20 | RESEARCH | DALLAS
30 | SALES | CHICAGO
40 | OPERATIONS | BOSTON
50 | HR | DENVER
60 | FINANCE | CHICAGO
70 | MARKETING | LOS ANGELES
(7 rows)
Scenario 1b – No autonomous transactions, but a final ROLLBACK
The next scenario shows that a final ROLLBACK command after all inserts results in the
rollback of all three insertions:
BEGIN;
INSERT INTO dept VALUES (50,'HR','DENVER');
BEGIN
INSERT INTO dept VALUES (60,'FINANCE','CHICAGO');
insert_dept_70;
END;
ROLLBACK;
SELECT * FROM dept ORDER BY 1;
deptno | dname | loc
--------+------------+----------
10 | ACCOUNTING | NEW YORK
20 | RESEARCH | DALLAS
30 | SALES | CHICAGO
40 | OPERATIONS | BOSTON
(4 rows)
Scenario 1c – No autonomous transactions, but anonymous block ROLLBACK
A ROLLBACK command given at the end of the anonymous block also eliminates all three
prior insertions:
BEGIN;
INSERT INTO dept VALUES (50,'HR','DENVER');
BEGIN
INSERT INTO dept VALUES (60,'FINANCE','CHICAGO');
insert_dept_70;
ROLLBACK;
END;
COMMIT;
SELECT * FROM dept ORDER BY 1;
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 243
Database Compatibility for Oracle® Developers Guide
deptno | dname | loc
--------+------------+----------
10 | ACCOUNTING | NEW YORK
20 | RESEARCH | DALLAS
30 | SALES | CHICAGO
40 | OPERATIONS | BOSTON
(4 rows)
This next set of scenarios shows the effect of using autonomous transactions with
PRAGMA AUTONOMOUS_TRANSACTION in various locations.
Scenario 2a – Autonomous transaction of anonymous block with COMMIT
The procedure remains as initially created:
CREATE OR REPLACE PROCEDURE insert_dept_70 IS
BEGIN
INSERT INTO dept VALUES (70,'MARKETING','LOS ANGELES');
END;
Now, the PRAGMA AUTONOMOUS_TRANSACTION is given with the anonymous block
along with the COMMIT command at the end of the anonymous block.
BEGIN;
INSERT INTO dept VALUES (50,'HR','DENVER');
DECLARE
PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
INSERT INTO dept VALUES (60,'FINANCE','CHICAGO');
insert_dept_70;
COMMIT;
END;
ROLLBACK;
After the ROLLBACK at the end of the transaction, only the first row insertion at the very
beginning of the transaction is discarded. The other two row insertions within the
anonymous block with PRAGMA AUTONOMOUS_TRANSACTION have been independently
committed.
SELECT * FROM dept ORDER BY 1;
deptno | dname | loc
--------+------------+-------------
10 | ACCOUNTING | NEW YORK
20 | RESEARCH | DALLAS
30 | SALES | CHICAGO
40 | OPERATIONS | BOSTON
60 | FINANCE | CHICAGO
70 | MARKETING | LOS ANGELES
(6 rows)
Scenario 2b – Autonomous transaction anonymous block with COMMIT including
procedure with ROLLBACK, but not an autonomous transaction procedure
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 244
Database Compatibility for Oracle® Developers Guide
Now, the procedure has the ROLLBACK command at the end. Note, however, that the
PRAGMA ANONYMOUS_TRANSACTION is not included in this procedure.
CREATE OR REPLACE PROCEDURE insert_dept_70 IS
BEGIN
INSERT INTO dept VALUES (70,'MARKETING','LOS ANGELES');
ROLLBACK;
END;
Now, the rollback within the procedure removes the two rows inserted within the
anonymous block (deptno 60 and 70) before the final COMMIT command within the
anonymous block.
BEGIN;
INSERT INTO dept VALUES (50,'HR','DENVER');
DECLARE
PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
INSERT INTO dept VALUES (60,'FINANCE','CHICAGO');
insert_dept_70;
COMMIT;
END;
COMMIT;
After the final commit at the end of the transaction, the only row inserted is the first one
from the beginning of the transaction. Since the anonymous block is an autonomous
transaction, the rollback within the enclosed procedure has no effect on the insertion that
occurs before the anonymous block is executed.
SELECT * FROM dept ORDER by 1;
deptno | dname | loc
--------+------------+----------
10 | ACCOUNTING | NEW YORK
20 | RESEARCH | DALLAS
30 | SALES | CHICAGO
40 | OPERATIONS | BOSTON
50 | HR | DENVER
(5 rows)
Scenario 2c – Autonomous transaction anonymous block with COMMIT including
procedure with ROLLBACK that is also an autonomous transaction procedure
Now, the procedure with the ROLLBACK command at the end also has PRAGMA
ANONYMOUS_TRANSACTION included. This isolates the effect of the ROLLBACK
command within the procedure.
CREATE OR REPLACE PROCEDURE insert_dept_70 IS
PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
INSERT INTO dept VALUES (70,'MARKETING','LOS ANGELES');
ROLLBACK;
END;
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 245
Database Compatibility for Oracle® Developers Guide
Now, the rollback within the procedure removes the row inserted by the procedure, but
not the other row inserted within the anonymous block.
BEGIN;
INSERT INTO dept VALUES (50,'HR','DENVER');
DECLARE
PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
INSERT INTO dept VALUES (60,'FINANCE','CHICAGO');
insert_dept_70;
COMMIT;
END;
COMMIT;
After the final commit at the end of the transaction, the row inserted is the first one from
the beginning of the transaction as well as the row inserted at the beginning of the
anonymous block. The only insertion rolled back is the one within the procedure.
SELECT * FROM dept ORDER by 1;
deptno | dname | loc
--------+------------+----------
10 | ACCOUNTING | NEW YORK
20 | RESEARCH | DALLAS
30 | SALES | CHICAGO
40 | OPERATIONS | BOSTON
50 | HR | DENVER
60 | FINANCE | CHICAGO
(6 rows)
The following sections now show examples of PRAGMA AUTONOMOUS_TRANSACTION in
a couple of other SPL program types.
Autonomous Transaction Trigger
The following example shows the effect of declaring a trigger with PRAGMA
AUTONOMOUS_TRANSACTION.
The following table is created to log changes to the emp table:
CREATE TABLE empauditlog (
audit_date DATE,
audit_user VARCHAR2(20),
audit_desc VARCHAR2(20)
);
The trigger attached to the emp table that inserts these changes into the empauditlog
table is the following. Note the inclusion of PRAGMA AUTONOMOUS_TRANSACTION in
the declaration section.
CREATE OR REPLACE TRIGGER emp_audit_trig
AFTER INSERT OR UPDATE OR DELETE ON emp
DECLARE
PRAGMA AUTONOMOUS_TRANSACTION;
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 246
Database Compatibility for Oracle® Developers Guide
v_action VARCHAR2(20);
BEGIN
IF INSERTING THEN
v_action := 'Added employee(s)';
ELSIF UPDATING THEN
v_action := 'Updated employee(s)';
ELSIF DELETING THEN
v_action := 'Deleted employee(s)';
END IF;
INSERT INTO empauditlog VALUES (SYSDATE, USER,
v_action);
END;
The following two inserts are made into the emp table within a transaction started by the
BEGIN command.
BEGIN;
INSERT INTO emp VALUES (9001,'SMITH','ANALYST',7782,SYSDATE,NULL,NULL,10);
INSERT INTO emp VALUES (9002,'JONES','CLERK',7782,SYSDATE,NULL,NULL,10);
The following shows the two new rows in the emp table as well as the two entries in the
empauditlog table:
SELECT * FROM emp WHERE empno > 9000;
empno | ename | job | mgr | hiredate | sal | comm | deptno
-------+-------+---------+------+--------------------+-----+------+--------
9001 | SMITH | ANALYST | 7782 | 23-AUG-18 07:12:27 | | | 10
9002 | JONES | CLERK | 7782 | 23-AUG-18 07:12:27 | | | 10
(2 rows)
SELECT TO_CHAR(AUDIT_DATE,'DD-MON-YY HH24:MI:SS') AS "audit date",
audit_user, audit_desc FROM empauditlog ORDER BY 1 ASC;
audit date | audit_user | audit_desc
--------------------+--------------+-------------------
23-AUG-18 07:12:27 | enterprisedb | Added employee(s)
23-AUG-18 07:12:27 | enterprisedb | Added employee(s)
(2 rows)
But then the ROLLBACK command is given during this session. The emp table no longer
contains the two rows, but the empauditlog table still contains its two entries as the
trigger implicitly performed a commit and PRAGMA AUTONOMOUS_TRANSACTION
commits those changes independent from the rollback given in the calling transaction.
ROLLBACK;
SELECT * FROM emp WHERE empno > 9000;
empno | ename | job | mgr | hiredate | sal | comm | deptno