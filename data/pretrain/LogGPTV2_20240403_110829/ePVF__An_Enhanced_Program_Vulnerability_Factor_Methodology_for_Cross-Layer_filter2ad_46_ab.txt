program, and is constructed based on the program’s dynamic
instruction trace [27]. In the DDG, a vertex can be a register,
a memory address or even a constant value. An edge records
the instruction (i.e., an operation) and links source operand(s)
to destination operand(s).
We implement the DDG analysis at the LLVM compiler’s
intermediate representation (IR) level. Note that since the
LLVM IR abstracts out the hardware/ISA-speciﬁc information,
it contains an inﬁnite number of virtual registers 1. As a result,
at this level there is no notion of a register ﬁle. We model the
architectural resource as the set of virtual registers used in
the IR of a program. This deﬁnition also matches our fault
injection experiments as only activated faults are considered.
One further issue is deciding how to express register-based
memory addressing instructions. This needs special care as it
is common to have the same register to store many different
memory addresses, or different registers store to the same
address. Since we create new DDG nodes for each newly
written memory address, it is also common for a register to
store multiple uses of the same memory address. To handle
these cases, we create an edge in the DDG to link the
memory address used and the register. This edge is virtual
to differentiate this case from direct data data dependencies.
Running example: Figure 3 shows a small portion of the
DDG constructed from a dynamic IR instruction trace of
the pathﬁnder benchmark [28]. We rename the IR registers
for readability. Figure 3a presents the corresponding static
instruction in the LLVM IR of the program2. Figure 3b illus-
trates the DDG obtained after executing the static instructions
in Figure 3a. Nodes representing memory are labelled with
the address values recorded during the run-time. Memory
addresses that correspond to the output are highlighted.
From each memory location that is part of the output, in this
1The register allocator will take the physical register ﬁle size into account
when mapping the virtual registers to physical ones in the compiler backend.
2LLVM has a special IR instruction named getelementptr (gep) to abstract
memory address computations, which corresponds to a combination of several
instructions in a assembly language such as MOV and ADD instructions.
LLVM IR 
Instruction 
Trace
Base ACE 
Analysis
Section III.A 
ePVF Methodology
  r1 = load i32* r2, align 4
  r4 = add nsw i32 r1, r3
  r5 = getelementptr inbounds i32* r6, i64 r7
  store i32 r4, i32* r5, align 4 
  r8= load i32* r2, align 4
Propagation 
Model
Section III.C
(a) A small portion of static IR-level representation of the pathﬁnder
benchmark
0x15FB178
virtual
r2
load
r8
add
r3
load
add
r1
r4
store
r2
virtual
load
r8
add
r3
0x15FB178
load
add
r1
r4
store
0x15FB174
virtual
r6
gep
gep
r5
r7
0x15FB174
virtual
r6
gep
gep
r5
r7
(b) The DDG constructed based
on the dynamic trace resulting
from executing the code pre-
sented in (a).
(c) The ACE graph used to cap-
ture the ACE bits. Note that dy-
namically dead code is elimi-
nated.
Fig. 3: An example of computing PVF for the register ﬁle
case 0x15FB174 (highlighted in Figure 3b), we run a reverse
breadth-ﬁrst search on the DDG that contains all the dependent
vertices of 0x15FB174. This step will exclude the node r8
as it does not contribute to the output. We call the resulting
graph the ACE graph (Figure 3c). Then the total ACE bits are
calculated as (the size of each operand is deﬁned in IR):
ACE Bitsused registers =
Bits in Ri
7(cid:3)
= 32 + 64 + 32 + 32 + 64 + 64 + 64 = 352
i=1
To compute the PVF we also need to compute the total bits
for used registers, summing the total bits used in operations
within this sequence of instructions.
8(cid:3)
Total Bitsused registers =
Bits in Ri
= 32 + 64 + 32 + 32 + 64 + 64 + 64 + 64 = 416
i=1
Then, the PVF of used registers for this example is:
PVFused registers =
ACEBitsused registers
T otalBitsused registers
= 0.846
B. Finding the Crash-causing Bits
We aim to identify the bits that cause the program to crash
(i.e., lead to hardware exceptions), and subtract these bits from
the overall ACE bits. To this end, it is important to determine
the types of crashes we observe in practice and their relative
frequencies. We perform a fault injection experiment by in-
jecting faults into ten benchmark applications (§IV describes
our fault injection methodology and benchmarks).
We observe four types of exceptions resulting in crashes
(Table I). Table II shows their relative frequencies. Our results
show that segmentation faults are the predominant source of
171
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:17:04 UTC from IEEE Xplore.  Restrictions apply. 
TABLE I: Types of exceptions resulting in crashes
Type
Segmentation fault (SF)
Abort (A)
Misaligned memory
access (MMA)
Arithmetic errors (AE)
Description
Memory access that exceeds the legal
boundary of a memory segment
Programs aborted by themselves or OS
Memory accesses are not aligned at
four bytes
Division by 0, Overﬂow etc.
TABLE II: Relative crash frequency analysis for each benchmarks
Benchmark
hotspot
bfs
kmeans
nw
pathﬁnder
lud
srad
mm
particleﬁlter
lulesh
Types of crashes (%)
A
SF
97.6% 0.0%
98.8% 0.0%
100.0% 0.0%
99.6% 0.0%
99.9% 0.1%
100.0% 0.0%
96.0% 0.0%
99.8% 0.1%
100.0% 0.0%
99.0% 1.0%
MMA
AE
2.3% 0.1%
0.7% 0.5%
0.0% 0.0%
0.4% 0.0%
0.0% 0.0%
0.0% 0.0%
4.0% 0.0%
0.1% 0.0%
0.0% 0.0%
0.0% 0.0%
crashes with a 99% average frequency and a 96% minimum
over all benchmarks. This observation suggests that, for the
class of workloads with similar properties as these bench-
marks, we only need to model the mechanisms that generate
segmentation faults to identify almost all crash-causing bits.
We note that other workloads, architectures, or operating
systems may change these precise ﬁndings, but a similar
methodology can be followed.
Segmentation faults result from memory access violations.
Although different operating systems may implement violation
detection mechanisms in different ways, segmentation faults
are determined based on checking memory accesses against
segment boundaries.
There are two main challenges in determining which bit
ﬂips would lead to a segmentation fault: ﬁrst, we need to
ﬁnd the ranges of the bits that, if ﬂipped, would result in
an out-of-bounds memory access. This includes both faults in
the memory instructions themselves (i.e., load and store), and
faults in their backward slices used for memory addressing.
Second, we need to predict if an incorrect memory access
will generate an access violation. To this end, all segment
boundaries at the time of the memory access need to be known.
To overcome the ﬁrst challenge, we implement an algorithm
that propagates the ranges of crash-causing bits along the
backward slice of the memory access operation (§III-C). To
overcome the second challenge, we instrument the program to
embed a probe for each memory access and capture all the
dynamic segment boundaries (§III-D).
C. The Propagation Model
We model fault propagation for crash-causing faults starting
from a memory addressing operation and going backwards in
the DDG. This analysis is triggered each time a load/store
instruction is encountered during the iteration over the ACE
graph (i.e., the subgraph that contains all ACE nodes in the
DDG) to compute ACE bits. The aim is to ﬁnd all bits that
can generate an out-of-bound address on the backward slice of
the memory address calculation. The model assumes that only
one fault happens during the course of a program. (§II-E).
is
triggered.
consists of
It consists of
two procedures:
The propagation model
two algorithms.
Algorithm 1 describes when and how the propagation
model
IT-
ERATE OVER ACE GRAPH and CRASH CALC. The ITER-
ATE OVER ACE GRAPH procedure takes the ACE graph as
input and iterates over the vertices in the ACE graph. When
it reaches a load/store instruction (line 3), the backward slice
for the address used in the load/store instruction is calculated
(line 5) and passed to the procedure CRASH CALC (line 6).
Inside CRASH CALC, all the instructions along the backward
slice are visited and, for each instruction,
the ranges for
crash-causing bits in operands are computed by invoking
GET RANGE FOR CRASH BITS.
for all inst in ACE Graph do
if inst.opcode == load/store then
Algorithm 1 Iterates over
the ACE graph and invokes
CRASH CALC whenever a load or store instruction is encoun-
tered
1: procedure ITERATE OVER ACE GRAPH(ACEGraph)
2:
3:
4:
5:
6:
7:
8:
9: end procedure
10: procedure CRASH CALC(backwardslice)
11:
12:
13:
14: end procedure
backwardslice =
CALCULATE BACKWARD SLICE(inst)
CRASH CALC(backwardslice)
GET RANGE FOR CRASH BITS(inst)
for all inst in backwardslice do
end for
end for
end if
crashing bits ← 0
global crash bits list
oplist ← inst.source operands
if inst == load/store then
Algorithm 2 Calculates the range of the crash-causing bits
for memory access instructions based on the backward slice
of the address used
1: procedure GET RANGE FOR CRASH BITS(inst)
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
(new max, new min) = lookup table(op, inst)
crash bits list[op] = (new max, new min)
crashing bits
(max, min) = CHECK BOUNDARY(inst.addres)
crash bits list[inst.address] = (max, min)
(max, min) = crash bits list[inst.dest opernd]
end if
for all op in oplist do
make
that
else
the value of op outside (new max, new min)
+=
bits
15:
16: end procedure
end for return crashing bits
The second algorithm (Algorithm 2) consists of the proce-
dure GET RANGE FOR CRASH BITS that models the execu-
tion of each instruction along the backward slice to calculate
the range for crash-causing bits. Speciﬁcally, for a load/store
instruction, the crash model is invoked (CHECK BOUNDARY)
to determine the range of bits that generate an out-of-bound
memory access (at line 6) to obtain a range of crash-causing
bits for the destination register (line 9). Then, for each
source operand, the procedure calculates the range for the
172
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:17:04 UTC from IEEE Xplore.  Restrictions apply. 
crash-causing bits by taking into account the range of the
corresponding destination operand and the semantics of that
instruction (line 11 to line 15). The semantics of the instruction
are determined by the lookup table function in line 13.
Table III shows the common instruction types encountered
on the backward slice of a memory address calculation and
how the lookup table is used to compute the range for each
operand. We assume that all values of operands are positive
integers. The algorithm propagates these ranges along the
backward slice by storing them in the CRASHING BIT LIST
for further reference by the next instructions, as shown in
line 7.
We explain the details of these algorithms using our running
example. In Figure 3b, r5 stores the address 0x15FB174 for the
instruction store i32 r4, i32* r5, align 4. Suppose our bound-
determination technique (described in the next subsection)
returns the bound (0x15FB800, 0x15FA000), meaning that
addressing outside this bound will generate a segmentation
fault. The ACE graph indicates that r5, r6 and r7 are used in
addressing (or computing the address). Together, these three
registers belong to the instruction getelementptr in LLVM. The
instruction semantics are based on row 6 of the Table III -
ranges are obtained by applying the corresponding equations.
r5.value = r6.value + sizeof (r6).type) × (r7)
maxr6 = maxr5 − sizeof ((r6).type) × (r7)