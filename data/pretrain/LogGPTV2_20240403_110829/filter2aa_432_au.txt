usage()
{
        fprintf(stderr, "shmtool - A utility for tinkering with shared memory\n");
        fprintf(stderr, "\nUSAGE:  shmtool (w)rite \n");
        fprintf(stderr, "                (r)ead\n");
        fprintf(stderr, "                (d)elete\n");
        fprintf(stderr, "                (m)ode change \n");
        exit(1);
}
4.9.4  共享内存与信号量的结合使用
在前面的介绍中可以看出，共享内存的使用非常的简便，只要取得映射的指针就可以
直接存取，省去了其它 IPC 方式的传递过程，因此效率极高。不过，因此也产生了一些问
题。如:一个进程修改一个共享内存单元，另一个进程在读该共享内存单元时可能有第三个
进程立即修改该单元，从而会影响程序的正确性。同时，由于分时系统对各进程是分时间
第四章  进程间通信
- 115 -
片处理的，可能会引起不同的正确性问题。为了避免这些问题，在使用中常常将共享内存
和信号量结合使用，利用信号量的保护机制来防止内存的不正确共享。
我们通过实例程序 shmcopy 来进一步说明共享存贮器的实际使用情况。shmcopy 的功
能很简单：把其从标准输入读到的内容送到标准输出。每次调用 shmcopy 就形成两个进程
——读进程和写进程。它们共享两个缓冲区，这两个缓冲区作为共享内存段来实现。当读
进程把数据读入第一个缓冲区期间，写进程就把第二个缓冲区内容写出去，反之亦然。由
于读和写是并发进行的，所以数据吞吐量增加了。这种方法可以用在磁盘高速缓冲程序中。
为了使两个进程同步，防止读进程装满缓冲区之前，写进程就把该缓冲区内容写出来，
我们使用了两个信号量。几乎所有的共享存贮器程序都要使用信号量来实现同步。共享存
贮器机构本身没有提供同步功能。
在程序 shmcopy 中使用了标题文件 share_ex.h，该文件的内容如下：
#include 
#include 
#include 
#include 
#include 
#include 
/* 共享内存的关键字 */
#define SHMKEY1_t (key_t)0x10
#define SHMKEY2 (key_t)0x15
/* 信号量的关键字 */
#define SEMKEY (key_t)0x20
/* 读写缓冲区的大小 */
#define SIZ 5*BUFSIZ
struct databuf{
int d_nread;
char d_buf[SIZ];
};
其中，符号常数 BUFSIZ在头文件 stdio.h 中被定义，它是系统的磁盘块长度。结构 databuf
将强加给每个共享存贮器段，其中的 d_nread 域用于存放读进程所读的字符数，可以通过
共享存贮器段把这个数传送给写进程。d_buf 域用于存放共享信息。
下面的清单中有三个例行程序，getseg()和 getsem()分别实现对两个共享存贮器段和信
号量组的初始化。remove 用于在进程结束端删除各种 IPC 目标。
#include "share_ex.h"
#define IFLAGS (IPC_CREAT | IPC_EXCL)
#define ERR ((struct databuf*) -1)
static int shmid1,shmid2,semid;
fatal(char *mes)
- 116 -
Linux网络编程
{
perror(mes);
exit(1);
}
getseg(struct databuf** p1,struct databuf** p2)
{
/* 创建共享内存 */
if ((shmid1=shmget(SHMKEY1,sizeof(struct databuf),0600|IFLAGS
     )) dnread=read(0,buf1->d_buf,SIZ);
/* 同步 */
semop(semid,&v1,1);
semop(semid,&p2,1);
/* 防止 writer 进程休眠 */
if (buf1->d_nreadd_nread(0,buf2-d_nreadd_nreadd_buf,buf1->d_nread);
semop(semid,&v1,1);
semop(semid,&p2,1);
if (buf2->d_nreadd_buf,buf2->d_nread);
semop(semid,&v2,1);
}
这儿要注意 reader()和 writer 对信号量组使用的一致性。writer()用 v2 来发出一个写操
作已完成的信号，并调用 p1 来等待 semop 的读操作已完成信号。另外，必须注意下列情
况：buf1->d_nread 和 buf2->d_nread 之值是由读进程设置的。
shmcopy 作为命令的使用方法如下：
shmcopy output file
- 120 -
Linux网络编程
第五章  通信协议简介
5.1  引言
通信协议用于协调不同网络设备之间的信息交换，它们建立了设备之间互相识别的有
价值的信息机制。当今在通信界有许多可采用的协议，如 XNS、SNA、TCP/IP 等。这些协
议具有处理各种不同数据通信类型类型的几种基本结构。
在小型工作群和办公部门，局域网正在成为企业极计算的主要平台，过去只有简单的
二十个用户的网络现已发展成能包含几千个用户的全企业网络，并可将许多不同的办公部
门连在一起。
为了配合这种新要求，LAN 协议变得越来越有力和灵活。本章将介绍几种最广泛使用
的协议，比较详细的讨论它们的结构和经过网络进行通信的方法。
5.2  XNS（Xerox Network Systems）概述
Xerox Network Systems（XNS）由 Xerox 公司的 Palo Alto 研究中心（Xerox PARC）的
研究人员开发。起初被设计成连接用于 Xerox 环境的计算机。XNS 是许多局域网结构的基
础设计，对 Novel 和 3com 等公司后来的设计有很大影响。
作为多重 LAN 结构基础的 XNS，其主要特点是设计清楚而简单，实现起来相对方便。
XNS 是最早一种分层网络结构，比 OSI 参考模型出现得更早，对后来的 7 层 OSI 具有
一定的启发作用。
XNS 结构是为它自己的用户阻止专用而设计的，主要服务于 PARC 的研究人员。用于
网络上的电子邮件、电子资料交换和资料的远程打印等项业务。这意味着各个站点比较靠
近。由于存在着距离较近的有利条件，因此设备之间的通信可设计得比较快而可靠。
在 XNS 结构的情况下，可以互联几种类型的设备，特别是工作站和路由器。局域网络
内部的工作站互相连接，各个局域网络又可互联，形成成为网中网的较大系统。路由器通
常放在各个局域网络的交界处，用于在子网间路上选择数据报文。
5.2.1  XNS 分层结构
XNS 结构由五层组成。它和 OSI 模型相似，较高层使用较低层提供的服务，完成较低
层的任何请求。这种协议提供了一个服务范围，包括报文传递、请求和回答包交换，以及
排序的包和字节流。层的编号是从 0 到 4。第 0 层是与网络通信媒体相互作用的最低层，
第 4 层包括网络应用和服务。
1．第四层
第四层是 XNS 的最高层。与 OSI 模型的应用层（第 7 层）相对应。在这一层规定了
两个协议和服务。
交换服务（Clearing house）。
执行分布的名字服务，提供给 XNS 连接的计算机一种使资源和计算机与名字相联系或
相结合的方法。
网关存取协议（GAP）。
第五章通信协议简介
- 121 -
它提供使 XNS 系统连接到非 XNS 系统的网关服务。文件、打印和报文服务通常归第
四层
2．第三层
XNS 的第三层与 OSI 模型的对话层和表示层（第 5 层和第 6 层）相一致。该层所规定
的协议称为信使，信使控制存取网路或网际上的远程过程调用。远程过程调用（RPC）是
类似本地过程调用的网络扩展。它们能让应用程序存取文件，并能远程现实和打印网络上
的其它资源。
3．第二层
XNS 的第二层与 OSI 模型的传输层（第 4 层）相一致。该层除包含被认为是传输层协
议的协议外，还有以下几个协议：
排序包协议（SPP）。
它是一种全双工的传输级协议。这个协议考虑到了两个站点之间的可靠数据交换。协
调发送方和接收方之间的同步并在它们之间建立连接。在这个处理期间家里排序好，标记
在它们之间建立的包，在包级的基础上完成这种排序。
包交换协议（PEP）。
它是一种请求和响应协议。如果在规定的时间后没有接收到响应，则重传包。它使用
在面向事务的应用程序中，因为这种应用程序要求简单而快速的信息交换协议。
路由选择信息协议（RIP）。
类似于其它的 RIP 实现，在距离向量算法的基础上提供路由选择表的动态修改。应注
意这个规范没有规定特定的路由选择算法，但是大多数厂家正在实现它们，它的修改时间
间隔是 60 秒。
差错协议。
允许一个网络站点通知另一个网络站点被接收的包已经发生差错。
回送协议（Echo）。
这个协议考虑到了网络通路的测试或记录的来回旅程时间。
4．第一层
XNS 的第一层符合 OSI 模型的网络层（第 3 层）。第一层本质上执行路由器的功能。