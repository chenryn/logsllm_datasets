了start=mid;或后者写成了end=mid;那么很可能会导致死循环（想一想什么情况下会死循
试。这个算法容易出错的地方很多，
这个算法的思想很简单，
围缩小到后半部分，然后再次使用这种算法迭代。这种"每次将搜索范围缩小一半"的思想称为折半
待查找的元素小，就说明“如果待查找的元素存在，
由于这个序列已经从小到大排好序了，
快的算法：
上一页
写程序,
例11.4.折半查找
（start + end）／ 2，
，有90%的人写出的程序中有各种各样的Bug，
int main(void)
int binarysearch(int number)
int a[LEN] 
#define LEN 8
#include 
return 0;
printf("%d\n", binarysearch(5));
return -1;
while (start 
= １，２，２，２，5，６，８，９ };
一下，这个算法的时间复杂度是多少？
else
if (a[mid]
mid
，每次取中间的元素和待查找的元素比较，
全国嵌入式人才培训基地
第11章排序与查找
(start
return mid;
start
6.折半查找
一定位于序列的后半部分"
 end） / 2;
V
mid
 number
，读者不信的话可以不看书自己写一遍试
1;
+1;
如果前者写成
 这样可以把搜索范
如果中间的元素比
19
下一页
---
## Page 192
的Predicate函数，然后把相关的测试插入到binarysearch函数中：
调用它的Caller没有保证Precondition，最后的结果也还是错的。我们编写几个测试用
如binarysearch这个函数，即使它写得非常正确，
测试一个函数是否正确需要把Precondition、Maintenance和Postcondition这三方面都测试到，
by Contract (DbC）。
个系统就会易于维护。
组a中不存在，
了Precondition、Maintenance和Postcondition是什么，
某些义务，
保a[start..end]都是有效的数组元素而没有访问越界，这称为Precondition，
契约（Contract）
注意这个算法有一个非常重要的前提－－a是排好序的。缺了这个前提，
成mustbe(start，end，number）。可以一边看算法一边做推理:
围之外的数组a的元素中一定不存在number这个元素。以下为了书写方便，我们把这句话表示
怎样才能保证程序的正确性呢？在第2节“插入排序"我们讲过借助Loop Invariant证明循环的正确
个数组a中都不存在number
以mustbe(start, mid-1,
比number小，
组a[O..LEN-1]
int binarysearch(int number)
比如确保“如果number在数组a中存在，
一定能返回-1",
while (start 
return 0;
printf("%d\n", binarysearch(5));
return
assert(!contains(number)); /* Postcondition 2 *
int mid, start = O, end = LEN - l;
return 0;
return 1;
for 
return 
(i = end+l; iy，我们可以据此缩小查找范围，当我们查找的
2、编写一
多个则返回第一个。请修改折半查找算法实现这一特性。
本节定义的数组int a[8]
习题 请点评
出assert.h一种实现。
了NDEBUG宏。宏定义和预处理到第21章预处理再详细解释，在第4节“其它预处理特性"将给
还有另一种办法，
标识符NDEBUG替换成空。这样的宏定义主要是为了用#ifdef等预处理指示测试它定义过没有，而不
码中所有的标识符v替换成20，
注意NDEBUG和我们以前使用的宏定义有点不同，例如#define N 20将N定义为20，
用assert.h中的assert宏定义，这样代码中的所有assert测试都不起作用了：
测试代码只在开发和调试时有用，如果正式发布（Release）的软件也要运行这些测试代码就会严
正确性，
几个测试函数来测试binarysearch，
在代码中适当的地方使用断言（Assertion）可以有效地帮助我们测试程序。也许有人会问：我们用
assert是头文件assert.h中的一个宏定义，
重影响性能了
（例如把数组的排列顺序改一改），则报错退出程序:
for (i
#include
也就是用简单的、不容易出错的代码去测试复杂的、容易出错的代码。
 main: main.c:33: binarysearch: Assertion 
#define NDEBUG 
Aborted
，如果在包含assert.h之前定义一
不必修改源文件，在编译命令行加上选项-DNDEBUG就相当于在源文件开头定义
，则当什么事都没发生过，
1；
，那么这几个测试函数又用什么来测试呢？在实际工作中我们要
，就可以认为找到了y的平方根。思考一下这个算法需要迭
，而我们编写的测试函数往往都很简单，比较容易保证
一般定义成空就足够了。
一个NDEBUG宏
 继续往下执行，
也就是说，
-is_sorted()'
1
参数y是正实数。我们用折半查找来
，参数n是正整数。最简单的算法
，如果待查找的元素在数组中
，在预处理时把代码中所有的
，如果is_sorted()返回值为假
 failed.
，在预处理时把代
1
10
有
---
## Page 195
常详细的介绍。
个元素的位置，
从以上几题可以看出，
考一下如果n不是2的整数次幂应该怎么处理。请分别用递归和循环实现这个算法。
二次循环算出x2.x²=x4，
这个算法的时间复杂度是(n)。其实有更好的办法，比如mypow(x，8)，
5.线性查找
，还可以解决很多类似的问题。[编程珠玑]对于折半查找的各种应用和优化技巧有非
product *= x;
折半查找的思想有非常广泛的应用，
 第三次循环算出4·x4=x8。这样只需要三次循环，
全国嵌入式人才培训基地
起始页
上一级
，不仅限于从一组排好序的元素中找出某
，第一次循环算出xx=x²，
，时间复杂度是⊙(lgn)。
第12章栈与队列
195
贝
思
第
---
## Page 196
5.环形队列
4.队列与广度优先搜索
6.折半查找
3.深度优先搜索
2.堆栈
第 12 章 栈与队列 请点评
1.数据结构的概念
目
全国嵌入式人才培训基地
全国嵌入式人才培训基地
部分I.C语言入门
第12章栈与队列
起始页
1.数据结构的概念
96
---
## Page 197
构=程序（详见[算法+数据结构=程序]）。
计相应的数据结构来支持这种算法。所以Pascal语言的设计者Niklaus Wirth提出：算法+数据结
数据的存储方式和访问方式就决定了解决问题可以采用什么样的算法，要设计一个算法就要同时设
本章主要介绍栈和队列这两种数据结构以及它们的应用。
问，而不能按下标访问。
构体的各成员也是一个挨一
各元素是-
系的，根据访问数据的需求不同，
数据结构（Data Structure）是数据的组织方式。程序中用到的数据都不是孤立的，
第12章栈与队列
可
体。数据的组织方式包含了存储方式和访问方式这两层意思，
.数据结构的概念 请点评
以看作数据的组织方式，把同一类型的数据组织成数组，或者把描述同一对象的各成员组织成结
上一页
页
一个挨一个存储的，
一个存储的，但是每个成员的大小不同，所以只能用.运算符加成员名来访
并且每个元素的大小相同，
，同样的数据可以有多种不同的组织方式。
全国嵌入式人才培训基地
全国嵌入式人才培训基地
第12章栈与队列
1.数据结构的概念
起始页
上一级
从本章的应用实例可以看出，
因此数组可以提供按下标访问的方式，
二者是紧密联系的。例如，
，以前学过的复合类型也
，而是有相互联
一个问题中
，数组的
2.堆栈
下二
一页
结
---
## Page 198
运行结果是cba。运行过程图示如下:
2.堆栈 请点评
取出当前栈顶的元素，
规则被限制为Push和Pop两种操作，Push（入栈或压栈）向栈顶添加元素，
在第3节“递归"中我们已经对堆栈这种数据结构有了初步认识。堆栈是一组元素的集合，
不同之处在于，
页
图12.1.用堆栈实现倒序打印
例12.1.用堆栈实现倒序打印
char pop(void)
void push(char c)
char stack[512];
#include 
int main(void)
int
is_empty(void)
，数组可以按下标随机访问,
，也就是说,
return 0;
while(!is_empty())
push(
push(
push('
return top == 0;
return stack[--top];
stack[top++] = c;
只能访问栈顶元素而不能访问栈中其它元素。如果所有元素的类
全国嵌入式人才培训基地
第12章栈与队列
，访问操作可以通过函数接口提供。看以下的示例程序。
2.堆栈
 这次访问a[5]下次可以访问a[1]，
，Pop（出栈或弹出）
但是堆栈的访问
类似于数
198
下二
贝
---
## Page 199
我们也可以写-
的'c'最早出来,
在main函数中,
实严格来说Push操作之前也应该检查栈是否满了。
的实现其实并没有清除原来的栈顶元素，
据结构而不是一个循环，
指向栈顶的下一个元素",
数组stack是堆栈的存储空间，
了Loop Invariant的概念，
，这就足够了，
例 12.2.用递归实现倒序打印
栈增长方向
底
void print_backward(int pos)
char buf[LEN]={'a',
一个递归函数做倒序打印，
int
入栈的顺序是'a'、
，因为此后通过Push和Pop操作不可能再访问到已经取出的元素，
 main(void)
print_
 在DbC中称为Class Invariant。Pop操作的语义是取出栈顶元素，
，可以用它检验循环的正确性，
m
top=2
一
0
m
Z
一
top=
 return;
_backward(pos+1) ;
'c'
'b'
'b'、'c'，
，利用函数调用的栈帧实现后进先出：
m
2
top=1
0
m
2
top=
0
".0.
，而出栈打印的顺序却是'e`、
top=0
山
top=2
一
0
，和printf的c作用相同。布尔函
。在第2节“插入排序"中介绍
这种Invariant描述的对象是一个数
原来的栈顶元素仍然存在那
'b'、'a',
top=
下次Push操作
最后入栈
但上例
199
---
## Page 200