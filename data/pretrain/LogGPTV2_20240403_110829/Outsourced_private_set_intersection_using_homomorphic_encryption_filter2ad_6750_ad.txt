i.Add(si)
S −→ P : E1(b′
1,1), . . . , E1(b′
P
i = 1, . . . , w :
:
i =Create(m)
w,m), El
2(s1), . . . , El
2(sw)
P −→ C : El
2(s′
j = 1, . . . , m : E2(¬bj ∧ b′
El
1), . . . , El
2(si) ×Qm
i) = El
2(s′
2(s′
w)
i,j) = ˆe(E1(1) · E1(bj), E1(b′
i,j )
j=1Expand(E2(¬bj ∧ b′
i,j) · E2(1))
Figure 4: Outsourced Private Set Intersection Protocol OP SI
obliviously to the server’s set evaluates the Test function
(on the ciphertexts) as
m
^j=1
¬(¬bj ∧ b′
i,j )
The problem is that this formula has multiplicative depth
2 which can no longer be evaluated using the SYY tech-
nique. We therefore construct a new combination of homo-
morphic encryption system that can evaluate this formula
and may be of independent interest. We use Boneh, Goh,
Nissim (BGN) encryption instead of GM encryption which
enables evaluating one multiplication of fan-in 2 (comple-
menting unbounded addition). Then after evaluating the
ﬁrst logical-and we use again the SYY technique for the sec-
ond logical-and.
5.1 Boneh, Goh, Nissim Encryption
Instead of describing the BGN encryption system as in [4],
we will describe its simpliﬁcation based on the techniques of
GM encryption [19]. We emphasize that while our simpliﬁ-
cation reduces the plaintext domain from Zq to Z2, it also
has a few advantages. First, it is no longer necessary to solve
the hard problem of discrete logarithm for decryption, but
instead simple computations suﬃce. Second, the domain of
the plaintext does not need be kept secret by the private key
holder. Instead any party can perform operations, such as
negation, in the group of the plaintext.
5.1.1 Cryptographic Pairings
Given a security parameter κ, let G1 and G2 be two groups
of order n = pq for two large primes p and q, where the
bit-size of n is determined by the security parameter κ.
Our scheme uses a computable, non-degenerate bilinear map
ˆe : G1 × G1 → G2. Modiﬁed Weil or Tate pairings on super-
singular elliptic curves are examples of such maps. Recall
that a bilinear pairing satisﬁes the following three proper-
ties:
• Bilinear: for g, h ∈ G1 and for a, b ∈ Z∗
n, ˆe(ga, hb) =
ˆe(g, h)ab
• Non-degenerate: ˆe(g, g) 6= 1 is a generator of G2
encode a 0 as a quadratic residue in G1, and a 1 as a pseudo
quadratic residue in G1. Let E1(x) denote the encryption
of plaintext x in this ﬁrst stage and let D1(c) denote the
corresponding decryption. Clearly, E1(x) is homomorphic
in the exclusive-or operation.
D1(E1(x) · E1(y)) = x ⊕ y
Using the properties of the bilinear map we can then also
perform one logical-and operation on two ciphertexts. Since
the result of the bilinear map inherits the exponents, if one
operand is a quadratic residue, then the result will be a
quadratic residue. The result will be either a quadratic
residue or quadratic non-residue in G2. We then have a
second-stage encryption scheme following the GM construc-
tion. Let E2(x) denote the encryption of plaintext x in this
second stage and let D2(c) denote the corresponding decryp-
tion.
D2(ˆe(E1(x), E1(y))) = x ∧ y
And again, the second-stage encryption system is homo-
morphic in the exclusive-or operation.
D2(E2(x) · E2(y)) = x ⊕ y
We can now use the SYY technique on the second-stage
encryption for unbounded fan-in logical-and. Let El
2(x) de-
note the expanded ciphertext (using the same Expand algo-
rithm as in Section 3.2).
Dl
2(El
2(x) × El
2(y)) = x ∧ y
Using this combination of homomorphic encryption sys-
tems we can evaluate the formula above on ciphertexts.
5.1.3 Security
We adopt the IND-CPA security model for our construc-
tion. Our encryption algorithm does not involve any new
primitives, but is a simpliﬁcation of BGN encryption to GM
encryption. We therefore make the following proposition.
Proposition 1. If the quadratic residuosity assumption
holds, then our encryption scheme is IND-CPA secure.
• Computable: there exists an eﬃcient algorithm to com-
5.2 Protocol
pute ˆe(g, h) for all g, h ∈ G1
5.1.2 Algorithm
Recall that GM encryption is based on quadratic residues.
In the ﬁrst stage we encrypt using elements in group G1. We
In the outsourced protocol we introduce a third party,
the service provider P . Both, client and server, send their
encrypted inputs to the service provider who does not learn
anything about either inputs or output. Figure 4 shows the
protocol.
The protocol is only secure in the semi-honest model. Se-
curity against a malicious service provider – while not tech-
nically diﬃcult – requires verifying the integrity of the com-
putation which has the same complexity as performing the
computation. Veriﬁable computation [7, 16] may help by
shifting this complexity to a pre-computation phase, but is
prohibitively expensive in practice due to its use of fully ho-
momorphic encryption. We therefore argue that security in
the malicious model annihilates any advantage of outsourc-
ing.
Outsourced computation can be performed independently
from either the client’s or server’s on-line availability. The
client can store an encrypted Bloom ﬁlter at the service
provider and the server may query new sets or elements
as they arrive. Vice-versa, the server may store encrypted
element-wise Bloom ﬁlter and bit-wise encrypted elements
and the client may query using new Bloom ﬁlter.
5.2.1 Security Proof
The security of this protocol (in the semi-honest model)
also trivially follows from the security of the encryption
scheme.
In case of outsourcing we have to also simulate the view of
the service provider – an additional party in the ideal model.
We consider the service provider as just another party in the
protocol with no input or output, i.e.
its view is empty in
the ideal model. It does not interact with the trusted server.
Theorem 3. If the quadratic residuosity assumption holds,
then protocol OP SI implements private set intersection in
the semi-honest model.
Proof. The server receives no messages and the client
only the intersection, such that simulators are trivial.
In the protocol execution the service provider only receives
encrypted messages, such that a simulator only needs to
simulate ciphertexts. These are all independent due to IND-
CPA security of our encryption scheme.
6. CONCLUSIONS
We have investigated private set intersection protocols.
We have presented a novel construction based on Bloom ﬁl-
ter and homomorphic encryption. Our construction is secure
against malicious adversaries in the standard model. Fur-
thermore, we have the client certify its set with a trusted
third party and hide the size of the client set from the server.
Our construction is eﬃcient. It has not only optimal com-
plexity, but also constants similar to protocols only secure
in the random oracle model. We extend our construction to
outsourcing the computation of the intersection to an obliv-
ious service provider. This makes private set intersection
amenable to secure cloud computing.
7. REFERENCES
[1] G. Ateniese, E. De Cristofaro, and G. Tsudik. (If) Size
Matters: Size-Hiding Private Set Intersection.
Proceedings of the 14th International Conference on
Practice and Theory in Public Key Cryptography,
2011.
[2] S. Bellovin, and W. Cheswick. Privacy-Enhanced
Searches Using Encrypted Bloom Filters. Cryptology
ePrint Archive Report 2004/022, 2004.
[3] B. Bloom. Space/Time Trade-oﬀs in Hash Coding
with Allowable Errors. Communication of the ACM
13(7), 1970.
[4] D. Boneh, E. Goh, and K. Nissim. Evaluating 2-DNF
Formulas on Ciphertexts. Proceedings of the 2nd
Theory of Cryptography Conference, 2005.
[5] J. Camenisch, and G. Zaverucha. Private Intersection
of Certiﬁed Sets. Proceedings of the 13th International
Conference on Financial Cryptography and Data
Security, 2009.
[6] D. Chaum. Blind Signatures for Untraceable
Payments. Proceedings of CRYPTO, 1983.
[7] K. Chung, Y. Kalai, and S. Vadhan. Improved
Delegation of Computation Using Fully Homomorphic
Encryption. Proceedings of CRYPTO, 2010.
[8] J. Coron. On the Exact Security of Full Domain Hash.
Proceedings of CRYPTO, 2000.
[9] D. Dachman-Soled, T. Malkin, M. Raykova, and Moti
Yung. Eﬃcient Robust Private Set Intersection.
Proceedings of the 7th International Conference on
Applied Cryptography and Network Security, 2009.
[10] E. De Cristofaro, J. Kim, and G. Tsudik.
Linear-Complexity Private Set Intersection Protocols
Secure in Malicious Model. Proceedings of
ASIACRYPT, 2010.
[11] E. De Cristofaro, Y. Lu, and G. Tsudik. Eﬃcient
Techniques for Privacy-Preserving Sharing of Sensitive
Information. Proceedings of the 2nd International
Conference on Trust and Trustworthy Computing,
2011.
[12] E. De Cristofaro, and G. Tsudik. Practical Private Set
Intersection Protocols with Linear Complexity.
Proceedings of the 14th International Conference on
Financial Cryptography and Data Security, 2010.
[13] U. Feige, A. Fiat, and A. Shamir. Zero-Knowledge
Proofs of Identity. Journal of Cryptology 1(2), 1988.
[14] M. Freedman, Y. Ishai, B. Pinkas, and O. Reingold.
Keyword Search and Oblivious Pseudorandom
Functions. Proceedings of the 2nd Theory of
Cryptography Conference, 2005.
[15] M. Freedman, K. Nissim, and B. Pinkas. Eﬃcient
Private Matching and Set Intersection. Proceedings of
EUROCRYPT, 2004.
[16] R. Gennaro, C. Gentry, and B. Parno. Non-interactive
Veriﬁable Computing: Outsourcing Computation to
Untrusted Workers. Proceedings of CRYPTO, 2010.
[17] E. Goh. Secure Indexes. Cryptology ePrint Archive
Report 2003/216, 2003.
[18] O. Goldreich. Foundations of Cryptography: Basic
Applications. Cambridge University Press, 2004.
[19] S. Goldwasser, and S. Micali. Probabilistic Encryption.
Journal of Computer and Systems Science 28(2), 1984.
[20] C. Hazay, and Y. Lindell. Eﬃcient Protocols for Set
Intersection and Pattern Matching with Security
Against Malicious and Covert Adversaries. Proceedings
of the 5th Theory of Cryptography Conference, 2008.
[21] C. Hazay, and K. Nissim. Eﬃcient Set Operations in
the Presence of Malicious Adversaries. Proceedings of
the 13th International Conference on Practice and
Theory in Public Key Cryptography, 2010.
[22] S. Jarecki, and X. Liu. Eﬃcient Oblivious
Pseudorandom Function with Applications to
Adaptive OT and Secure Computation of Set
Intersection. Proceedings of the 6th Theory of
Cryptography Conference, 2009.
[23] S. Jarecki, and X. Liu. Fast Secure Computation of
Set Intersection. Proceedings of the 7th International
Conference on Security and Cryptography for
Networks, 2010.
[24] F. Kerschbaum. Public-Key Encrypted Bloom Filters
with Applications to Supply Chain Integrity.
Proceedings of the 25th IFIP WG 11.3 Conference on
Data and Applications Security, 2011.
[25] L. Kissner, and D. Song. Privacy-Preserving Set
Operations. Proceedings of CRYPTO, 2005.
[26] L. Michael, W. Nejdl, O. Papapetrou, and W.
Siberski. Improving Distributed Join Eﬃciency with
Extended Bloom Filter Operations. Proceedings of the
21st International Conference on Advanced
Networking and Applications, 2007.
[27] M. Naor and B. Pinkas. Oblivious Transfer and
Polynomial Evaluation. Proceedings of the 31st
Symposium on Theory of Computer Science, 1999.
[28] R. Nojima, and Y. Kadobayashi. Cryptographically
Secure Bloom-Filters. Transactions on Data Privacy
2, 2009.
[29] L. Qiu, Y. Li, and X. Wu. Preserving Privacy in
Association Rule Mining with Bloom Filters. Journal
of Intelligent Information Systems 29(3), 2009.
[30] S. Ramesh, O. Papapetrou, and W. Siberski.
Optimizing Distributed Joins with Bloom Filters.
Proceedings of the 5th International Conference on
Distributed Computing and Internet Technology, 2009.
[31] M. Raykova, B. Vo, S. Bellovin, and T. Malkin. Secure
Anonymous Database Search. Proceedings of the ACM
Cloud Computing Security Workshop, 2009.
[32] T. Sander, A. Young, and M. Yung. Non-Interactive
CryptoComputing For NC1. Proceedings of the 40th
Symposium on Foundations of Computer Science,
1999.
[33] A. Yao. Protocols for Secure Computations.
Proceedings of the IEEE Symposium on Foundations
of Computer Science, 1982.