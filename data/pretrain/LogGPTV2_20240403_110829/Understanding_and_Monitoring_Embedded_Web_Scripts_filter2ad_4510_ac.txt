Analytics. Analytics scripts are typically transparent to the
site visitors and do not affect the functionality or visual out-
put of the embedding webpage. Their base policies include
a ﬁxed group of sensitive APIs such as setting and reading
document.cookie, but not any speciﬁc DOM accesses.
2In selecting the container sites, we excluded inappropriate sites includ-
ing those which the embedded scripts do not access anything, trivial sites
that have few subpages and content, sites with objectionable content (e.g.,
porn), and foreign language sites for which we were unable to register and
login. The full list is available at ScriptInspector.org/sites.
856856
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:03:40 UTC from IEEE Xplore.  Restrictions apply. 
Policy 1 Google Analytics Base Policy
/HTML[1]/BODY[1]:GetId; /HTML[1]/BODY[1]:ClientHeight;
/HTML[1]/BODY[1]:ClientWidth; /HTML[1]:ClientHeight;
/HTML[1]:ClientWidth;
navigator.javaEnabled, navigator.language,
navigator.plugins; navigator.cookieEnabled;
navigator.userAgent; screen.height; screen.width;
screen.colorDepth
GetCookie; SetCookie
NetworkSend:doubleclick.net; NetworkSend:google.com;
NetworkSend:google−analytics.com
/HTML[1]/HEAD[1]>InsertBefore:\[o\]
As the most frequently embedded script by far, Google
Analytics exhibits a very stable behavior pattern described
by Policy 1. Other than the ﬁnal permission, all its accesses
can be categorized into three categories: 1) Generic DOM
access: reading the size of the body element; 2) special
property access: testing the browser’s conﬁguration, read-
ing and writing cookies; and 3) network access: sending
information back to Google Analytics servers via setting the
src property of an image element. This reassures the site
owner that the Google analytics script is not accessing site-
speciﬁc information or making content changes to the site.
The ﬁnal permission is needed because the Google Analytics
script inserts dynamically-loaded scripts into the page. The
\[o\] limits the insertions to nodes owned by the script. The
parameter is a regular expression that speciﬁes the element
type inserted must be a script. Note that the network policies
still apply, restricting the domain hosting the dynamically-
loaded script. Also, recall that this same base policy still
applies to any scripts from the same domain due to our
access attribution implementation, so dynamically loading
scripts does not provide extra capabilities.
Another popular embedded script, Quantcast analytics,
exhibits similar behavior with the addition of reading the
content attribute of all meta elements. Common practice
suggests using these attributes to mark keywords for the
document, so Quantcast is likely collecting these keywords.
In sites that embed Chartbeat analytics, the src attributes
of all script elements on the page are read by Chartbeat,
along with href and rel attributes of link elements. This is
a somewhat surprising, yet common behavior that was also
observed for several other scripts. Chartbeat also maintains
a heartbeat message protocol with the backend server and
multiple request-response pairs are observed per session.
All the major analytics scripts appear to have sufﬁciently
limited behaviors that containing sites will not need site-
speciﬁc policies. Base policies can cover all observed be-
haviors without including any permissions that allow access
to obviously sensitive resources and content-changing APIs.
Advertisements. Google offers the most widely used adver-
Policy 2 Google Adsense Base Policy Excerpt
(permissions similar to those in Policy 1 are omitted)
//: GetAttribute:data−ad−container;
// DIV[@id=‘div−gpt−ad−.∗’]:!
/HTML[1]/BODY[1]:document.write:
//: GetId
tising service through AdSense and DoubleClick. Policy 2 is
an excerpt of the policy for googleadservices.com, whose
behaviors are representative of most advertising scripts.
The AdSense script accesses several browser properties
similar to the analytics scripts, but also injects advertise-
ments into the page and often inserts a hidden empty frame
or tiny image pixel for bootstrapping or tracking purposes.
The tracking pixels are always injected into the body or
document element, and the last permission in Policy 2 allows
such behavior.
The node where the actual advertisements are injected,
however, varies from site to site. As a result,
the base
policy only covers the most popular use, described by the
// DIV[@id=‘div−gpt−ad−.∗’]:! permission. This allows any
APIs to be called on a node whose id starts with div-
gpt-ad-, except those that may modify attribute names in
node descriptors of itself and any other permissions that
belong to the same script. Behaviors of other ways of
integrating AdSense need to be covered by site-speciﬁc
policies (Section 7).
Scripts from moatads.com, rubiconproject.com, adroll.
com and adnxs.com all exhibit similar behaviors to Google
advertising scripts. In addition, the moatads.com scripts
occasionally read the src attribute of all script and img
elements. This behavior is dangerous and could result in
information leakage. Since it is observed on many containing
sites, however, we add it to the base policy despite the
fact that it may only happen once in many visits. Scripts
from betrad.com also access localStorage APIs, presum-
ably adding an extra tracking approach should the user reject
or delete their cookie.
Compared to analytics scripts,
the advertising scripts
exhibit behaviors that vary substantially across sites. Hence,
additional site-speciﬁc permissions are often necessary to
accurately describe their behavior. The base policies for
ad scripts also include more permissions, such as reading
attributes of all nodes with a certain tag name and appending
ad contents and tracking pixels to the body element.
Social widgets. Social widget scripts behave similarly to
advertising scripts. As an example, Policy 3 shows the base
policy for twitter.com scripts which includes permissions
for getting and setting twitter-speciﬁc attributes, accessing
content size, injecting content, and replacing placeholders
of the page. As we see in Section 7, social widget scripts
often require site-speciﬁc policies.
857857
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:03:40 UTC from IEEE Xplore.  Restrictions apply. 
Policy 3 Twitter Base Policy Excerpt
//: GetAttribute:data−.∗;
//: ReplaceChild:[o]
//: SetAttribute :data−twttr−.∗;
sub:ˆ//A[@class=‘twitter−share−button’]:GetAttribute:height
Web development. Finally, we consider web development
scripts such as web A/B testing scripts from optimizely.com
and the jQuery library hosted on googleapis.com. Due to
their broad purpose, the behavior of these scripts differs
signiﬁcantly from those in the previous three categories.
For example, the optimizely.com script modiﬁes all “com-
ment” buttons on guardian.com, inserts a style element on
magento.com, but did not access any part of the DOM on
techcrunch.com. What these scripts do is depends a great
deal on how the site owners use them.
Effective base policies cannot be developed for these
scripts — their behavior varies too much across sites and
even across requests on the same site. Web developers using
these scripts would need to develop a custom policy for
them, based on understanding what the script should do
given their intended use.
7 DEVELOPING SITE-SPECIFIC POLICIES
Site-speciﬁc policies are needed for scripts that require
different permissions depending on how they are embedded.
To aid site administrators in developing appropriate site-
speciﬁc policies, we developed the PolicyGenerator tool to
partially automate the process. The PolicyGenerator gener-
ates permission candidates based on violations to existing
policies reported by ScriptInspector. The site administrator
can use Visualizer to examine the candidate permissions
and either select appropriate permissions to include in the
script’s policy or decide not to embed the script if it requires
excessive access. Section 7.1 introduces the PolicyGenerator
tool and Section 7.2 reports on our experience using it.
7.1 PolicyGenerator
With the base policies in place,
the site-speciﬁc per-
missions typically need to allow access to speciﬁc DOM
elements such as placeholders for advertisements. Our key
observation behind the PolicyGenerator is that although
absolute properties of these nodes vary across different pages
and requests, good selector patterns can often be found
that hold site-wide, due to consistencies within the web
application design. For example, the DOM representations
of the access nodes often have some common property such
as sharing a class which other elements on the same page
do not have.
For example, consider these two CSS selectorsdescribing
advertisements observed on two requests to mtv.com:
div#adPos300x250
div#adPos728x90
These ad containers have different ids, but their id always
starts with the string ‘adPos’, followed by a pair of height
and width parameters. Patterns like these are straightforward
for site administrators to understand and can be inferred
automatically from access reports.
To use PolicyGenerator, the user starts ScriptInspector
with the PolicyGenerator extension. ScriptInspector is con-
ﬁgured to load base policies from a ﬁle to provide the initial
base policy for the scripts. The user visits the page of inter-
est, and then clicks on the PolicyGenerator extension button
to start the process. PolicyGenerator generates permission
candidates, which are presented to the user using Visualizer.
The user can then select permissions to add to the site-
speciﬁc policy for the script. The user can continue visiting
additional pages from the site, invoking PolicyGenerator,
and reﬁning policies based on automated suggestions.
When the user invokes PolicyGenerator, it obtains a list
of violating records from the instrumented DOM by calling
document.checkPolicy. It initially generates a set of simple
tag permission candidates which match DOM accesses only
by their node name, API name, and arguments, but not by
attribute-value pairs. This searches for simple permissions
like // DIV:getID. These candidates are selected by counting
the number of accesses to each node name and comparing
it to the total number of occurrences of that tag in the
document. If the ratio reaches a threshold (customizable
by the user;
is 25% which we have found
works well), a tag permission is proposed for that API call.
Accesses that match this permission are removed from the
set of violating accesses for the next phase.
the default
Finding good permission candidates that involve complex
DOM selectors is more challenging, but important to do well
since these are the permissions that would be hardest for a
site administrator to derive without assistance. In Section 5,
we observed that most accesses by a third-party script can
be divided into two categories: those that happen on “nodes
of interest”, and those that can be covered by adding root,
parent or sub preﬁx to the nodes of interest. The node of
interest often has content modiﬁcation APIs called upon
them (e.g., appendChild, setInnerHTML), or is the deepest
node accessed along the same path with other accessed
nodes. For example, the ﬁrst node listed in Listing 1 would
be a node of interest because it’s the deepest node accessed.
Following this observation, the next step is for Policy-
Generator to develop a set of selector patterns using at-
tribute names for all nodes of interest, excluding those that
could interfere with current permissions (as described in
Section 2.3). Then, it produces an attribute-value pair pattern
candidates for each node of interest. Our implementation
uses heuristics to synthesize four types of patterns for each
attribute name candidate: matches exactly, matches all, starts
with, and ends with. For the latter two pattern types the gen-
858858
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:03:40 UTC from IEEE Xplore.  Restrictions apply. 
erator calculates the strictest restriction without sacriﬁcing
the number of accesses it matches, and then selects the best
pattern type that matches the most violations out of the four.
After a best pattern and pattern type has been determined
for each attribute name, the generator sorts them by the
number of matched violations of each attribute name’s best
pattern, but excludes those which also accidentally match
any untouched nodes.
We provide an option to allow the generator to accept
a pattern if it matches some untouched nodes below a
threshold ratio. An example of where this is useful occurs
with advertising scripts that do not ﬁll not all advertisement
spaces in one response, but instead leaves some untouched
for later use. The decision regarding whether to accept over-
matched patterns is left to the developer, but it is important
that such patterns are clearly presented by Visualizer.
The best qualifying permission is then added to the set
of permission candidates that will be presented to the user,
and all accesses matching that permission are removed. The
process repeats until there are no nodes of interest left.
If any violating accesses remain after all nodes of interest
have been removed, PolicyGenerator examines if the remain-
ing unmatched violations involve either a parent, ancestor,
or descendent of any node of interest. If so, a corresponding
parent, root, or sub permission is proposed.
It is ultimately up to the developer’s discretion to accept,
reject, or tweak the generated permissions. To ease this pro-
cess, the policy candidates can be viewed using Visualizer.
The presentation is similar to what is described in Section 4,
and developers may click on individual permissions to view
the nodes they cover.
In the next section, we see that although the initial guessed
permissions are not always perfect, only minor tweaks are
needed to reach effective site-speciﬁc policies for most
scripts and sites. This manual approval process is important
for developing good policies, but also valuable since our
goal is not to produce policies that completely describe
the behaviors of all scripts on the site, but to help site
administrators identify scripts that are exhibiting undesirable
behaviors on their site.
7.2 Adjusting permission candidates
We want to understand how much work is required to
develop effective site-speciﬁc policies for a typical website
using our tools, assuming base policies are provided for
all scripts on the site. In this section, we describe manual
efforts involved in using PolicyGenerator on typical sites and
show some examples of site-speciﬁc policies. We defer the
discussion of quantitative results to Section 8.
To evaluate the PolicyGenerator from a site administra-
tor’s point of view, we ﬁrst set up a crawler robot that visits
a new set of 100 test sites using ScriptInspector. The goal
of the robot is to simulate regular users’ browsing actions
to explore site-speciﬁc behavior of embedded scripts. Given
the URL of a test site, the robot ﬁrst visits that URL using
the ScriptInspector, and waits for 30 seconds after the page
has ﬁnished loading (or times out after 60 seconds). Then,
it navigates to a randomly selected link on the page whose
target has the same domain as the test site. We chose not
to navigate the robot away from each page right after it
completes loading because certain third-party scripts may
not start to execute after the page has loaded. Upon page
unloading, the robot calls document.checkPolicy to log the
violating traces.
The robot repeats the navigation until it has successfully
navigated ﬁve times for that test site, before moving on to
the next. If the robot cannot ﬁnd a link on the current page
(or if the browser crashes), it goes back to the homepage
and resumes from there. The scan explores each site ﬁve
levels deep to simulate user browsing behavior. Finally, after
the robot successfully navigated 5 times for all 100 sites, it
restarts the whole process from the ﬁrst site.
Whenever ScriptInspector outputs a violation to existing
policies on a site, further visits to that site are postponed until
we manually examine the violation using PolicyGenerator
and add necessary permissions to the policy. This is to
prevent similar violations being recorded multiple times.
We ran the evaluation from 28 December 2014 to 6 Febru-
ary 2015, a total of 40 days. For each site, the experiment
contains two stages: an initial stage to train a reasonably
stable model, and a testing stage to estimate how many
violations would be reported if the policy were deployed.
We initially deﬁne the training phase to last until after
ScriptInspector completes 100 requests to that site without
recording a single alarm (we show how this threshold can
be tuned in Section 8.2).
Permission adjustment examples. Depending on the com-
plexity of the site, generating and tweaking the policy for
one site may take from a few minutes up to half an hour
based on our experience. The cost varies due to factors such
as the number and complexity of scripts the site embeds, and
how much pages differ across the site (for example, in where
they place advertisements). The results here are based on the
ﬁrst author’s experience, who, as creator of PolicyGenerator
and Visualizer, is intimately familiar with their operation. A
developer using PolicyGenerator for the ﬁrst time will need
more time to become familiar with the tool, but we expect
the tool would not be difﬁcult for a fairly experienced web
developer to learn to use.
We evaluate the effort required for each manual permis-
sion by considering three of the most common ways auto-
generated permissions needed to be manually changed. The
ﬁrst example, taken from mtv.com’s policy for doubleclick.
net, is a result of auto-generated permission over-ﬁtting the
accesses on this particular request:
// DIV[@id=‘adPos300x250’]
It includes overly-speciﬁc size properties, and was ﬁxed by
859859
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:03:40 UTC from IEEE Xplore.  Restrictions apply. 
manually replacing them with a regular expression pattern:
// DIV[@id=‘adPos\d∗x\d∗’]
The other way to relax over-ﬁtting permissions is to
increase the matching threshold PolicyGenerator uses to
eliminate permissions. This threshold controls the number of
nodes that may be matched by a generated node descriptor
but are not accessed by the third-party script. Adjusting this
threshold is often enough to eliminate further manual effort.
For example, these are the three permission candidates
proposed for foxnews.com by PolicyGenerator, with match-
ing threshold set to default value 1 which does not allow any
additional node matches:
// DIV[@id=‘trending−292x30’]
// DIV[@id=‘board1−970x66’]
// DIV[@id=‘frame2−300x100’]
// DIV[@id=‘stocksearch−292x30’]
The PolicyGenerator did not yield the more elegant and
representative permission,