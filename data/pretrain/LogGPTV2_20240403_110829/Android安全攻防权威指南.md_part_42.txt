## Page 188
172
第7章调试与分析安全漏润
国心
图 7-6 Android Device Monitor ( ro , debuggable=1 )
除了显示所有进程，图7-6也显示了system_server进程的线程。如果不使用工程设备或进行
本节所列的步骤，就不可能做到这一点。完成这些步骤后，就可以使用DDMS、AndroidDevice
Monitor，甚至是Eclipse来调试系统上的任何Dalvik进程了。
注意Pau Oliva的RootAdb应用自动执行本节所列的步骤。可以在Google Play上找到该应用：
https:/play.google.com/store/apps/details?id=org.eslack.rootadb。
2.附加到其他进程
除了基本的分析和调试，处于完全调试模式下的设备也支持实时调试任何Dalvk进程。通
过附加到进程来调试也是一个渐进的简单过程。
在Eclipse启动并运行的状态下，使用右上角的界面选择器转至DDMS 界面。在Devices窗
口中选择期望的目标进程，例如 system_process。在Run菜单中选择Debug Configurations 打开
Debug Configurations 对话框。在对话框左边列表中选择 Remote Java Application 并点击 New
LaunchConfiguration 按钮。在Name 输入框中输人任意名称，例如 Attacher。在Conncct选项卡
选择7.5.2节创建的AOSPFramework Source项目。在Host输入框中输人127.0.0.1.在Port输
人框中输人8700。
---
## Page 189
7.6调试原生代码
173
注意8700端口对应DDMS界面中当前选中的任何一个进程。每个可调试进程都被赋予了唯一
的端口号。正如我们的预料，使用特定于进程的端口生成了一个特定于该进程的调试配
置文件。
最后，点击Apply按钮，然后点击Debug按钮
此时，Eclipse 已经附加到了 system_process 进程上。转到 Debug 界面会在 Debug 窗口中显示
该进程的活动线程。点击Suspend按钮将会停止已选线程。图7-7描述了Eclipse已经附加至
system_process 进程上，并挂起了WifiManager服务线程。
gA
图 7-7Eelipse 已附加至 system_process 进程
与之前相同，点击线程的栈帧将会引导至源代码的相关位置。下面唯一要做的，就是利用
Eclipse调试器的断点和其它功能来跟踪bug或探索系统内部工作原理。
7.6调试原生代码
在 Android平台上开发原生代码（NativeCode）所用的 C 和 C++编程语言缺乏Dalvik 提供的
内存安全特性。由于面临更多的潜在陷阱，更可能发生错误和崩溃。这样的bug很严重，因为存
在被攻击者利用的潜在风险。因此，无论对攻击者还是防御者来说，发现问题的根源都是最为
重要的。无论是哪种情况，使用交互式调试来分析存在漏润的程序都是得到期望结果最为常见
的途径。
本节讨论调试Android原生代码的各种方法。第一，使用Android原生开发工具包（NDK）
---
## Page 190
174第7章调试与分析安全漏洞
来调试编译在应用内部的自定义原生代码；第二，使用Eclipse调试原生代码；第三，使用AOSP
在Nexus设备上调试Android浏览器：第四，使用AOSP实现完全源代码级别的交互式调试。第
五，调试运行在非Nexus设备上的原生代码。
7.6.1使用NDK进行调试
Android支持通过NDK开发自定义的原生代码。从4b版本开始，NDK包含了一个易用的
ndk-gdb脚本。该脚本的出现意味着官方开始支持对应用中原生代码的调试了。本节介绍调试原
生代码的要求，详细描述了准备过程及其内部工作原理，并讨论了该脚本的局限性。
警告Android4.3版本的Over-the-Air（OTA）更新引入了NDK调试的不景容问题。可以在
Android bug跟踪系统的问题58373中找到更多参考信息，包括解决方法。Android4.4修
复了此问题。
1.准备用于调试的应用
要了解NDK的调试支持，需要一台运行Android2.2或以上版本的设备或模拟器。若要调试
多线程原生代码，则需要使用Android2.3或以上版本。不幸的是，Android上的几乎所有代码都
是多线程的，而运行如此旧Android版本的设备正在逐渐减少。最后，在准备阶段必须创建可以
用于调试的目标应用。
准备目标应用的方法因使用的生成系统面异。通过设置NDK_DEBUG环境变量为1，就能开
启使用NDK的原生代码调试（通过ndk-build）。如果使用Eclipse，就需要修改工程属性，这
将在下节讨论。也可以使用ApacheAnt生成系统，通过antdebug命令来生成支持调试的应用。
不论使用哪个生成系统，对成功调试原生代码来说，在生成阶段开启调试都是必要的。
注意使用本节讨论的脚本时，环境变量路径中需要包含NDK目录。
2.实践所见
为了演示使用NDK调试原生代码的整个过程，对“HelloWorld”应用稍微进行修改。使用
一个Java原生接口（JNI）方法将一个字符串返回给应用，面不是显示字符串。本章的资料包中
有演示应用的代码。以下片段展示了使用NDK生成应用的命令。
GdbServer
: [arm-1inux-androideabi-4 .6] 1ibs/armeabi/gdbserver
Compile thumb: he1lo-jni 1ibs/armeabi/libhello-jni.so
Dev:NativeTest$
通过以上输出结果可以明显看出，设置NDK_DEBUG环境变量后，ndk-build脚本会做额外的
---
## Page 191
7.6调试原生代码
175
事情。首先，该脚本向应用包中添加了一个gdbserver二进制文件。这是必要的，因为设备一般
没有安装GDB服务器。此外，使用与GDB客户端匹配的gdbserver可以最大程度地保证调试的
兼容性和可靠性。其次，ndk-build创建了一个gdb.setup文件。查看该文件内容，可以看出该文
件是为GDB客户端自动生成的短脚本。该脚本协助配置GDB，使其能够找到本地库文件副本，
包括JNI和源代码。
在这种生成方法中，生成原生代码与生成应用包是互不相干的。要完成剩余的操作，可以使
用Apache Ant。使用Apache Amt的 ant debug instal1 命令可以一步完成应用包的生成和安
装。以下片段展示了这个过程。简洁起见，许多输出结果已被省略。
Bui1df11e: /androld/vs/1/NativeTest/bui1d. xm1
dev:NativeTest $ ant debug insta11
[..-]
install:
[echo] Insta11ing /android/ws/1/Native/Test/bin/MainActivity-debug -apk
onto
default emulator or device.
[exee] pkg: /data/1ocal/tmp/MainActivity-debug-apk
[exec] 759 KB/s (393632 byte8 in 0.5068)
[exec]  Success
BUILD SUCCESSFUL
Total time: 16 seconds
应用包安装完成后，就可以开始调试该应用了。
7
无参数执行ndk-gdb脚本时，脚本会尝试寻找目标应用的一个运行示例。如果没有找到，就
会打印错误信息。有多种方法可以解决这个问题，但是所有方法（只有一个除外）都需要手动启
动该应用。最方便的方法是为ndk-gdb脚本提供--Start参数，如以下片段所示。
dev:NativeTest $ ndk-gdb --start
Set uncaught Java .lang.Throwable
Initializing jdb ...
Set deferred uncaught Java.lang.Throwable
> Input strean elosed.
GNU gdb (GDB) 7.3 .1gg2
Copyright (C) 2011 Free Software Foundation, Inc.
warning: Could not load shared 1ibrary symbols for 82 libraries, e.g.
[..-]
Use the *info sharedlibrary* command to see the complete listing.
1ibstdc++.80.
warning: Breakpoint addres8 adjusted from 0x40179b79 to 0x40179b78.
0x401bb564in futex_sysca113 () from
/android/ws/1/NativeTest/obj/1oca1/armeabi /1ibe , 80
(gdb) break Java_com_example_nativetest_MainActivity_stringFromJNI
Function *Java_com_example_nativetest_MainActivity_stringFromJNI* not
Make breakpoint pending on future shared library load? (y or [n]) y
defined.
Breakpoint 1 (Java_com_example_nativetest_MainActivity_stringFromJNI)
---
## Page 192
176第7章调试与分析安全漏润
Burpued
100s(qp6)
Continuing
使用这种方法的最大优势是能够较早地在原生代码执行路径中设置断点。然面，这个功能在
Android4.2.2和4.3版本上使用NDKr9时会遇到问题。确划地说，应用并没有启动，面是不断
显示等待润试器的对话框。幸运的是，有一个简单的解决办法。原生GDB客户端启动后，手动
运行Java调试器并将其连接至默认端点即可，如下所示：
dev:- $ jdb -connect con.sun.jdi.SoeketAttach:ho8tname=127.0.0.1,port=65534
Set uncaught java.lang.Throwable
Set deferred uncaught Java.1ang.Throwable
Initializing jdb ...
可以通过挂起脚本进程运行此命令，也可以在另一个窗口中运行。JDB连接成功后，应用开
始运行，上个片段中设置的断点就会被触发。
(env=0x40168d90, thiz=0x7af0001d) at jni/he11o-jni-c:31
Breakpoint 1, Java_com_example_nativetest_MainActivity_stringFromJNI
31
_android_1og_print (ANDRoID_toG_ERROR, *NativeTest* , *INSIDB
JNI1*) :
(gdb)
使用这种解决办法，可以方便地在程序较早运行的位置设置断点。即使手动启动应用，通常
也可能会因为旋转设备方向面导致应用重新执行onCreate事件处理程序。这样也有助于设置一
些难以捉摸的断点。
注意编写这本书时，我们贡献了一个简单的补丁来修复此问题：https://code.google.com/p/android/
issues/detail?id60685#c4。
NDK的较新版本包含了ndk-gdb-py脚本，它与ndk-gdb类似，是用 Python语言编写的（非
shell脚本）。虽然该脚本不会遇到不断等待调试器的问题，但是也有其自身的问题。具体来说，
如果应用以较旧的AndroidSDK版本作为调试目标，就会遇到问题。其实，只需简单地修改一行
就可修复该问题；这种修改方法原本用于修复之前的一个bug。希望这些问题能够随着时间的推
移得到解决，NDK的调试功能可以变得更加健壮可用。
3.内在原理探究
顺利躲过问题雷区后，就可以调试原生代码了。但是在运行ndk-build 脚本时到底发生了什
么？使用--verbose参数运行脚本会闸明这个问题。查看NDK位于docs/NDK-GDB.html的官
方文档也有助于解释这个问题。该shell脚本有750行左右，阅读起来并不困难。最相关的部分
在脚本的最后40行左右。以下片段展示了Linuxx86_64平台AndroidNDKr9的部分代码：
708 # Get the app_server binary from the device
ooddvs qiedenaeu,sseddde/urq/es/s/ Tnd puoge unx0,
709APP_PROCESS=$AFP_OUT/app_process
---
## Page 193
7.6调试原生代码
177
711 1og *Pulled app_proces8 from device/emulator.*
713
712
run adb_cmd pu11 /system/bin/1inker *native_path SAPP_oUr/1inker
714
1og *Pu1led 1inker from device/emulator,*
STL
7171og *Pulled 1ibc.so from device/emulator.*
716
run adb_cmd pu11 /8ystem/1ib/1ibc.so *native_path $APP_0Ur/1ibc,so*
位于第710、713和716行的命令从设备上下载了三个关键文件：app_process、linker和libc.so
二进制文件。这些文件包含关键信息和一些有限的符号，虽然没有包含足够的信息来支持源代码
级的调试，但是7.6.5节会进行介绍。如果没有这些下载的文件，GDB客户端调试目标进程时将
会遇到麻烦，尤其是处理线程时。得到这些文件后，该脚本会尝试启动JDB以解决前面的“等
待调试器”问题。最后，该脚本启动GDB客户端，如下所示：
730 + Now launch the appropriate gdb client with tbe right init commands
732 GDBCLIENT=$ (TOOLCHAIN_PREFIX) gdb
TC4
733
734