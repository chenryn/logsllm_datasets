Achieving Adaptive Security
In this section, we prove that MIFE from Figure 4.6 is many-AD-IND-static under Dk(p)-
MDDH assumption in G1 and G2. That is, our scheme is secure with many challenge cipher-
texts, chosen adaptively by the adversary, and handles static corruptions of input slots (see
Deﬁnition 23).
Security. The security proof proceeds in two steps, similarly than the many-SEL-IND se-
curity proof in Section 4.1. First, we show in Theorem 11 that the MIFE in Figure 4.6 is
one-AD-IND-static secure, that is, it is adaptively secure when there is only a single challenge
ciphertext, and handles static corruption of input slots.
Then, using Theorem 10 (many-yy-IND security of FE & one-yy-IND security of MIFE ⇒
many-yy-IND of MIFE) together with Theorem 11 (one-AD-IND security of MIFE) and the
many-AD-IND security of the underlying FE (proven in Theorem 4), we obtain many-AD-IND
security of MIFE (Corollary 3)
Theorem 11: one-AD-IND-static security of MIFE
Suppose the Dk(p)-MDDH assumption holds in G1 and G2. Then, the multi-input FE in
Figure 4.6 is one-AD-IND-static secure.
That is, we show that our multi-input FE is adaptively secure when there is only a single
challenge ciphertext.
Corollary 3: many-AD-IND-static security of MIFE
Suppose the Dk(p)-MDDH assumption holds in G1 and G2. Then, the multi-input FE in
Figure 4.6 is many-AD-IND-static secure.
G1,β Asi + u Wici + xβ
Asi + u Wici + xβ
i
G2,β
i Vici + zi
G3,β
Asi + u Wici + xβ
i
Vici
Vici
G⋆
3,β
Asi + u Wici + xβ
i
Vici
W⊤
i yi + V⊤
i r
i r − a⊥hzi, ri
i yi + V⊤
i yi + V⊤
i yi + V⊤
i yi + V⊤
W⊤
i yi + V⊤
If i ∈ HS: W⊤
If i ∈ CS: W⊤
If i ∈ HS: W⊤
If i ∈ CS: W⊤
i r − a⊥ezi
i r − a⊥hzi, ri Pi∈CShzi, ri +Pi∈HSezi
i r − a⊥ezi
i r − a⊥hzi, ri Pi∈CShzi, ri +Pi∈HSezi
hz1 + . . . + zn, ri
hz1 + . . . + zn, ri
hz1 + . . . + zn, ri
one-AD-IND-static
security game
Dk-MDDH in G1
inf. theoretic
Dk-MDDH in G2
Deﬁnition 23
Lemma 33
Lemma 34
Lemma 35
selective variant
Lemma 36
Game
ci
c′
i
c′′
i
di:
z:
justiﬁcation/remark
reference
G0,β
Asi
Wici + xβ
i Vici + zi
W⊤
i yi + V⊤
i r
Figure 4.7: Sequence of games for the proof of Theorem 11. Here, for any slot i ∈ [n], ([−ci]1, [c′
[di]2 and [z]T are part of the sky1,k···kyn computed by OKeygen(y1k···kyn). We use u ←R Zk+1
To analyze the games G3,β, we consider the selective variant of these games: G⋆
identically distributed. Using a guessing argument, we prove the same holds for the adaptive games G3,0 and G3,1.
i]1, [c′′
\ Span(A) and a⊥ ←R Zk+1
q
q
3,β. We prove using an information-theoretic argument that G⋆
i ]1) is the challenge ciphertext computed by Enc(i, x0
i );
such that A⊤a⊥ = 0 and u⊤a⊥ = 1.
3,1 are
3,0 and G⋆
i , x1
9
4
C
h
a
p
t
e
r
4
.
M
u
l
t
i
-
I
n
p
u
t
I
n
n
e
r
-
P
r
o
d
u
c
t
F
u
n
c
t
i
o
n
a
l
E
n
c
r
y
p
t
i
o
n
f
r
o
m
P
a
i
r
i
n
g
s
4.2 Achieving Adaptive Security
95
Games G0,β, G1,β, G2,β, G3,β, G⋆
3,β :
p
n
n
)
), {xb
i}i∈HS ← A(1λ, F m,X,Y
CS ⊆ [n] ← A(1λ, F m,X,Y
PG ← PGGen(1λ), A ←R Dk(p), pk := (PG, [A]1)
\ Span(A), a⊥ ←R Zk+1
s.t. A⊤a⊥ = 0 and u⊤a⊥ = 1
u ←R Zk+1
For all i ∈ [n]: Wi ←R Zm×(k+1)
, Vi ←R Zk×(k+1)
, zi ←R Zk
For all i ∈ HS, cti := OEnc(i, (x0
i ))
i , x1
α ← AOKeygen(·),OEnc(·,·)(cid:16)pk, {cti}i∈HS ,{eki}i∈CS(cid:17)
Output α.
p
p
p
p, eki := (zi, [WiA]1, [ViA]1),
G0,β, G1,β, G2,β,G3,β, G⋆
3,β
G0,β,G1,β, G2,β, G3,β,G⋆
3,β
OEnc(i, (x0
i , x1
i )):
p; ci := Asi + u , c′
i := Wici + xβ
i
If i ∈ HS, return ⊥. si ←R Zk
i := Vici + zi; c′′
i := Vici .
c′′
Return
−ci
c′
i
c′′
i
p; ∀i ∈ HS :ezi ←R Zp
i yi + V⊤
OKeygen(y1k···kyn):
r ←R Zk
∀i ∈ [n] : di := W⊤
∀i ∈ HS : di := W⊤
z := hz1 + . . . + zn, ri; z :=Pi∈HSezi +Pi∈CShzi, ri
Return(cid:0){[di]2,}i∈[n], [r]2, [z]T(cid:1)
i r − a⊥ezi
i r − a⊥hzi, ri
i yi + V⊤
Figure 4.8: Games for the proof of Theorem 11. In each procedure, the components inside a solid
(dotted, gray) frame are only present in the games marked by a solid (dotted, gray) frame. Here, CS
denotes the set of corrupted slots, and HS := [n] \ CS is the set of honest input slots. The oracle OEnc
can be queried at most once per input slot.
Proof of Theorem 11. Using Theorem 2, it is suﬃcient to prove one-AD-IND-zero-static (i.e.
the scheme is secure when no decryption keys are queried), and one-AD-IND-weak-static i.e. we
assume the adversary requests a challenge ciphertext for all slots i ∈ HS, where HS := [n]\CS
denotes the set of slots that are not corrupted) to obtain one-AD-IND-static security.
The one-AD-IND-zero-static security of MIFE follows directly from the one-AD-IND se-
curity for n instance of the underlying FE (recall that the construction from Figure 4.6 is
simply the implementation of the generic construction from Figure 4.1, with the concrete FE
from Section 2.6.1, which is one-AD-IND secure for n instance). In what follows, we prove
one-AD-IND-weak-static security of MIFE.
We proceed via a series of games described in Figure 4.8. The transitions are summarized
in Figure 4.7. Let A be a PPT adversary, and λ ∈ N be the security parameter. For game G,
we deﬁne AdvG(A) to be the probability that the game G outputs 1 when interacting with A.
Games G0,β, for β ∈ {0, 1}: are such that
Advone-AD-IND-static
MIFE,A
(λ) = |AdvG0,0 − AdvG0,1|,
according to Deﬁnition 23.
96
Chapter 4. Multi-Input Inner-Product Functional Encryption from Pairings
Games G1,β, for β ∈ {0, 1}: we change the distribution of the vectors [ci]1 computed by
OEnc(i,·,·), for all queried i ∈ [n], using the Dk(p)-MDDH assumption. Namely, in Lemma 33,
we prove that there exists a PPT adversary B1,β such that:
AdvG0,β (A) − AdvG1,β (A) ≤ AdvDk(p)-mddh
G1,B1,β
(λ) +
1
p
.
Games G2,β, for β ∈ {0, 1}: here, for all slots i ∈ [n], we change the way the vectors [c′′
i ]1 and
[di]2 are computed, respectively, by OEnc(i,·,·) and OKeygen, using an information theoretic
argument. The point is to make it possible to simulate the G2 only knowing [zi]2 (and not
[zi]1), which will be useful later, to use the Uk(p)-MDDH assumption on [zi]2, in G2. Namely,
we show in Lemma 34 that
AdvG1,β (A) = AdvG2,β (A).
Games G3,β, for β ∈ {0, 1}: we use the Dk(p)-MDDH assumption to switch simultaneously
for all i ∈ HS the values [hzi, ri]2 computed by OKeygen, to uniformly random values over G2.
Recall that HS ⊆ [n] denotes the set of honest (that is, non corrupted) input slots. This relies
on the fact that it is not necessary to know [zi]1 for i ∈ HS to simulate the games G2,β or G3,β.
Namely, in Lemma 35, we show that there exists a PPT adversary B3,β such that:
AdvG2,β (A) − AdvG3,β (A) ≤ AdvUk-mddh
G2,B3,β
(λ) +
1
p − 1
.
At this point, we show that AdvG3,0(A) = AdvG3,1(A) in three steps. First, we consider the
selective variant of game G3,β, called G⋆
3,β, where the adversary must commit to its challenge
(x0
i , x1
i )i∈HS before receiving pk or making any decryption key queries, where HS ⊆ [n] de-
notes the set of input slots which are not corrupted. Further encryption queries can be made
adaptively for slots i ∈ CS. By a guessing argument, we show in Lemma 36 that there exists
PPT adversary A⋆ such that
AdvG3,β (A) = (X + 1)2hm · AdvG⋆
3,β
(A⋆),