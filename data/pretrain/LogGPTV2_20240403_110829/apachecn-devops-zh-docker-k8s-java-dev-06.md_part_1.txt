# 六、使用 Java 应用运行容器
在[第 5 章](05.html)、*用 Java 应用创建映像*中，我们了解了 Dockerfile 的结构以及如何构建映像。此时，您应该能够创建自己的 Docker 映像并开始使用它。实际上，我们确实运行了几次容器，但没有深入了解细节。我们使用 Dockerfile 手动构建映像，然后发出`docker build`命令。我们也一直在使用 Maven 来自动化构建过程。我们创建的映像包含我们简单的 REST Java 服务。我们已经运行了它，目的是检查它是否真的有效。然而，这一次，我们将从我们的映像中了解更多关于运行容器的细节。本章将包括以下概念:
*   启动和停止容器
*   容器运行模式
*   监控容器
*   容器重启策略
*   资源的运行时约束
*   使用 Maven 运行容器
# 启动和停止容器
让我们返回一点，从基础开始:如何从 shell 或命令行手动运行和停止 Docker 容器。
# 开始
正如您在前面章节中看到的，要从映像中旋转容器，我们使用`docker run`命令。运行中的容器将有自己的文件系统、网络栈和独立于主机的独立进程树。从[第 5 章](05.html)、*用 Java 应用创建映像*中，您会记得，每个单独的`docker run`命令都会创建一个新的容器，并执行 Dockerfile、`CMD`或`ENTRYPOINT`中指定的命令。
`docker run`命令的语法如下:
```
$ docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...]
```
该命令采用映像名称，可选`TAG`或`DIGEST`。如果您跳过`TAG`和`DIGEST`命令参数，Docker 将根据标记为`latest`的映像运行容器。`docker run`命令还采用了一组您可能会发现有用的可能选项，例如运行时模式、分离或前台、网络设置或对 CPU 和内存的运行时限制。我们将在本章后面讨论这些内容。当然，您可以执行`docker run`命令，除了映像名称之外，几乎没有任何参数。它将运行并采用映像中定义的默认选项。指定选项使您有机会覆盖映像作者指定的选项以及 Docker 引擎的运行时默认值。
`COMMAND`参数不是强制的，映像的作者可能已经使用`Dockerfile`中的`CMD`指令提供了默认的`COMMAND`。`CMD`在一个文件中只出现一次，通常是最后一条指令。从映像启动容器时，我们可以忽略`CMD`指令，只需提供我们自己的命令或参数作为`docker run`的`COMMAND`参数。出现在`docker run`命令中映像名称之后的任何内容都将被传递给容器，并被视为`CMD`参数。如果映像还指定了`ENTRYPOINT`，则`CMD`或`COMMAND`将作为参数追加到`ENTRYPOINT`中。但是你猜怎么着，我们也可以使用`docker run`命令的`--entrypoint`选项来覆盖`ENTRYPOINT`。
# 填料
要停止一个或多个正在运行的 Docker 容器，我们使用`docker stop`命令。语法很简单:
```
$ docker stop [OPTIONS] CONTAINER [CONTAINER...]  
```
您可以指定一个或多个要停止的容器。`docker stop`的唯一选项是`-t` ( `--time`)，它允许我们指定在停止容器之前等待的时间。10 秒是默认值，这应该足以让容器优雅地停止。要以更残酷的方式停止容器，可以执行以下命令:
```
$ docker kill  CONTAINER [CONTAINER...]  
```
`docker stop`和`docker kill`有什么区别？它们都将停止运行容器。但是有一个重要的区别:
*   `docker stop`:容器内的主进程首先会收到一个`SIGTERM`，经过一段宽限期后会收到一个`SIGKILL`
*   `docker kill`:容器内的主要过程将被发送`SIGKILL`(默认)或选项`--signal`指定的任何信号
换句话说，`docker stop`试图通过发送标准 POSIX 信号`SIGTERM`来触发正常关闭，而`docker kill`只是残忍地终止了进程，因此关闭了容器。
# 列出正在运行的容器
要列出正在运行的容器，只需执行`docker ps`命令:
```
$ docker ps  
```
要包含 Docker 主机上的所有容器，请包含`-a`选项:
```
$ docker ps -a  
```
您也可以使用`-f`选项指定过滤器来过滤列表。过滤器需要以`key=value`格式提供。当前可用的过滤器包括:
*   `id`:按容器 id 过滤
*   `label`:按标签过滤
*   `name`:按容器名称过滤
*   `exited`:根据容器的退出代码进行过滤
*   `status`:按状态过滤，可创建、重启、运行、删除、暂停、退出或停止
*   `volume`:指定卷名或装入点时，将包括装入指定卷的容器
*   `network`:当用网络 id 或名称指定时，将包括连接到指定网络的容器
考虑以下示例，该示例将获取 Docker 主机上存在的所有容器，并通过运行状态将其过滤掉:
```
$ docker ps -a -f status=running
```
# 移除容器
要从主机中移除容器，我们使用`docker rm`命令。语法如下:
```
$ docker rm [OPTIONS] CONTAINER [CONTAINER...]  
```
您可以一次指定一个或多个容器。如果您多次运行短期前台进程，这些文件系统的大小可能会快速增长。对此有一个解决方案:告诉 Docker 自动清理容器，并在容器退出时移除文件系统，而不是手动清理。您可以通过添加`--rm`标志来实现这一点，这样容器数据将在流程完成后自动移除。
`--rm` flag will make Docker remove container after it has been shut down.
例如，使用`run`命令，如下例所示:
```
$ docker run --rm -it Ubuntu /bin/bash  
```
前面的命令告诉 Docker，如果容器关闭，就移除它。
启动 Docker 容器时，您可以决定是在默认模式下运行容器，还是在前台或后台运行容器，即所谓的分离模式。让我们解释一下区别是什么。
# 容器运行模式
Docker 有两种容器运行模式，前台和分离。让我们从默认的前景模式开始。
# 前景
在前台模式下，您用来执行`docker run`的控制台将附加到标准输入、输出和错误流。这是默认值；Docker 会将`STDIN`、`STDOUT`和`STDERR`流连接到您的 shell 控制台。如果需要，您可以更改此行为，并使用`-a`开关执行`docker run`命令。作为`-a`开关的参数，您可以使用要附加到控制台的流的名称。例如:
```
$ docker run -a stdin -a stdout -i -t centos /bin/bash  
```
前面的命令将把`stdin`和`stdout`流连接到您的控制台。
有用的`docker run`选项是`-i`或`--interactive`(用于保持`STDIN`流打开，即使未连接)和`-t`或`-tty`(用于连接`pseudo-tty`)开关，通常一起用作`-it`，您需要使用它们为容器中运行的过程分配一个`pseudo-tty`控制台。实际上，当我们运行 REST 服务时，我们在[第 5 章](05.html)、*中使用了这个选项。*
```
$ docker run -it rest-example  
```
简单来说，`-it`是用来组合在容器启动后将命令行附加到容器上的。这样，您就可以在 shell 控制台中看到正在运行的容器中发生了什么，并在需要时与容器进行交互。
# 分离的
您可以使用`-d`选项在分离模式下启动 Docker 容器。它与前景模式相反。容器在后台启动和运行，与守护程序或服务相同。让我们尝试在后台运行我们的 rest 示例，执行以下命令:
```
$ docker run -d -p 8080:8080 rest-example  
```
容器启动后，您将获得一个控件，并且可以使用 shell 或命令行来执行其他命令。Docker 将只输出容器 ID，如下图所示:
![](img/903fe770-8767-4655-863d-6edd63a820e7.png)
您可以使用容器标识在其他 docker 命令中引用容器，例如，如果您需要停止容器或附加到它。我们的服务在后台仍然有效:Spring Boot 应用在端口`8080`上监听`HTTP` `GET`或`POST`请求。请注意，以分离模式启动的容器在用于运行容器的根进程退出时停止。理解这一点很重要，即使您有一些进程在后台运行(从 Dockerfile 中的指令开始)，如果启动容器的命令完成，Docker 也会停止容器。在我们的例子中，Spring Boot 应用正在运行和监听，同时防止 Docker 关闭容器。要将容器从后台放回控制台的前台，您需要连接到它。
# 连接到运行的容器
要保持对分离容器的控制，请使用`docker attach`命令。`docker attach`的语法很简单:
```
$ docker attach [OPTIONS]   
```
在我们的例子中，这是容器启动时给我们的 ID:
```
$ docker attach 5687bd611f84b53716424fd826984f551251bc95f3db49715fc7211a6bb23840  
```
此时，如果有东西被打印出来，比如我们正在运行的 REST 服务的另一个日志行，您将在控制台上看到它。如您所见，如果您需要实时查看写入`stdout`流的内容，则`docker attach`命令可以派上用场。它将基本上*重新将*您的控制台连接到容器中运行的进程。换句话说，它会将`stdout`输入你的屏幕，并将`stdin`映射到你的键盘，让你输入命令并查看它们的输出。请注意，在连接容器的同时按下 *CTRL + C* 键盘顺序会杀死容器的运行过程，而不是从控制台上脱离。使用默认的 *CTRL+P* 和 *CTRL+Q* 键盘顺序来脱离进程。如果 *CTRL + P* 和 *CTRL + Q* 序列与您现有的键盘快捷键冲突，您可以通过为`docker attach`命令设置`--detach-keys`选项来提供自己的分离序列。如果您希望能够使用 *CTRL + C* 分离，您可以通过使用设置为`false`的`sig-proxy`参数告诉 Docker 不要将`sig-term`发送到容器中运行的进程:
```
$ docker attach --sig-proxy=false [container-name or ID]  
```
如果容器在后台运行，那么能够监控它的行为就好了。Docker 为此提供了一组特性。让我们看看如何监控正在运行的容器。
# 监控容器
有一些监视正在运行的 Docker 容器的方法。它可以查看日志文件，查看容器事件和统计信息，还可以检查容器属性。让我们从 Docker 拥有的强大日志功能开始。对日志条目的访问是至关重要的，尤其是当您的容器在分离运行时模式下运行时。让我们看看 Docker 在日志机制方面能提供什么。
# 查看日志
大多数应用将其日志条目输出到标准的`stdout`流。如果容器在前台模式下运行，您将在控制台中看到它。但是，在分离模式下运行容器时，您在控制台上只会看到容器标识。然而，Docker 引擎将运行容器的所有`stdout`输出收集到主机上的历史文件中。您可以使用`docker logs`命令显示。该命令的语法如下: