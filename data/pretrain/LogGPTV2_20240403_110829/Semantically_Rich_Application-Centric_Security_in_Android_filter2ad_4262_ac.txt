IPC, and 2) expose policies identify the callee’s security
requirements on the IPC. That is, access policies govern
the IPC an application initiates, and expose policies
govern the IPC an application receives. Note that the
target (for access) and source (for expose) are implicitly
interpreted as the application specifying the policy, and an
application cannot specify policy for other applications.
One can view Saint policy as being similar to a
network-level stateful ﬁrewall [7]3. Like a stateful ﬁre-
wall, Saint identiﬁes policy by its source and destination,
and checks conditions to determine if the IPC should
be allowed. In Saint,
the source and destination are
applications, components, Intent (event) types, or some
combination thereof. Conditions are checks of the con-
ﬁguration or current state of the phone. Note that unlike
3A stateful ﬁrewall maintains ordered policies of
type
{source address, destination address, f lags}, where source
and destination are IP address/ports pairs, and the ﬂags represents the
required state of the communication, e.g., whether a ongoing TCP
connection between the source and destination exists.
the
344
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:12:28 UTC from IEEE Xplore.  Restrictions apply. 
EXAMPLE INSTALL-TIME AND RUNTIME POLICIES.
Table I
Install-time policies: (permission-label) (owner) [!]cond1 [[!]cond2] . . . [[!]condn]
(1) (com.abc.perm.getloc) (com.abc.lbs) required-permission(ACCESS FINE LOCATION)
Permission com.abc.perm.getloc declared by com.abc.lbs only be granted to applications with ACCESS_FINE_LOCATION permission
Run-time policies: (expose|access) (source app, type, action) (destination app, component) [!]cond1 [[!]cond2] . . . [[!]condn]
(1) (access) (com.ok.shopper, START ACT, ACTION PAY) (any, any) sig:default-deny:except(3082019f3082 . . . )
com.ok.shopper cannot start activity with ACTION_PAY action to any component in any applications unless they have signature 3082019f3082 . . .
(2) (access) (com.ok.shopper, any, any) (com.secure.passwordvault, any) min-version(1.2)
com.ok.shopper can start any interaction with any action to any component in com.secure.passwordvault version 1.2 or higher
(3) (access) (com.ok.shopper, any, RECORD EXPENSE) (any, any) forbid-permissions(INTERNET)
com.ok.shopper cannot start any interaction with action “RECORD EXPENSE” to any component in any application with permission “INTERNET”
a ﬁrewall, all Saint policies that match an IPC must be
satisﬁed. Moreover, if no such policies exist, the IPC
is implicitly allowed. Thus, from a technical standpoint,
Saint is a “conjunctional default allow policy” rather than
“default deny ﬁrst match policy” [8].
therefore,
As shown in Table I, Saint runtime policy consists
of a type label, source application details, destination
application details, and a set of conditions. The expose/ac-
cess label identiﬁes the policy type. Applications must
only govern their own IPC,
the specifying
application must be the destination for access polices and
source for expose polices. The source identiﬁes the caller
application and, if applicable, the Intent. The deﬁnition of
a destination callee of a policy is somewhat more ﬂexible.
The destination can be an application, a component, an
Intent, or an application/Intent combination. We expand
the notion of destination to provide ﬁner granularity
policy, as applications with many interfaces frequently
require per-interface policies. For example, the security
policy governing an “add an item to my shopping cart”
feature provided by one component may be very different
than the “authorize this transaction” component policy.
Runtime policy rules specifying multiple conditions
require all conditions to be true for the IPC to proceed.
Conditions can be any test that returns a Boolean value.
For example, test for permission conﬁguration, roaming
state, or any other evaluation function the application
deems necessary. Conditions may also be negated, indi-
cating the IPC should only proceed when the condition
is not satisﬁed (e.g.,
to blacklist conﬁgurations). For
example, a reasonable policy might prevent the phone’s
web browser from accessing the address book or dialer.
Table I provides runtime policies in response to security
requirements (1), (3), and (4) of the example in Section II.
In Saint, runtime policy (1) is presented in XML as:
com.ok.shopper
ACTION_PAY
any
3082019f ... 
C. Administrative Policy
An administrative policy dictates how policy itself
can be changed [9]. Saint’s default administrative policy
attempts to retain the best qualities of mandatory access
control in Android: all application policies are ﬁxed at
installation can only change through application update
(reinstallation). In Saint, the application update process
removes all
the of relevant policies and inserts those
speciﬁed in the update. From a policy perspective, this is
semantically equivalent to uninstalling and installing an
application. We considered other administrative models
allowing the updater to modify, add, or delete policy.
However, the phone policy could unpredictably diverge
from that desired by the developer quickly where, for
example, update versions were skipped by the user.
There is a heated debate in smartphone operating sys-
tems community about whether to allow users to override
system/application policies. A purist school of thought
suggests that applications are providing MAC policies,
and therefore, nothing should be changed. This provides
the most stringent (and predictable) security, but poten-
tially can prevent otherwise legitimate operations from
occurring. The second school of thought says the user is
always right and every policy should be overrideable.
There is no one right answer to the override debate.
Hence, we introduce an infrastructure for overriding, but
leave it as an OS build option. If the SaintOverride
compile ﬂag is set, Saint allows user override to applica-
tion policy. Additionally, Saint XML policy schema in-
cludes the Override ﬂag for each policy rule deﬁned by
the application. If the system SaintOverride system
ﬂag and Override ﬂags are true, the FrameworkPoli-
cyManager application (see Section VI) allows the user
to disable the rule though the interface. If disabled, this
rule is ignored during policies decisions. Note that we
considered allowing the user to arbitrarily modify the
policy (rather than simply disabling it), but this introduces
a number of complex security and usability concerns that
we defer to future work.
D. Operational Policy
Saint has the potential to hamper utility by restricting
access to interfaces. Detecting such incidents is essential
to be providing a useful service. Past security measures
345
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:12:28 UTC from IEEE Xplore.  Restrictions apply. 
that have prevented application behavior in an opaque
and ambiguous way have not fared well, e.g., Microsoft
Vista. This section deﬁnes policies that detect when Saint
renders an application inefﬁcient, faulty, or inoperable.
Consider a simple logical formulation of the Saint
runtime policies. The conditions supported in the system
are denoted by the set C = {c1, c2, . . . , cn}. C can be
further subdivided into two sets V and T , i.e., C = V ∪T .
V is the set of conditions which are invariant with respect
to the system state. Invariant conditions do not change
as a function of the normal operation of the phone. For
example, permission assignments, developer signatures,
and application version numbers are invariant. T is the set
of conditions which rely on transient system state, e.g.,
roaming state, battery power, access to a 3G interface.
Recall that IPC is governed by the access policy pa
of the caller and the expose policy pe of callee. A given
interaction will succeed only if the conditions of both
policies are satisﬁed. Logically speaking, each policy
consists of zero or more elements of C or their negation.
At any given time, the system state of the phone S is a
truth assignment for Boolean variables for each element
of C. ˆS is the set of all possible sets of S. Let V be
the subset of S relating to elements of V (the invariant
conditions). The run-time IPC decision is therefore a
simple test of satisfaction of the conjunction of pa and
pe by S, i.e., S ⇒ pa ∧ pe.4
This formulation allows us to reason about the satisﬁ-
ability of policy at install time. There are three possible
outcomes for the install-time analysis of future IPC:
V ⇒ pa ∧ pe (always satisﬁed)
∃S ∈ ˆS | S ⇒ pa ∧ pe (satisﬁable)
(cid:7) ∃S ∈ ˆS | S ⇒ pa ∧ pe (unsatisﬁable)
where, “always satisﬁed” IPC will always be able to
proceed (because the invariant conditions never change),
“satisﬁable” can occur under certain conditions (because
they depend on changing system state), and “unsatis-
ﬁable” will never be allowed to occur. This last case
occurs when either rule contains an unsatisﬁed invariant
condition, e.g., incorrect developer signature, or the two
rules conﬂict, e.g., where the expose/access rule contains
a condition c and the other contains its negation ¬c. Note
that because of the structure of the logical expressions,
this satisﬁability test can be tested in polynomial time
(proof omitted for brevity).
We exploit this analysis to lean about the ability of an
application to function. Saint tests every access rule of an
application during its installation. Any rule that is unsatis-
ﬁable depicts an unusable interface, which may represent
a serious functional limitation, e.g., imagine a text mes-
sage application that cannot use the address book. Thus,
the framework warns the user if any access rule is un-
4Interfaces unprotected Saint policies are in essence “empty” policies.
For the purposes of the logical analysis presented in this section, WLOG,
they can be modeled simply by the Boolean value TRUE.
satisﬁable. Moreover, we add FeatureRequirement
enumerated value to the XML structure of each policy
rule. This value has three values; NONE, AVAILABLE,
and ALWAYS. The NONE has no effect. The frame-
work prevents the application from being installed if
AVAILABLE is declared and the rule is unsatisﬁable or if
ALWAYS is declared and the rule is not always satisﬁed.
The operational policy allows the system to track and
manage dependencies between applications and inter-
faces. By checking the operational policies of all applica-
tions during installation, update and uninstallation, we can
detect when a change in an application will effect other
applications. The system can warn the user or simply
prevent the operation from moving forward if required
interfaces become non-functional or are removed.
VI. SAINT ARCHITECTURE
Saint was implemented as a modiﬁcation to the An-
droid 1.5 OS. For each of the above install-time and
runtime policies, we inserted one or more enforcement
hooks into Android’s middleware layer. In this section,
we describe the relevant functionality in Android and the
modiﬁcations we made to enforce Saint policies.
A. Saint Installer
The Saint installer is a modiﬁed version of Android’s
application installer. The installer receives the path to
the downloaded Android package (.apk) and parses the
package using PackageParser and PackageManager.
During this step, we collect all package conﬁgurations
necessary for install-time policy evaluation, such as the
package’s signature, requested permissions, and applica-
tion version. The package’s declared permissions are also
acquired to verify this package’s application policy.
We implement Saint’s policy in a separate XML ﬁle
with name identical
to the package name. We chose
to express the application policy in XML to match the
format of Android’s manifest ﬁle. Including the policy
into the manifest ﬁle requires changes to the Android
SDK and to the installer’s package parsing function. We
consider this extension as our future work.
Immediately after the package is parsed,
the Saint
installer examines each requested permission against its
corresponding permission-granting policy queried from
the AppPolicy provider. If a conﬂict is found, the installer
rejects the installation.
After successful installation, the installer parses the
application’s policy ﬁle to an intermediate form. By con-
sidering the application’s declared permissions obtained
during the package parsing step, the installer ensures that
each policy entry is inserted into the AppPolicy provider
only if its permission label is declared by the application.
B. Saint Mediator
Saint’s runtime enforcement covers four critical com-
ponent interactions: starting new Activities, binding com-
ponents to Services, receiving broadcast Intents and ac-
cessing Content Providers. For each of these interactions,
346
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:12:28 UTC from IEEE Xplore.  Restrictions apply. 
we cover the limitations of the existing Android security
implementation and explain the necessary modiﬁcations
and authorization hooks needed to enforce Saint policies.
Starting Activities (4.A) — As users interact with activ-
ities, they often spawn new activities for GUI elements
such as menus and dialogs. In Android, a request to start a
new activity takes the form of an Intent sent to the Activity
Manager Service (AMS), a key Android component that
facilitates interactions between activities.
i.e.
The AMS will then match one or more activities that
have registered for that Intent. In the event that a single
match is not found,
there are multiple registered
activities, the list of all such activities is displayed to
the user who chooses the correct one, e.g. should a
photograph be sent to an email client or an album. When
the destination activity is known, the AMS will check
if the sending activity has the permission to start such
activity. If so, the activity is started. This possibility for
multiple activities to match an Intent represents one of the
limitations of the current Android security framework in
that the registered activity has no control what component
may call it beyond the permissions needed for its Intent.
The calling activity has no control over which target
activity is selected. To allow both the source as well as
the receiver activity to inﬂuence the decision to spawn the
receiver, we add a hook that restricts the set of candidate
activities to choose from as shown in Figure 5.
Saint Hook Placement: If a single activity matches the
Intent when it is resolved by the AMS, hook (1) checks
that the conditions for both the source and destination
activity before starting the destination activity as a match
for the Intent. If multiple activities are registered for the
Intent, it is passed to ResolverActivity for further
Intent resolution. For each of the matched activities, hook
(2) checks the source against each potential destination
before allowing it to be included in the list of user options.
Any destination activities not allowed by the current
policy are excluded from the list. The activity selected
by the user is the target activity for the Intent. There is
also a small probability that only one matched activity is
found. This match is checked by hook (3) whether it can
be the target. Then, the target activity is started through
the AMS. This time, the Intent is addressed to the speciﬁc
activity and will have only a single match. The ﬁnal check
is performed by hook (1) to prevent TOCTTOC attack.
Receiving Intent Broadcasts (4.B) — A Broadcast
Receiver acts as a mailbox for the application. It listens
to Intent message broadcast by another component in
the same or different application for data exchange. To
specify the type of messages it is listening to, the Broad-
cast Receiver is attached with Intent-ﬁlter(s) that describe
Intent values to be matched including the action string.
Intent broadcasts are handled by the AMS, which attempts
to resolve the broadcast receiver components registered
for the Intent. A broadcast receiver may be registered for
receiving speciﬁc Intent(s) either statically at install-time
or dynamically during its execution. A static Broadcast
Receiver and its permanently associated Intent-ﬁlter(s) are
declared in the manifest and is always registered with
the system. In contrast, a dynamic Broadcast Receiver is
declared as a class in the code and is instantiated during
runtime. It can be registered and unregistered any time.
The Intent-ﬁlter(s) attached to the dynamic Broadcast
Receiver is also created at runtime, thus can be changed.
Saint Hook Placement: In order to enforce Saint’s access
policies for Intent broadcasts, several authorization hooks
were inserted into this process. Hook (4) is taken if the
broadcast receiver is selected by name. In this case, only
a single check is performed for the named receiver. If
the Intent contains an action string, it can be received
by potentially multiple broadcast receivers. In this case,