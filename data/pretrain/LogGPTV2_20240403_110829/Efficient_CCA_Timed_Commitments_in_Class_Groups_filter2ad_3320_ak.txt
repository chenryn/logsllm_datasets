defined as
L2 :=
stmt2 := (ğº, ğ¾, ğ»0, ğ»1)
(cid:110)(ğº, ğ¾, ğ»0, ğ»1)(cid:12)(cid:12)(cid:12)âˆƒ ğ‘ , ğœŒ s.t. ğ»0 = ğºğ‘ Â·2âˆ’ğœŒ
ğ‘–,0 and ğ»1 :=ğ›¼
where ğ»0 :=ğ›¼
ğ‘–=1 ğ‘2ğ‘–âˆ’1
â€¢ Language L3 contains statements
ğ‘–=1 ğ‘2ğ‘–âˆ’1
ğ‘–,1
AND ğ»1 = ğ¾ğ‘ Â·2âˆ’ğœŒ(cid:111) ,
Â· ğ‘âˆ’1
1 .
stmt3 := (ğº, ğ¾, Ëœğº, Ëœğ¾, {ğ‘ğ‘–,0, ğ‘ğ‘–,1, Ëœğ‘ğ‘–,0, Ëœğ‘ğ‘–,1}ğ‘–âˆˆ[ğ›¼]),
defined as
L3 :=
(ğº, ğ¾, Ëœğº, Ëœğ¾)
{ğ‘ğ‘–,0, ğ‘ğ‘–,1}ğ‘–âˆˆ[ğ›¼]
{ Ëœğ‘ğ‘–,0, Ëœğ‘ğ‘–,1}ğ‘–âˆˆ[ğ›¼]
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)
AND
âˆƒ {ğ‘ ğ‘–, Ëœğ‘ ğ‘–, ğœŒğ‘– }ğ‘–âˆˆ[ğ›¼] s.t.
(ğ‘ğ‘–,0, ğ‘ğ‘–,1) = (ğºğ‘ ğ‘–Â·2âˆ’ğœŒğ‘– , ğ¾ğ‘ ğ‘–Â·2âˆ’ğœŒğ‘– )
( Ëœğ‘ğ‘–,0Ëœ,ğ‘ğ‘–,1) = ( Ëœğº Ëœğ‘ ğ‘– , Ëœğ¾ Ëœğ‘ ğ‘–)
(ğ‘ğ‘–,0, ğ‘ğ‘–,1) = (ğºğ‘ ğ‘–Â·2âˆ’ğœŒğ‘– , ğ¾ğ‘ ğ‘–Â·2âˆ’ğœŒğ‘–
( Ëœğ‘ğ‘–,0, Ëœğ‘ğ‘–,1) = ( Ëœğº Ëœğ‘ ğ‘– , Ëœğ¾ Ëœğ‘ ğ‘– Â· Ëœğº)
AND
OR
Â· ğº)
While we present individual protocols for each language, our system
will prove the conjunction of such statements. This can be achieved
by standard AND composition of sigma protocols. The protocols are
presented in Figures 6 to 8 and they assume three hash functions
H1, H2 : {0, 1}âˆ— â†’ Z2ğœ† and H3 : {0, 1}âˆ— â†’ (Z2ğœ†)ğ›¼ modelled
as random oracles. These functions can be obtained by a single
random oracle via standard domain separation techniques, but for
simplicity we treat them as independent oracles. In all protocols, we
assume that the prover checks that the elements of the statements
belong to the correct groups as in standard discrete log based ZK
proofs. For instance, for elements of the class groups, one has to
check that there are squares, which can be done in polynomial time
(cf. [49]). The setup algorithm solely consists of the sampling of the
corresponding hash function, and it is therefore omitted. We recall
the following standard lemma, proven e.g. in [2].
Lemma E.1. Let ğ‘ˆ[0,ğ‘Ÿ] be the uniform distribution on the interval
[0, ğ‘Ÿ] and ğ›½ âˆˆ Z. Then the statistical distance between ğ‘ˆ[0,ğ‘Ÿ] and
ğ‘ˆ[0,ğ‘Ÿ] + ğ›½ is ğ›½/ğ‘Ÿ.
We now proceed with the analysis our protocols. We remark
that many of these proofs are already well known in the literature
(e.g. some proofs for the CL encryption scheme can be found in
[24, 26]) and we present them here only for completeness.
Theorem E.2 (Zero-knowledge). The protocol in Figure 6 satis-
fies statistical zero-knowledge in the random oracle model.
Proof of Theorem E.2. The simulator on input (crs, stmt), pic-
ğ¾ â† Zğ‘„ and ğ‘’â€² â† Z2ğœ†. It then computes ğ¾â€²
ks ğ‘¡â€²
ğ¾ /ğ¾ğ‘’â€² and
sets the random oracle H1(stmt, ğ¾â€²
0, ğ‘¡â€²
ğ¾)
as its proof. Notice that for a randomly sampled ğ‘¡ in the honest
proof the statistical distance between ğ‘¡â€²
ğ¾ and ğ‘¡ + ğ‘’ Â· ğ‘¥ is 2ğœ† Â· Ëœğ‘/ğ‘„
(following from Lemma E.1) which is negligible. Therefore the joint
distribution of (ğ¾â€²
ğ¾ , ğ‘’â€²) computed by the simulator is statistically
close to computing (ğ¾0, ğ‘¡ + ğ‘’ Â· ğ‘¥, ğ‘’) honestly.
â–¡
0) := ğ‘’â€². It outputs ğœ‹ := (ğ¾â€²
0 := ğºğ‘¡â€²
0, ğ‘¡â€²
Session 10C: Foundations CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2680PrvL1(crs, stmt, wit): The prover routine does the following:
â€¢ Sample ğ‘¡ â† Zğ‘„, where ğ‘„ = Ëœğ‘ Â· 22ğœ†, compute ğ¾0 := ğºğ‘¡
â€¢ Compute ğ‘’ â† H1(stmt, ğ¾0)
â€¢ Compute ğ‘¡ğ¾ := ğ‘¡ + ğ‘’ Â· ğ‘¥
â€¢ Set the proof ğœ‹ := (ğ¾0, ğ‘¡ğ¾ , ğ‘’)
VfyL1(crs, stmt, ğœ‹): The verifier routine does the following:
â€¢ Parse ğœ‹ := (ğ¾0, ğ‘¡ğ¾ , ğ‘’)
?
â€¢ Check if ğ‘’
= H1(stmt, ğ¾0), if so continue, otherwise output 0
?
= ğ¾0 Â· ğ¾ğ‘’. If successful, output 1, else output 0.
â€¢ Check if ğºğ‘¡ğ¾
Figure 6: Prover and Verifier routine for NIZK proof for statements in language L1
Theorem E.3 (Simulation Soundness). The protocol in Figure 6
satisfies simulation soundness provided the 2ğœ†-low order assumption
and the strong root assumption holds in G, in the random oracle
model.
Proof of Theorem E.3. In the following we assume without
loss of generality that the reduction is given ahead of time the
false statement stmt and the more general claim follows with a
polynomial loss (by guessing the right query of the adversary to
the random oracle). The proof consists of a reduction against the
2ğœ†-low order assumption and the strong root assumption. Consider
a reduction R that on input G, generates crs and gives it to the
adversary A. The adversary A may query statements stmt to the
reduction and the reduction returns simulated proofs. The reduction
sets and answers random oracle queries to H1 via lazy sampling.
At some point in the execution, the adversary makes a query of the
form (stmt, ğ¾0) to the random oracle H1. The reduction forks the
execution of the game by answering with two different integers
(ğ‘’, ğ‘’â€²) â† Zğ‘„ such that ğ‘’â€² â‰  ğ‘’. By the forking lemma [63], with
inverse polynomial probability the adversary outputs two accepting
proofs ğœ‹ := (ğ¾0, ğ‘¡ğ¾ , ğ‘’) and ğœ‹â€² := (ğ¾0, ğ‘¡â€²
ğ¾ , ğ‘’â€²) on the statement stmt.
ğ¾), (ğ‘’ âˆ’ ğ‘’â€²) and
ğ¾ , ğ‘’ âˆ’ ğ‘’â€²).
Â· ğ¾âˆ’ ğ‘’âˆ’ğ‘’â€²
The reduction computes (ğ‘¡ğ¾ âˆ’ ğ‘¡â€²
ğ›¾ := gcd(ğ‘¡ğ¾ âˆ’ ğ‘¡â€²
We denote
ğœ‡ := ğº
ğ‘¡ğ¾ âˆ’ğ‘¡â€²
which is either 1 or different from 1. In the case ğœ‡ â‰  1, we clearly
have ğœ‡ğ›¾ = 1. Given the maximum value of (ğ‘’ âˆ’ ğ‘’â€²) is at most 2ğœ†
and ğ›¾ divides (ğ‘’ âˆ’ ğ‘’â€²), the reduction outputs (ğœ‡, ğ›¾) as a solution to
2ğœ†-low order assumption.
ğ¾
ğ›¾
ğ›¾
Now suppose that ğœ‡ = 1. Let us denote ğ¸ := ğ‘’âˆ’ğ‘’â€²
ğ‘¡ğ¾ âˆ’ğ‘¡â€²
ğ¾
ğ›¾
= ğ¾ğ¸. We have two cases here,
ğº
(1) In the first case we suppose that ğ¸ = 2ğœŒ for some integer ğœŒ. In
such that ğºğ‘¥ = ğ¾2ğœŒ or
this case we can compute ğ‘¥ :=
equivalently ğºğ‘¥Â·2âˆ’ğœŒ
= ğ¾ as ğº, ğ¾ are checked to be in the correct
groups (in our applications with class groups, one checks that
ğº and ğ¾ are squares which means that they have odd orders).
But since stmt âˆ‰ L1, this case is not possible.
(2) In the second case. We have for some (ğ›¼, ğ›½) that
ğ‘¡ğ¾âˆ’ğ‘¡â€²
ğ›¾
ğ¾
ğ›¾ , so that
ğ›¼(ğ‘¡ğ¾ âˆ’ ğ‘¡â€²
ğ¾) + ğ›½(ğ‘’ âˆ’ ğ‘’â€²) = ğ›¾
which can be efficiently computed by the extended Euclidean
algorithm. Observe that
ğ¾)+ğ›½(ğ‘’âˆ’ğ‘’â€²)
ğºğ›¾ = ğºğ›¼(ğ‘¡ğ¾âˆ’ğ‘¡â€²
ğºğ›¾ = ğºğ›¼(ğ‘¡ğ¾âˆ’ğ‘¡â€²
ğ¾)ğº ğ›½(ğ‘’âˆ’ğ‘’â€²)
ğºğ›¾ = ğ¾ğ›¼(ğ‘’âˆ’ğ‘’â€²)ğº ğ›½(ğ‘’âˆ’ğ‘’â€²)
ğºğ›¾ = (ğ¾ğ›¼ğº ğ›½)(ğ‘’âˆ’ğ‘’â€²) .
The reduction outputs (ğ¾ğ›¼ğº ğ›½, ğ¸) as its solution to the strong
root problem since ğ¸ is not a power of 2 or a solution to the
2ğœ†-low order assumption as before. Thus we arrive at a contra-
diction, which proves the simulation soundness of the protocol.
â–¡
Theorem E.4 (Zero-knowledge). The protocol in Figure 7 satis-
fies statistical zero-knowledge in the random oracle model.
Proof of Theorem E.4. The simulator samples ğ‘¡â€²
and ğ‘’â€² â† Z2ğœ†. It then computes ğºâ€²
ğ¾ğ‘¡â€²
ğº,ğ¾ /(ğ»1)ğ‘’â€² and sets the random oracle
0 := ğºğ‘¡â€²
ğº,ğ¾ â† Zğ‘„
0 :=
ğº,ğ¾ /(ğ»0)ğ‘’â€² and ğ¾â€²
0) := ğ‘’â€².
It outputs the proof ğœ‹ := (ğºâ€²
lated proof is statistically close to the honest one.
H2(stmt, ğºâ€²
0, ğ¾â€²
ğº,ğ¾ , ğ‘’â€²). By Lemma E.1 the simu-
0, ğ‘¡â€²
0, ğ¾â€²
â–¡
Theorem E.5 (Simulation Soundness). The protocol in Figure 7
satisfies simulation soundness provided the 2ğœ†-low order assumption
and the strong root assumption holds in G, in the random oracle
model.
Proof of Theorem E.5. The proof follows along the lines of the
argument for Theorem E.3 and it boils down to showing that it is
possible to extract a solution to the 2ğœ†-low order assumption or the
strong root problem given two accepting transcripts with the same
first message ğœ‹ := (ğº0, ğ¾0, ğ‘¡ğº,ğ¾ , ğ‘’) and ğœ‹â€² := (ğº0, ğ¾0, ğ‘¡â€²
ğº,ğ¾ , ğ‘’â€²).
â–¡
Theorem E.6 (Zero-knowledge). The protocol in Figure 8 is
zero-knowledge in the random oracle model.
Proof of Theorem E.6. We describe the simulator for a single
index ğ‘– âˆˆ [ğ›¼] and the algorithm can be extended to the more
general case in a natural way. The simulator picks ğ‘‘ğ‘–,1, ğ‘‘ğ‘–,2 â† Z2ğœ†,
ğ‘Ÿğ‘–,1, ğ‘Ÿğ‘–,2 â† Zğ‘„ and Ëœğ‘Ÿğ‘–,1, Ëœğ‘Ÿğ‘–,2 â† Z Ëœğ‘. It then sets
Session 10C: Foundations CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2681PrvL2(crs, stmt, wit): The prover routine does the following:
â€¢ Sample ğ‘¡ â† Zğ‘„, where ğ‘„ = Ëœğ‘ Â· 22ğœ†, compute ğº0 := ğºğ‘¡ and ğ¾0 := ğ¾ğ‘¡
â€¢ Compute ğ‘’ â† H2(stmt, ğº0, ğ¾0)
â€¢ Compute ğ‘¡ğº,ğ¾ := ğ‘¡ + ğ‘’ Â· ğ‘ 
â€¢ Set the proof ğœ‹ := (ğº0, ğ¾0, ğ‘¡ğº,ğ¾ , ğ‘’)
VfyL2(crs, stmt, ğœ‹): The verifier routine does the following:
â€¢ Parse ğœ‹ := (ğº0, ğ¾0, ğ‘¡ğº,ğ¾ , ğ‘’)
â€¢ Check if ğ‘’
â€¢ Check if ğºğ‘¡ğº,ğ¾
?
= ğº0 Â· ğ»ğ‘’
?
= H2(stmt, ğº0, ğ¾0), if so continue, otherwise output 0
0 and ğ¾ğ‘¡ğº,ğ¾
?