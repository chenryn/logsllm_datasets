title:High-Speed Matching of Vulnerability Signatures
author:Nabil Schear and
David R. Albrecht and
Nikita Borisov
High-Speed Matching of Vulnerability Signatures
Nabil Schear1, David R. Albrecht2, and Nikita Borisov2
1 Department of Computer Science
2 Department of Electrical and Computer Engineering
University of Illinois at Urbana–Champaign
{nschear2,dalbrech,nikita}@uiuc.edu
Abstract. Vulnerability signatures offer better precision and ﬂexibility than ex-
ploit signatures when detecting network attacks. We show that it is possible to
detect vulnerability signatures in high-performance network intrusion detection
systems, by developing a matching architecture that is specialized to the task of
vulnerability signatures. Our architecture is based upon: i) the use of high-speed
pattern matchers, together with control logic, instead of recursive parsing, ii) the
limited nature and careful management of implicit state, and iii) the ability to
avoid parsing large fragments of the message not relevant to a vulnerability.
We have built a prototype implementation of our architecture and vulnerabil-
ity speciﬁcation language, called VESPA, capable of detecting vulnerabilities in
both text and binary protocols. We show that, compared to full protocol pars-
ing, we can achieve 3x or better speedup, and thus detect vulnerabilities in most
protocols at a speed of 1 Gbps or more. Our architecture is also well-adapted to
being integrated with network processors or other special-purpose hardware. We
show that for text protocols, pattern matching dominates our workload and great
performance improvements can result from hardware acceleration.
1 Introduction
Detecting and preventing attacks is a critical aspect of network security. The dominant
paradigm in network intrusion detection systems (NIDS) has been the exploit signature,
which recognizes a particular pattern of misuse (an exploit). An alternative approach is
to use a vulnerability signature, which describes the class of messages that trigger a
vulnerability on the end system, based on the behavior of the application. Vulnerability
signatures are exploit-generic, as they focus on how the end host interprets the message,
rather than how the particular exploit works, and thus can recognize polymorphic and
copycat exploits.
Exploit signatures are represented using byte-string patterns or regular expressions.
Vulnerability signatures, on the other hand, usually employ protocol parsing to recover
the semantic content of the communication and then decide whether it triggers a vulner-
ability. The semantic modeling allows vulnerability signatures to be both more general
and more precise than exploit signatures. However, this comes at a high performance
cost. To date, vulnerability signatures have only been considered for user on end hosts,
severely limiting their deployment.
R. Lippmann, E. Kirda, and A. Trachtenberg (Eds.): RAID 2008, LNCS 5230, pp. 155–174, 2008.
c(cid:2) Springer-Verlag Berlin Heidelberg 2008
156
N. Schear, D.R. Albrecht, and N. Borisov
In our work, we observe that full and generic protocol parsing is not necessary for
detecting vulnerability signatures. Using custom-built, hand-coded vulnerability signa-
ture recognizers, we show that these signatures can be detected 3 to 37 times faster than
the speed of full protocol parsing. Therefore, there is no inherent performance penalty
for using vulnerability signatures instead of exploit signatures.
Motivated by this, we design an architecture, called VESPA1, for matching vulner-
ability signatures at speeds adequate for a high-performance enterprise NIDS, around
1 Gbps. We build our architecture on a foundation of fast string and pattern matchers,
connected with control logic. This allows us to do deep packet inspection and model
complex behavior, while maintaining high performance. We also minimize the amount
of implicit state maintained by the parser. By avoiding full, in-memory semantic rep-
resentation of the message, we eliminate much of the cost of generic protocol parsing.
Finally, in many cases we are able to eliminate the recursive nature of protocol analysis,
allowing us to skip analysis of large subsections of the message.
We have implemented a prototype of VESPA; tests show that it matches vulnerability
signatures about three times faster than equivalent full-protocol parsing, as implemented
in binpac [1]. Our architecture matches most protocols in software at speeds greater
than 1 Gbps. Further, we show that our text protocol parsing is dominated by string
matching, suggesting that special-purpose hardware for pattern matching would permit
parsing text protocols at much higher speeds. Our binary protocol parsing is also well-
adapted to hardware-aided implementation, as our careful state management ﬁts well
with the constrained memory architectures of network processors.
The rest of this paper is organized as follows: Section 2 gives some background
on vulnerability signatures and discusses the context of our work. Sections 3 and 4
describe the design of VESPA and the vulnerability signature language. We present
the implementation details of VESPA in Section 5. Section 6 contains a performance
evaluation of our prototype. We discuss some future directions in Section 7 and related
work in Section 8. Finally, Section 9 concludes.
2 Background
2.1 Vulnerability Signatures
Vulnerability signatures were originally proposed by Wang et al. [2] as an alternative to
traditional, exploit-based signatures. While exploit signatures describe the properties of
the exploit, vulnerability signatures describe how the vulnerability gets triggered in an
application. Consider the following exploit signature for Code Red [3]:
urlcontent:"ida?NNNNNNNNNNNN..."
The signature describes how the exploit operates: it uses the ISAPI interface (invoked
for ﬁles with extension “.ida”) and inserts a long string of N’s, leading to a buffer over-
ﬂow. While effective against Code Red, this signature would not match Code Red II [4];
that variant used X’s in place of the N’s. A vulnerability signature, on the other hand,
does not specify how the worm works, but rather how the application-level vulnerability
is triggered. An extract from the CodeRed signature in Shield [2] is:
1 VulnErability Signature Parsing Architecture.
High-Speed Matching of Vulnerability Signatures
157
c = MATCH_STR_LEN(>>P_Get_Request.URI,"id[aq]\?(.*)$",limit);
IF (c > limit)
# Exploit!
This signature captures any request that overﬂows the ISAPI buffer, making it effec-
tive against Code Red, Code Red II, and any other worm or attack that exploits the
ISAPI buffer overﬂow. In fact, this signature could well have been written before the
release of either of the Code Red worms, as the vulnerability in the ISAPI was pub-
lished a month earlier [5]. Thus, while exploit signatures are reactive, vulnerability
signatures can proactively protect systems with known vulnerabilities until they are
patched (which can take weeks or months [6]).
2.2 Protocol Parsing
Traditionally, exploit signatures are speciﬁed as strings or regular expressions. Vulnera-
bility signatures, on the other hand, involve some amount of protocol parsing. Shield [2]
used a language for describing C-like binary structures, and an extension for parsing text
protocols. The follow-on project, GAPA [7], designed a generic application-level pro-
tocol analyzer to be used for matching vulnerability signatures. GAPA represented both
binary and text protocols using a recursive grammar with embedded code statements.
The generated GAPA parser, when guided by code statements, performed context-
sensitive parsing. GAPA aimed to provide an easy-to-use and safe way to specify pro-
tocols and corresponding vulnerabilities.
Binpac [1], another protocol parser, was designed to be used in the Bro intrusion
detection system [8]. Binpac is similar to GAPA: both use a recursive grammar and
embedded code for parsing network protocols, and both are intended to minimize the
risks of protocol parsing. Binpac, however, is designed only for parsing, with other
parts of Bro performing checks for alarms or vulnerabilities. Binpac uses C++ for its
embedded code blocks, and compiles the entire parser to C++ (similar to yacc), whereas
GAPA uses a restricted, memory-safe interpreted language capable of being proven free
of inﬁnite loops. Binpac trades some of GAPA’s safety for parsing speed; consequently,
it achieves speeds comparable to hand-coded parsers written for Bro.
Since the implementation of GAPA is not freely available, we use binpac as our
prototypical generic protocol parser generator in comparing to our work. Binpac is sig-
niﬁcantly faster than GAPA, yet it is not able to parse many protocols at speeds of 1
Gbps (though sparing use of binpac, where most data passing through the NIDS is not
analyzed, can be supported.)
2.3 Vulnerability Complexity
Although Shield and GAPA used protocol parsing for vulnerability signatures, Brum-
ley et al. suggest that vulnerability signatures could be represented across a spectrum
of complexity classes [9]. They consider the classes of regular expressions, constraint
satisfaction languages, and Turing machines, and provide algorithms to derive auto-
matic vulnerability signatures of each class. As increasingly complex speciﬁcations of
signatures are used, the precision of signature matching improves.
158
N. Schear, D.R. Albrecht, and N. Borisov
We make a different observation: most vulnerability signatures can be matched pre-
cisely without full protocol parsing. And such precise matching can be carried out at
much greater speeds. In Table 1, we compare the performance of binpac to hand-coded
implementations of several vulnerability signatures. We wrote the hand-coded imple-
mentations in C and designed them to match one speciﬁc vulnerability only. These
would fall into the Turing machine class according to Brumley et al., but they are opti-
mized for speed. Notice that the hand-coded implementations operate about 3x to 37x
faster than equivalent binpac implementation.
Table 1. The throughput (Mbits/s) of binpac parsers vs. hand-coded vulnerability matchers
Protocol
CUPS/HTTP
DNS
IPP
WMF
binpac
5,414
71
809
610
hand-coded
20,340
2,647
7,601
14,013
To see why this is the case, consider the following CUPS vulnerability (CVE-2002-
1368 [10]). CUPS processes the IPP protocol, which sends messages embedded inside
HTTP requests. CUPS would crash if a negative Content-Length were speciﬁed, pre-
senting a denial-of-service opportunity. Our binpac implementation to check for this
vulnerability is based on the binpac HTTP speciﬁcation, which parses the HTTP header
into name–value pairs. We add a constraint that looks for header names that match
Content-Length and veriﬁes that a non-negative value is used. Our hand-coded imple-
mentation, on the other hand, is built upon an Aho–Corasick [11] multi-string matcher,
which looks for the strings “Content-Length:” and “\r\n\r\n” (the latter indicating
the end of the headers). If “Content-Length:” is found, the following string is parsed
as an integer and checked for being non-negative.
The parsers operate with equal precision when identifying the vulnerability, yet the
hand-coded approach performs much less work per message, and runs more than 3 times
as quickly. Of course, not all vulnerabilities can be matched with a simple string search.
However, what this vulnerability demonstrates is that an efﬁcient vulnerability signa-
ture matching architecture must be able to handle such simple vulnerabilities quickly,
rather than using heavy-weight parsing for all vulnerabilities, regardless of complexity.
The architecture will surely need to support more complex constructs as well, but they
should only be used when necessary, rather than all the time. We next present a new
architecture for specifying and matching vulnerability signatures that follows this prin-
ciple. Our architecture shares some of the goals of binpac and GAPA; however, it puts
a stronger focus on performance, rather than generality (GAPA) or ease-of-authoring
(binpac).
3 Design
To make vulnerability signatures practical for use in network intrusion detection sys-
tems, we developed VESPA, an efﬁcient vulnerability speciﬁcation and matching
High-Speed Matching of Vulnerability Signatures
159
architecture. The processes of writing a protocol speciﬁcation and writing a vulnera-
bility signature are coupled to allow the parser generator to perform optimizations on
the generated code that specialize it for the vulnerabilities the author wishes to match.
Our system is based on the following design principles:
– Use of fast matching primitives
– Explicit state management
– Avoiding parsing of irrelevant message parts
Since text and binary protocols require different parsing approaches, we describe
our design of each type of parser and how we apply the design principles listed above.
We ﬁrst give a brief outline of how the system works, and then go into detail in the
subsequent sections on how our approach works.
We use fast matching primitives—string matching, pattern matching (regular ex-
pressions), and binary traversal—that may be easily ofﬂoaded to hardware. The signa-
ture author speciﬁes a number of matcher primitive entries, which correspond to ﬁelds
needed by the signature to evaluate the vulnerability constraint. Each matcher contains
embedded code which allows the matching engine to automatically extract a value from
the result of the match. For example, the HTTP speciﬁcation includes a string matcher
for “Content-Length:”, which has an extraction function that converts the string rep-
resentation of the following number to a integer.
Along with each matcher, the author also speciﬁes a handler function that will be
executed following the extraction. The handlers allow the signature author to model
the protocol state machine and enable additional matchers. For example, if a matcher
discovers that an HTTP request message contains the POST command, it will in turn
enable a matcher to parse and extract the message body. We also allow the author to
deﬁne handlers that are called when an entire message has been matched.
The author checks vulnerability constraints inside the handler functions. Therefore
constraint evaluation can be at the ﬁeld level, intra-message level, and inter-message
level. Depending on the complexity of the vulnerability signature, the author can choose
where to evaluate the constraint most efﬁciently.
3.1 Text Protocols
We found that full recursive parsing of text protocols is both too slow and unnecessary
for detecting vulnerabilities. However, simple string or regular expression matching
is often insufﬁcient to express a vulnerability constraint precisely in cases where the
vulnerability depends on some protocol context. In our system, we combine the beneﬁts
of the two approaches by connecting multiple string and pattern matching primitives
with control logic specialized to the protocol.
Matching Primitives. To make our design amenable to hardware acceleration we
built it around simple matching primitives. At the core, we use a fast multi-string
matching algorithm. This allows us to approximate the performance of simple pattern-
based IDSes for simple vulnerability signatures. Since our system does not depend on
any speciﬁc string matching algorithm, we have identiﬁed several well-studied algo-
rithms [11,12] and hardware optimizations [13] that could be employed by our system.
160
N. Schear, D.R. Albrecht, and N. Borisov
Furthermore, hardware-accelerated regular expression matching is also becoming a re-
ality [14]. As discussed later, this would further enhance the signature author’s ability
to locate protocol ﬁelds.
Minimal Parsing and State Managment. We have found that protocol ﬁelds can be
divided into two categories: core ﬁelds, which deﬁne the structure and semantics of
the protocol, and application ﬁelds, which have meaning to the application, but are
not necessary to understand the rest of the message. An example of a core ﬁeld is
the Content-Length in HTTP, as it determines the size of the message body that fol-
lows in the protocol, whereas a ﬁeld such as Accept-Charset is only relevant to the
application.
Our approach in writing vulnerability signatures is to parse and store only the core
ﬁelds, and the application ﬁelds relevant to the vulnerability, while skipping the rest.
This allows us to avoid storing irrelevant ﬁelds, focusing our resources on those ﬁelds
that are absolutely necessary.
Although many text protocols are deﬁned in RFCs using a recursive BNF grammar,
we ﬁnd that protocols often use techniques that make identiﬁcation of core ﬁelds possi-
ble without resorting to a recursive parse. For example, HTTP headers are speciﬁed on
a separate line; as a result, a particular header can be located within a message by a sim-
ple string search. Header ﬁelds that are not relevant to a vulnerability will be skipped by
the multi-string matcher, without involving the rest of the parser. Other text protocols
follow a similar structure; for example, SMTP uses labeled commands such as “MAIL
FROM” and “RCPT TO”, which can readily be identiﬁed in the message stream.
3.2 Binary Protocols
While some of the techniques we use for text protocol parsing apply to binary protocols
as well, binary protocols pose special challenges that must be handled differently from
text.
Matching Primitives. Unlike text protocols, binary protocols often lack explicit ﬁeld
labeling. Instead, a parser infers the meaning of a ﬁeld from its position in the message—
relative to either the message start, or to other ﬁelds. In simple cases, the parser can
use ﬁxed offsets to ﬁnd ﬁelds. In more complicated cases, the position of a ﬁeld varies