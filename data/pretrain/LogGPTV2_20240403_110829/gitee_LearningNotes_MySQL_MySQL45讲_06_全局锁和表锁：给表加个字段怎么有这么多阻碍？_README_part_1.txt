### MySQL 锁机制概述

数据库锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问时，数据库需要合理地控制资源的访问规则。锁就是用来实现这些访问规则的重要数据结构。根据加锁的范围，MySQL 中的锁大致可以分为全局锁、表级锁和行锁三类。本文将重点介绍全局锁和表级锁，而关于行锁的内容将在后续文章中详细介绍。

### 全局锁

全局锁是对整个数据库实例进行加锁。MySQL 提供了一个全局读锁命令 `Flush tables with read lock (FTWRL)`。使用此命令后，其他线程的数据更新语句（如增删改）、数据定义语句（如建表、修改表结构）以及更新类事务的提交语句将被阻塞。全局锁的一个典型应用场景是全库逻辑备份，即把整库每个表都导出为文本文件。

#### 使用场景与问题

以前的做法是在备份期间通过 FTWRL 确保没有其他线程对数据库进行更新。然而，这种方法存在一些问题：

- 如果在主库上执行备份，备份期间无法执行任何更新操作，业务可能会受到影响。
- 如果在从库上执行备份，备份期间从库不能执行主库同步过来的 binlog，导致主从延迟。

#### 不加锁的问题

假设有一个“极客时间”的购买系统，包含用户账户余额表 (`u_account`) 和用户课程表 (`u_course`)。如果在备份过程中不加锁，可能会出现以下问题：

1. **备份顺序问题**：假设先备份 `u_account` 表，然后用户购买了一门课程，接着备份 `u_course` 表。这样会导致备份结果中，用户 A 的账户余额未扣减，但课程表中已添加了新课程。这种情况下，如果使用备份恢复数据，用户 A 会发现自己的账户余额未减少，但课程已增加。

2. **逻辑不一致**：如果不加锁，备份得到的库不是一个逻辑时间点的一致性视图，导致数据不一致。

#### 解决方案

在可重复读隔离级别下开启一个事务，可以确保获取一致性视图。官方自带的逻辑备份工具 `mysqldump` 支持 `--single-transaction` 参数，启动一个事务来确保一致性视图。由于 MVCC 的支持，这个过程中数据是可以正常更新的。

然而，`--single-transaction` 方法只适用于所有表使用事务引擎的库。对于不支持事务的引擎（如 MyISAM），备份过程中有更新时只能取到最新数据，破坏了备份的一致性。这时需要使用 `FTWRL` 命令。

另外，虽然 `set global readonly=true` 也可以使全库进入只读状态，但建议使用 `FTWRL`，原因如下：

- `readonly` 变量可能被用于其他逻辑判断，修改该变量影响面更大。
- 异常处理机制不同：客户端异常断开时，`FTWRL` 会自动释放全局锁，而 `readonly` 会导致数据库长时间处于不可写状态，风险较高。

### 表级锁

MySQL 中的表级锁有两种：表锁和元数据锁（MDL）。

#### 表锁

表锁的语法是 `lock tables ... read/write`。与 `FTWRL` 类似，可以通过 `unlock tables` 主动释放锁，或在客户端断开时自动释放。需要注意的是，`lock tables` 语法不仅限制其他线程的读写操作，还限定了本线程的操作对象。

例如，在线程 A 中执行 `lock tables t1 read, t2 write;`，则其他线程对 `t1` 的写操作和对 `t2` 的读写操作都会被阻塞。同时，线程 A 在执行 `unlock tables` 之前，也只能执行读 `t1` 和读写 `t2` 的操作。

对于支持行锁的引擎（如 InnoDB），通常不使用 `lock tables` 命令来控制并发，因为锁住整个表的影响面较大。

#### 元数据锁（MDL）

MDL 是在访问表时自动加上的锁，不需要显式使用。MDL 的作用是保证读写的正确性。例如，如果一个查询正在遍历一个表中的数据，而另一个线程在此期间对表结构进行了变更（如删除一列），那么查询结果将与表结构不匹配，这是不允许的。

### 总结

本文介绍了 MySQL 中的全局锁和表级锁，并讨论了它们的应用场景和潜在问题。全局锁主要用于全库逻辑备份，而表级锁则包括表锁和 MDL，分别用于控制表级别的并发访问和保证读写的正确性。理解这些锁机制有助于更好地管理和优化数据库的并发性能。