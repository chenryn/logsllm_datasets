### 实验：体验事件的产生条件和作用

可以通过以下步骤来感受该事件的产生条件及其作用。

1. **编译 WMI SDK 中的 ClassProv 项目**：
   - 在 `chap31\ClassProv` 目录下找到示例项目的副本并进行编译。

2. **注册 ClassProv.DLL**：
   - 打开命令行窗口，切换到编译好的 `ClassProv.DLL` 文件所在的目录。
   - 使用 `regsvr32 classprov.dll` 命令对其进行注册。

3. **向 CIM 对象管理器注册提供器**：
   - 切换到项目文件所在目录，确认存在 `ClassProv.MOF` 文件。
   - 使用 `mofcomp classprov.mof` 命令将提供器注册到 CIM 对象管理器。

4. **验证类的存在**：
   - 运行 WbemTest 工具，连接到 `\root\default` 命名空间。
   - 选择 "Open Class" 按钮并输入 `ClassProvSamp`，确认该类已经存在。

5. **停止 WMI 服务**：
   - 请在测试机器上执行此操作以避免意外损失。
   - 可以通过服务面板或在命令行中键入 `net stop winmgmt` 来停止 WMI 服务。

6. **删除已注册的 DLL 文件**：
   - 删除刚刚注册的 `ClassProv.DLL` 文件。

7. **运行脚本**：
   - 切换命令行窗口的当前目录到 `chap31\script\`。
   - 使用 `cscript loadfailure.vbs` 命令执行脚本。如果成功，应看到如下屏幕输出：

   ```plaintext
   c:\dig\dbg\author\code\chap31\script>cscript loadfailure.vbs
   Microsoft (R) Windows Script Host Version 5.6
   Copyright (C) Microsoft Corporation 1996-2001. All rights reserved.
   Waiting for events...
   ```

8. **再次打开类**：
   - 重复第 4 步的操作，尝试打开 `ClassProvSamp` 类。
   - 由于 `ClassProvSamp` 类的提供器模块已在第 6 步被删除，Wbemtest 会显示一个错误对话框（如图 31-17 所示）。

   **图 31-17**：加载提供器失败对话框

9. **观察脚本输出**：
   - 观察运行脚本的命令行窗口，应看到类似以下的输出：

   ```plaintext
   -----------------------------------------------------------
   Msft_WmiProvider_LoadOperationFailureEvent event has occurred.
   ServerName: WINMGMT Sample Class Provider
   InProcServer: True
   InProcServerPath: c:\dig\dbg\author\code\chap31\ClassProv\Debug\classprov.dll
   ThreadingModel: 1
   ResultCode: -2147024770
   ```

   - 结果码 `-2147024770` 对应的 16 进制值为 `0x8007007E`，使用 Error Lookup 工具可以查到其含义为 “The specified module could not be found.”，即没有找到指定的模块。

### 事件消耗器提供器诊断类

前面我们介绍过，事件消耗器提供器的作用是判断应该使用哪一个永久的（permanent）事件消耗器来处理给定的事件，即将物理消耗器映射到逻辑消耗器。与普通 WMI 提供器一样，事件消耗器提供器也是以 COM 服务器的形式工作的，WMI 会根据需要动态加载这些提供器。

为了调试事件消耗器提供器，WMI 设计了四个事件类来报告事件消耗器提供器的加载（`MSFT_WmiConsumerProviderLoaded`）、卸载（`MSFT_WmiConsumerProviderUnloaded`）以及成功激活（`MSFT_WmiConsumerProviderSinkLoaded`）和解除（`MSFT_WmiConsumerProviderSinkUnloaded`）事件接插点（sink）对象。这四个事件类都派生自 `MSFT_WmiProviderEvent`。

### 本章总结

本章较为全面地介绍了 Windows 系统中最广泛应用的管理机制——WMI。我们的主要目的有三：

1. **调试资源**：尽管 WMI 主要是一种管理机制，但由于它建立了强大的访问受管对象的设施和丰富的工具，也为调试受管对象提供了宝贵的资源。Windows 系统的许多重要部件和服务都支持 WMI，使用 WMI 可以探测这些部件和服务的内部信息，接收事件，或执行操作。

2. **可维护性和可调试性**：从软件开发的角度来看，支持 WMI 有助于提高软件的可维护性和可调试性（Debuggability）。本章介绍 WMI 的工作原理也是为本书第五部分讨论软件的可调试性奠定基础。

3. **操作系统理解**：WMI 是 Windows 操作系统的一个重要部分，学习和深入理解 WMI 是全面理解 Windows 系统的一门必修课。熟悉 WMI 的基础部件和提供器，熟练使用 WMI 脚本和工具可以丰富我们的知识库，并有助于提高调试技能。

### 补编内容

#### CPU 异常详解

本书第三章介绍了 IA-32 CPU 的异常，并通过表 3-2 列出了 IA-32 处理器迄今为止所定义的所有异常。本附录将以向量号为顺序逐一介绍每一种异常，详细描述其属性：

- **向量号**：该异常的向量号。
- **异常类型**：即该异常属于错误类异常、陷阱类异常还是中止类异常。
- **相关处理器**：最早引入该异常的处理器，以及其它处理器对该异常的实现情况。
- **描述**：该异常的产生原因、用途等信息。
- **错误代码**：CPU 在产生某些异常时，会向栈中压入一个 32 位的错误代码。
- **保存的程序指针**：CPU 在产生异常时会向栈中压入程序指针。
- **程序状态变化**：该异常对程序状态的影响，是否可以安全地恢复重新执行。

本附录的内容主要参考了 IA-32 手册和 Tom Shanley 所著的《The Unabridged Pentium 4》一书。

##### C.1 除零异常（#DE）

- **向量号**：0
- **异常类型**：错误（Fault）
- **引入该异常的处理器**：8088 最早引入该异常，其后的 8086、80286 以及所有 IA-32 处理器都实现了该异常。
- **描述**：CPU 在执行 `DIV`（无符号除法）或 `IDIV`（带符号除法）指令时，如果检测到以下情况则会产生该异常：
  - 除数为 0。
  - 商值太大，无法用目标运算符表示出来。
- **错误代码**：CPU 不会向栈中放入错误代码。
- **保存的程序指针**：栈中保存的 CS 和 EIP 值指向的是导致该异常的指令。
- **程序状态变化**：该异常不会改变程序状态，CPU 会将处理器状态恢复到执行该指令之前的状态。所以当错误情况被纠正后（比如除数改为非 0）可以安全地重新执行。

##### C.2 调试异常（#DB）

- **向量号**：1
- **异常类型**：陷阱（Trap）或错误（Fault），异常处理例程可以根据 DR6 和其它调试寄存器的内容判断，参见第四章的表 4-2。
- **引入该异常的处理器**：8088 最早引入该异常，其后的 8086、80286 以及所有 IA-32 处理器都实现了该异常。
- **描述**：此异常表示 CPU 已经检测到一个或多个调试事件的触发条件被满足。
- **错误代码**：CPU 不会向栈中放入错误代码。
- **保存的程序指针**：
  - 对于错误类异常，栈中保存的 CS 和 EIP 值指向的是导致该异常的指令。
  - 对于陷阱类异常，栈中保存的 CS 和 EIP 值指向的是导致异常指令执行完接下来该执行的指令。注意，CS 和 EIP 指向的不一定是地址相邻的下一条指令，比如如果在执行 `JMP` 指令时发生了陷阱异常，那么 CS：EIP 指向的是 `JMP` 指令的目标地址。
- **程序状态变化**：
  - 错误类异常不会改变程序状态，CPU 会将处理器状态恢复到执行该指令之前的状态。所以程序可以安全地从异常处理例程返回并正常执行。
  - 陷阱类调试异常伴随有程序状态变化，因为在异常产生前正在执行指令或任务切换会执行完毕。不过，程序状态不会被破坏，可以继续安全地执行。

##### C.3 不可屏蔽中断（NMI）

- **向量号**：2
- **异常类型**：不属于异常，属于中断。
- **引入该异常的处理器**：8088 最早引入该中断（不是异常），其后的 8086、80286 以及所有 IA-32 处理器都实现了该中断。
- **描述**：硬件中断，是由于外部硬件通过 CPU 的 NMI 管脚发出中断请求或者系统的 I/O APIC 向 CPU 内的本地 APIC 发送了 NMI 中断消息。
- **错误代码**：N/A（不适用）
- **保存的程序指针**：栈中保存的 CS 和 EIP 值指向的是响应中断前接下来要执行的那条指令。
- **程序状态变化**：CPU 总是在指令边界（instruction boundary）响应 NMI 中断，也就是当 CPU 接收到 NMI 时如果有指令正在执行，那么它会执行完正在执行的指令。因此，当中断处理程序处理结束后可以安全地返回到被中断的程序或任务继续执行。

##### C.4 断点异常（#BP）

- **向量号**：3
- **异常类型**：陷阱（Trap）
- **引入该异常的处理器**：8088 最早引入该异常，其后的 8086、80286 以及所有 IA-32 处理器都实现了该异常。
- **描述**：当 CPU 执行 `INT 3` 指令时会产生此异常。`INT n`（n=3）指令也会导致该异常，但是二者的机器码不同，功能也有微小差异。
- **错误代码**：CPU 不会向栈中放入错误代码。
- **保存的程序指针**：栈中保存的 CS 和 EIP 值指向的是 `INT 3` 指令后面要执行的那条指令。
- **程序状态变化**：尽管栈中的 CS 和 EIP 指向的是下一条指令，但是因为 `INT 3` 指令不会影响任何寄存器或内存数据，程序状态并没有实质性变化，所以调试器可以先将被 `INT 3` 替换掉的指令首字节恢复回来，再将 EIP 指针减一，然后恢复程序执行。程序恢复执行后，执行的是被 `INT 3` 替换的那条指令。

##### C.5 溢出异常（#OF）

- **向量号**：4
- **异常类型**：陷阱（Trap）
- **引入该异常的处理器**：8088 最早引入该异常，其后的 8086、80286 以及所有 IA-32 处理器都实现了该异常。
- **描述**：当 CPU 执行 `INTO` 指令时，如果标志寄存器的 OF 标志为 1（即 EFlags[OF]=1），那么便会产生此异常。
- **错误代码**：无
- **保存的程序指针**：栈中保存的 CS 和 EIP 值指向的是 `INTO` 指令后面要执行的那条指令。
- **程序状态变化**：尽管栈中的 CS 和 EIP 指向的是下一条指令，但是因为 `INTO` 指令不会影响任何寄存器或内存数据，程序状态并没有实质性变化，所以可以安全地恢复执行原来的程序。

##### C.6 数组越界异常（#BR）

- **向量号**：5
- **异常类型**：错误（Fault）
- **引入该异常的处理器**：80286 最早引入该异常，其后的所有 IA-32 处理器都实现了该异常。
- **描述**：当 CPU 执行 `BOUND` 指令时，如果数组的索引值不在指定的数组边界（bound）内，那么便会产生本异常（BOUND Range Exceeded Exception）。
- **错误代码**：无
- **保存的程序指针**：栈中保存的 CS 和 EIP 值指向的是导致异常的 `BOUND` 指令。
- **程序状态变化**：该异常不会伴有程序状态变化，`BOUND` 指令的操作数也不会被修改。从异常处理例程返回后会重新执行 `BOUND` 指令。因此如果错误情况没有消除，那么会陷入“重新执行 `BOUND` 指令导致异常，异常返回再重新执行 `BOUND` 指令”的“死”循环。

##### C.7 非法操作码异常（#UD）

- **向量号**：6
- **异常类型**：错误（Fault）
- **引入该异常的处理器**：80286 最早引入该异常，其后的所有 IA-32 处理器都实现了该异常，而且导致该异常的情况也在逐渐增加。
- **描述**：以下情况会导致此异常：
  - 试图执行无效或保留的操作码（OpCode）。一个例外是，尽管 D6 和 F1 是 IA-32 架构保留的未定义操作码，但它们不会导致异常。
  - 指令的操作数类型与操作码不匹配，比如 `LEA`（Load Effective Address）指令的源操作数不是内存地址（偏移部分）。
  - 在不支持 MMX 技术或 SSE/SSE2/SSE3 扩展的处理器上试图执行 MMX 或 SSE/SSE2/SSE3 指令。执行这些指令前应该先使用 `CPUID` 指令判断处理器是否支持 MMX（EDX 的位 23）、SSE（EDX 的位 25）/SSE2（EDX 的位 26）/SSE3（ECX 的位 0）。
  - 当 CR4 的 OSFXSR 位（位 9）为 0 时，试图执行 SSE/SSE2/SSE3 指令。OSFXSR 位的含义是操作系统对 `FXSAVE` 和 `FXRSTOR` 指令的支持。但此规则不包括以下 SSE/SSE2/SSE3 指令：`MASKMOVQ`、`MOVNTQ`、`MOVNTI`、`PREFETCHh`、`SFENCE`、`LFENCE`、`MFENCE` 和 `CLFLUSH`；或 64 位版本的 `PAVGB`、`PAVGW`、`PEXTRW`、`PINSRW`、`PMAXSW`、`PMAXUB`、`PMINSW`、`PMINUB`、`PMOVMSKB`、`PMULHUW`、`PSADBW`、`PSHUFW`、`PADDQ` 和 `PSUBQ`。
  - 当 CR4 的 OSXMMEXCPT 位（位 10）为 0 时，试图执行导致 SIMD 浮点异常的 SSE/SSE2/SSE3 指令。OSXMMEXCPT 位的含义是操作系统对非屏蔽 SIMD 浮点异常（Unmasked SIMD Floating-Point Exception，简称 #XF）的支持。操作系统设置此位以表示已经准备好处理 #XF 异常的例程。如果此位没被设置，则处理器会产生 #UD 异常。
  - 执行了 `UD2` 指令。值得注意的是即使是 `UD2` 指令导致了本异常，栈中保存的指令指针仍然是指向 `UD2` 指令。
  - 在不可以锁定的指令前或可以锁定但目标操作数不是内存地址的指令前使用了锁前缀（Lock Prefix）。