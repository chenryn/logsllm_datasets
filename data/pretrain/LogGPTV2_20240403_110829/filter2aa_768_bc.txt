Loop 
可以通过如下实验来感受该事件的产生条件和作用。 
1. 
编译 WMI SDK 中的 ClassProv 项目，chap31\ClassProv 目录下有该示例的一个副本。 
2. 
开启一个命令行窗口，转到编译好的 ClassProv.DLL 文件所在目录，键入 regsvr32 
classprov.dll 对其进行注册。 
3. 
转到项目文件所在目录，确认存在 ClassProv.MOF 文件，然后键入 mofcomp 
classprov.mof 向 CIM 对象管理器注册此提供器。 
4. 
运行 WbemTest 工具，连接到\root\default 命名空间，然后选择 Open Class 按钮并键入
ClassProvSamp，确认该类已经存在。 
5. 
停止 WMI 服务（请在测试机器上实验，以免导致意外损失），可以在服务面板操作，
也可以在命令行键入 net stop winmgmt。 
6. 
将刚刚注册的 ClassProv.DLL 文件删除。 
7. 
将命令行窗口的当目录切换到 chap31\script\，然后键入 cscript loadfailure.vbs 执行该
脚本。如果成功，应该看到如下屏幕输出。 
c:\dig\dbg\author\code\chap31\script>cscript loadfailure.vbs 
Microsoft (R) Windows Script Host Version 5.6 
Copyright (C) Microsoft Corporation 1996-2001. All rights reserved. 
Waiting for events ... 
8. 
重复第 4 步的打开 ClassProvSamp 类操作，因为 ClassProvSamp 类的提供器模块已经
仔第 6 步被删除，所以 Wbemtest 会显示出图 31-17 所示的错误对话框。 
图 31-17  加载提供器失败对话框 
9. 
此时观察运行脚本的命令行窗口，应该看到类似如下的输出： 
----------------------------------------------------------- 
Msft_WmiProvider_LoadOperationFailureEvent event has occurred. 
ServerName: WINMGMT Sample Class Provider 
InProcServer: True 
InProcServerPath: c:\dig\dbg\author\code\chap31\ClassProv\Debug\classprov.dll 
ThreadingModel: 1 
ResultCode: -2147024770 
结果码-2147024770 对应的 16 进制值为 0x8007007E，使用 Error Lookup 工具可以查
到其含义为 “The specified module could not be found.”，即没有找到指定的模块。 
事件消耗器提供器诊断类
事件消耗器提供器诊断类
事件消耗器提供器诊断类
事件消耗器提供器诊断类 
前 面 我 们 介 绍 过 ， 事 件 消 耗 器 提 供 器 的 作 用 是 判 断 应 该 使 用 哪 一 个 永 久 的
（permanent）事件消耗器来处理给定的事件，也就是将物力消耗器映射到逻辑消耗器。
与普通 WMI 提供器一样，事件消耗器提供器也是以 COM 服务器的形式工作的，WMI 会
根据需要动态加载这些提供器。为了调试事件消耗器提供器，WMI 设计了四个事件类来
《软件调试》补编 
- 109 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
报 告 事 件 消 耗 器 提 供 器 的 加 载 （ MSFT_WmiConsumerProviderLoaded ）、 卸 载
（ MSFT_WmiConsumerProviderLoaded ） 以 及 成 功 激 活 （ MSFT_WmiConsumer- 
ProviderSinkLoaded）和解除（MSFT_WmiConsumerProviderSinkUnloaded）事件接插点
（sink）对象。这四个事件类都派生自 MSFT_WmiProviderEvent。 
31.6  本章总结 
本 章 花 较 大 的 篇 幅 比 较 全 面 的 介 绍 Windows 系 统 中 应 用 最 广 泛 的 管 理
（administration）机制——WMI。我们的主要目的有三： 
第一、尽管 WMI 主要是一种管理机制，由于它所建立的访问受管对象的强大设施和
丰富工具也为调试受管对象提供了宝贵的资源。Windows 系统的很多重要部件和很多系统
服务都支持 WMI（参见 31.4 节），使用 WMI 可以探测这些部件和服务的内部信息，接收
事件，或者执行操作。 
第二、从软件开发的角度来看，支持 WMI 有助于提高软件的可维护性和可调试性
（Debuggability）。本章介绍 WMI 的工作原理也是为本书第 5 部分讨论软件的可调试性奠
定基础。 
第三、WMI 是 Windows 操作系统的一个重要部分，学习和深入理解 WMI 是全面理
解 Windows 系统的一门必修课。熟悉 WMI 的基础部件和提供器，熟练使用 WMI 脚本和
工具可以丰富我们的知识库、有助于提高调试技能。 
《软件调试》补编 
- 110 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
补编内容
补编内容
补编内容
补编内容 9 CPU 异常逐一描述
异常逐一描述
异常逐一描述
异常逐一描述 
补编说明： 
这一章本来是《软件调试》的第一个附录，描述的是 CPU 的每个异常。 
《软件调试》的一条主线就是异常，全书按从底层到顶层的顺序反复介绍了
异常。CPU 的异常（有时也叫硬件异常）是很多程序员感觉陌生的，因此《软
件调试》的第 2 篇对此做了比较全面的介绍。这个附录是配合第 2 篇内容的，
更详细的介绍了每一种 CPU 异常。 
在邻近出版进行编辑时，这一附录被删除了，目的是为了控制篇幅，删除
的原因主要是这一内容的难度比较大，一般的程序员可能望而却步，不会
仔细阅读。 
《软件调试》补编 
- 111 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
CPU 异常详解 
本书第 3 章介绍了 IA-32 CPU 的异常，并通过表 3-2 列出了 IA-32 处理器迄今为止所
定义的所有异常。本附录将以向量号为顺序逐一介绍每一种异常，详细描述它的以下属性： 
向量号：该异常的向量号。 
异常类型：即该异常属于错误类异常、陷阱类异常还是中止类异常。 
相关处理器：最早引入该异常的处理器，以及其它处理器对该异常的实现情况。 
描述：该异常的产生原因、用途等信息。 
错误代码：CPU 在产生某些异常时，会向栈中压入一个 32 位的错误代码。 
保存的程序指针：CPU 在产生异常时会向栈中压入程序指针。 
程序状态变化：该异常对程序状态的影响，是否可以安全的恢复重新执行。 
本附录的内容主要参考了 IA-32 手册和 Tom Shanley 所著的《The Unabridged Pentium 
4》一书。 
C.1  除零异常（#DE） 
向量号：0 
异常类型：错误（Fault） 
引入该异常的处理器：8088 最早引入该异常，其后的 8086、80286 以及所有 IA-32
处理器都实现了该异常。 
描述：CPU 在执行 DIV（无符号除法）或 IDIV（带符号除法）指令时如果检测到以
下情况则会产生该异常： 
除数为 0。 
商值太大，无法用目标运算符表示出来。 
错误代码：CPU 不会向栈中放入错误代码。 
保存的程序指针：栈中保存的 CS 和 EIP 值指向的是导致该异常的指令。 
程序状态变化：该异常不会改变程序状态，CPU 会将处理器状态恢复到执行该指令
之前的状态。所以当错误情况被纠正后（比如除数改为非 0）可以安全的重新执行。 
C.2  调试异常（#DB） 
向量号：1 
附  录  C 
《软件调试》补编 
- 112 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
异常类型：陷阱（Trap）或错误（Fault），异常处理例程可以根据 DR6 和其它调试寄
存器的内容判断，参见第 4 章的表 4-2。 
引入该异常的处理器：8088 最早引入该异常，其后的 8086、80286 以及所有 IA-32
处理器都实现了该异常。 
描述：此异常表示 CPU 已将检测一或多个调试事件的触发条件被满足。 
错误代码：CPU 不会向栈中放入错误代码。 
保存的程序指针：对于错误类异常，栈中保存的 CS 和 EIP 值指向的是导致该异常的
指令。 
对于陷阱类异常，栈中保存的 CS 和 EIP 值指向的是导致异常指令执行完接下来该执
行的指令。注意，CS 和 EIP 指向的不一定是地址相邻的下一条指令，比如如果在执行 JMP
指令时发生了陷阱异常，那么 CS：EIP 指向的是 JMP 指令的目标地址。 
程序状态变化：错误类异常不会改变程序状态，CPU 会将处理器状态恢复到执行该
指令之前的状态。所以程序可以安全的从异常处理例程返回并正常执行。 
陷阱类调试异常伴随有程序状态变化，因为在异常产生前正在执行指令或任务切换会
执行完毕。不过，程序状态不会被破坏，可以继续安全的执行。 
C.3  不可屏蔽中断（NMI） 
向量号：2 
异常类型：不属于异常，属于中断。 
引入该异常的处理器：8088 最早引入该中断（不是异常），其后的 8086、80286 以及所
有 IA-32 处理器都实现了该中断。 
描述：硬件中断，是由于外部硬件通过 CPU 的 NMI 管脚发出中断请求或者系统的 I/O 
APIC 向 CPU 内的本地 APIC 发送了 NMI 中断消息。 
错误代码：N/A（不适用） 
保存的程序指针：栈中保存的 CS 和 EIP 值指向的是响应中断前接下来要执行的那条
指令。 
程序状态变化：CPU 总是在指令边界（instruction boundary）响应 NMI 中断，也就是
当 CPU 接收到 NMI 时如果有指令正在执行，那么它会执行完正在执行的指令。因此，当
中断处理程序处理结束后可以安全的返回到被中断的程序或任务继续执行。 
C.4  断点异常（#BP） 
向量号：3 
异常类型：陷阱（Trap） 
引入该异常的处理器：8088 最早引入该异常，其后的 8086、80286 以及所有 IA-32 处
理器都实现了该异常。 
描述：当 CPU 执行 INT 3 指令时会产生此异常。INT n（n=3）指令也会导致该异常，
但是二者的机器码不同，功能也有微小差异。 
《软件调试》补编 
- 113 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
INT 3 指令是常用的软件断点的基础，当用户在调试器中设置断点时，调试器会用 INT 
3 指令替换掉断点位置的那条指令的第一个字节。参见本章第 2 节。 
错误代码：CPU 不会向栈中放入错误代码。 
保存的程序指针：栈中保存的 CS 和 EIP 值指向的是 INT 3 指令后面要执行的那条指令。 
程序状态变化：尽管栈中的 CS 和 EIP 指向的是下一条指令，但是因为 INT 3 指令不会
影响任何寄存器或内存数据，程序状态并没有实质性变化，所以调试器可以先将被 INT 3
替换掉的指令首字节恢复回来，再将 EIP 指针减一，然后恢复程序执行。程序恢复执行后，
执行的是被 INT 3 替换的那条指令。 
C.5  溢出异常（#OF） 
向量号：4 
异常类型：陷阱（Trap） 
引入该异常的处理器：8088 最早引入该异常，其后的 8086、80286 以及所有 IA-32 处
理器都实现了该异常。 
描述：当 CPU 执行 INTO 指令时，如果标志寄存器的 OF 标志为 1（即 EFlags[OF]=1），
那么便会产生此异常。 
一些算术指令（如 ADD 和 SUB）使用 OF（Overflow Flag）标志表示在进行带符号
整数计算时发生溢出（太大的整数或太小的负数，目标操作数无法容纳），使用 CF（Carry 
Flag）位表示在进行无符号整数计算时发生溢出（有进位或借位）。在进行带符号算术计
算时，程序可以直接测试 OF 标志判断是否有溢出发生，也可以使用 INTO 指令。INTO
指令的优点是如果有溢出发生，CPU 会自动调用异常处理程序来进行处理。 
错误代码：无 
保存的程序指针：栈中保存的 CS 和 EIP 值指向的是 INTO 指令后面要执行的那条指令。 
程序状态变化：尽管栈中的 CS 和 EIP 指向的是下一条指令，但是因为 INTO 指令不会
影响任何寄存器或内存数据，程序状态并没有实质性变化，所以可以安全的恢复执行原来
的程序。 
C.6  数组越界异常（#BR） 
向量号：5 
异常类型：错误（Fault） 
引入该异常的处理器：80286 最早引入该异常，其后的所有 IA-32 处理器都实现了该异
常。 
描述：当 CPU 执行 BOUND 指令时，如果数组的索引值不在指定的数组边界（bound）
内，那么便会产生本异常（BOUND Range Exceeded Exception）。 
BOUND 指令需要两个操作数，第一个操作数是装有数组索引值的寄存器，第二个操
作数一个指向数组高低边界的内存位置（下边界在前）。如果将数组的高低边界都存贮在
数组本身的前面，那么只要从数组开始处偏移一个常量就可以得到数组边界的位置，因为
数组地址通常已经在寄存器中，这样便避免了分别取数组上下边界有效地址的总线操作。 
《软件调试》补编 
- 114 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
但对于 Windows 这样的操作系统环境，因为所有异常都首先交给操作系统的异常处
理程序来处理，然后如果异常来自用户态，那么再分发给用户态的应用程序。这个过程所
花费的代价远远超过了 BOUND 指令可以节约的开销，所以 BOUND 指令在今天的软件产
品中应用并不多。 
错误代码：无 
保存的程序指针：栈中保存的 CS 和 EIP 值指向的是导致异常的 BOUND 指令。 
程序状态变化：该异常不会伴有程序状态变化，BOUND 指令的操作数也不会被修改。
从异常处理例程返回后会重新执行 BOUND 指令。因此如果错误情况没有消除，那么会陷
入“重新执行 BOUND 指令导致异常，异常返回再重新执行 BOUND 指令”的“死”循环。 
C.7  非法操作码异常（#UD） 
向量号：6 
异常类型：错误（Fault） 
引入该异常的处理器：80286 最早引入该异常，其后的所有 IA-32 处理器都实现了该异
常，而且导致该异常的情况也在逐渐增加。 
描述：以下情况会导致此异常： 
试图执行无效或保留的操作码（OpCode）。一个例外是，尽管 D6 和 F1 是 IA-32 架构
保留的未定义操作码，但它们不会导致异常。 
指令的操作数类型与操作码不匹配，比如 LEA（Load Effective Address）指令的源操
作数不是内存地址（偏移部分）。 
在不 支持 MMX 技术或 SSE/SSE2/SSE3 扩展 的处 理器 上试 图执行 MMX 或
SSE/SSE2/SSE3 指令。执行这些指令前应该先使用 CPUID 指令判断处理器是否支持
MMX（EDX 的位 23）、SSE（EDX 的位 25）/SSE2（EDX 的位 26）/SSE3（ECX 的
位 0）。 
当 CR4 的 OSFXSR 位（位 9）为 0 时，试图执行 SSE/SSE2/SSE3 指令。OSFXSR 位
的含义是操作系统对 FXSAVE 和 FXRSTOR 指令的支持。但此规则不包括以下
SSE/SSE2/SSE3 指令：MASKMOVQ、MOVNTQ、MOVNTI、PREFETCHh、SFENCE、
LFENCE、MFENCE 和 CLFLUSH；或 64 位版本的 PAVGB、PAVGW、PEXTRW、
PINSRW、PMAXSW、PMAXUB、PMINSW、PMINUB、PMOVMSKB、PMULHUW、
PSADBW、PSHUFW、PADDQ 和 PSUBQ。 
当 CR4 的 OSXMMEXCPT 位（位 10）为 0 时，试图执行导致 SIMD 浮点异常的
SSE/SSE2/SSE3 指令。OSXMMEXCPT 位的含义是操作系统对非屏蔽 SIMD 浮点异常
（Unmasked SIMD Floating-Point Exception，简称#XF）的支持。操作系统设置此位以
表示已经准备好处理#XF 异常的例程。如果此位没被设置，则处理器会产生#UD 异常。 
执行了 UD2 指令。值得注意的是即使是 UD2 指令导致了本异常，栈中保存的指令指
针仍然是指向 UD2 指令。 
在不可以锁定的指令前或可以锁定但目标操作数不是内存地址的指令前使用了