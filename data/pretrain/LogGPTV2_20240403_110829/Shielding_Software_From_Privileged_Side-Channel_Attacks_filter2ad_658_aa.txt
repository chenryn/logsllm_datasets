title:Shielding Software From Privileged Side-Channel Attacks
author:Xiaowan Dong and
Zhuojia Shen and
John Criswell and
Alan L. Cox and
Sandhya Dwarkadas
Shielding Software From Privileged 
Side-Channel Attacks
Xiaowan Dong, Zhuojia Shen, and John Criswell, University of Rochester;  
Alan L. Cox, Rice University; Sandhya Dwarkadas, University of Rochester
https://www.usenix.org/conference/usenixsecurity18/presentation/dong
This paper is included in the Proceedings of the 
27th USENIX Security Symposium.
August 15–17, 2018 • Baltimore, MD, USA
978-1-939133-04-5
Open access to the Proceedings of the 27th USENIX Security Symposium is sponsored by USENIX.Shielding Software From Privileged Side-Channel Attacks
Xiaowan Dong
University of Rochester
Zhuojia Shen
University of Rochester
John Criswell
University of Rochester
Alan L. Cox
Rice University
Sandhya Dwarkadas
University of Rochester
Abstract
Commodity operating system (OS) kernels, such as Win-
dows, Mac OS X, Linux, and FreeBSD, are suscepti-
ble to numerous security vulnerabilities. Their mono-
lithic design gives successful attackers complete access
to all application data and system resources. Shield-
ing systems such as InkTag, Haven, and Virtual Ghost
protect sensitive application data from compromised OS
kernels. However, such systems are still vulnerable to
side-channel attacks. Worse yet, compromised OS ker-
nels can leverage their control over privileged hardware
state to exacerbate existing side channels; recent work
has shown that a compromised OS kernel can steal entire
documents via side channels.
This paper presents defenses against page table and
last-level cache (LLC) side-channel attacks launched by
a compromised OS kernel. Our page table defenses re-
strict the OS kernel’s ability to read and write page table
pages and defend against page allocation attacks, and our
LLC defenses utilize the Intel Cache Allocation Technol-
ogy along with memory isolation primitives. We proto-
type our solution in a system we call Apparition, building
on an optimized version of Virtual Ghost. Our evalua-
tion shows that our side-channel defenses add 1% to 18%
(with up to 86% for one application) overhead to the op-
timized Virtual Ghost (relative to the native kernel) on
real-world applications.
1
Introduction
Bugs in commodity operating system (OS) kernels, such
as Windows [60], Mac OS X [64], Linux [15], and
FreeBSD [54], render them vulnerable to security attacks
such as buffer overﬂows and information leaks. Further-
more, their monolithic architecture provides high perfor-
mance but poor protection: a single vulnerability may
give an attacker control over the entire OS kernel, allow-
ing the attacker to steal and corrupt any data on the sys-
tem. To reduce the size of the trusted computing base
(TCB) on commodity systems, software solutions (such
as InkTag [40] and Virtual Ghost [26]) and hardware so-
lutions (such as Intel SGX [42], ARM TrustZone [11],
and Haven [12]) prevent the OS kernel from reading and
corrupting application data.
Despite these protections, attackers can steal applica-
tion data using side-channel attacks that exploit shared
hardware resources [38] or interactions between applica-
tion code and the OS kernel [73]. Worse yet, a compro-
mised OS kernel can exacerbate these side channels by
manipulating software state, e.g., via CPU scheduling,
and by conﬁguring privileged hardware resources, e.g.,
the processor’s interrupt timer and memory management
unit (MMU) [38, 73]. Shielding systems must mitigate
side-channel attacks if they are to protect the conﬁden-
tiality of application data.
In this paper, we present methods to defend against
page table and last-level cache (LLC) side-channel at-
tacks launched by a compromised OS kernel. Our meth-
ods require no changes to existing processors. A mali-
cious OS kernel may infer victims’ memory access pat-
terns and in turn recover secret information via tracing
page table updates or page faults, or measuring the vic-
tims’ cache usage patterns [43, 52, 63, 73]. To eliminate
page table side channels, our key insight is that trusted
software should prevent the OS kernel from reading or
manipulating page table entries (PTEs) for memory hold-
ing application secrets. To thwart LLC side-channel at-
tacks, we leverage Intel’s Cache Allocation Technology
(CAT) [4] in concert with techniques that prevent physi-
cal memory sharing.
Since our solution must prevent physical memory
sharing, control conﬁguration of the Intel CAT feature,
and prevent reading and writing of page table pages,
we implement our solution by enhancing Virtual Ghost.
Virtual Ghost [26] already controls an OS kernel’s ac-
cess to page tables and to privileged hardware regis-
ters.
It also provides private memory in which an ap-
plication can store sensitive information and prevents
USENIX Association
27th USENIX Security Symposium    1441
sharing of physical memory containing application se-
crets. As Virtual Ghost is based on Secure Virtual Ar-
chitecture (SVA) [28], we can combine our solution with
other security policies enforced by SVA (such as memory
safety [27,28]). Our solution does not change the Virtual
Ghost paravirtualization interface and therefore requires
no changes to existing SVA software and hardware.
We prototype our changes in a new version of Virtual
Ghost dubbed Apparition. Apparition is optimized rela-
tive to the original Virtual Ghost by using Intel Memory
Protection Extensions (MPX) [4] to reduce software fault
isolation (SFI) overheads and by eliminating serializing
instructions (which reduce instruction-level parallelism)
added by the original Virtual Ghost to control page table
access.
To summarize, our contributions are as follows:
• We show that using MPX for SFI and eliminating
serializing instructions when accessing page table
pages improves performance by up to 2× relative to
the original Virtual Ghost.
• We design,
implement, and evaluate a defense
against page table side-channel attacks in Appari-
tion that leverages Apparition’s control over the
page table pages.
• We show how Apparition’s control over privileged
hardware state can partition the LLC to defeat cache
side-channel attacks. Our defense combines Intel’s
CAT feature [4] (which cannot securely partition
the cache by itself) with existing memory protec-
tions from Virtual Ghost [26] to prevent applica-
tions from sharing cache lines with other applica-
tions or the OS kernel.
• We present a design that eliminates side-channel at-
tacks that infer code memory accesses by control-
ling interrupt, trap, and system call dispatch, con-
text switching, and native code generation.
• We evaluate the performance of Apparition, study
the sources of its overheads, and compare it to the
performance of Virtual Ghost enhanced with our
new optimizations. Using native FreeBSD as the
baseline, we ﬁnd that Apparition adds 1% to 18%
overhead to this version of Virtual Ghost on the real-
world applications we tested except for one real-
world program that experiences up to 86% addi-
tional overhead.
The rest of the paper is organized as follows. Section 2
describes our attack model. Section 3 provides back-
ground on memory management side channels along
with potential/possible attacks. Section 4 provides back-
ground on Virtual Ghost and explains how we improved
its performance. Section 5 describes the design of our
mitigations against page table and cache-based side-
channel attacks, and Section 6 discusses how our work
mitigates some of the recent speculative execution side-
channel attacks. Section 7 describes our prototype im-
plementation. Section 8 presents the results of our ex-
perimental evaluation. Section 9 discusses related work,
and Section 10 summarizes our contributions.
2 Attack Model
Our attack model assumes a strong attacker that controls
the OS kernel and wishes to steal application data. Due to
defenses like Virtual Ghost [26], this attacker cannot di-
rectly read application memory. We assume that the ap-
plication and the libraries that it uses are part of the TCB
for that application’s security policy; that the application
author has taken measures to ensure that the application
and its libraries are safe from direct attack, e.g., by using
security hardening tools [33, 56] or type-safe program-
ming languages, and that the application and its libraries
protect themselves from Iago attacks [17] by distrusting
return values from the OS. We also assume that the at-
tacker cannot gain physical access to the machine. Under
such conditions, side-channel attacks become attractive.
We assume that the attacker will attempt to use side
channels, either via a malicious user-space process or
via malicious code within the OS kernel itself. We fo-
cus on page table side-channel [63, 73] and LLC side
channel [13, 43, 52, 76, 79] attacks launched by software
because of their practicality. These side channels may
leak information on the program’s accesses to data and/or
code memory. Speculative execution side channels are
outside our attack model’s scope, but we discuss how
our system can mitigate some of the Meltdown [49] and
Spectre [46] side channels in Section 6. Side-channel at-
tacks launched by hardware are outside the scope of our
attack model.
3 Side-Channel Attacks
Side-channel attacks exploit implicit information ﬂows
within modern processors [36–38, 43, 52, 58, 63, 69, 73]
to steal sensitive application data. The memory manage-
ment side channels fall into two categories: ones result-
ing from shared architectural states and ones due to the
OS’s control of memory management.
Modern systems share architectural states across pro-
cesses, including translation lookaside buffers (TLBs),
translation caches, CPU caches, memory controllers,
memory channels, DIMMs, and DRAM ranks and banks.
The shared state allows one process to indirectly infer an-
other process’s behavior without direct access to the vic-
1442    27th USENIX Security Symposium
USENIX Association
tim process’s data. Observing which code or data a vic-
tim process accesses allows attackers to infer protected
application data [37, 38, 58, 69].
A compromised OS can leverage its complete control
over privileged processor state to create additional side
channels. For example, the OS can steal a victim pro-
cess’s secret information by tracing page faults, page ta-
ble updates, and cache activities [38, 73]. It can control
system events to alleviate noise and use a side channel to
steal an application’s secret data with a single execution
of the victim’s code [38, 63, 73].
Systems that protect applications from the OS kernel
like Virtual Ghost [26], Overshadow [20], InkTag [40],
and Haven [12] do not mitigate these side channels; the
architectural states are still shared among processes, and
the OS kernel has access to or even controls the page ta-
ble on these systems. In this section, we explain the page
table [63, 73], LLC [43, 52], and instruction tracing [73]
side-channel attacks that Apparition mitigates.
3.1 Page Table Side Channels
Commodity OS kernels can conﬁgure page tables, inter-
cept and process page faults, and query the virtual ad-
dress causing a page fault [15, 54, 60, 64]. With these
abilities, a compromised OS can monitor which virtual
addresses a victim process accesses and, with knowledge
of the application’s source code, infer its secret informa-
tion [73]. Recent research [63, 73] shows that a compro-
mised OS can use its ability to conﬁgure the page table
to launch page fault side-channel attacks to acquire sen-
sitive application data protected by Intel SGX [23, 42].
The attack is powerful enough to steal a document and
outlines of JPEG images from a single execution of ap-
plications protected by InkTag [40] and Haven [12].
More speciﬁcally, the OS kernel can use the methods
below to infer information about an application’s mem-
ory access patterns via the virtual-to-physical address
translation mechanism:
Swapping If the OS kernel cannot directly modify the
PTEs for pages containing private application data, it can
indirectly mark the pages inaccessible if the shielding
system provides the OS with a mechanism to swap pages
out and back in. The OS can use the mechanism to swap
a page out and then infer the memory access patterns of
applications by monitoring when the shielding system re-
quests the OS to swap the page back in. Systems such as
InkTag [40] and Virtual Ghost [26] provide mechanisms
for swapping that prevent direct data theft via encryption
but do not mitigate swapping side channels.
Reading PTEs
If the OS kernel cannot modify PTEs
and cannot swap out pages, it can still infer an applica-
tion’s memory access patterns by reading PTEs as the
application executes. Many processors set a dirty bit in
the PTE when they write to a page. Processors may also
set an accessed bit when they read from or write to a
page. By continually examining PTEs, the OS can learn
when an application ﬁrst reads from and writes to various
memory locations [67]. On multi-processor and multi-
core systems, the compromised OS can scan the page
tables (which reside in memory) on one core while the
application executes on another core.
Inferring Caching of Translations A compromised
OS can potentially infer a victim’s memory access pat-
terns using PRIME+PROBE [8–10, 38, 58, 66, 78] and
FLUSH+RELOAD [13,76,79] cache side-channel attacks
on caches holding virtual-to-physical address transla-
tions. Processors cache virtual-to-physical address trans-
lations in TLBs [3, 4], on-chip translation caches [4, 14],
and CPU caches in the memory hierarchy [2,3]. If a com-
promised OS can use the same virtual-to-physical trans-
lation caches as the application or determine if a PTE
is already cached in the processor’s memory caches, it
can infer information on whether the application has used
that page.
We observe that successfully mitigating page table
side channels requires protecting both the conﬁdentiality
and integrity of virtual-to-physical address translations.
3.2 Cache Side Channels
Cache side-channel attacks infer secret data by measur-
ing the cache usage patterns of the victim [36–38,43,52,
58, 76, 79]. Two common cache side-channel attacks are
PRIME+PROBE [58] and FLUSH+RELOAD [76], both of
which can be applied on private caches [58] and shared
LLC [43, 52].
The PRIME+PROBE attack [58] ﬁlls the monitored
cache set with its own cache lines, busy-waits for a
set time, and measures the time it takes to access its
cache lines again. A longer access time indicates that
the attacker’s cache line has been evicted by a vic-
tim’s access to data mapping to the same cache set.
The FLUSH+RELOAD attack [76] is a variant of the
PRIME+PROBE attack that relies on the victim and the
attacker sharing pages containing target cache lines.
Page sharing is common for shared libraries. The at-
tacker ﬁrst ﬂushes the target cache line e.g., with the
clflush instruction, busy-waits for a set time, and mea-
sures the time it takes to access the target cache line. A
shorter access time indicates that the victim has already
reloaded this target cache line.
LLC side-channel attacks can achieve a high attack
resolution without requiring the attacker and the victim
to share the same core [52]. Cache partitioning [35, 44,