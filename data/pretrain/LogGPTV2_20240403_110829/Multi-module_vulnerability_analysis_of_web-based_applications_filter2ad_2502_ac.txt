’VALUES (\’’ . $user .
’\’, \’’ . $pass . ’\’ )’;
mysql_query($sql);
$_SESSION["loggedin"] = "ok";
header("Location: answer.php");
exit;
}
?>
UserName:
Password:
create.php
| Type
Table: users
+----------+-------------+
| Field
|
+----------+-------------+
| username | varchar(32) |
| password | varchar(32) |
+----------+-------------+
Database schema
Figure 2: Example application.
example through mathematical or string operators; constant depen-
dencies denote that a variable takes a constant value; superglobal
dependencies indicate that a variable takes a value from one of the
superglobal objects in PHP, e.g., from a request or session variable.
Multiple dependencies are composed together until each variable is
reduced to either a constant or a state entity.
Note that an additional set of conditional guards can be discov-
ered during the dependency reconstruction analysis: for example,
a variable used in an operation might assume different values de-
pending on some conditions. Such conditions are added to the set
of conditional guards for the operation.
In our example, the variable _SESSION["loggedin"], used
in the state-related statement at line 21 in create.php, is asso-
ciated with a constant dependency that models the fact that it was
assigned the constant value ok. The conditional guard at line 9 is
reduced to the composition of a call dependency (to the isset()
function) and a superglobal dependency (to the _POST["user"]
variable).
4.3.2 Creating the View
After all sensitive operations and their complete set of condi-
tional guards have been identiﬁed, we translate them into pre-con-
ditions, post-conditions, and sinks. Currently the following predi-
cates are used in pre-conditions: Exist(v) is true if and only if the
entity v is deﬁned in the current application state. Compare(v, u,
op), where v and u are state entities and op is an operator, is true
if and only if the expression v op u is true. MiMoSA currently
supports the operators , =, and their combinations. The Prop-
agate predicate is used in post-conditions: Propagate(v, u, San)
denotes that the value of the entity v is propagated to u applying
the sanitization operations speciﬁed by the set San. For sinks, the
following predicates are used: InSql(v) denotes that the state entity
v is used in a SQL query; Displayed(v) indicates that v is displayed
to the user. Conditions can be combined with the use of and, or,
and not operators.
In addition, we introduce the special Unknown predicate, which
is assumed to be always satisﬁable, to model the cases where we
cannot resolve the dependency of a program variable to a state en-
tity. This happens, for example, when a variable takes its value
from a complex series of calls to functions that we do not model.
As an example of the view creation process, consider the module
create.php of our sample application. MiMoSA summarizes it
into two views, corresponding to the two branches of the condi-
tional statement at line 9. One view (corresponding to the false
branch) has pre-condition not Exist($_POST["user"]) and empty
post-conditions and sinks. The other view (corresponding to the
true branch) has pre-condition Exist($_POST["user"]). The as-
signments introduced by the database analysis step to model the
SQL query at line 19 are modeled with the post-conditions Propa-
gate($_POST["user"], DB_dbname.users.username, {addslashes})
and Propagate($_POST["pass"], DB_dbname.users.password,
{addslashes}). In both cases, the analysis keeps track of the san-
itization operated by the addslashes() function. Finally, the
assignment to the session variable _SESSION["loggedin"] is
modeled with the post-conditions Exist($_SESSION["loggedin"])
and Propagate("ok", $_SESSION["loggedin"], ∅). The complete
set of views for our example application is shown in Table 1.
In a module, the number of extracted views is exponential in the
number of state-related conditional statements. As a consequence,
the view extraction process is slow when dealing with very complex
modules. Therefore, whenever the number of views is determined
to be larger than a certain threshold, MiMoSA can be conﬁgured to
switch to a simpliﬁed view construction approach. In this approach,
instead of generating views for all the paths in the CFG of a mod-
ule, we only generate the views corresponding to a number of paths
sufﬁcient to include all the state- and sink-related operations con-
tained in the module. As a result, all the post-conditions and sinks
of the module are extracted and will be analyzed during the detec-
tion phase. However, since not all their possible combinations are
considered, the simpliﬁed approach might introduce inaccuracies.
4.4 Links Extraction
The last step before starting the inter-module vulnerability anal-
ysis is to extract the links contained in the module and associate
them with the views they belong to.
We parse both PHP and HTML code looking for HTML hyper-
links, form actions and inputs, source attributes of frames, and calls
to the PHP function header()4. We also have a limited support
for link extraction from JavaScript code. If the URL of the link is
dynamic, i.e., it is generated using a block of PHP code, the link
extraction routine tries to determine its runtime value by applying a
dynamic analysis technique similar to the one used in the database
analysis phase.
Once all the links have been extracted, we identify the set of
views to which each link belongs. In order to do this, we determine
the conditional branches in the CFG that must be taken in order for
a link to be shown to the user and we compare these branch expres-
sions with the pre-conditions of the extracted views. Consider, for
instance, the link to answer.php contained in the create.php
module of our example application. Our analysis recognizes that it
is displayed only if the execution follows the true branch of the con-
ditional statement at line 9. .view_0 is the only
view compatible with this execution and, therefore, it is identiﬁed
as the source view of the link.
To correctly model the application workﬂow, in addition to hav-
ing the names of the modules to which one can navigate from a
given view, we also need to extract the set of inputs that are sub-
mitted along the link. In particular, we need to determine which
GET and POST requests parameters are submitted if a user follows
the link. For example, in our sample application, if a user submits
the form at line 28 of the create.php module, the user-provided
parameters user and pass are submitted as a part of the POST
request to create.php.
5.
INTER-MODULE ANALYSIS
In the second phase of our analysis, we connect the views ex-
tracted during the intra-module analysis into a single graph. This
graph models the intended workﬂow of the entire web application.
We then use a model checking technique to identify multi-module
data-ﬂow vulnerabilities and violations of the intended workﬂow.
4The header() function in PHP is commonly used to set the
HTTP Location header to redirect users to a different page.
.view_0
HREF
.view_1
REDIRECT
FORM
HREF
.view_0
REDIRECT
REDIRECT
.view_0
.view_1
Figure 4: Intended workﬂow of our example application.
The main steps of the inter-module phase are shown in Figure 3.
Note that since this phase is built on top of the view abstraction, it
is completely independent of the programming languages in which
the modules are developed.
5.1
Intended Workﬂow
In the ﬁrst step of the inter-module phase, we use the link infor-
mation extracted during the intra-module analysis to connect all the
views of the application into a single graph.
We connect a source view Vi to a target view Vj if Vi contains
a link l that references Vj’s module and the parameters provided
by l satisfy the pre-condition of Vj. In particular, we adopt the
following two rules:
1. If Vj’s pre-condition contains predicates over client-side state
entities, we check that the extracted link satisﬁes these re-
quirements. For example, if the pre-condition requires the
presence of a particular GET parameter, we check that the
link provides a parameter with the required name.
2. If Vj’s pre-condition contains predicates over server-side state
entities, we assume that these predicates are always satisﬁed.
The rationale is that, in general, it is not possible to deter-
mine the extended state of the application considering the
two views in isolation, because it depends on the path that
the user has followed to reach Vi. Therefore, we conserva-
tively assume that the state can satisfy Vj’s pre-condition.
When both conditions are satisﬁed, we assume that there is an
intended path between the two views and we connect them to-
gether. For example, the link in .view_0 (line
20) is connected to the view .view_1 but not to
.view_0. In fact, the pre-condition of .view_0 requires the existence of a POST parameter
named user that is obviously not provided if the user clicks on
the link in index.php. The intended workﬂow for our example
application is given in Figure 4.
Finally, the analysis identiﬁes the application’s entry points. We
exclude the modules that appear inside an include statement
from this step of the analysis, because they are generally not in-
tended to be directly accessed by the user. Of the remaining mod-
ules, we consider as entry point any view that has either an empty
pre-condition or a pre-condition that contains only predicates over
GET parameters (see Section 3).
Module
index.php
View ID Pre-conditions
view_0
∅
Post-conditions
∅
create.php
view_0
Exist($_POST["user"])
Propagate($_POST["user"],
DB_dbname.users.username,
{addslashes})
Propagate($_POST["pass"],
DB_dbname.users.password,
{addslashes})
Sinks
Displayed(DB_dbname.-
users.username)
∅
create.php
answer.php
view_1
view_0
answer.php
view_1
(Exist($loggedin)
not Exist($_POST["user"])
not
and
Compare($loggedin, "ok", =))
and
Exist($loggedin)
Compare($loggedin, "ok", =)
$_SES-
Exist($_SESSION ["loggedin"])
Propagate("ok",
SION["loggedin"], ∅)
∅
∅
∅
∅
∅
∅
Table 1: Views generated for the example application of Figure 2.
View
set
Intended 
workﬂow 
determination
Public view 
identiﬁcation
Vulnerability 
detection
Reports
Figure 3: The main steps of the inter-module analysis.
Unfortunately, in some cases it is not possible to differentiate
between an application’s entry point and the developer’s failure to
put the necessary safety checks into a module. For example, in
our experiments we tested a web application where in one of the
administration pages the developer forgot to put a check to verify
that the user was actually logged in as administrator. Our technique
classiﬁed the views of this module as entry points since they did not
have any pre-condition at all. Nevertheless, the user of our tool can
easily detect these vulnerabilities by inspecting the automatically
generated list of entry points.
5.2 Detecting Public Views
The intended path introduced in Section 3 did not model a very
important concept of a web application: the existence of publicly-
accessible pages. These pages (such as the FAQs pages) are very
common in many web sites but they are rarely intended as entry
points to the application. Therefore, we do not generate any secu-
rity alert if it is possible to access these pages violating the intended
workﬂow of the application.
For this reason, we adopted the following rules to detect and
mark the publicly-accessible views:
• Starting from one of the application entry points, all the views
that are reachable along some intended path traversing only
views that have empty post-conditions are marked as pub-
lic. This models the fact that if it is possible to reach a view
through a path that does not change the extended state of the
application, the access to the view is not supposed to be re-
stricted.
• Any empty redirect view is public. An empty redirect view
is a view that does not have any post-condition, any sink, and
only contains a redirect link. This models all the views used
to detect and redirect unauthenticated users that try to access
a restricted page.
In the example, our algorithm marked .view_0,
.view_1, and .view_0 as
public views. The ﬁrst two because they are reachable without
any change in the application state and the last one because it is
an empty redirect.
5.3 Detection Algorithm
Our graph exploration mechanism simulates a user that moves
from one view to another. At each step, we select a new view to
add to the current path, we evaluate its pre-condition against the
current state, and, if the pre-condition is satisﬁed, we update the
state to reﬂect the effects of the view’s post-conditions.
Each path is analyzed to check if it satisﬁes the deﬁnition we
provided in Section 2 for multi-step data-ﬂow vulnerabilities and
workﬂow violations. In general, if the graph is correct, it is pos-
sible to ﬁnd all the vulnerabilities simply by trying each possible
navigation path in the application. Our solution is similar to a
model checking approach, and, unfortunately, it suffers from the
same path explosion problem. Therefore, we limit our analysis to
paths that contain up to one loop and with a total length limited
by a user-deﬁned upper bound. In our experiments, in fact, we ob-
served that most of the vulnerabilities can be exploited using a very
limited number of steps (usually less than 5).
Our detection algorithm traverses the graph following the in-
tended paths. At each step it checks if it is possible to jump to
one of the views that should not be reachable from the current po-
sition. If it succeeds, it raises a workﬂow violation alert and it does
not go any further along that path. This means that some vulner-
abilities may not be discovered because they are hidden “behind”
other vulnerabilities. In this case, the user should ﬁx the discovered
vulnerability and run the analysis again.
By applying MiMoSA to our sample application, we identify the
two existing vulnerabilities. Figure 5 shows the reports produced
by MiMoSA for the example application of Figure 2.
Workflow Violation:
Path:
- index.php[view_0]
- answer.php[view_1]
DISPLAY of unsanitized entity:
Entity: DB_dbname.users.username
Example of Exploitable Path:
- create.php[view_0]
- index.php[view_0]
Figure 5: Vulnerabilities detected in the sample application of
Figure 2.
6. EVALUATION
To prove the effectiveness of our approach in detecting multi-
module data-ﬂow vulnerabilities and violations of the intended
workﬂow of a web application, we ran our tool on ﬁve real-world
web applications.
The selected applications satisfy three requirements: i) they are
written in PHP and they contain multiple modules, ii) they use both
session variables and database tables to maintain the application
state, and iii) they do not contain object-oriented code. The list of
chosen applications is shown in Table 2. The table also shows the
list of known vulnerabilities for each application.
For each application we ran the intra-module analysis in order
to extract the set of views corresponding to the application mod-
ules. We then ran the inter-module analysis to connect together the
views and calculate the intended application workﬂow. Finally, we
applied our detection algorithm to ﬁnd anomalies in the possible
navigation paths and to detect multi-module data-ﬂow vulnerabili-
ties.
The results of our tests are summarized in Table 3. For the intra-
module phase, the table reports the number of views extracted and
the time required by the analysis5. In the inter-module phase, we
explored up to one hundred million paths, covering at least all the
paths of length 3. The table reports the time required to generate
the paths and the alert messages raised by our tool. The alerts are
grouped according to the entities involved (for the data-ﬂow vulner-
abilities) and the modules (for the workﬂow violations). For both
data-ﬂow and workﬂow vulnerabilities, we report the number of
violations detected by our tool, the number of false positives, and