broader context.
van Oorschot and Wiener [37] had already observed that, if: (1)
𝑝 − 1 contains enough small factors, and (2) 𝑔 generates the full
group (e.g., in Configuration A), then using short exponents in
the public key 𝑋 = 𝑔𝑥 can lead to key recovery, as described in
Section 3. As we have seen, Crypto++ uses safe primes, so it is not
at risk. Although gcrypt generates 𝑝 −1 with many distinct factors,
none of these is small, and it is thus also safe.
However, both Crypto++ and gcrypt also use short exponents in
the ephemeral key 𝑌 = ˆ𝑔𝑦. But the generator ˆ𝑔 is part of a public key
that may have been generated by a different library, possibly one
adhering to Configuration A. Our analysis of registered keys shows
that such public keys, albeit rare, do exist. This immediately leads
to a message recovery attack: given a ciphertext ( ˆ𝑔𝑦, 𝑀 · ˆ𝑔𝑥 𝑦), the
attacker finds 𝑦, uses the public key to compute ˆ𝑔𝑥 𝑦, and recovers
the cleartext 𝑀.
To recap, whenever: (1) the public key of the receiver defines a
generator 𝑔 of a group containing “enough” small-order subgroups,
and (2) the sender uses short exponents in the ephemeral key, an
attacker who intercepts messages can decrypt any communication
from sender to receiver. The exact cost of the attack will depend on
Figure 1: Normalized cumulative distribution function Φ(𝜆, 𝜌)
of group orders 𝑁 that contain a 2𝜌-smooth factor 𝑄 of at
least 𝜆 bits.
the number and the size of the small subgroups, which we analyze
next.
Practical exploitation. Like in Section 3, let 𝑁 = 𝑞0 · · · 𝑞𝑛 =: 𝑄𝑞𝑛
be the group order of a public key, with 𝑞𝑛 not necessarily prime.
Assume that ephemeral exponents for encryption are sampled from
a short interval [0, 𝐵[, with 𝐵 ≪ 𝑁 . As we saw, the cost of recover-
ing the exponent depends on two factors: the largest divisor 𝑞𝑛−1
of 𝑄, and 𝐵/𝑄.
Note that, while 𝑄 and the 𝑞𝑖’s depend on the receiver’s public
key, the bound 𝐵 is set by the sender. To compare the relative risk
for several public keys, without taking a specific sender library into
account, it is best to look at the sizes of 𝑞𝑛−1 and 1/𝑄: the first
number measures the maximum effort done by the Rho algorithm,
the latter measures an amount of effort “spared” by the Lambda
algorithm.
To quantify the threat, we look at these two quantities for those
groups in the OpenPGP key dump that contain small factors. None
of the moduli we called “quasi-safe” are seriously at risk, since 𝑄
is too small. From the remaining 2,158 keys, we narrow down the
selection to those that had 2048 bits modulus, were not created
before 2016, and were not expired nor revoked, leaving us with
2,071 keys. Because we could not complete the factorization of any
of these, we can only state an upper bound on the cost of attacking
them, but it is entirely possible that some keys are much more
vulnerable than what our findings suggest.
In Figure 1 we plot the (normalized) cumulative counting func-
Φ(𝜆, 𝜌) = #(cid:8)𝑁 = 𝑞0 · · · 𝑞𝑛 = 𝑄𝑞𝑛(cid:12)(cid:12) 𝑞0, . . . , 𝑞𝑛−1 ≤ 2𝜌, 𝑄 ≥ 2𝜆(cid:9),
message recovery with a Rho effort at most 2𝜌/2√︁𝜋/2 and a Lambda
which counts, among the 2,071 keys, how many are exposed to
√
𝐵/2𝜆/2−1. Note that the factors of a single group
effort at most
order can arranged in more than one way, and thus appear in more
than one bucket.
From Φ(𝜆, 𝜌) we obtain the number of keys for which message
recovery is possible with a given effort with respect to a given en-
crypting library. For example, we know that for moduli of 2048 bits
gcrypt has 𝑦 < 2344 (see Appendix A): limiting both the Lambda
tion
Session 6D: Authentication and Privacy CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2070and the Rho efforts to roughly 240 modular multiplications, a com-
putation well within reach of a casual attacker, we find that there are
at least Φ(344−80, 80) = 15 vulnerable keys. Even more concerning
is the case of Crypto++, which samples exponents in [1 .. 2226]: in
this case the number of weak keys goes up to Φ(226− 80, 80) ≥ 231.
It is plausible that a state-level attacker could target as much as
Φ(344 − 140, 140) ≥ 83 (gcrypt) and Φ(226 − 140, 140) ≥ 895
(Crypto++) keys.
To confirm the vulnerability we used GPG to encrypt a message
to the only key contributing to Φ(344−56, 59), expecting to complete
the attack using roughly 230 modular multiplications. We were able
to recover the plaintext in less than 2.5 hours on a single Intel
E5-2640 core clocked at 2.40GHz.
5 ATTACKS ENABLED BY SIDE-CHANNELS
The attack conditions exploited in Section 4 emerged from different
implementers coming up with different conceptual interpretations
of ElGamal encryption. In particular, the attacks did not depend on
implementation details. The current section specifically considers
issues connected with implementation weaknesses. While a couple
of our findings can quickly be recognized and comprehended as
negatively affecting security, for others it remains unclear, at first,
how they can be practically exploited. This is where, again, the
different interpretations of ElGamal encryption come into play.
A crucial component of an ElGamal implementation is the mod-
ular exponentiation routine. In this section we study the details
of the exponentiation routines of Go, Crypto++, and gcrypt, and
we find all three vulnerable to side-channel attacks. The attack
conditions in Go and Crypto++ are immediately identified when in-
specting (our pseudo-code versions of) the algorithms, and they can
be exploited with standard side-channel exploitation techniques
like cache timing analysis. The existence of the attack in Go is not
surprising, as comments in the code indicate that the authors are
aware of the weaknesses.
Attacking the gcrypt implementation is significantly more in-
volved as the authors of that code took explicit measures to prevent
side-channel leakage. By exploiting a condition that the authors
allegedly overlooked we present a key recovery attack that signifi-
cantly reduces the security margin of gcrypt. The attack is only
practically exploitable against gcrypt-generated keys with moduli
up to 1024 bits. However we show that the vulnerability is more
worrisome in an interoperability context where gcrypt decryp-
tion is used in combination with a Crypto++ key: in this case we
experimentally confirm a practical key recovery attack against a
non-negligible fraction of Crypto++ keys with 2048 bits modulus.
5.1 Exponentiation Algorithms
The task of an exponentiation algorithm (EA) is to compute 𝑅 = 𝐵𝑥
given 𝐵 and 𝑥, where base 𝐵 is an element of a cyclic group and ex-
ponent 𝑥 is a non-negative integer. As any two EAs implement pre-
cisely the same function (just possibly in a different way), the spe-
cific exponentiation method relied upon in a cryptographic library
can be freely chosen by the implementer. Many different EAs are
known and common, where fixed-window, comb-based, and sliding-
window exponentiation represent some classic options. These can
be seen as derived from the basic Square-and-Multiply algorithm
with the goal of improving its efficiency by intelligently grouping
together the bits of the exponent, precomputing small sets of fre-
quently used values, or similar. Some but not all details of the three
algorithms are relevant for our attacks. Thus, while referring to [23,
Sect. 14.6–7] for a systematic treatment, in this section we repro-
duce the algorithms’ inner mechanics only up to a suitable level
of abstraction. We start with formalizing two notions related to
exponent recoding. Both are defined with respect to a parameter 𝑤
(for ‘width’ or ‘window length’) that is typically instantiated such
that 2 ≤ 𝑤 ≤ 5.
An odd-digit representation (ODR) of a non-negative integer 𝑥
with respect to a parameter 𝑤 is a sequence Γ = (𝛾𝑙 , . . . , 𝛾0) such
that
𝑥 =
2𝑗𝛾 𝑗
and ∀𝑗 : 𝛾 𝑗 ∈ {0} ∪ {1, 3, . . . , 2𝑤 − 1} .
𝑙∑︁
𝑗=0
𝑙∑︁
Independently of ODRs, a radix representation (RR) of a non-
negative integer 𝑥 with respect to a parameter 𝑤 is a sequence
Γ = (𝛾𝑙 , . . . , 𝛾0) such that
𝑥 =
2𝑤 𝑗𝛾 𝑗
and ∀𝑗 : 𝛾 𝑗 ∈ {0, . . . , 2𝑤 − 1} .
𝑗=0
The fixed-window, comb-based, and sliding-window methods
have in common that they consist of three phases: (1) an initializa-
tion phase in which some data that does not depend on the exponent
is (pre-)computed and tabulated; (2) an exponent encoding phase
in which an ODR or RR of the exponent is encoded into some data
structure;4 and (3) a computation-intensive online phase in which
the results of (1) and (2) are combined. Exploiting that phases (1)
and (2) are independent of each other and thus concurrent, practi-
cal implementations in fact do not cleanly separate the phases but
interleave them for efficiency. The reproductions provided in this
article, however, separate the phases for readability.5
The three libraries analyzed and attacked in this article—Go,
Crypto++, and gcrypt—implement AE via the fixed-window, comb-
based, and sliding-window method, respectively. We dedicate the
Sections 5.2, 5.3, and 5.4 to individual treatments of their security.
5.2 Fixed-window Exponentiation
Exponentiations 𝑅 ← 𝐵𝑥 in Go6 are computed, given a parame-
ter 𝑤, using a fixed-window algorithm by (1) precomputing and
tabulating a set of values that depend solely on 𝑤 and base ele-
ment 𝐵;7 (2) encoding an RR Γ = (𝛾𝑙 , . . . , 𝛾0) of the exponent 𝑥 into
a sequence (𝑒1, . . . , 𝑒𝐿) (the latter merely consists of relabelling the
coefficients); and (3) combining the results of (1) and (2) in an online
phase.
4If an ODR encoding is used, the values tabulated in Phase 1 are usually
𝐵1, 𝐵3, . . . , 𝐵2𝑤−1; if an RR encoding is used, the values tabulated in Phase 1 are
usually 𝐵0, . . . , 𝐵2𝑤−1.
5At a high level, our attacks work independently of whether the phases are separated
or interleaved. Looking a bit closer reveals that the attacks actually work better if the
phases are interleaved, as it is the case in all practical implementations we are aware
of, as side-channel sensors can then be placed with higher precision.
6The code is available at https://github.com/golang/go/blob/e491c6ee/src/math/big/
nat.go#L1386-L1477
7In the Go implementation, the width parameter is hard-coded as 𝑤 = 4.
Session 6D: Authentication and Privacy CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2071Go
Exponentiation 𝑅 ← 𝐵𝑥
Parameterized by: 𝑤
Registers: 𝑇 [0], . . . ,𝑇 [2𝑤 − 1],𝑊
1 // Initialize 𝑇 [. . .]
2 For 0 ≤ 𝑖 < 2𝑤: 𝑇 [𝑖] ← 𝐵𝑖
3 // Encode the exponent
4 (𝑒1, . . . , 𝑒𝐿) ← 𝑓𝑤(𝑥)
5 // Main loop
6 𝑅 ← 1
7 For 𝑖 ← 1 to 𝐿:
8
9
10
// Square 𝑤 times
If 𝑖 ≠ 1, for 𝑗 ← 1 to 𝑤:
𝑅 ← 𝑅 · 𝑅
// Multiply with 𝑇 [𝑒𝑖]
12 𝑊 ← 𝑇 [𝑒𝑖]
𝑅 ← 𝑅 · 𝑊
11
13
14 Return 𝑅
Crypto++
Exponentiation 𝑅 ← 𝐵𝑥
Parameterized by: 𝑤
Registers: 𝑇 [1],𝑇 [3], . . . ,𝑇 [2𝑤 − 1], 𝐻
15 // Initialize 𝑇 [. . .]
16 For odd 0 ≤ 𝑖 < 2𝑤: 𝑇 [𝑖] ← 1
17 // Encode the exponent
18 (𝑒1, . . . , 𝑒𝐿) ← 𝑓𝑤(𝑥)
19 // Main loop
20 𝐻 ← 𝐵
21 For 𝑖 ← 1 to 𝐿:
22
23
𝑇 [𝑒𝑖] ← 𝑇 [𝑒𝑖] · 𝐻
If 𝑒𝑖 ≠ 0:
𝐻 ← 𝐻 · 𝐻
24
25 // Accumulate results
26 𝑅 ← 1
27 For odd 0 ≤ 𝑖 < 2𝑤:
𝑅 ← 𝑅 · 𝑇 [𝑖]𝑖
28
29 Return 𝑅
gcrypt
Exponentiation 𝑅 ← 𝐵𝑥
Parameterized by: 𝑤
Registers: 𝑇 [1],𝑇 [3], . . . ,𝑇 [2𝑤 − 1],𝑊
30 // Initialize 𝑇 [. . .]
31 For odd 0 ≤ 𝑖 < 2𝑤: 𝑇 [𝑖] ← 𝐵𝑖
32 // Encode the exponent
33 (𝑒0, 𝑐1, 𝑒1, . . . , 𝑐𝐿, 𝑒𝐿, 𝑐𝐿+1) ← 𝑓𝑤(𝑥)
34 // Main loop
35 𝑅 ← 𝐵 // implicitly process 𝑒0 = 1
36 For 𝑖 ← 1 to 𝐿:
37
38
39
// Square 𝑐𝑖 times, then multiply with 𝑇 [𝑒𝑖]
For 𝑗 ← 1 to 𝑐𝑖 + 1:
Securely 𝑊 ← [ 𝑗 ≤ 𝑐𝑖 ? 𝑅 : 𝑇 [𝑒𝑖] ]
𝑅 ← 𝑅 · 𝑊
40
41 // Square 𝑐𝐿+1 times
42 For 𝑗 ← 1 to 𝑐𝐿+1:
𝑅 ← 𝑅 · 𝑅
43
44 Return 𝑅