### Broader Context

van Oorschot and Wiener [37] observed that if:
1. \( p - 1 \) contains enough small factors, and
2. \( g \) generates the full group (e.g., in Configuration A),

then using short exponents in the public key \( X = g^x \) can lead to key recovery, as described in Section 3. Since Crypto++ uses safe primes, it is not at risk. Although gcrypt generates \( p - 1 \) with many distinct factors, none of these are small, making it also safe.

However, both Crypto++ and gcrypt use short exponents in the ephemeral key \( Y = \hat{g}^y \). The generator \( \hat{g} \) is part of a public key that may have been generated by a different library, possibly one adhering to Configuration A. Our analysis of registered keys shows that such public keys, although rare, do exist. This leads to a message recovery attack: given a ciphertext \( (\hat{g}^y, M \cdot \hat{g}^{xy}) \), the attacker finds \( y \), uses the public key to compute \( \hat{g}^{xy} \), and recovers the cleartext \( M \).

To summarize, whenever:
1. The public key of the receiver defines a generator \( g \) of a group containing "enough" small-order subgroups, and
2. The sender uses short exponents in the ephemeral key,

an attacker who intercepts messages can decrypt any communication from the sender to the receiver. The exact cost of the attack depends on the number and size of the small subgroups, which we analyze next.

### Practical Exploitation

As in Section 3, let \( N = q_0 \cdots q_n := Qq_n \) be the group order of a public key, with \( q_n \) not necessarily prime. Assume that ephemeral exponents for encryption are sampled from a short interval \([0, B[\), with \( B \ll N \). The cost of recovering the exponent depends on two factors: the largest divisor \( q_{n-1} \) of \( Q \), and \( B / Q \).

Note that while \( Q \) and the \( q_i \)'s depend on the receiver's public key, the bound \( B \) is set by the sender. To compare the relative risk for several public keys, without considering a specific sender library, it is best to look at the sizes of \( q_{n-1} \) and \( 1 / Q \): the first number measures the maximum effort done by the Rho algorithm, and the latter measures the amount of effort "spared" by the Lambda algorithm.

To quantify the threat, we examine these two quantities for those groups in the OpenPGP key dump that contain small factors. None of the moduli we called "quasi-safe" are seriously at risk since \( Q \) is too small. From the remaining 2,158 keys, we narrow down the selection to those with a 2048-bit modulus, created after 2016, and not expired or revoked, leaving us with 2,071 keys. Because we could not complete the factorization of any of these, we can only state an upper bound on the cost of attacking them, but it is possible that some keys are much more vulnerable than our findings suggest.

In Figure 1, we plot the (normalized) cumulative counting function:
\[
\Phi(\lambda, \rho) = \# \left\{ N = q_0 \cdots q_n = Qq_n \mid q_0, \ldots, q_{n-1} \leq 2^\rho, Q \geq 2^\lambda \right\}
\]
which counts, among the 2,071 keys, how many are exposed to message recovery with a Rho effort at most \( 2^{\rho/2} \sqrt{\pi/2} \) and a Lambda effort at most \( \sqrt{B / 2^{\lambda/2 - 1}} \). Note that the factors of a single group order can be arranged in more than one way and thus appear in more than one bucket.

From \(\Phi(\lambda, \rho)\), we obtain the number of keys for which message recovery is possible with a given effort with respect to a given encrypting library. For example, for 2048-bit moduli, gcrypt has \( y < 2^{344} \) (see Appendix A). Limiting both the Lambda and Rho efforts to roughly \( 2^{40} \) modular multiplications, a computation well within reach of a casual attacker, we find that there are at least \(\Phi(344-80, 80) = 15\) vulnerable keys. Even more concerning is the case of Crypto++, which samples exponents in \([1, 2^{226}]\): in this case, the number of weak keys goes up to \(\Phi(226-80, 80) \geq 231\). It is plausible that a state-level attacker could target as many as \(\Phi(344-140, 140) \geq 83\) (gcrypt) and \(\Phi(226-140, 140) \geq 895\) (Crypto++) keys.

To confirm the vulnerability, we used GPG to encrypt a message to the only key contributing to \(\Phi(344-56, 59)\), expecting to complete the attack using roughly \( 2^{30} \) modular multiplications. We were able to recover the plaintext in less than 2.5 hours on a single Intel E5-2640 core clocked at 2.40 GHz.

### Attacks Enabled by Side-Channels

The attack conditions exploited in Section 4 emerged from different implementers' conceptual interpretations of ElGamal encryption. Specifically, the attacks did not depend on implementation details. This section considers issues connected with implementation weaknesses. While some of our findings can quickly be recognized and comprehended as negatively affecting security, others remain unclear at first regarding practical exploitation. This is where the different interpretations of ElGamal encryption come into play.

A crucial component of an ElGamal implementation is the modular exponentiation routine. In this section, we study the details of the exponentiation routines of Go, Crypto++, and gcrypt, and find all three vulnerable to side-channel attacks. The attack conditions in Go and Crypto++ are immediately identified when inspecting (our pseudo-code versions of) the algorithms, and they can be exploited with standard side-channel techniques like cache timing analysis. The existence of the attack in Go is not surprising, as comments in the code indicate that the authors are aware of the weaknesses.

Attacking the gcrypt implementation is significantly more involved, as the authors took explicit measures to prevent side-channel leakage. By exploiting a condition that the authors allegedly overlooked, we present a key recovery attack that significantly reduces the security margin of gcrypt. The attack is practically exploitable against gcrypt-generated keys with moduli up to 1024 bits. However, we show that the vulnerability is more worrisome in an interoperability context where gcrypt decryption is used in combination with a Crypto++ key. In this case, we experimentally confirm a practical key recovery attack against a non-negligible fraction of Crypto++ keys with 2048-bit moduli.

### Exponentiation Algorithms

The task of an exponentiation algorithm (EA) is to compute \( R = B^x \) given \( B \) and \( x \), where base \( B \) is an element of a cyclic group and exponent \( x \) is a non-negative integer. As any two EAs implement precisely the same function (just possibly in a different way), the specific exponentiation method relied upon in a cryptographic library can be freely chosen by the implementer. Many different EAs are known and common, where fixed-window, comb-based, and sliding-window exponentiation represent some classic options. These can be seen as derived from the basic Square-and-Multiply algorithm with the goal of improving its efficiency by intelligently grouping together the bits of the exponent, precomputing small sets of frequently used values, or similar. Some but not all details of the three algorithms are relevant for our attacks. Thus, while referring to [23, Sect. 14.6–7] for a systematic treatment, in this section, we reproduce the algorithms' inner mechanics only up to a suitable level of abstraction.

We start with formalizing two notions related to exponent recoding. Both are defined with respect to a parameter \( w \) (for 'width' or 'window length') that is typically instantiated such that \( 2 \leq w \leq 5 \).

An odd-digit representation (ODR) of a non-negative integer \( x \) with respect to a parameter \( w \) is a sequence \( \Gamma = (\gamma_l, \ldots, \gamma_0) \) such that:
\[
x = \sum_{j=0}^l 2^j \gamma_j \quad \text{and} \quad \forall j : \gamma_j \in \{0\} \cup \{1, 3, \ldots, 2w - 1\}
\]

Independently of ODRs, a radix representation (RR) of a non-negative integer \( x \) with respect to a parameter \( w \) is a sequence \( \Gamma = (\gamma_l, \ldots, \gamma_0) \) such that:
\[
x = \sum_{j=0}^l 2^{wj} \gamma_j \quad \text{and} \quad \forall j : \gamma_j \in \{0, \ldots, 2w - 1\}
\]

The fixed-window, comb-based, and sliding-window methods have in common that they consist of three phases:
1. An initialization phase in which some data that does not depend on the exponent is (pre-)computed and tabulated.
2. An exponent encoding phase in which an ODR or RR of the exponent is encoded into some data structure.
3. A computation-intensive online phase in which the results of (1) and (2) are combined.

Exploiting that phases (1) and (2) are independent of each other and thus concurrent, practical implementations in fact do not cleanly separate the phases but interleave them for efficiency. The reproductions provided in this article, however, separate the phases for readability.

The three libraries analyzed and attacked in this article—Go, Crypto++, and gcrypt—implement AE via the fixed-window, comb-based, and sliding-window method, respectively. We dedicate Sections 5.2, 5.3, and 5.4 to individual treatments of their security.

#### 5.2 Fixed-window Exponentiation

Exponentiations \( R \leftarrow B^x \) in Go are computed, given a parameter \( w \), using a fixed-window algorithm by:
1. Precomputing and tabulating a set of values that depend solely on \( w \) and base element \( B \).
2. Encoding an RR \( \Gamma = (\gamma_l, \ldots, \gamma_0) \) of the exponent \( x \) into a sequence \( (e_1, \ldots, e_L) \) (the latter merely consists of relabeling the coefficients).
3. Combining the results of (1) and (2) in an online phase.

**Go**
```plaintext
Exponentiation R ← B^x
Parameterized by: w
Registers: T[0], ..., T[2^w - 1], W

1. // Initialize T[...]
2. For 0 ≤ i < 2^w: T[i] ← B^i
3. // Encode the exponent
4. (e1, ..., eL) ← f_w(x)
5. // Main loop
6. R ← 1
7. For i ← 1 to L:
   8. // Square w times
   9. If i ≠ 1, for j ← 1 to w:
      10. R ← R · R
   11. // Multiply with T[e_i]
   12. W ← T[e_i]
   13. R ← R · W
14. Return R
```

**Crypto++**
```plaintext
Exponentiation R ← B^x
Parameterized by: w
Registers: T[1], T[3], ..., T[2^w - 1], H

15. // Initialize T[...]
16. For odd 0 ≤ i < 2^w: T[i] ← 1
17. // Encode the exponent
18. (e1, ..., eL) ← f_w(x)
19. // Main loop
20. H ← B
21. For i ← 1 to L:
   22. T[e_i] ← T[e_i] · H
   23. If e_i ≠ 0:
      24. H ← H · H
25. // Accumulate results
26. R ← 1
27. For odd 0 ≤ i < 2^w:
   28. R ← R · T[i]^i
29. Return R
```

**Gcrypt**
```plaintext
Exponentiation R ← B^x
Parameterized by: w
Registers: T[1], T[3], ..., T[2^w - 1], W

30. // Initialize T[...]
31. For odd 0 ≤ i < 2^w: T[i] ← B^i
32. // Encode the exponent
33. (e0, c1, e1, ..., cL, eL, cL+1) ← f_w(x)
34. // Main loop
35. R ← B // implicitly process e0 = 1
36. For i ← 1 to L:
   37. // Square c_i times, then multiply with T[e_i]
   38. For j ← 1 to c_i + 1:
      39. Securely W ← [ j ≤ c_i ? R : T[e_i] ]
      40. R ← R · W
41. // Square c_L+1 times
42. For j ← 1 to c_L+1:
   43. R ← R · R
44. Return R
```