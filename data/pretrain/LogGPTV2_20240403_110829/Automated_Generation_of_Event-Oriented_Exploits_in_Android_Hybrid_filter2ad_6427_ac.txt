reported in Table I, almost 60% of the event handlers require
JavaScript enabled to trigger.
document.write("
7 
+ id + "’ />")
Listing 2: Exploit Code
V. TECHNICAL APPROACHES
In this section, we ﬁrst present our study of events and
event handlers in WebView to understand their constraints for
triggering event-oriented exploits. We then present technical
details about
the design and implementation of selective
symbolic execution, program state analysis, and exploit code
generation.
A. Understanding Event Handler Triggering Constraints
The ofﬁcial Android documentation of events and event
handlers is obscure and incomplete. We hence conduct a
systematic study based on both reading documents about
WebView on the web and analyzing real-world hybrid apps.
The main study result is shown in Table I. We ﬁnd that 37
events are available for adversaries in WebView. The triggering
code for each event is shown in the ﬁfth column. Note that
the DOM element ‘’ can directly trigger two
events, whose corresponding event handlers are shouldOver-
rideUrlLoading() and shouldInterceptRequest(), respectively.
It depends on the attribute src’s content s. If s’s scheme is
not ‘HTTP’ and ‘HTTPS’, but customized, the former one is
triggered. Otherwise, the latter one is triggered.
As reported in the third column, using HTML code,
adversaries can trigger 15 event handlers, including popular
event handlers shouldOverrideUrlLoading() and shouldInter-
ceptRequest(). Note that, four of them require supports from
the web server side to get appropriate HTTP response code.
For instance, onReceivedLoginRequest(webview, realm, account,
args) can be triggered by the combination of the HTML code
“” and the HTTP
response header “x-auto-login:realm=x&account=y&args=z”,
which is from the malicious server “attacker.com”. x, y, and z
are passed to onReceivedLoginRequest() as function parameters.
As the above example shows, adversaries can pass data from
the web context to the native context. In our study, we ﬁnd
that the parameters of 29 event handlers can be inﬂuenced by
adversaries. More details are shown in the ﬁrst column (i.e.,
the parameters between parentheses).
As reported in the fourth column, triggering event handlers
are inﬂuenced by the level of web frames where the events
occur. We ﬁnd that events which occur in the main frame could
trigger all event handlers, whereas the capability of events in
subframes is limited. More speciﬁcally, three event handlers
cannot be triggered by events that occur in the main frame.
Let Ei (i ≥ 0) be the events that occur in the ith level web
frame and can be handled by event handlers, E denotes all
events available in the whole WebView space and E0 denotes
the events available in the main frame, they have the following
relationship: E0 = E while Ei (cid:64) E (i > 0).
Event Triggering Constraints. The constraints for trigger-
ing events are mainly caused by the status of JavaScript. As
7
Event Handler Triggering Constraints. The constraints
for triggering event handlers are mainly from two aspects:
I: The frame level. Triggering three of the event handlers
require their corresponding events to occur in the main frame.
Adversaries must inject malicious code into the main frame,
which is usually well protected. Also, it is easy for users to
realize the injected web code, because it may reload web pages.
II: Predetermined execution orders. Several event handlers’
execution orders are predetermined in WebView, which also
imposes constraints on triggering the event handlers. To
understand these predetermined execution orders, we create
an experimental app which registers all event handlers, and
proﬁle them when they are invoked. Then, the app loads fuzzing
HTML/JavaScript code. We also apply static analysis to track
the return values of all event handlers. If an event handler’s
return value appears in a conditional statement, and later another
event handler is called, a predetermined event order may exist.
Finally, we conﬁrm ﬁve predetermined execution orders:
1. shouldInterceptRequest() → onLoadResource(): The latter
event handler is called only when the former event handler
returns null.
2. shouldOverrideKeyEvent() → onUnhandledKeyEvent():
The latter event handler is only called when the former event
handler returns false.
3. onPageStarted() → ... → onPageFinished(): When
WebView starts loading a web page, onPageStarted() is called.
When WebView ﬁnishes loading the page, onPageFinished() is
called. During the process, other event handlers may be called as
well, such as onReceivedError() and shouldInterceptRequest().
4. onPageStarted() can be called multiple times before
onPageFinished() is called. This happens when there are URL
redirections in the web server side (i.e., 3xx HTTP response
code). The number of times that onP ageStarted() is called
depends on the URL redirection number. Moreover, generally,
onPageFinished() is only called once, no matter how many
URL redirections there are. But if the last HTTP response code
is 4xx, WebView may be redirected to show a page-not-found
HTML, and then, onPageFinished() is called again.
5. onGeolocationPermissionsShowPrompt() → onGeolo-
cationPermissionsHidePrompt() and onShowCustomView() →
onHideCustomView(): When location permission is requested,
or Full Screen is entered, these events are called sequentially.
Adversaries’ Capability: Playing Gadgets. Adversaries
can change program states by manipulating gadgets’ input and
execution orders. More speciﬁcally, adversaries can pass data to
web events, and then the data are passed to the corresponding
event handlers as their function parameters. Adversaries can
also trigger events and event handlers in arbitrary orders, even
though there are constraints on triggering events and event
handlers.
Gadgets’ Input. Adversaries may be able to control event
handlers’ parameters. For example, shouldInterceptRequest()’s
parameter (i.e., request) can be set as ‘‘https://attacker.com/im
g’’, if adversaries use the HTML code “” to trigger the event handler.
Event Handlers and Main Parameters
Handled Events
JS?
E0?
Example Trigger Code (HTML/JavaScript/HTTP)
onFormResubmission
onPageCommitVisible(url)
doUpdateVisitedHistory(url, isReloaded)
onPageStarted(url, icon)
onPageFinished(url)
onReceivedError(errorcode, description, url)
onReceivedSslError(error)
onReceivedClientCertRequest(request)
onReceivedHttpAuthRequest (host, realm)
onReceivedHttpError(request, response)
onReceivedLoginRequest(realm, account, arg)
onScaleChanged(old_scale, new_scale)
shouldOverrideKeyEvent(keyevent)
onUnhandledKeyEvent(keyevent)
shouldInterceptRequest(request)
onLoadResource(url)
shouldOverrideUrlLoading(url [or request])
onCreateWindow
onCloseWindow
onConsoleMessage(message)
onGeolocationPermissionsShowPrompt
(origin)
onGeolocationPermissionsHidePrompt
onShowCustomView
onHideCustomView
onJsBeforeUnload(url, message, result)
onJsAlert(url, message, result)
onJsConﬁrm(url, message, result)
onJsPrompt(url, message, defaultValue, result)
onPermissionRequest(request)
onPermissionRequestCanceled(request)
onRequestFocus
onShowFileChooser
onProgressChanged(progress)
onReceivedIcon(icon)
onReceivedTitle(title)
onReceivedTouchIcon(url, precomposed)
onDownloadStart(url, userAgent,
contentDisposition, mimetype, contentLength)
Resubmitting a form
Updating history
Starting to load a page
ﬁnishing loading a page
Failing to load a page
SSL error
Client cert request
Authentication request
HTTP error
Login request
Updating scale
Pressing key
Facing an unhandled key
Resources loading
Loading a resource
URL navigation
Creating a window
Closing a window
Printing messages
GPS request
Entering full screen
Quitting full screen
Leaving a webpage
Popuping an alert box
Popuping a conﬁrm box
Popuping a prompt box
Permission request
Request is cancelled
Requesting focus
Browsing ﬁle system
Page loading status
Receiving a icon
Receiving a title
Receiving an apple touch
icon
Downloading a ﬁle
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
[HTML]  [JS] form.resubmit()
[HTML]  , 
Trigger Constraint
[HTML] 
[JS] window.open()
[JS] window.close()
[JS] console.log()
[JS] navigator.geolocation.getCurrentPosition()
Trigger Constraint
[HTML] [JS] webkitRequestFullScreen()
Trigger Constraint
[JS] dispatch onbeforeunload event
[JS] alert()
[JS] conﬁrm()
[JS] prompt()
[JS] navigator.getUserMedia()
[HTML] <input type="text" id="name" . . . [JS] focus();
[HTML] <input type="ﬁle" . . . [JS] dispatch a click event
[HTML] <iframe src="http://url.apk" ...
Table I: The Systematic Study Result. The third column ‘JS?’ means: ‘Is JavaScript required to trigger the event?’, and the forth
column ‘E0?’ means: ‘Does the event handler only deal with events from E0?’. In answers, we use (cid:88)and blank to indicate ‘Yes’
and ‘No’, respectively.
Gadgets’ Execution Orders. Consider two event handlers
eh1 and eh2, there are two cases to analyze: (1) If eh1 and
eh2 do not have any relationship, adversaries can call them
in any order (i.e., eh1→e2 and eh2→eh1); (2) If eh1 must be
executed before eh2, their relationship should be t−→ eh1
c−→ eh2,
where t is the trigger code to call eh1 and c is the pre-
condition that must be satisﬁed to trigger eh2. By repeating
t and make c be satisﬁed, we may get the event handler
sequence (eh1eh2eh1eh2), which includes expected sequences
(both eh1→eh2 and eh2→eh1).
B. Selective Symbolic Execution
To apply symbolic execution in event handlers, we address
four challenges (with details in following subsections):
•
Path explosion: To address this notorious problem,
EOEDroid uses static analysis to provide heuristic
information for path selection. However, as discussed
in Section I, static analysis may introduce false neg-
atives to the heuristic information. To avoid it, we
8
conservatively and safely apply static analysis on only
a certain number of instructions that do not cause false
negatives (Section V-B1).
• Unsupported fork(): In existing dynamic symbolic
execution based approaches, fork() is frequently used
to help systems traverse branches and keep the analysis
environment clean. However, in Android, fork() is not
supported. Instead, EOEDroid needs to sequentially
traverse branches. However, different with desktop
software, it is expensive to save and restore states
of Android apps. To ﬁx the problem, we propose an
analysis sandbox to handle the interaction with the
external environment (Section V-B2).
Android Intent: Intent is frequently used in event
handlers, such as triggering a GUI event to open
a GUI activity. However, it introduces semantic gap
between Intent senders and receivers. Figure 4 shows
an example that an intent message is delivered between
two apps. The Intent message escapes from the Java
•
context (i.e., DVM), enters the C/C++ context (i.e.,
Linux kernel), and ﬁnally returns to the Java context.
This way raises challenges to track the Intent message
in the Java context. When the receiver obtains the