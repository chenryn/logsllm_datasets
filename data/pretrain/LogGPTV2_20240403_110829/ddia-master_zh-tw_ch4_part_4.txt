}
```
首先，请注意模式中没有标签号码。如果我们使用这个模式编码我们的例子记录（[例 4-1]()），Avro 二进位制编码只有 32 个位元组长，这是我们所见过的所有编码中最紧凑的。编码位元组序列的分解如 [图 4-5](../img/fig4-5.png) 所示。
如果你检查位元组序列，你可以看到没有什么可以识别字段或其资料型别。编码只是由连在一起的值组成。一个字串只是一个长度字首，后跟 UTF-8 位元组，但是在被包含的资料中没有任何内容告诉你它是一个字串。它可以是一个整数，也可以是其他的整数。整数使用可变长度编码（与 Thrift 的 CompactProtocol 相同）进行编码。
![](../img/fig4-5.png)
**图 4-5 使用 Avro 编码的记录**
为了解析二进位制资料，你按照它们出现在模式中的顺序遍历这些栏位，并使用模式来告诉你每个栏位的资料型别。这意味著如果读取资料的程式码使用与写入资料的程式码完全相同的模式，才能正确解码二进位制资料。Reader 和 Writer 之间的模式不匹配意味著错误地解码资料。
那么，Avro 如何支援模式演变呢？
#### Writer模式与Reader模式
有了 Avro，当应用程式想要编码一些资料（将其写入档案或资料库、透过网路传送等）时，它使用它知道的任何版本的模式编码资料，例如，模式可能被编译到应用程式中。这被称为 Writer 模式。
当一个应用程式想要解码一些资料（从一个档案或资料库读取资料、从网路接收资料等）时，它希望资料在某个模式中，这就是 Reader 模式。这是应用程式程式码所依赖的模式，在应用程式的构建过程中，程式码可能已经从该模式生成。
Avro 的关键思想是 Writer 模式和 Reader 模式不必是相同的 - 他们只需要相容。当资料解码（读取）时，Avro 库透过并排检视 Writer 模式和 Reader 模式并将资料从 Writer 模式转换到 Reader 模式来解决差异。Avro 规范【20】确切地定义了这种解析的工作原理，如 [图 4-6](../img/fig4-6.png) 所示。
例如，如果 Writer 模式和 Reader 模式的栏位顺序不同，这是没有问题的，因为模式解析透过栏位名匹配栏位。如果读取资料的程式码遇到出现在 Writer 模式中但不在 Reader 模式中的栏位，则忽略它。如果读取资料的程式码需要某个栏位，但是 Writer 模式不包含该名称的栏位，则使用在 Reader 模式中宣告的预设值填充。
![](../img/fig4-6.png)
**图 4-6 一个 Avro Reader 解决读写模式的差异**
#### 模式演变规则
使用 Avro，向前相容性意味著你可以将新版本的模式作为 Writer，并将旧版本的模式作为 Reader。相反，向后相容意味著你可以有一个作为 Reader 的新版本模式和作为 Writer 的旧版本模式。
为了保持相容性，你只能新增或删除具有预设值的栏位（我们的 Avro 模式中的栏位 `favoriteNumber` 的预设值为 `null`）。例如，假设你添加了一个有预设值的栏位，这个新的栏位将存在于新模式而不是旧模式中。当使用新模式的 Reader 读取使用旧模式写入的记录时，将为缺少的栏位填充预设值。
如果你要新增一个没有预设值的栏位，新的 Reader 将无法读取旧 Writer 写的资料，所以你会破坏向后相容性。如果你要删除没有预设值的栏位，旧的 Reader 将无法读取新 Writer 写入的资料，因此你会打破向前相容性。在一些程式语言中，null 是任何变数可以接受的预设值，但在 Avro 中并不是这样：如果要允许一个栏位为 `null`，则必须使用联合型别。例如，`union {null, long, string} field;` 表示 field 可以是数字或字串，也可以是 `null`。如果要将 null 作为预设值，则它必须是 union 的分支之一 [^iv]。这样的写法比预设情况下就允许任何变数是 `null` 显得更加冗长，但是透过明确什么可以和什么不可以是 `null`，有助于防止出错【22】。
[^iv]: 确切地说，预设值必须是联合的第一个分支的型别，尽管这是 Avro 的特定限制，而不是联合型别的一般特征。
因此，Avro 没有像 Protocol Buffers 和 Thrift 那样的 `optional` 和 `required` 标记（但它有联合型别和预设值）。
只要 Avro 可以支援相应的型别转换，就可以改变栏位的资料型别。更改栏位的名称也是可能的，但有点棘手：Reader 模式可以包含栏位名称的别名，所以它可以匹配旧 Writer 的模式栏位名称与别名。这意味著更改栏位名称是向后相容的，但不能向前相容。同样，向联合型别新增分支也是向后相容的，但不能向前相容。
#### 但Writer模式到底是什么？
到目前为止，我们一直跳过了一个重要的问题：对于一段特定的编码资料，Reader 如何知道其 Writer 模式？我们不能只将整个模式包括在每个记录中，因为模式可能比编码的资料大得多，从而使二进位制编码节省的所有空间都是徒劳的。
答案取决于 Avro 使用的上下文。举几个例子：
* 有很多记录的大档案
  Avro 的一个常见用途 - 尤其是在 Hadoop 环境中 - 用于储存包含数百万条记录的大档案，所有记录都使用相同的模式进行编码（我们将在 [第十章](ch10.md) 讨论这种情况）。在这种情况下，该档案的作者可以在档案的开头只包含一次 Writer 模式。Avro 指定了一个档案格式（物件容器档案）来做到这一点。
* 支援独立写入的记录的资料库
  在一个数据库中，不同的记录可能会在不同的时间点使用不同的 Writer 模式来写入 - 你不能假定所有的记录都有相同的模式。最简单的解决方案是在每个编码记录的开始处包含一个版本号，并在资料库中保留一个模式版本列表。Reader 可以获取记录，提取版本号，然后从资料库中获取该版本号的 Writer 模式。使用该 Writer 模式，它可以解码记录的其余部分（例如 Espresso 【23】就是这样工作的）。
* 透过网路连线传送记录
  当两个程序透过双向网路连线进行通讯时，他们可以在连线设定上协商模式版本，然后在连线的生命周期中使用该模式。Avro RPC 协议（请参阅 “[服务中的资料流：REST 与 RPC](#服务中的资料流：REST与RPC)”）就是这样工作的。
具有模式版本的资料库在任何情况下都是非常有用的，因为它充当文件并为你提供了检查模式相容性的机会【24】。作为版本号，你可以使用一个简单的递增整数，或者你可以使用模式的杂凑。
#### 动态生成的模式
与 Protocol Buffers 和 Thrift 相比，Avro 方法的一个优点是架构不包含任何标签号码。但为什么这很重要？在模式中保留一些数字有什么问题？
不同之处在于 Avro 对动态生成的模式更友善。例如，假如你有一个关系资料库，你想要把它的内容转储到一个档案中，并且你想使用二进位制格式来避免前面提到的文字格式（JSON，CSV，SQL）的问题。如果你使用 Avro，你可以很容易地从关系模式生成一个 Avro 模式（在我们之前看到的 JSON 表示中），并使用该模式对资料库内容进行编码，并将其全部转储到 Avro 物件容器档案【25】中。你为每个资料库表生成一个记录模式，每个列成为该记录中的一个栏位。资料库中的列名称对映到 Avro 中的栏位名称。
现在，如果资料库模式发生变化（例如，一个表中添加了一列，删除了一列），则可以从更新的资料库模式生成新的 Avro 模式，并在新的 Avro 模式中汇出资料。资料汇出过程不需要注意模式的改变 - 每次执行时都可以简单地进行模式转换。任何读取新资料档案的人都会看到记录的栏位已经改变，但是由于栏位是透过名字来标识的，所以更新的 Writer 模式仍然可以与旧的 Reader 模式匹配。
相比之下，如果你为此使用 Thrift 或 Protocol Buffers，则栏位标签可能必须手动分配：每次资料库模式更改时，管理员都必须手动更新从资料库列名到栏位标签的对映（这可能会自动化，但模式生成器必须非常小心，不要分配以前使用的栏位标签）。这种动态生成的模式根本不是 Thrift 或 Protocol Buffers 的设计目标，而是 Avro 的。