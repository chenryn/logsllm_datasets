a conflicting block ğµğ‘™ cannot exist.
Proof. Suppose an honest replica directly commits a block ğµğ‘˜
in a view ğ‘£, then it must have received ğ‘› âˆ’ ğ›¾ğ‘  âŸ¨commit, ğµğ‘˜, ğ‘£âŸ©. At
least one of them is from an honest replica since ğ‘›âˆ’ğ›¾ğ‘  > ğ›½ğ‘ . Let ğ‘¡ be
the first time when an honest replica (say ğ‘Ÿ) sends âŸ¨commit, ğµğ‘˜, ğ‘£âŸ©,
then ğ‘Ÿ must have received and broadcasted Cğ‘£(ğµğ‘˜) by ğ‘¡ âˆ’ 2Î”. Thus,
all honest replicas must have received Cğ‘£(ğµğ‘˜) by ğ‘¡ âˆ’ Î”, and could
not have voted a conflicting block ğµğ‘™ after that. But if any honest
replica voted for ğµğ‘™ (and forwarded the proposal of ğµğ‘™) before ğ‘¡ âˆ’ Î”,
then ğ‘Ÿ must have received the conflicting proposal of ğµğ‘™ by ğ‘¡. Then,
ğ‘Ÿ would have then stopped all processes in the steady state of view
ğ‘£ and could not have sent commit for ğµğ‘˜ at ğ‘¡, a contradiction. Thus,
no honest replica could not voted for ğµğ‘™. As ğ‘› âˆ’ ğ›¾ğ‘  > ğ›½ğ‘ , there are
not enough votes for ğµğ‘™ to form Cğ‘£(ğµğ‘™)
â–¡
Lemma 4.7. If an honest replica directly commits a block ğµğ‘˜ in
a view ğ‘£, then at least ğ›¾ğ‘  + 1 honest replicas receive Cğ‘£(ğµğ‘˜) before
entering the next view ğ‘£ + 1.
Proof. Suppose an honest replica directly commits a block ğµğ‘˜
in a view ğ‘£, then it must have received ğ‘› âˆ’ ğ›¾ğ‘  âŸ¨commit, ğµğ‘˜, ğ‘£âŸ©. At
least one of them is from an honest replica since ğ‘›âˆ’ğ›¾ğ‘  > ğ›½ğ‘ . Let ğ‘¡ be
the first time when an honest replica (say ğ‘Ÿ) sends âŸ¨commit, ğµğ‘˜, ğ‘£âŸ©,
then ğ‘Ÿ must have received and broadcasted Cğ‘£(ğµğ‘˜) by ğ‘¡ âˆ’ 2Î”. Thus,
all honest replicas must have received Cğ‘£(ğµğ‘˜) by ğ‘¡âˆ’Î”. We just need
to prove that no honest replica has entered the next view before
ğ‘¡ âˆ’ Î”. Suppose for the sake of contradiction an honest replica enters
the next view ğ‘£ + 1 before ğ‘¡ âˆ’ Î”, then it must have received and
broadcasted Bğ‘£ before ğ‘¡ âˆ’ Î”. Then, ğ‘Ÿ must have received Bğ‘£ before
ğ‘¡, and could not have sent commit for ğµğ‘˜ at ğ‘¡, a contradiction. Thus,
Session 6A: Consensus and Attacks CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1693Let ğ‘£ be the view number and replica ğ¿ be the leader of the view ğ‘£. While in view ğ‘£, a replica ğ‘Ÿ runs the following steps in iterations:
the proposal and âŸ¨vote, ğµğ‘˜, ğ‘£âŸ©ğ‘Ÿ .
(1) Propose. Upon receiving Cğ‘£(ğµğ‘˜âˆ’1), if ğ‘Ÿ = ğ¿, broadcast âŸ¨propose, ğµğ‘˜, Cğ‘£(ğµğ‘˜âˆ’1), ğ‘£âŸ©ğ¿ where ğµğ‘˜ extends ğµğ‘˜âˆ’1.
(2) Vote. Upon receiving a valid proposal âŸ¨propose, ğµğ‘˜, Cğ‘£(ğµğ‘˜âˆ’1), ğ‘£âŸ©ğ¿, if it has not detected equivocation in the current view ğ‘£, broadcast
(3) Pre-commit. Upon receiving Cğ‘£(ğµğ‘˜), broadcast it, wait for 2Î”, and broadcast âŸ¨commit, ğµğ‘˜, ğ‘£âŸ©ğ‘Ÿ .
(4) Commit. Upon receiving a quorum of âŸ¨commit, ğµğ‘˜, ğ‘£âŸ©âˆ—, forward them, and commit ğµğ‘˜ and all its ancestors.
Figure 2: An optimal multi-threshold BFT SMR â€“ steady state protocol.
Let ğ‘£ be the view number and replica ğ¿ and ğ¿â€² be the leader of the view ğ‘£ and ğ‘£â€², respectively. A replica ğ‘Ÿ run the following in view ğ‘£.
(1) Blame. When either two conditions below holds, broadcast âŸ¨blame, ğ‘£âŸ©ğ‘Ÿ .
(a) The replica ğ‘Ÿ cannot commit a transaction ğ‘¡ğ‘¥ by max{ğ‘‡ğ‘¡ğ‘¥,ğ‘‡ğ‘£} + Î› where ğ‘‡ğ‘¡ğ‘¥ is the time it receives ğ‘¡ğ‘¥, and ğ‘‡ğ‘£ is the time it starts
view ğ‘£, and Î› is a given time-out.
(b) The replica ğ‘Ÿ receives two equivocating proposals.
In the third case, broadcasts the two proposals, and stop all processes in the steady state of view ğ‘£ immediately.
(2) Status. Upon receiving Bğ‘£, broadcast it, stop all processes in the steady state of view ğ‘£, and send âŸ¨status, lockğ‘Ÿ , ğ‘£âŸ©ğ‘Ÿ to ğ¿â€² where
lockğ‘Ÿ is the highest certificate known to ğ‘Ÿ. Enter the next view ğ‘£ + 1.
(3) New-View. Upon receiving a quorum of âŸ¨status, lock, ğ‘£âŸ©âˆ— denoted Sğ‘£, if ğ‘Ÿ = ğ¿â€², broadcast âŸ¨new-view, lockğ‘£+1,Sğ‘£, ğ‘£ + 1âŸ©ğ¿â€², where
lockğ‘£+1 is a highest certificate in Sğ‘£.
certificate in Sğ‘£.
(4) First-Vote Upon receiving the first âŸ¨new-view, Cğ‘£â€²(ğµğ‘˜â€²),Sğ‘£, ğ‘£ + 1âŸ©ğ¿â€², broadcast it and âŸ¨vote, ğµğ‘˜â€², ğ‘£ + 1âŸ©ğ‘Ÿ , if Cğ‘£â€²(ğµğ‘˜â€²) is the highest
Figure 3: An optimal multi-threshold BFT SMR â€“ view change protocol.
all ğ‘› âˆ’ ğ›½ğ‘  â‰¥ ğ›¾ğ‘  + 1 honest replicas receive Cğ‘£(ğµğ‘˜) before entering
the next view ğ‘£ + 1, and the lemma holds.
â–¡
The rest of the safety proof under synchrony is the same as the
safety proof under partial synchrony.
Liveness. We prove liveness under partial synchrony when at most
ğ›¾ğ‘ â‰¤ ğ›¾ğ‘  replicas are faulty. Liveness under synchrony can be proven
in the same way, and we omit the details of the proof. We prove
that, with a reasonable timeout of Î› = ğ‘‚(Î”), every transaction is
eventually committed by all honest replicas.
Lemma 4.8. There exists a timeout Î› = ğ‘‚(Î”) such that every
transaction is eventually committed by all honest replicas.
Proof. Let ğ‘£ğ‘” be the highest view among honest replicas at the
global standardization time ğ‘‡ğ‘”. Then, all honest replicas receive
Bğ‘£ğ‘”âˆ’1 by ğ‘‡ğ‘” + Î” and enter view ğ‘£ğ‘”. We first prove that if an honest
replica (say ğ‘Ÿ) permanently stays in a view ğ‘£ â‰¥ ğ‘£ğ‘”, then every
transaction will eventually be committed by all honest replicas in
view ğ‘£.
If ğ‘Ÿ permanently stays in a view ğ‘£ â‰¥ ğ‘£ğ‘”, then no honest replica
enters a higher view ğ‘£â€² > ğ‘£ because that will make ğ‘Ÿ eventually
enter view ğ‘£â€² as well. If an honest replica commits a transaction
by committing a block ğµğ‘˜ in view ğ‘£, then the replica must have
received and broadcast a quorum of ğ‘› âˆ’ ğ›¾ğ‘  âŸ¨commit, ğµğ‘˜, ğ‘£âŸ©âˆ—, and all
honest replicas will also commit ğµğ‘˜ and the transaction. Thus, if
any transaction ğ‘¡ğ‘¥ is not eventually committed by ğ‘Ÿ, then it is not
committed in view ğ‘£ by any honest replica. Then, all honest replicas
send âŸ¨blame, ğ‘£âŸ©, receive Bğ‘£, and enter the next view ğ‘£+1. Therefore,
if ğ‘Ÿ permanently stays in a view ğ‘£ â‰¥ ğ‘£ğ‘”, then every transaction is
eventually committed by all honest replicas in view ğ‘£.
To complete the proof, it remains to show such a view indeed
exists. In fact, after the global standardization time, a view ğ‘£ with an
honest leader ğ¿ is a view that all honest replicas permanently stay
in. Let ğ‘¡ be the time when the first honest replica enters this view ğ‘£.
Then, the honest leader ğ¿ collects a quorum of âŸ¨status, lock, ğ‘£ âˆ’ 1âŸ©âˆ—,
broadcasts a valid âŸ¨new-view, Cğ‘£â€²(ğµğ‘˜â€²),Sğ‘£, ğ‘£ + 1âŸ©ğ¿, and receives a
certificate Cğ‘£(ğµğ‘˜â€²), and thus proposes a first block in the view ğ‘£
containing all transactions that have not committed yet by ğ‘¡ +ğ‘‚(Î”).
After that ğ¿ proposes a new block every 2Î” time (or less) upon
collecting a certificate for the previous proposal. Each proposed
block will collect a quorum of ğ‘› âˆ’ ğ›¾ğ‘  vote and commit within ğ‘‚(Î”)
time. Therefore, every honest replica commits every transaction ğ‘¡ğ‘¥
by max{ğ‘‡ğ‘£,ğ‘‡ğ‘¡ğ‘¥} + ğ‘‚(Î”), and thus stays in view ğ‘£.
â–¡
Remark on censorship resistance. Our protocol uses the stan-
dard and widely used stable leader approach of PBFT [14] where a
leader is replaced only if it is believed to be faulty. Thus, the pro-
tocol sets a timeout for each transaction to prevent a faulty leader
from censoring specific transactions. But this approach assumes an
honest leader is able to propose all transactions in time. In practice,
an adversary may create a large number of dummy transactions to
saturate the system and that would create an issue for the stable
leader approach. An alternative is to revolve the leader after every
block proposal such as in HotStuff [47]. The revolving leader ap-
proach offers simpler censorship resistance but is less efficient as a
leader cannot proposal multiple blocks in a non-blocking fashion.
Session 6A: Consensus and Attacks CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea16944.5 Efficiency
The latency of our protocol is 2Î”+3ğ›¿. It almost matches the latency
of Sync HotStuff (2Î”+ 2ğ›¿). The number of messages sent to commit
a block is ğ‘›+3ğ‘›2, which also close to that of PBFT (ğ‘›+2ğ‘›2) and Sync
HotStuff (ğ‘›+ğ‘›2). The amount of bits sent to commit a block is ğ‘‚(ğ‘›3)
as some message contains a linear number of signatures, which
matches that of Sync HotStuff but is more expensive than PBFTâ€™s
ğ‘‚(ğ‘›2) bit complexity. It can be reduced to ğ‘‚(ğ‘›2) using threshold
signatures. Our protocol commits blocks every 2ğ›¿ as a leader can
propose a subsequent block upon collecting a quorum of votes
for the previous proposal, which also matches that of PBFT and
Sync HotStuff. Therefore, we expect our protocol to have similar
performance as PBFT and Sync HotStuff.
4.6 Parameter Choices
Our protocol allows flexible parameter choices within the trade-offs
between safety and liveness as well as synchronous and partially
synchronous security. There are several characteristic parameter
choices with suited applications.
Strengthen the classic partially synchronous setting. A
prominent parameter choice is ğ›½ğ‘ = ğ›¾ğ‘ = ğ›¾ğ‘   ğ›½â€²
It is then easy to see that the converted protocol is live if both
the base protocol and the RBC protocol are live, and they commit
the same block. More interestingly, the converted protocol is safe if
either the base protocol or the RBC protocol is safe. From another
angle, in order to break safety in the converted protocol, the adver-
sary needs to break the safety of both the base protocol and the
RBC protocol. This is the key observation that leads to the upgraded
synchronous safety tolerance. Even when the base protocol violates
safety under synchrony, in the presence of ğ‘›âˆ’ğ›¾â€²
ğ‘  faults, the
RBC protocol, with its higher synchronous safety tolerance, guards
the safety of the converted protocol.
The other cases are more straightforward. With ğ›¾ğ‘ â€² faults under
synchrony or ğ›¾ğ‘â€² faults under asynchrony, both the base protocol
and the RBC protocol are safe and live. This also means the base
protocol functions as an honest virtual sender for the RBC. In this
case, by the integrity and validity properties, the RBC protocol
commits the same block as the base protocol. Thus, the converted
protocol achieves both safety and liveness. With ğ›½ğ‘ â€² faults under
synchrony or ğ›½ğ‘â€² faults under asynchrony, both the base protocol
and the RBC protocol are safe (but not necessarily live). The con-
verted protocol is also safe. We remind the readers that we only
consider the case with ğ›¾ğ‘ â€² â‰¤ ğ›½ğ‘ â€² and ğ›¾ğ‘â€² â‰¤ ğ›½ğ‘â€² in this paper. That
means a multi-threshold protocol may enjoy safety without live-
ness; but we do not consider the case in which a protocol enjoys
liveness without safety.
Actual framework with consistent broadcast. An acute reader
may have noticed that we did not use RBCâ€™s totality property in the
above argument. Indeed, totality is not needed and RBC is a slight
overkill. We used RBC in this intuitive overview for convenience
since we have already introduced RBC. In the actual framework,
we use a multi-threshold consistent broadcast, which is a weaker