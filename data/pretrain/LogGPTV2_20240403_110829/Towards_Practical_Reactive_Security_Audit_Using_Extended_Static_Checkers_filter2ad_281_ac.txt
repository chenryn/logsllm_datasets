. . .
i n t main ( ) {
C∗ pc = new C ( ) ;
B ∗pb = (B∗) pc ;
D ∗pd = (D∗) pb ;
pc−>e = 4 ;
pb−>a = 6 ;
pc−>h ( ) ;
pd−>f ( ) ;
}
( t h i s −>e > o l d ( t h i s −>e ) )
/∗ a l l o c a t i o n ∗ /
/∗ dynamic c a s t ∗ /
/∗ dynamic c a s t ∗ /
/∗ f i e l d a c c e s s ∗ /
/∗ base
f i e l d a c c e s s ∗ /
/∗ method c a l l
/∗ v i r t u a l method c a l l ∗ /
∗ /
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
Fig. 6. A simple C++ example.
A. Modeling C++ language constructs
By far, the most signiﬁcant shortcoming of HAVOC was
inability to deal with most C++ constructs. In this section,
we brieﬂy describe some of the changes required to handle
the most common C++ features used commonly in the COM
components. We illustrate the translation of C++ to BoogiePL
program with the aid of a simple example in Figure 6 and the
translated BoogiePL program in Figure 7.
To handle instance methods, we make the receiver object
explicit by exposing the this pointer. The BoogiePL transla-
tion of the procedure C::f takes this as an argument, and
updates the ﬁeld array Mem_e that represents the ﬁeld e in the
class. We use the function Offset_f_C to denote the offset
of a ﬁeld f in a class C. Further, the annotation expressions
can refer to this in assertions, as shown for this method.
Constructor calls are modeled by ﬁrst allocating a con-
tiguous buffer with the size of the class by invoking the
special method __HV_malloc. The mutable variable alloc
38
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:54:10 UTC from IEEE Xplore.  Restrictions apply. 
f u n c t i o n Delta D A ( x ) {x+0}
. . .
f u n c t i o n Delta B C ( x ) {x+12}
. . .
f u n c t i o n O f f s e t e C ( x ) {x+24}
. . .
v a r
a l l o c :
const Base :
const DT:
i n t ;
[ i n t ] i n t ;
[ i n t ] i n t ;
/∗ p o i n t e r
t o t h e
/∗ dynamic t y p e ∗ /
s t a r t o f an o b j e c t ∗ /
a l l o c
( new == o l d ( a l l o c ) )
( a l l o c > o l d ( a l l o c ) + n )
( f o r a l l u \ i n [ new , new+n ) . Base ( u ) = new )
(DT( new ) == t y p e )
e n s u r e s
e n s u r e s
e n s u r e s
e n s u r e s
p r o c e d u r e HV malloc ( n ,
r e t u r n s new ;
/∗ s e t
t y p e )
t h e dyn t y p e ∗ /
( Mem e [ O f f s e t e C ( t h i s ) > o l d ( Mem e [ O f f s e t e C ( t h i s ) ] ) ) )
e n s u r e s
p r o c e d u r e C : : f ( t h i s ){Mem e [ O f f s e t s e t e C ( t h i s ) ] + + ;} /∗ e x p l i c i t
p r o c e d u r e main ( ) {
‘ ‘ t h i s ’ ’ ∗ /
1
2
3
4
5
6
7
8
9
10
11 m o d i f i e s
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
}
}
pc = HV malloc ( 2 8 , C ) ;
c a l l C : : c t o r ( pc ) ;
pb = ( pc == 0 ? 0 : Delta B C ( pc ) ) ;
pd = ( pb == 0 ? 0 : Delta D B ( pb ) ) ;
Mem d[ O f f s e t e C ( pc ) ] = 4 ;
Mem d[ O f f s e t a D ( Delta D B ( ( pb ) ) ) ] = 6 ;
c a l l B : : h ( Delta B C ( pc ) ) ;
/∗ v i r t u a l method c a l l ∗ /
b a s e = Base ( pd ) ;
switch (DT( b a s e ) ) {
case A:
case B :
case C :
d e f a u l t :
c a l l A : : f ( b a s e ) ; break ;
c a l l B : : f ( b a s e ) ; break ;
c a l l C : : f ( b a s e ) ; break ;
c a l l D : : f ( b a s e ) ; break ;
c a l l ∗ /
f i e l d s o f 4 b y t e s ∗ /
/∗ 7 i n t e g e r
/∗ c o n s t r u c t o r
/∗ c a s t ∗ /
/∗ c a s t ∗ /
/∗ f i e l d a c c e s s ∗ /
/∗ f i e l d a c c e s s o f base c l a s s ∗ /
/∗ method c a l l ∗ /
/∗ o b t a i n t h e
s t a r t o f o b j e c t ∗ /
Fig. 7. The BoogiePL (cleaned up) for the C++ example.
monotonically increases to ensure that the buffer allocated is
fresh.5 The constant map Base tracks the base of the buffer
for any pointer in the buffer, and the constant map DT maps
the base of the buffer to its dynamic type (the type used during
allocation). The constraints are enforced by the speciﬁcation of
the procedure __HV_malloc speciﬁed using the
ensures
annotations. The newly allocated object is then passed to the
constructor of the class.
Dynamic casts is modeled by a conditional assignment that
checks if the right hand side (RHS) of the assignment is null
or not. In case, the RHS is non-null, it assigns the pointer
shifted by the offset of the base class in the derived type.
The functions Delta_A_B model the offset of a base class
A inside a derived class B.
Field access is modeled similar to C programs as before,
except for accessing ﬁelds inside base classes. To access ﬁelds
in a (transitive) base class (such as the ﬁeld a deﬁned within
the base class D from within B), we ﬁrst add the offset of
5We currently do not model deallocation.
the base classes in the access path from the derived class
(Delta_D_B for this example).
Non-virtual method calls are handled similar to C, except
the addition of the this parameter. Similar to ﬁeld access,
calling a method in one of (transitive) base classes requires
the addition of the offsets of the base classes in the access
path. Virtual method calls require looking up the dynamic
type (stored in DT) of the start of the object into a temporary
variable base and performing a case split on the possible set
of runtime types. For each dynamic type, the corresponding
virtual method is invoked (assuming for simplicity the method
is deﬁned in each derived class). In each of the cases, the
pointer passed as the this parameter is the start of the
object stored in the map Base during allocation. Currently,
we assume a separate analysis to compute the set of potential
target types that is fed into HAVOC-LITE as an input.
In addition, HAVOC-LITE also handles operator overload-
ing, simple forms of templates (both parameterized by types
or values) and other C++ features commonly encountered in
39
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:54:10 UTC from IEEE Xplore.  Restrictions apply. 
COM. Although the modeling is far from being considered
complete for C++, it allows us to get substantial coverage of
many C++ code-bases using COM.
B. Instrumentations
The instrumentation mechanism in HAVOC was extended
to support some object-oriented constructs. These include (a)
instrumenting all instance methods declared in a given class,
and (b) instrumenting an instance method in all classes.
The ﬁrst feature is useful for annotating class invariants,
by instrumenting all instance methods in a class with a pre-
condition and postcondition. In addition, the user can remove
the constructors and destructors from the set by using a set of
patterns that are excluded. For example,
__requires(x->f != null)
__ensures (y->f != null)
__instrument_universal_exclude(‘‘A$dtor’’)
__instrument_universal_exclude(‘‘A$ctor’’)
__instrument_universal_include(‘‘A$*’’)
__instrument_universal_type(x)
void __instrument_class_inv(A *x);
instruments all methods in the class A (denoted by the
_include pattern) except
the constructor and destructor
(denoted by the _exclude patterns) require and ensure that
a ﬁeld f is non-null for the receiver (“this”) object. Instance
methods that take additional objects of type A or static methods
that take an object of type A have to be manually excluded
though.
The second feature is often useful for getting the effect of
annotation inheritance, where annotation on a virtual method
is inherited by the overriding methods of all derived classes.
All instance methods with the name foo can be speciﬁed
with the pattern ‘‘*$foo’’. However, we currently do not
provide any support for checking that derived classes only
weaken preconditions and strengthen postconditions — it is
left to the user to enforce.
C. Inference
HAVOC used the Houdini algorithm [4] to choose inductive
invariants from a set of candidates. Although the inference was
successful in scaling to modules with several hundred to a few
thousand procedures [2], it did not scale to the modules that
had several hundred thousand procedures measuring several
million lines of code. In this section, we discuss the improve-
ments made to make the inference scalable to these modules.
1) Persisting fewer Boogie ﬁles: The approach in HAVOC
generated a single BoogiePL ﬁle on disk containing the
deﬁnition of all the procedures, and then invoked the Houdini
procedure inside Boogie. However, creating a Boogie ﬁle with
almost a million procedure did not scale as HAVOC crashed
due to memory blowup during the generation of the Boogie
ﬁle, and Boogie could not load such a ﬁle and perform VC
generation. Instead, we ﬁrst changed the ﬂow to generate a
Boogie ﬁle per procedure, and fed Boogie a list of Boogie
ﬁles. This avoided the memory blowup in HAVOC, but still
caused Boogie to take a long time.
Our ﬁrst observation is that for the purpose of Houdini
inference, one can safely ﬁlter procedures that do not have
any (a) candidate assertions inside the body of the procedure,
(b) does not have any candidate postconditions, (c) does not
have (immediate) callees that have a candidate precondition.
This is because analyzing such procedure will always return
“veriﬁed” as there are no assertions to check. This simple
optimization allowed us to reduce the number of Boogie ﬁles
used during the inference by at least 2 orders of magnitude,
when the annotations were sparse.
2) Two-level Houdini algorithm: In spite of the dramatic
reduction in the number of procedures being analyzed during
Houdini, we were still left with several tens of thousand of
procedures to analyze, and maintaining all the procedures (and
their VCs) in memory during Houdini exceeded memory. To
alleviate it, we designed a two-level Houdini algorithm that
uses a cache to only pass a small set of procedures to the
Houdini procedure.
Given a set of procedures P with candidate annotations C
and a cache size n, the algorithm operates as follows.
1) It ﬁrst initializes a work list W with all the procedures
in P .
2) At each stage, it removes a set S of n procedures from
W (or all procedures if |W| ≤ n) and invokes Houdini
on S.
tions R ⊆ C after analyzing S.
3) Houdini removes a (possibly empty) subset of annota-
4) For each removed candidate c ∈ R, we update the
worklist as follows: (a) if c is a precondition of a
method p (cid:8)∈ S, then we add p to W , and (b) if c is
a postcondition of a method p then we add any of its
caller q that is not present in S.
5) At the same time, C is updated to C \ R by removing
the candidates removed by Houdini.
6) The method is repeated until W is empty.
It is not difﬁcult to show that when W is empty, then the set
of candidates in C can be proved modularly.
The size of the cache inﬂuences the overall runtime as
the larger the cache, the more chance the (inner) Houdini
algorithm gets to perform optimizations, and thus the outer
loop converges faster. On the other hand, making the cache
large increases the memory consumption for Houdini. We have
observed that the memory requirement is really a function of
the size of the procedures instead of the number of procedures.
For a given problem where the size of the largest procedure
is k, it is useful to set n so that n ∗ k does not exceed the
memory alloted to the process. For most of our experiments,
n is set between 20 and 100.
3) Candidates on roots and leaves: It is well-known that
if the set of candidate preconditions on root procedures (that
have no callees) or the set of candidate postconditions on leaf
procedures (that have no body) are inconsistent, then Houdini
can infer annotations that may not hold. Previously, the users
of HAVOC manually ensured that the root procedures have no
candidate preconditions and leaf procedures have no candidate
postconditions. This was an expensive process as determining
40
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:54:10 UTC from IEEE Xplore.  Restrictions apply. 
the roots can be tricky when certain procedures are targets
of function pointers. To simplify matters, HAVOC-LITE ﬁrst
removes candidate preconditions from the root and candidate
postconditions from the leaves of the call graph presented to
it for annotation inference. This substantially improves the
usability of the inference for the user.
D. Other
In addition to the above enhancements, a number of other
usability issues were addressed. First, we added a mechanism
to insert annotations completely non-intrusively — i.e. the
source tree did not have to be modiﬁed. Annotations were
ﬁrst compiled with type and procedure declarations and then
linked with the deﬁnitions later. This greatly improved the
adoption in teams that did not want to modify the source
code, even to include an annotation header ﬁle. The separate
compilation of the annotation ﬁle also allowed us to correct
annotation parse errors quicker. HAVOC-LITE also added bit-
vector support by interpreting the scalars and pointers as ﬁxed-
size bit-vectors, and using the theory of bit-vectors inside SMT
solver Z3. Earlier implementation in HAVOC used unbounded
integers and could not model the bitwise operations accurately.
Finally, the user can associate custom strings and identiﬁers
for warning messages that are displayed on assertion failures
— this allowed easier triaging of warnings when multiple
properties were checked in a single run.
V. EVALUATION
In this section, we go through the evaluation of the capabil-
ities of HAVOC-LITE to detect variations of known software
problems that are commonly reported in Microsoft products.
Security holes belonging to these vulnerability classes, when
reported by independent security researchers, give rise to
security bulletins and general distribution release of ﬁxes.
Such bulletins are very costly for software vendors and users,
in particular for businesses with hundreds or thousands of
computers, whose activity is interrupted while the update
is performed. As such, each bulletin must ensure that
it
covers not only the originally reported security problem, but
variations of the problem that may be more easily identiﬁed by
third party researchers after the bulletin is published. Extended
static checking helps software vendors increase coverage of
such reactive analysis.
A. Checked properties
We have evaluated the tool on the large scale on multiple
heterogeneous properties across multiple products written in C
and C++, summarized in Figure 8. The properties were derived
by studying a set of security vulnerabilities reported in a set of
recent MSRC bulletins ( [13], [14], [15], [16], [17], [18], [19],
[20]). We avoid relating the properties to speciﬁc MSRC cases
to avoid disclosing any conﬁdential information not available
in the bulletins.
Some of the properties we describe in this table are in fact