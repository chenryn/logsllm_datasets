### 优化后的文本

#### C++ 语言结构建模
到目前为止，HAVOC 最显著的不足之处在于无法处理大多数 C++ 构造。在本节中，我们将简要描述处理 COM 组件中常用 C++ 特性所需的一些更改。我们通过图 6 中的一个简单示例和图 7 中的转换后的 BoogiePL 程序来说明 C++ 到 BoogiePL 的转换。

##### 实例方法处理
为了处理实例方法，我们通过暴露 `this` 指针使接收对象显式化。BoogiePL 对 `C::f` 方法的翻译将 `this` 作为参数，并更新表示类中字段 `e` 的字段数组 `Mem_e`。我们使用 `Offset_f_C` 函数表示类 `C` 中字段 `f` 的偏移量。此外，注释表达式可以在断言中引用 `this`，如该方法所示。

##### 构造函数调用
构造函数调用通过首先调用特殊方法 `__HV_malloc` 分配一个与类大小相等的连续缓冲区来建模。可变变量 `alloc` 单调递增以确保分配的缓冲区是新的。常量映射 `Base` 跟踪缓冲区内任何指针的基地址，而常量映射 `DT` 将缓冲区的基地址映射到其动态类型（分配时使用的类型）。这些约束通过 `__HV_malloc` 过程的 `ensures` 注释强制执行。新分配的对象然后传递给类的构造函数。

##### 动态类型转换
动态类型转换通过条件赋值来建模，该条件检查赋值右侧 (RHS) 是否为空。如果 RHS 非空，则将其指针加上基类在派生类型中的偏移量进行赋值。`Delta_A_B` 函数模型了派生类 `B` 中基类 `A` 的偏移量。

##### 字段访问
字段访问类似于 C 程序，但对于访问基类中的字段有所不同。为了访问基类中的字段（例如，在从 `B` 访问 `D` 中定义的字段 `a`），我们首先加上从派生类到基类的访问路径中的基类偏移量（例如 `Delta_D_B`）。

##### 非虚方法调用
非虚方法调用类似于 C，除了添加 `this` 参数。类似于字段访问，调用某个基类的方法需要加上基类在访问路径中的偏移量。虚方法调用需要查找对象起始处的动态类型（存储在 `DT` 中）并存入临时变量 `base`，然后对可能的运行时类型进行情况拆分。对于每种动态类型，调用相应的虚方法（假设每个派生类中都定义了该方法）。在每种情况下，作为 `this` 参数传递的指针是分配期间存储在 `Base` 映射中的对象起始位置。目前，我们假设有一个单独的分析来计算潜在的目标类型集合作为 HAVOC-LITE 的输入。

此外，HAVOC-LITE 还处理运算符重载、简单的模板（由类型或值参数化）和其他在 COM 中常见的 C++ 特性。尽管这种建模远未达到 C++ 完整性的要求，但它允许我们覆盖许多使用 COM 的 C++ 代码库。

#### 仪器化机制
HAVOC 的仪器化机制扩展了对一些面向对象构造的支持。这些包括：
- 为给定类中声明的所有实例方法添加仪器。
- 为所有类中的特定实例方法添加仪器。

第一个功能对于通过在类的所有实例方法中添加前置条件和后置条件来注释类不变量非常有用。用户可以通过使用排除模式来移除构造函数和析构函数。例如：

```cpp
__requires(x->f != null)
__ensures (y->f != null)
__instrument_universal_exclude("A$dtor")
__instrument_universal_exclude("A$ctor")
__instrument_universal_include("A$*")
__instrument_universal_type(x)
void __instrument_class_inv(A *x);
```

这会为类 `A` 中的所有方法（由 `_include` 模式表示）添加仪器，但不包括构造函数和析构函数（由 `_exclude` 模式表示），并要求和确保接收对象（"this"）的字段 `f` 非空。需要手动排除接受额外类型 `A` 对象的实例方法或静态方法。

第二个功能通常用于实现注解继承的效果，其中虚拟方法上的注解被所有派生类中的重写方法继承。所有名为 `foo` 的实例方法可以使用模式 `*$foo` 来指定。然而，我们目前没有提供任何支持来检查派生类是否只削弱前置条件并加强后置条件——这留给用户自行强制。

#### 推理
HAVOC 使用 Houdini 算法 [4] 从一组候选者中选择归纳不变量。虽然推理成功地扩展到了包含数百到数千个过程的模块 [2]，但它无法扩展到包含数十万个过程且代码行数达数百万的模块。在本节中，我们将讨论为使推理能够扩展到这些模块所做的改进。

1. **减少 Boogie 文件的数量**：HAVOC 的方法是在磁盘上生成一个包含所有过程定义的单个 BoogiePL 文件，然后在 Boogie 中调用 Houdini 过程。然而，创建包含近百万个过程的 Boogie 文件无法扩展，因为 HAVOC 在生成 Boogie 文件时因内存溢出而崩溃，而 Boogie 也无法加载如此大的文件并生成验证条件。相反，我们首先更改流程，为每个过程生成一个 Boogie 文件，并向 Boogie 提供一个 Boogie 文件列表。这避免了 HAVOC 的内存溢出问题，但仍导致 Boogie 耗时过长。

   我们的第一个观察是，对于 Houdini 推理的目的，可以安全地过滤掉以下过程：
   - 过程体内没有任何候选断言，
   - 没有任何候选后置条件，
   - 没有具有候选前置条件的直接调用者。
   
   这是因为分析这样的过程总是返回“已验证”，因为没有断言需要检查。这个简单的优化使得在注解稀疏的情况下，推理过程中使用的 Boogie 文件数量至少减少了两个数量级。

2. **两层 Houdini 算法**：尽管在 Houdini 推理过程中过程数量大幅减少，但我们仍然需要分析数万个过程，并且在 Houdini 期间维护所有过程（及其验证条件）的内存超出了限制。为了解决这个问题，我们设计了一个使用缓存的两层 Houdini 算法，只将一小部分过程传递给 Houdini 过程。

   给定一组带有候选注解 C 和缓存大小 n 的过程 P，算法如下操作：
   1. 初始化工作列表 W，包含 P 中的所有过程。
   2. 在每个阶段，从 W 中移除 n 个过程（或所有过程，如果 |W| ≤ n），并调用 Houdini 分析 S。
   3. Houdini 在分析 S 后移除 C 中的一组（可能是空的）候选注解 R。
   4. 对于每个移除的候选 c ∈ R，我们按以下方式更新工作列表：
      - 如果 c 是不在 S 中的方法 p 的前置条件，则将 p 添加到 W 中。
      - 如果 c 是方法 p 的后置条件，则将不在 S 中的任何调用者 q 添加到 W 中。
   5. 同时，C 更新为 C \ R，移除 Houdini 移除的候选者。
   6. 重复此方法直到 W 为空。

   当 W 为空时，C 中的候选注解可以被证明是模块化的。

   缓存的大小影响整体运行时间，因为缓存越大，内部 Houdini 算法就越有机会执行优化，从而使外部循环更快收敛。另一方面，增加缓存大小会增加 Houdini 的内存消耗。我们观察到内存需求实际上是过程大小的函数，而不是过程数量的函数。对于给定的问题，其中最大过程的大小为 k，设置 n 使得 n * k 不超过进程分配的内存是有用的。在我们的大多数实验中，n 设置在 20 到 100 之间。

3. **根和叶上的候选者**：众所周知，如果根过程（没有调用者）上的候选前置条件集或叶过程（没有主体）上的候选后置条件集不一致，Houdini 可能会推断出不成立的注解。以前，HAVOC 用户手动确保根过程没有候选前置条件，叶过程没有候选后置条件。这是一个昂贵的过程，因为当某些过程是函数指针的目标时，确定根节点可能会很棘手。为了简化问题，HAVOC-LITE 首先从呈现给它的调用图中的根和叶删除候选前置条件和候选后置条件。这大大提高了推理的可用性。

#### 其他改进
除了上述增强外，还解决了一些其他可用性问题。首先，我们添加了一种完全无侵入的方式插入注解，即不需要修改源树。注解首先与类型和过程声明一起编译，然后稍后与定义链接。这极大地提高了那些不想修改源代码甚至包含注解头文件的团队的采用率。注解文件的独立编译还使我们能够更快地纠正注解解析错误。HAVOC-LITE 还通过将标量和指针解释为固定大小的位向量并在 SMT 求解器 Z3 中使用位向量理论来添加位向量支持。HAVOC 早期的实现使用无界整数，无法准确建模位运算。最后，用户可以为显示在断言失败时的警告消息关联自定义字符串和标识符，这使得在单次运行中检查多个属性时更容易分类警告。

#### 评估
在本节中，我们将评估 HAVOC-LITE 检测 Microsoft 产品中常见软件问题变体的能力。属于这些漏洞类别的安全漏洞一旦被独立安全研究人员报告，就会产生安全公告并发布一般分发修复程序。此类公告对软件供应商和用户来说成本非常高，特别是对于拥有数百或数千台计算机的企业，其活动会在更新期间中断。因此，每个公告必须确保不仅涵盖最初报告的安全问题，还包括公告发布后第三方研究人员更容易识别的问题变体。扩展静态检查有助于软件供应商提高此类反应分析的覆盖率。

##### 检查的属性
我们已在多个异构属性上大规模评估了该工具，这些属性涉及多种用 C 和 C++ 编写的多个产品，总结见图 8。这些属性是通过对最近 MSRC 公告中报告的一组安全漏洞的研究得出的（[13]、[14]、[15]、[16]、[17]、[18]、[19]、[20]）。为了避免披露公告中不可用的任何机密信息，我们避免将属性与具体的 MSRC 案例相关联。

表中描述的一些属性实际上是对已知漏洞的变体。