对一次SRC平台漏洞挖掘 全程文字描述多一点。
* * *
测试范围:  
XXXXX平台: www.A.com  
Xxxxxxx平台: www.B.com
本人信息搜集不是很6, 我这里直接测他的某个站的主站。 所以我决定一个一个测，防止漏过，很多人一般都是先搜集子域名,
因为子域名的防护相对薄弱一点。而且奖金也一样的高。
我就先打开了A.com的主站 先用layer先跑他的子域。在信息搜集中，我先测测A.com  
看看能不能捡个漏。
第一眼就相中了这个搜索框 习惯性先测高危测起，先测SQL注入。  
在参数 输入 1’ 发现只返回了1
发现只返回了1 没有返回 1’
那这里SQL注入 就不存在了，但是我们可以联想到
  1. 这个站可能全局过滤了单引号？  
1.1. 如果真是这样 我只能找int类型注入  
1.2. 如果真是这样 这个可以帮我过Waf 利用全局特性过滤 se'l'e'c't=select
  2. 如果不是全局，那我们换个点来测
然后我就这个搜索框来继续测XSS，发现失败了。他过滤了。  
然后从其他点发现，他不是全局过滤单引号的，那我们实行plan B。
测试的时候发现有waf
**毕竟是主站，我们可以看看他是什么样的WAF,  
1.代码waf （对有效参数的参数值进行拦截）  
2.硬waf(拦截流量)**
我输入一个不存在的参数， **?x=1 union select**
直接给我拦了。  
说明存在Waf 拦截的是流量。
那我就先来绕Waf
最后发现这是智能型WAF, **他不会管注释里的内容**
那我的思路就来了 直接给他安排两个虚假的参数a 和b
程序只接收的到id参数
发现页面显示正常！  
轻松bypass 可以用来测注入 也能用来测XSS，毫无阻拦
一顿操作下来 一个漏洞都没测到
然后我们开始目录扫描 选择扫描302 403 200 这些 我用的BURP 因为怕其他软件的特征被封IP
一分钟过去后 我们看到了结果。
发现扫什么都是302 但是发现了tz这个目录不一样
返回的是这个，那这个tz目录绝对有猫腻呀！！
然后我们观察他的url结构 后面都是跟方法名 那我们不扫文件 直接扫方法
Fuzz一波
啊哈 扫到另一个add
字典呢 这里用的是  下载的
返回结果是用户名不能为空，那我们就构造用户名的参数  
Fuzz一波 比如username=1
啊哈？有不同的的返回结果了，让我们真实姓名不能为空 继续用&来构造参数
当我输入name=1 它还是提示这个，说明我们参数名不对，那我们百度一下真实姓名的英文 发现是realname 这个参数
OK 有了新的返回结果，感觉就像是在猜谜语一样哈哈。
当我们把身份证的英文字母都填进去的时候 发现答案都不对
这时候我有点丧气了 躺了一会想想 想起以前日站的时候 身份证号参数基本上都是idcard呀 这些
,突然想起来 会不会用的是拼音呢？
然后索性我就用sfz=1 发信还是提示的这个
我们注意到 是4个字 那我改为sfzh=1
然后就返回了这个 说明参数全部猜对了。
返回用户名1 已存在，我脑海中飞速运转。  
它为什么知道 用户名已经存在？  
答案一个：他和数据库交互了。
那这里就可能存在SQL注入。
一个单引号过去了 果然报错了 然后试着用and 来闭合
发现
忘记了 有waf 但是我们不是已经过waf了吗
指哪打哪  
a=/ _& username=1' and 1='1&realname=1&sfzh=111'&b=_/  
构造payload
1=2 的时候 返回这个
这不就百分百存在SQL注入吗，然后我绞经脑汁 测不出数据来 不知道他是啥数据库
用sqlmap跑直接给我IP给封了
最后 and 1=‘dddd
刚开始我看到这个 搜索了一波 刚开始以为是mssql 但是没测出来 用了waitfor delay 还报错了
还以为是HQL注入 最后测了 老半天. 去下了个hqlmap但是开始就卡死了
当时我还坚认为是HQL注入 哈哈哈 因为当时我是这么测的
and user=’1 （这是错误的规范哦 因为这里的1 也是字符串 只有int类型 才会出数据）
当时用substring 加上盲猜用户名函数是user 破解出user是dbo
我靠？是dbo 那还不是mssql数据库吗
继续测 看到原因了 修改payload
可以看到是报错mssql报错注入 可以欢快的出数据啦
* * *
**后续**  
一个SQL注入到手，后续测了很多东西,一顿手工操作定位到账号密码
拿到了账号密码去其他平台撞库了。
是一个PHP的站点
进了后台 然后有一处任意文件上传 是有WAF 检测后缀
首先上传个jpg 然后直接抓包改后缀 (是前端认证的话 抓包可以直接绕过)
换行直接绕过 发现能上传绕过。
可开心死我了。心想着一处Getshell到手了呀 然后再图片内容后面加上一句话木马
啊哈？go 一直是没反应 说明了他还检测内容. 那我直接把代码内容删了 从
发现上传成功了 解释一下 这是php的短标签风格 “=”号 这里相当于echo
之后发现是php5.6
那可好绕了 php7.0下面的php都能用assert拼接 他是拦截关键字的
直接$a='a'.'s'.'sert';
最后发现$_GET['a'],$_PSOT['b'].... 这种传参方式被拦截了，
继续 FUZZ 删到 他不拦截为止 删到了$_GET 他不拦截了 思路来了，那我可以用foreach。
    foreach ($_GET as $key=>$value){
        $$key=$value;
    }
伪全局,最后$key 相当于 $_GET['key']  
最后直接 $a($key); 原生代码就等于assert($_GET['key'])
然后久违的SHELL 就到手了~