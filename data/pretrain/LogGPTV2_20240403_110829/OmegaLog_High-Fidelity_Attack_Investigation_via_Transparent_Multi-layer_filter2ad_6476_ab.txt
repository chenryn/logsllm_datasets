that can waste space and CPU cycles [41]. Most notably, prior
approaches do not consider the broader value of application
semantics as forensic evidence outside of the bare minimum
required for the identiﬁcation of work units.
Limitation of System Logs #2: Semantic Gap. Existing
system-level provenance logs are beneﬁcial in that they offer
a broad view of system activity, but unfortunately they lack
knowledge of application-speciﬁc behaviors that are pivotal for
attack reconstruction. In our motivating example, information
such as failed login attempts, HTTP headers, WordPress plugin
behavior, and SQL queries cannot be extracted from system
logs. Such information is present in the siloed event logs
of each application; PostgreSQL maintained a record of all
SQL queries, and HAProxy recorded the headers for all HTTP
requests. However, it is not possible to associate those event
descriptions with the system records reliably in a post-hoc
manner, because of multi-threaded activity and ambiguous or
incomplete information within the application event logs.
Prior work has sought to address the semantic gap prob-
lem through instrumentation-based techniques [57], [28], [55].
Those approaches either statically or dynamically instrument
function calls in the application to disclose function names,
arguments, and return values. However, such instrumentation-
based systems suffer from several limitations: (1) developers
need to specify which functions to instrument, imposing a
domain knowledge requirement; (2) the logging information is
captured on a per-application basis and thus cannot be used to
connect information ﬂow between different applications; and
(3) high-level semantic events may not always be effectively
captured at the function call level.
C. Our Approach
Recent work in application logging [25], [65], [64], [21],
[49] has shown the efﬁcacy of application logs in program
understanding, debugging, and proﬁling. OmegaLog takes in-
spiration from those efforts, with the goal of better leveraging
event logs during attack investigation. The key insight behind
OmegaLog is that developers have already done the hard work
of encoding high-level application semantics in the form of
event logging statements; these statements not only contain
the relevant forensic information that we require, but also mark
the boundaries of execution units in the program. The insertion
of event logging statements is an organic byproduct of sound
software engineering practices, permitting developers and users
to better understand programs’ runtime behavior. Thus, it is
possible to enrich system logs with application semantics
without further instrumentation or proﬁling. Moreover, these
applications logs can be used to identify execution units.
Applying that intuition to our motivating example yields
the provenance graph in Fig. 3a, which was generated using
OmegaLog. The administrator can associate the malicious SQL
(a) Investigating SQL injection attack using SQL query that reads
the accounts table.
(b) Investigating website defacement using a ﬁle write event to
index.html as a symptom.
Fig. 3: Graphs generated by OmegaLog for the SQL injection attack.
The parallelograms represent the app log vertices. App log vertex
is annotated with log messages which belong to the corresponding
execution unit of attached process vertex.
query with a speciﬁc system call event (read). By performing
execution partitioning on PostgreSQL using OmegaLog’s log-
ging behavior analysis, the administrator is then able to trace
back to system calls issued and received by Apache httpd,
which are also annotated with application events describing
the vulnerable web form. Iteratively, OmegaLog uses execution
partitioning again to trace back to the correct unit of work
within HAProxy to identify the IP address of the attacker. After
ﬁnding out how the user data and login credentials were stolen
using SQL injection, the investigator tries to ﬁgure out how the
website was defaced by issuing a backward-tracing query on
the index.html ﬁle. Using the OmegaLog provenance graph
shown in Fig. 3b, the investigator deduces that the attacker
used a WordPress ﬁle manager plugin to change index.html.
III. THREAT MODEL & ASSUMPTIONS
This work considers an attacker whose primary goal is to
exploit a security vulnerability in an application running on
a system and exﬁltrate or manipulate sensitive information
present in the system. We make the typical assumptions of
work in this space about the integrity of the operating system,
kernel-layer auditing framework, audit logs and application
event logs, all of which is in our trusted computing base
(TCB) (cf., [39], [42], [41], [36], [30], [38], [58], [16]).
That assumption is made more reasonable through system-
hardening techniques, e.g., [17], [20], designed to mitigate
threats to system logs. Like all prior work on execution
partitioning [39], [42], [41], [38], [29], [32], we also assume
the integrity of applications’ control ﬂows (further discussed in
§X). We consider hardware-layer trojans, side channel attacks,
and backdoors to be out of scope of this paper.
4
httpdHAProxypostgresqlx.x.x.xuser.phpBashhaproxy[30291]: x.x.x.x:45292 [TIME REMOVED] app-http-in~app-bd/nginx-2 10/0/30/69/109 200 2750 – – —- 1/1/1/1/0 0/0 {} {} “POST /user.php HTTP/1.0" y.y.y.y POST /wordpress/user.php 200 - HTTP/1.1 200 1568 "-"Statement: SELECT * FROM users WHERE user_id=123 UNION SELECT password FROM accounts;httpdHAProxyx.x.x.xIndex.htmlBash y.y.y.y POST /wordpress/wp-admin/admin-ajax.php 200 - http://shopping.com/wordpress/wp-admin/admin.php?page=ﬁle-manager_settingshaproxy[30291]: x.x.x.x:45292 [TIME REMOVED] app-http-in~app-bd/httpd-2 10/0/30/69/109 200 2750 POST /wordpress/wp-admin/admin-ajax.php 200 …IV. APPLICATION LOGGING BEHAVIOUR
Our approach to partition long-running program into exe-
cution units and overcome the dependence explosion problem
depends on the pervasiveness of event-logging behavior in
those applications. Fortunately, the importance of logging in
applications has been widely established [33]. Practically, all
open-source applications print event log messages, offering
four levels of verbosity: FATAL is for an error that is forcing a
shutdown, ERROR is for any error that is fatal to the operation,
INFO is for generally useful information, and DEBUG is for
information that is diagnostically helpful. Note that logging
levels are inclusive; higher levels also print messages that be-
long to lower levels (i.e. FATAL ⊆ ERROR ⊆ INFO ⊆ DEBUG).
However, to partition successful executions of an appli-
cation into its units, we require log messages with verbosity
level of INFO or DEBUG to be present inside event-handling
loops. Unfortunately, such behavior in applications has not
been investigated. In that regard, we studied a large number
of popular open-source applications.
We collected a list of 79 long-running Linux applications
which belong to different categories. Those applications are
written in the C/C++, Java, Python, and Erlang programming
languages. We investigated the source code and man pages
of those applications to identify the event-handling loops and
understand if they print log messages for each meaningful
event. Lee et al. [39] conducted a similar study in 2013 but they
only analyzed the design patterns of open-source applications
and the pervasiveness of event-handling loops as drivers for
execution. They did not however study the logging behavior
of those applications and the presence of log messages inside
event-handling loops.
We summarize our results in Table II. In the column “Apps
with Log Verbosity of”, we show how many of 79 proﬁled
applications include log statements in their event-handling
loop at verbosity of INFO and DEBUG, and how many of 79
applications do not print meaningful log messages for new
events. We observe that 39 applications print log with both
INFO and DEBUG verbosity levels (IN+DE) inside the event-
handling loops. While 8 applications only log at INFO level and
17 applications only log at DEBUG level.1 We show the intra-
event-handling loop logging behavior of some of the well-
know applications in Figure 4.
During our study, we found 15 applications that do not
have any information about event logs in their source code or
in man pages. We categorized those applications as follows:
• Light-weight Applications: Certain client-server applica-
tions are designed to be light-weight to keep a minimal
resource footprint. Those applications – including thttpd
(Web server) and skod (FTP client) – do not print log
messages for new events.
• GUI Applications: We observe that 12 out of 17 GUI
applications either (1) do not print log messages, or (2) they
print log messages that do not match the expectations of the
forensic investigator. In other words, those log messages
to partition the execution. Ma et
were not meaningful
1For web servers such as lighttpd and NGINX, we treat the Access Log as
INFO level log. Moreover, for certain applications that do not have DEBUG
log level, we categorize the Trace Log as DEBUG level log.
TABLE II: Logging behavior of long-running applications.
Category
Web server
Database server
SSH server
FTP server
Mail server
Proxy server
DNS server
Version control server
Message broker
Print server
FTP client
Email client
Bittorrent client
NTP client
r
e
v
r
e
S
-
t
n
e
i
l
C
I Audio/Video player
U
G
PDF reader
Image tool
Total
Total Apps with Log Verbosity of
Apps IN+DE INFO DEBUG None
9
9
5
5
4
4
3
2
3
2
6
3
4
3
8
4
5
79
7
7
5
4
3
3
2
0
2
1
0
1
3
0
1
0
0
39
1
1
0
0
1
1
0
1
0
0
1
0
1
1
0
0
0
8
0
1
0
1
0
0
1
1
1
1
4
1
0
2
3
0
1
17
1
0
0
0
0
0
0
0
0
0
1
1
0
0
4
4
4
15
al. [41] also observed similar behavior for GUI applications
where event-handling loops do not correspond to the high-
level logic tasks. For example, we found that none of the
PDF readers in our study printed log messages whenever
a new PDF ﬁle was opened. Such PDF ﬁle open event is
forensically important event for threat investigations [41].
Our study suggests that sufﬁcient logging information is
present inside the event-handling loops of long-running appli-
cations. This behavior allows us to automatically identify the
unit boundaries of those programs. For further evaluation, we
only consider the applications shown in Table III. We picked
those applications based on their popularity and category.
Note that we did not pick any subjects from the category of
applications that do not print meaningful log messages for new
events. Moreover, GUI applications usually use asynchronous
I/O with call backs and such programming model
is not
currently handled by OmegaLog (described more in §X).
V. DESIGN OVERVIEW
A. Deﬁnitions
Whole-System Provenance Graph. A graph generated from
system-level audit logs, in which the vertices, represent the
system subject (processes) and system objects (ﬁles and socket
connection), while the edges represent a causal dependency
event. The edges are usually annotated with a timestamp of
the event and the type of event, such as read or execute.
Causality Analysis. Forensic investigators use the whole-
system provenance graph to ﬁnd the root causes and rami-
ﬁcations of an attack by performing backward and forward
causality analysis on the graph, respectively. Given a symptom
of an attack, an investigator can issue a backward-tracing query
on the graph; it will ﬁnd root cause of the attack by traversing
the ancestry of the symptom event. The investigator can also
issue a forward-tracing query that starts from the root cause
identiﬁed in the previous query and returns all the causally
connected events in the progeny of the root cause, explaining
the ramiﬁcations of the attack.
5
Fig. 4: Logging behavior of different applications inside the event-handling loop. Underlined code represent log printing statements.
Properties of Causality Analysis. The provenance graph
should preserve the following three properties of causality
analysis. Validity means that the provenance graph describes
the correct execution of the system ,i.e., the provenance graph
does not add an edge between entities that are not causally
related. Soundness means that the provenance graph respects
the happens-before relationship during backward and forward
tracing queries. Completeness means that the provenance graph
is self-contained and fully explains the relevant event.
B. Design Goals
The limitations mentioned in §II on prior work motivated
our identiﬁcation of the following high-level goals:
• Semantics-Aware. Our threat investigation solution must be
cognizant of the high-level semantic events that occurred
within the contexts of each attack-related application.
• Widely Applicable. Our solution must be immediately
deployable on a broad set of applications commonly found
in enterprise environments. Therefore,
the solution must
not depend on instrumentation or developer annotations.
Moreover, our techniques should be agnostic to applica-