Phone、Android、Tizen以及iOS。几乎各个地方都能见到它的身影。
VLC作者的原话为：“这是个非常流行，但也非常复杂的软件”。我们相信字幕类漏洞同样也存在于VLC中。
**6.2 结构设计**
事实上，VLC是一个全功能的多媒体框架（类似于[DirectShow](https://msdn.microsoft.com/en-us/library/windows/desktop/dd375454\(v=vs.85\).aspx)或者[GStreamer](https://gstreamer.freedesktop.org/)），并且支持许多模块的动态加载及插入。
VLC的核心框架所做的事情就是“串起”输入输出以及处理媒体数据，其输入为文件或网络流，输出为音频、视频，可以输出到显示屏上或网络中。VLC在每个阶段都会使用模块来处理大多数工作（包括各种[分离器](https://wiki.videolan.org/Documentation:Hacker%27s_Guide/Demux/)、[解码器](https://wiki.videolan.org/Documentation:Hacker%27s_Guide/Decoder/)、过滤器以及输出）。
VLC中主要模块的功能如下图所示：
图23. VLC模块
**6.3 字幕**
暂时抛开VLC，让我们来聊聊杂乱无章的字幕世界。
在我们研究过程中，我们总共遇到了超过25种格式的字幕！某些字幕是二进制形式的，某些是文本形式的，只有少数几种字幕有较为完善的文档说明。
我们都知道SRT字幕支持少数几种HTML标签以及属性，但让我们惊讶不已的是，其他许多字幕格式可以支持各种各样的奇怪功能。比如，[SAMI](https://msdn.microsoft.com/en-us/library/ms971327.aspx)字幕支持内嵌图片，[SSA](https://en.wikipedia.org/wiki/SubStation_Alpha#Principal_sections_in_an_SSA_subtitle)字幕支持多种主题及样式定义，然后可以从每个字幕中引用这些主题及样式，而[ASS](https://en.wikipedia.org/wiki/SubStation_Alpha#Advanced_SubStation_Alpha)字幕甚至允许内嵌二进制形式的字体。这个名单还可以不断延伸下去。
通常情况下，我们并没有统一的库来解析所有的字幕格式，这些解析任务都会分摊给每个开发者，但问题也出自于此。
**6.4 回到VLC**
VLC会在名为[subtitle.c](https://github.com/videolan/vlc/blob/2.2.0-git/modules/demux/subtitle.c)的分离器中对文本形式的字幕进行解析。
这个分离器所支持的全部格式及对应的解析函数如下所示：
图24. subtitle.c中负责解析的函数数组
这个分离器的唯一任务就是解析不同格式的时间线信息，然后将每个字幕发送到对应的解码器。SSA以及ASS使用开源库[libass](https://github.com/libass/libass)进行解码，除此之外，其他所有的格式都会发往VLC自己的subsdec.c解码器。
[subsdec.c](https://github.com/videolan/vlc/blob/2.2.0-git/modules/codec/subsdec.c)会解析每个字幕中的文本字段，然后创建与其对应的两个版本。第一个版本是一个去掉所有标签、属性以及样式的明文版本。VLC会在字幕渲染失败时启用这个版本。
第二个版本是一个HTML字幕版本，包含更多的功能，比如各种样式属性（字体、对其）等。
字幕解码完成后，就会被发往最后一个阶段，以便渲染呈现。VLC主要是使用[freetype库](https://www.freetype.org/developer.html)来进行文本渲染。
以上过程基本覆盖了字幕从加载到显示的整个生命周期。
**6.5 漏洞寻找**
在VLC字幕相关代码中，我们很快注意到VLC使用原始指针而不是使用内置的字符串函数来完成大量解析工作。通常情况下这不是一个好的解决方法。
比如，当处理字体标签中的某些可能的属性时（如字体类别、大小或者颜色），VLC在某些地方无法验证字符串的结束位置。因此，这些解码器会继续从缓冲区中读取数据，跳过任何Null结束符，直到遇到一个‘>’字符为止（CVE-2017-8310）。
图25. subsdec.c CVE-2017-8310
**6.6 模糊测试**
在人工对代码进行审计时，我们同时也对VLC进行了模糊测试，寻找与字幕有关的漏洞。
我们选择的模糊测试工具是[AFL](http://lcamtuf.coredump.cx/afl/)。AFL是面向安全的模糊测试器，采用了编译时规范策略以及遗传算法来发现目标程序内部中新的状态及触发边缘执行路径。AFL已经发现了无数个[漏洞](http://lcamtuf.coredump.cx/afl/#bugs)，如果输入正确的语料库，那么AFL就可以在非常短的时间内给出非常有趣的测试用例。
在我们的语料库中，我们下载并重写了多个字幕文件，这些文件包含多种格式，具备多种不同的功能。
为了避免软件的视频渲染及显示功能（我们的模糊测试服务器没有安装任何图形显卡），我们使用转码功能将一个没有任何内容的短视频从一种编码转化为另一种编码。
我们用来运行AFL的命令如下所示：
    ./afl-fuzz –t 600000 –m 2048 –i input/ -o output/ –S “fuzzer$(date +%s)” -x subtitles.dict — ~/sources/vlc-2.2-afl/bin/vlc-static –q –I dummy –subfile
    @@ -sout=‘#transcode{vcodec=“x264”,soverlay=“true”}:standard{access=”file”,mux=”avi”,dst=”/dev/null”}’ ./input.mp4 vlc://quit
**6.7 崩溃点**
没过多久，AFL就发现了存在漏洞的一个函数：ParseJSS。JSS代表的是JACO Sub
Scripts文件。JACOsub是一种非常灵活的格式，可以支持时间线修改（如跳转）、可以包含外部JACOsub文件、可以暂停时钟，还有许多功能可以在其规范文档中找到。
JACO脚本的功能实现非常依赖于指令（directive）。一条指令由一系列字符编码组合而成，这些编码决定了字幕的位置、字体、样式、颜色等等。指令只会对当前附加的那条字幕造成影响。
AFL发现的崩溃点与越界读取漏洞有关，当程序在尝试跳过不支持的指令时（即当前尚未完全实现的功能）就会发生越界读取问题，漏洞编号为CVE-2017-8313。
图26. Subtitle.c（CVE-2017-8313）
如果某条指令后面没有跟着任何空格符，那么这个while循环就会跳过Null字节，越过psz_text缓冲区边界，继续往下读取。在整段代码中，psz_text是一个指针，指向一个在堆上分配的、以Null为结束符的字符串。
这个崩溃点引起了我们对ParseJSS函数的关注，我们很快又发现了程序在解析其他指令时存在的另外两个越界读取问题。这一次对应的是跳转（shift）以及时间（time）指令（分别对应‘S’以及‘T’）。原因在于跳转长度可能会比psz_text的长度更大（CVE-2017-8312）。
图29. Subtitle.c（CVE-2017-8311）
在另一种情况下，VLC会直接跳过NULL字节（第1883行）。
图30. Subtitle.c（同样为CVE-2017-8311）
这一行为也会导致堆缓冲区溢出漏洞。
**6.8 漏洞利用**
VLC支持许多操作系统及硬件架构平台。从指针大小到缓存策略，每个平台在功能以及堆实现细节上可能存在不同，这些因素都对漏洞利用造成一定影响。
在我们的PoC中，我们决定使用Ubuntu 16.04
x86_64系统。这个演示平台是现今非常流行的一个平台，因此这个PoC同样适用于现实世界。由于堆的实现代码是开源的，因此我们可以较为深入地理解漏洞利用过程中的具体细节。
经过多年的发展，现存的针对GLibC-malloc函数的通用型堆利用技术已经寥寥无几。然而，VLC漏洞的触发条件使得我们无法使用已有的这些方法。
我们唯一的选择是使用这个漏洞作为数据写入方法来覆盖某些应用的特定数据。被覆盖的这些数据反过来又会导致更加严重的后果（可以在任意位置写入任意数据），或者完全控制代码执行流程。
VLC是一个高度线程化的应用。根据堆的具体实现，这意味着每个线程在堆上都有各自的资源，这限制了我们可以覆盖的对象数量（只有在线程中分配的负责处理字幕的对象才是我们可能覆盖的对象）。并且，我们很有可能能够溢出代码附近的某个对象来触发漏洞。
线程创建点和存在漏洞的函数之间的距离并不远。我们开始手动寻找有用的对象，然后发现了demux_sys_t和variable_t这两类对象。此外，通过自动跟踪堆上分配的每个对象，我们还发现了link_map、es_out_id，以及包含虚拟表的一些Qt对象。经过删选，我们最终选择了variable_t对象作为研究目标。
图31. variable_t结构体
该对象用于在VLC应用中保存各种类别的数据，包括模块的配置信息和命令行选项。由于这些对象数目较多，因此我们有机会在某个对象之前找到缝隙，进而修改堆布局。variable_t结构包含一个p_ops字段，该字段保存了一个指针，指向的是操作变量值的某个函数地址。攻击者可以通过控制这个字段获得对程序的控制权。其他对象由于无法利用或者存在过多限制无法成为我们的利用目标。
现在我们已经有一个能够利用的对象，我们必须在该对象之前，在堆上分配一个JACOSubScript（JSS）字幕对象。通过精心选择分配对象，修改堆布局，使其成为可预测的、可使用的状态，这一过程称之为堆风水（Heap
Feng Shui、或者称为堆功夫、堆美容）。相当幸运地，我们偶然发现目标对象（即variable_t(sub-fps)）前恰巧有一个缝隙（hole）可以使用。
图32. variable_t之前的内存布局
尽管我们没有必要非得使用其他堆修改方法，但我们的确发现了一段非常有趣的代码，这段代码可以在要求更为精准的环境下给我们提供非常大的帮助。当VLC打开一个字幕文件时，它并不知道该使用哪个模块来解析这个新的文件。VLC采用了非常模块化的架构，当需要解析某个文件时，它会查找所有的模块（库），加载这些模块，然后判断这些模块是否能解析给定的输入流（在这种情况下，输入流即为字幕文件）。存在漏洞的代码位于字幕模块中，但这个模块不是第一个被加载的模块。
VLC会先加载两个模块，VobSub模块会被加载，用来检查字幕文件是否为VobSub格式。我们可以欺骗这个模块，在文件的第一行中设置VobSub魔术值，这样一来，VobSub模块就会认为我们的字幕文件为VobSub格式。然后，这个模块开始解析输入文件，执行各种内存分配及释放操作。这段代码比我们目标对象的分配代码更早执行，因此我们刚好可以将VobSub/JSS用于堆风水过程。
利用这一漏洞，我们可以线性地覆盖某个已分配的字幕字符串后的数据。这里存在一个问题，variable_t结构体的第一个字段为psz_name，这个字段应该为字符串的一个指针。在VLC的整个生命周期中，这个指针的引用计数会被减去若干次。由于ParseJSS函数会拷贝字符串，因此我们无法写入NULL字节，因为它为有效指针的前两个字节。这样一来，我们无法写入有效的指针数据，也无法真正溢出variable_t结构体。
为了克服这一问题，我们拓展了堆的元数据功能。我们使用了一系列分配、溢出、释放操作，经过这些复杂的操作后，我们覆盖了元数据中的堆块（chunk）大小值（与该案例类似）。这样一来，我们可以在不覆盖psz_name字段的前提下，覆盖variable_t结构提中的p_ops字段。
现在，我们的问题变为：我们具体应该写入什么数据？当VLC被关闭时，Destroy函数就会使用p_ops这个字段。这段代码会调用该字段所指向的数组中的pf_free函数，并将该值以参数形式传递给被调用的函数。因此，我们需要写入一个指针，将其指向另一个指针，后者指向的是我们第一个利用点所在的位置（实际上是16个字节之前）。这里我们面临的主要问题是ASLR。我们不知道任何数据的实际位置。这种环境也称之为无脚本利用环境。
解决这个问题的一种方法是使用部分覆盖方法。原始的指针指向的是libvlccore库中的float_ops静态数组。我们可以部分覆盖这个值，让指针指向libvlccore库中的其他位置。
另外一种方法就是将指针指向ubuntu中没有被随机化的主程序。我们在主程序中发现了一些非常有趣的小工具。比如，某个小工具会调用dlysm，然后将生成的结果作为第一个参数传递给另一个寄存器（具体代码为：dlsym(-1,
$rsi)($rbx)）。
第三种方法就是执行部分复制操作。由于我们的漏洞利用过程会从堆块外复制数据，因此我们可以修改堆结构，将某个堆指针写入到堆块中，然后执行部分复制操作即可。
虽然这几种方法看起来都非常有希望，但我们并没有使用这些方法。无脚本利用会给我们带来许多挑战，并且在这种环境下，为了演示漏洞利用过程我们需要研究太多细节。我们选择了另一种方法，那就是禁用ASLR机制，将指针指向合适的堆地址。此时，漏洞可利用的地址发生了些许改变，很有可能需要根据线程的具体行为进行调整，但从统计概率上来看，我们可以认为该地址为某个特定的地址。我们的下一个问题是，我们应该指向那个区域？VLC会逐行读取字幕文件，并将每行字幕复制到堆块中。这种底层的按行读取机制导致单行字幕的最大大小会被限制为204800字节。
我们将漏洞利用数据存放到VLC所允许的最长行中，据此发现漏洞可利用的地址的分布情况。我们构建了一个基于ROP链的libvlccore库，并在开头部位设置了一个特征值。然后，我们将p_ops字段指向特征值，使用我们构造的字幕文件启动VLC。最终，我们让VLC运行并弹出了一个gnome-calculator程序。
**七、总结**
利用各种漏洞，我们能够攻击流媒体平台并且获得用户电脑的控制权。这些漏洞的类型包括XSS漏洞、逻辑漏洞以及内存损坏漏洞等等。
由于使用率高、覆盖面积大，这些多媒体播放器暴露了非常巨大的攻击面（我们相信还有其他播放器受到类似漏洞影响），可能会影响数亿用户。
这里我们可以总结出一个结论：许多表面上安全且容易被我们忽略的地方，恰恰可以作为攻击者突破途径。我们将继续探寻可能被攻击者利用的突破口，保护用户免受攻击。