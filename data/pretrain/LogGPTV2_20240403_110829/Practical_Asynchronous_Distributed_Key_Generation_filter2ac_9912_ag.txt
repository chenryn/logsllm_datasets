actions on Telecommunications, vol. 5, no. 4, pp. 449–458,
1994.
[22] S. Duan, M. K. Reiter, and H. Zhang, “Beat: Asynchronous
bft made practical,” in Proceedings of the 2018 ACM SIGSAC
Conference on Computer and Communications Security,
2018, pp. 2028–2041.
[23] T. ElGamal, “A public key cryptosystem and a signature
scheme based on discrete logarithms,” IEEE transactions on
information theory, vol. 31, no. 4, pp. 469–472, 1985.
[10] D. Boneh, B. Lynn, and H. Shacham, “Short signatures from
the weil pairing,” in International conference on the the-
ory and application of cryptology and information security.
Springer, 2001, pp. 514–532.
[24] A. Fiat and A. Shamir, “How to prove yourself: Practical solu-
tions to identiﬁcation and signature problems,” in Conference
on the theory and application of cryptographic techniques.
Springer, 1986, pp. 186–194.
[11] G. Bracha, “Asynchronous byzantine agreement protocols,”
Information and Computation, vol. 75, no. 2, pp. 130–143,
1987.
[25] M. J. Fischer, N. A. Lynch, and M. S. Paterson, “Impossibility
of distributed consensus with one faulty process,” Journal of
the ACM (JACM), vol. 32, no. 2, pp. 374–382, 1985.
[12] C. Cachin, K. Kursawe, and V. Shoup, “Random oracles in
constantinople: Practical asynchronous byzantine agreement
using cryptography,” Journal of Cryptology, vol. 18, no. 3,
pp. 219–246, 2005.
[26] P.-A. Fouque and J. Stern, “One round threshold discrete-
log key generation without private channels,” in International
Workshop on Public Key Cryptography. Springer, 2001, pp.
300–316.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:34:29 UTC from IEEE Xplore.  Restrictions apply. 
14
2531
[27] A. G ˛agol, D. Le´sniak, D. Straszak, and M. ´Swi˛etek, “Aleph:
Efﬁcient atomic broadcast in asynchronous networks with
byzantine nodes,” in Proceedings of the 1st ACM Conference
on Advances in Financial Technologies, 2019, pp. 214–228.
[42] E. Kokoris-Kogias, E. C. Alp, L. Gasser, P. Jovanovic, E. Syta,
and B. Ford, “Calypso: private data management for de-
centralized ledgers,” Proceedings of the VLDB Endowment,
vol. 14, no. 4, pp. 586–599, 2020.
[28] Y. Gao, Y. Lu, Z. Lu, Q. Tang, J. Xu, and Z. Zhang, “Efﬁcient
asynchronous byzantine agreement without private setups,”
arXiv preprint arXiv:2106.07831, 2021.
[29] R. Gelashvili, L. Kokoris-Kogias, A. Sonnino, A. Spiegel-
man, and Z. Xiang, “Jolteon and ditto: Network-adaptive
efﬁcient consensus with asynchronous fallback,” in Interna-
tional conference on ﬁnancial cryptography and data security.
Springer, 2022.
[30] R. Gelashvili, L. Kokoris-Kogias, A. Spiegelman, and Z. Xi-
ang, “Brief announcement: Be prepared when network goes
bad: An asynchronous view-change protocol,” in Proceedings
of the 2021 ACM Symposium on Principles of Distributed
Computing, 2021, pp. 187–190.
[31] R. Gennaro, S. Jarecki, H. Krawczyk, and T. Rabin, “Secure
distributed key generation for discrete-log based cryptosys-
tems,” Journal of Cryptology, vol. 20, no. 1, pp. 51–83, 2007.
[32] N. Giridharan, L. Kokoris-Kogias, A. Sonnino,
and
A. Spiegelman, “Bullshark: Dag bft protocols made practi-
cal,” arXiv preprint arXiv:2201.05677, 2022.
[33] GNOSIS, “Distributed key generation,” 2020, https://www.
nongnu.org/dkgpg/.
[34] J.
Grigg
and
https://github.com/zkcrypto/pairing.
S.
Bowe,
“zkcrypto/pairing,”
[35] J. Groth, “Non-interactive distributed key generation and key
resharing.” IACR Cryptol. ePrint Arch., vol. 2021, p. 339,
2021.
[36] B. Guo, Z. Lu, Q. Tang, J. Xu, and Z. Zhang, “Dumbo: Faster
asynchronous bft protocols,” in Proceedings of
the 2020
ACM SIGSAC Conference on Computer and Communications
Security, 2020, pp. 803–818.
[37] K. Gurkan, P. Jovanovic, M. Maller, S. Meiklejohn, G. Stern,
and A. Tomescu, “Aggregatable distributed key generation,”
in Annual International Conference on the Theory and Ap-
plications of Cryptographic Techniques. Springer, 2021, pp.
147–176.
[38] T. Hanke, M. Movahedi, and D. Williams, “Dﬁnity tech-
nology overview series, consensus system,” arXiv preprint
arXiv:1805.04548, 2018.
[39] A. Kate and I. Goldberg, “Distributed key generation for the
internet,” in 2009 29th IEEE International Conference on
Distributed Computing Systems.
IEEE, 2009, pp. 119–128.
[40] A. Kate, Y. Huang, and I. Goldberg, “Distributed key gener-
ation in the wild.” IACR Cryptol. ePrint Arch., vol. 2012, p.
377, 2012.
[41] I. Keidar, E. Kokoris-Kogias, O. Naor, and A. Spiegelman,
“All you need is dag,” in Proceedings of the 2021 ACM
Symposium on Principles of Distributed Computing, 2021,
pp. 165–175.
15
2532
[43] E. Kokoris Kogias, D. Malkhi, and A. Spiegelman, “Asyn-
chronous distributed key generation for computationally-
secure randomness, consensus, and threshold signatures.”
in Proceedings of the 2020 ACM SIGSAC Conference on
Computer and Communications Security, 2020, pp. 1751–
1767.
[44] Y. Lu, Z. Lu, Q. Tang, and G. Wang, “Dumbo-mvba: Optimal
multi-valued validated asynchronous byzantine agreement, re-
visited,” in Proceedings of the 39th Symposium on Principles
of Distributed Computing, 2020, pp. 129–138.
[45] A. Miller, Y. Xia, K. Croman, E. Shi, and D. Song, “The
honey badger of bft protocols,” in Proceedings of the 2016
ACM SIGSAC Conference on Computer and Communications
Security, 2016, pp. 31–42.
[46] A. Mostéfaoui, H. Moumen, and M. Raynal, “Signature-free
asynchronous binary byzantine consensus with t< n/3, o (n2)
messages, and o (1) expected time,” Journal of the ACM
(JACM), vol. 62, no. 4, pp. 1–21, 2015.
[47] W. Neji, K. Blibech, and N. Ben Rajeb, “Distributed key
generation protocol with a new complaint management strat-
egy,” Security and communication networks, vol. 9, no. 17,
pp. 4585–4595, 2016.
[48] O. Network, “Dkg for bls threshold signature scheme on the
evm using solidity,” 2018, https://github.com/orbs-network/
dkg-on-evm.
[49] P. Paillier, “Public-key cryptosystems based on composite
degree residuosity classes,” in International conference on
the theory and applications of cryptographic techniques.
Springer, 1999, pp. 223–238.
[50] T. P. Pedersen, “A threshold cryptosystem without a trusted
party,” in Workshop on the Theory and Application of of
Cryptographic Techniques. Springer, 1991, pp. 522–526.
[51] D. Pointcheval and J. Stern, “Security proofs for signature
schemes,” in International Conference on the Theory and
Applications of Cryptographic Techniques. Springer, 1996,
pp. 387–398.
[52] P. Schindler, “Ethereum-based distributed key generation pro-
tocol,” 2020, https://github.com/PhilippSchindler/ethdkg.
[53] P. Schindler, A. Judmayer, N. Stifter, and E. R. Weippl,
“Ethdkg: Distributed key generation with ethereum smart
contracts.” IACR Cryptol. ePrint Arch., vol. 2019, p. 985,
2019.
[54] A. Shamir, “How to share a secret,” Communications of the
ACM, vol. 22, no. 11, pp. 612–613, 1979.
[55] H. Stamer, “Distributed privacy guard,” 2018, https://github.
com/gnosis/dkg.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:34:29 UTC from IEEE Xplore.  Restrictions apply. 
[56] A. Tomescu, R. Chen, Y. Zheng, I. Abraham, B. Pinkas,
G. Gueta, and S. Devadas, “Towards scalable threshold cryp-
tosystems,” in 2020 IEEE Symposium on Security and Privacy
(SP), 2020, pp. 877–893.
[57] M. Yin, D. Malkhi, M. K. Reiter, G. G. Gueta, and I. Abra-
ham, “Hotstuff: Bft consensus with linearity and respon-
siveness,” in Proceedings of the 2019 ACM Symposium on
Principles of Distributed Computing. ACM, 2019, pp. 347–
356.
[58] T. Yurek, L. Luo, J. Fairoze, A. Kate, and A. Miller, “hbacss:
How to robustly share many secrets,” in Proceedings of
the 29th Annual Network and Distributed System Security
Symposium, 2022.
APPENDIX A.
PROOF OF LEMMA 7
Proof of Lemma 7: Each node incurs the computation
cost of one ACSS dealer and n − 1 ACSS non-dealer
node. During the key-set proposal phase, each node incurs
the computation cost of one RBC broadcaster and n − 1
RBC non-broadcaster node. During the agreement phase, in
addition to the computation cost of n parallel ABA instances,
each node needs to derive n different sets of threshold keys.
Finally, during the key-derivation phase, each node veriﬁes
O(n) shares and interpolate O(n) threshold keys.
Thus, in our ADKG protocol, each node incurs O(n2)
elliptic curve exponentiations except for the key set pro-
posal phase and the key derivation step of the agreement
phase [19], [12], [17]. During the key set proposal phase, in
the worst case, each node incurs O(n3 log n) computation
cost. However, these costs are due to Reed-Solomon de-
coding and do not involve any elliptic curve operations and
hence are not a bottleneck. Furthermore, each node incurs
O(n3) elliptic curve operations to derive the intermediate
threshold keys for the agreement phase.
APPENDIX B.
ABA OF [17]
In this section we brieﬂy describe the ABA protocol of
Crain ([17], Figure 3). The ABA protocol of Crain [17]
improves the round complexity of Mostefaoui et al. [46],
from 13 rounds per epoch to 8 rounds per epoch, assuming
the common-coin uses a single round. If no honest node
has terminated so far, the probability of termination in an
epoch is 1/2 in both protocols, assuming the common-coin
is unbiased. Each message sent by a node in [17] contains
a single bit and a tag. Crain’s ABA incurs a expected
communication cost of O(n2) and terminates in O(1) rounds
in expectation.
As we describe earlier, in addition to the standard ABA
properties, we crucially rely on the following property of
Crain’s ABA.
Good-Case-Coin-Free: If all honest nodes input the same
value to the ABA, then all honest nodes output without
invoking the common coin.
Algorithm 3 BV_Broadcast(v)
1: bin_values ← ∅
2: send BVAL(v) to all
3: return bin_values
reached its ﬁnal value when returned
(cid:46) bin_values has not necessarily
if BVAL(v) received from t + 1 different nodes then
4: upon receiving BVAL(v) do
5:
6:
7:
8:
if BVAL(v) received from 2t + 1 different nodes then
send BVAL(v) to all (if haven’t done already)
bin_values ← bin_values ∪ {v}
Algorithm 4 SBV_Broadcast(v)
1: bin_values ← BV_Broadcast(v)
2: wait until bin_values (cid:54)= ∅
3: send AUX(w) for w ∈ bin_values to all
(cid:46) bin_values has
4: wait until ∃ a set view such that (i) view ⊆ bin_values; and
(ii) contained in AUX(·) messages received from n − t
not necessarily reached its ﬁnal value when returned
nodes;
5: return (view, bin_values)
We restate Crain’s ABA in Algorithm 5. Here we brieﬂy
explain why it has the Good-Case-Coin-Free property. When
all honest nodes have the same input value v, it is not hard to
verify that for the ﬁrst round r = 1, view[1, 0], view[1, 1]
and view[1, 2] will all equal to {v}. Hence, every honest
node will decide v in line 12 without invoking the common
coin. We also need to argue that every honest node knows
that no other honest nodes need the common coin, so that
it does not need to participate in the common coin to help
other honest nodes. This is guaranteed by SBV_Broadcast,
which ensures that if an honest node has {v} as the output of
SBV_Broadcast, then no honest node will have {v(cid:48)} where
v (cid:54)= v(cid:48) as the output. Therefore, if the condition on line 11
gets satisﬁed at any honest node, then no honest node will
enter the conditional branch on line 14, i.e., no honest node
will need the common coin.
ZERO KNOWLEDGE PROOF OF EQUALITY OF DISCRETE
APPENDIX C.
LOGARITHM
Our ADKG protocol has a step that requires nodes to
produce zero-knowledge proofs about the equality of dis-
crete logarithms for a tuple of publicly known values. In
particular, given a group G of prime order q, two uniformly
random generators g, h ← G and a tuple (g, x, h, y), a prover
P wants to prove to a probabilistic polynomial time veriﬁer
V, in zero-knowledge, the knowledge of a witness α such
that x = gα and y = hα.
We will use the Chaum-Pedersen "Σ-protocols" [16],
which assumes the hardness of the Discrete Logarithm
problem.
Protocol for equality of discrete logarithm. For any given
tuple (g, x, h, y), the Chaum-Pedersen protocol proceeds as
16
2533
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:34:29 UTC from IEEE Xplore.  Restrictions apply. 
Algorithm 5 ABA protocol of [17] Figure 3 (Restated)
1: input: v
2: est ← v; r ← 0
3: while true do
r ← r + 1
4:
(view[r, 0], bin_values[r]) ← SBV_Broadcast(est)
5:
send AUXSET[r](view[r, 0]) to all
6:
wait until ∃ a set view[r, 1] such that
7:
(i) view[r, 1] ⊆ bin_values; and
(ii) contained in AUXSET(·) messages received from n− t
if view[r, 1] = {w} then est ← w
else est ← ⊥
view[r, 2] ← SBV_Broadcast(est)
if view[r, 2] = {v}, v (cid:54)= ⊥ then decide(v); est ← v
else Coin() = sign(pk, #ABA(cid:107)#round)
if view[r, 2] = {v,⊥} then est ← v
if view[r, 2] = {⊥} then est ← Coin()
8:
9:
10:
11:
12:
13:
14:
nodes;
(a1, a2) to V where a1 = gβ and a2 = gβ.
follows.
1) P samples a random element β ← Zq and sends
2) V sends a challenge e ← Zq.
3) P sends a response z = β − αe to V.
4) V checks whether a1 = gzxe and a2 = hzye and
accepts if and only if both the equality holds.
This protocol guarantees completeness, knowledge sound-
ness, and zero-knowledge. The knowledge soundness im-
plies that if P convinces the V with non-negligible proba-
bility, there exists an efﬁcient (polynomial time) extractor
that can extract α from the prover with non-negligible
probability.
This above protocol can be made non-interactive in the
Random Oracle model using the Fiat-Shamir heuristic [24],
[51]. In our ADKG, we use the non-interactive variant of
the protocol. For any given tuple (g, x, h, y) where x =
gs and y = hs, dleq.Prove(s, g, x, h, y) generates the non-
interactive zero proof π. The proof π is O(κ) bits long.
Given a proof π and (g, x, h, y), dleq.Verify(π, g, x, h, y)
veriﬁes the proof.
Simulating a proof without
the secret. We will use
programmability of random oracle to generate an convincing
NIZK proof without having access to the corresponding
secret. Furthermore, we use the same approach to gen-
erate NIZK proof for false statements. Given the tuple
(g, gx, h, hy), the simulator works as follows.
1) Sample uniformly random z, c ∈ Zq.
2) Compute a1 = gzgx·c and a2 = hzhy·c.
3) Set c = hash(a1, a2).
4) Output π = (a1, a2, z)
Note that
the distribution of proof generated by the
simulator is identical
to the distribution of proof of a
correct statement generated by an honest prover during a
real execution of the dleq protocol.
17
2534
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:34:29 UTC from IEEE Xplore.  Restrictions apply.