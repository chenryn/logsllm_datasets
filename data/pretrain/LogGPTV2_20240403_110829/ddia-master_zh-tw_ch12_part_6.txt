资料库继承了这种可变资料的被动方法：如果你想知道资料库的内容是否发生了变化，通常你唯一的选择就是轮询（即定期重复你的查询）。订阅变更只是刚刚开始出现的功能（请参阅 “[变更流的 API 支援](ch11.md#变更流的API支援)”）。
#### 资料流：应用程式码与状态变化的互动
从资料流的角度思考应用程式，意味著重新协调应用程式码和状态管理之间的关系。我们不再将资料库视作被应用操纵的被动变数，取而代之的是更多地考虑状态，状态变更和处理它们的程式码之间的相互作用与协同关系。应用程式码透过在另一个地方触发状态变更来响应状态变更。
我们在 “[资料库与流](ch11.md#资料库与流)” 中看到了这一思路，我们讨论了将资料库的变更日志视为一种我们可以订阅的事件流。诸如 Actor 的讯息传递系统（请参阅 “[讯息传递中的资料流](ch4.md#讯息传递中的资料流)”）也具有响应事件的概念。早在 20 世纪 80 年代，**元组空间（tuple space）** 模型就已经探索了表达分散式计算的方式：观察状态变更并作出反应的过程【38,39】。
如前所述，当触发器由于资料变更而被触发时，或次级索引更新以反映索引表中的变更时，资料库内部也发生著类似的情况。分拆资料库意味著将这个想法应用于在主资料库之外，用于建立衍生资料集：快取、全文搜寻索引、机器学习或分析系统。我们可以为此使用流处理和讯息传递系统。
需要记住的重要一点是，维护衍生资料不同于执行非同步任务。传统的讯息传递系统通常是为执行非同步任务设计的（请参阅 “[日志与传统的讯息传递相比](ch11.md#日志与传统的讯息传递相比)”）：
* 在维护衍生资料时，状态变更的顺序通常很重要（如果多个检视是从事件日志衍生的，则需要按照相同的顺序处理事件，以便它们之间保持一致）。如 “[确认与重新传递](ch11.md#确认与重新传递)” 中所述，许多讯息代理在重传未确认讯息时没有此属性，双写也被排除在外（请参阅 “[保持系统同步](ch11.md#保持系统同步)”）。
* 容错是衍生资料的关键：仅仅丢失单个讯息就会导致衍生资料集永远与其资料来源失去同步。讯息传递和衍生状态更新都必须可靠。例如，许多 Actor 系统预设在记忆体中维护 Actor 的状态和讯息，所以如果执行 Actor 的机器崩溃，状态和讯息就会丢失。
稳定的讯息排序和容错讯息处理是相当严格的要求，但与分散式事务相比，它们开销更小，执行更稳定。现代流处理元件可以提供这些排序和可靠性保证，并允许应用程式码以流运算元的形式执行。
这些应用程式码可以执行任意处理，包括资料库内建衍生函式通常不提供的功能。就像透过管道连结的 Unix 工具一样，流运算元可以围绕著资料流构建大型系统。每个运算元接受状态变更的流作为输入，并产生其他状态变化的流作为输出。
#### 流处理器和服务
当今流行的应用开发风格涉及将功能分解为一组透过同步网路请求（如 REST API）进行通讯的 **服务**（service，请参阅 “[服务中的资料流：REST 与 RPC](ch4.md#服务中的资料流：REST与RPC)”）。这种面向服务的架构优于单一庞大应用的优势主要在于：通过松散耦合来提供组织上的可伸缩性：不同的团队可以专职于不同的服务上，从而减少团队之间的协调工作（因为服务可以独立部署和更新）。
在资料流中组装流运算元与微服务方法有很多相似之处【40】。但底层通讯机制是有很大区别：资料流采用单向非同步讯息流，而不是同步的请求 / 响应式互动。
除了在 “[讯息传递中的资料流](ch4.md#讯息传递中的资料流)” 中列出的优点（如更好的容错性），资料流系统还能实现更好的效能。例如，假设客户正在购买以一种货币定价，但以另一种货币支付的商品。为了执行货币换算，你需要知道当前的汇率。这个操作可以透过两种方式实现【40,41】：
1. 在微服务方法中，处理购买的程式码可能会查询汇率服务或资料库，以获取特定货币的当前汇率。
2. 在资料流方法中，处理订单的程式码会提前订阅汇率变更流，并在汇率发生变动时将当前汇率储存在本地资料库中。处理订单时只需查询本地资料库即可。
第二种方法能将对另一服务的同步网路请求替换为对本地资料库的查询（可能在同一台机器甚至同一个程序中）[^ii]。资料流方法不仅更快，而且当其他服务失效时也更稳健。最快且最可靠的网路请求就是压根没有网路请求！我们现在不再使用 RPC，而是在购买事件和汇率更新事件之间建立流联接（请参阅 “[流表连线（流扩充）](ch11.md#流表连线（流扩充）)”）。
[^ii]: 在微服务方法中，你也可以透过在处理购买的服务中本地快取汇率来避免同步网路请求。但是为了保证快取的新鲜度，你需要定期轮询汇率以获取其更新，或订阅变更流 —— 这恰好是资料流方法中发生的事情。
连线是时间相关的：如果购买事件在稍后的时间点被重新处理，汇率可能已经改变。如果要重建原始输出，则需要获取原始购买时的历史汇率。无论是查询服务还是订阅汇率更新流，你都需要处理这种时间相关性（请参阅 “[连线的时间依赖性](ch11.md#连线的时间依赖性)”）。
订阅变更流，而不是在需要时查询当前状态，使我们更接近类似电子表格的计算模型：当某些资料发生变更时，依赖于此的所有衍生资料都可以快速更新。还有很多未解决的问题，例如关于时间相关连线等问题，但我认为围绕资料流构建应用的想法是一个非常有希望的方向。
### 观察衍生资料状态
在抽象层面，上一节讨论的资料流系统提供了建立衍生资料集（例如搜寻索引、物化检视和预测模型）并使其保持更新的过程。我们将这个过程称为 **写路径（write path）**：只要某些资讯被写入系统，它可能会经历批处理与流处理的多个阶段，而最终每个衍生资料集都会被更新，以适配写入的资料。[图 12-1](../img/fig12-1.png) 显示了一个更新搜寻索引的例子。
![](../img/fig12-1.png)
**图 12-1 在搜寻索引中，写（文件更新）遇上读（查询）**
但你为什么一开始就要建立衍生资料集？很可能是因为你想在以后再次查询它。这就是 **读路径（read path）**：当服务使用者请求时，你需要从衍生资料集中读取，也许还要对结果进行一些额外处理，然后构建给使用者的响应。
总而言之，写路径和读路径涵盖了资料的整个旅程，从收集资料开始，到使用资料结束（可能是由另一个人）。写路径是预计算过程的一部分 —— 即，一旦资料进入，即刻完成，无论是否有人需要看它。读路径是这个过程中只有当有人请求时才会发生的部分。如果你熟悉函数语言程式设计语言，则可能会注意到写路径类似于立即求值，读路径类似于惰性求值。
如 [图 12-1](../img/fig12-1.png) 所示，衍生资料集是写路径和读路径相遇的地方。它代表了在写入时需要完成的工作量与在读取时需要完成的工作量之间的权衡。
#### 物化检视和快取
全文搜寻索引就是一个很好的例子：写路径更新索引，读路径在索引中搜索关键字。读写都需要做一些工作。写入需要更新文件中出现的所有关键词的索引条目。读取需要搜寻查询中的每个单词，并应用布林逻辑来查询包含查询中所有单词（AND 运算子）的文件，或者每个单词（OR 运算子）的任何同义词。