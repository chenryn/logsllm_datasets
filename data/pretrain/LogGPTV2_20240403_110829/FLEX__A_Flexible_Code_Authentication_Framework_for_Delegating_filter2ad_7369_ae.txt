 (cid:62)
V T ype(v, H) =
if v = null
void if v = •
C
if v = o and H(o) = (C, E)
Definition 7. We write E, H |= Γ if and only if:
∀x.V T ype(E(x), H) = τ ∧ τ (cid:118) Γ(x)
Lemma 1. For each expression e and statement s, and
for all E, H, Γ such that E, H |= Γ, the following holds:
(cid:48) |= Γ
(cid:48) |= Γ
∆; Γ (cid:96) e : τ ∧ (E, H, e) → (E
∆; Γ (cid:96) s : τ ∧ (E, H, s) → (E
, v) =⇒ E
, v) =⇒ E
, H
, H
(cid:48)
(cid:48)
(cid:48)
(cid:48)
(cid:48)
(cid:48)
, H
, H
Proof. The property trivially holds for expressions. In
fact, expressions have no eﬀect on E (i.e., E(cid:48) = E), and the
types associated to the entries of H are immutable. With re-
spect to statements, we proceed by induction over the struc-
ture of s:
• Case skip;. Trivially, E(cid:48) = E and H(cid:48) = H.
• Case return e;. A direct consequence of the property
for expressions.
• Case x = e;. Since the property holds for e, we know
|= Γ. Hence, we just need to show that
that E, H(cid:48)
[x \ v] ◦ E, H(cid:48) |= Γ, which is a consequence of the fact
that V T ype(v) (cid:118) DT ype(x).
• Case if (e1 == e2) { s1 } else { s2 }. We itera-
tively apply the inductive hypothesis to e1, e2 and s1
(or s2, depending on the applied rule of the operational
semantics).
• Case e.f = e
(cid:48)
;. We apply the inductive hypothesis to
(cid:48) and we conclude by noticing that the operation
e and e
does not change the type of the records in H.
• Case C x in {s}. A direct consequence of the induc-
tive hypothesis applied to s and [x \ null] ◦ E.
• Case s1 s2. We conclude by applying the inductive hy-
pothesis to s1 and s2, in this order.
Lemma 2. For each expression e and statement s and for
all E, H, Γ such that E, H |= Γ the following properties hold
∆; Γ (cid:96) e : τ =⇒ ∃v, E(cid:48), H(cid:48).(E, H, e) → (E(cid:48), H(cid:48), v) ∧ V T ype(v, H(cid:48)) (cid:118) τ
∆; Γ (cid:96) s : σ =⇒ ∃v, E(cid:48), H(cid:48).(E, H, s) → (E(cid:48), H(cid:48), v) ∧ V T ype(v, H(cid:48)) (cid:118) σ
• Case e.f. We instantiate rule (TE-Fld) and apply
the inductive hypothesis to e. As a consequence, we
have that ∆; Γ (cid:96) e : C (such that ∆(C)(f) = τ ) and
(E, H, e) → (E, H(cid:48), o) with H(o) = C(cid:48) (cid:22) C. We can
conclude since C(cid:48) (cid:22) C implies ∆(C(cid:48))(f) = τ (ﬁelds
cannot be redeﬁned).
• Case e.m(¯e). We follow the same reasoning as above,
but we apply rule (TE-Mth). Hence we obtain that
∆; Γ (cid:96) e : C (such that ∆(C)(m) = ¯τ(cid:48)(cid:48) → τ ) and
(E, H, e) → (E, H(cid:48), o) with H(o) = C(cid:48) (cid:22) C. Also,
we iteratively apply the inductive hypothesis to all the
elements of ¯e starting from the conﬁguration (E, H0, e1)
(with H0 = H(cid:48)).6 We obtain that ¯e are typed ¯τ∗ and
generate n values ¯v such that ∀i.V T ype(vi, Hi) (cid:118) τ∗
i .
Since ¯τ∗ (cid:118) ¯τ(cid:48)(cid:48) we can conclude by applying rule (EE-
Mth) (and the assumption that the method body is
correctly typed w.r.t. ∆).
• Case new C(¯e). The proof follows the same reasoning as
in the previous case.
• Case (C)e. By inductive hypothesis, we have ∆; Γ (cid:96) e :
τ and, by rule (TE-Cst), we know that τ = C(cid:48) such
that C(cid:48) (cid:52) C. The property holds, since V T ype(o, H(cid:48)) (cid:118)
C(cid:48) (cid:118) C.
• Case /*@ ER @*/e. Trivially from the inductive hy-
pothesis.
• Case skip;. By (TS-Skip), ∆; Γ (cid:96) skip; : void and,
by (SE-Skip) (E, H, skip;) → (E, H,•). By deﬁnition,
V T ype(•, H(cid:48)) = void which suﬃces to conclude.
• Case return e;. We conclude by applying the induc-
tive hypothesis.
• Case x = e;. We start by applying the inductive hy-
pothesis to e. Then, we apply the typing rule (TS-
Asgn) and the operational semantics sule (SE-Asgn)
and we conclude as in the previous case.
• Case if (e1 == e2) { s1 } else { s2 }. We apply the
inductive hypothesis to e1 and e2 (in this order). Then,
we have two symmetric cases depending on whether the
guard evaluates to tt or ﬀ. In both cases, we conclude
by applying the inductive hypothesis (to s1 and s2, re-
spectively).
• Case e.f = e;
(cid:48). We follow the same reasoning applied
for variable assignments. The only diﬀerence is that
here we apply the inductive hypothesis to both e and
(cid:48).
e
• Case C x in {s}. We apply and assume the premise
of rule (TS-Blk) to obtain ∆; Γ, x : C (cid:96) s : σ. To
apply the inductive hypothesis and conclude, we need
to show that [x\ null]◦ E, H |= Γ, x : C. However, this
trivially follows from E, H |= Γ and (cid:62) (cid:118) C.
• Case s1 s2. Here we have two sub-cases (depending on
Proof. We proceed by structural induction on e.
• Case null. By (TE-Null), ∆; Γ (cid:96) null : (cid:62) and, by
(EE-Null) (E, H, null) → (E, H, null). Trivially, by
deﬁnition, V T ype(null, H(cid:48)) = (cid:62) (cid:118) (cid:62).
• Case x. By (TE-Var), ∆; Γ (cid:96) x : Γ(x) and, by (EE-
Var) (E, H, x) → (E, H, E(x)). We conclude by notic-
ing that by assumption E, H |= Γ, V T ype(E(x), H) (cid:118)
Γ(x).
which typing rule is applied).
– (TS-Seq1). Again we have two branches, one for
rule (SE-Seqr) and one for (SE-Seqc). The ﬁrst
one simply requires to apply the inductive hypoth-
Instead, applying (SE-Seqc) we ob-
esis to s1.
tain that (E, H, s1) → (E(cid:48), H(cid:48),•). By Lemma 1 we
know that E(cid:48), H(cid:48) |= Γ which suﬃces to apply the
inductive hypothesis to s2 and conclude.
6Condition E, Hi |= Γ is always satisﬁed due to Lemma 1.
C. TYPING RULES FOR
EXPRESSIONS AND STATEMENTS
Name
(TE-Null)
(TE-Var)
(TE-Wkn)
(TE-Fld)
(TE-Mth)
(TE-New)
(TE-Cst)
(TE-Erew)
(TS-Skip)
(TS-Ret)
(TS-If)
(TS-Fld)
(TS-Asgn)
(TS-Blk)
(TS-Wkn)
(TS-Seq1)
(TS-Seq2)
(TS-Srew)
Rule
∆; Γ (cid:96) null : (cid:62)
∆; Γ (cid:96) x : τ
∆; Γ (cid:96) e : τ
∆; Γ (cid:96) e : τ(cid:48)
∆; Γ (cid:96) e : C
∆; Γ (cid:96) e.f : τ
∆; Γ (cid:96) e.m(¯e) : τ
∆; Γ (cid:96) new C(¯e) : C
∆; Γ (cid:96) ¯e : ¯τ
∆; Γ (cid:96) e : C(cid:48)
∆; Γ (cid:96) (C)e : C
∆; Γ (cid:96)/*@ER@*/e : τ
∆; Γ (cid:96) skip; : void
∆; Γ (cid:96) return e; : τ
∆; Γ (cid:96) e : τ
∆; Γ (cid:96) e : τ
∆; Γ (cid:46) ER : τ
∆; Γ (cid:96) e : C
∆; Γ (cid:96) ¯e : ¯τ
∆; Γ (cid:96) s2 : σ
∆; Γ (cid:96) s1 : σ
∆; Γ (cid:96) if(e1 == e2) s1 else s2 : σ
∆; Γ (cid:96) e
∆; Γ (cid:96) e : C
(cid:48) : τ
∆; Γ (cid:96) e.f = e
(cid:48); : void
∆; Γ (cid:96) e : τ
∆; Γ (cid:96) x = e; : void
∆; Γ, x : C (cid:96) s : σ
∆; Γ (cid:96) C x in {s} : σ
∆; Γ (cid:96) s1 : σ
∆; Γ (cid:96) s1 : void
∆; Γ (cid:96) s : σ
∆; Γ (cid:96) s : σ(cid:48)
∆; Γ (cid:96) s1 s2 : σ
∆; Γ (cid:96) s1 s2 : σ
∆; Γ (cid:96) s : σ
∆; Γ (cid:96) s2 : σ
∆; Γ (cid:96) s2 : σ
∆; Γ (cid:46) SR : σ
∆; Γ (cid:96)/*@SR@*/s : σ
Side
Γ(x) = τ
τ (cid:118) τ(cid:48)
∆(C)(f) = τ
∆(C)(m) = ¯τ(cid:48)(cid:48) → τ(cid:48)
∆(C)(new) = ¯τ(cid:48)(cid:48) → C
¯τ (cid:118) ¯τ(cid:48)(cid:48)
¯τ (cid:118) ¯τ(cid:48)(cid:48)
C(cid:48) (cid:52) C
∆(C)(f) = τ
Γ(x) = τ
σ (cid:118) σ(cid:48)
σ (cid:54)= void
– (TS-Seq2). In this case rule (SE-Seqr) does not
apply (as v (cid:54)= • entails that V T ype(v) (cid:54)= void).
Hence we consider rule (SE-Seqc) and we have
(E, H, s1) → (E(cid:48), H(cid:48),•). Again, we apply Lemma 1
and the inductive hypothesis to conclude.
• Case /*@ SR @*/s. Trivially from the inductive hy-
pothesis.
Theorem 1. For all closed expressions e and statements
s the following properties hold
∅, ∆ (cid:96) e : τ =⇒ ∃v, E, H.(∅,∅, e) → (E, H, v) ∧ V T ype(v, H) (cid:118) τ
∅, ∆ (cid:96) s : σ =⇒ ∃v, E, H.(∅,∅, s) → (E, H, v) ∧ V T ype(v, H) (cid:118) σ
Proof. A corollary of Lemma 2.
B. OPERATIONAL SEMANTICS
Name
(EE-Null)
(EE-Var)
(EE-Fld)
(EE-Mth)
(EE-New)
(EE-Cst)
(SE-Skip)
(SE-Ret)
(SE-Iftt)
(SE-Ifﬀ)
(SE-Asgn)
(SE-Fld)
(SE-Blk)
(SE-Seqc)
(SE-Seqr)
Rule
(E, H, null) → (E, H, null)
(E, H, x) → (E, H, v)
(E, H, e) → (E, H(cid:48), o)
(E, H, e.f) → (E, H(cid:48), v)
(E, H, e) → (E, H0, o)
(E, H0, e1) → (E, H1, v1)
...
...
(E, Hn−1, en) → (E, Hn, vn)
([¯x \ ¯v] ◦ Eo, Hn, s) → (E(cid:48)
o, H(cid:48), v)
(E, H, e.m(¯e)) → (E, H(cid:48), v)
(E, H, e1) → (E, H1, v1)
(E, Hn−1, en) → (E, Hn, vn)
([¯x \ ¯v] ◦ Eo, H(cid:48), s) → (E(cid:48)
o, H(cid:48)(cid:48),•)
(E, H, new C(¯e)) → (E, H(cid:48)(cid:48), o)
(E, H, e) → (E, H(cid:48), o)
(E, H, (C)e) → (E, H(cid:48), o)
(E, H, skip;) → (E, H,•)
(E, H, e) → (E, H(cid:48), v)
(E, H, e1) → (E, H(cid:48), v)
(E, H(cid:48), e2) → (E, H(cid:48)(cid:48), v(cid:48))
(E, H(cid:48)(cid:48), s1) → (E1, H1, v1)
(E, H, return e;) → (E, H(cid:48), v)
(E, H, if (e1 == e2) s1 else s2) → (E1, H1, v1)
(E, H, e1) → (E, H(cid:48), v)
(E, H(cid:48), e2) → (E, H(cid:48)(cid:48), v(cid:48))
(E, H(cid:48)(cid:48), s2) → (E2, H2, v2)
(E, H, if (e1 == e2) s1 else s2) → (E2, H2, v2)
(E, H, e) → (E, H(cid:48), v)
(E, H, x = e;) → ([x \ v] ◦ E, H(cid:48),•)
(E, H, e) → (E, H(cid:48), o)
(cid:48)) → (E, H(cid:48)(cid:48), v)
(E, H(cid:48), e
(E, H, e.f = e
(cid:48);) → (E, [o \ (C, E(cid:48))] ◦ H(cid:48)(cid:48),•)
([x \ null] ◦ E, H, s) → (E(cid:48), H(cid:48), v)
(E, H, C x in {s}) → (E(cid:48)|x, H(cid:48), v)
(E, H, s1) → (E(cid:48), H(cid:48),•)
(E(cid:48), H(cid:48), s2) → (E(cid:48)(cid:48), H(cid:48)(cid:48), v)
(E, H, s1s2) → (E(cid:48)(cid:48), H(cid:48)(cid:48), v)
(E, H, s1) → (E(cid:48), H(cid:48), v)
(E, H, s1s2) → (E(cid:48), H(cid:48), v)
Side
E(x) = v
H(o) = (C, Eo)
f ∈ F ields(C)
Eo(f) = v
H(o) = (C, Eo)
(m, ¯x, s) ∈ M ethods(C)
(¯x, s) ∈ Constructor(C)
o fresh in Hn
¯f = F ields(C)
Eo = [this \ o, ¯f \ null]
H(cid:48) = [o \ (C, Eo)] ◦ Hn
H(o) = (D, E)
D (cid:52) C
v = v(cid:48)
v (cid:54)= v(cid:48)
x ∈ Dom(E)
V T ype(v) (cid:118) DT ype(x)
H(cid:48)(cid:48)(o) = (C, Eo)
f ∈ F ields(C)
E(cid:48) = [f \ v] ◦ Eo
v (cid:54)= •