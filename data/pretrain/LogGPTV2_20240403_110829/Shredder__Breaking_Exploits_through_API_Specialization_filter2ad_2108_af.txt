### References

1. [68] Reinhard Tartler, Anil Kurmus, Bernhard Heinloth, Valentin Rothberg, Andreas Ruprecht, Daniela Dorneanu, Rüdiger Kapitza, Wolfgang Schröder-Preikschat, and Daniel Lohmann. 2012. Automatic OS Kernel TCB Reduction by Leveraging Compile-time Configurability. In *Proceedings of the 8th USENIX Conference on Hot Topics in System Dependability (HotDep)*.

2. [69] PaX Team. Address Space Layout Randomization. (2003). <http://pax.grsecurity.net/docs/aslr.txt>.

3. [70] Victor van der Veen, Dennis Andriesse, Manolis Stamatogiannakis, Xi Chen, Herbert Bos, and Cristiano Giuffrida. 2017. The Dynamics of Innocent Flesh on the Bone: Code Reuse Ten Years Later. In *Proceedings of the ACM SIGSAC Conference on Computer and Communications Security (CCS)*. 1675–1689.

4. [71] D. Wagner and R. Dean. 2001. Intrusion Detection via Static Analysis. In *Proceedings of the IEEE Symposium on Security & Privacy*. 156–168.

5. [72] Richard Wartell, Vishwath Mohan, Kevin W Hamlen, Zhiqiang Lin, and W Campbell Rd. 2012. Binary Stirring: Self-randomizing Instruction Addresses of Legacy x86 Binary Code. In *Proceedings of the 19th ACM Conference on Computer and Communications Security (CCS)*. 157–168.

6. [73] Jan Werner, George Baltas, Rob Dallara, Nathan Otternes, Kevin Snow, Fabian Monrose, and Michalis Polychronakis. 2016. No-Execute-After-Read: Preventing Code Disclosure in Commodity Software. In *Proceedings of the 11th ACM Asia Conference on Computer and Communications Security (ASIACCS)*. 35–46.

7. [74] Andreas Wespi, Marc Dacier, and Hervé Debar. 2000. Intrusion Detection Using Variable-Length Audit Trail Patterns. In *Proceedings of the 3rd Conference on Recent Advances in Intrusion Detection (RAID)*. 110–129.

8. [75] Chao Zhang, Tao Wei, Zhaofeng Chen, Lei Duan, László Szekeres, Stephen McCamant, Dawn Song, and Wei Zou. 2013. Practical Control Flow Integrity & Randomization for Binary Executables. In *Proceedings of the 34th IEEE Symposium on Security & Privacy (S&P)*.

9. [76] Mingwei Zhang and R Sekar. 2013. Control Flow Integrity for COTS Binaries. In *22nd USENIX Security Symposium*.

### Appendix

#### A. Call-Site-Specific Specialization

In many cases, it is possible to determine the values of a given argument for the majority of a function's call sites, but miss just a few call sites where the values for the same argument remain unknown, preventing the specification of a global policy. In such cases, Shredder’s policies can be refined so that instead of having a single "weak" policy for all call sites of a given function (or no policy at all), different policies can be enforced according to the actual call site from which the function was invoked. The main benefit of this call-site-specific specialization approach is that for cases where an effective global policy cannot be derived for a given function, at least the majority of its call sites can still be protected.

For instance, when only a few call sites of `VirtualProtect()` legitimately use the execute permission in a given application, an attacker would have to invoke it only through those particular call sites as part of a Return-Oriented Programming (ROP) payload that needs to allocate executable memory. This approach creates multiple versions of the original function, each with different stripped functionality. The aggressively stripped-down version becomes the default (as it is of no use for attackers), while invocations to the more "dangerous" version of the function can be permitted only from specific code locations that really require the sensitive functionality (i.e., allocating executable memory).

To prevent attackers from simply jumping to particular call sites and reusing the sensitive version of the function, the invocation points can be further protected by applying context-sensitive and type-based control flow integrity (CFI) [14]. Assuming such a form of CFI is in place, this enforcement significantly complicates the construction of a functional ROP payload, as the attacker has less freedom in picking appropriate ROP gadgets that include non-protected call sites, while at the same time not violating the CFI policy [12, 15, 26, 59, 61].

**Figure 7** illustrates this case further. The attacker's code attempts to use `VirtualProtect()` with the third parameter set to `0x40`. The application in this case has three different call sites for that function, two of which have known, hard-coded values (`0x2` and `0x104`), which now become part of the call-site-specific policy. Given that these known values are different from what the attacker needs to use for the exploit code, if any of the first two call sites is reused as part of a ROP payload, Shredder will identify the argument mismatch and prevent the attack. Only if the last call site is used by the attacker will the attack succeed.

Call-site-specific policies are implemented by including call site identifiers in the policies. Every call site of a critical function is recorded along with the set of input arguments. The address of each call site is kept with respect to the subroutine it is part of and with respect to the base of the binary image. Additionally, the name of the module (executable or shared library) which makes the call is also recorded as part of the policy.

A policy for a given call site includes the following fields:
1. Critical function name
2. Module name
3. Offset within the module
4. Tuple with "known" and "unknown" arguments for this particular call site

For every call of a sensitive function, the runtime interposition layer traverses the stack of the process to determine the origin of the call. For the current process, we use `EnumProcessModule()`, `GetModuleFileName()`, and `GetModuleInformation()` to get the image base addresses of all the modules loaded by the application. With this information, an intercepted call is verified against the policies of all modules.

**Table 4** shows the number of call sites for which Shredder was previously unable to create global policies (second column) and their subset for which site-specific policies can be derived. In several applications, a majority of the previously unprotected call sites are now protected. However, there are cases like 7zip and Notepad++ for which even site-specific policies could not be derived. As discussed in Section 5.3.2, this is mostly due to input arguments that can only be derived at runtime.

**Table 5** lists the set of critical Windows API functions considered by Shredder for policy enforcement.

**Table 4: Number of Call Sites for Which Site-Specific Policies Can Be Derived**

| Application       | Call Sites Without Global Policies | Call Sites with Site-Specific Policies |
|-------------------|------------------------------------|----------------------------------------|
| 7Zip              | 12                                 | 0 (0%)                                 |
| Google Chrome     | 42                                 | 31 (75%)                               |
| Microsoft Edge    | 94                                 | 52 (55%)                               |
| Mozilla Firefox   | 28                                 | 12 (43%)                               |
| iTunes            | 108                                | 76 (70%)                               |
| PhotoViewer       | 4                                  | 2 (50%)                                |
| Notepad++         | 18                                 | 0 (0%)                                 |
| PowerShell        | 2                                  | 0 (0%)                                 |
| VLC               | 5                                  | 2 (40%)                                |
| Winrar            | 47                                 | 11 (23%)                               |

**Table 5: Set of Critical Windows API Functions Considered by Shredder for Policy Enforcement**

| Module          | Function Name                        |
|-----------------|--------------------------------------|
| kernel32.dll    | CloseHandle, CreateFileA, CreateFileMappingA, CreateFileMappingW, CreateFileW, CreateProcessA, CreateProcessW, CreateRemoteThread, DeleteFileA, DeleteFileW, DuplicateHandle, ExitProcess, ExitThread, GetCurrentProcess, VirtualAlloc, VirtualProtect, WaitForSingleObject, WriteFile |
| ws2_32.dll      | accept, bind, closesocket, connect, ioctlsocket, listen, recv, send, socket, WSASocketA, WSASocketW, WSAStartup |
| wininet.dll     | GetSystemDirectoryA, GetSystemDirectoryW, GetTemplatePathA, GetTemplatePathW, LoadLibraryA, LoadLibraryW, PeekNamedPipe, ReadFile, Sleep, WinExec, WriteFile, InternetOpenA, InternetOpenUrlA, InternetOpenUrlW, InternetOpenW, InternetReadFile |
| msvcrt.dll      | _execv, fclose, fopen, fwrite |
| urlmon.dll      | URLDownloadToFileA, URLDownloadToFileW |
| ntdll.dll       | NtSetInformationProcess |

#### B. ROP Payload Data Set

**Table 6** shows a detailed list of the ROP payloads used in our evaluation (some sources contain multiple distinct payloads). We did not include payloads that would not be functional in the considered Windows 10 environment (e.g., ROP payloads that rely on `setProcessDEPPolicy()`, which works only on Windows XP). The vast majority of the payloads use either `VirtualProtect()` to give execute permission to the memory area where the second-stage shellcode resides, or `VirtualAlloc()` to allocate some executable memory and copy the shellcode there. To achieve this, there are specific sets of values for certain arguments that exploit code must use. For instance, the `flNewProtect` or `flProtect` argument, respectively, should be one of `PAGE_EXECUTE`, `PAGE_EXECUTE_READ`, `PAGE_EXECUTE_READWRITE` (most commonly encountered), or `PAGE_EXECUTE_WRITECOPY`. In applications where these memory protection constants are never used, Shredder is able to derive policies that effectively prevent their use. We also encountered a few payloads that use `WinExec()` or `NtSetInformationProcess()`.

**Table 6: List of Windows ROP Payloads Used in Our Experimental Evaluation**

1-5) Direct RET: The ROP Version with Immunity Debugger, Direct RET: Generic parameter generation for ROP, Direct RET: NtSetInformationProcess(), Direct RET: WinExec(), Direct RET: Using VirtualAlloc()
<https://www.corelan.be/index.php/2010/06/16/exploit-writing-tutorial-part-10-chaining-dep-with-rop-the-rubikstm-cube/>

6) ASLR/DEP bypass exploit - BlazeDVD5.1
<https://thesprawl.org/research/corelan-tutorial-10-exercise-solution/>

7) A DEP evasion technique
<http://woct-blog.blogspot.com/2005/01/dep-evasion-technique.html>

8) Buffer overflow attacks bypassing DEP
<http://www.mastropaolo.com/2005/06/05/buffer-overflow-attacks-bypassing-dep-nxxd-bits-part-2-code-injection/>

9) TrailOfBits Practical ROP
<https://trailofbits.files.wordpress.com/2010/04/practical-rop.pdf>

10) The Audio Converter Case
<http://tekwizz123.blogspot.com/2014/02/bypassing-aslr-and-dep-on-windows-7.html>

11) DEP Bypass
<https://www.nccgroup.trust/uk/about-us/newsroom-and-events/blogs/2016/june/writing-exploits-for-win32-systems-from-scratch/>

12) Defeating DEP with ROP
<https://samsclass.info/127/proj/rop.htm>

13) Vulnserver DEP Bypass Exploit
<https://web.archive.org/web/20121110045053/http://www.violentpython.org/wordpress/>

14) Malicious PDF in Adobe Reader
<http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0569>

15) Malicious SWF in Adobe Flash
<https://cve.mitre.org/cgi-bin/cvename.cgi?name=cve-2010-2883>

16) Abusing Non-ASLR’d Modules
<https://exploitresearch.wordpress.com/2012/06/23/abusing-non-aslrd-modules-on-windows-7/>

17) Buffer Overflow on Vulnserver
<http://resources.infosecinstitute.com/return-oriented-programming-rop-attacks/>

18-19) DEP bypass with msvcr71, mona.py, DEPS-Precise Heap Spray - Firefox, IE10
<https://www.corelan.be/index.php/2011/07/03/universal-depaslr-bypass-with-msvcr71-dll-and-mona-py/>

20) Bypassing Win ASLR using “skype4COM”
<http://www.greyhathacker.net/?p=641>

21) Whitepaper on Bypassing ASLR/DEP
<https://www.exploit-db.com/docs/17914.pdf>

22) An Easy Guide to Bypass DEP using ROP
<http://securitydynamics.blogspot.com/2015/11/an-easy-guide-to-bypass-dep-using-rop.html>

23) A-PDF All to MP3 Converter
<http://www.exploit-db.com/exploits/17275/>

24) Integard Pro v2.2.0.9026
<http://www.exploit-db.com/exploits/15016/>

25) Mplayer Lite r33064
<http://www.exploit-db.com/exploits/17124/>

26) Adobe Acrobat Bundled Int Overflow
<http://www.exploit-db.com/exploits/16670/>

27) Adobe Flash “newfunction” Invalid Ptr
<http://www.exploit-db.com/exploits/16687/>

28) Adobe CoolType SING “uniqueName”
<http://www.exploit-db.com/exploits/16619/>

29) Adobe Flash “Button” Remote Code Exec
<http://www.exploit-db.com/exploits/16667/>

30) Winamp v5.572
<http://www.exploit-db.com/exploits/14068/>

**Table 7: Sets of Equivalent Windows API Functions Considered for the Construction of Shellcode Variants with the Same Functionality (Used in the Experiments of Section 5.4.3)**

1. `VirtualAlloc`, `coTaskmemAlloc`, `globalAlloc`, `heapAlloc`, `localAlloc`, `malloc`, `new`
2. `VirtualProtect`
3. `CreateThread`, `CreateRemoteThread`, `CreateProcess`, `ShellExecute`, `ShellExecuteEx`, `system`, `WinExec`
4. `CloseHandle`, `FindClose`
5. `CreateFile`, `CreateTextFile`, `WriteAllText`, `WriteAllLines`, `Write`, `WriteLine`, `WriteAsync`, `WriteTextAsync`, `WriteLinesAsync`, `WriteLineAsync`, `AppendLinesAsync`, `AppendTextAsync`, `AppendAllLines`, `AppendAllText`, `AppendText`, `WriteFile`, `FtpGetFile`, `FtpPutFile`, `FileOpenPicker`
6. `OpenFile`, `FtpOpenFile`, `ReadFile`, `CreateFileMapping`
7. `DeleteFile`, `remove`, `unlink`, `MoveFileEx`, `MoveFileTransacted`, `MoveFileWithProgress`, `FtpDeleteFile`, `_wremove`
8. `DuplicateHandle`, `CreateFile`, `WSADuplicateHandle`
9. `ExitProcess`, `ExitThread`, `TerminateProcess`, `_tsystem`, `closesocket`, `shutdown`
10. `ioctlsocket`, `WSAAsyncSelect`, `WSAEventSelect`, `WSAIoctl`, `recv` with `MSG_PEEK`
11. `URLDownloadToFile`, `ShellExecute`, `libcurl`, `InternetReadFile`, `InternetOpenUrl`
12. `InternetOpen`, `open`, `WinInet`, `HttpOpenRequest`, `HttpSendRequest`, `InternetOpenUrl`, `FtpGetFile`, `FtpGetFileEx`, `FtpOpenFile`, `send`, `HttpSendRequest`

This revised version aims to improve clarity, coherence, and professionalism in the text.