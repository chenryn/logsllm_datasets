ceedings of the 22nd ACM Conference on Computer and Communications Security
(CCS). 256–267.
[68] Reinhard Tartler, Anil Kurmus, Bernhard Heinloth, Valentin Rothberg, Andreas
Ruprecht, Daniela Dorneanu, Rüdiger Kapitza, Wolfgang Schröder-Preikschat,
and Daniel Lohmann. 2012. Automatic OS Kernel TCB Reduction by Leveraging
Compile-time Con(cid:27)gurability. In Proceedings of the 8th USENIX Conference on
Hot Topics in System Dependability (HotDep).
[69] PaX Team. Address Space Layout Randomization. (2003). http://pax.grsecurity.
net/docs/aslr.txt.
[70] Victor van der Veen, Dennis Andriesse, Manolis Stamatogiannakis, Xi Chen,
Herbert Bos, and Cristiano Giu(cid:29)rdia. 2017. The Dynamics of Innocent Flesh
on the Bone: Code Reuse Ten Years Later. In Proceedings of the ACM SIGSAC
Conference on Computer and Communications Security (CCS). 1675–1689.
[71] D. Wagner and R. Dean. 2001. Intrusion detection via static analysis. In Proceedings
of the IEEE Symposium on Security & Privacy. 156–168.
[72] Richard Wartell, Vishwath Mohan, Kevin W Hamlen, Zhiqiang Lin, and W Camp-
bell Rd. 2012. Binary stirring: Self-randomizing instruction addresses of legacy
x86 binary code. In Proceedings of the 19th ACM conference on Computer and
communications security (CCS). 157–168.
[73] Jan Werner, George Baltas, Rob Dallara, Nathan Otternes, Kevin Snow, Fabian
Monrose, and Michalis Polychronakis. 2016. No-Execute-After-Read: Preventing
Code Disclosure in Commodity Software. In Proceedings of the 11th ACM Asia
Conference on Computer and Communications Security (ASIACCS). 35–46.
[74] Andreas Wespi, Marc Dacier, and Hervé Debar. 2000. Intrusion Detection Using
Variable-Length Audit Trail Patterns. In Proceedings of the 3rd Conference in
Recent Advances in Intrusion Detection (RAID). 110–129.
[75] Chao Zhang, Tao Wei, Zhaofeng Chen, Lei Duan, László Szekeres, Stephen Mc-
Camant, Dawn Song, and Wei Zou. 2013. Practical Control Flow Integrity &
Randomization for Binary Executables. In Proceedings of the 34th IEEE Symposium
on Security & Privacy (S&P).
[76] Mingwei Zhang and R Sekar. 2013. Control (cid:30)ow integrity for COTS binaries. In
22nd USENIX Security Symposium.
APPENDIX
A CALL-SITE-SPECIFIC SPECIALIZATION
In many cases, it is possible to determine the values of a given
argument for the majority of a function’s call sites, but miss just a
few call sites in which the values for the same argument remain
unknown, preventing the speci(cid:27)cation of a global policy. In such
cases, Shredder’s policies can be re(cid:27)ned so that instead of having a
single “weak” policy for all call sites of a given function (or no policy
at all), di(cid:29)erent policies can be enforced according to the actual call
site from which the function was invoked. The main bene(cid:27)t of such
a call-site-speci(cid:27)c specialization approach is that for cases in which
an e(cid:29)ective global policy cannot be derived for a given function, at
least the majority of its call sites can still be protected. For instance,
when just a few call sites of VirtualProtect() legitimately use
the execute permission in a given application, then an attacker
would have to invoke it only through those particular call sites, as
part of a ROP payload that needs to allocate executable memory.
In a sense, this approach creates multiple versions of the original
function, each with di(cid:29)erent stripped functionality. The aggres-
sively stripped-down version becomes the default (as it is of no use
for attackers), while invocations to the more “dangerous” version
of the function can be permitted only from the speci(cid:27)c code loca-
tions that really require the sensitive functionality (i.e., allocating
executable memory). To prevent attackers from simply jumping to
particular call sites and reusing the sensitive version of the function,
the invocation points can be protected further by applying context-
sensitive and type-based control (cid:30)ow integrity [14]. Assuming such
a form of CFI is in place, this enforcement complicates signi(cid:27)cantly
the construction of a functional ROP payload, as the attacker has
now less freedom in picking appropriate ROP gadgets that include
V--31[&,%>)0&
V--31[&,%>)0&
VirtualProtect(0x4f,  512, 
VirtualProtect(0x4f,  512, 
0x40, 0xff3)
0x40, 0xff3)
B$,&00&,
G)4=1‘%>$&1[
3
3
@
O=,-"34G,)-&1- JLL%+%LL%+%567 +%LLK
@
O=,-"34G,)-&1- JLL%+%LL%+%56859 +%LLK
@
O=,-"34G,)-&1- JLL%+%LL%+%LL%+%LLK
@
V!!L&2&
Figure 7: Call-site-speci(cid:27)c policies restrict the call sites that
can be reused by an attacker to a fraction of all available
call sites. In this example, when Shredder is enabled, only
the third call site remains usable.
the non-protected call sites, while at the same time not violating
the CFI policy [12, 15, 26, 59, 61].
Figure 7 illustrates this case further. The attacker’s code attemtps
to use VirtualProtect() with the third parameter set to 0x40. The
application in this case has three di(cid:29)erent call sites for that function,
two of which has known, hard-coded values (0x2 and 0x104), which
now become part of the call-site-speci(cid:27)c policy. Given that these
known values are di(cid:29)erent than what the attacker needs to use
for the exploit code, if any of the (cid:27)rst two call sites is reused as
part of a ROP payload, then Shredder will identify the argument
mismatch and prevent the attack. Only if the last call site is used
by the attacker, then the attack will succeed.
Call-site-speci(cid:27)c policies are implemented by including call site
identi(cid:27)ers to the policies. Every call site of a critical function is
recorded along with the set of input arguments. The address of
each call site is kept with respect to the subroutine it is part of and
with respect to the base of the binary image. Also, the name of the
module (executable or shared library) which makes the call is also
recorded as part of the policy.
A policy for a given call site includes the following (cid:27)elds:
(1) Critical function name
(2) Module name
(3) O(cid:29)set within the module
(4) Tuple with “known” and “unknown” arguments for this par-
ticular call site
For every call of a sensitive function, the runtime interposition
layer traverses the stack of the process to determine the origin of
the call. For the current process, we use EnumProcessModule(),
GetModuleFileName() and GetModuleInformation() to get the
image base addresses of all the modules loaded by the application.
With this information, an intercepted call is veri(cid:27)ed against the
policies of all modules.
Table 4 shows the number of call sites for which Shredder was
previously unable to create global policies (second column), and
their subset for which site-speci(cid:27)c policies can be derived. In several
applications, we see that a majority of the previously unprotected
call sites are now protected. Still, there are cases like 7zip and
13ACSAC ’18, December 3–7, 2018, San Juan, PR, USA
Shachee Mishra and Michalis Polychronakis
Table 4: Number of call sites for which site-speci(cid:27)c policies
can be derived.
Table 5: Set of critical Windows API functions considered by
Shredder for policy enforcement.
Application
Call sites without
global policies
Call sites with
site-specific policies
7Zip
Google Chrome
Microso(cid:28) Edge
Mozilla Firefox
iTunes
PhotoViewer
Notepad++
Powershell
VLC
Winrar
12
42
94
28
108
4
18
2
5
47
0 ( 0%)
31 (75%)
52 (55%)
12 (43%)
76 (70%)
2 (50%)
0 ( 0%)
0 ( 0%)
2 (40%)
11 (23%)
Notepad++ for which even site-speci(cid:27)c policies could not be derived.
As discussed in Section 5.3.2, this is again mostly due to input
arguments that can only be derived at runtime.
B ROP PAYLOAD DATA SET
Table 6 shows a detailed list of the ROP payloads used in our eval-
uation (some sources contain multiple distinct payloads). We did
not include payloads that would not be functional in the consid-
ered Windows 10 environment (e.g., ROP payloads that rely on
setProcessDEPPolicy(), which works only on Windows XP). The
vast majority of the payloads use either VirtualProtect() to give
execute permission to the memory area where the second-stage
shellcode resides, or VirtualAlloc() to allocate some executable
memory and copy the shellcode there. To achieve this, there are
speci(cid:27)c sets of values for certain arguments that exploit code must
use. For instance, the flNewProtect or flProtect argument, re-
spectively, should be one of PAGE_EXECUTE, PAGE_EXECUTE_READ,
PAGE_EXECUTE_READWRITE (most commonly encountered), or PAG
E_EXECUTE_WRITECOPY. In applications that these memory protec-
tion constants are never used, Shredder is able to derive policies that
e(cid:29)ectively prevent their use. We also encountered a few payloads
that use WinExec() or NtSetInformationProcess().
kernel32.dll
CloseHandle
CreateFileA
CreateFileMappingA
CreateFileMappingW
CreateFileW
CreateProcessA
CreateProcessW
CreateRemoteThread
DeleteFileA
DeleteFileW
DuplicateHandle
ExitProcess
ExitThread
GetCurrentProcess
ws2_32.dll
accept
bind
closesocket
connect
ioctlsocket
listen
wininet.dll
GetSystemDirectoryA
GetSystemDirectoryW
GetTemplatePathA
GetTemplatePathW
LoadLibraryA
LoadLibraryW
PeekNamedPipe
ReadFile
Sleep
VirtualAlloc
VirtualProtect
WaitForSingleObject
WinExec
WriteFile
recv
send
socket
WSASocketA
WSASocketW
WSAStartup
InternetOpenA
InternetOpenUrlA
InternetOpenUrlW
InternetOpenW
InternetReadFile
msvcrt.dll
_execv
fclose
urlmon.dll
fopen
fwrite
URLDownloadToFileA
URLDownloadToFileW
ntdll.dll
NtSetInformationProcess
14Shredder: Breaking Exploits through API Specialization
ACSAC ’18, December 3–7, 2018, San Juan, PR, USA
Table 6: List of Windows ROP payloads used in our experimental evaluation.
1–5) Direct RET: The ROP Version with Immunity Debugger, Direct RET: Generic parameter generation for ROP
Direct RET: NtSetInformationProcess(), Direct RET: WinExec(), Direct RET: Using VirtualAlloc()
https://www.corelan.be/index.php/2010/06/16/exploit-writing-tutorial-part-10-chaining-dep-with-rop-the-rubikstm-cube/
6) ASLR/DEP bypass exploit - BlazeDVD5.1
https://thesprawl.org/research/corelan-tutorial-10-exercise-solution/
7) A DEP evasion technique
http://woct-blog.blogspot.com/2005/01/dep-evasion-technique.html
8) Bu(cid:27)er overflow a(cid:29)acks bypassing DEP
9)
10)
http://www.mastropaolo.com/2005/06/05/bu(cid:29)er-over(cid:30)ow-attacks-bypassing-dep-nxxd-bits-part-2-code-injection/
TrailOfBits Practical ROP
https://trailofbits.(cid:27)les.wordpress.com/2010/04/practical-rop.pdf
The Audio Converter Case
http://tekwizz123.blogspot.com/2014/02/bypassing-aslr-and-dep-on-windows-7.html
11) DEP Bypass
https://www.nccgroup.trust/uk/about-us/newsroom-and-events/blogs/2016/june/writing-exploits-for-win32-systems-from-scratch/
12) Defeating DEP with ROP
https://samsclass.info/127/proj/rop.htm
13) Vulnserver DEP Bypass Exploit
https://web.archive.org/web/20121110045053/http://www.violentpython.org/wordpress/
14) Malicious PDF in Adobe Reader
http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0569
15) Malicious SWF in Adobe Flash
https://cve.mitre.org/cgi-bin/cvename.cgi?name=cve-2010-2883
16) Abusing Non-ASLR’d Modules
https://exploitresearch.wordpress.com/2012/06/23/abusing-non-aslrd-modules-on-windows-7/
17) Bu(cid:27)er Overflow on Vulnserver
http://resources.infosecinstitute.com/return-oriented-programming-rop-attacks/
18–19) DEP bypass with msvcr71, mona.py, DEPS-Precise Heap Spray - Firefox, IE10
https://www.corelan.be/index.php/2011/07/03/universal-depaslr-bypass-with-msvcr71-dll-and-mona-py/
20) Bypassing Win ASLR using “skype4COM”
http://www.greyhathacker.net/?p=641
21) Whitepaper on Bypassing ASLR/DEP
https://www.exploit-db.com/docs/17914.pdf
22) An Easy Guide to Bypass DEP using ROP
http://securitydynamics.blogspot.com/2015/11/an-easy-guide-to-bypass-dep-using-rop.html
23) A-PDF All to MP3 Converter
24)
http://www.exploit-db.com/exploits/17275/
Integard Pro v2.2.0.9026
http://www.exploit-db.com/exploits/15016/
25) Mplayer Lite r33064
http://www.exploit-db.com/exploits/17124//
26) Adobe Acrobat Bundled Int Overflow
http://www.exploit-db.com/exploits/16670/
27) Adobe Flash “newfunction” Invalid Ptr
http://www.exploit-db.com/exploits/16687/
28) Adobe CoolType SING “uniqueName”
http://www.exploit-db.com/exploits/16619/
29) Adobe Flash “Bu(cid:29)on” Remote Code Exec
http://www.exploit-db.com/exploits/16667/
30) Winamp v5.572
http://www.exploit-db.com/exploits/14068/
15ACSAC ’18, December 3–7, 2018, San Juan, PR, USA
Shachee Mishra and Michalis Polychronakis
Table 7: Sets of equivalent Windows API functions considered for the construction of shellcode variants with the same func-
tionality (used in the experiments of Section 5.4.3).
1) VirtualAlloc, coTaskmemAlloc, globalAlloc, heapAlloc, localAlloc, malloc, new
2) VirtualProtect
3) CreateThread, CreateRemoteThread, CreateProcess, ShellExecute, ShellExecuteEx, system, WinExec
4) CloseHandle, FindClose
5) CreateFile, CreateTextFile, WriteAllText, WriteAllLines, Write, WriteLine, WriteAsync, WriteTextAsync, WriteLinesAsync,
WriteLineAsync, AppendLinesAsync, AppendTextAsync, AppendAllLines, AppendAllText, AppendText, WriteFile,
FtpGetFile, FtpPutFile, FileOpenPicker
6) OpenFile, FtpOpenFile, ReadFile, CreateFileMapping
7) DeleteFile, remove, unlink, MoveFileEx, MoveFileTransacted, MoveFileWithProgress, FtpDeleteFile, _wremove
8) DuplicateHandle, CreateFile, WSADuplicateHandle
9)
ExitProcess, ExitThread, TerminateProcess, _tsystem
closesocket, shutdown
10)
11)
ioctlsocket, WSAAsyncSelect, WSAEventSelect, WSAIoctl, recv with MSG_PEEK
12) URLDownloadToFile, ShellExecute, libcurl, InternetReadFile, InternetOpenUrl
13)
14)
InternetOpen, open, WinInet, H(cid:29)pOpenRequest, H(cid:29)pSendRequest, InternetOpenUrl, FtpGetFile, FtpGetFileEx, FtpOpenFile
send, H(cid:29)pSendRequest
16