# CVE-2021-3129 Laravel Debug mode RCE 漏洞分析
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 0x00 前言
这是笔者第一次撰写漏洞分析的文章，Ignition
个人并没有深入的开发经验，所以有部分可能写得不是那么“入行”，在浏览了许多官方文档粗略了解的情况下，复现并分析了这个漏洞。
总之，如有不当，烦请评论捉虫，我会在第一时间响应并评论提示，谢谢。
## 0x01 简介
Laravel 是基于 MVC 模式的 php 框架，更多框架知识可参考：
[Laravel 框架基础知识总结](https://www.cnblogs.com/yimingwang/p/9781735.html)
[Laravel 5.8 中文文档](https://learnku.com/docs/laravel/5.8)
Ignition 是 Laravel 6 应用程序的默认可自定义的错误页面，它允许在 Flare 上公开分享错误。 如果使用有效的 Flare API
key 进行配置，则会跟踪在应用程序中发生的错误，包括堆栈跟踪。
[Ignition 项目地址](https://github.com/facade/ignition)
[Ignition 官方文档](https://flareapp.io/docs/ignition-for-laravel/installation)
这篇建议阅读，会帮助后续理解：
[Laravel Ignition 功能全解析](https://learnku.com/laravel/t/33857)
####  漏洞成因
在 Debug 模式下，Laravel 内置的 Ignition 功能某些接口未严格过滤输入数据，导致 `file_get_contents()` 和
`file_put_contents()` 函数使用不安全，从而使攻击者能够使用恶意日志文件引起 phar 反序列化攻击，远程执行代码并最终获得服务器权限。
####  影响版本
  * Laravel 
具体配置参照项目的食用方法，`generate app key` 刷新显示如下页面即成功。
同时我们还需要一个工具 [phpggc](https://github.com/ambionics/phpggc) 生成 payload：
    git clone https://github.com/ambionics/phpggc.git
## 0x02 复现
以 [Ignition 2.5.1](https://github.com/facade/ignition/releases/tag/2.5.1)
源代码审计。
在功能解析的文章中，我们知道 Igniton 有很多建议的解决方案，这对应着源码中的 `Solutions`：
我们配置环境做的 `generate app key` 也在其中。
漏洞成因出自 `MakeViewVariableOptionalSolution.php` 这个文件过滤不严，举个例子，假如我们使用了一个未知变量：
可以看到使用了 blade 模板。
Ignition 提出的解决方案便是将 `{{ $name }}` 替换为`{{ $name ?? '' }}` ，这里我们点击 `Make
variable optional` 前抓包：
post 传递了相应的解决方案类、要替换的变量名以及对应 View 文件路径。
###  代码审计
接下来审计代码，看上述三个参数是否有可利用的地方。
首先我们从 `src/IgnitionServiceProvider.php` 中查找对应路由映射的控制器。
`src/Http/Controllers/ExecuteSolutionController.php` 这是只有单个行为的控制器：
    class ExecuteSolutionController
    {
        use ValidatesRequests;
        public function __invoke(
            ExecuteSolutionRequest $request,
            SolutionProviderRepository $solutionProviderRepository
        ) {
            $solution = $request->getRunnableSolution();
            $solution->run($request->get('parameters', []));
            return response('');
        }
    }
`solution` 决定解决方案类名：
`src/SolutionProviders/SolutionProviderRepository.php` ：
    public function getSolutionForClass(string $solutionClass): ?Solution
        {
            if (! class_exists($solutionClass)) {
                return null;
            }
            if (! in_array(Solution::class, class_implements($solutionClass))) {
                return null;
            }
            return app($solutionClass);
        }
其确保了我们指向的类实现 `RunnableSolution` 这个接口，这个参数是不能被随意更改的，pass。
而另外的 `parameters` 则会被传到各个方案类中：
我们再来看 `variableName` 和 `viewFile`：
`src/Solutions/MakeViewVariableOptionalSolution.php`：
    class MakeViewVariableOptionalSolution implements RunnableSolution
    {
        .
        .
        .
        public function run(array $parameters = [])
        {
            $output = $this->makeOptional($parameters);
            // 这里写入修改后的文件
            if ($output !== false) {
                file_put_contents($parameters['viewFile'], $output);
            }
        }
        public function makeOptional(array $parameters = [])
        {
            /* 注解 1:
             * 读取 viewFile 文件内容，然后判断 variableName 是否设置并非 NULL(isset)，决定对文件的操作:
             * (1) 已设置，什么都不做。
             * (2) 未设置，就将 '$'.$parameters['variableName'] 替空('')
             */
            $originalContents = file_get_contents($parameters['viewFile']);
            $newContents = str_replace('$'.$parameters['variableName'], 
                                       '$'.$parameters['variableName']." ?? ''", 
                                       $originalContents);
            /* 注解 2:
             * 对原始文件内容和修改后的文件内容字符进行了解析，然后使用 Zend 引擎的语法分析器获取源码中的 PHP 语言的解析器代号
             * 等价于分析代码结构
             */
            $originalTokens = token_get_all(Blade::compileString($originalContents));
            $newTokens = token_get_all(Blade::compileString($newContents));
            /* 注解 3:
             * 进行了一次“正确”的代码结构分析，如果我们对 variableName 动了些手脚，它可以通过结果对比阻止我们修改文件
             * 当然如果比对正确，修改后的文件将会被写入
             */
            $expectedTokens = $this->generateExpectedTokens($originalTokens, $parameters['variableName']);
            if ($expectedTokens !== $newTokens) {
                return false;
            }
            return $newContents;
        }
        // 正常情况下的 token_get_all() 执行结果生成
        protected function generateExpectedTokens(array $originalTokens, string $variableName): array
        {
            $expectedTokens = [];
            foreach ($originalTokens as $token) {
                $expectedTokens[] = $token;
                if ($token[0] === T_VARIABLE && $token[1] === '$'.$variableName) {
                    $expectedTokens[] = [T_WHITESPACE, ' ', $token[2]];
                    $expectedTokens[] = [T_COALESCE, '??', $token[2]];
                    $expectedTokens[] = [T_WHITESPACE, ' ', $token[2]];
                    $expectedTokens[] = [T_CONSTANT_ENCAPSED_STRING, "''", $token[2]];
                }
            }
            return $expectedTokens;
        }
    }
配合代码的三条注解理解，`variableName` 其实等同于加密口令，我们很难绕过这个验证。
而最后一个变量 `viewFile` ，有读写两个操作，且 **没有任何过滤** ：
    $originalContents = file_get_contents($parameters['viewFile']);
    if ($output !== false) {
                file_put_contents($parameters['viewFile'], $output);
    }
而 `file_get_contents` 通过 `phar://` 伪协议解析 phar 文件时，会将 meta-data
进行反序列化，我们或许可以利用它来 RCE 。
###  漏洞分析
接下来我们从两个问题出发，分析如何去利用这个漏洞。
####  写入什么样的文件？
现在，我们的目的是要找合适的文件写入，之前的情况是使用了未知变量，但因为 `variableName`
修改文件内容前有严格验证，我们并不能利用它，也不能从页面得到任何有效信息，已存在的文件同理。
那么，最后的选项便是日志文件了。
Laravel 使用 [Monolog](https://github.com/Seldaek/monolog)
库为各种强大的日志处理程序提供支持，`config/app.php` 配置文件的 `debug`
选项决定了是否向用户显示错误信息。默认情况下，此选项设置为获取存储在 `.env` 文件中的 `APP_DEBUG` 环境变量的值，默认的 Laravel
日志记录在一个文件 `storage/logs/laravel.log` 。
我们复现的环境本来就是处于 Debug 模式下，本来对于本地开发，应该将 `APP_DEBUG` 环境变量设置为 true 。而在生产环境中，此值应始终保持
false 。如果在生产中将该值设置为 true
，则有可能会将敏感的配置信息暴露给应用程序的最终用户，这也是该漏洞的一大成因。举个例子，我们来尝试加载一个不存在的 View 文件：
再来看实例的 log 文件是否有对应记录：
成功了，这样我们可以尝试注入精心构造的 payload 通过日志文件获取想要的信息。
####  如何转换文件？
虽能写入日志文件，还是有几个问题需要注意：
我们写入了日志文件后，要怎么让其作为 php 文件解析？
后缀名是不能变的，那么自然而然想到了 phar 来伪造。
phar 文件只要有正确的 stub 即可，它可以理解为一个标志，格式为 `xxx<?php xxx;