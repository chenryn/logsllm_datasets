图2.1 常见大“O”函数的图像
图2.1是表2.1中常见函数的图像。注意到当n很小时，函数之间不易区分，很难说谁占主导。
然而，当n增大时，就能观察到明显的区别，很容易进行比较。
最后再举一个例子，假如我们有如下所示的一个Python代码片段，。尽管这个程序实现不了什
么功能，但能指导我们如何对代码进行执行分析。
a = 5
b = 6
c = 10
for i in range(n):
for j in range(n):
x = i * i
y = j * j
z = i * j
for k in range(n):
w = a * k + 45
v = b * b
d = 33
代码2.8
我们发现，任务操作总数分为四项。第一项是常数3，代表程序开头的三个赋值语句。第二项是
3n²，因为嵌套迭代（循环结构）中有三个赋值语句分别被重复执行了n²次。第三项是2n，表示两
个赋值语句被重复执行了n次。最后一项是常数1，代表最后的赋值语句。我们得到T(n) = 3+3n²
+2n+1 = 3n²+2n+ 4。看到指数项，我们自然地发现n²项占主导，当n增大时，其他项和主导项的系
数都可以忽略，所以这个代码片段的数量级就是O(n²)。
图2.2 常见的大“O”函数与T(n)函数对比
表2.2表示常见的大“O”函数与前面讨论到的T(n)进行比较。起初T(n)函数比三次函数大一
些。但是，当n增大时，三次函数很快超过了T(n)。不难发现，随着n增大，T(n)函数越来越接近二
次函数。
小试牛刀
1.编写两个Python函数来寻找一个列表中的最小值。函数一将列表中的每个数都与其他数作比
较，数量级是O(n²).函数二的数量级是O(n)。
2.2.2 变位词检测
经典的字符串变位词检测问题是比较不同数量级函数算法的一个典型例子。如果一个字符串是
另一个字符串的重新排列组合，那么这两个字符串互为变位词。比如，”heart”与”earth”互为变位
词，”python”与”typhon”也互为变位词。为了简化问题，我们设定问题中的字符串长度相同，都是由
26个小写字母组成。我们需要编写一个接受两个字符串，返回真假，代表是否是一对变位词的布尔
函数。
解法1：检查标记
变位词问题的第一种解法是检查第一个字符串中的所有字符是不是都在第二个字符串中出现。
如果能够把每一个字符都“检查标记”一遍，那么这两个字符串就互为变位词。检查标记一个字符
要用特定值None来代替，作为标记。然而，由于字符串不可变，首先要把第二个字符串转化成一个
def anagram_solution1(s1,s2):
a_list = list(s2)
pos1 = 0
still_ok = True
while pos1 <len(s1) and still_ok:
pos2 = 0
found = False
while pos2 <len(a_list) and not found:
if s1[pos1] == a_list[pos2]:
found = true
else:
pos2 = pos2 + 1
If found:
a_list[pos2] = None
else:
still_ok = false
pos1 =pos1 + 1
return still_ok
print(anagram_solution1(‘abcd’,’dcba’)
列表。第一个字符串中的每一个字符都可以在列表的字符中去检查，如果找到，就用None代替以示
标记。
代码2.9
为了分析这个算法，我们要注意到s1中n个字符的每一个都会引起一个最多迭代到s2列表中第
n个字符的循环。（考虑最坏的情况）列表中的n个位置各会被寻找一次去匹配s1中的某个字符，
那么执行总数就是从1到n的代数和。我们之前提到过它可以这样表示：
∑𝑛 𝑖 = 𝑛(𝑛+1) = 𝑛2 +𝑛
𝑖=1
2 2 2
当n变大时，n²相对于n将占主要部分，并且1/2可以忽略。因此，这个算法的复杂度是O(n
²)。
Def anagram_solution2(s1,s2):
A_list1=list(s1)
A_list2=list(s2)
A_list1.sort()
A_list2.sort()
Pos=0
Matches=True
While pos < len(s1) and matches:
If a_list1[pos] == a_list2[pos]:
Pos=pos + 1
Else:
Matches=False
Return matches
Print(anagram_solution2(‘abcde’,’edcba’))
代码xxx 解法一
解法二：排序比较法
尽管s1和s2并不相同，但若为变位词它们一定包含完全一样的字符，利用这一特点，我们可以
采用另一种方法。我们首先从a到z给每一个字符串按字母顺序进行排序，如果它们是变位词，那么
我们将得到两个完全一样的字符串。此外，我们可以先将字符串转化为列表，再利用Python中内建
的sort方法对列表进行排序。下面代码展示了这种方法。
第一眼看上去你可能会认为这个算法的复杂度是O(n)，毕竟排序后只需要一个简单的循环去比较n
个字符。然而对Python内建的sort方法的两次使用并非毫无消耗。事实上，正如我们在后面的章节
中将要看到的，排序方法的复杂度往往都是O(n²)或者O(n㏒n)，所以排序贡献了这个函数主要的循
环操作。最终，这个算法和排序的复杂度相同。
解法三：暴力匹配算法
解决这个问题的典型暴力方法是尝试所有的可能。为了解决变位词检测问题，我们可以简单地
构造一个由s1中所有字符组成的所有可能的字符串的列表，并检查s2是否在列表中。然而这个方法
有一个困难之处。当我们构造由s1中字符组成的所有可能字符串时，第一个字符有n个可能，第二
个字符有n-1种可能，第三个则是n-2种，以此类推。所有可能字符串的总数是n*(n-1)*(n-
2)*...*3*2*1。也就是n!。尽管这些字符串中的一些可能是重复的，但程序不能提前预见到，所以还
是会产生n!个字符串。
事实上当n变大时，n!增长的比2ⁿ还要快。如果s1有20个字符，将会有
20!=2,432,902,008,176,640,000个可能的字符串。如果我们每秒进行一个尝试，这将会花费我们
77,146,816,596年去尝试所有列表。这大概不是一个好方法。
解法四：计数比较法
解决变位词问题的最后一个方法利用了任何变位词都有相同数量的a，相同数量的b，相同数量
的c等等。为判断两个字符串是否为变位词，我们首先计算每一个字符在字符串中出现的次数。由于
共有26个可能的字符，我们可以利用有26个计数器的列表，每个计数器对应一个字符。每当我们
看到一个字符，就在相对应的计数器上加一。最终，如果这两个计数器列表相同，则这两个字符串
是变位词。下面展示了这种方法：
代码xxx 计数比较法
Def anagram_solution4(s1,s2):
C1 = [0] * 26
C2 = [0] * 26
For i in range(len(s1)):
Pos = ord(s1[i]) - ord(‘a’)
C1[pos] = c1[pos] + 1
For i in range(len(s2)):
Pos = ord(s2[i]) - ord(‘a’)
C2[pos] = c2[pos] + 1
J = 0
Still_ok = True
Wile j < 26 and still_ok:
If c1[j] == c2[j]:
J = j+1
Else:
Still_ok=False
Return still_ok
Print(anagram_solution4(‘apple’,’pleap’))
同样，这个方法有一些循环操作。然而不同于第一个方法，所有循环都不是嵌套的。前两个计
数字符数的循环都是n重。而因为字符串中总共有26种可能的字符，第三个比较两个计数列表的循
环总是执行26步。把它们全部加起来就得到T(n)=2n+26，也就是O(n)。这样，我们就找到了一个解
决这个问题的线性复杂度的算法。
在结束这个问题之前，我们需要讨论一些关于空间需求的事情，尽管最后一个方法可以以线性
的时间复杂度来运行，但是这是以使用了额外的空间来存储两个计数器列表为代价的。换句话说，
这个算法牺牲了空间来换取时间。
这是一个常见的现象。很多情况下你需要在时间和空间的权衡中做出选择。在这个例子中，额
外的空间消耗并不足道。但是如果可能的字母多达几百万种，这将是一个问题。作为一个计算机科
学家，当要做出算法选择时，需要你根据具体问题来决定利用计算资源的最好方式。
牛刀小试
Q-1：判断下列代码段的大O级别
Q-2：判断下列代码段的大O级别
Q-3：判断下列代码段的大O级别
2.3 PYTHON 数据结构的性能
既然大家已经大体了解了大O表示法以及不同算法间复杂度的差异，在这一节我们的目标是来
讲授一些关于Python中列表和字典操作的大O复杂度的知识。然后我们将展示一些计时操作，以此
来阐明在各种数据结构上使用某个操作的优缺点。这对你去理解这些Python 数据结构的性能是非常
重要的，因为随着我们在本书接下来的部分学习其他数据结构，它们将是我们需要使用到的构件。
在本节中，我们不打算去解释这些性能为什么是这样的问题，不过在接下来的章节中，我们将看到
一些列表和字典的实现方式以及它们的操作是如何依赖于这些实现方式的。
2.3.1 列表 LIST
当要执行列表数据结构时，Python 的编写者有多种方式去实现这个目的。这些方式中的每一个
都对列表运行的速度产生影响。为了做出正确的选择，他们着眼于人们最经常使用的列表数据结构
的方式，然后完善他们的列表操作手段，所以常用的操作是非常快的。当然，他们也会尽力提高那
些不常用操作的速度。但是当不得不去做一个权衡处理时，不常用操作常常被牺牲用来支持那些更
常用操作。
索引和分派到一个索引位置是两个常见操作，它们无论列表多大，操作花费的时间都相同。当
一个操作的速度像这样不依赖于列表的大小，那么这个操作就是O(1)。
另一个非常常用的程序操作是去扩充一个列表。这有两种方式去生成一个更长的列表。你可以
用“append”操作或者串联运算符。这个“append”操作是O(1)。然而，串联运算符是O(k)，这里k
是指正在被连接的列表的大小。了解它对你非常重要，因为通过选择工作的正确工具可以使你的程
序更加有效。
让我们来看一下四种不同的方法来生成从0到n的列表。首先，我们尝试用 for 循环体通过串联生
成一个列表，然后我们可以用“append”代替串联操作。接下来，我们可以使用列表解析来生成一
个列表。最后，也许是最明显的方法，通过列表结构体的访问来使用“range”的功能。下面展示了
生成列表四种方法的代码。
为了获取我们程序运行所需要的时间，我们需要引用Python中的timeit模块。这个timeit模块
是被设计成在一个持续稳定的环境中，尽可能使用与计算机操作系统相似的计时机制，让Python的
开发者实现跨平台运行时间的测量。
为使用timeit模块，你需要创建一个Timer对象，这个对象的参数是两个Python语句。第一个
参数是你想进行计时的Python语句；第二个参数是建立这次测试你将要运行的语句。timeit模块就
将测量运行这个语句一定次数多花费的时间。如果不加要求，timeit模块的默认运行次数是一百万
次。运行结束后，它将以浮点数的形式返回运行的总时间（单位：秒）。但是，由于它默认运行语
句一百万次，当你执行程序一次时，它返回的结果是以微秒为单位的。你也可以在timeit中附上一个
名叫number的参数，这样你就可以指定程序被执行的次数。下图将展示对我们的每一个程序执行
1000次，分别需要花费的时间。
在上面的实验中，我们进行测试的语句是调用函数到test1（），test2（），等等。这个设置语
句可能会让你感觉到十分奇怪，所以让我们更加细致的考虑它。你可能对from，import语句十分熟
悉，但这个语句常常被运用在Python程序文本的开头。在这种情况下，from __main__ import test1
这个语句将来自 __main__命名空间的函数test1调用到为进行时间测量而建立的timeit命名空间中
去。Timeit模块这样做是以为它需要在某中特定的环境中运行，这种环境要求将你可能已经生成的，
或已经偏离的，或可能以某种不可预测的方式对你程序的运行产生干扰的变量进行整理。
从上面的实验中，我们可以清楚的看到，运行时间为0.30毫秒的append操作明显快于运行时
间为6.54毫秒的串联操作。在上面的实验中，我们还展示了创建一个列表（list）的两种额外的方
式：调用range进行列表创建和列表推导。我们惊喜的发现列表推导的速度足足是在for循环中逐个
append操作的两倍。
关于这个小实验的最后一个结论是，上面我们所看到的所有运行时间，都包括了进行访问测试
所耗费的时间。但我们可以认定，在这四种情形中，访问操作所耗费的时间是完全相同的，所以我