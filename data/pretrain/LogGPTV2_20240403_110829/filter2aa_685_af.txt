its input to a string.
Licensed to   
32
CHAPTER 2
Getting started
The fillString procedure in listing 2.8 will generate a new string, equal to "01234".
The constant count will then be assigned this string.
 I added the echo at the top of fillString’s body, in order to show you that it’s exe-
cuted at compile time. Try compiling the example using Aporia or in a terminal by
executing nim c file.nim. You’ll see "Generating string" amongst the output. Run-
ning the binary will never display that message because the result of the fillString
procedure is embedded in it.
 In order to generate the value of the constant, the fillString procedure must be
executed at compile time by the Nim compiler. You have to be aware, though, that not
all code can be executed at compile time. For example, if a compile-time procedure
uses the FFI, you’ll find that the compiler will output an error similar to “Error: cannot
'importc' variable at compile time.”
 The main benefit of using constants is efficiency. The compiler can compute a
value for you at compile time, saving time that would be otherwise spent during run-
time. The obvious downside is longer compilation time, but it could also produce a
larger executable size. As with many things, you must find the right balance for your
use case. Nim gives you the tools, but you must use them responsibly.3
 You can also specify multiple variable definitions under the same var, let, or
const keyword. To do this, add a new line after the keyword and indent the identifier
on the next line:
var
text = "hello"
number: int = 10
isTrue = false
The identifier of a variable is its name. It can contain any characters, as long as the
name doesn’t begin with a number and doesn’t contain two consecutive underscores.
This applies to all identifiers, including procedure and type names. Identifiers can
even make use of Unicode characters:
var 火 = "Fire"
let ogien´ = true
Unlike in many other programming languages, identifiers in Nim are case insensitive
with the exception of the first letter of the identifier. This is to help distinguish vari-
able names, which must begin with lowercase letters, from type names, which must
begin with uppercase letters.
 Identifiers in Nim are also style insensitive. This allows identifiers written in
camelCase to be equivalent to identifiers written in snake_case. The way this is
accomplished is by ignoring the underscore character in identifiers, so fooBar is
equivalent to foo_bar. You’re free to write identifiers in whichever style you prefer,
3 With great power comes great responsibility.
Licensed to   
33
Nim basics
even when they’re defined in a different style. But you’re encouraged to follow Nim’s
style conventions, which specify that variables should use camelCase and types should
use PascalCase. For more information about Nim’s conventions, take a look at the
“Style Guide for Nim Code” on GitHub: https://github.com/nim-lang/Nim/wiki/
Style-Guide-for-Nim-Code. 
2.2.3
Procedure definitions
Procedures allow you to separate your program into different units of code. These
units generally perform a single task, after being given some input data, usually in the
form of one or more parameters.
 In this section, we’ll explore procedures in Nim. In other programming languages
a procedure may be known as a function, method, or subroutine. Each programming lan-
guage attaches different meanings to these terms, and Nim is no exception. A proce-
dure in Nim can be defined using the proc keyword, followed by the procedure’s
name, parameters, optional return type, =, and the procedure body. Figure 2.1 shows
the syntax of a Nim procedure definition.
Stropping
As you may recall from section 2.1, there are identifiers in Nim that are reserved.
Such identifiers are called keywords, and because they have a special meaning, they
can’t be used as names for variables, types, or procedures.
In order to get around this limitation, you can either pick a different name or explicitly
mark the identifier using backticks (`). The latter approach is called stropping, and
here’s how it can be used:
var `var` = "Hello"
echo(`var`)
The var keyword is enclosed in backticks, allowing a variable with that name to be
defined.
proc keyword
Procedure name
Parameter
Return type
Procedure body
Name
Type
Figure 2.1
The syntax of a Nim procedure definition
Licensed to   
34
CHAPTER 2
Getting started
The procedure in figure 2.1 is named myProc and it takes one parameter (name) of
type string, and returns a value of type string. The procedure body implicitly
returns a concatenation of the string literal "Hello " and the parameter name.
 You can call a procedure by writing the name of the procedure followed by paren-
theses: myProc("Dominik"). Any parameters can be specified inside the parentheses.
Calling the myProc procedure with a "Dominik" parameter, as in the preceding exam-
ple, will cause the string "Hello Dominik" to be returned.
 Whenever procedures with a return value are called, their results must be used in
some way.
proc myProc(name: string): string = "Hello " & name
myProc("Dominik")
Compiling this example will result in an error: “file.nim(2, 7) Error: value of type
'string' has to be discarded.” This error occurs as a result of the value returned by the
myProc procedure being implicitly discarded. In most cases, ignoring the result of a
procedure is a bug in your code, because the result could describe an error that
occurred or give you a piece of vital information. You’ll likely want to do something
with the result, such as store it in a variable or pass it to another procedure via a call.
In cases where you really don’t want to do anything with the result of a procedure, you
can use the discard keyword to tell the compiler to be quiet:
proc myProc(name: string): string = "Hello " & name
discard myProc("Dominik")
The discard keyword simply lets the compiler know that you’re happy to ignore the
value that the procedure returns.
When a procedure returns no values, the return type can be omitted. In that case, the
procedure is said to return void. The following two examples return no value:
Order of procedures
Procedures must be defined above the call site. For example, the following code will
fail to compile:
myProc()
proc myProc() = echo("Hello World")
For procedures that have a circular dependency, a forward declaration must be used:
proc bar(): int
proc foo(): float = bar().float
proc bar(): int = foo().int
A future version of Nim will likely remove the need for forward declarations and allow
procedures to be defined in any order.
A forward declaration contains no 
procedure body, just the procedure’s 
name, parameters, and return type.
Licensed to   
35
Nim basics
proc noReturn() = echo("Hello")
proc noReturn2(): void = echo("Hello")
It’s idiomatic to avoid writing the redundant void in procedure definitions. The spe-
cial void type is useful in other contexts, such as generics, which you’ll learn about in
chapter 9.
 Nim allows you to cut down on unnecessary syntax even further. If your procedure
takes no parameters, you can omit the parentheses:
proc noReturn = echo("Hello")
RETURNING VALUES FROM PROCEDURES
A procedure body can contain multiple statements, separated either by a semicolon
or a newline character. In the case where the last expression of a procedure has a non-
void value associated with it, that expression will be implicitly returned from that pro-
cedure. You can always use the return keyword as the last statement of your proce-
dure if you wish, but doing so is not idiomatic nor necessary. The return keyword is
still necessary for early returns from a procedure.
 The following code block shows different examples of returning values from
procedures:
proc implicit: string =
"I will be returned"
proc discarded: string =
discard "I will not be returned"
proc explicit: string =
return "I will be returned"
proc resultVar: string =
result = "I will be returned"
proc resultVar2: string =
result = ""
result.add("I will be ")
result.add("returned")
proc resultVar3: string =
result = "I am the result"
"I will cause an error"
assert implicit() == "I will be returned"
assert discarded() == nil
assert explicit() == "I will be returned"
assert resultVar() == "I will be returned"
assert resultVar2() == "I will be returned"
# resultVar3 does not compile!
ASSERT
The code block showing examples of returning values from proce-
dures uses assert to show the output that you should expect when calling
each of the defined procedures. You’ll learn more about assert when it
comes time to test your code in chapter 3.
Licensed to   
36
CHAPTER 2
Getting started
Just like a variable’s default value, a procedure’s return value will be binary zero by
default. Nim supports a lot of different methods of setting the return value, and
you’re free to combine them.
 Every procedure with a return type has a result variable declared inside its body
implicitly. This result variable is mutable and is of the same type as the procedure’s
return type. It can be used just like any other variable; the resultVar and resultVar2
procedures are two examples. You should make use of it whenever you can, instead of
defining your own variable and returning it explicitly.
 The result variable comes with some restrictions when it’s combined with implicit
returns. These restrictions prevent ambiguities. For example, in the resultVar3 pro-
cedure, what do you think should be returned: the last expression, or the value that
result was assigned? The compiler doesn’t choose for you; it simply shows an error so
you can correct the ambiguity.
 So far, I’ve been explicitly specifying the return types of procedures. You may recall
that this isn’t necessary for variable definition. It’s also possible to ask the compiler to
infer the return type of your procedure for you. In order to do this, you need to use
the auto type:
proc message(recipient: string): auto =
"Hello " & recipient
assert message("Dom") == "Hello Dom"
Although this is handy, you should specify the type explicitly whenever possible. Doing
so makes it easier for you and others to determine the return type of a procedure,
without needing to understand the procedure’s body.
WARNING: TYPE INFERENCE
Type inference for procedures is still a bit experi-
mental in Nim. You may find that it’s limited in some circumstances, espe-
cially if you’re used to more advanced forms of type inference, such as those
found in Haskell or OCaml. 
PROCEDURE PARAMETERS
A procedure with multiple parameters can be defined by listing the parameters and
separating them with the comma character:
proc max(a: int, b: int): int =
if a > b: a else: b
assert max(5, 10) == 10
You don’t need to repeat the types of parameters if they’re specified consecutively:
proc max(a, b: int): int =
if a > b: a else: b
Default parameters can be used to ask for arguments that can be optionally specified
at the call site. You can introduce default parameters by assigning a value to a parame-
ter using the equals character; the type can also be omitted in that case:
Licensed to   
37
Nim basics
proc genHello(name: string, surname = "Doe"): string =
"Hello " & name & " " & surname
assert genHello("Peter") == "Hello Peter Doe"
assert genHello("Peter", "Smith") == "Hello Peter Smith"
A procedure taking a variable number of parameters can be specified using the
varargs type:
proc genHello(names: varargs[string]): string =
result = ""
for name in names:
result.add("Hello " & name & "\n")
assert genHello("John", "Bob") == "Hello John\nHello Bob\n"
PROCEDURE OVERLOADING
Overloading a procedure is a feature that you may not have come across yet, but it’s
one that’s commonly used in Nim. Procedure overloading is the ability to define dif-
ferent implementations of procedures with the same name. Each of these procedures
shares the same name but accept different parameters. Depending on the arguments
passed to the procedure, the appropriate implementation is picked by the compiler.
 As an example, consider a getUserCity procedure. It may take two parameters:
firstName and lastName.
proc getUserCity(firstName, lastName: string): string =
case firstName
of "Damien": return "Tokyo"
of "Alex": return "New York"
else: return "Unknown"
CASE STATEMENTS
Case statements might still be new to you. They’ll be
explained later in section 2.4.
This kind of procedure may be used to retrieve a person’s city of residence from a
database, based on the name specified. You may also wish to offer alternative search
criteria—something more unique, such as an ID number. To do this, you can overload
the getUserCity procedure like so:
proc getUserCity(userID: int): string =
case userID
of 1: return "Tokyo"
of 2: return "New York"
else: return "Unknown"
In this case, the default 
value for the surname 
argument is used.
In this case, the default value is
overridden with the string literal "Smith".
Initializes the result 
variable with a new string
Iterates through each of the 
arguments. You’ll learn more about 
for loops in section 2.4.
Adds the string "Hello" concatenated
with the current argument and a
newline character to the result variable
Licensed to   
38
CHAPTER 2
Getting started
This way, you can reuse the name, but you’re still able to use the different implemen-
tations, as shown here:
doAssert getUserCity("Damien", "Lundi") == "Tokyo"
doAssert getUserCity(2) == "New York
ANONYMOUS PROCEDURES
Sometimes you may wish to pass procedures as parameters to other procedures. The
following listing shows the definition of a new procedure, and how a reference to it
can be passed to the filter procedure.
import sequtils
let numbers = @[1, 2, 3, 4, 5, 6]
let odd = filter(numbers, proc (x: int): bool = x mod 2 != 0)
assert odd == @[1, 3, 5]
These procedures are called anonymous procedures because there’s no name associated
with them. In listing 2.9, the anonymous procedure is highlighted in bold.
THE @ SYMBOL
The @ symbol creates a new sequence. You’ll learn more
about it in the next section.
The anonymous procedure gets a single parameter, x, of type int. This parameter is
one of the items in the numbers sequence. The job of this anonymous procedure is to
determine whether that item should be filtered out or whether it should remain.
When the procedure returns true, the item isn’t filtered out.
 The filter procedure is the one doing the actual filtering. It takes two parame-
ters: a sequence and an anonymous procedure. It then iterates through each item and
uses the anonymous procedure it got to see whether it should filter the item out or
keep it. The filter procedure then returns a new sequence that includes only the
items that the anonymous procedure determined should be kept and not filtered out.
 In listing 2.9, the resulting sequence will only contain odd numbers. This is
reflected in the anonymous procedure, which checks whether dividing each item by 2
results in a remainder. If a remainder is produced, true is returned because that
means the number is odd.
 The syntax for anonymous procedures is a bit cumbersome. Thankfully, Nim sup-
ports some syntactic sugar for defining anonymous procedures and procedure types.
The syntactic sugar isn’t part of the language but is instead defined in the standard
library, so to use it you must import the future module. (The syntactic sugar is
defined using macros, which you’ll learn about in chapter 9.)
Listing 2.9
Using anonymous procedures
Definition of an immutable 
variable holding a list of numbers
The filter procedure used to 
filter out even numbers
Assertion to show 
the output
Licensed to   
39
Collection types
 Compare the following code to listing 2.9, and note the differences shown in bold:
import sequtils, future
let numbers = @[1, 2, 3, 4, 5, 6]
let odd = filter(numbers, (x: int) -> bool => x mod 2 != 0)
assert odd == @[1, 3, 5]
The syntactic sugar doesn’t actually make the definition that much shorter, but it does
remove some of the noise. It can be shortened further using type inference: x => x
mod 2 != 0. But keep in mind that this may not work in some cases. The compiler
may not be able to infer the types for your anonymous procedure. In that case, you’ll
need to explicitly state the types. The -> symbol is used to specify types.
DOCUMENTATION
The documentation for each module (available on Nim’s
website: http://nim-lang.org/) contains links under each procedure defini-
tion to the source code for that procedure. Take a look at it to learn more
about the procedures mentioned in this book.
The -> symbol can also be used on its own in place of procedure types. For example,
you can use it when defining a procedure that takes another procedure as a parameter.
 For example, consider the following code:
proc isValid(x: int, validator: proc (x: int): bool) =
if validator(x): echo(x, " is valid")
else: echo(x, " is NOT valid")
It can be rewritten as follows:
import future
proc isValid(x: int, validator: (x: int) -> bool) =
if validator(x): echo(x, " is valid")
else: echo(x, " is NOT valid")
The proc keyword can be omitted, and the : is replaced by the -> symbol.
 This ends the section on Nim basics. So far, this chapter has been very heavy with
information, but don’t worry if you don’t remember everything that you’ve read or
you don’t understand some concepts. The next chapter will put these ideas into prac-
tice and solidify your knowledge. You can also go back over this section at any time. 
2.3
Collection types
Collections such as lists, arrays, sets, and more are incredibly useful. In this section, I’ll
talk about the three most commonly used collection types in Nim: the array, seq, and
set types.
2.3.1
Arrays
The array type represents a list of a static number of items. This type is similar to C
arrays but offers more memory safety, as demonstrated in the following example:
Licensed to   
40
CHAPTER 2
Getting started
var list: array[3, int]
list[0] = 1
list[1] = 42
assert list[0] == 1
assert list[1] == 42
assert list[2] == 0
echo list.repr
echo list[500]
Arrays are value types, just like int, float, and many others, which means they’re allo-
cated on the stack. This is similar to C arrays, but it differs completely from Java’s
arrays, which are reference types and are stored on the heap.
 Arrays are static in size, so an array can’t change its size once it’s declared. This is
why the compiler can give you an error when you try to access an index outside its
bounds. In C, checks for index bounds aren’t made, so it’s possible to access memory
that’s outside the bounds of the array.
 Nim performs these checks at compile time and at runtime. The runtime checks
are performed as long as the --boundsChecks option is not turned off.
WARNING: THE -D:RELEASE FLAG
Compiling with the -d:release flag will turn
the bounds checks off. This will result in higher performance but less safety.
An array constructor can be used to assign a list of items to the array when it’s defined:
var list = ["Hi", "There"]
You can iterate over most collection types using a for loop. Iterating over a collection
type will yield a single item from the collection during each iteration. If you prefer to
iterate over each index rather than each item, you can access an array’s bounds using
the low and high fields and then iterate from the lowest index to the highest:
var list = ["My", "name", "is", "Dominik"]
for item in list:
echo(item)
for i in list.low .. list.high:
echo(list[i])
The array contains three elements. Any elements that 
have not been set are given a default value.
This will output [1, 42, 0]. The repr procedure converts any 
variable into a string, but the resulting string sometimes 
contains debug information such as the memory address of 
the variable.
Compilation will fail with “Error: index out of bounds.”
Custom array ranges
It’s possible to define arrays with a custom range. By default, arrays range from 0 to
the number specified in the array type, but you can also specify the lower bound, as
in this array of two integers:
var list: array[-10 .. -9, int]
list[-10] = 1
list[-9] = 2
This is useful when your array indices don’t start at 0.
Loops through each item
Loops through each index
Licensed to   
41
Collection types
2.3.2
Sequences
Arrays are static in size. You can’t add more items to them; you can only overwrite
existing items with new data. This is where Nim’s sequences come in. They’re dynamic
in size and can grow to as many items as needed (within the limits of your memory).
You’ve already seen a few examples of sequences in the previous section.
 Sequences are defined using the seq type:
var list: seq[int] = @[]
list[0] = 1
list.add(1)
assert list[0] == 1
echo list[42]
Sequences are stored on the heap, and as such are garbage collected. This means that
they need to be initialized before they’re used, just like strings.
var list: seq[int]
echo(list[0])
Accessing the items of an uninitialized sequence will result in a segmentation fault at
runtime. Copy the preceding code into your favorite text editor and save it as segfault
.nim. Then compile and run it. If you’re using Aporia, just press F5, or open a termi-