title:Off-Path TCP Exploit: How Wireless Routers Can Jeopardize Your Secrets
author:Weiteng Chen and
Zhiyun Qian
Off-Path TCP Exploit: How Wireless Routers  
Can Jeopardize Your Secrets
Weiteng Chen and Zhiyun Qian, University of California, Riverside
https://www.usenix.org/conference/usenixsecurity18/presentation/chen-weiteng
This paper is included in the Proceedings of the 
27th USENIX Security Symposium.
August 15–17, 2018 • Baltimore, MD, USA
978-1-939133-04-5
Open access to the Proceedings of the 27th USENIX Security Symposium is sponsored by USENIX.Off-Path TCP Exploit: How Wireless Routers Can Jeopardize Your Secrets
Weiteng Chen
Zhiyun Qian
University of California, Riverside
University of California, Riverside
PI:EMAIL
PI:EMAIL
Abstract
In this study, we discover a subtle yet serious timing side
channel that exists in all generations of half-duplex IEEE
802.11 or Wi-Fi technology. Previous TCP injection at-
tacks stem from software vulnerabilities which can be
easily eliminated via software update, but the side chan-
nel we report is rooted in the fundamental design of IEEE
802.11 protocols. This design ﬂaw means it is impos-
sible to eliminate the side channel without substantial
changes to the speciﬁcation. By studying the TCP stacks
of modern operating systems and their potential interac-
tions with the side channel, we can construct reliable and
practical off-path TCP injection attacks against the latest
versions of all three major operating systems (macOS,
Windows, and Linux). Our attack only requires a device
connected to the Internet via a wireless router, and be
reachable from an attack server (e.g., indirectly so by ac-
cessing to a malicious website). Among possible attacks
scenarios, such as inferring the presence of connections
and counting exchanged bytes, we demonstrate a partic-
ular threat where an off-path attacker can poison the web
cache of an unsuspecting user within minutes (as fast as
30 seconds) under realistic network conditions.
1
Introduction
Side channels in networking stacks have recently been
demonstrated to precipitate serious attacks. One of the
most noteworthy cases is CVE-2016-5696 [18] where
a completely blind off-path attacker can infer whether
two arbitrary hosts on the Internet are communicating
using a TCP connection. The attacker can even infer
the TCP sequence numbers in use from both sides of
the connection.
In addition to this serious vulnerabil-
ity, other types of side channel vulnerabilities have also
been discovered in various scenarios and protocol com-
ponents [39, 40, 25, 24, 27, 33, 23, 48, 13]. Fundamen-
tally, like any side channel vulnerabilities, these vulner-
abilities are introduced by shared resources between the
attacker and victim.
In the case of TCP, for example, a server has many
kinds of shared resources implemented by operating sys-
tems such as a global IP ID counter [1, 25, 23], SYN
cache and RST limit [24], SYN-backlog [33], and chal-
lenge ACK rate limit [18]. These resources are shared on
a host between a connection established with the attacker
and a connection with the victim.
When the attacker sends spoofed packets to the server
that appear to come from the victim, these shared re-
sources are used differently, depending on the validity of
the spoofed packets (e.g., in-window vs out-of-window
sequence number). By observing the shared resources,
how these spoofed packets are processed are visible to
the attacker.
All existing vulnerabilities related to off-path TCP ex-
ploit essentially stem from software artifacts. The ones
that can lead to serious attacks are already patched pri-
marily by (1) eliminating the shared resources in protocol
implementations (or adding randomness to them) [7, 8]
and (2) reducing the opportunities that the shared re-
sources leak information, e.g., employing a more strin-
gent acknowledge(ACK) number check [44]). As we
will discuss later in §2.3, almost all previously reported
off-path TCP attacks no longer work.
Unlike yet another software side channel, we report a
fundamental side channel inherent in all generations of
IEEE 802.11 or Wi-Fi technology, because they are half-
duplex. From its deﬁnition: when there are uplink wire-
less frames being transmitted, downlink frames have to
wait, and vice versa. This basic and fundamental design
seems benign but it creates a timing channel sensitive to
the contention between uplink and downlink trafﬁc. For
example, a downlink packet measuring the RTT will in-
cur a higher latency if uplink trafﬁc is going on. As we
will show in the paper, an attacker can leverage the tim-
ing channel to craft clever sequences of packets, creat-
ing primitives to infer TCP sequence number and ACK
number, ultimately completing a working off-path TCP
USENIX Association
27th USENIX Security Symposium    1581
C
S
Internet
OR
Sandboxed
script
Un-privileged
App
Mallory
Figure 1: Threat model
exploit.
Through extensive experimentation, we demonstrate
that the timing channel is reliable (through ampliﬁcation)
and can be used even when the attacker and victim are far
away (with RTTs over 20ms). We implement a realistic
blind off-path attack that can achieve web cache poison-
ing within minutes. The video demo can be found on our
project website [3]. We also open sourced the attack im-
plementation at [5] to assist the reproduction and further
research of the work.
The contributions of the paper are the following:
• We report the timing side channel inherent in all gen-
erations of IEEE 802.11 or Wi-Fi technology. We
show the timing channel is reliable and ampliﬁable
and unfortunately almost impossible to eliminate with-
out substantial changes to the 802.11 speciﬁcation.
• We show that the side channel affects macOS, Win-
dows, and Linux by studying the overlaps and differ-
ences in their TCP stack implementations. We con-
struct the only off-path TCP exploit working at the
moment based on this new side channel.
• We provide a thorough analysis and evaluation
of the proposed attack under different router/net-
work/OS/browser combinations. We also suggest pos-
sible defenses to alleviate this attack.
Roadmap. The rest of the paper is organized as follows:
we begin with background introduction and the most rel-
evant work in § 2, and then present the timing side chan-
nel in Wi-Fi technology in § 3. § 4 describes an overview
of the off-path TCP exploit and its goal. In § 5, we elab-
orate the implementation of the attack against different
OSes. In § 6, we evaluate our attack under different con-
ditions. § 7 discusses some potential attacks that exploit
the vulnerability. We propose some mitigation schemes
at different layers in § 8. We also introduce previous re-
search related to side channels in § 9. Finally, § 10 con-
cludes the paper.
2 Off-Path TCP Exploits
2.1 Generic Threat Model
Fig. 1 illustrates a typical off-path TCP hijacking threat
model consisting of three hosts: a victim client, a victim
server and an off-path attacker. The off-path attacker,
Mallory, is capable of sending spoofed packets with the
IP address of the legitimate server. In contrast to Man-in-
the-middle attack, Mallory cannot eavesdrop the trafﬁc
transferred between a client C and a server S. Depending
on the nature of the side channel, an unprivileged appli-
cation or a sandboxed script may be required to run on
the client side [40, 27] to observe the results of the shared
state change and determine the outcome of the spoofed
packets (e.g., whether guessed sequence numbers are in-
window). In rare cases, if the state change is remotely
observable, an off-path attacker can complete the attack
alone without the assistance from the unprivileged ap-
plication or script [18]. After multiple rounds of infer-
ences, starting from whether a connection is established
(four tuple inference) to the expected sequence number
and ACK number inference, the attacker can then inject a
malicious payload that becomes acceptable to the client
at the TCP layer.
The side channels typically manifest
themselves
through the following control ﬂow block:
if ( in_packet . seq is in rcv_window )
// shared state change 1
else
// shared state change 2
The example illustrates two variables: (1) the attacker-
controlled variable in packet.seq — guessed sequence
number in a spoofed packet and (2) the receive window
deciding what in packet.seq are valid. Depending on the
outcome of the comparison, the shared state may change
to different values. The change also has to be observable
by the attacker through some side channel. Two neces-
sary building blocks are needed in a TCP off-path side
channel attack: (1) existence of vulnerable packet valida-
tion logic; (2) the shared state has to be observable by an
attacker (i.e., the sandboxed script, unprivileged app, or
the off-path attacker). Note that together these two build-
ing blocks result in a violation of the non-interference
property [29, 50].
Next we give an overview of these two building blocks
used by previous attacks and explain why those attacks
no longer work. Simply put, they either rely on outdated
TCP packet validation logic or shared state that can be
easily eliminated.
1582    27th USENIX Security Symposium
USENIX Association
Connection 
identiﬁcation
Exist
SYN?
Not Set
Not exist
Set
Rate-
limited?
Sequence 
number check
Out-of-
window
In-window
No
RST?
Not Set
Set
SEQ 
match?
Yes
Send 
RST
No
Yes
RST?
Challenge 
Send 
ACK
Set
Discard
Not Set
Reset the 
connection
Ack number 
check
In-window
Accept
Out-of-window
Send Duplicate 
ACK
Figure 2: Incoming packet validation logic in RFC
2.2 Latest TCP Incoming Packet Valida-
tion Logic
To understand how incoming packets are validated, we
refer to the standards of RFC 793 [4] and RFC 5961 [44].
We focus on the latest standard only as it is helpful in
understanding why attacks against old versions now fail.
Note that even though different operating system imple-
mentations may differ in reality, they still try to keep up
with the standards (albeit with their own tunings) and
overall it provides a foundation for discussion. We dis-
cuss the speciﬁc operating system implementations in §4.
We distill the latest standard and summarize it in Fig.
2. It involves primarily three types of checks, and each
of them has some form of vulnerable logic — different
actions are taken depending on the outcome of the check
(e.g., a response packet is sent vs. not).
• Connection (four-tuple) Identiﬁcation: The ﬁrst
check tries to identify if an incoming packet belongs to
any established connection based on the four tuples –
source and destination port numbers as well as IP ad-
dresses. If no ongoing connection matches the four tu-
ples, an incoming packet not containing a RST causes a
RST to be sent in response. Otherwise, if the SYN bit
is set, irrespective of the sequence number, TCP must
send an ACK referred to as challenge ACK to the remote
peer to conﬁrm the loss the previous connection. Upon
receipt of this challenge ACK, a legitimate remote peer
who truly lost its connection, after a restart, sends a RST
packet back with the sequence number derived from the
ACK ﬁeld of the challenge ACK, which can terminate
the connection at that point. The challenge ACK is hence
a defense against blind off-path attacks that attempt to
terminate a connection forcefully through spoofed SYN
packets.
• Sequence number check: This check makes sure that
the sequence number falls in the receive window. Oth-
erwise, according to the TCP speciﬁcation RFC 793, an
immediate duplicate ACK packet should be sent in re-
ply (unless the RST bit is set, in which case the packet
is dropped without reply).
If the sequence number is
in window and RST bit is on, similar to handling SYN,
RFC 5961 suggests the use of challenge ACKs to defend
against off-path RST attacks: only if the sequence num-
ber matches the next expected sequence number, a re-
ceiver terminates the connection; otherwise, the receiver
must send a challenge ACK.
• ACK number check: Pre-RFC 5961, the ACK num-
ber is considered valid as long as it falls in the wide range
of [SND.UNA (231 1), SND.NXT]1, which is effectively
half of the ACK number space. Thus, an attacker only
needs to guess two ACK numbers for every guessed se-
quence number to successfully inject data into a connec-
tion, resulting in a guaranteed successful data injection
with up to 2⇤ 232/RCV.WND2 spoofed data packets. RFC
5961 proposes a much more stringent check suggest-
ing a valid ACK number should be within [SND.UNA -
MAX.SND.WND, SND.NXT]3, where MAX.SND.WND is the
maximum receive window size the receiver has ever seen
from its peer.
If the ACK number is out of this win-
dow, the packet is dropped and an ACK should be sent
back [44]. If the ACK number is in window yet there is
no payload, then the packet should be silently dropped.
Besides, to alleviate the waste of CPU and bandwidth
resources caused by challenge ACKs, an ACK throttling
mechanism is also proposed. Speciﬁcally, the system ad-
ministrator can conﬁgure the maximum number of chal-
lenge ACKs that can be sent out in a given interval.
2.3 Prior Attacks and Side Channels
Now that we understand how the generic TCP packet val-
idation logic is envisioned by the standard, we describe
the known shared states that lead to side channels, com-
bined with the variants in TCP packet validation logic in
different operating systems (sometimes out-of-date), that
were leveraged by existing attacks.
• Global IPID counter. Until recent years, Windows
is the only operating system that chooses to maintain
a globally incrementing IPID counter shared across all
connections and stamped onto the IPID ﬁeld in IP header
for every outgoing packet [23]. This creates a side chan-
nel that allows an attacker to count how many outgoing
1SND.UNA: the sequence number of the ﬁrst byte of data that has
been sent but not yet acknowledged; SND.NXT: the sequence number
of the next byte of data to be sent
2RCV.WND: size of receive window
3The window can be as small as a few thousand bytes, which makes
the guess much more difﬁcult
USENIX Association
27th USENIX Security Symposium    1583
Side channel
Requirement
Global IPID count [1, 25]
Direct browser page read [27]
Global challenge ACK rate limit [18]
Packet counter [40, 39]
Wireless contention (this work)
Pure off-path or Javascript
Javascript
Pure off-path
Malware
Javascript
Affected OS
Windows
Any old OS
Linux
Patch/Mitigation
Global IPID counter eliminated
RFC 5961
Global rate limit eliminated
Linux,macOS Namespace / macOS* patch [9, 10]
Any
N/A
Table 1: Summary of Different Off-Path TCP Side Channel Attacks including the one we propose in this paper
packets have been sent during a time interval, through
difﬁng the queried IPIDs of a Windows machine. This
is leveraged in several off-path TCP attacks [1, 25]. Us-
ing IP spooﬁng, an off-path attacker can tell whether the
guess is correct based on whether a response is triggered.
However, at the time of writing, we experimentally
verify that Windows 10 has ﬁnally eliminated this side
channel by adopting a safer IPID generation algorithm
similar to that used in Linux [33], where connections
destined for different IP addresses will no longer share