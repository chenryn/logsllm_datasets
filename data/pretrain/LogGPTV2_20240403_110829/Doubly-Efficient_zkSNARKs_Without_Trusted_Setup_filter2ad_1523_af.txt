t
e
b
s
i
r
e
w
o
l
(
104
103
100
10
1
104
103
high-resolution image size, pixels
105
(e) P time: 16× Lanczos scaling
104
s
d
n
o
c
e
s
,
e
m
i
t
r
e
ﬁ
i
r
e
v
)
r
e
t
t
e
b
s
i
r
e
w
o
l
(
103
100
10
1
0.1
103
105
(f) V time: 16× Lanczos scaling
high-resolution image size, pixels
104
105
104
103
100
10
B
k
i
,
e
z
i
s
f
o
o
r
p
)
r
e
t
t
e
b
s
i
r
e
w
o
l
(
1
2
8
log2 M, number of leaves in Merkle tree
(g) Proof size: SHA-256 Merkle tree
4
6
s
d
n
o
c
e
s
,
e
m
i
t
r
e
v
o
r
p
)
r
e
t
t
e
b
s
i
r
e
w
o
l
(
104
103
100
10
1
2
8
log2 M, number of leaves in Merkle tree
(h) P time: SHA-256 Merkle tree
4
6
104
103
100
10
1
0.1
s
d
n
o
c
e
s
,
e
m
i
t
r
e
ﬁ
i
r
e
v
)
r
e
t
t
e
b
s
i
r
e
w
o
l
(
2
8
log2 M, number of leaves in Merkle tree
(i) V time: SHA-256 Merkle tree
4
6
Hyrax-1/2
Hyrax-1/3
Hyrax-naive
BCCGP-sqrt
Bulletproofs
ZKB++
Ligero
libSTARK
Figure 2—Comparison of concrete costs between the baseline systems and Hyrax (§8.1). Hyrax-1/2 is Hyrax where P’s witness commitments have
size |w|1/2, and likewise Hyrax-1/3 has commitments of size |w|1/3 (§6.1). Hyrax-naive is Hyrax without our reﬁnements (§5–6). BCCGP-sqrt [24],
Bulletproofs [30], ZKB++ [32], Ligero [1], and libSTARK [11] are prior work. Where the BCCGP-sqrt, Bulletproofs, and libSTARK data are
truncated, their provers exceeded available RAM (§8.1). We evaluate ZKB++, Ligero, and libSTARK only on Merkle trees (we discuss in §8.3).
• Image scaling establishes that V’s input, a low-resolution
image, is a scaled version of a high-resolution image that P
knows. For scaling, we use Lanczos resampling [100], a standard
image transformation in which each output pixel is the result of
convolving a two-dimensional windowed sinc function [77] with
the input image. We evaluate on 4×, 16×, 64×, and 256× scaling,
varying the number of pixels.
• Ligero [1]: we report on the authors’ C++ implementation.
• ZKB++ [32]: we report runtime of the C implementation of
ZKBoo [47, 111]; per the ZKB++ authors, these systems have
similar performance [32, §3.2].7 We report extrapolated proof
sizes (which are linear with AC size) from ZKB++ [32, §3.2.1].
• libSTARK [11]: we report on the authors’ C++ implementa-
tion [67] and SHA-256 primitive [11, Fig. 4], which we adapt to
the Merkle tree benchmark (described below).
This implementation supports multi-threading, but we restrict
it to a single thread for consistency with the other baselines and
to focus on total prover work; we discuss in Section 8.3.
Benchmarks. We evaluate Hyrax, Hyrax-naive, BCCGP-sqrt,
and Bulletproofs on all benchmarks below, but Ligero, ZKB++,
and libSTARK only on Merkle trees; we discuss in Section 8.3.
• Matrix factoring (i.e., matrix multiplication) proves to V that
P knows two matrices whose product equals the public input.
We evaluate on 16×16, 32×32, 64×64, and 128×128 matrices,
and for each we vary N, the number of parallel executions.
7We run ZKBoo because there is no standalone ZKB++ implementation that can
run our benchmarks, only one tailored to the Picnic signature scheme [82].
936
This is a data-parallel computation where each sub-AC eval-
uates one pixel of the low-resolution image, but because of the
windowed sinc function, sub-ACs for adjacent pixels must share
inputs from the high-resolution image. To accommodate this, we
use a redistribution layer (RDL; §6.2).
• Merkle tree proves to V that P knows an assignment to
the leaves of a Merkle tree [72] corresponding to a root that V
provides [23].8 We use SHA-256 for the hash, varying the number
of leaves in the tree; we implement a data-parallel computation
in which each sub-computation is one invocation of SHA-256;
8In related applications (e.g., [107]), P convinces V that it knows a path from a
supplied Merkle root to a leaf. For these systems, a path of length 2M−1 has
essentially the same cost as an M-leaf Merkle tree. We evaluate the full-tree
benchmark because it demonstrates a wider range of computation sizes.
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:29:14 UTC from IEEE Xplore.  Restrictions apply. 
and we connect outputs at one level of the tree to inputs at the
next level using an RDL. For M leaves, the benchmark comprises
2M−1 sub-computations.
To implement SHA-256 eﬃciently in an arithmetic circuit,
we use an approach from prior work [12] for eﬃcient addition
modulo 232. We describe the approach, and an optimization that
may be of independent interest, in the full version [106, Appx. C].
Testbed. We run experiments on Amazon EC2 [3]. For Hyrax,
Hyrax-naive, Ligero, and ZKB++, we use c3.4xlarge instances
(30 GiB of RAM, 8 Xeon E5-2680v2 cores, 2 threads per core,
2.8 GHz). The BCCGP-sqrt, Bulletproofs, and libSTARK provers
are memory intensive (“P cost,” below), so for these we use
c3.8xlarge instances (60 GiB of RAM, 16 cores at 2.8 GHz).
Only RAM is relevant because we run all tests single threaded.
All testbed machines run Debian GNU/Linux 9 [38]. We run
all Python code using PyPy [86], a fast JIT-compiling interpreter.
Security parameters. For Hyrax, Hyrax-naive, BCCGP-sqrt,
and Bulletproofs, G is M191 [2], an elliptic curve over a base ﬁeld
modulo 2191−19 with a subgroup of order qG = 2188+293+ . . .,
giving ≈90-bit security. We run Ligero, ZKB++, and libSTARK
at 2−80 soundness error.9 ACs are over FqG and group elements
and scalars are 24 bytes, except that Ligero and libSTARK work
over smaller ﬁelds and ZKB++ works over Boolean circuits.
Method. For each benchmark, we construct a set of arithmetic
circuits (and, for image scaling and Merkle trees, RDLs) for a
range of computation sizes. We then run each system’s prover,
feeding the resulting proof into its veriﬁer. We record proof size,
and measure time using the high-resolution system clock.
For matrix factoring and image scaling, we set Hyrax’s com-
munication and V runtime to |w|1/2 (§6.1). For Merkle trees, we
optimize proof size versus V runtime by setting witness-related
communication to |w|1/3 and V runtime to |w|2/3; we explore the
eﬀect of this setting in Section 8.2.
Results. Figure 2 compares costs for the benchmarks. For matrix
factoring and image scaling we show only 64×64 matrices and
16× scaling, respectively; other values give similar results. For
an AC C, M denotes the number of multiplication gates.
Proof size (Figs. 2a, 2d, 2g):
• Hyrax has much larger proofs than Bulletproofs, both asymp-
totically and concretely.
• Hyrax’s proofs are smaller than BCCGP-sqrt’s when the cost
of the witness commitment dominates the cost of P’s mes-
sages in Gir++ (i.e., for large enough computations). Speciﬁcally,
Hyrax’s cost tracks |w|1/2 (|w|1/3 for Merkle trees; Fig. 2g), while
BCCGP-sqrt’s tracks M1/2. Thus, on matrix factoring (where
|w| (cid:18)M) Hyrax has much smaller proofs.
• Hyrax’s Merkle tree proofs are asymptotically and concretely
smaller than Ligero’s: the latter’s cost tracks |C|1/2.
• libSTARK’s proof size is asymptotically smaller than Hyrax’s,
but its proofs are concretely ≈5× larger at these problem sizes.
• ZKB++’s cost is linear in the number of AND gates, and
Hyrax-naive’s cost tracks |w|; both are large.
9ZKB++, Ligero, and libSTARK give statistical security in the random oracle
model, while the other systems make computational assumptions; this makes
direct comparison diﬃcult. We have chosen security parameters to give all
systems roughly equivalent cost to prove a false statement.
P cost (Figs. 2b, 2e, 2h):
• BCCGP-sqrt and Bulletproofs require a number of crypto-