### 优化后的文本

#### 图2—基准系统与Hyrax的成本比较 (§8.1)

- **Hyrax-1/2**：在Hyrax中，证明者的见证承诺大小为|w|1/2。
- **Hyrax-1/3**：在Hyrax中，证明者的见证承诺大小为|w|1/3（§6.1）。
- **Hyrax-naive**：没有采用我们改进措施的Hyrax版本（§5–6）。
- **BCCGP-sqrt [24]**、**Bulletproofs [30]**、**ZKB++ [32]**、**Ligero [1]** 和 **libSTARK [11]** 是之前的工作。其中，BCCGP-sqrt、Bulletproofs 和 libSTARK 的数据被截断，因为它们的证明者超出了可用RAM（§8.1）。我们仅对Merkle树评估ZKB++、Ligero和libSTARK（详细讨论见§8.3）。

### 图像缩放
图像缩放验证V的输入（一个低分辨率图像）是P知道的一个高分辨率图像的缩放版本。对于缩放，我们使用Lanczos重采样[100]，这是一种标准的图像变换方法，每个输出像素是通过将二维窗口化的sinc函数[77]与输入图像卷积得到的。我们评估了4×、16×、64×和256×的缩放比例，并改变了像素数量。

### 基准测试
我们对Hyrax、Hyrax-naive、BCCGP-sqrt和Bulletproofs进行了所有基准测试，但Ligero、ZKB++和libSTARK仅限于Merkle树测试；详细讨论见§8.3。

- **矩阵因式分解（即矩阵乘法）**：验证P知道两个矩阵，其乘积等于公开输入。我们评估了16×16、32×32、64×64和128×128的矩阵，并对每个矩阵改变并行执行的数量N。这是一个数据并行计算，每个子AC评估低分辨率图像中的一个像素。但由于窗口化的sinc函数，相邻像素的子AC必须共享高分辨率图像的输入。为了适应这一点，我们使用了一个重新分配层（RDL；§6.2）。

- **Merkle树**：验证P知道对应于V提供的根节点的Merkle树叶子节点的赋值[72][23]。我们使用SHA-256作为哈希函数，并改变树中的叶子节点数量。我们实现了一个数据并行计算，每个子计算是一次SHA-256调用。我们使用RDL连接树的一级输出到下一级输入。对于M个叶子节点，基准测试包括2M−1个子计算。

### 实现细节
为了在算术电路中高效实现SHA-256，我们采用了先前工作[12]中的有效模2^32加法方法。我们在完整版本[106, Appx. C]中描述了这种方法及其优化。

### 测试平台
我们在Amazon EC2上运行实验[3]。对于Hyrax、Hyrax-naive、Ligero和ZKB++，我们使用c3.4xlarge实例（30 GiB RAM，8个Xeon E5-2680v2核心，每核2个线程，2.8 GHz）。由于BCCGP-sqrt、Bulletproofs和libSTARK的证明者内存密集型（“P成本”，如下），我们使用c3.8xlarge实例（60 GiB RAM，16个核心，2.8 GHz）。所有测试都是单线程运行，因此只有RAM相关。所有测试机器运行Debian GNU/Linux 9[38]。我们使用PyPy[86]运行所有Python代码，这是一种快速的JIT编译解释器。

### 安全参数
对于Hyrax、Hyrax-naive、BCCGP-sqrt和Bulletproofs，G是M191[2]，一个基域模2^191−19的椭圆曲线，具有qG = 2^188+2^93+...的子群，提供约90位安全。我们以2^-80的声音错误运行Ligero、ZKB++和libSTARK[9]。算术电路是在FqG上的，组元素和标量是24字节，除了Ligero和libSTARK在较小的域上工作，而ZKB++在布尔电路上工作。

### 方法
对于每个基准测试，我们构建了一系列算术电路（以及图像缩放和Merkle树的RDL）来覆盖一系列计算规模。然后运行每个系统的证明者，将其生成的证明传递给验证者。我们记录证明大小，并使用高分辨率系统时钟测量时间。

对于矩阵因式分解和图像缩放，我们将Hyrax的通信和V运行时间设置为|w|^1/2（§6.1）。对于Merkle树，我们通过将见证相关的通信设置为|w|^1/3和V运行时间设置为|w|^2/3来优化证明大小与V运行时间的关系；我们在§8.2中探讨了这种设置的影响。

### 结果
图2比较了基准测试的成本。对于矩阵因式分解和图像缩放，我们仅展示了64×64矩阵和16×缩放的结果；其他值结果相似。对于算术电路C，M表示乘法门的数量。

- **证明大小（图2a、2d、2g）**：
  - Hyrax的证明比Bulletproofs大得多，无论是渐近还是具体情况下。
  - 当见证承诺的成本主导Gir++中P的消息成本时（即对于足够大的计算），Hyrax的证明比BCCGP-sqrt小。具体来说，Hyrax的成本跟踪|w|^1/2（对于Merkle树为|w|^1/3；图2g），而BCCGP-sqrt的成本跟踪M^1/2。因此，在矩阵因式分解中（其中|w| ≈ M），Hyrax的证明要小得多。
  - Hyrax的Merkle树证明在渐近和具体情况下都比Ligero的小：后者成本跟踪|C|^1/2。
  - libSTARK的证明大小在渐近情况下比Hyrax小，但在这些问题规模下，其证明实际上大约大5倍。
  - ZKB++的成本线性依赖于AND门的数量，而Hyrax-naive的成本跟踪|w|；两者都很高。

- **P成本（图2b、2e、2h）**：
  - BCCGP-sqrt和Bulletproofs需要大量的加密操作。

希望这些优化使文本更加清晰、连贯和专业。如果有任何进一步的需求或修改，请告诉我！