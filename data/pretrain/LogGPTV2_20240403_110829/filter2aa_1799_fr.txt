the Windows installation to do so, even in safe mode.
I 
System mage Recover Called Complete PC Restore or Automated System Recovery (ASR) in 
previous versions of Windows, this restores a Windows installation from a complete backup, not
just from a system restore point, which might not contain all damaged files and lost data.
I 
Startup Repair An automated tool that detects the most common Windows startup prob-
lems and automatically attempts to repair them.
I 
PC Reset A tool that removes all the applications and drivers that don’t belong to the stan-
dard Windows installation, restores all the settings to their default, and brings back Windows to
its original state after the installation. The user can choose to maintain all personal data files or
remove everything. In the latter case, Windows will be automatically reinstalled from scratch.
I 
Command Prompt For cases where troubleshooting or repair reuires manual intervention
(such as copying files from another drive or manipulating the BCD), you can use the command
prompt to have a full Windows shell that can launch almost any Windows program (as long as
the reuired dependencies can be satisfied)unlike the Recovery Console on earlier versions of
Windows, which only supported a limited set of specialized commands.
I 
Windows emory iagnostic Tool Performs memory diagnostic tests that check for signs
of faulty RAM. Faulty RAM can be the reason for random kernel and application crashes and
erratic system behavior.
When you boot a system from the Windows DVD or boot disks, Windows Setup gives you the choice 
of installing Windows or repairing an existing installation. If you choose to repair an installation, the 
system displays a screen similar to the modern boot menu (shown in Figure 12-15), which provides dif-
ferent choices.
The user can select to boot from another device, use a different OS (if correctly registered in the 
system BCD store), or choose a recovery tool. All the described recovery tools (except for the Memory 
Diagnostic Tool) are located in the Troubleshoot section.
The Windows setup application also installs WinRE to a recovery partition on a clean system installa-
tion. ou can access WinRE by keeping the Shift key pressed when rebooting the computer through the 
relative shutdown button located in the Start menu. If the system uses the Legacy Boot menu, WinRE 
can be started using the F8 key to access advanced boot options during Bootmgr execution. If you see 
the Repair our Computer option, your machine has a local hard disk copy. Additionally, if your system 
failed to boot as the result of damaged files or for any other reason that Winload can understand, it in-
structs Bootmgr to automatically start WinRE at the next reboot cycle. Instead of the dialog box shown 
in Figure 12-15, the recovery environment automatically launches the Startup Repair tool, shown in 
Figure 12-16.
846 
CHAPTER 12 Startup and shutdown
FIGURE 12-15 The Windows Recovery Environment startup screen.
FIGURE 12-16 The Startup Recovery tool.
At the end of the scan and repair cycle, the tool automatically attempts to fix any damage found, 
including replacing system files from the installation media. If the Startup Repair tool cannot automati-
cally fix the damage, you get a chance to try other methods, and the System Recovery Options dialog 
box is displayed again. 
The Windows Memory Diagnostics Tool can be launched from a working system or from a 
Command Prompt opened in WinRE using the mdsched.exe executable. The tool asks the user if they 
want to reboot the computer to run the test. If the system uses the Legacy Boot menu, the Memory 
Diagnostics Tool can be executed using the Tab key to navigate to the Tools section.
CHAPTER 12 Startup and shutdown
847
Safe mode
Perhaps the most common reason Windows systems become unbootable is that a device driver crashes 
the machine during the boot seuence. Because software or hardware configurations can change over 
time, latent bugs can surface in drivers at any time. Windows offers a way for an administrator to attack 
the problem booting in see. Safe mode is a boot configuration that consists of the minimal set 
of device drivers and services. By relying on only the drivers and services that are necessary for boot-
ing, Windows avoids loading third-party and other nonessential drivers that might crash.
There are different ways to enter safe mode
I 
Boot the system in WinRE and select Startup Settings in the Advanced options (see
Figure 12-17).
FIGURE 12-17 The Startup Settings screen, in which the user can select three different kinds of safe mode.
I 
In multi-boot environments, select hange eaults r hoose ther ptions in the modern
boot menu and go to the Troubleshoot section to select the Startup Settings button as in the
previous case.
I 
If your system uses the Legacy Boot menu, press the F8 key to enter the Advanced Boot
Options menu.
848 
CHAPTER 12 Startup and shutdown
ou typically choose from three safe-mode variations Safe mode, Safe mode with networking, and 
Safe mode with command prompt. Standard safe mode includes the minimum number of device driv-
ers and services necessary to boot successfully. Networking-enabled safe mode adds network drivers and 
services to the drivers and services that standard safe mode includes. Finally, safe mode with command 
prompt is identical to standard safe mode except that Windows runs the Command Prompt application 
(Cmd.exe) instead of Windows Explorer as the shell when the system enables GUI mode.
Windows includes a fourth safe modeDirectory Services Restore modewhich is different from 
the standard and networking-enabled safe modes. ou use Directory Services Restore mode to boot 
the system into a mode where the Active Directory service of a domain controller is offline and un-
opened. This allows you to perform repair operations on the database or restore it from backup media. 
All drivers and services, with the exception of the Active Directory service, load during a Directory 
Services Restore mode boot. In cases when you can’t log on to a system because of Active Directory 
database corruption, this mode enables you to repair the corruption.
Driver loading in safe mode
ow does Windows know which device drivers and services are part of standard and networking-
enabled safe mode The answer lies in the KLMSSTEMCurrentControlSetControlSafeBoot regis-
try key. This key contains the Minimal and Network subkeys. Each subkey contains more subkeys that 
specify the names of device drivers or services or of groups of drivers. For example, the ssplysys 
subkey identifies the Basic display device driver that the startup configuration includes. The Basic 
display driver provides basic graphics services for any PC-compatible display adapter. The system uses 
this driver as the safe-mode display driver in lieu of a driver that might take advantage of an adapter’s 
advanced hardware features but that might also prevent the system from booting. Each subkey under 
the SafeBoot key has a default value that describes what the subkey identifies the ssplysys 
subkey’s default value is Driver.
The Boot file system subkey has as its default value Driver Group. When developers design a device 
driver’s installation script (.inf file), they can specify that the device driver belongs to a driver group. The 
driver groups that a system defines are listed in the List value of the KLMSSTEMCurrentControlSet
ControlServiceGroupOrder key. A developer specifies a driver as a member of a group to indicate to 
Windows at what point during the boot process the driver should start. The ererupOrer key’s 
primary purpose is to define the order in which driver groups load some driver types must load either 
before or after other driver types. The Group value beneath a driver’s configuration registry key associ-
ates the driver with a group.
Driver and service configuration keys reside beneath KLMSSTEMCurrentControlSetServices. 
If you look under this key, you’ll find the ssply key for the basic display device driver, which you 
can see in the registry is a member of the Video group. Any file system drivers that Windows reuires 
for access to the Windows system drive are automatically loaded as if part of the Boot file system 
group. Other file system drivers are part of the File System group, which the standard and networking-
enabled safe-mode configurations also include.
When you boot into a safe-mode configuration, the boot loader (Winload) passes an associated switch 
to the kernel (Ntoskrnl.exe) as a command-line parameter, along with any switches you’ve specified in the 
CHAPTER 12 Startup and shutdown
849
BCD for the installation you’re booting. If you boot into any safe mode, Winload sets the safeboot BCD op-
tion with a value describing the type of safe mode you select. For standard safe mode, Winload sets n-
mal, and for networking-enabled safe mode, it adds ner. Winload adds nl and sets lernesell
for safe mode with command prompt and dsrepair for Directory Services Restore mode.
Note An exception exists regarding the drivers that safe mode excludes from a boot. 
Winload, rather than the kernel, loads any drivers with a Start value of 0 in their registry key, 
which specifies loading the drivers at boot time. Winload doesn’t check the SafeBoot registry 
key because it assumes that any driver with a Start value of 0 is reuired for the system to 
boot successfully. Because Winload doesn’t check the SafeBoot registry key to identify which 
drivers to load, Winload loads all boot-start drivers (and later Ntoskrnl starts them).
The Windows kernel scans the boot parameters in search of the safe-mode switches at the end of 
phase 1 of the boot process (senlnsr, see the Kernel initialization phase 1 section 
earlier in this chapter), and sets the internal variable nee to a value that reflects the switches 
it finds. During the ne function, the kernel writes the nee value to the registry 
value KLMSSTEMCurrentControlSetControlSafeBootOptionOptionValue so that user-mode 
components, such as the SCM, can determine what boot mode the system is in. In addition, if the system 
is booting in safe mode with command prompt, the kernel sets the KLMSSTEMCurrentControlSet 
Control SafeBoot OptionUseAlternateShell value to 1. The kernel records the parameters that Winload 
passes to it in the value KLMSSTEMCurrentControlSetControlSystemStartOptions.
When the I/O manager kernel subsystem loads device drivers that KLMSSTEMCurrentControlSet 
Services specifies, the I/O manager executes the function prer. When the Plug and Play manag-
er detects a new device and wants to dynamically load the device driver for the detected device, the Plug 
and Play manager executes the function pllreree. Both these functions call the function 
perer before they load the driver in uestion. perer checks the value 
of nee and determines whether the driver should load. For example, if the system boots in 
standard safe mode, perer looks for the driver’s group, if the driver has one, under the 
nl subkey. If perer finds the driver’s group listed, perer indicates 
to its caller that the driver can load. Otherwise, perer looks for the driver’s name under 
the nl subkey. If the driver’s name is listed as a subkey, the driver can load. If perer 
can’t find the driver group or driver name subkeys, the driver will not be loaded. If the system boots in 
networking-enabled safe mode, perer performs the searches on the er subkey. 
If the system doesn’t boot in safe mode, perer lets all drivers load.
Safe-mode-aware user programs
When the SCM user-mode component (which Services.exe implements) initializes during the 
boot process, the SCM checks the value of KLMSSTEMCurrentControlSet ControlSafeBoot
OptionOptionValue to determine whether the system is performing a safe-mode boot. If so, the SCM 
mirrors the actions of perer. Although the SCM processes the services listed under 
KLM SSTEMCurrentControlSetServices, it loads only services that the appropriate safe-mode 
850 
CHAPTER 12 Startup and shutdown
subkey specifies by name. ou can find more information on the SCM initialization process in the sec-
tion Services in Chapter 10.
Userinit, the component that initializes a user’s environment when the user logs on (SystemRoot
System32Userinit.exe), is another user-mode component that needs to know whether the system is 
booting in safe mode. It checks the value of KLMSSTEMCurrentControlSetControlSafeBoot 
OptionUseAlternateShell. If this value is set, Userinit runs the program specified as the user’s shell in 
the value KLMSSTEMCurrentControlSetControlSafeBootAlternateShell rather than executing 
Explorer.exe. Windows writes the program name Cmd.exe to the lerneell value during installa-
tion, making the Windows command prompt the default shell for safe mode with command prompt. 
Even though the command prompt is the shell, you can type Explorer.exe at the command prompt to 
start Windows Explorer, and you can run any other GUI program from the command prompt as well.
ow does an application determine whether the system is booting in safe mode By calling the 
Windows eyseersOO function. Batch scripts that need to perform certain 
operations when the system boots in safe mode look for the OOOO environment variable 
because the system defines this environment variable only when booting in safe mode.
Boot status file
Windows uses a susfile (SystemRootBootstat.dat) to record the fact that it has progressed 
through various stages of the system life cycle, including boot and shutdown. This allows the Boot 
Manager, Windows loader, and Startup Repair tool to detect abnormal shutdown or a failure to shut 
down cleanly and offer the user recovery and diagnostic boot options, like the Windows Recovery 
environment. This binary file contains information through which the system reports the success of the 
following phases of the system life cycle
I 
Boot
I 
Shutdown and hybrid shutdown
I 
Resume from hibernate or suspend
The boot status file also indicates whether a problem was detected the last time the user attempted 
to boot the operating system and the recovery options shown, indicating that the user has been made 
aware of the problem and taken action. Runtime Library APIs (Rtl) in Ntdll.dll contain the private inter-
faces that Windows uses to read from and write to the file. Like the BCD, it cannot be edited by users.
Conclusion
In this chapter, we examined the detailed steps involved in starting and shutting down Windows (both 
normally and in error cases). A lot of new security technologies have been designed and implemented 
with the goal of keeping the system safe even in its earlier startup stages and rendering it immune 
from a variety of external attacks. We examined the overall structure of Windows and the core system 
mechanisms that get the system going, keep it running, and eventually shut it down, even in a fast way. 
851
A P P E N D I X
Contents of Windows Internals, 
Seventh Edition, Part 1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xi
Chapter 1 
Concepts and tools 
1
Windows operating system versions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
Windows 10 and future Windows versions  . . . . . . . . . . . . . . . . . . . . . . . . 3
Windows 10 and OneCore . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
Foundation concepts and terms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
Windows API . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
Services, functions, and routines  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
Processes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
Threads . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
Jobs  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .20
Virtual memory  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
Kernel mode vs. user mode  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .23
Hypervisor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
Firmware . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .29
Terminal Services and multiple sessions . . . . . . . . . . . . . . . . . . . . . . . . . .29
Objects and handles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .30
Security . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
Registry . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .32
Unicode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .33
Digging into Windows internals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
Performance Monitor and Resource Monitor . . . . . . . . . . . . . . . . . . . . .36
Kernel debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .38
Windows Software Development Kit . . . . . . . . . . . . . . . . . . . . . . . . . . . . .43
Windows Driver Kit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .43
Sysinternals tools . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .44
Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .44
852 
Contents of Windows Internals, Part 1, 7th Edition
Chapter 2 
System architecture 
45
Requirements and design goals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .45
Operating system model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .46
Architecture overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
Portability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .50
Symmetric multiprocessing  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
Scalability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .53
Differences between client and server versions . . . . . . . . . . . . . . . . . . .54
Checked build . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
Virtualization-based security architecture overview . . . . . . . . . . . . . . . . . . . . 59
Key system components . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
Environment subsystems and subsystem DLLs . . . . . . . . . . . . . . . . . . . .62
Other subsystems  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .68
Executive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
Kernel . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75
Hardware abstraction layer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
Device drivers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .82
System processes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .88
Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .99
Chapter 3 
Processes and jobs 
101
Creating a process . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .101
CreateProcess* functions arguments. . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
Creating Windows modern processes . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
Creating other kinds of processes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .104
Process internals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
Protected processes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
Protected Process Light (PPL) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
Third-party PPL support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
Minimal and Pico processes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
Minimal processes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
Pico processes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
Trustlets (secure processes). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
Trustlet structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
Contents of Windows Internals, Part 1, 7th Edition
853
Trustlet policy metadata . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
Trustlet attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
System built-in Trustlets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
Trustlet identity  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126
Isolated user-mode services . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
Trustlet-accessible system calls . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
Flow of CreateProcess  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
Stage 1 Converting and validating parameters and flags . . . . . . . . . 131
Stage 2: Opening the image to be executed . . . . . . . . . . . . . . . . . . . . . 135
Stage 3: Creating the Windows executive process object . . . . . . . . . 138
Stage 4: Creating the initial thread and its stack and context . . . . .144
Stage 5 Performing Windows subsystem–specific initialization . . 146
Stage 6: Starting execution of the initial thread . . . . . . . . . . . . . . . . . . 148
Stage 7: Performing process initialization in the context  
    of the new process . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148
Terminating a process  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154
Image loader . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155
Early process initialization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
DLL name resolution and redirection . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
Loaded module database . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .164
Import parsing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168
Post-import process initialization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170
SwitchBack . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171
API Sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173
Jobs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176
Job limits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177
Working with a job . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178
Nested jobs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179
Windows containers (server silos) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183