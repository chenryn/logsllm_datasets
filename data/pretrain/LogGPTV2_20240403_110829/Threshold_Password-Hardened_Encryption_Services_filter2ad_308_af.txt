answer DecO oracle queries5 honestly. B however has knowledge
Â¯ğ‘˜0. B therefore simulate the answers to
of Â¯ğ‘˜0 for which Â¯ğ¾0 = ğº
DecO oracle queries during this time period as follows.
B computes the views of all parties honestly except for the values
ğ‘ˆ0, ğ‘‰0,ğ‘‡0 and ğ‘‡ â€²
0. For the ğ‘-th query, B sets ğ‘ˆ0 := ğº ğ›½ and ğ‘‰0 := ğºğ›¾ Â·
ğº ğ›½ Â¯ğ‘˜0 Â·ğ‘Œâˆ’1
0,0 . For other queries,B computes ğ‘ˆ0 and ğ‘‰0 honestly. For all
queries, to compute ğ‘‡0 and ğ‘‡ â€²
0, B runs the extractor of the NIZKPoK
to extract the discrete logarithm Ëœğ‘¢ and Ëœğ‘¢â€² such that Ëœğ‘ˆ = ğº Ëœğ‘¢ and
Ëœğ‘ˆ â€² = ğº Ëœğ‘¢â€². It then compute ğ‘‡0 := ğºğ›¼ Ëœğ‘¢ and ğ‘‡ â€²
Clearly, if (ğº, ğºğ›¼, ğº ğ›½, ğºğ›¾) is a DH tuple, B simulates Hybğ‘,3,ğ‘âˆ’1
perfectly. Else, if (ğº, ğºğ›¼, ğº ğ›½, ğºğ›¾) is a random tuple, B simulates
Hybâ€²
ğ‘,3,ğ‘
Case 2: 0 âˆˆ ğ¼. Without loss of generality, we can assume that
ğ¼ = {0, ğ‘–1, . . . , ğ‘–ğ‘¡âˆ’1} for some Ëœğ¼ := {ğ‘–1, . . . , ğ‘–ğ‘¡âˆ’1} âŠ† [ğ‘š]. In this case,
let ğ‘€ğ¼ be the following (ğ‘¡ âˆ’ 1)-by-ğ‘¡ matrix
ğ‘–ğ‘¡âˆ’1
1
...
ğ‘–ğ‘¡âˆ’1
ğ‘¡âˆ’1
perfectly. The claim then follows.
0 := ğºğ›¼ Ëœğ‘¢â€².
ğ‘–1
...
ğ‘–ğ‘¡âˆ’1
. . .
. . .
. . .
B receives a DDH instance (ğº, ğºğ›¼, ğº ğ›½, ğºğ›¾). When answering
the ğ‘¡-th honest key rotation query, B generates secret key shares
for the combined public key Â¯ğ¾â€²
0 := ğºğ›¼. For this, it samples a random
vector u := (ğ‘¢0, . . . , ğ‘¢ğ‘¡âˆ’1)ğ‘‡ â†$ Ker(ğ‘€ğ¼) in the kernel of ğ‘€ğ¼ , i.e.,
ğ‘€ğ¼ u = 0. It also samples a random vector v = (ğ‘£0, . . . , ğ‘£ğ‘¡âˆ’1)ğ‘‡ â†$ Zğ‘¡
ğ‘.
It sets Â¯ğ¾â€²
ğ‘— := ğºğ›¼ğ‘¢ ğ‘—+ğ‘£ğ‘— for all ğ‘— âˆˆ [0, ğ‘¡ âˆ’ 1]. For the corrupt parties
ğ‘– âˆˆ Ëœğ¼, B can compute secret keys ğ‘˜ğ‘– without knowledge of ğ›¼ as
ğ‘—=0 ğ‘£ ğ‘—ğ‘– ğ‘— (since ğ‘€ğ¼ u = 0), which are then
5B can answer DecChO oracle queries honestly since it does not need to return the
view of S, while the views of Rğ‘– for all ğ‘– âˆˆ [ğ‘š] can be computed without knowing
ğ‘˜0.
ğ‘—=0(ğ›¼ğ‘¢ ğ‘— + ğ‘£ ğ‘—)ğ‘– ğ‘— =ğ‘¡âˆ’1
ğ‘˜ğ‘– :=ğ‘¡âˆ’1
 .
ğ‘€ğ¼ :=
1
...
1
returned to A. Note that B does not know ğ‘˜ğ‘– :=ğ‘¡âˆ’1
ğ‘—=0(ğ›¼ğ‘¢ ğ‘— + ğ‘£ ğ‘—)ğ‘– ğ‘—
for the honest parties ğ‘– âˆ‰ Ëœğ¼ and hence, during the time between the
ğ‘¡-th and (ğ‘¡ + 1)-st honest key rotation, cannot answer DecO oracle
queries honestly. B can however simulate the views of all parties
in a DecO query using the DDH instance and the extractor of the
NIZKPoK as in case 1. We thus arrive at a similar conclusion that, if
(ğº, ğºğ›¼, ğº ğ›½, ğºğ›¾) is a DH tuple, B simulates Hybğ‘,3,ğ‘âˆ’1 perfectly and,
if (ğº, ğºğ›¼, ğº ğ›½, ğºğ›¾) is a random tuple, B simulates Hybâ€²
perfectly.
The claim then follows.
ğ‘,3,ğ‘
3.3.2
From Hyb0,3,ğ‘„Dec to Hyb1,3,ğ‘„Dec. We show that
= 1(cid:105) âˆ’ Pr(cid:104)
= 1(cid:105)(cid:12)(cid:12)(cid:12) â‰¤ negl(ğœ†) .
(cid:12)(cid:12)(cid:12) Pr(cid:104)
Hyb0,3,ğ‘„Dec
Hyb1,3,ğ‘„Dec
assuming the CCA-security of SKE and DDH.
Suppose not, we construct an adversary B against the CCA-
security of SKE or DDH as follows. Without loss of generality, let
the ğ‘¡-th honest key rotation query be the latest one before the
ChOğ‘ oracle query. Let ğ¼ be the set of corrupt parties requested by
A during this key rotation query. We consider two cases.
ğ‘
Case 1: 0 âˆ‰ ğ¼. Without loss of generality, we can assume that ğ¼ =
[ğ‘š]. In this case, note that S remains uncorrupt when answering
the ChOğ‘ oracle query, as well as the last (say ğ‘¡â€²-th, potentially
malicious) key rotation query. For the ğ‘¡â€²-th key rotation query,
B simulates most secret key components honestly, except that it
sets ğ‘ 0 := ğœ–. To generate the challenge ciphertext, B computes
ğ¶0 := ğ»0(pwâˆ—, ğ‘›âˆ—)ğ»0(ğ‘›âˆ—)Â¯ğ‘ 0 and ğ¶1,ğ‘ := ğ»1(pwâˆ—, ğ‘›âˆ—)ğ»1(ğ‘›âˆ—)Â¯ğ‘ 0ğ‘€âˆ—
by
interacting with the possibly malicious rate-limiters. It then submits
(ğ¶0, ğ¶1,0) and (ğ¶0, ğ¶1,1) to the challenge oracle of SKE. During the
time between the ğ‘¡â€²-th and the (ğ‘¡â€² + 1)-st key rotation queries,
whenever SKE.Enc(ğ‘ 0, Â·) is supposed to be executed (except when
answering the ChOğ‘ oracle query), B delegates the computation
to the encryption oracle of SKE. B makes a random guess ğ‘â€² of the
random bit used by the SKE challenger. Whenever SKE.Dec(ğ‘ 0, Â·) is
supposed to be executed on the challenge ciphertext ğ¶âˆ—, the return
value is replaced by (ğ¶0, ğ¶1,ğ‘â€²). When it is supposed to be executed
on other non-challenge ciphertext, B delegates the computation to
the decryption oracle of SKE. Clearly,when the guess ğ‘â€² is correct,B
perfectly simulates the environments of Hyb0,3,ğ‘„Dec
or Hyb1,3,ğ‘„Dec
,
depending on the secret bit chosen by the SKE challenger.
Case 2: 0 âˆˆ ğ¼. We define an intermediate hybrid Hybâ€²
ğ‘,3,ğ‘„Dec
, except that when generat-
which is mostly identical to Hyb0,3,ğ‘„Dec
ing the challenge ciphertext,the experiment samples (ğ¶0, ğ¶1) â†$ G2
). Clearly Hybâ€²
uniformly at random (independent of ğ‘€âˆ—
and
Hybâ€²
are functionally equivalent. It therefore suffices to show
0,3,ğ‘„Dec
ğ‘
= 1(cid:105) âˆ’ Pr(cid:104)
Hybğ‘,3,ğ‘„Dec
= 1(cid:105)(cid:12)(cid:12)(cid:12) â‰¤ negl(ğœ†) .
1,3,ğ‘„Dec
(cid:12)(cid:12)(cid:12) Pr(cid:104)
Hybâ€²
ğ‘,3,ğ‘„Dec
Without loss of generality,we can assume that ğ¼ = {0, ğ‘–1, . . . , ğ‘–ğ‘¡âˆ’1}
for some Ëœğ¼ := {ğ‘–1, . . . , ğ‘–ğ‘¡âˆ’1} âŠ† [ğ‘š]. In this case, we will make use of
the matrix ğ‘€ğ¼ defined above, and simulate the secret key compo-
nents ğ‘ ğ‘– for ğ‘– âˆˆ Ëœğ¼ in a similar fashion. As before, although B does not
possess the knowledge of ğ‘ ğ‘– (but only ğºğ‘ ğ‘– ) for ğ‘– âˆ‰ Ëœğ¼, encryption and
10
decryption can be simulated given a DDH instance and by program-
ming the random oracles6. If B is given a DH instance, it simulates
perfectly. Otherwise, B is given a random instance, and
Hybğ‘,3,ğ‘„Dec
it simulates Hybâ€²
â–¡
perfectly. The claim then follows.
ğ‘,3,ğ‘„Dec
Theorem 3.2 (Soundness). If the discrete logarithm as-
sumption holds with respect to GGen, then the (ğ‘¡, ğ‘š)-PHE scheme
constructed above is sound in the random oracle model7.
Proof. Firstly,we recall that the well known generalized Schnorr
protocol [17] (recalled in Figure 7) is a statistical proof of knowl-
edge in the random oracle model. We therefore do not need extra
assumptions on the NIZKPoK.
We give a high level idea of why an adversary against sound-
ness cannot exist in the random oracle model, under the discrete
logarithm assumption. Suppose such an adversary A exists, we con-
sider the following experiment. First, it runs A as in the soundness
experiment until A outputs the indices (ğ‘–, ğ‘—). It then retrieves
(sk0, ğ‘›, ğ¶, pw, ğ‘€) := Queries[ğ‘–] and
0, ğ‘›â€², ğ¶â€², pwâ€², ğ‘€â€²) := Queries[ ğ‘—].
(skâ€²
With non-negligible probability, the condition ğ‘0 âˆ§ ğ‘1 âˆ§ (ğ‘2 âˆ¨ ğ‘3)
is satisfied. Since ğ‘0 âˆ§ ğ‘1 is satisfied, we have
0, ğ¶â€²)âˆ§
ğ‘€ â‰  âŠ¥ âˆ§ ğ‘€â€² â‰  âŠ¥.
(sk0, ğ¶) = (skâ€²
By the second condition, we can deduce that regardless of whether
these tuples were created during an encryption or decryption oracle
query, the server did not abort the protocol. Thus, we must have
KVf(0, sk0) = 1, which means sk0 is of the form sk0 = (ğ‘ 0, ğ‘˜0,
ğ¾0, { Â¯ğ‘† ğ‘— , Â¯ğ¾ğ‘—}ğ‘¡âˆ’1
ğ‘—=0) where ğ¾0 = ğºğ‘˜0. In the following, let (ğ¶0, ğ¶1) â†
SKE.Dec(ğ‘ 0, ğ¶).
Suppose (sk0, ğ‘›, ğ¶, pw, ğ‘€) is created during an encryption oracle
query. Then we must have ğ‘€ â‰  ğœ–. By running the extractor E,
whose existence is guaranteed by the proof of knowledge property
of the NIZKPoK, on the proofs generated by the (possibly malicious)
rate-limiters, the reduction can extract Â¯ğ‘ 0 such that
ğ¶0 = ğ»0(pw, ğ‘›)ğ»0(ğ‘›)Â¯ğ‘ 0
ğ¶1 = ğ»1(pw, ğ‘›)ğ»1(ğ‘›)Â¯ğ‘ 0ğ‘€.
(1)
(2)
Similarly, if (skâ€²
0, ğ‘›â€², ğ¶â€², pwâ€², ğ‘€â€²) is created during an encryption
oracle query, then ğ‘€â€² â‰  ğœ–, and the reduction can extract Â¯ğ‘ 0 with
ğ¶0 = ğ»0(pwâ€², ğ‘›â€²)ğ»0(ğ‘›â€²)Â¯ğ‘ 0
(3)
ğ¶1 = ğ»1(pwâ€², ğ‘›â€²)ğ»1(ğ‘›â€²)Â¯ğ‘ 0ğ‘€â€².
(4)
Suppose (sk0, ğ‘›, ğ¶, pw, ğ‘€) is created during a decryption oracle
query, we consider two cases: 1) ğ‘€ â‰  ğœ–, and 2) ğ‘€ = ğœ–. In the first
case, the extraction process is slightly more complicated than when
the tuple is created via encryption. Nevertheless, the experiment
6e.g., to compute ğ»0(ğ‘›)ğ‘ ğ‘– and ğ»1(ğ‘›)ğ‘ ğ‘– for ğ‘› â‰  ğ‘›âˆ—, B first samples ğ‘¥0 and ğ‘¥1 and
programs ğ»0(ğ‘›) := ğºğ‘¥0 and ğ»1(ğ‘›) := ğºğ‘¥1 . It can then compute ğ»0(ğ‘›)ğ‘ ğ‘– = ğºğ‘¥0ğ‘ ğ‘–
and ğ»1(ğ‘›)ğ‘ ğ‘– = ğºğ‘¥1ğ‘ ğ‘– . For ğ‘› = ğ‘›âˆ—, B programs the random oracle similarly except
that ğºğ‘¥0 and ğºğ‘¥1 are derived from the DDH instance.
7There is an error in [12], where the strong soundness property is claimed to hold
assuming only the soundness of the NIZKPoK, which in turn holds unconditionally in
the random oracle model. In fact, they would also need to rely on the discrete logarithm
assumption.
can also extract Â¯ğ‘ 0 so that it satisfies the above relations. In the
second case, we can deduce that
ğ¶0 â‰  ğ»0(pw, ğ‘›)ğ»0(ğ‘›)Â¯ğ‘ 0 .
(5)
Similar conclusion can be made if (skâ€²
0, ğ‘›â€², ğ¶â€², pwâ€², ğ‘€â€²) is created
during a decryption oracle query.
Next, we examine the conditions ğ‘2 and ğ‘3, where at least one of
them must be satisfied. Suppose ğ‘2 is satisfied, we have ((ğ‘›, pw) =
(ğ‘›â€², pwâ€²)) âˆ§ (ğ‘€ â‰  ğ‘€â€²). There are two possibilities.
(1) ğ‘€ = ğœ– and ğ‘€â€² â‰  ğœ– (or ğ‘€ â‰  ğœ– and ğ‘€â€² = ğœ–): Since ğ‘€ = ğœ–, the
tuple must have been produced via decryption, and by Equa-
tion (5) we have ğ¶0 â‰  ğ»0(pw, ğ‘›)ğ»0(ğ‘›)Â¯ğ‘ 0. However, since
ğ‘€â€² â‰  ğœ–, by Equation (3) we have ğ¶0 = ğ»0(pw, ğ‘›)ğ»0(ğ‘›)Â¯ğ‘ 0
(note that (ğ‘›, pw) = (ğ‘›â€², pwâ€²)) which is a contradicton.
(2) ğ‘€ â‰  ğœ– and ğ‘€â€² â‰  ğœ–: From Equations (2) and (4) we can deduce
that ğ‘€ = ğ‘€â€², which is a contradiction.
Suppose ğ‘3 is satisfied, we have ((ğ‘›, pw) â‰  (ğ‘›â€², pwâ€²))âˆ§(ğ‘€, ğ‘€â€² âˆˆ
M). Since ğ‘€, ğ‘€â€² âˆˆ M, we must have ğ‘€ â‰  ğœ– and ğ‘€â€² â‰  ğœ–. Then,
from Equations (1) and (3), we can deduce
ğ»0(pw, ğ‘›)ğ»0(ğ‘›)Â¯ğ‘ 0ğ»0(pwâ€², ğ‘›â€²)âˆ’1ğ»0(ğ‘›â€²)âˆ’Â¯ğ‘ 0 = ğ¼
However, since (ğ‘›, pw) â‰  (ğ‘›â€², pwâ€²), ğ»0(pw, ğ‘›) and ğ»0(pwâ€², ğ‘›â€²) are
independent random elements, we obtain a non-trivial discrete
logarithm representation of the identity element, which violates
the discrete logarithm assumption.
â–¡
4 EVALUATION
We have implemented our construction in Python using the Charm
framework [2]. For interactions we use the falcon REST frame-
work (for the rate-limiter), Python requests (for the server), and
HTTP keep-alive. As in [12] we instantiate the hash functions with
SHA-256 and the group with NIST P-256. This enables meaningful
comparison between our results and those of [12].
All our results are measured in a LAN and a more realistic WAN
setting (between North California and Oregon; ping 21ms) for dif-
ferent choices of the threshold ğ‘¡ and number of rate-limiters ğ‘š. In-
teractions are made by POST calls. The rate-limiters use in-memory
dictionaries for storing the states. The server is sending out multiple
requests at once and waits for ğ‘¡ rate-limiters to respond.
4.1 Results
Latency. We measured the latency of encryption (resp. decryp-
tion) of the (ğ‘¡, ğ‘š)-PHE scheme, i.e., the time needed to complete
an encryption (resp. decryption) protocol execution. For ğ‘¡ = ğ‘š = 1,
Table 1 shows that the average latency for encryption is 8.431 ms
(LAN) and 94.911 ms (WAN), and that for decryption is 18.763 ms
(LAN) and 147.970 ms (WAN), where the averages are taken over
1000 executions. Further experiments show that the threshold ğ‘¡
and total number of rate-limiters ğ‘š do not affect the latency sig-
nificantly, except for a minor communication overhead, because
the protocol will continue as soon as ğ‘¡ parties, who run in parallel,
have answered.
Our scheme has a higher latency by an estimated factor of two
for encryption and a factor slightly higher than three for decryption
(see Table 1), mainly due to the additional communication rounds
Scheme
[12] - Encrypt
[12] - Decrypt
(ğ‘¡, ğ‘š)-PHE in LAN - Encrypt
(ğ‘¡, ğ‘š)-PHE in LAN - Decrypt
(ğ‘¡, ğ‘š)-PHE in WAN - Encrypt
(ğ‘¡, ğ‘š)-PHE in WAN - Decrypt
Latency in ms
4.501
4.959
8.431
18.763
94.911
147.970
Table 1: Latency Comparison
(2x for encryption and 3x for the decryption protocol) compared to
the PHE in [12].
Throughput. To estimate the computational resources needed, we
also measured the throughput (maximum number of encryption and
decryption requests per time) of (ğ‘¡, ğ‘š)-PHE for different thresholds
ğ‘¡ and number of rate-limiters ğ‘š. For various values of (ğ‘¡, ğ‘š) with ğ‘¡ =
ğ‘š, Figure 6 shows the inverse of the throughput (i.e., amortized time
per request) of the server against the threshold of ğ‘¡. Likewise, we
report the inverse of the throughput of the rate-limiters in Figure 6.
Points on the figure are averages over single-, dual, quad- and octa-
core performances, with 1000 executions each. The raw data is
reported in Table 2. For generating amortized benchmarking results,
we fixed the time for network traffic and randomness generation, as
generating large numbers of random values may cause odd runtime
artifacts. However, this is not a restriction, because generating those
values can be done via pseudorandom functions (e.g., SHA2 or AES
with hardware acceleration). Figure 6 shows that the amortized time