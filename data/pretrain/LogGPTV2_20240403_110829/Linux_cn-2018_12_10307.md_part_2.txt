	+ `ENV_DYING`： 表示那个 `Env` 结构所表示的是一个僵尸环境。一个僵尸环境将在下一次被内核捕获后被释放。我们在实验 4 之前不会去使用这个标志。
* `env_pgdir`： 这个变量持有这个环境的内核虚拟地址的页目录。
就像一个 Unix 进程一样，一个 JOS 环境耦合了“线程”和“地址空间”的概念。线程主要由保存的寄存器来定义（`env_tf` 字段），而地址空间由页目录和 `env_pgdir` 所指向的页表所定义。为运行一个环境，内核必须使用保存的寄存器值和相关的地址空间去设置 CPU。
我们的 `struct Env` 与 xv6 中的 `struct proc` 类似。它们都在一个 `Trapframe` 结构中持有环境（即进程）的用户模式寄存器状态。在 JOS 中，单个的环境并不能像 xv6 中的进程那样拥有它们自己的内核栈。在这里，内核中任意时间只能有一个 JOS 环境处于活动中，因此，JOS 仅需要一个单个的内核栈。
#### 为环境分配数组
在实验 2 的 `mem_init()` 中，你为数组 `pages[]` 分配了内存，它是内核用于对页面分配与否的状态进行跟踪的一个表。你现在将需要去修改 `mem_init()`，以便于后面使用它分配一个与结构 `Env` 类似的数组，这个数组被称为 `envs`。
> 
> **练习 1**、修改在 `kern/pmap.c` 中的 `mem_init()`，以用于去分配和映射 `envs` 数组。这个数组完全由 `Env` 结构分配的实例 `NENV` 组成，就像你分配的 `pages` 数组一样。与 `pages` 数组一样，由内存支持的数组 `envs` 也将在 `UENVS`（它的定义在 `inc/memlayout.h` 文件中)中映射用户只读的内存，以便于用户进程能够从这个数组中读取。
> 
> 
> 
你应该去运行你的代码，并确保 `check_kern_pgdir()` 是没有问题的。
#### 创建和运行环境
现在，你将在 `kern/env.c` 中写一些必需的代码去运行一个用户环境。因为我们并没有做一个文件系统，因此，我们将设置内核去加载一个嵌入到内核中的静态的二进制镜像。JOS 内核以一个 ELF 可运行镜像的方式将这个二进制镜像嵌入到内核中。
在实验 3 中，`GNUmakefile` 将在 `obj/user/` 目录中生成一些二进制镜像。如果你看到 `kern/Makefrag`，你将注意到一些奇怪的的东西，它们“链接”这些二进制直接进入到内核中运行，就像 `.o` 文件一样。在链接器命令行上的 `-b binary` 选项，将因此把它们链接为“原生的”不解析的二进制文件，而不是由编译器产生的普通的 `.o` 文件。（就链接器而言，这些文件压根就不是 ELF 镜像文件 —— 它们可以是任何东西，比如，一个文本文件或图片！）如果你在内核构建之后查看 `obj/kern/kernel.sym` ，你将会注意到链接器很奇怪的生成了一些有趣的、命名很费解的符号，比如像 `_binary_obj_user_hello_start`、`_binary_obj_user_hello_end`、以及 `_binary_obj_user_hello_size`。链接器通过改编二进制文件的命令来生成这些符号；这种符号为普通内核代码使用一种引入嵌入式二进制文件的方法。
在 `kern/init.c` 的 `i386_init()` 中，你将写一些代码在环境中运行这些二进制镜像中的一种。但是，设置用户环境的关键函数还没有实现；将需要你去完成它们。
> 
> **练习 2**、在文件 `env.c` 中，写完以下函数的代码：
> 
> 
> * `env_init()`
> 
> 
> 初始化 `envs` 数组中所有的 `Env` 结构，然后把它们添加到 `env_free_list` 中。也称为 `env_init_percpu`，它通过配置硬件，在硬件上为 level 0（内核）权限和 level 3（用户）权限使用单独的段。
> * `env_setup_vm()`
> 
> 
> 为一个新环境分配一个页目录，并初始化新环境的地址空间的内核部分。
> * `region_alloc()`
> 
> 
> 为一个新环境分配和映射物理内存
> * `load_icode()`
> 
> 
> 你将需要去解析一个 ELF 二进制镜像，就像引导加载器那样，然后加载它的内容到一个新环境的用户地址空间中。
> * `env_create()`
> 
> 
> 使用 `env_alloc` 去分配一个环境，并调用 `load_icode` 去加载一个 ELF 二进制
> * `env_run()`
> 
> 
> 在用户模式中开始运行一个给定的环境
> 
> 
> 在你写这些函数时，你可能会发现新的 cprintf 动词 `%e` 非常有用 – 它可以输出一个错误代码的相关描述。比如：
> 
> 
> 
> ```
>     r = -E_NO_MEM;
>     panic("env_alloc: %e", r);
> ```
> 
> 中 panic 将输出消息 env\_alloc: out of memory。
> 
> 
> 
下面是用户代码相关的调用图。确保你理解了每一步的用途。
* `start` (`kern/entry.S`)
* `i386_init` (`kern/init.c`)
	+ `cons_init`
	+ `mem_init`
	+ `env_init`
	+ `trap_init`（到目前为止还未完成）
	+ `env_create`
	+ `env_run`
		- `env_pop_tf`
在完成以上函数后，你应该去编译内核并在 QEMU 下运行它。如果一切正常，你的系统将进入到用户空间并运行二进制的 `hello` ，直到使用 `int` 指令生成一个系统调用为止。在那个时刻将存在一个问题，因为 JOS 尚未设置硬件去允许从用户空间到内核空间的各种转换。当 CPU 发现没有系统调用中断的服务程序时，它将生成一个一般保护异常，找到那个异常并去处理它，还将生成一个双重故障异常，同样也找到它并处理它，并且最后会出现所谓的“三重故障异常”。通常情况下，你将随后看到 CPU 复位以及系统重引导。虽然对于传统的应用程序（在 [这篇博客文章](http://blogs.msdn.com/larryosterman/archive/2005/02/08/369243.aspx) 中解释了原因）这是重大的问题，但是对于内核开发来说，这是一个痛苦的过程，因此，在打了 6.828 补丁的 QEMU 上，你将可以看到转储的寄存器内容和一个“三重故障”的信息。
我们马上就会去处理这些问题，但是现在，我们可以使用调试器去检查我们是否进入了用户模式。使用 `make qemu-gdb` 并在 `env_pop_tf` 处设置一个 GDB 断点，它是你进入用户模式之前到达的最后一个函数。使用 `si` 单步进入这个函数；处理器将在 `iret` 指令之后进入用户模式。然后你将会看到在用户环境运行的第一个指令，它将是在 `lib/entry.S` 中的标签 `start` 的第一个指令 `cmpl`。现在，在 `hello` 中的 `sys_cputs()` 的 `int $0x30` 处使用 `b *0x...`（关于用户空间的地址，请查看 `obj/user/hello.asm` ）设置断点。这个指令 `int` 是系统调用去显示一个字符到控制台。如果到 `int` 还没有运行，那么可能在你的地址空间设置或程序加载代码时发生了错误；返回去找到问题并解决后重新运行。
#### 处理中断和异常
到目前为止，在用户空间中的第一个系统调用指令 `int $0x30` 已正式寿终正寝了：一旦处理器进入用户模式，将无法返回。因此，现在，你需要去实现基本的异常和系统调用服务程序，因为那样才有可能让内核从用户模式代码中恢复对处理器的控制。你所做的第一件事情就是彻底地掌握 x86 的中断和异常机制的使用。
> 
> **练习 3**、如果你对中断和异常机制不熟悉的话，阅读 80386 程序员手册的第 9 章（或 IA-32 开发者手册的第 5 章）。
> 
> 
> 
在这个实验中，对于中断、异常、以其它类似的东西，我们将遵循 Intel 的术语习惯。由于如 异常   exception 、 陷阱   trap 、 中断   interrupt 、 故障   fault 和 中止   abort 这些术语在不同的架构和操作系统上并没有一个统一的标准，我们经常在特定的架构下（如 x86）并不去考虑它们之间的细微差别。当你在本实验以外的地方看到这些术语时，它们的含义可能有细微的差别。
#### 受保护的控制转移基础
异常和中断都是“受保护的控制转移”，它将导致处理器从用户模式切换到内核模式（`CPL=0`）而不会让用户模式的代码干扰到内核的其它函数或其它的环境。在 Intel 的术语中，一个中断就是一个“受保护的控制转移”，它是由于处理器以外的外部异步事件所引发的，比如外部设备 I/O 活动通知。而异常正好与之相反，它是由当前正在运行的代码所引发的同步的、受保护的控制转移，比如由于发生了一个除零错误或对无效内存的访问。
为了确保这些受保护的控制转移是真正地受到保护，处理器的中断/异常机制设计是：当中断/异常发生时，当前运行的代码不能随意选择进入内核的位置和方式。而是，处理器在确保内核能够严格控制的条件下才能进入内核。在 x86 上，有两种机制协同来提供这种保护：
1. **中断描述符表** 处理器确保中断和异常仅能够导致内核进入几个特定的、由内核本身定义好的、明确的入口点，而不是去运行中断或异常发生时的代码。
x86 允许最多有 256 个不同的中断或异常入口点去进入内核，每个入口点都使用一个不同的中断向量。一个向量是一个介于 0 和 255 之间的数字。一个中断向量是由中断源确定的：不同的设备、错误条件、以及应用程序去请求内核使用不同的向量生成中断。CPU 使用向量作为进入处理器的中断描述符表（IDT）的索引，它是内核设置的内核私有内存，GDT 也是。从这个表中的适当的条目中，处理器将加载：
	* 将值加载到指令指针寄存器（EIP），指向内核代码设计好的，用于处理这种异常的服务程序。
	* 将值加载到代码段寄存器（CS），它包含运行权限为 0—1 级别的、要运行的异常服务程序。（在 JOS 中，所有的异常处理程序都运行在内核模式中，运行级别为 0。）
2. **任务状态描述符表** 处理器在中断或异常发生时，需要一个地方去保存旧的处理器状态，比如，处理器在调用异常服务程序之前的 `EIP` 和 `CS` 的原始值，这样那个异常服务程序就能够稍后通过还原旧的状态来回到中断发生时的代码位置。但是对于已保存的处理器的旧状态必须被保护起来，不能被无权限的用户模式代码访问；否则代码中的 bug 或恶意用户代码将危及内核。
基于这个原因，当一个 x86 处理器产生一个中断或陷阱时，将导致权限级别的变更，从用户模式转换到内核模式，它也将导致在内核的内存中发生栈切换。有一个被称为 TSS 的任务状态描述符表规定段描述符和这个栈所处的地址。处理器在这个新栈上推送 `SS`、`ESP`、`EFLAGS`、`CS`、`EIP`、以及一个可选的错误代码。然后它从中断描述符上加载 `CS` 和 `EIP` 的值，然后设置 `ESP` 和 `SS` 去指向新的栈。
虽然 TSS 很大并且默默地为各种用途服务，但是 JOS 仅用它去定义当从用户模式到内核模式的转移发生时，处理器即将切换过去的内核栈。因为在 JOS 中的“内核模式”仅运行在 x86 的运行级别 0 权限上，当进入内核模式时，处理器使用 TSS 上的 `ESP0` 和 `SS0` 字段去定义内核栈。JOS 并不去使用 TSS 的任何其它字段。
#### 异常和中断的类型
所有的 x86 处理器上的同步异常都能够产生一个内部使用的、介于 0 到 31 之间的中断向量，因此它映射到 IDT 就是条目 0-31。例如，一个页故障总是通过向量 14 引发一个异常。大于 31 的中断向量仅用于软件中断，它由 `int` 指令生成，或异步硬件中断，当需要时，它们由外部设备产生。
在这一节中，我们将扩展 JOS 去处理向量为 0-31 之间的、内部产生的 x86 异常。在下一节中，我们将完成 JOS 的 48（0x30）号软件中断向量，JOS 将（随意选择的）使用它作为系统调用中断向量。在实验 4 中，我们将扩展 JOS 去处理外部生成的硬件中断，比如时钟中断。
#### 一个示例
我们把这些片断综合到一起，通过一个示例来巩固一下。我们假设处理器在用户环境下运行代码，遇到一个除零问题。
1. 处理器去切换到由 TSS 中的 `SS0` 和 `ESP0` 定义的栈，在 JOS 中，它们各自保存着值 `GD_KD` 和 `KSTACKTOP`。
2. 处理器在内核栈上推入异常参数，起始地址为 `KSTACKTOP`：
```
+--------------------+ KSTACKTOP             
| 0x00000 | old SS   |     " - 4
|      old ESP       |     " - 8
|     old EFLAGS     |     " - 12
| 0x00000 | old CS   |     " - 16
|      old EIP       |     " - 20 <---- ESP 
+--------------------+
```
3. 由于我们要处理一个除零错误，它将在 x86 上产生一个中断向量 0，处理器读取 IDT 的条目 0，然后设置 `CS:EIP` 去指向由条目描述的处理函数。
4. 处理服务程序函数将接管控制权并处理异常，例如中止用户环境。
对于某些类型的 x86 异常，除了以上的五个“标准的”寄存器外，处理器还推入另一个包含错误代码的寄存器值到栈中。页故障异常，向量号为 14，就是一个重要的示例。查看 80386 手册去确定哪些异常推入一个错误代码，以及错误代码在那个案例中的意义。当处理器推入一个错误代码后，当从用户模式中进入内核模式，异常处理服务程序开始时的栈看起来应该如下所示：