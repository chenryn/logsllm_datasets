        RPC_C_AUTHZ_NONE,             
// RPC_C_AUTHZ_xxx  
        NULL,                            
// Server principal name  
        RPC_C_AUTHN_LEVEL_CALL,        
// RPC_C_AUTHN_LEVEL_xxx  
        RPC_C_IMP_LEVEL_IMPERSONATE,  
// RPC_C_IMP_LEVEL_xxx 
        NULL,                             
// client identity 
        EOAC_NONE                         // proxy capabilities  
    ); 
执行应用逻辑
执行应用逻辑
执行应用逻辑
执行应用逻辑 
在成功连接 WMI 服务并完成代理安全设置后，便可以调用 IWbemServices 接口中的
方法来执行应用程序自身的逻辑了。 比如通过 CreateInstanceEnum 方法创建一个实例枚
举（IEnumWbemClassObject）对象，然后枚举出某个类的所有实例。再比如，可以通过
GetObject 方法取得命名空间中的类对象，然后创建类的实例（SpawnInstance），读取类的
属性，执行类的方法（ExecMethod）等。概而言之，就是利用 WMI 服务暴露出的 COM
接口来访问和操作 WMI 对象。 
WMI SDK（现在是 Platform SDK 的一部分）的 Samples\Sysmgmt\VC 目录下给出了
几个使用 C++编写的 WMI 应用程序的例子，MSDN 文档中也给出了一些例子，大家可以
参考，在此从略。 
清理工作
清理工作
清理工作
清理工作 
包括释放创建的对象（Release），调用 CoUninitialize 清理 COM/DCOM 库所分配的资
源等。 
31.5.2  WMI 脚本 
使用 WMI 服务的更简单和更常用方法是编写脚本。因为 Windows 提供了可以访问
WMI 的 ActiveX 控件，所以任何支持 ActiveX 控件的脚本语言都可以使用 WMI 服务，比
《软件调试》补编 
- 99 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
如 VBScript、Microsoft Jscript 和 Perl。可以执行 WMI 脚本的常见环境（解释器）有 Windows 
Script Host (WSH)、ASP（Active Server Pages）网页（IIS 服务器）和 IE 浏览器等。 
下面先举几个例子让大家认识一下 WMI 脚本。将清单 31-10 所示的使用 VBScript 编
写的脚本保存为一个 process_list.vbs 文件。然后在命令行下执行 cscript process_list.vbs，
便可以列出当前系统中所运行的所有进程。 
清单 31-10 process_list.vbs 
for each Process in GetObject("winmgmts:{impersonationLevel=impersonate}")._ 
 InstancesOf("Win32_process") 
   WScript.Echo Process.Name 
Next 
每次执行清单 31-11 所示的 cerate_process 脚本都会启动一个记事本程序，通过这个脚
本我们演示了如何执行一个带有输入参数的方法。 
清单 31-11 create_process.vbs 
Set objWMIService = GetObject("winmgmts:{impersonationLevel=impersonate}") 
Set objW32Process = objWMIService.Get("Win32_Process") 
Set objInParam = objW32Process.Methods_("Create")._ 
    inParameters.SpawnInstance_() 
' Add the input parameters. 
objInParam.Properties_.Item("CommandLine") =  "notepad.exe" 
' Execute the method and obtain the return status. 
Set objOutParams = objWMIService.ExecMethod("Win32_Process", "Create", objInParam) 
Wscript.Echo "Out Parameters: " 
Wscript.echo "ProcessId: " & objOutParams.ProcessId 
Wscript.echo "ReturnValue: " & objOutParams.ReturnValue 
最后再看看如何监听 WMI 事件，清单 31-12 所示的脚本注册接收记事本（notepad.exe）
进程启动（Win32_ProcessStartTrace）事件。 
清单 31-12 pmon.vbs 
Set EventSource = GetObject("winmgmts:{impersonationLevel=impersonate}")._ 
 ExecNotificationQuery("select * from Win32_ProcessStartTrace"&_ 
 " where ProcessName='notepad.exe'") 
While true 
   Set objEvent = EventSource.NextEvent 
   WScript.Echo "NotePad starts with PID = "& objEvent.ProcessID 
Wend 
31.5.3  WQL 
SQL（结构化查询语言）是数据库软件中广泛使用的一种数据查询语言，利用它可以
定义数据库对象（这部分被称为 Data definition Language，简称 DDL），操作数据库中的
数据（这部分被称为 Data Manipulation Language, 简称 DML），以及控制数据库的安全（这
部分被称为 Data Contorl Language，简称 DCL）。SQL 简单易懂，功能强大，被几乎所有
关系数据库管理系统（RDBMS）所采用。用于不同数据库系统的 SQL 的大多是对 ANSI
标准定义（SQL-92）的扩展，基本语法是相同的，但是某些方面会有所差异，比如微软
SQL Server 数据库所使用的 T-SQL。那么可以不可以使用 SQL 来查询 WMI 中的数据呢？
可以，这便是用于 WMI 的 SQL，被称为 WQL。 
WQL（WMI Query Language）是标准 SQL 的一个子集，并加入了少量的变化。目前，
WQL 只实现了 SQL 语言中的 DDL 部分（数据操纵）所定义的一部分功能，主要是提取
数据。 
《软件调试》补编 
- 100 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
WMI 的很多内部类都对执行 WQL 查询提供了强大的支持。通过 IWbemServices 接口
的 ExecQuery 方 法便可 以提交 WQL 查询 。因 此只要 先取 得或 创建一 个实现 了
IWbemServices 接口的对象，然后就可以通过它执行查询了。与数据库查询都是相对于当
前数据库类似，WQL 查询都是相对于当前命名空间的。因此要先连接到一个命名空间，
成功连接到命名空间就会得到一个实现了 IWbemServices 接口的对象（参考前面对
ConnectServer 方法的介绍），恰好就可以使用它执行查询了。事实上，连接命名空间会导
致 WMI 创建一个 CWbemNamespace 实例（参见清单），该实例便是实现了 IWbemServices
接口的组件对象。清单 31-13 所示的脚本演示了如何使用 VbScript 来连接一个命名空间，
取得 WbemService 对象，然后执行 WQL 查询的过程。 
清单 31-13 使用 VBScript 执行 WQL 查询 
strComputer = "."  
Set objWMIService = GetObject("winmgmts:\\" & strComputer & "\root\CIMV2")  
Set colItems = objWMIService.ExecQuery( _ 
    "SELECT * FROM Win32_NTLogEvent",,48)  
For Each objItem in colItems  
    Wscript.Echo "-----------------------------------" 
    Wscript.Echo "Win32_NTLogEvent instance" 
    Wscript.Echo "Message: " & objItem.Message 
Next 
容易想到，通过COM API 也可以得到WbemService对象然后执行WQL查询，Windows 
XP 自带的 WbemTest 工具（wbemtest.exe）就是一个这样的小程序。启动后连接到一个命
名空间，然后点击 Query 按钮就可以执行 WQL 查询了（图 31-12），下面我们便利用这个
工具带领大家通过几个试验学习 WQL。 
图 31-12 WbemTest 工具 
首先我们来看一下最常用的 SELECT 语句，在查询对话框的编辑区输入如下查询，然
后点击 Apply 按钮开始执行（参见图 31-13）。 
select * from meta_class where __class like "%Win%" 
这个查询的作用是列出当前命名空间中所有类名里包含 Win 字样的所有类。可以把
meta_class 理解为包含了当前命名空间（相当于数据库）内所有类描述的一张内部数据表。
__class 是 WQL 的一个关键字，可以把理解为 meta_calss 数据表中的一个内部列。 
《软件调试》补编 
- 101 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
图 31-13  使用 WbemTest 工具执行 WQL 查询 
下面再来看一下 WQL 特有的 ASSOCIATORS OF 和 REFERENCES OF 语句，它们都
是用来提取与指定实例存在关联关系的实例（association instances）。但不同的是，
ASSOCIATORS OF 得到的实例是都是关联关系的端点（endpoint），而 REFERENCES OF
语句得到的是中继（intervening）。举例来说，首先输入并执行如下语句： 
ASSOCIATORS OF {Win32_LogicalDisk.DeviceID="C:"} 
在笔者机器上得到的结果如下： 
Win32_Directory.Name="C:\\" 
Win32_QuotaSetting.VolumePath=”C:\\” 
Win32_DiskPartition.DeviceID="Disk #0, Partition #0" 
Win32_ComputerSystem.Name="ADVDBG2" 
以上每行代表一个对象实例，其格式为“类名.键名=键值”，即这个类的键值等于指
定值的实例与源实例存在关联关系。 
接下来输入并执行以下语句，看看使用 REFERENCES OF 语句的结果。 
REFERENCES OF {Win32_LogicalDisk.DeviceID="C:"} 
在笔者机器上得到的结果如下： 
Win32_VolumeQuotaSetting.Element="\\\\SHXPLYZHAN31\\root\\cimv2:Win32_LogicalDis
k.DeviceID=\"C:\"",Setting="\\\\SHXPLYZHAN31\\root\\cimv2:Win32_QuotaSetting.Vol
umePath=\"C:\\\\\"" 
[以下多行省略] 
使 用 我 们 前 面 介 绍 的 CIM Sutdio 工 具 可 以 观 察 到 Win32_LogicalDisk 、
Win32_VolumeQuotaSetting 和 Win32_QuotaSetting 这三个类的关联关系。从图中可以看到
Win32_QuotaSetting 是该关联关系的端点，而 Win32_VolumeQuotaSetting 类是联系着两个
类的一个中继类。这与前面的执行结果正好符合，ASSOCIATORS OF 的结果包含了
Win32_QuotaSetting 的实例，因为它是端点关联实例；REFERENCES OF 的结果包含了
Win32_VolumeQuotaSetting 的实例，因为它是中间的引用类。 
从 Win32_VolumeQuotaSetting 类的定义中也可以看到它的“纽带特征”，Element 属性
指向 Win32_LogicalDisk，Setting 属性指向 Win32_QuotaSetting。 
[dynamic: ToInstance, provider("DskQuotaProvider"): ToInstance, Locale(1033): 
ToInstance, UUID("FA452BCE-5B4F-4A56-BF52-7C4533984706"): ToInstance] 
class Win32_VolumeQuotaSetting : CIM_ElementSetting 
{ 
[read: ToSubClass, key, Override("Element")] Win32_LogicalDisk ref Element = NULL; 
[read: ToSubClass, key, Override("Setting")] Win32_QuotaSetting ref Setting = 
NULL; 
}; 
《软件调试》补编 
- 102 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
图 31-14  Win32_LogicalDisk 和 Win32_QuotaSetting 类的关联关系 
31.5.4  WMI 代码生成器 
从微软网站可以免费下载一个名为 WMI Code Writer 的工具，使用该工具可以交互式
的生成各种 WMI 代码，比如浏览命名空间、执行查询、执行方法和接收事件（参见图
31-15）。 
图 31-15  WMI 代码生成器 
WMI Code Writer 支持生成三种语言的代码：VBScript、VB.Net 和 C#。清单 31-13 中
的 VBScript 脚本就是该工具自动生成的。WMI Code Writer 是使用 C#语言编写的，下载
的压缩包中包含了完整的源代码，感兴趣的读者可以仔细读一读。 
31.5.5  WMI ODBC 适配器 
ODBC（Open Database Connectivity）是数据库领域中一种广泛应用的调用层（call 
level）接口，通过 ODBC，应用程序可以使用同一套 API 来访问各种格式的数据库，只要
为其安装了 ODBC 驱动程序。WMI 的 CIM 数据仓库也是一种数据库，因此只要为其配备
了驱动程序，那么各种数据库应用程序就可以使用 ODBC API 来访问 WMI 中的信息了，
而不必使用 COM/DCOM。WMI ODBC 适配器（Adapter）就是按照这一思想设计的，通
过 WMI ODBC 适配器，应用程序可以像访问数据库一样访问 CIM 数据仓库。从 ODBC
架构角度来看，WMI ODBC 适配器启动的就是 ODBC 驱动程序的作用。 
在 Windows XP 和 2000 的默认安装中都不含 WMI ODBC 适配器，但可以在安装光盘
的如下目录中找到它的安装程序。 
VALUEADD\MSFT\MGMT\WBEMODBC 
《软件调试》补编 
- 103 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
运行以上目录中的 wbemodbc.msi 后，从控制面板的 ODBC 数据源管理对话框中就可
以看到 WBEM ODBC 驱动程序了（如图 31-16）。 
图 31-16  WBEM ODBC 驱动程序 
有了 ODBC 驱动程序，就可以通过 DSN（Data Source Name）或者连接字符串
（Connection String）来访问 CIM 数据了。其细节请参看 MSDN 中关于 ODBC 编程的部
分。需要说明的是，通过 WMI ODBC 适配器所访问到的 CIM 信息是只读的，而且不支持
Unicode。 
31.5.6  在.Net 程序中使用 WMI 
前面我们讲过，通过 COM API 来访问 WMI 服务是最灵活高效的方式，因为 WMI 本
身就是使用 COM 技术构建的。利用 COM Interop 技术，.Net 程序可以访问和使用 COM
组件，COM 组件也可以像使用其它 COM 组件那样访问.Net 语言编写的组件。因此，.Net
程序完全可以通过 COM Interop 来使用 WMI（WMI Consumer），也可以成为 WMI 的提供
器。为了使.Net 程序可以更简单使用 WMI，.Net Framework 提供了一个类库来封装 COM 
Interop 的细节，让程序员只要通过这些托管类（managed class）就可以使用 WMI。这些
类主要位于 System.Management 和 System.Management. Instrumentation 两个 namespace 中，
前者主要供使用 WMI（WMI 消耗器）的程序使用，后者供向 WMI 提供事件或数据（WMI
提供器）的程序使用，它们都被包含在 System.Management.dll 内。 
清单 31-14 给出了一个使用 C#语言编写的小程序，它可以通过 WMI 列出当前系统中
运行着的所有进程。\code\chap31\c#\WmiClientCS\目录下包含了完整的项目文件。因为使
用了 System.Management 类，所以应该向项目中加入对 System.Management.dll 的引用（Add 
Reference）。 
清单 31-14 在.Net 程序中使用 WMI 的简单示例 
1 using System; 
2 using System.Management; 
3  
4 namespace WmiClientCS 
5 { 
6     class Program 
7     { 
8         static void Main(string[] args) 
9         { 
《软件调试》补编 
- 104 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
10             string searchQuery = "SELECT * FROM Win32_Process"; 
11             ManagementObjectSearcher searchPrinters = 
12                   new ManagementObjectSearcher(searchQuery); 
13             ManagementObjectCollection printerCollection = searchPrinters.Get(); 
14             foreach (ManagementObject printer in printerCollection) 
15             { 
16                 Console.WriteLine(printer.Properties["Name"].Value.ToString()); 
17             } 
18       } 
19     } 
20 } 
31.6  调试 WMI 
WMI 是个复杂的系统，种类繁多的 WMI 应用程序和 WMI 提供器丰富了 WMI 的功
能，但同时也增加了整个系统的复杂度。在一个典型的 WMI 系统中，各种 COM/DCOM
组件在多个进程间相互调用，RPC 通信和异步调用非常普遍，这些因素都为调试 WMI 有
关的问题增加了难度。好在 WMI 在设计时便考虑到了调试问题，内建了很多调试支持： 
1. 
WMI 的所有核心模块都具有日志记录功能，可以将重要的操作和异常情况记录到日
志文件中。 