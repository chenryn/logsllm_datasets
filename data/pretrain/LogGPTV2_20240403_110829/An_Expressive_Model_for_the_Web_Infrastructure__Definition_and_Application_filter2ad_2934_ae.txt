non-interactive way for RPs to obtain a freshly generated
CAP: During initialization of the BrowserID code included
by RP-Doc, an invisible iframe called the communication
iframe (CIF) is created inside RP-Doc. The CIF’s JavaScript
is loaded from LPO and behaves similar to LD, but without
user interaction. The CIF automatically issues a fresh CAP
and sends it to RP-Doc under speciﬁc conditions: among
others, the email address must be marked as logged in at RP
in the localStorage. If necessary, a new key pair is created
and a corresponding new UC is requested at IdP.
Logout. We have to differentiate between three ways of
logging out: an RP logout, an LPO logout, and an IdP logout.
An RP logout is handled by the CIF after it has received
a logout postMessage from RP-Doc. The CIF then changes
the localStorage such that no email address is recorded to
be logged in at RP.
An LPO logout essentially requires to logout at the web
site of LPO. The LPO logout removes all key pairs and
certiﬁcates from the localStorage and invalidates the session
on the LPO server.
An IdP logout depends on the IdP implementation and
usually cancels the user’s session with IdP. This entails
that IdP will not issue new UCs for the user without re-
authentication.
C. Sideshow and BigTent
Since several email providers, such as gmail.com and
yahoo.com, already use OpenID [24], a widely employed
SSO system, Mozilla implemented IdPs called Sideshow
and BigTent which use an OpenID backend for user au-
thentication: Sideshow/BigTent are put between BrowserID
and an email provider running OpenID. That is, BrowserID
uses Sideshow/BigTent as an IdP. Sideshow/BigTent translate
requests from BrowserID to requests to the email provider’s
OpenID interface. Currently, Sideshow and BigTent are used
to provide BrowserID support for gmail.com and yahoo.com,
respectively. In what follows, we describe Sideshow in more
detail; BigTent is similar.
In Phases vi and vii , mainly the IA is generated by LD for
the origin of RP-Doc and sent (together with the UC) to RP-
in Figure 2). In the localStorage, LD stores that the
Doc ( II
user’s email is logged in at RP. Moreover, the user’s email
is recorded at LPO (see the explanation on LPO Sessions
below). For this purpose, LD generates an IA for the origin
of LPO and sends the UC and IA to LPO.
LPO Session. LPO establishes a session with the browser
683
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:01:20 UTC from IEEE Xplore.  Restrictions apply. 
All BrowserID protocol steps that would normally be
carried out by the IdP are now handled by Sideshow (i.e.,
the Sideshow server). For this purpose, Sideshow serves the
provisioning URL (for the PIF) and the authentication URL
used in iii . It maintains a session with the user’s browser.
This session is considered to be authenticated if the user
has successfully authenticated to Sideshow using OpenID.
In this case, Sideshow’s PIF document may send public keys
to Sideshow. Sideshow then creates a UC for the identity it
believes to be logged in. If the session at Sideshow is not
authenticated, the user will ﬁrst be redirected to the Sideshow
authentication URL. Sideshow’s authentication document
will redirect the user further to the OpenID URL at Gmail.
This URL contains an authentication request encoding that
Sideshow requests an OpenID assertion that contains an
email address. In general, such an assertion is a list of
attribute name/value pairs (partially) MACed by Gmail with a
temporary symmetric key known only to Gmail; an additional
attribute, openid.signed, in such an assertion encodes
which attribute name/value pairs have actually been MACed
and in which order. The user now authenticates to Gmail.
Then, Gmail issues the requested OpenID assertion and
redirects the browser to Sideshow with the assertion in the
URL parameters. Sideshow then sends the OpenID assertion
to Gmail
in order to check its validity. If the OpenID
assertion is valid, i.e. the MAC over the attributes listed in
openid.signed veriﬁes, Sideshow considers its session
with the user’s browser to be authenticated for the email
address contained in the OpenID assertion.
D. Secondary Identity Provider
If an email provider (IdP) does not directly support
BrowserID, LPO can be used as a so-called secondary IdP
(sIdP), i.e., it replaces the IdP completely. For this, the user
has to register at LPO. That is, she creates an account at
LPO where she can register one or more email addresses
to be used as identities. She has to prove ownership of all
email addresses she registers. (LPO sends URLs to each
email address, which then have to be opened by the user.)
When the sIdP is used, the phases ii – vi are not needed
as now LPO replaces the IdP and the actions previously
performed by IdP and LPO are now carried out by LPO
alone. The user is prompted to enter her password directly
into LD. If the password is correct, LPO now considers the
session with the browser to be authenticated. LPO will then
issue UCs on behalf of the email provider. We note that, for
automatic CAP creation, the CIF (see Section IV-B) is still
used.
V. ANALYSIS OF BROWSERID
In this section, we present the analysis of the BrowserID
system. We ﬁrst formulate fundamental security properties
for the BrowserID system. We then present attacks that show
that these properties are not satisﬁed and propose ﬁxes. For
the case of BrowserID with sIdP and the ﬁxes applied, we
then prove that the security properties are satisﬁed in our
web model. We note that we also incorporate the automated
CAP creation with the CIF in our model of BrowserID (see
Section IV-B). Our web model is expressive enough to also
formally model the BrowserID system with primary IdPs
(and Sideshow/BigTent) in a straightforward way. However,
we leave the detailed formulation of such a model and the
proof of the security of the ﬁxed system with primary IdPs
to future work.
A. Security Properties for BrowserID
While the documentation of BrowserID does not contain
explicit security goals, we deduce two fundamental security
properties that can be informally described as follows (see
Section V-C for a formal description): (A) The attacker
should not be able to use a service of RP as an honest
user. In other words, the attacker should not get hold of (be
able to derive from his current knowledge) an RP service
token for an ID of an honest user (browser), even if the
browser was closed and then later used by a malicious user
(i.e., after a CLOSECORRUPT). (B) The attacker should not
be able to authenticate an honest browser to an RP with an
ID that is not owned by the browser.
B. Attacks on BrowserID
Our analysis of BrowserID w.r.t. the above security proper-
ties revealed several attacks (as sketched next). We conﬁrmed
the attacks on the actual implementation and also reported
them to Mozilla. The ﬁrst two ﬁxes proposed below have
been adopted by Mozilla already and the others are currently
under discussion at Mozilla.
1) Identity Forgery: There are two problems in Sideshow
that lead to identity forgery attacks for Gmail addresses;
analogously in BigTent with Yahoo email addresses.5
a) It is not checked if all requested attributes in the OpenID
assertion are MACed, which allows for the following at-
tack: A (web) attacker may choose any Gmail address to
impersonate, say victim@gmail.com. He starts a BrowserID
login with this email address. When he is then redirected
to the OpenID URL at Gmail, he removes the email at-
tribute from Sideshow’s authentication request. The attacker
authenticates himself at Gmail with his own account (say,
PI:EMAIL). Upon receipt of the OpenID assertion,
he appends the email attribute with value PI:EMAIL
and forwards it to Sideshow. The assertion is declared valid
by Gmail since the MAC is correct (the email attribute is
not listed in openid.signed). Since Sideshow does not
require the email attribute to be in openid.signed, it
accepts the OpenID assertion, considers the attacker’s session
to be authenticated for PI:EMAIL, and issues UCs
for this address to the attacker. This violates Condition (A).
5See https://bugzilla.mozilla.org/show_bug.cgi?id=920030 and https://
bugzilla.mozilla.org/show_bug.cgi?id=920301.
684
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:01:20 UTC from IEEE Xplore.  Restrictions apply. 
b) Sideshow uses the ﬁrst email address in the OpenID
assertion (based on the attribute type information), which
is not necessarily the MACed email address. This allows
for an attack similar to the above, except that the attacker
does not need to change Sideshow’s authentication request
but only prepends the victim’s email address to the OpenID
assertion in an additional attribute.
Proposed ﬁx. Sideshow/BigTent must ensure to use the
correct and MACed attribute for the email address.
2) Login Injection Attack: During the login process,
in Figure 3),
the origin of the response postMessage ( 26
which contains the CAP, is not checked. An attacker (e.g.,
in a malicious advertisement iframe within RP-Doc), can
continuously send postMessages to the RP-Doc with his
own CAP in order to log the user into his own account. This
attack violates Condition (B).6
Proposed ﬁx. To ﬁx the problem, the sender’s origin of the
postMessage 26 must be checked to match LPO.
3) Key Cleanup Failure Attack: When LD creates a key
pair ( 15 in Figure 3), it stores the keys in the localStorage
(even in ephemeral sessions). When a user quits a session
(e.g, by clicking on RP’s logout button and closing the brow-
ser) the key pair (and the UC) remain in the localStorage,
unlike session cookies. Hence, users of shared terminals can
read the localStorage (in our model, a CLOSECORRUPT allows
an attacker to do this) and then, using the key pair and the
UC, create valid CAPs to log in at any RP under the identity
of the previous user, which violates Condition (A).7
Proposed ﬁx. We propose to use the localStorage for this
data only in non-ephemeral sessions.
4) Cookie Cleanup Failure Attack (for the case of sec-
ondary IdP only): The LPO session cookie is not deleted
when the browser is closed, even in ephemeral sessions and
even if a user logged out at RP beforehand. (In our model,
if the attacker issues a CLOSECORRUPT, he can therefore still
access the LPO session cookie.) Hence, another user of the
same browser could request new UCs for any ID registered
at LPO for that user, and hence, log in at any RP under this
ID, which violates Condition (A).8
Proposed ﬁx. In ephemeral sessions, LPO should limit the
cookie lifetime to the browser session.
C. Analysis of BrowserID with sIdP
We now present our formal model and analysis of
BrowserID with sIdP. We consider ephemeral sessions (the
default), which are supposed to last until the browser is
closed. We assume that users are already registered at LPO,
i.e., they have accounts at LPO with one or more email
addresses registered in each account.
6See https://bugzilla.mozilla.org/show_bug.cgi?id=868967
7See https://github.com/mozilla/browserid/issues/3770
8See https://github.com/mozilla/browserid/issues/3769
More speciﬁcally, we ﬁrst model the BrowserID system
as a web system (in the sense of Section III), then pre-
cisely formalize the security properties already sketched
in Section V-A in this model, and ﬁnally prove, for the
BrowserID model with the ﬁxes proposed in Section V-B
applied (otherwise the proof would not go through), that
these security properties are satisﬁed.
1) Our BrowserID Model: We call a web system BID =
(W , S , script, E0) a BrowserID web system if it is of the
form described in what follows.
The system W = Hon ∪ Web ∪ Net consists of the
(network) attacker process attacker, the web server for LPO,
a ﬁnite set B of web browsers, and a ﬁnite set RP of web
servers for the relying parties, with Hon := B∪ RP∪{LPO},
Web := ∅, and Net := {attacker}. DNS servers are assumed
to be dishonest, and hence, are subsumed by attacker. More
details on the processes in W are provided below.
The set N of nonces is partitioned into three sets, an
inﬁnite set N W , an inﬁnite set Kprivate, and a ﬁnite set
Secrets. The set N W is further partitioned into inﬁnite sets
of nonces, one set N p ⊆ N W for every p ∈ W .
The set IPs contains for LPO, attacker, every relying party
in RP, and every browser in B one address each. By addr
we denote the corresponding assignment from a process to
its address. The set Doms contains one domain for LPO, one
for every relying party in RP, and a ﬁnite set of domains
for attacker. Each domain is assigned a fresh private key
(a nonce). Additionally, LPO has a fresh signing key kLPO,
which it uses to create UCs.
Each browser b ∈ B owns a ﬁnite set of secrets (⊆ Secrets)
for LPO and each secret is assigned a ﬁnite set of email
addresses (IDs) of the form (cid:5)name, d(cid:6), with name ∈ S and
d ∈ Doms, such that browsers have disjoint sets of secrets
and secrets have disjoint sets of IDs. An ID i is owned by
a browser b if the secret associated with i belongs to b.
The set S contains four scripts, with their string repre-
sentations deﬁned by script: the honest scripts running in
RP-Doc, CIF, and LD, respectively, and the malicious script
Ratt (see below for more details).
The set E0 contains only the trigger events speciﬁed in
Deﬁnition 6.
Before we specify the processes in W , we ﬁrst note that
a UC uc for a user u with email address i and public
key (veriﬁcation key) pub(ku), where ku is the private key
(signing key) of u, is modeled to be a message of the
form uc = sig((cid:5)i, pub(ku)(cid:6), kLPO), with kLPO as deﬁned
above. An IA ia for an origin o (e.g., (cid:5)example.com, S(cid:6)) is
a message of the form ia = sig(o, ku). Now, a CAP is of the
form (cid:5)uc, ia(cid:6). Note that the time stamps are omitted both
from the UC and the IA. This models that both certiﬁcates
are valid indeﬁnitely. In reality, as explained in Section IV,
they are valid for a certain period of time, as indicated by the
time stamps. So our modeling is a safe overapproximation.
685
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:01:20 UTC from IEEE Xplore.  Restrictions apply. 
We are now ready to deﬁne the processes in W as well
as the scripts in S in more detail. We note that in our full
version [14], we provide a detailed formal speciﬁcation of
the processes and scripts in the style of Algorithm 1.
All processes in W contain in their initial states all public
keys and the private keys of their respective domains (if any).
We deﬁne I p = {addr(p)} for all p ∈ Hon.
Attacker. The attacker process is a network attacker (see
Section III-A), who uses all addresses for sending and
listening. All parties use the attacker as a DNS server.
Browsers. Each b ∈ B is a web browser as deﬁned in
Section III-D. The initial state contains all secrets owned
by b, stored under the origin (cid:5)dom(LPO), S(cid:6) of LPO; sts is
(cid:5)dom(LPO)(cid:6).
LPO. The initial state of LPO contains its signing key
kLPO, all secrets in Secrets and the corresponding IDs. The
deﬁnition of RLPO closely follows the description of LPO in
Section IV-D. Sessions of LPO expire non-deterministically.
UCs are signed using kLPO.
Relying Parties. A relying party r ∈ RP is a web server. The
deﬁnition of Rr follows the description in Section IV and the
security considerations in [23].9 RP answers any GET request
with the script script_RP_index (see below). When receiv-
ing an HTTPS POST message, RP checks (among others) if
the message contains a valid CAP. If successful, RP responds
with an RP service token for ID i of the form (cid:5)n, i(cid:6), where
i ∈ ID is the ID for which the CAP was issued and n is a
freshly chosen nonce. The RP r keeps a list of such tokens
in its state. Intuitively, a client having such a token can use
the service of r for ID i.
BrowserID Scripts. The set S consists of the follow-
ing scripts: Ratt, script_RP_index , script_LPO_cif , and
script_LPO_ld, with their string representations being
att_script, script_RP_index, script_LPO_cif, and
script_LPO_ld. The latter two scripts (issued by LPO) are