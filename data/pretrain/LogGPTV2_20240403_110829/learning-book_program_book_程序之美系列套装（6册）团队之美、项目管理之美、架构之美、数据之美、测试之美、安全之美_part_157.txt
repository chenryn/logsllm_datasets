品质需求。让我们回到Web应用的例子。请考虑提供Web页面的诸
多方式一Apache和静态页面、CGI、Servlet、JSP、JSF、PHP、Ruby
onRails、ASP.NET等。选择其中的一种技术是一种架构决定，它将
对你满足特定品质需求的能力产生重要影响。例如，像Rubyon
Rails这样的方式可能提供快速推向市场的好处，但可能更难维护，
因为Ruby语言和Rails框架都在不断地快速发展。也许我们的应用是
基于Web的电话，我们需要让电话“响铃”。如果你为了满足性能的
要求，需要从服务器向Web页面发出真正异步的事件，那么基于
Servlet的架构可能更容易测试和修改。
在真实的项目中，满足利益相关人的关注点需要做出更多的决定，
而不仅是选择一个Web框架。你是否真的需要一个“架构”，并需要
一名“架构师”来做出这些决定？谁将做出这些决定？是编程人员
吗？他们可能会做出许多无意识的、隐含的决定。还是由架构师来
做出这些决定？他们全面了解整个系统、利益相关人和系统的演
进，然后做出明确的决定。不论哪种方式，你会有一个架构。它是
否应该明确地形成并记入文档？或者它应该是隐式的，需要通过阅
读代码才能发现？
当然，这种选择通常不是这么死板。但是，随着系统的规模、复杂
度和并发人员数目的增长，这些早期决定以及它们的记录方式将产
生越来越大的影响。
我们希望你现在已经理解，如果你的系统要满足其品质要求，架构
决定是很重要的，你需要注意架构，有意识地做出这些决定，而不
只是“让架构自动出现”。
如果系统非常大，情况会怎样？我们之所以运用“分而治之”这样的
架构原则，一个原因就是为了降低复杂性，让工作能够并发进行。
这让我们能够创建越来越大的系统。架构本身是否能够分解为多个
部分，这些部分是否能由不同的人并行并发？考虑到计算机的架
构，GerritBlaauw和FredBrooks断定：
....如果，在采取了所有让任务能够由单人处理的方法之后，架构
任务仍然巨大而复杂，不能由一人来完成，那么产品肯定是太复杂
了，以致不实用且不应构建。换言之，单个用户必须能够理解计算
机的架构。如果计划的架构不能由一个人设计，那它也不能被一个
人理解。（1997）
881
---
## Page 883
你是否需要理解架构的所有方面，才能使用它？架构会分离关注
点，所以在大多数情况下，利用架构来构建或维护系统的并发人员
或测试人员，不需要一下面对全部的架构，而是只要面对必要的部
分，就能完成指定的功能。这让我们能够创建超出个人可以理解
的、更大的系统。但是，在我们完全忽略IBMSystem/360（最长寿
的计算机架构之一）创造者的建议之前，让我们先来看看他们为什
么这样说。
FredBrooks说，概念完整性是架构最重要的特征：“最好是让系
统......反映一组设计思想，而不是让系统包含许多好的思想，而这
些思想却彼此独立而不协调”（1995）。正是这种概念完整性，让
开发者在知道了系统的一部分之后，能够迅速理解系统的另一部
分。概念完整性来自于处理问题的一致性，如分解的判据、设计模
式的应用和数据模式。这让开发者运用在系统中的一部分工作的经
验，来开发和维护系统的其他部分。同样的规则应用于整个系统各
处。当我们转向“众系统之系统"时，在集成了这些系统的架构中也
必须保持概念完整性。例如，可以选择发布/订阅消息总线这样的架
构风格，然后将这种风格统一地应用于“众系统之系统"的系统集成
中。
架构团队的挑战在于，在创建架构时保持同一种思考方式和同一种
哲学。让团队保持尽可能小，让他们在充分沟通、高度协作的环境
工作，让一两个“首席架构师"担任仁慈的独裁者，最终做出所有决
定。这种架构模式常见于成功的团队，不论是公司并发还是并源并
发，由此而得到的概念完整性是美丽架构的一种特性。
好的架构师通常来自于更好的架构师提供的现场指导（Waldo
2006）。原因之一可能是有一些关注点几乎在所有项目中都会出
现。我们已经提到过一些，但这里有一份更完整的清单。每个关注
点都以问题的方式表述，架构师在项目过程中可能需要考虑它。当
然，具体系统会有其他关键的关注点。
功能性（Functionality）
产品向它的用户提供哪些功能？
可变性（Changeability）
882
---
## Page 884
软件将来可能需要哪些改变？哪些改变不太可能发生，不需要特别
容易进行这些改变？
性能（Performance）
产品将达到怎样的性能？
容量（Capacity）
多少用户将并发使用该系统？该系统将为用户保存多少数据？
生态系统（Ecosystem）
在部署的生态环境中，该系统将与其他系统进行哪些交互？
模块化（Modularity）
如何将编写软件的任务分解为工作指派（模块），特别是这些模块
可以独立地并发，并能够准确而容易地满足彼此的需要？
可构建性（Buildability）
如何将软件构建为一组组件，并能够独立实现和验证这些组件？哪
些组件应该复用其他的产品，哪些应该从外部供应商处获得？
产品化（Producibility）
如果产品将以几种变体的形式存在，如何并发一个产品线，并利用
这些变体的共性？产品线中的产品以怎样的步骤开发（Weiss和Lai
1999）？在创建一条软件产品线时，要进行哪些投资？开发产品线
中不同变体的选择，预期会得到怎样的回报？特别是，是否可能先
并发最小的有用产品，然后再添加（扩展）组件，在不改变以前编
写的代码的情况下，开发产品线的其他成员？
安全性（Security）
产品是否需要用户认证，或者必须限制对数据的访问？数据的安全
性如何得到保证？如何抵挡“拒绝服务”攻击或其他攻击？
最后，一个好的架构师会认识到，架构会影响组织机构。Conway指
出，系统的结构会反映构建它的组织机构的结构（1968）。架构师
883
---
## Page 885
可能会认识到，Conway法则可以反过来应用。换言之，一个好的架
构可能对组织机构产生影响，让组织机构发生改变，从而更有效地
从该架构构建出系统。
1.3架构结构
那么，好的架构师如何来处理这些关注点？我们曾经提到过，需要
将系统组织成一些结构，每种结构都定义了特定类型的组件之间的
具体关系。架构师的主要关注点就是对系统进行组织，让每种结构
有助于解答一个关注点所定义的问题。关键的结构决定将产品划分
为组件，并定义了这些组件之间的关系（Bass、Clements和Kazman
2003;Booch、Rumbaugh和Jacobson1999;IEEE2000:Garlan和
Perry1995）。对于任何产品，都有许多结构需要设计。每种结构
都必须单独设计，这样它就表现为一个独立的关注点。在接下来的
几节中我们会讨论一些结构，你可以利用它们来考虑前面列表中的
关注点。例如，“信息隐藏结构”展示了如何将系统组织成一些工作
指派。这种结构也可以用作改变的路线图，展示了建议的改变，以
及哪些模块支持这些改变。针对每种结构，我们描述了一些组件及
其之间的关系，正是这些组件和关系确定了这种结构。对照前面的
列表，我们认为下面的结构是最重要的。
1.3.1信息隐藏结构
组件与关系：主要组件是一些“信息隐藏模块”，每个模块都是针对
一组并发人员的工作指派，每个模块都包含了一种设计决定。如果
一项决定可以改变，同时又不影响任何其他模块，我们就说这项设
计决定是一个模块的秘密（Hoffman和Weiss2000，第7章和第16
章）。模块间最基本的关系是“整体-部分"关系。如果“信息隐藏模
块A"的秘密是“信息隐藏模块B"的秘密的一部分，那么A就是B的一
部分。请注意，必须能够在改变A的秘密的同时，不改变B的其他部
分。否则，根据我们的定义，A就不是B的一个子模块。例如，许多
架构都有一些虚拟设备模块，它们的秘密是如何与特定的物理设备
通信。如果虚拟设备分成不同类型，那么每种类型可能构成该虚拟
设备模块的一个子模块，其中每种虚拟设备类型的秘密将是如何与
这种类型的设备进行通信。
每个模块都是一份工作指派，包含了一组要写的程序。根据不同的
语言、平台、环境，“程序"可以是能在计算机上执行的方法、过
程、函数、子程序、脚本、宏或其他指令序列。第二种信息隐藏模
884
---
## Page 886
块结构是基于程序和模块之间的“包含”关系。如果模块M的一部分
工作指派是要编写程序P，那么M就包含P。请注意，每个程序都包
含在一个模块中，因为每个程序必然是某些开发人员的工作指派的
一部分。
这些程序中的一些可以通过模块的接口来访问，而另一些则是内部
的。模块也可能通过接口发生关系。A模块的接口是一组假定，这
些假定包括该模块之外的程序可以对该模块做出的假定，也包括该
模块中的程序对其他模块的程序和数据结构所做的假定。如果改变
B的接口就要求A也发生改变，那么我们就说A“依赖"B的接口。
“整体-部分"结构是层次状的。在这个层次结构的叶节点上的模块不
包含可识别的子模块。“包含”结构也是层次状的，因为每个程序都
只包含在一个模块之中。“依赖"关系不一定是层次状的，因为两个
模块可能互相依赖，要么是直接互相依赖，要么是通过一个较长的
“依赖”关系形成的坏。请注意，“依赖”不应该与后面小节中定义的
“使用”混淆起来。
信息隐藏结构是面向对象设计方法的基础。如果一个信息隐藏模块
设计为一个类，这个类的公有方法就属于该模块的接口。
满足的关注点：信息隐藏结构的设计应该能满足可变性、模块化和
可构建性的要求。
1.3.2使用结构
组件与关系：根据前面我们的定义，信息隐藏模块包含一个或多个
程序（在上一小节中定义）。当且仅当两个程序共享一个秘密时，
（）影用，
些可以单独调用的程序。请注意，程序可以相互调用，或被硬件调
用（例如，被一个中断例程调用），调用也可能来自于不同命名空
间的程序，如操作系统例程或远程过程。而且，调用发生的时间可
以是任何时候，从编译时到运行时。
只有在相同绑定时间操作的程序之间，我们才考虑形成一种使用结
构。首先只考虑运行时操作的程序可能最容易。以后，我们也可以
考虑那些编译时或载入时操作的程序之间的使用关系。
如果程序B必须存在并满足其规格说明，程序A才能满足其规格说
明，我们就说A使用了B。换言之，B必须存在且操作正常，A才能
885
---
## Page 887
操作正常。使用关系有时候也称为“要求存在正确的版本”。进一步
的解释和例子，参见（Hofman和Weiss20oo）的第14章。
使用结构确定了我们可以构建并测试怎样的工作子集。在软件系统
的使用结构中，期望的属性是它定义了一种层次结构，这意味着其
中不出现环。如果在使用关系中出现环，那么环中所有程序都必须
存在且正常工作，才能让其他的程序正常工作。由于也许不能够创
建完全没有环的使用关系，架构师可能将使用环中的所有程序作为
单一的程序，以这种方法来创建子集。子集必须要么包含全部程
序，要么都不包含。
如果在使用关系中没有环，软件采用的就是一种层次结构。在最底
层，即第0层，是所有不使用其他程序的程序。第n层包含了所有的
程序，它们使用了第n-1层或以下层的程序。这些层常常描绘为一系
列的层次，每个层次表示了使用关系中的一个或几个层。在使用结
构中对相邻的层分组，有助于简化表示，并允许在关系中出现小环
的情况。进行这种分组有一个指导原则，即一个层次中的程序应该
比它上一个层次中的程序执行速度快9倍，执行频率高9倍
(Courtois 1977）。