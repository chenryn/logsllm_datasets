Constructing ELF Metadata
DEFCON 20
July 28, 2012
Rebecca Shapiro and Sergey Bratus
Dartmouth College
Who? What? Where?
Image by Stripey the crab [CC-BY-SA-3.0]
This Talk in One Minute
 ”Deep magic” before a program can run
 ELF segments, loading, relocation, 
 ”Deeper magic” to support dynamic linking
 Dynamic symbols, loading of libraries
 Many pieces of code – enough to program 
anything (Turing-complete)
 In perfectly valid ELF metadata entries alone
 Runs before most memory protections are 
set for the rest of runtime
 Runs with access to symbols (ASLR? what 
ASLR?)
Image: “Clock” symbol by Brandon Hopkins, from thenounproject.com
The Weird Kinds of Programming
Exploit is a program running on the target
 encoded as crafted data
 reliably executed by target's intended and 
unindented primitives
 Resembles assembly with calls to library 
functions and system calls – very weird 
assembly
 aa4bmo [Phrack 61:6, jp]
 %n in format strings
Virtual Machine vs ”Weird Machine”
 VM bytecode programs are data in memory
 Pieces of native code implement effects and 
actions of bytecodes
 ”Data (bytecode) acts on the state of the VM”
 Exploit payload is (crafted) data in memory
 Pieces of native code produce unexpected 
effects on system state 
 Crafted data is executed as bytecode on a 
”weird” VM inside target
Exploitation is Programming Weird 
Machines
 Exploit programs use dormant/latent state 
and/or transitions not present in the target’s 
programming model but actually present in the 
target 
  Memory corruptions, escaping errors, in-band 
signalling effects, ...
 Memory buffers become “stored programs” 
(hallo von Neumann) 
 “Exploitation is setting up, instantiating, and 
programming a weird machine” 
 T. Dullien, Infiltrate 2011
Where Do We See Weird 
Machines?
 Heap metadata executed on heap manager
 Format strings act on pring's internals
 TCP/IP packet acts on the stack
 Executable file metadata acts on loader/RTLD
Exploit Techniques & Weird 
Machines
Normal
Odd
Weird
XSS
SQL injection
Stack smashing
Modern heap smashing
Crafting DWARF
Crafting ELF
ROP
The Quest
 ELF background
 Prior work with abusing ELF
 Everything you need to know about ELF 
metadata for this talk
 Branfuck to ELF compiler
 Relocation entry backdoor 
 Demo exploit
ELF
Executable and Linking Format
  How gcc toolchain components communicate
 Assembler (*.c → *.oo)
 Static linker (*.o → executable)
 Runtime linker/loader (RTLD) (exec, *.so)
 Dynamic linker/loader (*.so)
ELF File Contents
 Architecture/version information
 Symbols
 Symbol names (string table)
 Interpreter location (usually ld.so)
 Relocation Entries
 Debugging information
 Constructors/deconstructors
 Dynamic linking information
 ….
 Static/initialized data
 Code
 Entrypoint
ELF Sections
 All data/code is contained in ELF sections
 Except ELF, section, and segment headers
 Section = contiguous chunk of bytes
 1 section  1 section header
 Header contains: size, file offset, memory 
offset, etc, for linker/loader
 Most sections contain one of:
 Table of structs (.ssymtab, .rela.dyn)
 Null terminated strings (.strtab)
 Mixed data (ints, long, etc) (.data)
 Code (.text)
Interesting ELF Sections
 Symbol table (.dynsym)
 Relocation tables (.rela.dyn, .rela.plt)
 Global offset table (.got)
 Procedure linkage table (.got.plt)
 Dynamic table (.dynamic)
Interesting ELF Sections
 Symbol table (.dynsym)
 Relocation tables (.rela.dyn, .rela.plt)
 Global offset table (.got)
 Procedure linkage table (.got.plt)
 Dynamic table (.dynamic)
Symbol Tables
 Info to (re)locate symbolic definitions and 
references
 For variables/functions imported/exported
 Example  symbols in libc:
           typedef struct {
               uint32_t      st_name;
               unsigned char st_info;
               unsigned char st_other;
               uint16_t      st_shndx;
               Elf64_Addr    st_value;
               uint64_t      st_size;
           } Elf64_Sym;
  Num:            Value             Size  Type          Bind          Vis      Ndx Name
  7407: 0000000000376d98     8  OBJECT  GLOBAL DEFAULT  31  stdin
  7408: 00000000000525c0    42  FUNC      GLOBAL DEFAULT  12  putc
 Symbol definition for 64-bit architectures:
Image: “Table” Sofie Hauge Katan, from The Noun Project
Interesting ELF Sections
 Symbol table (.dynsym)
 Relocation tables (.rela.dyn, .rela.plt)
 Global offset table (.got)
 Procedure linkage table (.got.plt)
 Dynamic table (.dynamic)
Relocation Tables
 .rela.dyn
 Relocation information for RTLD
 Processed at load time
 .rela.plt
 Relocation information for dynamic linker
 Processed as needed at runtime
Image: “Commercial Loading Zone” Kirk Lohry, from The Noun Project
Relocation Table Entries
 Where to write what value at load/link time
 For amd64:
           typedef struct {
               Elf64_Addr r_offset;
               uint64_t   r_info;
               int64_t    r_addend;
           } Elf64_Rela;
 Where to write what value at load/link time
 For amd64:
 Where to write what value at load/link time
 For amd64:
 r_info: 
 Relocation entry type
 #define ELF64_R_TYPE(i) ((i) & 0xffffffff)
 Associated symbol table entry index
 #define ELF64_R_SYM(i) ((i) >> 32)
 amd64 ABI defines 37 relocation types
 gcc toolchain uses 13 types (1 not in ABI)
 (.rela.dyn, .rela.plt)
Image: “Door” Tak Imoto, from The Noun Project
Interesting ELF Sections
 Symbol table (.dynsym)
 Relocation tables (.rela.dyn, .rela.plt)
 Global offset table (.got)
 Procedure linkage table (.got.plt)
 Dynamic table (.dynamic)
GOT and PLT
Global Offset Table and Procedure Linkage Table
 Entry in each for dynamically-linked functions 
 GOT is a table of addresses
 GOT[1] = object's link_map struct
 ELF object metadata used by RTLD/linker
 GOT[2] = &_dl_fixup (dynamic linker function)
 GOT entry for linked function is &function or 
&
 PLT contains instructions that work with GOT 
to invoke _dl_fixup and linked function 
Image: “Chain” Plinio Fernandes, from The Noun Project
Interesting ELF Sections
 Symbol table (.dynsym)
 Relocation tables (.rela.dyn, .rela.plt)
 Global offset table (.got)
 Procedure linkage table (.got.plt)
 Dynamic table (.dynamic)
Dynamic Table
 Table of metadata used by runtime loader
           typedef struct {
               Elf64_Sxword    d_tag;
               union {
                   Elf64_Xword d_val;
                   Elf64_Addr  d_ptr;
               } d_un;
           } Elf64_Dyn;
 Types of interest
 DT_RELA, DT_RELASZ
 DT_RELACOUNT
 DT_SYM
 DT_JMPREL, DT_PLTRELSZ
b
b
Useful dynamic section entries
 DT_RELA, DT_RELASZ, 
 Start and size of .rela.dyn table
 DT_SYM
 Location of symbol table (.dynsym)
 DT_PLTGOT
 Location of GOT
 Among others needed for clean execution
Linking and Loading
Source: http://keithsrockin.blogdrive.com/archive/5.html
Loading and Linking:
The story of exec()
After exec() finishes
After ld.so finishes loading
Memory layout of ping (partial)
00400000-00408000 r-xp ping
00607000-00608000 r--p ping
00608000-00609000 rw-p ping
00609000-0061c000 rw-p 
02165000-02186000 rw-p  [heap]
7fc2224d2000-7fc2224de000  r-xp libnss_files-2.13.so
7fc2226dd000-7fc2226de000 r--p  libnss_files-2.13.so
7fc2226de000-7fc2226df000 rw-p  libnss_files-2.13.so
7fc2226df000-7fc222876000 r-xp libc-2.13.so
7fc222a75000-7fc222a79000 r--p  libc-2.13.so
7fc222a79000-7fc222a7a000 rw-p  libc-2.13.so
7fc222a7a000-7fc222a80000 rw-p 
7fc222a80000-7fc222aa1000 r-xp ld-2.13.so
7fc222c77000-7fc222c7a000 rw-p  
7fc222c9d000-7fc222ca0000 rw-p 
7fc222ca0000-7fc222ca1000 r--p ld-2.13.so
7fc222ca1000-7fc222ca3000 rw-p ld-2.13.so
7fff01379000-7fff0139a000 rw-p [stack]
Memory Layout of a Process 
Memory Layout of a Process 
Layout of Executable in Memory
Memory Layout: Our Perspective
Memory Layout: Our Perspective
ld.so's link_map structures
Fun Ways to Craft Metadata
 Change entrypoint to point to injected code
 Inject object files (mayhem, phrack 61:8)
 Intercept library calls to run injected code
 Injected in executable
 Cesare PLT redirection (Phrack 56:7)
 Mayhem ALTPLT (Phrack 61:8)
 Resident in attacker-built library
 LD_PRELOAD (example: Jynx-Kit rootkit)
 DT_NEEDED (Phrack 61:8)
 Loaded at runtime (Cheating the ELF, the grugq)
 Injected in library
 LOCREATE (Skape, Uniformed 2007)
 Unpack binaries using relocation entries
More fun with relocation entries
Warning. The following you are about to see is 
architecture and libc implementation dependant.  
Please try this at home, but there are no 
guarantees it will work with your architecture/gcc 
toolchain combination.
(Ours is Ubuntu 11.10's eglibc-2.13 on amd64)
Not all Brainfuck instructions work in presence of ASLR
This is proof of concept, after all.
Image: “Caution” Sam Ahmed, from The Noun Project
Injecting Relocation/Symbol tables
 Use eresi toolkit
 Injects into executable's data segment
Inject metadata here
Relocation Entry Type Primer
 Let r be our Elf64_Rela, s be the corresponding 
Elf64_Sym (if applicable)
 R_X86_64_COPY
 memcpy(r.r_offset, s.st_value, s.st_size)
 R_X86_64_64
 *(base+r.r_offset) = s.st_value +r.r_addend+base
 R_X86_64_32
 Same as _64, but only writes 4 bytes
 R_X86_64_RELATIVE
 *(base+r.r_offset = r.r_addend+base)
           typedef struct {
               Elf64_Addr r_offset;
               uint64_t   r_info; // contains type and symbol number
               int64_t    r_addend;
           } Elf64_Rela;
Relocation & STT_IFUNC symbols
 Symbols of type STT_IFUNC are special
 st_value treated as a function pointer
 Trivial example of indirect functions:
    43: 0000000000400524    11 FUNC    LOCAL  DEFAULT    13 f1
    44: 000000000040052f     11 FUNC    LOCAL  DEFAULT    13 f2
    57: 000000000040053a    29 FUNC    GLOBAL DEFAULT   13 foo_ifunc
    62: 000000000040053a    29 IFUNC   GLOBAL DEFAULT   13 foo
#include 
int foo (void) __attribute__ ((ifunc ("foo_ifunc")));
static int global = 1;
static int f1 (void) { return 0; }
static int f2 (void){ return 1; }
void *foo_ifunc (void) { return global == 1 ? f1 : f2; }
int main () { printf ("%d\n", foo()); }
 Corresponding symbol table entries:
 Musical IInterlude: I'm My Own Grandpa
(Why Reloc Entries are so Powerful)
Source: Ray Stevens on https://www.youtube.com/watch?v=eYlJH81dSiw
Brainfuck Primer
 8 instructions:
1) > Increment the pointer.
2)  Increment the pointer.