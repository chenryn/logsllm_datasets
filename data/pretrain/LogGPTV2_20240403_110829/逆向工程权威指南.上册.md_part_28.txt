DWORD PTR _a$[e8p-4], 0FFSET $SG2800 : '3, 4, 5′
20
$LN3ef:
jap
gadduT sia C80R
22
21
mov
DMORD PTR _a$[esp-4], 0FFSET $SG2802 : *8, 9, 21*
23
24 SLN2ef:
mp
D80RD PTR _impprintf
25
nov
22.  082099 435430 *[>ds9]se" 81d 08080
26
27 $LN1ef:
jmp
DMORD PTR _imp._printf
2B
ipd
mov
DMORD PTR _a$[esp-4], OFFSET $SG2806 : default'
29
30
2  align $LN118f table on 16-byte boundary
DMORD PTR
_imp_printf
31 $LN11ef:
32
DD
$LN5ef : print *1, 2, 7, 10′
33
$LN4ef 1 print *3,4, 5'
34
DD
$IN2er; print *22
SIN38f ; print *8, 9, 21′
35
DD
$INlef i print *default*
37 $LN108f:
BC
6C
BG
DB
0 ; a=1
40
DB
0 ; a=2
41
1 ; a=3
4.2
DB
DB
1 ; a=5
b=e:
43
DB
44
DB
11
a=6
45
2:
3=7
4 6
DB
2:
a=B
47
DB
a=10
6=f
48
49
DB
DB
a=12
3=11
50
51
DB
DB
a=13
52
DB
d~14
53
a=15
54
B0
4：
4：
a=17
a=16
55
s6
DB
DB
4 ; a=18
57
DB
2 ; a=20
4 1 a=19
85
59
80
DB
2 :a=21
3 : a=22
60 _f
ENDP
这个程序用到了两个表：一个是索引表SLN10@f：另一个是转移表SLN11@f。
第13行的movzx指令在索引表里查询输入值。
索引表的返回值又分为0（输入值为1、2、7、10）、1（输入值为3、4、5）、2（输入值为8、9、21）、
3（输入值为22）、4（其他值）这5种情况。
程序把索引表的返回值作为关键字，再在第二个转移表里进行查询，以完成相应跳转（第14行指令的作用）。
需要注意的是，输入值为0的情况没有相应的case从句。如果a=0，则“deccax”指令会继续进行计
算，而SLN10@f表的查询是从1开始的。可见，没有必要为0的特例设置单独的表。
---
## Page 165
第13章switch/case/default
147
这是一种普遍应用的编译技术。
表面看来，这种双表结构似乎不占优势。为什么它不象前文（请参见13.2.1节）那样采用一个统一的指
针结构呢？在这种双表结构中，索引表采用的是byte型数据，所以双表结构比前面那种单表结构更为紧凑。
13.3.2GCC
在编译这种多对一的switch语句时，GCC会生成统一的转移表。其代码风格和前文13.2.1节的风格
相同。
13.3.3ARM64: Optimizing GCC 4.9.1
因为输入值为零的情况没有对应的处理方法，所以GCC会从输入值为1的特例开始枚举各个分支，
以便把转移表压缩得尽可能小。
GCC4.9.1forARM64的编译技术更为优越。它能把所有的偏移量信息编码为8位字节型数据、封装在单条
指令的opcode里。前文介绍过，ARM64程序的每条指令都对应着4个字节的opcode。在本例这种类型的小型
代码中，各分支偏移量的具体数值不会很大。GCC能够充分利用这一现象，构造出单字节指针组成的转移表。
指令清单13.11OptimizingGCC4.9.1ARM64
 input valoe in W0
f14:
cap
sub
w0, w0, 11
 branch if less or
w0, 21
equal (unsigned) :
-L2:
b1s
6T'
 print “default":
adrp
ad
x0,.LC4
x0, x0,:1012:,1C4
-L9:
b
put.s
 load jumptable address to X1:
adrp
add
x1, x1, :1o12:,L4
x1, .14
[nTe"nduT=0 
: load byte from the table:
: load address of the Lrtx labe1:
1drb
0,[x1,w0,uxt]
 multiply table elenent by 4 (by shifting 2 bits left) and add (or subtract) to the address of 1rtx
adr.
x1, .Lrtx4
add
x0,x1, v0,sxtb #2
 jump to the calculated address1
: this 1abel is point.ing in code (text.) segnent:
br
x0
-Lrtx:
 evezything after *,section* statement Is allocated In the read-only data (rodata) segment:
.section
.rodata
byte
[.L3 -.Lrtx4) / 4:case 1
.byte
(.L3 - ,Lrtx4)
-byte
(.15 - ,Lrtx4)
/4icase 2
(.L5 - ,Lrtx4)
/4
/ 4;case 4
;c88e 3
byte
byte
byte
(.15 - .Lrtx4)
(.L5 -
-Lrtx4)
/4
/4
case 5
[.L3 -
:case 6
byte
byte
(.16 -
-Lrtx4)
-Lrtx4)
/4
Jcase 7
byte
[.L6 - .Lrtx4)
/4icase 9
:c8se 8
byte
(.12 - ,Lrtx4) / 4 1caae 11
(.13 - .Lrtx4)
byte
/4
case 10
byte
(.L2 - ,Lrtx4)
/ 4 icase 12
byte
[.L2 - ,Lrtx4) / 4 icase 13
---
## Page 166
148
逆向工程权威指南（上册）
-byte
(.L2 - .Lrtx4) / 4 :case 14
byte
(.12 -.Lrtx4) / 4case 16
(.12
-Lrtx4)
/4
Jcase 15
-byte
byte
(.L2 -
-Lrtx) / 4
-byte
(.L2 -
-Lrtx4)
/4
Jcase 17
(.12 -Lrtx4) / 4
:c88e 18
-byte
(.L6
Jcase 19
eq
.byte
(.L6
-Lrtx4)
-Lrtx4)
1/4
/4
:case 21
;case
20
-byte
(.L7 -
-Lrtx4) / 4
.text
Jcase 22
J everything after
*,text* statenent is allocated in the code (text) segnent:
 print *22*
.L7:
adrp
x0, x0, :1o12:.LC3
x0,-LC3
add
.16:
b
put.s
pzint
*8,9, 21#
adrp
x0,
x0,:1012:.LC2
.LC2
add
puts
x0,
.L5:
/ print
*3, 4, 5*
adrp
x0, -LC1
add
x0, x0, :1o12:,LC1
.L3:
b
puts
 print
*1, 2,
7,10*
adrp
add
x0,.1c0
x0，x0,:1012:,LC0
-LC0:
b
puts
string *1, 2, 7, 10*
.LC1:
.1C2:
string *3, 4, 5*
.string *B, 9, 21"
.1C3±
string *22*
.1C4:
inegep. butxae
把上述程序编译为obj文件，然后再使用IDA打开，可看到其转移表如下。
指令清单 13.12jumptable in IDA
-rodata:0000000000000064
AREA rodata, DATA, READONLY
-rodata: 0000000000000064
：ORG0x64
- rodata: 0000000000000064
P$
DCB
3
case 1
.rodata:000000000000
-rodata: 0000000000000066
S900C
DCB
DCB
: case 2
DCB
case 3
- rodata: 0000000000000067
-. rodata: 0000000000000068
DCB
中
J case 5
case 4
10000000000:epo2*
-rodata: 0000000000000069
DCB
case
case 6
- rodata: 000000000000006B
006A
DCB
DCB
 case 8
7
.rodata: 000000000000006c
DCB
-rodata:000000000000006D
DCB
6 883 ;
DCB 0xF7
 case
: case 11
10
.rodata:000000000000006F
.rodata:0000000000000070
DCB
0xF7
0xF7
 case
DCB
: case
12
. rodata: 0000000000000071
DCB 0xE7
J case 14
13
rodata: 00000000000
10072
DCB
DCB 0×F7
0xE7
: case
1case 16
15
-rodata: 0000000000000074
DCB
DCB
0xF7
-rodata:0000000000000075
0xF7
Jcase
:case
17
-rodata:0000000000000076
DCB 0xF7
f case 19
18
---
## Page 167
第13章switch/case/default
149
rodata:0000000000000077
DCB
rodata:000000000000078
3
1 case 20
-rodasta:0000000000000079
DCB
DCB
0
1case 21
.rodata:0000000000007B : -rodata ends
1 case 22
当输入值为1时，目标偏移量的技术方法是：9乘以4、再加上Lrtx4的偏移量。当输入值为22时，
目标偏移量为：0乘以4、结果为0。在转移表Lrtx4之后就是L7的标签的指令了，这部分指令将负责打
印数字22。请注意，转移表位于单独的.rodata段。编译器没有把它分配到.text的代码段里。
上述转移表有一个负数0xF7。这个偏移量指向了打印默认字符串（L2标签）的相关指令。
13.4Fall-through
SwitchO语句还有一种常见的使用方法—fall-through。
1 define R 1
2 #define W 2
5 void f(int type)
6
了
int read=0, write=0;
switch (type)
10
11
case RW:
1
12
13
case W:
read=1;
14
breakI
vrite=1;
15
16
1.7
case R:
breakJ
read=1;
19
18
20
default:
breakJ
21
22
1:
23 1:
printf (*read=td, write=id\n*, read, write):
如果type为1（参见第一行可知，这是读取权限R为真的情况），则read的值会被设置为1：如果type
为2（W），则write被设置1：如果type为3（RW），则read和 write 的值都会被设置为1。
无论type的值是RW还是W，程序都会执行第14行的指令。type为RW的陈述语句里没有break指
令，从而利用switch语句的fallthrough 效应。
13.4.1MSVCx86
指令清单13.13MSVC2012
$SG1305 DB
'read=ld, write=ld', 0aH, 008
_vrite$ = -12
: size= 4
_reads
= -B
- =9
: size= 4
: size= 4