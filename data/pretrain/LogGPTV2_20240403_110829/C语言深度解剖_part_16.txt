看例子：
void fun(char a[10])
{
char c = a[3];
}
intmain()
{
char b[10] = ‚abcdefg‛;
fun(b[10]);
return 0;
}
先看上面的调用，fun(b[10]);将b[10]这个数组传递到fun 函数。但这样正确吗？
b[10]是代表一个数组吗？
显然不是，我们知道b[0]代表是数组的一个元素，那b[10]又何尝不是呢？只不过这里
数组越界了，这个b[10]并不存在。但在编译阶段，编译器并不会真正计算b[10]的地址并
取值，所以在编译的时候编译器并不认为这样有错误。虽然没有错误，但是编译器仍然给出
了两个警告：
warning C4047: 'function' : 'char *' differs in levels of indirection
from 'char '
warning C4024: 'fun' : different types for formal and actual parameter
1
这是什么意思呢？这两个警告告诉我们，函数参数需要的是一个char*类型的参数，而
实际参数为char 类型，不匹配。虽然编译器没有给出错误，但是这样运行肯定会有问题。
如图：
这是一个内存异常，我们分析分析其原因。其实这里至少有两个严重的错误。
第一：b[10]并不存在，在编译的时候由于没有去实际地址取值，所以没有出错，但是
在运行时，将计算b[10]的实际地址，并且取值。这时候发生越界错误。
第二：编译器的警告已经告诉我们编译器需要的是一个char*类型的参数，而传递过去
的是一个char 类型的参数，这时候fun 函数会将传入的char 类型的数据当地址处理，同
样会发生错误。（这点前面已经详细讲解）第一个错误很好理解，那么第二个错误怎么理解
呢？fun 函数明明传递的是一个数组啊，编译器怎么会说是char *类型呢？别急，我们先
- 86 -
把函数的调用方式改变一下：
fun(b);
b 是一个数组，现在将数组b 作为实际参数传递。这下该没有问题了吧？调试、运行，
一切正常，没有问题，收工！很轻易是吧?但是你确认你真正明白了这是怎么回事？数组b
真的传递到了函数内部？
4.6.1.2 无法向函数传递一个数组
我们完全可以验证一下：
void fun(char a[10])
{
int i = sizeof（a）；
char c = a[3];
}
如果数组b 真正传递到函数内部，那i 的值应该为10。但是我们测试后发现i 的值竟
然为4！为什么会这样呢？难道数组b 真的没有传递到函数内部？是的，确实没有传递过去，
这是因为这样一条规则：
C 语言中，当一维数组作为函数参数的时候，编译器总是把它解析成一个指向其首元
素首地址的指针。
这么做是有原因的。在C 语言中，所有非数组形式的数据实参均以传值形式（对实参做
一份拷贝并传递给被调用的函数，函数不能修改作为实参的实际变量的值，而只能修改传递
给它的那份拷贝）调用。然而，如果要拷贝整个数组，无论在空间上还是在时间上，其开销
都是非常大的。更重要的是，在绝大部分情况下，你其实并不需要整个数组的拷贝，你只想
告诉函数在那一刻对哪个特定的数组感兴趣。这样的话，为了节省时间和空间，提高程序运
行的效率，于是就有了上述的规则。同样的，函数的返回值也不能是一个数组，而只能是指
针。这里要明确的一个概念就是：函数本身是没有类型的，只有函数的返回值才有类型。很
多书都把这点弄错了，甚至出现“XXX 类型的函数”这种说法。简直是荒唐至极！
经过上面的解释，相信你已经理解上述的规定以及它的来由。上面编译器给出的提示，
说函数的参数是一个char*类型的指针，这点相信也可以理解。既然如此，我们完全可以把
fun 函数改写成下面的样子：
void fun(char *p)
{
char c = p[3]; //或者是char c = *(p+3);
}
同样，你还可以试试这样子：
void fun(char a[10])
{
char c = a[3];
}
intmain()
{
char b[100] = ‚abcdefg‛;
fun(b);
return 0;
- 87 -
}
运行完全没有问题。实际传递的数组大小与函数形参指定的数组大小没有关系。既然如
此，那我们也可以改写成下面的样子：
void fun(char a[ ])
{
char c = a[3];
}
改写成这样或许比较好，至少不会让人误会成只能传递一个10 个元素的数组。
4.6.2 一级挃针参数
4.6.2.1 能否把指针变量本身传递给一个函数
我们把上一节讨论的列子再改写一下：
void fun(char *p)
{
char c = p[3]; //或者是char c = *(p+3);
}
intmain()
{
char *p2 = ‚abcdefg‛;
fun（p2）;
return 0;
}
这个函数调用，真的把p2 本身传递到了fun 函数内部吗？
我们知道p2 是main 函数内的一个局部变量，它只在main 函数内部有效。（这里需要
澄清一个问题：main 函数内的变量不是全局变量，而是局部变量，只不过它的生命周期和
全局变量一样长而已。全局变量一定是定义在函数外部的。初学者往往弄错这点。）既然它
是局部变量，fun 函数肯定无法使用p2 的真身。那函数调用怎么办？好办：对实参做一份
拷贝并传递给被调用的函数。即对p2 做一份拷贝，假设其拷贝名为_p2。那传递到函数内
部的就是_p2 而并非p2 本身。
4.6.2.2 无法把指针变量本身传递给一个函数
这很像孙悟空拔下一根猴毛变成自己的样子去忽悠小妖怪。所以fun 函数实际运行时，
用到的都是_p2 这个变量而非p2 本身。如此，我们看下面的例子：
void GetMemory（char * p, int num）
{
p = (char *)malloc(num*sizeof(char));
}
intmain()
{
- 88 -
char *str = NULL;
GetMemory（str，10）;
strcpy(str,‛hello‛);
free（str）；//free 并没有起作用，内存泄漏
return 0;
}
在运行strcpy(str,‛hello‛)语句的时候发生错误。这时候观察str 的值，发现仍然
为NULL。也就是说str 本身并没有改变，我们malloc 的内存的地址并没有赋给str，而是
赋给了_str。而这个_str 是编译器自动分配和回收的，我们根本就无法使用。所以想这样
获取一块内存是不行的。那怎么办? 两个办法：
第一：用return。
char * GetMemory（char * p, int num）
{
p = (char *)malloc(num*sizeof(char));
return p；
}
intmain()
{
char *str = NULL;
str = GetMemory（str，10）;
strcpy(str,‛hello‛);
free（str）；
return 0;
}
这个方法简单，容易理解。
第二：用二级指针。
void GetMemory（char ** p, int num）
{
*p = (char *)malloc(num*sizeof(char));
return p；
}
intmain()
{
char *str = NULL;
GetMemory（&str，10）;
strcpy(str,‛hello‛);
free（str）；
return 0;
}
注意，这里的参数是&str 而非str。这样的话传递过去的是str 的地址，是一个值。
在函数内部，用钥匙（“*”）来开锁：*(&str)，其值就是str。所以malloc 分配的内存
地址是真正赋值给了str 本身。
另外关于malloc 和free 的具体用法，内存管理那章有详细讨论。
- 89 -
4.6.3 二维数组参数不二维挃针参数
前面详细分析了二维数组与二维指针，那它们作为参数时与不作为参数时又有什么区别
呢？看例子：
void fun（char a[3][4]）;
我们按照上面的分析，完全可以把a[3][4]理解为一个一维数组a[3]，其每个元素都是
一个含有4 个char 类型数据的数组。上面的规则，“C 语言中，当一维数组作为函数参数
的时候，编译器总是把它解析成一个指向其首元素首地址的指针。”在这里同样适用，也就
是说我们可以把这个函数声明改写为：
void fun（char (*p)[4]）;
这里的括号绝对不能省略，这样才能保证编译器把p 解析为一个指向包含4 个char 类
型数据元素的数组，即一维数组a[3]的元素。
同样，作为参数时，一维数组“[]”号内的数字完全可以省略：
void fun（char a[ ][4]）;
不过第二维的维数却不可省略，想想为什么不可以省略？
注意：如果把上面提到的声明void fun（char (*p)[4]）中的括号去掉之后，声明“void
f un（char *p[4]）”可以改写成：
void fun（char **p）;
这是因为参数*p[4]，对于p 来说，它是一个包含4 个指针的一维数组，同样把这个一
维数组也改写为指针的形式，那就得到上面的写法。
上面讨论了这么多，那我们把二维数组参数和二维指针参数的等效关系整理一下：
这里需要注意的是：C 语言中，当一维数组作为函数参数的时候，编译器总是把它解析
成一个指向其首元素首地址的指针。这条规则并不是递归的，也就是说只有一维数组才是如
此，当数组超过一维时，将第一维改写为指向数组首元素首地址的指针之后，后面的维再也
不可改写。比如：a[3][4][5]作为参数时可以被改写为（*p）[4][5]。至于超过二维的数
组和超过二级的指针，由于本身很少使用，而且按照上面的分析方法也能很好的理解，这里
就不再详细讨论。有兴趣的可以好好研究研究。
4.7 函数挃针
4.7.1 函数挃针的定义
顾名思义，函数指针就是函数的指针。它是一个指针，指向一个函数。看例子：
A)，char * (*fun1)(char * p1,char * p2);
B)，char * *fun2(char * p1,char * p2);
C)，char * fun3(char * p1,char * p2);
数组参数等效的指针参数
- 90 -
数组的数组：char a[3][4] 数组的指针：char (*p)[10]
指针数组： char *a[5] 指针的指针：char **p
看看上面三个表达式分别是什么意思？
C）：这很容易，fun3 是函数名，p1，p2 是参数，其类型为char *型，函数的返回