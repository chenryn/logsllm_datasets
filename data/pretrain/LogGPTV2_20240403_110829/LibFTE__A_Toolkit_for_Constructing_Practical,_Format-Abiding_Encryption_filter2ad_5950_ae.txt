default.
In all conﬁgurations except PSQL, when per-
forming modiﬁcations to the database we perform an en-
crypt when storing the account balance. When retrieving
the account balance we recover the plaintext via a call to
the decryption algorithm.
In Table 8 we have the have the benchmark results
for transactions per second carried out by the server for
our four database conﬁgurations and three transaction
types. For the most complex transaction type (USUUI)
our +FPE conﬁguration reduces the number of transac-
tions per seconds by only 0.8%, compared to the +AE
conﬁguration. For the simplest query type (S), +FPE
reduces the transactions-per-second rate by only 1.1%,
compared to +AE. Compared to the +AES conﬁguration
the +AE and +FPE reduce the transactions per second
by roughly 72%. This is, in fact, not surprising as under
the hood the +FPE conﬁguration relies on FFX, which in
turn calls AES at least ten times.
In Table 9 we have the average latency for each of the
ﬁve different query types. This measures the amount
of time elapsed between a client request and server re-
sponse. Compared to the +AE conﬁguration, +FPE in-
troduces no substantial latency.
Simultaneous encryption and compression. As one ﬁ-
nal test, we deploy a T-DD scheme in our PostgreSQL
888  23rd USENIX Security Symposium 
USENIX Association
12
Account Balance Queries
Average Latency (ms)
Query
(U) accounts
(S) accounts
(U) tellers
(U) branches
(I) history
PSQL
0.6
0.4
412
78
0.2
+AES
1.2
0.5
412
80
0.2
+AE
2.1
1.0
415
80
0.2
+FPE
2.1
1.0
420
84
0.2
Table 9: Average latency per query for each database
conﬁguration.
Credit Card Number Queries
Table Size
Query Avg.
PSQL
50MB
74ms
+AES
65MB
92ms
+AE
112MB
112ms
+FPECC
50MB
125ms
+FTECC
42MB
110ms
Table 10: FTE for simultaneous encryption and compres-
sion. The table size is the amount of space required on
disk to store the table. We also present the average query
time (over 1,000 trials) for selecting (and decrypting) 100
credit card numbers at random from 1 million records.
database to provide simultaneous privacy and compres-
sion. We augment the default pgbench database schema
to add a new table for credit card numbers. This table has
two columns: an account number of type integer and
a credit card number ﬁeld of type bytea. (Following
the structure of the pgbench schema, we do not add any
indexes to this table.) We start with the four conﬁgura-
tions we presented in our initial benchmarks. However,
we change our +FPE conﬁguration to a P-DD scheme
that encrypts 16-digit credit card number in-place and
call this +FPECC. Then we introduce a new conﬁgura-
tion, +FTECC, a T-DD scheme where our input format
is a 16-digit credit card number and our output format is
the set of all 7-byte strings.
In each conﬁguration we populated our database with
1 million random credit card numbers. For each database
conﬁguration, we have a breakdown (Table 10) of the
query cost to retrieve 100 credit card numbers at ran-
dom (and decrypt, if required) as well as the total size
of the new credit card table. Compared to the +AES and
+AE conﬁguration, our +FTECC conﬁguration requires
35% and 62.5% less space, respectively. We note that it
may be possible to employ additional compression in the
PSQL, +FPECC settings (e.g., an int to bitstring conver-
sion). However, such optimizations are not possible in
the +AES and +AE conﬁgurations.
We also highlight that, with respect to query times
(Table 10) our +FTECC conﬁguration modestly outper-
forms the +AE conﬁguration. Compared to +AES,
+FTECC introduces a 19.5% increase in query cost.
7.2 Web Forms
Next, we present a Firefox extension powered by libfte.
The job of this browser extension is to encrypt sensitive
contact information, client-side, in a Yahoo address book
contact form, prior to submission to the remote Yahoo
servers.
Browser extension. We tested our libfte-extension with
Firefox version 26, using our C++-to-JavaScript com-
piled libfte API. In addition to libfte , in roughly 200
lines of code, we implemented logic that was responsi-
ble for locating page elements to encrypt/decrypt. The
Yahoo-speciﬁc logic was minimal and consisted of map-
pings between form ﬁelds and FPE/FTE schemes.
Fields were manually speciﬁed using unique identi-
ﬁers (e.g., CSS id tags) and mapped to their correspond-
ing P-DD FPE scheme in JavaScript. There are many
options for determining what input/output formats to use
for a given scheme. For this proof-of-concept we started
with a set of formats we considered to be reasonable,
then progressively relaxed/increased constraints on the
formats appropriately until they were accepted by Ya-
hoo’s server-side validation. As a couple examples, we
found that the email address ﬁeld is required to have an
@ symbol, and all dates are required to be valid date
ranges. (e.g., month must between 1 and 12 inclusive)
We expect that such constraints could be identiﬁed pro-
grammatically, at scale, using a browser automation tool
such as Selenium [2].
Our Firefox extension exposes an “encrypt/decrypt”
drop-down menu to the user. Prior to saving a new con-
tact to their address book, the user can press the “en-
crypt” button to automatically libfte-encrypt all ﬁelds in
the form. To recover the encrypted data, they user visits
the page for a contact, then presses the libfte extension’s
decrypt button to recover the plaintext data. With fur-
ther engineering efforts this encryption/decryption pro-
cess could be transparent to the user. We present a
screenshot of our extension in Figure 11.
7.3 Network Monitors
Finally, we turn our attention to building T-xx-$ schemes
(as used in [11]) by lifting regular expressions from the
Snort IDS [19]. As far as these authors are aware, this
Snort IDS corpus of regular expressions is the largest and
most diverse (publicly available) set of regexes used for
deep-packet inspection.
In the initial exploration of FTE by Dyer et al. [11]
a fundamental limitation to their construction was the
need to perform a regex-to-DFA conversion for formats.
Unfortunately, this creates a natural asymmetry: systems
USENIX Association  
23rd USENIX Security Symposium  889
13
Figure 12: The CDF representing the fraction of the
Snort corpus that can be instantiated for a given memory
threshold. The CDF graph has a long tail and reaches
100% at 143MB for T-DN-$. We were unable to cal-
culate the threshold for T-DD-$ to reach 100%, due to
memory constraints on our test system.
pus that can be instantiated when constrained by a given
memory threshold, for each scheme. At 1MB, roughly
60% of the corpus can be instantiated using T-DD-$
ranking, compared to roughly 85% of the corpus with
T-DN-$ ranking. At 5MB, T-DN-$ is at roughly 97% and
T-DD-$ is at roughly 92%. If we increase the threshold
to 143MB (beyond the focus of the graph) we can instan-
tiate 100% of the corpus using T-DN-$. Yet, at at thresh-
old of 1GB, we are able to instantiate only 97.0% of the
corpus using T-DD-$.
In fact we were unable to con-
struct some schemes (due to memory constraints) using
T-DD-$, so we don’t know the exact threshold required
to reach 100% instantiation.
As a ﬁnal test we measured the total memory utiliza-
tion for instantiating the complete Snort corpus.
Ini-
tially, we instantiated all regular expressions in the cor-
pus using T-DD-$, which required a cumulative 8.8GB
of memory. Then we considered a “best case” scenario,
where, over the 97% of tractable regexs (those that we
could construct a T-DD-$ scheme) we took the minimum
of the T-DD-$ or T-DN-$ memory utilization. Using
the best-case approach we reduced memory utilization to
6.2GB, a reduction of roughly 30%. The best-case sce-
nario is, of course, biased against T-DN-$, as 3% of the
corpus couldn’t be instantiated with T-DD-$.
8 Conclusion
In this paper we presented a unifying approach for de-
ploying format-preserving encryption (FPE) and format-
transforming encryption (FTE) schemes. The approach
is realized via a library we call libfte, which has two
components: an ofﬂine conﬁguration assistant to aid en-
gineers in developing formats and understanding their
system-level implications, and an API for instantiating
Figure 11: Screenshot from our Firefox Browser Ex-
tension that encrypts the data ﬁelds of our Yahoo ad-
dress book, client-side, prior to transmission to the Ya-
hoo servers.
such as Snort are able to perform network monitoring di-
rectly from an NFA representation, but the construction
presented by Dyer et al. requires regex-to-DFA conver-
sion. In this section we show that we’ve overcome this
limitation — regular expressions that were intractable us-
ing the construction by Dyer et al. are no longer an ob-
stacle, given our new NFA ranking algorithm.
Snort IDS regex corpus. To build our corpus, we started
with the ofﬁcial Snort ruleset, version 2955, released Jan
14, 2014. Each rule in the ruleset contains a mixture of
values, including static strings or regular expressions to
match against trafﬁc. From each rule we extracted all
regular expressions (as deﬁned by the pcre ﬁeld) which
resulted in 6,277 expressions. Of these, 3,458 regular ex-
pressions compiled with our regular expression parser5.
For all regular expressions that compiled, if we were able
to instantiate their precomputation table in memory, we
were able to successfully utilize them for encryption.
Corpus evaluation. For each regular expression R in
the Snort corpus we attempted to build a T-DD-$ and
T-DN-$ scheme with an output format F   (R, 0, 256),
and input format that is a blog2 |L(F)|c-bit string. This
choice of libfte scheme and ↵ and β is motivated by the
construction in [11].
In Figure 12 we plot the CDF of the fraction of the cor-
5We don’t support greedy operators *? or case insensitivity
(?i...), which accounted for the majority of compilation failures.
Greedy operators are used for parsing, not for language deﬁnition, and
we do not support extended patterns of the form (?...) in general.
890  23rd USENIX Security Symposium 
USENIX Association
14
12345Threshold(MB)0.30.40.50.60.70.80.91.0CDF(%underthreshold)T-DN-$vs.T-DD-$T-DN-$T-DD-$[10] Debra L. Cook, Angelos D. Keromytis, and Moti Yung.
Elastic block ciphers: the basic design. pages 350–352,
2007.
[11] Kevin P. Dyer, Scott E. Coull, Thomas Ristenpart, and
Thomas Shrimpton. Protocol misidentiﬁcation made easy
with format-transforming encryption. In Proceedings of
the 20th ACM Conference on Computer and Communica-
tions Secuirty (CCS 2013), November 2013.
[12] A Goldberg and M Sipser. Compression and ranking. In
Proceedings of the seventeenth annual ACM symposium
on Theory of computing, STOC ’85, pages 440–448, New
York, NY, USA, 1985. ACM.
[13] Shaﬁ Goldwasser and Silvio Micali. Probabilistic en-
Journal of Computer and System Sciences,
cryption.
28(2):270–299, 1984.
[14] Shai Halevi. EME*: Extending EME to handle arbitrary-
length messages with associated data. pages 315–327,
2004.
[15] Shai Halevi and Phillip Rogaway. A tweakable encipher-
ing mode. pages 482–499, 2003.
[16] Daniel Lachaup, Kevin P. Dyer, Somesh Jha, Thomas
Ristenpart, and Thomas Shrimpton. LibFTE: A toolkit
for constructing practical,
format-abiding encryption
schemes (full version), 2014. Available from authors’
websites.
[17] Moses Liskov, Ronald L Rivest, and David Wagner.
In Advances in Cryptology-
Tweakable block ciphers.
CRYPTO 2002, pages 31–46. Springer, 2002.
[18] Chanathip Namprempre, Phillip Rogaway, and Thomas
Shrimpton. Reconsidering generic composition. In Ad-
vances in Cryptology – EUROCRYPT ‘14, LNCS, pages
257–274. Springer-Verlag, 2014.
[19] Martin Roesch. Snort - lightweight intrusion detection
for networks. In Proceedings of the 13th USENIX Con-
ference on System Administration, LISA ’99, pages 229–
238, Berkeley, CA, USA, 1999. USENIX Association.
[20] Phillip Rogaway. A synopsis of format-preserving en-
cryption. Unpublished manuscript, March 2010.
[21] Rich Schroeppel. An overview of the hasty pudding ci-
pher, July 1998.
In the development
and deploying FPE/FTE schemes.
of libfte we overcame a number of obstacles. Most no-
tably, we developed a new approach to perform FPE/FTE
directly from the NFA representation of a regular expres-
sion, which was previously considered to be impractical.
This signiﬁcantly increases the expressiveness of regular
languages for which FTE can be made useful in practice,
and generally improves system efﬁciency, potentially
making FTE a viable cryptographic option in contexts
where it previously was not. We studied libfte perfor-
mance empirically in several application contexts, ﬁnd-
ing that it typically introduces negligible performance
overhead relative to conventional encryption.
In some
cases (e.g. simultaneous compressions and encryption)
even enables substantial performance improvements.
Our work surfaces many avenues for future research.
To name a few: investigate the security of libfte’s algo-
rithms (and FTE implementations, in general) in the face
of side-channel attacks; integrate FTE into additional ap-
plications, and report on newly found algorithmic and
engineering challenges; and explore efﬁciency improve-
ments for speciﬁc classes of regular expressions that are
in wide use. To promote further research and develop-
ment, we will make libfte open source and publicly avail-
able at https://libfte.org/.
References
[1] Perl regular expressions man page. http://perldoc.perl.
org/perlre.html, February 2014.
[2] Seleniumhq:
Browser
automation.
http://www.
seleniumhq.org/, February 2014.
[3] Voltage security.
http://www.voltage.com/, February
2014.
[4] Mihir Bellare and Chanathip Namprempre. Authenticated
encryption: Relations among notions and analysis of the
generic composition paradigm. pages 531–545, 2000.
[5] Mihir Bellare, Thomas Ristenpart, Phillip Rogaway, and
Till Stegers. Format-preserving encryption. In Selected
Areas in Cryptography, pages 295–312. Springer-Verlag,
2009.
[6] Mihir Bellare and Phillip Rogaway.
Encode-then-
encipher encryption: How to exploit nonces or redun-
dancy in plaintexts for efﬁcient cryptography. pages 317–
330, 2000.
[7] Mihir Bellare, Phillip Rogaway, and Terence Spies. The
ffx mode of operation for format-preserving encryption
draft 1.1, 2010.
[8] John Black and Phillip Rogaway. Ciphers with arbitrary
In Topics in Cryptology–CT-RSA 2002,
ﬁnite domains.
pages 114–130. Springer Berlin Heidelberg, 2002.
[9] Debrup Chakraborty and Mridul Nandi. An improved se-
curity bound for HCTR. pages 289–302, 2008.
USENIX Association  
23rd USENIX Security Symposium  891
15