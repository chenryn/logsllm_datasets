title:You Can't Be Me: Enabling Trusted Paths and User Sub-origins in Web
Browsers
author:Enrico Budianto and
Yaoqi Jia and
Xinshu Dong and
Prateek Saxena and
Zhenkai Liang
You Can’t Be Me: Enabling Trusted Paths and User
Sub-origins in Web Browsers
Enrico Budianto1, Yaoqi Jia1, Xinshu Dong2, Prateek Saxena1, and Zhenkai Liang1
1 National University of Singapore
2 Advanced Digital Sciences Center
{enricob,jiayaoqi,prateeks,liangzk}@comp.nus.edu.sg,
PI:EMAIL
Abstract. Once a web application authenticates a user, it loosely associates all
resources owned by the user to the web session established. Consequently, any
scripts injected into the victim web session attain unfettered access to user-owned
resources, including scripts that commit malicious activities inside a web appli-
cation. In this paper, we establish the ﬁrst explicit notion of user sub-origins to
defeat such attempts. Based on this notion, we propose a new solution called
USERPATH to establish an end-to-end trusted path between web application users
and web servers. To evaluate our solution, we implement a prototype in Chromium,
and retroﬁt it to 20 popular web applications. USERPATH reduces the size of
client-side TCB that has access to user-owned resources by 8x to 264x, with
small developer effort.
Keywords: User sub-origins, trusted path, script injection attacks.
1 Introduction
Many of the web applications today, such as DropBox, Gmail and Facebook, provide
user-oriented services, where users need to create their own accounts to use the service
tailored to them. User-oriented web applications isolate data belonging to individual
users and bind access control privileges to speciﬁc user accounts (e.g., owners or ad-
ministrators). In such web applications, the authority of a user is typically represented
by a web session, and the security mechanisms are centered on protecting the web ses-
sion state from being accessed by attackers. In such a setting, if an attacker is able to
inject scripts into the session, the scripts run with user’s full authority. In this paper, we
do not focus on mechanisms to prevent web application vulnerabilities from occurring.
Rather, we propose mechanisms to defend against post-attack malicious behavior of an
injected script, which we term as post-injection script execution (PISE) attacks. Our
proposal serves as a second line of defense when existing mechanisms of script injec-
tion prevention, such as Content Security Policy [1], fail to achieve full coverage [2].
PISE attacks are the aftermath of script-injection attacks that occur in a variety of
ways, such as mixed content (over HTTP) in HTTPS sessions [3], loading malicious
third-party scripts [4], or via XSS attacks [5]. The threat model in PISE attacks is
strong and challenging to counteract: injected scripts already run under the same ori-
gin as the web application. In this work, we focus on PISE attacks that target sensitive
A. Stavrou et al. (Eds.): RAID 2014, LNCS 8688, pp. 150–171, 2014.
c(cid:2) Springer International Publishing Switzerland 2014
Enabling Trusted Paths and User Sub-origins in Web Browsers
151
data owned by users and mimic normal user interactions within a web application. For
example, XSS worms on Facebook proﬁles that utilize self-XSS attacks to befriend cer-
tain users [6] or malicious extensions that stealthily steal authentication credentials and
hijack user accounts [7] are some of the real-world examples.
We observe two fundamental limitations of the present web platform. First, to defeat
PISE attacks, browsers need to have the notion of a user authority that controls access
to sensitive user-owned resources. The same-origin policy does not support such access
control. Second, there is no direct way for server-side web applications to be faithfully
informed about user’s interaction at the client-side. As a result, web servers cannot,
for example, distinguish between web requests generated in response to legitimate user
interaction versus requests generated by injected scripts, even in the presence of web
sessions protection mechanisms like HTTPS. A recent line of research has proposed
piecemeal defenses to mitigate some classes of PISE attacks via client-side channels [8,
9], server-side channels [10, 11], self-exﬁltration [12], or using attacks that mimic user
interactions to legitimize dangerous information ﬂows [13]. However, none of them
offer a comprehensive solution to prevent PISE attacks completely.
Our Solution. We propose a solution called USERPATH, which augments the present
web platform with a security primitive that explicitly represents a User authority and
establishes an end-to-end trusted Path between the user and the server. We introduce
the ﬁrst explicit notion of user sub-origins1 into web applications, which are primitives
that run with the authority of web application users. Our mechanism enables user sub-
origins to isolate user’s data and privilege-separate the code operating on it from the rest
of the web origin. Thus, our mechanism tightens the authority of the web application
users from web sessions to user-suborigins. To support our end-to-end system, we build
a trusted path between human users and the web application server [15]. A trusted path
in our work is deﬁned as a privileged channel, which allows the server to tightly and
reliably control the communication of visible content and input with the user (via the
standard DOM APIs), even in the presence of malicious application code. Although
this concept has recently been explored to develop new access control mechanisms
on mobile and traditional operating systems [15, 16], building it for the web has only
recently been investigated [9].
Our solution is easy to deploy in practice – with a small number of changes in
existing browsers and web applications, USERPATH can be set up to protect users
from PISE attacks. We reuse the existing web isolation primitives and minimize new
abstractions added. Our solution is a 475 lines of code patched on Chromium 12.
USERPATH-enabled browsers are backward-compatible with non-USERPATH-enabled
websites. From the user’s perspective, using a USERPATH-enabled website would be
largely identical to the original site, except for verifying a colored login input box when
authenticating with a password (see Section 4). As a result, USERPATH has a much
lower adoption cost as compared to another recent trusted-path proposal that requires
generation and uploading of SSL keys for every website [9]. Furthermore, our solution
1 Recently, browsers have added support for per-page sub-origins [14] that compartmentalize
contents on a web page within several sub-authorities under the same origin. The per-page
sub-origin proposal offers no guarantee to defend against PISE attacks, and we complement
per-page sub-origins with the additional notion of user authority and trusted path.
152
E. Budianto et al.
can also be easily deployed with modest development effort. Speciﬁcally, developers
can easily retroﬁt web applications to use USERPATH simply by privilege-separating
sensitive data and JavaScript logic on a client-side user-suborigins called UFrame.
UFrame is an iframe-like component that isolates code under a different JavaScript
context and has the ability to render tamper-proof HTML elements. Such privilege sep-
aration of JavaScript code is straightforward for developers to use, as argued in recent
works [17, 18].
From a security standpoint, users no longer trust a website at the time of login if
script injection vulnerabilities are present in the website. Then, how does a user login
and setup an authenticated trusted path? We address this critical issue by introducing
secure UI elements [16] that protect user’s login credential from malicious client-side
code and using a PAKE protocol [19]. A PAKE protocol is a zero knowledge protocol
that lets two parties authenticate each other without revealing secret information (e.g., a
password) through the communication channel. Having authenticated the user, USER-
PATH maintains isolation of sensitive resources throughout the session by resorting to
user sub-origins and a trusted path.
Summary of Results. We deploy USERPATH on 20 popular open-source web applica-
tions. The evaluation demonstrates that our solution can protect user-owned data from
PISE attacks in these applications with modest adoption effort (in the order of days).
For each application, we label a number of data ﬁelds as sensitive, and modify the ap-
plication logic to use USERPATH abstractions. We ﬁnd that USERPATH eliminates the
threats to user data from 325 historical security vulnerabilities in these applications,
and reduces the trusted computing base (TCB) size by 8x to 264x. Finally, the perfor-
mance overhead incurred by our solution is negligible for real-world applications. All
case studies and the Chromium-based implementation are available online [20], and we
release a video demonstrating the smooth user experience with a USERPATH-enabled
browser [21].
Contributions. In summary, we make the following contributions in the paper:
– End-to-end Solution. Our main contribution lies in analyzing the attack model we
term as PISE attacks, examining the various dimensions of attacks, and providing
an end-to-end solution to defeat them. We adapt and combine some known tech-
niques with our new ones to achieve a solution that is easy to deploy on the existing
web platform. To the best of our knowledge, this is the ﬁrst comprehensive defense
against PISE attacks targeting user-owned resources, which is a signiﬁcant subset
of self-exﬁltration attacks [12].
– User Sub-Origins & Trusted Path. We propose the ﬁrst explicit notion of user sub-
origins on the web. We further develop an end-to-end trusted path to eliminate PISE
attacks targeting user-owned data.
2 Problem Deﬁnition
The missing notion of user sub-origins in today’s web sessions gives rise to various
attacks threatening web applications. We summarize such attacks and elaborate how
they can occur in an existing web application.
Enabling Trusted Paths and User Sub-origins in Web Browsers
153
2.1 PISE Attacks Targeting User-owned Data
Unlike in traditional OSes (e.g., UNIX), there is no built-in notion of a user authority on
the present web, where users login into sites and authenticate themselves using custom
password-based interfaces. Authentication of subsequent HTTP requests is performed
via “bearer tokens”, such as session IDs, CSRF tokens, or cookies. In the presence of
script injection vulnerabilities, these tokens are prone to attacks, either via direct token
stealing [22], phishing attempts [23], or session riding (e.g., fake HTTP request [24]).
In this paper, we term such illegitimate accesses from malicious scripts to resources
owned by benign victim users as post-injection script execution (PISE) attacks.
(cid:48)(cid:68)(cid:79)(cid:79)(cid:82)(cid:85)(cid:92)
(cid:53)(cid:82)(cid:79)(cid:72)(cid:3)(cid:29)(cid:3)(cid:3)(cid:49)(cid:82)(cid:85)(cid:80)(cid:68)(cid:79)(cid:3)(cid:88)(cid:86)(cid:72)(cid:85)
(cid:57)(cid:76)(cid:70)(cid:87)(cid:76)(cid:80)
(cid:53)(cid:82)(cid:79)(cid:72)(cid:3)(cid:29)(cid:3)(cid:3)(cid:36)(cid:71)(cid:80)(cid:76)(cid:81)(cid:76)(cid:86)(cid:87)(cid:85)(cid:68)(cid:87)(cid:82)(cid:85)
(cid:20)
(cid:3)(cid:3)(cid:3)(cid:3)(cid:39)(cid:44)(cid:54)(cid:51)(cid:47)(cid:36)(cid:60)(cid:29)(cid:3)
(cid:37)(cid:85)(cid:82)(cid:90)(cid:86)(cid:72)(cid:85)(cid:3)(cid:85)(cid:72)(cid:81)(cid:71)(cid:72)(cid:85)(cid:86)(cid:3)(cid:90)(cid:72)(cid:69)(cid:3)
(cid:70)(cid:82)(cid:81)(cid:87)(cid:72)(cid:81)(cid:87)(cid:15)(cid:3)(cid:76)(cid:81)(cid:70)(cid:79)(cid:88)(cid:71)(cid:76)(cid:81)(cid:74)(cid:3)
(cid:88)(cid:86)(cid:72)(cid:85)(cid:16)(cid:82)(cid:90)(cid:81)(cid:72)(cid:71)(cid:3)(cid:71)(cid:68)(cid:87)(cid:68)
(cid:36)(cid:87)(cid:87)(cid:68)(cid:70)(cid:78)(cid:72)(cid:85)(cid:3)(cid:76)(cid:81)(cid:77)(cid:72)(cid:70)(cid:87)(cid:86)(cid:3)
(cid:86)(cid:70)(cid:85)(cid:76)(cid:83)(cid:87)(cid:86)(cid:3)(cid:87)(cid:75)(cid:85)(cid:82)(cid:88)(cid:74)(cid:75)(cid:3)
(cid:85)(cid:72)(cid:73)(cid:79)(cid:72)(cid:70)(cid:87)(cid:72)(cid:71)(cid:3)(cid:59)(cid:54)(cid:54)(cid:3)(cid:68)(cid:87)(cid:87)(cid:68)(cid:70)(cid:78)(cid:3)
(cid:82)(cid:85)(cid:3)(cid:80)(cid:68)(cid:79)(cid:76)(cid:70)(cid:76)(cid:82)(cid:88)(cid:86)(cid:3)(cid:87)(cid:75)(cid:76)(cid:85)(cid:71)(cid:16)
(cid:83)(cid:68)(cid:85)(cid:87)(cid:92)(cid:3)(cid:86)(cid:70)(cid:85)(cid:76)(cid:83)(cid:87)(cid:86)
(cid:40)(cid:79)(cid:74)(cid:74)(cid:3)(cid:54)(cid:72)(cid:85)(cid:89)(cid:72)(cid:85)
(cid:21)
(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:44)(cid:49)(cid:51)(cid:56)(cid:55)(cid:3)(cid:29)(cid:3)
(cid:57)(cid:76)(cid:70)(cid:87)(cid:76)(cid:80)(cid:3)(cid:76)(cid:81)(cid:87)(cid:72)(cid:85)(cid:68)(cid:70)(cid:87)(cid:86)(cid:3)(cid:90)(cid:76)(cid:87)(cid:75)(cid:3)
(cid:76)(cid:81)(cid:83)(cid:88)(cid:87)(cid:3)(cid:72)(cid:79)(cid:72)(cid:80)(cid:72)(cid:81)(cid:87)(cid:86)
(cid:56)(cid:44)
(cid:48)(cid:68)(cid:79)(cid:76)(cid:70)(cid:76)(cid:82)(cid:88)(cid:86)(cid:3)
(cid:54)(cid:70)(cid:85)(cid:76)(cid:83)(cid:87)(cid:86)
(cid:37)(cid:72)(cid:81)(cid:76)(cid:74)(cid:81)
(cid:54)(cid:70)(cid:85)(cid:76)(cid:83)(cid:87)(cid:86)
(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:53)(cid:40)(cid:52)(cid:56)(cid:40)(cid:54)(cid:55)(cid:29)(cid:3)
(cid:23)
(cid:73)(cid:82)(cid:85)(cid:80)(cid:86)(cid:18)(cid:88)(cid:86)(cid:72)(cid:85)(cid:68)(cid:71)(cid:71)(cid:17)(cid:83)(cid:75)(cid:83)
(cid:37)(cid:53)(cid:50)(cid:58)(cid:54)(cid:40)(cid:53)(cid:3)
(cid:54)(cid:40)(cid:53)(cid:57)(cid:44)(cid:38)(cid:40)(cid:54)
(cid:39)(cid:50)(cid:48)
(cid:36)(cid:51)(cid:44)
(cid:49)(cid:72)(cid:87)(cid:90)(cid:82)(cid:85)(cid:78)
(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:54)(cid:40)(cid:54)(cid:54)(cid:44)(cid:50)(cid:49)(cid:3)(cid:39)(cid:36)(cid:55)(cid:36)(cid:29)(cid:3)
(cid:3)(cid:22)
(cid:37)(cid:72)(cid:81)(cid:76)(cid:74)(cid:81)(cid:3)(cid:86)(cid:70)(cid:85)(cid:76)(cid:83)(cid:87)(cid:86)(cid:3)(cid:29)(cid:3)(cid:68)(cid:70)(cid:70)(cid:72)(cid:86)(cid:86)(cid:76)(cid:81)(cid:74)(cid:3)(cid:70)(cid:82)(cid:81)(cid:87)(cid:68)(cid:70)(cid:87)(cid:3)(cid:71)(cid:68)(cid:87)(cid:68)
(cid:48)(cid:68)(cid:79)(cid:76)(cid:70)(cid:76)(cid:82)(cid:88)(cid:86)(cid:3)(cid:86)(cid:70)(cid:85)(cid:76)(cid:83)(cid:87)(cid:86)(cid:3)(cid:29)(cid:3)(cid:86)(cid:87)(cid:72)(cid:68)(cid:79)(cid:76)(cid:81)(cid:74)(cid:3)(cid:70)(cid:82)(cid:82)(cid:78)(cid:76)(cid:72)(cid:86)(cid:15)(cid:3)
(cid:76)(cid:81)(cid:87)(cid:72)(cid:85)(cid:70)(cid:72)(cid:83)(cid:87)(cid:76)(cid:81)(cid:74)(cid:3)(cid:88)(cid:86)(cid:72)(cid:85)(cid:3)(cid:76)(cid:81)(cid:83)(cid:88)(cid:87)(cid:15)(cid:3)(cid:72)(cid:87)(cid:70)(cid:17)(cid:3)
(cid:54)(cid:68)(cid:80)(cid:72)(cid:16)(cid:86)(cid:76)(cid:87)(cid:72)(cid:3)(cid:85)(cid:72)(cid:84)(cid:88)(cid:72)(cid:86)(cid:87)(cid:3)(cid:70)(cid:85)(cid:68)(cid:73)(cid:87)(cid:72)(cid:71)(cid:3)
(cid:87)(cid:82)(cid:3)(cid:68)(cid:71)(cid:71)(cid:3)(cid:48)(cid:68)(cid:79)(cid:79)(cid:82)(cid:85)(cid:92)(cid:3)(cid:68)(cid:86)(cid:3)(cid:36)(cid:71)(cid:80)(cid:76)(cid:81)
Fig. 1. Example Interactions in Elgg. Solid lines illustrate benign interactions between the user,
UI elements and session data. Dashed lines illustrate the examples of PISE attacks, where an
attacker injects malicious scripts into the victim’s session, steals the victim’s CSRF token, and
performs a same-site request forgery attack to the Elgg server.
We illustrate various PISE attacks with a real-world social networking application
called Elgg2. Elgg maintains user proﬁles, manages private message dispatch and blog-
ging, and integrates itself with other social networking sites. Consider the following
features available to administrators:
– Add New User: This is a privileged feature that can only be accessed by administra-
tors. The administrator speciﬁes information belonging to a particular user that is
going to be added to the system. The administrator can also mark the user as a new
administrator by identifying it on a checkbox element. Thereafter, this particular
information is sent to the server using HTML Form submit mechanism.
– Proﬁle Management: Elgg provides proﬁle data management to maintain particular
information for each user, similar to most social networking applications. In addi-
tion, there is a feature to set other users as administrators directly from their proﬁle
pages. However, this feature is privileged to an administrator. The administrator
can add another user as an administrator by clicking on “Make admin” link on the
user’s proﬁle page.
2 http://elgg.org/
154
E. Budianto et al.
In PISE attacks, injected scripts can access user-owned resources (e.g., the state of
“is admin” checkbox of a user) located at the client side and the server side, as shown
in Figure 1. We systematically analyze the various channels available to PISE attacks.
At the client side, we categorize three variants of PISE attacks depending on different
channels that are exposed to an attacker.
– Display Channel Attacks. An attacker can tamper with display elements of a web
application to steal sensitive information from users. Two examples of attacks that
exploit this channel are UI defacing and phishing for user credentials. In UI de-
facing attacks, an attacker alters the web content to mislead users. For instance, a
malicious extension can change the appearance of a proﬁle page in Facebook [6].
Besides, malicious scripts can also introduce fake UI elements (such as fake login
input) to steal users’ credentials, therefore allowing them to impersonate as Alice
on a site O. Unlike traditional phishing attacks where a malicious website mimics
another benign website, in this example the malicious scripts are running within
the victim origin O. Therefore, common security indicators such as SSL lock icons
and URL bars do not help Alice in detecting the phishing attempt.
– Input Channel Attacks. In order to tamper with sensitive data, an attacker can ex-
ploit this channel by (1) intercepting or stealing user input; or (2) launching an attack
that programmatically interacts with the interface element of the web [13,16]. In the
second scenario, malicious scripts can impersonate a user by forging a user inter-
action with the DOM element on the web page (e.g., auto-clicking the “add user”
button) and mimic the user’s action. Another popular attack that exploits this chan-
nel (and the display channel) is clickjacking [25], which typically runs in a different
website than on Elgg. It can, for instance, load Elgg in a transparent overlay. Then
underneath Elgg, it can render another malicious web page to attract users to click
on the “Make admin” button in the invisible Elgg layer above. Clickjacking attacks
sabotage a user’s intention to interact with a UI element as intended by an attacker.
– Session Data Channel Attacks. Malicious scripts injected into the web page have
access to arbitrary data. It can exﬁltrate sensitive data, including cookies, CSRF
tokens, capability-bearing URLs, and passwords, through two channels: directly
to an attacker-controlled website [8] or via the victim’s website itself, which is
recently discussed and termed as self-exﬁltration attacks by Chen et.al. [12]. Due
to lack of input sanitization on Elgg’s “edit page” functionality [26], cookie data
can be stolen and exﬁltrated using XSS attacks via a public blog entry, which is
visible to the attacker. This is a conﬁrmed security bug and has been documented
as a CVE entry [27].
In addition to these three attack variants, the injected scripts have access to the net-
work, allowing the attacker to access server-side resources of the user.
– Network Request Channel Attacks. Malicious scripts can craft and send HTTP
requests to the server by invoking XMLHttpRequest API, or using HTML’s re-
source tag attributes, such as a src attribute in an  tag. Such crafted re-
quests can be used to perform speciﬁc operations on the server-side application.
Some websites implement CSRF tokens that are sent along with HTTP requests
and server-side applications verify whether the incoming requests carry expected
CSRF tokens. However, secret CSRF tokens and other existing defenses for CSRF
Enabling Trusted Paths and User Sub-origins in Web Browsers
155
attacks, such as Referer and Origin headers [28], do not sufﬁce for preventing
requests forged by PISE attacks, as the injected scripts run in the same origin.
2.2 Insufﬁciency of Existing Solutions
Many existing solutions provide piecemeal defenses against PISE attacks. In Table 1,
we brieﬂy compare existing second line of defense techniques to mitigate this class
of attacks. The comparison is categorized based on the four channels exposed to the
attackers (Section 2.1). As Table 1 summarizes, none of them provides full protection
for the four channels against malicious scripts injected into victim web sessions. We
refer readers to Section 6 for a detailed comparison with previous solutions. We propose
a user-based end-to-end trusted path that comprehensively protects all the four channels.
Table 1. Various Techniques for Mitigating PISE Attacks
HTML5 Privilege Separation [18]
HTML5 Data Conﬁnement [8]
Object-Capability Sec Model [30, 31]
PathCutter [24]
Request Triggering Attribution [13]
Adsentry [34]
USERPATH
3
2
II
III
√
√ √
√
√ √
√ √
√
4
IV
3
1
I
2
II
III
√
√ √ √
√ √
√ √