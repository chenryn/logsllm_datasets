# You Can't Be Me: Enabling Trusted Paths and User Sub-origins in Web Browsers

**Authors:**
- Enrico Budianto¹
- Yaoqi Jia¹
- Xinshu Dong²
- Prateek Saxena¹
- Zhenkai Liang¹

¹ National University of Singapore  
² Advanced Digital Sciences Center

**Contact:**  
{enricob, jiayaoqi, prateeks, liangzk}@comp.nus.edu.sg, PI:EMAIL

## Abstract
After a web application authenticates a user, it loosely associates all resources owned by the user with the established web session. Consequently, any scripts injected into the victim's web session gain unfettered access to user-owned resources, including those that perform malicious activities within the web application. In this paper, we introduce the first explicit notion of user sub-origins to counter such threats. Based on this concept, we propose a new solution called USERPATH, which establishes an end-to-end trusted path between web application users and web servers. To evaluate our solution, we implemented a prototype in Chromium and retrofitted it to 20 popular web applications. USERPATH reduces the size of the client-side TCB (Trusted Computing Base) that has access to user-owned resources by 8x to 264x, with minimal developer effort.

**Keywords:** User sub-origins, trusted path, script injection attacks.

## 1. Introduction
Many modern web applications, such as Dropbox, Gmail, and Facebook, provide user-oriented services where users create accounts to access personalized services. These applications isolate data belonging to individual users and bind access control privileges to specific user accounts (e.g., owners or administrators). The authority of a user is typically represented by a web session, and security mechanisms are centered on protecting the session state from attackers. If an attacker injects scripts into the session, these scripts run with the user's full authority. This paper does not focus on preventing web application vulnerabilities but rather proposes mechanisms to defend against post-attack malicious behavior of injected scripts, termed as post-injection script execution (PISE) attacks. Our proposal serves as a second line of defense when existing mechanisms, such as Content Security Policy [1], fail to achieve full coverage [2].

PISE attacks can occur through various means, such as mixed content (over HTTP) in HTTPS sessions [3], loading malicious third-party scripts [4], or via XSS attacks [5]. The threat model in PISE attacks is strong and challenging to counteract: injected scripts already run under the same origin as the web application. We focus on PISE attacks targeting sensitive user-owned data and mimicking normal user interactions within a web application. Real-world examples include XSS worms on Facebook profiles that utilize self-XSS attacks to befriend certain users [6] and malicious extensions that stealthily steal authentication credentials and hijack user accounts [7].

We observe two fundamental limitations of the current web platform:
1. To defeat PISE attacks, browsers need a notion of user authority to control access to sensitive user-owned resources, which the same-origin policy does not support.
2. There is no direct way for server-side web applications to be reliably informed about user interactions at the client side, making it difficult to distinguish between legitimate user interactions and requests generated by injected scripts, even with HTTPS.

Recent research has proposed piecemeal defenses to mitigate some classes of PISE attacks via client-side channels [8, 9], server-side channels [10, 11], self-exfiltration [12], or using attacks that mimic user interactions to legitimize dangerous information flows [13]. However, none of these solutions offer comprehensive protection against PISE attacks.

### Our Solution
We propose USERPATH, a solution that augments the current web platform with a security primitive explicitly representing a User authority and establishing an end-to-end trusted Path between the user and the server. We introduce the first explicit notion of user sub-origins, which are primitives that run with the authority of web application users. This mechanism enables user sub-origins to isolate user data and privilege-separate the code operating on it from the rest of the web origin, thereby tightening the authority of the web application users from web sessions to user sub-origins. To support our end-to-end system, we build a trusted path between human users and the web application server [15]. A trusted path in our work is defined as a privileged channel that allows the server to tightly and reliably control the communication of visible content and input with the user, even in the presence of malicious application code.

Our solution is easy to deploy in practice, requiring only a few changes in existing browsers and web applications. We reuse existing web isolation primitives and minimize new abstractions. Our solution is a 475-line patch on Chromium 12, and USERPATH-enabled browsers are backward-compatible with non-USERPATH-enabled websites. From the user's perspective, using a USERPATH-enabled website is largely identical to the original site, except for verifying a colored login input box during authentication (see Section 4). As a result, USERPATH has a much lower adoption cost compared to other recent trusted-path proposals that require generating and uploading SSL keys for every website [9]. Additionally, developers can easily retrofit web applications to use USERPATH by privilege-separating sensitive data and JavaScript logic in a client-side user-suborigin called UFrame. UFrame is an iframe-like component that isolates code under a different JavaScript context and can render tamper-proof HTML elements. Such privilege separation is straightforward for developers, as argued in recent works [17, 18].

From a security standpoint, users should not trust a website at the time of login if script injection vulnerabilities are present. To address this, we introduce secure UI elements [16] that protect user login credentials from malicious client-side code and use a PAKE protocol [19]. A PAKE protocol is a zero-knowledge protocol that allows two parties to authenticate each other without revealing secret information (e.g., a password) through the communication channel. After authenticating the user, USERPATH maintains isolation of sensitive resources throughout the session by using user sub-origins and a trusted path.

### Summary of Results
We deployed USERPATH on 20 popular open-source web applications. Our evaluation shows that our solution can protect user-owned data from PISE attacks with modest adoption effort (in the order of days). For each application, we labeled a number of data fields as sensitive and modified the application logic to use USERPATH abstractions. We found that USERPATH eliminates the threats from 325 historical security vulnerabilities in these applications and reduces the TCB size by 8x to 264x. The performance overhead incurred by our solution is negligible for real-world applications. All case studies and the Chromium-based implementation are available online [20], and we released a video demonstrating the smooth user experience with a USERPATH-enabled browser [21].

### Contributions
In summary, we make the following contributions in this paper:
- **End-to-End Solution:** We analyze the attack model we term as PISE attacks, examine the various dimensions of attacks, and provide an end-to-end solution to defeat them. To the best of our knowledge, this is the first comprehensive defense against PISE attacks targeting user-owned resources, which is a significant subset of self-exfiltration attacks [12].
- **User Sub-Origins & Trusted Path:** We propose the first explicit notion of user sub-origins on the web and develop an end-to-end trusted path to eliminate PISE attacks targeting user-owned data.

## 2. Problem Definition
The lack of a notion of user sub-origins in today's web sessions gives rise to various attacks threatening web applications. We summarize such attacks and elaborate on how they can occur in an existing web application.

### 2.1 PISE Attacks Targeting User-Owned Data
Unlike in traditional operating systems (e.g., UNIX), there is no built-in notion of a user authority on the current web. Users log in to sites and authenticate themselves using custom password-based interfaces. Authentication of subsequent HTTP requests is performed via "bearer tokens," such as session IDs, CSRF tokens, or cookies. In the presence of script injection vulnerabilities, these tokens are prone to attacks, either via direct token stealing [22], phishing attempts [23], or session riding (e.g., fake HTTP request [24]). We term such illegitimate accesses from malicious scripts to resources owned by benign victim users as post-injection script execution (PISE) attacks.

We illustrate various PISE attacks with a real-world social networking application called Elgg. Elgg maintains user profiles, manages private message dispatch and blogging, and integrates itself with other social networking sites. Consider the following features available to administrators:
- **Add New User:** This is a privileged feature accessible only by administrators. The administrator specifies information for a new user, which is then sent to the server using an HTML Form submit mechanism. The administrator can also mark the user as a new administrator by checking a checkbox element.
- **Profile Management:** Elgg provides profile data management to maintain information for each user. Administrators can set other users as administrators directly from their profile pages.

In PISE attacks, injected scripts can access user-owned resources (e.g., the state of the "is admin" checkbox of a user) located at the client side and the server side, as shown in Figure 1. We systematically analyze the various channels available to PISE attacks. At the client side, we categorize three variants of PISE attacks depending on different channels exposed to an attacker:
- **Display Channel Attacks:** An attacker can tamper with display elements of a web application to steal sensitive information from users. Examples include UI defacing and phishing for user credentials. In UI defacing attacks, an attacker alters the web content to mislead users. Malicious scripts can also introduce fake UI elements (such as fake login inputs) to steal users' credentials, allowing them to impersonate as Alice on a site O. Unlike traditional phishing attacks, common security indicators like SSL lock icons and URL bars do not help Alice detect the phishing attempt.
- **Input Channel Attacks:** An attacker can exploit this channel by intercepting or stealing user input or programmatically interacting with the interface element of the web. Malicious scripts can impersonate a user by forging a user interaction with the DOM element (e.g., auto-clicking the "add user" button) and mimic the user's action. Another popular attack that exploits this channel (and the display channel) is clickjacking, which typically runs in a different website than on Elgg. It can load Elgg in a transparent overlay and render another malicious web page underneath to attract users to click on the "Make admin" button in the invisible Elgg layer above.
- **Session Data Channel Attacks:** Malicious scripts injected into the web page have access to arbitrary data. They can exfiltrate sensitive data, including cookies, CSRF tokens, capability-bearing URLs, and passwords, through two channels: directly to an attacker-controlled website [8] or via the victim's website itself, which is recently discussed and termed as self-exfiltration attacks by Chen et al. [12]. Due to a lack of input sanitization on Elgg’s "edit page" functionality [26], cookie data can be stolen and exfiltrated using XSS attacks via a public blog entry, which is visible to the attacker. This is a confirmed security bug and has been documented as a CVE entry [27].

In addition to these three attack variants, the injected scripts have access to the network, allowing the attacker to access server-side resources of the user.
- **Network Request Channel Attacks:** Malicious scripts can craft and send HTTP requests to the server by invoking the XMLHttpRequest API or using HTML resource tag attributes, such as the `src` attribute in an `<img>` tag. Such crafted requests can be used to perform specific operations on the server-side application. Some websites implement CSRF tokens that are sent along with HTTP requests, and server-side applications verify whether the incoming requests carry expected CSRF tokens. However, secret CSRF tokens and other existing defenses for CSRF attacks, such as Referer and Origin headers [28], do not suffice for preventing requests forged by PISE attacks, as the injected scripts run in the same origin.

### 2.2 Insufficiency of Existing Solutions
Many existing solutions provide piecemeal defenses against PISE attacks. In Table 1, we briefly compare existing second-line-of-defense techniques to mitigate this class of attacks. The comparison is categorized based on the four channels exposed to the attackers (Section 2.1). As Table 1 summarizes, none of them provides full protection for the four channels against malicious scripts injected into victim web sessions. We refer readers to Section 6 for a detailed comparison with previous solutions. We propose a user-based end-to-end trusted path that comprehensively protects all four channels.

| Technique | Display Channel | Input Channel | Session Data Channel | Network Request Channel |
|-----------|-----------------|---------------|----------------------|-------------------------|
| HTML5 Privilege Separation [18] | √ | √ | - | - |
| HTML5 Data Confinement [8] | - | - | √ | - |
| Object-Capability Security Model [30, 31] | - | - | √ | - |
| PathCutter [24] | - | - | - | √ |
| Request Triggering Attribution [13] | - | - | - | √ |
| Adsentry [34] | - | - | - | √ |
| **USERPATH** | √ | √ | √ | √ |

This table highlights the insufficiency of existing solutions and underscores the need for a comprehensive approach like USERPATH, which addresses all four channels of PISE attacks.