set by V, and embedded inside the token T . During attestation
responses aggregation, aggregators keep aggregating signatures on
bad software conﬁgurations only until the threshold is reached. Ev-
ery signature received afterwards is simply dropped. Consequently,
since dropping signatures renders the ﬁnal report unveriﬁable, if
report veriﬁcation fails, V deduces that the number of bad devices
has exceeded the threshold.
As shown in Figure 7, threshold attestation run in constant- time.
However, besides reaching the upper bound in the number of al-
lowed bad conﬁgurations, other factors, such as benign errors and
active (DoS) attacks, may cause a failure in the veriﬁcation of the
aggregate attestation response. For this reason, it is important to
verify that this result is indeed due to the existence of too many bad
devices. In order to tackle this problem, a potential solution is to
split the OAS signature into two parts: An aggregate signature (over
bad conﬁgurations), and a multi-signature (over the good conﬁgu-
ration). In this way, verifying the aggregate signature (in constant
time), gives V an assurance that the number of devices with bad
conﬁguration has exceeded the threshold. Additionally, V learns
identities and software conﬁgurations of such bad devices.
Figure 7: Run-time of SANA on an EC2 t2.micro [3] veriﬁer
9. BACKGROUND AND RELATED WORK
Individual Device Attestation is a well-established research area.
The main goal of an attestation process is to allow a veriﬁer to check
the integrity of the software running on a (potentially remote) device
(prover). We can distinguish three main approaches of attestation:
software-based, co-processor-based, and hybrid. Software-based
attestation [16, 31, 14, 19] requires no secure hardware and does
not rely on cryptographic secrets, making it particularly attractive
for low-end devices with limited resources. Unfortunately, the se-
curity of software-based attestation has been challenged [35], since
it is based on strong assumptions that are hard to achieve in prac-
tice [4]. As an example, software-based attestation assumes that
the attestation algorithm and its implementation are optimal, and
that the adversary is passive during the whole execution of the at-
testation protocol. Moreover, software-based attestation relies on
strict estimation of round trip times, requires an out-of-band authen-
tication channel, and is thus restricted to one hop communication,
and not suitable for remote attestation. Co-processor based attes-
tation schemes [27, 33, 18, 30, 22, 21], on the other hand, offer
improved security guarantees. However, they are more suitable for
general-purpose computing platforms, since their underlying secu-
rity hardware is often too complex and/or expensive for low-end
embedded devices. A third recently presented approach for attes-
tation is based on a hardware/software co-design [12, 17, 13, 11],
and aims for minimizing the hardware security features required for
enabling secure remote attestation. Such security features can be
as simple as a Read Only Memory (ROM), and a simple Memory
Protection Unit (MPU). SANA requires the same minimal hardware
support to implement collective attestation on the attested devices.
Collective Attestation. SEDA, the solution recently proposed
in [5], made a ﬁrst step towards a collective attestation, i.e., the
scalable attestation of large groups of interconnected devices. The
main focus of SEDA is efﬁciency and applicability to low-end de-
vices, rather than security in the presence of a strong adversary. To
that end, SEDA extends the software-only attacker assumed by most
 0 2 4 6 8 10 12 140 200k400k600k800k1MRun-time (s)Number of devices in the networkBinary tree4-ary tree8-ary tree12-ary tree 0 2 4 6 8 10 12 140 200k400k600k800k1MRun-time (s)Number of devices in the network4 neighbors8 neighbors12 neighbors 0 2 4 6 80 200k400k600k800k1MRun-time (s)Number of devices in the network4-ary tree (SANA)4-ary tree (SEDA) 0 2 4 6 80 200k400k600k800k1MRun-time (s)Number of devices in the network4-ary tree (SANA)4-ary tree (SEDA)4-ary tree (SEDA-ID) 0 1 2 3 4 5 6 0 1000 2000 3000 4000 5000Run-time (s)Number of malicious devices in the networkThresholdNo-extensionExtensionsingle-prover attestation schemes to, so-called, swarms of devices.
With this in mind, security hardware, used for protecting attesta-
tion code, is exploited to enable: (1) neighbors’ veriﬁcation, which
decreases the load on the veriﬁer; and (2) secure hop-by-hop aggre-
gation, which reduces the communication overhead. SEDA achieves
high efﬁciency and scalability through the distribution of the attesta-
tion burden across the whole network. It merely reports the number
of devices in the network that passed attestation. SEDA requires
(minimal) trust anchor in hardware for all involved nodes [5], and
therefore, it cannot operate in presence of a stronger attacker, i.e.,
an attacker capable of physically tampering devices. Indeed, if an
attacker violates the hardware security of one node, it may break the
overall security of the scheme for all other devices.
Our proposed collective attestation protocol SANA overcomes
the limitations of SEDA by: (i) requiring minimal trust anchor in
hardware only for the attested devices, (ii) allowing aggregation to
be performed by largely untrusted nodes, which are only required
for availability, and (iii) limiting the effect of successful attacks
on the hardware of an attested device to the device itself, i.e., it
will not affect the attestation of other devices. Similarly, Denial-of-
Service attacks on one device in SANA will not affect other devices.
Finally, SANA informs the veriﬁer with ids as well as software
conﬁgurations of the devices that failed attestation.
In Network Aggregation. To meet the aforementioned goals,
SANA employs in network aggregation. Several secure in network
aggregation protocols have been proposed in the sensor network
area, and in wireless sensor networks in particular, to provide scal-
able data collection from sensors [26]. In general, such aggregation
schemes allow a collection of sensors to collaboratively and securely
compute arbitrary aggregation functions on collected data, to reduce
message complexity. However, all these protocols have either a
veriﬁcation complexity which is linear in the number of nodes in
the network, or are built in multiple protocol rounds.
Aggregate Multi-Signatures. SANA requires a scalable aggregat-
able signature scheme, to allow attested devices in the network to
sign their state. Such scheme allows different signers with different
public keys to sign distinct messages. Moreover, it allows inter-
mediate nodes to securely aggregate individual signatures into a
single veriﬁable short signature. Unfortunately, all known aggregate
signature schemes have a veriﬁcation overhead that is linear in the
number of messages and signers, which renders them unsuitable for
scalable attestation. Additionally, they either require all messages to
be distinct, or a complex key agreement protocol [24], require a se-
quential order [9, 20], or all the signatures to be created on the same
message [6]. As a consequence, we consider none of the known
scheme as suitable for our collective attestation scheme. Recently,
the work in [32] proposed CoSi, a scalable witness cosigning system
for certiﬁcation, logging, and timestamping authorities that com-
bines existing multi-signature schemes with communication trees.
However, the protocol proposed in [32] considers static communica-
tion trees, constitutes multiple round-trips, and has communication
and computational overhead that are also linear in the number of
signers. Moreover, CoSi does not allow signing different messages,
and is thus not applicable to large scale network attestation.
For the reasons above, in this paper we present a new signature
scheme, Optimistic Aggregate Signature (OAS), that: (1) allows
signatures on distinct messages to be aggregated; and (2) provides
a signature veriﬁcation algorithm that is constant in the number of
signers. The communication overhead of the scheme is linear in the
number of different messages, while the computational overhead is
linear in the number signers who signed a different message than
the default one. However, this number is assumed limited. To the
best of our knowledge, our proposed OAS is the ﬁrst scheme that
satisﬁes the requirements of a secure collective attestation. Finally,
we present a pairings-based construction of OAS, and combine it
with aggregation trees, providing unlimited scalability. Our OAS
construction is also applicable to witness cosigning at certiﬁcation,
logging, and timestamping authorities [32].
10. CONCLUSIONS
Collective attestation is a key building block for securing the
Internet of Things. For very large numbers of devices, to enable
enterprises to validate the conﬁguration and software and ensure
that all devices are indeed up-to-date. In this paper, we have pro-
posed the ﬁrst practical and secure collective attestation scheme
SANA. It substantially improves the state of the art (e.g. SEDA
[5]) in three aspects: (1) it is easy to deploy since it can use any
untrusted aggregator; (2) its output is publicly veriﬁable since a
short aggregate attestation can be publicly veriﬁed by anyone; (3) it
provides superior security since it ensures that if a device is fully
compromised (including its hardware and keys), then other devices
are not affected at all; and (4) it allows a realistic trust model, where
only the attested devices are required to be trusted. We have demon-
strated that the protocol is truly scalable and can be implemented on
lightweight devices.
Acknowledgements
We thank anonymous reviewers for their useful comments. This
research was co-funded by the German Science Foundation, as part
of project S2 within CRC 1119 CROSSING, EC-SPRIDE, the Eu-
ropean Union’s 7th Framework Programme, under grant agreement
No. 609611, PRACTICE project, and Intel Collaborative Research
Institute for Secure Computing (ICRI-SC). This work is also par-
tially supported by the EU TagItSmart! Project (agreement H2020-
ICT30-2015-688061), and the EU-India REACH Project (agree-
ment ICI+/2014/342-896). Mauro Conti is supported by a Marie
Curie Fellowship funded by the European Commission (agreement
PCIG11-GA-2012-321980).
11. REFERENCES
[1] Target attack shows danger of remotely accessible HVAC
systems. http://www.computerworld.com/article/2487452/
cybercrime-hacking/target-attack-shows-danger-of-
remotely-accessible-hvac-systems.html, 2014.
[2] Jeep Hacking 101. http://spectrum.ieee.org/cars-that-think/
transportation/systems/jeep-hacking-101, 2015.
[3] Amazon EC2 Instance Types.
https://aws.amazon.com/ec2/instance-types/, 2016.
[4] F. Armknecht et al. A security framework for the analysis and
design of software attestation. In ACM CCS’13.
[5] N. Asokan et al. SEDA: Scalable Embedded Device
Attestation. In ACM CCS’15.
[6] A. Bagherzandi et al. Multisignatures secure under the
discrete logarithm assumption and a generalized forking
lemma. In ACM CCS’08.
[7] M. Bellare, C. Namprempre, and G. Neven. Unrestricted
aggregate signatures. In ICALP ’07.
[8] M. Bellare et al. Random oracles are practical: A paradigm
for designing efﬁcient protocols. In ACM CCS ’93.
[9] A. Boldyreva. Threshold signatures, multisignatures and blind
signatures based on the gap-difﬁe-hellman-group signature
scheme. In PKC ’03.
[10] D. Boneh et al. Aggregate and veriﬁably encrypted signatures
from bilinear maps. In EUROCRYPT’03.
[11] F. Brasser et al. Tytan: Tiny trust anchor for tiny devices. In
ACM/EDAC/IEEE DAC’15.
[12] K. Eldefrawy et al. SMART: Secure and minimal architecture
for (establishing a dynamic) root of trust. In NDSS’12.
[13] A. Francillon et al. A minimalist approach to remote
attestation. In DATE’14.
[14] R. Gardner et al. Detecting code alteration by creating a
temporary memory bottleneck. IEEE Transactions on
Information Forensics and Security, 2009.
[15] K. Itakura et al. A public-key cryptosystem suitable for digital
multisignatures. NEC Research & Development, 1983.
[16] R. Kennell et al. Establishing the genuinity of remote
computer systems. In USENIXSec’03.
[17] P. Koeberl et al. TrustLite: A security architecture for tiny
embedded devices. In ACM EuroSys’14.
[18] X. Kovah et al. New results for timing-based attestation. In
IEEE S&P’12.
[19] Y. Li et al. VIPER: Verifying the integrity of peripherals’
ﬁrmware. In ACM CCS’11.
[20] S. Lu et al. Sequential aggregate signatures, multisignatures,
and veriﬁably encrypted signatures without random oracles.
Journal of Cryptology, 2012.
[21] J. McCune et al. TrustVisor: Efﬁcient TCB reduction and
attestation. In IEEE S&P ’10.
[22] J. McCune et al. Flicker: An execution infrastructure for TCB
minimization. SIGOPS Operating Systems Review, 2008.
[23] S. Micali et al. Accountable-subgroup multisignatures:
extended abstract. In ACM CCS’01.
[24] S. Micali et al. Accountable-subgroup multisignatures:
Extended abstract. In ACM CCS’01.
[25] OpenSim Ltd. OMNeT++ discrete event simulator.
http://omnetpp.org/, 2015.
[26] S. Ozdemir and Y. Xiao. Secure data aggregation in wireless
sensor networks: A comprehensive overview. Computer
Networks, 2009.
[27] J. Petroni et al. Copilot — A coprocessor-based kernel
runtime integrity monitor. In USENIXSec’04.
[28] T. Ristenpart et al. The power of proofs-of-possession:
Securing multiparty signatures against rogue-key attacks. In
EUROCRYPT’07.
[29] M. Rubenstein et al. Programmable self-assembly in a
thousand-robot swarm. Science, 2014.
[30] D. Schellekens et al. Remote attestation on legacy operating
systems with trusted platform modules. Science of Computer
Programming, 2008.
[31] A. Seshadri et al. SAKE: Software attestation for key
establishment in sensor networks. In Ad Hoc Networks. 2011.
[32] E. Syta et al. Keeping authorities"honest or bust"with
decentralized witness cosigning. In IEEE S&P ’15.
[33] Trusted Computing Group (TCG). Website.
http://www.trustedcomputinggroup.org, 2015.
[34] T. Unterluggauer et al. Efﬁcient pairings and ECC for
embedded systems. In CHES ’14.
[35] G. Wurster et al. A generic attack on checksumming-based
software tamper resistance. In IEEE S&P ’05.
APPENDIX
A. SECURITY OF SANA
The security goal of any collective attestation scheme is to ensure
a veriﬁer V that all the devices in a network are running a software
that is known to, and accepted by V. In other words, V should
accept the attestation result, and declare the network G as benign,