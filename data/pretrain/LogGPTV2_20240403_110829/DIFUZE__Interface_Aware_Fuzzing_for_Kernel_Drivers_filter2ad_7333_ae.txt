-
2
3
2
4
3
2
1
-
10
22
5
6
3
5
2
-
13
34
3
6
2
5
2
0
12
30
5
6
3
6
2
0
14
36
configuration option, and a malicious userspace application can
read or write the privileged configuration options.
Adding a check to disallow modifications to privilege config-
uration options could fix this issue. It should not be possible for
Android kernel running at privilege level EL1 to read or write op-
tions that belong to the boot loader running at higher privilege.
Of course, the truly correct fix for this is to separate privileged
and unprivileged options, and store them on different partitions
accessible by differently-privileged code.
# before fuzzing
HWFRD:/ $ getprop ro.serialno
RNV0216811001641
# after fuzzing
HWFRD:/ $ getprop ro.serialno
^Rï£¡DO>l
Listing 6: A design issue found by DIFUZE while fuzzing nve
driver.
8.5 Case Study II: qseecom bug
In this section, we walk through an example of a bug that was
found only with the highest level of interface extraction (that is,
type recovery/complex structure instantiation). The relevant source
is shown below, which we will reference.
static int qseecom_mdtp_cipher_dip(void __user *argp)
{
struct qseecom_mdtp_cipher_dip_req req;
u32 tzbuflenin, tzbuflenout;
char *tzbufin = NULL, *tzbufout = NULL;
int ret;
do {
ret = copy_from_user(&req, argp, sizeof(req));
if (ret) {
pr_err("copy_from_user failed, ret= %d\n",
ret);
break;
}
...
/* Copy the input buffer from
userspace to kernel space */
tzbuflenin = PAGE_ALIGN(req.in_buf_size);
tzbufin = kzalloc(tzbuflenin, GFP_KERNEL);
if (!tzbufin) {
pr_err("error allocating in buffer\n");
ret = -ENOMEM;
break;
}
ret = copy_from_user(tzbufin, req.in_buf,
req.in_buf_size);
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
...
} while (0);
...
return ret;
}
long qseecom_ioctl(struct file *file, unsigned cmd,
unsigned long arg)
{
}
int ret = 0;
void __user *argp = (void __user *) arg;
switch (cmd) {
...
case QSEECOM_IOCTL_MDTP_CIPHER_DIP_REQ: {
...
ret = qseecom_mdtp_cipher_dip(argp);
break;
}
...
}
return ret;
Our example is that of CVE-2017-0612 (this is one of the four bugs
which was patched during the course of the experiments) [1]. This
bug was found by our system on Google’s flagship Android phone,
the Pixel. The ioctl function for the driver starts at line 31 and
follows the common design of ioctls. The userspace application
specifies cmd and arg.
Given the cmd QSEECOM_IOCTL_MDTP_CIPHER_DIP_REQ, we en-
ter qseecom_mdtp_cipher_dip on line 39. Inside this function, on
line 9, we see our user data copied into a struct
qseecom_mdtp_cipher_dip_req req. In line 16, we see the bug.
tzbuflenin is calculated by calling PAGE_ALIGN on our user con-
trolled value of req.in_buf_size. If a userspace application pro-
vides a large value here, PAGE_ALIGN will overflow, resulting in a
value smaller than req.in_buf_size, specifically zero. Next, on
line 17, we see an attempt to kalloc this calculated size. Finally,
on line 24, the driver attempts to copy_from_user an embedded
pointer in our struct to the allocated buffer. This copy_from_user
will result in a crash, as the size of the buffer was improperly calcu-
lated. Note, however, for this crash to be observed, the user supplied
req.in_buffer must be a valid pointer (else copy_from_user will
fail gracefully, and return an error). Thus, without a properly in-
stantiated argument to the ioctl, this crash will never be triggered.
Session J2:  Fun with FuzzingCCS’17, October 30-November 3, 2017, Dallas, TX, USA2134Table 6: Performance of coverage-guided fuzzing with and without interface information.
ioctl cmd ID
SCSI_IOCTL_SEND_COMMAND
CDROM_SEND_PACKET
Interface type
Simple Structure
Complex Structure
8.6 Augmenting with Coverage-guided Fuzzing
Coverage-guided fuzzing is a well-studied technique and was shown
to be an effective method to achieve good coverage [9]. Thus, a nat-
ural question arises: is interface awareness still needed if coverage-
guidance can be used? The answer is yes: providing interface infor-
mation for coverage-guided fuzzing will significantly improve its
performance on drivers.
To demonstrate, we ran syzkaller in the coverage-guided mode
on an x86-64 kernel, fuzzing ioctls SCSI_IOCTL_SEND_COMMAND
(which has a simple interface) and CDROM_SEND_PACKET (which has
a complex interface) with and without structure interface informa-
tion for four hours per combination. Table 6 shows the results of
these combinations, where the last column shows the percentage
increase in basic blocks reached when the interface information
was provided. This shows that interface information would still
significantly improve coverage-guided fuzzing performance.
Scaling this evaluation to our commercial devices is difficult due
to the necessity to recompile, often backporting kcov [36], and
re-flashing the kernel. This requires significant engineering effort,
outside the scope of this project.
9 DISCUSSION
We have shown that by using interface-aware fuzzing DIFUZE can
improve kernel security by uncovering potentially harmful bugs.
However, there are still some weaknesses of this approach and
directions for improvement, which we will review in this section.
9.1 Weaknesses
One problem, which we discovered while fuzzing, was that buggy
drivers could crash early on, preventing the fuzzer from exploring
deeper functionality in the driver. There are likely bugs that we
never hit, simply because an earlier bug is triggered frequently,
and each time we hit that bug the phone rebooted. With current
techniques, our only recourse was to stop fuzzing that particular
command identifier, or at times, even the whole ioctl handler and
move on to others.
Another weakness of DIFUZE is the inability to extract complex
relationships between fields of structures in the interface. It is
not uncommon that one field of a structure relates to another: for
example, a length field could specify the size of a buffer. However,
our system does not recognize these relationships, which could
potentially provide valuable information to the fuzzer.
Basic Blocks covered
No interface
Interface Aware
3811
3956
4629
5582
Percentage increase
21.46%
41.10%
vastly improve coverage guided techniques with interface aware-
ness). To use run-time coverage information, we would need to
re-compile and flash the kernel to the device, which presents several
challenges. First, to get fine-grained coverage information, a devel-
opment board is needed. This can be expensive or, in many cases,
simply unavailable for real-world devices. Second, it is not always
possible to find the latest kernel sources to recompile. This is ac-
ceptable for DIFUZE, as it is unlikely that ioctl interfaces change
radically between minor kernel updates, and the actual execution
will still be performed on the latest version of the software on the
target host. However, if an older (instrumented) kernel is flashed
onto the target host, the bugs discovered as a result might already
be obsolete. Finally, some vendors do not make it easy to flash a
new kernel to the device by locking the bootloader and performing
other security checks.
For these reasons, we did not instrument the kernel to insert code
coverage measurements or the Kernel Address Sanitizer (KASAN).
Both KASAN and coverage information could further improve
the results of DIFUZE. KASAN helps to find bugs by detecting
memory corruption and triggering an assertion failure. Without it,
exploitable bugs may be triggered without causing the device to
crash, simply because the corrupted memory is not used by other
functionality, or because no important data was corrupted. Cov-
erage information could improve the system by enabling deeper
exploration of drivers as it will try to mutate inputs that trigger
previously-neglected driver functionality.
10 CONCLUSION
In this paper, we proposed interface aware fuzzing to increase the
effectiveness of automated analysis on interface-sensitive code
such as Linux kernel drivers. We provided a set of techniques to
recover the ioctl interface specifications for fuzzing such code.
We implemented all our techniques in an automated pipeline that
works directly on the kernel source archive with a single command.
We show that our technique is efficient and effective in recovering
components, device file names, valid command identifiers and corre-
sponding argument types of the interface for most drivers. We carry
out a thorough evaluation, using several different configurations of
DIFUZE on seven models of Android phones, to demonstrate that
our implementation of interface aware fuzzer is effective, finding
36 bugs, of which 32 are previously unknown vulnerabilities.
We are open sourcing our DIFUZE to provide the community
with a tool to help ensure the safety of modern mobile devices.
9.2 Future Work
A valuable technique for fuzzing, found in many of the best fuzzers,
is using run-time coverage to guide the fuzzer. Currently, we do
not use this technique (though as we show in Section 8.6, we can
ACKNOWLEDGMENTS
We would like to thank the anonymous reviewers for their valuable
comments and input to improve our paper. This material is based
on research sponsored by the Office of Naval Research under grant
Session J2:  Fun with FuzzingCCS’17, October 30-November 3, 2017, Dallas, TX, USA2135numbers N00014-15-1-2948, N00014-17-1-2011 and by DARPA un-
der agreement number FA8750-15-2-0084. The U.S. Government is
authorized to reproduce and distribute reprints for Governmental
purposes notwithstanding any copyright notation thereon.
This work is also sponsored by a gift from Google’s Anti-Abuse
The views and conclusions contained herein are those of the
authors and should not be interpreted as necessarily representing
the official policies or endorsements, either expressed or implied,
of DARPA or the U.S. Government.
group.
REFERENCES
[1] 2016.
Android Security BulletinâĂŤMay 2017.
(2016).
https://
(2002).
source.android.com/security/bulletin/2017-05-01.
[2] Alfred Aho, Jeffrey Ullman, Monica S. Lam, and Ravi Sethi. 1986. Compilers:
Principles, Techniques, and Tools. "Addison-Wesley".
[3] Dave Aitel. 2002. The Advantages of Block-Based Protocol Analysis for
https://www.immunitysec.com/downloads/
Security Testing.
advantages_of_block_based_analysis.html.
[4] ARM. 2013. ARM Exception levels. (2013). http://infocenter.arm.com/help/
index.jsp?topic=/com.arm.doc.ddi0488c/CHDHJIJG.html.
[5] K. Ashcraft and D. Engler. 2002. Using programmer-written compiler extensions
to catch security holes. In Proceedings of the 2002 IEEE Symposium on Security
and Privacy (SP ’02). 143–159. https://doi.org/10.1109/SECPRI.2002.1004368
[6] Thomas Ball, Ella Bounimova, Byron Cook, Vladimir Levin, Jakob Lichtenberg,
Con McGarvey, Bohus Ondrusek, Sriram K. Rajamani, and Abdullah Ustuner.
2006. Thorough Static Analysis of Device Drivers. In Proceedings of the 2006 ACM
SIGOPS/EuroSys European Conference on Computer Systems (EuroSys ’06). ACM,
New York, NY, USA, 73–85. https://doi.org/10.1145/1217935.1217943
[7] Peter T. Breuer and Simon Pickin. 2006. One Million (LOC) and Counting: Static
Analysis for Errors and Vulnerabilities in the Linux Kernel Source Code. Springer
Berlin Heidelberg, Berlin, Heidelberg, 56–70. https://doi.org/10.1007/11767077_5
[8] Laurent Butti and Julien Tinnes. 2008. Discovering and exploiting 802.11 wireless
driver vulnerabilities. Journal in Computer Virology 4, 1 (2008), 25–37.
[9] Cristian Cadar, Daniel Dunbar, and Dawson Engler. 2008. KLEE: Unassisted and
Automatic Generation of High-coverage Tests for Complex Systems Programs.
In Proceedings of the 2008 USENIX Conference on Operating Systems Design and
Implementation (OSDI ’08). USENIX Association, Berkeley, CA, USA, 209–224.
http://dl.acm.org/citation.cfm?id=1855741.1855756
[10] Cristian Cadar, Vijay Ganesh, Peter M. Pawlowski, David L. Dill, and Dawson R.
Engler. 2006. EXE: Automatically Generating Inputs of Death. In Proceedings of
the 2006 ACM Conference on Computer and Communications Security (CCS ’06).
ACM, New York, NY, USA, 322–335. https://doi.org/10.1145/1180405.1180445
[11] Gabriel Campana. 2009. Fuzzgrind: un outil de fuzzing automatique. Actes du
(2009), 213–229.
[12] Sang Kil Cha, Maverick Woo, and David Brumley. 2015. Program-Adaptive
Mutational Fuzzing. In Proceedings of the 2015 IEEE Symposium on Security and
Privacy (SP ’15). IEEE Computer Society, Washington, DC, USA, 725–741. https:
//doi.org/10.1109/SP.2015.50
[13] Paolo Milani Comparetti, Gilbert Wondracek, Christopher Kruegel, and Engin
Kirda. 2009. Prospex: Protocol Specification Extraction. In Proceedings of the