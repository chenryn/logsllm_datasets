47.
maxDistance = buckets[i].min - leftMax;
48.
}
49.
leftMax = buckets[i].max;
50.
51.
52.
return maxDistance;
53.}
54.
55.
/**
56.
*桶
57.
*/
58.
private static class Bucket {
59.
Integer min;
60.
Integer max;
61.}
62.
63. public static void main(String[] args) {
64.
int[] array = new int[] {2,6,3,4,5,10,9};
---
## Page 340
65.
System.out.println(getMaxSortedDistance(array));
66.}
代码的前几步都比较直观，唯独第4步稍微有些不好理解：使用临时变
量leftMax，在每一轮选代时存储当前左侧桶的最大值。而两个桶之间的
差值，则是buckets[i].minleftMax。
没错，这就是这道题目的最优解决方
法。关于无序数组排序后最大差值的问题就介绍到这里，咱们下一
节再见！
5.7
如何用栈实现队列
5.7.1
又是一道关于栈的面试题
小灰。你这次确定真
的准备好了？
---
## Page 341
备好了
那么下面我来考查你一道算法题，怎样
用栈来实现一个队列？
题目
用栈来模拟一个队列，要求实现队列的两个基本操作：入队、出队。
哦....栈是先入后出，队列是先入先
出，用栈没办法实现队列吧？
---
## Page 342
提示你一下，用一个栈肯定是没办法实
现队列的，但如果我们有两个栈呢？
让我想想啊....
没想出来，就算给我8个栈，我也不知道
怎么实现队列。
呵呵，没事，回家等通知去吧！
---
## Page 343
别啊，我觉得我还可
以再抢妆一下..
5.7.2
解题思路
小灰，你刚刚去面试了？结果怎么
样？
埃
---
## Page 344
大黄，你能不能给我讲讲，怎样
可以用两个栈来实现一个队列呀？
要解决这个问题，我们先来回顾一下
栈和队列的不同特点。
栈的特点是先入后出，出入元素都是在同一端（栈顶）。
入栈：
栈底
栈顶
351496
出栈：
栈底
栈顶
5
C
队列的特点是先入先出，出入元素是在不同的两端（队头和队尾）。
入队：
---
## Page 345
队头
队尾
3514
19
出队：
队头
队尾
3
5149
6
617
既然我们拥有两个栈，那么可以让其中一个栈作为队列的入口，负责插
入新元素；另一个栈作为队列的出口，负责移除老元素。
模拟入队
栈A
模拟出队
栈B
可是，两个栈是各自独立的，怎么能把
它们有效地关联起来呢？
---
## Page 346
别着急，让我来具体演示一下。
队列的主要操作无非有两个：入队和出队。
在模拟入队操作时，每一个新元素都被压入到栈A当中。
让元素1入队。
栈A
栈B
栈A
栈B
让元素2入队。
栈A
栈B
栈A
栈B
---
## Page 347
让元素3入队。
栈A
栈B
栈A
栈B
这时，我们希望最先入队的元素1出队，需要怎么做呢？
让栈A中的所有元素按顺序出栈，再按照出栈顺序压入栈B。这样
来，元素从栈A弹出并压入栈B的顺序是3、2、1，和当初进入栈A的顺
序1、2、3是相反的。
栈A
栈B
此时让元素1出队，也就是让元素1从栈B中弹出。
栈A
栈B
让元素2出队。
栈A
栈B
---
## Page 348
如果这个时候又想做入队操作了
呢？
很简单，当有新元素入队时，重新把
新元素压入栈A。
让元素4入队。
栈A
栈B
栈A
栈B
此时出队操作仍然从栈B中弹出元素。
让元素3出队。
---
## Page 349
栈A
栈B
现在栈B已经空了，如果再想出
队该怎么办呢？
也不难，只要栈A中还有元素，就像
刚才一样，把栈A中的元素弹出并压入栈B即可。
栈A
栈B
让元素4出队。
栈A
栈B
---
## Page 350
怎么样，这回你绕明白了吗？
哦，基本上明白了，那么代码怎
么来实现呢？
代码很好写，让我们来看一看。
1. private Stack stackA = new Stack();
2.private Stack stackB = new Stack();
3./**
4.
*入队操作
5.
*@paramelement
入队的元素
---
## Page 351
7.public void enQueue（int element）{
8.
stackA.push(element);
9.}
10.
/**
11.
*
出队操作
12.
*/
13.
public Integer deQueue() {
14.
if(stackB.isEmpty()){
15.
if(stackA.isEmpty()){
16.
return null;
17.
18.
transfer();
19.
20.
return stackB.pop();
21.}
22.
23.
/ **
24.
*栈A元素转移到栈B
25.
*/
26.
private void transfer(){
27.
while (!stackA.isEmpty()){
28.
stackB.push(stackA.pop()) ;
29.
30.}
---
## Page 352
31. public static void main(String[] args) throws Exception {
32.
StackQueue stackQueue = new StackQueue(）;
33.
stackQueue.enQueue(1);
34.
stackQueue.enQueue(2);
35.
stackQueue.enQueue(3);
36.
System.out.println(stackQueue.deQueue());
37.
System.out.println(stackQueue.deQueue());
38.
stackQueue.enQueue(4);
39.
System.out.println(stackQueue.deQueue());
40.
System.out.println(stackQueue.deQueue());
41.}
小灰，你说说，这个队列的入队和出
队操作，时间复杂度分别是多少？
入队操作的时间复杂度显然
是0(1）。至于出队操作，如果涉及栈A和栈B的元素迁移，那么一
次出队的时间复杂度是O(n)；如果不用迁移，时间复杂度是0(1)。
---
## Page 353
咦，在这种情况下，出队的时间复杂度究竞应该是多少呢？
这里涉及一个新的概念，叫作均摊时
间复杂度
需要元素迁移的出队操作只有少数情况，并且不可能
连续出现，其后的大多数出队操作都不需要元素迁移。
所以把时间均摊到每一次出队操作上
面，其时间复杂度是0(1)。这个概念并不常用，稍做了解即可。
好了，用栈实现队列的题目，我们就
介绍到这里，咱们下一节再见！
5.8
寻找全排列的下一个数
5.8.1
一道关于数字的题目
---
## Page 354
候选人，你好，请简单
介绍一下你自己
我是小灰啊
装不认识。
下面我来考查你一道算法题，假设给出
一个正整数，请找出这个正整数所有数字全排列的下一个数。
题目
给出一个正整数，找出这个正整数所有数字全排列的下一个数。
说通俗点就是在一个整数所包含数字的全部组合中，找到一个大于且仅
大于原数的新整数。让我们举几个例子。
如果输入12345，则返回12354。
如果输入12354，则返回12435。
---
## Page 355
如果输入12435，则返回12453。
让我想一想啊...
我发现了，这里面有个规律！让我来
解释一下。
小灰发现的“规律"如下。
输入12345，返回12354，那么
12354 - 12345 = 9,
刚好相差9的一次方。
输入12354，返回12435，那么
12435 - 12354 = 81,
刚好相差9的二次方。
所以，每次计算最近的换位数，只需要加上9的n次方即可。
---
## Page 356
怎么样，我是不是很机智？
这算哪门子规律？
12453-12435= 18,
24135-23541=594，也并不都是9的整数次幂啊！
啊，尴尬了....
呵呵，今天就到这里，回家等通知去
吧！
---
## Page 357
，我白高兴一场
5.8.2
解题思路
小灰，你刚刚去面试了？结果怎么
样？
埃
---
## Page 358
大黄，你能不能给我讲讲，怎么
样寻找一个整数所有数字全排列的下一个数？
好啊，在给出具体解法之前，小灰你
先思考一个问题：由固定几个数字组成的整数，怎样排列最大？怎
样排列最小？
让我想一想啊...
---
## Page 359
知道了，如果是固定的几个数字，应
该是在逆序排列的情况下最大，在顺序排列的情况下最小。
举一个例子。
给出1、2、3、4、5这几个数字。
最大的组合：54321。
最小的组合：12345。
没错，数字的顺序和逆序，是全排列
中的两种极端情况。那么普遍情况下，一个数和它最近的全排列数
存在什么关联呢？
例如给出整数12354，它包含的数字是1、2、3、4、5，如何找到这些数
字全排列之后仅大于原数的新整数呢？
为了和原数接近，我们需要尽量保持高位不变，低位在最小的范围内
变换顺序。
至于变换顺序的范围大小，则取决于当前整数的逆序区域。
---
## Page 360
123
逆序区域
如图所示，12354的逆序区域是最后两位，仅看这两位已经是当前的最
大组合。若想最接近原数，又比原数更大，必须从倒数第3位
开始改
变。
怎样改变呢？12345的倒数第3位是3，我们需要从后面的逆序区域中找
到大于3的最小的数字，让其和3的位置进行互换。
3
5
12
53
2
互换后的临时结果是12453，倒数第3位已经确定，这个时候最后两位仍
然是逆序状态。我们需要把最后两位转变为顺序状态，以此保证在倒
数第3位数值为4的情况下，后两位尽可能小。
1
2
53
1243
35
这样一来，就得到了想要的结果12435。
---
## Page 361
有些明白了，不过还真是复杂呀！
看起来复杂，其实只要3个步骤。
获得全排列下一个数的3个步骤。
1.从后向前查看逆序区域，找到逆序区域的前一位，也就是数字置换的
边界。
2.让逆序区域的前一位和逆序区域中大于它的最小的数字交换位置
3.把原来的逆序区域转为顺序状态。
最后让我们用代码来实现一下。这里
为了方便数字位置的交换，入参和返回值的类型都采用了整型数
组。
---
## Page 362
1. public static int[] findNearestNumber(int[] numbers){
2.
//1，从后向前查看逆序区域，找到逆序区域的前一位，也就是数字置换的边
界
3.
int index = findTransferPoint(numbers);
4.//如果数字置换边界是0，说明整个数组已经逆序，无法得到更大的相同数
5.//字组成的整数，返回null
6.
if(index == 0){