表6-4-5
datachild1child2child3
childd
其中data是数据域。child1到childd是指针域，用来指向该结点的孩子结点。
对于图6-4-1的树来说，树的度是3，所以我们的指针城的个数是3，这种方法实
现如图6-4-2所示。
A
AAA
AA
E
G
图 6-4-2
这种方法对于树中各结点的度相差很大时，显然是很浪费空间的，因为有很多的
结点，它的指针域都是空的。不过如果树的各结点度相差很小时，那就意味着开辟的
空间被充分利用了，这时存储结构的缺点反而变成了优点。
既然很多指针域都可能为空，为什么不按需分配空间呢。于是我们有了第二种
158
---
## Page 183
嘉9巢
方案。
方案二
第二种方案每个结点指针域的个数等于该结点的度，我们专门取一个位置来存储
结点指针域的个数，其结构如表6-4-6所示。
表6-4-6
data
degreechild1
chilld2
childd
其中data为数据域，degree为度域，也就是存储该结点的孩子结点的个数，
child1到childd为指针域，指向该结点的各个孩子的结点。
对于图6-4-2的树来说，这种方法实现如图6-4-3所示。
F
0
G
0H
01
J0
图6-4-3
这种方法克服了浪费空间的缺点，对空间利用率是很高了，但是由于各个结点
的链表是不相同的结构，加上要维护结点的度的数值，在运算上就会带来时间上的
损耗。
能否有更好的方法，既可以减少空指针的浪费又能使结点结构相同。
仔细观察，我们为了要遍历整棵树，把每个结点放到一个顺序存储结构的数组中
是合理的，但每个结点的孩子有多少是不确定的，所以我们再对每个结点的孩子建立
一个单链表体现它们的关系。
这就是我们要讲的孩子表示法。具体办法是，把每个结点的孩子结点排列起来，
以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为
159
---
## Page 184
大语数据结构
空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组
中，如图6-4-4所示。
下标
11
2
B
3
6
E
9
G
图6-4-4
为此，设计两种结点结构，一个是孩子链表的孩子结点，如表6-4-7所示。
表6-4-7
childnext
其中child是数据域，用来存储某个结点在表头数组中的下标。next是指针域，用
来存储指向某结点的下一个孩子结点的指针。
另一个是表头数组的表头结点，如表6-4-8所示。
表6-4-8
datafirstchild
其中data是数据域，存储某结点的数据信息。firstchild是头指针域，存储该结点
的孩子链表的头指针。
以下是我们的孩子表示法的结构定义代码。
1·树的孩子表示法结构定义·/
define MAX_TREE_SIZE 100
typedefstruct CTNode/*孩子给点/
int child;
160
---
## Page 185
第6章树
}*ChildPtr;
typedef struct
/表头结构*/
TElemType data;
Childptrfirstchild;
}CTBox;
typedef struct
/树结构/
CTBoxnodes[MAX_TREE_SIZE];/·结点数组*/
intr,n;
/·根的位置和结点数·/
]CTree;
这样的结构对于我们要查找某个结点的某个孩子，或者找某个结点的兄弟，只需
要查找这个结点的孩子单链表即可。对于遍历整棵树也是很方便的，对头结点的数组
循环即可。
但是，这也存在着问题，我如何知道某个结点的双亲是谁呢？比较麻烦，需要整
棵树遍历才行，难道就不可以把双亲表示法和孩子表示法综合一下吗？当然是可以。
如图6-4-5所示。
下作 data
Child next
0
A
-1
1
2
1
B
3A
C
4
6
A
9
A
图 6-4-5
我们把这种方法称为双亲孩子表示法，应该算是孩子表示法的改进。至于这个表
示法的具体结构定义，这里就略过，留给同学们自己去设计了。
161
---
## Page 186
大话数据结构
6.4.3孩子兄弟表示法
刚才我们分别从双亲的角度和从孩子的角度研究树的存储结构，如果我们从树结
点的兄弟的角度又会如何呢？当然，对于树这样的层级结构来说，只研究结点的兄弟
是不行的，我们观察后发现，任意一棵树，它的结点的第一个孩子如果存在就是唯一
的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的
第一个孩子和此结点的右兄弟。
结点结构如表6-4-9所示。
表6-4-9
datafirstchildrightsib
其中data是数据域，frstchild为指针城，存储该结点的第一个孩子结点的存储地
址，rightsib是指针域，存储该结点的右兄弟结点的存储地址。
结构定义代码如下。
/树的孩子兄弟表示法结构定义·
typedef struct csNode
TElemType data;
struct csNode*firstchild,*rightsib;
}CSNode,*CSTree;
对于图6-4-1的树来说，这种方法实现的示意图如图6-4-6所示。
A
A
D
E
FAA
图6-4-6
162
---
## Page 187
第6章树
这种表示法，给查找某个结点的某个孩子带来了方便，只需要通过fistchild找到
此结点的长子，然后再通过长子结点的rightsib找到它的二弟，接着一直下去，直到
找到具体的孩子。当然，如果想找某个结点的双亲，这个表示法也是有缺陷的，那怎
么办呢？
呵呵，对，如果真的有必要，完全可以再增加一个parent指针域来解决快速查找
双亲的问题，这里就不再细谈了。
其实这个表示法的最大好处是它把一棵复杂的树变成了一棵二叉树。我们把图
6-4-6变变形就成了图6-4-7这个样子。
B
HA
F
图6-4-7
这样就可以充分利用二叉树的特性和算法来处理这棵树了。嗯？有人问，二叉树
是什么？哈哈，别急，这正是我接下来要重点讲的内容。
6.5二叉树的定义
现在我们来做个游戏，我在纸上已经写好了一个100以内的正整数数字，请大家
想办法猜出我写的是哪一个？注意你们猜的数字不能超过7个，我的回答只会告诉你
是“大了”或“小了”。
163
---
## Page 188
大数据结
这个游戏在一些电视节目中，猜测一些商品的定价时常会使用。我看到过有些人
是一点一点的数字累加的，比如5、10、15、20这样猜，这样的猜数策略太低级了，
显然是没有学过数据结构和算法的人才做得出的事。
其实这是一个很经典的折半查找算法。如果我们用图6-5-1（下三层省略）的办
法，就一定能在7次以内，猜出结果来。
50
图6-5-1
由于是100以内的正整数，所以我们先猜50（100的一半），被告之“大了”，于
是再猜25（50的一半），被告之“小了”，再猜37（25与50的中间数），小了，于
是猜43，大了，40，大了，38，小了，39，完全正确。过程如表6-5-1所示。
表6-5-1
被猜数字第一次第二次第三次第四次第五次第六次第七次
39
50
25
37
43
40
38
39
82
50
75
75
88
99
50
88
96
98
99
1
150
25
12
6
3
2
1
我们发现，如果用这种方式进行查找，效率高得不是一点点。对于折半查找的详
细讲解，我们后面章节再说。不过对于这种在某个阶段都是两种结果的情形，比如开
和关、0和1、真和假、上和下、对与错，正面与反面等，都适合用树状结构来建
模，而这种树是一种很特殊的树状结构，叫微二叉树。
二叉树（BinaryTree）是n（n≥0）个结点的有限集合，该集合
或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交
的、分别称为根结点的左子树和右子树的二叉树组成。
图6-5-2就是一棵二叉树。而图6-2-1的树，因为D结点有三个子树，所以它不
是二叉树。
164
---
## Page 189
9
①
图6-5-2
6.5.1二叉树特点
二叉树的特点有：
+
每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。注意不是
只有两棵子树，而是最多有。没有子树或者有一棵子树都是可以的。
左子树和右子树是有顺序的，次序不能任意颠倒。就像人是双手、双脚，但
显然左手、左脚和右手、右脚是不一样的，右手戴左手套、右脚穿左鞋都会
极其别扭和难受。
1
即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。图6-5-3
中，树1和树2是同一棵树，但它们却是不同的二叉树。就好像你一不小
心，摔伤了手，伤的是左手还是右手，对你的生活影响度是完全不同的。
iS
树1
树2
图6-5-3
二叉树具有五种基本形态：
1.空二叉树。
2.只有一个根结点。
165
---
## Page 190