a−1 · shash
a
sb
699Note that the protection order stated for Meas in Figure 3
applies to all nodes in Meas. If however, and as explained
in Section 6.4, diﬀerent protection orders are used for nodes
at diﬀerent risk, the depicted plots mark the border cases
for the actual memory overhead. For example, if low-level
tree nodes do not use masking (i.e., having ﬁrst-order DPA
security) and ﬁrst-order masking is applied to all other nodes
(i.e., having second-order DPA security), the actual memory
overhead is lower- and upper-bounded by the plot with ﬁrst-
and second-order protection, respectively.
An evaluation of the memory overhead of Meas over dif-
ferent protection orders and arity is depicted for 1024-bit
blocks and 128-bit security in Figure 4. Hereby, it turns out
that the memory overhead is strongly inﬂuenced by the tree’s
arity leading to two main observations. First, a higher arity
clearly lowers the memory overhead, but for an arity higher
than eight, the reduction resulting from another increase of
the arity becomes quite small. Second, the memory overhead
rises linearly with the protection order, but the increase is
stronger the lower the tree’s arity is. This is due to the masks
for randomization of the plaintext being chosen and stored
for each tree node. As a result, higher arity leads to more
plaintext blocks sharing such masks in one tree node and
thus lower memory overhead due to the masking.
7.5 Randomness
Meas consumes a considerable amount of randomness. In
particular, fresh random keys and masks must be chosen for
all nodes on the path from the root to the leaf whenever
a write operation is performed. For Meas with protection
order d, this sums up to (skey + (d − 1) · smask) · (l + 1)
random bits needed on each write operation, where l is the
tree height. Implementations of Merkle trees, PATs and TEC
trees without consideration of side channels however do not
require any random value if all nonces are chosen as counters.
Yet, cipher implementations that protect PATs and TEC
trees against side-channel attacks rely on signiﬁcant amounts
of randomness too. Namely, implementations with protection
order d split its state into (d + 1) shares. This demands for
at least d · sstate random bits per cipher invocation that get
necessary for all accessed nodes on both reads and writes.
8. CONCLUSION
Authentic and encrypted memory is a requirement for
storing and processing data in hostile environments where
attackers have physical access. The consideration of the
imminent threat of side-channel attacks against the involved
cryptographic primitives is thus the natural next step.
In this work, we therefore presented Meas, the ﬁrst Mem-
ory Encryption and Authentication Scheme which is secure
against DPA attacks. The scheme does not require any
DPA-protected primitive, allowing its use in COTS systems.
Moreover, Meas provides fast random access on the conﬁg-
ured block level and can be adopted for all kinds of use cases
including RAM and disk encryption.
The scheme combines the concept of fresh re-keying with
authentication trees by storing the involved keys in an en-
crypted tree structure. While this prevents ﬁrst-order DPA,
masking of the plaintext values ﬂexibly extends the protec-
tion of Meas to higher-order DPA if required. Compared
to existing schemes, Meas exclusively oﬀers DPA protection
by design at roughly the same memory overhead and perfor-
mance. This is a clear beneﬁt over state-of-the-art memory
authentication and encryption techniques, which would face
impractical implementation and runtime overheads for DPA-
protected implementations if adapted accordingly.
Acknowledgments.
The research leading to
these results has received
funding from the European
Research Council (ERC) un-
der the European Union’s
Horizon 2020 research and innovation programme (grant
agreement No 681402). Further, this work has been sup-
ported by the Austrian Research Promotion Agency (FFG)
under the grant number 845579 (MEMSEC).
9. REFERENCES
[1] Apple Inc. Apple Technical White Paper: Best
Practices for Deploying FileVault 2, 2012.
http://docplayer.net/
281501-Best-practices-for-deploying-ﬁlevault-2.html.
[2] Apple Inc. iOS Security, 2015. https://www.apple.com/
business/docs/iOS Security Guide.pdf.
[3] J. Balasch, B. Gierlichs, O. Reparaz, and
I. Verbauwhede. DPA, bitslicing and masking at 1 ghz.
In Cryptographic Hardware and Embedded Systems -
CHES 2015, pages 599–619, 2015.
[4] S. Bela¨ıd, V. Grosso, and F. Standaert. Masking and
leakage-resilient primitives: One, the other(s) or both?
Cryptology ePrint Archive, Report 2014/053, 2014.
[5] S. Bela¨ıd, F. D. Santis, J. Heyszl, S. Mangard,
M. Medwed, J. Schmidt, F. Standaert, and S. Tillich.
Towards fresh re-keying with leakage-resilient PRFs:
cipher design principles and analysis. J. Cryptographic
Engineering, 4(3):157–171, 2014.
[6] M. Bellare and C. Namprempre. Authenticated
encryption: Relations among notions and analysis of
the generic composition paradigm. J. Cryptology,
21(4):469–491, 2008.
[7] B. Bilgin, B. Gierlichs, S. Nikova, V. Nikov, and
V. Rijmen. A more eﬃcient AES threshold
implementation. In Progress in Cryptology –
AFRICACRYPT 2014, pages 267–284, 2014.
[8] S. Chari, C. S. Jutla, J. R. Rao, and P. Rohatgi.
Towards sound approaches to counteract power-analysis
attacks. In Advances in Cryptology - CRYPTO 1999,
pages 398–412, 1999.
[9] S. Chari, J. R. Rao, and P. Rohatgi. Template attacks.
In Cryptographic Hardware and Embedded Systems -
CHES 2002, pages 13–28, 2002.
[10] R. Elbaz, D. Champagne, C. H. Gebotys, R. B. Lee,
N. R. Potlapally, and L. Torres. Hardware mechanisms
for memory authentication: A survey of existing
techniques and engines. Trans. Computational Science,
4:1–22, 2009.
[11] R. Elbaz, D. Champagne, R. B. Lee, L. Torres,
G. Sassatelli, and P. Guillemin. Tec-tree: A low-cost,
parallelizable tree for eﬃcient defense against memory
replay attacks. In Cryptographic Hardware and
Embedded Systems - CHES 2007, pages 289–302, 2007.
[12] N. Ferguson. AES-CBC + Elephant diﬀuser A Disk
Encryption Algorithm for Windows Vista, Aug. 2006.
700[13] C. Fruhwirth. New Methods in Hard Disk Encryption,
[32] T. T. Michael Halcrow, Uday Savagaonkar and
2005.
[14] O. Goldreich, S. Goldwasser, and S. Micali. How to
construct random functions. J. ACM, 33(4):792–807,
1986.
[15] Google Inc. Android Full Disk Encryption, 2015.
https://source.android.com/security/encryption/.
[16] L. Goubin and J. Patarin. DES and diﬀerential power
analysis (the ”duplication” method). In Cryptographic
Hardware and Embedded Systems - CHES 1999, pages
158–172, 1999.
[17] S. Gueron. A memory encryption engine suitable for
general purpose processors. IACR Cryptology ePrint
Archive, 2016:204, 2016.
[18] W. E. Hall and C. S. Jutla. Parallelizable
authentication trees. In Selected Areas in Cryptography
- SAC 2005, pages 95–109, 2005.
[19] N. Hanley, M. Tunstall, and W. P. Marnane. Unknown
plaintext template attacks. In Information Security
Applications - WISA 2009, pages 148–162, 2009.
[20] M. Henson and S. Taylor. Beyond full disk encryption:
Protection on security-enhanced commodity processors.
In Applied Cryptography and Network Security - ACNS
2013, pages 307–321, 2013.
[21] IEEE. IEEE Standard for Cryptographic Protection of
Data on Block-Oriented Storage Devices. IEEE Std
1619-2007, April 2008.
[22] Intel Corporation. Intel R(cid:13) 64 and IA-32 Architectures
Software Developer Manuals. 325462-058.
[23] D. Kaplan, J. Powell, and T. Woller. AMD memory
encryption, 2016. http:
//developer.amd.com/resources/articles-whitepapers/.
[24] P. Kocher. Leak-resistant cryptographic indexed key
update, Mar. 25 2003. US Patent 6,539,092.
[25] P. C. Kocher, J. Jaﬀe, and B. Jun. Diﬀerential power
analysis. In Advances in Cryptology - CRYPTO 1999,
pages 388–397, 1999.
[26] Linux Kernel Organization Inc. Linux Kernel 4.3
Source Tree, 2015. https://git.kernel.org/cgit/linux/
kernel/git/torvalds/linux.git/log/?id=refs/tags/v4.3.
[27] J. Longo, E. D. Mulder, D. Page, and M. Tunstall. Soc
it to EM: electromagnetic side-channel attacks on a
complex system-on-chip. In Cryptographic Hardware
and Embedded Systems - CHES 2015, pages 620–640,
2015.
[28] S. Mangard, E. Oswald, and T. Popp. Power analysis
attacks - revealing the secrets of smart cards. Springer,
2007.
[29] M. Medwed, F. Standaert, J. Großsch¨adl, and
F. Regazzoni. Fresh re-keying: Security against
side-channel and fault attacks for low-cost devices. In
Progress in Cryptology - AFRICACRYPT 2010, pages
279–296, 2010.
[30] R. C. Merkle. Protocols for public key cryptosystems.
In IEEE Symposium on Security and Privacy - SP
1980, pages 122–134, 1980.
[31] T. S. Messerges. Using second-order power analysis to
attack DPA resistant software. In Cryptographic
Hardware and Embedded Systems - CHES 2000, pages
238–251, 2000.
I. Muslukhov. Ext4 Encryption Design Document.
http://goo.gl/qbcZV2.
[33] A. Moradi, A. Poschmann, S. Ling, C. Paar, and
H. Wang. Pushing the Limits: A Very Compact and a
Threshold Implementation of AES. In Advances in
Cryptology - EUROCRYPT 2011, pages 69–88, 2011.
[34] E. Owusu, J. Guajardo, J. M. McCune, J. Newsome,
A. Perrig, and A. Vasudevan. OASIS: on achieving a
sanctuary for integrity and secrecy on untrusted
platforms. In Computer and Communications Security -
CCS 2013, pages 13–24, 2013.
[35] O. Pereira, F. Standaert, and S. Vivek.
Leakage-resilient authentication and encryption from
symmetric cryptographic primitives. In Computer and
Communications Security – CCS 2015, pages 96–108,
2015.
[36] K. Pietrzak. A leakage-resilient mode of operation. In
Advances in Cryptology – EUROCRYPT 2009, pages
462–482, 2009.
[37] P. Rogaway. Eﬃcient Instantiations of Tweakable
Blockciphers and Reﬁnements to Modes OCB and
PMAC. In Advances in Cryptology - ASIACRYPT
2004, pages 16–31. Springer Berlin Heidelberg, 2004.
[38] B. Rogers, S. Chhabra, M. Prvulovic, and D. Solihin.
Using Address Independent Seed Encryption and
Bonsai Merkle Trees to Make Secure Processors OS-
and Performance-Friendly. In IEEE/ACM
International Symposium on Microarchitecture -
MICRO 2007, pages 183–196, Dec 2007.
[39] B. Rogers, S. Chhabra, M. Prvulovic, and Y. Solihin.
Using address independent seed encryption and bonsai
merkle trees to make secure processors OS- and
performance-friendly. In IEEE/ACM International
Symposium on Microarchitecture - MICRO 2007, pages
183–196, 2007.
[40] P. R. Sami Saab and C. Hampel. Side-channel
protections for cryptographic instruction set extensions.
Cryptology ePrint Archive, Report 2016/700, 2016.
[41] F. Standaert, O. Pereira, Y. Yu, J. Quisquater,
M. Yung, and E. Oswald. Leakage resilient
cryptography in practice. In Towards
Hardware-Intrinsic Security - Foundations and Practice,
pages 99–134. 2010.
[42] G. Suh, D. Clarke, B. Gasend, M. van Dijk, and
S. Devadas. Eﬃcient Memory Integrity Veriﬁcation and
Encryption for Secure Processors. In IEEE/ACM
International Symposium on Microarchitecture -
MICRO 2003, pages 339–350, Dec 2003.
[43] G. E. Suh, D. E. Clarke, B. Gassend, M. van Dijk, and
S. Devadas. AEGIS: architecture for tamper-evident
and tamper-resistant processing. In International
Conference on Supercomputing - ICS 2003, pages
160–171, 2003.
[44] M. M. I. Taha and P. Schaumont. Key updating for
leakage resiliency with application to AES modes of
operation. IEEE Trans. Information Forensics and
Security, 10(3):519–528, 2015.
[45] T. Unterluggauer and S. Mangard. Exploiting the
physical disparity: Side-channel attacks on memory
encryption. In Constructive Side-Channel Analysis and
Secure Design, COSADE 2016, pages 3–18, 2016.
701APPENDIX
A. AUTHENTICATION TREES
In the following we describe three prominent examples of
authentication trees, namely, Merkle trees [30], Paralleliz-
able Authentication Trees [18] (PAT), and Tamper Evident
Counter [11] (TEC) trees. Note however that there are also
hybrid variants like Bonsai Merkle trees [39], which use ele-
ments from both Merkle trees and PATs. The description
assumes binary trees, the operator || denotes concatenation.
A.1 Merkle Trees [30]
Merkle trees use a hash function H to hash each of the m
memory blocks pi:
hl,i = H(pi)
0 ≤ i ≤ m − 1.
These hashes hl,i are recursively hashed together in a tree
structure and the root hash h0,0 is put on the secure chip:
hj,i = H(hj+1,2i||hj+1,2i+1)
2l−j − 1,
0 ≤ i ≤ m
0 ≤ j ≤ l − 1.
A.2 Parallelizable Authentication Trees [18]
PATs use a nonce-based MAC and a key k to authenticate
each of the m data blocks pi using a tag tl,i:
tl,i = M AC(k; nl,i; pi)
0 ≤ i ≤ m − 1.
The nonces nl,i are recursively authenticated in a tree struc-
ture using again nonce-based MACs. While the key k and the
root nonce n0,0 must be stored on the secure chip, all other
nonces and the tags are stored publicly in oﬀ-chip memory:
tj,i = M AC(k; nj,i; nj+1,2i||nj+1,2i+1)
2l−j − 1,
0 ≤ i ≤ m
0 ≤ j ≤ l − 1.
A.3 Tamper Evident Counter Trees [11]
While Merkle trees and PATs provide memory authentic-
ity, TEC trees additionally provide memory conﬁdentiality.
Therefore, TEC trees use Added Rendundancy Explicit Au-
thenticity [13] (AREA) codes. Hereby, each plain memory
block pi is padded with a nonce nl,i and then encrypted with
key k using a common block cipher:
i||n(cid:48)
cl,i = E(k; pi||nl,i)
0 ≤ i ≤ m − 1.
For veriﬁcation, a ciphertext cl,i is decrypted to p(cid:48)
l,i and
n(cid:48)
l,i compared with the original nonce nl,i. Hereby, the au-
thenticity is ensured by the diﬀusion of the block cipher as
it makes it hard for the adversary to modify the encrypted
nonce nl,i. The nonce nl,i is formed from the memory block
address and a counter ctrl,i [11]. The nonce counters are
recursively authenticated using AREA codes in a tree struc-
ture. The key k and the root counter ctr0,0 are stored on
the secure chip:
cj,i = E(k; ctrj+1,2i||ctrj+1,2i+1||nj,i)
2l−j − 1,
0 ≤ i ≤ m
0 ≤ j ≤ l − 1.
702