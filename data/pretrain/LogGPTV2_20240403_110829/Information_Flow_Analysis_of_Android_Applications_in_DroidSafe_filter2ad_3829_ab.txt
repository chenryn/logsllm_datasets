techniques that enable DroidSafe to deliver an analysis of
unprecedented scalability, accuracy, and robustness, 3) a set
of new mechanisms that enable these techniques to work
together to provide a comprehensive, accurate, and precise
information-ﬂow analysis for Android applications, and 4)
signiﬁcant engineering effort that delivers a comprehensive
model of the Android runtime. Speciﬁc contributions include:
• Accurate Analysis Stubs: A novel technique that enables
the rapid and accurate development of semantics miss-
ing from a source code base. Each stub is written in
the language of the implementation of the API model,
simplifying analysis. Stubs augment the implementation
with semantics possibly incomplete for the full runtime
behavior, but complete for the analysis abstractions.
• Android Device Implementation: A comprehensive and
precise model of the Android API and runtime system
implemented in Java that accurately captures the semantics
of life-cycle events, callback context, external resources,
and inter-component communication. The core of the ADI
includes 550 manually-veriﬁed Android API classes which
cover over 98% of API calls in deployed Android applica-
tions. The ADI currently models Android 4.4.3, because
updating the model for Android updates is not overly
burdensome. Independent analysis tools can readily employ
this model.
• Static Analysis Design Decisions: Our analysis occupies
a new design point for information-ﬂow analysis of An-
droid: deep object sensitivity and ﬂow insensitivity. Flow
insensistivity enables DroidSafe to accurately consider all
possible event orderings. It also enables DroidSafe to scale
to analyze an accurate and precise model of the Android
environment, which is critical for the overall success of
DroidSafe. Any loss of precision due to ﬂow-insensitivity
is more than compensated for by the analysis’s ability to
scale to analyze our accurate and precise Android model.
• Static Communication Target Resolution: A comprehen-
sive and precise model of inter-component communication
resolution in Android that links data ﬂows between sender
and target. DroidSafe includes a global Intent and Uri
value resolution analysis, IntentFilter reasoning, and
coverage of all common forms of communication. To our
knowledge it is the most complete such model to date.
• Experimental Evaluation: An evaluation demonstrating
that 1) DroidSafe achieves unprecedented precision and
accuracy for the information-ﬂow analysis of Android and
2) DroidSafe can detect malicious sensitive information
leaks inserted by sophisticated, independent hostile orga-
nizations, where a current state-of-the-art information-ﬂow
analysis largely fails.
• Full Implementation: A full open-source implementation
of DroidSafe and our ADI available upon request.
Contributions
II. BACKGROUND AND PROBLEM
This paper identiﬁes and implements, for the ﬁrst time, an
effective point in the overall Android information-ﬂow design
space. Our overarching contribution is the identiﬁcation of this
design point and the resulting DroidSafe implementation. We
attribute the ability of DroidSafe to operate at this design point
to: 1) the identiﬁcation of a set of techniques that work well
together, 2) new implementations of known program analysis
Android applications are implemented in Java on top
of the Android API. The implementation of an application
speciﬁes handlers for the dynamic events that may occur during
the execution of the application. Thus, Android applications
are dynamic and event-driven by nature. Applications have
multiple entry points, and interact heavily with the Android
API via utility and resource access classes. The package for
3
an Android application represents an incomplete program; the
source package alone is not appropriate for analysis without
an accompanying model of the Android API and runtime
semantics to exercise all possible semantics in the application.
The Android API version 4.4.3 includes over 3,500 classes
visible to an application developer. Analyzing the complete
source code for the API is exceedingly difﬁcult because it
is implemented over multiple languages and some of the
implementation is device-speciﬁc. Thus, static analysis frame-
works rely on modeling the Android API semantics. Manually
producing summaries for all of the application-visible methods
of the Android API is daunting task that is potentially error
prone. For a high-precision analysis, it is also exceedingly dif-
ﬁcult to model all semantics of the implementation regarding
memory allocation, data ﬂows, and aliasing. A blanket policy
for generating ﬂows for all API methods would risk being too
imprecise and inaccurate.
A. Event Dispatch and Ordering
An accurate model of the event dispatch and ordering must
represent all valid event orderings so that a static analysis can
accurately capture possible runtime behavior. Otherwise, an
attacker can hide ﬂows in semantics not covered by the model.
Android applications are composed of multiple components,
each implementing one of four classes: Activity, Service,
BroadcastReceiver, and ContentProvider. Each of these
components has its own life-cycle deﬁned with events for
which a callback implementation can be provided. For exam-
ple, Figure 1(a) provides an example of a single Activity that
deﬁnes two life-cycle events. These events have the potential
to run in many orders, and they are not called directly in
application code. There exists a leak of sensitive information
in one possible ordering,
if onCreate is dispatched after
onStop. This is possible if the activity is placed in the
background by user interaction, and not reclaimed by the
system before it is reactivated by the user.
In addition to life-cycle state orderings, components can
have different launching modes that specify whether a single
object should handle all activations or if a separate object is
spawned for each activation. Thus memory could be shared
across separate activations of a component.
B. Callback Context
An Android application deﬁnes callback handler methods
that are called for dynamically-dispatched runtime events.
Many event handler methods include arguments passed by the
runtime to the application for processing. These arguments
are generated by the runtime and could include data from
the application (including tainted data), depending on the
execution sequence prior to the event. We call the arguments
to a callback handler its callback context. Figure 1(b) gives
example of a ﬂow through callback context. This example
employs an Activity’s ability to save state when it is paused,
and restore that state when resumed. An accurate model must
represent these possible ﬂow connections (of which there are
possibly thousands). Policies such as injecting taint for all
callback handler arguments or connecting callback argument
ﬂows conservatively risk generating an overwhelming number
of false positives (see Section VIII).
C. Inter-component Communication (ICC)
The Android framework relies heavily on inter-component
communication (ICC) to allow individual components to be
independent and to better manage resources. Components ini-
tiate and connect to other components via android.content
.Intent objects (which can themselves contain a payload).
The resolution of Intent destination is complex [20]. An
Intent can specify a class explicitly, or implicitly allow the
Android system to select a destination based on a Uri and
string ﬁelds. Components register for implicit Intent delivery
programmatically or via their application’s XML manifest.
Service components additionally allow one to send and receive
messages and perform remote procedure calls.
An accurate model of Android must represent the possible
ﬂows via ICC mechanisms. Figure 1(c) gives an example of
three components that communicate via Intent objects and
Service messages. In the example, there is a ﬂow through
ICC from ICCSource through ICCService to ICCSink. In
addition to representing the communication, a model must
consider all possible orderings of component activations.
A blanket conservative policy to deliver Intent objects
and messages to all possible targets may not be acceptable
because applications are typically constructed of many compo-
nents. However, statically calculating the destination of each
Intent requires resolution of Intent values such as Uri
strings and action strings, and reasoning about components’
implicit IntentFilter registration.
III. THREAT MODEL AND LIMITATIONS
In our scenario the application developer (or re-packager) is
malicious. This attacker seeks to exﬁltrate sensitive data from
a mobile device to her servers or to an area on the device that
is unprotected so that a colluding application can perform the
exﬁltration.
Our deﬁnition of sensitive data includes unique device ID,
sensor data (location, acceleration, etc.), ﬁle data, image data
and meta-data, email and SMS messages, passwords, network
trafﬁc, and screen-shots. All of these data items are retrieved
or stored via the Android API; we deﬁne sources of sensitive
data as ﬂows initiated from calls to Android API methods that
we have identiﬁed (see Section IV).
The attacking developer intentionally routes sensitive data
to a destination (on or off the device) that is not authorized
by the user. We deﬁne sinks as Android API calls that may
exﬁltrate data beyond the application boundaries. Sinks include
network, NFC, ﬁle system, email or SMS message, or directly
to a colluding application via ICC or RPC. All of these
sinks are guarded by the Android API. Sinks are identiﬁed
as described in Section IV.
DroidSafe protects against explicit sensitive information
exﬁltration by tracking sensitive source to sink ﬂows present in
the application. DroidSafe analyzes an applications before it is
placed on an app store or before device install. Not every ﬂow
reported by DroidSafe is malicious; maliciousness depends on
the intent of the developer and the security policies of the user
or organization. Thus, the user or a trusted entity reviews the
information ﬂows for malicious leaks.
4
A. Limitations
We assume the device has not been rooted, and dynamic
code loading is not present in the application. We do not aspire
to detect leaks of sensitive data via side channels or implicit
ﬂows [21]. Our trusted computing base on a device is the Linux
kernel and libraries, the Android framework, and the Dalvik
VM.
DroidSafe’s reporting is deﬁned by the source and sink
calls identiﬁed in the Android API. An attacker could exﬁltrate
API-injected information that is not considered sensitive by
DroidSafe, or via a call that is not considered a sink; and it
would not be reported.
Our analysis does not have a fully sound handling of
Java native methods, dynamic class loading, and reﬂection.
However, we compensate for these idioms with aggressive
best-effort policies and analyses. Our analysis has a blanket
ﬂow policy for native methods of an Android application, but
an application could inject a sensitive ﬂow in a native method,
and DroidSafe would not report it. We attempt to aggressively
resolve reﬂection targets in a fashion similar to [22] and [23],
but if a reﬂected invoke cannot be resolved, we inject a special
REFLECTION taint on the method’s arguments and return
value (injected by DroidSafe). Thus we could miss a ﬂow
injected in an unresolved reﬂected call.
Finally, we intend the DroidSafe ADI to accurately reﬂect
the runtime semantics of Android with respect to the infor-
mation ﬂow and points-to information. While we believe we
largely cover the semantics, given the size of the Android
runtime and API we acknowledge that there may be some
methods whose semantics the current ADI does not fully
reﬂect. Different versions exist of Android, and we analyze
an application in the context of Android 4.4.3.
IV. DROIDSAFE’S ANDROID DEVICE IMPLEMENTATION
To our knowledge, our model of Android represents the
most complete, accurate, and precise Android execution model
suitable for static analysis. We accurately and precisely model
complexities such as callback context, life-cycle events, data
ﬂows, heap object instantiations, native methods, and aliasing.
Our Android model is expressed in a single language, standard
Java, matching the source language of Android applications,
and is appropriate for many existing analysis techniques.
One could think of our Android model as a software imple-
mentation of an Android device; along with the application
and harness. Thus we call our model the Android Device
Implementation (ADI).
The ADI is a simpliﬁed (thus easier to analyze) model of
the actual Android system that, with respect to our analysis,
represents a best-effort over approximation of the possible
behaviors of the real system. The combination of an applica-
tion, our ADI core, our harness, the semantic transformations
for ICC (see Section VI), and resources (unique for each
application), creates a closed application for analysis of an
Android application.
A. ADI Core
We seeded our ADI with the Java implementation of the
Android API available from the Android Open Source Project
(AOSP) [15], version 4.0.3, along with additional open-source
libraries upon which the AOSP implementation depends. This
created a code base with no missing dependencies that could
be compiled. This code base was approximately 1.3 MLOC,
however it was missing substantial portions of the semantics
of the Android API and runtime such as native methods, event
ﬁrings, callback initiation, and component life-cycle events.
Furthermore, many commonly used classes included Java
implementations that present difﬁculties for a static analysis.
We therefore developed a novel technique, accurate anal-
ysis stubs, to enable the effective analysis of code whose full
semantics lies outside the scope of AOSP. Each stub is written
in Java and only incompletely models the runtime behavior of
the modeled code. But the semantics of the stub is complete for
the abstractions that the analysis deploys (in this case points-to
and information-ﬂow analyses).
We added accurate analysis stubs for 3,176 native methods
to model the data ﬂow, object instantiation and aliasing of the
missing native code. This was accomplished through a com-
bination of automated and manual means, though all methods
were reviewed manually. We developed concrete implementa-
tions of 45 classes for which concrete implementations are left
to closed-source, commercial libraries.
We simpliﬁed the implementation of 117 classes in the Java
standard library and Android library to increase precision and
decrease analysis time. Examples include container classes,
component classes, I/O classes, primitive wrapper classes,
strings, and threading classes. We attempted to faithfully
maintain the semantics of the original code with respect to
its contract with an Android application and a ﬂow-insensitive
analysis. The base AOSP plus our additions and modiﬁcations
enable our ADI to accurately and precisely track ﬂows through
the API.
B. Event and Callback Dispatch
We created a runtime implementation hooked into the API