# 【漏洞分析】CVE-2016-7290： 微软office word的整数下溢漏洞分析
|
##### 译文声明
本文是翻译文章，文章来源：srcincite.io
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
****
****
**翻译：**[ **myswsun**
****](http://bobao.360.cn/member/contribute?uid=2775084127)
**预估稿费：130RMB**
******投稿方式：发送邮件至**[ **linwei#360.cn**](mailto:PI:EMAIL) **，或登陆**[
**网页版**](http://bobao.360.cn/contribute/index) **在线投稿******
**  
**
**0x00 前言**
这个下溢是当word处理特殊的二进制文档文件时，在复制操作期间越界读取时触发，能够导致winword.exe保护模式下栈的缓冲区溢出问题。
一切听起来是戏剧性的，但是PoC触发只需要越界读取，然而本文将深入分析漏洞细节。
这个漏洞影响Microsoft Word 2007 Service Pack 3, Microsoft Office 2010 Service Pack 2
(32位版本), Microsoft Office 2010 Service Pack 2 (64位版本) 和 Microsoft Office
Compatibility Pack Service Pack
3。更多的细节能从[SRC-2016-0042](http://srcincite.io/advisories/src-2016-0042/)获取。本文所有的分析是基于Microsoft
Office 2010 专业版的winword.exe(v14.0.4734.1000)。
首先，来看下sample和PoC文件的不同之处。
注意到只有一个字节的不同。接下来看下哪个结构块包含了这个不同。
可以看到不同之处在于OneTableDocumentStream数据域中。Sample文件的值为0x68，而poc文件使用0xfa来触发下溢。
**0x01 触发漏洞**
首先，为了调试开启页堆和用户态栈跟踪：
    c:Program FilesDebugging Tools for Windows (x86)>gflags.exe -i winword.exe +hpa +ust
    Current Registry Settings for winword.exe executable are: 02001000
        ust - Create user mode stack trace database
        hpa - Enable page heap
    c:Program FilesDebugging Tools for Windows (x86)>
然后运行poc.doc文件导致以下保护模式外异常访问：
    (880.ac4): Access violation - code c0000005 (first chance)
    First chance exceptions are reported before any exception handling.
    This exception may be expected and handled.
    eax=00000000 ebx=00000000 ecx=00000033 edx=00000002 esi=22870ffd edi=002513c4
    eip=744fb40c esp=0024c694 ebp=0024c69c iopl=0         nv up ei pl nz ac po nc
    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00210212
    MSVCR90!memmove+0xfc:
    744fb40c f3a5            rep movs dword ptr es:[edi],dword ptr [esi]
    0:000> kvn
     # ChildEBP RetAddr  Args to Child              
    00 0024c69c 5e3f9b36 002513bf 22870ff8 000000d3 MSVCR90!memmove+0xfc
    WARNING: Stack unwind information not available. Following frames may be wrong.
    01 0024c6b0 5e413843 22870ff8 002513bf 000000d3 wwlib!DllGetClassObject+0x455a
    02 0024c744 5e413223 002513ac 002513a0 00004ab8 wwlib!GetAllocCounters+0xcadb
    03 00251230 5e4131c6 002513ac 002513a0 00004ab8 wwlib!GetAllocCounters+0xc4bb
    04 00251264 5e45f414 002513ac 002513a0 00004ab8 wwlib!GetAllocCounters+0xc45e
    05 00251280 5e8da8a7 002513a0 22872fe4 00000000 wwlib!GetAllocCounters+0x586ac
    06 002512b8 5e89fdcb 04760520 002513a0 ffffffff wwlib!DllGetLCID+0x2d4521
    07 002567f4 5e66e957 1b132948 04760098 00000000 wwlib!DllGetLCID+0x299a45
    08 002580e0 5e671d5b 04760098 00258928 00000001 wwlib!DllGetLCID+0x685d1
    09 00258584 5e671489 04760098 00258928 1b132948 wwlib!DllGetLCID+0x6b9d5
    0a 0025894c 5e675c10 04760098 00002490 00000000 wwlib!DllGetLCID+0x6b103
    0b 00258998 5e4a6ad4 04760098 1b132948 0000056e wwlib!DllGetLCID+0x6f88a
    0c 002589d4 64270be6 22562f10 0000056e 00000000 wwlib!GetAllocCounters+0x9fd6c
    0d 002589f8 64270ebd 18bea880 18bea998 00258aa8 MSPTLS!FsTransformBbox+0x279b3
    0e 00258a4c 64270f2c 22798de8 00258d40 00000000 MSPTLS!FsTransformBbox+0x27c8a
    0f 00258aec 64271196 00258d40 00000000 00000000 MSPTLS!FsTransformBbox+0x27cf9
    10 00258ca0 6425736a 22798de8 227f0ca0 00000000 MSPTLS!FsTransformBbox+0x27f63
    11 00258db4 6428aa6f 22826fd0 00000000 00000000 MSPTLS!FsTransformBbox+0xe137
    12 00258eac 6426fbb9 22798de8 227f0ca0 00000000 MSPTLS!FsTransformBbox+0x4183c
    13 00259000 6425684e 22798de8 00000000 00000000 MSPTLS!FsTransformBbox+0x26986
**0x02 调查访问的内存**
第一步我们要检查在崩溃时访问的内存。
    0:000> !heap -p -a @esi
        address 22870ffd found in
        _DPH_HEAP_ROOT @ 61000
        in busy allocation (  DPH_HEAP_BLOCK:         UserAddr         UserSize -         VirtAddr         VirtSize)
                                    227a13a8:         22870fe0               19 -         22870000             2000
        67be8e89 verifier!AVrfDebugPageHeapAllocate+0x00000229
        77126206 ntdll!RtlDebugAllocateHeap+0x00000030
        770ea127 ntdll!RtlpAllocateHeap+0x000000c4
        770b5950 ntdll!RtlAllocateHeap+0x0000023a
        5de2d804 mso!Ordinal149+0x000074b0
        5e6a754d wwlib!DllGetLCID+0x000a11c7
        5e7debc2 wwlib!DllGetLCID+0x001d883c
        5e41f313 wwlib!GetAllocCounters+0x000185ab
        5e41ec32 wwlib!GetAllocCounters+0x00017eca
        5e41eb57 wwlib!GetAllocCounters+0x00017def
        5e41e72a wwlib!GetAllocCounters+0x000179c2
        5e423d89 wwlib!GetAllocCounters+0x0001d021
        5e6acca5 wwlib!DllGetLCID+0x000a691f
        5e422aa0 wwlib!GetAllocCounters+0x0001bd38
        5e43ed59 wwlib!GetAllocCounters+0x00037ff1
        5e43ec61 wwlib!GetAllocCounters+0x00037ef9
        5e48f0c3 wwlib!GetAllocCounters+0x0008835b
        5e48f050 wwlib!GetAllocCounters+0x000882e8
        5e4a6aba wwlib!GetAllocCounters+0x0009fd52
        64270be6 MSPTLS!FsTransformBbox+0x000279b3
        64270ebd MSPTLS!FsTransformBbox+0x00027c8a
        64270f2c MSPTLS!FsTransformBbox+0x00027cf9
        64271196 MSPTLS!FsTransformBbox+0x00027f63
        6425736a MSPTLS!FsTransformBbox+0x0000e137
        6428aa6f MSPTLS!FsTransformBbox+0x0004183c
        6426fbb9 MSPTLS!FsTransformBbox+0x00026986
        6425684e MSPTLS!FsTransformBbox+0x0000d61b
        6426ad48 MSPTLS!FsTransformBbox+0x00021b15
        6428573e MSPTLS!FsTransformBbox+0x0003c50b
        64285910 MSPTLS!FsTransformBbox+0x0003c6dd
        64285c7b MSPTLS!FsTransformBbox+0x0003ca48
        6426b17a MSPTLS!FsTransformBbox+0x00021f47
    0:000> !address @edi
     ProcessParametrs 00069738 in range 00069000 0006a000
     Environment 02b233d8 in range 02b23000 02b24000
        00160000 : 0023d000 - 00023000
                        Type     00020000 MEM_PRIVATE
                        Protect  00000004 PAGE_READWRITE
                        State    00001000 MEM_COMMIT
                        Usage    RegionUsageStack
                        Pid.Tid  880.ac4    
    0:000> dd @esi
    22870ffd  ???????? ???????? ???????? ????????
    2287100d  ???????? ???????? ???????? ????????
    2287101d  ???????? ???????? ???????? ????????
    2287102d  ???????? ???????? ???????? ????????
    2287103d  ???????? ???????? ???????? ????????
    2287104d  ???????? ???????? ???????? ????????
    2287105d  ???????? ???????? ???????? ????????
    2287106d  ???????? ???????? ???????? ????????
    0:000> ?@ecx*4
    Evaluate expression: 204 = 000000cc
可以看到越界读取了一个0x19字节的堆内存，试着将另外的204个字节复制到edi中。
正如结果，栈变量在顶上6个栈桢传递，下面的是通过其他变量和偏移动态计算的。没有符号直接加大了跟踪的难度。
**0x03 写内存**
如果我们继续从esi读，那么可以假定继续写是安全的。我知道这是一个大的猜测，但是利用[ole堆喷射](https://www.greyhathacker.net/?p=911)或者得到使用[eps](https://www.fireeye.com/blog/threat-research/2015/12/the_eps_awakens.html)的的堆，是有可能控制那个偏移的数据的。但是如何覆写？我们看下目标栈地址：
    0:000> !py mona do -a 002513c4 -s 0xcc
    Hold on...
    [+] Command used:
    !py mona.py do -a 002513c4 -s 0xcc
    ----------------------------------------------------    [+] Dumping object at 0x002513c4, 0xcc bytes
    [+] Preparing output file 'dumpobj.txt'
        - (Re)setting logfile dumpobj.txt
    [+] Generating module info table, hang on...