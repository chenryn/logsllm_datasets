# 【漏洞分析】CVE-2016-7290：微软Office Word的整数下溢漏洞分析

## 译文声明
本文是翻译文章，原文来源：srcincite.io  
原文地址：[SRC-2016-0042](http://srcincite.io/advisories/src-2016-0042/)  
译文仅供参考，具体内容表达及含义以原文为准。

**翻译：** [myswsun](http://bobao.360.cn/member/contribute?uid=2775084127)  
**预估稿费：** 130 RMB  
**投稿方式：** 发送邮件至 [linwei#360.cn](mailto:linwei@360.cn)，或登录 [网页版](http://bobao.360.cn/contribute/index) 在线投稿。

---

### 0x00 前言
该整数下溢漏洞在Word处理特定二进制文档文件时触发，具体发生在复制操作期间越界读取时。这一行为可能导致`winword.exe`在保护模式下的栈缓冲区溢出问题。尽管听起来非常严重，但PoC仅需通过越界读取即可触发。本文将深入探讨该漏洞的细节。

受影响版本包括Microsoft Word 2007 Service Pack 3, Microsoft Office 2010 Service Pack 2 (32位和64位版本), 以及Microsoft Office Compatibility Pack Service Pack 3。更多详情请参阅[SRC-2016-0042](http://srcincite.io/advisories/src-2016-0042/)。本文所有分析基于Microsoft Office 2010 专业版的`winword.exe`（v14.0.4734.1000）。

首先，我们来看一下样本文件与PoC文件之间的差异。

注意到两者之间只有一个字节不同。接下来，我们查看哪个结构块包含此差异。

可以看到，不同之处在于`OneTableDocumentStream`数据域中。样本文件的值为`0x68`，而PoC文件使用`0xfa`来触发下溢。

### 0x01 触发漏洞
为了调试目的，我们需要启用页堆和用户态栈跟踪：

```sh
c:\Program Files\Debugging Tools for Windows (x86)>gflags.exe -i winword.exe +hpa +ust
Current Registry Settings for winword.exe executable are: 02001000
    ust - Create user mode stack trace database
    hpa - Enable page heap
```

运行PoC文件（`poc.doc`），导致以下保护模式外异常访问：

```sh
(880.ac4): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00000000 ebx=00000000 ecx=00000033 edx=00000002 esi=22870ffd edi=002513c4
eip=744fb40c esp=0024c694 ebp=0024c69c iopl=0         nv up ei pl nz ac po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00210212
MSVCR90!memmove+0xfc:
744fb40c f3a5            rep movs dword ptr es:[edi],dword ptr [esi]
0:000> kvn
 # ChildEBP RetAddr  Args to Child              
00 0024c69c 5e3f9b36 002513bf 22870ff8 000000d3 MSVCR90!memmove+0xfc
WARNING: Stack unwind information not available. Following frames may be wrong.
01 0024c6b0 5e413843 22870ff8 002513bf 000000d3 wwlib!DllGetClassObject+0x455a
02 0024c744 5e413223 002513ac 002513a0 00004ab8 wwlib!GetAllocCounters+0xcadb
03 00251230 5e4131c6 002513ac 002513a0 00004ab8 wwlib!GetAllocCounters+0xc4bb
04 00251264 5e45f414 002513ac 002513a0 00004ab8 wwlib!GetAllocCounters+0xc45e
05 00251280 5e8da8a7 002513a0 22872fe4 00000000 wwlib!GetAllocCounters+0x586ac
06 002512b8 5e89fdcb 04760520 002513a0 ffffffff wwlib!DllGetLCID+0x2d4521
07 002567f4 5e66e957 1b132948 04760098 00000000 wwlib!DllGetLCID+0x299a45
08 002580e0 5e671d5b 04760098 00258928 00000001 wwlib!DllGetLCID+0x685d1
09 00258584 5e671489 04760098 00258928 1b132948 wwlib!DllGetLCID+0x6b9d5
0a 0025894c 5e675c10 04760098 00002490 00000000 wwlib!DllGetLCID+0x6b103
0b 00258998 5e4a6ad4 04760098 1b132948 0000056e wwlib!DllGetLCID+0x6f88a
0c 002589d4 64270be6 22562f10 0000056e 00000000 wwlib!GetAllocCounters+0x9fd6c
0d 002589f8 64270ebd 18bea880 18bea998 00258aa8 MSPTLS!FsTransformBbox+0x279b3
0e 00258a4c 64270f2c 22798de8 00258d40 00000000 MSPTLS!FsTransformBbox+0x27c8a
0f 00258aec 64271196 00258d40 00000000 00000000 MSPTLS!FsTransformBbox+0x27cf9
10 00258ca0 6425736a 22798de8 227f0ca0 00000000 MSPTLS!FsTransformBbox+0x27f63
11 00258db4 6428aa6f 22826fd0 00000000 00000000 MSPTLS!FsTransformBbox+0xe137
12 00258eac 6426fbb9 22798de8 227f0ca0 00000000 MSPTLS!FsTransformBbox+0x4183c
13 00259000 6425684e 22798de8 00000000 00000000 MSPTLS!FsTransformBbox+0x26986
```

### 0x02 调查访问的内存
首先，我们检查崩溃时访问的内存。

```sh
0:000> !heap -p -a @esi
address 22870ffd found in
_DPH_HEAP_ROOT @ 61000
in busy allocation (  DPH_HEAP_BLOCK:         UserAddr         UserSize -         VirtAddr         VirtSize)
                                227a13a8:         22870fe0               19 -         22870000             2000
67be8e89 verifier!AVrfDebugPageHeapAllocate+0x00000229
77126206 ntdll!RtlDebugAllocateHeap+0x00000030
770ea127 ntdll!RtlpAllocateHeap+0x000000c4
770b5950 ntdll!RtlAllocateHeap+0x0000023a
5de2d804 mso!Ordinal149+0x000074b0
5e6a754d wwlib!DllGetLCID+0x000a11c7
5e7debc2 wwlib!DllGetLCID+0x001d883c
5e41f313 wwlib!GetAllocCounters+0x000185ab
5e41ec32 wwlib!GetAllocCounters+0x00017eca
5e41eb57 wwlib!GetAllocCounters+0x00017def
5e41e72a wwlib!GetAllocCounters+0x000179c2
5e423d89 wwlib!GetAllocCounters+0x0001d021
5e6acca5 wwlib!DllGetLCID+0x000a691f
5e422aa0 wwlib!GetAllocCounters+0x0001bd38
5e43ed59 wwlib!GetAllocCounters+0x00037ff1
5e43ec61 wwlib!GetAllocCounters+0x00037ef9
5e48f0c3 wwlib!GetAllocCounters+0x0008835b
5e48f050 wwlib!GetAllocCounters+0x000882e8
5e4a6aba wwlib!GetAllocCounters+0x0009fd52
64270be6 MSPTLS!FsTransformBbox+0x000279b3
64270ebd MSPTLS!FsTransformBbox+0x00027c8a
64270f2c MSPTLS!FsTransformBbox+0x00027cf9
64271196 MSPTLS!FsTransformBbox+0x00027f63
6425736a MSPTLS!FsTransformBbox+0x0000e137
6428aa6f MSPTLS!FsTransformBbox+0x0004183c
6426fbb9 MSPTLS!FsTransformBbox+0x00026986
6425684e MSPTLS!FsTransformBbox+0x0000d61b
6426ad48 MSPTLS!FsTransformBbox+0x00021b15
6428573e MSPTLS!FsTransformBbox+0x0003c50b
64285910 MSPTLS!FsTransformBbox+0x0003c6dd
64285c7b MSPTLS!FsTransformBbox+0x0003ca48
6426b17a MSPTLS!FsTransformBbox+0x00021f47
0:000> !address @edi
ProcessParametrs 00069738 in range 00069000 0006a000
Environment 02b233d8 in range 02b23000 02b24000
00160000 : 0023d000 - 00023000
                Type     00020000 MEM_PRIVATE
                Protect  00000004 PAGE_READWRITE
                State    00001000 MEM_COMMIT
                Usage    RegionUsageStack
                Pid.Tid  880.ac4    
0:000> dd @esi
22870ffd  ???????? ???????? ???????? ????????
2287100d  ???????? ???????? ???????? ????????
2287101d  ???????? ???????? ???????? ????????
2287102d  ???????? ???????? ???????? ????????
2287103d  ???????? ???????? ???????? ????????
2287104d  ???????? ???????? ???????? ????????
2287105d  ???????? ???????? ???????? ????????
2287106d  ???????? ???????? ???????? ????????
0:000> ?@ecx*4
Evaluate expression: 204 = 000000cc
```

可以看到，程序越界读取了大小为`0x19`字节的堆内存，并尝试将另外204个字节复制到`edi`中。正如结果所示，栈变量在顶部六个栈帧中传递，其余部分通过其他变量和偏移动态计算。没有符号信息使得跟踪变得更加困难。

### 0x03 写内存
如果我们继续从`esi`读取，可以假设继续写入也是安全的。这是一个大胆的假设，但通过使用[OLE堆喷射](https://www.greyhathacker.net/?p=911)或[EPS](https://www.fireeye.com/blog/threat-research/2015/12/the_eps_awakens.html)技术控制偏移的数据是可能的。那么如何覆盖？我们来看看目标栈地址：

```sh
0:000> !py mona do -a 002513c4 -s 0xcc
Hold on...
[+] Command used:
!py mona.py do -a 002513c4 -s 0xcc
----------------------------------------------------    [+] Dumping object at 0x002513c4, 0xcc bytes
[+] Preparing output file 'dumpobj.txt'
    - (Re)setting logfile dumpobj.txt
[+] Generating module info table, hang on...
```