title:Understanding Open Ports in Android Applications: Discovery, Diagnosis,
and Security Assessment
author:Daoyuan Wu and
Debin Gao and
Rocky K. C. Chang and
En He and
Eric K. T. Cheng and
Robert H. Deng
Understanding Open Ports in Android Applications:
Discovery, Diagnosis, and Security Assessment
Daoyuan Wu1, Debin Gao1, Rocky K. C. Chang2, En He3, Eric K. T. Cheng2, and Robert H. Deng1
1Singapore Management University
2The Hong Kong Polytechnic University
3China Electronic Technology Cyber Security Co., Ltd.
Abstract—Open TCP/UDP ports are traditionally used by
servers to provide application services, but they are also found in
many Android apps. In this paper, we present the ﬁrst open-
port analysis pipeline, covering the discovery, diagnosis, and
security assessment, to systematically understand open ports in
Android apps and their threats. We design and deploy a novel on-
device crowdsourcing app and its server-side analytic engine to
continuously monitor open ports in the wild. Over a period of ten
months, we have collected over 40 million port monitoring records
from 3,293 users in 136 countries worldwide, which allow us to
observe the actual execution of open ports in 925 popular apps
and 725 built-in system apps. The crowdsourcing also provides
us a more accurate view of the pervasiveness of open ports in
Android apps at 15.3%, much higher than the previous estimation
of 6.8%. We also develop a new static diagnostic tool to reveal that
61.8% of the open-port apps are solely due to embedded SDKs,
and 20.7% suffer from insecure API usages. Finally, we perform
three security assessments of open ports: (i) vulnerability analysis
revealing ﬁve vulnerability patterns in open ports of popular apps,
e.g., Instagram, Samsung Gear, Skype, and the widely-embedded
Facebook SDK, (ii) inter-device connectivity measurement in 224
cellular networks and 2,181 WiFi networks through crowdsourced
network scans, and (iii) experimental demonstration of effective
denial-of-service attacks against mobile open ports.
I.
INTRODUCTION
A network port is an abstraction of a communication point.
Servers on the Internet offer their services by “opening” a
port for clients to send requests to, e.g., web servers on
TCP port 80. A TCP/UDP port
is regarded as open if a
server process listens for incoming packets destined to the
port and potentially responds to them. Since mobile devices
are generally not suitable for providing network services due
to their non-routable addresses and lack of CPU and bandwidth
resources, one may argue that mobile apps are not suitable for
hosting open ports. However, a few recent studies have shown
otherwise and these open ports are susceptible to various
attacks. Lin et al. [57] demonstrated the insecurity of local TCP
open ports used in non-rooted Android screenshot apps. Wu
et al. [79] found that the top ten ﬁle-sharing apps on Android
and iOS typically do not authenticate trafﬁc to their ports. Bai
et al. [83] further revealed the insecurity of Apple ZeroConf
techniques that are powered by ports such as 5353 for mDNS.
Network and Distributed Systems Security (NDSS) Symposium 2019
24-27 February 2019, San Diego, CA, USA
ISBN 1-891562-55-X
https://dx.doi.org/10.14722/ndss.2019.23171
www.ndss-symposium.org
Beyond these manual studies on speciﬁc apps, Jia et al. [52]
recently developed a static tool OPAnalyzer to identify TCP
open ports and detect vulnerable ones in Android apps. They
identiﬁed potential open ports in 6.8% of the top 24,000
Android apps, among which around 400 apps were likely
vulnerable and 57 were manually conﬁrmed. Nevertheless,
OPAnalyzer still suffers from the inherent limitation of static
analysis (i.e., the code detected might not execute) and the
incapability of typical Android static analysis to handle dy-
namic code loading [65], [67], complex implicit ﬂows [43],
[66], and advanced code obfuscation [46], [78]. Moreover, the
focus of OPAnalyzer is about detecting permission-misuse-
related vulnerabilities in TCP open ports (via pre-selected sink
APIs), while the entire picture of open ports in the Android
ecosystem is still largely unexplored.
In this paper, we aim to systematically understand open
ports in Android apps and their threats by proposing the ﬁrst
analysis pipeline that covers the open port discovery, diagnosis,
and security assessment. The key of this pipeline is to employ
crowdsourcing, instead of static analysis, for the open port
discovery, and use static analysis only for the diagnosis of
discovered open ports. As shown in Fig. 1, our pipeline ﬁrst
adopts a novel crowdsourcing approach to continuously mon-
itor open ports in the wild, and then employs static analysis
to collect and diagnose the code-level information of discov-
ered open ports. It also performs three security assessments:
vulnerability analysis, inter-device connectivity measurement,
and denial-of-service attack evaluation. We further elaborate
our contributions as follows.
First, we design and deploy the ﬁrst crowdsourcing plat-
form (an on-device monitoring app and a server-side analytic
engine) to continuously monitor open-port apps without user
intervention, and show that such a crowdsourcing approach is
more effective than static analysis in open port discovery. Our
Android app, NetMon1, has been available on Google Play for
an IRB-approved crowdsourcing study since October 2016. It
is still an on-going deployment cumulatively with 6K+ installs.
In this paper, we base our analysis on the data over ten months
(a period when most of our evaluations were performed and
security ﬁndings were conﬁrmed), which already generates a
large number of port monitoring records (over 40 million) from
a wide spectrum of users (3,293 phones from 136 countries).
It enables us to observe the actual open ports in execution
on 2,778 Android apps,
including 925 popular ones from
Google Play and 725 built-in apps pre-installed by over 20
1NetMon is short for “Network Scanner & Port Monitor” and is available
at https://play.google.com/store/apps/details?id=com.netmon.
Fig. 1: The workﬂow of our open-port analysis pipeline (methodology shown in colored blocks and results shown in rounded blocks).
phone manufacturers. Besides the built-in apps missed by
OPAnalyzer, NetMon also covers both TCP and UDP ports.
We further quantify the efﬁcacy of crowdsourcing through a
comparison with static analysis. Out of the 1,027 apps that are
conﬁrmed with TCP open ports by our crowdsourcing, 25.1%
of them use dynamic or obfuscated codes for open ports, and
only 58.9% can be detected by typical Android static analysis
techniques. With the help of NetMon, we manage to quantify
the pervasiveness of open ports in a controlled set of the top
3,216 apps from Google Play, and ﬁnd TCP open ports in
492 of them. This level of pervasiveness (15.3%) is more than
twice previously reported (6.8%) using static analysis [52].
Moreover, we are the ﬁrst to measure the distribution of open-
port apps across all 33 Google Play categories.
While crowdsourcing is effective in port discovery, it does
not reveal the code-level information for more in-depth under-
standing and diagnosis. As the second contribution, we include
a diagnosis phase through OPTool, a new static analysis tool
enhanced with open-port context and semantics, to understand
the code-level open port constructions and the corresponding
security implications. We focus on two kinds of diagnoses:
whether an open port is introduced by developers themselves
or embedded via a third-party SDK (Software Development
Kit) by default, and whether developers apply secure open-port
coding practice. The detection results are quite alarming. First,
13 popular SDKs are identiﬁed with open ports and 61.8% of
open-port apps are solely due to these SDKs, among which
Facebook SDK is the major contributor. Second, 20.7% of
the open-port apps make convenient but insecure API calls,
unnecessarily increasing their attack surfaces.
In the last phase of our pipeline, we perform three novel
security assessments of open ports:
Vulnerability analysis. Unlike OPAnalyzer which concentrates
on the pre-deﬁned vulnerability pattern, our vulnerability
analysis aims to identify popular apps’ vulnerabilities that
may not contain a ﬁxed pattern — therefore more difﬁcult
to detect. The ﬁve vulnerability patterns identiﬁed by us
present themselves in apps, such as Instagram, Samsung
Gear, Skype, and the widely-embedded Facebook SDK.
Denial-of-service attack evaluation. We experimentally eval-
uate the effectiveness of a generic denial-of-service
(DoS) attack against mobile open ports. We show that
DoS attacks can signiﬁcantly and effectively downgrade
YouTube’s video streaming, WeChat’s voice call, and
AirDroid’s ﬁle transmission via their open ports.
Inter-device connectivity measurement. Remote open-port at-
tacks require the victim device to be connected (intra-
or inter-network). To measure the extent to which this
requirement is satisﬁed, we extend NetMon to conduct
inter-device connectivity tests. With 6,391 network scan
traces collected from devices in 224 cellular networks and
2,181 WiFi networks worldwide, we ﬁnd that 49.6% of
the cellular networks and 83.6% of the WiFi networks
allow devices to directly connect to each other in the same
network. Furthermore, 23 cellular networks and 10 WiFi
networks assign public IP addresses to their users, which
allows inter-network connectivity from the Internet.
II. BACKGROUND AND THREAT MODEL
Before presenting our analysis pipeline, we ﬁrst introduce
the necessary background and our threat model.
An open port, in this paper, is deﬁned as a TCP/UDP port
that binds to any legitimate IP address and is conﬁgured to
accept packets. Legitimate IP address includes public, private,
any (0.0.0.0), and also the local loopback IP address. We
use such a generalized deﬁnition primarily due to the threat
model in smartphones — any third-party apps running on the
phone could be untrusted and could utilize even the local
loopback address for attacks. To make it simple, we use host
IP address to refer to all IP addresses except the loopback
IP address, which will be explicitly stated. Under such a
convention, a local open port refers to one that binds to the
loopback address.
Open ports on Android are typically created using TCP
stream or UDP datagram sockets. BluetoothSocket [10]
(in Android SDK), NFCSocket [26] (an open-source li-
brary), and in particular, the previously studied UNIX domain
socket [71] are out of our scope because they do not use
network ports. For example, Unix domain sockets use ﬁle
system as their address name space, and therefore there are
no IP addresses and port numbers. The communication also
occurs entirely within the operating system between processes.
We consider three types of adversaries in our threat model:
• A local adversary is an attack app installed on the device
on which the victim app (with open ports) runs. Such a
adversary does not require sensitive permissions but needs
the INTERNET permission to access the open ports.
• A remote adversary resides in the same WiFi or cellular
network to which the victim device connects. Such an
2
Raw recordsDevices with NetMoninstalledOpen Port MonitoringviaNetMon(§III.A)Crowd-sourced Open Ports (§III.C)Open-Port Analytic Engine (§III.B)Static Analysis via OPTool(§IV.A-C)Vulnerability Analysis(§V.A)Inter-device Connectivity MeasurementviaNetMon(§V.C)Denial-of-Service Attack Evaluation (§V.B)Detection of Open-Port SDKs (§IV.D)Identification of Insecure API Usages (§IV.E)Security AssessmentDiscoveryDiagnosisPortresultsSecurity Assessmentadversary can send TCP/UDP packets to other nodes if the
network provides intra-network connectivity or even inter-
network connectivity (with public IP addresses assigned
to clients), surprisingly true for numerous networks as we
will show in Sec. V-C.
• A web adversary remotely exploits a victim’s open ports
by enticing the victim to browse a JavaScript-enabled
web page under the adversary’s control. This threat is
only applicable to HTTP-based ports with a ﬁxed port
number, because (i) JavaScript and WebSocket can issue
only HTTP packets, and (ii) the resource constraint makes
it infeasible for a web page to iterate the ephemeral port
range [16] according to our test.
Note that local open ports could be attacked only by the
ﬁrst and the third adversaries, while other open ports may
suffer from all three adversaries.
III. DISCOVERY VIA CROWDSOURCING
The ﬁrst phase of our pipeline is to discover open ports.
Instead of using static analysis as in [52], we propose the ﬁrst
crowdsourcing approach for the discovery of open ports. It has
the following unique advantages: (i) it can monitor open ports
in the wild, covering not only third-party apps but also built-
in apps that are usually difﬁcult to analyze due to the heavy
Android fragmentation [5]; (ii) it results in no false positive;
(iii) it captures the exact port number and IP address used
as well as their timestamps; and (iv) it covers both TCP and
UDP ports. Furthermore, as to be evaluated in Sec. III-C3,
our crowdsourcing is much more effective in terms of port
discovery than typical Android static analysis, which cannot
handle dynamic code loading [65], [67], complex implicit
ﬂows [43], [66], and advanced code obfuscation [46], [78].
Our crowdsourcing platform consists of an on-device port
monitoring app NetMon (Sec. III-A) and a server-side open-
port analytic engine (Sec. III-B). We have deployed NetMon
to Google Play and collected the crowdsourcing results from a
large number of real users (Sec. III-C). Before moving to the
technical details, it is worth highlighting the overall challenges
in our crowdsourcing approach. The development of NetMon
requires us to handle many product-level issues for a long-term
and user-friendly deployment, let alone we are the ﬁrst to ex-
plore on-device crowdsourcing for monitoring other open-port
apps in real user devices. Moreover, compared to the typical
app-based crowdsourcing (e.g., Netalyzer [75], MopEye [80],
and Haystack [69]), our open-port crowdsourcing is unique
in that the collected raw records cannot be directly analyzed
due to the existence of random port numbers. We thus need
to design an “intelligent” analytic engine that can effectively
cluster raw records into per-app open port results.
A. On-device Open Port Monitoring
Different from ZMap [53] and Nmap [27] that probe ports
by externally sending network trafﬁc, we launch on-device
port monitoring directly on crowdsourced devices to collect
not only open port numbers but also their app information.
Fig. 2 shows two NetMon user interfaces for port monitoring.
Fig. 2(a) shows a partial list of apps running with open ports,
while Fig. 2(b) shows the detailed records for a speciﬁc app
(YouTube), including the TCP/UDP port numbers, IP addresses
to which the ports bind, and the timestamps.
(a) A sample of open-port apps.
(b) Detailed records for YouTube.
Fig. 2: User interfaces in NetMon showing open ports.
Port monitoring mechanism. NetMon leverages a pub-
lic interface in the proc ﬁle system [29]
to moni-
tor open ports created by all apps on the device. The
four pseudo ﬁles under the /proc/net/ directory (i.e.,
/proc/net/tcp|tcp6|udp|udp6) serve as a real-time
interface to the TCP and UDP socket tables in the kernel
space. Each pseudo ﬁle contains a list of current socket entries,
including both client and server sockets. Any Android app can
access these pseudo ﬁles without explicit permissions, and this
works on all Android versions including the latest Android 9.
By using such an interface, NetMon can obtain the following
port-related information:
• Socket address. It covers a port number and an IP address.
• TCP socket state. There are 12 possible TCP states [34],
• The app UID. Using the PackageManager APIs, Net-
such as LISTEN and ESTABLISHED.
Mon obtains the app’s name from its UID (user ID).
According to the deﬁnition in Sec. II, NetMon considers
server ports as open ports. Therefore, it identiﬁes a TCP open
port from the proc ﬁle when it is in the LISTEN state. On
the other hand, since UDP has no state information, we rely on
the server-side analytic engine to further identify UDP open
ports. Hence, the collected UDP port records are only the initial
results and not all of them will be treated as open ports (e.g.,
the client UDP port used by YouTube in Fig. 2(b)).
Challenges. The goal of long-term port monitoring on real
user devices requires NetMon to periodically analyze those
four proc ﬁles with minimal overhead. A simple idea of
creating a “long-lived” service to periodically monitor open
ports would not work as the service will be stopped by
Android after a certain amount of time (e.g., after the device
goes to sleep) or simply terminated by users. To overcome
this, we leverage Android AlarmManager [2] to schedule
periodic alarms to perform the proc ﬁle analysis robustly. We
chose ﬁve minutes as the alarm interval because it provides a
good sampling rate (excluding many client UDP ports) while
incurring negligible overhead. Our experience shows that the
potential information loss within the ﬁve-minute interval is
well compensated by the large number of users contributing
data in our crowdsourcing campaign. Moreover, we take ad-
vantage of the batched alarm mechanism [3] introduced since
Android 4.4 and a characteristic in /proc/net/tcp6|tcp
— the server socket entries always appear in the top rows —
to further minimize the overhead. As a result, NetMon incurs
less than 1% overhead on CPU and battery for a daily usage.
3
Fig. 3: An overview of our server-side open-port analytic engine to perform the three-step clustering (using Netﬂix as an example).
B. Server-side Open-Port Analytic Engine
The open port
information gathered from individual
phones, e.g., the Netﬂix app opens TCP port 9080 at time t1
and opens UDP port 39798 at time t2, constitute individual
observations that need to be clustered to generate per-app
open port results, e.g., Netﬂix has a ﬁxed TCP port 9080
and a random UDP port. More speciﬁcally, different port
records associated with the same “random” open port should
be uniﬁed, and open ports with “ﬁxed” port numbers should
be recognized. This may sound straightforward, but it turns
out to be a challenging task because ﬁxed and random ports
could exhibit indistinguishable observations. To overcome this
challenge, we introduce a server-side analytic engine, as shown
in Fig. 3, to perform a three-step clustering:
Step 1: Aggregation. We ﬁrst aggregate each app’s obser-
vations by different types of ports and IP addresses. This is
a “narrow down” step to effectively reduce the complexity of
clustering — open ports with different types or IP addresses
shall be in different clusters, since they are created by different
APIs or InetAddress parameters at the code level. Specif-