用户名 
密码 
代码清单 /31/31-021.php
 登录 
登录成功
 我的账号 
代码清单 /31/31-022.php
 我的账号 
用户名 :
同 Basic 认证的例子一样，随便输入 ID 和密码就能成功通过认证。页面跳转流程如下图所示。
图 3-20 示例应用的页面跳转
最初显示 31-020.php 的 ID 和密码输入页面时，返回的响应消息如下（仅列出要点）。
HTTP/1.1 200 OK
Set-Cookie: PHPSESSID=gg5144avrhmdiaelvh80l4lb53; path=/
Content-Length: 279
Content-Type: text/html; charset=UTF-8
 请登录 
【以下略】
通过 Set-Cookie 响应头信息，Web 服务器向浏览器下达了记住此 Cookie 值的指示。
在登录页面上输入 ID 和密码后点击“登录”按钮，浏览器就会向服务器发送如下请求。
POST /31/31-021.php HTTP/1.1
Referer: http://example.jp/31/31-020.php
Content-Type: application/x-www-form-urlencoded
Host: example.jp
Content-Length: 18
Cookie: PHPSESSID=gg5144avrhmdiaelvh80l4lb53
ID=user1&PWD=pass1
记住了 Cookie 值的浏览器，从此再向相同网站（example.jp）发送请求时，就会同时发送此 Cookie 值（PHPSESSID=…）。Cookie 可以设置有效期限，没有设置有效期限的 Cookie 会在浏览器被关闭之前一直有效。
Cookie 中 PHPSESSID 的值被称为会话 ID，它是访问会话信息的关键。31-021.php 中，认证成功后的用户 ID 被保存在会话变量 $_SESSION['ID']
 中。随后程序在 31-022.php 中取得了此用户 ID。保存在会话变量中的信息，在会话失效之前随时都能被访问。
使用 Cookie 的会话管理
Cookie 能让浏览器记忆少量数据，但保存应用程序的数据时几乎不会使用 Cookie，理由如下。
Cookie 能保存的值的数量和字符串长度有限
Cookie 的值能被用户自己看到或更改，所以不适用于存储敏感信息
因此，可以采用在 Cookie 中保存类似于“受理编号”的会话 ID，实际对应的值则保存在服务器端的方法。这种方法被称为“使用 Cookie 的会话管理”，目前有着非常广泛的应用。PHP 等主流 Web 应用开发工具中已经提供了这种会话管理的机制。
会话管理的拟人化解说
将解说 Basic 认证时使用的银行窗口业务的比喻，转换为会话管理版本，其详情如下。
顾客：你好。
柜员：您的受理编号为 005。请提供您的银行卡号和密码。
顾客：受理编号为 005。卡号为 12345，密码为 9876，请确认。
柜员：身份核实完毕。
顾客：受理编号为 005。请帮我查下余额。
柜员：余额为 5 万元。
顾客：受理编号为 005。请向卡号 23456 的账户转账 3 万元。
柜员：转账完毕。
对话中的受理编号即为会话 ID。顾客每次都要向柜员汇报受理编号，正如浏览器每次都自动向服务器发送 Cookie 一样。
但是，005 这个受理编号多少让人感到不安。因为随便换一个相近的号码，就有可能假冒他人。比如像下面这样。
恶人：你好。
柜员：您的受理编号为 006。请提供您的银行卡号和密码。
恶人将受理编号减去 1 变成了 005。假设受理编号为 005 的顾客已经通过了身份核实。
恶人：受理编号为 005。请向卡号 99999 的账户转账 3 万元。
柜员：转账完毕。
仅仅更改了受理编号，就能成功使用他人的账户进行转账。
由此可见，会话 ID 不能使用连续的数字，而应当使用位数足够长的随机数，刚才看到的 PHPSESSID 的值有 26 位也正是出于这个原因。综上，会话 ID 需要满足如下需求。
需求 1：会话 ID 不能被第三方推测
需求 2：会话 ID 不能被第三方劫持
需求 3：会话 ID 不能向第三方泄漏
需求 1 的会话 ID 不能被推测，本质上要求的是随机数的质量问题。如果随机数存在规律性，就能够通过收集足够多的会话 ID 来推测别人的会话 ID。因此，会话 ID 的随机数可以使用密码学级别的伪随机数生成器生成，伪随机数生成器的范例在电子政府推荐密码列表 8
 中有所记载。
但是实际开发的过程中，会话 ID 并非自己手动生成，而应该使用 Web 应用开发工具（PHP、Tomcat、.NET 等）提供的会话 ID。这些主流开发工具经受着全球研究者的调查，因此，即使生成会话 ID 的处理有问题，也一定会被作为安全隐患而得到改善。以笔者多年诊断安全隐患的经验来看，自己实现的会话管理机制中混入安全隐患的例子不在少数。所以务必不要自己来实现会话管理机制。关于会话管理不完善所导致的安全隐患问题，4.6 节中会进行细述。
要点
  使用开发工具提供的会话管理机制。
接着，关于需求 2 的会话 ID 不能被劫持，最初使用银行窗口业务的比喻来说明的流程中其实存在安全问题。具体请看下面对话中的攻击流程。
恶人：你好。
柜员：您的受理编号为 9466ir8fgmmk1gn6raeo7ne71。请提供您的银行卡号和密码。
恶人暂时离开柜台并等待来客。有顾客进入银行时，恶人冒充银行柜员向顾客搭话。
恶人：您的受理编号为 9466ir8fgmmk1gn6raeo7ne71。
顾客：知道了。
顾客走向柜台。
顾客：我的受理编号为 9466ir8fgmmk1gn6raeo7ne71。
柜员：请提供您的银行卡号和密码。
顾客：受理编号为 9466ir8fgmmk1gn6raeo7ne71。卡号为 12345，密码为 9876，请确认。
柜员：身份核实完毕。
顾客执行完身份确认后恶人也走向了柜台。
恶人：受理编号为 9466ir8fgmmk1gn6raeo7ne71。请向卡号 99999 的账户转账 3 万元。
柜员：转账完毕。
像这样，恶人（攻击者）劫持正规用户的会话 ID 来进行攻击的手法被称为会话固定攻击（Session Fixation Attack）。详情将在 4.6.4 节中讲述，这里我们可以先尝试修复此安全隐患。从客人进入银行开始。
有顾客进入银行时，恶人冒充银行柜员向顾客搭话。
恶人：您的受理编号为 9466ir8fgmmk1gn6raeo7ne71。
顾客：知道了。
顾客走向柜台。
顾客：我的受理编号为 9466ir8fgmmk1gn6raeo7ne71。
柜员：请提供您的银行卡号和密码。
顾客：受理编号为 9466ir8fgmmk1gn6raeo7ne71。卡号为 12345，密码为 9876，请确认。
柜员：身份核实完毕。您新的受理编号为 eut1j15a058pm8gapa87l937h6。
顾客执行完本人身份确认后恶人也走向了柜台。
恶人：受理编号为 9466ir8fgmmk1gn6raeo7ne71。请向卡号 99999 的账户转账 3 万元。
柜员：您还没有进行身份核实。请提供您的银行卡号和密码。
由于顾客通过认证时受理编号（会话 ID）发生了变化，所以攻击者试图使用原来的受理编号进行转账时就遭到了“您还没有进行身份核实”的提示。通过这个方法，可有效防止会话固定攻击。
要点
  认证后改变会话 ID。
下面让我们继续看一下需求 3 的防止会话 ID 泄漏。
会话 ID 泄漏的原因
会话 ID 一旦遭到泄漏就有可能发生伪装事件，所以必须采取防范措施。会话 ID 泄漏主要有以下几种原因。
发行 Cookie 时的属性指定有问题（稍后讲述）
会话 ID 在网络上被监听（参考 7.3 节）
通过跨站脚本漏洞等应用中的安全隐患被泄漏（参考第 4 章）
由于 PHP 或浏览器等平台存在安全隐患而被泄漏
会话 ID 保存在 URL 中的情况下，会通过 Referer 消息头泄漏（参考 4.6.3 节）
网络传输线路上若存在监听装置，会话 ID 就有被窃取的风险。虽然从外部无法得知具体哪里会有监听装置，但在公共无线网等理论上易于监听的环境中，会话 ID 被盗的风险是非常高的。
为了保护会话 ID 不被监听，采用 SSL（Secure Socket Layer）加密是行之有效的方法，但发行 Cookie 时也需要注意属性的指定。
Cookie 的属性
生成 Cookie 时可以设置很多属性。先前看到的 PHPSESSID 在生成时指定了“path=/”，这就是一个属性。
生成 Cookie 时的主要属性如表 3-3 所示。
表 3-3 Cookie 的属性
属性
含义
Domain
Cookie 发送对象服务器的域名
Path
Cookie 发送对象 URL 的路径
Expires
Cookie 的有效期限。未指定则表示至浏览器关闭为止
Secure
仅在 SSL 加密的情况下发送 Cookie
HttpOnly
指定了此属性的 Cookie 不能被 JavaScript 访问