456
CL-USER>
(c d))
"a string" ; this is a comment
(123)
的配置文件，然后使用PRINT来保存对数据的修改，那么你将失去那些注释。
(A B)(C D))
L-USER>
(when in
(when in
(close in)))
(close in)))
第14章文件和文件I/O
(read *s*)
(read *s*)
www.TopSage.com
?
---
## Page 162
WRITE-LINE写一个字符串并紧跟--个换行，其将被输出成用于当前平台的适当行结束字符或字
例子如下所示：
数据。而传递NIL将导致OPEN在文件已存在时返回NIL而不是流。一个典型的使用OPEN来输出的
并保证新数据被写到文件结尾处，而：overwrite返回一个从文件开始处开始的流从而覆盖已有
传递值：supersede可以告诉opEN来替换已有文件。传递：append将导致oPEN打开已有的文件
该文件不该存在并会在文件存在时报错。但你可以使用：if-exists关键字参数来改变该行为。
14.4
复调用READ-BYTE或READ-CHAR来填充一个序列更加高效。
带有该流元素类型的元素。由于多数操作系统支持某种形式的块I/O，READ-SEQUENCE通常比重
和：end关键字参数来指定一个应当被代替填充的子序列。该序列参数的元素类型必须足以保存
没有被填充的元素的索引，或是在完全填充的情况下返回该序列的长度。你也可以传递：start
（通常是一个向量）和一个流，然后它会尝试用来自流的数据填充该序列。它返回序列中第一个
14.3
数据。?
到结尾时返回何值。第24章将构建一个库，它允许使用READ-BYTE来便利地读取结构化的二进制
样，READ-BYTE也支持可选的参数以便指定当其被调用在文件结尾时是否应该报错，以及在遇
14.2
③一般情况下，一个流要么是字符流要么是二进制流，因此你不能混和调用READ-BYTE、READ-CHAR或者其他基
②类型（unsigned-byte 8)代表8位字节。Common Lisp的“字节”类型并不是固定大小的，由于Lisp曾经运行在
①默认情况下，OPEN使用当前操作系统的默认字符编码，但它也接受一个关键字参数：external-format，它可
Common Lisp也提供了几个用于写数据的函数：WRITE-CHAR会向流中写入一个单一字符;
为了向一个文件中写数据，你需要一个输出流，你可以通过在调用OPEN时使用一个值
最后一个读取函数READ-SEQUENCE可同时工作在字符和二进制流上。你传递给它一个序列
默认情况下，OPEN返回字符流，它根据特定的字符编码方案将底层字节转化成字符。“为了
比特的变长字节域。
以传递由实现定义的值来指定一个不同的编码。字符流也会转换平台相关的行结束序列到单一字符#\Newline上。
(apasiadns: sistxa-it: andano: uotaoarip: uaxr'aweu/atti/auos/  uado) 
于字符的函数。不过某些实现，例如Allegro，支持所谓的二义流（bivalent stream），其同时支持字符和二进制I/O。
不同时期的体系结构上，其字节长度为6～9位。更不用说还有PDP-10计算机，其带有可独立寻址的长度为1～36
文件输出
批量读取
读取二进制数据
www.TopSage.com
14.4文件输出
145
---
## Page 163
样来组织文件使用代码：
了。“确保每一个OPEN都有一个匹配的CLOSE可能是非常显而易见的。例如，完全可以像下面这
文件句柄往往是稀缺资源，如果打开一些文件却不关闭它们，你很快会发现不能再打开更多文件
14.5
出一个序列元素更为高效。
于该流的适当类型即可，无论其是字符还是字节。和READ-SEQUENCE一样，该函数会比每次输
中写入单独的字节。
同的:element-type实参，其值为＇（unsigned-byte 8），然后就可以使用wRITE-BYTE向流
生格式化输出的微型语言。
本输出。我将在第18章里讨论一些关于FORMAT的更重要的细节，它从本质上定义了一种用于产
字符串时不带有引号。你可以使用极其灵活但有时略显神秘的FORMAT函数来生成更加复杂的文
错而不打印该对象。
函数将以一种导致READ在试图读取时肯定会报错的特殊语法来打印该对象；否则它们将直接报
PPRINT来打印这样一种对象时，变量*PRINT-READABLY*将会予以控制。当它是NIL时，这些
美化打印器（pretty printer），它会试图将输出打印得赏心悦目。
则它将不会产生一个额外换行。
使用FRESH-LINE，那么它的输出将总是从一个新行开始。但如果它刚好在前一个函数之后调用，
函数被依次调用，而你又不希望在两个输出操作之间产生一个空行，如果你在第二个函数开始处
在其生成输出时总是带有一个换行，而另一个函数应当每次从一个新行开始输出。但假设这两个
调用的不同函数所生成的文本输出中的额外换行时，FRESH-LINE很有用。例如，假设一个函数
行字符；FRBSH-LINE打印一个换行字符，除非该流已经在一行的开始处。在想要避免由按顺序
可以只打印一个换行：TERPRI是“终止打印”（terminate print）的简称，即无条件地打印一个换
符序列。另一个函数WRITE-STRING写一个字符串而不会添加任何行结束符。有两个不同的函数
批量输出函数WRITE-SEQUENCE可同时接受二进制和字符流，只要序列中的所有元素都是用
另一个函数PRINC也会打印Lisp对象，但其工作方式很适合人们使用。例如，PRINC在打印
146
① 有些人可能认为这在诸如Lisp的垃圾收集型语言里不是个问题。在多数Lisp实现中，当一个流变成垃圾之后都将
任何编写过处理大量文件代码的人都知道，当处理完文件之后，关闭它们是多么重要。因为
为了向一个文件中写入二进制数据，你需要在使用OPEN打开文件时带有与读取该文件时相
一些函数会将Lisp数据输出成S-表达式：PRINT打印一个S-表达式，前缀一个换行及一个空
件句柄这样的稀缺资源。如果有大量的可用内存，就可以轻易地在垃圾收集器运行之前用光所有的文件句柄。
会自动关闭。不过这种行为不能被依赖一
关闭文件
1.
·第14章
文件和文件 IO
www.TopSage.com
---
## Page 164
行来回转换的责任则被放在了Lisp实现身上。
的文件名语法上。而在以本地语法写成的字符串，即名字字符串（namestring)，和路径名之间进
对象。路径名以一种结构化的方式来表示文件名，这种方式使得它们易于管理而无须捆绑在特定
隔目录）用程序来构造文件名，那么你就会将代码捆绑到特定的文件系统上。
作系统和文件系统上。而且如果按照一个特定的文件命名方案的规则（比如说，使用“”来分
14.6文件名
述符并可能最终无法打开更多文件。
生的流时。在那种情况下必须注意一点，最终要由你自己来关闭这个流，否则你将会泄漏文件描
和CLOSE调用的唯一情况是，当需要在一个函数中打开一个文件并在函数返回之后仍然保持所产
流在WITH-OPEN-FILE返回之前被关闭。因此，从一个文件中读取一行的代码应如下所示。
一-个以open-argument为实参的OPEN调用而打开。WITH-OPEN-FILE会确保stream-var中的
WITH-OPEN-FILE来封装这一模式。下面是它的基本形式：
然后再关闭流的模式是如此普遍，CommonLisp就提供了一个构建在UNWIND-PROTECT之上的宏
作符UNWIND-PROTECT，第20章将予以讨论。不过因为这种打开文件，对产生的流做一些事情，
那么控制流可能就会跳出LET语句块而转到一个错误处理器中，然后不再回来关闭那个流。
离开LET语句块。或者如同第19章里将要介绍的，如果任何CLOSE之前的代码产生了一个错误，
例如，如果CLOSE之前的代码含有一个RETURN或RETURN-FROM，那就会在没有关闭流的情况下
在每次运行时泄漏一个文件句柄。而更重要的一点是，该代码并不保证你能够到达CLOSE那里。
为了避免这种不可移植性，CommonLisp提供了另一种文件名的表示方式：路径名（pathname)
到目前为止，文件名都是用字符串表示的。但使用字符串作为文件名会将代码捆绑在特定操
CommonLisp对于如何确保一直运行特定代码这一问题提供了一-个通用的解决方案：特殊操
不幸的是，如同许多被设计用于隐藏本质上不同的底层系统细节的抽象那样，路径名抽象也
在你所使用的90%～99%的文件I/O中都可能会用到WITH-OPEN-FILE一
其中body-form中的形式将在stream-var被绑定到一个文件流的情况下进行求值，该流由
但这一方法还是有两方面的问题。一是容易出现错误一—如果忘记使用cLOSE，那么代码将
(andano: uotasartp: "axa'aweu/alts/awos/ wearas) atts-uado-uatm)
为了创建一个新文件，你可以这样写。
(with-open-file (stream-var open-argument*)
(let ((stream (open
body-form*)
(close stream))
 do stuff with stream
"/some/file/name.txt")))
www.TopSage.com
14.6文件名
一需要使用原始OPEN
147
---
## Page 165
例如，前面章节里所有的用字符串来表示文件名的位置都同样可以传入路径名对象或流。
符（pathnamedesignator）。所有内置的以文件名作为参数的函数都能接受所有这三种路径名描述符。
也代表文件名，也就是那个当初用来打开该流的文件名。这三种类型的文件名被总称为路径名描述
节。但通过编程方法产生的文件名是路径名，因为你能可移植地创建它们。一个由OPEN返回的流
通常是名字字符串，因为用户只知道它们所运行在的文件系统，而不关心Lisp如何表示文件名的细
在很大程度上取决于该名字的来源。由用户提供的文件名（例如作为参数或是配置文件中的值）
展史中的遗留产物而忽略时，你就会发现它们确实提供了一种管理文件名的便捷方式。
些细微之处就没有什么意义了。不过，一旦你理解了路径名抽象中的哪些部分可以作为路径名发
加丰富多彩。这带来的结果是，在你只关心如何表示Unix或Windows文件名时，路径名抽象的某
引入了它们自己的复杂性。当路径名最初被设计时，通常使用的文件系统集合比今天所使用的更
就已经准备好了。
以处理将来可能存在的文件系统。比如说，如果版本文件系统重新流行起来的话，CommonLisp
使用这种用来处理过去存在的广泛的文件系统的路径名抽象带来的另一种好处是，它有可能可
你抽象掉的一些区别了。例如，Windows文件名含有一个驱动器字母，而Unix文件名却没有。
如果考察两种像Windows和Unix这样相似的文件系统，你可能已经开始注意路径名系统可能帮
std.com）新闻组上描述了如下情形。
Lisp标准的主要技术编辑之一，有一次在comp.lang.lisp（Message-ID: sfwzo74np6w.fsf@world.
在多数使用文件名的调用场合里，你都可以同时使用名字字符串或是路径名。具体使用哪个
148
①路径名系统从某种意义上被认为结构复杂的另一个原因是其对逻辑路径名（logicalpathname）的支持。不过，你
理路径名。它们在特定场合下有其自己的用途，但是你可以足够远离且无须担心它们。
可以完美地使用路径名系统的其余部分而无需了解任何关于逻辑路径名更多的东西，从而安全地忽略它们。简洁
如果从任何单一文件系统的观点上观察路径名抽象，那么它看起来显得过于复杂。不过，
本的文件系统以及没有设备的文件系统，等等。
相对路径名中使用：up，另一些不这样做。一些带有可命名的根目录，而另一些没有。还存在
些对于特殊的文件字符带有引用字符，另一些不会。一些带有通配符，而另一些没有。一些在
统了。它们中的一些只支持大写字母，一些是大小写混合的，另一些则是大小写敏感但却能自
TOPS-20、VAXVMS、AT&TUnix、MITMultics、MITITS，更不用说还有许多大型机操作系
存在于20世纪七八十年代的文件系统的历史多样性很容易被遗忘。KentPitman，Common
pathnametranslation）来将匹配特定通配符的文件路径名转化成代表文件系统中文件的路径名，也就是所谓的物
个实际的文件系统中被映射到特定的位置上，前提是当程序被安装时，通过定义“逻辑路径名转换”（logical
地说，逻辑路径名允许CommonLisp程序含有对路径名的引用而无须命名特定的文件。逻辑路径名随后可以在一
没有目录的文件系统，使用非层次目录结构的文件系统，不支持文件类型的文件系统，没有版
动作大小写转换（就像CommonLisp）。它们中的一些将目录视为文件，而另一些则不会。一
在CommonLisp的设计完成时期，处于支配地位的文件系统是：TOPS-10、TENEX
第14章
文件和文件I/O
www.TopSage.com
进化历程
弘网
---
## Page 166
三个路径名组件，尽管它们在Unix上不太可能带有感兴趣的值。在Windows上，PATHNAME-HOST
径名中的单独组件。
类型组件中。
有的话，最后一个元素将在最右边的点处被分拆开，然后得到的两部分将被放进路径名的名称和
果有的话，忽略驱动器字母）以一个路径分隔符开始。这个列表将成为路径名的目录组件。如果
一个之外都被放置在一个以:absolute或:relative开始的列表中,具体取决于该名字是否（如
在Windows上，驱动器字母要么被放置在设备中，要么就是在主机组件中。其他名字元素除最后
件（通常是设备或主机）保存了驱动器字母。在这些平台上，一个名字字符串在解析时首先会被
特定映射，但是多数实现遵守了与其所在操作系统相同的约定。
文件名语法来解析。作为一个平台中立的文档，语言标准没有指定任何从名字字符串到路径名的
流时，最初的文件名就会被抽取出然后返回。不过当描述符是一个名字字符串时，它将根据本地
并返回等价的路径名对象。当该描述符已经是一个路径名时，它就会被简单地返回。当它是一个
象，
心哪个组件在特定文件系统上是否可被用来表示文件名，除非你需要手工地从头创建一个新路径
的一—这也是路径名让许多初级Lisp程序员感到无端复杂的原因之一。另一方面，你真的不必担
带有关键字:absolute或:relative作为前缀。但并非所有路径名组件在所有平台上都是必需
通常是字符串。只有目录组件有其进一步的结构，含有一个目录名（作为字符串）的列表，其中
(directory）、名称（name）、类型（type）以及版本（version）。这些组件的多数都接受原子值，
14.7
你可以使用函数PATHNAME-DIRECTORY、PATHNAME-NAME和PATHNAME-TYPE来检查一个路
① 许多基于Unix的实现特别地对待那些最后一个元素以点开始并且不含有任何其他点的文件名，将整个元素包括点
在Unix文件系统上，只有目录、名称和类型组件通常会被用到。在Windows上，还有一个组
例如，为了将名字字符串转化成路径名，你可以使用PATHNAME函数。它接受路径名描述符
，或是通过从一个已有路径名中取得其多数组件来创建新路径名，从而得到路径名对象。
路径名是一种使用6个组件来表示文件名的结构化对象：主机（host）、设备（device）、目录
(pathname-type (pathname "/foo/bar/baz.txt"))
(pathname-name (pathname "/foo/bar/baz.txt"))
(pathname-directory (pathname "/foo/bar/baz.txt")) → (:ABsOLUTE "foo" "bar")
路径名。
尽管如此，并非所有实现都遵守这一约定。一些实现创建一个以空字符串作为名称同时将"emacs"作为类型的
pathname-type
"soewa " t (("ssewa /oos/a aweuuaed) aweu-aweuuned)
在内放置在名称组件中，并且保留类型组件为NIL。
路径名如何表示文件名
{pathname
www.TopSage.com
→→NIL
14.7