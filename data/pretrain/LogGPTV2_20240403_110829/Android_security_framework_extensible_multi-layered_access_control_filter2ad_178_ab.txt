4. REQUIREMENTS ANALYSIS
The current development of Android security extensions
has strong parallels to the initial development of the above
mentioned Linux and BSD security extensions, since current
Android security extensions are provided as patches to the
software stack or, in the case of SE Android [36], are em-
bedded into the Android source tree. For the same, above
mentioned reasons as for the early Linux and BSD security
extensions, this impedes the applicability and adaption of
Android security extensions and additionally precludes many
of the beneﬁts that a modular composition could oﬀer in
terms of maintenance: Embedding SE Android’s security
model into Android’s source tree limits policy authors to the
expressiveness and boundaries of type enforcement, whereas
provisioning security models and architectures as patches
to Android’s software stack forces policy authors to chose a
solution-speciﬁc Android fork. This requires for every version
update to the Android OS a re-evaluation and port of each
separate fork. Moreover, security solutions cannot be easily
compared with each other, because their infrastructures are
deeply embedded into the Android software stack.
In this paper, we develop in the spirit of the two de facto
most established security frameworks, Linux Security Mod-
ules (LSM) [40] and the BSD MAC Framework [39], a generic
and extensible Android Security Framework that allows
the instantiation and deployment of diﬀerent security models
as modules at Android’s application layer, middleware, and
kernel. The two most important guiding principles from
LSM and the BSD MAC framework that govern the design
of our Android Security Framework are: 1) provision-
ing of policies as code instead of data; and 2) providing a
policy-agnostic OS security infrastructure. In the remainder
of this section, we analyze the requirements and challenges
for their transfer to the Android software stack.
Policy as code and not data. The ﬁrst guiding prin-
ciple is that policies should be supported as code instead
of data (such as rules written in one predetermined policy
language). Providing an extensible security framework that
supports integration of policy logic as code avoids committing
to one particular security model or architecture. For Android,
this removes the need to chose a particular extension-speciﬁc
Android fork or to be limited to one speciﬁc security model
in the mainline Android software stack. Additionally, de-
veloping modules against an OS security API provides the
beneﬁts of modularization for developing and maintaining
security extensions. This includes, foremost, a higher func-
tional cohesion of security modules and lower coupling with
the Android software stack and, hence, can signiﬁcantly re-
duce the maintenance overhead of modules, especially in case
of OS changes. Moreover, it allows a better dissemination,
comparison, and analysis of self-contained security modules.
Transferring this principle to an extensible security frame-
work for Android poses the additional requirement to consider
the semantics and dominant programming languages of the
incorporates the design principles explained in Section 4.
This API allows to easily author, integrate, and enforce
generic security policies. Figure 2 provides an overview of
our ASF and we explain its building blocks in the following.
5.1.1 Reference Monitors
In our design we diﬀerentiate between policy enforcing
and policy decision making code. For enforcement we use
reference monitors [22] at all layers of the Android software
stack, i.e., at the application layer, the middleware layer, and
the kernel layer. Each reference monitor protects one speciﬁc
privileged resource and is placed such, that it mediates all
access to the resource through the Android API. The beneﬁt
of this multi-tiered enforcement is that each reference monitor
can operate with the semantics of its respective layer.
Figure 2: Android Security Framework architecture.
diﬀerent layers of Android’s software stack. LSM and the
BSD MAC Framework, for instance, as part of the kernel,
support modules written in C and operate on kernel data
structures (e.g., ﬁlesystem inodes). While this applies to the
Android Linux kernel as well, an Android security framework
should additionally support modules written for Android’s
semantically-rich middleware and application layers. That
means modules written in Java and operating on application
framework classes (e.g., Intents or app components).
Policy-agnostic security infrastructure. The second
principle is that the security framework and its API should
be policy-agnostic. This means that policy-speciﬁc intrusions
into the software stack are avoided and policy-speciﬁc data
structures and logic are conﬁned to security modules.
A particular additional requirement for a security frame-
work on Android are enforcement hooks in the middleware
and application layer that support edit automata [23] poli-
cies, as promoted by diﬀerent solutions [42, 7, 21, 3]. Edit
automata, in contrast to truncation automata, can not only
abort control ﬂows but also divert or manipulate them and,
thus, give policy authors a higher degree of freedom in im-
plementing their enforcement strategies. For instance, when
querying a ContentProvider component, the policy could sim-
ply deny access by throwing a Java Exception (truncation),
but also modify the return value to return ﬁltered, empty, or
fake data (edit). To technically enable security modules to
implement edit automata, our design requires a re-thinking
of the “classical” object manager vs. policy server design that
is used, e.g., in LSM. Object managers (i.e., enforcement
points) are responsible for assigning security labels to the ob-
jects that they manage and for both requesting and enforcing
access control decisions from the policy server (i.e., policy
decision point). Because this design embeds the enforcement
logic into the system independently from the security model,
it is unﬁt for realizing edit automata. Thus, our design re-
quires hooks that generically support diﬀerent enforcement
strategies and shift the enforcement and object labelling logic
from the object managers to the security modules.
5. ANDROID SECURITY FRAMEWORK
In the following we present ASF. We provide further details
in an anonymous long version of this paper [2].
5.1 Framework Overview
The basic idea behind our Android Security Frame-
work is to extend Android with a new security API that
Security Modules
5.1.2
Security extensions are deployed in the form of code mod-
ules and loaded during boot into the security frameworks at
the middleware and kernel level. Modules should be signed
to ensure their integrity and trustworthiness, and the veriﬁ-
cation key is embedded in the kernel (or a secure location like
a secure execution environment). Each module implements
a policy engine that manages its own security policies and
acts as policy decision making point. Security modules are
integrated into the security frameworks through a security
API that exposes objects and operations of the diﬀerent
software stack layers.
To provide a clear separation between policy decision logic
using kernel level semantics and logic using middleware/ap-
plication layer semantics, each module consists of two sub-
modules: a Kernel Sub-Module leveraging the already
existing Linux Security Module (LSM) infrastructure of the
Linux kernel and a Middleware Sub-Module, for which
we designed and implemented a novel security infrastructure
at the application and middleware layers.
5.1.3 Front-end Apps
To enable user conﬁgurable policies or graphical event
notiﬁcations, modules might want to include user interfaces.
To this end, the module developers (or external parties being
aware of the modules) can deploy standard Android apps that
act as front-end and that communicate through the frame-
work API with the module. We enable such proprietary
module interfaces through a Bundle based communication
protocol. A Bundle is a key-value store that supports het-
erogenous value types (e.g., Integer and String) and that can
be transmitted via Binder IPC. It is the responsibility of the
module to verify that the caller is suﬃciently privileged.
5.2 Framework Infrastructure
We present now in a bottom-up approach details about the
ASF infrastructure that has been prototypcially implemented
for Android v4.3 and currently comprises 4606 lines of code.
5.2.1 Kernel Space
At kernel level we employ the existing Linux Security
Module (LSM) [40] framework of the Linux kernel. LSM
implements an infrastructure for mandatory access control
and provides a number of enforcement hooks within kernel
components such as the process management or the virtual
ﬁlesystem. The Kernel Sub-Module is implemented as
a standard Linux Security Module that registers through
AppSystem Service/AppUser-spaceVirtual FilesystemApiDiscretionary Access ControlLSM HookPrivate/Public ResourcePrivileged ResourceAPIPermisson checkPrivileged FunctionalityKernel spacesyscallsyscallDex (DVM)Native CodeBinder IPCMiddleware FrameworkMiddlewareAPIMiddlewareSub-ModuleMiddleware HookcheckAccessInlined RMKernel APIKernelSub-ModulecheckAccessProprietary self-contained channel(e.g., sysfs, socket, ...)LSM FrameworkModule Front-end App(s)callModule(Bundle args)Security FrameworkReference MonitorStock Android SecuritySecurity ModuleListing 1: Exemplary enforcement functions
1 public boolean deliverToRegisteredReceiver (Intent intent,
ComponentName targetComp, String requiredPermission,
int targetUid, int targetPid, String callerPackage,
ApplicationInfo callerApp, int callingUid, int callingPid);
2 public Location getLastLocation (Location currentLocation,
LocationRequest request, int callingUid, int calingPid);
the LSM API for the LSM hooks in the system and that
operates with kernel level semantics. Kernel Sub-Module
can be an existing Linux security module like SELinux or
proprietary ones [20]. Kernel-level policies form truncation
automata that terminate illegal control ﬂows.
Since there might be operational inter-dependencies be-
tween the Kernel Sub-Module and user-space processes
like the Middleware Sub-Module (e.g., propagation of
access control decisions), the kernel module can implement
proprietary channels for communication between kernel- and
user-space (e.g., sysfs entries).
5.2.2 Middleware Layer
At the middleware layer we extended the system services
and apps that implement the Android API with hooks that
enforce access control decisions made by the Middleware
Sub-Module. The middleware security framework is exe-
cuted as a new Android system service and mediates between
our hooks and the Middleware Sub-Module. The hooks
are policy-agnostic and not tailored to one speciﬁc security
model. Each hook takes as arguments all relevant, ambient
information of the current control ﬂow that led to the hook’s
invocation. For instance, Listing 1 presents two exemplary
hooks in our system: one for the Intent broadcasting sub-
system of the ActivityManagerService (line 1) and one for
the LocationManagerService that implements the location
API of Android (line 2). Both provide to the Middleware
Sub-Module information about the current caller to the
Android API, i.e., App in Figure 2 (parameters callingUid
and callingPid). However, all other parameters are speciﬁc
to the hooks’ contexts, e.g., the hook in line 1 provides infor-
mation about the Intent being broadcast and the app compo-
nent that should receive this Intent (parameters targetComp
through targetPid). Thus, the hooks support policies that
use the rich middleware-speciﬁc semantics.
In general, all hooks support truncation automata as poli-
cies by either allowing the module to throw exceptions that
terminate the control ﬂow and that are returned to the caller
of the Android API, or by explicitly requiring a boolean
return value that indicates whether the hook truncates the
control ﬂow or not (line 1 in Listing 1). A subset of the hooks
additionally supports edit automata policies, that is the mod-
ule can modify or replace return values of the Android API
function or modify/replace arguments that divert or aﬀect
the further control ﬂow after the hook. For instance, the
LocationManagerService hook in Listing 1 (line 2) allows the
module to edit or replace the Location object that is returned
to the app that requested the current device location.
5.2.3 Application Layer
At the application layer, our Android Security Frame-
work provides a mechanism to inject access control hooks
into apps themselves. This access control technique is based
on the concept of inlined reference monitors (IRM) pioneered
by Erlingsson and Schneider [14]. The basic idea is to rewrite
an untrusted app such that the reference monitor is directly
embedded into the app itself, yielding a “self-monitoring”
app. Although using IRMs might seem counter-intuitive
or redundant in our design, IRMs are the only way in An-
droid’s current app model to achieve privilege separation
between the components within an app (e.g., ad libs [19])
or to enforce edit automata policies on ﬁle-system and net-
work interfaces (e.g., HTTPS-everywhere). The former are
DVM internal operations and the latter do not involve the
middleware, but instead the app processes interact directly
with the ﬁle-system and network API of the kernel, whose
semantics are rather unsuitable for enforcing edit automata
policies. Thus, until this app model has been retroﬁtted to
enable a system-centric solution for such kind of policies,
our design relies on IRM. ASF provides an instrumentation
API that enables security modules to dynamically hook any
Java function within an app’s DVM. Hooked functions divert
the control ﬂow of the program to the reference monitor,
which thereby not only gains access to all function arguments
but can also modify or replace the function’s return value.
Furthermore, in contrast to the hooks placed in the Android
middleware, application layer hooks are dynamic: Hooks
are injected by directly modifying the target app’s DVM
memory when a new app process is started. This design
enables security modules to dynamically create and remove
hooks at runtime as well as to inject app-speciﬁc hooks.
5.3 Middleware Framework API
We elaborate now in more detail on our framework API
and the interaction between modules and the security infras-
tructure. Since we use the existing LSM framework as is,
we focus here on our newly introduced middleware security
framework and refer to the kernel documentation [25] for
details on the LSM API. The middleware framework API of
our current implementation contains 168 callback functions;
a full listing is provided in the long version of this paper [2].
This API can be broken down into the following categories:
Enforcement functions. These functions form the bulk
of the API (136 methods) and are called by the framework
whenever the enforcement hooks in system apps and ser-
vices are triggered. Each hook has a corresponding callback
function in the module API, which has the same method
signature as the hook (cf. Listing 1) and which implements
the policy decision logic for its hook.
Kernel Sub-Module Interface. To avoid policy-speciﬁc
interfaces for the communication between middleware/appli-
cation layer apps and the Kernel Sub-Module, we intro-
duce a generic kernel module API as part of the middleware
framework API. It allows apps and services a controlled ac-
cess to Linux security modules. Each security module can
implement this interface and internally translate the API calls
to calls on the proprietary channel between the user-space
and the Linux security module. Two particular challenges
for establishing this interface were the self-contained secu-
rity checks of the kernel module and the requirement that
this interface is already available during system boot. To
guarantee security, the kernel module is required to perform
policy checks to verify that a user-space process is suﬃciently
privileged to issue commands to it. Additionally, the kernel
module is called before the middleware framework can load
any Middleware Sub-Module, e.g., it can be called by
Zygote when spawning new app processes. To solve these
challenges, our design avoids an additional layer of indirec-
tion (i.e., IPC) for communication with the kernel module
and loads the interface implementations via the Java reﬂec-
tion API statically into the application framework when it is