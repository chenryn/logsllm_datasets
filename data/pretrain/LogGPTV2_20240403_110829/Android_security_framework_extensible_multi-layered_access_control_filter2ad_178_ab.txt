### 4. Requirements Analysis

The current development of Android security extensions closely mirrors the early stages of Linux and BSD security extensions. These extensions are typically provided as patches to the software stack or, in the case of SE Android [36], embedded directly into the Android source tree. This approach, similar to the initial Linux and BSD security extensions, hinders the applicability and adoption of Android security extensions. It also precludes many of the benefits that a modular composition could offer in terms of maintenance.

Embedding SE Androidâ€™s security model into the Android source tree restricts policy authors to the expressiveness and boundaries of type enforcement. Conversely, providing security models and architectures as patches to the Android software stack forces policy authors to choose a solution-specific Android fork. This requires re-evaluating and porting each separate fork with every version update to the Android OS. Furthermore, security solutions cannot be easily compared because their infrastructures are deeply embedded into the Android software stack.

In this paper, we develop an extensible and generic Android Security Framework (ASF) inspired by the two most established security frameworks: Linux Security Modules (LSM) [40] and the BSD MAC Framework [39]. The ASF allows the instantiation and deployment of different security models as modules at the application layer, middleware, and kernel. The two key guiding principles from LSM and the BSD MAC framework that inform our design are: 1) provisioning policies as code rather than data, and 2) providing a policy-agnostic OS security infrastructure. In the remainder of this section, we analyze the requirements and challenges for transferring these principles to the Android software stack.

#### 4.1. Policy as Code and Not Data

The first guiding principle is that policies should be supported as code rather than data (such as rules written in a predetermined policy language). An extensible security framework that supports the integration of policy logic as code avoids committing to a specific security model or architecture. For Android, this removes the need to choose a particular extension-specific Android fork or to be limited to one specific security model in the mainline Android software stack. Additionally, developing modules against an OS security API provides the benefits of modularization for developing and maintaining security extensions. This includes higher functional cohesion of security modules, lower coupling with the Android software stack, and significantly reduced maintenance overhead, especially in the case of OS changes. Moreover, it allows for better dissemination, comparison, and analysis of self-contained security modules.

Transferring this principle to an extensible security framework for Android requires considering the semantics and dominant programming languages of the different layers of the Android software stack. LSM and the BSD MAC Framework, for instance, support modules written in C and operate on kernel data structures (e.g., filesystem inodes). While this applies to the Android Linux kernel, an Android security framework should also support modules written for the semantically-rich middleware and application layers, such as those written in Java and operating on application framework classes (e.g., Intents or app components).

#### 4.2. Policy-Agnostic Security Infrastructure

The second principle is that the security framework and its API should be policy-agnostic. This means avoiding policy-specific intrusions into the software stack and confining policy-specific data structures and logic to security modules.

A particular additional requirement for a security framework on Android is the inclusion of enforcement hooks in the middleware and application layers that support edit automata [23] policies, as promoted by various solutions [42, 7, 21, 3]. Edit automata, unlike truncation automata, can not only abort control flows but also divert or manipulate them, providing policy authors with greater flexibility in implementing their enforcement strategies. For example, when querying a ContentProvider component, the policy could simply deny access by throwing a Java Exception (truncation) or modify the return value to return filtered, empty, or fake data (edit). To technically enable security modules to implement edit automata, our design requires a rethinking of the "classical" object manager vs. policy server design used in LSM. Object managers (i.e., enforcement points) are responsible for assigning security labels to the objects they manage and for both requesting and enforcing access control decisions from the policy server (i.e., policy decision point). This design, which embeds the enforcement logic into the system independently of the security model, is unsuitable for realizing edit automata. Thus, our design requires hooks that generically support different enforcement strategies and shift the enforcement and object labeling logic from the object managers to the security modules.

### 5. Android Security Framework

In the following sections, we present the details of the Android Security Framework (ASF). Further details are provided in an anonymous long version of this paper [2].

#### 5.1. Framework Overview

The basic idea behind the Android Security Framework is to extend Android with a new security API that incorporates the design principles explained in Section 4. This API allows for the easy authoring, integration, and enforcement of generic security policies. Figure 2 provides an overview of our ASF, and we explain its building blocks in the following sections.

##### 5.1.1. Reference Monitors

In our design, we differentiate between policy-enforcing and policy-decision-making code. For enforcement, we use reference monitors [22] at all layers of the Android software stack: the application layer, the middleware layer, and the kernel layer. Each reference monitor protects a specific privileged resource and is placed such that it mediates all access to the resource through the Android API. The benefit of this multi-tiered enforcement is that each reference monitor can operate with the semantics of its respective layer.

##### 5.1.2. Security Modules

Security extensions are deployed as code modules and loaded during boot into the security frameworks at the middleware and kernel levels. Modules should be signed to ensure their integrity and trustworthiness, and the verification key is embedded in the kernel (or a secure location like a secure execution environment). Each module implements a policy engine that manages its own security policies and acts as a policy decision point. Security modules are integrated into the security frameworks through a security API that exposes objects and operations of the different software stack layers.

To provide a clear separation between policy decision logic using kernel-level semantics and logic using middleware/application-layer semantics, each module consists of two sub-modules: a Kernel Sub-Module leveraging the existing Linux Security Module (LSM) infrastructure of the Linux kernel and a Middleware Sub-Module, for which we designed and implemented a novel security infrastructure at the application and middleware layers.

##### 5.1.3. Front-end Apps

To enable user-configurable policies or graphical event notifications, modules may include user interfaces. To this end, module developers (or external parties aware of the modules) can deploy standard Android apps that act as front-ends and communicate with the module through the framework API. We enable such proprietary module interfaces through a Bundle-based communication protocol. A Bundle is a key-value store that supports heterogeneous value types (e.g., Integer and String) and can be transmitted via Binder IPC. It is the responsibility of the module to verify that the caller is sufficiently privileged.

#### 5.2. Framework Infrastructure

We now present details about the ASF infrastructure, which has been prototypically implemented for Android v4.3 and currently comprises 4,606 lines of code.

##### 5.2.1. Kernel Space

At the kernel level, we employ the existing Linux Security Module (LSM) [40] framework of the Linux kernel. LSM implements an infrastructure for mandatory access control and provides a number of enforcement hooks within kernel components such as process management and the virtual filesystem. The Kernel Sub-Module is implemented as a standard Linux Security Module that registers through the LSM API for the LSM hooks in the system and operates with kernel-level semantics. The Kernel Sub-Module can be an existing Linux security module like SELinux or proprietary ones [20]. Kernel-level policies form truncation automata that terminate illegal control flows.

Since there may be operational inter-dependencies between the Kernel Sub-Module and user-space processes like the Middleware Sub-Module (e.g., propagation of access control decisions), the kernel module can implement proprietary channels for communication between kernel- and user-space (e.g., sysfs entries).

##### 5.2.2. Middleware Layer

At the middleware layer, we extended the system services and apps that implement the Android API with hooks that enforce access control decisions made by the Middleware Sub-Module. The middleware security framework is executed as a new Android system service and mediates between our hooks and the Middleware Sub-Module. The hooks are policy-agnostic and not tailored to a specific security model. Each hook takes as arguments all relevant, ambient information of the current control flow that led to the hook's invocation. For example, Listing 1 presents two exemplary hooks in our system: one for the Intent broadcasting subsystem of the ActivityManagerService (line 1) and one for the LocationManagerService that implements the location API of Android (line 2). Both provide the Middleware Sub-Module with information about the current caller to the Android API, i.e., the app (parameters `callingUid` and `callingPid`). However, all other parameters are specific to the hooks' contexts, e.g., the hook in line 1 provides information about the Intent being broadcast and the app component that should receive this Intent (parameters `targetComp` through `targetPid`). Thus, the hooks support policies that use the rich middleware-specific semantics.

In general, all hooks support truncation automata as policies by either allowing the module to throw exceptions that terminate the control flow and are returned to the caller of the Android API, or by explicitly requiring a boolean return value that indicates whether the hook truncates the control flow or not (line 1 in Listing 1). A subset of the hooks additionally supports edit automata policies, meaning the module can modify or replace return values of the Android API function or modify/replace arguments that divert or affect the further control flow after the hook. For example, the LocationManagerService hook in Listing 1 (line 2) allows the module to edit or replace the `Location` object that is returned to the app that requested the current device location.

##### 5.2.3. Application Layer

At the application layer, our Android Security Framework provides a mechanism to inject access control hooks into apps themselves. This access control technique is based on the concept of inlined reference monitors (IRM) pioneered by Erlingsson and Schneider [14]. The basic idea is to rewrite an untrusted app such that the reference monitor is directly embedded into the app itself, yielding a "self-monitoring" app. Although using IRMs might seem counter-intuitive or redundant in our design, IRMs are the only way in Android's current app model to achieve privilege separation between the components within an app (e.g., ad libs [19]) or to enforce edit automata policies on file-system and network interfaces (e.g., HTTPS-everywhere). The former are DVM internal operations, and the latter do not involve the middleware; instead, the app processes interact directly with the file-system and network API of the kernel, whose semantics are rather unsuitable for enforcing edit automata policies. Thus, until this app model has been retrofitted to enable a system-centric solution for such policies, our design relies on IRM. ASF provides an instrumentation API that enables security modules to dynamically hook any Java function within an app's DVM. Hooked functions divert the control flow of the program to the reference monitor, which thereby not only gains access to all function arguments but can also modify or replace the function's return value.

Furthermore, in contrast to the hooks placed in the Android middleware, application layer hooks are dynamic: Hooks are injected by directly modifying the target app's DVM memory when a new app process is started. This design enables security modules to dynamically create and remove hooks at runtime as well as to inject app-specific hooks.

#### 5.3. Middleware Framework API

We now elaborate in more detail on our framework API and the interaction between modules and the security infrastructure. Since we use the existing LSM framework as is, we focus here on our newly introduced middleware security framework and refer to the kernel documentation [25] for details on the LSM API. The middleware framework API of our current implementation contains 168 callback functions; a full listing is provided in the long version of this paper [2]. This API can be broken down into the following categories:

- **Enforcement Functions:** These functions form the bulk of the API (136 methods) and are called by the framework whenever the enforcement hooks in system apps and services are triggered. Each hook has a corresponding callback function in the module API, which has the same method signature as the hook (cf. Listing 1) and which implements the policy decision logic for its hook.
- **Kernel Sub-Module Interface:** To avoid policy-specific interfaces for the communication between middleware/application-layer apps and the Kernel Sub-Module, we introduce a generic kernel module API as part of the middleware framework API. It allows apps and services controlled access to Linux security modules. Each security module can implement this interface and internally translate the API calls to calls on the proprietary channel between the user-space and the Linux security module. Two particular challenges for establishing this interface were the self-contained security checks of the kernel module and the requirement that this interface is available during system boot. To guarantee security, the kernel module must perform policy checks to verify that a user-space process is sufficiently privileged to issue commands to it. Additionally, the kernel module is called before the middleware framework can load any Middleware Sub-Module, e.g., it can be called by Zygote when spawning new app processes. To solve these challenges, our design avoids an additional layer of indirection (i.e., IPC) for communication with the kernel module and loads the interface implementations via the Java reflection API statically into the application framework when it is initialized.