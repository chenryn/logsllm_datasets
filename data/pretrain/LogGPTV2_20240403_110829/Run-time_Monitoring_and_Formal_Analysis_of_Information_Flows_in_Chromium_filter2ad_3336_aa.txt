title:Run-time Monitoring and Formal Analysis of Information Flows in Chromium
author:Lujo Bauer and
Shaoying Cai and
Limin Jia and
Timothy Passaro and
Michael Stroucken and
Yuan Tian
Run-time Monitoring and Formal Analysis
of Information Flows in Chromium
Lujo Bauer
Limin Jia
Timothy Passaro Michael Stroucken Yuan Tian
Shaoying Cai(cid:63)
{lbauer,liminjia,tpassaro,mxs,yt}@cmu.edu
Carnegie Mellon University
(cid:63)Institute for Infocomm Research
(cid:63)PI:EMAIL
Abstract—Web browsers are a key enabler of a wide range
of online services, from shopping and email to banking and
health services. Because these services frequently involve handling
sensitive data, a wide range of web browser security policies and
mechanisms has been implemented or proposed to mitigate the
dangers posed by malicious code and sites.
This paper describes an approach for specifying and en-
forcing ﬂexible information-ﬂow policies on the Chromium web
browser. Complementing efforts that focus on information-ﬂow
enforcement on JavaScript, our approach focuses on an existing
browser and encompasses a broad range of browser features,
from pages and scripts to DOM elements, events, persistent state,
and extensions. In our approach, which is a coarse-grained,
light-weight implementation of taint tracking, entities in the
browser are annotated with information-ﬂow labels that specify
policy and track information ﬂows. We develop a detailed formal
model of our approach, for which we prove noninterference. We
also develop a corresponding prototype system built on top of
Chromium. We demonstrate, and experimentally conﬁrm, that
the system can enforce many existing browser policies, as well as
practically useful policies beyond those enforceable in standard
web browsers.
I.
INTRODUCTION
Web browsers are used to access a wide range of services—
from shopping and email to banking, health services, and
document editing. While bringing about increased convenience
and productivity,
the continuing rise in popularity of web
services also causes users to incur signiﬁcant risks. Using these
services causes users’ conﬁdential data—such as passwords,
bank account numbers, and emails—to be exposed to the web
browser, to scripts running in pages loaded in the browser,
and to browser extensions and plugins. Scripts and extensions
are particularly difﬁcult to trust: even simple web pages com-
monly load multiple page scripts of often dubious provenance;
similarly, tens of thousands of extensions are available to be
installed on browsers like Firefox and Chrome, and popular
extensions are downloaded by tens of millions of users.
To reduce the dangers posed by scripts and extensions,
today’s browsers use numerous security mechanisms, from the
same origin policy (SOP), content security policies (CSPs),
Permission to freely reproduce all or part of this paper for noncommercial
purposes is granted provided that copies bear this notice and the full citation
on the ﬁrst page. Reproduction for commercial purposes is strictly prohibited
without the prior written consent of the Internet Society, the ﬁrst-named author
(for reproduction of an entire paper only), and the author’s employer if the
paper was prepared within the scope of employment.
NDSS ’15, 8-11 February 2015, San Diego, CA, USA
Copyright 2015 Internet Society, ISBN 1-891562-38-X
http://dx.doi.org/10.14722/ndss.2015.23295
and permissions to process isolation and isolated worlds.
Despite all these mechanisms, however, risks to users’ data
remain. Dangerous new attacks and vulnerabilities are regu-
larly demonstrated. For example, page scripts and extensions
can track user browsing behavior [14], [24], capture user input
in web forms [36], steal cookies and conﬁdential web page
content [3], [12], and even hijack user sessions and make web
service requests on behalf of the user [9].
A promising recent development
is the emergence of
information-ﬂow control as an approach for preventing many
such script misbehaviors [19], [27], [42], [48], [49]. Some
such approaches are more heavy-weight; they enforce ﬁne-
grained policies, but require implementing a new JavaScript
interpreter [19], [27]. In contrast, BFlow and COWL compart-
mentalize scripts and assign policies at the granularity of com-
partments that encapsulate content from a single origin [42],
[49]. They enforce coarse-grained policies on communication
across compartments and build on existing JavaScript engines.
Complementing existing research on information ﬂow in
web browsers, in this paper we pursue a light-weight, dynamic,
taint-tracking-based approach to constrain information ﬂows
within a browser and to prevent secrets from leaving the
browser. We provide a formal accounting of information ﬂows
among the many entities, both static and dynamic, which
inhabit browsers. These include dynamic entities such as page
scripts and extension scripts; ephemeral ones like browser
tabs, loaded web pages, and events (e.g., a button click); and
persistent entities like cookies, history, and bookmarks. We
explore whether an information-ﬂow enforcement system can
encompass all the above entities and implement useful policies
without unduly impacting regular browsing functionality and
with reasonable run-time overhead.
More speciﬁcally, we develop an approach for speci-
fying and enforcing ﬂexible information-ﬂow policies for
Chromium. Compared to other successes in applying formal
information-ﬂow reasoning to web browsers, we believe our
approach is novel in the combination of richness of policy
speciﬁcation it allows and breadth of the space it encompasses.
In our approach, all entities in a browser are described
using information-ﬂow labels. For web pages, extensions, and
some APIs, these labels express the policy of the author or
user, or built-in browser policies, e.g., a superset of a web
page’s CSP or variants of the SOP. For other entities in the
browser, including ephemeral ones like button-click events and
persistent ones like cookies and browser history, labels are
created automatically and serve to track information ﬂows and
prevent those that violate speciﬁed policies.
Our information-ﬂow labels are based on entity origin:
domains in URLs, extension IDs, and the browser’s user.
Labels can express declassiﬁcation and endorsement policies,
permitting controlled ﬂow of information to untrusted compo-
nents when this is required to achieve speciﬁc functionality
(e.g., a password stored by a password manager is allowed to
be sent to a web site if the user clicks the page’s login button).
Our approach is sufﬁciently expressive to encompass poli-
cies that are currently explicitly speciﬁed in the browser,
such as speciﬁc CSP, domain relaxation, and cross-origin
resource-sharing policies; and policies expressed via exten-
sion permissions. Our approach also explicitly exposes policy
composition, e.g., between the CSP of a web page, the CSP of
content loaded in iframes, and policies speciﬁed by developers
of extensions whose content scripts are active in the page.
This enables our approach to represent both the ad-hoc ways
in which browsers currently handle policy composition (e.g.,
conﬂicts between policies of web pages and extension content
scripts) and more principled and ﬁne-grained ways of resolving
policy conﬂicts.
We precisely deﬁne our approach by means of a formal
model, which we show obeys trace-based noninterference. We
concretely demonstrate through a prototype implementation on
Chromium that our system can be used to enforce practically
useful policies, including those that prevent malicious exten-
sions from stealing user input or other extensions’ secrets and
colluding via explicit shared state. We also discuss inherent
tradeoffs between security and functionality via case studies
that expose the need for a semi-trusted script or extension to
have dangerous declassiﬁcation privileges in order to imple-
ment seemingly innocuous functionality.
In summary, this paper makes the following contributions:
• An approach for specifying and enforcing information-
ﬂow polices that encompasses the full range of compo-
nents (entities) within the browser.
• A formalization of our approach in a model of an
extended version of Chromium, for which we have
proved a noninterference theorem.
• A functional prototype implementation on Chromium
reasonable performance overhead
• Examples of enforcement of practically relevant policies
enabled by our approach, and insights about tradeoffs
implicitly made in everyday web browsing.
that demonstrates
while supporting ﬁne-grained policies.
We do not contend that
the design described in this
paper is a complete, ready-to-use replacement for existing
browser security mechanisms. Instead, we believe that it is
an interesting point in the design space of possible solutions;
as such, it is important to explore, and doing so helps provide
a concrete basis for further discussion toward more satisfy-
ing practical solutions. Further, the browser entities that we
model—shared state (e.g., cookies, history, bookmarks, DOM)
and blocking and nonblocking event handlers—are common
to many browser infrastructures and our model can potentially
be reused in projects that require formal models of browser
internals.
background and closely related work. Section III gives an
overview of our approach, including describing how labels
are speciﬁed and used to enforce policies. We describe the
formal model and analysis in Section IV and the prototype
implementation in Section V. Section VI discusses how our
approach can be used to implement existing browser security
mechanisms.
A. Motivating Example
We use a password manager extension as a motivating
scenario to demonstrate the features of our approach. The
password manager, extpwdMgr, collects usernames and pass-
words entered into login forms and saves them for future use.
On subsequent visits to previously visited pages, the password
manager automatically ﬁlls in usernames and passwords.
Suppose that a page for which extpwdMgr has saved the
user’s password is cnn.com. Several other extensions, including
exteve—a malicious extension masquerading as a web page
translation extension—are installed in the browser and have
access to cnn.com. cnn.com loads advertising content, which
includes page scripts, from ad sites like ad.com.
Given currently deployed browser security mechanisms,
exteve and scripts from ad.com may be able to interfere with
the password manager in a number of ways, including:
• Once extpwdMgr ﬁlls in a login form with previously
saved passwords, these can be read by exteve and ad.com
scripts and communicated to other sites.
• exteve can collect saved passwords even for sites that the
user does not herself visit by opening new tabs that load
arbitrary web pages; if extpwdMgr has saved passwords
for those web pages, it may automatically ﬁll them in.
• exteve and page scripts can automatically cause the user
to log in to sites for which extpwdMgr stores a password
by fabricating form-submit events.
As we describe in Section III, our approach makes it
possible to deﬁne and enforce policies that prevent
these
attacks, as well similar attacks carried out by more constrained
page scripts or extensions that collude to achieve similar
malicious functionality.
II. RELATED WORK
Improving the security and reliability of browsers has
received much attention from both academia and industry [8],
[10], [18], [25], [43], [45]. Most popular browsers, such as
Chrome and Firefox, enforce forms of component isolation
and privilege separation. Even with such architectures, new
ways to exploit users by launching attacks within the browser
or to compromise the browser are frequently reported [21],
[31], [47]. Allowing browsers to be further extended by third-
party extensions has brought a new set of security concerns [7],
[12], [34], [35], [46]. Our information-ﬂow policy enforcement
mechanism enhances existing browser infrastructure, and can
be used to enforce ﬂexible information-ﬂow policies, which
can mitigate some of the above-mentioned attacks.
The rest of this paper proceeds as follows. We start with
a motivating example, in Section I-A. Section II describes
Ad-hoc browser security features (e.g., Content Security
Policy (CSP) [44], origin header [9], X-Frame-Options [30])
2
have been adopted to prevent common attacks such as cross-
site scripting (XSS) [26], cross-site request forgery (CSRF),
and clickjacking [29]. Many of these security features con-
strain information ﬂows. Our approach can enforce richer and
more precise policies and can be used to approximate the
information-ﬂow policies enforced by those security features.
Enforcing information-ﬂow policies has been an active
area of research. Some develop novel information-ﬂow type
systems that enforce noninterference properties statically
(cf. [41]); others use run-time monitoring, or hybrid tech-
niques (e.g., [4], [6], [16], [28], [37], [40]). Much work has
investigated preventing information leakage via JavaScript in
browsers (e.g., [6], [13], [17], [19], [27], [28]). These works
typically protect data at the variable level, which is much lower
level than our system’s entity-level granularity. This means that
we do not need to track every instruction in the JavaScript
engine, and instead only enforce policies when API calls are
made and when event handlers and callbacks are invoked. This
is not only more efﬁcient, but also ﬁts nicely into the browser’s
model of classifying information based on origin. Scripts from
the same origin in our system have the same information-
ﬂow labels. Further, our work also encompasses other browser
components, such as DOM elements and extensions.
In terms of policy speciﬁcation and enforcement granu-
larity, our system is similar to BFlow [49] and COWL [42].
There, each compartment, which includes scripts and DOM
from the same origin, is associated with an information-ﬂow
label specifying its policies. Aside from the differences in
the choice of policy language, we additionally examine policy
composition, explore different ways to implement shared states
(i.e., DOM, cookies, history, and bookmarks), and build a
formal model of our design and analyze its security guarantees.
Bohannon et al. formally modeled the core of Firefox [15].
Their model contains all key components of a browser, in-
cluding the DOM, cookies, and bookmarks. In particular, they
model the browser as a reactive system, where entities in the
browser are modeled as consumers and producers that commu-
nicate by sending and receiving messages through channels. In
contrast, our model of the browser uses different abstractions,
supports policy speciﬁcation, and is compatible with a real
browser. Recent work by Fett et al. also models a browser as
a transition system [22]. Some of their transition rules overlap
with ours. Our model additionally includes our information-
ﬂow tracking mechanism and encompasses browser extensions.
The differences in the models are driven by different analysis
goals: Fett et al. aim to analyze browser single sign-on systems,
while we aim to prove noninterference.
III. SYSTEM OVERVIEW
In this section we ﬁrst deﬁne the threat model that our
approach addresses (Section III-A). We then describe how
policies are speciﬁed (Section III-B), outline the enforcement