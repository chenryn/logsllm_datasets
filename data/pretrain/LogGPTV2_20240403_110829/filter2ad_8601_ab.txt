# **0x04 - 攻击：堆栈缓冲区溢出**
在深入了解堆栈缓冲区溢出及其工作原理的技术细节之前，让我们先看一下快速，易于理解的类比：  
过去爱丽丝和鲍勃经常约会，但爱丽丝最终与鲍勃分手了。随着时间的推移，爱丽丝继续生活，但鲍勃无法从极度的悲伤中走出来。现在，爱丽丝准备嫁给罗伯特哈克曼，他是鲍勃的情敌。鲍勃变成了一个令人毛骨悚然的怪人，他通过秘密访问爱丽丝的电子邮件帐户，监视爱丽丝的所有婚礼计划。鲍勃看到爱丽丝聘请了一位著名的婚礼蛋糕设计师，设计师希望爱丽丝根据自己的口味偏好修改部分食谱。设计师给爱丽丝一个推荐的成分列表，但他说他可以做任何她想吃的。Bob打开了设计师电子邮件附带的文件，发现食谱的自定义行看起来像：  
...然后，我们将通过添加______为糖霜添加味道。在那之后，我们将添加一些巧克力....  
Bob注意到如果你在行中输入“Banana”，文本将如下所示：  
...然后，我们将通过添加香蕉来增加糖霜的味道。在那之后，我们将添加一些巧克力......  
但是，如果Bob将“草莓”输入该行，则文本将如下所示：  
...然后，我们将通过添加草莓来增加糖霜的味道，我们将添加一些巧克力......  
鲍勃意识到这将是破坏爱丽丝婚礼的完美方式，他所要做的就是用他恶心的版本覆盖其余的食谱！在爱丽丝的婚礼当天，设计师揭开他制作的蛋糕发现它是用冷冻蛋黄酱制成并且被虫子覆盖着的！  
堆栈缓冲区溢出（就像Bob的攻击一样）会覆盖开发人员不打算覆盖的数据，从而可以完全控制程序及其输出。  
那么，现在让我们在现实世界中看到它。看一下来自exploit-exercises.com的以下代码：  
在上面的函数中，我们看到创建了一个名为buffer的字符类型数组，其大小为64.然后，我们看到modified变量设置为0和以buffer变量作为参数调用的gets函数。最后，我们看到一个IF语句，检查modified是不是0.显然，在这段代码中没有地方把modified这个变量设置为0以外的任何数，那么我们如何更改呢？  
好吧，我们先来看看获取功能文档：  
如您所见，gets函数只接受用户输入。但是，该函数不检查用户输入是否实际适合我们存储的数据结构（在本例中为缓冲区），因此，我们能够溢出数据结构并影响堆栈上的其他变量/数据。此外，由于我们知道所有变量都存储在堆栈中，并且我们知道modified变量的值是多少（0），我们所要做的就是输入足够的数据来覆盖modified变量。我们来看一个图：  
如您所见，如果恶意用户输入太多文本，他们可以覆盖modified变量和堆栈上的任何其他内容，包括返回指针。这意味着如果恶意代理能够控制程序堆栈，它们实际上可以控制整个程序并使其执行任何他们想要的操作。他们可以简单地将堆栈上函数返回指针覆盖掉并且指向携带某个恶意payload的自定义指针。
# **0x05.攻击：return-to-libc(ret2libc)攻击**
在我们讨论return-to-libc（ret2libc）攻击之前，让我们花点时间更深入地讨论libc。  
(从第0x01节)我们知道，libc是标准的C库。这意味着它包含C编程语言中包含的所有通用系统函数。现在，如果恶意用户能够控制程序执行其中一些功能，该怎么办？  
嗯，这就是ret2libc。对于ret2libc的后果的一个完美类比可能是[黑客帝国系列](https://www.imdb.com/title/tt0133093/
"黑客帝国系列")。回想一下经典的“Guns, lots of guns”场景。操作员TANK，能够完全绕过并重新编译黑客帝国，使得大量枪支出现整个空间。  
你可以想到像这样返回libc，我们能够控制黑客帝国（标准C库）并使它做任何我们想做的事情。  
在它的基础上，ret2libc攻击实际上是基于堆栈缓冲区溢出。回想一下我在第0x04节末尾所说的内容，如果恶意代理可以覆盖堆栈上的数据，它们可以简单地覆盖返回指针以指向libc中的特定函数，并通过它传递任何payload必要的参数。  
用于ret2libc攻击的最常见功能之一是系统函数。我们来看看它的文档：  
如您所见，system命令只执行shell命令（shell是linux命令行）。此外，如果我们读上面的描述，我们可以看到system只执行/bin/sh
-c (/bin/sh是实际的shell命令)，并且命令通过参数传递给函数。  
因此，我们所要做的就是获取易受攻击的程序机器的命令行访问权限，首先将“/bin/sh”作为参数推送到堆栈，然后将函数返回或调用指针替换为系统函数的内存地址，以便/bin/sh作为函数参数被调用，最后启动shell并授予我们对系统的完全访问权限。
# **0x06 - 第1部分结论**
在本文中，我们讨论了：  
1.虚拟内存以及应用程序如何在内存处理  
2.动态链接库和libc  
3.堆栈  
4.如何调用函数以及函数返回的工作机制  
5.堆栈缓冲区溢出  
6.返回libc（ret2libc）攻击  
我希望这篇文章很有帮助。