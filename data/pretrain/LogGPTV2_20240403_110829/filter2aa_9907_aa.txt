.\" Copyright (c) 1995,1997 Paul Gortmaker and Andries Brouwer
.\" 中文版 Copyright (c) 2000 Bill Pan, Laser 和 www.linuxforum.net
.\"
.\"
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, write to the Free
.\" Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111,
.\" USA.
.\"
.\" This man page written 950814 by aeb, based on Paul Gortmaker's HOWTO
.\" (dated v1.0.1, 15/08/95).
.\" Major update, aeb, 970114.
.TH BOOTPARAM 7 "14 January 1995" "Linux 2.1.21" "Linux Programmer's Manual"
.SH NAME
bootparam \- 介绍Linux核心的启动参数
.SH 描叙
Linux 核心在启动的时候可以接受指定的"命令行参数"或"启动参数"．
在通常情况下，由于核心有可能无法识别某些硬件，
或可能将某些硬件识别为不正确的配置，因此，
这些参数可以被用来提供正确的硬件配置参数。
当Linux核心被BIOS直接启动的时候
（比如说你的核心是从使用了 "cp zImage /dev/fd0" 命令制造的 Linux 启动软盘来启动的），
你无法指定任何的启动参数。
因此，为了能够指定启动参数，你必须使用某些能够传递启动参数的软件，
例如 LILO 或 Loadlin。
为了使用很少的参数来改变的核心配置，
可以使用 rdev，查看
.BR rdev（8）
可以得到更多的细节。
由 Werner Almesberger 开发的 LILO 程序 (LInux LOader) 是最普遍的启动配置软件。
它能够启动各种不同的系统核心，
这些启动配置信息被放置在一个简单明了的文本文件中
（请看
.BR lilo（8）
和
.BR lilo.conf(5).）
LILO 可以启动象 DOS，OS/2，Linux，FreeBSD，UnixWare 这样的操作系统，
而且灵活性也非常强。
另外一个较为普遍的启动软件是"LoadLin"。这是一个基于 DOS 操作系统的软件。
该软件能够从DOS提示符下启动Linux核心（使用启动参数），
只要某些必需的资源可用就行。
这对于那些希望从 DOS 系统中启动 Linux 的人来说是很不错的方法。
如果你的硬件能够被 DOS 驱动程序启用的话，LoadLin也会是非常有用的。
一个最常见的例子是设置与 SoundBlaster 兼容的声卡。
这些声卡通过使用 DOS 驱动程序设定一些寄存器就可以将它们设置成为 SB 兼容模式的声卡。
在DOS下启动这些声卡的启动程序，然后使用LoadLin程序启动Linux，
这样就可以避免由于重新启动Linux系统而造成声卡被重新设置。
.SH "参数列表"
核心参数行被解析成为一个由空格分隔的字符串列表（即启动参数表）。
大部分的启动参数的格式就象下面这样
.IP
名字[=值1]，[值2]……[，值10]
.LP
其中"名字"是一个唯一关键字，被用来区分接受值（如果有的话）那一部分核心。
要注意的是 10 个值的限制是确实存在的，
目前的程序代码只能对每个关键字处理 10 个逗号分隔的参数
（当然，在一些复杂的应用中，
你可以通过重新使用同样的关键字来传递多于10个的参数，
只要配置程序可以支持该方法）
大部分的排序工作是在 linux/init/main.c 中进行的。
首先，核心检查参数是否为 "root="、"nfsroot="、"nfsaddrs="、"ro"、"rw"、"debug"
和"init"这些特殊参数中的一种。这些参数的意义我们将在下面说明。
然后，核心会搜索"配置程序队列"（bootsetups队列）
来查看指定的参数字符串（比如"foo"）是不是与某个配置指定设备
或是核心的配置程序建立了关联。
例如假设你传递给核心 foo=3,4,5,6，
那么核心会搜索 bootsetups 队列看看"foo"是否已经注册。
如果是，那么核心将运行与"foo"关联的配置程序（比如foo_setup()）
并且将参数3，4，5，6交给核心命令列。
任何象 "foo=bar" 这样格式的参数不会被上面所说的那样，
作为一个配置程序的关联被接受，而是被解释成为一个环境变量的设置。
一个（无用的？）例子就是使用 "TERM=vt100" 作为核心的启动参数。
任何既不被核心接受又不被解释为环境变量的参数会被传送给第一个系统进程，
通常这会是init程序。最常用的传递给 init 进程的参数是 "single"，
它告诉init使用单用户模式启动计算机，并且不要执行任何的守护进程。
查阅帮助，看看你所装版本的 init 程序可以支持的参数。
.SH "一般的、与设备无关的启动参数"
.SS "`init=...'"
这个启动参数提供核心执行时的初始化命令。如果它没有被设置，
或者没有被找到的话，核心会去尝试调用
.IR /etc/init ,
然后是
.IR /bin/init ,
然后是
.IR /sbin/init ,
最后是
.IR /bin/sh
，如果都失败了，就会提示一个异常信息。
.SS "`nfsaddrs=...'"
该启动参数设置 nfs（网络文件系统）启动地址为指定的字符串值。
该启动地址被用于网络启动中。
.SS "`nfsroot=...'"
该动参数设置 nfs（网络文件系统）根目录名为指定字符串。
如果该字符串不是以'/'、','或者一个数字开始的，则该字符串加上"/tftpboot/"的前缀。
.SS  "`no387'"
(只有当CONFIG_BUGi386被定义后才有效)
某些 i387 协处理器在使用 32 位保护模式时会出现错误。
例如，一些早期的ULSI-387芯片在处理浮点运算时会出现死锁的情况。
使用"no387"启动参数可以让Linux忽略你的算术协处理器的存在。
当然，这时你就必须将你的核心编译成为支持数学仿真模式。
.SS "`no-hlt'"
(只有当CONFIG_BUGi386被定义后才有效)
某些早期的 i486DX-100 的处理器芯片在使用 "halt" 时会出现问题，
使用这个指令后它不会正常的返回到操作模式。
使用 "no-halt" 指令告诉 Linux 在没有事情可做的时候，
只是执行一个无限的循环指令，而不是让CPU进入"halt"模式。
这样就可以令人们使用这些有缺陷的芯片来运行 Linux。
.SS "`root=...'"
这个参数告诉核心在启动的时候使用哪个设备被作为根文件系统。
其缺省值是你在编译核心的时候就所确定的根设备。
如果你想要修改该值，比如说，将第二个软盘驱动器作为根设备，
你可以使用 "root=/dev/fd1" （根设备也可以用
.BR	rdev(8)）；
来设置。
根设备能够以符号形式或数字形式来指定。一种符号指定形式是 /dev/XXYN，
其中 XX 代表设备类型（ "hd" 代表普通 IDE 硬盘，紧跟其后的 Y 的范围是 "a" 到 "d"；
"SD" 代表 SCSI 硬盘，紧跟其后的 Y 的范围是 "a" 到 "e"；"ad" 代表 Atari ACSI磁盘，
紧跟其后的 Y 的范围是 "a" 到 "e"；"ez" 代表 Syquest EZ135 兼容的使用并口的可移动硬盘，
紧跟其后的 Y 的值只能是"a"；"xd" 代表 XT 兼容的磁盘，紧跟其后的 Y 的值是 "a"
或者是 "b"；"fd" 代表软驱，而 Y 代表软驱的序号 - fd0 代表 DOS 的 "A："，
fd1代表DOS的 "B："），Y 表示驱动器字母或序号。N 代表驱动器的分区号
（以十进制数值表示，当然，软驱是没有该信息的）。
目前的核心可以使用更多的驱动设备，
比如 nfs，ram，scd，mcd，cdu535，aztcd，cm206cd，gscd，sbpcd，sonycd，bpcd，
其中大部分都是 CD-ROM 设备。
（nfs 指示网络启动的位置；ram 表示一个 ram 虚拟磁盘（ram 表示可读写储存器）。
需要注意的是以上这些指定对你文件系统上的设备名称并没有做任何实质改变，
"/dev/" 部分的描述只是出于传统习惯。
你也可以通过使用数字形式的主/次设备号指定根设备，
但这是很笨拙和不方便的方法。
（例如，/dev/sda3 的主设备号是 8，次设备号是 3，
所以你也可以使用 "root=0x0803" 来指定根设备。）
.SS "`ro'和`rw'"
"ro" 选项告诉核心使用"只读"方式装配文件系统。
这样可以让"文件一致性检查"程序
（fsck程序，用来检查磁盘的工具，类似 DOS 的 scandisk 程序）
能够在一种所谓"静止"
（也就是说没有任何对文件系统的写操作）的文件系统中执行。
需要进行写操作的进程必须等到该文件系统使用
"读/写"方式重新装配以后才能进行，
例如，使用了"mount -w -n -o remount /"命令。
（请查看
.BR mount(8)。)
"rw" 选项告诉核心使用"可读写"方式装配文件系统。这是缺省值。
只读方式和可读写方式的选择可以使用
.BR rdev (8).
来设定。
.SS "`reserve=...'"
该参数用来设定保留区域，使得该区域的 I/O 端口不会被检测。该命令的格式是
.IP
.BI reserve= iobase,extent[,iobase,extent]...
.LP
在某些情况下你的机器也许必须避免设备驱动程序检测
（自动检测）某些指定区域的设备。
这些情况有可能是因为由于检测会导致硬件错误，或者硬件会被错误地识别，
又或者你只是不想核心对该硬件进行初始化。
reserve(保留)启动参数指定一个不要检测的 I/O 端口保留区。
设备驱动程序不会检测保留区域的 I/O 端口，
除非其他的启动参数明确的指定需要去检测。
例如，命令行
.IP
reserve=0x300,32  blah=0x300
.LP
表示设置保留 I/O 区域 0x300 到 0x31f（共32个端口）
不会被 `blah' 程序以外的驱动程序所检测。
.SS "`mem=...'"
PC 规范定义的返回内存数的 BIOS 调用最大可以返回 64MB 内存。
Linux 使用这个 BIOS 调用检测机器安装了多少内存。
如果你拥有超过 64MB 的内存，就可以使用这个参数告诉 Linux 你的内存数。
该值可以是 10 进制的或者是 16 进制的（加上 0x 的前缀），
后缀也可以加上 "k" （乘以 1024）或 "M" （乘以 1048576）。
下面是 Linux 初始人 Linus 对 "mem=" 参数使用的声明：
\&"核心能够接受任何你给予的 'mem=xx' 参数，
但是如果你欺骗它的话，它迟早会让你死的很难看。
参数用来指定最高位的 RAM 地址，所以 'mem=0x1000000' 表示你拥\&有 16MB 的内存。
而对于96MB内存的机器来说你应该设置为 'mem=0x6000000'。
注意注意注意：有些机器可能会将内存高端设置为 BIOS 所使用，
所以你可能将不能全部拥有 96MB 地址空间。
反之，有些芯片可以将包括 BIOS 的物理内存影射到内存高端去，
所以，你可以用的实际空间可能会是 96MB+384kB。
但是如果你告诉 Linux 核心你拥有的内存超出你的实际内存的话，将会发生很糟糕的事情。
也许躲得过初一，躲不过十五。"
.SS "`panic=N'"
在缺省情况下，核心并不会在异常后重新启动系统，
但是这个参数可以指定内核在发生异常后 N 秒后重新启动（如果 N>0）。
这个异常时限也可以使用 "echo N>/proc/sys/kernel/panic" 来设定。
.SS "`reboot=[warm|cold][,[bios|hard]]'"
（只有当 CONFIG_BUGi386 被定义的时候该参数才起作用）
从 2.0.22 版本后的核心开始，reboot 命令在缺省情况下使用冷启动。
你可以使用 "reboot=warm" 来进行老版本所的缺省的热启动方式。
（冷启动意味着对所有的硬件设备进行重新设置，
但是也有可能令在磁盘缓冲区中尚未写到磁盘上的数据被破坏。
热启动的优点是速度比较快。）
在缺省情况下，
要求键盘控制器向机器发出可以重新启动的低电位脉冲是很困难的，
但是至少有一种类型的主板不会这样工作。
选项 "reboot=bios" 将用 BIOS 的设置代替跳线。
.SS "`nosmp'" 和 "`maxcpus=N'"
（该参数只有当 __SMP__ 参数被定义的时候才有效）
命令行选项 "nosmp" 或 "maxcpus=0" 将会禁止激活 SMP（对称多处理）功能，
选项 "maxcpus=N" 限制在 SMP 方式下工作的 CPU 最大数目为 N．
.SH "核心开发者所使用的启动参数"
.SS "`debug'"
核心信息被传递给核心的日志守护进程 klogd 使得它们能够被记录在磁盘中。优先级高于
.I console_loglevel
的信息也可以在控制台上被显示出来。
（如果想了解信息优先级，可以去查看文件。）
在缺省情况下，所有比调试信息级别高的信息都会被写入日志文件。
但是这个启动参数的设置，可以使得核心将 DEBUG（调试信息）级别的信息写到日志里。
console loglevel 也能够在系统运行时通过使用 klogd 来设置。
请看