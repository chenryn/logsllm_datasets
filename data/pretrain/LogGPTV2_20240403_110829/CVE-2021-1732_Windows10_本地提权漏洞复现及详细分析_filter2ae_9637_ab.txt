    }
运行起来，你便得到了一个标题是 Hello World 的窗口：
在窗口中右键会弹出一个对话框：
我来解释一下这个程序是怎么工作的。首先，桌面应用对于程序员而言的入口点从常见的 main 变成了 **WinMain** （这里的 wWinMain 是
unicode 版 WinMain，表明程序中使用的字符为 unicode 编码）。其次，需要有个概念，那就是我们平常看到的应用程序窗口，都是某个
**窗口类** 的“实例”（注意，这里的类不是 C++ 类的概念），Windows 使用一个结构体来管理 行为/风格 相似一类窗口，其定义[6]如下：
    typedef struct tagWNDCLASSEXW {
        UINT        cbSize;        // 该结构体的大小，通过这个字段来区分桌面开发的新旧版本
        /* Win 3.x */
        UINT        style;         // 窗口类的风格
        WNDPROC     lpfnWndProc;   // 窗口的消息处理函数
        int         cbClsExtra;    // 窗口类的扩展内存大小
        int         cbWndExtra;    // 窗口的扩展内存大小
        HINSTANCE   hInstance;     // 该窗口类的窗口消息处理函数所属的应用实例
        HICON       hIcon;         // 该窗口类所用的图标
        HCURSOR     hCursor;       // 该窗口类所用的光标
        HBRUSH      hbrBackground; // 该窗口类所用的背景刷
        LPCWSTR     lpszMenuName;  // 该窗口类所用的菜单资源
        LPCWSTR     lpszClassName; // 该窗口类的名称
        /* Win 4.0 */
        HICON       hIconSm;       // 该窗口类所用的小像标
    } WNDCLASSEXW;
从窗口类的定义可以看出，它包含了一个窗口的重要信息，如窗口风格、窗口过程、显示和绘制窗口所需要的信息，等等。可以使用 VS 自带的工具 Microsoft
spy++ 来实际感知窗口类的存在，比如计算器对应的窗口类是 Windows.UI.Core.CoreWindow：
所以想要创建一个窗口 “实例”，需要先向系统注册一个窗口类，这就是为什么开始的代码要这样写：
    WNDCLASSEX wndclass = { 0 }; // 创建窗口类结构体
    /* 对窗口类的各属性进行初始化 */
    wndclass.cbSize = sizeof(WNDCLASSEX);     // 字段 cbSize 需要等于结构体 WNDCLASSEX 的大小
    wndclass.style = CS_HREDRAW | CS_VREDRAW; // 窗口类风格 - 窗口水平/竖直方向的长度变化时重绘整个窗口
    wndclass.lpfnWndProc = MyWndProc;         // 窗口消息处理函数 - 这里使用上面声明的 MyWndProc
    wndclass.hInstance = hInstance;           // 该窗口类的窗口消息处理函数所属的应用实例 - 这里就使用 hInstance
    wndclass.lpszClassName = L"TestWndClass"; // 窗口类名称
    /* 注册窗口类 */
    RegisterClassEx(&wndclass);
现在我们就能用这个窗口类来创建看得见、摸得着的窗口了。创建窗口使用 CreateWindowEx[7]
函数，通过下面的代码，我们就能成功创建一个可见的窗口并得到它的窗口句柄：
    /* 创建窗口 */
    hwnd = CreateWindowEx(
        NULL,                              // 扩展窗口风格
        L"TestWndClass",                   // 窗口类名
        L"Hello World",                    // 窗口标题
        WS_OVERLAPPEDWINDOW | WS_VISIBLE,  // 窗口风格
        CW_USEDEFAULT,                     // 窗口左上角 x 坐标 - 这里使用默认值
        CW_USEDEFAULT,                     // 窗口左上角 y 坐标 - 这里使用默认值
        CW_USEDEFAULT,                     // 窗口宽度 - 这里使用默认值
        CW_USEDEFAULT,                     // 窗口高度 - 这里使用默认值
        NULL,                              // 父窗口句柄
        NULL,                              // 菜单句柄
        hInstance,                         // 窗口句柄
        NULL                               // 该值会传递给窗口 WM_CREATE 消息的一个参数
    );
创建了窗口后，如果后面什么代码都不写，那程序就直接退出，创建的窗口也立马被销毁了，这个不能交互的桌面应用对用户来说毫无意义。为了给创建出的窗口注入灵魂，最后往往会加一个
while 主消息循环：
    /* 消息循环 */
    while (GetMessage(&msg, hwnd, NULL, 0))
    {
        TranslateMessage(&msg);   // 翻译消息
        DispatchMessage(&msg);    // 派发消息
    }
我们常常能听到一些名词，如事件驱动、Windows 消息处理机制等，这些概念集中体现在上面这个 while
循环中。为什么在窗口中右键，会弹出一个对话框？那是因为鼠标右键按下被视作了一个事件，当这个事件在窗口中发生时，系统会去调用窗口所属窗口类的
WNDCLASSEX.lpfnWndProc 回调函数来响应，这个函数中写了弹出对话框的代码，因此才会有这样的效果。
那么问题来了，为什么我按鼠标左键它不会弹出对话框？照你这个说法，鼠标左键按下也是一个事件，系统不也会调用同一个回调
WNDCLASSEX.lpfnWndProc，那行为应该相同（即弹出对话框）才对啊？诚然，不论是左键还是右键按下，该窗口的
WNDCLASSEX.lpfnWndProc 都会被调用，而结果我们也清楚 —— 只有右键按下才会弹出对话框，这个函数是怎么做到区分左/右键按下的呢？
事实上，操作系统会把每个到来的事件包装成一个消息结构体（MSG
结构体，不是本文关注点，这里就不列出它的各个字段了），这个结构体记录了事件发生在哪个窗口（窗口句柄）、事件对应的消息编号（
**每种事件都对应了一个唯一的编号** ）、事件发生时所处的坐标等。系统将这个 MSG 结构体放入线程的消息队列，当线程调用 GetMessage
时，就能从队列中取出这个结构体，再通过 DispatchMessage 根据 MSG 结构体中的窗口句柄，向对应窗口递送该消息（具体体现就是调用那个窗口的
lpfnWndProc）。TranslateMessage 函数用于做一些虚拟键消息转换，与我们所说的内容关系不大，可以忽略掉这个函数。
现在就可以解释为什么按下左键没有弹出对话框了，来看本例代码中的窗口过程函数：
    /* 窗口类的窗口过程函数(负责消息处理) */
    LRESULT CALLBACK MyWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) 
    {
        switch (message)
        {
            case WM_RBUTTONDOWN:    // #define WM_RBUTTONDOWN 0x0204 - 代表鼠标右键按下
                MessageBox(hWnd, L"Right Button Down Detected", L"Message Arrival", MB_OK); // 简单弹个对话框
                break;
            default:
                return DefWindowProc(hWnd, message, wParam, lParam); // 对其他消息都使用默认方式处理
        }
        return 0;
    }
左键按下和右键按下是不同的事件，它们的消息编号不同，所以当回调 MyWndProc 先后被调用时，参数 message 的值就不同（分别是 WM_
**L** BUTTONDOWN 和 WM_ **R** BUTTONDOWN）。在函数实现中，通过一个 switch
语句来判断消息的类型，针对不同的消息，采取不同的相应措施。比如上面的代码，我们判断当消息是右键按下时就弹个对话框，其他的消息使用默认方式处理（这种窗口中左键按下的默认处理方式就是什么也不做）。
有了上面的基本概念后，我们来拓展聊聊 WNDCLASSEX 结构体的 cbClsExtra 和 cbWndExtra 字段，之前注释里也写了，它们分别表示
**窗口类** 的扩展内存大小和 **窗口** 的扩展内存大小，那扩展内存有什么用？二者又有什么区别呢？
先说说什么是 **窗口类**
的扩展内存。在应用程序注册一个窗口类时，可以让系统分配一定大小的内存空间，作为该窗口类的扩展内存，之后属于该窗口类的每个窗口都共享这片内存区域，每个窗口都可以通过
Windows 提供的 API 来读写这片扩展内存，如
GetClassLong、GetClassLongPtr、SetClassLong、SetClassLongPtr 等（Ptr 后缀是为了兼容 32 和
64 位），以此实现同窗口类的窗口间通信，而 cbClsExtra 字段就记录了这片内存的大小。
同理，当 **窗口** 创建时，可以让系统分配一定大小的内存空间，作为该窗口的扩展内存，这就是窗口的扩展内存。这片内存每个窗口独享，也可以通过 API
来读写（GetWindowLong、GetWindowLongPtr、SetWindowLong、SetWindowLongPtr），该机制提供了一种窗口数据暂存的方式，这片内存的大小由
cbWndExtra 字段记录。
还是通过一个实例来感受 cbWndExtra 字段的意义：
    #include 
    /* 窗口类的窗口过程函数(负责消息处理) */
    LRESULT CALLBACK MyWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
    {
        /* 通过 GetWindowLongPtr 获取偏移为 0 和 8 的两个 long long 的值 */
        LONG_PTR A = GetWindowLongPtr(hWnd, 0);
        LONG_PTR B = GetWindowLongPtr(hWnd, 8);
        wchar_t* content = new wchar_t[20];
        switch (message)
        {
        case WM_LBUTTONDOWN:  // 左键按下时，输出 A 的值
            wsprintf(content, L"%p", A);
            MessageBox(hWnd, content, L"Left Button Down", MB_OK);
            break;
        case WM_RBUTTONDOWN:  // 右键按下时，输出 B 的值
            wsprintf(content, L"%p", B);
            MessageBox(hWnd, content, L"Right Button Down", MB_OK);
            break;
        default:
            return DefWindowProc(hWnd, message, wParam, lParam);
        }
        return 0;
    }
    /* 程序入口点 */
    int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
        _In_opt_ HINSTANCE hPrevInstance,
        _In_ LPWSTR    lpCmdLine,
        _In_ int       nCmdShow)
    {
        HWND hwnd;
        MSG msg;
        WNDCLASSEX wndclass = { 0 };
        wndclass.cbSize = sizeof(WNDCLASSEX);
        wndclass.style = CS_HREDRAW | CS_VREDRAW;
        wndclass.lpfnWndProc = MyWndProc;
        wndclass.hInstance = hInstance;
        wndclass.lpszClassName = L"TestWndClass";
        /* 使用 cbWndExtra 字段，设置扩展内存大小为两个 long long */
        wndclass.cbWndExtra = 2 * sizeof(long long);
        RegisterClassEx(&wndclass);
        hwnd = CreateWindowEx(
            NULL, L"TestWndClass", L"Hello World",
            WS_OVERLAPPEDWINDOW | WS_VISIBLE,
            CW_USEDEFAULT, CW_USEDEFAULT,
            CW_USEDEFAULT, CW_USEDEFAULT,
            NULL, NULL, hInstance, NULL
        );
        /* 通过 SetWindowLongPtr 设置偏移为 0 和 8 的两个 long long 的值 */
        SetWindowLongPtr(hwnd, 0, 0xAAAAAAAAAAAAAAAA);
        SetWindowLongPtr(hwnd, 8, 0xBBBBBBBBBBBBBBBB);
        while (GetMessage(&msg, hwnd, NULL, 0))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
        return msg.wParam;
    }
运行起来，按下左键：
按下右键：
好了，关于 Windows 桌面编程就先聊到这儿吧，花了不少的篇幅来引出 cbWndExtra 字段，是因为该字段不为 0（窗口具有扩展内存）正是
CVE-2021-1732 漏洞利用的导火索。
###  3.2 tagWND 结构体
与每个窗口类对应一个结构体类似，Windows 使用 tagWND 结构体来描述每个窗口，这个结构体在加载了官方 pdb 文件的 Win7
win32k.sys 模块可以找到[8]。可能是由于泄露了太多对开发者无用的内核符号，导致 win32k 被五花八门的漏洞利用手段玩坏了，Win7