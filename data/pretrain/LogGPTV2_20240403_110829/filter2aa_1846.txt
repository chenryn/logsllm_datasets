如何在3个月发现12个内
核信息泄露漏洞
陈唐晖 李龙 百度安全实验室
2019
目录
0. 我是谁
1. 认识漏洞
2. 研究漏洞
• 堆栈数据污染
• 检测漏洞技术
• CVE实例分析
3. 成果
4. 总结和思考
我是谁？
•
百度安全实验室资深安全研发工程师
•
百度杀毒、卫士主防设计者和负责人
•
十多年的windows内核研究和开发经验
•
深谙Rootkit技术，内功深厚，剑法独到
•
偶然涉入漏洞挖掘领域
Tanghui Chen
PI:EMAIL
什么是内核信息泄露漏洞？
Windows内核存在很多信息泄露漏洞，可能导致绕过KASLR或系统关
键信息泄露，攻击者可以利用它们得到一些重要信息，比如：
•
加密密钥
•
内核对象
•
关键模块地址
•
…
漏洞是如何产生的？
如CVE-2018-8443
1. 用户态调用ZwDeviceIoControlFile (..., 0x7d008004, Output,…);
2. ZwDeviceIoControlFile经过系统调用进入内核
3. 返回用户态后，Output包含内核栈中未初始化的数据
现有的挖掘技术
•
BochsPwn
❑
CPU指令模拟
•
DigTool
❑
重量级VT技术
•
插桩
•
…
挖掘信息泄露漏洞的方法
第1步：堆/栈数据污染方法
•
Hook KiFastCallEntry，内核栈污染
•
Hook ExAllocatePoolWithTag，内核堆污染
•
对堆和栈的内存数据填充特殊标志数据，如AA等
在Hook KiFastCallEntry中，通过IoGetStackLimits获取内核栈内存，填充特殊标志数据
IoGetStackLimits(&LowLimit, &HighLimit);
__asm{
xor eax, eax;
mov al, g_cFlags; //0xAA
mov edi, LowLimit;
mov ecx, Esp_Value;
sub ecx, LowLimit;
cld;
rep stosb;
}
栈的污染
在调用ExAllocatePoolWithTag分配内存时，填充特殊标志数据
PVOID NTAPI HOOK_ExAllocatePoolWithTag(...)
{
PVOID Buffer = NULL; 
Buffer = pfn_ExAllocatePoolWithTag(PoolType, NumberOfBytes, Tag);
if (Buffer){
memset(Buffer, g_cFlags, NumberOfBytes); //将内存初始化特殊数据，如0xAA
}
return Buffer;
}
堆的污染
堆栈数据污染的思考
•
堆和栈数据污染技术相对简单，并不存在方法优劣
•
内存中可能存在和污染标记相同的数据，有误报的可能性
•
采用随机污染标记减少误报
第2步：数据检测技术研究
目前已经有基于CPU指令模拟、VT等数据检测技术。
那是否还有更简捷的方法呢？
数据检测技术研究
经过探索，我们提出了三种新的用于数据检测技术：
•
Nirvana（首次应用于内核信息泄露漏洞挖掘）
•
memcpy/memmove，后称memcpy（最轻量级的方法）
•
movsd
Nirvana是Microsoft提供的一个轻量级的动态translation框架，可用于监视和控制正在运行的进
程的执行，而无需重新编译或构建进程中的任何代码 （from Hooking Nirvana@Alex
Ionescu），首次被我们应用于内核信息泄露漏洞挖掘。
通过Nirvana可设置系统调用返回到用户态时的回调函数，在回调函数中能够检测栈数据。
ZwSetInformationProcess(NtCurrentProcess(),ProcessInstrumentationCallback,&Info64,size
of(Info64));
typedef struct _PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION{
ULONG_PTR Version;
ULONG_PTR Reserved;
ULONG_PTR Callback;
}PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION;
Nirvana概述
__declspec (naked) VOID InstrumentationCallback()
{
__asm{
//代码有省略...
mov eax, fs:[0x8];
mov edi, fs:[0x4];
cmp dword ptr[eax], g_cFlag; //如0xAAAAAAAA
jz __find;
add eax, 4;
cmp eax, edi;
//代码有省略...
jmp dword ptr fs : [0x1B0];
}
}
Nirvana检测技术的实现
Nirvana捕获到的现场
16
Nirvana检测技术的优点
•
Windows Vista之后系统都支持Nirvana
•
使用系统提供接口，实现非常简单
•
兼容性好
Nirvana检测技术的缺陷
•
只能检测栈数据，几乎无法检测堆数据
•
抓不到泄露现场，分析和编写POC相对困难
memcpy
•
Windows内核层向应用层写入数据一般都使用memcpy/memmove
kernel space
user space
用户态内存
内核态内存
memcpy(dst, src, size);
检测
Hook memcpy/memmove，检测dst是否用户态内存，数据是否包含特殊标志数据
void * __cdecl HOOK_memcpy( void * dst, void * src, size_t count)
{
//代码有省略...
if ((ULONG_PTR)dst  MmSystemRangeStart){
pOffset = (PUCHAR)src;
while (pOffset <= (PUCHAR)src + count - sizeof(DWORD)){
if (*(DWORD *)pOffset == g_dwDwordFlags){
//checked
}
}
}
//代码有省略...
}
memcpy检测技术的实现
memcpy检测技术特点
•
实现简单，性能突出几乎没有性能损失
•
兼容性好
•
能够抓到漏洞第一现场，分析和编写POC简单
•
优点突出，几无缺点
memcpy深入研究
•
size为变量，直接调用memcpy
•
size为常数，memcpy被优化
•
size为较大常数，优化为movsd
•
memmove不会被优化
movsd检测方法探索
•
memcpy会被优化成了什么？
•
最终都是编译成movsd指令
•
通过movsd检测数据解决极个别情况下memcpy覆盖面不够
的问题
movsd如何实现检测？
•
movsd dst, src; (F3A5)  int 20h; (CD20)  都是两字节
•
扫描nt模块代码段，替换所有movsd为int 20h
•
自定义int 20h中断处理函数，KiTrap20
•
KiTrap20中检测内存数据
if (*(WORD *)pOffset == 0xA5F3){ //rep movs dword ptr es:[edi],dword ptr [esi] 
MdlBuffer = GetMdlBuffer(&Mdl, pOffset, 2); 
*(WORD *)MdlBuffer = 0x20CD;//int 20
}
__declspec (naked) VOID HOOK_KiTrap20()
{       
__asm {
//代码有省略...
pushfd;
pushad; 
call DetectMemory;
popad;
popfd; 
rep movs dword ptr es:[edi], dword ptr[esi];//也可以检测类似指令
iretd; }
//代码有省略...
}
movsd检测技术的实现
VOID 
DetectMemory(PVOID DestAddress, PVOID SrcAddress, SIZE_T Size)
{
//代码有省略...
if ((ULONG_PTR)DestAddress < MmUserProbeAddress){
pOffset = (PUCHAR)SrcAddress;
if (*(ULONG_PTR *)pOffset == g_dwDwordFlags){
//checked
}
//代码有省略...
}
}
movsd检测技术的实现
movsd检测技术特点
•
检测数据较memcpy覆盖更全面
•
能够抓到漏洞第一现场，分析和编写POC简单
第3步：漏洞分析
•
捕获到疑似漏洞时，通过调试器现场分析确认
•
让代码执行回到用户态，确认用户态内存中是否存在特殊标志数据，
如果存在那么就是内核信息泄露漏洞
•
通过分析调用栈和逆向用户态的系统调用的相关代码，编写POC
漏洞分析
•
有些漏洞内存经过多次拷贝，造成分析和编写POC非常困难
•
我们专门实现了一套内存追踪的工具来辅助分析，支持：
•
内存trace
•
内存条件断点
这是win10 17134 x64检测到的一个漏洞现场，该漏洞已分配CVE-2018-8443
CVE实例分析
回溯到mpssvc.dll，确认用户态内存是否包含特殊标记
CVE实例分析
回溯到mpssvc.dll，找到漏洞触发代码
CVE实例分析
CVE实例分析
最终完成poc
CVE实例分析
使用三个月就已挖掘windows内核信息泄露漏洞12个，都已分配CVE
其中7个CVE获得当时最高5000$奖金
成果
思考
•
仅此而已吗…
•
用户态内存只读(去掉PTE写位)
•
反向追踪
•
…
？
Thank you
Tanghui Chen
PI:EMAIL