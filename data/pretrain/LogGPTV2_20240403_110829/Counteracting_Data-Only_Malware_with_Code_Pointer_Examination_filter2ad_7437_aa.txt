title:Counteracting Data-Only Malware with Code Pointer Examination
author:Thomas Kittel and
Sebastian Vogl and
Julian Kirsch and
Claudia Eckert
Counteracting Data-Only Malware
with Code Pointer Examination
Thomas Kittel(B), Sebastian Vogl, Julian Kirsch, and Claudia Eckert
Technische Universit¨at M¨unchen, M¨unchen, Germany
{kittel,vogls,kirschju,eckert}@sec.in.tum.de
Abstract. As new code-based defense technologies emerge, attackers
move to data-only malware, which is capable of infecting a system with-
out introducing any new code. To manipulate the control ﬂow without
code, data-only malware inserts a control data structure into the system,
for example in the form of a ROP chain, which enables it to combine
existing instructions into a new malicious program. Current systems try
to hinder data-only malware by detecting the point in time when the mal-
ware starts executing. However, it has been shown that these approaches
are not only performance consuming, but can also be subverted.
In this work, we introduce a new approach, Code Pointer Exami-
nation (CPE), which aims to detect data-only malware by identifying
and classifying code pointers. Instead of targeting control ﬂow changes,
our approach targets the control structure of data-only malware, which
mainly consists of pointers to the instruction sequences that the malware
reuses. Since the control structure is comparable to the code region of
traditional malware, this results in an eﬀective detection approach that
is diﬃcult to evade. We implemented a prototype for recent Linux ker-
nels that is capable of identifying and classifying all code pointers within
the kernel. As our experiments show, our prototype is able to detect
data-only malware in an eﬃcient manner (less than 1 % overhead).
Keywords: VMI · Introspection · CFI · CPI · CPE · Pointer examina-
tion · OS Integrity · Linux · kernel · Data-only malware
1 Introduction
Malware is without doubt one of the biggest IT security threats of our time. This
is especially true for kernel-level malware, which runs at the highest privilege
level and is thus able to attack and modify any part of the system, including the
operating system (OS) itself. However, even kernel-level malware has a weak-
ness that is well-suited for its detection: in order to execute, the malware has
to load its malicious instructions onto the victim’s system and thereby eﬀec-
tively change its codebase. This makes current kernel-level malware vulnerable
to code integrity-based defense mechanisms, which prevent or detect malicious
changes to the code regions of the system. It is not surprising that validating
c(cid:2) Springer International Publishing Switzerland 2015
H. Bos et al. (Eds.): RAID 2015, LNCS 9404, pp. 177–197, 2015.
DOI: 10.1007/978-3-319-26362-5 9
178
T. Kittel et al.
the integrity of the system’s code regions became a key approach to counter-
act malware. In the meantime, commodity OSs employ a multitude of mech-
anisms that protect the system’s codebase (e.g. W⊕X, secure boot, etc.) and
researchers presented sophisticated Code Integrity Validation (CIV) frameworks
that are capable of reliably and eﬃciently detecting malicious changes to the
code regions of userspace programs [20] as well as modern OS kernels [17].
As code integrity mechanisms become more and more widespread, attackers
are forced to ﬁnd new ways to infect and control a system. A likely next step
in malware evolution is thereby data-only malware, which solely uses instruc-
tions that already existed before its presence to perform its malicious compu-
tations [14]. To accomplish this, data-only malware employs code reuse tech-
niques such as return-oriented programming (ROP) or jump-oriented program-
ming (JOP) to combine existing instructions into new malicious programs. This
approach enables the malware form to evade all existing code-based defense
approaches and to persistently infect a system without changing its codebase [30].
Despite this capability and the substantial risk associated with it, there only exist
a handful of countermeasures against data-only malware so far, and those can
often be easily circumvented [6,9,13,24].
In this paper, we explore a new approach to the detection of data-only mal-
ware. The key idea behind this approach is to detect data-only malware based
on “malicious” pointers to code regions. For simplicity we refer to them as code
pointers. Similar to traditional malware, data-only malware has to control which
reused instruction sequence should be executed when. To achieve this, data-only
malware makes use of a control structure that contains pointers to the instruc-
tions that should be (re)used. This control structure can essentially be seen as
the “code region” of the data-only program that the malware introduces. By
identifying malicious code pointers in memory, we in essence aim to apply the
idea of code integrity checking to the ﬁeld of data-only malware by detecting
malicious control data within the system. For this purpose, we introduce the
concept of Code Pointer Examination (CPE).
The idea behind CPE is to identify and examine each possible code pointer
in memory in order to classify it as benign or malicious. This is essentially a
two-step process: In the ﬁrst step, we iterate through the entire memory of
the monitored machine with a byte by byte granularity in order to identify all
code pointers. In the second step, we classify the identiﬁed code pointers based
on heuristics. As our experiments showed, this approach results in an eﬀective
and high-performance (less than 1 % overhead) detection mechanism that can
detect data-only malware and is well-suited for live monitoring as well as forensic
investigations.
Since the OS is the integral part of the security model that is nowadays used
on most systems, we focus our work primarily on the Linux kernel. We chose this
OS, since it is open and well documented, which makes it easier to understand
and reproduce our work. However, the concepts and ideas that we present are
equally applicable to userspace applications and other OSs such as Windows.
Counteracting Data-Only Malware with Code Pointer Examination
179
In summary we make the following contributions:
– We present CPE, a novel approach to identify and classify code pointers in
64-bit systems.
– We highlight data structures that are used for control ﬂow decisions in modern
Linux kernels and thus must be considered for control ﬂow validation.
– We provide a prototype implementation and show that it is both eﬀective
and eﬃcient in detecting control structures of data-only malware.
2 Background
In this section we discuss foundations required for the rest of the paper.
Protection Mechanisms. Intel provides two new protection mechanisms to
make it signiﬁcantly harder for an attacker to introduce malicious code or data
into the kernel. The ﬁrst protection mechanism is Supervisor Mode Execution
Protection (SMEP). SMEP ensures that only code that is marked as executable
and supervisor is executed in kernel mode. In particular, if the CPU is trying to
fetch an instruction from a page that is marked as a user page while operating
with a Current Privilege Level (CPL) that is equal to zero, SMEP will generate
a protection fault. SMEP is usually used together with the No-eXecute (NX)
bit, which marks a page as not executable.
The second protection mechanism is Supervisor Mode Access Prevention
(SMAP). This feature can basically be seen as SMEP for data; it raises a fault if
data that is marked as user in the page tables is accessed within the kernel. With
both of these features enabled, the kernel is thus unable to access any userspace
memory. In combination, this signiﬁcantly reduces the amount of memory that
is usable as gadget space for an attacker.
Runtime Code Validation. A key idea that our work builds upon is runtime
code validation. While code-based defense mechanisms such as W⊕X and secure
boot ensure the integrity of code at load time, runtime code validation guarantees
that all code regions of a system are coherent and valid at any point in time
during its execution [17]. For this purpose, the code of the protected system is
constantly monitored and the legitimacy of all observed changes is veriﬁed. As
a result, any modiﬁcation or extension of the existing codebase can be detected
and prevented. To illustrate this, we brieﬂy describe the runtime code validation
framework presented by Kittel et al. [17], which serves as a foundation for this
work.
Kittel et al. created a runtime code validation framework that is capable of
reliably validating the integrity of all kernel code pages at runtime. To isolate the
monitoring component from the protected system, the proposed system makes
use of virtualization. Once monitoring begins, the validation framework ﬁrst
iterates through the page tables of the system to obtain a list of all executable
supervisor pages. Since the page tables are the basis for the address translation
conducted by the underlying hardware, this approach eﬀectively enables the
180
T. Kittel et al.
framework to reliably determine which memory regions are marked as executable
and could thus contain instructions.
In the next step, the monitor obtains the list of loaded kernel modules from
the monitored system using virtual machine introspection (VMI). Based on this
information the framework simulates the loading process of each of the modules
as well as the kernel image to obtain a trusted and known-to-be-good state of
the code regions that can later on be compared to the current state of the code
regions. To accomplish this, the framework requires access to a trusted store
that contains all modules as well as the kernel binary that are executing in
the monitored system. This trusted store is implemented by storing all trusted
binary ﬁles within the hypervisor.
Once the loading process has been simulated, the trusted code pages con-
tain all load time changes that the kernel applies. However, modern kernels may
also patch code regions at runtime in order to increase compatibility and per-
formance. As a result, the trusted code pages may at this point still diﬀer from
the code pages that are currently used by the monitored system. To identify
whether runtime changes have been applied, each of the trusted code pages is
compared byte by byte with its counterpart in the protected system. If a diﬀer-
ence is observed, the framework attempts to validate the changes by determining
whether the change was conducted by one of runtime patching mechanisms that
the kernel uses. The individual validation steps thereby heavily depend on the
hardware conﬁguration of the monitored system as well as the runtime patch-
ing mechanisms that it uses. The interested reader can ﬁnd an overview of the
individual runtime patching mechanisms employed by the Linux kernel in [17].
Data-only Malware. Runtime code validation frameworks eﬀectively hinder
an attacker from introducing malicious instructions into a system as this new
code will be detected and prevented from execution. To be able to control a
system under such circumstances, attackers must thus resort to malware forms
that leave the codebase of the attacked system untouched. The only malware
form that is currently known to be capable of such a feat is data-only malware,
which alters the control ﬂow of the infected system based on specially crafted
data structures [14,30].
In particular, data-only malware reuses the instructions that already existed
on the target system before the malware arrived to perform its malicious oper-
ations. This is achieved by applying code reuse techniques, commonly used in
the ﬁeld of binary exploitation, to the problem of malware creation. Well-known
examples of such techniques are ROP [27], JOP [3] and ret2libc [4].
To control the execution of the system, code reuse techniques leverage a
control data structure that consists of pointers to existing instruction sequences.
In general one cannot reuse arbitrary instruction sequences; instead, each of the
reused sequences must fulﬁll a particular property. For example, in the case of
ROP, each reused instruction sequence must end with a return instruction. The
property of the return instruction is thereby that it will load the address which
currently resides on top of the stack into the instruction pointer. This enables
us to control the execution of the system as follows: our ﬁrst reused instruction
Counteracting Data-Only Malware with Code Pointer Examination
181
sequence will point the stack pointer to our control data structure in memory.
Since the control structure now resides on the stack, the execution of the return
instruction at the end of each reused sequence will obtain the address of the next
sequence from the control structure and initiate its execution. Consequently, the
return instruction provides the “transition” between the individual sequences
whose addresses are contained within the control structure.
While code reuse exploits usually only make use of a very small control
data structure that simply allocates a writable and executable memory region
which is then used to execute traditional shellcode, control data structures of
data-only malware are in general quite large. The reason for this is that data-
only malware solely relies on code reuse to function. Each functionality that
the malware provides must be implemented by code reuse. The result are huge
chains that contain hundreds of reused instruction sequences [30]. However, due
to the increasing proliferation of code integrity mechanisms, attackers will likely
transition to this type of malware to attack modern OS kernels.
3 Attacker Model and Assumptions
In this work we assume that the monitored system is protected by a virtualization-
based runtime code integrity validation framework. In addition, we assume that
an attacker has gained full access to the monitored system, which she wants to
leverage to install kernel malware. While the attacker can, in principle, modify any
part of the system, the code validation framework will detect some of the changes
that the attacker may conduct. Most importantly, it will detect any changes to
executable kernel code and will in addition enforce SMEP and SMAP from the
hypervisor-level. As a result, the attacker is forced to use data-only malware to
infect the kernel. In this process, the control structure that is used by the attacker
must reside within kernel’s memory space since SMAP is in place. We also assume
that the kernel’s identity mapping which maps the entire physical memory into
kernel space is marked as usermode in the page tables. A similar approach was pre-
viously proposed by Kemerlis et al. [15], in which pages that are used by userspace
applications are temporarily unmapped from the identity mapping. Finally, we
assume that the data-only malware introduced into the system by the attacker is
persistent, i. e. will permanently reside within the memory of the target system, as
otherwise it could not be triggered by an external event. Notice that this is usually
the case for malware as Petroni and Hicks [22] showed.
4 Related Work
There is a plethora of work that is concerned with verifying the integrity of soft-
ware. The existing research can thereby be roughly divided into two parts. The
ﬁrst branch of research focuses on the integrity of the system’s code regions.
This led to the development of various frameworks that are capable of vali-
dating the integrity of the codebase of applications as well as the kernel code
sections [12,17,20]. This work builds upon said research by assuming that the
182
T. Kittel et al.
code of the monitored system cannot be modiﬁed by an attacker due to fact that
it is protected by such a framework.
The second branch of research, which our work belongs to, focuses on the
integrity of the kernel’s data and especially the kernel’s control data. A pop-
ular approach in this regard is Control Flow Integrity CFI validation, which
aims to dynamically validate the target of each branch instruction [1,16]. This
is accomplished by tracing and monitoring every indirect branch and the cur-
rent stack pointer of the inspected machine, implementing a shadow stack, or
using the performance counters of the monitored system to trace unpredicted
branches [7,21,33,34]. Unfortunately, however, current approaches not only suf-
fer from a signiﬁcant performance overhead, but also rely on invalid assumptions,
which makes them vulnerable to evasion attacks [6,9,13,26].
Instead of ensuring control ﬂow integrity for the entire kernel, there also
have been approaches that solely focus on the discovery of hooks, which are
often used by rootkits and other malware forms to intercept events within the
system [31,32]. During this process, existing approaches rely on the assumption
that only persistent control data can be abused for hooking. As in the case of CFI,
this assumption is invalid and can be used to circumvent existing mechanisms by
targeting transient control data instead [30]. Thus, neither hook-based detection
nor CFI mechanisms are currently capable of countering data-only malware.
In addition, there has been work aiming to reconstruct the kernel data struc-
tures and their interconnection on the hypervisor level in order to provide data
integrity checking [5,11,19,25]. The basic idea hereby is to parse the entire ker-
nel code to be able to reconstruct the dependencies of diﬀerent data structures
(points-to analysis) and to construct a map of kernel data structures. However,
current approaches are so far unable to reconstruct the entire graph of kernel
data structures, which allows data-only malware to evade detection by leveraging
techniques such as DKSM [2].
An alternative approach, similar to the one proposed in this work, aims to
scan for pointers to executable code in 32-bit userspace memory [23,28]. Unfor-
tunately, this approach has a high number of false positives on 32-bit systems.
Therefore, each detected code pointer is further analyzed using speculative code
execution.