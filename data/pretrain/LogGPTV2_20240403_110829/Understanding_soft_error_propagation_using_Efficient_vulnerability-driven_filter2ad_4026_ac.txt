level  and lower,  many 
more 
3) Branches and branch-related 
instructions. 
systems, where branch inÂ­
work, we target x86-based 
structions perform 
produced  by 
ways to corrupt 
control 
First, 
flow of the program. 
the previous 
jumps by reading 
the condition 
flags 
branch instructions 
instructions. 
There are two 
and change the 
the flags used by a branch instruction 
can be 
among the temporal-spatial points within the injection 
map. 
The  injection map is essentially 
identified 
identifier, 
often has 
ACE bits, as shown in Table II. Each instruction 
multiple 
registers. 
The potentially 
by VA. Each entry has three fields: the instruction 
the register 
and the mask of potentially 
as it accesses different 
ACE bit mask of the register 
architectural 
is important 
a list of vulnerable 
bits 
identifier, 
entries 
as 
to deterÂ­
results. 
In this 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:50:05 UTC from IEEE Xplore.  Restrictions apply. 
TABLE II 
INJECTION 
MAP 
Register ACE Bits 
No /-lOp 
Â°  add 
fax 
1  sub 
fbx 
2  st 
fax 
zf 
4  bf 
...  ... 
... 
0, 1,2,3,4,5,6,7,8 
Â° 
3 1,32,33, ... ,63 
2 
... 
different types of pruning 
in VA. 
if the mask of the 64-bit register 
rax has a value 
bits that survive 
it describes 
For example, 
of OxA, then only 2 bits (bits 1  and 3) 
surprisingly, 
for GFI 
targeted 
by VA. This condition 
environment. 
experiment, 
trace to zero in  on the intended 
by GFI has to  match 
to operate 
exactly 
Even in a hardware-based in
jection (e.g., FPGA) 
strategic breakpoints 
can be placed in the program 
injection regions, 
are eligible 
for GFL Not 
correctly, 
the instruction 
trace 
cessed 
with the trace pro
can be controlled 
in the simulation 
Because CriticalFault aims 
to stress 
the injections are inherently 
fault 
test the underlying 
biased. 
GFI 
tolerance 
solutions, 
map  to  avoid 
relies on the injection 
focus on faults that are more likely to result 
detection, 
computational 
non-derated 
soft errors on the reliability 
error samples, amplifying 
method-under
-test. 
a DUE, or a SDC Given  a fixed amount of 
derated 
faults and  to 
the effect of transient 
in  a recoverable 
resources, GFI will yield a higher number  of 
Despite 
lly, to conduct traÂ­
GFl's biased nature, 
SFI in CriticalFault 
we note that SER can still 
be modeled using CriticalFault. 
Specifica
ditional 
selected fault 
by the VA to determine 
A derated 
without 
injecting 
GFI is used to determine 
fault and to update the 
the fault into 
the error effect, if any, of the selected 
SER calculation. 
is first checked with the injection map generated 
is known to be derated, 
noted in the SER calculation 
the system. Otherwise, 
if the  fault 
fault  is 
actually 
right away 
IV. EXPERIMENTAL METHODOLOGY 
A. Simulation 
Infrastructure 
The main goal of CriticalFault 
is to steer the fault injection 
system. However, 
in a real microprocessor .  Also, non-deterministic 
controllability 
and observability 
of the 
towards 
on a real 
Ideally, 
in order 
allows  a 
and context 
complicate 
would further 
environment 
non-derated 
Fault framework 
and the fact  that 
Because of these  reasons 
faults 
mechanism. 
likely 
reliability 
the deployment 
a 
to stress 
we would 
microprocesÂ­
experiment 
test the underlying 
want to use the Critical 
sor in a real 
are limited 
system events such as asynchronous  interrupts 
switching 
framework. 
simulation 
experiments, 
work. Moreover,  since 
layer reliability 
to  completion  in 
aspect, 
and Guided Fault 
register 
transfer 
levels severely 
faults 
Nevertheless, as software-visible 
data in the  architectural 
we believe 
instruction 
the final error effect. In this 
can perform Vulnerability 
latch level, 
and 
solutions, 
order to observe 
while CriticalFault 
level (RTL), the low simulation 
limits the number of feasible 
we target hardware-software crossÂ­
are often required 
to run 
will eventually 
that the microÂ­
(or micro-Ops in x86 processors) level strikes 
speed at these 
experiments. 
of injection 
in this 
we focus on a simulated 
Injection at the  gate 
infrastructure 
better control 
Analysis 
programs 
corrupt 
level, 
state, 
a 
for determining  the  SER,  every 
stage of the instruction 
and the 
accuracy 
at this level. 
to  target 
good  balance  between  speed  and 
experiments 
CriticalFault 
level and use both microarchitecture-Ievel 
functional 
software 
and full-system 
the end error effects on the 
lly, we implement 
at the architecture 
soft errors occurring 
simulations 
More specifica
and conduct our 
programs, 
to capture 
In our experiments, 
we employ the FeS2 simulator 
[24] 
system 
floating 
integer 
are selected 
applications 
running on a computer 
from SPEC2000 and two 
and control-intensive 
and two SPLASH-2 benchmarks 
to 
computations. Two 
allow us to 
when they exÂ­
with CentOS Linux on x86-64 ISA. We chose 
benchmarks 
from 
that simulates 
equipped 
eight benchmarks 
SPLASH-2. Six SPECINT2000 benchmarks 
represent 
SPECFP2000 
investigate 
perience 
provides 
model that simulates 
x86 instructions 
Wind River Simics 3.0 [25] handles full-system simulation 
and  PTLSim 
[26] handles x86-to-fLOp translation. 
With  this 
setup, we are able to inject faults at  the /-lOp level instead 
x86-64 instruction 
level, 
behaviors 
point application 
On  the simulated 
superscalar 
soft errors. 
a detailed 
in a full-system environment. 
micro-operations 
hardware  side, 
(flOpS) of decoded 
us to observe 
of the faults. 
behavior 
allowing 
Specifica
more realistic 
out-of-order  micropr
ocessor 
FeS2 
lly, 
of 
paradigm, it 
executes 
in Simics. 
FeS2 is 
state of Simics. To facilitate 
faults are introduced 
As FeS2 uses a timing-first 
in parallel 
simulation 
to the x86 execution 
from FeS2  and Simics mismatch, 
injection mechanism, 
is then tagged as faulty. 
to the architectural 
/-lOp instructions 
If the results 
synchronized 
our guided  fault 
into FeS2 in the execution 
instruction 
faulty instruction 
in the architectural 
they do  not match, instead 
FeS2 overwrites 
state. 
This way, the faulty state can be properly 
subsequent 
After that, the processor pipeline 
Simics's architectural 
state after comparing 
retires, FeS2 detects 
instructions 
Subsequently, 
in  FeS2. 
state with its own faulty 
is flushed and restarted, 
propagated 
to 
of copying the state 
to that of Simics. If 
from Simics, 
when  this 
if there is a difference 
into 
the same  x86 
instruction. 
an x86 instruction  can 
arise when an x86 instruction 
Complications 
flOpS. A fault 
is decoded 
can propagate 
injected into  a  register 
to 
In this case, sevÂ­
ble or /-lOp-visible registers  might 
several 
later  flOpS  within 
eral x86-visi
For example, 
into three 
/-lOpS while a fault is injected into the second /-lOp. In this 
in the third 
case, the fault can corrupt 
keeps 
flOp. To handle these cases, 
track of affected registers 
and communicates  the 
changes to 
Simics after  the 
retires. 
our injection mechanism 
more than one register 
be translated 
The timing-first 
paradigm 
also affects how we handle store 
last flOp of the decoded x86 instruction 
be corrupted. 
faults may corrupt 
registers 
If only the date 
to the main 
the faulty data is committed 
In store  operations, 
values or memory addresses. 
instructions, 
holding  data 
value is affected, 
memory by our mechanism, 
value. However, 
A to A',  address A should still contain 
erroneously 
retires 
handle this scenario, 
A when a store is encountered 
in FeS2, Simics  already 
if a fault  changes 
and restores 
the old  value  while 
gets the store data. But, when the store instruction 
the memory address 
A' 
from 
our mechanism  reads 
the old value from 
A's  old  value 
when 
overwriting 
Simics's correct 
writes the store data to A. To 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:50:05 UTC from IEEE Xplore.  Restrictions apply. 


























 






 






Fig. 2. Different 
injection 
zones for architectural 
register 
R3. 
the faulty store retires, properly 
simulating 
the faulty behavior. 
B. Fault Model 
one of the bits. If there are more 
as many as nine 
If the bit mask 
as 
bits (bits identified 
for fault injection, 
three classes of 64-bit registers. 
We  select 
way. First, 
candidate 
bits in the mask, 
in VA), all bits are selected 
fewer than nine candidate 
of injected bits of each registers. 
bits for  the 
indicates 
potentially ACE 
with each injection corrupting 
than nine 
the following 
are always  selected.  Then, 
that are separated 
 is  randomly 
between the highest 
above. However, 
the highest 
we select 
chosen in Table II, the uniform 
bit (bit 63) and the lowest bit (bit 
bItS are 59, 55, . . .  , 
selected 
. 
has at most six possible injection points 
branch only depends 
we select 
and lowest candidate 
bits 
the nine bits in 
seven bits in the mask 
For example, 
if entry 
C. Parameters 
of Fault Injection 
CriticalFault 
currently 
uses the single bit-flip  fault  model 
state visible 
As our purpose 
after a bit is flipped, 
register until 
at the pDp level. 
value persists 
by a subsequent 
how non-derated 
in the architectural  register 
Essentially, 
the erroneous 
the architectural 
instruction. 
soft errors propagate 
we assume that the register 
observe 
Had parity or ECC mechanisms  been 
used, we can still model single bit-flips after  registers 
read/written 
it is overwritten 
is to investigate 
across the hardware 
file is unprotected 
the error effects. 
in order to better 
and software 
layers, 
[ 1 0] .  
are 
in 
In our experiments, 
w e  further 
assume that only bits in 
but not those of the 
registers. 
destination 
would be corrupted 
Figure 2 shows why this fault model 
the source registers 
destination 
covers bit-flips  in 
R3 is first written 
before  the 
for injecting errors in R3, with each zone 
of the read accesses. 
occurring 
next write. Thus, there are three possible zones 
each 
We note that zone 1 covers the faults 
and read by three different 
after R3 is written the 
first time. 
starting before 
registers  as  well.  In  the 
figure, 
instructions 
we conduct 
mentioned 
To investigate 
the effectiveness of CriticalFault, 
above. For each 
jection period 
By checking 
of instructions. 
picked a targeted  in
we randomly 
billions 
GFI on the ten benchmarks 
benchmark, 
by skipping 
traces, we make sure that the processor is not executing 
system library 
of the applicat
sufficient 
1 ,000 injections. Even if we extend the trace length to lOOK 
/-lOpS, the vulnerability 
same for 
the traces we studied. 
faults across the ten 
calls as  we want to observe the behavior 
ions. I We  found this trace size ( 10k)  to be 
results 
we injected around 1 0,000 
for identifying  potentially 
analysis 
OveraIl, 
remain  the 
ACE bits for selecting 
benchmarks. 
the /-lOp 
Based on this fault model, CriticalFault 
period is selected, 
execution 
proceeds 
as follows. 
the vulnerability 
D. Observing 
Error Propagation 
collects 
the injection 
After a targeted 
analyzer 
generate 
in the trace, 
registers 
map as shown in Table  II. 
the analyzer 
and insert 
a trace of 1 0,000 dynamic instructions 
to 
map. For every non-dead 
instruction 
identifies 
the appropriate 
ACE bits  in  the 
source 
into the injection 
entries 
Given the generated 
injection map, the Guided Fault InjecÂ­
/-lOpS from the beginning 
about 1 000 injection points. GFI chooses 
of the injection map, with 
/-lOpS separated 
by a random stride 
and 1 1  entries.  The distance 
between the first 
selects 
tor randomly 
candidate 
two adjacent candidate 
between  1 
candidate 
as they have different 
of injection entries. 
and the  last 
candidate 
AVFs, leading 
varies  among 
benchmarks 
distributions 
to different 
Each injection entry targets 
one of the following 
four types 
The primarily 
objective of CriticalFault 