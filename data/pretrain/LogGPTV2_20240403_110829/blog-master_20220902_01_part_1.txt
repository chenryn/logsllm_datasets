## DuckDB 线性回归预测股价的例子  
### 作者            
digoal            
### 日期            
2022-09-02            
### 标签            
PostgreSQL , DuckDB , 线性回归     
----            
## 背景        
如何预测股价? 除了回归分析统计算法, 还需要有方法论, 找出影响股价的因素, 可以参考华为基本法: 五看三定四配.   
- [《PG社区建设方法论 - 五看三定》](../202103/20210329_01.md)       
- [《德说-第122期, 隆中对 - 五看三定四配-华为基本法-战略制定》](../202208/20220811_02.md)    
- [《产品经理 - 以“五看三定”谈产品规划 - 含竞品分析方法》](../202101/20210128_02.md)    
影响企业的发展的要素:   
- 企业的生存环境(所处行业相关政策)、  
- 供应链(生产资料、伙伴等, 影响产能、成本等)、  
- 用户(客户所在行业的发展情况, 影响销售)、  
- 友商(竞争, 影响销售)、  
- 所处的行业(影响未来发展趋势)、  
- 自己;   
以上要素如何体现数字化呢? 可以从如下几个方面分析:   
- 政策文件, 根据文件影响的范围体现在行业或者大盘指数。所以可以看企业所处行业指数、大盘指数.   
- 供应链, 看企业所处行业的上游的相关行业指数。  
- 用户, 看企业服务的用户群体所属行业的行业指数。  
- 友商, 好坏可能不好评判, 除非它直接影响你. 因为友商好, 也可以解释为行业好.  但是: 友商如果是通过什么技术突破或者商业模式突破抢夺了有限的地盘, 这个就影响可能就是消极的. 甚至是颠覆的, 例如当年电商对线下零售的冲击.  
    - 建议看行业指数    
    - 非数字化的, 建议关注降维打击  
- 行业, 看行业指数。  
- 自己, 直接看自己的股价就好了。  
有了这几个输入, 就比较容易实施多元线性回归股价预测。可以根据情况选择里面的指标,   
## 算法举例  
根据 “看自己”模型, 只选取自己的每日收盘价, 做一元回归, 预测自己下一天的收盘价.   
在数学中，方程式 `Y=a+bX+修正值` , 自变量就是X , 因变量是Y。    
自变量是原因，因变量是结果。这个方程式中自变量的变化是因变量变化的原因，自变量是本身会发生变化，而因变量就是根据自变量的变化而变化。  
以天为周期, 样本数据例子:   
```  
自变量(自立、独立) - independent variable X  
因变量(果, 被预测) - dependent variable Y  
(X 昨天, Y 今天) :   
(day-15, day-14)   
(day-14, day-13)   
(day-13, day-12)   
...  
(day-1, day)   
```  
公式:  
```  
Y = regr_intercept + regr_slope * X  
regr_intercept(Y,X), 计算截距.  
regr_slope(Y,X), 计算斜率.  
regr_r2(Y,X), 计算相关性, 相关性越高, 说明这组数据用于预估的准确度越高.  
```  
预测算法:   
```  
LOOP 最近4到15天的数据, 自变量是"day"(也就是今天), 因变量是"day-1"(也就是前一天)   
//为什么选取最近4到15天呢? 因为至少要2组数据才能计算, 所以至少需要3天才能构成2组数据: (day-2,day-1), (day-1,day) ,  
//但是两组数就变成直线了, 相关性逼近1, 下一个点必然在直线上, 会导致没有参考意义. 所以至少取3组数字, 那么就需要4天的值:    
//(day-3,day-2), (day-2,day-1), (day-1,day)   
    计算 线性相关性, 截距, 斜率;  
    返回 最大的线性相关性, 以及对应 天数, 原始值list, 截距, 斜率;  
END LOOP;  
根据最近一个周期(天)的值, 截距, 斜率, 预测下一个周期(天)的值;  
返回预测值, 线性相关性, 以及对应 天数, 原始值list, 截距, 斜率;   
-- 如果停牌, 价格是0, 可以在生成原始数据时, 过滤掉价格是0的日期的数据. 价格通常会波动较大, 没什么可预测性.    
```  
最后, 可以对比真实值与预测值的差距;  
## DuckDB 一元回归预测例子  
测试到最后, 发现map类型的key不能动态输入, 可能是个bug. 本来map和array_sort是绝配, 根据最佳r2作为key返回对应map的预测值.    
```  
v_map = map([r2_list],[predict_result_list])   
k = array_sort(r2_list, 'DESC', 'NULLS LAST')[1]  
v_map[k]   
```  
1、下载茅台的历史收盘价数据:   
https://zhuanlan.zhihu.com/p/65662875  
```  
curl "http://quotes.money.163.com/service/chddata.html?code=0600519&start=20010101&end=20220901&fields=TOPEN;TCLOSE" -o ./historical_tradedata_0600519.SH.csv  
```  
由于下载过来的文件有编码的问题, 转换处理一下:    
```  
$ iconv -f GBK -t UTF-8 ~/Downloads/historical_tradedata_0600519.SH.csv > ~/Downloads/2.csv  
$ head -n 5 ~/Downloads/2.csv   
日期,股票代码,名称,开盘价,收盘价  
2022-09-01,'600519,贵州茅台,1912.15,1880.89  
2022-08-31,'600519,贵州茅台,1860.1,1924.0  
2022-08-30,'600519,贵州茅台,1882.35,1870.0  
2022-08-29,'600519,贵州茅台,1883.0,1878.82  
...  
```  
导入到duckdb his表:  
```  
D create table his (c1 date, c2 text, c3 text, c4 numeric, c5 numeric);  
D copy his from '/Users/digoal/Downloads/2.csv' ( HEADER );  
D select count(*) from his;  
┌──────────────┐  
│ count_star() │  
├──────────────┤  
│ 5101         │  
└──────────────┘  
D select * from his limit 10;  
┌────────────┬─────────┬──────────┬──────────┬──────────┐  
│     c1     │   c2    │    c3    │    c4    │    c5    │  
├────────────┼─────────┼──────────┼──────────┼──────────┤  
│ 2022-09-01 │ '600519 │ 贵州茅台 │ 1912.150 │ 1880.890 │  
│ 2022-08-31 │ '600519 │ 贵州茅台 │ 1860.100 │ 1924.000 │  
│ 2022-08-30 │ '600519 │ 贵州茅台 │ 1882.350 │ 1870.000 │  
│ 2022-08-29 │ '600519 │ 贵州茅台 │ 1883.000 │ 1878.820 │  
│ 2022-08-26 │ '600519 │ 贵州茅台 │ 1900.000 │ 1898.000 │  
│ 2022-08-25 │ '600519 │ 贵州茅台 │ 1859.000 │ 1885.000 │  
│ 2022-08-24 │ '600519 │ 贵州茅台 │ 1869.990 │ 1854.200 │  
│ 2022-08-23 │ '600519 │ 贵州茅台 │ 1898.600 │ 1870.010 │  
│ 2022-08-22 │ '600519 │ 贵州茅台 │ 1885.010 │ 1893.980 │  
│ 2022-08-19 │ '600519 │ 贵州茅台 │ 1898.000 │ 1895.010 │  
└────────────┴─────────┴──────────┴──────────┴──────────┘  
```  
删除报价为0的数据  
```  
D delete from his where c4 =0 or c5=0;   
D select * from his where c4 =0 or c5=0;   
D select c1, lag(c5) over (order by c1) as yesterday, c5 as today from his order by c1 limit 10;  
┌────────────┬───────────┬────────┐  
│     c1     │ yesterday │ today  │  
├────────────┼───────────┼────────┤  
│ 2001-08-27 │           │ 35.550 │  
│ 2001-08-28 │ 35.550    │ 36.860 │  
│ 2001-08-29 │ 36.860    │ 36.380 │  
│ 2001-08-30 │ 36.380    │ 37.100 │  
│ 2001-08-31 │ 37.100    │ 37.010 │  
│ 2001-09-03 │ 37.010    │ 36.990 │  
│ 2001-09-04 │ 36.990    │ 37.460 │  
│ 2001-09-05 │ 37.460    │ 37.440 │  
│ 2001-09-06 │ 37.440    │ 36.700 │  
│ 2001-09-07 │ 36.700    │ 35.680 │  
└────────────┴───────────┴────────┘  
```  
使用窗口函数, 帧的概念, 可以获得每一条记录对应的最近N天的数据, 并聚合成数组. 后面就可以用这个数组来做回归运算.  