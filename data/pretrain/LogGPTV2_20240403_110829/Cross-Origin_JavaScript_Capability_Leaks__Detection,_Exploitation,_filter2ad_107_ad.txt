if their prototypes share the same structure. Addi-
tionally,
the Nitro JavaScript engine initializes each
Object.prototype with a unique structure identi-
ﬁer, preventing two object from different security ori-
gins (as deﬁned by our prototype-based algorithm) from
being be grouped together as sharing the same structure.
(Other JavaScript engines, such as V8, do contain struc-
ture groups that span security origins, but this design
is not necessary for performance.) Whenever the inline
cache has a hit, we observe the following:
• The current object is from the same security origin
as the original object that created the cache entry
because the two objects share the same structure.
• The script has the same security origin as when the
cache entry was created because the cache is inlined
into the script and the security origin of the script is
ﬁxed at compile time.
Taken together, these properties imply that the current
access control check will return the same result as the
original check because both of the origins involved in the
check are unchanged. Therefore, we need not perform
an access control check during a cache hit, greatly reduc-
ing the performance overhead of adding access control
checks to the JavaScript engine.
5.4 Evaluation
To evaluate performance overhead of our defense,
we added access control checks to Safari 4’s Nitro
JavaScript engine in a 394 line patch. We veriﬁed that
our access control checks actually defeat the proof-of-
concept exploits we construct in Section 4. To speed up
the access control checks, we represented each security
origin by a pointer, letting us allow the vast majority of
accesses using a simple pointer comparison.
In some
rare cases, including to deny access, our implementation
performs a more involved access check. The majority of
performance overhead in our implementation is caused
Figure 4: Overhead for access control checks as measure
by industry-standard JavaScript benchmarks (average of
10 runs, 95% conﬁdence).
Figure 5: Overhead for reading and writing properties of
JavaScript objects both with and without an inline cache
as measured by microbenchmarks (average of 10 runs,
95% conﬁdence).
by computing the currently active origin from the lexical
scope, which can be reduced with further engineering.
Overall Performance. Our implementation incurs a
small overhead on industry-standard JavaScript bench-
marks (see Figure 4). On Mozilla’s Dromaeo bench-
mark, we observed a 0.57% slowdown for access con-
trol versus an unmodiﬁed browser (average of 10 runs,
±0.58%, 95% conﬁdence). On Apple’s SunSpider
benchmark, we observed a 1.16% slowdown (average
of 10 runs, ±0.45%, 95% conﬁdence). On Google’s V8
benchmark, we observed a 1.94% slowdown (average of
10 runs, ±0.61, 95% conﬁdence). We hypothesize that
the variation in slowdown between these benchmarks is
due to the differing balance between arithmetic opera-
tions and property accesses in the different benchmarks.
Note that these overhead numbers are tiny in comparison
with the 338% speedup of Safari 4 over Safari 3.1 [24].
DromaeoSunSpiderV8 Suite0.0%0.5%1.0%1.5%2.0%2.5%3.0%BenchmarkSlowdownInline CacheNo Inline Cache-2%0%2%4%6%8%10%12%SlowdownReadReadWriteWriteBeneﬁts of Inline Cache. We attribute much of the
performance of our access checks to the inline cache,
which lets our implementation skip redundant access
control checks for repeated property accesses. To evalu-
ate the performance beneﬁts of the inline cache, we cre-
ated two microbenchmarks, “read” and “write.” In the
read benchmark, we repeatedly performed a get opera-
tion on one property of a JavaScript object in a loop. In
the write benchmark, we repeatedly performed a set
operation on one property of a JavaScript object in a
loop. We then measured the slowdown incurred by the
access control checks both with the inline cache enabled
and with the inline cache disabled (see Figure 5). With
the inline cache enabled, we observed a −0.08% slow-
down (average of 50 runs, ±0.22%, 95% conﬁdence)
on the read benchmark and a 0.55% slowdown (aver-
age of 50 runs, ±0.74%, 95% conﬁdence) on the write
benchmark. By contrast, with the inline cache disabled,
we observed a 9.41% slowdown (average of 50 runs,
±1.11%, 95% conﬁdence) on the read benchmark and
a 10.25% slowdown (average of 50 runs, ±1.00%, 95%
conﬁdence) on the write benchmark.
From these observations we conclude that browser
vendors can implement access control checks for ev-
ery get and set operation with a performance over-
head of less than 1–2%. To reap these security bene-
ﬁts with minimal overhead, the JavaScript engine should
employ an inline cache to optimize repeated property
accesses, and the inline cache should group structurally
similar JavaScript objects only if those objects are from
the same security origin.
6 Related Work
The operating system literature has a rich history
of work on access control and object-capability sys-
tems [13, 21, 23, 8]. In this section, we focus on com-
paring our work to related work on access control and
object-capability systems in Web browsers.
FBJS, Caja, and ADsafe. Facebook, Yahoo!, and
Google have developed JavaScript subsets, called
FBJS [5], ADsafe [3], and Caja [16], respectively,
that enforce an object-capability discipline by remov-
ing problematic JavaScript features (such as prototypes)
and DOM APIs (such as innerHTML). These projects
take the opposite approach from this paper: they extend
the JavaScript engine’s object-capability security model
to the DOM instead of extending the DOM’s access
control security model to the JavaScript engine. These
projects choose this alternative design point for two rea-
sons: (1) the projects target new social networking gad-
gets and advertisements that are free from compatibil-
ity constraints and (2) these projects are unable to al-
ter legacy browsers because they must work in existing
browsers. We face the opposite constraints: we cannot
alter legacy content but we can change the browser. For
these reasons, we recommend the opposite design point.
Opus Palladianum. The Opus Palladianum (OP) Web
browser [6] isolates security origins into separate sand-
boxed components. This component-based browser
architecture makes it easier to reason about cross-
origin JavaScript capability leaks because these capa-
bility leaks must occur between browser components
instead of within a single JavaScript heap. We can
view the sandbox as a coarse-grained reference mon-
itor. Unfortunately, the sandbox alone is too coarse-
grained to implement standard browser features such
as postMessage. To support these features,
the
OP browser must allow inter-component references, but
without a public implementation, we are unable to eval-
uate whether these inter-component references give rise
to cross-origin JavaScript capability leaks.
Script Accenting. Script accenting [2] is a technique
for adding defense-in-depth to the browser’s enforce-
ment of the same-origin policy. To mitigate mistaken
script execution, the browser encrypts script source code
with a key speciﬁc to the security origin of the script.
Whenever the browser attempts to run a script in a secu-
rity origin, the browser ﬁrst decrypts the script with the
security origin’s key. If decryption fails, likely because
of a vulnerability, the browser refuses to execute the
script. Script accenting similarly encrypts the names of
JavaScript properties ostensibly preventing a script from
manipulating properties of objects from another origin.
Unfortunately, this approach is not expressive enough to
represent the same-origin policy (e.g., this design does
not support document.domain). In addition, script
accenting requires XOR encryption to achieve sufﬁcient
performance, but XOR encryption lacks the integrity
protection required to make the scheme secure.
Cross-Origin Wrappers. Firefox 3 uses cross-origin
wrappers [20] to mitigate security vulnerabilities caused
by cross-origin JavaScript capability leaks.
Instead of
exposing JavaScript objects directly to foreign security
origins, Firefox exposes a “wrapper” object that me-
diates access to the wrapped object with a reference
monitor. Implementing cross-origin wrappers correctly
is signiﬁcantly more complex than implementing ac-
cess control correctly because the cross-origin wrappers
must wrap and unwrap objects at the appropriate times
in addition to implementing all the same access con-
trol checks. Our access control design can be viewed
as a high-performance technique for reducing this com-
plexity (and the attendant bugs) by adding the reference
monitor to every object.
7 Conclusions
In this paper, we identify a class of vulnerabilities, cross-
origin JavaScript capability leaks, that arise when the
browser leaks a JavaScript pointer from one security
origin to another. These vulnerabilities undermine the
same-origin policy and prevent Web sites from secur-
ing themselves against Web attackers. We present an
algorithm for detecting cross-origin JavaScript capabil-
ity leaks by monitoring the “points-to” relation between
JavaScript objects in the JavaScript heap. We imple-
ment our detection algorithm in WebKit and use it to
ﬁnd new cross-origin JavaScript capability leaks by run-
ning the WebKit regression test suite in our instrumented
browser. Having discovered these leaked pointers, we
turn our attention to exploiting these vulnerabilities. We
construct exploits to illustrate the vulnerabilities and ﬁnd
that the root cause of the these vulnerabilities is the
mismatch in security models between the DOM, which
uses access control, and the JavaScript engine, which
uses object-capabilities. Instead of patching each leak,
we recommend that browser vendors repair the under-
lying architectural issue by implementing access con-
trol checks throughout the JavaScript engine. Although
a straight-forward implementation that performed these
checks for every access would have a prohibitive over-
head, we demonstrate that a JavaScript engine optimiza-
tion, the inline cache, reduces this overhead to 1–2%.
Acknowledgements. We thank Chris Karloff, Oliver
Hunt, Collin Jackson, John C. Mitchell, Rachel Parke-
Houben, and Sam Weinig for their helpful suggestions
and feedback. This material is based upon work par-
tially supported by the National Science Foundation un-
der Grants No. 0311808, No. 0448452, No. 0627511,
and CCF-0424422, and by the Air Force Ofﬁce of Scien-
tiﬁc Research under MURI Grant No. 22178970-4170.
Any opinions, ﬁndings, and conclusions or recommen-
dations expressed in this material are those of the au-
thor(s) and do not necessarily reﬂect the views of the
Air Force Ofﬁce of Scientiﬁc Research, or the National
Science Foundation.
References
[1] Adam Barth, Collin Jackson, and John C. Mitchell.
Securing frame communication in browsers.
In
Proceedings of the 17th USENIX Security Sympo-
sium, 2008.
[2] Shuo Chen, David Ross, and Yi-Min Wang. An
analysis of browser domain-isolation bugs and a
light-weight transparent defense mechanism.
In
CCS ’07: Proceedings of the 14th ACM conference
on Computer and communications security, pages
2–11, New York, NY, USA, 2007. ACM.
[3] Douglas Crockford. ADsafe.
[4] Douglas Crockford. ADsafe DOM API.
[5] Facebook. Facebook Markup Language (FBML).
[6] Chris Grier, Shuo Tang, and Samuel T. King. Se-
cure web browsing with the OP web browser. In
IEEE Symposium on Security and Privacy, 2008.
[7] Jeremiah Grossman. Clickjacking: Web pages can
see and hear you, October 2008.
[8] Norm Hardy. The keykos architecture. Operating
Systems Review, 1985.
[9] Norm Hardy. The confused deputy: (or why capa-
bilities might have been invented). SIGOPS Oper.
Syst. Rev., 22(4):36–38, 1988.
[10] Ian Hickson et al. HTML 5 Working Draft.
[11] Collin Jackson and Helen J. Wang.
Sub-
space: Secure cross-domain communication for
web mashups. In Proceedings of the 16th Interna-
tional World Wide Web Conference. (WWW), 2007.
2004.
Frame busting,
http://www.quirksmode.org/js/
framebust.html.
[12] Peter-Paul Koch.
[13] Butler Lampson. Protection and access control in
operating systems. Operating Systems: Infotech
State of the Art Report, 14:309–326, 1972.
[14] Sergio Maffeis, John C. Mitchell, and Ankur Taly.
In Pro-
An operational semantics for JavaScript.
ceedings of the 6th Asian Programming Language
Symposium (APLAS), December 2008.
[15] Mark Miller. A theory of taming.
[16] Mark Miller. Caja, 2007.
[17] Mitre. CVE-2008-4058.
[18] Mitre. CVE-2008-4059.
[19] Mitre. CVE-2008-5512.
[20] Mozilla. XPConnect wrappers.
http://developer.mozilla.org/en/
docs/XPConnect_wrappers.
[21] Sape J. Mullender, Guido van Rossum, Andrew
Tannenbaum, Robbert van Renesse, and Hans van
Staveren. Amoeba: A distributed operating system
for the 1990s. Computer, 23(5):44–53, 1990.
[22] Prototype JavaScript framework.
http://www.prototypejs.org/.
[23] Jonathan S. Shapiro, Jonathan M. Smith, and
David J. Farber. Eros: a fast capability system. In
17th ACM Symposium on Operating System Prin-
ciples, New York, NY, USA, 1999. ACM.
[24] Maciej Stachowiak. Introducing SquirrelFish Ex-
treme, 2008.
[25] Kris Zyp. CrossSafe.