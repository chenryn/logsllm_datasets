### Improved Text

#### Structure Identifier and Security Origin

The Nitro JavaScript engine assigns a unique structure identifier to each `Object.prototype`, ensuring that objects from different security origins (as defined by our prototype-based algorithm) cannot be grouped together as having the same structure. This is in contrast to other JavaScript engines, such as V8, which may group objects across different security origins. However, this design is not necessary for performance.

When an inline cache hit occurs, the following conditions are observed:
- The current object shares the same security origin as the original object that created the cache entry, due to their shared structure.
- The script's security origin remains the same as when the cache entry was created, since the cache is inlined into the script and the script's security origin is fixed at compile time.

These properties ensure that the current access control check will yield the same result as the original check, as both the involved origins remain unchanged. Consequently, there is no need to perform an access control check during a cache hit, significantly reducing the performance overhead of adding access control checks to the JavaScript engine.

#### Evaluation

To evaluate the performance overhead of our defense, we implemented access control checks in Safari 4’s Nitro JavaScript engine using a 394-line patch. We verified that these access control checks effectively mitigate the proof-of-concept exploits described in Section 4. To optimize the access control checks, we represented each security origin with a pointer, allowing most accesses to be validated through a simple pointer comparison. In rare cases, including those where access is denied, a more detailed access check is performed. The primary source of performance overhead in our implementation is the computation of the currently active origin from the lexical scope, which can be further optimized.

**Overall Performance:**
Our implementation incurs a minimal overhead on industry-standard JavaScript benchmarks (see Figure 4). On Mozilla’s Dromaeo benchmark, we observed a 0.57% slowdown for access control compared to an unmodified browser (average of 10 runs, ±0.58%, 95% confidence). On Apple’s SunSpider benchmark, we observed a 1.16% slowdown (average of 10 runs, ±0.45%, 95% confidence). On Google’s V8 benchmark, we observed a 1.94% slowdown (average of 10 runs, ±0.61%, 95% confidence). The variation in slowdown between these benchmarks is likely due to the differing balance between arithmetic operations and property accesses. These overhead numbers are negligible compared to the 338% speedup of Safari 4 over Safari 3.1 [24].

**Benefits of Inline Cache:**
We attribute much of the performance of our access checks to the inline cache, which allows our implementation to skip redundant access control checks for repeated property accesses. To evaluate the performance benefits of the inline cache, we created two microbenchmarks: "read" and "write". In the read benchmark, we repeatedly performed a get operation on one property of a JavaScript object in a loop. In the write benchmark, we repeatedly performed a set operation on one property of a JavaScript object in a loop. We then measured the slowdown incurred by the access control checks both with and without the inline cache enabled (see Figure 5).

With the inline cache enabled, we observed a -0.08% slowdown (average of 50 runs, ±0.22%, 95% confidence) on the read benchmark and a 0.55% slowdown (average of 50 runs, ±0.74%, 95% confidence) on the write benchmark. Without the inline cache, we observed a 9.41% slowdown (average of 50 runs, ±1.11%, 95% confidence) on the read benchmark and a 10.25% slowdown (average of 50 runs, ±1.00%, 95% confidence) on the write benchmark.

From these observations, we conclude that browser vendors can implement access control checks for every get and set operation with a performance overhead of less than 1–2%. To achieve these security benefits with minimal overhead, the JavaScript engine should use an inline cache to optimize repeated property accesses, and the inline cache should group structurally similar JavaScript objects only if they are from the same security origin.

#### Related Work

The operating system literature has a rich history of work on access control and object-capability systems [13, 21, 23, 8]. In this section, we focus on comparing our work to related efforts on access control and object-capability systems in web browsers.

**FBJS, Caja, and ADsafe:**
Facebook, Yahoo!, and Google have developed JavaScript subsets, called FBJS [5], ADsafe [3], and Caja [16], respectively, that enforce an object-capability discipline by removing problematic JavaScript features (such as prototypes) and DOM APIs (such as `innerHTML`). These projects extend the JavaScript engine’s object-capability security model to the DOM, rather than extending the DOM’s access control security model to the JavaScript engine. They choose this approach because they target new social networking gadgets and advertisements that are free from compatibility constraints and must work in existing browsers. In contrast, we face the opposite constraints: we cannot alter legacy content but can change the browser. Therefore, we recommend the opposite design point.

**Opus Palladianum:**
The Opus Palladianum (OP) Web browser [6] isolates security origins into separate sandboxed components. This component-based architecture simplifies reasoning about cross-origin JavaScript capability leaks, as these leaks must occur between browser components rather than within a single JavaScript heap. The sandbox can be viewed as a coarse-grained reference monitor. Unfortunately, the sandbox alone is too coarse-grained to support standard browser features like `postMessage`. To support these features, the OP browser must allow inter-component references, but without a public implementation, it is difficult to evaluate whether these references lead to cross-origin JavaScript capability leaks.

**Script Accenting:**
Script accenting [2] is a technique for adding defense-in-depth to the browser’s enforcement of the same-origin policy. To mitigate mistaken script execution, the browser encrypts script source code with a key specific to the security origin of the script. When the browser attempts to run a script in a security origin, it first decrypts the script with the security origin’s key. If decryption fails, likely due to a vulnerability, the browser refuses to execute the script. Script accenting also encrypts the names of JavaScript properties, preventing a script from manipulating properties of objects from another origin. However, this approach is not expressive enough to fully represent the same-origin policy (e.g., it does not support `document.domain`). Additionally, script accenting requires XOR encryption for sufficient performance, but XOR encryption lacks the integrity protection required for security.

**Cross-Origin Wrappers:**
Firefox 3 uses cross-origin wrappers [20] to mitigate security vulnerabilities caused by cross-origin JavaScript capability leaks. Instead of exposing JavaScript objects directly to foreign security origins, Firefox exposes a “wrapper” object that mediates access to the wrapped object with a reference monitor. Implementing cross-origin wrappers correctly is significantly more complex than implementing access control, as the wrappers must wrap and unwrap objects at the appropriate times and implement all the same access control checks. Our access control design can be viewed as a high-performance technique for reducing this complexity (and the attendant bugs) by adding the reference monitor to every object.

#### Conclusions

In this paper, we identify a class of vulnerabilities, cross-origin JavaScript capability leaks, which arise when the browser leaks a JavaScript pointer from one security origin to another. These vulnerabilities undermine the same-origin policy and prevent websites from securing themselves against web attackers. We present an algorithm for detecting cross-origin JavaScript capability leaks by monitoring the “points-to” relation between JavaScript objects in the JavaScript heap. We implement our detection algorithm in WebKit and use it to find new cross-origin JavaScript capability leaks by running the WebKit regression test suite in our instrumented browser.

Having discovered these leaked pointers, we turn our attention to exploiting these vulnerabilities. We construct exploits to illustrate the vulnerabilities and find that the root cause is the mismatch in security models between the DOM, which uses access control, and the JavaScript engine, which uses object-capabilities. Instead of patching each leak, we recommend that browser vendors address the underlying architectural issue by implementing access control checks throughout the JavaScript engine. Although a straightforward implementation that performs these checks for every access would have a prohibitive overhead, we demonstrate that a JavaScript engine optimization, the inline cache, reduces this overhead to 1–2%.

#### Acknowledgements

We thank Chris Karloff, Oliver Hunt, Collin Jackson, John C. Mitchell, Rachel Parke-Houben, and Sam Weinig for their helpful suggestions and feedback. This material is based upon work partially supported by the National Science Foundation under Grants No. 0311808, No. 0448452, No. 0627511, and CCF-0424422, and by the Air Force Office of Scientific Research under MURI Grant No. 22178970-4170. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the Air Force Office of Scientific Research or the National Science Foundation.

#### References

[1] Adam Barth, Collin Jackson, and John C. Mitchell. Securing frame communication in browsers. In Proceedings of the 17th USENIX Security Symposium, 2008.

[2] Shuo Chen, David Ross, and Yi-Min Wang. An analysis of browser domain-isolation bugs and a light-weight transparent defense mechanism. In CCS ’07: Proceedings of the 14th ACM conference on Computer and communications security, pages 2–11, New York, NY, USA, 2007. ACM.

[3] Douglas Crockford. ADsafe.

[4] Douglas Crockford. ADsafe DOM API.

[5] Facebook. Facebook Markup Language (FBML).

[6] Chris Grier, Shuo Tang, and Samuel T. King. Secure web browsing with the OP web browser. In IEEE Symposium on Security and Privacy, 2008.

[7] Jeremiah Grossman. Clickjacking: Web pages can see and hear you, October 2008.

[8] Norm Hardy. The keykos architecture. Operating Systems Review, 1985.

[9] Norm Hardy. The confused deputy: (or why capabilities might have been invented). SIGOPS Oper. Syst. Rev., 22(4):36–38, 1988.

[10] Ian Hickson et al. HTML 5 Working Draft.

[11] Collin Jackson and Helen J. Wang. Sub-space: Secure cross-domain communication for web mashups. In Proceedings of the 16th International World Wide Web Conference (WWW), 2007.

[12] Peter-Paul Koch. Frame busting, http://www.quirksmode.org/js/framebust.html.

[13] Butler Lampson. Protection and access control in operating systems. Operating Systems: Infotech State of the Art Report, 14:309–326, 1972.

[14] Sergio Maffeis, John C. Mitchell, and Ankur Taly. An operational semantics for JavaScript. In Proceedings of the 6th Asian Programming Language Symposium (APLAS), December 2008.

[15] Mark Miller. A theory of taming.

[16] Mark Miller. Caja, 2007.

[17] Mitre. CVE-2008-4058.

[18] Mitre. CVE-2008-4059.

[19] Mitre. CVE-2008-5512.

[20] Mozilla. XPConnect wrappers, http://developer.mozilla.org/en/docs/XPConnect_wrappers.

[21] Sape J. Mullender, Guido van Rossum, Andrew Tannenbaum, Robbert van Renesse, and Hans van Staveren. Amoeba: A distributed operating system for the 1990s. Computer, 23(5):44–53, 1990.

[22] Prototype JavaScript framework, http://www.prototypejs.org/.

[23] Jonathan S. Shapiro, Jonathan M. Smith, and David J. Farber. Eros: a fast capability system. In 17th ACM Symposium on Operating System Principles, New York, NY, USA, 1999. ACM.

[24] Maciej Stachowiak. Introducing SquirrelFish Extreme, 2008.

[25] Kris Zyp. CrossSafe.