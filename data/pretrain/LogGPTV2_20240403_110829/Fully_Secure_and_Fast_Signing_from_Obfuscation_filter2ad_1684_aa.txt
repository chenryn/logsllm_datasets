title:Fully Secure and Fast Signing from Obfuscation
author:Kim Ramchen and
Brent Waters
Fully Secure and Fast Signing from Obfuscation
Kim Ramchen
Brent Waters
University of Texas at Austin
University of Texas at Austin
PI:EMAIL
PI:EMAIL
Abstract
In this work we explore new techniques for building short signatures from obfuscation. Our goals are
twofold. First, we would like to achieve short signatures with adaptive security proofs. Second, we would
like to build signatures with fast signing, ideally signiﬁcantly faster than comparable signatures that are
not based on obfuscation. The goal here is to create an “imbalanced” scheme where signing is fast at the
expense of slower veriﬁcation.
We develop new methods for achieving short and fully secure obfuscation-derived signatures. Our base
signature scheme is built from punctured programming and makes a novel use of the “preﬁx technique”
to guess a signature. We ﬁnd that our initial scheme has slower performance than comparable algorithms
(e.g. EC-DSA). We ﬁnd that the underlying reason is that the underlying PRG is called ≈ (cid:96)2 times for
security parameter (cid:96).
To address this issue we construct a more eﬃcient scheme by adapting the Goldreich-Goldwasser-
Micali [GGM86] construction to form the basis for a new puncturable PRF. This puncturable PRF
accepts variable-length inputs and has the property that evaluations on all preﬁxes of a message can
be eﬃciently pipelined. Calls to the puncturable PRF by the signing algorithm therefore make fewer
invocations of the underlying PRG, resulting in reduced signing costs.
We evaluate our puncturable PRF based signature schemes using a variety of cryptographic candidates
for the underlying PRG. We show that the resulting performance on message signing is competitive with
that of widely deployed signature schemes.
1 Introduction
Obfuscation deals with the problem of how to protect a program from reverse engineering while preserving
functionality. Traditionally constructing secure obfuscation in a mathematically sound way has been a very
challenging problem. While there have been numerous ad hoc approaches to obfuscation, in practice these
have nearly all broken, pointing to the need for a cryptographically grounded solution. This state of aﬀairs
changed dramatically with the introduction of candidate indistinguishability obfuscation by Garg, Gentry,
Halevi, Raykova, Sahai and Waters [GGH+13a].
Recently, starting with [SW14] there has been much interest in investigating what can be built from
indistinguishability obfuscation, since this model leads to poly-time obfuscation of unrestricted program
classes, circumventing the known impossibility results of [BGI+01]. Roughly, this body of work can be
divided into two classes. The ﬁrst seeks to discover new applications that were not achievable prior to
introduction of secure obfuscation. The second seeks to re-explore the construction of existing cryptographic
primitives, but through the lens of obfuscation.
The latter direction is important for several reasons. First, re-exploration leads to qualitatively diﬀerent
ways of approaching cryptographic problems. For example, the Sahai-Waters [SW14] public key scheme was
obtained by application of obfuscation to symmetric key encryption, thereby matching Diﬃe and Hellman’s
original vision that public key encryption be obtainable by scrambling a private key enciphering program
[DH76]. Moreover the techniques that were used to build cryptographic primitives for which their were
already candidates, led to new and unexpected results. For example the technique of “punctured program-
ming”, which was used to construct public key encryption in turn, led to the ﬁrst construction of deniable
1
encryption. Second, such schemes have unique and interesting properties in their own right. For example,
decryption in the SW public key cryptosystem involves only a symmetric key operations and is therefore
quite fast. Likewise the signing algorithm from their signature scheme is also fast due to only applying
symmetric key primitives.
This work In this paper we explore building new signature systems from obfuscation. Our goals are
twofold. First, we would like to achieve short signatures with adaptive security proofs (matching the GMR
deﬁnition [GMR88]).
Second, we would like to build signatures with fast signing— ideally signiﬁcantly faster than comparable
signatures that are not based on obfuscation. The goal here is to create an “imbalanced” scheme where
signing is fast at the expense of longer veriﬁcation. Such imbalance could be useful in applications where
signing must be done by low power devices such as sensors, which veriﬁcation can be done by well equipped
machines. We note that employing imbalanced schemes has a long history. For example, an earlier feature
of low-exponent RSA [Knu81] (e.g. e = 3) was that veriﬁcation was very fast. In addition, recent work
on delegation of computation (e.g., [GGP10, LW12, GGH+13b, GVW13, PHGR13] ) works on a similar
principle of saving resources of a weaker client.
Although current obfuscation candidates will admit prohibitively slow veriﬁcation, the work of obfuscation
is in its nascent stages and it is plausible that systems with reasonable performance will be realized in the
not too distant future. This future seems even more possible if one considers that obfuscation candidates
might be designed and optimized for implementing particular functionalities.
We begin by overviewing the techniques of the SW signature system [SW14] which builds signatures
from puncturable pseudorandom functions (PRFs). We brieﬂy recall that a puncturable PRF is a type of
constrained pseudo random function [BW13, BGI14, KPTZ13] where a key K{x∗} can be given out that
allows one to evaluate the (keyed) function FK(·) at all inputs x except when x = x∗. In this scheme the Setup
algorithm chooses a puncturable PRF key at random. A message is signed by evaluating the puncturable
PRF on it. The veriﬁcation key is an indistinguishability obfuscation that on input a message and signature
pair, veriﬁes that the signature is the correct output of the PRF on the message. One signiﬁcant limitation
of this scheme is that it only satisﬁes unforgettability against a selective attacker. In this notion of security,
the attack algorithm is forced to select the message M∗ it will attempt to forge on at the beginning of the
security game, before seeing the veriﬁcation key and before he gets to query for signatures on other messages.
We are therefore interested in designing signature systems to accommodate stronger attacks on security
- in particular the standard notion of security where that attacker can adaptively choose which message
it will forge on. To construct a signature scheme satisfying this notion of security, we employ the preﬁx-
guessing technique of Hohenberger-Waters [HW09]. Here the signature scheme challenger uses the list of
pre-committed message queries to guess the shortest diﬀering preﬁx between these messages and the forgery.
This preﬁx is used to embed a challenge in the veriﬁcation key, which a successful forger must answer with
noticeable probability. We note that this “preﬁx technique” has been successfully employed in other contexts
[CHKP10, BSW11, FS12, MP12, CK12, BHJ+14, Seo14].
The Hohenberger-Waters technique gives a technique to build a scheme against an attacker that adap-
tively chooses the forged message, but where the signature queries must be declared before seeing the
veriﬁcation key.
In [HW09] they transform this notion into a fully adaptive secure scheme by using the
well-known technique of applying a chameleon hash [KR00] to the message before running the base signa-
ture scheme. Here we wish to avoid this transformation ﬁrstly to meet the goal of constructing fully secure
signatures using purely obfuscation-based techniques and secondly to keep signing costs low compared to
deployed signature schemes such as EC-DSA, necessitates avoiding discrete-log based systems.
To achieve adaptive security from the preﬁx-embedded scheme, we do something akin1 to publishing a
signature tag t and building a one-time signature using the tag t as the verifcation key for the message. This
part of the signature is secure provided that no tag t is ever re-used more than once. We can then sign
1Our construction uses the primitive a little diﬀerently. In a standard one-time signature scheme, anyone can generate a
veriﬁcation key and sign with the corresponding private key. In our scheme some secret information is needed even to sign with
tag t.
2
the tag with the preﬁx-guessing scheme, generating a second signature part. The structure of our signature
scheme is such that we can xor these parts together, with a suitable modiﬁcation to the veriﬁcaion circuit.
Our construction in a nutshell We now describe the main two pieces of our construction. Firstly we
construct a one-time like signature scheme as follows. We generate a tag t of λ bits. Our ﬁrst “signature
piece” is s1 = ⊕l
i=1F1(K1, t(cid:107)i(cid:107)M(i)), where F1(K1,·) is a puncturable PRF with appropriate input length.
Our veriﬁcation key is an obfuscated circuit that on input (M, (t, s1)) checks that s1 is of the above form.
The security property is that an adversary on seeing a signature for a message M that uses tag t, cannot
construct a signature on M∗ (cid:54)= M, that uses the same tag t. To argue security, we use a Lamport-like
proof. If M∗ (cid:54)= M then there exists some index ˆi where M∗(ˆi) (cid:54)= M(ˆi). Let bit ˆb = M∗(ˆi). The reduction
algorithm can guess the position ˆi and bit ˆb = M∗(ˆi) with noticeable probability. The reduction ﬁrst
punctures K1 on τ = t(cid:107)ˆi(cid:107)ˆb. Then it evaluates an injective one way function evaluated on the punctured
value F1(K1, τ), yielding an image z. This image is embedded inside the veriﬁcation key, VK, and is used
to test validity of message M∗, while the punctured key can still be used to verify all other messages. VK is
sent to the adversary. Now suppose an adversary produces a valid forgery (t, s∗
1). The reduction can extract
1 ⊕i(cid:54)=ˆi F1(K1{τ}, t(cid:107)i(cid:107)M∗(i)), yielding a pre-image of z. This breaks the security
the punctured value as s∗
guarantee of the one way function.
Our second piece is the ability to sign the tag t according to the [HW09] preﬁx-guessing technique. To
sign a tag t, a puncturable PRF F2,i(K2,i,·) is evaluated on every preﬁx. Here F2,i for i = 1, . . . , (cid:96) takes in
inputs of i bits. The signature piece is thus s2 = ⊕λ
i=1F2,i(K2,i, t(i)), where the length-i preﬁx of t is denoted
t(i). A veriﬁcation key is an obfuscated circuit that on input (t, s2), checks that s2 is of the above form.
The security property is as follows. The attacker commits to a list of tags (tj)q
j=1. The challenger sends
veriﬁcation key VK, as well as signatures (σj)q
j=1 corresponding to the above tags. The attacker should not
be able to construct a signature on a tag t∗ not contained in the queried list. We argue security as follows.
Since t∗ is distinct from all queried tags, there exists some tag tj(cid:48) and index i(cid:48) such that t∗ and tj(cid:48) agree on
the ﬁrst i(cid:48) − 1 bits, diﬀering at the i(cid:48)th bit. The reduction algorithm guesses the tag tj(cid:48) and index i(cid:48). The
reduction punctures K2,i(cid:48) on the diﬀering preﬁx p and generates an equivalent veriﬁcation circuit, using an
injective one way function is to hide the punctured value F2,i(cid:48)(K2,i(cid:48), p). This image is embedded inside the
veriﬁcation key, VK, which is sent to the adversary. Suppose the adversary now submits a valid forgery s∗
2.
2 ⊕i(cid:54)=i(cid:48) F2,i(K2,i, t(i)), again breaking the one way function.
The reduction extracts the punctured value as s∗
Our complete scheme merges these two ideas to generate concise signatures. The signatures s1 and s2
are xor-ed together yielding a single signature s. The complete signature is thus (t, s). The veriﬁcation
circuit on input (M, (t, s)) computes s1 = ⊕l
i=1F2,i(K2,i, t(i)) and checks
that s = s1⊕s2. In the proof of security, the reduction will deal with the case that a forgery tag t is repeated,
or not, separately.
i=1F1(K1, t(cid:107)i(cid:107)M(i)) and s2 = ⊕λ
Fast Signing While the scheme above achieves our goal of getting short signatures that are fully secure,
it does not meet our goal of getting fast signing. The primarily culprit is that in the generation of the
second signature piece, (cid:96) diﬀerent punctured PRF systems must be evaluated leading to a O((cid:96)2) calls to the
underlying psuedorandom generator when using current constructions based on GGM [GGM86] trees.
We address this problem by giving a slightly modiﬁed second construction. The primary change is that
instead of using (cid:96) diﬀerent punctured PRF systems, each with a diﬀerent domain size, we will use one
punctured PRF with a variable length domain {0, 1}1≤i≤(cid:96). That is the input to the function can be a string
of any length up to (cid:96). We can then plug this into our main construction.
At ﬁrst glance it might seem that this modiﬁcation brings us nothing since the construction still needs
to XOR together (cid:96) diﬀerent PRF values. However, as we will show that it is possible to create a variable
length punctured PRF where the cost of evaluating the PRF on all preﬁxes of an (cid:96) bit message M is the
same as computing the GGM tree once on M. The main modiﬁcation is that, following Goldreich [Gol06],
we now need a length tripling PRG G : {0, 1}λ → {0, 1}3·λ that goes from λ bits to 3 · λ bits. In practice,
this will likely consume more computation per pseudo random generator invocation call more than using a
length doubling one, but in total should result in signiﬁcantly faster signatures than the prior approach.
3
Evaluation We evaluate the cost of the selectively secure Sahai-Waters scheme and our adaptively secure
scheme in terms of the cost of the underlying PRGs used by the puncturable PRFs. We compute concrete
signing costs at the 128-bit security level using a several cryptographic hash functions and ciphers to instan-
tiate the PRGs. These costs are compared to the RSA and EC-DSA signature schemes at the same security
level.
For appropriate choices of the underlying PRG, our adaptively secure construction is signiﬁcantly faster
than EC-DSA. For example, at the 128-bit level, the EC-DSA algorithm takes 348 microseconds. When the
ChaCha stream cipher is used to instantiate the PRGs, the selectively secure Sahai-Waters scheme takes
25 microseconds and the adaptively secure scheme takes 81 microseconds. Timings were performed on a
quad-core Intel Xeon E3-1270 v2 workstation with 16Gb RAM, clocked @3.50GHz.
2 Signature Scheme Preliminaries
A signature scheme is a tuple of PPT algorithms:
Setup(1λ) The setup algorithm outputs a pair (VK, SK) where VK is the veriﬁcation key and SK is the
secret key.
Sign(SK, M) The signing algorithm takes in secret key SK and message M ∈ M and outputs a signature
σ.
Verify(VK, M, σ) The veriﬁcation algorithm takes in a veriﬁcation key VK, a message M and a claimed
signature σ. The algorithm returns 1 if the signature is valid and ⊥ otherwise.
Correctness ∀M ∈ M Pr[Verify(VK, M, Sign(SK, M)) = 1 : (VK, SK) ← Setup(1λ)] = 1 − negl(λ)
In what follows will assume M is an l-bit message space.
2.1 Unforgeability against Adaptive Attacks
We extend the above notion of a secure signature scheme to accommodate adaptive attacks, according to
the formalization by Goldwasser, Micali and Rivest [GMR88]. Here an attacker may adaptively make an
arbitrary (polynomial) number of signature queries on messages, even after it has received the veriﬁcation
key. The attacker must then output a message on which it did not receive a signature, and a valid signature