layer, then the buffer of the network layer, and then the buffer
of the data link layer. In each layer, new packet headers are
added. Eventually, the entire network packet is stored in a
data structure called sk_buff. Finally, the kernel will call
dev->hard_start_xmit to transfer the data in sk_buff to
the device driver, where Bp is located.
Both Ppriv and the address of sk_buff, Psk, should be found
in the faulting addresses sequence . It is
because the memory pages that store the private memory
buffer Bp and sk_buff are not otherwise used during the
process of sending network packets. The adversary could
combine page offsets, page frame numbers, the page-fault
error code, and the number of page faults between the two
page faults of Bp and sk_buff to create a signature, which
can be used to ﬁnd Ppriv. For example, the page-fault error
code of Bp is 0b110 and the page-fault error code of sk_buff
is 0b100; the page offset of Ppriv is usually 0x0fa or 0x8fa and
the offset of sk_buff usually ends with 0xe8 or 0x00; and the
number of page faults between Bp and sk_buff is roughly 20.
With these signatures, the adversary can identify Ppriv from
the sequence of faulting addresses. Of course, the signature
may change from one OS version to another, or change with
different OS kernel. However, because the adversary controls
the hypervisor, such information can be re-trained ofﬂine,
before performing the attacks.
It was indicated by AMD researchers (during an ofﬂine
discussion) that SEV-ES should mask the page offset infor-
mation when there is a VMEXIT. However, we were not able
to ﬁnd related public documentation. Moreover, as the KVM
patch for SEV-ES support is not yet available at the time of
writing, we were not able to validate the claim or estimate
the remaining leakage (e.g., error code, page offset) after the
patch. However, regardless of the hardware changes, a coarse-
grained page-fault side channel in which the page frame num-
ber of the faulting address is leaked must remain. To show
that the demonstrated attack still works, we conducted experi-
ments to perform pattern matching without page fault offsets
and error code information. Speciﬁcally, we performed pat-
Figure 4: Format of an SSH packet.
tern matching using only the faulting page numbers, with
the guest VM running different Ubuntu versions (e.g., 18.04,
18.04.1 and 19.04) and different kernel versions (4.15.0-20-
generic, 4.15.0-48-generic and 5.0.0-13-generic). The results
show that after training in one virtual machine, the pattern
matching rules can work well even in different virtual ma-
chines with the same Ubuntu version and kernel version—the
attacker is still able to successfully identify the page frame
number of Ppriv. To determine the complete address of Ppriv,
the attacker could determine the offset by scanning the en-
tire memory page and looking for content changes (e.g., in a
90-byte buffer).
3.3.3 Replacing Ciphertext
After determining Ppriv, the adversary replaces aligned SSH
header in Bp with the ciphertext he or she chooses to decrypt.
As shown in Figure 4, the packet headers include a 6-byte
destination address, a 6-byte source address, a 2-byte IP type
(e.g., IPv4 or IPv6), 1-byte IP version and IP header length,
1-byte of differentiated services ﬁeld, 2-byte packet length,
2-byte identiﬁcation, 2-byte of IP ﬂags, 1-byte time-to-live,
1-byte protocol type, 2-byte checksum, and 4-byte source IP
address and 4-byte destination address, and 20-bytes TCP
headers (start with 2-byte source port and 2-byte destination
port).
As shown in Figure 4, Ppriv has the offset address ending
with 0xfa. Because SEV encrypts data in 16-byte aligned
blocks, only part of the TCP/IP header (i.e., header in gray
blocks in Figure 4) can be used to decrypt ciphertext. Addi-
tional constraints apply if the packet needs to be recovered
later. Before replacing the packet header with the chosen
ciphertext, the adversary performs a WBINVD instruction to
ﬂush the guest VM’s cached copy of Bp back to memory. It
is because cache coherence is not maintained by the hard-
ware between cache lines with different ASIDs. To make sure
the guest VM’s copy does not overwrite our changes to the
memory, WBINVD instruction needs to be called ﬁrst.
The ciphertext replacement takes place before memcpy, af-
ter Bp is accessed and before Bs is accessed. Bs is located
inside the SWIOTLB pool, which is the next available address
within SWIOTLB that can be used by the guest. After replacing
a few blocks in Bp, another WBINVD instruction is performed
to ensure the guest VM reads and decrypts up-to-date cipher-
USENIX Association
28th USENIX Security Symposium    1263
text in memory. All replacement operation is achieved by
IOremap instead of Kmap, since Kmap decrypts data with the
hypervisor’s key ﬁrst and IOremap directly operates data in
the memory without decryption.
We use the following example to illustrate the attack. Let
the ciphertext c be a 16-byte aligned memory block with
the gPA of Pc. The function which can translate gPA to hPA
is called hPA(). The goal of the attack is to decrypt c. The
adversary replaces a 16-byte data in the SSH header that
begins with address (Ppriv + 16)/16 ∗ 16 with c. After the
data in Bp is copied to Bs, the adversary could read the de-
crypted SSH packet and extract the plaintext of decrypted
memory block, d, from the corresponding location of the
packet. However, d is not the plaintext of c yet, as SEV’s mem-
ory encryption involves a tweak function T (). That is, c =
EKvek (m ⊕ T (hPA(Pc))) but d = DKvek (c) ⊕ T (hPA((Ppriv +
16))/16∗ 16). Therefore, the plaintext message m of cipher-
text c can be calculated by m = d⊕T (hPA((Ppriv +16))/16∗
16)⊕ T (hPA(Pc)).
3.3.4 Packets Recovery
To make the attack stealthy, the adversary needs to recover
the network packet with decrypted data before those packets
are passed to the physical NIC device. As shown in Figure 4,
the SSH header also contains metadata of the packet. When
the malicious hypervisor injects chosen ciphertext into the
memory block with offset = 0x100, the adversary only needs
to be concerned about a portion of the source IP address, IP
protocol type, IP tags, TCP header length, and the identiﬁca-
tion of the packet. Majority of the ﬁelds are determined. The
identiﬁcation of the IP packet increases by 1 every time SSH
server replies a packet. So when hypervisor tries to recovery
the (plaintext) packet from the QEMU side, it only need to
correct the packet length, increase identiﬁcation by 1 and copy
the remaining portion from previous packet such as source
address, header length, time to live and protocol number.
3.4 Encryption Oracle
We next show the construction of a memory encryption ora-
cle using unprotected I/O operations. The encryption oracle
stealthily encrypts a chosen plaintext message using a guest
VM’s memory encryption key Kvek. Similar to the construc-
tion of the decryption oracle, during the DMA operation of
the guest that transfers data from the device to the encrypted
memory, the adversary changes the message m in the shared
memory buffer Bs, waits until it is copied to the private buffer
Bp in the encrypted page, and then extracts the corresponding
ciphertext Ekg(m) from Bp.
To determine the gPA address of Bp and retrieve the cipher-
text of the plaintext message at address Pt, the steps shown in
Figure 5 are taken. Again, we leverage the ﬁne-grained page-
fault side channel we used in the previous section. Speciﬁcally,
Figure 5: An encryption oracle. Step , QEMU forwards an
incoming packet to the guest. Step , QEMU passes the ad-
dress of Bs to the hypervisor. Step , a page fault immediately
after the fault at Bs is captured by the page fault handler. Step
, message m(cid:48) is placed in Bp. Step , page fault handler
returns the control to the guest.
we modiﬁed all memory pages’ PTEs right after the QEMU
ﬁnishes writing the packet into SWIOTLB and before the
QEMU notifying guest VM about the DMA write. Then, when
the guest VM performs a memcpy operation to copy the data,
the adversary will observe a sequence of page faults: , where Pshare is the address of Bs and Ppriv is the ad-
dress of Bp. The page fault at Ppriv will take place right after
the page fault at Pshare. When the hypervisor handles the page
fault at Ppriv, it replaces the 16-byte aligned data block with
the message m(cid:48), where m(cid:48) = m⊕T (hPA(Ppriv))⊕T (hPA(Pt )),
where Pt is the gPA of the target address to which the adver-
sary wishes to copy m. The corresponding ciphertext will be
c = Ekg(m⊕ T (hPA(Pt ))), which can be used to replace the
ciphertext at address Pt.
The encryption oracle can be typically exploited to inject
code or data into the SEV-enabled VM’s encrypted memory,
or it can be used to make guesses of the memory content
by providing a probable plaintext. We note that to use the
encryption oracle, the adversary may simply generate mean-
ingless packets and send them to the guest VM, which will
be discarded. But the oracle can still be constructed and used.
The only downside of this approach is that the guest VM will
observe large volume of meaningless network trafﬁc and may
become suspicious of attacks.
4 Evaluation
We implemented our attacks on a blade server with an 8-
Core AMD EPYC 7251 Processor, which has SEV enabled
on the chipset. The host OS runs Ubuntu 64-bit 18.04 with
1264    28th USENIX Security Symposium
USENIX Association
Linux kernel v4.17 (KVM hardware-assisted virtualization
supported since v4.16) and the guest OS also runs Ubuntu
64-bit 18.04 with Linux kernel v4.15 (SEV supported since
v4.15). The QEMU version used was QEMU 2.12. The SEV-
enabled guest VMs were conﬁgured with 1 virtual CPU, 30GB
disk storage, and 2GB DRAM. The OpenSSH server was
installed from the default package archives.
4.1 Pattern Matching
We ﬁrst evaluate the pattern matching algorithm’s accuracy of
determining Ppriv. To obtain the ground truth, we modiﬁed the
guest kernel to log the gPA address of sk_buff, the source
gPA and destination gPA of memcpy, as well as the size of
each DMA read or write. All the data was recorded in the
kernel debug information, which can be retrieved using a
Linux command dmesg.
The experiments were conducted as follows: We ran a
software program AnJian [13] (an automated keystroke gener-
ation tool) on a remote machine, which opened a terminal that
was remotely connected to the SEV-enable VM through an
SSH communication channel. AnJian automatically typed on
the SSH terminal two Linux commands cat security.txt
|grep sev and dmesg at the rate of 10 keystrokes per second.
This was used to simulate the remote owner controlling the
SEV-enabled VM through SSH. The adversary would make
use of the generated SSH packets to perform memory decryp-
tion. The dmesg command also retrieved the kernel debug
message that recorded the ground truth.
At the same time, the pattern matching was performed by
the adversary on the hypervisor side. The page-fault side-
channel analysis was conducted upon receiving every incom-
ing SSH packet to guess the address Ppriv. There were three
outcomes of the guesses: a correct guess, an incorrect guess,
and unable to make a guess. Because there were 33 keystrokes
generated by AnJian, the adversary was allowed to guess Ppriv
for 33 times in each experiment. The experiments were con-
ducted 20 times.
Figure 6 shows the precision and recall of these 20 rounds
of experiments. Precision is deﬁned as the ratio of the number
of correct guesses and the number of times that a guess can be
made. Recall is deﬁned as the ratio of the number of correct
guesses and the number of total SSH packets. The average
precision is 0.956, the average recall is 0.847 and the average
F1 Score is 0.897.
4.2 Persistent Bp
According to our experiments, the Bp will remain unchanged
and reused for multiple network packets. This greatly helps
the adversary, either by performing pattern matching once
and reusing the same Bp directly in subsequent packets, or by
improving the accuracy of the guesses.
Figure 6: The precision and recall of determining Ppriv in 20
rounds or experiments.
Figure 7: Reduction of incorrect guesses using the N-Streak
strategy.
Improving attack ﬁdelity using persistent Bp. The persis-
tent Bp can be used to reduce the number of incorrect guesses.
During a real-world attack, when Ppriv is incorrectly guessed,
the ciphertext replacement may crash the guest VM (although
we have not experienced any crashes in our experiments). As
such, a safer strategy of when to perform ciphertext replace-
ment is only after correctly guessing Ppriv N times in a streak,
which we call the N-streak strategy. We then applied this
strategy to Round 20, 6 and 11, which have the highest FPR
(i.e., 0.167, 0.133, 0.103, respectively). As shown in Figure 7,
when by increasing N (i.e., 1, 2, 3), the number of incorrectly
performed ciphertext replacement is reduced.
Packet rate vs. Bp persistence. We further evaluated the ef-
fect of Bp persistence when the rate of SSH packets varies.
Again, on the remote machine, we used AnJian to generate
keystrokes at a ﬁxed rate, ranging from 0.5 keystrokes per
second, to 20 keystrokes per second. The rate of SSH ac-
knowledgement packets is close to the keystroke rate. For
each keystroke rate, 500 keystrokes were generated and the
number of different Bps were reported in Figure 8. We can
see that as the packet rate increases, fewer number of Bps will
be used to send SSH packets. We repeated this experiment
and collected over 200 different Bps after generating 5000
keystrokes with rates ranging from 0.5 to 20 per second. The
statistics of the repeated use of Bps are shown in Figure 9.
I/O Performance Degradation
4.3
Conducting page-fault based side-channel analysis to guess
Ppriv and performing ciphertext replacement will slow down
USENIX Association
28th USENIX Security Symposium    1265
1234567891011121314151617181920Round0.00.20.40.60.81.0RecallPrecision1 packet2 packets3 packets01234Number of Wrong GuessesRound 20Round 6Round 11(a) 0.5pps
(b) 1pps
(c) 2pps
(d) 5pps
(e) 10pps
(f) 20pps
Figure 8: The number of different Bps used with various rates of packets (pps).
in total 1,000 keystrokes were generated during the tests. We
can see from the ﬁgure, the average SSH response latency
without attack is 2.5ms and the median is 0.99ms. The aver-
age latency for SSH connection under a Bp-persistent strategy
is 6.81ms and the median is 2.4ms. The average latency for
SSH connection under a guess-every-time strategy is 8.0ms
and the median is 8.7ms. Because the typical network latency
of cloud servers are 40-60ms within US and more than 100ms
worldwide [5], it is very difﬁcult for the VM owners to detect
the latency caused by the attacks.
Figure 9: Statistics of repeated Bps.
the I/O operations of the guest VM. To evaluate the degree of
performance degradation, we evaluate the SSH response time
on the server side during the attacks. The SSH response time
measures the time interval between the QEMU receives an
incoming SSH packet to the time that an SSH response packet
is sent to QEMU. Note the measurements do not include
network latency.
Figure 10 shows the SSH response time under three con-
ditions: Original (not under attack), Bp Persistent (assuming
Bp does not change) , and Guess Every Time (assuming Bp
changes and making guesses every time). The keystroke rate
used in the experiments were 10 keystrokes per second, and
4.4 An End-to-End Attack
We conducted an end-to-end attack in which the adversary
decrypts a 4KB memory page that is encrypted with the guest
VM’s Kvek. The attack assumes a network trafﬁc with the rate
of 10 pps, which is simulated using the same method used in
the previous sections. Table 2 shows the number of packets
and time used to complete the attack, when one or two 16-byte
aligned blocks were exploited for the data decryption. We can
see that in the four trials we conducted, roughly 300 packets
are needed to decrypt the 4KB page, which takes about 40
seconds. The speed of the attack doubles if the ﬁrst two blocks
of the packets were used to decrypt data.
1266    28th USENIX Security Symposium