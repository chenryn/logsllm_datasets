title:Detecting stealthy malware with inter-structure and imported signatures
author:Bin Liang and
Wei You and
Wenchang Shi and
Zhaohui Liang
Detecting Stealthy Malware with Inter-Structure and
Imported Signatures
Bin Liang1;2
Wei You1;2
Wenchang Shi1;2
Zhaohui Liang1;2
1Key Laboratory of Data Engineering and Knowledge Engineering (Renmin University of China), MOE,
2School of Information, Renmin University of China, Beijing 100872, P.R.China
{liangb, youwei, wenchang, lzh}@ruc.edu.cn
Beijing 100872, P.R. China
ABSTRACT
Recent years have witnessed an increasing threat from kernel
rootkits. A common feature of such attack is hiding mali-
cious objects to conceal their presence, including processes,
sockets, and kernel modules. Scanning memory with object
signatures to detect the stealthy rootkit has been proven to
be a powerful approach only when it is hard for adversaries
to evade. However, it is di(cid:14)cult, if not impossible, to select
(cid:12)elds from a single data structure as robust signatures with
traditional techniques. In this paper, we propose the con-
cepts of inter-structure signature and imported signature,
and present techniques to detect stealthy malware based
on these concepts. The key idea is to use cross-reference
relationships of multiple data structures as signatures to
detect stealthy malware, and to import some extra infor-
mation into regions attached to target data structures as
signatures. We have inferred four invariants as signatures
to detect hidden processes, sockets, and kernel modules in
Linux respectively and implemented a prototype detection
system called DeepScanner. Meanwhile, we have also devel-
oped a hypervisor-based monitor to protect imported signa-
tures. Our experimental result shows that our DeepScanner
can e(cid:11)ectively and e(cid:14)ciently detect stealthy objects hidden
by seven real-world rootkits without any false positives and
false negatives, and an adversary can hardly evade Deep-
Scanner if he/she does not break the normal functions of
target objects and the system.
Categories and Subject Descriptors
D.4.6 [Operating System]: Security and Protection
General Terms
Design, Security
Keywords
Rootkit, Signature, Malware Detection
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ASIACCS ’11, March 22–24, 2011, Hong Kong, China.
Copyright 2011 ACM 978-1-4503-0564-8/11/03 ...$10.00.
217
1.
INTRODUCTION
Kernel mode rootkits have been proven to be a signi(cid:12)cant
threat to computer security. They hide some system object-
s such as processes, sockets and kernel modules to conceal
their presence on a victim host. The usual stealth techniques
employed by rootkits include Kernel Object Hooking (KO-
H) and Direct Kernel Object Manipulation (DKOM). KO-
H rootkits hijack kernel control (cid:13)ow while DKOM rootkits
directly modify kernel data objects. For example, the hp
rootkit unlinks the target process from the task list main-
tained by Linux kernel to prevent it from being discovered
with utility ps.
One way to detect hidden objects is to scan kernel mem-
ory with signatures to seek the data structures of processes,
sockets, and kernel modules, and compare an object list in-
ferred from these data structures with the output of the
system standard utility tools, such as ps, netstat, and lsmod.
When an object is found in the scan results but not in the
output of utility tools, it means that a possible stealthy mal-
ware is detected. Some detection tools and forensic anal-
ysis tools have been implemented to scan kernel memory
using signatures to detect hidden objects [3][8][9][21][23].
Signature-based scanning can be used in online and o(cid:15)ine
forensic.
The signature-based scan method can only be e(cid:11)ective if it
is di(cid:14)cult for adversaries to evade. Unfortunately, some sig-
natures employed by detection tools can easily be evaded by
modifying some (cid:12)elds of object data structures. For exam-
ple, a signature used by KSTAT [3] to detect hidden kernel
modules is that the value of the (cid:12)rst 4 bytes of the target
memory area (the size of struct (cid:12)eld of module structure) is
equal to the size of the module data structure. Adversaries
can set the value of size of struct (cid:12)eld to another value (e.g.,
setting it to zero), to conceal rootkit LKM (Loadable Kernel
Module) from KSTAT detection. Furthermore, the value of
this (cid:12)eld is irrelevant to the operations of LKMs, the code
and data of a hidden kernel module can be still correctly
accessed after modifying size of struct (cid:12)eld.
A natural question is that which (cid:12)elds of a target data
structure can be used as scanning signatures to e(cid:11)ective-
ly detect stealthy malware and di(cid:14)cult to be evaded. The
(cid:12)elds chosen as signatures should correlate closely to the sys-
tem operations. Any attempting to modify these values will
lead functions of objects to fail or the operating system to
crash. Thus, adversaries will not want to modify these (cid:12)elds
to avoid losing the control of hidden objects or the victim
system. Take the processes as an example, process hiding
is a common feature of kernel rootkits, a kernel rootkit may
be employed to hide the presence of a wide variety of user-
space malware. With regards to this, Dolan-Gavitt et al.
[12] proposed an automated fuzzing technique for generat-
ing robust signatures for kernel data structures of processes
in Windows. Some constraints are found for robust signa-
tures in the EPROCESS data structure. They can be used
by a scanner to detect hidden processes. However, there stil-
l are two obstacles to obtaining robust signatures for some
security-critical kernel data structures.
First, the (cid:12)elds relevant to the correct operations of a
target kernel data structure may not be able to act as signa-
tures because it is di(cid:14)cult to distinguish the target kernel
structure from memory based on these (cid:12)elds. For example,
the socket data structure in Linux kernel has several pointer
(cid:12)elds, such as ops and (cid:12)le. Modifying these (cid:12)elds will result
in communication failure of sockets. But these (cid:12)elds point to
some dynamic memory areas rather than hold speci(cid:12)c con-
stants. It is impossible to accurately (cid:12)nd socket structures
by scanning based on these (cid:12)elds.
Second, all (cid:12)elds of structures of some passive kernel ob-
jects are hardly relevant to system operations. The opera-
tions of system and objects still are normal even after mod-
ifying them arbitrarily. For example, the main purpose of
the Linux kernel module data structure is providing some
operation handles and information for unloading LKM. Ac-
cording to our experiments, the codes imported by an LKM
still execute correctly even after setting all (cid:12)elds of its mod-
ule structure to zero or any other arbitrary value.
An elaborate scanner should/can discover the hidden sock-
ets and kernel modules and resist possible evasion tech-
niques. The above discussion shows that it is di(cid:14)cult to
use (cid:12)elds limited in a single kernel data structure (intra-
structure) as scan signatures to detect hidden objects when
facing skilled adversaries. However, traditional approaches
generate signatures commonly from the intra-structure view
and cannot provide e(cid:11)ective detection capability to some
critical kernel objects, such as sockets and kernel modules.
To address the above challenges, we propose the concept-
s of inter-structure signature and imported signature and
present an approach to detect stealthy malware based on
them. The key idea is to use the cross-reference relation-
ships of target data structure and other related data struc-
tures as signatures to detect the hidden objects mentioned
in the (cid:12)rst obstacle, and to import some extra information
into regions attached to target data structures as signatures
to detect the hidden objects mentioned in the second obsta-
cle. According to these concepts, we can either infer some
invariants from multiple related data structures or introduce
new invariants as robust signatures. With these signatures,
a scanner can e(cid:11)ectively detect some stealthy malware that
can hardly be discovered with prior techniques. In this pa-
per, we construct four invariants to detect hidden process,
socket, and kernel module in Linux. One of them is derived
from some imported information in the text section of k-
ernel module to reverse search module structures; the other
three re(cid:13)ect some cross-reference relationships of task struct,
socket, and related data structures to recognize process and
socket objects respectively.
It is important to note that the imported signatures should
be protected to prevent attacker modifying them to evade
scanning. The hardware only provides page-level protection.
But Linux doesn’t page-align the sections of a kernel module
and cannot set appropriate page access permissions to them
when loading modules. Consequently, the text section of a
kernel module is still writeable. More seriously, even after
setting the text section to read-only, a kernel mode rootkit
can reset it to writeable and modify its content. To protect
the imported signatures, we add a new page, called signature
page, to store the tag data and protect it by a monitor in
a virtual machine hypervisor XEN [7]. The signature page
will be allocated as the (cid:12)rst page of text section and be set
to read-only. Any attempts to modify its access permissions
will be trapped into hypervisor, and the monitor will deny
the requests to set access permissions of signature pages.
A prototype system called DeepScanner is implemented
to detect stealthy malware in Linux. The essential function
of DeepScanner is enumerating all processes, sockets and k-
ernel modules in the system by using above four invariants
as signatures to scan kernel memory. Our experiments show
that DeepScanner can e(cid:11)ectively detect all stealthy process-
es, sockets, and kernel modules hidden by real-world rootkits
without false positives or false negatives. Besides, we also
implement an experiment rootkit to imitate evasion attack-
s by modifying the (cid:12)elds related to signatures. Our works
demonstrate that rootkits cannot evade DeepScanner with-
out breaking the normal functions of target objects and the
operating system.
The rest of this paper is organized as follows. Section 2
describes related works. Section 3 presents the concepts of
inter-structure and imported signatures. Section 4 describes
the implementation of prototype system. Section 5 presents
the experiments. Section 6 discusses the limitations and
future work, and Section 7 concludes this paper.
2. RELATED WORKS
Recently, a large number of studies pay much attention to
the detection of rootkits. Since almost all rootkits possess
the nature of hiding themselves, it is a reasonable way to
detect them by digging the hidden objects. The cross-view
based detection is a simple but valid technique which de-
tects hidden entities via comparing the di(cid:11)erences between
untrusted view collecting from high-level and trusted view
collecting from low-level. This notion is initially proposed
by Wang et al. in their Strider GhostBuster system [25].
The key factor and primary di(cid:14)culty of this method is the
way to get the trusted view. Several approaches have been
proposed to address it. For example, Klister [20] collects all
existing processes from scheduler’s thread list rather than
the system-wide process list. Petroni et al. [17] put forward
an architecture which check the semantic integrity violations
between the All-Tasks linked-list and Running-Tasks linked-
list in Linux. But unfortunately, an evasion for this kind of
detection has been demonstrated, which bypasses detection
via replacing the OS scheduler with a modi(cid:12)ed copy [1].
Another attempt to obtain the trusted view is memory
searching. Due to the fact that every entity has its correl-
ative kernel data structure maintained by operating system
which indicates its existence, it is a feasible way to (cid:12)nd all
existing entities via locating them in memory with the fea-
tures of speci(cid:12)c data structures. Such kinds of kernel mem-
ory scanning tools have been proposed by some researchers
[3][8][9][21][23]. However, the signatures used by these tools
are almost brittle and non-essential that making them easy
to be evaded, even by simply modifying some bits of the
data structure without preventing the entity from working
correctly [24].
218
Dolan-Gavitt et al.
[12] developed a novel method for
systematically selecting features from a kernel data struc-
ture that can be used to create robust signatures with the
support of fuzzing technique. Attempts to evade this kind
of signatures by modifying the data structure contents will
cause the OS to consider the object invalid. Their e(cid:11)orts
show that signature based memory scanning is an e(cid:11)ective
and unfailing way, and it is possible to (cid:12)nd out some ro-
bust signatures that are infeasible for attackers to modify.
However, selecting candidate signatures is limited in a single
data structure in their method, such as "value equals X" or
"value is between X and Y". Consequently, this method can-
not discover the inter-structure features as signatures which
are proven to be indispensable to detect some objects by
our research. Based on our observations and experiments in
section 3.1, we can (cid:12)nd that it is impossible to generate a
feasible robust intra-structure signature for some important
system objects, such as socket objects in Linux kernel.
Carbone et al. proposed KOP [10] which involves building
a global points-to graph for kernel memory mapping and k-
ernel integrity checking. The output of KOP’s memory anal-
ysis component is an object graph whose nodes are instances
of objects in the memory snapshot and edges are the pointers
connecting these objects. Given an object type (e.g., pro-
cess), a corresponding trusted view can be obtained from
the list of all the objects of that type found by KOP in a
memory snapshot. However, this method requires that data
structure instances be reachable starting from the root(s) of
the graph. The path from root(s) to target objects may be
cut by adversaries without breaking the normal functions
of target objects.
In a latest research, Lin et al. devel-
oped a novel approach [16], called SigGraph, to generate
graph-based signatures by a data structure de(cid:12)nition ex-
tractor and a dynamic pro(cid:12)le. Unlike KOP, SigGraph does
not require the object reachability and hence supports brute
force memory scanning that can start at any kernel memory
address. These two methods can automatically derive some
useful information for detecting malwares by employing stat-
ic analysis technique. Compared with them, our method
is lightweight and gives special consideration to preventing
possible evasion attacks.
Baliga et al.
[6] presented an approach to automatically
detect rootkits and implemented a tool Gibraltar. Their key
idea is to externally observe the execution of the kernel dur-
ing a training period and hypothesize invariants on kernel
data structures. These invariants are used as speci(cid:12)cations
of data structure during an enforcement phase; violation of
these invariants indicates the presence of a rootkit. Howev-
er, this approach doesn’t take into account some important
attack methods of rootkits, such as hiding sockets and ker-
nel modules. Especially, due to the function-independence
of (cid:12)elds in the kernel module data structure (will be demon-
strated in section 3.2), it may be impossible to infer an in-
variant for kernel modules by observing the execution of the
kernel.
HookFinder [28] and HookMap [27] focus on identifying
and extracting hooks placed by rootkits. HookFinder per-
forms impact analysis using dynamic tainting to identify
hooks placed by a rootkit in the kernel execution paths.
HookMap uses a more elaborate method of identifying all
potential hooks in the execution path of kernel code that
is induced by the execution of Linux utility programs such
as ls, ps, and netstat in RedHat Fedora Core 5. HookMap
Figure 1: Signature-based scanning.