# x32 PEB: 获取Kernel32基地址的原理及实现
## 0x0 前言
如何在程序内部获取到自身加载的DLL的基地址是一个有趣的问题。通过研究这个问题，能够让笔者对Window的可执行程序的运行机制和底层实现(区别于高级语言实现)有更为深入的认识，与此同时该技术广泛应用于ShellCode来定位动态API地址，实践应用面较大，值得好好去分析和学习。
## 0x1 暴力搜索
32位在4G内存搜索有一定可行性，但是处理起来其实还是比较麻烦的，因为内存不可读会触发异常，需要对这些异常问题进行处理，可用性和性价比，自然顾名思义。
优化思路:缩小范围、增大搜索步长。
(1)不优化，原始内存特征匹配，容易出错，利用复杂。
(2)优化暴力搜索，有三种方法
### 0x1.1 方法一
只要系统没有做模块基址重定位，那么32位下`kernel32`的加载地址在`0x70000000`-`0x80000000`之间,然后Kernel32.dll加载是64k对齐的，所以查找次数
**
    #include 
    int main()
    {
        HANDLE kernelA = LoadLibrary(L"kernel32.dll");
        printf("0x:%p\n", kernelA);
        system("pause");
    }
win11:`0x76640000`
win10:`0x75710000`
win7:`0x754A0000`
window 2003:`0x7c800000`
...除开DOS系统，其它系统都可以囊括在这里面。
但是这里判断定位成功条件仍然需要采取两重判断，先判断`MZ`头再解析PE结构来获取DLL名称进行判断，从而来降低在其他环境出现地址错误的概率。
导入表与exe实际加载顺序:
`ntdll.dll`->`kernelbase.dll`->`kernel32.dll`->....
可以看到关键的系统模块都分配在了0x70000000上面，故单一匹配MZ头不是100%准确。
### 0x1.2 方法二
进一步优化搜索范围，Window加载可执行程序时，会创建可执行程序的子进程，其主线程被初始化时，执行`ExitThread`的指令的地址被压人堆栈，以便线程通过ret返回时可以执行`ExitThread`退出线程。而`ExitThread`是从`KERNEL32.DLL`中导出的函数，故可以从这个地址开始递减0x10000h来搜索"MZ"头从而确定`Kernel32.dll`的地址。
调试之前，先了解EXE点击执行的经历阶段:
1.双击exe程序，注册表的Shell键值指定`Explorer.exe`作为命令解释器，作为用户桌面应用程序的父进程来启动程序。
    计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon
2.调用`Kernel32.dll`的`CreateProcess`函数，打开其映像文件，创建一个内存区对象。
3.创建内核中的进程对象，NtCreateProcess-NtCreateProcessEx-PspCreateProcess，其中创建EPROCESS对象、初始化各种参数、创建初始的进程地址空间、创建和初始化句柄表，并设置好EPROCESS
和KPROCESS 中的各种属性，如进程优先级、安全属性等。至此进程地址空间初始化完成、EPROCESS的PEB也初始化完成。
> 该过程可参考:
4.通过调用`NtCreateThread`创建初始线程，创建ETHREAD结构、初始化域、创建TEB结构并初始化...
> 该过程可参考:
5.进程创建/退出，通知Windows子系统csrss.exe进程，以便对Windows所有进程进行管理。
6.启动初始线程，调用`NtResumeThread`唤醒，进入用户态最先执行`ntdll.dll`的`LdrInitializeThunk`函数，完成用户态进线程的环境初始化，加载DLL并执行入口函数、对"线程本地存储"(TLS)进行初始化。
> 使用x32dbg运行程序的时候,执行`LdrInitializeThunk`函数时，会在`LdrpInitializeProcess`中触发一个int
> 3异常，用来作为程序运行的"系统断点"。
>
>
> 
回到用户态之后，主线程进入`Kernel32.dll`的 `BaseThreadInitThunk`函数进入入口点函数，开始执行程序后续执行。
进入入口点之后，返回地址入栈,此时就是栈顶位置，指向了`Kernel32`内存空间。
但是真正使用的话，这种方法有非常大的局限性的，通过IDA反编译VC2019编译的exe，选定_main函数，`View`->`Graph`->查看函数调用图
在到达真正用户的入口，会存在大量编译器的包装代码，用于初始化和终止库，在将控制权转交给main函数之前正确配置相关参数，所以内联汇编是没办法使用这个方法的。
在笔者看来这个方法，确实鸡肋，利用栈上残余的地址虽然是个好思路，但是一般都具有强烈的特殊性，这种方法不适合用来做通用寻址的手段。
### 0x1.3 方法三
**1.什么是异常处理链表?**
>
> 当异常发生时，系统从fs:[0]指向的内存地址处取出ExceptionList字段，然后从ExceptionList字段指向的`_EXCEPTION_REGISTRATION_RECORD`结构中取出`handler`字段，并根据其中的地址去调用异常处理程序（回调函数）。
异常处理链表是提到的由`_EXCEPTION_REGISTRATION_RECORD`结构构成的单链表。
    typedef struct _EXCEPTION_REGISTRATION_RECORD
    {
         PEXCEPTION_REGISTRATION_RECORD Next;
         PEXCEPTION_DISPOSITION Handler;
    } EXCEPTION_REGISTRATION_RECORD, *PEXCEPTION_REGISTRATION_RECORD;
Next指向异常处理程序的地址，prev 则指向下一个
[_EXCEPTION_REGISTRATION_RECORD](https://nirsoft.net/kernel_struct/vista/EXCEPTION_REGISTRATION_RECORD.html)
结构体，来构成一个单向链表。
**2.异常处理链表有什么特点?**
当异常发生时，系统会遍历异常处理链表，直到找到正确的异常处理程序。链表最后一项的prev值为0xFFFFFFFF，说明链表已经遍历完毕。
**最后一项指向的是系统默认的位于`Kernel32.dll`的`UnhandledExceptionFilter`顶层异常处理程序的过滤函数，该过滤函数的地址是存在于`Kernel32.dll`内存空间的**
**3.查找`Kernel32.dll`加载基址**
基于上面1.2的认识，很自然可以得到一个查找`Kernel32.dll`加载基址的方法，步骤如下:
1)取fs:[0]的值即`ExceptionList`指针指向的地址赋予给`edx`寄存器
2)判断Next指针指向的值是否为`0xffffffff`计算机负数用补码表示即-1,是的话
`mov edx, [edx]`,将值传递到edx寄存器中,接着`mov
edx,[edx+4]`将`Handler`指向的值赋值给`edx`,此时edx就在`Kernel32.dll`内存空间中,然后开始逐一递减`dec
edx`来回溯PE头
    #include 
    int main()
    {
        unsigned int kernelAddr;
        __asm {
            mov edx, fs: [0] ;
        Foreach:
            cmp [edx], 0xffffffff
            je Handle; //if equal : jump   
            mov edx, [edx];
            jmp Foreach;
        Handle:
            mov edx, [edx + 4];
        _Loop:
            cmp word ptr[edx], 'ZM';
            jz Kernel;
            dec edx;
            xor dx, dx;
            jmp _Loop
         Kernel :
            mov kernelAddr, edx;
        }
        printf(TEXT("Kernel32.dll address: %x\r\n"), kernelAddr);
        printf(TEXT("LoadLibrary Kernel32.dll address: %x\r\n"),
            LoadLibrary(TEXT("kernel32.dll")));
        return 0;
    }
在WinServer 2003/XP 上这种方法是可以得到正确结果的。
不过这种方法在win7/win11都是 **不行** 的，原因是版本差异，这里获取的是`ntdll.dll`的加载地址  
造成这种差异的原因,我们可以使用Windbg查看下Win10下最终地址的指向。  
查看TEB结构:`!teb`
查看FS寄存器信息:`dg fs`  
查看fs[0]的值: `dd 009b5000`  
确定`ExceptionList`地址指向的结构地址:`00aff3d0`。
下面根据该地址查看`_EXCEPTION_REGISTRATION_RECORD`结构:
`dt -r1 ntdll!_TEB`
`dt -r1 _EXCEPTION_REGISTRATION_RECORD 0x00aff3d0`  
可以查看Win10中，最后一个过滤函数在`ntdll`的内存空间，而不是`Kernel32.dll`，故这种方法在win10是没办法使用的，win7同理。
更多可参考:
> [维基百科:Windows异常处理机制](https://zh.wikipedia.org/zh-> hans/%E7%BB%93%E6%9E%84%E5%8C%96%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86#%E4%B8%8EWindows%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E7%9A%84%E5%85%B3%E7%B3%BB)
>
> [windows的SEH异常处理以及顶层异常处理](https://www.cnblogs.com/revercc/p/13373732.html)
### 0x1.4 小结&补充
**小结**
​
从上面的三种方法来看，可以看出三者有很明显的共同缺陷，那就是除了暴力的搜索行为之外，还有个致命低兼容性，虽然可以通过进一步加强判断的条件，比如从`ntdll.dll`地址继续回溯到`Kernel32.dll`，判断PE结构的第一个函数名称等手段来优化，这种代价会进一步增大ShellCode的大小并使程序流程复杂化，同时，内存空间的访问存在很多不可意料的情况。总而言之，搜索内存的方法是一种下下之选。
**补充**
> 使用到的分析工具列表如下
>
> 调试程序:Windbg、x32dbg
>
> 辅助定位:[CFF](https://ntcore.com/files/CFF_Explorer.zip)
过程中出现的小问题:
> VS2019
> 正常编译的exe，win2003执行会提示"不是一个合法的win32应用程序"，调整编译的平台工具集(xp)可以解决该问题,同时选用静态编译(多线程MT/Release)解决依赖问题。
>
> 参考:[https://docs.microsoft.com/en-us/cpp/build/configuring-programs-for-> windows-xp?redirectedfrom=MSDN&view=msvc-160](https://docs.microsoft.com/en-> us/cpp/build/configuring-programs-for-windows-> xp?redirectedfrom=MSDN&view=msvc-160)
## 0x2 基于PEB搜索
在第一节我们提到了暴力搜索并不可取，那么有没有一种优雅地良好兼容性、精确搜索`Kernel32.dll`加载基地址的方法呢?
下面来学习一种区别暴力方法，但也比较简单且已经应用成熟的最佳方法。
### 0x2.1 TEB->PEB
前面提到了部分与TEB相关的内容，我们进一步来了解TEB与PEB的关系。
> **TEB** （Thread Environment Block，线程环境块）系统在此TEB中保存频繁使用的线程相关的数据。位于用户地址空间，在比
> PEB 所在地址低的地方。用户模式下，当前线程的TEB位于独立的4KB段(页)，可通过CPU的FS寄存器来访问该段，一般存储在[FS:0]
>
> **PEB** （Process Environment
> Block，进程环境块）存放进程信息，每个进程都有自己的PEB信息。位于用户地址空间。可在TEB结构地址偏移0x30处获得PEB的地址位置。
查看结构Windbg 命令: