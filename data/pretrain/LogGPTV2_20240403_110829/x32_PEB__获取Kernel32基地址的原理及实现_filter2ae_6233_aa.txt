# x32 PEB: 获取Kernel32基地址的原理及实现

## 0x0 前言
在程序内部获取自身加载的DLL基地址是一个有趣且具有挑战性的问题。通过研究这一问题，可以深入理解Windows可执行程序的运行机制和底层实现，并将其与高级语言实现区分开来。此外，这项技术广泛应用于ShellCode中以定位动态API地址，因此值得深入分析和学习。

## 0x1 暴力搜索方法
虽然在32位系统中对4GB内存进行搜索是可行的，但实际操作中会遇到不可读内存导致的异常等问题，处理起来较为复杂。为了提高效率，可以通过缩小搜索范围和增加搜索步长来进行优化。

### 0x1.1 方法一：基于已知加载地址范围
若系统未进行模块基址重定位，则`kernel32.dll`在32位系统中的加载地址通常位于`0x70000000`到`0x80000000`之间，并且该DLL加载时是以64KB为单位对齐的。因此，可以通过遍历此范围内的64KB边界地址并检查每个位置是否存在有效的PE头（即"MZ"签名）来确定`kernel32.dll`的确切位置。

```c
#include <windows.h>
#include <stdio.h>

int main() {
    HANDLE kernelA = LoadLibrary(L"kernel32.dll");
    printf("Loaded at: 0x%p\n", kernelA);
    system("pause");
    return 0;
}
```

不同版本的Windows可能会有不同的默认加载地址：
- Windows 11: `0x76640000`
- Windows 10: `0x75710000`
- Windows 7: `0x754A0000`
- Windows 2003: `0x7c800000`

注意，仅依靠"MZ"头部匹配可能不够准确，还需要进一步解析PE结构验证DLL名称等信息。

### 0x1.2 方法二：利用线程栈上的返回地址
当Windows创建新的进程及其主线程时，会在栈上保存一个指向`ExitThread`函数（属于`KERNEL32.DLL`）的地址。通过从这个地址开始反向搜索"MZ"头部，可以找到`KERNEL32.DLL`的位置。

但是这种方法存在局限性，尤其是在现代编译器生成的代码中，由于存在大量的初始化逻辑，使得直接使用内联汇编变得非常困难。

### 0x1.3 方法三：利用SEH链表
异常处理链表由一系列`_EXCEPTION_REGISTRATION_RECORD`结构组成，这些记录链接在一起形成单向链表。链表的最后一项通常指向`KERNEL32.DLL`中的顶层异常过滤函数`UnhandledExceptionFilter`。通过遍历这条链表直到找到最后一个元素，然后回溯其所在的内存区域，理论上能够定位到`KERNEL32.DLL`的加载地址。

然而，这种方法的有效性取决于操作系统版本。例如，在较新的Windows版本如Win7或Win10中，最终指向的是`ntdll.dll`而非`KERNEL32.DLL`，使得此方法不再适用。

### 0x1.4 小结与补充
上述三种暴力搜索方式均存在一定缺陷，包括兼容性差、可靠性低以及可能导致程序复杂度增加等问题。尽管可以通过更严格的条件判断来改进，但这将不可避免地增加ShellCode大小并使流程更加复杂。总之，对于大多数应用场景而言，这些方法都不是最优选择。

此外，在开发过程中还遇到了一些小问题，比如使用VS2019编译的程序在旧版Windows上无法正常运行，需要调整编译设置以确保兼容性。

## 0x2 基于PEB的搜索
既然暴力搜索并不理想，那么是否存在一种更为优雅且高效的方法来准确获取`KERNEL32.DLL`的加载地址呢？接下来我们将探讨一种基于TEB（Thread Environment Block）和PEB（Process Environment Block）的方法，它不仅简单而且已经被广泛应用。

### 0x2.1 TEB到PEB
首先简要介绍TEB与PEB的概念及其关系：
- **TEB** (Thread Environment Block) 存储了当前线程相关的常用数据，位于用户地址空间的一个独立页面内，可通过FS寄存器访问。
- **PEB** (Process Environment Block) 包含了整个进程的信息，同样位于用户地址空间。每个线程的TEB中都包含一个指向相应PEB的指针，偏移量通常是0x30字节。

通过访问当前线程的TEB并从中提取PEB指针，进而可以从PEB结构中获得`KERNEL32.DLL`的加载地址等重要信息。这为我们提供了一种简洁而强大的手段来解决最初提出的问题。