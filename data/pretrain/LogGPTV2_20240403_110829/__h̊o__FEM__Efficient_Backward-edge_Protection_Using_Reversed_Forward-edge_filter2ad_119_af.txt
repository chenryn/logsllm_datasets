T
L
ρ F E
Benchmark
500.perlbench_r
-0.91%
505.mcf_r
0.00%
520.omnetpp_r
0.37%
523.xalancbmk_r
2.05%
525.x264_r
0.54%
531.deepsjeng_r
1.47%
541.leela_r
0.79%
557.xz_r
-0.11%
508.namd_r
0.78%
511.povray_r
4.52%
519.lbm_r
0.00%
526.blender_r
0.00%
538.imagick_r
-0.57%
600.perlbench_s
-1.14 %
605.mcf_s
0.30 %
620.omnetpp_s
3.94 %
623.xalancbmk_s
4.83 %
625.x264_s
1.17 %
631.deepsjeng_s
1.48 %
641.leela_s
0.00 %
657.xz_s
-8.74 %
0.11%
geomean
Table 7: ρFEM’s overhead w.r.t. the SPEC CPU2017.
L
ρ F E
-0.91
11.1
2.56% 11.7
-0.87% 8.02
0.00% 8.61
-4.30% 18.5
-2.94% 13.4
-0.79% 12.6
-4.58% 8.74
-1.56% 12.7
0.56% 16.9
0.00% 4.82
0.58% 17.1
-8.52% 17.7
1.42 % 3.55
5.68 % 6.67
2.89 % 3.66
2.14 % 3.55
-0.97 % 5.09
0.99 %
4
2.21 % 3.62
-8.74 % 2.24
0.85%
-
O
T
11.0
11.7
8.05
8.79
18.6
13.6
12.7
8.73
12.8
17.7
4.82
17.1
17.6
3.51
6.69
3.81
3.73
5.15
4.06
3.62
2.06
-
11.1
11.4
8.12
8.79
19.4
14.0
12.8
9.13
13.0
17.6
4.82
17.0
19.1
3.46
6.31
3.7
3.65
5.2
4.02
3.54
2.24
-
is 0.85% on average. Thus, these results support ρFEM’s competi-
tiveness.
10
8
6
4
2
d
a
e
h
r
e
v
O
e
m
i
t
n
u
R
%
Clang’s SafeStack
ρFEM & IVT
ρFEM
-j s
S
e
e
p
d
0
u
S
r
e
p i d
s
n
e
n
c t a
O
a
r
K
n
8 - b
e
k
V
n
e
k
r
h m a
c
o
a
o m e
D r
o m e t e
r
n
a
o m e
e
g
Figure 7: Comparing ρFEM, SafeStack and IVT overheads.
In addition to the SPEC CPU 2017 benchmark, we also evaluated
ρFEM with a set of popular JavaScript benchmarks for the Chrome
Web browser. Figure 7 depicts the runtime overhead of SafeStack
(shaded light gray), ρFEM + IVT (shaded gray; note IVT provides
virtual call based forward-edge protection only), and ρFEM (shaded
black) for these benchmarks. As shown in the figure, when running
ρFEM incrementally together with IVT, offering both forward-edge
and backward-edge protection, the geomean runtime overhead is
equal to that of SafeStack (4.86% vs. 4.89%). In contrast, when run-
ning ρFEM alone then the runtime ovehead is 3.44% in geomean.
Therefore, we conclude that ρFEM’s runtime overhead is negligible
and that it can be used as an always-on solution.
7 LIMITATIONS AND FUTURE WORK
Number of all function returns. Clang SafeStack’s (based on
LLVM v.3.7.0 stable) number of return addresses per callee is smaller
476ACSAC 2020, December 7–11, 2020, Austin, USA
Paul Muntean, Matthias Neumayer, Zhiqiang Lin, Gang Tan, Jens Grossklags, and Claudia Eckert
than the number of return address which ρFEM can enforce. In
future work, we want to reduce the number of return addresses
per callee. To achieve this, we first need to check availability of
gadgets for each hardened program. Additionally, we will reduce
this number by performing an analysis of provided and consumed
parameters by each callsite. This will further help to reduce the
number of callee return addresses considerably.
Attacker access to legitimate gadgets. As the number of callee
return addresses is in general larger than one, in some situations,
these addresses could still be used by an attacker to jump to a legit-
imate address, in order to access useful gadgets. In future work, we
would like to address this issue by analyzing all legitimate callee
return sites and determining if these can be used as a gadget. In case
this can be further used as a gadget then instruction level program
transformations will be made in order to make the gadget unusable.
Performing attacks with our protection in-place. The le-
gitimate number of return addresses for a callee protected by ρFEM
is low but research shows that in general attacks are still feasible.
For example, Carlini et al. [12] show that in case the attacker knows:
(1) the legitimate return address of a callee, and (2) a usable return
address to access a gadget, then an attack is still possible. In future
work, we plan to address these cases by first looking into possibil-
ities to insert another level of indirection (e.g., re-purposed register
based trampoline) (1) between callee and its return address and (2)
between callee and the return address which can be used to jump
to the beginning of a gadget.
RET instrumentation improvement. The return address is
used to access the respective return site(s), and to check IDs. This ad-
dress will be reloaded from the stack, via a ret instruction, and even-
tually consumed. As such, this scheme may suffer from TOCTTOU-
like issues, as the check can be completed successfully, but the
return address in the stack can be altered right before ret is exe-
cuted. In future work, we will address this issue by replacing ret
with pop and jmp instructions, such that the return address is not
double-fetched. Note that most of backward-edge CFI schemes do
not do this (i.e., are willing to tolerate the risk of TOCTTOU) be-
cause replacing RET with POP/JMP may greatly increase overhead.
This was the case at least on Intel CPUs a few years ago as this
would greatly influence the hardware return address prediction.
Tail calls and position independent code. Currently, ρFEM
does not support tail calls and position independent code (PIC). In
future work, we plan to address this issue by keeping track during
runtime of all function calls which have not returned and enforce
that a tail call could return to the next address of all functions which
did not return. The PIC issue can be also addressed by not using
absolute addresses and by compiling any PIC code that may be
loaded in protected programs.
Labeling of legitimate return sites. ρFEM inserts labels with IDs