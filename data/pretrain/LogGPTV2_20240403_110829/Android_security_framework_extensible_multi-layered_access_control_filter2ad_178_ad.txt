reference monitor is injected into selected app processes via
our framework at app startup. The policy decision logic
and persistent storage of policy settings was moved into
2Source code provided by the original authors
Figure 6: Cumulative frequency distribution of micro bench-
marks in stock Android (dashed line) vs. ASF (solid line).
116.182±4.550
129.851±5.681
7320
6009
Stock Android 4.3
ASF v4.3
Frequency Mean (µs)
Table 2: Weighted average performance overhead of executing
hooked functions in stock Android and in our ASF. The
margin of error is given for the 95% conﬁdence interval.
(2) a middleware module. The middlware module selects the
apps into which the IRM is injected. It also implements a
Bundle-based communication protocol to exchange policy
decisions and security events with the IRM component and
with (3) a front-end app. The front-end app allows the user
to adjust policy settings and to view logs of security-relevant
events. We used the policies included in the original App-
Guard implementation to conﬁrm that policy enforcement by
our module and by the original implementation are identical.
Our AppGuard security module consists of 5059 LoC in
total (cf. Table 1), with 782 LoC residing in the middleware
module and 4277 LoC in the IRM. Our module diverts in
18.18% of all LoC from the original code. The majority of
the diﬀerence, 728 LoC, is attributed to moving the policy
decision logic into the middleware module, while only 46
LoC were required to adapt the inlined reference monitor to
use the provided instrumentation API.
7. EVALUATION AND DISCUSSION
We evaluate the performance of our ASF and discuss its
current scope and prospective future work. An extended
evaluation is provided in the long version of this paper [2].
7.1 Performance
Although the actual performance overhead strongly de-
pends on the overhead imposed by the loaded module, we
wanted to establish a baseline for the impact of our Android
Security Framework on the system performance. The
performance of LSM has been evaluated separately, e.g., for
SEAndroid [36], and we are interested here in the eﬀect of
our new middleware security framework on the performance
of instrumented middleware system services and apps.
User-spaceKernel spaceMiddleware FrameworkMiddleware APISELinuxSELinux sysfsLSM FrameworkFlaskDroid ModulePolicyServerlibselinuxSELinux...KernelAPI40%60%80%100%02004006008001000120014001600Time (µs)Relative cumulative frequencyAndroid Security Framework (no module)Stock Android 4.3Methodology. We implemented our ASF as a modi-
ﬁcation to the Android OS code base in version 4.3_r3.1
and used the Android Linux kernel in branch android-omap-
tuna-3.0-jb-mr1.1. We performed micro-benchmarks for all
execution paths on which a hook diverts the control ﬂow to
our middleware framework: We ﬁrst measured the execution
time of each hooked function with no security module loaded
and allowing all access. Afterwards we repeated this test
with hooks removed to measure the default performance of
the same functions and thus operating identical to a stock
Android. All our micro-benchmarks were performed on a
standard Nexus 7 development tablet (Quad-core 1.51 GHz
CPU and 2GB DDR3L RAM), which we booted and then
used according to a testplan for diﬀerent daily tasks such
as browsing the Internet, sending text messages and e-mails,
contacts management, or (un-)installing 3rd party apps.
Micro-benchmark results. Table 2 presents the num-
ber of measurements for each test case and their mean values.
To eliminate extreme outliers, we excluded in both measure-
ment series the highest decile of the measurements. For
ASF the mean is the weighted mean value with consider-
ation of the frequency of each single hook. In overall, our
framework with no loaded module imposed with 129.851 µs
approximately 11.8% overhead compared to stock Android.
Figure 6 presents the relative cumulative frequency distri-
bution of our measurements series and further illustrates
this low performance overhead. Major contributor to this
overhead is the marshalling, sending, and unmarshalling of
the hooks’ parameters. Thus, a future optimization of the
baseline overhead would be a framework conﬁguration that
enables only the hooks that are actually used by the loaded
module(s) and, hence, avoids irrelevant hook invocations.
7.2 Current Scope and Future Work
System setup. Certain security models require a prepara-
tory system setup. For instance, type enforcement requires a
pre-labelling of all subjects and objects. After the system has
been setup, ASF supports modularization of these security
models (cf. Section 6.2).
Module Integrity. As part of the kernel, the Kernel
Sub-Module has the highest level of integrity. In contrast,
the Middleware Sub-Module, as a user space process,
can be circumvented or compromised by attacks against the
underlying system (e.g., root exploits) and thus requires
support by the kernel modules to prevent low-level privilege
escalation attacks. Inlined reference monitors are inherently
susceptible to attacks by malicious applications, because
the reference monitor executes in the same process as the
application that it monitors and no strong security boundary
exists between the monitor and the app code. To remedy this
situation, we are currently retroﬁtting Android’s application
model to combine the beneﬁts of inlined and of system-centric
reference monitors. By splitting apps into smaller units of
trust (e.g., app components and ad libs), system-centric
reference monitors are able to diﬀerentiate distinct trust
levels within apps [31, 38, 35].
Completeness. It is crucial for the eﬀectiveness of our
security framework, that all access to security and privacy
sensitive resources is mediated by the reference monitors.
We consider it out of scope for this submission to formally
verify the completeness of our prototype framework, but plan
to use recent advances in static and dynamic analysis on
Android to verify the placement of our hooks, similarly to
how it was done for the LSM framework [12, 17].
Information ﬂow control. Our framework provides
modules with the control over which subject (e.g., app) has
access to which objects (e.g., device location), but it cannot
control how privileged subjects distribute this information.
Controlling information ﬂows is an orthogonal problem specif-
ically addressed by diﬀerent solutions [13, 33]. We plan to
integrate such data ﬂow solutions into our framework and
to extend our security API with new generic calls for taint
labeling and taint checking.
8. CONCLUSION
In this paper we presented the Android Security Frame-
work (ASF), an extensible and policy-agnostic security in-
frastructure for Android. ASF allows security experts to
develop Android security extensions against a novel Android
security API and to deploy their solutions in form of mod-
ules or “security apps”. Modularizing security extensions
overcomes the current unsatisfactory situation that policy au-
thors are either limited to one predetermined security model
that is embedded in the Android software stack or that they
are forced to conﬁde in a security-model-speciﬁc Android fork
instead of the mainline Android code base. Additionally, this
modularization provides a number of beneﬁts such as easier
maintenance and direct comparison of security extensions.
We demonstrated the eﬀectiveness and eﬃciency of ASF by
porting diﬀerent security models from related work to ASF
modules and by establishing a baseline for the impact of our
infrastructure on the system performance.
Availability
The ASF source code and example modules can be retrieved
from http://infsec.cs.uni-saarland.de/projects/asf/.
Acknowledgements
We thank the anonymous reviewers for their comments. This
work was supported by the German Ministry for Education
and Research (BMBF) through funding for the Center for
IT-Security, Privacy and Accountability (CISPA).
9. REFERENCES
[1] M. D. Abrams, K. W. Eggers, L. J. LaPadula, and
I. M. Olson. A generalized framework for access control:
An informal description. In NIST NCSC’90, 1990.
[2] M. Backes, S. Bugiel, S. Gerling, and P. von
Styp-Rekowsky. Android security framework: Enabling
generic and extensible access control on android.
Technical Report A/01/2014, Saarland University,
April 2014.
[3] M. Backes, S. Gerling, C. Hammer, M. Maﬀei, and
P. von Styp-Rekowsky. Appguard - enforcing user
requirements on Android apps. In TACAS’13, 2013.
[4] L. Badger, D. F. Sterne, D. L. Sherman, K. M. Walker,
and S. A. Haghighat. Practical domain and type
enforcement for UNIX. In IEEE SP’95. IEEE, 1995.
[5] D. B. Baker. Fortresses built upon sand. In NSPW’96.
ACM, 1996.
[6] S. Bugiel, L. Davi, A. Dmitrienko, T. Fischer, A.-R.
Sadeghi, and B. Shastry. Towards taming
privilege-escalation attacks on Android. In NDSS’12.
The Internet Society, 2012.
[7] S. Bugiel, L. Davi, A. Dmitrienko, S. Heuser, A.-R.
Sadeghi, and B. Shastry. Practical and lightweight
domain isolation on Android. In SPSM ’11. ACM, 2011.
[8] S. Bugiel, S. Heuser, and A.-R. Sadeghi. Flexible and
ﬁne-grained mandatory access control on Android for
diverse security and privacy policies. In USENIX
Security’13. USENIX, 2013.
[9] E. Chin, A. Porter Felt, K. Greenwood, and D. Wagner.
Analyzing inter-application communication in Android.
In MobiSys’11. ACM, 2011.
[10] M. Conti, V. T. N. Nguyen, and B. Crispo. CRePE:
Context-related policy enforcement for android. In
ISC’10. Springer, 2010.
[11] J. Edge. The return of loadable security modules?
Online: http://lwn.net/Articles/526983/, Nov.
2012.
[12] A. Edwards, T. Jaeger, and X. Zhang. Runtime
veriﬁcation of authorization hook placement for the
Linux security modules framework. In CCS’02. ACM,
2002.
[13] W. Enck, P. Gilbert, B.-G. Chun, L. P. Cox, J. Jung,
P. McDaniel, and A. N. Sheth. Taintdroid: An
information-ﬂow tracking system for realtime privacy
monitoring on smartphones. In OSDI’10. USENIX,
2010.
[14] Ú. Erlingsson and F. B. Schneider. IRM enforcement of
Java stack inspection. In IEEE SP’00. IEEE, 2000.
[15] T. Fraser. LOMAC: MAC you can live with. In
USENIX ATC’01. USENIX, 2001.
[16] T. Fraser, L. Badger, and M. Feldman. Hardening
COTS software with generic software wrappers. In
IEEE SP’99, 1999.
[17] V. Ganapathy, T. Jaeger, and S. Jha. Automatic
placement of authorization hooks in the Linux Security
Modules framework. In CCS’05. ACM, 2005.
[18] V. Gligor, S. Gavrila, and D. Ferraiolo. On the formal
deﬁnition of separation-of-duty policies and their
composition. In IEEE SP’98. IEEE, 1998.
[19] M. Grace, W. Zhou, X. Jiang, and A.-R. Sadeghi.
Unsafe exposure analysis of mobile in-app
advertisements. In WISEC’12. ACM, 2012.
[20] S. Heuser, A. Nadkarni, W. Enck, and A.-R. Sadeghi.
Asm: A programmable interface for extending android
security. Technical Report TUD-CS-2014-0063, Intel
CRI-SC at TU Darmstadt, North Carolina State
University, CASED / TU Darmstadt, Mar. 2014. To
appear at USENIX Security’14.
[21] J. Jeon, K. K. Micinski, J. A. Vaughan, A. Fogel,
N. Reddy, J. S. Foster, and T. Millstein. Dr. Android
and Mr. Hide: Fine-grained security policies on
unmodiﬁed Android. In SPSM ’12. ACM, 2012.
[22] B. W. Lampson. Protection. ACM SIGOPS Operating
Systems Review, 8(1):18–24, Jan. 1974.
[23] J. Ligatti, L. Bauer, and D. Walker. Edit automata:
Enforcement mechanisms for run-time security policies.
International Journal of Information Security,
4(1–2):2–16, 2005.
[24] T. A. Linden. Operating system structures to support
security and reliable software. ACM Computer Surveys,
8(4):409–445, Dec. 1976.
[25] Linux Cross Reference. Linux Security Module
framework. Online: http://lxr.free-electrons.com/
source/Documentation/security/LSM.txt.
[26] P. A. Loscocco, S. D. Smalley, P. A. Muckelbauer, R. C.
Taylor, S. J. Turner, and J. F. Farrell. The inevitability
of failure: The ﬂawed assumption of security in modern
computing environments. In NISSC’98, 1998.
[27] P. McDaniel and A. Prakash. Methods and limitations
of security policy reconciliation. In IEEE SP’02. IEEE,
2002.
[28] M. Ongtang, S. E. McLaughlin, W. Enck, and
P. McDaniel. Semantically rich application-centric
security in Android. In ACSAC’09. ACM, 2009.
[29] A. Porter Felt, H. J. Wang, A. Moshchuk, S. Hanna,
and E. Chin. Permission re-delegation: Attacks and
defenses. In USENIX Security’11. USENIX, 2011.
[30] N. Provos. Improving host security with system call
policies. In USENIX Security’03. USENIX, 2003.
[31] N. Provos, M. Friedl, and P. Honeyman. Preventing
privilege escalation. In USENIX Security’03. USENIX,
2003.
[32] V. Rao and T. Jaeger. Dynamic mandatory access
control for multiple stakeholders. In SACMAT’09.
ACM, 2009.
[33] G. Russello, M. Conti, B. Crispo, and E. Fernandes.
MOSES: supporting operation modes on smartphones.
In SACMAT’12. ACM, 2012.
[34] J. Saltzer and M. Schroeder. The protection of
information in computer systems. Proceedings of the
IEEE, 63(9):1278–1308, 1975.
[35] S. Shekhar, M. Dietz, and D. S. Wallach. Adsplit:
Separating smartphone advertising from applications.
In USENIX Security’12. USENIX, 2012.
[36] S. Smalley and R. Craig. Security Enhanced
(SE) Android: Bringing Flexible MAC to Android. In
NDSS’13. The Internet Society, 2013.
[37] R. Spencer, S. Smalley, P. Loscocco, M. Hibler,
D. Andersen, and J. Lepreau. The Flask security
architecture: System support for diverse security
policies. In USENIX Security’99. USENIX, 1999.
[38] Y. Wang, S. Hariharan, C. Zhao, J. Liu, and W. Du.
Compac: Enforce component-level access control in
Android. In CODASPY’14. ACM, 2014.
[39] R. Watson, W. Morrison, C. Vance, and B. Feldman.
The TrustedBSD MAC Framework: Extensible kernel
access control for FreeBSD 5.0. In USENIX ATC’03.
USENIX, 2003.
[40] C. Wright, C. Cowan, S. Smalley, J. Morris, and
G. Kroah-Hartman. Linux Security Modules: General
security support for the Linux kernel. In USENIX
Security’02. USENIX, 2002.
[41] Y. Zhou and X. Jiang. Dissecting Android malware:
Characterization and evolution. In IEEE SP’12, 2012.
[42] Y. Zhou, X. Zhang, X. Jiang, and V. Freeh. Taming
information-stealing smartphone applications (on
Android). In TRUST’11. Springer, 2011.