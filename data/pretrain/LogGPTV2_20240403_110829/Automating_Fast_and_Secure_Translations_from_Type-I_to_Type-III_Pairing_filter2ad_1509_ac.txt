is on purpose as to reduce the burden of transcribing these constructions for AutoGroup+ users.
Indeed, in our experience the most time consuming and tedious part is in specifying the reductions
accurately.
Step 2: Extracting the Dependencies Once the SDLs have been generated along with the
metadata and the user’s desired optimization goal, the user can proceed with executing Auto-
Group+ to begin deriving the dependency graphs for each input ﬁle. AutoGroup+ programmati-
cally extracts the dependencies from the SDL descriptions starting with the assumption(s), then
the reduction(s) and ﬁnally, the scheme. The dependency graph diagrams for BB HIBE [BB04b,
§4.1] are included in Figures 2, 3, and 4. Note that these diagrams were generated automatically
by our tool; we believe this feature provides more transparency to make it easier for humans to
verify that the software is operating correctly. In “naming” the nodes of our dependency graphs,
we closely follow the naming conventions that the user employed in the SDL, thus supporting the
quick and easy veriﬁcation.
In Figure 5, we show the third step in AutoGroup+ which is to
Step 3: Merge the Graphs
merge the multiple dependency graphs (assumption, reduction and scheme graphs) into one single
graph.
Step 4: Assignment of Variables With the merged graph, we encode the pairing equations as
a logical formula as in AutoGroup but also encode certain group elements in the dependency graph
as additional constraints to the solver (with optimization requirements):
P 1[0] (cid:54)= P 1[1] ∧ P 2[0] (cid:54)= P 2[1] ∧ P 3[0] (cid:54)= P 3[1] ∧ P 4[0] (cid:54)= P 4[1]
Recall that pairing identiﬁers (e.g., P 2[0], P 2[1]) are unique references which refer to pairing inputs
from the scheme (e.g., e(C3, d2)).
Step 5: Search for an Optimal Solution In our BB HIBE example, the goal is to minimize the
number of splits in the master public parameters params, so this requires specifying the following
parameters of the EvalGraph function. Let B = {g, g1, g2, h1, h2} be the set of elements in the
public parameters we wish to minimize and let G be an encoding of the merged dependency graph
shown in Figure 5. As reﬂected in Table 8, the solver identiﬁes 16 possible solutions for the BB
HIBE scheme and computes the following on each solution as Sj = EvalGraph(Aj, B, G) where
Aj is the j-th set of possible variable assignments. Recall that EvalGraph simply applies a given
solution to G and records how elements of B are assigned. From the set S, the solver ﬁnds
an assignment that has the fewest number of duplicated public key elements with the smallest
overall size. Based on this criteria, the solver returned a optimal solution in the ﬁfth step which
consisted of 2 splits (i.e., two duplicated elements). The new public key elements are assigned as
B(cid:48) = {g, ˜g, g1, g2, ˜g2, h1, h2} ∈ G5
2. This constitutes only an addition of 2 group elements in
G2.
1 × G2
13
Figure 2: Dependency graph for the DBDH instance generated by AutoGroup+.
Figure 3: Dependency graph that merges Setup, KeyGen, Encrypt and Decrypt algorithms in BB
HIBE and generated by AutoGroup+. For brevity, we only show the combined scheme graph and
omit the smaller ones for each routine in the scheme. Note that nodes P 1 through P 4 represent
unique pairing identiﬁers, with a 0 index representing a left-hand pairing element and a 1 the right.
Figure 4: Dependency graph for the reduction to DBDH in BB HIBE. This graph was generated
by AutoGroup+.
14
gABCg2g2alphaP1[1]d1C4P3[0]h1C3P4[1]P2[0]gd3d2g1C2P3[1]P2[1]P1[0]h2P4[0]gABCd1d3h1d2h2g1g2g3C3C4C2Figure 5: The merged dependency graph for the assumption, reduction to DBDH, and the BB
HIBE scheme. This graph was generated by AutoGroup+.
In the last step, AutoGroup+ splits the graph as dictated
Step 6: Assignment of Variables
by the optimal solution found by the solver. The resulting graphs for G1 and G2 assignments for
the BB HIBE scheme are shown in Figure 6. AutoGroup+ programmatically converts the split
graph into an asymmetric translation for the scheme and assumption. We improve on code from
AutoGroup to do the former translation and write a new module to do the latter (see Figure 7 for the
graph split of co-DBDH). These resulting SDL ﬁles are provided in Appendix B.2. As mentioned
before, there is a publicly-available tool (see Section 2.3) for automatically turning this SDL into
C++, Python or LATEX.
5 AutoGroup+: Experimental Evaluation
We tested AutoGroup+ on 9 schemes, with 3-4 optimization options and 4 diﬀerent levels of BB
HIBE, for 48 total translations.9 Figure 8 summarizes the translation times and resulting scheme
sizes.10 To demonstrate the improvement in running times due to both the asymmetric setting
and AutoGroup+’s optimizations, Figure 9 includes over 140 timing experiments, showing drastic
improvements. In Figure 10, we summarize the eﬀect of scheme complexity on AutoGroup+ conver-
sion time by varying the complexity of BB HIBE. We note that even given a more complex scheme
than attempted by any other tool, AutoGroup+ still provides fast conversion times.
System Conﬁguration. All of our benchmarks were executed on a standard workstation that has a
2.20GHz quad-core Intel Core i7-2720QM processor with 8GB RAM running Ubuntu 11.04 LTS,
Linux Kernel version 2.6.38-16-generic (x86-64-bit architecture). Our measurements only use a
single core of the Intel processor for consistency. The AutoGroup+ implementation utilizes the
9Currently the tool does not support the assumption minimization option for schemes with more than one as-
sumption. This is future work, although we would like to explore how valuable assumption minimization is to tool
users.
10We only give details for two variations of BB HIBE because the results are similar for all levels.
15
g1P1[0]d1h2C4C3h1P4[1]P3[0]gC2Cd2d3BAP2[0]g3g2P1[1]g2alphaP4[0]P2[1]P3[1](a) Showing G1 elements in the scheme
(b) Showing G2 elements in the scheme
Figure 6: The dependency graphs for the asymmetric translation of BB HIBE scheme only (with
PK optimization). This graph was generated by AutoGroup+.
Figure 7: The dependency graph for the co-DBDH assumption and generated by AutoGroup+.
same building blocks as AutoGroup which include the MIRACL library (v5.5.4) and/or RELIC
cryptographic toolkit [AG], Charm v0.43 [AGM+13] in C++ or Python code, and the Z3 SMT
solver (v4.3.2).
Limitations. In Section 3.1.1, we provide an example of a scheme which falls into a category of things
that Abe et al. warned about and on which AutoGroup gets confused. AutoGroup tries to power
through and split the hash output (which it cannot really do because the discrete log is unknown),
so while it eventually outputs some SDL, this SDL is not a proper translation. Unlike AutoGroup,
AutoGroup+ includes logic to output a warning when processing such inputs and continues trying
to translate the scheme. If the veriﬁcation check of a valid split fails (e.g., due to hash split), then
AutoGroup+ identiﬁes the split as invalid and attempts checking the next best solution. If there
are no such solutions, AutoGroup+ outputs no solution.
16
d1P4[1]gG1g1g2G1h2G1h1G1C4P1[0]C3g2alphaP3[0]P2[0]d3P3[1]g2G2P1[1]gG2d2C2P2[1]P4[0]gG1ABG1CG1gG2BG2CG2Conversion
Number of Group Elements
Time
Public Key
Secret Key
Ciphertext
Assumption
Assumption
Num.
Solutions
ID-Based Enc.
BB04 HIBE [BB04a, §4] Symmetric (l = 2)
Asymmetric [Min. PK]
Asymmetric [Min. SK]
Asymmetric [Min. CT]
Asymmetric [Min. Assump]
BB04 HIBE [BB04a, §4] Symmetric (l = 9)
Asymmetric [Min. PK]
Asymmetric [Min. SK]
Asymmetric [Min. CT]
Asymmetric [Min. Assump]
GENTRY06 [Gen06, §3.1] Symmetric
Asymmetric [Min. PK]
Asymmetric [Min. SK]
Asymmetric [Min. CT]
Asymmetric [Min. Assump]
WATERS05 [Wat05, §4] Symmetric
Asymmetric [Min. PK]
Asymmetric [Min. SK]
Asymmetric [Min. CT]
Asymmetric [Min. Assump]
WATERS09 (DSE) [Wat09, §3.1] Symmetric
Asymmetric [Min. PK]
Asymmetric [Min. SK]
Asymmetric [Min. CT]
Asymmetric [Min. Assump]
Broadcast Encryption
BGW05 [BGW05, §3.1] Symmetric (n users)
Asymmetric [Min. PK]
Asymmetric [Min. SK]
Asymmetric [Min. CT]
Asymmetric [Min. Assump]
Signature
ACDKNO [ACD+12, §5.3] Symmetric
Asymmetric [Min. PK]
Asymmetric [Min. Sig]
Asymmetric [Min. Assump]
BLS [BLS04, §2.2] Symmetric
Asymmetric [Min. PK]
Asymmetric [Min. Sig]
Asymmetric [Min. Assump]
CL04 [CL04, §3.1] Symmetric
Asymmetric [Min. PK]
Asymmetric [Min. Sig]
Asymmetric [Min. Assump]
WATERS05 [Wat05, §7] Symmetric
Asymmetric [Min. PK]
Asymmetric [Min. Sig]
Asymmetric [Min. Assump]
-
592 ms
641 ms
626 ms
582 ms
-
20629 ms
15714 ms
15690 ms
20904 ms
-
669 ms
718 ms
723 ms
676 ms
-
725 ms
770 ms
767 ms
716 ms
-
6217 ms
5871 ms
5858 ms
6228 ms
-
530 ms
601 ms
587 ms
544 ms
-
18216 ms
14689 ms
18135 ms
-
515 ms
556 ms
517 ms
-
278 ms
328 ms
275 ms
-
724 ms
721 ms
755 ms
2
2
2
2
2
2
2
2
2
G5
1 × G2
G5
1 × G4
G5
1 × G5
G4
1 × G5
G4
G12
1 × G2
G12
1 × G11
G12
1 × G12
G11
1 × G12
G11
G3
1 × G2
G2
1 × G3
G2
1 × G2
G2
1 × G2
G2
G4+n
1 × G2
G4+n
1 × G3+n
G4+n
1 × G4+n
G3+n
1 × G3+n
G4+n
G13 × GT
1 × G4
2 × GT
G10
2 × GT
1 × G13
G7
2 × GT
1 × G7
G13
1 × G5
2 × GT
G12
2
2
2
2
2
2
2
G2n+1
2
× G2n
G2n+1
1
1 × G2n+1
G2n
× G2n
G2n+1
× G2n
G2n+1
2
1
2
2
1
2
2
2
G15
1 × G5
G14
1 × G14
G6
1 × G14
G5
G2
G2
2
G2
2
G2
2
G3
1 × G2
G3
G1 × G3
1 × G2
G3
G4+n
1 × G2
G3
1 × G3+n
G4+n
1 × G2
G4+n
2
2