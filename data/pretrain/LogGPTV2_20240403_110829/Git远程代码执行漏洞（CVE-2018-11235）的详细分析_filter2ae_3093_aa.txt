# Git远程代码执行漏洞（CVE-2018-11235）的详细分析

## 译文声明
本文是翻译文章，原文来源：[https://staaldraad.github.io/](https://staaldraad.github.io/)。具体内容表达及含义以原文为准。

## 概述
在研究一个包含多个子模块的Git仓库时，我意识到自己对子模块的工作机制并不完全了解。因此，我决定深入探究子模块的工作原理。在此过程中，我发现了一个可能导致远程代码执行（RCE）的漏洞。通过在一台恶意软件库主机上成功利用该漏洞，我向GitHub的Bounty Hunters项目提交了这一发现，并获得了CVE-2018-11235的编号。本文将详细描述该漏洞的发现过程及其利用步骤。

## 关于子模块
Git允许用户将外部仓库作为子模块嵌入到自己的仓库中，从而轻松管理依赖关系并自动跟踪更改。根据Git-scm的定义，子模块是一个嵌入在另一个仓库中的独立仓库，具有自己的历史记录。包含子模块的仓库被称为超级项目。

### 添加子模块
要将子模块添加到仓库，可以使用`git submodule add`命令。例如：
```bash
git submodule add https://github.com/staaldraad/repository.git mysubmodule
```
这将创建以下文件和目录：
1. `mysubmodule/`：子模块仓库的路径。
2. `.gitmodules`：包含子模块初始化信息的配置文件。
3. `$GIT_DIR/modules/mysubmodule`：子模块的Git目录。
4. 修改后的`.git/config`文件，包含所有子模块的引用。

### 子模块初始化
为了在本地复制的仓库中初始化子模块，可以使用以下命令：
```bash
git clone --recurse-submodules https://github.com/staaldraad/repository.git
```
或者在现有仓库中运行：
```bash
git submodule update --init
```

## 漏洞发现过程
### 初步尝试
通过检查`.gitmodules`文件，我注意到其中两次出现了`mysubmodule`，一次作为子模块名称，另一次作为路径。默认情况下，子模块名称和路径相同，除非使用`--name`参数指定。此外，子模块名称用于创建其`.git`目录，路径为`$GIT_DIR/modules/mysubmodule`。

如果子模块名称是一个路径会怎样？为了验证这一点，我修改了`.gitmodules`文件中的子模块名称：
```ini
[submodule "../../submodule"]
    path = mysubmodule
    url = https://github.com/staaldraad/repository.git
```
提交修改后，子模块仓库被创建在主仓库中，而不是在`.git/modules`目录下：
```bash
git clone --recurse-submodules https://github.com/staaldraad/repository.git
cd repository
ls -l
```
结果表明，存在目录遍历漏洞，但此时我们还不能控制写入的内容。于是我尝试使用符号链接进行写入，但效果有限。

### Git钩子
Git钩子是在Git工作流中触发的可执行脚本，分为客户端钩子和服务端钩子。常见的例子包括预提交钩子，用于验证提交内容。这些钩子位于`$GIT_DIR/hooks/`目录下，不会存储在远程仓库中。

子模块也可以有钩子，存储在`$GIT_DIR/modules/modulename/hooks`目录下。我考虑利用遍历漏洞来创建并触发位于`$GIT_DIR`之外的钩子。

### 重新回到遍历漏洞
由于遍历漏洞允许子模块仓库位于`$GIT_DIR`之外，我们可以将其添加到工作树并提交到远程。理论上，当子模块更新时，会触发钩子。

具体步骤如下：
1. 添加一个子模块：
   ```bash
   git submodule add https://github.com/staaldraad/repository.git submod
   ```
2. 创建一个伪造的Git目录：
   ```bash
   mkdir -p fakegit/modules
   ```
3. 创建一个Git钩子：
   ```bash
   vim fakegit/modules/submod/hooks/post-checkout
   chmod +x !$
   ```
4. 修改`.gitmodules`文件，包含遍历路径（新模块名称为`../../fakegit/modules/submod`）。
5. 提交所有内容：
   ```bash
   git add .
   git commit -m "msg"
   git push origin master
   ```

我们的目标是，在仓库被克隆时，`fakegit/modules/submod`看起来像是一个有效的子模块仓库，并且在子模块更新时触发钩子。然而，实际操作中遇到了失败：
```bash
Submodule '../../fakegit/modules/submod' (https://github.com/staaldraad/repository.git) registered for path 'submod'
Cloning into '/tmp/c/v/subs/submod'...
fatal: /tmp/c/v/subs/.git/modules/../../fakegit/modules/submod already exists
fatal: clone of 'https://github.com/staaldraad/repository.git' into submodule path '/tmp/c/v/subs/submod' failed
Failed to clone 'submod'. Retry scheduled
```

尽管初步尝试未成功，但这一发现揭示了Git子模块系统中的潜在安全风险。