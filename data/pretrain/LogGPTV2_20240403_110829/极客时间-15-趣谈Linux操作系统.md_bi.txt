## 总结时刻用户态的内存映射机制，我们解析的差不多了，我们来总结一下，用户态的内存映射机制包含以下几个部分。-   用户态内存映射函数 mmap，包括用它来做匿名映射和文件映射。-   用户态的页表结构，存储位置在 mm_struct 中。-   在用户态访问没有映射的内存会引发缺页异常，分配物理页表、补齐页表。如果是匿名映射则分配物理内存；如果是    swap，则将 swap 文件读入；如果是文件映射，则将文件读入。![](Images/a22a85d32ea3b367cabfb1adbba3525c.png){savepage-src="https://static001.geekbang.org/resource/image/78/44/78d351d0105c8e5bf0e49c685a2c1a44.jpg"}
## 课堂练习你可以试着用 mmap 系统调用，写一个程序来映射一个文件，并读取文件的内容。欢迎留言和我分享你的疑惑和见解，也欢迎你收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习、进步。![](Images/1a5564dd4e1c9f25d4772c7f844ca84a.png){savepage-src="https://static001.geekbang.org/resource/image/8c/37/8c0a95fa07a8b9a1abfd394479bdd637.jpg"}
# 26 \| 内核态内存映射：如何找到正确的会议室？前面讲用户态内存映射机制的时候，我们已经多次引申出了内核的映射机制，但是咱们都暂时放了放，这一节我们就来详细解析一下，让你彻底搞懂它。首先，你要知道，内核态的内存映射机制，主要包含以下几个部分：-   内核态内存映射函数 vmalloc、kmap_atomic 是如何工作的；-   内核态页表是放在哪里的，如何工作的？swapper_pg_dir 是怎么回事；-   出现了内核态缺页异常应该怎么办？
## 内核页表和用户态页表不同，在系统初始化的时候，我们就要创建内核页表了。我们从内核页表的根 swapper_pg_dir 开始找线索，在arch/x86/include/asm/pgtable_64.h 中就能找到它的定义。    extern pud_t level3_kernel_pgt[512];extern pud_t level3_ident_pgt[512];extern pmd_t level2_kernel_pgt[512];extern pmd_t level2_fixmap_pgt[512];extern pmd_t level2_ident_pgt[512];extern pte_t level1_fixmap_pgt[512];extern pgd_t init_top_pgt[];  #define swapper_pg_dir init_top_pgtswapper_pg_dir 指向内核最顶级的目录pgd，同时出现的还有几个页表目录。我们可以回忆一下，64位系统的虚拟地址空间的布局，其中 XXX_ident_pgt对应的是直接映射区，XXX_kernel_pgt 对应的是内核代码区，XXX_fixmap_pgt对应的是固定映射区。它们是在哪里初始化的呢？在汇编语言的文件里面的arch\\x86\\kernel\\head_64.S。这段代码比较难看懂，你只要明白它是干什么的就行了。``{=html}    __INITDATA  NEXT_PAGE(init_top_pgt).quad   level3_ident_pgt - __START_KERNEL_map + _KERNPG_TABLE.org    init_top_pgt + PGD_PAGE_OFFSET*8, 0.quad   level3_ident_pgt - __START_KERNEL_map + _KERNPG_TABLE.org    init_top_pgt + PGD_START_KERNEL*8, 0/* (2^48-(2*1024*1024*1024))/(2^39) = 511 */.quad   level3_kernel_pgt - __START_KERNEL_map + _PAGE_TABLE  NEXT_PAGE(level3_ident_pgt).quadlevel2_ident_pgt - __START_KERNEL_map + _KERNPG_TABLE.fill511, 8, 0NEXT_PAGE(level2_ident_pgt)/* Since I easily can, map the first 1G. * Don't set NX because code runs from these pages. */PMDS(0, __PAGE_KERNEL_IDENT_LARGE_EXEC, PTRS_PER_PMD)  NEXT_PAGE(level3_kernel_pgt).fillL3_START_KERNEL,8,0/* (2^48-(2*1024*1024*1024)-((2^39)*511))/(2^30) = 510 */.quadlevel2_kernel_pgt - __START_KERNEL_map + _KERNPG_TABLE.quadlevel2_fixmap_pgt - __START_KERNEL_map + _PAGE_TABLE  NEXT_PAGE(level2_kernel_pgt)/* * 512 MB kernel mapping. We spend a full page on this pagetable * anyway. * * The kernel code+data+bss must not be bigger than that. * * (NOTE: at +512MB starts the module area, see MODULES_VADDR. *  If you want to increase this then increase MODULES_VADDR *  too.) */PMDS(0, __PAGE_KERNEL_LARGE_EXEC,KERNEL_IMAGE_SIZE/PMD_SIZE)  NEXT_PAGE(level2_fixmap_pgt).fill506,8,0.quadlevel1_fixmap_pgt - __START_KERNEL_map + _PAGE_TABLE/* 8MB reserved for vsyscalls + a 2MB hole = 4 + 1 entries */.fill5,8,0  NEXT_PAGE(level1_fixmap_pgt).fill51内核页表的顶级目录 init_top_pgt，定义在 \_\_INITDATA 里面。咱们讲过 ELF的格式，也讲过虚拟内存空间的布局。它们都有代码段，还有一些初始化了的全局变量，放在.init区域。这些说的就是这个区域。可以看到，页表的根其实是全局变量，这就使得我们初始化的时候，甚至内存管理还没有初始化的时候，很容易就可以定位到。接下来，定义 init_top_pgt包含哪些项，这个汇编代码比较难懂了。你可以简单地认为，quad是声明了一项的内容，org 是跳到了某个位置。所以，init_top_pgt 有三项，上来先有一项，指向的是level3_ident_pgt，也即直接映射区页表的三级目录。为什么要减去\_\_START_KERNEL_map 呢？因为 level3_ident_pgt是定义在内核代码里的，写代码的时候，写的都是虚拟地址，谁写代码的时候也不知道将来加载的物理地址是多少呀，对不对？因为 level3_ident_pgt 是在虚拟地址的内核代码段里的，而\_\_START_KERNEL_map 正是虚拟地址空间的内核代码段的起始地址，这在讲 64位虚拟地址空间的时候都讲过了，要是想不起来就赶紧去回顾一下。这样，level3_ident_pgt减去 \_\_START_KERNEL_map 才是物理地址。第一项定义完了以后，接下来我们跳到 PGD_PAGE_OFFSET的位置，再定义一项。从定义可以看出，这一项就应该是 \_\_PAGE_OFFSET_BASE对应的。\_\_PAGE_OFFSET_BASE是虚拟地址空间里面内核的起始地址。第二项也指向level3_ident_pgt，直接映射区。    PGD_PAGE_OFFSET = pgd_index(__PAGE_OFFSET_BASE)PGD_START_KERNEL = pgd_index(__START_KERNEL_map)L3_START_KERNEL = pud_index(__START_KERNEL_map)第二项定义完了以后，接下来跳到 PGD_START_KERNEL的位置，再定义一项。从定义可以看出，这一项应该是 \_\_START_KERNEL_map对应的项，\_\_START_KERNEL_map是虚拟地址空间里面内核代码段的起始地址。第三项指向level3_kernel_pgt，内核代码区。接下来的代码就很类似了，就是初始化个表项，然后指向下一级目录，最终形成下面这张图。![](Images/6115d0efdb8036bb6839b3f867a976c0.png){savepage-src="https://static001.geekbang.org/resource/image/78/6d/78c8d44d7d8c08c03eee6f7a94652d6d.png"}内核页表定义完了，一开始这里面的页表能够覆盖的内存范围比较小。例如，内核代码区512M，直接映射区1G。这个时候，其实只要能够映射基本的内核代码和数据结构就可以了。可以看出，里面还空着很多项，可以用于将来映射巨大的内核虚拟地址空间，等用到的时候再进行映射。如果是用户态进程页表，会有 mm_struct 指向进程顶级目录pgd，对于内核来讲，也定义了一个 mm_struct，指向 swapper_pg_dir。    struct mm_struct init_mm = {.mm_rb= RB_ROOT,.pgd= swapper_pg_dir,.mm_users= ATOMIC_INIT(2),.mm_count= ATOMIC_INIT(1),.mmap_sem= __RWSEM_INITIALIZER(init_mm.mmap_sem),.page_table_lock =  __SPIN_LOCK_UNLOCKED(init_mm.page_table_lock),.mmlist= LIST_HEAD_INIT(init_mm.mmlist),.user_ns= &init_user_ns,INIT_MM_CONTEXT(init_mm)};定义完了内核页表，接下来是初始化内核页表，在系统启动的时候 start_kernel会调用 setup_arch。    void __init setup_arch(char **cmdline_p){/* * copy kernel address range established so far and switch * to the proper swapper page table */clone_pgd_range(swapper_pg_dir     + KERNEL_PGD_BOUNDARY,initial_page_table + KERNEL_PGD_BOUNDARY,KERNEL_PGD_PTRS);  load_cr3(swapper_pg_dir);__flush_tlb_all();......init_mm.start_code = (unsigned long) _text;init_mm.end_code = (unsigned long) _etext;init_mm.end_data = (unsigned long) _edata;init_mm.brk = _brk_end;......init_mem_mapping();......}在 setup_arch 中，load_cr3(swapper_pg_dir)说明内核页表要开始起作用了，并且刷新了 TLB，初始化 init_mm的成员变量，最重要的就是 init_mem_mapping。最终它会调用kernel_physical_mapping_init。    /* * Create page table mapping for the physical memory for specific physical * addresses. The virtual and physical addresses have to be aligned on PMD level * down. It returns the last physical address mapped. */unsigned long __meminitkernel_physical_mapping_init(unsigned long paddr_start,     unsigned long paddr_end,     unsigned long page_size_mask){unsigned long vaddr, vaddr_start, vaddr_end, vaddr_next, paddr_last;  paddr_last = paddr_end;vaddr = (unsigned long)__va(paddr_start);vaddr_end = (unsigned long)__va(paddr_end);vaddr_start = vaddr;  for (; vaddr = VMALLOC_START && address `{=html}**第二点，文件系统中也要有索引区，用来方便查找一个文件分成的多个块都存放在了什么位置**。这就好比，图书馆的书太多了，为了方便查找，我们需要专门设置一排书架，这里面会写清楚整个档案库有哪些资料，资料在哪个架子的哪个格子上。这样找资料的时候就不用跑遍整个档案库，在这个书架上找到后，直奔目标书架就可以了。![](Images/e3aa53b601533ffc7ce6ed929dee81ea.png){savepage-src="https://static001.geekbang.org/resource/image/93/07/93bf5e8e940752b32531ed6752b5f607.png"}**第三点，如果文件系统中有的文件是热点文件，近期经常被读取和写入，文件系统应该有缓存层**。这就相当于图书馆里面的热门图书区，这里面的书都是畅销书或者是常常被借还的图书。因为借还的次数比较多，那就没必要每次有人还了之后，还放回遥远的货架，我们可以专门开辟一个区域，放置这些借还频次高的图书。这样借还的效率就会提高。**第四点，文件应该用文件夹的形式组织起来，方便管理和查询**。这就像在图书馆里面，你可以给这些资料分门别类，比如分成计算机类、文学类、历史类等等。这样你也容易管理，项目组借阅的时候只要在某个类别中去找就可以了。在文件系统中，每个文件都有一个名字，这样我们访问一个文件，希望通过它的名字就可以找到。文件名就是一个普通的文本。当然文件名会经常冲突，不同用户取相同的名字的情况还是会经常出现的。要想把很多的文件有序地组织起来，我们就需要把它们成为目录或者文件夹。这样，一个文件夹里可以包含文件夹，也可以包含文件，这样就形成了一种树形结构。而我们可以将不同的用户放在不同的用户目录下，就可以一定程度上避免了命名的冲突问题。![](Images/6fb3d671c8aebf27ed6629ff5dc14237.png){savepage-src="https://static001.geekbang.org/resource/image/e7/4f/e71da53d6e2e4458bcc0af1e23f08e4f.png"}如图所示，不同的用户的文件放在不同的目录下，虽然很多文件都叫"文件1"，只要在不同的目录下，就不会有问题。有了目录结构，定位一个文件的时候，我们还会分**绝对路径**（AbsolutePath）和**相对路径**（RelativePath）。所谓绝对路径，就是从根目录开始一直到当前的文件，例如"/ 根目录 /用户 A 目录 / 目录 1/ 文件 2"就是一个绝对路径。而通过 cd命令可以改变当前路径，例如"cd / 根目录 / 用户 A 目录"，就是将用户 A目录设置为当前目录，而刚才那个文件的相对路径就变成了"./ 目录 1/ 文件2"。**第五点，Linux内核要在自己的内存里面维护一套数据结构，来保存哪些文件被哪些进程打开和使用**。这就好比，图书馆里会有个图书管理系统，记录哪些书被借阅了，被谁借阅了，借阅了多久，什么时候归还。好了，这样下来，这文件系统的几个部分，是不是就很好理解、记忆了？你不用死记硬背，只要按照一个正常的逻辑去理解，自然而然就能记住了。接下来的整个章节，我们都要围绕这五点展开解析。
## 文件系统相关命令行在 Linux命令的那一节，我们学了一些简单的文件操作的命令，这里我们再来学几个常用的。首先是**格式化**，也即将一块盘使用命令组织成一定格式的文件系统的过程。咱们买个硬盘或者U 盘，经常说要先格式化，才能放文件，说的就是这个。使用 Windows 的时候，咱们常格式化的格式为**NTFS**（New Technology FileSystem）。在 Linux 下面，常用的是 ext3 或者 ext4。当一个 Linux系统插入了一块没有格式化的硬盘的时候，我们可以通过命令**fdisk-l**，查看格式化和没有格式化的分区。    