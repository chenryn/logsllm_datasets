Weight distribution: To evaluate the size of the compact
certiﬁcate when the distribution of weights is not uniform,
we generated several skewed distributions, based on a skew
parameter s. The skew distribution was chosen to be easy
to model and understand, to illustrate the eﬀect of skew
on certiﬁcate size, rather than modeling any real-world
distribution of weights. Each skewed distribution consisted
of 1 million attestors. The ﬁrst attestor had a weight of 244,
and the weight of each subsequent attestor was multiplied by
1 − 10−s (rounded up to 1 unit of weight to ensure that all 1
million attestors have non-zero weight).
Figure 7 shows the results. With extremely skewed distribu-
tions, the number of distinct reveals (i.e., |T|) is low because
the same attestor is chosen to be revealed multiple times, but
appears only once in the resulting certiﬁcate (Section IV-A,
Step 6). For example, at s = 1, there are only 29 distinct
reveals even though numReveals = 129. As seen from the
graph, at extreme skew levels (s ≤ 2), the naïve approach of
sending the highest-weight signatures is more eﬃcient than a
compact certiﬁcate. For instance, with s = 2, signatures from
the top 69 attestors account for half of the total weight.
Fig. 7. Size of compact certiﬁcate (bytes) and number of distinct reveals,
as a function of the skew of the weight distribution, for signedWeight =
totalWeight = 2 · provenWeight.
At moderate skew levels (s ≥ 3), attestors are no longer
chosen to be revealed multiple times, but the certiﬁcate size
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:26:28 UTC from IEEE Xplore.  Restrictions apply. 
60708090100Percentageofsignaturespresent020406080Veriﬁcationtime(msec)1Mattestors10Kattestors100attestors123456789Skewparameter0255075100125DistinctrevealsorsignaturesNaivesignaturesDistinctrevealsCompactcertsize0250005000075000100000125000Compactcertsize(bytes)connected attestors will wish to make sure that the certiﬁcate
is constructed without knowing who exactly is constructing it.
We thus have to address several challenges that arise due to
resource constraints, adversarial nodes, and fault tolerance.
We will use the term node to refer to a computer that
participates in the decentralized protocol. In Algorand’s
deployment setting, there is a special type of node called
a relay. The job of relay nodes is to support the decentralized
protocol by relaying messages among all of the participants. A
public directory of known relay nodes enables any participant
to join the Algorand network protocol. Non-relay nodes
typically connect to several relay nodes, but do not connect
to one another. We assume that the underlying blockchain
system (Algorand) provides a consensus mechanism; we will
rely on this mechanism to ensure reliability.
We do not give evaluation results for the design in this
section, because those results would depend almost exclusively
on the details of the underlying blockchain and network.
Algorand’s deployment of compact certiﬁcates is in the early
stages, and we do not yet have signiﬁcant data from a real-
world deployment.
A. Resource constraints: Collecting signatures
The ﬁrst challenge in our decentralized setting lies in decid-
ing what nodes will form compact certiﬁcates. Constructing a
compact certiﬁcate requires access to all of the signatures from
attestors (the sigs array from Section IV-A), even though the
resulting compact certiﬁcate is far smaller. This means that
any node that forms a compact certiﬁcate must receive and
store many messages (linear in the number of attestors in the
system). Requiring all nodes in a decentralized protocol to play
this role would require bandwidth quadratic in the number of
attestors, and can be costly if the number of attestors is high.
To avoid this cost, we treat relay nodes specially. Relay
nodes are responsible for collecting all signatures that will
be used to build the compact certiﬁcate, and relaying any
signatures they receive to other relay nodes in the system,
so that all relay nodes have all of the signatures. Non-relay
nodes send their signatures to relay nodes, but do not receive
signatures from other nodes. Each node in the system (both
relay and non-relay) chooses several relay nodes to which it
will send its messages. For relay nodes, this forms a network of
relays so that signatures propagate between them in relatively
few hops. For non-relay nodes, this ensures that their signatures
will be quickly propagated across relay nodes, even if some
relay nodes might be faulty.
It is important to choose carefully when to send a signature.
All attestors in the system are likely to produce signatures at
approximately the same time (e.g., when the next candidate
block in a blockchain becomes available); if all nodes immedi-
ately send those signatures, the system will be overwhelmed by
a spike of messages, many of which will have to be dropped.
To avoid such a bandwidth spike, we de-synchronize the
transmission of signatures, by randomizing the time at which
signatures are sent. In Algorand’s protocol, we use the round
number of the latest block as a proxy for time in this context.
Speciﬁcally, we choose some window (e.g., the N/2 rounds
after a multiple-of-N block is decided) to be designated for
transmitting signatures. When an attestor signs a message,
that attestor’s node chooses a pseudorandom oﬀset within
the window at which the signature will be sent.6 A relay
node that receives a new, previously unseen signature, will
immediately send that signature to other relays; this ensures
rapid propagation of signatures. A relay nodes that receives a
duplicate signature does not relay it.
A signiﬁcant cost of the compact certiﬁcate protocol lies in
the veriﬁcation of the signatures from all attestors prior to the
construction of the compact certiﬁcate. A natural optimization
to consider is to avoid eager veriﬁcation of these signatures:
relay nodes would not bother verifying the signature, and
would relay the signature to others as-is. Unfortunately, this
optimization is problematic, for the following reason. To
prevent an adversary from ﬂooding the network with invalid
signatures, relays would need to force veriﬁcation of signatures
once they receive two or more signatures from the same
attestor. As a result, while the optimistic case avoids the CPU
cost of verifying signatures, it would be relatively easy for
an adversary to force relays to verify all signatures anyway,
and to increase the bandwidth cost of signatures by relaying
fake signatures ﬁrst. Furthermore, this optimization makes it
diﬃcult for a relay node to know when it’s ready to build a
compact certiﬁcate: the node might start building a compact
certiﬁcate, only to discover that one of the signatures that it
needs to reveal is not valid, requiring it to drop that signature
and restart the build. A non-trivial fraction of bad signatures
can lead to many such restarts. To avoid the complexity and
to achieve more predictable resource consumption, we chose
to avoid this optimization.
It is also important to limit the number of attestors that
are allowed to contribute signatures to the compact certiﬁcate,
because otherwise an adversary who can form a large number
of attestor identities can force relay nodes to handle and
maintain in memory a large number of signatures. This can be
addressed by capping the number of attestors for the purposes
of compact certiﬁcates to some moderate number—say, the
top 1 million accounts by weight—as long as all nodes in the
system agree on which precise subset of accounts constitutes
the set of attestors.
B. Adversarial nodes: When to create a certiﬁcate?
In a decentralized setting, there is a tension regarding
when to form a compact certiﬁcate. On the one hand, it
is desirable to form a compact certiﬁcate quickly, so that
relay nodes can stop maintaining the set of all signatures in
memory, attestors can stop re-transmitting their signatures (as
we describe in the next subsection), and the compact certiﬁcate
can be used sooner to convince veriﬁers. On the other hand,
the total weight of all signatures at a relay node grows over
time, as more signatures arrive from diﬀerent attestors. Thus,
waiting for more signatures to arrive enables a smaller compact
certiﬁcate (because a higher signedWeight implies a lower
numReveals, per Section V-B).
6A convenient scheme is to choose the oﬀset pseudorandomly based on
the public key of the signer.
636
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:26:28 UTC from IEEE Xplore.  Restrictions apply. 
This tension is exacerbated by the presence of adversarial
nodes. In a decentralized setting, any relay node should be able
to create a compact certiﬁcate; however, if one of those nodes
was adversarial, it could create a compact certiﬁcate with
the lowest acceptable signedWeight (and thus the largest
possible numReveals), leading to a larger-than-necessary
certiﬁcate.
To address this tension, we implement a decaying threshold
for signedWeight of an acceptable compact certiﬁcate. The
threshold decays with time, where time is measured by the
round number of the latest block. The creation of the compact
certiﬁcate can start at the time that corresponds to the end of
the window for sending signatures (from the previous section).
At that time, the threshold is initialized to totalWeight (i.e.,
requiring signatures from every attestor); the threshold decays
linearly towards provenWeight (i.e., the lowest acceptable
value for signedWeight) time goes on. At any given time,
nodes in the system will accept a compact certiﬁcate only if
its signedWeight is at least the current threshold value. The
decay rate should be gradual enough to allow honest nodes to
propose the best compact certiﬁcate they can construct, while
still allowing the system to make progress (by forming at least
some compact certiﬁcate) in a reasonable time frame.
In order for the nodes to have a consistent view of the
current threshold (and thus have an agreement on whether
a compact certiﬁcate is acceptable), they must agree on the
time (round number) at which a compact certiﬁcate appears.
In Algorand, a convenient way to ensure that each proposed
compact certiﬁcate appears at an unambiguous round number
is to include the compact certiﬁcate (attesting to an earlier
block) as part of a (later) block; the compact certiﬁcate is
then said to appear at the round number of the block that
contains it.
C. Fault tolerance: Retransmitting signatures
It is important that compact certiﬁcates can be formed even
if network or node failures occur during signature collection, as
long as a suﬃcient set of nodes comes back online afterwards.
To this end, we follow a simple rule: nodes must durably store
their attestors’ signatures until they see that a corresponding
compact certiﬁcate is durably stored by the system. In a
blockchain setting, storing the compact certiﬁcate on the
blockchain itself provides a convenient way of ensuring the
durability of the compact certiﬁcate, and thus making it safe
to delete the input signatures that would have been necessary
for creating the certiﬁcate.
Nodes periodically retransmit their stored signatures, so that
a compact certiﬁcate can be formed even if the signatures were
lost when they were ﬁrst sent over the network. In particular,
each node periodically (de-synchronized, just like during the
initial sending) sends out all of its stored signatures to the
relays to which it is connected. When a relay receives a
signature that it already knows, it does not relay this signature
immediately; the relay will resend that signature on its own
retransmission schedule. On the other hand, when a relay
receives a new signature for the ﬁrst time, it will immediately
relay it to other nodes, to ensure timely propagation.
637
In the common case, we expect that network-level re-
transmission (e.g., TCP) should ensure reliable message
propagation, so the above retransmission plan should not start
until after the initial transmission time window plus the decay
time. This ensures that, in the common case, signatures for
a compact certiﬁcate are sent at most once by each node to
each of its connected relays.
Acknowledgments
We thank Alessandro Chiesa for clarifying the results of
[10], Chris Peikert for a careful reading of our proof, Fraser
Brown for editorial feedback, and Max Justicz for suggestions
on and review of our implementation. We thank Sebastian
Faust and the anonymous referees of both the real and the
shadow program committees of IEEE S&P for help improving
our presentation. The work of G.V. was performed while the
author was at Algorand.
References
[1] Jae Hyun Ahn, Matthew Green, and Susan Hohenberger.
Synchronized aggregate signatures: new deﬁnitions, con-
structions and applications. In ACM CCS 2010, October
2010.
[2] Moreno Ambrosin, Mauro Conti, Ahmad Ibrahim,
Gregory Neven, Ahmad-Reza Sadeghi, and Matthias
Schunter. SANA: Secure and scalable aggregate network
attestation. In ACM CCS 2016, October 2016.
[3] Scott Ames, Carmit Hazay, Yuval Ishai, and Muthura-
makrishnan Venkitasubramaniam. Ligero: Lightweight
sublinear arguments without a trusted setup. In ACM
CCS 2017, October / November 2017.
[4] Ali Bagherzandi, Jung Hee Cheon, and Stanislaw Jarecki.
Multisignatures secure under the discrete logarithm
assumption and a generalized forking lemma. In ACM
CCS 2008, October 2008.
[5] Ali Bagherzandi and Stanislaw Jarecki. Multisignatures
using proofs of secret key possession, as secure as the
Diﬃe-Hellman problem. In SCN 08, September 2008.
[6] Mihir Bellare and Gregory Neven. Multi-signatures in
the plain public-key model and a general forking lemma.
In ACM CCS 2006, October / November 2006.
[7] Mihir Bellare and Phillip Rogaway. Random oracles are
practical: A paradigm for designing eﬃcient protocols.
In ACM CCS 93, November 1993.
[8] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael
Riabzev. Scalable zero knowledge with no trusted setup.
In CRYPTO 2019, Part III, August 2019.
[9] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran
Tromer, and Madars Virza. SNARKs for C: Verifying
program executions succinctly and in zero knowledge.
In CRYPTO 2013, Part II, August 2013.
[10] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas
In TCC 2016-B,
Interactive oracle proofs.
Spooner.
Part II, October / November 2016.
[11] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and
Madars Virza. Scalable zero knowledge via cycles of
elliptic curves. In CRYPTO 2014, Part II, August 2014.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:26:28 UTC from IEEE Xplore.  Restrictions apply. 
[12] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and
Madars Virza. Succinct non-interactive zero knowledge
for a von Neumann architecture. In USENIX Security
2014, August 2014.
[13] Iddo Bentov, Ariel Gabizon, and Alex Mizrahi. Cryp-
In FC 2016
tocurrencies without proof of work.
Workshops, February 2016.
[14] Daniel J. Bernstein, Niels Duif, Tanja Lange, Peter
Schwabe, and Bo-Yin Yang. High-speed high-security
signatures. In CHES 2011, September / October 2011.
[15] Daniel J. Bernstein, Niels Duif, Tanja Lange, Peter
Schwabe, and Bo-Yin Yang. High-speed high-security
Journal of Cryptographic Engineering,
signatures.
2(2):77–89, September 2012.
[16] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran
Tromer. From extractable collision resistance to succinct
non-interactive arguments of knowledge, and back again.
In ITCS 2012, January 2012.
[17] Nir Bitansky, Alessandro Chiesa, Yuval Ishai, Rafail
Ostrovsky, and Omer Paneth. Succinct non-interactive
arguments via linear interactive proofs. In TCC 2013,
March 2013.
[18] Alexandra Boldyreva. Threshold signatures, multisig-
natures and blind signatures based on the gap-Diﬃe-
Hellman-group signature scheme. In PKC 2003, January
2003.
[19] Dan Boneh, Benedikt Bünz, and Ben Fisch. Batching
techniques for accumulators with applications to IOPs
In CRYPTO 2019, Part I,
and stateless blockchains.
August 2019.
[20] Dan Boneh, Justin Drake, Ben Fisch, and Ariel Gabizon.
Eﬃcient polynomial commitment schemes for multiple
points and polynomials. Cryptology ePrint Archive,
Report 2020/081, 2020. https://eprint.iacr.org/2020/081.
[21] Dan Boneh, Manu Drijvers, and Gregory Neven. Com-
pact multi-signatures for smaller blockchains. In ASI-
ACRYPT 2018, Part II, December 2018.
[22] Dan Boneh, Craig Gentry, Ben Lynn, and Hovav
Shacham. Aggregate and veriﬁably encrypted signatures
from bilinear maps. In EUROCRYPT 2003, May 2003.
[23] Kyle Brogle, Sharon Goldberg, and Leonid Reyzin.
Sequential aggregate signatures with lazy veriﬁcation
from trapdoor permutations - (extended abstract).
In
ASIACRYPT 2012, December 2012.
[24] Benedikt Bünz, Ben Fisch, and Alan Szepieniec. Trans-
In EURO-
parent SNARKs from DARK compilers.
CRYPT 2020, Part I, May 2020.
[25] Mike Burmester, Yvo Desmedt, Hiroshi Doi, Masahiro
Mambo, Eiji Okamoto, Mitsuru Tada, and Yuko Yoshifuji.
A structured ElGamal-type multisignature scheme. In
PKC 2000, January 2000.
[26] Vitalik Buterin. Ethereum: A next-generation smart
contract and decentralized application platform, 2014.
[27] Benedikt Bünz, Mary Maller, Pratyush Mishra, and Noah
Vesely. Proofs for inner pairing products and applications.
Cryptology ePrint Archive, Report 2019/1177, 2019.
https://eprint.iacr.org/2019/1177.
[28] Matteo Campanelli, Dario Fiore, Nicola Greco, Dimitris
Kolonelos, and Luca Nizzardo. Incrementally aggregat-
able vector commitments and applications to veriﬁable
decentralized storage. In ASIACRYPT, 2020.
[29] Ran Canetti, Rosario Gennaro, Stanislaw Jarecki, Hugo
Krawczyk, and Tal Rabin. Adaptive security for threshold
cryptosystems. In CRYPTO’99, August 1999.
[30] Claude Castelluccia, Stanislaw Jarecki, Jihye Kim, and
Gene Tsudik. A robust multisignatures scheme with
applications to acknowledgment aggregation. In SCN 04,
September 2005.
[31] Dario Catalano and Dario Fiore. Vector commitments
and their applications. In PKC 2013, February / March