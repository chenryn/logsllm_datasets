received on that connection. If this number is less than
the system limit, some challenge ACKs must have been
sent over the connection under test, as responses to the
spoofed packets.
Depending on the types of spoofed packets sent in
step 1, the off-path attacker can infer 1) if a connec-
tion speciﬁed by its four-tuple exists; 2) the next ex-
pected sequence number (RCV.NXT ) on the server (or
client); 3) the next expected ACK number (SND.UNA)
on the server (or client). It is intriguing to realize that
the three information leakages are enabled by the three
(and only three) conditions that trigger challenge ACKs
as described in §2.1, §2.2, and §2.3, respectively.
can be done in each case.
We elaborate below, the intuition on how the inference
Connection (four-tuple) inference. Figure 4 shows
the sequence of packets that an off-path attacker can send
to differentiate between the cases of (i) the presence or
(ii) the absence of an ongoing connection. In both cases,
the attacker sends the same sequence of packets. Dashed
lines represent packets with spoofed IP addresses.
In
the ﬁgure, the initial SYN-ACK packet is spoofed so
that it appears to come from the client. The counter for
the number of challenge ACKs that can be issued (100
initially) is tracked and depicted on the timeline of the
server.
The hope is that the initial spoofed SYN-ACK packet
will hit a correct four-tuple that corresponds to an active
connection between the client and the server. In such a
case (the left of Figure 4) the server will reply with a
challenge ACK2 (in accordance with the countermeasure
proposed to defend against blind SYN packet injection as
described in §2.1). At the same time, this will reduce the
global challenge ACK count from 100 to 99. In the case
where the spoofed SYN-ACK does not hit a correct four-
tuple (on the right of the ﬁgure), the server will simply
reply with a RST back to the corresponding client (as per
TCP standards).
The attacker will
then send 100 non-spoofed in-
window RST packets to exhaust the challenge ACK
count (this behavior is described in §2.2). In the active
connection case, since the challenge ACK count is 99,
the attacker can now observe only 99 challenge ACKs.
In the no connection case, the attacker can observe 100.
The difference in the number of challenge ACKs effec-
tively leaks the information about whether a tested four-
tuple corresponds to an active connection or not.
Sequence number inference. Assuming the attacker
has already identiﬁed a four-tuple that corresponds to
an active connection between the client and server, the
off-path attacker now needs to guess a valid sequence
number that is considered acceptable by the server. Fig-
ure 5 shows the sequence of packets that an attacker can
send to distinguish between the cases of (i) in-window
and (ii) out-of-window sequence number.
In the ﬁrst
case where the spoofed RST packet has an in-window
sequence number (but not the next expected sequence
number), as per the countermeasure proposed to defend
against blind RST packet injection as described in §2.2,
a challenge ACK is triggered and this reduces the global
challenge ACK count from 100 to 99. In the second case
where the sequence number falls outside of the window,
no challenge ACK will be generated (the global chal-
lenge ACK count remains at 100).
Similar to connection inference, the attacker will now
send 100 non-spoofed in-window RST packets to ex-
haust the challenge ACK count. Once again, based on
how many challenge ACKs are received, the attacker can
tell if the guessed sequence number in the spoofed RST,
is in-window or out-of-window.
ACK number inference. After an in-window se-
quence number of an active connection is identiﬁed, the
attacker now will need to guess a valid ACK number that
2The effect is the same as sending a spoofed SYN. However, send-
ing a SYN-ACK is generally more stealthy.
4
212  25th USENIX Security Symposium 
USENIX Association
Active connection
Server1
Client1
Off-path 
attacker
No connection
Server2
Client2
In-window seq
Server1
Client1
SYN-ACK
SYN-ACK
100 RSTs
100 RSTs
ACK 
count 
= 100
ACK 
count
= 99
ACK 
count
= 0
Challenge
ACK
Challenge
99 
ACKs
ACK 
count 
= 100
RST
Challenge
100 
ACKs
ACK 
count
= 0
ACK 
count
= 100
ACK 
count 
= 99
ACK 
count
= 0
Challenge
ACK
Challenge
99 
ACKs
ACK in challenge
ACK window
Client1
Server1
ACK 
count
= 100
ACK 
count
= 99
ACK 
count
= 0
Challenge
ACK
Challenge
99 
ACKs
Off-path 
attacker
RST
RST
Out-of-window seq
Client2
Server2
ACK 
count 
= 100
Drop
Off-path 
attacker
ACK
ACK
Other ACK
Client2
Server2
ACK 
count
= 100
Drop or 
accept
100 RSTs
100 RSTs
Challenge
100 
ACKs
ACK 
count
= 0
100 RSTs
100 RSTs
Challenge
100 
ACKs
ACK 
count 
= 0
Figure 4: Connection (four-tuple) test
Figure 5: Sequence number test
Figure 6: ACK number test
is considered acceptable by the server. Figure 6 shows
the sequence of packets that an attacker can send to dif-
ferentiate the cases of (i) ACKs in challenge ACK win-
dow and (ii) other ACK numbers. In the ﬁrst case where
the spoofed ACK packet has an ACK number in chal-
lenge ACK window (but with an in-window sequence
number), the server will reply with a challenge ACK, in
accordance with the countermeasure proposed to defend
against blind data packet injection (as described in §2.3).
Following the same procedure as before, an attacker can
infer if the guessed ACK number falls in the challenge
ACK window. As will be described in §5.2, this helps
the attacker to eventually identify the SND.NXT on the
server.
It is worth noting that once both the sequence number
and ACK number acceptable by the server are inferred,
an attacker can determine the sequence number and the
ACK number acceptable by the client as well. This is
because the RCV.NXT and SND.NXT on the server are
basically equivalent to SND.NXT and RCV.NXT on the
client [25, 18]. In practice, if the victim connection has
ongoing trafﬁc, the inferred sequence and ACK number
may shift as the attack is in progress. We discuss such
cases in §6.
An alternative approach for sequence number in-
ference. In some cases a large number of RST packets
observed in a short period time may be considered ab-
normal. Firewalls may even rate limit RST packets on a
per-connection basis. In order to alleviate this, one can
in fact replace RST packets with ACK packets, which
are likely to stay under the radar. As shown in Figure 3,
a challenge ACK will be sent when ACK number is in
challenge ACK window while sequence number is in-
window. Since the challenge ACK window space is at
least 1/4 of the entire 4G of the ACK number space,
one can send 4 packets with ACK numbers 0, 1G, 2G,
and 3G respectively and at least one packet will trigger
a challenge ACK if the guessed sequence number is in-
window. To understand why the challenge ACK window
is at least this large, we ﬁrst point out that the maximum
receive window size is 1G with the TCP window scaling
option (RFC 7323), which means that SND.MAX.WIN
cannot be larger than 1G. Therefore, according to deﬁ-
nition of the challenge ACK window described in §2.3,
it is at least 1G as well. Given this, every spoofed RST
packet sent earlier for sequence number inference is re-
placed by four ACK packets, which is less efﬁcient but
still effective. We have implemented and tested this al-
ternative approach for sequence number inference. How-
ever, to simplify the description, we assume the use the
original sequence number inference with RST packets in
the subsequent sections.
4 Off-Path Connection Reset Attack
In the previous section, we illustrate how the global chal-
lenge ACK rate limit can theoretically leak information
about an ongoing connection to an off-path attacker. In
this section, we focus on how to construct a practical
off-path connection reset attack that succeeds when a
spoofed RST arrives with a matching sequence number
of RCV.NXT . This requires an attacker to successfully
carry out both connection (four-tuple) inference and se-
quence number inference. As will be discussed, to con-
struct a realistic attack, several practical challenges need
to be overcome. We assume the threat model to be the
one in Figure 1 throughout the section, but the attack
works with the alternative threat model (Figure 2) as
well.
Goals and constraints. The main goal of the attack
is to quickly and reliably conduct the sequence number
inference and use it to reset an ongoing connection. The
faster the attack succeeds, the more potent the DoS effect
will be. However, the extent of the effect is subject to two
practical constraining factors: (i) The bandwidth may be
limited between the attacker and the victim (either server
or client). (ii) Packet loss may occur between the attacker
and victim, especially when they are far away. In this
section, we focus only on designing fast probing schemes
with given bandwidth constraints and leave the strategy
to deal with packet loss to §6.
USENIX Association  
25th USENIX Security Symposium  213
5
4.1 Time Synchronization
Challenge: As mentioned in §3, the challenge ACK rate
limit is on a per second basis. In other words, the counter
for the number of challenge ACK packets that can be is-
sued, gets reset each second. Therefore, it is critical that
in each cycle, all the spoofed and non-spoofed packets
sent from the attacker arrive within the same 1-second
interval, at the server.
One naive solution is that the attacker sends all those
packets in a very short period (say, 10 ms), to ensure
that the likelihood that they arrive within the same 1-
second interval is high. Unfortunately, in practice, this
solution does not work well since (i) many factors inﬂu-
ence packet delays and thus, the gaps between packet ar-
rival times at the receiver, might be much larger than the
gaps in their transmission times, (ii) such bursts of traf-
ﬁc are likely going to experience congestion and packet
loss. Thus, it is best for the attacker to synchronize with
the clock on the server, so that the attacker can spread the
trafﬁc over the 1-second interval, without worrying that
some packet arrivals may cross the boundary between
two 1-second intervals.
The most common way to synchronize time be-
tween two machines is using the Network Time Protocol
(NTP). But in practice, the attacker does not know if the
server uses NTP, or to what NTP server it connects to;
thus, it is not a reliable solution.
Solution: We propose a time synchronization strategy
based on the very side channel introduced by the chal-
lenge ACK rate limit. The idea is to send more than 200
in-window RST packets spread out evenly in one second
and check if we can see more than 100 challenge ACKs;
if so, this indicates that we have crossed the boundary be-
tween two one second intervals (and have therefore not
synced with the server yet). We then adjust the timing
for next round of probing (shift it just enough) until we
receive exactly the 100 challenge ACKs; in this case, we
have succeeded in synchronizing with the server clock.
The reason we choose 200 packets is two-fold: 1) We
are able to trigger at most 200 challenge ACKs no matter
how many RST packets we send. These 200 challenge
ACKs are triggered only when half of the RST packets
arrive before the start of a new 1-second interval and half
arrive after. 2) By evenly spreading the 200 packets over
a 1-second window, i.e., sending one packet every 5ms,
allows us to adjust the timing of the next round probing
with the ﬁnest granularity. Speciﬁcally, we show that the
time synchronization can be done in at most three rounds
of probing in an ideal case (without packet losses).
Round 1: As described before, the attacker sends 200
in-window RST packets to the server evenly spread out
over a 1-second window. The attacker then listens and
counts the number of received challenge ACK packets.
This value is stored as n1. Here, the attacker listens for
incoming packets for 2 seconds conservatively, before
sending any additional packets to make sure a 1-second
interval on the server has elapsed. Note that apart from
the 200 RST packets, no other packet is sent to the server
in this interval. If n1 equals 100, it means that all 200
RST packets all arrive in the same 1-second interval on
the server, thereby indicating that we have already syn-
chronized with the server. Otherwise, it must be true that
n1 > 100, in which case the attacker proceeds to the next
round.
Round 2: The attacker waits for 5ms (shifting the start
time of the probes by 5ms) and repeats the same process
as in the ﬁrst step. The number of received challenge