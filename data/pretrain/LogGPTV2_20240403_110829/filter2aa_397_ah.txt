会话固定
会话固定 
关于会话，需要关注的主要问题是会话标识的保密性问题。如果它是保密的，
就不会存在会话劫持的风险了。通过一个合法的会话标识，一个攻击者可以非常
成功地冒充成为你的某一个用户。 
一个攻击者可以通过三种方法来取得合法的会话标识： 
l 猜测 
l 捕获 
《PHP 安全基础详解》        www.528163.cn 提供 
l 固定 
PHP 生成的是随机性很强的会话标识，所以被猜测的风险是不存在的。常见
的是通过捕获网络通信数据以得到会话标识。为了避免会话标识被捕获的风险，
可以使用 SSL，同时还要对浏览器漏洞及时修补。 
小提示 
要记住浏览器会根据请求中的 Set-cookie 头部中的要求对之后所有的请求中
都包含一个相应的 Cookie 头部。最常见的是，会话标识会无谓的在对一些嵌入
资源如图片的请求中被暴露。例如，请求一个包含 10 个图片的网页时，浏览器
会发出 11 个带有会话标识的请求，但只有一个是有必要带有标识的。为了防止
这种无谓的暴露，你可以考虑把所有的嵌入资源放在有另外一个域名的服务器
上。 
会话固定是一种诱骗受害者使用攻击者指定的会话标识的攻击手段。这是攻
击者获取合法会话标识的最简单的方法。 
在这个最简单的例子中，使用了一个链接进行会话固定攻击： 
Click Here 
另外一个方法是使用一个协议级别的转向语句： 
header('Location: http://example.org/index.php?PHPSESSID=1234'); 
?> 
这也可以通过 Refresh 头部来进行，产生该头部的方法是通过真正的 HTTP
头部或 meta 标签的 http-equiv 属性指定。攻击者的目标是让用户访问包含有攻击
者指定的会话标识的 URL。这是一个基本的攻击的第一步，完整的攻击过程见
图 4-3 所示。 
Figure 4-3. 使用攻击者指定的会话标识进行的会话固定攻击 
如果成功了，攻击者就能绕过抓取或猜测合法会话标识的需要，这就使发起
更多和更危险的攻击成为可能。 
为了更好地使你理解这一步骤，最好的办法是你自己尝试一下。首先建立一
个名为 fixation.php 的脚本： 
session_start(); 
$_SESSION['username'] = 'chris'; 
?> 
确认你没有保存着任何当前服务器的 cookies，或通过清除所有的 cookies 以
确保这一点。通过包含 PHPSESSID 的 URL 访问 fixation.php： 
http://example.org/fixation.php?PHPSESSID=1234 
它建立了一个值为 chris 的会话变量 username。在检查会话存储区后发现
1234 成为了该数据的会话标识： 
$ cat /tmp/sess_1234username|s:5:"chris"; 
建立第二段脚本 test.php，它在$_SESSION[‘username’] 存在的情况下即
输入出该值： 
session_start(); 
if (isset($_SESSION['username'])) 
{ 
《PHP 安全基础详解》        www.528163.cn 提供 
echo $_SESSION['username']; 
} 
?> 
在另外一台计算机上或者在另一个浏览器中访问下面的 URL，同时该 URL
指定了相同的会话标识： 
http://example.org/test.php?PHPSESSID=1234 
这使你可以在另一台计算机上或浏览器中（模仿攻击者所在位置）恢复前面
在 fixation.php 中建立的会话。这样，你就作为一个攻击者成功地劫持了一个会
话。 
很明显，我们不希望这种情况发生。因为通过上面的方法，攻击者会提供一
个到你的应用的链接，只要通过这个链接对你的网站进行访问的用户都会使用攻
击者所指定的会话标识。 
产生这个问题的一个原因是会话是由 URL 中的会话标识所建立的。当没有
指定会话标识时，PHP 就会自动产生一个。这就为攻击者大开了方便之门。幸运
的是，我们以可以使用 session_regenerate_id( )函数来防止这种情况的发生。 
session_start(); 
if (!isset($_SESSION['initiated'])) 
{ 
session_regenerate_id(); 
$_SESSION['initiated'] = TRUE; 
} 
?> 
这就保证了在会话初始化时能有一个全新的会话标识。可是，这并不是防止
会话固定攻击的有效解决方案。攻击者能简单地通过访问你的网站，确定 PHP
给出的会话标识，并且在会话固定攻击中使用该会话标识。这确实使攻击者没有
机会去指定一个简单的会话标识，如 1234，但攻击者依然可以通过检查 cookie
或 URL（依赖于标识的传递方式）得到 PHP 指定的会话标识。该流程如图 4-4
所示。 
该图说明了会话的这个弱点，同时它可以帮助你理解该问题涉及的范围。会
话固定只是一个基础，攻击的目的是要取得一个能用来劫持会话的标识。这通常
用于这样的一个系统，在这个系统中，攻击者能合法取得较低的权限(该权限级
别只要能登录即可)，这样劫持一个具有较高权限的会话是非常有用的。 
如果会话标识在权限等级有改变时重新生成，就可以在事实上避开会话固定
的风险： 
$_SESSION['logged_in'] = FALSE; 
if (check_login()){ 
session_regenerate_id(); 
$_SESSION['logged_in'] = TRUE; 
} 
?> 
Figure 4-4. 通过首先初始化会话进行会话固定攻击 
《PHP 安全基础详解》        www.528163.cn 提供 
小提示 
我不推荐在每一页上重新生成会话标识。虽然这看起来确实是一个安全的方
法。但与在权限等级变化时重新生成会话标识相比，并没有提供更多的保护手段。
更重要的是，相反地它还会对你的合法用户产生影响，特别是会话标识通过 URL
传递时尤甚。用户可能会使用浏览器的访问历史机制去访问以前访问的页面，这
样该页上的链接就会指向一个不再存在的会话标识。 
如果你只在权限等级变化时重新生成会话标识，同样的情况也有可以发生，
但是用户在访问权限变更前的页面时，不会因为会话丢失而奇怪，同时，这种情
况也不常见。 
4.4. 会话劫持
会话劫持
会话劫持
会话劫持 
最常见的针对会话的攻击手段是会话劫持。它是所有攻击者可以用来访问其
它人的会话的手段的总称。所有这些手段的第一步都是取得一个合法的会话标识
来伪装成合法用户，因此保证会话标识不被泄露非常重要。前面几节中关于会话
暴露和固定的知识能帮助你保证会话标识只有服务器及合法用户才能知道。 
深度防范原则（见第一章）可以用在会话上，当会话标识不幸被攻击者知道
的情况下，一些不起眼的安全措施也会提供一些保护。作为一个关心安全的开发
者，你的目标应该是使前述的伪装过程变得更复杂。记住无论多小的障碍，都会
以你的应用提供保护。 
把伪装过程变得更复杂的关键是加强验证。会话标识是验证的首要方法，同
时你可以用其它数据来补充它。你可以用的所有数据只是在每个 HTTP 请求中的
数据： 
GET / HTTP/1.1Host: example.orgUser-Agent: 
Firefox/1.0Accept: text/html, image/png,  
image/jpeg, image/gif, */* 
Cookie: PHPSESSID=1234 
你应该意识到请求的一致性，并把不一致的行为认为是可疑行为。例如，虽
然 User-Agent(发出本请求的浏览器类型)头部是可选的，但是只要是发出该头部
的浏览器通常都不会变化它的值。如果你一个拥有 1234 的会话标识的用户在登
录后一直用 Mozilla Firfox 浏览器，突然转换成了 IE，这就比较可疑了。例如，
此时你可以用要求输入密码方式来减轻风险，同时在误报时，这也对合法用户产
生的冲击也比较小。你可以用下面的代码来检测 User-Agent 的一致性： 
session_start(); 
if (isset($_SESSION['HTTP_USER_AGENT'])) 
{ 
if ($_SESSION['HTTP_USER_AGENT'] != 
md5($_SERVER['HTTP_USER_AGENT'])) 
{ 
/* Prompt for password */ 
exit; 
} 
} 
《PHP 安全基础详解》        www.528163.cn 提供 
else 
{ 
$_SESSION['HTTP_USER_AGENT'] = 
md5($_SERVER['HTTP_USER_AGENT']); 
} 
?> 
我观察过，在某些版本的 IE 浏览器中，用户正常访问一个网页和刷新一个
网页时发出的 Accept 头部信息不同，因此 Accept 头部不能用来判断一致性。 
确保 User-Agent 头部信息一致的确是有效的，但如果会话标识通过 cookie
传递（推荐方式），有道理认为，如果攻击者能取得会话标识，他同时也能取得
其它 HTTP 头部。由于 cookie 暴露与浏览器漏洞或跨站脚本漏洞相关，受害者
需要访问攻击者的网站并暴露所有头部信息。所有攻击者要做的只是重建头部以
防止任何对头部信息一致性的检查。 
比较好的方法是产生在 URL 中传递一个标记，可以认为这是第二种验证的
形式（虽然更弱）。使用这个方法需要进行一些编程工作，PHP 中没有相应的功
能。例如，假设标记保存在$token 中，你需要把它包含在所有你的应用的内部链
接中： 
$url = array(); 
$html = array(); 
$url['token'] = rawurlencode($token); 
$html['token'] = htmlentities($url['token'], ENT_QUOTES, 'UTF-8'); 
?> 
Click Here 为了更方便地管理这个传递过程，你可能会把整个请求串放在一
个变量中。你可以把这个变量附加到所有链接后面，这样即便你一开始没有使用
该技巧，今后还是可以很方便地对你的代码作出变化。 
该标记需要包含不可预测的内容，即便是在攻击者知道了受害者浏览器发出
的 HTTP 头部的全部信息也不行。一种方法是生成一个随机串作为标记： 
$string = $_SERVER['HTTP_USER_AGENT']; 
$string .= 'SHIFLETT'; 
$token = md5($string); 
$_SESSION['token'] = $token; 
?> 
当你使用随机串时（如 SHIFLETT），对它进行预测是不现实的。此时，捕
获标记将比预测标记更为方便，通过在 URL 中传递标记和在 cookie 中传递会话
标识，攻击时需要同时抓取它们二者。这样除非攻击者能够察看受害者发往你的
应用所有的 HTTP 请求原始信息才可以，因为在这种情况下所有内容都暴露了。
这种攻击方式实现起来非常困难（所以很罕见），要防止它需要使用 SSL。 
有专家警告不要依赖于检查 User-Agent 的一致性。这是因为服务器群集中
的 HTTP 代理服务器会对 User-Agent 进行编辑，而本群集中的多个代理服务器
在编辑该值时可能会不一致。 
如果你不希望依赖于检查 User-Agent 的一致性。你可以生成一个随机的标
记： 
$token = md5(uniqid(rand(), TRUE)); 
《PHP 安全基础详解》        www.528163.cn 提供 
$_SESSION['token'] = $token; 
?> 
这一方法的安全性虽然是弱一些，但它更可靠。上面的两个方法都对防止会
话劫持提供了强有力的手段。你需要做的是在安全性和可靠性之间作出平衡。