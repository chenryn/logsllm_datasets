running environment with Chinese and English keyboards for analyzing malware be-
haviors. As shown in Figure 2, the parallel environments is constructed alongside with
malware’s execution, therefore, it prevents running the same sample by multiple times.
As long as our API labeling (introduced in Section 4) can cover the environment query,
we believe GOLDENEYE can automatically detect/expose all environment-sensitive be-
haviors of samples.
Our second novel design is to apply speculative execution in these parallel environ-
ments. Observing the limitation of existing work [37], which consumes a huge amount
of time and memory on rolling back the analysis on alternative paths, we apply the con-
cept of speculative execution [31], which refers to the situation when a computer system
performs some task that may not be actually needed but to trade off some other opti-
mize needs. The merit of applying speculative execution in our context is to keep the
execution forward as far as possible. Thus, we consider to construct multiple possible
environments online and speculatively execute malware in each environment instance.
Through determining the most possible malicious execution path, we can also deter-
mine what the running environment is in order to reach certain path.
To embrace speculative execution in our new problem domain, we need to solve new
technical challenges. First, since the executed instructions in each environment vary,
it is practically infeasible to predict the execution in an online dynamic fashion. We
solve this challenge by progressively performing the speculative execution at the basic
block level. In particular, we execute each basic block in all alternative environment
settings. Since there is no branch instruction inside each basic block, the instructions
are the same for all environments. When we reach the branch instruction at the end of
a block, we apply several heuristics to determine which is the possible malicious path.
Consequently, we reduce the space by only keeping the settings that most likely lead to
the desired path.
Second, speculative execution is essentially a trade-off scheme between speed and
space (i.e., trading more memory consumption for speedup) [31]. In our design, we also
try to reduce the memory consumption by two novel designs: (1) We only speculatively
execute the instructions that generate different results for different environments. We
choose to employ taint analysis to narrow down the scope to the instructions which
operate on environment-related data. (2) We monitor the memory usage to prevent the
explosion of alternative environments.
In general, we introduce the following speculative execution engine: We conduct
speculative execution at the granularity of code block to emulate the malware’s execu-
tion in multiple parallel environment spaces. We ﬁrst prefetch a block of instructions.
28
Z. Xu et al
Snapshot
Speculative Execution in 
Parallel Environments
C
D
D
A
B
C
D
A
B
A
B
B
Not Sensitive 
Node
A
A
Multi- Path Exploration
GoldenEye
Fig. 2. Illustration of Differences between GOLDENEYE (right) and Multi-path Exploration [37]
(left)
Next, we apply taint analysis on the pre-fetched instructions and taint each byte of
the API/instruction output (environment element) as the tainted source. The reason to
use taint analysis is to ﬁlter those instructions that are not related to the environment,
which can reduce the overhead of full speculative execution. We propagate tainted la-
bels and when we hit one instruction with the tainted operands, we accordingly update
the execution context in all alternative environments. We continue such propagation
until we reach the end of the block, which is a branch instruction. For the branch in-
struction, we determine whether it could be affected by the tainted bytes or not. If it is
an environment-sensitive branch, we continue to the next step, i.e., branch selection and
update. If not, speculative execution will start a new pre-fetch operation.
For environment-sensitive branches, we attempt to prevent the overhead caused by
roll-back operation in [37]. We design our scheme to proactively select the branches
based on the information provided in the speculative execution. The intuition is: if we can
tell which branch is more likely the malware author’s intended branch, we can dynam-
ically adjust the environment to enforce the malware to only execute some designated
branch. In principle, whenever we ﬁnd a branch that belongs to a possible malicious
path, we will re-examine the alternative environments and only select the environment
that could be used to enforce the desired branch. Our solution to ﬁnd the possible ma-
licious branch is to apply similar techniques as branch evaluation [47] to predict the
possible malicious branches. The detail will be presented in Section 4.2.
To differentiate GOLDENEYE with other approaches, we illustrate the high-level idea
of GOLDENEYE in Figure 2 by comparing with an existing multi-path exploration ap-
proach [37]. For the multi-path exploration approach (the left part in Figure 2), the
redundant overhead comes from exploring all the possible paths by depth-ﬁrst execu-
tion and storing roll-back snapshots for all deviation branches. GOLDENEYE works in
a different way. It applies branch prediction that follows a breath-ﬁrst execution scheme
to quickly locate possible malicious paths, which saves the effort of exploring all possi-
ble paths. Second, it enumerates all the possible alternative environments, e.g., ABCD
in Figure 2, dynamically. It ensures the analysis continuously keep forward and saves
GOLDENEYE: Efﬁciently and Effectively Unveiling Malware’s Targeted Environment
29
the roll-back operations. Thus, it is not necessary to store snapshots for every branch.
Lastly, we use taint analysis to skip many non-environment-sensitive branches to further
save the exploration overhead.
Meanwhile, from the ﬁgure we can also notice how the speculative execution tech-
nique is performed in parallel environments. Essentially, our speculative execution is
periodically progressing for each code block. We need to iterate all the environments
and synchronize their running results for each instruction in the code block. At the end
of a basic block, the parallel space will be curtailed and GOLDENEYE clears all the
environments settings that unlikely lead to targeted paths.
4 Detailed Design
4.1 Phase I: Pre-selection of Malware Corpus
The ﬁrst phase of GOLDENEYE is to quickly obtain the malware samples which are
candidates of environment-targeted malware. As deﬁned in Section 2.1, our criteria for
the pre-processing is to ﬁnd any malware that is sensitive to its running environment.
Our scheme of pre-selection is achieved by tainting the return values of certain envi-
ronment query API/instructions and tracking whether the tainted bytes affect the deci-
sion on some branch instructions, such as changing CFlag register. If the tested sample
is sensitive to its environment querying, we keep the sample for further steps.
API Labeling. The most common way for malware to query its running environment
is through certain system APIs/instructions. To capture malware’s environment queries,
we need to hook these APIs/instructions. Furthermore, it is important to derive all pos-
sible return values of these APIs/instructions because these return values are used to
deﬁne parallel denvironments. In GOLDENEYE, we label three categories of environ-
ment queries:
– Hook system-level environment query APIs. The operating system provides a large
set of system APIs to allow programmers query the running environment. They
have also been commonly used by malware to achieve the similar goal.
– Hook environment-related instructions. Some X86 instructions such as CPUID can
also be thought as a way to query environment information.
– Hook APIs with environment-related parameter(s). Some system ﬁles/registries can
be used to store environment conﬁguration. Thus, we also hook ﬁle/registry opera-
tion APIs and examine their parameters. If the parameters contain some keywords,
such as version, we also treat as a query attempt.
For each labeled API/instruction, we examine its return value as the reference to ini-
tialize parallel environments. In general, we construct one speculative execution context
for each possible return value. To narrow down the alternative choices of the environ-
ment, we deﬁne the following four basic sets of return values.
– BSET(n) deﬁnes a two-choice (binary) set. One example for NtOpenFile is
BSET(0) for the return value NTSTATUS, which accepts 0 (success) or other value
(failure).
– SET([...]) deﬁnes a normal enumeration of values, such as enumeration for LANGID
in the default system language.
– RANGE(A, B) set contains a range of possible return values.
30
Z. Xu et al
Based on these three sets, we construct the parallel contexts. For example, we simply
construct two parallel contexts for BSET(n) element. Note that a large amount of system
objects, whose querying API returns -1 as non-existence and random value as the object
handle, belong to this type. We consider all these objects as BSET(n) element.
For SET([...]) with n different values, we accordingly initialize n parallel settings
based on the context.
For RANGE(A, B) set, we examine whether the range set can be divided into some
semantically independent sub-ranges. For example, the different range of native call
NtQuerySystemInformation’s return speciﬁes different type of the system in-
formation. For these cases, we construct one context for each semantically-independent
sub-range. Otherwise, we initially construct one context for each possible value.
One current limitation of our labeling is that we cannot provide parallel environ-
ments for API functions whose return values are not enumerable. For example, some
malware logic may depend on the content of certain ﬁle. However, it is not possible
for us to construct all possible (correct) ﬁle contents in advance. One possible solution
is to combine symbolic execution [22] in the analysis step at the cost of extra analysis
overhead. However, to achieve better balance between efﬁciency and effectiveness, we
do not adopt such solution at the moment.
4.2 Phase II: Dynamic Environment Analysis
Dynamic environment analysis is the main component of GOLDENEYE. In this section,
we present its detailed design. We use Conﬁcker [43] worm’s logic as a working exam-
ple. As illustrated in Figure 3, in this example, Conﬁcker worm queries the existence of
speciﬁc mutex and the version of the running operating system. The malicious logic is
triggered only after the check succeeds.
+58 push eax
+59 push 0
+5B push 0
+5D call OpenMutexA
+63 mov esi, eax
+65 test esi, esi
+67 jz short loc_8E7C4D
…
EIP
C: Branch Selection
Low Preference Branch
High Preference Branch
Base Execution Context
EAX:0x5FE32EED
EBX:0x0000001D
……
A: Environment Initialization
Base Execution Context
EAX:0x00000000
EBX:0x0000001D
……
Alternative Context
EAX:0x7FFFFFFF
Base Execution Context
EAX:0x00000000
ESI:0x00000000
ZF: 0x0
……
Alternative Context
EAX:0x7FFFFFFF
ESI:0x7FFFFFFF
ZF: 0x1
B: Speculative Execution
+9c pop edi
+9D pop esi
+9E pop ebx
+9F leave
+A0 retn 0Ch
Sub_8E799E
..
l 
+3C
..
+69
..
+89
l
l
call GetModuleFileNameA
call GetComputerNameA
call CreateThread
Loc_8E7C4D:
+81 call GetVersion
+87 cmp al, 5
+89 jb short loc_8E7C60
EIP
Loc_8E7C60:
+8B push [ebp + hModule]
+8E call sub_8E799E
EIP
+93 pop ecx
EIP
Create a Global 
Mutex return 
0x7FE34321 
D:Environment Update
Base Execution Context
EAX:0x7FE34321
ESI:0x7FE34321
ZF: 0x1
……
Base Execution 
Context
EAX:0x00000007
ESI:0x7FE34321
ZF: 0x1
……
Fig. 3. Working Example of GOLDENEYE
GOLDENEYE: Efﬁciently and Effectively Unveiling Malware’s Targeted Environment
31
Initialization of Malware Environment Analysis. After the preprocessing, we ﬁrst
initialize the analysis by constructing parallel environments when we ﬁnd malware’s en-
vironment
query. We
of
environment elements as
environment with
running
deﬁne
a
env = {e1, ..., ei, ...en}
a
set
For each ei, it is deﬁned as a tuple:
where identif ier uniquely denotes the name of each environment element, such as
the mutex name or the title of GUI windows; AP I is the invoked API to query the
element; type speciﬁes the type of element, such as system setting (system language,
os version, etc.) or system objects (the existence of ﬁles, registries, etc.); and value
states what are possible values of each element, such as true/false or a set of hex values.
Context Maintenance of Speculative Execution. After GOLDENEYE captures mal-
ware’s environment query, a set of initialized environment contexts are maintained
by our speculative execution engine. The main overhead of our speculative execution
comes from continuously maintaining those parallel contexts.
To save space, the key design for context maintenance is based on our progressive
execution scheme. Since the execution in parallel can be naturally synchronized by each
instruction (it follows the same code block(s)), we choose to only record the modiﬁca-
tion of parallel contexts. As illustrated in Figure 3 Step A and B, we have no need
to maintain the full execution context, such as all general registers value and execu-
tion stack, in each parallel space. We only track the different data, which is EAX and
ESI in the example. We maintain such alternative contexts using a linked list. When
an environment update operation starts, we only update the dirty bytes that have been
modiﬁed since the previous block(s). In further, we organize each progressive context
using linked-list to track the modiﬁed bytes.
Taint-assisted Speculative Execution. Another key design to prevent redundant over-
head is to applying taint tracking on environment-sensitive data. In particular, we taint
each byte of the environment query’s return and propagate the tainted labels by each
instruction. When we encounter an instruction without tainted operation, we continue
with concrete execution. Otherwise, when we encounter an instruction with the tainted
operands, we accordingly update the execution context in all alternative environments.
We continue such propagation until we reach the end of a basic block. For the branch
instruction, we also determine whether it could be affected by the tainted bytes or not
(whether CFlag has been tainted or not). If it is an environment-sensitive branch, we