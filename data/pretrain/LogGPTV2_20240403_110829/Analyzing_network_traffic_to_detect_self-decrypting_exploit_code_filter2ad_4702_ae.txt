sal and backwards data-ﬂow analysis. First, forward traver-
sal is performed to decode the byte sequences, starting at
address 0006 where the seeding instruction fnstenv 14/28
byte[esp-0c] is found. The process is continued till instruc-
tion xor [ebx + 15], edi at address 0010, a target instruc-
tion, is encountered. Then a round of backward data ﬂow
analysis is triggered to ﬁnd previous instructions that deter-
mine the operands of this target instruction. ebx and edi
are variables of the operands of this target instruction. Their
values are deﬁned by instruction pop ebx at address 000F
and mov edi, f35e0f78 at address 000A. Instruction pop
ebx reads a 4-byte value from the stack referenced through
register esp by default. The left task is to ﬁnd the ac-
tual value stored at [esp] that will be used to deﬁne or
assigned to ebx through pop ebx. According to the seman-
tics of fnstenv, it will store the program counter (P C) of
a FPU instruction preceding it at twelve bytes from the ad-
dress speciﬁed. Hence, the P C is stored at [esp] in this ex-
ample. Finally, backward traversal is performed starting at
the seeding instruction. Hence instruction fcmovb st(0),
st(7) is easily found, according to the method described
above.
After constructing a chain of instructions through the two-
way traversal, the execution of instructions in the chain is
then emulated, as described below.
Detection of Self-modifying Decryption Routine.
Self-modifying decryption routines are detected by perform-
ing emulated execution of the already found decryption in-
structions. The purpose of this execution is to determine the
address to which the target instruction writes a value, or the
address to which the target instruction branches, depending
on the type of the target instruction. As far as the emula-
tion is concerned, the decryption code of the input network
traﬃc is mapped to a random virtual address space of the
vulnerable program that the exploit code targets.
The emulation is limited in the following way. Instruction
emulation proceeds until a decryption loop is detected, or
an illegal instruction is encountered. If a memory location
is modiﬁed that is within the emulated address space of the
code, this fact is noted. It is evidence for the existence of a
decryption routine. If the address of the target instruction
branches points to the ﬂow itself, the forward traversal is
continued, otherwise it is stopped.
In a favorable situation, emulated instruction execution
only occurs for a small number of instructions. This is be-
cause execution ends once a self-modifying decryption loop
is revealed. For a decryption loop not using self-modifying
techniques, only one traversal of the loop is needed to stop
execution.
3.3 Decryption Routine Veriﬁcation
The previous phase detects the presence of a possible de-
(cid:1)(cid:1)(cid:1)(cid:1)(cid:2)(cid:2)(cid:2)(cid:2)(cid:3)(cid:4)(cid:2)(cid:5)(cid:6)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:7)(cid:8)(cid:9)(cid:2)(cid:10)(cid:5)(cid:7)(cid:11)(cid:2)(cid:10)(cid:5)(cid:7)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:1)(cid:1)(cid:1)(cid:12)(cid:2)(cid:2)(cid:2)(cid:2)(cid:13)(cid:14)(cid:2)(cid:5)(cid:15)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:16)(cid:5)(cid:17)(cid:8)(cid:18)(cid:19)(cid:2)(cid:20)(cid:21)(cid:22)(cid:1)(cid:23)(cid:11)(cid:2)(cid:20)(cid:21)(cid:22)(cid:15)(cid:23)(cid:1)(cid:1)(cid:1)(cid:24)(cid:2)(cid:2)(cid:2)(cid:2)(cid:19)(cid:4)(cid:2)(cid:12)(cid:3)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:17)(cid:8)(cid:18)(cid:2)(cid:5)(cid:25)(cid:11)(cid:2)(cid:12)(cid:3)(cid:1)(cid:1)(cid:1)(cid:26)(cid:2)(cid:2)(cid:2)(cid:2)(cid:13)(cid:6)(cid:2)(cid:15)(cid:24)(cid:2)(cid:12)(cid:24)(cid:2)(cid:16)(cid:24)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:16)(cid:27)(cid:20)(cid:21)(cid:10)(cid:27)(cid:18)(cid:2)(cid:4)(cid:24)(cid:28)(cid:12)(cid:29)(cid:19)(cid:30)(cid:21)(cid:10)(cid:31)(cid:10)(cid:20) !(cid:1)(cid:5)"(cid:1)(cid:1)(cid:1)#(cid:2)(cid:2)(cid:2)(cid:19)(cid:16)(cid:2)(cid:15)(cid:29)(cid:2)(cid:1)(cid:16)(cid:2)$(cid:10)(cid:2)(cid:16)(cid:3)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:17)(cid:8)(cid:18)(cid:2)(cid:10)(cid:13)%(cid:11)(cid:2)(cid:16)(cid:3)$(cid:10)(cid:1)(cid:16)(cid:15)(cid:29)(cid:1)(cid:1)(cid:1)&(cid:2)(cid:2)(cid:2)$(cid:19)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2) (cid:8) (cid:2)(cid:10)(cid:19)(cid:7)(cid:1)(cid:1)(cid:4)(cid:1)(cid:2)(cid:2)(cid:2)(cid:2)(cid:3)(cid:4)(cid:2)(cid:15)(cid:19)(cid:2)(cid:4)$(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:7)(cid:8)(cid:9)(cid:2)(cid:31)(cid:10)(cid:19)(cid:7)’(cid:4)$"(cid:11)(cid:2)(cid:10)(cid:13)%(cid:1)(cid:1)(cid:4)(cid:3)(cid:2)(cid:2)(cid:2)(cid:2)(cid:1)(cid:3)(cid:2)(cid:15)(cid:19)(cid:2)(cid:4)$(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:14)(cid:13)(cid:13)(cid:2)(cid:10)(cid:13)%(cid:11)(cid:2)(cid:31)(cid:10)(cid:19)(cid:7)’(cid:4)$"(cid:1)(cid:1)(cid:4)(cid:26)(cid:2)(cid:2)(cid:2)(cid:2)(cid:29)(cid:3)(cid:2)(cid:19)(cid:19)(cid:2)(cid:1)(cid:19)(cid:2)(cid:19)(cid:5)(cid:2)(cid:1)(cid:26)(cid:5)(cid:15)(cid:2)(cid:16)(cid:5)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:5)(cid:17) (cid:2)(cid:31)(cid:10)(cid:19)(cid:7)’(cid:5)(cid:15)(cid:1)(cid:26)(cid:19)(cid:5)(cid:1)(cid:19)"(cid:11)!(cid:24)()(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)*(cid:10)(cid:27)(cid:5)(cid:9)(cid:30) (cid:21)(cid:10)(cid:13)(cid:2) (cid:14)(cid:30)(cid:25)(cid:8)(cid:14)(cid:13)+(cid:22)(cid:14)(cid:23)(cid:22)(cid:19)(cid:23)(cid:1)(cid:1)(cid:1)(cid:1)(cid:2)(cid:2)(cid:2)(cid:2)(cid:3)(cid:4)(cid:2)(cid:5)(cid:6)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:7)(cid:8)(cid:9)(cid:2)(cid:10)(cid:5)(cid:7)(cid:11)(cid:2)(cid:10)(cid:5)(cid:7)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:1)(cid:1)(cid:1)(cid:12)(cid:2)(cid:2)(cid:2)(cid:2)(cid:13)(cid:14)(cid:2)(cid:5)(cid:15)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:16)(cid:5)(cid:17)(cid:8)(cid:18)(cid:19)(cid:2)(cid:20)(cid:21)(cid:22)(cid:1)(cid:23)(cid:11)(cid:2)(cid:20)(cid:21)(cid:22)(cid:15)(cid:23)(cid:1)(cid:1)(cid:1)(cid:24)(cid:2)(cid:2)(cid:2)(cid:2)(cid:19)(cid:4)(cid:2)(cid:12)(cid:3)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:17)(cid:8)(cid:18)(cid:2)(cid:5)(cid:25)(cid:11)(cid:2)(cid:12)(cid:3)(cid:1)(cid:1)(cid:1)(cid:26)(cid:2)(cid:2)(cid:2)(cid:2)(cid:13)(cid:6)(cid:2)(cid:15)(cid:24)(cid:2)(cid:12)(cid:24)(cid:2)(cid:16)(cid:24)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:16)(cid:27)(cid:20)(cid:21)(cid:10)(cid:27)(cid:18)(cid:2)(cid:4)(cid:24)(cid:28)(cid:12)(cid:29)(cid:19)(cid:30)(cid:21)(cid:10)(cid:31)(cid:10)(cid:20) !(cid:1)(cid:5)"(cid:1)(cid:1)(cid:1)#(cid:2)(cid:2)(cid:2)(cid:19)(cid:16)(cid:2)(cid:15)(cid:29)(cid:2)(cid:1)(cid:16)(cid:2)$(cid:10)(cid:2)(cid:16)(cid:3)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:17)(cid:8)(cid:18)(cid:2)(cid:10)(cid:13)%(cid:11)(cid:2)(cid:16)(cid:3)$(cid:10)(cid:1)(cid:16)(cid:15)(cid:29)(cid:1)(cid:1)(cid:1)&(cid:2)(cid:2)(cid:2)$(cid:19)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2) (cid:8) (cid:2)(cid:10)(cid:19)(cid:7)(cid:1)(cid:1)(cid:4)(cid:1)(cid:2)(cid:2)(cid:2)(cid:2)(cid:3)(cid:4)(cid:2)(cid:15)(cid:19)(cid:2)(cid:4)$(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:7)(cid:8)(cid:9)(cid:2)(cid:31)(cid:10)(cid:19)(cid:7)’(cid:4)$"(cid:11)(cid:2)(cid:10)(cid:13)%(cid:1)(cid:1)(cid:4)(cid:3)(cid:2)(cid:2)(cid:2)(cid:2)(cid:1)(cid:3)(cid:2)(cid:15)(cid:19)(cid:2)(cid:4)$(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:14)(cid:13)(cid:13)(cid:2)(cid:10)(cid:13)%(cid:11)(cid:2)(cid:31)(cid:10)(cid:19)(cid:7)’(cid:4)$"(cid:1)(cid:1)(cid:4)(cid:26)(cid:2)(cid:2)(cid:2)(cid:2)(cid:29)(cid:3)(cid:2)(cid:5)(cid:3)(cid:2)(cid:1)(cid:24)(cid:14)(cid:13)(cid:13)(cid:2)(cid:10)(cid:19)(cid:7)(cid:11)(cid:2)(cid:24)(cid:1)(cid:1)(cid:4)(cid:6)(cid:2)(cid:2)(cid:2)(cid:2)(cid:10)(cid:12)(cid:2)(cid:16)$(cid:25)(cid:8)(cid:8) (cid:2)(cid:1)(cid:1)(cid:4)(cid:1)()(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)*(cid:10)(cid:27)(cid:5)(cid:9)(cid:30) (cid:21)(cid:10)(cid:13)(cid:2) (cid:14)(cid:30)(cid:25)(cid:8)(cid:14)(cid:13)+cryption routine by ﬁnding the loops in its control ﬂow struc-
ture. During the detection of the loop, a form of GetP C
code should be available to ﬁnd a pointer to the encrypted
payload. The data ﬂow of the detected loop is analyzed to
improve the overall accuracy of the method. Two properties
of of decryption routines are exploited for this purpose.
The ﬁrst property is that in a detected loop, there must
be a memory-write instruction that uses indirect addressing.
That is, a register is used to contain an oﬀset that partly
identiﬁes the location where data is to be read or written. In
addition, the memory address pointers to the input network
traﬃc. IA-32 [3] oﬀers 24 memory addressing modes which
can be classiﬁed into two categories - the direct and indirect
addressing. For direct addressing, the memory operand’s
address is speciﬁed directly in the instruction. For indi-
rect addressing, the memory operand’s address is referenced
through one or two registers. These registers oﬀer a base ad-
dress(stored in the base register) w/o an oﬀset value(stored
in the index register). A memory-write instruction using di-
rect addressing is unlikely the instruction that directly mod-
iﬁes the encrypted payload. The hard-coded address easily
results a fragile exploit code. (That is why the GetP C code
is needed). For instance, the instruction at address 000D
in ﬁgure 2 (a) is such an example. IA-64 architecture also
supports RIP/EIP-relative data addressing. The memory ad-
dress can be referred through RIP/EIP registers.
The second property is that the register holding the ad-
dress or oﬀset must be updated within the loop. Otherwise
the same memory location will be written over and over. In
our current prototype, we only look for instructions that will
update the register value in predictable and regular ways.
For instance, inc/dec/sub/add instructions are most favor-
able for updating the registers. Other instructions, such as
string instruction lods and loop instruction loop may also
be used to update the register which holds the address or the
oﬀset. Future work will generalize this analysis. A possible
way for the attackers to achieve the randomness is using a
sequence of push instructions to specify the decryption or-
der in the stack. The decryption loop then uses pop to get
the order and then decode iteratively.
A few implementation details are as follows. Each instruc-
tion in a cycle is inspected to determine if it satisﬁes the ﬁrst
property, according to its opcode and addressing mode. If
it is such an instruction, the cycle is cut to create an in-
struction sequence, with this instruction at the end. Then,
other instructions in the sequence are sliced out by check-
ing whether they have a data-ﬂow dependency on the target
instruction, using backward data ﬂow analysis.
For example, suppose an unwrapped cycle contains the in-
struction sequence inc eax, xchg eax,esi, xor [esi],ebx.
The ﬁrst two instructions are sliced out because of their ef-
fect on register esi, used in the ﬁnal instruction.
For checking the data ﬂow dependency of two instructions,
instructions are ﬁrst converted, through into a semantics-
preserving transformation, into an intermediate representa-
tion. This is helpful for overcoming code obfuscation tech-
niques used in metamorphic exploits. For instance, a well
crafted decryption routine may combine several processing
steps into a single instruction. The loop and lodsd instruc-
tions shown in ﬁgure 2 are examples.
4. EVALUATION
A prototype of the proposed method has been imple-
mented, and evaluated under realistic conditions. The re-
sults are described below.
4.1 Detection Rate
We tested the detection capability of the proposed ap-
proach on polymorphic exploits. These exploits were gen-
erated by two oﬀ-the-shelf polymorphic engines: ADMmu-
tate [5], and Clet [6]. These engines have been used in other
research papers for the same purpose [16, 14, 19, 18]. Also
tested were polymorphic exploits generated by the Metas-