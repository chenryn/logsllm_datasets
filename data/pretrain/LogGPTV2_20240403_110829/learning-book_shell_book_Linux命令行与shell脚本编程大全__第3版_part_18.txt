虽然zip命令能够很好地将数据压缩和归档进单个文件，但它不是Unix和Linux中的标准归档
工具。目前，Unix和Linux上最广泛使用的归档工具是tar命令。
tar命令最开始是用来将文件写到磁带设备上归档的，然而它也能把输出写到文件里，这种
用法在Linux上已经普遍用来归档数据了。
下面是tar命令的格式：
tazrfunction[optiona]  object1  object2
function参数定义了tar命令应该做什么，如表4-8所示。
表4-8tar命令的功能
功
长名称
描
A
-concatenate
将一个已有tar归档文件追加到另一个已有tar归档文件
-c
--create
创建一个新的tr归档文件
--diff
检查归档文件和文件系统的不同之处
--delete
从已有tr归档文件中删除
-Y
--append
追加文件到已有tar归档文件末尾
--1ist
列出已有tar归档文件的内容
-u
--update
将比tr归档文件中已有的同名文件新的文件追加到该tar归档文件中
X
extract
从已有tar归档文件中提取文件
每个功能可用选项来针对tar归档文件定义一个特定行为。表4-9列出了这些选项中能和tar
命令一起使用的常见选项。
表4-9tar命令选项
选
项
描
述
-C dix
切换到指定目录
-ffile
输出结果到文件或设备fi1e
-J
将输出重定向给bzip2命令来压缩内容
“D
保留所有文件权限
V
在处理文件时显示文件
2
将输出重定向给gzip命令来压缩内容
这些选项经常合并到一起使用。首先，你可以用下列命令来创建一个归档文件：
tar -cvf test,tar test/ test2/
上面的命令创建了名为test.tar的归档文件，含有test和test2目录内容。接着，用下列命令：
tar -tf test.tar
列出tar文件test.tar的内容（但并不提取文件）。最后，用命令：
tar -xvf test,tar
---
## Page 100
4.4小结
85
通过这一命令从tar文件test.tar中提取内容。如果tar文件是从一个目录结构创建的，那整个目
录结构都会在当前目录下重新创建。
如你所见，tar命令是给整个目录结构创建归档文件的简便方法。这是Linux中分发开源程序
源码文件所采用的普遍方法。
窍门下载了开源软件之后，你会经常看到文件名以.tgz结尾。这些是gzip压缩过的tar文件可以
用命令tar-zxvffilename.tgz未解压。
4.4小结
本章讨论了Linux系统管理员和程序员用到的一些高级bash命令。ps和top命令在判断系统的
状态时特别重要，能看到哪些应用在运行以及它们消耗了多少资源。
在可移动存储普及的今天，系统管理员常谈到的另一个话题就是挂载存储设备。mount命令
可以将一个物理存储设备挂载到Linux虚拟目录结构上。umount命令用来移除设备。
最后，本章讨论了各种处理数据的工具。sort工具能轻松地对大数据文件进行排序，便于
组织数据：grep实用工具能快速检索大数据文件来查找特定信息。Linux上有一些不同的文件压
缩工具，包括bzip2、gzip和zip。每种工具都能够压缩大型文件来节省文件系统空间。tar工
具能将整个目录都归档到单个文件中，方便把数据迁移到另外一个系统上。
下一章将讨论各种Linux shell及其使用。Linux允许你在多个shell之间进行通信，这一点在脚
本中创建子shell时非常有用。
---
## Page 101
第5章
理解shell
本章内容
探究shell的类型
理解shell的父/子关系
口别出心裁的子shell用法
口探究内建的shell命令
去一探shell进程的究竞了。要想理解shell，得先理解一些CLI。
shell不单单是一种CLI。它是一个时刻都在运行的复杂交互式程序。输人命令并利用shel来
运行脚本会出现一些既有趣又令人困惑的问题。搞清楚shell进程以及它与系统之间的关系能够帮
助你解决这些难题，或是完全避开它们。
本章将会带你全面学习shell进程。你会了解到如何创建子shell以及父shell与子shell之间的关
系。探究各种用于创建子进程的命令和内建命令。另外还有一些shell的跨门和技巧等你一试。
5.1shell的类型
系统启动什么样的shell程序取决于你个人的用户ID配置。在/etc/passwd文件中，在用户ID记
终端仿真器，默认的shell程序就会开始运行。
在下面的例子中，用户christine使用GNU bash shel作为自己的默认shel程序：
$ cat /etc/passvd
Christine1x:501:501:Chriatine B:/hone/Chriatine:/bin/bash
( - + + J
bash shel程序位于/bin目录内。从长列表中可以看出/bin/bash（bash shell）是一个可执行程序：
 18 -1F /bin/bash
-rwxr-xr-x. 1 root root 938832Jul 18 2013 /bin/bash*
---
## Page 102
5.1shell 的类型
87
本书所使用的CentOS发行版中还有其他一些shell程序。其中包括tesh，它源自最初的C shell：
S 18 -1F /bin/tcsh
-rMxr-xr-x. 1 root root 387328 Feb 21 2013 /bin/tcsh*
另外还包括ash shell的Debian版：
S 18 -1F /bin/dash
-rwxr-xr-x. 1 root root 109672 0et 17 2012 /bin/dash*
最后，C shell的软链接（参见第3章）指向的是tcsh shell;
S 18 -1r /bin/csh
1rwxrwxrwx. 1 root root 4 Mar 18 15116 /bin/csh -> tcsh*
这些shell程序各自都可以被设置成用户的默认shell。不过由于bash shell的广为流行，很少有
人使用其他的shell作为默认shell。
说明第1章对各种shell有一个简单的描述。如果你想进一步学习GNU bash shell之外的shell，第
23章提供了更多的相关信息。
默认的交互shell会在用户登录某个虚拟控制台终端或在GUI中运行终端仿真器时启动。不过
还有另外一个默认shell是/bin/sh，它作为默认的系统shell，用于那些需要在启动时使用的系统shell
脚本。
你经常会看到某些发行版使用软链接将默认的系统shell设置成bashshell，如本书所使用的
CentOS发行版：
1rwxrwxrwx. 1 root root 4 Max 18 15:05 /bin/ah => bash
S 1s -1 /bin/sh
但要注意的是在有些发行版上，默认的系统shell和默认的交互shell并不相同，例如在Ubuntu
发行版中：
S cat /etc/passwd
chx1at:ine:x:1000 :1000 :Chr 1at1ne, *, : /home /chz1at1ne : /bin/baah
[ - - .]
S 1s -1 /bin/sh
1raxrwxrwx 1 root xoot 4 Apr 22 12:33 /bin/ah -> dash
注意，用户christine默认的交互shell是/bin/bash，也就是bash shell。但是作为默认系统shell
的/bin/sh被设置为dash shell。
---
## Page 103
88
第5章理解shell
窍门对bash shell脚本杂说，这两种不同的shell（默认的交互shell和默认的系统shell）会造成问
题。一定要阔读第11章中有关bash shell脚本首行的语法委求，以避免这些麻烦。
并不是必须一直使用默认的交互shell。可以使用发行版中所有可用的shell，只需要输人对应
的文件名就行了。例如，你可以直接输人命令/bin/dash来启动dash shell。
$ /bin/dash
除启动了dash shell程序之外，看起来似乎什么都没有发生。提示符s是dash shell的CLI提示符。
可以输人exit来退出dash shell。
$ exit
exit
$
这一次好像还是什么都没有发生，但是dashshell程序已经退出了。为了理解这个过程，我们
将在下一节中探究登录shell程序与新启动的shell程序之间的关系。
5.2shell的父子关系
用于登录某个虚拟控制器终端或在GUI中运行终端仿真器时所启动的默认的交互shell，是一
个父shell。本书到目前为止都是父shell提供CLI提示符，然后等待命令输人。
在CLI提示符后输人/bin/bash命令或其他等效的bash命令时，会创建一个新的shell程序。
这个shell程序被称为子shell（child shell）。子shell也拥有CLI提示符，同样会等待命令输人。
当输人bash、生成子shell的时候，你是看不到任何相关的信息的，因此需要另一条命令帮助
我们理清这一切。第4章中讲过的ps命令能够派上用场，在生成子shell的前后配合选项-E来使用。
J- Bd S
UID
501
PID
1841
PPID C STIME TTY
1840 0 11:50 pta/0
TIHE CND
501
2429 1841 4 13 :44 pta/0
qeeq- 00=00=00
I- ed 00=00=00
$ bash
 ps -f
UID
Ala 3KIaS 3CIddCId
501
TIHE CND
243 0
1841
1841
1.840
0 13:44 pts/0
o/d s=Tt 0
00 :00:00 -bash
501
2444 2430 1 13:44 pta/0
00 :00 :00 bash
501
I- ed 00=00=00
$
第一次使用ps-F的时候，显示出了两个进程。其中一个进程的进程ID是1841（第二列），
运行的是bash shel程序（最后一列）。另一个进程（进程ID为2429）对应的是命令ps-f。
---
## Page 104
5.2shell的父子关系
89
说明进程就是正在运行的程序。bashshell是一个程序，当它运行的时候，就成为了一个进程。
一个运行着的shell就是某种进程而己。因此，在说到运行一个bash shell的时候，你经常会
看到“shel”和“进程”这两个词交换使用。
输人命令bash之后，一个子shell就出现了。第二个ps-f是在子shell中执行的。可以从显示
结果中看到有两个bash shell程序在运行。第一个bash shel程序，也就是父shell进程，其原始进程
ID是1814。第二个bash shelI程序，即子shel进程，其PID是2430。注意，子shell的父进程ID（PPID）
是1841，指明了这个父shell进程就是该子shell的父进程。图5-1展示了这种关系。
父shell
shell
发出命令：
创建子shell,
发出命令：
bash
p8-f
图5-1bash shell进程的父子关系
在生成子shell进程时，只有部分父进程的环境被复制到子shelI环境中。这会对包括变量在内
的一些东西造成影响，我们会在第6章中谈及相关的内容。
子shell（child shell，也叫subshell）可以从父shel中创建，也可以从另一个子shell中创建。
$ p8
-f
UID
PIDPPIDC STIME TTY
501
TIME CMD
501
1841
2532
1841
0P8T
1 14:22 pts/0
0 11:50 pts/0
 0 0 : 00 : 0 0  bash
00:00:00 ps -f
S bash
$ bash
S bash
S ps --forest
ALL GId
00:00:00 bash
TIME CMD
1841 pts/0
0/eqd εe5z
00 : 00 : 00
_ bash
2562 pt8/0
2546 pts/ 0
00 : 00 : 00
00 :00 :00
_ba.sh
_bash
2576 ptα/0
00 : 00 : 00
P&
在上面的例子中，bash命令被输人了三次。这实际上创建了三个子shell。ps-forest命令
展示了这些子shell间的嵌套结构。图5-2中也展示了这种关系。
---
## Page 105
06
第5章理解shell
父shell
创建
bash的千shell
发出命令：
子-shell
发出命令：
bash
bash
创建子shell
bash的曾孙shell
创建
bash的孙shell
发出命令：
-子-shell
发出命令：
--forest
bash
图5-2子shell的嵌套关系
P-f命令也能够表现子shel的嵌套关系，因为它能够通过PPID列显示出谁是谁的父进程。
$ pa
 f
501
UID
PID
PPID
0/sd ns+it 0
AId 3KI&S 3
TIHE CND
1841
1840