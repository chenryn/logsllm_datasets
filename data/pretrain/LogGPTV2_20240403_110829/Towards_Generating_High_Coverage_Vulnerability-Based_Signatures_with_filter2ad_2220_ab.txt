To overcome these limitations, we propose to use a constraint-guided approach by
monitoring the program execution, performing symbolic execution to generate path
predicates, and generating new inputs that will go down a different path. This constraint-
guided exploration is similar in spirit to recent work on using symbolic execution for
automatic test case generation [30, 31, 32]. However, simply applying those techniques
does not scale to real-world programs, given the exponential number of paths to explore.
In fact, in Bouncer [17] the authors acknowledge that they wanted to use a constraint-
guided approach but failed to do so due to the large number of paths that need to be
explored and thus had to fall back to the heuristics-based probing approach.
To make the constraint-guided exploration feasible and effective we have incorpo-
rated two other key characteristics into our approach as described below.
Protocol-level constraints. Previous symbolic execution approaches generate what we
call stream-level conditions, i.e., constraints that are evaluated directly on the stream
of input bytes. Such stream-level conditions in turn generate stream-level signatures,
which are also speciﬁed at the byte level. However, previous work has shown that
Towards Generating High Coverage Vulnerability-Based Signatures
167
signatures are better speciﬁed at the protocol-level instead of the byte level [6, 18].
We call such signatures protocol-level signatures.
Our contribution here is to show that, by lifting stream-level conditions to protocol-
level conditions, so that they operate on protocol ﬁelds rather than on the input bytes, we
can make the constraint-guided approach feasible, as using constraints at the protocol-
level hugely reduces the number of paths to be explored compared to using stream-level
conditions. The state reduction is achieved in two ways. First, the parsing logic often
introduces huge complexity in terms of the number of execution paths that need to be
analyzed. For example, in our experiments, 99.8% of all constraints in the HTTP vul-
nerabilities are generated by the parsing logic. While such parsing constraints need to be
present in the stream-level conditions, they can be removed in the protocol-level condi-
tions. Second, the stream-level conditions introduced by the parsing logic ﬁxes the ﬁeld
structure to be the same as in the original exploit message, for example ﬁxing variable-
length ﬁelds to have the same size as in the original exploit message, and ﬁxing the
ﬁeld sequence to be the same as in the exploit message (when protocols such as HTTP
allow ﬁelds to be reordered). Unless the parsing conditions are removed the resulting
signature would be very easy to evade by an attacker by applying small variations to
the ﬁeld structure of the exploit message. Finally, the vulnerability point reachability
predicates at the protocol level are smaller and easier to understand by humans.
Merging execution paths. The combination of protocol-level conditions with
constraint-guided exploration is what we call protocol-level constraint-guided explo-
ration, an iterative process that incrementally discovers new paths leading to the vul-
nerability point. Those paths need to be added to the vulnerability point reachability
predicate. The simplistic approach would be to blindly explore new paths by revers-
ing conditions and at the end create a vulnerability point reachability predicate that is
a disjunction (i.e., an enumeration) of all the discovered paths leading to the vulnera-
bility point. Such approach has two main problems. First, blindly reversing conditions
produces a search space explosion, since the number of paths to explore becomes ex-
ponential in the number of conditions, and much larger than the real number of paths
that exist in the program. We explain this in detail in Section 4. In addition, merely
enumerating the discovered paths generates signatures that quickly explode in size.
To overcome those limitations, we utilize the observation that the program execution
may fork at one condition into different paths for one processing task, and then merge
back to perform another task. For example, a task can be a validation check on the input
data. Each independent validation check may generate one or multiple new paths (e.g.,
looking for a substring in the HTTP URL generates many paths), but if the check is
passed then the program moves on to the next task, which usually merges the execution
back into the original path. Thus, in our exploration, we use a protocol-level exploration
graph to identify such potential merging points. This helps alleviate the search space
explosion problem, and allows our exploration to quickly reach high coverage.
2.4 Architecture Overview
We have implemented our approach in a system called Elcano. The architecture of
Elcano is shown in Figure 2. It comprises of two main components: the constraint
168
J. Caballero et al.
Exploit
Program
Vulnerability 
point
Protocol 
specification
 Execution 
Monitor
Test result
Execution trace
Message 
format
Protocol 
parser
Field constraint 
chain
Constraint 
extractor
Exploration 
module
Vulnerability 
point 
reachability 
predicate
New input
Fig. 2. Elcano architecture overview. The darker color modules are given, while the lighter color
components have been designed and implemented in this work.
extractor and the exploration module, and two off-the-shelf assisting components: the
execution monitor and the parser.
The overall exploration process is an iterative process that incrementally explores
new execution paths. In each iteration (that we also call test), an input is sent to the
program under analysis, running inside the execution monitor. The execution monitor
produces an execution trace that captures the complete execution of the program on
the given input, including which instructions were executed and the operands content.
The execution monitor also logs the test result, i.e., whether the vulnerability point was
reached or not during the execution. In addition, the parser extracts the message format
for the input, according to the given protocol speciﬁcation.
Then, given the execution trace and the message format, the constraint extractor ob-
tains the ﬁeld constraint chain. The ﬁeld constraint chain is conceptually similar to the
path predicate used in previous work on automatic test case generation, but the condi-
tions are at the protocol-level and each condition is tagged with additional information.
We detail the ﬁeld constraint chain and its construction in Section 3.
The exploration module maintains the protocol-level exploration graph, which stores
the current state of the exploration, i.e., all the execution paths that have been so far
explored. Given the ﬁeld constraint chain, the exploit message and the test result, the
exploration module merges the new ﬁeld constraint chain into the current protocol-level
exploration graph. Then, the exploration module uses the protocol-level exploration
graph to select a new path to be explored and generates a new input that will lead
the program execution to traverse that path. Given the newly generated input, another
iteration begins. We detail the exploration module in Section 4.
The process is started with the initial exploit message and runs iteratively until there
are no more paths to explore or a user-speciﬁed time-limit is reached. At that point
the exploration module outputs the VPRP. The VPRPs produced by Elcano are written
using the Vine language [33] with some extensions for string operations [34]. The Vine
language is part of the Bitblaze binary analysis infrastructure [35].
3 Extracting the Protocol-Level Path-Predicate
In this section we present the constraint extractor, which given an execution trace, pro-
duces a ﬁeld constraint chain. The architecture of the constraint extractor is shown in
Figure 3. First, given the execution trace the path predicate extractor performs symbolic
execution with the input represented as a symbolic variable and extracts the path pred-
icate, which is essentially the conjunction of all branch conditions dependent on the
Towards Generating High Coverage Vulnerability-Based Signatures
169
Stream 
level path 
predicate
Message 
format
Field 
Condition 
Generator
Protocol 
specification
Input
Protocol 
level path 
predicate
Field 
Condition 
Generalizer
Field 
Constraint 
Chain
Path 
Predicate
Extractor
Execution 
trace
Fig. 3. Constraint Extractor Architecture. The darker color module is given, while the lighter
color components have been designed and implemented in this work.
symbolic input in the execution captured in the execution trace. The concept of sym-
bolic execution, the path predicate and how to compute it are well understood and have
been widely used in previous work including vulnerability signature generation [11,12]
and automatic test case generation [30,31]. Thus, we refer the interested reader to these
previous work for details.
The path predicate generated by previous work is at the stream-level, i.e., the con-
ditions are on raw bytes of the input. To enable constraint-guided exploration, Elcano
needs to lift the path predicate from the stream-level to the protocol-level, where the
conditions are instead on ﬁeld variables of the input. To make the distinction clear, we
refer to the path predicate at the stream-level the stream-level path-predicate, and the
path predicate at the protocol-level the protocol-level path-predicate. In addition, the
constraint extractor needs to remove the parsing conditions, which dramatically reduces
the exploration space and makes the constraint-guided exploration feasible.
To accomplish this, ﬁrst the ﬁeld condition generator lifts the stream-level path-
predicate to the protocol-level, and then the ﬁeld condition generalizer generalizes it
by removing the parsing conditions and outputs the ﬁeld constraint chain, which is
essentially the protocol-level path-predicate, where each condition is annotated with
some additional information and conditions are ordered using the same order as they
appeared in the execution.
3.1 The Field Condition Generator
Given the stream-level path-predicate generated by the path predicate extractor and
the message format of the input given by the parser, the ﬁeld condition generator out-
puts a protocol-level path-predicate. It performs this in two steps. First, it translates
each byte symbol INPUT[x] in the stream-level path-predicate into a ﬁeld symbol
FIELD fieldname [x - start(fieldname)] using the mapping produced
by the parser. Second, it tries to combine symbols on consecutive bytes of the same
ﬁeld. For example, the stream-level path-predicate might include the following con-
dition: (INPUT[6] << 8 | INPUT[7]) == 0. If the message format states that
inputs 6 and 7 belong to the same 16-bit ID ﬁeld, then the condition ﬁrst gets trans-
lated to (FIELD ID[0] << 8 | FIELD ID[1]) == 0 and then it is converted
to FIELD ID == 0 where FIELD ID is a 16-bit ﬁeld symbol.
The message format provided by the parser is a hierarchical tree, where one ﬁeld
may contain different subﬁelds, with the root of the tree representing the whole mes-
sage. For example, the linebuf variable in our running example represents the
170
J. Caballero et al.
Request-Line ﬁeld, which in turn contains 3 subﬁelds: Method, Request-URI,
and HTTP-Version. Thus, a condition such as: strstr(linebuf,"../") (cid:2)=
0 would be translated as strstr(FIELD Request-Line,"../") (cid:2)= 0. A con-
dition on the whole message would translate into a condition on the special MSG ﬁeld.
Beneﬁts. This step lifts the stream-level path-predicate to the protocol-level, breaking the
artiﬁcial constraints that the stream-level path-predicate imposes on the position of ﬁelds
inside the exploit message. For example, protocols such as HTTP allow some ﬁelds in
a message (i.e., all except the Request-Line/Status-Line) to be ordered differently with-
out changing the meaning of the message. Thus, two equivalent exploit messages could
have the same ﬁelds ordered differently and a byte-level vulnerability point reachability
predicate generated from one of them would not ﬂag that the other also reaches the vul-
nerability point. In addition, if variable-length ﬁelds are present in the exploit message,
changing the size of such ﬁelds changes the position of all ﬁelds that come behind it in
the exploit message. Again, such trivial variation of the exploit message could defeat
stream-level signatures. Thus, by expressing constraints using ﬁeld symbols, protocol-
level signatures naturally allow a ﬁeld to move its position in the input.
3.2 The Field Condition Generalizer
The ﬁeld condition generalizer takes as input the protocol-level path-predicate gener-
ated by the ﬁeld condition generator, the protocol speciﬁcation and the input that was
sent to the program and outputs a ﬁeld constraint chain where the parsing-related con-
ditions have been removed.
First, the ﬁeld condition generalizer assigns a symbolic variable to each byte of the
input and processes the input according to the given protocol speciﬁcation. This step
generates symbolic conditions that capture the constraints on the input which restrict
the message format of the input to be the same as the message format returned by the
parser on the given input. We term these conditions the parsing conditions. Then, the
ﬁeld condition generalizer removes the parsing conditions from the protocol-level path-
predicate by using a fast syntactic equivalence check. If the fast syntactic check fails,
the ﬁeld condition generalizer uses a more expensive equivalence check that uses a
decision procedure.
Beneﬁts. The parsing conditions in the protocol-level path-predicate over-constrain the
variable-length ﬁelds, forcing them to have some speciﬁc size (e.g., the same as in the
exploit message). Thus, removing the parsing conditions allows the vulnerability point
reachability predicate to handle exploit messages where the variable-length ﬁelds have a
size different than in the original exploit message. In addition, for some protocols such
as HTTP, the number of parsing conditions in a single protocol-level path-predicate
can range from several hundreds to a few thousands. Such a huge number of unneces-
sary conditions would blow up the size of the vulnerability point reachability predicate
and negatively impact the exploration that we will present in Section 4. Note that the
parsing conditions are enforced by the parser, so we can safely remove them from the
protocol-level path-predicate while still having the conditions enforced during the sig-
nature matching time. We refer the reader to the extended version for more details [36].
Towards Generating High Coverage Vulnerability-Based Signatures
171
The ﬁeld constraint chain. To assist the construction of the protocol-level exploration
graph (explained in Section 4), the constraint extractor constructs the ﬁeld constraint
chain using the generalized protocol-level path-predicate (after the parsing conditions
have been removed). A ﬁeld constraint chain is an enhanced version of the protocol-level
path-predicate where each branch condition is annotated with the instruction counter and
an MD5 hash of the callstack of the program at the branching point, and these annotated
branch conditions are put in an ordered chain using the same order as they appear in the
execution path.
4 Execution-Guided Exploration
In this section we present the exploration module, which adds the given ﬁeld constraint
chain to the protocol-level exploration graph, selects a new path to be explored and
generates an input that will traverse that path. That input is used to start a new iteration
of the whole process by sending it to the program running in the execution monitor.
Once there are no more paths to explore or a user-speciﬁed time-limit is reached, the
exploration module stops the exploration and outputs the VPRP.
Our exploration is based on a protocol-level exploration graph, which makes it sig-
niﬁcantly different from the traditional constraint-based exploration used in automatic
test case generation approaches [30, 31, 37]. Using a protocol-level exploration graph
provides two fundamental beneﬁts: 1) the exploration space is signiﬁcantly reduced, and
2) it becomes easy to merge paths, which in turn further reduces the exploration space,
and reduces the size of the vulnerability point reachability predicate. In this section,
we ﬁrst introduce the protocol-level exploration graph, next we present our intuition
for merging paths, and then we describe the exploration process used to extract the
vulnerability point reachability predicate.
4.1 The Protocol-Level Exploration Graph
The explorer dynamically builds a protocol-level exploration graph as the exploration
progresses. In the graph, each node represents an input-dependant branching point (i.e.,
a conditional jump) in the execution, which comprises the protocol-level condition and
some additional information about the state of the program when the branching point
was reached, which we explain in Section 4.2. Each node can have two edges repre-
senting the branch taken if the node’s condition evaluated to true (T) or false (F). We
call the node where the edge originates the source node and the node where the edge
terminates the destination node. If a node has an open edge (i.e, one edge is missing),
it means that the corresponding branch has not yet been explored.
4.2 Merging Execution Paths
When a new ﬁeld constraint chain is added to the protocol-level exploration graph, it is
important to merge all conditions in the ﬁeld constraint chain that are already present
in the graph. Failure to merge a condition creates a duplicate node, which in turn effec-
tively doubles the exploration space because all the subtree hanging from the replicated
172
J. Caballero et al.
node would need to be explored as well. Thus, as the number of duplicated nodes in-
creases, the exploration space increases exponentially.
The key intuition behind why merging is necessary is that it is common for new
paths generated by taking a different branch at one node, to quickly merge back into
the original path. This happens because programs may fork execution at one condition
for one processing task, and then merge back to perform another task. One task could
be a validation check on the input data. Each independent check may generate one or
multiple new paths (e.g., looking for a substring in the URI generates many paths), but if
the check is passed then the program moves on to the next task (e.g., another validation
check), which usually merges the execution back into the original path. For example,
when parsing a message the program needs to determine if the message is valid or not.
Thus, it will perform a series of independent validity checks to verify the values of the
different ﬁelds in the message. As long as checks are passed, the program still considers
the message to be valid and the execution will merge back into the original path. But, if
a check fails then the program will move into a very different path, for example sending
an error message.
The intuition on the merging is that two nodes can be merged if they represent the
same program point and they are reached with the same program state. To identify
the program point, each condition in the ﬁeld constraint chain is annotated with the
program’s instruction counter (eip) and an MD5 hash of the callstack, both taken at
the time the condition was executed. To identify the program state we use a technique
similar to the one introduced in [38] where we compute the set of all values (both
concrete and symbolic) written by the program during the execution up to the point
where the condition is executed. Thus, we merge nodes that satisfy 4 conditions: same
eip, same callstack hash, equivalent conditions, and same program state, where Elcano
queries the decision procedure to determine if two conditions are equivalent.
4.3 The Exploration Process
Figure 4 shows the architecture of the exploration module. It is comprised of three
components: the explorer, the prioritization engine, and the input generator, plus an off-
the-shelf decision procedure. The exploration process is comprised of 3 steps: (1) given
the ﬁeld constraint chain, the explorer adds it to the current protocol-level exploration
graph producing an updated graph; (2) given the updated protocol-level exploration