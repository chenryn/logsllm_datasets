Challenge
Personality
Random
Hash
PUF
ECC
Random
Hash
Response
Redundancy Information
Figure 1. Using control to improve a PUF.
• Given a challenge a PUF can compute a corresponding
response.
• The user is in the possession of her own private list
of CRPs originally generated by the PUF. The list is
private because only the user and the PUF know the
responses to each of the challenges in the list. We as-
sume that the user’s challenges can be public, and that
the user has established several CRPs with the PUF.
easily. An Error Correcting Code (ECC) can be used to take
noisy physical measurements and turn them into consistent
responses. Finally, an output random hash function decore-
lates the response from actual physical measurements, thus
making a model-building adversary’s task even harder.
User
untrusted
communication
channel
CPUF chip
Figure 2. Model for Applications
3.3.1. Giving a PUF Multiple Personalities
A possible concern with the use of PUFs is in the area of
privacy. Indeed, past experience shows that users feel un-
comfortable with processors that have unique identiﬁers,
because they feel that they can be tracked. Users could have
the same type of concern with the use of PUFs, given that
PUFs are a form of unique identiﬁer.
This problem can be solved by providing a PUF with
multiple personalities. The owner of the PUF has a param-
eter that she can control that allows her to show different
facets of her PUF to different applications. To do this, we
hash the challenge with a user-selected personality number,
and use that hash as the input to the rest of the PUF.
In this way, the owner effectively has many different
PUFs at her disposal, so third parties to which she has
shown different personalities cannot determine if they in-
teracted with the same PUF.
Section 5.4 goes into the details of the protocols that use
multiple personalities.
4. Models
4.1 Application Model
Figure 2 illustrates the basic model for applications using
the PUF.
• The user is the principal that wants to make use of the
computing capabilities of a chip.
• The user and the chip are connected to one another by
an untrusted public communication channel.
• The interface between the chip and the untrusted com-
munication channel is a PUF.
The responses are only known to the user and the PUF.
To establish this property we need a secure way of manag-
ing the CRPs as described in section 4.2. CPUFs control the
access to CRPs by algorithms which enable secure manage-
ment. Special attention will be given to protection against
man-in-the-middle-attacks while managing CRPs. To pre-
vent man-in-the-middle attacks, we prevent a user from ask-
ing for the response to a speciﬁc challenge, during the CRP
management protocols. This is a concern in the CRP man-
agement protocols, as, in these protocols, the chip sends
responses to the user. In the application protocols, the re-
sponses are used to generate MACs, and are never sent to
the user.
4.2. CRP Management Models
In our models for challenge-response pair management,
the user does not have CRPs for the CPUF yet, and would
like to establish its own private list of CRPs. For challenge-
response pair management, we introduce the following 3
new principals:
• manufacturer: the manufacturer is the principal that
made the chip with the CPUF. When the manufacturer
had the chip, and was in physical contact with the chip,
it established its own private list of CRPs. We assume
that, in the special situation when the manufacturer is
in physical contact with the CPUF chip, the communi-
cation channel between the manufacturer and the chip
is authentic and private. Though the manufacturer was
originally in physical contact with the chip, we assume
that it does not have the chip now.
• owner: the owner is the principal that controls access
to the CPUF. The owner has its own private list of
CRPs. The owner can be considered to be the principal
that bought the CPUF chip from the manufacturer.
Proceedings of the 18th Annual Computer Security Applications Conference (ACSAC(cid:146)02) 
1063-9527/02 $17.00 ' 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:32:29 UTC from IEEE Xplore.  Restrictions apply. 
• certiﬁer: the certiﬁer has its own private list of CRPs
for the CPUF, and is trusted by the user. The manu-
facturer of the CPUF chip can act as a certiﬁer to other
users. After the user has established its own private
list of CRPs, it may act as a certiﬁer to another user, if
the second user trusts the ﬁrst user. For example, if the
user trusts the owner of the chip, the owner of the chip
can also act as a certiﬁer.
We have 5 scenarios:
• bootstrapping: the manufacturer of the CPUF gets the
initial CRP from the CPUF.
• introduction: a user, who does not have any CRPs for
the CPUF, securely obtains a CRP from a certiﬁer.
• private renewal: after obtaining a CRP from a certiﬁer,
the user can use this CRP to generate his own private
list of CRPs.
• renewal: after generating his own private list of CRPs,
the user can use one of these to generate more private
CRPs.
• anonymous introduction: in anonymous introduction,
a user, who does not have any CRPs for the CPUF,
securely obtains a certiﬁed, anonymous, CRP for the
CPUF. The user is given a CRP that is certiﬁed by
the certiﬁer. However, in anonymous introduction, the
owner of the CPUF does not want to reveal to the user
which CPUF the user is being given a CRP to. Thus, at
the end of the protocol, the user knows that he has been
given a CRP that is certiﬁed by the certiﬁer, and can
use this CRP to generate other CRPs with the CPUF
and run applications using the CPUF. However, if the
user colludes with the certiﬁer, or other users with cer-
tiﬁed, anonymous CRPs to the CPUF, he will not be
able to use the CRPs to determine that he is communi-
cating with the same CPUF as them.
4.2.1. Bootstrapping
Figure 3 illustrates the model for bootstrapping. When a
CPUF has just been produced, the manufacturer generates
a CRP for it. We assume that, when the manufacturer gen-
erates this CRP, it is in physical contact with the chip, and
thus, the communication channel is private and authentic.
None of the other protocols make this assumption.
Manufacturer
CPUF chip
Figure 3. Model for Bootstrapping
4.2.2. Introduction
Figure 4 illustrates the model for CPUF introduction. In
introduction, the certiﬁer gives a CRP for the CPUF to the
user over a channel that is authentic and private.
As the certiﬁer knows the CRP the user is given, the cer-
tiﬁer can read all of the messages the user exchanges with
the CPUF using this CRP. The user, thus, needs to use the
private renewal protocol to generate his own private list of
CRPs.
Furthermore, as, in this scheme, the CPUF honors mes-
sages that are MAC’ed with a key generated from the re-
sponse of the CRP the certiﬁer has given to the user, the user
and the certiﬁer can collude to determine that they are com-
municating with the same CPUF. They, and other users who
use the same certiﬁer, may then be able to use this infor-
mation to track and monitor the CPUF’s transactions. The
CPUF’s owner can introduce the CPUF to the user using the
anonymous introduction protocol to deal with this problem.
Certifier
User
Figure 4. Model for Introduction
4.2.3. Private Renewal
Figure 5 illustrates the model for private renewal. The user
is assumed to already have a certiﬁed CRP. However, he
wants to generate a private list of CRPs. In this model, the
communication channel between the user and the CPUF is
untrusted.
User
untrusted
communication
channel
CPUF chip
Figure 5. Model for Private Renewal
4.2.4. Renewal
The model for renewal is the same as that for private re-
newal. The user is assumed to have already generated a
private list of CRPs, and would like to generate more pri-
vate CRPs with the CPUF. He may need more CRPs for his
applications, say.
4.2.5. Anonymous Introduction
Figure 6 illustrates the model for anonymous introduction.
Again, the user is the principal which does not have CRPs
Proceedings of the 18th Annual Computer Security Applications Conference (ACSAC(cid:146)02) 
1063-9527/02 $17.00 ' 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:32:29 UTC from IEEE Xplore.  Restrictions apply. 
for the CPUF yet, and would like to establish its own pri-
vate list of CRPs. The communication channels between the
certiﬁer, owner and user are secure (private and authentic).
The communication channels between each of these princi-
pals and the CPUF is untrusted. In our version of the pro-
tocol, the certiﬁer and owner communicate with each other,
the owner and user communicate with each other, and the
owner communicates with the CPUF. The certiﬁer and user
can potentially collude to determine if their CRPs are for
the same CPUF.
certifier
owner
untrusted
communication
channel
user
CPUF chip
Figure 6. Model for Anonymous Introduction
5. Protocols
We will now describe the protocols that are necessary
in order to use PUFs. These protocols must be designed
to make it impossible to get the response to a chosen chal-
lenge. Indeed, if that were possible, then we would be vul-
nerable to a man-in-the-middle attack that breaks nearly all
applications. The strategy that we describe is designed to be
deterministic and state-free to make it as widely applicable
as possible. Slightly simpler protocols are possible if these
constraints are relaxed.
5.1. Man-in-the-Middle Attack
Before looking at the protocols, let us have a closer look
at man-in-the-middle attack that we must defend against.
The ability to prevent this man-in-the-middle attack is
the fundamental difference between controlled and uncon-
trolled PUFs.
The scenario is the following. Alice wants to use a
challenge-response pair (CRP) that she has to interact with a
CPUF in a controlled way (we are assuming that the CRP is
the only shared secret between Alice and the CPUF). Oscar,
the adversary, has access to the PUF, and has a method that
allows him to extract from it the response to a challenge of
his choosing. He wants to impersonate the CPUF that Alice
wants to interact with.
At some point, in her interaction with the CPUF, Alice
will have to give the CPUF the challenge for her CRP so that
the CPUF can calculate the response that it is to share with
her. Oscar can read this challenge because up to this point
in the protocol Alice and the CPUF do not share any secret.
Oscar can now get the response to Alice’s challenge from
the CPUF, since he has a method of doing so. Once Oscar
has the response, he can impersonate the CPUF because he
knows everything Alice knows about the PUF. This is not at
all what Alice intended.
We should take note that in the above scenario, there is
one thing that Oscar has proven to Alice. He has proven
that he has access to the CPUF. In some applications, such
as the key cards from [Rav01], proving that someone has
access to the CPUF is probably good enough. However,
for more powerful examples such as certiﬁed execution that
we will cover in section 6.2, where we are trying to protect
Alice from the very owner of the CPUF, free access to the
PUF is no longer sufﬁcient.
More subtle forms of the man-in-the-middle attack ex-
ist. Suppose that Alice wants to use the CPUF to do what
we will refer to in section 6.2 as certiﬁed execution. Essen-
tially, Alice is sending the CPUF a program to execute. This
program executes on the CPUF, and uses the shared secret
that the CPUF calculates to interact with Alice in a secure
way. Here, Oscar can replace Alice’s program by a pro-
gram of his own choosing, and get his program to execute
on the CPUF. Oscar’s program then uses the shared secret
to produce messages that look like the messages that Alice
is expecting, but that are in fact forgeries.
5.2. Defeating the Man-in-the-Middle Attack
5.2.1. Basic CPUF Access Primitives
In the rest of this section, we will assume that the CPUF
is able to execute some form of program in a private (no-
body can see what the program is doing) and authentic (no-
body can modify what the program is doing) way.4 In some
CPUF implementations where we do not need the ability to
execute arbitrary algorithms, the program’s actions might in
fact be implemented in hardware or by some other means –
the exact implementation details make no difference to the
following discussion.
In this paper we will write programs in pseudo-code in
which a few basic functions are used:
• Output(arg1, ...) is used to send results out of
the CPUF. Anything that is sent out of the CPUF is
potentially visible to the whole world, except during
bootstrapping, where the manufacturer is in physical
possession of the CPUF.
• EncryptAndMAC(message, key) is used to en-
crypt and MAC message with key.
4In fact the privacy requirement can be substantially reduced. Only the
key material that is being manipulated needs to remain hidden.
Proceedings of the 18th Annual Computer Security Applications Conference (ACSAC(cid:146)02) 
1063-9527/02 $17.00 ' 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:32:29 UTC from IEEE Xplore.  Restrictions apply. 
• PublicEncrypt(message, key) is used to en-
crypt message with key, the public key.
• MAC(message, key) MACs message with key.
The CPUF’s control is designed so that the PUF can only
be accessed by programs, and only by using two primitive
functions: GetResponse and GetSecret. If f is the PUF,
and h is a publicly available random hash function (or in
practice some pseudo-random function) then the primitives
are deﬁned as:
GetResponse(P reChallenge) =