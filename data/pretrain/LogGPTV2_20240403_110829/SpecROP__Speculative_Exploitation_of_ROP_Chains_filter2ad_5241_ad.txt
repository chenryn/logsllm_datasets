# Table 4: Occurrence of Arithmetic (A) and Leakage (L) Gadgets
The table below lists the occurrence of arithmetic (A) and leakage (L) gadgets, with each type listed on the first and second rows respectively for each library.

| Register | A1 | A2 | A3 | A4 | A5 | A6 | L1 | L2 | L3 | L4 |
|----------|----|----|----|----|----|----|----|----|----|----|
| rsi      | 0  | 0  | 2  | 0  | 0  | 43 | 65 | 59 | 421| 110|
| rsp      | 0  | 0  | 0  | 10 | 0  | 0  | 9  | 15 | 186| 899|
| rbp      | 0  | 0  | 0  | 10 | 1  | 13 | 0  | 112| 48 | 159|
| r8       | 0  | 0  | 0  | 0  | 0  | 0  | 0  | 0  | 0  | 26 |
| r9       | 0  | 0  | 0  | 0  | 0  | 0  | 0  | 0  | 0  | 21 |
| r10      | 0  | 0  | 0  | 0  | 0  | 0  | 0  | 0  | 0  | 7  |
| r11      | 0  | 0  | 0  | 0  | 0  | 0  | 0  | 0  | 0  | 0  |
| r12      | 15 | 128| 8  | 34 | 0  | 0  | 0  | 8  | 7  | 2  |
| r13      | 33 | 106| 12 | 28 | 0  | 0  | 0  | 2  | 2  | 0  |
| r14      | 10 | 106| 6  | 41 | 0  | 0  | 2  | 23 | 2  | 0  |
| r15      | 3  | 35 | 15 | 32 | 0  | 0  | 0  | 0  | 0  | 1  |

## Insufficiency of CFI Mechanisms
Control-Flow Integrity (CFI) mechanisms are insufficient in mitigating speculative execution attacks. Hardware mechanisms, such as Intel's upcoming Control-Flow Enforcement Technology (CET), aim to limit speculative execution following a jump or call. However, as demonstrated by the example in Figure 2, SpecROP attacks can still be executed within the constraints imposed by early CET implementations. Since the set of targets allowed by CET is a superset of the actual set of targets, it remains to be seen if this imprecision can be exploited for speculative attacks. Newer proposals [22] suggest more comprehensive CFI under speculative execution.

## Related Work
### Hypothesis of Chained Code Gadgets
The hypothesis that an advanced Speculative Execution Attack (SEA) might chain multiple code gadgets through "multiple outstanding speculative changes of address stream caused by branch prediction" was first proposed in a white paper by ARM [23]. However, the paper lacks a detailed investigation into the practicality or existence of the required code gadgets. A similar hypothesis is also mentioned in a recent work by Canella et al. [24].

### Practical SEA Demonstrations
Mambretti et al. [25] demonstrated a practical SEA using multiple, chained gadgets to leak information following a mispredicted conditional branch. Unlike SpecROP, their attack requires a memory corruption bug in the victim binary to inject arbitrary return addresses onto the stack. The targets for the return instructions used to chain gadgets come from the overwritten stack. In contrast, SpecROP considers a stronger attacker model and is more stealthy, as the attacker cannot write arbitrary values to the victim’s stack and leaves no architecturally visible traces.

### Load Value Injection (LVI)
Bulck et al. [26] discussed the possibility of using Load Value Injection (LVI) to transiently poison the values loaded from memory and used by return and indirect jump instructions, thereby chaining gadgets like in Return-Oriented Programming (ROP) and Jump-Oriented Programming (JOP). LVI depends on faulty behavior in specific CPU models and requires the ability to induce faults in the victim on the load instructions. This makes the attack practical only against victims running within an SGX enclave. The paper does not comment on the practicality of causing multiple LVIs.

### Automated Program Analysis
Other works that use automated program analysis include Spectector [27] and oo7 [28]. Both aim to prevent Spectre-like attacks by performing static analysis of the code. oo7 applies taint analysis to binaries to check whether tainted values (secrets) can affect the outcome of conditional branches and speculative memory accesses. Spectector analyzes binaries for speculative code paths that leave microarchitectural traces which the architecturally intended path does not. Given the exact path through a SpecROP chain, Spectector would be able to detect that the instruction sequence is leaky. However, neither of these analyses can practically detect information leakage resulting from a SpecROP gadget chain due to the exponential growth in the number of sequences to analyze.

### SplitSpectre
SplitSpectre [29] proposes an approach to implement the Spectre attack where the target does not contain any single gadget that loads the secret and performs a dependent load, instead relying on an attacker with the ability to inject the second load on the natural control flow following the first. In contrast, SpecROP reuses existing gadgets for both loads. Spectector can detect that the code sequence used in SplitSpectre is leaky since there is a direct path between the dependent loads.

## Conclusion
Through SpecROP, we extend our understanding of practical speculative execution attacks by studying the ability to chain multiple gadgets. We demonstrate that poisoning multiple control flow instructions (returns and indirect jumps) is possible on modern processors. On tested processors, we can poison up to 4 indirect jumps with more than a 50% success rate. This opens the potential for attackers to use gadget chains instead of monolithic gadgets. Using the SpecROP technique, we show how generic gadgets can extend the reach of secrets accessible by an attacker, with an example of accessing and leaking the AES key from a pointer to the context. We also demonstrate a practical attack that can leak multiple plaintext bits from a victim during encryption using the OpenSSL library.

To facilitate the gadget search, we designed SpecFication, a tool for searching for generic SpecROP gadgets, from which we build up useful chains. Applying SpecFication to existing code bases, we found an abundance of small, generic SpecROP gadgets. We also studied possible mitigation techniques for SpecROP attacks. Our results lead us to believe that modern processors and programs are indeed vulnerable to a SpecROP attack, and that processors require hardware solutions for preventing malicious influence on branch/return prediction.

We have published the code for our experiments, proof-of-concepts, and SpecFication as open-source to enable others to further explore this methodology. The code is available at the GitHub repository: https://github.com/HexHive/specrop-public.

## Acknowledgments
We thank the anonymous reviewers for their insightful comments. This project has received funding from the European Research Council (ERC) under the European Union’s Horizon 2020 research and innovation program (grant agreement No. 850868).

## References
[1] P. Kocher, J. Horn, A. Fogh, D. Genkin, D. Gruss, W. Haas, M. Hamburg, M. Lipp, S. Mangard, T. Prescher, M. Schwarz, and Y. Yarom, “Spectre attacks: Exploiting speculative execution,” in 40th IEEE Symposium on Security and Privacy (S&P’19), 2019.
[2] H. Shacham, “The geometry of innocent flesh on the bone: return-into-libc without function calls (on the x86),” in Proceedings of the 2007 ACM Conference on Computer and Communications Security, CCS 2007, Alexandria, Virginia, USA, October 28-31, 2007, P. Ning, S. D. C. di Vimercati, and P. F. Syverson, Eds. ACM, 2007, pp. 552–561.
[3] V. van der Veen, D. Andriesse, M. Stamatogiannakis, X. Chen, H. Bos, and C. Giuffrida, “The Dynamics of Innocent Flesh on the Bone: Code Reuse Ten Years Later,” in CCS, Oct. 2017.
[4] T. K. Bletsch, X. Jiang, V. W. Freeh, and Z. Liang, “Jump-oriented programming: a new class of code-reuse attack,” in Proceedings of the 6th ACM Symposium on Information, Computer and Communications Security, ASIACCS 2011, Hong Kong, China, March 22-24, 2011, B. S. N. Cheung, L. C. K. Hui, R. S. Sandhu, and D. S. Wong, Eds. ACM, 2011, pp. 30–40.
[5] E. M. Koruyeh, K. N. Khasawneh, C. Song, and N. B. Abu-Ghazaleh, “Spectre returns! speculation attacks using the return stack buffer,” in 12th USENIX Workshop on Offensive Technologies, WOOT 2018, Baltimore, MD, USA, August 13-14, 2018, C. Rossow and Y. Younan, Eds. USENIX Association, 2018.
[6] A. Bhattacharyya, A. Sandulescu, M. Neugschwandtner, A. Sorniotti, B. Falsafi, M. Payer, and A. Kurmus, “Smotherspectre: Exploiting speculative execution through port contention,” in Proceedings of the 2019 ACM SIGSAC Conference on Computer and Communications Security, CCS 2019, London, UK, November 11-15, 2019, L. Cavallaro, J. Kinder, X. Wang, and J. Katz, Eds. ACM, 2019, pp. 785–800.
[7] Y. Yarom and K. Falkner, “FLUSH+RELOAD: A high resolution, low noise, L3 cache side-channel attack,” in Proceedings of the 23rd USENIX Security Symposium, San Diego, CA, USA, August 20-22, 2014, K. Fu and J. Jung, Eds. USENIX Association, 2014, pp. 719–732.
[8] M. Schwarz, M. Schwarzl, M. Lipp, J. Masters, and D. Gruss, “Netspectre: Read arbitrary memory over network,” in Computer Security - ESORICS 2019 - 24th European Symposium on Research in Computer Security, Luxembourg, September 23-27, 2019, Proceedings, Part I, ser. Lecture Notes in Computer Science, K. Sako, S. Schneider, and P. Y. A. Ryan, Eds., vol. 11735. Springer, 2019, pp. 279–299.
[9] S. Schirra, “Ropper - rop gadget finder and binary information tool,” http://scoding.de/ropper/, 2014.
[10] L. De Moura and N. Bjørner, “Z3: An efficient SMT solver,” in International conference on Tools and Algorithms for the Construction and Analysis of Systems. Springer, 2008, pp. 337–340.
[11] N. A. Quynh, “Capstone: Next-gen disassembly framework,” Black Hat USA, vol. 5, no. 2, pp. 3–8, 2014.
[12] S. Heule, E. Schkufza, R. Sharma, and A. Aiken, “Stratified synthesis: Automatically learning the x86-64 instruction set,” in Programming Language Design and Implementation (PLDI). ACM, June 2016.
[13] S. Dasgupta, D. Park, T. Kasampalis, V. S. Adve, and G. Rosu, “A complete formal semantics of x86-64 user-level instruction set architecture,” in Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI 2019, Phoenix, AZ, USA, June 22-26, 2019, K. S. McKinley and K. Fisher, Eds. ACM, 2019, pp. 1133–1148.
[14] P. Turner, “Retpoline: a software construct for preventing branch-target-injection,” https://support.google.com/faqs/answer/7625886, 2018.
[15] M. Yan, J. Choi, D. Skarlatos, A. Morrison, C. W. Fletcher, and J. Torrellas, “Invisispec: Making speculative execution invisible in the cache hierarchy (corrigendum),” in Proceedings of the 52nd Annual IEEE/ACM International Symposium on Microarchitecture, MICRO 2019, Columbus, OH, USA, October 12-16, 2019. ACM, 2019, p. 1076.
[16] V. Kiriansky, I. A. Lebedev, S. P. Amarasinghe, S. Devadas, and J. S. Emer, “DAWG: A defense against cache timing attacks in speculative execution processors,” in 51st Annual IEEE/ACM International Symposium on Microarchitecture, MICRO 2018, Fukuoka, Japan, October 20-24, 2018. IEEE Computer Society, 2018, pp. 974–987.
[17] O. Weisse, I. Neal, K. Loughlin, T. F. Wenisch, and B. Kasikci, “NDA: Preventing speculative execution attacks at their source,” in Proceedings of the 52nd Annual IEEE/ACM International Symposium on Microarchitecture, MICRO 2019, Columbus, OH, USA, October 12-16, 2019. ACM, 2019, pp. 572–586.
[18] Intel Corporation, “Deep dive: Indirect branch restricted speculation,” https://software.intel.com/security-software-guidance/insights/deep-dive-indirect-branch-restricted-speculation, accessed: 2020-03.
[19] ——, “Deep dive: Indirect branch predictor barrier,” https://software.intel.com/security-software-guidance/insights/deep-dive-indirect-branch-predictor-barrier, accessed: 2020-03.
[20] ——, “Deep dive: Single thread indirect branch predictors,” https://software.intel.com/security-software-guidance/insights/deep-dive-single-thread-indirect-branch-predictors, accessed: 2020-03.