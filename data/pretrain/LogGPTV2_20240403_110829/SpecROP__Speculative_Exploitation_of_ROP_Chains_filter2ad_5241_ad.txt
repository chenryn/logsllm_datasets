0
0
2
0
0
43
rsi
65
59
421
110
0
0
0
10
0
0
9
15
rsp
186
899
32
643
1
43
0
10
1
13
0
112
rbp
48
159
3
231
0
0
0
1
0
0
0
60
r8
0
26
13
8
0
0
0
0
0
0
0
0
r9
0
21
29
8
0
0
0
0
0
0
0
r10
0
7
2
36
0
0
0
0
0
0
0
0
r11
0
0
0
360
0
0
0
0
0
0
0
0
r12
15
128
8
34
0
0
0
8
7
2
0
8
r13
33
106
12
28
0
0
0
2
2
0
0
13
r14
10
106
6
41
0
0
2
23
2
0
0
16
r15
3
35
15
32
0
0
0
0
0
1
0
46
Table 4: Occurrence of arithmetic (A) and leakage (L) gadgets, listed on the ﬁrst and second rows respectively for each library
CFI mechanisms are insufﬁcient. Hardware mechanisms in-
clude Intel’s upcoming CET technology [21] which plans to
limit speculative execution following a jump or call. However,
as we see with the example in Figure 2, SpecROP attacks
are still possible within the limits imposed by the early im-
plementations1. Since the set of targets allowed by CET is
a superset of the actual set of targets, it remains to be seen
if this imprecision can be used for speculative exploitation.
There are newer proposals [22] for more complete CFI under
speculative execution.
7 Related Work
The hypothesis that an advanced SEA might chain multiple
code gadgets by having “multiple outstanding speculative
changes of address stream caused by branch prediction” ﬁrst
appeared in a white-paper by ARM [23]. The paper, however,
lacks an investigation of this idea, its practicality or the exis-
tence of the required code-gadgets. A similar hypothesis also
appears in a more recent work by Canella et al. [24].
More recently, Mambretti et al. [25] demonstrated a practi-
cal SEA using multiple, chained gadgets to leak informa-
tion following a mispredicted conditional branch. Unlike
SpecROP, the attack requires a memory corruption bug in the
victim binary to be able to inject arbitrary return addresses
on to the stack. The targets for the return instructions used
to chain gadgets comes from the overwritten stack. In con-
trast, SpecROP considers a stronger attacker model and is
more stealthy. Our attacker cannot write arbitrary values to
the victim’s stack, and leaves no architecturally visible traces.
Bulck et al. [26] mention the possibility of using Load
Value Injection(LVI) to transiently poison the values loaded
from memory and used by return and indirect jump instruc-
tions, thereby chaining gadgets like in ROP/JOP. LVI depends
on faulty behavior in speciﬁc CPU models. Moreover, their
attack requires the ability to induce faults in the victim on
the load instructions which they wish to poison. In general,
this makes their attack practical only against victims running
within an SGX enclave. The paper also does not comment on
the practicality of causing multiple LVIs.
Other work which uses automated program analysis in-
clude Spectector [27] and oo7 [28]. Both of these works aim
to prevent Spectre-like attacks by doing a static analysis of
the code. oo7 statically applies taint analysis to binaries to
check whether tainted values (secrets) can affect the outcome
of conditional branches and speculative memory accesses.
Spectector analyzes binaries for speculative code paths which
leave microarchitectural traces which the architecturally in-
tended path does not. Given the exact path through a SpecROP
chain, Speculator would be able to detect that the instruction
sequence is leaky. However, neither of these analyses can prac-
tically detect information leakage resulting from a SpecROP
gadget chain since the set of available sequences to analyze
grows exponentially with the length of the gadget chain.
SplitSpectre [29] also proposes an approach to implement
the Spectre attack where the target does not contain any single
gadget which loads the secret and performs a dependent load,
instead relying on an attacker with the ability to inject the
second load on the natural control-ﬂow following the ﬁrst.
In contrast, SpecROP reuses existing gadgets for both loads.
Further, Spectector will be able to detect that the code se-
quence used in SplitSpectre is leaky since there is a direct
path between the dependent loads.
8 Conclusion
1The early implementations of Intel CET will restrict execution following
indirect jumps/calls to 8 instructions and 5 loads.
Through SpecROP, we extend our understanding of practi-
cal Speculative Execution Attacks by studying the ability to
12    23rd International Symposium on Research in Attacks, Intrusions and Defenses
USENIX Association
chain multiple gadgets. We demonstrate that poisoning multi-
ple control ﬂow instructions (returns and indirect jumps) is
possible on modern processors. In fact, on tested processors,
we can poison up to 4 indirect jumps with more than 50%
success rate. This opens up the potential for attackers to use
gadget chains instead of monolithic gadgets. With the use of
the SpecROP technique, we show how generic gadgets can
extend the reach of secrets accessible by an attacker, with an
example of how this methodology may be applied to access
and leak the AES key from a pointer to the context. We also
demonstrate a practical attack which is able to leak multi-
ple plaintext bits from a victim during encryption using the
OpenSSL library.
To facilitate the gadget search, we design SpecFication, a
gadget search tool for searching for generic SpecROP gadgets,
from which we build up useful chains. Applying SpecFication
to existing code bases, we see the abundance of small, generic
SpecROP gadgets. We also study the possible mitigation tech-
niques for SpecROP attacks. Our results lead us to believe
that modern processors and programs are indeed vulnerable
to a SpecROP attack, and that processors require hardware
solutions for preventing malicious inﬂuence on branch/return
prediction.
We have published as open-source the code for our experi-
ments, the proof-of-concepts and SpecFication to enable oth-
ers to further explore this methodology. The code is available
at the GitHub repository https://github.com/HexHive/
specrop-public.
Acknowledgments
We thank the anonymous reviewers for their insightful com-
ments. This project has received funding from the European
Research Council (ERC) under the European Union’s Hori-
zon 2020 research and innovation program (grant agreement
No. 850868).
References
[1] P. Kocher, J. Horn, A. Fogh, , D. Genkin, D. Gruss,
W. Haas, M. Hamburg, M. Lipp, S. Mangard, T. Prescher,
M. Schwarz, and Y. Yarom, “Spectre attacks: Exploit-
ing speculative execution,” in 40th IEEE Symposium on
Security and Privacy (S&P’19), 2019.
[2] H. Shacham, “The geometry of innocent ﬂesh on the
bone: return-into-libc without function calls (on the
x86),” in Proceedings of the 2007 ACM Conference
on Computer and Communications Security, CCS
2007, Alexandria, Virginia, USA, October 28-31, 2007,
P. Ning, S. D. C. di Vimercati, and P. F. Syverson,
Eds. ACM, 2007, pp. 552–561. [Online]. Available:
https://doi.org/10.1145/1315245.1315313
[3] V. van der Veen, D. Andriesse, M. Stamatogiannakis,
X. Chen, H. Bos, and C. Giuffrida, “The Dynamics
of Innocent Flesh on the Bone: Code Reuse Ten
Years Later,” in CCS, Oct. 2017. [Online]. Avail-
able: Paper=http://vvdveen.com/publications/newton.
pdfWeb=https://www.vusec.net/projects/newton
[4] T. K. Bletsch, X. Jiang, V. W. Freeh, and Z. Liang,
“Jump-oriented programming: a new class of code-reuse
attack,” in Proceedings of the 6th ACM Symposium on
Information, Computer and Communications Security,
ASIACCS 2011, Hong Kong, China, March 22-24, 2011,
B. S. N. Cheung, L. C. K. Hui, R. S. Sandhu, and
D. S. Wong, Eds. ACM, 2011, pp. 30–40. [Online].
Available: https://doi.org/10.1145/1966913.1966919
[5] E. M. Koruyeh, K. N. Khasawneh, C. Song, and
N. B. Abu-Ghazaleh, “Spectre returns! speculation
attacks using the return stack buffer,” in 12th USENIX
Workshop on Offensive Technologies, WOOT 2018,
Baltimore, MD, USA, August 13-14, 2018, C. Rossow
and Y. Younan, Eds. USENIX Association, 2018.
[Online]. Available: https://www.usenix.org/conference/
woot18/presentation/koruyeh
[6] A. Bhattacharyya, A. Sandulescu, M. Neugschwandtner,
A. Sorniotti, B. Falsaﬁ, M. Payer, and A. Kurmus,
“Smotherspectre: Exploiting speculative execution
through port contention,” in Proceedings of
the
2019 ACM SIGSAC Conference on Computer and
Communications Security, CCS 2019, London, UK,
November 11-15, 2019, L. Cavallaro, J. Kinder, X. Wang,
and J. Katz, Eds. ACM, 2019, pp. 785–800. [Online].
Available: https://doi.org/10.1145/3319535.3363194
in Proceedings of
[7] Y. Yarom and K. Falkner, “FLUSH+RELOAD: A
high resolution, low noise, L3 cache side-channel
the 23rd USENIX
attack,”
Security Symposium, San Diego, CA, USA, August
20-22, 2014, K. Fu and J. Jung, Eds. USENIX
Association, 2014, pp. 719–732. [Online]. Available:
https://www.usenix.org/conference/usenixsecurity14/
technical-sessions/presentation/yarom
[8] M. Schwarz, M. Schwarzl, M. Lipp, J. Masters, and
D. Gruss, “Netspectre: Read arbitrary memory over
network,” in Computer Security - ESORICS 2019 - 24th
European Symposium on Research in Computer Security,
Luxembourg, September 23-27, 2019, Proceedings, Part
I, ser. Lecture Notes in Computer Science, K. Sako,
S. Schneider, and P. Y. A. Ryan, Eds., vol. 11735.
Springer, 2019, pp. 279–299. [Online]. Available:
https://doi.org/10.1007/978-3-030-29959-0_14
[9] S. Schirra, “Ropper - rop gadget ﬁnder and binary infor-
mation tool,” http://scoding.de/ropper/, 2014.
USENIX Association
23rd International Symposium on Research in Attacks, Intrusions and Defenses    13
[10] L. De Moura and N. Bjørner, “Z3: An efﬁcient smt
solver,” in International conference on Tools and Al-
gorithms for the Construction and Analysis of Systems.
Springer, 2008, pp. 337–340.
[11] N. A. Quynh, “Capstone: Next-gen disassembly frame-
work,” Black Hat USA, vol. 5, no. 2, pp. 3–8, 2014.
[12] S. Heule, E. Schkufza, R. Sharma, and A. Aiken,
“Stratiﬁed synthesis: Automatically learning the x86-64
instruction set,” in Programming Language Design and
Implementation (PLDI). ACM, June 2016. [Online].
Available: http://dx.doi.org/10.1145/2908080.2908121
[13] S. Dasgupta, D. Park, T. Kasampalis, V. S. Adve, and
G. Rosu, “A complete formal semantics of x86-64
user-level instruction set architecture,” in Proceedings of
the 40th ACM SIGPLAN Conference on Programming
Language Design and Implementation, PLDI 2019,
Phoenix, AZ, USA, June 22-26, 2019, K. S. McKinley
and K. Fisher, Eds. ACM, 2019, pp. 1133–1148.
[Online]. Available: https://doi.org/10.1145/3314221.
3314601
[14] P. Turner, “Retpoline: a software construct for prevent-
ing branch-target-injection,” https://support.google.com/
faqs/answer/7625886, 2018.
[15] M. Yan, J. Choi, D. Skarlatos, A. Morrison, C. W.
Fletcher, and J. Torrellas, “Invisispec: Making spec-
ulative execution invisible in the cache hierarchy
(corrigendum),” in Proceedings of the 52nd Annual
IEEE/ACM International Symposium on Microarchi-
tecture, MICRO 2019, Columbus, OH, USA, October
12-16, 2019. ACM, 2019, p. 1076. [Online]. Available:
https://doi.org/10.1145/3352460.3361129
[16] V. Kiriansky, I. A. Lebedev, S. P. Amarasinghe,
S. Devadas, and J. S. Emer, “DAWG: A defense
against cache timing attacks in speculative execution
processors,” in 51st Annual
IEEE/ACM Interna-
tional Symposium on Microarchitecture, MICRO 2018,
Fukuoka, Japan, October 20-24, 2018.
IEEE Com-
puter Society, 2018, pp. 974–987. [Online]. Available:
https://doi.org/10.1109/MICRO.2018.00083
their source,” in Proceedings of
[17] O. Weisse, I. Neal, K. Loughlin, T. F. Wenisch, and
B. Kasikci, “NDA: preventing speculative execution
the
attacks at
52nd Annual IEEE/ACM International Symposium on
Microarchitecture, MICRO 2019, Columbus, OH, USA,
October 12-16, 2019. ACM, 2019, pp. 572–586.
[Online]. Available: https://doi.org/10.1145/3352460.
3358306
[18] Intel Corporation, “Deep dive: Indirect branch restricted
https://software.intel.com/security-
speculation,”
software-guidance/insights/deep-dive-indirect-branch-
restricted-speculation, accessed: 2020-03.
[19] ——, “Deep dive: Indirect branch predictor barrier,”
https://software.intel.com/security-software-guidance/
insights/deep-dive-indirect-branch-predictor-barrier,
accessed: 2020-03.
[20] ——, “Deep dive: Single thread indirect branch pre-
dictors,” https://software.intel.com/security-software-
guidance/insights/deep-dive-single-thread-indirect-
branch-predictors, accessed: 2020-03.