    {
        ...
        this.EditCustomer = new Command(this.Edit, ...);
        this.DiscardChanges = new Command(this.Discard,
            () => { return this.CanSaveOrDiscardChanges; });
    }
    ...
}
Notice that the DiscardChanges command is enabled only if the
CanSaveOrDiscardChanges property is true, the ViewModel has a
connection to the web service, and the ViewModel is in Adding or
Editing mode.
14. In the Methods For Fetching And Updating Data region, after the
Discard method, add one more method, named SaveAsync, as shown in
the code that follows. This method should be marked with the async
modifier.
Click here to view code image
// Save the new or updated customer back to the web service
// and return the form to Browsing mode
private async void SaveAsync()
{
    if (this.ValidateCustomer(this.Current))
    {
        try
        {
            AdventureWorksService service = new
AdventureWorksService();
            if (this.IsAdding)
            {
                // If the user is adding a new customer, post
the details back
  to the web service
                var cust = await
service.CustomersOperations.PostCustomerAsync
  (this.Current);
                this.CopyCustomer(cust, this.Current);
                this.OnPropertyChanged(nameof(Current));
                this.IsAdding = false;
                this.IsBrowsing = true;
            }
            else
            {
Download from finelybook PI:EMAIL
1065
                // If the user is updating an existing customer,
perform a PUT
  operation instead
                await
service.CustomersOperations.PutCustomerAsync(
                    this.Current.CustomerID, this.Current);
                this.IsAdding = false;
                this.IsBrowsing = true;
            }
        }
        catch (Exception e)
        {
            // TODO: Handle any errors
        }
    }
}
The ValidateCustomer method ensures that the current customer
displayed by the app contains valid data, such as a non-null first and last
name, a correctly formatted email address, and telephone number that
only contains valid characters. If the details are valid, the code in the try
block determines whether the user is adding a new customer or editing
the details of an existing customer. If the user is adding a new customer,
the code sends a POST message to the web service by using the
PostCustomerAsync method of the REST API client model. This
operation might take a little time, so the code uses the asynchronous
version of the operation to prevent the UI of the Customers app from
freezing.
Keep in mind that the POST request is sent to the PostCustomer method
in the CustomersController class in the web service, and this method
expects a Customer object as its parameter. The details are transmitted in
JSON format. You might also recall that the CustomerID column in the
Customer table in the AdventureWorks database contains automatically
generated values. The user does not provide a value for this data when a
customer is created; rather, the database itself generates the value when
a customer is added to the database. In this way, the database can ensure
that each customer has a unique customer ID. The value returned by the
PostCustomerAsync method in the REST API client model returns the
details for the newly created customer, including the customer ID. The
code that you have added updates the details displayed by the Customers
app with the new data.
Download from finelybook PI:EMAIL
1066
If the user is editing an existing customer, the app generates a PUT
request that is passed to the PutCustomer method in the
CustomersController class in the web service by using the
PutCustomerAsync method of the REST API client model. The
PutCustomerAsync  method updates the details of the customer in the
database and expects the customer ID and customer details as
parameters. Again, this data is transmitted to the web service in JSON
format.
15. Add the SaveChanges Command variable shown here to the list at the
start of the ViewModel class, and update the constructor to instantiate
this command, as shown in the following:
Click here to view code image
public class ViewModel : INotifyPropertyChanged
{
    ...
    public Command DiscardChanges { get; private set; }
    public Command SaveChanges { get; private set; }
    ...
    public ViewModel()
    {
        ...
        this.DiscardChanges = new Command(this.Discard, ...);
        this.SaveChanges = new Command(this.SaveAsync,
            () => { return this.CanSaveOrDiscardChanges; });
        ...
    }
    ...
}
16. On the Build menu, click Build Solution and verify that your app
compiles without any errors.
The web service needs to be updated to support the edit functionality.
Specifically, if you are adding or editing a customer, you should set the
ModifiedDate property of the customer to reflect the date on which the
change was made. Additionally, if you are creating a new customer, you must
populate the rowguid property of the Customer object with a new GUID
before you can save it. (This is a mandatory column in the Customer table;
other apps inside the Adventure Works organization can use this column to
track information about customers.)
Download from finelybook PI:EMAIL
1067
Note GUID stands for globally unique identifier. A GUID is a string,
generated by Windows, that is almost guaranteed to be unique (there is
a very small possibility that Windows might generate a nonunique
GUID, but the possibility is so infinitesimally small that it can be
discounted). GUIDs are frequently used by databases as key values used
to identify individual rows, as in the case of the Customer table in the
AdventureWorks database.
Update the web service to support add and edit functionality
1. In Solution Explorer, in the AdventureWorksService project, expand the
Controllers folder and open the CustomersController.cs file to display it
in the Code and Text Editor window.
2. In the PostCustomer method, before the statements that save the new
customer in the database, add the following code shown in bold.
Click here to view code image
// POST api/Customers
[ResponseType(typeof(Customer))]
public async Task PostCustomer(Customer
customer)
{
    if (!ModelState.IsValid)
    {
        ...
    }
    customer.ModifiedDate = DateTime.Now;
    customer.rowguid = Guid.NewGuid();
    db.Customers.Add(customer);
    await db.SaveChangesAsync();
    ...
}
3. In the PutCustomer method, update the ModifiedDate property of the
customer before the statement that indicates that the customer has been
modified, as shown here in bold:
Download from finelybook PI:EMAIL
1068
Click here to view code image
// PUT api/Customers/5
[ResponseType(typeof(void))]
public async Task PutCustomer(int id,
Customer customer)
{
    ...
    customer.ModifiedDate = DateTime.Now;
    db.Entry(customer).State = EntityState.Modified;
    ...
}
4. Redeploy the web service to the cloud again, as follows:
a. In Solution Explorer, right-click the AdventureWorksService project,
and then click Publish.
b. On the Publish page of the wizard, click Publish. This action should
overwrite the existing web service that you deployed to Azure earlier.
Correcting a problem with the REST API client
code
At the time of writing, I found an issue with the code generated by
Visual Studio for the REST API client model. Specifically, the
PostCustomerWithHttpMessagesAsync method does not handle the
HTTP Created response that a REST web service is likely to send back
when a new entity is successfully added. Currently, the
PostCustomerWithHttpMessagesAsync method constructs an HTTP
POST request which it sends to the web service. It waits for the
response, and if the HTTP status code in the response is anything other
than 200 (the HTTP status code for OK), it throws an exception.
However, a REST web service is allowed to send back other 2xx status
codes, all of which can indicate success. For example, a POST request
is likely to result in the status code 201 (Created) rather than a plain 200
(OK).
Although it goes against the previous advice given of not directly
editing the code generated by Visual Studio for the REST API client
model, the simplest solution is to change this code manually, as follows:
Download from finelybook PI:EMAIL
1069
1. In Solution Explorer, in the Customers project, expand the
AdventureWorksService nnnnnnnnn folder, expand Models, and
double-click the CustomerOperations.cs file to display it in the
Code and Text Editor window.
2. Find the PostCustomerWithHttpMessagesAsync method.
3. In this method, find the following line:
if ((int)_statusCode != 200)
4. Change this line as follows, in bold:
Click here to view code image
if ((int)_statusCode != 200 && (int)_statusCode != 201)
5. Still in the PostCustomerWithHttpMessagesAsync method, find the
following code:
Click here to view code image
// Deserialize response
if ((int)_statusCode == 200)
6. Change this code as follows, in bold:
Click here to view code image
// Deserialize response
if ((int)_statusCode == 200 || (int)_statusCode == 201)
7. On the Build menu, click Rebuild Solution.
This issue might be fixed in future updates to Visual Studio, so
check first before making these changes to your code.
Reporting errors and updating the UI
You have added the commands by which a user can retrieve, add, edit, and
save customer information. However, if something goes wrong and an error
occurs, the user is not going to know what has happened because the
ViewModel class does not include any error-reporting capabilities. One way
to add such a feature is to capture the exception messages that occur and
Download from finelybook PI:EMAIL
1070
expose them as a property of the ViewModel class. A view can use data
binding to connect to this property and display the error messages.
Add error reporting to the ViewModel class
1. Return to the Customers project and display the ViewModel.cs file in
the Code and Text Editor window.
2. After the ViewModel constructor, add the private _lastError string
variable and public LastError string property shown here:
Click here to view code image
private string _lastError = null;
public string LastError
{
    get => this._lastError;
    private set
    {
        this._lastError = value;
        this.OnPropertyChanged(nameof(LastError));
    }
}
3. Find the ValidateCustomer method, and add the following statement
shown in bold immediately before the return statement:
Click here to view code image
private bool ValidateCustomer(Customer customer)
{
    ...
    this.LastError = validationErrors;
    return !hasErrors;
}
The ValidateCustomer method populates the validationErrors variable
with information about any properties in the Customer object that
contain invalid data. The statement that you have just added copies this
information to the LastError property.
4. Find the SaveAsync method. In this method, add the following code
shown in bold to catch any errors and HTTP web service failures:
Click here to view code image
private async void SaveAsync()
Download from finelybook PI:EMAIL
1071
{
    // Validate the details of the Customer
    if (this.ValidateCustomer(this.Current))
    {
        ...
        try
        {
            ...
            if (this.IsAdding)
            {
                ...
                this.IsBrowsing = true;
                this.LastError = String.Empty;
            }
            else
            {
                ...
                this.IsBrowsing = true;
                this.LastError = String.Empty;
             }
         }
        catch (Exception e)
        {
            // TODO: Handle any errors
            this.LastError = e.Message;
        }
    }
}
5. Find the Discard method, and then add the statement shown here in bold
to the end of it:
Click here to view code image
private void Discard()
{
    ...
    this.IsBrowsing = true;
    this.LastError = String.Empty;
}
6. On the Build menu, click Build Solution and verify that the app builds
without any errors.
The ViewModel is now complete. The final stage is to incorporate the
new commands, state information, and error-reporting features into the view
provided by the Customers form.
Integrate add and edit functionality into the Customers form
Download from finelybook PI:EMAIL
1072
1. Open the MainPage.xaml file in the Design View window.
The XAML markup for the MainPage form has already been modified,
and the following TextBlock controls have been added to the Grid
controls that display the data:
Click here to view code image
        ...
            ...
                ...
            ...
                ...
    ...
    ...
The ErrorMessageStyle referenced by these TextBlock controls is
defined in the AppStyles.xaml file.
2. Set the Text property of both TextBlock controls to bind to the LastError
property of the ViewModel, as shown here in bold:
Click here to view code image
...
...
3. The TextBox and ComboBox controls that display customer data on the
form should allow the user to modify this data only if the ViewModel is
in Adding or Editing mode; otherwise, they should be disabled. Add the
IsEnabled property to each of these controls and bind it to the
IsAddingOrEditing property of the ViewModel as follows:
Click here to view code image
...
...
...
...
...
IsEnabled="{Binding IsAddingOrEditing}" .../>
...
...
4. Add a command bar to the bottom of the page, immediately after the top
command bar, using the  element. This
command bar should contain buttons for the AddCustomer,
EditCustomer, SaveChanges, and DiscardChanges commands, as
follows:
Download from finelybook PI:EMAIL
1074
Click here to view code image
    ...
        ...
Note that the icons referenced by the buttons are the standard images
provided with the Blank App template.
When the user clicks Save Changes, the interaction with the web service
might be quick, or it could take a few seconds, depending on the speed of the
HTTP connection to Azure, and the load on the database behind the web
service. It would be helpful to let users know when the application is saving
the data, that although the app might appear to be doing nothing, it is active
behind the scenes. In a UWP app, you can use a ProgressRing control to
provide a visual cue. This control should be displayed when the ViewModel
is busy communicating with the web service but be inactive otherwise.