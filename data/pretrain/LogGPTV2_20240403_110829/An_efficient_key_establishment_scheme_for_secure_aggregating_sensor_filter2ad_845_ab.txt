be established between those nodes and i. Details about how i de-
termines its aggregation path f, b, a, . . . will be given in Section
5.6. For now, it has to be assumed that i simply knows the nodes it
needs to share keys with.
5.1 Pairing of New Nodes
As explained in Section 4.2, i has to be prepared or paired by
MD to properly enter the network. In this protocol, pairing works
as follows: Only MD knows a hard-coded key KMD, which might
have been generated during its fabrication and never leaves the de-
vice. Using KMD, MD is able to compute a pairwise key with
every sensor node at any time. Every node is assumed to have a
0
…
d
a
c
b
e
f
g
h
…
…
…
i
Figure 2: Node i joins the network and gets keys for communi-
cation with random nodes e and d.
unique identity ID, like f or g or any other unique identiﬁcation
ID respectively. MD computes the pairwise key with node ID by
calculating KMD,ID = EKMD (ID). During the initial pairing with
a new joining node ID, MD hands out KMD,ID to ID using a se-
cure location limited channel, e.g., physical contact. MD, however,
does not need to store KMD,ID. MD can be completely stateless.
KMD,ID can easily be re-computed. As a result, every node that
has ever joined the network successfully, possesses a pairwise se-
cret key with MD. From now on, MD is in the position to send
messages to node ID that are encrypted with KMD,ID. Receiving
those messages and decrypting them with KMD,ID, the node knows
that they are originated from MD. This technique allows MD to
hand out tickets to new nodes. Tickets are encrypted speciﬁcally
for older nodes already in the network and will help a new node to
introduce itself to the older nodes, as described below.
So, with i going to join the network, MD generates KMD,i and
gives it to i. After that, it randomly chooses two nodes from the ex-
isting network, e.g., e and d. Section 5.5 discusses how two nodes
are randomly chosen by MD without knowing the exact network
conﬁguration. Again, assume for now MD to be in the position of
picking two nodes like e and d randomly. MD computes and hands
out two tickets Te and Td and two keys Ke,i and Kd,i. This is
similar to Kerberos with MD as KDS [11].
In conclusion, i gets from MD using a location limited channel:
• KMD,i, a secret key between i and MD. Node i can thereby
securely communicate with MD in the future.
• Random node IDs e and d as well as secret keys Ke,i and
Kd,i, so i knows whom to talk to during the rest of the pro-
tocol.
• Ticket Te = EKMD,e (i, ”is legal player”, Ke,i) and
Ticket Td = EKMD,d (i, ”is legal player”, Kd,i)
5.2 Splitting and Distributing Keys
In the following, the term key splitting is used. The main idea
is to split a key K perfectly into two key shares K1 and K2 by
choosing a random number r of the same size as K and computing
(⊕ means XOR)
K2 are known to the same node. Knowledge of only one K1 or K2
will not reveal anything about K [13].
Node i generates a symmetric key Ki,f for secret communica-
tion between i and f and splits Ki,f into two shares K1 and K2.
Because i possesses two tickets and keys for the two random nodes
e and d, it uses these nodes to forward both shares towards f. Node
i does the following:
• Node i sends Te and Td to e and d using its normal wireless
communication facilities. As both tickets are encrypted with
the corresponding key between MD and e or d, both nodes
realize that the tickets are originally coming from MD. The
term ”is a legal player” convinces them about i going to be
a legal node in the network. Using keys Ke,i and Kd,i, they
can now also securely communicate with i. Tickets Te and
Td can be discarded.
• Node i sends
C1 = (i, EKe,i (i, K1, f ))
to e. This is a request to forward K1 to f. The preceding
plain node ID i in C1 just helps the receiving node e to un-
derstand that the following ciphertext is coming from i and
can be decrypted with Ke,i.
• Node i requests d to forward K2 to f in the same way. It
sends
C2 = (i, EKd,i(i, K2, f )).
Nodes e and d now accept i as a legal new node, both have shared
keys with i, and possess i’s key shares for forwarding to f.
Now, secure key forwarding begins. If e already had a pairwise
key with f, say Ke,f , it would simply send
γ1 = (e, EKe,f (i, K1))
to f. However, as shown in Figure 2, there is no key between e
and f. What e now does is to gradually ﬁnd one of its predecessors
with a secret key to f, simply by asking them. Node e starts asking
its father b whether it has a key with f. If b did not have a key
with f then e would go on and ask a etc. As f is taking part in the
aggregation tree, one of e’s predecessors will have a key with f in
any case. Similar to the technique explained above, these forward
request are secured with the pairwise keys all nodes along a tree-
predecessor path possess: By the induction hypothesis, e.g., e and
b share the key Ke,b or e and a share the key Ke,a and so on. In our
case however, e’s predecessor b already has the common key Kb,f
with f and reports this fact back to e. As e now has knowledge that
b owns a key with f, it is quite clear to e that b’s predecessor a must
also have a common key with f. On the other hand, e knows a,
because a is of course also along the path upwards the aggregation
tree. And because a is a predecessor in e’s aggregation tree, e has
a common key Ke,a with a as well.
Now e does the following:
• e splits K1 into two shares, namely K 1
• It computes
1 and K 2
1 .
C 1
1 = (e, EKe,b (f, K 1
1 ))
K1 = r,
and
K2 = K ⊕ r.
Now K1 and K2 may be distributed to different nodes. This tech-
nique allows K = K1 ⊕ K2 to be restored only if K1 as well as
0
C 2
1 = (e, EKe,a (f, K 2
1 )).
• Finally, e sends C 1
3(a).
1 to b and C 2
1 to a. This is shown in Figure
After decryption, b and a send to f:
b : γ 1
1 = (b, EKb,f (i, K 1
1 ))
a : γ 2
1 = (a, EKa,f (i, K 2
1 )).
This is shown in Figure 3(b).
2 and K 2
Node d carries out the same operations after receiving C2 and
generating K 1
2 . It will ask a and a’s father (not shown in
2 in a similar way to f. Note that
Figure 3) to forward K 1
it is no problem, if a has no father but is the root node, that is, the
sink (cf. Section 5.3). Eventually, f receives γ 1
2 and
decrypts to K 1
2 , see Figure 3(b). Therewith, it can
compute Ki,f by
2 and K 2
1 , K 1
2 , K 2
1 , K 2
1 , γ 1
2 , γ 2
1 , γ 2
Ki,f = K 1
1 ⊕ K 2
1 ⊕ K 1
2 ⊕ K 2
2 .
If one of e or d already had a key with f, say e, then f would
have received only γ1, γ 1
2 . Yet, f is able to
compute Ki,f by simple XOR:
2 giving K1, K 1
2 , K 2
2 , γ 2
Ki,f = K1 ⊕ K 1
2 ⊕ K 2
2 .
As a result, a secret key Ki,f has been established between nodes
i and f.
2
1K
1
1K
b
a
c
K
1
⊕=
1
K
1
K
2
1
e
f
g
h
…
2K
…
1
2K
2
2K
d
K
2
=
K
1
2
⊕
K
2
2
…
…
1K
i
KK
⊕=
1 K
2
(a) Distribution of key shares tree upwards
…
2
2K
a
c
,1
2K
2
1K
b
1
1K
e
f
1
KK
1
⊕=
2
K
1
…
g
h
⊕⊕
K
1
2
K
2
2
d
…
…
(b) Node f receiving shares to restore Ki,f
Figure 3: Key split, distribution and receipt. Shares are sent
encrypted, see text.
Using the above scheme, i establishes keys with b, a and all other
predecessors along the aggregation path.
It will ask e and d to
forward a newly generated and split key Ki,b to b and so on and so
forth.
5.3 Security Discussion
This section explains the protocols resistance against one com-
promised malicious node for simplicity. As a result, all an attacker
0
can do is some kind of Denial-of-Service-attack, i.e., denying a suc-
cessful key establishment. He will, however, never be in the posi-
tion to learn a new key, because all data exchange is individually
encrypted.
What makes this protocol secure is the idea to split and distribute
a new key in a way that no single node in the network can fully re-
store it. From a security point of view, it becomes obvious that
therefore the following would be the worst scenario: Both initial
random nodes are residing in the same subtree so that both of them
ﬁnd the same predecessor having a common key with f. For exam-
ple, let h and c be the random nodes. Both nodes will recognize a
as the predecessor with a key to f. However, even if a is malicious,
it will not get all key shares, because h and c are also securely send-
ing shares to a’s father. The same holds for the situation where a’s
father is malicious.
In another scenario with c being malicious,
c might lie on h’s request and might pretend having a key with f.
Yet, h is going to send one key share to a, leaving attacker c with an
incomplete set of key shares. Note: It may be possible that one of
the predecessors during a key establishment is the sink itself. This
is not a problem, because you generally assume to trust the sink.
So if the sink turns out to be one of the predecessor taking part in
an ongoing protocol cycle, there is no need to look for more prede-
cessors – you already found a node which you can trust. Something
similar holds, if the initially chosen nodes reside in different sub-
trees and ﬁnd different predecessor with keys to f: It is impossible
for one node to gather all the different key shares together.
It is, however, possible for a malicious node to intercept and drop
encrypted key shares, i.e., to refuse forwarding, or to alter a key
share before forwarding it. This will result in an incomplete or
erratic set of key shares arriving at the destination node f. As a
consequence, the destination node will assemble the shares incor-
rectly and compute a new key K ′
i,f which is different from Ki,f .
Nodes i and f will thus not be able to communicate securely at all –
ending in a Denial-of-Service attack on the establishment protocol.
Detecting such a Denial-of-Service attack is quite simple: i and f
will not understand each others encrypted data, yet they would not
know which of the nodes taking part in the protocol misbehaved.
In this case only unprotected communication between both nodes
would be possible, as would be without any key establishment pro-
tocol. Wireless sensor networks are prone to Denial-of-Service in
general. If an attacker successfully compromises a legal node in
the network he can launch any type of Denial-of-Service attack.
Looking at Figure 2, you must not consider the vertexes between
nodes as communications paths but only as application-wise aggre-
gation ﬂows, as mentioned above. Communication between, e.g.,
node b and a may be multi-hop communication involving a lot of
other nodes in the whole network, maybe even e or f or whatever.
This is not a security problem, as those multi-hop nodes are only
forwarding end-to-end encrypted data between say b and a. Inter-
mediate nodes will never learn anything from the data they forward.
5.4 Extension to Defend against Multiple Ma-
licious Nodes
So far, the key establishment protocol is secure only in the pres-
ence of one compromised node. However, the user may assume the
presence of up to k malicious nodes in the network. The proposed
protocol can easily be extended to cope with k malicious nodes.
The security goal here would be that even if k nodes may work