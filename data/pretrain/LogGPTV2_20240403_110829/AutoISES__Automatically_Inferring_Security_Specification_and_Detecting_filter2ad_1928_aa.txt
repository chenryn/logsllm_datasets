title:AutoISES: Automatically Inferring Security Specification and Detecting
Violations
author:Lin Tan and
Xiaolan Zhang and
Xiao Ma and
Weiwei Xiong and
Yuanyuan Zhou
AutoISES: Automatically Inferring Security Speciﬁcations and Detecting
Violations
University of Illinois, Urbana-Champaign
IBM T.J. Watson Research Center
Xiaolan Zhang
PI:EMAIL
Lin Tan1
PI:EMAIL
Xiao Ma†‡, Weiwei Xiong†, Yuanyuan Zhou†‡
†University of Illinois, Urbana-Champaign
‡Pattern Insight Inc.
{xiaoma2, wxiong2, yyzhou}@cs.uiuc.edu
Abstract
The importance of software security cannot be over-
stated.
In the past, researchers have applied program
analysis techniques to automatically detect security vul-
nerabilities and verify security properties. However, such
techniques have limited success in reality because they
require manually provided code-level security speciﬁca-
tions. Manually writing and generating these code-level
security speciﬁcations are tedious and error-prone. Ad-
ditionally, they seldom exist in production software.
In this paper, we propose a novel method and tool,
called AutoISES, which Automatically Infers Security
Speciﬁcations by statically analyzing source code, and
then directly use these speciﬁcations to automatically de-
tect security violations. Our experiments with the Linux
kernel and Xen demonstrated the effectiveness of this ap-
proach – AutoISES automatically generated 84 security
speciﬁcations and detected 8 vulnerabilities in the Linux
kernel and Xen, 7 of which have already been conﬁrmed
by the corresponding developers.
1 Introduction
1.1 Motivation
The critical importance of software security has driven
the design and implementation of secure software sys-
tems. Security-Enhanced Linux (SELinux) [23, 28], de-
veloped as a research prototype to incorporate Manda-
tory Access Control (MAC) into the Linux kernel sev-
eral years ago, imposes constraints on its existing Dis-
cretionary Access Control (DAC) for stronger security.
SELinux has since been adopted by the mainline Linux
2.6 series and incorporated into many commercial dis-
tributions, including Redhat, Fedora, and Ubuntu. Re-
cently, Xen also adopted a similar MAC security archi-
tecture to enable system-wide security policy [7].
A core part of such access control systems is
a set of
security check functions, which check
whether a subject (e.g., a process) can perform a
certain operation (e.g., read or write) on an object
(e.g., a ﬁle, an inode, or a socket).
These pro-
tected operations are called security sensitive opera-
tions. For example, Linux’s security check function
. . .) can deter-
security file permission(f ile,
mine if the current process is authorized to read or
write the ﬁle, while another security check function,
. . .), checks if the cur-
security file mmap(f ile,
rent process is authorized to map a ﬁle into mem-
ory. To ensure only authorized users can read or write
the ﬁle, developers must add the security check func-
tion security file permission() before each ﬁle
read/write operation on every ﬁle. Similarly, develop-
ers must add security file mmap() each time before
mapping a ﬁle to memory, to ensure only authorized
users can memory map the ﬁle.
A major challenge of supporting the secure architec-
ture above is to ensure that all sensitive operations on all
objects are protected (i.e., checked for authorization) by
the proper security check functions in a consistent man-
ner. If the proper security check function is missing be-
fore a sensitive operation, an attacker with insufﬁcient
privilege will be able to perform the security sensitive op-
eration, causing damage. For example, the ﬁle read/write
operation is performed in many functions throughout
the Linux kernel, such as read(), write(), readv(),
writev(), readdir(), and sendfile(). Despite the
different names of these function calls,
they all per-
form the same conceptual ﬁle read/write operation, and
must be checked for authorization by calling the security
check function security file permission(). As
the Linux kernel code is reasonably mature, most of these
functions performing the ﬁle read/write operation, such
as read(), write(), and readdir(), are protected by
USENIX Association  
17th USENIX Security Symposium 
379
linux/fs/read_write.c:
linux/fs/read_write.c:
linux/fs/readdir.c:
ssize_t vfs_read(...) {
…
ret = security_file_permission (file, ...);
…
// performs file read/write operation
ret = file->f_op->read(file, ...);
…
}
ssize_t vfs_write(...) {
…
ret = security_file_permission (file, ...);
…
// performs file read/write operation
ret = file->f_op->write(file, ...);
…
}
ssize_t vfs_readdir(...) {
…
ret = security_file_permission (file, ...);
…
// performs file read/write operation
ret = file->f_op->readdir(file, ...);
…
}
linux/fs/read_write.c:
static ssize_t do_readv_writev(...) { …
Forgot to call
security_file_permission()!
–- A security violation.
// performs file
// read/write operation
ret = file->f_op->readv(file,); …
}
(a) file read/write operation
protected by the check
(b) file read/write operation
protected by the check
(c) file read/write operation
protected by the check
(d) Security Violation – violating the
implicit security specification
Figure 1: A real security violation in Linux 2.6.11. The security check security file permission() was missing before
the security sensitive operation performed via file->f op->readv(), violating the implicit security speciﬁcation — every
ﬁle read/write operation must be checked for authorization using security file permission(). This is a real security
violation, which has already been ﬁxed in later versions. The code is slightly modiﬁed to simplify illustration.
the security check function, as shown in Figure 1(a)-(c).
However, in a few other cases, as shown in Figure 1(d),
the security check function is not invoked before the ﬁle
read/write operation performed by readv(), violating
the implicit security speciﬁcation or security rule: every
ﬁle read/write operation must be protected by calling se-
curity check function security file permission().
Due to this real world security vulnerability in Linux
2.6.11 (CVE-2006-1856 [1]), unauthorized user can read
and write ﬁles that they are not allowed to access, poten-
tially providing unauthorized user account access. Addi-
tional damages might include partial conﬁdentiality, in-
tegrity, and availability violation, unauthorized disclo-
sure of information, and disruption of service.
There have been great advances in applying program
analysis techniques [2, 4, 5, 12, 16] to automatically de-
tect these security vulnerabilities and to verify security
properties [6, 9, 18, 30]. Generally, these tools take a
speciﬁcation that describes the security properties to ver-
ify as input. For example, in earlier efforts [9, 30], the
authors manually identiﬁed the data types (e.g., struct
file, struct inode, etc.) that might be accessed to
perform security sensitive operations and automatically
veriﬁed that any access to these data types was protected
by a security check function. Although these previous
studies detected some vulnerabilities, and made signiﬁ-
cant progresses toward automatic veriﬁcation of security
properties, they are limited in two perspectives:
• All these previous tools require developers or their
tool users to provide code-level security speciﬁ-
cations, which greatly limit their practicability in
checking and verifying security properties. Writ-
ing speciﬁcations that accurately capture the secu-
rity properties of a piece of software and at the same
time maintaining their correctness across different
versions of the software is notoriously difﬁcult. Such
speciﬁcations seldom exist in production software.
• Human-generated speciﬁcations can be imprecise,
causing false positives and potentially false negatives
in violation detection. As an example, the speciﬁ-
cation used in one of the earlier work [30], intro-
duced false positives because it treated any access
to speciﬁed data structures as security sensitive op-
erations.
In reality, a security sensitive operation
typically consists of accesses to multiple data struc-
tures: a ﬁle read/write operation involves accessing
struct file, struct inode, struct dentry,
etc. Accessing the ﬁle structure alone is not neces-
sarily (actually in most cases is not) a ﬁle read/write
operation.
In addition, some ﬁeld accesses (e.g.,
file->f version) of a security sensitive data type
are not part of any security sensitive operation, and
therefore do not need to be protected. Therefore, in
the two cases above, simply requiring accesses to ev-
ery ﬁeld of these data structures to be protected led
to false positives [30]. The speciﬁcation may also
introduce false negatives because it does not spec-
ify which security check is required for which op-
eration. The tool can fail to detect violations where
the wrong check function is used as different security
sensitive operations (e.g., ﬁle read/write and memory
map) may access the same data types (e.g., struct
file) but require different security checks.
Therefore, to design tools that are truly usable for or-
dinary programmers, it is highly desirable for these tools
to meet the following three requirements on speciﬁcation
generation:
(1) to automatically check against source
code for security violations, the security speciﬁcations
must be at the code level. The conceptual speciﬁcation
“ﬁle read/write operation must be protected by the secu-
rity check function security file permission()”
can not be checked against source code without know-
ing its corresponding code-level representation. (2) as it
is tedious and error-prone for developers to write these
380 
17th USENIX Security Symposium 
USENIX Association
Security Check Function: security_file_permission
Security Sensitive Operation (A group of data
structure accesses):
1. READ inode->i_size
2. READ file->f_flags
3. READ file->f_pos
4. READ file->f_dentry
5. READ file->f_dentry->d_inode
6. READ file->f_vfsmnt
7. READ dentry->d_inode
8. READ address_space->flags
9. READ address_space->nrpages
10. WRITE address_space->nrpages
11. READ address_space->page_tree
12. READ address_space->tree_lock
13. READ page->_count
14. READ page->flags
15. WRITE page->index
16. READ page->mapping
17. WRITE page->mapping
18. READ pglist_data->node_zonelists
19. READ zone->wait_table
20. READ zone->wait_table_bits
21. READ (Global) nr_pagecache
22. READ (Global) zone_table
linux/fs/read_write.c:
static ssize_t do_readv_writev(...) {
…
// file->f_op->readv is set to function
generic_file_readv().
ret = file->f_op->readv();
…
}
security_file_permission() is
missing before the file read/write
operation, which accesses data
structures in (a) in many different
functions and files.
linux/mm/filemap.c:
ssize_t generic_file_readv (...) { ...
__generic_file_aio_read(); ...
}
linux/mm/filemap.c:
ssize_t __generic_file_aio_read(...) {
struct file *filp = iocb->ki_filp; …
if (filp->f_flags … ) { …
} …
i_size_read(); … }
READ file->f_flags
linux/include/linux/fs.h:
static inline loff_t i_size_read(struct
inode *inode) { ...
return inode->i_size;
}
READ inode->i_size
(a) Security Rule/Specification
(b) Security Violation
(c) Accesses in the Code
Figure 2: A code-level security speciﬁcation AutoISES automatically generated and a real security violation to the speciﬁcation
in Linux 2.6.11. The leftmost box shows the security rule, consisting of a security check function and a group of data structure
accesses. Each row is one access, which can be either a structure ﬁeld access or a global variable access, denoted by “(Global)”.
For each structure ﬁeld access, the name before the ﬁrst -> is the type name of the structure, and the rest are ﬁeld names. For a
global variable, the variable name is used. The code is slightly modiﬁed to simplify illustration.
security rules, the tool should automatically generate se-
curity speciﬁcations with minimum user/developer in-
volvement; and (3) the generated speciﬁcation must be
precise, otherwise it would result in too many false posi-
tives and/or false negatives.
1.2 Our Contributions
This paper makes two contributions:
(1) We propose an approach and a tool, AutoISES,
to automatically extract concrete code-level security
speciﬁcations from source code and automatically de-
tect security violations to these speciﬁcations. Our
key observation is that although the same security sen-
sitive operation can be performed in different functions,
ultimately, the structure ﬁelds and global variables these
functions access are the same. We call these structure
ﬁeld and global variable accesses together as data struc-
ture accesses. For example, all of the different func-
tions performing the ﬁle read/write operation share the
22 data structure accesses listed in Figure 2(a) (automat-
ically generated by AutoISES), including reading ﬁeld
f flags of the file structure and reading ﬁeld i size
of the inode structure. These 22 data structure accesses
are performed in many different functions located in dif-
ferent source ﬁles. Intuitively, this makes sense as secu-
rity check functions are designed to protect data. There-
fore, the use of data structure accesses is fundamental in
representing security sensitive operations.
Based on this observation, we propose a method and a
tool, called AutoISES, to Automatically Infer Security
Speciﬁcations by statically analyzing source code and
directly use these speciﬁcations to automatically detect
security violations. Speciﬁcally, if a code-level security
sensitive operation is frequently protected by a security
check function in source code, AutoISES automatically
infers that the security check function should be used to
protect the particular code-level security sensitive opera-
tion. Our rationale is that for release software, the ma-
jority of the code should be correct, therefore we can use
the code to infer security speciﬁcations or rules, which
are observed in most places of the source code, but may
not in a few other places. The rationale is similar to that
of prior work in speciﬁcation mining [10, 11, 20, 22],
each of which extracts different types of programming
rules automatically from source code or execution trace.
However, previous techniques are not directly applica-
ble to our problem, because they are limited by the
types of rules they can infer (e.g., function correlation
rules [10, 20], variable value related invariants [11], vari-
able pairing rules [22]). As noted previously, our key ob-
servation states that the sensitive operation should be rep-
resented as data structure accesses, therefore, it requires
AutoISES to be able to learn speciﬁcations that contain
both functions and multiple variable accesses that satisfy
certain constraints. None of the previous techniques can
be applied without signiﬁcant re-design of the learning
algorithm (more detailed discussion in Section 6.1 and
Section 7).
USENIX Association  
17th USENIX Security Symposium 
381
We evaluated AutoISES on the latest versions of
two large software systems,
the Linux kernel and
Xen, to demonstrate the effectiveness of our approach.
AutoISES automatically extracted 84 rules from the
Linux kernel and Xen, and detected 8 true violations, 7 of
which are conﬁrmed and ﬁxed by the corresponding de-
velopers. Figure 2 shows (a) the code-level security spec-
iﬁcation learned by AutoISES which consists of the 22
data structure accesses, (b) a security violation automati-
cally detected by AutoISES, and (c) the unprotected sen-
sitive operation that performs all the accesses shown in
(a) in different functions located in various source ﬁles.
It would be very difﬁcult, if impossible, for a human be-
ing to generate such a speciﬁcation. More examples and
results can be found in Section 5.
The automatically generated speciﬁcations can also
be used by other analysis tools for vulnerability detec-
tion. Additionally they can assist in software understand-
ing and maintenance. These results demonstrate that
AutoISES is effective at automatically inferring secu-
rity rules and detecting violations to these rules, which
greatly improves the practicality of security property
checking and veriﬁcation tools.
For example,
(2) We quantitatively evaluate rule granularity im-
pact on the accuracy of rule inference and vi-
olation detection. Security speciﬁcations can vary
in granularity.