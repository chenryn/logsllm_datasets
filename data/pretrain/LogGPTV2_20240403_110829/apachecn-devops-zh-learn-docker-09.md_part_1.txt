# 九、编排器
在前一章中，我们介绍了 Docker Compose，这是一个允许我们在单个 Docker 主机上使用声明方式定义的多服务应用的工具。
本章介绍编排器的概念。它告诉我们为什么需要编排器，以及他们在概念上是如何工作的。本章还将概述最受欢迎的编排器，并列举一些他们的优缺点。
在本章中，我们将涵盖以下主题:
*   什么是编排器，为什么我们需要他们？
*   编排器的任务
*   流行编排器概述
完成本章后，您将能够:
*   说出指挥者负责的三到四项任务
*   列出两到三个最受欢迎的编排器
*   用你自己的话和适当的类比，向感兴趣的外行解释为什么我们需要容器编排器
# 什么是编排器，为什么我们需要他们？
在[第 6 章](06.html) *【分布式应用架构】*中，我们学习了哪些模式和最佳实践常用于成功构建、发布和运行高度分布式的应用。现在，如果我们的高度分布式应用是容器化的，那么我们将面临与非容器化分布式应用完全相同的问题或挑战。其中一些挑战在[第 6 章](06.html)、*分布式应用架构*中讨论，服务发现、负载平衡、扩展等等。
与 Docker 对容器所做的类似——通过引入容器来标准化软件的包装和运输——我们希望有一些工具或基础设施软件来处理所有或大部分提到的挑战。这个软件变成了我们所说的编排器，或者我们也称之为编排引擎。
如果我刚才说的对你来说还没有多大意义，那我们换个角度来看。以演奏乐器的艺术家为例。他们可以独自为观众演奏美妙的音乐，而不仅仅是艺术家和他们的乐器。但是现在请一群音乐家。把他们都放在一个房间里，给他们一首交响乐的音符，让他们演奏，然后离开房间。没有任何导演，这群非常有才华的音乐人就无法和谐地演奏这首曲子；这听起来或多或少像是不和谐的声音。只有当编排器有一个指挥来指挥一群音乐家时，我们才能欣赏到编排器的音乐:
![](img/2e78b35e-a8de-4a49-8a6f-c212a561baa0.jpg)
A container orchestrator is like the conductor of an orchestra
我们现在有了容器而不是音乐家，也没有了不同的乐器，我们有了对容器主机运行有不同要求的容器。音乐不是以不同的节奏播放，我们有容器，它们以特定的方式相互通信，并且必须放大和缩小。在这一点上，容器编排器的指挥和编排器的指挥有着非常相似的角色。它确保集群中的容器和其他资源和谐地一起工作。
我希望你现在能更清楚地看到什么是容器编排器，为什么我们需要一个。假设您确认了这个问题，我们现在可以问自己指挥者将如何实现预期的结果，即确保集群中的所有容器彼此和谐地演奏。答案是，编排器的指挥必须执行非常具体的任务，类似于编排器的指挥也有一套他们执行的任务，以便驯服并同时提升编排器。
# 编排器的任务
*那么，* *我们期望一个值得花钱的指挥者为我们执行的任务是什么？*我们来详细看看。下面的列表显示了在撰写本文时，企业用户通常期望从他们的编排者那里得到的最重要的任务。
# 调和期望的状态
当使用一个编排器时，可以用声明的方式告诉它如何运行一个给定的应用或应用服务。我们在[第八章](08.html) *、Docker Compose* 中学习了*陈述句*与*祈使句*的含义。描述我们想要运行的应用服务的声明性方式的一部分是元素，例如使用哪个容器映像、运行这个服务的多少个实例、打开哪些端口等等。我们的应用服务属性的声明就是我们所说的*期望状态*。
因此，当我们现在告诉 orchestrator 第一次根据声明创建这样一个新的应用服务时，orchestrator 会确保在集群中调度尽可能多的容器。如果容器映像在应该运行容器的集群的目标节点上还不可用，那么调度程序会确保首先从映像注册表中下载它们。接下来，容器以所有设置开始，例如要连接的网络或要公开的端口。指挥者尽最大努力在集群中实现与我们声明中完全一致的效果。
一旦我们的服务按照请求启动并运行，也就是说，它在期望的状态下运行，那么编排者继续监视它。每当编排者发现服务的实际状态与其期望状态之间存在差异时，它会再次尽力协调期望状态。
应用服务的实际状态和期望状态之间会有什么样的差异？好吧，假设服务的一个副本，也就是其中一个容器，由于一个错误而崩溃，那么编排者将发现实际状态与期望状态在副本数量上不同:缺少一个副本。编排者将立即安排一个新实例到另一个集群节点，替换崩溃的实例。另一个差异可能是，如果服务被缩减，运行的应用服务实例太多。在这种情况下，编排者只需随机删除所需数量的实例，以实现实际实例数和所需实例数之间的均等。另一个差异可能是当编排者发现应用服务的一个实例运行错误(可能是旧的)版本的底层容器映像时。现在，你应该明白了，对吧？
因此，我们不是主动监视集群中运行的应用服务并纠正与期望状态的任何偏差，而是将这项繁琐的任务委托给编排者。如果我们使用声明性的而不是命令性的方式来描述应用服务的期望状态，这将非常有效。
# 复制和全球服务
有两种完全不同类型的服务，我们可能希望在由编排者管理的集群中运行。它们是**复制的**和**全球**服务。复制服务是需要在特定数量的实例中运行的服务，例如 10 个实例。反过来，全局服务是一种需要在集群的每个工作节点上运行一个实例的服务。我在这里使用了术语*工人节点*。在由指挥者管理的集群中，我们通常有两种类型的节点，**管理人员**和**工作人员**。管理器节点通常只由编排器用来管理集群，不运行任何其他工作负载。工作节点反过来运行实际的应用。
因此，orchestrator 确保对于一个全局服务，它的一个实例在每个工作节点上运行，不管有多少个工作节点。我们不需要关心实例的数量，只需要在每个节点上保证运行服务的单个实例。
我们可以再次完全依靠指挥者来完成这一壮举。在复制的服务中，我们将始终保证找到确切的所需实例数，而对于全局服务，我们可以确信，在每个工作节点上，将始终恰好运行一个服务实例。指挥者将一直尽最大努力来保证这种期望的状态。
In Kubernetes, a global service is also called a daemon set.
# 服务发现
当我们以声明的方式描述应用服务时，我们不应该告诉编排者服务的不同实例必须在哪些集群节点上运行。我们让编排者来决定哪些节点最适合这个任务。
当然，在技术上可以指示指挥者使用非常确定的布局规则，但这是一种反模式，根本不推荐。
因此，如果我们现在假设编排引擎对于将应用服务的单个实例放在哪里有完整和自由的意愿，而且实例可能崩溃并被编排者重新安排到不同的节点，那么我们将意识到跟踪单个实例在任何给定时间的运行位置是徒劳的。更好的是，我们甚至不应该试图了解这一点，因为它并不重要。
好吧，你可能会说，但是如果我有两个服务，A 和 B，服务 A 依赖于服务 B 呢；*服务 A 的任何给定实例不应该知道在哪里可以找到服务 B 的实例吗？*
在这一点上，我必须大声而明确地说——不，不应该。这种知识在高度分布式和可伸缩的应用中是不可取的。相反，我们应该依靠编排者来为我们提供到达我们所依赖的其他服务实例所需的信息。这有点像电话技术的旧时代，那时我们不能直接给朋友打电话，而必须给电话公司的中心局打电话，然后由接线员把我们送到正确的目的地。在我们的例子中，指挥者扮演操作员的角色，将来自服务 A 实例的请求路由到服务 b 的可用实例。整个过程称为**服务发现**。
# 按指定路线发送
到目前为止，我们已经了解到，在分布式应用中，我们有许多交互服务。当服务 A 与服务 B 交互时，是通过数据包的交换来实现的。这些数据包需要以某种方式从服务 A 传输到服务 b。将数据包从源传输到目的地的过程也称为**路由**。作为应用的作者或操作者，我们确实期望编排者接管路由任务。正如我们将在后面的章节中看到的，路由可以发生在不同的层次上。就像现实生活中一样。假设你在一家大公司的办公楼里工作。现在，您有一份文档需要转发给公司的另一名员工。内部邮局将从发件箱中取出文件，并将其送到位于同一栋大楼的邮局。如果目标人在同一栋楼里工作，那么文件就可以直接转发给那个人。另一方面，如果此人在同一街区的另一栋大楼工作，该文件将被转发到目标大楼的邮局，然后从那里通过内部邮政服务分发给收件人。第三，如果文件的目标是在公司位于不同城市甚至国家的另一个分支机构工作的员工，那么文件将被转发到外部邮政服务，如联合包裹，该服务将把文件运送到目标位置，再一次，内部邮政服务将从该位置接管并将其交付给收件人。