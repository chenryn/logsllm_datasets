by injecting malicious JavaScript, before it is transmitted to
the victim. Under IMA, the binary would be added to the
measurement list when it was loaded, and this new binary
measurment would not be in the list of known-good hashes.
Similarly, if a malicious patch was made to a system binary,
or if an unapproved or outdated binary was being used, these
would be discovered through measurement and comparison
with the known good hashes.
A byproduct of the content integrity information is that it
also protects against “in-ﬂight” page modiﬁcations, e.g., within
web caches. In [4], the authors show that the content of web
pages is modiﬁed in a number of different ways including
advertisement
injection, such as provided by the NebuAd
service [19]. Our system is able to ensure that “in-ﬂight”
page changes are discovered. The authors identify several
other classes of modiﬁcations, including page modiﬁcations
such as image distillation [20] or advertisement removal by a
proxy [21], [22], and also types of malware that modiﬁed pages
viewed by the user, such as the Adware.LinkMaker [23] which
creates links in the page that the publisher did not include, or
W32.Arpiframe [24], which injects content into HTTP streams
on a local subnet.
III. DESIGN
In this section, we provide a detailed description of an
architecture for scalable web content attestation. A central
observation is that to date, attestation-based systems present
a challenge to the TPM in the form of a randomized nonce, in
order to receive a TPM quote. The nonce ensures the freshness
of the quote but provides no semantics beyond that. In our
system, by contrast, we directly tie the content to the system’s
integrity state through the use of a cryptographic proof system
that succinctly represents the content served; this is used along
with the current time as a challenge to the TPM. In this manner,
we provide stronger guarantees about content origin, and when
it was served, than have been found in past proposals.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:10:03 UTC from IEEE Xplore.  Restrictions apply. 
TimeServerApacheSporkDaemonTPMTPMClientRequestPageRequest TimeRequestTimeWeb ServerFig. 4. A Merkle hash tree base for the cryptographic proof system. The leaf
nodes are hashes of the pages served to clients.
Quote(Hw, pcrHw , h(pi))
The quote operation provides a clear binding: document pi
was generated by (or is at least present on or known to) Hw
with PCR state pcrHw. Of course, the proof is not tied to
any particular time. In tangible terms, properties a (web server
identity) and b (integrity state) from above are provided. What
is missing from the simple proof is c (the element of time).
Thus any page delivered to a client at any time could be
replayed forever, i.e., a compromised server delivering stale
content could not be detected.
Figure 2 describes a more semantically rich content proof
construction that simultaneously ties content to both the host
and time. In this, the time server acts as a root of trust in
providing a self-certiﬁed timestamp (that uses the timestamp
itself as the quote challenge). The time server is trusted to
provide the correct time (by deﬁnition of a root of trust [26]),
and its quote mechanism is a means of tying a speciﬁc
timestamp to that trusted service. We revisit the design and
security issues of the time service in Section IV-B.
During the validation process, the client acquires a times-
tamp from the time server directly (or uses a suitably fresh
timestamp from its cache). The client will then judge whether
the content is too stale to trust, i.e., the difference between the
timestamp in the proof and that received from the time service
is too great. Because the time service is trusted, the client can
securely make judgments on content validity based on loose
clock synchronization, e.g., as seen in Kerberos [27]. Thus,
we have provided a proof whose semantics provide all of the
required properties.
The central limitation of the proposed content proof con-
struction is cost. Web servers may receive many hundreds
or thousands of requests per second (RPS). The above proof
would take about a second to generate on commodity hardware
(including the round-trip time (RTT) delay to acquire the
timestamp and the 900 msec for the quote operation in our
test environment). Because a unique proof is needed per
page/timestamp, the web server would not be able to serve
content at a reasonable rate, i.e., the web server RPS would be
≈ 1. What is a needed is a means to amortize quote costs.
A cryptographic proof system is a construction used to
efﬁciently authenticate collections of objects using one or more
cryptographic operations. Objects can be validated by extract-
ing succinct proofs from the proof system. These succinct
proofs are generally signiﬁcantly smaller that the proof system
as a whole. Thus, authentication costs are amortized over
Fig. 6. Static Page Scheduling - For static pages, the server provides the most
recently generated quote (Q0) to all incoming requests while it is generating
the next quote. Once the next quote is generated (Q1), this new quote is
provided to each incoming request.
collections of objects. While more sophisticated techniques
exist [25], [28], we concentrate on a conceptually simple proof
system based on the Merkle hash trees [29]. We create a proof
system for all of the documents that will be served by the
web server. Assume for the moment that the web server has a
static collection of pages that it delivers to clients (we extend
our solution to dynamic content generation in the next section).
To create the proof system for these static documents, all of
the documents are arranged as an ordered sequence of pages
p1 . . . pn. As shown in Figure 4, a binary tree is initially con-
structed by assigning the hash of each page h(pi) as a leaf, and
each interior node is the hash of the concatenation of both its
children. The root node is CP Sr. The succinct proof for page
pi, denoted P f(pi), consists of the root node and all of the
siblings on the path to the root. For example, the proof system
for page p3 in Figure 4 is {h(p4), h(h(p1)|h(p2)), CP Sr =
h(h(h(p1)|h(p2))|h(h(p3)|h(p4)))}. A proof
recipient can
then validate the content by hashing the ﬁle and computing
the p3 leaf and interior nodes on the path to the root. If the
computed hash root is the same as in the proof, then the page
is the one used in the original proof system. The proofs are
succinct in the sense that they grow logarithmically in the
number of documents in the proof system, i.e., the size of
the proof is ((log2 n) + 1) ∗ H + S, where H and S are the
sizes of the hash and signature respectively.
The proof system is used to generate an extended content
proof for page pi is shown in Figure 3. The two differences
between this construction and the preceding one are that the
CP Sr is used as the challenge (instead of a document hash),
and that a succinct proof for pi is included. Because a single
quote is used to bind any number of pages to the time quote
and host integrity state, we can efﬁciently support serving a
large body of pages. As we discuss below, the challenge is
knowing exactly what the body of documents is.
C. Proof Scheduling
Content proofs are delivered to browsers through in-
tegrity proof pages. The web server inserts an extension
X-Attest-URL HTTP header in each delivered page whose
URL points to a proof for that page. The browser parses the
header, retrieves the proof from the web server, and validates
the proof. If the validation fails, the browser can log the error,
notify the user, or perform other actions deemed appropriate.
We discuss the design and operation of the Firefox-based client
software in section VI.
Determining what pages should be included in a proof
98
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:10:03 UTC from IEEE Xplore.  Restrictions apply. 
p1p2p3p4h(p1)h(p2)h(p3)h(p4)h(h(p1)|h(p2))h(h(p3)|h(p4))CPSr = h(h(h(p1)|h(p2))|h(h(p3)|h(p4)))ServerRequestsGETQ0Q0Q1Q2!"#$Quote GenerationGETQ0GETQ0GETQ1|
|
{z
Quote(Hw, pcrHw , h(h(pi)
{z
{z
web server quote (content proof + time server quote)
Fig. 2. A content proof construction that ties content to both the originating host and the time.
}| Quote(HT S, pcrHT S , h(ti))
}))
|
|
}|Quote(HT S, pcrHT S , h(ti))
{z
| {z }| Quote(HT S, pcrHT S , h(ti))
}| Quote(HT S, pcrHT S , h(ti))
|
}))
|
}| CP Sr
{z
time server quote
{z
{z
{z
Quote(Hw, pcrHw , h(CP Sr
|
|
}| ti|{z}
time
| {z }| ti|{z}
}|P f (pi)
time
page
proof
web server quote (content proof + time server quote)
time server quote
proof
sys. root
Fig. 3. Extended content proof that uses a cryptographic proof system as the challenge rather than a document hash. A succinct page proof is also included.
Fig. 5.
recent hash tree computed (CPSr).
Server quote generation - The server requests the most recent timestamp from the time server (Q(t0)), and then generates a quote using the most
Fig. 7. Dynamic Page Scheduling - Incoming requests for an integrity proof
page are delayed until the quote including the page is ready. At this point,
a hash tree is generated that includes the cached requests (GET1 and GET2)
and the hash tree is used to generate the next quote (Q1).
system is essential to supporting the browsing community.
Static web pages represent the simplest case. As illustrated
in Figure 5, the web server generates a Merkle hash tree of all
pages it will be serving to clients. The web server will then
generate proofs at the rate at which the TPM can generate
quotes, e.g., once a second. When a browser asks for a proof
for a given page, the succinct proof is extracted from the most
recent proof system completed and returned to the browser,
as shown in Figure 6. A proof is always available because
the content is unchanging. Thus, the latency induced by the
integrity proofs is bounded by the proof acquisition (a web
page GET) and browser validation costs.
Dynamic content presents other challenges. Centrally, the
page content only becomes available after the request arrives
from a client. For example, consider a .php [30] web page.
PHP allows the web designer to create content programmati-
cally. The inputs to this process include referrer page, URL,
query strings, database contents, cookies, and other informa-
tion. Because the inputs are unknowable, precomputation of
pages is infeasible in many cases, and the web server must
create integrity proofs in real time.
As illustrated in Figure 7, our approach is to exploit the
periodicity of quote generation. The web server creates and
delivers content through dynamic generation interfaces, e.g.,
PHP, as in normal operation. However, the proof identiﬁed in
the X-Attest-URL header identiﬁes a proof that does not
yet exist. The web server caches hashes of the dynamic content
delivered since the last quote was completed. As soon as the
TPM becomes available (by completing a previous quote), a
hash tree of recent dynamic content is generated and used as
the challenge to the TPM. The proof system becomes available
as soon as the quote operation completes.
The browser will observe additional latency when receiv-
ing dynamic content. Assuming a 900 msec quote operation
(which is the case in our test environment) and uniform
distribution of arrivals, the expected latency would be about
1350 msec plus the time to deliver the quote itself (which is
network dependent). More speciﬁcally, the expected arrival in
the previous quote epoch is 0.5 ∗ 900 = 450 msec plus the
quote cost itself 900 msec is the expected delay observed by a
browser. Note that this will be interleaved with the delivery
(and possibly rendering) of the content itself, and thus the
observed delay may be somewhat less.
Most web servers simultaneously support static and dynamic
content. The above processes can support this operation by
simply joining the static and dynamic hash trees at the root,
and using the resulting hash as the challenge. In all other
respects, the web content is processed as before—proofs for
static content can be extracted from the most recent proof
system, while proofs for dynamic pages will become available
at the completion of the following quote epoch. No other
modiﬁcations to the web server are needed.
IV. IMPLEMENTATION
We have developed a version of the architecture detailed in
the preceding sections that supports static, dynamic, and mixed
99
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:10:03 UTC from IEEE Xplore.  Restrictions apply. 
Web ServerTPMTime ServerTPMTRQ(t0)Quote OperationQ(h(Q(t0)⎮CPSr))h(Q(t0)⎮CPSr)Quote OperationQ(t1)t1Q(t0)t2!!t0!!!!!!GET4ServerRequestsGET1GET3GET2Q1Q1!"#$Quote Generation (includes requests 1 and 2)Q0Q1Q2user, conﬁrm the rendering, or place visual indicators on the
display,
.e.g, icons or red shading over failed objects. We
brieﬂy touch on this policy further in the description of the
browser extension in Section VI.
B. Time Server
The time service uses a hash of the current hardware
timestamp as a challenge to the TPM (8 in Figure 8). This
time attestation is provided to requesters such as the web
servers for inclusion in content proofs or to clients for clock
synchronization, e.g., to detect content replay attacks.
The time server plays a critical role in operation of the
system, because of the importance of freshness to verifying
attestations. While the web server has a ﬁle system that is
mutable, due to the ability to add, delete, or modify web
ﬁles to be served, the time server’s ﬁle system can become
largely static after it is installed. As a result, we can provide
deeper validation than what is afforded with typical integrity
measurement. We provide trust guarantees from the system
clock all the way to the software, forming a time root of
trust in a similar manner to how a root of trust installer fully
guarantees the system from installation up to applications [26].
This approach provides a smaller base of components that
need to be trusted: the BIOS core root of trust measurement
(CRTM), the TPM, and the clock.
Another requirement solved by this approach is the ability
for the client to directly verify the attestation from the time
server itself. If the client establishes an SSL connection with
the time server,
it can receive the same time update that
is presented to the web server, allowing conﬁrmation of the
validity of the time attestation and veriﬁcation of functionality.
Once the client has established trust with the time server, it can
rely on attestations that are carried in the HTML document
presented to it by the web server.
V. EVALUATION
In this section, we empirically evaluate the performance and
scalability of the Spork system presented in the preceding
sections. We begin by measuring the throughput and latency of
the system compared to an unmodiﬁed Apache web server, and
expose the underlying costs via microbenchmarking. We pro-
pose a number of optimizations and evaluate the performance
impact.
All tests were performed on Dell PowerEdge M605 blades
with 8-core 2.3GHz Dual Quad-core AMD Opteron processors,
16.0GB RAM, and 2x73GB SAS Drives (RAID 1). Six blades
running Ubuntu 8.04.1 LTS Linux kernel version 2.6.24 were
connected over a Gigabit Ethernet switch on a quiescent
network. One blade ran Apache web servers (one normal
install and one running the integrity proof system described