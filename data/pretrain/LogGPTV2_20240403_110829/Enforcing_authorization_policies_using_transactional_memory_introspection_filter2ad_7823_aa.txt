title:Enforcing authorization policies using transactional memory introspection
author:Arnar Birgisson and
Mohan Dhawan and
&apos;Ulfar Erlingsson and
Vinod Ganapathy and
Liviu Iftode
Enforcing Authorization Policies using
Transactional Memory Introspection
Arnar Birgisson
School of Computer Science
Reykjav´ık University
PI:EMAIL
Mohan Dhawan
Department of Computer Science
Rutgers University
´Ulfar Erlingsson
School of Computer Science
Reykjav´ık University
PI:EMAIL
PI:EMAIL
Vinod Ganapathy
Department of Computer Science
Rutgers University
Liviu Iftode
Department of Computer Science
Rutgers University
PI:EMAIL
PI:EMAIL
ABSTRACT
Correct enforcement of authorization policies is a diﬃcult task, es-
pecially for multi-threaded software. Even in carefully-reviewed
code, unauthorized access may be possible in subtle corner cases.
We introduce Transactional Memory Introspection (TMI), a novel
reference monitor architecture that builds on Software Transac-
tional Memory—a new, attractive alternative for writing correct,
multi-threaded software.
TMI facilitates correct security enforcement by simplifying how
the reference monitor integrates with software functionality. TMI
can ensure complete mediation of security-relevant operations,
eliminate race conditions related to security checks, and simplify
handling of authorization failures. We present the design and im-
plementation of a TMI-based reference monitor and experiment
with its use in enforcing authorization policies on four signiﬁcant
servers. Our experiments conﬁrm the beneﬁts of the TMI architec-
ture and show that it imposes an acceptable runtime overhead.
Categories and Subject Descriptors. D.4.6 [Operating Systems]:
Access controls; D.1.3 [Software]: Concurrent programming
General Terms. Languages, Security
Keywords. Reference monitors, Transactional memory
INTRODUCTION
1.
Security enforcement mechanisms must be implemented with spe-
cial care. Because attackers may exploit exceptional state transi-
tions, enforcement must be correct even on uncommon code paths,
for unusual interleavings of execution, or during abnormal error
conditions. Experience shows that achieving these goals is chal-
lenging, especially for multi-threaded software [37, 62]. This pa-
per introduces Transactional Memory Introspection, an architecture
that can signiﬁcantly simplify the task of correctly implementing
security enforcement mechanisms.
Our work is based on Software Transactional Memory (STM)
techniques for declarative concurrency control (e.g., [32, 33, 35,
52]). STM techniques are an active area of research, especially in
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. To copy otherwise, to republish, to post on servers or to redistribute
to lists, requires prior speciﬁc permission and/or a fee.
CCS’08, October 27-31, 2008, Alexandria, Virginia, USA.
Copyright 2008 ACM 978-1-59593-810-7/08/10 ...$5.00.
connection to multi-core trends in hardware concurrency [42]. With
STM, a runtime system ensures that code sections have eﬀects as
if they were executed in serial order; typically, those code sections
are marked using language-level annotations such as atomic or
transaction. STM constrains concurrency without relying on
error-prone locking and provides attractive guarantees, such as
consistent recovery from failures. Although current STM systems
incur high costs, hardware acceleration and language support may
soon provide competitive overhead [42]. Therefore, in the near
future, much software may be written to use STM techniques.
Transactional Memory Introspection (TMI) is a reference moni-
tor architecture that builds on STM semantics and machinery. TMI
allows security enforcement to beneﬁt from STM guarantees, yet
remains compatible with existing security mechanisms, such as
those based on history- or state-based enforcement [2, 17, 30]. TMI
helps ensure that enforcement remains correct, even in corner cases.
In particular, TMI-based enforcement needs neither consider con-
current interleavings of execution nor worry about remedial steps
on policy violation.
Notably, TMI changes how security enforcement is integrated
into software functionality. TMI builds on the precise bookkeep-
ing, or read/write sets, that STM runtime system maintain to de-
tect read/write conﬂicts for concurrent executions. A TMI refer-
ence monitor is implicitly invoked whenever a security-relevant
shared resource is accessed in a transaction—i.e., on all changes
to security-relevant memory objects in the STM read/write sets—
as well as when transactions commit. Application-speciﬁc security
checks ensure security-policy compliance, e.g., that all security-
relevant accesses comply with an authorization policy. A transac-
tion is aborted unless all such security checks are successful.
By triggering security checks on resource accesses, TMI can
ensure complete mediation and can also avoid exceptional control
paths and other complexities arising from explicit security checks.
Furthermore, TMI can reduce the latency and performance over-
heads of expensive security checks, such as group membership
tests. Because security checks need not be fully evaluated until a
transaction attempts to commit, costly security-policy evaluation
can be performed lazily, or in parallel with execution.
The TMI architecture is practical. We have designed and imple-
mented TMI reference monitors for enforcing authorization poli-
cies on server software. In particular, we have created a TMI imple-
mentation based on Sun’s Dynamic Software Transactional Mem-
ory (DSTM2) toolkit for Java [34]. In our design, TMI-based en-
forcement can integrate the functionality of existing authorization
frameworks; we have performed such integration with Java stack
223a1.
a2.
a3.
a4.
a5.
a6.
a7.
a8.
a9.
a10.
a11.
a12.
a13.
a14.
a15.
a16.
dispatch request ( ) {
. . .
perform request ( );
. . .
}
perform request ( ) {
. . .
if (allowed(principal, resource1, access1))
perform access1(resource1);
else handle failure1( );
. . .
if (allowed(principal, resource2, access2))
perform access2(resource2);
else handle failure2( );
. . .
}
b1.
b2.
b3.
b4.
b5.
F b6.
b7.
b8.
b9.
F b10.
b11.
F b12.
b13.
b14.
dispatch request ( ) {
transaction [ principal ] {
. . .
perform request ( );
. . .
/* Commits only if all authorization succeeds */
}
}
perform request ( ) {
. . .
perform access1(resource1);
. . .
perform access2(resource2);
. . .
}
Authorization manager, implicitly consulted by TMI for F lines:
switch ()
case (resource=R, access type=A) −→
if (¬allowed(principal, R, A)) then abort tx;
(a) Current practice in authorization enforcement: Embeds refer-
ence monitor invocations in application code. Presents diﬃculties
in (1) identifying resource accesses and ensuring complete mediation;
(2) eliminating time-to-check to time-of-use bugs (in lines a8/a9 and
lines a12/a13); and (3) correctly handling authorization failures.
(b) TMI-based authorization enforcement: Decouples application
functionality from policy enforcement. (1) Ensures complete mediation
of all resource accesses via introspection on memory-access bookkeeping
performed by the STM runtime; (2) prevents race conditions by construc-
tion; and (3) allows simple handling of authorization failures via rollback.
Figure 1. A comparison of traditional and TMI-based enforcement of authorization policies.
inspection [30] and XACML [23]. TMI can also support I/O when
combined with external transactional I/O mechanisms; we have im-
plemented such support using oﬀ-the-shelf packages for transac-
tional ﬁle and database access.
In summary, the main contributions of this paper are:
We experimented with TMI-based enforcement of authorization
policies on four servers, comprising a total of nearly 55,000 lines of
code, converted to make use of DSTM2. Our experiments conﬁrm
that the TMI architecture can help ensure the correct enforcement
of security policies, and that it can have acceptable enforcement
overhead. We also found that retroﬁtting STM techniques and TMI-
based authorization to existing server software was a manageable
task; most of the work was due to DSTM2 limitations that should
disappear in future, more mature, STM systems. Based on our
experiments, we conclude that the TMI architecture is a useful new
alternative for authorization policy enforcement, and that it can be
widely applicable, even to existing software.
• Transactional Memory Introspection. We introduce TMI, a
new architecture for implementing reference monitors. We de-
scribe its components and applicability, and show that it can
help avoid violation of complete mediation and time-of-check
to time-of-use race conditions, and can simplify handling of er-
rors and authorization failures (Sections 2 and 3).
• An implementation of a TMI reference monitor. We show
that TMI-based enforcement can be practically implemented
and can integrate and build on existing security mechanisms and
frameworks. We present one particular TMI implementation,
suited to the enforcement of authorization policies (Section 4).
• Experimental validation of the beneﬁts of TMI to security
enforcement. We have retroﬁtted server software with a TMI
reference monitor in a way that integrates with the software’s
existing security mechanisms (e.g., XACML or Java stack in-
spection). Our experiments show that adopting TMI-based en-
forcement can be straightforward, and that this results in simpler
and less error-prone code. We measured an acceptable, average
overhead of less than 11% for TMI-based enforcement of autho-
rization policies (Section 5).
2. MOTIVATION AND BACKGROUND
In this section, we ﬁrst present our focus application—enforcement
of authorization policies in server software—and explain how TMI-
based enforcement can help overcome many of the diﬃculties in
the implementation of such enforcement. We then present back-
ground material on transactional semantics and STM techniques.
2.1 Challenges in implementing authorization
Server software must protect shared resources from inappropriate
client access by formulating and enforcing an authorization policy.
Such policies specify, for each shared resource, what principals can
perform which operations. At runtime, a reference monitor should
ensure that each access to a shared resource is authorized.
Unfortunately, as prior work shows, integrating authorization
enforcement into server software is time-consuming and error-
prone. For example, it took almost two years to add invocations
of the Linux Security Modules (LSM) reference monitor to the
Linux kernel [58]. Similar recent attempts to enforce authorization
policies in the X11 server [40, 56], the JVM [25], and IBM Web-
sphere [36] have also become time-consuming, multi-year eﬀorts.
To understand the key diﬃculties in the current practice of
enforcing authorization policies, consider Figure 1(a), which shows
pseudo-code from a server. This server accesses resources on behalf
of a client (on lines a9 and a13). As an example, if this server is
a chat server, the accesses may correspond to adding a user to a
chat forum. Because a chat forum is a shared resource, accesses to
modify the forum must be authorized, e.g., to prevent users from
joining private forums or forums where they are blacklisted.
As shown in Figure 1(a), authorization is typically enforced
by embedding reference monitor checks with server functionality,
using a programming language pattern such as if. . .then. . .else.
ssize t vfs read (struct file *file, . . .) {
. . .
if (check permission(file, MAY READ) == ALLOWED) {
}
. . .
file->f op->read(file, . . .);
}
int page cache read (struct file *file, . . .) {
struct address space *mapping =
file->f dentry->d inode->i mapping;
. . .
mapping->a ops->readpage(file, . . .);
. . .
}
Figure 2. An example showing violation of complete mediation.
Resource accesses are performed conditional on a predicate that
checks whether the access is permitted (lines a8 and a12).
If the access is denied, an error handler is executed (lines a10
and a14) to perform any remedial steps necessary to restore the
software into a consistent state. In this current practice of authoriza-
tion policy enforcement, three major diﬃculties must be overcome,
as discussed below.
(1) Diﬃculty in completely mediating access to resources. Two
properties must be ensured for complete mediation of access to
shared resource. First, each access must be checked and authorized.
Second, each call to the reference monitor must provide the cor-
rect security-relevant metadata, such as the operating principal, the
identities of accessed resources, and the types of access (in the chat
server example, respectively, the user attempting to join, the chat
server forum, and the operation of joining a forum).
In current practice, ensuring these two properties is a chal-
lenge. First, the locations for authorization checks that guard each
resource access (in Figure 1(a), lines a9 and a13) are currently
identiﬁed manually. This process can easily fail to identify re-
source accesses, especially along uncommon, easy-to-overlook
code paths. For instance, consider Figure 2, which shows (sim-
pliﬁed) code snippets from the Linux kernel. Both vfs read and
page cache read read the contents of a ﬁle object (the lines in
bold font). However, the function page cache read does not
check for ﬁle permissions, since it expects them to have been
checked elsewhere. This omission may lead to an unauthorized