a privacy-preserving and secure RHSs.
Additional features. Similarly to current RHSs, ORide
enables the riders to retrieve lost items (i.e., items forgot-
ten in the car), as drivers’ certiﬁcates certD and car in-
formation are provided during the ride set-up procedure.
As discussed earlier, the riders can share certD with their
friends, hence even if the riders lose their phones, they
can still be able to retrieve the certD from their friends
and to then contact the driver (as in current RHSs). More-
over, due to the secure channel established between the
rider and the driver, the rider can still track the driver tra-
jectory while waiting at her pick-up location, or they can
contact each other (e.g., messaging or calling).
7 Protecting against Malicious Behaviors
In this section, we describe how the protocol presented
in Section 5 can be extended to defend against malicious
drivers and a covertly active SP.
USENIX Association
26th USENIX Security Symposium    1243
7.1 Malicious Drivers: Masking
As mentioned in Section 5.4, if a driver behaves mali-
ciously, she could encrypt non-zero values in the slots
other than her allotted one, thus corrupting the inputs
from other drivers. Our protocol can cope with this
malicious behavior by adding one extra step in which
the SP homomorphically multiplies each driver cipher-
text by a mask mi = NTT−1(X i) for the driver’s index i
(see notations from Section 5.4), which preserves only
the contents in the allocated slot. However, because the
mask does not hold any sensitive information and it is
known by the SP, a naive homomorphic multiplication
with an encrypted mask would incur an unjustiﬁed over-
head. Therefore, we propose, instead, a more efﬁcient
multiplication operation, denoted (cid:63), as follows.
q corresponding to a
plaintext m ∈ Rt, and a mask mi ∈ Rt, we want to obtain a
ciphertext ccc(cid:48) = ccc (cid:63)mi corresponding to the masked plain-
text FV.Dec(ks,ccc) · mi. Here, mi can be thought of as
its own noiseless and unscaled encryption (Equation (1)
on page 4, evaluated for u,e1,e2 = 0, and no scale ∆),
being a vector in R2
q with only one non-zero component
([mi,0] ∈ R2
Given a ciphertext ccc = [c0,c1] ∈ R2
q). Therefore, the product results
ccc (cid:63) mi = [c0 · mi,c1 · mi].
The (cid:63) operation consists of two polynomial multipli-
cations, it avoids encryption of mi, halves the number
of products w.r.t. an encrypted homomorphic multipli-
cation, and keeps the cipher size from growing after the
product, thus considerably improving the performance of
this operation.
In any case, this precaution is only needed in case the
drivers are malicious; and random checks on their loca-
tions can be implemented instead if the drivers are just
covertly active (i.e., they refrain from cheating if there is
a negligible chance of being caught in the act).
7.2 Covertly Active SP
If the SP is an active attacker, it might attempt to perform
a man-in-the-middle (MITM) attack at Step 2 of the ride
set-up protocol (Section 5.4) by replacing the public key
kkkp. However, this can be detected because the driver can
share the key she received with the rider through the se-
cure channel. If the rider detects that this key is different
from the one she originally sent to the SP, then a MITM
attack must have happened. The SP might also attempt
to tamper with the set-up of the secure channel (Step 7a,
Fig. 2). However, this can be detected because via the
proximity channel, the rider and the driver can compare
with each other the inputs that they received from the SP
during the set-up protocol.
As mentioned in Section 5.4, any valid rider can gen-
erate an ephemeral key to make a ride request. As the SP
issues credentials for riders and drivers, it can imperson-
ate a rider or a driver in its own system. If the SP con-
tinuously impersonates a rider, it could learn the drivers’
locations from which it could learn the coarse-grained
pick-up locations of the riders. In other words, if a rider
chooses the driver who is the closest to her pick-up loca-
tion, the SP would know that she is in the Voronoi cell of
her selected driver [2]. Next, we present a mechanism for
deterring this attack. We note that the attack is not trivial,
due to the high dynamics of the system, i.e., drivers can
arbitrarily go on-line and off-line anytime. The SP would
not have strong incentives to perform this attack, because
it would add computational and bandwidth overhead to
the service, thus negatively affecting the productivity of
the service itself. To deter this attack, we introduce the
notion of Proof-of-Ride (PoR), deﬁned and used as ex-
plained below. An illustration of the protocol with PoR
is shown in Appendix A.1.
A PoR is a random number rand generated by the
rider, signed by the driver by using the secret key associ-
ated with her certD, and then blindly signed by the SP by
using blind-signature schemes such as [13], i.e., PoR =
BsigSP{sigD{rand}}. It is used to prove to the drivers
that the rider is real, i.e., she did a ride in the past. When
a rider makes a ride request, she has to provide in her
ride request a PoR, the certD and the random number
rand used in the PoR. A PoR can be used only once. For
the ﬁrst ride, PoR = certR.
To prevent the SP from creating its own certR and
certD in order to create its own fake PoR, the SP has to
provide a public bulletin board such as certiﬁcate trans-
parency [27]: the SP maintains and publishes a publicly
auditable and append-only log of all rider and driver cer-
tiﬁcates it has issued and revoked. Whenever a driver
receives a PoR, she can check whether the rider’s certiﬁ-
cate certR (in the case of the ﬁrst ride), or the driver’s
certiﬁcate indicated in the PoR, is in the list of certiﬁ-
cates published by the SP. In this way, if the SP inter-
nally creates fake accounts, it can be detected by audit-
ing authorities, similarly to the cases of companies open-
ing fake user accounts [10]. Similarly, to prevent a rider
from double-spending a PoR, and the SP from reusing a
valid PoR to perform the aforementioned active attack,
the SP maintains and publishes an append-only logs of
PoRs that have been spent, or cancelled (due to ride can-
cellation).
Note that PoR could create a point of linkability,
i.e., the SP is able to know that the rider is in the set
of identities indicated in the fare reports deposited by a
speciﬁc driver. This can be easily prevented by using
anonymous-reputation and anonymous-payment systems
(e.g., e-cash), as used in the PrivateRide system [39].
1244    26th USENIX Security Symposium
USENIX Association
this is not an additional leakage of information. In ad-
dition, knowing the home/work addresses and the fares
of the rides, the SP might be able to infer if a rider went
from home to work. However, note that even for frequent
rides between home and work of the same rider, the fares
would not be the same due to different routes and traf-
ﬁc conditions. Therefore, the inference of rides between
home and work of a rider is error-prone. Moreover,
such rides are not sensitive, compared to others, such as
one-night stands, going to abortion clinics or political-
party meetings. For improved anonymity, anonymous-
payment methods, such as e-cash or regular cash, could
be used to decouple the riders’ identities from the fares,
thus preventing the SP from learning about rides between
home and work of the riders.
By using the Ride DB, the SP might be able to guess
the identities of the riders, only if the pick-up zone has a
limited number of ride activities and riders, e.g., a zone
where only one rider lives. This case, however, is un-
likely to happen in ORide, because the zones are deﬁned
in such a way that each zone has at least a large mini-
mum number of ride requests per day, while balancing
the bandwidth requirements for the drivers. We illustrate
this in Section 9. Note that the SP would be detected if
it lied about the activity densities in the zones, because
these densities are public knowledge [43], and the drivers
would notice if they received very few ride requests from
a certain zone.
In the case where the SP knows that a rider makes ride
requests from a speciﬁc zone (e.g., the zone that contains
her home/work addresses) and it wants to know the pick-
up times of these rides, the anonymity set of a ride is
the number of rides that occurred on the same day from
that zone. As this requires the SP to have precise knowl-
edge about the pick-up zones, the anonymity-set size in
this case is the lower-bound estimation of the anonymity
set for the general case of large-scale proﬁling attacks
by the SP. This lower bound is used in the evaluation of
the anonymity set achieved by ORide, presented in Sec-
tion 9.
(A3) Targeted attacks by the SP.
In the case where
the SP knows the precise pick-up location and time of a
ride, it still cannot know the drop-off location and time
of the ride, because, in ORide, the drop-off event is not
reported to the SP. Knowing the fare from the Payment
DB, the SP might be able to guess whether the target
went home or to work, but it could not know about other
destinations. However, note that similar to the aforemen-
tioned case, the inference of rides between home and
work of a rider is error-prone. Also such rides are not
very sensitive. Anonymous-payment methods, such as
e-cash could be used to prevent these attacks.
PII-
siders.
out-
ORide relies on a similar proximity-check
and location-harvesting
Table 2: Information observed by the SP during ride set-up
procedure w.r.t. different RHS designs. Note that the zone in
ORide is larger than the zone in PrivateRide without affect-
ing the ride-matching optimality (see Section 9.4). Also note
that, the payment operation in ORide reveals some information
about the riders, but it cannot be used to break the anonymity
of the rides (see Section 8).
8 Privacy and Security Analysis
In this section, we present an analysis of ORide to show
that it effectively addresses against the privacy attacks
described in Section 3.1.
The SP cannot de-anonymize a rider or driver through
their anonymous logins by using their ACs. This is guar-
anteed due to the anonymity and unlinkability properties
of the ACL anonymous credential system [9]. Addition-
ally, the SP cannot obtain extra information from the rid-
ers’ and drivers’ encrypted locations and their encrypted
distances; this is due to the semantic security property of
the FV encryption scheme [16].
In ORide, the information observed by the SP from
ORide operations can be put in two databases, as follows
(see Table 2).
• Ride DB, in which each entry contains the role and ex-
piration date of the AC, the pick-up zone and obfus-
cated pick-up time. The role and expiration date are
coarse-grained, i.e., all ACs issued on the same day ex-
pire at the end of the day they were issued.
• Payment DB, in which each entry contains a rider’s ID,
a driver’s ID, a fare, and the day the fare report is de-
posited to the SP. Note that this database does not exist
if payment is done through e-cash or regular cash, as the
fare and payment are done without the SP knowledge.
(A2) Large-scale inference attacks by the SP. To pro-
ﬁle riders’ and drivers’ activities, the SP needs to learn
the identities, the locations, and the times associated with
their rides.
By using the Payment DB, the SP would know which
speciﬁc rider took a ride with a speciﬁc driver on which
day and what its fare was. Since RHS drivers are of-
ten licensed to operate in a city or state, knowing that
a rider took a ride with a speciﬁc driver, the SP might
be able to know the city where the rider took a ride, but
it does not know the speciﬁc location in the city. Note
that, in most cases, as the city could be inferred from
the zones reported by the riders in their ride requests,
USENIX Association
26th USENIX Security Symposium    1245
attacks by
Identities Pick-up loc. Pick-up time Drop-off loc. Drop-off time Loc. trace Fare Current RHSs Rider, Driver Precise Precise Precise Precise Full Yes PrivateRide Driver Zone Obfuscated Zone Obfuscated Partial Yes ORide N/A Zone Obfuscated N/A N/A N/A N/A locations at
mechanism as PrivateRide, hence it provides the same
guarantees for harvesting-attacks against drivers’ PII.
However, a malicious outsider might attempt to triangu-
late drivers, to obtain a snapshot of the locations of all
drivers in a zone: It could make three fake ride requests
from different
the same time to obtain
the distances, and cancels these requests immediately.
ORide mitigates this attack by applying two measures:
(1) requiring a deposit token from each rider per request,
thus making the attack more ﬁnancially expensive and
enabling the SP to identify riders who make many
requests and cancel (as discussed in Section 5.6), and
(2) permuting the list of drivers’ indices for each ride
request (Step 2 in Section 5.4). Also, the SP can deﬁne
a smaller threshold on the number of ACs each rider
account can obtain per day, if the threat of such an attack
is high.
9 Evaluation
In this section, we evaluate our protocols by using a real
data-set of taxi rides. We ﬁrst evaluate the performance
of the ride-matching operation in terms of computational
and bandwidth requirements for the riders and drivers.
We then evaluate the effect of Euclidean distances on the
optimality of ride-matching operations.
9.1 Data-Sets
Our data-set consists of over 1.1 billion taxi rides in New
York from January 2009 to June 2015 [44]. We ex-
tracted data for the month of October in 2013, one of
the busiest months in the data-set, which resulted in a
subset of over 15 million rides. In this subset, the aver-
age duration of the rides is 13 minutes. The GPS traces
of the rides are not given; however, the precise pick-
up and drop-off locations and times, and pseudo-IDs of
the taxi drivers associated with the rides are provided.
In addition, the data-set provides mapping between lati-
tude/longitude coordinates to NYC census tracts (CTs),
neighborhood tabulation areas (NTAs) and boroughs in
NYC.
We make the following assumptions. First, the drop-
off location of a driver is her waiting location for new
ride requests. Second, a ride-request event is a pick-up
event (i.e., consisting of a pick-up location and pick-up
time) in our data-set. Third, for each ride-request event,
the set of drivers available for that request consists of
drivers who have at least one drop-off event in the last 30
minutes since the ride-request timestamp. The 30-minute
interval is chosen, because the data-set shows that 99th
percentile of the time gap between the drop-off event of
a driver and her next pick-up event is approximately 30
minutes.
Rider
Setting
Algorithm
S1
S2
S3
Upload
(KB)
372
372
372
Download
(KB)
761856
186
186
Driver
Download
(KB)
124
124
124
Upload
(KB)
248
248
248
Implementation Details