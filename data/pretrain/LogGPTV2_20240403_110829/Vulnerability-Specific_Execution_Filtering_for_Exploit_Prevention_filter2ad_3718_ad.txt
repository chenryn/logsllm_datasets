4.1. Taint-based VSEF
4.1.1. Implementation
As discussed in Section 2, TaintCheck already records
the information needed to produce a taint-based VSEF ﬁlter.
As the monitored program is executing it keeps a directed
acyclic graph (DAG) that represents how tainted data was
propagated, and what instructions propagated it. When an
exploit is detected, part of the output is the part of the DAG
showing how the misused tainted data was derived. We im-
Avg Time (s) Overhead
Native
DynamoRIO
+ Taint-based VSEF ﬁlter
121.4
135.05
138.35
-
11%
14%
Table 2. SQL taint-based VSEF benchmark.
Latency (ms) Overhead
Native
Valgrind
+ Taint-based VSEF ﬁlter
Full TaintCheck
Destination-based VSEF
.566
1.279
1.360
9.797
.585
-
126%
140%
1631%
3%
Table 3. ATPhttpd taint-based VSEF and
destination-based VSEF benchmark.
(1 KB
pages)
plemented the taint-based VSEF Filter Generator by mod-
ifying TaintCheck to save the set of instruction addresses
from that part of the DAG into a separate ﬁle, along with
the instruction address where the tainted data was misused.
This ﬁle is the taint-based VSEF ﬁlter.
We also implemented the taint-based VSEF Binary In-
strumentation Engine as an extension to TaintCheck. Nor-
mally TaintCheck adds taint-propagation instrumentation to
every instruction that propagates data, which is most in-
structions. It also adds taint-assertions to every instruction
that could potentially misuse tainted data. In our extension,
TaintCheck accepts a taint-based VSEF ﬁlter as input, and
then only adds taint-propagation to the propagation instruc-
tions listed in the VSEF ﬁlter, and taint-assertion instrumen-
tation to the misuse instruction listed in the VSEF ﬁlter.
Note that our current implementation of the taint-based
VSEF Binary Instrumentation Engine is intended only as
a prototype to show the relative difference between mon-
itoring nearly every instruction, and monitoring only the
instructions in the taint-based VSEF ﬁlter. However,
TaintCheck is currently implemented on Valgrind [24] (for
Linux), and DynamoRIO [1] (for Windows). Both of these
tools are well suited for when the entire program needs to
be monitored, but they each add substantial overhead even
when no instrumentation is added. A more efﬁcient imple-
mentation could be done using a tool such as Dyninst [2],
which is better suited for adding instrumentation to speciﬁc
points of a program.
(We use Dyninst to implement the
destination-based VSEF Binary Instrumentation Engine).
4.1.2. Evaluation
We evaluate the quality and efﬁciency of our taint-based
VSEF using real world exploits. We have tested the ef-
fectiveness of our taint-based VSEF approach on Windows
against the SQL Slammer attack [22], and on Linux against
the ATPhttpd exploit [29].
Taint-based VSEF Filter Size. The ﬁlter generated for the
ATPhttpd exploit contains only 10 instructions that must be
instrumented. The ﬁlter for the vulnerability exploited by
the SQL Slammer worm contains 200 instructions that must
be instrumented. Note that our Windows implementation
of taint-based VSEF Filter Generator, which is based on
the less mature DynamoRIO implementation of TaintCheck,
currently adds every instruction that operates on the mis-
used tainted data to the VSEF ﬁlter, rather than reﬁning it
to only the instructions that actually propagate the tainted
data to the point where it is misused. This reﬁnement is
straight-forward to implement, and should reduce the ﬁlter
size by an order of magnitude. For comparison, the AT-
Phttpd VSEF ﬁlter contains 83 instructions without this re-
ﬁnement.
Taint-based VSEF Performance. The time to generate a
VSEF and use it to harden a binary is very small. For AT-
Phttpd it was 186 microseconds to generate a VSEF from
TaintCheck’s DAG, and 195 ms to use the VSEF to harden
the ATPhttpd binary. Here, we measure the performance of
the hardened Microsoft SQL Server and the hardened AT-
Phttpd server. For both tests, we issue queries to the server
process from the same machine so as to not introduce net-
work latency.
We subjected the Microsoft SQL server to the bench-
mark query described in [19]. We measured performance
when the server was run natively, and when it was run un-
der DynamoRIO with and without the taint-based VSEF in-
strumentation. Table 2 shows the results. The instrumenta-
tion added by the taint-based VSEF causes the server to run
only 14% slower than native, and only 2% slower than run-
ning under DynamoRIO alone. Again, implementing the ﬁl-
ter reﬁnement step for the Windows version of TaintCheck
would reduce the number of instructions instrumented, and
further reduce the taint-based VSEF overhead.
We used the Apache Flood tool [39] to measure the per-
formance of the hardened ATPhttpd server when serving 1
KB ﬁles. Results are shown in Table 3. Our results show
that the hardened server runs only 6% slower than when
running under Valgrind alone. We also ran the same bench-
mark using Valgrind to count how often the instrumented
instructions are executed. We found that the 10 instructions
instrumented by the taint-based VSEF accounted for only
32,649 of 746,419,783 instructions executed (.00437%).
This suggests that implementing the VSEF Binary Instru-
mentation Engine with more efﬁcient instrumentation tech-
niques (such as DynamoRIO or Dyninst) should result in the
taint-based VSEF having very little performance overhead.
Taint-based VSEF Accuracy. We veriﬁed that the hard-
ened ATPhttpd and Microsoft SQL server were able to suc-
cessfully defend against the original exploit. For ATPhttpd,
we also created synthetic polymorphic variants of the ex-
ploit by replacing the code in the request with randomly
generated bytes. We veriﬁed that the hardened ATPhttpd
successfully detected these modiﬁed versions of the exploit,
thus demonstrating that our taint-based VSEF approach is
effective against polymorphic variants of the sample exploit.
During our benchmarks, neither hardened server had
false positives. We also sent the ATPhttpd server several
anomalous requests that exercise similar code paths as the
exploit, without actually exploiting the server. The hard-
ened ATPhttpd correctly did not identify these as attacks.
4.2. Destination-based VSEF
4.2.1. Implementation
We implemented the destination-based VSEF Binary In-
strumentation Engine using Dyninst [2], a binary instrumen-
tation tool. Unlike Valgrind and DynamoRIO, Dyninst per-
forms static rewriting of the target binary. Instructions are
instrumented by overwriting them with jumps to trampo-
line functions that call our instrumentation code, and then
execute the overwritten instruction before returning. This
approach was chosen to avoid the run-time overhead of dy-
namic binary rewriting. Dyninst and our destination-based
VSEF Binary Instrumentation Engine run on both Linux
and Windows.
The destination-based VSEF ﬁlter consists of the ad-
dress of the overwrite point, the activation records on the
stack when the overwrite point was executed in the origi-
nal exploit, and the normalized address of the data that was
overwritten. Given the exploit execution trace generated by
TaintCheck, the destination-based VSEF ﬁlter is generated
using the algorithm from Section 3.2 to identify which in-
struction is the overwrite point, and pulling the rest of the
information from the exploit execution trace in a straight-
forward manner. We assume the most difﬁcult scenario,
in which no debug or type information is available to help
identify the overwrite point.
We observe that the overwrite instruction is usually a
mov instruction, which is usually too small to be overwrit-
ten by a jump instruction by Dyninst. Dyninst handles this
case by instead overwriting it with a 1 byte instruction to
generate a trap, which causes the operating system to deliver
a signal to the process, and the instrumentation code to be
executed by the signal handler.1 This is undesirable, since
this is a relatively expensive process. We observe that in
many cases, the instrumented mov is called frequently (i.e.,
1Dyninst version 5, which is currently under development, uses a dif-
ferent method to insert instrumentation which should mostly eliminate the
need to use traps. Unfortunately, we were not able to test this version at
the time of writing.
it may be in strcpy), but usually not in the vulnerable
context. Therefore we address this problem by only having
the instrumentation be used when the function is called in
the vulnerable context. The most efﬁcient way to do this is
by copying the functions that make up the vulnerable con-
text, and rewriting the corresponding call instructions so
that the instrumented mov is only used in the vulnerable
context.
In cases where this is infeasible, we can dynam-
ically enable or disable the mov instrumentation when the
vulnerable context is entered or left.
We currently implement the latter approach. We imple-
mented the VSEF Binary Instrumentation Engine to instru-
ment the call instruction corresponding to each activation
record in the vulnerable context. This instrumentation in-
crementally tracks which of the activation records of the
vulnerable context are currently on the stack. The instru-
mentation for the last call of the vulnerable context dy-
namically adds or removes the instrumentation at the over-
write point when the vulnerable context is entered or left.
Note that if we instrumented only this call instead of each
call in the vulnerable context, the instrumentation would
need to walk the stack every time that call was executed
to see if it was in the vulnerable context, which would result
in a higher performance cost.
The instrumentation at
the overwrite point checks
whether the instruction is about to write to the protected
location. If so, an attack is detected.
4.2.2. Evaluation
We evaluate the quality and efﬁciency of our destination-
based VSEF using the ATPhttpd exploit.2
Destination-based VSEF Filter Size. The ﬁlter generated
for the ATPhttpd vulnerability consists of the addresses of
12 instructions (the mov that causes the overwrite, and the
11 call instructions corresponding to the vulnerable con-
text), and a range of offsets from the vulnerable stack frame
to protect. The ATPhttpd exploit overwrote the return ad-
dress, so in this case we are protecting the return address,
which is located at offsets 4 to 7 in the vulnerable stack
frame. (In our implementation, we recognize this case and
extend the range to 0 to 7 to also protect the frame pointer).
To clarify, if we were protecting data inside the stack frame
(such as a local variable storing a function pointer), this off-
set would be negative.
Destination-based VSEF Performance. It takes a negligi-
ble amount of time to create a destination-based VSEF ﬁl-
ter from TaintCheck’s log, and to use the destination-based
VSEF Binary Instrumentation Engine to harden the vulner-
2At the time of writing, the Windows implementation of TaintCheck
does not log the correct information to create a destination-based VSEF, so
we were unable to evaluate our destination-based VSEF for the Microsoft
SQL server exploit. However, doing so would be straight-forward.
able binary. Here, we measure the performance of the hard-
ened ATPhttpd server.
As in Section 4.1, we evaluate the performance of the
hardened ATPhttpd server using the Apache Flood tool to
measure the time to serve requests for 1 KB ﬁles. Our re-
sults are shown in Table 3. Our results show that the server
runs only 3% slower than when the server is run without
instrumentation.
We also used Valgrind to count how often the instru-
mented instructions are executed during the benchmark.
The 12 instrumented instructions accounted for 6,070 of
746,465,052 instructions executed(.000813%).
Destination-based VSEF Accuracy. We veriﬁed that the
hardened ATPhttpd server was able to successfully defend
against the original exploit. As in the taint-based VSEF ex-
periment, we also veriﬁed that server was able to defend
against polymorphic variations of the exploit, and that it cor-
rectly did not identify similar but non-exploiting requests as
attacks.
5. Deployment and Applications
Vulnerability-speciﬁc execution ﬁltering meets three im-
portant goals: fast ﬁlter generation, accurate detection, and
low performance overhead. These requirements address the
most relevant threat to today’s Internet infrastructure: fast
spreading worms. Worms that exploit known vulnerabilities
can cause millions of dollars of damage. A worm exploiting
an unknown vulnerability could be much more devastating.
Figure 2 shows our envisioned architecture for defend-
ing against worms. Various full instrumentation detectors
are placed across the Internet, for example on honeypots or
over-provisioned sites. When a new worm is released, the
full instrumentation version detects the exploit and uses the
VSEF Filter Generator to create an execution ﬁlter. The ﬁl-
ter is then distributed to other vulnerable hosts across the In-
ternet (that have the same vulnerable binary, similar shared
libraries, etc.), which use VSEF Binary Instrumentation En-
gine to harden their binaries against subsequent infection.
This hardening can be done without restarting the server for
destination-based VSEF, because Dyninst is able to attach
to an already running program and instrument it without
restarting. Taint-based VSEF could also be implemented
using Dyninst, which would also allow it to harden the pro-
gram binary without needing to restart the program.
Our architecture provides for completely automatic re-
sponse and containment, and therefore can respond to a
rapid worm outbreak. Our system also works for previously
unknown vulnerabilities where the hardened binary can be
used until a proper patch can be installed. We note that sites
may be unmotivated to install automatically generated net-
work ﬁlters with suspect accuracy. The accuracy of our ﬁl-
ters make automatic installation much more attractive.
3. VSEF filter
disseminated
1: New exploit received
Primergy