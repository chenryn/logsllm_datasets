101
 Summary
• 
OAuth 2.0 is the de facto standard for securing APIs, and it primarily 
solves the access delegation problem.
• 
A grant type in OAuth 2.0 defines how a client can obtain an 
authorization grant from a resource owner to access a resource on 
his/her behalf.
• 
OAuth 2.0 core specification defines five grant types: authorization 
code, implicit, password, client credentials, and refresh.
• 
Refresh grant type is a special grant type, which is used by an OAuth 
2.0 client application to renew an expired or closer to expiry access 
token.
• 
Implicit grant type and client credentials grant types do not return 
back any refresh tokens.
• 
Implicit grant type is obsolete and is not recommended to use due to 
its own inherent security issues.
• 
OAuth 2.0 supports two types of client applications: public clients 
and confidential clients. Single-page applications and native mobile 
applications fall under public clients, while web applications fall 
under confidential clients.
• 
The OAuth 2.0 Authorization Framework: JWT Secured Authorization 
Request (JAR) draft proposal suggests to introduce the ability to send 
request parameters in a JWT.
• 
The Pushed Authorization Requests (PAR) draft proposal suggests 
to introduce a push endpoint at the authorization server end, so the 
client applications can securely push all the authorization request 
parameters and then initiate the browser-based login flow.
Chapter 4  Oauth 2.0 Fundamentals
103
© Prabath Siriwardena 2020 
P. Siriwardena, Advanced API Security, https://doi.org/10.1007/978-1-4842-2050-4_5
CHAPTER 5
Edge Security with  
an API Gateway
The API gateway is the most common pattern in securing APIs in a production 
deployment. In other words, it’s the entry point to your API deployment. There are many 
open source and proprietary products out there, which implement the API gateway 
pattern, which we commonly identify as API gateways. An API gateway is a policy 
enforcement point (PEP), which centrally enforces authentication, authorization, and 
throttling policies. Further we can use an API gateway to centrally gather all the analytics 
related to APIs and publish those to an analytics product for further analysis and 
presentation.
 Setting Up Zuul API Gateway
Zuul1 is an API gateway (see Figure 5-1) that provides dynamic routing, monitoring, 
resiliency, security, and more. It is acting as the front door to Netflix’s server 
infrastructure, handling traffic from all Netflix users around the world. It also routes 
requests, supports developers’ testing and debugging, provides deep insight into Netflix’s 
overall service health, protects the Netflix deployment from attacks, and channels traffic 
to other cloud regions when an Amazon Web Services (AWS) region is in trouble. In this 
section, we are going to set up Zuul as an API gateway to front the Order API, which we 
developed in Chapter 3.
1 https://github.com/Netflix/zuul
104
All the samples used in this book are available in the https://github.com/
apisecurity/samples.git git repository. Use the following git command to clone it. All 
the samples related to this chapter are inside the directory ch05. To run the samples in 
the book, we assumed you have installed Java (JDK 1.8+) and Apache Maven 3.2.0+.
\> git clone https://github.com/apisecurity/samples.git
\> cd samples/ch05
 Running the Order API
This is the simplest API implementation ever, which is developed with Java Spring 
Boot. In fact one can call it as a microservice as well. You can find the code inside the 
directory, ch05/sample01. To build the project with Maven, use the following command 
from the sample01 directory:
\> cd sample01
\> mvn clean install
Figure 5-1. A typical Zuul API gateway deployment at Netflix. All the Netflix 
microservices are fronted by an API gateway
Chapter 5  edge SeCurity with an api gateway 
105
Now, let’s see how to run our Spring Boot service and talk to it with a cURL client. 
Execute the following command from ch05/sample01 directory to start the Spring Boot 
service with Maven.
\> mvn spring-boot:run
To test the API with a cURL client, use the following command from a different 
command console. It will print the output as shown in the following, after the initial 
command.
\> curl http://localhost:8080/order/11
{"customer_id":"101021","order_id":"11","payment_method":{"card_type": 
"VISA","expiration":"01/22","name":"John Doe","billing_address":"201, 1st 
Street, San Jose, CA"},"items": [{"code":"101","qty":1},{"code":"103","qty"
:5}],"shipping_address":"201, 1st Street, San Jose, CA"}
 Running the Zuul API Gateway
In this section, we are going to build the Zuul API gateway as a Spring Boot project and 
run it against the Order service. Or in other words, the Zuul gateway will proxy all the 
requests to the Order service. You can find the code inside ch05/sample02 directory. To 
build the project with Maven, use the following commands:
\> cd sample02
\> mvn clean install
Before we delve deep into the code, let’s have a look at some of the notable Maven 
dependencies and plugins added into ch05/sample02/pom.xml. Spring Boot comes 
with different starter dependencies to integrate with different Spring modules. The 
spring- cloud-starter-zuul dependency (as shown in the following) brings in Zuul 
API gateway dependencies and does all the wiring between the components, making the 
developer’s work to a minimum.
  org.springframework.cloud
  spring-cloud-starter-zuul
Chapter 5  edge SeCurity with an api gateway 
106
It is important to have a look at the class file src/main/java/com/apress/ch05/
sample02/GatewayApplication.java. This is the class which spins up the Zuul API 
gateway. By default it starts on port 8080, and you can change the port by adding, say, for 
example, server.port=9000 to the src/main/resources/application.properties file. 
This will set the API gateway port to 9000. The following shows the code snippet from 
 GatewayApplication class, which spins up the API gateway. The @EnableZuulProxy 
annotation instructs the Spring framework to start the Spring application as a Zuul 
proxy.
@EnableZuulProxy
@SpringBootApplication
public class GatewayApplication {
    public static void main(String[] args) {
        SpringApplication.run(GatewayApplication.class, args);
    }
}
Now, let’s see how to start the API gateway and talk to it with a cURL client. The 
following command executed from ch05/sample02 directory shows how to start the API 
gateway with Maven. Since the Zuul API gateway is also another Spring Boot application, 
the way you start it is the same as how we did before with the Order service.
\> mvn spring-boot:run
To test the Order API, which is now proxied through the Zuul API gateway, let’s use 
the following cURL. It will print the output as shown in the following. Also make sure 
that the Order service is still up and running on port 8080. Here we add a new context 
called retail (which we didn’t see in the direct API call) and talk to the port 9090, where 
the API gateway is running.
\> curl http://localhost:9090/retail/order/11
{"customer_id":"101021","order_id":"11","payment_method":{"card_type": 
"VISA","expiration":"01/22","name":"John Doe","billing_address":"201, 1st 
Street, San Jose, CA"},"items": [{"code":"101","qty":1},{"code":"103","qty"
:5}],"shipping_address":"201, 1st Street, San Jose, CA"}
Chapter 5  edge SeCurity with an api gateway 
107
 What Happens Underneath?
When the API gateway receives a request to the retail context, it routes the request 
to the back-end API. These routing instructions are set in the src/main/resources/
application.properties file, as shown in the following. If you want to use some other 
context, instead of retail, then you need to change the property key appropriately.
zuul.routes.retail.url=http://localhost:8080
 Enabling TLS for the Zuul API Gateway
In the previous section, the communication between the cURL client and the Zuul API 
gateway happened over HTTP, which is not secure. In this section, let’s see how to enable 
Transport Layer Security (TLS) at the Zuul API gateway. In Chapter 3, we discussed 
how to secure the Order service with TLS. There the Order service is a Java Spring Boot 
application, and we follow the same process here to secure the Zuul API gateway with 
TLS, as Zuul is also another Java Spring Boot application.
To enable TLS, first we need to create a public/private key pair. The following 
command uses keytool that comes with the default Java distribution to generate a key 
pair and stores it in keystore.jks file. If you are to use the keystore.jks file as it is, 
which is inside sample02 directory, you can possibly skip this step. Chapter 3 explains in 
detail what each parameter in the following command means.
\> keytool -genkey -alias spring -keyalg RSA -keysize 4096 -validity 3650 
-dname "CN=zool,OU=bar,O=zee,L=sjc,S=ca,C=us" -keypass springboot -keystore 
keystore.jks -storeType jks -storepass springboot
To enable TLS for the Zuul API gateway, copy the keystore file (keystore.jks), 
which we created earlier, to the home directory of the gateway (e.g., ch05/sample02/) 
and add the following to the [SAMPLE_HOME]/src/main/resources/application.
properties file. The samples that you download from the samples git repository 
already have these values (and you only need to uncomment them), and we are using 
springboot as the password for both the keystore and the private key.
server.ssl.key-store: keystore.jks
server.ssl.key-store-password: springboot
server.ssl.keyAlias: spring
Chapter 5  edge SeCurity with an api gateway 
108
To validate that everything works fine, use the following command from  
ch05/sample02/ directory to spin up the Zuul API gateway and notice the line, which 
prints the HTTPS port. If you already have the Zuul gateway running from the previous 
exercise, please shut it down first.
\> mvn spring-boot:run
Tomcat started on port(s): 9090 (https) with context path "
Assuming you already have the Order service still running from the previous section, 
run the following cURL command to access the Order service via the Zuul gateway, over 
HTTPS.
\> curl –k https://localhost:9090/retail/order/11
{"customer_id":"101021","order_id":"11","payment_method":{"card_type":"V
ISA","expiration":"01/22","name":"John Doe","billing_address":"201, 1st 
Street, San Jose, CA"},"items": [{"code":"101","qty":1},{"code":"103","qty"
:5}],"shipping_address":"201, 1st Street, San Jose, CA"}
We used the -k option in the preceding cURL command. Since we have self-signed 
(untrusted) certificates to secure our HTTPS endpoint, we need to pass the –k parameter 
to advise cURL to ignore the trust validation. In a production deployment with proper 
certificate authority–signed certificates, you do not need to do that. Also, if you have  
self- signed certificates, you can still avoid using –k, by pointing cURL to the 
corresponding public certificate.
\> curl --cacert ca.crt https://localhost:9090/retail/order/11
You can use the following keytool command from ch05/sample02/ to export the 
public certificate of the Zuul gateway to ca.crt file in PEM (with the -rfc argument) 
format.
\> keytool -export -file ca.crt -alias spring –rfc -keystore keystore.jks 
-storePass springboot
The preceding command will result in the following error. This complains that 
the common name in certificate, which is zool, does not match with the hostname 
(localhost) in the cURL command.
curl: (51) SSL: certificate subject name 'zool' does not match target host 
name 'localhost'
Chapter 5  edge SeCurity with an api gateway 
109
Ideally, in a production deployment when you create a certificate, its common name 
should match the hostname. In this case, since we do not have Domain Name Service 
(DNS) entry for the zool hostname, you can use the following workaround, with cURL.
\> curl --cacert ca.crt https://zool:9090/retail/order/11 --resolve 
zool:9090:127.0.0.1
 Enforcing OAuth 2.0 Token Validation at the Zuul API 
Gateway
In the previous section, we explained how to proxy requests to an API, via the Zuul API 
gateway. There we didn’t worry about enforcing security. In this section, we will discuss 
how to enforce OAuth 2.0 token validation at the Zuul API gateway. There are two parts 
in doing that. First we need to have an OAuth 2.0 authorization server (also we can call 
it a security token service) to issue tokens, and then we need to enforce OAuth token 
validation at the Zuul API gateway (see Figure 5-2).
Figure 5-2. The Zuul API gateway intercepts all the requests going to the Order 
API and validates OAuth 2.0 access tokens against the authorization server (STS)
Chapter 5  edge SeCurity with an api gateway 
110
 Setting Up an OAuth 2.0 Security Token Service (STS)
The responsibility of the security token service (STS) is to issue tokens to its clients and 
respond to the validation requests from the API gateway. There are many open source 
OAuth 2.0 authorization servers out there: WSO2 Identity Server, Keycloak, Gluu, and 
many more. In a production deployment, you may use one of them, but for this example, 
we are setting up a simple OAuth 2.0 authorization server with Spring Boot. It is another 
microservice and quite useful in developer testing. The code corresponding to the 
authorization server is under ch05/sample03 directory.
Let’s have a look at ch05/sample03/pom.xml for notable Maven dependencies. 
These dependencies introduce a new set of annotations (@EnableAuthorizationServer 
 annotation and @EnableResourceServer annotation), to turn a Spring Boot application 
to an OAuth 2.0 authorization server.
  org.springframework.boot
  spring-boot-starter-security
  org.springframework.security.oauth
  spring-security-oauth2
The class sample03/src/main/java/com/apress/ch05/sample03/TokenServiceApp.
java carries the @EnableAuthorizationServer annotation, which turns the project into 
an OAuth 2.0 authorization server. We’ve added @EnableResourceServer annotation 
to the same class, as it also has to act as a resource server, to validate access tokens and 
return back the user information. It’s understandable that the terminology here is a little 
confusing, but that’s the easiest way to implement the token validation endpoint (in fact 
the user info endpoint, which also indirectly does the token validation) in Spring Boot. 
When you use self-contained access tokens (JWTs), this token validation endpoint is not 
required. If you are new to JWT, please check Chapter 7 for details.
The registration of clients with the Spring Boot authorization server can be done in 
multiple ways. This example registers clients in the code itself, in sample03/src/ 
main/java/com/apress/ch05/sample03/config/AuthorizationServerConfig.
java file. The AuthorizationServerConfig class extends the 
AuthorizationServerConfigurerAdapter class to override its default behavior. Here  
Chapter 5  edge SeCurity with an api gateway 
111
we set the value of client id to 10101010, client secret to 11110000, available scope 
values to foo and/or bar, authorized grant types to client_credentials, password, and 
refresh_token, and the validity period of an access token to 6000 seconds. Most of the 
terms we use here are from OAuth 2.0 and explained in Chapter 4.
@Override
public void configure(ClientDetailsServiceConfigurer clients) throws 
Exception {
      clients.inMemory().withClient("10101010")
             .secret("11110000").scopes("foo", "bar")
             .authorizedGrantTypes("client_credentials", "password",
                                   "refresh_token")
             .accessTokenValiditySeconds(6000);
}
To support password grant type, the authorization server has to connect to a user 
store. A user store can be a database or an LDAP server, which stores user credentials 
and attributes. Spring Boot supports integration with multiple user stores, but once 
again, the most convenient one, which is just good enough for this example, is an in- 
memory user store. The following code from sample03/src/main/java/com/apress/
ch05/sample03/config/WebSecurityConfiguration.java file adds a user to the system, 
with the role USER.
@Override
public void configure(AuthenticationManagerBuilder auth) throws
Exception {
    auth.inMemoryAuthentication()
          .withUser("peter").password("peter123").roles("USER");
}
Once we define the in-memory user store in Spring Boot, we also need to engage that 
with the OAuth 2.0 authorization flow, as shown in the following, in the code sample03/
src/main/java/com/apress/ch05/sample03/config/AuthorizationServerConfig.
java.
@Autowired
private AuthenticationManager authenticationManager;
@Override
Chapter 5  edge SeCurity with an api gateway 
112
public void configure(AuthorizationServerEndpointsConfigurer endpoints) 
throws Exception {
       endpoints.authenticationManager(authenticationManager);
}
To start the authorization server, use the following command from ch05/sample03/ 
directory to spin up the TokenService microservice, and it starts running on HTTPS port 
8443.