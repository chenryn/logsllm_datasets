    ">
    // 输出后如下:
    // " type=text>
如果 `` 被过滤的话可以换成选择使用事件来闭合属性，并将后面的引号注释掉或闭合：
    " autofocus onfocus=alert(1)//
    " autofocus onfocus=alert(1) "
    // 输出后如下:
    // 
同样还有很多其他的payload：
    " onmouseover=prompt(0) x="
    " onfocusin=alert(1) autofocus x="
    " onfocusout=alert(1) autofocus x="
    " onblur=alert(1) autofocus a="
还有一些特殊的场景，如：
这里只能把input标签闭合，然后直接执行脚本，否则会因为type为hidden导致无法执行脚本。
### 输出在HTML标签之间
例如输出的位置如下：
    [输出]
直接提交 `` 即可触发XSS，但是当标签是不能执行脚本的标签时，如下面这几个：
  * ``
  * ``
  * ``
  * ``
那么就得先把那个标签闭合（后文会讲到原理），然后在注入XSS语句，例如：
### 输出在script标签之间
例如：
可控位置在input，可以闭合script标签插入代码，但是同样我们仅仅闭合双引号就可以执行js代码了：
    ";alert(1)//
    // 输出后如下:
    // 
# XSS 字符编码绕过
在XSS中，还有一个绕过关键字过滤的方法，那就是字符编码绕过。这里给出一个编码网站：
编码属于计算机系统的基础知识，其内容写起来估计也可以出本书了，不过或多或少我们都有所了解，总的来说，编码就是将字符变为二进制数，而解码就是将二进制数还原为字符。从浏览器请求url到在页面上显示出来也经历了一些编码和解码过程，下面大概介绍一下流程。
## 请求网页解码流程
  * **HTML 编码/解码**
当浏览器接收到服务端发送来的二进制数据后，首先会对其进行HTML解码，呈现出来的就是我们看到的源代码。具体的解码方式依具体情况而定，所以我们需要在页面中指定编码，防止浏览器按照错误的方式解码，造成乱码。
但是在HTML中有些字符是和关键词冲突的，比如
``、`&`，解码之后，浏览器会误认为它们是HTML标签，如果希望正确地显示预留字符，就需要在HTML中使用对应的HTML字符实体。
字符实体是一个转义序列，它定义了一般无法在文本内容中输入的单个字符或符号。一个字符实体以一个&符号开头，后面跟着一个预定义的实体的名称，或用&#开头+实体编号+分号来表示。
常见的HTML字符实体有：
显示结果 | 描述 | 实体名称 | 实体编号  
---|---|---|---  
| 空格 | `&nbsp;` | `&#160;`  
 | 大于号 | `&gt;` | `&#62;`  
& | 和号 | `&amp;` | `&#38;`  
" | 引号 | `&quot;` | `&#34;`  
' | 撇号 | `&apos;`(IE不支持) | `&#39;`  
但并不是所有的字符都有实体名称，但是它们都有自己的实体编号。
一个HTML解析器作为一个状态机，它从输入流中获取字符并按照转换规则转换到另一种状态。在解析过程中，任何时候它只要遇到一个 ``、``
这样的标签时，解析器会自动切换到JavaScript解析模式，而 `src`、 `href` 后边加入的 javascript 伪URL，也会进入
JavaScript 的解析模式。
比如 `test`，JavaScript 出发了 JavaScript
解释器，JavaScript 会先对内容进行解析，里边有一个转义字符`\u0031`，前导的 u 表示他是一个unicode
字符，根据后边的数字，解析为“1”，于是在完成 JavaScript 的解析之后变成了 `test`。
**下面用一个普通的XSS代码来说明一下浏览器对其解析的过程。**
  * `test`
首先HTML解析器开始工作，并对href中的字符做HTML解码，接下来URL解析器对href值进行解码，正常情况下URL值为一个正常的URL链接，如：`https://www.baidu.com`，那么URL解析器工作完成后是不需要其他解码的，但是该环境中URL资源类型为Javascript，因此该环境中最后一步Javascript解析器还会进行解码操作，最后解析的脚本将被执行。
整个解析顺序为3个环节：HTML解码 —>URL解码 —>JS解码
我们可以对XSS攻击向量做这三种编码都可以成功弹框。
## HTML 实体编码
我们可以将DOM节点中的内容转化为HTML实体，因为解析HTML之后建立起节点，然后会对DOM节点里面的HTML实体进行解析。HTML
编码主要分为10进制和16进制，格式为以 `&#` 开头以分号 `;` 结尾（也可以不带分号）。
  * `test`
    // 十进制
    test
    // 十六进制
    test
    // 也可以不带分号
    test
  * ``
    // 十进制
    // 十六进制
    // 也可以不带分号
但是要注意，对于HTML字符实体，并不是说任何地方都可以使用实体编码，只有处于 “数据状态中的字符引用”、“属性值状态中的字符引用” 和
“RCDATA状态中的字符引用” 这三种状态中的HTML字符实体将会从 `&#…` 形式解码，转化成对应的解码字符并被放入数据缓冲区中。
**（1）数据状态中的字符引用：** 数据状态就是解析一个标签内里面的内容，如 `...` 中的内容，当浏览器解析完 ``
标签之后如果发现标签内还含有实体字符的话，就会有一个实体编码解析了，如：
    &#60;img src=x onerror=alert("xss")&#62;
如下图，此时在页面上显示的是经过转义的内容：
这看上去是一个标准的标签语言，但并不会触发xss，因为当前HTML解析器处于“数据状态”，不会转换到“标签开始状态”，所以就不会建立新的标签。因此，我们能够利用字符实体编码这个行为来转义用户输入的数据从而确保用户输入的数据只能被解析成“数据”而不是XSS攻击向量。
**（2）属性值状态中的字符引用：**
属性值状态中的字符引用就好理解了，就是src，herf这样的属性值中的HTML实体，他也是会先进行HTML解码的，比如下面的语句，会先对里面HTML解码，然后再继续往下执行：
    test
**（3）RCDATA状态中的字符引用：** 然后再来看一下什么是RCDATA转态，这里需要我们先了解一下HTML中有五类元素：
  1. 空元素(Void elements)，如 ``、``、`` 等等。空元素不能容纳任何内容，因为它们没有闭合标签，没有内容能够放在开始标签和闭合标签中间。
  2. 原始文本元素(Raw text elements)，有 `` 和 ``。原始文本元素可以容纳文本。
  3. RCDATA元素(RCDATA elements)，有 `` 和 ``。RCDATA元素可以容纳文本和字符引用。
  4. 外部元素(Foreign elements)，例如MathML命名空间或者SVG命名空间的元素。外部元素可以容纳文本、字符引用、CDATA段、其他元素和注释。
  5. 基本元素(Normal elements)，即除了以上4种元素以外的元素。基本元素可以容纳文本、字符引用、其他元素和注释。
注意到RCDATA元素中有 `` 和 ``
两个属性并且有字符引用，也就是当实体字符出现在这两个标签里面的时候，实体字符会被识别并进行HTML编码解析。这里要再提醒一次，在解析这些字符引用的过程中不会进入“标签开始状态”，所以就不会建立新的标签，所以下面这个语句触发不了XSS：
    &#60;script&#62;alert("xss")&#60;/script&#62;
但是如果直接放进去标签的内容呢，不带转义字符呢，如下：
同样也是不会触发XSS的：
这涉及到了RCDATA的一个特殊的情况。即在浏览器解析RCDATA元素的过程中，解析器会进入“RCDATA状态”。在这个状态中，如果遇到“` 或者 ``，因此，在 `` 和 ``
的内容中不会创建标签，就不会有脚本能够执行了。
另外还有一点要注意：我们从上面HTML的五类元素中还发现有一个原始文本元素 ``
在这个标签内容纳的是文本，所以浏览器在解析到这个标签后，里面内容中的HTML编码并不会被认为是HTML实体引用，所以并不会被解码为相应的字符。浏览器看不懂中间这堆编码是和啥东西，所以也不会被执行，如下：