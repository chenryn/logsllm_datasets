## Systemtap Userspace probing - 4        
### 作者                                                                                                   
digoal                                                                                                   
### 日期                                                                                                   
2013-09-30                                                                                                
### 标签                                                                                                   
PostgreSQL , Linux , systemtap , stap , dtrace , probe                                           
----                                                                                                   
## 背景                                            
接上一篇BLOG  
http://blog.163.com/digoal@126/blog/static/163877040201383042846295/  
本文讲一下userspace 探针的最后一点内容, 静态userspace探针.  
```  
Static userspace probing  
You can probe symbolic static instrumentation compiled into programs and shared libraries with the following syntax:  
process("PATH").mark("LABEL")  
The .mark variant is called from a static probe defined in the application by STAP_PROBE1(handle,LABEL,arg1). STAP_PROBE1 is defined in the sdt.h file. The parameters are:  
Parameter	Definition	   
handle	the application handle	   
LABEL	corresponds to the .mark argument	   
arg1	the argument	   
Use STAP_PROBE1 for probes with one argument. Use STAP_PROBE2 for probes with 2 arguments, and so on. The arguments of the probe are available in the context variables $arg1, $arg2, and so on.  
As an alternative to the STAP_PROBE macros, you can use the dtrace script to create custom macros. The sdt.h file also provides dtrace compatible markers through DTRACE_PROBE and an associated python dtrace script. You can use these in builds based on dtrace that need dtrace -h or -G functionality.  
```  
使用这些宏添加静态用户空间探针, 支持无参数, 或者1-12个参数的宏. 语法如下 :   
```  
STAP_PROBE[1-12](handle,LABEL[,arg1-12])  
DTRACE_PROBE[1-12](handle,LABEL[,arg1-12])  
```  
静态userspace探针的用法  
```  
probe process("PATH").mark("LABEL")  
```  
例如在PostgreSQL定义的某静态探针, 使用的是DTRACE模式定义, 在sdt.h中有DTRACE的兼容模式, 所以也可以用.  
```  
src/backend/utils/probes.h  
/* Generated by the Systemtap dtrace wrapper */  
#define _SDT_HAS_SEMAPHORES 1  
#define STAP_HAS_SEMAPHORES 1 /* deprecated */  
#include   
/* TRACE_POSTGRESQL_TRANSACTION_START ( unsigned int) */  
#if defined STAP_SDT_V1  
#define TRACE_POSTGRESQL_TRANSACTION_START_ENABLED() __builtin_expect (transaction__start_semaphore, 0)  
#define postgresql_transaction__start_semaphore transaction__start_semaphore  
#else  
#define TRACE_POSTGRESQL_TRANSACTION_START_ENABLED() __builtin_expect (postgresql_transaction__start_semaphore, 0)  
#endif  
__extension__ extern unsigned short postgresql_transaction__start_semaphore __attribute__ ((unused)) __attribute__ ((section (".prob  
es")));  
#define TRACE_POSTGRESQL_TRANSACTION_START(arg1) \  
DTRACE_PROBE1(postgresql,transaction__start,arg1)  
```  
PG中使用的是dtrace宏定义,   
```  
DTRACE_PROBE1(postgresql,transaction__start,arg1)  
```  
DTRACE_PROBE1在sdt.h中可以找到.  
```  
#define DTRACE_PROBE1(provider,probe,parm1)     \  
  STAP_PROBE1(provider,probe,parm1)  
```  
如果要使用以上PostgreSQL中定义的这个静态探针, 如下 :   
```  
probe process("/opt/pgsql/bin/postgres").mark("transaction__start")  
```  
举例如下 :   
首先, 前面举例用到的在PostgreSQL中定义的静态用户空间探针transaction__start对应的宏TRACE_POSTGRESQL_TRANSACTION_START在代码中被植入的位置如下,   
```  
src/backend/access/transam/xact.c  
/*  
 *      StartTransaction  
 */  
static void  
StartTransaction(void)  
{  
        TransactionState s;  
        VirtualTransactionId vxid;  
... 略  
        /*  
         * Advertise it in the proc array.      We assume assignment of  
         * LocalTransactionID is atomic, and the backendId should be set already.  
         */  
        Assert(MyProc->backendId == vxid.backendId);  
        MyProc->lxid = vxid.localTransactionId;  
        TRACE_POSTGRESQL_TRANSACTION_START(vxid.localTransactionId);  
```  
所以对应的参数arg1是vxid.localTransactionId  
下面我们来做一个测试 :   
user_string这没有, 因为$arg1不是一个字符串, 可以不用管它.  
```  
[root@db-172-16-3-39 ~]# stap -e 'global cnt; probe process("/home/pg94/pgsql9.4devel/bin/postgres").mark("transaction__start") { cnt  
4349, process("/home/pg94/pgsql9.4devel/bin/postgres").statement(0x4a4caa), $arg1=0x11,   
4349, process("/home/pg94/pgsql9.4devel/bin/postgres").statement(0x4a4caa), $arg1=0x12,   
```  
观察久一点的话, 可能还有其他进程的输出.  
```  
[root@db-172-16-3-39 ~]# stap -e 'global cnt; probe process("/home/pg94/pgsql9.4devel/bin/postgres").mark("transaction__start") { cnt  
4349, process("/home/pg94/pgsql9.4devel/bin/postgres").statement(0x4a4caa), $arg1=0x11,   
4349, process("/home/pg94/pgsql9.4devel/bin/postgres").statement(0x4a4caa), $arg1=0x12,   
4212, process("/home/pg94/pgsql9.4devel/bin/postgres").statement(0x4a4caa), $arg1=0xc,   
4991, process("/home/pg94/pgsql9.4devel/bin/postgres").statement(0x4a4caa), $arg1=0x13,   
4991, process("/home/pg94/pgsql9.4devel/bin/postgres").statement(0x4a4caa), $arg1=0x14,   
4993, process("/home/pg94/pgsql9.4devel/bin/postgres").statement(0x4a4caa), $arg1=0x15,   
4993, process("/home/pg94/pgsql9.4devel/bin/postgres").statement(0x4a4caa), $arg1=0x16,   
4993, process("/home/pg94/pgsql9.4devel/bin/postgres").statement(0x4a4caa), $arg1=0x17,   
4993, process("/home/pg94/pgsql9.4devel/bin/postgres").statement(0x4a4caa), $arg1=0x18,   
4993, process("/home/pg94/pgsql9.4devel/bin/postgres").statement(0x4a4caa), $arg1=0x19,   
4212, process("/home/pg94/pgsql9.4devel/bin/postgres").statement(0x4a4caa), $arg1=0xd,   
4998, process("/home/pg94/pgsql9.4devel/bin/postgres").statement(0x4a4caa), $arg1=0xf,   
4998, process("/home/pg94/pgsql9.4devel/bin/postgres").statement(0x4a4caa), $arg1=0x10,   
4993, process("/home/pg94/pgsql9.4devel/bin/postgres").statement(0x4a4caa), $arg1=0x1a,   
4212, process("/home/pg94/pgsql9.4devel/bin/postgres").statement(0x4a4caa), $arg1=0xe,   
5012, process("/home/pg94/pgsql9.4devel/bin/postgres").statement(0x4a4caa), $arg1=0x11,   
5012, process("/home/pg94/pgsql9.4devel/bin/postgres").statement(0x4a4caa), $arg1=0x12,   
```  
## 参考  
1\. http://blog.163.com/digoal@126/blog/static/163877040201382941342901/  
2\. http://blog.163.com/digoal@126/blog/static/16387704020138301545039/  
3\. http://blog.163.com/digoal@126/blog/static/163877040201383042846295/  
4\. src/backend/utils/probes.h  
5\. /usr/include/sys/sdt.h  
```  
/*  - Systemtap static probe definition macros.  
   Copyright (C) 2010-2011 Red Hat Inc.  
   This file is part of systemtap, and is free software in the public domain.  
*/  
#ifndef _SYS_SDT_H  
#define _SYS_SDT_H    1  
#ifdef __ASSEMBLER__  
# define _SDT_PROBE(provider, name, n, arglist) \  
  _SDT_ASM_BODY(provider, name, _SDT_ASM_STRING_1, (_SDT_DEPAREN_##n arglist)) \  
  _SDT_ASM_BASE  
# define _SDT_ASM_1(x)                  x;  
# define _SDT_ASM_2(a, b)               a,b;  
# define _SDT_ASM_3(a, b, c)            a,b,c;  
# define _SDT_ASM_5(a, b, c, d, e)      a,b,c,d,e;  
# define _SDT_ASM_STRING_1(x)           .asciz #x;  
# define _SDT_DEPAREN_0()                               /* empty */  
# define _SDT_DEPAREN_1(a)                              a  
# define _SDT_DEPAREN_2(a,b)                            a b  
# define _SDT_DEPAREN_3(a,b,c)                          a b c  
# define _SDT_DEPAREN_4(a,b,c,d)                        a b c d  
# define _SDT_DEPAREN_5(a,b,c,d,e)                      a b c d e  
# define _SDT_DEPAREN_6(a,b,c,d,e,f)                    a b c d e f  
# define _SDT_DEPAREN_7(a,b,c,d,e,f,g)                  a b c d e f g  
# define _SDT_DEPAREN_8(a,b,c,d,e,f,g,h)                a b c d e f g h  
# define _SDT_DEPAREN_9(a,b,c,d,e,f,g,h,i)              a b c d e f g h i  
# define _SDT_DEPAREN_10(a,b,c,d,e,f,g,h,i,j)           a b c d e f g h i j  
# define _SDT_DEPAREN_11(a,b,c,d,e,f,g,h,i,j,k)         a b c d e f g h i j k  
# define _SDT_DEPAREN_12(a,b,c,d,e,f,g,h,i,j,k,l)       a b c d e f g h i j k l  
#else  
# include   
# define _SDT_PROBE(provider, name, n, arglist) \  
  do {                                                                      \  
    __asm__ __volatile__ (_SDT_ASM_BODY(provider, name, _SDT_ASM_ARGS, (n)) \  
                          :: _SDT_ASM_OPERANDS_##n arglist);                \  
    __asm__ __volatile__ (_SDT_ASM_BASE);                                   \  
  } while (0)  
# define _SDT_S(x)                      #x  
# define _SDT_ASM_1(x)                  _SDT_S(x) "\n"  