    0:027> p
    GDI32!MRSETDIBITSTODEVICE::bPlay+0xaa:
    00007ff8`2a3787da e8815cf8ff      call    GDI32!ModifyWorldTransform (00007ff8`2a2fe460)
    0:027> r rdx
    rdx=0000003492ac5540
    0:027> dt XFORM 0000003492ac5540//线形变换参数
    vaultcli!XFORM
       +0x000 eM11             : 0.9870000482 
       +0x004 eM12             : 0 
       +0x008 eM21             : 0 
       +0x00c eM22             : 0.9893333316 
       +0x010 eDx              : 0 
       +0x014 eDy              : 0 
    ……
    0:027> p
    GDI32!MRSETDIBITSTODEVICE::bPlay+0xb3://获取cbBmiSrc成员值，负责BITMAP的大小
    00007ff8`2a3787e3 448b4b34        mov     r9d,dword ptr [rbx+34h] ds:0000002c`8f00bec0=00000028
    0:027> p
    GDI32!MRSETDIBITSTODEVICE::bPlay+0xb7:
    00007ff8`2a3787e7 498bd6          mov     rdx,r14
    0:027> p
    GDI32!MRSETDIBITSTODEVICE::bPlay+0xba://获得offBmiSrc成员变量值，负责BITMAP的偏移
    00007ff8`2a3787ea 448b4330        mov     r8d,dword ptr [rbx+30h] ds:0000002c`8f00bebc=0000004c
    0:027> p
    GDI32!MRSETDIBITSTODEVICE::bPlay+0xbe:
    00007ff8`2a3787ee 488bcb          mov     rcx,rbx
    0:027> p
    GDI32!MRSETDIBITSTODEVICE::bPlay+0xc1://主要就是Check tagBITMAPINFO
    00007ff8`2a3787f1 e852d6faff      call    GDI32!MR::bValidOffExt (00007ff8`2a325e48)
    0:027> r rdx
    rdx=0000002c8f00be8c
    0:027> dt tagBITMAPINFO 2c8f00be8c+4c
    vaultcli!tagBITMAPINFO
       +0x000 bmiHeader        : tagBITMAPINFOHEADER
       +0x028 bmiColors        : [1] tagRGBQUAD
    0:027> dt tagBITMAPINFOHEADER 2c8f00be8c+4c
    vaultcli!tagBITMAPINFOHEADER
       +0x000 biSize           : 0x28
       +0x004 biWidth          : 0n16
       +0x008 biHeight         : 0n16
       +0x00c biPlanes         : 1
       +0x00e biBitCount       : 0x18
       +0x010 biCompression    : 0
       +0x014 biSizeImage      : 4
       +0x018 biXPelsPerMeter  : 0n0
       +0x01c biYPelsPerMeter  : 0n0
       +0x020 biClrUsed        : 0
       +0x024 biClrImportant   : 0
如注释内容，这三个函数会分别对坐标，线性变换的参数，以及EMRSETDIBITSTODEVICE结构体的BITMAPINFO成员变量进行获取赋值和检查。这些赋值和检查如果成功，都会返回非0值，这样才能继续下面的逻辑，接下来，bPlay函数会为BITMAPINFO开辟地址空间。
    0:027> p
    GDI32!MRSETDIBITSTODEVICE::bPlay+0xce:
    00007ff8`2a3787fe b8f8040000      mov     eax,4F8h
    0:027> p
    GDI32!MRSETDIBITSTODEVICE::bPlay+0xd3://获得LocalAlloc的第一个参数nType
    00007ff8`2a378803 b940000000      mov     ecx,40h
    0:027> p
    GDI32!MRSETDIBITSTODEVICE::bPlay+0xd8://判断cbBmiSrc和4f8的大小
    00007ff8`2a378808 394334          cmp     dword ptr [rbx+34h],eax ds:0000002c`8f00bec0=00000028
    0:027> p
    GDI32!MRSETDIBITSTODEVICE::bPlay+0xdb://如果大于则将cbBmiSrc的大小作为开辟的空间大小，否则就开辟4f8
    00007ff8`2a37880b 0f474334        cmova   eax,dword ptr [rbx+34h] ds:0000002c`8f00bec0=00000028
    0:027> p
    GDI32!MRSETDIBITSTODEVICE::bPlay+0xdf://获得要开辟空间的大小
    00007ff8`2a37880f 8bd0            mov     edx,eax
    0:027> p
    GDI32!MRSETDIBITSTODEVICE::bPlay+0xe1://开辟4f8的bitmapinfo空间
    00007ff8`2a378811 ff15d9190300    call    qword ptr [GDI32!_imp_LocalAlloc (00007ff8`2a3aa1f0)] ds:00007ff8`2a3aa1f0={KERNELBASE!LocalAlloc (00007ff8`2810fe40)}
    0:027> r edx
    edx=4f8
    0:027> p
    GDI32!MRSETDIBITSTODEVICE::bPlay+0xe7:
    00007ff8`2a378817 488bf0          mov     rsi,rax
    0:027> r rax
    rax=0000003492a637b0//开辟出4f8的空间，并且获取堆指针
    0:027> dd 3492a637b0 l5
    00000034`92a637b0  00000000 00000000 00000000 00000000
    00000034`92a637c0  00000000
在函数中，会对开辟的空间进行一个判断，如果BITMAPINFO的size大于4f8，则开辟BITMAPINFO
size大小空间，如果小于的话，则直接开辟4f8空间，开辟后，会将当前EMRSETDIBITSTODEVICE结构体的BITMAPINFO拷贝进去，在EMRSETDIBITSTODEVICE结构体中offBmiSrc是BITMAPINFO距离EMRSETDIBITSTODEVICE结构体的偏移，而cbBmiSrc则是BITMAPINFO的大小。
根据我们当前的情况，偏移是0x4c，大小是0x28，随后会执行memcpy拷贝BITMAPINFO。
    0:027> p
    GDI32!MRSETDIBITSTODEVICE::bPlay+0x100://拷贝bitmapinfo
    00007ff8`2a378830 e8d34cfbff      call    GDI32!memcpy (00007ff8`2a32d508)
    0:027> r r8
    r8=0000000000000028
    0:027> r rdx
    rdx=0000002c8f00bed8
    0:027> dd 2c8f00bed8
    0000002c`8f00bed8  00000028 00000010 00000010 00180001
    0000002c`8f00bee8  00000000 00000004 00000000 00000000
    0000002c`8f00bef8  00000000 00000000 00ed1c24 0000000e
可以看到，拷贝的内容正是我们EMF文件中对应BITMAPINFO区域的内容，这里要注意，其实这里拷贝的只是BITMAP的信息，而并不是我们真正图像的内容，因此这里还不是造成内存泄露的原因。
接下来会进行一系列的变量判断，这些变量判断我将在下面的伪代码的注释中给大家讲解，但是这一系列的判断并没有判断引发这个漏洞最关键的部分，随后我们会看到一处关键函数调用。
          LOBYTE(v6) = StretchDIBits(
                         v3,
                         pt.x,
                         pt.y,
                         *((_DWORD *)v4 + 10),//
                         *((_DWORD *)v4 + 11),
                         *((_DWORD *)v4 + 8),
                         *((_DWORD *)v4 + 9) - *((_DWORD *)v4 + 17),
                         *((_DWORD *)v4 + 10),//宽和高，0x10
                         *((_DWORD *)v4 + 11),
                         v15,//this is important pointer，指向要拷贝的bitmap指针
                         v11,
                         *((_DWORD *)v4 + 16),
                         0xCC0020u) != 0;
这个函数调用，会拷贝当前的图像像素到目标的设备（画布）中，而这个过程拷贝的内容就是v15，这个v15变量是指向要拷贝内容的指针，而拷贝取决于之前我们定义的cxSrc和cySrc，拷贝的大小是cxSrc*cySrc*4，而当前v15的值是什么呢，这取决于EMRSETDIBITSTODEVICE结构体的offBitsSrc，这里就是当前结构体偏移+0x74的位置。
    0:026> p
    gdi32full!MRSETDIBITSTODEVICE::bPlay+0x1a4: