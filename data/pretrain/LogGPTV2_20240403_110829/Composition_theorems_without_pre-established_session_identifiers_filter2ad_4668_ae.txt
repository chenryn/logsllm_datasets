{F(MS, c3(cid:107)handshake)}IKCS,EKCS
S → C:
original
modiﬁed
c1, NC
S , kS , c2, NS ,
C, kC,{|sid, PMS|}kS , sigkC (sid, handshake),
{F(MS, c4(cid:107)handshake)}IKSC,EKSC
{F(MS, c3(cid:107)handshake)}IKCS,EKCS
Figure 2: The TLS Handshake Protocol (Key Exchange Method: RSA) and its modiﬁed version.
For SSL/TLS and SSH, we now show that they satisfy implicit
disjointness; for details and the proofs for other protocols see [22].
Implicit Disjointness of SSL/TLS. The cryptographic core of
the TLS Handshake Protocol with RSA encryption is depicted in
Figure 2 on the left (we consider the variant where the client au-
thenticates itself using digital signatures): NC and NS are nonces
generated by C and S , respectively; the premaster secret PMS is
chosen randomly by C and is encrypted under the public key of S
({|PMS|}kS ); c0, . . . , c4 are distinct constants; F is a pseudo-random
function; the master secret MS is derived from PMS as follows:
MS = F(PMS, c0(cid:107)NC(cid:107)NS ); {m}k1,k2 denotes MAC-then-encrypt, i.e.,
{m}k1,k2
= {m, mack1(m)}k2; the symmetric encryption and MAC
keys EKCS, EKSC, IKCS, IKSC are derived from MS using F and
the nonces NC and NS as a seed; handshake stands for the concate-
nation of all previous messages, that is, handshake = c1(cid:107)NC(cid:107)S(cid:107)kS(cid:107)
c2(cid:107)NS(cid:107)C(cid:107)kC(cid:107){|PMS|}kS .
In Step 3 of the protocol, the server per-
forms the following test (as soon as a check fails, the whole mes-
sage is dropped): It ﬁrst decrypts the ﬁrst ciphertext (using Fcrypto).
If successful, it checks that the signature is over the expected mes-
sage. If so, it veriﬁes the signature sigkC (handshake) (using Fcrypto).
If successful, S derives the keys MS, EKCS, etc. and decrypts the
second ciphertext (using Fcrypto). If this succeeds, the MAC within
the plaintext is veriﬁed (using Fcrypto). If successful, the test accepts
and S continues the protocol.
Modeling this protocol as a multi-session real protocol PTLS =
!MC | !MS that uses Fcrypto for all cryptographic operations (i.e.,
public-key and symmetric encryption, key derivation, digital sig-
natures, and MAC) is straightforward. The protocol PTLS is meant
to realize Fkey-use, i.e., after the keys are established, the parties
can send encryption and decryption requests to MC and MS which
are MACed and encrypted under the corresponding keys. Corrup-
tion is deﬁned such that the adversary can corrupt the public/private
keys of parties (via Fcrypto) and can corrupt instances of MC and MS
when they are created. In particular, the adversary can gain com-
plete control over a party by corrupting her public/private keys and
all her instances of MC and MS .
We provide a proof sketch that PTLS satisﬁes implicit disjointness
(see [22] for details). The proof does not need to exploit security
of symmetric encryption. Moreover, the proof merely requires syn-
tactic arguments (rather than probabilistic reasoning or reduction
arguments) since we can use Fcrypto for the cryptographic primi-
tives.
The partnering function τTLS for PTLS we use is the obvious one:
Let ρ be a run of E|PTLS |Fcrypto for some environment E and α be
the projection of ρ to an instance of Mr for some user (p, lsid, r)
(where r ∈ {C, S}). If (p, lsid, r) is corrupted, then τTLS(α) := ⊥.
Otherwise, if r = C and α contains at least the ﬁrst two messages
of the protocol, then τTLS(α) := (NC, NS ), where NS is the server’s
nonce (p, lsid, r) received and NC is the nonce (p, lsid, r) generated;
analogously for the case r = S . It is easy to see that τTLS is valid
for PTLS because ideal nonces (i.e., nonces generated using Fcrypto)
do not collide.
Theorem 5. PTLS satisﬁes implicit disjointness w.r.t. τTLS.
Proof sketch. All symmetric keys (PMS, MS, EKSC, etc.) are,
by deﬁnition, not explicitly shared: PMS is not a pre-shared key but
a freshly generated symmetric key; MS is derived from PMS and all
other keys are derived from MS. Hence, we only have to show (b) of
Deﬁnition 2 for public-key encryption and digital signatures. More
precisely, the only relevant cases are when the server performs a
decryption request with kS (to obtain PMS) or when it performs a
veriﬁcation request to verify the signature of the client.
We now consider the former case (decryption request with kS );
the latter follows a similar (even simpler) argumentation. In this
proof sketch, we only consider the case where the server which
makes the decryption request is uncorrupted and where the key kC
he received is uncorrupted (in Fcrypto) as well.
(We refer to our
technical report [22] for the case of corruption. The argument there
requires a more precise description of our protocol and corruption
model than what we can present in this extended abstract.)
So, let us assume that an uncorrupted instance of the server, say
ˆMS , performed an accepted and ideal decryption request. Let NC
be the nonce ˆMS received, let NS be the nonce generated by ˆMS ,
let kS be its public key, let kC be the public key received, and ct
be the ciphertext received (containing PMS) and on which ˆMS per-
formed the decryption request under consideration. Since the de-
cryption request is accepted, by the deﬁnition of the test the server
performs, we know that the handshake message has the required
format and the signature veriﬁed. From this we can conclude that
an uncorrupted instance made a signing request to Fcrypto with (a
pointer to) the private key of kC and the message handshake; a
corrupted instance would not have had access to an uncorrupted
signing key. This instance must be in role C (so say the instance is
ˆMC), since uncorrupted server instances do not produce signatures.
Since handshake contains NC and NS , we know that these are the
nonces generated and received, respectively, by ˆMC. Consequently,
ˆMC and ˆMS are partners according to τTLS. Since the ciphertext ct
and the public key kS are contained in handshake, it follows that
ˆMC must have encrypted PMS under kS and obtained the ciphertext
ct from Fcrypto. Hence, we have shown, as desired, that the partner
ˆMC of ˆMS has issued the corresponding encryption request.
Implicit Disjointness of SSH. The cryptographic core of the key
exchange protocol of SSH—for which we show implicit disjoint-
ness—is depicted in Figure 3, with K = gxy and sid = H(NC, NS , kS ,
gx, gy, K), where H is a hash function. The symmetric encryption
and MAC keys EKCS, EKSC, IKCS, IKSC are derived from K us-
ing H and sid as a seed. (The details are not relevant for proving
implicit disjointness.) By {m}k1,k2 we denote encrypt-and-MAC,
i.e., {m}k1,k2
= {m}k2 , mack1(m). The formal model of SSH as a
multi-session real protocol PSSH = !MC | !MS is similar to the one
for TLS. However, PSSH only uses Fcrypto for digital signatures; all
other cryptographic operations (i.e., encryption, MAC, hashing) are
carried out by MC and MS itself because Fcrypto does not support
Diﬃe-Hellman key exchange yet, and hence, K (and all derived
keys) cannot be a key in Fcrypto. Still, in the proof that PSSH satisﬁes
implicit disjointness, we only need to do a reduction argument to
the collision resistance of the hash function, since PSSH uses Fcrypto
491. C → S :
S → C:
2.
3. C → S :
S → C:
4.
5. C → S :
S → C:
6.
c1, NC
c2, NS
gx
kS , gy, sigkS (sid)
{C, kC, sigkC (sid, C, kC)}IKCS,EKCS
{“success”}IKSC,EKSC
Figure 3: The SSH Key Exchange Protocol.
for digital signatures and security of the encryption scheme, the
MAC scheme, or the Diﬃe-Hellman key exchange is not needed.
The partnering function τSSH for PSSH is the obvious one: It is de-
ﬁned similarly to TLS except that the SID is sid = H(NC, NS , kS , gx,
gy, K) instead of (NC, NS ). To show that it is valid, we need that the
hash function is collision resistant; alternatively, one could deﬁne
sid = (NC, NS ), in which case collision resistance is not needed to
show that τSSH is valid, but then collision resistance would be nec-
essary to show implicit disjointness. With τSSH, implicit disjoint-
ness of PSSH follows very easily since sid is part of every signature.
Theorem 6. PSSH satisﬁes implicit disjointness w.r.t. τSSH.
6. REFERENCES
[1] M. R. Albrecht, K. G. Paterson, and G. J. Watson. Plaintext
Recovery Attacks against SSH. In S&P 2009, pages 16–26.
IEEE Computer Society, 2009.
[2] B. Barak, Y. Lindell, and T. Rabin. Protocol Initialization for
the Framework of Universal Composability. Technical
Report 2004/006, Cryptology ePrint Archive, 2004.
http://eprint.iacr.org.
[3] M. Bellare, D. Pointcheval, and P. Rogaway. Authenticated
Key Exchange Secure against Dictionary Attacks. In
B. Preneel, editor, EUROCRYPT 2000, volume 1807 of
LNCS, pages 139–155. Springer, 2000.
[4] M. Bellare and P. Rogaway. Entity Authentication and Key
Distribution. In D. Stinson, editor, CRYPTO’93, volume 773
of LNCS, pages 232–249. Springer, 1993.
[5] M. Bellare and P. Rogaway. Provably Secure Session Key
Distribution: The Three Party Case. In STOC’95, pages
57–66. ACM, 1995.
[6] B. Blanchet. Computationally Sound Mechanized Proofs of
Correspondence Assertions. In CSF 2007, pages 97–111.
IEEE Computer Society, 2007.
[7] R. Canetti. Universally Composable Security: A New
Paradigm for Cryptographic Protocols. In FOCS 2001, pages
136–145. IEEE Computer Society, 2001.
[8] R. Canetti. Universally Composable Security: A New
Paradigm for Cryptographic Protocols. Technical Report
2000/067, Cryptology ePrint Archive, December 2005.
http://eprint.iacr.org.
[9] R. Canetti and H. Krawczyk. Analysis of Key-Exchange
Protocols and Their Use for Building Secure Channels. In
B. Pﬁtzmann, editor, EUROCRYPT 2001, volume 2045 of
LNCS, pages 453–474. Springer, 2001.
[10] R. Canetti and H. Krawczyk. Security Analysis of IKE’s
Signature-Based Key-Exchange Protocol. In M. Yung, editor,
CRYPTO 2002, volume 2442 of LNCS, pages 143–161.
Springer, 2002.
[11] R. Canetti and T. Rabin. Universal Composition with Joint
State. In CRYPTO 2003, volume 2729 of LNCS, pages
265–281. Springer, 2003.
[12] I. Cervesato, A. D. Jaggard, A. Scedrov, J.-K. Tsay, and
C. Walstad. Breaking and Fixing Public-key Kerberos. Inf.
Comput., 206(2-4):402–424, 2008.
[13] K.-K. R. Choo and Y. Hitchcock. Security Requirements for
Key Establishment Proof Models: Revisiting
Bellare-Rogaway and Jeong-Katz-Lee Protocols. In C. Boyd
and J. M. G. Nieto, editors, ACISP 2005, volume 3574 of
LNCS, pages 429–442. Springer, 2005.
[14] A. Datta, A. Derek, J. C. Mitchell, and B. Warinschi.
Computationally Sound Compositional Logic for Key
Exchange Protocols. In CSFW 2006, pages 321–334. IEEE
Computer Society, 2006.
[15] J. P. Degabriele and K. G. Paterson. On the (In)Security of
IPsec in MAC-then-Encrypt Conﬁgurations. In CCS 2010.
ACM, 2010.
[16] S. Gajek, M. Manulis, O. Pereira, A. Sadeghi, and
J. Schwenk. Universally Composable Security Analysis of
TLS. In J. Baek, F. Bao, K. Chen, and X. Lai, editors,
ProvSec 2008, volume 5324 of LNCS, pages 313–327.
Springer, 2008.
[17] K. Kobara, S. Shin, and M. Streﬂer. Partnership in key
exchange protocols. In W. Li, W. Susilo, U. K. Tupakula,
R. Safavi-Naini, and V. Varadharajan, editors, ASIACCS
2009, pages 161–170. ACM, 2009.
[18] H. Krawczyk. SIGMA: The ’SIGn-and-MAc’ Approach to
Authenticated Diﬃe-Hellman and Its Use in the
IKE-Protocols. In D. Boneh, editor, CRYPTO 2003, volume
2729 of LNCS, pages 400–425. Springer, 2003.
[19] R. Küsters. Simulation-Based Security with Inexhaustible
Interactive Turing Machines. In CSFW 2006, pages 309–320.
IEEE Computer Society, 2006.
[20] R. Küsters and M. Tuengerthal. Joint State Theorems for
Public-Key Encryption and Digitial Signature Functionalities
with Local Computation. In CSF 2008, pages 270–284.
IEEE Computer Society, 2008.
[21] R. Küsters and M. Tuengerthal. Universally Composable
Symmetric Encryption. In CSF 2009, pages 293–307. IEEE
Computer Society, 2009.
[22] R. Küsters and M. Tuengerthal. Composition Theorems
Without Pre-Established Session Identiﬁers. Technical
Report 2011/406, Cryptology ePrint Archive, 2011.
http://eprint.iacr.org.
[23] R. Küsters and M. Tuengerthal. Ideal Key Derivation and
Encryption in Simulation-based Security. In A. Kiayias,
editor, CT-RSA 2011, volume 6558 of LNCS, pages 161–179.
Springer, 2011.
[24] G. Lowe. An attack on the Needham-Schroeder public-key
authentication protocol. Information Processing Letters,
56:131–133, 1995.
[25] M. Ray and S. Dispensa. Renegotiating TLS. November
2009. Available at http:
//extendedsubset.com/Renegotiating_TLS.pdf.
[26] P. Rogaway and T. Stegers. Authentication without Elision:
Partially Speciﬁed Protocols, Associated Data, and
Cryptographic Models Described by Code. In CSF 2009,
pages 26–39. IEEE Computer Society, 2009.
[27] E. Tews and M. Beck. Practical Attacks against WEP and
WPA. In D. A. Basin, S. Capkun, and W. Lee, editors,
WISEC 2009, pages 79–86. ACM, 2009.
50