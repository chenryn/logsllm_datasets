C. Security Analysis
FPValidator implements the L3 function pointer valida-
tion, which checks the equivalence between the point-to type
and target type of function pointers. When using FPValida-
tor, all function entry attacks that violate type equivalence
can be detected. To bypass FPValidator, an adversary has
to ﬁnd a vulnerability through which he can tamper with a
function pointer of the desired type. Thus the possibility of
carrying out a successful attack is much lower than that of
L1 or L2 validation.
The effectiveness of FPValidator depends on the integrity
of the validation code and type information, which are
integrated into ELF ﬁles. As long as the code segment and
the type information are not compromised, the validation
mechanism will not be circumvented. Since the code seg-
ment and the type information do not change after being
loaded,
the memory they reside in is marked as read-
only during execution. Hence their integrity can easily be
veriﬁed by lower level software through cryptographic hash
functions. For example, the integrity of applications can
be veriﬁed by the OS kernel, by calculating the hashes of
code segment and type information, and comparing them
with trusted values. Similarly, the OS kernel itself can be
veriﬁed by virtual machine monitor. At last, the lowest level
software can be veriﬁed by some hardware solutions such
as the technology proposed by Trusted Computing Group
(TCG) [20].
D. The L4 Validation
If the compromised function pointer and the abused func-
tion are type equivalent, the attack will not be detected by
the L3 validation. In this case the L4 validation is required.
The L4 validation requires the precise set of possible targets
for each function pointer. Given these sets, the L4 validation
can be easily implemented in FPValidator. We just need
to replace the type information with the sets, and checks
whether the target address is included in the set, instead of
type matching.
However, there are some challenges in identifying precise
sets. If developers are responsible for providing all valid
entry sets, it is a tedious and error-prone task. Furthermore,
it is often impossible to list all entries at the development
stage, because some functions may be implemented by the
third party and loaded at runtime. Some solutions, such as
Inlined CFI and WIT, try to ﬁnd out precise sets via static
char ∗ i n b u f ,
i n t
l e n )
f o o ( unsigned long parm ,
1 t y p e d e f void (∗ f u n c t ) ( void ) ;
2
3 i n t
4
5
6 {
7
8
9
10
11
12
13
14 }
f u n c t
char b u f [ 1 6 ] ;
. . .
memcpy ( buf ,
i n b u f ,
f p = ( f u n c t ) parm ;
f p ( ) ;
. . .
f p ;
l e n ) ;
Figure 7.
PointGuard
A buggy function that could be exploited to circumvent
analysis [21], [22], but their results are still constrained by
the limitation of static analysis.
V. RELATED WORK
Manipulating function pointers is an often-used attacking
method. Many solutions have been proposed to thwart
against this kind of attacks. Among them we choose several
closely related solutions to compare with.
CFI is a safety property denoting that a programs ex-
ecution follows paths of its Control-Flow Graph (CFG)
determined in advance. Abadi et al propose an enforcing
method, called Inlined CFI [5], based on static binary
rewriting. Their method instruments each indirect branch,
validating its target according a CFG obtained statically.
However, such a CFG can hardly be precise. In order to
avoid false-positives, their implementation uses conservative
CFGs in which a call instruction may invoke any functions.
WIT [6] enforces CFI through compilation-stage instru-
mentation. Function pointers and functions, according to the
result of static points-to analysis, are labeled with colors. A
fragment of validation code is inserted before indirect calls,
checking whether the function pointer and the target function
have the same color. Since points-to analysis is not precise,
it is possible that all functions have the same color in order
to avoid false-positives.
Petroni et al propose a virtual machine based method
to enforce an approximate of CFI, called state-based CFI
(SBCFI) [4]. A monitor, running in the domain 0, validates
the global function pointer variables of the OS kernels in
other domains periodically. But their method only concerns
57
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:14:01 UTC from IEEE Xplore.  Restrictions apply. 
Table II
COMPARISON OF RELATED WORK
Solutions
Inlined CFI
WIT
SBCFI
Shepherding
NE Memory
FPValidator
Mechanism
Coverage
Level
Static Binary Instrumentation
Compilation-stage Instrumentation
VM-based Monitoring
Dynamic Binary Instrumentation
Hardware Support
Compilation-stage Instrumentation
Indirect Branches
Indirect Calls
Global Variables
Indirect Branches
Indirect Branches
Indirect Calls
L2
L2+
L2
L2
L1
L3
√
DRA
√
√
√
√
√
Attacks
√
NFEA
√
√
√
√
FEA
√
?
√
persistent attacks. Attacks ﬁnished within a period could
escape from being detected.
Program Shepherding [3] validates indirect branches by
dynamic binary translation. The validation code is inserted
by a dynamic translator, e.g. Dynamo [23] for their work,
into a code block before the block is executed. It checks the
targets of indirect branches by censoring a hash table which
contains all valid entries.
Non-Executable Memory (NE-Memory), such as Exec
Shield [24] and Openwall Linux patch [25], is capable of
marking some memory regions (e.g. stack and heap) as non-
executable, which usually requiring hardware support [26].
Thus, malicious code that is injected into stack or heap
and masquerading as data can not be executed, though
an adversary has succeeded in manipulating some function
pointers to target it. e-NeXSh uses a software approach, i.e.
monitoring all LIBC function and system-call invocations, to
create an “effectively” non-executable stack and heap [27].
The comparison of the above work with ours is shown
in Table II. Validation mechanism can be roughly divided
into instrumentation and monitoring. The former is harder
to be bypassed, while the latter is more ﬂexible. NE-
Memory uses another way to achieve the same effort of
instrumentation-based validation. Inlined CFI, Shepherding
and NE-Memory work at the binary level and deal with
all
indirect branches, some of which are derived from,
for example, switch statements whose targets are actually
ﬁxed [28]; while FPValidator and WIT validate all indirect
calls whose targets may be changed dynamically. SBCFI
only validates global variables, so it fails to detect attacks
on local variables and function pointer expressions. The
√
validation levels of these solutions are listed in the column
level, and the detectable attacks are marked with
. The
level of WIT depends on the precision of static points-to
analysis. Currently it could only reach L2 in some cases.
Some solutions try to protect function pointers from
being maliciously modiﬁed. For example, PointGuard [29]
encrypts pointers before writing and decrypts them before
reading. The encrypting and decrypting code is also in-
serted by a compilation-stage instrumentation mechanism.
Libsafe [30] and LibsafePlus [31] provide safe versions of
exploitable library functions such as strcpy and memcpy,
which could protect function pointers from being modiﬁed
through buffer overﬂow attacks. Stack-smashing protector
(SSP) [32] achieves this goal by rearranging local variables.
However, these solutions can not thoroughly defend against
illegal modiﬁcations. For example, the protection of Point-
Guard could be circumvented in some cases. Figure 7 shows
a buggy function that could be exploited to circumvent
PointGuard. Since PointGuard only encrypts pointers, an
adversary could modify parm through buffer overﬂow, and
then the modiﬁcation will be propagated to fp at line 9.
To provide stronger security, protection and validation of
function pointers can be combined to work together.
VI. CONCLUSION
Function pointers are often attacked at runtime by adver-
saries to execute malicious code, so it is useful to validate
their values on the ﬂy. But the validation performed by
existing solutions is not strict enough to detect function entry
attacks.
In this paper we propose FPValidator, a new solution
capable of dynamically validating the type equivalence of
function pointers and target functions, which is able to detect
all function entry attacks that manipulate function pointers
to invoke incompatible functions. The validation code is
inserted by a compilation-stage instrumentation mechanism,
bringing no extra burden to developers. We integrate FPVal-
idator into GCC, and the evaluation shows that it is both
effective and efﬁcient.
Currently we use C as the example language, but FPVal-
idator can also be used in other statically-typed languages.
C++, usually viewed as a super set of C, has a more com-
plicated type system. We are planning to apply FPValidator
to C++ in our future work.
REFERENCES
[1] J. Pincus and B. Baker, “Beyond Stack Smashing: Recent
Advances in Exploiting Buffer Overruns,” IEEE Security &
Privacy, vol. 2, no. 4, pp. 20 – 27, 2004.
[2] M. Castro, M. Costa, and T. Harris, “Securing software
by enforcing data-ﬂow integrity,” in the 7th Symposium
on Operating Systems Design and Implementation, Seattle,
Washington, 2006, pp. 147 – 160.
[3] V. Kiriansky, D. Bruening, and S. Amarasinghe, “Secure
Execution via Program Shepherding,” in 11th USENIX Se-
curity Symposium.
San Francisco, California: USENIX
Association, 2002, pp. 191 – 206.
58
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:14:01 UTC from IEEE Xplore.  Restrictions apply. 
[4] J. Nick L. Petroni and M. Hicks, “Automated Detection
of Persistent Kernel Control-Flow Attacks,” in the 14th
ACM Conference on Computer and Communications Security
(CCS’07). Alexandria, Virginia, USA: ACM, 2007, pp. 103
– 115.
[5] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti, “Control-
Flow Integrity,” in the 12th ACM Conference on Computer
and Communications Security (CCS’05), Alexandria, VA,
USA, 2005, pp. 340 – 353.
[6] P. Akritidis, C. Cadar, C. Raiciu, M. Costa, and M. Castro,
“Preventing Memory Error Exploits with WIT,” in SP ’08:
Proceedings of the 2008 IEEE Symposium on Security and
Privacy (sp 2008). Washington, DC, USA: IEEE Computer
Society, 2008, pp. 263–277.
[7] L. O. Andersen, “Program analysis and specialization for the
c programming language,” Ph.D. dissertation, 1994.
[8] M. Hind, “Pointer Analysis: Haven’t We Solved This Prob-
lem Yet?” in PASTE ’01: Proceedings of the 2001 ACM
SIGPLAN-SIGSOFT workshop on Program analysis for soft-
ware tools and engineering. New York, NY, USA: ACM,
2001, pp. 54–61.
[9] C. Chambers, D. Ungar, and E. Lee, “An Efﬁcient Imple-
mentation of Self, A Dynamically-Typed Object-Oriented
Language Based On Prototypes,” ACM SIGPLAN Notices,
vol. 24, no. 10, pp. 49–70, 1989.
[10] M. Chang, M. Bebenita, A. Yermolovich, and A. Gal, “Ef-
ﬁcient Just-In-Time Execution of Dynamically Typed Lan-
guages Via Code Specialization Using Precise Runtime Type
Inference,” Donald Bren School of Information and Computer
Science, University of California, Irvine, Tech. Rep., 2007.
[11] C. Flanagan, “Hybrid Type Checking,” in the 33rd ACM
SIGPLAN-SIGACT Symposium on Principles of Programming
Languages, Charleston, South Carolina, USA, 2006, pp. 245
– 256.
[12] S. Fagorzi and E. Zucca, “A Calculus of Components with
Dynamic Type-Checking,” Electronic Notes in Theoretical
Computer Science (ENTCS), vol. 182, pp. 73 – 90, 2007.
[13] R. B. Findler and M. Felleisen, “Contracts for Higher-order
Functions,” ACM SIGPLAN Notices, vol. 37, no. 9, pp. 48 –
59, 2002.
[14] U. Erlingsson, “Low-Level Software Security: Attacks and
Defenses,” in Foundations of Security Analysis and Design
IV, LNCS 4677/2007. Springer Berlin, 2007, pp. 92–134.
[15] A. V. Aho, M. S. Lam, R. Sethi, and J. D. Ullman, Compilers:
Addison-Wesley,
Principles, Techniques, and Tools 2nd.
2006.
[16] A. M. Zaremski and J. M. Wing, “Signature Matching: A Tool
for Using Software Libraries,” ACM Transactions on Software
Engineering and Methodology, vol. 4, no. 2, pp. 146 – 170,
1995.
[17] M. V. Aponte and R. D. Cosmo, “Type Isomorphisms for
Module Signatures,” in the 8th International Symposium
on Programming Languages: Implementations, Logics, and
Programs. Springer-Verlag, 1996, pp. 334 – 346.
[18] S. Jha, J. Palsberg, and T. Zhao, “Efﬁcient Type Matching,” in
the 5th International Conference on Foundations of Software
Science and Computation Structures. Springer-Verlag, 2002,
pp. 187–204.
[19] Wikibooks, “GNU C Compiler Internals,” 2008. [Online].
http://en.wikibooks.org/wiki/GNU C Compiler
Available:
Internals
[20] TCG, “TCG Speciﬁcation Architecture Overview,” August
2007.
[21] D. Liang and M. J. Harrold, “Efﬁcient Points-to Analysis for
Whole-program Analysis,” in ESEC/FSE-7: Proceedings of
the 7th European software engineering conference held jointly
with the 7th ACM SIGSOFT international symposium on
Foundations of software engineering. London, UK: Springer-
Verlag, 1999, pp. 199–215.
[22] N. Heintze and O. Tardieu, “Ultra-fast Aliasing Analysis
Using CLA: A Million Lines of C code in a Second,”
SIGPLAN Notices, vol. 36, no. 5, pp. 254–263, 2001.
[23] V. Bala, E. Duesterwald, and S. Banerjia, “Dynamo: A Trans-
parent Dynamic Optimization System,” in the ACM SIGPLAN
2000 Conference On Programming Language Design And
Implementation.
Vancouver, British Columbia, Canada:
ACM Press, 2000, pp. 1 – 12.
[24] “Exec Shield. http://people.redhat.com/mingo/exec-shield.”
[25] “Linux
kernel
http://www.openwall.com/linux/.”
patch
from the Openwall
Project.
[26] “Intel 64 and IA-32 Architectures Software Developer’s Man-
ual,” November 2007.
[27] G. S. Kc and A. D. Keromytis, “e-NeXSh: Achieving an
Effectively Non-Executable Stack and Heap via System-Call
Policing,” in the 21st Annual Computer Security Applications
Conference (ACSAC’05), 2005, pp. 286 – 302.
[28] C. Cifuentes and M. V. Emmerik, “Recovery of Jump Table
Case Statements from Binary Code,” Science of Computer
Programming, vol. 40, no. 2-3, pp. 171 – 188, 2001.
[29] C. Cowan, S. Beattie, J. Johansen, and P. Wagle, “PointGuard:
Protecting Pointers from Buffer Overﬂow Vulnerabilities,” in
the 12th USENIX Security Symposium, 2003, pp. 91 – 104.
[30] A. Baratloo, T. Tsai, and N. Singh, “Libsafe: Protecting
Critical Elements of Stacks,” December 25 1999.
[31] K. Avijit, P. Gupta, and D. Gupta, “TIED, LibsafePlus: Tools
for Runtime Buffer Overﬂow Protection,” in the 13th USENIX
Security Symposium, 2004.
[32] H. Etoh, “GCC Extension for Protecting Applications
from Stack-smashing Attacks (ProPolice),” 2003. [Online].
Available: http://www.trl.ibm.com/projects/security/ssp/
59
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:14:01 UTC from IEEE Xplore.  Restrictions apply.