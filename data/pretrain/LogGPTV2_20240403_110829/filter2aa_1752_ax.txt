进以及的时对的。
。的的对单的自然对更
的。的
• 的对的的的。
的以 4 对的 32bit 的以 4 对
。
• 对的以自的对
。以 char (能以 1 对)  int (能以 4 
对)自 3 作 int 以 4 对。程
们时的的空间
。以将的小进。 GCC 时
-Wpadded 以。时出。
• 的对的。
• 的对的。以对
对的对。以的自
然对的。
。处理绝的对以
的的时。然的处理
的时。
设对的对的
的时处理能对的
对。的段 c  badnews 的程将 c 
unsigned long 读
char greeting[] = ”Ahoy Matey”;
char *c = greeting[1];
unsigned long badnews = *(unsigned long *) c;
 unsigned long 能以 4 或 8 对 c 然以 1 
对。 c 进读将对。的的
– 269 –
 8 
内存理
同的上同小性能程。
以能处理对的内出的进程 SIGBUS
进程。我们。
的子实出的的。然实的子
们更。
8.3 数据段的管理
Unix 上提理段的。然 malloc() 
的方更程。我
满的同时给自实
的的
#include 
int brk (void *end);
void * sbrk (intptr_t increment);
 Unix 的时同
段。存的段的上段的
。的 (break) 或 (break point)。
段存自的内存映射我们映射的
。
调 brk() 设 (段的) 的 end。的时
 0。的时 -1设 errno  ENOMEM。
调 sbrk() 将段 increment  increment 。 sbrk()
的。以 increment  0 时的的
printf(”The current break point is %p\n”,sbrk(0));
 POSIX  C 。的 Unix 
。的程的。
– 270 –
 8 
内存理
8.4 匿名存储器映射
glibc 的内存段内存映射。实 malloc( ) 方
将段的小 2 的的小的的满
。单的将。相的空
的们更的。的空的以 brk(
) 将内存给。
内存（buddy memory allocation scheme。的
单的。的内存
的小时内（Internal fragmentation。内存的
率。空存满单
的空间以处理时的。同内存（
能更的或的（的存。
内存的 glibc 能将
的内存给。内存的 A  B。 A 
处的 B  A 的 B A 
glibc 能相的调。存的内存
的空空间。
 glibc 将空间给∗。
。 glibc 的内存以的
。的的内存时 glibc 小段的小。
方的。
 对    的   glibc              内 存 映
射。（anonymous memory mapping满。存映射
的文件的映射相文件 - 以。实
上内存映射 0 的的内存以
。以单的。映射的存
的以段内。
映射内存处
• 。程内存的时映射
内存给。
∗glibc 更进的存 arena 。
– 271 –
 8 
内存理
• 存映射的小的调的以设能的映射
（。
• 存的内存映射。理的。
映射
• 存映射页小的。以小页
的的空间。对小的空间的更
相对的空间的空间将更。
• 新的内存映射内存的
及何内操作。小的的。
自的 glibc 的 malloc() 段满小的
内存映射满的。的调的（
的内存 glibc 的同。
 128KB 128KB 小的实相的
存映射实。
8.4.1 创建匿名存储器映射
或内存映射或写自
的内存工自的内存映射 Linux 将
单。 mmap（内存映射
munmap（
#include 
void * mmap (void *start,
size_t length,
int prot,
int flags,
int fd,
off_t offset);
int munmap (void *start, size_t length);
理文件存映射文件的存
映射更单。的。我们
子
– 272 –
 8 
内存理
void *p;
p = mmap (NULL, /* do not care where */
512 * 1024, /* 512 KB */
PROT_READ | PROT_WRITE, /* read/write */
MAP_ANONYMOUS | MAP_PRIVATE, /*
anonymous, private */
-1, /* fd (ignored) */
0); /* offset (ignored) */
if (p == MAP_FAILED)
perror (”mmap”);
else
/* ’p’ points at 512 KB of anonymous
memory... */
对的映射 mmap() 的子。然
程映射小的。
•  start设 NULL映射以内的
上。然给 non-NULL 以的页对的
性。实上程真映射上!
• prot 同时设 PROT READ  PROT WRITE 映射
读写的。能读写的空存映射的。方
将映射映射能的。
• flags 设 MAP ANONYMOUS 映射的设
MAP PRIVATE 映射的。
•  MAP ANONYMOUS 设 fd  offset 将的。然
更的 fd  -1程的
性。
映射的内存上的。映射进
的处的页 0 进。内写时
 (copy-on-write) 将内存映射 0 的页上的
。同时对的内存 memset()。实上
calloc（ malloc（ memset（效的原 glibc 
映射 0 的映射的 calloc() 式的零
– 273 –
 8 
内存理
。调 munmap() 映射的内存给内。
int ret;
/* all done with ’p’, so give back the 512 KB
mapping */
ret = munmap (p, 512 * 1024);
if (ret)
perror (”munmap”);
 mmap() munmap()的映射。
8.4.2 映射到 /dev/zero
  Unix   (  BSD)   MAP ANONYMOUS 
。相们的设备文件 /dev/zero 实的
方。设备文件提内存相同的。 0 的写时
页的映射存。 Linux  /dev/zero 设备
以映射文件 0 的内存。实上 MAP ANONYMOUS
 Linux 的程方。对的 Linux 提或
 Unix 上程然以将 /dev/zero 作映射
方。文件的映射
void *p;
int fd;
/* open /dev/zero for reading and writing */
fd = open (”/dev/zero”, O_RDWR);
if (fd 
int mallopt (int param, int value);
调 mallopt() 将 param 的存理相的设 value。
时调 0 时 0。以
对能的。
Linux  param   
M CHECK ACTION
    MALLOC CHECK 的 （将     
。
– 275 –
 8 
内存理
M MMAP MAX
    满    存     的   存   映 射
。时能段进
映射。 0 时将
映射存的。
M MMAP THRESHOLD 映射段满存
的（以单。的时
小能
映射满存的。 0 时
映射满的段满
。
M MXFAST
Fast bin 的小（以单。 Fast bins 
的内存的内存
给以满的内
存。 0 时 fasy bin 将。
M TOP PAD
调    段 的      的  （padding 
。 glibc  brk() 段的小时
能更的内存调 brk() 的
能性。相 glibc 段的时
的内存将的给。
的。 0 时。
XPG    mallopt(),         :M GRAIN, M KEEP, 
M NLBLKS。 Linux 实上何作。 8-1 
们的以及的。
– 276 –
 8 
内存理
效
M CHECK ACTION
Linux 
0
0-2
M GRAIN
XPG 
Linux 
>=0
M KEEP
XPG 
Linux 
>=0
M MMAP MAX
Linux 
64*1024
>=0
0  mmap()
M MMAP THRESHOLD
Linux 
128*1024
>=0
0 
M MXFAST
XPG 
64
0-80
0  fast bin
M NLBLK
XPG 
Linux 
>=0
M TOP PAD
Linux 
0
>=0
0 
程调 malloc() 或内存 mallopt()方
单
/* use mmap( ) for all allocations over 64 KB */
ret = mallopt (M_MMAP_THRESHOLD, 64 * 1024);
if (!ret)
fprintf (stderr, ”mallopt failed!\n”);
8.5.1 使用 malloc usable size() 和 malloc trim() 进行调优
Linux 提 glibc 内存的。
程内存
#include 
size_t malloc_usable_size (void *ptr);
调 malloc usable size() 时 ptr 的内存的实小。
 glibc 能扩内存存的或映射存
的空间能的。然能的小。
的子
size_t len = 21;
size_t size;
char *buf;
– 277 –
 8 
内存理
buf = malloc (len);
if (!buf) {
perror (”malloc”);
return -1;
}
size = malloc_usable_size (buf);
/* we can actually use ’size’ bytes of ’buf’... */
程 glibc 的的内存给内
#include 
int malloc_trim (size_t padding);
调  malloc trim()   时  段    能         
。然 1。时 0。空的内存
M TRIM THRESHOLD 时 glibc 自。 M TOP PAD 
作。将调以的方。们
的将 glibc 内存的给的程。
8.6 调试内存分配
程以设 MALLOC CHECK 存的调
能。的调以内存的效率的然
的调段的。
能调新的程。
以单的
$ MALLOC_CHECK_=1 ./rudder
设 0存。设 1 
出出 stderr。设 2进程即 abort( ) 。
MALLOC CHECK 的程的以 setuid 程
。
8.6.1 获得统计数据
Linux 提 mallinfo() 存的
– 278 –
 8 
内存理
#include 
struct mallinfo mallinfo (void);
mallinfo() 的调将存 mallinfo 。
的。的段  。
/* all sizes in bytes */
struct mallinfo {
int arena; /* 的段的小malloc */
int ordblks; /* 空的 */
int smblks; /* fast bin 的 */
int hblks; /* 映射的 */
int hblkhd; /* 映射的小 */
int usmblks; /*  */
int fsmblks; /* 的fast 的小bin */
int uordblks; /* 的的空间 */
int fordblks; /* 的小 */
int keepcost; /* 的空间的小 */};
单
struct mallinfo m;
m = mallinfo();
printf (”free chunks: %d\n”, m.ordblks);
Linux 提 stats() 将内存相的
出（stderr
#include 
void malloc_stats (void);
内存操作的程调的:
Arena 0:
system bytes = 865939456
in use bytes = 851988200
– 279 –
 8 
内存理
Total (incl. mmap):
system bytes = 3216519168
in use bytes = 3202567912
max mmap regions = 65536
max mmap bytes = 2350579712
8.7 基于栈的分配
我们的的内存存
映射实的。我们自然的们映射
的。程空间的存程的自
（automatic variables的。
然程能进内存理的。
出的单的。实
内存调 alloca()
#include 
void * alloca (size_t size);
调 alloca()时 size 小的内存。内存
的调的（ main 时, 内存将自
。的实时 NULL时 alloca() 
能或能。出的出。
 malloc() （实上能的内存。以
示 (能 /etc) 给的文件
时。新的
然将提的文件的
int open_sysconf (const char *file, int flags,
int mode)
{
const char *etc = SYSCONF_DIR; /* ”/etc/” */
char *name;
name = alloca (strlen (etc) + strlen (file) +
– 280 –
 8 
内存理
1);
strcpy (name, etc);
strcat (name, file);
return open (name, flags, mode);
}
 open sysconf 时 alloca() 的内存的自