# 存储媒体
> 原文：
## 介绍
存储介质是用来存储数据和信息的设备。在处理包括存储设备在内的外部设备时，Linux 有着惊人的能力。存储设备有很多种，物理存储设备如硬盘、虚拟存储设备如 RAID 或 LVM、网络存储等等。
在本节中，我们将学习如何使用任何存储设备，并根据我们的需求对其进行配置。
## 列出已装载的存储设备:
我们可以使用 **`mount`** 命令来列出所有挂载到你电脑上的存储设备。
![](img/ffc28f1f8fee236a29bdd70c06f552d7.png)
我们看到的上面输出的格式是:
*`device`* 上 *`mount_point`* 下 *`file\_system\_type (options)`*
例如，在第一行中，虚拟设备 *sysfs* 安装在 */sys* 路径中，并且具有一个 *sysfs* 文件系统。现在让我们看看什么是文件系统以及如何创建文件系统。
## 创建文件系统
想象一个磁盘，其中存储在磁盘中的所有数据都是一个大块的形式，没有什么要弄清楚一块数据在哪里开始和结束，哪块数据位于整个数据块的哪个位置，因此文件系统就进入了画面。文件系统(fs)负责任何存储设备上的数据存储、索引和检索。
以下是最常用的文件系统:
| f 型 | 描述 |
| --- | --- |
| 文件分配表(file allocation table) | 文件分配表，最初用于 DOS 和 Microsoft Windows，现在广泛用于便携式 USB 存储 |
| Windows NT 文件系统(NT File System) | (新技术文件系统)用于微软基于 Windows 的操作系统 |
| 外面的（exterior 的简写） | 为 Linux 系统设计的扩展文件系统。 |
| ext4 | 第四个扩展文件系统是日志文件系统，通常由 Linux 内核使用。 |
| 超精结构(hyperfine structure) | 分层文件系统，在 Mac OS 8.1 上引入 HFS+之前一直使用。 |
| HFS+ | 支持文件系统日志记录，支持系统崩溃后的数据恢复。 |
| 网络文件系统 | 最初来自 Sun Microsystems 的网络文件系统是基于 UNIX 的网络中的标准。 |
我们将尝试使用 [*mkfs*](https://man7.org/linux/man-pages/man8/mkfs.8.html) 创建一个 *ext4* 文件系统，它是 linux 原生 fs。
Discalimer:在空磁盘上运行该命令，因为这将清除现有数据。
![](img/a46523d026fcb860052b83d64599a876.png)
在这里，设备 */dev/sdb1* 被格式化，其文件系统被更改为 *ext4* 。
## 安装设备:
在 Linux 系统中，所有的文件都是以(/)为根的树形结构排列的。挂载一个文件系统仅仅意味着让 Linux 目录树中的某个点可以访问这个文件系统。
我们需要一个挂载点(位置)来挂载上面格式化的设备。
![](img/0452e81b8624e77c43cea607677059b8.png)
我们创建了一个挂载点 */mount* ，并使用 *[mount](https://man7.org/linux/man-pages/man8/mount.8.html)* 命令来附加文件系统。这里的 *-t* 标志指定了什么是 fs 类型，之后是 */dev/sdb1* (设备名)和/mount(我们之前创建的挂载点)。
## 卸载设备:
现在让我们来看看如何卸载设备，如果我们有可移动存储介质，并希望安装到另一台主机上，这同样重要。我们使用 [***卸载***](https://man7.org/linux/man-pages/man8/umount.8.html) 来卸载设备。
![](img/f09d70941dd28c0843e2c8ad4cdd7bb8.png)
我们的第一次尝试没有卸载/sdb1，因为我们在存储设备内部，并且它正在被使用。一旦我们伸缩主目录，我们就能够成功地卸载设备。
## 使用/etc/fstab 文件会更容易吗？
在我们的生产环境中，我们的服务器可能有许多需要装载的存储设备，每次重新启动系统时使用命令装载每个设备是不可行的。为了减轻这一负担，我们可以利用 Linux 系统上的 ***`/etc/fstab`*** 中常见的名为“fstab”的配置表。
![](img/24bffcb297e13b9e12fce51278773e27.png)
在这里的第一行中，我们将 */dev/mapper/rootvg-rootlv(存储设备*)挂载在 */(根挂载点)上，它具有 xfs 文件系统类型*，后跟选项。
我们可以运行 *`mount -a`* 来重新载入修改后的这个文件。
## 检查和修理 FS
文件系统在任何硬件故障、电源故障的情况下都会遇到问题，有时是由于不正确的关机。Linux 通常在启动时检查并修复损坏的磁盘。我们还可以使用命令[***fsck***](https://man7.org/linux/man-pages/man8/fsck.8.html)手动检查文件系统的损坏。
![](img/458538d18563a2a377959ffb726c96c8.png)
我们可以使用 *`fsck -y /dev/sdb1`* 修复同一个文件系统。
每种文件系统错误都附有错误代码，并返回活动错误的总和。
| 错误代码 | 描述 |
| --- | --- |
| Zero | 没有错误 |
| one | 文件系统错误已更正 |
| Two | 系统应该重新启动 |
| four | 未纠正的文件系统错误 |
| eight | 操作错误 |
| Sixteen | 用法或语法错误 |
| Thirty-two | 用户请求取消检查 |
| One hundred and twenty-eight | 共享库错误 |
在上面的 fs 检查中，我们得到了返回代码 12，这是错误代码 8(操作错误)和 4(未纠正的 FS 错误)的总和。
## 袭击
RAID 或“独立磁盘冗余阵列”是一种跨多个磁盘分布 I/O 以实现更高性能和数据冗余的技术。RAID 能够提高整体磁盘性能，并在磁盘出现故障时仍然存在。软件 RAID 使用计算机的 CPU 来执行 RAID 操作，而硬件 RAID 使用磁盘控制器上的专用处理器来管理磁盘。RAID 的三个基本功能是镜像、条带化和奇偶校验。
## RAID 级别
下一节讨论了常用的 RAID 级别。关于所有 RAID 等级的信息，请参考 [这里](https://en.wikipedia.org/wiki/RAID) 。
### RAID 0(条带化)
分条是将数据拆分成“块”并写入阵列中所有磁盘的方法。通过将数据分布在多个驱动器上，这意味着多个磁盘可以访问文件，从而提高了读/写速度。阵列中的第一个磁盘不会重复使用，直到等量的数据写入阵列中的其他每个磁盘。
![](img/df56383eaf4a470e85efa6bba1f0c2a6.png)
优势
*   这很容易实现。
*   避免了由于来自同一磁盘的 I/O 操作而导致的瓶颈，从而提高了此类操作的性能。
不足之处
*   它不提供任何冗余。如果任何一个磁盘出现故障，整个磁盘的数据都会丢失，并且无法恢复。
用例
RAID 0 可用于需要高速读取非关键数据的系统，例如视频/音频编辑站或游戏环境。
### RAID 1(镜像)
镜像将数据副本写入阵列中的每个磁盘。这意味着数据的写入次数与阵列中的磁盘数一样多。它将所有数据的精确副本存储在单独的一个或多个磁盘上。正如预期的那样，与单个磁盘相比，这将导致较慢的写入性能。另一方面，读取操作可以并行进行，从而提高读取性能。
![](img/7c7ccee65b6c04196a87be1a67c2d96a.png)
优势
*   RAID 1 提供了比 RAID 0 或单个磁盘更好的读取性能。
*   它可以承受多个磁盘故障，而不需要特殊的数据恢复算法
不足之处
*   由于数据复制，有效存储容量只有磁盘数量的一半，因此成本很高。
用例
要求低停机时间但对写入性能有轻微影响的应用。
### RAID 4(带专用奇偶校验的条带化)
RAID 4 works 使用块级条带化(根据应用和要存储的数据，可以将数据条带化为各种大小的块)和用于存储奇偶校验信息的专用驱动器。每次将数据写入阵列磁盘时，都会通过算法生成奇偶校验信息。使用奇偶校验位是将校验和添加到数据中的一种方式，可以使目标设备确定数据是否已被正确接收。如果驱动器出现故障，可以反转算法，并根据剩余数据和奇偶校验信息生成缺失数据。
![](img/c58861af8c4f319e85e59954561765a5.png)
优势
*   RAID 4 阵列中的每个驱动器都独立运行，因此 I/O 请求并行发生，性能比以前的 RAID 级别更快。
*   它可以承受多个磁盘故障，而不需要特殊的数据恢复算法
不足之处
*   安装至少需要 3 张磁盘。