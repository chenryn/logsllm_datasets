i, c
i
∗
i
∗
i , s
i, ti,1, . . . , ti,(cid:2)), (c
∗
i ) on message m
• If ci,0 = ci,1, then F aborts. Otherwise, it continues
the (cid:3) open signing sessions by generating random bits
bi,1(cid:12) . . .(cid:12)bi,(cid:2) ← rand((pk
∗
i , ci,0, ci,1))
and sending the ﬁnal ¯t-value for the j-th signing session
as ¯ti,j ← gbi,j for j = 1, . . . , (cid:3).
• When F receives the values si,1, . . . , si,(cid:2) in the (cid:3) signing
protocols, it veriﬁes that gsi,j = ti,j · pk ci,bi,j
, aborting
if an invalid signature is detected.
• F outputs a forgery (c
∗
with public
} by computing s
← forge(¯t
keys PK = {pk
∗
∗
i , pk
i ).
Observe that F makes (cid:3) signing queries, three random-
oracle queries, and performs at most (2(cid:3) + 1) exponentiations
so that F runs in time (2(cid:3)+1)τexp+O((cid:3)). It outputs a success-
ful forgery unless ci,0 = ci,1, which happens with probability
1/q. Therefore, F is a ((2(cid:3)+1)τexp+O((cid:3)), (cid:3), 3, 1−1/q)-forger
for CoSi. Note that F works in the KOSK setting because the
forgery doesn’t include any signer other than the target signer.
Suppose that there exists an algebraic reduction B that,
when given black-box access to the above forger F, (τ, )-
breaks the n-OMDL problem. We now describe a meta-
reduction M that breaks the (n+k)-OMDL problem, where k
is the number of times that B runs F. As mentioned earlier, M,
on input target points y0, . . . , yn+k, runs B on input y0, . . . , yn
and forwards B’s Odlog queries to its own Odlog oracle.
It implements the subroutines target and rand as explained
above, and implements the forge subroutine as follows:
the i-th execution of F invokes the subroutine
• If
∗
∗
i , pk
forge(¯t
i ) and there exists a previous execution
(cid:9)= i that already computed the secret key sk i corre-
(cid:3)
i
sponding to pk
i, then the subroutine computes and return
i(cid:2) )·sk i mod q .
∗
the requested s-value as s
• If the i-th execution of F invokes the subroutine forge(¯t
∗
i ,
(cid:3) (cid:9)= i with
pk
(pk
i, ti,1, . . . , ti,(cid:2)), then it checks
whether (ci(cid:2),bi(cid:2) ,1 , . . . , ci(cid:2),bi(cid:2) ,(cid:2) ) = (ci,bi,1 , . . . , ci,bi,(cid:2) ). If
so, then M halts and outputs failure. If not, then there
(cid:9)= ci,bi,j , so
exists at least one index j such that ci(cid:2),bi(cid:2) ,j
that M can compute the secret key sk i corresponding to
i as sk i ← si,j−si(cid:2) ,j
mod q . It can then compute
−ci(cid:2) ,b
i(cid:2) )·
∗
and return the requested s-value as s
sk i mod q .
• Else, M uses Odlog and returns s
∗
i
i ) .
If B is successful, then B will output x0, . . . , xn such that
yi = gxi for i = 0, . . . , n after having made at most n queries
to its Odlog oracle. Now M proceeds to compute the discrete
logarithms xn+1, . . . , xn+k of yn+1, . . . , yn+k as follows.
Let P be the partition of {1, . . . , k} where i and i
(cid:3)
∗
i ) and there exists a previous execution i
← s
∗
i(cid:2) + (c
← Odlog(¯t
∗
i
i, ti,1, . . . , ti,(cid:2)) = (pk
are
considered equivalent (and are therefore in the same com-
ponent C ∈ P ) if the i-th and i
-th executions are such
that (pk
i(cid:2) , ti(cid:2),1, . . . , ti(cid:2),(cid:2)). Because of
the way M instantiated the target subroutine, we know
that M used the same target point yjC as the value ¯t
∗
i for
all executions i that are in the same component C ∈ P ,
meaning that during the full simulation of B, M used target
points yn+1, . . . , yn+|P|. Let P0 be the set of components
C ∈ P such that F never invoked the forge subroutine in any
execution i ∈ C, let P1 contain C ∈ P such that F invoked
i, c
i(cid:2) , ti(cid:2),1, . . . , ti(cid:2),(cid:2)) = (pk
∗
i
− c
· pk c
∗
i(cid:2) +(c
∗
i
← s
ci,bi,j
i(cid:2) ,j
∗
i
∗
i
∗
i
−c
i, c
pk
(cid:3)
(cid:18)(cid:17)(cid:26)(cid:18)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:45:54 UTC from IEEE Xplore.  Restrictions apply. 
the forge exactly once over all executions i ∈ C, and let P2+
contain the components C ∈ P such that F invoked forge at
least twice in total over all executions i ∈ C. It is clear that
|P| = |P0| + |P1| + |P2+|.
We will now show that M, using a total of |P| queries to
its Odlog oracle, can derive a system of |P| independent linear
equations in the |P| unknowns xn+1, . . . , xn+|P|. Namely,
for every component C ∈ P0, M simply makes a discrete-
logarithm query αC ← Odlog(yjC ), which adds an equation
of the form
xjC = αC .
(1)
∗
i
· pk c
For every component C ∈ P1,
there exists exactly one
←
execution i ∈ C that caused M to make a query s
i ). Since B is algebraic and only obtains group
Odlog(yjC
i output by B, M
elements g, y0, . . . , yn+k as input, for all pk
can use Extract to obtain coefﬁcients βi, βi,0, . . . , βi,n+k ∈ Zq
n+k
such that sk i = logg(pk
j=0 βi,jxj mod q. For
every C ∈ P1 it therefore has an equation of the form
i) = βi +
(cid:6)
∗
i
(cid:3)
and (ci(cid:2),bi(cid:2) ,1 , . . . , ci(cid:2),bi(cid:2) ,(cid:2) ) = (ci,bi,1 , . . . , ci,bi,(cid:2) ). We know
that ci,0 (cid:9)= ci,1, because otherwise F would have aborted
earlier, meaning that at most one choice for bi,j will cause
ci(cid:2),bi(cid:2) ,j = ci,bi,j . Therefore, at the moment that bi,1(cid:12) . . .(cid:12)bi,(cid:2) is
chosen at random from {0, 1}(cid:2) in a call to the rand subroutine,
(cid:9)= i there is at most one bad choice
for each execution i
for bi,1(cid:12) . . .(cid:12)bi,(cid:2) that causes M to output failure, meaning
that there are at most k bad choices overall. (Note that the
output of rand is fresh because it takes the full transcript of
the protocol so far as an argument. If the arguments of rand
-th execution, then the executions
are equal in the i-th and i
are simply identical. Also note that B learns F’s choice for
bi,1(cid:12) . . .(cid:12)bi,(cid:2) before F calls the forge subroutine, so that it
open at the same
could keep many candidate executions i
time.) The probability that the choice of bi,1(cid:12) . . .(cid:12)bi,(cid:2) hits any
of these k bad choices causing M to output failure in any of
the k executions is at most k2/2(cid:2). The success probability in
solving the (n + k)-OMDL game is therefore  − k2/2(cid:2).
(cid:3)
(cid:3)
n+k(cid:16)
∗
i = xjC + c
∗
i (βi +
s
βi,jxj) mod q .
(2)
3.2 Applicability to MuSig
j=0
∗
i
Note that x0, . . . , xn are known values above, as they were
output by B. For every component C ∈ P2+, M made one
∗
i ) during the
discrete-logarithm query s
i
ﬁrst invocation of forge, and extracted the value of sk i during
the second invocation of forge. It can therefore add an equation
of the form
← Odlog(yjC
· pk c
(3)
Finally, for the unused target points yj, j ∈ {n + |P| +
1, . . . , n + k}, M can make an additional query αj ←
Odlog(yj) to obtain an equation
sk i mod q .
∗
i = xjC + c
∗
i
s
(cid:3)
for i
xj = αj .
i, its view is independent of yji(cid:2)
(4)
The metareduction M created a system of |P0| equations of
the form (1), |P1| equations of the form (2), |P2+| equations
of the form (3), and k − |P| equations of the form (4),
so that overall it has a system of k linear equations in k
unknowns. The equations of the form (1), (3), and (4) are
clearly linearly independent, as each of these equations affects
a single and different unknown xj. Equations of the form (2)
are independent as well, because at the time that B produces
pk
> i. One can
therefore order the equations of the form (2) such that each
contains one unknown xjC that does not occur in any of the
preceding equations.
Solving this linearly independent system of k equations in
k unknowns yields all the values for xn+1, . . . , xk. M can
therefore output (x0, . . . , xn+k) after having made exactly one
Odlog query for each of the k equations and at most n Odlog
queries to respond to B’s Odlog queries, meaning at most n+k
queries in total.
The metareduction M runs in time τ + τext + O(n + k(cid:3))
and wins the (n + k)-OMDL game whenever B wins the n-
OMDL game, unless M outputs failure. The latter happens
when in the i-th execution of F, there exists a previous exe-
cution i
i, ti,1, . . . , ti,(cid:2))
i(cid:2) , ti(cid:2),1, . . . , ti(cid:2),(cid:2)) = (pk
< i with (pk
(cid:3)
While our metareduction is written for CoSi,
the same
technique can be applied to the similar multi-signature scheme
MuSig as recently introduced by Maxwell et al. [MPSW18a].
The main difference between CoSi and MuSig is in how
they avoid rogue-key attacks. While CoSi uses the key-
veriﬁcation model to avoid these attacks, MuSig works in
the plain public key model by using a more involved key
aggregation procedure. Rather than simply multiplying the
individual keys together, they raise the individual keys to a
hash function output, and present a security proof under the
OMDL assumption. However, the problem in proving CoSi
secure is not related to rogue-key attacks, as demonstracted
by the fact that our metareduction holds in the KOSK setting,
but due to the fact that many signing queries can be made
in parallel, and rewinding may force the reduction to know
the signer’s secret key. Indeed, the same metareduction (with
some minor changes in bookkeeping and including the more
involved key aggregation) is applicable to MuSig, proving
that their security proof overlooked this case and that it is
very unlikely that MuSig can be proven secure under standard
assumptions. In response to this work, the authors updated
MuSig to use a 3-round signing algorithm [MPSW18b].
3.3 Applicability to MWLD
Our metareduction can be applied to the MWLD scheme
with small modiﬁcations. This means that the security proof
under the DL assumption [MWLD10] is ﬂawed.3 While the
metareduction is mostly unchanged, the forger and the forge-
routine slightly change to account for the double generator and
the double hashing.
3Claim 4 of [MWLD10] is incorrect: while the view of the forger is
independent of (sk 1, sk 2) in a single run of the forger, the joint input of
different rewindings of the forger are not independent of (sk 1, sk 2), and
hence the keys that the reduction extracts from these different rewindings are
not independent of (sk 1, sk 2) either. Their event E1 may therefore occur
with a non-negligible probability.
(cid:18)(cid:17)(cid:26)(cid:19)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:45:54 UTC from IEEE Xplore.  Restrictions apply. 
3.4 Applicability to BCJ
Our metareduction can be applied to the BCJ key-
veriﬁcation model scheme with small modiﬁcations. This
means
the DL assump-
tion [BCJ08] is ﬂawed.4
the security proof under
that
4. SUB-EXPONENTIAL ATTACKS ON MULTI-SIGNATURE
SCHEMES
In this section we state the k-sum problem [Wag02], which
is a k-dimensional generalization of the birthday problem.
We show that
the security of CoSi, MuSig, MWLD, and
BCJ multi-signature schemes can be reduced to this problem.
Wagner [Wag02] proposed an algorithm that solves the k-
sum problem in sub-exponential
time. Together these re-
sults allow us to break the above multisignature schemes.
Finally, we point out that the public-randomness generator
RandHound [SJKK+17] is insecure, which stems from its use
of the CoSi scheme.
Our attacks are related to the ROS-based attack on blind
signatures [Sch01], which can also be reduced to the k-sum
problem [Wag02]. However, for subtle reasons our attacks on
multi-signatures need to use the k-sum problem directly.
4.1 The k-Sum Problem
We now deﬁne the k-sum problem and provide the com-
plexity estimates for solving it.
Deﬁnition 5 (k-Sum Problem). The k-sum problem in group
(Zq, +) for an arbitrary q provides k lists L1, . . . , Lk of equal
size, each containing elements sampled uniformly and inde-
pendently from Zq, and requires to ﬁnd x1 ∈ L1, . . . , xk ∈ Lk
such that x1 + . . . + xk ≡ 0 mod q. We say that adversary A
(τ, sL, )-breaks the k-sum problem if it runs in time at most τ,
uses lists L1, . . . , Lk each containing sL elements, and solves
the k-sum problem with probability Advk-sum
(A) ≥ .
Zq
For any parameters k and n, Wagner [Wag02] deﬁnes the
k-tree algorithm that (τ, sL, )-breaks the k-sum problem on
n-bit long list elements for τ ∈ O(k · 2n/(1+lg k)), sL =
2n/(1+lg k) and  some non-negligible function. The k-tree
algorithm roughly requires to merge k− 1 pairs of sL-element
lists. This means that the 4-sum problem with lists of size
2n/3 can be solved with a non-negligible probability in time
O(2n/3). Furthermore, if k = 2
n then the k-sum problem
n can be solved in sub-exponential time
with lists of size 2
√
√
4The security proof distinguishes two forgery events: In E1, the forger
broke the binding property of the commitment scheme, and in E2,
the
reduction can extract the secret key of the honest signer. It considers two
different reductions, B0 which embeds the DL challenge in the commitment
parameters and simulates signing queries by knowing the honest signer secret
key, and B1 which embeds the DL challenge as the honest signer public key
and simulates signing queries by knowing the backdoor to the commitment
scheme. The DL challenge is solved if E1 occurs with B1 or if E2 occurs
with B0. The proof argues that, because the simulation strategies of B0 and
B1 are indistinguishable, for each event it holds that the difference between
the probabilities that it occurs in reduction B0 and B1 is negligible. However,
while it is true that the forger cannot distinguish between the oracle simulation
strategies of B0 and B1 in a single execution, the events E1 and E2 are
deﬁned based on the joint outputs of multiple rewindings of the forger, which
do depend on the simulation strategy. The events may therefore occur with
non-negligibly different probability in both reductions, invalidating the proof.
√
n). The analysis of the k-tree algorithm by Minder
O(22
and Sinclair [MS09] suggests that  ≈ 1/4. Some further
improvements to the k-tree algorithm are provided by Nikoli´c
and Sasaki [NS15].
4.2 Attack on CoSi
We state the reduction from the unforgeability of CoSi to
the k-sum problem, and discuss the implications of our result
to the choice of CoSi parameters.
(cid:6)
∗
=
(cid:6)
∗
=
∗
, s
∗
+sk ) =
+sk ). Let h = g
k−1
i=1 ri+c
∗·(sk∗