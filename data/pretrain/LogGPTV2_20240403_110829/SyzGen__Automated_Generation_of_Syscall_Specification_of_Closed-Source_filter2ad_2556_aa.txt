title:SyzGen: Automated Generation of Syscall Specification of Closed-Source
macOS Drivers
author:Weiteng Chen and
Yu Wang and
Zheng Zhang and
Zhiyun Qian
SyzGen: Automated Generation of Syscall Specification
of Closed-Source macOS Drivers
Weiteng Chen
University of California, Riverside
Riverside, California, USA
Zheng Zhang
University of California, Riverside
Riverside, California, USA
Yu Wang
Didi Research America
Mountain View, USA
Zhiyun Qian
University of California, Riverside
Riverside, California, USA
ABSTRACT
Kernel drivers are a critical part of the attack surface since they con-
stitute a large fraction of kernel codebase and oftentimes lack proper
vetting, especially for those closed-source ones. Unfortunately, the
complex input structure and unknown relationships/dependencies
among interfaces make them very challenging to understand. Thus,
security analysts primarily rely on manual audit for interface re-
covery to generate meaningful fuzzing test cases. In this paper,
we present SyzGen, a first attempt to automate the generation of
syscall specifications for closed-source macOS drivers and facilitate
interface-aware fuzzing. We leverage two insights to overcome the
challenges of binary analysis: (1) iterative refinement of syscall
knowledge and (2) extraction and extrapolation of dependencies
from a small number of execution traces. We evaluated our ap-
proach on 25 targets. The results show that SyzGen can effectively
produce high-quality specifications, leading to 34 bugs, including
one that attackers can exploit to escalate privilege, and 2 CVEs to
date.
CCS CONCEPTS
• Security and privacy → Vulnerability scanners; Operating
systems security.
KEYWORDS
fuzzing, operating system security, vulnerability analysis
ACM Reference Format:
Weiteng Chen, Yu Wang, Zheng Zhang, and Zhiyun Qian. 2021. SyzGen:
Automated Generation of Syscall Specification of Closed-Source macOS
Drivers. In Proceedings of the 2021 ACM SIGSAC Conference on Computer
and Communications Security (CCS ’21), November 15–19, 2021, Virtual Event,
Republic  of  Korea.  ACM,  New  York,  NY,  USA,  15  pages.  https://doi.org 
/10.1145/3460120.3484564
1 
According to syzbot [5], Google’s Linux kernel fuzzing platform,
2,854 bugs have been found in the Linux upstream kernel in just
under four years of deployment. This translates to 3 bugs per day on
INTRODUCTION
This work is licensed under a Creative Commons Attribution International 4.0 
License.
CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea
© 2021 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-8454-4/21/11.
https://doi.org/10.1145/3460120.3484564
average, demonstrating the tremendous success of its underlying
kernel fuzzing system, namely Syzkaller [25]. More importantly, ac-
cording to the report [24] from Google and some prior research[30],
the majority of Linux bugs reported are attributed to drivers as they
contribute to a large portion of the codebase and oftentimes are less
tested, indicating a critical attacking surface. It is no different from
Apple’s operating systems. There were 74 CVEs related to Apple
drivers, accounting for approximately one-third of all 231 reported
Apple kernel vulnerabilities from iOS 8 through iOS 13.4.1 [7].
The key to the success of kernel fuzzing hinges on a fuzzer’s
ability to generate diverse and interesting test cases that exercise
various corner cases relatively deep in the kernel. Today, this is
largely accomplished through syscall specifications that are typi-
cally manually crafted by experts. For example, Syzkaller, the state-
of-the-art kernel fuzzer, supports templates that encode the in-
formation regarding syscalls that can be invoked against specific
kernel modules. More specifically, they contain two types of infor-
mation about syscalls: (1) The structures and constraints of syscall
arguments, i.e., type, value ranges, and the relationship between
fields. Without such knowledge, the input generated by a fuzzer will
likely be rejected by the kernel as driver-specific sanitization will be
performed on untrusted input from userspace. (2) Dependencies
between syscalls. This is crucial because a kernel module maintains
its internal states: successful execution of syscalls usually require
the right sequence of invocation (i.e., implicit dependence or
ordering dependence) and/or correctly passing a ‘handler’ (e.g.,
file descriptor) returned from the kernel to a syscall (i.e., explicit
dependence or value dependence) [14]. Missing explicit depen-
dencies can be especially detrimental because key functionalities
of a kernel module would become unreachable, i.e., it is unlikely a
fuzzer can generate a random value that happens to match a specific
‘handler’ returned by previous syscalls.
Unfortunately, the process of curating templates is tedious and
labor-intensive, often requiring a deep understanding of the corre-
sponding module. As a result, in practice, templates are incomplete
and lead to sub-optimal fuzzing results. Indeed, from tracking the
history of templates maintained by Syzkaller [6] over the years,
there are a large number of additions and corrections to improve
the quality.
Despite the challenge, there has been recent work on automating
the generation of syscall templates. Specifically, DIFUZE [9] was
proposed to statically analyze the source code of a Linux kernel
module to infer the structure and constraints of syscall arguments,
based on how the arguments are copied and used in the module. In
Session 3B: Operating Systems CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea749addition, it also compiles a list of hard-coded explicit dependencies
in kernel modules.
In this project, we take on an ambitious goal to automatically
generate syscall templates for closed-source drivers on macOS. There
are several unique challenges in achieving the goal. First, unlike
the core kernel’s syscalls which are well-documented to support
application development, drivers’ syscalls are generic and yet have
vastly different functionalities depending on the underlying driver-
specific implementation. For example, IOConnectCallMethod in
macOS (or its counterpart ioctl in Linux) is a generic syscall that
takes a void* argument to communicate with any driver. Second,
since we target closed-source drivers, it is much more difficult to
recover information regarding syscall arguments and dependencies
among syscalls (e.g., lack of type, inlined functions). This also means
that we cannot directly apply the recent work [9] that statically
analyzes the source code of Linux kernel modules to automated
specification generation.
To overcome the challenges, we present SyzGen, driven by two
key insights: (1) Iterative refinement. Templates can be generated
and refined over time instead of being curated in one shot. This
allows us to overcome the challenge of having to precisely analyze
the whole binary-only driver. Instead, we can sample various ex-
ecution paths and combine the knowledge from each. (2) Explicit
dependencies can be extracted and extrapolated based on a small
number of execution traces. This allows us to map out the explicit
dependencies that we may not have seen in the past, creating much
more complete templates.
In summary, we make the following contributions:
SyzGen is the first to automate the generation of syscall specifica-
tions for closed-source macOS drivers and facilitate interface-aware
fuzzing. We evaluated our tool against 25 targets without source
code and discovered 34 bugs, 2 of which have been assigned CVE
numbers so far. We also observed that SyzGen could identify 271
explicit dependencies and produce high-quality specifications by
measuring the code coverage, demonstrating the effectiveness of
our explicit dependence inference and interface recovery.
• Interface-aware fuzzing of binary-only drivers. We devel-
oped SyzGen capable of automatically extracting both structures/-
constraints of syscalls and explicit dependencies between syscalls,
given a specific macOS driver. We released the source code of
our prototype to facilitate the reproduction of results and future
research: https://github.com/seclab-ucr/SyzGen_setup.
• Novel techniques. We leveraged two insights to get around the
challenges in binary analysis: (1) iterative refinement of syscall
knowledge and (2) extraction and extrapolation of explicit de-
pendencies from a small number of execution traces.
• Promising experimental results. We evaluated SyzGen against
25 targets on macOS and found 34 bugs, 2 of which have been
assigned CVE numbers so far.
2 BACKGROUND AND RELATED WORK
In this section, we will give some brief background on the internal
structure of macOS drivers, which are the main targets of this
paper, and introduce prior work to explain the challenges we must
overcome.
Figure 1: The internal structure of drivers and its interface.
2.1 MacOS Device Drivers
Similar to Linux, MacOS provides a few generic syscalls such as
IOServiceOpen and IOConnectCallMethod through which a user-
space application can interact with a driver. Specifically, each driver
can expose a few services through specific service names (hard-
coded strings), each of which in turn can have a few user clients
providing different functionalities. Note that user clients reside in
kernel space and are part of the drivers. Fig. 1 depicts the typical
communication process for an application to interact with a kernel
driver. Any user application that wishes to connect to a service
must firstly invoke IOServiceOpen (first argument service speci-
fies which). Then the second argument type, an unsigned 32-bit
integer, is interpreted by the service 1 to instantiate a correspond-
ing user client object responsible for subsequent communication
between the user application and service. Upon a successful invo-
cation, a connection handler is returned to the caller which can
be used to locate the user client object in kernel. Any request
that the application sends to the driver will be made by calling
IOConnectCallMethod() (the main syscall) that takes this connec-
tion as the first parameter.
As shown in Fig. 1, IOConnectCallMethod() is a generic syscall
that can take any complex data structures, and is implemented differ-
ently by each driver. The second parameter selector is commonly
known as the “command identifier” to determine which operation
the user client would perform. The rest eight parameters are used
to pass inputs and gather outputs. Specifically, inputValues con-
tains integer-only inputs and inputCount determines the number
of elements in inputValues. In contrast, inputStruct can contain
arbitrary types of inputs (as its type is void*), and its size is speci-
fied in inputStructSize. The four output parameters are similar
in nature compared to the input ones. We refer to the collection
of functionalities corresponding to a specific command identifier
value as an interface. The separation of interfaces follows the con-
vention of Syzkaller templates and allows the different interfaces
to be treated differently as will be shown later.
1It may be omitted by the driver if there is only one user client to serve.
IOServiceOpen(service, owningTask, type, &connection)ApplicationService DriverSpawn a UserClient object according to typereturn connection handler representing the corresponding UserClient object in kernelIOConnectCallMethod(        io_connect_t         connection,        uint32_t                 selector,        const uint64_t*      inputValues,        uint32_t                 inputCount,        const void*            inputStruct,        size_t                     inputStructSize,        uint64_t*                outputValues,        uint32_t                 outputCount,        void*                      outputStruct,        size_t*                    outputStructSize)Call diﬀerent functionalities according to the inputSession 3B: Operating Systems CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea750There are a few interesting things we wish to point out. First, to
conduct any meaningful fuzzing, it is critical to infer the mapping
for each interface between the value of a command identifier and the
rest of the arguments (input or output). Second, even though there
is a convention, drivers can interpret the inputs in any way they
choose, and the command identifier does not necessarily need to be
passed as the second argument (i.e., selector). It can be embedded
in one of the parameters labeled as inputs. Finally, interfaces can
have dependencies on each other. New and interesting code can be
revealed only when a test case exercises a dependence by invoking
multiple interfaces with the correct arguments.
2.2 Kernel Fuzzing
Coverage-guided fuzzing [32] is now the de facto standard for test-
ing and bug finding in the industry due to its efficacy in discovering
complex vulnerabilities without false positives. The unique aspect
of kernel fuzzing is that the input is comprised of a sequence of
syscalls, involving complex arguments and dependencies. To ad-
dress the challenge, the state-of-the-art kernel fuzzer Syzkaller [25]
was developed to allow developers to encode the knowledge of
syscalls in the form of templates.
Below we summarize the recent efforts on interface recovery
assisting kernel fuzzing. Specifically, we list their characteristics in
Table 1.
Interface Recovery without Dependence Inference. DIFUZE [9],
dedicated to recovering interfaces of Linux drivers, is the most
relevant work. It conducts a static analysis to retrieve command
identifiers and their corresponding input structures. However, it
requires source code to extract the structure definition and thus
can not be applied to closed-source kernel modules including ma-
cOS drivers. Moreover, it only conducts static range analysis to a
certain argument (i.e., ioctl’s command identifier) to refine
the syscall templates. It also fails to extract complex relationships
between fields of structures (e.g., a length field specifies the size of a
buffer) and dependencies between syscalls (other than a hard-coded
list), which impedes the fuzzer from exploring deeper and more
interesting code.
Regarding closed-source macOS drivers, there is a small tool,
p-joker [28], which was developed in the industry [3] to recover the
interface of some drivers. The idea is based on some common pro-
gramming pattern in macOS where command identifiers are often
used as indices into function dispatch tables to locate the correspond-
ing handler function. Following Apple’s guidelines, developers
can encode the required values for inputCount, inputStructSize,
outputCount, and outputStructSize in such dispatch table, which
would be enforced by the kernel. p-joker also extracts the informa-
tion to facilitate fuzzing. Unfortunately, this is not the only way a
command identifier is used. In addition, the tool is unable to recover
types and other constraints of the arguments associated with the
command identifier.
Interface Recovery with Dependence Inference. As opposed
to structure recovery, IMF [14] works on general syscall interfaces of
which the argument types are well documented. IMF rather focuses
on mutating the value of arguments in a black-box manner, without
an understanding of their valid ranges and does not attempt to
generate syscall templates. In addition, it also attempts to infer the
dependence between syscalls by analyzing existing syscall traces
generated by applications. Intuitively, it preserves the order of
syscall sequences to produce a fuzzing harness, and infer the explicit
dependence by checking the identical value pairs from the input
and output of syscalls. Similarly, Moonshine [21] relies on traces to
infer explicit dependence and implicit dependence. However, both
schemes cannot be directly applied to macOS drivers where the
interface argument type is generic (void*). Furthermore, none of
the approaches attempts to extrapolate dependencies beyond the
traces that have been observed, and thus the quality of the inferred
dependencies is heavily dependent on the applications that may
exercise various functionalities of the corresponding kernel module
to various degrees.
A more recent work dubbed HFL [16], a hybrid Linux kernel
fuzzer, employs concolic execution to monitor every possible read
and write pairs along the execution of a sequence of syscalls in a
given test case to find dependencies, which is unfortunately not
very scalable and challenging in practice because it needs to drive
the execution perfectly to exercise both of the read and write. In
contrast, SyzGen is much more realistic as it requires the analysis
of a single interface only by generalizing the knowledge gathered
from prior dependencies (see §4.3). In addition, HFL requires source
code to conduct static analysis for instrumentation and points-to
relationship, and such analysis is much less precise on binaries.
Type Recovery. To support fuzzing, type inference is necessary
but not a strong requirement. For example, it is important to differ-
entiate a pointer from non-pointer types, and string (char array)
from other array types. However, it is not critical to differenti-
ate unsigned from signed integer, as long as we know what value
is interesting and allows more coverage. As a result, we borrow
ideas from the rich literature on reverse engineering of variable
types in binary programs [10, 17, 19]. Tupni [10] leverages dynamic
analysis to recover input formats based on the usage of input. RE-
WARDS [19] proposes to propagate type information based on “type
sinks”, which are calls to functions with known type signatures
(e.g., a library call). In contrast, TIE [17], a static analysis based
approach, proposes a principled type inference system that could
generate type constraints based upon how the binary code is used
and then deduce the actual types. Our type recovery method is
similar to Tupni [10] but is simpler due to the lower requirement.
Other kernel fuzzing work. In addition to the above, we have
seen several other related works in recent years. Moonshine [21]
improves syzkaller by distilling seeds of high quality from existing
testing suites. JANUS [31], specific to fuzz file system, extends
the attacking surface to disk image of which metadata could be
malicious and thus leads to vulnerabilities that are neglected by
other fuzzers. Similarly, PeriScope [23] is tailored to detect driver
vulnerabilities reachable from the hardware side as opposed to the