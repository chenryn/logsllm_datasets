title:DoubleX: Statically Detecting Vulnerable Data Flows in Browser Extensions
at Scale
author:Aurore Fass and
Dolière Francis Som&apos;e and
Michael Backes and
Ben Stock
DoubleX: Statically Detecting Vulnerable Data Flows
in Browser Extensions at Scale
Aurore Fass, Dolière Francis Somé, Michael Backes, and Ben Stock
CISPA Helmholtz Center for Information Security
{aurore.fass,doliere.some,backes,stock}@cispa.de
Abstract
Browser extensions are popular to enhance users’ browsing experi-
ence. By design, they have access to security- and privacy-critical
APIs to perform tasks that web applications cannot traditionally do.
Even though web pages and extensions are isolated, they can com-
municate through messages. Specifically, a vulnerable extension
can receive messages from another extension or web page, under
the control of an attacker. Thus, these communication channels
are a way for a malicious actor to elevate their privileges to the
capabilities of an extension, which can lead to, e.g., universal cross-
site scripting or sensitive user data exfiltration. To automatically
detect such security and privacy threats in benign-but-buggy exten-
sions, we propose our static analyzer DoubleX. DoubleX defines
an Extension Dependence Graph (EDG), which abstracts extension
code with control and data flows, pointer analysis, and models the
message interactions within and outside of an extension. This way,
we can leverage this graph to track and detect suspicious data flows
between external actors and sensitive APIs in browser extensions.
We evaluated DoubleX on 154,484 Chrome extensions, where it
flags 278 extensions as having a suspicious data flow. Overall, we
could verify that 89% of these flows can be influenced by external
actors (i.e., an attacker). Based on our threat model, we subsequently
demonstrate exploitability for 184 extensions. Finally, we evaluated
DoubleX on a labeled vulnerable extension set, where it accurately
detects almost 93% of known flaws.
CCS Concepts
• Security and privacy → Web application security; Browser
security.
Keywords
Web Security, Browser Extension, JavaScript, Vulnerability Detec-
tion, Static Analysis, Data Flow Analysis
ACM Reference Format:
Aurore Fass, Dolière Francis Somé, Michael Backes, and Ben Stock. 2021.
DoubleX: Statically Detecting Vulnerable Data Flows in Browser Extensions
at Scale. In Proceedings of the 2021 ACM SIGSAC Conference on Computer
and Communications Security (CCS ’21), November 15–19, 2021, Virtual Event,
Republic of Korea. ACM, New York, NY, USA, 16 pages. https://doi.org/10.
1145/3460120.3484745
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea
© 2021 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-8454-4/21/11...$15.00
https://doi.org/10.1145/3460120.3484745
1 Introduction
The Web has become a popular ecosystem used by billions of peo-
ple every day. To extend their browser functionality, users install
browser extensions. For the most popular desktop browser Chrome
(with a market share of 67% [78]), there are almost 200,000 ex-
tensions, totaling over 1.2 billion installs [26]. While some ex-
tensions merely customize user browser interface, others serve
more security- and privacy-critical tasks, e.g., to be effective, an
ad-blocker needs to modify web page content or intercept network
requests. To achieve this, and contrary to regular JavaScript in web
pages, extensions have privileged capabilities, such as downloading
arbitrary files or accessing arbitrary cross-domain data.
Given their elevated privileges, extensions attract the interest
of attackers [1, 35, 39, 81, 82]. Still, Google engineers are actively
working on detecting such malicious extensions in their store. In
February 2020, they removed 500 extensions that were exfiltrating
user data [41]; in April 2020, 49 additional extensions that were
hijacking users’ cryptocurrency wallets [42]; in June 2020, an ex-
tra 70 spying extensions [48]; and, in December 2020, extensions
redirecting to phishing websites [43]. In addition, before being pub-
lished, extensions are reviewed by Chrome’s vetting system to flag
extensions requiring many or powerful privileges for further analy-
ses [16] and to directly detect the ones that may contain or spread
malicious software. This process makes it harder to have malicious
extensions in the store today.
Still, malicious extensions represent only a fraction of the ex-
tensions that may lead to security or privacy issues. In fact, an
attacker can also abuse vulnerable extensions to elevate its priv-
ileges through the capabilities of an extension. To this end, an
attacker can leverage an extension’s communication channels to
send payloads to this extension, tailored to exploit its vulnerabilities.
Such vulnerabilities can lead to, e.g., universal cross-site scripting
(XSS) (i.e., the ability to execute code in every website even without
a vulnerability in the site itself) or sensitive user data exfiltration.
Due to their inherently benign intent, these vulnerable extensions
are more challenging to detect than malicious ones, e.g., as they are
not doing anything suspicious. Furthermore, even though they do
require powerful privileges, their benign nature allows them to pass
the review process. While some previous works have focussed on
vulnerable extensions, they were either purely formal [7], specific
to the deprecated Firefox XPCOM [52] infrastructure [5, 6], or based
on primarily manual analysis [8]. To the best of our knowledge,
only EmPoWeb from Somé [72] focuses on analyzing extensions’
susceptibility to attacks through external messages at scale. In prac-
tice, though, his work is based on a lightweight call graph analysis
and yields an extremely high number of reported extensions to
manually vet: of the 66k Chrome extensions analyzed, it flagged
3.3k as suspicious, and 95% of them were false alarms. In fact, we
Session 6B: Web VulnerabilitiesCCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1789currently lack a precise analyzer to perform an analysis at scale
and limit the number of extensions falsely reported as vulnerable
so as to cut down the manual effort.
In this paper, we introduce our static analyzer DoubleX, which
relies on an advanced data flow analysis to accurately track data
from and toward security- and privacy-critical APIs in extensions.
In particular, due to its entirely static character, DoubleX has com-
plete coverage of the available code. Specifically, we propose a
semantic abstraction of extension code, including control and data
flows, and pointer analysis. In addition, DoubleX models inter-
actions between extension components with a message flow. We
refer to the resulting structure as the Extension Dependence Graph
(EDG). DoubleX then leverages the EDG to detect external mes-
sages coming from web pages or extensions and flags them as
attacker-controllable. At the same time, it collects security- and
privacy-critical APIs in browser extensions. Finally, DoubleX per-
forms a data flow analysis to identify any path between external
actors (i.e., an attacker) and these sensitive APIs. DoubleX summa-
rizes its findings in fine-grained data flow reports.
We analyzed 154,484 Chrome extensions, 278 of which we flagged
as having externally controllable data flows or exfiltrating sensitive
user information. For those, we could verify that 89% of the data
flows can be influenced by an attacker, which highlights DoubleX
precision. In addition, we detected 184 extensions (with 209 vul-
nerabilities) that are exploitable under our threat model, leading
to, e.g., arbitrary code execution in any website. Also, we evalu-
ated DoubleX recall on a ground-truth vulnerable extension set,
where it accurately flags 92.64% of known vulnerabilities. Finally,
DoubleX is fast and can analyze 93% of our extension set in less
than 20s per extension, with a median time of 2.5s, highlighting its
practicability for an accurate analysis at scale.
To sum up, our paper makes the following contributions:
• We introduce our static analyzer DoubleX to analyze browser
extensions at scale. Specifically, we define an Extension Depen-
dence Graph (EDG), which provides a semantic abstraction of
extension code (including control and data flows, and pointer
analysis) and models message interactions within and outside of
an extension.
• We leverage the EDG to perform a data flow analysis to track data
from and toward security- and privacy-critical APIs in browser
extensions.
• We perform a large-scale analysis of Chrome extensions and
identify 184 vulnerable extensions. In addition, we highlight
DoubleX precision (89% verified dangerous data flows) and recall
(detection of 92.64% of known vulnerabilities).
• For reproducibility, follow-up work, and practical detection of
suspicious external data flows in specific APIs of browser exten-
sions, we make DoubleX publicly available [27].
2 Browser Extensions
Browser extensions are third-party programs, which users can
install to extend their browser functionality, e.g., by adding ad-
blocking capabilities or better integration with shopping sites. In
this section, we first present the extension architecture with a
highlight on security mechanisms extensions implement. Then, we
focus on the message-passing APIs they use to communicate.
Figure 1: Extension architecture
2.1 Architecture and Security Considerations
By design, extensions have access to privileged APIs and features.
Contrary to JavaScript in web pages, which is restricted by the Same-
Origin Policy (SOP) [59], extensions can access arbitrary cross-
domain in the logged-in context of the user’s browser and inject
code into any document. Due to their elevated privileges, extensions
may introduce security and privacy threats and put their user base
at risk. To limit those risks, extensions only have access to the
permissions explicitly declared in their manifest.json [14, 57]. Such
permissions include the possibility for an extension to read/write
user data on any or specific web pages (host), to store/retrieve data
from the extension storage (storage), to download arbitrary files
(downloads), or to access users’ browsing history (history).
As represented in Figure 1, an extension is divided into four
main components. The core logic of an extension is implemented
through a background page (or background scripts),1 which runs
independently of the lifetime of any particular web page or browser
window. Through the background page, or if defined in the mani-
fest, an extension can inject content scripts to run along with web
applications. These content scripts can use the standard DOM APIs
to read and modify web pages and have access to localStorage,
similarly to the scripts loaded by web pages. UI pages enable users
to customize an extension’s behavior, e.g., over different options,
settings, or pop-ups. Finally, through definition in the manifest,
an extension can expose Web Accessible Resources (WARs), e.g.,
scripts to be executed on every page. While the highly privileged
background page, UI pages, and WARs have access to the full ex-
tension’s capabilities, the less privileged content scripts only have
access to the host2 and storage permissions.
2.2 Message Passing in Extensions
To communicate with web pages and other extensions, an extension
relies on message passing. In this section, we present the communi-
cation channels between a web page and each extension component,
within an extension, and between two extensions. Figure 2 shows
an overview of the message-passing APIs.
Web Page - Content Script — Web pages and content scripts
communicate over regular postMessages [62] (similarly to the com-
munication between two web pages). Likewise, to receive messages,
they use the addEventListener or onmessage API [55, 61], as shown
1Replaced with service workers, for Chrome Manifest V3 [19]
2Starting with Chrome Manifest V3, content scripts are subject to the same request
rules as the page they are running within [23]
Session 6B: Web VulnerabilitiesCCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1790/ / Web page code
1
2 window.postMessage ( " Hi CS " ,
3
4
5 window.onmessage = f u n c t i o n ( event )
6
7
r e c e i v e d = e v e n t . d a t a ;
/ / Content
s c r i p t
" ∗ " ) ;
code
}
{
/ / Sends
/ /
r e c e i v e d = " Hi CS "
1
2
3
4
5
6
7
8
9
10
11
Figure 2: Extension message-passing APIs
in Listing 1 (orange and blue refer to receiving and sending mes-
sages, respectively). By default, content scripts receive all messages
sent toward the window in which they are injected. Thus, if a web
page running a content script receives a postMessage from another
page, the content script’s handler is also invoked.
Content Script - Background Page — There are two types of
APIs to exchange messages between a content script and a back-
ground page. The one-time requests API aims at sending a single
message and receiving a response. In contrast, long-lived connec-
tions leverage an established message port and stay open to ex-
change multiple messages [18]. As shown in Figure 2, the con-
tent script uses runtime.sendMessage (one-time) or runtime.connect
(long-lived) to send messages.3 Similarly, the background page
sends requests with tabs.sendMessage (one-time) or tabs.connect
(long-lived). In both cases, the last parameter of these APIs can be
a callback to access the response sent by the other component (for
Firefox, these APIs can return a Promise [58] instead of invoking a
callback). As for receiving messages (and responding), both compo-
nents register a listener: runtime.onMessage.addListener (one-time)
or runtime.onConnect.addListener (long-lived). Listing 2 illustrates
Chrome one-time requests.
Web Page - Background Page — For Chromium-based exten-
sions, a web application and a background page can directly com-
municate under two assumptions [18]. First, the extension should
fill the externally_connectable field in its manifest with specific
URLs, to allow the communication with the corresponding web
pages only. Second, the communication can only be initiated by the
web application. As presented in Figure 2, the web application sends
requests (and gets a response) with runtime.sendMessage (one-time)
or runtime.connect (long-lived). The background page receives mes-
sages (and responds) with runtime.onMessageExternal.addListener
(one-time) or runtime.onConnectExternal.addListener (long-lived).
We give an example in Listing 6 in the Appendix.
3For legibility reasons, we omit browser/chrome from the APIs, which would be,
e.g., chrome.runtime.sendMessage or browser.runtime.sendMessage
Listing 1: Messages: web page - content script
s c r i p t
/ / Content
chrome.runtime.sendMessage ( " Hi BP " ,
c s R e c e i v e d = r e s p o n s e . f a r e w e l l ;
/ /
} ) ;
code
f u n c t i o n ( response )
{
c s R e c e i v e d = " Bye CS "
/ / Background page code
c h r o m e . r u n t i m e . o n M e s s a g e . a d d L i s t e n e r (
f u n c t i o n ( request ,
bpReceived = r e q u e s t ;
sendResponse ( { f a r e w e l l :
" Bye CS " } ) ;
sender ,
sendResponse )
{
/ / bpReceived = " Hi BP "
} ) ;
Listing 2: Messages: content script - background page
Case of UI Pages and WARs — Like the background page, UI
pages and WARs are part of the extension core. To exchange mes-
sages with the content scripts or with a web page, they use the
same APIs as those used by the background page, respectively. As
WARs can be injected as iframes in web pages, WARs also lever-
age the same APIs as the content scripts to interact with a web
page. Figure 1 summarizes the three sorts of messages used by the
extension components, while Figure 2 presents the specific APIs.
Extension A - Extension B — Finally, two extensions can com-
municate. In this case, the message-passing APIs are the same as
those for the communication between a background page and a web
application. Still, contrary to the communication with a web page,
communication is enabled by default with all extensions [15]. To
interact with specific extensions only, an extension must explicitly
declare the IDs of allowed extensions in its manifest.
3 Threat Model
Browser extensions can interact with web pages and other exten-
sions. By design, malicious actors can send specific messages to a
vulnerable extension, tailored to exploit its flaws. Given extensions’
elevated privileges, attackers could gain the following capabilities:
• Code execution: attackers can execute arbitrary code in the ex-
tension (or content script) context. For example, through eval, they