we use the code rate of 2/3 since it has the highest compression ratio,
and hence we can reduce the length of the input bits required for an
output sequence of given length. We also make several observations
as follows. The bit inter-leaver in WiFi has an internal period of
13 and the same bit location in different cycles corresponds to the
same or nearby subcarriers. So, important bits always appear in the
same region in each cycle. We also found that the polynomials for
the convolutional coder used in WiFi are chosen in such a way that
we can design an algorithm to guarantee that at most 1/3 of bits
will be flipped when we compare an arbitrary sequence with its
reconstruction after decoding and encoding it with the code rate
of 2/3. Specifically, we divide the original sequence into groups of
39 bits. For the first 13 bits, we pre-generate a lookup table of all
possible 12-bit candidates that result in a given 9-bit pattern from
bit 5 to 13. Because of the well-designed WiFi codebook, any 9-bit
pattern has, and only has, eight 12-bit candidates and their first
3 bits are distinct. Note that in the normal process of continuous
encoding, bit 0 to 13 are generated by feeding 9 bits into an encoder.
We keep track of the last 3 bits of the decoded sequence we have
so far (or use zeros for initialization). We select the candidate that
has the same first 3 bits as these 3 bits and the remaining 9 bits
are the decoded sequence for bit 0 to 13. These 12 bits together
guarantee that bit 5 to 13 of the reconstructed sequence will not
flip while the first 3 bits ensure that the solution for bit 0 to 13 is
compatible with the sequence decoded in the last round. We use
similar processes to decode bits 14–25 and bits 26–38. This solution
guarantees that, after reconstruction/encoding, 2/3 of bits will not
flip and bit-flips will only occur near the front for each 13-bit cycle.
Using this algorithm, bit-flips can only happen on subcarriers -28 to
480
-8, and hence we can use it for generating Bluetooth packets with
a positive frequency shift, and it guarantees that important bits
will never flip. For negative frequency shifts, we devise a similar
algorithm so that bit-flips can only occur on subcarriers 8 to 28.
Table 1: Weight assignment for the Viterbi algorithm.
Bit Mapped Location Wt.
Bit Mapped Location
1000
9
0
1
10
1000
Subcarrier 12, bit 5
Subcarrier 16, bit 3
Wt.
1
1
Subcarrier -28, bit 5
Subcarrier -24, bit 3
.
.
.
Subcarrier 3, bit 3
7
11
12
1
100
Subcarrier 20, bit 4
Subcarrier 25, bit 5
.
.
.
100
1
Subcarrier 8, bit 4
8
2.8 Scrambler
The feasibility of our solution depends on whether the mapping
from the bit-stream to the IQ waveform is deterministic. The only
operation in the WiFi Tx chain that might not be deterministic is the
scrambling of bits as the standard suggests use of a “pseudorandom
nonzero initial state.” For testing and certification, however, the
seed (i.e., the initial state of the scrambler) can usually be set to a
constant by drivers, although public information on how to do it is
very limited and not documented well. The datasheet and register
map of almost all WiFi chips are not available without signing NDAs.
We found that major vendors, such as Broadcom and Qualcomm,
provide functions or register definitions in their drivers to set the
scrambler seed to a constant. By capturing the radio signals, we
also found that Realtek chips use fixed scrambler seeds, although
the exact values are different for different chip generations (802.11n
and 802.11ac).
Since the inverse of an XOR operation is simply the same XOR
operation, we can obtain the de-scrambled bit-stream by applying
the same scrambler with the same scrambler seed as that used in
the WiFi chip.
3 IMPLEMENTATION
We have implemented BlueFi using Python and real, commercial
off-the-shelf WiFi chips. We test the performance of using a GL-
AR150 WiFi router, which is equipped with an (Qualcomm) Atheros
AR9331 802.11n-compliant SoC and is pre-loaded with OpenWrt
[10]. The AR9331 belongs to Atheros’s widely-adopted ath79 prod-
uct family. OpenWrt supports at least 272 routers with ath79 chips
[11]. BlueFi does not use any OpenWrt-specific features. We use
OpenWrt because its source code is available and we can modify
the driver code (ath9k) for the ath79 chip.
We also test the performance of using a TP-Link T2U Nano
WiFi NIC. At its core, T2U Nano uses the RTL8811AU chip from
Realtek. The Realtek RTL88xx device family is popular among WiFi
device makers and dominates the market of USB NICs. Although
RTL8811AU supports 802.11ac, we did not use any of the 802.11ac
modes. We chose this chip mainly because it is cheap and has better
driver support in Linux.
The generation and transmission of a BlueFi packet starts in the
user space. BlueFi first gathers Bluetooth payload. We use 30 bytes
of data with 6 bytes of address as the payload. We use Python to
implement the process described in Sec. 2. The Scipy library [12] is
used for FFT computation. We also implement the modified Viterbi
algorithm where the optimization takes the weight of each bit into
consideration. The final results, in the form of WiFi packets, are
sent to the WiFi hardware for transmission.
The required total number of bytes to be sent by WiFi hardware
is in the range of a few thousand bytes, which is much smaller
than the PSDU limits of 65,535 bytes defined in the WiFi physical
layer (PHY) standard. We found that the Linux kernel typically frag-
ments packets with the size exceeding the limit of an MPDU (2,304
bytes) or the MTU of Ethernet (1,500 bytes). Because of these limi-
tations, BlueFi directly sends packets in the driver layer. BlueFi
can support very long Bluetooth packets (even the longest, optional
5-time-slot packets) after driver modification. For AR9331, the trans-
mission starts in the user space and packets are sent to the ath9k
driver in the kernel space via netlink. A callback function will be
invoked and set the transmit parameters such as MCS, SGI before in-
voking the normal transmit function in the driver. For RTL8811AU,
we first remove the hard-coded limit of 2,304 bytes. (This does not
affect normal WiFi traffic since Linux kernel fragments outgoing
packets.) Packets are sent to the driver via a character driver in-
terface. The driver then fills transmit parameters and sends the
packets to hardware.
For the best performance, the value of the scrambler seed needs
to be known. For Atheros chips, [13] suggests that similar to ath5k
devices, the scrambler seed of earlier ath9k chips can be set to a con-
stant of 1 by clearing the GEN_SCRAMBLER bit in the PHY_CTL
register. However, we found that AR9331 uses an almost entirely
different register map. We solved this problem by finding the new
location of the register, which is not mentioned anywhere in the
datasheet or the driver code. Alternatively, it is possible to deter-
mine the scrambler seed without setting registers since scrambler
seeds are predictable (increment by 1 in Atheros’s implementation)
in most WiFi chips [14, 15]. Fixing the seed has no effect on normal
WiFi operation and Realtek chips already use a constant by default.
We find this constant (71 for RTL8811AU) by decoding the WiFi
signals it sends.
4 EVALUATION
4.1 Experimental Setup
We use an iPhone, a Google Pixel and a Samsung S6 (Edge) as Blue-
tooth receivers. We use the nRF Connect app [16] on the iPhone
and the Beacon Scanner [17] app on Android devices. We measured
the signal strength under various conditions for 2 minutes, which
is the default measuring duration of nRF Connect. For the BlueFi
transmitter, the majority of tests are done on the GL-AR150 WiFi
router as this represents the typical use-case (leveraging WiFi in-
frastructure for beacons) we envision. We can control (start/stop) or
modify BlueFi packets remotely via SSH from either the Internet
(e.g., cloud servers), local Ethernet or WiFi. To show that BlueFi is
vendor-agnostic, we also test it on RTL8811AU. Both AR9331 and
RTL8811AU can independently send BlueFi packets regardless of
whether there is any connection to a station or AP or not.
Since the 2.4GHz spectrum is very crowded and there are at
least 2 other APs operating on the same WiFi channel in the test
environment, we expect some interference typical of office envi-
ronments. Except for Sec. 4.3, we use the default transmit power of
AR9331 (18dBm) and RTL8811AU. We did not modify the firmware
481
SIGCOMM ’21, August 23–28, 2021, Virtual Event, USA
of RTL8811AU or the ART (Atheros Radio Test) partition of AR9331,
which is required for regulatory compliance.
4.2 Performance vs. Distance
We place the phones under test near (∼20cm), close (∼1.5m), and
far (4∼5m) from a WiFi transmitter on which BlueFi runs, and
collect the received signal strengths of packets (RSSI) reported by
Bluetooth hardware.
Fig. 5b plots the results of using AR9331, showing that differ-
ent smartphones can receive Bluetooth packets with consistent
performance. Although the measuring duration of nRF Connect
is 2 minutes, the iPhone’s power-saving mechanism kicks in after
approximately 110 seconds elapsed, and therefore iPhone’s traces
are typically 10 seconds short. We observe different RSSI levels
on different phones placed at the same distance. The RSSI of S6 is
generally 6∼10dB less than the counterparts. This is most likely
due to the fact that the underlying Bluetooth chips have different
sensitivity. We observe the same behavior even when dedicated
Bluetooth hardware is used (Sec. 4.4). We found (by transmitting
BlueFi signals using USRP) that smartphones can pick up Blue-
tooth signals of as low as -90 to -100 dBm. Therefore, the margin
is around 10∼20dB, which is theoretically equivalent to 3∼10x in
range. Fig. 5c shows the results of using RTL8811AU under the
same condition. Compared to Fig. 5b, there are some variations
in terms of RSSI, but devices can still steadily receive Bluetooth
packets using BlueFi.
4.3 Performance vs. WiFi Tx Power
OpenWrt provides a convenient way to control the transmit power,
and hence we also measure the received signal strength with respect
to different transmit power levels. We placed the phones 1.5m away
from the WiFi router. Fig. 6 shows the results. The RSSI is very high
on the Pixel and gradually decreases with the transmit power. Even
at the router’s lowest transmit power of 0dBm (=1mW), the RSSI is
still significantly higher than -90dBm. In contrast, such a trend is
not so obvious on S6. Its RSSI values may be more sensitive to the
waveform impairments than to the absolute power. Although the
iPhone’s RSSI shows a similar trend as Pixel’s, it fluctuates more,
which may be the result of multipaths or interference from the
environment.
4.4 Comparison with Bluetooth Hardware
To compare BlueFi with dedicated Bluetooth hardware, we also
measure the performance of using conventional Bluetooth trans-
mitters. Beacon packets are sent using the Beacon Simulator app
[18] on Android. We set the Bluetooth Tx power to high and set the
broadcasting frequency to 10Hz. All other conditions are exactly
the same as those in Sec. 4.3.
The results are plotted in Fig. 7a, where the first two and the
last two columns represent using Pixel and S6 as the transmitter,
respectively. Note that the same fluctuating behavior on iPhone
can be observed here, and hence we conclude that the transmitter
design does not cause such behavior in Sec. 4.3. We can also see that
the RSSI is lower on S6 than on iPhone under the same condition.
Since conditions are exactly the same as those in Sec. 4.3, we
can directly compare Figs. 6 and 7a. At the Tx power of 8dBm, the
performance of BlueFi is found comparable to those of using a
SIGCOMM ’21, August 23–28, 2021, Virtual Event, USA
Hsun-Wei Cho and Kang G. Shin
(a) Experimental setup
Figure 5: Evaluation of BlueFi
(b) AR9331
(c) RTL8811AU
(a) Pixel
(b) S6
(c) iPhone
Figure 6: Performance vs. Transmit power
(a) Using dedicated Bluetooth hardware
(b) WiFi throughput measurements
(c) RSSI with background WiFi traffic
Figure 7: Comparison with dedicated hardware and effect of background WiFi traffic
dedicated Bluetooth chip. Therefore, with WiFi chips that nominally
come with a default Tx power of 18dBm, one could expect better
performance with BlueFi.
4.5 Effect on Concurrent WiFi Traffic
We also evaluate the effect of BlueFi on concurrent WiFi traffic. For
this, we use iPerf3 [19], a standard tool for benchmarking network
throughput. We install iperf3 on the WiFi router and configure it
as an iPerf3 server. We then connect a Ubuntu laptop to the router
over WiFi and run an iPerf3 client on the laptop. We make the
throughput measurements, reported by iPerf3 every second, for
120s.
As shown in Fig. 7b, we test four scenarios. We establish the
baseline by measuring the throughput without any Bluetooth trans-
mission. Then, we run BlueFi on the same WiFi router that also
runs the iPerf3 server simultaneously. For comparison, we also test
the throughput when we use dedicated Bluetooth hardware on
Pixel and S6 instead.
The figure shows the throughput difference in each scenario
to be very small. Although the baseline has the lowest median
throughput, it has the highest average throughput (UL: 48.8Mbps,
DL: 48.7Mbps). With BlueFi, the average throughputs are 47.8Mbps
UL and 47.7Mbps DL, which are only 1Mbps lower than the baseline.
For comparison, using Pixel and S6 yields average throughputs of
48.6/48.6 and 48.4/48.3Mbps, respectively. Note the contention for
airtime is not the only factor that limits the throughput. Since
we send BlueFi packets by the single-core microcontroller in the