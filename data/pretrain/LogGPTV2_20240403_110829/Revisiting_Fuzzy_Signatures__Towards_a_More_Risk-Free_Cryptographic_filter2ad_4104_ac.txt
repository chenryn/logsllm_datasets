4Throughout the rest of the paper we implicitly assume that real numbers are repre-
sented by some pre-determined number of significant digits in order to handle them
on computers.
5If there are multiple vectors y ∈ L satisfying this condition, then we consider some
canonical ordering of the lattice points in L and choose the first one according to the
ordering to make it unique.
Figure 4: Our fuzzy signature scheme ΠDL
indicate the procedure of the verification algorithm.
FS . The gray items
FS.Setup(1κ , F):
1: G ← GGen(1κ)
2: Λ = (Zp , +)
3: ppLS ← LinS.Setup(F, Λ)
= (G, ppLS)
4: return ppFS
FS.Sign(ppFS, x′, M):
2: ((cid:101)c , ˜a) ← Sketch(ppLS, x′)
1: (G, ppLS) ← ppFS
3: r ← Zp
4: β ← H(д ˜a , дr , M)
6: return σFS = (β , z,(cid:101)c )
5: z ← β · ˜a + r
FS.KeyGen(ppFS, x)
1: (G, ppLS) ← ppFS
2: (c , a) ← Sketch(ppLS, x)
3: return vkFS = (дa , c)
FS.Vrfy(ppFS, vkFS, M, σFS)
1: (G, ppLS) ← ppFS
3: (β , z,(cid:101)c ) ← σFS
2: (h, c) ← vkFS
4: ∆a ← DiffRec(ppLS, c ,(cid:101)c )
˜h ← h · д∆a
5:
6: R ← дz · ˜h−β
7: return ⊤ iff β = H( ˜h, R, M)
Figure 5: Construction of fuzzy signature ΠDL
FS .
Efficiency. The verification key consists of one group element in G
and a sketch. The signature consists of two elements in Zp and a
sketch. Notably, the only difference from the Schnorr signature is
the linear sketch component.
4.2 Correctness and Security Proof
Correctness. The correctness of ΠDL
FS
ness is evident from Fig. 4, we omit the proof to App. B.
is provided below. As correct-
Theorem 4.1. If the linear sketch ΠLinS is correct, then the fuzzy
FS in Fig. 5 is ϵ-correct, where ϵ is the error parameter of
signature ΠDL
the fuzzy key setting F .
Security. The security of our fuzzy signature ΠDL
is based on a
FS
variant of the DL problem where the secret exponent is a proxy key
a generated by the linear sketch scheme on input a random fuzzy
data x ← X. The adversary is given the DL instance дa along with
the sketch c. Formally, we define the DL with sketch assumption in
Def. 4.2. We provide detailed discussions in Sec. 5.4 to validate that
the DL with sketch problem is as hard as the standard DL problem
for our specific choice of biometrics and the linear sketch scheme.
Definition 4.2 ( DL with sketch ). Let ΠLinS be a linear sketch
scheme for a fuzzy key setting F = (X,X, AR, Φ, ϵ) with respect to
a (finite) abelian group Λ = (Zp, +). We say the discrete logarithm
problem with sketch (DLsketch) assumption holds (relative to GGen)
if for all PPT adversaries A, the following probability is upper
Session 6D: Authentication and Privacy CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2051{x|y = CVL(x)}. Due to the translational symmetry of a
lattice, we have VRL(y) = VRL(0) + y.6 See Fig. 6 for a
pictorial example of VRL(0).
LinS.Setup(F , Λ = (Zp, +)):
1: UH ← UH
2: return ppLS = (Λ, UH)
DiffRec(ppLS, c, c′):
1: ∆y ← CVL(c − c′)
2: ∆a ← UH(B−1(∆y))
3: return ∆a
Sketch(ppLS, x)
1: y ← дL(x)
2: c ← x − y
3: a ← UH(B−1y)
4: return (c, a)
Mc(ppLS, c, e)
1: c′ ← c + e − дL(c + e)
2: y′ ← дL(c + e)
3: ∆a ← UH(B−1y′)
4: return (c′, ∆a)
Figure 6: The left and right light gray grids depict two different
lattices L and Ltri. The regions VRL(0) is the set of points that has
0 as the closest vector in the lattices and the region ARL(x) denotes
all the point that is considered to be “close" to x.
Fuzzy key setting based on a lattice. We define a fuzzy key setting
F = (X,X, AR, Φ, ϵ) with respect to a lattice as follows.
Fuzzy data space X: The fuzzy data space X is Rn, where n ∈ N
is specified by the context (e.g. the device which we use
to measure fuzzy data). We associate X with a lattice L =
L(B) spanned by some basis B ∈ Rn×n such that the closest
vectors in L can be efficiently computed. We also associate
X with a natural number p ∈ N that determines the support
of X (see below).
Distribution X: An efficiently sampleable distribution such that
the support of X satisfies the property that if x ← X, then
B−1x ∈ [0, p)n.
Acceptance region function AR: We define the acceptance region
function AR by AR(x) = ARL(x) := {x′|CVL(x − x′) = 0}.
Note that we have ARL(x) = VRL(0) + x. See Fig. 6 for a
pictorial example of ARL(x).
Error distribution Φ and Error parameter ϵ: Φ is any efficiently sam-
plable distribution over X such that FNMR ≤ ϵ.
дL(x) := B(cid:4)B−1x(cid:5) . Let
5.2 Construction of Linear Sketch
Let F = (X = Rn,X, AR, Φ, ϵ) be the fuzzy key setting as defined
above. Let дL : X → L be the function7
UH = {UH : Zn
p → Zp} be a family of universal hash functions8
that satisfies linearity, namely, for all UH ∈ H and x, y ∈ Zn
p ,
we have UH(x + y) = UH(x) + UH(y). Using these ingredients,
the description of our linear sketch scheme ΠLinS = (LinS.Setup,
Sketch, DiffRec) for F and the additive group (Zp, +) (=: Λ) is
provided in Fig. 7. The auxiliary algorithm Mc used to show the
linearity property is also included. A pictorial example (Fig. 8) and
an intuitive explanation of Sketch and DiffRec follow.
Algorithm Sketch(ppLS, x) first deterministically computes a lat-
tice point y = дL(x) ∈ L with respect to the basis B. As depicted
6For X ⊂ Rn and y, we define X + y =: {x + y|x ∈ X }.
7As far as correctness and linearity are concerned, the function дL can be any efficiently
computable deterministic function satisfying (1) дL(x + y) = дL(x) + y for all x ∈ X
and y ∈ L, and (2) ∥B−1x∥∞ ≈ ∥B−1дL(x)∥∞. We choose this particular function
for its simplicity and efficiency.
8Recall that UH = {UH : D → R} is called universal if for all distinct elements
x , x′ ∈ D, we have PrUH←UH[UH(x) = UH(x′)] ≤ |R|−1.
Figure 7: Construction of linear sketch ΠLinS and the auxiliary al-
gorithm Mc for the linearity property.
Figure 8: The left (resp. right) figure depicts algorithm Sketch (resp.
DiffRec). The shaded gray parallelogram denotes the fundamental
parallelepiped spanned by the basis B = [b1, b2]. The gray hexagon
denotes the acceptance region AR(x) of x.
in Fig. 8, the fundamental parallelepiped spanned by B9 originated
at y always contains x. Then, the sketch c is simply the shift x − y
and the proxy key a is a hash of some “canonical representation” of
the lattice point y. Now, it is clear from Fig. 8 that if x′ ∈ AR(x) is
contained in the same fundamental parallelepiped originated at y,
then it produces the same proxy key a since y = дL(x′). However,
as in the right figure in Fig. 8, this is not always the case. Therefore,
we require a mechanism to relate the proxy key a′ (or equivalently
y′) generated by x′ and those by x only given their sketches c′ and c.
Recall that this was the core property of linear sketch that allowed
us to meaningfully relate the secret keys generated from different a
and a′ for our fuzzy signature scheme (see Fig. 3). Now, algorithm
DiffRec(ppLS, c, c′) exactly offers this mechanism. First, by defini-
tion c−c′ = (x−x′) +(y′−y). Then since the vector x−x′ ∈ VR(0)
(see Fig. 8), CVL(c − c′) is the same as CVL(y′ − y) = y′ − y since
y′−y are points contained in L. Hence, we can recover ∆y = y′−y
(or equivalently ∆a = a′ − a) only from the sketches c and c′.
Formally, we have the following theorem whose proof is provided
in App. C.
Theorem 5.1. The linear sketch scheme ΠLinS in Fig. 7 satisfies
correctness and linearity (as per Def. 3.1).
5.3 Concrete Lattice for Efficient Linear Sketch
Depending on the the type of lattice L (or equivalently basis B),
the computational complexity of CVL and дL differs greatly. For
our concrete instantiation of linear sketch, we use triangular lat-
tices. Geometrically, they are lattices that have regular hexagons
9The fundamental parallelepiped spanned by B is defined as
the set
{ Bw | w ∈ [0, 1)n }.
Session 6D: Authentication and Privacy CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2052and дLtri
, the acceptance region ARLtri
as the Voronoi region VR (see the right hand side of Fig. 6 for an
illustration). Over such a lattice, CVLtri
can be computed in time
2). Moreover, other than they allow for efficient computations
O(n
of CVLtri
of triangular
lattices reflects nicely the notion of “closeness” of most natural
biometrics. In a typical biometric authentication, the most natural
and widely-used way to judge two biometrics x, x′ are “close” is to
calculate how close they are with respect to the Euclidean distance
∥x−x′∥2. The triangular lattice is a very suitable lattice in the sense
that ARLtri
(which is a regular hexagon) best approximates the
closeness induced by the Euclidean distance compared to any other
lattice L. We note that casting the linear sketch schemes in [33] in
the framework of lattices, we see that they considered lattices with
a square as the ARL (i.e., a lattice with basis B = d · In for some
positive real d ∈ R). See Fig. 9 for a visual aid. Effectively, our lattice
allows to extract more entropy from the underlying biometric since
we are able to model more accurately the real closeness metric.
A formal description of triangular lattices and how CVLtri
is
implemented are provided in App. D.
5.4 Security of the DL Assumption with Sketch
In Sec. 4, we introduced the DLsketch assumption on which the
security of our fuzzy signature scheme is based. The main question
is of course: how plausible is this assumption? We argue that for our
linear sketch scheme ΠLinS presented in this section, the DLsketch
assumption is plausible if:
• the quantity that we call the conditional false matching rate
(ConFMR) is “small”, say, ≈ 2−κ for a cryptographic security
parameter κ, and
• the standard DL assumption holds.
Here, for the linear sketch scheme ΠLinS over a fuzzy key setting
F = (X,X, AR, Φ, ϵ) with which a lattice L = L(B) is associated,
we define ConFMR by
In other words, ConFMR is the conditional probability that x′ be-
longs to AR(x) conditioned on the event that their sketch values
c = x − дL(x) and c′ = x′ − дL(x′) are identical.
Our argument is based on the following two facts:
(1) If ConFMR ⪅ 2−(2κ+ω(log κ)), then the standard DL assump-
(2) If ConFMR ≈ 2−κ (or even 2−ω(log κ)), then the DLsketch as-
tion implies the DLsketch assumption;
sumption holds in the generic group model [31].
We give an explanation for each item. Below, recall that for a
joint distribution (X, C), the (average) conditional collision entropy
of X given C is defined by ˜H2(X|C) := − log2 COL(X|C), where
COL(X|C) := Pr[(x , c), (x′
, c′) ← (X, C) : x = x′|c = c′].
(1)
Here, COL(X|C) is called the conditional collision probability of X
given C. When the context is clear, we often abuse notation and
write ˜H2(x|c) instead of ˜H2(X|C), and we do a similar treatment
for COL.
(1) DL implies DLsketch when ConFMR is sufficiently small. Identify-
ing the joint distribution (X, C) in Eq. (1) with {x ← X : (x, c =
x−дL(x))}, we clearly have COL(x|c) ≤ ConFMR. Moreover, observe
(cid:20) x, x ← X; c ← x − дL(x);
c′ ← x′ − дL(x′)
ConFMR := Pr
(cid:12)(cid:12)(cid:12)(cid:12)c = c′(cid:21)
.
: x′ ∈ AR(x)
COL(x|c) = COL(B−1y|c), since recovering x given c implies recover-
ing B−1y given c and vice versa due to c = x − y. Now, suppose we
had an upper bound of COL(B−1y|c) ≤ p−1 · 2−ω(log κ), or equiva-
lently ˜H2(B−1y|c) ≥ log2 p +ω(log κ), when we sample x ← X and
calculate (c, a) ← Sketch(ppLS, x), where c = x − y = x − дL(x).
Then, the leftover hash lemma of [7], formally recalled in App. A.2,
guarantees that the proxy key a = UH(B−1y) ∈ Zp is statistically
close to a uniformly random element even given c, and thus the
standard DL assumption implies the DLsketch assumption.
Putting things together, if ConFMR ⪅ 2−(2κ+ω(log κ)), then stan-
dard DL implies the DLsketch assumption since p ≈ 2κ. However,
since typically κ ≥ 80, this condition on ConFMR may be some-
what too expensive to assume for fuzzy biometrics. Nevertheless,
we believe the above provides us an intuition that the DLsketch
assumption is not an esoteric assumption and justifies that ConFMR
is the right quantity to care about.
(2) DLsketch is hard in the generic group model. The generic group
model [31] is an idealized model of computation for a cyclic group,
where algorithms do not use the representation (or, the encoding)
of the group elements, other than testing the equality of group
elements. When a new computational problem related to a cyclic
group is introduced, this model is typically used to reason about
its hardness. Specifically, if some computational problem is proved
to be hard for PPT adversaries in the generic group model, then it
formally guarantees that one cannot solve the problem efficiently
as long as one is performing only group operations. To solve it
efficiently, one must rely on a weakness of a particular group. Thus,
the hardness of a computational problem in the generic group model
serves as a strong evidence that if we use a cyclic group where no
such weakness is known (e.g. a group over an elliptic curve).
Based on existing works, we can observe that if ConFMR ≈ 2−κ (or
even 2−ω(log κ) = κ−ω(1)), then there is no PPT algorithm that can
break the DLsketch assumption in the generic group model. Specif-
ically, it is a well-known fact (and formally shown in [9, Lemma
6]) that a universal hash family is a good “strong randomness con-
denser” and preserves essentially all the (conditional) collision en-
tropy of the input B−1y of UH to its output a = UH(B−1y). That is,
we have COL(a|UH, c) ≈ COL(B−1y|c) ≤ ConFMR. Moreover, [3] con-
siders a stronger variant of the decisional Diffie-Hellman problem
where the exponents are not uniformly distributed but of superloga-
rithmic min-entropy ω(log κ), and showed that this problem is hard
for any PPT adversary in the generic group model. This directly
implies the hardness of the DL problem in which the exponent of a
problem instance is chosen from a distribution with min-entropy
ω(log κ) in the generic group model. Finally, min-entropy and colli-
sion entropy are linearly related. Hence, taking average over the
choice of c = x − y, we can conclude that the DLsketch problem is
hard to solve for any PPT adversary in the generic group model if
ConFMR = 2−ω(log κ).
6 EXPERIMENTAL METHOD FOR
ESTIMATING BIOMETRIC ENTROPY
The final and most important content to cover is the question of
whether we can use real-world biometrics to realize efficient and