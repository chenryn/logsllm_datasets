    00000000  22 00 00 10 00 00 00 00  00 00 00 00 00 00 00 00  |"...............|
    00000010  4e 4f 52 4d 41 4c 5f 43  4f 44 45 5f 44 41 54 41  |NORMAL_CODE_DATA|
    00000020  01 80 00 08 35 56 47 57  24 4c 41 4e 47 50 41 43  |....5VGW$LANGPAC|
    00000030  4b 5f 43 4f 44 45 5f 44  41 54 41 3d 06 01 00 01  |K_CODE_DATA=....|
    00000040  24 4d 4f 44 45 4c 5f 4e  41 4d 45 3d 57 52 54 35  |$MODEL_NAME=WRT5|
    00000050  34 47 00 24 4f 45 4d 5f  4e 41 4d 45 3d 4c 49 4e  |4G.$OEM_NAME=LIN|
    00000060  4b 53 59 53 00 43 6f 70  79 72 69 67 68 74 20 32  |KSYS.Copyright 2|
    00000070  30 30 34 2d 32 30 30 35  20 43 79 62 65 72 54 41  |004-2005 CyberTA|
    00000080  4e 20 4c 69 6d 69 74 65  64 00 00 00 39 80 1c 3c  |N Limited...9..<|
    00000090  50 ba 9c 27 00 10 08 3c  fe ff 09 24 24 40 09 01  |P..'...<...$$@..|
可以看到里面还是存在一些有意义的字符串的，看起来像是一些服务应用的字符串如HTTP和HNAP。
里面也有一些二进制数据，也许是可执行代码。但是，如果存在可执行代码，也找不到可以区别出来的头或者节信息，这使得分析起来存在困难。而且我们也不知道CPU的架构或者是大小端（这可能可以通过谷歌搜索找到）。
我们也看到在固件镜像偏移0x200的地方看到了一个ELF头的信息，分析下该文件：
    embedded@ubuntu:~/WRT54Gv8$ dd if=FW_WRT54Gv8_8.00.8.001_US_20091005.bin bs=512 skip=1 of=elf
    3453+1 records in
    3453+1 records out
    1768392 bytes (1.8 MB) copied, 0.020778 s, 85.1 MB/s
    embedded@ubuntu:~/WRT54Gv8$ file elf 
    elf: ELF 32-bit LSB executable, MIPS, MIPS-II version 1 (SYSV), statically linked, not stripped
    embedded@ubuntu:~/WRT54Gv8$ strings -n 10 elf | head
    VxWorks5.4.2
    Oct  5 2009, 15:15:53
    memPartFree
    %-5s = %8x
    0123456789abcdef
    0123456789ABCDEF
    bug in vfprintf: bad base
    WIND version 2.5
    workQPanic: Kernel work queue overflow.
    DDDDDDDDDD
这是一个小端的mips ELF文件，里面包含一些字符串有`Vxworks`、`Wind
River`、以及`Kernel`。看起来这似乎是VxWorks内核文件。用IDA加载这个文件看下能不能查看它（确定选择mipsl cpu）：
由于这个文件有ELF头，所以IDA可以很好的解析这个文件，识别函数以及解析符号。首先看下第一个函数`startInflate`：
可以看到地址`0x80001000`加载到了`$v0`寄存器中，并调用`decompressImage`函数，最终跳转到`$v0(0x80001000)`地址去执行。因此，可能是`decompressImage`函数将`0x80001000`处的代码解压，然后再执行该地址处的代码。
查看`decompressImage`函数的参数，第一个参数是`_binArrayStart`，第二个地址是`0x80001000`。让我们看下`_binArrayStart`：
`_binArrayStart`地址处的前五个字节是`6C 00 00 80
00`，看起来像是一个`LZMA`镜像的头文件。与之前提取出来的LZMA数据比较下，确定了这个想法：
    embedded@ubuntu:~/WRT54Gv8$ hexdump -C lzma_data.7z | head
    00000000  6c 00 00 80 00 60 2a 38  00 00 00 00 00 00 11 00  |l....`*8........|
    00000010  2c 20 00 df 1e 01 d7 44  6b 43 41 4d a8 aa 91 9c  |, .....DkCAM....|
    00000020  11 ed 0d 6b bd 40 da 21  19 b1 16 8b 51 48 b8 a6  |...k.@.!....QH..|
    00000030  c9 1f 7e 0b 24 4c 24 14  2b db 64 59 fb 79 2a 3c  |..~.$L$.+.dY.y*<|
    00000040  11 70 12 a7 84 78 fc 38  f5 99 ed 0d db 0f c3 64  |.p...x.8.......d|
    00000050  4c ca ca 70 31 bc e7 1a  7f 42 51 dc 1f fe 8b dc  |L..p1....BQ.....|
    00000060  d0 89 fc 0a 9a dc 03 37  62 e3 75 f3 10 56 7c f8  |.......7b.u..V|.|
    00000070  6a c1 14 69 bc 28 e6 fc  48 2e f5 bf b2 22 dc f5  |j..i.(..H...."..|
    00000080  ec b1 c7 9b ec 76 93 73  b8 cf fa 2d 06 34 cb 75  |.....v.s...-.4.u|
    00000090  4b ed 1f f1 28 d7 00 ea  ae 29 57 19 de 87 42 ae  |K...(....)W...B.|
跟进去`decompressImage`函数，我们还可以看到它还调用了一个叫做`LzmaDecode`的函数：
所以看起来是我们之前提取的`LZMA`数据包含可执行代码，这些数据被解压然后载入到地址`0x80001000`中，google搜`vxworks
lzmadecode`出来的[源码](http://www.hackchina.com/en/cont/27807)（译者注：这个链接已经失效了）证明了这个结论。
基于之前看到的字符串，可以初步判断`LZMA`数据中包含OS的应用代码。
我们现在已经有了足够多的信息，可以将解压出来的LZMA数据加载到IDA中分析了。与kernel一样，我们将架构设为mipsl，由于这是一个二进制文件，我们需要在IDA中设置一些适当的加载信息。
我们将ROM的开始地址设置为`0x80001000`，把size设置成文件的size`0x382A60`，同时把`loading
address`设置为`0x80001000`。如下图所示：
当文件加载进IDA，到第一个字节处，按下`c`键直接把它转换成代码。IDA会将该地址处的字节直接转换成代码并对文件进行分析。可以看到，第一条指令是一个跳转指令，跳过了文件头附近的一些文件。
代码看起来很清晰，IDA也识别出来了超过5000个函数，并且字符串的引用看起来也是正确的：
我们将该数据文件载入IDA，不设置正确的载入地址。将分析结果与上面得到的结果进行对比；
IDA的导航栏中有相当数量的蓝色区域（代码）：
可以看到，虽然我们的分析已经提升了IDA的分析结果，仍然还有很多代码是丢失的，因此我写了一个IDA[脚本](http://www.devttys0.com/wp-content/uploads/2011/07/ida_scripts.zip)来帮助得到更多的反汇编代码。
首先，我们希望通过迭代查找代码寻找常见的函数序言来定位未识别的函数。如果找到了，我们会告诉IDA在那里创建一个函数。对于MIPS而言，有时比intel架构困难，因为函数序言在MIPS中的标准化程度较低。
`addui`指令经常在函数最开始被用来操作栈桢寄存器`$sp`，我们可以在IDA中看到很多的函数是这样的：
然而，也有一些函数在`addui`指令前还有一条`lw`指令：
`create_function.py`
IDAPython脚本通过搜索代码字节序（从上图的光标处地址开始）寻找相应的指令，如果找到的话就引导IDA将该处的代码创建为一个函数。
查看反汇编代码，包含字符串的数据节出现在地址`0x802DDAC0`，因此我将脚本的设定为分析到该地址就结束：
在跑完这个脚本后，IDA识别出来了9600个函数，相比于之前，更多的代码被识别出来了：
但是仍然有一些数据节没有被分析到：
这些节被代码所包围，并且导航到其中几个节将它们直接转换成代码，可以看到它们也是有效的汇编指令：
因为这些节看起来都是以`jr $ra`（mips的返回指令）结束，并且由于它们没有被其他的函数所使用，它们可能是自身调用的函数（since they are
not referenced by the surrounding functions, they are likely functions
themselves. ）（译者注：不太理解这句话，怕误导，所以将原文贴出）
`create_code.py`会遍历代码并将这些没有定义的字节转换成函数（方法和之前的类似，脚本从下图光标处地址开始遍历至`0x802DDAC0`结束）：
现在在IDA的导航栏中有一个比较完美的代码块：
随着完成对代码的处理，我们将注意力转向字符串。没有像ELF文件中的符号，我们不得不依赖字符串的引用来提供对于固件中的事件的理解。但是仍然有一些ascii字节的数组没有被IDA转换成字符串：
将这些ascii字节的数组转换成字符串将会使得代码的可读性更强，因此`create_ascii.py`脚本是将ascii字节的数组转换成字符串。我们之前看到的是，包含字符串的数据地址开始于0x802DDAC0，因此我们将开始的地址设定为该地址，并运行脚本。运行的结果相较于之前又了一定的提升：
随着字符串也被修复好了，让我们在汇编代码中去识别一些基本的函数：
上图中有两个函数被调用。第一个是`sub_802A7F90`，参数为一个：1将其左移16位（65536）。如果返回值是0，调用第二个函数`sub_802A06E8`。
第二个函数接受不了两个参数：一个包含格式化字符的字符串；一个65536立即数。伪代码如下：
    if(!sub_802A7F90(65536))
    {
       sub_802A06E8("Can't allocate %d bytes of memoryn", 65536);
    }
很容易看出来`sub_802A7F90`等同于`malloc`函数，`sub_802A06E8`函数是`printf`。我们将这些函数重命名，以便其他代码对它们进行引用的时候会更加便于分析。
到这里就结束了，我们现在就拥有了内核以及应用层的所有代码。可以进一步进行分析，寻找bug或漏洞了。