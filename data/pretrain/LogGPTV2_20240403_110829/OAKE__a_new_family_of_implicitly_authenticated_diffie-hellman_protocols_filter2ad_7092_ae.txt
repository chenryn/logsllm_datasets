[45] L. Law, A. Menezes, M. Qu, J. Solinas and S. Vanstone. An Eﬃcient Protocol for Authenticated
Key Agreement. Designs, Codes and Cryptography, 28: 119-134, 2003.
[46] W. Mao. Modern Cryptography: Theory and Practice. Prentice Hall PTR, 2004.
[47] T. Matsumoto, Y. Takashima, and H. Imai. On seeking smart public-key distribution systems,
Trans. IECE of Japan, 1986, E69(2), pp. 99-106.
[48] U. Maurer and S. Wolf. Diﬃe-Hellman Oracles. In Advances in Cryptology-Proceedings of CRYPTO
1996, LNCS 1109, pages 268-282, Springer-Verlag, 1996.
[49] A. Menezes, P. van Oorschot, and S. Vanstone. Handbook of Applied Cryptography. CRC Press,
1995, pages 617-619.
[50] A. Menezes, M. Qu, and S. Vanstone. Some New Key Agreement Protocols Providing Mutual
Implicit Authentication. Second Workshop on Selected Areas in Cryptography (SAC’95), 1995.
[51] A. Menezes and B. Ustaoglu. On the Importance of Public-Key Validation in the MQV and HMQV
Key Agreement Protocols. INDOCRYPT 2006: 133-147.
[52] C. J. Mitchell, M. Ward and P. Wilson. Key Control in Key Agreement Protocols. Electronic
Letters, 34(10):980-981, 1998.
[53] M. Naor and O. Reingold. Number-Theoretic Constructions of Eﬃcient Pseudo-Random Functions.
Journal of the ACM, 1(2): 231-262 (2004).
[54] D. Naccache, D. M’Raihi, S. Vaudenay and D. Raphaeli. Can D.S.A be Improved? Complexity
Trade-Oﬀs with the Digital Signature Standard. In Advances in Cryptology-Proceedings of EURO-
CRYPT 1994, LNCS 950, pages 77-85, Springer-Verlag, 1994.
[55] J. B. Nielsen. Separating Random Oracle Proofs from Complexity Theoretic Proofs: The Non-
Committing Encryption Case. In Advances in Cryptology-Proceedings of CRYPTO 2002, LNCS
2442, pages 111-126, Springer-Verlag, 2002.
[56] NIST Special Publication 800-56 (DRAFT): Recommendation on Key Establishment Schemes.
Draft 2, January 2003.
[57] NSAs Elliptic Curve Licensing Agreement. Presentation by Mr. John Stasak (Cryptography Oﬃce,
National Security Agency) to the IETF’s Security Area Advisory Group, November 2004.
[58] T. Okamoto and D. Pointcheval. The Gap-Problems: A New Class of Problems for the Security of
Cryptographic Schemes. In PKC’01, LNCS 1992, pages 104-118, Springer-Verlag, 2001.
[59] R. Pass. On Deniabililty in the Common Reference String and Random Oracle Models. In Advances
in Cryptology-Proceedings of CRYPTO 2003, LNCS 2729, pages 316-337, Springer-Verlag 2003.
[60] D. Pointcheval and J. Stern. Security Arguments for Digital Signatures and Blind Signatures.
Journal of Cryptology, 13: 361-396, 2000.
[61] C. Schnorr. Eﬃcient Signature Generation by Smart Cards. Journal of Cryptology, 4(3): 161-174,
1991.
[62] A. Shamir and Y. Tauman.
Improved Online/Oﬄine Signature Schemes. In In Advances in
Cryptology-Proceedings of CRYPTO 2001, LNCS 2139, pages 355-367, Springer-Verlag, 1996.
15
[63] SP 800-56 (DRAFT), Special Publication 800-56, Recommendation for Pair-Wise Key Estab-
lishment Schemes Using Discrete Logarithm Cryptography, National Institute of Standards and
Technology, July 2005.
[64] T. Ylonen. SSH Protocol Architecture. INTERNET-DRAFT, draft-ietf-architecture-15.txt, 2002.
[65] T. Ylonen. SSH Transport Layer Protocol. INTERNET-DRAFT, draft-ietf-architecture-13.txt,
2002.
[66] A.C.Yao and Y. Zhao. On-line Eﬃcient, Deniable and Non-Malleable Key-Exchange Methods (in
Chinese), Domestic patent in China, No. 200710047344.8, August 2007.
[67] A.C.Yao and Y. Zhao. Method and Structure for Self-Sealed Joint Proof-of-Knowledge and Diﬃe-
Hellman Key-Exchange Protocols. PCT Patent. Online available from Global Intellectual Property
Oﬃce (GIPO) since August 2008. This is the PCT version of [66], with [66] serving as the priority
reference.
[68] A.C.Yao and Y. Zhao. Deniable Internet Key-Exchange. In 8th International Conference on Applied
Cryptography and Network Security (ACNS 2010), LNCS 6123 , pages 329-348, Springer-Verlag,
2010. Preliminary version appears in Cryptology ePrint Archive, Report 2007/191.
A Variants of (H)MQV
Three-round HMQV (resp., MQV) adds key conﬁrmation as follows: let Km = HK(K ^A; 0) = HK(K ^B; 0),
ˆB uses Km as the MAC key to authenticate 0 (resp., (2; ˆB; ˆA; Y; X)) in the second-round of HMQV
(resp., MQV); and ˆA uses Km to authenticate 1 (resp., (3; ˆA; ˆB; X; Y )) in an additional third-round of
HMQV (resp., MQV). The session-key is set to be K = HK(K ^A; 1) = HK(K ^B; 1).
In one-round HMQV, only ˆA sends X, and the session-key is derived as follows: K ^A = Bx+da,
K ^B = (XAd)b, d = h(X; ˆA; ˆB), K = HK(K ^A) = HK(K ^B).
B Basic Deﬁnitions
Gap Diﬃe-Hellman (GDH) assumption [58]. Let G be a cyclic group generated by an element g,
and a decision predicate algorithm O be a (full ) Decisional Diﬃe-Hellman (DDH) Oracle for the group G
and generator g such that on input (U; V; Z), for arbitrary (U; V ) ∈ G2, oracle O outputs 1 if and only
if Z = CDH(U; V ). We say the GDH assumption holds in G if for any polynomial-time CDH solver
for G, the probability that on a pair of random elements (X; Y ) ← G the solver computes the correct
value CDH(X; Y ) is negligible, even when the algorithm is provided with the (full) DDH-oracle O for
G. The probability is taken over the random coins of the solver, and the choice of X; Y (each one of
them is taken uniformly at random in G).
q and z ∈ {0; 1}∗
∗
Knowledge-of-Exponent Assumption (KEA). Let G be a cyclic group of prime order q gen-
erated by an element g, and consider algorithms that on input a triple (g; C = gc; z) output a pair
(Y; Z) ∈ G2, where c is taken uniformly at random from Z
is an arbitrary string that is
generated independently of C. Such an algorithm A is said to be a KEA algorithm if with non-negligible
probability (over the choice of g; c and A’s random coins) A(g; gc; z) outputs (Y; Z) ∈ G2 such that
Z = Y c. Here, C = gc is the random challenge to the KEA algorithm A, and z captures the auxiliary
input of A that is independent of the challenge C.
We say that the KEA assumption holds over G, if for every probabilistic polynomial-time (PPT)
KEA algorithm A for G there exists another eﬃcient algorithm K, referred to as the KEA-extractor,
for which the following property holds except for a negligible probability: let (g; gc; z) be an input to A
and (cid:26) a vector of random coins for A on which A outputs (Y; Z = Y c), then, on the same inputs and
random coins, K(g; C; z; (cid:26)) outputs the triple (Y; Z = Y c; y) where Y = gy.
16
C NMJPOK: Motivation, Formulation, and Implementations
We consider an adversarial setting, where polynomially many instances (i.e., sessions) of a Diﬃe-Hellman
protocol ⟨ ˆA; ˆB⟩ are run concurrently over an asynchronous network like the Internet. To distinguish
concurrent sessions, each session run at the side of an uncorrupted player is labeled by a tag, which is the
concatenation, in the order of session initiator and then session responder, of players’ identities/public-
keys and DH-components available from the session transcript. A session-tag is complete if it consists
of a complete set of all these components.
0 and f h
1 (X y; aux1) in the random oracle model, where f h
In this work, we study the mechanisms for non-malleably and jointly proving the knowledge of
both b and y w.r.t. a challenge DH-component X between the prover ˆB (of public-key B = gb and
DH-component Y = gy) and the veriﬁer ˆA (who presents the challenge DH-component X = gx), where
b; y; x ← Z
∗
q . Our starting point is the JPOK mechanism proposed in [68] for deniable Internet key-
exchange: JP OK(b;y) = h( ˆA; A; ˆB; B; Y; X; X b; X y) w.r.t. a random DH-component challenge X from
ˆA. This JPOK mechanism is shown to be sound in the RO model [68], but is less eﬃcient and has
no way to be used for IA-OAKE. Motivated to further improve its eﬃciency toward a building tool
for IA-OAKE, in this work we investigate joint proof-of-knowledge (JPOK) of the type JP OK(b;y) =
0 (X b; aux0) · f h
f h
1 are some functions from
to G \ 1G with oracle access to an RO h : {0; 1}∗ → {0; 1}l, aux0 and aux1 are some public
{0; 1}∗
values. Moreover, we look for solutions of JP OK(b;y) such that JP OK(b;y) can be eﬃciently computed
with one single exponentiation by the knowledge prover. Note that the tag for a complete session of
JP OK(b;y) is ( ˆA; ˆB; B; X; Y ). The possibility of NMJPOK without ROs (based upon pairings) is left
to be studied in a subsequent separate paper. In the rest of this paper, we denote by the output length,
i.e., l, of h as the security parameter.
One naive solution of JP OK(b;y) is just to set JP OK(b;y) = X b · X y = X b+y. But, such a naive
solution is totally insecure, for example, an adversary A can easily impersonate the prover ˆB and pre-
−1. The underlying reason is:
determine the value of JP OK(b;y) to be 1G, by simply setting Y = B
A can malleate B and Y into X y+b by maliciously correlating the exponents of y and b, but actually
without knowing either of them. A further remedy of this situation is to mask the exponents b and y
by some random values. In this case, the proof is denoted as JP OK(b;y) = X db+ey, where d and e are
random values (e.g., d = h(X; ˆB) and e = h(Y; ˆA)). The intuition with this remedy solution is: since d
and e are random values, the values of db and ey are also random (even if the values Y and B, and thus
the values of y and b, may be maliciously correlated). This intuition however turns out also to be wrong
in general. With the values d = h(B; ˆA) and e = h(X; ˆB) as an illustrative example, after receiving X
an adversary A can generate and send Y = B
−d=e, and in this case JP OK(b;y) = X db+ey = 1G. This
shows that masking b and y by random values is also not suﬃcient for ensuring the non-malleability of
JP OK(b;y). The key point here is that the values db and ey are not necessarily independent. A series
of careful investigations bring us to the following principles for proving DH knowledges non-malleably
and jointly:
Inside Computational Independence. Denote S0 = {X; B}, Z0 = CDH(X; B) = gxb, F0 =
0 (Z0; aux0), S1 = {X; Y }, Z1 = CDH(X; Y ) and F1 = f h
f h
1 (Z1; aux1). The key principle is: the inside
multiplied components F0 and F1 of JP OK(b;y) should be computationally independent, no matter
how a malicious knowledge prover ˆB (of public-key B = gb ∈ G) does. That is, the adversarial
attempts at Z(cid:14) for any (cid:14) ∈ {0; 1} should be essentially sealed (i.e., localized) to F(cid:14), and are isolated
(i.e., “independent”) from the adversarial attempts at Z1−(cid:14). This essentially ensures that no matter
how the possibly malicious knowledge-prover ˆB does, to compute JP OK(b;y)
ˆB has to compute two
“independent” DH-secrets F0 and F1 w.r.t. the fresh challenge X, which implies that ˆB does indeed
“know” both b and y.
Deﬁnition C.1 (computational independence) We formulate two types of “computational inde-
pendence” w.r.t. JP OK(b;y):
(1) Self-sealed computational independence. Given arbitrary values ((cid:11); (cid:12)) ∈ (G\ 1G)2, no matter how
a malicious ˆB does, both Pr[F0 = (cid:11)] and Pr[F1 = (cid:12)] are negligible.
17
aux1−(cid:14) ⊆ aux(cid:14).
(cid:14) (Z(cid:14); aux
∪
non-negligible probability, (S
′
(cid:14) (w.r.t.
(2) Committed computational independence. There exists (cid:14) ∈ {0; 1} such that for any (cid:11) ∈ G \ 1G
Pr[F(cid:14) = (cid:11)] is negligible, no matter how a malicious ˆB does. This captures the independence of F(cid:14) on
F1−(cid:14), i.e., the infeasibility of adversarial attempts by a malicious prover on setting F(cid:14) to be correlated
to F1−(cid:14); On the other hand, the value F1−(cid:14) is committed to F(cid:14), in the sense that
∪
• S1−(cid:14)
• Given (Z(cid:14); aux(cid:14)) that determines F(cid:14) = f h
(cid:14) (Z(cid:14); aux(cid:14)), no eﬃcient algorithm can provide, with
1−(cid:14)) ⊆ aux
′
′
′
1−(cid:14); aux
1−(cid:14)
− aux
from ˆA and aux(cid:14) − aux1−(cid:14) = aux
′
aux1−(cid:14) but
′
(cid:14)
f h
(cid:14) (Z(cid:14); aux(cid:14)) = f h
(cid:14)).That is, any adversarial attempt by a malicious prover on setting
F1−(cid:14) to be correlated to a given value F(cid:14), by changing {S1−(cid:14); aux1−(cid:14)} into {S
} w.r.t.
′
′
1−(cid:14)
1−(cid:14); aux
the same random challenge X = S1−(cid:14) ∩ S
− aux
′
1−(cid:14) (for example, by
simply changing B for the case of (cid:14) = 1 or Y for the case of (cid:14) = 0), will cause the value F(cid:14) itself
changed that in turn determines and commits to the value F1−(cid:14) (while Pr[F(cid:14) = (cid:11)] is negligible
for any (cid:11) ∈ G \ 1G). This implies the infeasibility of adversarial attempt on setting F1−(cid:14) to be
correlated to F(cid:14), i.e., the “computational independence” of F1−(cid:14) on F(cid:14).
the same challenge X = S1−(cid:14) ∩ S
1−(cid:14) and aux(cid:14) − aux1−(cid:14) = aux
′
′
1−(cid:14)) such that S
′
1−(cid:14)
′
1−(cid:14)
aux
̸= S1−(cid:14)
∪
′
(cid:14)
The probabilities are taken over the random coins used by the malicious ˆB and the honest ˆA, and
the choice of the random function h in the RO model.