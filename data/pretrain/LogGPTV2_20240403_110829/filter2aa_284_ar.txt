unencoded (or unencypted), will be considered valid.
Forwards
The countermeasure for forwards is to either whitelist the range of pages that can be forwarded to (similar to 
redirects) and to enforce authentication on the forwarded page as well as the forwarding page.  This means 
that even if an attacker manages to force a forward to a page they should not have access to, the authentica-
tion check on the forwarded page will deny them access.
Note on J2EE
There is a noted flaw related to the “sendRedirect” method in J2EE applications. For example:
• response.sendRedirect(“home.html”);
This method is used to send a redirection response to the user who then gets redirected to the desired web 
component whose URL is passed an argument to the method. One such misconception is that execution flow 
in the Servlet/JSP page that is redirecting the user stops after a call to this method. Note that if there is code 
present after the ‘If’ condition it will be executed.
The fact that execution of a servlet or JSP continues even after sendRedirect() method, also applies to Forward 
method of the RequestDispatcher Class. However,  tag is an exception, it is observed that the 
execution flow stops after the use of  tag.
After issue a redirect or forward, terminate code flow using a “return” statement.
References
• OWASP Article on Open Redirects https://www.owasp.org/index.php/Open_redirect
Method of Redirection
Description
Redirect Response
(note 301 and 307 responses will 
also cause a redirect)
HTTP/1.1 302 Found
Location: http://www.attacker.com/page.html
Meta Tag
JavaScript
Refresh Header
HTTP/1.1 200 OK
Refresh=0; url=http://attacker.com/page.html
Table 22: Redirect Risks
A10 - Unvalidated Redirects And Forwards
153
• CWE Entry 601 on Open Redirects http://cwe.mitre.org/data/definitions/601.html
• WASC Article on URL Redirector Abuse http://projects.webappsec.org/w/page/13246981/URL%20Redi-
rector%20Abuse
• Google blog article on the dangers of open redirects http://googlewebmastercentral.blogspot.
com/2009/01/open-redirect-urls-is-your-site-being.html
• Preventing Open Redirection Attacks (C#) http://www.asp.net/mvc/tutorials/security/preventing-open-re-
direction-attacks
A10 - Unvalidated Redirects And Forwards
154
HTML 5
HTML5 was created to replace HTLML4, XHTML and the HTML DOM Level 2. The main purpose of this new stan-
dard is to provide dynamic content without the use of extra proprietary client side plugins. This allows designers 
and developers to create exceptional sites providing a great user experience without having to install any addi-
tional plug-ins into the browser.
17.1 Description
Ideally users should have the latest web browser installed but this does not happens as regularly as security ex-
perts advice, therefore the website should implement 2 layer controls, one layer independent from browser type, 
second, as an additional control.
What to Review: Web Messaging
Web Messaging (also known as Cross Domain Messaging) provides a means of messaging between documents 
from different origins in a way that is generally safer than the multiple hacks used in the past to accomplish this 
task.  The communication API is as follows:
However, there are still some recommendations to keep in mind: 
• When posting a message, explicitly state the expected origin as the second argument to ‘postMessage’ rather 
than ‘*’ in order to prevent sending the message to an unknown origin after a redirect or some other means of the 
target window’s origin changing.
• The receiving page should always:
o  Check the ‘origin’ attribute of the sender to verify the data is originating from the expected location.
o  Perform input validation on the ‘data’ attribute of the event to ensure that it’s in the desired format.
• Don’t assume you have control over the ‘data’ attribute. A single Cross Site Scripting flaw in the sending page 
allows an attacker to send messages of any given format.
• Both pages should only interpret the exchanged messages as ‘data’. Never evaluate passed messages as code (e.g. 
via ‘eval()’) or insert it to a page DOM (e.g. via ‘innerHTML’), as that would create a DOM-based XSS vulnerability.
• To assign the data value to an element, instead of using an insecure method like ‘element.innerHTML = data’, use 
the safer option: ‘element.textContent = data;’
• Check the origin properly exactly to match the FQDN(s) you expect. Note that the following code: ‘ if(message.
orgin.indexOf(“.owasp.org”)!=-1) { /* ... */ }’ is very insecure and will not have the desired behavior as ‘www.owasp.
org.attacker.com’ will match.
• If you need to embed external content/untrusted gadgets and allow user-controlled scripts (which is highly 
discouraged), consider using a JavaScript rewriting framework such as Google’s Caja or check the information 
on sandboxed frames.
HTML5
155
HTML 5
What to Review: Cross Origin Resource Sharing
Cross Origin Resource Sharing or CORS is a mechanism that enables a web browser to perform “cross-domain” 
requests using the XMLHttpRequest L2 API in a controlled manner. In the past, the XMLHttpRequest L1 API 
only allowed requests to be sent within the same origin as it was restricted by the same origin policy.
Cross-Origin requests have an Origin header that identifies the domain initiating the request and is automat-
ically included by the browser in the request sent to the server. CORS defines the protocol between a web 
browser and a server that will determine whether a cross-origin request is allowed. In order to accomplish 
this goal, there are HTTP headers that provide information on the messaging context including: Origin, Ac-
cess-Control-Request-Method, Access-Control-Request-Headers, Access-Control-Allow-Origin, Access-Con-
trol-Allow-Credentials, Access-Control-Allow-Methods, Access-Control-Allow-Headers.
The CORS specification mandates that for non simple requests, such as requests other than GET or POST or requests 
that uses credentials, a pre-flight OPTIONS request must be sent in advance to check if the type of request will have 
a negative impact on the data. The pre-flight request checks the methods, headers allowed by the server, and if 
credentials are permitted, based on the result of the OPTIONS request, the browser decides whether the request is 
allowed or not. 
Items to note when reviewing code related to CORS includes:
• Ensure that URLs responding with ‘Access-Control-Allow-Origin: *’ do not include any sensitive content or informa-
tion that might aid attacker in further attacks. Use the ‘Access-Control-Allow-Origin’ header only on chosen URLs that 
need to be accessed cross-domain. Don’t use the header for the whole domain.
• Allow only selected, trusted domains in the ‘Access-Control-Allow-Origin’ header. Prefer whitelisting domains over 
blacklisting or allowing any domain (do not use ‘*’ wildcard nor blindly return the ‘Origin’ header content without any 
checks).
• Keep in mind that CORS does not prevent the requested data from going to an unauthenticated location. It’s still 
important for the server to perform usual Cross-Site Request Forgery prevention.
• While the RFC recommends a pre-flight request with the ‘OPTIONS’ verb, current implementations might not per-
form this request, so it’s important that “ordinary” (‘GET’ and ‘POST’) requests perform any access control necessary.
• Discard requests received over plain HTTP with HTTPS origins to prevent mixed content bugs.
• Don’t rely only on the Origin header for Access Control checks. Browser always sends this header in CORS requests, 
but may be spoofed outside the browser. Application-level protocols should be used to protect sensitive data.
What to Review: WebSockets
Traditionally the HTTP protocol only allows one request/response per TCP connection. Asynchronous JavaS-
cript and XML (AJAX) allows clients to send and receive data asynchronously (in the background without a 
page refresh) to the server, however, AJAX requires the client to initiate the requests and wait for the server 
responses (half-duplex). HTML5 WebSockets allow the client/server to create a ‘full-duplex’ (two-way) commu-
nication channels, allowing the client and server to truly communicate asynchronously. WebSockets conduct 
their initial ‘upgrade’ handshake over HTTP and from then on all communication is carried out over TCP chan-
nels.
The following is sample code of an application using Web Sockets:
156
When reviewing code implementing websockets, the following items should be taken into consideration:
• Drop backward compatibility in implemented client/servers and use only protocol versions above hybi-00. Popular
Hixie-76 version (hiby-00) and older are outdated and insecure. 
• The recommended version supported in latest versions of all current browsers is rfc6455 RFC 6455  (supported by
Firefox 11+, Chrome 16+, Safari 6, Opera 12.50, and IE10).
• While it’s relatively easy to tunnel TCP services through WebSockets (e.g. VNC, FTP), doing so enables access to these
tunneled services for the in-browser attacker in case of a Cross Site Scripting attack. These services might also be 
called directly from a malicious page or program. 
• The protocol doesn’t handle authorization and/or authentication. Application-level protocols should handle that
separately in case sensitive data is being transferred.
• Process the messages received by the websocket as data. Don’t try to assign it directly to the DOM nor evaluate as
code. If the response is JSON, never use the insecure eval() function; use the safe option JSON.parse() instead.
• Endpoints exposed through the ‘ws://’ protocol are easily reversible to plain text. Only ‘wss://’ (WebSockets over SSL/
TLS) should be used for protection against Man-In-The-Middle attacks.
• Spoofing the client is possible outside a browser, so the WebSockets server should be able to handle incorrect/
malicious input. Always validate input coming from the remote site, as it might have been altered. 
• When implementing servers, check the ‘Origin:’ header in the Websockets handshake. Though it might be spoofed 
[Constructor(in DOMString url, optional in DOMString protocol)] 
 interface WebSocket 
 { readonly attribute DOMString URL; 
 // ready state const unsigned short CONNECTING = 0; 
 const unsigned short OPEN = 1; 
 const unsigned short CLOSED = 2; 
 readonly attribute unsigned short readyState; 
 readonly attribute unsigned long bufferedAmount;  
 // networking 
 attribute Function onopen; 
 attribute Function onmessage; 
 attribute Function onclose; 
 boolean send(in DOMString data); 
 void close(); 
 }; 
 WebSocket implements EventTarget;
 var myWebSocket = new WebSocket(“ws://www.websockets.org”);
 myWebSocket.onopen = function(evt) { alert(“Connection open ...”); }; 
 myWebSocket.onmessage = function(evt) { alert( “Received Message: “ + evt.data); }; 
 myWebSocket.onclose = function(evt) { alert(“Connection closed.”); };
Sample 17.1
HTML 5
157
outside a browser, browsers always add the Origin of the page that initiated the Websockets connection.
• As a WebSockets client in a browser is accessible through JavaScript calls, all Websockets communication can be
spoofed or hijacked through Cross Site Scripting. Always validate data coming through a WebSockets connection.
5.1.5 What to Review: Server-Sent Events
Server sent events seem similar to WebSockets, however they do not use a special protocol (they re-used HTTP) and 
they allow the client browser to solely listen for updates (messages) from the server, thereby removing the need for 
the client to send any polling or other messages up to the server.  
When reviewing code that is handling server sent events, items to keep in mind are:
• Validate URLs passed to the ‘EventSource’ constructor, even though only same-origin URLs are allowed.
• As mentioned before, process the messages (‘event.data’) as data and never evaluate the content as HTML or script
code.
• Always check the origin attribute of the message (‘event.origin’) to ensure the message is coming from a 
trusted domain. Use a whitelist.
HTML 5
158
Same Origin Policy (SOP), also called Single Origin Policy is a part of web application security model.  Same Origin 
Policy has vulnerabilities that the code reviewer needs to take into consideration. SOP covers three main areas of 
web development, Trust, Authority, and Policy. Same Origin Policy is made of the combination of three components 
(Scheme, Hostname and Port).
18.1 Description
Internet Explorer has two major exceptions when it comes to same origin policy:
1. Trust Zones: if both domains are in highly trusted zone e.g, corporate domains, then the same origin limita-
tions are not applied.
2. Port: IE doesn’t include port into Same Origin components, therefore http://yourcompany.com:81/index.
html  and http://yourcompany.com/index.html are considered from same origin and no restrictions are applied. 
These exceptions are non-standard and not supported in any of other browser but would be helpful if developing an 
app for Windows RT (or) IE based web application.
The following figure displays the various parts of the URL:
SAME ORIGIN POLICY
  foo://username:PI:EMAIL:8042/over/there/index.dtb?type=animal&name=narwhal#nose
userinfo
path
authority
hierarchical part
interpretable as keys
interpretable as values
scheme
name
hostname
query
port
interpretable as filename
path
interpretable as filename
fragment
Figure 12
Same Origin Policy
159
• foo://username:PI:EMAIL:8042/over/there/index.dtb?type=animal&name =narwhal#nose
18.2 What to Review
• If application allows user-supplied data in the URL then the code reviewer needs to make sure the path, 
query or Fragment Id Code data is validated. 
• Make sure user-supplied scheme name or authority section has good input validation. This is a major code 
injection and phishing risk. Only permit prefixes needed by the application. Do not use blacklisting. Code re-
viewer should make sure only whitelisting is used for validation.
• Make sure authority section should only contain alphanumerics, “-“, and “.” And be followed by “/”, “?”,”#”. The 
risk here an IDN homograph attack.
• Code reviewer needs to make sure the programmer is not assuming default behavior because the program-
mers browser properly escapes a particular character or browser standard says the character will be escaped 
properly before allowing any URL-derived values are put inside a database query or the URL is echoed back 
to the user.
• Resources with a MIME type of image/png are treated as images and resources with MIME type of text/html 
are treated as HTML documents. Web applications can limit that content’s authority by restricting its MIME 
type.  For example, serving user-generated content as image/png is less risky than serving user-generated 
content as text/html.
• Privileges on document and resources should grant or withhold privileges from origins as a whole (rath-
er than discriminating between individual documents within an origin). Withholding privileges is ineffective 
because the document without the privilege can usually obtain the privilege anyway because SOP does not 
isolate documents within an origin.
Same Origin Policy
160
 Reviewing Logging Code
Applications log messages of varying intensity and to varying sinks.  Many logging APIs allow you to set the 
granularity of log message from a state of logging nearly all messages at level ‘trace’ or ‘debug’ to only logging 
the most important messages at level ‘critical’.  Where the log message is written to is also a consideration, 
sometimes it can be written to a local file, other times to a database log table, or it could be written over a 
network link to a central logging server.
The volume of logging has to be controlled since the act of writing messages to the log uses CPU cycles, thus 
writing every small detail to a log will use up more resources (CPU, network bandwidth, disk space).  Couple 
that with the fact that the logs have to be parsed or interpreted by a tool or human in order for them to be use-
ful, the consumer of the log could have to parse through thousands of lines to find a message of consequence.
19.1 Description
Logs can vary by type; for example a log may simply contain application state or process data, allowing sup-
port or development track what the system is doing when a bug has occurred.  Other logs may be specific to 
security, only logging important information that a central security system will have interest in.  Further logs 
could be used for business purposes, such as billing.
Application logs can be powerful as the application business logic has the most information about the user 
(e.g. identity, roles, permissions) and the context of the event (target, action, outcomes), and often this data 
is not available to either infrastructure devices, or even closely-related applications.  Application logging is an 
important feature of a production system, especially to support personnel and auditors, however it is often 
forgotten and is rarely described in sufficient detail in design/requirement documentation.  The level and con-
tent of security monitoring, alerting and reporting needs to be set during the requirements and design stage 
of projects, and should be proportionate to the information security risks. Application logging should also be 
consistent within the application, consistent across an organization’s application portfolio and use industry 
standards where relevant, so the logged event data can be consumed, correlated, analyzed and managed by 
a wide variety of systems.
All types of applications may send event data to remote systems, either directly over a network connection, or asyn-
chronously though a daily/weekly/monthly secure copy of the log to some centralized log collection and manage-
ment system (e.g. SIEM or SEM) or another application elsewhere.
If the information in the log is important, and could possibly be used for legal matters, consider how the source (log) 
can be verified, and how integrity and non-repudiation can be enforced.  Log data, temporary debug logs, and back-
ups/copies/extractions, must not be destroyed before the duration of the required data retention period, and must 
not be kept beyond this time. Legal, regulatory and contractual obligations may impact on these periods.
Server applications commonly write event log data to the file system or a database (SQL or NoSQL), however logging 
could be required on client devices such as applications installed on desktops and on mobile devices may use local 
storage and local databases.  Consider how this client logging data is transferred to the server.  
What to Review
When reviewing code modules from a logging point of view, some common issues to look out for include:
REVIEWING LOGGING CODE
161
 Reviewing Logging Code
• When using the file system, it is preferable to use a separate partition than those used by the operating system, 
other application files and user generated content
• For file-based logs, apply strict permissions concerning which users can access the directories, and the permissions 
of files within the directories
• In web applications, the logs should not be exposed in web-accessible locations, and if done so, should have 
restricted access and be configured with a plain text MIME type (not HTML)
• When using a database, it is preferable to utilize a separate database account that is only used for writing log 
data and which has very restrictive database, table, function and command permissions
• Consider what types of messages should be logged:
o Input validation failures e.g. protocol violations, unacceptable encodings, invalid parameter names and values
o Output validation failures e.g. database record set mismatch, invalid data encoding
o Authentication successes and failures
o Authorization (access control) failures
o Session management failures e.g. cookie session identification value modification
o Connection timings
• Consider what each log message should contain:
o Date and time, in some common format (also makes sense to ensure all nodes of an application are synced 
through something like NTP
o User performing the action
o Action being performed/attempted
o Information on the client, e.g. IP address, source port, user-agent
o External classifications e.g. NIST Security Content Automation Protocol (SCAP), Mitre Common Attack Pat-
tern Enumeration and Classification (CAPEC)
o Perform sanitization on all event data to prevent log injection attacks e.g. carriage return (CR), line feed (LF) 
and delimiter characters (and optionally to remove sensitive data)
• If writing to databases, read, understand and apply the SQL injection cheat sheet
• Ensure logging is implemented and enabled during application security, fuzz, penetration and performance testing
162
• Ensure logging cannot be used to deplete system resources, for example by filling up disk space or exceeding 
database transaction log space, leading to denial of service
• The logging mechanisms and collected event data must be protected from mis-use such as tampering in 
transit, and unauthorized access, modification and deletion once stored
• Store or copy log data to read-only media as soon as possible
• Consider what should not be logged: 
o Session identification values (consider replacing with a hashed value if needed to track session specific events)
o Sensitive personal data and some forms of personally identifiable information (PII)
o Authentication passwords (successful or unsuccessful)
o Database connection strings
o Keys
o Data of a higher security classification than the logging system is allowed to store
References
• See NIST SP 800-92 Guide to Computer Security Log Management for more guidance.
• Mitre Common Event Expression (CEE)
• PCISSC PCI DSS v2.0 Requirement 10 and PA-DSS v2.0 Requirement 4
• Other Common Log File System (CLFS), Microsoft
 Reviewing Logging Code
163
Error Handling
Proper error handling is important in two ways:
1. It may affect the state of the application. The initial failure to prevent the error may cause the application to traverse 