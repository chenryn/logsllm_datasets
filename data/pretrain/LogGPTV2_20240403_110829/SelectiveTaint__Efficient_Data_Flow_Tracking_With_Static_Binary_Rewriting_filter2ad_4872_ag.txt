Figure 7: The performance overhead of the tested benchmarks
Category
Sound Processing Utilities
Program
SoX 14.4.2
TinTin++ 2.01.6 Multiplayer Online Game Client
dcraw 9.28
ngiﬂib 0.4
Gravity 0.3.5
MP3Gain 1.5.2
NASM 2.14.02
Jhead 3.00
Nginx 1.4.0
Raw Image Decoder
GIF Format Decoding Library
Programming Language Interpreter
Audio Normalization Software
Assembler and Disassembler
Exif Jpeg Header Manipulation Tool
Web Server
CVE ID
Vulnerability
CVE-2019-8356
Buffer Overﬂow
CVE-2019-7629
Buffer Overﬂow
CVE-2018-19655
Buffer Overﬂow
CVE-2018-11575
Buffer Overﬂow
CVE-2017-1000437
Buffer Overﬂow
CVE-2017-14411
Buffer Overﬂow
Double Free
CVE-2019-8343
Integer Underﬂow CVE-2018-6612
Buffer Overﬂow
CVE-2013-2028
STATICTAINTALL
✓
✓
✓
✓
✓
✓
✓
✓
✓
SELECTIVETAINT
✓
✓
✓
✓
✓
✓
✓
✓
✓
Table 4: The tested vulnerable software and their vulnerabilities
each data object could hold. Dynamic information such as
concrete values from run-time could further help SELEC-
TIVETAINT. For instance, if we have some concrete inputs
for a function, the binary rewriting could be tailored to those
concrete inputs. In fact, recent taint improvement system Io-
dine [5] has used such a static and dynamic approach. Inspired
by Iodine, we could similarly elide unnecessary taint prop-
agation logic with the help from the dynamic information.
Context-aware instrumentation. Current binary instru-
mentation of SELECTIVETAINT is context-insensitive, i.e.,
SELECTIVETAINT instruments taint propagation logic
disregarding the calling context of the binary function.
However, we notice there could be cases that a function
may need taint propagation in some contexts but not others
(e.g., the function called from the beginning of program
execution to the ﬁrst taint introducing instruction). Therefore,
it could be an improvement if we make the instrumentation
context-aware or use multiple copies of the function (some
contains taint, and some never). We plan to validate whether
this could be a viable approach in one of our future works.
Improving static binary analysis. We have made several
assumptions about the binary code to ease our binary analysis,
e.g., we assume the code under analysis is not obfuscated
and we do not consider dynamic generated code, since
they are current obstacles and challenges for static binary
analysis in general. That is, any improvement from static
binary code analysis could beneﬁt SELECTIVETAINT. In
our implementation, we use Dyninst [7] and successfully
rewrite all binaries in our evaluation without encountering
corner cases described in Dyninst’s limitations. Future work
may include implementations using other binary rewriters
such as MULTIVERSE [6] and DDISASM [13].
Improving CFG reconstruction for a more precise alias
analysis. As we have seen in the soundness analysis of
SELECTIVETAINT (§4.3.2), improving the precision of alias
analysis and CFG reconstruction can improve the soundness
of SELECTIVETAINT. For instance, in instruction call eax
where there could be aliasing between formal parameters
and actual parameters, a precise alias analysis result would
greatly affect the control ﬂow targets and thus the CFG
reconstruction. Though we use the approaches in §4.1 and
§4.2 to improve the precision, a more precise alias analysis
can largely beneﬁt our analysis.
8 Related Work
Dynamic Data Flow Tracking (DDFT). Over the past
decades, many DDFT systems were built. DYTAN [11] is one
of the ﬁrst such a tool that allows customized taint analysis,
and it can also track implicit information ﬂows due to control
dependences. However, its performance overhead can be as
high as 50x when performing dynamic taint analysis with
both control- and data-ﬂow based propagation and 30x for
data-ﬂow based propagation alone. Saxena et al. [32] propose
1680    30th USENIX Security Symposium
USENIX Association
targzipbzip2scpcatcommcutgrepheadnlodptxshredtailtruncateuniqaverage0123456Slowdown(normalizedruntime)eximmemcachedproftpdlighttpdnginxaverage0123456nativenullpinlibdftStaticTaintAllSelectiveTainta static technique that recovers higher level structures from
x86 binaries and apply it to the context of taint tracking.
Unlike our approach, their stack analysis trades off analysis
accuracy over performance, e.g., stack analysis ignores global
and heap memory while VSA tracks global and heap memory.
Also, Saxena et al.’s analysis mainly enables optimizations
such as tag-sharing, but our analysis is the ﬁrst static taint
analysis to selectively instrument instructions. MINEMU [8]
aims to design efﬁcient emulator, using new memory layout
and SSE registers to improve the taint analysis. Being a
highly-optimized DDFT framework, libdft [17] shows a
faster performance than previous efforts; for instance, libdft
imposes about 4x slowdown for gzip when compressing or
decompressing ﬁles.
Recent efforts [5, 15, 16, 24, 25] further improve the
performance overhead of DDFT. For instance, Jee et al.
propose Taint Flow Algebra (TFA) [16] that separates the
program logic from data ﬂow tracking, transforms the data
ﬂow tracking logic into an intermediate representation,
and then performs classic compiler optimizations. SHAD-
OWREPLICA [15] runs DFT in parallel in a shadow thread
for each application thread and uses an off-line application
analysis phase which leverages both static and dynamic
analysis approaches to minimize the information needed to
communicate between both threads. TAINTPIPE [25] uses
pipelined symbolic taint analysis that both parallelizs and
pipelines taint analysis. STRAIGHTTAINT [24] logs control
ﬂow proﬁling and execution state when taint seeds were ﬁrst
introduced. Most recently, IODINE [5] uses an optimistic hy-
brid analysis which restricts predicated static analysis to elide
a runtime monitor only when it is proven to be a safe elision.
Different from our approach, Iodine is built atop LLVM IR,
which requires source code of the target application, whereas
SELECTIVETAINT is a binary only approach.
Binary Rewriting. There is also a large body of work
on static binary rewriting. Most recent efforts include
UROBOROS
[6],
[23], and DDISASM [13].
probabilistic disassembly
UROBOROS [37] is a tool which repeatedly dissembles the
executable such that the generated code could be reassembled
back to working binaries. RAMBLR [36] further analyzes the
assumptions of UROBOROS and ﬁnds multiple complex cor-
ner cases that must be considered in symbolization. RAMBLR
applies advanced static analyses, e.g., VSA, and achieves
great performance for a static rewriter. MULTIVERSE [6]
is the ﬁrst static binary rewriting tool that systematically
rewrites x86 COTS binaries without heuristics. Probabilistic
disassembly [23] uses probabilities to model the uncertainty
caused by the information loss during compilation and assem-
bling. Features such as data ﬂow and control ﬂow features
are leveraged to compute a probability for each address in
the code space to indicate the likelihood to be an instruction.
DDISASM [13] combines static analysis and heuristics in
Datalog and shows that Datalog’s inference process suits for
[37], RAMBLR [36], MULTIVERSE
the disassembling. In our implementation, while we could
have used the most recent work such as MULTIVERSE, we
use Dyninst [7] instead due to its rich APIs.
Alias Analysis on Binary. Prior efforts on binary alias anal-
ysis either introduce an IR and use Datalog to reason about
points-to relations [9], or introduce sets for values held at
each program point (e.g., abstract address sets [12], or sym-
bolic value sets [1]). The alias relation of two variables is
determined by whether the abstraction sets of these two vari-
ables intersect, e.g., intersection of abstract address sets [12],
symbolic value sets [1], and points-to predicates results [9],
respectively. Also, a number of earlier efforts (e.g., [1, 12])
do not further resolve indirect jumps in CFG and reconstruct
more CFG edges and yet this limits the analysis precision.
They also assume no system calls. However, system calls
may introduce uninitialized value sets into the system, and
the work by Debray et al. [12] uses less general sets of val-
ues, which is residue-based (module k), whereas we use all
possible values.
9 Conclusion
We have presented an efﬁcient static analysis based data
ﬂow tracking framework SELECTIVETAINT. Unlike previous
taint analysis that uses dynamic binary instrumentation, SE-
LECTIVETAINT is built atop static binary rewriting. The key
insight is to use VSA to identify the instructions that never
involve taint analysis, and then rewrite the rest to implement
the taint analysis. We have tested SELECTIVETAINT with
29 binary programs including 16 Unix utilities, ﬁve network
daemons, and eight vulnerable applications and observed a
superior performance, which is 1.7x faster than that of the
state of the art dynamic taint analysis tools.
Acknowledgment
We are grateful to our shepherd Vasileios P. Kemerlis as well
as the anonymous reviewers including those from the artifact
evaluation committee for their very constructive feedback.
We also would like to thank Haohuang Wen for his assistance
during the evaluation. This research was supported in part by
DARPA award N6600120C4020, NSF awards 1750809 and
1834215, and ONR award N00014-17-1-2995.
Availability
The source code of SELECTIVETAINT and also the
benchmark programs used during the evaluation have
been made public available at https://github.com/
OSUSecLab/SelectiveTaint.
USENIX Association
30th USENIX Security Symposium    1681
References
[1] W. Amme, P. Braun, E. Zehendner, and F. Thomasset. Data dependence analy-
sis of assembly code. In Proceedings of the 1998 International Conference on
Parallel Architectures and Compilation Techniques, PACT ’98, pages 340–347,
Washington, DC, USA, 1998. IEEE Computer Society.
[2] Q. N. Anh. Capstone: Next generation disassembly framework. In Proceedings
of the 2014 Black Hat USA, Black Hat USA ’14, 2014.
[3] G. Balakrishnan and T. Reps. Analyzing memory accesses in x86 executables.
In Proceedings of the 2004 International Conference on Compiler Construction,
CC ’04, pages 5–23, Berlin, Heidelberg, 2004. Springer Berlin Heidelberg.
[4] G. Balakrishnan and T. Reps. WYSINWYX: What You See is Not What You eX-
ecute. ACM Transactions on Programming Languages and Systems, 32(6):23:1–
23:84, Aug. 2010.
[5] S. Banerjee, D. Devecsery, P. M. Chen, and S. Narayanasamy. Iodine: Fast dy-
namic taint tracking using rollback-free optimistic hybrid analysis. In Proceed-
ings of the 40th IEEE Symposium on Security and Privacy, SP ’19, pages 712–
726, 2019.
[6] E. Bauman, Z. Lin, and K. Hamlen. Superset disassembly: Statically rewriting
x86 binaries without heuristics. In Proceedings of the 25th Annual Network and
Distributed System Security Symposium, NDSS ’18, San Diego, CA, Feb. 2018.
[7] A. R. Bernat and B. P. Miller. Anywhere, any-time binary instrumentation. In
Proceedings of the 10th ACM SIGPLAN-SIGSOFT Workshop on Program Anal-
ysis for Software Tools, PASTE ’11, pages 9–16, New York, NY, USA, 2011.
ACM.
[8] E. Bosman, A. Slowinska, and H. Bos. Minemu: The world’s fastest taint tracker.
In Proceedings of the 14th International Symposium on Recent Advances in In-
trusion Detection, RAID ’11, pages 1–20, Berlin, Heidelberg, 2011. Springer
Berlin Heidelberg.
[9] D. Brumley and J. Newsome. Alias analysis for assembly. Technical report,
Carnegie Mellon University, 2006.
[10] J. Caballero, H. Yin, Z. Liang, and D. Song. Polyglot: Automatic extraction
of protocol message format using dynamic binary analysis. In Proceedings of
the 14th ACM conference on Computer and Communications Security, CCS ’07,
pages 317–329. ACM, 2007.
[11] J. Clause, W. Li, and A. Orso. Dytan: A generic dynamic taint analysis frame-
work. In Proceedings of the 2007 International Symposium on Software Testing
and Analysis, ISSTA ’07, pages 196–206, New York, NY, USA, 2007. ACM.
[12] S. Debray, R. Muth, and M. Weippert. Alias analysis of executable code.
In
Proceedings of the 25th ACM SIGPLAN-SIGACT Symposium on Principles of
Programming Languages, POPL ’98, pages 12–24, New York, NY, USA, 1998.
ACM.
[13] A. Flores-Montoya and E. Schulte. Datalog disassembly.
In Proceedings of
the 29th USENIX Security Symposium, USENIX Security ’20, pages 1075–1092.
USENIX Association, Aug. 2020.
[14] W. G. J. Halfond, A. Orso, and P. Manolios. Using positive tainting and syntax-
In Proceedings of the 14th
aware evaluation to counter sql injection attacks.
ACM SIGSOFT International Symposium on Foundations of Software Engineer-
ing, FSE ’14, pages 175–185, New York, NY, USA, 2006. ACM.
[15] K. Jee, V. P. Kemerlis, A. D. Keromytis, and G. Portokalidis. ShadowReplica:
In Proceedings of the
Efﬁcient parallelization of dynamic data ﬂow tracking.
20th ACM Conference on Computer and Communications Security, CCS ’13,
pages 235–246, New York, NY, USA, 2013. ACM.
[16] K. Jee, G. Portokalidis, V. P. Kemerlis, S. Ghosh, D. I. August, and A. D.
Keromytis. A general approach for efﬁciently accelerating software-based dy-
namic data ﬂow tracking on commodity hardware. In Proceedings of the 19th
Annual Network and Distributed System Security Symposium, NDSS ’12, 2012.
libdft: Practical
dynamic data ﬂow tracking for commodity systems. In Proceedings of the 8th
ACM SIGPLAN/SIGOPS Conference on Virtual Execution Environments, VEE
’12, pages 121–132, New York, NY, USA, 2012. ACM.
[17] V. P. Kemerlis, G. Portokalidis, K. Jee, and A. D. Keromytis.
[18] K. H. Lee, X. Zhang, and D. Xu. High accuracy attack provenance via binary-
based execution partition. In Proceedings of the 20th Annual Network and Dis-
tributed System Security Symposium, NDSS ’13, 2013.
[19] Z. Lin, X. Jiang, D. Xu, and X. Zhang. Automatic protocol format reverse engi-
neering through context-aware monitored execution. In Proceedings of the 15th
Annual Network and Distributed System Security Symposium, NDSS ’08, San
Diego, CA, February 2008.
[20] Z. Lin, X. Zhang, and D. Xu. Automatic reverse engineering of data structures
from binary execution. In Proceedings of the 17th Network and Distributed Sys-
tem Security Symposium, NDSS’10, 2010.
[21] B. Livshits, M. Sridharan, Y. Smaragdakis, O. Lhoták, J. N. Amaral, B.-Y. E.
Chang, S. Z. Guyer, U. P. Khedker, A. Møller, and D. Vardoulakis. In defense of
soundiness: a manifesto. Communications of the ACM, 58(2):44–46, Jan. 2015.
[22] C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser, G. Lowney, S. Wallace, V. J.
Reddi, and K. Hazelwood. Pin: Building customized program analysis tools with
dynamic instrumentation. In Proceedings of the 2005 ACM SIGPLAN Confer-
ence on Programming Language Design and Implementation, PLDI ’05, pages
190–200, New York, NY, USA, 2005. ACM.
[23] K. Miller, Y. Kwon, Y. Sun, Z. Zhang, X. Zhang, and Z. Lin. Probabilistic disas-
sembly. In Proceedings of the 41st International Conference on Software Engi-
neering, ICSE ’19, page 1187–1198. IEEE Press, 2019.
[24] J. Ming, D. Wu, J. Wang, G. Xiao, and P. Liu. StraightTaint: Decoupled ofﬂine
In Proceedings of the 31st IEEE/ACM International
symbolic taint analysis.
Conference on Automated Software Engineering, ASE ’16, pages 308–319, New
York, NY, USA, 2016. ACM.
[25] J. Ming, D. Wu, G. Xiao, J. Wang, and P. Liu. TaintPipe: Pipelined symbolic
taint analysis. In Proceedings of the 24th USENIX Security Symposium, USENIX
Security ’15, pages 65–80, Washington, D.C., 2015. USENIX Association.
[26] P. Muntean, M. Fischer, G. Tan, Z. Lin, J. Grossklags, and C. Eckert. τCFI:
Type-assisted control ﬂow integrity for x86-64 binaries. In Proceedings of the
21st International Symposium on Research in Attacks, Intrusions, and Defenses,
RAID ’18, pages 423–444. Springer International Publishing, 2018.
[27] S. Nagy and M. Hicks. Full-speed fuzzing: Reducing fuzzing overhead through
coverage-guided tracing. In Proceedings of the 40th IEEE Symposium on Secu-
rity and Privacy, SP ’19, pages 787–802, May 2019.
[28] J. Newsome and D. Song. Dynamic taint analysis for automatic detection, analy-
sis, and signature generation of exploits on commodity software. In Proceedings
of the 12th Annual Network and Distributed Systems Security Symposium, NDSS
’05, 2005.
[29] A. Nguyen-Tuong, S. Guarnieri, D. Greene, J. Shirley, and D. Evans. Automat-
ically hardening web applications using precise tainting. In Proceedings of the
2005 IFIP International Information Security Conference, IFIP SEC ’05, pages
295–307, Boston, MA, 2005. Springer US.
[30] T. Pietraszek and C. V. Berghe. Defending against injection attacks through
context-sensitive string evaluation. In Proceedings of the 9th International Sym-
posium on Recent Advances in Intrusion Detection, RAID ’06, pages 124–145,
Berlin, Heidelberg, 2006. Springer Berlin Heidelberg.
[31] G. Ramalingam. The undecidability of aliasing. ACM Transactions on Program-
ming Languages and Systems, 16(5):1467–1471, Sept. 1994.
[32] P. Saxena, R. Sekar, and V. Puranik. Efﬁcient ﬁne-grained binary instrumentation
In Proceedings of the 2008 International
with applications to taint-tracking.
Symposium on Code Generation and Optimization, CGO ’08, page 74–83, New
York, NY, USA, 2008. ACM.
[33] Y. Shoshitaishvili, R. Wang, C. Salls, N. Stephens, M. Polino, A. Dutcher,
J. Grosen, S. Feng, C. Hauser, C. Kruegel, and G. Vigna. SoK: (State of) The
Art of War: Offensive Techniques in Binary Analysis. In Proceedings of the 37th
IEEE Symposium on Security and Privacy, SP ’16, 2016.
[34] N. Vachharajani, M. J. Bridges, J. Chang, R. Rangan, G. Ottoni, J. A. Blome,
G. A. Reis, M. Vachharajani, and D. I. August. RIFLE: An architectural frame-
In Proceedings of the 37th
work for user-centric information-ﬂow security.
Annual IEEE/ACM International Symposium on Microarchitecture, MICRO 37,
pages 243–254, Washington, DC, USA, 2004. IEEE Computer Society.
[35] V. van der Veen, E. Gökta¸s, M. Contag, A. Pawlowski, X. Chen, S. Rawat, H. Bos,
T. Holz, E. Athanasopoulos, and C. Giuffrida. A tough call: Mitigating advanced
code-reuse attacks at the binary level. In Proceedings of the 37th IEEE Sympo-
sium on Security and Privacy, SP ’16, pages 934–953, 2016.
[36] R. Wang, Y. Shoshitaishvili, A. Bianchi, A. Machiry, J. Grosen, P. Grosen,
C. Kruegel, and G. Vigna. Ramblr: Making reassembly great again. In Proceed-
ings of the 24th Annual Network and Distributed System Security Symposium,
NDSS ’17, 2017.
[37] S. Wang, P. Wang, and D. Wu. Reassembleable disassembling. In Proceedings
of the 24th USENIX Security Symposium, USENIX Security ’15, pages 627–642,
Washington, D.C., 2015. USENIX Association.
[38] J. Whaley and M. S. Lam. Cloning-based context-sensitive pointer alias analysis
In Proceedings of the ACM SIGPLAN 2004
using binary decision diagrams.
Conference on Programming Language Design and Implementation, PLDI ’04,
pages 131–144, New York, NY, USA, 2004. ACM.
[39] H. Yin, D. Song, M. Egele, C. Kruegel, and E. Kirda. Panorama: Capturing
system-wide information ﬂow for malware detection and analysis. In Proceed-
ings of the 14th ACM Conference on Computer and Communications Security,
CCS ’07, pages 116–127, New York, NY, USA, 2007. ACM.
[40] J. Zeng, Y. Fu, K. Miller, Z. Lin, X. Zhang, and D. Xu. Obfuscation-resilient
binary code reuse through trace-oriented programming. In Proceedings of the
20th ACM Conference on Computer and Communications Security, CCS ’13,
Berlin, Germany, Nov. 2013.
[41] D. Y. Zhu, J. Jung, D. Song, T. Kohno, and D. Wetherall. TaintEraser: Protecting
sensitive data leaks using application-level taint tracking. ACM SIGOPS Operat-
ing Systems Review, 45(1):142–154, Feb. 2011.
1682    30th USENIX Security Symposium
USENIX Association