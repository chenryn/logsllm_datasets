# 31 \| 瞧一瞧Linux：如何获取所有设备信息？你好，我是 LMOS。前面我们已经完成了 Cosmos的驱动设备的建立，还写好了一个真实的设备驱动。今天，我们就来看看 Linux 是如何管理设备的。我们将从 Linux如何组织设备开始，然后研究设备驱动相关的数据结构，最后我们还是要一起写一个Linux设备驱动实例，这样才能真正理解它。感受一下 Linux 下的设备信息Linux 的设计哲学就是一切皆文件，各种设备在 Linux系统下自然也是一个个文件。不过这个文件并不对应磁盘上的数据文件，而是对应着存在内存当中的设备文件。实际上，我们对设备文件进行操作，就等同于操作具体的设备。既然我们了解万事万物，都是从最直观的感受开始的，想要理解 Linux对设备的管理，自然也是同样的道理。那么 Linux设备文件在哪个目录下呢？其实现在我们在 /sys/bus目录下，就可以查看所有的设备了。Linux 用 BUS（总线）组织设备和驱动，我们在 /sys/bus 目录下输入 tree命令，就可以看到所有总线下的所有设备了，如下图所示。![](Images/2d45b6e4a7c53c0e56934cf207140ec8.png)savepage-src="https://static001.geekbang.org/resource/image/56/28/567588d1ca461ed56c4cd3447d9dff28.jpg?wh=990x1047"}Linux设备文件上图中，显示了部分 Linux设备文件，有些设备文件是链接到其它目录下文件，这不是重点，重点是你要在心中有这个目录层次结构，即**总线目录下有设备目录，设备目录下是设备文件**。数据结构我们接着刚才的图往下说，我们能感觉到 Linux的驱动模型至少有三个核心数据结构，分别是总线、设备和驱动，但是要像上图那样有层次化地组织它们，只有总线、设备、驱动这三个数据结构是不够的，还得有两个数据结构来组织它们，那就是kobject 和kset，下面我们就去研究它们。kobject 与 ksetkobject 和 kset 是构成 /sys目录下的目录节点和文件节点的核心，也是层次化组织总线、设备、驱动的核心数据结构，kobject、kset数据结构都能表示一个目录或者文件节点。下面我们先来研究一下 kobject数据结构，代码如下所示。    struct kobject {        const char      *name;           //名称，反映在sysfs中        struct list_head    entry;       //挂入kset结构的链表        struct kobject      *parent;     //指向父结构         struct kset     *kset;           //指向所属的kset        struct kobj_type    *ktype;        struct kernfs_node  *sd;         //指向sysfs文件系统目录项         struct kref     kref;            //引用计数器结构        unsigned int state_initialized:1;//初始化状态        unsigned int state_in_sysfs:1;   //是否在sysfs中        unsigned int state_add_uevent_sent:1;        unsigned int state_remove_uevent_sent:1;        unsigned int uevent_suppress:1;    };每一个 kobject，都对应着 /sys 目录下（其实是 sysfs 文件系统挂载在/sys 目录下） 的一个目录或者文件，目录或者文件的名字就是 kobject结构中的 name。我们从 kobject 结构中可以看出，它挂载在 kset 下，并且指向了 kset，那kset 是什么呢？我们来分析分析，它是 kobject结构的容器吗？其实是也不是，因为 kset 结构中本身又包含一个 kobject 结构，所以它既是kobject 的容器，同时本身还是一个 kobject。kset结构代码如下所示。    struct kset {        struct list_head list; //挂载kobject结构的链表        spinlock_t list_lock; //自旋锁        struct kobject kobj;//自身包含一个kobject结构        const struct kset_uevent_ops *uevent_ops;//暂时不关注    } __randomize_layout;看到这里你应该知道了，kset 不仅仅自己是个 kobject，还能挂载多个kobject，这说明 kset 是 kobject 的集合容器。在 Linux内核中，至少有两个顶层kset，代码如下所示。    struct kset *devices_kset;//管理所有设备    static struct kset *bus_kset;//管理所有总线    static struct kset *system_kset;    int __init devices_init(void)    {        devices_kset = kset_create_and_add("devices", &device_uevent_ops, NULL);//建立设备kset        return 0;    }    int __init buses_init(void)    {        bus_kset = kset_create_and_add("bus", &bus_uevent_ops, NULL);//建立总线kset        if (!bus_kset)            return -ENOMEM;        system_kset = kset_create_and_add("system", NULL, &devices_kset->kobj);//在设备kset之下建立system的kset        if (!system_kset)            return -ENOMEM;        return 0;    }我知道，你可能很难想象许多个 kset 和 kobject在逻辑上形成的层次结构，所以我为你画了一幅图，你可以结合这张示意图理解这个结构。![](Images/1f8f030d8ec08ede18fc481223962a62.png)savepage-src="https://static001.geekbang.org/resource/image/bc/da/bcd9216d04b1f2ec6yy67ddf18052fda.jpg?wh=5039x4605"}kset与kobject上图中展示了一个类似文件目录的结构，这正是 kset 与 kobject设计的目标之一。kset 与 kobject结构只是基础数据结构，但是仅仅只有它的话，也就只能实现这个层次结构，其它的什么也不能干，根据我们以往的经验可以猜出，kset与 kobject结构肯定是嵌入到更高级的数据结构之中使用，下面我们继续探索。总线kset、kobject 结构只是开胃菜，这个基础了解了，我们还要回到研究 Linux设备与驱动的正题上。我们之前说过了，Linux用总线组织设备和驱动，由此可见总线是 Linux 设备的基础，它可以表示 CPU与设备的连接，那么总线的数据结构是什么样呢？我们一起来看看。Linux 把总线抽象成 bus_type结构，代码如下所示。    struct bus_type {        const char      *name;//总线名称        const char      *dev_name;//用于列举设备，如（"foo%u", dev->id）        struct device       *dev_root;//父设备        const struct attribute_group **bus_groups;//总线的默认属性        const struct attribute_group **dev_groups;//总线上设备的默认属性        const struct attribute_group **drv_groups;//总线上驱动的默认属性        //每当有新的设备或驱动程序被添加到这个总线上时调用        int (*match)(struct device *dev, struct device_driver *drv);        //当一个设备被添加、移除或其他一些事情时被调用产生uevent来添加环境变量。        int (*uevent)(struct device *dev, struct kobj_uevent_env *env);        //当一个新的设备或驱动程序添加到这个总线时被调用，并回调特定驱动程序探查函数，以初始化匹配的设备        int (*probe)(struct device *dev);        //将设备状态同步到软件状态时调用        void (*sync_state)(struct device *dev);        //当一个设备从这个总线上删除时被调用        int (*remove)(struct device *dev);        //当系统关闭时被调用        void (*shutdown)(struct device *dev);        //调用以使设备重新上线（在下线后）        int (*online)(struct device *dev);        //调用以使设备离线，以便热移除。可能会失败。        int (*offline)(struct device *dev);        //当这个总线上的设备想进入睡眠模式时调用        int (*suspend)(struct device *dev, pm_message_t state);        //调用以使该总线上的一个设备脱离睡眠模式        int (*resume)(struct device *dev);        //调用以找出该总线上的一个设备支持多少个虚拟设备功能        int (*num_vf)(struct device *dev);        //调用以在该总线上的设备配置DMA        int (*dma_configure)(struct device *dev);        //该总线的电源管理操作，回调特定的设备驱动的pm-ops        const struct dev_pm_ops *pm;        //此总线的IOMMU具体操作，用于将IOMMU驱动程序实现到总线上        const struct iommu_ops *iommu_ops;        //驱动核心的私有数据，只有驱动核心能够接触这个        struct subsys_private *p;        struct lock_class_key lock_key;        //当探测或移除该总线上的一个设备时，设备驱动核心应该锁定该设备        bool need_parent_lock;    };可以看出，上面代码的 bus_type结构中，包括总线名字、总线属性，还有操作该总线下所有设备通用操作函数的指针，其各个函数的功能我在代码注释中已经写清楚了。从这一点可以发现，**总线不仅仅是组织设备和驱动的容器，还是同类设备的共有功能的抽象层。**下面我们来看看subsys_private，它是总线的驱动核心的私有数据，其中有我们想知道的秘密，代码如下所示。    //通过kobject找到对应的subsys_private    #define to_subsys_private(obj) container_of(obj, struct subsys_private, subsys.kobj)    struct subsys_private {        struct kset subsys;//定义这个子系统结构的kset        struct kset *devices_kset;//该总线的"设备"目录，包含所有的设备        struct list_head interfaces;//总线相关接口的列表        struct mutex mutex;//保护设备，和接口列表        struct kset *drivers_kset;//该总线的"驱动"目录，包含所有的驱动        struct klist klist_devices;//挂载总线上所有设备的可迭代链表        struct klist klist_drivers;//挂载总线上所有驱动的可迭代链表        struct blocking_notifier_head bus_notifier;        unsigned int drivers_autoprobe:1;        struct bus_type *bus;   //指向所属总线        struct kset glue_dirs;        struct class *class;//指向这个结构所关联类结构的指针    };看到这里，你应该明白 kset 的作用了，我们通过 bus_kset 可以找到所有的kset，通过 kset 又能找到 subsys_private，再通过 subsys_private就可以找到总线了，也可以找到该总线上所有的设备与驱动。设备虽然 Linux 抽象出了总线结构，但是 Linux还需要表示一个设备，下面我们来探索 Linux是如何表示一个设备的。其实，在 Linux系统中设备也是一个数据结构，里面包含了一个设备的所有信息。代码如下所示。    struct device {        struct kobject kobj;        struct device       *parent;//指向父设备        struct device_private   *p;//设备的私有数据        const char      *init_name; //设备初始化名字        const struct device_type *type;//设备类型        struct bus_type *bus;  //指向设备所属总线        struct device_driver *driver;//指向设备的驱动        void        *platform_data;//设备平台数据        void        *driver_data;//设备驱动的私有数据        struct dev_links_info   links;//设备供应商链接        struct dev_pm_info  power;//用于设备的电源管理        struct dev_pm_domain    *pm_domain;//提供在系统暂停时执行调用    #ifdef CONFIG_GENERIC_MSI_IRQ        struct list_head    msi_list;//主机的MSI描述符链表    #endif        struct dev_archdata archdata;        struct device_node  *of_node; //用访问设备树节点        struct fwnode_handle    *fwnode; //设备固件节点        dev_t           devt;   //用于创建sysfs "dev"        u32         id; //设备实例id        spinlock_t      devres_lock;//设备资源链表锁        struct list_head    devres_head;//设备资源链表        struct class        *class;//设备的类        const struct attribute_group **groups;  //可选的属性组        void    (*release)(struct device *dev);//在所有引用结束后释放设备        struct iommu_group  *iommu_group;//该设备属于的IOMMU组        struct dev_iommu    *iommu;//每个设备的通用IOMMU运行时数据    };device 结构很大，这里删除了我们不需要关心的内容。另外，我们看到device 结构中同样包含了 kobject 结构，这使得设备可以加入 kset 和 kobject组建的层次结构中。device结构中有总线和驱动指针，这能帮助设备找到自己的驱动程序和总线。驱动有了设备结构，还需要有设备对应的驱动，Linux是如何表示一个驱动的呢？同样也是一个数据结构，其中包含了驱动程序的相关信息。其实在device 结构中我们就看到了，就是 device_driver结构，代码如下。    struct device_driver {        const char      *name;//驱动名称        struct bus_type     *bus;//指向总线        struct module       *owner;//模块持有者        const char      *mod_name;//用于内置模块        bool suppress_bind_attrs;//禁用通过sysfs的绑定/解绑        enum probe_type probe_type;//要使用的探查类型（同步或异步）        const struct of_device_id   *of_match_table;//开放固件表        const struct acpi_device_id *acpi_match_table;//ACPI匹配表        //被调用来查询一个特定设备的存在        int (*probe) (struct device *dev);        //将设备状态同步到软件状态时调用        void (*sync_state)(struct device *dev);        //当设备被从系统中移除时被调用，以便解除设备与该驱动的绑定        int (*remove) (struct device *dev);        //关机时调用，使设备停止        void (*shutdown) (struct device *dev);        //调用以使设备进入睡眠模式，通常是进入一个低功率状态        int (*suspend) (struct device *dev, pm_message_t state);        //调用以使设备从睡眠模式中恢复        int (*resume) (struct device *dev);        //默认属性        const struct attribute_group **groups;        //绑定设备的属性        const struct attribute_group **dev_groups;        //设备电源操作        const struct dev_pm_ops *pm;        //当sysfs目录被写入时被调用        void (*coredump) (struct device *dev);        //驱动程序私有数据        struct driver_private *p;    };    struct driver_private {        struct kobject kobj;        struct klist klist_devices;//驱动管理的所有设备的链表        struct klist_node knode_bus;//加入bus链表的节点        struct module_kobject *mkobj;//指向用kobject管理模块节点        struct device_driver *driver;//指向驱动本身    };在 device_driver结构中，包含了驱动程序的名字、驱动程序所在模块、设备探查和电源相关的回调函数的指针。在driver_private 结构中同样包含了 kobject结构，用于组织所有的驱动，还指向了驱动本身，你发现没有，bus_type 中的subsys_private结构的机制如出一辙。文件操作函数前面我们学习的都是 Linux驱动程序的核心数据结构，我们很少用到，只是为了让你了解最基础的原理。其实，在 Linux 系统中提供了更为高级的封装，Linux将设备分成几类分别是：字符设备、块设备、网络设备以及杂项设备。具体情况你可以参考我后面梳理的图表。![](Images/d2e59a2aa687694433972ce8d8869ae2.png)savepage-src="https://static001.geekbang.org/resource/image/a4/79/a4104a41c67d94f6c9a7de94a05c6a79.jpg?wh=1554x683"}设备类型一览表这些类型的设备的数据结构，都会直接或者间接包含基础的 device结构，我们以杂项设备为例子研究一下，Linux 用 miscdevice结构表示一个杂项设备，代码如下。    struct miscdevice  {        int minor;//设备号        const char *name;//设备名称        const struct file_operations *fops;//文件操作函数结构        struct list_head list;//链表        struct device *parent;//指向父设备的device结构        struct device *this_device;//指向本设备的device结构        const struct attribute_group **groups;        const char *nodename;//节点名字        umode_t mode;//访问权限    };miscdevice结构就是一个杂项设备，它一般在驱动程序代码文件中静态定义。我们清楚地看见有个this_device 指针，它指向下层的、属于这个杂项设备的 device结构。 但是这里重点是 **file_operations结构**，设备一经注册，就会在 sys相关的目录下建立设备对应的文件结点，对这个文件结点打开、读写等操作，最终会调用到驱动程序对应的函数，而对应的函数指针就保存在file_operations结构中，我们现在来看看这个结构。    struct file_operations {        struct module *owner;//所在的模块        loff_t (*llseek) (struct file *, loff_t, int);//调整读写偏移        ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);//读        ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);//写        int (*mmap) (struct file *, struct vm_area_struct *);//映射        int (*open) (struct inode *, struct file *);//打开        int (*flush) (struct file *, fl_owner_t id);//刷新        int (*release) (struct inode *, struct file *);//关闭    } __randomize_layout;file_operations 结构中的函数指针有 31个，我删除了我们不熟悉的函数指针，我们了解原理，不需要搞清楚所有函数指针的功能。那么，Linux 如何调用到这个 file_operations结构中的函数呢？我以打开操作为例给你讲讲，Linux 的打开系统调用接口会调用filp_open 函数，filp_open函数的调用路径如下所示。    //filp_open    //file_open_name    //do_filp_open    //path_openat    static int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)    {        struct path path;        int error = path_lookupat(nd, flags, &path);//解析文件路径得到文件inode节点        if (!error) {            audit_inode(nd->name, path.dentry, 0);            error = vfs_open(&path, file);//vfs层打开文件接口            path_put(&path);        }        return error;    }    int vfs_open(const struct path *path, struct file *file)    {        file->f_path = *path;        return do_dentry_open(file, d_backing_inode(path->dentry), NULL);    }    static int do_dentry_open(struct file *f, struct inode *inode,int (*open)(struct inode *, struct file *))    {        //略过我们不想看的代码        f->f_op = fops_get(inode->i_fop);//获取文件节点的file_operations        if (!open)//如果open为空则调用file_operations结构中的open函数            open = f->f_op->open;        if (open) {            error = open(inode, f);        }        //略过我们不想看的代码        return 0;    }看到这里，我们就知道了，file_operations 结构的地址存在一个文件的inode 结构中。在 Linux 系统中，都是用 inode结构表示一个文件，不管它是数据文件还是设备文件。到这里，我们已经清楚了文件操作函数以及它的调用流程。驱动程序实例我们想要真正理解 Linux设备驱动，最好的方案就是写一个真实的驱动程序实例。下面我们一起应用前面的基础，结合Linux提供的驱动程序开发接口，一起实现一个真实驱动程序。这个驱动程序的主要工作，就是获取所有总线和其下所有设备的名字。为此我们需要先了解驱动程序的整体框架，接着建立我们总线和设备，然后实现驱动程序的打开、关闭，读写操作函数，最后我们写个应用程序，来测试我们的驱动程序。驱动程序框架Linux内核的驱动程序是在一个可加载的内核模块中实现，可加载的内核模块只需要两个函数和模块信息就行，但是我们要在模块中实现总线和设备驱动，所以需要更多的函数和数据结构，它们的代码如下。    #define DEV_NAME  "devicesinfo"    #define BUS_DEV_NAME  "devicesinfobus"    static int misc_find_match(struct device *dev, void *data)    {        printk(KERN_EMERG "device name is:%s\n", dev->kobj.name);        return 0;    }    //对应于设备文件的读操作函数    static ssize_t misc_read (struct file *pfile, char __user *buff, size_t size, loff_t *off)    {        printk(KERN_EMERG "line:%d,%s is call\n",__LINE__,__FUNCTION__);        return 0;    }    //对应于设备文件的写操作函数    static ssize_t misc_write(struct file *pfile, const char __user *buff, size_t size, loff_t *off)    {        printk(KERN_EMERG "line:%d,%s is call\n",__LINE__,__FUNCTION__);            return 0;    }    //对应于设备文件的打开操作函数    static int  misc_open(struct inode *pinode, struct file *pfile)    {        printk(KERN_EMERG "line:%d,%s is call\n",__LINE__,__FUNCTION__);        return 0;    }     //对应于设备文件的关闭操作函数    static int misc_release(struct inode *pinode, struct file *pfile)    {        printk(KERN_EMERG "line:%d,%s is call\n",__LINE__,__FUNCTION__);        return 0;    }    static int devicesinfo_bus_match(struct device *dev, struct device_driver *driver)    {            return !strncmp(dev->kobj.name, driver->name, strlen(driver->name));    }    //对应于设备文件的操作函数结构    static const  struct file_operations misc_fops = {        .read     = misc_read,        .write    = misc_write,        .release  = misc_release,        .open     = misc_open,    };    //misc设备的结构    static struct miscdevice  misc_dev =  {        .fops  =  &misc_fops,         //设备文件操作方法        .minor =  255,                //次设备号        .name  =  DEV_NAME,           //设备名/dev/下的设备节点名    };    //总线结构    struct bus_type devicesinfo_bus = {            .name = BUS_DEV_NAME, //总线名字            .match = devicesinfo_bus_match, //总线match函数指针    };    //内核模块入口函数    static int __init miscdrv_init(void)    {        printk(KERN_EMERG "INIT misc\n")；        return 0;    }    //内核模块退出函数    static void  __exit miscdrv_exit(void)    {        printk(KERN_EMERG "EXIT,misc\n");    }    module_init(miscdrv_init);//申明内核模块入口函数    module_exit(miscdrv_exit);//申明内核模块退出函数    MODULE_LICENSE("GPL");//模块许可    MODULE_AUTHOR("LMOS");//模块开发者一个最简单的驱动程序框架的内核模块就写好了，该有的函数和数据结构都有了，那些数据结构都是静态定义的，它们的内部字段我们在前面也已经了解了。这个模块一旦加载就会执行miscdrv_init 函数，卸载时就会执行 miscdrv_exit函数。 建立设备Linux系统也提供了很多专用接口函数，用来建立总线和设备。下面我们先来建立一个总线，然后在总线下建立一个设备。首先来说说建立一个总线，Linux 系统提供了一个 bus_register函数向内核注册一个总线，相当于建立了一个总线，我们需要在 miscdrv_init函数中调用它，代码如下所示。    static int __init miscdrv_init(void)    {        printk(KERN_EMERG "INIT misc\n");        busok = bus_register(&devicesinfo_bus);//注册总线        return 0;    }bus_register 函数会在系统中注册一个总线，所需参数就是总线结构的地址(&devicesinfo_bus)，返回非 0 表示注册失败。现在我们来看看，在bus_register函数中都做了些什么事情，代码如下所示。    int bus_register(struct bus_type *bus)    {        int retval;        struct subsys_private *priv;        //分配一个subsys_private结构        priv = kzalloc(sizeof(struct subsys_private), GFP_KERNEL);        //bus_type和subsys_private结构互相指向        priv->bus = bus;        bus->p = priv;        //把总线的名称加入subsys_private的kobject中        retval = kobject_set_name(&priv->subsys.kobj, "%s", bus->name);        priv->subsys.kobj.kset = bus_kset;//指向bus_kset        //把subsys_private中的kset注册到系统中        retval = kset_register(&priv->subsys);        //建立总线的文件结构在sysfs中        retval = bus_create_file(bus, &bus_attr_uevent);        //建立subsys_private中的devices和drivers的kset        priv->devices_kset = kset_create_and_add("devices", NULL,                             &priv->subsys.kobj);        priv->drivers_kset = kset_create_and_add("drivers", NULL,                             &priv->subsys.kobj);        //建立subsys_private中的devices和drivers链表，用于属于总线的设备和驱动        klist_init(&priv->klist_devices, klist_devices_get, klist_devices_put);        klist_init(&priv->klist_drivers, NULL, NULL);        return 0;    }我删除了很多你不用关注的代码，看到这里，你应该知道总线是怎么通过subsys_private 把设备和驱动关联起来的（通过 bus_type 和 subsys_private结构互相指向），下面我们看看怎么建立设备。我们这里建立一个 misc杂项设备。misc 杂项设备需要定一个数据结构，然后调用 misc杂项设备注册接口函数，代码如下。    #define DEV_NAME  "devicesinfo"    static const  struct file_operations misc_fops = {        .read     = misc_read,        .write    = misc_write,        .release  = misc_release,        .open     = misc_open,    };    static struct miscdevice  misc_dev =  {        .fops  =  &misc_fops,         //设备文件操作方法        .minor =  255,                //次设备号        .name  =  DEV_NAME,           //设备名/dev/下的设备节点名    };    static int __init miscdrv_init(void)    {        misc_register(&misc_dev);//注册misc杂项设备        printk(KERN_EMERG "INIT misc busok\n");        busok = bus_register(&devicesinfo_bus);//注册总线        return 0;    }上面的代码中，静态定义了 miscdevice 结构的变量 misc_dev，miscdevice结构我们在前面已经了解过了，最后调用 misc_register 函数注册了 misc杂项设备。 misc_register函数到底做了什么，我们一起来看看，代码如下所示。    int misc_register(struct miscdevice *misc)    {        dev_t dev;        int err = 0;        bool is_dynamic = (misc->minor == MISC_DYNAMIC_MINOR);        INIT_LIST_HEAD(&misc->list);        mutex_lock(&misc_mtx);        if (is_dynamic) {//minor次设备号如果等于255就自动分配次设备            int i = find_first_zero_bit(misc_minors, DYNAMIC_MINORS);            if (i >= DYNAMIC_MINORS) {                err = -EBUSY;                goto out;            }            misc->minor = DYNAMIC_MINORS - i - 1;            set_bit(i, misc_minors);        } else {//否则检查次设备号是否已经被占有            struct miscdevice *c;            list_for_each_entry(c, &misc_list, list) {                if (c->minor == misc->minor) {                    err = -EBUSY;                    goto out;                }            }        }        dev = MKDEV(MISC_MAJOR, misc->minor);//合并主、次设备号        //建立设备        misc->this_device =            device_create_with_groups(misc_class, misc->parent, dev,                          misc, misc->groups, "%s", misc->name);        //把这个misc加入到全局misc_list链表        list_add(&misc->list, &misc_list);     out:        mutex_unlock(&misc_mtx);        return err;    }可以看出，misc_register 函数只是负责分配设备号，以及把 miscdev加入链表，真正的核心工作由 device_create_with_groups函数来完成，代码如下所示。    struct device *device_create_with_groups(struct class *class,                         struct device *parent, dev_t devt,void *drvdata,const struct attribute_group **groups,const char *fmt, ...)    {        va_list vargs;        struct device *dev;        va_start(vargs, fmt);        dev = device_create_groups_vargs(class, parent, devt, drvdata, groups,fmt, vargs);        va_end(vargs);        return dev;    }    struct device *device_create_groups_vargs(struct class *class, struct device *parent, dev_t devt, void *drvdata,const struct attribute_group **groups,const char *fmt, va_list args)    {        struct device *dev = NULL;        int retval = -ENODEV;        dev = kzalloc(sizeof(*dev), GFP_KERNEL);//分配设备结构的内存空间        device_initialize(dev);//初始化设备结构        dev->devt = devt;//设置设备号        dev->class = class;//设置设备类        dev->parent = parent;//设置设备的父设备        dev->groups = groups;////设置设备属性        dev->release = device_create_release;        dev_set_drvdata(dev, drvdata);//设置miscdev的地址到设备结构中        retval = kobject_set_name_vargs(&dev->kobj, fmt, args);//把名称设置到设备的kobjext中去        retval = device_add(dev);//把设备加入到系统中        if (retval)            goto error;        return dev;//返回设备    error:        put_device(dev);        return ERR_PTR(retval);    }到这里，misc 设备的注册就搞清楚了，下面我们来测试一下看看结果，看看Linux系统是不是多了一个总线和设备。你可以在本课程的代码目录中，执行 make 指令，就会产生一个 miscdvrv.ko内核模块文件，我们把这个模块文件加载到 Linux系统中就行了。为了看到效果，我们还必须要做另一件事情。 在终端中用 sudo cat/proc/kmsg 指令读取 /proc/kmsg 文件，该文件是内核 prink函数输出信息的文件。指令如下所示。    #第一步在终端中执行如下指令    sudo cat /proc/kmsg    #第二步在另一个终端中执行如下指令    make    sudo insmod miscdrv.ko    #不用这个模块了可以用以下指令卸载    sudo rmmod miscdrv.koinsmod 指令是加载一个内核模块，一旦加载成功就会执行 miscdrv_init函数。如果不出意外，你在终端中会看到如下图所示的情况。![](Images/1df5519814fb3d89da24c74a766657cf.png)savepage-src="https://static001.geekbang.org/resource/image/93/3b/93a929ea1218c7f934713fbf03ba643b.jpg?wh=846x449"}驱动测试这说明我们设备已经建立了，你应该可以在 /dev 目录看到一个 devicesinfo文件，同时你在 /sys/bus/ 目录下也可以看到一个 devicesinfobus文件。这就是我们建立的设备和总线的文件节点的名称。打开、关闭、读写函数建立了设备和总线，有了设备文件节点，应用程序就可以打开、关闭以及读写这个设备文件了。虽然现在确实可以操作设备文件了，只不过还不能完成任何实际功能，因为我们只是写好了框架函数，所以我们下面就去写好并填充这些框架函数，代码如下所示。    //打开    static int  misc_open(struct inode *pinode, struct file *pfile)    {        printk(KERN_EMERG "line:%d,%s is call\n",__LINE__,__FUNCTION__);//打印这个函数所在文件的行号和名称        return 0;    }    //关闭     static int misc_release(struct inode *pinode, struct file *pfile)    {        printk(KERN_EMERG "line:%d,%s is call\n",__LINE__,__FUNCTION__);//打印这个函数所在文件的行号和名称        return 0;    }    //写    static ssize_t misc_write(struct file *pfile, const char __user *buff, size_t size, loff_t *off)    {        printk(KERN_EMERG "line:%d,%s is call\n",__LINE__,__FUNCTION__);//打印这个函数所在文件的行号和名称            return 0;    }以上三个函数，仍然没干什么实际工作，就是打印该函数所在文件的行号和名称，然后返回0 就完事了。回到前面，我们的目的是要获取 Linux中所有总线上的所有设备，所以在读函数中来实现是合理的。具体实现的代码如下所示。    #define to_subsys_private(obj) container_of(obj, struct subsys_private, subsys.kobj)//从kobject上获取subsys_private的地址    struct kset *ret_buskset(void)    {        struct subsys_private *p;        if(busok)            return NULL;        if(!devicesinfo_bus.p)            return NULL;        p = devicesinfo_bus.p;        if(!p->subsys.kobj.kset)            return NULL;        //返回devicesinfo_bus总线上的kset，正是bus_kset        return p->subsys.kobj.kset;    }    static int misc_find_match(struct device *dev, void *data)    {        struct bus_type* b = (struct bus_type*)data;        printk(KERN_EMERG "%s---->device name is:%s\n", b->name, dev->kobj.name);//打印总线名称和设备名称        return 0;    }    static ssize_t misc_read (struct file *pfile, char __user *buff, size_t size, loff_t *off)    {        struct kobject* kobj;        struct kset* kset;        struct subsys_private* p;        kset = ret_buskset();//获取bus_kset的地址        if(!kset)            return 0;        printk(KERN_EMERG "line:%d,%s is call\n",__LINE__,__FUNCTION__);//打印这个函数所在文件的行号和名称        //扫描所有总线的kobject        list_for_each_entry(kobj, &kset->list, entry)        {            p = to_subsys_private(kobj);            printk(KERN_EMERG "Bus name is:%s\n",p->bus->name);            //遍历具体总线上的所有设备            bus_for_each_dev(p->bus, NULL, p->bus, misc_find_match);        }        return 0;    }正常情况下，我们是不能获取 bus_kset地址的，它是所有总线的根，包含了所有总线的 kobject，Linux 为了保护bus_kset，并没有在 bus_type 结构中直接包含 kobject，而是让总线指向一个subsys_private 结构，在其中包含了 kobject结构。 所以，我们要注册一个总线，这样就能拔出萝卜带出泥，得到bus_kset，根据它又能找到所有 subsys_private 结构中的 kobject，接着找到subsys_private 结构，反向查询到 bus_type结构的地址。然后调用 Linux 提供的 bus_for_each_dev函数，就可以遍历一个总线上的所有设备，它每遍历到一个设备，就调用一个函数，这个函数是用参数的方式传给它的，在我们代码中就是misc_find_match 函数。在调用 misc_find_match函数时，会把一个设备结构的地址和另一个指针作为参数传递进来。最后就能打印每个设备的名称了。测试驱动驱动程序已经写好，加载之后会自动建立设备文件，但是驱动程序不会主动工作，我们还需要写一个应用程序，对设备文件进行读写，才能测试驱动。我们这里这个驱动对打开、关闭、写操作没有什么实际的响应，但是只要一读就会打印所有设备的信息了。下面我们来写好这个应用，代码如下所示。    #include     #include     #include     #include     #include     #include     #include     #define DEV_NAME "/dev/devicesinfo"    int main(void)    {        char buf[] = {0, 0, 0, 0};        int fd;        //打开设备文件        fd = open(DEV_NAME, O_RDWR);        if (fd rde_mstart=(void*)blkp;        rfsexp->rde_msize=blksz;        //把rfsdevext_t结构的地址放入device_t 结构的dev_extdata字段中，这里dev_extdata字段就起作用了        devp->dev_extdata=(void*)rfsexp;.        return DFCOKSTUS;    }上述代码中，new_rfsdevext_mmblk 函数分配了一个内存空间和一个rfsdevext_t 结构实例变量，rfsdevext_t结构中保存了内存空间的地址和大小。而 rfsdevext_t 结构的地址放在了device_t 结构的 dev_extdata字段中。 剩下的就是建立文件系统设备了，我们在文件系统驱动程序的 rfs_entry函数中，通过后面这段代码完成这个功能。    void rfs_set_device(device_t* devp,driver_t* drvp)    {        //设备类型为文件系统类型        devp->dev_id.dev_mtype = FILESYS_DEVICE;         devp->dev_id.dev_stype = 0;        devp->dev_id.dev_nr = 0;        //设备名称为rfs        devp->dev_name = "rfs";        return;    }    drvstus_t rfs_entry(driver_t* drvp,uint_t val,void* p)    {        //分配device_t结构并对其进行初级初始化        device_t* devp = new_device_dsc();        rfs_set_driver(drvp);        rfs_set_device(devp,drvp);        //分配模拟储存设备的内存空间        if(new_rfsdevext_mmblk(devp,FSMM_BLK) == DFCERRSTUS){……}        //把设备加入到驱动程序之中        if(krldev_add_driver(devp,drvp) == DFCERRSTUS){……}        //向内核注册设备        if(krlnew_device(devp)==DFCERRSTUS){……}        return DFCOKSTUS;    }其实这和我们之前的写 systick驱动程序的套路差不多，只不过这里需要分配一个模拟储存设备的空间，并把它放在device_t 结构相关的字段中。**还有很重要的一点是，这个设备类型我们要在 rfs_set_device函数把它设置好，设置成文件系统类型。**需要注意的是要把 rfs_entry函数放在驱动表中，文件系统程序才可以运行，下面我们就把这个 rfs_entry函数，放入驱动表中，代码如下所示。    //cosmos/kernel/krlglobal.c    KRL_DEFGLOB_VARIABLE(drventyexit_t,osdrvetytabl)[]={systick_entry,rfs_entry,NULL};有了上述代码，Cosmos 在启动的时候，在 init_krldriver 函数中就会运行rfs_entry 函数。从名字就能看出 rfs_entry 函数的功能，这是 rfs文件系统设备驱动程序的入口函数，它一旦执行，就会建立文件系统设备。文件系统系统格式化我们经常听说格式化硬盘、格式化 U盘，可以把设备上的数据全部清空，事实是格式化操作并不是把设备上所有的空间都清零，而是在这个设备上重建了文件系统用于管理文件的那一整套数据结构。这也解释了为什么格式化后的设备，还能通过一些反删除软件找回一些文件。在储存设备上创建文件系统，其实就是执行这个格式化操作，即重建文件系统的数据结构。那么接下来，我们就从建立文件系统的超级块开始，然后建立用于管理储存设备空间的位图，最后建立根目录，这样才能最终实现在储存设备上创建文件系统。建立超级块我们首先来建立文件系统的超级块。建立超级块其实非常简单，就是初始化超级块的数据结构，然后把它写入到储存设备中的第一块逻辑储存块。下面我们一起写代码来实现，如下所示。    void *new_buf(size_t bufsz)    {        return (void *)krlnew(bufsz);//分配缓冲区    }    void del_buf(void *buf, size_t bufsz)    {        krldelete((adr_t)buf, bufsz)//释放缓冲区        return;    }    void rfssublk_t_init(rfssublk_t* initp)    {        krlspinlock_init(&initp->rsb_lock);        initp->rsb_mgic = 0x142422;//标志就是一个数字而已，无其它意义        initp->rsb_vec = 1;//文件系统版本为1        initp->rsb_flg = 0;        initp->rsb_stus = 0;        initp->rsb_sz = sizeof(rfssublk_t);//超级块本身的大小        initp->rsb_sblksz = 1;//超级块占用多少个逻辑储存块        initp->rsb_dblksz = FSYS_ALCBLKSZ;//逻辑储存块的大小为4KB        //位图块从第1个逻辑储存块开始，超级块占用第0个逻辑储存块        initp->rsb_bmpbks = 1;        initp->rsb_bmpbknr = 0;        initp->rsb_fsysallblk = 0;        rfsdir_t_init(&initp->rsb_rootdir);//初始化根目录        return;    }    bool_t create_superblk(device_t *devp)    {        void *buf = new_buf(FSYS_ALCBLKSZ);//分配4KB大小的缓冲区，清零        hal_memset(buf, 0, FSYS_ALCBLKSZ);        //使rfssublk_t结构的指针指向缓冲区并进行初始化        rfssublk_t *sbp = (rfssublk_t *)buf;        rfssublk_t_init(sbp);        //获取储存设备的逻辑储存块数并保存到超级块中        sbp->rsb_fsysallblk = ret_rfsdevmaxblknr(devp);        //把缓冲区中超级块的数据写入到储存设备的第0个逻辑储存块中        if (write_rfsdevblk(devp, buf, 0) == DFCERRSTUS)        {            return FALSE;        }        del_buf(buf, FSYS_ALCBLKSZ);//释放缓冲区        return TRUE;    }上述代码的意思是，我们先在内存缓冲区中建立文件系统的超级块，最后会调用write_rfsdevblk函数，把内存缓冲区的数据写入到储存设备中。下面我们来实现这个 write_rfsdevblk函数，代码如下所示。    //返回设备扩展数据结构    rfsdevext_t* ret_rfsdevext(device_t* devp)    {        return (rfsdevext_t*)devp->dev_extdata;    }    //根据块号返回储存设备的块地址    void* ret_rfsdevblk(device_t* devp,uint_t blknr)    {        rfsdevext_t* rfsexp = ret_rfsdevext(devp);        //块号乘于块大小的结果再加上开始地址（用于模拟储存设备的内存空间的开始地址）        void* blkp = rfsexp->rde_mstart + (blknr*FSYS_ALCBLKSZ);        //如果该地址没有落在储存入设备的空间中，就返回NULL表示出错        if(blkp >= (void*)((size_t)rfsexp->rde_mstart+rfsexp->rde_msize))            return NULL;        //返回块地址        return blkp;    }    //把4KB大小的缓冲区中的内容，写入到储存设备的某个逻辑储存块中    drvstus_t write_rfsdevblk(device_t* devp,void* weadr,uint_t blknr)    {        //返回储存设备中第blknr块的逻辑存储块的地址        void* p = ret_rfsdevblk(devp,blknr);         //复制数据到逻辑储存块中        hal_memcpy(weadr,p,FSYS_ALCBLKSZ);        return DFCOKSTUS;    }前面我们一下子写了三个函数，由于我们用内存模拟储存设备，我们要写一个ret_rfsdevext 函数返回设备扩展数据结构，这个函数和 ret_rfsdevblk函数将会一起根据块号，计算出内存地址。然后，我们把缓冲区的内容复制到这个地址开始的内存空间就行了。建立位图接下来，我们要建立文件系统的位图了。延续我们文件系统的设计思路，储存设备被分成了许多同等大小的逻辑储存块，位图就是为了能准确地知道储存设备中，哪些逻辑储存块空闲、哪些是被占用的。我们使用一个逻辑储存块空间中的所有字节，来管理逻辑储存块的状态。建立位图无非就是把储存设备中的位图块清零，因为开始文件系统刚创建时，所有的逻辑储存块都是空闲的。下面我们来写好代码。    //把逻辑储存块中的数据，读取到4KB大小的缓冲区中    drvstus_t read_rfsdevblk(device_t* devp,void* rdadr,uint_t blknr)    {        //获取逻辑储存块地址        void* p=ret_rfsdevblk(devp,blknr);        //把逻辑储存块中的数据复制到缓冲区中        hal_memcpy(p,rdadr,FSYS_ALCBLKSZ);        return DFCOKSTUS;    }    //获取超级块    rfssublk_t* get_superblk(device_t* devp)    {        //分配4KB大小的缓冲区        void* buf=new_buf(FSYS_ALCBLKSZ);        //清零缓冲区        hal_memset(buf,FSYS_ALCBLKSZ,0);        //读取第0个逻辑储存块中的数据到缓冲区中，如果读取失败则释放缓冲区        read_rfsdevblk(devp,buf,0);        //返回超级块数据结构的地址，即缓冲区的首地址        return (rfssublk_t*)buf;    }    //释放超级块    void del_superblk(device_t* devp,rfssublk_t* sbp)     {        //回写超级块，因为超级块中的数据可能已经发生了改变，如果出错则死机        write_rfsdevblk(devp,(void*)sbp,0);//释放先前分配的4KB大小的缓冲区        del_buf((void*)sbp,FSYS_ALCBLKSZ);        return;    }    //建立位图    bool_t create_bitmap(device_t* devp)    {        bool_t rets=FALSE;        //获取超级块，失败则返回FALSE        rfssublk_t* sbp = get_superblk(devp);        //分配4KB大小的缓冲区        void* buf = new_buf(FSYS_ALCBLKSZ);           //获取超级块中位图块的开始块号        uint_t bitmapblk=sbp->rsb_bmpbks;        //获取超级块中储存介质的逻辑储存块总数        uint_t devmaxblk=sbp->rsb_fsysallblk;        //如果逻辑储存块总数大于4096，就认为出错了        if(devmaxblk>FSYS_ALCBLKSZ)        {            rets=FALSE;            goto errlable;        }        //把缓冲区中每个字节都置成1        hal_memset(buf,FSYS_ALCBLKSZ,1);        u8_t* bitmap=(u8_t*)buf;        //把缓冲区中的第3个字节到第devmaxblk个字节都置成0        for(uint_t bi=2;birsb_bmpbks块（位图块），到缓冲区中        read_rfsdevblk(devp, buf, sbp->rsb_bmpbks)        //释放超级块        del_superblk(devp, sbp);        //返回缓冲区的首地址        return (u8_t*)buf;    }    //释放位图块    void del_bitmapblk(device_t* devp,u8_t* bitmap)    {        //获取超级块        rfssublk_t* sbp = get_superblk(devp);        //回写位图块，因为位图块中的数据可能已经发生改变        write_rfsdevblk(devp, (void*)bitmap, sbp->rsb_bmpbks)        //释放超级块和存放位图块的缓冲区        del_superblk(devp, sbp);        del_buf((void*)bitmap, FSYS_ALCBLKSZ);        return;    }获取 /释放位图块非常简单，就是根据超级块中的位图块号，把储存设备中的位图数据块读取到缓冲区中，而释放位图块则需要把缓冲区的数据写入到储存设备对应的逻辑块中。获取/释放超级块的函数，我们建立位图时已经写好了。建立根目录需要分配新的逻辑储存块，分配新的逻辑储存块其实就是扫描位图数据，从中找出一个空闲的逻辑储存块，下面我们来写代码实现这个函数，如下所示。    //分配新的空闲逻辑储存块    uint_t rfs_new_blk(device_t* devp)     {        uint_t retblk=0;        //获取位图块        u8_t* bitmap = get_bitmapblk(devp);                if(bitmap == NULL)        {                return 0;        }        for(uint_t blknr = 2; blknr rsb_rootdir.rdr_name[0] = '/';        //设置超级块中的rfsdir_t结构中的类型为目录类型        sbp->rsb_rootdir.rdr_type = RDR_DIR_TYPE;        //设置超级块中的rfsdir_t结构中的块号为新分配的空闲逻辑储存块的块号        sbp->rsb_rootdir.rdr_blknr = blk;        fimgrhd_t* fmp = (fimgrhd_t*)buf;        //初始化fimgrhd_t结构        fimgrhd_t_init(fmp);        //因为这是目录文件所以fimgrhd_t结构的类型设置为目录类型        fmp->fmd_type = FMD_DIR_TYPE;        //fimgrhd_t结构自身所在的块设置为新分配的空闲逻辑储存块        fmp->fmd_sfblk = blk;        //fimgrhd_t结构中正在写入的块设置为新分配的空闲逻辑储存块        fmp->fmd_curfwritebk = blk;        //fimgrhd_t结构中正在写入的块的偏移设置为512字节        fmp->fmd_curfinwbkoff = 0x200;        //设置文件数据占有块数组的第0个元素        fmp->fmd_fleblk[0].fb_blkstart = blk;        fmp->fmd_fleblk[0].fb_blknr = 1;        //把缓冲区中的数据写入到新分配的空闲逻辑储存块中，其中包含已经设置好的      fimgrhd_t结构        if(write_rfsdevblk(devp, buf, blk) == DFCERRSTUS) {            rets = FALSE;            goto errlable;        }        rets = TRUE;    errlable:        //释放缓冲区        del_buf(buf, FSYS_ALCBLKSZ);    errlable1:        //释放超级块        del_superblk(devp, sbp);         return rets;    }上述代码的注释已经很清楚了，虽然代码有点长，但总体流程还是挺清晰的。首先，分配一块新的逻辑储存块。接着，设置超级块中的rfsdir_t结构中的名称以及类型和块号。然后设置文件管理头，由于根目录是目录文件，所以文件管理头的类型为FMD_DIR_TYPE，表示文件数据存放的是目录结构。最后，回写对应的逻辑储存块即可。串联建立超级块、建立位图、建立根目录的代码已经写好了。现在我们来写一个 rfs_fmat函数，把刚才这三个操作包装起来，调用它们完成文件系统格式化这一流程。顺便，我们还可以把init_rfs 函数也实现了，让它调用 rfs_fmat 函数，随后 init_rfs函数本身会在 rfs_entry函数的最后被调用，代码如下所示。    //rfs初始化    void init_rfs(device_t *devp)    {        //格式化rfs        rfs_fmat(devp);        return;    }    //rfs格式化    void rfs_fmat(device_t *devp)    {        //建立超级块        if (create_superblk(devp) == FALSE)        {            hal_sysdie("create superblk err");        }        //建立位图        if (create_bitmap(devp) == FALSE)        {            hal_sysdie("create bitmap err");        }        //建立根目录        if (create_rootdir(devp) == FALSE)        {            hal_sysdie("create rootdir err");        }        return;    }    //rfs驱动程序入口    drvstus_t rfs_entry(driver_t *drvp, uint_t val, void *p)    {        //……        init_rfs(devp);//初始化rfs        return DFCOKSTUS;    }上述代码中，init_rfs 函数会在 rfs驱动程序入口函数的最后被调用，到这里我们 rfs文件系统的格式化操作就完成了，这是实现文件系统的重要一步。测试文件系统尽管我们的文件系统还有很多其它操作，如打开、关闭，读写文件，这些文件相关的操作我们放在下一节课中来实现。这里我们先对文件系统格式化的功能进行测试，确认一下我们的格式化代码没有问题，再进行下一步的开发。测试文件系统超级块之前我们文件系统格式化操作的第一步，就是建立文件系统的超级块。所以我们首先来测试一下建立文件系统超级块的代码，测试方法非常简单，我们只要把超级块读取到一个缓冲区中，然后把其中一些重要的数据，打印出来看一看就知道了，我们写个函数完成这个功能，代码如下所示。    //测试文件系统超级块    void test_rfs_superblk(device_t *devp)    {        kprint("开始文件系统超级块测试\n");        rfssublk_t *sbp = get_superblk(devp);        kprint("文件系统标识:%d,版本:%d\n", sbp->rsb_mgic, sbp->rsb_vec);        kprint("文件系统超级块占用的块数:%d,逻辑储存块大小:%d\n", sbp->rsb_sblksz, sbp->rsb_dblksz);        kprint("文件系统位图块号:%d,文件系统整个逻辑储存块数:%d\n", sbp->rsb_bmpbks, sbp->rsb_fsysallblk);        kprint("文件系统根目录块号:%d 类型:%d\n", sbp->rsb_rootdir.rdr_blknr, sbp->rsb_rootdir.rdr_type);        kprint("文件系统根目录名称:%s\n", sbp->rsb_rootdir.rdr_name);        del_superblk(devp, sbp);        hal_sysdie("结束文件系统超级块测试");//死机用于观察测试结果        return;    }    //rfs驱动程序入口    drvstus_t rfs_entry(driver_t *drvp, uint_t val, void *p)    {        init_rfs(devp);//初始化rfs        test_rfs_superblk(devp);//测试文件系统超级块        return DFCOKSTUS;    }测试代码我们已经写好了，下面我们打开终端，切换到 Cosmos 目录下执行make vboxtest，Cosmos 加载 rfs驱动程序运行后的结果，如下所示。![](Images/119431d1d48ee5ba22539270c0552472.png)savepage-src="https://static001.geekbang.org/resource/image/a3/a4/a3cb6f6d31d2f5faaf77d2fbb3010fa4.jpg?wh=1044x921"}文件系统超级块测试.上图中我们可以看到，文件系统的标识、版本和最初定义的是相同的，逻辑储存块的大小为4KB。位图占用的是第 1 个逻辑储存块，因为第 0个逻辑储存块被超级块占用了。同时，我们还可以看到储存设备上共有 1024个逻辑储存块，根目录文件的逻辑储存块为第 2块，名称为"/"，这些正确的数据证明了建立超级块的代码是没有问题的。测试文件系统位图测试完了文件系统超级块，我们接着来测试文件系统位图。测试方法很简单，先读取位图块到一个缓冲区中，然后循环扫描这个缓冲区，看看里面有多少个为0的字节，即表明储存介质上有多少个空闲的逻辑储存块。我们一起来写好这个测试函数，代码如下所示。    void test_rfs_bitmap(device_t *devp)    {        kprint("开始文件系统位图测试\n");        void *buf = new_buf(FSYS_ALCBLKSZ);        hal_memset(buf, 0, FSYS_ALCBLKSZ);        read_rfsdevblk(devp, buf, 1)//读取位图块        u8_t *bmp = (u8_t *)buf;        uint_t b = 0;        //扫描位图块        for (uint_t i = 0; i rdr_blknr)        fimgrhd_t *fmp = (fimgrhd_t *)buf;        kprint("文件管理头类型:%d 文件数据大小:%d 文件在开始块中偏移:%d 文件在结束块中的偏移:%d\n",                fmp->fmd_type, fmp->fmd_filesz, fmp->fmd_fileifstbkoff, fmp->fmd_fileiendbkoff);        kprint("文件第一组开始块号:%d 块数:%d\n", fmp->fmd_fleblk[0].fb_blkstart, fmp->fmd_fleblk[0].fb_blknr);        del_buf(buf, FSYS_ALCBLKSZ);        del_rootdir(devp, dr);        hal_sysdie("结束文件系统根目录测试\n");//死机用于观察测试结果        return;    }test_rfs_rootdir 函数同样要在 rfs_entry函数的末尾调用，然后我们在终端下执行 make vboxtest，就可以看到 cosmos加载 rfs驱动程序运行后的结果了。![](Images/35a0c61cc97b34b2e067ab97a17ef6e6.png)savepage-src="https://static001.geekbang.org/resource/image/f9/1a/f98f2035948514bdf5ffcc3a50b9061a.jpg?wh=1044x921"}文件系统根目录测试从上图我们可以看到，根目录文件的类型为目录文件类型。因为根目录文件才刚建立，所以文件大小为0，文件数据的存放位置从文件占用的第 1 块逻辑储存块的 512字节处开始。因为第 0、1块逻辑储存块被超级块和位图块占用了，所以根目录文件占用的逻辑储存块，就是第2 块逻辑储存块，只占用了 1 块。好了，上面一系列的测试结果，表明我们的文件系统格式化的代码正确无误，文件系统格式化操作的内容我们就告一段落了重点回顾今天的课程就到这里了，今天我们继续推进了文件系统的进度，实现了文件系统的格式化操作，我来为你把今天的课程重点梳理一下。首先实现了文件系统设备驱动程序框架，这是因为我们之前的架构设计，把文件系统作为Cosmos系统下的一个设备，这有利于**扩展不同的文件系统。**然后我们实现了文件系统格式化操作，包括建立文件系统超级块、位图、根目录操作，并且将它们串联在一起完成文件系统格式化。最后是对文件系统测试，我们通过打印出文件系统超级块、位图还有根目录的相关数据来验证，最终确认了我们文件系统格式化操作的代码是正确的。虽然我们实现了文件系统的格式化，也对其进行了测试，但是我们的文件系统还是不能存放文件，因为我们还没有实现操作文件相关的功能，下一节课我们继续探索。思考题请问，建立文件系统的超级块、位图、根目录的三大函数的调用顺序可以随意调换吗，原因是什么？欢迎你在留言区记录你的疑问或者收获，积极输出有利于你深入理解这节课的内容。同时，也欢迎你把这节课转给身边的同事、朋友。好，我是LMOS，我们下节课见！