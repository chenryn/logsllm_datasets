A
RiscOS
(cid:88)
(cid:88)†
(cid:88)†
(cid:88)
N/A
N/A
A
A
do not appear in our ground truth (and so would normally
be considered false positives) but which we feel can justiﬁ-
ably considered real handlers. Chained handlers are virtual
handlers that dispatch to more speciﬁc handlers. We do not
consider these false positives, since a user may wish to use
such handlers to disable multiple peripherals at once. In some
cases, there may only be a single sub-handler registered under
a chained handler. In this case IRQDebloat will only ﬁnd the
top-level handler in the chain, since there will be no further
divergences. We consider this a true positive, since disabling
the top-level handler will still disable the desired peripheral.
Default handlers similarly do not appear in our ground truth,
as they are statically registered by the OS as a fallback when
no other handler is suitable. These are found by our divergence
analysis, since invalid IRQ numbers will diverge from valid
IRQs. We do not include these as false positives.
Aside from chained and default handlers, we have two false
negatives for Sabre LITE Linux, two false positives for Sabre
LITE VxWorks, two false positives for Romulus Linux, and
three false positives for Steam Link Linux. The two false
negatives are missed during the fuzzing stage (as mentioned
in Section V-C) and so do not appear in any trace.
The false positives in Sabre LITE VxWorks and Romu-
lus Linux are caused by internal callback functions inside
speciﬁc IRQ handlers. For Sabre LITE VxWorks, the false
positive is located at __udivmodsi4, an LLVM compiler
intrinsic for the integer divide and modulus operation, which
has a switch statement at the end of the function for opti-
mization. Romulus Linux has two callback functions regis-
tered under its UART interrupt handler (serial8250 interrupt),
which could invoke either aspeed vuart handle irq or se-
rial8250 default handle irq. The Steam Link false positives
turn out to be caused by Linux softirq tasklets (callbacks which
can be scheduled by drivers and run at the end of IRQ handling
in irq exit).
While not ideal, false positives are not particularly harmful
in our setting. A false positive will mean that the user has one
more handler to check (which just means booting the device
and seeing if the unwanted peripheral has been disabled).
F. IRQ Monitoring and Removal
To evaluate the IRQ monitoring and removal on a real
device, we used the results of our analysis to instrument three
operating systems (Linux, FreeBSD, and RiscOS) running on
a Raspberry Pi. We selectively disabled all discovered IRQ
handlers on each operating system as shown in Table V. For
the USB and Video IRQ handlers in RiscOS (indicated with
a † in the table), we found that the handlers could not be
disabled during boot, so we used our instrumentation engine
to add code that waits until the system has booted (using a
simple counter) and then disables the handler at runtime. The
“N/A” entries in the table indicate that the OS does not register
a handler for that device. Finally, A entries indicate that the
device cannot function properly with that IRQ disabled.
With the UART disabled, we lose all input/output through
the serial port, while all the other parts (HDMI, USB etc.)
are unaffected. When USB is disabled, we can still interact
through the serial port, but we lose all control from USB-
connected devices (keyboard, mouse etc.), as well as the
Ethernet connection, which is internally connected to the USB
bus on the Raspberry Pi. We did not see any effect from
disabling the video controller interrupt (DMA) or Performance
Monitoring Unit (PMU). The remaining handlers (timer and
inter-processor interrupt (IPI)) are essential for device func-
tionality and cannot be disabled.
G. Case Study: Bluetooth on the Steam Link
We use the Valve Steam Link to illustrate a real-world
case of how IRQDebloat could be used to reduce attack
surface. The Steam Link is based on the Marvell Armada
1500-mini (MV88DE3108) SoC and is used to stream games
from a desktop PC to an external display via HDMI. It runs
Linux and supports connectivity via WiFi, Bluetooth, and
Ethernet. Our scenario considers a user who does not have any
Bluetooth devices and wishes to disable this functionality to
avoid Bluetooth exploits such as BleedingTooth [37]. Indeed,
we found that the Steam Link in its default conﬁguration
is vulnerable to one of the BleedingTooth vulnerabilities,
BadChoice (CVE-2020-12352; the kernel version used, 3.8.13,
is too old to be vulnerable to BadKarma and BadVibes).
Although the Steam Link only accepts signed ﬁrmware and
does not have JTAG exposed on the board, Valve has released
information that allows users to log in as root on the device.
This allowed us to create a snapshot using our own custom
kernel module (for the CPU registers) and LiME [3] (for the
memory dump). Root access also means that we can patch the
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:36:44 UTC from IEEE Xplore.  Restrictions apply. 
1618
kernel in memory in order to disable handlers, even though
we are not able to modify the ﬁrmware image itself.
Our analysis ﬁnds a total of 21 handlers. We disabled
them one by one and checked whether Bluetooth was still
working on the device. If available, kernel symbols (e.g.,
/proc/kallsyms on Linux) can speed up this process, but
are not required. After some analysis we determined that WiFi
and Bluetooth functionality are both handled by the Marvell
88W8897 peripheral, which uses a shared interrupt on the
SDIO bus for both protocols.
We opted to disable both WiFi and Bluetooth on the device
by overwriting the shared SDIO handler. Although this is not
ideal (we only intended to disable Bluetooth), we note that
the Steam Link can still access the internet over Ethernet, so
the device is still usable. We then checked whether it was
still vulnerable to BadChoice by running the proof-of-concept
exploit code, and conﬁrmed that the exploit failed. Indeed, all
Bluetooth connections to the device failed.
H. Quantifying Attack Surface Reduction
To more rigorously assess the potential attack surface reduc-
tion from disabling handlers on the Steam Link, we collected a
list of all CVEs in the past ﬁve years (2016–2021) for which
the Linux Kernel CVEs project [4] could identify a patch,
excluding patches larger than 1MB (as these usually removed
entire subsystems and would not allow precise matching). In
total we found 978 CVEs that met our criteria.
Next we annotated each IRQ on the Steam Link according
to whether it is exposed to external input and then manually
identiﬁed which kernel source paths were potentially reachable
from the interrupt handler. We included here both the driver
code for the Steam Link’s particular peripherals as well as code
that handled protocols accessible only via those peripherals
(e.g., the Bluetooth protocol stack). We then matched these
source paths against our CVE patches to determine which
CVEs could have been blocked by disabling the handler.
We used the National Vulnerability Database’s Attack Vector
classiﬁcation to exclude CVEs that could only be exploited
locally by a process running on the device.
The results are shown in Table VI. We can see that there
are indeed many vulnerabilities in the WiFi and Bluetooth
drivers that would be prevented by disabling the handler (13
CVEs). Similarly, USB devices have been the source of many
vulnerabilities, and disabling this interrupt would have blocked
31 vulnerabilities. This count is conservative in two ways.
First, it does not consider vulnerabilities in the peripheral
ﬁrmware itself. For example, the ThreadX-based ﬁrmware on
the 88W8897 WiFi/Bluetooth peripheral is vulnerable to CVE-
2019-6496; while disabling the IRQ for this peripheral would
not prevent the peripheral’s ﬁrmware from being exploited,
it would prevent further escalation to the main application
processor. Second, the attack surface reduction from disabling
multiple IRQ handlers at once is not just additive: for example,
disabling IRQs 49 and 56 (WiFi/BT and Ethernet) would
disable all network access, preventing any vulnerabilities in
the entire network stack from being exploited.
IRQ#
32
33
38
44
49
Presentation Engine
Presentation Engine
GPU
USB
Bluetooth (SDIO)
49 WiFi (SDIO)
50
51
56
57
168
176
200
NAND Flash
Presentation Engine
Ethernet
Presentation Engine
APB Timers
Two Wire Serial I2C
UART
208
Presentation Engine



(cid:88)
(cid:88)
(cid:88)


(cid:88)



(cid:88)

N/A
N/A
N/A
drivers/usb
drivers/bluetooth,
net/bluetooth
drivers/net/
wireless/marvell/
mwiﬁex
N/A
N/A
drivers/net/
ethernet/marvell/
geth.c
N/A
N/A
N/A
drivers/tty/serial/
8250
N/A
#CVEs
N/A
N/A
N/A
31
7
6
N/A
N/A
0
N/A
N/A
N/A
0
N/A
157
STEAM LINK ATTACK SURFACE REDUCTION
TABLE VI
Peripheral
Ext?
Source
Total remotely exploitable kernel CVEs, 2016–2021
VI. LIMITATIONS AND FUTURE WORK
Non-IRQ Inputs. A core assumption we make is that
unwanted input to the system is delivered via interrupts. It is
possible that some systems just poll for input from a peripheral
in a loop. In our experience thus far, this type of input handling
is generally only used for very simple peripherals (e.g., simple
sensors), but we hope to more thoroughly explore this type of
input and ﬁnd ways to disable it automatically in future work.
Shared and Threaded Handlers. There are currently some
OS mechanisms for handling IRQs that we do not yet support.
In particular, some peripherals are handled using threaded
handlers, in which incoming IRQs are queued and then han-
dled asynchronously in a different kernel thread. This can be
particularly problematic when multiple devices share a single
interrupt (the shared WiFi/Bluetooth interrupt on the Steam
Link): although the individual peripherals do have their own
handlers, they are only executed after the initial handler has
ended, so IRQDebloat can only see and disable the initial top-
level handler.
We believe that such handlers can be identiﬁed by continu-
ing our fuzzing after the initial IRQ handler returns and then
applying our divergence analysis to the code executed by the
kernel scheduler. Since the same threaded handler will always
be invoked for a given IRQ, the analysis should allow us to
distinguish between threaded handlers and other kernel thread
activity. However, we leave this to future work.
Manual Effort. Some parts of our system still require
manual effort, which we describe and quantify here; note that
the times given are for a user who is relatively skilled at reverse
engineering and embedded device hacking. First, human effort
is required to acquire a snapshot from the device and to ﬁgure
out how to ﬂash a modiﬁed ﬁrmware image. This is currently
one of the more time-consuming pieces, as it depends on the
device and whether any protection measures exist. For three
of the four physical devices in our dataset, we were able to
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:36:44 UTC from IEEE Xplore.  Restrictions apply. 
1619
obtain a usable snapshot within 2-3 hours of work, but one
device (the WRT54GL) took several days of work due to our
unfamiliarity with MIPS.
It also requires human judgment to validate that the right
peripheral has been disabled. The user must boot the device
with the modiﬁed ﬁrmware and check whether the disabled
peripheral responds to input. However, this does not require
technical expertise (beyond what is required to modify the
ﬁrmware) and only takes a few minutes per candidate handler.
Finally, identifying a return value for a disabled handler
that satisﬁes the kernel’s IRQ handling API currently requires
manual reverse engineering for each operating system (around
an hour per OS). One possibility for automating this step is
to use the dynamic information from our traces to see what
valid handlers return, and try those values.
Rehosting. Aside from addressing limitations of our system,
we also believe that our techniques for automatically enumer-
ating and identifying interrupt handlers could be useful for
other embedded reverse engineering efforts, such as rehost-
ing [22], [45]. When faced with a new embedded system,
it can be challenging to even enumerate its peripherals and
identify their memory-mapped register ranges. IRQDebloat
could help automate this process, as each interrupt identiﬁes
a unique peripheral, and the interrupt handler usually contains
code to interact with the device’s memory-mapped registers.
In addition, interrupt handling remains a challenge for auto-
mated rehosting systems; we hope to extend IRQDebloat to
automatically create an emulated model of the target interrupt
controller along with stub devices for each interrupt source
that will need to be emulated.
VII. RELATED WORK
As embedded and Internet of Things (IoT) devices have
proliferated, academic research has turned its attention to the
challenges of securing these systems. Embedded analysis is
difﬁcult due to the wide variety of hardware used, and the
relative dearth of embedded security tooling.
One line of embedded research focuses on bringing dynamic
program analysis to embedded systems by emulating them
in an embedded environment. These include pure software
emulation with inferred MMIO inputs or abstracted hardware
interfaces [11], [14], [25], [35], [41], [18], [23], [34], [26]
and hardware-in-the-loop hybrid emulation [49], [36], [44],
[30], [32], [17]. Two recent surveys [22], [45] provide a more
comprehensive picture of the state of the art in rehosting, and
we refer interested readers there for more details.
Aside from dynamic analysis, some work has sought to
analyze embedded ﬁrmware statically. FIE [20] lifts MSP430
source to LLVM and then symbolically executes it
in
KLEE [9], while Firmalice [43] symbolically executes binary
ﬁrmware to identify potential backdoors. On the protection
side, Cui and Stolfo proposed embedded symbiotes [19], in
which embedded ﬁrmware is rewritten to inject a runtime
security monitor. Our work also focuses on improving the
security of deployed embedded devices, but does so by re-
moving, rather than adding functionality.
Separately, interest has recently grown in how to eliminate
unwanted features in existing software to reduce its exposed
attack surface. This technique, known as debloating, has been
applied to desktop and server software [12], [39], [38], [31],
[28], mobile applications [47], [27], web applications [8], and
even containers [40].
Work on debloating embedded ﬁrmware is somewhat more
scarce. DECAF [13] and me cleaner [16] attempt to remove
unused functionality in UEFI ﬁrmware and the Intel ME BIOS,
respectively. Speciﬁcally for Linux-based embedded systems,
Lee et al. [33] removes unused syscall and driver code for
hardware that is not present, and Chanet et al. [10] use link-
time binary rewriting to remove unreachable system calls.
Closest
to our own work is LIGHTBLUE [46], which
debloats Bluetooth protocol stacks in embedded devices to
reduce the attack surface exposed by Bluetooth. LIGHTBLUE
allows individual portions of the Bluetooth protocol to be
disabled by analyzing an accompanying proﬁle. Although this
allows for more ﬁne-grained control over Bluetooth (IRQDe-
bloat can only enable or disable the Bluetooth peripheral as
a whole), it cannot be used to limit the attack surface caused
by non-Bluetooth peripherals.
VIII. CONCLUSION
In this paper, we presented IRQDebloat, an automated
technique for reducing the exposed attack surface of embedded
devices by rewriting ﬁrmware to disable unwanted hardware
functionality. To do so, we identiﬁed a key architectural
feature—namely, interrupt handling—that acts as a bottleneck
through which inputs enter the system, and then developed an
automated dynamic analysis to precisely identify and disable
interrupt handlers for unwanted peripherals. We believe that in
addition to giving end users more control over the embedded
hardware deployed on their networks, our techniques may
also be useful for automated reverse engineering of embedded
systems for security.
ACKNOWLEDGMENTS
We would like to thank our anonymous reviewers for
their feedback, which helped make the paper much stronger.
We also warmly acknowledge the contributions of NYU
students Amandeep Singh, Kevin Kwan, Fernando Maymi,
Casey McGinley, Birkan Erenler, and Hao Ke, who performed
early exploratory work on IRQDebloat
throughout course
and independent study projects in 2016–2018. The work
in this paper is supported by funding from the Ofﬁce of
Naval Research under ONR award N00014-15-1-2180 and the
National Science Foundation under Grant No. CNS-1657199.
Any opinions, ﬁndings, and conclusions or recommendations
expressed in this material are those of the authors and do not
necessarily reﬂect the views of the Ofﬁce of Naval Research
or the National Science Foundation.
AVAILABILITY
The code and data used in this paper are available at: