练习 2.2： 写一个通用的单位转换程序，用类似cf程序的方式从命令行读取参数，如果缺省的
话则是从标准输入读取参数，然后做类似Celsius和Fahrenheit的单位转换，长度单位可以对
应英尺和米，重量单位可以对应磅和公斤等。
2.6.2. 包的初始化
包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始
化：
var a = b + c // a 第三个初始化, 为 3
var b = f() // b 第二个初始化, 为 2, 通过调用 f (依赖c)
var c = 1 // c 第一个初始化, 为 1
func f() int { return c + 1 }
如果包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化，Go语言的构建工具
首先会将.go文件根据文件名排序，然后依次调用编译器编译。
对于在包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表
达式的，例如某些表格数据初始化并不是一个简单的赋值过程。在这种情况下，我们可以用
一个特殊的init初始化函数来简化初始化工作。每个文件都可以包含多个init初始化函数
func init() { /* ... */ }
这样的init初始化函数除了不能被调用或引用外，其他行为和普通函数类似。在每个文件中的
init初始化函数，在程序开始执行时按照它们声明的顺序被自动调用。
每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，
如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。初始化
工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之
前，所有依赖的包都已经完成初始化工作了。
下面的代码定义了一个PopCount函数，用于返回一个数字中含二进制1bit的个数。它使用init
初始化函数来生成辅助表格pc，pc表格用于处理每个8bit宽度的数字含二进制的1bit的bit个
数，这样的话在处理64bit宽度的数字时就没有必要循环64次，只需要8次查表就可以了。（这
并不是最快的统计1bit数目的算法，但是它可以方便演示init函数的用法，并且演示了如何预生
成辅助表格，这是编程中常用的技术）。
gopl.io/ch2/popcount
包和文件 74
gopl
package popcount
// pc[i] is the population count of i.
var pc [256]byte
func init() {
for i := range pc {
pc[i] = pc[i/2] + byte(i&1)
}
}
// PopCount returns the population count (number of set bits) of x.
func PopCount(x uint64) int {
return int(pc[byte(x>>(0*8))] +
pc[byte(x>>(1*8))] +
pc[byte(x>>(2*8))] +
pc[byte(x>>(3*8))] +
pc[byte(x>>(4*8))] +
pc[byte(x>>(5*8))] +
pc[byte(x>>(6*8))] +
pc[byte(x>>(7*8))])
}
译注：对于pc这类需要复杂处理的初始化，可以通过将初始化逻辑包装为一个匿名函数处
理，像下面这样：
// pc[i] is the population count of i.
var pc [256]byte = func() (pc [256]byte) {
for i := range pc {
pc[i] = pc[i/2] + byte(i&1)
}
return
}()
要注意的是在init函数中，range循环只使用了索引，省略了没有用到的值部分。循环也可以这
样写：
for i, _ := range pc {
我们在下一节和10.5节还将看到其它使用init函数的地方。
练习 2.3： 重写PopCount函数，用一个循环代替单一的表达式。比较两个版本的性能。
（11.4节将展示如何系统地比较两个不同实现的性能。）
练习 2.4： 用移位算法重写PopCount函数，每次测试最右边的1bit，然后统计总数。比较和
查表算法的性能差异。
包和文件 75
gopl
练习 2.5： 表达式 用于将x的最低的一个非零的bit位清零。使用这个算法重写
x&(x-1)
PopCount函数，然后比较性能。
包和文件 76
gopl
2.7. 作用域
一个声明语句将程序中的实体和一个名字关联，比如一个函数或一个变量。声明语句的作用
域是指源代码中可以有效使用这个名字的范围。
不要将作用域和生命周期混为一谈。声明语句的作用域对应的是一个源代码的文本区域；它
是一个编译时的属性。一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时
间区域内它可以被程序的其他部分引用；是一个运行时的概念。
句法块是由花括弧所包含的一系列语句，就像函数体或循环体花括弧包裹的内容一样。句法
块内部声明的名字是无法被外部块访问的。这个块决定了内部声明的名字的作用域范围。我
们可以把块（block）的概念推广到包括其他声明的群组，这些声明在代码中并未显式地使用
花括号包裹起来，我们称之为词法块。对全局的源代码来说，存在一个整体的词法块，称为
全局词法块；对于每个包；每个for、if和switch语句，也都对应词法块；每个switch或select的
分支也有独立的语法块；当然也包括显式书写的词法块（花括弧包含的语句）。
声明语句对应的词法域决定了作用域范围的大小。对于内置的类型、函数和常量，比如int、
len和true等是在全局作用域的，因此可以在整个程序中直接使用。任何在在函数外部（也就
是包级语法域）声明的名字可以在同一个包的任何源文件中访问的。对于导入的包，例如
tempconv导入的fmt包，则是对应源文件级的作用域，因此只能在当前的文件中访问导入的
fmt包，当前包的其它源文件无法访问在当前源文件导入的包。还有许多声明语句，比如
tempconv.CToF函数中的变量c，则是局部作用域的，它只能在函数内部（甚至只能是局部的
某些部分）访问。
控制流标号，就是break、continue或goto语句后面跟着的那种标号，则是函数级的作用域。
一个程序可能包含多个同名的声明，只要它们在不同的词法域就没有关系。例如，你可以声
明一个局部变量，和包级的变量同名。或者是像2.3.3节的例子那样，你可以将一个函数参数
的名字声明为new，虽然内置的new是全局作用域的。但是物极必反，如果滥用不同词法域可
重名的特性的话，可能导致程序很难阅读。
当编译器遇到一个名字引用时，如果它看起来像一个声明，它首先从最内层的词法域向全局
的作用域查找。如果查找失败，则报告“未声明的名字”这样的错误。如果该名字在内部和外部
的块分别声明过，则内部块的声明首先被找到。在这种情况下，内部声明屏蔽了外部同名的
声明，让外部的声明的名字无法被访问：
作用域 77
gopl
func f() {}
var g = "g"
func main() {
f := "f"
fmt.Println(f) // "f"; local var f shadows package-level func f
fmt.Println(g) // "g"; package-level var
fmt.Println(h) // compile error: undefined: h
}
在函数中词法域可以深度嵌套，因此内部的一个声明可能屏蔽外部的声明。还有许多语法块
是if或for等控制流语句构造的。下面的代码有三个不同的变量x，因为它们是定义在不同的词
法域（这个例子只是为了演示作用域规则，但不是好的编程风格）。
func main() {
x := "hello!"
for i := 0; i < len(x); i++ {
x := x[i]
if x != '!' {
x := x + 'A' - 'a'
fmt.Printf("%c", x) // "HELLO" (one letter per iteration)
}
}
}
在 和 声明语句的初始化的表达式中都引用了外部作用域声明的x变量，稍
x[i] x + 'A' - 'a'
后我们会解释这个。（注意，后面的表达式与unicode.ToUpper并不等价。）
正如上面例子所示，并不是所有的词法域都显式地对应到由花括弧包含的语句；还有一些隐
含的规则。上面的for语句创建了两个词法域：花括弧包含的是显式的部分是for的循环体部分
词法域，另外一个隐式的部分则是循环的初始化部分，比如用于迭代变量i的初始化。隐式的
词法域部分的作用域还包含条件测试部分和循环后的迭代部分（ ），当然也包含循环体
i++
词法域。
下面的例子同样有三个不同的x变量，每个声明在不同的词法域，一个在函数体词法域，一个
在for隐式的初始化词法域，一个在for循环体词法域；只有两个块是显式创建的：
func main() {
x := "hello"
for _, x := range x {
x := x + 'A' - 'a'
fmt.Printf("%c", x) // "HELLO" (one letter per iteration)
}
}
作用域 78
gopl
和for循环类似，if和switch语句也会在条件部分创建隐式词法域，还有它们对应的执行体词法
域。下面的if-else测试链演示了x和y的有效作用域范围：
if x := f(); x == 0 {
fmt.Println(x)
} else if y := g(x); x == y {
fmt.Println(x, y)
} else {
fmt.Println(x, y)
}
fmt.Println(x, y) // compile error: x and y are not visible here
第二个if语句嵌套在第一个内部，因此第一个if语句条件初始化词法域声明的变量在第二个if中
也可以访问。switch语句的每个分支也有类似的词法域规则：条件部分为一个隐式词法域，然
后每个是每个分支的词法域。
在包级别，声明的顺序并不会影响作用域范围，因此一个先声明的可以引用它自身或者是引
用后面的一个声明，这可以让我们定义一些相互嵌套或递归的类型或函数。但是如果一个变
量或常量递归引用了自身，则会产生编译错误。
在这个程序中：
if f, err := os.Open(fname); err != nil { // compile error: unused: f
return err
}
f.ReadByte() // compile error: undefined f
f.Close() // compile error: undefined f
变量f的作用域只有在if语句内，因此后面的语句将无法引入它，这将导致编译错误。你可能会
收到一个局部变量f没有声明的错误提示，具体错误信息依赖编译器的实现。
通常需要在if之前声明变量，这样可以确保后面的语句依然可以访问变量：
f, err := os.Open(fname)
if err != nil {
return err
}
f.ReadByte()
f.Close()
你可能会考虑通过将ReadByte和Close移动到if的else块来解决这个问题：
作用域 79
gopl
if f, err := os.Open(fname); err != nil {
return err
} else {
// f and err are visible here too
f.ReadByte()
f.Close()
}
但这不是Go语言推荐的做法，Go语言的习惯是在if中处理错误然后直接返回，这样可以确保
正常执行的语句不需要代码缩进。
要特别注意短变量声明语句的作用域范围，考虑下面的程序，它的目的是获取当前的工作目
录然后保存到一个包级的变量中。这可以本来通过直接调用os.Getwd完成，但是将这个从主
逻辑中分离出来可能会更好，特别是在需要处理错误的时候。函数log.Fatalf用于打印日志信
息，然后调用os.Exit(1)终止程序。
var cwd string
func init() {
cwd, err := os.Getwd() // compile error: unused: cwd
if err != nil {
log.Fatalf("os.Getwd failed: %v", err)
}
}
虽然cwd在外部已经声明过，但是 语句还是将cwd和err重新声明为新的局部变量。因为内
:=
部声明的cwd将屏蔽外部的声明，因此上面的代码并不会正确更新包级声明的cwd变量。
由于当前的编译器会检测到局部声明的cwd并没有本使用，然后报告这可能是一个错误，但是
这种检测并不可靠。因为一些小的代码变更，例如增加一个局部cwd的打印语句，就可能导致
这种检测失效。
var cwd string
func init() {
cwd, err := os.Getwd() // NOTE: wrong!
if err != nil {
log.Fatalf("os.Getwd failed: %v", err)
}
log.Printf("Working directory = %s", cwd)
}
全局的cwd变量依然是没有被正确初始化的，而且看似正常的日志输出更是让这个BUG更加
隐晦。
作用域 80
gopl
有许多方式可以避免出现类似潜在的问题。最直接的方法是通过单独声明err变量，来避免使
用 的简短声明方式：
:=
var cwd string
func init() {
var err error
cwd, err = os.Getwd()
if err != nil {
log.Fatalf("os.Getwd failed: %v", err)
}
}
我们已经看到包、文件、声明和语句如何来表达一个程序结构。在下面的两个章节，我们将
探讨数据的结构。
作用域 81
gopl
第三章 基础数据类型
虽然从底层而言，所有的数据都是由比特组成，但计算机一般操作的是固定大小的数，如整
数、浮点数、比特数组、内存地址等。进一步将这些数组织在一起，就可表达更多的对象，
例如数据包、像素点、诗歌，甚至其他任何对象。Go语言提供了丰富的数据组织形式，这依
赖于Go语言内置的数据类型。这些内置的数据类型，兼顾了硬件的特性和表达复杂数据结构