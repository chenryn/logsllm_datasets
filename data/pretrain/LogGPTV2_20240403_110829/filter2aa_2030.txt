Forward-Looking Statement Disclaimer 
This presentation may contain forward-looking statements under 
applicable securities laws. All statements other than statements of 
historical fact are forward-looking statements. Forward-looking 
statements are based on information available to Jamf at the time they 
are made and provide Jamf’s current expectations and projections about 
our ﬁnancial condition, results, plans, objectives, future performance and 
business. You can identify forward-looking statements by the fact that 
they do not relate strictly to historical or current facts. Forward-looking 
statements may include words such as "anticipate," "estimate," "expect," 
"project," "plan," "intend," "believe,” "may," "will," "should," "can have," 
"likely" and other terms of similar meaning in connection with any 
discussion of the timing or nature of future operating or ﬁnancial 
performance or other events. 
All statements we make about our estimated and projected costs, 
expenses, cash ﬂows, growth rates and ﬁnancial results are forward-
looking statements. In addition, our plans and objectives for future 
operations, growth initiatives, product plans and product strategies are 
forward-looking statements. 
There are various factors, risks and uncertainties that may cause Jamf’s 
actual results to diﬀer materially from those that we expected in any 
forward-looking statements. These factors and risks are set forth in the 
documents Jamf ﬁles with the U.S. Securities and Exchange Commission 
(SEC). These documents are publicly available on the SEC’s website.
Forward-looking statements are not guarantees of future performance 
and you should not place undue reliance on them. Jamf is under no 
obligation to update any forward-looking statements made in this 
presentation.
macOS Detections  
         at Jamf Threat Labs
Introduced 10.15 
Replacement for: 
• Kauth KPI 
• Mac kernel framework 
• OpenBSM audit trail 
Kernel extensions difﬁcult to develop and maintain 
New security issues created as even minor bugs often 
lead to kernel panics. 
ESF System Extensions subscribe to system events 
e.g.: 
•es_event_create_t 
•es_event_rename_t 
•es_event_exec_t 
•es_event_fork_t 
kernel sends detailed info about event to all subscribed 
system extensions  
ESF events delivered as either Notiﬁcation Events or 
Authorization Events
Notify events send detailed event information to the 
subscribed system extensions and the vendor 
application can do what it wants with that information. 
e.g.: 
•Logging 
•Apply detection logic 
•Display an alert 
Notify events are report only. They have no bearing on 
the execution of the event.
Authorization events: 
•Prevent activity from proceeding 
•Send event data to subscribed clients 
•Await approve/deny response from client 
Client uses its own logic to determine whether event 
should proceed 
Authorization events on process creates offer a great 
opportunity for vendors to apply static detections at the 
moment of execution 
Behavioral Detections 
Powered by ESF
Fake File Extension
Attackers sometimes disguise malicious ﬁles like 
executables by masquerading ﬁle extensions like PDF. 
Detection logic can be applied at the time of ﬁle 
creation.
Attackers can gain persistence via malicious launch 
agents and launch daemons 
In many cases, they will disguise their launch plist by 
pre-pending the name with com.apple 
This can be detected by performing additional code 
signing checks on the executable at the path in the 
program arguments of the plist  
If the program is not signed by Apple, it shouldn’t be 
called from a plist labeled com.apple
Plist Disguised as Apple
• Event process (pid) is cut command 
• Cut command was run by the parent (ppid) zsh 
• Responsible pid was Terminal.app 
• String of piped commands was led by (pgid) 
system_proﬁler 
• All commands in the session have the same Session 
id which belongs to /usr/bin/login
Behaviors and Processes
Fileless malware curls scripts and binaries piped directly to 
interpreters like osascript to avoid leaving ﬁle artifacts for 
static detection. 
Detection can often be achieved by linking interpreter 
execution with a pgid pointing to curl
Curl piped to Interpreter
Advanced  
Behavioral Detections
Covered last year by Cedric Owens, macOS 
Gatekeeper had a (since patched) bug that allowed 
unsigned code to pass Gatekeeper checks by failing to 
meet Gatekeeper’s heuristic deﬁnition of an app bundle. 
If an app was missing an info.plist and had a script as 
the app executable, Gatekeeper would simply allow the 
app to run without any additional checks or prompts to 
the user.
CVE 2021-30657 
Gatekeeper Bypass
We discovered Shlayer abusing this bypass.  
Example of pre-bypass Shlayer (left) vs 
Double-click (no prompt) bypass found in wild (right) 
XCSSET discovered piggybacking TCC permissions of 
legitimate apps 
Malicious app nested inside of legitimate app, inheriting 
its TCC permissions with no user prompts 
(Since patched by Apple)
CVE 2022-22616 
TCC Bypass
Detection achieved by looking for nested app bundles 
Code signing checks performed on both apps 
In malicious cases, inner app has either: 
• No code signature 
• Ad-hoc signature 
• Team ID that does not match outer app
Application bundles are directory structures and can’t 
be downloaded from the internet as a ﬁle.  
They are often zipped into an archive ﬁle to get around 
this.  
For convenience, Safari, by default, automatically unzips 
these archives. 
CVE 2022-22616 
Gatekeeper Bypass
We discovered legitimate apps hosted online bypassing 
Gatekeeper checks when auto-unzipped by Safari. The 
top level of the app directory was missing the 
quarantine attribute. 
When downloaded from a different browser and 
unzipped by manually clicking, the same app properly 
received the quarantine attribute. 
This narrowed the issue to the Safari Sandbox broker 
which is responsible for the auto unzip
We were able to replicate this issue by taking a normally 
zipped app and manually deleting the ﬁrst directory 
header in the zip ﬁle 
Removing this header led to the Bill of Materials failing 
to index the top level of the app bundle, but would still 
successfully unzip the application
Since that directory header was missing from the Bill of 
Materials, the quarantine bit failed to be applied to the 
unzipped ﬁle. 
When the top level of the app directory has no 
quarantine bit, it runs with no Gatekeeper checks 
This bug was patched by Apple
• Detection looks for rename event that is being 
handled by Safari Sandbox Broker 
• It looks for apps being moved from a temp directory 
to Downloads  
• It then performs an additional extended attribute 
lookup to conﬁrm that quarantine bit has been applied 
as expected