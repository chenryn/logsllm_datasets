目标数据中只包含一个分号，两个表达式就没有区别了（匹配到唯一的分号为止），所以选
择速度更快的表达式可能更合适。
不过并不是任何时候优劣都如此分明，大的原则是，如果自标字符事很长，而你认为分号
---
## Page 283
提高表达式速度的诀窍
257
会比较接近字符串的开头，就使用忽略优先量词，这样引擎能更快地找到分号。如果你认
为分号在接近字符串末尾的位置，就使用匹配优先量词。如果数据是随机的，又不知道分
号究竞会靠近哪一头，就使用匹配优先的量词，因为它们的优化一般来说都要比其他量词
要好，尤其是表达式的后面部分禁止进行“忽略优先量词之后的字符优化”（248）时，
更是如此。
如果待匹配的字符事很短，差别就不那么明显了。这时候，两个正则表达式的速度都很快，
不过如果你很在乎那一点点速度差别，就对典型数据做个性能测试吧。
一个与此有关的问题是，在忽略优先量词和排除型字符组之间（^.*？：与"[^：1*：1)，应
该如何选择？答案还是取决于所使用的编程语言和应用的数据，但是对大多数引擎来说，
排除型字符组的效率比忽略优先量词高的多。Perl是个例外，因为它能对忽略优先量词之后
的字符进行优化。
拆分正则表达式
SplitlntoMulfipleRegnlarExpressions
有时候，应用多个小正则表达式的速度比一个大正则表达式要快得多。举个极端的例子，
如果你希望检查一个长字符串中是否包含月份的名字，依次检查‘January1、Februaryi、
Marchs之类的速度，要比January|February|March|快得多。因为对后者来说，不存
在匹配成功必须的文字内容，所以不能进行“内嵌文字字符串检查优化”（247）。“大而
全”的正则表达式必须在目标文本中的每个位置测试所有的自表达式，速度相当慢。
撰写本章时，我遇到了-个有趣的情况。用Perl写一个数据处理模块时，我意识到客户端
程序有个bug，导致它发送奇怪的数据，类似‘HASH（0x80f60ac）’而不是真正的数据。所
以，我打算修正这个模块，寻找怪异数据的来源，并报告错误。我使用的正则表达式相当
直白：\b(?：SCALAR1ARRAY1..1HASH)\(Ox[0-9a-fA-F]+\）。
在这里，效率是非常关键的。这个表达式的速度如何？Perl的调试模式（debuggingmode）
能够告诉你它对特定表达式使用的某些优化（361），所以我进行了检查。我希望启用了
预查必须字符/字符串优化（245），因为足够先进的引擎应该能够明白（0x’是任何匹配
所必须的。因为这个正则表达式所应用的数据几乎不包含一（0x，我相信预查能够节省许
多时间。不幸的是，Perl没有这样做，所以程序必须在每个目标字符串的每个字符那里测试
整个正则表达式的众多多选分支。速度达不到我的要求。
---
## Page 284
258
第6章：打造高效正则表达式
因为正在研究和撰写与优化有关的内容，所以我冥思苦想，这个表达式应该怎样写才能得
到优化。-个办法是以复杂的方式“\（0x（?[^：+）：或者占有优先量词[^：]++：就能够直接抛弃备用状态，
---
## Page 286
260
第6章：打造高效正则表达式
或者根本不会创造多少备用状态。因为引擎没有内容状态可以回溯，就不会进行不必要的
回溯（第251页的补充内容说明，足够聪明的引擎能够自动进行这种优化）。
不过，我必须强调，这两种结构运用不当，就会在不经意间改变匹配结果，所以必须极为
小心。如果不用.*：而用（?>.*）：，结果必然会失败。整行文本都会被.*：匹配，后面
的：就无法匹配任何字符。固化分组阻止最后的：匹配必须进行的回溯，所以匹配必定失
败。
主导引擎的匹配
Lead theEngine toa Mntch
提高正则表达式匹配效率的另一个办法是尽可能准确地设置匹配过程中的“控制权”。我们
曾经看过的用‘th（?：islat）取代‘thislthati的例子。在后一个表达式中，多选结构获得
最高级别的控制权，而在前一个表达式中，相对代价更高昂的多选结构只有在'thi匹配之
后才获得控制权。
下一节“消除循环”是这种技巧的高级形式，此处再介绍些简单的技巧。
将最可能匹配的多选分支放在前头
在本书中我们看到，许多时候多选分支的摆放顺序非常重要（28、176、189、216）。在
这些情况下，摆放顺序比优化更重要，但相反，如果顺序与匹配正确无关，就应该把最可
能匹配的多选分支放在首位。
举例来说，在匹配主机名的正则表达式（205）中，有人可能习惯把后缀按照字母顺序排
序，例如（?：aerolbiz|comlcoopl…)。不过，某些排在前头的后缀应用并不广泛，匹配
极有可能失败，为什么要把他们排在前头呢？如果按照分布数量的排序：（?：com|edulorgl
net!….)，更有可能获得更迅速更常见的匹配。
Y
当然，这只有对传统型NFA引擎才适用，而且只有存在匹配的时候才适用。如果使用POSIX
NFA，或是不存在匹配，此时所有的多选分支都必须检测，所以顺序是无关紧要的。
二
---
## Page 287
消除循环
261
将结尾部分分散到多选结构内
接下来我们比较（?:com|edu1..[a-z][a-z])\b;和com\b|edu\b|..\bl[a-z][a-z]\bl。
在后一个表达式中，多选结构之后的b被分散到每个多选分支。可能的收益就是，它可
能容许一个多选分支能够匹配，但多选分支之后的b可能导致这个匹配不成功，把b
加到多选结构之内，匹配失败的更快。这样不需要退出多选结构就能发现失败。
要说明这个技巧的价值，这可能还不是最好的办法，因为它只是适用于一种特殊情形，即
多选分支可能能够匹配，但是之后紧接的字符可能令匹配失败。在本章中我们会着到一个
更合适的例子—请参考280页关于SOTHER*的讨论。
这个优化是有风险的。切记，使用这个功能时要小心，不要因此阻正了本来可以进行的其
他优化。举例来说，如果“分散的”子表达式是文字文本，那么把“（?：thislthat）：）更
换为‘this：that：就违背了“将文字文本独立出来”（r255）中的某些思想。各种优化都
是平等的，所以在优化时请务必小心，不要因小失大。
在能够进行独立结尾锚点（*256）的系统上把正则表达式末尾的'$i分散，也会遇到这种问
题。在这些系统上，（?：comleduI..)$：比comsledusI.$i快得多（我测试了各种系统，只
有Perl使用了这种优化)。
消除循环
LlnrollingthicLoop
无论系统本身支持怎样的优化，最重要的收益或许还是来自于对引擎基本工作原理的理解，
和编写能够配合引擎工作的表达式。所以，既然我们已经考察了繁琐的细节，不妨登堂人
室，学习我说的“消除循环”的技巧。对某些常用的表达式来说，它的加速效果很明显。
举例来说，用它改造本章开头（226）会进行无休止匹配的表达式，能够在有限的时间内
报告匹配失败，而如果能够匹配，速度也会更快。
此处说的“循环”采用的是（this|that|…)*之类问题中星号代表的意义。之前的无休止匹
配"“（\\.1[^\\"]+)*"其实就属于此类。如果无法匹配，这个表达式需要近乎无限的时间
进行尝试，所以必须改进。
---
## Page 288
262
第6章：打造高效正则表达式
此技巧有两种不同的实现途径：
1.我们可以检查，在各种典型匹配中，（\\.[^\\"]+)*中的哪个部分真正匹配成功了，
这样就能留下子表达式的痕迹。再根据刚刚发现的模式，重新构建高效的表达式。这个
（或许联系不那么紧密的）概念模型就是一个大球，它表示表达式（…)*，球在某些文
本上滚动。（）内的元素总是能够匹配某些文本，这样就留下了痕迹，就好像是把脏兮
兮的雪球在地毯上滚过去一样。
2.另一个办法是，从更高的层面考察我们期望用于匹配的结构。然后根据我们认为的常见
情形，对可能出现的目标字符事做出非正式假设。从这个角度出发构建有效的表达式。
无论采取哪种办法，得到的表达式都是一样的。我首先讲解第一种思路，然后介绍如何通
过第二种思路取得同样的结果。
为了保证例子容易看懂，并尽可能广泛地使用，我会使用（）来代替所有括号，如果程序
支持非捕获型括号（？：）能够支持，使用它们能提高效率。然后会讲解固化分组（139）
和占有优先量词（142）的使用。
方法1：依据经验构建正则表达式
Mlethod 1: Building a Regex FromPast Experiences
在分析"（\\.1[^\\"]+)*"时，用若干具体的字符串来检验全局匹配的具体情况是很自然
的做法。举例来说，如果目标字符串是‘"hi"”，那么使用的自表达式就是""{^\\"]+"。
这说明，全局匹配使用了最开始的，然后是多选分支（~\\"]+，然后是末尾的“1。
如果目标字符串是：
"he said\*hi there\*and left"
对应的表达式就是[\\]+\（\\"]+A[\]+"。在这个例子里以及表6-2中，我
标记了对应的正则表达式，让模式更显眼。如果我们能对每个输人字符串构造特定的表达
式当然很好。这不可能，但我们能够找出一些常用的模式，构造效率更高，又不失通用性
的正则表达式。
现在来看表6-2前面的四个例子。下画线标注的部分表示”一个转义元素，然后是更多的正
常字符”。这就是关键：在每种情况下，开头是引号，然后是【^\\"1+，然后是若干个
11.[^\\"}+1。综合起来就得到（^\1"]+（\\.（^\\"]+)*1。这个特殊的例子说明，通用模
式可以用来构建许多有用的表达式。
---
## Page 289
消除循环
263
表6-2：消除循环的具体情况
目标字符串
对应的表达式
"hi there”
"[^\\*] + "
"just one \* here"
+[11]+[11]
"some \*quoted\" things"
+[11]+[11]+[11]
+[11]+[11]+[11]+[11]+[11]
“\"ok\"\n"
"empty\-\*quote"
“[]+[]+
构造通用的“消除循环”解法
在匹配双引号字符串时，引号自身和转义斜线是“特殊”的一一因为引号能够表示字符串
的结尾，反斜线表示它之后的字符不会终结整个字符串。在其他情况下，‘~\\"]就是普通
的点号。考察它们如何组合为[^\\"]+（（~\\"]+)*，首先它符合通用的模式
normal+(specialnormal+）*1
再添加两端的引号，就得到"[^\\"]+（△[\\"]+）*"。不幸的是，表6-2中下面两个例
子无法由这个表达式匹配。症结在于，目前这个正则表达式的两个[\\"]+要求字符串以
一个普通字符开始，然后是任何数目的特殊字符。从这个例子中我们可以看到，它并不能
应付所有情况一—字符串可能以转义元素开头和结尾，一行中间也可能包含两个转义元素。
我们可以尝试把两个加号改成星号：[^\\"]（[^\\"]*）*"。这会达到我们期望的结
果吗？更重要的是，它是否会产生负面影响？
就期望的结果来说，很容易看到所有的例子都能匹配。事实上，即使是"\"\"\""这样的字
符串都能匹配。这当然很不错。不过，我们还需要确认，这样重大的改变，是否会导致预
料之外的结果。格式不对的引号字符串能否匹配呢？格式正确的引号字符串是否可能无法
匹配呢？效率文如何呢？
仔细看看[\"]（[\\"）*"。开头的[\\"]*只会应用一次，这没有问题：它
匹配开头必须出现的引号，以及之后的任何普通字符。这没有问题。接下来的
（[^\\"]*）*是由星号限定的，所以不匹配任何字符也能够成功。也就是说，去掉这一
部分仍然会得到一个合法的表达式。这样我们就得到[~\\"]*"，这显然没有问题一它
代表了常见的，也就是没有转义元素的情形。
另一方面，如果[~\\"]*)*部分匹配了一次，其实就等价于[^\\"]*.[~\\"]*”。
---
## Page 290
264
第6章：打造高效正则表达式
.）
样分析下去（如果没记错的话，这就是高中代数中的“照此类推（byinduction）”），我们发
现，这样的改动其实是没有任何问题的。
所以，我们最后得到的，用来匹配包括转义引号的引号字符串的正则表达式就是：
fnx（[11]4）[11]