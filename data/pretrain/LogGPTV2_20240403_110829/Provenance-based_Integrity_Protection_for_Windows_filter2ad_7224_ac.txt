tialization stage are not intercepted. This means that if a
library used by a benign application is somehow replaced by
a low-integrity version, a malicious library could be silently
loaded into a high-integrity process. Our current defense
relies on the inability of untrusted applications to replace a
high-integrity ﬁle, but subtle attacks may be possible where
an application loads a DLL from the current directory if
the DLL is present, but if the DLL is not found, it starts
normally. A better solution is to develop a kernel driver to
enforce a no-read-down policy on ﬁle loads.
Our prototype does not consider IPC that takes place
through COM and Windows messages. COM supports ACL,
so it may be easy to handle. Windows messages cannot be
protected using userids because any process with a handle
to the desktop can send message to any other process on the
desktop. This is known as a shatter attack. As a result, an
untrusted process can send Windows messages to a benign
process. There are two ways to solve the problem: The ﬁrst
method is to apply job control in Windows to prevent un-
trusted processes from accessing handles of benign processes.
By setting the JOB_OBJECT_ULIMIT_HANDLES restriction, a
process cannot access handles outside of the job. The other
method is to run untrusted processes as low WIM integrity
processes. WIM already prevents lower integrity processes
from sending messages to higher integrity processes.
Our prototype does not support untrusted software whose
installation phase needs administrative privileges. If we en-
force the no-read-down policy, the installation won’t proceed.
If we waive it, then malicious software will run without any
conﬁnement, and can damage system integrity. Techniques
for secure software installation [41] can be applied to solve
this problem, but will need to be implemented for Windows.
5. EXPERIMENTAL EVALUATION
In this section, we ﬁrst discuss the implementation com-
plexity of Spif, and then proceed to evaluate its performance,
functionality, and security.
5.1
Implementation complexity
Spif consists of 4000 lines of C++ and 1500 lines of header.
This small size is a testament to the design choices made in
our design. A small code size usually translates to a higher
level of assurance about safety and security.
5.2 Performance
All performance evaluation results were obtained on Win-
dows 8.1. (Performance does not vary much across diﬀerent
versions of Windows.) Figure 3 shows that on the CPU-
intensive SPEC2006 benchmark, Spif has negligible over-
head. This is to be expected, as the overhead of Spif will
be proportional to the number of intercepted Windows API
calls, and SPEC benchmarks make very few of these.
We also evaluated Spif with Postmark [18], a ﬁle I/O
intensive benchmark. To better evaluate the system for
Windows environment, we tuned the parameters to model
401.bzip2
429.mcf
433.milc
445.gobmk
450.soplex
456.hmmer
458.sjeng
470.lbm
471.omnetpp
482.sphinx3
Base (s)
1785.9
716.4
3314.1
1094.9
1108.0
2386.2
1442.5
1203.0
750.9
2653.6
Benign (%) Untrusted (%)
0.26%
-0.96%
-0.53%
-0.08%
2.34%
0.13%
0.20%
-0.32%
1.83%
-3.45%
-0.33%
-1.69%
1.15%
0.26%
0.58%
0.02%
-0.25%
-1.51%
0.96%
-2.55%
Mean Overhead
-0.336%
-0.059%
Figure 3: SPEC2006 ref benchmark
File Size
Operations
Files Created per Second
File Read per Second
File Appended per Second
File Deleted per Second
Total Transaction Time (s)
500B to 5KB
5KB to 300KB
300KB to 3MB
Base
351.14
350.14
344.79
350.21
285.36
Benign Untrusted
-5.02%
-10.45%
-10.59%
-5.18%
-10.58%
-5.19%
-10.57%
-5.17%
6.53%
12.38%
Base
68.00
67.64
67.64
67.86
367.29
Benign Untrusted
-2.79%
-2.02%
-2.34%
-3.02%
-2.61%
-3.02%
-2.00%
-3.03%
3.05%
4.58%
Base
8.00
7.60
8.00
8.00
308.67
Benign Untrusted
-1.25%
-1.56%
-1.97%
-3.95%
-2.34%
-2.50%
-2.34%
-1.25%
1.27%
-0.62%
Figure 4: Postmark overhead for high and low integrity processes in Spif
ﬁles on a Windows 8.1 system. There were 193475 ﬁles on
the system. The average ﬁle size is 299907 bytes, and the
median is a much smaller 5632 bytes. We selected 3 size
ranges based on this information: small (500 bytes to 5KB),
medium (5KB to 300KB), and large (300KB to 3MB) bytes.
Each test creates, reads, writes and deletes ﬁles repeatedly
for about 5 minutes. We ran the tests multiple times and the
average is presented in Figure 4. There are three columns
for each ﬁle size, showing (a) the base runtime obtained on
a system that does not have Spif, (b) the overhead when
the benchmark is run as a high-integrity process, and (c)
the overhead when it is run as a low-integrity process. As
expected, the system shows higher overhead for small ﬁles.
This is because there are more frequent ﬁle creation and
deletion operations that are intercepted by Spif. For larger
ﬁles, relatively more time is spent on reads and writes, which
are not intercepted by Spif.
We also benchmarked Spif with Firefox. Speciﬁcally, the
time required to load webpages. We used a standard test
suite [31] to perform page load tests. We fetched Alexa top
1000 pages locally to eliminate network variances. Figure 5
shows the correlation between unprotected page load time
with protected benign Firefox and untrusted Firefox. The
overheads for benign Firefox and untrusted Firefox are 3.32%
and 3.62% respectively.
5.3 Functionality evaluation
Figure 6 shows a list of unmodiﬁed applications that can
run successfully at high- and low-integrity in Spif. We used
them to perform basic tasks. These applications span a
wide range of categories: document readers, editors, web
browsers, email clients, media players, media editors, maps,
and communication software.
World-writable ﬁles. Some applications intentionally leave
some directories and ﬁles as writable by everyone. As such,
low-integrity processes can also write to these locations. Spif
prevents low-integrity processes from writing into these loca-
tions by revoking write permissions from low-integrity users.
This is achieved by explicitly denying writes in ACLs.
Figure 5: Firefox page load time correlation
Readers
Document
Proces-
sor
Adobe Reader, MuPDF
MS Oﬃce, OpenOﬃce, Kingsoft Oﬃce, Notepad 2,
Notepad++, CppCheck, gVim, AklelPad, IniTranslator,
KompoZer
Internet
Internet Explorer, Firefox, Chrome, Calavera UpLoader,
CCProxy, Skype, Tor + Tor Browser, Thunderbird
Media
Photoshop CC, Picasa, GIMP, WinAmp, Total Video
Player, VLC, Picasa, Light Alloy, Windows Media
Player, SMPlayer, QuickTime
Other
Virtual Magnifying Class, Database Browser, Google
Earth, Celestia
Figure 6: Sample applications supported by Spif
Some system ﬁles are writable by all users, yet they are
protected by signatures. Spif currently does not consider
digital signatures as integrity label, and hence we grant
benign processes exceptions to read these “untrusted” ﬁles.
A better approach is to incorporate signatures into integrity
label so that no exception has to be granted.
Apart from ﬁles, there are also other world-writable re-
sources such as named pipes and devices for system-wide
services. Spif grants exceptions for these resources as none of
them can be controlled by low-integrity processes and hence
do not carry low-integrity information.
Reading both high and low integrity ﬁles. Applica-
tions that only read, but not modify ﬁles can always start as
low-integrity, so that they can consume both high and low
integrity ﬁles.
Editing both high and low integrity ﬁles. Spif does
not allow a process to edit ﬁles of diﬀerent integrity simul-
taneously as this can compromise the high-integrity ﬁles.
However, Spif allows ﬁles to be edited in diﬀerent processes—
edit high-integrity ﬁles in high-integrity processes, and edit
low-integrity ﬁles in low-integrity processes. As these pro-
cesses are running as diﬀerent users, diﬀerent instances of
the same application can run simultaneously in Spif.
When it is the users’ intention to open low-integrity ﬁles,
Spif opens the ﬁles with low-integrity processes. However,
when users do not expect opening the low-integrity ﬁles,
such openings would be denied. Spif considers user-actions
such as double-clicking on the ﬁles, selecting ﬁles from a ﬁle-
dialog box, or explicitly typing the ﬁle names as indications
of their intents. When intent is inferred in this manner,
Spif runs the applications as low-integrity. Spif currently
captures such intents via user interaction with the Windows
Explorer: when users double-clicked to open a ﬁle, Windows
Explorer will execute the handler programs with the ﬁle-
path as an argument. When the ﬁle-path corresponds to a
low-integrity ﬁle, Spif considers this as a user-consent for
starting a program as a low-integrity process.
Low-integrity processes writing high-integrity ﬁles.
Applications like OpenOﬃce maintain runtime information
in user proﬁle directories. Applications expect these ﬁles to be
0200060001000002000600010000Benign FirefoxUnprotected (ms)Benign (ms)0200060001000002000600010000Untrusted FirefoxUnprotected (ms)Untrusted (ms)CVE/OSVDB-ID
Application
Attack Vector
2014-0568
Adobe Reader
CVE-2010-2568
Windows Explorer
Code
Data (lnk)
2014-4114/113140
(Stuxnet)
Windows
(Sandworm)
Data (ppsx)
104141
100619
Calavera UpLoader
Total Video Player
Preference (dat)
Preference (ini)
2013-6874/100346
2013-3934
Light Alloy
Kingsoft Oﬃce
Data (m3u)
Data (wps)
102205
2013-4694/94740
2014-2013/102340
Writer
CCProxy
WinAmp
MuPDF
Preference (ini)
Preference (ini)
Data (xps)
Figure 7: Exploits defended by Spif
both readable and writable— otherwise they will simply fail
to start and crash. Having these ﬁles as high-integrity would
prevent low-integrity processes from being usable. Letting
these ﬁles become low-integrity would break availability of
high-integrity processes.
Spif shadows accesses to these ﬁles inside user-proﬁle
directories, hence high- and low-integrity processes can both
run without signiﬁcant usability issues. One problem is
that proﬁles for high and low integrity sessions are isolated.
There is no safe way to automatically merge the shadowed
ﬁles together.
5.4 Security evaluation
We evaluated the security of Spif against malware from
Exploit-DB [34] on Windows XP, 7 and 8.1. We selected all
local exploits targeting Windows platform, mostly released
between January and October of 2014. Since these exploits
work on speciﬁc versions of software, we only included mal-
ware that “worked” on our testbed, and their results were easy
to verify. Figure 7 summarizes the CVE/OSVDB-ID, vulner-
able applications, and the attack vectors. We classify attacks
into three types: data input attacks, preference/conﬁguration
ﬁle attacks, and code attacks.
Note that by design, Spif protects high-integrity processes
against all these attacks. Since high-integrity processes can-
not open low-integrity ﬁles, only low-integrity applications
can input any of the malware-related ﬁles. In other words,
attackers can only compromise low-integrity processes. More-
over, there is no mechanism for low-integrity processes to
“escalate their privilege” to become high-integrity processes.
Note that since low-integrity processes can only modify ﬁles
within the shadow directory, they cannot aﬀect any user or
system ﬁles. For this reason, Spif stopped all of the attacks
shown in Figure 7.
Both data and preference/conﬁguration ﬁle attacks concern
inputs to applications. When applications fail to sanitize
malicious inputs, attackers can exploit vulnerabilities and
take control of the applications. Data input attacks involve
day-to-day ﬁles like documents (e.g., wps, ppsx, xps). They
can be exploited by simply tricking users to open ﬁles. On
the other hand, attacks using preference/conﬁguration ﬁles
are typically hidden from users, and are trickier to exploit
directly. These exploits are often chained together with