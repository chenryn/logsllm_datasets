Coldfusion 12的所有jar文件以外部库方式添加到工程中。
首先我想到的是寻找对Java的`ObjectInputStream.readObject`方法的进一步调用情况。使用Eclipse可以轻松完成这个任务，只需要打开`ObjectInputStream`类，右键点击`readObject()`方法，然后点击“Open
Call Hierarchy”即可。感谢JD-Eclipse以及反编译器的强大功能，Eclipse可以根据收集到的类信息，在没有源代码的情况下重新构造整个函数调用图。调用图最开始看起来规模非常庞大，但只要具备一定经验，你很快就能发现整张图中哪些节点比较有趣。经过几个小时的分析后，我找到了两个比较有希望的调用图。
###  基于SETTER方法的利用技术
第一个切入点源自于`org.jgroups.blocks.ReplicatedTree`类的`setState(byte[] new_state)`方法。
阅读这个方法的实现代码，我们可以想象第605行会出现什么状况。
    /*      */   public void setState(byte[] new_state)
    /*      */   {
    /*  597 */     Node new_root = null;
    /*      */     
    /*      */
    /*  600 */     if (new_state == null) {
    /*  601 */       if (log.isInfoEnabled()) log.info("new cache is null");
    /*  602 */       return;
    /*      */     }
    /*      */     try {
    /*  605 */       Object obj = Util.objectFromByteBuffer(new_state);
    /*  606 */       new_root = (Node)((Node)obj).clone();
    /*  607 */       root = new_root;
    /*  608 */       notifyAllNodesCreated(root);
    /*      */     }
    /*      */     catch (Throwable ex) {
    /*  611 */       if (log.isErrorEnabled()) { log.error("could not set cache: " + ex);
    /*      */       }
    /*      */     }
    /*      */   }
快速查看函数调用图后，我们确认调用链的最后一个节点是调用`ObjectInputStream.readObject()`。
这里只需要注意一件事情：传递给`setState()`的`byte[]`参数在`0x0`偏移处有一个额外的字节`0x2`，我们可以在`org.jgroups.util.Util`类的364行代码中看到这个信息。
    /*      */   public static Object objectFromByteBuffer(byte[] buffer, int offset, int length) throws Exception
    /*      */   {
    /*  358 */     if (buffer == null) return null;
    /*  359 */     if (JGROUPS_COMPAT)
    /*  360 */       return oldObjectFromByteBuffer(buffer, offset, length);
    /*  361 */     Object retval = null;
    /*  362 */     InputStream in = null;
    /*  363 */     ByteArrayInputStream in_stream = new ByteArrayInputStream(buffer, offset, length);
    /*  364 */     byte b = (byte)in_stream.read();
    /*      */     try {
    /*      */       int len;
    /*  367 */       switch (b) {
    /*      */       case 0:
    /*  369 */         return null;
    /*      */       case 1:
    /*  371 */         in = new DataInputStream(in_stream);
    /*  372 */         retval = readGenericStreamable((DataInputStream)in);
    /*  373 */         break;
    /*      */       case 2:
    /*  375 */         in = new ObjectInputStream(in_stream);
    /*  376 */         retval = ((ObjectInputStream)in).readObject();
    /*      */       //...
    /*      */       }
    /*      */      }
    /*      */ }
漏洞利用情况如下图所示：
这个漏洞利用方法针对的是Adobe ColdFusion 12，并且只有启用JGroups时才能利用成功。
###  基于Externalizable的利用技术
第二个切入点源自于`org.apache.axis2.util.MetaDataEntry`类的`readExternal`方法。
在代码中的297行，程序会调用`SafeObjectInputStream.install(inObject)`方法。
    /*     */   public static SafeObjectInputStream install(ObjectInput in)
    /*     */   {
    /*  62 */     if ((in instanceof SafeObjectInputStream)) {
    /*  63 */       return (SafeObjectInputStream)in;
    /*     */     }
    /*  65 */     return new SafeObjectInputStream(in) ;
    /*     */   }
在这个函数中，我们的`AMF3Input`实例属于`org.apache.axis2.context.externalize.SafeObjectInputStream`类的一个实例。
    /*     */   private Object readObjectOverride()
    /*     */     throws IOException, ClassNotFoundException
    /*     */   {
    /* 318 */     boolean isActive = in.readBoolean();
    /* 319 */     if (!isActive) {
    /* 320 */       if (isDebug) {
    /* 321 */         log.debug("Read object=null");
    /*     */       }
    /* 323 */       return null;
    /*     */     }
    /* 325 */     Object obj = null;
    /* 326 */     boolean isObjectForm = in.readBoolean();
    /* 327 */     if (isObjectForm)
    /*     */     {
    /* 329 */       if (isDebug) {
    /* 330 */         log.debug(" reading using object form");
    /*     */       }
    /* 332 */       obj = in.readObject();
    /*     */     } else {
    /* 334 */       if (isDebug) {
    /* 335 */         log.debug(" reading using byte form");
    /*     */       }
    /*     */       
    /* 338 */       ByteArrayInputStream bais = getByteStream(in);
    /*     */       
    /*     */
    /* 341 */       ObjectInputStream tempOIS = createObjectInputStream(bais);
    /* 342 */       obj = tempOIS.readObject();
    /* 343 */       tempOIS.close();
    /* 344 */       bais.close();
    /*     */     }
    /*     */   //...
    /*     */   }
上述代码的341行会创建`org.apache.axis2.context.externalize.ObjectInputStreamWithCL`类的一个新的实例，这个类扩展了（extend）标准的`java.io.ObjectInputStream`类。在第342行，我们最终实现了对`readObject()`方法的调用。
漏洞利用情况如下图所示：
这种漏洞利用方法适用于Adobe ColdFusion 11以及12。
###  COLDFUSIONPWN工具
为了让我们的工作更加轻松，我开发了一款简单的工具：
**[ColdFusionPwn](https://github.com/codewhitesec/ColdFusionPwn)**
。这是一款命令行工具，我们可以通过该工具生成序列化后的AMF消息。该工具可以与Chris Frohoff的ysoserial配合使用生成gadget。
## 六、总结
毋庸置疑，反序列化不可信的输入数据并不是一件好事。从攻击者的角度来看，利用反序列化漏洞是一项富有挑战性的任务，因为他们需要找到“正确”的对象（即gadget），才能触发漏洞、构造利用路径，然而这也是非常有趣的一个探索历程。
顺便提一句：如果你想深入了解服务端的Java利用技术，理解Java中的各种反序列化漏洞，正确开展静态以及动态分析，那么你应该会对我们即将推出的“Java高级利用技术”课程感兴趣。