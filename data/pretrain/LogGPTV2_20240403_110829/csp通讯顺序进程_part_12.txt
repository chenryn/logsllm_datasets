个非常贪吃的左邻座。还没等他把左边的叉子拿起来，那位邻座
被他的邻位抢了先。假设一位入座的哲学家左手不太灵活，又有
2.5.5无限抢先
计人员去处理。
限进程来说，其死锁的不存在性的证明还必须留给并发系统的设
历全部这类迹，简直是不可能的。因此，即使对一个很简单的有
数就超过21.8k10"了。尽管是有穷多个，但要让一个计算机程序减
态中几乎都包含了两个或更多的可能事件，我们要考虑的迹的个
以NEWCOLLEGE的状态不比COLLEGE多。叉因为在每个状
大约1.8×10°。叉山于仆人的字母表也包含在COLLEGE中，所
个状态，每把叉子有三个状态，则COLLEGE的状态总数不超过
的长度不会超过可由状态数计算出的某个已知上限。（PIQ）的状
样的有限状态系统中，所需考虑的迹，只是有穷多个，因为它们
这个程序是否已经逼历了全部可能行为。
来研究这个系统所有可能的行为，以寻找死锁。一般说来，使用
地叙速的。现在我们换一种证明方法：设计一个计算机程序，用
如果五把叉子都被拿起来了，则这四位中至少有一位--定在吃了。
位左侧的那位不仅左手握叉，而且还能把他右边的叉子也拿起来。
，除了死锁之外，吃饭的哲学家还面临着另一个危险一一总是
这个证明要分析好几种情况，是用这一实例的行为，非形式
Xg9
但是象在COLLEGE这
9
---
## Page 85
行事件f（c)。它遵从以下规则
我们定义f(P)为这样一个进程：
A上去
组进程。设为一个单射函数，它将F的字母表映射到符号集合
这一节里，我们介绍一个很方便的方法，用以定义行为相似的成
叉子；每一组中进程的行为相似，只是执行的事件的名字不同。
把叉子都拿起来之后，才去帮着这个人的左右邻居人座。
的行为：在他帮着-一位哲学家入座后，他就一直等到这个人把两
心面，才可以解决这个问题。
么聪明的办法使大家都满意，只能再多买几把叉子，多添几次通
则肯定有人（不是他就是他的邻座）要长时间埃饿。实在没有什
学家总也吃不成。
来，
X1
（f*的定义看1.9.1节）。
但是，如果保证入座的人最终都能吃到，可以修改一下男仆
这个问题没办法解决，因为如果真有位那么贪吃的哲学家，
，我们以下列方程式定义函数
过了几年之后，所有的东西都要涨价。要把通货膨涨表示出
在前一节所举的例子中有两组进程，一-组是哲学家，
举例
f(outip)=out5p
f(inip)=in5p
f(in2p)=in10p
traces(f(P))={f*(s)|s∈traces(P))
af(P)=f(aP)
2.6符号变换
f:aP-A
当P执行事件时，f(P)就执
f(small) = small
f(large) = large
-组是
---
## Page 86
值舒注意的是，山f和9的定义可见，左边的运算对象的输出0
我们需要的结果就是
个COPYBIT的输出及另--个COPYBIT的输入，即
入两个新的事件mid.0和mid.1，再定义函数f和9，以变换
COPYBIT里去。首先，我们变一下用作内部通信的事件名；引
这样由第一个COPYBIT输出的每个数位可同时输入到第二个
X4我们希望把两个COPYBIT（参看1.1.3节X7）连接起来；
进程的独立动作；但是around就需要两个进程同时参加，故
垂直和水平移动分别看作是下同
圈。用第2.3背X2中的办法，将
也仅在这个方格里，它才允许转
边沿，如右图筹码从左下角出发
方无穷的，其边界在左边沿和下
左、右移动，这块板是上方和右
X3一个筹码可在板中上、下、
并发组合时充分发挥作川。
是向左和向右移动，面不是向上或向下移动，合
则新的自动售货机就是
X2:
f(up)=right,
我们对进程的事件名做这种变换，主要的原因是使它们能在
--个筹码，行为跟CT。相同（1.1.4背X2)，不同的是，它
CHAIN2 = f(COPY BIT)I9(COPY BIT)
g(out.0)=out.0,
f(out.1)=g(in.1)=mid.1
f(out.0)=g(in.0)= mid.0
f(in,0) =in.0,
NEWVMC= f(VMC)
f(down)=left.
LRUD = LR。ICT,
LR,=f(GT)
g(out.1)= out.1
f(in.1)=in.1
f(around) = around,
—----
口
口
口
---
## Page 87
所以确定发生哪个事件的总是输出进程。并发进程之间的这种通
运算对象则准备好或者执行事件mid.0，或者执行事件mid.1。
型，该通信是在一条连接了两个运算对象的通道上进行的。
mid.1)。这样就给出了图2.7所示的二进制数字的同步通信的模
或1与其右边运算对象的输入0或1完全是同一事件（mid.0，或
的解剖程序就能将这类错误指出。
—这恐怕是程序错误中最容易发觉的出错方式了，因为最简单
赋值前是不会给出它的值的。要取一个未赋的植，将导致死锁
函数/的定义留作小小的练习。要注意的是这个布尔变量在未被
我们定义
变量的行为与饮料分配器（1.1.4节X1）的行为非常相似，所以
母表中的事件有
X5我们想把计算机程序中使用的布尔变量的行为表示出来。字
能会引人非确定性，所以我们把这个问题推后到3.5节去处理，
把这类内部事件忽略或屏蔽掉，但在一般情况下，做这类屏截可
并且可被进程的环境观察到（甚至可受环境控制）。有时我们希望
信方法在第四章中还要推广成更一般的情形。
注意内部通信mid.0和mid、1包含在组合进程的字母表中，
0t61580
左边的运算对象决定在连接通道上传送哪一个值，而右边的
jetchl
fetcho
assignl
in.1
in.0.
COPYB!T
当变量为1时取出变量的值
当变量为0时取出变量的值
给变量赋1值
给变量赋0值
BOOL= f(DD)
函2.7
mid.0
mid.
COPYBIT
our.D
ou.1
·口
---
## Page 88
强调f是单射函数，主要是因为在法则中要用到f-。
律，详见下述法则。为此我们还要用到几条辅助定义如下，
点由以下事实即可得出：1-1函数运算对其它一切算子均有分配
2.6.1法则
应变化，故
在选择的情况下，供选择的符号变了，且进程的后续行为也要相
的示意图如图2.8。
且由同一结点引出的分叉上的标记仍互不相同。例如NEWVMC
的树形图。由于/是1-1函数，故该变换仍能保持树的原结构，而
L2
f(x:B→P(x))=(y:f(B)→f(P(f-1(y))))
在应用1-1面数变换符号时不会改变进程的行为结构。这一
经过符号变换后，STOP在改变后的字母表中仍什么都不做，
把函数作用于P的树形图各枝的标记上，就得到了{（P）
f(B)={f(x)|x∈B}
f-1
in5p
定义见1.9.1节
f和9的复合
f的逆函数
in5p
图2.8
iorgt
in16p
ot15p
---
## Page 89
2.6.2进程标记
L7f(P)/f*(s)=f(Pjs)
最后一条法则的解释说明与L6类似
L6 traces(f(P))= {f*(s)/s∈iraces(P))
变换后得到的，故
L5
递归式的有效性。
表为A，应用就将字母表变成(A)，以此保证法则L4等式右边
此要用--下反函数f-I将字母表变回去。现在F（f-I(Y)）的字母
只有当其字母表经反变换回到A之后，才能做为F的自变量。为
式右边，变量Y的变化范围是所有宇母表为(A）的进程，因此
数F的计算结果也是个进程，它与自变量的字母表相同。L4中等
递归式有效，要求函数F的自变量为字母表为A的进程，而且函
等式右边的f1又让人迷惑不解了。以前讲过，要使等式左边的
LAf(μX:A.F(X))=(uY:f(A).f(F(f-(y))))
它对递归式的分配律更稍微复杂些，且使进程字母表相应地变化，
L3 f(PHQ) =f(P)If(Q)
要继续变换。
为就是 P(f-(y))，而且进程 P(f-"(y))的动作在f的作用下还
有
且f-（y)在B中（因为'y∈f（B)）。执行完f-(y)之后，P的行
量y是集合f(B）的元素。对P来说，y的对应事件就是f（y），
根据由集合B中选出的某事件x得到一个进程，但等式右边的变
等式右边的/-1可能需要解释-一下。我们说过P为一函数，它要
符号变换在组建由类似的进程组成的群体时特别有用，这些
经变换符号后的进程的迹，是将原进程的迹中的各个符号都
f(g(P))=(/·g)(P)
两次符号变换的复合就定义为两个符号变换函数的复合，即
符号变换显然对并行组合有分配律，故
---
## Page 90
进程USER与它的两个布尔变量持行运行
赋值和取值。这样αUSER中就包括了如下的复合事件
块其行为表示为进程USER。该进程对两个布尔变量b和进行
X2布尔变量的行为的模型是BOOL（2,6节X5)。有一个程序
样使用进程了，这类变量只在具体用到它们的程序块中局部地说
名，则每个事件的发生都要求它们同时参予。这样一来这两台机
这两个逃程的宇母表是不相交的，而且在哪台机器上发生的事伴
X1两台并排放置的自动售货机记为
明。
器就跟一台没什么区别了。由这一事实我们推出
而标记的定义是
就用那台机器的名字做上标记。万一在并排放置之前没给他们赋
每当P要执行x时，l:P就执行L.x。定义I:P所用的函数是f
的事件是个二元组“x，其中！是标记，x是代表该事件的符号。
把进程的每个事件也标记上与共所属进程相同的名字。做了标记
交。为了做到这一点，我们把每个进程都标记上不同的名字；再
间不发生联系。这意味着它们的字母表必须互不相同而且互不相
类似进程并发操作，对其外部环境提供相同的服务，但是相互之
c.fetch1
b,assigno
有了进程标记，就可以象使用高级程序设计语言里的变量那
标记为！的进程P表示为
举例
(SWA:z4O!ulSNA:1fa1)
(VmSVmS) =VmS
当c的值为1时取出其当前值
给b赋0值
f1(x)=l.x
l:P=f(P)
1:P
éαP
9
口
---
## Page 91
CT（1.1.4节X2)，但需用！和m作为适当标记。即有
而不是直接定义命合对
择的方法，以发现变量当前的；还要注意该选择并以适当方式
要注意的是，我们是通过允许变量在fetoho和fetch1之间做出选
在程序USER内部，可以等效地表示
少1。这样！就要在这两个事件中选择：如果！的值为0，它就
检验！是否为馨的同时，也试用事件I.4own去将计数变量【减
注意检验变量是否为零是这样进行的：进程在试用事件I.around
在进程USER内，可以等效地表示习惯使用的
是否为0的事件为l.around和m.around。所以就可以使用进程
值（当变量髓大于容时）的事件为l.down和m.down。检验变量
别为0和3，USER使每个变量增值的事件为I.up或m,up，减
X3进程USER需要两个计数变量I和m。给它们赋的初值分
方法将在第五章中介绍。
在命合对中明确提到了程序的剩余部分P。单独定义赋值命合的
例如先定义赋值
影响USER的后续行为。
里选择了l.down之后，I的值就被减少1，故需用事件l.up立职
选择I.around，如果它不是0，就选择l.down。但在后一种情况
在X2及以下儿例中，如果先定义了赋值，可能就更方便了，
8
if l = 0 then P else Q 为 (l.aroundP|l,down-l,up→Q)
b:=false;P
b:BOOL|c:BOOL|USER
(m=m+I;P)
b:=-c;P
为
(l:CT,|m:CT,IUSER)
为
·(c.fetcho-→b.assignl-P
(b,assigno-→P)
[o.fetch1-b,assign0-→P)
b:=false,P
为（m,up-→P）
b:=false