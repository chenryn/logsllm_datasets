possible ranges. B¨ock et al. [12] also mention the possibility
of using multiple servers to parallelize the attack. However,
they do not present a concrete method of doing this. Nguyen
[52] shows how to replace the search in the Bleichenbacher
attack with a lattice technique that the author claims to be
more intuitive than the search. However, this lattice technique
is not used for paralleilzation and is much less efﬁcient than
the technique we present in this work.
Limitations of Trivial Parallelization. A trivial method for
parallelizing Bleichenbacher attacks is to concurrently send
multiple queries with different values for si in each phase
of the attack. When one of the ciphertexts is found to be
conforming, the attacker can reduce the range and proceed
with the next step. Another approach is to parallelize the mul-
tiple identical queries for error correction in Bleichenbacher
and Manger attacks mentioned in Section VI-B. The main
drawback of these approaches is that both the Bleichenbacher
N sequential
and the Manger attacks require at least log2
queries.
Our Approach.
In this paper we present a new approach that
reduces the number of sequential queries we need to perform.
In a nutshell, we perform multiple padding oracle attacks in
parallel, each starting from a different initial blinding value.
(cid:21)(cid:21)(cid:22)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:53:49 UTC from IEEE Xplore.  Restrictions apply. 
We do some range reduction for each of the parallel attacks,
but stop short of completing any of them. We then use a lattice
technique to combine the information we learn in each of the
attacks and recover the key.
A. Parallelization of the Manger Attack.
j, bi
j, bi
Recall the Manger attack from Section II-D. After com-
pleting Phase 1 of the attack, at each step, we know that
m · s mod N is inside the interval [a, b], where m is the
unknown plaintext, s is the known blinding value and N is
the RSA modulus. The attack’s goal is to decrease the size of
the interval [a, b], which is achieved in every adaptive attack
step. When a = b, we know that a = m · s mod N, and
can recover the original plaintext by calculating m = a · s−1
mod N. Thus, if the attacker can approximately halve the size
of the interval in each step it is possible to complete the entire
attack with ≈ log2
The Parallel Case.
Consider a scenario where we run k
Manger attacks in parallel, but only have time for i adaptive
steps for each attack. Thus, for after i attack steps, the interval
of jth attack is [ai
j]. We note that this reduces the search
space for m to the interval [ai
j], which (abusing information
N−
theory terminology) roughly represents learning I i
log2 (bi
j) bits of information on m. If after i adaptive
N we can recover the value of m. At
queries
this stage we have a set of equations of the form
j−ai
N adaptive queries.
(cid:7)k
j − ai
I i
j > log2
j mod N < 2log2 (bi
(1)
Lattice Construction. We note that this set of equations is
very similar to the hidden number problem [13], and similar
to past solutions to the hidden number problem [9, 13, 15,
29, 34, 53], we use a lattice technique to solve our equations.
Speciﬁcally, we form the lattice M i
sk
0
0
0
s1
s3
s2
N 0
0
0 N 0
0
. . .
. . .
. . .
0 N . . .
...
...
...
. . . N
k N · (k − 1)/k
ai
. . .
⎢⎢⎢⎢⎢⎢⎢⎢⎢⎣
j = m · sj − ai
ri
⎥⎥⎥⎥⎥⎥⎥⎥⎥⎦
j = log2
M i =
0
0
0
0
...
0
⎡
⎤
j=1
j ).
...
0
ai
1
...
0
ai
3
0
ai
2
We note that, from Equation 1, the vector
, ri
2
, . . . , ri
Ri = (ri
1
k,−N · (k − 1)/k)
j < N · (k − 1)/k we get that
is in the lattice, and assuming ri
Ri is a short vector in the lattice M i. We can now use the
LLL algorithm [45] to ﬁnd a reduced basis for the lattice, and
with high probability Ri is the second vector in the reduced
1) · s−1
basis.1 Finally, we ﬁnd m by calculating m = (ri
mod N.
Analyzing the Parallel Attack. We would like to analyze
the trade-off between the number of adaptive queries and
the number of parallel oracles. In the Manger attack the
1 + ai
1
1The ﬁrst row is zero as M i does not have full rank.
blinding phase requires on average 128 parallel queries, and
gives us 8 bits of information on the plaintext. The next
two phases (called steps 1 and 2 in the original paper) are
harder to analyze, but experiments show that they usually
require 40–100 adaptive queries and give us 8–12 extra bits
of information. After that, each adaptive query gives us
approximately one bit of information. For an RSA modulus
of 2048 bits the original Manger attack without blinding
requires ≈ 2100 adaptive queries and just one oracle (which
requires negligible computation). On the other extreme we can
try a fully parallelized attack using only the blinding phase.
This will require approximately 128 · 256 = 32768 parallel
queries, that will result in 256 equations giving us 8 bits
each. Recovering the plaintext will require us to reduce a
relatively large lattice of dimension ≈ 256, which requires a
considerable amount of computation. A more efﬁcient trade-
off is to run a moderate number of partial adaptive attacks in
parallel.
Parallel Manger Attack Simulation. We ran a simulation to
test the feasibility of performing a MitM on a TLS connection
and a 2048 bits RSA with multiple parallel partial Manger
attacks. We assume that we have 30 seconds before the TLS
connection times out and that each TLS handshakes takes
about 0.05 seconds (which is the actual time measured on
a Core i7-7500U CPU @ 2.70GHz). We allow each of the
parallel attacks to have 560 adaptive oracle queries, leaving
two seconds for the lattice reduction and for ﬁnalizing the
handshake. We simulate a parallel attack using ﬁve servers
(The minimal number of servers required to ﬁt at least 2048
queries in 30 seconds is four, but due to overheads we require
at least ﬁve servers).
We start by running the blinding phase in parallel until we
get ﬁve valid blinding values. We then use our remaining
queries to continue the ﬁve attacks in parallel. As before,
we perform 500000 simulations of the attack, each simulation
running ﬁve attacks in parallel. With probability 0.001 we get
at least 438 bits of information from each of the ﬁve attacks, or
a total of more than 2190 bits. This is more than the required
number of bits to recover the plaintext. We successfully
implemented and tested a proof of concept of the lattice
reduction and were able to perform the plaintext recovery
using the LLL algorithm in Sage [63] with a negligible run
time of less than 0.01 seconds (running on a Intel Core i7-4790
CPU @ 3.6GHz).
B. Parallelization of the Bleichenbacher Attack.
The Bleichenbacher attack can also be parallelized in the
same way as we have shown for the Manger attack. We assume
k parallel attacks. For each attack we start with a different
blinding value, such that for attack number j we know that
j < 3B − 1. After i adaptive queries we learn that
2B < s0
ai < si
j < bi.2 Using this information we can recover the
plaintext as we have done for the Manger attack.
2With low probability we might have more than one possible domain, and
in that case we can take the domain from one of the previous queries
(cid:21)(cid:21)(cid:23)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:53:49 UTC from IEEE Xplore.  Restrictions apply. 
≈ log N consecutive calls to the oracle. Larger keys (at least
2048 bits) take longer to attack and might make MitM attack
less practical.
Handshake Timeouts.
It is harder to do a MitM attack when
the TLS handshake timeout is very short. Clients should use
short TLS timeouts, and make sure they are resilient to any
attack that can lengthen the timeout (such as the TLS warning
alerts attack against Firefox [4]).
Speed Limitation. As RSA key exchanges are only a small
fraction of today’s TLS trafﬁc [1, 51], limiting the speed of
allowed RSA decryptions makes MitM attacks less practical.
Dedicated Hardware for Sensitive Cryptographic Code.
Side channel attacks are extremely difﬁcult to defend against.
Critical and sensitive operations such as private key decryption
should not be run on a shared hardware if possible.
B. Future Work
Timeouts in TLS Client. As we have seen in this work and
previous works [4], the possibility of doing some MitM attacks
depends strongly on the amount of time the attacker has before
the client gives up on the handshake. Clients that have long
handshake timeouts (e.g. curl and git) or are vulnerable to a
”timeout extension” attack (e.g. Firefox) put their users at risk.
A systematic review of different client’s timeouts conﬁguration
and their resilience to ”timeout extension” attacks is required.
Keyless TLS Implementations. Many (often private) TLS
implementations segregate private key operations from the
protocol implementation by having a keyless server responding
to signature and decryption requests from keyless clients.
PKCS #1 v1.5 veriﬁcation is not always done from the keyless
server and decrypted ciphertexts of variable-length passed to
the keyless clients can be passively observed from a privileged
network position. A review of available implementations and
standards (such as LURK [49]) is needed.
ACKNOWLEDGMENTS
We would like to thank Orr Dunkelman for his insights on
the parallelization of the attack using LLL; Kenny Paterson
for the insightful comments on the paper and on the Bleichen-
bacher attack; and the anonymous reviewers for their helpful
and constructive comments.
This research was supported in part by Intel Corporation
and the Robert Bosch foundation.
Analyzing the Parallel Attack.
As the Bleichenbacher
attack has a much higher query complexity than the Manger
attack, we will require a large number of servers to attack.
However, if we have k servers, running k attacks in parallel
is very inefﬁcient, due to the high cost of the ﬁrst blinding
phase. Instead we use the fact that each adaptive step of the
attack includes many queries that can be done in parallel. We
start by using all servers for multiple parallel queries until
we ﬁnd a small number of blinded values (e.g. 5 as in the
Manger attack). We then split the k servers evenly between
the blinded values to create multiple attacks. For each blinded
value, multiple servers will be used to run the parallel queries
required for each adaptive step.
VIII. DISCUSSION AND CONCLUSIONS
In this work we have answered negatively the question
”Are modern implementations of PKCS #1 v1.5 secure against
padding oracle attacks?”. The systemic re-discovery of Ble-
ichenbacher’s attack on RSA PKCS #1 v1.5 encryption over
the last 20 years has shown that the mitigations requirements
are unrealistic towards developers. Among the nine popular
implementations we surveyed, only two successfuly survived
our analysis. The insistence that protocols preserve this broken
padding standard still have consequences today, reaching even
the latest version of TLS 1.3 released in August 2018.
A. Recommendations for Mitigation
As we have seen, implementing a completely secure and
side channel free PKCS #1 v1.5-based RSA key exchange for
TLS is not easy. We propose several approaches to reduce
implementations’ vulnerability to our attacks.
Deprecation of RSA Key Exchange.
The safest counter-
measure is to deprecated the RSA key exchange and switch
to (Elliptic Curve) Difﬁe-Hellman key exchanges. This might
be hard due to backward compatibility issues.
Certiﬁcate Separation.
If RSA key exchange support
is required, it should be done with a dedicated public key
that does not allow signing. Similarly, to prevent downgrade
attacks, support for multiple TLS versions should not reuse
keys across versions. If multiple TLS servers are used, each
server should use a different public key if possible to prevent
parallelized attacks.
Constant-Time Code and Safe API.
The decryption
code should be constant-time, with no branching or memory
accesses depending on the plaintext (e.g., as achieved in the
BoringSSL and BearSSL code). A common problem across
multiple implementations is that the expected plaintext size is
not provided to the decryption function. Passing the expected
plaintext size is safer because it facilitates constant-time
implementations. Furthermore, we observe that side-channel
leakage from code that uses the expected plaintext size results
in weaker padding oracles that greatly increase the amount of
time required for an attack.
Using Large RSA Keys.
threshold for
decryption using Bleichenbacher and Manger type attacks is
The minimal
(cid:21)(cid:21)(cid:24)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:53:49 UTC from IEEE Xplore.  Restrictions apply. 
REFERENCES
[1] “The ICSI Notary,” http://notary.icsi.berkeley.edu/#connection-cipher-
[2] O. Acıic¸mez, “Yet another microarchitectural attack: Exploiting I-
details.
Cache,” in CSAW, 2007.
[3] O. Acıic¸mez, S. Gueron, and J. Seifert, “New branch prediction vulner-
abilities in OpenSSL and necessary software countermeasures,” in IMA
Int. Conf., 2007.
[4] D. Adrian, K. Bhargavan, Z. Durumeric, P. Gaudry, M. Green, J. A.
Halderman, N. Heninger, D. Springall, E. Thom´e, L. Valenta, B. Van-
derSloot, E. Wustrow, S. Z. B´eguelin, and P. Zimmermann, “Imperfect
forward secrecy: How Difﬁe-Hellman fails in practice,” in CCS, 2015.
[5] N. J. AlFardan and K. G. Paterson, “Lucky thirteen: Breaking the TLS
and DTLS record protocols,” in IEEE SP, 2013, pp. 526–540.
[6] T. Allan, B. B. Brumley, K. E. Falkner, J. van de Pol, and Y. Yarom,
“Amplifying side channels through performance degradation,” in AC-
SAC, 2016.
[7] R. Bardou, R. Focardi, Y. Kawamoto, L. Simionato, G. Steel, and
J. Tsay, “Efﬁcient padding oracle attacks on cryptographic hardware,”
in CRYPTO, 2012.
[8] M. Ben-Or, B. Chor, and A. Shamir, “On the cryptographic security of
single RSA bits,” in STOC, 1983.
[9] N. Benger, J. van de Pol, N. P. Smart, and Y. Yarom, “”Ooh aah... just
a little bit” : A small amount of side channel can go a long way,” in
CHES, 2014.
[10] D. J. Bernstein, “Cache-timing attacks on AES,” 2005.
[11] D. Bleichenbacher, “Chosen ciphertext attacks against protocols based
on the RSA encryption standard PKCS #1,” in CRYPTO, 1998.
[12] H. B¨ock, J. Somorovsky, and C. Young, “Return of Bleichenbacher’s
oracle threat (ROBOT),” in USENIX Sec, 2018.
[13] D. Boneh and R. Venkatesan, “Hardness of computing the most sig-
niﬁcant bits of secret keys in Difﬁe-Hellman and related schemes,” in
CRYPTO, 1996.
[14] F. Brasser, U. M¨uller, A. Dmitrienko, K. Kostiainen, S. Capkun, and
A. Sadeghi, “Software grand exposure: SGX cache attacks are practical,”
in WOOT, 2017.
[15] B. B. Brumley and N. Tuveri, “Remote timing attacks are still practical,”
in ESORICS, 2011.
[16] J. V. Bulck, F. Piessens, and R. Strackx, “SGX-Step: A practical attack
framework for precise enclave execution control,” in SysTEX@SOSP,
2017.
[17] ——, “Nemesis: Studying microarchitectural timing leaks in rudimen-
tary CPU interrupt logic,” in CCS, 2018.
[18] S. Checkoway, J. Maskiewicz, C. Garman, J. Fried, S. Cohney, M. Green,
N. Heninger, R.-P. Weinmann, E. Rescorla, and H. Shacham, “A sys-
tematic analysis of the Juniper Dual EC incident,” in CCS, 2016.
[19] T. Dierks and C. Allen, “The TLS Protocol Version 1.0,” RFC 2246,