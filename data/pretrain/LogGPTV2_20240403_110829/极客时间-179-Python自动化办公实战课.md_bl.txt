# 批量改名的代码      ... ...    rename("/Users/user1/Desktop/pic", ".jpg")这段代码实现的功能和没有重构之前完全相同，都是对指定目录的指定扩展名文件进行批量重命名。但是在代码结构上，要比直接在文件实现的代码逻辑更清晰，可以看到，改名功能被放在函数定义中，执行的时候就可以直接调用rename() 函数。将改名功能封装为函数的好处就是，代码更工整了，新的功能也可以继续采用函数的形式添加到当前代码中。比起把所有代码按执行顺序都写在一个文件中，这样的格式会让你更容易区分开代码中的每一个功能。明确执行位置把批量改名的功能封装为函数之后，对程序的执行顺序也会带来一些变化。我把前后变化给你做个对比：1.  封装函数之前，程序的执行顺序是导入库之后依次执行。        2.  封装为函数之后，执行顺序就变为导入库之后，就开始执行 rename()    函数的调用。        当这个脚本再陆续添加新的函数的话，那么找到哪一行是脚本第一个执行的命令，就非常麻烦了。因此在Python 中有一个参考 C语言设置代码入口的方法，让你能快速定位代码是从哪一行开始执行的。这个方法就是通过对内置变量"**name**"的值进行判断，判断它是不是和字符串"**main**" 相等。在 Python中，执行代码的方式有两种。1.       一种是单独运行，也就是用 Python    加脚本的名称方式运行。        2.       另一种方式是把.py    结尾的脚本文件作为自定义的模块使用"import"关键字导入，导入后通过"模块.    函数 ()"的格式运行。        如果一个脚本文件独立运行，那么它的内置变量"**name**"的值就是"**main**"，通过"if **name** == \"**main**\"" 的判断，结果必然为True，则该判断逻辑下的代码块就会执行。如果作为模块导入，那么"**name**"的值就是False，则不被执行。我们可以把函数的调用全部放入 "if**name** == \"**main**\""语句块中，这样就可以指定这条 if语句作为代码单独运行的入口，既方便你快速找到入口对程序进行修改，又方便你把它作为其他程序的模块进行导入。我把实现对"**name**"变量判断的脚本写在下方，你可以对照代码学习。    def rename():       ... ...    def func1():       ... ...    def func2():       ... ...    def func3():       ... ...    
# func1() 
# 在__name__之外执行，不推荐    if __name__ == "__main__":        func3()        rename("/Users/edz/Desktop/pic", ".jpg")        func1()        func2()在代码中，我定义了 4 个函数，对于四个函数的调用，都放在了 "if**name** == \"**main**\""语句块中。在使用这种方式设置程序入口时，有两点需要你特别注意。一方面，这种设置方法是人为指定程序入口，因此你需要把代码中所有函数调用都放在if 语句块下，这样才能实现作为入口的功能。虽然放在 if语句块之外也可以运行，但函数调用写在 if语句块之外，就很容易给代码阅读带来障碍。另一方面，使用"**name**"作为入口的判断变量，只能在单独运行的时候才为\"**main**\"，如果使用 Python交互方式执行，就无法对"**name**" 变量进行判断。我们通过指定代码的入口，让程序的逻辑更加清晰。那么接下来就是为这段代码添加命令行参数，在不修改代码的前提下，通过命令行参数来设置批量改名的目录和扩展名。命令行参数处理使用命令行参数的优点，就是在调用脚本的时候一并传入要操作的对象，这会比修改配置文件和变量更直接。那么在原有代码基础上，我们还需要增加两个参数，也就是要操作的目录和扩展名，并使用argparse库实现对这两个参数的处理。参数处理是一个比较笼统的概念，它包括参数的接收、参数数量的判断和参数的解析三个部分。"argparse"库是命令行解析模块，它负责在脚本运行时，接收和处理脚本执行时的参数。首先是**参数的接收**，在本讲之前，我们执行 Python脚本的方式是：    python3 脚本名称.py在脚本中使用"argparse"库后，脚本能够支持在该命令后面增加参数，并在脚本内获取参数的内容。哪些参数能够被脚本处理，需要使用argparse 库的 add_argument()函数指定。 接下来是**参数的判断**，add_argument()函数可以接收两种参数格式，分别是"-"和"\--"，后面再跟着英文。按照惯例，一个"-"一般后面会使用单个英文字母，两个"\--"后面是完整名称。以对目录改名的参数为例，我需要接收"-p"或"\--path"两种形式的参数指定的方法是：    add_argument("-p", "--path", required=True, help="path to rename")同时，我还为"\--path"参数所在的 add_argument()增加了两个额外的参数，一个是要求用户执行程序，必须输入"-p"或"\--path"，如果执行不指定会报错的required 参数。另一个"-p"或"\--path"参数含义的帮助信息"help"参数。增加参数处理后，如果你没有输入完整参数，argparse库会自报错，并提示你如何正确使用该脚本的参数。你也可以直接使用"-h"得到执行帮助。我把参数输入不完整和通过 -h获取帮助的执行结果，贴在下面供你学习。    SHELL$ python3 rename_v2.py -p /path/to/rename/files -e    usage: rename_v2.py [-h] -p PATH -e EXT    rename_v2.py: error: argument -e/--ext: expected one argument    SHELL$ python3 rename_v2.py -h    usage: rename_v2.py [-h] -p PATH -e EXT    optional arguments:      -h, --help            show this help message and exit      -p PATH, --path PATH  path to rename      -e EXT, --ext EXT     files name extension, eg: jpg最后是**参数的解析**，它是在参数数量正确的前提下自动完成的。完成解析后，会以"\--path"参数后的英文字面"path"作为属性名称，以"\--path"后面的参数，作为属性值。比如我在取得用户参数后，就可以使用"args.path"来得到命令行"-p"参数后面参数的值，以及使用"args.ext"得到"-e"参数后面参数的值。此外，我还把这两个属性作为批量改名函数rename()函数的参数，这样就可以把命令行参数作为重命名函数的参数使用了。获取命令行参数的核心代码我也为你整理了出来，放在下方供你参考：    import os    import argparse    def rename(file_path, old_ext):      """批量改名函数"""      ... ...    def args_opt():      """获取命令行参数函数"""              #定义参数对象        parser = argparse.ArgumentParser()                
# 增加参数选项、是否必须、帮助信息        parser.add_argument("-p", "--path", required=True, help="path to rename")        parser.add_argument("-e", "--ext", required=True, help="files name extension, eg: jpg")                