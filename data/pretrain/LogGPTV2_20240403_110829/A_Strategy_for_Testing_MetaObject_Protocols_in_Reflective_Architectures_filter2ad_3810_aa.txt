title:A Strategy for Testing MetaObject Protocols in Reflective Architectures
author:Juan-Carlos Ruiz-Garcia and
Pascale Th&apos;evenod-Fosse and
Jean-Charles Fabre
A Strategy for Testing MetaObject Protocols in Reflective Architectures 
Juan Carlos Ruiz, Pascale Thevenod-Fosse and Jean-Charles Fabre 
LAAS- CNRS 
7, AV. du Colonel Roche - 31077 Toulouse Cedex 4 (France) 
{ruiz, thevenod, fabre]@laas.fv 
Abstract 
As has been shown in previous  work, the separation of 
concerns  provided  by  reflective  architectures  is of  high 
interest  for  the  development  of  dependable  systems. 
Beyond  this  initial  interest,  the  use  of  this  technology 
remains questionable due to the lack of  work reporting on 
validation  aspects.  This  paper  defines  an  incremental 
strategy  for  testing  the  cornerstone  of  the  reflective 
architectures 
that  we  consider,  i.e.,  the  MetaObject 
Protocol  (MOP). The approach  is aimed  at  reducing  the 
testing  effort  by  promoting  a  gradual  increment  of  the 
observability  and  controllability  of  the  MOP  under  test. 
This  strategy  enables  reflective  mechanisms  that  have 
already  been  tested  to  be  reused  for  verifiing 
the 
remaining  ones. A different testing level is associated  with 
each  reflective  mechanism defined  in the MOP.  For each 
testing  level,  we  characterize  the  test  objectives  and  the 
required  test environment. The feasibility of the approach 
is  exemplified  on  a  real  MOP 
implemented  using 
O p e d +  + and  extracted from the  FRIENDS architecture 
devoted  to  the  implementation  of  CORBA  dependable 
systems.  First test experiments were very useful since they 
revealed some implementation errors. 
1.  Introduction 
Dependable  systems  need 
to  meet  non-functional 
requirements that can change from one instance of the system 
to another, and also during the system operational life. Indeed, 
most  dependable systems have a  long lifetime and are  thus 
subject to a great number of evolutions on their non-functional 
and  functional  requirements.  This  situation  motivates  the 
emergence of design techniques enabling dynamic changes to 
be applied into the system. 
Reflection [ 11 is an attractive design concept to tackle this 
issue. The reflective approach has been successfully used in a 
large  range  of  application  domains 
like  programming 
This  work  is  supported  in  part  by  France-Telecom  (contract 
ST,CNET/DTUASR/97049/DT)  and the European Community (project 
IST-1999-11585: DSoS - Dependable Systems of Systems). 
0-7695-1101-5/01 $10.00 0 2001 IEEE 
327 
languages  [2],  operating  systems  [3],  and  more  recently 
middleware [4].  The clear separation of concerns provided by 
this  approach  has  shown  to  be  of  great  interest  for  the 
development of dependable systems [5][6]. In  these systems, 
reflection is used to separate the functional mechanisms of the 
system  from 
the  dependability  mechanisms,  which  are 
considered as non-functional mechanisms. The composition 
those  functional  and  non-functional  mechanisms  is 
of 
govemed by  a set of rules, which are often specified in terms 
of a MetaObject Protocol (MOP) [7]. This protocol specifies 
the reflective capabilities of the system architecture. The use 
of  MOP-based 
the 
development of dependable systems and provides the required 
facilities  for  handling 
the  software 
architecture and its basic components. 
reflective  architectures  simplifies 
the  evolution  of 
Beyond  this  initial  interest,  the  use  of  reflection  in 
dependable systems remains questionable. To the best of  our 
knowledge, little work has been carried out on the verification 
of MOP-based reflective architectures. Solutions to this issue 
are,  however,  essential  for  dependable  systems.  Previous 
research work reports on  the definition of formal models for 
verifying  high-level  properties  in  reflective  architectures 
[8][9]. These models enable the reflective mechanisms of the 
MOP to be  analyzed in  terms of  consistency, completeness, 
deadlocks  and  refinement  checks.  However,  the  level  of 
description used in  the models is too generic to be helpful in 
finding  problems  associated  with  a  particular  MOP 
implementation.  Testing,  which  is  a  dynamic  verification 
technique that  consists  in  exercising the  implementation by 
supplying it  with  test case  input values, is  thus an essential 
complementary verification technique. 
the  corner  stone  of  such 
The test strategy presented in the paper is part of a global 
approach  for  the  verification  of  MOP-based  dependable 
reflective architectures. As  a  first  step  along  the  road,  we 
concentrate  on 
reflective 
architectures, i.e., the MOP. The strategy was defined with the 
aim  of  being generic enough  to be  used  for different MOP- 
based  architectures, and  thus  is  independent of  a  particular 
MOP implementation. The issues to be solved are numerous 
since, from  the  tester’s viewpoint, a MOP gathers the  well 
known  problems  related  to  both  protocol  testing  (see  e.g., 
[IO])  and  object-oriented  testing  (see  e.g.,  [I 1][12]).  The 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:57:26 UTC from IEEE Xplore.  Restrictions apply. 
to 
proposed  strategy  provides  general  solutions 
fundamental problems: 
1. What order should the reflective mechanisms of  the MOP 
be tested in? The goal is to define successive testing levels 
that  fit  with  an  incremental  verification  of  the  protocol 
mechanisms,  facilitating the reuse of  the mechanisms  that 
have already been tested for verifying the remaining ones. 
four 
2. Which  test  objectives  should  be  associated  with  the 
successive testing levels? The objectives must focus on the 
verification of  the properties expected  from  the  reflective 
mechanism under test at each testing level. 
3.Which  conformance  checks  should  be  used  in  order  to 
decide whether or not a MOP passes the tests, i.e., whether 
it produces correct results for the test case input values? 
4. Given the test objectives and the conformance checks to be 
performed,  how  to  design  the  test environments  required 
for  conducting  the  test  experiments?  In  particular,  these 
environments must offer solutions to the observability and 
controllability problems generated by object encapsulation. 
Other testing issues - e.g., the definition of  test criteria to 
guide the selection of  test case input values according to the 
test objectives - are out of the scope of this paper. 
The  next  section  provides  the  background  on  reflection 
required  for understanding the rest of  the paper. It describes 
the  reflective  mechanisms  used  in  metaobject  protocols  to 
enable  fault-tolerance  mechanisms  to  be  implemented  and 
applied  on  the  system  functional  mechanisms.  Section  3 
presents the test strategy that may be used for any MOP of the 
family  introduced  in  Section  2.  Then,  in  Section  4,  the 
feasibility  of  the  strategy  is  exemplified  on  a  real  MOP 
extracted  from  the  y-xIE!i$D.s architecture  [13],  which  is  a 
reflective  architecture  devoted  to  the  implementation  of 
COMA-based dependable systems. First test experiments are 
reported. They  were  usefully conducted since  they  revealed 
errors.  Section  5  addresses  the  relation  of  this  work  to 
previous one, and Section 6 presents conclusions. 
2.  Background on Reflection 
“Computational  reflection  is  the  activity performed  by  a 
system when doing  computation about (and by  that possibly 
affecting)  its  own  computation”  [I].  Reflection  enables  a 
system  to  be  structured  in  two  layers: a  lower  layer, called 
base-level,  executing  the  application  components,  and  an 
upper layer, called metu-level, running components devoted to 
the implementation of non-functional requirements. 
The input for the meta-level is an image of  the structural 
image 
and  behavioral  features  of 
(sometimes  called  meta-model) is  causally  connected  to the 
base-level, which means that any change in one of them leads 
to  a corresponding  effect  upon  the  other.  Ideally,  the  meta- 
model deals with two important base-level features: 
the  base-level.  This 
The  behavior  of 
the  base-level  components,  which 
corresponds to a finite state machine indicating the possible 
states  and  transitions  goveming  the  base-level  execution 
(notion of execution model); 
The structure of the base-level components that depends on 
the  base-level  components  considered,  e.g.  an  object,  a 
kernel or a middleware (notion of structural model). 
The above  issues are differently addressed  depending on 
the reflective component considered. Let us take the example 
of  the  structural  view  defined  for  an  application  object.  In 
Java  [2], for  instance,  this  view  is  a  stream  of  information 
items generated and  interpreted by  the Java  virtual machine. 
A more elaborated structural view of an object can be defined, 
as in  [ 141, in terms of the object attributes and their types, the 
object methods and their respective signatures, the inheritance 
links, etc. 
The  meta-level  may  be  considered  as  a  customizable 
interpreter of  the  meta-model.  The interest of  this approach, 
from  a  dependability  viewpoint,  is  that  any  standard  action 
defined  by  the  meta-level  can  be  adapted  towards  non- 
functional objectives. 
2.1. Reflective Architectures and MOPS 
From  a  design  viewpoint  (see  Figure  l), four  different 
processes are defined to observe and control at the meta-level 
the features of the system’s base-level. The reijication process 
corresponds to the process of exhibiting to the meta-level the 
occurrence  of  base-level events,  which trigger  transitions in 
the  execution  model.  The  introspection  process  provides 
means  to  the  meta-level  for  retrieving  base-level  structural 
information.  Finally,  the  infercession process  enables  the 
meta-level  to  act  on  the  base-level  behavior  (behavioral 
intercession) or structure (structural intercession). 
(non-finctional mechanisms) 
observation, interpretation and control 
MetaObject Protocol (MOP) 
(reflective  mechanisms) 
Behavioral intercession 
Stmctural intercession 
(behavioral control) 
(structural control) 
(behavioral observdtion) 
Reifiation 
lntros  rtion 
(~tnrch‘ra~bservaIron) 
Application 
behavior and structure 
Figure 1. A MOP-based reflective architecture 
In  most  reflective  systems,  the  interactions  between  the 
base-  and  the  meta-level  are  implemented  by  a  so-called 
Metaobject Protocol (MOP). Metaobject protocols correspond 
to  the  rules  that  govem  the  use  of  the  system  reflective 
mechanisms. Their goal is to handle the interactions between 
328 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:57:26 UTC from IEEE Xplore.  Restrictions apply. 
base-  and meta-level entities respectively called objects and 
metaobjects. The definition of  a  MOP is  thus  based  on  the 
level of observability and controllability required at the meta- 
level  for  interpreting  and  acting  on  the  behavior  and  the 
structure of the application objects. 
the  meta-level  (redirecting  messages  by 
Various MOPs have been defined and used, in  particular, 
for  the  implementation of  fault-tolerant mechanisms  at  the 
meta-level.  MAUD  [15]  and  GARF  [16]  architectures 
propose simple reflective mechanisms for intercepting events 
at 
renaming 
destinations in  the first case, and making a tricky use  of  the 
Smalltalk exception handling mechanism in the second case). 
The reflective capabilities defined in  these MOPs are limited 
to  the  reification  and  behavioral  intercession  mechanisms 
described above. The  F!IE5i@S architecture [6]  relies  on  a 
more  sophisticated MOP enabling both  base-level behavior 
and  structure to  be  observed  by  (and  controlled from)  the 
meta-level. In  these architectures, metaobjects are developed 
independently and  selected  according  to  the  current  set  of 
system requirements. When  these  requirements change,  the 
reflective  mechanisms  of  the  MOP  enable  non-functional 
mechanisms  to  be  changed  accordingly.  From  a  non- 
functional  viewpoint, 
the 
specialization  or  the  replacement  of  the  metaobjects.  The 
features of  the  MOP  enable  objects  and  metaobjects to  be 
linked  together  either  statically  or  dynamically.  Despite 
changes, the observation and control features provided by  the 
MOP remain  always  the  same. This  is  why  the  MOP is  a 
crucial element of such reflective architectures. 
this 
customization  entails 
2.2.  MOP Description 
This  section  provides  a  generic  description  of  a  MOP 
adapted to the implementation of fault-tolerant mechanisms at 
the  meta-level. This MOP provides a meta-model expressed 
in terms of method invocations and object states. We do not 
consider  for  the  moment  how  the  protocol  mechanisms 
themselves are implemented, these considerations concern the 
case study section. We provide here a high-level view  of the 
protocol that is used to discuss the main testing issues related 
to the reflective mechanisms defined by a MOP. 
As  showed in  Figure 2, objects communicate by  method 
invocations, which  are service requests sent by client objects 
to  server  objects.  Each  server  has  at  least  one  Service 
interface. Every service request received by  the server object 
(step I) is intercepted (using the reification mechanisms of the 
MOP)  by 
its  metaobject.  This  interception  enables  the 
metaobject to  transparently insert pre- and  post-computation 
to  the  invoked  method.  The  metaobject  can,  for  instance, 
check specific access rights of the client and authorize or deny 
in consequence the execution of the concemed method. Using 