# 实战Web缓存中毒

## 摘要
长期以来，Web缓存投毒一直被视为一种理论上的威胁，尽管开发人员被警告需要修补此类漏洞，但实际上很少有人能够成功利用它。本文将展示如何通过使用复杂的网络功能，将缓存转变为漏洞传送系统，从而对请求访问有误主页的任何用户发起攻击。我们将探讨这些技术如何从简单的单一请求攻击发展到复杂的漏洞链，包括劫持JavaScript、跨越缓存层、颠覆社交媒体及误导云服务。此外，本文还会讨论防御策略，并发布一个推动该研究的Burp Suite社区扩展工具。文章还提供了可打印的PDF版本以及在Black Hat USA会议上演讲的相关资料。

## 核心概念

### 缓存基础
理解缓存投毒的关键在于了解缓存的基本工作原理。Web缓存位于用户与应用程序服务器之间，用于存储并提供某些资源的副本，旨在减少延迟和减轻服务器负载。公司可能使用Varnish等软件或依赖Cloudflare这样的CDN来部署缓存；一些框架如Drupal也内置了缓存机制。尽管存在客户端浏览器缓存和DNS缓存等其他类型，但它们不是本研究的重点。

### 缓存键
缓存必须确定是否已有请求资源的副本可用。由于HTTP请求中包含大量无关信息，直接比较不可行。因此，缓存采用“缓存键”来唯一标识资源。例如，在两个仅Cookie值不同的请求间，如果缓存键未包含Cookie，则认为两者等效，可能导致错误内容被传递给用户。理论上，“Vary”响应头可用于指定哪些头部应作为缓存键的一部分，但在实践中，许多CDN忽略了这一点，导致潜在的安全问题。

### 缓存投毒
Web缓存投毒的目标是发送会导致有害响应的请求，该响应会被保存在缓存中并向其他用户分发。除了基于未加密输入的方法外，还有HTTP响应拆分和请求走私等手段可以实现类似目的。请注意，Web缓存投毒不同于Web缓存欺骗，二者不应混淆。

### 研究方法
我们采用以下步骤寻找并利用缓存投毒漏洞：
1. 识别未加密输入。
2. 评估其潜在危害。
3. 尝试将其存储于缓存中。
4. 如果失败，则需进一步分析缓存行为以找到合适的页面。
5. 使用参数破坏器确保每次请求具有独特性，避免意外影响其他用户。

## 案例研究
接下来，我们将通过几个实际案例来说明上述方法的应用。所有示例均针对允许安全研究且已修复相关漏洞的网站。

### 基础投毒
即使对于知名站点，缓存投毒也可能相对容易实施。以Red Hat为例，`Param Miner`很快发现了X-Forwarded-Host头部的一个未加密输入点。通过构造恶意脚本注入Payload，我们成功使特定URL受到污染，尽管返回的响应头中包含了"Cache-Control: no-cache"字段，但仍被Akamai CDN缓存。

### 选择性投毒
某些情况下，攻击者可通过控制User-Agent等特定头部实现更精确的目标定位。例如，在某匿名网站上，尽管存在Vary头部指示User-Agent参与缓存键生成过程，但我们仍能通过对常见浏览器版本进行枚举的方式扩大受影响范围。

### DOM投毒
并非所有场景都适合直接执行XSS攻击。在另一个例子中，我们控制了一个名为'data-site-root'的属性，虽然无法直接触发XSS，但通过监控JavaScript生成的请求模式，最终发现了一种间接方式来操纵DOM结构。