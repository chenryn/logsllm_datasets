### 4.5.4 Keep-Alive首部

Keep-Alive首部是完全可选的，但只有在提供Connection: Keep-Alive时才能使用它。以下是一个Keep-Alive响应首部的例子，该例子说明服务器最多还会为另外5个事务保持连接的打开状态，或者将打开状态保持到连接空闲了2分钟之后。

**示例：**
```
Connection: Keep-Alive
Keep-Alive: max=5, timeout=120
```

### 4.5.5 Keep-Alive连接的限制和规则

在使用keep-alive连接时，有一些限制和需要注意的地方：

- **HTTP/1.0中的默认设置**：在HTTP/1.0中，keep-alive并不是默认使用的。客户端必须发送一个Connection: Keep-Alive请求首部来激活keep-alive连接。
- **持续发送Connection: Keep-Alive首部**：为了维持持久连接，客户端必须随所有希望保持持久连接的报文一起发送Connection: Keep-Alive首部。如果客户端没有发送此首部，服务器会在处理完当前请求后关闭连接。
- **检测连接状态**：通过检查响应中是否包含Connection: Keep-Alive响应首部，客户端可以判断服务器是否会关闭连接。
- **实体主体长度**：只有当无需检测到连接的关闭即可确定报文实体主体部分长度的情况下，才能将连接保持在打开状态。这意味着实体的主体部分必须有正确的Content-Length，或多部件媒体类型，或使用分块传输编码进行编码。否则，可能会导致无法准确检测出一条报文的结束和另一条报文的开始。
- **代理和网关的行为**：代理和网关必须执行Connection首部的规则。在将报文转发出去或将其高速缓存之前，它们必须删除在Connection首部中命名的所有首部字段以及Connection首部自身。
- **与不支持Connection首部的代理建立连接的风险**：严格来说，不应与无法确定是否支持Connection首部的代理服务器建立keep-alive连接，以防止哑代理问题。但在实际应用中，这一点并不总是能够做到。
- **忽略来自HTTP/1.0设备的Connection首部**：从技术上讲，应该忽略所有来自HTTP/1.0设备的Connection首部（包括Connection: Keep-Alive），因为它们可能是由较老的代理服务器误转发的。然而，在实践中，有些客户端和服务器会违反这一规则，尽管存在在老代理上挂起的风险。
- **重试请求**：除非重复发送请求会产生其他副作用，否则如果在客户端收到完整响应之前连接就关闭了，客户端应准备好重试请求。

### 4.5.6 Keep-Alive和哑代理

让我们仔细看看keep-alive和哑代理之间的一些微妙问题。Web客户端的Connection: Keep-Alive首部应该只对离开客户端的TCP链路产生影响，因此被称为“连接”首部。如果客户端正在与一台Web服务器对话，客户端可以发送一个Connection: Keep-Alive首部来告知服务器它希望保持连接的活跃状态。如果服务器支持keep-alive，就会回送一个Connection: Keep-Alive首部，否则就不回送。

#### 1. Connection首部和盲中继

问题出在代理上——特别是那些不理解Connection首部且不知道在沿转发链路将其发送出去之前应删除该首部的代理。许多老旧或简单的代理都是盲中继，它们只是将字节从一个连接转发到另一个连接中去，不对Connection首部进行特殊处理。

假设有一个Web客户端正通过一个作为盲中继使用的哑代理与Web服务器进行对话。图4-15展示了这种情况。

- **图4-15a**：Web客户端向代理发送了一条包含Connection: Keep-Alive首部的报文，请求建立一条keep-alive连接。客户端等待响应，以确定对方是否认可其对keep-alive信道的请求。
- **图4-15b**：哑代理收到了这条HTTP请求，但并不理解Connection首部（只是将其作为一个扩展首部对待）。代理不知道keep-alive是什么意思，因此只是沿着转发链路将报文一字不漏地发送给服务器。但Connection首部是逐跳首部，只适用于单条传输链路，不应该沿传输链路向下传输。接下来，会发生一些糟糕的事情。
- **图4-15c**：经过中继的HTTP请求抵达了Web服务器。当Web服务器收到经过代理转发的Connection: Keep-Alive首部时，会误以为代理希望进行keep-alive对话。服务器同意进行keep-alive对话，并回送了一个Connection: Keep-ive响应首部。此时，Web服务器认为它在与代理进行keep-alive对话，而代理却对keep-alive一无所知。
- **图4-15d**：哑代理将Web服务器的响应报文回送给客户端，并将来自Web服务器的Connection: Keep-Alive首部一起传送过去。客户端看到这个首部，就会认为代理同意进行keep-alive对话。此时，客户端和服务器都认为它们在进行keep-alive对话，而与它们进行对话的代理却对keep-alive一无所知。
- **图4-15e**：由于代理对keep-alive一无所知，所以会将收到的所有数据都回送给客户端，然后等待源端服务器关闭连接。但源端服务器会认为代理已经显式地请求它将连接保持在打开状态了，所以不会去关闭连接。这样，代理就会挂在那里等待连接的关闭。
- **图4-15f**：客户端在收到回送的响应报文时，会立即转向下一条请求，在keep-alive连接上向代理发送另一条请求。而代理并不认为同一条连接上会有其他请求到来，请求被忽略，浏览器就在这里转圈，不会有任何进展了。
- **图4-15g**：这种错误的通信方式会使浏览器一直处于挂起状态，直到客户端或服务器将连接超时并关闭为止。

#### 2. 代理和逐跳首部

为避免此类代理通信问题的发生，现代的代理绝不能转发Connection首部和所有名字出现在Connection值中的首部。因此，如果一个代理收到了一个Connection: Keep-Alive首部，是不应该转发Connection首部或所有名为Keep-Alive的首部的。

此外，还有几个不能作为Connection首部值列出，也不能被代理转发或作为缓存响应使用的首部，包括Proxy-Authenticate、Proxy-Connection、Transfer-Encoding和Upgrade。更多信息，请参考4.3.1节。

### 4.5.7 插入Proxy-Connection

Netscape的浏览器及代理实现者们提出了一种变通做法，引入了一个名为Proxy-Connection的新首部，解决了客户端后面紧跟着一个盲中继所带来的问题。现代浏览器在显式配置了代理的情况下实现了Proxy-Connection，很多代理也能够理解它。

问题是哑代理盲目地转发Connection: Keep-Alive之类的逐跳首部惹出了麻烦。逐跳首部只与一条特定的连接有关，不能被转发。当下游服务器误将转发来的首部作为来自代理自身的请求解释，用它来控制自己的连接时，就会引发问题。

在网景的变通做法是，浏览器会向代理发送非标准的Proxy-Connection扩展首部，而不是官方支持的Connection首部。如果代理是盲中继，它会将无意义的Proxy-Connection首部转发给Web服务器，服务器会忽略此首部，不会带来任何问题。但如果代理是个聪明的代理（能够理解持久连接的握手动作），就用一个Connection首部取代无意义的Proxy-Connection首部，然后将其发送给服务器，以收到预期的效果。

图4-16a～图4-16d显示了盲中继如何向Web服务器转发Proxy-Connection首部而不带来任何问题，Web服务器忽略了这个首部，这样在客户端和代理，或者代理和服务器之间就不会建立起keep-alive连接了。图4-16e～图4-16h中那个聪明的代理知道Proxy-Connection首部是对keep-alive对话的请求，它会发送自己的Connection: Keep-Alive首部来建立keep-alive连接。

这种方案可以在客户端和服务器之间只有一个代理时解决问题。但如图4-17所示，如果在哑代理的任意一侧还有一个聪明的代理，这个问题就会再次出现。

而且，网络中出现“不可见”代理的情况现在变得很常见了，这些代理可以是防火墙、拦截缓存，或者是反向代理服务器的加速器。这些设备对浏览器是不可见的，所以浏览器不会向它们发送Proxy-Connection首部。透明的Web应用程序正确地实现持久连接是非常重要的。

### 4.5.8 HTTP/1.1持久连接

HTTP/1.1逐渐停止了对keep-alive连接的支持，用一种名为持久连接（persistent connection）的改进型设计取代了它。持久连接的目的与keep-alive连接相同，但工作机制更优。

与HTTP/1.0+的keep-alive连接不同，HTTP/1.1持久连接在默认情况下是激活的。除非特别指明，否则HTTP/1.1假定所有连接都是持久的。要在事务处理结束后关闭连接，HTTP/1.1应用程序必须向报文中显式地添加一个Connection: close首部。这是与以前的HTTP协议版本的重要区别，在以前的版本中，keep-alive连接要么是可选的，要么根本就不支持。

HTTP/1.1客户端假定在收到响应后，除非响应中包含了Connection: close首部，否则HTTP/1.1连接就仍维持在打开状态。但是，客户端和服务器仍然可以随时关闭空闲的连接。不发送Connection: close并不意味着服务器承诺永远将连接保持在打开状态。

### 4.5.9 持久连接的限制和规则

在持久连接的使用中有以下限制和需要澄清的问题：

- **发送Connection: close请求首部**：发送了Connection: close请求首部之后，客户端就无法在那条连接上发送更多的请求了。
- **关闭连接**：如果客户端不想在连接上发送其他请求了，就应该在最后一条请求中发送一个Connection: close请求首部。
- **报文长度**：只有当连接上所有的报文都有正确的、自定义报文长度时——也就是说，实体主体部分的长度都和相应的Content-Length一致，或者是用分块传输编码方式进行编码——连接才能持久保持。
- **代理管理**：HTTP/1.1的代理必须能够分别管理与客户端和服务器的持久连接——每个持久连接都只适用于一跳传输。
- **与HTTP/1.0客户端的兼容性**：由于较老的代理会转发Connection首部，HTTP/1.1的代理服务器不应该与HTTP/1.0客户端建立持久连接，除非它们了解客户端的处理能力。实际上，这一点是很难做到的，很多厂商都违背了这一原则。
- **异步关闭**：尽管服务器不应该试图在传输报文的过程中关闭连接，而且在关闭连接之前至少应该响应一条请求，但不管Connection首部取什么值，HTTP/1.1设备都可以在任意时刻关闭连接。
- **恢复机制**：HTTP/1.1应用程序必须能够从异步关闭中恢复出来。只要不存在可能会累积起来的副作用，客户端都应该重试这条请求。
- **重新发起请求**：除非重复发起请求会产生副作用，否则如果在客户端收到整条响应之前连接关闭了，客户端就必须要重新发起请求。
- **连接数量限制**：一个用户客户端对任何服务器或代理最多只能维护两条持久连接，以防服务器过载。代理可能需要更多到服务器的连接来支持并发用户的通信，所以，如果有N个用户试图访问服务器的话，代理最多要维持2N条到任意服务器或父代理的连接。

### 4.6 管道化连接

HTTP/1.1允许在持久连接上可选地使用请求管道。这是相对于keep-alive连接的又一性能优化。在响应到达之前，可以将多条请求放入队列。当第一条请求通过网络流向地球另一端的服务器时，第二条和第三条请求也可以开始发送了。在高时延网络条件下，这样做可以降低网络的环回时间，提高性能。

图4-18a-c显示了持久连接是怎样消除TCP连接时延，以及管道化请求（参见图4-18c）是如何消除传输时延的。