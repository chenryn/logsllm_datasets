语法为name [=value]。
Keep-Alive首部完全是可选的，但只有在提供Connection: Keep-Alive时才能
使用它。这里有个Keep-Alive响应首部的例子，这个例子说明服务器最多还会为
另外5个事务保持连接的打开状态，或者将打开状态保持到连接空闲了2分钟之后。
Connection: Keep-Alive
Keep-Alive: max=5, timeout=120
4.5.5 Keep-Alive连接的限制和规则
使用keep-alive连接时有一些限制和一些需要澄清的地方。
• 在 HTTP/1.0 中，keep-alive 并 不 是 默 认 使 用 的。 客 户 端 必 须 发 送 一 个
Connection: Keep-Alive请求首部来激活keep-alive连接。
• Connection: Keep-Alive首部必须随所有希望保持持久连接的报文一起发送。
如果客户端没有发送Connection: Keep-Alive首部，服务器就会在那条请求
之后关闭连接。 93
• 通过检测响应中是否包含Connection: Keep-Alive响应首部，客户端可以判
断服务器是否会在发出响应之后关闭连接。
• 只有在无需检测到连接的关闭即可确定报文实体主体部分长度的情况下，才能
将连接保持在打开状态——也就是说实体的主体部分必须有正确的Content-
Length，有多部件媒体类型，或者用分块传输编码的方式进行了编码。在一条
keep-alive信道中回送错误的Content-Length是很糟糕的事，这样的话，事务
处理的另一端就无法精确地检测出一条报文的结束和另一条报文的开始了。
• 代理和网关必须执行Connection首部的规则。代理或网关必须在将报文转发出
去或将其高速缓存之前，删除在Connection首部中命名的所有首部字段以及
Connection首部自身。
• 严格来说，不应该与无法确定是否支持Connection首部的代理服务器建立
keep-alive连接，以防止出现下面要介绍的哑代理问题。在实际应用中不是总能
做到这一点的。
• 从技术上来讲，应该忽略所有来自HTTP/1.0设备的Connection首部字段（包
括Connection: Keep-Alive），因为它们可能是由比较老的代理服务器误转发
的。但实际上，尽管可能会有在老代理上挂起的危险，有些客户端和服务器还是
会违反这条规则。
• 除非重复发送请求会产生其他一些副作用，否则如果在客户端收到完整的响应之
前连接就关闭了，客户端就一定要做好重试请求的准备。
连接管理 ｜ 99
4.5.6 Keep-Alive和哑代理
我们来仔细看看 keep-alive 和哑代理中一些比较微妙的问题。Web 客户端的
Connection: Keep-Alive首部应该只会对这条离开客户端的TCP链路产生影响。
这就是将其称作“连接”首部的原因。如果客户端正在与一台Web服务器对话，客
户端可以发送一个Connection: Keep-Alive首部来告知服务器它希望保持连接
的活跃状态。如果服务器支持keep-alive，就回送一个Connection: Keep-Alive
首部，否则就不回送。
1. Connection首部和盲中继
问题出在代理上——尤其是那些不理解Connection首部，而且不知道在沿着转
发链路将其发送出去之前，应该将该首部删除的代理。很多老的或简单的代理都
是盲中继（blind relay），它们只是将字节从一个连接转发到另一个连接中去，不对
Connection首部进行特殊的处理。
假设有一个Web客户端正通过一个作为盲中继使用的哑代理与Web服务器进行对
话。图4-15显示的就是这种情形。
（b）服务器认为对方请求
保持连接活跃，因此处理
完连接后不会将其关闭。
(a) Connection: Keep-Alive (b) Connection: Keep-Alive
(c) Connection:
(d) Connection: Keep-Alive哑代理 Keep-Alive
客户端 服务器
（c）代理会忽略连接上所有
下一条请求 新的请求，等待连接关闭。
（e）由于代理不会对其进
行处理，所以客户端在keep-alive
连接上发送的第二条请求会被挂起。
图4-15 keep-alive无法与不支持Connection首部的代理进行互操作
这幅图中发生的情况如下所示。
(1) 在图4-15a中，Web客户端向代理发送了一条报文，其中包含了Connection:
Keep-Alive首部，如果可能的话请求建立一条keep-alive连接。客户端等待响
94 应，以确定对方是否认可它对keep-alive信道的请求。
100 ｜ 第4章
(2) 哑代理收到了这条HTTP请求，但它并不理解Connection首部（只是将其作
为一个扩展首部对待）。代理不知道keep-alive是什么意思，因此只是沿着转发
链路将报文一字不漏地发送给服务器（图4-15b）。但Connection首部是个逐
跳首部，只适用于单条传输链路，不应该沿着传输链路向下传输。接下来，就要
发生一些很糟糕的事情了。
(3) 在图4-15b中，经过中继的HTTP请求抵达了Web服务器。当Web服务器收到
经过代理转发的Connection: Keep-Alive首部时，会误以为代理（对服务器
来说，这个代理看起来就和所有其他客户端一样）希望进行keep-alive对话！对
Web服务器来说这没什么问题——它同意进行keep-alive对话，并在图4-15c中
回送了一个Connection: Keep-Alive响应首部。所以，此时Web服务器认为
它在与代理进行keep-alive对话，会遵循keep-alive的规则。但代理却对keep-
alive一无所知。不妙。
(4) 在图4-15d中，哑代理将Web服务器的响应报文回送给客户端，并将来自Web
服务器的Connection: Keep-Alive首部一起传送过去。客户端看到这个首
部，就会认为代理同意进行keep-alive对话。所以，此时客户端和服务器都认为
它们在进行keep-alive对话，但与它们进行对话的代理却对keep-alive一无所知。
(5) 由于代理对keep-alive一无所知，所以会将收到的所有数据都回送给客户端，然
后等待源端服务器关闭连接。但源端服务器会认为代理已经显式地请求它将连接
保持在打开状态了，所以不会去关闭连接。这样，代理就会挂在那里等待连接的
关闭。
(6) 客户端在图4-15d中收到了回送的响应报文时，会立即转向下一条请求，在keep- 95
alive连接上向代理发送另一条请求（参见图4-15e）。而代理并不认为同一条连接
上会有其他请求到来，请求被忽略，浏览器就在这里转圈，不会有任何进展了。
(7) 这种错误的通信方式会使浏览器一直处于挂起状态，直到客户端或服务器将连接
超时，并将其关闭为止。17
2. 代理和逐跳首部
为避免此类代理通信问题的发生，现代的代理都绝不能转发Connection首部
和所有名字出现在Connection值中的首部。因此，如果一个代理收到了一个
Connection: Keep-Alive首部，是不应该转发Connection首部，或所有名为
Keep-Alive的首部的。
注17： 在很多类似的情形下，盲中继和转发的握手信息都会引发问题。
连接管理 ｜ 101
另外，还有几个不能作为Connection首部值列出，也不能被代理转发或作为
缓存响应使用的首部。其中包括 Proxy-Authenticate、Proxy-Connection、
Transfer-Encoding和Upgrade。更多信息，请参考4.3.1节。
4.5.7 插入Proxy-Connection
Netscape的浏览器及代理实现者们提出了一个对盲中继问题的变通做法，这种做法
并不要求所有的Web应用程序支持高版本的HTTP。这种变通做法引入了一个名为
Proxy-Connection的新首部，解决了在客户端后面紧跟着一个盲中继所带来的问
题——但并没有解决所有其他情况下存在的问题。在显式配置了代理的情况下，现
代浏览器都实现了Proxy-Connection，很多代理都能够理解它。
问题是哑代理盲目地转发Connection: Keep-Alive之类的逐跳首部惹出了麻烦。
逐跳首部只与一条特定的连接有关，不能被转发。当下游服务器误将转发来的首部
作为来自代理自身的请求解释，用它来控制自己的连接时，就会引发问题。
在网景的变通做法是，浏览器会向代理发送非标准的Proxy-Connection扩展首
部，而不是官方支持的著名的Connection首部。如果代理是盲中继，它会将无意
义的Proxy-Connection首部转发给Web服务器，服务器会忽略此首部，不会带
来任何问题。但如果代理是个聪明的代理（能够理解持久连接的握手动作），就用一
个Connection首部取代无意义的Proxy-Connection首部，然后将其发送给服
务器，以收到预期的效果。
图4-16a～图4-16d显示了盲中继是如何向Web服务器转发Proxy-Connection
96 首部，而不带来任何问题的，Web服务器忽略了这个首部，这样在客户端和代理，
或者代理和服务器之间就不会建立起keep-alive连接了。图4-16e～图4-16h中那个
聪明的代理知道Proxy-Connection首部是对keep-alive对话的请求，它会发送自
己的Connection: Keep-Alive首部来建立keep-alive连接。
在客户端和服务器之间只有一个代理时可以用这种方案来解决问题。但如图4-17所
示，如果在哑代理的任意一侧还有一个聪明的代理，这个问题就会再次露头了。
而且，网络中出现“不可见”代理的情况现在变得很常见了，这些代理可以是防火
墙、拦截缓存，或者是反向代理服务器的加速器。这些设备对浏览器是不可见的，
所以浏览器不会向它们发送Proxy-Connection首部。透明的Web应用程序正确
地实现持久连接是非常重要的。
102 ｜ 第4章
服务器不认识Proxy-Connection首部，将其忽略。没有建立keep-alive连接。
(a) Proxy-Connection: Keep-Alive (b) Proxy-Connection: Keep-Alive
哑代理
（d）没有Connection首部 （c）没有Connection首部
客户端 服务器
哑代理转发了Proxy-Connection首部，服务器将其忽略。
代理识别出了Proxy-Connection首部，同意与客户端进
行keep-alive对话，可能还会（可选地）决定与服务器
建立一条keep-alive连接。
(e) Proxy-Connection: Keep-Alive (f) Connection: Keep-Alive
聪明的代理
(h) Connection: Keep-Alive (g) Connection: Keep-Alive
客户端 服务器
聪明的代理理解了Proxy-Connection首部，并主动
向服务器发送了一个Connection: Keep-Alive首部。
图4-16 Proxy-Connection首部修正了单个盲中继带来的问题
(a) (b) (c)
Proxy-Connection: Keep-Alive Proxy-Connection: Keep-Alive Connection: Keep-Alive
哑代理 聪明的代理
(f) (e) (d)
Connection: Keep-Alive Connection: Keep-Alive Connection: Keep-Alive
客户端 服务器
哑代理无意识地向浏览器和聪明的代理广播Keep-Alive。
(g) (h) (i)
Proxy-Connection: Keep-Alive Connection: Keep-Alive Connection: Keep-Alive
聪明的代理 哑代理
（l） (k) (j)
Connection: Keep-Alive Connection: Keep-Alive Connection: Keep-Alive
客户端 服务器
哑代理无意识地向聪明的代理和服务器广播Keep-Alive。
图4-17 对有多层次代理的情况，Proxy-Connection仍然无法解决问题
连接管理 ｜ 103
4.5.8 HTTP/1.1持久连接
HTTP/1.1逐渐停止了对keep-alive连接的支持，用一种名为持久连接（persistent
connection）的改进型设计取代了它。持久连接的目的与keep-alive连接的目的相
97 同，但工作机制更优一些。
与 HTTP/1.0+ 的 keep-alive 连接不同，HTTP/1.1 持久连接在默认情况下是激活
的。除非特别指明，否则HTTP/1.1假定所有连接都是持久的。要在事务处理结束
之后将连接关闭，HTTP/1.1应用程序必须向报文中显式地添加一个Connection:
close首部。这是与以前的HTTP协议版本很重要的区别，在以前的版本中，keep-
alive连接要么是可选的，要么根本就不支持。
HTTP/1.1客户端假定在收到响应后，除非响应中包含了 Connection: close首
部，不然HTTP/1.1连接就仍维持在打开状态。但是，客户端和服务器仍然可以随
时关闭空闲的连接。不发送Connection: close并不意味着服务器承诺永远将连
接保持在打开状态。
4.5.9 持久连接的限制和规则
在持久连接的使用中有以下限制和需要澄清的问题。
• 发送了Connection: close请求首部之后，客户端就无法在那条连接上发送更
多的请求了。
• 如果客户端不想在连接上发送其他请求了，就应该在最后一条请求中发送一个
Connection: close请求首部。
• 只有当连接上所有的报文都有正确的、自定义报文长度时——也就是说，实体主
体部分的长度都和相应的Content-Length一致，或者是用分块传输编码方式
98 编码的——连接才能持久保持。
• HTTP/1.1的代理必须能够分别管理与客户端和服务器的持久连接——每个持久
连接都只适用于一跳传输。
• （由于较老的代理会转发Connection首部，所以）HTTP/1.1的代理服务器不应
该与HTTP/1.0客户端建立持久连接，除非它们了解客户端的处理能力。实际上，
这一点是很难做到的，很多厂商都违背了这一原则。
• 尽管服务器不应该试图在传输报文的过程中关闭连接，而且在关闭连接之前至少
应该响应一条请求，但不管Connection首部取了什么值，HTTP/1.1设备都可
以在任意时刻关闭连接。
104 ｜ 第4章
• HTTP/1.1应用程序必须能够从异步的关闭中恢复出来。只要不存在可能会累积
起来的副作用，客户端都应该重试这条请求。
• 除非重复发起请求会产生副作用，否则如果在客户端收到整条响应之前连接关闭
了，客户端就必须要重新发起请求。
• 一个用户客户端对任何服务器或代理最多只能维护两条持久连接，以防服务器过
载。代理可能需要更多到服务器的连接来支持并发用户的通信，所以，如果有
N个用户试图访问服务器的话，代理最多要维持2N条到任意服务器或父代理的
连接。
4.6 管道化连接
HTTP/1.1允许在持久连接上可选地使用请求管道。这是相对于keep-alive连接的又
一性能优化。在响应到达之前，可以将多条请求放入队列。当第一条请求通过网络
流向地球另一端的服务器时，第二条和第三条请求也可以开始发送了。在高时延网
络条件下，这样做可以降低网络的环回时间，提高性能。
图4-18a-c显示了持久连接是怎样消除TCP连接时延，以及管道化请求（参见图
4-18c）是如何消除传输时延的。