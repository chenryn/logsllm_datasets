  * `trim L/S`(裁去)：预测试阶段，尝试将输入用例裁剪为最短的形式，要求修饰前的用例将仍然产生相同的执行路径。裁去长度(`L`)和间隔步长(`S`)通常根据文件大小来确定。
  * `bitflip L/S`(位翻转)：确定性变异。在任何给定的时间对输入样例以`S`位为步长进行遍历，每次遍历循环对`L`位字节执行位翻转操作(即，每隔`S`位，翻转`L`位)。 当前的`L/S`有效取值为:`1/1`、`2/1`、`4/1`、`8/8`、`16/8`、`32/8`。
  * `arith L/8`(算术变异)：确定性变异。`fuzzer`尝试将输入样例中的字节减去或加上`8/16/32`位值。两次变异的字节位置间隔总是8位。
  * `interest L/8`(替代变异)：确定性变异。`fuzzer`需要有一个已知且可能触发异常的`8/16/32`位值的列表来尝试替代输入样例中的字节。两次变异的字节位置间隔总是8位。
  * `extras`(字典变异)：确定性变异。可能显示为`user`或`auto`，这取决于`fuzzer`是使用用户通过`-x`提供的词典还是自动创建的词典。 您还会看到`over`或`insert`标识符，具体取决于字典单词是覆盖现有数据还是通过偏移量以适应其长度来插入其中。
  * `havoc`(综合变异)：一种带栈随机调整的固定偏移循环。 在此阶段尝试的操作包括以上的几种变异思路，例如：位翻转、使用随机和可能触发异常的整数进行覆盖，块删除，块复制以及各种与字典相关的操作(如果首先提供字典)。
  * `splice`(拼接变异)：最后一个变异策略，该策略在第一个完整队列周期(`3.2`中所述)后没有新路径发现时开始。 它等效于`havoc`，不同的是它首先在任意选择的中点将来自队列的两个随机输入拼接在一起。
  * `sync`(同步变异)：仅在设置`-M`或`-S`时会使用的阶段(请参见`parallel_fuzzing.txt`)。此阶段不涉及真正的模糊测试，但是该工具会扫描其他模糊测试器的输出，并在必要时导入输入用例。 第一次执行此操作可能需要几分钟左右。
其余字段应该是字面意思就能理解的：当前阶段的`exec`计数进度指示器，全局`exec`计数器以及当前程序执行速度。
这些值可能会在输入用例发生切换时产生波动，但是理想情况下，执行速度在大多数情况下应该超过`500
execs/sec`——如果它保持在`100`以下，则该工作可能会花费很长时间。
`fuzzer`还将明确警告您有关慢速目标的信息。 如果发生这种情况，请参阅`perf_tips.txt`文件，以获取有关如何加快速度的方案。
### 3.6 Findings in depth(`fuzz`发现信息)
    +--------------------------------------+
    | favored paths : 879 (41.96%)         |
    |  new edges on : 423 (20.19%)         |
    | total crashes : 0 (0 unique)         |
    |  total tmouts : 24 (19 unique)       |
    +--------------------------------------+
这为您提供了几个完成度的指标。该部分包括基于嵌入代码中的最小化算法的路径数量(这些路径将加快运行速度)，以及实际上导致更好边缘分支覆盖的测试用例数量(而不是仅仅推动分支命中计数器上升)。
还有其他更详细的崩溃和超时计数器。
请注意，超时计数器与挂起计数器有所不同。 挂起计数器包括超过超时时间的所有测试用例也包括一些没有超出超时的程度但将其分类为挂起的用例。
### 3.7 Fuzzing strategy yields(`fuzz`详细信息)
    +-----------------------------------------------------+
    |   bit flips : 57/289k, 18/289k, 18/288k             |
    |  byte flips : 0/36.2k, 4/35.7k, 7/34.6k             |
    | arithmetics : 53/2.54M, 0/537k, 0/55.2k             |
    |  known ints : 8/322k, 12/1.32M, 10/1.70M            |
    |  dictionary : 9/52k, 1/53k, 1/24k                   |
    |       havoc : 1903/20.0M, 0/0                       |
    |        trim : 20.31%/9201, 17.05%                   |
    +-----------------------------------------------------+
这只是另一个有关完成度的部分，他用于跟踪我们为前面讨论的每个模糊测试策略建立了多少条路径，与尝试的执行次数成比例。 这有助于令人信服地验证有关`afl-fuzz`采取的各种方法的有效性的假设。
本节中的`trim`统计信息与其余统计信息略有不同。该行的第一个数字显示从输入文件中删除的字节数占总文件字节数的比率。第二个数字对应于实现此目标所需的`exec`数量。
最后，第三个数字表示虽然无法删除但被认为没有效果并且被从某些更重要的确定性模糊处理步骤中所排除的字节所占的比例。
###  3.8 Path geometry(路径信息)
    +---------------------+
    |    levels : 5       |
    |   pending : 1570    |
    |  pend fav : 583     |
    | own finds : 0       |
    |  imported : 0       |
    | stability : 100.00% |
    +---------------------+
本部分中的第一个字段表示此次模糊测试过程达到的路径深度。 本质上，用户提供的初始测试用例被认为是`Level 1`。
通过传统的模糊测试可以从中得出的输入用例被认为是`Level 1`。 通过将它们用作后续模糊测试循环的输入而得出的结果为`Level 1`；
等等。因此，最大深度可以大致代表您从`afl-fuzz`采取的编译策略中获得的测试价值。
下一个字段表示尚未进入任何模糊测试的输入样例数量。对于`fuzzer`真正想要在此队列周期中访问的受青睐条目，在下一个字段中也给出了相同的统计信息(非受青睐的条目可能需要等待几个周期才能获得机会进入测试)。
接下来的字段在并行化模糊测试中显示在此实例中发现的新路径的数量、从其他实例导入的新路径的数量、相同输入在不同实例中产生行为的一致性。毕竟同样的输入有时会在待测文件中产生可变的行为。
最后一点实际上很有趣：它可以测量观察到的路径的一致性。 如果程序对于相同的输入数据始终表现相同，则它将获得`100％`的显示。
当该值较低但仍显示为紫色时，`fuzz`过程不太可能受到负面影响。 但它如果变成红色，则可能会遇到麻烦，因为这表示`AFL`难以区分调整输入文件的意义。
现在，大多数目标只会得到`100％`的显示，但是当您看到较低的数字时，有几件事情要注意确认：
  * 在待测文件中，是否使用了未初始化的内存和某些内在的熵增源。 这对`AFL`无害，但这可能表示待测程序存在安全漏洞。
  * 是否在尝试操纵外部永久资源，例如遗留在临时文件或共享内存对象中的资源。 通常，这是无害的，但是您可能需要仔细检查以确保程序不会过早退出。磁盘空间、`SHM`句柄或其他全局资源用完也会触发此情况。
  * 是否故意进行随机输出的功能。通常无害。 例如，在对`sqlite`进行模糊处理时，输入`select random();`之类的输入将触发变量执行随机路径。
  * 多线程待测程序是否正以半随机顺序单次执行。 当`stability`指标保持在90％左右时，这是无害的，但如果不是这样，则可能成为问题。 您可以尝试以下方法： 
    * 使用`llvm_mode/`中的`afl-clang-fast`对待测程序进行重编译——此工具使用本地线程跟踪模型，该模型不太容易出现并发问题。
    * 查看目标是否可以在没有多线程机制的情况下进行编译或运行。 常见的`./configure`选项包括`--without-threads`、`-disable-pthreads`或`--disable-openmp`。
    * 用`GNU Pth`([https://www.gnu.org/software/pth/)替换`pthread`，这使您可以使用确定性线程调度程序。](https://www.gnu.org/software/pth/\)%E6%9B%BF%E6%8D%A2%60pthread%60%EF%BC%8C%E8%BF%99%E4%BD%BF%E6%82%A8%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%A1%AE%E5%AE%9A%E6%80%A7%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F%E3%80%82)
  * 在持久模式下，`stability`的细微下降可能是正常的，因为并非所有代码在重新输入时都表现出相同的行为。 但是大量的下降可能表示`__AFL_LOOP()`中的代码在后续迭代中行为不正确(例如，由于状态的不完全清理或重新初始化)，这将使得大部分的测试资源都浪费了。
检测到变量行为的路径在`/queue/.state/variable_behavior/`目录中用匹配的条目标记，因此您可以轻松地查找它们。
### 3.9 CPU load(`CPU`利用率)
    [cpu: 25%]
这个小部件显示了本地系统上的明显CPU利用率。 通过获取处于可运行状态的进程数，然后将其与系统上的逻辑核心数进行比较来计算获得。
如果该值显示为绿色，则说明您使用的CPU内核数量少于系统上可用的CPU内核数量，并且可能可以通过并行使用`fuzzer`以提高性能。
有关如何执行此操作的提示，请参见`parallel_fuzzing.txt`。
如果该值显示为红色，则说明`CPU`可能被超额使用，此时运行其他模糊测试可能不会给您带来任何好处。
当然，此基准非常简单，它告诉您准备运行多少个进程，而不告诉您它们可能需要多少资源。 它还没有区分物理内核，逻辑内核和虚拟`CPU`。
这些中的每一个的性能特征都会有很大的不同。
如果要更精确的测量，可以从命令行运行`afl-gotcpu`实用程序。
###  3.10 Addendum: status and plot files
对于无人值守的操作，一些关键状态屏幕信息也可以在输出目录的`fuzzer_stats`文件中以机器可读的格式找到。 这包括：
  * `start_time` – `unix` 时间，指示 `afl-fuzz` 的开始时间
  * `last_update` – 此文件上次更新的`unix`时间
  * `fuzzer_pid` – `fuzzer` 进程的 `PID`
  * `cycles_done` – 到目前为止完成的队列周期
  * `execs_done` – 尝试的 `execve()` 调用次数
  * `execs_per_sec` – 当前每秒执行次数
  * `paths_total` – 路径队列中的条目总数
  * `paths_found` – 通过本地模糊测试发现的路径条目数
  * `paths_imported` – 从其他实例导入的路径条目数
  * `max_depth` – 生成的数据集中的路径深度级别数
  * `cur_path` – 当前处理的路径条目号
  * `pending_favs` – 仍在等待模糊测试的受青睐路径条目的数量
  * `pending_total` – 等待模糊测试的所有路径条目的数量
  * `stability` – 行为一致的哈希表条目的百分比
  * `variable_paths` – 显示可变行为的测试用例数量
  * `unique_crashes` – 记录的唯一崩溃次数
  * `unique_hangs` – 遇到的唯一挂起数
  * `command_line` – 用于模糊会话的完整命令行
  * `slowest_exec_ms`– 最慢执行的实时时间，以毫秒为单位
  * `peak_rss_mb` – 在 `mb` 中进行模糊测试时达到的最大 `rss` 使用量
其中大多数直接映射到前面讨论的UI元素。
最重要的是，您还可以找到一个名为`plot_data`的条目，其中包含大多数这些字段的绘图表历史记录。
如果您安装`gnuplot`，则可以使用随附的`afl-plot`工具将其转换为不错的进度报告。