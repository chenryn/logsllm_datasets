**译者：知道创宇404实验室翻译组  
原文链接：**
## 前言
在[第一篇](https://paper.seebug.org/1523/)中，我们突出了相关侦察步骤！在本文中，我们深入研究了IDA历险，更好地了解`imgdecrypt`如何操作，以确保最新路由器型号的固件完整性。
使用默认的IDA加载选项
将二进制文件加载到IDA中时，将会出现一个功能列表。我们已经发现二进制代码应该是从调试符号中剥离出来的，使得调试整个代码变得较为困难，但从IDA提供给我们的方式来看，它还是相当不错的:
1.共有104个公认功能。
2.只有16个函数不能与任何库函数(或类似的函数)匹配，该程序很可能包含由D-Link生成的自定义解/加密程序。
3.即使二进制文件被称为`img` **`de`**`crypt`，主要入口点显示它显然也具有加密功能。
带注释的主要功能
这里的要点是，为了进入二进制文件的解密部分，我们的`**argv`参数列表必须包含子字符串“decrypt”。如果不是这种情况，则`char
*strstr(const char *haystack, const char *needle)`会返回`NULL`，因为它在`haystack
(argv[0] == "imgdecrypt\0")`中找不到"decrypt"。如果返回NULL，则`beqz $v0,
loc_402AE0`指令将计算正确，并将控制流重定向到`loc_402AE0`，这是二进制文件的加密部分。不理解的话，建议您仔细阅读本系列的[第1部分](https://paper.seebug.org/1523/)。
因为我们正在分析的二进制文件`imgdecrypt`被调用，从 _argv_ 空间的开头进行搜索会找到途径进入解密例程。为了能够输入 _加密_
例程，我们需要重命名二进制文件。
所以现在我们知道了如何到达存放解密固件`decrypt_firmware`的基本块。在输入之前，应该仔细查看该函数是否带有参数以及使用哪个参数。从带注释的版本中可以看到，`argc`被加载到`$a0`中，`argv`被加载到`$a1`。根据MIPS32
ABI，这两个寄存器保存了前两个函数参数！
## crypto_firmware
crypto_firmware概述
从IDA如何在图形视图中分组基本块进入`decrypt_firmware`函数后，我们可以肯定两件事:从IDA如何
1.解密有两个明显的途径
2.存在某种形式的循环。
开头的少数几个`lw`和`sw`指令是在适当的位置设置堆栈框架和函数参数，还记得[第1部分](https://paper.seebug.org/1523/)中的`/etc_ro/public.pem`吗？在这里的函数序言中，还为以后的使用设置了证书。除此之外，`argc`被加载到`$v0`中，通过`slti
$v0, 2`和2进行比较，并将其与下一条指令`beqz $v0, loc_402670`转换为以下样式代码：
    if(argc  egrep -i '(PROT_|MAP_)' /usr/include/x86_64-linux-gnu/bits/mman-linux.h
       implementation does not necessarily support PROT_EXEC or PROT_WRITE
       without PROT_READ.  The only guarantees are that no writing will be
       allowed without PROT_WRITE and no access will be allowed for PROT_NONE. */
    #define PROT_READ   0x1     /* Page can be read.  */
    #define PROT_WRITE  0x2     /* Page can be written.  */
    #define PROT_EXEC   0x4     /* Page can be executed.  */