redistribution, contrary to ﬁrmwares which do. As such, this
evaluation beneﬁts the reproducibility of our work, as well
as demonstrates the general principle, accuracy and perfor-
mance on a test set representative of high-end embedded
device ﬁrmware. Given the uncertainty over the legality of
redistribution, we refer to the original sources of the propri-
etary cipher implementations rather than publish our binary
test set. Due to copyright restrictions, we unfortunately lack
permission to publish the real-world embedded ﬁrmwares.
Section 6.1.1 deﬁnes a tunable variable n, the target number
of instances of an algorithm contained within a DFG. The
value chosen for n should be low as it correlates with the
size of the constructed DFGs, and hence running time, but
high enough so that all signatures listed in Section 10 can be
identiﬁed. The algorithm-speciﬁc and Feistel classiﬁers only
target a single instance of an algorithm, and hence are not
affected by n. Conversely, the (N)LFSR and sequential block
2https://openwrt.org/docs/techref/targets/mvebu
I
c
c
B2
c
...
c
B0
B1
(ii) Any of the input blocks B0,B1, . . . ,Bn.
In order to express this in a signa-
ture deﬁnition, we may opt for an
approach similar to how the Feis-
tel cipher signature deﬁnition is con-
structed. However, Figure 7 does not
contain any operation that serves as
an ‘anchor point’ for c, analogous
to the XOR-operation in the Feistel
structure. As such, any pattern of re-
peated operations satisﬁes property
(i), which is overtly generic. Hence,
we must also take property (ii) into
account. Let ci be the ith instance of
c. The number of arithmetic/logical
operations on the path between ci−1
and ci need not be related to that of
the path between input block Bi and
ci. Therefore, in order to translate c
into multiple variants of the signa-
ture, we have to perform a transla-
tion for both paths independently. Note that the number of
variants grows exponentially in the number of translations.
On top of that, the compression function c can be vastly more
complex than a round function in a Feistel cipher. For e.g.,
the MD5 compression function in itself consists of 64 rounds.
Therefore, the upper bound of the number of operations that
c may consist of is an order of magnitude higher than what
one would typically ﬁnd in a Feistel cipher’s round function.
All in all, the number of signature variants, and therewith the
running time of the analysis, becomes prohibitively large.
Figure 7: DFG of
a sequential block
permutation. The
blue arrows depict
the visitation order
by the classiﬁer
Fortunately, there is no need to restrict ourselves to sub-
graph isomorphism as a means of identifying primitives.
Rather, we can apply any algorithm to the DFGs generated by
the graph construction framework, which is our approach for
the sequential block permutation use case. We take several
observations into account. First, input blocks B0,B1, . . . ,Bn
are typically loaded from a memory address. Second, c has a
ﬁxed (unknown) block size, and thus we can safely assume
that the offsets between the load addresses of Bi, Bi+1 and
Bi+2 are constant. We take the following approach:
(i) We identify all nodes representing LOAD(ADD(x,k)),
where x is an arbitrary graph node, and k is a con-
stant. For each instance of x, we construct a list of tuples
(v0,v1,v2), where vi represents LOAD(ADD(x,ki)). A tu-
ple is valid only if k1 − k0 ≥ 16∧ k1 − k0 = k2 − k1, i.e.
the offsets between v0,v1 and v2 are constant, and at
564    30th USENIX Security Symposium
USENIX Association
Signature Compiler
XTEA
4 rounds
70 vertices
MD5
64 rounds
GCC
Clang
MSVC
GCC
Clang
MSVC
GCC
Clang
MSVC
458-618 vertices
AES
1 round
85-110 vertices
-O3
ok (2ms)
ok (2ms)
-O1
ok (2ms)
ok (2ms)
-O2 /
Release
ok (2ms)
ok (2ms)
ok (2ms)
-O0 /
Debug
ok (1ms)
ok (1ms)
ok (1ms)
ok (267ms) ok (335ms) ok (345ms) ok (348ms)
ok (286ms) ok (241ms) ok (272ms) ok (265ms)
ok (269ms)
ok (64ms)
ok (37ms)
ok (30ms)
ok (322ms)
ok (53ms)
ok (32ms)
ok (42ms)
ok (61ms)
ok (32ms)
ok (56ms)
ok (27ms)
-
-
-
-
-
-
Table 1: Signature matching step execution times, sample set
of Lestringant et al.
permutation classiﬁers are, as they identify a primitive based
on multiple instances. The latter identiﬁes two successive
instances of some unknown compression function c. Because
the rewrite rules are designed to promote numeric simpliﬁca-
tion (Section 5), the initialization and ﬁnalization step of an
algorithm may become merged with the ﬁrst and last instance
of c, respectively. Thus, by choosing n = 4, the presence of
two successive instances of c in the DFG is warranted. Choos-
ing a value beyond 4 clearly does not offer any advantages
regarding this property. Furthermore, identifying 4 successive
rounds of an (N)LSFR in a DFG produced from code that
does not actually implement one is highly unlikely. Therefore,
for the remainder of this section, we take n = 4.
11.1 Comparison with Lestringant et al.
Lestringant et al. [43] showcase the effectiveness of their
method by successfully identifying AES, MD5 and XTEA in
binary ﬁles. Unfortunately, their sample set was never pub-
lished, and is compiled for x86, which our implementation cur-
rently does not support. Therefore, we constructed a new sam-
ple set for the ARM architecture that is as faithful as possible
to theirs. The algorithms are taken from the cited sources3,4,5,
and subsequently compiled with GCC 9.3.0, Clang 9.0.8, and
MSVC 19.16 on all available optimization levels (O0–O3,
debug/release). We use algorithm-speciﬁc signatures in order
to warrant a fair comparison. The results are depicted in Ta-
ble 1. They show that all samples are identiﬁed successfully
by (a variant of) their corresponding signatures, regardless
of compiler and optimization level. This effectively demon-
strates that our approach is equally capable of identifying
these algorithms, without resorting to heuristics for fragment
selection.
11.2 Performance on OpenWRT binaries
The version of OpenWRT used is 19.07.2, which is the latest
at time of writing. The sample set consists of several binaries
3https://en.wikipedia.org/w/index.php?title=XTEA
4https://tools.ietf.org/html/rfc1321
5https://github.com/BrianGladman/AES
taken from the distribution and is known to contain crypto-
graphic primitives.
DFG construction from binary code (Section 5) is a special
case of execution, and is thus affected by the halting problem.
As such, graph-construction is not guaranteed to terminate.
Therefore, we introduce a graph construction timeout ttimeout.
Figure 8a depicts a histogram of graph construction time t for
all graphs constructed during the analysis of libcrypto.so.1.1.
It shows that, for the vast majority of all graphs, construction
completes within 10s. Thus, we take ttimeout = 10s.
Furthermore, we must decide what action to take when the
function under analysis invokes another function. Either we
perform inlining, and hence incorporate the entire invocation
in the resulting DFG, or we represent it by a single CALL op-
eration. To address this issue, we deﬁne a tunable variable d,
denoting the depth level to which function calls are inlined.
We investigate the impact of d by running the analysis on
libcrypto.so.1.1, while taking on different values, and measur-
ing performance in terms of running time and accuracy. We
then choose a sensible value based on a trade-off between the
two, and use it for the remainder of this section. Figure 8b
depicts the time taken to complete the entire analysis pipeline
over every function in libcrypto.so.1.1, under the inﬂuence
of d. Figure 8c contains accuracy measurements for each
signature. True negatives are omitted since they cover an over-
whelming majority of results, and thus impact readability.
Recall that the signature evaluation is performed on graphs,
and the graph construction step may yield several graphs. As
such, several signature evaluation results may exist per func-
tion. The measurements provided in Figure 8c are aggregated
on a per-function level.
Let f be any function in the binary under analysis, and let
signature sα denote a signature targeting primitive α. Further-
more, let F be the set of DFGs generated from f during the
graph construction phase. Finally, match(sα,G) indicates that
signature sα was identiﬁed in graph G, imp(f ,α) denotes that
f implements cryptographic primitive α.
A result is marked as a true positive if imp(f ,α)∧∃G.G ∈
F ∧ match(sα,G), i.e. f implements cryptographic primitive
α, and its signature is found in at least one graph in F. In-
deed, there is no guarantee that all DFGs in F contain al-
gorithm α, and hence it is expected that the signature is not
found in every graph in F. A result is marked as a false pos-
itive if ¬imp(f ,α) ∧ ∃G.G ∈ F ∧ match(sα,G), i.e. f does
not implement primitive α, yet its signature is found in at
least one graph in F. A result is marked as a true negative if
¬imp(f ,α)∧¬∃G.G ∈ F ∧ match(sα,G). A result is a false
negative if imp(f ,α)∧¬∃G.G ∈ F ∧ match(sα,G).
The results in Figure 8c show that accuracy does not
substantially improve when choosing d > 2. However, do-
ing so does impact the running time. We conclude that, for
libcrypto.so.1.1, d = 2 is a reasonable trade-off between ac-
curacy and running time. As such, we continue to use d = 2
for the remainder of this section, unless speciﬁed otherwise.
USENIX Association
30th USENIX Security Symposium    565
(a) Histogram of graph construction
(b) Inline depth d vs analysis time
(c) Inline depth d vs accuracy
Figure 8: Effect of inline depth d and ttimeout for libcrypto.so.1.1
At this point, sensible values for n, d and ttimeout have been
selected. We continue the evaluation by feeding the entire
set of OpenWRT binaries to our analysis framework. The
results are listed in Table 2. Each cell in the table depicts the
symbol name in the corresponding binary of the ﬁrst positive
result, or, in case of a false negative, the symbol name where a
positive result is expected. The results indicate our solution is
capable of successfully identifying the vast majority of cryp-
tographic primitives present in various binaries in a timely
manner. Should accuracy take precedence over performance,
it is possible to tune the parameters to improve detection.
197 KB
6m56s
(cid:88) BF_encrypt
(cid:88) aes_encrypt
N/A
libnettle.so.7.02
237 KB
11m32s
libcrypto.so.1.1
1,735 KB
39m47s
N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A
N/A
(cid:88) md4_update4
N/A
N/A
N/A
N/A
(cid:88) sha512_update5
(cid:88) sha512_process5
libmbedcrypto.so.2.16.31
dropbear
145 KB
6m44s
(cid:88) blowﬁsh_crypt_ecb4
(cid:88) Camellia_EncryptBlock
(cid:88) md5_update_ret
(cid:88) md5_update_ret
(cid:88) hmac_md5_update
(cid:88) hmac_md5_update
(cid:88) Unlabeled3
(cid:88) Unlabeled3
(cid:88) Unlabeled3
(cid:88) Unlabeled3
(cid:88) sha1_update_ret
(cid:88) sha1_update_ret
(cid:88) sha256_update_ret
(cid:88) RIPEMD160_Update
(cid:88) SHA512_Update5
(cid:88) sm3_block_data_order
(cid:88) sha1_compress
(cid:88) sha1_update4
(cid:88) sha256_update4,5
(cid:88) aes_encrypt_armv6
(cid:88) SHA1_Update
(cid:88) SHA1_Update
(cid:88) SHA256_Update5
(cid:88) AES_encrypt
(cid:88) MD4_Update
(cid:88) MD5_Update
(cid:88) MD5_Update
Algorithm
signature
size
analysis time
SHA1
sha1
bl.perm.
SHA256
bl.perm.
AES
aes
MD4
bl.perm.
MD5
md5
bl.perm.
RIPEMD160
bl.perm.
SHA512
bl.perm.
SM3
bl.perm.
BLOWFISH
feistel
CAMELLIA
feistel
CAST
feistel
DES
feistel
RC2
feistel
SEED
feistel
SM4
feistel
GOST
feistel
MD2
bl.perm.
TWOFISH
feistel
SHA3
bl.perm.
1 Symbols preﬁxed with mbedtls_
2 Symbols preﬁxed with nettle_
3 Misclassiﬁed by IDA as an integer array. Manual cast to function
required.
4 Positive match for d ≥ 4.
5 Positive match for ttimeout ≥ 30s.
Table 2: Analysis result for various binaries in OpenWRT
(cid:88) blowﬁsh_encrypt
(cid:88) camellia_crypt
(cid:88) cast128_encrypt
 RC2_encrypt
(cid:88) SEED_encrypt
(cid:88) SM4_encrypt
 twoﬁsh_encrypt
(cid:88) sha3_update4