出
配决策速度、健壮性、安全性等因素，这使得堆管理变得异常复杂。本书关注的主要是Win32
利
平台的堆管理策略。微软操作系统堆管理机制的发展大致可以分为三个阶段。
用
（1）Windows2000～WindowsXPSP1：堆管理系统只考虑了完成分配任务和性能因素，丝
毫没有考虑安全因素，可以比较容易发被攻击者利用。
（2）WindowsXP2～Windows2003：加入了安全因素，比如修改了块首的格式并加入安全
cookie，双向链表结点在删除时会做指针验证等。这些安全防护措施使堆溢出攻击变得非常困
滩，但利用一些高级的攻击技术在一定情况下还是有可能利用成功。
（3）WindowsVista～Windows7：不论在堆分配效率上还是安全与稳定性上，都是堆管理算
法的一个里程碑。
本书将主要讨论Windows2000～WindowsXPSP1平台的堆管理策略。
5.1.2堆与栈的区别
第2章中提到过，程序在执行时需要两种不同类型的内存来协同配合。
一种是前面所讨论的系统栈。经过对栈溢出利用的学习，我们应该明白栈空间是在程序设
计时已经规定好怎么使用，使用多少内存空间的。典型的栈变量包括函数内部的普通变量、数
组等。栈变量在使用的时候不需要额外的申请操作，系统栈会根据函数中的变量声明自动在函
数栈帧中给其预留空间。栈空间由系统维护，它的分配（如subesp，xx；）和回收（如addesp，
xxx）都由系统来完成，最终达到栈平衡。所有的这些对程序员来说都是透明的。
另外一种内存就是本章将讨论的堆。从程序员的角度来看，堆具备以下特性。
（1）堆是一种在程序运行时动态分配的内存。所谓动态是指所需内存的大小在程序设计时
不能预先决定，需要在程序运行时参考用户的反馈。
（2）堆在使用时需要程序员用专用函数进行申请，如C语言中的malloc等函数、C++中的
new函数等都是最常见的分配堆内存的函数。堆内存申请有可能成功，也有可能失败，这与申
请内存的大小、机器性能和当前运行环境有关。
（3）一般用一个堆指针来使用申请得到的内存，读、写、释放都通过这个指针来完成。
（4）使用完毕后需要把堆指针传给堆释放函数回收这片内存，否则会造成内存泄露。典型
的释放函数包括free、delete等。
堆内存与栈内存的比较如表5-1-1所示。
栈只有pop和push两种操作，总是在“线性”变化，其管理机制也相对简单，所以，栈
溢出的利用很容易掌握。与“整齐”的栈不同，堆往往显得“杂乱无章”，所以堆溢出的利用
是内存利用技术的一个转折点。对堆利用技术的讨论也是安全技术界长久不衰的热门话题。
145
---
## Page 171
0
day
表5-1-1堆内存与栈内存的比较
安
堆内存
栈内存
全
典型用例
动态增长的链表等数据结构
的数局部数组
：
需要用函数申请，通过返回的指计使用。如
软
申请方式
在程序中直接声明即可，如charbuffer[8]：
件
p=malloc(8):
漏
释放方式
需要把指针传给专用的释放函数，如free
函数返回时，由系统自动回收
洞
管理方式
申请后直接使用，申请与释放由系统自动完
分
需要程序员处理申请与释放
成，最后达到栈区平衡
析
所处位置
变化范围很大
0x0012XXXX
技
术
增长方向
由内存低址向高址排列（不考虑碎片等情况）
由内存高址向低址增加
（第
5.1.3堆的数据结构与管理策略
2
版
操作系统一般会提供一套API把复杂的堆管理机制屏蔽掉。因此，如果不是技术狂热者，
普通的程序员是没有必要知道堆分配细节的。然而，要理解堆溢出利用技术，就必须适当了解
制的原理，这些知识将有助于您更好地理解后续的技术细节，甚至启发您自己去挖掘堆中更深
层次的东西。如果您是计算机系科班出身，那一定对本节的内容不陌生，因为这听起来更像是
操作系统课程中的一个章节。
面将站在实现一一个堆管理机制的设计者角度，来看看怎样才能向程序员提供这样透明的操作。
对于堆管理系统来说，响应程序的内存使用申请就意味着要在“杂乱”的堆区中“辨别”
出哪些内存是正在被使用的，哪些内存是空闲的，并最终“寻找”到一片“恰当”的空闲内存
区域，以指针形式返回给程序。
（1）“杂乱”是指堆区经过反复的申请、释放操作之后，原本大片连续的空闲内存区可能
皇现出大小不等且空闲块、占用块相间隔的凌乱状态。
（2）“辨别”是指堆管理程序必须能够正确地识别哪些内存区域是正在被程序使用的占用
块，哪些区域是可以返回给当前请求的空闲块。
用8个字节，而返回给用户一片512字节的连续内存区域并将其标记成占用状态，这将造成大
量的内存浪费，以致出现明明有内存却无法满足申请请求的情况。
为了完成这些基本要求，必须设计一套高效的数据结构来配合算法。现代操作系统的堆数
据结构一般包括堆块和堆表两类。
堆块：出于性能的考虑，堆区的内存按不同大小组织成块，以堆块为单位进行标识，而不
是传统的按字节标识。一个堆块包括两个部分：块首和块身。块首是一个堆块头部的几个字节，
用来标识这个堆块自身的信息，例如，本块的大小、本块空闲还是占用等信息；块身是紧跟在
块首后面的部分，也是最终分配给用户使用的数据区。
146
---
## Page 172
第
注意：堆管理系统所返回的指针一般指向块身的起始位置，在程序中是感觉不到块首
5
的存在的。然而，连续地进行内存申请时，如果您够细心，可能会发现返回的内存之
章
间存在“空隙”，那就是块首！
堆
堆表：堆表一般位于堆区的起始位置，用于索引堆区中所有堆块的重要信息，包括堆块的
溢
出
位置、堆块的大小、空闲还是占用等。堆表的数据结构决定了整个堆区的组织方式，是快速检
利
索空闲块、保证堆分配效率的关键。堆表在设计时可能会考虑采用平衡二叉树等高级数据结构
用
用于优化查找效率。现代操作系统的堆表往往不止一种数据结构。
堆的内存组织如图5.1.1所示。
维表
堆级
Du
区
内存
图5.1.1堆的内存组织
在Windows中，占用态的堆块被使用它的程序索引，而堆表只索引所有空闲态的堆块。其
中，最重要的堆表有两种：空闲双向链表Freelist（以下简称空表，如图5.1.2所示）和快速单
向链表Lookaside（以下简称快表，如图5.1.3所示）。
1.空表
空闲堆块的块首中包含一对重要的指针，这对指针用于将空闲堆块组织成双向链表。按照
堆块的大小不同，空表总共被分为128条。
堆区一开始的堆表区中有一个128项的指针数组，被称做空表索引（Freelistarray）。该数
组的每一项包括两个指针，用于标识一条空表。
如图5.1.2所示，空表索引的第二项（free[1]）标识了堆中所有大小为8字节的空闲堆块，
之后每个索引项指示的空闲堆块递增8字节，例如，free[2]标识大小为16字节的空闲堆块，free[3]
标识大小为24字节的空闲堆块，free[127]标识大小为1016字节的空闲堆块。因此有：
空闲堆块的大小=索引项（ID）x8（字节）
把空闲堆块按照大小的不同链入不同的空表，可以方便堆管理系统高效检索指定大小的空
闲堆块。需要注意的是，空表索引的第一项（free[0]）所标识的空表相对比较特殊。这条双向
链表链入了所有大于等于1024字节的堆块（小于512KB）。这些堆块按照各自的大小在零号空
147
---
## Page 173
ody安全：软件漏洞分析技术（第2版）
表中升序地依次排列下去，您会在稍后发现这样组织的好处。
free[0],
1024byte8R
2048bytes
2048bytes4096bytes
free[1]
8bys8byes
8byes8bytes
free[2]]
16byes16byes16byes16byes
free[3]
24byes24bys24bys24bys]
free[4]
32byes32byes32byes32byes
.....
ree[126]
1016bytes1016bytes1016bytes1016bytes
空表索引
空闲堆块
图5.1.2空闲双向链表（Freelist）
lookaside[0]
lookaside[1]
8bytes
lookaside[2]
16bytes
16 bytes
lookaside[3]
lookaside[4]
lookaside[126]
lookaside[127]
1016bytes1016bytes
图5.1.3
快速单向链表（Lookaside）
2.快表
快表是Windows用来加速堆块分配而采用的一种堆表。这里之所以把它叫做“快表”是因
为这类单向链表中从来不会发生堆块合并（其中的空闲块块首被设置为占用态，用来防止堆块
合并）。
快表也有128条，组织结构与空表类似，只是其中的堆块按照单链表组织。快表总是被初
148
---
## Page 174
始化为空，而且每条快表最多只有4个结点，故很快就会被填满。
5
堆中的操作可以分为堆块分配、堆块释放和堆块合并（Coalesce）三种。其中，“分配”和
喜
“释放”是在程序提交申请和执行的，而堆块合并则是由堆管理系统自动完成的。
堆
1.堆块分配
溢
堆块分配可以分为三类：快表分配、普通空表分配和零号空表（free[0]）分配。
出
从快表中分配堆块比较简单，包括寻找到大小匹配的空闲堆块、将其状态修改为占用态、
利
用
把它从堆表中“卸下”、最后返回一个指向堆块块身的指针给程序使用。
普通空表分配时首先寻找最优的空闲块分配，若失败，则寻找次优的空闲块分配，即最小
的能够满足要求的空闲块。
零号空表中按照大小升序链着大小不同的空闲块，故在分配时先从free[0]反向查找最后一
个块（即表中最大块），看能否满足要求，如果能满足要求，再正向搜索最小能够满足要求的
空闲堆块进行分配（这就明白为什么零号空表要按照升序排列了）。
块会被用于分配。这种次优分配发生时，会先从大块中按请求的大小精确地“割”出一块进行
分配，然后给剩下的部分重新标注块首，链入空表。这里体现的就是堆管理系统的“节约”原
则：买东西的时候用最合适的钞票，如果没有，就要找零钱，决不会玩大方。
由于快表只有在精确匹配时才会分配，故不存在“找钱”现象。
注意：这里没有讨论堆缓存（heapcache）、低碎片堆（LFH）和虚分配。
2.堆块释放
释放堆块的操作包括将堆块状态改为空闲，链入相应的堆表。所有的释放块都链入堆表的
末尾，分配的时候也先从堆表末尾拿。
另外需要强调，快表最多只有4项。
3.堆块合并
经过反复的申请与释放操作，堆区很可能变得“千疮百孔”，产生很多内存碎片。为了合
理有效地利用内存，堆管理系统还要能够进行堆块合并操作，如图5.1.4所示。
当堆管理系统发现两个空闲堆块彼此相邻的时候，就会进行堆块合并操作。
堆块合并包括将两个块从空闲链表中“卸下”、合并堆块、调整合并后大块的块首信息（如
大小等）、将新块重新链入空闲链表。
题外话：实际上，堆区还有一种操作叫做内存紧缩（shrinkthecompact），由RtlConpactHeap
执行，这个操作的效果与碰盘碎片整理差不多，会对整个堆进行调整，尽合并可用
的碎片。
在具体进行堆块分配和释放时，根据操作内存大小的不同，Windows采取的策略也会有所
不同。可以把内存块按照大小分为三类：
小块：SIZE<IKB
149
---
## Page 175
0
day
大块：1KB≤SIZE<512KB
安全：
巨块：SIZE≥512KB
512
1：内存中有1个空闲
Bytes
块，大小为512字节
软件漏
64
2:连续7次请求64
字节的内存
洞分析技术
64
3：在使用中，2个堆
64
64
块被提前释放，这时程
BytesBytesBytes
序再次申请一个128字
节的堆块，虽然堆区内
目前有3x64=192字节
（第
的空闲内存，但由于他
新内存中请
128 bytes
们是不连续的“内存碎
片”，故无法满足申请
2
要求
版
192
gs6gogsgog
4：如果能把小堆块合
Bytes
虹
并成大堆块，则能够
更有效的利用内存，
从而完成分配
新内存申请
128 bytes
图5.1.4内存紧缩示意图
对应的分配和释放算法也有三类，我们可以通过表5-1-2来理解Windows的堆管理策略。
表5-1-2分配和释放算法
分配
释放
首先进行快表分配：
若快表分配失败，进行普通空表分配：
优先链入快表（只能入4个空
若普通空表分配失败，使用堆缓存（heapcache）分配：
闲块）：
小块
若堆缓存分配失败，尝试零号空表分配（freelist[O]）
如果快表满，则将其链入相应的
若零号空表分配失败，进行内存紧缩后再尝试分配：
空表
若仍无法分配，返回NULL
首先使用堆缓存进行分配：
优先将其放入堆缓存
大块
若堆缓存分配失败，使用free[O]中的大块进行分配
若堆缓存满，将链入freelists[0]
般说来，巨块申请非常罕见，要用到虚分配方法（实际上
巨块
并不是从堆区分配的）。
直接释放，没有堆表操作
这种类型的堆块在堆溢出利用中几乎不会遇到，本书中讨论
暂不涉及这种情形
最后，再强调一下Windows堆管理的几个要点。
（1）快表中的空闲块被设置为占用态，故不会发生堆块合并操作。
150
---
## Page 176
第
5
（3）快表是单链表，操作比双链表简单，插入删除都少用很多指令。
章
（4）综上所述，快表很“快”，故在分配和释放时总是优先使用快表，失败时才用空表。
堆溢出利
（5）快表只有4项，很容易被填满，因此空表也是被频繁使用的。
综上所述，Windows的堆管理策略兼顾了内存合理使用、分配效率等多方面的因素。
5.2
在堆中漫游
用
5.2.1堆分配函数之间的调用关系
Windows平台下的堆管理架构可以用图5.2.1来概括。
应用程序
Appllcation code
User
Mode
VirtualMemoryAPI
Kernel
Kernel-levelVirtual MemoryManager
Mode
PhysicalMemory
图5.2.1Windows堆分配体系架构
Windows中提供了许多类型的堆分配函数，您可以在MSDN中找到这些函数的详细说明。
它们之间的关系如图5.2.2所示。
所有的堆分配函数最终都将使用位于ntdll.dll中的RtlAllocateHeapO函数进行分配，这个函
数也是在用户态能够看到的最底层的堆分配函数。所谓万变不离其宗，这个“宗”就是
RtlAllocateHeapO。因此，研究Windows堆只要研究这个函数即可。
LocalAlloc(
GlobalAlloc()
HeapAlloc0
malloc()
kernel32.dll
ntdll.dll
RtlAllocateHeap()
kemel mode
kernel
图5.2.2Windows堆分配API调用关系
151