*12
247
口
---
## Page 264
这里，f和x表示表达式，而s→ 表示从到的函数。这个针对单参数函数的规则可以推广到带
达式的类型。它要求名字先声明再使用。表达式 E；+F2的类型是根据 E 和E2的类型定义的。
6.5.1
攻击。
细类型信息。导人的代码在被执行之前首先要进行类型检查，以防止因疏忽造成的错误和恶意
软件模块。Java 程序被编译成为机器无关的字节码，在字节码中包含了有关字节码中的运算的详
实现就被称为强类型的。
候发生。如果编译器可以保证它接受的程序在运行时刻不会发生类型错误，那么该语言的这个
动态类型错误检查的需要，因为它可以帮助我们静态地确定这些错误不会在目标程序运行的时
了元素类型的信息，那么任何检查都可以动态地进行。一个健全(sound)的类型系统可以消除对
型系统（type system）。
达式。然后，编译器要确定这些类型表达式是否满足一组逻辑规则。这些规则称为源语言的类
6. 5
列元素的位置。
20。
-一个典型的类型综合规则具有如下形式：
除了用于编译，类型检查的思想还可以用于提高系统的安全性，使得人们安全地导人和执行
类型宽度的)4,我们就可以在我们的翻译方案中做到这一点。
小，因此中间代码独立于机器的字长。只要用一个符号常量来代替翻译方案中的（作为整数
所示，关于基本类型的信息被融合到了这个翻译方案中。例如，例6.12 中假定每个整数数组
码生成器时，优化器不需要做出太大的改变。然而，正如我们刚刚描述的类型宽度计算方法
类型检查有两种形式：综合和推导。类型综合(type synthesis)根据子表达式的类型构造出表
类型检查具有发现程序中的错误的潜能。原则上，如果目标代码在保存元素值的同时保存
248
为了进行类型检查(type checking），编译器需要给源程序的每--个组成部分赋予一个类型表
练习6.4.9：假定A 是按列存放的，重复练习6.4.8。
1) A[3,4,5] 
练习6.4.7：假定A 是按列存放的，重复练习6.4.6。
1) 4[4,5] 2) A[10,8] 3) A[3,17] 
每个整数占4个字节。假设数组A从0字节开始存放，请给出下列元素的位置：
练习6.4.6：一个按行存放的整数数组A[,的下标的范围为1～10，下标j的范围为1～
！4）其他条件和3 相同，但是采用按列存放方式。
！3）--个k维的数组 A，按行存放，元素宽度为αu，第j维的下标从到h;。
类型检查
中间代码应该相对独立于目标机器，这样当代码生成器被替换为对应于另一台机器的代
类型检查规则
2) A[1,2,7] 3) A[4,3,9]
then 表达式f(α)的类型为t
iff的类型为 s-→#且x的类型为s
符号化表示的类型宽度
第6章
(6.8)
---
## Page 265
换和窄化(narrowing)转换。拓宽转换可以保持原有的信息，而窄化转换则可能丢失信息。拓宽
时，精心组织用于类型转换的语义动作就变得非常重要。
代码给出：
算分量的运算符，而 float＊表示作用于浮点型运算分量的运算符。
在表达
个运算分量进行转换，以保证在进行加法运算时两个运算分量具有相同的类型。
有不同的表示形式，而且使用不同的机器指令来完成整数和浮点数运算。编译器需要把+的某
6.5.2
void。
例如，我们可以把条件语句“if（E）S；"看作是对E和 S应用ü函数。令特殊类型 uoid 表示没有
声明。
表达式中的类型变量。
是：x是-个列表类型，其元素类型当前未知。
我们可以指出x必须是一个列表类型。列表中的元素类型是未知的，我们所知道的全部信息
6.5. 4 节中的例子，令 nul是一个测试列表是否为空的函数。那么，根据这个函数的使用 null(),
数应用add(E，E2)就可以了。
有多个参数的函数。只要稍做修改，规则(6.8)就可以用于E，+E2，我们只需要把它看作一个函
即使我们在确定类型时需要某些上下文信息，我们仍将使用“综合"这个术语。使用重载函数时（多个函数可能被
不同语言具有不同的类型转换规则。图 6-25 中的 Java 的转换规则区分了拓宽(widening)转
我们将扩展6.4.2节中的用于表达式翻译的翻译方案，以说明如何进行类型综合。我们引人
假定在必要的时候可以使用一个单目运算符（f1oat)将整数转换成浮点数。例如，整数2
直的类型，那么ü函数将被应用在--个布尔型和-个 void 型的对象上。此函数的结果类型是
在本节中，我们考虑表达式的类型检查。检查语句的规则和检查表达式类型的规则类似。
代表类型表达式的变量使得我们可以考虑未知类型。我们可以用希腊字母α、β 等作为类型
类型推导(type inference）根据--个语言结构的使用方式来确定该结构的类型。先看--下
中间代码生成
考虑类似于+i的表达式，其中×是浮点数类型而i是整型。因为整数和浮点数在计算机中
随着需要转换的类型的增多，需要处理的不同情况也急剧增多。因此，在处理大量的类型
我们可以扩展这样例子，考虑运算符的整型和浮点型版本。比如，int＊表示作用于整型运
在类似 ML 这样的语言中需要进行类型推导。ML 语言会检查类型，但是不需要对名字进行
一个典型的类型推导规则具有下面的形式：
赋予同一个名字)，在某些语言中，我们还需要考虑E，+E2的上下文才能确定其类型规则。
=t1*3.14
式2＊3.14对应的代码中被转换成浮点数：
类型转换
then 对某些α和β,f的类型为α→β 且α的类型为α
iff(x)是一个表达式，
(6.9)
是
---
## Page 266
示加法运算。用户自定义的函数同样可以重载，例如
例6.13
些只需要查看函数参数就能解决的函数重载。Java 中的重载即是如此。
名字的每次出现确定其唯一的含义，该名字的重载问题就得到了解决。在本节中，我们仅考虑那
6.5.3函数和运算符的重载
都转换成为第三种类型。
是浮点型，就不需要进行任何转换。我们会发现，将两个不同类型的值相加的唯一方法是把它们
E2.addr，也可能是一个新临时变量，用于存放转换后的 E2的值。如果两个变量都是整型或者都
如果需要进行这样的转换，则α;就是 uwiden 函数返回的一个新的临时变量。类似地，α2可能是
在这个语义动作中，如果E的类型不需要被转换成E的类型，那么临时变量α,就是E,，addr。
类型转换加入到图6-20 所示的翻译表达式的方案中。
假设只有integer和float 两种类型。
结果返回。函数 αwiden 的伪代码如图 6-26 所示，这里
换
身
代码。如果t和w是相同的类型，则该函数返回α本
层次结构中，比如有个类型是数组类型或指针类型,
者
并
的
转换(coercion）。在很多语言中，自动类型转换仅
仅
转换就称为隐式转换。隐式转换也称为自动类型
char、short、byte 之间可以两两相互转换。
的规则如图6-25b 所示：如果存在一条从s到t的路径，则可以将类型s窄化为类型t。可以看出，
换结果放置到临时变量 temp 中。这个临时变量将作为
身。否则，它会生成一条指令来完成转换工作并将转
类型的值，则函数 widen(α,t,w)将生成类型转换的
最小上界)。如果或t之一没有出现在这个
返回拓宽层次结构中这两个类型中的最大者（或
依据符号所在的上下文不同，被重载(overloaded）的符号会有不同的含义。如果能够为一个
图6-27 中 E→E;+E2 的语义动作说明了如何把
。
限于拓宽转换。如果程序员必须写出某些代码
如果类型转换由编译器自动完成，那么这样的
250
2）如果需要将类型为的地址α 中的内容转换成
void err()
检查E→E+E2的语义动作使用了两个函数：
显式转换也称为强制类型转换(cast）。
）max(μ，t)接受t;和 t两个类型的参数,
根据其运算分量的类型，Java 中的+运算符既可以表示字符串的连接运算，也可以表
E→E+E2
图6-27在表达式求值中引人类型转换
型
，那么该函数返回一个错误信息。
a）拓宽类型转换
double
图6-25
图6-26uiden 函数的伪代码
else error;
char
if(t
Java 中简单类型的转换
return temp;
u ) return a;
r and w = foat ){
b）窄化类型转换
Temp();
double
9
---
## Page 267
次使用多态类型时，我们将受限变量替换为新的变量，并去掉相应的全称量词。
Vβ. list(β)→integer 和式(6.12)等价。其中带有V符号的类型表达式被称为“多态类型”。
被任意地重命名，但是需要把这个变量的所有出现一起重命名。因此，类型表达
符号V是全称量词（wiversal quantifier），它所作用的类型变量称为受限的（bound）。受限变量可以
字符串列表的长度为3，整数列表的长度为4，因此表达式(6.11)的值为7。
达式中，length 被应用到两种不同类型的列表中(列表元素用"["和“]”括起来)：
同的类型。不管列表元素是什么类型，都可以用 length 函数来求出这个列表的长度。在下面的表
返回列表的余下部分。
的函数 null 测试一个列表是否为空。预定义函数 l(tail 的缩写)移除列表中的第一个元素，然)
序片段定义了带有单个参数x的函数length。这个函数的函数体包含了一个条件表达式。预定
例6.14
为：“对于任何类型α，length 函数将元素类型为α的列表映射为整型”。
ML 程序作为一个贯穿本节的例子。该程序定义了一个函数 length。函数 length 的类型可以描述
数多态（parametric polymorphism），这种多态通过参数和类型变量来刻划。我们使用图6-28 中的
进行声明。类型推导保证了名字使用的一致性。
6.5.4类型推导和多态函数
可选范围，最终得到唯一-的可选类型(见练习6.5.2)。
有一组可能的类型，而不是只有一个确定的类型。它所在的上下文必须提供足够的信息来缩小
载的问题就等价于基于范型解决重载的问题。
值编码组成。“一个函数的范型由其函数名和它的参数的类型组成。根据函数的参数类型解决重
用算法6.3，我们可以构造出每个结点的范型，该范型由该结点的标号及其从左到右的子结点！
请注意，我们可以根据函数érr 的参数来确定选择该函数的哪一-个版本。
在多态函数的各次应用中，函数的受限的类型变量可以表示不同的类型。在类型检查中，每
类型推导常用于像 ML 这样的语言。ML 是-一个强类型语言，但是它不要求名字在使用前先
仅仅通过查看--个函数的参数类型不一定能够解决重载问题。在 Ada 中，一个子表达式会
中间代码生成
使用符号（读作“对于任意类型”）以及类型构造算子 lis，length 的类型可以写作：
函数 length 确定一个列表x的长度，或者说x中元素的个数。列表中的所有元素必须具有相
术语“多态"指的是任何可以在不同的参数类型上运行的代码片段。在本节中，我们考虑参
，在表示类型表达式的一个 DAC上，我们给每个结点赋予－-个被称为值编码的整数序号。
6.1.2节中的值编码方法同样可以用于类型表达式，以便根据参数类型高效地解决重载问
以下是针对重载函数的类型综合规则：
在图6-28 中，关键字fun 引出了一个函数定义，被定义的函数可以是递归的。这个程
([L8‘6 '01])yau+ (.on,‘"uou‘uns])yau
then 表达式f(x)的类型为 tk
andx的类型为 s(1≤k≤n）
if f可能的类型为s;→t;(1≤i≤n)，其中，s;≠s;(i≠j)
图6-28计算一个列表长度的 ML 程序
fun tength(2)
if nul(c) then 0 else length(tl(z) + 1;
Vα.list(α)→integer
(6.12)
(6.11)
(6.10)
251
口
后
义
的
使
参
口