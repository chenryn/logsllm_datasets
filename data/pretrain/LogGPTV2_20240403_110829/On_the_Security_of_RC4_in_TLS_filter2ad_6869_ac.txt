240&
250&
Figure 2: Measured distributions of RC4 keystream
bytes Z16 (top), Z32 (middle), and Z50 (bottom).
the latter ﬁnding both conﬁrms and extends the results
from [23]. Both of these new biases were also observed
by Isobe et al. [13], with a theoretical explanation be-
ing given for the bias towards r. Figure 3 shows the es-
timated strength of these biases in comparison with the
strength of the bias towards 0x00 for the keystream bytes
Z1, . . . ,Z 256. The estimates are based on the empirical
distribution of the RC4 keystream bytes, calculated over
244 random 128-bit RC4 keys. We note that the key-
length dependent bias dominates the other two biases un-
til position Z112, and that the bias of Zr towards r dom-
inates the bias towards 0x00 observed by [15] between
positions Z5 and Z31, except for byte Z16 where the bias
towards 0x00 is slightly stronger.
Furthermore, for the ﬁrst keystream byte Z1, we have
observed a bias away from value 0x81 (decimal 129) in
the addition to the known bias away from value 0x00.
This additional bias is not consistent with the recent re-
sults of Sen Gupta et al. [23] who provide a theoreti-
cal treatment of the distribution of Z1. The disparity
likely arises because Sen Gupta et al. work with 256-
byte keys, while our work is exclusively concerned with
128-bit (16-byte) keys as used in TLS; in other words,
our observed bias in Z1 = 0x81 seems to be key-length-
dependent. Finally, our computations have revealed a
number of other, smaller biases in the initial bytes of the
RC4 keystream.
Figure 3: Measured strength of the bias towards 0x00
(green), the bias towards value r in Zr (blue), and the key-
length dependent bias towards byte value 256− r (red)
for keystream bytes Z1, . . . ,Z 256, based on keystreams
generated by 244 independent random keys. Note that
the large peak for the 0x00 bias in Z2 extends beyond the
bounds of the graph and is not fully shown for illustrative
purposes.
3.2 Multi-byte Biases
Besides the single-byte biases highlighted above, sev-
eral multi-byte biases have been identiﬁed in the RC4
keystream.
In contrast to the single-byte biases, most
of the identiﬁed multi-byte biases are “long term” bi-
ases which appear periodically at regular intervals in the
keystream.
The most extensive set of multi-byte biases was
identiﬁed by Fluhrer and McGrew [12] who analyzed
the distribution of pairs of byte values for consecutive
keystream positions (Zr,Zr+1), r ≥ 1. More precisely,
they estimated the distribution of consecutive keystream
bytes for scaled-down8 versions of RC4 by assuming an
idealized internal state of RC4 in which the permuta-
tion S and the internal variable j are random (see Fig-
ure 1), and then extrapolated the results to standard RC4.
The reported biases for standard RC4 are listed in Ta-
ble 1. Note that all biases are dependent on the internal
variable i which is incremented (modulo 256) for each
keystream byte generated. It should also be noted that,
due to the assumption that S and j are random, the bi-
ases cannot be expected to hold for the initial keystream
bytes. However, this idealization becomes a close ap-
proximation to the internal state of RC4 after a few invo-
cations of the RC4 keystream generator, [12].
We experimentally veriﬁed the Fluhrer-McGrew bi-
ases by analysing the output of 210 RC4 instances using
128-bit keys and generating 240 keystream bytes each.
For each keystream, the initial 1024 bytes were dropped.
Based on this data, we found the biases from [12] to be
accurate, also for 128-bit keys. This is in-line with the
310  22nd USENIX Security Symposium 
USENIX Association
6
experiments and observations reported in [12]. Further-
more, we did not identify any additional signiﬁcant long
term biases for consecutive keystream bytes which are
repeated with a periodicity that is a proper divisor of 256.
Hence, for the purpose of implementing the attack pre-
sented in Section 4.2, we assume that the biases iden-
tiﬁed in [12] are the only existing long term biases for
consecutive keystream bytes, and that all other pairs of
byte-values are uniformly distributed.
Byte pair
Condition on i
(0,0)
(0,0)
(0,1)
(i + 1,255)
(255,i + 1)
(255,i + 2)
(255,0)
(255,1)
(255,2)
(129,129)
(255,255)
(0,i + 1)
i = 1
i (cid:30)= 0,253,254,255
i (cid:30)= 1,255
i (cid:30)= 0,1
i (cid:30)= 254
i (cid:30)= 1,254
i = 254
i = 255
i = 0,1
i = 2
i (cid:30)= 254
i (cid:30)= 0,255
Probability
2−16(1 + 2−9)
2−16(1 + 2−8)
2−16(1 + 2−8)
2−16(1 + 2−8)
2−16(1 + 2−8)
2−16(1 + 2−8)
2−16(1 + 2−8)
2−16(1 + 2−8)
2−16(1 + 2−8)
2−16(1 + 2−8)
2−16(1− 2−8)
2−16(1− 2−8)
Table 1: Fluhrer-McGrew biases for consecutive pairs of
byte values. In the table, i is the internal variable of the
RC4 keystream generation algorithm (see Section 2.1).
Independently of [12], Mantin [16] identiﬁed a pos-
itive bias towards the pattern ABSAB, where A and B
represent byte values and S is a short string of bytes
(possibly of length 0). The shorter the string S is, the
more signiﬁcant is the bias. Additionally, Sen Gupta
et al. [23] identiﬁed a bias towards the byte values (0,0)
for keystream positions (Zr,Zr+2), separated by any sin-
gle keystream byte for r ≥ 1. However, we do not make
use of these biases in the attacks presented in this paper.
4 Plaintext Recovery Attacks
For the purpose of exposition, we ﬁrst explain how the
broadcast attack by Maitra et al. [15] and Sen Gupta
et al. [23] is meant to work. Suppose byte Zr of the
RC4 keystream has a dominant bias towards value 0x00.
As RC4 encryption is deﬁned as Cr = Pr ⊕ Zr, the cor-
responding ciphertext byte Cr has a bias towards plain-
text byte Pr. Thus, obtaining sufﬁciently many ciphertext
samples Cr for a ﬁxed plaintext Pr allows inference of Pr
by a majority vote: Pr is equal to the value of Cr that
occurs most often. This is the core idea of Algorithm 3
that we reproduce from [15, 23]. Let S denote the num-
ber of ciphertexts available to the attacker and, for all
1 ≤ j ≤ S, let Cj,r denote the r-th byte of ciphertext Cj.
For a ﬁxed position r, Algorithm 3 runs through all j,
and in each iteration increments one out of 256 counters,
Algorithm 3: Basic plaintext recovery attack
input : S independent encryptions (Cj)1≤ j≤S of
output: estimate P∗r for plaintext byte Pr
begin
ﬁxed plaintext P, position r
N0x00 ← 0, . . . , N0xFF ← 0
for j = 1 to S do
NCj,r ← NCj,r + 1
P∗r ← argmaxµ∈{0x00,...,0xFF} Nµ
namely the one that corresponds to value Cj,r. After pro-
cessing all ciphertexts, the character corresponding to the
largest counter in the obtained histogram is the output of
the algorithm.
The algorithm is tailor-made for plaintext recovery
in the case described by Result 2:
it assumes that the
largest bias in the RC4 keystream is towards 0x00. How-
ever, it is highly likely to fail to reliably suggest the cor-
rect plaintext byte Pr if the RC4 keystream has, in posi-
tion r, additional biases of approximately the same size
(or larger) as the bias towards 0x00. Such additional
biases would simply be misinterpreted as the bias to-
wards 0x00 and hence falsify the result. As we observed
in Section 3.1 (and Figure 3), several other quite strong
biases in the RC4 keystream do indeed exist. This clearly
invalidates Algorithm 3 for practical use.
4.1 Our Single-byte Bias Attack
We propose a plaintext-recovery algorithm that takes into
account all possible single-byte RC4 biases at the same
time, along with their strengths. The idea is to ﬁrst obtain
a detailed picture of the distributions of RC4 keystream
bytes Zr, for all positions r, by gathering statistics from
keystreams generated using a large number of indepen-
dent keys (244 in our case). That is, for all r, we (empiri-
cally) estimate
pr,k := Pr(Zr = k),
k = 0x00, . . . ,0xFF ,
where the probability is taken over the random choice
of the RC4 encryption key (i.e., 128 bit keys in the
TLS case). Using these biases pr,k, in a second step,
plaintext can be recovered with optimal accuracy using
a maximum-likelihood approach, as follows.
0xFF) with
Suppose we have S ciphertexts C1, . . . ,CS available
for our attack.
For any ﬁxed position r and any
candidate plaintext byte µ for that position, vector
0x00, . . . ,N (µ)
(N(µ)
N(µ)
k = |{ j | Cj,r = k⊕ µ}1≤ j≤S|
(0x00 ≤ k ≤ 0xFF)
represents the distribution on Zr required to obtain the
observed ciphertexts {Cj,r}1≤ j≤S by encrypting µ. We
USENIX Association  
22nd USENIX Security Symposium  311
7
Algorithm 4: Single-byte bias attack
input : S independent encryptions {Cj}1≤ j≤S of
ﬁxed plaintext P, position r, keystream
distribution (pr,k)0x00≤k≤0xFF at position r
output: estimate P∗r for plaintext byte Pr
begin
N0x00 ← 0, . . . , N0xFF ← 0
for j = 1 to S do
for µ = 0x00 to 0xFF do
NCj,r ← NCj,r + 1
for k = 0x00 to 0xFF do
N(µ)
k ← Nk⊕µ
k=0x00 N(µ)
k
λµ ← ∑0xFF
log pr,k
P∗r ← argmaxµ∈{0x00,...,0xFF} λµ
return P∗r
compare these induced distributions (one for each pos-
sible µ) with the accurate distribution pr,0x00, . . . , pr,0xFF
and interpret a close match as an indication for the cor-
responding plaintext candidate µ being the correct one,
i.e., Pr = µ. More formally, we observe that the proba-
bility λµ that plaintext byte µ is encrypted to ciphertext
bytes {Cj,r}1≤ j≤S follows a multinomial distribution and
can be precisely calculated as
λµ =
S!
N(µ)
0x00!···N (µ)
0xFF!
∏
k∈{0x00,...,0xFF}
pN(µ)
k
r,k
.
(1)
By computing λµ for all 0x00 ≤ µ ≤ 0xFF and identify-
ing µ such that λµ is largest, we determine the (optimal)
maximum-likelihood plaintext byte value. Algorithm 4
speciﬁes the details of the described single-byte bias at-
tack, including the optimizations discussed next.
Observe that, for each ﬁxed position r and set of
ciphertexts {Cj,r}1≤ j≤S, values N(µ)
can be computed
from values N(µ(cid:23))
by equation N(µ)
k⊕µ(cid:23)⊕µ, for
In other words, vectors (N(µ)
0xFF) and
all k.
(N(µ(cid:23))
0xFF) are permutations of each other; by
consequence, term S!/(N(µ)
0xFF!) in equation (1)
can safely be ignored when determining the largest λµ.
Furthermore, computing and comparing log(λµ ) instead
of λµ makes the computation slightly more efﬁcient.
k = N(µ(cid:23))
0x00, . . . ,N (µ)
0x00!···N (µ)
0x00, . . . ,N (µ(cid:23))
k
k
4.2 Our Double-byte Bias Attack
As we have seen, Algorithm 4 allows the recovery of the
initial 256 bytes of plaintext when multiple encryptions
under different keys are observed by the attacker. In the
following, we describe an algorithm which allows the re-
covery of plaintext bytes at any position in the plaintext.
8
Furthermore, the algorithm does not require the plain-
text to be encrypted under many different keys but works
equally well for plaintexts repeatedly encrypted under a
single key.
Our algorithm is based on biases in the distribution of
consecutive bytes (Zr,Zr+1) of the RC4 keystream that
occur as long term biases, i.e., that appear periodically
at regular intervals in the keystream. As described in
Section 3, we empirically measured the biases which are
repeated with a period of 256 bytes. However, in 250 ex-
perimentally generated keystream bytes we observed no
signiﬁcant new biases besides those already identiﬁed by
Fluhrer and McGrew [12]; for the purpose of construct-
ing our algorithm, we hence use the biases described in
Table 1 and assume that all other consecutive byte pairs
are equally likely to appear in the keystream. In other
words, we assume that we have accurate estimates pr,k1,k2
such that
pr,k1,k2 = Pr[(Zr,Zr+1) = (k1,k2)]
for 1 ≤ r ≤ 256 and 0x00 ≤ k1,k2 ≤ 0xFF, where the
probability is taken over all possible conﬁgurations of
the internal state S and the index j of the RC4 keystream
generation algorithm.9 Note that, since these proba-
bilities express biases that are repeated with a period
of 256 bytes, we have pr,k1,k2 = p(r mod 256),k1,k2 for all
r,k1,k2.
Let L be an integer multiple of 256. In the following
description of our plaintext recovery algorithm, we as-
sume that a ﬁxed L-byte plaintext P = P1||···||PL is en-
crypted repeatedly under a single key, i.e., we consider a
ciphertext C obtained by encrypting P||···||P. (In fact, it
is sufﬁcient for our attack that the target plaintext bytes
form a subsequence of consecutive bytes that are con-
stant across blocks of L bytes.) Let Cj denote the sub-
string of C corresponding to the encryption of the j-th
copy of P, and let Cj,r denote the r-th byte of Cj (i.e.,
Cj,r corresponds to byte ( j− 1)· L + r of C).
Given this setting, it seems reasonable to take an ap-
proach towards plaintext recovery similar to that of Al-
gorithm 4: for each position r, the most likely plaintext
pair (µr, µr+1) could be computed from the ciphertext
bytes {(Cj,r,Cj,r+1)}1≤ j≤S and the probability estimates
{pr,k1,k2}0x00≤k1,k2≤0xFF. In other words, a plaintext can-
didate would be obtained by splitting ciphertexts C into
byte pairs and individually computing the most likely
corresponding plaintext pairs.
However, by considering overlapping byte pairs, it is
possible to construct a more accurate estimate of the like-
lihood of a plaintext candidate being correct than by just
considering the likelihood of individual byte-pairs. More
speciﬁcally, for any plaintext candidate P(cid:23) = µ1||···||µL
we compute an estimated likelihood λP(cid:23) = λµ1||···||µL for
312  22nd USENIX Security Symposium 
USENIX Association
(cid:31)=2 δµ(cid:31)|µ(cid:31)−1.
((cid:31) ≤ L),
P(cid:31) being correct via the recursion
λµ1||···||µ(cid:31)−1||µ(cid:31) = δµ(cid:31)|µ(cid:31)−1 · λµ1||···||µ(cid:31)−1
(2)
where δµ(cid:31)|µ(cid:31)−1 denotes the probability that P(cid:31) = µ(cid:31)
assuming P(cid:31)−1 = µ(cid:31)−1, and λµ1||···||µ(cid:31)−1
is the esti-
mated likelihood of µ1||···||µ(cid:31)−1 being the correct