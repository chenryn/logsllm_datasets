0x00000000不再触发内存访问异常，但是因为if判断中uDraggingIndex cItems=0
不成立，导致返回pItem=0。我们需要控制程序流程走到红框分支，返回可控数据：
由于零页内存可控，考虑设置[0x00000020]=0xffffffff：
再次运行利用程序，控制流程进入if分支：
这次uDraggingIndex cItems=0xffffffff 成立，进入if成立分支，并注意到函数返回值eax =
uDraggingIndex * 0x6c +
[0x00000034]，其中[0x00000034]可控。如果uDraggingIndex的值也可以泄露的话，MNGetpItem函数的返回值就用户态可控。
继续执行，返回xxxMNUpdateDraggingInfo函数：
继续向后寻找，下面一处函数调用是xxxMNSetGapState，注意到xxxMNSetGapState函数中存在位修改操作：
幸运的是，这里再次出现了之前分析的MNGetpItem函数，并且MNGetpItem函数的第一个参数就是从用户态返回的tagPOPUPMENU，其属性spmenu正指向零页内存，用户态可控。而根据之前对MNGetpItem函数返回值的分析知道，返回值eax
= (uDraggingIndex – 1) * 0x6c +
[0x00000034]，其中[0x00000034]可控，uDraggingIndex可以从tagMSG的wParam取到，因此MNGetpItem函数返回的pItem值用户态可控。从而可以通过pItem->fState
|= 0x40000000u 实现指定地址的值修改为与0x40000000或的功能，计算过程如下（addressToWrite表示写入地址）：
  1. pItem = eax = (uDraggingIndex – 1) * 0x6c + [0x00000034]
  2. [pItem->fState] = [eax + 0x4] = [(uDraggingIndex – 1) * 0x6c + [0x00000034] + 0x4] |= 0x40000000
  3. [addressToWrite] = [(uDraggingIndex – 1) * 0x6c + [0x00000034] + 0x4] |= 0x40000000
  4. [0x00000034] = addressToWrite – (uDraggingIndex – 1) * 0x6c – 0x4
这里addressToWrite就是期望写入的地址，首先设置为0，查看是否可以利用漏洞修改成功：
动态调试发现，未进入xxxMNSetGapState函数前就发生了内存访问异常，静态分析这段代码：
因此这里需要将[0x0000004c]*0x6C + [0x00000034] +
0x28地址指向的稳定可读写的内存区域，Exodus的exp中选择了零页内存0x180附近的地址，并设置其值为0xF0F0F0F0从而进入pMENUSTATE_->uDraggingFlags
= 1的else分支：
再次调试，成功步过之前的crash点，最终将0x00000000的值修改为0x40000000
这样，我们就实现了指定地址值的有限修改功能。
## 0x2 窗口对象喷射
那么获得了指定地址值的修改功能后，如何进一步利用呢？Exodus的blog中选择了窗口对象喷射：
简单的说就是通过创建大量窗口对象tagWND，寻找到两个相近的tagWND。因为tagWND+0x90->cbwndExtra表示窗口附加数据长度（tagWND+0xB0开始），从而可以通过漏洞修改第一个窗口的cbwndExtra
=
0x40000000实现第一个窗口附加数据越界读写功能。而第一个窗口对象附加数据越界读写目标是修改第二个窗口对象的strName.Buffer指针，从而通过设置第二个窗口的strName实现指定地址数据修改功能。
窗口对象喷射有一个需要解决的问题是如何在用户态泄露内核态窗口对象指针。user32!HMValidateHandle可以用来泄露内核对象地址，user32!
HMValidateHandle用来返回窗口句柄的THRDESKHEAD结构体，而THRDESKHEAD.pSelf属性保存了该句柄的内核对象地址：
但是user32!HMValidateHandle并未导出，因此需要借助其他导出函数寻找，这里选择的是user32! IsMenu：
IsMenu间接调用函数HMValidateHandle。查找HMValidateHandle函数地址代码如下：
得到HMValidateHandle函数地址后，就可以进行窗口喷射，找到满足要求的两个相近窗口对象，窗口喷射部分代码说明：
## 0x3 内核态Shellcode执行
通过窗口对象喷射，我们得到两个相邻的窗口对象，并可以利用漏洞修改第一个窗口对象的cbwndExtra实现第一个窗口对象附加数据越界读写功能。我们最终的目的是在内核态执行用户态的shellcode，窗口对象tagWND.
bServerSideWindowProc标志位可以帮助实现此功能。如果tagWND. bServerSideWindowProc
被置位则窗口过程函数直接在内核上下文执行，而通过之前的窗口喷射我们已经可以通过第一个窗口的附加数据越界修改第二个窗口的strName.Buffer字段，通过将第二个窗口的strName.Buffer指向第二个窗口的bServerSideWindowProc，最终可以利用第二个窗口strName修改第二个窗口对象的bServerSideWindowProc标志位：
通过漏洞修改第二个窗口对象tagWND. bServerSideWindowProc 标志位后，就可以直接在内核态执行用户态shellcode：
注意这里和一般内核提权替换token利用方法稍有不同的是，这里首先清空了进程的Job对象指针，这是因为在Chrome的渲染进程中，即使shellcode替换了system进程的token，当前进程的token依然会继承自Job对象，并且Job不允许Chrome渲染进程产生新进程，因此需要先清空当前进程的Job对象指针：
修改tagWND. bServerSideWindowProc标志位的部分代码说明如下：
Shellcode执行成功后，当前进程提升为system权限，最后可以通过WinExec(“cmd.exe”, 1);
创建一个system权限的cmd。动态调试过程：
窗口对象喷射后，找到满足条件的两个相邻窗口对象：
触发漏洞后，第一个窗口的cbwndExtra被修改为0x40000000:
通过第一个窗口cbwndExtra越界修改第二个窗口的strName.Buffer，将其指向第二个窗口的bServerSideWindowProc标志位:
通过SetWindowTextA(hSecondaryWindow, “\x06”)修改第二个窗口的bServerSideWindowProc标志位:
最后执行shellcode，成功替换system进程token，实现提权：
## 0x4 Chrome执行dll
在完成了内核提权exp后，接下来需要考虑如何结合Chrome渲染进程的漏洞实现沙箱逃逸。首先可以考虑将内核提权exp以dll的形式编译，然后加载到目标进程，执行提权操作。但是由于Chrome渲染进程运行在Untrusted权限，无法直接利用漏洞获取shellcode执行权限后注入提权dll，需要考虑其他方法。
反射型dll注入就是一个比较好的方法，github中有相关项目可以直接使用：
以一个简单的dll程序为例：
vs编译选择最大优化并选择/MT模式生成payload.dll。使用sRDI的python模块生成bin文件：
再通过python脚本转换为js，替换CVE-2019-5768里的shellcode，关闭sandbox可以看到dll被成功执行：
同样方法编译CVE-2019-0808的exp，可以实现沙箱逃逸，完整的利用代码可以参考Exodus的github。感兴趣的同学可以自行尝试。
## 0x5 参考文献
  1. 
  2. /
  3. 
  4. 
  5. 
  6. 