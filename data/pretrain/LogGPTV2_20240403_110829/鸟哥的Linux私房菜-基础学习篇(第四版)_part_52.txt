选项与参数：
-n ：后面接数字，代表显示几行的意思
-f ：表示持续侦测后面所接的文件名，要等到按下[ctrl]-c才会结束tail的侦测
[root@study ~]# tail /etc/man_db.conf
# 默认的情况中，显示最后的十行！若要显示最后的 20 行，就得要这样：
[root@study ~]# tail -n 20 /etc/man_db.conf
范例一：如果不知道/etc/man_db.conf有几行，却只想列出100行以后的数据时？
[root@study ~]# tail -n +100 /etc/man_db.conf
范例二：持续侦测/var/log/messages的内容
[root@study ~]# tail -f /var/log/messages
 \0 001 \0 \0 \0 364 3 \0 \0 \0 \0 \0 \0
0000040 @ \0 \0 \0 \0 \0 \0 \0 x e \0 \0 \0 \0 \0 \0
0000060 \0 \0 \0 \0 @ \0 8 \0 \t \0 @ \0 035 \0 034 \0
0000100 006 \0 \0 \0 005 \0 \0 \0 @ \0 \0 \0 \0 \0 \0 \0
.....（后面省略）....
# 最左边第一栏是以 8 进位来表示Bytes数。以上面范例来说，第二栏0000020代表开头是
# 第 16 个 byes （2x8） 的内容之意。
范例二：请将/etc/issue这个文件的内容以8进位列出储存值与ASCII的对照表
[root@study ~]# od -t oCc /etc/issue
0000000 134 123 012 113 145 162 156 145 154 040 134 162 040 157 156 040
\ S \n K e r n e l \ r o n
0000020 141 156 040 134 155 012 012
a n \ m \n \n
0000027
# 如上所示，可以发现每个字符可以对应到的数值为何！要注意的是，该数值是 8 进位喔！
# 例如 S 对应的记录数值为 123 ，转成十进制：1x8^2+2x8+3=83。
利用这个指令，可以将 data file 或者是 binary file 的内容数据给他读出来喔！ 虽然读出的来数值默认是使用非文本文件，亦即是 16 进
位的数值来显示的， 不过，我们还是可以通过 -t c 的选项与参数来将数据内的字符以 ASCII 类型的字符来显示， 虽然对于一般使用者来说，这
个指令的用处可能不大，但是对于工程师来说， 这个指令可以将 binary file 的内容作一个大致的输出，他们可以看得出东西的啦～ ^_^
如果对纯文本文件使用这个指令，你甚至可以发现到 ASCII 与字符的对照表！非常有趣！ 例如上述的范例二，你可以发现到每个英文字
S 对照到的数字都是 123，转成十进制你就能够发现那是 83 啰！ 如果你有任何程序语言的书，拿出来对照一下 ASCII 的对照表，就能够发现
真是正确啊！呵呵！
例题：
我不想找 google，想要立刻找到 password 这几个字的 ASCII 对照，该如何通过 od 来判断？
答：
其实可以通过刚刚上一个小节谈到的管线命令来处理！如下所示：
echo password | od -t oCc
echo 可以在屏幕上面显示任何信息，而这个信息不由屏幕输出，而是传给 od 去继续处理！就可以得到 ASCII code 对照啰！
我们在 ls 这个指令的介绍时，有稍微提到每个文件在linux下面都会记录许多的时间参数， 其实是有三个主要的变动时间，那么三个时
间的意义是什么呢？
modification time （（mtime））：
当该文件的“内容数据”变更时，就会更新这个时间！内容数据指的是文件的内容，而不是文件的属性或权限喔！
status time （（ctime））：
当该文件的“状态 （status）”改变时，就会更新这个时间，举例来说，像是权限与属性被更改了，都会更新这个时间啊。
access time （（atime））：
当“该文件的内容被取用”时，就会更新这个读取时间 （access）。举例来说，我们使用 cat 去读取 /etc/man_db.conf ， 就会更新该文件
的 atime 了。
这是个挺有趣的现象，举例来说，我们来看一看你自己的 /etc/man_db.conf 这个文件的时间吧！
[root@study ~]# date; ls -l /etc/man_db.conf ; ls -l --time=atime /etc/man_db.conf ; \
> ls -l --time=ctime /etc/man_db.conf # 这两行其实是同一行喔！用分号隔开
Tue Jun 16 00:43:17 CST 2015 # 目前的时间啊！
-rw-r--r--. 1 root root 5171 Jun 10 2014 /etc/man_db.conf # 在 2014/06/10 创建的内容（mtime）
-rw-r--r--. 1 root root 5171 Jun 15 23:46 /etc/man_db.conf # 在 2015/06/15 读取过内容（atime）
-rw-r--r--. 1 root root 5171 May 4 17:54 /etc/man_db.conf # 在 2015/05/04 更新过状态（ctime）
# 为了要让数据输出比较好看，所以鸟哥将三个指令同时依序执行，三个指令中间用分号 （;） 隔开即可。
看到了吗？在默认的情况下，ls 显示出来的是该文件的 mtime ，也就是这个文件的内容上次被更动的时间。 至于鸟哥的系统是在 5 月 4
号的时候安装的，因此，这个文件被产生导致状态被更动的时间就回溯到那个时间点了（ctime）！ 而还记得刚刚我们使用的范例当中，有使
用到man_db.conf这个文件啊，所以啊，他的 atime 就会变成刚刚使用的时间了！
文件的时间是很重要的，因为，如果文件的时间误判的话，可能会造成某些程序无法顺利的运行。 OK！那么万一我发现了一个文件来
自未来，该如何让该文件的时间变成“现在”的时刻呢？ 很简单啊！就用“touch”这个指令即可！
Tips
嘿嘿！不要怀疑系统时间会“来自未来”喔！很多时候会有这个问题的！举例来说在安装过后系统时间可能会被改变！ 因为台湾时区在国际标准
时间“格林威治时间, GMT”的右边，所以会比较早看到阳光，也就是说，台湾时间比GMT时间快了八小时！ 如果安装行为不当，我们的系统可能会有八小时
快转，你的文件就有可能来自八小时后了。
至于某些情况下，由于BIOS的设置错误，导致系统时间跑到未来时间，并且你又创建了某些文件。 等你将时间改回正确的时间时，该文件不就变成来自未来
了？^_^
[root@study ~]# touch [-acdmt] 文文件件
选项与参数：
-a ：仅修订 access time；
-c ：仅修改文件的时间，若该文件不存在则不创建新文件；
-d ：后面可以接欲修订的日期而不用目前的日期，也可以使用 --date="日期或时间"
-m ：仅修改 mtime ；
-t ：后面可以接欲修订的时间而不用目前的时间，格式为[YYYYMMDDhhmm]
范例一：新建一个空的文件并观察时间
[dmtsai@study ~]# cd /tmp
[dmtsai@study tmp]# touch testtouch
[dmtsai@study tmp]# ls -l testtouch
-rw-rw-r--. 1 dmtsai dmtsai 0 Jun 16 00:45 testtouch
# 注意到，这个文件的大小是 0 呢！在默认的状态下，如果 touch 后面有接文件，
# 则该文件的三个时间 （atime/ctime/mtime） 都会更新为目前的时间。若该文件不存在，
# 则会主动的创建一个新的空的文件喔！例如上面这个例子！
范例二：将 ~/.bashrc 复制成为 bashrc，假设复制完全的属性，检查其日期
[dmtsai@study tmp]# cp -a ~/.bashrc bashrc
[dmtsai@study tmp]# date; ll bashrc; ll --time=atime bashrc; ll --time=ctime bashrc
Tue Jun 16 00:49:24 CST 2015 <==这是目前的时间
-rw-r--r--. 1 dmtsai dmtsai 231 Mar 6 06:06 bashrc <==这是 mtime
-rw-r--r--. 1 dmtsai dmtsai 231 Jun 15 23:44 bashrc <==这是 atime
-rw-r--r--. 1 dmtsai dmtsai 231 Jun 16 00:47 bashrc <==这是 ctime
在上面这个案例当中我们使用了“ll”这个指令（两个英文L的小写），这个指令其实就是“ls -l”的意思， ll本身不存在，是被“做出来”的一个
命令别名。相关的命令别名我们会在bash章节当中详谈的，这里先知道ll="ls -l"即可。 至于分号“ ; ”则代表连续指令的下达啦！你可以在一行指
令当中写入多重指令， 这些指令可以“依序”执行。由上面的指令我们会知道ll那一行有三个指令被下达在同一行中。
至于执行的结果当中，我们可以发现数据的内容与属性是被复制过来的，因此文件内容时间（mtime）与原本文件相同。 但是由于这个
文件是刚刚被创建的，因此状态（ctime）就变成现在的时间啦！那如果你想要变更这个文件的时间呢？可以这样做：
范例三：修改案例二的 bashrc 文件，将日期调整为两天前