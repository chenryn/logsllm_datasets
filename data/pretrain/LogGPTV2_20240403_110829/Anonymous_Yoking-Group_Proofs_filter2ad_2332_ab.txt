i, Ti, i),
and then it deletes init(s(cid:48)
build(s(cid:48)
link(s(cid:48)
k, Tk, k).
i, Ti, i), records and outputs link(s(cid:48)
k) at tag Tk:
i, s(cid:48)
i, Ti, i).
j , s(cid:48)
link(s(cid:48)
If there
k, Tk, k),
k, Tk, k), records and outputs
j , Tj , j),
init(s(cid:48)
Upon receiving input Impersonate(s, s(cid:48)
init(s, R), init(s(cid:48)
versary, and then it records and outputs proof(s, s(cid:48)
where ps(cid:48)
i, Tj ): If there are records
i, Ti) and Tj is a tag controlled by an ad-
j ),
j is a pseudo-subsession.
i, ps(cid:48)
Upon receiving input Verify(proof) at veriﬁer: If there exists a
j )= proof, and then it outputs valid,
i, s(cid:48)
record proof(cid:48)(s, s(cid:48)
otherwise invalid.
Figure 1: Fayp for anonymous yoking-proof.
• A can corrupt at most n − 1 tags where n is the num-
ber of tags. In this case, the anonymity of compromised
tags are ignored. Note that the corrupted tags are not
destructive that they can be involved in the future com-
munications.
• A is allowed to interact with both tags and a reader in
any order and messages can be altered by A in some
manners.
The universal composability (UC) framework [7] supports
composable security even in complex systems. Most RFID
applications are assumed to be deployed in a large and scal-
able system, thus we apply the UC model to analyze pro-
posed protocols. In UC framework, it introduces models in
ideal world which expresses robust protocol execution and
real world where a probabilistic polynomial time (PPT) ad-
versary is allowed to control adversarial parties and arranges
the order of activation for parties. In the UC model, it de-
ﬁnes a simulator S which emulates the real protocol ρ exe-
cution and translates runs of ρ with real world adversary A
into runs of ρ which is executed by ideal functionality F with
ideal world adversary (cid:98)A. An adversary of UC model in both
collected are from F and (cid:98)A or from ρ and A. To analyze
ideal world and real world shall interact with a PPT called
environment Z which distinguishes whether the interactions
the security of a protocol ρ, we say that ρ UC-realizes F if
there is no Z can distinguish between ideal and real world
with non-negligible probability.
In UC framework, a protocol execution is captured by a
session identiﬁer sid which is created by Z. In each protocol
run, all parties use the same sid and any input/output of
the protocol is represented associated with sid. We describe
parties and sessions involved in the protocol execution for
both of proposed protocols as follows.
Upon receiving input Build(s(cid:48)
ists four records link(s(cid:48)
and init(s(cid:48)
puts build(s(cid:48)
z, s(cid:48)
k, Tk, k), it deletes init(s(cid:48)
i, s(cid:48)
i, Ti, i), link(s(cid:48)
j , s(cid:48)
k, Tk, k).
j , Tj , j), init(s(cid:48)
k) at tag Tk: If there ex-
z, Tz, z)
k, Tk, k), records and out-
Upon receiving input Prove(s, {s(cid:48)
m}), where m ≥ 1:
i ∈ {s(cid:48)
i, Ti, i), then it records proof(s, {s(cid:48)
is a record init(s, R);
build(s(cid:48)
build records and outputs proof.
for all s(cid:48)
If there
m}, there exists
m}), deletes all
Upon receiving input Impersonate(s, {s(cid:48)
j}, Tj ): If there is
j} and Tj is a
a record init(s, R); for all s(cid:48)
tag controlled by an adversary, then it records and out-
puts proof(s, ({s(cid:48)
j is a pseudo-
subsession.
m} \ {s(cid:48)
j}), where ps(cid:48)
j})∪{ps(cid:48)
m} \ {s(cid:48)
m}\{s(cid:48)
i ∈ {s(cid:48)
Upon receiving input Verify(proof) at veriﬁer: If there exists a
m})= proof, and then it outputs valid,
record proof(cid:48)(s, {s(cid:48)
otherwise invalid.
Figure 2: Faygp for anonymous yoking-group proof
Sessions. The entire life-time of a protocol is represented
by a single session. For each session sid, it consists of multi-
ple subsessions which are initiated by protocol parties. Par-
ticularly, a unique subsession identiﬁer ssid is assigned when
a protocol party receives an input Initiate from Z. Note that
all parities in diﬀerent subsessions share the same sid.
Parties. There are three types of parties: tag, reader and
veriﬁer. In each subsession ssid, there are arbitrarily many
of tags that diﬀerent instances of type tag are allowed. How-
ever, there is only one instance type of reader in a subsession.
As UC entities, such as Z and A, are not parties of a pro-
tocol, an adversary is allowed to control multiple protocol
parties.
Yoking-proof. A successful yoking proof in the real
world implies that the output of each tag contains the other
tag’s input which is generated by a piece of secret. An adver-
sary is entitled to fully control the network and can selects
involved partners. In the ideal world, the protocol execution
is emulated by the calls of Link and Prove activities.
Yoking-group proof. A successful yoking-group proof
in the real world implies that yoking proof of each pair of
child nodes is successful, correctness of group secret recon-
struction and the output of one group involves the secrets of
another group. As above, the adversary can choose partici-
pating partners and control the network. In the ideal world,
the protocol execution is emulated by the calls of Link, Build
and Prove activities.
617Tag Tl (Kl
I , Kl
A)
$←− {0, 1}k, σl = Kl
bl
∆l = H(bl||a)
A ⊕ bl
“lef t proof ”, a
←−−−−−−−−−−
−−−−−−−−−−→
σl,∆l
Reader R
a $←− {0, 1}k
“right proof ”, a
−−−−−−−−−−→
←−−−−−−−−−− br
σr ,∆r
Tag Tr (Kr
I , Kr
A)
$←− {0, 1}k, σr = Kr
A ⊕ br
∆r = H(br||a)
ml = bl||σr||∆r, σ(cid:48)
l = Kl
I ⊕ H(ml)
σr ,∆r
←−−−−−−−−−−
−−−−−−−−−−→Σ = (a, σl, σ(cid:48)
σ(cid:48)
l
l, ∆l, σr, σ(cid:48)
r, ∆r)
−−−−−−−−−−→
←−−−−−−−−−− mr = br||σl||∆l, σ(cid:48)
σl ,∆l
σ(cid:48)
r
r = Kr
I ⊕ H(mr)
Figure 3: Anonymous yoking-proof protocol.
Anonymity.
In the ideal functionality Fayp of anony-
mous yoking proof, it only leaks a party’s type information
which is “tag” or “reader”. In the ideal functionality Faygp
of anonymous yoking-group proof, it discloses the type in-
formation of involved parties as well as the index when the
party is type tag. Note that an index of a tag indicates the
position of a tag in a group other than the identity of a tag.
Clearly, tags and readers are distinguishable as they proceed
distinct tasks. We respectively depict the ideal functionality
Fayp of anonymous yoking proof and the ideal functional-
ity Faygp of anonymous yoking-group proof in Figure 1 and
Figure 2.
4. BUILDING BLOCK
A novel anonymous yoking-proof protocol is proposed in
this section. It is an essential building block of our yoking-
group proofs described in Section 5. The proposed yoking-
proof is a lightweight symmetric key based protocol which
only requires one hash computation to each tag. The un-
trusted third party who controls the reader has an obliga-
tion to ensure the sequence of interactions and collects re-
sponses of tags without obtaining any privacy of target tags.
Then, it compiles the proof and submits it to the veriﬁer who
is referred to a trusted third party. During the reader-tag
communication, the trusted third party is unnecessary to be
online and all proofs can be veriﬁed latter.
Our protocol is described as in Figure 3 that any two legit-
imate tags are eligible to be presented in the proof. For each
tag, the TTP stores two keys in its non-volatile memory,
namely identiﬁcation key KI and authentication key KA,
such that KI , KA ∈ K, where K is the deﬁned key space.
Firstly, the reader randomly chooses a ∈ {0, 1}k, where k is
a security parameter, and sends a as a challenge to both of
tags Tl and Tr. Upon receiving the challenge, Tl selects a
random number bl ∈ {0, 1}k and computes (σl, ∆l) that bl
is considered as an ephemeral key to protect the authentica-
tion key K l
A. The tag Tr executes the same as Tl and sends
challenge (σr, ∆r) to the reader. Then, the reader swaps two
responses and sends (σr, ∆r), (σl, ∆l) to Tl, Tr, respectively.
Upon receiving the challenge, the tag generates a message m
and encrypts the message by using the identiﬁcation key KI .
At last, the reader compiles the responses received from two
tags and generates a yoking proof Σ. To verify the proof,
the veriﬁer who maintains pairs of keys (KA, KI ) searches
pairs (K l
I ) and checks the proof as
I ) and (K r
A, K r
A, K l
?= H(σl ⊕ K l
A||a), σ
(cid:48)
l
∆l
?= H(σr ⊕ K r
A||a), σ
(cid:48)
r
∆r
?= K l
I ⊕ H(σl ⊕ K l
A||σr||∆r),
?= K r
I ⊕ H(σr ⊕ K r
A||σl||∆l),
where H : {0, 1}∗ → {0, 1}k is a cryptographic collision-
resistant hash function. We assume that each tag Ti is
assigned a distinct key pair (K i
I ) which indicates its
unique identity in the database and only the veriﬁer can
reveal the keys.
A, K i
The proposed protocol also employs the timeout mech-
anism which guarantees the interaction is completed in a
small period of time. The tag and reader abort the pro-
tocol if the response received later than the deﬁned time
window. To simplify the description, we assume that there
is a timeout for each round where the recipient is awaiting
any response. For the rest of this paper, we will adopt the
same deﬁnition.
5. PROPOSED PROTOCOL
In this section, we demonstrate an anonymous yoking-
group proof protocol which allows an untrusted third party
to prove that two groups of tags have been scanned simulta-
neously. Intuitively, the protocol guarantees plenty of tags
have been presented during the protocol run. However, the
further requirement of the protocol is that the veriﬁer needs
to identify which groups of tags have been scanned other
than the validity of tags. The proposed protocol is based on
the building block introduced in Section 4. Although a tag
may handle more computations during the authentication,
the minimum computational cost remains the same as in our
yoking-proof protocol. In addition, the computational cost
to the veriﬁer is irrelevant to the number of tags.
5.1 Anonymous Yoking-group Proof
An anonymous yoking-group protocol is described as in
two phases: the grouping phase and the yoking phase. To
show the presence of distinct groups, a reader ﬁrstly requests
tags to generate a grouping-proof and then yokes groups to
generate a yoking-proof. We call the proof created by the
protocol as a yoking-group proof ΣG.
In some previous grouping-proof protocols, the tags are ar-
ranged in a speciﬁc logical structure. For instance, Burmester
and Munilla [6] assume that a group of tags form a logical
ring and the tags are labelled from 1 to n, where n is the
quantity of tags. Some other protocols [2, 20] also consider a
group of tags as a ring or a chain during the authentication.
They also consecutively assign each tag a distinct number.
Usually, the protocols which apply symmetric-key cryptog-