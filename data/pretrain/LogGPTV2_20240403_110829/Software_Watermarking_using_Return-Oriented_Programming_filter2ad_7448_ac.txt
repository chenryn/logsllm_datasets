3.6 Triggering ROP via function pointer
overwriting
Now that the watermarking payload is chained up for exe-
cution. The last missing piece in the ROP-based watermark-
ing is to instantiate the execution of the hidden watermark-
ing path. This involves transitioning from normal execution
of the program to ROP execution of the pre-selected gad-
gets, and we don’t want instructions that perform such a
transition to look suspicious.
We use a function pointer for triggering the ROP execu-
tion. The reason of this design choice is because a function
pointer not only allows control transfer to the ROP gadgets
via a simple overwriting of its value, but also provides a nat-
ural way of loading the initiating stub of the watermarking
payload (given in the example in Section 3.2) directly onto
the stack as function parameters. Usually this watermark-
ing trigger points to a dummy function we added to the
program so that in normal execution the trigger calls the
dummy function and performs computations that do not
 class gadC { Private:         int var_1;         int var_2; Public:         gadC (int init_1, int init_2)         {                   var_1 = init_1;                   var_2 = init_2;         }    …  } …  gadC *gad = new gadC(addr, X) ; …  …  Int *gad = new int[2]; gad[0] = addr;  gad[1] = X;  …  struct gadS {       int var_1, var_2; } …  gadS *gad = new gadS ;  gad.var_1 = addr;   gad.var_2 = X;  … watermarking payload watermarking payload addr(addres of gadget )X(operand of the gadget)heap regionsomewhere in the codegadgetspop esp; retPkgadgetsPk+1gadgets???payload segmentPk-1payload segmentPkpayload segmentPk+1pop esp; retpop esp; ret3.7
Implementation
Our ROP-based watermarking toolkit is implemented in
a set of python scripts consisting of a gadget scanner, a trace
processor and a code re-writer, as shown in Figure 6.
Figure 6: Implementation of ROP-based watermarking
Gadget scanner analyzes the system libraries, selects avail-
able gadgets of the four types given in Section 3.3 and creates
a gadget database. It also generates the ROP payload that
chains the candidate gadgets into the watermarking code.
Meanwhile, the trace processor analyzes the execution
traces of the subject program under the secret input to ﬁnd
available carriers for watermarking payload. It not only ﬁnds
the entry points of carriers but also records which parts of
them are executed in the given trace.
After these preparations, code re-writer modiﬁes the pro-
gram’s source code to embed the watermark. First, it divides
the payload provided by the gadget scanner into segments
and generates code for building and linking them. Follow-
ing that, it distributes these code into the carriers, and also
plants the dummy function as well as the ROP trigger. Fi-
nally, the modiﬁed source code is re-compiled, resulting the
watermarked program.
Secret trace analysis is a tricky part of the watermarking
since the analyzer only records execution on binary level
while the watermark is embedded to the source code. To ﬁll
this gap, our trace processor consists of a code marker and
a trace analyzer.
First, code marker makes a special copy of the program’s
source code by marking entry points and end points of func-
tions as well as conditional code blocks in them with inef-
fective inline assembly sequences (which we called tags). We
format these tags so that they are not only easy to be rec-
ognized, but also tell the exact locations in the correspond-
ing source ﬁles they are assigned to. In particular, we let
each tag to be started and ended with a 
instruction, which never occurs in regular binaries. Addi-
tionally, a global junk variable is added in the program,
with each tag carrying instructions that write the ﬁle ID
and line number of the marked position in sequence to this
junk variable. consequently, the resulting executable from
the marked source is run with the secret trace recorded, and
the trace analyzer can simply search for the inserted tags to
ﬁgure out exactly which part of the source code is executed.
The trace processor is implemented as a total of 207 lines
of scripts, in which the code marker takes 135 lines and the
trace analyzer takes 72 lines. Code re-writer script consists
of 191 lines due to the need of generating code for payload
preparation in addition to scanning and re-writing source
ﬁles. Gadget scanner is extended from GALILEO [27], an
existing gadget searching algorithm.
4. EVALUATION
In this section, we subject our ROP-based watermarking
to a number of security analyses and present the results. We
also measure the static and dynamic overhead.
Security of software watermarking is usually evaluated in
terms of the stealth, credibility, and resilience. Stealth typ-
ically refers to how well the watermark blends in the code
or data around it; credibility describes how precisely the
watermark can be retrieved; while resilience measures the
resistance against determined attempts at discovery or re-
moval. ROP-based watermarking extracts a watermark as a
direct result of executing the embedded ROP gadgets; thus
its credibility is quite self-evident. Therefore, in this section,
we mainly focus on analyzing stealth and resilience of our
approach. Meanwhile, the overhead caused by applying the
ROP-based watermarking is also evaluated on three aspects
– time it takes to generate the watermark, increment in code
size, and the additional heap space required.
We apply our scheme on a number of subject programs
from the SPECint-2006 test suite which are subject pro-
grams that previous research chose to work with [23]. The
experimental watermarking is designed to simply output a
watermark message on the screen. All tests were run on a
PC with a 2.66GHz Intel Core 2 Quad CPU, 4GB memory,
and Windows 7 operating system.
4.1 Static stealth
Static stealth of software watermarking measures how well
a watermark ﬁts into the program around it. As mentioned
in Section 3, the ROP-based watermarking needs to insert
a small amount of code into the program for constructing
its payload. Therefore, static stealth plays an important
role in evaluating our design. The good news is that code
introduced by our ROP-based watermarking is only for cre-
ating and updating the payload segments which appear to
be program data.
It is broken down to instruction level
and distributed over many carriers in the program (see Sec-
tion 3.4). Considering the diversity of such code as also
discussed in Section 3.4, we expect that ROP-based water-
marking presents good static stealth in this measurement.
We adopt the static stealth measurement introduced by
Collberg et al. [11], brieﬂy described as follows:
• First, given a piece of watermarking code that gener-
ates an x-bit watermark, a dictionary is created as an
instruction level proﬁle. This is done by sweeping a
peephole (of which the size is set to one to three in-
structions as suggested by Collberg et al.) over the
instruction stream of the watermarking code, while
distinct instruction combinations observed in the scan-
ning are added as new words to the dictionary.
• Second, to measure whether the watermarking code is
stealthy in a program, all words in the dictionary are
then searched in the original and watermarked pro-
grams. The more words appearing in them, the better
the watermarking code ﬁts into the program.
Watermarking Toolkitsystem librariesprogram source codewatermarked programgadget scannercode re-writertrace processorcode markertrace analyzerdynamic trace analyzer(a) bzip2
(b) hmmer
(c) lbm
(d) mcf
(e) sjeng
(f) soplex
Figure 8: Locality evaluation on static stealth
(200 instructions in our experiment, since the watermarking
code itself only has 271 instructions in total) over the pro-
grams’ instruction stream. Again, we look for words from
the dictionary when running the sliding window, one step
to the right when the number of words found is below a
threshold, or 200 steps to the right otherwise to avoid dou-
ble counting. Locations where the number of words found
exceeds the threshold are considered “hotspots” that have
similar proﬁle compared to the watermarking code, and will
be marked as suspicious. Figure 8 shows the result where
the horizontal axis shows diﬀerent threshold settings and the
vertical axis shows the number of “hotspots” found.
Results are consistent with those from the previous ex-
periment, where few windows in which over 50% coverage
of watermarking dictionary are reported. When comparing
the results for the original and the watermarked programs,
there is no signiﬁcant increase on the number of hotspots.
4.2 Dependence analysis on watermarking
components
In the second analysis on the stealth of the watermark-
ing technique, we assume a more realistic scenario where
the attacker manages to locate one distinguishable compo-
nent used in the watermark, and tries to trace the other
parts of it with dependency analysis to the exposed com-
ponent. Existing watermarking schemes can be vulnerable
on this aspect since certain features used by their external
extractor to recognize watermark may also be exploited by
adversaries, while the connections between their code and
data are directly exposed to analyses.
As an example, we simulate such a dependency analysis
on the CT watermarking technique [10], one representative
watermarking techniques proposed in the literature. In the
simulation, we set the root node of the heap-allocated wa-
termark graph to be static, as if it is recognized already.
IDA pro 6.4 is then used to launch a dependency analysis
starting from the given root node in order to ﬁnd anything
Figure 7: Static stealth of ROP-based watermarking
We apply our ROP-based watermarking on six benchmark
programs bzip2, hmmer, lbm, mcf, sjeng, and soplex to
embed a 192-bit watermark. By analyzing the watermarking
code inserted into the six watermarked program, we identify
a total of 171 words in the dictionary. Figure 7 shows the
number of words in the dictionary that are found in the
original and watermarked programs.
There are two important takeaways from these results.
First, we observe that between 70 and 85 percent of the
words in the dictionary of watermarking code already ex-
ists in the original programs. This shows that most of the
code introduced by our ROP-based watermarking can be
seen in the ordinary program, making it hard for attackers
to look for special instruction sequences that could serve as
signatures for detection. Second, we ﬁnd that even in the
watermarked programs, there are only 72 to 88 percent of
the words in the dictionary being observed. Meanwhile, the
diﬀerences between results on the original programs and the
watermarked programs are pretty small – making the orig-
inal and watermarked programs relatively indistinguishable
in this analysis.
We further extend this experiment to perform a locality
evaluation by running a considerably large sliding window
01020304050607017345168861031201371541710204060801001201401601734516886103120137154171024681012173451688610312013715417102468101214161734516886103120137154171010203040506070809010017345168861031201371541710501001502002503001734516886103120137154171050100150200250300917263443516068778694103111120128137145154162171originalwatermarked020406080100120140160180200bzip2hmmerlbmmcfsjengsoplexoriginalwatermarkeddictionarycontains 171 word in totalthat are semantically connected. Figure 9 shows the analysis
result, where we ﬁnd that based on the exposed root node,
IDA pro is able to detect a dependency graph connecting
all functions that participate in the watermark generation,
making it relatively easy for attackers to narrow down to
speciﬁc functions in searching for the watermarking code.
Figure 9: Dependency analysis result of CT watermarking
In contrast, our ROP-based watermarking payload stay
in the data region of the program, thus from normal per-
spective it has no explicit connection to the corresponding
gadgets, making the watermarking semantics “invisible” to
code analyses (including dependence analysis), i.e. the code
stream in charge of writing the watermark message into pro-
gram’s memory then printing it out literally does not exist
when the embedded ROP is not triggered. For veriﬁcation,
we perform a similar simulation on our design, in which
we intentionally let the watermarking code write the hidden
message in a static character string that can be easily picked
up by a static analyzer, and again look for semantically con-
nected portions from the program. However, IDA pro en-
counters a failure to reach anything that have dependencies
on the exposed string, i.e., it believes that semantically there
is no instruction in the watermarked program that tries to
read or modify the string at all.
To conﬁrm this result, we dynamically execute the water-
marked program and monitor the target string to ﬁnd out
instructions that operate upon it. Figure 10 shows screen-
shots of this dynamic analysis (before and after the exposed
character string is overwritten). We can see that instruc-
tions operating on the target string are actually unintended
instructions from the shared library that are beyond the
scope of the analyzer. This conﬁrms that there is zero de-
pendency found in the watermarked program.
Note that the above simulation is only for demonstrating
the diﬀerence on semantic visibility between our design and
the previous work. In our ROP-based watermarking, we do
not actually use such a static string to store the watermark
message, and therefore the dependency analysis might even
have no ground to begin with.
4.3 Resilience
In this subsection, we discuss the strength of our design
against distortion attacks in which the adversary attempts
to destroy the watermark by twisting the binary of water-
marked program. Common binary obfuscations (including
function and basic block reordering, function inlining and
outlining, data restructuring, etc.) are the main approaches
of distortion attack while program packing and optimizing
are also included in the adversaries’ arsenal.
Intuitively, semantic-preserving transformations do not af-
fect our design because they do not change the way gadgets
are constructed. One possibility, though, is to target param-
eters of the function pointer for triggering ROP execution.
However, the trigger function pointer works via a indirect
call, whose target is hard to be determined at binary level.
Theoretically, a complete distortion on the trigger needs to
locate all indirect calls and modify all their potential targets
including those imported to the program (which are highly
error-prone). This makes the adversary’s task impractical.
We test the resilience of all our watermarked programs
against transformation of a selection of well-known tools:
• xenocode, performs binary-level obfuscation including
encrypting static strings, randomly inserting redun-
dant ineﬀective instructions, and obfuscating program’s
control ﬂow [3];
• UPX, provides high-quality packing and compression
on softwares [2]; and
• LLVM optimizer, enables various source- and target-
independent binary optimizations, some of which per-
form decompilation/recompilation on target code [1].
Results show that after transformations, the watermarked
programs can still correctly generate and chain the water-
marking payload, and the hidden watermarks can still be
correctly extracted. This not only indicates the good re-
silience of our design, but also shows that our ROP-based
watermarking has potentially high compatibility should we
want to combine it with other protection mechanisms.
4.4 Overhead
In this subsection, we evaluate the performance overhead
of our design in comparison with graph-based watermark-
ing. Intuitively, ROP-based watermarking involves far less
overhead in both execution time and heap space because it
does not need to encode the watermark into complex data
structures (e.g., a graph).
In our experiments, we apply the CT watermarking tech-
nique to encode the watermark into radix graphs because
it is widely considered to be the most eﬃcient solution in
graph-based watermarking [11]. All programs involved in
the test are compiled under the same setting, and programs
watermarked with both methods do not have any additional
protection mechanisms integrated. Table 2 shows the result
for runtime overhead, while Figure 11 presents results for
static program size increments.
We ﬁnd that the runtime overhead of a ROP-based wa-
termarked programs is signiﬁcantly smaller than that in the
graph-based one – in some cases more than two orders of
magnitude smaller. Our method also experiences smaller
increase in program size.
We also evaluate the size of heap-allocated data struc-
tures that are constructed for the watermark. Results are
very much identical for all six programs, in which CT water-
marking uses 1,536 bytes of heap space to encode a 192-bit
(a) Before string overwriting
(b) After string overwriting
Figure 10: Unintended instructions that overwrite the watermark string in our design
benchmark
runtime overhead (ms)
ROP-based
watermarking
graph-based
watermarking
bzip2
hmmer