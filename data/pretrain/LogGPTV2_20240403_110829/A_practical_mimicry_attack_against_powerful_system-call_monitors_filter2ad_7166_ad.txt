utilize the operational code to query the number of requests
Apache had processed.
4.1.4 Verifying evasion of an I/O-data-oblivious
monitor
By design, persistent interposition attacks cannot be de-
tected by any IOM. Nevertheless, it would be useful to ex-
perimentally verify this. However, a direct veriﬁcation is not
feasible since the system call monitors available today (or
those that are likely to be available in the future) are weaker
than the most powerful IOMs. Consequently, we need to
rely primarily on manual reasoning based on the deﬁnition
of IOMs to establish that no IOM can detect an persistent
interposition attack. Speciﬁcally, we used the following com-
bination of manual reasoning and experimentation to verify
that the attack presented above won’t be detected by any
IOM.
We used strace to generate logs of the system calls made
by Apache and each of its child processes. First, we started
the Apache server, and used a client to carry out the above
attack, and logged the system calls. We then restarted the
Apache server, and used the same client to send benign re-
quests. We recorded the system calls in this case. These two
steps were repeated several times to obtain multiple logs,
each corresponding to one (benign or attack) run. We then
used diff to compare the strace logs for each run. We ob-
served that across the benign runs, there were small dif-
ferences in the logs, such as the the position of sbrk and
mmap calls (both used for memory allocation), ﬁle descriptor
numbers and process ids. Since this variation is present in
benign runs, an IOM, by deﬁnition, must accept these varia-
tions. We then compared benign runs with attack runs and
veriﬁed that the diﬀerences between the two runs were the
same as those observed between benign runs, or were due to
the data arguments to read and write calls. Thus, an IOM
would accept the attack run as well.
4.2 Implementing Persistent Interposition
Attack on Other Applications
In this section, we consider each of the steps in persistent
interposition attacks, and evaluate the ease with which they
can be implemented. We chose a collection of applications
(rather than a single one) for this evaluation, so that we can
independently evaluate each of the implementation choices
mentioned in Section 3.
4.2.1 Initial Exploit Phase
Storing Bootstrap Code
Several alternatives were discussed in Section 3 for this
step. Of these, the feasibility of storing data in global buﬀers
was already established by the Apache case study. We also
veriﬁed the feasibility of copying attack data into the stack.
We used a test program for this veriﬁcation, but the de-
tails won’t change across applications. Our implementation
pushes data on the stack within a loop, and pops oﬀ this
data. To ensure that the attack code won’t be clobbered
by the victim during its normal operation, the amount of
data pushed should be more than the total of the maximum
stack ever used by the victim and the memory needed by
the attack code. Since our implementation could allocate
hundreds of MBs of space in this manner without triggering
any system calls, we did not pursue storage of attack data
on the heap.
Interposing Bootstrap Code
Our Apache implementation demonstrated the feasibility
of interposing on application-speciﬁc function pointers used
to support module and plug-in functionality.
Interposing
on GOT is perhaps most convenient, since it works reliably
across all applications in practice. We used interposition
on GOT entries for two server programs, namely, bind and
lsh. Interposing on virtual functions (or pointers to virtual
function tables) is also likely to be quite easy. However, we
did not have access to working exploits on real-world C++
applications, and hence didn’t evaluate this choice experi-
mentally.
Cleanup
Three common exploit types are prevalent today: stack-
smashing, heap-overﬂow and format-string attacks. We ob-
tained working exploits for the ﬁrst two types, but could
not ﬁnd a fully-working exploit of a format-string vulnera-
bility. Nevertheless, as described before, the technique for
recovery from a format-string exploit is similar to that of
heap-overﬂow or stack-smashing attack, depending on the
nature of “collateral damage” resulting from a format-string
attack.
Our Apache case-study has already demonstrated the ease
of the clean-up phase on a heap-overﬂow exploit, so we con-
sider stack-smashing exploits here. First, we examined the
trans2open vulnerability in the Samba server. This attack
overﬂows a 1024-byte stack buﬀer, overwriting the return
163
address on the stack frame above that of call trans2open.
We used an available exploit that launches a shell when
trans2open returns to its caller. As with any stack-smashing
attack, the value of the saved ebp pointer and the return ad-
dress on the stack are modiﬁed, causing the victim to crash
when the shell-code ﬁnishes. We modiﬁed this attack so that
the process could recover. Speciﬁcally, the length of the over-
ﬂow was reduced so as to avoid clobbering the local variables
of the caller. Next, as soon as control was transferred to the
attack code, it computed the expected value of ebp register
from the value of the esp register and restored this value. It
then executed a ret instruction. These changes added about
20 bytes to the shell-code and were suﬃcient to allow the
samba process to continue normal execution after the attack
without making any additional system calls.
4.2.2 Bootstrap Phase
The bootstrap phase remains essentially the same across
all applications, so we did not pursue additional feasibility
evaluation of this step beyond the Apache server.
4.2.3 Operational Phase
Since our intent is to demonstrate what can be accom-
plished by interposing attack code during normal operation
of a victim, we simpliﬁed our evaluation task by interposing
at the source-code level rather than using the more labor-
intensive binary-code interposition. We ensured that we
used only those capabilities that were available to code that
would be injected in binary form into a working process,
e.g., the ability to examine and alter input parameters to
an interposed function, or to change global data. Using this
approach, we veriﬁed that bind (a popular DNS server) and
lsh (a GNU implementation of the ssh version 2 protocol)
could be successfully attacked using a persistent interposi-
tion attack. We describe these results below.
BIND
DNS is a lightweight, connectionless, query-response pro-
tocol, so most DNS servers use a single process but may be
multi-threaded. We examined bind-8.2.2_p5 for targets for
code interposition. The GOT entries for sendto and recvfrom
are very convenient targets for an interposition attack. Our
attack interposed on sendto. Using documented DNS record
formats, we were able to identify the location of the IP ad-
dress (which is the most important piece of data within the
DNS response) within the buﬀer argument to sendto. We
simply modiﬁed this data to redirect clients to our server. It
is possible to make this attack stealthier by doing this sub-
stitution selectively, e.g., when the query is from a certain
IP address.
LSH
We inspected lsh-1.4.2 for interposition targets. After
authenticating a user, lshd does an execve on the lsh-execuv
program with command-line arguments that specify the user-
id and the group-id for the shell to be spawned. It is this lsh-
execuv program that executes the actual setuid and setgid
calls. In our attack, we targeted the GOT entry of execve. It
was simple to modify the argument data at the entry of the
execve call so as to set the userid to an arbitrary, attacker-
chosen value. Depending upon the conﬁguration of the LSH
server, the attacker may still not be able to get a root shell
this way, but he/she can easily assume any other userid.
(Note that although this attack involves changing a system-
call argument, the change is undetectable to an IDS, in the
sense that the new value that we use would be a valid value
in a diﬀerent run of the server, where the user correspond-
ing to this userid authenticated herself. The only diﬀerence
between such a run, corresponding to valid authentication,
and the attack sequence, is the authentication data itself,
which appears as the data argument to an input system call
— a diﬀerence that, by deﬁnition, can’t be detected by an
I/O data oblivious monitor.)
4.3 Possible attacks on other servers
In this section, we discuss (rather than experimentally ver-
ify) possible persistent interposition attacks on a few addi-
tional servers.
DHCP Servers
On most networks, DHCP servers provide clients with
their IP address, name server, and IP gateway, and may
be conﬁgured to supply even more conﬁguration parame-
ters. An attacker could use a compromised DHCP server to
redirect client DNS requests to a server under his control, or
to redirect client packets through his computer, acting as a
gateway.
The Internet Systems Consortium DHCP server handles
all requests in one, long-lived process, making a persistent
interposition attack against the DHCP server relatively easy
and powerful.
Sendmail
Sendmail forks a new process to handle each incoming
mail message, so a persistent interposition attack against
sendmail’s message reception code will be of limited use –
the compromised server will exit soon, anyway. Sendmail
can also forward messages, though, and, in its default con-
ﬁguration, uses a single process to handle all the messages
queued up for later transmission. If an attacker ﬁnds a bug
in sendmail’s message forwarding routines, he can mount a
persistent interposition attack on the forwarding process by
inserting malformed messages in the forwarding queue. The
attacker’s code can then read and modify all subsequent mes-
sages processed from the same queue. This enables attackers
to alter forwarded emails, misdirect them, or read the emails
intended for arbitrary users.
5.
Implications for Existing Defenses
System-call Learning Based IDS
Our work was motivated by the long series of research
works in this area [16, 27, 34, 8, 10, 3, 19, 30]. All of them
use I/O data oblivious models, and hence aren’t able to de-
tect persistent interposition attacks. The range of objectives
that are achievable using persistent interposition attack sug-
gests that one shouldn’t rely on these IDS to protect against
injected code attacks. Nevertheless, these techniques can be
used to detect various other types of attacks such as race
conditions, temp ﬁle bugs, and so on. More generally, due
to its reliance on learning, these techniques have the po-
tential to detect attacks that involve unintended uses of an
164
application that wasn’t captured in training.
Static-Analysis Based IDS
A number of system call monitoring IDS have been based
on static analysis of application code. Some of these tech-
niques rely on source-code analysis [32], while others can
operate on binaries [14, 7, 13]. They construct I/O data
oblivious models, and are hence susceptible to our attack.
The main advantage of this class of techniques is that they
don’t produce false positives. This is because they rely on
static analysis techniques that are sound with respect to the
semantics of the programming language (namely, C or C++)
of the victim application. As a result, these techniques will
detect only those attacks that cause the victim’s code to be-
have diﬀerently from the semantics speciﬁed by its language.
Many kinds of attacks, including race condition attacks due
to TOCTTOU vulnerabilities, temp ﬁle attacks, and various
types of injection attacks, do not involve any violation of the
semantics assumed by the static analysis, and hence aren’t
be detected by these techniques. Memory corruption attacks
do involve a violation of the language semantics and hence
fall within the scope of these techniques. However, our tech-
niques show that it is possible to modify typical memory
corruption exploits so as to evade detection by these IDS.
As a result, it is unclear if there are attack types that can
be reliably detected using existing static analysis based IDS
techniques.
Policy-Enforcement Techniques and Speciﬁcation-
Based IDS
Well-deﬁned policies or speciﬁcations with speciﬁc secu-
rity objectives can be successfully enforced using system-call
monitoring, and our results don’t dispute this in any man-
ner. However, in the absence of such policies, it is harder
to quantify the protection oﬀered by these techniques. For
instance, Systrace and SELinux policies7 have the primary
objective of limiting damage to system resources and other
applications that can result when a protected application is
compromised. Their policies do achieve this objective. Our
results show that, even if the rest of the system is protected
from a successful attack against a single application, attack-
ers can still violate crucial security goals, such as stealing
private keys and passwords. System-call-monitoring policy-
enforcement techniques are therefore only part of a complete
defense system.
Techniques for Control Transfer Integrity Checking
Recently, techniques have been developed that are related
to system call monitors, but go beyond it in that they mon-
itor most control transfers rather than just system calls.
Control-ﬂow integrity [2] transforms binaries to introduce in-
tegrity checks on targets of control transfers before any jump
or call. Such a technique can disrupt the initial control-
hijack step of code injection attacks. PAID [22] is a hy-
brid approach that incorporates a limited degree of integrity
checking into a system call monitor. In particular, it uses
source-code transformation to insert notify system calls be-
fore each indirect function call to report the target of the
7SELinux policies aren’t stated in terms of system calls, but are
close enough for our purposes, so we discuss them together with
system-call based techniques.
indirect branch to a system call monitor. Although this was
designed as a measure to resolve non-determinism in the au-
tomata model extracted from the program by PAID, it has
the eﬀect that the monitor will come to know about any
jump into injected code residing in data segment.
Injected code attacks seem virtually impossible with these
techniques, so persistent interposition attacks aren’t eﬀective
against them. However, there are simpler attacks that can
succeed against these techniques by simply modifying system
call arguments. Chen et al [5] demonstrate several powerful
memory corruption attacks that operate by corrupting only
data values, while providing the attacker with capabilities
similar to those of code injection attacks. Although PAID
can detect some of these attacks by examining system call
arguments, due to the diﬃculty of accurate data ﬂow anal-
ysis in languages such as C, there will likely be plenty of
opportunities to craft successful data attacks.
Defenses against memory corruption attacks
The results of this paper, together with the above discus-
sion, reinforce the idea that eﬀective defenses against mem-
ory corruption attacks need to focus on the corruption step
itself, rather than attempting to contain the damage that
follows memory corruption. The best defenses are provided
by techniques that detect a memory error before it happens,
such as those described in [24, 17, 26]. However, these tech-