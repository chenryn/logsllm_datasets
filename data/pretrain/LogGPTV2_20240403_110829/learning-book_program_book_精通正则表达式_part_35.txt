下面是一个分解URL的Perl代码：
if(Surl =~m(~http://({/:]+)(:(\d+）)？(/.*)?$}i)
my $host= $1;
mySport=S31180；#如果存在，就使用S3：否则默认为80
mySpath=S411·/"；#如果存在，就使用S4；否则联认为"/"
print *Host: $host\n";
print "Port:Sport\n";
print "Path: Spath\n";
}else（
print*Not an HTTP URL\n";
验证主机名
Validating aHostname
在上面的例子中，我们用[~/：]+来匹配主机名。不过，在第2章中（76）我们使用的
是更复杂的[-a-z]+（\.[-a-z]+）*\.（comledu||info）。做同样的事情，复杂程度为什
么会有这么大的差别？
Y
而且，虽然二者都用来“匹配主机名”，方法却大不相同。从已知文本（例如，从现成的
而且，在上例中我们假设，‘http：//之后就是主机名，所以用[~/：]+来匹配就是理所
当然的。但是在第2章的例子中，我们使用正则表达式从随机文本中寻找主机名，所以它
必须更加复杂。
现在从另外一个角度来看主机名的匹配，我们可以用正则表达式来验证主机名。也就是说，
我们需要知道，一串字符是否是形式规范、语意正确的主机名。按规定，主机名由点号分
---
## Page 230
204
第5章：正则表达式实用技巧
VB.NET中的link检查程序
下面的程序会列出Html变量中的链接：
Imports System.Text.RegularExpressions
：设置循环中将会遇到的正则表达式
Dim A_RRegex as Regex = New Regex(
[^>]+)>(?.*?)
RegexOptions.IgnoreCase)
Dim GutsRegex as Regex = New Regex(
"\b HREF
(?#
'href属性
"\S*=\s*
(?#
=：可能存在空白字符
* (? :
#)
其值为...
&
（+[]）·
(?#
双引号字符串
(?#
或者是
&
.([.]）.
(?#
单引号字符串
&
(?#
或者是，
(?[
">\s]+)
(?#
其他文本
*)
(?#
·现在检查·Html·变量
Dim CheckA as Match = A_Regex.Match(Html)
'For each match within..
While CheckA.Success
·已匹配tag，现在检查URL
Dim UrlCheck as Match
GutsRegex.Match(CheckA.Groups("guts*).Value)
If UrlCheck.Success
：已经匹配完毕，得到URL/link
Console.WriteLine("Url*&UrlCheck.Groups(*url*).Value &
·WITH LINK *& CheckA.Groups("Link*).Value)
End If
CheckA = CheckA.NextMatch
End While
需要注意的几点：
在VB.NET中使用正则表达式，需要首先执行对应的Imports语句，告诉编译器
应当导入的库文件。
程序中使用了（？#）风格的注释，因为VB.NET中加入换行符很不方便，所以普
通的‘#”注释会延伸到下一个换行符或者字符串的结尾（第一种情况即意味着正
则表达式剩下的所有内容都作为注释）。为了使用正常的#注释，请在每一行的
结尾添加&chr（10）（420）。
表达式中的每个双引号都需要以‘""表示（103）。
两个表达式都用到了命名捕获，Groups（“url"）比Groups（1）和Groups（2）之类
更为清晰。
|1
---
## Page 231
HTML相关范例
205
隔的部分组成，每个部分可以包括ASCI1字符、数字和连字符，但是不能以连字符作为开
头和结尾。所以，我们可以在不区分大小写的模式下使用这个正则表达式：[a-20-9]1
[a-z0-9][-a-z0-9]*[a-z0-9]s。结尾的后缀部分（`com”、edu’、‘uk’等）只有有限
多个可能，这在第2章的例子中提到过。结合起来，下面的正则表达式就能够匹配一个语
意正确的主机名：
A
(?i)
#进行不区分大小写的匹配
#零个或多个据点分隔的部分
(?:[a-z0-9]\.1[a-z0-9][-a-z0-9]*[a-z0-9]\.） +
#然后是结尾的后级部分.：
(?: comledulgovlint |mi1|net |org|biz|info|name|museum| cooplaerol[a-z}[a-z] )
因为存在长度的限制，能够由这个正则表达式匹配的可能并不是合法的主机名：每个部分
不能超过63个字符。也就是说，[-a-z0-9]*应该改为（-a-z0-9】（0，61}l。
还需要做最后的改动。按规定，只包括后缀的主机名同样是语意正确的。但实践证明，这
些“主机名”不存在，但是对于两个字母的后缀来说情况可不是如此。例如，安哥拉的域
名‘ai’就有一-个Web服务器http://ai/。我见过其他这样的链接：cc、co、dk、mm、ph、
tj、tv和tw。
如果希望匹配这些特殊情况，应该把中间的（？：)+改为（？：）*：
(?i)
#进行不区分大小写的匹配
#零个或多个据点分隔的部分
(?:[a-z0-9]\.1[a-z0-9][-a-z0-9](0,61}[a-z0-9]\.）*
然后是结尾的后缀部分.：：
(?: com|edulgov|int (mi1 |net |orglbiz|info|nameimuseumicooplaero1[a-z] [a-z])
S
现在它可以用来验证包含主机名的字符串了。因为这是我们想出的与主机名相关的三个正
则表达式中最复杂的，你也许会想，不要这些锚点，可能比之前那个从随机文本中提取主
机名的表达式更好。但情况并非如此。这个正则表达式能匹配任意双字母单词，正因为如
此，第2章中不那么精妙的正则表达式的实际效果更好。但是在下一节我们会看到，某些
情况下它仍然不够完善。
---
## Page 232
206
第5章：正则表达式实用技巧
在真实世界中提取URL
Plucking Out a URLin the Real World
供职于Yahoo！Finance时，我曾写过处理收录的财经新闻和数据的程序。新闻通常是以纯文
本格式提供的，我的程序将其转化为HTML格式以便于显示（如果你在过去10年中曾经在
http：/finance.yahoo.com浏览过财经新闻，没准看过我处理过的新闻）。
因为接受的数据的“格式”（其实是无格式）很杂乱，从纯文本中识别（recognize）出hostname
和URL又比验证（validate）它们困难得多，这任务就很不轻松。前面的内容并没有体现这
一点，在本节，你会看到我在Yahoo！用来解决这个问题的程序。
这个程序从文本中提取几种类型的URL—-mailto、http、https和ftp。如果我们在文
本中找到‘http：//'，就知道这肯定是一个URL的开头，所以我们可以直接用http：//[-\w]
+（\.\w[-\W]*)+来匹配主机名。我们知道，要处理的文本肯定是ASCII编码的英文字母，
所以完全可以用'-\w来取代-a-z0-9。w同样可以匹配下画线，在某些系统中，它还可
以匹配所有的Unicode字符，但是我们知道，这个程序在运行时不会遇到这些问题。
不过，URL通常不是以http：//或者mailto：开头的，例如：
visit us at www.oreilly.com or mail to PI:EMAIL
在这种情况下，我们需要加倍小心。我在Yahoo！使用的正则表达式与前面那节的非常相似，
只是有一点点不同：
（?i：[a-20-9]（?:[-a-z0-9]*[a-z0-9])?\.）+#子域名S
#.Com之类的后缀，要求小写
(?-i: com\b
|edu\b
1biz\b
1org\b
1gov\b
1in(?:t1fo)\b
#.int或者.info
1mi1\b
|net\b
Iname\b
Imuseum\b
1coop\b
Iaero\b
1[a-z][a-z]\b
#双宇母国家代码
在这个正则表达式中，我们用（？i：）和（？-i：)用来规定正则表达式的某个部分是否
）
---
## Page 233
HTML相关范例
207
代码（NT.TO是北电网络在多伦多证券交易市场的代号，因为要处理的是财经新闻和数据，
这样的股票代码很多）。按规定，URL的结尾部分（例如‘.com'）可能是大写的，但我不
准备处理这些情况。因为我需要保持平衡-一匹配期望的文本（尽可能多的URL），忽略不
期望的文本（股票代码）。我希望（？-i：...）只包括国家代码，但是在现实中，我们没有
遇到大写的URL地址，所以不必这么做。
下面是从纯文本中查找URL的框架，我们可以在其中添加匹配主机名的子表达式：
b
#匹配开头部分（proto://hostname，或直接是hostname）
#ftp://、http://或https://开头部分
(ftp1https?)://[-\w]+(\.\w[-\w]*)+
#或者是用更准确的子表达式找到hostname
full-hostname-regex
#可能出现端口号
（：\d+）？
#下面部分可能出现、以/开头
/path-part
(
orielly.com/catalog/regex/中的划线部分）。path是最难正确匹配的文本，因为它需要
一些猜测才能做得很漂亮。我们在第2章说过，通常出现在URL之后的文本也能被作为
URL的一部分。例如：
Read his comments at http://www.oreilly.com/ask_tim/index.html.He...
我们观察之后就会发现，在index.htm1’之后的句号是一个标点，不应该作为URL的
部分，但是‘index.html’中的点号却是URL的一部分。
肉眼很容易分辨这两种情况，但程序做起来却很难，所以必须想些聪明的办法来尽可能好
地解决问题。第2章的例子使用逆序环视来确保URL不会以句末的句号结尾。我在Yahoo！
Finance写程序时还没有逆序环视，所以我用的办法要复杂的多，不过效果是一样的。代码
在下一页。
---
## Page 234
208
第5章：正则表达式实用技巧
示例5-1：从财经新闻中提取URL
\b
匹配开头部分（proto：//hostname，或直接是hostname）
#ftp：//、http：//或https：//开头部分
(ftpihtcps?)://[-\w}+(\.\w[-\w}*)+
#或者是用更准确的子表达式找到hostname
(?i:[a-z0-9] (?:[-a-z0-9] *[a-z0-9])? \.)+
#sub domains
.COm之类的后缀，要求小写
(?-i: com\b
1edu\b
1biz\b
1gov\b
1in(?:t|fo)\b
#.int或者.info
1mi1\b
Inet\b
1org\b
1[a-z][a-z]\b
#双宇母国家代码
可能出现端口号
（：\d+）？
剩下的部分可能出现，以/开头.
#虽然很复杂，但确实管用
[.!,?;*<>()\[\](）\s\x7F-\xFF]*
(?:
[.!,?]+[.!,？;*'<>()\[\](}\s\x7F-\xFF] +
) *
)?
这里用到的办法与第2章第75页用到的办法有很多不同，比较起来也很有意思。下一页里
使用此表达式的Java程序详细介绍了它的构造。
在实际生活中，我怀疑自已是否会写这样繁杂的正则表达式，但是作为取代，我会建立一
个正则表达式“库（library）”，需要时取用。这方面一个简单的例子就是第76页的
SHostnameRegex，以及下面的补充内容。
扩展的例子
Extended Examples
下面的几个例子讲解了一些关于正则表达式的重要诀窍。讨论会稍微多一些，关于解决办
法和错误思路的着墨也会更多一些，最终会给出正确答案。
---
## Page 235