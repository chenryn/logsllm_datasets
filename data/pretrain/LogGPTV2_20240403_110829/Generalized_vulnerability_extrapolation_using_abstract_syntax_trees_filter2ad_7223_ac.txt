1 static int flic_decode_frame_8BPP(AVCodecContext *avctx,
2
void *data, int *data_size,
const uint8_t *buf,
int buf_size)
3
4
5 { [...]
6
signed short line_packets; int y_ptr;
[...]
pixels = s->frame.data[0];
pixel_limit = s->avctx->height * s->frame.linesize[0];
frame_size = AV_RL32(&buf[stream_ptr]); [...]
frame_size -= 16;
/* iterate through the chunks */
while ((frame_size > 0) && (num_chunks > 0)) { [...]
chunk_type = AV_RL16(&buf[stream_ptr]);
stream_ptr += 2;
switch (chunk_type) { [...]
case FLI_DELTA:
y_ptr = 0;
compressed_lines = AV_RL16(&buf[stream_ptr]);
stream_ptr += 2;
while (compressed_lines > 0) {
line_packets = AV_RL16(&buf[stream_ptr]);
stream_ptr += 2;
if ((line_packets & 0xC000) == 0xC000) {
// line skip opcode
line_packets = -line_packets;
y_ptr += line_packets * s->frame.linesize[0];
} else if ((line_packets & 0xC000) == 0x4000) {
[...]
} else if ((line_packets & 0xC000) == 0x8000) {
// "last byte" opcode
pixels[y_ptr + s->frame.linesize[0] - 1] =
line_packets & 0xff;
} else { [...]
y_ptr += s->frame.linesize[0];
}
}
break; [...]
}
[...]
} [...]
return buf_size;
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43 }
static void vmd_decode(VmdVideoContext *s)
{
[...] int frame_x, frame_y;
int frame_width, frame_height;
int dp_size;
frame_x = AV_RL16(&s->buf[6]);
frame_y = AV_RL16(&s->buf[8]);
frame_width = AV_RL16(&s->buf[10]) - frame_x + 1;
frame_height = AV_RL16(&s->buf[12]) - frame_y + 1;
if ((frame_width == s->avctx->width &&
frame_height == s->avctx->height) &&
(frame_x || frame_y)) {
s->x_off = frame_x;
s->y_off = frame_y;
}
frame_x -= s->x_off;
frame_y -= s->y_off; [...]
if (frame_x || frame_y || (frame_width != s->avctx->width) ||
(frame_height != s->avctx->height)) {
memcpy(s->frame.data[0], s->prev_frame.data[0],
s->avctx->height * s->frame.linesize[0]);
} [...]
if (s->size >= 0) {
pb = p;
meth = *pb++; [...]
dp = &s->frame.data[0][frame_y * s->frame.linesize[0]
+ frame_x];
dp_size = s->frame.linesize[0] * s->avctx->height;
pp = &s->prev_frame.data[0][frame_y *
s->prev_frame.linesize[0] + frame_x];
switch (meth) { [...]
case 2:
for (i = 0; i frame.linesize[0];
pp += s->prev_frame.linesize[0];
} break; [...]
}
}
}
Figure 5: Original vulnerability in flic_decode_frame_8BPP (left) and zero-day vulnerability found in vmd_decode (right)
ity extrapolated in our previous work [33], thus allowing the
advantages of our improved method to be demonstrated in
direct comparison to a non-structured approach.
Original vulnerability. Video decoding in general in-
volves processing image data in form of video frames. These
frames contain the encoded pixels as well as meta informa-
tion of the image, such as width and oﬀset values. Decoders
usually proceed by allocating an array and then using the
oﬀsets provided in the video frame to populate the array
with the image data. In this context, it must be carefully
veriﬁed that oﬀsets speciﬁed by the frame refer to loca-
tions within the array. In the case of the decoding routine
flic_decode_frame_8BPP shown in Figure 5, no veriﬁcation
of this kind is performed allowing an attacker to reference
locations outside the pixel array.
The critical write is performed on line 32, where the least
signiﬁcant byte of the user-supplied integer line_packets is
written to a location relative to the buﬀer pixels.
It has
been overlooked that the oﬀset is dependent on y_ptr and
s->frame.linesize[0], both of which can be controlled by an
attacker. Due to the loop starting at line 21, it is possible
to assign an arbitrary value to y_ptr independent of the last
value stored in line_packets and no check is performed to
verify whether the oﬀset remains within the buﬀer.
Extrapolation. We proceed by using our method to
generate the ranking shown in Table 2. This ranking con-
tains the 30 most similar functions to the vulnerable function
flic_decode_frame_8BPP selected from a total of 6,941 func-
tions in the FFmpeg code base. Candidate functions for the
vulnerabilities are depicted with light shading, discovered
vulnerabilities are indicated by dark shading.
First, we note that 20 out of 30 functions are candidate
functions, i.e., they are decoders performing a write opera-
tion to a pixel buﬀer. Furthermore, no irrelevant functions
are part of the ﬁrst 13 results and we can spot four vulner-
able functions in the ranking corresponding to the following
three vulnerabilities:
1. The function flic_decode_frame_15_16BPP is located in
the same ﬁle as the original vulnerability and likewise
processes FLIC video frames. The function has been
found by FFmpeg developers to contain a similar vul-
nerability, which was patched along with the original
ﬂaw. Our method returns a similarity of 98%.
2. The function vmd_decode depicted in Figure 5 contains
the vulnerability discovered in [33]. The function pro-
ceeds by employing the same API functions used in
the original vulnerability to read frame meta data on
line 7 to 10 and then uses these values to calculate an
incorrect index into the pixel buﬀer on line 28. Our
method returns a similarity of 89%, leading us almost
instantly to this vulnerability.
364
1 static void vqa_decode_chunk(VqaContext *s)
2 {
3
[...]
int lobytes = 0;
int hibytes = s->decode_buffer_size / 2; [...]
for (y = 0; y frame.linesize[0] * s->height;
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
y += s->frame.linesize[0] * s->vector_height){
for (x = y; x width; x += 4, lobytes++, hibytes++)
{
pixel_ptr = x;
/* get the vector index, the method for
which varies according to
* VQA file version */
switch (s->vqa_version) {
case 1: [...]
case 2:
lobyte = s->decode_buffer[lobytes];
hibyte = s->decode_buffer[hibytes];
vector_index = (hibyte vector_height;
break;
case 3: [...]
}
while (lines--) {
s->frame.data[0][pixel_ptr + 0] =
s->codebook[vector_index++];
s->frame.data[0][pixel_ptr + 1] =
s->codebook[vector_index++];
s->frame.data[0][pixel_ptr + 2] =
s->codebook[vector_index++];
s->frame.data[0][pixel_ptr + 3] =
s->codebook[vector_index++];
pixel_ptr += s->frame.linesize[0];
}
}
}
}
static av_cold int vqa_decode_init(AVCodecContext *avctx)
{
VqaContext *s = avctx->priv_data;
unsigned char *vqa_header;
int i, j, codebook_index;
s->avctx = avctx;
avctx->pix_fmt = PIX_FMT_PAL8; [...]
/* load up the VQA parameters from the header */
vqa_header = (unsigned char *)s->avctx->extradata;
s->vqa_version = vqa_header[0];
s->width = AV_RL16(&vqa_header[6]);
s->height = AV_RL16(&vqa_header[8]); [...]
/* allocate decode buffer */
s->decode_buffer_size = (s->width / s->vector_width) *
(s->height / s->vector_height) * 2;
s->decode_buffer = av_malloc(s->decode_buffer_size);
s->frame.data[0] = NULL;
return 0;
}
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
Figure 6: The second zero-day vulnerability found by extrapolation of CVE-2010-3429 in vqa_decode_chunk.
3. The function vqa_decode_chunk contains another previ-
ously unknown vulnerability shown in Figure 6. In this
case, however, reading of frame meta data using the
characteristic API is performed by a diﬀerent function,
vqa_decode_init, on line 21 and 22. Despite the miss-
ing API information, our method is able to uncover the
decoder based on its characteristic code structure. In
particular, the two nested loops iterating over the pixel
buﬀer on line 6 and 8 are common to most decoders.
In summary, this example shows that our method is use-
ful to identify zero-day vulnerabilities in real-world code.
Furthermore, by combining information about symbol usage
and code structure, our method gains increased robustness
over approaches resting solely on symbol information.
Sim. Function name
Sim. Function name
0.98 flic_decode_frame_15_16BPP
0.92 decode_frame
0.92 decode_frame
0.91 flac_decode_frame
0.90 decode_format80
0.89 decode_frame
0.89 tgv_decode_frame
0.89 vmd_decode
0.89 wavpack_decode_frame
0.88 adpcm_decode_frame
0.88 decode_frame
0.88 aasc_decode_frame
0.88 vqa_decode_chunk
0.87 cmv_process_header
0.87 msrle_decode_8_16_24_32
0.87 wmavoice_decode_init
0.85 decode_frame
0.84 smc_decode_stream
0.84 rl2_decode_init
0.84 xvid_encode_init
0.84 vmdvideo_decode_init
0.83 mjpega_dump_header
0.82 ff_flac_is_._valid
0.82 decode_init
0.82 ws_snd_decode_frame
0.81 bmp_decode_frame
0.81 sbr_make_f_master
0.80 ff_h264_decode_ref_pic_.
0.80 decode_frame
0.79 vqa_decode_init
Table 2: Top 30 most similar functions to a known vulner-
ability in FFmpeg.
3.2.2 Case study: Pidgin
To demonstrate the generality of our method, we perform
a second extrapolation on a diﬀerent code base and for a
diﬀerent vulnerability type.
In this case study, the set of
relevant functions is very small in comparison to the size
of the code base, that is, only 67 out of 11,505 functions
are candidate functions. Despite this increased diﬃculty, we
are able to identify nine vulnerabilities similar to a known
vulnerability among the ﬁrst 30 hits, six of which were pre-
viously unknown.
Original Vulnerability. The function receiveauthgrant
shown in Figure 7 does not perform suﬃcient validation of
UTF-8 strings received from the network allowing attackers
to cause a denial of service condition and possibly execute
arbitrary code. The function reads the username and mes-
sage from an incoming binary data packet on line 15 and 20
respectively. It then passes these values to a suitable packet
handler on line 27. In general, packet handlers assume that
strings passed in parameters are valid UTF8-strings, how-
ever, the function does not ensure that this is the case.
Extrapolation. We again apply our method to obtain
the 30 most similar functions to the original vulnerability as
shown in Table 3. We ﬁrst note that 28 of the ﬁrst 30 hits are
candidates selected from a total of 11,505 functions. After
a short inspection of the suggested functions, we are able to
spot the same type of vulnerability as in the original function
in nine of the candidates. As an example, consider function
parseicon shown in Figure 7. The username is read from
the binary data packet on line 16 and is passed to a handler
function unchecked on line 25–similar to the vulnerability in
receiveauthgrant. It has been veriﬁed that this again allows
to cause a denial of service condition.
The second case study demonstrates that our method
works well even when the number of relevant functions is
small compared to the total size of the code base. We are
able to narrow down the search for potentially vulnerable
365
1 static int
2 receiveauthgrant(OscarData *od,
3
FlapConnection *conn,
aim_module_t *mod,
FlapFrame *frame,
aim_modsnac_t *snac,
ByteStream *bs)
4
5
6
7
8 {
9
10
11
12
13
14
15
16