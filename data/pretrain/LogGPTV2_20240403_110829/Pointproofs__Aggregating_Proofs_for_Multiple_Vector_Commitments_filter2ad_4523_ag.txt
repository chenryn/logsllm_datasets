1
1
vS0
e(C, g
2
vS1
)vS1 = e(C, g
2
)vS0, we have:
(cid:80)
) · g
vS1
T
vS1
e(ˆπ0, g
2
i∈S0 m0
i uivi
vS0
= e(ˆπ1, g
2
) · g
vS0
T
(cid:80)
i∈S1 m1
i uivi
ui∗ v2
i∗
T
Rearranging the terms so that g
vi∗(cid:80)
(vS1−vi∗ )(cid:80)
vS1
e(ˆπ0, g
2
· g
· g
T
) · e(ˆπ1, g
i∈S0\{i∗} m0
i uivi
i∈S0 m0
T
i∗−m0
i∗ )ui∗ v2
i∗
(m1
T
= g
appears on the RHS,
vS0
2
)−1
−vi∗(cid:80)
· g
−(vS0−vi∗ )(cid:80)
· g
i uivi
T
T
i∈S1\{i∗} m1
i uivi
i∈S1 m1
i uivi
We can now extract g
given ˆπ0, ˆπ1, gui∗
, gvi∗
using the fact that m1
ui∗ v2
i∗
and {ui, vi}i(cid:54)=i∗.
T
1
2
i∗ − m0
i∗ (cid:54)= 0, since we can compute the terms on the LHS
B Weak binding
In this section, we describe a weaker notion of binding, in which the commitment C must be honestly
computed by Commit (on some, possibly adversarially chosen, messages) rather than chosen arbitrarily
by the adversary. (cid:145)is notion o(cid:137)en su(cid:129)ces in blockchain applications. We then sketch how our scheme
achieves this notion without the restriction to algebraic adversaries.
Weak binding. For every N and every adversary running in time polynomial in λ, the probability of
(cid:128)nding
C, m, r, (ˆπ, S, m∗[S])
such that
• C = Commit(m; r);
• Verify(C, S, m∗[S], ˆπ) = 1;
• m[S] (cid:54)= m∗[S]
(assuming parameters generated by Setup(1λ, 1N )) is negligible in λ.
Realizing weak binding. To establish weak binding, it su(cid:129)ces to show that any e(cid:129)cient adversary wins
the following game with negligible probability:
1. challenger sends gα, . . . , gαN ∈ G
29
2. adversary sends C ∈ G, S,{m∗
i}i∈S
3. challenger sends t1, . . . , tN ← Zp
4. adversary sends m1, . . . , mN
Adversary wins if
(cid:80) αimi (cid:94) (cid:88)
i∈S
C = g
(cid:94) ∃i∗ ∈ S, mi∗ (cid:54)= m∗
i∗
(mi − m∗
i )ti = 0
If adversary wins game with probability , then it breaks strong DH with probability 2/4 − 1/p.
Proof sketch. By an averaging argument, w.p. /2 over steps 1,2, the adversary wins with probability /2
over steps 3,4 (conditioned on steps 1,2). We run the adversary on steps 1,2,3,4 to get some winning ti, mi
and then rewind steps 3,4 to get another winning t(cid:48)
. We proceed via a case analysis:
i, m(cid:48)
i
• if (m(cid:48)
1, . . . , m(cid:48)
N ) = (m1, . . . , mN ), then we have as before
(cid:20)(cid:88)
(cid:21)
this step uses the fact that t(cid:48)
mit(cid:48)
≤ 1/p
Pr
t(cid:48)
1,...,t(cid:48)
1, . . . , t(cid:48)
are independent of m1, . . . , mN.
i = 0
N
N
• if (m(cid:48)
1, . . . , m(cid:48)
N ) (cid:54)= (m1, . . . , mN ), then we have
(cid:80) αi(m(cid:48)
g
i−mi) = 1
(cid:145)is yields a non-trivial univariate polynomial equation in α, which we can use to solve for α.
C Cross-Commitment Aggregation from Polynomial Commitments
We sketch how the recent and independent work of Boneh, Drake, Fisch, and Gabizon [BDFG20] on
polynomial commitments (building upon [KZG10, MBKM19]) also yields a vector commitment that
supports cross-commitment aggregation. (cid:145)e scheme we present below is the same as the scheme
in [BDFG20, Section 3] with the Fiat-Shamir transform and the following additional changes applied.
First, a commitment to a polynomial P of degree N − 1 can be thought of as commitment to the
vector (P (1), . . . , P (N )). Second, we explicitly show both a same-commitment and a cross-commitment
aggregation mechanism; that is, we show how to decompose the batch opening algorithm of [BDFG20]
into single openings followed by aggregation. (cid:145)ird, we modify the veri(cid:128)cation equation in the cross-
commitment case to use independent random tj values rather than powers of a single random value γ, for
consistency with our scheme (note that we could, instead, have used powers of a single random value in
our scheme, too, with slight changes to the proof and exact security bounds; see [GWC19, footnote 5]).
Although polynomial commitments were not initially designed for e(cid:129)cient updates, as pointed out
to us by Gabizon [Gab20], updates can made as e(cid:129)cient as in our scheme with a bit of precomputation
(see the Setup and UpdateCommit algorithms below). Other e(cid:129)ciency parameters are comparable (up to
constant factors), except VerifyAcross, which can take up to Θ((cid:96)N ) more exponentiations depending on
the exact subsets being aggregated.
30
Unfortunately, the more e(cid:129)cient scheme presented in [BDFG20, Section 4] does not seem to support
cross-commitment aggregation, because the second element of the proof (denoted W (cid:48) in [BDFG20])
depends on a random value that itself depends on the (cid:128)rst element of the aggregated proof (denote π
the description of AggregateAcross below and W in [BDFG20]).
Overview. Given m = (m1, . . . , mN ) and a subset S ⊆ [N ], let φS is the unique polynomial of degree at
most |S| − 1 such that φS(i) = mi for all i ∈ [S]. Let φ = φ[N ]. Observe that the polynomial
evaluates to 0 at all i ∈ [S], and is therefore divisible by zS(X) :=(cid:81)
φ(X) − φS(X)
exponent) be the commitment and the fraction
j∈S(X − j). We will let φ(α) (in the
φ(α) − φS(α)
zS(α)
(again, in the exponent) be the proof for S.
Same-commitment aggregation.
• Setup(1λ, 1N ). Samples α ← {N + 1, . . . , p} and outputs
), (g2, gα
1 , . . . , gαN−1
(g1, gα
1
2 , . . . , gαN−1
2
)
In addition, if desired to enable fast UpdateCommit, precomputes and outputs values ui = gφi(α)
for i ∈ [N ], where φi is the unique degree N − 1 polynomial such that φi(i) = 1 and φ(j) = 0 for
all j ∈ [N ] − {i}. (cid:145)is one-time precomputation can be done easily in time O(N 2); it can also be
done in time O(N log N ) using Fast Fourier Transform (FFT). It is faster if α is available, but can be
done with just pp.
1
• Commit(m). Outputs
where φ is the unique degree N − 1 polynomial such that φ(i) = mi for all i ∈ [N ].
• UpdateCommit(C, S, m[S], m(cid:48)[S]). Outputs
C := gφ(α)
1
C(cid:48) := C ·(cid:89)
i∈S
i−mi
um(cid:48)
i
• Prove(i, m). Outputs
φ(α)−mi
πi := g
1
α−i
where φ is the same as for Commit.
• Aggregate(C, S, m[S],{πi : i ∈ S}). Outputs
where
λi :=
are the Langrangian coe(cid:129)cients (see Proof of Correctness, below, for an explanation).
ˆπ :=
πλi
i
1
i − j
j∈S\{i}
(cid:89)
(cid:89)
i∈S
31
• Verify(C, S, m[S], ˆπ). Checks that
(cid:16)
C · g
−φS (α)
1
, g2
e
(cid:17) ?= e
(cid:16)
(cid:81)
ˆπ, g
2
(cid:17)
i∈S (α−i)
Cross-commitment aggregation. We describe the following additional algorithms:
AggregateAcross({ Cj, Sj, mj[Sj], ˆπj }j∈[(cid:96)]). Outputs
(cid:96)(cid:89)
j=1
π :=
ˆπtj
j ,
where
VerifyAcross({ Cj, Sj, mj[Sj]}j∈[(cid:96)], π). Checks that
−φj,Sj (α)
(cid:89)
(cid:18)
tj = H(j,{Cj, Sj, mj[Sj]}j∈[(cid:96)]) .
(cid:16)
(cid:19)
tj·zT\Sj
(α)
(cid:17)
, g
2
?= e
π, gzT (α)
2
Cj · g
1
e
j
where T = ∪jSj and φj,S is the unique degree |S| − 1 polynomial such that φj,S(i) = mj,i for all
i ∈ [S].
Proof of correctness. Recall the de(cid:128)nition zS(X) =(cid:81)
We claim that ˆπ output by Aggregate is equal to
j∈S(X − j) and observe that λi = 1/zS\{i}(i).
φ(α)−φS (α)
zS (α)
g
1
(cid:145)is claim immediately shows the correctness of Verify, because both sides, by bilinearity, are equal to
gφ(α)−φS (α)
.
T
(cid:88)
(cid:145)e claim follows from the following relation:
λi · φ(X) − mi
X − i
(cid:88)
i∈S
1
(cid:145)e relation can be shown by the following two steps. First,
φ(X) − φS(X)
zS(X)
.
=
λi ·
i∈S
1
X − i
=
,
zS(X)
(cid:88)
i∈S
λi ·
1
X − i
=
(cid:80)
i∈S λi · zS\{i}(X)
,
zS(X)
which is true because, when we bring the fractions to a common denominator, we obtain
and the numerator of the right-hand side is a polynomial of degree at most |S| − 1 that evaluates to 1 at
all i ∈ S and therefore must be the constant 1. Second,
(cid:88)
i∈S
λi · mi
X − i
=
φS(X)
zS(X)
,
32
(cid:80)
λi · mi
X − i
=
i λi · mi · zS\{i}(X)
zS(X)
,
i∈S
which is true because
(cid:88)
and the numerator of the right-hand side is a polynomial of degree at most |S| − 1 that evaluates to mi at
all i ∈ S and therefore must be the constant φS(X).
For the correctness of VerifyAcross, observe that we can obtain the veri(cid:128)cation equation by (1) raising
the G2 element on both sides of the jth-commitment veri(cid:128)cation equation to the power zT\Sj (α); (2)
raising the G2 element on the le(cid:137)-hand side and the G1 element on the right-hand side of each resulting
equation to the power tj; (3) multiplying all (cid:96) resulting equations together.
Proof of binding. Binding holds under a q-type assumption in the AGM+ROM model as shown in
[BDFG20, Section 3].
33