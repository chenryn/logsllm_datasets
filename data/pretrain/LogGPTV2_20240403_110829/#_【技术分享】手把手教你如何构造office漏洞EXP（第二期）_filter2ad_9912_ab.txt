而图表对象的解析过程都会涉及到其他更多的子对象，比如GraphicsPath这种图像路径对象。构造TIFF图片并填充SOI数据为重复的内存地址值（如0x0a0a00a0），替换了构造的TIFF图片后打开文档，在调试器里跟踪会发现程序会在一个图像路径复制函数GdipClonePath中调用到GraphicsPath对象的虚函数，且GraphicsPath对象的虚表指针被构造的TIFF图片SOI数据覆盖为指定的内存地址值（以0x0a0a00a0为例），于是就成功劫持了程序eip到内存地址0x0a0a00a4:
上图的eax实际上就是GraphicsPath对象的虚表指针，其值存放的位置刚好是0字节堆块后面的堆内存，说明上述的越界拷贝覆盖了GraphicsPath内存对象，而此对象又在解析第二个图表对象时被复制，复制的过程中由于调用了对象的虚函数对对象本身进行检查，导致我们的利用目标得以实现。整个利用过程大概如下图所示（请自行脑补并通过实践去验证）：
到了这里，终于从一个堆内存越界写漏洞成功拿到了程序的控制eip，但是漏洞利用过程还远没有结束，因为有了eip后就要跳转到我们的shellcode地址去，可是shellcode存放在哪里？此时，介绍一种office堆喷射的技术，利用office的activeX控件进行内存布局。首先，在文档插入第一个图表对象的前面先插入n多个（如n=40）activeX对象（如上期提到的ListView对象），保存文档为docx格式（office
open
xml文件格式）后对其进行zip解压缩，将里面的n多个ActiveX.bin文件（一模一样）进行改造。改造的过程也很简单，文件头不需要动，然后将我们的shellcode以一定的间隔进行重复填充，直到整个bin文件的大小为一个编排计算好的值（比如2mb）。改造完顺便替换TIFF图片后重新打包文档，然后office打开文档的过程中就会先映射这n多个bin文件到内存，由于这些内存正常是会连续申请的，所以比较方便我们对进程的内存进行编排，把shellcode布局到可以预测的地址，这个过程大概如下图所示：
通过这种方式，shellcode能够相对稳定的布局到特定的某个内存地址（当然这种方法其实是有一些缺点的，比如无法百分百每次都成功，以及喷射过程比较缓慢等），然后我们只要控制eip跳转到那个地址去执行shellcode就可以。不过，如果是WINXP+office
2007还好可以直接执行payload代码，因为默认没有开启dep保护，堆内存代码可以被直接执行；而如果是在office 2010以上环境，
payload代码所在映射堆的内存由于没有可执行属性，执行的时候会抛出异常而停止执行。这时候就该ROP链出场了，众所周知它是dep的老伙伴。ROP是基于栈内存的编程，我们的思路也很简单，就是通过这种特殊的编程方式实现修改shellcode所在地址的内存具有可执行属性后再跳转到上面去执行。
首先由于shellcode存放在堆内存里，而ROP编程基于栈内存，所以我们先修改esp，进行堆和栈之间的转换。要实现这个很简单，就是在进程空间找到一段类似这样的指令：
    xchg esp, eax
    ret
然后控制eip指向该指令地址去执行后便能直接将shellcode翻转到栈内存，这里会遇到两个问题，一个是如何搜索这些指令的问题，另一个是如何确保这些指令的地址是固定不变的（必需）。第二个问题其实好说，就是根据运行环境找没有开启aslr保护的程序模块进行搜索，就比如winword.exe和上期提到的mscomctl.ocx这两个模块都没有开aslr。而第一个问题，搜索这些指令一般都是借助工具，工具的实现原理一般是对代码段数据进行反汇编后搜索匹配，将一些可用的指令集及其地址展现出来供编程者（我们）来使用。另外，也有一些网站提供在线上传搜索服务，比如通过ropshell.com这个网站上传winword程序文件进行搜索，返回一些易于使用的指令集：
翻转shellcode后，就可以基于栈来跳转调用内存属性修改函数了，这里我的思路是在winword程序的导入表里找到VirtualProtect函数的地址，在栈内存上构造好需要的参数后就跳转到该函数调用，完成修改后直接跳转到payload代码地址去执行，编写好的ROP链如下：
    • 从call dword ptr ds:[eax+4]开始：
    • 0x0a0a0000(eax):
    – 0x3000143d ;pop esi ;ret 
    – 0x30002465 ;xchg esp,eax ;retn 0c28b
    – payload
    • 0x0a0a0000+0x0c28b+4(esp):
    – 0x300010ed ;(pop esi ;ret)
    – 0x30002071 ;jmp [esi + 0xffffff83] (virtualprotect)
    – 0x0a0a00a8 ;ret payload start
    – 0x0a0a00a8 ;lpAddress(payload start addr)
    – 0x00010000 ;dwSize(payload size)
    – 0x00000040 ;flNewProtect(RWE)
    – 0x0a0a2210 ;lpFlOldProtect(mem can write)
最后，总算可以在office 2010弹一把计算器了：  
****
**总结**
通过本文详细的分析，我们展示了如何通过一个简单的堆内存越界写漏洞在office程序里执行任意代码。虽然本文采取的利用方式略有繁琐且利用的效果稍有不足之处，但是整体的技术框架还是比较经典，具有一定的借鉴意义，很多地方值得好好的思考。这个漏洞的利用思路以及对应的检测方法具有显著的多样性，漏洞的本质是由于计算结果缺少校验导致内存可以越界写数据，从这一点也可以看出程序开发人员具备认真严谨的编程习惯与良好的安全意识是多么的重要。
****
**传送门**
* * *
[**【技术分享】手把手教你如何构造office漏洞EXP（第一期）**
****](http://bobao.360.cn/learning/detail/3003.html)
[**【技术分享】手把手教你如何构造office漏洞EXP（第三期）**
****](http://bobao.360.cn/learning/detail/3049.html)
[**【技术分享】手把手教你如何构造office漏洞EXP（第四期）**](http://bobao.360.cn/learning/detail/3246.html)
**[](http://bobao.360.cn/learning/detail/3003.html)**