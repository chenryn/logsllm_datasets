Timelion允许使用自己的查询语法在数据源上运行查询。
JavaScript代码可以从页面的URL片段读取查询，并将查询传递给服务器端。结果，攻击者可以在未经受害者同意或不知情的情况下执行恶意查询。
**Modx：**
在Modx中发现了20个可伪造的请求，可以通过两种不同的方式对其进行利用。首先，Modx的JavaScript从页面URL的查询参数中获取URL字符串，并逐字使用该字符串来提交带有有效反CSRF令牌的异步请求。与SuiteCRM和SugarCRM相似，攻击者可以向状态更改服务器端端点伪造请求。同样，在一个可伪造的请求中，Modx在客户端请求中复制页面的URL参数，该参数会在响应中反映出来并插入到DOM树中，从而使攻击者可以使用客户端CSRF来安装客户端XSS。根据手动评估，攻击者只能通过客户端CSRF来利用客户端XSS。
**Odoo：**
发现了一个可伪造的请求，该请求使用URL片段的id参数加载数据库实体。发现服务器在未经正确验证的SQL查询中使用此参数，从而导致SQLi漏洞。注意到由于使用了反CSRF
Token，如果不先利用客户端CSRF漏洞，就很难通过直接请求来利用SQLi漏洞。
**Shopware：**
发现页面加载时Shopware发送了20个可伪造的请求。该代码将页面的URL哈希片段映射到传出请求的不同部分。首先，代码将哈希片段的第一个片段用作传出请求的URL路径。然后，它将剩余的片段用作传出请求正文的参数。例如，这使攻击者可以删除商店目录中的产品。
### F.动态快照影响
本文设计并进行了其他实验，以显示动态快照对漏洞检测和HPG构建的影响。
#### （1）漏洞检测
使用JAW-static重复了评估，并将结果与JAW进行了比较。 JAW-static总共发现了48,543个请求，其中11,878个据报告是可伪造的。通过比较差异，观察到JAW-static已检测到840个较少的可伪造请求（即下限为+ 7.07％漏报性）。在840个漏报中，有161个是本研究发现了利用的漏洞，即，JAW-static未检测到JAW检测到的可利用客户端CSRF漏洞的79.3％。此外，JAW-static报告了另外17个不容易受到攻击的案例（即误报率下限为+
0.15％）。手动检查了所有误报和漏报案例，以发现潜在原因。
**误报（FP）：** 在17个FP中，有12个是由于不存在动态获取的代码（即，通过动态插入脚本标签）而导致，在动态代码中，污染变量的值发生了变化。
JAW中消除了此类FP，因为它利用DOM树和HTTP消息监视程序执行。然后，在这17种情况中，有3种是由于随后使用具有动态生成的字符串的动态代码评估构造删除了事件处理程序。最后，最后两个FP发生是由于从DOM树中删除了元素，因此隐式删除了它们的事件处理程序。同样，此类FP不会随JAW一起发生，因为它在运行时监视触发的事件及其处理程序。
**漏报（FN）：**
观察到几乎有一半的FN（即405）是由于漏洞位于动态加载的代码中而发生的。对于78个和7个FN，针对DOM查询的指向分析不准确，因为分别需要DOM树的状态和环境变量进行此类分析。剩下的350个FN源自JavaScript程序使用setTimeout和eval通过在运行时生成代码来触发事件。
#### （2）HPG的构造
总计，JAW静态生成了4,836个HPG的498,054,077个节点和639,323,601个边，比JAW（漏报）少10,756,335个节点（-2.11％）和13,338,972个边（-2.04％）。在所有丢失的边中，有1,048,172个是对建模事件至关重要的ERDDG边，其余的12,290,800个边是AST，CFG，PDG和IPCG边。此外，JAW-static错过了16,710个边属性（在ERDDG注册边上设置），这些边属性标记了是否在运行时触发了事件处理程序，而未使用静态分析进行标记。  
进行了其他实验之后，记录了JAW无法映射到其代码行的触发事件。
JAW总共在运行时观察到了4,974个HPG中的51,974个事件，其中34,808个已经被静态分析标记并被动态触发。其余的17,166个事件在运行时触发，而未被纯静态分析捕获。在17,166个事件中，JAW无法在代码中找到456个事件的相应事件处理程序（0.88％），这表明HPG中的FN节点和边。手动分析显示，大多数情况（387个事件）的原因是使用eval和setTimeout函数以及动态构造的字符串来触发事件。由于代码的动态加载以及JAW不监视的方式（例如，从iframe内部加载代码），其余69个事件未映射。
最后，当执行DOM查询的指向分析时，评估DOM树快照的使用所引入的FP和FN边。
JAW总共在4,836个HPG中遇到了241,428个DOM查询选择器，其中127个选择器（0.05％）中JAW不精确地解析了查询所指向的DOM元素。为了确定ERDDG派发边，JAW将总共87,340对DOM查询选择器的指针相互比较（即，在一个DOM查询选择器上分派的事件链接到其事件处理程序，该事件处理程序使用另一个查询选择器进行事件注册）。评估表明，JAW在87,212个案例（决策准确度为99.85％）中准确地决定了连接分发站点与注册站点之间的分发边，其中有56,923个真阳性和30,289个真阴性。在其余的128种情况下，JAW决定是否创建边线是不准确的，有94
FN和34 FP边（决策不准确度为0.15％）。
观察到查询选择器可能会出现这样的FP和FN边，这些选择器在页面加载的53.7毫秒（平均）之内（最大）为92.5毫秒。比所有查询选择器的平均访问时间低十倍，即559.2毫秒。在本实验中，使用运行时程序工具获取了评估JAW在HPG施工中的准确性的基本事实。但是，这样的技术会带来性能上的损失，并且不适用于大型HPG（例如，在模型构建和漏洞检测中），DOM快照对JAW
FP和FN边的影响可以忽略不计。
## 0x06 讨论
**客户端可伪造请求的属性：**
在本文中表明82％的Web应用程序至少具有一个带有客户端可伪造请求的网页，可利用该网页发起CSRF攻击，这表明可伪造请求很普遍。还展示了客户端CSRF可用于发起其他攻击，例如XSS和SQLi，这些攻击无法通过传统的攻击媒介进行装载。然后，对可伪造请求的分析表明某些客户端CSRF模板比其他客户端更普遍，例如，在28.7％的易受攻击的应用程序中，攻击者可以覆盖请求正文中的参数。
**脆弱应用程序的特性：**
发现测试平台上的106个目标中有39个是单页应用程序（SPA），即36.7％。手动检查了87个易受攻击的目标，发现其中有44.8％是SPA的目标。另外，在17.9％的经过测试的SPA中发现了漏洞利用（§5.5）。这揭示了客户端CSRF实例在SPA应用程序中更为普遍的事实。
**控制权转移和运行监视：**
评估表明，动态信息使控制路径的传输增加了0.26％。尽管评估可以忽略不计，但评估显示，动态信息对于识别87个易受攻击的应用程序中的14个和7个可利用的应用程序中的3个的可伪造请求至关重要（分别增加了+
19.1％和+ 75％）。
**漏洞源自相同代码：**
对515个可伪造的HTTP请求的手动分析显示，每个漏洞都源自跨多个页面使用的同一代码的不同副本。每个应用程序的漏洞模板范围为一到四个，而大多数应用程序（即78.1％）只有一个模板。这些事实表明，开发人员倾向于在不同页面上重复相同的错误。
**误报：**
观察到，将状态值与传统的静态分析一起使用将有助于消除虚假的执行轨迹。但是广泛的手动验证发现，由于动态调用函数中此语句的指针分析不准确，因此1/516请求是错误肯定的。观察到这样的请求正在使用源自DOM树的数据值，这意味着DOM-READ可伪请求类别的1/83请求可能是误报。计划在将来通过将this关键字的对call敏感的解析合并到JAW中来解决此缺点。
**局限性：**
本文中发现的漏洞是本研究模型和遍历所捕获的漏洞。但是，由于模型的构建受到用于构建属性图的单个静态分析工具，例如CFG，PDG。由于JavaScript程序的流性质和JavaScript动态代码生成功能，通过静态分析准确地构建这些模型是一项具有挑战性的任务。与先前的工作类似，只要字符串参数可以静态重建，JAW就会提取由动态结构执行的代码，即eval，setTimeout和new
Function(
)。作为未来的工作，计划用改良的JavaScript引擎（例如VisibleV8）替换扩展，以更好地支持反射和这种动态构造，并最大程度地减少函数挂钩的潜在副作用，尤其是对于到事件处理程序。此外，本文中发现的漏洞会影响JAW通过爬虫到达的那些页面。但是，爬取是一项艰巨的任务，并且JAW可能丢失了带有易受攻击代码的页面。为了扩大覆盖范围，计划为其他爬网程序的平滑集成提供支持。
**增量静态分析：**
JAW可以通过预先构建的符号模型将分析客户端JavaScript程序所需的工作减少60％。查看独特的应用程序代码时，发现页面之间也共享了很大一部分代码。例如，4,836个页面总共包含104,720个应用程序脚本，其中只有4,559个是唯一的，这表明不同网页的共享代码可以一次建模，并可以通过增量程序分析进行重用，这是计划在将来解决的问题。
## 0x07 总结
在本文中，JAW是用于检测和分析客户端CSRF漏洞的第一个工具。
JAW的核心是HPG的新概念，它是用于客户端JavaScript程序的规范，静态+动态模型。
对JAW的评估发现了12,701个可伪造的客户端请求，这些请求影响了87个Web应用程序。
对于其中的203个，针对七个应用程序创建了一个可利用的漏洞，可用于破坏数据库完整性。 本文分析了可伪造的请求，并确定了25种不同的请求模板。
这项工作已经成功地证明了范例检测客户端CSRF的功能。