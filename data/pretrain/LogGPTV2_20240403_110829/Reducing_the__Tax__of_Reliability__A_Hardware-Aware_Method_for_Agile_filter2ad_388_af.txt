outperforms our optimized system by only 9.3% on average, 
since  it  doesn’t  need  to  perform  and  manage  file  system 
journal for each data persistence. However, as we discussed 
in  Section  I,  the  integrity  of  file  system  is  crucial  for  user 
data.  It  is  worth  to  trade  less  than  10%  performance  for 
keeping the user data safe and sound. 
We  also  evaluate  the  performance  of  SQLite  database, 
because mobile apps highly lean on SQLite for management 
of  their  private  data.  As  described  in  Section  III.C,  every 
database  operation  usually  involves  multiple  synchronous 
writes  for  the  atomicity  of  database  operations.  Fig.  15 
shows the results of experiment on SQLite benchmark [29]. 
For insert, update and delete operations upon SQLite data-
base, the optimized system outperforms baseline system in 
the TPS (transactions per second) by 15%, 28.5% and 22% 
respectively.  
d
n
o
c
e
S
r
e
P
n
o
i
t
c
a
s
n
a
r
T
350
300
250
200
Baseline Optimized
Baseline w/ Metadata Intensive w/ Data Intensive
1.4
1.2
1
0.8
0.6
e
c
n
a
m
r
o
f
r
e
P
d
e
z
i
l
a
m
r
o
N
Figure 15. Speedup of 
SQLite Benchmark. 
Figure 16. Performance of Mobile Work-
loads with Metadata Intensive and Data 
Intensive Background Jobs 
D. Concurrent Multi-Programs
Note  that  user  may  run  apps  in  foreground  and  back-
ground concurrently. The performance impact on I/O stack 
caused by background jobs can be modeled as introducing 
extra  data  and  metadata  blocks  in  data  persistence  path  of 
foreground job. To evaluate the optimized system in concur-
rent scenario, we choose a metadata intensive program and a 
data intensive program as background jobs. 
 fdtree[30] is a metadata intensive benchmark, which cre-
ate  files/folders  in  a  destination  directory  and  delete  them 
recursively. We execute each app while fdtree is running in 
background. The results are shown in Fig. 16. The average 
improvement over the baseline is 16.5%, which means the 
optimized system can preserve the performance boost even 
if a metadata intensive job is running in background. This is 
82
because  the  large  amount  of  metadata  can  be  reduced  by 
applying journal coalition scheme. Similarly, we use a data 
intensive program as background job and repeat the experi-
ments,  where  the  data  intensive  job  is  circularly  writing 
4KB data to a 4GB file. The results in Fig. 16 indicate the 
optimized system shows no performance improvement with 
data  intensive  background  job.  The  reason  is  in  this  case, 
there is little redundancy to exploit, since the persistence of 
large amount of data blocks dominants the runtime. Consid-
ering  the  real  background  jobs  should  introduce  a  mix  of 
data  and  metadata  blocks,  the  optimized  system  shows  a
performance boost between these two extreme cases. 
E. Overhead of Metadata Check-pointing 
In  usual,  checkpoint  operation  is  asynchronous  except 
that  when  there  are  no  available  blocks  in  journal  region, 
journal thread must synchronously wait for check-pointing. 
But  considering  that  check-pointing  will  become  less  fre-
quent  when  journal  region  becomes  larger,  the  overhead 
may be alleviated by expanding journal region size. There-
fore, we vary the journal region size and evaluate the per-
formance  variety  compared  to  the  default  case  (journal  re-
gion is 256MB). In this experiment, we choose SQLite and 
Facebook as examples. In fact, the results on other bench-
marks  are  similar.  From  Fig.  17,  we  can  observe  that  the 
performance improves as the journal region size increases, 
but  the  improvement  ceases  when  the  journal  size  reaches
512MB. It implies the overhead on metadata check-pointing 
can be mitigated by expending journal region. This solution 
is  feasible  under  the  trend  that  storage  capacity  becomes
larger and larger. 
d
e
z
i
l
a
m
r
o
N
e
c
n
a
m
r
o
f
r
e
P
1.05
0.95
0.85
SQLite-insert
SQLite-update
SQLite-delete
facebook
32MB
64MB
128MB
Journal region size
256MB
512MB
Figure 17. Performance of SQLite (Insert, Update, Delete) and Face-
book When Varying Journal Region Size. 
F. Power Consumption 
Power consumption of smartphone is a key factor of the 
user  experience.  We  measure  the  system  power  consump-
tion  by  chaining  a  Watt’s  Up  Pro  [31]  meter  in  the  power 
supply of the Odroid-XU4 board. The results show that the 
differences among the average power consumption between 
the baseline system and optimized system are less than 1%. 
It  proves  that  dynamically  enabling  reliable  write  and 
packed  write  incurs  little  power  consumption  on  mobile 
systems.  Recovery Correctness and Overhead 
    To verify the correctness of recovery, we conduct exper-
iments by manually cutting off the power supply of Odroid-
XU4  board  when  the  PostMark  [32]  benchmark  is  execut-
ing. PostMark is a data-intensive benchmark, whose execu-
tion can be divided into three phases: create files, write to 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:22:09 UTC from IEEE Xplore.  Restrictions apply. 
them and deleted all files. We use the large data set (shown 
in Table 5), so that a considerable pressure is set on the op-
timized system. Also, the large data set leads to long execu-
tion time of each phase, so that we have enough time to cut 
off  the  power.  Then,  we  restore  the  power  and  restart  the 
system.  The  recovery  procedure  depicted  in  Section  IV  is 
executed  in  the  file  system  mounting  stage  of  Android 
startup. After the system is fully booted, we use e2fsck [33] 
to check the integrity of the recovered file system. We re-
peat this procedure 10 times in each of the three phases of 
PostMark  execution.  Results  show  that  the  recovered  file 
system can pass the check of e2fsck every time. 
File 
Number 
Table 5. PostMark Parameters 
Transaction 
Number 
10000 
 The  overhead  of  re-
covery  derives  from  that 
the  data  blocks  in  main 
File Size 
file  system  region  must 
(MB) 
1000~10240  20000 
be  read  to  memory  for 
applying the metadata changes. We produce power interrup-
tion on the 2nd phase (write to file) of PostMark on the op-
timized file system and the baseline Ext4, and restart system 
to  measure  the  time  of  file  system  mounting.  They  are 
0.049s  and  0.130s  on  baseline  system  and  the  optimized 
system  respectively.  However,  the  Android  system  boot 
time is 27s in total. Thus, compared to the time cost of self-
checking and initializing various system services at Android 
boot stage, the added overhead is negligible. 
VII.RELATED WORK 
    Many  recent  efforts  have  contributed  to  mitigate  the 
overhead of file system journal. We classify these endeavors 
into four categories. 
    I/O Software Stack: By analyzing the I/O traces of pop-
ular smartphone apps, studies [5, 6] observe that excessive 
amount of synchronous writes and storage cache flushes are 
generated  when  SQLite  performs  database  transactions  on 
the Ext4 file system. To resolve this anomaly, [6] conducts a 
throughout  investigation  on  different  combinations  of  file 
systems and database journal  modes, and presents an opti-
mal  configuration  of  I/O  stack  components  to  make  data-
base  transactions  harmonic  with  file  system  journaling.  [7, 
10] try to solve the same problem by modifying the internal 
structures  of  SQLite  database.  [8]  purposes  a  file-adaptive 
method to dynamically adjust Ext4 journaling mode for files 
with different I/O patterns. Note that all these studies focus 
on coordinating different software components to minimize 
the performance overhead in the I/O stack. On the contrary, 
our  work  exploits  hardware  features  to  eliminate  the  over-
head  of  file  system  journaling,  which  is  orthogonal  to  the 
previous works. 
Transactional  Flash:  Prior  works  [22,  34,  35]  leverage 
customized  SSDs  to  alleviate  the  file  system  and  database 
journaling overhead. All of them exploit the copy-on-write 
nature of flash medium and make FTL handle the transac-
tional updates. The FTL can complete transactional updates 
to a vector of blocks faster than purely software based ap-
proaches.  The  quantitative  improvement  can  be  estimated 
83
through  the  data  series  of  “no-journal”  shown  in  Fig.  13. 
Considering that FTL does extra work to achieve atomicity, 
minute  performance  overhead  remains  comparing  to  the 
“no-journal”  results.  This  complies  with  the  results  shown 
in  [34].  However,  the  abovementioned  mechanism  largely 
targets on the enterprise SSDs equipped with capable micro-
controller and abundant DRAM [36], which makes feasible 
to  store  extra  logs/tables  and  maintain  the  atomicity  of  a 
bunch of writes in a high throughput. This hardware scale-
up would raise power consumption and cost of end devices, 
which  are  essential  factors  of  consumer  electronics  [37]. 
Moreover,  the  existing  applications  have  to  be  patched  to 
enable the transactional sematic [38]. Compared to that ap-
proach, our design and implementation is based on an ener-
gy  and  cost  efficient  flash  storage,  transparent  to  applica-
tions,  and  can  benefit  billions  of  eMMC-based  devices  in-
tuitively and instantly. 
    Non-Volatile Memory: Prior works [39, 40] explore the 
usage  of  non-volatile  memory  to  reduce  the  consistency 
overhead. The rationale is to exploit the non-volatile feature 
of  NVM  upon  power  lost  so  that  the  file  system  metadata 
could  be  placed  in  there  without  extra  hardware/software 
efforts  to  prevent  file  system  inconsistency  after  system 
crash.  However,  as  of  today,  non-volatile  memory  has  not 
been widely deployed due to issues such as interface com-
patibility  and  cost.  Therefore,  non-volatile  memory  based 
approaches are not feasible to benefit nowadays widely-used 
mobile devices. 
    DRAM Based Solution: The prior work [28] proposes to 
use the battery backed DRAM as quasi non-volatile memory 
so  that  file  system  metadata  is  quasi-safe  when  they  are 
placed  in.  Note  that  power  failure  is  one  of  the  many  rea-
sons that cause system crash. System bugs [3], unexpected 
execution path [41] or user misbehaviors may cause system 
crashes  and  DRAM-based  solutions  cannot  preserve  im-
portant metadata in above mentioned situations. 
VIII.CONCLUSION 
In this study, we conduct a detailed breakdown analysis 
of the existing data persistence path in mobile systems, and 
identify the connection between the performance overheads 
and  reliability  characteristics  of  storage  hardware.  In  addi-
tion,  we  leverage  eMMC  features  including  reliable  write, 
packed command and FUA to improve the efficiency of data 
persistence  while  preserving  reliability.  Evaluation  results 
show  that  our  solution  improves  performance  of  mobile 
applications  by  5-31%.  We  believe  that  leveraging  eMMC 
hardware features in system level optimization will open a 
new door for future research. 
ACKNOWLEDGMENT 
We thank all reviewers and Amer Qouneh for providing 
valuable  feedback  to  our  paper.  This  work  is  supported  in 
part  by  NSF  grants  1527535,  1423090,  1320100,1117261, 
0937869, 
0834288, 
0811611, 0720476, by SRC grants 2008-HJ-1798, 2007-RJ-
0845721(CAREER), 
0916384, 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:22:09 UTC from IEEE Xplore.  Restrictions apply. 
1651G,  by  Microsoft  Research  Trustworthy  Computing, 
Safe  and  Scalable  Multicore  Computing  Awards,  and  by 
three IBM Faculty Awards. 
References 
[1]  Samsung Begins Mass Producing Industry’s 128GB Embedded 
NAND Storage: 
http://www.samsung.com/global/business/semiconductor/news-
events/press-releases/detail?newsId=12062. 
I dropped my droid... won’t turn on! | Android Forums: 
http://androidforums.com/threads/i-dropped-my-droid-wont-turn-
on.110622/. 
[2] 
[3]  Apple says working on fix for random iOS 7 crashing issue: 
http://appleinsider.com/articles/14/01/22/apple-says-fix-in-the-works-
for-random-ios-7-crashing-issue. 
[4]  How To Reboot Your Frozen Smartphone | Lifehacker Australia: 
http://www.lifehacker.com.au/2013/03/how-to-reboot-your-frozen-
smartphone/. 
[5]  Kisung Lee and Youjip Won. Smart layers and dumb result. In 
Proceedings of the 10th ACM International Conference on Embedded 
software (EMSOFT), 2012. 
[6]  Sooman Jeong, Kisung Lee, Seongjin Lee, Seoungbum Son, and 
Youjip Won. I/O Stack Optimization for Smartphones. In 
Proceedings of USENIX Conference on Annual Technical Conference 
(ATC), 2013. 
[7]  Wook-Hee Kim, Beomseo Nam, Dongil Park, and Youji Won. 
Resolving Journaling of Journal Anomaly in Android I/O: Multi-
Version B-tree with Lazy Split. In Proceedings of the 12th USENIX 
Conference on File and Storage Technologies (FAST), 2014. 
[8]  Kai Shen, Stan Park, and Meng Zhu. Journaling of Journal Is 
(Almost) Free. In Proceedings of the 12th USENIX Conference on 
File and Storage Technologies (FAST), 2014. 
[9]  Vijay Chidambaram, Thanumalayan Sankaranarayana Pillai, Andrea 
C Arpaci-Dusseau, and Remzi H Arpaci-Dusseau. Optimistic crash 
consistency. In Proceedings of the Twenty-Fourth ACM Symposium 
on Operating Systems Principles (SOSP), 2013. 
[10]  Wongun Lee, Keonwoo Lee, and Hankeun Son. WALDIO : 
Eliminating the Filesystem Journaling in Resolving the Journaling of 
Journal Anomaly. In Proceedings of the 2015 USENIX Annual 
Technical Conference (ATC), 2015. 
[11]  Mingming Cao. Forking ext4 filesystem and JBD2. Linux kernel 
mailing list, 2006. 
[12]  Android 2.3 Gingerbread to use Ext4 file system - The H Open: News 
and Features: http://www.h-online.com/open/news/item/Android-2-3-
Gingerbread-to-use-Ext4-file-system-1152775.html. 
[13]  Datalight: 
http://www.datalight.com/solutions/technologies/emmc/what-is-
emmc. 
[14]  eMMC: https://www.jedec.org/standards-documents/technology-
focus-areas/flash-memory-ssds-ufs-emmc/e-mmc. 
[15]  The-aio Co. 2015 nvramos, 2015. 
[16]  JEDEC eMMC STANDARD v5.1, 2015. 
[17]  Method and system for managing flash write, 2011. 
[18]  Flash memory management method that is resistant to data corruption 
by power loss, 2006. 
[19]  Storage Options | Android Developers: 
http://developer.android.com/guide/topics/data/data-storage.html. 
[20]  Ext3 Data=Ordered vs Data=Writeback mode - Ext4: 
https://ext4.wiki.kernel.org/index.php/Ext3_Data%3DOrdered_vs_Da
ta%3DWriteback_mode. 
[21]  ODROID | Hardkernel: 
http://www.hardkernel.com/main/products/prdt_info.php?g_code=G1
43452239825. 
[22]  Woon-hak Kang, Sang-won Lee, Bongki Moon, Gi-Hwan Oh, and 
Changwoo Min. X-FTL: Transactional FTL for SQLite Databases. In 
Proceedings of the International Conference on Management of Data 
(SIGMOD), 2013. 
[23]  Daniel Campello, Hector Lopez, Ricardo Koller, Raju Rangaswami, 
and Luis Useche. Non-blocking Writes to Files. In 13th USENIX 
Conference on File and Storage Technologies (FAST), 2015. 
[24]  Sooman Jeong, Kisung Lee, Jungwoo Hwang, Seongjin Lee, and 
Youjip Won. Androstep: Android storage performance analysis tool. 
In Proceedings of the First European Workshop on Mobile 
Engineering, Aachen, Germany, 2013. 
[25]  strace(1): trace system calls/signals - Linux man page: 
http://linux.die.net/man/1/strace. 
[26]  monkeyrunner | Android Developers: 
http://developer.android.com/tools/help/monkeyrunner_concepts.html
. 
[27]  Hyojun Kim, Nitin Agrawal, and Cristian Ungureanu. Revisiting 
storage for smartphones, p. 17, Feb. 2012. 
[28]  Hao Luo, Lei Tian, and Hong Jiang. qNVRAM: quasi Non-Volatile 
RAM for Low Overhead Persistency Enforcement in Smartphones, 
6th USENIX Workshop on Hot Topics in Storage and File Systems 
(HotStorage), 2014. 
[29]  MobiBench(Benchmark) - Android Apps on Google Play: 
https://play.google.com/store/apps/details?id=esos.MobiBench&hl=e
n. 
[30]  High Performance Computing: Scalable I/O Project: 
https://computing.llnl.gov/?set=code&page=sio_downloads. 
[31]  Watts Up? Plug Load Meters: 
https://www.wattsupmeters.com/secure/products.php?pn=0. 
[32]  Postmark: http://www.filesystems.org/docs/auto-pilot/Postmark.html. 
[33]  e2fsck(8): check ext2/ext3/ext4 file system - Linux man page: 
https://linux.die.net/man/8/e2fsck. 
[34]  Xiangyong Ouyang, David Nellans, Robert Wipfel, David Flynn, and 
Dhabaleswar K Panda. Beyond block I/O: Rethinking traditional 
storage primitives. In International Symposium on High-Performance 
Computer Architecture (HPCA), 2011. 
[35]  Vijayan Prabhakaran, Thomas L Rodeheffer, and Lidong Zhou. 
Transactional Flash. In 8th USENIX Symposium on Operating 
Systems Design and Implementation (OSDI), 2008. 
[36]  Peter Desnoyers. What Systems Researchers Need to Know About 
NAND Flash, Proceedings of the 5th USENIX Conference on Hot 
Topics in Storage and File Systems (HotStorage), p. 6, 2013. 
[37]  Why don’t any Android phones use PCIe/NVMe memory? : Android: 
https://www.reddit.com/r/Android/comments/4py7it/why_dont_any_a
ndroid_phones_use_pcienvme_memory/#bottom-comments. 
[38]  Changwoo Min, Woon-Hak Kang, and Taesoo Kim. Lightweight 
Application-Level Crash Consistency on Transactional Flash Storage. 
In Proceedings of the 2015 USENIX Annual Technical Conference 
(ATC), 2015. 
[39]  Dohee Kim, Eunji Lee, Sungyong Ahn, and Hyokyung Bahn. 
Improving the storage performance of smartphones through 
journaling in non-volatile memory, IEEE Transactions on Consumer 
Electronics, 2013. 
[40]  Eunji Lee, Hyokyung Bahn, Sam H.Noha, and Sh Noh. Unioning of 
the Buffer Cache and Journaling Layers with Non-volatile Memory, 
11th USENIX Conference on File and Storage Technologies (FAST), 
2013. 
[41]  Lanyue Lu, Yupu Zhang, Thanh Do, Samer Al-kiswany, Andrea C 
Arpaci-dusseau, and Remzi H Arpaci-Dusseau. Physical 
Disentanglement in a Container-Based File System. In Proceedings of 
the 11th USENIX conference on Operating Systems Design and 
Implementation (OSDI), 2014. 
84
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:22:09 UTC from IEEE Xplore.  Restrictions apply.