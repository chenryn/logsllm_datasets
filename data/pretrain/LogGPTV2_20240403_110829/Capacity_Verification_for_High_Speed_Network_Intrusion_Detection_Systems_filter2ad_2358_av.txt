Fig. 9. M2D2 IP Events, TCP Events, UDP Events and HTTP Events
An IP datagram is a sequence of messages whose payload is a triple
(as, ad, p(cid:2)), where as, ad ∈ N are respectively the source and destination ad-
dresses of the IP datagram. The messages in the sequence represent the route of
the datagram.
An IP session is a sequence of IP datagrams and represents a conversation
between two hosts.
An UDP datagram is an IP datagram whose payload is a couple (ps, pd),
where ps,pd ∈ N are respectively the source port and the destination port of the
UDP datagram. An UDP session is a couple of UDP datagrams (request and
response).
Basically, a TCP segment is an IP datagram whose payload is a tuple
(ps,pd,s,a,F ,p(cid:2)(cid:2)), where ps,pd,s,a ∈ N are respectively the source port, the des-
tination port, the sequence number and the acknowledgement number, F is a
set of ﬂags and p(cid:2)(cid:2) is the payload of the TCP segment. A TCP session is an
IP session with constraints over the datagram attributes which are described in
Vigna’s model.
In the same way, a M2D2 TCP event (resp. an UDP event) is a TCP segment
(resp. an UDP datagram) in Vigna’s model.
128
B. Morin et al.
We do not model sessions in M2D2 yet because most current NIDS do not
work at the session level. However, extending M2D2 with sessions is straightfor-
ward since the M2D2 events are conceptually identical to the concepts found in
Vigna’s model.
An IP event is linked to its content with the ipayload function. In the same
way, TCP or UDP event are linked to their content (an application protocol like
HTTP for instance) with the tpayload function.
HTTP Events. An HTTP event models an HTTP interaction between a client
and a server. HTTP event attributes potentially reﬂect a complete HTTP inter-
action. Thus, we use the httpmeth, url, and status functions. Note that if only
a part of the interaction may be analyzed (that is the case for NIDS, which may
only have access to a part of the interaction), then a special value is assigned to
the event attribute.
HTTP Log events. Log events correspond to entries in HTTP server logs. An
HTTP server log entry contains an HTTP event, and an identiﬁer of the requester
(either its IP address or its host name). That mix of information coming from
two diﬀerent protocol layers raises a modeling problem. We thus had to introduce
a speciﬁc kind of events, the HTTP Log events. That kind of events reﬂect the
contents of a HTTP server log.
3 Alert Correlation Using M2D2
A ﬁrst step towards alert correlation is alert aggregation. It consists in grouping
alerts following various criteria. In this section, we propose three relevant exam-
ples of aggregation methods which use many M2D2 concepts. As these concepts
are deﬁned in an unambiguous way, the aggregation methods are rigorously ex-
pressed. M2D2 contribution to alert correlation resides in the use of relations
between vulnerabilities and topology, between topology and security tools, as
well as between security tools and vulnerabilities to model alert aggregation
methods.
3.1 Aggregation of Alerts Referring a Single Host
The goal of the common target aggregation function (cf ﬁgure 10) is to group
alerts referring to a given target host. This set is made of two subsets: one con-
tains the alerts generated by HIDS running on the host, and the other contains
alerts generated by NIDS having detected malicious IP events destined to the
host.
As HIDS monitor a single host (cf ﬁgure 7, monitored host), the set of alerts
referring to a host is equal to the set of alerts generated by the HIDS monitoring
the host. We call this aggregation function hids target (cf ﬁgure 10).
M2D2: A Formal Data Model for IDS Alert Correlation
129
Functions & Relations
hids target ∈ H ↔ EA
nids target ∈ H ↔ EA
common target ∈ H ↔ EA
belongs to host ∈ I → H
Properties
hids target = monitored host
nids target = addr; ip dst
i belongs to host h ⇐⇒ i ∈ h
−1; alert generator
−1
−1; causes
common target = hids target ∪ nids target
Fig. 10. The common target aggregation function referring the same target host
sub conﬁg ∈ ran(aﬀects) ↔ ran(conﬁguration)
Functions & Relations
EA
relative vulns ∈
EA
harmful ∈
↔ VN
↔ H
Properties
v sub conﬁg c ⇐⇒ v ⊂ c
relative vulns = reportname; refersto; equiv
harmful = relative vulns; vulname
−1; aﬀects; sub conﬁg; conﬁguration
−1
Fig. 11. The successful attacks identiﬁcation function
An intermediate relation is required to uniquely identify a host from a net-
work interface (this is a function because hosts partition the interface set, cf
ﬁgure 10). We call this function belongs to host (cf 16).
NIDS monitor an interface which has access to a stream of network events,
some of which being destined to the host under consideration. The aggregation
function, nids target (cf ﬁgure 10) consists in aggregating all the alerts caused
by IP events whose IP destination address maps to one of the host interfaces.
3.2
Identiﬁcation of the Hosts Vulnerable to an Attack Occurrence
The successful attack identiﬁcation function, called harmful (cf ﬁgure 11), applies
to a single alert and gives the set of hosts on which the attack may work. In
other words, it gives information about the success of the attack.
An attack may be successful if one of the conﬁgurations aﬀected by the
vulnerability which is exploited by the attack really exists on some hosts in the
information system. For example, an attack exploiting a ProFTP vulnerability
against a WU-ftp server may not work. Thus the attack severity is low. That does
130
B. Morin et al.
not mean that the attack should not be reported (it is still an attack attempt),
but its severity may be lowered.
A vulnerability v ∈ V exists on a host if the host conﬁguration is a superset
of at least one of v vulnerable conﬁgurations. Thus, we introduce the sub conﬁg
(cf ﬁgure 11) relation, which maps all the vulnerability conﬁgurations with all
the host conﬁgurations. sub conﬁg provides all the vulnerabilities exhibited by
a given host, and sub conﬁg−1 provides all the hosts which exhibit a given
vulnerability. Building and updating the sub conﬁg relation in batch mode is
required for eﬃciency because evaluating existing vulnerabilities in real time
would be prohibited.
We introduce the relative vulns relation which applies to an alert and maps
the vulnerability names the alert report name refers to. From an alert relative
vulnerability set, we get the corresponding CVE vulnerability subset, and then
the vulnerable conﬁgurations set is extracted. Thanks to the sub conﬁg relation,
we get the set of vulnerable host conﬁgurations. Lastly, applying conﬁguration−1
to the host conﬁguration set provides the set of hosts which are vulnerable.
3.3 Detecting False Positives
In this section we present a correlation function which is a way to detect false
positives. When an IDS generates an alert, it is relevant to check if all the IDS
which were able to detect the events causing the alarm did generate an alert too.
When an IDS generates an alert, a simple sanity check is to verify that others
able to both process the events and create the alert did so. If this constraint is
veriﬁed, then the alert likelihood is reinforced. If not, the proper behavior of all
IDSes should be checked to decide whether the one sending the alert is providing
the wrong diagnosis or whether the others are misbehaving.
Let us consider an alert a ∈ EA. We ﬁrst need to identify the alerts which
are similar to a. That is, we need to know which alerts are caused by the same
set of events. Once we have the set of similar alerts, we can know which set
of IDS raised them. Finally, we have to compare this set with the set of IDS
which were able to detect the events (the ability of an IDS to detect events and
generate alerts depends on its topological visibility and its operational visibility
(cf section 2.4)).
In the following, we ﬁrst describe two methods to identify similar alerts.
We then show how to get the set of IDS which did react. Lastly, we propose a
function to get the potentially reactive IDS set (i.e the set of IDS which could
react to an attack).
Alerts similarity. In Howard’s classiﬁcation [14], an attack is a series of actions
taken by an attacker to achieve an unauthorized result. Events result from these
actions. As it has been described in section 2, one or more alerts may result
from every each event. Determining the likelyhood of an alert can be achieved
by enumerating the IDS which also generated an alert for a single action (be it
from an attack or from a legitimate action which is believed malicious). We call
M2D2: A Formal Data Model for IDS Alert Correlation
131
Deﬁnitions
ip= ∈ EIP ↔ EIP
∀i1, i2 ∈ EIP, i1
ip=i2 ⇐⇒
ip src(i1) = ip src(i2) ∧ ip dst(i1) = ip dst(i2)
∧ idt(i1) = idt(i2)
∧ |tstamp(i1) − tstamp(i2)| < ε
∃i3 ∈ EIP, such that i1 = i3 ∧ i2 = i3
OR
sim alert ip ∈ EA ↔ EA
Properties
ip= is an equivalence relation.
sim alert ip = (causes
sim alert ip[{a}] is the set of alerts which are caused by the same IP event as a.
−1; ip=; causes)
Fig. 12. Alerts caused by the same IP event
alerts caused by a single action similar alerts. Several ways to aggregate alerts
are possible, for example:
– aggregating alerts caused by the same event
– aggregating alerts referring to the same vulnerability
– aggregating alerts caused by events belonging to the same TCP/IP session
– aggregating alerts on a temporal relation basis
In the remainder of this section, we illustrate the ﬁrst two examples of similar
alerts aggregation methods.
Aggregating alerts through events. Several alerts can be generated from a single
event either because more than one triggers within the same IDS matches the
event (a trigger is a condition fulﬁllment leading an IDS to generate an alert), or
because more than one IDS have access to the event itself. Thus, alerts caused
by the same events should be aggregated. We call events causing an alert causal
events. It should be noted that two alerts do not need to have the same set of
causal events to be aggregated: alerts can be aggregated if they have at least
one causal event in common. For example, a suspicious HTTP request can be
detected by a NIDS (A) and by an application-based IDS (B). A alert is caused
by an HTTP event and the underlying network layers event. B alert is caused
by an HTTP event, which is part of a web server log occurrence. Thus, A and
B do not have the same set of causal events; the HTTP event is the only one
they have in common. However, A alert and B alert are aggregated because they
have one causal event in common.
As every alert comes along with its own causal event set, we need to deﬁne a
relation to compare events. Such a relation strongly depends on the timestamp
B. Morin et al.
132
sim alert vuln ∈ EA ↔ EA ∪ ES
sim alert vuln = relative vulns; refersto
−1; reportname
−1
Fig. 13. Alerts referring to the same vulnerability
reactive ids ∈ EA ↔ D
reactive ids = (sim alert ip ∪ sim alert vuln); alert generator
Fig. 14. Reactive IDS
of the events. Although distinct IDS alert timestamps (IDMEF analysertime)
may diﬀer, the timestamp of the causal events (IDMEF detecttime) should be
very close. Two events cannot have the same timestamps as clock synchroniza-
tion is impossible to achieve. This is why we impose two events to have close
timestamps (in ﬁgure 12, ε is a constant whose value is close to the maximum
gap existing between two synchronized clocks).
We recursively deﬁne the comparison relation between IP events, noted ip= (cf
ﬁgure 12). Two IP events are equal if they have the same attributes (destination
address, source address, identiﬁcation number) and close timestamps or if there
is another IP event which is equal to the two others. A recursive deﬁnition is
required here otherwise ip= would not be an equivalence relation due to the time
constraint. Equality relations for other types of events can be built in the same
way.
Applying the causes (ﬁgure 8) relation to an ip= equivalence class gives the
set of alerts which are caused by the same IP event. The sim alert ip (cf ﬁgure
12) is a function which applies to an alert, and gives a set of alerts which are
caused by the same IP event (if the alert is caused by an IP event, otherwise
this is the empty set).
Aggregating alerts through vulnerability. As a second example, we propose a way
to aggregate alerts generated by IDS which not only use distinct data sources,
but also use distinct alert naming conventions. Thus, we propose to group alerts
which refer to the same vulnerability (ﬁgure 13).
Let us consider an alert a ∈ EA. The set of a similar alerts is composed of
the alerts whose relative vulnerabilities (deﬁned in ﬁgure 11) are the same as a.
Reactive IDS. Reactive IDS are the IDS which have generated an alert because
of a single action. Actions are on the attacker’s side so we do not have access
to this concept. We only have access to the manifestations of actions, i.e events
and alerts. Thus, for a given alert a ∈ EA, the reactive IDS are the IDS which
have generated alerts similar to a. In the preceding paragraphs, we introduced
two examples of similar alert aggregation functions. The reactive IDS can be
M2D2: A Formal Data Model for IDS Alert Correlation
133
oper able ∈ EA ↔ D ∪ S
oper able = relative vulns; refersto
−1; canraise
−1
Fig. 15. Operationnaly-able IDS
topo able hids ∈ EA ↔ DH
topo able hids = alert generator; monitored host; monitored host
topo able nids ∈ EA ↔ DH
topo able nids = causes
topo able ∈ EA ↔ DH
topo able = topo able hids ∪ topo able nids
−1; ip dst; addr
−1
−1; belongs to host; monitored host
−1
Fig. 16. Topologically-able IDS
able ∈ EA ↔ DH
able = topo able ∩ oper able
Fig. 17. Potentialy reactive IDS
obtained by simply applying alert generator (cf ﬁgure 8) to the similar alerts.
We call this relation reactive ids (cf ﬁgure 14).
Potentially reactive IDS. A potentially reactive IDS is an IDS which is
both topologically and operationally able (see section 2.4) to detect an at-
tack. Topological and operational ability both apply to alerts: given an alert
a ∈ EA, operationally-able IDS (resp. topologically-able IDS) are IDS which are
operationally-able (resp. topologically-able) to generate an alert similar to a.
Given an alert a ∈ EA, the operationally-able IDS set is composed of the IDS
which can raise a report which refers to one of a relative vulnerabilities. This
function is formalized in ﬁgure 15.
Evaluating the topologically-able IDS faces two major pitfalls. The ﬁrst one is
that the topological visibility of an HIDS is limited to a single host, whereas the
topological visibility of an NIDS is not even limited to a static set of hosts. An
NIDS having access to a network stream of events depends on the route followed
by the datagrams. Thus, it is generally not possible to say that an NIDS has
access to the datagrams of such attack without knowing a priori the route taken
by the datagrams, and this information is not available.
The second pitfall is that an attack may concern more than a single host.
In other words, a set of events may be considered malicious only because of the
multiplicity of the targets (network probes are such examples). In such a case,
although an IDS is operationally able and topologically able to detect some part
of an attack, it may not generate an alert.
134
B. Morin et al.
Moreover, if an alert a ∈ EA is generated by an HIDS, no reliable conclusion
can be sketched about NIDS topological ability to detect the corresponding
attack: if the attack is launched locally, it has no network-side eﬀect ; if it is
launched remotely, no information about the route taken by the datagrams is
available
Thus, the set of topologically-able IDS is currently limited to the set of
HIDS. We propose two functions to obtain topologically HIDS set for a given
alert. The ﬁrst one is called topo able hids and applies to alerts generated by
HIDS and gives HIDS which monitor the same host. The second relation, called
topo able nids, applies to alerts generated by an NIDS and gives HIDS which
monitor the destination host of the underlying IP event which causes the alert
(cf ﬁgure 16).
Lastly, potentially reactive IDS are both topologically-able and operationally-