more records for variable updates and ﬁrst local update
tags. Indeed, these two types of records account for 90%
of all records that qpopper) had written to the log. These
results suggest once again a need for a more sophisticated
checkpointing algorithm that can help reduce the number
of variable update log records as well as a more intelligent
mechanism for choosing the restart points. The current
mechanism relies on information about local updates to
determine where restart points are, and consequently re-
quires generating a lot more ﬁrst local update records than
necessary. Ideally, such a mechanism should use depen-
dency analysis techniques such as slicing to ﬁnd out points
in the program that can eventually lead to a function that
reads external data. Only those points can be program’s
potential restart points.
In our next series of experiments we measured the
amount of ﬁle and network I/O activity performed by the
programs from our test suite. This information can help
answer the question of whether the ﬁle system and net-
work undo is indeed required for the repair process or
the programs can be repaired and continue their execu-
tion without ﬁle system and network undo. The results
are presented in Table 5. The results showed that 3 out
of 5 programs that we tested do not perform any ﬁle out-
put operations when serving a single client request. Our
analysis of the source code of the remaining two programs
showed that the ﬁle output operations performed by those
programs are used to create temp ﬁles and write logging
information. We believe that this information is not a crit-
ical part of program’s state and therefore leaving it after
Program
File IN
File OUT
Net IN
Net OUT
ghttpd
45
0
1
49
drcatd
319
0
3
320
named
0
0
1
1
qpopper
41
80
5
7
proftpd
13
63
11
61
Table 5. Network and ﬁle I/O activity for a
single client request as described in Table 3.
an attack will not bring the program into an inconsistent
state. The network output operations performed by the
programs are related to communicating with the client that
initiated the connection only. Therefore, if that client turns
out to be malicious there is no need to undo the effects of
network operations for such a client. These observations
allow us to conclude that ﬁle system and network undo
support is not really required for the network daemons that
we have studied.
5.2.
Experiences
We tried to compromise named,
ghttpd,
and
drcatd compiled in DIR-mode by using malicious code
from public databases [15, 5]. All these attempts failed
because the programs were able to detect and identify the
attacks. Moreover, two out of three programs could re-
pair themselves to the extent that allowed them to continue
normal execution. Below we describe our experiences of
applying DIRA to each of these programs in more detail.
BIND named inverse query vulnerability.
BIND
named version 8.1 has a bug in its inverse DNS query pro-
cessing function allowing the attacker to gain root con-
trol of the vulnerable system. Malicious code available to
us exploited this vulnerability by sending a single packet
and waiting for response. It did not try to run a remote
shell on the victim machine. For this particular program,
the repair procedure determined that function f_restart
is function main() of named.
However, it turned out
that there were no local variable updates from f_read to
f_attack, and therefore the execution could be restarted
from f_read (which was function evGetNext() in this
case).
Format string vulnerability in ghttpd.
There is a
format string vulnerability in function Log(). The re-
pair procedure determined that for this particular program
functions f_restart and f_read is the same function
serverconnection().
However, since there were a
number of local variable updates between the point where
the data was read and the point where Log() was called,
the execution restarted from the beginning of function
f_restart. Still, the initial connection was kept open.
The exploit program that we used continued sending pack-
ets to the same port as where the initial malicious packet
was sent to. These subsequent packets were treated as in-
valid requests by the survived program. It sent the “bad
request” HTML page back to the exploit program in re-
sponse.
Format string vulnerability in drcatd.
There is a
similar vulnerability in the logging function of drcatd.
However, in this case function main() turned out to be
f_restart. In addition, there were a number of local
variable updates between f_read and f_attack. There-
fore, the whole program needed to be restarted in case of
an attack. This problem can be solved in two ways. The
ﬁrst is to reorganize the source code manually by putting
potentially vulnerable parts of the code into a separate
function so that the execution can be restarted from it in
case of attack. However, this solution requires some un-
derstanding of the source code of the program and there-
fore is not suitable for automatic program protection. The
second solution is to log all memory updates including lo-
cal ones. However, current version of DIRA cannot tell
automatically whether tracking global updates only will
be sufﬁcient or not. Currently, this option can be turned on
and off manually. When compiled with this option turned
on drcatd can repair itself and continue normal execu-
tion. However, even if it turns out that the whole program
needs to be restarted the program can still detect the attack
and identify it.
The analysis presented above shows that it is not always
possible to repair a program automatically and that even
when it is, the restart point may be quite close to the begin-
ning of the program. This raises the question as to whether
automated attack repair is useful in practice. We believe
automated attack repair is indeed useful for the following
reasons. First, with attack repair, dynamic attack detection
is now as effective as static analysis in protecting vulner-
able applications at run time without suffering from the
latter’s false positive problems. More concretely, even if a
vulnerable application is compromised, DIRA ensures the
application can continue as if the vulnerability does not
exist in the ﬁrst place. Second, automated attack repair
is essential to provide protection among clients of single-
threaded or event-based network applications. In these ap-
plications, requests from multiple clients are processed in
the same process. Therefore, terminating an application of
this type upon detecting an attack from some client is not
acceptable as it also disrupts the service to other clients
as well. Finally, DIRA’s automated attack repair can be
used together with other types of attack detection meth-
ods such as system call argument monitoring, which can
detect attacks that could damage a victim application’s ad-
dress space without hijacking its control. For these types
of attacks, the automated attack repair mechanism can still
repair the damaged address space even long after the at-
tack takes place.
6.
Conclusion
In this paper we presented the ﬁrst known compiler that
can transform arbitrary programs to a form that can detect
control hijacking attacks, identify the malicious input and
repair the compromised program, all without human in-
tervention. In addition, the performance overhead of these
transformations is shown to be quite modest, even without
any aggressive optimizations.
There are a number of ways in which the DIRA pro-
totype can be improved. First, we aim to improve the
efﬁciency of the memory updates logging mechanism by
employing control ﬂow analysis. Currently, DIRA tracks
every update to any global variable, even though in theory
only the ﬁrst one needs to be logged. Another problem
with the current logging mechanism is that it may miss
certain data dependencies, for example, when a local vari-
able is used to transfer information between two global
variables. Comprehensive data dependency analysis is re-
quired to improve the accuracy of attack identiﬁcation.
We are going to address multi-threading issues in more
detail in the next version of DIRA. Multiple threads of
the same program can concurrently access the memory
updates log and other global data structures, and thus
introduce additional data dependencies. At repair time,
DIRA needs to determine which threads should be rolled
back, restore the state of each such thread to the corre-
sponding pre-attack state, and resume its execution. We
are also planning to broaden the scope of the repair pro-
cess by including support for ﬁle system undo. Although
not common among network applications, ﬁle system
undo can help erase the side effects of an attack on a ﬁle
system such as temp ﬁles.
7.
Acknowledgement
We would like to thank the anonymous reviewers and
our shepherd Dr. Dawn Song for their valuable comments.
This research is supported by NSF awards ACI-
0234281, CCF-0342556, SCI-0401777, CNS-0410694
and CNS-0435373 as well as fundings from Computer As-
sociates Inc., New York State Center of Advanced Tech-
nology in Sensors, National Institute of Standards and
Technologies, Siemens, and Rether Networks Inc.
References
[1] H. Agrawal, R. A. DeMillo, and E. H. Spafford.
An
execution-backtracking approach to debugging. In IEEE
Software, May 1981.
[2] H. Agrawal and J. R. Horgan.
Dynamic program slic-
ing. In Proceedings of ACM SIGPLAN Conference on Pro-
gramming Language Design and Implementation, 1990.
[3] T. M. Austin, S. E. Breach, and G. S. Sohi. Efﬁcient detec-
tion of all pointer and array access errors. ACM SIGPLAN
Notices, 29(6), 1994.
[4] A. Baratloo, T. Tsai, and N. Singh. Transparent run-time
defense against stack smashing attacks. In Proceedings of
USENIX Annual Technical Conference, June 2000.
[5] Beyond
Security’s
SecuriTeam.
http://www.
securiteam.com.
[6] G. Candea and A. Fox. Crash-only software. In Proceed-
ings of the 9th Workshop on Hot Topics in Operating Sys-
tems (HotOS-IX), 2003.
[7] G. Candea, S. Kawamoto, Y. Fujiki, G. Friedman, and
A. Fox. A microrebootable system — design, implementa-
tion, and evaluation. In Proceedings of Operating System
Design and Implementation Conference, 2004.
[8] T.-C. Chiueh and F.-H. Hsu. RAD: A compile-time solu-
tion to buffer overﬂow attacks. In Proc. of 21st Intl. Conf.
on Distributed Computing Systems, 2001.
[9] C. Cowan, M. Barringer, S. Beattie, G. Kroah-Hartman,
M. Frantzen, and J. Lokier. FormatGuard: Automatic pro-
tection from printf format string vulnerabilities. In Pro-
ceedings of 10th USENIX Security Symposium, August
2001.
[10] C. Cowan, C. Pu, D. Maier, J. Walpole, P. Bakke, S. Beat-
tie, A. Grier, P. Wagle, Q. Zhang, and H. Hinton. Stack-
Guard:
Automatic detection and prevention of buffer-
overﬂow attacks. In Proceedings of the 7th USENIX Se-
curity Conference, January 1998.
[11] H. Etoh.
GCC extensions for protecting applications
from stack-smashing attacks. http://www.trl.ibm.
com/projects/security/ssp, June 2000.
[12] D. Evans, J. Guttag, J. Horning, and Y. M. Tan. LCLint: A
tool for using speciﬁcations to check code. In Proceedings
of the ACM SIGOFT Symposium on the Foundations of
Software Engineering, December 1994.
[13] S. Feldman and C. Brown. Igor: A system for program de-
bugging via reversible execution. In ACM SIGPLAN No-
tices, Workshop on Parallel and Distributed Debugging,
January 1989.
[14] M. Frantzen and M. Shuey. StackGhost: Hardware facili-
tated stack protection. In Proceedings of the 10th USENIX
Security Sumposium, August 2001.
[15] Fyodor. Remote exploits. http://www.insecure.
org/sploits_remote.html.
[16] L. A. Grenier. Practical code auditing. http://www.
daemonkitty.net/lurene, 2002.
[17] S. Hangal and M. S. Lam. Tracking down software bugs
using automatic anomaly detection. In Proceedings of Int.
Conf. Software Engineering, May 2002.
[18] R. Hastings and B. Joyce. Purify: Fast detection of mem-
ory leaks and access errors. In Proceedings of the Winter
USENIX Conference, 1992.
[19] S. C. Johnson. Lint, a C program checker. In AT&T Bell
Laboratories:Murray Hill, NJ, July 1978.
[20] R.
Jones
and
P.
Kelly.
Bounds
checking
for
C.
http://www-ala.doc.ic.ac.uk/~phjk/
BoundsChecking.html, July 1995.
[21] H.-A. Kim and B. Karp. Autograph: Toward automated,
distributed worm signature detection. In Proceedings of
USENIX Security Symposium, 2004.
[22] B. Korel and J. Laski. Dynamic program slicing. Informa-
tion Processing Letters, 29(3), 1988.
[23] B. Korel and J. Laski. Dynamic slicing of computer pro-
grams. The Journal of Systems and Software, 13(3), 1990.
[24] A. D. Lucia. Program slicing: Methods and applications.
In Proceedings of the 1st IEEE International Workshop on
Source Code Analysis and Manipulation, 2001.
[25] S. L. Min and J.-D. Choi. An efﬁcient cache-based access
anomality detection scheme. In Proceedings of the Fourth
International Conferenceon Architectural Support for Pro-
gramming Languages and Operating Systems, 1991.
[26] J. Nazario.
Project Pedantic — source code analy-
sis tool(s). http://pedantic.sourceforge.net,
March 2002.
[27] Openwall project. http://www.openwall.com.
[28] D. Z. Pan and M. A. Linton. Supporting reverse execution
of parallel programs.
In Proceedings of the ACM SIG-
PLAN/SIGOPS Workhop on Paralleland Distributed De-
bugging, January 1989.
[29] A. Pasupulati, J. Coit, K. Levitt, S. F. Wu, S. H. Li,
J. C. Kuo, and K. P. Fan. Buttercup: On network-based
detection of polymorphic buffer-overﬂow vulnerabilities.
In Proceedings of Network Operations and Management
Symposium, 2004.
[30] M. Prvulovic and J. Torrellas. ReEnact: Using thread-level
speculation to debug software; An application to data races
in multithreaded codes. In Proceedings of the 30th Annual
International Symposium on Computer Architecture, June
2003.
[31] O. Ruwase and M. S. Lam. A practical dynamic buffer
overﬂow detector. In Proceedings of the 11th Network and
Distributed System Security Symposium, February 2004.
[32] Secure software solutions. Rough auditing tool for secu-
rity, RATS 2.1. http://www.securesw.com/rats.
[33] S. Srinivasan, S. Kandula, C. Andrews, and Y. Zhou.
Flashback: A lightweight extension for rollback and de-
terministic replay for software debugging. In Proceedings
of USENIX Annual Technical Conference, June 2000.
[34] P. Team.
Non-executable pages design and imple-
mentation. http://pax.grsecurity.net/docs/
noexec.txt.
[35] T. Toth and C. Kruegel. Accurate buffer overﬂow detection
via abstract payload execution. In Proc. of Intl. Symposium
on Recent Advances in Intrusion Detection, 2002.
[36] Vendicator. StackShield GCC compiler patch. http://
www.angelfire.com/sk/stackshield, January
2001.
[37] J. Viega, J. T. Bloch, T. Kohno, and G. McGraw. ITS4: A
static vulnerability scanner for C and C++ code. In Pro-
ceedings of the 16th Annual ComputerSecurity Applica-
tions Conference, December 2000.
[38] D. Wheeler.
Flawﬁnder.
http://www.dwheeler.
com/flawfinder.
[39] J. Wilander and M. Kamkar. A comparison of publicly
available tools for static intrusion prevention. In Proc. of
7th Nordic Workshop on Secure IT Systems, 2002.
[40] J. Wilander and M. Kamkar. A comparison of publicly
available tools for dynamic buffer overﬂow prevention. In
Proc. of 10th Network and Distributed System Security
Symposium, 2003.
[41] P. Zhou, F. Qin, W. Liu, Y. Zhou, and J. Torrellas.
iWatcher: Efﬁcient architectural support for software de-
bugging. In Proceedings of the 31st Annual International
Symposium on Computer Architecture, 2004.