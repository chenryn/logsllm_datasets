t
i n
( c : VG (1+N) ) ,
l e t
t r a n s c r i p t
:= Vmap2 (
( h : G)
(1+N) )
(1+N) )
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
t r a n s c r i p t −>
= t r u e )
V f o r a l l
c h a l −>
( fun e => Sigma . d i s j o i n t F Sig e . 1 e . 2 = t r u e )
l e t w := Vmap ( fun t => Sigma . e x t r a c t o r F Sig t . 2 . 1
t . 2 . 2 t . 1 . 2 . 1 t . 1 . 2 . 2 )
l e t U’
:= Vmap ( fun w => w . 2 . 1 . 1 . 1 ) w i n
t r a n s c r i p t
i n
l e t A := MF inv U i n
l e t B := ( MF mult A U’ )
i n
( MF inv U’ ) = ( MF id (1+N) ) −>
MF mult U’
MF mult U ( MF inv U) = ( MF id (1+N) ) −>
( M F i s P e r m u t a t i o n B = f a l s e −>
( VF beq ( MF VCmult
&& Fbool eq ( VF prod ( MF VCmult
− VF prod ( Vnth U i n d e x 0 ) ) 0 )
= f a l s e ) −>
( VF one (1+N) ) B)
( VF one (1+N) )
( Vnth U i n d e x 0 ) B)
WikRel pk e e ’ h hs c .
The proof of the theorem can be found in the Coq source,
essentially it works by exploiting the structure of the proof of
shufﬂe which is essentially a sigma protocol with an extra
challenge on the front. For each initial challenge, we ﬁrst
extract the witness whose existence is guaranteed by the un-
derlying sigma protocol. Having gathered all these witnesses,
we compute from them, using fairly straightforward linear
algebra, either two distinct openings to the same commitment
or the permutation and randomness used to shufﬂe. The only
part of the proof which is not linear algebra is the use of the
Schwartz-Zippel lemma to check the equality of polynomials.
Since the lemma implies the polynomials are equal except
with negligible probability we have added the equality of the
polynomials as an assumption to the theorem (lines 43 to 47)
and leave a general treatment of the lemma as future work.
VI. ENCRYPTION SCHEMES IN CLASS
Having proven the security of the mix net for all cryptosys-
tems in the class deﬁned in Section IV, we now prove that the
cryptosystems commonly used in e-voting fall into this class.
A. ElGamal in Class
The most common encryption scheme used in e-voting is
ElGamal. (In addition to the many variants of ElGamal the
PPATC scheme from [64] also belongs to this class.) We
brieﬂy recall the deﬁnition of ElGamal here.
Deﬁnition 3. ElGamal encryption scheme (in a Schnorr
group) Σ is a tuple (Σ.KeyGen, Σ.Enc, Σ.Dec,Σ.KeyMatch)
of PPT algorithms such that:
• Let G be the group of kth residues in Zp of prime order
q where p = kq + 1 for some p, k, and q. Let g denote
some generator of G.
• the ciphertext space C is the Cartesian product of G with
itself, the randomness space R is the ﬁeld Zq and the
ciphertext space is a vector space with respect to the
randomness space;
• the message space M is G;
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:14:48 UTC from IEEE Xplore.  Restrictions apply. 
1758
• the KeyGen algorithm deﬁnes a set of public and se-
cret key pairs (PK = G,SK = Zq) from which one
is uniformly selected: (P K ∈ PK, SK ∈ SK) ←r
Σ.KeyGen() = (gx, x ←r Zq);
• The Enc algorithm takes a public key P K, message
M and R and returns a ciphertext CT from C: that
is, ∀P K ∈ PK,∀m ∈ M,∀r ∈ R, CT ∈ C ←
Σ.EncP K(m, r) = (gr, P K rm)
• The Dec algorithm takes a ciphertext CT = (c1, c2) ∈ C
and SK ∈ SK and returns either a message m ∈ M or
null ⊥: that is, ∀CT ∈ C, Σ.DecSK(CT ) → c2/(cSK
).13
1
Basic ElGamal ﬁts the deﬁnition of our (Terelius-Wikstr¨om
compatible) encryption scheme. The statement of this theorem
is fairly straightforward but because of the work we have
already done it immediately allows us to get a veriﬁed imple-
mentation of the optimised Terelius-Wikstr¨om mix net which
is compatible with existing voting systems used in national
elections; this is a ﬁrst and hugely signiﬁcant in gaining better
conﬁdence in the correctness of e-voting systems deployed in
national elections.
However, as we noted earlier, most of the national e-
voting systems do not use basic ElGamal. Instead they use a
variety of variants of ElGamal. For instance parallel ElGamal
where multiple ElGamal ciphertexts are shufﬂed in parallel
is fairly common, as is Gjøsteen ElGamal which achieves
short ciphertexts for longer messages in exchange for longer
keys. All of these variants are (provably Terelius-Wikstr¨om
compatible) encryption schemes.
We have proven in Coq that parallel ElGamal is a (Terelius-
Wikstr¨om compatible) encryption scheme. The module (Ex-
tendedElGamal) which shows this takes as input the number
of ciphertexts N to be shufﬂed in parallel.
VII. APPLICATIONS TO VERIFYING NATIONAL ELECTIONS
We will now discuss the application of our work to verify
national elections. Currently, we have proven that both El-
Gamal and parallel ElGamal fall into this class. We can now
extract the mix net with the case of basic ElGamal into OCaml
and use this to verify evidence produced by an election scheme
built for binding government elections.
Our Coq formalisation contains a Coq function to mix the
inputs to produce the appropriate outputs. These functions are
rather trivial and consist of only a few lines of Coq. Our Coq
proofs verify that these functions obey their Coq speciﬁcations,
meaning they produce correctly mixed outputs. Moreover, for
each such mix net (function), our Coq formalisation contains
a Coq function for the required veriﬁer, and a Coq proof of its
correctness, meaning the software to produce the ZKP proof
that the mix was done correctly, the software to check this
ZKP proof, and Coq proofs that the veriﬁer accepts on the
output of the prover running on valid inputs. That is, we also
have formally veriﬁed veriﬁers for these various mix nets.
A. Extracted Veriﬁer
In this section will discuss our extracted veriﬁer, speciﬁcally
its delta from the veriﬁed objects, its efﬁciency and the existing
e-voting system with which we have tested it.
a) Delta between the veriﬁed objects and the implemen-
tation: There are two gaps between our veriﬁed objects and
the extracted veriﬁer.
The ﬁrst is that the Coq extraction facility is not itself
veriﬁed to be correct; the required veriﬁed extraction facility
CertiCoq has been under development for some time but
until it is complete this gap remains.14 For existing elections
it seems astronomically unlikely that the ﬂaws, if any, in
the system line up with the ﬂaws in the Coq extraction
facility. However, once the extracted veriﬁer is public, an
adversary may try to determine ﬂaws and design a system
which exploits them. For this reason, the current practice of
multiple independent veriﬁer should be continued. The Coq
proof of the veriﬁer (before extraction) is still a machine-
checked proof that a correct veriﬁer exists for the mix net
in question, which is still a massive improvement over the
current state of the art.
The second delta is the Fiat-Shamir transform. As we have
already noted, since the statement and commitment are both
formally deﬁned in our implementation, this is a one line
modiﬁcation to the implementation. Proving the correctness of
this transform is out of scope as it requires formalising highly
non-trivial cryptographic reasoning; speciﬁcally it requires
reasoning about rewinding in the random oracle model which
to our knowledge has not been done by any prior work in Coq,
EasyCrypt or other comparable interactive theorem provers.
We have also checked that the veriﬁer in our implementation
is compatible with the proof transcripts produced by (other)
implementations used in national elections. One must check
that the Fiat-Shamir transform is done correctly when checking
their transcripts, but as noted, the security of this one line
modiﬁcation is not overly hard to check. When verifying tran-
scripts produced by other implementations, this modiﬁcation
is dependent on that implementation.
b) Efﬁciency: Efﬁciency is not as vital an issue with mix
net veriﬁers as in other areas of cryptography since the veriﬁer
is run irregularly, as compared to key exchange for example.
Our extracted veriﬁer is lightweight with the exception of
group exponentiations. However, since our veriﬁer uses a fairly
standard implementation of big integers, it is not much slower
than a directly written veriﬁer. For example, when using a
2048bit Schnorr group, an election of 10,000 ballots took 200
seconds to verify. The veriﬁers we tested have nearly iden-
tical efﬁciency regardless of whether it is for Veriﬁcatum or
CHVote. We note that the bottleneck operation is parallelisable
and further optimisations, such as ﬁxed base exponentiation,
could also be applied. At present, the largest elections using
these techniques are in Estonia and our results suggest that
13For ElGamal—provided the input is in the right set—always returns a
message and never ⊥
14 The Coq extraction facility maps most but not all of the arithmetic
functions into native OCaml; we have mapped the remaining functions as
documented in the code.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:14:48 UTC from IEEE Xplore.  Restrictions apply. 
1759
our veriﬁer would check all the proofs in under an hour on
commodity hardware, even without further optimisations.
c) Sanity Checks: We have also tested our extracted
veriﬁer on a wide variety of invalid transcripts; as expected it
rejected all of them. This is not a surprising result because, by
the soundness property we proved about the veriﬁer, it must
reject on the overwhelming majority of inputs.
B. Veriﬁcatum
The Veriﬁcatum mix net was the ﬁrst complete and fully
distributed veriﬁable mix net. It is considered the gold standard
for implementations of veriﬁable mix nets and has withstood
easily the security of its more than a decade of use in national
elections. The mix net has been used in national elections in
Norway, Estonia and Switzerland.
We installed Veriﬁcatum from the github repository15 on
an Ubuntu virtual machine and generated various test proof
transcripts using its demo functionality;
this process took
some time due to conﬁguration issues. We converted these
transcripts to JSON ﬁles using the tool provided by Veriﬁca-
tum. There are several differences in notation and structure
between Veriﬁcatum and our veriﬁer but the parser is not
overly complicated. Speciﬁcally, we deliberately wrote our
veriﬁer to generalise both Veriﬁcatum and CHVote and be
compatible with either depending on the choice of parameters.
We wrote a parser to convert the JSON ﬁles into the data
structures expected by our veriﬁer; ﬁnally, we successfully
veriﬁed the transcripts from Veriﬁcatum using our veriﬁer.
This code is included in our repository.
C. CHVote 2.0
The CHVote 2.0 system [32] was developed by the state of
Geneva in Switzerland.
Switzerland’s elections are run at a canton (state) level.
Different cantons use different methods with different vendors.
We have already referred to the SwissPost electronic voting
system which was used in several cantons. The canton of
Geneva decided to develop its own system which was called
CHVote2.0. The system is fairly similar to the SwissPost
system in user experience. The voter ﬁrst receives a code sheet
in the mail; they then log into the online system and cast their
vote. After casting, they receive a conﬁrmation code which
should match the sheet they were sent. The system then uses
a veriﬁable mix net as part of the tally process.
The mix net used in the CHVote2.0 system is a fairly direct
implementation of the optimised Terelius-Wikstr¨om mix net.
Importantly, it is compatible with the veriﬁer we proved in
Coq. We installed the CHVote2.0 system locally from its git
repository16 and produced several demo election transcripts
by slightly extending the test routines included; in this case
we copied the transcripts directly from the console output and
posted them into the OCaml ﬁle which calls the veriﬁer. Again,
there are several differences in notation and structure between
CHVote2.0 and our veriﬁer but the parser, and parameters, are
15https://github.com/veriﬁcatum
16https://github.com/republique-et-canton-de-geneve/chvote-protocol-poc
not overly complicated. Finally, we successfully veriﬁed the
transcripts from CHVote2.0 in our veriﬁer.
D. Deploying the veriﬁer on real elections
We have not deployed the veriﬁer on transcripts from real
elections even though we have checked the veriﬁer is compati-
ble with the software used to generate those transcripts because
countries using these systems do not make the transcripts
publicly available, but only release them to trusted auditors.
VIII. CONCLUSION
Veriﬁable mix nets are a crucial component in numerous ap-
plications. In particular, they are deployed widely in electronic
voting systems for governmental elections where they are by
far the most complicated cryptographic component. Given the
litany of critical errors in e-voting, we must develop tools to
give greater conﬁdence in the security of veriﬁable mix nets.
We have contributed such conﬁdence by using Coq to
machine-check the security of the veriﬁable mix net most
commonly used in secure e-voting and extract an efﬁciently
executable version of the veriﬁer which we ran on evidence
produced by e-voting systems for real governmental elections.
We have demonstrated our veriﬁer for two e-voting systems
which have collectively handled millions of votes and been
used in several national elections. The veriﬁer is also clearly
applicable to a wide variety of additional electronic voting
systems; and to other applications that rely upon veriﬁable
mix nets based on proofs of shufﬂe.
A. Future work
There are several relevant directions to expand either the
security guarantees provided by this work or its applicability.
As already mentioned, we inherit the limitation of Haines
et al. [49] that we only prove the interactive version and
consequently we must assume that the Fiat-Shamir transform
is done correctly when the scheme is made non-interactive;
implementing this transform is fairly straight forward, despite
how often errors have occurred in implementations. Neverthe-
less, it would be highly interesting to prove the transform in
Coq and hence remove this limitation; at present, a proof of
the transform seems impractical but it may be possible to do a
hybrid paper/machine proof where we machine-check the use
of the transform rather than the transform itself.
The Terelius-Wikstr¨om mix net only works as a proof of
shufﬂe if the commitment scheme is binding; consequently, it
only works if the commitment parameters are correctly gen-
erated. Generating these parameters is fairly straightforward