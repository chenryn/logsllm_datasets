装置自行驱动，Perl的\G肯定无法匹配。
另一方面，在其他某些工具软件中使用同样的查找-替换命令，会得到！a！b！c！d！e！，也
就是说\G是在每次匹配的起始位置匹配成功，然后由传动装置进行驱动。
关于G:的匹配，也不能完全相信文档，微软的.NET和Sun的Java文档，在我通知这两家
公司之前，都是错误的（然后他们才修正）。现在的状态就是，PHP和Ruby中的G指向
当前匹配的开头位置，而Perl、java.uti1.regex和.NET匹配上一次匹配的结束位置。
---
## Page 158
132
第3章：正则表达式的特性和流派概览
Perl中\G的高级用法
下面的程序对Shtml中的HTML代码进行简单的校验，确保其中只有少数几种HTML
结构（例如和，以及&gt：）。在Yahoo！我用这种方法确保用户提交的HTML
符合某些规范。
这段代码中最重要的就是Perl的m/…/gc匹配操作符，它会把这个正则表达式一次性
应用到目标宇符串，下一次匹配从上一次成功匹配之后的文本开始，如果匹配失败，
也不会重新设定position（315）。
这样，我们就能用包含多个表达式的“tagteam”来检查宇符串。从理论上说、它好像
对所有这些表达式进行整体的选代，但是这段程序的执行单位不是一次表达式而是一
次匹配，而且能够临时新增或排除某些表达式。
my$need_close_anchor=0；#加果遇见了而没有对应的，则返回True
while（notShtml=~m/\G\z/gc）#在整个字将事没有处理完之前
if（$html=~m/\G(\w+）/gc）{
：..如果S1中包含数宇或单词一可以检查语言的规范性...
}elsif （Shtml=~m/\G[<>&\w]+/gc）{
#其他非HTML代码无关紧要
)elsif（$html=~m/\G]+)>/gci）（
...包含imagetag--可以检查它是否符合规范...
}elsif (not $need_close_anchor and $html =~m/\G]+)>/gci）{
...包含超链接，这里可以进行验证...
Sneed_close_anchor=1；#我们现在需要的是
)elsif (Sneed_close_anchor and $html s-m(\G)gci）{
Sneed_close_anchor=0；#常求已经满足，不再容许出现
}elsif（$html=~m/\G&（#\d+
if ($need_close_anchor)(
die "Missing final "
---
## Page 159
常用的元字符和特性
133
单词分界符：\b、\B、\
单词分界符的作用与行锚点一样，也是匹配字符串中的某些位置。单词分界符可以分为两
类，一类中单词起始位量分界符和结束位置分界符是相同的（通常是\），另一类则以
统一的分界符来匹配（通常是\b）。两类都提供了非单词分界符序列（通常是\B）。表3-12
给出了一些例子。如果所使用的工具软件没有提供单独的起始位置和结束位置分界符，但
支持环视功能，用户也可以用它来模拟那两种单词分界符。在下面的表格中，如果程序本
身没有提供分开的单词分界符，我会列出实践中的做法。
），
则不是。每种工具软件对“单词字符”的理解都不一样，对单词边界的理解也是这样。如
果单词分界符等于\w当然好办，但很多时候事实并非如此。例如，在PHP和java.uti1.
regex中，\w只能匹配ASClI字符，而不是Unicode字符，所以在表格中我会使用带有
Unicode单词属性\pL（这是p（L)的缩略表示法121）的环视功能。
无论单词分界符怎么定义“单词字符”，单词分界符的测试通常只是简单的字符相邻测试。
所有的正则引擎都不会对单词进行语意分析：它们认为“NE14AD8”是一个单词，而“M.1.T.”
不是。
顺序环视（？=）、（？！…）：逆序环视（？
ly
\B
GNUegrep
1b
\B
GNU Emacs
1
1b
\B
Java
(?: ]]
[[:]]
.NET
(M\i)(M\=>).--(M\=)(M\i>)
1b
\B
Perl
（M\i)(M\=>）.(M\=)（M\1>)
\b
\B
PHP
(?)--(M\=)(M\i>)
b
\B
Ruby
\b
\B
GNU sed
1
b
\B
Tcl
W\...u\
1y
IY
表示只能对ASCII中的字符（或者是基于locale的8位编码数据）有效，即使该流派支持
Unicode也是如此。
（请参考第91页的版本信息）
更高一层次的支持容许逆序环视中出现不同长度的多选分支，所以（？（?i）very（?-i）会对中
间的very进行不区分大小写的匹配。而两端的tag仍然必须为大写。它可以匹配
‘VERY’和‘Very”，但不能匹配‘Very”。
这个例子在大多数支持（?i）的系统中都可以运行，例如Perl、PHP、java.util.regex、
Ruby（注15）和.NET。在Python和Tcl中则不行，因为它们不支持（?-i）。
除Python之外，大多数实现方式中，（?i）的作用范围都只限于括号内部（也就是说，在闭
括号之后就失效)。所以，我们可以拿掉(？-i），将整个不需要区分大小写的部分放在一个
括号里，把(?i）放在最前面：(?：（?i)very)l。
模式修饰符中能够出现的不只有‘1”。在大多数系统中，我们至少可以使用表3-13列出的
修饰符。有的系统还提供了更多的选项。比如PHP就提供了少数其他选项（446），Tcl
也是如此 (请参考文档)。
表3-13：常见模式修饰符字母
字母模式
i
不区分大小写的匹配模式（110）
X
宽松排列和注释模式（111）
S
点号通配模式（111）
m
增强的行锚点模式（112）
模式作用范围：（?modifier：..），例如（?i：）
如果所使用的系统支持模式修饰范围，这样前一节的例子可以更加简化。（？i：表示模
式修饰符的作用范围只有在括号内有效。这样，（?：(?i)very）就可以化简为
(?i:very)]。
注15：在Ruby中可以运行，但Ruby的（?i）有个bug，即它有时不能正确处理用1i分隔的小
写多选分支（大写则没有问题）。
---
## Page 162
136
第3章：正则表达式的特性和流派概览
如果支持，这种格式一般可以应用于所有的模式修饰符字母。Tcl和Python都支持（?i）
格式，但是不支持（？i：）格式。
注释：（?#…）和#··
某些流派支持用（？#）添加注释。实际上，如果流派支持宽松排列和注释模式（111），
就很少使用这种功能。不过，如果在字符事文字中很难插入换行符，用这种格式加入注释
就非常方便，例如VB.NET就是如此（99，420)。
文字文本范围：\Q..\B
Q\E是由Perl引I入的，它会消除其中除\E之外所有元字符的特殊含义（如果没有\E，就
会一直作用到正则表达式末端）。其中的所有字符都会被当成普通文字文本来对待。如果在
构建正则表达式时包含变量，此功能就非常有用。
举例来说，为了响应Web检索，我们可能希望把用户输入的内容保存在Squery中，然后使
用m/Squery/i。但是，如果squery包含某些字符，例如‘c：\WINDowS\’，结果是运行时
错误，因为这不是一个合法的正则表达式（最后有一个单独的反斜线）。
Q…\Ej可以解决这个问题。如果在Perl中使用m/\QSquery\E/i，则squery就从‘C:\WIN-
DOWS\’变成C\：\\WINDOWS\\，结果能找到用户期望的‘C：\WINDOWS\'。
但是在面向对象和程序式处理（95）中，这个特性的用处要打折扣。在构建需要用在正
则表达式中的字符事时，有很方便的函数对这个值“上保险”，以便用在正则表达式中。例
如，在VB中，我们可以使用Regex.Escape(432)；PHP提供了preg_quote函数（r470)，
Java有quote方法（395）。
就我所知，支持Q.\Es的引擎只有java.uti1.regex和PCRE（也包括PHP的preg套件）。
请注意，我刚刚提到，这个功能是在Perl中引入的（而且我给出了Perl的例子），你可能觉
得很奇怪，为什么刚刚没有提到Per。Perl支持正则文字中的\Q\E（也就是直接出现在程
序中的正则表达式），但是不能在可能使用插值的内容和变量上使用。细节问题请参考第7
章（290)。
在低于1.6.0的Java中，java.util.regex对字符组中的\Q…\Ei支持是不可靠的，不建
议使用。
---
## Page 163
常用的元字符和特性
137
分组，捕获，条件判断和控制
Grouping,Capturing,Conditionals,andControl
捕获/分组括号：（.）和\1，\2，*
普通的无特殊意义的括号通常有两种功能：分组和捕获。普通括号常见的形式是（），但
有的流派中使用（\），例如GNUEmacs、sed、vi和grep。
如41、43和57页的图所示，捕获型括号的编号是按照开括号出现的次序，从左到右计算
的。如果提供了反向引用，则这些括号内的子表达式匹配的文本可以在表达式的后面部分
用1、\2来引用。
括号的常用功能之一是从字符串中提取数据。括号中的子表达式匹配的文本（也可以称为
“括号匹配文本（thetext matchedby theparentheses）"）在不同的程序中可以通过不同的方
式来引用，例如Perl的$1和s2（常见的错误是在正则表达式之外使用八1，这种形式只在
sed和vi中能用）。下一页的表3-14说明了各种程序中，匹配完成之后访问文本的方法。它
还说明了访问整个表达式匹配的文本，或者某一组捕获型括号所匹配文本的做法。
仅用于分组的括号：（？：.）
仅用于分组的括号（？："）不能用来提取文本，而只能用来规定多选结构或者量词的作用
对象。它们不会按照s1、$2之类编号。在（1lone）（?：andlor）（2Itwo）匹配之后，$1包
含‘1'或者‘one'，S2包含‘2'或者‘two'。只用于分组的括号也叫非捕获型括号（non-capturing
parentheses)。
非捕获型括号的价值体现在好几个方面。它们能够把复杂的表达式变得清晰，这样读者不
会担心在其他地方用到$1会产生混乱。而且它们还有助于提高效率。如果正则引擎不需要
记录捕获型括号匹配的内容，速度会更快，所用的内存也更少（第6章详细讲解效率问题）。
非捕获型括号的另一个用途是利用多个成分构建正则表达式。在第76页的例子中，$Host-
nameRegex保存的是用来匹配主机名的正则表达式。如果使用它来提取主机名两端的空白，
在Perl中是m/（\s*）SHostnameRegex（\s*）/。然后s1和s2分别保存开头和结尾的空白，
但结尾的空白其实是保存在s4中的，因为sHostnameRegex包含两组捕获型括号。