以下是优化后的参考文献和附录部分，使其更加清晰、连贯和专业：

### 参考文献

1. **Chromium.** (2014, November). 使用 ASan 作为保护措施。[在线] 可访问于: <http://using-asan-as-protection.html>

2. **Chromium.** (2014, July). Chromium Revision 285353 - UBsan 的 vptr 黑名单。[在线] 可访问于: <https://src.chromium.org/viewvc/chrome?view=revision&revision=285353>

3. **Chromium.** (2014, November). Chromium 项目：/trunk/src/tools/ubsan_vptr/blacklist.txt 的日志。[在线] 可访问于: <https://src.chromium.org/viewvc/chrome/trunk/src/tools/ubsan_vptr/blacklist.txt?view=log>

4. **Clang 文档.** (2014, November). MSVC 兼容性。[在线] 可访问于: <http://clang.llvm.org/docs/MSVCCompatibility.html>

5. **CodeSourcery, Compaq, EDG, HP, IBM, Intel, Red Hat, and SGI.** (2005). Itanium C++ ABI (修订版 1.83)。[在线] 可访问于: <http://mentorembedded.github.io/cxx-abi/abi.html>

6. **CodeSourcery, Compaq, EDG, HP, IBM, Intel, Red Hat, and SGI.** (2014, November). C++ ABI 已解决的问题。[在线] 可访问于: <http://www.codesourcery.com/public/cxx-abi/cxx-closed.html>

7. **J. Criswell, A. Lenharth, D. Dhurjati, and V. Adve.** (2007). 安全虚拟架构：商品操作系统的安全执行环境。在 ACM SIGOPS 操作系统原理研讨会 (SOSP) 上发表。

8. **Dai Mikurube.** (2014, November). 堆内存分析中的 C++ 对象类型标识符。[在线] 可访问于: <http://www.chromium.org/developers/deep-memory-profiler/cpp-object-type-identifier>

9. **M. Daniel, J. Honoroff, and C. Miller.** (2008). 利用 JavaScript 进行堆溢出攻击的工程化方法。在 USENIX 攻击技术研讨会 (WOOT) 上发表。

10. **L. Davi, D. Lehmann, A.-R. Sadeghi, and F. Monrose.** (2014). 粗粒度控制流完整性保护的有效性探讨。在 USENIX 安全研讨会 (Security) 上发表。

11. **GCC.** (2015, June). 变长数组。[在线] 可访问于: <https://gcc.gnu.org/onlinedocs/gcc/Variable-Length.html>

12. **E. Göktas, E. Athanasopoulos, H. Bos, and G. Portokalidis.** (2014). 失控：克服控制流完整性。在 IEEE 安全与隐私研讨会上发表。

13. **E. Göktaş, E. Athanasopoulos, M. Polychronakis, H. Bos, and G. Portokalidis.** (2014). 长度很重要：为什么使用 gadget 链长度来防止代码重用攻击是困难的。在 USENIX 安全研讨会上发表。

14. **Google.** (2014, August). Octane 基准测试。[在线] 可访问于: <https://code.google.com/p/octane-benchmark>

15. **Google.** (2014, November). 适用于 ThreadSanitizer, MemorySanitizer 等的专用内存分配器。[在线] 可访问于: <http://llvm.org/klaus/compiler-rt/blob/7385f8b8b8723064910cf9737dc929e90aeac548/lib/sanitizer_common/sanitizer_allocator.h>

16. **R. Hastings and B. Joyce.** (1991). Purify：快速检测内存泄漏和访问错误。在 1992 年冬季 USENIX 会议上发表。

17. **D. Jang, Z. Tatlock, and S. Lerner.** (2014). SafeDispatch：从内存破坏攻击中保护 C++ 虚函数调用。在网络安全研讨会 (NDSS) 上发表。

18. **T. Jim, J. G. Morrisett, D. Grossman, M. W. Hicks, J. Cheney, and Y. Wang.** (2002). Cyclone：一种安全的 C 方言。在 USENIX 年度技术会议 (ATC) 上发表。

19. **I. JTC1/SC22/WG21.** (2013). ISO/IEC 14882:2013 编程语言 C++ (N3690)。[在线] 可访问于: <https://isocpp.org/files/papers/N3690.pdf>

20. **LLVM 项目.** (2014, November). 如何为你的类层次结构设置 LLVM 风格的 RTTI。[在线] 可访问于: <http://llvm.org/docs/HowToSetUpLLVMStyleRTTI.html>

21. **J. Mihalicza, Z. Porkoláb, and A. Gabor.** (2011). C++ 的类型保留堆分析器。在 IEEE 国际软件维护会议 (ICSM) 上发表。

22. **Mozilla.** (2014, August). DROMAEO, JavaScript 性能测试。[在线] 可访问于: <http://dromaeo.com>

23. **GCC Bugzilla.** (2014, November). libstdc++-v3/include/bits 中的多个未定义行为 (static_cast<>)。[在线] 可访问于: <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63345>

24. **MWR Labs.** (2013). Pwn2Own 2013 写作：WebKit 漏洞利用。[在线] 可访问于: <https://labs.mwrinfosecurity.com/blog/2013/04/19/mwr-labs-pwn2own-2013-write-up---webkit-exploit/>

25. **Standard Performance Evaluation Corporation.** (2014, August). SPEC CPU 2006。[在线] 可访问于: <http://www.spec.org/cpu2006>

26. **The Chromium Project.** (2014, August). [在线] 可访问于: <http://www.chromium.org/Home>

27. **The Chromium Project.** (2014, November). Chromium 问题 - Bug 387016。[在线] 可访问于: <http://code.google.com/p/chromium/issues/detail?id=387016>

28. **The Chromium Projects.** (2014, November). 未定义行为清理器。[在线] 可访问于: <http://www.chromium.org/developers/testing/undefinedbehaviorsanitizer>

29. **The LLVM Compiler Infrastructure.** (2014, August). [在线] 可访问于: <http://llvm.org>

30. **The Mozilla Foundation.** (2014, November). Firefox Web 浏览器。[在线] 可访问于: <https://www.mozilla.org/firefox>

31. **C. Tice.** (2012). 提高虚函数调度的安全性。在 GNU Tools Cauldron 研讨会上发表。

32. **TIS 委员会.** (1995). Tool Interface Standard (TIS) Executable and Linking Format (ELF) 规范版本 1.2。TIS 委员会。

33. **WebKit.** (2014, August). SunSpider 1.0.2 JavaScript 基准测试。[在线] 可访问于: <https://www.webkit.org/perf/sunspider/sunspider.html>

34. **W. Xu, D. C. DuVarney, and R. Sekar.** (2004). 一种高效且向后兼容的转换以确保 C 程序的内存安全性。在 ACM SIGSOFT 国际软件工程基础研讨会 (FSE) 上发表。

35. **B. Zeng, G. Tan, and G. Morrisett.** (2011). 结合控制流完整性和静态分析实现高效且验证的数据沙箱。在 ACM 计算机与通信安全会议 (CCS) 上发表。

36. **C. Zhang, T. Wei, Z. Chen, L. Duan, L. Szekeres, S. McCamant, D. Song, and W. Zou.** (2013). 二进制可执行文件的实用控制流完整性和随机化。在 IEEE 安全与隐私研讨会 (SP) 上发表。

37. **M. Zhang and R. Sekar.** (2013). COTS 二进制文件的控制流完整性。在 USENIX 安全研讨会 (Security) 上发表。

38. **S. Nagarakatte, J. Zhao, M. M. Martin, and S. Zdancewic.** (2009). SoftBound：高度兼容且完整的 C 语言空间内存安全。在 ACM SIGPLAN 编程语言设计与实现会议 (PLDI) 上发表。

39. **G. C. Necula, J. Condit, M. Harren, S. McPeak, and W. Weimer.** (2005). Ccured：遗留软件的类型安全改造。ACM 编程语言与系统事务 (TOPLAS)。

40. **N. Nethercote and J. Seward.** (2007). Valgrind：一个重型动态二进制插桩框架。在 ACM SIGPLAN 编程语言设计与实现会议 (PLDI) 上发表。

41. **Qualys Security Advisory.** (2015, June). Qualys 安全公告 CVE-2015-0235 - GHOST：glibc gethostbyname 缓冲区溢出。[在线] 可访问于: <http://www.openwall.com/lists/oss-security/2015/01/27/9>

42. **K. Serebryany, D. Bruening, A. Potapenko, and D. Vyukov.** (2012). AddressSanitizer：一个快速地址检查工具。在 USENIX 年度技术会议 (ATC) 上发表。

43. **S. Shende, A. D. Malony, J. Cuny, P. Beckman, S. Karmesin, and K. Lindlan.** (1998). 使用 C++ 进行并行科学应用的便携式性能分析和跟踪。在 ACM SIGMETRICS 并行和分布式工具研讨会 (SPDT) 上发表。

44. **A. Sotirov.** (2007). JavaScript 中的堆风水术。在 Black Hat Europe 上发表。

### 附录

#### 附录 1：基于跟踪的类型信息验证类型转换的算法

```python
def getTHTableByAddr(addr):
    if isObjectInStack(addr):
        allocBaseAddr, pTHTable = stack_rbtree.rangedSearch(addr)
    elif isObjectInHeap(addr):
        MetaData = getMetaDataStorage(addr)
        return (MetaData.allocBaseAddr, MetaData.pTHTable)
    elif isObjectInGlobal(addr):
        allocBaseAddr, pTHTable = global_rbtree.rangedSearch(addr)
    else:
        # addr 指向未知区域。
        return ERROR
    
    return (allocBaseAddr, pTHTable)

def isGoodCast(addr, allocBaseAddr, THTable, TargetTypeHash):
    TargetTHTable = getTHTableByHash(TargetTypeHash)
    for i in range(TargetTHTable.num_bases):
        base = TargetTHTable.bases[i]
        if addr == allocBaseAddr + base.offset and base.hashValue == THTable.type_hash and base.isPhantom:
            return True
    for i in range(THTable.num_bases):
        base = THTable.bases[i]
        if addr == allocBaseAddr + base.offset and base.hashValue == TargetTypeHash:
            return True
    return False

def verify_cast(beforeAddr, afterAddr, TargetTypeHash):
    (allocBaseAddr, pTHTable) = getTHTableByAddr(beforeAddr)
    if pTHTable == ERROR:
        HandleBadCastingAttempt()
        return
    if isGoodCast(afterAddr, allocBaseAddr, pTHTable, TargetTypeHash):
        # 这是一个良好的类型转换。
        return
    # 达到此处意味着检测到不良类型转换尝试。
    HandleBadCastingAttempt()
```

#### 附录 2：运行时对象类型信息跟踪算法

```python
# 全局红黑树按进程初始化
def trace_global(pTHTable, baseAddr, numArrayElements):
    allocSize = pTHTable.type_size * numArrayElements
    global_rbtree.insert((baseAddr, allocSize), pTHTable)

# 栈红黑树按线程初始化
def trace_stack_begin(pTHTable, baseAddr, numArrayElements):
    allocSize = pTHTable.type_size * numArrayElements
    stack_rbtree = getThreadLocalStackRbtree()
    stack_rbtree.insert((baseAddr, allocSize), pTHTable)

def trace_stack_end(baseAddr):
    stack_rbtree = getThreadLocalStackRbtree()
    stack_rbtree.remove(baseAddr)

# 动态对象的元数据存储为每个对象分配预留
def trace_heap(pTHTable, baseAddr, numArrayElements):
    MetaData = getMetaDataStorage(baseAddr)
    MetaData.baseAddr = baseAddr
    MetaData.allocSize = pTHTable.type_size * numArrayElements
    MetaData.pTHTable = pTHTable
```

希望这些改进能够使您的文档更加清晰和专业！