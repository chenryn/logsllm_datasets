using-asan-as-protection.html, Nov 2014.
http:
[9] Chromium. Chromium Revision 285353 - Blacklist for UBsan’s
vptr. https://src.chromium.org/viewvc/chrome?view=
revision&revision=285353, Jul 2014.
[10] Chromium. Chromium project: Log of /trunk/src/tools/ubsan_-
https://src.chromium.org/viewvc/
vptr/blacklist.txt.
chrome/trunk/src/tools/ubsan_vptr/blacklist.txt?
view=log, Nov 2014.
[11] Clang Documentation. MSVC Compatibility. http://clang.
llvm.org/docs/MSVCCompatibility.html, Nov 2014.
[12] CodeSourcery, Compaq, EDG, HP, IBM, Intel, R. Hat, and SGI.
Itanium C++ ABI (Revision: 1.83). http://mentorembedded.
github.io/cxx-abi/abi.html, 2005.
[13] CodeSourcery, Compaq, EDG, HP, IBM, Intel, Red Hat, and SGI.
C++ ABI Closed Issues. www.codesourcery.com/public/
cxx-abi/cxx-closed.html, Nov 2014.
[14] J. Criswell, A. Lenharth, D. Dhurjati, and V. Adve. Secure virtual
architecture: A safe execution environment for commodity operat-
ing systems. In ACM SIGOPS Symposium on Operating Systems
Principles (SOSP), 2007.
[15] Dai Mikurube.
C++ Object Type Identifier
for Heap
http://www.chromium.org/developers/
Profiling.
deep-memory-profiler/cpp-object-type-identifier,
Nov 2014.
[16] M. Daniel, J. Honoroff, and C. Miller. Engineering Heap Overflow
In USENIX Workshop on Offensive
Exploits with JavaScript.
Technologies (WOOT), 2008.
[17] L. Davi, D. Lehmann, A.-R. Sadeghi, and F. Monrose. Stitching
the Gadgets: On the Ineffectiveness of Coarse-Grained Control-
Flow Integrity Protection. In USENIX Security Symposium (Secu-
rity), 2014.
[18] GCC. Arrays of Variable Length. https://gcc.gnu.org/
onlinedocs/gcc/Variable-Length.html, Jun 2015.
[19] E. Göktas, E. Athanasopoulos, H. Bos, and G. Portokalidis. Out of
control: Overcoming Control-Flow Integrity. In IEEE Symposium
on Security and Privacy (SP), 2014.
94  24th USENIX Security Symposium 
USENIX Association
14
[20] E. Gökta¸s, E. Athanasopoulos, M. Polychronakis, H. Bos, and
G. Portokalidis. Size does matter: Why using gadget-chain length
to prevent code-reuse attacks is hard. In USENIX Security Sympo-
sium (Security), 2014.
[21] Google. Octane Benchmark. https://code.google.com/p/
octane-benchmark, Aug 2014.
[22] Google. Specialized memory allocator for ThreadSanitizer, Mem-
orySanitizer, etc. http://llvm.org/klaus/compiler-rt/
blob/7385f8b8b8723064910cf9737dc929e90aeac548/
lib/sanitizer_common/sanitizer_allocator.h,
2014.
Nov
[23] R. Hastings and B. Joyce. Purify: Fast detection of memory leaks
and access errors. In Winter 1992 USENIX Conference, 1991.
[24] D. Jang, Z. Tatlock, and S. Lerner. SafeDispatch: Securing C++
Virtual Calls from Memory Corruption Attacks. In Network and
Distributed System Security Symposium (NDSS), 2014.
[25] T. Jim, J. G. Morrisett, D. Grossman, M. W. Hicks, J. Cheney,
and Y. Wang. Cyclone: A safe dialect of C. In USENIX Annual
Technical Conference (ATC), 2002.
[26] I. JTC1/SC22/WG21. ISO/IEC 14882:2013 Programming Lan-
guage C++ (N3690). https://isocpp.org/files/papers/
N3690.pdf, 2013.
[27] LLVM Project.
class
your
How to set up LLVM-style RTTI
http://llvm.org/docs/
for
HowToSetUpLLVMStyleRTTI.html, Nov 2014.
hierarchy.
[28] J. Mihalicza, Z. Porkoláb, and A. Gabor. Type-preserving heap
profiler for c++. In IEEE International Conference on Software
Maintenance (ICSM), 2011.
[29] Mozilla. DROMAEO, JavaScript Performance Testing. http:
//dromaeo.com, Aug 2014.
[30] Multiple undefined behaviors (static_cast<>)
in libstdc++-
v3/include/bits. GCC Bugzilla - Bug 63345. https://gcc.gnu.
org/bugzilla/show_bug.cgi?id=63345, Nov 2014.
Pwn2Own
[31] MWR
MWR
Labs.
Labs
Webkit
Write-up:
mwrinfosecurity.com/blog/2013/04/19/
mwr-labs-pwn2own-2013-write-up---webkit-exploit/,
2013.
Exploit.
2013
https://labs.
[39] Standard Performance Evaluation Corporation. SPEC CPU 2006.
http://www.spec.org/cpu2006, Aug 2014.
[40] The Chromium Project. http://www.chromium.org/Home,
Aug 2014.
[41] The Chromium Project. Chromium Issues - Bug 387016.
http://code.google.com/p/chromium/issues/detail?
id=387016, Nov 2014.
[42] The Chromium Projects.
for Chromium.
testing/undefinedbehaviorsanitizer, Nov 2014.
Undefined Behavior Sanitizer
http://www.chromium.org/developers/
[43] The LLVM Compiler Infrastructure. http://llvm.org, Aug
2014.
[44] The Mozilla Foundation. Firefox Web Browser. https://www.
mozilla.org/firefox, Nov 2014.
[45] C. Tice. Improving Function Pointer Security for Virtual Method
Dispatches. In GNU Tools Cauldron Workshop, 2012.
[46] TIS Committee. Tool Interface Standard (TIS) Executable and
Linking Format (ELF) Specification Version 1.2. TIS Committee,
1995.
[47] WebKit. SunSpider 1.0.2 JavaScript Benchmark. https://www.
webkit.org/perf/sunspider/sunspider.html, Aug 2014.
[48] W. Xu, D. C. DuVarney, and R. Sekar. An efficient and backwards-
compatible transformation to ensure memory safety of c programs.
In ACM SIGSOFT International Symposium on Foundations of
Software Engineering (FSE), 2004.
[49] B. Zeng, G. Tan, and G. Morrisett. Combining Control-flow In-
tegrity and Static Analysis for Efficient and Validated Data Sand-
boxing. In ACM Conference on Computer and Communications
Security (CCS), 2011.
[50] C. Zhang, T. Wei, Z. Chen, L. Duan, L. Szekeres, S. McCamant,
D. Song, and W. Zou. Practical Control Flow Integrity and Ran-
domization for Binary Executables. In IEEE Symposium on Secu-
rity and Privacy (SP), 2013.
[51] M. Zhang and R. Sekar. Control Flow Integrity for COTS Binaries.
In USENIX Security Symposium (Security), 2013.
[32] S. Nagarakatte, J. Zhao, M. M. Martin, and S. Zdancewic. Soft-
Bound: Highly Compatible and Complete Spatial Memory Safety
for C. In ACM SIGPLAN Conference on Programming Language
Design and Implementation (PLDI), 2009.
[33] G. C. Necula, J. Condit, M. Harren, S. McPeak, and W. Weimer.
Ccured: Type-safe retrofitting of legacy software. ACM Transac-
tions on Programming Languages and Systems (TOPLAS), 2005.
[34] N. Nethercote and J. Seward. Valgrind: A Framework for Heavy-
weight Dynamic Binary Instrumentation. In ACM SIGPLAN Con-
ference on Programming Language Design and Implementation
(PLDI), 2007.
[35] Qualys Security Advisory. Qualys Security Advisory CVE-
2015-0235 - GHOST: glibc gethostbyname buffer over-
flow.
http://www.openwall.com/lists/oss-security/
2015/01/27/9, Jun 2015.
[36] K. Serebryany, D. Bruening, A. Potapenko, and D. Vyukov. Ad-
dressSanitizer: A Fast Address Sanity Checker. In USENIX An-
nual Technical Conference (ATC), 2012.
[37] S. Shende, A. D. Malony, J. Cuny, P. Beckman, S. Karmesin, and
K. Lindlan. Portable profiling and tracing for parallel, scientific
applications using c++. In ACM SIGMETRICS Symposium on
Parallel and Distributed Tools (SPDT), 1998.
[38] A. Sotirov. Heap Feng Shui in JavaScript. Black Hat Europe,
2007.
USENIX Association  
24th USENIX Security Symposium  95
15
# addr points to unknown area.
return ERROR
False if there is no good-castings.
return True
Appendix
if isObjectInStack(addr):
if isObjectInHeap(addr):
return (allocBaseAddr, pTHTable)
global_rbtree.rangedSearch(addr):
return (allocBaseAddr, pTHTable)
stack_rbtree.rangedSearch(addr):
if isObjectInGlobal(addr):
# addr points to global objects.
allocBaseAddr, pTHTable = \
and addr = allocBaseAddr + comp.offset
# addr points to stack objects.
stack_rbtree = getThreadLocalStackRbtree()
allocBaseAddr, pTHTable = \
# addr points to heap objects.
MetaData = getMetaDataStorage(addr):
return (MetaData.allocBaseAddr, MetaData.pTHTable)
1 def getTHTableByAddr(addr):
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23 # Return True if there exists a good-casting.
24 #
25 def isGoodCast(addr, allocBaseAddr, THTable, TargetTypeHash):
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53 def verify_cast(beforeAddr, afterAddr, TargetTypeHash):
54
55
56
57
58
59
60
61
62
63
64
65
66
# Reaching here means a bad-casting attempt is detected.
# Below may report the bug, halt the program, or nullify
# the pointer according to the user’s configuration.
HandleBadCastingAttempt()
# Check phantom.
TargetTHTable = getTHTableByHash(TargetTypeHash)
for i in range(TargetTHTable.num_bases):
base = TargetTHTable.bases[i]
if addr == allocBaseAddr + base.offset
and base.hashValue == THTable.type_hash
and base.isPhantom:
base = THTable.bases[i]
if addr == allocBaseAddr + base.offset
and base.hashValue == TargetTypeHash:
(allocBaseAddr, pTHTable) = getTHTableByAddr(beforeAddr)
if pTHTable == ERROR:
if isGoodCast(afterAddr, allocBaseAddr, \
THTable, TargetTypeHash):
# This is a good casting.
return
return True
# Check bases.
for i in range(THTable.num_bases):
return True
return False
return
allocSize = pTHTable.type_size * numArrayElements
global_rbtree.insert((baseAddr, allocSize), pTHTable)
return
stack_rbtree = getThreadLocalStackRbtree()
allocSize = pTHTable.type_size * numArrayElements
stack_rbtree.insert((baseAddr, allocSize), pTHTable)
return
1 # global_rbtree is initialized per process.
2 def trace_global(pTHTable, baseAddr, numArrayElements):
3
4
5
6
7 # stack_rbtree is initialized per thread.
8 def trace_stack_begin(pTHTable, baseAddr, numArrayElements):
9
10
11
12
13
14 def trace_stack_end(baseAddr):
15
16
17
18
19 # Meta-data storage for dynamic objects are reserved
20 # for each object allocation.
21 def trace_heap(pTHTable, baseAddr, numArrayElements):
22
23
24
25
26
MetaData = getMetaDataStorage(baseAddr)
MetaData.baseAddr = baseAddr
MetaData.allocSize = pTHTable.type_size * numArrayElements
MetaData.pTHTable = pTHTable
return
stack_rbtree = getThreadLocalStackRbtree()
stack_rbtree.remove(baseAddr)
return
Appendix 2: Algorithm for tracking type information on objects
in runtime.
Appendix 1: Algorithm for verifying type conversions based
on the tracked type information.
96  24th USENIX Security Symposium 
USENIX Association
16