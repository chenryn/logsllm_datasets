# A Case for a Stateful Middlebox Networking Stack

**Authors:**
- Muhammad Asim Jamshed
- Donghwi Kim
- YoungGyoun Moon
- Dongsu Han
- KyoungSoo Park

## 1. Introduction

Stateful middleboxes, such as intrusion detection systems, application-layer firewalls, and protocol analyzers, are increasingly important in modern networks due to their critical operations. These middleboxes typically function by maintaining the flow states of live TCP connections that pass through the network.

Despite their growing importance, developing a stateful middlebox remains a challenging task. The primary complexity arises from the lack of a common programming abstraction that clearly separates flow management from custom middlebox logic. Consequently, developers often need to write complex flow management modules from scratch, resulting in tens of thousands of lines of code that are difficult to port [4, 2]. This contrasts sharply with the development of networking applications for end nodes, which benefit significantly from well-defined network abstractions like the Berkeley socket API. The absence of a reusable networking stack for middleboxes makes the code highly dependent on custom packet libraries, reducing readability, modularity, and extensibility.

In this work, we propose a general-purpose flow management stack that meets the basic requirements of monitoring middlebox applications. The proposed stack should satisfy three key requirements:
1. **Abstraction of TCP State Management:** It should abstract TCP state management, allowing developers to focus on custom middlebox processing rather than low-level details. Clear separation of flow management and custom middlebox logic is essential for high code readability and modularity.
2. **Flexibility in Event Handling:** It should be flexible enough to express any packet or flow-level event that triggers a special middlebox operation. Events can range from simple TCP state changes to more complex conditions, such as retransmitted packets with different content. A flexible event-based system enables developers to write middlebox applications as sets of logical events and their handlers.
3. **Efficient Resource Management:** It should allow efficient resource management. Depending on the needs of the middlebox, developers might want to avoid flow reassembly on the server side while actively monitoring flow content from the client side, or deallocate resources for a flow even if it has not yet terminated.

## 2. Operation Model

Figure 1 provides an overview of our middlebox networking stack architecture. The stack monitors TCP flows passing through the middlebox and exposes a socket that abstracts each flow to the application. The application developer defines a set of middlebox events and registers event handlers (or callbacks) that perform custom middlebox logic. When an event handler is called, it is passed a socket for the flow that raised the event, and the application can probe the flow state through our middlebox socket API.

For flow management in the middlebox, each TCP flow context must track both client- and server-side TCP states. This is necessary because a middlebox may act on either the client- or server-side state, or both. For example, an Intrusion Detection System (IDS) might monitor a client-side TCP state transition (e.g., from ESTABLISHED to FIN_WAIT_1) or inspect data from a server. To ensure efficient resource usage, our stack allows developers to disable state management on either side on a per-flow basis.

An event is a critical abstraction in our networking stack, representing a condition for specific middlebox operations. Events can be built-in or user-defined. Built-in events are generated by the flow management module when certain pre-defined conditions are met, such as new connection establishment, teardown, new data availability, TCP state changes, packet arrival, or packet retransmission. Developers can register handlers for built-in events or define their own user-defined events (UDEs) based on built-in events. UDEs can extend built-in events with custom functions, enabling a wide range of custom events without dealing with low-level details.

## 3. Sample Code

Listing 1 shows sample code that counts the number of TCP SYN retransmissions for flows traversing the middlebox. Due to space constraints, only the main logic is explained.

```c
static void on_syn_rexmit(ctx_t ctx, int sock, int side, event_t e) {
    static uint64_t syn_retx = 0;
    syn_retx++;
}

static bool ft_syn(ctx_t ctx, int sock, int side, event_t e, event_data_t data) {
    struct pkt_ctx p;
    mtcp_cb_get_curpkt(ctx, &p);
    return (p.tcph->syn && !p.tcph->ack);
}

// Create a UDE for SYN retransmission
ude_syn = mtcp_define_ude(ON_REXMIT, ft_syn);

// Open a monitoring socket
msock = mtcp_socket(ctx, AF_INET, SOCK_MONITOR_STREAM_PASSIVE, 0);

// Register a callback for ude_syn
mtcp_register_callback(ctx, msock, ude_syn, PRE_TCP, on_syn_rexmit);
```

In this code, `on_syn_rexmit` is the callback function for SYN retransmissions, and `ft_syn` is the filter function that checks if the retransmitted packet is a SYN packet. The UDE `ude_syn` is defined based on the built-in event `ON_REXMIT`. If the filter function returns true, the callback function is invoked. A generic monitoring socket (`msock`) is created to monitor all TCP flows unless the scope is limited. The callback function `on_syn_rexmit` is registered for `ude_syn` with the monitoring socket, and `PRE_TCP` ensures the event is raised before updating the middlebox TCP state for the flow.

## 4. Preliminary Evaluation

We are currently porting popular middlebox applications to our framework, and the preliminary results are promising.

### Scalability & Composability

We evaluated the robustness of our system in a testbed consisting of four sets of web client/server machines and an inline network toy web monitor (an Intel Xeon E5-2697 14-core machine with 64 GB RAM) that counts the number of ongoing connections. We tested performance under two scenarios: one with a monitoring socket without TCP management and another with flow monitoring without payload inspection. As shown in Figure 2, our toy monitor can handle up to 40 Gbps for 8KB web pages and manage flows at a rate of at least 10 Gbps for small file sizes.

### Improved Abstraction

We have partially ported Snort, a popular open-source signature-based network security monitor. We replaced approximately 8,000 lines of source code with only 799 lines to support Snort's default TCP stream management module. Our version currently skips some elaborate checks, such as segment overlapping and connection anomaly checks. The porting process has simplified the core framework, focusing on pattern matching rather than flow management. We evaluated the performance by generating innocent client/server web request/response pages for varying file sizes in the same testbed with around 3,000 HTTP Snort attack signatures. Figure 3 shows that our version outperforms the I/O-optimized Snort by a factor of 1.5 to 2.2.

### Enhanced Monitoring Capabilities

Some security monitors, such as Snort and Suricata, use elaborate reassembling routines to examine payloads spanning several successive TCP segments. These routines are typically used to detect attack patterns in malicious flows. Our stack provides user-friendly APIs that simplify the development of such routines in practice.

## 5. Acknowledgment

This work was supported by the ICT R&D program of MSIP/IITP, Republic of Korea [14-911-05-001, Development of an NFV-inspired networked switch and an operating system for multi-middlebox services].

## 6. References

[1] PF RING I/O Driver. http://www.ntop.org/products/pf_ring/.

[2] Suricata Open Source IDS. http://suricata-ids.org/.

[3] E. Jeong et al. mTCP: a Highly Scalable User-level TCP Stack for Multicore Systems. In NSDI, 2014.

[4] M. Roesch. Snort - Lightweight Intrusion Detection for Networks. In LISA, 1999.

---

**Figures:**

- **Figure 1:** Stateful inline middlebox architecture.
- **Figure 2:** Monitor Performance (HTTP GET 16K reqs/s).
- **Figure 3:** Snort Performance (HTTP GET 16K reqs/s).

---

This revised version aims to improve the clarity, coherence, and professionalism of the original text.