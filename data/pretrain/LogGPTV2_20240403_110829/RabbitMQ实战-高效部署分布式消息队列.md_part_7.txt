蓝莓
香蕉
黄瓜
蓝莓
Q1
Q2
图2.4direct交换器消息流
服务器必须实现direct类型交换器，包含一个空白字符串名称的默认交换器。
当声明一个队列时，它会自动绑定到默认交换器，并以队列名称作为路由键。这意
味着你可以使用如下代码发送消息到之前声明的队列去。前提是你已经获得了信道
实例：
（,aweu-ananb,'，'bsus)ystqnd oseq-teuueuos
第一个参数是你想要发送的消息内容；第二个参数是一个空的字符串，指定了
---
## Page 46
24
第2章理解消息通信
默认交换器；而第三个参数就是路由键了。这个路由键就是之前用来声明队列的名
称。之后，你会看到如何使用默认交换器和临时队列来实现RPC消息通信模式。
当默认的direct交换器无法满足应用程序的需求时，你可以声明你自己的交换
器。只需发送exchange.declare命令并设置合适的参数就行了。
接下来我们要讨论的是fanout交换器。就如你看到的图2.5那样，这种类型的
交换器会将收到的消息广播到绑定的队列上。消息通信模式很简单：当你发送一条
消息到fanout交换器时，它会把消息投递给所有附加在此交换器上的队列。这允许
你对单条消息做不同方式的反应。举例来说，一个Web应用程序可能需要在用户上
传新的图片时，用户相册必须清除缓存，同时用户应该得到些积分奖励。你可以将
两个队列绑定到图片上传交换器上。一个用于清除缓存，另一个用于增加用户积分。
从这个场景中你可以了解到，使用交换器、绑定和队列比直接向指定的队列发送
消息要有优势。假设应用程序的第一个需求是在图片上传到网站上后，需要清除用
户相册缓存。你可以通过只使用一个队列就能轻易完成。但是当产品负责人让你实
现一个新功能，即在上传完成后给用户一点奖励，你该怎么办呢？如果你是直接将
消息发送给队列的话，就不得不修改发送方的代码，以将消息发送给新的用户积分
（points）队列。如果你使用的是fanout交换器的话，你唯一需要做的就是为新的消
fanout交换器
图2.5fanout交换器消息流
---
## Page 47
2.3联合起来：交换器和绑定
25
费者写一段代码，然后声明新的队列并将其绑定到fanout交换器上。就如同我们之
前讲的那样，发送方的代码和消费者的代码两者之间完全解耦了，这允许你轻而易
举地添加应用程序的功能。
最后，我们将讨论topic交换器。这类交换器允许你实现有趣的消息通信场景，
它使得来自不同源头的消息能够到达同一个队列。让我们用Web应用程序日志系
统作为示例。你拥有多个不同的日志级别，例如 error、info和 warning。与此同时，
你的应用程序分为以下几个模块：user-profile、image-gallery、msg-inbox等。参见
图2.6，如果在发送消息的动作失败时，你想要报告一个error 的话，则可以编写以
下代码：
$channel->basic_publish($msg,
‘logs-exchange',‘error.msg-inbox');
topic交换器
alert
critical
oa.
Q1
Q2
Q3
图2.6topic交换器消息流
然后，假设你声明了一个msg-inbox-errors队列，你可以将其绑定到交换器上来
接收消息，如下所示：
$channel->queue_bind('msg-inbox-errors'
'logs-exchange',
'error.msg-inbox');
---
## Page 48
26
第2章理解消息通信
到目前为止，这看起来和使用direct交换器很像。你为队列绑定操作和消息发
布路由键指定了相同的error.msg-inbox字符串作为绑定规则。那样就能确保你
的消息会路由到msg-inbox-errors队列，这没什么特别的。但是如果你想要一
个队列监听msg-inbox模块的所有error级别的话，你该怎么做呢？你可以通过将新
的队列绑定到已有的同一个交换器来实现，就像下面这样：
$channel->queue_bind('msg-inbox-logs',
'logs-exchange',
I*,msg-inbox');
msg-inbox-logs队列将会接收从msg-inbox模块发来的所有error、warning 和
info日志信息。那么如何接收所有的日志呢？这实现起来也很简单。你可以在队列
绑定到交换器上的时候使用通配符。从之前的例子可以看到，单个“”把路由键分
为了几部分，“*”匹配特定位置的任意文本。为了实现匹配所有规则，你可以使用“#”
字符：
$channel->queue_bind('all-logs'， 'logs-exchange', '#');
通过这样的绑定方式，all-logs队列将会接收所有从Web应用程序发布的日志。
当然，要使得之前的示例能够运行，你必须在绑定之前对队列进行声明。“*”操作
符将“”视为分隔符；与之不同的是，“#”操作符没有分块的概念，它将任意“”
字符均视为关键字的匹配部分。
到目前为止，你应该已经理解了这三种交换器类型，并能体会AMQP的强大之
处了。你可以对服务器的行为编程以满足自已的需求。它既能够以发布/订阅模式
的设置方式作为队列服务器使用，也可以作为RPC服务器。这取决于你如何组织这
些功能。
让我们回顾一下本节所学到的知识：
■AMQP架构中最关键的几个组件分别是交换器、队列和绑定。
■根据绑定规则将队列绑定到交换器上。
·消息是发布到交换器上的。
·有三种类型的交换器：direct、fanout 和 topic。
■基于消息的路由键和交换器类型，服务器会决定将消息投递到哪个队列去。
---
## Page 49
2.4多租户模式：虚拟主机和隔离
27
2.4多租户模式：虚拟主机和隔离
在理解了交换器、绑定和队列之后，你可能会认为自己已经掌握了Rabbit的
所有特性。但是随着深入使用Rabbit之后，你会发现有一个概念我们尚未讨论过：
vhost。每一个RabbitMQ服务器都能创建虚拟消息服务器，我们称之为虚拟主机
交换器和绑定·..·更重要的是，它拥有自己的权限机制。这使得你能够安全地使用
一个RabbitMQ服务器来服务众多应用程序，而不用担心你的Sudoku（数独）应用
可能会删除狗狗防去跟踪器正在使用的队列。vhost之于Rabbit就像虚拟机之于物
理服务器一样：它们通过在各个实例间提供逻辑上分离，充许你为不同应用程序安
全保密地运行数据。这很有用，它既能将同一Rabbit的众多客户区分开来，又可以
避免队列和交换器的命名冲突。否则你可能不得不运行多个Rabbit，并忍受随之而
来头疼的管理问题。相反，你可以只运行一个Rabbit，然后按需启动或关闭vhost。
whost是AMQP概念的基础，你必须在连接时进行指定。由于RabbitMQ包含
了开箱即用的默认vhost：“7”，因此使用起来非常简单。如果你不需要多个vhost的
话，那么就使用默认的吧。通过使用缺省的guest用户名和密码guest就可以访问默
认vhost。为安全起见，你应该更改它（更多内容请参见第3章）。AMQP的一个有
趣的地方在于它并没有指定权限控制是在vhost级别还是在服务器端级别实现。这
留给了服务器的开发者去决定。在RabbitMQ的例子中，权限控制是以vhost为单位的。
当你在Rabbit里创建一个用户时，用户通常会被指派给至少一个vhost，并且
只能访问被指派vhost内的队列、交换器和绑定。当你在设计消息通信架构时，记
住vhost之间是绝对隔离的。你无法将vhostbanana_tree上的交换器绑定到vhost
oak_tree 中的队列去。事实上，这既保证了安全性，又确保了可移植性。假设你为
重要的银行应用设计了支票兑现层，并使用了自己的vhost。最初，你可能把这个
vhost同其他vhost一起运行在同一个Rabbit上。直到有一天客户们开始兑换数以
百万计的支票一对你来说是好事，但是对Rabbit服务器来说可就惨了。支票兑换
需要运行在轻负载的Rabbit服务器上。如果支票兑现层使用的是默认vhost的话，
全地迁移到新的Rabbit服务器上，然后马上开始处理新的负载而不会有任何命名冲
突。因此，我们强烈推荐你仔细甄别基础架构（譬如Web日志）中的通用功能群
组，并为它们分别分配各自的vhost。同时，请记住，当你在RabbitMQ集群上创建
---
## Page 50
28
第2章理解消息通信
vhost时，整个集群上都会创建该vhost。vhost不仅消除了为基础架构中的每一层运
行一个RabbitMQ服务器的需要，同样也避免了为每一层创建不同集群。
我们讨论了vhost带来的所有巨大益处，那么如何创建它们呢？vhost和权限
控制非常独特，它们是AMQP中唯一无法通过AMQP协议创建的基元（不同于队
列，交换器和绑定）。对于RabbitMQ来说，你需要通过RabbitMQ的安装路径下
./sbin/目录中的rabbitmqctl工具来创建。通过简单地运行rabbitmqctladd_
vhost[vhost_name］就可以创建一个vhost。其中[vhost_name]就是你想要创建的
vhost。删除vhost 同样简单：rabbitmqctl delete_vhost[vhost_name]。一旦
vhost创建成功之后，你就可以连接上去并开始添加队列和交换器了。如果你想要知
道特定Rabbit服务器上运行着哪些vhost时，运行rabbitmqctllist_vhosts即
可。之后你就会看见如下所示的内容：
$./sbin/rabbitmqctl list_vhosts
Listing vhosts ...
oak
sycamore
...done.
注意：通常情况下，你将在服务器上直接运行rabbitmqctl来管理自
己的RabbitMQ节点。不过，你也可以通过指定-nrabbit@[server_
name］选项来管理远程RabbitMQ节点。@符号将节点标识符（rabbit@
[server_name]）分成两部分：左边的是Erlang应用程序名称，在这里永远
都是rabbit。右边是服务器主机名或者IP地址。你需要确保运行Rabbit节
点的服务器和运行rabbitmqctl的工作站安装了相同的Erlangcookie。
更多关于Erlangcookie的信息，请参阅3.4.1节。
到目前为止，通过vhost你保障了队列和交换器的安全。现在我们来讨论当
Rabbit崩溃或者重启时，如何确保关键消息不丢失。
2.5我的消息去哪儿了呢？持久化和你的策略
关于在Rabbit里创建队列和交换器有个不可告人的秘密：默认情况下它们无法
幸免于服务器重启。没错，重启RabbitMQ服务器后，那些队列和交换器就都消失
---
## Page 51
2.5我的消息去哪儿了呢？持久化和你的策略
29
了（随同里面的消息）。原因在于每个队列和交换器的 durable 属性。该属性默认
情况为false，它决定了RabbitMQ是否需要在崩溃或者重启之后重新创建队列（或者
交换器）将它设置为true，这样你就不需要在服务器断电后重新创建队列和交换器了。
你也许会认为把队列和交换器的durable属性设置为true就足够可以让消息幸免于
重启，但是你错了。队列和交换器当然必须被设置成true，但光这样做还不够。
能从AMQP服务器崩溃中恢复的消息，我们称之为持久化消息。在消息发布前，
通过把它的“投递模式”（deliverymode）选项设置为2（AMQP客户端可能会使用
人性化的常量来代替数值）来把消息标记成持久化。到目前为止，消息还只是被表
示为持久化的，但是它还必须被发布到持久化的交换器中并到达持久化的队列中才
行。如果不是这样的话，则包含持久化消息的队列（或者交换器）会在Rabbit崩溃
重启后不复存在，从而导致消息成为孤儿。因此，如果消息想要从Rabbit崩溃中恢复，
那么消息必须：
■把它的投递模式选项设置为2（持久）
■发送到持久化的交换器
■到达持久化的队列
做到以上三点，你就不用和你的关键消息玩“躲猫猫”了。
RabbitMQ确保持久性消息能从服务器重启中恢复的方式是，将它们写入磁盘
上的一个持久化日志文件。当发布一条持久性消息到持久交换器上时，Rabbit会在
消息提交到日志文件后才发送响应。记住，之后这条消息如果路由到了非持久队列
的话，它会自动从持久性日志中移除，并且无法从服务器重启中恢复。如果你使用
持久性消息的话，则确保之前提到的持久性消息的那三点都必须做到位（我们再怎
么强调也不为过）。一旦你从持久化队列中消费了一条持久性消息的话（并且确认
了它），RabbitMQ会在持久化日志中把这条消息标记为等待垃圾收集。在你消费持
久性消息前，如果RabbitMQ重启的话，服务器会自动重建交换器和队列（以及绑定），
重播持久性日志文件中的消息到合适的队列或者交换器上（取决于Rabbit服务器岩
机的时候，消息处在路由过程的哪个环节）。
你可能认为自己应该为所有的消息都启用持久化消息通信。你可以这样做，但
同时你也要为此付出代价：性能。写入磁盘要比存人内存中慢不止一点点，而且
会极大地减少RabbitMQ服务器每秒可处理的消息总数。使用持久化机制而导致
---
## Page 52
30
第2章理解消息通信
消息吞吐量降低至少10倍的情况并不少见“。另外还有一点就是，持久性消息在
何节点的任一队列进行通信，但是事实上那些队列均匀地分布在各个节点而没有允
余（在集群中任何一个队列都没有备份的拷贝）。如果运行seed_bin队列的集群节
点崩溃了，那么直到节点恢复前，这个队列也就从整个集群中消失了（如果队列是
可持久化的）。更重要的是，当节点岩机时，其上的队列也都不可用了，而且持久
化队列也无法重建。这就会导致消息丢失。我们会在第5章更详细地讨论这一情况，
并给出替代的集群方法来解决这个问题。
权衡取舍，什么情况下你应该使用持久性/持久化消息通信呢？首先，你需要
分析（并测试）性能需求。你是否需要单台Rabbit服务器每秒处理100000条消息呢？
如果是这样的话，你应该寻找其他方式来保证消息投递（或者使用更快速的存储系
统）。举例来说，生产者可以在单独的信道上监听应答队列。每次发送消息的时候，
都包含应答队列的名称，这样消费者就可以回发应答以确认接收到了。如果消息应
答未在合理时间范围内到达，生产者就重新发送消息。也就是说，要保证消息的投
递这一关键本质决定了相对于其他类型的消息（例如日志消息）会有更低的吞吐量。
因此如果持久性消息通信能够满足性能需求的话，那么用这种机制确保消息投递是
极佳的方式。我们更多的是为关键消息使用持久化机制。我们只是对何种类型的内
容使用持久性消息通信举棋不定。举个例子，我们运行两种类型的Rabbit集群：非
持久化消息通信的传统RabbitMQ集群和持久化消息通信的活动/热备非集群Rabbit
服务器（使用负载均衡）。这样做确保了为持久化消息通信处理负载不会减慢非持
久化消息的处理。这也意味着Rabbit内建集群在节点岩机时不会让持久性消息消失。
请记住Rabbit能帮助确保投递，但并不是方无一失的。硬盘崩溃、充满bug的消费
者或者其他极端事件都能导致持久化消息丢失。最终确保消息安全到达都将取决于
你的策略。持久化消息通信是一个很好的工具，可以帮助你完成这一点。
和消息持久化相关的一个概念是AMQP事务（transaction）。到自前为止，我
们讨论的是将消息、队列和交换器设置为持久化。这一切都工作得很好，并且
RabbitMQ也负责保证消息的安全。但是由于发布操作不返回任何信息给生产者，
那你怎么知道服务器是否已经持久化了持久消息到硬盘呢？服务器可能会在把消息
与人磁盘前就岩机了，消息因此而丢失，而你却不知道。这就是事务发挥作用的地方。
2将RabbitMQ的消息存储置于SSD上的话，就可以极大地提升持久化消息通信的性能。
---
## Page 53
2.5我的消息去哪儿了呢？持久化和你的策略
31
当继续处理其他任务前，你必须确保代理接收到了消息（并且已经将消息路由给所
的话，不要把AMQP事务和大多数数据库的事务概念搞混了。在AMQP中，在把
信道设置成事务模式后，你通过信道发送那些想要确认的消息，之后还有多个其他
AMQP命令。这些命令是执行还是忽略，取决于第一条消息发送是否成功。一旦你
发送完所有命令，就可以提交事务了。如果事务中的首次发布成功了，那么信道会
在事务中完成其他AMQP命令。如果发送失败的话，其他AMQP命令将不会执行。
事务填补了生产者发布消息以及RabbitMQ将它们提交到磁盘上这两者之间“最后
1英里”的差距。不过，还有更好的方法来填补差距。
虽然事务是正式AMQP0-9-1规范的一部分，但是它们有阿喀琉斯之踵”：几乎
吸千了Rabbit的性能。使用事务不但会降低大约2~10倍的消息吞吐量，而且会使
生产者应用程序产生同步。而你使用消息通信就是想要避免同步。知晓了所有这一
切之后，RabbitMQ团队决定拿出更好的方案来保证消息投递：发送方确认模式4。