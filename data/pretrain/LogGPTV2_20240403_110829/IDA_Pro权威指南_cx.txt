             }  
          }  
       }  
    }
找到我们想要的函数地址后（➊），再利用两个循环迭代以该函数为目标的交叉引用。在第一个循环（➋）中，在每一个调用该函数的位置插入一段注释。在第二个循环（➌）中，在每一个使用该函数地址的位置插入其他注释（使用一个偏移量交叉引用）。为了跟踪以下形式的调用，我们需要第二个循环：
➊  .text:000194EA                 mov     esi, ds:strcpy  
    .text:000194F0                 push    offset loc_40A006  
    .text:000194F5                 add     edi, 160h  
    .text:000194FB                 push    edi  
➋  .text:000194FC call    esi
在这个例子中，编译器将 strcpy
 函数的地址缓存到 ESI 寄存器中（➊），以方便程序随后更快地调用 strcpy
 函数（➋）。这里的 call
 指令执行起来更加快捷，因为它不但更小（2 个字节），而且不需要执行额外的操作来解析调用目标，因为函数地址已经包含在 CPU 的ESI 寄存器中。当一个函数多次调用另一个函数时，编译器可以选择生成这种类型的代码。
由于这个例子中的函数调用属于间接调用，因此我们例子中的flagCalls
 函数只能看到以strcpy
 为目标的数据交叉引用（➊），而无法看到对 strcpy
 的调用（➋），因为 call
 指令并不直接引用strcpy
 。但是，实际上，IDA 能够执行有限的数据流分析，并且可以生成下面的反汇编代码清单：
    .text:000194EA                 mov     esi, ds:strcpy  
    .text:000194F0                 push    offset loc_40A006  
    .text:000194F5                 add     edi, 160h  
    .text:000194FB                 push    edi  
➊  .text:000194FC                 call    esi ; strcpy
注意，这里的 call
 指令（➊）包含一段注释，它指出 IDA 认为该指令所调用的函数。除了插入注释外，IDA 还添加了一个以调用点为源头、以被调用函数为目标的代码交叉引用。这对flagCalls
 函数有利，因为这样它将能够发现这个例子中的 call
 指令，并通过一个代码交叉引用为其添加注释。
为了完善示例脚本，我们需要一个main
 函数，它将为所有我们想审核的函数调用flag- Calls
 。下面这个简单示例说明如何标记对本节前面提到的一些函数的调用：
static main() {  
   flagCalls("strcpy");  
   flagCalls("strcat");  
   flagCalls("sprintf");  
   flagCalls("gets");  
}
运行这段脚本后，可以通过搜索插入的注释文本***AUDIT***
 ，由我们感兴趣的一个调用转移到另一个调用。当然，从分析的角度看，我们还有许多工作要做，因为一个程序调用strcpy
 ，并不表示这个程序可以被利用。这时，我们需要进行数据流分析。为了理解 strcpy
 函数的一个特殊调用是否可被利用，你必须确定 strcpy
 接收到的参数，并评估是否能够以对你有利的方式操纵这些参数。
与寻找对问题函数的调用相比，数据流分析是一个更加复杂的任务。为了跟踪静态分析环境中的数据流，你需要全面理解这个环境所使用的指令集。因此，你的静态分析工具需要了解寄存器在什么地方分配到了值，这些值如何变化并扩散到其他寄存器。而且，你的工具需要确定在程序中被引用的来源和目标缓冲区的大小，这需要你了解栈帧和全局变量的布局，并推断动态分配的内存块的大小。当然，我们需要在不运行程序的前提下了解所有这些信息。
Halvar Flake创建的BugScam2
 脚本是通过创意脚本编写方法完成的，它为我们提供了一个有趣的示例。BugScam 采用的技巧与前面的例子使用的技巧类似，即找到调用问题函数的位置，并采取额外的步骤对每一个函数调用进行基本的数据流分析。BugScam 分析的结果是一份HTML报告，指出二进制文件中可能存在的问题。分析 sprint
 得到的样本报告表如表 22-1 所示。
2. 参见http://www.sourceforge.net/projects/bugscam
 。
表22-1 样本报告表
地址
严重程度
描述
8048c03
5
数据的最大扩展大于目标缓冲区，这可能是缓冲区溢出的原因。最大扩展为 1053。目标大小为1036
在这个例子中，BugScam 能够确定输入和输出缓冲区的大小。如果与格式化字符串包含的格式指示符结合，它们可用于确定程序生成的输出的最大尺寸。
开发这种类型的脚本需要我们深入了解各种破解程序，以设计一种适用于各种二进制文件的算法。不过，即使缺乏这方面的知识，我们仍然能够开发出一些脚本（或插件）。与手动寻找答案相比，它们可以更快地为我们解答一些简单的问题。
举最后一个例子，假设需要定位包含栈分配的缓冲区的所有函数，因为这些函数可能会受到基于栈的缓冲区溢出攻击。相比于手动浏览数据库，我们可以开发一个脚本，分析每个函数的栈帧，寻找占用大量空间的变量。代码清单 22-3 中的Python 函数遍历一个给定函数的栈帧的已定义成员，从中搜索其大小大于指定最小大小的变量。
代码清单 22-3 扫描栈分配的缓冲区
      def findStackBuffers(func_addr, minsize):  
         prev_idx = -1  
         frame = GetFrame(func_addr)  
         if frame == -1: return   #bad function  
         idx = 0  
         prev = None  
         while idx &lt GetStrucSize(frame):  
➊          member = GetMemberName(frame, idx)  
            if member is not None:  
               if prev_idx != -1:  
                  #compute distance from previous field to current field  
➋                delta = idx - prev_idx  
➌                if delta >= minsize:  
                     Message("%s: possible buffer %s: %d bytes\n" %  \  
                            (GetFunctionName(func_addr), prev, delta))  
               prev_idx = idx  
               prev = member  
➎             idx = idx + GetMemberSize(frame, idx)  
            else:  
➍             idx = idx + 1
这个函数通过对栈帧中的所有有效偏移量重复调用 GetMemberName
 （➊），定位该栈帧中的所有变量。变量的大小通过两个连续变量起始偏移量之间的差值计算出来（➋）。如果这个大小超过一个阈值大小（minsize
 ，➌），则在报告中指出，这个变量是一个可能溢出的栈缓冲区。如果当前偏移量位置处没有定义结构体成员，则结构体索引以1 字节递增（➍ ），否则，则按在当前偏移量位置发现的任何成员的大小递增（➎ ）。在计算每个栈变量的大小时，GetMemberSize
 函数似乎是一个更合适的选择，但前提是，IDA 或用户已经正确确定了变量的大小。以下面的栈帧为例：
.text:08048B38 sub_8048B38     proc near  
.text:08048B38  
.text:08048B38 var_818         = byte ptr -818h  
.text:08048B38 var_418         = byte ptr -418h  
.text:08048B38 var_C           = dword ptr -0Ch  
.text:08048B38 arg_0           = dword ptr  8
使用列表中显示的字节偏移量，我们可以计算出：在 var_818
 与var_418
 的起始偏移量之间有1024 个字节（818h-418h=400h
 ），在var_418
 与var_C
 的起始偏移量之间有1036 个字节（418h-0Ch
 ）。但是，这个栈帧可以被扩展，以显示以下布局：
-00000818 var_818         db ?  
-00000817                 db ? ; undefined  
-00000816                 db ? ; undefined  
...  
-0000041A                 db ? ; undefined  
-00000419                 db ? ; undefined  
-00000418 var_418         db 1036 dup(?)  
-0000000C var_C           dd ?
从中可以看到，var_418
 已经折叠成一个数组，而 var_818
 仅仅只有一个字节（有 1023 个未定义的字节填充 var_818
 与var_418
 之间的空间）。对于这个栈布局，GetMemberSize
 将报告var_818
 的大小为1 字节，var_418
 的大小为1036 个字节，这并不是我们希望见到的结果。无论 var_818
 被定义为一个字节还是一个 1024 字节的数组，调用 findStackBuffers(0x08048B38, 16)
 将得到以下输出：
sub_8048B38: possible buffer var_818: 1024 bytes  
sub_8048B38: possible buffer var_418: 1036 bytes
创建一个main
 函数，使它遍历数据库中的所有函数（参见第15 章），并为每个函数调用findStackBuffers
 ，我们将得到一个脚本，该脚本能够迅速指出程序的栈缓冲区的使用情况。当然，要确定这些缓冲区是否能够溢出，需要我们对每个函数进行额外的分析（通常是手动分析）。正是由于静态分析非常单调乏味，才使得模糊测试变得如此流行。
22.2 使用IDA 在事后发现漏洞
对于发现软件漏洞的具体过程，一直以来都存在激烈的讨论。对于在软件中发现的任何漏洞，我们都可以指定（漏洞）发现者和（软件）维护者的角色。此外，我们还可以指定在发现漏洞的过程中可能或不可能发生的许多事件。下面我们简要描述其中一些事件。请记住，发现漏洞的整个过程是人们激烈争论的主题，下面的这些术语绝非标准，也未被广泛接受。
发现
 。最初发现一个漏洞的时刻。为了方便讨论，我们还把这个时刻看成是初步开发一个针对该漏洞的破解程序的时刻。
通知
 。软件维护者最初知道其产品中存在漏洞的时刻。如果是供应商自己发现的漏洞，则这个时刻与“发现”时刻一样。
公布
 。向公众公布漏洞的时刻。根据所发布的有关漏洞的细节信息，这个事件可能会令人困惑。公布可能伴随着发布或识别有效的破解程序。有时候，公布也会作为通知提供给供应商。
缓解
 。公布防范措施的时刻，如果遵循这些措施，用户可以免于成为现有破解程序的受害者。缓解措施是等待发布补丁的用户的折中解决方案。
补丁可用性
 。维护者（或第三方）为易受攻击的软件提供更正版本的时刻。
补丁应用
 。用户安装已更新、已更正的软件，使自己免受（希望如此）所有依赖于给定漏洞的已知攻击侵害的时刻。
有大量论文介绍所有有关漏洞的信息，如漏洞发现者和维护者的责任，他们应公开多少信息，应何时公开这些信息等。通常，供应商会在公开漏洞的同时发布补丁。
许多时候，供应商在发布补丁的同时，还会发布一个漏洞公告。这个漏洞公告提供了一些技术信息，描述已被补丁修复的问题的本质和严重程度，但这些信息的详细程度一般不足以开发一个针对该问题的有效破解程序。那么，为什么有人想要开发一个有效的破解程序呢？很明显，一些人想要利用那些还没有安装补丁的计算机。开发破解程序的速度越快，他们利用更多计算机的几率就越大。另外，供应商可能希望开发一些工具，用于扫描网络中未安装补丁的系统，或者找到一些技巧，以实时检测入侵尝试。多数情况下，开发这样的工具需要开发者深入了解新修复的漏洞的本质。
漏洞公告中可能缺乏一些基本的信息，如包含漏洞的具体文件、任何易受攻击的函数的名称或位置，以及这些函数中的什么内容被变更。但是，被修复的文件本身包含了大量信息，破解程序开发者可以借助这些信息开发一个利用新修复的漏洞的有效破解程序。一开始，这些信息并不十分明显，看起来似乎不能被破解程序开发者使用。我们为消除基本的漏洞所做的变更正是这些信息的表示形式。要突出这些变更，一个最简单的方法是将已打补丁的二进制文件与对应的未打补丁的文件比较。如果只需要在已打补丁的源文件中寻找不同，那么，使用diff
 之类面向文本、较为实用的标准工具，就可以迅速指出发生变更的位置。然而，跟踪一个二进制文件的两个修订版本之间的行为变更，远比简单的文本文件比较复杂得多。
使用差异计算隔离两个二进制文件中发生的变更的困难在于，二进制文件可能会因为各种原因而发生变更。有许多操作都有可能触发变更，如编译器优化、编译器本身的变化、源代码重组、添加与漏洞无关的代码，当然还有添加修复漏洞的代码。我们面临的挑战在于如何将行为变更（如那些修改漏洞所需的变更）与表面变更（如使用不同的寄存器完成相同的任务）区分开来。