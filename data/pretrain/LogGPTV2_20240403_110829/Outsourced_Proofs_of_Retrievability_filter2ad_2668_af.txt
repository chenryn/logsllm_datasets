https://github.com/tsuraan/Jerasure, 2008.
[5] Amazon S3 Service Level Agreement, 2009.
http://aws.amazon.com/s3-sla/.
[6] Micorosfot Corporation. Windows Azure Pricing and
Service Agreement, 2009.
[7] JPBC:Java Pairing-Based Cryptography Library.
http://gas.dia.unisa.it/projects/jpbc/#.
U3HBFfna5cY, 2013.
[8] Protect data stored and shared in public cloud storage.
http://i.dell.com/sites/doccontent/
shared-content/data-sheets/en/Documents/
Dell_Data_Protection_Cloud_Edition_Data_
Sheet.pdf, 2013.
[9] SATOSHI NAKAMOTO. Bitcoin: A Peer-to-Peer Electronic
Cash System.
[10] ANDROULAKI, E., KARAME, G., AND CAPKUN, S.
Evaluating user privacy in bitcoin.
http://eprint.iacr.org/2012/596.pdf.
[11] ATENIESE, G., BURNS, R. C., CURTMOLA, R., HERRING,
J., KISSNER, L., PETERSON, Z. N. J., AND SONG, D. X.
Provable data possession at untrusted stores. In ACM
Conference on Computer and Communications Security
(2007), pp. 598–609.
[12] ATENIESE, G., PIETRO, R. D., MANCINI, L. V., AND
TSUDIK, G. Scalable and efﬁcient provable data possession.
IACR Cryptology ePrint Archive 2008 (2008), 114.
[13] BONEH, D., LYNN, B., AND SHACHAM, H. Short
signatures from the weil pairing. J. Cryptology 17, 4 (2004),
297–319.
[14] BOWERS, K. D., JUELS, A., AND OPREA, A. HAIL: a
high-availability and integrity layer for cloud storage. In
ACM Conference on Computer and Communications
Security (2009), pp. 187–198.
[15] BOWERS, K. D., JUELS, A., AND OPREA, A. Proofs of
retrievability: theory and implementation. In CCSW (2009),
pp. 43–54.
[16] BOWERS, K. D., VAN DIJK, M., JUELS, A., OPREA, A.,
AND RIVEST, R. L. How to tell if your cloud ﬁles are
vulnerable to drive crashes. In ACM Conference on
Computer and Communications Security (2011),
pp. 501–514.
[17] CASH, D., KÜPÇÜ, A., AND WICHS, D. Dynamic Proofs of
Retrievability via Oblivious RAM. In EUROCRYPT (2013),
pp. 279–295.
[18] CLARK, J., AND ESSEX, A. (Short Paper) CommitCoin:
Carbon Dating Commitments with Bitcoin. In Proceedings
of Financial Cryptography and Data Security (2012).
[19] CURTMOLA, R., KHAN, O., BURNS, R. C., AND
ATENIESE, G. MR-PDP: Multiple-Replica Provable Data
Possession. In ICDCS (2008), pp. 411–420.
[20] DECKER, C., AND WATTENHOFER, R. Information
Propagation in the Bitcoin Network. In 13-th IEEE
International Conference on Peer-to-Peer Computing (2013).
[21] DOBRE, D., KARAME, G., LI, W., MAJUNTKE, M., SURI,
N., AND VUKOLI ´C, M. Powerstore: Proofs of writing for
efﬁcient and robust storage. In Proceedings of the 2013 ACM
SIGSAC Conference on Computer &#38; Communications
Security (New York, NY, USA, 2013), CCS ’13, ACM,
pp. 285–298.
[22] DODIS, Y., VADHAN, S. P., AND WICHS, D. Proofs of
Retrievability via Hardness Ampliﬁcation. In TCC (2009),
pp. 109–127.
[23] ERWAY, C. C., KÜPÇÜ, A., PAPAMANTHOU, C., AND
TAMASSIA, R. Dynamic provable data possession. In ACM
Conference on Computer and Communications Security
(2009), pp. 213–222.
[24] JUELS, A., AND JR., B. S. K. PORs: Proofs Of
Retrievability for Large Files. In ACM Conference on
Computer and Communications Security (2007),
pp. 584–597.
[25] KARAME, G. O., ANDROULAKI, E., AND CAPKUN, S.
Double-spending fast payments in bitcoin. In Proceedings of
the 2012 ACM conference on Computer and communications
security (New York, NY, USA, 2012), CCS ’12, ACM,
pp. 906–917.
[26] MEIKLEJOHN, S., POMAROLE, M., JORDAN, G.,
LEVCHENKO, K., MCCOY, D., VOELKER, G. M., AND
SAVAGE, S. A ﬁstful of bitcoins: Characterizing payments
among men with no names. In Proceedings of the 2013
Conference on Internet Measurement Conference (New
York, NY, USA, 2013), IMC ’13, ACM, pp. 127–140.
[27] NETEM. NetEm, the Linux Foundation. Website, 2009.
Available online at
http://www.linuxfoundation.org/
collaborate/workgroups/networking/netem.
[28] PETERSON, Z. N. J., GONDREE, M., AND BEVERLY, R. A
position paper on data sovereignty: The importance of
geolocating data in the cloud. In Proceedings of the 3rd
USENIX Conference on Hot Topics in Cloud Computing
(Berkeley, CA, USA, 2011), HotCloud’11, USENIX
Association, pp. 9–9.
[29] PIETRO, R. D., AND SORNIOTTI, A. Boosting efﬁciency
and security in proof of ownership for deduplication. In
ASIACCS (2012), H. Y. Youm and Y. Won, Eds., ACM,
pp. 81–82.
[30] POPA, R. A., LORCH, J. R., MOLNAR, D., WANG, H. J.,
AND ZHUANG, L. Enabling Security in Cloud Storage SLAs
with CloudProof. In Proceedings of the 2011 USENIX
Conference on USENIX Annual Technical Conference
(Berkeley, CA, USA, 2011), USENIXATC’11, USENIX
Association, pp. 31–31.
[31] REID, F., AND HARRIGAN, M. An Analysis of Anonymity
in the Bitcoin System. CoRR (2011).
[32] REN, Y., XU, J., WANG, J., AND KIM, J.-U.
Designated-veriﬁer provable data possession in public cloud
storage. International Journal of Security and Its
Applications 7, 6 (2013), 11–20.
[33] RON, D., AND SHAMIR, A. Quantitative analysis of the full
bitcoin transaction graph.
http://eprint.iacr.org/2012/584.pdf.
[34] SCHNORR, C.-P. Efﬁcient identiﬁcation and signatures for
smart cards (abstract). In EUROCRYPT (1989), J.-J.
Quisquater and J. Vandewalle, Eds., vol. 434 of Lecture
Notes in Computer Science, Springer, pp. 688–689.
[35] SHACHAM, H., AND WATERS, B. Compact Proofs of
Retrievability. In ASIACRYPT (2008), pp. 90–107.
[36] SHEN, S.-T., AND TZENG, W.-G. Delegable provable data
possession for remote data in the clouds. In ICICS (2011),
S. Qing, W. Susilo, G. Wang, and D. Liu, Eds., vol. 7043 of
Lecture Notes in Computer Science, Springer, pp. 93–111.
[37] SHI, E., STEFANOV, E., AND PAPAMANTHOU, C. Practical
dynamic proofs of retrievability. In ACM Conference on
Computer and Communications Security (2013), A.-R.
Sadeghi, V. D. Gligor, and M. Yung, Eds., ACM,
pp. 325–336.
[38] WATSON, G. J., SAFAVI-NAINI, R., ALIMOMENI, M.,
LOCASTO, M. E., AND NARAYAN, S. Lost: location based
storage. In CCSW (2012), T. Yu, S. Capkun, and S. Kamara,
Eds., ACM, pp. 59–70.
APPENDIX
A. POR SCHEMES OF SHACHAM AND
WATERS
The literature features a number of POR proposals; we refer the
readers to Section 5 for a comprehensive overview of existing pro-
posals. To the best of our knowledge, Juels and Kaliski (JK) [24]
propose the ﬁrst formal security deﬁnition of POR; their deﬁni-
tion relies on the notion of an extractor algorithm, which interacts
with the server provider, and must be able to extract the ﬁle with
overwhelming probability if the provider passes the POR veriﬁca-
tion. Shacham and Waters (SW) [35] later built on this model, and
proposed POR constructs based on private and public-key cryp-
tography which rely on homomorphic authenticators to reduce the
communication costs drastically by aggregating the responses of
the service provider.
PSW: The private POR scheme of SW (PSW) leverages pseudo-
random functions (PRFs). Here, the user ﬁrst erasure encodes a ﬁle
M and then splits it into n blocks m1, . . . , mn ∈ Zp, where p is
a large prime. The user then chooses a random α ∈R Zp and a
PRF key k for function f. The user then authenticates each block
as follows:
σi = fk(i) + αmi ∈ Zp.
The blocks {mi} and their authenticators {σi} are all stored at
the service provider in M∗.
At the POR veriﬁcation stage, the veriﬁer (here, the user) chooses
a random challenge set I ⊂R [1, n], |I| = (cid:96), and (cid:96) random co-
efﬁcients νi ∈R Zp. The challenge query then is the set Q :=
{(i, νi)}i∈I which is sent to the prover (here, service provider).
The prover computes the response (σ, µ) as follows and sends it
back to the veriﬁer:
σ ← (cid:88)
νiσi, µ ← (cid:88)
(i,νi)∈Q
νimi.
(i,νi)∈Q
Finally, the veriﬁer checks the correctness of the response:
(cid:88)
(i,νi)∈Q
σ ?= αµ +
νifk(i).
Public SW POR Scheme: PSW only enables the user, who pos-
sesses the secrets α and k, to verify a POR. To enable any entity
which does not necessarily possess secrets to verify a POR, SW
propose two publicly veriﬁable POR schemes based on BLS signa-
tures [13] and RSA, respectively.
Public BLS SW Scheme: The setup phase requires choosing a
group G with support Zp, and a computable bilinear map e :
G × G → GT . Additionally, the user chooses a private key
x ∈ Zp, the corresponding public key v = gx ∈ G along with
another generator u ∈ G. In the storage phase, a signature on
each block i is computed σi = (H(i)umi )x. For veriﬁcation,
computes ρ = Hash(τ s). Next, he computes τ∗ as the product of
τ and the publicly known values. Finally, the provider computes T
such that T e = τ∗. The response (T, ρ) will pass CheckProof but
does not depend on the ﬁle.
C.
IMPACT OF BLOCK SIZE ON POR
VERIFICATION TIME
(a) Impact of block size on the veriﬁcation time of the cloud re-
sponse in Fortress and in PSW.
(b) Impact of block size on the veriﬁcation time of the cloud re-
sponse in the public BLS-based SW scheme.
(c) Impact of block size on the veriﬁcation time of the cloud re-
sponse in the public RSA-based SW scheme.
Figure 6: Impact of the block size on the veriﬁcation time of the
cloud response in the private and public SW schemes [35].
the challenge query Q is generated similarly to PSW and sent
to the prover who computes:
νimi ∈ Zp.
These values are sent to the veriﬁer who checks that:
σ ← (cid:89)
(i,νi)∈Q
σνi
i ∈ G, µ ← (cid:88)
 (cid:89)
(i,νi)∈Q
(i,νi)∈Q
 .
e(σ, g) ?= e
H(i)νi uµ, v
Public RSA SW Scheme: The public RSA-based SW scheme is
similar to its public counterpart. Here, the block authenticator
can be computed by σi = (H(i)umi )d mod N , where d is
the private key of the user. The cloud response is calculated
similarly to the public BLS SW scheme. Given the public
RSA key e, the veriﬁcation unfolds as follows:
σe ?=
H(i)νi uµ mod N.
(cid:89)
(i,νi)∈Q
B. ON THE VULNERABILITY OF EXIST-
ING SCHEMES AGAINST MALICIOUS
AUDITORS
As pointed out in Section 3.1, existing private-veriﬁable POR
and PDP schemes cannot be simply outsourced since they cannot
deter against malicious auditors. To illustrate this, we brieﬂy show
in what follows possible attacks by a malicious auditor in three
POR/PDP schemes. In the sequel, we adopt the notation from the
original works and refer to these for further details.
Our ﬁrst examples addresses SW-POR which has been the basis
of Fortress. Recall the private scheme as explained in Appendix A
and suppose the secrets of the user are given to a malicious auditor
who colludes with the service provider. This allows the provider to
generate correct proofs without actually storing the data.
More precisely, if the auditor and therefore the service provider
knows kprf and the values αj, 1 ≤ j ≤ s, he can use the following
strategy to pass the veriﬁcation test: For any challenge {(i, νi)},
(i,νi)∈Q νifkprf (i) and σ
as speciﬁed in the protocol. Then, using the knowledge of αj, the
j=1 αjµj. This
response will pass the veriﬁcation test but does not depend on the
original data.
the service provider computes x := (cid:80)
service provider chooses µj such that σ = x +(cid:80)s
The second example is the dynamic PDP scheme by Ateniese et
al. in [12]. In the veriﬁcation phase, the data owner receives a tuple
i) from the server where v(cid:48)
(z, v(cid:48)
i is an authenticated encryption of
v = (i, z) where i represents the index and z is some hash value.
Observe that the data owner only checks if v(cid:48)
i is an encryption of
(i, z) but does not check z itself. Here, a malicious service provider
simply samples some random z and returns z and an encryption of
(i, z). Also here, this response would pass veriﬁcation but does not
depend on the ﬁle.
Our ﬁnal example is the PDP by Ateniese et al. given in [11]. In
details, this PDP scheme contains a procedure called CheckProof
which involves three parameters: τ, T , and ρ. In a nutshell, ρ is
the hash value of τ s := gs·(α1mi1
+...+αcmic ) where the αi are
part of the challenge and the values mij represent the entries of the
ﬁle that are requested within the challenge. The core idea is that
in the setup phase, some tags Ti,m are generated which allow to
compute a value T such that T e is equal to τ times some publicly
known value. Here, e represents an RSA encryption key. A mali-
cious service provider who knows the secrets can construct correct
proofs backward. First, the provider chooses a random value τ and
4KB8KB16KB32KB64KB128KBBlockSize20406080100120140VeriﬁcationTime(sec)4KB8KB16KB32KB64KB128KBBlockSize20406080100120140160180VeriﬁcationTime(sec)4KB8KB16KB32KB64KB128KBBlockSize50100150200250300VeriﬁcationTime(sec)