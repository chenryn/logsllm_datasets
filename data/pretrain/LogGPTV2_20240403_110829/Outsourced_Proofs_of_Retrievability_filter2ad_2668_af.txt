### References

1. **Jerasure Library**  
   *Source*: [GitHub](https://github.com/tsuraan/Jerasure)  
   *Year*: 2008

2. **Amazon S3 Service Level Agreement**  
   *Source*: [AWS](http://aws.amazon.com/s3-sla/)  
   *Year*: 2009

3. **Microsoft Corporation. Windows Azure Pricing and Service Agreement**  
   *Year*: 2009

4. **JPBC: Java Pairing-Based Cryptography Library**  
   *Source*: [Project Website](http://gas.dia.unisa.it/projects/jpbc/#.U3HBFfna5cY)  
   *Year*: 2013

5. **Dell Data Protection Cloud Edition Data Sheet**  
   *Source*: [Dell](http://i.dell.com/sites/doccontent/shared-content/data-sheets/en/Documents/Dell_Data_Protection_Cloud_Edition_Data_Sheet.pdf)  
   *Year*: 2013

6. **Nakamoto, S. Bitcoin: A Peer-to-Peer Electronic Cash System**

7. **Androulaki, E., Karame, G., and Capkun, S. Evaluating User Privacy in Bitcoin**  
   *Source*: [IACR ePrint Archive](http://eprint.iacr.org/2012/596.pdf)

8. **Ateniese, G., Burns, R. C., Curtmola, R., Herring, J., Kissner, L., Peterson, Z. N. J., and Song, D. X. Provable Data Possession at Untrusted Stores**  
   *Conference*: ACM Conference on Computer and Communications Security (2007)  
   *Pages*: 598–609

9. **Ateniese, G., Pietro, R. D., Mancini, L. V., and Tsudik, G. Scalable and Efficient Provable Data Possession**  
   *Source*: IACR Cryptology ePrint Archive 2008  
   *Number*: 114

10. **Boneh, D., Lynn, B., and Shacham, H. Short Signatures from the Weil Pairing**  
    *Journal*: J. Cryptology 17, 4 (2004)  
    *Pages*: 297–319

11. **Bowers, K. D., Juels, A., and Oprea, A. HAIL: A High-Availability and Integrity Layer for Cloud Storage**  
    *Conference*: ACM Conference on Computer and Communications Security (2009)  
    *Pages*: 187–198

12. **Bowers, K. D., Juels, A., and Oprea, A. Proofs of Retrievability: Theory and Implementation**  
    *Conference*: CCSW (2009)  
    *Pages*: 43–54

13. **Bowers, K. D., Van Dijk, M., Juels, A., Oprea, A., and Rivest, R. L. How to Tell if Your Cloud Files Are Vulnerable to Drive Crashes**  
    *Conference*: ACM Conference on Computer and Communications Security (2011)  
    *Pages*: 501–514

14. **Cash, D., Küpçü, A., and Wichs, D. Dynamic Proofs of Retrievability via Oblivious RAM**  
    *Conference*: EUROCRYPT (2013)  
    *Pages*: 279–295

15. **Clark, J., and Essex, A. (Short Paper) CommitCoin: Carbon Dating Commitments with Bitcoin**  
    *Conference*: Proceedings of Financial Cryptography and Data Security (2012)

16. **Curtmola, R., Khan, O., Burns, R. C., and Ateniese, G. MR-PDP: Multiple-Replica Provable Data Possession**  
    *Conference*: ICDCS (2008)  
    *Pages*: 411–420

17. **Decker, C., and Wattenhofer, R. Information Propagation in the Bitcoin Network**  
    *Conference*: 13th IEEE International Conference on Peer-to-Peer Computing (2013)

18. **Dobre, D., Karame, G., Li, W., Majuntke, M., Suri, N., and Vukolić, M. Powerstore: Proofs of Writing for Efficient and Robust Storage**  
    *Conference*: Proceedings of the 2013 ACM SIGSAC Conference on Computer & Communications Security (CCS '13)  
    *Pages*: 285–298

19. **Dodis, Y., Vadhan, S. P., and Wichs, D. Proofs of Retrievability via Hardness Amplification**  
    *Conference*: TCC (2009)  
    *Pages*: 109–127

20. **Erway, C. C., Küpçü, A., Papamanthou, C., and Tamassia, R. Dynamic Provable Data Possession**  
    *Conference*: ACM Conference on Computer and Communications Security (2009)  
    *Pages*: 213–222

21. **Juels, A., and Kaliski, B. S. Jr. PORs: Proofs of Retrievability for Large Files**  
    *Conference*: ACM Conference on Computer and Communications Security (2007)  
    *Pages*: 584–597

22. **Karame, G. O., Androulaki, E., and Capkun, S. Double-Spending Fast Payments in Bitcoin**  
    *Conference*: Proceedings of the 2012 ACM Conference on Computer and Communications Security (CCS '12)  
    *Pages*: 906–917

23. **Meiklejohn, S., Pomarole, M., Jordan, G., Levchenko, K., McCoy, D., Voelker, G. M., and Savage, S. A Fistful of Bitcoins: Characterizing Payments Among Men with No Names**  
    *Conference*: Proceedings of the 2013 Conference on Internet Measurement Conference (IMC '13)  
    *Pages*: 127–140

24. **NetEm, The Linux Foundation**  
    *Website*: [Linux Foundation](http://www.linuxfoundation.org/collaborate/workgroups/networking/netem)  
    *Year*: 2009

25. **Peterson, Z. N. J., Gondree, M., and Beverly, R. A Position Paper on Data Sovereignty: The Importance of Geolocating Data in the Cloud**  
    *Conference*: Proceedings of the 3rd USENIX Conference on Hot Topics in Cloud Computing (HotCloud'11)  
    *Pages*: 9–9

26. **Pietro, R. D., and Sorniotti, A. Boosting Efficiency and Security in Proof of Ownership for Deduplication**  
    *Conference*: ASIACCS (2012)  
    *Editors*: H. Y. Youm and Y. Won  
    *Pages*: 81–82

27. **Popa, R. A., Lorch, J. R., Molnar, D., Wang, H. J., and Zhuang, L. Enabling Security in Cloud Storage SLAs with CloudProof**  
    *Conference*: Proceedings of the 2011 USENIX Conference on USENIX Annual Technical Conference (USENIXATC'11)  
    *Pages*: 31–31

28. **Reid, F., and Harrigan, M. An Analysis of Anonymity in the Bitcoin System**  
    *Source*: CoRR (2011)

29. **Ren, Y., Xu, J., Wang, J., and Kim, J.-U. Designated-Verifier Provable Data Possession in Public Cloud Storage**  
    *Journal*: International Journal of Security and Its Applications 7, 6 (2013)  
    *Pages*: 11–20

30. **Ron, D., and Shamir, A. Quantitative Analysis of the Full Bitcoin Transaction Graph**  
    *Source*: [IACR ePrint Archive](http://eprint.iacr.org/2012/584.pdf)

31. **Schnorr, C.-P. Efficient Identification and Signatures for Smart Cards (Abstract)**  
    *Conference*: EUROCRYPT (1989)  
    *Editors*: J.-J. Quisquater and J. Vandewalle  
    *Volume*: 434 of Lecture Notes in Computer Science  
    *Publisher*: Springer  
    *Pages*: 688–689

32. **Shacham, H., and Waters, B. Compact Proofs of Retrievability**  
    *Conference*: ASIACRYPT (2008)  
    *Pages*: 90–107

33. **Shen, S.-T., and Tzeng, W.-G. Delegable Provable Data Possession for Remote Data in the Clouds**  
    *Conference*: ICICS (2011)  
    *Editors*: S. Qing, W. Susilo, G. Wang, and D. Liu  
    *Volume*: 7043 of Lecture Notes in Computer Science  
    *Publisher*: Springer  
    *Pages*: 93–111

34. **Shi, E., Stefanov, E., and Papamanthou, C. Practical Dynamic Proofs of Retrievability**  
    *Conference*: ACM Conference on Computer and Communications Security (2013)  
    *Editors*: A.-R. Sadeghi, V. D. Gligor, and M. Yung  
    *Pages*: 325–336

35. **Watson, G. J., Safavi-Naini, R., Alimomeni, M., Locasto, M. E., and Narayan, S. Lost: Location Based Storage**  
    *Conference*: CCSW (2012)  
    *Editors*: T. Yu, S. Capkun, and S. Kamara  
    *Pages*: 59–70

### Appendix

#### A. POR Schemes of Shacham and Waters

The literature features a number of POR proposals; we refer the readers to Section 5 for a comprehensive overview of existing proposals. To the best of our knowledge, Juels and Kaliski (JK) [24] propose the first formal security definition of POR; their definition relies on the notion of an extractor algorithm, which interacts with the server provider and must be able to extract the file with overwhelming probability if the provider passes the POR verification. Shacham and Waters (SW) [35] later built on this model and proposed POR constructs based on private and public-key cryptography, which rely on homomorphic authenticators to reduce the communication costs drastically by aggregating the responses of the service provider.

**PSW: Private POR Scheme of SW**
- **Setup**: The user first erasure encodes a file \( M \) and then splits it into \( n \) blocks \( m_1, \ldots, m_n \in \mathbb{Z}_p \), where \( p \) is a large prime. The user then chooses a random \( \alpha \in_R \mathbb{Z}_p \) and a PRF key \( k \) for function \( f \). Each block is authenticated as follows:
  \[
  \sigma_i = f_k(i) + \alpha m_i \in \mathbb{Z}_p
  \]
- **Storage**: The blocks \( \{m_i\} \) and their authenticators \( \{\sigma_i\} \) are all stored at the service provider in \( M^* \).
- **Verification**: The verifier (here, the user) chooses a random challenge set \( I \subset_R [1, n] \), \( |I| = \ell \), and \( \ell \) random coefficients \( \nu_i \in_R \mathbb{Z}_p \). The challenge query is the set \( Q := \{(i, \nu_i)\}_{i \in I} \), which is sent to the prover (here, the service provider). The prover computes the response \( (\sigma, \mu) \) as follows and sends it back to the verifier:
  \[
  \sigma \leftarrow \sum_{(i, \nu_i) \in Q} \nu_i \sigma_i, \quad \mu \leftarrow \sum_{(i, \nu_i) \in Q} \nu_i m_i
  \]
- **Check**: The verifier checks the correctness of the response:
  \[
  \sigma \stackrel{?}{=} \alpha \mu + \sum_{(i, \nu_i) \in Q} \nu_i f_k(i)
  \]

**Public SW POR Scheme: PSW only enables the user, who possesses the secrets \( \alpha \) and \( k \), to verify a POR. To enable any entity that does not necessarily possess secrets to verify a POR, SW propose two publicly verifiable POR schemes based on BLS signatures [13] and RSA, respectively.**

**Public BLS SW Scheme:**
- **Setup**: Choose a group \( G \) with support \( \mathbb{Z}_p \) and a computable bilinear map \( e: G \times G \to G_T \). Additionally, the user chooses a private key \( x \in \mathbb{Z}_p \), the corresponding public key \( v = g^x \in G \) along with another generator \( u \in G \).
- **Storage**: A signature on each block \( i \) is computed as \( \sigma_i = (H(i) u^{m_i})^x \).
- **Verification**: The challenge query \( Q \) is generated similarly to PSW and sent to the prover who computes:
  \[
  \sigma \leftarrow \prod_{(i, \nu_i) \in Q} \sigma_i^{\nu_i} \in G, \quad \mu \leftarrow \sum_{(i, \nu_i) \in Q} \nu_i m_i
  \]
- **Check**: The verifier checks:
  \[
  e(\sigma, g) \stackrel{?}{=} e\left(\prod_{(i, \nu_i) \in Q} H(i)^{\nu_i} u^\mu, v\right)
  \]

**Public RSA SW Scheme:**
- **Setup**: The block authenticator can be computed by \( \sigma_i = (H(i) u^{m_i})^d \mod N \), where \( d \) is the private key of the user.
- **Verification**: Given the public RSA key \( e \), the verification unfolds as follows:
  \[
  \sigma^e \stackrel{?}{=} \prod_{(i, \nu_i) \in Q} H(i)^{\nu_i} u^\mu \mod N
  \]

#### B. On the Vulnerability of Existing Schemes Against Malicious Auditors

As pointed out in Section 3.1, existing private-verifiable POR and PDP schemes cannot be simply outsourced since they cannot deter against malicious auditors. To illustrate this, we briefly show possible attacks by a malicious auditor in three POR/PDP schemes. In the sequel, we adopt the notation from the original works and refer to these for further details.

**Example 1: SW-POR (Private Scheme)**
- **Attack**: If the secrets of the user (i.e., \( k_{\text{prf}} \) and \( \alpha_j \)) are given to a malicious auditor who colludes with the service provider, the provider can generate correct proofs without actually storing the data. Specifically, if the auditor and therefore the service provider knows \( k_{\text{prf}} \) and the values \( \alpha_j \), 1 ≤ j ≤ s, he can use the following strategy to pass the verification test: For any challenge \( \{(i, \nu_i)\} \), the service provider computes \( x := \sum_{(i, \nu_i) \in Q} \nu_i f_{k_{\text{prf}}}(i) \) and \( \sigma \) as specified in the protocol. Then, using the knowledge of \( \alpha_j \), the service provider chooses \( \mu_j \) such that \( \sigma = x + \sum_{j=1}^s \alpha_j \mu_j \). This response will pass the verification test but does not depend on the original data.

**Example 2: Dynamic PDP Scheme by Ateniese et al. [12]**
- **Attack**: In the verification phase, the data owner receives a tuple \( (z, v') \) from the server where \( v' \) is an authenticated encryption of \( v = (i, z) \) where \( i \) represents the index and \( z \) is some hash value. Observe that the data owner only checks if \( v' \) is an encryption of \( (i, z) \) but does not check \( z \) itself. Here, a malicious service provider simply samples some random \( z \) and returns \( z \) and an encryption of \( (i, z) \). This response would pass verification but does not depend on the file.

**Example 3: PDP by Ateniese et al. [11]**
- **Attack**: This PDP scheme contains a procedure called `CheckProof` which involves three parameters: \( \tau \), \( T \), and \( \rho \). In a nutshell, \( \rho \) is the hash value of \( \tau^s := g^{s \cdot (\alpha_1 m_{i1} + \ldots + \alpha_c m_{ic})} \) where the \( \alpha_i \) are part of the challenge and the values \( m_{ij} \) represent the entries of the file that are requested within the challenge. The core idea is that in the setup phase, some tags \( T_{i,m} \) are generated which allow to compute a value \( T \) such that \( T^e \) is equal to \( \tau \) times some publicly known value. Here, \( e \) represents an RSA encryption key. A malicious service provider who knows the secrets can construct correct proofs backward. First, the provider chooses a random value \( \tau \) and computes \( \rho = \text{Hash}(\tau^s) \). Next, he computes \( \tau^* \) as the product of \( \tau \) and the publicly known values. Finally, the provider computes \( T \) such that \( T^e = \tau^* \). The response \( (T, \rho) \) will pass `CheckProof` but does not depend on the file.

#### C. Impact of Block Size on POR Verification Time

- **Figure 6(a)**: Impact of block size on the verification time of the cloud response in Fortress and in PSW.
- **Figure 6(b)**: Impact of block size on the verification time of the cloud response in the public BLS-based SW scheme.
- **Figure 6(c)**: Impact of block size on the verification time of the cloud response in the public RSA-based SW scheme.

![Impact of Block Size on Verification Time](path_to_figure.png)

- **Block Sizes**: 4KB, 8KB, 16KB, 32KB, 64KB, 128KB
- **Verification Time (sec)**: 
  - **PSW and Fortress**: 20-140 seconds
  - **BLS-based SW Scheme**: 20-180 seconds
  - **RSA-based SW Scheme**: 50-300 seconds