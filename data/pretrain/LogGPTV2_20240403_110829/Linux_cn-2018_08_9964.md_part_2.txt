所有的这些解决方案都简化了网络管理，就像它们可以让一个管理员开始从“box-by-box”管理（LCTT 译者注：指的是单个设备挨个去操作的意思）迁移到网络范围的管理。这是在正确方向上迈出的很大的一步，这些解决方案并不能消除在变更期间中人类犯错的机率。例如，比起配置 *N* 个交换机，你可能需要去配置一个单个的 GUI，它需要很长的时间才能实现所需要的配置改变 —— 它甚至可能更复杂，毕竟，相对于一个 CLI，他们更喜欢 GUI！另外，你可能有不同类型的 SDN 解决方案部署在每个应用程序、网络、区域或者数据中心。
在需要自动化的网络中，对于配置管理、监视和数据收集，当行业开始向基于控制器的网络架构中迁移时，这些需求并不会消失。
大量的软件定义网络中都部署有控制器，几乎所有的控制器都 提供   expose 一个最新的 REST API。并且，因为 Ansible 是一个无代理架构，它实现自动化是非常简单的，而不仅仅是对那些没有 API 的传统设备，但也有通过 REST API 的软件定义网络解决方案，在所有的终端上不需要有额外的软件（LCTT 译注：指的是代理）。最终的结果是，使用 Ansible，无论有或没有 API，可以使任何类型的设备都能够自动化。
#### 自由开源软件（FOSS)
Ansible 是一个开源软件，它的全部代码在 GitHub 上都是公开可访问的，使用 Ansible 是完全免费的。它可以在几分钟内完成安装并为网络工程师提供有用的价值。Ansible 这个开源项目，或者 Ansible 公司，在它们交付软件之前，你不会遇到任何一个销售代表。那是显而易见的事实，因为它是一个真正的开源项目，但是，作为开源的、社区驱动的软件项目在网络行业中的使用是非常少的，但是，也在逐渐增加，我们想明确指出这一点。
同样需要指出的一点是，Ansible, Inc. 也是一个公司，它也需要去赚钱，对吗？虽然 Ansible 是开源的，它也有一个叫 Ansible Tower 的企业产品，它增加了一些特性，比如，基于规则的访问控制（RBAC）、报告、 web UI、REST API、多租户等等，（相比 Ansible）它更适合于企业去部署。并且，更重要的是，Ansible Tower 甚至可以最多在 10 台设备上 *免费* 使用，至少，你可以去体验一下，它是否会为你的组织带来好处，而无需花费一分钱，并且，也不需要与无数的销售代表去打交道。
#### 可扩展性
我们在前面说过，Ansible 主要是为部署 Linux 应用程序而构建的自动化平台，虽然从早期开始已经扩展到 Windows。需要指出的是，Ansible 开源项目并没有“自动化网络基础设施”的目标。事实上是，Ansible 社区更明白如何在底层的 Ansible 架构上更具灵活性和可扩展性，对于他们的自动化需要（包括网络）更容易成为一个 *扩展* 的 Ansible。在过去的两年中，部署有许多的 Ansible 集成，许多是有行业独立人士进行的，比如，Matt Oswalt、Jason Edelman、Kirk Byers、Elisa Jasinska、David Barroso、Michael Ben-Ami、Patrick Ogenstad 和 Gabriele Gerbino，也有网络系统供应商的领导者，比如，Arista、Juniper、Cumulus、Cisco、F5、和 Palo Alto Networks。
#### 集成到已存在的 DevOps 工作流中
Ansible 在 IT 组织中被用于应用程序部署。它被用于需要管理部署、监视和管理各种类型的应用程序的运维团队中。通过将 Ansible 集成到网络基础设施中，当新应用程序到来或迁移后，它扩展了可能的范围。而不是去等待一个新的顶架交换机（LCTT 译注：TOR，一种数据中心设备接入的方式）的到来、去添加一个 VLAN、或者去检查接口的速度/双工，所有的这些以网络为中心的任务都可以被自动化，并且可以集成到 IT 组织内已经存在的工作流中。
#### 幂等性
术语 幂等性   idempotency  （读作 item-potency）经常用于软件开发的领域中，尤其是当使用 REST API 工作的时候，以及在 *DevOps* 自动化和配置管理框架的领域中，包括 Ansible。Ansible 的其中一个信念是，所有的 Ansible 模块（集成的）应该是幂等的。那么，对于一个模块来说，幂等是什么意思呢？毕竟，对大多数网络工程师来说，这是一个新的术语。
答案很简单。幂等性的本质是允许定义的任务，运行一次或者上千次都不会在目标系统上产生不利影响，仅仅是一种一次性的改变。换句话说，如果有一个要做的改变去使系统进入到它期望的状态，这种改变完成之后，并且，如果这个设备已经达到这种状态，就不会再发生改变。这不像大多数传统的定制脚本和拷贝、黏贴到那些终端窗口中的 CLI 命令。当相同的命令或者脚本在同一个系统上重复运行，（有时候）会出现错误。即使是粘贴一组命令到一个路由器中，也可能会遇到一些使你的其余的配置失效的错误。好玩吧?
另外的例子是，如果你有一个配置 10 个 VLAN 的文件文件或者脚本，那么 *每次* 运行这个脚本，相同的命令命令会被输入 10 次。如果使用一个幂等的 Ansible 模块，首先会从网络设备中采集已存在的配置，并且，每个新的 VLAN 被配置后会再次检查当前配置。仅仅当这个新的 VLAN 需要被添加（或者，比如说改变 VLAN 名字）是一个变更，命令才会真实地推送到设备。
当一个技术越来越复杂，幂等性的价值就越高，在你修改的时候，你并不能注意到 *已存在* 的网络设备的状态，而仅仅是从一个网络配置和策略角度去尝试达到 *期望的* 状态。
#### 网络范围的和临时（Ad Hoc）的改变
用配置管理工具解决的其中一个问题是，配置“飘移”（当设备的期望配置逐渐漂移，或者改变，随着时间的推移，手动改变和/或在一个环境中使用了多个不同的工具），事实上，这也是像 Puppet 和 Chef 所使用的地方。代理商 电联   phone home 到前端服务器，验证它的配置，并且，如果需要变更，则改变它。这个方法是非常简单的。如果有故障了，需要去排除怎么办？你通常需要跳过管理系统，直接连到设备，找到并修复它，然后，马上离开，对不对？果然，在下次当代理电连回来，这个修复问题的改变被覆盖了（基于主/前端服务器是怎么配置的）。在高度自动化的环境中，一次性的改变应该被限制，但是，仍然允许使用它们（LCTT 译注：指的是一次性改变）的工具是非常有价值的。正如你想到的，其中一个这样的工具是 Ansible。
因为 Ansible 是无代理的，这里并没有一个默认的推送或者拉取去防止配置漂移。自动化任务被定义在 Ansible  清单   inventory 的文件决定；这个清单可以是一台设备或者是一千台设备。
下面展示的一个清单文件示例，它定义了两组共六台设备：
```
[core-switches]
dc-core-1
dc-core-2
[leaf-switches]
leaf1
leaf2
leaf3
leaf4
```
为了自动化所有的主机，你的剧本中的 剧集   play 定义的一个片段看起来应该是这样的：
```
hosts: all
```
并且，要只自动化一个叶子节点交换机，它看起来应该像这样：
```
hosts: leaf1
```
这是一个核心交换机：
```
hosts: core-switches
```
> 
> 注意
> 
> 
> 正如前面所说的那样，这个报告的后面部分将详细介绍剧本、剧集、和清单。
> 
> 
> 
因为能够很容易地对一台设备或者 *N* 台设备进行自动化，所以在需要对这些设备进行一次性变更时，Ansible 成为了最佳的选择。在网络范围内的变更它也做的很好：可以是关闭给定类型的所有接口、配置接口描述、或者是在一个跨企业园区布线的网络中添加 VLAN。
### 使用 Ansible 实现网络任务自动化
这个报告从两个方面逐渐深入地讲解一些技术。第一个方面是围绕 Ansible 架构和它的细节，第二个方面是，从一个网络的角度，讲解使用 Ansible 可以完成什么类型的自动化。在这一章中我们将带你去详细了解第二方面的内容。
自动化一般被认为是速度快，但是，考虑到一些任务并不要求速度，这就是为什么一些 IT 团队没有认识到自动化的价值所在。VLAN 配置是一个非常好的例子，因为，你可能会想，“创建一个 VLAN 到底有多快？一般情况下每天添加多少个 VLAN？我真的需要自动化吗？”
在这一节中，我们专注于另外几种有意义的自动化任务，比如，设备准备、数据收集、报告和遵从情况。但是，需要注意的是，正如我们前面所说的，自动化为你、你的团队、以及你的精确的更可预测的结果和更多的确定性，提供了更快的速度和敏捷性。
#### 设备准备
为网络自动化开始使用 Ansible 的最容易也是最快的方法是，为设备的最初投入使用创建设备配置文件，并且将配置文件推送到网络设备中。
如果我们去完成这个过程，它将分解为两步，第一步是创建一个配置文件，第二步是推送这个配置到设备中。
首先，我们需要去从供应商配置文件的底层专用语法（CLI）中解耦 *输入*。这意味着我们需要对配置参数中分离出文件和值，比如，VLAN、域信息、接口、路由、和其它的内容等等，然后，当然是一个配置的模块文件。在这个示例中，这里有一个标准模板，它可以用于所有设备的初始部署。Ansible 将帮助提供配置模板中需要的输入和值之间的部分。几秒钟之内，Ansible 可以生成数百个可靠的和可预测的配置文件。
让我们快速的看一个示例，它使用当前的配置，并且分解它到一个模板和单独的一个（作为一个输入源的）变量文件中。
这是一个配置文件片断的示例：
```
hostname leaf1
ip domain-name ntc.com
!
vlan 10
   name web
!
vlan 20
   name app
!
vlan 30
   name db
!
vlan 40
   name test
!
vlan 50
   name misc
```
如果我们提取输入值，这个文件将被转换成一个模板。
> 
> 注意：
> 
> 
> Ansible 使用基于 Python 的 Jinja2 模板化语言，因此，这个被命名为 *leaf.j2* 的文件是一个 Jinja2 模板。
> 
> 
> 
注意，下列的示例中，*双大括号（`{{}}`）* 代表一个变量。
模板看起来像这些，并且给它命名为 `leaf.j2`：
```
!
hostname {{ inventory_hostname }}
ip domain-name {{ domain_name }}
!
!
{% for vlan in vlans %}
vlan {{ vlan.id }}
  name {{ vlan.name }}
{% endfor %}
!
```
因为双大括号代表变量，并且，我们看到这些值并不在模板中，所以它们需要将值保存在一个地方。值被保存在一个变量文件中。正如前面所说的，一个相应的变量文件看起来应该是这样的：
```
---
hostname: leaf1
domain_name: ntc.com
vlans:
  - { id: 10, name: web }
  - { id: 20, name: app }
  - { id: 30, name: db }
  - { id: 40, name: test }
  - { id: 50, name: misc }
```
这意味着，如果管理 VLAN 的团队希望在网络设备中添加一个 VLAN，很简单，他们只需要在变量文件中改变它，然后，使用 Ansible 中一个叫 `template` 的模块，去重新生成一个新的配置文件。这整个过程也是幂等的；仅仅是在模板或者值发生改变时，它才会去生成一个新的配置文件。
一旦配置文件生成，它需要去 *推送* 到网络设备。推送配置文件到网络设备使用一个叫做 `napalm_install_config`的开源的 Ansible 模块。
接下来的示例是一个 *构建并推送* 一个配置文件到网络设备的简单剧本。同样地，该剧本使用一个名叫 `template` 的模块去构建配置文件，然后使用一个名叫 `napalm_install_config` 的模块去推送它们，并且激活它作为设备上运行的新的配置文件。
虽然没有详细解释示例中的每一行，但是，你仍然可以看明白它们实际上做了什么。