58 instrs
Figure 4: Malware propagation of Gapz.
previously been reported to be unreliable when instrumenting mal-
ware. For example, it fails instrumentation in case of code injection
into processes with multiple active threads [18].
7.3 Detailed analysis
To demonstrate the precision of our approach and its ability to
give insights about code injection techniques we present in this
section two detailed case studies of Tartarus. (cid:140)e (cid:128)rst case study is
from a Gapz malware sample and the second case is from a recently
published code injection technique called AtomBombing.
Gapz malware. Figure 4 shows a high-level view of the system-
wide CFG produced by Tartarus when matched with a sample from
the Gapz malware family. (cid:140)e solid arrows represent control-(cid:131)ow,
the dashed arrow represent data-(cid:131)ow and the black circle is the
entry point.
(cid:140)e malware (cid:128)rst decrypts itself with a single wave of self-
modifying code and then proceeds to inject code into explorer.exe.
Because Tartarus has identi(cid:128)ed an injection catalyst, we know there
are code-reuse a(cid:138)acks involved in the injection. Furthermore, the
injection transfers control to a rather small code wave of only 58 in-
structions. (cid:140)is suggests that the malware uses a code-reuse a(cid:138)ack
to leverage shellcode execution inside of explorer.exe, and this
is indeed the case. (cid:140)e key components identi(cid:128)ed by Tartarus are
shown in Figure 2, and Figure 5 shows a part of the code injection
graph for the three (cid:128)rst gadgets in the key components. Rounded
boxes are control-(cid:131)ow and squared boxes are taint-propagating
nodes. (cid:140)e rounded boxes shows the code-reuse initiator and also
the gadget itself.
Investigating the key components, we observe the (cid:128)rst code-
reuse a(cid:138)ack is a call to KiUserAPCDispatcher, and the code of
this function is shown in the bo(cid:138)om of Figure 3. (cid:140)is gadget puts
the value of esp + 0x10 into edi and the second gadget executes
the instruction std which will cause the direction (cid:131)ag to be set.
(cid:140)e third gadget, initiated by the instruction at 1001b4b, executes
the two instructions: mov ecx, 0x94 followed by rep movsd,
e(cid:130)ectively causing 0x94 bytes to be copied from esi to edi. Because
the direction (cid:131)ag is set, edi and esi will be decreased by one a(cid:137)er
every mov instruction. Recall that edi was set to esp + 0x10 by the
(cid:128)rst gadget, which means that the memory at the top of the stack
AtomBombing.exe
Nt(cid:134)eueAPC(cid:135)read
CALL [ebp-0xc]
. . .
explorer.exe
ZwSet(cid:135)readContext
. . .
ZwAllocateVirtualMemory
. . .
ret
wave0
mov eax, edi
. . .
RPCDispatcher
. . .
CALL eax
memcpy
. . .
ret
ret
Figure 6: AtomBombing caught by Tartarus
with hook on Nt(cid:134)eueAPC(cid:135)read.
to be overwri(cid:138)en with whatever esi points to. We can therefore
easily conclude the stack is being overwri(cid:138)en with the memory
pointed to by esi, hinting strongly towards a set of indirect call
instructions being hijacked to allow for a ROP a(cid:138)ack. Before we
proceed, it is important to note here that the malware execution
trace is subset of all the instructions executed. When the third
gadget is executed there has in fact been several push instructions
between the (cid:128)rst and the third gadget, resulting in a larger distance
between esp and edi than 0x14 as can be thought from looking at
the malware execution trace. However, these are not part of the
malware execution trace and is therefore not shown by Tartarus.
Investigating the code injection graph, we observe that Tartarus
correctly identi(cid:128)es SendNotifyMessage as the code execution ini-
tiator and SetWindowsLong as a function responsible for data-(cid:131)ow
in the overwri(cid:138)en addresses in the code-reuse a(cid:138)acks. Further anal-
ysis reveals that the ROP chain uses WriteProcessMemory to over-
write memory inside the process of explorer.exe and then pro-
ceeds to transfer execution to the (cid:128)rst wave inside explorer.exe.
Investigating the complete code injection graph, shown in Appen-
dix A, we see with minimal e(cid:130)ort that the code-reuse a(cid:138)acks does
in fact turn into a ROP chain and also that the return addresses
were overwri(cid:138)en by the rep movsd instruction.
AtomBombing. Recently, researchers discovered a new injec-
tion technique called AtomBombing [27], which uses code-reuse
a(cid:138)acks to avoid using standard API calls for code injection. (cid:140)e
technique was (cid:128)rst presented October 2016 and only four months
later researchers discovered a new 64-bit version of the Dridex
malware that had adopted AtomBombing into its arsenal [2].
AtomBombing abuses the global atom table in Windows to share
memory between processes and undocumented asynchronous pro-
cedure calls to force the injectee application to call various functions
on behalf of the injecting process. Speci(cid:128)cally, the injecting process
writes a ROP chain and shellcode onto the global atom table us-
ing GlobalAddAtom. (cid:140)e injecter then uses NtQueueApcThread to
force the injectee process to call GlobalGetAtomName such that the
ROP chain and shellcode is stored inside the target process. To in-
voke execution, the injecter again uses NtQueueApcThread to force
the injectee to call SetThreadContext to navigate eip and esp. eip
Session H2:  Code Reuse AttacksCCSâ€™17, October 30-November 3, 2017, Dallas, TX, USA1701mov [esi + 0x80], eax
0xa40, wave1
0x9b373d
mov [esi + 0x94], eax
0xa40, wave1
9b3748
[eax] chaser
Call SendNotifyMessage
push eax
0xa40, wave1
0x9b3aee
push [ebp + 0x10]
0xa40
0x7e42c2a4
User32.dll
SetWindowsLong
[esi] chaser
eax chaser
1001b4b Call [eax]
KiUserAPCDispatcher
. . .
Kernel
esi chaser
mov eax, [esi]
eax chaser
1001b59 Call [eax + 8]
std
ret
[eax + 8] chaser
mov [esi + 0x9c], eax
0xa40, wave1
0x9b3765
mov [esi + 0x94], eax
0xa40, wave1
0x9b3748
eax chaser
[eax+4] chaser
1001b6e Call [eax + 4]
mov ecx, 0x94
rep movsd
pop edi
xor eax, eax
pop esi
pop edi
Figure 5: Code injection graph for the (cid:128)rst three gadgets in Gapz code injection. (cid:135)e graph shows that in all
three call gadgets the value tainting eax was propagated through SetWindowsLong in the host process.
AtomBombing.exe
CALL ds:ExitProcess
explorer.exe
ZwSet(cid:135)readContext
. . .
ZwAllocateVirtualMemory
. . .
ret
wave0
mov eax, edi
. . .
ExitProcess
. . .
RPCDispatcher
. . .
CALL eax
memcpy
. . .
ret
ret
Figure 7: AtomBombing caught by Tartarus
without any hooks.
is set to ZwAllocateV irtualMemory which is the (cid:128)rst code-reuse
a(cid:138)ack in the target process, and esp is set to point to the begin-
ning of the ROP chain. As such, AtomBombing achieves code
execution with a combination of calls to NtQueueApcThread and
GlobalAddAtom in the injecter process.
When Tartarus is matched with AtomBombing, Tartarus (cid:128)nds
the code injection shown in Figure 6. Tartarus captures the code in-
jection exactly, seeing that a call to NtQueueApcThread in the host
process results in the target process calling SetThreadContext.
(cid:140)e ret instruction inside ZwAllocateVirtualMemory is the (cid:128)rst
ROP gadget in the injection. (cid:140)is ROP gadget transfers execution to
memcpy and the return instruction of memcpy transfers execution to
a simple ROP gadget consisting of only a ret instruction. (cid:140)is gad-
gets is there because the ROP chain must catch the dest parameter
given to memcpy, which is 4 bytes away from the original return
address. (cid:140)erefore, the third ret instruction executed results in
transfer of control to the destination of the copied bu(cid:130)er.
In Figure 7, we show the AtomBombing injection caught by Tar-
tarus when there are no hooks on NtQueueApcThread. In this case,
Tartarus catches the exact same code injection except for the initia-
tor instruction which in this case is a call to ExitProcess. (cid:140)e reason
this happens is because Nt(cid:137)eueAPC(cid:138)read is an asynchronous
procedure call, which means that the last API call in the injector
process at the time the injection happens inside explorer.exe is not
Nt(cid:137)eueAPC(cid:138)read because execution has continued inside the
injector process itself. (cid:140)is clearly shows the use of hooks in our
technique, namely to capture the right initiator instruction and not
to identify whether an injection has occurred or not.
7.4 Performance evaluation
(cid:140)e performance of Tartarus has a large impact on the applica-
tions of the tool. Because we speci(cid:128)cally use Tartarus for malware
analysis, we measure the performance of Tartarus relative to the
malware samples in our data set. For a performance measurement
speci(cid:128)cally about DECAF, we refer to the original DECAF paper
[21]. To put the performance of Tartarus in perspective, we mea-
sure how fast Tartarus identi(cid:128)es the instructions that are part of the
system-wide CFG, i.e. unique instructions in the malware execution
trace, during execution of the samples.
We selected one sample from each of the malware families in
our B data set and ran them for 1100 seconds inside Tartarus. (cid:140)e
samples shared very similar behaviours to the other samples in
their respective families, so each sample represents well the overall
malware family. Our experiments were performed on a laptop
with an i7 (cid:139)ad Core 2.5 GHz processor and 16 GB of ram and
three instances of the dynamic analysis environment were run
simultaneously, meaning 3 samples were analysed approximately
every 1100 seconds on a standard laptop. We used a Windows XP
SP3 image. Our experiments were performed with our taint-logging
turned o(cid:130), meaning Tartarus is able to identify code waves and
code injections with their key components, but not the entire code
injection graph. (cid:140)e results are shown in Figure 8.
We can see in Figure 8 that the majority of Tinba was captured in
less than 2 minutes, Gapz about 13 minutes, Ramnit about 7 minutes
Session H2:  Code Reuse AttacksCCSâ€™17, October 30-November 3, 2017, Dallas, TX, USA1702e
z
i
s
G
F
C
e
v
i
t
a
l
e
R
100
80
60
40
20
0
Gapz
Tinba
Ramnit
CryptoWall
0
5
10
15
20
Time (min)
Figure 8: Size of CFG relative to analysis time.
Total instructions MT instructions
Gapz
TinyBanker
CryptoWall
Ramnit
1.2B
230M
2.0B
580M
225M
10M
250M
50M
Last injection
13Min
2Min
14Min
7Min
Table 4: Instruction count of malware
samples. #MT = Malware execution trace.
and CryptoWall 4.0 in about about 17 minutes. To put this into
perspective of the sample sizes, we ran the same experiment with
two counters for capturing the number of instructions executed
in entire system and the number of instructions in the malware
execution trace. We counted until the last code injection in each of
the samples. (cid:140)e instruction counts are shown in Table 4.
An interesting aspect of Figure 8 is how clearly it shows that the
samples in our dataset work in stages in that the construction of the
CFG is not linear but more of a step-wise construction. For example,
the Gapz malware has revealed about 65% of its CFG within the
(cid:128)rst 3 minutes, but then continues for 10 with only about 5% more
of the CFG constructed. A(cid:137)er 13 minutes of execution time, Gapz
(cid:128)nally reveals more of itself and a big leap to about 95% happens.
To put the construction of the CFG into perspective of dynam-
ically generated code and code injections, Figure 9 and Figure 10
show the CFG construction relative to execution time, with the
addition of markers for when the (cid:128)rst wave of dynamically gener-
ated code and code injections occurred. (cid:140)e graphs are of a Tinba
and a Gapz sample, respectively. Note the Tinba graph is zoomed
in on the (cid:128)rst 2 minutes of execution time. A triangle shows the
(cid:128)rst wave of dynamically generated code and a circle denotes a
code injection. We observe that the majority of the code execu-
tion happens a(cid:135)er the (cid:128)rst wave of dynamically generated code.
Namely, in the Tinba case, more than 90% of the malware execution
happens a(cid:137)er the (cid:128)rst wave of dynamically generated code and in
the Gapz sample about 60%. Furthermore, in the Tinba case more
than 80% of unique instructions in the CFG happens a(cid:137)er the (cid:128)rst
code injection, where in the Gapz sample more than 20% happens
a(cid:137)er the (cid:128)rst code injection.
100
80
60
40
20
0
e
z
i
s
G
F
C
e
v
i
t