title:Traps and Pitfalls: Practical Problems in System Call Interposition
Based Security Tools
author:Tal Garfinkel
Traps and Pitfalls: Practical Problems in System Call Interposition Based
Security Tools
Tal Garﬁnkel
PI:EMAIL
Computer Science Department, Stanford University
Abstract
System call interposition is a powerful method for reg-
ulating and monitoring application behavior.
In recent
years, a wide variety of security tools have been developed
that use this technique. This approach brings with it a host
of pitfalls for the unwary implementer that if overlooked
can allow his tool to be easily circumvented. To shed light
on these problems, we present the lessons we learned in
the course of several design and implementation cycles
with our own system call interposition-based sandboxing
tool. We ﬁrst present some of the problems and pitfalls we
encountered, including incorrectly replicating OS seman-
tics, overlooking indirect paths to resources, race condi-
tions, incorrectly subsetting a complex interface, and side
effects of denying system calls. We then present some
practical solutions to these problems, and provide general
principles for avoiding the difﬁculties we encountered.
1 Introduction
The explosion of interest in OS-based intrusion detec-
tion and conﬁnement in recent years has brought with it
a host of approaches to security that rely on system call
interposition1 for conﬁnement [24, 2, 5, 3, 9, 11, 19, 14]
and intrusion detection [15, 30, 21, 27]. The system call
interface is a compelling boundary on which to interpose
, as it allows virtually all of an application’s interactions
with the network, ﬁle system, and other sensitive system
resources to be monitored and regulated. Unfortunately,
building tools that securely interpose on this interface can
be quite subtle. If the implementer is not careful, his tool
can easily be circumvented.
Over the course of several design and implementation
iterations to build the current incarnation of Janus, our
1System call interposition is sometimes referred to as system call in-
terception or system call tracing. The latter term typically refers to an
architecture where the system call interface is passively monitored.
own system call interposition-based application sandbox-
ing tool, we have encountered a host of mistakes and chal-
lenges related to building this class of systems. Given the
perspective of this experience, we believe that past work
in this area has often painted an incomplete or inaccurate
picture of the steps required to ensure the correctness of an
interposition-based tool. Often the details of the interposi-
tion mechanism, tool architecture, and underlying OS se-
mantics are only given cursory consideration. Most work
has instead focused on higher-level issues such as policy
speciﬁcation [3, 8] and analysis of system call patterns
[21, 15] for intrusion detection. Work that has focused
on mechanism [13, 11, 16] has been more concerned with
general design issues and performance than with the pit-
falls of the mechanism’s use in practice, where interac-
tions between interposition mechanism, tool architecture,
and the system call API must be taken into account.
We have found that the problems that arise from these
interactions can be quite subtle. The Unix API is tremen-
dously complex, as are the speciﬁcs of process-tracing in-
terfaces. Because work on system call interposition often
fails to take these details into account, its results may be
based on assumptions that are incomplete, unjustiﬁed or
simply wrong. Overlooking a “minor detail” can often un-
dermine a tool’s security. The changes that must be made
to a tool’s architecture to deal with a “minor detail” can
be signiﬁcant, and can have important implications for the
system’s performance and the range of security policies it
can enforce.
Presenting a detailed analysis of Unix for the purposes
of building interposition tools is far beyond the scope of a
single paper. In this work we will instead present the pit-
falls and problems we encountered in the course of build-
ing Janus, the solutions that we explored, and the prin-
ciples we distilled out of our experience for designing,
building, and auditing this class of systems. Although
these lessons are presented in the context of our work on a
sandboxing tool, most of the problems and solutions have
equal relevance to intrusion detection tools that rely on
system call interposition.
Our paper will proceed as follows. In Section 2 we pro-
vide background on the current version of Janus, discuss
related work on system call interposition-based security
tools and examine the relationship of interposition-based
sandboxing and intrusion detection tools. In Section 3 we
provide a basic model of how Janus works to provide con-
text for our discussion. Section 4 discusses the pitfalls
and problems that we encountered while building Janus;
these are divided into the following categories: incorrectly
replicating OS semantics, overlooking indirect paths to re-
sources, race conditions, incorrectly subsetting a complex
interface, and side effects of denying system calls. We
explain each category of error, then present concrete ex-
amples in the context of Janus. In Section 5 we present
solutions to some of the problems discussed in Section
4, consider the design choices and trade-offs we made in
Janus, and present some alternative designs. We also offer
design principles to help avoid the types of pitfalls that we
encountered. Section 6 presents a discussion of some re-
maining open questions and topics for future work in the
design of system call interposition-based security tools.
We conclude our discussion in Section 7.
2 Background and Related Work
The current Janus implementation was built through a
process of successive improvements and re-writings, start-
ing from the original prototype described in Goldberg
et. al. [14]. The original Janus work presented an archi-
tecture for restricting an application’s interactions with the
underlying operating system by interposing on the system
calls made by the application via standard process tracing
mechanisms. Several other systems for restricted execu-
tion were subsequently developed based upon this archi-
tecture including MapBox [3] and Consh [5].
Unfortunately, as detailed by Wagner [29], the ptrace
[22] interface, initially used by Janus for interposition in
Linux, has a variety of limitations that make it a poor
choice of mechanism for application sandboxing, and
other security-sensitive applications. Additional discus-
sion of the limitations of ptrace in the presence of hos-
tile applications is offered in Cesare [7].
There have been attempts to overcome the limitations
associated with ptrace through the creative use of other
standard Unix mechanisms; their results have been lack-
luster. Subterfugue [1] provides a means of overcoming
the problem of argument races (see Section 4.3.3) with
standard Unix mechanisms; unfortunately, their approach
exacts a severe performance penalty. Jain and Sekar [16]
demonstrate a more efﬁcient user-level approach to inter-
position using ptrace, but as the authors note, it relies
on a technique for avoiding system call argument races
that is not completely secure. The Solaris /proc inter-
face, another prominent process tracing mechanism, also
does not provide an ideal mechanism for security applica-
tions [29].
To address the problem of supporting secure system
call interposition, the present version of Janus relies on
its own dedicated system call interposition mechanism,
implemented in Linux as a loadable kernel module. A
similar approach to addressing this problem taken by Sys-
trace [24], another system call interposition-based secu-
rity tool whose design closely resembles the present ver-
sion of Janus.
Several groups have looked at developing novel system
call interposition mechanisms for a broader set of applica-
tions than simply sandboxing. Work on SLIC [13] and In-
terposition Agents [17] looked at providing an infrastruc-
ture for using interposition as a general mechanism for OS
extensibility. Ufo [4] examined the potential for applying
this technique as a means of implementing a user-level
ﬁlesystem.
Completely in-kernel system call interposition based
tools for application sandboxing have also been studied
by several groups [11, 2]. Several commercial products
using this approach are currently available [8, 9].
Intrusion detection via analysis of system call traces has
received a great deal of attention [10, 15, 21, 27]. Typ-
ically this work abstracts away many of the real details
of the system, choosing (explicitly or not) to work with
an idealized model of system call tracing. The problem
of secure system call tracing is similar to that of secure
system call interposition. In the system call tracing case,
the “viewer” is only interested in what calls an applica-
tion makes, and not in modifying them or denying them.
However, the same problems that can allow a system call
interposition-based sandbox to be circumvented can also
be used to evade a system call tracing-based IDS. The IDS
case is in some ways more difﬁcult. A sandbox can deny
system calls that would make interpreting the effects of
other calls difﬁcult, and can ignore issues like being over-
loaded by calls to analyze. An IDS is generally restricted
to passive observation, and thus must deal with these prob-
lems. Additionally, users are often willing to pay the over-
head associated with secure interposition for sandboxing
for some additional “guaranteed” degree of security; the
potential to simply detect an intruder may be less entic-
ing.
Our discussion of system call interposition requires
some basic knowledge of the Unix API. We recommend
readers looking for additional background on this topic re-
fer to Stevens [26] or McKusick et. al. [22].
3 The Janus Architecture
Intuitively, Janus can be thought of as a ﬁrewall that sits
between an application and the operating system, regulat-
Application
process
process
process
o
p
e
n
(
"
f
o
o
"
)
t
l
u
s
e
r
System Call Entry
t
l
u
s
e
r
Kernel Proper
open("foo")
Deny
result
Allow
open("foo")
janus
Policy Engine
)
"
o
o
f
"
(
n
e
p
o
A
l
l
/
o
w
D
e
n
y
mod_janus
User Space
Kernel Space
Figure 1. System Call Interposition in Janus
ing which system calls are allowed to pass. This is analo-
gous to the way that a ﬁrewall regulates what packets are
allowed to pass. Another way to think about Janus is as
an extension of the OS reference monitor that runs at user
level.
Concretely, Janus consists of mod janus, a kernel
module that provides a mechanism for secure system call
interposition, and janus, a user-level program that in-
terprets a user-speciﬁed policy in order to decide which
system calls to allow or deny.
To gain a better understanding of Janus’s basic operat-
ing model we will look at the lifetime of a program being
run under Janus:
1. At startup, janus reads in a policy ﬁle that speciﬁes
which ﬁles and network resources it will allow access
to.
2. janus then forks, the child process relinquishes
all of its resources (closes all of its descriptors, etc.),
and the parent attaches to the child with the trac-
ing interface provided via mod janus. At the user
level, this consists of attaching a ﬁle descriptor to
the child process. janus then selects on this de-
scriptor and waits to be notiﬁed of any interesting
events.
3. The child execs the sandboxed application.
4. All accesses to new resources via open, bind etc. is
ﬁrst screened by Janus to decide whether to allow the
application access to the descriptor for the resource.
5. The program continues to run under Janus’s supervi-
sion until it voluntarily ends its execution or is ex-
plicitly killed by Janus for a policy violation.
If a
sandboxed process forks, its new children will have
new descriptors attached to them, and will be sub-
jected to the security policy of their parents by the
janus process.
To further examine how Janus screens system calls, let
us consider the sequence of events that occurs when a
sandboxed process attempts the call open("foo") as
depicted in Figure 1.
1. A sandboxed process makes
open("foo");
the system call entry point.
system call
this traps into the kernel at
a
2. A hook at the system call entry point redirects con-
trol to mod janus, since open is a sensitive system
call.
3. mod janus notiﬁes janus that a system call has
been requested and puts the calling process to sleep.
4. janus wakes up and requests all relevant details
about the call from mod janus, which it uses to de-
cide whether to allow or deny the call. It then notiﬁes
mod janus of its decision.
5. If the call is allowed, control is returned to the kernel
proper and system call execution is resumed as nor-
mal. If janus decides to deny the call, an error is
returned to the calling process and the system call is
aborted.
This is the basic model of a program running in a Janus
sandbox. Readers may also wish to refer to other sources
[12, 23] on how janus and mod janus work , as well
as referring back to the description of the initial Janus pro-
totype [29].
4 Problems and Pitfalls
This section presents a selection of problems and pit-
falls encountered in the course of building Janus. These
can be broken into the following general categories: in-
correctly replicating OS semantics, overlooking indirect
paths to resources, race conditions, incorrectly subsetting
a complex interface, and side effects of denying system
calls. We introduce each problem with a general descrip-
tion, then present concrete examples from our own work.
4.1 Incorrectly Replicating the OS
In order to make policy decisions, Janus must obtain
and interpret OS state associated with the application it
is monitoring. Achieving this can lead to replicating the
OS in two ways. First, we may try to replicate OS state.
Necessarily, we must keep around some state in order to
track what processes we are monitoring. This state over-
laps with state managed by the OS. In order to interpret
application behavior (e.g. the meaning of a system call)
we must replicate OS functionality. In both cases, repli-
cation introduces the possibility of inconsistency that can
lead to incorrect policy decisions.
4.1.1 Incorrectly Mirroring OS State
Janus often needs OS state in order to make a policy de-
cision. For example, if we observe that a process wants to
call ioctl on a descriptor, we might want to know more
about that descriptor. Is it open read-only, or read-write?
Is it associated with a ﬁle or a socket? Does it have the
O SYNC ﬂag set? One solution to this problem is to infer
current OS state, by observing past application behavior.
This option is certainly attractive in some ways. Inferring
state means we don’t need to modify the OS if this in-
formation is not readily available. It also eliminates the
system call overhead of querying the OS. Unfortunately,
trying to infer even the most trivial information can be
error-prone, as we discovered in the course of building
Janus.
Janus needs to know the protocol type of IP sockets in
order to decided whether or not to let a monitored process