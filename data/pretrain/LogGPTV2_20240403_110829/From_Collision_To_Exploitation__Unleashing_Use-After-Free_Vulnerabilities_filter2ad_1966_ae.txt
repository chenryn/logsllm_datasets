7. DEFENDING AGAINST MEMORY COL-
LISION ATTACK
One notable advantage of the physmap-based attack is
that it ﬁrmly captures the inherent weakness of current ver-
sions of Linux kernel. Considering the direct mapping as a
fundamental feature of the system, it is not easy to build
highly eﬀective mitigation against the physmap-based at-
tack scheme. Two considerable approaches to defending
against the attack model are presented as follows.
7.1 Bound for the Physmap
One eﬀective way to defend against the memory collision
attack through the physmap is to restrict the percentage of
the total memory in use in the physmap for each user on
the system.
For a particular user, all of his active tasks scheduled by
Linux kernel are taken into consideration. And the sum of
the memory in the user space of every task which is directly
mapped by the physmap is recorded in the kernel. When
this value arrives at a threshold value predeﬁned by the
kernel, then any more memory request for the physmap will
be refused by the kernel unless the some of his task releases
a certain amount of memory mapped by the physmap to
make the total occupation of the physmap in the kernel
lower than the threshold value.
Such an upper bound on the occupation of the physmap
for all the active tasks owned by a user is able to defend
against the memory collision attack through the physmap
to a certain extent.
In fact, in order to cover the SLAB
caches storing the target kernel object, a large amount of
memory has to be mmaped in user space by the active tasks
of an attacker and sprayed with the data later used in the
exploitation. However due to the threshold predeﬁned by
the kernel, such things cannot be achieved and it is not
likely for the physmap to reach the relatively high virtual
address where the target SLAB caches are allocated.
The restriction on the occupation of the physmap must
be set for every user instead for every active task. That
is because when attacking the core of the system, all the
active tasks can inﬂuence the kernel memory. If the limita-
tion on the occupation of the physmap is for every active
task, attackers can create many independent processes and
each of them follows the restriction but however the total
amount of the memory mapped by the physmap in these
processes is enough to cover the SLAB caches storing the
target vulnerable objects and the protection is bypassed by
the attacker. Thus, the attention should be put on the
memory usage of all the active tasks owned by every user
logging on the system.
As illustrated above, this protection can prevent attack-
ers from making the memory collision attack through the
physmap. And the eﬀectiveness of this protection depends
on that predeﬁned threshold value. A lower threshold value
providing more safety leads to the result that less directly
mapped memory can be achieved by the user programs,
thus a balance has to be found between the eﬃciency and
the security of Linux kernel.
7.2 Complete Separation
The main cause of the memory collision attack through
the physmap is that the directly mapped memory sourcing
from the user space covers the place where originally the
kernel objects are stored, a valid way to defend against the
memory collision attack is to apply the complete separation
between the physmap area and the SLAB caches.
The kernel speciﬁes the memory of a ﬁxed range to be
the appropriative memory for the physmap. Even if a large
part of the memory for special physmap use is free, it is
impossible for the SLAB caches to be located in that region.
Similarly, the physmap can never expand into the space
once the kernel objects are stored there. A legible border is
speciﬁed by this protection between the physmap area and
the area for allocating objects in the kernel.
This protection against the collision attack is eﬀective
for sure since when it is on, there is no chance that a col-
lision will happens between the physmap and the target
vulnerable objects. However it is hard to be implemented
on 32-bit Linux kernel because the size of the kernel space
is too small to achieve a complete separation between the
physmap and the SLAB caches. But for the 64-bit Linux
kernel, the virtual address space is deﬁnitely enough for the
kernel to achieve this. And without doubt, for safety, there
will be more overhead and waste of the space.
8. RELATED WORK
In recent years, the use-after-free vulnerability become
the most popular and serious vulnerability in the applica-
tions both on the desktop PC and on the mobile devices.
In 2013, there were 129 CVEs for Microsoft Internet Ex-
plorer and most of them were use-after-free vulnerabilities,
and this number raised to 243 in year 2014 [9]. Due to
the various mitigations [34], exploiting other vulnerabilities
like stack overﬂows and heap overﬂows has become harder.
Taking advantage of the use-after-free vulnerability in the
web browsers or in the document viewers, attackers are able
to execute arbitrary code in the context of the applications
and eventually control your computer [3] or mobile phone [2]
remotely.
When exploiting a use-after-free vulnerability, the key
step is to re-occupy the memory of the freed object [29]
which means using some other objects to do the memory
collision with the vulnerable object. Thus, attackers should
carefully and accurately arrange the heap layout of the pro-
cess [28], [32], [12] before triggering the use-after-free vul-
nerability.
In order to defend against the use-after-free vulnerability,
numerous protection and mitigation schemes are proposed
to enforce the temporal safety [29]. Many of these protec-
tions employ special allocators.
It is the basic approach
to protect against use-after-free exploits since it tries to
prohibit the memory collision happens thus no re-use of
the memory happens and the use-after-free vulnerability is
hard to exploit. Such protections include Cling [13] and
DieHarder [23]. In fact, almost all the current popular web
browsers have their own allocators. They are known as
Heap Arena [31] for WebKit in Safari on Mac OSX and iOS,
PartitionAlloc [8] in Google Chrome, Presentation Arena
and Frame Poisoning [21] in Mozilla Firefox and Isolated
Heap [30] in Microsoft Internet Explorer. However, based
on the rapid advancement of the exploit techniques, all of
these allocators are defeated during the Pwn2Own/Pwnium
hacking contests in the recent years due to their existed
weakness. The related exploit techniques targeting the heap
allocators of these web browsers include [15] for Safari,
[5]
for Google Chrome,
[16] for Mozilla Firefox and [20] for
Internet Explorer involving the well-designed heap layout
arrangement, misalignment of the objects on the heap and
utilizing the unique features of these private allocators.
Other protections against use-after-free include the ob-
ject based approaches and the pointer based approaches [29].
The former ones are widely use in practice to detect mem-
ory corruptions include the AddressSanitizer [26] and the
Valgrind Memcheck [11], trying to detect use-after-free by
marking the memory once de-allocated. The latter ones fo-
cus on whether the pointer to be used is valid or not to
detect use-after-free vulnerabilities. Such protections in-
clude [22, 19, 33].
By contrast, relatively fewer use-after-free vulnerabilities
are discovered in OS kernel and only a few related researches
are documented [24] [1]. Considering the requirement for
the eﬃciency of the OS kernel, the protections like marking
memory or checking dangling pointers cause an unaccept-
able overhead and cannot be adopted by the kernel. How-
ever, all the OS kernels have their special allocators.
In
Linux kernel there are SLAB/SLUB allocators which pro-
vide a perfect isolation between the objects of diﬀerent sizes
and diﬀerent types. Thus it is diﬃcult for an attacker to
take advantage of a use-after-free vulnerability in Linux ker-
nel and few exploit techniques attacking against the isola-
tion of the kernel heap are documented.
Additionally, several previous reliable probabilistic tech-
niques of exploiting the user application include [27] and [14].
These techniques also take advantage of the weakness of the
memory management of Linux as well as our collision attack
schemes do.
9. CONCLUSION
curity threat to the core brought by the memory recycling,
in this paper a novel memory collision attack strategy is
constructed and two memory collision attacks, the object-
based attack and the physmap-based attack, are presented
based on it. The attack strategy is widely applied and fea-
tures the stability, complete bypassing the separation pro-
vided by the kernel allocator and the fully control of the
re-ﬁlling data, and is proved to be eﬀective on x86/x64,
AArch32/AArch64 and Android Linux in practice. Partic-
ularly, a case study about rooting popular Android devices
by exploiting CVE-2015-3636 with the physmap-based at-
tack is detailed. Finally, two mitigation schemes are de-
signed to to counter such memory collision attacks against
Linux kernel with acceptable overhead.
10. ACKNOWLEDGEMENTS
We would like to thank our reviewers for valuable com-
ments to improve the manuscript. We would also like to
show our gratitude to Shi Wu, James Fang, Siji Feng, and
Yubin Fu of Keen Team for their inspirations and great con-
tributions to the development and related statistics of the
universal Android root solution mentioned in this paper.
This work was supported in part by the National Key
Technology Research and Development Program of China
under Grants No. 2012BAH46B02, the National Science
and Technology Major Projects of China under Grants No.
2012ZX03002011, and the Technology Project of Shang-
hai Science and Technology Commission under Grants No.
13511504000 and No. 15511103002.
References
[1] Attacking the Core: Kernel Exploiting Notes.
http://phrack.org/issues/64/6.html.
[2] CVE-2010-1807.
https://cve.mitre.org/cgi-bin/cvename.cgi?name=
CVE-2010-1807.
[3] CVE-2014-1776. http://www.cve.mitre.org/cgi-
bin/cvename.cgi?name=CVE-2014-1776.
[4] CVE-2015-3636.
http://cve.mitre.org/cgi-bin/cvename.cgi?name=
CVE-2015-3636.
[5] Exploiting 64-bit Linux like a boss.
http://scarybeastsecurity.blogspot.com/2013/02/
exploiting-64-bit-linux-like-boss.html.
[6] Exploiting NVMAP to escape the Chrome
sandbox-CVE-2014-5332.
http://googleprojectzero.blogspot.com/2015/01/
exploiting-nvmap-to-escape-chrome.html.
[7] GCC stack protector support.
http://lxr.free-electrons.com/source/arch/x86/
include/asm/stackprotector.h.
[8] Google Chromium source.
https://chromium.googlesource.com/chromium/
blink/+/master/Source/wtf/PartitionAlloc.h.
[9] Microsoft Internet Explorer: CVE security
vulnerabilities, versions and detailed reports.
To reveal the universal exploiting solution for the use-
after-free vulnerabilities in Linux kernel and show the se-
[10] Short users guide for SLUB. https:
//www.kernel.org/doc/Documentation/vm/slub.txt.
[11] Understanding Valgrind memory leak reports.
[23] G. Novark and E. D. Berger. DieHarder: Securing the
http://es.gnu.org/~aleksander/valgrind/
valgrind-memcheck.pdf.
Heap. In Proc. 17th ACM conference on Computer
and communications security, 2010.
[12] J. Afek and A. Sharabani. Dangling Pointer:
[24] W. Robert. Exploiting Concurrency Vulnerabilities in
Smashing the Pointer for Fun and Proﬁt. Black Hat
USA, 2007.
System Call Wrappers. In Proc. 1st USENIX
Workshop on Oﬀensive Technologies, 2007.
[13] P. Akritidis. Cling: A Memory Allocator to Mitigate
[25] A. Rubini and J. Corbet. Linux device drivers.
Dangling Pointers. In Proc. 19th USENIX Security
Symposium, 2010.
[14] A. Bittau, A. Belay, A. Mashtizadeh, D. Mazieres,
and D. Boneh. Hacking blind. In Proc. 35th IEEE
Symposium on Security and Privacy, 2014.
O’Reilly Media, Inc., 2001.
[26] K. Serebryany, D. Bruening, A. Potapenko, and
D. Vyukov. AddressSanitizer: A Fast Address Sanity
Checker. In Proc. 2012 USENIX Annual Technical
Conference, 2012.
[15] L. Chen. WebKit Everywhere: Secure Or Not? Black
[27] H. Shacham, M. Page, B. Pfaﬀ, E.-J. Goh,
Hat Europe, 2014.
[16] P. A. C. Karamitas. Exploiting the jemalloc Memory
Allocator: Owning Firefox’s Heap. Black Hat USA,
2012.
[17] V. P. Kemerlis, M. Polychronakis, and A. D.
Keromytis. ret2dir: Rethinking Kernel Isolation. In
Proc. 23rd USENIX Security Symposium, 2014.
[18] C. Lameter. Slab allocators in the Linux Kernel:
SLAB, SLOB, SLUB. LinuxCon, 2014.
[19] B. Lee, C. Song, Y. Jang, T. Wang, T. Kim, L. Lu,
and W. Lee. Preventing Use-after-free with Dangling
Pointers Nulliﬁcation. In Proc. 2015 Annual Network
and Distributed System Security Symposium, 2015.
N. Modadugu, and D. Boneh. On the eﬀectiveness of
address-space randomization. In Proc. 11th ACM
conference on Computer and communications
security, 2004.
[28] A. Sotirov. Heap feng shui in Javascript. Black Hat
Europe, 2007.
[29] L. Szekeres, M. Payer, T. Wei, and D. Song. Sok:
Eternal War in Memory. In Proc. 34th IEEE
Symposium on Security and Privacy, 2013.
[30] TrendLabs. Isolated Heap for Internet Explorer Helps
Mitigate UAF Exploits.
http://blog.trendmicro.com/trendlabs-security-
intelligence/isolated-heap-for-internet-
explorer-helps-mitigate-uaf-exploits/.
[20] J. Lu. New Exploit Mitigation In Internet Explorer.
HITCON, 2014.
[31] G. Wicherski. Exploiting A Coalmine. Hackito Ergo
Sum, 2012.
[21] MWR Lab. Isolated Heap & Friends - Object
Allocation Hardening in Web Browsers.
https://labs.mwrinfosecurity.com/blog/2014/06/
20/isolated-heap-friends---object-allocation-
hardening-in-web-browsers/.
[22] S. Nagarakatte, J. Zhao, M. M. Martin, and
S. Zdancewic. CETS: Compiler Enforced Temporal
Safety for C. ACM Sigplan Notices, 2010.
[32] T. Yan. The Art of Leaks: The Return of Heap Feng
Shui. CanSecWest, 2014.
[33] Y. Younan. FreeSentry: Protecting Against
Use-After-Free Vulnerabilities Due to Dangling
Pointers. 2015.
[34] Y. Younan, W. Joosen, and F. Piessens. Runtime
Countermeasures for Code Injection Attacks against
C and C++ programs. ACM Computing Surveys,
2012.