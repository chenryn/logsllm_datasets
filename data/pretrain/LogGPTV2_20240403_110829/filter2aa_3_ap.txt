info
set Identity “Domain Admins”
set Recurse True
set FullData True
execute
现在，我们有一个用户、组、服务器和服务的收集列表。这将帮助我们了解哪些用户拥有哪些特权。但是，我们仍然需要有关工作站和系统的详细信息。这可能包括版本、创建日期、用途、主机名等。我们可以用一个叫做 get_computer 的模块来获得这些信息。
Module: situational_awareness/network/powerview/get_computer
描述：get_computer 模块可以查询域中当前的计算机对象。
get_computer 查询域控制器可以获得什么信息呢？好吧，我们看到我们可以获得关于机器的信息，比如当它被创建时的 DNS 主机名，自定义名称等等。作为攻击者，最有用的侦察细节之一是获取操作系统类型和操作系统版本。在这种情况下，我们可以看到这个系统是 Windows 10 Build 16299版本。我们可以通过获取这些信息，了解操作系统的最新版本以及它们是否在 Microsoft 的发布信息页上存在修补的补丁：https://technet.microsoft.com/en-us/windows/release-info.aspx 。
Bloodhound/Sharphound
我们如何利用在侦察阶段收集的所有信息来创建一条攻击线路呢？我们如何能够轻松、快速地得知谁有权限去调用那些功能？回想一下，我们总是试图直接攻击，让一切都达到我们想要的目的，但这总是会增加被抓住的可能性。
Andrew Robbins，Rohan Vazarkar 和 Will Schroeder 已经创造了一种最好的工具，那就是 Bloodhound/Sharphound。在他们的 Github 页面上显示。“Bloodhound/Sharphound 使用图表理论来揭示 Active Directory 环境中隐藏的、出乎意料的关系。攻击者红队可以使用 Bloodhound 轻松识别高度复杂的攻击路径，否则的话将无法快速识别。防御者蓝队可以使用 Sharphound 来识别和消除对应的的攻击路径。”[https://github.com/BloodHoundAD/BloodHound] 。
Bloodhound/Sharphound 的工作原理是在受害者系统上运行一个 Ingestor，然后为用户、组和主机查询 AD（类似于我们以前手工做的）。然后，Ingestor 将尝试连接到每个系统以枚举登录的用户、会话和权限。当然，这个动静会很大。对于采用默认设置（可以修改）的中型企业网站，连接到每个主机系统和使用 Sharphound 查询信息的时间可能不到10分钟。注意，因为这会接触到网络上每个加入域的系统，所以它可能会让你被发现。Bloodhound/Sharphound 中有一个秘密选项，它只查询 Active Directory，不连接到每个主机系统，但是输出结果非常有限。
目前有两种不同的版本（我相信旧版本很快就会被移除）：
在 Empire，你可以使用模块：
usemodule situational_awareness/network/bloodhound
这仍然是查询非常慢的旧的 PowerShell 版本
最好的选择是 Sharphound，Sharphound 是最原始的 C# 版本 Bloodhound Ingester。这是个更快更稳定的版本。可以用作独立二进制文件，也可以作为 PowerShell 脚本导入。Sharphound PowerShell 脚本将使用反射和 assembly.load 加载已编译 BloodHound C# 版本的 ingestor 并将其捕获。
https://github.com/BloodHoundAD/BloodHound/tree/master/Ingestors
要运行 Bloodhound/Sharphound Ingestor，你可能需要指定多个集合方法：
Group - Collect group membership information
收集组成员身份信息
LocalGroup - Collect local admin information for computers
收集计算机的本地管理信息
Session - Collect session information for computers
收集计算机的会话信息
SessionLoop - Continuously collect session information until killed
持续收集会话信息直到结束
Trusts - Enumerate domain trust data
列举域内信任数据
ACL - Collect ACL (Access Control List) data
收集ACL（访问控制列表）数据
ComputerOnly - Collects Local Admin and Session data
收集本地管理和会话数据
GPOLocalGroup - Collects Local Admin information using GPO (Group Policy Objects)
使用GPO（组策略对象）收集本地管理信息
LoggedOn - Collects session information using privileged methods (needs admin!)
使用特权方法收集会话信息（需要管理员权限！）
ObjectProps - Collects node property information for users and computers
为用户和计算机收集节点属性信息
Default - Collects Group Membership， Local Admin， Sessions， and Domain Trusts
收集组成员、本地管理员、会话和域信任关系
在目标系统上运行 Blood/Sharphound:
运行 PowerShell，然后导入 Bloodhound.ps1 或者 SharpHound.ps1：
Invoke-Bloodhound -CollectionMethod Default
Invoke-Bloodhound -CollectionMethod ACL，ObjectProps，Default-CompressData -RemoveCSV -NoSaveCache
运行可执行文件:
SharpHound.exe -c Default，ACL，Session，LoggedOn，Trusts，Group
一旦完成了 Bloundhound/Sharphound，这四个文件将被保存到受害者机器上。下载并处理这些文件，并将它们复制到你的 kali 上。接下来，我们需要启动 Neo4j 服务器并导入这些数据来构建相关关系图。
打开 Bloodhound
apt-get install bloodhound
neo4j console
打开浏览器访问  http://localhost:7474
连接到 bolt://localhost:7687
用户名: neo4j
密码: neo4j
修改密码
在一个终端中运行 Bloodhound：
bloodhound
数据库 URL: bolt://127.0.0.1:7687
用户名: neo4j
密码：新的密码
加载数据
在右侧，有一个 Upload Data 的按钮
上传 acls.csv，group_membership.csv， local_admin.csv 和 sessions.csv
如果你没有一个域来测试这个，我已经在这里上传了四个 Bloodhound 文件：https://github.com/cyberspacekittens/bloodhound ，这样你就可以重复这些练习了。一旦进入 Bloodhound 并导入了所有数据，我们就可以去查询“查找到域管理员的最短路径”。我们还可以选择特定的用户，看看是否可以将路径映射到特定的用户或组。在我们的示例中，我们攻陷的第一个用户机器是 PI:EMAIL。在搜索栏中，我们输入该用户的用户名，单击 Pathfinding 按钮，然后键入“Domain Admin”（或任何其他用户），查看是否可以在这些对象之间显示对应的路由路径。
你可以从 Neil 的机器上看到，我们可以一路顺利的到 CSK 实验组。在“实验”组中，有一个名为 Purri 的用户，他是 HelpDesk 组的成员。
如果我们能攻陷 HelpDesk 组，我们可以转到 Chris 的主机中，而且 Elon Muskkat 目前已登录此机器。如果我们能转移到他的进程或窃取他的明文密码，我们就可以把权限提升到域管理员！
对于大型网络的扫描结果，我们注意到了 Bloodhound 查询的搜索功能有一些局限性。使用 Neo4j 的一个巨大好处是，它允许通过自己本身的叫 Cypher 的语言进行原始查询。有关自定义查询的 Cypher 的深入研究，请访问：https://blog.cptjesus.com/posts/introtocypher 。
我们可以添加哪种自定义查询？来看吧，@porterhau5在扩展 Bloodhound 跟踪和可视化攻击方面取得了很大进展。查看他们的文章：https://porterhau5.com/blog/extending-bloodhound-track-and-visualize-your-compromise/ 。
从高层次的角度来看，@porterhau5增加了标记被攻陷主机的想法，以帮助更好地在内网漫游。例如，在这个伪造的场景中，我们通过仿冒用户 niel.pawstrong 来危害其他初始用户。使用 Bloodhound 上的 Cypher 语言和原始查询功能，我们可以运行这些查询：
向被攻陷系统添加自有标签：
MATCH (n) WHERE n.name=“PI:EMAIL” SET n.owned=“phish”， n.wave=1
运行查询以显示所有被仿冒的系统
MATCH (n) WHERE n.owned=“phish” RETURN n
现在，我们可以向 Bloodhound 添加一些自定义查询。在Bloodhound 的“查询”选项卡上，滚动到底部，单击“自定义查询”旁边的“编辑”按钮。用以下内容替换所有文本：
https://github.com/porterhau5/BloodHound-Owned/blob/master/customqueries.json
保存之后，我们应该创建更多的查询。现在我们可以单击查找结果“查找从所属节点到域管理员的最短路径”。
如果你想更仔细地研究这个问题，请查看 @porterhau5的 fork 版 Bloodhound。它用标记使被攻陷机器更直观，并允许更多的自定义功能：https://github.com/porterhau5/bloodhound-owned 。
到目前为止，在没有扫描的情况下，我们已经能够获得关于该组织的大量信息。这都是作为本地 AD 用户（域用户）的权限能做到的的，而且在大多数情况下，没有任何网络流量看起来太可疑。正如你所看到的，我们能够做到这一切，而无需成为本地管理员或对本地系统拥有任何管理权限。
Advanced ACL/ACE Bloodhound
当使用 Bloodhound 的收集方法访问控制列表（ACL）类型时，我们的脚本将查询 AD 以收集用户和对象的所有访问控制权限。我们从访问控制项（ACEs)收集的信息描述了用户、组和计算机的允许和拒绝权限。寻找和利用 ACEs 本身就是一个能写成完整的书的内容，但这里有一些很好的启动资源：
BloodHound  1.3–acl 攻击路径更新
https://wald0.com/?p=112
介绍对抗性恢复方法
http://bit.ly/2GYU7S7
在将 ACL 数据导入 Bloodhound 时，我们要寻找什么信息？Bloodhound 识别出 ACE 中可能存在弱点的地方。这将包括谁有能力更改或重置密码、向组中添加成员、为其他用户更新脚本路径等对象、更新对象或在对象上写入新的 ACE 等等。
怎么使用这个东西呢？当攻陷到某个用户和获得额外的凭证后，我们可以通过目标路径找到一个有能力重置密码或修改 ACE 权限的用户。这将导致会有新的方法来找到到域管理员或特权帐户的路径，甚至允许设置后门以供以后使用。了解这些类型的利用方法的一个很好的资源是：Robbins-An-ACE-Up-The-Sleeve-DesigningActive-Directory-DACL-Backdoors 演讲 。
横向漫游——移动
在一个拥有多个用户的机器上，通常的做法是创建一个新的用户凭证或者迁移不同用户的凭证。这种方法大量用于在环境中横向移动，这并不是什么新鲜问题。通常，从 Bloodhound 输出或共享工作站，作为攻击者，我们需要能够模仿被攻陷的受害者系统上的其他用户。
我们拥有的许多工具可以用不同的方法来实现这一点。比如 Metasploit，我们都应该非常熟悉使用 Post Exploitation 隐蔽框架来窃取 token。
在 Empire 中，我们可以使用窃取 token 来模拟该系统上的用户。我注意到，有时候窃取 token 会让我们的 shell 下线。为了避免这种情况，我们可以将一个新的 agent 注入到另一个用户拥有的正在运行的进程中。
在下面的图片中，我们使用钓鱼让一个员工运行了我们的恶意软件。。这使得我们可以在受害者用户的系统中运行我们自己的程序（neil.pawstrong）。在那个用户的系统上，我们可以转到 BuzzClawdrin 的系统，并用WMI（WindowsManagementInstrumentation）命令执行获得了一个新的 agent。这里的问题是，我们在最初攻击受害者 Neil.Pawstrong 的过程中，因为我们使用缓存的凭证在 Buzz 的主机上生成了一个 shell。因此，我们不应该窃取 token，而应该使用 Empire 的  psinject 功能。
psinject 描述“能够使用 ReflectivePick 将代理注入另一个进程，从而将通用.NET运行库时加载到进程中并执行特定的 PowerShell 命令，而无需启动新的 PowerShell.exe 进程！”[ http://bit.ly/2HDxj6x ]，我们使用它来生成一个全新的、以 buzz.clauldrin 的用户进程运行的 agent，这样我们现在就可以获得他的访问权限。