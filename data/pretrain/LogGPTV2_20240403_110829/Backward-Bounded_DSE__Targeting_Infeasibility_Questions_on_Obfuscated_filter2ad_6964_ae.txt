0
0
0
0
0
0
RTok (a/d/g)
0 (0/0/0)
11 (7/0/7)
125 (94/0/94)
14 (10/0/10)
21 (14/0/14)
4 (3/0/3)
14 (8/0/8)
3 (3/0/3)
7 (5/0/5)
4 (2/0/2)
RTko (a/d/s)
48 (45/1/45)
6 (1/4/1)
78 (0/30/32)
0 (0/0/0)
1 (0/0/0)
3 (0/1/0)
0 (0/0/0)
1 (0/1/0)
1 (0/0/0)
0 (0/0/0)
. opaque pred.: bound k = 16 – OP: proved opaque – Unk: query returns unknown – TO: timeout (5 sec.)
. stack tampering: RTok: #ret runtime genuine - RTko: #ret runtime tampered - a/d/g/s: proved aligned/disaligned/genuine/single target
. dynamic information: tr.ok: whether the executed trace was successfully gathered without exception/detection - host: whether the payload was
successfully executed - #proc: #process spawned - #th: #threads spawned - #layers: #self-modiﬁcation layers
not connected to internet but reachable from an internal network.
These two malwares are being used as part of target attack
campaigns (APT) from the APT28 group also known as Sednit,
Fancy Bear, Sofacy or Pawn Storm. This group, active since
2006, targets geopolitical entities and is supposedly highly
tight to Russian foreign intelligence. Among alleged attacks,
noteworthy targets are NATO [36], EU institutions [37], the
White House [38], the German parliaments [39] and more
recently the American Democrate National Comittee DNC [40]
that affected the running of elections. This group also makes
use of many 0-days [41] in Windows, Flash, Ofﬁce, Java and
also operate other malwares like rootkits, bootkits, droppers,
Mac 0SX malwares [42] as part of its ecosystem.
Goal. This use-case is based on 3 X-TUNNEL samples5
covering a 5 month period (according to timestamps). While
Sample #0 is not obfuscated and can be straightforwardly
analyzed, Samples #1 and #2 are, and they are also much
larger than Sample #0 (cf. Table VIII). The main issue here is:
G1: Are there new functionalities in the obfuscated samples?
Answering this question requires ﬁrst to be able to analyse
the obfuscated binaries. Hence we focus here on a second goal:
G2: Recover a de-obfuscated version of Samples #1 and #2.
We show in the latter how BB-DSE can solve goal G2, and
we give hints on what is to be done to solve G1.
Analysis context. Obfuscated samples appeared to contain a
tremendous amount of opaque predicates. As a consequence,
our goal is to detect and remove all opaque predicates in
order to remove the dead-code and meaningless instructions
to hopefully obtain a de-obfuscated CFG. This deobfuscation
step is a prerequisite for later new functionality ﬁnding. The
analysis here has to be performed statically:
5We warmly thank Joan Calvet for providing the samples.
643
TABLE VIII: Samples infos
Sample #0
42DEE3[...]
No
1.1 Mo
25/06/2015
3039
231907
Sample #1
C637E0[...]
Yes
2.1 Mo
02/07/2015
3775
505008
Sample #2
99B454[...]
Yes
1.8 Mo
02/11/2015
3488
434143
obfuscated
size
creation date
#functions
#instructions
• as the malware is a network component, it requires to
connect to the CC server, which is truly not desirable;
• moreover, many branching conditions are network-event
based, thus unreliable and more hardly reproducible.
Fortunately, a quick inspection (dynamic run skipping server
connexion) conﬁrms that X-TUNNEL does not seem to use any
self-modiﬁcation or neatly tricks to hamper static disassembly.
Thus, we proceed as follows: we take the CFG recovered by
IDA, and from that we compute the prek of each conditional
branch (IDASEC). This is a realistic reverse scenario when
dynamic recovery is not desirable, IDA being the de facto static
disassembly standard. Correctness of the analysis depends
on the quality of the CFG recovered by IDA, so we cannot
have absolute guarantees. Our goal here is to improve over
state-of-the-practice on a realistic scenario.
B. Analysis
OP detection. The analysis performs a BB-DSE on every
conditional jumps of the program, testing systematically both
branches. Taking advantage of previous experiments, we set
the bound k to 16. The solver used is Z3 with a 6s timeout.
If both branches are UNSAT, the predicate is considered dead,
as the unsatisﬁability is necessarily due to path constraints
indicating that the predicate is not reachable.
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:18:31 UTC from IEEE Xplore.  Restrictions apply. 
Code simpliﬁcation. We perform three additional computa-
tions in complement to the opaque predicate detection:
• predicate synthesis recovers the high-level predicate of an
opaque predicate by backtracking on its logical operations.
The goal of this analysis is twofold: (1) indexing the
different kind of predicates used and (2) identifying
instruction involved in the computation of an OP denoted
spurious instructions (in order to remove them);
• liveness propagation based on obfuscation-related data
aims at marking instruction by theirs status, namely alive,
dead, spurious;
• reduced CFG extraction extracts the de-obfuscated CFG
based on the liveness analysis.
TABLE XI: Opaque predicates evaluation
#pred
Sample #1
34505
Sample #2
30147
Genuine
(syntactic)
FN
1046
(3.0%)
914
(3.0%)
Genuine
17197
(49.8%)
16148
(53.7%)
OP
Unknown
(syntactic)
FP
2968
(8.6%)
2543
(8.4%)
OP
11973
(34.7%)
9790
(32.5%)
1321
(3.8%)
652
(2.5%)
C. Results
Execution time. Table IX reports the execution time of the the
BB-DSE and predicate synthesis. The predicate synthesis takes
a non-negligible amount of time, yet it is still very affordable,
and moreover our implementation is far from optimal.
TABLE IX: Execution time
Sample #1
Sample #2
#preds
34505
30147
DSE
57m36
50m59
Synthesis
48m33
40m54
Total
1h46m
1h31m
2
OP diversity. Each sample presents a very low diversity
of opaque predicates. Indeed, solely 7x2 − 1 (cid:2)= x2 and
x2+1 (cid:2)= y2 + 3 were found. Table X sums up the distribution
of the different predicates. The amount of predicates and
their distribution supports the idea that they were inserted
automatically and picked randomly.
TABLE X: Opaque predicates variety
7y2 − 1 (cid:3)= x2
Sample #1
Sample #2
6016 (49.02%)
4618 (45.37%)
2
(cid:3)= y2 + 3
x2+1
6257 (50.98%)
5560 (54.62%)
Detection results. As the diversity of opaque predicates is very
low, we are able to determine, with quite a good precision,
the amount of false negatives and false positives based on the
predicate synthesized. If a predicates matches one (resp. do
not match any) of the two identiﬁed opaque predicates and is
classiﬁed as genuine (resp. opaque), then we considered it a
false negative (respectively false positive). Results are given
in Table XI and Figure 11. The detection rate is satisfactory,
with 3% of false negative and 8.4 to 8.6% of false positive. A
few conditions are classiﬁed as unknown, since both branches
are proved infeasible due to some unhandled syscalls.
Dependency evaluation. While the average distance between
an opaque predicate and its variable deﬁnitions is here 8.7
(less than the bound k = 16), the maximum distances are 230
644
(a) OP results Sample #1
(b) OP results Sample #2
(cid:4) FN (cid:4) OK (cid:4) Opaque (cid:4) FP
Fig. 11: Graph of opacity distribution
(Sample #1) and 148 (Sample #2). Fortunately, we dot not
need all this information to prove infeasibility.
Difference with O-LLVM. Interesting differences with OP
found in O-LLVM are to be emphasized. First, there is more
interleaving between the payload and the OPs computation.
Some meaningful instructions are often encountered within the
predicate computation. Second, while O-LLVM OPs are really
local to the basic block, there are here some code sharing
between predicates, and predicates are not fully independent
from one another. Also, the obfuscator uses local function
variables to store temporary results at the beginning of the
function for later usage in opaque predicates. This increases the
depth of the dependency chain and complicates the detection.
Code simpliﬁcation, Reduced CFG extraction. Table XII
shows the number of instructions re-classiﬁed based on
their status. The dead code represents 1/4 of all program
instructions. Computing the difference with the original non-
obfuscated program shows a very low difference. Therefore,
the simpliﬁcation pass allowed to retrieve a program which is
roughly the size of the original one. The difference is highly
likely to be due to the false negatives or missed spurious
instructions. Finally, Figure 12 shows a function originally
(a), with the status tags (b), and the result after extraction (c)
using tags (red:dead, orange:spurious, green:alive). Although
the CFG extracted still containing noise, it allows a far better
understanding of the function behavior. A demo video showing
the deobfuscation of a X-TUNNEL function with BINSEC and
IDASEC is available as material for this paper6.
D. Conclusion
About the case-study. We have been able to automatically
detect opaque predicates in the two obfuscated samples
6https://youtu.be/Z14ab_rzjfA
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:18:31 UTC from IEEE Xplore.  Restrictions apply. 
(a) Original function CFG
(b) CFG tagged
(c) CFG extracted
Fig. 12: Examples of CFG extraction
TABLE XII: Code simpliﬁcation results
#instr
Sample #1
507,206
Sample #2
436,598
#alive
#spurious
279,483
103,731
(55%)
(20%)
241,177
79,202
(55%)
(18%)
† Sample #0: 231,907 instrs
#dead
121,794
(24%)
113.764
(26%)
diff sample #0†
47,576
9,270
of the X-TUNNEL malware, leading to a signiﬁcant (and
automatic) simpliﬁcation of these codes – removing all spurious
and dead instructions. Moreover, we have gained insights
(both strengths and weaknesses) into the inner working of
X-TUNNEL protections. Hence, we consider that goal G2 has
been largely achieved. In order to answer to the initial question
(G1), some similarity algorithms should be computed between
the non-obfuscated and simpliﬁed samples. This second step
is left as future work.
About X-TUNNEL protections. The obfuscations found here
are quite sophisticated compared with existing opaque predi-
cates found in the state-of-the-art. They successfully manage
to spread the data dependency across a function so that some
predicates cannot be solved locally at the basic block level.
Thankfully, this is not a general practice across predicates so
that BB-DSE works very well in the general case. The main
issue of the obfuscation scheme is the low diversity of opaque
predicates, allowing for example pattern matching techniques
to come in relay of symbolic approaches.
IX. APPLICATION: SPARSE DISASSEMBLY
A. Principles
As already explained, static and dynamic disassembly
methods tend to have complementary strengths and weak-
nesses, and BB-DSE is the only robust approach targeting
infeasibility questions. Hence, we propose sparse disassembly,
an algorithm based on recursive disasssembly reinforced
with a dynamic trace and complementary information about
obfuscation (computed by BB-DSE) in order to provide a
more precise disassembly of obfuscated codes. The basic
idea is to enlarge and initial dynamic disassembly by a
cheap syntactic disassembly in a guaranteed way, following
information from BB-DSE, hence getting the best of dynamic
and static approaches.
The approach takes advantage of the two analyses presented
in Sections VI-B and VI-C as follows (cf. Figure 13):
• use dynamic values found in the trace to keep disassem-
bling after indirect jump instructions;
• use opaque predicates found by BB-DSE to avoid dis-
assembling dead branches (thus limiting the number of
recovered non legit instructions);
• use stack tampering information found by BB-DSE to
disassemble the return site of the call only in the genuine
case, and the real ret targets in case of violation.
(cid:71)(cid:92)(cid:81)(cid:68)(cid:80)(cid:76)(cid:70)
(cid:3)
(cid:71)(cid:76)(cid:86)(cid:68)(cid:86)(cid:86)(cid:72)(cid:80)(cid:69)(cid:79)(cid:92)
(cid:72)(cid:91)(cid:72)(cid:70)(cid:88)(cid:87)(cid:76)(cid:82)(cid:81)(cid:3)
(cid:87)(cid:85)(cid:68)(cid:70)(cid:72)
(cid:81)(cid:72)(cid:90)(cid:3)(cid:76)(cid:81)(cid:83)(cid:88)(cid:87)
(cid:3)
(cid:71)(cid:92)(cid:81)(cid:68)(cid:80)(cid:76)(cid:70)
(cid:86)(cid:92)(cid:80)(cid:69)(cid:82)(cid:79)(cid:76)(cid:70)
(cid:72)(cid:91)(cid:72)(cid:70)(cid:88)(cid:87)(cid:76)(cid:82)(cid:81)
(cid:51)(cid:68)(cid:85)(cid:87)(cid:76)(cid:68)(cid:79)(cid:3)(cid:86)(cid:68)(cid:73)(cid:72)
(cid:38)(cid:41)(cid:42)
(cid:3)(cid:86)(cid:87)(cid:68)(cid:87)(cid:76)(cid:70)
(cid:71)(cid:76)(cid:86)(cid:68)(cid:86)(cid:86)(cid:72)(cid:80)(cid:69)(cid:79)(cid:92)
(cid:50)(cid:69)(cid:73)(cid:88)(cid:86)(cid:70)(cid:68)(cid:87)(cid:76)(cid:82)(cid:81)
(cid:76)(cid:81)(cid:73)(cid:82)(cid:85)(cid:80)(cid:68)(cid:87)(cid:76)(cid:82)(cid:81)
Fig. 13: Sparse disassembly combination
Implementation. A preliminary version of this algorithm has
645
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:18:31 UTC from IEEE Xplore.  Restrictions apply. 
been integrated in BINSEC, taking advantage of the existing
recursive disassembly algorithm. The BB-DSE procedure sends
OP and ret information to the modiﬁed recursive disassembler,
which takes the information into account.
B. Preliminary Evaluation
We report two sets of experiments, designed to assess the
precision of the approach and its ability to enlarge an initial
dynamic trace. We compare our method mainly to the well-
known disassembly tools IDA and Objdump. IDA relies on
a combination of recursive disassembly, linear sweep and
dedicated heuristics. Objdump performs only liner sweep.
Precision. In the ﬁrst evaluation, we compare these different
tools on simple programs obfuscated either by O-LLVM
(opaque predicates) or Tigress (stack tampering). In each
experiment, we compare the set of disassembled instructions
with the set of legitimate instructions of the obfuscated program
(i.e., those instructions which can be part of a real execution).
It turns out on these small examples that all methods are able
to ﬁnd all the legitimate instructions, yet they may be lured
into dead instructions introduced by obfuscation.
Tables XIII and XIV present our results. We report for each
program and each disassembly method the number of recovered
instructions. It turns out that this information is representative
of the quality of the disassembly (the less instruction, the
better), given the considered obfuscations and the fact that