10. function _searchSource(graph,node,search_result)//子算法:在 graph 中搜索影响节点 node 的节点,并把结果存在 search_result 中 11.   links=getLinks(graph,node) 
	//获取 graph 中所有节点中包含 node 的边的集合 links 
12. iflinks.length<1: 
13. return; 
	//node 的邻接节点中没有继续需要追溯的节点,停止继续链路搜索 14.   sub_graph=graph.remove(links); 
//构建一张新的子图,在递归中使用子图进行根因搜索,以保证从两个方向都能追溯的边不会因为在
之前的递归中已经遍历而不会被再次搜索.
15.   links=links.sort(links.weight)  //根据边的权重排序,权重较高的边将优先输出 16. forlink in links:17. other_node←link 中除 node 外的另一个端点; 
18. varchild_result  //将 link 的另一个端点当作下一个需要追溯的节点 
19. child_reuslt.node←other_node 
20. child_result.children←[⋅] 
21. search_result.children.push(child_result); 
22. _searchSource(sub_graph,sub_node,search_result.children[sub_node]); 
	//以递归的方式继续追溯链路 
23. function _build_path_strings(node_children,cur_string) 
	//子算法:在缓存路径 cur_string 后根据 children 继续构建链路 24. ifnode_children.length<1:25. return;  //已没有后续节点,停止构建链路
1242 	Journal of Software软件学报 Vol.32, No.5, May 2021 
26. path_strings.remove(cur_string)  //在最终输出链路中删除缓存链路 
27. forchild in node_children: 
28. new_string=child.name+“→”+cur_string 
	//构建新的缓存链路,由于节点到节点的追溯过程具有方向性,算法在链路分析结果中把无向边当作 	有向边输出 
29. path_strings.push(new_string);  //在最终输出中添加缓存链路 
30.   _build_path_string(child.children,new_string); 
	//递归调用链路生成方法以输出所有可能的链路//递归调用链路生成方法以输出所有可能的链路
4  案例研究以及结果分析
为了验证本文提出的微服务韧性风险识别和分析方法的有效性,本文选取了由文献[77]所提出的微服务基 线测试套件 Sock-Shop(https://microservices-demo.github.io/)作为实验对象,对本文提出的方法进行案例验证.案 例研究中将验证以下研究问题. 
(1) 	本文提出的韧性风险识别方法是否能够自动地识别出目标系统的韧性风险? 
(2) 	本文提出的韧性风险分析方法是否能够有效地分析出目标系统在发生韧性风险时因果的影响链路? 
4.1  目标系统以及实验环境4.1  目标系统以及实验环境
图 9 为 Sock-Shop 的系统架构图.整个 Sock-Shop 系统由前端(front-end)、订单服务(order)、支付服务 (payment)、用户服务(user)、商品详情服务(catalogue)、购物车服务(cart)以及邮寄服务(shipping)这几个微服务 组成,每一个微服务均可以独立运行且拥有独立的数据库.为了保证微服务技术异构性[10]的特点,Sock-Shop 中 不同微服务的实现语言以及使用的数据库各不相同.Sock-Shop 中,微服务之间的通信以 HTTP 通信为主,并使 用了 RESTful 的接口设计风格. 
Fig.9  Sock-Shop architecture 
图 9  Sock-Shop 系统架构图 10 为案例研究中 Sock-Shop 的部署环境图,整个部署环境将由一个控制服务器和由一个 Master 节点以 及 3 个 Worker 节点所构建的容器集群管理平台 Kubernetes(https://kubernetes.io/)组成.Sock-Shop 系统被部署在 Kubernetes 集群上,Sock-Shop 中的每一个微服务均在一个或多个容器上部署.控制服务器负责韧性风险识别方 法的自动化实现.其中,Sock-Shop 系统的自动部署和混沌实验的进行由部署在控制服务器上的 Jenkins(https:// jenkins.io/)容器完成,压力测试框架 Locust(https://www.locust.io/)负责 Sock-Shop 应用压力场景的模拟,混沌测 试工具 Chaos-Toolkit(https://chaostoolkit.org/)负责系统环境扰动的实现.部署环境的各个服务器配置相同,具体殷康璘 等:基于混沌工程的微服务韧性风险识别和分析 	1243 
配置见表 1.部署环境中的容器均按默认配置部署,并未对各容器的资源分配情况进行额外设置,因此,Worker 节 点上运行的各容器资源分配模式均采用容器默认的按需分配方式. 
Fig.10  Sock-Shop system deployment environment 
图 10  Sock-Shop 的部署环境
Table 1  Server configuration of the deployment environment 表 1部署环境的服务器配置
| 配置 | 参数 |
|---|---|
| 操作系统  CPU  内存  磁盘  网卡 |Ubuntu Server 16.04  Intel Xeon E5-2620*2  64GB ddr4  3TB  1 000Mb/s  |上述目标系统和实验环境满足了本文第 2.1 节中所提出的各项系统前提:自动化部署组件 Jenkins 与 Sock- Shop 本身提供的 Kubernetes 部署配置文件满足了条件(1)的系统自动化构建能力;Sock-Shop 系统已处于可发布 运行的状态因此满足条件(2);Kubernetes 本身集成的时序数据收集工具 Prometheus 使目标系统满足了条件(3). 案例研究将首先按照条件(4)、条件(5)提出的假设下对目标系统进行韧性风险识别. 
4.2  Sock-Shop的韧性风险识别
	为了验证研究问题 1,本案例研究中将根据本文第 2 节所提出的韧性风险识别方法寻找 Sock-Shop 系统中 的韧性风险. 
4.2.1  韧性风险识别4.2.1  韧性风险识别 
	在 Sock-Shop 中,所有的用户操作均为网页端的点击操作,因此,Sock-Shop 的系统服务均为事务性的 HTTP 服务.在本案例研究中,服务平均响应时间(response time)以及响应成功率(success rate)被作为所有服务的基础 性能指标.Sock-Shop 的核心服务的服务性能指标将根据服务的业务关注点设立.表 2 展示了在案例研究中针对 Sock-Shop 系统各服务所设计的服务性能指标. 
Table 2  Service performance indicators of Sock-Shop 
表 2  Sock-Shop 的服务性能指标
| 服务 | 服务性能指标名称 | 描述 |