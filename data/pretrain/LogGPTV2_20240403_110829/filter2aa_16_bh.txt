int i, *pi, *const cpi = &i;
const int ci = 3, *pci;
声明了一个整型 i 和一个指向整型的指针 pi。不能修改常量指针 cpi 的值，该指针总是 指向同一位置，但它所指之处的值可以改变。整型 ci 是常量，也不能修改(可以进行初始化， 如本例中所示)。pci 的类型是"指向 const int 的指针"，pci 本身可以被修改以指向另 一个地方，但它所指之处的值不能通过 pci 赋值来改变，
2 数组声明符
在声明 T D 中，如果 D 具有下列形式:
D1[常量表达式 opt]
且声明 T D1 中标识符的类型是"类型修饰符 T"，则 D 的标识符类型为"类型修饰符 T 类型的数组"。如果存在常量表达式，则该常量表达式必须为整型且值大于 0。若缺少指定数 组上界的常量表达式，则该数组类型是不完整类型。
数组可以由算术类型、指针类型、结构类型或联合类型构造而成，也可以由另一个数组 构造而成(生成多维数组)。构造数组的类型必须是完整类型，绝对不能是不完整类型的数组 或结构。也就是说，对于多维数组来说，只有第一维可以缺省。对于不完整数组类型的对象 来说，其类型可以通过对该对象进行另一个完整声明(参见 A.10.2 节)或初始化(参见 A.8.7 节)来使其完整。例如:
float fa[17], *afp[17];
声明了一个浮点数数组和一个指向浮点数的指针数组，而
static int x3d[3][5][7];
则声明了一个静态的三维整型数组，其大小为 3×5×7。具体来说，x3d 是一个由 3 个页组成的 数组，每个页都是由 5 个数组组成的一个数组，5 个数组中的每个数组又都是由 7 个整型数组 成的数组。x3d、x3d[i]、x3d[i][j]与 x3d[i][j][k]都可以合法地出现在一个表达式 中。前三者是数组类型，最后一个是 int 类型。更准确地说，x3d[i][j]是一个有 7 个整型 元素的数组;x3d[i]则是有 5 个元素的数组，而其中的每个元素又是一个具有 7 个整型元素 的数组。
根据数组下标运算的定义，E1[E2]等价于*(E1+E2)。因此，尽管表达式的形式看上去 不对称，但下标运算是可交换的运算。根据适用于运算符+和数组的转换规则(参见 A.6.6 节、 A.7.1 节与 A.7.7 节)，若 E1 是数组且 E2 是整数，则 E1[E2]代表 E1 的第 E2 个成员。
在本例中，x3d[i][j][k]等价于*(x3d[i][j]+k)。第一个子表达式 x3d[i][j]将 按照 A.7.1 节中的规则转换为“指向整型数组的指针”类型，而根据 A.7.7 节中的规则，这里的 加法运算需要乘以整型类型的长度。它遵循下列规则:数组按行存储(最后一维下标变动最 快)，且声明中的第一维下标决定数组所需的存储区大小，但第一维下标在下标计算时无其它 作用。
3 函数声明符
在新式的函数声明 T D 中，如果 D 具有下列形式:
D1(形式参数类型表)
并且，声明 T D1 中标识符的类型为"类型修饰符 T"，则 D 的标识符类型是"返回 T 类型值 且具有6形式参数类型表'中的参数的6类型修饰符'类型的函数"。
形式参数的语法定义为: 形式参数类型表:
形式参数表 形式参数表, ...
形式参数表:
形式参数声明
形式参数表, 形式参数声明 形式参数声明:
声明说明符 声明符 声明说明符 抽象声明符 opt
在这种新式的声明中，形式参数表指定了形式参数的类型。这里有一个特例，按照新式方式 声明的无形式参数函数的声明符也有一个形式参数表，该表仅包含关键字 void。如果形式参 数表以省略号“ , ..."结尾，则该函数可接受的实际参数个数比显式说明的形式参数个数 要多。详细信息参见 A.7.3 节。
如果形式参数类型是数组或函数，按照参数转换规则(参见 A.10.1 节)，它们将被转换为 指针。形式参数的声明中惟一允许的存储类说明符是 register，并且，除非函数定义的开 头包括函数声明符，否则该存储类说明符将被忽略。类似地，如果形式参数声明中的声明符 包含标识符，且函数定义的开头没有函数声明符，则该标识符超出了作用域。不涉及标识符 的抽象声明符将在 A.8.8 节中讨论。
在旧式的函数声明 T D 中，如果 D 具有下列形式:
D1(标识符表 opt)
并且声明 D1 中的标识符的类型是"类型修饰符 T"，则 D 的标识符类型为"返回 T 类型 值且未指定参数的6类型修饰符'类型的函数"。形式参数(如果有的话)的形式如下:
标识符表:
标识符
标识符表, 标识符 在旧式的声明符中，除非在函数定义的前面使用了声明符，否则，标识符表必须空缺(参见
A.10.1 节)。声明不提供有关形式参数类型的信息。
例如，下列声明:
int f(), *fpi(), (*pfi)();
声明了一个返回整型值的函数 f、一个返回指向整型的指针的函数 fpi 以及一个指向返回整
型的函数的指针 pfi。它们都没有说明形式参数类型，因此都属于旧式的声明。
在下列新式的声明中:
int strcpy(char *dest, const char *source), rand(void);
strcpy 是一个返回 int 类型的函数，它有两个实际参数，第一个实际参数是一个字符指针， 第一个实际参数星一个指向常量字符的指针。其中的形式参数名字可以起到注释说明的作用。 第二个函数 rand 不带参数，且返回类型为 int。
说明:到目前为止，带形式参数原型的函数声明符是 ANSI 标准中引入的最重要的一个语 言变化。它们优于第 1 版中的"旧式"声明符，因为它们提供了函数调用时的错误检查和参 数强制转换，但引入的同时也带来了很多混乱和麻烦，而且还必须兼客这两种形式。为了保 持兼容，就不得不在语法上进行一些处理，即采用 void 作为新式的无形式参数函数的显式标 记。
采用省略号“ , ..."表示函数变长参数表的做法也是 ANSI 标准中新引入的，并且，结 合标准头文件中的一些宏，共同将这个机制正式化了。该机制在第 1 版中是官 方上禁止的，但可非正式地使用。
这些表示法起源于 C++。
A.8.7              初始化
声明对象时，对象的初始化声明符可为其指定一个初始值。初值紧跟在运算符=之后，它 可以是一个表达式，也可以是嵌套在花括号中的初值序列。初值序列可以以逗号结束，这样 可以使格式简洁美观。
初值:
赋值表达式
{初值表}
{初值表,}
初值表:
初值
初值表, 初值
对静态对象或数组而言，初值中的所有表达式必须是 A.7.19 节中描述的常量表达式。 如果初值是用花括号括起来的初值表，则对 auto 或 register 类型的对象或数组来说，初 值中的表达式也同样必须是常量表达式。但是，如果自动对象的初值是一个单个的表达式， 则它不必是常量表达式，但必须符合对象赋值的类型要求。
说明:第 1 版不支持自动结构、联合或数组的初始化。而 ANSI 标准是允许的，但只能 通过常量结构进行初始化，除非初值可以通过简单表达式表示出来。
未显式初始化的静态对象将被隐式初始化，其效果等同于它(或它的成员)被赋以常量   0。 未显式初始化的自动对象的初始值没有定义。
指针或算术类型对象的初值是一个单个的表达式，也可能括在花括号中。该表达式将赋 值给对象。
结构的初值可以是类型相同的表达式，也可以是括在花括号中的按其成员次序排列的初 值表。无名的位字段成员将被忽略，因此不被初始化。如果表中初值的数目比结构的成员数 少，则后面余下的结构成员将被初始化为 0。初值的数目不能比成员数多。
数组的初值是一个括在花括号中的、由数组成员的初值构成的表。如果数组大小未知， 则初值的数目将决定数组的大小，从而使数组类型成为完整类型。若数组大小固定，则初值 的数目不能超过数组成员的数目。如果初值的数目比数组成员的数目少，则尾部余下的数组 成员将被初始化为 0。
这里有一个特例:字符数组可用字符串字面值初始化。字符串中的各个字符依次初始化 数组中的相应成员。类似地，宽字符字面值(参见 A.2.6 节)可以初始化 wchar_t 类型的数 组。若数组大小未知，则数组大小将由字符串中字符的数目(包括尾部的空字符)决定。若 数组大小固定，则字符串中的字符数(不计尾部的空字符)不能超过数组的大小。
联合的初值可以是类型相同的单个表达式，也可以是括在花括号中的联合的第一个成员 的初值。
说明:第 1 版不允许对联合进行和始化。"第一个成员"规则并不很完美，但在没有新语 法的情况下很难对它进行一般化。除了至少允许以一种简单方式对联合进行显式初始化外， ANSI 规则还给出了非显式初始化的静态联合的精确语义。
聚集是一个结构或数组。如果一个聚集包含聚集类型的成员，则初始化时将递归使用初 始化规则。在下列情况的初始化中可以省略括号:如果聚集的成员也足一个聚集，且该成员 的初始化符以左花括号开头，则后续部分中用逗号隔开的初值表将初始化子聚集的成员。初 值的数目不允许超过成员的数目。但是，如果子聚集的初值不以左花括号开头，则只从初值 表中取出足够数目的元素作为于聚集的成员，其它剩余的成员将用来初始化该子聚集所在的 聚集的下一个成员。
例如:
int x[] = { 1, 3, 5 };
将 x 声明并初始化为一个具有 3 个成员的一维数组，这是因为，数组未指定大小且有 3 个初 值。下面的例子:
float y[4][3] = {
{
1,
3,
5
},
{
2,
4,
6
},
{
3,
5,
7
},
};
是一个完全用花括号分隔的初始化:1、3 和 5 这 3 个数初始化数组 y[0]的第一行，即 y[0][0]、 y[0][1]和 y[0][2]。类似地，另两行将初始化 y[1]和 y[2]。因为初值的数目不够，所以 y[3]中的元素将被初始化为  0，完全相同的效果还可以通过下列声明获得:
float y[4][3] = {
1, 3, 5, 2, 4, 6, 3, 5, 7
};
y 的初值以左花括号开始，但 y[0]的初值则没有以左花括号开始，因此 y[0]的初始化将使 用表中的 3 个元素。同理，y[1]将使用后续的 3 个元素进行初始化，y[2]依此类推。另外， 下列声明:
float y[4][3] = {
{ 1 }, { 2 }, { 3 }, { 4 }
};
将初始化 y 的第一列(将 y 看成为一个二维数组)，其余的元素将默认初始化为 0。 最后
char msg[] = "Syntax error on line %s\n";
声明了一个字符数组，并用一个字符串字面值初始化该字符数组的元素。该数组的大小包括 尾部的空字符。
A.8.8              类型名
在某些上下文中(例如，需要显式进行强制类型转换、需要在函数声明符中声明形式参 数类型、作为 sizeof 的实际参数等)，我们需要提供数据类型的名字。使用类型名可以解决 这个问题，从语法上讲，也就是对某种类型的对象进行声明，只是省略了对象的名字而已。
类型名:
说明符限定符表 抽象声明符 opt
抽象声明符: 指针
指针 opt 直接抽象声明符 直接抽象声明符
(抽象声明符)
直接抽象声明符 opt [常量表达式 opt]
直接抽象声明符 opt (形式参数类型表 opt)
如果该结构是声明中的一个声明符，就有可能惟一确定标识符在抽象声明符中的位置。命名 的类型将与假设标识符的类型相同。例如:
int int *
int *[3] int (*)[] int *()
int (*[])(void)
其中的 6 个声明分别命名了下列类型:“整型”、“指向整型的指针”、“包含 3 个指向整型 的指针的数组”、“指向未指定元素个数的整型数组的指针”、“未指定参数、返回指向整型的指 针的函数”、“一个数组，其长度未指定，数组的元素为指向函数的指针，该函数没有参数且返 回一个整型值"。
A.8.9              typedef
存储类说明符为 typedef 的声明不用于声明对象，而是定义为类型命名的标识符。这些 标识符称为类型定义名。
类型定义名:
标识符
typedef 声明按照普通的声明方式将个类型指派给其声明符中的每个名字(参见 A.8.6 节)。 此后，类型定义名在语法上就等价于相关类型的类型说明符关键字。
例如，在定义
typedef long Blockno, *Blockptr;
typedef struct { double r, theta; } Complex;
之后，下述形式:
Blockno b;
extern Blockptr bp; Complex z, *zp;
都是合法的声明。b 的类型为 long，bp 的类型为"指向 long 类型的指针"。z 的类型为指
定的结构类型，zp 的类型为指向该结构的指针。
typedef 类型定义并没有引入新的类型，它只是定义了数据类型的同义词，这样，就可 以通过另一种方式进行类型声明。在本侧中，b 与其它任何 long 类型对象的类型相同。
类型定义名可在内层作用域中重新声明，但必须给出一个非空的类型说明符集合。例如， 下列声明:
extern Blockno;
并没有重新声明 Blockno，但下列声明: extern int Blockno;
则重新声明了 Blockno。
A.8.10          类型等价
如果两个类型说明符表包含相同的类型说明符集合(需要考虑类型说明符之间的蕴涵关 系，例如，单独的 long 蕴含了 long int)，则这两个类型说明符表是等价的。具有不同标 记的结构、不同标记的联合和不同标记的枚举是不等价的，无标记的联合、无标记的结构或 无标记的枚举指定的类型也是不等价的。
在展开其中的任何 typedef 类型并删除所有函数形式参数标识符后，如果两个类型的抽 象声明符(参见 A.8.8 节)相同，且它们的类型说明符表等价，则这两个类型是相同的。数组 长度和函数形式参数类型是其中很重要的因素。
A.9 语旬
如果不特别指明，语句都是顺序执行的。语句执行都有一定的结果，但没有值。语句可 分为几种类型。
语句:
带标号语句 表达式语句 复合语句 选择语句 循环语句 跳转语句
A.9.1               带标号语句
语句可带有标号前缀。 带标号语句:
标识符: 语句