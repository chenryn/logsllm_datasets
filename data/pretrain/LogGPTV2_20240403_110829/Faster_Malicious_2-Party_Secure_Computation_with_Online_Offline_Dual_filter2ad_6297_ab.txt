protocols in the garbled circuit paradigm like ours. The
latest implementations of [9] can securely evaluate AES
with online latency 20ms [33]. Of special note is the im-
plementation of the [11] protocol reported in [10], which
achieves latency of only 6ms to evaluate AES. However,
the implementation is heavily optimized for the special
case of computing AES, and it is not clear how applica-
ble their techniques are for general-purpose MPC. In any
case, no protocol has reported online latency for AES
that is less than our protocol’s total ofﬂine+online cost.
The above protocols based on secret-sharing also have
signiﬁcantly more expensive ofﬂine phases. Not all im-
plementations report the cost of their ofﬂine phases, but
the latest implementations of the [9] protocol require 156
seconds of ofﬂine time for securely computing AES [33];
many orders of magnitude more than ours. We note that
the protocols in the secret-sharing paradigm have an of-
ﬂine phase which does not depend on the function that
will be evalauted, whereas ours does.
3 Preliminaries
Secure computation. We use the standard notion of
universally composable (UC) security [6] for 2-party
computation. Brieﬂy, the protocol is secure if for every
adversary attacking the protocol, there is a straight-line
simulator attacking the ideal functionality that achieves
the same effect. We assume the reader is familiar with
the details.
We deﬁne the ideal functionality Fmulti-sfe that we
achieve in Figure 2. The functionality allows parties to
evaluate the function f , N times. Adversaries have the
power to delay (perhaps indeﬁnitely) the honest party’s
output, which is typical in the setting of malicious secu-
rity. In other words, the functionality does not provide
output fairness.
Furthermore, the functionality occasionally allows the
adversary to learn an arbitrary additional bit about the in-
puts. This leakage happens according to the distribution
L chosen by the adversary at setup time. The probability
of a leaked bit in any particular evaluation of f is guar-
anteed to be at most ε. Further, the leakage is “risky” in
the sense that the honest party detects cheating when the
leaked bit is zero.
Building blocks.
In Figures 10 & 11 we deﬁne obliv-
ious transfer (OT) and commitment functionalities that
are used in the protocol.
In the random oracle model,
where H is the random oracle, a party can commit to v by
choosing random r ← {0,1}κc and sending c = H(r(cid:28)v).
We use and adapt the Garbled Circuit notation and
terminology of [5]; for a formal treatment, consult that
paper.
In Appendix A we deﬁne the syntax and secu-
rity requirements, highlighting the differences we adopt
compared to [5].
4 The Dual Execution Paradigm
We now give a high-level outline of
the (non-
online/ofﬂine) 2PC protocol paradigm of [16], which is
the starting point for our protocol. The protocol makes
use of a two-phase PSI subprotocol. In the ﬁrst phase,
both parties become committed to their PSI inputs; in
the second phase, the PSI output is revealed. This com-
n,(cid:30)
psi functionality in
ponent is modeled in terms of the F
Figure 12.
Assume the parties agree on a function f to be eval-
uated on their inputs. The protocol is symmetric with
respect to Alice and Bob, and for simplicity we describe
only Alice’s behavior.
(1) Alice generates κb garbled circuits computing f , us-
ing a common garbled output encoding for all of
them.
(2) Alice announces a random subset of Bob’s circuits
to open. However, the actual checking of the cir-
cuits is delayed until later in the protocol.
(3) Alice uses OT to receive garbled inputs for the cir-
cuits generated by Bob, as in Yao’s protocol. Alice
sends the garbled circuits she generated, along with
her own garbled input for these circuits.
(4) Alice evaluates the garbled circuits received from
Bob. If Bob is honest, then all of his circuits use
the same garbled output encoding and Alice will re-
ceive the same garbled output from each one. But in
the general case, Alice might obtain several incon-
sistent garbled outputs.
(5) Assume that Alice can decode the garbled outputs
to obtain the logical circuit output. For each candi-
date circuit output y with garbled encoding Y b
y (b for
a garbled output under Bob’s encoding), let Y a
y de-
note the encoding of y under Alice’s garbled output
encoding (which Alice can compute). Interpreting
Y a
y and Y b
y as sets of individual wire labels, let Ry
be the XOR of all items in Y a
y , which we write
as Ry =(cid:31)[Y a
y ] and which we call the reconcil-
iation value for y. Alice sends the set of all {Ry}
values as input to a PSI instance.
(6) With the PSI inputs committed, the parties open and
check the circuits chosen in the cut-and-choose step.
They abort if any circuit is not correctly garbled, or
the circuits do not have consistent garbled output
encodings.
y ∪Y b
y ∪Y b
(7) The parties release the PSI output. Alice aborts if
the PSI output is not a singleton set. Otherwise, if
4
300  25th USENIX Security Symposium 
USENIX Association
Setup stage: On common input (SETUP, f ,N,ε) from both parties, where f is a boolean circuit:
• If neither party is corrupt, set L = 0N. Otherwise, wait for input (CHEAT, L ) where L is a distribution over
{0,1}N ∪{⊥} with the property that for every i, PrL←L [Li = 1] ≤ ε. Sample L ← L using random coins χ
and give (CHEATRESULT, χ) to the adversary. If L = ⊥ then give output (CHEATING!) to the honest party
and stop responding.
• Send output (READY) to both parties. Initialize counter ctr = 1. Proceed to the execution stage.
Execution stage: Upon receiving inputs (INPUT,x1) from P1 and (INPUT,x2) from P2:
p = P(x1,x2) and give (LEAKRESULT, p) to the adversary.
• Compute z = f (x1,x2). If both parties are honest, give (OUTPUT,ctr,z) to both parties.
• If any party is corrupt, give (OUTPUT,ctr,z) to the adversary.
• If Lctr = 1, wait for a command (LEAK,P) from the adversary, where P is a boolean predicate. Compute
• If any party is corrupt, then on input (DELIVER) from the adversary, if p = 0 above, then give output
• If ctr = N then stop responding; otherwise set ctr = ctr + 1 and repeat the execution stage.
(CHEATING!) to the honest party, else give output (OUTPUT,ctr,z) to the honest party.
Figure 2: The (ε-leaking) secure function evaluation functionality Fmulti-sfe.
the output is {R∗} then Alice outputs the value y
such that R∗ = Ry.
4.1 Security Analysis and Other Details
Suppose Alice is corrupt and Bob is honest. We will ar-
gue that Alice learns nothing beyond the function output,
except that with probability 2−κb she learns a single bit
about Bob’s input.
Suppose Alice uses input x1 as input to the OTs, and
Bob has input x2. Since Bob’s circuits are honestly gen-
erated and use the same garbled output encoding, every
circuit evaluated by Alice leads to the same garbled out-
put Y b
y∗ that encodes logical value y∗ = f (x1,x2). Note
that by the authenticity property of the garbled circuits,
this is the only valid garbled output that Alice can pre-
dict.
Since Alice may generate malicious garbled circuits,
honest Bob may obtain several candidate outputs from
these circuits. Bob’s input to the PSI computation will
be a collection of reconciliation values, each of the form
Ry =(cid:31)[Y a
y ∪Y b
y ].
At the time of PSI input, none of Bob’s (honestly) gar-
bled circuits have been opened, so they retain their au-
thenticity property. Then Alice cannot predict any valid
reconciliation value except for this Ry∗. This implies that
the PSI output will be either {Ry∗} or /0. In particular,
Bob will either abort or output the correct output y∗. Fur-
thermore, the output of the PSI computation can be simu-
lated knowing only whether honest Bob has included Ry∗
in his PSI input.
The protocol includes a mechanism to ensure that Al-
ice uses the same x1 input for all of the garbled circuits.
Hence, if Bob evaluates at least one correctly generated
garbled circuit, it will give output y∗ and Bob will surely
include the Ry∗ reconciliation value in his PSI input. In
that case, the PSI output can be simulated as usual.
The probability the Alice manages to make Bob evalu-
ate no correctly generated garbled circuits is 2−κb — she
would have to completely predict Bob’s cut-and-choose
challenge to make all opened circuits correct and all eval-
uated circuits incorrect. But even in this event, the simu-
lator only needs to know whether f (cid:22)(x1,x2) = y∗ for any
of the f (cid:22) computed by Alice’s malicious garbled circuits.
This is only one bit of information about x2 which the
simulator can request from the ideal functionality.
4.2 Outline
for Online/Ofﬂine Dual-
Execution
Our high-level approach is to adapt the [16] protocol to
the online/ofﬂine setting. The idea is that the two par-
ties plan to securely evaluate the same function f , N
times, on possibly different inputs each time. In prepara-
tion they perform an ofﬂine pre-processing phase that de-
pends only on f and N, but not on the inputs. They gener-
ate many garbled circuits and perform a cut-and-choose
on all of them. Then the remaining circuits are assigned
randomly to buckets. Later, once inputs are known in the
online phase, one bucket’s worth of garbled circuits are
consumed for each evaluation of f .
Our protocol will leak a single bit about the honest
party’s input only when a bucket contains no “good”
circuit from the adversary (where “good” is the condi-
tion that is veriﬁed for opened circuits during cut-and-
choose). Following the lead of [23], we focus on choos-
ing the number of circuits so that the probability of such
an event in any particular bucket is 2−κb. We note that
the analysis of parameters in [14, 22] considers an over-
all cheating condition, i.e., that there exists a bucket that
has no “good” circuits, which leads to slightly different
numbers.
Lemma 1 ([23]). If the parties plan to perform N exe-
USENIX Association  
25th USENIX Security Symposium  301
5
cutions, using a bucket of B circuits for each execution
and a total of(cid:31)N ≥ NB garbled circuits generated for the
overall cut-and-choose, then the probability that a spe-
ciﬁc bucket contains no good circuit is at most:
Ofﬂine phase:
(1) Parties perform ofﬂine preprocessing for the OTs
that will be needed, and for the PSI subprotocol,
if appropriate.
max
.
(cid:27) (cid:31)N−t
NB−t(cid:26)
NB(cid:26) · (cid:27) t
B(cid:26)(cid:27)NB
B(cid:26)
(cid:27) (cid:31)N
t∈{B,...,NB}
Suppose the parties will perform N executions, us-
ing buckets of size B in the online phase, and wish for
2−κb probability of leakage. We can use the formula
to determine the smallest compatible (cid:31)N.
In the full
version we show all reasonable parameter settings for
κb ∈ {20,40,80} and N ∈ {8,16,32, . . . ,32768}.
By adapting [16] to the online/ofﬂine setting, we ob-
tain the generic protocol outlined in Figure 3. Even with
pre-processing, an online OT requires two rounds, one
of which can be combined with the direct sending of gar-
bled inputs. The protocol therefore requires three rounds
plus the number of rounds needed for the PSI subproto-
col (at least two).
4.3 Technicalities
We highlight which parts of the [16] protocol break down
in the online/ofﬂine setting and require technical modiﬁ-
cation:
Same garbled output encoding. In [16] each party is re-
quired to generate garbled circuits that have a common
output encoding. Their protocol includes a mechanism
to enforce this property. In our setting, we require each
bucket of circuits to have the same garbled output encod-
ing. But this is problematic because in our setting a gar-
bled circuit is generated before the parties know which
bucket it will be assigned to.
Our solution is to have the garbler provide for each
bucket a translation of the following form. The garbler
chooses a bucket-wide garbled output encoding; e.g., for
the ﬁrst output wire, he chooses wire labels W∗0 ,W∗1 en-
coding false and true, respectively. Then if W j
1 are
the output wire labels already chosen for the jth circuit
in this bucket, the garbler is supposed to provide trans-
lation values W j
v ⊕W∗v for v ∈ {0,1}. After evaluating,
the receiver will use these values to translate the garbled
input to this bucket-wide encoding that is used for PSI
reconciliation.
0 ,W j
Of course, a cheating party can provide invalid transla-
tion values. So we use step 3 of the online phase (Figure
3) to check them. In more detail, a sender must commit
in the ofﬂine phase to the output wire labels of every gar-
bled circuit. These will be checked if the circuit is chosen
in the cut-and-choose. In step 3 of the online phase, these
commitments are opened so that the receiver can check
the consistency of the translation values (i.e., whether
(2) Based on N and κb, the parties determine appro-
sion in Section 4.2. Each party generates and
priate parameters (cid:31)N, B according to the discus-
sends (cid:31)N garbled circuits, and chooses a random
subset of(cid:31)N − NB of their counterpart’s circuits to
be opened. The chosen circuits are opened and
parties abort if circuits are found to be generated
incorrectly.
(3) Each party randomly assigns their counterpart’s
circuits to buckets of size B. Each online execu-
tion will consume one bucket’s worth of circuits.
Online phase:
(1) Parties exchange garbled inputs: For one’s own
garbled circuits in the bucket, a party directly
sends the appropriate garbled inputs;
for the
counterpart’s garbled circuits, a party uses OT as
a receiver to obtain garbled inputs as in Yao’s pro-
tocol.
(2) Parties evaluate the garbled circuits and compute
the corresponding set of reconciliation values.
They commit their sets of reconciliation values as
inputs to a PSI computation.
(3) With the PSI inputs committed, the parties open
some checking information (see text in Section
4.3) and abort if it is found to be invalid.
(4) The parties release the PSI output and abort if the
output is /0. Otherwise, they output the plaintext
value whose reconciliation value is in the PSI out-
put.
Figure 3: High-level outline of the online/ofﬂine, dual-
execution protocol paradigm.
they map to a hash of the common bucket-wide encod-
ing provided during bucketing.). This step reveals all of
the bucket-wide encoding values, making it now easy for
an adversary to compute any reconciliation value. This
is why we employ a 2-phase PSI protocol, so that PSI
inputs are committed before these translation values are
checked.
Adaptive garbling. Standard security deﬁnitions for gar-
bled circuits require the evaluator to choose the input
before the garbled circuit is given. However, the entire
purpose of ofﬂine pre-processing is to generate & send
the garbled circuits before the inputs are known. This
requires the garbling scheme to satisfy an appropriate
adaptive security property, which is common to all works
in the online/ofﬂine setting [14, 22]. See Appendix A for
details.
302  25th USENIX Security Symposium 
USENIX Association
6