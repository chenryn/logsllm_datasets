VMEntry
VMXON
(Start)
VMEntry
VMEntry
VMExit
VMExit
...
Ether
Ether
Ether
Hypervisor
Guest
Figure 1: Processor operation for Intel VT. Ether
operates between VMExits and VMEntries.
Intel VT hardware virtualization extensions are a set of in-
structions added to Intel processors to facilitate the virtual-
ization of the x86 instruction set. These instructions enable
two new processor modes, called VMX root mode and VMX
non-root mode. The Xen hypervisor, and hence Ether, runs
in VMX root mode. The domUs or guests, which we refer
to as the analysis targets, run in VMX non-root mode.
Events called VM transitions change operation between
the two modes. There are two diﬀerent transitions: VMEn-
try and VMExit. A VMExit will transition from VMX non-
root mode to VMX root mode, and a VMEntry will tran-
sition from VMX root mode to VMX non-root mode. Cer-
tain events in VMX non-root mode automatically cause a
VMExit; these include certain exceptions, changes to the
page directory entry pointer, and page faults.
Ether obtains control from the analysis target on VMExits
and performs a VMEntry when it chooses to resume execu-
tion of the analysis target (i.e., the guest). After a VMExit,
but before the next VMEntry, the guest is in a completely
dormant state. An overview of this process is shown in Fig-
ure 1.
4.2 Analyzer Architecture
As shown in Figure 2, the architecture of Ether consists of
a hypervisor component and a userspace component running
in domain 0. Ether’s hypervisor component is responsible
for detecting events in the analysis target. Currently, such
events include system call execution, instruction execution,
memory writes, and context switches.
Ether’s userspace component acts as a controller regulat-
ing which processes and events in the guest should be moni-
tored. This component also contains logic to derive semantic
information from analyzed events, such as translating a sys-
tem call number into system call name or displaying system
call argument content based on argument data type.
The analysis target consists of a Xen domU running Win-
Dom0
Ether 
Userspace 
Component
DomU
(Windows 
Guest)
...
DomU
(Windows 
Guest)
Ether Hypervisor Component
 Xen  
CPU / Hardware
Figure 2: Ether’s system architecture.
dows XP Service Pack 2. The only change we made to
the default installation of Windows XP was disabling PAE
and large memory pages. These modiﬁcations exist solely
to make memory write detection easier in the initial Ether
implementation and are not a limitation of our approach.
4.3 Using Intel VT for Malware Analysis
To present Ether as a full-featured malware analyzer we
required that it be able to monitor the instructions executed
by a guest process, any memory writes a guest process per-
forms, and any system calls a guest process makes. We chose
these low- and high-level operations due to their usefulness
in malware analysis and their ability to demonstrate the
eﬃcacy of Ether performing both coarse- and ﬁne-grained
tracing. The challenges to successful implementation in-
cluded using a mechanism that was not intended for mal-
ware analysis (i.e., Intel VT) while maintaining the original
level of transparency provided by hardware virtualization
extensions. Given that Intel VT extensions do not provide
explicit support for any of these monitoring activities we
performed an in-depth investigation of Intel VT to create
novel ways that fulﬁll our monitoring requirements. Below
we ﬁrst describe how Ether uses VT extensions to analyze
malware and then how it can maintain transparency.
4.3.1 Monitoring Instruction Execution
Instruction execution monitoring relies on Ether’s privi-
lege over the analysis target in handling debug exceptions,
and in guaranteeing a debug exception occurs after the exe-
cution of every instruction. Ether guarantees the occurrence
of a debug exception after every instruction by setting a ﬂag
called the trap ﬂag in the analysis target. Upon handling a
debug exception caused by the forced trap ﬂag, Ether will
once again set the trap ﬂag for the next instruction, thereby
inducing a debug exception after every instruction. Ultimate
control of which exceptions reach the analysis target rests
in Ether, so all induced debug exceptions are hidden from
the analysis target. This control allows Ether to execute the
target process one instruction at a time while preventing it
from detecting Ether’s presence. This form of instruction
stepping via the trap ﬂag was ﬁrst implemented in VAM-
PiRE, even though its approach is in-guest and hence vul-
nerable to in-guest detection attacks.
4.3.2 Monitoring Memory Writes
Ether monitors memory writes by using shadow page ta-
bles and privilege over the guest in handling page faults.
Ether induces a page fault at every attempted analysis target
memory write, traps the fault, and prevents it from reaching
the guest. Faults occurring due to normal guest operation
are forwarded to the guest. In this manner all memory write
attempts are transparently intercepted.
Shadow page tables refer to the actual page tables the
hardware uses for address translation, as the guest is never
permitted to do its own translation. The hypervisor is re-
sponsible for synchronizing shadow page tables with the
guest’s page table contents, as well as ensuring the guest
can only map memory explicitly allocated for it.
Ether causes page faults on write attempts by removing
writable permissions from shadow page table entries. When
Ether detects a fault caused by itself, the Ether userspace
component is notiﬁed of an attempted memory write, and
the fault is then hidden from the analysis target. Faults
resulting from normal guest operation are passed along. Af-
ter notiﬁcation, the faulting page is set to writable in the
shadow page table and the faulting instruction is re-executed.
Upon completion of the instruction, all pages are once again
marked read-only in preparation for the next instruction.
4.3.3 Monitoring System Call Execution
Ether’s novel system call execution monitoring exploits
features of the x86 fast system call entry mechanism to in-
form Ether of system calls executed by the analysis target.
The system call interception mechanism uses a special reg-
ister present on all modern x86 processors to cause a page
fault at a chosen address during system call invocation. A
fault at this address will then signal to Ether that a system
call was executed in the analysis target. In addition to trac-
ing system calls executed via the fast call entry mechanism,
Ether can trace system calls made via deprecated methods
as well. Semantic information such as system call arguments
and return value may also be obtained by Ether.
To properly describe Ether’s system call tracing technique,
some background on the fast system call entry mechanism of
x86 processors is required. This method is used for system
calls on all Windows versions starting with XP, and on Linux
kernels starting with 2.6. The fast system call entry mech-
anism uses the SYSENTER instruction to raise privilege and
jump to a pre-deﬁned address in the kernel. This address is
stored in a special register called SYSENTER_EIP_MSR, access
to which is only permitted from kernel mode. Whenever
a userspace application requires system services, it speciﬁes
the service number and parameters in an implementation
dependent manner, and then executes SYSENTER. SYSENTER
changes the privilege mode to kernel mode, the stack pointer
to the kernel mode stack, and the instruction pointer to the
value in SYSENTER_EIP_MSR.
Ether sets the value of the analysis target’s SYSENTER_EIP
_MSR to a chosen value on a page guaranteed to be not
present, and stores the original value in Ether’s memory.
Whenever the analysis target attempts system call execu-
tion, a fetch page fault will occur at the chosen address.
When Ether encounters such a fault in the analysis target,
it indicates a system call was attempted. The userspace
component of Ether is notiﬁed of system call execution, and
the instruction pointer of the analysis target is reset to the
expected value of SYSENTER_EIP_MSR. Execution of the anal-
ysis target resumes as if SYSENTER jumped directly to the
expected address, instead of our chosen address.
The arguments, return address, and return value of a sys-
tem call may be gathered from the guest by a series of guest
memory reads. The exact location of the arguments, return
value, and return address is guest operating system depen-
dent.
System calls executed via deprecated methods can also be
monitored by Ether. While all operating system provided
libraries in Windows XP will use the SYSENTER instruction
to execute system calls, support for system call execution
via software interrupt 0x2E is still present in the kernel. To
trace system calls executed by this older method, Ether can
change the interrupt descriptor table entry of interrupt 0x2E
to point to a non-present page. A VMExit caused by a page
fault at that address would indicate system call execution via
INT 2E. Alternatively, AMD’s hardware virtualization solu-
tion provides a direct means to cause VMExits on software
interrupts [14].
4.3.4 Limiting Scope to a Chosen Process
Ether can limit analysis scope to a chosen process in the
analysis target. Processes are identiﬁed for monitoring dur-
ing a context switch in the analyzed environment. When a
context switch occurs, Ether gains control and uses virtual
machine introspection [28] to obtain the upcoming process
name from the analysis target. If the process matches a tar-
get speciﬁed to Ether, analysis is enabled. In the current
implementation, the target process may either be speciﬁed
by name or by the process page directory entry. Enabling
process monitoring exactly when a process is about to run
guarantees Ether does not miss any events executed by the
process.
Ether gains control on every context switch by leveraging
a feature of Intel VT that causes a VMExit every time the
page directory entry pointer is accessed in the guest OS. As
the page directory pointer must be updated every context
switch to change address spaces, it is guaranteed that Ether
will detect all guest context switches.
4.4 Maintaining Analyzer Transparency
Despite making several modiﬁcations to the guest, Ether
maintains transparency of the analyzer by ensuring such
changes are undetectable. Other changes made by Ether,
such as those to shadow page tables, are changes outside of
the analysis target and therefore transparent. Transparency
of the analyzer does not imply hiding the presence of a vir-
tualized environment, but hiding the presence of Ether in a
virtualized environment.
4.4.1 Hiding the Trap Flag
Ether is able to conceal that it has the set trap ﬂag in the
guest by intercepting the few instructions that can read this
ﬂag, and altering their behavior to hide the ﬂag’s presence.
The only instruction which can directly read the presence
of the trap ﬂag is PUSHF. Ether intercepts this instruction
and changes its result to provide the environment-expected
state of the ﬂag. Besides PUSHF, the INT instruction reads
the value of the ﬂag indirectly. We monitor this instruction
as well, and ﬁx the ﬂags value pushed on the stack to match
the value expected by the analysis target.
At times the analysis target has set the trap ﬂag and ex-
pects to receive debug exceptions. Ether detects the setting
of the trap ﬂag by the POPF instruction, and when the anal-
ysis target expects the trap ﬂag to be set, Ether forwards
debug exceptions along as appropriate. Any debug excep-
tions not caused by the trap ﬂag are automatically forwarded
to the analysis target as they are not caused by Ether.
4.4.2 Page Table Modiﬁcations
The page table modiﬁcations made by Ether are to shadow
page tables, and not the page tables stored in the guest.
Therefore, the guest is not aware that the shadow page ta-
bles exist, and hence cannot detect their modiﬁcation or
presence. Ether can determine which faults were caused by
normal guest operation, and which faults it purposely cre-
ated. Any faults caused by normal operation are forwarded
to the guest. Conversely, any faults caused by Ether are
handled by Ether and never passed along.
4.4.3 SYSENTER_EIP_MSR
Ether mediates all access to the SYSENTER_EIP_MSR regis-
ter and can therefore conceal any modiﬁcations of the regis-
ter from the analysis target. Complete mediation is achieved
because any access of the register automatically causes a
VMExit. Ether saves any value the analysis target attempts
to write into SYSENTER_EIP_MSR, and uses this value any
time the guest-expected value of this register is required.
Although technically modiﬁed, as observed from the analy-
sis target the CPU state C is unchanged.
4.5 Potential Attacks
While theoretically resilient against in-guest detection at-
tacks, current architectural restrictions make some of these
attacks possible, and Ether is also vulnerable to a class of
timing attacks using external timing sources.
4.5.1 Attack Classes
Classic in-guest detection attacks cannot detect Ether due
to it being completely outside of the analysis target. Also,
none of the few modiﬁcations Ether makes to the guest envi-
ronment are unconditionally detectable. Ether is, however,
vulnerable to a certain class of timing attacks, and in the
current implementation, memory hierarchy attacks. Detec-
tion methods and our mitigation of them are outlined below.
In-Memory Presence: Traditional detection attacks
which rely on detecting the presence of an analyzer in mem-
ory will always fail against Ether, as it has no in-guest mem-
ory presence.
CPU Registers: Ether hides the few changes it makes
in CPU state from the analysis target so that it is unable to
detect deviation from a native hardware environment.
Memory Protection: Ether modiﬁes only the shadow
page tables, which are inaccessible to the analysis target.
That is, the analysis target is unable to detect changes to
shadow memory permissions. However, in the current imple-
mentation, Ether does indirectly modify the memory hierar-
chy (the cache and the TLB). This is due to an architectural
limitation; further details are provided in Section 4.6.
Privileged Instruction Handling: Ether uses built-
in hardware mechanisms to intercept only certain privileged
instructions and exceptions and as necessary, forwards these
exceptions to the guest. From the viewpoint of the guest,
no handler is ever modiﬁed, and privileged instructions have
the same eﬀects as in a native environment.
Instruction Emulation: Ether executes all instructions
on the actual processor. Therefore, Ether does not suﬀer
from emulation inaccuracies inherent in full system x86 em-
ulators; the transition function δ remains unmodiﬁed.
Timing Attacks: As described in Section 3.3, there are
two fundamental issues with avoiding timing attacks: con-
trolling queries about time, and answering those queries with
the expected time value. Ether controls the in-guest view of
the RDTSC instruction, the APIC timer, the 8254 timer chip,
as well as any periodic time-based interrupts and other guest
time queries. Section 3.3 outlines the requirements for a cor-
rect reply to a guest time query. This correct reply, ∆E,t,
is the wall-clock time when Ether is present, ∆A,t, reduced
by ∆′
A,t, the amount of overhead added by Ether’s pres-
ence. ∆′
A,t is equal to the time spent in the analyzer minus
the time spent in the guest exception handler. Since Ether
always calls the native exception handlers, if any, for any
exceptions the guest must process, ∆′
A,φ,t consists of the
time spent switching privilege to Ether, the time spent in
Ether’s handler, and the time to switch to the original guest
handler. The time spent in the handler is easily measured
using the wall-clock and times for privilege changes, and can
be calculated empirically. Therefore, Ether would be able to
adjust the time returned to the guest by the amount of over-
head, and remain untraceable by timing attacks which rely