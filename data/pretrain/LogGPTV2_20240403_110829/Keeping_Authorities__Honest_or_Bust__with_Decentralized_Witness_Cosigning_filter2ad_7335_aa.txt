# Title: Ensuring Authority Integrity with Decentralized Witness Cosigning

## Authors:
- Ewa Syta
- Iulia Tamas
- Dylan Visher
- David Isaac Wolinsky
- Philipp Jovanovic
- Linus Gasser
- Nicolas Gailly
- Ismail Khoffi
- Bryan Ford

## Affiliations:
- Yale University, New Haven, CT, USA
- Swiss Federal Institute of Technology (EPFL), Lausanne, Switzerland

## Abstract
The secret keys of critical network authorities—such as time, name, certificate, and software update services—represent high-value targets for hackers, criminals, and espionage agencies. To protect these authorities and their clients from undetected exploits and misuse, we introduce CoSi, a scalable witness cosigning protocol. This protocol ensures that every authoritative statement is validated and publicly logged by a diverse group of witnesses before any client will accept it. A statement \( S \) collectively signed by \( W \) witnesses assures clients that \( S \) has been seen and not immediately found erroneous by those \( W \) observers. Even if \( S \) is compromised in a way not readily detectable by the witnesses, CoSi still guarantees \( S \)'s exposure to public scrutiny, forcing secrecy-minded attackers to risk detection by one of the \( W \) witnesses. Since clients can verify collective signatures efficiently without communication, CoSi protects clients' privacy and offers the first transparency mechanism effective against persistent man-in-the-middle (MITM) attackers who control a victim’s Internet access, the authority’s secret key, and several witnesses’ secret keys. CoSi builds on existing cryptographic multisignature methods, scaling them to support thousands of witnesses via signature aggregation over efficient communication trees. A working prototype demonstrates CoSi in the context of timestamping and logging authorities, enabling groups of over 8,000 distributed witnesses to cosign authoritative statements in under two seconds.

## 1. Introduction
Centralized authorities provide critical services that many hosts and users rely on, such as time [96] and timestamp services [2], certificate authorities (CAs) [35], directory authorities [47, 119], software update services [116], digital notaries [3], and randomness services [103, 110]. Even when cryptographically authenticated, these authorities represent central points of failure and attractive attack targets for hackers, criminals, and espionage agencies. Attackers obtaining the secret keys of any of hundreds of CAs [50] can and have misused CA authority to impersonate websites and spy on users [8, 21, 22, 130]. By impersonating a time service, an attacker can trick clients into accepting expired certificates or other stale credentials [86]. Criminals increasingly use stolen code-signing keys to make their malware appear trustworthy [66].

Proposals such as Perspectives [134], Certificate Transparency (CT) [76, 78], AKI [68], ARPKI [10], and PoliCert [126] enable clients to cross-check certificates against public logs. However, this checking requires active communication and is usually done only retroactively, leaving a window of opportunity for attackers to serve malware or backdoored software. An attacker who controls the client’s access network—such as a compromised home or corporate network, or an ISP controlled by an authoritarian state—can block access to uncompromised log servers, permanently evading detection. Additionally, checking logs can create privacy concerns for clients [89, 104], and the log servers themselves become new central points of failure that must be audited [104].

To address these weaknesses, we propose witness cosigning, a proactive approach to transparency that can either replace or complement existing approaches. When an authority publishes a new signing key, it includes the identities and public keys of a large, diverse, and decentralized group of independent witnesses. Whenever the authority subsequently signs a new authoritative statement, such as a new timestamp, certificate, or log record, it first sends the proposed statement to its witnesses and collects cosignatures. The authority then attaches these cosignatures to the statement along with its own signature. A client receiving the statement (e.g., as a TLS certificate) verifies that it has been signed not only by the authority itself but also by an appropriate subset of the witnesses. The client’s signature acceptance criteria may be a simple numeric threshold (e.g., 50% of the witnesses) or a more complex predicate accounting for trust weights, groupings of witnesses, or contextual information such as whether a signed software update is to be installed automatically or by the user’s explicit request.

Witness cosigning offers clients direct cryptographic evidence—verifiable without communication—that many independent parties have had the opportunity to validate and publicly log any authoritative statement before the client accepts it. Without witness cosigning, an attacker who knows the authority’s secret key can use it in MITM attacks against targeted victims, anywhere in the world and without the knowledge of the legitimate authority, to feed the victim faked authoritative statements such as TLS certificates or software updates [114]. To attack a client who demands that statements be cosigned by at least \( W \) witnesses, however, a MITM attacker must either (a) control both the authority’s secret key and those of \( W \) witnesses, which becomes implausible if \( W \) is sufficiently large and diverse, or (b) submit the faked statement to one or more honest witnesses for cosigning, thereby exposing the faked statement to public scrutiny and risking detection.

We do not expect witnesses to detect all malicious statements immediately; for example, only a CA itself may have the information needed to verify the true correspondence between a name and a public key. Witnesses can, however, perform sanity checks on the correctness and consistency of proposed statements before cosigning. For instance, they can ensure that authoritative timestamps are not wildly different from the witnesses’ view of the present time, that logging authorities sign records in sequence without revising history or equivocating [80], or that only one authoritative binary image exists for a given software version number. Even if witnesses cannot immediately determine which of two conflicting TLS certificates or binaries is "good," they can ensure that the existence of the conflicting signed statements promptly becomes public knowledge. Witnesses can proactively check that statements conform to known policies, such as certificate issuance policies [126], raising alarms and withholding their cosignature if not. Finally, witnesses can publish logs of statements they cosigned to increase the likelihood of rapid attack detection [76].

Even if witnesses perform little or no validation of the authority’s statements, their proactive presence in statement signing deters attackers by increasing the threat of rapid misuse detection and reducing the effective value of an authority’s secret keys to attackers wishing to operate in secret. Witness cosigning thus serves as a “Ulysses pact” between the authority and its witnesses [48].

Authorities could implement witness cosigning simply by collecting and concatenating individual signatures from witnesses, similar to how PGP [28] or Bitcoin [102] can attach multiple signatures to a message or transaction. This is practical with tens or perhaps even a few hundred witnesses, but incurs substantial signature size and verification costs as the witness group grows large. To make witness cosigning scalable, we introduce CoSi, a witness cosigning protocol enabling authoritative statements to be validated and cosigned by thousands of witnesses in a few seconds. CoSi produces collective signatures comparable in size to a single individual signature (e.g., ≈ 100 bytes total) and nearly as quick and easy for clients to verify.

As a scenario motivating CoSi’s scalability goal, we envision the DNSSEC [6] root zone might be witnessed by all willing operators of the now over 1,000 top-level domains (TLDs). Future TLS certificates might be witnessed by all other willing CAs, of which there are hundreds [50], and by other parties such as CT servers [76]. Public ledgers of national cryptocurrencies [101, 123] might be collectively witnessed by all willing banks in the country—of which the US has thousands even after consolidation [129]. Threshold signatures [12, 93] and consensus protocols [33, 128] can split trust across a few nodes (typically 3–10), but do not scale, as we confirm in Section VI. To our knowledge, CoSi is the first multisignature protocol that scales to thousands of signers.

CoSi’s scalability goal presents three key technical challenges: efficient cosignature collection, availability in the face of slow or offline witnesses, and efficient cosignature verification by clients. CoSi makes verification efficient by adapting well-understood Schnorr multisignatures [106] to combine many cosignatures into a single compact signature, typically less than 100 bytes in size, which clients can check in constant time. To collect and combine thousands of cosignatures efficiently, CoSi adapts tree-based techniques, long used in multicast [32, 42, 131] and aggregation protocols [30, 135], to scalable multisignatures. To protect the authority’s availability even when witnesses go offline, CoSi includes metadata in its collective signatures to document “missing witnesses” and enable verifiers to check the signature correctly against an aggregate of the remaining witnesses’ public keys.

We have built a working CoSi prototype, deployed a small-scale test configuration on the public Internet, and evaluated it at larger scales of up to 33,000 cosigning witnesses on the DeterLab [44] testbed. We find that CoSi can collect and aggregate cosignatures from 8,000 witnesses, separated by 200ms round-trip network delays to simulate distribution, in about 2 seconds total per signing round. CoSi’s performance contrasts favorably with multisignatures produced via classic verifiable secret sharing (VSS) [55, 125], whose signing costs explode beyond about 16 participants, as well as with straightforward collection of individual cosignatures, whose costs become prohibitive beyond around 256 participants.

In addition, we have integrated CoSi into and evaluated it in the context of two specific types of “authorities”: a secure time and timestamping service [2, 63, 121], and the Certificate Transparency log server [76]. The CoSi timestamping service illustrates how some authorities can be made even more scalable by building on CoSi’s communication trees, allowing witnesses to serve timestamp requests and reduce load on the main authority, thereby achieving aggregate throughput of over 120,000 timestamp requests per second in a 4,000-witness configuration. The CoSi extension to the CT log server demonstrates the ease and simplicity with which witness cosigning can be added to existing authority services, in this case requiring only a 315-line change to the log server to invoke CoSi when signing each new log entry.

In summary, this paper contributes:
- A proactive approach to transparency based on witness cosigning.
- CoSi, the first collective signing protocol that demonstrably scales to thousands of participants.
- An experimental implementation of CoSi that demonstrates its practicality and how it can be integrated into existing authority services.

Section II of this paper explores the background and motivation for witness cosigning. Section III then presents CoSi, a scalable collective signing protocol. Section IV outlines variants of the CoSi design offering different tradeoffs. Section V describes the details of our prototype implementation of CoSi and its incorporation into timestamping and certificate logging applications. Section VI experimentally evaluates this prototype, and Section VII discusses CoSi’s applicability to real-world applications and outlines future work. Section VIII summarizes related work, and Section IX concludes.

## 2. Background and Motivation
This section briefly reviews several types of conventional authorities, their weaknesses, and how witness cosigning can help strengthen them. We revisit prototype implementations of some of these applications later in Section V.

### 2.1. Certificate Authorities and Public-Key Infrastructure
Certiﬁcate Authorities (CAs) sign certiﬁcates attesting that a public key represents a name such as google.com, to authenticate SSL/TLS connections [45, 60]. Current web browsers directly trust dozens of root CAs and indirectly trust hundreds of intermediate CAs [50], any one of which can issue fake certiﬁcates for any domain if compromised. Due to this “weakest-link” security, hackers have stolen the “master keys” of CAs such as DigiNotar [8, 22] and Comodo [21] and abused certiﬁcate-issuance mechanisms [74, 75, 130] to impersonate popular websites and attack their users.

As a stopgap, some browsers hard-code or pin public keys for popular sites such as google.com [52]—but browsers cannot hard-code public keys for the whole Web. Related approaches offer TOFU (“trust on ﬁrst use”) security by pinning the ﬁrst public key a client sees for a particular site [39, 88, 122], thereby protecting regular users but not new users. Browsers can check server certiﬁcates against public logs [10, 68, 76, 78, 113, 126], which independent monitors may check for invalid certiﬁcates. Monitoring can unfortunately detect misbehavior only retroactively, placing victims in a race with the attacker. Browsers could check certiﬁcates against such logs and/or via multiple Internet paths [4, 11, 87, 134], but such checks delay the critical page-loading path, at least on the ﬁrst visit to a site. Further, these approaches assume Web users can connect to independent logging, monitoring, or relaying services without interference, an assumption that fails when the user’s own ISP is compromised. Such scenarios are unfortunately all too realistic and have already occurred, motivated by state-level repression [8, 22] or commercial interests [54, 65].

A CA might arrange for a group of witnesses to cosign certiﬁcates it issues: e.g., other willing CAs and/or independent organizations. Witness cosigning might not only proactively protect users and increase the CA’s perceived trustworthiness but also decrease the value of the CA’s secret keys to potential attackers by ensuring that any key misuse is likely to be detected quickly. In the longer term, CAs might witness cosign OCSP staples [107], or entire key directory snapshots as in CONIKS [89], enabling clients to check not only the validity but also the freshness of certiﬁcates and address persistent weaknesses in certiﬁcate revocation [82].

### 2.2. Tamper-Evident Logging Authorities
Many storage systems and other services rely on tamper-evident logging [38, 81]. Logging services are vulnerable to equivocation, where a malicious log server rewrites history or presents different “views of history” to different clients. Even if a logging authority itself is well-behaved, an attacker who obtains the log server’s secret keys can present false logs to targeted clients, effectively “equivocating in secret” without the knowledge of the log’s legitimate operator. For example, an attacker can defeat CT [76] and attack clients this way by secretly stealing the keys of—or coercing signatures from—any single CA plus any two CT log servers.

Solutions to equivocation attacks include weakening consistency guarantees as in SUNDR [81], or adding trusted hardware as in TrInc [80]. Equivocation is the fundamental reason Byzantine agreement in general requires \( N = 3f + 1 \) total nodes to tolerate \( f \) arbitrary failures [33]. Witness cosigning does not change this basic situation but can make it practical for both \( N \) and \( f \) to be large: e.g., with \( N > 3000 \) participants independently checking and cosigning each new log entry, arbitrarily colluding groups up to 1000 participants cannot successfully equivocate or rewrite history. As a proof-of-concept, Section V-B later presents such a witness cosigning extension for Certiﬁcate Transparency log servers.

### 2.3. Time and Timestamping Authorities
Time services such as NTP [95, 96] enable hosts to learn the current time and synchronize their clocks against authoritative sources such as NIST’s Internet Time Service [83]. Cryptographic authentication was a late addition to NTP [64] and is still in limited use, leading to many vulnerabilities [86].