title:Keeping Authorities "Honest or Bust" with Decentralized Witness Cosigning
author:Ewa Syta and
Iulia Tamas and
Dylan Visher and
David Isaac Wolinsky and
Philipp Jovanovic and
Linus Gasser and
Nicolas Gailly and
Ismail Khoffi and
Bryan Ford
2016 IEEE Symposium on Security and Privacy
2016 IEEE Symposium on Security and Privacy
Keeping Authorities “Honest or Bust”
with Decentralized Witness Cosigning
Ewa Syta, Iulia Tamas,
Dylan Visher, David Isaac Wolinsky
Yale University
New Haven, CT, USA
Philipp Jovanovic, Linus Gasser,
Nicolas Gailly, Ismail Khofﬁ, Bryan Ford
Swiss Federal Institute of Technology (EPFL)
Lausanne, Switzerland
Abstract—The secret keys of critical network authorities –
such as time, name, certiﬁcate, and software update services
– represent high-value targets for hackers, criminals, and spy
agencies wishing to use these keys secretly to compromise other
hosts. To protect authorities and their clients proactively from
undetected exploits and misuse, we introduce CoSi, a scalable
witness cosigning protocol ensuring that every authoritative
statement is validated and publicly logged by a diverse group
of witnesses before any client will accept it. A statement S
collectively signed by W witnesses assures clients that S has
been seen, and not immediately found erroneous, by those W
observers. Even if S is compromised in a fashion not readily
detectable by the witnesses, CoSi still guarantees S’s exposure
to public scrutiny, forcing secrecy-minded attackers to risk that
the compromise will soon be detected by one of the W witnesses.
Because clients can verify collective signatures efﬁciently without
communication, CoSi protects clients’ privacy, and offers the
ﬁrst transparency mechanism effective against persistent man-in-
the-middle attackers who control a victim’s Internet access, the
authority’s secret key, and several witnesses’ secret keys. CoSi
builds on existing cryptographic multisignature methods, scaling
them to support thousands of witnesses via signature aggrega-
tion over efﬁcient communication trees. A working prototype
demonstrates CoSi in the context of timestamping and logging
authorities, enabling groups of over 8,000 distributed witnesses
to cosign authoritative statements in under two seconds.
I. INTRODUCTION
Centralized authorities provide critical services that many
hosts and users rely on, such as time [96] and timestamp
services [2], certiﬁcate authorities (CAs) [35], directory au-
thorities [47], [119], software update services [116], digital
notaries [3], and randomness services [103], [110]. Even when
cryptographically authenticated, authorities represent central
points of failure and attractive attack targets for hackers,
criminals, and spy agencies. Attackers obtaining the secret
keys of any of hundreds of CAs [50] can and have misused
CA authority to impersonate web sites and spy on users [8],
[21], [22], [130]. By impersonating a time service an attacker
can trick clients into accepting expired certiﬁcates or other
stale credentials [86]. Criminals increasingly use stolen code-
signing keys to make their malware appear trustworthy [66].
such as Perspec-
tives [134], CT [76], [78], AKI [68], ARPKI [10], and
PoliCert [126] enable clients to cross-check certiﬁcates against
public logs, but this checking requires active communication.
To avoid delaying web page loads this checking is usually done
Logging and monitoring proposals
only retroactively, leaving a time window an attacker could
exploit to serve the client malware or backdoored software,
which can then disable detection. An attacker who controls
the client’s access network – such as a compromised home or
corporate network, or an ISP controlled by authoritarian state
– can block access to uncompromised log servers, permanently
evading detection if the targeted client
is not sufﬁciently
mobile. Finally, checking logs can create privacy concerns for
clients [89], [104], and the log servers themselves become new
central points of failure that must be audited [104].
To address these weaknesses we propose witness cosigning,
a proactive approach to transparency that can either replace or
complement existing approaches. When an authority publishes
a new signing key, to be bundled in a web browser’s set of
root certiﬁcates for example, the authority includes with it
the identities and public keys of a preferably large, diverse,
and decentralized group of independent witnesses. Whenever
the authority subsequently signs a new authoritative statement
such as a new timestamp, certiﬁcate, or log record,
the
authority ﬁrst sends the proposed statement to its witnesses
and collects cosignatures, which the authority attaches to the
statement together with its own signature. A client receiving
the statement (e.g., as a TLS certiﬁcate) veriﬁes that it has
been signed not only by the authority itself but also by an
appropriate subset of the witnesses. The client’s signature
acceptance criteria may be a simple numeric threshold (e.g.,
50% of the witnesses) or a more complex predicate accounting
for trust weights, groupings of witnesses, or even contextual
information such as whether a signed software update is to be
installed automatically or by the user’s explicit request.
Witness cosigning offers clients direct cryptographic evi-
dence – which the client can check efﬁciently without commu-
nication – that many independent parties have had the oppor-
tunity to validate and publicly log any authoritative statement
before the client accepts it. Without witness cosigning, an
attacker who knows the authority’s secret key can use it in
man-in-the-middle (MITM) attacks against targeted victims,
anywhere in the world and without the knowledge of the
legitimate authority,
to feed the victim faked authoritative
statements such as TLS certiﬁcates or software updates [114].
To attack a client who demands that statements be cosigned by
at least W witnesses, however, a MITM attacker must either
(a) control both the authority’s secret key and those of W
2375-1207/16 $31.00 © 2016 IEEE
© 2016, Ewa Syta. Under license to IEEE.
DOI 10.1109/SP.2016.38
DOI 10.1109/SP.2016.38
526
526
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:12:54 UTC from IEEE Xplore.  Restrictions apply. 
witnesses, which becomes implausible if W is sufﬁciently
large and diverse, or (b) submit the faked statement to one
or more honest witnesses for cosigning, thereby exposing the
faked statement to public scrutiny and risking detection.
We do not expect witnesses to detect all malicious state-
ments immediately: for example, only a CA itself may have the
information needed to verify the true correspondence between
a name and a public key. Witnesses can, however, sanity-check
the correctness and consistency of proposed statements before
cosigning: e.g., that authoritative timestamps are not wildly
different from the witnesses’ view of the present time, that
logging authorities sign records in sequence without revising
history or equivocating [80], or that only one authoritative
binary image exists for a given software version number. Even
if witnesses cannot immediately tell which of two conﬂicting
TLS certiﬁcates or binaries is “good,” they can ensure that
the existence of the conﬂicting signed statements promptly
becomes public knowledge. Witnesses can proactively check
that statements conform to known policies, such as certiﬁcate
issuance policies [126], raising alarms and withholding their
cosignature if not. Finally, witnesses can of course publish
logs of statements they cosigned to increase the likelihood of
rapid attack detection [76].
Even if witnesses perform little or no validation of the
authority’s statements, their proactive presence in statement
signing deters attackers both by increasing the threat to the
attacker of rapid misuse detection, and by reducing the effec-
tive value of an authority’s secret keys to attackers wishing to
operate in secret. Witness cosigning thus serves as a “Ulysses
pact” between the authority and its witnesses [48].
Authorities could implement witness cosigning simply by
collecting and concatenating individual signatures from wit-
nesses, exactly like PGP [28] or Bitcoin [102] can already
attach multiple signatures to a message or transaction. This is
practical with tens or perhaps even a few hundred witnesses,
but incurs substantial signature size and veriﬁcation costs as
the witness group grows large. To make witness cosigning
scalable we introduce CoSi, a witness cosigning protocol
enabling authoritative statements to be validated and cosigned
by thousands of witnesses in a few seconds,
to produce
collective signatures comparable in size to a single individual
signature (e.g., ≈ 100 bytes total) and nearly as quick and
easy for clients to verify.
As a scenario motivating CoSi’s scalability goal, we envi-
sion the DNSSEC [6] root zone might be witnessed by all
willing operators of the now over 1,000 top-level domains
(TLDs). Future TLS certiﬁcates might be witnessed by all
other willing CAs, of which there are hundreds [50], and
by other parties such as CT servers [76]. Public ledgers of
national cryptocurrencies [101], [123] might be collectively
witnessed by all willing banks in the country – of which the
US has thousands even after consolidation [129]. Threshold
signatures [12], [93] and consensus protocols [33], [128] can
split trust across a few nodes (typically 3–10), but do not scale,
as we conﬁrm in Section VI. To our knowledge CoSi is the
ﬁrst multisignature protocol that scales to thousands of signers.
CoSi’s scalability goal presents three key technical chal-
lenges: efﬁcient cosignature collection, availability in the
face of slow or ofﬂine witnesses, and efﬁcient cosignature
veriﬁcation by clients. CoSi makes veriﬁcation efﬁcient by
adapting well-understood Schnorr multisignatures [106] to
combine many cosignatures into a single compact signature,
typically less than 100 bytes in size, which clients can check
in constant time. To collect and combine thousands of cosigna-
tures efﬁciently, CoSi adapts tree-based techniques, long used
in multicast [32], [42], [131], and aggregation protocols [30],
[135] to scalable multisignatures. To protect the authority’s
availability even when witnesses go ofﬂine, CoSi includes
metadata in its collective signatures to document “missing
witnesses” and enable veriﬁers to check the signature correctly
against an aggregate of the remaining witnesses’ public keys.
We have built a working CoSi prototype, deployed a small-
scale test conﬁguration on the public Internet, and evaluated it
at larger scales of up to 33,000 cosigning witnesses on the
DeterLab [44] testbed. We ﬁnd that CoSi can collect and
aggregate cosignatures from 8,000 witnesses, separated by
200ms round-trip network delays to simulate distribution, in
about 2 seconds total per signing round. CoSi’s performance
contrasts favorably with multisignatures produced via classic
veriﬁable secret sharing (VSS) [55], [125], whose signing
costs explode beyond about 16 participants, as well as with
straightforward collection of individual cosignatures, whose
costs become prohibitive beyond around 256 participants.
In addition, we have integrated CoSi into and evaluated it in
the context of two speciﬁc types of “authorities”: a secure time
and timestamping service [2], [63], [121], and the Certiﬁcate
Transparency log server [76]. The CoSi timestamping service
illustrates how some authorities can be made even more
scalable by building on CoSi’s communication trees, allowing
witnesses to serve timestamp requests and reduce load on
the main authority, thereby achieving aggregate throughput
of over 120,000 timestamp requests per second in a 4,000-
witness conﬁguration. The CoSi extension to the CT log
server demonstrates the ease and simplicity with which witness
cosigning can be added to existing authority services, in this
case requiring only an 315-line change to the log server to
invoke CoSi when signing each new log entry.
In summary, this paper contributes: (a) a proactive approach
to transparency based on witness cosigning; (b) CoSi, the
ﬁrst collective signing protocol that demonstrably scales to
thousands of participants; (c) an experimental implementation
of CoSi that demonstrates its practicality and how it can be
integrated into existing authority services.
Section II of this paper explores the background and moti-
vation for witness cosigning. Section III then presents CoSi,
a scalable collective signing protocol. Section IV outlines
variants of the CoSi design offering different tradeoffs. Sec-
tion V describes the details of our prototype implementation
of CoSi and its incorporation into timestamping and certiﬁcate
logging applications. Section VI experimentally evaluates this
prototype, and Section VII discusses CoSi’s applicability to
527527
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:12:54 UTC from IEEE Xplore.  Restrictions apply. 
real-world applications and outlines future work. Section VIII
summarizes related work and Section IX concludes.
II. BACKGROUND AND MOTIVATION
This section brieﬂy reviews several types of conventional
authorities, their weaknesses, and how witness cosigning can
help strengthen them. We revisit prototype implementations of
some of these applications later in Section V.
A. Certiﬁcate Authorities and Public-Key Infrastructure
Certiﬁcate Authorities (CAs) sign certiﬁcates attesting that
a public key represents a name such as google.com, to
authenticate SSL/TLS connections [45], [60]. Current web
browsers directly trust dozens of root CAs and indirectly trust
hundreds of intermediate CAs [50], any one of which can
issue fake certiﬁcates for any domain if compromised. Due
to this “weakest-link” security, hackers have stolen the “master
keys” of CAs such as DigiNotar [8], [22] and Comodo [21]
and abused certiﬁcate-issuance mechanisms [74], [75], [130]
to impersonate popular websites and attack their users.
As a stopgap, some browsers hard-code or pin public keys
for popular sites such as google.com [52] – but browsers
cannot hard-code public keys for the whole Web. Related ap-
proaches offer TOFU (“trust on ﬁrst use”) security by pinning
the ﬁrst public key a client sees for a particular site [39],
[88], [122], thereby protecting regular users but not new users.
Browsers can check server certiﬁcates against public logs [10],
[68], [76], [78], [113], [126], which independent monitors may
check for invalid certiﬁcates. Monitoring can unfortunately
detect misbehavior only retroactively, placing victims in a race
with the attacker. Browsers could check certiﬁcates against
such logs and/or via multiple Internet paths [4], [11], [87],
[134], but such checks delay the critical page-loading path,
at least on the ﬁrst visit to a site. Further, these approaches
assume Web users can connect to independent logging, moni-
toring, or relaying services without interference, an assumption
that fails when the user’s own ISP is compromised. Such
scenarios are unfortunately all too realistic and have already
occurred, motivated by state-level repression [8], [22] or
commercial interests [54], [65].
A CA might arrange for a group of witnesses to cosign
certiﬁcates it issues: e.g., other willing CAs and/or independent
organizations. Witness cosigning might not only proactively
protect users and increase the CA’s perceived trustworthiness,
but also decrease the value of the CA’s secret keys to potential
attackers by ensuring that any key misuse is likely to be
detected quickly. In the longer term, CAs might witness cosign
OCSP staples [107], or entire key directory snapshots as in
CONIKS [89], enabling clients to check not only the validity
but also the freshness of certiﬁcates and address persistent
weaknesses in certiﬁcate revocation [82].
B. Tamper-Evident Logging Authorities
Many storage systems and other services rely on tamper-
evident logging [38], [81]. Logging services are vulnerable to
equivocation, however, where a malicious log server rewrites
history or presents different “views of history” to different
clients. Even if a logging authority itself is well-behaved, an
attacker who obtains the log server’s secret keys can present
false logs to targeted clients, effectively “equivocating in
secret” without the knowledge of the log’s legitimate operator.
For example, an attacker can defeat CT [76] and attack
clients this way by secretly stealing the keys of – or coercing
signatures from – any single CA plus any two CT log servers.
Solutions to equivocation attacks include weakening consis-
tency guarantees as in SUNDR [81], or adding trusted hard-
ware as in TrInc [80]. Equivocation is the fundamental reason
Byzantine agreement in general requires N = 3f + 1 total
nodes to tolerate f arbitrary failures [33]. Witness cosigning
does not change this basic situation, but can make it practical
for both N and f to be large: e.g., with N > 3000 participants
independently checking and cosigning each new log entry,
arbitrarily colluding groups up to 1000 participants cannot
successfully equivocate or rewrite history. As a proof-of-
concept, Section V-B later presents such a witness cosigning
extension for Certiﬁcate Transparency log servers.
C. Time and Timestamping Authorities
Time services such as NTP [95], [96] enable hosts to learn
the current time and synchronize their clocks against author-
itative sources such as NIST’s Internet Time Service [83].
Cryptographic authentication was a late addition to NTP [64]
and is still in limited use, leading to many vulnerabilities [86].