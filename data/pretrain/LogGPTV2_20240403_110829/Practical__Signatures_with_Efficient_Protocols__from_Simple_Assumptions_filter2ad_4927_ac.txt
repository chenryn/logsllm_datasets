1. ( ˆD1/ˆg(cid:96)+2) ρ · ˆE1 = ˆg ¯m1
( ˆD2/ˆg2(cid:96)+3) ρ · ˆE2 = ˆg ¯m1
(cid:96)+3 ··· ˆg ¯m(cid:96)
· ˆDw3
· ˆDw2
0 · ˆE0 = ˆgwz
2. ˆD ρ
· gw4 .
C ¯r1
2
i · Vi = gwi f zi for each i ∈ {0, 2, 3, 4} and
··· ˆg ¯m(cid:96)
2(cid:96)+2 · g ¯r2 ;
· ˆg−w0 and C ρ
· C ¯r2
· ˆgw1
3. T ρ
3
1
z
1
2
and
0 · F0 =
(T0/T4)ρ · S0 = T ¯r1
2
· T ¯r2
3 .
(6)
Then, return 1 if and only if
e(C0, ˆg) · e(g, ˆD0) · e(Ω, ˆg2(cid:96)+4)
(7)
= e(C1, ˆg1) · e(C2, ˆD1) · e(C3, ˆD2) · e(Cz, ˆgz).
−1
It is worth noticing that no pairing evaluation is required
until the ﬁnal step of Verify, which is almost as eﬃcient
as the veriﬁcation of underlying signatures. Moreover,
the prover’s ﬁrst message com is of constant-size and the
communication complexity of the protocol exceeds the
length of the witness by a constant additive overhead.
Theorem 2. The above interactive scheme is a secure
Σ protocol for the language Lsig induced by the relation
Rsig(pk, ((cid:126)σ, (cid:126)m)) = 1 if and only if Verify(cid:48)(pk, (cid:126)σ, (cid:126)m) = 1,
where (KeyGen, Sign, Verify(cid:48)) is the signature of Section 3.
Proof. Correctness. Expanding an honestly gener-
2 · ˆg−t0 in equation (7) and
ated ˆD0 = ˆgtz
regrouping the pairing factors gives
1 · ˆDt2
1 · ˆDt3
z · ˆgt1
e(C0 · g
−t0 , ˆg) · e(Ω, ˆg2(cid:96)+4)
= e(C1 · g
−1
−t1 , ˆg1) · e(C2 · g
· e(C3 · g
−t2 , ˆD1)
−t3 , ˆD2) · e(Cz · g
−tz , ˆgz).
Now, expanding the commitments to group elements in
G reduces this equation to
e(σr1
3 , ˆg) · e(Ω, ˆg2(cid:96)+4)
2 · σr2
= e(σ1, ˆg1) · e(σ2, ˆD1) · e(σ3, ˆD2) · e(π, ˆgz)
−1
which holds true for valid witnesses when ˆD1 = d1 · ˆgr1
and ˆD2 = d2 · ˆgr2 . Remaining veriﬁcations of items 1,2,3
follow from the correctness of the built-in Σ protocols.
z ·ˆgt1
1 · ˆDt3
1 · ˆDt2
3 · gt4 .
Special-Soundness. Let us assume two accepting tran-
scripts (com, ρ, resp), (com, ρ(cid:48), resp(cid:48)) with ρ (cid:54)= ρ(cid:48). The
special soundness of the sub-protocols involving ˆD1, ˆD2
(with ˆE1, ˆE2) – consisting of steps 1 and 2 of Com-
mit and step 1 of Verify – ensures the extraction of
m1, . . . , m(cid:96), r1, r2 satisfying ˆD1 = d1 · ˆgr1 , where d1 =
··· ˆgm(cid:96)
(cid:96)+1 · ˆg(cid:96)+2, and ˆD2 = d2 · ˆgr2 , where d2 =
ˆgm1
2
(cid:96)+3 ··· ˆgm(cid:96)
2(cid:96)+2 · ˆg2(cid:96)+3. From step 2 of Verify, a similar
ˆgm1
argument on ˆD0 (with ˆE0) implies the extractability of
2 ·ˆg−t0 .
(tz, t0, t1, t2, t3, t4) such that ˆD0 = ˆgtz
Moreover, together with previously extracted (r1, r2),
step 2 of Verify also guarantees that t4 satisﬁes C0 =
2 · C r2
C r1
We now state that quantities {σi = Ci · g−ti}i∈{1,2,3}
and π = Cz · g−tz satisfy (3), so that, together with
(cid:126)m = (m1, . . . , m(cid:96)), they form a valid witness for Rsig.
Namely, (σ, (cid:126)m) = ((σ1, σ2, σ3, π), (m1, . . . , m(cid:96))) is a valid
message-signature pair.
To see this, deﬁne σ0 = C0 · g−t0 . Since equation (7)
holds by hypothesis, if we expand all commitments using
extracted values, we ﬁnd
−1
e(σ0, ˆg) · e(Ω, ˆg2(cid:96)+4)
= e(σ1, ˆg1) · e(σ2, d1 · ˆgr1 ) · e(σ3, d2 · ˆgr2 ) · e(π, ˆgz).
· σr2
We are thus left with showing that σ0 = σr1
or, equivalently, e(σ0, ˆg) = e(σ2, ˆgr1 ) · e(σ3, ˆgr2 ). Re-
2
member that, from step 2 of Verify, we know that ex-
tracted (r1, r2, t4) ∈ Z3
p form a representation of C0
· gt4 ,
w.r.t.
the base (C0, C2, g):
which, from the deﬁnition of σ0, σ2, σ3, yields σ0 · gt0 =
3 · gt2·r1+t3·r2+t4 . Hence, we are done if we can
2 · σr2
σr1
show that t0 = t2r1 + t3r2 + t4. But this exactly what
step 3 of Verify and the special soundness of the sub-
protocol involving (T0, T2, T3, T4) tells us. First, we have
a representation of these Ti’s w.r.t. the basis (g, f ) ∈ G2
which guarantees that we are working on the already ex-
tracted (t0, t2, t3, t4) involved in the expressions of ˆD0
and C0. Second, the veriﬁcation equation (6) ensures
· T4 and the ﬁnal result follows by
that T0 = T r1
2
replacing them by their representation.
i.e., C0 = C r1
2
· C r2
· T r2
3
3
3
Perfect SHVZK. To show this property we must build a
simulator that, on input of a challenge chall = ρ ∈R Zp,
emulates a valid transcript without any witness. First,
we need to compute a random tuple Cz,{Ci}3
constrained to satisfy the veriﬁcation equation (7).
i=0,{ ˆD}2
i=0
ˆDa2
From the identity e(Ω, ˆg2(cid:96)+4)−1 = e(Ω−1, ˆg2(cid:96)+4) we
ﬁrst pick a0, a1, a2, az ← Zp, ˆD1 ← ˆG and we have
z ) · e(Ωa0 , ˆg) ·
e(Ω, ˆg2(cid:96)+4)−1 = e(Ω−1, ˆg2(cid:96)+4 · ˆga0 ˆga1
e(Ωa1 , ˆg1) · e(Ωa2 , ˆD1) · e(Ωaz , ˆgz), so that we can set
C0 = Ω−a0 , C1 = Ωa1 , C2 = Ωa2 and Cz = Ωaz . Let
ˆB := ˆg2(cid:96)+4 · ˆga0 ˆga1
z . Now, we can introduce the
constant g ∈ G in the equation by picking ag ← Zp since
e(Ω−1, ˆB) = e(Ω−1·gag , ˆB)·e(g, ˆB−ag ). Then, we ﬁnally
set ˆD0 = ˆBag , ˆD2 = ˆBa3 and C3 = (Ω−1 · gag )1/a3 for a
random a3 ← Zp.
1 ˆgaz
1 ˆgaz
ˆDa2
1
1
To complete the simulated transcript, we run a paral-
lel execution of the simulators of all Σ protocols used
as subroutines. More explicitly, ﬁrst pick ρ R← Zp
R← Zp.
and ¯m1, . . . , ¯m(cid:96), ¯r1, ¯r2, wz, w0, . . . , w4, z0, z2, z3, z4
Also, choose T0, T2, T3, T4
R← G and do the following:
2
1. Compute ˆE1 = ( ˆD1/ˆg(cid:96)+2) −ρ· ˆg ¯m1
similarly, ˆE2 = ( ˆD2/ˆg2(cid:96)+3) −ρ · ˆg ¯m1
· C ¯r2
··· ˆg ¯m(cid:96)
(cid:96)+3 ··· ˆg ¯m(cid:96)
(cid:96)+1·g ¯r1 and,
2(cid:96)+2 · g ¯r2 ;
· gw4 as well as
· C ¯r1
−ρ
2. Compute F0 = C
0
· ˆDw2
· ˆgw1
1
· gvi f zi , for each i ∈ {0, 2, 3, 4},
−ρ
3. Compute Vi = T
i
· ˆg−w0 ;
0 · ˆgwz
ˆE0 = ˆD ρ
· ˆDw3
2
3
1
2
z
and S0 = (T0/T4)−ρ · T ¯r1
2
· T ¯r2
3 .
This concludes the proof.
4.3 Signing a Committed Message
(cid:96)
1
··· vm(cid:96)
At a high level, the protocol involves a committer who
wants to get a signature on m = (m1, . . . , m(cid:96)) and ﬁrst
·ur,
computes a commitment of the form cv = vm1
where u is the extra public parameter (with unknown
discrete log). The signer gives back elements of the form
τ1 = gωcs
v, τ2 = gs, τ3 = hs which is almost the desired
signature. To get the component σ1 of the right form
relatively to τ2, τ3 the committer has to remove the factor
urs from τ1. Then, the signer also sends τ0 = us to enable
removing τ r
0 . In the protocol some randomizing steps are
included as well as other additional components allowing
the committer to extract π, the QA-NIZK part of the
signature. In the security proof of the protocol we thus
have to show that the additional value τ0 = us does not
aﬀect the unforgeability of the signature.
The protocol. At the beginning of a new run of the
protocol, the committer has a vector m = (m1, . . . , m(cid:96)),
the public-key of the signature scheme and the extra
generator u ∈ G (which can be a hashed point), the
signer also has the secret key of the signature scheme
but not m. To get a signature on m, the committer
picks r R← Zp and computes a perfectly hiding commit-
·ur ∈ G. Besides, it also computes
··· vm(cid:96)
ment cv = vm1
(cid:96)+1 · utz . The signer receives
··· zm(cid:96)
the elements cz = zm1
these commitments and they both engage in an inter-
active proof of knowledge of an equal representation of
cv relatively to the basis (v1, . . . , v(cid:96); u) and cz relatively
to the basis (z2, . . . , z(cid:96)+1; u), where the signer plays the
role of the veriﬁer. Depending on the success of the proof
the signer computes what we can call a “pre-signature”
consisting of the following group elements
1
2
(cid:96)
τ1 = gω · (cv · w)s,
τ2 = gs,
τ3 = hs,
τ0 = us,
π0 = zω
1 · cs
z · zs
(cid:96)+2,
for a random s R← Zp.
In the ﬁnal step, the user re-
ceived the pre-signature, then picks s(cid:48) R← Zp and com-
putes (σ1, σ2, σ3, π) ∈ G4 as follows
· w)s(cid:48)
σ1 = τ1 · τ
(cid:96)+1 · z(cid:96)+2)s(cid:48)
π = π0 · τ
σ2 = τ2 · gs(cid:48)
, σ3 = τ3 · hs(cid:48)
··· vm(cid:96)
··· zm(cid:96)
· (vm1
· (zm1
−r
0
−tz
0
,
,
.
1
2
(cid:96)
Finally the user checks the validity of the signature. De-
pending on the validity, the user outputs the signature
or a failure symbol ⊥.
We notice that the number of transmitted group ele-
ments is constant and no pairing is needed before the
signature veriﬁcation phase.
In comparison, the con-
struction of [18] requires groups of larger hidden order
and their protocol for signing committed message blocks
requires a linear number of range proofs.
Security. We brieﬂy sketch the proof of the above proto-
col in front of malicious entities since classical arguments
can be applied. Assuming that the committer uses se-
cure ZKPK and does not output ⊥, a malicious signer
which receives perfectly hiding commitments cv, cz can-
not tell apart an honest proof from a simulated proof.
Consequently the signer learns nothing from m during
the execution of the protocol. In the other case, we have
to show that a corrupted committer remains unable to
produce valid signature on a new vector m(cid:63). First, since
the generation of u is not under the controlled of the
committer but of the random oracle, u can be made in-
dependent of rest of pk. Then, we only need to show
that the signature remains unforgeable when τ0 is given
in the signature. Since m and s can be extracted from
the proof of knowledge the reduction can output a signa-
ture on m. Moreover it is easy to see from the security
proof (in Appendix A) of the signature how this addi-
tional element can be simulated. Actually the only place
in the reduction where τ0 could not be computed directly
as us for a known s is when the challenger B has to em-
bed an SXDH challenge in a simulated signature. Given
(g, h, gb, hb+c), B can compute u = gau hbu from ran-
dom au, bu ← Zp and program the random oracle to out-
put this element u as the speciﬁcation of the public-key
would do. Then to simulate τ0 B simply has to compute
τ0 = (gb)au (hb+c)bv = ubhc·bv which is ub or random.
The rest of the reduction remains unchanged since the
value au, bu are completely independent of those already
described in the sketch of proof in Appendix A.
Remark. Since a malicious signer may know the sim-