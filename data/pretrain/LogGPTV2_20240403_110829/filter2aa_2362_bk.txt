excessive CPU load during processing, followed by memory exhaustion and concur-
rency issues.
The storms are designed to load the target protocol as heavily as possible while
minimizing interaction at high protocol layers. The traffic generated by each type
of storm has a structurally correct header for the protocol being tested with a ran-
dom payload meant to be caught by error-checking code at the next protocol level
up. This allows us to measure differences in behavior between protocols (Ethernet
vs. IP, IP vs. TCP, etc.) that may be exploitable. For example, in some devices
tested, there was a greater overhead incurred processing Ethernet headers with ran-
dom payloads than when processing IP headers with random payloads. Different
delivery mechanisms such as broadcast and multicast have also exhibited similar
unexpected behavior during storm tests, inciting the creation of broadcast/multi-
cast storm variants.
The ability to stress the communication process to various levels allows us to
measure how the device responds to hostile networking conditions. Most equip-
ment tested has had a design goal that inputs cannot impact the controller’s ability
to maintain its I/O functions according to some well-defined policy (no affect at all,
entering a fail-safe mode, etc.). Noting that different kinds of protocols affect CPU
and memory load differently, we are able to measure discrepancies between the
desired I/O policy and the actual behavior. Many SCADA networks are designed
for a maximum data rate of about 500 to 1,000 packets per second, which makes
simple load-based DoS attacks very feasible.
9.6
Black-Box Fuzzing for Security Researchers
Finally, we conclude this book with an example of auditing a black-box applica-
tion. This may occur as part of a formal audit at the end of the software develop-
ment cycle, as an engagement by a security consultant, or by a security researcher
9.6
Black-Box Fuzzing for Security Researchers
267
looking at a released product. In the first two cases, it is obvious which system is the
target. In the latter case, there is much discretion in choosing the target.
9.6.1
Select Target
For software developers and testers, there is usually not a chance to choose the tar-
get. You must simply test the system you are developing. Likewise, security auditors
are required to test the system given to them for review. The only exception is when
there are a number of systems that need testing, and it becomes important to pick
which one should be tested first or which one requires the most time for examining.
In this case, such a decision needs to be based on factors such as risk, whether some
applications are more exposed than others and how well each product was devel-
oped, for example.
For the security researcher, target selection is very important. If you choose a
target that is very secure and well written, say Apache, it is likely you won’t find
any bugs. If you choose a product that is too obscure, like Tom’s Mail Server, no
one will care if you find any bugs. It’s best to choose something in between. Other
good strategies include choosing products that have not been fuzzed or those with
a recent track record of problems. Examples of the former include SNMP imple-
mentations in 2002 and web browsers in 2006.18,19 We choose the latter path and
examine Apple’s QuickTime media player due to its history of vulnerabilities. In
fact, in 2007, there were over 34 security holes in this product alone.20
9.6.2
Enumerate Interfaces
Normally, when a system is about to be fuzzed, it is important to determine all the
ways data can be passed to the target. For local applications, this might include
command line arguments, environment variables and files consumed, for example.
For network devices, this might vary from low level packets such as Ethernet pack-
ets, up to the TCP/IP stack, and then any administrative applications such as web
servers on the device. It is important to identify all possible protocols/formats that
the system understands. This might be network protocols or file formats. For exam-
ple, a web browser can speak many different protocols including HTTP, FTP,
HTTPS, RTSP, and so on, as well as parse many different image formats.
In our target of QuickTime, we need to know which formats QuickTime sup-
ports. The Apple website lists many formats supported by QuickTime. However, it
is often best to ignore such documentation and go straight to the source. There is a
program for Mac OS X called RCDefaultApp that specifies which formats are asso-
ciated with which applications.21 Using this application, a wide variety of formats
are found, including
268
Fuzzing Case Studies
18http://xforce.iss.net/xforce/alerts/id/advise110
19www.news.com/Security-expert-dubs-July-the-Month-of-browser-bugs/2100-1002_3-6090959
.html
20www.securityfocus.com/brief/645
21http://rubicode.com/Software/RCDefaultApp
• 3g2;
• aac;
• amc;
• avi;
• caf;
• rtsp.
QuickTime Player supports almost 50 different file extensions. This is one rea-
son it has had so many bugs—it has a very large feature set. At this point it is just
a matter of choosing a protocol and beginning to fuzz. For this fuzzing session, we
chose the Audio Video Interleave (AVI) format.
9.6.3
Choose Fuzzer/Fuzzer Type
Choosing the fuzzer and fuzzer type is sometimes a difficult decision. It usually boils
down to how badly you want to find bugs versus how much time, energy, and/or
money you wish to spend. As we demonstrated in the last chapter, the most effec-
tive method for finding bugs is probably to use a combination of different fuzzers.
However, in real life, this is not always feasible. Normally, product shipment dead-
lines and other projects force us to choose one fuzzer and may even limit the
amount of time fuzzing can be performed with the single fuzzer.
For this case study, like most security researchers, we have no budget, so commer-
cial tools are out of the question. Therefore, our choice is between an open-source
mutation-based or generational-based fuzzer. We don’t have a lot of time, and as we’ll
see, attacking QuickTime Player with a generational-based fuzzer is a little like attack-
ing an ant with a sledgehammer, so we’ll go with the easier mutation-based approach.
We could use something like FileFuzz or the PaiMei file fuzzer, but we choose to rein-
vent the wheel. The following simple C program is used for our fuzzing.22
#include 
#include 
#include 
#define NUM_FILES 8192
#define SIZE 6250577
int main(void)
{
FILE *in, *out, *lout;
unsigned int n, i, j;
char *buf = malloc(SIZE);
char *backup = malloc(SIZE);
char outfile[1024];
9.6
Black-Box Fuzzing for Security Researchers
269
22Thanks to Josh Mason for writing this simple, but very effective fuzzer.
int rn, rn2, rn3, rn4;
int rbyte;
int numwrites;
in = fopen(“good.avi”, “r”);
n = read(fileno(in), buf, SIZE);
memcpy(backup, buf, n);
lout=fopen(“list”, “w”);
srand(time(NULL));
for (i=0;i:
movzx
eax,BYTE PTR [edx]
Closer inspection shows this is within a loop, and eventually edx goes beyond
mapped memory. It appears to be an overflow in the source buffer of a copy. It is
unclear whether this condition is exploitable without more investigation. This bug
has been reported to Apple but has not been fixed as of the time of this writing. Are
there other bugs in QuickTime Player? Probably. Does Apple use fuzzing as part of
its SDLC? Probably not in QuickTime.
9.7
Summary
To conclude the book, in this chapter we went through different use cases with
fuzzing. The purpose of this chapter was not to give a thorough walk-through of
fuzzing in any of these use cases, but to enable you to see the technique in use in dif-
ferent environments.
Deployment of fuzzing is often technology oriented. We do not want to downplay
that approach, because we definitely know that fuzzing is cool and exciting. If you get
your hands on a fuzzing framework such as a Sulley or GPF, you will definitely have
fun for months and months. The outcome is not necessarily what you might have
hoped for, though. You might catch a flaw here and another there, but what about
the bugs you left behind? The deployment of fuzzing should start from real need.
In any enterprise space, your CIO will most probably have regular nightmares
on some peculiar threat-scenarios that you could go and eliminate with fuzzing. An
enterprise network is loaded with various network applications and services that
are open to the hostile Internet, and all of those are good targets for fuzzing. Any
CIO will immediately understand the value of proactive fuzzing and most often
would look forward to outsourcing fuzzing to a consultant who has experience in
the field.
Fuzzing in the carrier and ISP space is a bit different. Whereas in the enterprise
environment you very rarely have the luxury of dedicated test networks, the serv-
ice providers are well prepared to schedule test-time for fuzzing. Also, because the
worst attack to a service provider is a Denial of Service, you will not have to waste
weeks and weeks explaining what a buffer overflow is. They do not care. Actually,
an attack with a malicious payload would just downplay the vulnerability, as
down-time is much more expensive for them.
Software developers are the most challenging users of fuzzing. The QA people
will only very slowly change their mentality from feature testing into seemingly ad-
lib negative testing, for which you could classify fuzzing. But, slowly, all the major
software-developing companies have seen the light, and hopefully smaller organiza-
tions will follow behind. Acquisitions of some selected web fuzzer companies by
both HP and IBM in 2007 could show that at least the web fuzzing market is
becoming more mature.
Network manufacturers, on the other hand, are driven by requirements set by
the service providers and have been quick to react to fuzzing needs. Again, the
9.7
Summary
273
fuzzing deployment has started from the biggest players in the market, all of which
do fuzzing of some sort. Security product vendors have also been quick to follow,
and the development of most security devices already utilizes fuzzing quite early in
the development process.
Next, we discussed fuzzing with SCADA fuzzing. Industrial automation is just
one of the examples of how software has penetrated the national critical infrastruc-
ture, and fuzzing in that space can really be a life saver. Next time when you read
an article about a power blackout, think about SCADA fuzzing for a second. The
same fuzzing concepts that are used in the industry data busses apply for any tradi-
tional industries such as the automobile or airline industries.
Finally, we took a look at fuzzing from the security researcher’s perspective.
This approach is different from the other ones because it is conducted in a black-
box setting since the source code is not available. We stepped though an entire
fuzzing session from target selection through reporting the vulnerabilities. It
showed very plainly just how effective even simple mutation-based fuzzing can be.
When we were finalizing this book in January 2008, fuzzers were still quite
early in the market. But already then/today you can hear the end users of software
screaming “Enough is enough!” Without fuzzing, we will forever stay in the hamster-
wheel of patch-and-penetrate, reading about the latest vulnerabilities and crashing
electric systems in the headlines of our morning papers. With that thought, please
keep an open mind and review your own work and the work of your colleagues
and see where fuzzing fits for you and your organization. Please do not hesitate to
e-mail us your stories from the trenches. Our foremost motivation in writing this
book was to help you, the reader, but in order to do that and to keep improving the
book, we need your feedback on what to improve.
274
Fuzzing Case Studies
About the Authors
Ari Takanen
Ari Takanen is founder and CTO of Codenomicon. Ari has been working with infor-
mation security since 1996. Since 1998, Ari has focused on proactive elimination of
information security issues in next-generation networks and security critical envi-
ronments. His main research topics include robustness testing, fuzzing and other
proactive means of security testing. He started his research on these fields at Oulu
University Secure Programming Group (OUSPG) as a contributing member to PRO-
TOS research. The research group studied information security and reliability errors,
applying their research into protocol fuzzing of e.g., WAP, SNMP, LDAP, and VoIP
implementations. PROTOS publicly launched their first model-based fuzzer in
2000. Continuing this work, Ari and his company, Codenomicon Ltd. provide and
commercialize automated tools using a systematic approach to test a multitude of
interfaces on mission-critical software, VoIP platforms, Internet-routing infrastruc-
ture, and 3G devices. Codenomicon supports more than one hundred communica-
tion interfaces and file formats with state-of-the-art fuzzing tools. Among these
protocols, Ari has selected a few that are most interesting to him, including those
used in the family of VoIP devices, in security devices such as VPNs, and wireless
devices. Ari has been speaking at numerous security and testing conferences, and also
on industry forums related to VoIP, IPTV and wireless. He has also been invited to
speak at leading universities and international corporations on topics related to
secure programming practices and fuzzing.
Jared DeMott
Jared DeMott is a life-long vulnerability researcher, speaker, teacher, and author. He
started his computer security journey with the mysterious NSA. Mr. DeMott played
his small role in opening the eyes of the world to the effects of fuzzing by speaking on