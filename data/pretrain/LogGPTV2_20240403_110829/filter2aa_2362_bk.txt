### Excessive CPU Load and Concurrency Issues

During processing, systems often experience excessive CPU load, followed by memory exhaustion and concurrency issues. These "storms" are designed to place the target protocol under maximum stress while minimizing interactions at higher protocol layers. The traffic generated by each storm type includes a structurally correct header for the protocol being tested, along with a random payload intended to be caught by error-checking code at the next protocol level. This approach allows us to measure differences in behavior between protocols (e.g., Ethernet vs. IP, IP vs. TCP) that may be exploitable.

For example, some devices incur greater overhead when processing Ethernet headers with random payloads compared to IP headers with similar payloads. Different delivery mechanisms, such as broadcast and multicast, have also exhibited unexpected behavior during storm tests, leading to the creation of specific broadcast/multicast storm variants.

### Stress Testing Communication Processes

The ability to stress the communication process to various levels enables us to measure how a device responds to hostile networking conditions. Most equipment is designed to ensure that inputs do not impact the controller’s ability to maintain its I/O functions according to a well-defined policy (e.g., no effect at all, entering a fail-safe mode). By noting that different protocols affect CPU and memory load differently, we can measure discrepancies between the desired I/O policy and actual behavior. Many SCADA networks are designed for a maximum data rate of about 500 to 1,000 packets per second, making simple load-based DoS attacks feasible.

### Black-Box Fuzzing for Security Researchers

#### Introduction
This section concludes the book with an example of auditing a black-box application. This may occur as part of a formal audit at the end of the software development cycle, as an engagement by a security consultant, or by a security researcher examining a released product. In the first two cases, the target system is clear. For researchers, there is more discretion in choosing the target.

#### Selecting the Target
For software developers and testers, the target is typically predetermined. Similarly, security auditors must test the system given to them for review. However, if multiple systems need testing, it becomes important to prioritize based on factors such as risk, exposure, and development quality.

For security researchers, target selection is crucial. Choosing a very secure and well-written target, like Apache, is unlikely to yield many bugs. Conversely, choosing an obscure product, like Tom’s Mail Server, may result in findings that few care about. It's best to choose something in between. Good strategies include selecting products that have not been fuzzed or those with a recent history of vulnerabilities. For this case study, we chose Apple’s QuickTime media player due to its history of vulnerabilities, with over 34 security holes reported in 2007.

#### Enumerating Interfaces
When preparing to fuzz a system, it is essential to determine all the ways data can be passed to the target. For local applications, this might include command-line arguments, environment variables, and files. For network devices, this could range from low-level packets like Ethernet to the TCP/IP stack and administrative applications like web servers. Identifying all possible protocols and formats is critical. For example, a web browser supports multiple protocols (HTTP, FTP, HTTPS, RTSP) and parses various image formats.

In our target, QuickTime, we need to know which formats it supports. While Apple's documentation lists many formats, it is often better to use tools like RCDefaultApp on Mac OS X to identify associated file formats. QuickTime Player supports nearly 50 different file extensions, making it a prime target for fuzzing. For this session, we chose the Audio Video Interleave (AVI) format.

#### Choosing the Fuzzer
Selecting the fuzzer and fuzzer type can be challenging. It depends on the balance between the desire to find bugs and the available time, energy, and budget. Using a combination of different fuzzers is often the most effective method, but in practice, constraints may limit this. For this case study, with no budget, we chose an open-source mutation-based fuzzer. We used a simple C program for our fuzzing, as shown below:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define NUM_FILES 8192
#define SIZE 6250577

int main(void) {
    FILE *in, *out, *lout;
    unsigned int n, i, j;
    char *buf = malloc(SIZE);
    char *backup = malloc(SIZE);
    char outfile[1024];
    int rn, rn2, rn3, rn4;
    int rbyte;
    int numwrites;

    in = fopen("good.avi", "r");
    n = fread(buf, 1, SIZE, in);
    memcpy(backup, buf, n);
    lout = fopen("list", "w");
    srand(time(NULL));

    for (i = 0; i < NUM_FILES; i++) {
        // Mutation logic here
    }

    free(buf);
    free(backup);
    fclose(in);
    fclose(lout);

    return 0;
}
```

#### Results and Analysis
After running the fuzzer, we observed a crash in QuickTime Player. Closer inspection revealed that the crash was due to an overflow in the source buffer of a copy operation within a loop. This condition is potentially exploitable, and the bug has been reported to Apple but remains unfixed as of this writing.

### Summary

In this chapter, we explored different use cases for fuzzing, providing a broad overview rather than a detailed walk-through. Fuzzing deployment should start from real needs, and its value is recognized in various sectors, including enterprise, carrier, and ISP spaces. Software developers, especially QA teams, are gradually adopting fuzzing, and major companies are increasingly integrating it into their development processes.

Fuzzing in industrial automation, such as SCADA systems, can be a life-saver, preventing critical infrastructure failures. Finally, we examined fuzzing from a security researcher's perspective, demonstrating the effectiveness of even simple mutation-based fuzzing.

As of January 2008, fuzzers were still early in the market, but their importance is growing. Without fuzzing, we will continue to face a cycle of patch-and-penetrate, with frequent vulnerabilities and system crashes. We encourage you to review your work and consider where fuzzing fits in your organization. Your feedback is invaluable for improving this book and helping others.

### About the Authors

**Ari Takanen**
Ari Takanen is the founder and CTO of Codenomicon. With a background in information security since 1996, Ari has focused on proactive elimination of security issues in next-generation networks and critical environments. His research includes robustness testing, fuzzing, and other proactive security testing methods. He started his work at Oulu University Secure Programming Group (OUSPG), contributing to PROTOS research, which publicly launched their first model-based fuzzer in 2000. Ari and Codenomicon provide and commercialize automated tools for testing mission-critical software, VoIP platforms, Internet-routing infrastructure, and 3G devices. Ari has spoken at numerous security and testing conferences and has been invited to speak at leading universities and international corporations.

**Jared DeMott**
Jared DeMott is a lifelong vulnerability researcher, speaker, teacher, and author. He began his computer security journey with the NSA and has contributed to raising awareness about the effects of fuzzing. Jared has spoken at various security conferences and has been involved in numerous research projects and publications.