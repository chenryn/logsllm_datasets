implementations  were  associated  with  each 
IDL 
interface.  In the first  one, a  single class implements all 
the  operations  of 
the  other  two 
implementations,  simple  and  multiple  inheritance  are 
respectively  used  in  order  to  reveal  potential  problems 
associated with the reification of inherited operations. 
the  interface.  In 
4.2. First Experiments and Results 
According to Section 3.1, a specific test environment was 
designed  and 
the 
correctness  of  the  interaction  channel  between  objects  and 
metaobjects. In  our  case  study, objects  and  metaobjects  are 
to  observe  and  check 
implemented 
1
334 
interface ServiceForTestingHandlingOfType-Long( 
long returnlong( ); 
void InLong(in T pl); 
void OutLong(out T pl); 
void InOutLong(inout T pl); 
long AIILong(in long p l .  out long p2. inout long p3); 
1; 
-
Figure 11 : IDL service interface 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:57:26 UTC from IEEE Xplore.  Restrictions apply. 
To  implement  the  oracle  procedure,  one  table  was 
generated for each operation included in the Service interface 
of the server object. This table describes the signature of the 
operation,  and  gives  the  method  identifier  used  by  the 
reification mechanisms for that operation. This information is 
needed for checking the compliance between the data reified 
to the metaobject and the one handled by the driver object. 
The  test  experiments  performed  revealed  that  different 
method  invocations could be  reified to the  meta-level using 
the  same  method  identifier.  Hence,  the  metaobject  cannot 
distinguish  which  method  has  actually  been  invoked.  This 
problem  has  been  observed using  both  simple  and  multiple 
inheritance. In the first case, it was easily fixed by modifying 
the code transformation rules that  generate the MOP imple- 
mentation. Concretely, the  algorithm  used  to  assign method 
identifiers to IDL operations was slightly changed in order to 
avoid  the  reuse  of  method  identifiers  already  assigned. 
However, in case of multiple inheritance, the problem is much 
more difficult to fix (and it has not been fixed yet). 
The next testing levels were performed after having fixed 
the  problem  related  to  simple  inheritance.  Since  multiple 
inheritance remains a restriction on the use of  the new MOP 
release, it was not used in the following test experiments. 
in 
the  server  object 
Testing  level  2:  Behavioral intercession  mechanisms 
(Figure  4).  According  to 
the  observability  constraints 
associated with the oracle procedure, the server object reports 
on its execution by  generating execution traces. These traces 
are  produced  by  every  public,  protected  or  private  method 
implementation.  Let  us 
included 
remember  that the activation of  a Service interface operation 
may lead to the execution of other object internal methods. As 
stated  in  Section  2.2,  the  object  must  encapsulate  these 
internal invocations, which consequently must not be reified. 
Two problems were revealed by the test experiments. The 
first  one  concerns  the  encapsulation  of  the  internal  object 
activity:  public  methods  that  do  not  belong  to  the  Service 
interface of  the server object were  reified to  the meta-level. 
This means that the behavioral intercession mechanisms may 
trigger reification mechanisms while they should not have to 
do so. The second problem was observed when the activated 
code performs an internal invocation to a method of a parent 
class that is redefined in  its child class. In that case, it  is the 
method  of  the  child  class  that  is  executed.  This  problem 
reveals  an  omission  fault  since  although  the  MOP  was 
supposed  to  handle  this  kind  of 
invocation,  no  code 
transformation rules deal with the associated transformations. 
Both problems were fixed before going to testing level 3. 
Testing level  3:  Introspection mechanisms  (Figure 5). 
The server object classes used in that level provide attributes 
with  different  data  types.  It  is  worth  noting  that  due  to 
dependability issues, the  MOP under test restricts the  set of 
data  types  that  can  be  used  for  defining  attributes.  For 
instance,  multiple  level  pointers  are  not  allowed.  In  the 
implementation of each server object class, we have included 
a  constructor  through  which  every  attribute  of  the  server 
object is initialized from a parameter  value (step  1 in  Figure 
5). No faults were revealed during the test experiments. 
Testing  level  4:  Structural  intercession  mechanisms 
(Figure 6). The server object classes used  in  this phase  have 
been defined using the same features as in the previous testing 
level.  Furthermore,  the  server  object  classes  provide  an 
initialization  method.  This  method  is  required  by  the  test 
driver  object for  modifying the state of  the object (step 3 in 
Figure  6).  No  faults  were  revealed  during 
test 
experiments. 
Further experiments must be performed at testing levels 3 
and 4 in  order to consider more complex data types, such as 
arrays, structures and class data types. 
the 
5.  Related Work and Discussion 
Most  research  work  focused  on 
the  verification  of 
reflective architectures reports on  the definition of  high-level 
models for such architectures, using formal languages. In [9], 
the  authors  propose  a  model  based  on  an  architectural 
description  language,  called  WRIGHT  [ 181.  This  language 
describes a system as a set of architectural components linked 
by connectors (MOPs). The notion of MOP used in that work 
is, however, different from  the  one considered  in  this  paper 
since  it  encapsulates  both  the  reflective  capabilities  of  the 
system and the system meta-level. A different model based on 
the n-calculus [ 191 is proposed in [8]. It describes a reflective 
system  as  a  system  composed  of  agents  (objects  and 
metaobjects), which communicate  by  exchanging messages. 
The  MOP  is  then  the  element  handling  the  interactions 
between  objects  and  metaobjects.  This  notion  of  MOP 
conforms to the one defined in Section 2.2. 
Both  previous  models  can  be  analyzed  using  tools 
specifically  developed  for  the  associated  formal  languages. 
The results obtained are useful to ensure a certain number of 
high-level properties, for instance the absence of deadlocks in 
the  MOP.  However,  the  level  of  description  used  in  these 
models  is  too  generic  to  be  helpful  in  finding  problems 
associated with a particular MOP implementation. 
The  generic strategy presented in  this paper  can  be  used 
for testing any MOP of  the family described in  Section 2.2. 
Obviously, the strategy must  be  adapted to each MOP. The 
four testing levels of the strategy are required for checking the 
implementation  of  the  FZJ€T$D.S  MOP.  However,  less 
sophisticated MOPs  may  be  tested  using  only  some  of  the 
instance,  MOPs  that  only  provide 
testing 
reification  and  behavioral  intercession  mechanisms  (like  in 
MAUD  and  C A W )  require  testing  levels  1  and  2  to  be 
instantiated;  the  COMA  portable  interceptors  (a  form  of 
reification  of  CORBA  requests)  can  be  tested  using  testing 
level  1; the testing of  the serialization features provided  by  a 
levels.  For 
335 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:57:26 UTC from IEEE Xplore.  Restrictions apply. 
Java  virtual machine  (a form of  introspection and  structural 
intercession mechanisms) only requires testing levels 3 and 4. 
7.  References 
6.  Conclusion 
in 
for 
the 
Reflection is a powerful concept for the implementation of 
complex  dependable  systems  with  a  clear  separation  of 
concerns.  In  spite  of  its  interest, the  use  of  this  technology 
remains  questionable  due  to  the  little work  reporting  on  its 
verification.  The  test  strategy  presented 
this  paper 
constitutes a step forward in the definition of a global strategy 
for  the  verification  of  MOP-based  reflective  architectures. 
The  main  interest  of  the  approach  is  the  systematic  and 
incremental  order  proposed 
reflective 
capabilities of the system. This order reduces the test effort by 
enabling  the  reuse  of  the  mechanisms  already  tested  for 
testing the remaining  ones, thus facilitating the  implementa- 
tion of the test environments. Furthermore, it allows the tester 
to progressively identify and fix potential problems related to 
the reflective mechanisms, one after the other. 
testing 
The efficiency of such a progressive testing and debugging 
process  was  noticeable  all  along  the  experiments  we 
conducted on the  FRIE5@.S  MOP. Indeed, these experiments 
were performed in parallel with the development of the MOP, 
i.e., with the definition of the code transformation rules used 
to generate the MOP implementation (see Figure 8). Specific 
rules  are  associated  with  each  of 
the  four  retlective 
mechanisms  covered  by  the  test strategy. As a  result, every 
testing level i (i = I,. . .,4)  concentrates on a subset S, of  rules. 
Fixing  potential  faults  in  the  rules  of  S,  before  defining  the 
rules of  S,+, avoids possible ripple effects of  these corrections 
on the rules of S,,,. Hence, errors were early and incrementally 
detected  and  fixed  (when  possible).  Note  that,  when  a 
problem  cannot  be  fixed,  the  test  results  allow  at  least  the 
identification of restrictions on  the use of  the MOP:  it is the 
ca$e of  multiple  inheritance  that  is  not correctly handled by 
the current version of the FRIENDsmetaobject protocol. 
Ongoing work is now focused on the definition of rigorous 
test criteria to guide the automatic generation of test case input 
values according to the test objectives specific to each testing 
level. The generic test strategy presented does not tackle this 
issue yet.  Based  on  existing elements of  solutions (see e.g., 
[ lO][l  I][ 12]),  we plan to propose specification-based criteria 
- that may be used for any MOP-based reflective architecture - 
supplemented with implementation-based criteria. 
Finally,  the MOP model  used  in  the  paper  assumes that 
objects and metaobjects are deterministic and mono-threaded 
system components. To lift these restrictions, more work has 
to  be  done  on  the  identification  of  the  necessary  retlective 
features. Then, the testing levels of the strategy will have to be 
revised and extended to handle these new features. This is an 
objective of our future investigation. 
336 
[I]  P.  Maes,  “Concepts  and  experiments  in  computational 
reflection”,  in  Object-Oriented  Programming  Systems, 
Languages and Applications,  ACM  Press, Orlando, 1987, 
vol. 22, pp. 147-155. 
[2]  Sun  Microsystems, “Java  reflective  API  documentation”, 
on-line document available at: http://java.sun.com/j2se/1.3/ 
docs/api/java/lang/reflect/package-summary. html. 
[3]  Y. Yokote, “The Apertos Reflective Operating System: The 
Concept  and 
its  implementation”,  in  Object-Oriented 
Programming  Systems, Languages and Applications, ACM 
Press, New York, 1992, vol. 27-10, pp. 414-434. 
[4]  G.  Blair  et  al.,  “An  Architecture  for  Next  Generation 
Middleware”, in  Middleware, Springer-Verlag, UK,  1998, 
pp. 19 1-206. 
[SI  R.J.  Stroud, “Transparency and  Reflection in  Distributed 
Systems”, ACM  Operating Systems review, 1993, vol. 22-2, 
pp.99- 103. 
[6]  J.-C.  Fabre and  T. PCrennou, “A  Metaobject Architecture 
for  Fault-Tolerant  Distributed  Systems:  the  F!IE?(DS 
Approach”, IEEE Trans. on  Computers,  1998, vol. 47, pp. 
78-95. 
[7]  G. Kiczales et al., The Art ofthe Metaobject Protocol, MIT 
Press, ISBN 0-262-61074-4, 1991. 
[ 131 M.-0. Killijian and J.C. Fabre, “Implementing a Reflective 
Fault-Tolerant CORBA  System”, in  IEEE  Symposium  on 
Reliuble Distributed Systems, Germany, 2000, pp.  154- 163. 
in  Object-Oriented 
Languages”, in  Technology of  Object-Oriented Languages 
and Systems, IEEE Press, Australia, 1998, pp.  1 13-1 26. 
[ 141 S.  Chiba,  “Macro  Processing 
[I51 G.Agha  et  al.,  “A  Linguistic  Framework  for  Dynamic 
Composition of  Dependability Protocols”, in  Dependable 
Computing for Critical Applications 3,Vol. 8 ,  in the Series 
on  Dependable  Computing  and  Fault-Tolerant  Systems, 
Springer-Verlag, 1993, pp. 345-363. 
[I61 B.  Garbinato  et  al.,  ‘‘Implementation  of 
the  GARF 
Replicated  Objects  Platform”,  in  Distributed  Systems 
Engineering Journal, 1995, vol. 2, pp. 14-27. 
[ 171 P. ThCvenod-Fosse et al., “Software Statistical Testing”, in 
Predictably  Dependable  Systems (Randell, Laprie, Kopetz, 
and  Littlewood, editors) , Springer-Verlag, 1995, pp. 253- 
272. 
[ 181 J. R. Allen, “A formal Approach to Software Architecture”. 
PhD Thesis, Camegie Mellon University, 1997. 
[ 191 A.J.R.G. Milner, A  Calculus  of  Communicating  Systems, 
LNCS vol. 92, Springer-Verlag, 1980. 
[8] E.  Marsden  et  al.,  “Towards  Validating  Reflective 
Architectures: Formalization of  a MOP”, in  Workshop on 
Reflective Middleware, New York, 2000, pp.33-35. 
[9]  I.  Welch  and  R.  Stroud,  “Adaptation  of  Connectors in 
Software  Architectures”, in  Workshop  on  Component  - 
Oriented Programming, Brussels, 1998, pp.145-146. 
[IO] G.V. Bochmann and A. Petrenko, “Protocol testing: review 
of  methods  and  relevance  for  software  testing”,  in 
International Symposium on Software Testing and Analysis 
(ISSTA ‘94), ACM Press, Seattle, 1994, pp. 109-124. 
[ I  I ]  D. Kung, P. Hsia and J. Gao (eds), Testing Object-Orienfed 
Sofrware, IEEE Computer Society, 1998. 
[ 121 R.V.  Binder,  Testing  Object-Oriented  Systems,  Addison- 
Wesley, 1999. 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:57:26 UTC from IEEE Xplore.  Restrictions apply.