— set of all system reconfigurations
Formally, an SFTA is an action  R in which the condi-
tions in Table 2 hold. We have proven the properties in
Table 2 directly from our abstract formal specification
using  the  PVS  system.  The  specification  is  a  set  of
types that enforces all of the desired system properties
by placing type restrictions on any instantiation. In our
case, an instantiation of the PVS architecture would be
a  PVS  specification  itself.  The  powerful  type  mecha-
nisms of PVS are used to automatically generate all of
the  proof  obligations  required  to  verify  that  a  system
instance  is  compliant  with  the  desired  properties.  In
this work, we have proven all of the desired properties
of our abstract specification in PVS, and the PVS proof
checker  has  mechanically  verified  that  the  proofs  are
sound (thus we do not include the proofs here).
7. Example instantiation
To assess the feasibility of the approach outlined in
this paper and to demonstrate the concepts that consti-
tute  the  approach,  we  have  implemented  an  example
reconfigurable  system.  The  system  is  a  hypothetical
avionics system that is representative, in part, of what
might be found on a modern UAV or general-aviation
aircraft. The example includes two functional applica-
tions:  an  autopilot  and  a  flight  control  system  (FCS).
Only  minimal  versions  of  application  functionality
have  been  implemented  since  the  system  is  not
intended  for  operational  use.  However,  each  applica-
tion has a complete reconfiguration interface, including
the  capability  to  provide  multiple  functionalities.  An
electrical  power  generation  system  is  modeled  as  an
environmental factor that might necessitate a reconfig-
uration.
In  its  primary  specification,  the  autopilot  provides
four  services  to  aid  the  pilot:  altitude  hold,  heading
hold,  climb  to  altitude,  and  turn  to  heading.  It  also
implements a second specification in which it provides
altitude  hold  only.  Its  second  specification  requires
substantially less processing and memory resources.
The  FCS  provides  a  single  service  in  its  primary
specification: it accepts input from the pilot or autopi-
lot  and  generates  commands  for  the  control  surface
actuators. This primary specification could include sta-
bility  augmentation  facilities  designed  to  reduce  pilot
workload, although we merely simulate this. The FCS
also implements a second specification in which it pro-
vides  direct  control  only,  i.e.,  it  applies  commands
directly to the control surfaces without any augmenta-
tion of its input. As with the autopilot, when operating
Proceedings of the 2005 International Conference on Dependable Systems and Networks (DSN’05) 
0-7695-2282-3/05 $20.00 © 2005 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:09:48 UTC from IEEE Xplore.  Restrictions apply. 
under this specification, the FCS requires less process-
ing and memory resources.
system  and  executed  by  the  application  and  SCRAM
instantiations.
The electrical system consists of two alternators and
a battery, and its interface exports the state that it is in.
One  alternator  provides  primary  vehicle  power;  the
second  is  a  spare,  but  normally  charges  the  battery,
which  is  an  emergency  power  source.  Loss  of  one
alternator reduces available power below the threshold
needed  for  full  operation.  Loss  of  both  alternators
leaves the battery as the only power source. The elec-
trical  system  operates  independently  of  the  reconfig-
urable system; it merely provides the system details of
its  state.  For  illustration,  the  anticipated  component
failures  for  which  reconfiguration  takes  place  are  all
based on the electrical system.
Our system can operate in three configurations:
• Full Service.   Full power is available, and all of the
platform  computing  equipment  can  be  used.  The
autopilot  and  FCS  provide  full  service,  and  each
operates on a separate computer.
• Reduced Service.   Power is available from only one
alternator  or  the  battery,  and  some  of  the  platform
computing  equipment  has  to  be  shut  down.  The
applications must share a single computer that does
not have the capacity to support full service from the
applications, so the autopilot provides altitude hold
service only and the FCS provides direct control.
• Minimal Service.   In  this  configuration,  power  is
available  from  the  battery  only,  and  the  remaining
platform computing equipment has to be switched to
its  low-power  operating  mode.  The  applications
must  share  a  single  computer  that  is  operating  in
low-power  mode,  and so the autopilot is turned off
and the FCS provides direct control.
The  reconfiguration  interfaces  for  the  two  applica-
tions described above,  the  three acceptable  configura-
tions,  and  the  transitions  between  configurations  are
specified  in  PVS.  We  type  checked  our  instantiation
against the abstract specification described in section 6
and discharged the generated proof obligations.
We  have  constructed  a  Java  implementation  of  the
example, but have not verified it against its specifica-
tion since the focus of this work is at the specification
level.  The  implementation  runs  on  a  set  of  personal
computers running Red Hat Linux. Real-time operation
is modeled using a virtual clock that is synchronized to
the  clocks  provided  by  Linux.  A  time-triggered,  real-
time bus and stable storage are simulated. This exam-
ple has been operated in a simulated environment that
includes  aircraft  state  sensors  and  a  simple  model  of
aircraft  dynamics.  Its  potential  reconfigurations  have
been  triggered  by  simulated  failures  of  the  electrical
7.1 An example system fault tolerant action
In  our  example,  each  AFTA  is  implemented  as
described  in  section  6.2.  For  illustration,  we  require
certain  hypothetical  constraints  on  system  transitions
that manage aircraft dynamics properly. In any transi-
tion, the aircraft’s condition in the target configuration
must be known so that processing in the target configu-
ration begins correctly. In this example, we require that
the control surfaces be centered, i.e., not exerting turn-
ing  forces  on  the  aircraft,  and  the  autopilot  be  disen-
gaged when a new configuration is entered. These are
thus  the  preconditions  for  the  FCS  and  autopilot.  The
postcondition that each application must establish prior
to reconfiguration is merely to cease operation.
The  specific  applications  that  we  have  used  in  this
illustration  have  no  dependencies  during  their  halt
stages because neither requires any support to establish
its postcondition. There is only one dependency during
initialization, namely that the autopilot cannot resume
service  in  the Reduced  Service  configuration  until  the
FCS  has  completed  its  reconfiguration—the  autopilot
cannot effect control without the other application.
Suppose that the system is operating in the Full Ser-
vice configuration and an alternator fails. The electrical
system  will  switch  to  use  the  other  alternator,  and  its
interface  will  inform  the  SCRAM  of  the  failure.  The
autopilot  and  flight  control  applications  are  unable  to
complete their AFTAs within the allotted time because
there is not enough power to run them both at full ser-
vice; however, their postconditions are simply to cease
operation, and so this does not pose a problem. Based
on  the  static  reconfiguration  table,  the  SCRAM  com-
mands a change to the Reduced Service configuration.
The  system  reconfiguration  is  implemented  using  the
sequence shown in Table 1 to complete its SFTA.
7.2 Properties of the example instantiation
As discussed above, the formal properties from sec-
tion  6.4  are  enforced  in  specification  instantiations
through the type system. PVS does this by generating
type-correctness  conditions  (TCCs),  a  kind  of  proof
obligation.  The  example  proof  obligation  in  Figure  2,
abbreviated  and  otherwise  edited  for  clarity,  requires
that:  (1)  the  example’s  specification  levels  are  of  the
type expected as the SCRAM input parameters; and (2)
the covering_txns predicate (which ensures a transi-
tion  exists  for  any  possible  failure-environment  pair)
Proceedings of the 2005 International Conference on Dependable Systems and Networks (DSN’05) 
0-7695-2282-3/05 $20.00 © 2005 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:09:48 UTC from IEEE Xplore.  Restrictions apply. 
% Subtype TCC generated(at line 117, column 16) for ex_SCRAM_table
%  expected type  SCRAM_table(ex_apps, extend[...](ex_speclvl)),
%  ex_valid_env, ex_reachable_env)
% proved - complete
example_reconf_spec_TCC6: OBLIGATION 
FORALL (x: speclvl): ex_speclvl(x) IFF
extend[speclvl, {sp: speclvl | NOT sp = indeterminate}, bool, FALSE] 
(restrict[speclvl, {sp: speclvl | NOT sp = indeterminate}, boolean](ex_speclvl))(x)
AND covering_txns(ex_apps, extend[...] (ex_speclvl)), ex_valid_env, ex_reachable_env,
ex_SCRAM_table`txns, ex_SCRAM_table`primary, ex_SCRAM_table`start_env);
Figure 2. Example TCC
must hold for the parameters. We have proven all of the
TCCs generated for the example.
8. Conclusion
Safety-critical  systems  often  use  hardware  replica-
tion to tolerate faults  that  occur during operation, and
Schlichting  and  Schneider  have  presented  a  theory  of
doing this based on the rigorous semantics of fail-stop
processors.  Reconfiguring  the  system  in  response  to
faults,  however,  can  help  designers  achieve  their
dependability  goals  without  necessitating  additional
hardware, thus saving weight, power, and space. In this
paper, we have drawn on a previous work in reconfigu-
ration  of  single  applications  and  the  semantics  pre-
sented  by  Schlichting  and  Schneider  to  create  an
architecture  and  verification  framework  to  use  recon-
figuration  in  dependable  systems.  We  address  the
requirements  of  systems  of  interacting  applications,
combining  the  distributed  system  aspect  of  fail  stop
with the structured, proof-based assurance of our previ-
ous work to address timing as well as temporal charac-
teristics of systems. This enables assurance not only of
liveness, but also of real-time characteristics of system
recovery. To assess the feasibility of our theory in prac-
tice, we have presented an example based on a proto-
typical control system, interpreted our theory in terms
of its specific requirements, and shown how the theo-
retical  properties  hold  over  an  instantiation  through
type mechanisms.
Acknowledgments
We  thank  Xiang  Yin  and  Dean  Bushey  for  their
assistance with our example. This work was sponsored,
in part, by NASA under grant number NAG1-02103.
References
[1] ARINC  Inc.  “Avionics  Application  Software  Standard
Interface.” ARINC Spec. 653, Baltimore, MD, 1997.
[2] Garlan, D., S. Cheng, and B. Schmerl. “Increasing Sys-
tem  Dependability  through  Architecture-based  Self-
repair.” Architecting Dependable Systems, R. de Lemos,
C.  Gacek,  A.  Romanovsky  (Eds),  Springer-Verlag,
2003.
Jahanian, F., and A.K. Mok. “Safety Analysis of Timing
Properties in Real-Time Systems.” IEEE Trans. on Soft-
ware Engineering, 12(9):890-904.
[3]
[4] Knight, J. C., E. A. Strunk and K. J. Sullivan. “Towards
a  Rigorous  Definition  of  Information  System  Surviv-
ability.”  Proc.  3rd  DARPA  Information  Survivability
Conf. and Exposition, Washington, D.C., April 2003.
[5] Kopetz, H., and G. Bauer, “The Time-Triggered Archi-
tecture.” Proc. IEEE, 91(1):112-126, Jan. 2003.
[6] Porcarelli, S., M. Castaldi, F. Di Giandomenico, A. Bon-
davalli, and P. Inverardi. “A framework for reconfigura-
tion-based  fault-tolerance 
in  distributed  systems.”
Architecting  Dependable  Systems  II,  R.  De  Lemos,  C.
Gacek,  and  A.  Romanovsky  (Eds),  Springer-Verlag,
2004.
[7] Sha,  L.  “Using  Simplicity  to  Control  Complexity.”
IEEE Software 18(4):20-28.
[8] Schlichting, R. D., and F. B. Schneider. “Fail-stop pro-
cessors:  An  approach  to  designing  fault-tolerant  com-
puting  systems.”  ACM  Trans.  Computing  Systems
1(3):222-238.
[9] Shelton,  C.,  and  P.  Koopman.  “Improving  System
Dependability with Functional Alternatives.” Proc. 2004
Int’l  Conf.  Dependable  Systems  and  Networks,  Flo-
rence, Italy, June 2004.
[10] Strunk, E. A., and J. C. Knight. “Assured Reconfigura-
tion  of  Embedded  Real-Time  Software.”  Proc.  Int’l
Conf.  Dependable  Systems  and  Networks,  Florence,
Italy, June 2004.
[11] Strunk, E. A., J. C. Knight, and M. A. Aiello. “Distrib-
uted  Reconfigurable  Avionics  Architectures.”  Proc.
23rd  Digital  Avionics  Systems  Conference,  Salt  Lake
City, UT, Oct. 2004.
[12] Yeh, Y. C. “Triple-Triple Redundant 777 Primary Flight
Computer.”  Proc.  1996  IEEE  Aerospace  Applications
Conference, vol. 1, New York, N.Y., February 1996.
Proceedings of the 2005 International Conference on Dependable Systems and Networks (DSN’05) 
0-7695-2282-3/05 $20.00 © 2005 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:09:48 UTC from IEEE Xplore.  Restrictions apply.