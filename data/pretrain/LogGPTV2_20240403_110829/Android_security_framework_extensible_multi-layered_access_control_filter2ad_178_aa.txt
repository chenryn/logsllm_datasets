# Title: Android Security Framework: Extensible Multi-Layered Access Control on Android

## Authors
- Michael Backes
- Sven Bugiel
- Sebastian Gerling
- Philipp von Styp-Rekowsky

### Contact
{backes, bugiel, sgerling, styp-rekowsky}@cs.uni-saarland.de

### Affiliation
Saarland University/CISPA, Germany

## Abstract
We introduce the Android Security Framework (ASF), a generic and extensible security framework for Android. ASF enables the development and integration of a wide spectrum of security models as code-based security modules. The design of ASF incorporates lessons learned from established security frameworks, such as Linux Security Modules and the BSD MAC Framework, while addressing the unique requirements and challenges of Android's software stack. ASF provides a novel security API that supports developers in creating their security modules, overcoming the current need to provide security solutions as separate patches or embed them into Androidâ€™s mainline codebase. This extensibility is particularly beneficial for enterprise or government solutions requiring advanced security models not supported by vanilla Android. We present a prototypical implementation of ASF and demonstrate its effectiveness and efficiency by modularizing different security models, such as dynamic permissions, inlined reference monitoring, and type enforcement.

## 1. Introduction
For several decades, the importance of operating system security mechanisms in providing strong security and privacy guarantees has been well understood [24, 34, 26, 5]. However, recent attacks on smartphone users' privacy and security [19, 41, 29, 9] have shown that modern mobile operating systems, including Android, often fail to provide these guarantees, especially in terms of access control and information flow control. To address this, security research has proposed a wide range of security models and extensions for mobile operating systems, particularly for the open-source Android OS. These include context-related access control [10], developer-centric security policies [28], and dynamic, fine-grained permissions [42, 21, 3]. They also encompass security models such as domain isolation and type enforcement, which are crucial for enterprise and governmental security solutions.

However, the lack of a comprehensive security API for developing and modularizing security extensions on Android has led to an unsatisfactory situation where these security models are either provided as model-specific patches to the Android software stack or integrated directly into the Android OS design [36]. This approach, as seen in established security frameworks like Linux Security Modules (LSM) [40] and the BSD MAC Framework [39], can impair both the practical and theoretical benefits of security solutions. First, there is no consensus on the "right" security model, as evidenced by the variety of Android security extensions [10, 28, 3, 42, 7, 36]. Second, providing security solutions as "security-model-specific Android forks" complicates maintainability across different OS versions, as each update must be re-evaluated and applied separately to each fork.

### Contributions
In this paper, we propose the design and implementation of the Android Security Framework (ASF), which allows security experts to develop and deploy their security models as modules within Android's platform security. This provides a means to easily extend Android's security mechanisms without forcing security designers to choose a specific Android security fork or having the OS vendor impose a particular security model. Our design integrates lessons learned from established OS security infrastructures and addresses new requirements for efficient security policies in multi-tiered software stacks of smart devices. Unlike concurrent work [20], which introduced extensibility for security apps, our design establishes a generic and extensible security framework that allows instantiating security models as part of Android's platform security and enables not only extending but also replacing Android's default security mechanisms. This is particularly beneficial for higher-security deployments, such as enterprise phones, where the default mechanisms may be insufficient or obsolete. Our contributions include:

1. **Policy-agnostic, multi-tiered security infrastructure**: ASF avoids committing to a specific security model and enables authors of security extensions to develop and deploy their solutions as code. This requires special consideration of Android's multi-tiered software stack and the dominant programming languages at each layer. We achieve this by integrating security-model-agnostic enforcement hooks into the Android kernel, middleware, and application layer, exposing these hooks through a novel security API to module authors.

2. **Enabling edit automata policies**: Various Android security solutions implement edit automata policies that modify control flows. In ASF, the application layer and middleware hooks are designed to allow module authors to leverage the rich semantics of Android's application framework and implement their security policies as edit automata. This required rethinking the "classical" object manager design by shifting the edit automata logic from the infrastructure into the security modules.

3. **Instantiation of existing security models**: We demonstrate the efficiency and effectiveness of ASF by instantiating different security models from related work on type enforcement [8, 36] and inlined access control [3], as well as from Android's default security architecture as modules.

4. **Maintenance benefits for security extensions**: Our ported security modules show how ASF simplifies the maintainability of security extensions across different OS versions by shifting the bulk of effort to the security framework maintainer, similar to the maintenance of the application framework for regular apps. This results in comparable benefits in adaption and stability across OS versions for security modules.

5. **Research and development benefits**: Developing security solutions against a well-documented security API enhances the understanding and analysis of new security models, improves reproducibility and dissemination of new solutions, and facilitates the application of security knowledge to the Android software stack without requiring deep technical familiarity with Android.

## 2. Background on Android
### 2.1 Primer on Android
Android is an open-source software stack for embedded devices. The lowest level of the stack consists of a Linux kernel responsible for memory management, device drivers, and an Android-specific lightweight inter-process communication (IPC) mechanism called Binder. Above the kernel lies the extensive Android middleware, comprising native libraries (e.g., SSL) and the application framework. System services in the middleware implement most of Android's application API (e.g., location service), and pre-installed system apps at the application layer, such as Contacts, complement this API.

Although applications and services are commonly written in Java, they are compiled to dex bytecode and run inside the Dalvik Virtual Machine (DVM). Apps and services can also use native code libraries (C/C++) for low-level interactions with the underlying Linux system, seamlessly integrated via the Java Native Interface.

Android apps are composed of different components: Activities (GUI for user interaction), BroadcastReceivers (mailbox for broadcast Intent messages), ContentProviders (SQL-like data management), and Services (long-running operations without user interaction). These components can be interconnected remotely across application boundaries using abstractions of Android's Binder IPC mechanism, such as Intent messages.

### 2.2 Android's Security Philosophy
Android's security philosophy involves sandboxing all apps by executing them in separate processes with distinct user IDs (UIDs) and assigning them private data directories on the filesystem. To achieve privilege separation between apps, Android introduces Permissions, which are privileges granted to an app by the user at install-time. According to the least privilege principle, an app without the necessary permissions cannot access security and privacy-sensitive resources. Permissions are assigned to the app's UID and enforced at two points in the system architecture (see Figure 1):

1. **Kernel-level enforcement**: Each app sandbox can interact directly with the kernel through system calls, e.g., to edit files or open network sockets. Access control in the filesystem ensures that the app's process has the necessary rights (Permissions) to issue specific syscalls. The filesystem access control includes traditional Linux Discretionary Access Control, complemented (since Android v4.3) by SELinux-based Mandatory Access Control (MAC).

2. **API-level enforcement**: Apps can interact with highly privileged resources through the Android API in a strictly controlled manner. To ensure system security and stability, apps are prohibited from accessing these resources directly. Instead, these resources are wrapped by system services and apps that implement the API. For example, the TelephonyService communicates on behalf of apps with the radio interface layer daemon (rild) to initiate calls or send text messages. Whether an app has sufficient privileges to call the API is determined by a Permission check within the system services/apps. The Binder mechanism provides the callee (system service/app) with the UID of the caller (app) for this check.

## 3. Related Work
### 3.1 Extensible Kernel Access Control
The importance of the operating system in providing system security has been well-studied over the past decades [34, 24, 5, 26], and various approaches to extending operating systems with access control and security policies have been explored. These include system-call interposition [15, 30], software wrappers [16], and extensible access control frameworks like DTE [4], GFAC [1], and Flask [37]. These solutions were provided as kernel patches for Linux or UNIX, leading to high maintenance costs for adapting patches to kernel changes. Additionally, none of these solutions was included in the vanilla kernel because it would constrain policy authors to a specific security model. To address this, extensible security frameworks [40, 39] were proposed, allowing the extension of the system with trusted code modules implementing specific security models. These frameworks provide an API that exposes kernel abstractions and operations, facilitating the implementation of desired security architectures and models. The results of this research have been integrated into the mainline kernels as the Linux Security Modules (LSM) [40] and the BSD MAC Framework [39].

### 3.2 Android Security
The closest approach to ours is the independently and concurrently developed ASM [20], which also provides a programmable interface for security extensions. However, ASM targets "security apps" added to the default Android security architecture, whereas ASF resides beneath the default Android security framework, allowing the instantiation of security models that complement or even substitute parts of the default platform security (cf. Section 6). Therefore, ASM can be implemented as a module in ASF, and by definition, we must trust the developer of security solutions for ASF.

In recent years, Android's security has been scrutinized, and a wide spectrum of security extensions has been proposed. For example, CRePE [10] provides context-related access control, Saint [28] enables developer-centric policies, and various approaches to more dynamic and fine-grained permissions have been proposed, such as TISSA [42], Dr. Android and Mr. Hide [21], and AppGuard [3]. XManDroid [6] enforces Chinese Wall policies, while TrustDroid [7] and MOSES [33] isolate different domains. SE Android [36] and FlaskDroid [8] bring type enforcement to Android, with SE Android focusing on the kernel layer and partially included in the mainline Android source code, and FlaskDroid extending type enforcement to the middleware layer on top of SE Android.