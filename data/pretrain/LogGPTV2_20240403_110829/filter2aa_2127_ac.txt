实验验证我们的方法是否有效
# DecObfs
•
使用Angr求解DecObfs示例，2h内Angr仍
未返回结果
我们测量了DecObfs Fork新路径所需的时间
DecObfs vs 3x+1Obfs
•
更快出现峰值
•
收敛回定值所需迭代次数更少
•
峰值更高
•
约束求解器求解所需时间越长
# DecObfs vs 3x+1Obfs
比较维度
数据范围
DecObfs
3x+1Obfs
谁胜出
收敛迭代平均次数
1-10000000
24次
152次
DecObfs
迭代次数一致时的
时间开销
88, 104, 108, 128, 
48152
14秒(执行
100000000次)
6秒(执行
100000000次)
3x+1
空间开销
300 BYTE
76 BYTE
3x+1
•
时间开销
•
当迭代所需次数相同时，DecObfs的耗时是3x+1Obfs的2.4倍左右，而从我们统计的平均情
况来看，DecObfs所需的迭代次数是24次，3x+1Obfs是152次，3x+1Obfs是DecObfs的
6.3倍左右。故而，DecObfs在一般情况下的时间开销可能比3x+1Obfs更少
•
空间开销
•
3x+1Obfs 好于 DecObfs
# 去符号化 vs ForObfs
只有当 k = 2时，ForObfs才开始产生作用（1/15，1h Timeout）
ForObfs带来的时间开销是会随着输入变化而变化的，
故而我们讨论平均情况，也即 2 个for循环的循环次数都为128次
项目
执行次数
时间
去符号化
100000000
2s
ForObfs
100000000
35s
（作者甚至在论文中加了一节以讨论如何编译出ForObfs不
被优化掉的BIN，实际上加一个volatile修饰符即可……
显然，去符号化在时间开销上远好于ForObfs。
然而，去符号化会引入一个包含256元素的数
组，造成一定的空间开销。但是可执行文件的
区段中一般存在很多为了对齐而尚未使用的内
存，我们认为严格讨论空间开销并没有很大的
意义
我们认为去符号化的代码片段可以单独插入进代码任何位置，并能显著增加约束求解
器的求解时间，我们做了一些简单的实验来验证这一想法
# 单独使用去符号化
不透明谓词
原程序Angr求解时间
去符号化后的求解时间
x * (x + 1) % 2 != 0
 3h （无结果返
回）
符号变量个数增加带来的时间增长是线性的，但如果各符号变量之间并不是独立的，
而是互相存在约束关系，那么带来的时间增长就是指数形式的
Part II  解决方案-安全计算
Secure Multi-party Computation
多方安全计算：在无可信第三方情况下，通过多方共同参与，安全地完成某种协同计算。
•
基于噪声
•
差分隐私，掩盖原始数据
•
不基于噪声
•
密码学方式
•
同态加密
•
混淆电路
•
… …
混淆电路(Garbled Circuit)
由百万富翁问题我们可以引入到混淆电路，在将安全计
算函数编译成布尔电路的形式后，加密打乱真值表，从
在现电路的正常输出的情况下，不泄露参与计算的双方
私有信息
Alice(资产X亿)
X、Y为1~10 以内的数
姚氏百万富翁
Bob (资产Y亿)
找到对应自己
财富
十个箱子编号1~10
根据自己的财富值
多于自己的放苹果
一样的放香蕉
少的放橘子
上锁
销毁其余的箱子，撕去编号，将上锁的箱子给 Alice
开锁
根据箱子中的水果判断谁的钱更多
Alice(资产X亿)
选取公钥
X、Y为1~10 以内的数
姚氏百万富翁
Bob (资产Y亿)
选取大数n
使用公钥机密
N
密文c=N-Y
对 c+i 进行解密后模p
(i=1~10)
前X个不变
其余+1
判断：kY≡n (mod p)
处理后的数列{k1,k2,k3,...,k10}及 p
是：Y≤X
否：Y>X
混淆电路
电路用户
电路设计者
安全计算函数 f
f(a,b)
数据 b
数据 a
混淆电路基本协议：
•
Alice 生成混淆电路
•
Alice 和 Bob 进行通信
•
Bob 计算生成的混淆电路
•
分享结果
混淆电路
a
b
c
xor
xor
xor
and
•
Alice 生成混淆电路，并对每一个模块的结果生成两个l长
度的字符串X0,i、X1,i分别对应逻辑上的 0、1
•
对每一个逻辑门的真值表用X0,i、X1,i替换、并在替换完成
后进行对称加密
•
其中，加密的秘钥对应逻辑门真值表的两个输入
•
打乱真值表
同态加密(Homomorphic encryption)
同态加密在代码保护中的应用
同态加密概述
Dec(X+Y)
=
Dec(X)+Dec(Y)
Decrypt
X+Y
X
Y
Decrypt
Decrypt
Dec(X)
Dec(Y)
Dec(X·Y)
=
Dec(X)·Dec(Y)
Decrypt
X·Y
X
Y
Decrypt
Decrypt
Dec(X)
Dec(Y)
加法同态
乘法同态
Craig Gentry
算法构造
于是可以在不公开 Enc1 和 Enc2 的解密方式的情况下，仅公开 Dec3，来实现对代码的加密
这在 Enc1、Enc2 采用相同的同态加密算法时可以实现
f'(x)=Enc2(f(x)) 
Enc3(B)=B'=f''(A) 
Obfuscate 
f''(x) 
A'=Enc1(A) 
Enc3(B) 
Dec3(B') 
整体流程
A 
f(x) 
B 
A 
A'=Enc1(A) 
Enc3(B)
=B’
=f''(A) 
f(x) 
f'(x)=Enc2(f(x)) 
f''(x) 
Enc3(B) 
Dec3(B')
B
效果
A 
f(x) 
B 
A 
A'=Enc1(A) 
Enc3(B)
=B’
=f''(A) 
f(x) 
f'(x)=Enc2(f(x)) 
f''(x) 
Enc3(B) 
Dec3(B')
B
我们可以使得：
蓝色部分的数据是用户可直接得到的
绿色部分是会提供在程序里
而未标注的将会在设计完成后删去
未来展望
在现阶段的测试中，同态加密所需的开销相对较大，目前采取的办法是通过将程序分段来进
行加密保护，这一定程度上也会带来安全隐患。
在未来，我们有着以下两个研究方向：
•
对同态算法进行改进
•
与电路相结合，对运算进行提速及优化
# 谢谢大家 & 问答环节
程瑞
昵称：
在野武将
ID：
chengrui191954
对我们的研究感兴趣？
欢迎添加我们的微信进一步交流！
在研究过程中，我们得到了许多老师的帮助，在此表示感谢
徐辉 @ 复旦大学计算机学院
赵川 @ VXProtect研究团队