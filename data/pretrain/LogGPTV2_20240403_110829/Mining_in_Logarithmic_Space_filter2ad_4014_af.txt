ğ‘†.
We first observe that no query in ğ‘Š â€² could have suppressed a
ğ‘„-block on C. As in the proof of Lemma 6.6, in such a case there
would exist a set of consecutive rounds |ğ‘†âˆ—| â‰¥ ğœ† such that ğ‘Œ (ğ‘†âˆ—) â‰¤
ğ‘(ğ‘†âˆ—). This contradicts the last item of Lemma 6.4.
From this observation and the Unsuppressibility Lemma, there
1âˆ’ğ‘“ + ğœ–) blocks that the ad-
are at least ğ‘Œ (ğ‘†) âˆ’ 2ğ‘(ğ‘Š ) âˆ’ 2ğœ†ğ‘“ ( ğ‘¡
versary cannot suppress. Each of these is a ğ‘„-block independently
1âˆ’ğ‘“ +ğœ–)  â„“â€². Assume â€”towards a contradictionâ€” that
â„“  (1 âˆ’ ğœ–)ğ‘|ğ‘ˆ |.
Theorem 6.10 (Succinctness). In a typical execution with ğ‘¡  ğœ†. Applying the Unsuppressibility Lemma, we ob-
tain that at least |ğ‘†| â‰¥ ğ‘|ğ‘ˆ | = ğ‘|D[â„“]| âˆˆ Î©(ğœ†) rounds of ğ‘ˆ must
have been uniquely successful and belong to the chain of every
honest party. Therefore |D[â„“]â†‘â„“+1 | â‰¥ (1âˆ’ğœ–) |ğ‘† |
2 . By the definition
of â„“ this is impossible.
Case 2: 0 â‰¤ ğœ‡ < â„“. By maximality of ğœ‡, we have |D[ğœ‡ + 1]| âˆˆ
ğ‘‚(ğœ†), but |D[ğœ‡]| âˆˆ Î©(ğœ†2). By the definition of D[ğœ‡] = C[: âˆ’ ğ‘˜]â†‘ğœ‡
[âˆ’2ğ‘š:] âˆª C[: âˆ’ ğ‘˜]â†‘ğœ‡ {C[: âˆ’ ğ‘˜]â†‘ğœ‡+1 [âˆ’ğ‘š]:}, clearly |C[: âˆ’ ğ‘˜]â†‘ğœ‡
[âˆ’2ğ‘š:]| = 2ğ‘š so necessarily C[:âˆ’ ğ‘˜]â†‘ğœ‡ {D[ğœ‡ + 1][âˆ’ğ‘š]:} âˆˆ Î©(ğœ†2).
Therefore there exist blocks ğ´ and ğµ in D[ğœ‡+1] and D[ğœ‡] such that
|D[ğœ‡ + 1]{ğ´:ğ‘}| = 1, but |D[ğœ‡]{ğ´:ğ‘}| âˆˆ ğœ”(ğœ†). Similarly to case 1,
consider the rounds ğ‘¢0 and ğ‘¢1 during which blocks ğ´ and ğ‘ were
generated respectively and the set of consecutive rounds ğ‘ˆ from ğ‘¢0
to ğ‘¢1 with |ğ‘ˆ | âˆˆ ğœ”(ğœ†). Using the Unsuppressibility Lemma, there
must exist a set of uniquely successful rounds |ğ‘†| â‰¥ ğ‘|ğ‘ˆ | whose
Session 12D: Decentralized Cryptographic ProtocolsCCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3498blocks have been adopted by all honest parties and of which at
least (1 âˆ’ ğœ–) |ğ‘† |
2 â‰¥ 0 will be of level ğœ‡ + 1. Therefore there must
exist a block between ğ´ and ğ‘ in D[ğœ‡ + 1].
Both cases are contradictions.
â–¡
The previous theorem allows us to make miners reject incoming
state that is too large (more than polylogarithmic) without process-
ing them fully.
We note here that our analysis critically relies on the honest
majority assumption holding throughout the execution. The rea-
son why our verifiers can maintain a valid chain is that, once they
receive a chain C which is the longest, they inductively know that
C[âˆ’ğ‘˜] must contain valid application data snapshot. Then, since
they have all the last ğ‘˜ blocks, they can validate the transactions ğ›¿
on the snapshot obtained before further mining on top of them.
7 DISCUSSION AND FUTURE WORK
We have presented a scheme in which full miners are replaced with
logarithmic-space miners. Our new mining protocol allows miners
to only keep storage growing logarithmically in time. Furthermore,
the data communicated to newly bootstrapped nodes is also loga-
rithmic. We focused on optimizing the consensus data portion of
blockchains (i.e., block headers) without concern for the applica-
tion data portion. Our techniques can be composed with applica-
tion data optimization techniques.
We have proven our scheme succinct and secure against all 1/3
adversaries. Our treatment requires uninterrupted honest computa-
tional majority throughout the execution, is in the static difficulty
model, works only for proof-of-work blockchains, and requires mod-
ifications to the blockchain protocol for deployment. Let us discuss
these aspects of our construction.
Temporary dishonest majority. One important difference be-
tween our scheme and the existing blockchain protocols is that
traditional full nodes are able to verify the whole state evolution
of the system from genesis. This allows them to recover in case of
temporary dishonest majority [1, 5], while our system cannot do
so. Let us consider what could happen in case an adversary tem-
porarily has the upper hand in a blockchain where everybody is
mining using our protocol. Let C denote the chain of the honest
parties that has converged. The adversary begins mining on top of
the honest tip. She eventually produces ğ‘˜ + 1 new blocks on top
of C[âˆ’1], generating an adversarial chain Câˆ—, prior to the honest
parties advancing by ğ‘˜ + 1 blocks â€” a Common Prefix violation.
In the block Câˆ—[âˆ’ğ‘˜ âˆ’ 1], the adversary places an invalid snapshot;
say, a snapshot in which she owns a lot of money. The rest of the
blocks in Câˆ—[âˆ’ğ‘˜:] are filled with valid transactions. This adversary
can then compress this consensus state into a convincing proof,
as state transitions buried ğ‘˜ + 1 blocks beyond the tip are never
checked. As soon as the honest parties transition to this adversar-
ial chain, the attack concludes, and no more adversarial supremacy
is required. It is critical to understand what assumptions our pro-
tocol mandates: An uninterrupted honest majority throughout the
execution. It remains an open question whether it is possible to
construct logarithmic space mining protocols that can withstand
temporary adversarial supremacy.
Variable difficulty. We have built and analyzed our logarithmic
mining protocol in the constant difficulty setting, i.e., requiring that
the target ğ‘‡ is a constant. We strongly suspect, but have not pro-
vided proof, that similar protocols to ours work in the variable diffi-
culty setting. One important change in the protocol that is required
before it can be adapted to variable difficulty settings is that the ğœ’
portion of the proofs cannot be a constant number of blocks long.
Instead, it must be a suffix which corresponds to sufficient work
having been performed, the difficulty of which must correspond
to the current target. Simply pruning ğ‘˜ blocks long is insufficient.
As such, the verifier must first gauge the difficulty of the network
prior to taking conclusive decisions. An analysis in the variable
difficulty model is beyond the scope of this work. The model re-
quired here would make use of the martingale arguments in the
variable difficulty backbone model [22]. The precise proofs would
need to articulate how the security parameter ğ‘š is related to the
epoch length. We leave such analysis for future work.
Deployment. Our scheme requires the introduction of interlink
pointers to block headers. Some blockchains have already adopted
such headers, namely ZCash [34], ERGO [15], Nimiq, WebDollar.
Ethereum has proposals to adopt such interlinking [11]. Notably,
Bitcoin, while possible [25], does not plan to include such a scheme.
However, it may be possible to introduce these changes using a vel-
vet fork [32, 45]. While velvet forking can enable (superblock and
FlyClient) NIPoPoW clients, it remains an open question whether
it can also be used to transition to light mining.
Comparison to other NIPoPoWs. Our protocol is a Non-Inter-
active Proof of Proof-of-Work, akin to superblock NIPoPoWs [31]
and FlyClient [10]. Our difference with FlyClient is the ability to
generate online proofs, proofs that can be updated as the block-
chain grows. Contrary to our construction, FlyClient requires the
sampling of past blocks to change as new blocks are added to the
tip of the blockchain. This is due to their use of the Fiatâ€“Shamir
heuristic [19]. More concretely, a block that was not sampled in
the past may need to be sampled in the future. In our protocol, pre-
viously pruned blocks never need to be salvaged. As any block has
a potential for future samplability in FlyClient, no blocks can be
discarded, and mining cannot be logarithmic. The construction of
superblock NIPoPoWs [31] is similar to ours. However, their con-
struction is not both succinct and secure against all adversaries. In
particular, their certificates of badness allow an adversary to pump
the storage state required from logarithmic to linear with the ap-
propriate attack. We are thus the first to propose a NIPoPoW which