0024446789
10 reverse
10987654321
qsort
12345678910
data now is the time for all good men
hsort
all for good is men now the time
性能.iBort所执行的操作次数取决于n的值，即待排序的元素个数，以及它们原来的排列顺序，插
入排序是平方级算法，也就是说，在最坏的情况下，随着元素个数的增加，算法的运行时间将以二次方的
碰巧就处于一种基本有序的状态，那么程序的工作量就会少很多，于是运行时间将会按照线性增长，线性
增长指的是运行时间与元素的个数成正比，
158
---
## Page 164
第七章算法实验
156
下面这副图显示了isort面对三种类型的数据时的性能变化情况，这三种类型分别是：逆序序列，
随机序列，以及同一个元素组成的序列，我们计算了比较和交换的次数，对于一个梅序过程来说，这是两
个很客观的指标，正如你所看到的那样，逆序序列拥有最差的性能，随机序列居中，而同一元素序列表现
出了最佳的性能.有序序列的性能表现（在图中没有显示出来）和同一元素序列非常接近
10000
8000
INSERTIONSORT
reverse-sorted
6000
Comparisons
+Exchanges
4000
random
2000
cqual-clement
0
T
0
20
40
60
80
100
Number of elements
总得来说，插入排序适用于元素个数较少的情况，当元素个数过多时，该算法的性能就会快速下降，
除非输入数据基本有序
通过为每个排序函数添加两个计数器，我们就可以为上面的图，以及本章中的其他图生成所需要的
数据，其中一个计算比较的次数，另一个计算交换的次数，这是带有计数功能的isort函数：
function isort (A,n,
i,j,t) {# insertion sort
for (i = 2; i  1 &6 ++comp &&
A[j-1]>A[j] && ++exch;j--){
#swap A[j-1]and A[j]
t = A[j-1]; A[j-1] = A[j]; A[j] = t
计数操作都放在内层for错环的条件判断部分完成.由&&连接的条件判断，按照从左到右的顺序进行
求值，直到某一项为假，表达式++comp总是为真（这里必须使用前继形式的自增运算符），于是，数组中
的元素每比较一次，comp的值就加1，递增操作在比较之前完成.当且仅当某两个元素被交换时，exch
的值才会加1.
159
---
## Page 165
第七章算法实验
157
下面的程序用于组织测试，以及为坐标图准备数据，同样，它的功能相当于一个微型编程语言，可以
灵活地指定参数.
# test framework for sort performance evaluation
input: lines with sort name, type of data, sizes...
#
output: name, type, size, comparisons, exchanges, c+e
{
for (i = 3; i 
D,此时需要递增last，并交换A[last]与A[i]，最后再递增i.按照这种方式，一旦所有的元素都处
理完毕，我们需要交换A[left]与A[last].到这里，我们已经完成了一次划分，此时的数组看起来就
像这样：
161
p
left
last
right
现在，我们对左边的子数组与右边的子组执行同样的操作
假设我们对下列8个元素进行快速排序：
81635247
---
## Page 167
第七章算法实验
159
第一步我们可能选择4作为划分元素，接下来，划分操作会把数组重新排列成
21 34568 7
然后再递归地对子数组213与5687进行快速排序，当子数组的元素个数少于2时，递归过程就
会停止，
下面程序所包含的函数g8ort实现了快速排序算法，我们可以用插入排序的测试例程对该程序进
行测试
#quicksort
{A[NR]= $0 }
END ( qsort (A, 1, NR)
for (i = 1; i = right)# do nothing if array contains
return
# less than two elements
swap(A, left, left + int((right-left+1) *rand()))
last = left# A[left] is now partition element
for (i = left+l; i <= right; i++)
if (A[i] < A[left])
swap(A, ++last, i)
swap(A, left, last)
qsort(A, left, last-1)
qsort(A, last+1, right)
function swap(A,i,j，t)(
t = A[i]; A[i] = A[j]; A[j] = t
性能.gsort所执行的操作次数取决于数组划分时的均匀程度，如果数组划分每次都很平均，那么
程序的运行时间与nlogn成正比.于是，如果数据规模变为原来的两倍，那么程序的运行时间只会在原
162
来两倍的基础上再稍微多出一点
在最坏的情况下，划分操作的结果会出现其中一个子数组长度为0的情况，比如，当所有元素都相同
时，就会出现这种情况，这时候，快速排序的时间复杂度就会退化到二次方，幸运的是，对于随机数据来
说，不会出现这种极不均匀的划分，下面这张图显示了快速排序面对三种类型的输入数据时的性能表现
---
## Page 168
第七章算法实验
160
（在测试插入排序时，也用到了这三种类型的数据）正如你所看到的那样，随着元素个数的增加，同元素
序列的操作次数比另外两种序列的操作次数增长得快.
6000
QUICKSORT
4000
Comparisons
+Exchanges
cqual-element
2000
random
reverse-sorted
1
T
T
0
20
40
60
80
001
Numberofelements
Exercise 7.4为gsort添加计数语句，计算比较操作和交换操作的执行次数，你得到的结果是否和我
们的类似？
Exereise7.5记录程序的运行时间，而不是操作次数，运行时间的统计图是否和操作次数的相网？用大
一点的例子作测试，看看其统计图还是不是一样的，
堆排序
基本概念.优先级队列（priorityqueue)是一种数据结构，用于存储和检索元素.它有两种基本操作：
往队列中插入一个新元素，以及从队列中提取最大的元素，这表明优先级队列可以用来排序：首先把所
有的元素插入到队列中，然后每次抽取一个元素，因为每次移除的都是最大的元素，所以元素是以降序地
方式从队列中抽取出来，这种排序方法叫作堆排序，由J.W.J.Williams和R.W.Floyd在60年代早
期提出.
163
堆排序使用一种称为堆（heap)的数据结构来维护优先级及列，我们可以把堆想像成一棵二叉树，但
是带有两条额外的性质：
1.树是高度平衡的：叶子结点最多只在两个不同的层次上出现，另外，位于最底层（距离根结点最远的
层次）的叶子尽量靠左排列；
2.树是部分有序的：每个结点的值大于或等于它的孩子结点。
这是带有10个元素的堆：
---
## Page 169
第七章算法实验
161
69
63
17
29
37
28
堆具有两个非常重要的特性，第一个特性是，如果有n个结点，那么所有的从根结点到叶子结点的
路径长度都不会大于log2n.第二个特性是，具有最大值的元素总是在根结点（这个位置称为“堆顶")
如果我们用一个数组A来模拟堆，那么就不需要构造显式的二叉树，树中的结点按照宽度优先遍历
于是，上面那棵树对应的数组A就是：
A[1] A[2] A[3] A[4 ]
A[5]A[6]A[7]
]A[8]A[9]A[10]
76
72
34
59
89
17
29
28
堆的部分有序性质指的是元素A[i]大于或等于它的孩子结点A[2i]与A[2i+1]，如果只有一个孩
子的话，就那大于或等于A[2i].如果某个数组满足这个条件，我们就说这个数组具有“堆属性”
实现（Implementation）.堆排序由两个阶段组成：构造堆，以及按暖序从堆中提取元素.两个阶段
都要调用函数heapify（A,i,J)，使得子数组A[i],A[i+1],.,A[】其有堆属性（假设A[i+1],-，
比它的孩子大，那么函数就直接返回；否则，交换A[i】和它的最大孩子，然后再对孩子重复这个基本操
作.
在第一个阶段，堆排序通过调用heapify(A,i,n)(i从n/2递减到1),把数组转化成一个堆.
164
第2个阶段开始时，i被赋值为n，然后重复执行以下三个步骤：首先，把堆的最大元素A[1]与
A[i]作交换，A[i]是堆中最靠右的元素，然后，堆的元素个数减1（即i减1).这两个步骤相当于从堆中
移除最大元素，注意到，这样做的结果是数组中最后的n-i+1个元素处于有序状态.最后，对数组A的前
i-1个元素调用heapify（A,1,i-1）.
这三个步骤一直重复到堆中只剩下一个元素为止，而这个元素其实就是序列中的最小值，由于数组
中剩下的元素按照升序排列，所以当操作结束时，序列就是有序的了，在操作过程中，数组看起来就像这
样：
heap
sorted
1
n
数组中从1到i的元素具有堆属性，从i+1到n是数组中最大的n-i个元素，按照升序排列.开始时，
i=n，因此数组中没有已排序的部分。
考虑上面展示的元素所组成的数组，该数组已经具有堆属性，在第二个阶段的第一个步骤，我们交换
元素76和28：
---
## Page 170
第七章算法实验
162
28 72 34 59 63 17 29 37 331 76
在第2个步骤，我们把堆的大小递减到9.然后在第3个步骤中，通过一系列的交换操作，把28移动到
合适的位置，从而维持住前9个元素的堆属性：
72 63 34 59 28 17 29 37 331 76
我们可以把这个过程可视化：让元素28沿着二叉树的路径，从根结点开始，朝着叶子结点方向，逐渐向
下渗透，直到到达这祥一个的结点：它的孩子小于或等于28：
72
29
59
/
28
17
29
3733