where equations are ğ‘„2ğ‘˜,ğ›½ğ‘–,ğ‘– = ğ‘ğ‘˜
variables are the ğ‘–ğ‘¡â„ column of T , i.e., ğ‘¡1ğ‘–, Â· Â· Â· , ğ‘¡ğ‘£ğ‘–.
(2) Suppose ğ‘¥ elements of ğ‘–ğ‘¡â„ column of T are known/recovered.
Define Ağ‘–(ğ‘¥) as a reduced system of Ağ‘– by inserting the ğ‘¥
recovered bits into Ağ‘–. Note that, inserting ğ‘¥ variables into
Ağ‘– reduces the system to ğ‘€ğ‘„(ğ‘£ âˆ’ ğ‘¥, ğ‘š) from ğ‘€ğ‘„(ğ‘£, ğ‘š).
(3) Define Bğ‘–,ğ‘— as the set of ğ‘š equations of 2ğ‘£ variables, ğ‘€ğ‘„(2ğ‘£, ğ‘š)
3 ( ğ‘—, ğ‘–) for ğ‘˜
where the equations are ğ‘„2(ğ‘˜,ğ›½ğ‘–,ğ‘—) = ğ‘ğ‘˜
from 1 to ğ‘š and variables are the ğ‘–ğ‘¡â„ and ğ‘—ğ‘¡â„ columns of T ,
i.e., ğ‘¡1ğ‘–, Â· Â· Â· , ğ‘¡ğ‘£ğ‘–, ğ‘¡1ğ‘— , Â· Â· Â· , ğ‘¡ğ‘£ ğ‘—.
(4) Suppose ğ‘–ğ‘¡â„ column of T , i.e. ğ‘¡1ğ‘–, Â· Â· Â· , ğ‘¡ğ‘£ğ‘–, is known. Inserting
these variables into Bğ‘–,ğ‘— reduces the system from quadratic
ğ‘€ğ‘„(2ğ‘£, ğ‘š) system to a linear ğ‘€ğ¿(ğ‘£, ğ‘š) system, where the
unknowns are ğ‘¡1ğ‘— , Â· Â· Â· , ğ‘¡ğ‘£ ğ‘—. We denote the insertion of the ğ‘–ğ‘¡â„
column of T into Bğ‘–,ğ‘— by Bğ‘–,ğ‘— (ğ‘¡ğ‘–, 0). Note that, this reduces
the hard problem ğ‘€ğ‘„(2ğ‘£, ğ‘š) into underdetermined linear
ğ‘€ğ¿(ğ‘£, ğ‘š) system.
(5) Suppose ğ‘¥ elements of the ğ‘—ğ‘¡â„ column of T and the entire ğ‘–ğ‘¡â„
column of T are known. Inserting these known variables into
Bğ‘–,ğ‘— reduces the system from ğ‘€ğ‘„(2ğ‘£, ğ‘š) to ğ‘€ğ¿(ğ‘£ âˆ’ ğ‘¥, ğ‘š).
The new system is denoted by Bğ‘–,ğ‘— (ğ‘¡ğ‘–, ğ‘¥). If ğ‘¥ â‰¥ ğ‘£ âˆ’ ğ‘š then
the system reduces to an overdetermined linear system from
an underdetermined one. Therefore, the new system has a
unique solution and is efficiently solvable.
4.3 A Practical Divide and Conquer Attack
We are going to use bit-tracing attack as an oracle to recover some
bits of some column in matrix T . Informally, QuantumHammer
proceeds as follows:
4.3.1 Bit-tracing (Section 3): Suppose ğ‘¥ bits in some column of
T is enough to reduce ğ‘€ğ‘„(ğ‘£, ğ‘š) system into a solvable ğ‘€ğ‘„(ğ‘£ âˆ’ ğ‘¥, ğ‘š)
system. When ğ‘¥ bits are recovered via bit-tracing in some column,
we stop bit-tracing and recover the bits as explained in Section 3.
Apply bit-tracing attack, and recover bits of T until the highest
number of recovered bits from a column is ğ‘£ âˆ’ ğ‘š. Pick the high-
are ğ‘¥1, ğ‘¥2, ğ‘¥3 and ğ‘¥4 bits in ğ›¼1, ğ›¼2, ğ›¼3 and ğ›¼4ğ‘¡â„ columns of T ,
(cid:7) columns. Assume the highest number of recovered bits
est(cid:6) ğ‘£
ğ‘š
different columns of T . But, having(cid:6) ğ‘£
(cid:7) columns of T is enough to
respectively. Note that, bit-tracing recovers additional bits from
reduce the MQ systems into ML systems and can efficiently solve
it. Therefore, we do not need to use the remaining bits recovered
by bit-tracing in different columns of T .
4.3.2 Quadratic Steps (Algorithm 3):
ğ‘š
2
able ğ‘€ğ‘„(ğ‘£ âˆ’ ğ‘¥2, ğ‘š) ğ‘€ğ¿(ğ‘£ âˆ’ ğ‘¥2, ğ‘š). The solution of the re-
(1) Consider Ağ›¼1, more specifically, consider the elements of
ğ›½ğ›¼1,ğ›¼1 = (ğ›¼1 âˆ’ 1)ğ‘š + ğ›¼1(ğ›¼1+1)
ğ‘¡â„ column of ğ‘„2 which are
3 (ğ›¼1, ğ›¼1) terms of ğ‘ƒğ‘˜
ğ‘ğ‘˜
3 for ğ‘˜ from 1 to ğ‘š and ğ›¼1 is the highest
column of T . Inserting ğ‘¥1 recovered bits into the system
Ağ›¼1 reduces the ğ‘€ğ‘„(ğ‘£, ğ‘š) system into ğ‘€ğ‘„(ğ‘£ âˆ’ ğ‘¥1, ğ‘š). We
recover the remaining ğ‘£ âˆ’ ğ‘¥1 elements of ğ›¼1ğ‘¡â„ column T
which are ğ‘¡1ğ›¼1, Â· Â· Â· , ğ‘¡ğ‘£ğ›¼1.
(2) Insert recovered ğ›¼1ğ‘¡â„ column of T into Bğ›¼1,ğ›¼2 and ğ‘¥2 recov-
ered bits of ğ›¼2ğ‘¡â„ column of T into the systems Bğ›¼1,ğ›¼2 and
Ağ›¼2 reducing the systems into Bğ›¼1,ğ›¼2(ğ‘¡ğ›¼1,ğ‘¥2) and Ağ›¼2(ğ‘¥2),
respectively. Thus, the system reduces to practically solv-
duced system gives the full ğ›¼2ğ‘›ğ‘‘ column of T which are
ğ‘¡1ğ›¼2, Â· Â· Â· , ğ‘¡ğ‘£ğ›¼2. Note that, even though solving ğ‘€ğ‘„(ğ‘£ âˆ’ ğ‘¥2, ğ‘š)
is harder than solving ğ‘€ğ‘„(ğ‘£ âˆ’ ğ‘¥1, ğ‘š), there are ğ‘š additional
linear equations from ğ‘€ğ¿(ğ‘£ âˆ’ ğ‘¥2, ğ‘š) which decrease the
number of unknowns from ğ‘£ âˆ’ ğ‘¥2 to ğ‘£ âˆ’ ğ‘¥2 âˆ’ ğ‘š. Therefore,
solve than ğ‘€ğ‘„(ğ‘£ âˆ’ ğ‘¥1, ğ‘š).
(3) Apply the same strategy to ğ›¼3ğ‘¡â„ column of T , i.e., insert ğ›¼1
and ğ›¼2ğ‘¡â„ columns of T which are recovered in the first two
steps, into the systems Bğ›¼1,ğ›¼3, Bğ›¼2,ğ›¼3 and Ağ›¼3. The com-
ğ‘€ğ‘„(ğ‘£ âˆ’ ğ‘¥2, ğ‘š) ğ‘€ğ¿(ğ‘£ âˆ’ ğ‘¥2, ğ‘š) is a much easier system to
plexity reduces to Bğ›¼1,ğ›¼3(ğ‘¡1, ğ‘¥3) Bğ›¼2,ğ›¼3(ğ‘¡2, ğ‘¥3) Ağ›¼3(ğ‘¥3).
Thus, the system reduces to ğ‘€ğ¿(ğ‘£ âˆ’ ğ‘¥3, 2ğ‘š) ğ‘€ğ‘„(ğ‘£ âˆ’ ğ‘¥3, ğ‘š)
which has the solution of ğ‘¥ğ‘¡â„
3 unknowns from the ğ›¼3 column
which are ğ‘¡1ğ›¼3, Â· Â· Â· , ğ‘¡ğ‘£ğ›¼3. Note that, the solution of the system
is equivalent to the solution of ğ‘€ğ‘„(ğ‘£ âˆ’ ğ‘¥3 âˆ’ 2ğ‘š, ğ‘š) which
is much easier than the previous steps.
(4) The same strategy can be applied to recover ğ›¼4ğ‘¡â„ column of
T by using previously recovered columns of T in addition
to recovered ğ‘¥4 bits of the ğ›¼4ğ‘¡â„ column in bit-tracing attack.
Inserting the known elements will reduce the complexity to
since it is equivalent to ğ‘€ğ‘„(ğ‘£ âˆ’ ğ‘¥4 âˆ’ 3ğ‘š, ğ‘š). The solution
gives us ğ›¼4ğ‘¡â„ column elements ğ‘¡1ğ›¼3, Â· Â· Â· , ğ‘¡ğ‘£ğ›¼3.
ğ‘€ğ¿(ğ‘£ âˆ’ ğ‘¥4, 3ğ‘š) ğ‘€ğ‘„(ğ‘£ âˆ’ ğ‘¥4, ğ‘š). This is a solvable system
(cid:7) recovered columns of T are enough to
(cid:7) steps,(cid:6) ğ‘£
After(cid:6) ğ‘£
(cid:7) columns
how one can reduce any small MQ system to a ML if(cid:6) ğ‘£
(cid:7) recov-
4.3.3 Linear Steps (Algorithm 4): Suppose there are(cid:6) ğ‘£
reduce the smaller MQ systems of remaining columns into overde-
termined ML systems. In the following steps, we are going to explain
ered columns of T from the quadratic steps. Inserting the bits of
recovered columns into the related systems will give us the follow-
ing reduced ML system:
are recovered.
ğ‘š
ğ‘š
ğ‘š
ğ‘š
ğ‘šâŒ‰
âŒˆ ğ‘£
ğ‘–=1
Bğ›¼ğ‘–,ğ›½(ğ‘¡ğ‘–, 0)
where ğ›¼ğ‘–â€™s are the column numbers of recovered columns of T
and ğ›½ is the column number of attacked column of T . This gives
(cid:7) Â· ğ‘š) system which can be solved
us an overdetermined ğ‘€ğ¿(ğ‘£,(cid:6) ğ‘£
(cid:7) steps.
one by one in ğ‘š âˆ’(cid:6) ğ‘£
efficiently.
Note that, by the linear steps, we can recover the rest of T columns
ğ‘š
ğ‘š
âŠ² high recovered columns
âŠ² from Bit-tracing
Algorithm 3: Quadratic_Steps
Input: (ğ›¼1, ğ‘¥1),Â· Â· Â· ,(ğ›¼ğœ…, ğ‘¥ğœ…)
Output: (ğ‘¡ğ›¼ğ‘– , Â· Â· Â· , ğ‘¡ğ›¼ğœ…) - entire columns of input vectors
1 Ağ›¼1(ğ‘¥1) â† ğ‘€ğ‘„_ğºğ‘’ğ‘›(ğ›¼1, ğ‘¥1)
2 ğ‘¡ğ›¼1 â† ğ¸ğ‘ğ‘›_ğ‘†ğ‘œğ‘™ğ‘£ğ‘’ğ‘Ÿ(Ağ›¼1(ğ‘¥1), âˆ…)
Ağ›¼ğ‘– (ğ‘¥ğ‘–) â† ğ‘€ğ‘„_ğºğ‘’ğ‘›(ğ›¼ğ‘–, ğ‘¥ğ‘–)
for ğ‘— from 1 to i-1 do
3 for ğ‘– from 2 to ğœ… =(cid:6) ğ‘£
âŠ² Quadratic Part
(cid:7) do
Bğ›¼ğ‘–,ğ›¼ ğ‘— (ğ‘¥ğ‘–, ğ‘¡ ğ‘—) â† ğ‘€ğ¿_ğºğ‘’ğ‘›((ğ›¼ğ‘–, ğ‘¥ğ‘–), (ğ›¼ ğ‘— , ğ‘¡ ğ‘—))
4
5
6
ğ‘š
ğ‘¡ğ‘– â† ğ¸ğ‘ğ‘›_ğ‘†ğ‘œğ‘™ğ‘£ğ‘’ğ‘Ÿ(Ağ›¼ğ‘–(ğ‘¥ğ‘–),ğ‘–âˆ’1
end
ğ‘—=1 Bğ›¼ğ‘–,ğ›¼ ğ‘— (ğ‘¥ğ‘–, ğ‘¡ ğ‘—))
âŠ² Linear Part
7
8
9
10 end
Algorithm 4: Linear_Steps
Input: (ğ›¼1, ğ‘¡ğ›¼1),Â· Â· Â· ,(ğ›¼ğœ…, ğ‘¡ğ›¼ğœ…)
Output: (ğ‘¡1, Â· Â· Â· , ğ‘¡ğ‘š)
1 For ğ‘– from 1 to m
2 for ğ‘— from 1 to ğœ… do
3
4 end
âŠ² Recovered Columns
âŠ² Columns of T
âŠ² except {ğ›¼1, Â· Â· Â· , ğ›¼ğœ…}
Bğ‘–,ğ›¼ ğ‘— (âˆ…, ğ‘¡ğ›¼ ğ‘—) â† ğ‘€ğ¿_ğºğ‘’ğ‘›((ğ‘–, âˆ…), (ğ›¼ ğ‘— , ğ‘¡ğ›¼ ğ‘—)) âŠ² âˆ¼ ğ‘€ğ¿(ğ‘£, ğ‘š)
âŠ² âˆ¼ ğ‘€ğ¿(ğ‘£, ğœ… Â· ğ‘š)
5 ğ‘¡ğ‘– â† ğ¸ğ‘ğ‘›_ğ‘†ğ‘œğ‘™ğ‘£ğ‘’ğ‘Ÿ(âˆ…,ğœ…
ğ‘—=1 Bğ‘–,ğ›¼ ğ‘— (0, ğ‘¡ğ›¼ ğ‘—))
return ğ‘¡ğ‘–
Algorithm 5: MQ_Gen
Input: ğ‘–, ğ‘¥
Output: Ağ‘–(ğ‘¥)
1 ğ´ğ‘– â† ğºğ‘’ğ‘›ğ‘€ğ‘„(ğ‘–)
2 ğ´ğ‘–(ğ‘¥) â† ğ¼ğ‘›ğ‘ ğ‘’ğ‘Ÿğ‘¡ğ‘‰ ğ‘’ğ‘(ğ´ğ‘–, ğ‘¥)
3 return ğ´ğ‘–(ğ‘¥)
âŠ² ğ‘–: column# in T ,
âŠ² ğ‘¥: known elements in ğ‘–ğ‘¡â„ column of T
âŠ² use Equation 3 for ğ‘– = ğ‘—
âŠ² Section 4.2,item 2
5 EXPERIMENTAL RESULTS
Bit-tracing:
We have attacked the constant-time AVX2 reference implementa-
tion of LUOV-7-57-197 [44] on a Haswell system equipped with
Intel Core i7-4770 CPU @ 3.40GHz, 2 GBytes DDR3 DRAM, model
Samsung (M378B5773DH0-CH9). Pre-processing (templating) step
is performed in 5.7 hours to find 17,129 physical addresses vulnera-
ble to the bit-tracing attack. After that, 16 hours of online phase is
carried out in which the victim is running and performing signing
Algorithm 6: ML_Gen
Input: (ğ‘–, ğ‘¥),( ğ‘—, ğ‘¦)
Output: Bğ‘–,ğ‘— (ğ‘¥, ğ‘¦)
1 ğµğ‘–,ğ‘— â† ğ¸ğ‘ğ‘›ğºğ‘’ğ‘›(ğ‘–, ğ‘—)
2 ğµğ‘–,ğ‘— (ğ‘¥, ğ‘¦) â† ğ¼ğ‘›ğ‘ ğ‘’ğ‘Ÿğ‘¡ğ‘‰ ğ‘’ğ‘(ğµğ‘–,ğ‘— , ğ‘¥, ğ‘¦)
3 return Bğ‘–,ğ‘— (ğ‘¥, ğ‘¦)
âŠ² ğ‘–, ğ‘—: column# in T ,
âŠ² ğ‘¥, ğ‘¦: known elements in the
âŠ² ğ‘¥, ğ‘¦ğ‘¡â„ columns of T , respectively
âŠ² Section 4.2,item 3
âŠ² Section 4.2,item 5
Algorithm 7: Eqn_Solver
ğ‘—=1 Bğ‘–,ğ‘— (ğ‘¥, ğ‘¦ ğ‘—)
Output: ğ‘¡ ğ‘— or No Result
1 if ğ‘£ âˆ’ ğ‘¥ â‰¤ ğ‘š then Solve Ağ‘–(ğ‘¥)
Input: Ağ‘–(ğ‘¥),ğ‘–âˆ’1
2 if ğ‘£ âˆ’ ğ‘¥ âˆ’ (ğ‘– âˆ’ 1)ğ‘š â‰¤ 0 then Solveğ‘–âˆ’1
Ağ‘–(ğ‘¥) âˆªğ‘–âˆ’1
4 if 0 â‰¤ ğ‘£ âˆ’ ğ‘¥ âˆ’ (ğ‘– âˆ’ 1)ğ‘š â‰¤ ğ‘š then Solve
ğ‘—=1 Bğ‘–,ğ‘— (ğ‘¥, ğ‘¦ ğ‘—)
3
5 else break
6 return ğ‘¡ ğ‘—
âŠ² âˆ¼ ğ‘€ğ‘„(ğ‘£ âˆ’ ğ‘¥, ğ‘š)
ğ‘—=1 Bğ‘–,ğ‘— (ğ‘¥, ğ‘¦ ğ‘—)
âŠ² âˆ¼ ğ‘€ğ‘„((ğ‘– âˆ’ 1)ğ‘š, ğ‘£ âˆ’ ğ‘¥)
âŠ² âˆ¼ ğ‘€ğ‘„(ğ‘£ âˆ’ ğ‘¥ âˆ’ ğ‘š, ğ‘š)
âŠ² No Solvable System
ğ‘˜, ğ‘„2
Algorithm 8: Matrix_Gen
Input: ğ‘„1
Output: ğ‘ƒ3
1 ğ‘ƒğ‘˜1 â† ğ‘“ ğ‘–ğ‘›ğ‘‘ğ‘ƒğ‘˜1(ğ‘„1, ğ‘˜)
2 ğ‘ƒğ‘˜2 â† ğ‘“ ğ‘–ğ‘›ğ‘‘ğ‘ƒğ‘˜2(ğ‘„1, ğ‘˜)
3 ğ‘ƒğ‘˜3 â† ğºğ‘’ğ‘›ğ‘ƒğ‘˜3(ğ‘ƒğ‘˜1, ğ‘ƒğ‘˜2, ğ‘˜)
4 ğ‘„2 â† ğºğ‘’ğ‘›ğ‘„2(ğ‘ƒğ‘˜3)
5 return ğ‘ƒ3
ğ‘˜, ğ‘„2
âŠ² [3]
âŠ² [3]
âŠ² âˆ¼ ğ‘€ğ‘„(ğ‘£ âˆ’ ğ‘¥, ğ‘£ âˆ’ ğ‘¥)
âŠ² Equation 4
ğ‘› = ğ‘š
40
43
49
Time
2.7s
12s
11m 33s
ğ‘› = ğ‘š
52
53
54
Time
1h 32m
3h 3m
3h 6m
ğ‘› = ğ‘š
55
56
57