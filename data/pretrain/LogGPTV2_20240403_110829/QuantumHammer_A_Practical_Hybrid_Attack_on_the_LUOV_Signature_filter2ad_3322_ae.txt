where equations are 𝑄2𝑘,𝛽𝑖,𝑖 = 𝑝𝑘
variables are the 𝑖𝑡ℎ column of T , i.e., 𝑡1𝑖, · · · , 𝑡𝑣𝑖.
(2) Suppose 𝑥 elements of 𝑖𝑡ℎ column of T are known/recovered.
Define A𝑖(𝑥) as a reduced system of A𝑖 by inserting the 𝑥
recovered bits into A𝑖. Note that, inserting 𝑥 variables into
A𝑖 reduces the system to 𝑀𝑄(𝑣 − 𝑥, 𝑚) from 𝑀𝑄(𝑣, 𝑚).
(3) Define B𝑖,𝑗 as the set of 𝑚 equations of 2𝑣 variables, 𝑀𝑄(2𝑣, 𝑚)
3 ( 𝑗, 𝑖) for 𝑘
where the equations are 𝑄2(𝑘,𝛽𝑖,𝑗) = 𝑝𝑘
from 1 to 𝑚 and variables are the 𝑖𝑡ℎ and 𝑗𝑡ℎ columns of T ,
i.e., 𝑡1𝑖, · · · , 𝑡𝑣𝑖, 𝑡1𝑗 , · · · , 𝑡𝑣 𝑗.
(4) Suppose 𝑖𝑡ℎ column of T , i.e. 𝑡1𝑖, · · · , 𝑡𝑣𝑖, is known. Inserting
these variables into B𝑖,𝑗 reduces the system from quadratic
𝑀𝑄(2𝑣, 𝑚) system to a linear 𝑀𝐿(𝑣, 𝑚) system, where the
unknowns are 𝑡1𝑗 , · · · , 𝑡𝑣 𝑗. We denote the insertion of the 𝑖𝑡ℎ
column of T into B𝑖,𝑗 by B𝑖,𝑗 (𝑡𝑖, 0). Note that, this reduces
the hard problem 𝑀𝑄(2𝑣, 𝑚) into underdetermined linear
𝑀𝐿(𝑣, 𝑚) system.
(5) Suppose 𝑥 elements of the 𝑗𝑡ℎ column of T and the entire 𝑖𝑡ℎ
column of T are known. Inserting these known variables into
B𝑖,𝑗 reduces the system from 𝑀𝑄(2𝑣, 𝑚) to 𝑀𝐿(𝑣 − 𝑥, 𝑚).
The new system is denoted by B𝑖,𝑗 (𝑡𝑖, 𝑥). If 𝑥 ≥ 𝑣 − 𝑚 then
the system reduces to an overdetermined linear system from
an underdetermined one. Therefore, the new system has a
unique solution and is efficiently solvable.
4.3 A Practical Divide and Conquer Attack
We are going to use bit-tracing attack as an oracle to recover some
bits of some column in matrix T . Informally, QuantumHammer
proceeds as follows:
4.3.1 Bit-tracing (Section 3): Suppose 𝑥 bits in some column of
T is enough to reduce 𝑀𝑄(𝑣, 𝑚) system into a solvable 𝑀𝑄(𝑣 − 𝑥, 𝑚)
system. When 𝑥 bits are recovered via bit-tracing in some column,
we stop bit-tracing and recover the bits as explained in Section 3.
Apply bit-tracing attack, and recover bits of T until the highest
number of recovered bits from a column is 𝑣 − 𝑚. Pick the high-
are 𝑥1, 𝑥2, 𝑥3 and 𝑥4 bits in 𝛼1, 𝛼2, 𝛼3 and 𝛼4𝑡ℎ columns of T ,
(cid:7) columns. Assume the highest number of recovered bits
est(cid:6) 𝑣
𝑚
different columns of T . But, having(cid:6) 𝑣
(cid:7) columns of T is enough to
respectively. Note that, bit-tracing recovers additional bits from
reduce the MQ systems into ML systems and can efficiently solve
it. Therefore, we do not need to use the remaining bits recovered
by bit-tracing in different columns of T .
4.3.2 Quadratic Steps (Algorithm 3):
𝑚
2
able 𝑀𝑄(𝑣 − 𝑥2, 𝑚) 𝑀𝐿(𝑣 − 𝑥2, 𝑚). The solution of the re-
(1) Consider A𝛼1, more specifically, consider the elements of
𝛽𝛼1,𝛼1 = (𝛼1 − 1)𝑚 + 𝛼1(𝛼1+1)
𝑡ℎ column of 𝑄2 which are
3 (𝛼1, 𝛼1) terms of 𝑃𝑘
𝑝𝑘
3 for 𝑘 from 1 to 𝑚 and 𝛼1 is the highest
column of T . Inserting 𝑥1 recovered bits into the system
A𝛼1 reduces the 𝑀𝑄(𝑣, 𝑚) system into 𝑀𝑄(𝑣 − 𝑥1, 𝑚). We
recover the remaining 𝑣 − 𝑥1 elements of 𝛼1𝑡ℎ column T
which are 𝑡1𝛼1, · · · , 𝑡𝑣𝛼1.
(2) Insert recovered 𝛼1𝑡ℎ column of T into B𝛼1,𝛼2 and 𝑥2 recov-
ered bits of 𝛼2𝑡ℎ column of T into the systems B𝛼1,𝛼2 and
A𝛼2 reducing the systems into B𝛼1,𝛼2(𝑡𝛼1,𝑥2) and A𝛼2(𝑥2),
respectively. Thus, the system reduces to practically solv-
duced system gives the full 𝛼2𝑛𝑑 column of T which are
𝑡1𝛼2, · · · , 𝑡𝑣𝛼2. Note that, even though solving 𝑀𝑄(𝑣 − 𝑥2, 𝑚)
is harder than solving 𝑀𝑄(𝑣 − 𝑥1, 𝑚), there are 𝑚 additional
linear equations from 𝑀𝐿(𝑣 − 𝑥2, 𝑚) which decrease the
number of unknowns from 𝑣 − 𝑥2 to 𝑣 − 𝑥2 − 𝑚. Therefore,
solve than 𝑀𝑄(𝑣 − 𝑥1, 𝑚).
(3) Apply the same strategy to 𝛼3𝑡ℎ column of T , i.e., insert 𝛼1
and 𝛼2𝑡ℎ columns of T which are recovered in the first two
steps, into the systems B𝛼1,𝛼3, B𝛼2,𝛼3 and A𝛼3. The com-
𝑀𝑄(𝑣 − 𝑥2, 𝑚) 𝑀𝐿(𝑣 − 𝑥2, 𝑚) is a much easier system to
plexity reduces to B𝛼1,𝛼3(𝑡1, 𝑥3) B𝛼2,𝛼3(𝑡2, 𝑥3) A𝛼3(𝑥3).
Thus, the system reduces to 𝑀𝐿(𝑣 − 𝑥3, 2𝑚) 𝑀𝑄(𝑣 − 𝑥3, 𝑚)
which has the solution of 𝑥𝑡ℎ
3 unknowns from the 𝛼3 column
which are 𝑡1𝛼3, · · · , 𝑡𝑣𝛼3. Note that, the solution of the system
is equivalent to the solution of 𝑀𝑄(𝑣 − 𝑥3 − 2𝑚, 𝑚) which
is much easier than the previous steps.
(4) The same strategy can be applied to recover 𝛼4𝑡ℎ column of
T by using previously recovered columns of T in addition
to recovered 𝑥4 bits of the 𝛼4𝑡ℎ column in bit-tracing attack.
Inserting the known elements will reduce the complexity to
since it is equivalent to 𝑀𝑄(𝑣 − 𝑥4 − 3𝑚, 𝑚). The solution
gives us 𝛼4𝑡ℎ column elements 𝑡1𝛼3, · · · , 𝑡𝑣𝛼3.
𝑀𝐿(𝑣 − 𝑥4, 3𝑚) 𝑀𝑄(𝑣 − 𝑥4, 𝑚). This is a solvable system
(cid:7) recovered columns of T are enough to
(cid:7) steps,(cid:6) 𝑣
After(cid:6) 𝑣
(cid:7) columns
how one can reduce any small MQ system to a ML if(cid:6) 𝑣
(cid:7) recov-
4.3.3 Linear Steps (Algorithm 4): Suppose there are(cid:6) 𝑣
reduce the smaller MQ systems of remaining columns into overde-
termined ML systems. In the following steps, we are going to explain
ered columns of T from the quadratic steps. Inserting the bits of
recovered columns into the related systems will give us the follow-
ing reduced ML system:
are recovered.
𝑚
𝑚
𝑚
𝑚
𝑚⌉
⌈ 𝑣
𝑖=1
B𝛼𝑖,𝛽(𝑡𝑖, 0)
where 𝛼𝑖’s are the column numbers of recovered columns of T
and 𝛽 is the column number of attacked column of T . This gives
(cid:7) · 𝑚) system which can be solved
us an overdetermined 𝑀𝐿(𝑣,(cid:6) 𝑣
(cid:7) steps.
one by one in 𝑚 −(cid:6) 𝑣
efficiently.
Note that, by the linear steps, we can recover the rest of T columns
𝑚
𝑚
⊲ high recovered columns
⊲ from Bit-tracing
Algorithm 3: Quadratic_Steps
Input: (𝛼1, 𝑥1),· · · ,(𝛼𝜅, 𝑥𝜅)
Output: (𝑡𝛼𝑖 , · · · , 𝑡𝛼𝜅) - entire columns of input vectors
1 A𝛼1(𝑥1) ← 𝑀𝑄_𝐺𝑒𝑛(𝛼1, 𝑥1)
2 𝑡𝛼1 ← 𝐸𝑞𝑛_𝑆𝑜𝑙𝑣𝑒𝑟(A𝛼1(𝑥1), ∅)
A𝛼𝑖 (𝑥𝑖) ← 𝑀𝑄_𝐺𝑒𝑛(𝛼𝑖, 𝑥𝑖)
for 𝑗 from 1 to i-1 do
3 for 𝑖 from 2 to 𝜅 =(cid:6) 𝑣
⊲ Quadratic Part
(cid:7) do
B𝛼𝑖,𝛼 𝑗 (𝑥𝑖, 𝑡 𝑗) ← 𝑀𝐿_𝐺𝑒𝑛((𝛼𝑖, 𝑥𝑖), (𝛼 𝑗 , 𝑡 𝑗))
4
5
6
𝑚
𝑡𝑖 ← 𝐸𝑞𝑛_𝑆𝑜𝑙𝑣𝑒𝑟(A𝛼𝑖(𝑥𝑖),𝑖−1
end
𝑗=1 B𝛼𝑖,𝛼 𝑗 (𝑥𝑖, 𝑡 𝑗))
⊲ Linear Part
7
8
9
10 end
Algorithm 4: Linear_Steps
Input: (𝛼1, 𝑡𝛼1),· · · ,(𝛼𝜅, 𝑡𝛼𝜅)
Output: (𝑡1, · · · , 𝑡𝑚)
1 For 𝑖 from 1 to m
2 for 𝑗 from 1 to 𝜅 do
3
4 end
⊲ Recovered Columns
⊲ Columns of T
⊲ except {𝛼1, · · · , 𝛼𝜅}
B𝑖,𝛼 𝑗 (∅, 𝑡𝛼 𝑗) ← 𝑀𝐿_𝐺𝑒𝑛((𝑖, ∅), (𝛼 𝑗 , 𝑡𝛼 𝑗)) ⊲ ∼ 𝑀𝐿(𝑣, 𝑚)
⊲ ∼ 𝑀𝐿(𝑣, 𝜅 · 𝑚)
5 𝑡𝑖 ← 𝐸𝑞𝑛_𝑆𝑜𝑙𝑣𝑒𝑟(∅,𝜅
𝑗=1 B𝑖,𝛼 𝑗 (0, 𝑡𝛼 𝑗))
return 𝑡𝑖
Algorithm 5: MQ_Gen
Input: 𝑖, 𝑥
Output: A𝑖(𝑥)
1 𝐴𝑖 ← 𝐺𝑒𝑛𝑀𝑄(𝑖)
2 𝐴𝑖(𝑥) ← 𝐼𝑛𝑠𝑒𝑟𝑡𝑉 𝑒𝑐(𝐴𝑖, 𝑥)
3 return 𝐴𝑖(𝑥)
⊲ 𝑖: column# in T ,
⊲ 𝑥: known elements in 𝑖𝑡ℎ column of T
⊲ use Equation 3 for 𝑖 = 𝑗
⊲ Section 4.2,item 2
5 EXPERIMENTAL RESULTS
Bit-tracing:
We have attacked the constant-time AVX2 reference implementa-
tion of LUOV-7-57-197 [44] on a Haswell system equipped with
Intel Core i7-4770 CPU @ 3.40GHz, 2 GBytes DDR3 DRAM, model
Samsung (M378B5773DH0-CH9). Pre-processing (templating) step
is performed in 5.7 hours to find 17,129 physical addresses vulnera-
ble to the bit-tracing attack. After that, 16 hours of online phase is
carried out in which the victim is running and performing signing
Algorithm 6: ML_Gen
Input: (𝑖, 𝑥),( 𝑗, 𝑦)
Output: B𝑖,𝑗 (𝑥, 𝑦)
1 𝐵𝑖,𝑗 ← 𝐸𝑞𝑛𝐺𝑒𝑛(𝑖, 𝑗)
2 𝐵𝑖,𝑗 (𝑥, 𝑦) ← 𝐼𝑛𝑠𝑒𝑟𝑡𝑉 𝑒𝑐(𝐵𝑖,𝑗 , 𝑥, 𝑦)
3 return B𝑖,𝑗 (𝑥, 𝑦)
⊲ 𝑖, 𝑗: column# in T ,
⊲ 𝑥, 𝑦: known elements in the
⊲ 𝑥, 𝑦𝑡ℎ columns of T , respectively
⊲ Section 4.2,item 3
⊲ Section 4.2,item 5
Algorithm 7: Eqn_Solver
𝑗=1 B𝑖,𝑗 (𝑥, 𝑦 𝑗)
Output: 𝑡 𝑗 or No Result
1 if 𝑣 − 𝑥 ≤ 𝑚 then Solve A𝑖(𝑥)
Input: A𝑖(𝑥),𝑖−1
2 if 𝑣 − 𝑥 − (𝑖 − 1)𝑚 ≤ 0 then Solve𝑖−1
A𝑖(𝑥) ∪𝑖−1
4 if 0 ≤ 𝑣 − 𝑥 − (𝑖 − 1)𝑚 ≤ 𝑚 then Solve
𝑗=1 B𝑖,𝑗 (𝑥, 𝑦 𝑗)
3
5 else break
6 return 𝑡 𝑗
⊲ ∼ 𝑀𝑄(𝑣 − 𝑥, 𝑚)
𝑗=1 B𝑖,𝑗 (𝑥, 𝑦 𝑗)
⊲ ∼ 𝑀𝑄((𝑖 − 1)𝑚, 𝑣 − 𝑥)
⊲ ∼ 𝑀𝑄(𝑣 − 𝑥 − 𝑚, 𝑚)
⊲ No Solvable System
𝑘, 𝑄2
Algorithm 8: Matrix_Gen
Input: 𝑄1
Output: 𝑃3
1 𝑃𝑘1 ← 𝑓 𝑖𝑛𝑑𝑃𝑘1(𝑄1, 𝑘)
2 𝑃𝑘2 ← 𝑓 𝑖𝑛𝑑𝑃𝑘2(𝑄1, 𝑘)
3 𝑃𝑘3 ← 𝐺𝑒𝑛𝑃𝑘3(𝑃𝑘1, 𝑃𝑘2, 𝑘)
4 𝑄2 ← 𝐺𝑒𝑛𝑄2(𝑃𝑘3)
5 return 𝑃3
𝑘, 𝑄2
⊲ [3]
⊲ [3]
⊲ ∼ 𝑀𝑄(𝑣 − 𝑥, 𝑣 − 𝑥)
⊲ Equation 4
𝑛 = 𝑚
40
43
49
Time
2.7s
12s
11m 33s
𝑛 = 𝑚
52
53
54
Time
1h 32m
3h 3m
3h 6m
𝑛 = 𝑚
55
56
57