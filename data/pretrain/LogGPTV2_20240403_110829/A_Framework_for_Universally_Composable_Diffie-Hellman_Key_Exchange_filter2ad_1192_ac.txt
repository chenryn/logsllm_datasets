which represents Difﬁe-Hellman keys. Keys of this type
may only be generated via a new GenDHKey command (see
below) or be inserted into Fcrypto via the existing Store
command; they may not be created by any other commands.
These keys can be used to derive new symmetric keys of
arbitrary types, but they may not be used for encryption or
creating MACs directly. Furthermore, just as all other key
types, they can be encrypted as part of a plaintext.
Upon the ﬁrst activation of Fcrypto, we now let Fcrypto exe-
cute GroupGen(1η) and store the generated group (G, n, g).
Then, Fcrypto sends both the group (G, n, g) and a request for
cryptographic algorithms to the adversary via a restricting
message. When this initialization is complete, Fcrypto either
continues to process the original message that activated it
(if the ﬁrst message was received on an I/O tape) or returns
control to the adversary (if the ﬁrst message was received
on a network tape).
Our extension of Fcrypto provides the following additional
commands to a user (pid , lsid , r ) on the I/O interface:
- Get generated group [(GetDHGroup)]. The user can
the group (G, n, g) that was generated by
request
Fcrypto during initialization. Fcrypto responds by sending
(DHGroup, (G, n, g)) to the user.
- Generate a fresh exponent [(GenExp)]. The user can re-
quest a pointer to a new unknown exponent e. This request
is forwarded to the adversary via a restricting message,
who is supposed to provide an exponent e ∈ {1, . . . , n}.
The functionality Fcrypto then ensures that this exponent
e is fresh, i.e., it does not collide with existing exponents
(e (cid:6)∈ Exp), and that ge is not blocked from being generated
(i.e., ge (cid:6)∈ BlockedElements). If the freshness check
fails, Fcrypto asks the adversary again for another e until
the check succeeds. Then, Fcrypto adds e to Exp, stores
a pointer ptr for user (pid , lsid , r ) pointing to e, and
returns (ExpPointer, ptr , ge) to the user.
- Mark group element as used [(BlockGroupElement,
h)]. The user can instruct Fcrypto to manually block a
group element h from being generated during a GenExp
request. This is useful for higher level protocols to ensure
that, if they receive some DH share h, no future GenExp
request will output the same DH share even if h was
not originally created by Fcrypto. Upon receiving this
command, Fcrypto checks that h is a valid group element
and, if so, adds it to BlockedElements. In any case, Fcrypto
returns OK. See Section III-C for a discussion of this
command.
- Retrieve an exponent [(RetrieveExp, ptr )]. The user
can retrieve the exponent e a pointer ptr refers to. In this
case, Fcrypto adds e to Expknown and outputs (Exponent, e)
to the user.
- Store an exponent [(StoreExp, e)]. The user can also
insert a new (known) exponent e ∈ {1, . . . , n} into Fcrypto.
Upon receiving this request, Fcrypto prevents guessing of
unknown exponents by ensuring that e (cid:6)∈ Exp\Expknown. If
the check succeeds, e is added to Expknown, a new pointer
ptr for this exponent is created, and (ExpPointer, ptr ) is
returned to the user. If the check fails, (ExpPointer,⊥)
is returned to the user.
- Generate a new Difﬁe-Hellman key [(GenDHKey,
ptr , h)]. A user can ask Fcrypto to create a new key of
type dh-key from some group element h and the exponent
e to which ptr points. When receiving this request,
Fcrypto ﬁrst ensures that h actually is a group element
and returns (Pointer,⊥) to the user otherwise. If the
check succeeds, Fcrypto adds h to the set BlockedElements
886
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:26:54 UTC from IEEE Xplore.  Restrictions apply. 
to ensure that h will not be output by future GenExp
requests (cf. Section III-C for a discussion). Furthermore,
if h = ge, then e is marked as known, i.e., is added to
the set Expknown (cf. Section III-C). A new pointer ptr(cid:2)
to the DH key is created as follows:
First, Fcrypto checks whether a key has already been
generated by the group elements ge and h. If so, then the
pointer ptr(cid:2) is set to this key. Otherwise, a new key is
generated as follows.
If h belongs to an unknown exponent (i.e., there exists
d ∈ Exp\Expknown such that h = gd) and e is marked
unknown, then the adversary is asked via a restricting
message to provide a fresh unknown key k ∈ G of
type dh-key. Formally, this is done by sending the re-
stricting message (ProvideDHKey, unknown, e, d) on the
network.4 The functionality Fcrypto ensures that k is fresh,
i.e., k (cid:6)∈ Keys (and keeps asking for a new k if this is not
the case), and then sets the pointer ptr(cid:2) to k.
If the checks regarding the exponents fail, i.e., there is
no d ∈ Exp\Expknown such that h = gd or e is marked
then the adversary is asked via a restricting
known,
message to provide a known key k ∈ G of type dh-key.
Formally, this is done by sending the restricting message
(ProvideDHKey, known, e, h) on the network. The func-
tionality Fcrypto prevents key-guessing of unknown keys,
i.e., if k ∈ Keys\Keysknown, the functionality asks for
another key. The pointer ptr(cid:2) is then set to k. Furthermore,
if there is no d ∈ Exp such that h = gd, then the exponent
e is marked known by adding it to Expknown even if it was
unknown before (we explain this in the remarks below).
In any case, Fcrypto records that ge and h have been
used to create a key k and returns (Pointer, ptr(cid:2)) to the
user.
In addition to these commands, we improve the overall
expressivity and usability of Fcrypto as follows:
- In [19], the adversary was allowed to corrupt a fresh
key generated via the New command. As this command
models a local computation performed by honest parties,
we remove this ability. Keys generated by this command
are now always uncorrupted and thus unknown.
- Every time Fcrypto adds a symmetric key k to Keysknown,
it sends a restricting message (AddedKnownKey, k) to the
adversary and waits for any response on the network
before continuing. This makes explicit that Fcrypto does
not provide any guarantees on the secrecy of actual values
or the status of keys. As the adversary is already asked
to provide unknown keys, there is no need to also leak
them. While this change is not necessary for realizing
Fcrypto (see Section IV), it reduces the burden imposed
4We note that it is important to tell the adversary the known/unknown
status for our realization as this determines whether our simulator responds
$← {1, . . . , n}. Also note that the adversary knows the
with ged or gc, c
actual values of e and d anyway, so there is no security loss by directly
sending these values on the network.
on simulators when using Fcrypto as part of a higher-level
protocol.
- As mentioned in Section III-A, the adversary may stat-
ically corrupt private keys. We now allow the adversary
to corrupt signing keys adaptively, i.e., these keys can be
corrupted by the adversary at any time.
- As mentioned above, our extension uses the power
of restricting messages to guarantee that
the environ-
ment/adversary cannot interfere with a higher level pro-
tocol while using Fcrypto (for DH related and other oper-
ations) by deﬁning all network messages to be restricting
if they are sent while some operation is in progress.
C. Remarks
The ideal functionality Fcrypto marks DH keys as unknown
only if they were generated from two unknown exponents.
In particular, if an unknown exponent e is used with a
group element h which was not created by Fcrypto, then
the resulting key is marked known and hence no security
guarantees are given for this key. Otherwise, Fcrypto would
not be realizable: In a realization of Fcrypto, an environment
might know the exponent d such that h = gd, in which case
it is trivial to compute the DH key ged. Hence, if Fcrypto used
such a key to derive other keys ideally, an environment could
easily distinguish Fcrypto and its realization Pcrypto.
We want to use the Decisional Difﬁe-Hellman (DDH)
assumption for realizing Fcrypto. However, Fcrypto provides
operations that are not covered by the DDH experiment. To
be more precise, the environment can use Fcrypto to compute
(ge)e=ge2 and he (where e is a secret exponent stored in
Fcrypto and h is an arbitrary group element not generated by
Fcrypto). By the DDH assumption, we cannot guarantee that
the environment does not learn anything about e itself or
keys created with e in these cases. Indeed, if an adversary
is able to calculate the function fa(h)→ha or the function
(cid:2)(ge)→g(e2) (where a is one of the exponents from the
f
DDH experiment and h, ge are arbitrary group elements)
he can break the DDH assumption (see, e.g., [26], [27] for
details). Thus, we have to consider e to be known in these
cases.
set
The need for
the BlockedElements
and the
BlockGroupElement command might seem surprising at
ﬁrst: Typically, cryptographic libraries in real world pro-
tocols do not keep track of “seen” DH shares and then
block them from being generated. However, this set and the
corresponding command are necessary to lift an important
property from the realization Pcrypto to the case of the
idealization. In the realization, it happens with negligible
probability only that ge for some fresh exponent e equals
some DH share h which might already have been used to
create a key. However, Fcrypto allows the adversary to choose
the actual value of e, i.e., he might choose the exponent
such that ge = h. To get the same guarantees as or even
stronger guarantees than in the realization, Fcrypto uses the
887
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:26:54 UTC from IEEE Xplore.  Restrictions apply. 
set BlockedElements to record all DH shares it has seen
so far. With this set Fcrypto makes sure that when creating
a new exponent the corresponding DH share is “fresh”,
i.e., does not belong to BlockedElements. The command
BlockGroupElement allows higher level protocols to notify
Fcrypto about DH shares they obtain such that Fcrypto can
add these shares to BlockedElements. For example, when a
responder in a DH-based key exchange protocol receives a
DH share h, she would ﬁrst add this share to Fcrypto using
the command BlockGroupElement and then create her own
share. By this, Fcrypto can make sure that the responder’s
share is indeed fresh, and in particular, different from h.
The responder can then use the GenDHKey command to
derive a fresh DH key from h and her own DH share.
We note that the BlockedElements set does not exist in
Pcrypto while the BlockGroupElement command in fact
does nothing. Thus, after replacing Fcrypto with Pcrypto, every
call of the BlockGroupElement command can be omitted
entirely, yielding a natural protocol implementation.
While we opted for a deﬁnition of Fcrypto with a single
DH key type for simplicity, it is trivial to extend Fcrypto to
multiple DH key types to model two or more groups that
are used simultaneously. Such an extension uses one set Exp
and Expknown and separate pointers to exponents for every
DH key type. All results presented in the following carry
over to this setting.
IV. REALIZATION
In this section, we construct a realization Pcrypto of Fcrypto.
This realization, which we describe in Section IV-A in
implements all operations of Fcrypto via common
detail,
cryptographic schemes in a natural and expected way. In
Section IV-B, we then prove that Pcrypto indeed realizes
Fcrypto under standard cryptographic assumptions. This proof
is quite involved and includes several reductions and hybrid
arguments, but due to the composition theorems this is a
once and for all effort. As mentioned in the introduction,
protocol designers can use Fcrypto for their security analysis
and then replace it with Pcrypto without re-doing any proofs.
A. Formal Deﬁnition of Pcrypto
the machine Pcrypto has the same network
Formally,
and I/O interface as Fcrypto. It is parameterized with three
schemes Σauthenc, Σunauthenc, Σpub for (un-)authenticated sym-
metric and public key encryption, a MAC scheme ΣMAC,
an algorithm GroupGen(η) with the same properties as for
Fcrypto, and two families of pseudo-random functions (PRF)
F = {Fη}η∈N and F
η}η∈N that take as input a key
(cid:2)
and a salt and output a key (see our technical report [24]
for formal deﬁnitions of these primitives). When activated
for the ﬁrst time by some message m, Pcrypto initializes
itself by executing GroupGen and storing the result before
processing m. Just as Fcrypto, the machine Pcrypto keeps track
of symmetric key types and uses them to decide which
(cid:2) = {F
(cid:2)
primitives may be excuted with a given key (the family
F is used for deriving keys from keys of type pre-key,
while F
is used for key derivation from keys of type
dh-key). The realization keeps track of the corruption status
of keys in order to answer corruption status requests from
the environment, but its behavior is independent of the cor-
ruption status otherwise. In particular, it does not maintain
the sets Keys, Keysknown, Exp, Expknown and does not include
any checks on freshness or key/exponent collisions.
We now give a detailed description of how each of the
DH related commands is implemented in Pcrypto; see [19]
for the remaining commands.
- Get generated group [(GetDHGroup)]. Outputs the
group description (G, n, g) that was generated during the
initialization of Pcrypto.
- Generate a fresh exponent [(GenExp)]. Pcrypto chooses
$← {1, . . . , n}, creates a pointer to e, and outputs
e
(ptr , ge) to the user.
- Mark group element as used [(BlockGroupElement,
h)]. Pcrypto returns OK.
- Retrieve an exponent [(RetrieveExp, ptr )]. Pcrypto out-
puts the exponent e to which ptr points.
- Store an exponent [(StoreExp, e)]. Pcrypto stores e ∈
{1, . . . , n}, creates a new pointer ptr for this exponent,
and returns ptr to the user.
- Generate a new Difﬁe-Hellman key [(GenDHKey,
ptr , h)]. Pcrypto ensures that h ∈ G and returns
(Pointer,⊥) to the user if this is not the case. Then,
Pcrypto calculates the key k := he where e is the exponent
to which ptr points to. A new pointer ptr(cid:2) pointing to k
is created and returned to the user.
The realization Pcrypto also adopts all usability improvements
from Fcrypto described at the end of Section III-B.
B. Showing that Pcrypto realizes Fcrypto
In this section, we state and prove our core theorem,
namely, that Pcrypto realizes Fcrypto. We want to use standard
cryptographic assumptions for this, but these assumptions
provide security only in a certain context. For example,
standard assumptions for symmetric encryption do not pro-
vide any security guarantees in the presence of key cycles
where a key is (indirectly) encrypted by itself. This is why
reasonable higher level protocols generally avoid situations
that are not covered by cryptographic assumptions; in con-
trast, environments in universal composability models are
free to use Pcrypto and Fcrypto in any way they want and, in
particular, they may create settings where the assumptions
fail. In order to capture the expected use of Pcrypto/Fcrypto as
a subroutine of a reasonable higher level protocol, we thus
slightly restrict environments such that they expose certain
natural properties of higher level protocols. We note that this
approach is established in the literature (see, e.g., [28]). The
next paragraphs describe and discuss our restriction in more
detail.
888
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:26:54 UTC from IEEE Xplore.  Restrictions apply. 
Recall that we want to use the DDH assumption in order
to prove Pcrypto ≤R Fcrypto. The general idea is that the sim-
ulator in the proof of this statement will provide gab when
$← {1, . . . , n})
asked for a known DH key, and gc (for c
in case of an unknown DH key. However, this leads to
the so-called commitment problem: Once the simulator has
committed to gc for an unknown key, neither a nor b may