[7] Assaf Ben-David, Noam Nisan, and Benny Pinkas. 2008. FairplayMP: a sys-
tem for secure multi-party computation. In ACM Conference on Computer and
Communications Security. 257–266.
[8] Michael Ben-Or, Shafi Goldwasser, and Avi Wigderson. 1988. Completeness The-
orems for Non-Cryptographic Fault-Tolerant Distributed Computation (Extended
Abstract). In STOC. 1–10.
for Fast Privacy-Preserving Computations. In ESORICS. 192–206.
2013. Key Homomorphic PRFs and Their Applications. In CRYPTO. 410–428.
ing from Classical GapSVP. In CRYPTO. 868–886.
(Leveled)
Fully Homomorphic Encryption without Bootstrapping. TOCT 6, 3 (2014), 13.
Preliminary version in ITCS 2012.
[13] Zvika Brakerski and Vinod Vaikuntanathan. 2011. Fully Homomorphic Encryp-
tion from Ring-LWE and Security for Key Dependent Messages. In CRYPTO.
505–524.
[14] Zvika Brakerski and Vinod Vaikuntanathan. 2014. Efficient Fully Homomor-
phic Encryption from (Standard) LWE. SIAM J. Comput. 43, 2 (2014), 831–871.
Preliminary version in FOCS 2011.
[15] Zvika Brakerski and Vinod Vaikuntanathan. 2014. Lattice-Based FHE as Secure
[11] Zvika Brakerski. 2012. Fully Homomorphic Encryption without Modulus Switch-
[10] Dan Boneh, Kevin Lewi, Hart William Montgomery, and Ananth Raghunathan.
as PKE. In ITCS. 1–12.
[16] Jacques Carette, Oleg Kiselyov, and Chung-chieh Shan. 2009. Finally tagless,
partially evaluated: Tagless staged interpreters for simpler typed languages. J.
Funct. Program. 19, 5 (2009), 509–543.
[17] Hao Chen, Kim Laine, and Rachel Player. 2017. Simple Encrypted Arithmetic
Library - SEAL v2.1. In Financial Cryptography and Data Security. 3–18.
[18] Jung Hee Cheon, Jean-Sébastien Coron, Jinsu Kim, Moon Sung Lee, Tancrède
Lepoint, Mehdi Tibouchi, and Aaram Yun. 2013. Batch Fully Homomorphic
Encryption over the Integers. In EUROCRYPT. 315–335.
[19] Jean-Sébastien Coron, Avradip Mandal, David Naccache, and Mehdi Tibouchi.
2011. Fully Homomorphic Encryption over the Integers with Shorter Public Keys.
In CRYPTO. 487–504.
[20] Jean-Sébastien Coron, David Naccache, and Mehdi Tibouchi. 2012. Public Key
Compression and Modulus Switching for Fully Homomorphic Encryption over
the Integers. In EUROCRYPT. 446–464.
[21] Jack L.H. Crawford, Craig Gentry, Shai Halevi, Daniel Platt, and Victor Shoup.
2018. Doing Real Work with FHE: The Case of Logistic Regression. Cryptology
ePrint Archive, Report 2018/202. https://eprint.iacr.org/2018/202.
[22] Eric Crockett and Chris Peikert. 2016. Λ ◦ λ: Functional Lattice Cryptography.
In ACM CCS. 993–1005. Full version at http://eprint.iacr.org/2015/1134.
[23] Ivan Damgård, Martin Geisler, Mikkel Krøigaard, and Jesper Buus Nielsen. 2009.
Asynchronous Multiparty Computation: Theory and Implementation. In PKC.
160–179.
[24] Yarkin Doroz, Yin Hu, and Berk Sunar. 2014. Homomorphic AES Evaluation
using NTRU. Cryptology ePrint Archive, Report 2014/039. https://eprint.iacr.
org/2014/039.
[25] Léo Ducas and Daniele Micciancio. 2015. FHEW: Bootstrapping Homomorphic
Encryption in Less Than a Second. In EUROCRYPT. 617–640.
Stanford University. http://crypto.stanford.edu/craig.
[26] Craig Gentry. 2009. A fully homomorphic encryption scheme. Ph.D. Dissertation.
[27] Craig Gentry. 2009. Fully homomorphic encryption using ideal lattices. In STOC.
[28] Craig Gentry, Jens Groth, Yuval Ishai, Chris Peikert, Amit Sahai, and Adam D.
Smith. 2015. Using Fully Homomorphic Hybrid Encryption to Minimize Non-
interative Zero-Knowledge Proofs. J. Cryptology 28, 4 (2015), 820–843.
Encryption Scheme. In EUROCRYPT. 129–148.
[30] Craig Gentry, Shai Halevi, Chris Peikert, and Nigel P. Smart. 2013. Field switching
in BGV-style homomorphic encryption. Journal of Computer Security 21, 5 (2013),
663–684. Preliminary version in SCN 2012.
[31] Craig Gentry, Shai Halevi, and Nigel P. Smart. 2012. Better Bootstrapping in
[29] Craig Gentry and Shai Halevi. 2011. Implementing Gentry’s Fully-Homomorphic
[33] Craig Gentry, Shai Halevi, and Nigel P. Smart. 2012. Homomorphic Evaluation
[32] Craig Gentry, Shai Halevi, and Nigel P. Smart. 2012. Fully Homomorphic Encryp-
Fully Homomorphic Encryption. In Public Key Cryptography. 1–16.
tion with Polylog Overhead. In EUROCRYPT. 465–482.
of the AES Circuit. In CRYPTO. 850–867.
[34] Craig Gentry, Amit Sahai, and Brent Waters. 2013. Homomorphic Encryp-
tion from Learning with Errors: Conceptually-Simpler, Asymptotically-Faster,
Attribute-Based. In CRYPTO. 75–92.
[35] Oded Goldreich, Silvio Micali, and Avi Wigderson. 1987. How to Play any Mental
Game or A Completeness Theorem for Protocols with Honest Majority. In STOC.
218–229.
[36] Shai Halevi and Victor Shoup. [n. d.]. HElib: an implementation of homomorphic
169–178.
encryption. https://github.com/shaih/HElib, last retrieved August 2016.
641–670.
[37] Shai Halevi and Victor Shoup. 2014. Algorithms in HElib. In CRYPTO. 554–571.
[38] Shai Halevi and Victor Shoup. 2015. Bootstrapping for HElib. In EUROCRYPT.
[39] Wilko Henecka, Stefan Kögl, Ahmad-Reza Sadeghi, Thomas Schneider, and Immo
Wehrenberg. 2010. TASTY: Tool for Automating Secure Two-partY computations.
In ACM Conference on Computer and Communications Security. 451–462.
[40] Yukiyoshi Kameyama, Oleg Kiselyov, and Chung-chieh Shan. 2015. Combinators
for impure yet hygienic code generation. Sci. Comput. Program. 112 (2015),
120–144.
[41] Oleg Kiselyov. 2010. Typed Tagless Final Interpreters. In Generic and Indexed
Programming - International Spring School, SSGIP 2010. 130–174. http://okmij.
org/ftp/tagless-final/.
[42] John Launchbury, Dave Archer, Thomas DuBuisson, and Eric Mertens. 2014.
Application-Scale Secure Multiparty Computation. In ESOP. 8–26.
[43] Philip D. MacKenzie, Alina Oprea, and Michael K. Reiter. 2003. Automatic gener-
ation of two-party computations. In ACM Conference on Computer and Commu-
nications Security. 210–219.
[44] Dahlia Malkhi, Noam Nisan, Benny Pinkas, and Yaron Sella. 2004. Fairplay -
Secure Two-Party Computation System. In USENIX Security Symposium. 287–302.
[45] Silvia Mella and Ruggero Susella. 2013. On the Homomorphic Computation of
Symmetric Cryptographic Primitives. In IMACC. 28–44.
morphic encryption be practical?. In CCSW. 113–124.
[47] Janus Dam Nielsen and Michael I. Schwartzbach. 2007. A domain-specific pro-
gramming language for secure multiparty computation. In Workshop on Program-
ming Languages and Analysis for Security. 21–30.
[48] Aseem Rastogi, Matthew A. Hammer, and Michael Hicks. 2014. Wysteria: A
Programming Language for Generic, Mixed-Mode Multiparty Computations. In
[46] Michael Naehrig, Kristin Lauter, and Vinod Vaikuntanathan. 2011. Can homo-
IEEE Symposium on Security and Privacy. 655–670.
[49] Ronald L. Rivest, Len Adleman, and Michael L. Dertouzos. 1978. On Data Banks
and Privacy Homomorphisms. Foundations of secure computation 4, 11 (1978),
169–180.
[50] Victor Shoup. 2006. A library for doing number theory. http://www.shoup.net/
ntl/, version 9.8.1.
[51] Nigel P. Smart and Frederik Vercauteren. 2014. Fully homomorphic SIMD opera-
tions. Designs, Codes and Cryptography 71, 1 (2014), 57–81. Preliminary version
in ePrint Report 2011/133.
[52] Marten van Dijk, Craig Gentry, Shai Halevi, and Vinod Vaikuntanathan. 2010.
[53] Andrew Chi-Chih Yao. 1982. Theory and Applications of Trapdoor Functions
Fully Homomorphic Encryption over the Integers. In EUROCRYPT. 24–43.
(Extended Abstract). In FOCS. 80–91.
A BASIC INTERPRETERS
In this section we describe the implementation of a few simple
object-language interpreters included with Alchemy, which are
due to [16, 41]. (We have already seen one interpreter in its entirety:
the evaluator E described in Section 2.)
A.1 Printer
The printer converts an object-language expression into a (host-
language) string representing the expression. This interpreter was
presented in a simplified form in Section 2; we describe the actual
implementation here. It has the following formal definition and
public interface:
newtype P e a = P (Int -> String)
-- closed code has lambda depth 0
print :: P () a -> String
print (P f) = f 0
This says that an object-language expression is represented by an
Int -> String function. The Int argument indicates how many
variables have already been bound “outside” the expression, and is
used only by the Lambda_ instance to unambiguously name new
variables:
instance Add_ P a where
add_ = P $ \i -> "add"
-- or: P $ pure "add"
-- instances of Mul_ etc. are similar
instance Lambda_ P where
lamDB (P f) =
P $ \i -> "(\\v" ++ show i ++ " -> " ++ f (i+1) ++ ")"
(P f) $: (P a) =
P $ \i -> "(" ++ f i ++ " " ++ a i ++ ")"
= P $ \i -> "v" ++ show (i-1)
v0
weaken (P v) = P $ \i -> v (i-1)
Here lamDB creates (a function mapping an Int i to) a string rep-
resenting a function of variable vi, where the body of the lambda
is in a context where i + 1 variables have been bound. Function
application (the $: operator) produces (a function mapping to) a
string that just appends the function string and the argument string;
the number of bound variables does not change. For v0, because
the body of any function appears in a context with at least one
bound variable (by definition), we print index i − 1 so that variables
are zero-indexed. Finally, because weaken refers to a variable one
step “down” the environment stack, it recursively interprets the
subexpression in a context with one fewer bound variable.
A.2 Expression Size
A useful metric for the complexity of an expression is its size in
term of the number of “primitive” DSL terms used. The interpreter S
that converts an expression to its size is defined as follows:
newtype S e a = S Int
size :: S () a -> Int
size (S i) = i
This says that an expression is simply represented by an Int, which
can be extracted using size. With this definition it is trivial to
interpret all the language components:
instance Add_ S a where
add_ = S 1
-- instances of Mul_ etc. are similar
instance Lambda_ S where
lamDB (S i) = S $ i+1
(S f) $: (S a) = S $ f + a
v0 = S 1
weaken (S i) = S i
The most interesting instance is Lambda_. The size of a function
definition (i.e., a call to lamDB) is one larger than the size of its
body, and the size of a function application (the $: operator) is the
sum of the sizes of the function and the argument. As for uses of
variables, v0 clearly should have unit size. The same should be true
for any other variable regardless of its location in the environment,
so weaken does not change the size of its subexpression.
Using S is easy:
ex1 = lam $ \x -> lam $ \y -> var y *: (var y +: var x)
size ex1
-- 7
A.3 Duplicator
The above interpreters each use a concrete host-language represen-
tation (a String, an Int) as their interpretations of object-language
expressions. Such interpreters are “terminal” in that they produce
a result in the host language. However, we also have interpreters
(like the error-rate logger ERW and plaintext-to-ciphertext com-
piler PT2CT) that transform object-language code into other object-
language code, i.e., “compilers.” Importantly, we want the produced
code to itself be interpretable in a variety of ways, i.e., it should
be also polymorphic in its interpreter. Unfortunately, this is not
currently possible in mainstream Haskell: while we can write poly-
morphic “top-level” DSL code that can be interpreted in multiple
ways by monomorphizing the interpreter, any DSL code output by
an interpreter must be monomorphic; therefore, it can be handled
by only one interpreter.9
Fortunately, [41] provides a simple way to work around this re-
striction via a special interpreter that duplicates any object-language
expression into two equivalent expressions. These expressions,
while necessarily monomorphic, can use different interpreters. This
duplicating interpreter Dup has the following definition and public
interface:
9The functionality we seek is known as impredicative polymorphism, which is quite
poorly supported in the GHC Haskell compiler.
data Dup expr1 expr2 e a = Dup (expr1 e a) (expr2 e a)
dup :: Dup expr1 expr2 e a -> (expr1 e a, expr2 e a)
dup (Dup ex1 ex2) = (ex1, ex2)
Notice that the Dup interpreter is parameterized by two other in-
terpreters, expr1 and expr2, and represents an object-language
expression simply as a pair of such expressions, one for each of
these interpreters. Naturally this idea can be applied recursively
to interpret an expression in arbitrarily many ways, by letting one
or both of expr1, expr2 themselves be a Dup (with appropriate
arguments).
The instances for Dup are all very simple and completely me-
chanical. For example:
instance (Add_ expr1 a, Add_ expr2 a)
=> Add_ (Dup expr1 expr2) a where
add_ = Dup add_ add_
neg_ = Dup neg_ neg_
The constraints on the instance say that in order for Dup expr1 expr2
to be able to interpret Add_ for (object-language) type a, the inter-
preters expr1, expr2 must be able to do the same. The implementa-
tion mirrors these constraints: the add_ term for Dup expr1 expr2
is simply the pair of add_ terms for the expr1 and expr2 inter-
preters.
Using Dup is very simple:
ex = functionThatOutputsSomeDSLExpression someArg
-- the following code infers the *monomorphic* type
-- ex :: Dup P E () Int
(ex1, ex2) = dup ex
print ex1
-- "(\\v0 -> ((add v0) v0))"
eval ex2 3
-- 6
B OBJECT-LANGUAGE FUNCTIONS AND
HOAS
Recall that we wish to have function abstraction and application
in our object languages, using the host language’s facilities for the
same. There is a standard, very elegant solution:
class LambdaPure_ expr where
lamPure :: (expr a -> expr b) -> expr (a -> b)
($:)
:: expr (a -> b) -> expr a -> expr b
double_ :: (Lambda_ expr, Add_ expr a) => expr e (a -> a)
double_ = lamPure $ \x -> x +: x
pprint $ double_ $: (3 *: 4)
-- (\v0 -> add v0 v0) (mul 3 4)
addMulPure = lamPure $ \x -> lamPure $ \y -> (x +: y) *: y
Notice that there is no need for an explicit environment argument
to expr; LambdaPure_ lets us rely entirely on the host language
for creating functions and naming variables, resolving variable
references, etc. This approach is known as higher-order abstract
syntax (HOAS).
Unfortunately, LambdaPure_ is too weak for our needs. While
pure host-language functions present no problem, difficulties arise
with effectful (monadic) ones that use side-effects to produce object-
language code, such as our plaintext-to-ciphertext compiler (which
creates random keys and hints during its code transformations). The
problem is most easily seen with an example: given some monadic
function
foo :: Monad m => expr a -> m (expr b)
we would like to convert it to an object-language function (in a
monadic context) of type m (expr (a -> b)). Unfortunately, this
is impossible in general: if expr a is isomorphic to a (as is the
case with evaluators), then we are asking to transform a monadic
function of type a -> m b into a pure function in a monadic con-
text, of type m (a -> b). This cannot be done because the former
type allows the monadic output to depend upon the input a-value,
whereas the latter type allows only the function itself to depend on
the monadic context.
The difficulty of using HOAS with effectful generators has long
been recognized in the literature as a thorny problem, and various
approaches—none of them completely satisfactory—have been pro-
posed; see [40] for an overview. In what follows we improve upon
the solution offered in [40, 41], by allowing interpreters to hide the
fact that they are effectful, and significantly simplifying the type
signatures and syntax of object-language code.
Functions and environments. As an alternative to LambdaPure_,
following [16] and [41, Section 3.3] we start from an object-language
representation expr e a, where the environment argument e has a
nested-pair structure reflecting de Bruijn-indexed variables. More
specifically:
class Lambda_ expr where