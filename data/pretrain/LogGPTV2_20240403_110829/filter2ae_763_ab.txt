    Using clock_gettime for delay loops (clk_id: 1, resolution: 1ns).
    Found Winbond flash chip "W25Q128.V" (16384 kB, SPI) on linux_spi.
    Reading flash... done.
## 从 MCU 中提取固件
从 Flash 中提取固件较为常见，但有些情况下固件被没有存储在外置的 Flash 上，而是在 MCU 的内置 Flash
中。这时需要通过调试接口（SWD/JTAG等）对固件进行提取，也可以进行动态调试。
对 MCU 上固件进行提取，首先需要根据芯片手册，找到调试接口。有些情况下，调试接口可能会引出。下图是我曾经研究过的一款智能设备，板子上引出 SWD
调试接口。
但随着硬件厂商对安全的重视，MCU 调试接口被引出的情况越来越少。但遇到这种情况时，可以尝试直接操作芯片针脚。下面演示使用芯片测试夹从 MCU
中提取内置固件。提取所需的软硬件如下。
  * 硬件 
    * 测试夹：芯片通用测试夹测试钩子。
    * FT232H：多功能 USB to JTAG SWD/UART/FIFO SPI/I2C 模块。也可以使用 JLink、STLink 等调试器。
  * 软件 
    * OpenOCD: [OpenOCD](https://github.com/ntfreak/openocd)（Open On-Chip Debugger)是一个开源的片上调试器，旨在提供针对嵌入式设备的调试、系统编程和边界扫描功能，可以与 GDB 配合进行动态调试。
以下以某 IOT 设备 MCU (STM32f030 RCT6) 为例使用测试夹通过 OpenOCD 提取固件。`STM32f030 RCT6`采用 QFP
64 封装。
  1. OpenOCD 安装与简单使用使用 apt 直接安装。 
        sudo apt-get install openocd
有特殊需求时，也可以进行源码安装。部分芯片厂商对 OpenOCD 进行了适配，如新唐的 [OpenOCD-Nuvoton](https://github.com/OpenNuvoton/OpenOCD-Nuvoton)。
OpenOCD 运行需要两个配置文件，第一个是调试器的配置文件，第二个是目标芯片的配置文件。
         openocd -f interface/ft232h-module-swd.cfg  -f target/stm32f0x.cfg
OpenOCD 运行之后，使用 telnet 连接本地的 4444 端口与芯片进行交互。连接后，输入 help
查看支持的命令，不同的芯片支持的命令有所不同。一般而言提取固件使用 `dump_image`命令。
GDB 动态调试监听见本地的 3333 端口，进入GDB 后通过 `target remote localhost:3333`连接。
  2. 连线根据芯片丝印 `STM32f030 RCT6`下载相应的[芯片手册](https://www.st.com/resource/en/datasheet/stm32f030f4.pdf)。在手册中找到调试接口，此芯片采用 SWD 进行调试。`STM32f030 RCT6`有 64 个针脚，对应下图 46 号针脚 SWDIO，49 号针脚 SWCLK，63 号针脚 VSS，7 号针脚 RESET。然后，使用已连接杜邦线的测试夹连接SWD 接口，依次为 7 号针脚（RESET）、 46 号针脚（SWDIO）、 49 号针脚（SWCLK）、 63 号针脚（VSS） ，连接之后如下图。
然后，按下图连接 FT232H。注意 AD2(DO) 需要串联一个电阻，然后与 AD1(DI) 合并组成 SWDIO。
最后将 FT232H 通过 USB 接口连接电脑。上面的忘记拍全景图了，放张读取其他的芯片的作为参考。连接好的效果图类似下图。
  1. 查看芯片手册找到固件所在位置根据芯片手册的内存映射（如上图） dump固件。固件地址在 0x0000 0000 – 0x2000 0000 中，0x0000 0000 – 0x0004 0000 为 Flash Memory/System Memory/SRAW depending on BOOT configuration、0x0804 0000 – 0x0800 0000 为 Flash memory、0x1FFF xx00 – 0x1FFF FFFF 为 System memory等。 
    * System Memory: 从系统存储器启动，这种模式启动的程序功能是由厂家设置的。一般来说，这种启动方式用的比较少。系统存储器是芯片内部一块特定的区域，STM32 在出厂时，由 ST 在这个区域内部预置了一段 BootLoader， 也就是我们常说的 ISP 程序， 这是一块 ROM，出厂后无法修改。一般来说，我们选用这种启动模式时，是为了从串口下载程序，因为在厂家提供的 BootLoader 中，提供了串口下载程序的固件，可以通过这个 BootLoader 将程序下载到系统的 Flash 中。
    * Flash Memory：是 STM32 内置的 Flash，一般我们使用 JTAG 或者 SWD 模式下载程序时，就是下载到这个里面，重启后也直接从这启动程序。
    * SRAW：内置 SRAM，既然是 SRAM，自然也就没有程序存储的能力了，这个模式一般用于程序调试。假如我只修改了代码中一个小小的地方，然后就需要重新擦除整个 Flash，比较的费时，可以考虑从这个模式启动代码（也就是 STM32 的内存中），用于快速的程序调试。
由上可知，固件在 Flash Memory 中，起始地址为 0x8000000 ，大小为 x40000。
  2. 提取固件首先运行 OpenOCD，连接成功的输出如下。 
        root[@kali](https://github.com/kali "@kali"):/usr/share/openocd/scripts# openocd -f interface/ft232h-module-swd.cfg  -f target/stm32f0x.cfg 
    Open On-Chip Debugger 0.10.0
    Licensed under GNU GPL v2
    For bug reports, read
        http://openocd.org/doc/doxygen/bugs.html
    adapter speed: 1000 kHz
    Info : FTDI SWD mode enabled
    swd
    adapter speed: 1000 kHz
    adapter_nsrst_delay: 100
    none separate
    cortex_m reset_config sysresetreq
    Info : clock speed 1000 kHz
    Info : SWD DPIDR 0x0bb11477
    Info : stm32f0x.cpu: hardware has 4 breakpoints, 2 watchpoints
    Polling target stm32f0x.cpu failed, trying to reexamine
    in procedure 'stm32f0x_default_examine_end' 
    in procedure 'mmw' called at file "target/stm32f0x.cfg", line 65
    in procedure 'mrw' called at file "mem_helper.tcl", line 25
    at file "mem_helper.tcl", line 6
然后使用 telnet 连接 locahsot:4444 端口 dump 固件。首先输入命令 `halt` 中断代码执行，然后使用`dump_image
导出固件的文件名 起始地址 导出的数据长度` 导出固件。固件的起始地址和大小，我们在上一步已经获取到了。使用命令`dump_image flash.bin
0x8000000 0x40000`提取固件。
        root[@kali](https://github.com/kali "@kali"):~# telnet 127.0.0.1 4444
    > halt
    target halted due to debug-request, current mode: Thread 
    xPSR: 0x21000000 pc: 0x0801a8de msp: 0x20007990
    > flash list 
    {name stm32f1x base 134217728 size 0 bus_width 0 chip_width 0}
    > dump_image flash.bin 0x8000000 0x40000
    dumped 262144 bytes in 3.812859s (67.141 KiB/s)
然而，并不是每一个 QFP 封装的 MCU 都能够免拆提取出固件 ，现在不少芯片开启了`代码读取保护（CRP/RDP）`。CRP
这一机制就是为了防止固件被提取而设计的。下图是 STM32L151 手册中关于代码读保护的介绍。
另一方面，此方法可以应用在 IOT 安全测试中，用于验证 CRP 是否开启。
另外，使用 `ECU 探针`读取固件方式与使用`芯片通用测试夹测试钩子`类似。唯一的差异是探针是搭在针脚上，而不是夹在针脚上。
以上我是近两年对 IOT 设备硬件的一些粗浅认识，有什么不当之处，还请大佬们不吝赐教。
## 参考
  * [40种芯片封装类型介绍（含实图） ](https://www.sohu.com/a/162899707_609521)
  * [openocd](https://github.com/ntfreak/openocd)
  * [STM32 Read-out protection via OpenOCD](https://stackoverflow.com/questions/32509747/stm32-read-out-protection-via-openocd)