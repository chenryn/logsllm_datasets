have been renamed and shortened through an obfuscation tool
like ProGuard [20]. Concretely, we consider classes named with
one or two lowercase, alpha characters as obfuscated (following
ProGuard’s renaming rules).
2. Determining actual changes: To determine actual changes
between consecutive library versions, we implement an API diff al-
gorithm that operates on two sets of public APIs apiold and apinew ,
where apiold is the API set of the immediate predecessor version of
apinew . An API is described by its signature that includes package
and class name as well as the list of argument and return type, e.g.
com.facebook.Session.getAccessToken()java.lang.String .
If apiold= apinew we have a patch-level release, i.e., there are code
changes only. If apiold⊊ apinew , new APIs were added but existing
ones did not change. This is classified as a backwards-compatible
minor release. Whenever apiold includes APIs that are not included
in apinew we conduct a type analysis to check for compatible coun-
terparts in apinew . Compatible changes include generalization of
argument types, e.g., an argument with type ArrayList is replaced
by its super type List. Generalization on return types is generally
not compatible and depends on the actual app code that uses the
return value. Since we do not conduct a code analysis we treat non-
matching return types as incompatibility. To not suffer from false
positives, we furthermore abstain from searching for alternative
candidates when the class and/or package name do no longer match,
since this may result in ambiguity.1 Hence we report conservative
numbers when searching for API alternatives. If we are able to
identify alternatives for all APIs that do not match exactly, we may
1Updating imports is typically done automatically by an IDE like Android Studio and
is therefore not considered as incompatibility.
Table 3: SemVer misclassification by type (expected vs. ac-
tual change). Highlighted cells are critical as the actual se-
mantic versioning suggests compatibility although the op-
posite is the case.
Expected
5.7%
patch minor major
0.85%
— 0.48%
—
patch
minor
major 15.02% 24.02%
—
11.93%
Actual
classify the release as patch or minor. All other cases are classified
as major release.
3.3 Semantic Versioning Statistics
Applied to our library set, we found that in 58% of all version
changes, the library developer incorrectly specified the new version
string, i.e., according to Semantic Versioning rules the expected
release level did not match the actual release level. Even worse, there
is no single library that achieved a 100% correctness in versioning.
Only 3/89 libraries (3.4%) correctly classified the release level in
more than 80% of all releases, with the android-oauth-client library
ranking first (93.8%). On the other hand, 10/89 (11.2%) of libraries
specified the version string correctly in less than 20% of all cases.
Two libraries (universal-image-loader and log4j) have not specified a
single version change correctly. Further, we could not find a positive
or negative, statistically significant, correlation between library
category (e.g., Advertising, Utilities) and the Semantic Versioning
classification score.
A mismatch between expected and actual changes is always
disadvantageously for the library consumer in that she can not
properly assess whether a new library version can be used as a
drop-in-replacement or whether a considerable amount of work has
to be spent to integrate the update. The severity of the mismatch,
however, depends on the type of inconsistency. In particular, two
types of inconsistencies are problematic: if either patch or minor
release is expected, but the actual changes indicate a major release
(highlighted cells in Table 3). These numbers show that library
developers under-specify changes in 39% of all cases, i.e., the version
increment is too moderate and suggests compatibility although
API changes might break existing applications. In about 6.5% of
cases library developers over-specify changes which does not effect
compatibility but might impede wide-spread adaptation due to a
high expected integration effort.
Figure 12 summarizes the total number of expected and actual
changes between consecutive versions by release level for the 1,971
analyzed versions. The expected changes denote how library de-
velopers specified new version strings. This distribution is what
you would expect for a typical library lifecycle; a stable base API
with occasional additions and code-only changes such as bug and
security fixes for the majority of releases. However, the reality looks
different: 44% of all versions in our analysis were classified as major
release due to non-compatible changes and/or removals of existing
Session J3:  Problematic PatchesCCS’17, October 30-November 3, 2017, Dallas, TX, USA2192and increase the chance that the patch is adapted by developers,
some libraries provide a blog/support entry in which they provide
additional details about the vulnerability. MoPub at least provides a
short note in its GitHub repository, referencing the respective ASI
support document.
Although we cannot provide the same detailed analysis for the
native libraries listed in the ASI program (libjpeg-turbo, libpng,
libupnp, OpenSSL, and Vitamio), we checked their expected SemVer
and changelogs for the fix versions. Only Vitamio provided the
security fix as part of a major release (5.0). All other libraries pro-
vide a patch-level version and, more interestingly, even provide
detailed changelogs for every (security) bugfix made. In our data-
base of Java/Android libraries, only the Android support libraries
and OkHttp provide comparable changelogs regarding the level of
detail.
4 LIBRARY UPDATABILITY
Keeping third-party dependencies up-to-date is a complex problem
with many facets and different parties involved. On the one hand,
there are app developers who mainly wish to update libraries for
bugfixes and security fixes (see Section 2). On the other hand, there
are library developers that want app developers to adapt new li-
brary versions within a reasonable time-frame, e.g., for fixes and/or
new functionality. In Section 3 we showed that library developers
contribute to the adaptation problem by not giving app developers
a simple means of assessing whether or not a new library version
can be integrated without compatibility issues.
To properly assess the current status quo in library updatability,
we have to analyze which library versions and which parts thereof
are in use by applications. Given this information, we can then
determine whether an actual major library release indeed requires
additional integration effort or could still be updated as the set of
used APIs remains compatible. To this end we scan 1,264,118 apps
from Google Play and identify included library versions. For each
found library, we subsequently analyze the application bytecode to
determine how the library is used in terms of API calls. Based on
that information we infer the highest library version that is fully
API compatible for that app/library combination.3
4.1 Approach
We base our approach on the open-source project LibScout [4]. We
extend its implementation to conduct the following analyses:
1. Library API robustness: We first analyze the robustness of the
public library API across versions of a given library. For each library
with more than 10 versions, we determine, on a per-API level, the
highest version that provides this exact API. We are conservative
in that we do not search for alternative candidates if the API in
question is no longer available, e.g., due to method removal or
renaming. Similar to the SemVer analysis, we filter methods that
are obfuscated or reside in internal packages. As a result, we receive
a comprehensive data set with updatability information for each
library version/API pair. Note, that this analysis is much more
fine-grained than the API compatibility analysis conducted in [4],
which checks whether or not the entire API set of some version is
3There might be cases in which a fully API-compatible library version still breaks the
client application. This is discussed in Section 5.3
Figure 12: Total number of expected and actual changes
between consecutive library versions grouped by patch/mi-
nor/major.
APIs. This indicates a poor library design without carefully tak-
ing into account the effort/incompatibilities that consumers might
experience.
3.4 Security Fixes
Finally, we have a dedicated look at security fixes in libraries. These
are the most important kind of updates and should typically be
provided as a patch release. However, even when released with a
short bug-fixing time, such patches miss their intended effect if they
are slowly adapted by app developers or not at all. Ultimately, the
end-user will be at risk and suffer from vulnerabilities like identity
theft or private data leakage. To check if library developers adhere
to this rule, we analyze the Facebook and Dropbox vulnerabilities
used in [4], vulnerabilities in Apache Commons Collections (Apache
CC) and OkHttp found via blog entries, as well as known library
vulnerabilities reported by Google’s ASI program [12]. In total, we
were able to investigate eight distinct bugfix versions2. For the eight
vulnerable libraries, we first determine whether the bugfix version
is a patch release or whether the library provider mixed bugfixes
with new content or even changed existing APIs. We subsequently
compare these findings with the official changelog to see whether
the fix is mentioned and properly documented. Table 4 shows the
detailed results.
Six out of ten patched libraries (including two backports) are mi-
nor releases, i.e., the developer did not intend to provide a dedicated
bugfix version. Only Airpush and Dropbox provide a patch-level
fix, while Facebook, MoPub, Supersonic and Vungle provide a major
version, i.e., they include new functionality and/or break existing
APIs. Apache CC and OkHttp provide an additional backport of the
security patch to allow an effortless adaption by older versions.
Surprisingly, both backport versions are patch-only updates, while
the fixes for the current releases were announced as minor versions
and even included major changes. Mixing critical security patches
with API changes is considered bad practice and certainly con-
tributes to a poor adaptation rate. Besides the version number, the
changelog is the primary way to convey and explain important fixes
and changes to the library consumer (see Figure 5). However, only
Apache CC explicitly mentions a security fix in its changelog, four
libraries at least mention a bug fix. Only the Dropbox and OkHttp
vulnerabilities have a CVE entry. In order to provide transparency
2We had to exclude further vulnerabilities reported by ASI since we were not able to
retrieve the original SDKs for either the fixed version and/or some older versions.
874 (44.34%)166 (8.42%)382 (19.38%)707 (35.87%)715 (36.28%)1,098 (55.71%)MajorMinorPatch05001000Number of changes between library versionsSemantic versioning changeExpected changeActual changeSession J3:  Problematic PatchesCCS’17, October 30-November 3, 2017, Dallas, TX, USA2193Table 4: Library versions with a fixed security vulnerability, the expected and actual SemVer, whether and how the security
fix is described and whether this library vulnerability is listed in Google’s ASI program. Versions marked with (B) denote
backport patches.
Fix Version exp. SemVer actual SemVer Changelog
CVE
CVE-2014-8889 blog
CVE-2016-2402 blog
other
–
blog+report
–
GitHub
–
blog
in ASI
✓
–
–
–
–
✓
✓
✓
–
–
–
–
–
–
Library
Airpush
Apache CC
Dropbox
Facebook
OkHttp
MoPub
Supersonic
Vungle
3.2.2 (B) / 4.1 patch / minor
patch /major
8.1x
1.6.2
3.16
4.4.0
6.3.5
3.3.0
minor
patch
minor
minor
patch
minor
patch
patch
major
major
major
major
–
security
bugfix
bugfix
bugfix
bugfix
–
–
2.7.5 (B) / 3.2.0 patch / minor
patch / major
present in the successor version. This data would be insufficient to
determine whether an actively used library can be updated.
2. Library usage: To identify the actively used parts of a library,
we scan the application bytecode for invocations of this library.
To account for identifier renaming obfuscation, we match the li-
brary API with the identified root package name, e.g., when the
original library root package com.gson was obfuscated/renamed
to com.mygson or com.ab, we rename the original library API ac-
cordingly. For ambiguous profile matches, i.e., LibScout is not able
to distinguish patch-level changes in libraries, we select one of the
matched libraries. Since patch-level changes are API-compatible