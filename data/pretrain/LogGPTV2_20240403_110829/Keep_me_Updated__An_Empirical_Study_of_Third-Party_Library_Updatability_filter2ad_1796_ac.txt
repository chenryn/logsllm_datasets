### 1. Obfuscation and Renaming
Classes have been renamed and shortened using an obfuscation tool such as ProGuard [20]. Specifically, we consider classes named with one or two lowercase alphabetic characters as obfuscated, following ProGuard’s renaming rules.

### 2. Determining Actual Changes
To determine the actual changes between consecutive library versions, we implement an API diff algorithm that compares two sets of public APIs: `apiold` (the API set of the immediate predecessor version) and `apinew` (the API set of the new version). An API is described by its signature, which includes the package and class name, as well as the list of argument and return types, e.g., `com.facebook.Session.getAccessToken(): java.lang.String`.

- **Patch-Level Release**: If `apiold = apinew`, it indicates a patch-level release, meaning there are only code changes.
- **Backwards-Compatible Minor Release**: If `apiold ⊊ apinew`, new APIs were added but existing ones did not change. This is classified as a backwards-compatible minor release.
- **Incompatible Changes**: Whenever `apiold` includes APIs that are not in `apinew`, we conduct a type analysis to check for compatible counterparts in `apinew`. Compatible changes include generalization of argument types, e.g., replacing an `ArrayList` argument with its super type `List`. Generalization of return types is generally not compatible and depends on the actual app code that uses the return value. We treat non-matching return types as incompatibilities to avoid false positives. Additionally, if the class and/or package names no longer match, we do not search for alternative candidates to avoid ambiguity. If we can identify alternatives for all non-matching APIs, we may classify the release as a patch or minor release. All other cases are classified as major releases.

### 3. Semantic Versioning Statistics
When applied to our library set, we found that in 58% of all version changes, the library developer incorrectly specified the new version string according to Semantic Versioning rules. No single library achieved 100% correctness in versioning. Only 3 out of 89 libraries (3.4%) correctly classified the release level in more than 80% of all releases, with the `android-oauth-client` library ranking first (93.8%). Conversely, 10 out of 89 libraries (11.2%) specified the version string correctly in less than 20% of all cases. Two libraries (`universal-image-loader` and `log4j`) did not specify a single version change correctly. We found no statistically significant correlation between library category (e.g., Advertising, Utilities) and the Semantic Versioning classification score.

A mismatch between expected and actual changes is disadvantageous for library consumers, as they cannot properly assess whether a new library version can be used as a drop-in replacement or if significant integration effort is required. The severity of the mismatch depends on the type of inconsistency. In particular, two types of inconsistencies are problematic:
- **Under-Specification**: If either a patch or minor release is expected, but the actual changes indicate a major release (highlighted cells in Table 3). This occurs in 39% of all cases, where the version increment is too moderate and suggests compatibility, even though API changes might break existing applications.
- **Over-Specification**: If a major release is expected, but the actual changes are minor. This occurs in about 6.5% of cases and does not affect compatibility but might impede widespread adoption due to the high expected integration effort.

Figure 12 summarizes the total number of expected and actual changes between consecutive versions by release level for the 1,971 analyzed versions. The expected changes reflect how library developers specified new version strings, which is what you would expect for a typical library lifecycle. However, the reality is different: 44% of all versions in our analysis were classified as major releases due to non-compatible changes and/or removals of existing APIs. This indicates poor library design without careful consideration of the effort and incompatibilities that consumers might experience.

### 4. Security Fixes
Finally, we examine security fixes in libraries. These are the most important updates and should typically be provided as patch releases. However, even when released quickly, such patches miss their intended effect if they are slowly adopted by app developers or not at all. Ultimately, end-users will be at risk and suffer from vulnerabilities like identity theft or private data leakage. To check if library developers adhere to this rule, we analyze vulnerabilities in Facebook, Dropbox, Apache Commons Collections (Apache CC), OkHttp, and known library vulnerabilities reported by Google’s ASI program [12]. In total, we investigated eight distinct bugfix versions.

For the eight vulnerable libraries, we determined whether the bugfix version is a patch release or if the library provider mixed bugfixes with new content or changed existing APIs. We then compared these findings with the official changelog to see if the fix was mentioned and properly documented. Table 4 shows the detailed results.

- **Patch-Level Fix**: Only Airpush and Dropbox provided a patch-level fix.
- **Minor Releases**: Six out of ten patched libraries (including two backports) are minor releases, indicating that the developer did not intend to provide a dedicated bugfix version.
- **Major Versions**: Facebook, MoPub, Supersonic, and Vungle provided a major version, including new functionality and/or breaking existing APIs.
- **Backport Patches**: Apache CC and OkHttp provided an additional backport of the security patch to allow effortless adoption by older versions. Surprisingly, both backport versions are patch-only updates, while the fixes for the current releases were announced as minor versions and included major changes.

Mixing critical security patches with API changes is considered bad practice and certainly contributes to a poor adaptation rate. Besides the version number, the changelog is the primary way to convey and explain important fixes and changes to the library consumer. However, only Apache CC explicitly mentions a security fix in its changelog, and four libraries at least mention a bug fix. Only the Dropbox and OkHttp vulnerabilities have a CVE entry.

### 5. Library Updatability
Keeping third-party dependencies up-to-date is a complex problem involving multiple parties. App developers primarily wish to update libraries for bugfixes and security fixes, while library developers want app developers to adopt new library versions within a reasonable timeframe. Section 3 showed that library developers contribute to the adaptation problem by not providing a simple means for app developers to assess whether a new library version can be integrated without compatibility issues.

To assess the current status quo in library updatability, we scan 1,264,118 apps from Google Play to identify included library versions. For each found library, we analyze the application bytecode to determine how the library is used in terms of API calls. Based on this information, we infer the highest library version that is fully API-compatible for that app/library combination.

#### 5.1 Approach
We base our approach on the open-source project LibScout [4], extending its implementation to conduct the following analyses:

1. **Library API Robustness**: We analyze the robustness of the public library API across versions of a given library. For each library with more than 10 versions, we determine, on a per-API level, the highest version that provides this exact API. We are conservative in that we do not search for alternative candidates if the API in question is no longer available, e.g., due to method removal or renaming. Similar to the SemVer analysis, we filter methods that are obfuscated or reside in internal packages. This analysis is more fine-grained than the API compatibility analysis conducted in [4], which checks whether the entire API set of some version is present in the successor version. This data would be insufficient to determine whether an actively used library can be updated.

2. **Library Usage**: To identify the actively used parts of a library, we scan the application bytecode for invocations of this library. To account for identifier renaming obfuscation, we match the library API with the identified root package name. For ambiguous profile matches, i.e., when LibScout cannot distinguish patch-level changes in libraries, we select one of the matched libraries. Since patch-level changes are API-compatible, this approach ensures accurate identification of the used APIs.