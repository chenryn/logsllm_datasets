在本章中，我们将使用一个非常简单的类 RISC 计算机作为目标机。我们在这个机器上加人
输出一个汇编程序使代码生成过程变得稍微容易一些。我们可以生成符号指令，并使用汇
328
a=b+e
ADD
这种策略常常会产生冗余的加载和存储运算。比如，下面的三地址语句序列
江
如果 IR是高层次的，代码生成器就要使用代码模板把每个 IR 语句翻译成为机器指令序列。
●想要达到的生成代码的质量。
?指令集体系结构本身的特性。
IR 的层次。
d，RO
RO,z
// d = RO
三
三
RO = a
a = RO
+C
第8章
---
## Page 345
图 8-2b 对应的最短汇编代码序列如图 8-3 所示。
图 8-2b 之间的唯一差别是第二个语句的运算符。图 8-2a 和
数，而奇数号寄存器保存商。
数号寄存器；而除数是Y。相除之后，偶数号寄存器保存余
其中，被除数占据了整个偶数/奇数寄存器对，×是其中的偶
奇数寄存器对。除法指令的形式如下：
其中被乘数×是偶数/奇数寄存器对中的奇数号寄存器，而
及寄存器对。乘法指令的形式如下：
例8.1
这个问题是 NP完全的。而且，目标机的硬件和/或操作系统可能要求代码遵守特定的寄存器使
用
快。
必须存放在内存中。使用寄存器运算分量的指令总是要比那些运算分量在内存中的指令短并且
最快的计算单元，但是我们通常没有足够的寄存器来存放所有的值。没有存放在寄存器中的值
8.1.4寄存器分配
的代码序列。动态规划将在8.11节中讨论。
果
和机器指令表示为树结构。然后，我们尝试着用一组对应于机器指令的子树覆盖一棵 IR 树。如
的代价信息。对于一个给定的三地址构造，可能还需要有关该构造所在上下文的信息才能决定
然后把结果保存回 a。
INC a来实现。这个指令要比如下的代码序列更加高效：把a加载进一个寄存器，对寄存器加1，
间代码的简单翻译虽然能产生正确的目标代码，但是这些代码却可能过于低效而让人不可接受。
序可以用很多种不同的代码序列来实现。这些不同实现之间在代价上有着显著的差别。因此，对中
数则可以存放在任意位置。乘法结果占据了整个偶数/
寄存器)。比如，在某些机器上，整数乘法和整数除法就涉
月规则，从而使这个问题变得更加复杂。
代码生成的关键问题之一是决定哪个值放在哪个寄存器里面。寄存器是目标机上运行速度
我们把每棵机器指令子树和－-个代价值相关联，我们就可以用动态规划的方法来生成最优化
现在，考虑图8-2 中的两个三地址代码序列。图8-2a和
个是最好的机器代码序列。
比如，如果目标机有－个“加一"指令（INC），那么三地址语句a=a+1可以用一个指令
代码生成
Dx,y
'XW
 在8.9节，我们将看到指令选择可以用树模式匹配过程来建模。在这个过程中，我们把 IR
生成代码的质量通常是由它的运行速度和大小来确定的。在大多数机器上，--个给定的 IR 程
即使对于单寄存器机器，找到一个从寄存器到变量的最优指派也是很困难的。从数学上讲
2）
寄
因
要
寄存器指派：我们指定一个变量被存放在哪个寄存器中。
寄存器分配：对于源程序中的每个点，我们选择一组将被存放在寄存器中的变量。
子存器的使用经常被分解为两个子问题：
此，有效利用寄存器非常重要。
要设计出良好的代码序列，我们就必须知道指令的代价。遗憾的是，我们经常难以得到精确
有些机器要求为某些运算分量和结果使用寄存器对（即一个偶数号寄存器和相邻的奇数
RO
图8-2两个三地址代码序列
图8-3最优机器代码序列
a
b
+
5
SRDA
b）
，a
+
3
329
---
## Page 346
算符，然后是一个目标地址，最后是一个源运算分量的列表。指令之前可能有一个标号。我们假
和条件跳转。这个计算机的内存按照字节寻址，它具有 n个通用寄存器 RO，Rl，…，Rn－1。一
8.2.1—个简单的目标机模型
技术也可以用于很多其他类型的机器。
代码作为目标语言。这个计算机是很多寄存器机器的代表。然而，本章中描述的很多代码生成
生成的一般性讨论中不可能描述出全部的细节。在本章中，我们将使用一个简单计算机的汇编
8.2目标语言
设有如下种类的指令可用：
们将只使用一个很有限的指令集合，并假设所有的运算分量都是整数。大部分指令包含一个运
个完整的汇编语言具有几十到上百个指令。为了避免因为过多的细节而妨碍对概念的解释，我
计算机可以在一个时钟周期内执行多个运算。
码，从而暂时避开这个问题。在第10章，我们将研究对流水线计算机的代码排序。这种流水线
困难的 NP 完全问题。一-开始，我们将按照中间代码生成器生成代码的顺序为三地址语句生成代
算顺序对用于存放中间结果的寄存器的需求更少。但是在一般情况下，找到最好的顺序是一个
8.1.5求值顺序
一个完整的源语言生成高质量的代码，我们需要了解该目标机的许多细节。遗憾的是，在对代码
构造出使用最少的寄存器来完成表达式求值的代码序列。
什么样的运算。
表示加载、保存和相加。需要注意的是，把a 加载到哪个寄存器的最优选择依赖于最终会对t做
把被除数从 RO中移人 R1 并把 RO 清空，使得所有位都等于被除数的正负号位。L，ST 和A 分别
我们的目标计算机是一个三地址机器的模型。它具有加载和保存操作、计算操作、跳转操作
熟悉目标计算机及其指令集是设计一个优秀代码生成器的前提。为了给某个目标机器上的
计算执行的顺序会影响目标代码的效率。我们即将看到，相比其他的计算顺序而言，某些计
寄存器的分配和指派的策略将在8.8节讨论。8.10节将给出对某些类型的机器，我们可以
Ri 表示第i号寄存器。SRDA 表示双算术右移（Shift-Right-Double-Arithmetic），而 SRDA RO 32
330
?加载运算：指令 LD dst，addr 把位置 addr 上的值加载到位置 dst。这个指令表示赋值 dst :
®
使得控制流跳转到标号L；否则，控制流传递到下--个机器指令。
了对寄存器r中的值所做的某个常见测试。比如，当寄存器r中的值小于O时，BLTZr，L
条件跳转：该指令的形式为 Bcond r，L，其中是一个寄存器，L是--个标号，而cond 代表
无条件跳转：指令 BRL使得控制流转向标号为L的机器指令。（BR 表示产生分支）。
r3，计算机会首先读出原来的值。只需要一个运算分量的单目运算符没有 src2。
SUBr，，计算了=2-。原先存放在中的值丢失了，但是如果等于r或者
的运算作用在位置 src;和 src 中的值上，然后把这次运算的结果放到位置 dst 中。比如,
和 src2是内存位置。这些位置不一定要相互不同。这个机器指令的作用是把 OP 所代表
计算运算：形如 OP dst，src1，src2，其中 OP是一个诸如 ADD或 SUB 的运算符，而 dst、src1
保存运算：指令 STx，r把寄存器中的值保存到位置x。这个指令表示赋值=。
αddr。这个指令最常见的形式是LD，x。它把位置x中的值加载到寄存器r中。形如LD
第8章
1
口
---
## Page 347
令序列：
的基地址 8i 个字节的地方。
可以通过下面的指令序列来执行三地址指令b=a[i]：
被用到，我们就不需要把这个值保存回x。
就可以避免相应的LD 步骤。类似地，如果×的值被使用时都存放在寄存器中，并且之后不会再
部四个指令。比如，Y和/或z 可能已经被计算出来并存放在一个寄存器中。如果是这样，我们
例8.2
在指令之后的注解由//开头。
代码生成
假设a 是一个元素为8字节值(比如实数)的数组。再假设a 的元素的下标从 0 开始。我们
为了实现一个简单的指针间接存取，比如三地址语句×=*P，我们可以使用如下的机器指
类似地，三地址指令
这里的第二步计算 8i；而第三步把a的第i个元素的值放到 R2 中，这个元素位于离数组a
也许我们能做得更好。一个优秀的代码生成算法的目标之一是尽可能地避免使用上面的全
·在指令中，一个位置可以是一个变量名x，它指向分配给x的内存位置(即x的左值)。
我们假设目标机具有多种寻址模式：
6
a(R2)，R1
·三地址语句x=Y－z 可以使用下面的机器指令序列实现：
整数100加载到 R1 中，而 ADD R1，R1，粗00 则把100 加到寄存器 R1中去。
最
的位置中的内容，再把这个内容代表的位置中的值加载到 R1中。
contents(R2)))。
位置。比如，LD R1，*100（R2）的效果是把 R1设置为contents（contents（100+
内存位置。而＊100(r)表示在r中内容加上100 的和所代表的位置上的内容所代表的
我们还支持另外两种间接寻址模式：*r表示在寄存器r的内容所表示的位置上存放的
将看到的那样，这个寻址方式可以用于沿指针取值。
得到的和，然后把这个和所指向的位置中的值加载到 R1 中。正如我们在下面的例子中
使得 R1=contents(100+contents（R2））。也就是说，首先计算寄存器 R2 中的值加上 100
到数组α的某个元素所要经过的字节数。
问是很有用的，其中α是数组的基地址（即第一个元素的地址），而：中存放了从基地址
contents（α)表示x所代表的寄存器或内存位置中存放的内容。这个寻址方式对于数组访
存器。α(r)所表示的内存位置按照如下方式计算得到：α的左值加上存放在寄存器r中的
一-个位置也可以是-个带有下标的形如α(r)的地址，其中α是一个变量，而r是一个寄
2
X，R1
a(R1)
R1，R2
N
令a[j]=c 所代表的对数组a 的赋值可以实现为：
。也就是说，首先计算寄存器 R2 中的内容加上100的和，取出和值所指
X=R1
1
=1
Z=
=y
contents(a + contents(R1))
contents(R2))= R1
331
1
---
## Page 348
8.2.38.2节的练习
机器上为表达式生成最优的代码。
所执行指令的代价总和最小。我们将会看到，在某些情况下，我们真的能够在某些类型的寄存器
时所执行的所有指令的代价总和。优秀的代码生成算法的目标是使得程序在典型输人上运行时
是一些例子：
寄存器寻址模式具有的附加代价为0，而涉及内存位置或常数的寻址方式的附加代价为1。下面
个指令的代价设定为1加上与运算分量寻址模式相关的代价。这个代价对应于指令中字的长度。
已经指出的，在代码生成时，我们通常必须满足于那些能够生成优良代码但不-一定是最优目标程
找到一个最优的目标程序是一个不可判定问题，而很多相关的子问题都是 NP 困难的。正如我们
们会使用不同的度量。常用的度量包括编译时间的长短，以及目标程序的大小、运行时间和能耗。
8.2.2程序和指令的代价
序的启发式技术。
算分量已经在寄存器中了，也可能因为结果不需要存放回内存。
它的等价的机器代码如下：
最后考虑一个带条件跳转的三地址指令：
在本章的其余部分，我们将假设每个目标语言指令都有相应的代价。为简单起见，我们把-
意一个三地址指令，我们希望可以省略这些指令中的某些指令。省略的原因可能是所需的运
332
练习8.2.1：假设所有的变量都存放在内存中，为下面的三地址语句生成代码：
·指令 LD RO，R1 把寄存器 R1 中的内容拷贝到寄存器 RO 中。因为不要求附加的内存字
这里的M 是从标号为L 的三地址指令所产生的机器指令序列中的第一个指令的标号。对于
if x<y goto L
5）两个语句的序列
在本章中，我们假设对于一个指定的输人，目标语言程序的代价是当此程序在该输入上运行
4
1)x= 1