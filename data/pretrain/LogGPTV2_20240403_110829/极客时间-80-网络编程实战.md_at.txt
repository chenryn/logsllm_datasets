### 非阻塞 I/O + readiness notification + 多线程前面的做法是所有的 I/O事件都在一个线程里分发，如果我们把线程引入进来，可以利用现代 CPU多核的能力，让每个核都可以作为一个 I/O 分发器进行 I/O 事件的分发。这就是所谓的主从 reactor 模式。基于 epoll/poll/select 的 I/O事件分发器可以叫做reactor，也可以叫做事件驱动，或者事件轮询（eventloop）。我没有把基于 select/poll 的所谓"level triggered"通知机制和基于 epoll的"edge triggered"通知机制分开（C10K 问题总结里是分开的），我觉得这只是reactor 机制的实现高效性问题，而不是编程模式的巨大区别。从 27 讲开始，我们就会引入 reactor 模式，并使用一个自己编写的简单reactor 框架来逐渐掌握它。
### 异步 I/O+ 多线程异步非阻塞 I/O模型是一种更为高效的方式，当调用结束之后，请求立即返回，由操作系统后台完成对应的操作，当最终操作完成，就会产生一个信号，或者执行一个回调函数来完成I/O 处理。这就涉及到了 Linux 下的 aio 机制，我们在第 30 讲对 Linux 下的 aio机制进行简单的讨论。
## 总结支持单机 1 万并发的问题被称为 C10K 问题，为了解决 C10K问题，需要重点考虑两个方面的问题：-   如何和操作系统配合，感知 I/O 事件的发生？-   如何分配和使用进程、线程资源来服务上万个连接？基于这些组合，产生了一些通用的解决方法，在 Linux下，解决高性能问题的利器是非阻塞 I/O 加上 epoll 机制，再利用多线程能力。
## 思考题最后给大家布置两道思考题：第一道，查询一下资料，看看著名的 Netty 网络编程库，用的是哪一种 C10K解决方法呢？第二道，现在大家又把眼光放到了更有挑战性的 C10M问题，即单机处理千万级并发，你认为能实现吗？挑战和瓶颈又在哪里呢？欢迎你在评论区写下你对这两个问题的思考，我会和你一起交流，也欢迎把这篇文章分享给你的朋友或者同事，一起交流一下。![](Images/5a282807b2a1ff091b7f803e8cef3429.png){savepage-src="https://static001.geekbang.org/resource/image/bf/25/bfc96ae0d8f839919b9d9866cfb8b025.jpg"}
# 25 \| 使用阻塞I/O和进程模型：最传统的方式你好，我是盛延敏，这里是网络编程实战第 25 讲，欢迎回来。上一讲中，我们讲到了 C10K 问题，并引入了解决 C10K问题的各种解法。其中，最简单也是最有效的一种解决方法就是为每个连接创建一个独立的进程去服务。那么，到底如何为每个连接客户创建一个进程来服务呢？在这其中，又需要特别注意什么呢？今天我们就围绕这部分内容展开，期望经过今天的学习，你对父子进程、僵尸进程、使用进程处理连接等有一个比较直观的理解。
## 父进程和子进程我们知道，进程是程序执行的最小单位，一个进程有完整的地址空间、程序计数器等，如果想创建一个新的进程，使用函数fork 就可以。    pid_t fork(void)返回：在子进程中为 0，在父进程中为子进程 ID，若出错则为 -1如果你是第一次使用这个函数，你会觉得难以理解的地方在于，虽然我们的程序调用fork一次，它却在父、子进程里各返回一次。在调用该函数的进程（即为父进程）中返回的是新派生的进程ID 号，在子进程中返回的值为0。想要知道当前执行的进程到底是父进程，还是子进程，只能通过返回值来进行判断。fork函数实现的时候，实际上会把当前父进程的所有相关值都克隆一份，包括地址空间、打开的文件描述符、程序计数器等，就连执行代码也会拷贝一份，新派生的进程的表现行为和父进程近乎一样，就好像是派生进程调用过fork 函数一样。为了区别两个不同的进程，实现者可以通过改变 fork函数的栈空间值来判断，对应到程序中就是返回值的不同。``{=html}这样就形成了文稿中的编程范式：    if(fork() == 0){  do_child_process(); // 子进程执行代码}else{  do_parent_process();  // 父进程执行代码}当一个子进程退出时，系统内核还保留了该进程的若干信息，比如退出状态。这样的进程如果不回收，就会变成僵尸进程。在Linux 下，这样的"僵尸"进程会被挂到进程号为 1 的 init进程上。所以，由父进程派生出来的子进程，也必须由父进程负责回收，否则子进程就会变成僵尸进程。僵尸进程会占用不必要的内存空间，如果量多到了一定数量级，就会耗尽我们的系统资源。有两种方式可以在子进程退出后回收资源，分别是调用 wait 和 waitpid 函数。    pid_t wait(int *statloc);pid_t waitpid(pid_t pid, int *statloc, int options);函数 wait 和 waitpid都可以返回两个值，一个是函数返回值，表示已终止子进程的进程 ID号，另一个则是通过 statloc指针返回子进程终止的实际状态。这个状态可能的值为正常终止、被信号杀死、作业控制停止等。如果没有已终止的子进程，而是有一个或多个子进程在正常运行，那么 wait将阻塞，直到第一个子进程终止。waitpid 可以认为是 wait函数的升级版，它的参数更多，提供的控制权也更多。pid参数允许我们指定任意想等待终止的进程 ID，值 -1表示等待第一个终止的子进程。options 参数给了我们更多的控制选项。处理子进程退出的方式一般是注册一个信号处理函数，捕捉信号 SIGCHILD信号，然后再在信号处理函数里调用 waitpid函数来完成子进程资源的回收。SIGCHLD是子进程退出或者中断时由内核向父进程发出的信号，默认这个信号是忽略的。所以，如果想在子进程退出时能回收它，需要像下面一样，注册一个SIGCHOLD 函数。    signal(SIGCHLD, sigchld_handler);  
## 阻塞 I/O 的进程模型为了说明使用阻塞 I/O和进程模型，我们假设有两个客户端，服务器初始监听在套接字 lisnted_fd上。当第一个客户端发起连接请求，连接建立后产生出连接套接字，此时，父进程派生出一个子进程，在子进程中，使用连接套接字和客户端通信，因此子进程不需要关心监听套接字，只需要关心连接套接字；父进程则相反，将客户服务交给子进程来处理，因此父进程不需要关心连接套接字，只需要关心监听套接字。这张图描述了从连接请求到连接建立，父进程派生子进程为客户服务。![](Images/af951578decb757e992ff1e2ad9888cf.png){savepage-src="https://static001.geekbang.org/resource/image/6c/a3/6cf70cf7f651273b38aac61cb61a88a3.png"}\假设父进程之后又接收了新的连接请求，从 accept调用返回新的已连接套接字，父进程又派生出另一个子进程，这个子进程用第二个已连接套接字为客户端服务。这张图同样描述了这个过程。![](Images/643feab2282a463d16d98b648f1054e9.png){savepage-src="https://static001.geekbang.org/resource/image/4f/08/4fb66c841fbca96f8b27c13c61a29608.png"}\现在，服务器端的父进程继续监听在套接字上，等待新的客户连接到来；两个子进程分别使用两个不同的连接套接字为两个客户服务。
## 程序讲解我们将前面的内容串联起来，就是下面完整的一个基于进程模型的服务器端程序。    #include "lib/common.h" #define MAX_LINE 4096 char rot13_char(char c) {    if ((c >= 'a' && c = 'A' && c = 'n' && c = 'N' && c  0);    return;} int main(int c, char **v) {    int listener_fd = tcp_server_listen(SERV_PORT);    signal(SIGCHLD, sigchld_handler);    while (1) {        struct sockaddr_storage ss;        socklen_t slen = sizeof(ss);        int fd = accept(listener_fd, (struct sockaddr *) &ss, &slen);        if (fd  quitConnection closed.    $telnet 127.0.0.1 43211Trying 127.0.0.1...Connected to localhost.Escape character is '^]'.agasgasgntnftnft]telnet> quitConnection closed.客户端退出，服务器端也在正常工作，此时如果再通过 telnet建立新的连接，客户端和服务器端的数据传输也会正常进行。至此，我们构建了一个完整的服务器端程序，可以并发处理多个不同的客户连接，互不干扰。
## 总结使用阻塞 I/O和进程模型，为每一个连接创建一个独立的子进程来进行服务，是一个非常简单有效的实现方式，这种方式可能很难足高性能程序的需求，但好处在于实现简单。在实现这样的程序时，我们需要注意两点：-   要注意对套接字的关闭梳理；-   要注意对子进程进行回收，避免产生不必要的僵尸进程。