Moreover, no user knows any of the random strings until at least
one round prior to the end of the epoch. That is, if epoch e has
good randomness, then epoch e + 1 also has good randomness.
Proof. By Lemma 3, there are at least 2c/3 honest members in the
ﬁnal committee w.h.p. Thus, each user in the network receives a set
R having from 2c/3 to 3c/2 random strings from members in the
ﬁnal committee in the last round of the epoch. The user’s random
string R is generated by XOR-ing any c/2 + 1 strings in R.
Since there are at most c/2 malicious members in the ﬁnal com-
mittee, at least one random string Ri used by malicious users orig-
inated at an honest user. Further, this Ri is not known by the ma-
licious users before the ﬁnal committee has agreed on the set S.
Thus, the r-bit string R generated by XOR-ing any c/2 + 1 is per-
fectly random. However, the attacker can still pick any of his c/2
values Ri to bias his random string R. As per Lemma 5, the at-
tacker’s bias to R is bounded by c − log(c)/2. Thus if we pick r
large enough, e.g., r > O(λ) + c − log(c)/2, the probability that
the attacker can guess R is negligible.
Finally, by construction any user can verify that the set of c/2+1
bit strings is valid by checking the commitments sent out previ-
ously. Similarly, it is immediate that no user knows the random
string prior to two rounds before the end of the epoch.
With the above lemmas in hand, the correctness of the ELAS-
TICO protocol follows from the following facts. We omit a theo-
rem and its formal proof, which is by induction and invokes Lemma 2–
Lemma 6 on different cases.
Claim 7. For every epoch i ≥ 1, with high probability, the follow-
ing properties hold:
(i) the ﬁnal committee will broadcast only one combined value
to the network with at least c/2 + 1 signatures and no other
combined value will have c/2 + 1 signatures;
(ii) this combined value contains 2s sub-values each of which
comes from a committee and is veriﬁed by at least one honest
processor; and
(iii) at the end of the epoch, each user has a publicly veriﬁable
random bit string of length r which has sufﬁcient randomness
(i.e., the following epoch has good randomness).
Notice that we have shown, at this point, that each epoch ends
with a correct (combined) value selected. Any user that is in the
system can, by listening, verify that this combined value is the cor-
rect and honest one. Often, it is desirable that the correctness by
externally veriﬁable, e.g., by a user that was not in the system at
the time.
In Bitcoin, this is achieved by showing that the chain
constructed is the longest chain, with very high probability (i.e.,
exponentially small probability). In fact, the same property holds
here: on average, it will take the malicious users twice as long to
generate a signed ﬁnal value as the honest users. Hence, an honest
“chain” will grow twice as fast as a malicious “chain” and hence
with very high probability it will be externally veriﬁable. (For a
more detailed discussion of this issue in Bitcoin, see [34]; the argu-
ment here is similar.)
5.
IMPLEMENTATION & EVALUATION
We implement ELASTICO and empirically evaluate the scalabil-
ity of ELASTICO and previous solutions. The goals of our evalua-
tion are twofold. We ﬁrst measure the scalability and efﬁciency of
ELASTICO when the network size increases. We aim to establish
that the performance of ELASTICO matches its theoretical analysis.
The second goal is to compare ELASTICO to other related consen-
sus protocols including Bitcoin [1], Bitcoin-NG [9] and PBFT [13].
5.1
Implementation
We implemented all components of ELASTICO based on the most
popular Bitcoin client version v0.12.1 [23]. Our implementation
is in C++ and has roughly 4, 000 LoC above that of Bitcoin’s code
base. We choose PBFT [13] as the consensus protocol for com-
mittees in ELASTICO. Since there was no well-maintained open
source implementation of PBFT when we started, we built a full-
ﬂedged implementation of our own, and the implementation may
be of independent interest to the community. We plan to release
ELASTICO for public use.
Recall that once the committee formation is complete, a normal
committee runs one instance of PBFT protocol to agree on a data
block of size 1 MB. The ﬁnal committee (or consensus committee)
runs two consecutive instances of PBFT protocol to agree on one
data block and the ﬁnal block which aggregates all data blocks from
other committees. Thus, nodes in the consensus committee bear
more cost than in normal committees.
Network implementation. We reuse the network implementa-
tion of Bitcoin for our peer-to-peer layer in the overall network.
The communications within committee are handled separately, in
which nodes in a committee form their own peer-to-peer overlay
network. Messages passed within a committee are not sent to nodes
in other committees. The choice of using peer-to-peer instead of
point-to-point communications within a committee is because the
latter requires much more resource for a node to open a socket con-
nection to each of 100 committee nodes.
Rate-limited mining. We artiﬁcially limit the mining rate to
allow testing ELASTICO with large scale experiments on a the pub-
lic EC2 infrastructure (which is expensive for our scale of testing).
In order to control the exact fraction of malicious computational
power, we limit the number of hash operations (i.e.,SHA2) that a
node (i.e., a processor) can perform to 1 operation per second. Each
hash output has a probability 1/600 of ﬁnding a valid PoW solu-
tion. Thus, on average it takes a processor 600 seconds to establish
its identity. Note that we still faithfully simulate the mining process
in Bitcoin, since we use the same implementation for mining.
5.2
ELASTICO’s Scalability
Experimental Setup. We run several experiments with different
settings on Amazon EC2 to measure the scalability of ELASTICO.
We vary the number of nodes in the network from 100 to 1, 600,
using up to 800 c4.large EC2 instances in two different regions
including Oregon and California. Each EC2 instance is shared by
two nodes, has 2 Amazon vCPUs and 3.75 GB of memory. Thus,
increasing the number of nodes in the network will increase the
computation power accordingly. We ﬁx our committee size at c =
100, to limit the performance overheads due to PBFT as we discuss
in Section 5.3.
Scalability of ELASTICO. We start with a network of 100 nodes
then double the network size 4 times, raising to 1, 600 nodes in
the last setting. We quantify the number of blocks created in each
epoch, time to reach consensus, number of PoWs required to ﬁll all
committees. The results are plotted in Figure 1. All numbers are
averaged after 10 epochs.
Figure 1 shows that ELASTICO scales up the block throughput
almost linear to the size of the network. The number of blocks per
epoch increases linearly (from 1 to 16) as we increase more nodes
to the network (100 to 1, 600 accordingly). However, the epoch
time is longer (e.g., 600 seconds in 100 nodes to 711 seconds in
1, 600 nodes) since it requires relatively more time to ﬁnd enough
PoWs to ﬁll up all committees when the number of committees in-
creases. In addition, we observe that the time to reach consensus on
blocks once the committee formation is complete remains almost
constant, regardless of the network size. For example, the laten-
cies to reach consensus are 103 and 110 seconds when the network
sizes are 400 and 800 nodes respectively. In summary, our experi-
500
400
300
200
100
0
)
s
(
y
c
n
e
t
a
L
n
o
i
t
a
g
a
p
o
r
P
1 Block
2 Blocks
4 Blocks
96
48
24
50
26
13
456
227
114
322
161
80
187
92
46
100
200
400
800
1600
Network size (number of nodes)
Figure 3: Latency of Bitcoin-NG with different number of micro blocks
8.1
8.09
8.11
8.12
8.13
1 Block
2 Blocks
4 Blocks
4.05
4.05
4.06
4.06
4.07
2.04
2.02
2.03
2.03
2.03
)
B
M
(
e
d
o
n
r
e
p
h
t
d
i
w
d
n
a
B
8
6
4
2
100
200
400
800
1600
Network size (number of nodes)
Figure 4: Bandwidth consumption of Bitcoin-NG with different number of
micro blocks and network sizes
therefore the number of blocks per epoch that the network can agree
on is 10, 000. State differently, ELASTICO scale up the agreement
by 4 orders of magnitude when deployed in a network of current
Bitcoin’s scale.
5.3 Comparison to Related Systems
We show how ELASTICO outperforms existing protocols in many
applications where the veriﬁcation check of a block does not re-
quire to scan through the entire history of the blockchain, but only
the block itself. A prominent example of such applications is an
append-only database for certiﬁcate directory, information regis-
tration platform and so on. In these applications, verifying a data
block can be done independently disregard to the current state of
the blockchain, thus ELASTICO nodes do not have to download
data blocks from other committees. We show that only ELASTICO
achieves the efﬁciency property deﬁned in Section 2. On the con-
trary, other protocols like Bitcoin, Bitcoin-NG [9] and PBFT re-
quire much more network bandwidth and/ or local computation at
each node when processing more transactions.
Bitcoin. Recent work has shown the scalability limit of Bit-
coin [10]. We also run our own set of experiments and get con-
sistent results with the results in [10]. Due to the space constraint,
we do not include this set of experiments and the results here.
Figure 1: ELASTICO scales up the throughput nearly linearly in the
computation capacity of the network.
Figure 2: Cost per node in ELASTICO stays almost constant regard-
less of network size.
ments conﬁrm the expected scalability of ELASTICO’s transaction
throughput.
Efﬁciency of ELASTICO. We next evaluate the efﬁciency prop-
erty (deﬁned in Section 2) of our protocol. Figure 2 depicts the
number of messages sent/received and the bandwidth consumed at
each node for different network sizes for reaching consensus once
the committees are formed. The number of messages per node re-
duces as more nodes join the network, while the bandwidth con-
sumed at each node ﬂuctuates around 5 MB per node.
The decrease in the number of messages exchanged when there
are more nodes in the network is because the extra messages re-
quired for running the second instance of PBFT in the ﬁnal commit-
tee are amortized. Thus, we see the reduction in the number of mes-
sages exchanged per node when the network size increases from
100 nodes (2, 416 messages) to 200 nodes (1, 821 messages). The
bandwidth used at each node, on the other hand, remains roughly
unchanged, e.g., 4.93 MB (400 nodes) and 5.01 MB (800 nodes)
per node. This is because the communication costs within commit-
tees are localized. Thus even when more nodes join the network,
existing nodes does not have to bear more costs.
Extrapolation to Bitcoin’s scale. We extrapolate the scale up
that ELASTICO can achieve in a network of current Bitcoin’s scale,
if we assume our scalability holds in real network. As of February
2016, the hash rate of Bitcoin network is 1.2× 109 GHash/s. Thus,
we assume that the network consists of n = 1, 000, 000 equivalent
processors, each of which can perform 1.2 × 103 GHash/s. We
consider a setting where the committee size is 100, thus the number
of committees is 10, 000. Each committee agrees on a single block,
0 2 4 6 8 10 12 14 16 18 0 100 200 300 400 500 600 700 800 900 100 200 400 800 1600 No. of Block  Time (s) Network size (number of nodes) Committee Formation time Consensus Time Blocks Final Scalability 4.00 4.40 4.80 5.20 5.60 6.00 500 1000 1500 2000 2500 3000 3500 100 200 400 800 1600 Bandwidth used per node (MB) Number of messages per node Network size (number of nodes) Number of messages Bandwidth Bitcoin-NG. Our next set of experiments compare the scalabil-
ity of ELASTICO and a recent scalability proposal namely Bitcoin-
NG [9]. Bitcoin-NG slightly modiﬁes Nakamoto consensus proto-
col to propose more blocks per epoch. At a high level idea, Bitcoin-
NG also probabilistically selects a leader, and the leader can pro-
pose several micro blocks (i.e., data blocks) per epoch. The leader
of the next epoch can decide which data block of previous epoch
he/ she wants to build on top.
We measure the bandwidth consumption per node of Bitcoin-NG
in different settings where the numbers of nodes are 100, 200, 400,
800, 1, 600. We also quantify the latency to broadcast different
number of micro blocks.
In terms of experimental setup, nodes
are distributed equally in two Amazon regions namely Oregon and
California. Each node randomly connects with 4 other nodes to
form a peer-to-peer network. We collect the source code of Bitcoin-
NG from the authors through our private communication. Figure 3
and Figure 4 report our results.
Figure 3 shows the latency of Bitcoin-NG for different number of
micro blocks. Bitcoin-NG performs well (i.e., low latency) when
the network size is small (100 nodes, 4 blocks, 50 seconds). Its