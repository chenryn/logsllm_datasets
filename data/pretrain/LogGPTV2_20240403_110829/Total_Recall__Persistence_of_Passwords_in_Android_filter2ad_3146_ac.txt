ID
Installs
0
N.A.
1
>1B
8
300M
0
100M
0
100M
2
100M
2
50M
0
10M
0
10M
10M
0
0.1M 117
0
0.1M
0.01M
3
PW
2
0
0
1
1
4
7
1
1
0
135
2
0
Japanese
Chinese
Voice support
Korean
TABLE II: Results for the tested keyboard applications.
is the default keyboard in the Android Open Source Project
(AOSP), and which should not be confused with Google’s
Gboard, which has over a billion installs, according to the
Google Play Store. All tested apps are listed in Table II.
We examined many popular keyboard apps, with hundreds of
millions of installs (Gboard, SwiftKey, Go, Kika, TouchPal)
as well as a number of less popular keyboards.
For each keyboard, we used it with the Facebook app,
typing our Facebook credentials for login. We then moved
Facebook into the background and locked the phone before
performing a memory dump. Table II shows the number of
copies of our user account (ID) and password (PW) that we
discovered for each keyboard app. Out of the 13 keyboard apps
we tested, nine of them hoarded user passwords. Fortunately,
two of the most popular keyboards, Gboard and SwiftKey,
cleaned up the passwords perfectly, only buffering account
IDs in memory which, generally speaking, aren’t sensitive like
passwords, so their presence in memory isn’t security-relevant.
Our most worrisome example is a keyboard that supports
simpliﬁed Chinese—it kept more than 100 copies of the user
password in memory.
Problem #4: Buffering the most recent input. Surprisingly,
the LatinIME keyboard also has password retention issues, so
we further analyzed its source code to identify the root cause.
We found that this is because this keyboard buffers the most
recent input obtained from a user, only clearing it when the
keyboard returns for subsequent data entry. This means that
when the keyboard is used for a sensitive input, like entering
a password, the password can stay in memory for quite a long
time.
LatinIME, by virtue of being Google’s AOSP reference
keyboard, has been used by many third-party keyboard devel-
opers as the starting point for their own efforts. That means
that we might expect a large number of less popular keyboard
apps to share these same problems. Since most keyboard apps
are closed source, we cannot directly verify whether their
developers have done this, but we believe that Table II hints at
this practice. The Go, Kika, FaceMoji, New Keyboard, and
Baidu keyboards all have similar patterns as the LatinIME
keyboard: they hold the user passwords but not the account
IDs. This is because users typically ﬁrst type their account
IDs and then passwords, in that order. Since the earlier entry
is gone and the later entry is present, this suggests reuse of
LatinIME’s buffering strategy.
6
A. Methodology
We wish to consider “example” apps using four categories
of authentication techniques: a) basic password-based authen-
tication apps, which simply send user passwords to a remote
server for authentication, b) challenge/response apps, which
derive secrets from passwords for authentication, c) OAuth
apps, which delegate authentication to an OAuth service (e.g.,
Facebook), and d) local authentication or standalone apps that
do not
including some password
manager apps.
involve a remote server,
If there exist popular open-source apps in the category
(e.g., Keepass2Android and PasswdSafe are open-source local
authentication apps), we directly analyze their source code.
Otherwise, we obtain similar types of apps from ofﬁcial sites,
open source repositories (e.g., GitHub), security guidebooks,
and developers’ website such as Stack Overﬂow. Many of
the apps we examined are relatively simple, demonstration
apps for some particular functionality rather than full-featured
applications. However, existing studies suggest that an analysis
of these sample apps is more representative than one might
initially think: many real-world apps contain the same snippets
from sample apps, e.g., obtained from Stack Overﬂow [23].
Collectively, we have analyzed more than 20 apps or code
snippets, and identiﬁed common mistakes throughout the cat-
egories.
B. Basic Password-based Authentication Apps
We ﬁrst consider basic authentication apps, where an app
sends raw user passwords to a server via HTTP/HTTPS. The
majority of apps we collected fall into this category, because
directly sending passwords is the simplest (but an insecure)
way of authentication. These apps use different libraries for
their implementations, but they share similar authentication
steps. Sample apps 1 – 2 in Table III are some of the basic
password-based authentication apps we have tested, and they
use different libraries for network communication (Apache
vs. Volley). The results show that both of them have many
password copies. Compared to the apps in the wild we have
examined in Section III, these apps are far worse. In order
to understand why such simple apps have so many password
copies, we have modiﬁed the apps one by one, and analyzed
the impacts of our modiﬁcations.
Problem #5: Use and propagation of String passwords.
We started by focusing our attention on the use of String
passwords. We mentioned in Problem #3 that the Android
framework provides getText().toString() in TextView.
Indeed, we saw that all the sample apps stored their passwords
as Java strings by invoking getText().toString(). How
much does the usage of String contribute to password reten-
tion? To measure the effect of String usage, we deleted all
uses of String in sample app 1, and instead, we had the app
send an empty password. The “server” ran on a local desktop
machine in our lab; it always sent successful authentication
messages to the app. Sample app 1a in the same table shows
the results after the modiﬁcation. This change eliminated more
than half of the in-memory passwords relative to the original
Category
Basic
Cha./Resp.
OAuth
Application
Sample 1
Sample 2
Sample 1a
Sample 1b
Sample 3
Sample 4
Description
Uses Volley lib.
Uses Apache lib.
Empty request
Nullifying widget
App security book
With Facebook
Login
25
28
11
4
21
3
BG
24
16
10
4
20
2
YouTube
11
13
5
0
8
1
Lock
11
12
5
0
7
1
TABLE III: Results for some of the sample apps.
version (sample app 1). This demonstrates that String is a
major source of problems, though not the only one.
Problem #6: Lack of manual TextView cleanup. Recall that
TextView holds the password in its buffer after it’s no longer
needed (Problem #1 and #2). This leaves the responsibility of
cleaning up TextView to individual app developers. To see
how effective a manual cleanup would be, we modiﬁed the
sample app 1a to call the clear() method in the buffer of
TextView right after login. Sample app 1b, which is the mod-
iﬁed app, did show some more improvement: all passwords in
the app’s memory were successfully deleted after playing the
YouTube videos. This means that calling the clear() method
of the buffer is effective. Unfortunately, almost all apps we
analyzed (including the SystemUI core service) did not clean
up the TextView buffer, with Keepass2Android being the only
exception. We also note that calling clear() does not clean up
passwords in app 1b immediately. This is because the clear()
method of the TextView buffer does not implement secure
deletion, but only sets the buffer to null and leaves it to the
garbage collector (Problem #1).
Problem #7: Lack of app-level zeroization. Even if an
app developer uses char arrays instead of String objects,
they would also need to clean up the passwords in their
apps manually, e.g., by zeroing out the char arrays. In other
words, even with a much stronger TextView implementation,
developers may still accidentally hold passwords in memory.
C. Challenge-Response Authentication Apps
We now turn to apps that use some form of challenge/re-
sponse authentication. Challenge/response apps do not directly
send passwords to the network, but rather generate HMAC
values from user passwords and use them as secrets for the
remote servers to perform authentication. By avoiding the
transmission of passwords over the network, they certainly
improve an application’s security posture, but do they do a
better job of handling passwords? We analyzed an app from a
popular security guidebook [27] (sample app 3). As shown in
Table III, this app is not notably different from sample apps 1
and 2. In fact, we analyzed the source code and found the same
problems #5 – #7 in its source code. Even worse, this “security
guidebook” app simply uses strings for passwords. Although
the number of password copies is slightly lower than those in
apps 1 – 2, this reduction of password copies mainly comes
from the fact that passwords are not propagated as widely as
in the apps that directly use passwords for authentication.
implemented sample app 4 using the Facebook OAuth library,
following the ofﬁcial guide from Facebook. If we launch
the app and click the login button, our app redirects to the
Facebook app, which then prompts the user for a password
and performs the requested authentication; the Facebook app
redirects back to our original app upon success, which then
displays a successful login message.
Sample app 4 in Table III shows the results. Although it is
far more secure than previous apps, it still holds quite a few
password copies in memory, and one of the copies remains
in memory after the phone is locked. All of these passwords
were found in the memory of the Facebook app itself, not in
our sample app.
Since the Facebook OAuth library and app are not open
source, we were not able to perform a code analysis. However,
our instrumentation of the Android framework reveals that
Facebook uses the standard TextView for passwords, as well
as its toString() method, which explains the password re-
tention. This is unfortunate, because Facebook’s OAuth library
is completely outside of the reach of any developer who might
want to zeroize the passwords in its memory, and this issue
will impact any app that uses it. As additional evidence, sample
app 4 (Table III) has identical password retention patterns
as Yelp (Table I), both of which use Facebook OAuth for
authentication.
E. Password Managers
We now consider password managers. If any app de-
velopers would take caution in controlling the presence of
passwords in memory, certainly it would be the developers of
password managers! As shown in Table I, password managers
are comparatively more secure than other apps, yet still many
passwords remain in memory. To begin, we analyzed the code
for Keepass2Android and PasswdSafe, which are two popular
open-source password managers, to identify their practices for
password handling. Keepass2Android consists of more than
80,000 lines of code and more than 300 source code ﬁles.
We found that its codebase is particularly well engineered to
handle secure password deletion.
•
•
•
It converts a password into char array and uses the
latter to generate master keys.
After authentication, it sets the TextView’s content
to an empty string, and it manually sets all password-
related objects to null.
It manually invokes the garbage collector, which might
help accelerate memory reuse.
the
above
combination of
Using a
techniques, Kee-
pass2Android successfully cleared all passwords from its own
memory when it went
to the background. However, Kee-
pass2Android still obtains passwords from TextView as a
String object before the char conversion, which results in
immutable passwords outside of the app’s ability to erase them.
Indeed, we found passwords for Keepass2Android in the full
memory dump.
D. OAuth Authentication Apps
We next consider apps that provide OAuth services. Since
Facebook is a dominant identity provider for OAuth, we have
Another password manager, PasswdSafe, is also commend-
able in its security measures. In fact, we were impressed with
their level of effort in handling passwords after analyzing the
source code. First, this app implements a manual reference
7
G. Summary of the Problems
To summarize, our analysis has revealed seven main causes
of password retention, which are prevalent
in many apps
and the Android framework itself. Some of the root causes
are also inter-related. For instance, Problem #5 (the use of
String passwords) needs to be addressed before Problem #7
(manual zeroization) can be solved, because String objects
are immutable. As another example, Problem #5 is attributed
partly to Problem #3 (the lack of secure API). Therefore, in
order to solve the password retention, we need to develop
a complete solution that addresses all of the identiﬁed root
causes together.
VI. OUR SOLUTION
In this section, we describe a series of changes that we
engineered to the AOSP framework that can address the
problems we have observed.
A. SecureTextView: Fixing the Android Framework
We have developed ﬁxes for the Android framework by
designing a patched version of TextView that we call Secure-
TextView. Since the root cause of retention in the Android
framework lies in the use of TextView, we developed ﬁxes to
TextView to handle passwords differently from regular textual