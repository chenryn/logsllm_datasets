User: We need to deploy a new application in the Kubernetes cluster. This application needs to use a self-built Docker image. Please provide the deployment plan and steps of this application.
Assistant: Deployment scheme: 1. Build a Docker image on the local machine and push it to the container registry. You can use Dockerfile to build the image, for example: ``` FROM ubuntu:18.04 RUN apt-get update \ && apt-get install -y python3-pip \ && apt-get clean \ && rm -rf /var/lib/apt/ lists/* COPY requirements.txt /app/ RUN pip3 install -r /app/requirements.txt COPY . /app CMD [ "python3", "/app/main.py" ] ``` where `main.py` is Application entry file, `requirements.txt` is a list of Python dependencies. 2. Create a Kubernetes deployment file, for example: ``` apiVersion: apps/v1 kind: Deployment metadata: name: myapp-deployment spec: replicas: 3 selector: matchLabels: app: myapp template: metadata: labels: app: myapp spec: containers: - name: myapp-container image: <your-repository>/<your-image-name>:<tag> ports: - containerPort: 5000 ``` This file defines a deployment named `myapp-deployment` , where the application container is named `myapp-container` and the mounted port is 5000. The `image` field should be set to the address of the Docker image you just built and pushed. 3. Deploy these two files to the cluster using the `kubectl` command line tool: ``` $ kubectl apply -f Dockerfile.yaml $ kubectl apply -f myapp-deployment.yaml ``` This will create the A deployment called `myapp-deployment` and automatically pushes and starts three replicas of the container. 4. The deployment status can be checked using the `kubectl` command line tool: ``` $ kubectl get deployment myapp-deployment ``` This should show the deployment object including the three containers. 5. The container running status can be checked using the `kubectl` command line tool: ``` $ kubectl get pods --selector=app=myapp ``` This should list the running `myapp` containers in the Kubernetes cluster. 6. You can use the `kubectl` command line tool to expose the service port: ``` $ kubectl expose deployment myapp-deployment --type=LoadBalancer --port=8080 --target-port=5000 ``` This will be in the Kubernetes cluster Create a service object called `myapp-deployment`, expose it as a `LoadBalancer` type service, and map port 5000 of the container to port 8080 of the Kubernetes service. 7. The status of the service can be checked using the `kubectl` command line tool: ``` $ kubectl get services myapp-deployment ``` This should display the IP address and port of the newly created service object. The application is now accessible through this IP address and port. The above deployment scheme and steps can meet the needs of deploying new applications using self-built Docker images in Kubernetes clusters.