title:Automatically Inferring Malware Signatures for Anti-Virus Assisted
Attacks
author:Christian Wressnegger and
Kevin Freeman and
Fabian Yamaguchi and
Konrad Rieck
Automatically Inferring Malware Signatures
for Anti-Virus Assisted Attacks
Christian Wressnegger*, Kevin Freeman†, Fabian Yamaguchi*, and Konrad Rieck*
* Institute of System Security, TU Braunschweig
† Institute of Computer Science, University of Göttingen
Abstract
Although anti-virus software has signiﬁcantly evolved over
the last decade, classic signature matching based on byte
patterns is still a prevalent concept for identifying security
threats. Anti-virus signatures are a simple and fast detection
mechanism that can complement more sophisticated analysis
strategies. However, if signatures are not designed with care,
they can turn from a defensive mechanism into an instrument
of attack.
In this paper, we present a novel method for
automatically deriving signatures from anti-virus software
and discuss how the extracted signatures can be used to
attack sensible data with the aid of the virus scanner itself.
To this end, we study the practicability of our approach
using four commercial products and exemplary demonstrate
anti-virus assisted attacks in three diﬀerent scenarios.
Keywords
Anti-Virus; Malware; Signatures; Attacks
1.
INTRODUCTION
Virus scanners are one of the most common defenses
against security threats—despite well-known weaknesses and
shortcomings. Millions of end hosts run these scanners on
a regular basis to check ﬁles for infections and detect ma-
licious code. Individuals, companies and even government
organizations employ anti-virus software for fending oﬀ at-
tacks at their desktop systems. The success and preva-
lence of these products largely build on their simple yet
reliable functionality: Files are matched against a database
of known detection patterns (signatures) which is regularly
updated by the vendor to account for novel threats. Such
pattern matching can be implemented very eﬃciently and is
able spot all sorts of threats if appropriate and up-to-date
signatures are available [see 3, 58].
Signature-based detection suﬀers from a well-known draw-
back: Unknown threats for which no signatures exist can eas-
ily bypass the detection. This problem is further aggravated
by the frequent use of obfuscation in malicious code that
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
ASIA CCS ’17, April 02 - 06, 2017, Abu Dhabi, United Arab Emirates
c(cid:13) 2017 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ISBN 978-1-4503-4944-4/17/04. . . $15.00
DOI: http://dx.doi.org/10.1145/3052973.3053002
obstructs static signature matching [14, 34, 37]. As a conse-
quence, a large body of research has focused on developing
alternative approaches for analyzing and detecting malicious
software, for example, using semantic models [e.g., 10, 11],
behavioral analysis [e.g., 13, 28, 31] or network traﬃc monitor-
ing [e.g., 20, 21, 54]. Over the last decade, anti-virus vendors
have increasingly adopted these detection mechanisms to
keep up with malware evolution. Still, signatures based on
byte patterns remain an integral part of security products
and complement more sophisticated detection mechanisms.
Attackers are well aware of the prevalence of virus scanners
and the detection mechanisms they employ. Thus, an ad-
versary might not only seek means for evasion but also take
advantage of their presence, for example, by injecting signa-
tures into benign content. In 2014 the Bitcoin blockchain
contained the signature of the DOS/STONED malware, trick-
ing the Microsoft Security Essentials into falsely identifying
the ﬁle as malware and removing it [62]. The nature and
origin of the incident is unclear and so is the fact whether
this has been an isolated proof-of-concept, driven by the
manual eﬀort of reverse engineering malware signatures or
part of an automated attack.
In this paper, we systematically explore the feasibility
of such anti-virus assisted attacks. We introduce a novel
method for automatically deriving signatures from commer-
cial virus scanners which is agnostic to the particular im-
plementation and provides an adversary with byte patterns
that approximate the original signatures without the need
to reverse engineer the analysis engine or signature database.
With these patterns at hand, the attacker can draw a virus
scanner’s attention to benign data and ﬂag chosen content as
malicious, and thereby selectively block access or delete ﬁles.
Moreover, we show that such malicious markers do not have
to be injected directly, but may be inﬁltrated as unprivileged
user in a way that these end up in the local data store, that
then gets ﬂagged by the virus scanner.
To assess the feasibility of this attack in practice, we ap-
ply our method for signature derivation to four commercial
anti-virus products in an empirical study. We ﬁnd that on
average 38% of the derived signatures can be approximated
by simple combinations of byte patterns. Several of these
patterns match text strings, artifacts of packers or environ-
ment checks, and are mostly unrelated to the semantics of
the considered malicious code. Furthermore our study shows
that only 8% of such signatures match patterns, that are
detected by more than one anti-virus product considered in
our experiments, enabling an attacker to play oﬀ gateway
and end-user security solutions against each other by crafting
587target-speciﬁc inputs. Finally, we make use of the inferred
malicious markers to demonstrate anti-virus assisted attacks
in three diﬀerent scenarios: 1) covering up password guess-
ing, 2) deleting a user’s emails and 3) facilitating web-based
attacks by removing browser cookies.
In summary we make the following contributions:
• Anti-virus assisted attacks. We introduce a new
class of anti-virus assisted attacks that limit access to
benign data by abusing byte-pattern based signatures
and demonstrate their feasibility in diﬀerent scenarios.
• Automatically deriving signatures. We present a
novel method for automatically deriving pattern-based
signatures from virus scanners without the need for
manually reverse engineering the software.
• Identiﬁcation of inadequate signatures.
In an
empirically study with four commercial anti-virus prod-
ucts, we identify overly simplistic signatures that build
on short byte patterns of resource or code artifacts and
thus are well-suited for the described attacks.
The remainder of the paper is structured as follows: In
Section 2 we describe the attack vector and present a brief
overview of anti-virus signatures. We introduce our method
for deriving signatures in Section 3 and empirically study
its application and results in Section 4.
In Section 5 we
then present speciﬁc attacks based on malicious markers and
discuss mitigations in Section 6. Limitations and related
work are discussed in Section 7 and Section 8, respectively.
Section 9 concludes the paper.
2. ANTI-VIRUS ASSISTED ATTACKS
Over the last years, numerous software ﬂaws have been
identiﬁed in popular anti-virus products [e.g., 25, 42]. For
example, Ormandy disclosed vulnerabilities in products of
ESET [43], Kaspersky [44], AVG [46], FireEye [45] and more
recently Symantec/ Norton [47]. These ﬁndings are especially
critical as the corresponding products are employed in many
network and host defenses. According to leaked internal
documents, even the NSA and GHCQ have set their hands
on anti-virus software to inﬁltrate networks [16].
We advance this line of work and present a novel class of
anti-virus assisted attacks, called malicious markers, that
does not rely on exploiting vulnerabilities but is based on the
weak design of pattern-based signatures. Although modern
anti-virus products comprise several diﬀerent detection mech-
anisms, signatures based on byte patterns are still widely
used as a complementary tool. In the following, we introduce
malicious markers as attack vector (Section 2.1) and look
upon anti-virus signatures that can be used to execute this
unique type of attack (Section 2.2).
2.1 Attack Vector
Any initially benign data that at some point in time con-
tains malware or its payload clearly has to be considered
harmful by an AV product. A ﬁle can thus be trivially ﬂagged
as malicious by injecting malware. However, in case only a
couple of carefully selected byte patterns are added to a ﬁle
that do not represent malicious functionality but happen to
match a signature deployed by virus scanners, the situation
is not necessarily as clear anymore.
Ideally, malware signatures capture malicous functionality.
In practice however, byte-pattern based signatures often
match resources, wrongly aligned code, import tables or
compressed data. Even worse, if the virus scanner does not
consider additional context for its decision, signatures can
be freely moved to other ﬁles. Malicious markers rely on
implanting such overly simplistic malware signatures into
benign data to raise false alarms.
In the most trivial case an attacker would achieve such an
implant by directly manipulating the targeted ﬁles. However,
having direct (privileged) access would give rise to several
other, way more powerful attacks than deleting or restricting
access to data. Malicious markers on the contrary allow to
operate on a more subtle setting where a remote attacker has
no direct access but is able to remotely “contribute” to a local
ﬁle. Inadequate signatures that do not consider the context
of the matched bytes are smuggled through input validation
of common network protocols and end-user applications to
trigger false-positives on the client-side.
Furthermore, such minimal triggers enable an attacker to
play oﬀ gateway and end-user security solutions against each
other if products from distinct vendors are used.
2.2 Anti-Virus Signatures
Anti-virus software comprises a wide range of diﬀerent
analysis and detection techniques, including batch process-
ing, on-access analysis, behavioral blocking and scheduled
updating of signatures. While the underlying analysis engines
often build on sophisticated concepts, such as bytecode inter-
preters [42] and other Turing-complete representations [8],
the actual signature matching typically boils down to three
basic strategies: byte patterns, hash sums, and in the widest
sense of the phrase, similarity measures. In the following, we
describe each of these strategies in more detail to identify
types that are suitable for malicious markers and set the
scope for our approach of deriving signatures.
Signatures based on Byte Patterns
2.2.1
The most common strategy for signature-based detection
is the use of byte patterns. These signatures contain one
or more constant sequence of bytes, possibly separated by
gaps of varying size, that need to match with the content
of a ﬁle to trigger a detection. These signatures can be
eﬃciently matched using classic string-processing techniques,
such as the Aho-Corasick algorithm [1, 22]. To this end, sets
of strings are represented as a Trie that serves as a ﬁnite
state machine for determining matches. This representation
allows to eﬃciently model wildcards, ranges and character
classes, thereby providing capabilities similar to those of
regular expressions.
Example of byte patterns. The open-source scanner ClamAV
deﬁnes a simple format for representing byte patterns, in-
cluding disjunctions (aa|bb), gaps {n-m}, wildcards ’?’ and
character classes [57]. Figure 1(a) shows a simpliﬁed version
of such a signature for the Virut malware family. While
ClamAV can generally match arbitrary data, in case of the
provided example the signature describes x86 code that cor-
responds to a simple decryption routine. Figure 1(b) shows
one instance matched by the above signature.
Formally, pattern-based signatures simply are a subset of
regular expressions, yet for the purpose of signature deriva-
tion, we choose a diﬀerent formal description that focuses
entirely on their appearance. We observe that pattern-based
signatures are given by sequences of disjunctions over bytes,
588(8a|86)0666(29|31)(c8|d0|d8|e8|f8)(86|88)0646
d4b1d2a45d2c555d3d77e472d47352d5:162970:Worm.Kido-249
(a) ClamAV signature W32.Virut.si
(a) ClamAV signature Worm.Kido-249
1
2
3
4
8a 06
66 31 e8
88 06
46
; mov al, byte ptr [esi]
; xor ax, bp
; mov byte ptr [esi], al
; inc esi
81920:2c8ba8e00c4b425e99fcda86f51e2b98:Worm.Kido-77
(b) ClamAV signature Worm.Kido-77
(b) Corresponding x86 code snippet.
Figure 1: ClamAV signature for the Virut malware
and the correspoding x86 code snippet.
Figure 2: Example of two hash-based signatures:
ClamAV signatures for the Kido malware matching
(a) the complete ﬁle and (b) only a speciﬁc PE Sec-
tion of the malware.
possibly separated by gaps of varying size. Expressing each
disjunction as a set containing its alternatives, a signature
becomes a sequence of sets. We can describe this formally by
deﬁning a symbolic alphabet S = P({0, . . . , 255}), where P
is the power set and corresponds to all possible subsets of byte
values. Additionally we use (cid:63) as a shortcut for {0, . . . , 255}
to represent irrelevant bytes. Each word w ∈ S∗ of the corre-
sponding language then already fully expresses the format of
a signature. However, these words alone do not account for
the varying sizes of gaps. We hence introduce two functions,
l : {1, . . . ,|w|} → N and h : {1, . . . ,|w|} → N that assign a
minimum and maximum number of repetitions to each of
w’s symbols. A pattern-based signature is then simply given
by the tuple s = (w, l, h).
2.2.2 Signatures based on Hash Sums
A second strategy frequently implemented by anti-virus
software is matching based on hash sums. To this end, hash
sums over complete ﬁles or parts of ﬁles are calculated and
stored in the signature database. Simple checksums such
as CRC32 or cryptographic hash functions such as MD5 or
SHA1 are often used due to the availability of fast implemen-
tations in both software and hardware [24, 42, 57]. While
hash collisions may theoretically result in false positives, in
practice this is not an issue in this particular ﬁeld of ap-
plication, making it an attractive choice for many vendors.
In comparison to byte patterns, hash sums enable match-
ing large regions in a ﬁle with a compact signature. This
approach, however, does not allow for wildcard characters
or gaps, and therefore provides no means to match largely
similar ﬁles with a single signature. In consequence, individ-
ual hash-based signatures are required for even the slightest
variations of known malware samples.
Conceptually, hash-based signatures can however be inter-
preted as continuous byte patterns and thus the signatures
can be described using the same formal description presented
in Section 2.2.1. In particular, a hash sum with given oﬀset
and length can be represented as a continuous byte pattern
that is preceded by a gap of ﬁxed size.
Example of hash sums. The open-source scanner ClamAV
enables to deﬁne hash-based signatures either as hash sum
of the complete ﬁle or speciﬁcally for PE ﬁles over individual
sections [57]. Figure 2 illustrates both types of hash sums for
the malware Kido, where in the ﬁrst case the length of the