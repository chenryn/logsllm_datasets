# AntCTF X D³CTF Reverse签到题 No Name 详细题解 & IDA入门使用技巧
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## JEB分析文件
apk文件拖入JEB进行分析
发现程序调用了checkFlag函数对flag进行检验
发现check函数是一个native函数，所以去so文件里面寻找对应的函数
## FlagChecker_check Native函数分析
在IDA中搜索check函数，可以搜索到一个
发现了check函数
###  还原参数类型
找到函数后，我们要先把第一个参数变量类型设置成 **JNIEnv ***
这样的话对于识别一些函数会方便很多，在分析so文件的时候都推荐这样来做
###  基本框架分析
修改之后再观察代码信息
发现这个函数从输入中获取信息，并把长度信息保存在v6[0]的位置，传入 **sub_D478** 函数进行解密，解密后的内容使用 **memcmp**
进行比对。 **这是一种比较常见的情况，告诉你函数操作结束后的内容，要求你逆向出函数操作来得到输入信息**
### 分析 **sub_D478** 函数
一眼可以看出是一个变种的TEA的 **解密函数** ，运算轮数为16轮，所以sum的值从 **0xE3779B90** 开始
**使用Invert sign快速识别常量**
对于 **0x61C88647** 这个常量，如果你做题做的不够多，可能一眼看不出来这个就是 **0x9E3779B9** 的补码
这个时候就可以尝试在数据上右键， **Invert sign** 一下再看看数据
转换之后就可以看到熟悉的 **TEA常数** 了（可以借助百度来快速的分析算法）
**编写TEA解密代码并解密**
    void tea_decrypt(uint32_t* v, int len)
    {
        for (int idx = 0; idx > 2; idx += 2)
        {
            uint32_t v0 = v[idx], v1 = v[idx + 1], sum = 0xE3779B90, i;
            uint32_t delta = 0x9e3779b9;
            _DWORD v12[4];
            memcpy(v12, "com.d3ctf.noname", 16LL);
            for (int j = 0; j > 5)) + v0) ^ (sum + v12[(sum >> 11) & 3]);
                sum -= delta;
                v0 -= (((16 * v1) ^ (v1 >> 5)) + v1) ^ (sum + v12[sum & 3]);
            }
            v[idx] = v0;
            v[idx + 1] = v1;
        }
    }
    void tea_encrypt(uint32_t* v, int len)
    {
        for (int idx = 0; idx > 2; idx += 2)
        {
            uint32_t v0 = v[idx], v1 = v[idx + 1], sum = 0, i;
            uint32_t delta = 0x9e3779b9;
            _DWORD v12[4];
            memcpy(v12, "com.d3ctf.noname", 16LL);
            for (i = 0; i > 5)) + v1) ^ (sum + v12[sum & 3]);
                sum += delta;
                v1 += (((v0 > 5)) + v0) ^ (sum + v12[(sum >> 11) & 3]);
            }
            v[idx] = v0;
            v[idx + 1] = v1;
        }
    }
解密后发现
可恶，居然拿了个假的flag。
**疑问**
根据代码逻辑来说，应该是要对最后比对的数据进行加密，编写加密函数输出的内容才是要输入的内容，但是这道题里面使用的却是用解密函数输出fake_flag，不过影响不大，因为这个反正不是真正程序执行的内容
## 重新审视文件
由于前面分析的急切，所以都没有注意到程序中其他内容，以至于分析到了错误的flag。
浪费了很多时间后，我们又回到了起点，
发现有这么一个函数，观察发现FlagChecker类居然被替换了。
而这部分代码的逻辑是，对data.enc文件进行AES解密，秘钥信息从native函数中得到。
## NoNameApp_getAESKey Native函数分析
这里实际上可以下断点来调试程序。但是我这里由于没有实体机，且so文件只提供了amd64的格式（在模拟器上无法正常的运行），所以我这里只能静态分析。
发现直接返回了key的内容，所以key的数据应该在其他地方被修改调用。
同时我们知道key的长度是0x10，也正好符合AES-128的秘钥长度。
###  还原key的数据类型
双击进入数据显示
发现key的旁边是 **%4** ，我理解为IDA识别这个变量的长度，我们这里要设置成的是1字节。
在内容下按D键多次，直到显示为 **%1**
接着按下小键盘上的星号，可以定义key为数组，设置数组长度（Array size）为0x10
最后就成功还原成这样了
###  分析key数据内容
在这个函数中，没有对key的数据内容进行任何的修改，那么只可能是在初始化的时候就生成了key的信息，我们可以从 **JNI_OnLoad**
开始分析，但是我这里为了方便，用一个更简单的方法快速定位
**查找引用**
在变量上按下 **X 查找引用**
发现了引用位置
**定义函数**
发现这一块代码都是红色的，我们之间按F5没有任何的反应，这代表这一块的代码还没有被定义成函数，一般来说是IDA对于这一块代码的栈帧分析数据存在一些问题，或者IDA分析后不认为这里是个函数。
前者需要手动修改，而我们这里是后者的情况，我们只需要到函数头部按下 **P键手动进行定义函数** 。
定义后再按下F5，就可以看到比较舒服的伪代码了， **这得益于之前的信息还原**
这一块内容对key进行运算，我们可以直接复制这一块的伪代码，以及此函数最上面的变量定义，删除一些无关紧要的变量后，补上一些文件头后，可以直接在IDE中运行。
同时在这一段伪代码中，只调用了 **sub_D478** 函数这一个函数，而这个函数就是我们之前所编写的TEA解密函数，所以我们直接替换即可
###
**引入IDA常用函数头文件**
我一般使用的是vs，这里需要补充的一点是，有些在伪代码的函数定义是不存在的，这时候需要使用
    #include "defs.h"
来引入头文件，这个文件在 **IDA目录下的plugins文件夹** 内，这个文件里面包含了伪代码中绝大多数变量类型和函数定义。
**导出程序常量**
这一行语句里面包含了一个全局变量，我们需要把这个全局变量导出，才能在我自己的代码中使用。我一般用的方法是先定义为数组，然后再用 **Shift + E**
导出。
我们从之前的分析中得知前四个字节存放字符长度，所以我们只需要设置后0x10长度的数据为数组即可。
IDA只能导出unsigned char 的字节数据，对于其他类型的导出，IDA还不支持，我们只能用插件来完成这个功能，我这里使用的是
**LazyIDA.py** 插件。
###  执行程序得到AES-KEY
在上述操作后，我们可以编写代码并且成功执行。
在比赛的时候时间是比较宝贵的，所以使用VS下断点来直接的观察程序内存数据不妨为一个好方法
可以通过vs自带的内存查看，在地址栏中输入key就会跳转到对应位置。
**坑点**
这里刚开始算出来的key一直都是错误的，在之后才发现原来这个常量数组在其他地方被修改了，导致无法计算出正确值。
## 解密数据
得到key之后，我们就可以用python直接解密文件
    import binascii
    from Crypto.Cipher import AES
    key = binascii.unhexlify("bbbc3bef42b068f57a90078cc03f797b")
    aes = AES.new(key, mode=AES.MODE_ECB)
    with open("data.enc", "rb") as fp:
        with open("data.jar", "wb") as f:
            f.write(aes.decrypt(fp.read()))
## 分析替换后的JAR文件
解密后再用JEB打开文件，发现了程序的真实执行代码
比较简单的异或比对，编写程序并进行解密输出。
## 解题程序
    #include 
    #include 
    #include 
    #include 
    #include "defs.h"
    unsigned int data[9] = {
    0x4A35EBB6, 0x6674F329, 0x4A8AAD73, 0xB5335406, 0x7F668F12, 0x8A966EF7, 0xE7E8807F,
    0xC0F604E0, 0x61630000
    };
    unsigned char ida_chars[] =
    {
    0x07, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x11, 0x00,
    0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
    0x0C, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x16, 0x00,
    0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00,