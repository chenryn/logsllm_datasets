### Table III: Patch Generation by Senx

| **Expression** | **Determinate/Indeterminate** | **Cloned** | **ARA** | **Simple/Complex** | **Patched?** | **Loop Analysis** | **Patch Placement** | **Data Access** | **Failed/Error Handling** |
|---------------|------------------------------|------------|---------|--------------------|--------------|-------------------|---------------------|-----------------|---------------------------|
| B             | Determinate                  | —          | —       | Simple             |             | Loop Analysis     | Patch Placement     | Data Access     | Failed/Error handling      |
| B             | Determinate                  | —          | —       | Simple             |             | Trivial           | Translated          | —               | Failed                    |
| B             | Determinate                  | —          | —       | Simple             |             | Trivial           | Translated          | —               | Trivial                   |
| B             | Determinate                  | —          | —       | Simple             |             | Trivial           | Translated          | —               | Trivial                   |
| B             | Determinate                  | —          | —       | Simple             |             | Trivial           | Translated          | —               | Trivial                   |
| B             | Determinate                  | —          | —       | Simple             |             | Trivial           | Translated          | —               | Trivial                   |
| C             | Determinate                  | Cloned     | ARA     | Complex            |             | Trivial           | Translated          | —               | Trivial                   |
| C             | Determinate                  | Cloned     | ARA     | Complex            |             | Trivial           | Translated          | —               | Trivial                   |
| C             | Determinate                  | Cloned     | ARA     | Complex            |             | Trivial           | Translated          | —               | Trivial                   |
| C             | Determinate                  | Cloned     | ARA     | Complex            |             | Trivial           | Translated          | —               | Trivial                   |
| C             | Determinate                  | Cloned     | ARA     | Complex            |             | Trivial           | Translated          | —               | Trivial                   |
| C             | Determinate                  | Cloned     | ARA     | Complex            |             | Trivial           | Translated          | —               | Trivial                   |
| ... (continues) | ... (continues)              | ... (continues) | ... (continues) | ... (continues)   | ... (continues) | ... (continues)    | ... (continues)     | ... (continues) | ... (continues)           |

### Patch Generation by Senx

#### Case Study: libtiff-CVE-2016-5844
In the `cpContig2SeparateByRow` function, both the buffer range and the access range start at `inbuf`. Senx synthesizes the patch predicate as `spp * imagewidth > scanlinesizein`. The function contains error handling code with a label `bad`. Senx generates the following patch:

```c
if (spp * imagewidth > scanlinesizein)
    goto bad;
```

The official patch also invokes the same error handling but checks for `bps != 8`. Further analysis reveals that both patches are equivalent. However, the human-generated patch relies on the semantics of the libtiff format, while Senx's patch directly checks if the loop cannot exceed the size of the allocated buffer.

#### Case Study: libarchive-CVE-2016-5844
This integer overflow in the ISO parser of libarchive can cause a denial of service via a specially crafted ISO file. The overflow occurs in the `choose_volume` function when it multiplies a block index, which is a 32-bit integer, with a constant number. This can exceed the maximum value representable by a 32-bit integer, causing an overflow into a negative number, which is then used as a file offset.

Senx detects the integer overflow when running libarchive's ISO parser with a crafted ISO file. It generates an expression for the overflowed value as the product of `2048` and `vd->location`. Senx further detects that the overflowed value is assigned to a 64-bit variable `skipsize`, classifying this as a repairable integer overflow. Senx patches the vulnerability by casting the 32-bit value to a 64-bit value before multiplication:

```c
- skipsize = LOGICAL_BLOCK_SIZE * vd->location;
+ skipsize = 2048 * (int64_t)vd->location;
```

The official patch is essentially identical to the one generated by Senx, with the only difference being the use of the constant `LOGICAL_BLOCK_SIZE` instead of its equivalent value `2048` in the multiplication.

### Comparison with Other Work
To evaluate whether Senx addresses the limitations of state-of-the-art APR tools, we compare its effectiveness against SemFix [34] and Angelix [30]. Due to the considerable effort required for each application and vulnerability, we conducted this comparison on two vulnerabilities for the autotrace application. We used all four built-in test inputs for autotrace and 50 randomly generated inputs for each vulnerability.

Both SemFix and Angelix were unable to generate patches, either because they could not locate existing program constructs to pass both positive and negative test inputs or because they could not synthesize a guard statement to prevent the vulnerabilities from being triggered. In contrast, Senx successfully generated working patches for both vulnerabilities.

### Applicability
We evaluated the applicability of loop cloning, access range analysis, and expression translation across a larger dataset. We extracted all loops that access memory buffers and their allocations from 11 programs in GNU Coreutils. Applying Senx’s loop analysis, we found that loop cloning can be applied to 88% of the loops and access range analysis to 46% of the loops. These results align with our findings from the vulnerabilities. For more details, see the Appendix.

### Related Work

#### Automatic Patch Generation
- **Leveraging Fix Patterns**: PAR [20] generates patches using common fix patterns. Unlike PAR, Senx uses a guided approach based on semantic information.
- **LeakFix**: Fixes memory leaks by adding deallocation statements [16].
- **Using Program Mutations**: GenProg [55] uses genetic programming to generate patches, focusing on code executed for negative test cases.
- **Using SMT Solvers**: SemFix [34] and Angelix [30] use constraint solving to find expressions to replace incorrect ones.
- **Learning from Correct Code**: Prophet [27] learns from existing correct patches using a probabilistic model.

#### Mitigating Security Vulnerabilities
- **Fortifying Programs**: Techniques like SFI [18], [31], [52], [57] and CFI [13], [51], [58] prevent vulnerabilities by instrumenting checks or modifying memory regions.
- **Filtering Inputs**: Techniques such as Bouncer [11] and Shields detect and filter out malicious inputs.

While these techniques prevent exploits at the cost of runtime overhead or loss of functionality, Senx generates patches to fix vulnerabilities without such costs.