B
B
B
B
B
B
C
C
C
C
C
C
Expressions
Determinate
Determinate
Determinate
Determinate
Determinate
Determinate
Determinate
Indeterminate
Determinate
Determinate
Determinate
Determinate
Determinate
Determinate
Determinate
Determinate
Determinate
Determinate
Determinate
Determinate
Determinate
Determinate
Determinate
Determinate
Determinate
Determinate
Determinate
Determinate
Determinate
Determinate
Indeterminate
Indeterminate
Determinate
Determinate
Determinate
Determinate
Determinate
Determinate
Determinate
Determinate
Determinate
Determinate
Cloned
—
—
—
—
—
—
—
Cloned
ARA
ARA
—
—
—
—
—
—
—
Cloned
Cloned
Failed
ARA
ARA
Cloned
ARA
Cloned
—
—
—
—
—
—
ARA
ARA
Failed
ARA
—
—
—
—
—
—
—
Simple
Complex
Complex
Complex
Complex
Simple
—
Complex
Simple
Simple
Simple
Simple
Complex
Complex
Complex
Complex
—
Simple
Simple
—
Simple
Complex
Simple
Simple
Simple
Simple
Simple
—
—
—
—
—
—
Simple
Simple
Simple
Complex
Complex
Complex
Complex
Complex
Patched?










































Loop Analysis
Patch Placement
Data Access
Failed/Error handling
Failed
Trivial
Translated
Translated
Translated
Translated
Translated
Trivial
Trivial
—
Trivial
Trivial
Trivial
Trivial
Trivial
Trivial
Trivial
Trivial
Trivial
—
Translated
Translated
Trivial
Translated
Translated
Trivial
Failed
Translated
Failed
—
—
Trivial
Trivial
—
Failed
Trivial
Trivial
Trivial
Trivial
Trivial
Trivial
TABLE III: Patch generation by Senx
Because both the buffer
range and the access range
start at inbuf, Senx synthesizes
the patch predicate
as spp*imagewidth > scanlinesizein. Senx then
ﬁnds that cpContig2SeparateByRow contains error han-
dling code, which has a label bad, and generates the patch as
below. As the buffer allocation and overﬂow occur in the same
function, Senx puts the patch immediately before the buffer
allocation.
i f
( spp * imagewidth > s c a n l i n e s i z e i n )
goto bad ;
The ofﬁcial patch invokes the same error handling and
is placed at the same location as Senx’s patch. However,
the ofﬁcial patch checks that “(bps != 8)”. From further
analysis, we ﬁnd that both patches are equivalent, though the
human-generated patch relies on the semantics of the libtiff
format, while Senx’s patch directly checks that the loop cannot
exceed the size of the allocated buffer.
libarchive-CVE-2016-5844. This integer overﬂow in the ISO
parser in libarchive can result in a denial of service via a
specially crafted ISO ﬁle. The overﬂow happens in function
choose_volume when it multiplies a block index, which is
a 32-bit integer, with a constant number. This can exceed the
maximum value that can be represented by a 32-bit integer
and overﬂow into a negative number, which is then used as a
ﬁle offset.
Senx detects the integer overﬂow when it runs libarchive’s
ISO parser with a crafted ISO ﬁle. It generates an expres-
sion of the overﬂown value as the product of 2048 and
vd→location. Further Senx detects that
the overﬂown
value is assigned to a 64-bit variable skipsize, thus clas-
sifying this as a repairable integer overﬂow. Senx patches the
vulnerability by casting the 32-bit value to a 64-bit value
before multiplying:
− s k i p s i z e = LOGICAL_BLOCK_SIZE * vd−> l o c a t i o n ;
+ s k i p s i z e = 2048 * ( i n t 6 4 _ t ) vd−> l o c a t i o n ;
The ofﬁcial patch is essentially identical to the patch gener-
ated by Senx. The only difference is that the ofﬁcial patch
uses the constant LOGICAL_BLOCK_SIZE rather than its
equivalent value 2048 in the multiplication.
550
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:43:21 UTC from IEEE Xplore.  Restrictions apply. 
D. Comparison with Other Work
To illustrate whether Senx can address the limitations of
state-of-art APR tools, we evaluate the effectiveness of Senx
against SemFix [34] and Angelix [30]. Because SemFix and
Angelix require considerable effort for each application and
vulnerability, we were only able to make this comparison on
2 vulnerabilities for one application, autotrace. We use all four
built-in test inputs for autotrace, and 50 randomly generated
inputs for examples and one vulnerable-triggering input for
each vulnerability.
In both cases Semﬁx and Angelix are unable to generate
a patch either because they are unable to locate an existing
program constructs to change to pass both positive test inputs
and negative test inputs, or they are unable to synthesize
a guard statement to prevent the vulnerabilities from being
triggered. Senx, on the other hand, is able to generate working
patches for both vulnerabilities.
E. Applicability
We evaluate how applicable loop cloning, access range
analysis and expression translation are across a larger dataset.
To generate such a dataset, we extract all loops that access
memory buffers and the allocations of these buffers from the
11 programs in GNU Coreutils, regardless of whether they
contain vulnerabilities or not. We then apply Senx’s loop
analysis to all loops and ﬁnd that loop cloning can be applied
to 88% of the loops and access range analysis can be applied
to 46% of the loops. This is in line with our results from the
vulnerabilities. For the sake of space, we describe the details
of these experiments in the Appendix.
VIII. RELATED WORK
A. Automatic Patch Generation
Leveraging Fix Patterns. By observing common human-
developer generated patches, PAR generates patches using ﬁx
patterns such as altering method parameters, adding a null
checker, calling another method with the same arguments, and
adding an array bound checker [20]. Senx differs from PAR
in two aspects. First, PAR is unable to generate a patch when
the correct variables or methods needed to synthesize a patch
are not accessible at the faulty function or method. Second,
PAR uses a trial-and-error approach that tries out not only
each ﬁxing pattern upon a given bug, but also variables or
methods that are accessible at the faulty function or method
to synthesize a patch. On the contrary, Senx employs a guided
approach that identiﬁes the type of the given bug and chooses
a corresponding patch model to generate the patch for the
bug and systematically ﬁnds the correct variables to synthesize
the patch based on semantic information provided by a patch
model.
LeakFix ﬁxes memory leak bugs by adding a memory
deallocation statement for a leaked memory allocation at the
correct program location [16]. By abstracting a program into
a CFG containing only program statements related to memory
allocation, deallocation, and usage, LeakFix transforms the
problem of ﬁnding a ﬁx for a memory leak into searching for
a CFG edge where a memory deallocation statement can be
added to ﬁx the memory leak without introducing new bugs.
Using Program Mutations. GenProg is a pioneering work
that induces program mutations, i.e. genetic programming,
to generate patches [55]. Leveraging test suites, it focuses
on program code that is executed for negative test cases but
not for positive test cases and utilizes program mutations to
produce modiﬁcations to a program. As a feedback to its
program mutation algorithm, it considers the weighted sum
of the positive test cases and negative test cases that the
modiﬁed program passes. Treating all the results of program
mutations as a search space, its successor improves the scal-
ability by changing to use patches instead of abstract syntax
trees to represent modiﬁcations and exploiting search space
parallelism [23].
Using SMT Solvers. SemFix [34] and Angelix [30] use
constraint solving to ﬁnd the needed expression to replace
incorrect expressions used in a program. By executing a target
program symbolically with both inputs triggering a defect and
inputs not triggering the defect, they identify the constraints
that the target program must satisfy to process both kinds of in-
puts correctly. They then synthesize a patch using component-
based program synthesis, which combines components such as
variables, constants, and arithmetic operations to synthesize a
symbolic expression that can make the target program satisfy
the identiﬁed constraints.
Learning from Correct Code. Prophet learns from exist-
ing correct patches [27]. It uses a parameterized log-linear
probabilistic model on two features extracted from the ab-
stract trees of each patch: 1) the way the patch modiﬁes
the original program and 2) the relationships between how
the values accessed by the patch are used by the original
program and by the patched program. With the probabilistic
model, it ranks candidate patches that it generated for a defect
by the probabilities of their correctness. Finally it uses test
suites to test correctness of the candidate patches. Like other
generate-and-validate automatic patch generation techniques,
its effectiveness depends on the quality of the test suites.
B. Mitigating Security Vulnerabilities
Fortifying Programs. One way to prevent vulnerabilities from
being exploited is by fortifying programs to make them more
robust to malicious inputs. Software Fault Isolation (SFI) in-
struments checks before memory operations to ensure that they
cannot corrupt memory [18], [31], [52], [57]. Control Flow
Integrity (CFI) learns valid control ﬂow transfers of a program
and validates control ﬂow transfers to prevent execution of
exploit code [13], [51], [58]. Alternatively, some techniques
modify the layout or permissions of critical memory regions
to detect or prevent exploits [9], [12], [43], [45], [49], [50].
By contrast, Talos introduces the notion of Security
Workarounds for Rapid Response (SWRR), which steers pro-
gram execution away from a vulnerability to error handling
551
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:43:21 UTC from IEEE Xplore.  Restrictions apply. 
code, and instruments SWRRs to programs to prevent mali-
cious inputs from triggering vulnerabilities [19].
While these techniques prevent exploit of vulnerabilities
at the cost of extra runtime overhead or loss of program
functionality, Senx generates patches to ﬁx vulnerabilities
without imposing such a cost.
Filtering Inputs. Some techniques detect and simply ﬁlter
out malicious inputs [4], [11], [28], [47], [53]. Among them,
Bouncer combines static analysis and symbolic analysis to
infer the constraints to exploit a vulnerability and generates an
input ﬁlter to drop such malicious inputs [11]. Shields models
a vulnerability as a protocol state machine and constructs