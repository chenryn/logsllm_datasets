Annotations in the code [58], [62], or specified by the user through a Domain-Specific Language (DSL) [17], [8] are commonly used to detect API misuse bugs. These bugs represent violations of rules imposed by the specifications of API functions. For instance, IMChecker [24] utilizes a YAML [67] based DSL to define the behavior of API functions and checks for any violations within lightweight static traces computed over the program. Similarly, Semmle [19] identifies API misuses by employing semantic patterns of correct or erroneous behavior, as specified using CodeQL [4], a declarative logic programming language based on Datalog, over a relational representation of programs. MOPS [11] uses a finite automata-based specification, with violations checked via a model checker.

However, creating a formal API specification is challenging, and it is unrealistic to expect developers to write precise specifications (Section II). As a result, numerous API specification inference techniques have been proposed. These methods compute lightweight program traces and use static features such as control-dependencies [45] or various mining techniques, including FRECPO [47], [3], factor graphs [39], [33], semantics-constrained mining [6], and frequent item sets [37] to infer API specifications. These techniques often require a large corpus of programs covering all possible API usages. As demonstrated in Section V, this assumption does not always hold in practice.

Another class of techniques is based on the idea that bugs represent anomalous or deviant behavior [16]. JUXTA [44] identifies common patterns in file system implementations and detects semantic bugs in file systems as violations of these patterns using lightweight symbolic reasoning. Similarly, JIGSAW [61] targets resource access vulnerabilities. APISAN [69] is a generic approach to find API misuse bugs by encoding common patterns as semantic beliefs. However, APISAN fails to capture certain common usage patterns [25] and, as shown in Section V, has a high false positive rate for complex APIs. Machine learning techniques, such as the Apriori algorithm [60], [40], clustering [66], [65], and kNN [7], are also used to identify bugs as anomalous patterns. Similar to specification mining techniques, the success of these bug-finding methods depends on the availability of a large corpus of programs. Other bug pattern learning techniques, such as Vccfinder [48] and Vuldeepecker [36], also require a large bug corpus, making them infeasible for API misuse detection.

Unlike existing approaches, ARBITRAR does not require a specification or a large code corpus with predominantly valid uses. Additionally, our technique is general and can handle APIs of diverse use cases and complexity. We avoid the need for a large code corpus by actively learning from user feedback. Unlike other active learning techniques [68], ARBITRAR learns quickly and provides a responsive interface, even when interacting with the user at a finer level, i.e., program traces.

The use of user feedback for bug detection has been explored in Eugene [42] and Ursa [71], but these systems require a client analysis to be specified in Datalog. Similarly, other user-guided techniques based on Bayesian inference [49], [28] also require a client analysis. In contrast, ARBITRAR does not require any analysis specification.

**IX. CONCLUSION**

We presented ARBITRAR, a user-guided approach for finding API misuses. ARBITRAR interacts with the programmer to classify valid and invalid uses of a target API. It employs a novel active learning algorithm to minimize user burden. We demonstrated the effectiveness of ARBITRAR by using it to find new bugs in a rich set of target APIs in large real-world C/C++ programs within a few rounds of user interaction.

**ACKNOWLEDGMENTS**

We would like to thank our shepherd Nick Nikiforakis and anonymous reviewers for their valuable comments and inputs to improve our paper. We also thank Anthony Canino and Kihong Heo for contributing to the initial implementation of ARBITRARâ€™s symbolic execution engine. This research was supported by grants from AFRL (#FA8750-20-2-0501), ONR (#N00014-18-1-2021), and NSF (#1836822).

Authorized licensed use limited to: Tsinghua University. Downloaded on February 25, 2022, at 12:25:07 UTC from IEEE Xplore. Restrictions apply.

**REFERENCES**

[References listed as provided, with no changes needed.]