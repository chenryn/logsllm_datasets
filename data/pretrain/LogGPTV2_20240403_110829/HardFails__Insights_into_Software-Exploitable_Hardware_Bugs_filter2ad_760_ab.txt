tinguishable in the RTL, or should not be measurable from
the software. However, current industry-standard security ver-
iﬁcation techniques focus exclusively on the functional in-
formation ﬂow of the logic and fail to model the associated
timing ﬂow. The complexity of timing-related security issues
is aggravated when the timing ﬂow along a logic path spans
multiple modules and involves various inter-dependencies.
L-3: Cache-state gap. State-of-the-art veriﬁcation tech-
niques only model and analyze the architectural state of a
processor by exclusively focusing on the state of registers.
However, they do not support analysis of non-register states,
such as caches, thus completely discarding modern proces-
sors’ highly complex microarchitecture and diverse hierarchy
of caches. This can lead to severe security vulnerabilities aris-
ing due to state changes that are unaccounted for, e.g., the
changing state of shared cache resources across multiple privi-
lege levels. Caches represent a state that is inﬂuenced directly
or indirectly by many control-path signals and can generate
security vulnerabilities in their interactions, such as illegal
information leakages across different privilege levels. Identi-
fying RTL bugs that trigger such vulnerabilities is beyond the
capabilities of existing techniques.
L-4: Hardware-software interactions. Some RTL bugs re-
main indiscernible to hardware security veriﬁcation tech-
niques because they are not explicitly vulnerable unless trig-
gered by the software. For instance, although many SoC ac-
cess control policies are directly implemented in hardware,
some are programmable by the overlying ﬁrmware to allow
for post-silicon ﬂexibility. Hence, reasoning on whether an
RTL bug exists is inconclusive when considering the hardware
RTL in isolation. These vulnerabilities would only materialize
when the hardware-software interactions are considered, and
existing techniques do not handle such interactions.
3.2 Constructing Real-World RTL Bugs
To systematically assess the state of the art in hardware se-
curity veriﬁcation with respect to the limitations described
above, we construct a test harness by implementing a large
number of RTL bugs in RISC-V SoC designs (cf. Table 1).
To the best of our knowledge, we are the ﬁrst to compile and
showcase such a collection of hardware bugs. Together with
our co-authors at Intel, we base our selection and construc-
tion of bugs on a solid representative spectrum of real-world
CVEs [47, 48, 49, 51, 52, 53] as shown in Table 1. For in-
stance, bug #22 was inspired by a recent security vulnerability
in the Boot ROM of video gaming mobile processors [56],
which allowed an attacker to bring the device into BootROM
Recovery Mode (RCM) via USB access. This buffer over-
ﬂow vulnerability affected many millions of devices and is
popularly used to hack a popular video gaming console1.
We extensively researched CVEs that are based on
software-exploitable hardware and ﬁrmware bugs and clas-
siﬁed them into different categories depending on the weak-
nesses they represent and the modules they impact. We repro-
duced them by constructing representative bugs in the RTL
and demonstrated their software exploitability and severity
by crafting a real-world software exploit based on one of
these bugs in Appendix D. Other bugs were constructed with
our collaborating hardware security professionals, inspired
by bugs that they have previously encountered and patched
during the pre-silicon phase, which thus never escalated into
CVEs. The chosen bugs were implemented to achieve cover-
age of different security-relevant modules of the SoC.
Since industry-standard processors are based on proprietary
RTL implementations, we mimic the CVEs by reproducing
and injecting them into the RTL of widely-used RISC-V SoCs.
We also investigate more complex microarchitecture features
of another RISC-V SoC and discover vulnerabilities already
existing in its RTL (Section 4). These RTL bugs manifest as:
1https://github.com/Cease-and-DeSwitch/fusee-launcher
216    28th USENIX Security Symposium
USENIX Association
• Incorrect assignment bugs due to variables, registers,
and parameters being assigned incorrect literal values,
incorrectly connected or left ﬂoating unintended.
• Timing bugs resulting from timing ﬂow issues and in-
correct behavior relevant to clock signaling such as in-
formation leakage.
• Incorrect case statement bugs in the ﬁnite state ma-
chine (FSM) models such as incorrect or incomplete
selection criteria, or incorrect behavior within a case.
• Incorrect if-else conditional bugs due to incorrect
boolean conditions or incorrect behavior described
within either branch.
• Speciﬁcation bugs due to a mismatch between a spec-
iﬁed property and its actual implementation or poorly
speciﬁed / under-speciﬁed behavior.
These seemingly minor RTL coding errors may constitute
security vulnerabilities, some of which are very difﬁcult to
detect during veriﬁcation. This is because of their intercon-
nection and interaction with the surrounding logic that affects
the complexity of the subtle side effects they generate in their
manifestation. Some of these RTL bugs may be patched by
modifying parts of the software stack that use the hardware
(e.g., using ﬁrmware/microcode updates) to circumvent them
and mitigate speciﬁc exploits. However, since RTL is usually
compiled into hardwired integrated circuitry logic, the under-
lying bugs cannot, in principle, be patched after production.
The limited capabilities of current detection approaches in
modeling hardware designs and formulating and capturing rel-
evant security assertions raise challenges for detecting some
of these vulnerabilities, which we investigate in depth in this
work. We describe next the adversary model we assume for
our vulnerabilities and our investigation.
3.3 Adversary Model
In our work, we investigate microarchitectural details at the
RTL level. However, all hardware vendors keep their propri-
etary industry designs and implementations closed. Hence,
we use an open-source SoC based on the popular open-source
RISC-V [73] architecture as our platform. RISC-V supports
a wide range of possible conﬁgurations with many standard
features that are also available in modern processor designs,
such as privilege level separation, virtual memory, and multi-
threading, as well as optimization features such as conﬁg-
urable branch prediction and out-of-order execution.
RISC-V RTL is freely available and open to inspection
and modiﬁcation. While this is not necessarily the case for
industry-leading chip designs, an adversary might be able
to reverse engineer or disclose/steal parts of the chip using
existing tools23. Hence, we consider a strong adversary that
can also inspect the RTL code.
In particular, we make the following assumptions:
2https://www.chipworks.com/
3http://www.degate.org/
• Hardware Vulnerability: The attacker has knowledge of
a vulnerability in the hardware design of the SoC (i.e., at
the RTL level) and can trigger the bug from software.
• User Access: The attacker has complete control over a user-
space process, and thus can issue unprivileged instructions
and system calls in the basic RISC-V architecture.
• Secure Software: Software vulnerabilities and resulting
attacks, such as code-reuse [65] and data-only attacks [27]
against the software stack, are orthogonal to the problem
of cross-layer bugs. Thus, we assume all platform software
is protected by defenses such as control-ﬂow integrity [1]
and data-ﬂow integrity [13], or is formally veriﬁed.
The goal of an adversary is to leverage the vulnerability
on the chip to provoke unintended functionality, e.g., access
to protected memory locations, code execution with elevated
privileges, breaking the isolation of other processes running
on the platform, or permanently denying services. RTL bugs
in certain hardware modules might only be exploitable with
physical access to the victim device, for instance, bugs in de-
bug interfaces. However, other bugs are software-exploitable,
and thus have a higher impact in practice. Hence, we focus on
software-exploitable RTL vulnerabilities, such as the exploit
showcased in Appendix D. Persistent denial of service (PDoS)
attacks that require exclusive physical access are out of scope.
JTAG attacks, though they require physical access, are still in
scope as the end user may be the attacker and might attempt to
unlock the device to steal manufacturer secrets. Furthermore,
exploiting the JTAG interface often requires a combination of
both physical access and privilege escalation by means of a
software exploit to enable the JTAG interface. We also note
that an adversary with unprivileged access is a realistic model
for real-world SoCs: Many platforms provide services to other
devices over the local network or even over the internet. Thus,
the attacker can obtain some limited software access to the
platform already, e.g., through a webserver or an RPC inter-
face. Furthermore, we emphasize that this work focuses only
on tools and techniques used to detect bugs before tape-out.
4 HardFails: Hardware Security Bugs
In light of the limitations of state-of-the-art veriﬁcation tools
(Section 3.1), we constructed a testbed of real-world RTL
bugs (Section 3.2) and conducted two extensive case stud-
ies on their detection (described next in Sections 5 and 6).
Based on our ﬁndings, we have identiﬁed particular classes of
hardware bugs that exhibit properties that render them more
challenging to detect with state-of-the-art techniques. We call
these HardFails. We now describe different types of these
HardFails encountered during our analysis of two RISC-V
SoCs, Ariane [59] and PULPissimo [61]. In Section 5.3, we
describe the actual bugs we instantiated for our case studies.
Ariane is a 6-stage in-order RISC-V CPU that implements
the RISC-V draft privilege speciﬁcation and can run Linux
OS. It has a memory management unit (MMU) consisting of
USENIX Association
28th USENIX Security Symposium    217
TABLE 1: Detection results for bugs in PULPissimo SoC based on formal veriﬁcation (SPV and FPV, i.e., JasperGold Security
Path Veriﬁcation and Formal Property Veriﬁcation) and our hardware security competition (M&S, i.e., manual inspection and
simulation). Check and cross marks indicate detected and undetected bugs, respectively. Bugs marked inserted were injected
by our team and based on the listed CVEs, while bugs marked native were already present in the SoC and discovered by the
participants during Hack@DAC. LOC denotes the number of lines of code, and states denotes the total number of logic states
for the modules needed to attempt to detect this bug.
SPV FPV M&S Modules



#
1
2
3
4
5
6
7
8
9
Bug
Address range overlap between peripherals SPI Master and SoC
Addresses for L2 memory is out of the speciﬁed range.
Processor assigns privilege level of execution incorrectly from CSR.
Register that controls GPIO lock can be written to with software.
Reset clears the GPIO lock control register.
Incorrect address range for APB allows memory aliasing.
AXI address decoder ignores errors.
Address range overlap between GPIO, SPI, and SoC control peripherals.
Incorrect password checking logic in debug unit.
10 Advanced debug unit only checks 31 of the 32 bits of the password.
11 Able to access debug register when in halt mode.
12
13
14
15
Password check for the debug unit does not reset after successful check.
Faulty decoder state machine logic in RISC-V core results in a hang.
Incomplete case statement in ALU can cause unpredictable behavior.
Faulty logic in the RTC causing inaccurate time calculation for security-critical ﬂows, e.g., DRM.
16 Reset for the advanced debug unit not operational.
17 Memory-mapped register ﬁle allows code injection.
18 Non-functioning cryptography module causes DOS.
19
Insecure hash function in the cryptography module.
20 Cryptographic key for AES stored in unprotected memory.
21 Temperature sensor is muxed with the cryptography modules.
22 ROM size is too small preventing execution of security code.
23 Disabled the ability to activate the security-enhanced core.
24 GPIO enable always high.
25 Unprivileged user-space code can write to the privileged CSR.
26 Advanced debug unit password is hard-coded and set on reset.
27
28
Secure mode is not required to write to interrupt registers.
JTAG interface is not password protected.
29 Output of MAC is not erased on reset.
30
Supervisor mode signal of a core is ﬂoating preventing the use of SMAP.
31 GPIO is able to read/write to instruction and data cache.
Type
Inserted (CVE-2018-12206 /
CVE-2019-6260 / CVE-2018-8933)
Native
Native
Inserted (CVE-2017-18293)
Inserted (CVE-2017-18293)
Inserted (CVE-2018-12206 /
CVE-2019-6260)
Inserted (CVE-2018-4850)
Inserted (CVE-2018-12206 /
(CVE-2017-5704)
Inserted (CVE-2018-8870)
Inserted (CVE-2017-18347 /
CVE-2017-7564)
Native (CVE-2017-18347 /
Inserted (CVE-2017-7564)
Native
Native
Native
Inserted (CVE-2017-18347)
Native
Inserted
Inserted (CVE-2018-1751)
Inserted (CVE-2018-8933 /
CVE-2014-0881 / CVE-2017-5704)
Inserted
Inserted (CVE-2018-6242 / )
CVE-2018-15383)
Inserted (CVE-2018-12206)
Inserted (CVE-2018-1959)
Inserted (CVE-2018-7522 /
CVE-2017-0352)
Inserted (CVE-2018-8870)
Inserted (CVE-2017-0352)
Native
Inserted
Native
Native






























































