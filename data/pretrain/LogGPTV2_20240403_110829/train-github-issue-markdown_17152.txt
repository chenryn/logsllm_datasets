Sometimes it is needed to parse several variants of item from single page,
where only a couple of fields differ. Obvious way to do this is to create base
item with all common fields collected and then create new items (for example
in a loop) using new ItemLoader instance with base item passed to it.
The problem I'm facing now is that ItemLoader.load_item() modifies base item -
which is counterintuitive and can result in weird behavior (for example if
variant items can have different fields - after those field were added to base
item - they would appear in all loaded items).
    In [5]: item = Item()
    In [7]: item['url'] = 'foo'
    In [8]: item
    Out[8]: {'url': 'foo'}
    In [9]: l = ItemLoader(item)
    In [12]: l.add_value('category', 'bar')
    In [13]: item
    Out[13]: {'url': 'foo'}
    In [14]: item_copy = l.load_item()
    In [15]: item_copy
    Out[15]: {'category': 'bar', 'url': 'foo'}
    In [16]: item
    Out[16]: {'category': 'bar', 'url': 'foo'}
    In [17]: id(item)
    Out[17]: 49468304
    In [18]: id(item_copy)
    Out[18]: 49468304
Now I'm using workaround like this to suppress such behavior:
    loader = ItemLoader(selector=sel)
    ...
    item = loader.load_item()
    for variant in variants:
        item_copy = item.copy()
        loader = ItemLoader(item_copy)
        ...
        yield loader.load_item()
What do you think about using item copy inside ItemLoader by default?