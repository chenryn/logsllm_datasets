### 2.2 Architecture Overview

Our approach consists of six main steps, as illustrated in Figure 2: malware execution, traffic clustering, signature generation, signature merging, signature clustering, and signature finalization.

#### Malware Execution
Malware execution (Section 3) involves running a malware binary in a contained virtual machine (VM) environment. The process captures the network traffic generated during the run. This step may be repeated multiple times for the same malware binary, using different VMs, varying durations, and different containment policies to ensure comprehensive coverage.

#### Traffic Clustering
Traffic clustering (Section 4) groups similar network traffic from the captured traces, regardless of the specific run or malware binary that produced it. This step is designed to be computationally efficient, deferring more complex operations like tokenization to later stages. It uses protocol-aware features for known C&C protocols and packet-level features for other traffic.

#### Signature Generation
Signature generation (Section 5.1) creates an initial set of signatures for each traffic cluster. For each field in the messages within a cluster, it tokenizes the field contents, identifying distinctive tokens that appear in a significant number of messages. Each traffic cluster results in one or more signature clusters, depending on the presence of unique tokens.

#### Signature Merging
Signature merging (Section 5.2) identifies and combines signatures across different clusters that share common tokens in their data fields. This step helps in consolidating signatures that are likely to belong to the same family.

#### Signature Clustering
Signature clustering (Section 5.3) merges signature clusters generated from traffic produced by the same malware binary or sent to the same endpoint. This step reduces the number of signature clusters and ensures that signatures from the same malware family are grouped together.

#### Signature Finalization
Signature finalization (Section 5.4) encodes the signatures in the format expected by the Intrusion Detection System (IDS) and removes signatures that generate false positives or have minimal coverage. Optionally, the set of signatures for each family cluster can be minimized. Finally, FIRMA outputs the clusters, signatures, and endpoints files.

### 3. Malware Execution

Executing malware in a controlled environment is a well-studied problem [11, 17, 21, 31, 36]. The primary goals are to induce the malware to produce network traffic, collect a diverse range of traffic, and prevent contamination. To achieve this, the same binary may be run multiple times with different configurations. If a binary fails to produce traffic in the default configuration, it is re-run on a different VM (e.g., QEMU instead of VMware) and for a longer duration. Common user actions, such as moving the mouse or opening a browser, are also simulated to trigger network activity. Additionally, successful binaries are re-run when capacity allows to account for non-deterministic behavior and to remove artifacts like local IP addresses.

#### Containment Policies
Malware binaries can be run under three containment policies:
- **Default Sink Policy**: Sinks all outgoing traffic except DNS and HTTP requests to top Alexa sites, which are proxied. This policy ensures that even if the remote endpoint is down, the initial request can still be captured and a signature can be built.
- **Endpoint Failure Policy**: Aborts any outgoing communication by sending error responses to DNS requests, resetting SYN packets, and sinking UDP traffic. This policy tricks the malware into revealing all known endpoints.
- **Restricted Access Policy**: Allows limited internet access, enabling deeper C&C dialogs. Connections with payloads larger than 4 KB are blocked to prevent remote installations.

The output of a malware execution includes a network trace annotated with a unique run identifier and a database entry detailing the run configuration, such as the malware binary, VM software, execution duration, containment policy, and result.

### 4. Traffic Clustering

Traffic clustering takes the network traces from malware executions and groups similar traffic together. The goal is to distinguish different network behaviors so that separate signatures can be created for each. This step may produce multiple traffic clusters for the same behavior, which will be merged during subsequent steps.

#### 4.1 Feature Extraction
For each request, FIRMA extracts the following feature vector:
- `f_id`: Unique identifier for the malware binary.
- `r_id`: Unique identifier for the malware execution.
- `proto`: Protocol used (HTTP, IRC, SMTP, TCP, UDP).
- `msg`: Message type (e.g., Method in HTTP, Command in IRC/SMTP).
- `sport`, `dport`: Source and destination ports.
- `sip`, `dip`: Source and destination IP addresses.
- `dsize`: Data size in bytes.
- `endpoint`: Domain name or IP address of the destination.
- `ptree`: Hierarchical field structure of the message.

The `proto` feature is determined using protocol signatures, which capture keywords in the early parts of a message. Wireshark is used to parse the messages and extract the `ptree` feature. Requests to benign domains (top 200,000 Alexa domains) are discarded to avoid false positives.

#### 4.2 Application Protocol Clustering
For HTTP, IRC, and SMTP, FIRMA uses the following features to group similar messages:
- **HTTP**: Groups requests with the same message type and either the same URL path, similar URL parameters (Jaccard index > 0.4), or similar header values (excluding Content-Length and Host headers).
- **IRC**: Groups messages with the same command and list of command parameters, excluding those found in benign traffic.
- **SMTP**: Groups EHLO and HELO messages with the same command and parameter value, excluding those found in benign traffic.

#### 4.3 Transport Protocol Clustering
For other traffic, FIRMA groups packets based on transport features, such as the same size, destination port, and endpoint, or the same size with an unidentified protocol. Endpoint information is added at this stage to differentiate between different binary protocols.

### 5. Signatures

This section describes the process of generating, merging, clustering, and finalizing signatures.

#### 5.1 Signature Generation
For each traffic cluster, FIRMA generates an initial set of signatures by tokenizing the field contents and identifying distinctive tokens. Each traffic cluster results in one or more signature clusters.

#### 5.2 Signature Merging
Signatures with similar payload tokens are identified and merged to consolidate signatures that are likely to belong to the same family.

#### 5.3 Signature Clustering
Signature clusters generated from traffic produced by the same malware binary or sent to the same endpoint are merged. This step produces a smaller set of family clusters without modifying the signatures.

#### 5.4 Signature Finalization
Signatures are encoded in the format expected by the IDS, and those that generate false positives or have minimal coverage are removed. The set of signatures for each family cluster can be optionally minimized. FIRMA then outputs the clusters, signatures, and endpoints files.