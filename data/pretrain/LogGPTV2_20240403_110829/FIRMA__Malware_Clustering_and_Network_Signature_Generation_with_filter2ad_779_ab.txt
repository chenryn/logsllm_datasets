the same family, collected nearby in time, reusing endpoints even if their payloads are
polymorphic. Payload signatures are typically longer-lived than endpoints, especially
for binary C&C protocols [6]. However, eventually the C&C protocol may change or
be replaced with another protocol, so they also need updating.
    Network Traces Malware Binaries Signature Generation Signature Merging Signature Clustering Malware Execution VM 1 VM 1 Traffic Clusters Signature Finalization    Encoding Validation Minimization Request Clustering  Feature Extraction  Protocol Detection  Family Clusters Traffic Clustering      Tokens  Fields  Values    Signatures  File-Ids End-Points  Sig. Clusters Sig. Clusters Benign Traffic Suricata  Sig. 1 Sig. 2 Sig. 3 Sig. 4 Sig. n Sig. Sig. 2 Sig. 1 Signature File Clusters File Endpoints File  Blacklists 6
2.2 Architecture Overview
Our approach comprises 6 steps illustrated in Figure 2: malware execution, trafﬁc clus-
tering, signature generation, signature merging, signature clustering, and signature ﬁ-
nalization. Malware execution (Section 3) runs a malware binary on a VM in a con-
tained environment and outputs a network trace capturing the trafﬁc generated during
the run. This step may happen multiple times for a malware binary, e.g., on different
VMs, for different amounts of time, and with different containment policies.
The network traces are the input to FIRMA. First, trafﬁc clustering (Section 4)
groups similar trafﬁc, regardless of which run it comes from and which malware bi-
nary produced it. Trafﬁc clustering operates on all trafﬁc in the network traces so it
is designed to be cheap; expensive operations (e.g., tokenization) are left for later. It
uses protocol-aware features for C&C protocols built on top of standard application
protocols and packet-level features for the remaining trafﬁc.
Next, signature generation (Section 5.1) produces an initial set of signatures for each
trafﬁc cluster. For each ﬁeld in the messages in the cluster (or full packets if the protocol
is unknown) it tokenizes the ﬁeld contents, identifying distinctive tokens that cover a
signiﬁcant number of messages in the cluster. It outputs a signature cluster for each
trafﬁc cluster, containing one or more signatures, e.g., if there are distinctive tokens that
do not appear in all cluster messages.
Signature merging (Section 5.2) identiﬁes signatures across clusters that share to-
kens in their data ﬁelds and merges those signatures and their corresponding clusters.
Then, signature clustering (Section 5.3) merges signature clusters generated from trafﬁc
produced by the same malware binary, or containing trafﬁc sent to the same endpoint, as
these indicate that the clusters belong to the same family. This step produces a smaller
set of family clusters but does not modify the signatures.
Signature ﬁnalization (Section 5.4) encodes the signatures in the syntax expected
by the IDS and removes signatures that create false positives or have little coverage.
Optionally, the set of signatures for each family cluster is minimized. Finally, FIRMA
outputs the clusters, signatures, and endpoints ﬁles.
3 Malware Execution
Executing malware in a contained environment is a widely studied problem [11, 17, 21,
31, 36] and not a contribution of this work. The main goals of malware execution are
to incite the malware to produce trafﬁc, to collect a variety of trafﬁc, and to prevent
contamination. Inciting the malware to produce network trafﬁc often requires running
the same binary multiple times with different conﬁgurations. In our environment if a
binary fails to produce trafﬁc in the default conﬁguration, it is queued to be rerun on
a different VM (e.g., on QEMU if originally run on VMWare) and for an extended
period of time (e.g., doubling the execution timer). In addition, all executions replicate
some common user actions such as moving the mouse or opening the browser. Malware
binaries that do produce network trafﬁc are also rerun when capacity is available to
help the signature generation account for non-determinism in the network trafﬁc and to
remove artifacts of the environment such as local IP addresses.
7
Fig. 3. Message ﬁeld tree examples.
Malware binaries may be run with 3 containment policies, designed for different
purposes. The default sink containment policy sinks all outgoing trafﬁc, except DNS
requests and HTTP requests to the top Alexa sites, which are proxied. If the proxy
receives no external response it sends a predeﬁned successful response to the malware.
The sink policy enables capturing the request sent by the malware even if the remote
endpoint is down, so that a signature can still be built for this initial request. The sink
policy also avoids remote installations where a malware binary downloads and executes
additional components, or malware from other families if involved in the pay-per-install
business model [5]. Such remote installations can contaminate the network trace with
trafﬁc from different malware families.
The endpoint failure policy aborts any outgoing communication from the malware
by sending error responses to DNS requests, resets to SYN packets, and sinking outgo-
ing UDP trafﬁc. This policy is designed to trick the malware into revealing all endpoints
it knows, as it tries to ﬁnd a working endpoint. The restricted access policy allows the
malware limited connection to the Internet, enabling deeper C&C dialogs. To prevent
remote installations any connection with a payload larger than 4 KB (the minimum size
of a working malware we have observed) is blocked.
The output of a malware execution is a network trace annotated with a unique run
identiﬁer, and a database entry stating the conﬁguration for the run such as the malware
binary executed, VM software, execution duration, containment policy, and result.
4 Trafﬁc Clustering
Trafﬁc clustering takes as input the network traces from the malware executions and
groups together similar trafﬁc. Its goal is to distinguish trafﬁc that corresponds to dif-
ferent network behaviors so that separate signatures can be later built for each. It may
produce multiple trafﬁc clusters for the same behavior, which will be later merged dur-
ing signature merging and clustering. Trafﬁc clustering ﬁrst extracts a feature vector for
each request (Section 4.1). Then, it computes a partition of the feature vectors into traf-
ﬁc clusters. For HTTP, IRC, and SMTP messages it applies a protocol-aware clustering
that uses different features for each protocol (Section 4.2). For other trafﬁc, it applies a
generic clustering based on transport level information (Section 4.3).
POST /static.html HTTP/1.1\r\nAccept-Encoding: gzip,deflate\r\nHost: sousuoku.com\r\n\r\nHTTP POST[0:80]Request-Line[0:25]CRLF[26:27]Accept-Encoding header [28:56]CRLF[57:58]Headers[28:78]CRLF[79:80]Host header[59:76]CRLF[77:78]Method[0:3]URI[5:16]Version[18:25]Name[28:42]Value[45:56]Name[59:62]Value[65:76]SP[17:17]SP[4:4]CS[43:44]CS[63:64]d7b6f5df28948dabc9c0d199ffb9736cUDP PKT[0:15]Data[0:15]EHLO localhost\r\n123SMTP EHLO[0:15]Request-Command[0:13]CRLF[14:15]Parameter[5:13]SP[4:4]Name[0:3]8
4.1 Feature Extraction
For each request sent by a malware binary FIRMA extracts the following feature vector:
(cid:104)f id, rid, proto, msg, sport, dport, sip, dip, dsize, endpoint, ptree(cid:105)
where f id and rid are unique identiﬁers for the malware binary and malware execution
respectively, proto and msg capture the protocol and message type, sport, dport, sip,
dip are the ports and IP addresses, dsize is the size in bytes, and endpoint is the domain
name used to resolve the destination IP (dip), or the destination IP if the malware did
not use DNS. The ptree feature uniquely identiﬁes the message ﬁeld tree output by
Wireshark4 when parsing the request.
The protocol feature (proto) can have 5 values: HTTP, IRC, SMTP, TCP, and UDP.
To identify HTTP, IRC, and SMTP trafﬁc FIRMA uses protocol signatures, which cap-
ture protocol keywords present in the early parts of a message (e.g., GET in HTTP or
EHLO in SMTP) [10, 15]. Protocol signatures are applied to all TCP connections re-
gardless of the ports used and matching trafﬁc is parsed into messages and ﬁelds using
the appropriate Wireshark dissector. Note that Wireshark uses the destination port to
select the right protocol parser. If FIRMA did not use protocol signatures, Wireshark
would not parse standard protocols on non-standard ports and it would try to parse pro-
prietary protocols on standard ports. Both situations are common with malware. For
packets not from these 3 protocols, the protocol feature is the transport protocol.
The message feature (msg) is the value of the type ﬁeld for messages from applica-
tion protocols (i.e., Method ﬁeld in HTTP and Command ﬁeld in IRC and SMTP) and
null for TCP and UDP packets. The message ﬁeld tree feature (ptree) captures the hi-
erarchical ﬁeld structure of a message. Figure 3 shows the trees for 3 different requests:
an HTTP POST message, a SMTP EHLO message, and a UDP packet with a single
data ﬁeld because its structure is unknown. The advantage of using Wireshark is that
it has dissectors for many protocols, so supporting other application protocols requires
only new protocol signatures.
As an optimization, HTTP requests where endpoint is one of the top 200,000 Alexa
domains are discarded. Requests to benign domains are often used by malware to check
connectivity and signatures derived from them would be discarded later as causing false
positives, so avoiding their construction is more efﬁcient.
4.2 Application Protocol Clustering
To group similar HTTP, IRC, and SMTP messages into trafﬁc clusters, FIRMA uses the
following set of features for each protocol.
HTTP. FIRMA groups HTTP requests that have the same message type and satisfy one
of these conditions:
– Same URL path. The path component of the URL is the same in both requests and
not empty (i.e., not the root page).
– Similar URL parameters. The Jaccard index of the sets of URL parameters (with-
out values) is larger than an experimentally selected threshold of 0.4.
4 http://www.wireshark.org/
9
– Similar header value. The value of any of the HTTP headers, except the Content-
Length and Host headers, is the same in both requests and that value does not ap-
pear in the pool of benign HTTP trafﬁc, the User-Agent whitelist or the whitelist of
protocol keywords. We exclude the Content-Length because the content of POST
requests often has variable length and the Host header because endpoint informa-
tion is used later in the signature merging step (Section 5.2).
Compared to prior work that clusters HTTP requests [26] our HTTP clustering does
not exclusively rely on URL information, but also leverages the HTTP headers. This is
important because a number of malware families build custom HTTP requests, which
may include distinctive values. For example, the third signature in Figure 1 has a User-
Agent header that impersonates the Opera browser. However, the VMs where the mal-
ware executes do not have this browser installed and more importantly the real Opera
browser includes a minor version in its User-Agent strings. Note that at this step the
body of HTTP POST requests is not compared. For efﬁciency and accuracy these are
tokenized and compared during the signature generation and merging steps (Section 5).
IRC. An IRC message comprises an optional preﬁx, a command, and a list of command
parameters. FIRMA groups together messages if they have the same command and the
same list of command parameters and the list of command parameters does not appear
in the benign trafﬁc pool.
SMTP. An SMTP message comprises a command and a parameter. The SMTP cluster-
ing focuses on commands speciﬁc to the SMTP engine, rather than to the email mes-
sages sent. Currently, it only considers EHLO and HELO messages. FIRMA groups
together messages with the same command and parameter value, where the parameter
value does not appear in the benign trafﬁc pool.
4.3 Transport Protocol Clustering
For the remaining requests the trafﬁc clustering uses transport features and, similar
to HTTP POST requests, the payload comparison is left for the signature generation
and merging steps. In particular, it groups packets from the same transport protocol
satisfying one of these conditions: same size and sent to the same destination port and
endpoint, or same size and Wireshark does not identify their protocol. This differs from
application protocols in that the endpoint information is added at this stage because it
is unlikely that a malware family will use multiple binary protocols with messages of
the same size.
The output of the trafﬁc clustering is the union of the trafﬁc clusters output by the
3 protocol-aware clusterings and the transport protocol clustering. Each trafﬁc cluster
contains the feature vectors for the requests in the cluster and the clusters do not overlap.
5 Signatures
This section describes the process of generating an initial set of signatures for each traf-
ﬁc cluster (Section 5.1), merging signatures with similar payload tokens (Section 5.2),
clustering signatures by endpoints and ﬁle identiﬁers (Section 5.3), and ﬁnalizing the
signatures (Section 5.4).
10
Algorithm 1 Signature Generation Algorithm
def g e n e r a t e s i g n a t u r e s ( traf f ic cluster ) {
s i g n a t u r e s = [ ]
f u l l c o v t o k e n s = [ ]
# Get u n i q u e
u n i q u e f i e l d s = g e t d i s t i n c t
f o r f ield in unique f ields
f i e l d s
f o r
f o r
# Get u n i q u e v a l u e s
f i e l d
u n i q u e v a l u e s = g e t d i s t i n c t
# T o k e n i z e u n i q u e
t o k e n s = g e t
f o r token in t o k e n s
f i e l d v a l u e s
t o k e n s ( u n i q u e v a l u e s )
r e q u e s t s
i n c l u s t e r
f i e l d s ( traf f ic cluster )
f i e l d s v a l u e s ( f ield )
f a l s e p o s i t i v e s and c o v e r a g e f o r
# Get
[ tf p , tcov ] = g e t c o v f p ( token )
# Get
token request set = g e t
# I g n o r e t o k e n s w i t h h i g h f a l s e p o s i t i v e or
i f tf p > thresf p or tcov < threscov
c o n t a i n t h e t o k e n
r e q u e s t s
t h a t
t o k e n
t o k e n r e q u e s t s ( token )
s m a l l c o v e r a g e
continue
# Accumulate t o k e n s w i t h f u l l
i f tcov == 1 . 0
f u l l c o v t o k e n s . append ( token )