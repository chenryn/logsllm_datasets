# 剔除文件名字符串出现的"[" "]",并用"，"做分隔转换为列表            files = files.strip("[]").split(",")            
# 对每个文件进行处理            for filename in files:                
# 将文件移动到新的目录                move_to_newdir(filename, filepath, type_to_classify)在这段代码中，我实现了从队列取出文件名称和目录，并根据分类将文件移动到新的目录。由于消费者的逻辑是从队列读取内容和移动文件两个功能组成的，所以我把消费者拆分成了两个函数进行编写：1.       classify_from_q()    函数，用来实现从队列读取文件列表，并遍历列表，得到每一个文件名称；        2.       move_to_newdir()    函数，把文件名称、路径、分类规则作为参数，真正实现移动。        相应的，如果你在编写包含多个功能的程序时，也要尽量保持每个功能的独立性，把每一个功能尽量放在一个函数中，这样能有效提升你的代码的可读性。这两个函数虽然比较长，但是大部分都是我们学过的内容，我想为你重点讲解一下第一次接触到的两个知识点，一个是in 操作，一个是利用 shutil 库的 move()函数实现的重命名。in操作叫做成员操作符，它能支持目前我们学习过的所有基础数据类型，用来判断一个值是否是列表、元组、字典等基础数据类型中的一员。如果这个值是基础类型的成员之一就会直接返回True，如果不是成员之一返回的就是 False。有了 in操作符，你就不用手动遍历基础数据类型，再使用"=="逐个去判断某个值和数据类型中的成员是否相等了。我举个例子，你会更容易理解。我在代码中使用了这样一行代码："if ext intype_to_newpath\[new_path\]" ：1.  "ext"    就是文件的扩展名，就像是"a.mp3"的扩展名是"mp3"；        2.  "type_to_newpath\[new_path\]"是字典"type_to_newpath"中，以"new_path"作为    key 的值，就像是"type_to_newpath = { \"music\": (\"mp3\", \"wav\")    }"的"(\"mp3\", \"wav\")"。        ```{=html}```    "mp3" in ("mp3", "wav")如果扩展名在元组中，那么 if 条件的返回结果就是True，就可以进行文件的移动了，如果结果是 False 则从字典中继续取下一个key，直到所有的 key遍历完成之后，仍然没有匹配的扩展名，就把文件保持在原地，不做任何移动操作。还有一个我们第一次接触到的函数是 shutil 库的 move()函数，这个函数是直接对系统上的文件进行操作的，所以你需要注意移动以后的文件名不要和已有的文件名冲突，这样会导致重名覆盖已有的文件，从而丢失文件。因此在你没有十足的把握之前，建议你在移动前增加一个判断功能，判断移动的文件是否存在，如果存在则提示使用脚本的人此情况，或移动前将文件进行改名。以上就是如何对混在一起的多个扩展名的文件，进行自动分类的完整过程。这节课的完整代码比较长，我一并贴在了下方，帮你理解多个函数之间的调用关系和执行顺序。    import os    import shutil    from queue import Queue    
# 建立新的目录    def make_new_dir(dir, type_dir):        for td in type_dir:            new_td = os.path.join(dir, td)            if not os.path.isdir(new_td):                os.makedirs(new_td)    