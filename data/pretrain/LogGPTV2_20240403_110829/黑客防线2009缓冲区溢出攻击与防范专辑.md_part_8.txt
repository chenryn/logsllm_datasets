sub cax, 020002020
82, *x* 3011
们就提文一个搜索ShellICode的代码，在内存中找到
原始的ShellCode，然后践过去执行就能满足要求。
ine ebx
acdd ex1 或者su e
设想是这样esp指向是当前被修改过的字符串，从
-1
再编译一下看看机器码，ASCI码在Ox41到0x5A
这里开始往下找，找到原始的字符串后跳转过去执
之间的字符全部没有了，这也算是符合要求吧，我
行，关于判断是否是原始字符串的问题，通过观察
们把这一段汇编编译后的机器码收集起来，加在前
看到，明明提交的是大写的字母，却变成了小写字
面的跳转地址后面，也就是esp指向的地方，在溢出
母，可以设想CMailServe把提交的字符串中的大写字
的时候，它们就可以被执行到，接下来设定大写的
母变成了小写字母我们只要设定一个大写字母构
标记.然后加上ShelICcode，全部组或一个程序，就
成的标志，在搜索的时候发现了大写的标志，就认
成了程序4.cpp
为找到了原始的字符串，先写一个框架如下
现在整体看一下这个好长的字符串，前面是一
mw . NEWS
：设定标记
大堆的垃极字符，然后在szUser+5+524的地方
dso * l1
：风esp开始我
是Ox7FFA9C1B，接下来是我们花了不少力气写的寻
：向下我
找没有被修改过的字符串的Searchcode，然后是一
omp (ets], cax
比收是否我到了
a
没有的动继续肉下
个标记，最后是ShelICode，用L表示垃圾字符，R表
add ebx,3
：执到了的协，疏过这几个半格
示0x7FFAsC1B这个pushesp/ret的地址，S表示Searh
jmp etx
code，F表示标记NEWSC表示ShelICode的话，是
VC中是可以嵌入汇编的，而且可以方便地看汇
下面一张表
编后的代码，嵌入汇编以后，按F10调试，然后按
Cturl+F11就可以看到（如果没有看到，可以试试看右
R
F
淄客安全网WwW.176Ku.CoM
---
## Page 26
免责申请：本站所供资料仅供学习之用，任何人不得将之他用或者进行传播，否则应当自行向实际权利人承担法律责任。因本站部分资料
来源于其他媒介，如存在没有标注来激或来激标注错误导致侵犯阁下权利之处，敬请告知，我将立即予以处理。请购买正版书籍，支持国
内网络安全。
4（黑客防线）2009缓冲区溢出攻击与防范专辑
初级篇
这也是内存中的表示，加了”“表示这是被修改
解，只要知道溢出后能够执行到我们自己提交的字符
后的字符串，实际上我们获得控制权是通过溢出，不
串上面去，然后想办法让它执行正确的ShellCode就
管是怎样获得的，反正就是执行到了R给定的地方
成.上面的过程同样适用于最近的一个Sprv-U的mdtm
(0x7FFA9C1B），然后跳转到了esp指向的地方即S
溢出，过程麻烦一点，但道理都是一样。
S向下搜索到F，最后一个跳转，跳到了C
下面说说寻找pushesp/ret的方法，首先我们要
这其中，L和L是否一致无所调，R和RS和S一定
确定一下机器码是多少，在VC中嵌入汇编，按照前
要一样，也就是不能含有大写的字母.不然执行的时
面的方法看到编译后的机器码，是54C3，在OllyObg
候就变了，F和F一定不能一样—
一如果一样的话，就
左下角的地址框中间.先到一个地方Ox7ftg1571-
没有办法定位原始数据与被CMaiServa修改过的数据的
lion，在这里找到了通用的另外一个代码，我们的
位置。最后C和C是不一样的，要是一样的话，我们
猜想是在附近能够找到想要的代码，右键选择搜
就不用花这么大的力气去写一个Searchcode，当然改
索，HEX栏中填入54C3然后就可以找到匹配的代
ShelICode也是可以的，要改到没有ASCII码在Ox41到
码.按Ctrl+L键看看，能够找到很多呢！
0x5A之间的字符太困难，所以还是算了。
最后还有个小问题前面的ret地址的定位，如果
试试执行的结果，在本地监听一个端口1111
是固定长度的话，确买可以通过两次溢出定位，但是
（cmd.exe下面nc-1-vv-p1111），是不是出来了
实际上这是和安装的路径有关的，还有没有好一点的
Shell？呵呵，一个Exploit就这么写好了，好像不用去看
方法来定位呢？不知道有没有哪位大虾可以为在下解
反汇编后的CMailSevr，也不用对溢出有多么深刻的理
WTF：IFrame这个漏润范害太严重了，很客易爆发全面的病每或者端虫，而且它没有补丁，所以我们只
是将它作为满润研完的类型去看，并不提倡公开灵巧的EP，功能强大的温洞利用程序，请各位有能力自已编
写温利用在要利书籍
就上瘤客安全网www.176lm
简单分析IFrame漏洞
文/图Mameuke
BugraQ公布了一个E的溢出漏洞并给出了相关的
利用EXP，这个漏洞目前还没有官方的补丁，所以急
DS[EAX+34]
MW RAX.DWORID PTR
害挺大，更为严重的是这个漏润影响的系统很广，在
回溯到函数的开头，我们可以看到反汇编后出
几乎所有的Windows语言和版本下面都可以利用，可
错的函数是这样的
以想象，隔不了多久也许就有相应的蝇虫或者是木马
7108822955
PUSH EEP
出来，这个漏洞的描述和利用出来以后，有人专门写
7108H22A
7108B22C
884514
SBBC
MOVEAXDWORD PTR SS:
MOV ERP,ESP
了分析的文章，为了照顾没有看过这篇文章的朋友。
这里还是简要地描述一下。
[EBP+14]
7108E223
8320 00
AND DWORD PTR DS[EAX],0
IE在处理IFrame的时候，调用Wcscpy复制IFrame
71088232
8B5D08
53
MOV EBX,DWORD PTR S8:
的Name这一步没有做长度的检查，结果导致覆盖到
71088236
18+
后面一个结构，这不是一个典型的栈溢出，所以并
8B83 PC130000 MOV EAX.DWORD PTR DS:
没有覆盖到Aet地址或者是Sch，所以利用基本上集中
[T+X]
7108823C
85C0
TEST EAXKAX
在利用原来程序本身代码的基础上，OllyDbg跟踪一
7108823E
7108E23F
56
57
PUSHIESI
个出错的HTML页面可以看到，异常触发时EP一般会
7428
PUSH EDI
停在这一步上
7108E36A
淄客安全网WwW.176Ku.CoM
---
## Page 27
免责申请：本站所供资料仅供学习之用，任何人不得将之他用或者进行传播，否则应当自行向实际权利人承担法律责任。因本站部分资料
来源于其他媒介，如存在没有标注来激或来激标注错误导致侵犯阁下权利之处，敬请告知，我将立即予以处理。请购买正版书籍，支持国
内网络安全。
初级篇
《黑客防线）2009缓冲区溢出攻击与防范专辑
7106428B4034
MOV EAX,DWORD PTR DS:
OxOD刚好可以构成一个XOREAXODCDODODh
[EAX+34]
71088245
8500
TEST EAX,EAX
这是一个肯定不会再次导致异常的指令按照这个
7421
JE SHORT SHDOCVW
POC所设想的，经过大量（而且个数通常不确定）
7108E36A
的“XOREAX，0D0D000Oh后，最后肯定会执行
7108E249
MOV ESLDWORD PTR SS:
到ShellCode.也就是JavaScript里面定义的那个
[EBP+C]
7108824C6A 04
PUSH4
ShellCode包含的数据，
59
POP ECX
这里还有一个小细节，那就是ShellCode前面4
7108E24
BF E8E30871
MOV EDLSHDOCVW.7108E38
个字节为什么都是0x43呢？其实很简单，因为你
71088254
33D2
XOR EDXEDX
不能确定前面这么多的OD是不是刚好都构成了
7108E256F3:A7
[EDILDWORD PTR DS:(ESI]
RHPE CMPS DWORD PTR ES
XOR EAX，ODODODODh”，最坏的情况是在
7108E258
01SL
JNZ SHORT SHDOCVW.
ShelICode之前有一个OxOD，那肯定是要和ShelICode
7108E36A
的前4个字节形成一条语句的，这4个0x43就是为
7108E25A
FP7514
PUSDWORDPR SSRP4
了保证ShelICode能够完整地从开头开始运行，而
71088250
8E08
PP510
PUSWP  1
0x43本身就是一个单字节的incedx，即使单独成
7108E26250
7106250
PUSH EAX
为一条语句也没有什么大碍。
7108E263
FF1I
CALL DWORD PTR DS[ECX]
因为这个溢出不是堆溢出，而且对字符似乎也没
我们可以控制的值最终在7106E236处传递给了
有什么特别的约束，所以可以按照自己的需求替换掉
EAX，然后我们精简一下上面的代码，更为直观地
ShelICode，无论是反向连接或者是下载并执行都可
以，最简单的办法就是在原来的基础上直接
看看，是这样的：
Copy&Paste-个过去，俏若要自己生成文件，那就要
710882428B40 34
稍微麻烦一点，因为你要控制Eax的值，而它本身读
7108E25D8808
CAL
MOV ECX.DWORD PTR DS(EAX)
过来的是一个Widechar，所以要求你生成的文件也是
FFII
我们仅能控制EAX.接着E会把EAX+13处的内等
unicodeng
一开始的时候，我也是直接就写，写到一半发
赋给EAX，再把EAX处的内容赋给ECX最ECX为
现不大对动，文件又小俱乎不对是我信计大小的
一个函数的指针被调用，这个过程还是很麻预的，蛋
两倍），结果用二进制输诚器打开一看才知道，原
然我们能够控制其中的一个寄存器，并且可以间接地
来这是一个Unicode格式的东西，文件的开头是
影响到程序的流程，但是这个“间接”的层数实在太
OxFFFE，于是只好推翻重来。
多，三次对地址的访问使得我们很难找到一个比较好
我其实并没有弄清楚为什么作者选用了
的地址，还有更槽糕的是就算找到了，也没有寄存器
OxODOD0D0D这样一个数字，也许和堆的管理有关，有
可以定位，栈内的数据似乎也没有直接指向我们能够
几次我用04来代替所有的0d是成功的，不过大部分情
控制的地方