在完善应用时，小项目还能减少风险：如果团队想尝试最新的编程语言或框架，
他们可在实现相同微服务API的原型上通过快速迭代来试一下，然后决定是否继续使
用新的编程语言或框架。
一个浮现在我脑海中的真实例子是Firefox的同步存储微服务，通过一些实验，从
当前的Python+MySQL实现切换到基于Go语言的实现，会将用户的数据存储在独立
的SQLite数据库中。该原型具有很高的实验性质，但由于我们已将存储功能和定义良
好的HTTP API隔离在一个微服务中，很容易让一小部分用户试用新方案。
1.4.3 扩展和部署
最后，将应用程序拆分为组件更便于在限制下进行扩展。假设每天都有很多顾客
预订酒店，而 PDF 生成开始消耗更多 CPU。这时你可将这个特定服务部署到具有更
大CPU的服务器上。
另一个典型例子是消耗内存的微服务，例如与诸如Redis 或Memcache的内存数
据库进行交互。你可通过将微服务部署到具有更少CPU、更多内存的服务器上来调整
部署。
总之，微服务的益处如下：
● 团队可独立开发每个微服务，使用任何技术栈都没问题。可自行定义发布周
期。而全部需要定义的只是与语言无关的HTTP API。
● 开发者将复杂的应用拆分成逻辑单元，每个微服务只关注将自己的事情做好。
● 由于微服务是独立应用，因此可对部署进行更精细的控制，让扩展变得更
容易。
微服务架构有利于解决应用开始增长后可能出现的诸多问题。然而，我们需要意
8
第1章 理解微服务
识到，在实践中，微服务架构也会带来一些新问题。
1.5 微服务的缺陷
如前所述，用微服务构建应用有很多益处，但它并非是万能的。
下面列出在编写微服务时，可能需要处理的主要问题：
● 不合理的拆分
● 更多的网络交互
● 数据存储和分享
● 兼容性问题
● 测试
下面将详细讨论这些问题。
1.5.1 不合理的拆分
微服务体系架构的第一个问题是：它如何被设计出来？在第一次尝试中，团队不
可能马上想出完美的微服务架构。诸如PDF生成器的微服务是个明显的用例。但是，
处理业务逻辑时，在你领悟到如何拆分出正确的微服务集之前，你的代码很可能是摇
摆不定的。
通过不断试错，设计才能逐渐趋于成熟。而添加或删除微服务可能比重构单体应
用更令人痛苦。如果没有证据表明需要拆分，不必先将应用拆分成微服务。
过早拆分是万恶之源。
如果对拆分的意义心存疑问，保持代码在同一个应用中是安全的选择。因为拆分
决定可能是错的，所以晚一点把代码拆分到一个新的微服务中比把两个微服务重新合
并到一个代码库更容易一些。
例如，如果你总是必须一起部署两个微服务，或一个微服务的改变会影响另一个
数据模型，很可能是你没有正确地拆分应用，这两个服务应该重新合并。
1.5.2 更多的网络交互
用微服务构建应用时，第二个问题是会增加网络交互。而在单体版本中，即使代
码变得混乱，所有处理也都在一个进程中，可在不需要调用太多后端服务的情况下生
成实际响应，然后返回结果。
9
Python微服务开发
对于微服务架构，需要额外注意每个后端服务的调用方式，下面是可能出现的
问题：
● 如果由于网络隔离或服务延迟， “预订UI”服务无法调用“PDF报表”服务，
会有什么后果？
● “预订UI”服务请求其他服务是同步的还是异步的？
● 这将如何影响响应时间？
我们需要有一个坚定的战略来回答所有这些问题，这个主题将在第5章中讨论。
1.5.3 数据的存储和分享
另一个问题是数据的存储和分享，有效的微服务需要独立于其他微服务，理想情
况下，不应该共享数据库。那么，这对酒店预订应用意味着什么？
再次引发了许多问题：
● 是否在所有数据库中使用相同的用户ID，或者每个服务都有独立的ID并作为
隐藏的实现细节来保存？
● 一旦用户添加到系统中，能否通过诸如“数据抽取”的策略将用户信息复制
到其他服务数据库中，这么做是不是过度重复了？
● 如何处理数据删除？
以上都是难以回答的问题，本书将介绍许多不同的方法来解决它们。
在设计基于微服务的应用时，一个最大的挑战是如何在保持微服务隔离的同
时尽量避免数据重复。
1.5.4 兼容性问题
另一个问题发生在当功能更改影响到多个微服务时。如果不能向后兼容，而且更
改影响到服务之间的数据传输方式，你将遇到很多麻烦。
你部署的新服务能否与旧版本的其他服务一起使用？或者你是否需要一次修改和
部署多个服务？这是不是说你可能无意中发现一些应该合并在一起的服务？
良好的版本控制和干净的API设计有助于缓解这些问题，本书后面将详细讲解这
个问题。
1.5.5 测试
最后，如果要进行端到端的测试并部署整个应用，现在需要测试很多积木一样的
10
第1章 理解微服务
微服务。要有一个强健且敏捷的过程才能高效部署。在开发时要顾及完整应用。你不
可能做到只根据其中一个微服务就完整地测试整个应用。
幸运的是，现在有许多工具可帮助部署使用多个组件构建的应用，我们也将在书
中学到这些工具。所有这些工具推动了微服务架构的成功和采用；如果没有这些工具，
微服务也不会是今天的面貌。
微服务风格架构促进了部署工具的革新，部署工具降低了微服务风格架构的
获准门槛。
下面总结一下微服务的缺陷：
● 过早将应用拆分成微服务可能导致架构设计问题。
● 微服务之间的网络交互增加了开销。
● 测试和部署微服务较为麻烦。
● 最大的挑战：不同微服务之间很难共享数据。
本节提到的所有这些缺陷其实都不必过于担心。它们看起来似乎难以应对，传统
的单体应用好像更安全一些。但从长远看，通过将项目拆分成微服务，开发和运维工
作都变得更容易了。
1.6 使用 Python 实现微服务
Python是一门神奇的多用途语言。
你可能已经知道，Python可用来构建很多不同类型的应用程序，从用来执行服务
器任务的简单系统脚本，到为数百万用户提供服务的大型面向对象应用。
根据 Philip Guo 在 2014 年发布在美国计算机协会(Association for Computing
Machinery)网站上的一项研究，Python 在美国顶尖大学的使用率已经超过 Java，成为
学习计算机科学最流行的语言。
这一趋势在软件行业也是如此。Python 现在位列 TIOBE 索引(http://www.tiobe.
com/tiobe-index/)的前五名，在 Web 开发领域的市场份额可能更大，因为像C 这样的
语言很少被用来构建Web应用程序。
本书假设你已经熟悉Python编程语言。如果你还不是一个富有经验的Python
开发者，可阅读本书作者的另一本书 Expert Python Programming, Second
Edition，来学习高阶Python编程技能。
有些开发者批评Python的速度慢，不适合构建Web服务。Python的确有些慢，
11
Python微服务开发
但依然是构建微服务的语言选项，许多大公司都乐意使用它。
本节将给出使用不同方法来构建Python微服务的背景，还给出关于异步与同步编
程的一些深刻见解，最后总结有关Python性能的一些细节。
本节包含5个部分：
● WSGI标准
● greenlet和gevent模块
● Twisted和Tornado模块
● asyncio模块
● 语言性能
1.6.1 WSGI标准
可以很方便地用Python创建和运行Web应用，这是Python吸引大多数Web开发
者的原因。
受到公共网关接口(Common Gateway Interface，CGI)的启发，Python Web社区建
立了一个标准，称为WSGI (Web Server Gateway Interface，Web服务器网关接口)。有
了WSGI，可更方便地编写Python应用来支持HTTP请求。
使用这个标准编码时，即可通过uwsgi或mod_wsgi等WSGI扩展，由Apache或
nginx等标准服务器执行项目。
应用只需要处理传入请求并返回JSON响应，Python在标准库中包含了所有实现
细节。
使用普通Python模块，只需要不到10行代码，即可创建一个返回服务器本地时
间的功能完备的微服务。下面是代码：
import json
import time
def application(environ，start_response):
headers = [('Content-type'，'application/json')]
start_response('200 OK'，headers)
return [bytes(json.dumps({'time': time.time()})，'utf8')]
自从WSGI协议建立，它就成为一个重要标准，Python Web社区广泛采用了它。
开发者通过编写可挂在WSGI应用之前或之后的功能性中间件，在Web应用环境中完
成不同的事情。
一些Web框架，如Bottle(http://bottlepy.org)，就是专门根据该标准创建的。此后，
12
第1章 理解微服务
很多框架都可在WSGI协议下使用。
使用WSGI的最大问题是原生同步性。对于每个传入请求，都会调用上述代码中
的application函数一次，当函数返回时，必须发回响应。这意味着，每次调用application
函数时，在响应准备好之前，都会阻塞。
对于这种情况下编写的微服务，代码总是需要等待各种网络资源的响应。换句话
说，这时你的应用是停顿的，在所有东西准备好之前，客户端会被阻塞。
对 HTTP API 来说，这样做问题不大。我们并非讨论构建双向应用(如基于 Web
套接字的应用)。但是，当你的应用同时收到多个调用请求时会发生什么？
WSGI 服务器允许运行一个线程池，来并发服务多个请求。但你不可能运行几千
个线程；一旦线程池耗尽，即便微服务除等待后端服务响应外无所事事，下一个请求
还是会阻塞客户的访问。
出于上述原因及其他因素，诸如 Twisted 或 Tornado 的非 WSGI 框架，以及
JavaScript领域的Node.js都大获成功，因为它们完全是异步框架。
在编写 Twisted 应用时，可使用回调来暂停和恢复生成响应的工作。此时，可接
受一个新请求并开始处理。该模型极大地缩短了进程的停顿时间。可服务数千个并发
请求。当然，这并非说应用会更快地返回每个响应，只是说一个进程可接受更多并发
请求，在数据准备好之前，能在请求间进行切换。
在WSGI标准中没有一个简单方式可做到同样的事情，虽然社区内争论了多年，
但最终没能达成共识。社区最终可能放弃WSGI标准。
同时，如果你的部署考虑到WSGI标准的“一个请求对应一个线程”限制，那么
使用同步框架构建微服务仍然是可能的。
不过还有一个诀窍来提升同步的Web 应用，这就是greenlet，下一节将对此进行
解释。
1.6.2 greenlet和gevent模块
异步编程的一般原则是，让进程处理多个并发执行的上下文来模拟并行处理方式。
异步应用使用一个事件循环，当一个事件触发时暂停或恢复执行上下文；只有一
个上下文处于活动状态，上下文之间进行轮替。代码中的显式指令将告诉事件循环，
哪里可暂停执行。这时，进程将查找其他待处理的线程进行恢复。最终，进程将回到
函数暂停的地方并继续运行。从一个执行上下文移到另一个称为“切换”。
greenlet 项目(https://github.com/python-greenlet/greenlet)是根据 Stackless 项目构建
的程序包，是一个特别的CPython实现。
greenlet 是易于实例化的伪线程，可用来调用Python函数。在这些函数中，可切
13
Python微服务开发
换到另一个函数，即将控制权交给另一个函数。切换是通过事件循环完成的，允许使
用类似线程的接口范式来编写异步应用。
下面是greenlet文档中的一个例子：
from greenlet import greenlet
def test1(x，y):
z = gr2.switch(x+y)
print(z)
def test2(u):
print (u)
gr1.switch(42)
gr1 = greenlet(test1)
gr2 = greenlet(test2)
gr1.switch("hello"，" world")
上例中的两个greenlet显式地从一个切换到另一个。
为构建基于 WSGI 标准的微服务，如果底层代码使用 greenlet，我们可接受多个
并发请求，当知道一个调用将阻塞请求(如I/O请求)时，只需要从一个请求切换到另
一个。
不过，从一个 greenlet 切换到另一个需要显式地完成，这会导致代码变得混乱，
难以理解。这就轮到gevent大显身手了。
gevent(http://www.gevent.org/)项目构建在greenlet的上层，能采用隐性方式在