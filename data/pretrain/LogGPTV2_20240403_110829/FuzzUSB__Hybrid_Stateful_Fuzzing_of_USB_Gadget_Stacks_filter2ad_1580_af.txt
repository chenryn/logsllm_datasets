Security 21), 2021, pp. 249–266.
[52] K. Lu and H. Hu, “Where does it go? refining indirect-call
targets with multi-layer type analysis,” in Proceedings
of the 2019 ACM SIGSAC Conference on Computer and
Communications Security, 2019, pp. 1867–1881.
[53] T. Zhang, W. Shen, D. Lee, C. Jung, A. M. Azab, and
R. Wang, “Pex: A permission check analysis framework
for linux kernel,” in Proceedings of 28th USENIX Security
Symposium (USENIX Security), 2019.
[54] A. Machiry, C. Spensky, J. Corina, N. Stephens,
C. Kruegel, and G. Vigna, “Dr.checker: A soundy analysis
for linux kernel drivers,” in Proceedings of the 26th
USENIX Security Symposium (USENIX Security), 2017.
[55] D. Song, F. Hetzelt, J. Kim, B. B. Kang, J.-P. Seifert, and
M. Franz, “Agamotto: Accelerating kernel driver fuzzing
with lightweight virtual machine checkpoints,” in 29th
{USENIX} Security Symposium ({USENIX} Security 20),
2020, pp. 2541–2557.
[56] G. Hernandez, F. Fowze, D. Tian, T. Yavuz, and K. R.
Butler, “Firmusb: Vetting usb device firmware using
domain informed symbolic execution,” in Proceedings
of the 2017 ACM SIGSAC Conference on Computer and
Communications Security, 2017, pp. 2245–2262.
[57] D. Song, F. Hetzelt, D. Das, C. Spensky, Y. Na, S. Vol-
ckaert, G. Vigna, C. Kruegel, J.-P. Seifert, and M. Franz,
“Periscope: An effective probing and fuzzing framework
for the hardware-os boundary,” in Proceedings of the
2019 Annual Network and Distributed System Security
Symposium (NDSS), San Diego, CA, Feb. 2019.
[58] S. Kim, M. Xu, S. Kashyap, J. Yoon, W. Xu, and T. Kim,
“Finding semantic bugs in file systems with an extensible
fuzzing framework,” in Proceedings of the 27th ACM
Symposium on Operating Systems Principles (SOSP),
2019.
[59] E. B. Yi, H. Zhang, K. Xu, A. Maji, and S. Bagchi,
“Vulcan: Lessons in reliability of wear os ecosystem
through state-aware fuzzing,” in Proceedings of the 18th
Annual International Conference on Mobile Systems,
Applications, and Services (MobiSys), 2020.
[60] H. Gascon, C. Wressnegger, F. Yamaguchi, D. Arp,
and K. Rieck, “Pulsar: Stateful black-box fuzzing of
proprietary network protocols,” in Proceedings of the
International Conference on Security and Privacy in
Communication Systems (SecureComm). Springer, 2015,
pp. 330–347.
[61] R. Ma, T. Zhu, C. Hu, C. Shan, and X. Zhao, “Sulleyex:
A fuzzer for stateful network protocol,” in Proceedings
of the International Conference on Network and System
Security (NSS). Springer, 2017, pp. 359–372.
[62] J. De Ruiter and E. Poll, “Protocol state fuzzing of tls
implementations,” in 24th USENIX Security Symposium
(USENIX Security 15), 2015, pp. 193–206.
[63] C. Aschermann, S. Schumilo, A. Abbasi, and T. Holz,
“Ijon: Exploring deep state spaces via fuzzing,” in 2020
IEEE Symposium on Security and Privacy (SP), 2020.
[64] Y. Chen and X. Xing, “Slake: facilitating slab manipu-
lation for exploiting vulnerabilities in the linux kernel,”
in Proceedings of the 2019 ACM SIGSAC Conference
on Computer and Communications Security, 2019, pp.
1707–1722.
[65] W. Wu, Y. Chen, J. Xu, X. Xing, X. Gong, and W. Zou,
“{FUZE}: Towards facilitating exploit generation for
kernel use-after-free vulnerabilities,” in 27th USENIX
Security Symposium (USENIX Security 18), 2018, pp.
781–797.
APPENDIX A
EFFICIENCY OF BUG FINDING
In this section, we evaluate how effective FUZZUSB is in
finding bugs. We performed the following two experiments: 1)
measure the number of vulnerabilities identified by FUZZUSB
within a limited period of time; and 2) measure the time taken to
identify previously known CVE vulnerabilities. While running
each experiment, we also run other gadget fuzzers to compare
the time-to-detection.
First, we examine how many bugs that FUZZUSB can
discover within a limited period of time. Using the kernel
version Linux-5.5, we ran FUZZUSB along with the two
gadget fuzzers for 50 hours. Removing duplicate crashes
(using syzkaller crash-hashing functionality), we recorded the
number of uniquely identified bugs for three running times,
then obtained the average results as presented in Figure 12b.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:39:18 UTC from IEEE Xplore.  Restrictions apply. 
162227
Compared with FuzzUSB-SL and G-fuzzer, FUZZUSB
not only found more bugs (about 40) in total but also found
the first bugs faster. Given the total number of bugs detected
by G-fuzzer and FuzzUSB-SL in 50 hours, FUZZUSB
showed the same bug-finding capability after 1 hour and 10
hours, respectively.
We carried out an additional experiment based on known
CVEs to measure the time taken to detect. Specifically, we
run FUZZUSB to detect CVE-2019-14763 and CVE-2018-
20961. Table VIII summarizes the results of this experiment.
FUZZUSB found these two bugs faster than FuzzUSB-SL.
In addition, we noticed that G-fuzzer is unable to find any
of these two bugs, since it cannot go deeper in the gadget code
due to the lack of multi-channel fuzzing capability.
To summarize, in terms of bug-finding efficiency, FUZZUSB
shows 50 times better performance than code-coverage fuzzing
G-fuzzer, and achieves 5 times higher efficiency than
FuzzUSB-SL.
# States/Trans
Analysis time (sec)
Kernel
Gadget
&
Linux
hid
mass
printer
acm
ecm
ncm
eem
rndis
subset
Total
10.07
48.22
11.34
13.66
16.67
16.28
15.49
17.53
15.20
17.40
19.24
17.19
19.41
11.72
9.89
23.87
9.38
11.79
13.30
15.25
11.69
14.53
15.45
11.48
16.16
18.74
13.15
12.17
TABLE IX: Performance of state machine construction.
Android midi
uac1
uac1_leg
uac2
serial
obex
tcm
loopback
sourcesink
phonet
accessory
audio_src
mtp
conn
cdev
ptp
ccid
laf
hw_acm
Symbolic
7.30
35.22
7.28
10.11
13.28
13.34
12.50
14.29
12.21
15.19
16.36
14.21
15.92
9.17
7.72
18.50
6.90
9.11
10.27
11.44
8.98
11.12
12.24
8.51
11.97
14.80
9.76
9.19
15 / 28
15 / 42
15 / 28
14 / 26
14 / 26
14 / 26
14 / 26
14 / 26
14 / 26
14 / 26
14 / 26
13 / 24
13 / 24
14 / 26
14 / 26
15 / 30
12 / 24
14 / 26
14 / 26
14 / 26
12 / 22
14 / 26
14 / 26
14 / 26
14 / 26
16 / 30
14 / 26
14 / 26
Static
1.75
11.70
2.73
1.68
1.69
1.71
1.62
1.43
1.68
1.24
1.77
1.76
1.86
1.16
1.30
4.33
0.79
1.33
1.26
1.71
1.15
2.11
2.22
1.09
2.09
2.33
1.50
1.74
Android
specific
...
// allocation point
req_in = hidg_alloc_ep_req(hidg->in_ep, ...);
if (!req_in) {
}
// error handling
if (hidg->in_ep != NULL) {
1 /* function from Ch2 */
2 int hidg_set_alt(struct usb_function *f, ...)
3 {
4
5
6
7
8
9
10
11
12
13
14
15
16
17 }
18 /* function from Ch1 */
19 void hidg_disable() {
20
21
22
23 }
...
usb_ep_disable(hidg->in_ep);
...
}
...
if (hidg->in_ep != NULL) {
hidg->req = req_in; // missing point
...
}
Fig. 18: A victim gadget code.
while (1)
feed_input(Ch2, arg)
1 /* exploit function from Ch2 */
2 void Ch2_exploit(arg)
3 {
4
5
6 }
7 /* exploit function from Ch1 */
8 void Ch1_exploit(arg)
9 {
10
11
12 }
13 create_thread (Ch2_exploit, reset_connect);
14 create_thread (Ch1_exploit, disable_connect);
feed_input(Ch1, arg)
while (1)
Fig. 19: Feasible PoC exploit against Figure 18.
to fully deal with a layered communication protocol (e.g.,
SCSI) over the USB channel. To tackle all protocol commands,
we leverage corresponding transition inputs obtained from
the symbolic execution, which increases the total transition
numbers. Accordingly, to fully handle every command, mass_-
storage includes large functionalities with a large codebase.
For this reason, building the state machine for this gadget
driver requires more time. In contrast, the loopback gadget
provides simpler functionalities — it receives messages from
Ch3, and sends them back through that channel, resulting in a
smaller number of states.
APPENDIX C
ADDITIONAL CASE STUDIES
APPENDIX B
OVERHEAD OF BUILDING STATE MACHINES
A. DoS attack
In this section, we examine the building process of state
machines. Table IX summarizes the result of our state machine
construction. In the table, the third column indicates the number
of states as well as transitions for each gadget, and the last
three columns present the time needed by the analyses to build
the state machines. The overhead of building state machines
is 15.93s on average, including static and symbolic analysis as
well as state merging.
Our observation found that the mass_storage gadget has
much more transitions than other gadgets because it needs
Aside from §C-B, we present an additional example of ex-
ploitation. In Figure 18, the buggy function hidg_set_alt
tries to reset the connection. For a new connection, the function
allocates a kernel object req_in to hold data from the host
(line 7). Since the assignment of req_in into a global instance
at line 14 is away from its initial allocation at line 7, during
such time window, the object can leak by the not-taken branch
at line 13 if unexpected disconnect function hidg_disable
nullifies the instance in_ep (line 21). Figure 19 outlines the
corresponding PoC code. The idea behind the PoC is to realize
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:39:18 UTC from IEEE Xplore.  Restrictions apply. 
172228
Component
FSM construction
Fuzzer
State manager
Host backend
TABLE X: Lines of code composing FUZZUSB.
Lines of Code
1,564
630
844
1,381
Language
Python,C++
Go
Python
C
such a race condition between the reconnection (Ch2) and
disconnection (Ch1), in the hope that we meet the condition
of the memory leak above. Using two separate threads, we
extensively feed inputs from the two channels Ch1 and Ch2,
to trigger reconnection and disconnection simultaneously. After
10-hour running of the exploit code, we observed the kernel
memory space fills up (as a result of frequent memory leaks),
causing the denial-of-service (DoS). Such a DoS exploit is
crucial, for instance, when providing services in the cloud
system. Note that FUZZUSB not only improves the capability
of revealing such a bug with our multi-channel mutation but
also facilitates exploit generation by providing the infrastructure
of the multi-channel input distribution, which are unlikely done
by existing USB fuzzers.
B. Control-flow attack
To demonstrate the high severity of our findings, we
demonstrate an arbitrary code execution on the buggy HID
gadget shown in Figure 9. Referring to the reported attack
scenario against use-after-free bugs [64, 65], we successfully
diverted the control flow of the HID driver, and achieved
illegitimate code execution. The exploit works by reallocating
the freed memory (i.e., hidg at
line 16) and putting a
compromised value into the function pointer in hidg, leading
to an illegal control flow transfer when the HID driver accesses
its dangling pointer. This example is fully exploitable because
the vulnerable object hidg contains abundant function and
data pointers (e.g., unbind), and attackers can populate them
with user-supplied data via system calls (e.g., sendmsg).
A successful exploitation is challenging, because it needs
to reallocate the memory region where the vulnerable object
(e.g., hidg) was occupied in a short time window between
its deallocation and the dangling pointer access. In this
example, however, the attacker could easily manipulate such
a time window, because the dangling pointer occurrence and
dereference could be controlled by system calls, i.e., close()
and read(), respectively. The PoC allows attackers to take
control of the gadget, diverting its control flow.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:39:18 UTC from IEEE Xplore.  Restrictions apply. 
182229