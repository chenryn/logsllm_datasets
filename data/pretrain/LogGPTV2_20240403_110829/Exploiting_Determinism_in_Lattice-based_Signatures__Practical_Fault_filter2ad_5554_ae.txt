### Iterations within the Signing Procedure

The rejection sampling approach used to sample for \( y \in S_{\ell}^{\gamma_1 - 1} \) introduces iterations within the signing procedure. We make two crucial observations regarding the reference implementation of the Dilithium scheme, which help us locate the target addition operation.

#### Observations
1. **Observation-1**: The first rejection of the signature occurs during the infinity norm check of \( z \). This operation is performed immediately after our target addition operation.
2. **Observation-2**: Almost all operations preceding our target addition operation are repeated a certain number of times, depending on the number of polynomials (\( k, \ell \)) in the module.

### Data Collection and Segmentation

We collect multiple fault-free electromagnetic (EM) traces \( t_i \) for \( i = 1, \ldots, N \), corresponding to the signing procedures for message inputs \( m_i \). These traces are then partitioned into segments, each corresponding to an individual iteration as described above.

Based on **Observation-1**, we know that the offset of the addition operation in \( zgen \) will be less than the length of the shortest segment (\( lenshort\_seg \)), and the addition operation will be approximately located near the end of the smallest segment, i.e., \( locadd(m) \lesssim lenshort\_seg \).

Using **Observation-2** and our knowledge of the implementation, we perform a second-order pattern recognition to identify repeating patterns within a given segment. With prior knowledge of the order of execution of operations and their repetition counts, the attacker can look for patterns in the same order and with the same repetition counts. Refer to Figure 8(c) for the EM trace corresponding to a single iteration/segment. We can distinguish the repeating patterns within the segment and identify our target addition operation within a certain approximation. The repeating patterns on the trace in Figure 8(c) are marked with the corresponding functions (and their repetition counts) used in the reference implementation [19].

### Estimating the Addition Operation Location

For a given message \( m \) to be signed, the identified location of the last iteration \( loclast\_iter(m) \) is added to the estimated offset of the addition operation \( locadd(m) \). Thus, the estimated location of the target addition operation from the start of the signing procedure is:
\[ tadd(m) = loclast\_iter(m) + locadd(m) \]

Considering the trigger-delay of about 130 nsec of our EM pulse generator, we identify a suitable time-window of sufficient length around \( tadd(m) \) and sweep the fault injection process over this window until we are able to fault the individual coefficients of the signature component \( z \).

### Fault Injection Results

For all three implementation variants, our attack requires realizing two different faults: skip-STR and skip-ADD. We scanned the entire top layer of the chip and identified a precise location (close to the center of the chip near the ARM logo) where we could achieve 100% repeatability in skipping the store instruction. With this fault model, we were able to attack both Variant-1 and Variant-2 implementations of Dilithium. However, we were not able to achieve practical faults to skip the ADD instruction required to attack Variant-3. Although we could not demonstrate a practical fault attack on Variant-3, we do not consider this a countermeasure against our attack, as a more powerful fault attacker with enhanced capabilities like increased precision and multiple laser injections might still mount a successful fault attack on the Variant-3 implementation [29].

### Zero-Cost Mitigation

There are generic countermeasures that provide protection against our attack, such as double computation and verification-after-sign, but at a considerable increase in computational cost [9]. Using additional randomness for sampling \( y \) can thwart our attack by removing the deterministic assumption, but the subsequent non-deterministic version of Dilithium is no longer secure in the quantum random oracle model [19]. Therefore, we present a zero-cost mitigation strategy against our skip-addition fault attacks, which only requires simple reordering of operations within the signing procedure.

#### Reordering Operations

We observe that the vulnerable addition operation is the last operation performed to generate the signature component \( z \). Targeting this addition operation ensures that the attacker can directly observe the effect of the injected fault from the faulty \( z \). Moreover, since the addition is a point-wise operation in \( R_q \), a single fault does not cause enough perturbation to be detected. These aspects enable the attacker to derive a relation between the faulty signatures and the primary secret \( s_1 \), thus enabling the attack.

We investigate the possibility of embedding the vulnerable addition operation deeper within the signing procedure to ensure that succeeding operations propagate the injected fault strongly enough so that the faulty signatures never pass the rejection checks in the signing procedure.

#### Utilizing Number Theoretic Transform (NTT)

We observe that polynomial multiplication in \( R_q \) in Dilithium is computed efficiently using the Number Theoretic Transform (NTT). The NTT operation is a deterministic linear transformation of a given polynomial from the normal domain to the NTT domain in the same ring, \( NTT: R_q \rightarrow R_q \). There is also an associated inverse NTT transformation (INTT) mapping polynomials back from the NTT domain to the normal domain. In the reference implementation of Dilithium, the addition operation within \( zgen \) occurs in the normal domain. We know that \( R_q \) exhibits an isomorphism with itself under the NTT transform, i.e., \( NTT(a + b) = NTT(a) + NTT(b) \) for all \( a, b \in R_q \). Additionally, the NTT (resp. INTT) transform has a diffusion property, where every coefficient of the output is a unique linear combination of all the input coefficients.

We examine the prospect of performing the addition in the NTT domain and further inverting the result into the normal domain using the INTT transform:
\[ z = INTT(NTT(s_1 c) + NTT(y)) \]

In the above case, the INTT operation is performed after the addition of polynomials in the NTT domain. A detailed description of the NTT operation is provided in Appendix C. If an attacker successfully faults the addition operation in the NTT domain, introducing a perturbation \( \delta_t > 0 \) at the \( t \)-th coefficient, the diffusion property of the INTT ensures that the fault \( \delta_t \) is propagated to all the coefficients of the output polynomial, which in our case is \( \hat{z} \). This ensures that the coefficients of the faulty \( \hat{z} \) in the normal domain are uniformly distributed in the range \([0, q - 1]\). Since valid signatures are expected to satisfy the condition \( \|z\|_\infty < \gamma_1 - \beta \), the faulted signatures are rejected by the signing procedure with a very high probability. The probability of acceptance of a faulty signature is estimated to be approximately \( 2^{-4320} \) for recommended parameters of Dilithium.

However, if the addition operation is not faulted even upon successful skipping, i.e., addition with a zero coefficient resulting in \( \delta_t = 0 \), our NTT-protected implementation is still attackable through a slight modification in the attack approach. Faulty signatures are never output due to the fault propagation by the INTT transform, so the attacker should look for safe errors (valid signatures) upon successful fault injection. On identifying a safe error in coefficient \( t \), the attacker can construct a corresponding equation of the form \( (s_1 c)_t = 0 \) (Case-1) or \( (s_1 c)_t = (z)_t \) for Case-2. Both equations are linear in \( N \) variables with the unknowns being the coefficients of the primary secret \( s_1 \). Collecting \( N \) such equations will lead to the successful recovery of the primary secret. Given that the coefficients of \( y \) and \( s_1 c \) are uniformly distributed in \([0, q - 1]\), the probability to observe a zero coefficient in either \( y \) or \( s_1 c \) is about \( 1/q \), which equals about \( 2^{-23} \) for Dilithium. Observing \( n \) safe errors for key recovery will require running the signing procedure \( q \times \ell \times n \) times, amounting to about \( 2^{33} \) signing procedures for the recommended parameter set of Dilithium, while our proposed attack on the previous cases only required about \( \ell \times n \) signatures, i.e., \( \approx 2^{10} \) signing procedures for recommended parameters. Though the theoretical increase is only about \( q \), the large size of \( q \approx 2^{23} \) exponentially increases the attacker’s complexity.

### Evaluation of the Mitigation Approach

We performed fault simulations of our NTT-protected implementation for about \( 2^{25} \) runs of the signing procedure and estimated that about \( 2^{30} \) signatures are required to collect enough information to construct the \( \ell \times n \) equations for the recovery of the primary secret of Dilithium. Referring to the results from Table 2, we infer that attacking our NTT-protected implementation requires around 20 years of signing time, under the same attack model, just to observe enough safe-errors to recover the primary secret \( s_1 \) of Dilithium. This underlines an increase in the attacker’s complexity of \( 2^{20} \) in terms of both computational time and effort.

Implementing the mitigation comes at zero cost since it involves only simple reordering of instructions within the \( zgen \) step. To the best of our knowledge, we present the first use case of the NTT transform being used as a countermeasure against fault attacks. We propose our algorithm-level mitigation technique as a concrete countermeasure against attacks that possibly target the vulnerable secret-dependent addition operation in lattice-based signature schemes.

### Conclusion

In this work, we have extended the practicality and applicability of skip-addition fault attacks to deterministic lattice-based signature schemes. We demonstrate practical fault attacks against deterministic variants of Dilithium and qTESLA signature schemes, which require only single-targeted faults in the signing procedure that allow key recovery and subsequently an existential forgery attack. We further demonstrate the efficacy of our attack against two well-known countermeasures used to protect against the skip-addition fault attack. We perform experimental validation of our attack using Electromagnetic fault injection over implementations from the pqm4 library on the ARM Cortex-M4 microcontroller. Finally, we also propose a zero-cost mitigation strategy using the NTT operation that exponentially increases the attacker’s complexity to protect against skip-addition fault attacks and possibly against attacks that target the vulnerable addition operation in lattice-based signature schemes.

### References

[1] Sedat Akleylek, Nina Bindel, Johannes Buchmann, Juliane Krämer, and Giorgia Azzurra Marson. 2016. An efficient lattice-based signature scheme with provably secure instantiation. In International Conference on Cryptology in Africa. Springer, 44–60.

[2] Christopher Ambrose, Joppe W Bos, Björn Fay, Marc Joye, Manfred Lochter, and Bruce Murray. 2018. Differential attacks on deterministic signatures. In Cryptographers’ Track at the RSA Conference. Springer, 339–353.

[3] Shi Bai and Steven D Galbraith. 2014. An Improved Compression Technique for Signatures Based on Learning with Errors. In CT-RSA, Vol. 8366. 28–47.

[4] Rami Barends, Julian Kelly, Anthony Megrant, Andrzej Veitia, Daniel Sank, Evan Jeffrey, Ted C White, Josh Mutus, Austin G Fowler, Brooks Campbell, et al. 2014. Superconducting quantum circuits at the surface code threshold for fault tolerance. Nature 508, 7497 (2014), 500–503.

[5] Alessandro Barenghi and Gerardo Pelosi. 2016. A note on fault attacks against deterministic signature schemes (short paper). In International Workshop on Security. Springer, 182–192.

[6] Daniel J Bernstein, Niels Duif, Tanja Lange, Peter Schwabe, and Bo-Yin Yang. 2012. High-speed high-security signatures. Journal of Cryptographic Engineering 2, 2 (2012), 77–89.

[7] Nina Bindel, Sedat Akleylek, Erdem Alkim, Paulo S. L. M. Barreto, Johannes Buchmann, Edward Eaton, Gus Gutoski, Juliane Kramer, Patrick Longa, Harun Polat, Jefferson E. Ricardini, and Gustavo Zanon. 2017. qTESLA. Technical Report. National Institute of Standards and Technology. available at https://csrc.nist.gov/projects/post-quantum-cryptography/round-1-submissions.

[8] Nina Bindel, Johannes Buchmann, and Juliane Krämer. 2016. Lattice-based signature schemes and their sensitivity to fault attacks. In Fault Diagnosis and Tolerance in Cryptography (FDTC), 2016 Workshop on. IEEE, 63–77.

[9] Nina Bindel, Juliane Kramer, and Johannes Schreiber. 2017. Special session: hampering fault attacks against lattice-based signature schemes—countermeasures and their efficiency. In Hardware/Software Codesign and System Synthesis (CODES+ISSS), 2017 International Conference on. IEEE, 1–3.

[10] Leon Groot Bruinderink, Andreas Hülsing, Tanja Lange, and Yuval Yarom. 2016. Flush, Gauss, and Reload—a cache attack on the BLISS lattice-based signature scheme. In International Conference on Cryptographic Hardware and Embedded Systems. Springer, 323–345.

[11] Leon Groot Bruinderink and Peter Pessl. 2018. Differential Fault Attacks on Deterministic Lattice Signatures. IACR Transactions on Cryptographic Hardware and Embedded Systems 2018, 3 (2018). https://eprint.iacr.org/2018/355.pdf.

[12] Léo Ducas, Alain Durmus, Tancrède Lepoint, and Vadim Lyubashevsky. 2013. Lattice signatures and bimodal Gaussians. In Advances in Cryptology–CRYPTO 2013. Springer, 40–56.

[13] Thomas Espitau, Pierre-Alain Fouque, Benoît Gérard, and Mehdi Tibouchi. 2016. Loop-abort faults on lattice-based Fiat-Shamir and hash-and-sign signatures. In International Conference on Selected Areas in Cryptography. Springer, 140–158.

[14] Thomas Espitau, Pierre-Alain Fouque, Benoît Gérard, and Mehdi Tibouchi. 2017. Side-channel attacks on BLISS lattice-based signatures: Exploiting branch tracing against strongswan and electromagnetic emanations in microcontrollers. In Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security. ACM, 1857–1874.

[15] Thomas Espitau, Pierre-Alain Fouque, Benoit Gerard, and Mehdi Tibouchi. 2018. Loop-Abort Faults on Lattice-Based Signatures and Key Exchange Protocols. IEEE Trans. Comput. (2018).

[16] Tim Güneysu, Vadim Lyubashevsky, and Thomas Pöppelmann. 2012. Practical lattice-based cryptography: A signature scheme for embedded systems. In International Conference on Cryptographic Hardware and Embedded Systems. Springer, 530–547.

[17] Matthias J. Kannwischer, Joost Rijneveld, Peter Schwabe, and Ko Stoffelen. [n.d.]. PQM4: Post-quantum crypto library for the ARM Cortex-M4. https://github.com/mupq/pqm4.

[18] Vadim Lyubashevsky. 2009. Fiat-Shamir with aborts: Applications to lattice and factoring-based signatures. In International Conference on the Theory and Application of Cryptology and Information Security. Springer, 598–616.

[19] Vadim Lyubashevsky, Leo Ducas, Eike Kiltz, Tancrede Lepoint, Peter Schwabe, Gregor Seiler, and Damien Stehle. 2017. CRYSTALS-Dilithium. Technical Report. National Institute of Standards and Technology. available at https://csrc.nist.gov/projects/post-quantum-cryptography/round-1-submissions.

[20] Vadim Lyubashevsky, Chris Peikert, and Oded Regev. 2013. On Ideal Lattices and Learning with Errors over Rings. J. ACM 60, 6 (2013), 43.

[21] Daniele Micciancio. 2007. Generalized compact knapsacks, cyclic lattices, and efficient one-way functions. Computational Complexity 16, 4 (2007), 365–411.

[22] National Institute of Standards and Technology. 2016. Post-Quantum Crypto Project. http://csrc.nist.gov/groups/ST/post-quantum-crypto/.

[23] National Institute of Standards and Technology. 2019. Round 2 Submissions, Post-Quantum Cryptography. Technical Report. available at https://csrc.nist.gov/projects/post-quantum-cryptography/round-2-submissions.

[24] NIST. 2016. Submission Requirements and Evaluation Criteria for the Post-Quantum Cryptography Standardization Process. https://csrc.nist.gov/csrc/media/projects/post-quantum-cryptography/documents/call-for-proposals-final-dec-2016.pdf.