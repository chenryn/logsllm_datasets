title:BScout: Direct Whole Patch Presence Test for Java Executables
author:Jiarun Dai and
Yuan Zhang and
Zheyue Jiang and
Yingtian Zhou and
Junyan Chen and
Xinyu Xing and
Xiaohan Zhang and
Xin Tan and
Min Yang and
Zhemin Yang
BScout: Direct Whole Patch Presence Test for 
Java Executables
Jiarun Dai, Yuan Zhang, Zheyue Jiang, Yingtian Zhou, and Junyan Chen, 
Fudan University; Xinyu Xing, Pennsylvania State University; Xiaohan Zhang, 
Xin Tan, Min Yang, and Zhemin Yang, Fudan University
https://www.usenix.org/conference/usenixsecurity20/presentation/dai
This paper is included in the Proceedings of the 29th USENIX Security Symposium.August 12–14, 2020978-1-939133-17-5Open access to the Proceedings of the 29th USENIX Security Symposium is sponsored by USENIX.BScout: Direct Whole Patch Presence Test for Java Executables
Jiarun Dai1, ¶, Yuan Zhang1, ¶, Zheyue Jiang1, Yingtian Zhou1, Junyan Chen1, Xinyu Xing2, Xiaohan
Zhang1, Xin Tan1, Min Yang1, and Zhemin Yang1
1School of Computer Science, Fudan University, China
2College of Information Sciences and Technology, Pennsylvania State University, USA
¶co-ﬁrst authors
Abstract
To protect end-users and software from known vulnerabilities,
it is crucial to apply security patches to affected executables
timely. To this end, patch presence tests are proposed with the
capability of independently investigating patch application
status on a target without source code. Existing work on
patch presence testing adopts a signature-based approach. To
make a trade-off between the uniqueness and the stability
of the signature, existing work is limited to use a small
and localized patch snippet (instead of the whole patch) for
signature generation, so they are inherently unreliable.
In light of this, we present BSCOUT, which directly checks
the presence of a whole patch in Java executables without
generating signatures. BSCOUT features several new tech-
niques to bridge the semantic gap between source code
and bytecode instructions during the testing, and accurately
checks the ﬁne-grained patch semantics in the whole target
executable. We evaluate BScout with 194 CVEs from the
Android framework and third-party libraries. The results show
that it achieves remarkable accuracy with and without line
number information (i.e., debug information) presented in
a target executable. We further apply BSCOUT to perform
a large-scale patch application practice study with 2,506
Android system images from 7 vendors. Our study reveals
many ﬁndings that have not yet been reported.
1 Introduction
Nowadays, it is very common for software developers to
borrow code from open-source projects and then integrate
them into their closed-source software products. According
to a recent study [17], open-source projects usually contain a
large number of vulnerabilities, which could be propagated to
closed-source software. To battle against n-day vulnerabilities
in closed-source software, it is crucial to know whether a vul-
nerability has been ﬁxed in affected closed-source software,
i.e., whether a piece of software has applied a security patch
for a speciﬁc vulnerability. This kind of capability, known as
patch presence test [46], enables independent and quantitative
evaluation of software security for known vulnerabilities
and may urge software vendors to pay more attention to
vulnerability patching. With these features, a patch presence
test is an important complementary technique to protect
software and end-users from known threats.
To test the presence of a patch in target software, one
instinctive reaction is to perform vulnerable code search.
However, such techniques cannot be simply applied to per-
form a patch presence test. First, previous work on ﬁnding
vulnerable code utilizes function-level [29, 34, 42] or image-
level [17, 21] code similarity to pinpoint code difference.
However, such methods cannot provide sufﬁcient granularity
for patch presence test, and thus inevitably introduce high
error rates in identifying patch existence. Second, existing
work on ﬁnding vulnerable code primarily leverages source-
to-source [29, 33, 42] or binary-to-binary [18, 22, 28] test. In
the patch presence test, it requires checking patch presence
in the source-to-binary fashion. Therefore, these methods are
not considered as feasible solutions.
Going beyond techniques in vulnerable code search,
FIBER [46] is another line of work that could be potentially
used for a patch presence test. It is built to perform patch
presence test for C/C++ binaries. Technically, FIBER
devises a two-step approach by generating binary-level patch
signatures from reference binary (built from reference source
code) and then leveraging binary-to-binary test for signature
matching on the target binary. To make a trade-off between
the uniqueness (i.e. the signature only exists in the patch
itself) and the stability (i.e. the signature is robust to benign
evolution of the codebase) of the signature, FIBER only
regards a small and localized part of the patch for signature
generation. An obvious limitation of this approach is that it
does not reﬂect the presence of the whole patch, thus it is
inherently unreliable. Furthermore, FIBER adopts an exact
signature matching mechanism on the target, which is hard
to tolerate the possible code customization on the signature
part. Actually, FIBER is evaluated with only 8 binaries, but
it has already reported several incorrect test results due to
USENIX Association
29th USENIX Security Symposium    1147
code customization, signature instability, etc (as conﬁrmed in
[46]). Another limitation is that it requires to build the whole
project for generating binary-level signatures from source
code, and requires to choose the most similar image with the
test target for signature generation, which is quite inﬂexible.
These facts hinder its adoption to test a large volume of
binaries.
To address the limitations above, we argue a patch presence
test tool should have three properties – robustness, high
accuracy, and ﬂexibility. By robustness, we mean a patch
presence test should rely on the whole patch rather than
a small and localized patch snippet for testing. By high
accuracy, we mean, whether a patch is applied or not, a patch
presence test should accurately report its status. By ﬂexibility,
we mean a patch presence test should not depend on building
the reference source code of the test target which is not a fully
automated process in most cases.
In this work, we propose a new patch presence test tool,
BSCOUT to ensure the three properties above. Different from
existing techniques, BSCOUT leverages the whole patch to
directly test its presence in Java Bytecode from Source code
without generating signatures. The rationales of targeting
Java executables are three-fold. First, Java executables are
pervasive and ubiquitous, which have been demonstrated to
have numerous n-day vulnerabilities. Second, there is no
existing work on patch presence test for Java executables.
Third, we observe that the semantic information carried by
Java bytecode instructions may be exploited to facilitate patch
presence test. To the best of our knowledge, we are the ﬁrst to
study patch presence testing techniques on Java executables
by leveraging the whole patch for a test.
Technical challenges. BSCOUT faces several non-trivial
challenges of directly performing a source-to-binary test
and accurately checking the presence of a group of source
code changes in an executable: 1) a security patch may only
introduce tiny changes [31], and we need to establish ﬁne-
grained and accurate links for these changes between the
patch and the target executable; 2) since Java source code and
Java bytecode instructions are expressed at different language
layers and have different formats, it is difﬁcult to perform
cross-layer code equivalence test; 3) some patch-changed
lines may occur multiple times in the target executable and,
therefore, it requires us not to simply check the presence of
the patch lines alone; 4) a patch may consist of several types
of changes (e.g., addition, deletion), and it is inappropriate to
adopt a uniform test strategy for each change type.
Basic idea. The design of BSCOUT is inspired by the
line-level patch generation and application practice [35],
which detects tiny modiﬁcation by measuring the proportion
of patch lines present in the target executable. To perform
line-level presence testing, BSCOUT ﬁrst proposes cross-
layer line-level correlative analysis. With this, it collects
language-independent features from both source code lines
and bytecode instructions. Then, it utilizes feature-based line-
level similarity analysis to link one source code line to several
aggregated bytecode instructions (marked as a bytecode line).
For bytecode instruction aggregation, BSCOUT leverages
the line number information in the target executable when
it is present. Otherwise, BSCOUT adopts learning-based
instruction segmentation to infer the bytecode line boundary.
To reliably test the presence of some patch-changed lines that
occur multiple times in the target executable, BSCOUT also
performs the line-level correlative analysis on the basis of
the entire functions. Following the line-level presence test,
BSCOUT further proposes patch-derived differential analysis.
With this, BSCOUT categorizes patch-changed lines into three
types (addition/deletion/modiﬁcation). Then, it utilizes both
pre-patch source code (i.e. the source code before applying
the patch) and post-patch source code (i.e. the source code
after applying the patch) to accurately test the presence of
each type of changes in the target executable.
Results. We evaluate BSCOUT with 194 CVEs pertaining
to the Android framework and third-party Java libraries. The
experiments are performed on 15 Android system images
(called ROMs for short in the following), 261 Android apps,
and 28 desktop/server apps. Our experiment results show that
BSCOUT achieves remarkable accuracy of 100% and 96.9%
with and without the line number information provided. We
also observed that, when applied in a patch presence test,
existing work exhibits poor performance in terms of accuracy
and coverage.
Given the popularity of the Android platform and its
severe fragmentation issues [1], we also apply BSCOUT
to study the patch application practice with 2,506 real-
world Android ROMs from 7 vendors. Through our study,
we have some important ﬁndings that have not yet been
veriﬁed before. First, we discover Google usually patches
its own devices in a proactive manner even before releasing
the vulnerabilities to the public, while other vendors apply
security patches relatively slowly. Second, we ﬁnd that,
rather than vulnerability severity or patch complexity, code
customization signiﬁcantly affects the adoption of a security
patch. Third, we observe that all vendors have forgotten to
apply patches to affected phone models. This implies it is a
challenging task to manage patches among multiple software
product lines. Last but not least, we surprisingly ﬁnd that, to
some extent, all vendors (including Google) over-claim the
security patch level in their devices. There are only about
9.4% of the ROMs correctly set the security patch level.
Use cases. Potential users of BSCOUT at least include:
1) since commercialized products (usually closed-source)
may inherit vulnerabilities reported in the integrated open-
source projects, third-party users of these products (e.g.
government agents, enterprise users, security companies) are
greatly interested in knowing the patching status of these
vulnerabilities; 2) developers or security testers who may
even have source code access, but may still want to perform
additional checks to guarantee that they have patched all n-
1148    29th USENIX Security Symposium
USENIX Association
day vulnerabilities for their products before releasing them to
the public. For all these users, BScout is very helpful for its
ability to assess the patching status of products without their
source code.
In summary, we make the following contributions.
• We propose BSCOUT, a new technique to examine the
presence of a patch for Java executables.
• Using real-world test cases, we conduct a thorough
analysis and show that BSCOUT is effective and efﬁcient
in patch presence test.
• Using BSCOUT as a tool, we conduct a large-scale
study and shed light on patch application practice in
the real world. Our study reveals several important and
interesting ﬁndings that have not yet been uncovered.
2 Challenges and Insights
We pick the security patch for CVE-2016-3832 [14] (an An-
droid framework vulnerability) as an example to demonstrate
the challenges in patch presence test and our insights to solve
these challenges. Generally, there are two kinds of bytecode
formats for Java executables: traditional stack-based Java
bytecode [9] and DEX bytecode [6]. Since DEX bytecode is
more comprehensible, we transform Java executables to DEX
bytecode with dx [3]. Figure 1 shows a patch snippet with
related code snippets from two Java executables. In Figure 1,
smali (which is the assembly language for DEX) is used to
present DEX instructions.
At ﬁrst, we can ﬁnd that the patch snippet in Figure 1
contains 3 addition lines (line 7, 13-14) and 1 deletion line
(line 12). Line 13-14 in Figure 1(a) are actually two broken
lines of a single statement, thus we use line 13 to refer both of
them in the following. As reported by Li et al. [31], security
patches tend to introduce fewer changes to source code than
general bug ﬁxes (marked as Challenge-I: patch is small).
Thus, to reliably check the patch presence, we need to consider
all meaningful patch changes. Speciﬁcally, we need to check
that whether corresponding bytecode instructions could be
found in the target for every patch-changed line.
However, since Java source code and smali instructions
are expressed in different languages, it is not straightforward
to judge whether a statement in source code is equivalent
to several smali instructions or not (marked as Challenge-II:
cross-language-layer test). Fortunately, we observe that Java
bytecode contains much semantic information. Based on
this observation, we try to infer the equivalence between a
Java statement and several smali instructions based on their
shared semantic features. For example, line 7 in the patch
snippet is a function invocation statement that invokes the
“android.os.Parcel.readInt()” method and saves the function
return value to a temporary variable named “userId”. For this
statement, we can use the name of the invoked method as a
Figure 1: Patch Snippet for CVE-2016-3832 with code
snippets from two target Java executables.
feature to locate corresponding smali instructions in the test
target. The name of the assigned variable is not used here,
because it is a temporary variable whose name is not kept
after compilation. Through this feature, we can ﬁnd line 1585
and line 1587 in the ﬁrst target, and line 1584 in the second
target can link to line 7 in the patch snippet. Similarly, we
can also ﬁnd all candidate smali instructions in the test target
for each patch-changed line with feature-based line-to-line
similarity analysis.
Based on the line-to-line link between patch lines and
target bytecode instructions, we shall further judge whether
the patch is present or not. For line 7 in the patch snippet, we
ﬁnd 2 linked lines in the ﬁrst target and 1 linked line in the
second target. Since line 7 is an addition line in this patch,
we may simply mark both targets as patched at this time.
However, we may also ﬁnd that line 5 in the patch snippet
(just as the same as line 7) can also link to line 1585 and
line 1587 in the ﬁrst target and line 1584 in the second target,
while line 5 exists before the patch is applied. When we take
both line 5 and line 7 in the patch snippet into account, we
ﬁnd that both of them have a linked line in the ﬁrst target,
while only one of them can have a linked line in the second
target (marked as Challenge-III: patch-changed lines may
occur multiple times). Based on this observation, it is easy to
recognize the second target as unpatched and the ﬁrst target as
patched. The lessons we learn here are that, if patch-changed
USENIX Association
29th USENIX Security Symposium    1149
01@@ -1582,9 +1582,10 @@    02   data.enforceInterface(IActivityManager.descriptor);03   ...04   ...05   int backupRestoreMode = data.readInt();06   ...07+  int userId = data.readInt();08   ...09   reply.writeNoException();1011@@ -2235,7 +2235,8 @@ 12-  if (mActivityManager.bindBackupAgent(app, mode)) {13+  if (mActivityManager.bindBackupAgent(app.packageName, mode,14+     UserHandle.USER_OWNER)) {.line 1585invoke-virtual/range {p2 .. p2}, Landroid/os/Parcel;->readInt()Imove-result v12 ....line 1587invoke-virtual/range {p2 .. p2}, Landroid/os/Parcel;->readInt()Imove-result v13 ....line 2238:try_start_ciget-object v6, p0, L..ActivityManagerService;->mActivityManager:L..IActivityManager;iget-object v7, p1, L..ApplicationInfo;->packageName:Ljava/lang/String;const/4 v8, 0x0invoke-interface {v6, v7, p2, v8}, L..IActivityManager;->bindBackupAgent(L..String;II)Zmove-result v6if-eqz v6, :cond_b1.line 1584invoke-virtual/range {p2 .. p2}, Landroid/os/Parcel;->readInt()Imove-result v12 ....line 2238:try_start_ciget-object v6, p0, L..ActivityManagerService;->mActivityManager:L..IActivityManager;invoke-interface {v6, p1, p2}, L..IActivityManager;->bindBackupAgent(L..ApplicationInfo;I)Zmove-result v6if-eqz v6, :cond_b1(a) Patch Snippet for CVE-2016-3832(c) Smali Snippet in Target_2(b) Smali Snippet in Target_1lines occur multiple times in the source code, it is hard to use
the patch alone to give a reliable patch presence test result.
For patch-added lines (such as line 7), we had better utilize
the whole post-patch method for the test.
For line 12 and line 13 in the patch snippet, we ﬁnd that they
are quite similar for sharing the same feature of invoking the
“android.app.IActivityManager.bindBackupAgent()” method.
After line-to-line similarity analysis, both of them are linked
to line 2238 in the ﬁrst target and are linked to line 2238 in
the second target. Because line 12 is a deletion line and line
13 is an addition line, from the perspective of line 12 we may
ﬂag both targets as unpatched, but from the perspective of line
13, we should ﬂag both targets as patched. This contradictory
result is caused by the fact that we do not recognize line 13 as
a modiﬁcation line on top of line 12 (marked as Challenge-IV:
patch has different types of changes). By performing a ﬁne-
grained analysis on line 12 and line 13, we can ﬁnd that line
13 invokes the method with three arguments, while line 12
invokes the method with two arguments. Considering this
slight difference, we ﬁnd line 2238 in the ﬁrst target is more
similar to line 13 than line 12 in the patch, while line 2238 in
the second target is more similar to line 12 than line 13 in the
patch.
Based on the checking results from line 7, line 12 and line
13, we meet a uniﬁed judgment: the executable in Figure 1(b)
applies the patch, while the executable in Figure 1(c) does
not apply the patch. Note that in the above example, we use
the line number information in smali ﬁles to represent several
smali instructions for brevity, which does not necessarily
mean our tool depends on this information.
3 BSCOUT Approach
Following the example in §2, the overall architecture of
BSCOUT is shaped in Figure 2, which consists of two steps:
Step 1: Cross-layer Line-level Correlative Analysis. Ba-