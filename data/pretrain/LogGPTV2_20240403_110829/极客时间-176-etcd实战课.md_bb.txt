# 22 \| 配置及服务发现：解析etcd在API Gateway开源项目中应用你好，我是唐聪。在软件开发的过程中，为了提升代码的灵活性和开发效率，我们大量使用配置去控制程序的运行行为。从简单的数据库账号密码配置，到confd支持以 etcd为后端存储的本地配置及模板管理，再到Apache APISIX等 API Gateway 项目使用 etcd存储服务配置、路由信息等，最后到 Kubernetes 更实现了 Secret 和 ConfigMap资源对象来解决配置管理的问题。那么它们是如何实现实时、动态调整服务配置而不需要重启相关服务的呢？今天我就和你聊聊 etcd 在配置和服务发现场景中的应用。我将以开源项目Apache APISIX 为例，为你分析服务发现的原理，带你了解 etcd 的 key-value模型，Watch 机制，鉴权机制，Lease特性，事务特性在其中的应用。希望通过这节课，让你了解 etcd在配置系统和服务发现场景工作原理，帮助你选型适合业务场景的配置系统、服务发现组件。同时，在使用Apache APISIX 等开源项目过程中遇到 etcd相关问题时，你能独立排查、分析，并向社区提交 issue 和 PR解决。 服务发现首先和你聊聊服务发现，服务发现是指什么？为什么需要它呢?为了搞懂这个问题，我首先和你分享下程序部署架构的演进。单体架构在早期软件开发时使用的是单体架构，也就是所有功能耦合在同一个项目中，统一构建、测试、发布。单体架构在项目刚启动的时候，架构简单、开发效率高，比较容易部署、测试。但是随着项目不断增大，它具有若干缺点，比如：1.  所有功能耦合在同一个项目中，修复一个小 Bug    就需要发布整个大工程项目，增大引入问题风险。同时随着开发人员增多、单体项目的代码增长、各模块堆砌在一起、代码质量参差不齐，内部复杂度会越来越高，可维护性差。        2.  无法按需针对仅出现瓶颈的功能模块进行弹性扩容，只能作为一个整体继续扩展，因此扩展性较差。        3.  一旦单体应用宕机，将导致所有服务不可用，因此可用性较差。        分布式及微服务架构如何解决以上痛点呢？当然是将单体应用进行拆分，大而化小。如何拆分呢？这里我就以一个我曾经参与重构建设的电商系统为案例给你分析一下。在一个单体架构中，完整的电商系统应包括如下模块：1.  商城系统，负责用户登录、查看及搜索商品、购物车商品管理、优惠券管理、订单管理、支付等功能。        2.  物流及仓储系统，根据用户订单，进行发货、退货、换货等一系列仓储、物流管理。        3.  其他客服系统、客户管理系统等。        因此在分布式架构中，你可以按整体功能，将单体应用垂直拆分成以上三大功能模块，各个功能模块可以选择不同的技术栈实现，按需弹性扩缩容，如下图所示。![](Images/011b943d2d5dd6dbfc7426a8dcd77a1c.png)savepage-src="https://static001.geekbang.org/resource/image/ca/20/ca6090e229dde9a0361d6yy2c3df8d20.png"}那什么又是微服务架构呢？它是对各个功能模块进行更细立度的拆分，比如商城系统模块可以拆分成：1.  用户鉴权模块；        2.  商品模块；        3.  购物车模块；        4.  优惠券模块；        5.  支付模块；        6.  ......        在微服务架构中，每个模块职责更单一、独立部署、开发迭代快，如下图所示。![](Images/66fbf5a6b286fb7347c79605a5dca30c.png)savepage-src="https://static001.geekbang.org/resource/image/cf/4a/cf62b7704446c05d8747b4672b5fb74a.png"}那么在分布式及微服务架构中，各个模块之间如何及时知道对方网络地址与端口、协议，进行接口调用呢？为什么需要服务发现中间件?其实这个知道的过程，就是服务发现。在早期的时候我们往往通过硬编码、配置文件声明各个依赖模块的网络地址、端口，然而这种方式在分布式及微服务架构中，其运维效率、服务可用性是远远不够的。那么我们能否实现通过一个特殊服务就查询到各个服务的后端部署地址呢？各服务启动的时候，就自动将 IP 和Port、协议等信息注册到特殊服务上，当某服务出现异常的时候，特殊服务就自动删除异常实例信息？是的，当然可以，这个特殊服务就是注册中心服务，你可以基于etcd、ZooKeeper、consul等实现。 etcd 服务发现原理那么如何基于 etcd实现服务发现呢?下面我给出了一个通用的服务发现原理架构图，通过此图，为你介绍下服务发现的基本原理。详细如下：1.  整体上分为四层，client 层、proxy 层 (可选)、业务 server、etcd    存储层组成。引入 proxy 层的原因是使 client    更轻、逻辑更简单，无需直接访问存储层，同时可通过 proxy    层支持各种协议。        2.  client 层通过负载均衡访问 proxy 组件。proxy 组件启动的时候，通过    etcd 的 Range RPC 方法从 etcd 读取初始化服务配置数据，随后通过 Watch    接口持续监听后端业务 server    扩缩容变化，实时修改路由。        3.  proxy 组件收到 client 的请求后，它根据从 etcd    读取到的对应服务的路由配置、负载均衡算法（比如    Round-robin）转发到对应的业务    server。        4.  业务 server 启动的时候，通过 etcd 的写接口 Txn/Put    等，注册自身地址信息、协议到高可用的 etcd 集群上。业务 server    缩容、故障时，对应的 key 应能自动从 etcd 集群删除，因此相关 key    需要关联 lease 信息，设置一个合理的 TTL，并定时发送 keepalive 请求给    Leader 续租，以防止租约及 key    被淘汰。        ![](Images/420ef32257832ffae004374018d67bca.png)savepage-src="https://static001.geekbang.org/resource/image/26/e4/26d0d18c0725de278eeb7505f20642e4.png"}当然，在分布式及微服务架构中，我们面对的问题不仅仅是服务发现，还包括如下痛点：1.  限速；        2.  鉴权；        3.  安全；        4.  日志；        5.  监控；        6.  丰富的发布策略；        7.  链路追踪；        8.  \...\...        为了解决以上痛点，各大公司及社区开发者推出了大量的开源项目。这里我就以国内开发者广泛使用的Apache APISIX 项目为例，为你分析 etcd在其中的应用，了解下它是怎么玩转服务发现的。Apache APISIX 原理Apache APISIX它具备哪些功能呢？它的本质是一个无状态、高性能、实时、动态、可水平扩展的 API网关。核心原理就是基于你配置的服务信息、路由规则等信息，将收到的请求通过一系列规则后，正确转发给后端的服务。Apache APISIX 其实就是上面服务发现原理架构图中的 proxy组件，如下图红色虚线框所示。![](Images/34477449b6edbf143eb7f8ae7c8590b2.png)savepage-src="https://static001.geekbang.org/resource/image/20/fd/20a539bdd37db2d4632c7b0c5f4119fd.png"}Apache APISIX详细架构图如下（引用自社区项目文档slate-object="inline"）。从图中你可以看到，它由控制面和数据面组成。控制面顾名思义，就是你通过 Admin API下发服务、路由、安全配置的操作。控制面默认的服务发现存储是etcd，当然也支持 consul、nacos等。 你如果没有使用过 Apache APISIX的话，可以参考下这个example，快速、直观的了解下 Apache APISIX是如何通过 Admin API下发服务和路由配置的。数据面是在实现基于服务路由信息数据转发的基础上，提供了限速、鉴权、安全、日志等一系列功能，也就是解决了我们上面提的分布式及微服务架构中的典型痛点。![](Images/42b2b3149cd90a98f09ca07b12438969.png)savepage-src="https://static001.geekbang.org/resource/image/83/f4/834502c6ed7e59fe0b4643c11b2d31f4.png"}那么当我们通过控制面 API 新增一个服务时，Apache APISIX是是如何实现实时、动态调整服务配置，而不需要重启网关服务的呢？下面，我就和你聊聊 etcd 在 Apache APISIX项目中的应用。etcd 在 Apache APISIX 中的应用在搞懂这个问题之前，我们先看看 Apache APISIX 在 etcd中，都存储了哪些数据呢？它的数据存储格式是怎样的？数据存储格式下面我参考 Apache APISIX 的example案例（apisix:2.3），通过 Admin API新增了两个服务、路由规则后，执行如下查看 etcd 所有 key的命令：     etcdctl get "" --prefix --keys-onlyetcd 输出结果如下：    /apisix/consumers/    /apisix/data_plane/server_info/f7285805-73e9-4ce4-acc6-a38d619afdc3    /apisix/global_rules/    /apisix/node_status/    /apisix/plugin_metadata/    /apisix/plugins    /apisix/plugins/    /apisix/proto/    /apisix/routes/    /apisix/routes/12    /apisix/routes/22    /apisix/services/    /apisix/services/1    /apisix/services/2    /apisix/ssl/    /apisix/ssl/1    /apisix/ssl/2    /apisix/stream_routes/    /apisix/upstreams/然后我们继续通过 etcdctl get 命令查看下 services都存储了哪些信息呢？    root@e9d3b477ca1f:/opt/bitnami/etcd