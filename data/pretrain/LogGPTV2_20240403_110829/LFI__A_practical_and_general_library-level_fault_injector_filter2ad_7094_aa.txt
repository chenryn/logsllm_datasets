**Title: LFI: A Practical and General Library-Level Fault Injector**

**Authors:**  
Paul Dan Marinescu and George Candea  
School of Computer and Communication Sciences, EPFL, Lausanne, Switzerland

**Abstract:**
Fault injection is a critical aspect of testing robust systems but is often overlooked in the development of general-purpose software. This oversight is largely due to the lack of easy-to-use tools and the extensive manual labor required for fault injection tests. This paper introduces LFI (Library Fault Injector), a tool that automates the preparation of fault scenarios and their injection at the boundary between shared libraries and applications. LFI extends prior work by automatically profiling fault behaviors of libraries through static analysis of their binaries, thereby reducing the dependence on human labor and perfect documentation. We present techniques for automatically generating injection scenarios and describe a simple language for expressing such scenarios. LFI does not require access to the source code of libraries and works for Linux, Windows, and Solaris on x86 and SPARC platforms.

**1. Introduction**
General-purpose applications heavily rely on shared libraries. For example, the MySQL database server directly links to 13 shared libraries, the Apache web server can link to more than 30 shared libraries depending on compile options, and Adobe Photoshop directly links to 36 shared libraries. If we count recursively the shared libraries used by these libraries themselves, the numbers are as high as 138 in the case of Adobe Photoshop. These applications make important assumptions about how the underlying libraries function, and any guarantees they try to provide to users depend heavily on the correctness of these assumptions.

For software expected to be highly dependable, such as database servers, web servers, and email clients, testing must verify that the ways in which applications use these libraries are consistent with the actual library behavior. Specifically, it is essential to verify that applications correctly handle faults at or below the library layer, which manifest as errors returned by library functions. Unfortunately, corner cases are easy to miss and can lead to crashes or correctness violations, such as when the result of a memory allocation is not checked, or when a `read()` call is not retried after getting an `EINTR` return code. These bugs are hard to find through input testing because they are triggered by low-probability events that are typically input-independent and occur below the library layer.

To test program robustness, we wish to simulate such error events at the program/library interface and then observe the program's reaction. Ideally, the simulation should be minimally invasive and should not require access to proprietary portions (e.g., source code) of the program or library. The challenge, however, is that regular systems have an overwhelming number of libraries: a typical Linux system has around 1000 libraries, Windows XP has around 1400, and Windows Vista has around 1650. To our knowledge, current library fault injectors require considerable amounts of manual work and are restricted to the C standard library (libc), thus not scaling to test all libraries used by programs.

Library fault injection must therefore be generalized and automated to the utmost, or else the scope of testing will have to remain narrow. Not only is it necessary to automate the injection of faults, but also the inference of the libraries' fault profiles. Libraries can change frequently; for example, GNU libc, perhaps the most widely used shared library, has already seen two releases in the first three months of this year [8]. By using shared libraries, applications accept that these libraries may change underneath them; yet, can they suitably cope? Frequent changes can introduce unexpected new behavior, much of which may not even be documented. While many libraries aim for backward compatibility, even GNU libc has not always guaranteed it. Relying on documentation to decide how a library may expose faults is risky: even if the documentation exists and is correct for one library version, it can get out of sync with the next one. As we show in ยง3.1, library documentation can be incomplete and miss some of the error return codes. We must therefore extract information on potential errors directly from the libraries; since source code is often not available, the library binaries themselves must be analyzed.

---

This optimized version maintains the original content while improving readability, flow, and professional tone.