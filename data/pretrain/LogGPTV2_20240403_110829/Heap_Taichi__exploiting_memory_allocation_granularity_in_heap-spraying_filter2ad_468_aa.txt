title:Heap Taichi: exploiting memory allocation granularity in heap-spraying
attacks
author:Yu Ding and
Tao Wei and
Tielei Wang and
Zhenkai Liang and
Wei Zou
Heap Taichi: Exploiting Memory Allocation Granularity in
Heap-Spraying Attacks
Yu Ding1,2, Tao Wei1,2∗, TieLei Wang1,2, Zhenkai Liang3, Wei Zou1,2,
1Institute of Computer Science and Technology, Peking University
2Key Laboratory of Network and Software Security Assurance(Peking University),
Ministry of Education, Beijing 100871, China
3Department of Computer Science, School of Computing, National University of Singapore
ABSTRACT
Heap spraying is an attack technique commonly used in hijacking
browsers to download and execute malicious code. In this attack,
attackers ﬁrst ﬁll a large portion of the victim process’s heap with
malicious code. Then they exploit a vulnerability to redirect the
victim process’s control to attackers’ code on the heap. Because the
location of the injected code is not exactly predictable, traditional
heap-spraying attacks need to inject a huge amount of executable
code to increase the chance of success. Injected executable code
usually includes lots of NOP-like instructions leading to attackers’
shellcode. Targeting this attack characteristic, previous solutions
detect heap-spraying attacks by searching for the existence of such
large amount of NOP sled and other shellcode.
In this paper, we analyze the implication of modern operating
systems’ memory allocation granularity and present Heap Taichi, a
new heap spraying technique exploiting the weakness in memory
alignment. We describe four new heap object structures that can
evade existing detection tools, as well as proof-of-concept heap-
spraying code implementing our technique. Our research reveals
that a large amount of NOP sleds is not necessary for a reliable
heap-spraying attack. In our experiments, we showed that our heap-
spraying attacks are a realistic threat by evading existing detection
mechanisms. To detect and prevent the new heap-spraying attacks,
we propose enhancement to existing approaches and propose to use
ﬁner memory allocation granularity at memory managers of all lev-
els. We also studied the impact of our solution on system perfor-
mance.
1.
INTRODUCTION
Heap spraying is a new attack technique commonly used in re-
cent attacks to web browsers [4–8, 36]. In a heap-spraying attack,
attackers allocate objects containing their malicious code in the vic-
tim process’s heap, and then trigger a vulnerability to force the
victim process to execute code from the heap region. Compared
to traditional buffer overﬂow attacks, heap spraying is simpler, as
∗Corresponding author. Email: PI:EMAIL
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ACSAC ’10 Dec. 6-10, 2010, Austin, Texas USA
Copyright 2010 ACM 978-1-4503-0133-6/10/12 ...$10.00.
there is no need to know the detailed layout of memory regions
surrounding the buffer vulnerable to overﬂow, but the heap object
locations are not predictable. In order to increase the chance of suc-
cess, existing heap-spraying techniques allocate lots of heap blocks
ﬁlled with a large amount NOP-like instructions (e.g. 0x90, 0x0c
0x0a), called NOP sled, and followed by the malicious shellcode.
The NOP sled serves as the landing area of the shellcode, which
leads the execution to the shellcode if the victim process jumps to
anywhere in the NOP sled.
Since a typical heap object used in a heap-spraying attack is in
the form of “NOP sled + shellcode," the large amount of NOP sled
and existence of shellcode are the main characters used by heap-
spraying attack detectors. Accordingly, existing approaches to de-
tect heap-spraying attacks mainly fall into two types: sled-oriented
and shellcode-oriented. Shellcode-oriented methods detect heap-
spraying attacks by detecting the existence of shellcode. For ex-
ample, Egele et al. [21] detect heap-spraying attacks by inspecting
the JavaScript string objects to identify shellcode using lightweight
emulation [9]. However, this type of approach have difﬁculty in
dealing with shellcode obfuscation techniques, such as, shellcode
encoding [28, 34], encryption [46], polymorphism [20, 24], and
other obfuscation schemes [17, 27, 31, 37].
A more successful type of techniques to detect heap-spraying at-
tacks are sled-oriented [11, 29, 32, 42]. Such techniques focus on
identifying large chunks of NOP sled. In particular, NOZZLE [32]
uses static analysis to build the control-ﬂow graph (CFG) of heap
memory blocks and measures the size of NOP sled, called surface
area, across a process’s entire heap region. If the percentage of
surface area is above a certain threshold, NOZZLE reports an at-
tack. NOZZLE assumes that heap-spraying attacks must inject a
large number of executable codes (especially NOP sled) because
attackers cannot predict the location of their malicious code. Next,
we will show that this assumption is not always valid.
We observe that modern operating system memory allocation be-
havior is more predictable than we usually believe, even in the pres-
ence of address space layout randomization (ASLR). For instance,
the Windows-family systems (from Windows XP to Windows 7)
enforce a memory allocation granularity of 64K bytes [22, 33],
which makes all memory blocks directly allocated by Windows (us-
ing API VirtualAlloc) aligned to a 64K-byte boundary. As a
result, addresses of such heap blocks are less random. For example,
a particular address in a 1MB block only has 16 possible locations,
much less than the one million possible locations if the heap block
can be allocated at random addresses. We discuss this in detail in
Section 3.
A new attack. Based on the above analysis, we present a new
heap-spraying technique, called Heap Taichi, which can evade ex-
isting detection mechanisms. By precisely manipulating the heap
layout, Heap Taichi only needs to put executable code at a small
number of offsets in a heap block, and thus makes the “large of
NOP sled” feature in traditional heap-spraying attacks unnecessary.
To demonstrate the feasibility of Heap Taichi, we made proof-of-
concept heap-spraying attacks using Heap Taichi. Our experiments
showed that the surface area of a Heap Taichi attack is signiﬁcantly
less than the acceptable threshold used in existing solutions. We
also studied the impact of different memory-allocation granularity
on heap-spraying attacks and system performance, and found that
larger memory allocation granularity gives attackers more ﬂexibil-
ity without signiﬁcant gain in performance.
To address this problem, we proposed methods to enhance exist-
ing heap-spraying attack detection techniques by considering mem-
ory allocation granularity, and experimented with new ways of mem-
ory allocation.
Contributions:
• We analyze the implication of modern operating systems’
memory allocation granularity on heap-spraying attacks, and
present a new heap-spraying technique utilizing the weak-
ness of memory alignments, which can effectively evade ex-
isting detection tools.
• We present four heap object structures that do not require a
large amount of NOP sled. We provide insight into the rela-
tionship between memory alignment size and heap-spraying
attack surface areas.
• We implement proof-of-concept Heap Taichi, and measure
the attack surface areas of these attacks. Experiments showed
that our heap-spraying attacks are a realistic threat, which
can evade existing detection tools.
2. HEAP SPRAYING AND DEFENSE
In this section, we describe a typical heap-spraying attack, and
discuss existing defense mechanisms.
2.1 Heap-spraying attacks
Throughout the paper, we use the term heap region to refer to
all the memory areas of a process’s heap. We use the term heap
block to refer to the memory block allocated for heap, e.g., the
blocks allocated by Windows’s memory management through the
VirtualAlloc family APIs. We call individual objects allo-
cated on the heap heap objects, e.g., objects allocated by the API
HeapAlloc. Therefore, a heap region consists of several heap
blocks, and a heap block contains one or more heap objects.
Figure 1 illustrates a typical heap-spraying attack found by our
web crawler. The attack is launched by malicious JavaScript in a
web page, targeting a vulnerability in the Internet Explorer version
6 or version 7 [18]. In the ﬁrst step of this attack, attackers cre-
ate a large amount of heap objects. Each heap object is ﬁlled with
a large number of NOP-like instructions (0x0c0c, the instruction
or al, 0ch) followed by a block of malicious shellcode. Illus-
trated in the right-hand side of Figure 1, the large white areas are
the NOP-like instructions, while the grey areas are the shellcode. If
attackers can hijack the process’s execution to any byte in the range
of NOP-like instructions, the malicious shellcode will be executed.
Although attackers cannot know the exact address of the injected
code, when the browser process’s heap region is very large, certain
Figure 1: The traditional heap spraying with stack buffer over-
ﬂow exploit.
range of address, such as 0x0c0c0c0c, will be in the region of
allocated heap objects, as is illustrated in Figure 1.
After the heap is prepared with malicious shellcode, the second
step of this attack is to exploit a vulnerability in the victim pro-
cess, forcing the victim process to transfer control to the sprayed
heap region. Any vulnerability that can be exploited to affect the
control ﬂow can be used in this step. Here we show an example
using a stack-based buffer overﬂow vulnerability, illustrated in the
left-hand side of Figure 1. By exploiting the buffer overﬂow vul-
nerability, attackers inject lots of 0x0c characters onto the stack,
overwriting the return address. When the program returns using the
corrupted return address, its execution is redirected to the address
0x0c0c0c0c, which is in the NOP sled of a sprayed heap object.
The victim program will continue through the NOP sled and reach
attackers’ shellcode.
Thanks to the defense mechanisms against buffer overﬂow at-
tacks, it is very hard for attackers to know the exact address of their
shellcode. Therefore, they cannot use the stack overﬂow to ex-
ecute their shellcode directly.
In contrast, heap-spraying attacks
do not require attackers to know the detailed layout of the data
structures of the targeted memory region. But the object addresses
on the heap are harder to predict, even with the deployment of
ASLR [22, 33, 40, 44]. To increase the chance of success in the
second step of the attack, attackers usually put a long NOP sled
before the shellcode in their heap objects, and they have to inject
a large amount of heap objects containing shellcode, so that the
jump target of the attack will be covered by injected code with a
high probability. Otherwise, if the victim process jumps into the
middle of shellcode, or even jumps out of the heap region sprayed
by the attacker, the victim process often crashes because of invalid
memory access or invalid instructions.
In the rest of the paper, we use the following terms to describe the
behavior of a heap-spraying attack. 1) We call the execution after
the exploit and before running the shellcode a landing action. In
traditional heap-spraying attacks, the landing action usually runs
on the huge sled area, byte by byte. The traditional sled is ﬁlled
with NOP like bytes, such as 0x90 (NOP), 0x0c0c (or al, 0ch)
and these bytes lead to smooth landing actions. On the contrary,
landing actions executing some jump instructions, such as jmp,
are called bumpy landing. 2) The place where the landing action
starts is called landing position, or landing point. 3) The notion of
surface area is deﬁned in the NOZZLE paper [32] as the number of
available landing positions in one heap object. 4) The normalized
attack surface area (NSA) is a heap object’s surface area divided by
the heap object’s size. The normalized attack surface area repre-
sents the percentage of sled in a memory block. It also represents
the possibility of successfully executing the shellcode when execu-
sprayed heap area  Sled0x0c0c : or al, 0ch0x0c0c : or al, 0ch0x0c0c : or al, 0ch0x0c0c : or al, 0chshellcode 0x0c0c00000x0bfc00000x0bec00000x0c0c0c0c0x0c0c0c0c0x0c0c0c0c0x0c0c0c0c…………Stack area……return addressretshellcode shellcode Shellcodeentry Landing actionLanding position:0x0c0c0c0cstack buffer overflowtion randomly falls into a heap object. 5) The shellcode entry is the
starting point of the shellcode.
2.2 Existing defense mechanisms
systems such as Linux have a similar memory allocation behavior
to Windows, which differs mainly in the default memory alignment
size.
Existing defense mechanisms against heap-spraying attacks can
be classiﬁed into two main types based on the analysis they perform
on heap objects. Approaches of the ﬁrst type detect shellcode by
searching for common patterns of shellcode. Approaches of the
second type analyze the control ﬂow structure of heap objects to
identify common structures used in heap-spraying attacks.
Egele et al. [21] is an example of the ﬁrst type. It monitors all
strings objects allocated in a browser’s JavaScript engine, and re-
ports an attack when there is shellcode detected in string objects
created by the script. To detect shellcode, it uses the libemu library
to identify suspicious and valid instruction sequences longer than
32 bytes. As is discussed in the paper [21], attackers can evade
detection by breaking shellcode into multiple fragments smaller
than 32 bytes and linking them with indirect jump/call instructions.
However, unless attackers can precisely control the landing posi-
tion, they still need a large portion of NOP sled to make a reliable
attack, which is well over the 32 byte threshold.
NOZZLE [32] is an example of the second type. Given a heap
object, it disassembles possible x86 instructions in the object and
build a control ﬂow graph (CFG). As we have described earlier in
this section, the heap block used in a typical heap-spraying attack
contains a block of shellcode, and the rest of the heap block con-
tains instructions leading to the shellcode. NOZZLE searches for
this property in the CFG by identifying the location S that can be
reaching from most of other locations in the heap object. The to-
tal number of locations that lead to S is the surface area of the
heap object. In other words, NOZZLE draws the CFG of the heap
block. For each basic block in the CFG, it counts the number of
instructions that connect to the basic block. NOZZLE then calcu-
lates the surface area of the entire heap. When the surface-area-to-
heap-size ratio is greater than a threshold, NOZZLE reports a heap-
spraying attack. This approach is more accurate than the ﬁrst type
approaches, because it looks for more intrinsic properties of heap-
spraying attacks: when the location of shellcode is not predictable,
it is necessary to include large surface areas to increase the chance
for success.
Both types of existing solutions assume attackers have little in-
formation about the address of their shellcode. With this assump-
tion, attackers cannot break sled and shellcode into small pieces to
evade the approach of Egele et al.; they also cannot evade NOZZLE
by only including very little NOP sled instructions. This assump-
tion is valid if heap objects are allocated randomly without restric-
tion. However, the randomness of heap object allocation is limited
by memory alignment enforced in operating systems. Next, we dis-
cuss its impact on heap memory allocation and describe an attack
that can evade both types of defense mechanisms.
3. HEAP SPRAYING WITH LITTLE SUR-