之类的赋值操作是一个表达式，并且具有一个值，即赋值后左边变量保存的值。也就是说， 赋值可以作为更大的表达式的一部分出现。如果将为 c 赋值的操作放在 while 循环语句的测 试部分中，上述字符复制程序便可以改写成下列形式:
/* copy input to output; 2nd version              */ main()
{
int c;
while ((c = getchar()) != EOF) putchar(c);
}
在该程序中，while 循环语句首先读一个字符并将其赋值给 c，然后测试该字符是否为文件 结束标志。如果该字符不是文件结束标志，则执行 while 语句体，并打印该字符。随后重复 执行 while 语句。当到达输入的结尾位置时，while 循环语句终止执行，从而整个 main 函 数执行结束。
以上这段程序将输入集中化，getchar 函数在程序中只出现了一次，这样就缩短了程序， 整个程序看起来更紧凑。习惯这种风格后，读者就会发现按照这种方式编写的程序更易阅读。 我们经常会看到这种风格。(不过，如果我们过多地使用这种类型的复杂语句，编写的程序可 能会很难理解，应尽量避免这种情况。)
对 while 语句的条件部分来说，赋值表达式两边的圆括号不能省略。不等于运算符!=的 优先级比赋值运算符=的优先级要高，这样，在不使用圆括号的情况下关系测试!=将在赋值= 操作之前执行。因此语句
c = getchar() != EOF
等价于语句
c = (getchar() != EOF)
该语句执行后，c 的值将被置为 0 或 1(取决于调用 getchar 函数时是否碰到文件结束标志)， 这并不是我们所希望的结果(更详细的内容，请参见第 2  章的相关部分)。
练习 1•6             验证表达式 getchar() != EOF 的值是 0 还是 1。 练习 1•7             编写一个打印 EOF 值的程序。
1.5.2.                  字符计数
下列程序用于对字符进行计数，它与上面的复制程序类似。
#include 
/* count characters in input; 1st version */ main()
{
long nc;
nc = 0;
while (getchar() != EOF)
++nc; printf("%ld\n", nc);
}
其中，语句
++nc;
引入了一个新的运算符++，其功能是执行加 1 操作。可以用语句 nc = nc + 1 代替它，但 语句++nc 更精炼一些，且通常效率也更高。与该运算符相应的是自减运算符••。++与••这 两个运算符既可以作为前缀运算符(如++nc)，也可以作为后缀运算符(如       nc++)。我们在 第 2 章中将看到，这两种形式在表达式中具有不同的值，但++nc 与 nc++都使 nc 的值增加 1。 目前，我们只使用前缀形式。
该字符计数程序使用 long 类型的变量存放计数值，而没有使用 int 类型的变量。long 整型数(长整型)至少要占用 32 位存储单元。在某些机器上 int 与 long 类型的长度相同， 但在一些机器上，int 类型的值可能只有 16 位存储单元的长度(最大值为 32767)，这样，相 当小的输入都可能使 int 类型的计数变量溢出。转换说明%ld 告诉 printf 函数其对应的参 数是 long 整型。
使用 double(双精度浮点数)类型可以处理更大的数字。我们在这里不使用 while 循 环语句，而用 for 循环语句来展示编写此循环的另一种方法:
#include 
/* count characters in input; 2nd version */ main()
{
double nc;
for (nc = 0; gechar() != EOF; ++nc)
;
printf("%.0f\n", nc);
}
对于 float 与 double 类型。printf 函数都使用%f 进行说明。%.0f 强制不打印小数点和 小数部分，因此小数部分的位数为 0。
在该程序段中，for 循环语句的循环体是空的，这是因为所有工作都在测试(条件)部 分与增加步长部分完成了。但 C 语言的语法规则要求 for 循环语句必须有一个循环体，因此 用单独的分号代替。单独的分号称为空语句，它正好能满足 for 语句的这一要求。把它单独 放在一行是为了更加醒目。
在结束讨论字符计数程序之前，我们考虑以下情况:如果输入中不包含字符，那么，在 第一次调用 getchar 函数的叫候，while 语句或 for 语句中的条件测试从一开始就为假， 程序的执行结果将为 0，这也是正确的结果。这一点很重要。whi1e 语句与 for 语句的优点 之一就是在执行循环体之前就对条件进行测试，如果条件不满足，则不执行循环体，这就可 能出现循环体一次都不执行的情况。在出现 0 长度的输入时，程序的处理应该灵活一些，在 出现边界条件时，while 语句与 for 语句有助于确保程序执行合理的操作。
1.5.3.                  行计数
接下来的这个程序用于统计输入中的行数。我们在上面提到过，标准库保证输入文本流 以行序列的形式出现，每一行均以换行符结束。因此，统计行数等价于统计换行符的个数。
/* count lines in input */ main()
{
int c, nl;
nl = 0;
while ((c = getchar()) != EOF) if (c == '\n')
++nl; printf("%d\n", nl);
}
在该程序中，while 循环语句的循环体是一个 if 语句，它控制自增语句++nl。if 语句 先测试圆括号中的条件，如果该条件为真，则执行其后的语句(或括在花括号中的一组语句)。 这里再次用缩进方式表明语句之间的控制关系。
双等于号==是 C 语言中表示"等于"关系的运算符(类似于 Pascal 中的单等于号=及 Fortran 中的.EQ.)。由于 C 语言将单等于号=作为赋值运算符，因此使用双等于号==表示相等的逻辑 关系，以示区分。这里提醒注意，在表示"等于"逻辑关系的时候(应该用==)，C 语言初学 者有时会错误地写成单等于号=。在第 2 章我们将看到，即使这样误用了，其结果通常仍然是 合法的表达式，因此系统不会给出警告信息。
单引号中的字符表示一个整型值，该值等于此字符在机器字符集中对应的数值，我们称 之为字符常量。但是，它只不过是小的整型数的另一种写法而已。例如，'A'是一个字符常量; 在 ASCII 字符集中其值为 65(即字符 A 的内部表示值为 65)。当然，用'A'要比用 65 好，因 为。'A'的意义更清楚，且与特定的字符集无关。
字符串常量中使用的转义字符序列也是合法的字符常量，比如，'\n'代表换行符的值， 在 ASCII 字符集中其值为 10。我们应当注意到，'\n'是单个字符，在表达式中它不过是一个 整型数而已;而"\n"是一个仅包含一个字符的字符串常量。有关字符串与字符之间的关系， 我们将在第 2 章进一步讨论。
练习 1•8             编写一个统计空格、制表符与换行符个数的程序。
练习 1•9 编写一个将输入复制到输出的程序，并将其中连续的多个空格用一个空格代 替。
练习 1•10 编写一个将输入复制到输出的程序，并将其中的制表符替换为\t，把回退符 替换为\b，把反斜杠替按为\\。这样可以将制表符和回退符以可见的方式显示出来。
1.5.4.                  单词计数
我们将介绍的第 4 个实用程序用于统计行数、单词数与字符数。这里对单词的定义比较 宽松，它是任何其中不包含空格、制表符或换行符的字符序列。下面这段程序是 UNIX 系统 中 wc 程序的骨干部分:
#include 
#define IN              1              /* inside a word */
#define OUT              0              /* outside a word */
/* count lines, words, and characters in input */ main()
{
int c, nl, nw, nc, state;
state = OUT;
nl = nw = nc = 0;
while ((c = getchar()) != EOF) {
++nc;
if (c == '\n')
++nl;
if (c == ' ' || c == '\n' || c = '\t') state = OUT;
else if (state == OUT) { state = IN;
++nw;
}
}
printf("%d %d %d\n", nl, nw, nc);
}
程序执行时，每当遇到单词的第一个字符，它就作为一个新单词加以统计。state 变量 记录程序当前是否正位于一个单词之中，它的初值是"不在单词中"，即初值被赋为 OUT。我 们在这里使用了符号常量 IN 与 OUT，而没有使用其对应的数值 1 与 0，这样程序更易读。在 较小的程序中，这种做法也许看不出有什么优势，但在较大的程序中，如果从一开始就这样 做，因此而增加的一点工作量与提高程序可读性带来的好处相比是值得的。读者也会发现， 如果程序中的幻数都以符号常量的形式出现，对程序进行大量修改就会相对容易得多。
下列语句
nl = nw = nc = 0;
将把其中的 3 个变量 nl、nw 与 nc 都设置为 0。这种用法很常见，但要注意这样一个事实: 在兼有值与赋值两种功能的表达式中，赋值结合次序是由右至左。所以上面这条语句等同于
n1 = (nw = (nc = 0));
运算符||代表 OR(逻辑或)，所以下列语句
if (c == ' ' || c== '\n' || c == '\t')
的意义是"如果 c 是空格，或 c 是换行符，或 c 是制表符"(前面讲过，转义字符序列\t 是 制表符的可见表示形式)。相应地，运算符&&代表 AND(逻辑与)，它仅比||高一个优先级。 由&&或||连接的表达式由左至右求值，并保证在求值过程中只要能够判断最终的结果为真或 假，求值就立即终止。如果 c 是空格，则没有必要再测试它是否为换行符或制表符，这样就 不必执行后面两个测试。在这里，这一点并不特别重要，但在某些更复杂的情况下这样做就 有必要了，不久我们将会看到这种例子。
这段程序中还包括一个 else 部分，它指定当 if 语句中的条件部分为假时所要执行的动 作。其一般形式为:
if (表述式)
语句 1
else
语句 2
其中，if•else 中的两条语句有且仅有一条语句被执行。如果表达式的值为真，则执行 语句 1，否则执行语句 2。这两条语句都既可以是单条语句，也可以是括在花括号内的语句序 列。在单词计数程序中，else 之后的语句仍是一个 if 语句，该 if 语句控制了包含在花括 号内的两条语句。
练习 1•11 你准备如何测试单词计数程序?如果程序中存在某种错误，那么什么样的输 入最可能发现这类错误昵’
练习 1•12             编写一个程序，以每行一个单词的形式打印其输入。
1.6 数组
在这部分内容中，我们来编写一个程序，以统计各个数字、空白符(包括空格符、制表 符及换行符)以及所有其它字符出现的次数。这个程序的实用意义并不大，但我们可以通过 该程序讨论 C 语言多方面的问题。
所有的输入字符可以分成 12 类，因此可以用一个数组存放各个数字出现的次数，这样比
使用 10 个独立的变量更方便。下面是该程序的一种版本:
#include 
/* count digits, white space, others */ main()
{
int c, i, nwhite, nother; int ndigit[10];
nwhite = nother = 0;
for (i = 0; i = '0' && c = '0' && c = '0' && c <= '9')
++ndigit[c•'0'];
else if (c == ' ' || c == '\n' || c == '\t')
++nwhite; else
++nother;
程序中经常使用下列方式表示多路判定:
if (条件 1)
语句 1
else if (条件 1)
语句 2