# 有向图之间边的关系edges = [("A", "B"), ("A", "C"), ("A", "D"), ("B", "A"), ("B", "D"), ("C", "A"), ("D", "B"), ("D", "C")]for edge in edges:    G.add_edge(edge[0], edge[1])pagerank_list = nx.pagerank(G, alpha=1)print("pagerank 值是：", pagerank_list)NetworkX 工具把中间的计算细节都已经封装起来了，我们直接调用 PageRank函数就可以得到结果：    pagerank 值是： {'A': 0.33333396911621094, 'B': 0.22222201029459634, 'C': 0.22222201029459634, 'D': 0.22222201029459634}我们通过 NetworkX 创建了一个有向图之后，设置了节点之间的边，然后使用PageRank 函数就可以求得节点的 PR值，结果和上节课中我们人工模拟的结果一致。好了，运行完这个例子之后，我们来看下 NetworkX 工具都有哪些常用的操作。**1. 关于图的创建**图可以分为无向图和有向图，在 NetworkX中分别采用不同的函数进行创建。无向图指的是不用节点之间的边的方向，使用nx.Graph() 进行创建；有向图指的是节点之间的边是有方向的，使用nx.DiGraph() 来创建。在上面这个例子中，存在 A→D 的边，但不存在 D→A的边。**2. 关于节点的增加、删除和查询**如果想在网络中增加节点，可以使用 G.add_node('A')添加一个节点，也可以使用 G.add_nodes_from(\['B','C','D','E'\])添加节点集合。如果想要删除节点，可以使用 G.remove_node(node)删除一个指定的节点，也可以使用 G.remove_nodes_from(\['B','C','D','E'\])删除集合中的节点。那么该如何查询节点呢？如果你想要得到图中所有的节点，就可以使用 G.nodes()，也可以用G.number_of_nodes() 得到图中节点的个数。**3. 关于边的增加、删除、查询**增加边与添加节点的方式相同，使用 G.add_edge("A", "B") 添加指定的"从 A 到B"的边，也可以使用 add_edges_from函数从边集合中添加。我们也可以做一个加权图，也就是说边是带有权重的，使用add_weighted_edges_from函数从带有权重的边的集合中添加。在这个函数的参数中接收的是 1个或多个三元组 \[u,v,w\] 作为参数，u、v、w 分别代表起点、终点和权重。另外，我们可以使用 remove_edge 函数和 remove_edges_from函数删除指定边和从边集合中删除。另外可以使用 edges() 函数访问图中所有的边，使用 number_of_edges()函数得到图中边的个数。以上是关于图的基本操作，如果我们创建了一个图，并且对节点和边进行了设置，就可以找到其中有影响力的节点，原理就是通过PageRank 算法，使用 nx.pagerank(G) 这个函数，函数中的参数 G代表创建好的图。
## 如何用 PageRank 揭秘希拉里邮件中的人物关系了解了 NetworkX工具的基础使用之后，我们来看一个实际的案例：希拉里邮件人物关系分析。希拉里邮件事件相信你也有耳闻，对这个数据的背景我们就不做介绍了。你可以从GitHub 上下载这个数据集：。整个数据集由三个文件组成：Aliases.csv，Emails.csv 和 Persons.csv，其中Emails 文件记录了所有公开邮件的内容，发送者和接收者的信息。Persons这个文件统计了邮件中所有人物的姓名及对应的ID。因为姓名存在别名的情况，为了将邮件中的人物进行统一，我们还需要用Aliases 文件来查询别名和人物的对应关系。整个数据集包括了 9306 封邮件和 513个人名，数据集还是比较大的。不过这一次我们不需要对邮件的内容进行分析，只需要通过邮件中的发送者和接收者（对应Emails.csv 文件中的 MetadataFrom 和 MetadataTo字段）来绘制整个关系网络。因为涉及到的人物很多，因此我们需要通过PageRank算法计算每个人物在邮件关系网络中的权重，最后筛选出来最有价值的人物来进行关系网络图的绘制。了解了数据集和项目背景之后，我们来设计到执行的流程步骤：![](Images/75cb6d7c05106ff2e0342b58ffa9a6e5.png){savepage-src="https://static001.geekbang.org/resource/image/72/c9/72132ffbc1209301f0876178c75927c9.jpg"}1.  首先我们需要加载数据源；2.  在准备阶段：我们需要对数据进行探索，在数据清洗过程中，因为邮件中存在别名的情况，因此我们需要统一人物名称。另外邮件的正文并不在我们考虑的范围内，只统计邮件中的发送者和接收者，因此我们筛选    MetadataFrom 和 MetadataTo    这两个字段作为特征。同时，发送者和接收者可能存在多次邮件往来，需要设置权重来统计两人邮件往来的次数。次数越多代表这个边（从发送者到接收者的边）的权重越高；3.  在挖掘阶段：我们主要是对已经设置好的网络图进行 PR    值的计算，但邮件中的人物有 500    多人，有些人的权重可能不高，我们需要筛选 PR    值高的人物，绘制出他们之间的往来关系。在可视化的过程中，我们可以通过节点的    PR 值来绘制节点的大小，PR 值越大，节点的绘制尺寸越大。设置好流程之后，实现的代码如下：    
# -*- coding: utf-8 -*-
# 用 PageRank 挖掘希拉里邮件中的重要任务关系import pandas as pdimport networkx as nximport numpy as npfrom collections import defaultdictimport matplotlib.pyplot as plt
# 数据加载emails = pd.read_csv("./input/Emails.csv")
# 读取别名文件file = pd.read_csv("./input/Aliases.csv")aliases = {}for index, row in file.iterrows():    aliases[row['Alias']] = row['PersonId']
# 读取人名文件file = pd.read_csv("./input/Persons.csv")persons = {}for index, row in file.iterrows():    persons[row['Id']] = row['Name']
# 针对别名进行转换        def unify_name(name):    
# 姓名统一小写    name = str(name).lower()    
# 去掉, 和 @后面的内容    name = name.replace(",","").split("@")[0]    
# 别名转换    if name in aliases.keys():        return persons[aliases[name]]    return name
# 画网络图def show_graph(graph, layout='spring_layout'):    