2020/7/27 linux pwn⼊门学习到放弃
linux pwn⼊⻔学习到放弃
队员编号002 酒仙桥六号部队 5⽉3⽇
这是 酒仙桥六号部队 的第 2 篇⽂章。
全⽂共计11470个字，预计阅读时⻓30分钟。
PWN是⼀个⿊客语法的俚语词，⾃"own"这个字引申出来的，意为玩家在整个游戏对战
中处在胜利的优势。
本⽂记录菜⻦学习linux pwn⼊⻔的⼀些过程，详细介绍linux上的保护机制，分析⼀些
常⻅漏洞如栈溢出,堆溢出，use after free等,以及⼀些常⻅⼯具集合介绍等。
程序的常⽤保护机制
linux
先来学习⼀些关于linux⽅⾯的保护措施，操作系统提供了许多安全机制来尝试降低或阻
⽌缓冲区溢出攻击带来的安全⻛险，包括DEP、ASLR等。
从checksec⼊⼿来学习linux的保护措施。checksec可以检查可执⾏⽂件各种安全属
性，包括Arch、RELRO、Stack、NX、PIE等。
pip安装pwntools后⾃带checksec检查elf⽂件。
1 checksec xxxx.so
2 Arch: aarch64-64-little
3 RELRO: Full RELRO
4 Stack: Canary found
5 NX: NX enabled
6 PIE: PIE enabled
https://mp.weixin.qq.com/s/XGcEHpRuKEL2Dxn1kE7wpw 1/36
2020/7/27 linux pwn⼊门学习到放弃
另外笔者操作系统为macOS,⼀些常⽤的linux命令如readelf需要另外brew install
binutils安装。
1 brew install binutils
当然也可以独⾃安装checksec。
1 wget https://github.com/slimm609/checksec.sh/archive/2.1.0.tar.gz
2 tar xvf 2.1.0.tar.gz
3 ./checksec.sh-2.1.0/checksec --file=xxx
gdb⾥peda插件⾥⾃带的checksec功能
1 gdb level4 //加载⽬标程序
2 gdb-peda$ checksec
3 CANARY : disabled
4 FORTIFY : disabled
5 NX : ENABLED
6 PIE : disabled
7 RELRO : Partial
CANNARY⾦丝雀(栈保护)/Stack protect/栈溢出保护
栈溢出保护是⼀种缓冲区溢出攻击缓解⼿段，当函数存在缓冲区溢出攻击漏洞时，攻击
者可以覆盖栈上的返回地址来让shellcode能够得到执⾏。
当启⽤栈保护后，函数开始执⾏的时候会先往栈⾥插⼊cookie信息，当函数真正返回的
时候会验证cookie信息是否合法，如果不合法就停⽌程序运⾏。
攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败⽽
阻⽌shellcode的执⾏。
在Linux中我们将cookie信息称为canary/⾦丝雀。
gcc在4.2版本中添加了-fstack-protector和-fstack-protector-all编译参数以
⽀持栈保护功能，4.9新增了-fstack-protector-strong编译参数让保护的范围更
⼴。
https://mp.weixin.qq.com/s/XGcEHpRuKEL2Dxn1kE7wpw 2/36
2020/7/27 linux pwn⼊门学习到放弃
开启命令如下:
1 gcc -o test test.c // 默认情况下，开启Canary保护
2 gcc -fno-stack-protector -o test test.c //禁⽤栈保护
3 gcc -fstack-protector -o test test.c //启⽤堆栈保护，不过只为局部变量中含有
4 gcc -fstack-protector-all -o test test.c //启⽤堆栈保护，为所有函数插⼊保护代码
FORTIFY/轻微的检查
fority其实是⾮常轻微的检查，⽤于检查是否存在缓冲区溢出的错误。
适⽤情形是程序采⽤⼤量的字符串或者内存操作函数，如memcpy，memset，
stpcpy，strcpy，strncpy，strcat，strncat，sprintf，snprintf，vsprintf，
vsnprintf，gets以及宽字符的变体。
FORTIFY_SOURCE设为1，并且将编译器设置为优化1(gcc -O1)，以及出现上述情
形，那么程序编译时就会进⾏检查但⼜不会改变程序功能。
开启命令如下:
1 gcc -o test test.c // 默认情况下，不会开这个检查
2 gcc -D_FORTIFY_SOURCE=1 -o test test.c // 较弱的检查
3 gcc -D_FORTIFY_SOURCE=1 仅仅只会在编译时进⾏检查 (特别像某些头⽂件 #include  /proc/sys/kernel/randomize_va_space
开启ASLR，切换⾄root⽤户，输⼊命令
1 echo 2 > /proc/sys/kernel/randomize_va_space
https://mp.weixin.qq.com/s/XGcEHpRuKEL2Dxn1kE7wpw 4/36
2020/7/27 linux pwn⼊门学习到放弃
上⾯的序号代表意思如下:
0 - 表示关闭进程地址空间随机化。
1 - 表示将mmap的基址，stack和vdso⻚⾯随机化。
2 - 表示在1的基础上增加栈（heap）的随机化。
可以防范基于Ret2libc⽅式的针对DEP的攻击。ASLR和DEP配合使⽤，能有效阻⽌攻
击者在堆栈上运⾏恶意代码。
PIE和PIC
PIE最早由RedHat的⼈实现，他在连接上增加了-pie选项，这样使⽤-fPIE编译的对象
就能通过连接器得到位置⽆关可执⾏程序。
fPIE和fPIC有些不同。-fPIC与-fpic都是在编译时加⼊的选项，⽤于⽣成位置⽆关的
代码(Position-Independent-Code)。这两个选项都是可以使代码在加载到内存时
使⽤相对地址，所有对固定地址的访问都通过全局偏移表(GOT)来实现。
-fPIC和-fpic最⼤的区别在于是否对GOT的⼤⼩有限制。-fPIC对GOT表⼤⼩⽆限
制，所以如果在不确定的情况下，使⽤-fPIC是更好的选择。
-fPIE与-fpie是等价的。这个选项与-fPIC/-fpic⼤致相同，不同点在于：-fPIC⽤
于⽣成动态库，-fPIE⽤于⽣成可执⾏⽂件。再说得直⽩⼀点：-fPIE⽤来⽣成位置⽆关
的可执⾏代码。
PIE和ASLR不是⼀样的作⽤，ASLR只能对堆、栈,libc和mmap随机化，⽽不能对代码
段，数据段随机化，使⽤PIE+ASLR则可以对代码段和数据段随机化。
区别是ASLR是系统功能选项，PIE和PIC是编译器功能选项。
联系点在于在开启ASLR之后，PIE才会⽣效。
开启命令如下:
1 gcc -o test test.c // 默认情况下，不开启PIE
2 gcc -fpie -pie -o test test.c // 开启PIE，此时强度为1
3 gcc -fPIE -pie -o test test.c // 开启PIE，此时为最⾼强度2
4 gcc -fpic -o test test.c // 开启PIC，此时强度为1，不会开启PIE
5 gcc -fPIC -o test test.c // 开启PIC，此时为最⾼强度2，不会开启PIE
RELRO(read only relocation)
https://mp.weixin.qq.com/s/XGcEHpRuKEL2Dxn1kE7wpw 5/36
2020/7/27 linux pwn⼊门学习到放弃
在很多时候利⽤漏洞时可以写的内存区域通常是⿊客攻击的⽬标，尤其是存储函数指针
的区域。⽽动态链接的ELF⼆进制⽂件使⽤称为全局偏移表（GOT）的查找表来动态解
析共享库中的函数，GOT就成为了⿊客关注的⽬标之⼀。
GCC, GNU linker以及Glibc-dynamic linker⼀起配合实现了⼀种叫做relro的技
术: read only relocation。⼤概实现就是由linker指定binary的⼀块经过dynamic
linker处理过 relocation之后的区域,GOT为只读。
设置符号重定向表为只读或在程序启动时就解析并绑定所有动态符号，从⽽减少对GOT
（Global Offset Table）攻击。如果RELRO为 "Partial RELRO"，说明我们对
GOT表具有写权限。
开启命令如下:
1 gcc -o test test.c // 默认情况下，是Partial RELRO
2 gcc -z norelro -o test test.c // 关闭，即No RELRO
3 gcc -z lazy -o test test.c // 部分开启，即Partial RELRO
4 gcc -z now -o test test.c // 全部开启
开启FullRELRO后写利⽤时就不能复写got表。
⼯具常⻅整合
pwn
pwntools
pwntools是⼀个⼆进制利⽤框架,⽹上关于pwntools的⽤法教程很多，学好pwntools
对于做漏洞的利⽤和理解漏洞有很好的帮助。可以利⽤pwntools库开发基于python的
漏洞利⽤脚本。
pycharm
pycharm可以实时调试和编写攻击脚本，提⾼了写利⽤的效率。
1. 在远程主机上执⾏：
https://mp.weixin.qq.com/s/XGcEHpRuKEL2Dxn1kE7wpw 6/36
2020/7/27 linux pwn⼊门学习到放弃
1 socat TCP4-LISTEN:10001,fork EXEC:./linux_x64_test1
2. ⽤pycharm⼯具开发pwn代码，远程连接程序进⾏pwn测试。
需要设置环境变量 TERM=linux;TERMINFO=/etc/terminfo，并勾选
Emulate terminal in output coonsoole，
然后pwntools的python脚本使⽤远程连接。
1 p = remote('172.16.36.176', 10001)
ida
1 ...
2 raw_input() # for debug
3 ...
4 p.interactive()
当pwntools开发的python脚本暂停时，远程ida可以附加查看信息。
gdb附加
https://mp.weixin.qq.com/s/XGcEHpRuKEL2Dxn1kE7wpw 7/36
2020/7/27 linux pwn⼊门学习到放弃
1 #!/usr/bin/python
2 # -*- coding: UTF-8 -*-
3 import pwn
4 ...
5 # Get PID(s) of target. The returned PID(s) depends on the type of targe
6 m_pid=pwn.proc.pidof(p)[0]
7 print("attach %d" % m_pid)
8 pwn.gdb.attach(m_pid) # 链接gdb调试，先在gdb界⾯按下n下⼀步返回python控制台ente
9
10 print("\n##########sending payload##########\n")
11 p.send(payload)
12
13 pwn.pause()
14 p.interactive()
gdb插件枚举
1)PEDA - Python Exploit Development Assistance for GDB
(https://github.com/longld/peda)
可以很清晰的查看到堆栈信息，寄存器和反汇编信息
git clone https://github.com/longld/peda.git ~/panda/peda
echo "source ~/panda/peda/peda.py" >> ~/.gdbinit
2)GDB Enhanced Features
(https://github.com/hugsy/gef)