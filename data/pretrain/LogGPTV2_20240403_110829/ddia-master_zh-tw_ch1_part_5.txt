众所周知，软体的大部分开销并不在最初的开发阶段，而是在持续的维护阶段，包括修复漏洞、保持系统正常执行、调查失效、适配新的平台、为新的场景进行修改、偿还技术债和新增新的功能。
不幸的是，许多从事软体系统行业的人不喜欢维护所谓的 **遗留（legacy）** 系统，—— 也许因为涉及修复其他人的错误、和过时的平台打交道，或者系统被迫使用于一些份外工作。每一个遗留系统都以自己的方式让人不爽，所以很难给出一个通用的建议来和它们打交道。
但是我们可以，也应该以这样一种方式来设计软体：在设计之初就尽量考虑尽可能减少维护期间的痛苦，从而避免自己的软体系统变成遗留系统。为此，我们将特别关注软体系统的三个设计原则：
* 可操作性（Operability）
  便于运维团队保持系统平稳执行。
* 简单性（Simplicity）
  从系统中消除尽可能多的 **复杂度（complexity）**，使新工程师也能轻松理解系统（注意这和使用者介面的简单性不一样）。
* 可演化性（evolvability）
  使工程师在未来能轻松地对系统进行更改，当需求变化时为新应用场景做适配。也称为 **可扩充套件性（extensibility）**、**可修改性（modifiability）** 或 **可塑性（plasticity）**。
和之前提到的可靠性、可伸缩性一样，实现这些目标也没有简单的解决方案。不过我们会试著想象具有可操作性，简单性和可演化性的系统会是什么样子。
### 可操作性：人生苦短，关爱运维
有人认为，“良好的运维经常可以绕开垃圾（或不完整）软体的局限性，而再好的软体摊上垃圾运维也没法可靠执行”。尽管运维的某些方面可以，而且应该是自动化的，但在最初建立正确运作的自动化机制仍然取决于人。
运维团队对于保持软体系统顺利执行至关重要。一个优秀运维团队的典型职责如下（或者更多）【29】：
* 监控系统的执行状况，并在服务状态不佳时快速恢复服务。
* 跟踪问题的原因，例如系统故障或效能下降。
* 及时更新软体和平台，比如安全补丁。
* 了解系统间的相互作用，以便在异常变更造成损失前进行规避。
* 预测未来的问题，并在问题出现之前加以解决（例如，容量规划）。
* 建立部署、配置、管理方面的良好实践，编写相应工具。
* 执行复杂的维护任务，例如将应用程式从一个平台迁移到另一个平台。
* 当配置变更时，维持系统的安全性。
* 定义工作流程，使运维操作可预测，并保持生产环境稳定。
* 铁打的营盘流水的兵，维持组织对系统的了解。
良好的可操作性意味著更轻松的日常工作，进而运维团队能专注于高价值的事情。资料系统可以透过各种方式使日常任务更轻松：
* 透过良好的监控，提供对系统内部状态和执行时行为的 **可见性（visibility）**。
* 为自动化提供良好支援，将系统与标准化工具相整合。
* 避免依赖单台机器（在整个系统继续不间断执行的情况下允许机器停机维护）。
* 提供良好的文件和易于理解的操作模型（“如果做 X，会发生 Y”）。
* 提供良好的预设行为，但需要时也允许管理员自由覆盖预设值。
* 有条件时进行自我修复，但需要时也允许管理员手动控制系统状态。
* 行为可预测，最大限度减少意外。
### 简单性：管理复杂度
小型软体专案可以使用简单讨喜的、富表现力的程式码，但随著专案越来越大，程式码往往变得非常复杂，难以理解。这种复杂度拖慢了所有系统相关人员，进一步增加了维护成本。一个陷入复杂泥潭的软体专案有时被描述为 **烂泥潭（a big ball of mud）** 【30】。
**复杂度（complexity）** 有各种可能的症状，例如：状态空间激增、模组间紧密耦合、纠结的依赖关系、不一致的命名和术语、解决效能问题的 Hack、需要绕开的特例等等，现在已经有很多关于这个话题的讨论【31,32,33】。
因为复杂度导致维护困难时，预算和时间安排通常会超支。在复杂的软体中进行变更，引入错误的风险也更大：当开发人员难以理解系统时，隐藏的假设、无意的后果和意外的互动就更容易被忽略。相反，降低复杂度能极大地提高软体的可维护性，因此简单性应该是构建系统的一个关键目标。
简化系统并不一定意味著减少功能；它也可以意味著消除 **额外的（accidental）** 的复杂度。Moseley 和 Marks【32】把 **额外复杂度** 定义为：由具体实现中涌现，而非（从使用者视角看，系统所解决的）问题本身固有的复杂度。
用于消除 **额外复杂度** 的最好工具之一是 **抽象（abstraction）**。一个好的抽象可以将大量实现细节隐藏在一个干净，简单易懂的外观下面。一个好的抽象也可以广泛用于各类不同应用。比起重复造很多轮子，重用抽象不仅更有效率，而且有助于开发高质量的软体。抽象元件的质量改进将使所有使用它的应用受益。
例如，高阶程式语言是一种抽象，隐藏了机器码、CPU 暂存器和系统呼叫。SQL 也是一种抽象，隐藏了复杂的磁碟 / 记忆体资料结构、来自其他客户端的并发请求、崩溃后的不一致性。当然在用高阶语言程式设计时，我们仍然用到了机器码；只不过没有 **直接（directly）** 使用罢了，正是因为程式语言的抽象，我们才不必去考虑这些实现细节。
抽象可以帮助我们将系统的复杂度控制在可管理的水平，不过，找到好的抽象是非常困难的。在分散式系统领域虽然有许多好的演算法，但我们并不清楚它们应该打包成什么样抽象。
本书将紧盯那些允许我们将大型系统的部分提取为定义明确的、可重用的元件的优秀抽象。
### 可演化性：拥抱变化
系统的需求永远不变，基本是不可能的。更可能的情况是，它们处于常态的变化中，例如：你了解了新的事实、出现意想不到的应用场景、业务优先顺序发生变化、使用者要求新功能、新平台取代旧平台、法律或监管要求发生变化、系统增长迫使架构变化等。