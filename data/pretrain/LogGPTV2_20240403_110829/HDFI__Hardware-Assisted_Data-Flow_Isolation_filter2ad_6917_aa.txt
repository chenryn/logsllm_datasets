title:HDFI: Hardware-Assisted Data-Flow Isolation
author:Chengyu Song and
Hyungon Moon and
Monjur Alam and
Insu Yun and
Byoungyoung Lee and
Taesoo Kim and
Wenke Lee and
Yunheung Paek
2016 IEEE Symposium on Security and Privacy
2016 IEEE Symposium on Security and Privacy
HDFI: Hardware-Assisted Data-ﬂow Isolation
Chengyu Song∗, Hyungon Moon†, Monjur Alam∗, Insu Yun∗, Byoungyoung Lee∗,
Taesoo Kim∗, Wenke Lee∗, Yunheung Paek†
∗Georgia Institute of Technology
†Seoul National University
Abstract—Memory corruption vulnerabilities are the root
cause of many modern attacks. Existing defense mechanisms
are inadequate; in general, the software-based approaches are
not efﬁcient and the hardware-based approaches are not ﬂexible.
In this paper, we present hardware-assisted data-ﬂow isolation,
or, HDFI, a new ﬁne-grained data isolation mechanism that is
broadly applicable and very efﬁcient. HDFI enforces isolation
at the machine word granularity by virtually extending each
memory unit with an additional tag that is deﬁned by data-
ﬂow. This capability allows HDFI to enforce a variety of security
models such as the Biba Integrity Model and the Bell–LaPadula
Model. We implemented HDFI by extending the RISC-V instruc-
tion set architecture (ISA) and instantiating it on the Xilinx Zynq
ZC706 evaluation board. We ran several benchmarks including
the SPEC CINT 2000 benchmark suite. Evaluation results show
that the performance overhead caused by our modiﬁcation to the
hardware is low (< 2%). We also developed or ported several
security mechanisms to leverage HDFI, including stack protection,
standard library enhancement, virtual function table protection,
code pointer protection, kernel data protection, and information
leak prevention. Our results show that HDFI is easy to use,
imposes low performance overhead, and allows us to create more
elegant and more secure solutions.
I. INTRODUCTION
Memory corruption vulnerabilities are the root cause of many
modern attacks. To defeat such attacks, many security features
have been commoditized, including NX-bit (No-eXecute),
Supervisor Mode Execution Protection (SMEP), Supervisor
Mode Access Prevention (SMAP), Memory Protection Exten-
sion (MPX), which have provided a strong foundation for
security in today’s computer systems. However, while these
hardware-based security features are very efﬁcient, they do not
provide adequate protection against modern, complex memory-
corruption-based attacks. For example, NX-bit can eliminate
simple forms of code injection attacks, but cannot stop code-
reuse attacks such as return-to-libc attack [26], return-oriented
programming (ROP) [65], COOP [62], and non-control data
attacks [14, 35, 66].
To defeat these new attacks, researchers continue to develop
new hardware-based mechanisms. For example, hardware-based
shadow stacks have been proposed to protect return addresses
from tampering by adversaries [46, 59, 81]. Hardware-based
control-ﬂow integrity (CFI) has also been proposed to prevent
code-reuse attacks, with various trade-offs [18, 23, 24, 41].
Furthermore, a number of other approaches have been proposed
to eliminate the root cause of these memory corruption
vulnerabilities [27, 51, 52, 77].
2375-1207/16 $31.00 © 2016 IEEE
© 2016, Chengyu Song. Under license to IEEE.
DOI 10.1109/SP.2016.9
DOI 10.1109/SP.2016.9
1
1
Our work also aims to prevent memory corruption based
exploits. Towards this end, we take the direction of developing
a new hardware feature that provides both ﬂexibility (i.e.,
applicable to broad use cases) and performance (i.e., very
efﬁcient when activated and otherwise near-zero performance
overhead on common execution paths). Our key observation is
that even with hardware support, enforcing memory safety for
the whole application is still too expensive for practical use, e.g.,
WatchDogLite [52] imposes 29% slowdown on SPEC CINT
2006 benchmarks. To further reduce performance overhead,
one promising direction is to divide the memory into different
regions—one for sensitive data (e.g., function pointers) and
the other for the rest (e.g., application data). Then, we enforce
memory safety only over the sensitive region [43, 63, 66]. There
are two major advantages of this approach. First, sensitive
data is usually a smaller set than normal data, and less data
implies fewer checks and less performance overhead. Second,
the safety of memory operations over sensitive data is easier for
static veriﬁcation. For example, because pushing/popping data
onto/from stack is always safe, once we isolate the stack slots
used to store return addresses, we can guarantee memory safety
for return addresses without any runtime check. With these
two advantages, we can signiﬁcantly reduce the number of
runtime checks, thereby making memory safety more affordable.
However, implementing this strategy on commodity hardware
is non-trivial due to the lack of an efﬁcient, ﬁne-grained
mechanism for data isolation.
Table I compares existing software-based (top half) and
hardware-based (bottom half) isolation mechanisms on com-
modity hardware. The most apparent problem is that the two
most efﬁcient hardware-based mechanisms—segment in x86
and access domain in ARM processors, are absent on 64-bit
mode. As a result, security solutions in modern processors must
make a trade-off between security and performance—solutions
that opt for performance, e.g., by using randomization based
protection, are usually subject to information disclosure or
brute-force based attacks [16, 32], while solutions that opt for
security, e.g., by leveraging context switch or masking, usually
yield poorer performance [19, 63, 66].
However, even if we managed to bring back the segment
and access domain, these mechanisms are still inadequate.
Speciﬁcally, because they are all coarse-grained, if we want to
isolate data at a smaller granularity (e.g., function pointers) and
preserve a program’s original memory layout, then we must
perform data shadowing. Unfortunately, data shadowing breaks
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:12:03 UTC from IEEE Xplore.  Restrictions apply. 
Software-based
Hardware-based
Mechanism
Randomization [43, 63]
Masking [19, 43, 63]
Access control list [11, 30]
x86 memory segment [43, 83]
ARM access domain [87]
Virtual address space [66]
Privilege level
Virtualization [64]
TrustZone [4]
ADI [57]
HDFI
(1)
Data
shadowing
(2)
(3)
(4)
Context Liveness Availability
switch tracking
on 64-bit
Y
Y
N
Y
Y
Y
Y
Y
Y
N
N
N
N
N
N
Y
Y
Y
Y
Y
N
N
N
N
Y
N
N
Y
Y
Y
Y
Y
N
Y
Y
Y
N
N
Y
Y
Y
Y
Y
Y
(5)
Self
protection
Y
Y
Y
Y
Y
Y
N
N
N
Y
Y
(6)
(7)
Vulnerable to Performance
info leak
overhead
Y
N
N
N
N
N
N
N
N
N
N
moderate
low
high
low
moderate
moderate
high
high
very high
low1
low
TABLE I: Comparison between HDFI and other isolation mechanisms, based on (1) whether data shadowing is required, (2) whether context
switch is required for data access, (3) whether liveness tracking is required, (4) is available on 64-bit mode, (5) whether they can be used for
self-protection, (6) is vulnerable to information leak, and (7) performance overhead. Self-protection means whether the mechanism can be
used to prevent attacks from the same privilege-level. Performance overhead is measured by comparing one instrumented read/write operation
against a normal memory read/write operation. 1There is no public benchmark result for ADI, so this conclusion is purely based on their
presentation [57].
data locality and requires extra steps to retrieve the shadow
data.This introduces additional performance overhead [21].
Furthermore, data shadowing also introduces unavoidable
memory overhead.
To overcome these limitations, we propose hardware-assisted
data-ﬂow isolation (HDFI), a new ﬁne-grained data isolation
mechanism. To eliminate data shadowing, HDFI enforces
isolation at machine word granularity by virtually extending
each memory unit with an additional tag. We choose to enforce
isolation at this granularity because it balances the memory
overhead (ﬁner granularity requires more spaces for tags) and
application requirements—a majority of sensitive data like
pointers are at this granularity, and the rest can be easily aligned
through software approaches. Please also note that HDFI’s
tags are associated with memory units’ physical addresses, so
attackers cannot tamper or bypass the protection by mapping
the same physical page to different virtual addresses. Moreover,
instead of using static partition, the tag is deﬁned by data-ﬂow.
Inspired by the idea of data-ﬂow integrity [10], HDFI deﬁnes
the tag of a memory unit by the last instruction that writes to
this memory location; then at memory read, it allows a program
to check if the tag matches what is expected. This capability
allows developers to enforce different security models. For
example, to protect the integrity of sensitive data, we can
enforce the Biba Integrity Model [6]. In particular, we can use
the tag to indicate integrity level (IL) of the corresponding data:
sensitive data has IL1 and normal data has IL0. Next, we assign
IL to write operations based on the data-ﬂow. That is, we use
static analysis to identify write operations that can manipulate
sensitive data, and allow them to set the memory tag to IL1;
all other write operations will assign to the tag to IL0. Finally,
when loading sensitive data from memory, we check if the tag
is IL1 (see §III for a concrete example). HDFI can also be used
to enforce conﬁdentiality, i.e., the Bell–LaPadula Model [5].
For instance, to protect sensitive data like encryption keys, we
can set their tag to SL1 (secret level 1), and enforce that all
untrusted read operations (e.g., when copy data to an output
buffer) can only read data with tag SL0.
We implemented a prototype of HDFI by extending the
RISC-V instruction set architecture (ISA) [72], an open-source,
license-free ISA that is designed with direct hardware imple-
mentation and practical applications in mind. Our prototype
implementation was designed to support one-bit tag for two
reasons: (1) it limits the amount of required resources; and (2)
as discussed above, in most security applications, one-bit tags
are sufﬁcient.
To evaluate the performance of HDFI, we instantiated it on
the Xilinx Zynq ZC706 evaluation board [80] and ran several
benchmarks including the SPEC CINT 2000 [68] benchmark
suite. Evaluation results show that the performance overhead
caused by our modiﬁcation to the hardware is low (< 2%).
In order to demonstrate the beneﬁt of HDFI to security
solutions, we developed and ported six representative security
mechanisms to leverage HDFI, including stack protection,
standard library enhancement (protection for setjmp/longjmp,
heap metadata, GOT, and the exit handler), virtual function
table protection, code pointer separation, kernel data protection,
and information leak prevention. Our development experience
shows that HDFI is easy to use and usually allows us to create
more elegant solutions. We also evaluated the security and
performance beneﬁts of HDFI. The results show that HDFI
can help improve the security guarantees. At the same time,
by eliminating data shadowing and context switching, HDFI
can also help reduce the performance overhead for security
mechanisms like CPS [43] and Kenali [66].
To summarize, this paper makes the following contributions:
• Design: We present a new hardware security mechanism,
which is general, efﬁcient, backwards compatible, and only
requires small hardware modiﬁcation. We also present
optimization techniques to minimize HDFI’s performance
impact on normal operations (§IV).
• Applications: To demonstrate the beneﬁts of HDFI, we
developed/ported six security mechanisms that utilize HDFI
and analyzed how HDFI can enhance their security and
performance (§V).
22
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:12:03 UTC from IEEE Xplore.  Restrictions apply. 
• Implementation: We implemented the proposed hardware
with realization on FGPA board. We also implemented all
six security applications (§VI).
• Evaluation: We quantitatively evaluated: (1) the perfor-
mance impact of HDFI and the effectiveness of our op-
timization techniques and (2) the performance improvement
delivered to the security mechanisms we implemented (§VII).
The rest of this paper is organized as follows. §II deﬁnes
the threat model and the problem scope. §III uses a concrete
example to explain how HDFI works, and discusses the differ-
ences between HDFI and similar work. §IV presents the the
design of HDFI. §V describes the security applications we have
developed. §VI provides some implementation details. §VII
describes the evaluation of HDFI and its security applications.
§VIII analyzes the security guarantee provided by HDFI, its
attack surface, and discusses best practices. §IX discusses the
limitations of our current design and future work. §X concludes
the paper.
II. THREAT MODEL AND ASSUMPTIONS
In this work, we focus on preventing memory corruption
based attacks; therefore we follow the typical threat model
of most related work. That is, we assume that software may
contain one or more memory vulnerabilities that, once triggered
would allow attackers to perform arbitrary memory reads and
writes. We do not limit what attackers would do with this