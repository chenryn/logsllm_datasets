and methods. The API documentation is given at the level of
class. There is a single HTML file for each class to describe the
basic class hierarchy information and also detailed documentation
for all methods in this class. Figure 4 shows an example of the
documentation for android.telephony.TelephonyManager and
one method getDeviceId() of it. The documentation can be
separated into two parts: 1) structured information including the
class profile and the prototype, return value and thrown exceptions
of a method, and 2) unstructured descriptions in the format
of several paragraphs of text, which describe the functionality,
requirements and directives of the API.
3.3 Entity Extraction
There are four entity types in our API relation graph. We extract
these entity types from the documents in the following ways:
â€¢ First, since the API document is organized in classes, APIGraph
extracts a class entity from every per-class document file.
As shown in Figure 4, the name of a class is described with
structured texts.
â€¢ Second, APIGraph extracts package entities by splitting the
package names from the full class name.
Figure
API
android.telephony.TelephonyManager.
example
An
4:
document
for
â€¢ Third, APIGraph parses per-class document files into Docu-
ment Object Model (DOM) and then extracts method entities
belonging to a class.
â€¢ Fourth, APIGraph parses the manifest file2 that lists all the
permissions to extract permission entities.
1https://developer.android.com/reference
2https://developer.android.com/reference/android/Manifest.permission
API Relation GraphEnhancing ClassifiersBuild API Relation Graph Leverage API Relation Graph API Document CollectionEntity ExtractionRelation ExtractionAPI EmbeddingAPI ClusteringAdded in API level 1Deprecated in API level 26getDeviceIdpublic String getDeviceId ()This method was deprecated in API level 26.Use getImei() which returns IMEI for GSM or getMeid() which returns MEID for CDMA.Returns the unique device ID, for example, the IMEI for GSM and the MEID or ESN for CDMA phones. Return null if device ID is not available.Requires Permission: READ_PRIVILEGED_PHONE_STATE, for the calling app to be the device or profile owner and have the READ_PHONE_STATE permission, or that the calling app has carrier privileges (see hasCarrierPrivileges()) on any active subscription. ...ReturnsStringunstructured descriptionstructured informationstructured informationandroid.telephony.TelephonyManager.htmlTelephonyManagerpublic class TelephonyManager extends Objectjava.lang.Object     android.telephony.TelephonyManagerAdded in API level 1Public methodsSession 3B: Malware CCS '20, November 9â€“13, 2020, Virtual Event, USA760Table 2: Templates to extract 4 relation types, where â€œENTâ€ represents an entity.
Relation Type
conditional
alternative
refers_to
uses_permission
# of Templates
186
22
5
4
Example Templates
â€œcall ENT before ENT be callâ€, â€œbefore ENT returnâ€, â€œif ENT failâ€, â€œwait for ENTâ€
â€œreplace by ENTâ€, â€œuse ENT insteadâ€, â€œbe deprecate. use ENTâ€
â€œsee also ENTâ€, â€œsee ENTâ€, â€œquery ENTâ€, â€œrefer to ENTâ€
â€œrequire permission ENTâ€, â€œrequire ENT permissionâ€, â€œbe grant ENT permissionâ€
3.4 Relation Extraction
As stated, since some relations, like class_of relation, are organized
in well-structured HTML elements, and some, like refers_to relation,
are embedded in unstructured texts, we adopt two methods to
extract relations from API documents.
3.4.1 Relation Parsing from Structured Texts. According to the rela-
tion types defined in Table 1, six relations are depicted structurally
in the documents. APIGraph extracts these kinds of relations by
direct document parsing. Here are the details. First, APIGraph
extracts function_of and class_of relations during the extraction
of class, method and package entities. Second, APIGraph extracts
inheritance relations from the class profile part in the per-class
document file. Lastly, APIGraph extracts uses_parameter, returns,
and throws relations at the prototype part for each method.
3.4.2 Template-based Relation Matching from Unstructured Texts.
APIGraph extracts four types of relations, i.e., conditional, al-
ternative, refers_to and uses_permission, using a template-based
relation matching method with the help of NLP (Natural Lan-
guage Processing) techniques. Note that APIGraph also extracts
uses_permission relations from two API-permission mappings
generated by existing works [4, 5] to complement the relations
extracted from API documents, because such information in the
Android API documents may be incomplete. In general, there
are three steps in template-based relation extraction: (i) manual
formation of matching templates, (ii) iterative expansion of template
set, and (iii) NLP-enhanced template matching.
Manual Formulation of Matching Templates. In this step, we
manually examine 1% of API documents to investigate the patterns
that are used to describe the relations. Table 2 gives several example
templates in regular expression format for each kind of relation
that are manually formulated to match relations from unstructured
texts. For example, the template â€œsee also ENTâ€ matches a refers_to
relation between the current method entity and the ENT entity.
Iteratively Expansion of Template Set. In this step, APIGraph
adopts a semi-automated strategy to iteratively formulate templates
for relation matching. There are three sub-steps in this process, as
described below:
â€¢ First, we randomly select 1% of APIs and collect their docu-
â€¢ Second, we use the existing template set to extract relations
from these documents with the help of NLP techniques (ex-
plained in the following paragraph).
â€¢ Third, after the matching, we manually check whether there are
relations not captured by existing template set. If the answer is
yes, we manually formulate the templates for them and repeat
from the first step. Otherwise, APIGraph finishes formulating
templates to extract relations for all APIs.
ments.
Guided by the above process, the template set converges after
manually looking into 5% of all API documents. Finally, we
summarize 217 templates for conditional, alternative, refers_to and
uses_permission relations. Table 2 presents the template number for
each relation. The whole template construction process takes two
security experts around three days. Note that Android documenta-
tion is stable over time. For example, only 1.4% (834) APIs are added
and 1.6% (989) APIs change their descriptions from API_level 28
to 29, and none of the newly added or changed descriptions need
additional templates.
NLP-enhanced Template Matching. APIGraph matches tem-
plates against unstructured API documents via two steps. First,
APIGraph splits paragraphs into sentences and then preprocess
each sentence via the following methods:
â€¢ Stemming. APIGraph reduces each word to its base form, for
example, â€œrequiresâ€ and â€œrequiredâ€ are stemmed to â€œrequireâ€.
â€¢ Co-reference Resolution. APIGraph adopts declaration-based
co-reference resolution [25] to resolve all the pronouns to the
underlying entity. For example, â€œThis methodâ€ in a sentence
â€œThis method requires permission INTERNETâ€ is resolved to
the method the sentence belongs to.
â€¢ Entity Name Normalization. APIGraph replaces all polymor-
phic names with their exact values via following the hyper-
links to their original definition so that APIGraph normal-
izes the representation of entities. For example, the name
android.Manifest.permission.INTERNET and its constant value
â€œandroid.permission.INTERNETâ€ are both used in documents:
APIGraph replaces the former with the latter.
Second, APIGraph matches all the templates against each
preprocessed sentence in the API descriptions. If a match against
a template is found, APIGraph then extracts relations from the
sentences as specified by the template. If a sentence can not be
matched with any template, APIGraph will drop the sentence.
3.5 Leveraging API Relation Graph
To leverage API relation graph, APIGraph will convert each API in
the relation graph into an embedding representation and then group
those embeddings into clusters. The concept of API embedding,
inspired by word embedding [36] and graph embedding, is to
convert each API in the relation graph to a vector, which represents
its semantic meanings. Our conversion algorithm (see Algorithm 1),
leveraging a prior algorithm called TransE [8] and fitting TransE
into our relation graph problem, is described below:
(1) APIGraph extracts permission entities and adds new relations
based on common permissions (Lines 3â€“5). The intuition here is
that permissions in Android preserve semantics and APIGraph
pays more attention to permissions.
Session 3B: Malware CCS '20, November 9â€“13, 2020, Virtual Event, USA761âŠ² Form Training Set
for each pair â„, ğ‘¡ âˆˆ ğ¸ that use this permission do
Add (â„, ğ‘Ÿuse_the_same_permission, ğ‘¡) to triples ğ‘†
Algorithm 1 API Embedding and Clustering
Input: Relation graph ğº = âŸ¨ğ¸, ğ‘…âŸ©, learning rate ğœ†, embedding size
ğ‘˜, cluster size ğ¶.
1: Set triples ğ‘† = âˆ…
2: Add existing relations to triples ğ‘†
3: for each permission entity do
4:
5:
6: for each entity ğ‘’ âˆˆ ğ¸ do
7:
8: for each relation ğ‘Ÿ âˆˆ ğ‘… do
9:
10: while True do
11:
12:
Assign ğ‘’ with a vector ğ‘™ğ‘’ âˆˆ Rğ‘˜
Assign ğ‘Ÿ with a vector ğ‘™ğ‘Ÿ âˆˆ Rğ‘˜
for triple (â„, ğ‘Ÿ, ğ‘¡) âˆˆ ğ‘† do
Minimize the following loss function:
âŠ² Vector Initialization
âŠ² Train Embeddings
13:
â„“ = âˆ¥ğ‘™â„ + ğ‘™ğ‘Ÿ âˆ’ ğ‘™ğ‘¡ âˆ¥2
2
Update ğ‘™â„ by gradient descent:
ğ‘™â„ = ğ‘™â„ + ğœ† Â· ğœ•â„“
ğœ•ğ‘™â„
Update ğ‘™ğ‘Ÿ , ğ‘™ğ‘¡ , ğ‘™ğ‘¡â€² with gradient descent similarly
if embeddings do not change then
14:
15:
16:
17: Collect embeddings of method entities
18: Use k-Means algorithm to find ğ¶ clusters
break
âŠ² Cluster APIs
(2) APIGraph embeds each API entity ğ‘’ âˆˆ ğ¸ (Lines 6â€“7) and each
relation ğ‘Ÿ âˆˆ ğ‘… (Lines 8â€“9) with vector ğ‘™ğ‘’, ğ‘™ğ‘Ÿ âˆˆ Rğ‘˜ respectively.
(3) APIGraph applies TransE algorithm (Lines 10â€“14) to minimize
âˆ¥ğ‘™â„ + ğ‘™ğ‘Ÿ âˆ’ ğ‘™ğ‘¡ âˆ¥2
2 for each triple (â„, ğ‘Ÿ, ğ‘¡) in triples set ğ‘† where â„ and
ğ‘¡ are entities and ğ‘Ÿ is a relation. The intuition here is that if two
head entities â„1, â„2 have the same relation with a common tail
entity, their embeddings ğ‘™â„1
(4) APIGraph clusters API embeddings into different groups using
k-Means and determines the cluster number via the Elbow
method [43].
After APIGraph successfully clusters APIs, APIGraph adopts
clusters, particularly the embedding of each clusterâ€™s center, to
represent the semantics of independent APIs in the cluster.
4 API RELATION GRAPH RESULTS AND
, ğ‘™â„2 should be close.
EXPERIMENTAL SETUP
In this section, we describe some statistics of the generated API
relation graph, the dataset used in the evaluation and existing ML
classifiers used in our experiment.
4.1 Statistics of API Relation Graph
Implementation. Our prototype of APIGraph contains 1,627
lines of Python code, including Android API reference document
collection and parsing, relation graph building, and embedding
generation and clustering. Specifically, we use spaCy [42] (a Python
NLP toolkit) to perform sentence splitting, stemming and co-
reference resolution, and our API embedding and clustering is built
Table 3: Extracted entities for Android API level 29.
Entity Type Count
59,125
method
class
7,368
446
package
permission
270
Table 4: Extracted relations for Android API level 29.
Relation Type Count Relation Type
function_of
class_of
inheritance
uses_parameter
returns
throws
alternative
conditional
refers_to
uses_permission
59,125
7,368
3,755
14,528
5,113
Count
8,310
1,264
5,990
10,859
5,033
with TensorFlow [44] and sklearn [41] respectively. Following the
Elbow method [43], we choose 2,000 as the total cluster number.
The results of API relation graph generated by APIGraph are
described in terms of entities and relations. Specifically, we use
API level 29 as an example. Table 4 shows the extracted entities:
There are 67,209 entities, including 59,125 methods, 7,368 classes,
446 packages, and 270 permissions. Note that different API levels
have different numbers of entities as API evolves over time. Table 4
lists the number of relations extracted for each type: There are
121,345 extracted relations among these entities.
4.2 Dataset
Our dataset, spanning over seven years, contains 322,594 Android
apps, i.e., 32,089 malicious and 290,505 benign as shown in Table 5.
The datasetâ€”following criteria documented by Tesseract [39]â€”
has two important properties: temporal consistency and spatial
consistency. The former ensures that data samples are ordered based
on their appearance and almost evenly distributed over seven years;
the latter that the ratio of malware is close to the percentage of
malware in the real-world, which is 10% according to Tesseract
for Android. Note that our dataset is almost two times larger than
the one used in state-of-the-art like Tesseract. Here is how we
construct this dataset.
â€¢ Step-1: Initial malware selection and validation. We downloaded
all given Android malware from three open repositories,
including VirusShare [45], VirusTotal [46]3, and the AMD
dataset [27, 48]. These are three largest open-source dataset at
the time we write our paper and they together contain 109,897
unique malware. We then feed all samples to VirusTotal and
only keep 109,770 malware samples that are reported by at least
154 anti-virus (AV) engines.
â€¢ Step-2: Initial selection and validation of benign apps. We
downloaded 1,060,000 Google Play apps with the help of
AndroZoo [13]. Again, we feed all the apps to VirusTotal and
only keep 1,033,073 that are reported as benign by all the AVs
from VirusTotal.
3VirusTotal provides a set of malicious samples for academic usage at request.
4We follow a most recent work [49] to choose 15 as the threshold.
Session 3B: Malware CCS '20, November 9â€“13, 2020, Virtual Event, USA762Table 5: Evaluation dataset. This dataset contains 322,594 apps from 2012 to 2018. For each month, the malware percentage 10%.
When there are enough apps available, most months contain about 5K apps to be representative and effective for evaluation.
Year
App
Malicious (M)
Benign (B)
M+B
M/(M+B)
2012
2013
2014
2015
2016
2017
2018
ALL
3,066
27,613
30,679
10%
4,871
43,873
48,744
10%
5,871
52,843
58,714
10%
5,797
52,173
57,970
10%
5,651
50,859
56,510
10%
2,620
24,930
32,300
10%
4,213
38,214
38,025
10%
32,089
290,505
322,594
10%
Table 6: Android malware classifiers in the evaluation. Note
that DroidEvolver uses a model pool that contains 5 linear
online learning algorithms.
Algorithm
Model Pool