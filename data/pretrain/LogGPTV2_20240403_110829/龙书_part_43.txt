是二义性的，αBu可能存在多个最右推导。如果--个文法是无二义性的，那么该文法的每个右句
A→β)称为-个句柄。注意，我们说的是“--个句柄”，
中出现在位于之前的最右句型。
始符号E推导得到。因此，和某个产生式体匹配的最左子串不一定是句柄。
表示得更清楚，我们为其中的词法单元id加上了下标。虽然T是产生式E→T的体，但符号T并
右推导中的一个反向步骤。
个最右推导。非正式地讲，“句柄”是和某个产生式体匹配的子串，对它的归约代表了相应的最
4.5.2句柄剪枝
这个摊导过程实际上是一个最右推导。
推导过程。下面的推导对应于图4-25 中的分析过程：
非终结符号替换为该符号的某个产生式的体)。因此，自底向上语法分析的目标是反向构造一个
后这个串被归约为 T。最后将T归约为开始符号E，从而结束整个语法分析过程。
第二个id是 F→id 的体。我们没有将 T归约为E，而是将第二个id 归约为 F，得到串 T＊F。然
T,生成T*id。
第一次归约使用产生式 F→id，将最左边的id 归约为 F，得到串 F＊id。第二次归约将 F 归约为
如下的符号串序列来讨论这个归约过程：
例4.37
约(reductior)步骤中，～-个与某产生式体相匹配的特定子串被替换为该产生式头部的非终结符号。
4.5.1归约
效利用 LR 分析器生成工具。实现语法分析器生成工具的算法将在4.7节中给出。
轻松地根据适当的文法构造出高效的 LR分析器。本节中的概念有助于写出合适的文法，从而有
换
为A之后得到的串是的某个最右推导序列
β在中出现的位置：将这个位置上的β
一个句柄是满足下述条件的产生式A→β】
一个句柄（handle）。换句话说，最右句型
是句型T*id2的一个句柄。假如T真的被替换为E，我们将得到串E*id2，而这个串不能从开
请注意，句柄右边的串u一定只包含终结符号。为方便起见，我们把产生式体β（而不是
比如，在按照表达式文法(4.1)对id，＊id, 进行语法分析时，各个句柄如图4-26 所示。为
根据定义，一次归约是一个推导步骤的反向操作（回顾一下，一次推导步骤将句型中的一个
在自底向上语法分析过程中，关键问题是何时进行归约以及应用哪个产生式进行归约。
我们可以将自底向上语法分析过程看成将一个串w"“归约”为文法开始符号的过程。在每个归
语法分析
通过“句柄剪枝”可以得到一个反向的最右推导。也就是说，我们从被分析的终结符号串u
 对输人进行从左到右的扫描，并在扫描过程中进行自底向上语法分析，就可以反向构造出-
现在我们可以选择是对串T还是对由第二个id组成的串进行归约，其中 T是E-→7 的体，而
这个序列中的符号串由快照中各相应子树的根结点组成。这个序列从输入串id＊id开始。
图4-25中的快照演示了一个归约序列，相应的文法是表达式文法(4.1)。我们将使用
id * id, F * id, T * id, T * F, T, E 
E=→T=T *F=7 *id=F * id=→id * id
替
，而不是“唯一句柄”。这是因为文法可能
id1 *id2
图 4-26id,*id, 的语法分析
过程中出现的句柄
T*F
句柄
F
山
↑
←
←
归约用的产生式
TT
P
*F
149
口
---
## Page 166
个错误恢复子例程。
决定用哪个非终结符号来替换这个串。
是栈顶。语法分析器在栈中确定这个串的左端，
顶端。
四种可能的动作：①移人，②归约，③接受，④报错。
取的动作。
一个移人－归约语法分析器在按照表达式文法(4.1)对输入串id＊id2 进行语法分析时可能采
为空为止：
析器不断地重复这个循环，直到它检测到--个语法错误，或者栈中包含了开始符号且输人缓冲区
候栈是空的，并且输人串w存放在输入缓冲区中。
我们将栈顶显示在右侧，而不是像在自顶向下语法分析中那样显示在左侧。如下所示，开始的时
出现在栈的顶部。
用一个输入缓冲区来存放将要进行语法分析的其余符号。我们将看到，句柄在被识别之前,总是
4.5.3移入－归约语法分析技术
输
会介绍多个寻找句柄的方法。
将β替换为相关产生式An一→β的头部，得到前一个最右句型
句型。
人串的一个最右推导过程。
可以停止分析并宣称语法分析过程成功完成。将归约过程中用到的产生式反向排序，就得到了
2）归约（reduce）:被归约的符号串的右端必然
虽然主要的语法分析操作是移人和归约，但实际上一个移人－归约语法分析器可采取如下
我们使用$来标记栈的底部以及输人的右端。按照惯例，在讨论自底向上语法分析的时候，
我们之所以能够在移人－归约语法分析中使用
1）移入(shift):将下一个输人符号移到栈的
移入－归约语法分析是自底向上语法分析的一种形式。它使用一个栈来保存文法符号，并
4）报错(error):发现一个语法错误，并调用一
3）接受（accept）:宣布语法分析过程成功完成。
然后我们重复这个过程。也就是说，我们在Yn-1中寻找句柄βn-1，并对这个句柄进行归约，
为了以相反顺序重构这个推导，我们在，中寻找句柄βn，
150
当进入这样的格局时，语法分析器停止运行，并宣称成功完成了语法分析。图 4-28 显示了
在对输人串的一次从左到右扫描过程中，语法分析器将零个或多个输人符号移到栈的顶端
$S
栈
栈
并
6
wS
3
输人
图4-28
FT
在处理输人 id,*id, 时经历的格局
栈
输人
并
一个移人－归约语法分析器
id * idg 
*id2
输人
图4-27
树中的—个句柄A→β
的
按按移
αβu的语法分析
>
E→T归约
F→id归约
动作
T★F归约
第
4章
---
## Page 167
例4.38
LR(1)文法类，即最多只需要向前看一个符号。
可能会出现这样的冲突。从技术上来讲，这些文法不在4.7节定义的LR(h)文法类中，我们把它
中选择正确的归约动作(归约/归约冲突)。现在我们给出一些语法构造的例子，这些构造的文法
约语法分析器都会得到如下的格局：即使知道了栈中的所有内容以及接下来的个输入符号，我
4.5.4移入－归约语法分析中的冲突
栈顶找到下一个句柄。因此它从不需要到栈中间去寻找句柄。
的下一个句柄y。该句柄可以被归约为 A：
中，句柄位于栈顶。将句柄归约为B之后，语法分析器可以把串x 移人栈中，得到位于栈顶
其中,句柄 βBy 位于栈顶，它将被归约为 A。
现在，语法分析器可以通过零次或多次移人动作，把串移人到栈的上方，得到如下格局：
语法分析器将句柄归约为B,从而到达如下格局:
y左侧的某个地方。
结符号。下一个最右非终结符号B将位于
展开，但这次使用的产生式体中只包含终
被替换为。在情况(2)中，A仍然首先被
演示了两种可能的情况。在情况(1)中，A 被替换为βBy，然后产生式体βBy 中最右非终结符号B
间。要证明这个性质，我们只需要考虑任意最右推导中的两个连续步骤可能具有的形式。图4-29
栈，是因为这个分析过程具有如下重要性质：句柄总是出现在栈的顶端，绝不会出现在栈的中
有些上下文无关文法不能使用移人－归约语法分析技术。对于这样的文法，每个移入－
语法分析
如果我们有一个移人－归约语法分析器处于格局
在这两种情况下，语法分析器在进行一次归约之后，都必须接着移人零个或多个符号才能在
现在考虑情况(2)。在格局
反向考虑情况(1)，即一个移入
换句话说：
一个二义性文法不可能是 LR 的。比如，考虑 4.3 节中的悬空-else 文法(4.14):
$&y
$αBxy
$αBBy
$αBB
$oBy
栈
stmt→ if expr then stmt
－归约语法分析器刚刚到达如下格局的情况：
1 other
I if expr then stmt else stmt
图4-29
一个最右推导中两个连续步骤的两种情况
情况（1）
xyz $
yz $
输人
N＄
情况(2）
151
---
## Page 168
4.5.54.5节的练习
来引导语法分析过程。
归约，虽然它本身并没有被归约。移入－归约的语法分析技术可以使用栈中离栈顶很远的信息
选择产生式(7)进行归约。请注意，在这个例子里,栈顶之下的第三个符号决定了应该执行什么
要么进人前面描述的格局。在前一种情况下，我们选择产生式(5)进行归约；在后一种情况下，则
器在返回一个词法单元之前先查询符号表。
确定。
式(7)。栈中的内容并没有指出p 是什么，必须使用从 p 的声明中获得的符号表中的信息来
式呢？如果 p是一-个过程，那幺正确的选择是产生式(5)；但如果 p是一个数组,就该选择产生
显然,栈顶的id必须被归约，但使用哪个产生
归约语法分析器将处于如下格局中：
在将前三个词法单元移人到栈中后，移人－
元流id(id，id)的方式输人到语法分析器中。
产生式）。
图 4-30中所示的产生式（还包含其他
翻译，我们希望使用不同的产生式分别生成实在参数列表和下标列表。因此，我们的文法包含
且假设引用数组的语法与此相同。因为在数组引用中对下标的翻译不同于过程调用中对参数的
回词法单元名id。假设我们的语言在调用过程时会给出过程名字，并把调用参数放在括号内。并
例4.39
据栈中内容和下一个输人符号确定应该使用哪个产生式进行归约。下面的例子说明了这种情况。
论能够处理这种二义性文法的语法分析器。
按照我们的期望运行，也就是将每个 else 和前一个尚未匹配的 thren 相关联。我们将在 4.8 节讨
面的 if-then-else 文法。如果我们在碰到 else 时选择移入来解决移入/归约冲突，语法分析器就会
stmt else stmt .
stmt，也可能应该将 elise 移人然后再寻找另一个 stmut，从而找到完整的 stimt 产生式体if expr then
中，那么不管栈中 if expr then stmt 之下是什么内容，我们都不能确定它是否是句柄。这里就出现
练习4.5.1：对于练习 4.2.2(a)中的文法 S→0 S1I0 1，指出下面各个最右句型的句柄：
请注意，经过修正的移入－归约语法分析技术可以对某些二义性文法进行语法分析，比如上
如果我们做了这样的修改，那么在处理 p(i，j)的时候，语法分析器要么进人格局
 解决方法之一是将产生式(1)中的词法单元id 改成 procid，并使用一个更加复杂的词法分析
..- id( id
一个以 p(i，j)开头的语句将以词法单
另一个常见的冲突情况发生在我们确认已经找到句柄的时候。在这种情况下我们不能够根
假设我们有这样--个词法分析器，它不考虑各个名字的类型，而是对所有的名字都返
... if expr then stmt
" procid （ id