第三种方法就是把libstack.so拷到/usr/lib或/lib目录，这样可以确保动态链接器能找到这个共享
些新的指令，所以上面1dd命令的输出结果显示动态链接器搜索到
是i586或i486，
ldconfig命令除了处理/etc/ld.so.conf中配置的目录之外，
$ readelf -a main
$ ldd main 
$ sudo ldconfig -v
S
/usr/lib/i586: 
/usr/1ib/i686: (hwcap: 0x0008000000000000)
/usr/lib/sse2:
/lib/tls:
/lib:
Tag
1
所以在运行程序时使用i686的库，
1ibv412.so.0 -> 1ibv412.so.0
/lib/1d-1inux.so.2 (0xb8082000)
libkdeinit_klauncher.so
 libncursesw.so.5
 libstack.so -> libstack.so
libstack.so =>
linux-gate.so.1 =>
(hwcap: 0x8000000000000000)
，在编译可执行文件main的时候就把ibstack.so的路径写死在可执行文件
(hwcap: 0x0000000004000000)
 -lstack
 /home/akaedu/somedir/libstack.so (0xb806a000)
0x0004000000000000
I√
-Istack -o main -Wl,-
(0xb809c000)
，这样可以更好地发挥平台的性能，
 libkdeinit_klauncher.so
系统检测到当前平台是i686而不 
 Shared library:
Name/Value
还处理一些默认目录,
 动态链接器就从这个缓存中搜索
也可以利用一
---
## Page 348
任意地址,
这余
和第3节“静态库"链接静态库不同，push函数没有链接到可执行文件中。而且ca11 80483d8
本节研究一下在main.c中调用共享库的函数push是如何实现的。首先反汇编看一下main的指令：
4.2.动态链接的过程 请点评
是不推荐的，
还可以看出，
S
int main(void)
Disassembly of section 
(gdb) si
(gdb) start
1895808
080483a8 :
开8
0
a0 04
9f 
9f
0408
0
0408
：08
mov
push
pushl
 and
lea
 line
call
TAOU
pushl
Library rpath:
Shared library: [libc.so.6]
7.
80483d8 
$0x61,(%esp).
%esp,%ebp
oe
%ebp
-0x4(%ecx)
*0x804a008
0x8049ff8
在运行时可以加载到
---
## Page 349
4.3.共享库的命名惯例 请点评
动态链接器已经把push函数的地址存在这里了，所以下次再调用push函数就可以直接从jmp
这时再看看0x804a008这个地址里存的是什么：
最终进入了动态链接器/lib/ld-linux.so.2，
原来就是下一条指令push $0x1o的地址。继续跟踪下去:
什么：
跳转到.plt段中，现在将要执行一条jmp*0x804a008指令，我们看看0x804a008这个地址里存的是
你可能已经注意到了，系统的共享库通常带有符号链接，例如:
*0x804a008指令跳到它的地址，
(ggb4a00x
Current language:
main () at main.c:8
-rw-r-
libcap.so.2.10 
S
Run
0x080483e3 in push@plt ()
Current language:
0x080484bc
-rwxr-xr-x 
(gdb）
0xb806a080 in ?? （) from /lib/ld-linux.so.2
gdb)
(gdb）
0x080483a8
（gdb）
ls -l 
rwxrwx
till
x 0x804a008
--r-
finish
S1
S1
S1
0x804a008
 /lib 
exit from #0 
_GLOBAL_OFFSET_TABLE_+20>:
 1 root root
in 
1 root root
？？（)
root
 root root
root
return 0;
.root
 auto; currently asm
而不必再进入/lib/ld-linux.so.2做动态链接了。
 0xb806a080 in ?? （) from /lib/ld-linux.so.2
t 1315024 2009-01-09 22:10 1ibc-2.8.90.so
（)
0x53e58955
 currently c
13792 2008-06-12 21:39 libcap.so.2.10
 10316 2007-08-01 03:20 1ibcap.so.1.10
14 2008-11-01 08:55 1ibcap.s0.2
4 2008-07-04 05:58
，在其中完成动态链接的过程并调用push函数，我们不
push('a');
0xb803f47c
0x080483de
IV
---
## Page 350
自动创建一个soname的符号链接：
如果把1ibstack.so.1.o所在的目录加入/ete/ld.so.conf中，然后运行1dconfig命令，ldconfig会
的soname是libstack.so.1:
这样编译生成的库文件是libstack.so.1.o，是real name，但这个库文件中记录了它
下面重新编译我们的1ibstack，指定它的soname：
name是库文件的-
殊，1ibc-2.8.90.so的主版本号是6而不是2或2.8。
库文件而不需要重新编译应用程序，
soname是-
文件（而不是符号链接）
按照共享库的命名惯例,
个linker name,
Dynamic section at offset 0xf10 contains 22 entries:
GROUP
OUTPUT_FORMAT(e1f32-i386)
libstack.so.1.0
lrwxrwxrwx 1 root 
SS
0x00000001
S
/lib/ld-1inux.so.2
/* GNU
S
lrwxrwxrwx
libstack.so.1]
cat
.8.90.s0
·
Tag
readelf -a libstack.so.1.0
the
Use
一个符号链接的名字，
-shared
...
static.
the
它是一段链接脚本：
有些应用程序依赖于1ibcap.so.2，
一个符号链接，
1 root root 238 2009-01-09 21:59 /usr/lib/libc.so
 1 root root
library'
的名字是real name，
每个共享库有三个文件名：real name、soname和linker name。真正的库
1>
1
有的linker name是一段链接脚本。例如上面的1ibc.so就是-
root
只包含共享库的主版本号，
 /usr/lib/libc_nonshared.a
so
，这是静态库所没有的优点。注意1ibc的版本编号有一点特
 try that secondarily.
14 2009-01-13 09:28 libc.so.6 -> libc-
15 2009-01-21 17:52 1ibstack.so.1 ->
 包含完整的共享库版本号。例如上面
主版本号-
只要soname-
 所以使用共享库可以很方便地升级
AS_NEEDED
一致即可保证库函数的接口
:[libc.so.6]
有些应用程序依赖
一致，
这个共享库就可以
真正
---
## Page 351
个名字，
注意，
但这样编译链接main.c却会报错：
3.静态库
问题了
一页
要做这个实验，
siS
因为编译器只认linker name。可以先创建一个linker name的符号链接，然后再编译就没
collect2:
/usr/bin/
-rwxr-xr-x 1 akaedu
gcc main.c 
/ld:
p
 你得把先前编译的libstack共享库、静态库都删掉,
-L.
returned
cannot
-lstack 
find
akaedu 10142 2009-01-21 17:49 libstack.so.1.0
exit status
全国嵌入式人才培训基地
-Istack 
-lstack
起始页
 如果先前拷到/lib或
5.虚拟内存管理
8
---
## Page 352
用ps命令查看当前终端下的进程,
知识之后，现在我们可以进一步理解虚拟内存管理了。首先分析一个例子：
系统，
我们知道操作系统利用体系结构提供的VA到PA的转换机制实现虚拟内存管理。有了共享库的基础
5.虚拟内存管理 请点评
5
当前系统中运行的每个进程在/proc下都有一个子目录，
页
图 20.4.进程地址空间
bfac5000-bfada000
b7fd9000-b7fda000
5
5
:6
/lib/tls/i686/cmov/libnss_files-2.8.90.s0
08048000-080f4000
S
30032
2997
L
7fd8000-b7fd9000
7fd7000-b7fd8000
7f6foo0-
7ca8000-b7cb2000
9283000-09497000
 cat
/proc/29977/maps
pts/0
pts/0
-b7f70000
-b7f6f000
00:00:00
00:00:00
r--p
r-xp
r-xp
r-xp 00000000
rw-p
rw-p
r-xp
TIME
得知bash进程的id是29977，
c-2.8.90.so
00000000 08:15
 bffeb0o0
0001b000
0001a000
b7fd7000
00000000
0015a000
09283000
 Ps
CMD
bash
015
全国嵌入式人才培训基地
files-
第 20 章 链接详解
5.虚拟内存管理
00:00
08:15
00:00
08:15
08:15 581656
08:15
08:15
00:00
00:00
565466
 581665
688142
0
565466
565466
0
00
目录名就是进程的id，查看目录下的
然后用cat/proc/29977/maps命令
[stack]
/lib/1d-2.8.90.so
vdso]
/lib/ld-2.8.90.s0
[heap]
而是由内核虚拟出来的文件
/lib/1d-2.8.90.so
3
T一
---
## Page 353
第一，虚拟内存管理可以控制物理内存的访问权限。物理内存本身是不限制访问的，任何地址都可
虚拟内存管理起到了什么作用呢？可以从以下几个方面来理解。
穷递归会月
量的非常少见。
应用程序动态分配大量内存的并不少见，
Oxbfad a000是栈空间，
享库也分为几个Segment,
到用mal1oc函数动态分配内存是在这里分配的。从0xb7ca 8000开始是共享库的映射空间，每个共
0x0928 3000-0x09497000不是从磁盘文件加载到内存的，
到内存的，
Segment,
0000~Oxbfffff）是用户空间，
分
（0x0949 7000）到共享库映射空间的起始地址（0xb7ca 8000）之间有很大的地址空洞，在动态
在第4 节“MMU"讲过，
要
函数栈帧，栈空间是向低地址增长的，
向高地址增长就要抬高Break，映射新的虚拟内存页面到物理内存，这是通过系统调用brk实现
，malloc函数也是调用brk向内核请求分配内存的。
Text Segment
Data Segment
共享库和mmap
用尽栈空间最终导致段错误。
内存映射区
命令行参数
环境变量
内核地址空间