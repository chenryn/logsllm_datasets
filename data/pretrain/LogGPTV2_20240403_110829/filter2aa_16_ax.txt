putchar(*p); break;
}
}
va_end(ap); /* clean up when done */
}
练习 7•3             改写 minprintf 函数，使它能完成 printf 函数的更多功能。
7.4 格式化输入——scanf 函数
输入函数 scanf 对应于输出函数 printf，它在与后者相反的方向上提供同样的转换功 能。具有变长参数表的函数 scanf 的声明形式如下:
int scanf(char *format, ...)
scanf 函数从标准输入中读取字符序列，按照 format 中的格式说明对字符序列进行解释， 并把结果保存到其余的参数中。格式参数 format 将在接下来的内容中进行讨论。其它所有 参数都必须是指针，用于指定经格式转换后的相应输入保存的位置。和上节讲述 printf 一 样，本节只介绍 scanf 函数最有用的一些特征，而并不完整地介绍。
当 scanf 函数扫描完其格式串，或者碰到某些输入无法与格式控制说明匹配的情况时， 该函数将终止，同时，成功匹配并赋值的输入页的个数将作为函数值返回，所以，该函数的
返回值可以用来确定已匹配的输入页的个数。如果到达文件的结尾，该函数将返回 EOF。注 意，返回 EOF 与 0 是不同的，0 表示下一个输入字符与格式串中的第一个格式说明不匹配。 下一次调用 scanf 函数将从上一次转换的最后一个字符的下一个字符开始继续搜索。
另外还有一个输入函数    sscanf，它用于从一个字符串(而不是标准输入)中读取字符序 列:
int sscanf(char *string, char *format, arg1, arg2, ...)
它按照格式参数 format 中规定的格式扫描字符串 string，并把结果分别保存到 arg1、 arg2、  这些参数中。这些参数必须是指针。
格式串通常都包含转换说明，用于控制输入的转换。格式串可能包含下列部分:
             空格或制表符，在处理过程中将被忽略。
             普通字符(不包括%)，用于匹配输入流中下一个非空白符字符。
             转换说明，依次由一个%、一个可选的赋值禁止字符*、一个可选的数值(指定最大 字段宽度)、一个可选的 h、l 或 L 字符(指定目标对象的宽度)以及一个转换字符
组成。
转换说明控制下一个输入字段的转换。一般来说，转换结果存放在相应的参数指向的变 量中。但是，如果转换说明中有赋值禁止字符*，则跳过该输入字段，不进行赋值。输入字段 定义为一个不包括空白符的字符串，其边界定义为到下一个空白符或达到指定的字段宽度。 这表明 scanf 函数将越过行边界读取输入，因为换行符也是空白符。(空白符包括空格符、 横向制表符、换行符、回车符、纵向制表符以及换页符)。
转换字符指定对输入字段的解释。对应的参数必须是指针，这也是 C 语言通过值调用语 义所要求的。表 7•2 中列出了这些转换字符。
表 7•2   scanf 函数的基本转换说明
 字符              输入数据;参数类型
d
 十进制整数;int *类型
i
 整数;int *类型，可以是八进制(以 0 开头)或十六进制(以 0x 或 0X 开头)
o
 八进制整数(可以以 0 开头，也可以不以 0 开头);int *类型
u
 无符号十进制整数;unsigned int *类型
x
 十六进制整数(可以 0x 或 0X 开头，也可以不以 0x 或 0X 开头);int *类型
c
 字符;char *类型，将接下来的多个输入字符(默认为 1  个字符)存放到指定位置。该转换规范通常不跳过 空白符。如果需要读入下一个非空白符，可以使用%1s
s
 字符串(不加引号);char *类型，指向一个足以存放该字符串(还包括尾部的字符'\0')的字符数组。字 符串的末尾将被添加一个结束符'\0'
e
,
f
,
g            
 浮点数，它可以包括正负号(可选)、小数点(可选)及指数部分(可选);float      *类型
%
 字符%;不进行任何赋值操作
转换说明 d、i、o、u 及 x 的前面可以加上字符 h 或 l。前缀 h 表明参数表的相应参数 是一个指向 short 类型而非 int 类型的指针，前缀 l 表明参数表的相应参数是一个指向 long 类型的指针。类似地，转换说明 e、f 和 g 的前面也可以加上前缀 l，它表明参数表的相应参 数是一个指向 double 类型而非 float 类型的指针。
来看第一个例子。我们通过函数 scanf 执行输入转换来改写第 4 章中的简单计算器程序，
如下所示:
#include 
main()              /* rudimentary calculator */
{
double sum, v;
sum = 0;
while (scanf("%lf", &v) == 1) printf("\t%.2f\n", sum += v);
return 0;
}
假设我们要读取包含下列日期格式的输入行:
25 Dec 1988
相应的 scanf 语句可以这样编写:
int day, year;
char monthname[20];
scanf("%d %s %d", &day, monthname, &year);
因为数组名本身就是指针，所以，monthname 的前面没有取地址运算符&。 字符字面值也可以出现在 scanf 的格式串中，它们必须与输入中相同的字符匹配。因此，
我们可以使用下列 scanf 语句读入形如 mm/dd/yy 的日期数据:
int day, month, year;
scanf("%d/%d/%d", &month, &day, &year);
scanf 函数忽略格式串中的空格和制表符。此外，在读取输入值时，它将跳过空白符(空 格、制表符、换行符等等)。如果要读取格式不固定的输入，最好每次读入一行，然后再用 sscanf 将合适的格式分离出来读入。例如，假定我们需要读取一些包含日期数据的输入行， 日期的格式可能是上述任一种形式。我们可以这样编写程序:
while (getline(line, sizeof(line)) > 0) {
if (sscanf(line, "%d %s %d", &day, monthname, &year) == 3) printf("valid: %s\n", line); /* 25 Dec 1988 form */
else if (sscanf(line, "%d/%d/%d", &month, &day, &year) == 3) printf("valid: %s\n", line); /* mm/dd/yy form */
else
printf("invalid: %s\n", line); /* invalid form */
}
scanf 函数可以和其它输入函数混合使用。无论调用哪个输入函数，下一个输入函数的 调用将从 scanf 没有读取的第一个字符处开始读取数据。
注意，scanf 和 sscanf 函数的所有参数都必须是指针。最常见的错误是将输入语句写 成下列形式:
scanf("%d", n);
正确的形式应该为:
scanf("%d", &n);
编译器在编译时一般检测不到这类错误。
练习 7•4             类似于上一节中的函数 minprintf，编写 scanf 函数的一个简化版本。 练习 7•5             改写第 4 章中的后缀计算器程序，用 scanf 函数和(或)sscanf 函数实
现输入以及数的转换。
7.5 文件访问
到目前为止，我们讨论的例子都是从标准输入读取数据，并向标准输出输出数据。标准 输入和标准输出是操作系统自动提供给程序访问的。
接下来，我们编写一个访问文件的程序，且它所访问的文件还没有连接到该程序。程序 cat 可以用来说明该问题，它把一批命名文件串联后输出到标准输出上。cat 可用来在屏幕 上打印文件，对于那些无法通过名字访问文件的程序来说。它还可以用作通用的输入收集器。 例如，下列命令行:
cat x.c y.c
将在标准输出上打印文件 x.c 和 y.c 的内容。 问题在于，如何设计命名文件的读取过程昵?换句话说，如何将用户需要使用的文件的
外部名同读取数据的语句关联起来。
方法其实很简单。在读写一个文件之前，必须通过库函数 fopen 打开该文件。fopen 用 类似于 x.c 或 y.c 这样的外部名与操作系统进行某些必要的连接和通信(我们不必关心这些 细节)，并返回一个随后可以用于文件读写操作的指针。
该指针称为文件指针，它指向一个包含文件信息的结构，这些信息包括:缓冲区的位置、 缓冲区中当前字符的位置、文件的读或写状态、是否出错或是否已经到达文件结尾等等。用 户不必关心这些细节，因为中已经定义了一个包含这些信息的结构 FILE。在程 序中只需按照下列方式声明一个文件指针即可:
FILE *fp;
FILE *fopen(char *name, char *mode);
在本例中，fp 是一个指向结构 FILE 的指针，并且，fopen 函数返回一个指向结构 FILE 的 指针。注意，FILE 像 int 一样是一个类型名，而不是结构标记。它是通过 typedef 定义的 (UNIX 系统中 fopen 的实现细节将在 8.5 节中讨论)。
在程序中，可以这样调用 fopen 函数:
fp = fopen(name, mode);
fopen 的第一个参数是一个字符串，它包含文件名。第二个参数是访问模式，也是一个字符 串，用于指定文件的使用方式。允许的模式包括:读(“ r")、写(“ w")及追加(“ a")。某些 系统还区分文本文件和二进制文件，对后者的访问需要在模式字符串中增加字符“  b"。
如果打开一个不存在的文件用于写或追加，该文件将被创建(如果可能的话)。当以写方 式打开一个已存在的文件时，该文件原来的内容将被覆盖。但是，如果以追加方式打开一个 文件，则该文件原来的内容将保留不变。读一个不存在的文件会导致错误，其它一些操作也 可能导致错误，比如试图读取一个无读取权限的文件。如果发生错误，fopen 将返回 NULL。
(可以更进一步地定位错误的类型，具体方法请参见附录  B.1  节中关于错误处理函数的讨论。)
文件被打开后，就需要考虑采用哪种方法对文件进行读写。有多种方法可供考虑，其中， getc 和 putc 函数最为简单。getc 从文件中返回下一个字符，它需要知道文件指针，以确 定对哪个文件执行操作:
int getc(FILE *fp)
getc 函数返回 fp 指向的输入流中的下一个字符。如果到达文件尾或出现错误，该函数将返 回 EOF，
putc 是一个输出函数，如下所示:
int putc(int c, FILE *fp)
该函数将字符 c 写入到 fp 指向的文件中，并返回写入的字符。如果发生错误，则返回 EOF。 类似于 getchar 和 putchar，getc 和 putc 是宏而不是函数。
启动一个 C 语言程序时，操作系统环境负责打开 3 个文件，并将这 3 个文件的指针提供 给该程序。这 3 个文件分别是标准输入、标准输出和标准错误，相应的文件指针分别为 stdin、 stdout 和 stderr，它们在中声明。在大多数环境中，stdin 指向键盘，而 stdout 和 stderr 指向显示器。我们从 7.1 节的讨论中可以知道，stdin 和 stdout 可以 被重定向到文件或管道。
getchar 和 putchar 函数可以通过 getc、putc、stdin 及 stdout 定义如下:
#define getchar()              getc(stdin)
#define putchar(c)              putc((c), stdout)
对于文件的格式化输入或输出，可以使用函数 fscanf 和 fprintf。它们与 scanf 和 printf 函数的区别仅仅在于它们的第一个参数是一个指向所要读写的文件的指针，第二个参 数是格式串。如下所示:
int fscanf(FILE *fp, char *format, ...) int fprintf(FILE *fp, char *format, ...)
掌握这些预备知识之后，我们现在就可以编写出将多个文件连接起来的 cat 程序了。该 程序的设计思路和其它许多程序类似。如果有命令行参数，参数将被解释为文件名，并按顺 序逐个处理。如果没有参数，则处理标准输入。
#include 
/* cat:              concatenate files, version 1 */ main(int argc, char *argv[])
{
FILE *fp;
void filecopy(FILE *, FILE *)
if (argc == 1) /* no args; copy standard input */ filecopy(stdin, stdout);
else
while(••argc > 0)
if ((fp = fopen(*++argv, "r")) == NULL) { printf("cat: can't open %s\n, *argv); return 1;
} else {
filecopy(fp, stdout); fclose(fp);
}
return 0;
}
/* filecopy:              copy file ifp to file ofp */ void filecopy(FILE *ifp, FILE *ofp)
{
int c;
while ((c = getc(ifp)) != EOF) putc(c, ofp);
}
文件指针 stdin 与 stdout 都是 FILE *类型的对象。但它们是常量，而非变量。因此不能 对它们赋值。
函数
int fclose(FILE *fp)
执行和 fopen 相反的操作，它断开由 fopen 函数建立的文件指针和外部名之间的连接，并 释放文件指针以供其它文件使用。因为大多数操作系统都限制了一个程序可以同时打开的文 件数，所以，当文件指针不再需要时就应该释放，这是一个好的编程习惯，就像我们在 cat 程序中所做的那样。对输出文件执行 fclose 还有另外一个原因:它将把缓冲区中由 putc 函数正在收集的输出写到文件中。当程序正常终止时，程序会自动为每个打开的文件调用 fclose 函数。(如果不需要使用 stdin 与 stdout，可以把它们关闭掉。也可以通过库函数 freopen 重新指定它们。)
7.6 错误处理——stderr 和 exit