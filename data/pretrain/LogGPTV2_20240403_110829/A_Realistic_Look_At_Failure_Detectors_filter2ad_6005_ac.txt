Algorithm Tv,*p consists 
plus the following 
of A (Le., a se­
1. Whenver Pi sends a message m, Pi attaches to 
m  the information 
[Pi is alive]. 
2. Whenever a process Pi receives a message m 
from a process Pi, Pi extracts from m  any infor­
mation [Pk is alive] and attaches that informa­
tion to every event executed as a consequence 
the reception 
of m. 
of 
3. Whenever a process Pi executes a decision event 
e (Le., Pi decides some value), Pj adds to 
output(P)j 
is not attached to e . 
every  process 
Pi such that [Pi is alive] 
• R1: RI is similar to Ro, except that Pj does not 
receive any message from any other process be­
fore time t, Le., we delay in Rl the reception 
of all messages by Pj. Moreover, no process Pk, 
k '" i, j, takes any step after its last step in the 
causal past of e, until time t. Since Pj does not 
participate 
e of Ro, then Pi exe­
cutes event e in Rl and also decides 0 at some 
time t (as in Ro). 
in the decision 
• R2: in R2, the failure pattern is the same as  in 
RI until time t, nd all  processes  crash 
at time 
t, except Pj which is correct. Moreover, no pro­
cess take steps until time t. By the termination 
property of consensus, 
in R2, and by the validity 
Pj actually decides 1 at t'. 
Pi decides at some time t' 
property of consensus, 
Lemma 4.2 The algorithm 
output(P) 
the behaviour 
Tv=>p emulates 
in 
of a Perfect 
failure detector. 
ensres strong completenes 
PROOF: We prove that the failure detector emulated 
in output(P) 
and strong 
accuracy. Consider first completeness. 
Let Pi be any 
process that crashes and Pj a correct process. There 
is a time after which Pi does not send any message . 
Pj eventu­
of consensus, 
By the termination  property 
i.e., by executing 
some 
ally decides in that execution, 
decision event e. Given that the information [Pi is 
alive] is not attached to e, Pi adds to output(P)
j Pi 
and never removes it, i.e., Pi permanently 
suspects Pi. 
is thus" ensured. Consider now 
Strong completeness 
350 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:21:30 UTC from IEEE Xplore.  Restrictions apply. 
Assume that Pj suspects Pi, Le., Pj adds Pi 
This can only happen if Pj executes a 
accuracy. 
to output(P)j. 
decision event e in some execution of A, and the in­
formation [Pi is aliveJ is not attached to e. Given that 
A is a total algorithm, 
crashed .. Strong accuracy is hence ensured  too. 0 
this can only happen if Pi has 
Proposition 4.3 Consider 
we do not bound the number of processes 
crash. 
tectors, 
that can 
among realistic 
failure 
In this environment, 
class for consensus 
the environment 
the weakest 
is P. 
de­
where 
Obviously, 
condition.) 
In [lJ, Chandra 
a S-based algorithm that solves 
PROOF: (1. Sufficient 
and Toueg presented 
the algorithm works with any 
consensus. 
failure detector in both 'R and P even if we do not 
bound the number of faulty processes. (2. Necessary 
condition.) 
detector in R that solves consensus 
into a failure detector in P. 
By Lemma 4.1 and Lemma 4.2, any failure 
can be transformed 
0 
cmsh. In this environment, among realistic failure de­
tectors, 
class for for terminating 
broadcast 
the weakest 
is P. 
reliable 
reliable 
detector, 
detectors, 
instance (k, k') 
each process waits until it receives the 
condition.) 
(1. Sufficient 
Let A be any terminating 
It is easy 
including 
real­
failure 
solves the terminating 
PROOF (SKETCH): 
to see that any Perfect 
istic failure 
broadcast problem. W hen executing 
of the problem, 
value from Pk or it suspects Pk. In the first case it 
else it proposes nil. 
proposes this value to a consensus 
The value delivered is the consensus value. (2. Nec­
essary condition.) 
broadcast algorithm using V. It is easy to see how 
we can emulate the output of V a failure detector of 
class P in a distributed 
ever a process Pj delivers nil for an instance (i, *) 
of 
the problem, Pi adds Pi to output(P)j. 
Any process 
that crashes will eventually 
added to 
be permanently 
output(P) 
process: strong complete­
ness will hence be ensured. Let Pi be any process that 
is added to output(P)j 
at some time t. This can only 
if Pi is faulty. Since we assume here that 
be possible 
V is realistic, 
then Pi must have crashed by time t. 0 
variable output (P). When­
at every  correct 
reliable 
in this paper the uniform variant of the 
We considered 
consensus problem. 
should decide differently, 
not [lOJ. 
variant of consensus where agreement is only required 
In this variant, no two processes 
w hether they are correct or 
Does our result  apply 
to the correct-restricted 
351 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:21:30 UTC from IEEE Xplore.  Restrictions apply. 
5  The weakest failure detector for 
terminating reliable broadcast 
initiator 
otherwise, 
reliable 
of the broadcast is 
broad­
[111. 
In this 
We denote by (i, k) the k'th instance 
must deliver a specific value nil 
We actually consider a general variant of 
the 
must deliver the message m broadcast by 
We consider here a strong form of reliable 
cast called terminating 
broadcast 
problem, processes 
if the sender process has crashed [llJ: 
processes 
sender(m). 
the problem where every process is a potential 
ofthe broadcast. 
of the problem where the initiator 
Pi' Instance (i, *) 
erties: (1) validity 
message m, then Pi eventually 
ment if a process delivers 
rect process delivers 
delivers 
=Pi· 
We state and show here that if we do not restrict 
the 
realistic 
number of faulty  processes  and  consider 
fail­
ure detectors, 
class to solve 
terminating 
already stated in [71 and proved implicitly 
realistic 
assumption 
is defined with the following 
prop­
if a correct process Pi broadcasts a 
delivers m, (2) agree­
failure detector 
broadcast is P. This result was 
a message m, then every cor­
m; and (3) integrity 
assuming 
The proof below makes that 
the weakest 
reliable 
a message m  and Pi is correct, 
if a  process 
detectors. 
explicit. 
failure 
. 
then sender(m) 
Proposition 5.1 Consider 
the environment 
where 
we do not bound the number of processes that can 
6  Concluding Remarks 
6.1 The impact of realism 
failure detectors 
in Section 3. 
As we pointed out in the introduction, 
our lower bound 
results do not hold if we also consider failure detec­
tors that can guess the future. To see why, consider 
the class M of Mambout 
introduced 
in [9J, and recalled 
There is an obvious algorithm A that solves consen­
sus using M even if we do not restrict 
faulty processes.  Every 
detector and selects the process Pj such that (a) Pj is 
not suspected and (b) there is no process Pk such that 
(b.I)  k  i permanently 
suspects Pi. It is easy to see that if we do not restrict 
the number of faulty processes, P   i. Interestingly, 
consensus is strictly 
this actually means that uniform 
harder than consensus. 
weaker 
this is because a process 
ev­
completeness 
6.3 Strength vs perfection 
the classes Sand 
weaker 
consensus 
failure detectors, 
failure detector that 
that V is a realistic 
model of [11. In fact, if we con­
our result because S is strictly 
That is, Sn'R. c P. To see why, assume by 
It was shown in [11 that the class S of Strong failure 
de­
even if we do not re­
tectors solves (uniform) 
strict the number of faulty processes. 
This might seem 
to contradict 
than P in the original 
sider only realistic 
P collapse. 
contradiction 
is Strong but not Perfect. 
This means that V violates 
some process Pi is falsely suspected. 
strong accuracy: 
Because V is realistic, 
it cannot guess the future  and 
hence it can very much be the case that all processes 
but Pi crashes. Weak accuracy would also be violated: 
a contradiction. 
It is important to notice that the observation 
has already been made by Halpern and Ricciardi 
in [121. In fact, they have expressed our notion 
of realism as a desirable 
sirable properties, 
of a failure detector model using 
knowledge theory and they proved that in this "new" 
model, Strong failure detectors 
Our definition 
rephrasing of a similar concept introduced 
is simpler because we do not introduce 
theory construct 
of [II.) 
of realism can be viewed as a simpler 
in (12]. 
any knowledge 
formalism 
and we stick to the original 
among other de­
property, 
above 
(It 
turn out to be Perfect. 
[1) T. Chandra and S. Toueg. Unreliable Failure Detectors 
for Reliable  Distributed 
43(2), March 1996. 
Systems. Journal of the ACM, 
(2) T. Chandra, V. Hadzilacos 
and S. Toueg. The Weakest 
Failure Detector for Solving Consensus. 
ACM, 43(4), 
July 1996. 
Journal of the 
[31 C. Dwork, N. Lynch and L. Stockmeyer. Consensus in 
of parlial 
synchrony. 
Journal of the ACM, 
the  presence 
35 (2), 1988. 
(4) C. Fetzer and F. Cristiano 
Fail-aware failure detectors. 
Proceedings of the 15th IEEE Symposium on Reliable 
Distributed  Systems, 
Oct 1996. 
Niagara-on-the-Lake, 
Canada, 
(5) M. Fischer, N. Lynch and M. Paterson. Impossibility 
of 
consensus with one faulty  process. 
Journal 
distributed 
of the ACM, 32(2), 
1985. 
[6) F. Greve, M. Hurfin, M. Raynal and F. Tronel. Pri­
mary Component Asynchronous  Croup  Membership 
as 
an Instance of a Generic Agreement F'mmework. Pro­
ceedings of the IEEE International 
tonomous Decentralized 
Systems (ISADS), 2001. 
Symposium on Au­
(7J E. Fromentin, M. Raynal, and F. Tronel. About Classes 
of Problems in A synchronous 
Process Crashes. Proceedings 
tional Conference on Distributed 
(lCDCS). 1999. 
Distributed 
Systems with 
of the IEEE Interna­
Computing Systems 
18J R. Guerraoui. Revisiting 
a.tomic commitment and consensus 
ings of the Workshop on Distributed 
Springer Verlag (LNCS 972), 1995. 
Algorithms, 
the relationship 
between the 
problems. Proceed­
(9] R. Guerraoui. On the Hardness of Failure Sensitive 
Processing Letters, 
Agreement Problems. Information 
79, 2001. 
(10) V. Hadzilacos. On the rela/ionship 
commitment and 'consensus 
the Workshop on Fault-Tolerant 
ing, Springer Verlag (LNCS 448), 1986. 
Distributed 
of 
Comput­
between .. the atomic 
problems. Proceedings 
(11] V. Hadzilacos and S. Toueg. Fault-Tolerant 
Broad­
Tech­
casts and Related Problems. Cornell  University, 
1994. Also in Distributed 
nical Report (TR 94·1425), 
Systems, S. Mullender (ed), Addison-Wesley, 1993. 
[12/ J. Halpern and A. Ricciardi. A Knowledge-Theoretic 
Analysis of Uniform Distributed 
ure Detectors. Proceedings 
Principles of Distributed 
Coordination 
and Fail­
of 1jhe ACM Symposium on 
Computing, 1999. 
352 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:21:30 UTC from IEEE Xplore.  Restrictions apply. 
[13\ L. Lamport, M. Pease and R. Shostak. The Byzantine 
Generals Problem. ACM Transactions 
Languages and Systems 4 (3), July 1982. 
on Programming 
[14\ D. Powell (editor). 
cations. Communications 
Special issue on Group Communi­
of the ACM, 39 (4), 1996. 
[15J G. Tel. Topics in Distributed 
Algorithms. Cambridge 
International 
Series, 1991. 
[16] P. Verissimo, A. Casimiro and C. Fetzer. The Timely 
Computing Base: Timely Actions in the Presence of 
Proceedings of the IEEE Inter­
Uncertain Timeliness. 
national Symposium on Dependable Systems and Net­
works (DSN), 2000. 
353 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:21:30 UTC from IEEE Xplore.  Restrictions apply.