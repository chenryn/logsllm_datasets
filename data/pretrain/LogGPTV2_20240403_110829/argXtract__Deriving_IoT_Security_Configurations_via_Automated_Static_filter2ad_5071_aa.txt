title:argXtract: Deriving IoT Security Configurations via Automated Static
Analysis of Stripped ARM Cortex-M Binaries
author:Pallavi Sivakumaran and
Jorge Blasco
argXtract: Deriving IoT Security
Configurations via
Automated Static Analysis of Stripped ARM
Cortex-M Binaries
Pallavi Sivakumaran
Royal Holloway, University of London
Egham, United Kingdom
PI:EMAIL
Jorge Blasco
Royal Holloway, University of London
Egham, United Kingdom
PI:EMAIL
ABSTRACT
Recent high-profile attacks on the Internet of Things (IoT) have
brought to the forefront the vulnerabilities in “smart” devices, and
have revealed poor device configuration to be the root cause in
many cases. This has resulted in IoT technologies and devices being
subjected to numerous security analyses. For the most part, auto-
mated analyses have been confined to IoT hub or gateway devices,
which tend to feature traditional operating systems such as Linux
or VxWorks. However, most IoT peripherals, by their very nature of
being resource-constrained, lacking traditional operating systems,
implementing a wide variety of communication technologies, and
(increasingly) featuring the ARM Cortex-M architecture, have only
been the subject of smaller-scale analyses, typically confined to a
certain class or brand of device. We bridge this gap with argXtract,
a framework for performing automated static analysis of stripped
Cortex-M binaries, to enable bulk extraction of security-relevant
configuration data. Through a case study of 200+ Bluetooth Low
Energy binaries targeting Nordic Semiconductor chipsets, as well
as smaller studies against STMicroelectronics BlueNRG binaries
and Nordic ANT binaries, argXtract has discovered widespread
security and privacy issues in IoT, including minimal or no pro-
tection for data, weakened pairing mechanisms, and potential for
device and user tracking.
CCS CONCEPTS
• Security and privacy → Distributed systems security.
KEYWORDS
IoT, Firmware Analysis, Stripped Binaries, ARM, Cortex-M, Blue-
tooth Low Energy, ANT, Nordic, STMicroelectronics
ACM Reference Format:
Pallavi Sivakumaran and Jorge Blasco. 2021. argXtract: Deriving IoT Se-
curity Configurations via Automated Static Analysis of Stripped ARM
Cortex-M Binaries. In Annual Computer Security Applications Conference
(ACSAC ’21), December 6–10, 2021, Virtual Event, USA. ACM, New York, NY,
USA, 16 pages. https://doi.org/10.1145/3485832.3488007
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
ACSAC ’21, December 6–10, 2021, Virtual Event, USA
© 2021 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-8579-4/21/12...$15.00
https://doi.org/10.1145/3485832.3488007
1 INTRODUCTION
The Internet of Things (IoT) is growing at a rapid pace, with an
estimated 22 billion connected IoT devices in use around the world
at the end of 2018, and projected to grow to 50 billion by 2030 [75].
These devices are increasingly handling users’ personal data and
health information, and performing security-related functions. It is
therefore imperative to fully understand the security and privacy
implications of IoT deployments.
Recent years have shown that there is legitimate cause for con-
cern, as numerous flaws have been uncovered in IoT devices, some
of which have been exploited at a large-scale (e.g., Mirai [22],
Brickerbot [64]). Severe vulnerabilities have also been discovered
in cardiac devices [45], baby heart monitors [80] and webcams [74].
The root cause on many occasions was poor device configuration,
e.g., default passwords [5, 51] or poor protection for data [53, 91].
The configuration of an IoT device can therefore be a vital source
of information regarding possible vulnerabilities, and the device
firmware is often the most definitive source of information regard-
ing its configuration. However, analysing IoT firmware is notori-
ously difficult, particularly in the case of peripheral firmware files,
which are often only available as stripped binaries, i.e., files that do
not contain headers, section information or debugging symbols. Ad-
ditionally, many IoT peripheral devices now utilise ARM Cortex-M
processors [9]. These feature inline data and instruction sets that
are not yet fully supported by current disassemblers, which greatly
complicates analysis [41].
In this work, we present argXtract, a framework for bulk extrac-
tion of security-relevant configuration information from stripped
ARM Cortex-M binaries via a partial-knowledge automated static
analysis. argXtract overcomes various challenges associated with
analysing stripped Cortex-M binaries and provides a generic frame-
work for extracting arguments to a Call Of Interest (COI); this can
be an ARM supervisor call or a standard function call, identified
via svc instructions and function pattern matching, respectively.
We also present three case studies, selected based on the avail-
ability of real-world Cortex-M binaries, where we use argXtract to
analyse the security configurations from: (i) binaries implementing
Bluetooth Low Energy (BLE) and targeting Nordic Semiconduc-
tor chipsets, where configurations are made via supervisor calls,
(ii) binaries implementing BLE and targeting STMicroelectronics
BlueNRG chipsets, where configurations are made via function
calls, and (iii) binaries implementing the ANT [33] technology and
targeting Nordic chipsets, with configurations via supervisor calls.
The results reveal widespread security issues in IoT peripherals,
including minimal or no protection for data, inconsistent permis-
sions, artificially weakened pairing mechanisms, and the potential
for tracking devices (and possibly also users).
861ACSAC ’21, December 6–10, 2021, Virtual Event, USA
Pallavi Sivakumaran and Jorge Blasco
We summarise our main contributions as follows:
• We develop argXtract, a framework for performing auto-
mated static analysis of stripped ARM Cortex-M binaries, to
enable extraction of security-related configuration informa-
tion (§3). We evaluate argXtract in terms of the accuracy
of function boundary estimation and pattern matching, and
correctness of extracted results (§4).
• We use argXtract to extract security configurations from
stripped Nordic BLE binaries (§5), STMicroelectronics’ Blu-
eNRG binaries and Nordic ANT binaries (§6). The results
reveal widespread lack of protection for data, inconsistent
data access controls and serious privacy vulnerabilities.
• We make argXtract available as open source code for the
benefit of the research community at https://github.com/
projectbtle/argXtract. The repository includes configuration
files for case studies presented in this paper.
2 MOTIVATION
Configuration issues have been the root cause for several recent at-
tacks on IoT devices. For example, Mirai exploited the use of default
credentials to infect IoT devices [5], while some baby monitors,
vaping products and e-skateboards did not implement basic protec-
tion for their data [52, 53, 91]. This left the devices vulnerable to
false data injection and the potential for physical harm to the user.
The configuration of an IoT device can therefore reveal exploitable
vulnerabilities and is a vector of interest in security analyses.
There are several possible sources for this configuration informa-
tion, including the devices themselves, the firmware they run, or any
application or website they interface with. We analyse the merits
and shortcomings of each of these potential sources in Appendix A.
Arguably, firmware is the richest standalone source of information
regarding a device’s security configuration. With devices such as
IoT hubs and gateways (e.g., mobile phones, routers), which often
run some version of the Linux OS, familiar filesystem structures
and commands may be identifiable within firmware, which can
contribute towards the analysis. Even so, the analysis will generally
not be straightforward. Analysis is much more complex for IoT
peripherals, which may run a custom OS, or have no OS at all. This
has resulted in far fewer analyses of IoT peripheral binaries. We
bridge this gap by focusing on peripheral firmware analysis.
IoT peripherals may implement one or more communication
technologies, such as BLE [16], Zigbee [93], ANT [33] or Thread [81].
Many of these technologies have fully-fledged stacks, which must
be implemented within peripheral firmware. To ease development,
many IoT chipset vendors implement the technology stacks them-
selves and provide APIs through which developers can configure
the stacks within their applications [57, 78, 79]. Developers may
also use library functions to perform other configurations.
We present an example configuration function in Figure 1a,
where a fixed passkey is defined for the BLE pairing process using
an API call sd_ble_opt_set. Fixed passkeys reduce the security
of BLE pairing and are therefore a vulnerability of interest. To iden-
tify fixed passkeys from firmware, we need to determine whether
sd_ble_opt_set (which we term a Call Of Interest, or COI) is
called with a fixed passkey as its argument. To do this, we need
to pinpoint the location of the COI within the firmware binary,
uint8_t passkey [] = "123456";
ble_opt_t ble_opt ;
ble_opt . gap_opt . passkey . p_passkey = & passkey [0];
err_code = sd_ble_opt_set ( BLE_GAP_OPT_PASSKEY , & ble_opt );
(a) Source C code.
r2 , [pc , #736] ; (1 ed9c )
r3 , sp , #24
r1 , [r2 , #0]
1 eaba : 4 ab8
1 eabc : ab06
1 eabe : 6811
1 eac0 : 2022
1 eac2 : 9106
1 eac4 : 8891
1 eac6 : 8099
1 eac8 : 7992
1 eaca : a908
1 eacc : 719 a
1 eace : 9308
1 ead0 : f7fffe3a bl
r1 , [sp , #24]
ldr
add
ldr
movs r0 , #34 ; 0 x22
str
ldrh r1 , [r2 , #4]
strh r1 , [r3 , #4]
ldrb r2 , [r2 , #6]
add
strb r2 , [r3 , #6]
str
r1 , sp , #32
r3 , [sp , #32]
1 e748 
1 ed9c : 00021 f14 . word
0 x00021f14
21 f0c : 2528 2000 0001 0700 3231 3433 3635 0000
(b) Disassembly of unstripped binary.
r1 , [sp , #0 x18 ]
r2 , [pc , #0 x2e0 ]
r3 , sp , #0 x18
r1 , [ r2 ]
ldr
add
ldr
movs r0 , #0 x22
str
ldrh r1 , [r2 , #4]
strh r1 , [r3 , #4]
ldrb r2 , [r2 , #6]
add
strb r2 , [r3 , #6]
str
r1 , sp , #0 x20
r3 , [sp , #0 x20 ]
#0 x3748
0 x3aba : b84a
0 x3abc : 06 ab
0 x3abe : 1168
0 x3ac0 : 2220
0 x3ac2 : 0691
0 x3ac4 : 9188
0 x3ac6 : 9980
0 x3ac8 : 9279
0 x3aca : 08 a9
0 x3acc : 9 a71
0 x3ace : 0893
0 x3ad0 : fff73afe bl
0 x3d9c : 141 f
0 x3d9e : 0200
0 x6f14 : 3132
0 x6f16 : 3334
0 x6f18 : 3536
subs r4 , r2 , #4
movs r2 , r0
adds r2 , #0 x31
adds r4 , #0 x33
adds r6 , #0 x35
(c) Disassembly of stripped binary.
Figure 1: Disassembly for stripped vs. unstripped binary.
and then analyse the arguments that are passed to it. Figure 1b
depicts the assembly instructions corresponding to this section of
code, obtained by disassembling the firmware binary. From the
instructions, we are able to identify that the function call occurs at
address 0x1ead0, that the passkey bytes occur at address 0x21f14
(as 323134333635 [little-endian], i.e., “123456”), and that they are
referenced by their absolute location at address 0x1ed9c. The abil-
ity to correctly deduce these pieces of information depends on a
set of conditions:
C1 Knowledge of function location and callers’ addresses (i.e.,
knowing that the code for sd_ble_opt_set is at address
0x1e748 and that it is called at address 0x1ead0).
C2 Knowledge of locations of inline data (i.e., knowing that the
bytes at addresses 0x1ed9c and 0x21f0c should be inter-
preted as data rather than as code).
C3 Firmware being loaded at the correct offset/application code
base (such that the absolute address 0x21f14 results in bytes
being loaded from the correct location).
This information is present within headers and symbol tables.
However, due to storage considerations, IoT peripherals tend to
ship firmware with this information removed, i.e., as stripped bina-
ries. Figure 1c depicts the disassembly of the binary file with ELF
862argXtract: Automated Analysis of Stripped IoT Binaries
ACSAC ’21, December 6–10, 2021, Virtual Event, USA
headers and debugging symbols stripped out. The disassembly of
the stripped binary does not contain information about function
names (failing Condition C1), thereby making it difficult to deduce
functionality. Also, data segments have been incorrectly interpreted
by the disassembler as code (failing Condition C2),1 which leads
to incorrect results when performing value tracing and precludes
the use of emulation frameworks (e.g., QEMU [13], unicorn [63]).
Further, the code has been loaded at the incorrect offset (failing
Condition C3), which means absolute addressing will fail.
Contributing to this problem is the fact that many resource-
constrained IoT devices feature ARM processors [50] with Thumb
or Thumb-2 instruction sets (instead of the ARM instruction set)
for greater code density [35]. In fact, the ARM Cortex-M architec-
tures, which are very popular in embedded systems [9], support
only the Thumb and Thumb-2 instruction sets. These instruction
sets are not yet fully supported by many disassemblers. Out of the
current state-of-the-art reverse-engineering tools, IDA (free) [38]
does not currently support ARM, while Debin [37] and BAP [18] do
not fully support the Thumb instruction set. Testing free reverse-
engineering tools that do support Thumb analysis against a simple
stripped Cortex-M IoT binary, we found that radare2 [2] failed to
identify almost 40% of the functions within the binary (analysing
using aaa and aaaa), Ghidra [55] failed to identify 30% of the func-
tions, while angr [83] was unable to produce a valid Control Flow
Graph - a step prior to analysis. Our observation regarding the
robustness of angr and radare2 for Thumb mode analysis is sup-
ported by [41], which also noted that Ghidra too has better support
for the ARM instruction set than for Thumb. Further, because IoT
peripheral binaries typically do not include the technology stack
or ROM data, dynamic analysis approaches are unsuitable. This
reveals a gap in the automated IoT security analysis landscape and
prompted the development of argXtract.
3 ARGXTRACT
We design argXtract to take as input the disassembly of a Cortex-M
binary,2 perform several levels of processing, and finally extract
and output arguments to security-relevant Calls Of Interest. The
processing is divided into the following stages: Application code
base identification, for correct absolute addressing (§3.1); Data
identification, such that data is not incorrectly interpreted as code
(§3.2); Function block identification, to enable call execution
path generation and function pattern matching (§3.3); COI identi-
fication (function call or ARM supervisor call), to determine trace
termination points (§3.4); Tracing and argument processing, to
extract and process the arguments to a COI (§3.5).
3.1 Application Code Base Identification
As described in §2, an incorrect address offset will lead to the failure
of absolute addressing. argXtract combines known address infor-
mation with obtained addresses to compute the application code
base. The addresses of core interrupt handlers are known, as they
are present at specific offsets within the Vector Table (VT), which is
1Note that inline data is far more common in ARM than in x86/x64 [41], and the
misinterpretation of such data as code is a problem that is encountered even with