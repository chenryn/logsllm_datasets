as suggested in Intuition 3. Finally, it prioritizes seeds with smaller
size and faster execution time, same as AFL’s default policy.
4.3 Diverging Inputs Filtering
With layout-oriented fuzzing, Revery could find diverging in-
puts able to trigger the same layout-contributor slice as the PoC
input. However, unlike layout-contributor digraph, the data flow
constraints are missing in the layout-contributor slice. So the diverg-
ing inputs sometimes do not match the target layout-contributor
digraph built from the crashing path. Revery thus takes an extra
step to isolate diverging inputs that could match the target layout-
contributor digraph.
In general, it first aligns the diverging path with the crashing
path, and locates the instructions responsible for creating the excep-
tional object. Then, it constructs a new layout-contributor digraph
of the exceptional object from the diverging path by backward slic-
ing, in a same way as the crashing path. Finally, it matches this
new digraph against the target digraph, by comparing each node’s
memory tag and its creator instruction’s address in two digraphs.
Figure 7 shows an example of how the match works.
If these two digraphs do not match, then this diverging input
will be discarded. Otherwise, the diverging input is kept. Moreover,
Seed queueSelect SeedMutateIdentifySeedsseedDivergingInputsQEMUTarget Binary ApplicationseedseedTestcasesInitialInputscode coverageslice hittest casesdiverging pathslayout-contributor digraphtargetlayout-contributor digraphcrashing pathMatch & AlignSession 9D: VulnDet 1CCS’18, October 15-19, 2018, Toronto, ON, Canada1920and diverging inputs to further reduce complicated constraints,
making symbolic execution more practical.
Figure 8 shows the general workflow of exploit synthesis. In
practical, it first identifies stitching points, and then explores sub-
paths between stitching points and synthesize exploitation path,
and finally solve related constraints to generate working exploits.
5.1 Identify Stitching Points
We first introduce how Revery identifies stitching points in both
the crashing path and diverging path.
Stitching Points in the Crashing Path. In order to successfully
5.1.1
exploit the victim program, its vulnerability must be first triggered,
and some exceptional objects are corrupted. Revery thus chooses
locations where exceptional objects are corrupted in the crashing
path as stitching points.
As mentioned in Section 3.2.1, in the crashing path, each write
access violation corrupts an exceptional object, and thus it is a
candidate stitching point. For each read access violation in a UAF
vulnerability, the exceptional object is the one that has been freed
but still pointed by the dangling pointer. This exceptional object’s
memory region will be occupied by another memory allocation.
Revery takes the new memory allocation operation as a candidate
stitching point.
Since there could be multiple violations in one crashing path,
there could also be multiple stitching points. Revery will try to
stitch each of them with the diverging path.
Stitching Points in Diverging Paths. In order to successfully
5.1.2
exploit the victim program, exploitable operations must be per-
formed on corrupted exceptional objects or collateral objects.
What are good stitching points? Every instruction could be used
as stitching points. But not all of them are good ones. A proper
stitching point should satisfy several criterions:
• Not too close to entry points. Otherwise, many duplicated opera-
tions as the crashing path will be performed. Since duplicate
operations (e.g., object initializations) will not happen in a le-
gitimate control flow, it is infeasible to find a path to connect
this stitching point with its counterpart in the crashing path.
• Not too close to exploitable points. Otherwise, a longer path is
required to connect this stitching point with its counterpart,
requiring more efforts of symbolic execution. The stitching
point can be set before certain operations, e.g., initialization of
exploitable points’ operands, to save symbolic execution efforts.
• Minimum data dependency. The data flow after the stitching
point in the diverging path should have few intersections with
the data flow before the stitching point in the crashing path.
How to find stitch points? At a high level, Revery matches the
diverging path’s data dependency against the crashing path’s, and
locates the differences. Then it uses the instruction which causes
the differences in the diverging path as stitching point.
First, Revery builds the layout-contributor digraph of the ex-
ploitable operation’s operand in the diverging path. Then it matches
this digraph against the digraph of the exceptional object in the
crashing path. If the former is a sub-graph of the latter, it means
the crashing path has already set up all data dependencies for the
exploitable operation. Then, the instruction in the diverging path,
Figure 8: The workflow of exploit synthesis
these two digraphs’ nodes (i.e., heap objects) will be aligned accord-
ingly, as well as the memory tags of all nodes. So, we could infer
each object’s counterpart between the diverging path and crashing
path, enabling further common analysis on these two paths.
4.4 Exploitable States Searching
Even if the diverging paths have similar layouts as the vulner-
ability, not all of them are exploitable. Revery further removes
diverging paths that do not have exploitable states.
4.4.1 Exploitable State. The exceptional object could affect other
objects, and sometimes will be directly or indirectly used in some
sensitive operations. The program states resulting from these sen-
sitive operations are denoted as exploitable states.
In this paper, we mainly consider two types of sensitive (ex-
ploitable) operations, i.e., memory write and indirect call. For ex-
ample, if the target address of a memory write is affected by the
exceptional object, then attackers may control where to write and
cause AAW (arbitrary address write), i.e., a commonly used ex-
ploitable state in practice. If attackers could affect the target of
indirect calls, including virtual function calls and indirect jmp in-
structions etc., then they could hijack the control flow. In addition,
Revery offers a template for experts to extend the definition of
exploitable points, e.g., operations launching the unlinking attack.
4.4.2 Exploitable States Searching. This problem thus becomes
identifying sensitive instructions whose operands are affected by
the exceptional objects. Taint analysis is a straightforward solution.
Revery marks each object creation operation as a taint source,
and attaches a unique taint label to it. Each operation propagates all
source operands’ taint labels to the destination. At each sensitive
instruction (i.e., memory write or function call), the target address’
taint labels will be checked if they contain the exceptional object’s
taint label. If yes, then this sensitive instruction is exploitable.
5 EXPLOIT SYNTHESIS
In this section, we will introduce how to synthesize new exploits
from PoC inputs and diverging inputs.
Once an exploitable state is found in a path, existing AEG solu-
tions usually generate exploits by solving the path, vulnerability
and exploit constraints. However, as discussed in Section 4.1, sym-
bolic execution solely is not effective in exploit generation.
Therefore, Revery uses symbolic execution as few as possible.
It uses a lightweight symbolic execution as a bond to stitch the
crashing path and diverging path together, and reuses the PoC input
Exploitation Pathcrashing pathdiverging pathbackwardIndentify Stitching PointsSymbolicexplorationfrom PoCfrom diverging inputPath StitchingVulnerability ConstraintsState ConstraintsPayload ConstraintsPath ConstraintsExploitGenerationSession 9D: VulnDet 1CCS’18, October 15-19, 2018, Toronto, ON, Canada1921vulnerability constraints, path constraints and exploit constraints
to generate final exploit samples. However, it is inadequate.
5.3.1 Exploitable State Constraints. Simply solving constraints of
the exploitation path may not trigger the same exploitable state
as the diverging path. Revery thus adds several extra data con-
straints to the exploitation path, ensuring the program state is still
exploitable.
First, the memory allocation sizes in the exploitation path should
be the same as the diverging path, in order to trigger the exploitable
states as in the diverging path. Revery records the concrete sizes of
all memory allocations when analyzing the diverging path. In the
exploitation path, if a memory allocation which was in the diverging
path has a symbolic size, then Revery will add a constraint to ensure
this size equals to the concrete value in the diverging path.
Second, Revery will align the digraph of the crashing path with
the diverging path’s. Certain symbolic addresses in the diverging
path are logically the same as their counterparts in the crashing
path. So, in the stitched exploitation path, extra constraints must be
introduced to claim the equality between these symbolic addresses.
5.3.2 Payload Constraints. With the aforementioned exploitable
state constraints, together with the vulnerability and path con-
straints, Revery is able to generate EXP inputs to trigger both ex-
ploitable states and vulnerabilities. These inputs could help security
experts to construct a full exploit.
In certain cases, Revery is able to directly generate working
exploits. At the exploitable point, Revery could construct payload
constraints which could lead to control flow hijacking. If the ex-
ploitable point is a function call (e.g., indirect call or jmp instruction)
and its target is a symbolic value, Revery adds an extra constraint
to set the target to attacker controlled value. If the exploitable state
is a write access, and both the destination address and content to
write are symbolic, then Revery adds an extra constraint to over-
write a known address (e.g., Global Offset Table entries or global
function pointers) with attacker controlled value.
In this way, Revery could generate exploits to hijack control-flow
for certain cases. However, it is not always guaranteed to succeed.
6 EVALUATION
We implemented a prototype of Revery based on the binary anal-
ysis engine angr [34] and the popular fuzzer AFL [41]. It consists
of 1334 lines of code to analyze vulnerabilities, 190 lines of code
to explore diverging paths with fuzzing, and 1249 lines of code to
stitch paths and generate exploits.
In this section, we present the evaluation results of this system.
The experiments are conducted in a Ubuntu 17.04 system running
on a server with 115G RAM and Intel Xeon (R) CPU E5-2620 @
2.40GHz*24. We evaluated Revery against 19 vulnerable programs
collected from 15 CTF (capture the flag) competition, 14 of them
can be found in CTFTIME [1]. 1
To thoroughly evaluate the effectiveness of Revery, we selected
the target programs from CTF events based on the following rules:
(1) no source code or debug symbols exist for these programs; (2)
Figure 9: Example call stacks of stitching points
which is right after the last write access to the exploitable opera-
tions’ operands, is chosen as the stitching point.
Otherwise, there are different nodes or edges in the diverging
path’s digraph, i.e., the diverging path has alternated the depen-
dency of the exploitable operations. In this case, Revery chooses
the earliest instruction (object creation or write) in the diverging
path, which causes differences in the digraph, as the stitching point.
5.2 Control-Flow Path Stitching
In order to stitch the crashing path and the diverging path to-
gether, Revery explores potential sub-paths connecting the stitch-
ing points in these paths. In general, it relies on symbolic execution
to explore paths. However, Revery utilizes several heuristics to
efficiently guide symbolic execution.
First of all, Revery uses the function call stack to guide the path
exploration. It inspects the call stacks at the two stitching points
respectively, and finds the differences. Figure 9 shows two example
call stacks. These differences in call stacks indicate the direction of
path exploration. Function invocations in the crashing path (e.g.,
g1, g2, ..., gM in the figure) should be returned one by one
first, while function invocations in the diverging path (e.g., h1, h2,
..., hK in the figure) should be called one by one later.
In other words, when exploring potential paths, Revery will
add the return instruction of function gM, ..., g2, g1 as target
instructions one by one, and then add the entry point of function
h1, h2, ..., hK as target instructions one by one. These tar-
get instructions are dominator points between the two stitching
points. Then Revery will explore potential sub-paths between these
intermediate target instructions.
Revery further mitigates the sub-path exploration by reusing
existing paths. For example, if there is already a sub-path connect-
ing two intermediate destinations in either the diverging path or
the crashing path, Revery will reuse this sub-path. Revery also per-
forms a simple loop identification algorithm, and finds a sub-path
to escape the loop as soon as possible, in order to reduce the bur-
den of symbolic execution. Sometimes, the reused sub-path would
cause the overall path unsolvable, Revery will try to remove these
sub-paths and search for alternative sub-paths.
In this way, Revery greatly reduces the burden of symbolic exe-
cution when exploring sub-paths to connect the stitching points.
5.3 Exploit Generation
Once a sub-path connecting two stitching points is found, a can-
didate exploitation path is constructed. Revery could also solve the
1We did not evaluate Revery on CGC programs which have heap-based vulnerabilities
or real world programs, because the binary analysis engine angr [34]’s constraints
solving ability is not enough for complex programs. And we are still working on it.
f1…fNf1…fNg1…gMh1…hKstitching pointin crashing pathstitching pointin diverging pathSession 9D: VulnDet 1CCS’18, October 15-19, 2018, Toronto, ON, Canada1922Name
woO2
woO2_fixed
shop 2
main
babyheap
b00ks
marimo
ezhp
note1
note2
note3
fb
stkof
TU CTF 2016
TU CTF 2016
ASIS Final 2015
RHme3 CTF 2017
SECUINSIDE 2017
ASIS Quals 2016
Codegate 2018
Plaid CTF 2014
ZCTF 2016
ZCTF 2016
ZCTF 2016
AliCTF 2016
HITCON 2014
simple note
childheap
CarMarket
SimpleMemoPad
Tokyo Westerns 2017
SECUINSIDE 2017
ASIS Finals 2016
CODEBLUE 2017
LFA
Recurse
34c3 2017
33c3 2016
CTF
Vul Type
Crash Type Violation
heap error
heap error
mem read
mem read
mem read
no crash
no crash
no crash
no crash
no crash
no crash
no crash
no crash
no crash
heap error
no crash
no crash
no crash
no crash
V1
V1
V1
V1
V1
V1
V1
V1
V1
V1
V1
V1
V1
V1
V1
V1
-
-
-
Final State
EIP hijack
EIP hijack
EIP hijack
mem write
mem write
mem write
mem write
mem write
mem write
unlink attack
unlink attack
unlink attack
unlink attack
unlink attack
-
-
-
-
-
EXP. Gen.
YES
YES
YES
YES
YES