call *0x18(%ebx)
call *0xec(%ecx)
call *0x18(%ebx)
call *0x18(%ecx)
call *0xfc(%ebx)
call *0xfc(%ebx)
call *0x2c(%edx)
call *%esi
call *0xf8(%ebx)
call *%edx
call *0x108(%ebx)
call *%ebx
call *%ebx
call *%esi
call *%edx
0xc0155f33
call *0xc4(%ecx)
sys write
sys open
sys close
sys ioctl
sys mmap2
sys fstat64
sys getdents6
sys getdents64
sys fcntl64
Kernel Hooks
address
sys call table[4]
selinux ops[59]
tty fops[4]
dummy con[33]
tty ldisc N TTY.write chan
con ops[3]
con ops[5]
con ops[4]
con ops[2]
vga con[7]
sys call table[5]
selinux ops[60]
ext3 dir inode operations[13] (ext3.ko)
selinux ops[47]
capability ops[47]
sys call table[6]
ext3 dir operations[14] (ext3.ko)
selinux ops[61]
sys call table[54]
tty fops[8]
selinux ops[62]
con ops[7]
tty ldisc N TTY.n tty ioctl
sys call table[192]
selinux ops[63]
selinux ops[11]
mm→get unmapped area
capability ops[6]
capability ops[63]
sys call table[197]
selinux ops[49]
sys call table[114]
selinux ops[59]
ext3 dir operations[6] (ext3.ko)
ext3 dir inode operations[3] (ext3.ko)
sys call table[220]
selinux ops[59]
ext3 dir operations[6] (ext3.ko)
ext3 dir inode operations[3] (ext3.ko)
sys call table[221]
selinux ops[66]
program slicing algorithm [5] to ﬁnd out a memory location that is associated with
a kernel object (including a global static variable) and whose content determines the
register value. To do that, we follow the algorithm by ﬁrst computing two sets for
Countering Persistent Kernel Rootkits through Systematic Hook Discovery
31
#line machine code       instruction             DEF        USE
====  =============    ====================    ========    =====
i-1 : ...
i+0 : 89 c3             mov    %eax,%ebx        %ebx       %eax                   
i+1 : 83 ec 04          sub    $0x4,%esp        %esp       %esp 
i+2 : 8b 80 c4 00 00 00 mov    0xc4(%eax),%eax  %eax       mem[%eax+0xc4], %eax
i+3 : f6 c2 03          test   $0x3,%dl         eflags     %dl  
i+4 : 89 04 24          mov    %eax,(%esp)      mem[esp]   %eax   
i+5 : 74 0e             je     c016b713                    eflags
i+6 : 8b 40 24          mov    0x24(%eax),%eax  %eax       mem[%eax+0x24], %eax  
i+7 : 8b 50 0c          mov    0xc(%eax),%edx   %edx       mem[%eax+0xc],  %eax    
i+8 : 85 d2             test   %edx,%edx        eflags     %edx 
i+9 : 74 04             je     c016b713                    eflags
i+10: 89 d8             mov    %ebx,%eax        %eax       %ebx 
i+11: ff d2             call   *%edx            %eip       %edx 
i+12: ...
Fig. 3. Discovering a kernel hook based on dynamic program slicing
each related instruction: one is DEF [i] that contains the variable(s) deﬁned by this
instruction, and another is U SE[i] that includes all variables used by this instruction.
Each set can contain an element of either a memory location or a machine register. After
that, we then examine backwards to ﬁnd out the memory location that is occupied by
a kernel object and whose content determines the register value. In the following, we
will walk-through the scheme with an example. (For the classic algorithm, interested
readers are referred to [5] for more details.)
Figure 3 shows some sequential kernel instructions7 of a kernel function mark
inode dirty that are executed in the sys getdent64 context of the ls command. In par-
ticular, the sequence contains an HAP instruction – call *%edx – at the memory lo-
cation 0xc016b711 (line i + 11 in Figure 3). Note that since we monitor at run-time,
we can precisely tell which memory locations/registers are deﬁned and/or used. As a
result, we directly derive the corresponding destination address (contained in the %edx
register), which is 0xc885bca0 – the entry point of a function ext3 dirty inode within
a LKM named ext3.ko. Obviously, it is the destination address the HAP instruction
will transfer to, not the relevant kernel hook. Next, our prototype further expands the
associated semantics of every executed instruction i to compute the two sets DEF [i]
and U SE[i] and the results are shown in Figure 3. With the two sets deﬁned for each
instruction, we can then apply the dynamic slicing algorithm. Speciﬁcally, from the
HAP instruction (line i + 11), the U SE set contains the %edx register, which is deﬁned
by the instruction at line i + 7. This particular instruction is associated with a U SE
set having two members: %eax and mem[%eax+0xc]. It turns out the %eax points
to the kernel object ext3 dir inode operations and 0xc is an offset from the kernel
object. After identifying the responsible kernel object, the slicing algorithm then out-
puts ext3 dir inode operations[3] as the corresponding kernel hook and terminates. In
Table 1, this is the fourth kernel hook identiﬁed in the sys getdent64 context. Note that
this particular kernel object is a jump table containing a number of function pointers.
The offset 0xc indicates that it is the fourth member function in the object as each
function pointer is four bytes in size. (The ﬁrst four member functions in the kernel
object are in the offsets of 0x0, 0x4, 0x8, and 0xc, respectively.)
7 These instructions are in the AT&T assembly syntax, where source and destination operands,
if any, are in the reverse order when compared with the Intel assembly syntax.
32
Z. Wang et al
5 Evaluation
In this section, we present the evaluation results. In particular, we conduct two sets
of experiments. The ﬁrst set of experiments (Section 5.1) is to monitor the execu-
tion of various security programs and identify those kernel hooks that can be poten-
tially hijacked for hiding purposes. The second set of experiments (Section 5.2) is to
Table 2. Process-hiding kernel hooks obtained by monitoring the ps -ef command in RedHat
Fedora Core 5
execution path
# kernel hooks
sys read
17
sys write
sys open
11
20
sys close
10
sys time
sys lseek
sys ioctl
sys mprotect
sys getdents8
sys getdents64
sys mmap2
2
2
5
3
3
3
8
sys stat64
16
Details
sys call table[3], selinux ops[5], selinux ops[59],
capability ops[5], kern table[336], timer pmtmr[2],
proc info ﬁle operations[2], proc ﬁle operations[2],
proc sys ﬁle operations[2], proc tty drivers operations[2],
tty drivers op[0], tty drivers op[1], tty drivers op[2],
tty drivers op[3], proc inode.op.proc read,
simple ones[1].read proc, simple ones[2].read proc
sys call table[4], selinux ops[59], dummy con[33], tty fops[4],
con ops[2], con ops[3], con ops[4], con ops[5],
vga con[6], vga con[7], tty ldisc N TTY.write chan
sys call table[5], selinux ops[34], selinux ops[46],
selinux ops[47], selinux ops[60], selinux ops[88],
selinux ops[112], capability ops[46], capability ops[47],
pid base dentry operations[0], proc sops[0], proc sops[2],
proc root inode operations[1], proc dir inode operations[1],
proc self inode operations[10], proc sys ﬁle operations[12] ,
proc tgid base inode operations[1], proc tty drivers operations[12],
ext3 dir inode operations[13] (ext3.ko), ext3 ﬁle operations[12] (ext3.ko)
sys call table[6], selinux ops[35], selinux ops[50],
selinux ops[61], pid dentry operations[3],
proc dentry operations[3], proc tty drivers operations[14],
proc sops[1], proc sops[6], proc sops[7]
sys call table[13], timer pmtmr[2]
sys call table[19], proc ﬁle operations[1]
sys call table[54], tty fops[8], selinux ops[62],
con ops[7], tty ldisc N TTY.n tty ioctl
sys call table[125], selinux ops[64], capability ops[64]
sys call table[141], selinux ops[59], proc root operations[6]
sys call table[220], selinux ops[59], proc root operations[6]
sys call table[192], selinux ops[63], selinux ops[11],
capability ops[6], capability ops[63], ext3 dir inode operations[3] (ext3.ko),
ext3 ﬁle operations[11], mm→get unmapped area
sys call table[195], selinux ops[34], selinux ops[46], selinux ops[47],
selinux ops[49], selinux ops[88], selinux ops[112], capability ops[46],
capability ops[47], ext3 dir inode operations[13] (ext3.ko),
pid base dentry operations[0], pid dentry operations[3],
proc root inode operations[1], proc self inode operations[10],
proc sops[0], proc tgid base inode operations[1]
sys fstat64
sys geteuid32
sys fcntl64
2
1
2
sys call table[197], selinux ops[49]
sys call table[201]
sys call table[221], selinux ops[66]
Countering Persistent Kernel Rootkits through Systematic Hook Discovery
33
Table 3. Network-hiding kernel hooks obtained by monitoring the netstat -atp command in
RedHat Fedora Core 5
execution path
# kernel hooks
Details
sys read
sys write
sys open
sys close
sys munmap
sys mmap2
sys fstat64
8
12
19
9
2
6
2
sys call table[3], selinux ops[59], seq ops.start, seq ops.show,
seq ops.next, seq ops.stop, proc tty drivers operations[2]
sys call table[4], selinux ops[59], dummy con[33],
con ops[2], con ops[3], con ops[4], con ops[5],
tty fops[4], tty ldisc N TTY.write chan,
vga con[6], vga con[7], vga ops[8]
sys call table[5], selinux ops[34], selinux ops[35],
selinux ops[47], selinux ops[50], selinux ops[60],
selinux ops[61], selinux ops[112], capability ops[47],
ext3 dir inode operations[13] (ext3.ko), pid dentry operations[3],
proc root inode operations[1], proc dir inode operations[1],
proc sops[0], proc sops[1], proc sops[2],
proc sops[6], proc sops[7], tcp4 seq fops[12]
sys call table[6], selinux ops[35], selinux ops[50], selinux ops[61],
proc dentry operations[3], proc tty drivers operations[14],
proc sops[1], proc sops[6], proc sops[7],
sys call table[91], mm→unmap area
sys call table[192], selinux ops[11], selinux ops[63], capability ops[6],
capability ops[63], mm→get unmapped area
sys call table[197], selinux ops[49]
empirically evaluate those identiﬁed hooks by analyzing a number of real-world rootkits
and see whether the used kernel hooks are actually a part of the discovered ones8.
5.1 Kernel Hooks
In our experiments, we focus on three types of resources that are mainly targeted
by rootkits: ﬁles, processes, and network connections. To enumerate related kernel
hooks, we correspondingly chose three different utility programs – ls, ps, and net-
stat. These three programs are from the default installation of Red Hat Linux Fedora
Core 5 that runs as a guest VM (with 512M B memory) on top of our system. Our test-
ing platform was a modest system, a Dell PowerEdge 2950 server with Xeon 3.16Ghz
and 4GB memory running Scientiﬁc Linux 4.4. As mentioned earlier, the way to choose
these programs is based on the intuition that to hide a ﬁle (, a process, or a network
connection), a persistent kernel rootkit needs to compromise the kernel-side execution
of the ls (, ps, or netstat) program.
In our evaluation, we focus on those portions of collected traces that are related to
the normal functionality of the security program (e.g., the querying of system states of
interest as well as the ﬁnal result output) and exclude other unrelated ones. For example,
if some traces are part of the loading routine that prepares the process memory layout,