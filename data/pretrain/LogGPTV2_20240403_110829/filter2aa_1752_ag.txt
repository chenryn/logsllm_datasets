### 文件 I/O

#### 2.11.1 虚拟文件系统
虚拟文件系统 (VFS) 是 Linux 内核中用于抽象和统一不同文件系统的模块。它提供了一个通用的接口，使得内核可以处理各种类型的文件系统（如 ext4、FAT 和 NTFS）。VFS 实现了常见的文件操作模型，包括读取、写入和同步等。

VFS 的主要组件包括 inode 和 superblock。inode 存储文件的元数据信息，而 superblock 则存储文件系统的全局信息。通过 VFS，Linux 可以支持多种文件系统，并且提供一致的操作接口。例如，`read()` 和 `write()` 系统调用可以通过 VFS 在不同的文件系统上进行操作。

##### 读取操作
`read()` 系统调用用于从文件中读取数据。在 C 语言中，`read()` 的原型如下：
```c
ssize_t read(int fd, void *buf, size_t count);
```
该调用从文件描述符 `fd` 中读取最多 `count` 个字节的数据，并将其存储到缓冲区 `buf` 中。如果成功，返回实际读取的字节数；如果到达文件末尾，返回 0；如果发生错误，返回 -1 并设置 `errno`。

VFS 在处理 `read()` 调用时，会根据具体的文件系统类型和文件内容，将数据从磁盘或其他存储介质读取到内存中。然后，这些数据会被复制到用户进程的缓冲区中。

##### 写入操作
`write()` 系统调用用于向文件中写入数据。其原型如下：
```c
ssize_t write(int fd, const void *buf, size_t count);
```
该调用将 `buf` 中的 `count` 个字节写入文件描述符 `fd` 指定的文件中。如果成功，返回实际写入的字节数；如果发生错误，返回 -1 并设置 `errno`。

VFS 在处理 `write()` 调用时，会将数据从用户进程的缓冲区复制到内核缓冲区，然后根据文件系统的特性，将数据写入磁盘或其他存储介质。

#### 2.11.2 页缓存
页缓存是 Linux 内核中用于提高文件 I/O 性能的一种机制。它利用内存来缓存文件的内容，从而减少对磁盘的访问次数。页缓存基于局部性原理（locality of reference）和时间局部性（temporal locality），能够显著提高文件读写的效率。

当进程读取文件时，内核会首先检查页缓存中是否存在所需的数据。如果存在，则直接从内存中读取；否则，内核会从磁盘读取数据并将其存储在页缓存中。同样，当进程写入文件时，数据会被写入页缓存，而不是立即写入磁盘。内核会在适当的时候将页缓存中的数据刷新到磁盘。

页缓存的大小可以通过 `/proc/sys/vm/swappiness` 参数进行调整。该参数的值范围为 0 到 100，默认值为 60。较低的值表示更倾向于使用物理内存，较高的值表示更倾向于使用交换空间。

#### 2.11.3 页回写
页回写是指将页缓存中的脏页（即被修改但尚未写入磁盘的页）写回到磁盘的过程。内核通过 `pdflush` 进程来管理页回写操作。`pdflush` 会定期检查页缓存中的脏页，并在必要时将其写入磁盘。

`write()` 系统调用在写入数据时，通常不会立即写入磁盘，而是先写入页缓存。只有当页缓存中的脏页数量达到一定阈值或经过一段时间后，`pdflush` 进程才会将这些脏页写入磁盘。

### 结论
Linux 内核提供了强大的文件 I/O 机制，包括虚拟文件系统 (VFS)、页缓存和页回写等。这些机制不仅提高了文件读写的性能，还确保了数据的一致性和可靠性。通过理解和合理使用这些机制，开发者可以编写出高效且可靠的文件 I/O 代码。

---

### 缓冲输入输出

#### 3.1 用户-缓冲 I/O
用户-缓冲 I/O 是指应用程序在进行文件 I/O 时，使用用户空间的缓冲区来提高 I/O 效率。通过调整缓冲区的大小，可以显著提升 I/O 性能。

例如，使用 `dd` 命令进行文件 I/O 测试时，可以通过调整块大小来观察性能差异：

```sh
# 使用 1 字节块大小
dd bs=1 count=2097152 if=/dev/zero of=pirate

# 使用 1024 字节块大小
dd bs=1024 count=2048 if=/dev/zero of=pirate

# 使用 1130 字节块大小
dd bs=1130 count=1888 if=/dev/zero of=pirate
```

通过比较不同块大小下的执行时间，可以看出较大的块大小通常会带来更高的 I/O 效率。

#### 3.1.1 块大小的影响
块大小的选择对 I/O 性能有重要影响。较小的块大小会导致更多的系统调用开销，而较大的块大小则可以减少系统调用次数，提高 I/O 效率。然而，过大的块大小可能会导致内存使用过多，因此需要根据具体情况进行权衡。

#### 3.1.2 标准 I/O
C 语言提供了标准 I/O 库 (stdio)，用于简化文件 I/O 操作。标准 I/O 库提供了一系列函数，如 `fopen()`、`fclose()`、`fgetc()` 和 `fputc()` 等，使得文件操作更加方便和高效。

##### 打开文件
使用 `fopen()` 函数打开文件：
```c
#include <stdio.h>

FILE* fopen(const char *path, const char *mode);
```
`mode` 参数指定文件的打开模式，常用的模式包括：
- `"r"`：只读模式
- `"w"`：写入模式，如果文件存在则清空文件内容
- `"a"`：追加模式，写入的数据会被添加到文件末尾
- `"r+"`：读写模式
- `"w+"`：读写模式，如果文件存在则清空文件内容
- `"a+"`：读写模式，写入的数据会被添加到文件末尾

##### 关闭文件
使用 `fclose()` 函数关闭文件：
```c
int fclose(FILE *stream);
```
关闭文件时，所有未写入的数据会被刷新到磁盘。

##### 从流中读取数据
标准 I/O 库提供了多种读取数据的方法：
- `fgetc()`：读取单个字符
- `fgets()`：按行读取数据
- `fread()`：读取二进制数据

##### 单字节读取
使用 `fgetc()` 函数读取单个字符：
```c
#include <stdio.h>

int fgetc(FILE *stream);
```
该函数从流中读取一个字符并返回其 ASCII 值。如果到达文件末尾，返回 `EOF`。

##### 按行读取
使用 `fgets()` 函数按行读取数据：
```c
#include <stdio.h>

char *fgets(char *str, int size, FILE *stream);
```
该函数从流中读取最多 `size-1` 个字符，并将它们存储在 `str` 中，最后在字符串末尾添加一个空字符 `\0`。

##### 读取二进制文件
使用 `fread()` 函数读取二进制数据：
```c
#include <stdio.h>

size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
```
该函数从流中读取 `nmemb` 个 `size` 大小的数据项，并将它们存储在 `ptr` 指向的缓冲区中。

通过合理使用标准 I/O 库提供的函数，开发者可以编写出高效且易于维护的文件 I/O 代码。