V
词法分析器的代码(第2部分)
E
词法分析器的代码(第1部分)
!=
new
eak:
= b.toString();
Word(Tag.TRUE,
)return w;
{ words.put(t.lexeme, t);}
：
 new Hashtable();
//文件 Lexer.java
）line = line + 1;
"true")
"false"
）；
，10);
第
2章
---
## Page 69
“语句”中的标识符之后都跟着一个冒号和该标识符的类型。
1.6.3节中块结构的例子处理了名字的定义和使用。输入(2.7)仅仅由名字的定义和使用组成。
识符的一次使用。下面是这个语言的一个例子程序：
块组成，每个块包含可选的声明和由单个标识符组成的语句。每个这样的语句都表示对相应标
他的语句和表达式构造都被忽略了，这使得我们可以重点关注符号表的操作。一个程序由多个
录A 中将这个翻译器集成到一起时可以直接使用这个模块。同时，为了简化问题，本节的主要
在此表中有一个对应的条目。
号表，这个块中的每个声明都在此符号表中有一个对应的条目。这种方法对其他能够设立作
为每个作用域建立一个单独的符号表来实现作用域。每个带有声明的程序块都会有自己的符
存储位置和其他相关信息。符号表通常需要支持同一-标识符在一-个程序中的多重声明。
号表的每个条目中包含与一个标识符相关的信息，比如它的字符串（或者词素）、它的类型、它
2.7符号表
2.6.62.6节的练习
格。当下一次调用 scan 时，这个空格会被删除。
v、V。
Tag.ID。最后，第39 行到第 41行将当前字符作为一个词法单元返回，并把 peek 设为一个空
为这个标识符创建一个新条目。
及指向这个词素的指针。只有语法分析器才能够决定是使用之前已创建的符号表条目，还是
条目。但是在更多的情况下，词法分析器只能向语法分析器返回--个词法单元，比如id，以
分析器而言，语法分析器通常更适合创建条目。它可以更好地区分一个标识符的不同声明。
我们让语法分析器来创建这些条目。因为语法分析器知道一个程序的语法结构，因此相对于词法
）比如，在C语言中，程序块要么是一-个函数，要么是函数中由花括号分隔的一个部分，这个部分中有一-个或多个声明。
我们将要完成的任务是打印出一个修改过的程序，程序中的声明部分已经被删除，而每个
信息在编译器的分析阶段被逐步收集并放人符号表，它们在综合阶段用于生成目标代码。
一个简单的语法制导翻译器
本节包括一个符号表模块，它可以和本章中的Java 翻译器代码片段--起使用。当我们在附
符号表(symbol table)是一种供编译器用于保存有关源程序构造的各种信息的数据结构。
练习2.6.3：扩展2.6.5节中的词法分析器，使它能够识别浮点数，比如2．、3.14和.5等。
在有些情况下，词法分析器可以在它碰到组成一个词素的字符串时立刻建立一个符号表
练习 2.6.2:扩展2.6.5 节中的词法分析器，使它能够识别关系运算符<、<=、==、！=、
2）以/＊开始的注释，包括从它到后面第一-次出现的字符序列＊/之间的所有字符。
1）以》开始的注释，包括从它开始到这--行的结尾的所有字符。
练习2.6.1：扩展2.6.5节中的词法分析器以消除注释。注释的定义如下：
{ x { x iA Tooq } A xeu ix quT }
谁来创建符号表条目？
(2.7)
其
特
例
用
的
这
---
## Page 70
于第1行上声明的作用域中。第3行上出现的位于第2行上的声明的作用域中，因为在内
下标并不是标识符的一部分，它实际上是该标识符对应的声明的行号。因此，的所有出现都位
例2.15
是说，从x出现的块开始，从内向外检查各个块时找到的第一个对×的声明。
些块中重新声明。
更进一步，一条语句可以是一个程序块，所以我们的语言支持嵌套的语句块。而标识符可以在这
开来。)在图 2-38 给出的文法中，decls 生成一个可选的声明序列，stmts 生成一个可选的语句序列。
（我们对这个语法中的花括号使用了引号，这么做的目的是将它们和用于语义动作的花括号区分
生成一个程序块时，下面的语法规则会产生嵌套的块：
盖父类中的相应方法。
识符。像×和i这样常见的名字会被重复使用。再例如，子类可以重新声明一个方法名字以覆
指一个或多个声明起作用的程序部分。
2.7.1为每个作用域设置一个符号表
所指定的类型。
类型。我们同时看到，外层块中×和Y的使用的类型分别为整型和字符型，也就是外层块中声明
面跟的是imt，即该声明中的类型。内层块中对y的使用指向同一个块中的声明，因此具有布尔
第一个×和y来自输人(2.7)的内层块。由于×的使用指向外层块中×的声明，因此第-个×后
例2.14
个散列表的所做的修改。
B 中的声明而对此散列表作出的修改。它可以在处理B的时候维护一个辅助的栈来跟踪对这
人和离开块时需要插入和删除相应的条目。在从一个块B离开时，编译器必须撤销所有因为
内嵌块中的某个声明掩盖起来的条目。这样的散列表实际上支持常量时间的查询，但是在进
表。因此，符号表可以按照类似于栈的方式来分配和释放。
成一个栈。在栈的顶部是当前块的符号表。栈中这个表的下方是包含这个块的各个块的符号
如果程序块可以嵌套，那么同一个标识符的多次声明就可能出现在同一个块中。当 stmts 能
语句块的最近嵌套(most-closely)规则是说，一个标识符x在最近的声明的作用域中。也就
作用域是非常重要的，因为在程序的不同部分，可能会出于不同的目的而多次声明相同的标
术语“标识符的作用域”实际上指的是&的某个声明的作用域。术语作用域(scope)本身是
{{x:int; y:bool; } x:int; y:char; }
S
：
1） int x; int y;
有些编译器维护了一个散列表来存放可访问的符号表条目。也就是说，存放那些没有被
块的符号表的实现可以利用作用域的最近嵌套规则。嵌套的结构确保可应用的符号表形
1 int vo ; bool y2; int zz1
.................Om...
下列伪代码用下标来区分对同一标识符的不同声明：
在处理上面的输人(2.7)时，目标是生成
block →'!' decls stnts '}'
块的符号表的优化
第2章
---
## Page 71
类 Env 支持三种操作：
以访问上一层的全局符号表Bo，但不能访问B2的符号表。
不可访问，环境指针转而指向B，的符号表，此时我们可
的指针表示的。当我们分析第5 行时，B2的符号表变
时，环境是由一个指向最下层的符号表(即 B2的符号表)
的或由语言提供的默认声明。在我们分析第2行至第4行
行开始的语句块。图的顶端是符号表B。，它记录了全
表。B,对应于从第1行开始的语句块；B2对应着从第2
例2.16
表指向外围语句块的符号表。
用于最内层的块。
个全局的或者位于这个块之外的声明。
层块中被再次声明了。然而，第5行上出现的y位于第1行上y的声明的作用域中。
图2-37 中是链接符号表的 Java 实现。它定义了一个类 Env（环境“environment"的缩写)。
实现语句块的最近嵌套规则时，我们可以将符号表链接起来，也就是使得内嵌语句块的符号
最后，在最内层的块中声明并使用。它不能在第5行上使用，因为这个内嵌的声明只能作
假设第5 行上w的出现位于这个程序片段之外某个w的声明的作用域中，它的下标表示-
一个简单的语法制导翻译器
●创建一个新符号表。图 2-37 中第6 行至第8行所示的构造函数 Env(p)创建一个 Env 对
圆键(key)是一个字符串，也可以说是一个指向字符串的引用。我们也可以使用指向对应
在当前表中加入一-个新的条目。散列表保存了键－值对，其中
但是将它们说成是链接的符号表比较方便。
这个参数的值是一个环境，因此这个对象被链接到环境。虽然形成链表的是 Env 对象,
象，该对象包含一个名为table 的散列表。这个对象的字段 prev 被设置为参数 p，
图2-36显示了对应于例2.15中伪代码的符号
8L9
public
import java.util,*;
 package symbols;
public void put(String s, Symbol sym) {
public Env(Env p) {
protected Env prev;
private Hashtable 'table;
return null;
for( Env
table.put(s, sym);
图2-37
table =
 new Hashtable(); prev = p;
类 Env 实现了链接符号表
null ） return found;
1// 文件 Eno.java
局
B2:
图2-36
int
bool
对应于例 2.15 的符号表链
B:
口
口
---
## Page 72
行上。
所有的语义动作都出现在第二列上。结果，一个产生式体的各个组成部分常常分开出现在多
时，
使用。它实现了例2.14 中描述的翻译。如前面描述的，在处理输人
例 2. 17
加人任意数量的运算符，而不会影响从声明通过符号表到达使用地点的基本信息流。
op 代表一般的运算符)的翻译只依赖于对E,和E2的翻译，不直接依赖于符号表，所以我们可以
符
?
个树形结构。图2-36 中的虚线提醒我们链接的符号表可以形成－-棵树。
生式的相关语义动作从符号表中“取出"这个标识符的信息。因为对一个表达式EOPE（其中
x的声明时，一个语义动作将有关x的信息“放人"符号表中。然后，
.7.2符号表的使用
9
请注意图2-38中各个产生式的体都已经对齐，因此所有的文法符号出现在同－列上，并且
{ { x:int; y:bool; ” x:int; y:char; }
这个翻译方案过滤掉了各个声明，并生成
[ int x;char y;{ bool y; x; y;” x; y;}
从效果看，一个符号表的作用是将信息从声明的地方传递到实际使用的地方。当分析标识
因为会有多个语句块嵌套在同－-外围语句块中，所以将这些符号表链接起来就可以形成一
中这个操作的代码返回一个符号表条目或 null。
得到一个标识符的条目。它从当前块的符号表开始搜索链接符号表。第12行至第18行
内部结构。也就是说，这个代码是独立于 Symbol 类的字段和方法的。
图2-38 中的翻译方案说明了如何使用类Env。这个翻译方案主要考虑作用域、声明和
值(value)是一个 Symbo1类的条目。第9行到第11行的代码不需要知道一个条目的
于标识符的词法单元对象的引用作为键。
progranl
图2-38使用符号表翻译带有语句块的语言
aclor
stme
stnts
decl
decls
block
→
↑
↑
stmts stmt
type id ;
decls decl
decls stmts'}'
block
{print(";");}