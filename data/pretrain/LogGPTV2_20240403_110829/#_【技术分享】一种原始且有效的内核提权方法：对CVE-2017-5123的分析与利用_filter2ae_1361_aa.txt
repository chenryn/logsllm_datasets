# 【技术分享】一种原始且有效的内核提权方法：对CVE-2017-5123的分析与利用
|
##### 译文声明
本文是翻译文章，文章来源：reverse.put.as
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
译者：[eridanus96](http://bobao.360.cn/member/contribute?uid=2857535356)
预估稿费：180RMB
投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿
**前言**
CVE-2017-5123是一个针对于Linux内核4.12-4.13版本，存在于waitid()系统调用中的本地提权漏洞。该漏洞原因在于：在waitid()系统调用中，由于没有检查用户态传入指针的有效性，而造成攻击者可以不受限制地将用户态写入任意内核地址的能力。
我在11月5日发布了漏洞利用的演示视频，网址为：
此外，Chris Salls在11月6日也独立发表了对该漏洞的分析和利用，大家可以阅读并比较：
与Chris不同的是，我将会带来另一种漏洞利用方法。并且我会将分析的重点放在如何利用这个漏洞，在不进行读取操作的前提下获得root权限。
这是一个让我非常感兴趣的漏洞，我也建议大家能进行更深入的思考。 **在Linux香草内核（Vanilla
Kernel）的自我防护下，仅利用这个漏洞本身，我们都能实现什么操作？或者说，当存在一个或多个任意内核地址写入漏洞时，我们可以如何利用？**
利用的是不是CVE-2017-5123这个漏洞并不重要，重要的是： **我们如何通过原本存在的漏洞，来最大限度地提升权限。**
这一类的漏洞十分强大，但很多人都没有对它足够地重视。
**漏洞分析**
以下是kernel/exit.c中的部分代码：
    SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *, 
                    infop, int, options, struct rusage __user *, ru)
    {
        struct rusage r;
        struct waitid_info info = {.status = 0};
        long err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);
        int signo = 0;
        if (err > 0) {
            signo = SIGCHLD;
            err = 0;
            if (ru && copy_to_user(ru, &r, sizeof(struct rusage)))
                return -EFAULT;
            }
            if (!infop)
                return err;
            user_access_begin();
            unsafe_put_user(signo, &infop->si_signo, Efault);
            unsafe_put_user(0, &infop->si_errno, Efault);
            unsafe_put_user(info.cause, &infop->si_code, Efault);
            unsafe_put_user(info.pid, &infop->si_pid, Efault);
            unsafe_put_user(info.uid, &infop->si_uid, Efault);
            unsafe_put_user(info.status, &infop->si_status, Efault);
            user_access_end();
            return err;
    Efault:
            user_access_end();
            return -EFAULT;
    }
自从4.12版本引入 **unsafe_put_user()** 之后，在 **waitid()** 的系统调用中，缺少一个 **access_ok()**
检查，由此产生了这一漏洞。
其中的 **access_ok()**
用于确保用户指定的指针是指向用户空间，而不是内存空间，因为非特权用户不能随意写入内核内存。这是通过检查限定的地址来实现的。
我们接下来看看 **arch/x86/include/asm/uaccess.h** 中的内容：
    #define user_addr_max() (current->thread.addr_limit.seg)
    ...
    /*
     * Test whether a block of memory is a valid user space address.
     * Returns 0 if the range is valid, nonzero otherwise.
     */
    static inline bool __chk_range_not_ok(unsigned long addr,  
                                    unsigned long size, unsigned long limit)
    {
        /*
         * If we have used "sizeof()" for the size,
         * we know it won't overflow the limit (but
         * it might overflow the 'addr', so it's
         * important to subtract the size from the
         * limit, not add it to the address).
         */
        if (__builtin_constant_p(size))
            return unlikely(addr > limit - size);
        /* Arbitrary sizes? Be careful about overflow */
        addr += size;
        if (unlikely(addr  limit);
    }
    #define __range_not_ok(addr, size, limit)                
    ({                                    
        __chk_user_ptr(addr);                        
        __chk_range_not_ok((unsigned long __force)(addr), size, limit); 
    })
    ...
    #define access_ok(type, addr, size)                    
    ({                                    
        WARN_ON_IN_IRQ();                        
        likely(!__range_not_ok(addr, size, user_addr_max()));        
    })
这也就意味着，该漏洞允许无特权的用户，在调用waitid()时，使用infop指定一个内核地址。随后，内核将直接使用该地址，执行写入操作。而具体到写入的内容，我们很难去控制。
Chris的文章中写道：
“info.status是一个32位的int型变量，但被限定在0 euid和cred->uid，从而有效获得root权限** **。**
以下是位于 **include/linux/cred.h** 中的cred结构定义：
    struct cred {
        atomic_t    usage;
    #ifdef CONFIG_DEBUG_CREDENTIALS
        atomic_t    subscribers;    /* number of processes subscribed */
        void        *put_addr;
        unsigned    magic;
    #define CRED_MAGIC    0x43736564
    #define CRED_MAGIC_DEAD    0x44656144
    #endif
        kuid_t        uid;        /* real UID of the task */
        kgid_t        gid;        /* real GID of the task */
        kuid_t        suid;        /* saved UID of the task */
        kgid_t        sgid;        /* saved GID of the task */
        kuid_t        euid;        /* effective UID of the task */
        kgid_t        egid;        /* effective GID of the task */
        kuid_t        fsuid;        /* UID for VFS ops */
        kgid_t        fsgid;        /* GID for VFS ops */
        unsigned    securebits;    /* SUID-less security management */
        kernel_cap_t    cap_inheritable; /* caps our children can inherit */
        kernel_cap_t    cap_permitted;    /* caps we're permitted */
        kernel_cap_t    cap_effective;    /* caps we can actually use */
        kernel_cap_t    cap_bset;    /* capability bounding set */
        kernel_cap_t    cap_ambient;    /* Ambient capability set */
    #ifdef CONFIG_KEYS
        unsigned char    jit_keyring;    /* default keyring to attach requested
                         * keys to */
        struct key __rcu *session_keyring; /* keyring inherited over fork */
        struct key    *process_keyring; /* keyring private to this process */
        struct key    *thread_keyring; /* keyring private to this thread */
        struct key    *request_key_auth; /* assumed request_key authority */
    #endif
    #ifdef CONFIG_SECURITY
        void        *security;    /* subjective LSM security */
    #endif
        struct user_struct *user;    /* real user ID subscription */
        struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */