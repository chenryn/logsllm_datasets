better coverage. For XSS exploits, Chainsaw generated 36
working exploits while Ardilla generated 37. On SQLI exploit
generation, Chainsaw outperforms Ardilla by 47 more as
it generated 80 exploits compared to 33 in Ardilla. The
reason behind 1 less XSS exploit in Chainsaw with respect
to Ardilla is traced to one case in the schoolmate.
For the code snippet in Listing 20 from schoolmate, Ardilla
generated an exploit for the print sink whereas Chainsaw
ﬂagged it as unfeasible because of the presence of the query
at line 1. This query needs to return some records that
satisfy the where clause or the execution of the module is
terminated and never reaches the print statement. However,
Ardilla’s input for $_POST[selectclass] will not make the
query return any records because courseid column is integer
and will not accept the supplied string input.
1 $query = mysql_query("SELECT aperc,bperc,cperc,dperc,coursename
FROM courses WHERE courseid = $_POST[selectclass]") or
2 die("ClassInfo.php: Unable to get the class info-".mysql_error());..
3 print(..);
Listing 20: Unfeasible exploit generated by Ardilla in
ClassSettings.php, schoolmate
On myBloggie, Chainsaw generated 7 exploits while [9]
generated 5 second-order vulnerabilities. On Scarf, both [9]
and Chainsaw generated 1 vulnerability and working exploit
respectively. CraxWeb [16] reports a total of 54 exploits (24
SQLI and 30 XSS) on 4 applications (Schoolmate, Webchess,
faqforge, and EVE). Over this set of applications, Chainsaw
generated 106 exploits (74 SQLI and 32 XSS). Chainsaw
generates 3-fold SQLI exploits compared to CraxWeb, and
32 XSS exploits versus CraxWeb’s 30.
Application Ardilla [19] CraxWeb [16]
Chainsaw
Eve
schoolmate
webchess
faqforge
geccbblite
6
18
25
5
6
5
31
11
7
-
9
56
31
10
10
Table 5: Comparison on working exploits generation (num-
bers reported are the sum of SQLI+XSS).
650Application
[26]
myBloggie
scarf
Eve
-
-
5
[8]
8
-
-
[9]
5
1
-
Chainsaw
25
1
7
Table 6: Comparison on exploit seeds generation.
5.7 Discussion
Static analysis limitations: Our tool can handle dynamic
workﬂow constructs where arguments are variables deﬁned
along an execution path. However, if the application code
contains dynamically generated workﬂow features (e.g., hy-
perlinks generated using JavaScript), Chainsaw cannot re-
solve the dynamic arguments of such functions. As a result,
when constructing the GWFG, Chainsaw may not infer the
existence of such dynamic edges. Thus, it may miss some
navigation links between modules. In our dataset, however,
we missed at most 0.23% of edges in all GWFGs. Addition-
ally, Chainsaw cannot construct symbolic sink expressions
if the structure (i.e., code, not arguments) of a SQL query
or an echo-like statement cannot be constructed statically
(e.g., determined by user input). A detailed discussion on
symbolic sink construction and its limitations can be found
in our previous work [6].
Solver failures: In few instances, Chainsaw encountered
a timeout or returned unknown (i.e., could not determine if
formula was satisﬁable). In our evaluation, the solver encoun-
tered undecidability in solving 28 out of 3463 seed SMT ﬁles
(less than 1% of the overall seed SMT ﬁles). Additionally, the
solver timed-out during the solving of 45 SMT ﬁles (about
1% of the overall seed SMT ﬁles).
Unsupported PHP features: Chainsaw uses Pixy [18]
for control ﬂow analysis in PHP web applications. Some
PHP features such as dynamic inclusions and certain object-
oriented features are not supported by Pixy. Consequently,
Chainsaw does not handle such features. In our evaluation,
however, these have not limited the applicability of Chainsaw
to the elaborate dataset that is used. Note, even though
Chainsaw is implemented for PHP (which is widely used),
our approach is applicable to other web platforms.
6. RELATED WORK
Exploit generation for binary programs. Brumley et
al. [7] developed an automatic exploit generation technique
that identiﬁes the diﬀerence between patched binaries and
their unpatched versions to generate inputs that trigger the
diﬀerence. Avgerinos et al. [1] developed AEG to generate
control ﬂow hijacking exploits on binary programs. FlowStich
[15] generated data-oriented attacks by connecting data-ﬂows
in binary programs assuming that control ﬂow integrity is
intact. All these works focus on generating exploits for
binaries while our approach deals with global navigation
structure and web applications state.
Exploit generation for web applications. Ardilla [19]
uses concolic execution and taint tracking (including database
tracking) to construct SQLI and XSS attack vectors. Ardilla
has three main limitations: low code coverage (alert("error")&postatoda=aaaa&testo=aaaa&testonuovo=&ispostadel=0
2 http://host/geccBBlite/leggi.php?rd=1
Listing 24: Stored XSS exploit for Listing 17.
1 http://host/schoolmate/header.php?schoolname=name&schooladdress=23aaa&
schoolphone=1234&sitetext=&
sitemessage=hello&numperiods=2&numsemesters=2&numperiods=2&apoint
=90.0&bpoint=80.0&cpoint=70.0&dpoint=60.0&fpoint=40.0&infoupdate=1
2 http://host/schoolmate/login.php?
Listing 25: Stored XSS exploit for Listing 19.
652