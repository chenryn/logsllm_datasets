//函数默认值相关信息
nk=2
17位置参数相关信息
b=4)
=7
11.4函数参数的实现
一深度探索动态语言核心技术
243
---
## Page 274
Python源码剖析
244
数的处理过程。
单11-11的[2]处设置了正规的位置参数后，就会进入代码清单11-11的[3]处对扩展位置参
argcount>co->co_argcount成立，就意味着函数调用时传递了扩展位置参数。在代码清
将成立。
标识。所以对于含有扩展位置参数和扩展键参数的函数，代码清单11-11的]处的判断都
的形式参数中包含**key这样的参数的函数，Python将在co_flags中添加co_VARKEYwoRDS
标识符号：CO_VARARGS，表示该函数在被调用时需要处理扩展位置参数。同样，对于函数
的参数形式，那么Python会在所编译得到的pyCodeObject对象的co_rlags中添加一个
前面我们已经知道，在PyEval_EvalcodeEx中，argcount其实就是na的值，一旦
当Python在编译一个函数时，如果在其形式参数中发现了*ist这样的扩展位置参数
第11章
fastlocals
//创建PyErameObject对象
register PyFrameobject*f;
register
PyFrame_New(tstate
[1]：
if
(eo
/13]：处理扩展位置参数
int
inti:
Pyobjeat *cloaure)
一深度探索动态语言核心技术
n=con>co_argcount;
判断是否需要处理扩展位置参数或扩展键参数
for
(CO->CO_flagS&CO_VARARGS)
n=argcount
Python虚拟机中的函数机制
co_argcount>O
PyTuple_New(argcount
设置位置参数的参数值
PyObject
PyTuple_SET_rTEM(u,
"g=eu=gtnoobxe
tstate
localsplus+f->f_nlocais;
1
>eo_argcount,
Co_FlagS&(CO_VARARGS
CO.
co_argcount=1
globals,
i-n，x）;
**freevars;
locals);
CO_VARKEYWORDS))
---
## Page 275
我们还是来看看Python虚拟机是如何做的（见代码清单11-12）。
之欲出了。照猫画虎，我们其实已经可以自己写出一个扩展键参数的传递机制了。不过，
co->co_argcount。没错，正是正规的位置参数列表后的第一个位置。
PyTupleobject。然后，还有最关键的一步，在[4]处，这个pyTupleObject对象也被Python
代码清单11-12
PyTupleobject对象，然后在代码清单11-11的[5]处将所有的扩展位置参数一股脑塞进这个
Pyobject*PyEval_EvalcodeEx()
[ceval.c]
了解了扩展位置参数的传递机制之后，对于扩展键参数的传递机制，实际上真的是呼
和我们之前的猜想相符，Python虚拟机首先在代码清单11-11的[4]处创建了一个
for
Pyobject
/[1]:创建PyDictObject对象，
pt
inti:
通历键参数，
77在函数的变量名对象表中寻找keywora
Pyobject
SETLOCAL（i.kWdict）
else(
//keywora在变量名对象表中出现
/[3]：Keywora没有在变量名对象表中出现
kwdlet=PyDict_New()
=co->coaurrucounb:
PyDict_SetItem(kwdict,
else if
Pyobject
+：
*kwdict=NUL
break;
(cmp
09
确定函数的de语句中是否出现了键参数的名字
coarocolnc)
PyObject_RichCompareBool(keyword,mm,Py_EQ):
0)
Pyluple
GO_VARARGS)
kws[2*i]
并将其放到_localsplus中
Python源码剖析
keyword,value);
GET_ITEM(CO
11.4函数参数的实现
深度探索动态语言核心技术
245
---
## Page 276
Python源码剖析
11.5
246
部变量的实现机制与函数参数的实现机制是完全一致的。这个”一致”究竟意味着什么呢？
局部变量是如何实现的。前面提到过，函数参数实际上也是一种局部的变量，所以其实局
自己想到了。
f_localsplus的情形如图11-21所示：
object对象中。
数，还是扩展键参数，如果是扩展键参数，就在代码清单11-12的[3]处将其插入到PyDict-
的位置一定在扩展位置参数的PyTupleobject对象之后的下一个位置。
证：当函数拥有扩展位置参数时，扩展键参数的PyDictObject对象在f_localsplus中
f_localsplus中。值得注意的是，在代码清单11-12的[2]处，这个判断及其后的操作保
拟机创建了一个PyDictObject对象，并且将该对象放入到了PyErameObject对象的
查找失败时，才能确定该键参数应该属于一个扩展键参数。
函数的pyCodeobject对象的变量名对象表（co_varnames）中查找键参数的名字，只有在
的默认值机制时我们已经看过了键参数的传递机制，在那里我们知道Pyhon虚拟机会在
中
在完成了对函数参数的详细剖析之后，最后，我们来看一看，在Python中，函数的
函数中局部变量的访问
当然，Pyton虚拟机如何访问这些扩展位置参数和扩展键参数呢。聪明的你一定能够
当图11-20中所示的函数调用的所有参数都传递完成之后，PyFrameObject对象中的
然后，对调用参数传递进来的每一个键参数，Pyhon虚拟机都会判断它是一般的键参
和扩展位置参数的实现一样，在代码清单11-12的[1]处，如我们所猜想的，Python虚
其实扩展键参数的传递机制与键参数的传递机制有很大关系，上一节在分析函数参数
第11章Python虚拟机中的函数机制
一深度探索动态语言核心技术
SETLOCAL（,Value）：
图11-21扩展位置参数和扩展键参数的最终归宿
valuestack
f_stacktop
1tkeys
localsplus
2
extras
PyFrameObject
stack
---
## Page 277
在是太普遍了，
现局部变量，而不需要借助于动态地查找pyDictobject对象的技术，毕竞，函数调用实
部变量的字节码指令应该如何访问内存。有了这些信息，Pyuon就能使用静态的方法来实
是固定不变的，所以在编译时就能确定局部变量使用的内存空间的位置，也能确定访问局
空间中。回过头参考一下图11-21，我们对局部变量c的藏身之处已经了然于胸。
局部变量的容身之处和函数参数一样，都是在f_localaplus中运行时栈前面的那段内存
个，那些重要的局部符号究竟会存放在哪里呢？别急，我们先来看一个使用局部变量的函
但毕竟还有一个PyDictobject对象可以使用。现在倒好，_1ocals变成了光杆司令
def f(a,
[func_3.py]
新的pyFrameObject对象时，那个至关重要的1ocal名字空间并没有被创建：
搜索变量名，但是很不幸的是，
PyFrame_New(PyThreadState *tstate,PyCodeObject *code,Pyobject *globals,
马上我们就能看到。
PyFrameobjecti
[frameobjec.c]
为什么在函数的实现中没有使用1oca1名字空间呢？这是因为函数中的局部变量总
按照我们对Python的了解，
在前面对函数调用时的giobal名字空间的剖析中，我们已经看到，当Pyhon虚拟机
10
print
f=>f_locals=locals;
目了然，
MosE Functions have do_NEWLoCALS and co_oPTIMIZED set.
LOADFAST
STORE FAST
LOAD_FAST
((code
BINARY
Pyobject
locais= NULL;
，静态的方法可以极大地提高函数执行的效率。
(CO_NEWLOCALS
原来局部变量也是利用LOAD_FAST和STORE_FAST来操作的，更进一步，
ADD
*locals)
2（c)
包
(CO_NEWLOCALISICO_OPTIMIZED)Y
在调用函数期间，Python虚拟机通过ryFrame_New创建
当访问局部变量时，似乎应该先到1ocal名字空间中去
PyFrame_RastroLocals() will set.
OPTIMIZED)
Python源码剖析
11.5
函数中局部变量的访问
一深度探素动态语言核心技术
247
---
## Page 278
Python源码剖析
11.6
248
是Python虚拟机专门为字节码指令准备的大包狱，global名字空间、默认参数都能在
与函数捆绑后的结果被称为一个闭包（closure）。在前面我们已经看到了，PyFunctionobject
的代码时，这个名字空间又被恢复了，这就是一种将名字空间静态化的方法。这个名字空间
候，有一个名字空间已经与real_compare紧紧地绑定在一起了，在执行real_compare
应该为10而不是1。
“base=1”，但是函数调用的结果显示，real_compare以一种神奇的方式得知了base
用的实际函数real_compare的local名字空间中没有base，而global名字空间中有
print compare_with_1o(20)
法利用了嵌套函数。
当不爽。Pyhon提供了一种方法，可以使我们在编写代码时，只设置一次基准值。这种方
是如果仔细观察一下就会发现，我们不得不每次都将基准值作为参数传入函数，这一点相
较，最简单的方法就是写一个函数：
响，始终保持一致的行为和结果。这样做有什么意义呢？
时，我们希望能将名字空间静态化。换句话说，我们希望有的代码不受名字空间变换的影
conpare_with_1o=get_
语义正是由名字空间决定的。名字空间是在运行时由Pyhon虚拟机动态维护的，但是有
[compare2.py]
compare(10,20)
行的结果不光取决于代码中的符号，更多地是取决于代码中符号的语义，而这个运行时的
dompare（10,
[comparel.py]
retwrn real_compare
retuzn value >base
在compare2.py中，我们只设置了一次基准值。此后，在每次进行比较操作时，尽管调
def
我们将10作为基准值，然后将5和20，分别与10进行比较，这样写当然没问题。但
嵌套函数、闭包与decorator
也就是说，在real_compare这个函数作为返回值被传递给compare_with_10的时
第11章Python虚拟机中的函数机制
来考虑一个具体的例子，假如我们想要定一个基准值，然后将许多值与这个值进行比
在前儿章我们已经提到，在Pyhon中，有一个核心的概念叫名字空间，一段代码执
compare(base):
深度探索动态语言核心技术
value):
_compare（10)
输出False
//输出True
---
## Page 279
11.6.1
object这些我们已经很熟悉的对象中，与闭包相关的属性。
def get_func):
含义如下：
落石出，现在我们先放一放，先来看看PyCodeObject、PyFunctionobject和pyFrame-
不同的机制，徒增复杂度。猜来猜去，闭包到底是如何实现的呢？别急，到后面自然会水
理，毕竞，如果默认参数的实现方式可以起作用，Pyhon应该没有必要去实现另一套完全
自然地会引起我们的猜测，闭包和默认参数的实现方式莫非是相似的？这个猜测也合情合
果使用闭包，最后一行输出代码是会抛出异常的。
[closure.py]
上就可以看到，不用闭包，我们同样可以实现compare2.py想要实现的效果。
个规则的一种实现方式，规则是形而上的“道”，而闭包是形而下的“器”。现在，我们马
用域规则，compare2.py的结果正是这套规则产生的效果。我们同时也提到了，闭包是这
中闭包的具体表现了。
PyFunctionObject中与字节码指令捆绑在一起，同样的，PyFunctionobject就是Python
print
print
print
compare_with_10= get_compare(1o)
[compare3.py]
了。在那里，我们提到，
这个结果相当令人惊讶，利用函数的默认参数，我们实现了闭包的效果。这个现象很
为了证明这段代码中闭包确实不存在了，我们在最后改变了比较的基准值（base），如
return real_compare
考虑下面的代码：
co_freevars：通常也是一个tuple，保存使用了的外层作用域中的变量名集合。
co_cellvars:
从compare2.py中可以发现，闭包的创建通常是利用嵌套函数来完成的。在
实现闭包的基石
如果你还记得的话，
comparewith_10（5，1)//输出True
compare_with_10(20)
compare_with_10(5)
Leturn value
real
compare(base):
compare(value,
：通常是一个tupie，保存嵌套的作用域中使用的变量名集合；
Pyhon语言的设计遵循了一个核心的作用域规则一
，关于闭包，实际上在前面介绍名字空间与作用域时，就已经遇到
base
base=base):
//输出True
//输出Fase
Python源码剖析
11.6
嵌套函数、闭包与decorator
一深度探索动态语言核心技术
最内嵌套作
249
---
## Page 280
Python源码剖析