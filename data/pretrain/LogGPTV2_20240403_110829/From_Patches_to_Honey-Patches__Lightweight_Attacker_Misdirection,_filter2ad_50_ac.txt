thread, which terminates itself gracefully in the target web
server. This successfully completes the checkpoint request,
and the CR-Service sends a success status response to the
CR-Controller.
We next examine the memory redaction step in greater
detail, to explain how sensitive, in-memory data is safely
replaced with decoy data during the fork.
Memory Redaction. Were session cloning performed in
the typical, rote fashion of copying all bytes, attackers who
successfully hijack decoys could potentially view any conﬁden-
tial data copied from the memory space of the original process
(e.g., in a multi-threaded setting). Sophisticated attacks could
thus glean sensitive information about other users previously
or concurrently connected to the original server process, if
targetCRqServicebimgsdecoybimgsCRqServiceReverseGProxyCRqController4Wcheckpoint5WrestoreAttacker2WGETbmalicious3Wfork6WHTTPGresponseLXCGController1WGETbmalicious7WHTTPGresponseLegend:requestGmessageresponseGmessageCRGoperationLXCcloneWebGServerWebGServerbindmounted4W2GterminateattackGsession5W2GresumeattackGsession4W1Gcheckpoint5W1Grestoresuch information is cloned with the process. In web servers,
such sensitive information includes IP addresses of other users,
request histories, and information about encrypted connections.
It is therefore important to redact these secrets during cloning.
We therefore introduce a memory redaction procedure that
replaces sensitive data with specially forged, anonymous data
during cloning. Since every server application has diﬀerent
forms of sensitive data stored in slightly diﬀerent ways, our
solution is a general-purpose tool that must be specialized to
each server product by an administrator prior to deployment.
In the case of Apache, we focus on redaction of user request
data, session data, and SSL context data, which Apache
records in a few data structures stored in memory for each
user session. For instance, Apache’s request_rec struct stores
request histories. Other servers store such data in similar
ways, but we omit their discussion due to limited space.
A brute force strategy for memory redaction is to search the
entire process memory space to match and replace sensitive
data. Such a strategy does not perform well. Instead, we
leverage the fact that most security-relevant data are stored in
struct variables in heap or stack memory, allowing us to narrow
the search space signiﬁcantly. Freed memory is included in the
search. For eﬃciency, our redactor replaces these structures
with anonymous data having exactly the same length and
characteristics. For example, IP addresses in request_rec
are replaced with strings having the same length that are also
valid IP addresses, but randomly generated. This yields a
realistic, consistent process image that can continue running
without errors (save possibly for eﬀects of the attack).
The redaction is implemented as a step of the checkpoint
procedure, so that the image ﬁles temporarily created during
process checkpoint and shared with decoys do not contain
any sensitive information that could be potentially abused
by attackers. Secrets are redacted from all session-speciﬁc
structures except the attacker’s, allowing the attacker’s session
to continue uninterrupted.
We initially implemented memory redaction as a separate
operation applied to the image ﬁles generated by CRIU. While
this seemed attractive for avoiding modiﬁcation of CRIU,
it exhibited poor performance due to reading and writing
the image ﬁles multiple times. Our revised implementation
therefore realizes redaction as a streaming operation within
CRIU’s checkpointing algorithm. In-lining it within check-
pointing avoids reloading the process tree images into memory
for redaction. In addition, redacting secrets before dumping
the process images avoids ever placing secrets on disk.
4.2 Restore
Upon successful completion of a checkpoint operation, the
CR-Controller sends a request to the decoy’s CR-Service into
which the attacker session is to be forked. In addition to $pgid,
$pid, and $tid, the body of the restore request contains a
callback port that has been dynamically assigned by the
reverse proxy to hold the new back-end connection associated
with the attacker session. Once the request is parsed, the CR-
Service passes this information as parameters to the CRIUm
restore interface, which (1) reads the corresponding process
tree from /imgs/$tid/; (2) uses the clone system call to start
each dumped process found in the process tree with its original
process ID; (3) restores ﬁle descriptors and pipes to their
original states, and executes relocation of ESTABLISHED socket
connections; (4) injects a BLOB code into the process address
space to recreate the memory map from the dumped data;
Figure 4: Procedure for TCP connection relocation
(5) removes the injected binary, and resumes the execution of
the application via the rt_sigreturn system call.
At this point, CRIUm returns to the caller, the forked
instance is running on the decoy, and the attacker thread waits
to be signaled. The CR-Service sends a resume signal to the
attacker thread, which allows it to resume request processing.
This completes the restore request, and the CR-Service sends a
success response to the CR-Controller. Subsequent attacker
requests are relayed to the decoy instead of the target, as
discussed in §3. Next, we discuss details of the TCP connection
relocation procedure.
Established Connection Relocation. Target and decoys
are fully isolated containers running on separate namespaces.
As a result, each container is assigned a unique IP in the
internal network, which aﬀects how we move active connections
from the target to a decoy. Since CRIU was not implemented
with this use case in mind, we extended it to support relocation
of TCP connections during process restoration. In what follows,
we explain how we approached this problem.
The reverse proxy always routes legitimate user connections
to the target; hence, there is no need to restore the state of
connections for these users when restoring the web server
on a decoy. We simply restore legitimate connections to
“drainer” sockets, since we have no interest in maintaining
legitimate user interaction with the decoys. This ensures that
the associated user sessions are restored to completion without
interrupting the overall application restoration.
Conversely, the attacker connection must be restored to
its dumped state when switching the attacker session to a
decoy. This is important to avoid connection disruption and
to allow transparent session migration (from the perspective
of the attacker). To accomplish this, our proxy dynamically
establishes a new back-end TCP connection between proxy
and decoy containers in order to hold the attacker session
communication. Moreover, a mechanism based on TCP repair
options [16] is employed to transfer the state of the original
attacker’s session socket (bound to the target IP address) into
the newly created socket (bound to the decoy IP address).
Figure 4 describes the connection relocation mechanism,
implemented as a step of the attacker’s session restore process.
At process checkpoint, the state information of the original
socket sk is dumped together with the process image (not
shown in the ﬁgure). This includes connection bounds, previ-
ously negotiated socket options, sequence numbers, receiving
and sending queues, and connection state. During process
restore, we relocate the connection to the assigned decoy by
(1) connecting a new socket tsk to the proxy $port given in
the restore request, (2) setting tsk to repair mode and silently
closing the socket (i.e., no FIN or RST packages are sent to the
create newconnection ( )tskclose silently (tsk)transfer state (tsk, sk)tsk = create_socket(new bounds)bind(tsk)connect(tsk)enter_repair_mode(tsk)close(tsk)transfer_seqs(tsk, sk)bind(sk)connect(sk)transfer_opts(tsk, sk)transfer_queues(tsk, sk)Listing 4: Abbreviated patch for CVE-2013-1862
...
1 logline = apr psprintf(r->pool, ...,
2
3 - ap get server name(r),
4 + ap escape logitem(r->pool, ...(r)),
5
...
Figure 5: Apache honey-patchable vulnerabilities
remote end), and (3) transferring the connection state from
sk to tsk in repair mode. Once the new socket tsk is handed
over to the restored attacker session, the relocation process
has completed and communication resumes, often with an
HTTP response being sent back to the attacker.
5.
IMPLEMENTATION
We have developed an implementation of RedHerring
for the 64-bit version of Linux (kernel 3.11 or above). The
implementation consists of ﬁve components: the honey-patch
library, the LXC-Controller, the CR-Controller, the CR-
Service, and the reverse proxy. The honey-patch library
provides the tiny API required for triggering the honey-
patching mechanism. Its implementation consists of about
270 lines of C code that uses no external libraries or utilities.
The reverse proxy routes HTTP/S requests in accordance
with the behavior described in §3. Its implementation is
fully asynchronous and consists of about 325 lines of node.js
JavaScript code. The CR-Controller is implemented as an
external C++ module to the proxy, and consists of about 450
lines of code that uses Protocol Buﬀers to communicate with
the CR-Service. Similarly, the LXC-Controller is implemented
as an external node.js library consisting of about 190 lines
of code. The CR-Service receives CR requests from the CR-
Controller and uses CRIUm to coordinate process checkpoint
and restore. Its implementation comprises about 525 lines of
C code. Our extensions to CRIUm add about 710 lines of C
code to the original CRIU tool.
6. EVALUATION
This section discusses the applicability of honey-patching
and investigates performance characteristics of the session
live migration scheme implemented by RedHerring. First,
we survey the past nine years of Apache’s security reports to
assess the proportion of security patches that are amenable to
our honey-patching technique. Then, we investigate the eﬀect
of session migration on malicious attack HTTP response times
and report measurements of the impact of concurrent attacks
on legitimate HTTP request round-trip times. Finally, we
compare the performances of the honey-patched versions of
Apache, Lighttpd, and Nginx.
All experiments were performed on a quad-core virtual
machine (VM) with 8 GB RAM running 64-bit Ubuntu 14.04
(Trusty Tahr). Each LXC container running inside the VM
was created using the oﬃcial LXC Ubuntu template. We
limited resource utilization on decoys so that a successful
attack does not starve the host VM. The host machine is an
Intel Xeon E5645 desktop running 64-bit Windows 7.
6.1 Honey-patchable Patches
Our strategy sketched in §2.1 for transforming patches into
honey-patches is more easily applied to some patches than
others. In general, patches that have a clear, boolean decision
point where patched and unpatched application behavior
diverge are best suited to our approach, whereas patches that
introduce deeper changes to the application’s control-ﬂow
structure or data structures may require correspondingly
deeper knowledge of the patch’s semantics to reformulate as a
honey-patch.
To assess the practicality of honey-patching, we surveyed
all vulnerabilities oﬃcially reported by the Apache HTTP
web server project between 2005 and 2013. We systematically
examined each security patch ﬁle and corresponding source
code to determine its amenability to honey-patching. Figure 5
reports the results. Overall, we found that 49 out of 75
patches analyzed (roughly 65%) are easily transformable into
honey-patches. This corroborates the intuition that most
security vulnerabilities are patched with some small check,
usually one that performs input validation [12].
Listing 4 shows an example of a patch (simpliﬁed for
brevity) for which honey-patching is not elementary. The
patch replaces the insecure method ap_get_server_name
with an alternate one (ap_escape_logitem) that performs
input sanitization. The sanitization step lacks any boolean
decision point where exploits are detected; it instead performs
a string transformation that replaces dangerous inputs with
non-dangerous ones. Thus, it is not obvious where to position
the forking operation needed for a honey-patch.
However, even in the case of Listing 4, we note that honey-
patching is still possible, given a suﬃciently comprehensive
understanding of the patch’s semantics. In particular, this
patch could be converted to a honey-patch by retaining
both the sanitizing and non-sanitizing implementations and
comparing the resulting strings. If the strings diﬀer, the
honey-patch forks the session to a decoy. Note that not every
input sanitization patch can be honey-patched in this way,
since some sanitization procedures modify even non-dangerous
inputs. Thus, patches of this sort were conservatively classiﬁed
as not easily honey-patchable in our study, since they require
greater eﬀort to honey-patch.
Experimental validation. To evaluate honey-patching’s ef-
fectiveness in diverting attackers to decoys, we tested RedHer-
ring with diﬀerent honey-patched Apache releases. Table 1
summarizes the tested versions of Apache and correspond-
ing vulnerabilities that we successfully exploited. For each
vulnerability, we tested the system on non-malicious inputs
and veriﬁed that RedHerring does not fork any attacker
sessions. Then we exploited honey-patched vulnerabilities,
and veriﬁed that the system behaves as a vulnerable decoy
server in response to the attack inputs.
Apache 2.2.21 allows the inadvertent exposure of inter-
nal resources to remote users who send specially crafted
requests (CVE-2011-3368). For example, the request GET
@private.com/topsecret.pdf HTTP 1.1 may result in an
exposure of unpatched servers. The security patch for this
vulnerability modiﬁes protocol.c to send an HTTP 400
 0 5 10 15 20200520062007200820092010201120122013number of security vulnerabilitieshoney-patchablenot easily honey-patchableTable 1: Honey-patched security vulnerabilities for
diﬀerent versions of the Apache Web Server
Version CVE-ID
Description
2.2.21
2.2.9
2.2.15
2.2.11
CVE-2011-3368
CVE-2010-2791
Improper URL validation
Improper timeouts of keep-alive
connections
CVE-2010-1452 Bad request handling
CVE-2009-1890 Request content length out of
2.0.55
CVE-2005-3357 Bad SSL protocol check
bounds
response if the request URI is not an absolute path. Our
honey-patch forks to a decoy instead.
Similarly, we honey-patched and tested CVE-2010-1452
and CVE-2009-1890, which involve improper HTTP request
sanitization. CVE-2010-1452 exposes a request handling
problem in which requests missing the path ﬁeld may cause
the worker process to segfault, inviting potential DOS attacks.
CVE-2009-1890 exposes another type of DOS vulnerability in
which a suﬃciently long HTTP request may lead to memory
exhaustion.
CVE-2010-2791 allows us to test RedHerring against
attacks exploiting vulnerabilities related to keep-alive con-
nections. In this particular case, a bug neglects closing the
back-end connection if a timeout occurs when reading a re-
sponse from a persistent connection, which allows remote
attackers to obtain a potentially sensitive response intended
for a diﬀerent client. Finally, CVE-2005-3357 exposes a bad
SSL protocol check that allows an attacker to cause a DOS if
a non-SSL request is directed to an SSL port.