清华大学
位图索引编码的研究
-在大数据中的应用
Saturn
www.nslab-Saturn.net
2014年05月09日 1
索引
人类进入大数据时代，数据查找离不开索引
传统索引使用哈希和树这两类最基本的数据结构
哈希
索引
树
2
位图索引 Bitmap Index
位图索引特点
– 数据查找操作灵活
– 数据查找速度快
– 空间消耗大
位图索引编码
– 压缩索引大小
– 加速索引查找
位图索引应用
– 广泛应用于数据管理，如数据仓库， NoSQL等
3
提出的位图索引编码算法之间关联
Raw Bitmap Index
+fill word
WAH
+piggyback +FLF/LFL
Run-length coding PLWAH COMPAX/COMPAX2
extension
+carrier,-literal SECOMPAX
+LF/NI2-LF
MASC ICX 4
算法全称
WAH: Word-Aligned Hybrid
PLWAH: Position List Word-Aligned Hybrid
COMPAX: COMPressed Adaptive indeX format
SECOMPAX: Scope Extended COMPressed Adaptive indeX
ICX: Improved CompaX
MASC: MAximized Stride with Carrier
5
常用术语
Chunk: 31比特为单位的块
Word: 32比特字
Fill：一个word/chunk全部为0或1
Literal: 一个word/chunk不全为0或1
– Literal顾名思义”字面意思”，表示该信息未做处理，原封
不动保留
6
0-BBC (Byte-aligned Bitmap Code)
Oracle数据库的位图索引编码
 “The bitmap bytes are classified as gaps containing only zeros or only ones and maps
containing a mixture of both. Continuous gaps are encoded by their byte length and a
fill bit differentiating between zero and one gaps. Stretches of map bytes encode
themselves and are accompanied with the stretch length in bytes. A pair (gap, map) is
encoded into a single atom composed of a control byte followed by optional gap
length and map. Single map byte having only one bit different than the others is
encoded directly into a control byte using a “different bit” position within this map
byte.”
7
1-WAH(Word-Aligned Hybrid)
每31bits分块，基于块单位进行压缩，全0为0-fill，全1为1-fill，否则为literal（直
接保留）.
 相邻的一串连续0-fill压成一个0-fill word，相邻的一串连续1-fill压成1个1-fill word.
 WAH核心是两种方法：（1）Run Length Encoding(RLE); （2）不能RLE部分直
接保留
8
经典算法1-WAH
优点：
– 简单有效，速度快
不足：
– bit序列分段存储 WAH Fill’s counter表示空间使用不够 有空间富
余  可以用于piggyback 合适的“literal”
– bit序列连续0或1的数目不够大 WAH Fill’s counter表示空间使用不
够 有空间富余 可以用于piggyback 合适的“literal”
进一步改进：PLWAH/COMPAX
– F和L组合的二次合并压缩，为优化指明方向
9
– 出现各种新的算法，SECOMPAX/ICX/MASC
2-PLWAH(Position List Word-Aligned Hybrid)
在WAH的基础上
1. 引入NI概念
– Nearly Identical(几乎等同): Literal word几乎等同于Fill word，可合并压缩
– 细分Literal word 为nearly identical 0-fill word 和普通literal word
– 本质上是”dirty bit” 的思想
2.二次压缩
– 用piggyback将NI的Literal合并入Fill word
– “piggyback”:如果0-fill序列下一个literal中只有一个非0比特，那么将这个
“1” piggyback到前一个fill word中.
– 如果有多个“1”，可以把位置列表(Position List ) piggyback到前一个fill
word中
10
经典算法2-PLWAH
11
经典算法2-PLWAH
优点：
– 减少WAH中literal word出现的数量，节省空间
缺点：
– piggyback了position的信息，position的值为(0-31) ，编码需5bit，开
销较大
– 挤压了counter空间，需设计Adaptive Counter,在piggyback较多
position时尤为明显
– 1.piggyback最多可以带5个(position)
– 2.Adaptive Counter(相当于将2个或更多fill word的counter合并
进一步改进：COMPAX
 12
3-COMPAX(COMPressed Adaptive indeX)
在PLWAH基础上进行改进
1. 引入”dirty byte” 概念
– dirty byte概念:相对全0 chunk,所有的非零比特在同一个byte内
– 沿用nearly identical literal word概念，细分Literal word类型
– “dirty byte”本质是更小的literal，是PLWAH中 “dirty bit”的推广
2.增添了码本，二次合并压缩
– 加入了LFL(literal-fill-literal)以及FLF(fill-literal-fill)
– LFL：两个L都只有一个dirty byte（但F限定为0-fill）
– FLF：L只有一个dirty byte
13
经典算法3-COMPAX
14
经典算法3-COMPAX改进
优点：
– 增加编码类型，提高压缩率
– 增强版本-COMPAX2
• 在0-fill基础上，增加1-fill
• 增加LFL中literal-1 fill-literal类型
进一步改进：SECOMPAX
15
4-SECOMPAX(Scope Extended COMPAX)
以COMPAX2为基础
1. 扩充”dirty byte”定义
– 扩充”dirty byte”定义，新定义带dirty byte的nearly identical literal (NI-L)
– 除原来是和全零chunk比所有非零位均在一个byte中，即0-NI-L
– 增添和全一chunk比所有非一位均在一个byte中的dirty byte类型，即1-NI-L
2. 扩展LFL和FLF组合类型
– LFL：除了0-NI-L + F + 0-NI-L类型外，补充三种类型，即0-NI-L + F + 1-NI-L， 1-NI-L + F + 0-
NI-L， 1-NI-L + F + 1-NI-L；
– FLF：除了0F + 0-NI-L + 0F与1F+0-NI-L+1F 两种外，补充六种类型，即0F + 1-NI-L + 0F，1F + 1-
NI-L + 1F； 1F + 1-NI-L + 0F， 0F + 1-NI-L + 1F； 1F + 0-NI-L + 0F， 0F + 0-NI-L + 1F；
16
新算法-SECOMPAX
在位图中 “1”出
现比例占多，出现
NI近F的情况下，
SECOMPAX算法
是COMPAX算法的
3倍
17
新算法-SECOMPAX
核心思想：编码0-NI-L与1-NI-L
18
新算法-SECOMPAX
优点：
– 将COMPAX提出的LFL与FLF概念进一步推广，相对COMPAX有
更出色的压缩率
– 在0和1局部数量相近时效果更加明显
进一步改进：ICX
19
新算法-ICX(Improved COMPAX)
在SECOMPAX基础上进一步改进
进一步细分literal word
– ”dirty bytes” 数目扩充为2
– ”dirty bytes”的位置组合共6种，即4中取2的组合
补充两个新组合类型(LF与NI2-LF)
– LF：一个nearly identical的literal + F，相当于对LFL情况补充
– NI2-LF：带2个dirty byte的literal + F
设计新码本
20
新算法-ICX(Improved COMPAX)
LF:
O r ig in s e q u e n c e 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 1 1 1 1 1 1 1 1 1 1 1 0 0 … 0 ( 3 * 3 1 b it s ) 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1
W A H e n c o d in g 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1
C O M P A X e n c o d in g 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1
IC X e n c o d in g 0 0 0 0 1 1 0 1 1 1 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1
NI2-LF：
Origin sequence 1111111 11001111 11000111 11111111 11…1(11*31 bits)
WAH encoding 1 1111111 11001111 11000111 11111111 0 1000000 00000000 00000000 00001011
COMPAX encoding 1 1111111 11001111 11000111 11111111 011 00000 00000000 00000000 00001011
ICX encoding 0001 1011 11000111 11001111 10001011
21
新算法-ICX (Improved COMPAX)
核心思想：编码2个dirty Bytes
1 Literal Word