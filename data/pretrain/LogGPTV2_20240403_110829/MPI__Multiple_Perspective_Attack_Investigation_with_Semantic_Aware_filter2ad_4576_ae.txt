causal graphs for all cases. Moreover, MPI generates
fewer execution units using the perspectives in Table 1,
when compared to BEEP/ProTracer. On average, the
number of units generated by MPI is only 25% of that
by BEEP/ProTracer. For attacks involving GUI programs
(e.g., Firefox), the number is 8%, and in an extreme at-
tack case involving Transmission, it is less than 1%. In
terms of the generated attack graphs, MPI can reduce
the number of nodes to 92% and the number of edges
to 83% on average. Note that it is because these attacks
have simple propagation paths such that the BEEP/Pro-
Tracer graphs are quite succinct. For complicated cases,
MPI can reduce the graphs to 76%(nodes)/62%(edges).
In addition, we evaluate it on a few other realistic attack
cases. Next, we show one such case. Two more cases are
presented in Appendix C to demonstrate the advantages
of MPI over BEEP/ProTracer in an insider threat and in
tracking complex browsing behaviors in Firefox.
Case: FTP Data Leak. Exploiting system misconfigura-
tion to acquire valuable sensitive information is a common
attack vector [9, 14]. It is important to assess and control
damages once the problem is noticed. In the following in-
cident, an FTP administrator accidentally configured the
root directory of many users to a folder containing clas-
sified files, and gave them read accesses. After noticing
the problem, he shut down the server and then conducted
investigation to figure out the significance of the potential
information leak. In the duration of the misconfiguration,
there are thousands of connections from a large number
of users. The number of classified files is also large.
In Figure 16, we show a number of possible investiga-
tion perspectives for the FTP server application. Event
Figure 16: FTP server partitioning perspectives
loop based partitioning techniques are based on each com-
mand or user request (box 1), and traditional auditing
approaches are based on the whole process (box 3). MPI
provides choices that align better with the logical struc-
tures of the application, such as the session perspective
(box 2), i.e., all the commands/requests from a session
belong to a unit, the directory perspective (box 4), i.e., all
the commands on a given directory are considered a unit,
and the user perspective (box 5), i.e., all commands/re-
quests from a user (not limited to an IP address) belong to
a unit. Note that all FTP commands are associated with
some file or directory as part of its context, and hence we
can partition FTP execution based on this information.
Figure 17: FTP server partitioned by BEEP
Figure 18: FTP server partitioned by each connection
Part of the BEEP graph is shown in Figure 17. Ob-
serve that each user command is captured as a unit. The
simplified graph by MPI with connection based partition-
ing is shown in Figure 18, and user based partitioning
in Figure 19. The connection perspective alleviates the
inspector from going through the individual commands.
The user perspective can aggregate all the behaviors from
a specific user over multiple sessions so that the inspector
can hold individual users for responsibilities. Note that a
user can use various IP addresses to connect to the server.
Without MPI, such semantic information cannot be ex-
posed to the provenance tracking system. The number of
nodes in the BEEP, connection (MPI), and user (MPI)
graphs are 962, 224, and 78, respectively. We want to
point out that the MPI graphs cannot be generated from
the BEEP graph by post-processing because of the subtask
delegation in this program, i.e., it is difficult to attribute a
sub-task to the top level unit that it belongs to with only
the low level semantic information in the BEEP graph.
5 Discussion
Similar to many existing works [23, 43, 44, 46, 55], MPI
trusts the Linux kernel and the components associated
with the audit logging system. Attacks that can bypass the
1122    26th USENIX Security Symposium
USENIX Association
3: FTP Process2: SessionSession4: Directorydownload1: CommandHelpdownload Session5: UserMF2C1MF0C1F0C1MF4C0F4C2MF1C1F1C0F7C2MF4C0MF2MF0C1F0F7C2F4F0C3MF4C0MF0MF1C1F2C2F2C0F1F2C2F3Figure 19: FTP server partitioned by users
security mechanisms of these systems may cause prob-
lems for MPI. Moreover, attacks that target the underly-
ing audit system, such as audit log blurring and log filling,
may inject noise to logs, making log inspection difficult.
As our system is built on top of existing provenance and
operating systems, MPI leverages existing features pro-
vided by these systems to mitigate some of the problems.
For example, operating systems like Ubuntu now lever-
ages Ubuntu Software Center to deliver trustworthy soft-
ware which can be used to protect the MPI binaries for
benign software. Provenance systems like Hi-Fi uses ref-
erence monitor guarantees to protect audit logs, and LPM
provides a general framework for trustworthy provenance
collection. We argue these are orthogonal challenges to
all existing provenance tracking techniques and a com-
plete solution to all these challenges is not the focus of
our paper. Instead, the emphasis of MPI is to address
dependence explosion caused by long running processes
with accuracy and flexibility.
MPI is essentially an add-on service to the OS-level
provenance collection system (e.g. the Linux Audit sys-
tem, LPM-HiFi, and ProTracer). System calls can be too
coarse-grained. Fine-grained events, such as library calls
or even instruction level dependencies, may need to be
captured for some sophisticated attacks. We argue that the
multiple perspective partitioning enabled by MPI is or-
thogonal. It is independent of the granularity of the events
captured by the underlying provenance system. It can be
easily integrated with systems of various granularities.
MPI requires program source code. We believe that
the semantic information needed to enable multiple per-
spective partitioning is difficult to acquire through binary
analysis for complex programs such as Firefox. If it is
necessary to partition the execution of a binary, training
and event loop based approaches such as BEEP could
be used together with MPI.
In the worst cases, MPI
treats the entire process execution as a unit. Note that
this approximation is only problematic for long running
processes. Many malware executables are likely not long
running such that treating a whole process as a unit does
not introduce a lot of bogus dependencies. Also note that
such approximation does not miss provenance so that the
attack path is still captured. It is just that more efforts
may be needed to go through the causal graph.
MPI relies on source code annotations, which are
widely used in practice. Windows developers explicitly
plant logging commands in their software source code to
customize ETW auditing. Both GCC and LLVM provide
advanced language features [4, 6, 7] that are triggered by
annotations. For example, Firefox has 926 different types
of annotations. The stack-only class annotation “NS_-
STACK_CLASS” has 406 uses through out the code base.
In contrast, we only introduce 36 annotations (of 4 types)
in Firefox. As MPI is based on source code level anno-
tation and compiler instrumentation, it cannot find units
within dynamic code. However, in practice, we find that
unit boundaries mostly lie in static code. For example,
JavaScript code can be grouped into different tabs. Thus,
dynamic code can be attributed to tab units.
6 Related work
Many approaches have been proposed for system level
provenance tracking. Detailed comparison of MPI with
existing audit systems [10, 31, 43–45] can be found in §2.
Another important approach is to monitor the internal ker-
nel objects (e.g., the file system [27, 49, 50, 59–61, 69],
or LSM objects [23, 32, 55]) to track lineages. The ca-
pabilities of these techniques are similar to those of the
audit systems. Thus MPI is complementary to such sys-
tems. For example in §4, we showed the integration
of MPI and LPM-HiFi. System wide record-and-replay
techniques [30, 37–39] can also track provenance. These
systems record the inputs for all programs, and replay the
whole system execution when needed. Such systems re-
quire deterministic record-and-replay techniques, which
are open research problems, and cause more space over-
head. Whole system tainting [28, 35, 52, 68] is another
method of tracking provenance. By tainting all inputs
to a system and tracking their propagation, such systems
can record the needed provenance data. These techniques
need to deal with the granularity problem as the taint set
may be explosive for a long living system objects/sub-
jects. MPI can be applied to such systems to overcome
the dependency explosion problem and enable multiple
perspective inspection.
In [48], researchers propose to develop provenance
aware applications. Muniswamy-Reddy et. al. [49] pro-
vide a library with provenance tracking APIs so that pro-
grammers can develop provenance aware applications.
Such an approach relies on the programmers to inten-
sively modify their code to leverage the APIs. In contrast,
MPI aims to address the partitioning problem. Prove-
nance tracking is through the underlying audit system.
Many works [22, 27, 44, 67] are proposed to reduce the
space overhead of provenance tracking based on reachabil-
ity analysis, Mandatory Access Control (MAC) policies
and so on. Provenance visualization [25, 26, 47, 53, 57]
and graph compression [34, 54, 58, 63–65] are also pro-
posed to correlate events and reduce graph size to fa-
cilitate investigation. These approaches work on gen-
erated graphs to compress them for better visualiza-
tion. As such, they are complementary to MPI, and
USENIX Association
26th USENIX Security Symposium    1123
AliceMF0C0MF1C2F0C3BobMF2MF3C1F4C2CarolF7F1C2DanF2F3C0can be directly applied to MPI, its provenance logs and
graphs. Researchers proposed many machine learning
methods [21, 24, 33, 40, 41, 51, 66] to investigate prove-
nance data to find abnormal behaviors. We envision that
the multiple perspectives provided by MPI may substan-
tially improve their effectiveness.
7 Conclusion
Execution partitioning is important for addressing de-
pendency explosion in audit logging. However, existing
techniques are event loop based. They generate too many
small units, require training to detect dependencies across
units, and lack information about high level logic tasks.
We propose MPI, a technique that partitions based on
high level tasks. It allows the user to annotate the data
structures corresponding to these task, and leverages com-
piler to instrument operations of the data structures in
order to capture unit context switches and delegations.
We implemented a prototype and evaluated it on three
existing systems: Linux Audit, ProTracer and LPM-HiFi.
The results show that MPI generates much smaller graphs
with lower overhead comparing to the state-of-the-art, and
avoids broken provenance due to incomplete training.
References
[1] Apache benchmark. https://goo.gl/L7bGOK.
[2] The browser exploitation framework. http://beefproject.
com/.
[3] Chinese hacker arrested for leaking 6 million logins. https:
//goo.gl/AO2Qlz.
[4] Clang language extensions. https://goo.gl/UpniZC.
[5] Event tracing for windows (etw). http://msdn.microsoft.
com/en-us/library/windows/desktop/aa363668(v=vs.
85).aspx.
[6] Extensions to the c++ language. https://goo.gl/pn19Np.
[7] Extensions to the c language family. https://goo.gl/evrruW.
[8] Github hacked, millions of projects at risk of being modified or
deleted. https://goo.gl/EdguGO.
[9] Leaked data. https://haveibeenpwned.com/.
[10] Linux audit subsystem. https://goo.gl/WSwnJB.
[11] Many watering holes, targets in hacks that netted facebook, twitter
and apple. https://goo.gl/NIg2Va.
[12] More details on "operation aurora". https://goo.gl/p76ovs.
[13] Sloccount. http://www.dwheeler.com/sloccount/.
[14] The sony hack. https://goo.gl/B4G7Pl.
[15] Tuxpaint. www.tuxpaint.org.
[16] Ubsi. https://github.com/kyuhlee/UBSI.
[17] Vim document: windows. https://goo.gl/Lqp9Gb.
[18] Watering hole attack. https://goo.gl/AcN0dv.
[19] Watering hole attack. https://goo.gl/aw1t9l.
[20] Windows event log. https://msdn.microsoft.com/en-us/
library/windows/desktop/aa385780(v=vs.85).aspx.
[21] ARP, D., SPREITZENBARTH, M., HUBNER, M., GASCON, H.,
AND RIECK, K. Drebin: Effective and explainable detection of
android malware in your pocket. NDSS’14.
[22] BATES, A., BUTLER, K. R., AND MOYER, T. Take only what
you need: Leveraging mandatory access control policy to reduce
provenance storage costs. TaPP ’15.
[23] BATES, A., TIAN, D. J., BUTLER, K. R., AND MOYER, T.
Trustworthy whole-system provenance for the linux kernel. Usenix
Security’15.
[24] BESCHASTNIKH, I., BRUN, Y., SCHNEIDER, S., SLOAN, M.,
AND ERNST, M. D. Leveraging existing instrumentation to auto-
matically infer invariant-constrained models. ESEC/FSE’11.
[25] BEVAN, C. F., AND YOUNG, R. M. Planning Attack Graphs. In
ACSAC (2011).
[26] BORKIN, M. A., YEH, C. S., BOYD, M., MACKO, P., GAJOS,
K. Z., SELTZER, M., AND PFISTER, H. Evaluation of filesystem
provenance visualization tools. IEEE Transactions on Visualiza-
tion and Computer Graphics 19, 12 (Dec. 2013), 2476–2485.
[27] BRAUN, U., GARFINKEL, S., HOLLAND, D. A., MUNISWAMY-
REDDY, K.-K., AND SELTZER, M. I. Issues in automatic prove-
nance collection. In Provenance and annotation of data.
[28] CHOW, J., PFAFF, B., GARFINKEL, T., CHRISTOPHER, K., AND
ROSENBLUM, M. Understanding data lifetime via whole system
simulation. USENIX SSYM’04.
[29] CUMMINGS, A., LEWELLEN, T., MCINTIRE, D., MOORE, A. P.,
AND TRZECIAK, R. Insider threat study: Illicit cyber activity
involving fraud in the us financial services sector. Tech. rep.,
DTIC Document, 2012.
[30] DEVECSERY, D., CHOW, M., DOU, X., FLINN, J., AND CHEN,
P. M. Eidetic systems. In 11th USENIX Symposium on Operating
Systems Design and Implementation (OSDI 14) (2014), pp. 525–
540.
[31] GEHANI, A., AND TARIQ, D. Spade: Support for provenance
auditing in distributed environments. Middleware ’12.
[32] GOEL, A., PO, K., FARHADI, K., LI, Z., AND DE LARA, E. The
taser intrusion recovery system. SOSP ’05.
[33] GU, Z., PEI, K., WANG, Q., SI, L., ZHANG, X., AND XU, D.
Leaps: Detecting camouflaged attacks with statistical learning
guided by program analysis. In 2015 45th Annual IEEE/IFIP
International Conference on Dependable Systems and Networks
(June 2015), pp. 57–68.
[34] GUO, Z., ZHOU, D., LIN, H., YANG, M., LONG, F., DENG,
C., LIU, C., AND ZHOU, L. G2: A graph processing system for
diagnosing distributed systems. USENIX ATC’11.
[35] JIANG, X., WALTERS, A., XU, D., SPAFFORD, E. H., BUCH-
HOLZ, F., AND WANG, Y.-M. Provenance-aware tracing of-
worm break-in and contaminations: A process coloring approach.
ICDCS ’06, IEEE.
[36] KEENEY, M., KOWALSKI, E., CAPPELLI, D., MOORE, A.,
SHIMEALL, T., ROGERS, S., ET AL. Insider threat study: Com-
puter system sabotage in critical infrastructure sectors. US Secret
Service and CERT Coordination Center/SEI (2005).
[37] KIM, T., WANG, X., ZELDOVICH, N., AND KAASHOEK, M. F.
Intrusion recovery using selective re-execution. OSDI’10.
[38] KING, S. T., AND CHEN, P. M. Backtracking intrusions. SOSP
’03.
[39] KING, S. T., MAO, Z. M., LUCCHETTI, D. G., AND CHEN, P. M.
Enriching intrusion alerts through multi-host causality. NDSS ’05.
[40] KOLBITSCH, C., COMPARETTI, P. M., KRUEGEL, C., KIRDA,
E., ZHOU, X.-Y., AND WANG, X. Effective and efficient malware
detection at the end host. USENIX’09.
[41] KOLBITSCH, C., KIRDA, E., AND KRUEGEL, C. The power
of procrastination: Detection and mitigation of execution-stalling
malicious code. CCS ’11, ACM.
[42] KOWALSKI, E., CONWAY, T., KEVERLINE, S., WILLIAMS, M.,
CAPPELLI, D., WILLKE, B., AND MOORE, A. Insider threat
study: Illicit cyber activity in the government sector. US De-
1124    26th USENIX Security Symposium
USENIX Association
partment of Homeland Security, US Secret Service, CERT, and
the Software Engineering Institute (Carnegie Mellon University),
Tech. Rep (2008).
[43] LEE, K. H., ZHANG, X., AND XU, D. High accuracy attack
provenance via binary-based execution partition. NDSS ’13.
[44] LEE, K. H., ZHANG, X., AND XU, D. Loggc: garbage collecting
audit log. CCS ’13.
[45] MA, S., LEE, K. H., KIM, C. H., RHEE, J., ZHANG, X., AND
XU, D. Accurate, low cost and instrumentation-free security audit
logging for windows. ACSAC ’15.
[46] MA, S., ZHANG, X., AND XU, D. Protracer: towards practical
provenance tracing by alternating between logging and tainting.
NDSS ’16.
[47] MEHTA, V., BARTZIS, C., ZHU, H., CLARKE, E., AND WING, J.
Ranking Attack Graphs. 9th International Symposium on Recent
Advances in Intrusion Detection (RAID’06) 4219 (2006), 127–144.
[48] MILES, S., GROTH, P., MUNROE, S., AND MOREAU, L. Prime:
A methodology for developing provenance-aware applications.
ACM Transactions on Software Engineering and Methodology
(TOSEM) 20, 3 (2011), 8.
[49] MUNISWAMY-REDDY, K.-K., BRAUN, U., HOLLAND, D. A.,
MACKO, P., MACLEAN, D., MARGO, D., SELTZER, M., AND
SMOGOR, R. Layering in provenance systems. USENIX ATC’09.
[50] MUNISWAMY-REDDY, K.-K., HOLLAND, D. A., BRAUN, U.,
AND SELTZER, M. I. Provenance-aware storage systems. Usenix
ATC ’06.
[51] NAGARAJ, K., KILLIAN, C., AND NEVILLE, J. Structured
comparative analysis of systems logs to diagnose performance
problems. NSDI’12.
[52] NEWSOME, J., AND SONG, D. X. Dynamic taint analysis for
automatic detection, analysis, and signaturegeneration of exploits
on commodity software. NDSS’05.
[53] OU, X., BOYER, W. F., AND MCQUEEN, M. A. A scalable
approach to attack graph generation. In Proceedings of the 13th
ACM conference on Computer and communications security - CCS
’06 (2006), p. 336.
[54] OU, X., GOVINDAVAJHALA, S., AND APPEL, A. MulVAL: A
logic-based network security analyzer. 14th USENIX Security . . . ,
August (2005), 8.
[55] POHLY, D. J., MCLAUGHLIN, S., MCDANIEL, P., AND BUT-
LER, K. Hi-fi: Collecting high-fidelity whole-system provenance.
ACSAC ’12.
[56] RANDAZZO, M. R., KEENEY, M., KOWALSKI, E., CAPPELLI,
D., AND MOORE, A. Insider threat study: Illicit cyber activity
in the banking and finance sector. Tech. rep., DTIC Document,
2005.
[57] SAWILLA, R. E., AND OU, X. Identifying critical attack assets in
dependency attack graphs. In Lecture Notes in Computer Science
(including subseries Lecture Notes in Artificial Intelligence and
Lecture Notes in Bioinformatics) (2008), vol. 5283 LNCS, pp. 18–
34.
[58] SHEYNER, O., HAINES, J., JHA, S., LIPPMANN, R., AND WING,
J. M. Automated generation and analysis of attack graphs. In
Proceedings - IEEE Symposium on Security and Privacy (2002),