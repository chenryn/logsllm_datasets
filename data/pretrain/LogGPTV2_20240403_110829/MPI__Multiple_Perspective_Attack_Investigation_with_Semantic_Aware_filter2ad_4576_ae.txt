### Causal Graphs and Execution Units

MPI (Multiple Perspective Instrumentation) generates fewer execution units compared to BEEP/ProTracer, as shown in Table 1. On average, the number of units generated by MPI is only 25% of that generated by BEEP/ProTracer. For attacks involving GUI programs (e.g., Firefox), this reduction is even more significant, with MPI generating only 8% of the units. In an extreme case involving Transmission, MPI generates less than 1% of the units.

In terms of attack graphs, MPI can reduce the number of nodes to 92% and the number of edges to 83% on average. This is particularly effective for attacks with simple propagation paths, where BEEP/ProTracer already produces succinct graphs. For more complex cases, MPI can further reduce the graphs to 76% of the nodes and 62% of the edges.

We have also evaluated MPI on several realistic attack scenarios. One such case is detailed below, with two additional cases presented in Appendix C to highlight MPI's advantages over BEEP/ProTracer in insider threat detection and tracking complex browsing behaviors in Firefox.

### Case Study: FTP Data Leak

Exploiting system misconfiguration to acquire valuable sensitive information is a common attack vector [9, 14]. It is crucial to assess and control damages once the issue is identified. In this incident, an FTP administrator mistakenly configured the root directory of many users to a folder containing classified files and granted them read access. Upon noticing the problem, the server was shut down, and an investigation was initiated to determine the extent of the potential information leak. During the misconfiguration period, there were thousands of connections from a large number of users, and the number of classified files was also substantial.

#### Investigation Perspectives

Figure 16 illustrates various possible investigation perspectives for the FTP server application. Event loop-based partitioning techniques (Box 1) and traditional auditing approaches (Box 3) are based on each command or user request and the entire process, respectively. MPI offers more aligned choices with the logical structures of the application, such as:
- **Session Perspective** (Box 2): All commands/requests from a session are grouped into a single unit.
- **Directory Perspective** (Box 4): All commands on a given directory are considered a unit.
- **User Perspective** (Box 5): All commands/requests from a user (not limited to an IP address) are grouped into a unit.

Since all FTP commands are associated with a file or directory, we can partition FTP execution based on this information.

#### Graph Comparison

Part of the BEEP graph is shown in Figure 17, where each user command is captured as a unit. The simplified graph by MPI using connection-based partitioning is shown in Figure 18, and user-based partitioning in Figure 19. The connection perspective reduces the need for the inspector to go through individual commands, while the user perspective aggregates all behaviors from a specific user across multiple sessions, making it easier to hold individuals accountable. Note that a user can use various IP addresses to connect to the server, and without MPI, such semantic information cannot be exposed to the provenance tracking system.

The number of nodes in the BEEP, connection (MPI), and user (MPI) graphs are 962, 224, and 78, respectively. It is important to note that MPI graphs cannot be generated from the BEEP graph by post-processing due to subtask delegation in the program, which makes it difficult to attribute a sub-task to the top-level unit with only the low-level semantic information in the BEEP graph.

### Discussion

Similar to many existing works [23, 43, 44, 46, 55], MPI trusts the Linux kernel and the components associated with the audit logging system. Attacks that bypass the security mechanisms of these systems may cause problems for MPI. Additionally, attacks targeting the underlying audit system, such as audit log blurring and log filling, may inject noise into logs, making log inspection difficult. However, MPI leverages existing features provided by the operating system and provenance systems to mitigate some of these issues. For example, Ubuntu Software Center delivers trustworthy software, and Hi-Fi uses reference monitor guarantees to protect audit logs.

MPI is designed to address dependency explosion caused by long-running processes with accuracy and flexibility. It is an add-on service to the OS-level provenance collection system (e.g., the Linux Audit system, LPM-HiFi, and ProTracer). While system calls can be too coarse-grained, fine-grained events such as library calls or instruction-level dependencies may need to be captured for sophisticated attacks. MPI's multiple perspective partitioning is orthogonal and independent of the granularity of the events captured by the underlying provenance system, making it easily integrable with systems of various granularities.

MPI requires program source code, as the semantic information needed for multiple perspective partitioning is difficult to acquire through binary analysis for complex programs like Firefox. If partitioning a binary is necessary, training and event loop-based approaches like BEEP can be used together with MPI. In the worst-case scenario, MPI treats the entire process execution as a unit, which is only problematic for long-running processes. Many malware executables are not long-running, so treating a whole process as a unit does not introduce many false dependencies and still captures the attack path, albeit with more effort required to analyze the causal graph.

MPI relies on source code annotations, which are widely used in practice. For example, Firefox has 926 different types of annotations, and MPI introduces only 36 annotations (of 4 types) in Firefox. Although MPI cannot find units within dynamic code, in practice, unit boundaries mostly lie in static code. For instance, JavaScript code can be grouped into different tabs, allowing dynamic code to be attributed to tab units.

### Related Work

Many approaches have been proposed for system-level provenance tracking. Detailed comparisons of MPI with existing audit systems [10, 31, 43–45] can be found in §2. Another important approach is monitoring internal kernel objects (e.g., the file system [27, 49, 50, 59–61, 69] or LSM objects [23, 32, 55]) to track lineages. These techniques complement MPI, as shown in the integration of MPI and LPM-HiFi in §4.

System-wide record-and-replay techniques [30, 37–39] can also track provenance but require deterministic record-and-replay techniques, which are open research problems and cause more space overhead. Whole-system tainting [28, 35, 52, 68] is another method, but it needs to handle the granularity problem as the taint set may explode for long-lived system objects/subjects. MPI can be applied to such systems to overcome the dependency explosion problem and enable multiple perspective inspection.

Researchers have proposed developing provenance-aware applications [48], and Muniswamy-Reddy et al. [49] provide a library with provenance tracking APIs. Such approaches rely on programmers to modify their code extensively. In contrast, MPI aims to address the partitioning problem through the underlying audit system. Many works [22, 27, 44, 67] focus on reducing the space overhead of provenance tracking using reachability analysis and Mandatory Access Control (MAC) policies. Provenance visualization [25, 26, 47, 53, 57] and graph compression [34, 54, 58, 63–65] are also proposed to correlate events and reduce graph size, facilitating investigation. These approaches work on generated graphs and are complementary to MPI, which can directly apply to its provenance logs and graphs.

Machine learning methods [21, 24, 33, 40, 41, 51, 66] have been proposed to investigate provenance data and find abnormal behaviors. The multiple perspectives provided by MPI may substantially improve their effectiveness.

### Conclusion

Execution partitioning is crucial for addressing dependency explosion in audit logging. Existing techniques are event loop-based, generating many small units, requiring training to detect dependencies, and lacking high-level task information. MPI partitions based on high-level tasks, allowing users to annotate data structures corresponding to these tasks and leveraging compiler instrumentation to capture unit context switches and delegations. We implemented a prototype and evaluated it on three existing systems: Linux Audit, ProTracer, and LPM-HiFi. The results show that MPI generates much smaller graphs with lower overhead compared to state-of-the-art methods and avoids broken provenance due to incomplete training.

### References

[1] Apache benchmark. https://goo.gl/L7bGOK.
[2] The browser exploitation framework. http://beefproject.com/.
[3] Chinese hacker arrested for leaking 6 million logins. https://goo.gl/AO2Qlz.
[4] Clang language extensions. https://goo.gl/UpniZC.
[5] Event tracing for windows (ETW). http://msdn.microsoft.com/en-us/library/windows/desktop/aa363668(v=vs.85).aspx.
[6] Extensions to the C++ language. https://goo.gl/pn19Np.
[7] Extensions to the C language family. https://goo.gl/evrruW.
[8] GitHub hacked, millions of projects at risk of being modified or deleted. https://goo.gl/EdguGO.
[9] Leaked data. https://haveibeenpwned.com/.
[10] Linux audit subsystem. https://goo.gl/WSwnJB.
[11] Many watering holes, targets in hacks that netted Facebook, Twitter, and Apple. https://goo.gl/NIg2Va.
[12] More details on "Operation Aurora". https://goo.gl/p76ovs.
[13] Sloccount. http://www.dwheeler.com/sloccount/.
[14] The Sony hack. https://goo.gl/B4G7Pl.
[15] Tuxpaint. www.tuxpaint.org.
[16] UBSI. https://github.com/kyuhlee/UBSI.
[17] Vim document: windows. https://goo.gl/Lqp9Gb.
[18] Watering hole attack. https://goo.gl/AcN0dv.
[19] Watering hole attack. https://goo.gl/aw1t9l.
[20] Windows event log. https://msdn.microsoft.com/en-us/library/windows/desktop/aa385780(v=vs.85).aspx.
[21] ARP, D., SPREITZENBARTH, M., HUBNER, M., GASCON, H., AND RIECK, K. Drebin: Effective and explainable detection of Android malware in your pocket. NDSS’14.
[22] BATES, A., BUTLER, K. R., AND MOYER, T. Take only what you need: Leveraging mandatory access control policy to reduce provenance storage costs. TaPP ’15.
[23] BATES, A., TIAN, D. J., BUTLER, K. R., AND MOYER, T. Trustworthy whole-system provenance for the Linux kernel. Usenix Security’15.
[24] BESCHASTNIKH, I., BRUN, Y., SCHNEIDER, S., SLOAN, M., AND ERNST, M. D. Leveraging existing instrumentation to automatically infer invariant-constrained models. ESEC/FSE’11.
[25] BEVAN, C. F., AND YOUNG, R. M. Planning Attack Graphs. In ACSAC (2011).
[26] BORKIN, M. A., YEH, C. S., BOYD, M., MACKO, P., GAJOS, K. Z., SELTZER, M., AND PFISTER, H. Evaluation of filesystem provenance visualization tools. IEEE Transactions on Visualization and Computer Graphics 19, 12 (Dec. 2013), 2476–2485.
[27] BRAUN, U., GARFINKEL, S., HOLLAND, D. A., MUNISWAMY-REDDY, K.-K., AND SELTZER, M. I. Issues in automatic provenance collection. In Provenance and annotation of data.
[28] CHOW, J., PFAFF, B., GARFINKEL, T., CHRISTOPHER, K., AND ROSENBLUM, M. Understanding data lifetime via whole system simulation. USENIX SSYM’04.
[29] CUMMINGS, A., LEWELLEN, T., MCINTIRE, D., MOORE, A. P., AND TRZECIAK, R. Insider threat study: Illicit cyber activity involving fraud in the US financial services sector. Tech. rep., DTIC Document, 2012.
[30] DEVECSERY, D., CHOW, M., DOU, X., FLINN, J., AND CHEN, P. M. Eidetic systems. In 11th USENIX Symposium on Operating Systems Design and Implementation (OSDI 14) (2014), pp. 525–540.
[31] GEHANI, A., AND TARIQ, D. Spade: Support for provenance auditing in distributed environments. Middleware ’12.
[32] GOEL, A., PO, K., FARHADI, K., LI, Z., AND DE LARA, E. The Taser intrusion recovery system. SOSP ’05.
[33] GU, Z., PEI, K., WANG, Q., SI, L., ZHANG, X., AND XU, D. Leaps: Detecting camouflaged attacks with statistical learning guided by program analysis. In 2015 45th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (June 2015), pp. 57–68.
[34] GUO, Z., ZHOU, D., LIN, H., YANG, M., LONG, F., DENG, C., LIU, C., AND ZHOU, L. G2: A graph processing system for diagnosing distributed systems. USENIX ATC’11.
[35] JIANG, X., WALTERS, A., XU, D., SPAFFORD, E. H., BUCHHOLZ, F., AND WANG, Y.-M. Provenance-aware tracing of worm break-in and contaminations: A process coloring approach. ICDCS ’06, IEEE.
[36] KEENEY, M., KOWALSKI, E., CAPPELLI, D., MOORE, A., SHIMEALL, T., ROGERS, S., ET AL. Insider threat study: Computer system sabotage in critical infrastructure sectors. US Secret Service and CERT Coordination Center/SEI (2005).
[37] KIM, T., WANG, X., ZELDOVICH, N., AND KAASHOEK, M. F. Intrusion recovery using selective re-execution. OSDI’10.
[38] KING, S. T., AND CHEN, P. M. Backtracking intrusions. SOSP ’03.
[39] KING, S. T., MAO, Z. M., LUCCHETTI, D. G., AND CHEN, P. M. Enriching intrusion alerts through multi-host causality. NDSS ’05.
[40] KOLBITSCH, C., COMPARETTI, P. M., KRUEGEL, C., KIRDA, E., ZHOU, X.-Y., AND WANG, X. Effective and efficient malware detection at the end host. USENIX’09.
[41] KOLBITSCH, C., KIRDA, E., AND KRUEGEL, C. The power of procrastination: Detection and mitigation of execution-stalling malicious code. CCS ’11, ACM.
[42] KOWALSKI, E., CONWAY, T., KEVERLINE, S., WILLIAMS, M., CAPPELLI, D., WILLKE, B., AND MOORE, A. Insider threat study: Illicit cyber activity in the government sector. US Department of Homeland Security, US Secret Service, CERT, and the Software Engineering Institute (Carnegie Mellon University), Tech. Rep (2008).
[43] LEE, K. H., ZHANG, X., AND XU, D. High accuracy attack provenance via binary-based execution partition. NDSS ’13.
[44] LEE, K. H., ZHANG, X., AND XU, D. Loggc: garbage collecting audit log. CCS ’13.
[45] MA, S., LEE, K. H., KIM, C. H., RHEE, J., ZHANG, X., AND XU, D. Accurate, low cost and instrumentation-free security audit logging for Windows. ACSAC ’15.
[46] MA, S., ZHANG, X., AND XU, D. Protracer: towards practical provenance tracing by alternating between logging and tainting. NDSS ’16.
[47] MEHTA, V., BARTZIS, C., ZHU, H., CLARKE, E., AND WING, J. Ranking Attack Graphs. 9th International Symposium on Recent Advances in Intrusion Detection (RAID’06) 4219 (2006), 127–144.
[48] MILES, S., GROTH, P., MUNROE, S., AND MOREAU, L. Prime: A methodology for developing provenance-aware applications. ACM Transactions on Software Engineering and Methodology (TOSEM) 20, 3 (2011), 8.
[49] MUNISWAMY-REDDY, K.-K., BRAUN, U., HOLLAND, D. A., MACKO, P., MACLEAN, D., MARGO, D., SELTZER, M., AND SMOGOR, R. Layering in provenance systems. USENIX ATC’09.
[50] MUNISWAMY-REDDY, K.-K., HOLLAND, D. A., BRAUN, U., AND SELTZER, M. I. Provenance-aware storage systems. Usenix ATC ’06.
[51] NAGARAJ, K., KILLIAN, C., AND NEVILLE, J. Structured comparative analysis of systems logs to diagnose performance problems. NSDI’12.
[52] NEWSOME, J., AND SONG, D. X. Dynamic taint analysis for automatic detection, analysis, and signature generation of exploits on commodity software. NDSS’05.
[53] OU, X., BOYER, W. F., AND MCQUEEN, M. A. A scalable approach to attack graph generation. In Proceedings of the 13th ACM conference on Computer and communications security - CCS ’06 (2006), p. 336.
[54] OU, X., GOVINDAVAJHALA, S., AND APPEL, A. MulVAL: A logic-based network security analyzer. 14th USENIX Security ..., August (2005), 8.
[55] POHLY, D. J., MCLAUGHLIN, S., MCDANIEL, P., AND BUTLER, K. Hi-fi: Collecting high-fidelity whole-system provenance. ACSAC ’12.
[56] RANDAZZO, M. R., KEENEY, M., KOWALSKI, E., CAPPELLI, D., AND MOORE, A. Insider threat study: Illicit cyber activity in the banking and finance sector. Tech. rep., DTIC Document, 2005.
[57] SAWILLA, R. E., AND OU, X. Identifying critical attack assets in dependency attack graphs. In Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics) (2008), vol. 5283 LNCS, pp. 18–34.
[58] SHEYNER, O., HAINES, J., JHA, S., LIPPMANN, R., AND WING, J. M. Automated generation and analysis of attack graphs. In Proceedings - IEEE Symposium on Security and Privacy (2002).