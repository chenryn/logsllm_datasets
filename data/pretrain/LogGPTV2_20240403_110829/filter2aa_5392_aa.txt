.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.\".de Sh\" Subsection heading
.\".br
.\".if t .Sp
.\".ne 5
.\".PP
.\"\fB\\$1\fR
.\".PP
.\"..
.\".de Sp\" Vertical space (when we can't use .PP)
.\".if t .sp .5v
.\".if n .sp
.\"..
.\".de Vb\" Begin verbatim text
.\".ft CW
.\".nf
.\".ne\\$1
.\"..
.\".de Ve\" End verbatim text
.\".ft R
.\".fi
.\"..
.\".\" Set up some character translations and predefined strings. \*(-- will
.\".\" give an unbreakable dash,\*(PI will give pi,\[lq] will give a left
.\".\" double quote, and\[rq] will give a right double quote.  | will give a
.\".\" real vertical bar. \*(C+ will give a nicer C++.  Capital omega is used to
.\".\" do unbreakable dashes and therefore won't be available. ` and'
.\".\" expand to `' in nroff, nothing in troff, for use with C<>.
.\".tr \(*W-|\(bv\*(Tr
.\".ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.\".ie n\{\
.\".    ds --\(*W-
.\".    ds PI pi
.\".    if (\n(.H=4u)&(1m=24u) .ds --\(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.\".    if (\n(.H=4u)&(1m=20u) .ds --\(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.\".    ds L" ""
.\".    ds R" ""
.\".    ds C` ""
.\".    ds C' ""
.\"'br\}
.\".el\{\
.\".    ds --\|\(em\|
.\".    ds PI\(*p
.\".    ds L" ``
.\".    ds R" ''
.\"'br\}
.\".\"
.\".\" If the F register is turned on, we'll generate index entries on stderr for
.\".\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\".\" entries marked with X<> in POD.  Of course, you'll have to process the
.\".\" output yourself in some meaningful fashion.
.\".if\nF\{\
.\".    de IX
.\".    tm Index:\\$1\t\\n%\t"\\$2"
.\"..
.\".    nr % 0
.\".    rr F
.\".\}
.\".\"
.\".\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\".\" way too many mistakes in technical documents.
.\".hy 0
.\".if n .na
.\".\"
.\".\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\".\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.\".   \" fudge factors for nroff and troff
.\".if n\{\
.\".    ds #H 0
.\".    ds #V .8m
.\".    ds #F .3m
.\".    ds #[\f1
.\".    ds #]\fP
.\".\}
.\".if t\{\
.\".    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.\".    ds #V .6m
.\".    ds #F 0
.\".    ds #[\&
.\".    ds #]\&
.\".\}
.\".   \" simple accents for nroff and troff
.\".if n\{\
.\".    ds '\&
.\".    ds `\&
.\".    ds ^\&
.\".    ds ,\&
.\".    ds ~ ~
.\".    ds /
.\".\}
.\".if t\{\
.\".    ds '\\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.\".    ds `\\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.\".    ds ^\\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.\".    ds ,\\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.\".    ds ~\\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.\".    ds /\\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\".\}
.\".   \" troff and (daisy-wheel) nroff accents
.\".ds :\\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.\".ds 8\h'\*(#H'\(*b\h'-\*(#H'
.\".ds o\\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.\".ds d-\h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.\".ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.\".ds th\*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.\".ds Th\*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.\".ds ae a\h'-(\w'a'u*4/10)'e
.\".ds Ae A\h'-(\w'A'u*4/10)'E
.\".   \" corrections for vroff
.\".if v .ds ~\\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.\".if v .ds ^\\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.\".   \" for low resolution devices (crt and lpr)
.\".if\n(.H>23 .if\n(.V>19\
.\"\{\
.\".    ds : e
.\".    ds 8 ss
.\".    ds o a
.\".    ds d- d\h'-1'\(ga
.\".    ds D- D\h'-1'\(hy
.\".    ds th\o'bp'
.\".    ds Th\o'LP'
.\".    ds ae ae
.\".    ds Ae AE
.\".\}
.\".rm #[ #] #H #V #F C
.\".\" ========================================================================
.\".\"
.\".IX Title "PERLDATA 1"
.TH PERLDATA 7 "2003-11-25" "perl v5.8.3" "Perl Programmers Reference Guide"
.SH "NAME"
perldata\- Perl 数据类型
.SH "DESCRIPTION 描述"
.\".IX Header "DESCRIPTION"
.SS "Variable names 变量名"
.\".IX Subsection "Variable names"
Perl 有三种内建的数据类型：标量，数组和关联数组（即\[lq]哈希表，
hash\[rq]）。数组以数字为索引，通常以0开始，升序排列。哈希表以与值相关联
的字符串为索引，内部排列是无序的。
.PP
值通常通过一个变量名（或变量名的引用）来引用。变量名的前缀字符显示了值的
数据类型。其余部分指明了引用的是哪一个特定的值。通常变量名是一个唯一的标
识符，以字母或下划线开始，包括字母、下划线和数字。某些情况下，也可以是以
`::'\fR 分隔的一串标识符(或者是过时的`''\fR)；除了最后一
个，其它都是包名，用来定位最后一个标识符所在的位置(详情参见 perlmod 中的
Packages)。可以用一个简单的标识符来替代它，利用引用就可以。下文有详述，
也可参见 perlref .
.PP
Perl 也有内建的变量，其名称不遵循这一规则。它们名称古怪，这样可以避免与你的变量名冲突。模式匹配中被匹配到的字符串是以`$'\fR 加一个数字的变量名来存放的(参见 the perlop manpage 和 the perlre manpage)。 另外，还有几个使你可以介入perl 内部工作的特殊变量，其名称中包含标点和控制字符（参见 perlvar ）
.PP
标量以 '$'开始, 即使它是数组或哈希的元素也是如此。可以把 '$' 理解为`s' 
，表示scalar（标量）。（译者注：此处根据有关文档，做了改动，下面的@处也
是这样）
.PP
.nf
\&    $days               # 简单标量 "days"
\&    $days[28]           # 数组 @days的第29个元素
\&    $days{'Feb'}        # 哈希 %days的 `Feb' 所对应的值
\&    $#days              # 数组 @days的最后一个元素的索引值
.fi
.PP
整个数组（或数组和哈希的局部）以 '@'开始, 它类似英文中的\[lq]these\[rq] 
或\[lq]those\[rq] (这些...那些...)，表示期望有多个值。
.PP
.nf
\&    @days               # ($days[0], $days[1],... $days[n])
\&    @days[3,4,5]        # 即 ($days[3],$days[4],$days[5])
\&    @days{'a','c'}      # 即 ($days{'a'},$days{'c'})
.fi
.PP
整个哈希以 '%' 开始:
.PP
.nf
\&    %days               # (key1, val1, key2, val2 ...)
.fi
.PP
另外，子程序以'&'来表示, 但有时在不引起误解的情况下也可以不用, 就象
\[lq]do\[rq] 在英语中常常省略一样。 符号表项以 '*' 作为开始字符, 不过你
现在还不用关心这个 (if ever ;-)
.PP
每一种数据类型都有它自己的名字空间，常量标识符也一样。这意味着你可以使用