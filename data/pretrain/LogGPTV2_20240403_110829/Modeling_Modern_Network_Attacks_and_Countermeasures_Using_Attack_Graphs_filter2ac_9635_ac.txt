### NAT规则处理

NAT规则的输出来自Ri，即使没有其他因素影响也可能会发生。例如，将X转换为Y的NAT规则并不妨碍在没有X的情况下出现Y。我们按照以下方式处理NAT规则：

\[ R_i = R_{i+1} \cup (exist(R_{i+1} \cap P_i, M_i) \cap T_i) \]

**跳转规则**会移除它们匹配的内容，因为这些可达性会被发送到其他链中：\[ R_i = R_{i+1} - P_i \]。

**加跳转规则**则没有任何效果：\[ R_i = R_{i+1} \]。

然而，当从另一条链回溯到跳转或加跳转规则时，这两种规则的处理方式不同：在这种情况下，对规则组的评估将从跳转或加跳转规则开始，而不是从规则组的末尾开始。因此，我们在跳转/加跳转规则i处开始，并考虑该规则可能发送到我们现在所在的链的所有内容。

### 示例

以图2中的链图为例，假设流量通过eth2反向传播。我们在链3上开始，初始T值为空集。反向处理后，我们会到达链3的起点，此时S值为全集。这将传播到链1的接受处置，以及链2规则组中间的跳转规则。

到达跳转规则时，我们计算\[ P_i \cap * \]，结果为\[ R_i = 2 \rightarrow b \]；这是唯一可能被此跳转规则发送到链3的流量，因此只有这部分可以反向传播。从链2，结果\[ 2 \rightarrow b \]成为链1默认处置的输入。

现在我们可以反向遍历链1的规则组，如图1右侧所示。输入是T为空集。规则组中的最后一条规则“接受4 → b”计算\[ R_i = (R_{i+1} - P_i) \cup (A \cap P_i) \]，结果为\[ R_i = ((2, 4) \rightarrow b) \]。

NAT规则反向操作Ri的内容，将\[ 4 \rightarrow * \]转换回\[ 1 \rightarrow * \]，但不移除\[ 4 \rightarrow * \]。最终结果为\[ R_i = ((1, 2, 4) \rightarrow b) \]。

最后，第一个过滤规则作用于\[ * \]。从这里，\[ P_i \cap R_i = (1 \rightarrow a) \]，因此将其添加到最终答案中，\[ R_1 = ((1, 2, 4) \rightarrow b, 1 \rightarrow a) \]。这就是能够进入eth0并从eth2出来的所有可达性的总和。

### 防火墙流量讨论

上述讨论主要集中在防火墙流量上。对于具有自己规则的受害主机或未禁用自身防火墙的恶意服务器，处理方法类似。如果流量来自地址为X的受害主机，我们在接口的出站链上以T为空集开始，并像之前一样反向遍历。

对于有防火墙保护的恶意服务器，情况更为复杂，因为没有明确的出口节点——任何可以从入站链到达的链都可能提供到达主机本身的可达性。NetSPA系统因此通过\[ S = * \]计算前向可达性，记录所有到达的链，然后从这些链作为潜在出口节点进行反向可达性计算。

### 非透明代理和IPS系统

透明代理看起来就像内联防火墙。要使用非透明代理，客户端必须配置为显式连接到代理主机，后者再代表客户端建立连接。从可达性的角度来看，客户端只连接到代理，但代理可以代表客户端连接到任何地方。

我们在NetSPA中通过目标NAT来模拟这种情况。我们添加一个形式为\[ * \rightarrow X : DNAT to * \]的NAT规则，其中X是代理服务器自身的IP和端口号。其他目标值（如协议和端口号）可以根据需要设置为通配符。随后限制可接触服务器的IPS系统可以通过在DNAT规则之后添加拒绝规则来建模。

NetSPA使用类似的技巧来模拟IPS的效果。假设存在攻击向量到漏洞的映射，NetSPA通过将其视为防火墙来建模IPS。NetSPA的过滤模型已扩展为基于漏洞阻止流量，将漏洞添加到源IP、目的IP、目的端口和协议的标准四元组中。

### 主机和防火墙分组

用于表示可达性的I × K矩阵通常是高度冗余的；在典型网络中，防火墙和其他过滤设备通常将一组接口同等对待。这样的接口组在矩阵中会有相同的行，因为它们都能到达相同的端口。NetSPA识别这些前向可达性组，并只为每个组计算一行，从而节省时间和空间。

为此，NetSPA收集所有防火墙规则中使用的单个IP地址和范围集合N。在同一子网上具有相同规则的两个接口，如果它们的监听地址在N的同一子集中，则可以组合在一起；其中一个的可达性与另一个相同。在一个具有I个接口和L条规则的网络上，这种分组操作的时间复杂度为O(IL + I log I)，但运行该算法获得的节省非常显著。在理想情况下，即一个内部子网互联且防火墙不对网络主机进行区分的网络中，I × K矩阵大小中的因子I可以有效地消失并被常数替代。在极端情况下，每个接口都被不同对待的网络中，则不会有任何节省。实际上，我们发现真实网络通常能从这种方法中获得显著的好处。在第六部分B2节中探讨的第一个案例中，我们将单元格数量从65,025减少到了3,825——时间与内存节省了17倍。

NetSPA可以使用类似的方法创建反向可达性组，合并I × K矩阵中的冗余列。

此外，NetSPA通过形成目标可达性组来组合具有相同个人防火墙规则集的主机。如果两个单宿主机位于同一子网并且其入站链同构（即使用相同的规则组且所有链的处置同构），则它们属于同一个组。NetSPA的可达性引擎可以一次遍历目标可达性组的公共规则，以尝试达到组内的每个主机。然而，额外的上下文意味着系统也知道在组内成员之间传输流量时遍历它们的出站和入站链。

### 性能评估

为了评估新系统的可扩展性，我们在各种合成网络上进行了多次测量测试。所有测试都在一台2.4GHz Pentium 4计算机上执行，该计算机运行Linux操作系统并配备1GB RAM。峰值内存测量通过Linux的libmemusage.so库完成。我们通过挂钟时间测量运行时间。对于时间测试，系统运行五次，丢弃第一次结果并对剩余四次取平均值。在所有情况下，系统假设有一个外部攻击者，按需计算可达性，构建攻击图，并计算推荐的补救步骤。

#### 完全和部分合成网络

我们首先比较新系统聚合个人防火墙的能力与旧系统昂贵的解决方法。我们使用了一个包含251台主机的小型网络的测试数据。我们在其中52台主机上放置了相同的合成个人防火墙，并将通用规则集中的规则数量从0增加到10,000；这些结果如图3顶部所示。然后，我们将具有个人防火墙的主机数量从0增加到52，固定通用规则集为250条规则；这些结果如图3底部所示。在这两种情况下，我们都显示了总消耗时间以及从X轴零点起的内存消耗变化。我们仅显示内存变化，以便清晰地看到两个系统之间的缩放效应，因为基线内存需求的差异相对不重要。

新系统的优势非常明显：添加共享规则集的额外个人防火墙几乎没有任何影响。增加规则集中的规则数量会导致近似线性的增长，尽管由于系统在整个测试过程中都非常快，这一点难以察觉。实际上，我们预计个人防火墙规则集不会超过2,000条规则。

我们还在图5所示的合成网络上进行了额外的可扩展性实验。如图所示，该网络由外部、DMZ、内部以及两个隔离区组成。

![Network Diagram](network_diagram.png)

### 结论

通过这些优化和示例，文本变得更加清晰、连贯和专业。希望这些改进对你有所帮助！