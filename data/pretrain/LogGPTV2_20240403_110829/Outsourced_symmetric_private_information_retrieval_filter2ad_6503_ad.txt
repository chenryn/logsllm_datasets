if C claims to be querying zipcode but actually enters the
keyword “Michael” into the OPRF computation, the output
for C will be the tag F (Kzip, “Michael”), where Kzip is a
zipcode-speciﬁc key, which will match no tag stored at E .
To obtain OSPIR-OXT we combine the above two tools
with an authorization mechanism similar to the one used in
MC-OXT via a homomorphic signature (using the ρi expo-
nents) for binding together the n tokens corresponding to
an n-term conjunctive query in a way that E can verify. We
describe the changes to MC-OXT (deﬁned via Figure 1 and
the modiﬁcations in Section 3) required by OSPIR-OXT. We
ﬁrst replace the PRF Fp used in computing xtrap and xtag
values with a PRF FG which maps w directly onto the group
G generated by g, i.e. we set xtrap as FG(KX , w) instead of
gFp(KX ,w), hence xtag = (xtrap)xind will now be computed as
FG(KX , w)xind instead of gFp(KX ,w)·xind. We similarly replace
the PRF Fτ used in computing the strap value with the PRF
FG, i.e. we set strap as FG(KS, w) instead of Fτ (KS, w).
(Since we use strap as a key to Fτ in deriving (Kz, Ke), we
assume that a PRF Fτ key can be extracted from a random
group element.)
G s.t. F m
We also make a speciﬁc assumption on the implemen-
tation of the function TSetGetTag used to derive stag(w)
value, i.e., the handle pointing to the set TSet(w) which
is computed as TSetGetTag(KT , w). First, we assume that
TSetGetTag is implemented using PRF FG. Second, to en-
able enforcement of attribute-based policies we assume that
the key KT in TSetGetTag is formed by an array of FG
keys KT = (KT [1], ..., KT [m]), where KT [i] is the key to be
used only for keywords with attribute I(w) = i. For nota-
tional convenience we deﬁne a PRF F m
G (KT , w) =
FG(KT [I(w)], w), and we set stag(w) = TSetGetTag(KT , w)
to F m
G (KT , w). Since we explicitly handle the keys used in
the TSetGetTag implementation we also need to modify the
TSet API: We will initialize TSet as TSet ← TSetSetup0(T),
where T indexes the tuple lists t(w) not by the keywords w
but by the corresponding stag(w) values. (This API change
does not aﬀect existing TSet implementations [9] because
they internally use stag(w) = TSetGetTag(KT , w) to store
the t(w) list.) The PRF we use in the computation of
xtag’s will be similarly attribute-partitioned. Namely, KX
is also an array of m independent FG keys KX = (KX [1],
. . . , KX [m]), the xtrap value for keyword w is deﬁned as
F m
G (KX , w), and the xtag corresponding to keyword w and
index xind is set to (F m
G (KX , w))xind.
In OSPIR-OXT, there are two two-party protocols involved
in the computation of FG. In the ﬁrst case, the protocol im-
plements an OPRF computation in which C enters an input
w, D enters a key KS, and the output is FG(KS, w) for C and
⊥ for D. In the second case, F m
G is computed via a protocol,
that we call a shared OPRF (S-OPRF), in which C inputs w
and i = I(w), and D enters a key K and additional input
ρ ∈ Z ∗
p ; the output learned by D is i, and the output learned
G (K, x))ρ = (FG(K[i], x))ρ. Note that the pair of
by C is (F m
outputs ((F m
G (K, x))ρ, ρ) can be seen as a secret sharing of
F m
G (K, x), hence the name shared-OPRF. OSPIR-OXT uses
the OPRF protocol to let C learn the strap value correspond-
ing to the w1 s-term, i.e. strap = FG(KS, w1), without D
learning w1. The S-OPRF protocol is used to let C com-
G (KT , w1)]ρ1 and the blinded
pute a blinded stag bstag = [F m
xtraps bxtrapi = [F m
G (KI , wi)]ρi , for i = 2, ..., n. The func-
tionality of the blinding ρi is the same as in the case of
MC-OXT, namely, as a form of homomorphic signature bind-
ing and authorizing stag and xtrap’s that E can verify. As
in MC-OXT, E will receive the corresponding (de)blinding
factors ρ1, . . . , ρn in the authenticated envelope env.
To simplify the description of OSPIR-OXT, we assume
that both OPRF and S-OPRF protocols take a single round
of interaction between C and D, as is indeed the case for
several eﬃcient OPRF’s of interest [14, 21], including the
Hashed Diﬃe-Hellman OPRF [22] used in our implementa-
tion below. We denote C’s initial computation in the OPRF
protocol as (a, r) ← OPRF.C1(x) (a is the value sent to D
and r is randomness used by C), D’s response computation
as b ← OPRF.D(K, a), and C’s local computation of the ﬁnal
output as OPRF.C2(b, r). We use the corresponding notation
in the case of S-OPRF, except that S-OPRF.D takes as an
input a triple (K, i, a) where i is an attribute and outputs a
pair (b, ρ). See below for a simple implementation of these
procedures for the case of the Hashed Diﬃe-Hellman OPRF.
881GenToken protocol
• Client C, on input ¯w = (w1, ..., wn) where w1 is chosen as s-term:
– Compute (as, rs) ← OPRF.C1(w1), and (ai, ri) ← S-OPRF.C1(wi) for each i = 1, ..., n.
– Send (as, a1, ..., an) and av = (I(w1), ..., I(wn)) to D.
• Data owner D, on input policy P and master key K = (KS , KX , KT , KI , KP , KM ):
– Abort if av is not in policy set P. Otherwise set av as D’s local output.
– Compute bs ← OPRF.D(KS , as).
– Compute (b1, ρ1) ← S-OPRF.D(KT , I1, a1), and (bi, ρi) ← S-OPRF.D(KX , Ii, ai) for i = 2, .., n.
– Set env ← AuthEnc(KM , (ρ1, ρ2, ..., ρn)) and send (env, bs, b1, ..., bn) to C.
• C outputs token = (env, strap, bstag, bxtrap2, ..., bxtrapn) where strap ← OPRF.C2(bs, rs),
bstag ← S-OPRF.C2(b1, r1), and bxtrapi ← S-OPRF.C2(bi, ri) for i = 2, ..., n.
Figure 2: Token Generation in OSPIR-OXT
OSPIR-OXT Speciﬁcation. With the above ingredients
and notation we specify OSPIR-OXT on the basis of MC-OXT
via the following changes.
Keys. Select key KS for FG; KT and KX for F m
Fp; and KM for the authenticated encryption scheme.
G ; KI for
EDBSetup. Follow the EDBSetup procedure of MC-OXT ex-
cept for computing strap ← FG(KS, w) and
xtag ← (F m
procedure as TSetGetTag(KT , w) = F m
that we compute stag(w) ← F m
G (KT , w); index t(w) in T
by stag(w) instead of by w itself; and generate TSet using
the modiﬁed API procedure TSetSetup0(T).
G (KX , w))xind, and for implementing the TSetGetTag
G (KT , w), which means
GenToken protocol. This is the main change with respect
to OSPIR-OXT; it follows the above mechanisms and is pre-
sented in Figure 2.
Search protocol. Same as MC-OXT except that stag is not
included under env but rather it is provided to E by C as
bstag from which E computes stag ← (bstag)1/ρ1 .
Instantiation via Hashed Diﬃe-Hellman OPRF. Our
implementation and analysis of OSPIR-OXT assumes the use
of Hashed DH OPRF mentioned above, namely, FG(K, x) =
(H(x))K. The instantiations of OPRF and S-OPRF protocols
in this case are as follows. OPRF.C1(x) and S-OPRF.C1(x)
p , set a ← (H(x))r, and output
both pick random r in Z ∗
(a, r). Procedure OPRF.D(K, a), where K ∈ Z ∗
p is a key for
PRF FG, outputs b ← aK. Procedure S-OPRF.D(K, i, a),
p )m
where i ∈ {1, ..., m} and K = (K[1], . . . , K[m]) ∈ (Z ∗
is a key for PRF F m
p , computes
b ← aK[i]·ρ, and outputs (b, ρ). Procedures OPRF.C1(b, r)
and S-OPRF.C1(b, r) both output b1/r. Note that if parties
follow the protocol, C’s ﬁnal output is equal to (H(x))K =
FG(K, x) in the OPRF protocol, while in the S-OPRF proto-
G (K, x))ρ
col it is equal to (H(x))K[i]·ρ, which is equal to (F m
if i = I(x). These OPRF and S-OPRF protocols emulate
their corresponding ideal functionalities in ROM under so-
called One-More Gap Diﬃe-Hellman assumption [22], see
Section 5.
G , picks random ρ in Z ∗
Figure 3 shows the OSPIR-OXT scheme instantiated with
the above Hashed DH OPRF. It helps to visualize the entire
protocol and it reﬂects our actual implementation. In Fig-
ure 3 we denote keys KT and KX of PRF F m
G by vectors of
exponents in Z ∗
p , respectively (k1, . . . , km) and (e1, . . . , em),
where m is the number of attributes. Also, because of the
speciﬁc OPRF instantiation we equate as to a1 in C’s mes-
sage of the GenToken protocol, instead of computing these
two blinded versions of keyword w1 separately, as in Fig-
ure 2.
4.2 Supporting Boolean Queries
For simplicity we presented our protocols for the case
of conjunctions. The protocols can be readily adapted to
search boolean queries in “searchable normal form (SNF)”,
i.e., of the form “w1 ∧φ(w2, . . . , wm)” (intended to return any
document that matches keyword w1 and in addition satis-
ﬁes the formula φ on the remaining keywords). In this case,
OXT and its derivatives change only in the way E determines
which tuples match a query (i.e., which values e it sends
back to C). Speciﬁcally, in OXT the c-th tuple matches if
and only if xtoken[c, i]y/ρi ∈ XSet for all 2 ≤ i ≤ n. Instead,
for boolean queries as above, E will have a set of boolean
variables v2, . . . , vn and will set vi to the truth value of the
predicate xtoken[c, i]y/ρi ∈ XSet. A tuple is matching if and
only if the result of evaluating φ on these values returns
true. The complexity of boolean search is same as for con-
junctions, i.e., proportional to |DB(w1)|, and leakage to E
is the same as for a conjunctive query on the same set of
keywords except that E also learns the expression φ being
evaluated. See [9] for details and support of other forms of
boolean queries.
In the OSPIR-SSE setting, supporting boolean queries re-
quires policies that are deﬁned in terms of such queries.
Speciﬁcally, a policy will determine a set of allowed pairs
(ψ, I) where ψ is a symbolic boolean expression and I a
sequence of attributes, one per each variable in ψ. Thus,
leakage to D will include I (as in the case of conjunctions)
plus the symbolic expression being evaluated.
4.3 Computational Cost
Here we provide an operations count for OSPIR-OXT when
instantiated with the DH-based OPRF noting its (mild)
overhead over the original OXT protocol from [9]. The com-
putational cost of OSPIR-OXT is easy to quantify by inspect-
ing Figure 3 in Page .
882The cost of pre-processing (EDBSetup) is dominated by
operations related to the group G, mainly exponentiations:
For every w ∈ W:
1. One hashing operation, H(w), of keyword w into an
element of the group G.
2. Two exponentiations: strap(w) = (H(w))KS and stag(w) =
(H(w))ki.
3. For every ind in DB(w): One exponentiation H(w)ei ·xind
for computing an XSet element.
The ﬁrst two items are speciﬁc to OSPIR-OXT while the
third is from the original OXT protocol, except that here
the base for exponentiation is changed from the generator g
in OXT to the value H(w). Hence the overhead introduced
by OSPIR-OXT is given by the ﬁrst two items and the vari-
able base. Importantly, the overhead for the ﬁrst two items
is only linear in |W|, typically much smaller than the num-
ber of exponentiations in OXT (item 3), namely one per pair
(w, ind) for ind ∈ DB(w). As for the latter exponentiations,
while the bases are variable, each H(w) is typically used
with a very large number of exponentiations (as the number
of documents containing w) hence allowing for signiﬁcant
same-base optimizations. The hashing of w into the group
G (item 1) is modeled as a random oracle, hence it rules
out algebraic implementations such as gh(w). For the ellip-
tic curves groups we use, H is realized by sampling a ﬁeld
element e and a bit b from a PRNG seeded with w until (e, b)
is the compressed representation of a valid group element.
Depending on the particular nature of a curve, the generic
square root algorithms required in solving the Weierstrass
equation, though, can be extremely ineﬃcient: Our origi-
nal implementation for the chosen NIST 224p curve using
OpenSSL’s standard algorithms was more than an order of
magnitude slower than a normal exponentiation and consid-
erably more when common-base optimization is used. By
implementing our own algorithm inspired by [4] and opti-
mizing it for this particular ﬁeld, we could reduce the cost
down to the order of an exponentiation. Once all these op-
timizations are in place, the performance of OSPIR-OXT is
remarkable as shown in Section 4.4 and, in much more de-
tails, in a companion paper [8].
The dominating cost of GenToken is just 2n + 1 exponen-
tiations for the client and n + 1 for D.
Finally, the cost of query processing between C and E
(Search) on a n-term SNF expression is as follows:
1. C computes n − 1 exponentiations for each tuple in
TSet(w1)
2. E performs up to n−1 exponentiations for each element
in TSet(w1).
Note that C can apply same-base optimization to the expo-
nentiations since each term in the SNF expression has its
own ﬁxed base. On the other hand, E cannot use same-base
optimizations. However, note that as soon as one of the val-