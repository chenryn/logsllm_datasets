than 16 bytes. Indexing means that an encoded value is used
to index a non-constant array. It is safe to decode the value
because the decoded value is of a primitive type and soon dies
after the operation. The entire buffer is never decoded.
Decoding Frontier (DF) Computation. Table. IV shows
the evaluation results of decoding frontier computation. The
ﬁrst column shows the programs. The next three columns
show the numbers of controllable operations, uncontrollable
operations, and their sum, respectively. The last column shows
the average number of constraints for each memory region
under test. Recall that if the solver returns SAT, TIMEOUT
or UNKNOWN for a constraint in any payload sequence test,
the corresponding operations are considered controllable.
We make the following observations. First, in most cases,
there are more UNSAT cases than SAT cases. This means that
most input related computations are not controllable. There
are a few exceptions. gif2png, apache, and chemtool
have more SAT cases as our modeling of the external library
0%20%40%60%80%100%Comparative (63%) Terminal (19%) Uncontrollable transformative (18%) Type  Widening (5%) Indexing (3%) Primitive Type  Conversion (5%) Irreversible Calculation   (5%) TABLE IV.
RESULTS FOR DECODING FRONTIER COMPUTATION.
Program
mupdf
Prozilla
stftp
yops
nginx
ngircd
unrar
mcrypt
gif2png
mp3info
fcrackzip
chemtool
vfu
unrtf
rarcrack
make
Xerces-C
apache
Average
Controllable
# of Operations
Uncontrollable
9
4
2
0
4
2
6
4
13
4
4
29
3
2
0
9
14
145
14.1
141
20
8
1
41
12
33
24
10
9
4
22
25
22
0
53
75
129
34.9
Total
150
24
10
1
45
14
39
28
23
13
8
51
28
24
0
62
89
274
49
Avg. # of
Constraints
16.4
15.9
11.5
8
17.2
14.1
14.2
18.3
16.9
15.3
13.6
14.1
15.5
14.5
0
15.4
14.8
17.7
14.05
calls is not complete and the modeling of ﬂoating point
functions is conservative. For example, we assume exp()
function can return any positive ﬂoating point values while
the parameter of the exp() function may have constraints,
hence it may not be able to produce some ﬂoating point
values. Note that such a conservative assumption only causes
over-approximation. Second, the total number of operations
for testing is not
large (apache has the largest number
274). This is because the controllability classiﬁcation for most
operations is straightforward (e.g., comparative operations and
copy operations) and hence does not require constraint solving.
Third, the average number of constraints in our tests is not
large, suggesting that controllable operations are often shallow
in the data ﬂow, meaning that
they are close to program
inputs. This supports our assumption that most computation
happens in the post-exploitable space. Note that we do not
need to test controllability of operations if their operands are
not controllable.
C. Case Studies
Running Web Servers on Real-world Trafﬁc. To further
evaluate the robustness of A2C, we run the instrumented web
servers on a real-world trafﬁc log. We obtained our institution’s
server access log from November 2015 to January 2016. The
log contains 5.6 million requests with 4.2 million unique
requests, including some suspicious requests with binary pay-
loads (about 100 of them). We also randomly inject 300 exploit
inputs to the access log. We ran three servers (apache,
nginx, and yops) with these requests. The results show that
the instrumented versions produce the same expected results
as the original versions except for the attacks. All attacks are
prevented. The throughput is only reduced by 8.83%, 7.37%,
and 5.49%, respectively.
Code Injection Through Benign Functions and Payload
Triggered Through Integer Overﬂow. In this case study,
we show how a payload can be injected through benign and
non-vulnerable program logic and later triggered by an integer
overﬂow vulnerability. Such a combination makes it difﬁcult
for traditional defense techniques. Fig. 14 shows code snippets
of the victim program, mupdf. First, observe that the xps_
read_dir_part() function reads a ﬁle. It opens a ﬁle at
Line 455, then gets the size of ﬁle at Line 458. Later, it reads
the ﬁle and puts it into a heap buffer (part->data) at Line
462. Note that the function xps_read_dir_part() is not
vulnerable. But still, the attacker can provide a crafted xps ﬁle
that contains a malicious payload. The payload will be injected
through the normal ﬁle read in the benign function. Thus,
most existing protection schemes including CFI, DFI, ASLR,
and boundary checkers cannot prevent such injection. While
malicious payload detection methods can identify the injected
shellcode by scanning the input ﬁle at the fread function,
the attacker can use obfuscation techniques to circumvent such
detection.
To trigger the payload, the attacker exploits an integer over-
ﬂow vulnerability. The integer overﬂow happens as follows.
It reads input from a ﬁle at Line 91 in lex_number().
Then the input is propagated to Line 97 where the integer
overﬂow occurs. The program assumes the input c is between
‘0’ to ‘9’, and converts it into an index (i). At Line 106,
the converted index is stored into buf->i. Later, the index
is used to write elements into a structure (at Lines 176-178
in pdf_repair_obj_stm()). Note that the earlier index
is propagated to variable n which is also used as an index.
This integer overﬂow can be leveraged to overwrite some
critical data ﬁelds such as function pointers in order to change
control ﬂow of the program to the injected shellcode. Note
that the exploit may not be detected by address sanitizers as
the attacker can manipulate the offset n to directly overwrite
the target memory addresses that may fall into other legitimate
memory regions, without overwriting the canaries.
In contrast, A2C defeats the attack by breaking its weakest
link, which is the injected payload itself. In particular, A2C
mutates the input including the shellcode at the fread in Line
462. The original shellcode is shown in Fig. 14 (a), and the
corresponding mutated shellcode in Fig. 14 (b). Observe that
the mutated shellcode is broken and not executable.
Fig. 14.
Integer Overﬂow in mupdf.
Note that A2C does not prevent the integer overﬂow. Even
through it encodes the input value at Line 91, it decodes the
value right before the overﬂow (at Line 97) because that is an
operation of primitive type. In other words, the attacker can
12
       static int lex_number (✁) {           ...  91:    int c =  fz_read_byte(f);              ...              case RANGE_0_9:  97:         i = 10*i  + Decode( c )                       -  '0';                ✁106:        buf->i  = i;pdf/pdf_lex.c       static void          pdf_repair_obj_stm (...) {          ...172:   n = buf.i;          ✁         // Triggering the shellcode176:   xref->table[n].ofs = num;177:   xref->table[n].gen = i;178:   xref->table[n].stm_ofs = 0;pdf/pdf_repair.c(a) Injected Shellcode(b) Mutated Shellcode  push    0x2e2e2e62  mov    edi, esp  xor      eax, eax   ...   ret       0x84c8  test  in        eax, dx   ... Hex: c2 c8 84 84 84 23 4d 99  ...Hex: 68 62 2e 2e 2e 89 e7 33 ...         static xps_part* xps_read_dir_part(...) {           ✁455:    file = fopen(buf, "rb");           ...458:       fseek(file, 0, SEEK_END);459:       size = ftell(file);              ...462:       fread(part->data, 1, size, file);    // Shellcode Injection                xps/xps_zip.cstill exploit integer overﬂow vulnerabilities. However, when
the control ﬂow of the program is redirected to the injected
shellcode, the execution crashes almost immediately as the ﬁrst
instruction of the mutated shellcode is “ret 0x84c8”, which
does not have a valid return address.
One might think the attacker can exploit the integer over-
ﬂow to direct the control ﬂow to some buffer in the post-
exploitable space. However, as we pointed out in Section V,
the transformations performed by the subject programs are
complex enough that the attackers cannot generate plain-text
payloads in the post-exploitable space.
Preventing ROP attacks. As DEP (Data Execution Preven-
tion) becomes more and more popular, attackers now use ROP
to bypass such protection. In this case study, we show how
A2C prevents ROP attacks using an example.
Fig. 15. Stack Buffer Overﬂow in unrtf.
Fig. 15 shows unrtf which has a stack buffer overﬂow
vulnerability. It can be leveraged to inject a malicious payload
that allows constructing a ROP gadget chain. The program ﬁrst
gets a user provided string at Line 342. Then, it compares the
string with a constant at Line 343. As it is a comparative op-
eration, A2C decodes the value, allowing proper comparison.
The buffer overﬂow happens when the program copies the user
provided buffer (tmp) to a local buffer name at Line 344 in
process_font_table(). Observe that the size of name
is only 255. Thus, providing a long enough input to the tmp
buffer will result in a stack overﬂow.
Fig. 15 (a) shows the injected ROP payload and the
corresponding gadgets. The address column shows the payload
that contains the raw addresses of the ROP gadgets. The
instructions column shows the instructions from the ROP
gadgets. Observe that they all end with a ret instruction.
These chains of instructions are essentially the ones that get
executed once the attack is launched. Fig. 15 (b) shows the
mutated payload. For demonstration purpose, we use a simple
encoding/decoding scheme even though our implementation
uses one-time-dictionary. In particular, the mutation is to xor a
value with 0xAA. Observe that all the addresses in the original
payload are encoded and point to invalid addresses. Hence, the
attack fails. Note that since A2C prevents attacks by mutating
payloads, the injection methods do not affect our protection.
Preventing English Shellcode. As a counter attack to shell-
code detection techniques, Mason et al. proposed an auto-
matic way to generate shellcode which is similar to English
prose [39]. Such technique can be used to avoid existing
shellcode identiﬁcation techniques [67], [37], [45], [18].
Fig. 16 shows an example of English Shellcode presented
in [39]. As shown in the ASCII column, the shellcode is an
English statement. The corresponding assembly instructions
are listed in the ﬁrst column. While we are just showing
Fig. 16. English Shellcode Example.
one example,
in practice attackers also use other various
shellcode obfuscation and compression techniques [38], [59]
to avoid shellcode identiﬁcation. A2C mutates all untrusted
inputs including shellcodes as they are part of the inputs. The
mutated English Shellcode includes those shaded in Fig. 16.
For demonstration, we again apply the xor with 0xAA muta-
tion. Observe that the mutated shellcode is completely different
from the original shellcode. While the ﬁrst instruction is exe-
cutable, it does not help attackers to achieve anything useful.
More importantly, the second instruction is iret, which can
only be executed in a kernel mode. Executing iret results
in a segmentation fault. One interesting observation is that
the ﬁrst a few instructions in the mutated shellcode are often
executable. The ﬁfth column of Table III shows the average
number of instructions executed in the mutated payload is
very small (<4). It
to note that such a
few (mutated) instructions do not have the same semantics
as the original malicious logic. They often immediately lead
to crashes and do not cause any damage to the system.
Buffer Overﬂow In Structure. AddressSanitizer [56] is an
important technique to prevent various buffer overﬂow attacks
including heap and stack overﬂows. It works by placing
canaries before and after a buffer. One of the limitations of
the technique is that it cannot handle buffer overruns within a
structure.
is also important
Fig. 17. Buffer Overrun in Structure.
Fig. 17 shows a buffer overﬂow vulnerability in a structure.
Speciﬁcally, buffer name in the structure RECORD can affect
adjacent data ﬁelds including a function pointer handler.
At Line 1, it reads a ﬁle to ﬁll the name buffer. By provid-
ing an input string longer than 255 bytes, it can overwrite
handler. Note that A2C mutates the input in fread at