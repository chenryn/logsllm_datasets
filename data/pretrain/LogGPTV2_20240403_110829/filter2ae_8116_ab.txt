public void setBookMapper(BookMapper bookMapper) {
? this.bookMapper = bookMapper;
}
方法注入的这个bookMapper是哪里来的了，是由我们配置了MapperScannerConfigurer这个bean后这个bean帮我们扫描dao包下的借口文件并生成bean然后再帮我们注入到Spring的IOC容器中，所以我们才可以在BookServiceImpl这个bean中通过标签注入bookmapper这个bean
然后我们来看这项配置
这里是生成一个id为sqlSessionFactory的bean，这里就要引出Mybatis中的两个关键对象即sqlSessionFactory和sqlSession。
简单介绍下这两个对象
SqlSessionFactory
SqlSessionFactory是MyBatis的关键对象，它是单个数据库映射关系经过编译后的内存镜像。SqlSessionFactory对象的实例可以通过SqlSessionBuilder对象获得，而SqlSessionBuilder则可以从XML配置文件或一个预先定制的Configuration的实例构建出SqlSessionFactory的实例。SqlSessionFactory是创建SqlSession的工厂。
SqlSession
SqlSession是执行持久化操作的对象，类似于JDBC中的Connection。它是应用程序与持久存储层之间执行交互操作的一个单线程对象。SqlSession对象完全包括以数据库为背景的所有执行SQL操作的方法，它的底层封装了JDBC连接，可以用SqlSession实例来直接执行已映射的SQL语句。
SqlSessionFactory和SqlSession的实现过程：
mybatis框架主要是围绕着SqlSessionFactory进行的，创建过程大概如下：
(1)、定义一个Configuration对象，其中包含数据源、事务、mapper文件资源以及影响数据库行为属性设置settings
(2)、通过配置对象，则可以创建一个SqlSessionFactoryBuilder对象
(3)、通过 SqlSessionFactoryBuilder 获得SqlSessionFactory 的实例。
(4)、SqlSessionFactory 的实例可以获得操作数据的SqlSession实例，通过这个实例对数据库进行
如果是spring和mybaits整合之后的配置文件,一般以这种方式实现,SqlSessionFactory的创建:
SqlSessionFactoryBean是一个工厂Bean，根据配置来创建SqlSessionFactory
如果是单独的使用手动创建SqlSessionFactory和SqlSession话流程如下
看完了SqlSessionFactory和SqlSession的基础知识我们同时注意到下面这个标签的value属性，“classpath:mybatis-config.xml”
这里又引入了一个xml配置文件，还记得我上面刚说过spring-dao.xml是用来整合Spring和Mybatis的么？这个mybatis-config.xml就是我们Mybatis的配置文件。
好了spring-dao.xml这个用来整合Spring和Mybatis的配置文件我们已经了解了，程序按着刚才的请求接着向下走。
我们刚在走到了BookServiceImpl类的queryAllBook方法，然后该方法又是调用了bookMapper的queryAllBook方法。现在我们清楚了bookMapper的类型是BookMapper
又从sping-dao.xml的配置文件中看到了该文件的位置位于com.kuang.dao路径下，我们现在就打开BookMapper.java文件看一看
我们注意到这只是个接口，我们都知道接口是不能实例化的接口只是提供一个规范，这是我们就有疑问了，那我们调用的bookMapper的queryAllBook是怎么执行的？
我们在仔细看下dao目录下的文件，
发现还有一个名字和BookMapper.java名字一样的xml文件，我们打开看一下内容。
看到这个文件，虽然我们对mybatis的了解不多，但是我们应该大概明白了，为什么我们BookMapper明明只是接口，我们却可以实例化生成BookMapper的bean并且可以调用他的方法了。
但是只有BookMapper.java和BookMapper.xml显然不能就是Mybatis的全部了，两个文件之间此时除了名字相同以外还没有什么直接联系，所以我们还需要关联起来，我们来看看mybatis-config.xml这个Mybatis的配置文件
我们看到了这个标签的resource属性的value就是我们BookMapper.xml的路径MyBatis 是基于 sql 映射配置的框架，sql
语句都写在 Mapper 配置文件中，当构建 SqlSession 类之后，就需要去读取 Mapper 配置文件中的 sql 配置。而
标签就是用来配置需要加载的 sql 映射配置文件路径的。
也就是说最终由我们的Spring帮我生成BookMapper的代理对象然后由Mybaits通过标签将BookMapper代理对象中的方法和BookMapper.xml中的配置进行一一的映射，并最终执行其中的Sql语句。
我们看到我们此次请求最终调用的BookMapper的queryAllBook方法，这时我们就需要去BookMapper.xml去寻找与之对应的Sql语句了
很容易就找到了
我们看到最后执行的sql语句是
SELECT * from ssmbuild.books
至此我们的请求已经完成从一开始的由DispatcherServlet这个前端控制器派发给SpringMVC并最终通过Mybatis
执行我们需要对数据库进行的操作。
生产环境的业务代码，会比这个Demo复杂，但是整体的执行流程和思路并不会有什么太大的变化，所以审计思路也是如此。
SSM框架有三种配置方式，即全局采用xml配置文件的形式，全局采取注解的配置方式，或者注解和xml配置文件配合使用的方式，区别只是在于写法不一样，执行流程不会因此发生太多改变。
## 2.6 审计的重点filter过滤器
此时在将web.xml时还有一个标签说放在后面讲，就是web.xml的标签
SpringMVC时构建于Servlet之上的，所以Servlet中的过滤器自然也是可以使用，只不过不能配置在spring-mvc.xml中，而是要直接配置在web.xml中，因为是属于Servlet的技术嘛。
我们重回web.xml
为了方便之前的讲解，我将这两个filter注释掉了。也就是说这两个filter并没有生效。我们以下面的filter-name为XSSEscape的filter来进行讲解。
首先我们此时程序是没有XSS防护的，所以存在存储型XSS漏洞，我们来尝试存储型XSS攻击
我们点击新增功能
看一下提交路径
去后台找与之对应的方法
找到后在这里下断点看传入参数的详细信息
看到没有任何过滤XSS语句就这么直接传了进来
如果我们此时想要防御这个XSS攻击就可以在web.xml中配置上我们的
这里声明了了我在com.kuang.filter的包路径下又一个类叫XssFilter是一个过滤器
下面的属性中的REQUEST的意思是
只要发起的操作是一次HTTP请求，比如请求某个URL、发起了一个GET请求、表单提交方式为POST的POST请求、表单提交方式为GET的GET请求。一次重定向则前后相当于发起了两次请求，这些情况下有几次请求就会走几次指定过滤器。
属性2.4版本的servlet中添加的新的属性标签，总共有四个值REQUEST,FORWARD,INCLUDE和ERROR，以下把这四个值简单说明一下
1、REQUEST
只要发起的操作是一次HTTP请求，比如请求某个URL、发起了一个GET请求、表单提交方式为POST的POST请求、表单提交方式为GET的GET请求。一次重定向则前后相当于发起了两次请求，这些情况下有几次请求就会走几次指定过滤器。
2、FOWARD
只有当当前页面是通过请求转发转发过来的情形时，才会走指定的过滤器
3、INCLUDE
只要是通过，嵌入进来的页面，每嵌入的一个页面，都会走一次指定的过滤器。
4、ERROR
假如web.xml里面配置了``：
例如
        400
        /filter/error.jsp
意思是HTTP请求响应的状态码只要是400、404、500三种状态码之一，容器就会将请求转发到error.jsp下，这就触发了一次error，走进了配置的DispatchFilter。需要注意的是注意一点的是，虽然把请求转发到error.jsp是一次forward的过程，但是配置成FORWARD并不会走DispatchFilter这个过滤器。
这四种dispatcher方式可以单独使用，也可以组合使用，配置多个``即可。
在审计的时候的过滤器``属性中使用的值也是我们关注的一个点，
``属性是指明我们要过滤访问哪些资源的请求，“/*”的意思就是拦截所有对后台的请求,
包括对一个简单的对jsp页面的GET请求，同时我们可以具体的指定拦截对某一资源的请求，同时也可以设置对某些资源的请求不过滤单独进行放过，
举例说明
         XSSEscape
         com.springtest.filter.XssFilter
         XSSEscape
         /com/app/UserControl
         REQUEST
既然等指定单独过滤特定资源，自然也就可以指定对特定资源的放行。
如果设置全局的资源请求过滤的话肯定是不合理的，生产环境中又很多静态资源是不需要进行过滤的，所以我们可以指定将这些资源进行放行，
例如
       XSSEscape 
       com.springtest.filter.XssFilter 