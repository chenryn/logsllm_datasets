consisted of:
– 5544 ﬂows (65.6%): An image appearing on most of the pages of a Java
programming language tutorial.
– 2148 ﬂows (25.4%): The image of the research group logo, which appears on
many local pages.
– 490 ﬂows (5.8%): A single Microsoft PowerPoint presentation.
222
C. Kruegel et al.
– 227 ﬂows (2.7%): Multiple PowerPoint presentations that were found to con-
tain common embedded images.
The remaining 43 ﬂows accounted for 0.5% of the total and consisted of ex-
ternal binary ﬁles that were accessed by local users and had ﬁngerprints that,
by random chance, collided with the 23 ﬂagged ﬁngerprints.
The problem of false positives caused by heavily accessed, locally hosted ﬁles
could be addressed by creating a white list of ﬁngerprints, gathered manually or
through the use of an automated web crawler. For example, if we had prepared
a white list for the 23 ﬁngerprints that occurred in the small number of image
ﬁles and the single PowerPoint presentation, we would not have reported a single
false positive during the test period of 9 days.
7.4 Detection Capabilities
In this section, we analyze the capabilities of our system to detect polymor-
phic worms. Polymorphism exists in two ﬂavors. On one hand, an attacker can
attempt to camouﬂage the nature of the malicious code using encryption. In
this case, many diﬀerent worm variations can be generated by encrypting the
payload with diﬀerent keys. However, the attacker has to prepend a decryption
routine before the payload. This decryption routine becomes the focus of de-
fense systems that attempt to identify encrypted malware. The other ﬂavor of
polymorphism (often referred to as metamorphism) includes techniques that aim
to modify the malicious code itself. These techniques include the renaming of
registers, the transposition of code blocks, and the substitution of instructions.
Of course, both techniques can be combined to disguise the decryption routine
of an encrypted worm using metamorphic techniques.
In our ﬁrst experiment, we analyzed malicious code that was disguised by
ADMmutate [11], a well-known polymorphic engine. ADMmutate operates by
ﬁrst encrypting the malicious payload, and then prepending a metamorphic de-
cryption routine. To evaluate our system, we used ADMmutate to generate 100
encrypted instances of a worm, which produced a diﬀerent decryption routine for
Table 5. Malware variant detection within families
Family
FIZZER
FRETHEM
KLEZ
KORGO
LOVGATE
MYWIFE
NIMDA
OPASERV
All
Variant Tests Matches Match Rate
100.00%
100.00%
100.00%
0.07%
100.00%
0.33%
100.00%
0.064%
16.97%
1
1
6
136
300
3
1
171
1,991
1
1
6
9
300
1
1
11
338
Polymorphic Worm Detection Using Structural Information of Executables
223
each run. Then, we used our system to identify common substructures between
these instances.
Our system could not identify a single ﬁngerprint that was common to all 100
instances. However, there were 66 instances that shared one ﬁngerprint, and 31
instances that shared another ﬁngerprint. Only 3 instances did not share a single
common ﬁngerprint at all. A closer analysis of the generated encryption routines
revealed that the structure was identical between all instances. However, ADM-
mutate heavily relies on instruction substitution to change the appearance of the
decryption routine. In some cases, data transfer instructions were present in a ba-
sic block, but not in the corresponding block of other instances. These diﬀerences
resulted in a diﬀerent coloring of the nodes of the control ﬂow graphs, leading
to the generation of diﬀerent ﬁngerprints. This experiment brings to attention
the possible negative impact of colored nodes on the detection. However, it also
demonstrates that the worm would have been detected quickly since a vast major-
ity of worm instances (97 out of 100) contain one of only two diﬀerent ﬁngerprints.
The aim of our second experiment was to analyze the structural similarities
between diﬀerent members of a worm family. Strictly speaking, members of a
worm family are not polymorphic per se, but the experiment provides evidence
of how much structural similarity is retained between variations of a certain
worm. This is important to understand how resilient our system is to a surge of
worm variations during an outbreak.
For this experiment, the prototype was run against 342 samples of malware vari-
ants from 93 distinct families. The ﬁngerprints generated for each of the malware
variants were extracted and recorded. An analyzer then performed a pairwise com-
parison between each member of each family, searching for common ﬁngerprints. If
a common ﬁngerprint was found, a match between the family variants was recorded.
Table 5 summarizes some of the more interesting results of this experiment.
From the results, one can see that certain malware variants retain signiﬁcant
structural similarity within their family. Notably, all 25 LOVGATE variants share
common structural characteristics with one another. There are, however, many
cases in which the structural characteristics between variants diﬀers greatly;
manual inspection using IDA Pro veriﬁed that our system was correct in not
reporting common ﬁngerprints as the CFGs were actually very diﬀerent. While
one might consider this disappointing, recall instead that it is rather diﬃcult for
an attacker to implement a worm that substantially and repeatedly mutates its
structure after each propagation while retaining its intended functionality. Thus,
the experiment should demonstrate that the prototype is capable of detecting
similarity between real-world examples of malware when it is present.
8 Limitations
One limitation of the current prototype is that it operates oﬀ-line. Our exper-
iments were performed on ﬁles that were captured from the network and later
analyzed. As future work, we plan to implement the necessary infrastructure to
operate the system on-line.
224
C. Kruegel et al.
Related to this problem is that our analysis is more complex, and, thus,
more costly than approaches that are based on substrings [6, 19]. Not only is it
necessary to parse the network stream into instructions, we also have to build the
control ﬂow graph, generate subgraphs, and perform canonical graph labeling.
While many network ﬂows do not contain executables, thus allowing us to abort
the analysis process at an early stage, performance improvements are necessary
to be able to deploy the system on-line on fast network links. Currently, our
system can analyze about 1 Megabyte of data per second. Most of the processing
time is spent disassembling the byte stream and generating the CFG.
A key advantage of our approach over the Earlybird [19] and Autograph [6]
systems is that our system is more robust to polymorphic modiﬁcations of a
malicious executable. This is due to the fact that we analyze the structure of an
executable instead of its byte stream representation. However, an attacker could
attempt to modify the structure of the malicious code to evade detection. While
one-time changes to the structure of a binary are quite possible, the automatic
generation of semantically equivalent code pieces that do not share common sub-
structures is likely more challenging. Another possibility to erode the similarities
between worm instances is to insert conditional branches into the code that are
never taken. This can be done at a low cost for the attacker, but it might not be
straightforward to generate such conditional branches that cannot be identiﬁed
by a more advanced static analysis. A possibly more promising attack venue for
a worm author is to attack the coloring scheme. By ﬁnding instructions from
diﬀerent classes, worm variations can be obtained that are considered diﬀerent
by our system. The experimental results for ADMmutate in the previous section
have demonstrated that the system can be forced to calculate diﬀerent ﬁnger-
prints for the decryption routine. However, the results have also shown that,
despite appearing completely diﬀerent on a byte string level, the total number
of ﬁngerprints is very low. In this case, detection is delayed, but because of the
small number of variations, the worm will eventually be automatically identiﬁed.
Finally, our technique cannot detect malicious code that consists of less than
k blocks. That is, if the executable has a very small footprint we cannot extract
suﬃcient structural information to generate a ﬁngerprint. We chose 10 for k in
our experiments, a value that seems reasonable considering that the Slammer
worm, which is only 376 bytes long and ﬁts into a single UDP packet, has a CFG
with 16 nodes. For comparison, CodeRed is about 4 Kilobytes long and has a
CFG with 127 nodes.
9 Conclusions
Worms are automated threats that can compromise a large number of hosts in a
very small amount of time, making human-based countermeasures futile. In the
past few years, worms have evolved into sophisticated malware that supports
optimized identiﬁcation of potential victims and advanced attack techniques.
Polymorphic worms represent the next step in the evolution of this type of
malicious software. Such worms change their binary representation as part of
Polymorphic Worm Detection Using Structural Information of Executables
225
the spreading process, making detection and containment techniques based on
the identiﬁcation of common substrings ineﬀective.
This paper presented a novel technique to reliably identify polymorphic worms.
The technique relies on structural analysis and graph coloring techniques to char-
acterize the high-level structure of a worm executable. By abstracting from the
concrete implementation of a worm, our technique supports the identiﬁcation of
diﬀerent mutations of a polymorphic worm.
Our approach has been used as the basis for the implementation of a system
that is resilient to a number of code transformation techniques. This system has
been evaluated with respect to a large number of benign ﬁles and network ﬂows
to demonstrate its low rate of false positives. Also, we have provided evidence
that the system represents a promising step towards the reliable detection of
previously unknown, polymorphic worms.
References
1. L. Babai annd E. Luks. Canonical Labeling of Graphs. In 15th ACM Symposium
on Theory of Computing, 1983.
2. M. Bailey, E. Cooke, F. Jahanian, J. Nazario, and D. Watson. The Internet Motion
Sensor: A Distributed Blackhole Monitoring System. In Network and Distributed
Systems Symposium (NDSS), 2005.
3. V. Berk, R. Gray, and G. Bakos. Using Sensor Networks and Data Fusion for Early
Detection. In SPIE Aerosense Conference, 2003.
4. D. Dagon, X. Qin, G. Gu, W. Lee, J. Grizzard, J. Levin, and Henry O. Honey-
Stat: Local Worm Detection Using Honeypots. In 7th International Symposium on
Recent Advances in Intrusion Detection (RAID), 2004.
5. T. DeTristan, T. Ulenspiegel, Y. Malcom, and M. von Underduk.
Poly-
morphic Shellcode Engine Using Spectrum Analysis. http://www.phrack.org/
show.php?p=61&a=9.
6. H.-A. Kim and B. Karp. Autograph: Toward Automated, Distributed Worm Sig-
nature Detection. In 13th Usenix Security Symposium, 2004.
7. O. Kolesnikov and W. Lee. Advanced Polymorphic Worms: Evading IDS by Blend-
ing in with Normal Traﬃc. Technical report, Georgia Tech, 2004.
8. C. Kreibich and J. Crowcroft. Honeycomb - Creating Intrusion Detection Signa-
tures Using Honeypots. In 2nd Workshop on Hot Topics in Networks, 2003.
9. C. Kruegel, F. Valeur, W. Robertson, and G. Vigna. Static Analysis of Obfuscated
Binaries. In 13th Usenix Security Symposium, 2004.
10. C. Linn and S. Debray. Obfuscation of Executable Code to Improve Resistance
In ACM Conference on Computer and Communications
to Static Disassembly.
Security (CCS), 2003.
11. S. Macaulay. ADMmutate: Polymorphic Shellcode Engine. http://www.ktwo.ca/
ttsecurity.html.
12. B. McKay. Nauty: No AUTomorphisms, Yes?
nauty/.
http://cs.anu.edu.au∼bdm/
13. B. McKay. Practical graph isomorphism. Congressus Numerantium, 30, 1981.
14. D. Moore, C. Shannon, G. Voelker, and S. Savage. Internet Quarantine: Require-
ments for Containing Self-Propagating Code. In IEEE Infocom Conference, 2003.
226
C. Kruegel et al.
15. J. Newsome, B. Karp, and D. Song. Polygraph: Automatically Generating Sig-
natures for Polymorphic Worms. In IEEE Symposium on Security and Privacy,
2005.
16. V. Paxson. Bro: A System for Detecting Network Intruders in Real-Time. In 7th
Usenix Security Symposium, 1998.
17. M. O. Rabin. Fingerprinting by Random Polynomials. Technical report, Center
for Research in Computing Techonology, Harvard University, 1981.
18. M. Roesch. Snort - Lightweight Intrusion Detection for Networks. In Usenix LISA
Conference, 1999.
19. S. Singh, C. Estan, G. Varghese, and S. Savage. Automated Worm Fingerprinting.
In 6th Symposium on Operating System Design and Implementation (OSDI), 2004.
20. S. Skiena. Implementing Discrete Mathematics: Combinatorics and Graph Theory,
chapter Graph Isomorphism. Addison-Wesley, 1990.
21. Sophos. War of the Worms: Top 10 list of worst virus outbreaks in 2004.
http://www.sophos.com/pressoffice/pressrel/uk/20041208yeartopten.html.
22. S. Staniford, D. Moore, V. Paxson, and N. Weaver. The Top Speed of Flash Worms.
In 2nd ACM Workshop on Rapid Malcode (WORM), 2004.
23. S. Staniford, V. Paxson, and N. Weaver. How to 0wn the Internet in Your Spare
Time. In 11th Usenix Security Symposium, 2002.
24. S. Venkataraman, D. Song, P. Gibbons, and A. Blum. New Streaming Algorithms
for Fast Detection of Superspreaders. In Network and Distributed Systems Sympo-
sium (NDSS), 2005.
25. N. Weaver, V. Paxson, S. Staniford, and R. Cunningham. A Taxonomy of Com-
puter Worms. In ACM Workshop on Rapid Malcode, October 2003.
26. N. Weaver, S. Staniford, and V. Paxson. Very Fast Containment of Scanning
Worms. In 13th Usenix Security Symposium, 2004.
27. D. Whyte, E. Kranakis, and P. van Oorschot. DNS-based Detection of Scanning
Worms in an Enterprise Network. In Network and Distributed Systems Symposium
(NDSS), 2005.
28. M. Williamson. Throttling Viruses: Restricting Propagation to Defeat Malicious
Mobile Code. In 18th Annual Computer Security Applications Conference (AC-
SAC), 2002.