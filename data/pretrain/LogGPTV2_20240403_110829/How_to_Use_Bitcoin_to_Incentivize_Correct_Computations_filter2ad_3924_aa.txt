# Title: Using Bitcoin to Incentivize Correct Computations

## Authors:
Ranjit Kumaresan and Iddo Bentov  
Technion, Haifa, Israel  
{ranjit | iddo}@cs.technion.ac.il

## Abstract
We explore a model for incentivizing correct computations in various cryptographic tasks. For each task, we propose a formal model and design protocols that meet our constraints in a hybrid model where parties have access to special ideal functionalities enabling monetary transactions. Our key results include:

- **Verifiable Computation**: We consider a scenario where a delegator outsources computation to a worker who expects payment for delivering correct outputs. We design protocols that compile both public and private verification schemes to support these incentives.
- **Secure Computation with Restricted Leakage**: Building on recent work by Huang et al. (Security and Privacy 2012), we present an efficient secure computation protocol that penalizes adversaries financially if they attempt to learn one bit of information but are detected.
- **Fair Secure Computation**: Inspired by recent research, we introduce a model of secure computation where a party that aborts after learning the output is monetarily penalized. We propose an ideal transaction functionality \( F_{\text{ML}} \) and demonstrate a constant-round realization on the Bitcoin network. In the \( F_{\text{ML}} \)-hybrid model, we design a constant-round protocol for secure computation.
- **Noninteractive Bounties**: We provide formal definitions and candidate realizations of noninteractive bounty mechanisms on the Bitcoin network. These mechanisms (1) allow a bounty maker to place a bounty for solving a hard problem with a single message, (2) enable a bounty collector (unknown at the time of bounty creation) to claim the bounty with the solution, (3) ensure the bounty maker can learn the solution when the bounty is collected, and (4) prevent malicious eavesdroppers from claiming the bounty or learning the solution.

Our protocol realizations (except for fair secure computation) rely on a special ideal functionality not currently supported in Bitcoin due to script limitations. To address this, we introduce the concept of validation complexity, a formal measure of the computational effort required to validate Bitcoin transactions. Our protocols are designed to leverage optimistic scenarios where parties behave honestly.

## 1. Introduction
We study a model for incentivizing correct computations in various cryptographic tasks, including verifiable computation, secure computation, fair computation, and bounty mechanisms. For each task, we propose a formal model and design protocols that satisfy our constraints in a hybrid model where parties have access to special ideal functionalities, such as \( F_{\text{CR}} \), enabling monetary transactions. Below, we explain each problem, provide motivation, discuss the state-of-the-art, and outline our contributions.

### Verifiable Computation
Outsourcing computation has been a significant area of research in cryptography. Recent developments have led to several efficient schemes [31]. Motivated by these, we consider a setting where a delegator outsources computation to a worker who expects payment for delivering correct outputs. This model is useful for pay-per-computation scenarios rather than subscription-based cloud services. We design protocols that compile both public and private verification schemes to support these incentives.

### Secure Computation with Restricted Leakage
Protocols for secure computation typically anticipate worst-case behavior from malicious parties and use expensive techniques to handle them. Recently, Huang et al. [23] proposed the "DualEx protocol," which restricts leakage to at most one bit even against malicious parties. While leaking a single bit might seem minor, it can be catastrophic in scenarios involving multiple secure evaluations on the same data. Enhancements to the DualEx protocol allow for some detection of leakage, but an adversary could still interact multiple times under different pseudonyms and learn sensitive information.

Despite these severe consequences, we believe sacrificing some leakage for better efficiency is a practical approach in secure protocol design. For instance, state-of-the-art searchable symmetric key encryption schemes [12, 25, 30] leak information about access patterns to even semi-honest adversaries. The research direction is to find an acceptable balance between leakage and performance [12]. In contrast, the DualEx protocol leaks information only when parties deviate from the protocol. We propose a model where a deviating party may be penalized if information leakage is detected. Specifically, a malicious party attempting to learn one bit of information, if detected, must pay a monetary penalty. We construct a protocol that, for very large circuits, has the same performance as the DualEx protocol in an optimistic scenario and allows for enforcing penalties. Our protocol is constructed in the \( F_{\text{CR}} \)-hybrid model [11] and can be realized over the Bitcoin network with extended script support.

### Fair Secure Computation
A major deficiency of secure computation is that, with a dishonest majority, a corrupt party can abort the protocol after learning the output while denying it to honest parties. Inspired by recent works [11, 4], we consider a model where a party that aborts after learning the output is monetarily penalized. We propose an ideal transaction functionality \( F_{\text{ML}} \) and show a constant-round realization on the Bitcoin network. In the \( F_{\text{ML}} \)-hybrid world, we design a constant-round protocol for secure computation in this model. Previous work [11] did not offer constant-round implementations over Bitcoin.

### Noninteractive Bounties
Bitcoin users have offered bounties for solving NP problems, such as SHA-1 and SHA-2 collisions [34]. The bounty maker expects to learn the preimages causing the collision. Realizing bounties is challenging because the identity of the solver is unknown at the time the bounty is placed. Malicious nodes in the Bitcoin network could strip the witness and attempt to redeem the reward themselves. A recommendation in [34] suggests that the reward claimer should generate the Proof of Work (PoW) block, but this is impractical and does not prevent other PoW miners from re-solving the block and broadcasting a higher-fee transaction. 

We address this by providing formal definitions and candidate realizations of noninteractive bounty mechanisms on the Bitcoin network. The key constraints are: (1) allowing a bounty maker to place a bounty for solving a hard problem with a single message, (2) enabling a bounty collector (unknown at the time of bounty creation) to claim the bounty with the solution, (3) ensuring the bounty maker can learn the solution when the bounty is collected, and (4) preventing malicious eavesdroppers from claiming the bounty or learning the solution.

### Validation Complexity
Our protocols and schemes are designed in a hybrid model where parties have access to an ideal transaction functionality, say \( G^* \). The description of \( G^* \) typically involves conditional payment release, formalized via a circuit \( \phi \). Our design of \( G^* \) is inspired by Bitcoin's transaction functionalities, where \( \phi \) corresponds to Bitcoin scripts. However, current Bitcoin scripts have heavy restrictions, making some of our protocols unimplementable today. We hope our models and constructions motivate increased Bitcoin script functionality. We also propose validation complexity, a new measure capturing the complexity of Bitcoin scripts in conditional transactions. Bitcoin transactions need to be confirmed by miners, who verify their validity and may charge a fee proportional to the validation complexity. Our goal is to design protocols with low validation complexity.

### Optimistic Complexity
We use optimistic techniques to minimize the computation, communication, and validation complexity of honest executions of our protocols. As in prior work [26, 7, 33], our aim is to recognize and optimize for the best cases during protocol execution while ensuring security against worst-case behavior. Optimistic protocols do not improve worst-case performance but offer meaningful gains in practice.

### Bitcoin Scripts and Their Limitations
Standard Bitcoin transactions blacklist many opcodes due to past exploits [1]. Even if all opcodes were whitelisted, the Bitcoin scripting language is not Turing complete to avoid denial of service attacks. Bitcoin caps transaction size and bounds verification time with a small polynomial function of the transaction size. Alternative designs with Turing-complete scripts, such as Ethereum, are being considered, suggesting that future cryptocurrencies may support richer financial mechanisms, though at potentially higher fees.

### Other Related Work
Works by [21, 10] design credit systems where users are rewarded for good work and fined for cheating, assuming a trusted arbiter/supervisor in some settings. Fair secure computation with reputation systems was considered in [5]. Reputation systems have limited applicability because it is unclear how to define the reputation of new users [14].

## 2. Preliminaries
A function \( \mu(·) \) is negligible in \( \lambda \) if for every positive polynomial \( p(·) \) and all sufficiently large \( \lambda \)'s, it holds that \( \mu(\lambda) < 1/p(\lambda) \). A probability ensemble \( X = \{X(a, \lambda)\}_{a \in \{0,1\}^*, \lambda \in \mathbb{N}} \) is an infinite sequence of random variables indexed by \( a \) and \( \lambda \in \mathbb{N} \). Two distribution ensembles \( X = \{X(a, \lambda)\}_{\lambda \in \mathbb{N}} \) and \( Y = \{Y(a, \lambda)\}_{\lambda \in \mathbb{N}} \) are computationally indistinguishable, denoted \( X \equiv_c Y \), if for every non-uniform polynomial-time algorithm \( D \), there exists a negligible function \( \mu(·) \) such that for every \( a \in \{0, 1\}^* \),

\[ | \Pr[D(X(a, \lambda)) = 1] - \Pr[D(Y(a, \lambda)) = 1] | \leq \mu(\lambda). \]

All parties are assumed to run in time polynomial in the security parameter \( \lambda \). We prove security in the "secure computation with coins" (SCC) model proposed in [11]. The main difference from standard definitions of secure computation [19] is that the view of \( Z \) now includes the distribution of coins. Let \( \text{IDEAL}_f^{S, Z}(\lambda, z) \) denote the output of environment \( Z \) initialized with input \( z \) after interacting in the ideal process with ideal process adversary \( S \) and (standard or special) ideal functionality \( G_f \) on security parameter \( \lambda \). Recall that our protocols will be run in a hybrid model where parties will have access to a (standard or special) ideal functionality \( G_g \). We denote the output of \( Z \) after interacting in an execution of \( \pi \) in such a model with \( A \) by \( \text{HYBRID}_g^{\pi, A, Z}(\lambda, z) \), where \( z \) denotes \( Z \)'s input. We are now ready to define what it means for a protocol to SCC realize a functionality.

**Definition 1.** Let \( n \in \mathbb{N} \). Let \( \pi \) be a probabilistic polynomial-time \( n \)-party protocol and let \( G_f \) be a probabilistic polynomial-time \( n \)-party (standard or special) ideal functionality. We say that \( \pi \) SCC realizes \( G_f \) with abort in the \( G_g \)-hybrid model (where \( G_g \) is a standard or a special ideal functionality) if for every non-uniform probabilistic polynomial-time adversary \( A \) attacking \( \pi \), there exists a non-uniform probabilistic polynomial-time adversary \( S \) for the ideal model such that for every non-uniform probabilistic polynomial-time adversary \( Z \),

\[ \{ \text{IDEAL}_f^{S, Z}(\lambda, z) \}_{\lambda \in \mathbb{N}, z \in \{0,1\}^*} \equiv_c \{ \text{HYBRID}_g^{\pi, A, Z}(\lambda, z) \}_{\lambda \in \mathbb{N}, z \in \{0,1\}^*}. \]

**Definition 2.** Let \( \pi \) be a protocol and \( f \) be a multiparty functionality. We say that \( \pi \) securely computes \( f \) with penalties if \( \pi \) SCC-realizes \( f \) according to Definition 1.