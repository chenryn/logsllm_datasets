title:How to Use Bitcoin to Incentivize Correct Computations
author:Ranjit Kumaresan and
Iddo Bentov
How to Use Bitcoin to Incentivize Correct Computations
Ranjit Kumaresan and Iddo Bentov
Technion, Haifa, Israel
{ranjit | idddo }@cs.technion.ac.il
ABSTRACT
We study a model of incentivizing correct computations in a variety
of cryptographic tasks. For each of these tasks we propose a for-
mal model and design protocols satisfying our model’s constraints
in a hybrid model where parties have access to special ideal func-
tionalities that enable monetary transactions. We summarize our
results:
• Veriﬁable computation. We consider a setting where a del-
egator outsources computation to a worker who expects to
get paid in return for delivering correct outputs. We design
protocols that compile both public and private veriﬁcation
schemes to support incentivizations described above.
• Secure computation with restricted leakage. Building on
the recent work of Huang et al. (Security and Privacy 2012),
we show an efﬁcient secure computation protocol that mone-
tarily penalizes an adversary that attempts to learn one bit of
information but gets detected in the process.
• Fair secure computation. Inspired by recent work, we con-
sider a model of secure computation where a party that aborts
after learning the output is monetarily penalized. We then
propose an ideal transaction functionality F (cid:63)
ML and show a
constant-round realization on the Bitcoin network. Then, in
the F (cid:63)
ML-hybrid world we design a constant round protocol
for secure computation in this model.
• Noninteractive bounties. We provide formal deﬁnitions and
candidate realizations of noninteractive bounty mechanisms
on the Bitcoin network which (1) allow a bounty maker to
place a bounty for the solution of a hard problem by sending
a single message, and (2) allow a bounty collector (unknown
at the time of bounty creation) with the solution to claim the
bounty, while (3) ensuring that the bounty maker can learn
the solution whenever its bounty is collected, and (4) pre-
venting malicious eavesdropping parties from both claiming
the bounty as well as learning the solution.
All our protocol realizations (except those realizing fair secure
computation) rely on a special ideal functionality that is not cur-
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’14, November 3–7, 2014, Scottsdale, Arizona, USA.
Copyright 2014 ACM 978-1-4503-2957-6/14/11 ...$15.00.
http://dx.doi.org/10.1145/2660267.2660380.
rently supported in Bitcoin due to limitations imposed on Bitcoin
scripts. Motivated by this, we propose validation complexity of a
protocol, a formal complexity measure that captures the amount of
computational effort required to validate Bitcoin transactions re-
quired to implement it in Bitcoin. Our protocols are also designed
to take advantage of optimistic scenarios where participating par-
ties behave honestly.
Categories and Subject Descriptors
C.2.0 [Computer-Communication Networks]: General—Secu-
rity and protection
Keywords
Bitcoin; secure computation; veriﬁable computation; fair exchange;
bounties
1.
INTRODUCTION
CR, F (cid:63)
We study a model of incentivizing correct computations in a va-
riety of cryptographic tasks, namely veriﬁable computation, secure
computation, fair computation, and bounty mechanisms. For each
of these tasks we propose a formal model and design protocols
satisfying our model’s constraints in a hybrid model where parties
have access to special ideal functionalities, e.g., F (cid:63)
f [11], that
enable monetary transactions. Below we explain each of the prob-
lems, provide motivation, discuss state-of-the-art, and outline our
contributions.
Veriﬁable computation. Outsourcing computation has been a ma-
jor area of research in cryptography. Recently several efﬁcient
schemes have been proposed [31]. Motivated by these develop-
ments, we consider a setting where a delegator outsources com-
putation to a worker who expects to get paid in return for deliv-
ering correct outputs. Such settings may be useful for situations
where the delegator is interested in a pay per computation model
rather than a model where the delegator subscribes to cloud service
to perform computations. We design protocols that compile both
public and private veriﬁcation schemes to support incentivizations
described above.
Secure computation with restricted leakage. Protocols for se-
cure computation anticipate worst-case behavior from malicious
parties and typically make heavy use of expensive techniques that
are meant solely to handle them. Recently, Huang et al. [23] (build-
ing on top of [29] proposed the “DualEx protocol” that restricts the
amount of leakage to at most one bit even against malicious parties.
While leaking a single bit might not sound too damaging, consider
what happens when multiple secure evaluations are performed on
the same data. This could be a server that is willing to allow com-
putations on a database it holds, or on a set of master keys that it
30possesses. In such scenarios leaking one bit of sensitive informa-
tion per execution might indeed be catastrophic. While enhance-
ments to DualEx protocol that allow (some restricted) detection of
leakage, it is quite natural to expect that an adversary may inter-
act with a server multiple times under different pseudonyms and
in each interaction learn (with some probability) a sensitive bit of
information.
Despite such severe consequences, we believe that sacriﬁcing
some leakage for (vastly) better efﬁciency is perhaps the way to
go in the area of secure protocol design. For instance, consider
state-of-the-art searchable symmetric key encryption schemes [12,
25, 30] that leak some information about access patterns to even
semihonest adversaries. Indeed, the research direction in this area
is to ﬁgure out “an acceptable balance between leakage and per-
formance” [12]. Note that in contrast, the DualEx protocol leaks
information only when parties deviate from the protocol. This jus-
tiﬁes considering a model where a deviating party may be penal-
ized if information leakage is detected. Speciﬁcally, we consider a
model where a malicious party may attempt to learn one bit of in-
formation, but with the guarantee that if its cheating attempt is de-
tected, then it is forced to pay a monetary penalty. We believe that
this constitutes a practical way to enforce honest behavior in the
DualEx protocol. We then construct a protocol that (for very large
circuits) essentially has the same performance as the DualEx proto-
col in an optimistic scenario and yet allows for enforcing penalties.
Our protocol is constructed in the F (cid:63)
CR-hybrid model [11] and thus
allows, assuming extended script support, for practical realization
over the Bitcoin network. Our protocols provide a formal proof-of-
concept that incentivizing secure computation to prevent leakage is
indeed possible. We believe that our results provided added mo-
tivation for further research in designing secure protocols with re-
stricted leakage—a relatively unexplored area—with the hope that
these protocols can be incentivized to prevent leakage.
Fair secure computation. A major deﬁciency of secure computa-
tion is that, assuming a dishonest majority among participating par-
ties, a corrupt party can always abort the protocol after learning the
output while denying the output to honest parties. Such situations
are highly undesirable if we want secure computation to be widely
adopted in practice. Inspired by the recent works of [11, 4], we
consider a model of secure computation where a party that aborts
after learning the output is monetarily penalized. We then propose
an ideal transaction functionality F (cid:63)
ML and show a constant-round
realization on the Bitcoin network. Then, in the F (cid:63)
ML-hybrid world
we design a constant round protocol for secure computation in this
model. Previous work [11] did not offer constant round implemen-
tations over Bitcoin.
Noninteractive bounties. Bitcoin users have been offering boun-
ties that can be collected anonymously by anyone who solves an
NP problem, such as SHA-1 and SHA-2 collisions [34]. The users
who place the bounty expect to learn the preimages that cause the
collision. The difﬁculty in realizing bounties arises from the fact
that the identity of the user who solves the NP problem is unknown
at the time the bounty is placed. This is a problem since other (ma-
licious) nodes in the Bitcoin network could strip the witness and
attempt to redeem the reward themselves. A recommendation out-
lined in [34] suggests that the user who claims the reward should
generate the PoW block by herself. While this may very well be
impractical, it still does not avoid the risk that other PoW miners
will re-solve the block if the bounty is high enough and broadcast
their own transaction that offers a higher fee to the Bitcoin miners.
Clearly, the above proposals for bounty mechanisms fall short of
what one would expect from a bounty mechanism. We approach
the problem by providing both formal deﬁnitions and candidate re-
alizations of noninteractive bounty mechanisms on the Bitcoin net-
work. The key constraints to keep in mind are that a noninteractive
bounty mechanism must (1) allow a bounty maker to place a bounty
for the solution of a hard problem by sending a single message,
and (2) allow a bounty collector (unknown at the time of bounty
creation) with the solution to claim the bounty, while (3) ensuring
that the bounty maker can learn the solution whenever its bounty is
collected, and (4) preventing malicious eavesdropping parties from
both claiming the bounty as well as learning the solution.
Validation complexity. Our protocols and schemes are designed in
a hybrid model where parties have access to an ideal transaction
functionality, say G(cid:63). The description of G(cid:63) typically involves a
conditional release of payment where the condition is formalized
via a circuit φ. Our design of G(cid:63) is certainly inspired by transac-
tion functionalities supported by Bitcoin. In particular, the circuit
φ corresponds to Bitcoin scripts that may be used to conditionally
release payments. Unfortunately, heavy restrictions are imposed on
the expressive power of Bitcoin scripts in the current Bitcoin sys-
tem. Consequently some of our protocols cannot be implemented
on the Bitcoin system today. On the one hand, we hope that our
models and constructions offer compelling motivation to increase
functionality of Bitcoin scripts. On the other hand, we propose
validation complexity, a new complexity measure that attempts to
capture the complexity of the Bitcoin script required in conditional
transactions. Note that Bitcoin transactions need to be conﬁrmed
by the Bitcoin miners in order to append them to the public ledger.
Thus, the miners need to ﬁrst verify whether the transaction is valid.
It is therefore natural to presume that miners levy an (additional)
transaction fee that is proportional to the validation complexity of
the transaction. As we will see, one of our main goals is to design
protocols with low validation complexity.
Optimistic complexity. We use optimistic techniques for designing
protocols to minimize the computation/communication/validation
complexity of honest executions of our protocols, i.e., when all par-
ties follow the protocol. As in prior work [26, 7, 33], our aim here
is to design protocols that can “recognize the best cases and opti-
mize for them, even in the midst of the protocol execution,” [33]
while guaranteeing security against worst-case behavior. Note that
optimistic protocols are not intended to improve worse-case perfor-
mance but are likely to offer meaningful gains in practice.
Bitcoin scripts and their limitations. Standard Bitcoin transaction
currently blacklist many of the opcodes, primarily because of ex-
ploits in code that were not vetted carefully enough [1]. Even if all
the opcodes will be whitelisted, it should be noted that the Bitcoin
scripting language is not Turing complete, to avoid denial of ser-
vice attacks. It is not enough to simply require a higher fee when
the script size is bigger, because the risk of network DoS attacks
implies that the nodes that propagate the transaction (and do not
receive the fee) must verify it before re-broadcasting it. Hence,
Bitcoin caps the transaction size, and bounds the veriﬁcation time
with a small polynomial function of the transaction size. Still, al-
ternative protocol designs with Turing complete scripts are being
considered, in particular with the Ethereum project [2]. Thus it is
conceivable that in the future, richer forms of ﬁnancial mechanisms
will be used by Bitcoin and other cryptocurrencies, though all the
users may have to pay somewhat larger fees as a result.
Other related work. The works of [21, 10] design a credit system
where users are rewarded for good work and ﬁned for cheating (as-
suming a trusted arbiter/supervisor in some settings). Fair secure
computation with reputation systems was considered in [5]. Note
that it has been claimed that reputation systems ﬁnd limited appli-
31cability because it is unclear how to deﬁne the reputation of new
users [14].
2. PRELIMINARIES
A function µ(·) is negligible in λ if for every positive polynomial
p(·) and all sufﬁciently large λ’s it holds that µ(λ) < 1/p(λ). A
probability ensemble X = {X(a, λ)}a∈{0,1}∗,n∈N is an inﬁnite
sequence of random variables indexed by a and λ ∈ N. Two dis-
tribution ensembles X = {X(a, λ)}λ∈N and Y = {Y (a, λ)}λ∈N
c≡ Y
are said to be computationally indistinguishable, denoted X
if for every non-uniform polynomial-time algorithm D there exists
a negligible function µ(·) such that for every a ∈ {0, 1}∗,
|Pr[D(X(a, λ)) = 1] − Pr[D(Y (a, λ)) = 1]| ≤ µ(λ).
All parties are assumed to run in time polynomial in the security
parameter λ. We prove security in the “secure computation with
coins” (SCC) model proposed in [11]. Note that the main difference
from standard deﬁnitions of secure computation [19] is that now the
view of Z contains the distribution of coins. Let IDEALf,S,Z (λ, z)
denote the output of environment Z initialized with input z after
interacting in the ideal process with ideal process adversary S and
(standard or special) ideal functionality Gf on security parameter
λ. Recall that our protocols will be run in a hybrid model where
parties will have access to a (standard or special) ideal functionality
Gg. We denote the output of Z after interacting in an execution of
π in such a model with A by HYBRIDg
π,A,Z (λ, z), where z denotes
Z’s input. We are now ready to deﬁne what it means for a protocol
to SCC realize a functionality.
Deﬁnition 1. Let n ∈ N. Let π be a probabilistic polynomial-
time n-party protocol and let Gf be a probabilistic polynomial-
time n-party (standard or special) ideal functionality. We say that
π SCC realizes Gf with abort in the Gg-hybrid model (where Gg
is a standard or a special ideal functionality) if for every non-
uniform probabilistic polynomial-time adversary A attacking π
there exists a non-uniform probabilistic polynomial-time adversary
S for the ideal model such that for every non-uniform probabilistic
polynomial-time adversary Z,
{IDEALf,S,Z (λ, z)}λ∈N,z∈{0,1}∗ c≡
{HYBRIDg
π,A,Z (λ, z)}λ∈N,z∈{0,1}∗ .
♦
f according to Deﬁnition 1.
Deﬁnition 2. Let π be a protocol and f be a multiparty function-
ality. We say that π securely computes f with penalties if π SCC-