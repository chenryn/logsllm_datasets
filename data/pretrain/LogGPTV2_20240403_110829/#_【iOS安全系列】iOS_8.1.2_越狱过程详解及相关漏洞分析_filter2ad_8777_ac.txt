/Developer/bin/ppunmount  
---  
表14:设备上 /Developer 目录的内容
完成对 DDI 的利用后,相当于我们向系统又添加了一些服务,这些服务如果使用的是系统本身的程序则可以直接调用,如果使用的是自己的程序则首先需要过掉代码签名。
[](http://nirvan.360.cn/blog/wp-content/uploads/2016/01/iOSJB812-com.apple_.remove_amfi.plist_.png)
图4:com.apple.remove_amfi.plist
[](http://nirvan.360.cn/blog/wp-content/uploads/2016/01/iOSJB812-com.apple_.ppinstall.plist_.png)
图5:com.apple.ppinstall.plist
至此,只要我们再过掉代码签名便可以在用户空间已 root 权限执行任意代码了,下面看下代码签名。
**三、过代码签名**
**相关漏洞**
**CVE-2014-4455**
**dyld – Fixed in iOS 8.1.3**
Available for: iPhone 4s and later, iPod touch (5th generation) and later,
iPad 2 and later
Impact: A local user may be able to execute unsigned code
Description: **A state management issue existed in the handling of Mach-O
executable files with overlapping segments**.This issue was addressed through
improved validation of segment sizes.
CVE-ID
**CVE-2014-4455** : TaiG Jailbreak Team  
---  
表15:CVE-2014-4455
这里过代码签名所使用的技术手段与之前的越狱工具相同,只是利用的漏洞不同,还是利用 dylib 函数重导出技术,利用了 dylib
重导出技术后,libmiss.dylib 变成了一个纯数据的
dylib,在执行期间发生缺页异常时也就不会触发内核对内存页的代码签名验证,这点比较重要,因为这里的过代码签名技术不是通用的,只能针对纯数据的 dylib。
相信大家都看过代码签名相关的文档与资料,比如: Stefan Esser 的《death of the vmsize=0 dyld
trick》,大多都会介绍利用 MachO 的 Segment
重叠技术来过代码签名,这里不再对这种技术做详细的说明。但是会解析另外一个问题:既然是一个纯数据的 dylib,本身也没有代码为何还要费劲得去过代码签名?因为
loader 要求 MachO 文件必须有一个代码段,即使本身不需要。
由于 iOS 8 之后 AMFI 中增加了另外一个安全机制,即:Library Validation,这个安全机制主要用来对抗代码注入式的攻击,盘古在
《Userland Exploits of Pangu 8》中对 LV (Library Validation)有介绍,下图是逆向分析得到的 LV
的流程图,供大家参考:
[](http://nirvan.360.cn/blog/wp-content/uploads/2016/01/Library-Validation-Flow.png)
图6:库验证的流程图
因此,这里 libmiss.dylib 也利用移植代码签名的技术手段来过 LV,这里给大家一个移植代码签名的思路:
1、解析要利用其签名信息的 MachO 文件,比如 afcd,从其中将签名数据 dump 到文件中,并得到大小。
2、在对 libmiss.dylib 做 malformed 之前,先用 codesign_allocate 为 dylib
申请签名空间,为第一步中的大小:
man codesign_allocate
codesign_allocate -i libmis.dylib -a arm64 128 -o libmis2.dylib  
---  
表16:为dylib申请代码签名空间
3、对 libmiss.dylib 做 malformed。
4、利用二进制编辑工具修改 libmiss.dylib,将预留的签名数据空间替换为第一步导出的签名数据。
**四、用户空间 root 执行任意代码**
至此,我们已经制作了 malformed libmiss.dylib,只要 afmid 加载了这个 dylib
相当于就过掉了代码签名。下面一起看下越狱工具以什么样的顺序执行 /Developer/Library/Lockdown/ServiceAgents
中的服务:
1、调用 com.apple.mount_cache_1~8.plist 中的服务,mount /dev/disk1s3 到
/System/Library/Caches,目的是让系统中存在 enable-dylibs-to-override-cache,从而可以用磁盘中的
libmiss.dylib 覆盖 dylib cache 中的文件。之所以有 1~8 是因为越狱工具无法确定具体是哪个 disk。
2、调用 com.apple.mount_lib_1~8.plist 中的服务,mount /dev/disk1s2 到 /usr/lib,这样
libmiss.dylib 就存在于文件系统中了。
3、调用 com.apple.remove_amfi.plist 中的服务,停掉 amfid。
4、调用 com.apple.load_amfi.plist 中的服务,重启 amfid 服务,由于 enable-dylibs-to-override-cache 的存在,/usr/lib 中的 malformed libmis.dylib 会被加载,代码签名的函数都被重导出,对于代码签名请求总会返回
0,0代表签名有效。之后,我们便可以执行任意代码了。
5、调用 com.apple.ppinstall.plist 中的服务,以 root 权限运行 untether,untether 会重新 mount
根分区到可写,将 /var/mobile/Media 中的 Payload 拷贝到系统的相应目录中,然后就是攻击内核,Patch 掉文章开始提到的安全特性。
6、调用 com.apple.umount_cache.plist 中的服务,还原 /System/Library/Caches 目录到磁盘上的状态。
7、调用 com.apple.umount_lib.plist 中的服务,
还原 /usr/lib 目录到磁盘上的状态。
至此,用户空间的攻击基本结束了,下面会介绍了持久化的方法,之后会介绍针对内核的攻击。
**五、持久化(完美越狱)**
所谓完美越狱是指设备重启后可以自动运行 untecher,这样就需要把 untether 做成开机自动启动的服务。我们知道系统的自启动服务存放在
/System/Library/LaunchDaemons/ 中,每个服务都是使用 plist 来配置,但是大概是从 iOS 7 之后自启动服务的
plist 还需要嵌入到 libxpc.dylib 中,苹果是想用代码签名技术保护防止恶意程序修改自启动服务。
因此,如果想让 untether 开机自启动我们还需要将相关的 plist 嵌入到 libxpc.dylib 中,由于 libxpc.dylib
会被修改,从而破坏了其原本的代码签名,因此也需要使用与构造 libmiss.dylib 相同的技术来过代码签名,过库验证。
下面介绍下系统是如何从 libxpc.dylib 中读取 plist 数据的:
1、使用 dlopen 加载 libxpc.dylib。
2、调用 dlsym 判断是否存在导出符号:__xpcd_cache。
3、调用 dladdr 得到 __xpcd_cache 符号的地址。
4、调用 getsectiondata 得到包含 __xpcd_cache 的 Section 的数据。
5、调用 CFDataCreateWithBytesNoCopy 创建 CFData 对象。
6、调用 CFPropertyListCreateWithData 将 Data 转换为 plist。
在测试的过程中编写了一个打印 libxpc.dylib 中 plist 信息的工具,大家可以从 github 下载,在设备上使用:
[https://github.com/Proteas/xpcd_cache_printer](https://github.com/Proteas/xpcd_cache_printer)
之所以在这里介绍持久化,是因为持久化是完美越狱的重要组成部分,但是又不属于内核漏洞。介绍来会介绍内核相关的漏洞与利用。
**六、内核信息泄露**
**相关漏洞**
**CVE-2014-4491**
**Kernel – Fixed in iOS 8.1.3**
Available for: iPhone 4s and later, iPod touch (5th generation) and later,
iPad 2 and later
Impact: Maliciously crafted or compromised iOS applications may be able to
determine addresses in the kernel
Description: An information disclosure issue existed in the handling of APIs
related to kernel extensions. Responses containing an OSBundleMachOHeaders key
may have included kernel addresses, which may aid in bypassing address space
layout randomization protection. This issue was addressed by unsliding the
addresses before returning them.
CVE-ID
**CVE-2014-4491** : @PanguTeam, Stefan Esser  
---  
表17:CVE-2014-4491
#### CVE-2014-4496
**Kernel – Fixed in iOS 8.1.3**
Available for: iPhone 4s and later, iPod touch (5th generation) and later,
iPad 2 and later
Impact: Maliciously crafted or compromised iOS applications may be able to
determine addresses in the kernel
Description: The **mach_port_kobject** kernel interface leaked kernel
addresses and heap permutation value, which may aid in bypassing address space
layout randomization protection. This was addressed by disabling the
mach_port_kobject interface in production configurations.
CVE-ID
**CVE-2014-4496** : TaiG Jailbreak Team  
---  
表18:CVE-2014-4496
### 利用方法
CVE-2014-4491,逻辑漏洞,不需要什么利用技巧,利用如下的代码,可以获取到内核信息:
    - (NSData *)getKextInfoData
    {
        vm_offset_t request = "Kext Request PredicateGet Loaded Kext Info";
        mach_msg_type_number_t requestLength = (unsigned int)strlen(request) + 1;
        vm_offset_t response = NULL;
        mach_msg_type_number_t responseLength = 0;
        vm_offset_t log = NULL;
        mach_msg_type_number_t logLength = 0;
        kern_return_t opResult = KERN_SUCCESS;
        kext_request(mach_host_self(),
                     0,
                     request,
                     requestLength,
                     &response,
                     &responseLength,
                     &log,
                     &logLength,
                     &opResult);
        if (opResult != KERN_SUCCESS) {
            printf("[-] getKextInfoString: fail to request kernel infon");
            return NULL;
        }
        NSData *responseData = [[NSData alloc] initWithBytes:response length:responseLength];
        return [responseData autorelease];
    }
表19:CVE-2014-4491 的利用
具体信息如下图:
[](http://nirvan.360.cn/blog/wp-content/uploads/2016/01/iOSJB812-KernelInfo.png)
图7:内核信息
得到内核信息后,解析 xml 数据,得到 OSBundleMachOHeaders 键对应 Base64 字符串,之后解码字符串可以得到一个 MachO:
[](http://nirvan.360.cn/blog/wp-content/uploads/2016/01/iOSJB812-MachOHeader.png)
图8:MachO Header
然后解析这个 MachO 头从中得到 __TEXT Segment 的开始地址,得到 __PRELINK_STATE 的开始地址,然后从
__PRELINK_STATE 的开始地址中计算出内核的开始地址,用内核的开始地址减去 __TEXT 的开始地址就是 KASLR 的
Slide。__PRELINK_INFO Segment 的结束地址就是内核的结束地址。这样我们就得到了内核的起始地址、结束地址、KASLR 的
Slide。这些信息主要有两方面的应用:Patch 内核相关的工作需要内核的真实地址;在内核堆利用过程中也需要知道KASLR 的 Slide
从而得到堆对象的真实地址。
CVE-2014-4496,逻辑漏洞,Stefan Esser 对这个漏洞做了详细的描述:
[mach_port_kobject() and the kernel address
obfuscation](https://www.sektioneins.de/en/blog/14-12-23-mach_port_kobject.html)
大家可以仔细阅读下,这里补充下具体怎么获得那个常量对象:
    io_master_t io_master = 0;
    kret = host_get_io_master(mach_host_self(), &io_master);
表20:创建常量对象
至此内核信息泄露相关的漏洞已经介绍完毕,这些都是内核读与内核代码执行的准备工作。
**七、内核读、任意代码执行**
**相关漏洞**
**CVE-2014-4487**
**IOHIDFamily – Fixed in iOS 8.1.3**
Available for: iPhone 4s and later, iPod touch (5th generation) and later,
iPad 2 and later
Impact: A malicious application may be able to execute arbitrary code with
system privileges
Description: A buffer overflow existed in IOHIDFamily. This issue was
addressed through improved size validation.
CVE-ID
**CVE-2014-4487** : TaiG Jailbreak Team  
---  
表21:CVE-2014-4487
盘古团队专门有篇文章介绍了这个漏洞产生的原因以及利用思路,大家可以仔细读下:
[CVE-2014-4487 – IOHIDLibUserClient堆溢出漏洞](http://blog.pangu.io/cve-2014-4487/)
利用思路:将一个小 zone 中的内存块释放到大的 zone 中,结合堆风水,释放后立即申请刚刚释放的内存块,便可以覆盖相邻的小内核块。
**利用思路示意图**
利用思路:将一个小 zone 中的内存块释放到大的 zone 中,结合堆风水,释放后立即申请刚刚释放的内存块,便可以覆盖相邻的小内核块。
[](http://nirvan.360.cn/blog/wp-content/uploads/2016/01/iOSJB812-HeapExp.png)
图9:堆溢出利用过程
**内核读**