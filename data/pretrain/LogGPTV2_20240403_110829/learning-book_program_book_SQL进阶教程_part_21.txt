一下，用减法来解答了啊。”
好了，这一节就到这里。下面我们学习其他内容。
寻找相等的子集
下面这个谜题是由CJ.Date于1993年提出的，一直非常有名。这里
也沿用他当时使用的表示“供应商-零件”关系的表作为示例数据，即展
注9
示各个供应商及其经营的零件的表
当然，这里也存在“供皮度”和
“零件”两张表。这里的表
张表的更多信息，请参考C
SupParts是*关系表。关于这
SupParts
J.Date 的著作(深度据索关系数
up|信应育|
psr (零性]
据库：实践者的关系理论入。
A
螺丝
A
螺母
A = C
A
管子
B
螺丝
B
管子
C
螺丝
C
螺母
8 = D
C
管子
D
螺丝
D
管子
E
保险丝
L1
螺母
入
管子
保险丝
我们需要求的是，经营的零件在种类数和种类上都完全相同的供应
商组合。由上面的表格我们可以看出，答案是A-C和B-D这两组。A和
E虽然经营的零件种类数都是3，但是零件的种类却不完全相同，所以
不符合要求。F则在种类数和种类上跟其他供应商都不相同，所以也不
考虑。
---
## Page 136
1-7用SOL进行集合运算123
这个间题看起来很简单，为什么会成为谜题呢？原因是，SQL并没有
提供任何用于检查集合的包含关系或者相等性的谓词。IN谓词只能用来
检查元素是否属于某个集合（∈），而不能检查集合是否是某个集合的子
集（C）。据说，IBM过去研制的第一个关系数据库实验系统—System
R曾经实现了用COWTAINS这一谓词来检查集合间的包含关系，但是后来
因为性能原因被删除掉了，直到现在也没有恢复。所以，我们不妨称它为
“传说中的谓词”
这个间题的特点在于比较的对象是集合。这一点与前面的关系除法运
算很相似。但是，在关系除法运算中，比较对象的一方是固定的（例如前
面例题里的表Skils），而这次比较的双方都不固定。这时，我们需要比较
所有子集的全部组合，所以这个间题更具有普遍性。
首先，我们来生成供应商的全部组合。方法是我们已经非常习惯了的
非等值连接。使用聚合只是为了去除重复。
--生成供应商的全部组合
SELBCT SP1.8up AS s1, SP2-8up AS s2
FROM SupPart8 SP1, SupFarts SP2
MHERE SP1.sup < SP2.sup
GROUP BY SP1-BUp, SP2.8up1
■执行结果
s1
2
接下来，我们检查一下这些供应组合是否满足以下公式：（ACB）
且（AB）=（A=B）。这个公式等价于下面两个条件。
条件1：两个供应商都经营同种类型的零件
条件2：两个供应商经营的零件种类数相同（即存在一一映射）
---
## Page 137
124—第1章神奇的SQL
条件1只需要简单地按照“零件”列进行连接，而条件2需要用
COUNT函数来描述。
SELBCT SP1.sup AS s1, SP2-Bup AS 82
FROM SupParts SP1, SupParts SP2
MHERE SP1.sup < SP2.sup
--生成供应商的全部组合
AND SP1.part = SP2.part
--条件1：经营同种炎型的零件
GROUP BY SP1-BUp, SP2.sup
HAVING COUNI(+) = (SELBCT COUNI(*)
-条件2：经营的零件种炎数相同
FROM SupParts SP3
MHERE SP3 sup = SP1.sup)
AND COUNT (+) = (SSLBCT COUNT(+)
FROM SupParts SP4
MHERE SP4.5up - SF2.sup) /
■执行结果
s1
82
A
C
B
如果我们把HAVING子句里的两个条件当成精确关系除法运算，就
会很好理解。加上这两个条件后，我们就能保证集合A和集合B的元
素个数一致，不会出现不足或者过剩（即存在一一映射）。而且，条件1
又保证了经营的零件类型也都是完全相同的。这样就满足了本题的全部
条件。
对于这个谜题，人们提出了各种各样的解法。本例介绍的方法对关系
除法运算进行了一般化，充分运用了SQL的面向集合的特性，是一种比
较巧妙的解法。这种解法告诉我们，SQL在比较两个集合时，并不是以行
为单位来比较的，而是把集合当作整体来处理的。
最后稍微说点题外话。刚才我们把CONTAINS谓词称作了传说中的谓
注0
词，但是如果它可以使用，我们就可以像下面这样写
关于COTAIE 调词的语法，请
参考 Joe Galko 的著作:bse Coke/s
Sl for Ssarties: Adenoar SOL
SELSCT 'A CONTAINS B
Progras(ng Thinr Edtfon 中 的
HHERE (SELECT paxt
FROM SupPaxta
FROM SupParta
KHEREsup = *A
COWTAINS
---
## Page 138
17用SQL进行集合运算
125
(SBLECT part
(8, = 4n8383HA
这里解释一下，AB即“供应商B经营的所有商品供应商A也都
经营”.如果存在这样的供应商组合，则返回ACONTAINS B这个字符串。
怎么样，如果真的能用，是不是很方便呢？现在或许能解决性能的问题了，
所以或许不久以后这个功能就可以复活了呢。
用于删除重复行的高效SQL
最后，我们通过关于“删除重复行”的例题来练习一下如何应用集合
运算。关于这个间题，在1-2节我们也曾练习过。我们再看一下当时用过
的没有主键的恐怖的表。
ume（商品名）
price (价格]
50
子
100
橘子
100
橘子
100
香蕉
80
删除重复行
me（商品名）
pnice|价格
省
50
子
100
香蕉
80
当时介绍的解法是使用关联子查询，代码非常简单。
--删除重复行：使用关联子查询
DELETE FBOM Producta
HHERE xov1d < ( SSLSCT MAX(P2 -rov1d)
FBOM Producta P2
HHERE Products nane
AND Producta-price = P2.price ):
= P2. nane
图灵社区会员 非洲钢(PI:EMAIL) 专享尊重版权
---
## Page 139
126—第1章神奇的SOL
这种做法不算太差，只是关联子查询的性能间题是难点（光是DELETE
处理就比较耗时了）。因此，这里我们思考一下如何不用关联子查询也能
实现同样的功能。
上面这条语句的思路是，按照“商品名，价格”的组合汇总后，求出
每个组合的最大rowid，然后把其余的行都删除掉。直接求删除哪些行比
较困难，所以这里先求出了要留下的行，然后将它们从全部组合中提取出
来除掉，把剩下的删除一一这就是补集的思想。使用关联子查询的这种方
法是以“商品名，价格”组合为单位来处理的（面向过程语言的循环、中
断控制）。接下来，我们在子查询里直接求出要删除的rowid。
我们假设表中加上了“rowid”列，如下所示。
owd [行 I0)
name[商品名)pnice|价格|
苹果
50
橘子
100
橘子
100
4
橘子
100
香蕉
80
不同的是，这次我们需要把要留下的集合从表Products这个集合中减掉。
SQL语句如下所示。
--用于删除重复行的高效BQL语句（1)：通过EXCEPT求补集
DBL&TE FROM Product8
MHERE rowid IN ( SELECT rovid
-- 全部 rovid
FROM Products
EXCEFT
--减去
SELECT MAX (rowid)
--基留下的rovid
FROM Products
GROUP BY name, pricel1
非相关的子查询返回结果是常数列表“2，3”。其中，使用EXCEPT
求补集的逻辑如下面的图表所示。
图灵社区会员非洲铜(PI:EMAIL）专享尊重版权
---
## Page 140
1-7用SCL进行集合运算127
全部rowid
要留下的 rowid
要删除的rowid
1
2
5
5
使用EXCEPT后，我们就可以轻松求得补集。这个方法想必大家已经
非常明白了。此外，把EXCEPT改写成NOT IN也是可以实现的。代码如
下所示。
--删除重复行的高效SQL语句（2)：通过NOTIN求补集
MHERE rovid MOTIN1 SEL&CT MAX (rovid)
FROM Product8
GROUP BY nane, price) /
这两种方法的性能优劣主要取决于表的规模，以及删除的行数与留下
的行数之间的比率。不过，第二种方法有一个优点，那就是不支持
EXCEPT的数据库也可以使用。
像这样实现了行ID的数据库只有Oracle 和 PostgreSQL.PostgreSQL
里的相应名字是oid，如果要使用，需要事先在CREATE TABLE的时候指
定可选项WITHOIDS。如果其他数据库想要使用这些SQL，则需要在表
中创建类似的具有唯一性的“id”列。
本节小结
本节，我们学习了集合运算的使用方法。本节开头的序文里说过，关
于集合运算，SQL的标准化进行得比较缓慢，所以尽管集合运算可以用来
解决很多问题，但是很多人并不知道。除了本节提到的内容以外，大家可
以再思考一些有趣的SQL。
下面是是本节要点。
1.在集合运算方面，SQL的标准化进行得比较缓慢，直到现在也是
实现状况因数据库不同而参差不齐，因此使用的时候需要注意。
---
## Page 141
128—第1章神奇的SQL
2.如果集合运算符不指定ALL可选项，重复行会被排除掉，而且，这
种情况下还会发生排序，所以性能方面不够好。
3. UNION和 INTERSECT 都具有幂等性这一重要性质，而 EXCEPT 不具
有幂等性。
4.标准SQL没有关系除法的运算符，需要自己实现。
5.判断两个集合是否相等时，可以通过幂等性或一一映射两种方法。
6.使用EXCEPT可以很简单地求得补集。
如果大家想了解更多关于关联子查询的内容，请参考下面的资料。
1.JoeCelko，《SQL权威指南（第4版》（人民邮电出版社，2013年）
关于排除重复行，请参考15.1.14节”在相同表内进行删除”：关于使用
差集运算进行关系除法运算，请参考272.6节“用集合操作符进行除法”。
需要注意的是，Joe Celko在判断集合是否为空集时使用了IS NULL，但
按照目前大多数数据库的实现状况来说，当子查询返回多个值时程序会
出错。根据标准SQL，ISNULL的参数允许是多个值的列表，因此该书
里的写法不算错，但是目前大多数数据库都还没有实现这个功能。
2.JoeCelko，《SQL解惑（第2版）》（人民邮电出版杜，2008年）
关于寻找相等的集合，请参考“谜题27找出相等集合”，正文中提到的
SystemR的故事也请参考这一章。
3. C.J. Date, Relational Database Writings 1991-1994( AddisonWesley,
1995年】
有幕等性是多么地重要。还有，前面提到的关于“寻找相等的集合”的
谜题出自该书AMatter of Intergrity（Part 2 of 3）部分。
---
## Page 142
1-7用SOL进行集合运算—
练习题
练习题1-7-1：改进“只使用UNION的比较”
在“比较表和表：检查集合相等性之基础篇”部分，我们学习了只使
用了UNION的SQL语句。当时我们提到，在使用这条SQL语句之前需要
事先查一下两张表的行数是否相等。实际上，我们稍微修改一下，就可以
不需要判断行数也能直接执行。请考虑一下该如何修改。
练习题1-7-2：精确关系除法运算
在“用差集实现关系除法运算”部分，我们学习了将除法还原成减法
来运算的方法。请将这条SQL语句修改一下，实现“精确关系除法运算”