关键在于它们的顺序，由于第2步和第3步都用到了p->next。如果第4步先执
行，则会使得p->next提前变成了s，使得插入的工作完不成。所以我们不妨把上面这
张图在理解的基础上记忆，顺序是先搞定s的前驱和后继，再搞定后结点的前驱，最
后解决前结点的后继。
如果插入操作理解了，那么删除操作，就比较简单了。
若要删除结点p，只需要下面两步骤，如图3-14-6所示。
p->prior
P
p->next
-(2)-
图 3-14-6
/*把p->next赋值给p->prior的后继，如图中①*/
/*p->prior赋值给p->next的前，如图中②*/
---
## Page 108
大语数据结构
free（p）;
/*静放结点*/
好了，简单总结一下，双向链表相对于单链表来说，要更复杂一些，毕竞它多了
prior指针，对于插入和删除时，需要格外小心。另外它由于每个结点都需要记录两份
指针，所以在空间上是要占用略多一些的。不过，由于它良好的对称性，使得对某个
结点的前后结点的操作，带来了方便，可以有效提高算法的时间性能。说白了，就是
用空间来换时间。
3.15总结回顾
这一章，我们主要讲的是线性表。
先谈了它的定义，线性表是零个或多个具有相同类型的数据元素的有限序列。然
后谈了线性表的抽象数据类型，如它的一些基本操作。
之后我们就线性表的两大结构做了讲述，先讲的是比较容易的顺序存储结构，指
的是用一段地址连续的存储单元依次存储线性表的数据元素。通常我们都是用数组来
实现这一结构。
后来是我们的重点，由顺序存储结构的插入和副除操作不方便，引出了链式存储
结构。它具有不受固定的存储空间限制，可以比较快捷的插入和删除操作的特点。然
后我们分别就链式存储结构的不同形式，如单链表、循环链表和双向链表做了讲解，
另外我们还讲了若不使用指针如何处理链表结构的静态链表方法。
总的来说，线性表的这两种结构（如图3-15-1所示）其实是后面其他数据结构的
基础，把它们学明白了，对后面的学习有着至关重要的作用。
线性表
顺序存储结构
链式存储结构
单链表
静态链表循环链表双向链表
图3-15-1
84
---
## Page 109
第3章线性表
3.16结尾语
知道为什么河里钓起来的鱼要比鱼塘里养的鱼好吃吗？因为鱼塘里的鱼，天天有
人喂，没有天敌追，就等着养肥给人吃，一天到晚游快游慢都一样，身上鱼肉不多，
鱼油不少。而河里的鱼，为了吃饱，为了避免被更大的鱼吃掉，它必须要不断地游。
这样生存下来的鱼，那鱼肉吃起来自然有营养、爽口。
五六十年代出生的人，应该也就是我们父母那一辈，当年计划经济制度下，他们
的生活被社会安排好了，先科员再科长、后处长再局长，混到哪算哪；学徒、技工、
高级技工；教师、中级教师、高级教师，总之无论哪个行业都论资排辈。这样的生活
如何让人奋发努力，所以经济发展缓慢。就像我们的线性表的顺序存储结构一样，位
置是排好的，一切都得慢慢来。
可见，舒适环境是很难培养出坚强品格，被安排好的人生，也很难做出伟大事
业。
市场经济社会下，机会就大多了，你可以从社会的任何一个位置开始起步，只要
你真有决心，没有人可以拦着你。事实也证明，无论出身是什么，之前是凄苦还是富
足，都有出人头地的一天。当然，这也就意味着，面临的竞争也是空前激烈的，一不
小心，你的位置就可能被人插足，甚至你就得out出局。这也多像我们线性表的链式
存储结构，任何位置都可以插入和删除。
不怕苦，吃苦半辈子，怕吃苦，吃苦一辈子。如果你觉得上学读书是受罪，假设
你可以活到80岁，其实你最多也就吃了20年苦。用人生四分之一的时间来换取其余
时间的幸福生活，这点苦不算啥。再说了，跟着我学习，这也能算是吃苦？
好了，今天课就到这，下课。
2
S8
---
## Page 110
大语数据结构
卖书笔记
---
## Page 111
第4章栈与队列
启
栈与队列：
示
栈是限定仅在表尾进行插入和删除操作的线性表。
队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。
---
## Page 112
大调数据结构
4.1开场白
同学们，大家好！我们又见面了。
不知道大家有没有玩过手枪，估计都没有。现在和平年代，上哪去玩这种危险的
真东西，就是仿真玩具也大都被限制了。我小时候在军训时，也算是一次机会，几个
老兵和我们学生聊天，让我们学习了一下关于枪的知识。
当时那个老兵告诉我们，早先军官们都爱用左轮手枪，而非弹夹式手枪，问我们
为什么，我们谁也说不上来。现在我要问问你们，知道为什么吗？（下面一脸茫然）
哈，我听到下面有同学说是因为左轮手枪好看，酷呀。喱，当然不是这个原因。
算了，估计你们也很难猜得到。他那时告诉我们说，因为子弹质量不过关，有个别可
能是臭弹一也就是有问题的、打不出来的子弹。弹夹式手枪（如图4-1-1所示），如
果当中有一颗是卡住了的臭弹，那么后面的子弹就都打不了了。想想看，在你准备用
枪的时候，那基本到了不是你死就是我亡的时刻，突然这手枪明明有子弹却打不出
来，这不是要命吗？面左轮手枪就不存在这问题，这一颗不行，转到下一颗就可以
了，人总不会倒霉到六颗全是臭弹。当然，后来子弹质量基本过关了，由于弹夹可以
放8颗甚至20颗子弹，比左轮手枪的只能放6颗子弹要多，所以后来普及率更高的
还是弹夹式的手枪。
图4-1-1
哦，原来如此。我当时自认为聪明的说道：那很好办呀，这弹夹不是先放进去的
子弹，最后才可以打出来吗？你可以把臭弹最先放进去，好子弹留在后面，这样就不
会影响了呀。
他笑骂道，笨蛋，如果真的知道哪一颗是臭弹，还放进去干吗，早就扔了。（大家
---
## Page 113
第4章栈与队列
大笑）
哎，我其实一直都是有点笨笨的。
4.2栈的定义
4.2.1栈的定义
好了，说这个例子目的不是要告诉你们我当年有多笨，而是为了引出今天的主
题，就是类似弹夹中的子弹一样先进去，却要后出来，面后进的，反而可以先出来的
数据结构—栈。
在我们软件应用中，栈这种后进先出数据结构的应用是非常普遍的。比如你用浏
加载浏览过的网页。比如你本来看着新闻好好的，突然看到一个链接说，有个可以让
你年薪100万的工作，你毫不犹豫点击它，跳转进去一看，这都是啥呀，具体内容我
也就不说了，骗人骗得一点水平都没有。此时你还想回去继续看新闻，就可以点击左
上角的后退键。即使你从一个网页开始，连续点了几十个链接跳转，你点“后退”
时，还是可以像历史倒退一样，回到之前浏览过的某个页面，如图42-1所示。
Google-Windows Iinternet Explorer
hp//wgoogle.comhk/
含收
网页图片后退键
童乐购物
图4-2-1
很多类似的软件，比如Word、Photoshop等文档或图像编辑软件中，都有撤销
（undo）的操作，也是用栈这种方式来实现的，当然不同的软件具体实现代码会有很
大差异，不过原理其实都是一样的。
栈（stack）是限定仅在表尾进行插入和删除操作的线性表。
我们把允许插入和删除的一端称为栈顶（top），另一端称为栈底（bottom），不
含任何数据元素的栈称为空栈。栈又称为后进先出（LastInFirstOut）的线性表，简
称LIFO结构。
理解栈的定义需要注意：
68
---
## Page 114
大话数据结构
首先它是一个线性表，也就是说，栈元素具有线性关系，即前驱后继关系。只不
过它是一种特殊的线性表而已。定义中说是在线性表的表尾进行插入和删除操作，这
里表尾是指栈顶，而不是栈底。
它的特殊之处就在于限制了这个线性表的插入和删除位置，它始终只在栈顶进
行。这也就使得：栈底是固定的，最先进栈的只能在栈底。
栈的插入操作，叫作进栈，也称压栈、入栈。类似子弹入弹夹，如图4-2-2所
示。
栈的删除操作，叫作出栈，也有的叫作弹栈。如同弹夹中的子弹出夹，如图4-2-3
所示。
进栈
出核
栈顶
栈项
栈顶
栈底
栈底
栈底
栈底
图4-2-2
图 4-2-3
4.2.2进栈出栈变化形式
现在我要问问大家，这个最先进栈的元素，是不是就只能是最后出栈呢？
答案是不一定，要看什么情况。栈对线性表的插入和删除的位置进行了限制，并
没有对元素进出的时间进行限制，也就是说，在不是所有元素都进栈的情况下，事先
进去的元素也可以出栈，只要保证是栈顶元素出栈就可以。
举例来说，如果我们现在是有3个整型数字元素1、2、3依次进栈，会有哪些出
栈次序呢？
第一种：1、2、3进，再3、2、1出。这是最简单的最好理解的一种，出栈
次序为321。
■第二种：1进，1出，2进，2出，3进，3出。也就是进一个就出一个，出
栈次序为123。
■第三种：1进，2进，2出，1出，3进，3出。出栈次序为213。
06
---
## Page 115
第4章栈与队列
■第四种：1进，1出，2进，3进，3出，2出。出栈次序为132。
■第五种：1进，2进，2出，3进，3出，1出。出栈次序为231。
有没有可能是312这样的次序出栈呢？答案是肯定不会。因为3先出栈，就意味
着，3曾经进栈，既然3都进栈了，那也就意味着，1和2已经进栈了，此时，2一
定是在1的上面，就是更接近栈顶，那么出栈只可能是321，不然不满足123依次进
栈的要求，所以此时不会发生1比2先出栈的情况。
从这个简单的例子就能看出，只是3个元素，就有5种可能的出栈次序，如果元
素数量多，其实出栈的变化将会更多的。这个知识点一定要弄明白。
4.3栈的抽象数据类型
对于栈来讲，理论上线性表的操作特性它都具备，可由于它的特殊性，所以针对
它在操作上会有些变化。特别是插入和删除操作，我们改名为push和pop，英文直译
的话是压和弹，更容易理解。你就把它当成是弹夹的子弹压入和弹出就好记忆了，我
们一般叫进栈和出栈。
ADT栈（stack）
Data
网线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。
Operation
InitStack（*s）：初始化操作，建立一个空栈S。
DestroyStack（*s）：若栈存在，则销毁它。
ClearStack（*s）：将栈清空。
StackEmpty（S）：若为空，适园true，否则通回false
GetTop（s，*e）：若栈存在且非空，用e返四S的栈项元素。
Push（*S，e）：若栈S存在，插入新元素e到机s中并成为栈顶元素。
Pop（*S，*e）：删除栈s中栈顶元素，并用e通回其值。
StackLength（s）：返回栈s的元素个数。
由于栈本身就是一个线性表，那么上一章我们讨论了线性表的顺序存储和链式存
储，对于栈来说，也是同样适用的。
91
---
## Page 116
大调数据结构
4.4栈的顺序存储结构及实现
4.4.1栈的顺序存储结构
既然栈是线性表的特例，那么栈的顺序存储其实也是线性表顺序存储的简化，我
们简称为顺序栈。线性表是用数组来实现的，想想看，对于栈这种只能一头插入删除
的线性表来说，用数组哪一端来作为栈顶和栈底比较好？
对，没错，下标为0的一端作为栈底比较好，因为首元素都存在栈底，变化最
小，所以让它作栈底。
我们定义一个top变量来指示栈顶元素在数组中的位置，这top就如同中学物理
学过的游标卡尺的游标，如图4-4-1，它可以来回移动，意味着栈顶的top可以变大
变小，但无论如何游标不能超出尺的长度。同理，若存储栈的长度为StackSize，则栈
顶位置top必须小于StackSize。当栈存在一个元素时，top等于0，因此通常把空栈
的判定条件定为top等于一1。
B 4-4-1
来看栈的结构定义
typedefintSElemype;/*SElemType美型根据实际情况而定，这里假设为int*/
typedef struct
SElemType data[MAxSIZE];
inttop:
1用子栈项指针*/
ISqStack;
若现在有一个栈，StackSize是5，则栈普通情况、空栈和栈满的情况示意图如图
4-4-2所示
92
---
## Page 117
第4章栈与队列
栈有两个元素，
tep
空栈，
栈满，
[=dos
lop=
top"4
图 4-4-2
4.4.2栈的顺序存储结构一
一进栈操作
对于栈的插入，即进栈操作，其实就是做了如图4-4-3所示的处理。
数细data