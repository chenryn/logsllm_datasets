ans = num/2 + 5*(1 + num++);
同样，该语句的问题是：编译器可能不会按预想的顺序来执行。你可能
认为，先计算第1项（num/2），接着计算第2项（5*(1 + num++)）。但是，
编译器可能先计算第2项，递增num，然后在num/2中使用num递增后的新
值。因此，无法保证编译器到底先计算哪一项。
还有一种情况，也不确定：
n = 3;
y = n++ + n++;
可以肯定的是，执行完这两条语句后，n的值会比旧值大2。但是，y的
值不确定。在对y求值时，编译器可以使用n的旧值（3）两次，然后把n递增
1两次，这使得y的值为6，n的值为5。或者，编译器使用n的旧值（3）一
次，立即递增n，再对表达式中的第2个n使用递增后的新值，然后再递增n，
这使得 y 的值为 7，n 的值为 5。两种方案都可行。对于这种情况更精确地
说，结果是未定义的，这意味着 C标准并未定义结果应该是什么。
遵循以下规则，很容易避免类似的问题：
如果一个变量出现在一个函数的多个参数中，不要对该变量使用递增或
递减运算符；
如果一个变量多次出现在一个表达式中，不要对该变量使用递增或递减
运算符。
另一方面，对于何时执行递增，C 还是做了一些保证。我们在本章后面
的“副作用和序列点”中学到序列点时再来讨论这部分内容。
276
5.4 表达式和语句
在前几章中，我们已经多次使用了术语表达式（expression）和语句
（statement）。现在，我们来进一步学习它们。C的基本程序步骤由语句组
成，而大多数语句都由表达式构成。因此，我们先学习表达式。
5.4.1 表达式
表达式（expression）由运算符和运算对象组成（前面介绍过，运算对
象是运算符操作的对象）。最简单的表达式是一个单独的运算对象，以此为
基础可以建立复杂的表达式。下面是一些表达式：
4
-6
4+21
a*(b + c/d)/20
q = 5*2
x = ++q % 3
q > 3
如你所见，运算对象可以是常量、变量或二者的组合。一些表达式由子
表达式（subexpression）组成（子表达式即较小的表达式）。例如，c/d是上
面例子中a*(b + c/d)/20的子表达式。
每个表达式都有一个值
C 表达式的一个最重要的特性是，每个表达式都有一个值。要获得这个
值，必须根据运算符优先级规定的顺序来执行操作。在上面我们列出的表达
式中，前几个都很清晰明了。但是，有赋值运算符（=）的表达式的值是什
277
么？这些表达式的值与赋值运算符左侧变量的值相同。因此，表达式q = 5*2
作为一个整体的值是10。那么，表达式q > 3的值是多少？这种关系表达式
的值不是0就是1，如果条件为真，表达式的值为1；如果条件为假，表达式
的值为0。表5.2列出了一些表达式及其值：
表5.2 一些表达式及其值
虽然最后一个表达式看上去很奇怪，但是在C中完全合法（但不建议使
用），因为它是两个子表达式的和，每个子表达式都有一个值。
5.4.2 语句
语句（statement）是C程序的基本构建块。一条语句相当于一条完整的
计算机指令。在C中，大部分语句都以分号结尾。因此，
legs = 4
只是一个表达式（它可能是一个较大表达式的一部分），而下面的代码
则是一条语句：
legs = 4;
最简单的语句是空语句：
;   //空语句
C把末尾加上一个分号的表达式都看作是一条语句（即，表达式语
句）。因此，像下面这样写也没问题：
8;
278
3 + 4;
但是，这些语句在程序中什么也不做，不算是真正有用的语句。更确切
地说，语句可以改变值或调用函数：
x = 25;
++x;
y = sqrt(x);
虽然一条语句（或者至少是一条有用的语句）相当于一条完整的指令，
但并不是所有的指令都是语句。考虑下面的语句：
x = 6 + (y = 5);
该语句中的子表达式y = 5是一条完整的指令，但是它只是语句的一部
分。因为一条完整的指令不一定是一条语句，所以分号用于识别在这种情况
下的语句（即，简单语句）。
到目前为止，读者已经见过多种语句（不包括空语句）。程序清单5.13
演示了一些常见的语句。
程序清单5.13 addemup.c程序
/* addemup.c -- 几种常见的语句 */
#include 
int main(void)         /* 计算前20个整数的和  */
{
int count, sum;     /* 声明[1]       */
count = 0;         /* 表达式语句      */
279
sum = 0;          /* 表达式语句      */
while (count++ 