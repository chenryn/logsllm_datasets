4.42
11.9k
7.6k
11.8k
8.4k
10.6k
6.1k
2.5k
11.2k
4.4k
7.5k
4
0
0
6
9
4
9
1
1
2.45
#Inputs
14.8k
4.4k
12.4k
11k
8.4k
10k
2.8k
8.8k
2.4k
7k
AFLFast
#Unique crashes
#Inputs
1
0
8
7
8
2
-
1
0
1.70
1.4M
1.6M
1.7M
9M
13M
1.8M
-*
347k
829k
1.9M
* We could not run AFLFast on this binary.
† We did not mention results for djpeg+libjpeg and tcpdump+libpcap as we could not find any crash with
any of the three fuzzers, evaluated in this experiment.
Table 3: Basic blocks discovered by TIFF and VUzzer on MA
dataset.
Program
mpg321
pdf2svg
jbig2dec
potrace
gif2png
tcptrace
autotrace
pdftocairo
convert
geo mean
Initial
#BBs
460
4767
974
1390
1170
1290
1521
4742
3399
-
TIFF (#inputs)
VUzzer (#inputs)
597(7400)
5656(3660)
1368(8454)
1542(2819)
1282(7200)
1637(3406)
1676(4380)
4872(6028)
5562(1600)
1935.6 (4438.6)
597(14800)
5078(4600)
1076(12400)
1520(11000)
1309(8600)
1405(10800)
1604(2800)
4758(8800)
5480(2400)
2063.7 (7184.5)
Table 4: Type of bugs discovered by TIFF
Program
mpg321
pdf2svg
Bug Information
heap overflow
buffer-overflow
jbig2dec
jump target corruption; arbitrary write access violation
potrace
gif2png
heap overflow; arbitrary write access violation
arbitrary read access violation
tcptrace
arbitrary write access violation; NULL pointer dereferencing
autotrace
arbitrary read/write access violation; buffer-overflow
pdftocairo
buffer-overflow
convert
buffer-overflow
for jbig2dec and potrace, these inputs were generated by targeting
offsets of type int, thereby causing integer overflow bugs in these
applications. We run the crashes found by jbig2dec on it’s latest
version (0.13) to check the effectiveness of TIFF. We found that on
the latest version, application exited by printing "Integer Overflow
multiplication from stride(268435456)*height(701)." This shows
that TIFF is able to triger bug on the previous version because of it’s
Type Based Mutation Strategy. TIFF aware of the type of stride
is able to put special INT32 values of stride, thus leading to a crash.
Similary we ran the crash found by potrace on one of known parser
of BMP file bmp2tiff. It exited by printing "Cannot process BMP
file with bit count 264". With the help of this statement we can
identify that TIFF is able to trigger crash on potrace since it was
aware of type of the input offset. TIFF mutated the value at that
offset with 2byte integer 264. Potrace application has not handled
this case, therefore TIFF is able to trigger crash in the application.
For pdf2svg, buffer overflow bugs were caused by targeting offsets
of type array.
Overall, we find that TIFF type-consistent fuzzing of both control
and data offsets finds bugs quickly, that both control offset and data
offset mutation matters, and, moreover, that some of the bugs we
found are very severe, as confirmed by manual inspection.
In particular, based on our crash analysis, we found that TIFF
discovered a previously reported CVEs on potrace [1] and auto-
trace [2, 7]. In jbig2dec, TIFF found integer overflow bugs, one of
which has been already reported [3]. Other bugs have been previ-
ously reported by VUzzer [4–6].
In Table 4, we report causes that resulted in crashes.
Finally, on these crash triggering inputs, we also analysed the
impact of our mutation strategy. Specifically, we observed that the
inputs that triggered the crashes in jbig2dec, pdf2svg, and potrace
are generated as a part of data offset based mutation. More precisely,
8 RELATED WORK
In this section, we walk over the literature on fuzzing to highlight
the contribution made by TIFF compared to existing approaches.
513ACSAC ’18, December 3–7, 2018, San Juan, PR, USA
Vivek Jain, Sanjay Rawat, Cristiano Giuffrida, and Herbert Bos
8.1 Directed Fuzzing Approaches
Directed fuzzing, intuitively, can be seen as a way to verify if a
seemingly suspicious code could indeed be vulnerable. Some of the
existing approaches use some form of symbolic execution to drive
the inputs towards the target [23, 26]. In [9], Böhme et al. proposed
DGF which involves LLVM-based static analysis to find functions
and basic-blocks that lead to a set of target error-prone code. While
the suspicious code, for example calls to known vulnerable functi-
ons or patched code, is often known a priori, there are exceptions
such as Dowser [26], which implements a symbolic execution-based
approach to automatically find code prone to buffer overflows. In
contrast, TIFF relies on a bug-oriented mutation strategy to target
buffer-overflow bugs, without knowing them a priori in the applica-
tion or using code-driven heuristics to reduce the (huge) search space.
TIFF’s taintflow based type inference, together with DGF, proposed
in [9], may be used to effectively mutate bytes that influence the
branches only on the directed path, thereby driving the execution
towards the target faster.
BuzzFuzz [22] is another example of fuzzerthat uses DTA, but on
the source code. TIFF also uses DTA to find interesting offsets in
the input, but uses this information for code and bug coverage by
learning the input properties based on the application behavior. This
makes TIFF a more generic fuzzer than directed fuzzing approaches.
Moreover, many of these approaches also require the availability
of source code to perform analysis, whereas TIFF is able to fuzz
binaries of the applications.
In [32], Zhiqiang et al. also showed a possible application of
REWARD’s analysis to directed fuzzing. In this case also, TIFF is
different as it does not rely on any vulnerability specific information
and it has its own input-driven heuristics to mutate and trigger bugs
(in addition to its coverage-oriented strategy).
Input Grammar-Based Fuzzing Approaches
8.2
Grammar-based fuzzing technique is an instance of generational
fuzzing, wherein the format of the input is known a priori. Such
approaches are more effective in fuzzing as by design, as the chan-
ces of creating invalid inputs are much less. However, availability
of input formats (specifications) and a guaranteed correct imple-
mentation of it are difficult to meet in practice. As a result, this
line of research is confined to a class of highly-structured input
formats, such as scripting languages (JavaScript, perl, etc.), mark-up
languages (HTML, XML etc.), where the grammar is available. As
examples, IFuzzer [48], LangFuzz [27] and the recently published
Skyfire [49] are fuzzers that target JavaScript interpreters and XML
type languages.
Very recently, there have also been efforts to learn input grammars
automatically and use that knowledge to fuzz [25]. TIFF differs from
such approaches in a number of ways. In certain input formats, such
as image file formats, the type information is not captured by learning
the grammar and hence, the coverage-based fuzzing may not gain
much as far as bug detection is concerned. also, most of the fuzzers
in this direction have shown a limited learning capabilities for an
arbitrary format. Nevertheless, learning a grammar automatically
and integrating it with TIFF’s type inference-based fuzzing could be
an attractive future direction to explore.
8.3 Evolutionary Fuzzing Approaches
Recent advantages in evolutionary fuzzing has shown very promising
results in security testing [10, 40, 42, 44, 51]. TIFF is an evolutionary
fuzzer and as a result, there are existing fuzzers that come closer to
TIFF in their functionalities.
In design closest to our proposal is VUzzer, which also uses DTA
to infer important input properties for smart fuzzing. However, as
mentioned earlier in this paper, TIFF’s unique type-based mutation
makes it much more powerful than VUzzer. In a very very recent
work (S&P, May, 2018 [14]), Chen et al. proposed Angora- a fuzzer
which uses taintflow analysis, but at the source code level by using
LLVM’s DFSan analysis tool, whereas TIFF works directly on the
binaries of the applications.
AFLFast [10], which improves AFL’s input generation strategy,
applies a probabilistic approach to prune uninteresting inputs, the-
reby speeding up the generation of interesting inputs. Similarly, a
very recent work by Gan et al. (CollAFL) improves AFL by consi-
dering the path connectivity of the executed path, i.e., selecting an
input that corresponds to a path that has more uncovered neighbo-
ring branches. In contrast, TIFF learns which offsets are intereting
to fuzz and what type of mutation should be applied to achieve better
coverage. Our experimental results shows that TIFF outperforms
AFLFast on every application that we tested.
On a different spectrum, there have been approaches that apply
symbolic execution for input generation [12, 26, 47]. Driller [47], for
example, uses AFL together with a concolic execution engine (based
on angr [43]) to drive the input generation. The combination of
evolutionary fuzzing and symbex has shown good results on DARPA
CGC [17]. TIFF substantially differs from such approaches as its
input generation depends on DTA and its mutation strategy is also
tuned to certain class of bugs.
9 CONCLUSIONS
In this work, we elaborate on challenges faced by current fuzzers
while mutating the input. The main challenge comes from the fact
that fuzzers unaware of the type of offsets in the input resort to
inefficient random mutation. This work argues that this mutation
component is crucial and responsible both for triggering bugs and
increasing code coverage. Therefore, we show that by inferring types,
and associating them with every offset of the input, we can prioritize
important offsets as well as values at those offsets to improve code
coverage, but also to increase the probability of triggering bugs.
Specifically, we proposed a new mutation strategy that uses input
type inference for achieving excellent code coverage, while trying to
also maximize the coverage of bugs. We implemented the proposed
mutation strategy in an effective, fully automated, input type-assisted
fuzzer called TIFF, and evaluated our prototype on several real-
world applications as well as the LAVA dataset. We compared the
performance of TIFF with two state-of-the-art fuzzers, VUzzer and
AFLFast, and showed that TIFF performs better than either of them
with an order of magnitude fewer inputs. The concrete lesson we
learn from our evaluation is that inferring input types by analyzing
application behavior is a viable and scalable strategy to improve
fuzzing performance.
514TIFF: Using Input Type Inference To Improve Fuzzing
ACSAC ’18, December 3–7, 2018, San Juan, PR, USA
ACKNOWLEDGEMENTS
We would like to thank the anonymous reviewers for their com-
ments. This project was supported by the European Union’s Horizon
2020 research and innovation programme under grant agreement No.
786669 (ReAct) and by the Netherlands Organisation for Scientific
Research through grants NWO 639.023.309 VICI “Dowsing” and
NWO 639.021.753 VENI “PantaRhei”. This paper reflects only the
authors’ view. The funding agencies are not responsible for any use
that may be made of the information it contains.
REFERENCES
[1] 2013. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-7437.
[2] 2013. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-1953.
[3] 2015. https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=779849.
[4] 2016. https://gitlab.com/esr/gif2png/issues/1.
[5] 2016. https://bugs.freedesktop.org/show_bug.cgi?id=85141.
[6] 2016. https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=844626.
[7] 2017. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-9167.
[8] Joy Arulraj, Guoliang Jin, and Shan Lu. 2014. Leveraging the Short-term Memory
of Hardware to Diagnose Production-run Software Failures. In Proc. ASPLOS ’14.
ACM, 207–222.
[9] Marcel Böhme, Van-Thuan Pham, Manh-Dung Nguyen, and Abhik Roychoudhury.
2017. Directed Greybox Fuzzing. In Proc. CCS’17. ACM, 2329–2344.
[10] Marcel Böhme, Van-Thuan Pham, and Abhik Roychoudhury. 2016. Coverage-
based Greybox Fuzzing As Markov Chain. In CCS’16. ACM, 1032–1043.
[11] Juan Caballero, Heng Yin, Zhenkai Liang, and Dawn Song. 2007. Polyglot: Auto-
matic Extraction of Protocol Message Format Using Dynamic Binary Analysis. In
Proc. CCS ’07. ACM, 317–329.
[12] Cristian Cadar, Vijay Ganesh, Peter M. Pawlowski, David L. Dill, and Dawson R.
Engler. 2006. EXE: Automatically Generating Inputs of Death. In CCS’06. ACM,
322–335.
[13] S. K. Cha, M. Woo, and D. Brumley. 2015. Program-Adaptive Mutational Fuzzing.
In S&P’15. 725–741.
[14] Peng Chen and Hao Chen. 2018. Angora: efficient fuzzing by principled search.
In IEEE S&P’18. San Francisco, CA, USA.
[15] Lucian Cojocar, Taddeus Kroes, and Herbert Bos. 2017. JTR: A Binary Solution
for Switch-Case Recovery. In In Proc. ESSoS’17. 177–195.
[16] Weidong Cui, Helen J. Wang, Marcus Peinado, Luiz Irun-briz, and Karl Chen.
2008. Tupni: Automatic Reverse Engineering of Input Formats. In Proc. CCS’08.
DARPA Cyber Grand Challenge Binaries.
[17] DARPA CGC. 2015.
https://github.com/CyberGrandChallenge.
[18] Brendan Dolan-Gavitt, Patrick Hulin, Engin Kirda, Tim Leek, Andrea Mambretti,
Wil Robertson, Frederick Ulrich, and Ryan Whelan. 2016. LAVA: Large-scale
Automated Vulnerability Addition. In IEEE S&P’16.
[19] Kathleen Fisher, Yitzhak Mandelbaum, and David Walker. 2006. The Next 700
Data Description Languages. In POPL’06. 2–15.
[20] Jonathan Foote. 2013. CERT Triage Tools.
[21] S. Gan, C. Zhang, X. Qin, X. Tu, K. Li, Z. Pei, and Z. Chen. 2018. CollAFL: Path
Sensitive Fuzzing. In IEEE S&P’18. IEEE, 660–677.
[22] Vijay Ganesh, Tim Leek, and Martin Rinard. 2009. Taint-based Directed Whitebox
Fuzzing. In ICSE’09. 474–484.
[23] Patrice Godefroid, Nils Klarlund, and Koushik Sen. 2005. DART: directed auto-
mated random testing. SIGPLAN Not. 40, 6 (2005), 213–223.
[24] Patrice Godefroid, Michael Y. Levin, and David Molnar. 2008. Automated White-
box Fuzz Testing. In NDSS’08. Internet Society.
[25] Patrice Godefroid, Hila Peleg, and Rishabh Singh. 2017. Learn&Fuzz: Machine
Learning for Input Fuzzing. CoRR abs/1701.07232 (2017).
[26] Istvan Haller, Asia Slowinska, Matthias Neugschwandtner, and Herbert Bos. 2013.
Dowsing for Overflows: A Guided Fuzzer to Find Buffer Boundary Violations. In
USENIX SEC’13. 49–64.
[27] Christian Holler, Kim Herzig, and Andreas Zeller. 2012. Fuzzing with Code
Fragments. In USENIX Security 12. Bellevue, WA, 445–458.
[28] Vasileios P. Kemerlis, Georgios Portokalidis, Kangkook Jee, and Angelos D.
Keromytis. 2012. Libdft: Practical Dynamic Data Flow Tracking for Commodity
Systems. In SIGPLAN/SIGOPS VEE ’12. ACM, 121–132.
[29] George Klees, Andrew Ruef, Benji Cooper, Shiyi Wei, and Michael Hicks. 2018.
Evaluating Fuzz Testing. In CCS’18.
[30] Bogdan Korel. 1990. Automated software test data generation. IEEE Transactions
on software engineering 16, 8 (1990), 870–879.
[31] libtiff. 2017. https://github.com/vadz/libtiff/blob/master/libtiff/tif_getimage.c#