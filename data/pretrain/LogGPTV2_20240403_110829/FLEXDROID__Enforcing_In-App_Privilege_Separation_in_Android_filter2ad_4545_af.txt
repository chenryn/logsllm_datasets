FLEXDROID’s features in comparison to stock Android. The
overhead of FLEXDROID mainly comes from two potential
sources. One is from the inter-process stack inspection that
FLEXDROID conducts upon each access request, and the other
is from a sandbox switch that FLEXDROID does upon every
JNI execution and Java API calls from JNI. For the inter-
process stack inspection overhead, we focus on situations
Android
39.13 ms
3.76 ms
136.54 ms
443.01 ms
100.56 ms
88.71 ms
Use scenario
Launch an application∗
Launch a service
Download 1.3MB ﬁle
Take a photo
Send an email∗
Read 8.4MB ﬁle via JNI
∗ Functionalities of open-source K-9 email app
TABLE VII: Performance overheads of real use scenario on both
FLEXDROID and the stock Android. FLEXDROID imposes 0.51%-
5.22% overheads depending on the type of task.
FLEXDROID
39.73 ms
3.95 ms
139.59 ms
448.99 ms
101.70 ms
89.16 ms
Over.
1.55%
5.22%
2.24%
1.35%
1.13%
0.51%
where an app attempts to access various resources, while
measuring the delay of JNI execution and Java API call
for sandbox switch. We note that FLEXDROID introduces
an additional thread, named stack tracer, for each app. The
stack sleeps all the time, thereby leaving negligible impacts
on performance, except when its app makes access requests.
In order to minimize the effect of unrelated processes
(e.g., system daemons), we turn on all cores of CPU and ﬁx
their frequencies to the maximum values for all experiments.
Besides, we assign the highest priorities to all the threads
running our benchmarks. We repeat each experiment case 50
times on both stock Android and FLEXDROID, and choose a
median value for comparison.
We conduct macro-benchmarks to examine overheads in
common use scenarios and micro-benchmarks to inspect the
details.
1) Benchmarks for Common Use Scenarios: We measure
the performance overheads imposed by FLEXDROID with our
custom benchmarks to simulate end-user scenarios commonly
seen on smartphones, as summarized in Table VII. For ease of
modiﬁcation and experiment, we use a popular open-source
email app K-9 [10]. In the following, we explain how we
measure the elapsed time for each case.
Launch an application. The application launch time measures
from when startActivity() is called and the time the app
becomes visible. This time includes relatively slow operations
(e.g., process creation, IPCs between system services, and
I/O operations for supporting GUI). FLEXDROID imposes an
overhead of only 1.6%.
Launch a service. We build a custom Android service to
measure the service launch time. Similar to the app’s launch,
we measure from when startService() is called to the time
the service routine is started. FLEXDROID adds an overhead
of 5.22%, which is relatively larger though the actual timespan
is quite small.
Download an image. Using our custom app, we measure the
elapsed time to download a 1.3MB image from the web and
to store it to an SD card. Although it takes several hundreds
of milliseconds, FLEXDROID adds an overhead of 2.24%, as
just a few permission checks occur.
Take a photo. We measure the elapsed time for taking a
photo using the camera benchmark. It measures from when
the shutter button is clicked to the time the image is stored.
13
Benchmark
Android
3,935 µs
1,221 µs
782 µs
1,390 µs
745 µs
138 µs
1,076 µs
97 µs
963 µs
FLEXDROID
4,529 µs
1,734 µs
1,657 µs
2,338 µs
1,330 µs
142 µs
1,134 µs
186 µs
8,436 µs
startActivity()
startService()
ﬁle open∗
ﬁle open (create)∗
ﬁle delete
ﬁle read†
ﬁle write†
call JNI method
call JNI method
after loading libs‡
∗ Two stack inspections are required during a ﬁle open
† No stack inspection is required during ﬁle read and write
‡ This includes the process of loading (and dynamic linking)
the JNI code and shared libraries needed by the JNI code
Over.
594 µs
513 µs
875 µs
948 µs
585 µs
4 µs
58 µs
89 µs
7,473 µs
TABLE VIII: Micro-benchmarks of starting activity/service, ﬁle-
related system calls and JNI method invocation. FLEXDROID imposes
4-948 µs overheads depending on the number of stack inspection calls
while calling JNI method, including loading and dynamic linking,
increases the delay by 7,473 µs.
FLEXDROID has an overhead of 1.35%, since the time includes
heavy operations such as capturing raw images from camera
and compressing it.
Send an email. In K-9 app, when we press the Compose but-
ton, a background task for sending an email is asynchronously
executed. Thereby we measure the email sending time as the
execution time of the background task. Since the task is heavy,
our system adds only 1.13% overhead.
Read a ﬁle via JNI. We invoke a native method which reads
data from a 8.4MB ﬁle and measure the time to ﬁnish its
execution. FLEXDROID imposes an overhead of only 0.51%,
which is imperceptible.
2) Micro-benchmarks: We build a custom benchmark app
to measure overheads from inter-process stack inspection for
accessing user-space and kernel-space resources (e.g., Activity,
Service, File) and the expense of calling JNI method. For
user-space resources, we measure the execution times of
startActivity() and startService(). Table VIII shows
the overheads that are mainly caused by inter-process stack
inspection.
evaluate
resources, we
For kernel-space
the over-
heads regarding ﬁle operations. Our benchmark app ac-
cesses a ﬁle located in the external storage by invok-
ing open, read, write, and close system calls, which need
READ/WRITE_EXTERNAL_STORAGE permissions. As shown
in Table VIII, we can see that opening a ﬁle has approximately
twice the delay of the one for ﬁle deletion. This is because
opening a ﬁle requires executing the inter-process stack in-
spection twice, while the ﬁle deletion needs to execute only
once. File read and write have a much lower overhead since
they do not involve the inter-process stack inspection.
Our benchmark app invokes a native method that simply
prints a log message. When Dalvik VM calls a JNI method
for the ﬁrst time, it conducts loading and dynamic linking the
JNI code and shared libraries needed by the JNI code. After
14
this, calling the same JNI method again skips the process
of loading and dynamic linking to shorten the delay. It is
worth mentioning that the Android linker keeps loaded shared
libraries to avoid loading the same shared library again. Since
the linker for JNI domain in FLEXDROID loads shared libraries
that are already loaded in Java domain, the ﬁrst delay of calling
a JNI method must be much longer. This overhead, however,
does not last after the ﬁrst call. Depicted in Table VIII, the ﬁrst
JNI method call introduces an overhead of 963 µs on stock
Android, and FLEXDROID incurs an additional overhead of
7,473 µs. The overhead mainly comes from additional loading
and dynamic linking. Though it is very large, the later JNI
method calls, fortunately, impose only 89 µs overhead. The
additional expenses of the later JNI method calls stem from
the sandbox switch.
VII. DISCUSSION
Currently, FLEXDROID has a weakness in terms of back-
ward compatibility which is caused by JNI sandbox. As spec-
iﬁed in §VI-A, Pthread ID, mmap(), and free() are known
sources of faults when executing JNI code in FLEXDROID.
In particular, supporting mmap() requires changing mmap()
system call implementation inside the kernel. It must distin-
guish memory pages that will be allocated in JNI domain from
the one allocated in Java domain, so that FLEXDROID can
allocate memory to each domain depending on the caller of
mmap() and avoid domain faults. Developing the JNI sandbox,
which provides complete backward compatibility, would be a
meaningful future work.
FLEXDROID does not provide memory isolation between
third-party libraries. What this means is that malicious third-
party libraries can use native code to access or overwrite the
memory of other third-party libraries running on its host app.
Establishing memory isolation between third-party libraries is
another signiﬁcant future work.
Since most of the third-party libraries are provided with
a list of necessary permissions as a plain text or a part
of the manifest code, an app developer can easily enforce
FLEXDROID’s policy with the given information.
App developers often protect apps’ source code with Pro-
Guard [15] which optimizes and obfuscates the source code.
Since ProGuard obfuscates package names, which is given to
FLEXDROID rule, FLEXDROID may not work effectively with
an app protected by ProGuard. To overcome this limitation,
we suggest that app developers conﬁgure ProGuard to exclude
suspicious libraries, which is easily done by adding a few lines
in the conﬁguration ﬁle (proguard.conﬁg).
VIII. CONCLUSION
In this paper, we present FLEXDROID, an extension to
Android’s permission system, which provides dynamic, ﬁne-
grained access control for third-party libraries. FLEXDROID
enables app developers to fully control capabilities of third-
party libraries (e.g., permissions to be granted), and specify
behaviors after unauthorized resource access attempts (e.g.,
quitting the app or sending dummy data). From our analysis
of 100,000 Android apps, 17.1% of 295 third-party libraries
are found to utilize JNI, and at
least 27.9% of them are
observed to use dynamic code generation. Considering that
these are two key factors hindering the host app and their third-
party libraries from drawing clear and trustworthy boundaries
at runtime, FLEXDROID provides a novel in-app privilege
isolation mechanism with inter-process stack inspection, which
is effective to JNI as well as dynamic code generation.
Our usability and compatibility experiments with 32 pop-
ular Android apps show that app developers can easily adopt
FLEXDROID’s policy to third-party libraries without any code
modiﬁcation except the manifest. Also, our evaluation shows
that FLEXDROID successfully regulates resource access of
third-party libraries with imperceptible performance over-
heads.
ACKNOWLEDGMENT
We thank the anonymous reviewers and our shepherd,
David Lie, for their helpful feedback. This work was sup-
ported in part by Institute for Information & communications
Technology Promotion (IITP) grant funded by the Korea
government(MSIP) (No.10041313, UX-oriented Mobile SW
Platform). Taesoo Kim was supported in part by the NSF award
(DGE-1500084), by the ONR grant (N00014-15-1-2162), and
by the DARPA Transparent Computing program under contract
No. DARPA-15-15-TC-FP-006.
REFERENCES
[1] acl(5) Linux man page. http://linux.die.net/man/5/acl.
[2] Actionbarsherlock Android SDK. http://actionbarsherlock.com/.
[3] Adobe Pdf Library SDK. http://www.adobe.com/devnet/pdf/library.html.
[4] android-apktool: A tool for reverse engineering Android apk ﬁles. https:
//code.google.com/p/android-apktool/.
[5] App annie. https://www.appannie.com.
[6] Dropbox Android SDK. https://www.dropbox.com/developers/core/sdks/
ﬁned-for-angry-birds-mobile-billing-scam.
[10] K-9 mail. https://en.wikipedia.org/wiki/K-9 Mail.
[11] Mp4parser. https://code.google.com/p/mp4parser/.
[12] Nineoldandroids. http://nineoldandroids.com/.
[13] Open Rich Media Mobile Advertising.
ormma/.
https://code.google.com/p/
[14] Paypal Android SDK. https://developer.paypal.com.
[15] Proguard. http://developer.android.com/tools/help/proguard.html.
[16] Snappydb. https://github.com/nhachicha/SnappyDB.
[17] Unity3d SDK. http://docs.unity3d.com/Manual/android-sdksetup.html.
[18] Yahoo news. https://play.google.com/store/apps/details?id=com.yahoo.
mobile.client.android.yahoo.
[19] K. W. Y. Au, Y. F. Zhou, Z. Huang, and D. Lie. Pscout: Analyzing
the android permission speciﬁcation. In Proceedings of the 2012 ACM
Conference on Computer and Communications Security, 2012.
[20] A. R. Beresford, A. Rice, N. Skehin, and R. Sohan. Mockdroid: Trading
In Proceedings
privacy for application functionality on smartphones.
of the 12th Workshop on Mobile Computing Systems and Applications,
2011.
[21] R. Bhoraskar, S. Han, J. Jeon, T. Azim, S. Chen, J. Jung, S. Nath,
R. Wang, and D. Wetherall. Brahmastra: Driving apps to test the security
of third-party components. In 23rd USENIX Security Symposium, Aug.
2014.
[22] T. Book, A. Pridgen, and D. S. Wallach. Longitudinal analysis of android
ad library permissions. arXiv preprint arXiv:1303.0857, 2013.
[23] S. Bugiel, L. Davi, A. Dmitrienko, T. Fischer, and A.-R. Sadeghi. Xman-
droid: A new android evolution to mitigate privilege escalation attacks.
Technical report, 2011. URL http://www.trust.informatik.tu-darmstadt.
de/ﬁleadmin/user upload/Group TRUST/PubsPDF/xmandroid.pdf.
android.
[7] FFMPEG. https://www.ffmpeg.org/.
[8] Google Analytics Android SDK.
analytics/devguides.
https://developers.google.com/
[9] Firm ﬁned for angry birds mobile billing scam. http://ipkonﬁg.com/ﬁrm-
[24] S. Bugiel, L. Davi, A. Dmitrienko, T. Fischer, A.-R. Sadeghi, and
B. Shastry. Towards taming privilege-escalation attacks on android. In
NDSS, 2012.
[25] J. Crussell, R. Stevens, and H. Chen. Madfraud: Investigating ad fraud
in android applications. In Proceedings of the 12th Annual International
Conference on Mobile Systems, Applications, and Services, 2014.
[26] M. Dietz, S. Shekhar, Y. Pisetsky, A. Shu, and D. S. Wallach. Quire:
In 20th
Lightweight provenance for smart phone operating systems.
USENIX Security Symposium, Aug. 2011.
[27] W. Enck, P. Gilbert, B.-G. Chun, L. P. Cox, J. Jung, P. McDaniel,
and A. N. Sheth. Taintdroid: An information-ﬂow tracking system for
realtime privacy monitoring on smartphones. In Proceedings of the 9th
USENIX Conference on Operating Systems Design and Implementation,
2010.
[28] F-Secure. Mobile Threat Report Q3 2013. https://www.f-secure.com/
documents/996508/1030743/Mobile Threat Report Q3 2013.pdf.
[29] A. P. Felt, H. J. Wang, A. Moshchuk, S. Hanna, and E. Chin. Permission
In USENIX Security Symposium,
re-delegation: Attacks and defenses.
2011.
[30] E. Fragkaki, L. Bauer, L. Jia, and D. Swasey. Modeling and enhancing
androids permission system. In 17th European Symposium on Research
in Computer Security, 2012.
[31] J. Gosling, B. Joy, and G. Steele. The Java Language Speciﬁcation.
1996.
[32] M. C. Grace, W. Zhou, X. Jiang, and A. Sadeghi. Unsafe exposure
In Proceedings of the Fifth
analysis of mobile in-app advertisements.
ACM Conference on Security and Privacy in Wireless and Mobile
Networks, 2012.
[33] P. Hornyack, S. Han, J. Jung, S. Schechter, and D. Wetherall. These
the droids you’re looking for: Retroﬁtting android to protect
In Proceedings of the 18th ACM
aren’t
data from imperious applications.
Conference on Computer and Communications Security, 2011.
[34] D. Lea. Dlmalloc, 2010. URL http://g.oswego.edu/dl/html/malloc.html.
[35] B. Livshits and J. Jung. Automatic mediation of privacy-sensitive
In Presented as part of
resource access in smartphone applications.
the 22nd USENIX Security Symposium, 2013.
[36] G. McGraw and E. W. Felten. Securing Java: Getting Down to Business
with Mobile Code. John Wiley & Sons, Inc., New York, NY, USA, 1999.
ISBN 0-471-31952-X.
[37] P. Pearce, A. P. Felt, G. Nunez, and D. Wagner. Addroid: Privilege
separation for applications and advertisers in android. In Proceedings of
the 7th ACM Symposium on Information, Computer and Communications
Security, 2012.
[38] F. Roesner and T. Kohno. Securing embedded user interfaces: Android
the 22nd USENIX Security
In Presented as part of
and beyond.
Symposium, 2013.
[39] S. Shekhar, M. Dietz, and D. S. Wallach. Adsplit: Separating smartphone
advertising from applications. In Presented as part of the 21st USENIX
Security Symposium, 2012.
[40] R. Stevens, C. Gibler, J. Crussell, J. Erickson, and H. Chen. Investigating
user privacy in android ad libraries. In IEEE MOST 2012, 2012.
[41] M. Sun and G. Tan. NativeGuard: Protecting android applications from
third-party native libraries. In Proceedings of the 2014 ACM conference
on Security and privacy in wireless & mobile networks, 2014.
[42] N. Viennot, E. Garcia, and J. Nieh. A measurement study of google
play. In The 2014 ACM International Conference on Measurement and
Modeling of Computer Systems, 2014.
[43] Y. Wang, S. Hariharan, C. Zhao, J. Liu, and W. Du. Compac: Enforce
component-level access control in android. In 4th ACM conference on
Data and application security and privacy, 2014.
[44] L. K. Yan and H. Yin. Droidscope: Seamlessly reconstructing the os
In
and dalvik semantic views for dynamic android malware analysis.
Presented as part of the 21st USENIX Security Symposium, 2012.
[45] X. Zhang, A. Ahlawat, and W. Du. Aframe: Isolating advertisements
from mobile applications in android. In Proceedings of the 29th Annual
Computer Security Applications Conference, 2013.
[46] Y. Zhou, X. Wang, Y. Chen, and Z. Wang. Armlock: Hardware-based
In Proceedings of the 2014 ACM SIGSAC
fault isolation for arm.
Conference on Computer and Communications Security, CCS ’14, pages
558–569, 2014. ISBN 978-1-4503-2957-6.
[47] Y. Zhou, K. Patel, L. Wu, Z. Wang, and X. Jiang. Hybrid user-level
sandboxing of third-party android apps. In Proceedings of the 10th ACM
Symposium on Information, Computer and Communications Security,
ASIA CCS ’15, pages 19–30, 2015. ISBN 978-1-4503-3245-3.
15