title:SoK: Demystifying Binary Lifters Through the Lens of Downstream Applications
author:Zhibo Liu and
Yuanyuan Yuan and
Shuai Wang and
Yuyan Bao
9
9
7
3
3
8
9
.
2
2
0
2
.
4
1
2
6
4
P
S
/
9
0
1
1
.
0
1
:
I
O
D
|
E
E
E
I
2
2
0
2
©
0
0
.
1
3
$
/
2
2
/
9
-
6
1
3
1
-
4
5
6
6
-
1
-
8
7
9
|
)
P
S
(
y
c
a
v
i
r
P
d
n
a
y
t
i
r
u
c
e
S
n
o
m
u
i
s
o
p
m
y
S
E
E
E
I
2
2
0
2
2022 IEEE Symposium on Security and Privacy (SP)
SoK: Demystifying Binary Lifters Through the
Lens of Downstream Applications
Zhibo Liu, Yuanyuan Yuan, Shuai Wang∗
{zliudc,yyuanaq,shuaiw}@cse.ust.hk
The Hong Kong University of Science and Technology
Yuyan Bao
University of Waterloo
PI:EMAIL
Abstract—Binary lifters convert executables into an intermedi-
ate representation (IR) of a compiler framework. The recovered
IR code is generally deemed “analysis friendly,” bridging low-
level code analysis with well-established compiler infrastructures.
With years of development, binary lifters are becoming increas-
ingly popular for use in various security, systems, and software
(re)-engineering applications. Recent studies have also reported
highly promising results that suggest binary lifters can generate
LLVM IR code with correct functionality, even for complex cases.
This paper conducts an in-depth study of binary lifters from an
orthogonal and highly demanding perspective. We demystify the
“expressiveness” of binary lifters, and reveal how well the lifted
LLVM IR code can support critical downstream applications in
security analysis scenarios. To do so, we generate two pieces
of LLVM IR code by compiling C/C++ programs or by lifting
the corresponding executables. We then feed these two pieces
of LLVM IR code to three keystone downstream applications
(pointer analysis, discriminability analysis, and decompilation)
and determine whether inconsistent analysis results are gen-
erated. We study four popular static and dynamic LLVM IR
lifters that were developed by the industry or academia from a
total of 252,063 executables generated by various compilers and
optimizations and on different architectures. Our ﬁndings show
that modern binary lifters afford IR code that is highly suitable
for discriminability analysis and decompilation, and suggest that
such binary lifters can be applied in common similarity- or
code comprehension-based security analysis (e.g., binary difﬁng).
However, the lifted IR code appears unsuited to rigorous static
analysis (e.g., pointer analysis). To obtain a more comprehensive
view of
the utility of binary lifters, we also compare the
performance of lifter-enabled approaches with that of binary-
only tools in three security tasks, i.e., sanitization, binary difﬁng,
and C decompilation. We summarize our ﬁndings and make
suggestions for the correct use and further enhancement of binary
lifters. We also explored practical ways to enhance the accuracy
of pointer analysis using lifted IR code, by using and augmenting
Debin, a tool for predicting debug information.
I. INTRODUCTION
An intermediate representation (IR) denotes the language
used by a compiler to represent source code for the purpose
of analysis and optimization. A good-quality IR accurately and
concisely represents the semantics of source code in a manner
that is independent of high-level languages. IR designs may
also reﬂect underlying hardware details or be platform-neutral.
To the best of our knowledge, SecondWrite [19], [47], was
the ﬁrst to advocate and provide methods for lifting executa-
bles into LLVM IR code. It enables the reuse of analysis
facilities provided by the LLVM framework, thereby linking
∗Corresponding author.
low-level code analysis with mature compiler infrastructures.
New binary lifter papers are continually presented at top-tier
conferences (e.g., [18], [48], [58], [113]), and industry (e.g.,
Microsoft [80]) has also expended considerable resources to
develop binary lifters [87], [80], [68], [61].
Given the dominance of the LLVM community, most com-
mercial binary lifters aim to translate executables into LLVM
IR code. The lifting of assembly programs into LLVM IR
enables a full set of LLVM compiler passes to be used
to smoothly and rapidly build various security and systems
applications, such as applications for vulnerability detection,
malware analysis, off-the-shelf software security hardening,
cross-architecture code reuse, and proﬁling [19], [47], [40],
[113], [58]. Lifter developers have also demonstrated that
lifted IR code is highly accurate and can pass most function-
ality tests or rigorous formal veriﬁcations [38], [66].
However, we have observed (as elaborated in Sec. III)
that lifted IR code frequently exhibits visually different rep-
resentations, which may stealthily undermine its utility for
application to downstream tasks. Overall, there are several
reverse engineering-related difﬁculties that arise when lifting
machine code into a (platform-neutral) IR, whereas translating
a high-level language into IR is generally facile. We note that
the research community lacks a systematic understanding of
how well the lifted IR code supports downstream applications.
This has caused great confusion for normal users (e.g., [105],
[21], [106], [73]), who want to use lifted IR code for various
downstream applications, and is a research gap that is not fully
disclosed by lifter developers [79].
This research aims to systematically determine the true
capability of binary lifters, which to the best of our knowledge
have yet to be explicated in real-world usage scenarios. We
aim to answer the following key research question: “To
what extent can lifted IR code support representative security
downstream applications?” Although previous research [110]
has highlighted that binary lifters’ outputs may not be of
satisfactory quality, recently released lifters have incorporated
many advanced techniques to enhance the quality of the IR
code they recover [18], [48], [113]. At present, a popular and
attractive procedure involves analyzing low-level x86 binary
and ﬁrmware samples by ﬁrst lifting them into LLVM IR
code [40], [37], [117], [39], [18]. Hence, there is a demand for
studies of LLVM IR lifters in realistic settings to more clearly
© 2022, Zhibo Liu. Under license to IEEE.
DOI 10.1109/SP46214.2022.00027
1100
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:56:18 UTC from IEEE Xplore.  Restrictions apply. 
delineate the applicability of these lifters to common security
analysis and instrumentation tasks.
Our study targets four modern static and dynamic binary
lifters that output LLVM IR code. We set up three rep-
resentative tasks, namely pointer analysis, discriminability
analysis, and C decompilation, as these are the key tasks
of many downstream applications that use binary lifters. We
compare the analysis results obtained from the lifted IR
and the compiled IR (denoted the “upper bound” quality)
over three datasets comprising a total of 252,063 executables
generated using various compilers and optimization settings
on 64-bit x86 and ARM64 platforms. We perform extensive
manual inspections and repairs of unaligned analysis results
and summarize key ﬁndings and their implications. The results
of discriminability analysis and decompilation are generally
good (though as expected, heavy optimizations like -O3 can
impose extra challenge), and provide solid empirical sup-
port to use lifters in similarity-based analysis (e.g., patch-
searching of legacy code [120], [124], [121]). Furthermore,
we also compare the performance of binary-only security
tools with that of lifter-enabled tools in three security tasks,
sanitization [101], binary code difﬁng, and C decompilation,
and present inspiring ﬁndings. We also study approaches to
employing and augmenting Debin [59] to recover debug
information in executables,
thereby enhancing the shallow
support of lifted IR code in pointer analysis. Our augmented
Debin substantially increases the accuracy of pointer analysis
supported by RetDec [68], a popular binary lifter. In sum,
we demonstrate how binary lifters can be optimally applied to
support security-related tasks via the following contributions:
• We advocate a new and important focus for the study of
binary lifters. Rather than using the current approaches
of testing or formally verifying the “functional correct-
ness” of binary lifters, we explore binary lifters from an
orthogonal and demanding perspective by clarifying their
support for downstream applications.
• We use three downstream applications that are the corner-
stone of many security analysis scenarios. To smoothly
benchmark modern static and dynamic lifters, we address
several engineering challenges and expend considerable
manual effort. Our study is conducted in cross-compiler,
cross-optimization, and cross-architecture settings. To ob-
tain a more comprehensive overview, we also directly
compare lifter-enabled solutions with binary-only solu-
tions over three popular security tasks.
• We summarize the ﬁndings and implications of our study.
We provide practical solutions to a common limitation of
modern binary lifters — the ability to support rigorous
static analysis — by using and augmenting recent re-
search [59]. Our ﬁndings provide guidelines for users on
how to analyze low-level binary code with LLVM infras-
tructures for security purposes, and also highlight further
improvements that should be made by lifter developers.
We have released artifacts to support further research and
enhancement of binary lifters [1].
Fig. 1. The workﬂow of modern binary lifters. “Static” and “Dynamic” denote
static disassembling and dynamic binary translation, respectively.
II. PRELIMINARIES
Fig. 1 depicts the high-level workﬂow of binary lifters. To
give a general review of lifting techniques, we subsume both
static and dynamic lifting procedures from a very holistic
perspective. Also, although LLVM IR is used as an example,
the introduced process should be conceptually applicable to
lifters of other IRs. We now elaborate on each step.
Reverse Engineering. A modern static binary lifter forms
an “end-to-end” workﬂow. The input executable ﬁrst goes
through the reverse engineering procedures and is converted
into machine code. To date, disassembling of (non-obfuscated)
executable can be performed smoothly and correctly [110],
[49]. Some binary lifters would even take the commercial tools
(e.g., IDA-Pro [60]) as their frontend.
Dynamic lifters typically run executable within a hardware
emulator (e.g., Qemu [25]). Executed instructions and the
execution context (e.g., values of registers) are collected for
lifting [48], [18]. To accelerate the discovery of new execution
paths, symbolic execution engines (e.g., S2E [35]) could be
used by modern dynamic lifters [18]. Static lifters may also
recover function boundary information before lifting machine
instructions. To identify and recover functions, binary lifters
typically outsource this task to the underlying reverse engi-
neering infrastructures, e.g., IDA-Pro [60] or Radare2 [3].
Line by Line IR Lifting. This step denotes the key procedure
to lift IR code, where each machine instruction is mapped into
a sequence of IR statements. The lifted IR statements would
faithfully emulate machine execution, including CPU register-
level computations, memory updates, and other side effects.
A sequence of IR statements, corresponding to one machine
instruction, will be usually wrapped into a utility function.
Hence, each machine instruction will be mapped to a function
call in the lifted IR code to its utility function.
Runtime Module. Executing machine instructions typically
updates the runtime environment, e.g., CPU registers, ﬂags,
stack, and heap. Accordingly, lifted IR code typically deﬁnes
speciﬁc data structures to represent the runtime environment
and assist
the computation. For instance, a popular lifter,