ful verification of the secret, the server will reply to this n-Auth
device with some information that allows it to compute a series of
symmetric keys that will be forgotten over time. These symmetric
keys can then be used to decrypt private keys that are stored en-
crypted in the n-Auth device’s database. When access to a private
key is needed and the symmetric key to decrypt it is no longer
available on the device, the user will again be asked to provide its
secret for online verification. The servers can specify these timeouts,
which can be rather long depending on the application (or even
infinite for servers that do not require two-factor authentication).
4 FUTURE PROOF
A crucial aspect to take into account when designing the crypto-
graphic protocols for n-Auth is algorithm and key agility. It is very
likely that in the future certain algorithms will need to be replaced
or key sizes increased due to security considerations. Keys will also
need to be changed, regardless of algorithm changes.
4.1 Algorithm Agility
Popular cryptographic protocols (e.g., SSL/TLS) allow for negoti-
ation of the parameters. Even though this is great for backwards
compatibility, this comes with the risk of an adversary negotiating
both parties in the weakest protocol parameters2. We have opted
for a different approach, by strictly limiting the number of protocol
parameters. In essence, we only want to allow a single protocol and
associated parameters, which should maximally satisfy all security
requirements. The only reason to allow multiple (in this case: two)
parameter sets is to allow for fast upgrading in case one of the
ciphers or protocols gets broken.
We make a distinction between the temporary and permanent
parameters. The temporary parameters are set by the server: the
hash function, the elliptic curve and key derivation function for
key agreement; and the authenticated encryption scheme. The
permanent parameters define the signature scheme that is used.
For both the temporary and permanent parameters we define two
versions, one to be used initially and one to enable migration in
the future to a more secure set of parameters. There is no intent
to maintain an extensive list of broken parameters for backward
compatibility.
The server determines which version of the temporary param-
eters (tV ersion) is used, there is no margin for negotiation on the
n-Auth device side. This allows for a very fast migration of the
temporary parameters, which is possible since no long term keys
are involved. The n-Auth device should reject weak temporary pa-
rameters. The version of the temporary parameters is passed on to
the n-Auth device as a part of the SCD message.
For the permanent parameters a similar approach is desirable,
but due to long term keys being involved it is impossible to do in-
stantaneous upgrades. Using the SCD message the server indicates
the preferred permanent parameter set. During the transition of
the server switching from one version to the next, it is possible
for the n-Auth device to set the permanent version (pV ersion) to
the previous version. When the transition period is over, it will no
longer be possible for the user to upgrade his account and the user
will be forced to create a new account.
This means that we have to augment the handshake to set up
the secure connection as follows:
a ) the n-Auth device sends the version of the permanent pa-
rameters along with its first message to the server (DS1);
2See https://censys.io/blog/freak and https://www.mitls.org/pages/attacks/SLOTH for
concrete examples.
n-Auth: Mobile Authentication Done Right
ACSAC 2017, December 4–8, 2017, San Juan, PR, USA
b ) upon receiving DS1, the server sets tV ersion and checks if
c ) in SD2, the server puts a signature on (SERV_AUTH, A, B,
d ) in DS3, the n-Auth device puts a signature on (type, A, B,
the received pV ersion is allowed or aborts otherwise;
pV ersion, tV ersion);
pV ersion, tV ersion).
The last two modifications will prevent man-in-the-middle attackers
from exploiting a version mismatch between n-Auth and server.
Directly after the handshake the server will request that the
n-Auth device updates its key according to the new version. This
is done by sending a MSG with type UPGRADE and a signature
with the server’s new public key (suitable for the new version) on
(UPGRADE, A, B, pV ersion, tV ersion). Note that the pV ersion in this
and the following message are now set by the server. The n-Auth
device will get the server’s new public key and validity period by
requesting the server parameters through a separate request to the
server with an I N IT message (see Section 3.3).
The n-Auth device generates a new key pair and makes a new en-
try in its database, using the received parameters and server public
key.3 The n-Auth device will send a MSG to the server of the type
UPDATE with its new public key(s) and the signature(s) with the new
authentication private key(s) on (UPDATE, A, B, pV ersion, tV ersion).
Upon validation of the signature, the server updates its database
by overwriting the existing entry for this user. From this point
onwards the n-Auth device can no longer authenticate to the server
using the previous pV ersion, even if the transition period is still
active. The server sends a confirmation (MSG of type CONFIRM_
UPDATE) to the n-Auth device, that can now remove the old account
from its database.
4.2 Key Agility
A similar protocol will be used for the server to update its public key
without migrating to a new version of algorithm parameters. This
allows the server to update its key before it expires or to replace its
key if there is doubt about the private key being compromised.
The handshake protocol will be augmented by having the server
sending two signatures (during the transition period) in SD2, one
with the new key and one with the old key. The n-Auth device will
try to validate the first signature (new key), and upon failure the
second signature (old key). When both signatures fail to verify, the
connection will be terminated. Given that the first signature fails
and the second signature verifies, the n-Auth device requests the
new server parameters (by sending a separate I N IT message) and
checks the first signature, using the new public key of the server.
If this signature verifies (new key is correct), the n-Auth device
updates the selected account in its database. Even if this signature
does not verify, the n-Auth device will still continue by sending
DS3 but not update its database.
5 IMPLEMENTATION
In this section we describe the design choices of the implementation
of the user interface, different smart phone operating systems and
other technical details of the n-Auth.
5.1 User Interface
We now go deeper into the user interaction with the application
and the underlying HCI design principles. Molich and Nielsen [16]
provided ten usability recommendations, among others that a usable
system needs to be consistent and that it is better to prevent errors
in the first place than being good at handling these. The n-Auth
device only offers a single button to start the authentication process
(see Figure 3a). By clicking this button, the n-Auth device will start
its camera to capture a 2D visual code.
The principle of psychological acceptability [20] implies that a
user interface must be designed while keeping the user’s mental
models in mind and thus, by extent, the context he is working in.
Yee’s key principles for secure interaction design [27] require users
to provide explicit authorization and visibility of all active sessions.
For the user to establish context and give explicit authorization,
the user will be presented with a confirmation screen after scan-
ning the code, before the n-Auth device authenticates to the server
(step 3a in Figure 1). Depending on the purpose a different confir-
mation screens will be shown to the user. Examples are given in
Figure 3b, 4a, and 4b.
After scanning a code for a login, the user will be asked to
confirm his login, by selecting the desired account (see Fig. 3b). This
approach works for one as well as for multiple accounts existing
with a given server.
Visibility of all active sessions means that, from the n-Auth
device, the user should be able to see to which servers he is currently
logged in and have the possibility to log out (see Figure 3d). To log
out, we choose to have the user swipe a label off the screen to avoid
logging out by accidental tapping. A helper text is displayed the
first time the user logs in using his n-Auth device.
We assume open registrations whereby creating a new account
is started from within the client, in which the user first enters some
basic account information, e.g., a user name. Then the user will be
shown a visual code to be scanned with the n-Auth device. This
visual code contains the necessary parameters of the server and
the selected user name. On the n-Auth device, the user first needs
to confirm the creation of a new account. This confirmation screen
displays the server’s logo and url location, to help the user with
establishing context. The server parameters will be verified by the
user by comparing the displayed visual hash with the server’s ref-
erence image (see Figure 4a). However, if the user already has other
accounts at the same server, he can be relieved from this burden.
The n-Auth device will check that the received server parameters
correspond with the ones of the existing accounts. In this case, the
user is presented with a different screen, as depicted in Figure 4b.
5.2 Smart phone specifics
Because the majority of smart phones today runs on either Android
or iOS, we choose to develop an application for these operating
systems. By making our application freely available through the
official Google Play Store4 and the official Apple iTunes Store5, it
is easy to install, also for less tech-savvy users.
The n-Auth application fully respects the user’s privacy, by only
requiring the minimal permissions (networking and camera) for
3The server’s identity remains the same over all permanent versions.
4https://play.google.com/store/apps/details?id=com.nauth.client
5https://itunes.apple.com/us/app/n-auth/id1176128845
ACSAC 2017, December 4–8, 2017, San Juan, PR, USA
R. Peeters et al.
(a) Starting screen.
(b) Selecting an account.
(c) Entering PIN.
(d) After being logged in.
Figure 3: Login process. Note that step (c) Entering PIN is not always necessary, it depends on the timeout specified for that
server and the time since the user has last entered a PIN that verified.
directly to the n-Auth application, and even to close the n-Auth
application, logging out of all currently logged in sessions.
(a) Notification bar.
(b) Notification drawer.
Figure 5: Using Android’s notification capabilities.
(a) Default.
(b) Pre-existing accounts.
Figure 4: Confirming the creation of a new account.
providing its functionality and not profiling the device and or the
user beyond the model of the device (to ease account management)
and the profiling done by Android and iOS itself6.
When browsing on the same device as our n-Auth application
is installed on, it is possible to transfer the data in the visual code
directly to the n-Auth application. By clicking on the visual code,
the n-Auth application will open, do the authentication, and go back
to the mobile browser. At the same time the n-Auth application will
keep on running in the back, as will be apparent [Android version
only] from the n-Auth icon in the notification bar (see Fig. 5a). This
icon will be visible as long as the user is logged in at some server,
keeping Yee’s [27] principle of visibility of all active sessions in
mind. From the notification drawer (see Fig. 5b) it is possible to go
6Note that we do not make use of any analytics frameworks like, e.g., Google Analytics,
Crashlitics ...
5.3 Technical
The n-Auth server is implemented as a RESTful API to ensure easy
integration with the application backend server (where the actual
service runs that needs authentication). The n-Auth server handles
the coupling of users by the backend server, all communication with
n-Auth device and open sessions. Through the API the backend
server can request if there is a user logged in for a certain session
identifier, and if so which user. Through the developers’ web portal7,
one can set up their own server instance for testing and interact
with it through the API. Note that this is on a shared server and
one obviously loses the No-Trusted-Third-Party benefit.
For mobile browsing, we also implemented a direct link on the
visual codes in the HTML source, and made sure that the n-Auth
application listens for Intents. This way a user can simply click on
the visual code to launch the n-Auth application and pass on the
data needed to start authenticating to the server.
All protocol messages are encapsulated using Google protocol
buffers and sent over a plain HTTP connection between the n-
Auth device and the Java application. HTTP was mainly selected
for simplicity of the implementation and to easily pass through
firewalls. This however implies that all protocol round-trips must
be initiated by the n-Auth device and require a connection identifier.
7https://www.n-auth.com/dev/
n-Auth: Mobile Authentication Done Right
ACSAC 2017, December 4–8, 2017, San Juan, PR, USA
For this connection identifier we chose the Diffie-Hellman key B
since this is randomly generated by the server. For efficiency we
however do prefer a dedicated, permanent TCP connection. In case
of loss of connection, it can be recovered using B.
All cryptographic operations have been implemented using the
NaCl [4] library, which is very efficient and has constant time im-
plementations. The used elliptic curve, Curve25519 [2], has several
security advantages compared to the NIST curves. We make use of
the Ed25519 signature [3] scheme, which in comparison with the
widely-used ECDSA signature scheme is less vulnerable to leakage
of the secret key in the case of bad randomness. For authenticated
encryption, we use secret_box, which combines a stream cipher
xsalsa20 and a one-time mac function poly1305.
The client’s database locking mechanism is implemented using a
4 digit PIN, where the 20 most commonly chosen PINs8 are excluded.
This was done to ensure that the success probability of an attacker
trying the most commonly used PIN codes is drastically reduced
(26.83% of all PINs could be guessed by entering the ones in the top
20). Note that this database locking mechanism is optional for each
account, depending on the server’s needs. The server implements
a lock-out mechanism that triggers after 3 consecutive failed PIN
verifications, meaning that after 3 consecutive failed verifications
of the PIN, the device can no longer get the information from the
server needed to unlock the database on the client. The default PIN
timeout is 2 minutes, meaning that the user will not be requested
to input his PIN where he normally would, e.g. to login to another
account, if the last input of the PIN was less than 2 minutes ago.
A login (excluding user interactions) and the database unlocking
mechanism are comparable in the time required and their communi-
cation overhead. The average time required is 0.4 seconds (tested on
a range of Android devices in different setups). This time is mainly
dominated by the time needed to communicate back and forth with
the server (timings of the cryptographic operations on the devices
are in the order of tens of milliseconds), also depending on the used
wireless connection: WIFI (typically the longest time needed, WIFI
is optimised for high throughput at the cost of latency), 3G, 4G.
The communication between the n-Auth device and the server is in
the order of kiloBytes. For enrolment the time and communication
overhead is slightly larger, mainly depending on the size of the logo
to be transferred to the n-Auth device.
6 PRELIMINARY USER STUDY
To evaluate the usability of n-auth, we created a survey website:
https://www.n-auth.com/survey/. Participants were asked to login
daily using n-Auth over the course of two weeks. Each day there
was a new set (each taking less than two minutes to answer) of two
to three short questions on authentication in general and on the
usability of the n-Auth application.
First, participants had to download the n-Auth app from the
official store and create an account on the site using n-Auth. At the
time of creating an account, we assigned participants at random to
one of two groups: a group for which the PIN code mechanism is
enabled and group for which no PIN code is required.
8http://www.datagenetics.com/blog/september32012/
The questionnaire was provided in the native language of the
users (Finnish). The questions are translated to English and provided
in Appendix A for the convenience of the reader.
The entire study was conducted online. Participants were re-
cruited through the user base of Owela (online survey platform)
and mailings to student associations of a nearby university. Partici-
pants could win 2 film tickets (12 in total) if they participated for
at least 6 days. Participants could also opt-in to receive daily email
reminders to participate in the study over the course of two weeks
when the study took place.
Limitations of this study are that (1) no interviews with the par-
ticipants were conducted, we only had ad hoc email conversations
with some of them for trouble shooting; (2) the only demographic
information collected from the participants is their age groups; (3)
the participants had to login to a new service, i.e., it is not a service
they already logged in to on a regular basis; (4) this study was done
for a single website, not showing the n-Auth’s full potential.
The results of this usability study can be found in Appendix B.
Note that this preliminary study is only indicative as the number
of participants (24) does not allow to draw statistically relevant
conclusions.
7 COMPARISON TO PICO
The Pico concept went through an evolution after the initial pub-
lication [22]. In order to bootstrap the Pico ecosystem, a smart