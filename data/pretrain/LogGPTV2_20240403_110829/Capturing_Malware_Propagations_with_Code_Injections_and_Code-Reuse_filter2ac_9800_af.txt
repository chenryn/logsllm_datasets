a
l
e
R
0
0.5
1
1.5
2
Time (min)
Figure 9: Relative CFG size of Tinba malware with (cid:128)rst wave of
dynamically generated code and code injections marked.
e
z
i
s
G
F
C
e
v
i
t
a
l
e
R
100
80
60
40
20
0
0
5
10
15
20
Time (min)
Figure 10: Relative CFG size of Gapz malware with (cid:128)rst wave of
dynamically generated code and code injections marked.
7.5 Relevance of approach on recent malware
We match Tartarus with a recent collection of malware samples to
demonstrate the relevance of our approach. In total, we analyse
934 PE (cid:128)les submi(cid:138)ed to VirusTotal in April and May of 2017. Each
sample has at least 40 anti-malware vendors reporting the sample
malicious. We verify the relevance of our approach by counting
the number of processes a sample injects into and whether it uses
code-reuse a(cid:138)acks. We execute each sample for 600 seconds.
We found that 373 samples inject code into other processes,
which corresponds to 40% of the total malware samples. In contrast,
a report from PaloAlto Networks on New and Evasive Malware from
2013 reports that code injection was observed in 13.5% of samples
Session H2:  Code Reuse AttacksCCS’17, October 30-November 3, 2017, Dallas, TX, USA1703collected in March 2013 [33]. (cid:140)is is an increase of almost three
times in four years. We found that 223 of the samples inject into 4
processes or less and in 120 of the samples code-reuse a(cid:138)acks were
used as part of a code injection. In 118 of these cases, only one
code-reuse a(cid:138)ack was used and in the other two cases a chain of
two code-reuse a(cid:138)acks were used. We consider this to be a strong
indication that indeed code-injection is increasingly being used,
but chained code-reuse a(cid:138)acks inside code injections remain rare.
8 LIMITATIONS AND FUTURE WORK
In this work our focus is on tracing malware propagations within
the host and identifying code injections and code waves with a
special a(cid:138)ention to the use of code-reuse a(cid:138)acks. In this section
we describe limitations of our approach and some of the remain-
ing challenges in the problem space of capturing and describing
malware propagations.
An interesting limitation to our approach is that we only con-
sider malware propagations that happens within a single system
execution. However, some malware carry propagation strategies
that stretch over a system reboot by, for example, dropping a bootkit
or rootkit which is initialized during system start-up. In fact, the
Gapz malware is in this category. When Gapz has injected into
explorer.exe it continues to drop a bootkit and then modify either
the master boot record (MBR) or the volume boot record (VBR)
(depending on the version of Gapz). As a result, during the next
bootup, the modi(cid:128)cations to the MBR or VBR will cause the bootkit
to be loaded and Gapz will continue execution via the bootkit. Au-
tomatic analysis of this part of Gapz requires dynamic analysis to
be stretched over the system boot. To the best of our knowledge,
dynamic analysis of malware has never been done over several
system boots. (cid:140)erefore, an interesting avenue of further research
is to investigate how much more information can be leveraged
automatically about the malware with such an approach.
Another limitation to our approach is the use of our techniques
when the guest system is a multiprocessor environment. For ex-
ample, our approach to collecting the malware execution trace
described in Algorithm 1 assumes a single-core execution environ-
ment. Although we believe the identi(cid:128)cation of code injections
and code waves can follow very similar strategies to our current
approach, we have not yet tested Tartarus with a multi-core guest
environment. However, we will have many more parallel execution
contexts to concern ourselves with and can potentially not rely on
the order of the malware execution trace as we do in this work.
In this paper we focused on identifying control-(cid:131)ow aspects
between processes based on code injections and code waves within
each process. However, we have not paid a lot of a(cid:138)ention to the
control-(cid:131)ow aspects within each code wave itself. In most cases,
we can identify a lot of the control-(cid:131)ow within each code wave
from the instruction execution order in the malware execution trace
and disassembly of the code wave. However, if a malware sample
writes memory to another process and this memory has several
di(cid:130)erent entry points independent of each other, then our approach
will only recognize one code injection and consider the wri(cid:138)en
memory as one code wave. A more accurate approach would be to
discover multiple code injections to the same code wave, and use
that information to capture more precisely the control-(cid:131)ow within
the code wave itself. One potential strategy for solving this problem
is a more re(cid:128)ned de(cid:128)nition of a code-wave, for example something
similar to Ugarte et al. who divides the memory of a code wave
into unpacking frames. However, this would require us to relax the
way we identify code injections and may end up producing many
false positives in the control-(cid:131)ow graph of the malware.
From a practical point of view, a limitation to our approach is
that malware can detect the use of dynamic analysis. (cid:140)is problem
is shared by any dynamic analysis environment. For example, mal-
ware can detect the presence of QEMU and then diverge execution
to non-malicious behaviours. We do not perform any activities to
combat malware that tries to detect the presence of our system.
(cid:140)ere exists several approaches to hardening QEMU for malware
analysis which are directly correlated with approaches in which
malware detects QEMU. If we implement these techniques into
Tartarus we may harden it for some time, but is not likely to work
as a general solution. Conceptually, in order to make it harder for
the malware to detect that it is running inside an analysis environ-
ment, one approach is to switch to dynamic analysis environment
that are more transparent in nature. For example, environments
like Ether [12] that utilize hardware virtualization extensions o(cid:130)er
more separation between the analysis environment and the guest
environment in which the malware is executing.
On a fundamental level, our techniques rely on taint analysis for
capturing malware propagation. As such, our techniques inherit
the limitations of taint analysis for malware analysis, meaning an
a(cid:138)acker can deploy information-(cid:131)ow evasive behaviours in order to
avoid analysis by our techniques. Certainly, techniques like multi-
path exploration via symbolic execution can aid in defeating evasive
behaviours. However, given that we can’t explore the entire state-
space of the vast majority of malware samples, the question we must
really solve is how to identify evasive behaviours. When an evasive
behaviour is then detected, we can rely on various techniques, with
symbolic execution as one of them, to guide execution down the
path of interest. For a more general description about limitation to
taint analysis for malware analysis we refer to Cavallaro et al. [7].
9 RELATED WORK
Dynamic taint analysis have many applications in automating mal-
ware analysis tasks and a lot of work has been done in this area.
System-wide (cid:128)ne-grained malware analysis with taint information
was (cid:128)rst proposed in Panorama by Yin et al. [46]. Panorama is
built on top of QEMU and o(cid:130)ers multiple features such as keylog-
ger detection and malware tracing based on taint analysis. Indeed
the malware tracing o(cid:130)ered by Panorama is the work the comes
closest to ours. In the malware execution tracing itself, Tartarus
di(cid:130)ers from Panorama by also considering code-reuse a(cid:138)acks and
initially taints more memory than Panorama which only taints the
text section. Panorama deploys no abstractions on the execution
trace itself where Tartarus abstracts the trace into code waves and
code injections that are then used to construct a system-wide CFG.
Finally, the evaluation performed with Panorama is centred around
its keylogger detection, which does not rely on malware tracing
via taint, and the evaluation presented in this work is therefore the
(cid:128)rst evaluation on taint analysis for malware tracing. Other work
include Egele et al. who use dynamic taint analysis for spyware
Session H2:  Code Reuse AttacksCCS’17, October 30-November 3, 2017, Dallas, TX, USA1704detection [13] and Moser et al. who use dynamic taint analysis
in combination with linear constraint solvers to explore multiple
execution paths in malware [32]. Dynamic taint analysis has also
been explored in Android, most notably by TaintDroid [14] and
DroidScope [44]. Besides automatic approaches to malware anal-
ysis, dynamic taint analysis has also been proposed as an aid to
manual reverse engineering tasks. For example, the tool SemTrax
[26], which is no longer being developed, augments debugging with
dynamic taint analysis and has the ability to visualize various rela-
tionships on tainted data, such as the set of operations performed
on tainted memory.
In the last decade, full-system dynamic binary analysis platforms
have gained a lot of a(cid:138)ention from malware analysis researchers.
As a result, there now exists several multi-purpose systems that are
well-suited for building further analysis tools. We designed Tartarus
on top of DECAF [20] which is the successor of TEMU from the
BitBlaze project [39]. One of the key features of DECAF is that taint
analysis is performed directly on the QEMU tcg instructions, which
allows it to perform fast taint analysis during execution. In addition
to fast tainting via the tcg instructions, DECAF performs bitwise
taint analysis which gives it a very high level of precision in its taint.
PANDA is another platform that allows full-system dynamic binary
analysis. In comparison to DECAF, PANDA is built around the
concept of repeatable reverse engineering. It executes an instance
of QEMU and records all non-deterministic data that goes into the
system. With the non-deterministic data recorded, PANDA then
provides the ability to replay the execution and the actual analysis
of the execution is performed during replay. (cid:140)e key advantages
of this strategy compared to performing analysis directly on the
real execution is that the recording minimally a(cid:130)ects the actual
execution in terms of performance, and that analysis can take a step-
wise fashion. As such, the execution on which analysis is performed
is e(cid:130)ectively independent of the computational workload of the
analysis, i.e. analysis is performed on a “fast” full-system emulation,
and, di(cid:130)erent analysis can be performed on the same execution.
PANDA supports byte-level taint analysis by raising the QEMU
trace into an LLVM trace. S2E [9] is another platform that also o(cid:130)ers
full-system dynamic binary analysis, but, in comparison to DECAF
and PANDA, is focused around augmenting symbolic execution
to full-system analysis. S2E does this via an x86-to-LLVM QEMU
backend that interfaces S2E with the KLEE symbolic execution
engine that interprets LLVM instructions. Both DECAF, PANDA
and S2E provides comprehensible interfaces for writing plugins
and are all open-source projects.
(cid:140)roughout the paper we have already mentioned automated
unpackers and other tools that give solutions to the problem of
self-modifying code. We have speci(cid:128)cally focused on Codisasm [5]
and Ugarte et al [40]. Other tools include Renovo [22], OmniUn-
pack [30], EtherUnpack [12], RePEconstruct [24] and Polyunpack
[37]. All of these tools rely on the heuristic of monitoring explicit
write-then-execute pa(cid:138)erns. EtherUnpack and Renovo captures
dynamically generated code within a speci(cid:128)c process where Omni-
Unpack deploys a more coarse-grained approach by monitoring for
page-level write-then-execute pa(cid:138)erns and suspicious system calls.
RePEconstruct is a tool based on DynamoRIO that aims at uncover-
ing dynamically generated code and identify obfuscated API calls,
but does not make any a(cid:138)empt to follow the malware across pro-
cesses. Polyunpack detects unpacking behaviour by single-stepping
an application and matching the program counter to an initial static
analysis.
Besides related work in the more general scope of malware anal-
ysis, memory forensics is an area that also provides solutions to
the problem of identifying how malware infects a system. For ex-
ample, the Gapz malware places shellcode within explorer.exe by
overwriting the function atan inside of ntdll. Code integrity check
to verify the provenance of code in memory images is able to iden-
tify that malware overwrote the function by analysing memory
images [42]. Volatility [15] is a popular open source project that is
used for digital forensics and indeed there are plugins for volatility
aimed at identifying code injection [31]. (cid:140)e di(cid:130)erence between
our approach and that of memory forensics is the forensics analy-
sis relies on a snapshot where our approach is based on analysis
of an execution. (cid:140)is means, if the Gapz would rewrite the atan
function a(cid:137)er having executed its shellcode, such that the atan
function would contain its original instructions and the snapshot
of the memory image was taken post this rewriting, then forensics
on this snapshot would not reveal the overwri(cid:138)en code, whereas
we would still observe the execution of shellcode.
10 CONCLUSION
In this paper we concern ourselves with automatic analysis of host-
based malware propagations. Speci(cid:128)cally, we divide the problem
into to two smaller tasks. First, how to trace malware in a gen-
eral and precise manner in the context of execution across several
processes and code-reuse a(cid:138)acks. Second, how to raise the col-
lected execution trace into higher-level semantics of dynamically
generated code and code injections.
To solve these problems we have proposed three techniques and
implemented them in a system we call Tartarus. Tartarus is a mal-
ware analysis environment that traces malware execution based on
taint analysis and a model of code-reuse a(cid:138)acks. Tartarus abstracts
the execution trace into code waves based on an information-(cid:131)ow
model, and also identi(cid:128)es and highlights intrinsic characteristics
about code injection techniques in the execution trace. Finally, Tar-
tarus combines these abstractions into a system-wide control-(cid:131)ow
graph.
We test Tartarus in the context of ground-truth applications
and our results show that Tartarus accurately captures malware
propagations, even without prior knowledge about them. We show
via a comparative evaluation that Tartarus improves capture of
malware execution traces over state-of-the-art dynamic analysis
tools. We evaluate the performance of Tartarus which ranges from
a few minutes to 15 minutes depending on the complexity of the
sample. Finally we demonstrate the relevance of our approach by
matching Tartarus with a recent malware data set which shows the
number of malware samples that inject code have increased almost
three times since 2013.
ACKNOWLEDGMENTS
(cid:140)e authors would like to acknowledge our anonymous reviewers,
Pedro Antonino and Julien Vanegue for useful feedback and insight-
ful critique. We would also like to thank VirusTotal for providing
Session H2:  Code Reuse AttacksCCS’17, October 30-November 3, 2017, Dallas, TX, USA1705malware samples and Udi Yavo and Tal Liberman of enSilo for
making their code injection techniques available. Finally we would
like to thank Xunchao Hu for helping the (cid:128)rst author with several
aspects of DECAF. Work is funded by National Science Foundation
Grant #1664315 and DARPA Grant #FA8750-16-C-0044.
tinues. (2015).
REFERENCES
[1] Andrea Allievi and Holger Unterbrink. 2015. CryptoWall 4 (cid:140)e Evolution Con-
[2] Magal Baz and Or Safran. 2017. Dridex’s Cold War: Enter AtomBombing. (2017).
[3] Fabrice Bellard. 2005. QEMU, a Fast and Portable Dynamic Translator. In Pro-
ceedings of the Annual Conference on USENIX Annual Technical Conference (ATEC
’05). USENIX Association, Berkeley, CA, USA, 41–41. h(cid:138)p://dl.acm.org/citation.
cfm?id=1247360.1247401
[4] Tyler Bletsch, Xuxian Jiang, Vince W. Freeh, and Zhenkai Liang. 2011. Jump-
oriented Programming: A New Class of Code-reuse A(cid:138)ack. In Proceedings of
the 6th ACM Symposium on Information, Computer and Communications Security
(ASIACCS ’11). ACM, New York, NY, USA, 30–40. h(cid:138)ps://doi.org/10.1145/1966913.
1966919
[5] Guillaume Bonfante, Jose Fernandez, Jean-Yves Marion, Benjamin Rouxel, Fab-
rice Sabatier, and Aur´elien (cid:140)ierry. 2015. CoDisasm: Medium Scale Con-
catic Disassembly of Self-Modifying Binaries with Overlapping Instructions.
In Proceedings of the 22Nd ACM SIGSAC Conference on Computer and Com-
munications Security (CCS ’15). ACM, New York, NY, USA, 745–756. h(cid:138)ps:
//doi.org/10.1145/2810103.2813627
[6] Erik Buchanan, Ryan Roemer, Hovav Shacham, and Stefan Savage. 2008. When
Good Instructions Go Bad: Generalizing Return-oriented Programming to RISC.
In Proceedings of the 15th ACM Conference on Computer and Communications
Security (CCS ’08). ACM, New York, NY, USA, 27–38. h(cid:138)ps://doi.org/10.1145/
1455770.1455776
[7] Lorenzo Cavallaro, Prateek Saxena, and R. Sekar. 2008. On the Limits of Informa-
tion Flow Techniques for Malware Analysis and Containment. In Proceedings of
the 5th International Conference on Detection of Intrusions and Malware, and Vul-
nerability Assessment (DIMVA ’08). Springer-Verlag, Berlin, Heidelberg, 143–163.
h(cid:138)ps://doi.org/10.1007/978-3-540-70542-0 8
[8] Stephen Checkoway, Ariel J. Feldman, Brian Kantor, J. Alex Halderman, Ed-
ward W. Felten, and Hovav Shacham. 2009. Can DREs Provide Long-lasting
Security? (cid:140)e Case of Return-oriented Programming and the AVC Advantage. In
Proceedings of the 2009 Conference on Electronic Voting Technology/Workshop on
Trustworthy Elections (EVT/WOTE’09). USENIX Association, Berkeley, CA, USA,
6–6.
[9] Vitaly Chipounov, Volodymyr Kuznetsov, and George Candea. 2012. (cid:140)e S2E
Platform: Design, Implementation, and Applications. ACM Trans. Comput. Syst.
30, 1, Article 2 (Feb. 2012), 49 pages. h(cid:138)ps://doi.org/10.1145/2110356.2110358
[10] Lucas Davi, Ahmad-Reza Sadeghi, Daniel Lehmann, and Fabian Monrose. 2014.
Stitching the Gadgets: On the Ine(cid:130)ectiveness of Coarse-grained Control-(cid:131)ow
Integrity Protection. In Proceedings of the 23rd USENIX Conference on Security