    -   更新处理时中途发生错误，导致数据库的不一致性
    -   用户填写完很多项目后点击确认按钮时因发生了内部错误而不得不全部重新填写
    -   程序在用户漏填邮箱地址的情况下依然执行发送邮件的处理
    像这样，不校验输入值会导致应用程序内部业务逻辑在中途发生错误，以及乍一看似乎很正常，但相关操作在后台其实根本没有被处理，或者没有被处理完等问题。
    而输入校验就是为了减少此类事故的发生。然而，输入校验说到底也只是对字符串的格式进行检查，格式以外的其他条件（如是否还有库存，账户余额是否充足等）则并不会得到检验。因此，输入校验并不能消灭所有的错误，但是通过尽早通知用户输入存在不妥并让其改正，可以使应用的易用性得到提高。
    综上，输入校验的目的可以被总结如下。
    -   尽早发现输入错误并提示用户重新输入，提高了易用性
    -   防止错误处理造成数据不一致等，提高了系统的可靠性
-   **输入校验与安全性**
    虽然输入校验的主要目的并不是安全性，但有时却也能对提高应用的安全性大有裨益。例如以下情况。
    -   在有些参数忘了防范 SQL
        注入攻击的情况下，因为输入检验时只允许字母和数字，所以就能避免损害
    -   在 PHP
        中使用了非二进制安全的函数（稍后讲述）的情况下，因为输入校验时过滤了控制字符，所以就能避免损害
    -   在页面显示处理函数中对字符编码的指定有所疏忽时，因为输入校验时检验了字符编码的有效性，所以就能避免损害
        [5]{.注释编号}
-   **二进制安全与空字节攻击**
    刚才出现了"二进制安全"这个用语。二进制安全是指，不管输入值是怎样的字节列都能将其原封不动地进行处理的功能，特别是当包含零值字节（NULL
    字节，PHP 中记为 \\0）时也能正确处理。
    空字节之所以特殊，是因为在 C 语言以及 Unix 与 Windows 的 API
    中规定空字节为字符串的结尾。因此，底层为 C 语言的 PHP
    以及其他脚本语言中，有些函数不能正确处理空字节。而这类函数就被称为不是二进制安全的函数。
    利用空字节的攻击手段被称为空字节攻击。空字节攻击本身并不造成伤害，而是通常被用于绕过其他安全隐患的防范策略。
    以下为没有进行空字节攻击防范的范例脚本。42-002.php 使用正则表达式
    `ereg` 检验变量 `$p` 的值中仅包含数字。
    > **代码清单 /42/42-002.php**
    ``` 代码无行号
    ```
    `$p`
    只包含数字的情况下，页面显示应该一切正常。接下来，我们来尝试用如下
    URL 来执行 42-002.php。
    ``` 代码无行号
    http://example.jp/42/42-002.php?p=1%00
    ```
    运行结果如图 4-5 所示。
    ![{%}](Image00047.jpg)
    **图 4-5 绕过 ereg 检验的安全隐患**
    浏览器中执行了 JavaScript
    代码，弹出"XSS"的对话框，这就是跨站脚本漏洞（XSS），具体内容将在 4.3
    节中详述，但在此也可以看出使用 `ereg` 的检验是能被绕过的。
    -   **ereg 检验被绕过的原因**
        `ereg` 检验被绕过的原因是 URL 中含有 %00。%00 就是空字节，由于
        `ereg`
        函数不是二进制安全的函数，因此，检验对象字符串中如果含有空字节，就会被视作字符串的结束（图
        4-6）。
        ![{%}](Image00048.jpg)
        **图 4-6 空字节攻击**
        由于 `…`
        以后的字符串被检验函数忽略，检验对象字符串变成了"1"，满足"仅限数字"的要求，因此便通过了检验。而
        JavaScript 得以被执行的原因也就是如此。
        前面已经说过，空字节攻击很少能独自造成损害，而是通常被用来在其他安全隐患防范策略的疏漏中见缝插针。而除了
        XSS 外，常与空字节攻击组合使用的还有目录遍历攻击（参考 4.10.1
        节）。
        虽然在应用中全部使用二进制安全的函数就能完全防御空字节攻击，但实际实现起来却颇为困难。因为很多情况下函数的参考文档中都没有明确记载该函数是否二进制安全。因此，行之有效的策略为，在应用程序的入口处使用二进制安全的函数检验输入值中是否有空字节，如果含有空字节就报错。
-   **仅校验输入值并不是安全性策略**
    至此，读者们或许会产生以下疑问：如果在输入阶段就将所有的非法输入值过滤掉，是不是就能确保应用的安全性了呢？而且在输入阶段就将安全隐患全部搞定的话，之后的工作也更轻松了呢。
    但遗憾的是这并不可行。因为输入阶段实施的校验并不能成为安全隐患的防范策略。输入校验是根据应用程序的软件规格而实施的操作。例如，假设规格书中规定允许输入任何字符，那么，在输入阶段就无法进行任何安全性防范措施。
    因此，输入校验的作用最多也就是为安全机制多加一层保障。
-   **输入校验的依据是应用程序的规格**
    输入校验时的基准是应用程序的规格。例如电话号码应该全部是数字、用户
    ID 应该是 8
    位的字母或数字等，各参数允许的字符种类以及长度都应根据应用的要求规格进行设置。
    -   **校验控制字符**
        刚才已经提到输入校验的基准是应用程序的规格，但为了在应用的规格中规定"允许输入任何字符"的情况下也能够进行验证，就需要校验控制字符。
        控制字符是指，换行符（CR 和 LF）和 Tab
        等通常不显示在页面上的、ASCII 编码中 0x20 以下以及
        0x7F（DELETE）的字符。前面讲到的空字节也是控制字符。由于 Web
        应用中的输入参数多为文本格式，所以应当限制控制字符的输入，然而也有一些
        Web 应用未对控制字符进行处理。
        单行的文本输入框（input 要素的 type 属性值为 text 或
        password）中，由于按常规的输入方法无法输入控制字符，因此多数情况下所有的控制字符都会遭到拒绝。textarea
        元素中能够输入换行和 Tab，但是否允许 Tab 则要由规格决定。
    -   **校验字符数**
        应用程序的规格文档中应当明确定义所有输入项目的最大字符数。如果是要保存到数据库的值，最大字符数理应与表字段的最大字符数一致。而即使有些输入项目没有物理上的上限值限制，为了保证程序的正常运行，也同样需要确定最大字符数。
        某些情况下，校验最大字符数能使应用的安全性更为稳固。由于攻击 Web
        应用有时需要用到很长的字符串，因此，假设限制字符串的最大长度为
        10 的话，那么就能使攻击者在发现 SQL
        注入隐患时也无法实施攻击。虽然我们不能对校验字符数的效果抱有过多期待，但也应该认识到校验字符数的必要性以及其对安全性的帮助。
-   **哪些参数需要校验**
    输入校验的对象为所有的参数。hidden 参数、单选框、select
    元素等也不例外。Cookie 中包含会话 ID 以外的值的情况下，Cookie
    值也是校验对象。此外，应用中用到了 Referer 等 HTTP
    消息头时也需要进行校验。
-   **PHP 的正则表达式库**
    利用正则表达式能够便利地实现输入校验。PHP 中可以利用的正则表达函数有
    `ereg` 、`preg` 、`mb_ereg3` 大类。其中，`ereg`
    由于不是二进制安全的，因此在 PHP5.3 及以后的版本中已被废弃，而改用了
    `preg` 或 `mb_ereg` 。`preg` 仅在字符编码为 UTF-8
    的情况下能正常处理中文字符，而 `mb_ereg` 则适用于大多数字符编码。
    通过在程序的开头使用 `preg` 或 `mb_ereg`
    进行包含空字节的控制字符校验，就能够同时进行应用规格中的字符种类校验和空字节校验。
    关于正则表达式的详情请参考 PHP
    的文档或说明手册。下面，我们通过具体例子来了解一下 PHP
    中输入校验时的注意点。
-   **使用正则表达式检验输入值的实例（1）1 ～ 5 个字符的字母数字**
    下面的代码展示了使用 `preg_match` 函数来校验"1-5
    个字符的字母数字"的范例。
    > **代码清单 /42/42-010.php**
        p 的值为 
    传递给 `preg_match` 的正则表达式可以按照图 4-7 这样进行解释。
    ![{%}](Image00049.jpg)
    **图 4-7 检验"1～5 个字符的字母数字"的正则表达式**
    其中，各部分的意思分别如下。
    -   **u 修饰符**
        在中文环境中使用 `preg_match`
        函数时，无论检验对象是否含有中文，都必须指定表示字符编码为 UTF-8
        的 `u` 修饰符。
    -   **i 修饰符**
        `i` 修饰符表示匹配时不区分大小写。
    -   **全体一致匹配时使用 \\A 和 \\z**
        `\A` 代表数据的开头，`\z` 代表数据的结尾。有时也会使用 `^` 和
        `$` 来代替 `\A` 和 `\z` ，但由于 `^` 和 `$`
        代表"行的"开头和结尾，`$`
        会匹配换行符，所以当它们被用于匹配数据的开头和结尾时就有可能产生
        Bug。
        图 4-8 的脚本中使用了 `^` 和 `$` 代替 `\A` 和 `\z`
        [6]{.注释编号} ，校验对象字符的结尾处为 `%0a` （LF
        换行）。能看到换行符绕过了校验。
        ![{%}](Image00050.jpg)
        **图 4-8 换行符绕过了校验**
    -   **字符集合**
        `[` 和 `]`
        围住的部分就是字符集合。在方括号内将允许的字符全部列举出来，或者使用
        `[0-9]` 这样的形式来指定范围。指定字母，可使用 `[a-zA-Z]`
        。指定字母与数字，可使用 `[a-zA-Z0-9]` 。而使用 `i`
        修饰符后，只需在大写文字与小写文字中任选其一即可。
    -   **数量修饰符**
        `{` 和 `}` 围住的部分就是数量修饰符。`{1,5}`
        的意思是字符数大于等于 1 且小于等于 5。允许为空（0
        字符）的情况下指定为 `{0,5}` 。
    -   **使用 mb_ereg**
        如果不用 `preg_match` 而改用 `mb_ereg`
        函数，就需要将脚本的开头部分作如下修改。
        > **代码清单 /42/42-012.php（选摘）**
        ``` 代码无行号
        ```
        `mb_regex_encoding` 函数的作用为指定 `mb_ereg`
        函数的字符编码。如果 php.ini
        已经设置了内部字符编码，此步骤可以省略。
        `mb_ereg` 与 `preg_match` 的不同之处有 3 点：`mb_ereg`
        的正则表达式不需要用 `/` 括起来；不使用 `u`
        修饰符；没找到匹配项时返回 false。另外，由于 `m b_ereg`
        的返回值为整数或布尔型，所以比较时应使用区分类型的 `===`
        运算符。
-   **使用正则表达式检验输入值的实例（2）住址栏**
    住址和姓名等的输入框多数情况下只限制字符的长度而不限制字符的种类。但是，即使不限制字符种类，也应当检查是否有控制字符混入，以防范空字节攻击。例如，下面脚本的正则表达式中就使用了
    POSIX 字符集合 [7]{.注释编号} `[[:^cntrl:]]`
    来表示"非控制字符的字符"。
    > **代码清单 /42/42-013.php**
    ``` 代码无行号
    <?php
      $addr = isset($_GET['addr']) ? $_GET['addr'] : '';
      if (preg_match('/\A[[:^cntrl:]]{1,30}\z/u', $addr) == 0) {
        die(' 请输入长度小于 30 个字符的地址（必填项）。不能使用换行或 Tab 等控制字符 ');
      }
    ```
    输入评论等使用的 textarea
    元素（多行输入文本框）中允许包含控制字符中的换行（有时也允许
    Tab），这种情况下可以使用如下正则表达式。下例的意思是，禁止除换行和