41
74
124
138
38
38
124
131
1164
Veriﬁed
Falsiﬁed
Unknown
Veriﬁed
Falsiﬁed
Unknown
Average
Time (s)
#
SMARTPULSE
#
#
KEVM-VER
#
#
89
35
125
10
123
4
62
74
42
101
75
69
106
20
123
6
39
101
38
103
105
19
114
13
556
1041
TABLE III: Large Scale Evaluation
2.9
2.7
2.6
4.1
4.4
4.3
3.5
2.8
19.0
8.6
4.6
3.3
5.2
7
7
7
7
8
7
7
7
11
9
8
7
92
37
1
3
64
80
47
17
3
83
84
18
9
446
25
25
25
25
29
29
28
25
29
29
28
28
325
the tool did not report a result (e.g., due to a time-out), and
(4) average time in seconds for those benchmarks that could
be solved (i.e., either veriﬁed or refuted).
The key take-away from this evaluation is that SMART-
PULSE is able to solve signiﬁcantly more benchmarks than
KEVM-VER (95% vs 82%), and it is able to solve them a lot
faster (5 vs 404 seconds). We conjecture that SMARTPULSE
is signiﬁcantly faster than KEVM-VER due to its use of lazy
abstraction as opposed to eager symbolic execution.
To ensure the correctness of these results, we also com-
pared the results produced by SMARTPULSE against those
of KEVM-VER. For the benchmarks solved by both tools,
SMARTPULSE and KEVM-VER produced the same results
except in two cases. Upon further inspection, we found these
two discrepancies to be caused by a bug in KEVM-VER
(speciﬁcally, a bug in the translation from EVM bytecode to
K), and we manually conﬁrmed that the result produced by
SMARTPULSE is indeed correct.
D. Evaluating SMARTPULSE on Vulnerable Contracts
One of the capabilities provided by SMARTPULSE is the
ability to generate attacks for vulnerable contracts. In this
section, we evaluate SMARTPULSE on a set of benchmarks
that contain vulnerability patterns described in prior work [11],
[17], [22], [23] and assess whether SMARTPULSE can generate
attacks for all of these vulnerable contracts. Since several of
these vulnerability patterns require non-trivial fallback imple-
mentations to perform the attack, we conduct this evaluation
using the powerful adversary model.
The results of this evaluation are shown in Table IV.
Here, the column labeled “Pattern” describes the vulnerability
patterns (e.g., re-entrancy, integer overﬂow) described in prior
work, and the column labeled “Property” shows an important
correctness property that is violated due to the presence of the
corresponding vulnerability pattern. As shown in Table IV,
SMARTPULSE is able to generate attacks for all of these
benchmarks, and the column labeled “Attack summary” shows
a summary of the attack in terms of relevant methods that
are invoked. We highlight some of the salient features of the
attacks generated by SMARTPULSE:
Counterexamples as attacks. The counterexamples generated
by SMARTPULSE provide a series of transactions along with
their argument values that, if executed, would violate the given
temporal property. Therefore, the counterexamples generated
by SMARTPULSE correspond to a full attack against
the
vulnerable contract (e.g., see Figure 15).
Synthesis of attacker’s fallback. As indicated by(cid:1)f the
notation in Table IV, about a third of the benchmarks require
synthesizing a fallback method for an adversarial contract. In
the process of generating a counterexample trace, SMART-
PULSE also synthesizes a concrete implementation of the
attacker’s fallback method.
Inﬁnite counterexample traces. Denial-of-service vulnerabil-
ities correspond to violations of liveness properties; hence, for
the DOS vulnerability patterns, SMARTPULSE generates an
attack in the form of an inﬁnite counterexample trace. For
instance, for revert DOS, the attack involves a loop of the
form (func(cid:1) transfer(cid:1)f revert)ω, indicating that all calls to
function func result in the attacker reverting that transaction.
Attacks for gas vulnerabilities. To the best of our knowledge,
SMARTPULSE is the ﬁrst tool that can generate attacks for
gas-related vulnerabilities. For instance, in the attack for the
“gas DOS” pattern, SMARTPULSE’s attack involves creating
enough bidders so that the contract runs out of gas when trying
to issue refunds.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:30:07 UTC from IEEE Xplore.  Restrictions apply. 
566
Pattern
Reentrancy
Unprotected Function
Integer Overﬂow
Integer Underﬂow
Gas DOS
Revert DOS
Push DOS
Unchecked Send
Locked Funds
Property
Users can’t withdraw more money than their credit
Users can’t withdraw unless they are the owner
A balance cannot decrease without withdrawing
A balance cannot be greater than the sum of deposits
Users who buy tokens are eventually refunded
Users can always eventually outbid another user
All non-winning bidders are eventually refunded
The contract tracks how much money each user stores
Funds cannot be transferred to unaccessible accounts
buy(cid:1) buy(cid:1) close(cid:1) (refund(cid:1) transfer(cid:1) transfer(cid:1) OOG)ω
bid(cid:1) bid(cid:1) bid(cid:1) close(cid:1) (refund(cid:1) transfer(cid:1)f revert)ω
TABLE IV: Evaluation for attack generation. Here(cid:1)f indicates a call from a fallback function and OOG stands for ”Out of Gas.”
bid(cid:1) (bid(cid:1) transfer(cid:1)f revert)ω
deposit(cid:1) withdraw(cid:1) send(cid:1) revert
deposit(cid:1) transfer
transfer
deposit(cid:1) deposit(cid:1) withdraw(cid:1) call(cid:1)f withdraw
Attack Summary
addOwner(cid:1) withdraw
deposit(cid:1) deposit
Among prior techniques, KEVM [15] and Lem [16] model
reverts by restoring the initial state of the reverting call or
transaction. On the other hand, VERISOL [35] and SOLC-
VERIFY [13] mark any paths that throw an exception as infea-
sible. Such modeling, however, is unsound in the presence of
low-level calls (e.g., send) since these methods do not revert
a transaction if one of their callees throws an exception. In
contrast to these approaches, our method instruments Solidity
programs with history variables to capture the. Our approach
is amenable to automated veriﬁcation since it explicitly marks
which paths modify the contract’s state and which revert.
D. Veriﬁcation using CEGAR
Our veriﬁcation algorithm is based on the counterexample-
guided abstraction reﬁnement paradigm [4], [5]. The general
idea is to perform veriﬁcation using a coarse abstraction
and then iteratively reﬁne it as spurious counterexamples are
encountered. Most CEGAR techniques generalize counterex-
amples by using Craig interpolation [14], [21], with the goal
of ruling out more than a single counterexample. However, in
general, CEGAR-based software model checkers do not have
termination guarantees, and our method inherits this limitation.
E. Checking Liveness Properties
A number of approaches have been proposed to verify live-
ness properties of inﬁnite-state systems. Several approaches
verify liveness by searching for a program path that violates
the LTL property [3], [6], [8], [33]. They do so by reducing
liveness veriﬁcation to fair termination, then search for a path
that does not fairly terminate using a combination of SMT
solvers and ranking function synthesizers. Our veriﬁcation
approach is based on the same framework proposed by Dietsch
et al. [8] but differs in two important ways: First, due to the
semantics of SMARTLTL, our product construction only needs
to consider external call/return sites as ﬁnal states. Second,
for non-termination checking, we use a simple but effective
technique that leverages the distinction between variables used
in the harness vs. those used in the transactions themselves.
In other words, rather than using expensive techniques for
computing recurrent sets [12], we can check non-termination
in a much simpler way. As we show in Appendix C, these
differences are very important for making liveness veriﬁcation
practical in this context.
XI. CONCLUSION AND FUTURE WORK
We have described SMARTPULSE, the ﬁrst tool for au-
temporal properties of smart
tomatically checking general
contracts,
including liveness. Given a formal SMARTLTL
speciﬁcation and an attacker model, SMARTPULSE ﬁrst per-
forms a sequence of program instrumentations to model the
contract’s execution environment and then uses a CEGAR-
based veriﬁcation approach to search for property violations.
We evaluate SMARTPULSE on a total of 1947 benchmarks and
X. RELATED WORK
A. Veriﬁcation of Smart Contracts
In recent years, there has been great interest in formally
verifying the correctness of smart contracts. For instance,
ZEUS [17], VERISOL [34], SOLC-VERIFY [13], and KEVM-
VER [26] allow users to specify correctness properties in terms
of method pre- and post-conditions and verify the program by
generating veriﬁcation conditions and discharging them with
an SMT solver. Since VERISOL and SOLC-VERIFY do not
automate invariant generation, they require users to manually
provide annotations. Zeus, on the other hand, can generate
invariants using a Constrained Horn Clause (CHC) solver,
and KEVM-VER translates EVM bytecode to KEVM and
leverages the K framework [29] for veriﬁcation. However, all
of the techniques are limited to safety and require the user to
write lower-level speciﬁcations compared to SMARTPULSE.
Among veriﬁcation techniques for smart contracts, our
method is most closely related to VERX [27], which performs
semi-automated veriﬁcation of temporal safety speciﬁcations
written in PastLTL. VERX performs a combination of sym-
bolic execution and predicate abstraction; furthermore, since
VERX extracts predicates automatically from the contract’s
source code, it is capable of automated veriﬁcation. However,
VERX does not perform abstraction reﬁnement; thus, the coun-
terexamples it produces can be spurious, and successful veri-
ﬁcation may require the user to supply additional predicates.
SMARTPULSE differs from VERX in that it is not limited to
safety and never produces spurious counterexamples.
The only prior work that addresses liveness properties of
smart contracts is by Sergey et al [31]. They express smart
contracts in an intermediate language called SCILLA [31] and
manually discharge proofs using the Coq proof assistant [7].
In contrast, our method is fully automated and can perform
falsiﬁcation as well as veriﬁcation.
B. Finding Bugs in Smart Contracts
There has also been signiﬁcant
interest
in characteriz-
ing and detecting vulnerability patterns in smart contracts.
For instance, the Oyente tool by Luu et al. uses symbolic
execution to check for various vulnerability patterns such
as reentrancy [19]. Similarly, MADMAX [11] uses dataﬂow
analysis to check for out-of-gas related vulnerabilities, and
Feist et al. [9] describe the Slither infrastructure for building
scalable static bug ﬁnding tools. In contrast to our method,
these tools cannot be used to verify functional correctness.
Furthermore, because patterns like re-entrancy do not always
lead to the violation of a correctness property, these approaches
can erroneously ﬂag safe contracts as being vulnerable.
C. Modeling Exceptions in Smart Contracts
One of the challenges we addressed is how to faithfully
model revert statements when reasoning about LTL properties.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:30:07 UTC from IEEE Xplore.  Restrictions apply. 
567
demonstrate that SMARTPULSE advances the state-of-the-art
in smart contract veriﬁcation.
There are several interesting avenues for future work. First,
we are interested in exploring new, more scalable algorithms
for ﬁnding non-terminating program traces. Second, we are
interested in proving the end-to-end soundness of our tool.
However, since Solidity does not have formal semantics,
the proof would need to be with respect to an intermediate
representation like YUL that does have formal semantics.
REFERENCES
[1] M. Abadi and L. Lamport. The existence of reﬁnement mappings.
Theoretical Computer Science, 82(2):253–284, 1991.
[2] M. Barnett, B. E. Chang, R. DeLine, B. Jacobs, and K. R. M. Leino.
Boogie: A modular reusable veriﬁer for object-oriented programs.
In
F. S. de Boer, M. M. Bonsangue, S. Graf, and W. P. de Roever,
editors, Formal Methods for Components and Objects, 4th International
Symposium, FMCO 2005, Amsterdam, The Netherlands, November 1-
4, 2005, Revised Lectures, volume 4111 of Lecture Notes in Computer
Science, pages 364–387. Springer, 2005.
[3] M. Brockschmidt, B. Cook, S. Ishtiaq, H. Khlaaf, and N. Piterman. T2:
In International Conference on Tools
temporal property veriﬁcation.
and Algorithms for the Construction and Analysis of Systems, pages
387–393. Springer, 2016.
[4] E. Clarke, O. Grumberg, S. Jha, Y. Lu, and H. Veith. Counterexample-
guided abstraction reﬁnement. In International Conference on Computer
Aided Veriﬁcation, pages 154–169. Springer, 2000.
[5] E. Clarke, O. Grumberg, S. Jha, Y. Lu, and H. Veith. Counterexample-
guided abstraction reﬁnement for symbolic model checking. Journal of
the ACM (JACM), 50(5):752–794, 2003.
[6] B. Cook, A. Gotsman, A. Podelski, A. Rybalchenko, and M. Y. Vardi.
Proving that programs eventually do something good. In M. Hofmann
and M. Felleisen, editors, Proceedings of the 34th ACM SIGPLAN-
SIGACT Symposium on Principles of Programming Languages, POPL
2007, Nice, France, January 17-19, 2007, pages 265–276. ACM, 2007.
[7] T. Coquand and G. P. Huet. The calculus of constructions. Inf. Comput.,
76(2/3):95–120, 1988.
[8] D. Dietsch, M. Heizmann, V. Langenfeld, and A. Podelski. Fairness
modulo theory: A new approach to ltl software model checking.
In
International Conference on Computer Aided Veriﬁcation, pages 49–66.
Springer, 2015.
[9] J. Feist, G. Greico, and A. Groce. Slither: A static analysis framework
for smart contracts. In Proceedings of the 2nd International Workshop
on Emerging Trends in Software Engineering for Blockchain, pages 8–
15. IEEE Press, 2019.
[13]
[10] P. Gastin and D. Oddoux. Fast ltl to b¨uchi automata translation.
In
International Conference on Computer Aided Veriﬁcation, pages 53–65.
Springer, 2001.
[11] N. Grech, M. Kong, A. Jurisevic, L. Brent, B. Scholz, and Y. Smarag-
dakis. Madmax: Surviving out-of-gas conditions in ethereum smart
the ACM on Programming Languages,
contracts.
2(OOPSLA):1–27, 2018.
Proceedings of
[12] A. Gupta, T. A. Henzinger, R. Majumdar, A. Rybalchenko, and R.-G.
Xu. Proving non-termination. SIGPLAN Not., 43(1):147–158, Jan. 2008.
´A. Hajdu and D. Jovanovic.
solc-verify: A modular veriﬁer for
solidity smart contracts.
In S. Chakraborty and J. A. Navas, editors,
Veriﬁed Software. Theories, Tools, and Experiments - 11th International