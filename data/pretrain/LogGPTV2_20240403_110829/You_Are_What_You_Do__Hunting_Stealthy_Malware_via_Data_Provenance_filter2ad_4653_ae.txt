in our experiment as a case study. The example is the “Dow-
nAuto Certutil Macro Dropper” malware, which is a part of
APT28 attack [20], [15]. The causality chain of this attack
is shown in Figure 7. This malware embeds its malicious
payload as a base64 string and exploits the certiﬁcate services
(certutil.exe) to convert the base64 string to an executable
(c029ec8b.exe). After that, the malware runs the payload,
which uses rundll32.exe to connect back to the adversary.
The analysis based on the one-hop relationships cannot
disclose the adversarial context, as every step in this attack
looks normal. It is possible for excel.exe to handle certiﬁ-
cates with certutil.exe . It is also normal behavior for
certutil.exe to create any arbitrary ﬁles. Note that in our
experiment environment, although the malicious executable
has a random name, in practice, this name could also be the
name of any benign software and may not contain the exten-
sion .exe. Finally, it is also impractical to prevent excel.exe
from executing external programs and rundll32.exe whose
execution logic depends on its command line given at runtime.
The abnormality of the operation arises only when all dots
are connected and considered as a whole. PROVDETECTOR
models the whole causality path altogether as a vector and
detects anomalous paths instead of anomalous steps. This is
why PROVDETECTOR outperforms simple approaches.
2) Whole Graph Modeling: To understand why the whole
graph is not a good feature for detecting stealthy malware as
well as why graph2vec does not perform well in §VI-B,
we perform a set of empirical measurements. We randomly
selected paths from the provenance graphs of processes that
were hijacked by stealthy attacks. We then feed these paths
into our anomaly detector to get their prediction. We found
that, on average, about 70% of randomly selected paths from
hijacked processes cannot be detected as malicious. In other
words, about 70% of the paths are not distinguishable from
benign paths. For a graph-level embedding method, which
summarizes the features of all paths to get an embedding, will
not be sensitive to a small number of abnormal paths.
To better understand the distribution of paths from hijacked
programs, we take the winword (MS Word) program as an
excel.execertutil.exec029ec8b.exeexcel.exec029ec8b.exerundll32.exex.x.x.xstartwritestartstartwriteexecute_bypoints are paths selected from benign provenance graphs and
the red points are paths selected from malicious provenance
graphs by PROVDETECTOR. The result in Figure 9 delivers
two ﬁndings. First,
the selected benign paths form multi-
ple clusters representing the diversity of custom workloads
of benign programs. Second, the selected (rare) paths from
malicious graphs are very different from other benign paths,
therefore they are easy to be separated in the embedding space.
This result conﬁrms our assumption that rare paths could
capture abnormal behavior of stealthy malware.
4) Robustness Against Mimicry Attacks: The adversary
may evade the detection of PROVDETECTOR by mimicking
“normal” behaviors of programs. It is important to know how
much effort does the adversary need to take to evade the
detection.
To answer this question, we introduce the editing distance
between malicious paths and benign paths. We deﬁne the edit-
ing distance between two causal paths as the minimum number
of actions needed to convert one path to another. The actions
include add, modify, and delete any node in a causal path3.
In our experiment, we measured the average editing distance
between malicious paths and benign paths4. The average value
is about ﬁve. In other words, to make a malicious path looks
benign, an adversary needs to mimic about ﬁve system objects.
This result suggests that PROVDETECTOR is more robust than
the single step detection approaches (e.g., blacklist approach)
since the adversary only needs to mimic the behavior of one
system object.
D. Runtime Performance
We measure the runtime overhead of PROVDETECTOR for
its training and detection stages.
Training Overhead
The runtime overhead in the training
stage for each monitored program mainly consists of (1) the
overhead for building provenance graphs and path selection,
(2) the overhead to build the doc2vec model, and (3) the
overhead to build the anomaly detection model. On average,
it takes seven seconds to build a provenance graph from the
database and select the top 20 paths. With the data of 30,000
paths, it takes about 94 seconds to train the doc2vec model
with the embedding vector size of 100 and epochs of 100. It
takes around 39 seconds to train the LOF novelty detection
model. Note that the training overhead for one program is
a one-time effort. We do not need to retrain either of the
doc2vec model or the LOF model unless we want to improve
the models with more training samples.
Detection Overhead
The runtime overhead in the detection
stage for a process instance mainly consists of (1) the overhead
for building provenance graphs and path selection, (2) the over-
head for embedding the selected paths, and (3) the prediction
overhead of the anomaly detection model. On average, it takes
ﬁve seconds to build the provenance graph and two seconds
to select the top 20 paths from the graph. It only takes one
millisecond (ms) to embed a path into a vector and 0.06 ms
3This concept is borrowed from computational linguistics.
4To eliminate the bias introduced by arbitrary ﬁle names, we consider all
ﬁles with the same type as one ﬁle; for network connection, we abstract all
IPs to ”*.*.*.*”.
Fig. 8: The t-SNE plot with the paths randomly selected from
benign and malicious provenance graphs of the winword pro-
gram. The blue points and red points represent paths selected
from benign provenance graphs and malicious provenance
graphs respectively.
Fig. 9: The t-SNE plot with the paths selected by our path
selection algorithm from benign and malicious provenance
graphs of the winword program. The blue points and red
points represent paths selected from benign provenance graphs
and malicious provenance graphs respectively.
example and visualize the distribution in Figure 8. To generate
Figure 8, we randomly select 20 paths from each provenance
graph of winword (both benign and malicious), embed them
with PROVDETECTOR, and plot the embedding vectors with
t-SNE [75]. We mark the paths selected from benign graphs in
blue and those from malicious graphs in red. In Figure 8, the
majority of paths selected from malicious graphs are mixed
with paths selected from benign graphs. This is because these
“malicious” paths are generated from the benign part of the
hijacked process. There is only a small group of paths that are
easily separable, which we marked in a black circle. Therefore,
graph-level embedding methods, such as graph2vec, which
learn features from all the paths, is less capable of detecting
stealthy malware as the features from “real” malicious paths
are overlapped with the “normal” paths.
3) Path Selection: To demonstrate why our path selection
technique can maintain the accuracy while reducing training
and detection workload, we again take the winword program
as an example. In Figure 9, we plot the embedding vectors
of paths selected by PROVDETECTOR with t-SNE. The blue
11
benignmaliciousfor the novelty detection model to make a prediction with the
vector. In total, the detection overhead for a process instance
is about seven seconds.
To estimate the practicality of PROVDETECTOR in an
enterprise, we count the number of process instances created
for the 23 evaluated programs from the data over three months
with 306 hosts. On average, each host creates about 22.7
instances of these programs, i.e., about one process for each
program. Suppose an enterprise which has 100 hosts and there
are 30 programs to monitor, it will take 5.7 hours per day
to check all the created instances in the enterprise. However,
note that our experiments were conducted on a single general
desktop with a single thread. The detection time can be reduced
by parallelizing PROVDETECTOR on multiple server machines.
VII. DISCUSSION AND LIMITATIONS
Ofﬂine Detection vs. Online Detection
In our current im-
plementation, PROVDETECTOR works as an ofﬂine detector,
where it scans the provenance database to detect stealthy
attacks. However, PROVDETECTOR can be implemented as a
real-time approach by using an in-memory provenance graph
database on each monitored host [59]. Then PROVDETECTOR
can model the path selection problem as an incremental K
longest paths problem on a dynamic graph, which is an
orthogonal problem and has existing solutions [61], [31]. We
leave the implementation details to our future work.
Applicability to Other Operating Systems
In this work, our
evaluation focuses on programs (e.g., MS Word) on Windows
systems as most of the stealthy malware we collected target
Windows. However, our approach is not limited to a certain
operating system like Windows since similar OS level prove-
nance data can be also collected from other operating systems
such as Linux [30]. Moreover, our approach does not rely on
any Windows speciﬁc feature.
More Complex Embedding or Learning Approaches
In this
work, PROVDETECTOR uses the doc2vec paragraph embed-
ding technique and a simple anomaly detection model LOF
for its detection purpose. As shown in §VI, the combination
of these two models have already achieved very good detection
performance. More complex machine learning techniques, such
as LSTM [58], Tree-structured LSTM [98], Graph Convolu-
tional Networks [64], and One-class Neural Networks [36],
[88] could possibly further improve the detection accuracy,
yet they may also introduce a higher cost.
Mimicry Attacks
An adversary may mimic behaviors of
benign programs to evade the detection of PROVDETECTOR.
In §VI-C4, we measured that, on average, an adversary needs
to add, modify, or delete about ﬁve different nodes in a causal
path to mimic the behavior of benign programs. Since a causal
path embeds the contextual causality among different system
entities (e.g., processes), we believe that it is much harder to
evade PROVDETECTOR than the approaches that focus only on
the behavior of one process. We will conduct more evaluation
and research on defending mimicry attacks in our future work.
Anti-analysis Malware A lot of today’s malware has anti-
analysis (e.g., anti-VM or anti-debug) capabilities. When the
malware detects that
is being run in a virtual machine
it
or under a debugger, it changes its behavior (usually either
less malicious behavior or termination). PROVDETECTOR,
unlike virtualization based solutions [66], [62], is designed
to run on bare metal machines and does not require isolated
environments. Similar to previous work [27], [26], [62], to
perform a large-scale analysis, we use sandbox environments to
automate the execution of malware samples in our evaluation.
It is possible that some anti-analysis malware changed their
behavior during our evaluation. However, 289 (26%) of the
malware samples in our evaluation are identiﬁed as anti-VM
by VirusTotal. For these samples, PROVDETECTOR should
still be able to detect them when they are running on bare
metal machines as their behaviors on bare metal should be
same or more malicious, which will be easily selected by
PROVDETECTOR’s path selection algorithm.
The Benign Dataset We collected our benign data from an
anonymous enterprise which was well guarded by security
professionals and continuously monitoring using up-to-date
security solutions. Although it does not guarantee that our
“benign” data is perfectly benign, we believe that the chance
of data pollution is low and will not invalidate our evaluation.
VIII. RELATED WORK
Malware
Stealthy Malware
is becoming increasingly
stealthy to evade detection. A popular trend in recent cyber-
attacks is to impersonate or abuse benign applications on the
victim host to achieve the attack goals. There are many imper-
sonation techniques. For example, DLL injection [47], portable
executable injection, and remote thread injection [1]. Recently
developed new techniques such as process hollowing [13],
AtomBombing [3] and shim-based DLL injection [2] have
also been applied in real-world malware. Fileless malware,
which follows the “living off the land” attack strategy, has
been actively studied by both industry [6] and academia [42].
While characterized by its avoidance of using ﬁles during an
attack, we believe that PROVDETECTOR will also be helpful
in detecting certain types of ﬁleless malware whose behavior
can be tracked by our kernel-level provenance tracing.
Malware Detection Malware detection has been an active
area of research in multiple platforms like Android, Windows,
and Linux. In traditional approaches, static analysis [95], [92],
[46] and dynamic analysis [24], [41], [34] have been used
to analyze and detect malware. Recently, machine learning
and deep learning approaches are leveraged as a new trend
in malware analysis and detection which greatly improve the
detection accuracy over traditional methods [108], [65], [54],
[53]. Shu et al. [96] proﬁle a program’s historical behavior
to detect stealthy control ﬂow violations (e.g., aberrant path
attack) based on function call logs gained by software in-
strumentation. Differently, PROVDETECTOR aims to detect a
malware-controlled program using more coarse-grained kernel-
provided audit logs. There are multiple proposals to detect
stealthy malware that uses impersonation techniques like code
injection. Bee master [27] prepares honeypot processes in an
analysis environment and detects injections into the processes.
Membrane [87] and Quincy [26] extract features from memory
information such as memory paging information and memory
dumps, and use supervised machine learning to detect code
injection. Tartarus [66] and API Chaser [62] use taint tracking
12
to identify code injection. However, these proposals either
target only certain types of attacks [27] (e.g., [27] cannot
detect process hollowing), relay on some OS features [87], or
need virtualization environments and have severe impact on
the system performance [62], [66]. Moreover, all of them have
a limitation for script-based attacks. In contrast, our approach
uses lightweight kernel-level provenance tracking and targets
the broad scope of impersonation techniques including script-
based attacks.
Anomaly Detection with Host Level System Events
Several
approaches have been proposed to detect intrusion or abnormal
behaviors using system event data on the end hosts [35], [83],
[43], [39], [56]. Caselli el al. [35] proposed an approach which
ﬁrst builds the proﬁle of k-grams from benign system call
traces and then it throws an alert if a new system call trace is
signiﬁcantly different from the normal proﬁle. Padmanabhan
et al. [83] modeled the information ﬂow in a system using
directed graphs and extracts abnormal substructures from it.
Dong et al. [43] proposed a system to ﬁnd abnormal event
sequences from a large number of heterogeneous event traces.
Chen et al. [39] proposed a principled and uniﬁed probabilistic
model to learn the likelihood of system events. Siddiqui et
al. [97] developed a system to detect malicious system entities
using a multi-view based technique.
Unstructured Data Embeddings Multiple embedding tech-
niques (i.e., learning distributed representations or numerical
vectors of data) have been proposed for unstructured data
such as texts and graphs. In the natural language processing
domain, different embedding techniques have been proposed
for words [77], [32], sentences [84] and documents [69].
Learning techniques have also been proposed for graphs [79]
as well. These embedding techniques are utilized in mul-
tiple security applications for data modeling. For example,
Narayanan et al. [79] demonstrated the ability of graph2vec
in classifying malicious and benign Android apps using API
dependency graphs. Mimura et al. [78] used paragraph vectors
to detect unseen malicious trafﬁc from proxy log. Tavabi et
al. [99] proposed a neural language modeling approach that
learns embeddings of darkweb/deepweb discussions to predict
whether vulnerabilities are exploited. In this work, we utilize
paragraph embedding techniques over system provenance data
to detect stealthy malware. PROVDETECTOR would beneﬁt
from the future improvement of embedding techniques.
Mimicry Attacks on Host-based Solutions
System call traces
have long been used as the information source for host-based
instruction detection systems (IDS). The seminal research on
mimicry attacks [102], [48] demonstrated that the IDS can
be evaded by carefully crafting an exploit that produces a
legitimate sequence of system calls while performing mali-