title:Privilege Separation in HTML5 Applications
author:Devdatta Akhawe and
Prateek Saxena and
Dawn Song
Privilege Separation in HTML5 Applications
Devdatta Akhawe, Prateek Saxena, Dawn Song
{devdatta,prateeks,dawnsong}@cs.berkeley.edu
University of California, Berkeley
Abstract
The standard approach for privilege separation in
web applications is to execute application components
in different web origins. This limits the practicality of
privilege separation since each web origin has ﬁnan-
cial and administrative cost.
In this paper, we pro-
pose a new design for achieving effective privilege sep-
aration in HTML5 applications that shows how appli-
cations can cheaply create arbitrary number of com-
ponents. Our approach utilizes standardized abstrac-
tions already implemented in modern browsers. We do
not advocate any changes to the underlying browser or
require learning new high-level languages, which con-
trasts prior approaches. We empirically show that we
can retroﬁt our design to real-world HTML5 applica-
tions (browser extensions and rich client-side applica-
tions) and achieve reduction of 6x to 10000x in TCB for
our case studies. Our mechanism requires less than 13
lines of application-speciﬁc code changes and consider-
ably improves auditability.
1
Applications written with JavaScript, HTML5 and CSS
constructs (called HTML5 applications) are becoming
ubiquitous. Rich web applications and web browser ex-
tensions are examples of HTML5 applications that al-
ready enjoy massive popularity [1, 2]. The introduc-
tion of browser operating systems [3, 4], and support for
HTML5 applications in classic operating systems [5, 6]
herald the convergence of web and desktop applica-
tions. However, web vulnerabilities are still pervasive in
emerging web applications and browser extensions [7],
despite immense prior research on detection and mitiga-
tion techniques [8–12].
Introduction
Privilege separation is an established security prim-
itive for providing an important second line of de-
fense [13]. Commodity OSes enable privilege separated
applications via isolation mechanisms such as LXC [14],
seccomp [15], SysTrace [16]. Traditional applications
have utilized these for increased assurance and secu-
rity. Some well-known examples include OpenSSH [17],
QMail [18] and Google Chrome [19]. In contrast, privi-
lege separation in web applications is harder and comes
at a cost. If an HTML5 application wishes to separate
its functionality into multiple isolated components, the
same-origin policy (SOP) mandates that each component
execute in a separate web origin.1 Owning and main-
taining multiple web origins has signiﬁcant practical ad-
ministrative overheads. 2 As a result, in practice, the
number of origins available to a single web application
is limited. Web applications cannot use the same-origin
policy to isolate every new component they add into the
application. At best, web applications can only utilize
sub-domains for isolating components, which does not
provide proper isolation, due to special powers granted
to sub-domains in the cookie and document.domain be-
haviors.
Recent research [12, 20] and modern HTML5 plat-
forms, such as the Google Chrome extension platform
(also used for “packaged web applications”), have recog-
nized the need for better privilege separation in HTML5
applications. These systems advocate re-architecting the
underlying browser or OS platform to force HTML5 ap-
plications to be divided into a ﬁxed number of compo-
nents. For instance, the Google Chrome extension frame-
work requires that extensions have three components,
each of which executes with different privileges [19].
Similarly, recent research proposes to partition HTML5
applications in “N privilege rings”, similar to the isola-
tion primitives supported by x86 processors [12]. We
observe two problems with these approaches. First, the
ﬁxed limit on the number of partitions or components
creates an artiﬁcial and unnecessary limitation. Differ-
1Browsers isolate applications based on their origins. An origin is
deﬁned as the tuple . In recent browser exten-
sion platforms, such as in Google Chrome, each extension is assigned
a unique public key as its web origin. These origins are assigned and
ﬁxed at the registration time.
2To create new origins, the application needs to either create new
DNS domains or run services at ports different from port 80 and 443.
New domains cost money, need to be registered with DNS servers and
are long-lived. Creating new ports for web services does not work: ﬁrst,
network ﬁrewalls block atypical ports and Internet Explorer doesn’t
include the port in determining an application’s origin
1
ent applications require differing number of components,
and a “one-size-ﬁts-all” approach does not work. We
show that, as a result, HTML5 applications in such plat-
forms have large amounts of code running with unneces-
sary privileges, which increases the impact from attacks
like cross-site scripting. Second, browser re-design has
a built-in deployment and adoption cost and it takes sig-
niﬁcant time before applications can enjoy the beneﬁts
of privilege separation.
In this paper, we rethink how to achieve privilege sepa-
ration in HTML5 applications. In particular, we propose
a solution that does not require any platform changes
and is orthogonal to privilege separation architectures en-
forced by the underlying browsers. Our proposal uti-
lizes standardized primitives available in today’s web
browsers, requires no additional web domains and im-
proves the auditability of HTML5 applications. In our
proposal, HTML5 applications can create an arbitrary
number of “unprivileged components.” Each compo-
nent executes in its own temporary origin isolated from
the rest of the components by the SOP. For any priv-
ileged call, the unprivileged components communicate
with a “privileged” (parent) component, which executes
in the main (permanent) origin of the web application.
The privileged code is small and we ensure its integrity
by enforcing key security invariants, which we deﬁne in
Section 3. The privileged code mediates all access to
the critical resources granted to the web application by
the underlying browser platform, and it enforces a ﬁne-
grained policy on all accesses that can be easily audited.
Our proposal achieves the same security beneﬁts in en-
suring application integrity as enjoyed by desktop appli-
cations with process isolation and sandboxing primitives
available in commodity OSes [14–16].
We show that our approach is practical for exist-
ing HTML5 applications. We retroﬁt two widely used
Google Chrome extensions and a popular HTML5 appli-
cation for SQL database administration to use our design.
In our case studies, we show that the amount of trusted
code running with full privileges reduces by a factor of
6 to 10000. Our architecture does not sacriﬁce any per-
formance as compared to alternative approaches that re-
design the underlying web browser. Finally, our migra-
tion of existing applications requires minimal changes to
code. For example, in porting our case studies to this
new design we changed no more than 13 lines of code
in any application. Developers do not need to learn new
languages or type safety primitives to migrate code to
our architecture, in contrast to recent proposals [21]. We
also demonstrate strong data conﬁnement policies. To
encourage adoption, we have released our core infras-
tructure code as well as the case studies (where permit-
ted) and made it all freely available online [22]. We are
currently collaborating with the Google Chrome team to
apply this approach to secure Chrome applications, and
our design has inﬂuenced the security architecture of up-
coming Chrome applications.
In our architecture, HTML5 applications can de-
ﬁne more expressive policies than supported by exist-
ing HTML5 platforms, namely the Chrome extension
platform [19] and the Windows 8 Metro platform [5].
Google Chrome and Windows 8 rely on applications
declaring install-time permissions that end users can
check [23]. Multiple studies have found permission sys-
tems to be inadequate: the bulk of popular applications
run with powerful permissions [24, 25] and users rarely
check install-time permissions [26]. In our architecture,
policy code is explicit and clearly separated, can take
into account runtime ordering of privileged accesses, and
can be more ﬁne-grained. This design enables expert au-
ditors, such as maintainers of software application gal-
leries, to reason about the security of applications. In our
case studies, these policies are typically a small amount
of static JavaScript code, which is easily auditable.
2 Problem and Approach Overview
Traditional HTML applications execute with the author-
ity of their “web origin” (protocol, port, and domain).
The browser’s same origin policy (SOP) isolates differ-
ent web origins from one another and from the ﬁle sys-
tem. However, applications rarely rely on domains for
isolation, due to the costs associated with creating new
domains or origins.
In more recent application platforms, such as the
Google Chrome extension platform [23], Chrome pack-
aged web application store [1] and Windows 8 Metro ap-
plications [5], applications can execute with enhanced
privileges.
These privileges, such as access to the
geo-location, are provided by the underlying platform
through privileged APIs. Applications utilizing these
privileged API explicitly declare their permissions to use
privileged APIs at install time via manifest ﬁles. These
applications are authored using the standard HTML5 fea-
tures and web languages (like JavaScript) that web ap-
plications use; we use the term HTML5 applications to
collectively refer to web applications and the aforemen-
tioned class of emerging applications.
Install-time manifests are a step towards better secu-
rity. However, these platforms still limit the number of
application components to a ﬁnite few and rely on sep-
arate origins to isolate them. For example, each Google
Chrome extension has three components. One compo-
nent executes in the origin of web sites that the exten-
sion interacts with. A second component executes with
the extension’s permanent origin (a unique public key as-
signed to it at creation time). The third component exe-
cutes in an all-powerful origin having the authority of the
web browser. In this section, we show how this limits the
2
Issues with the Current Architecture
degree of privilege separation for HTML5 applications in
practice.
2.1
In this section, we point out two artifacts of today’s
HTML5 applications: bundling of privileges and TCB
inﬂation. We observe that these issues are rooted in the
fact that, in these designs, the ability to create new web
origins (or security principals) is severely restricted.
Common vulnerabilities (like XSS and mixed content)
today actually translate to powerful gains for attackers
in current architectures. Recent ﬁndings corroborate the
need for better privilege separation—for instance, 27 out
of 100 Google Chrome extensions (including the top 50)
recently studied have been shown to have exploitable
vulnerabilities [7]. These attacks grant powerful privi-
leges like code execution in all HTTP and HTTPS web
sites and access to the user’s browsing history.
As a running example, we introduce a hypothetical ex-
tension for Google Chrome called ScreenCap. Screen-
Cap is an extension for capturing screenshots that also in-
cludes a rudimentary image editor to annotate and mod-
ify the image before sending to the cloud or saving to a
disk.
Bundling. The ScreenCap extension consists of two
functionally disjoint components: a screenshot capturing
component and an image editor. In the current architec-
ture, both the components run in the same principal (ori-
gin), despite requiring disjoint privileges. We call this
phenomenon bundling. The screenshot component re-
quires the tabs and  permission, while the
image editor only requires the pictureLibrary permis-
sion to save captured images to the user’s picture library
on the cloud.
(cid:91)
Bundling causes over-privileged components. For ex-
ample, the image editor component runs with the power-
ful tabs and  permission. In general, if an
application’s components require privilege sets α1, α2...,
all components of the application run with the privileges
αi, leading to over-privileging. As we show in Sec-
tion 5.4, 19 out of the Top 20 extensions for the Google
Chrome platform exhibit bundling. As discussed earlier,
this problem manifests on the web too.
TCB inﬂation. Privileges in HTML5 are ambient—all
code in a principal runs with full privileges of the princi-
pal. In reality, only a small application core needs access
to these privileges and rest of the application does not
need to be in the trusted computing base (TCB). For ex-
ample, the image editor in ScreenCap consists of a num-
ber of complex and large UI and image manipulation li-
braries. All this JavaScript code runs with the ambient
privilege to write to the user’s picture library. Note that
this is in addition to it running bundled with the privi-
3
Figure 1: CDF of percentage of functions in an extension that
make privileged calls (X axis) vs. the fraction of extensions
studied (in percentage) (Y axis). The lines for 50% and 20% of
extensions as well as for 5% and 20% of functions are marked.
leges of the screenshot component.
We measured the TCB inﬂation for the top 50 Chrome
extensions. Figure 1 shows the percentage of total func-
tions in an extension requiring privileges as a fraction of
the total number of static functions. In half the exten-
sions studied, less than 5% of the functions actually need
any privileges.
In 80% of the extensions studied, less
than 20% of the functions require any privileges.
Summary.
It is clear from our data that HTML5 ap-
plications, like Chrome extensions, do not sufﬁciently
isolate their sub-components. The same-origin policy
equates web origins and security principals, and web ori-
gins are ﬁxed at creation time or tied to the web do-
main of the application. All code from a given provider
runs under a single principal, which forces privileges
to be ambient. Allowing applications to cheaply create
as many security principals as necessary and to conﬁne
them with ﬁne-grained, ﬂexible policies can make privi-
lege separation more practical.
Ideally, we would like to isolate the image editor com-
ponent from the screenshot component, and give each
component exactly the privileges it needs. Moving the
complex UI and image manipulation code to an unprivi-
leged component can tremendously aid audit and anal-
ysis. Our ﬁrst case study (Section 5.1) discusses un-
bundling and TCB reduction on a real world screenshot
application. We achieved a 58x TCB reduction.
2.2 Problem Statement
Our goal is to design a new architecture for privilege sep-
aration that side steps the problem of scarce web origins
and enables the following properties:
Reduced TCB. Given the pervasive nature of code in-
jection vulnerabilities, we are interested, instead, in
reducing the TCB.
 0 10 20 30 40 50 60 70 80 90 100 0 5 10 15 20 25 30 35 40 45 50Number of Extensions (Percentage)Percentage of Functions requiring privilegesEase of Audit. Dynamic code inclusion and use of com-
plex JS constructs is pervasive. An architecture that
eases audits, in spite of these issues, is necessary.
Flexible policies. Current manifest mechanisms pro-
vide insufﬁcient contextual data for meaningful se-
curity policies. A separate ﬂexible policy mecha-
nism can ease audits and analysis.
Reduce Over-privileging. Bundling of disjoint applica-
tions in the same origin results in over-privileging.
We want an architecture that can isolate applications
agnostic of origin.
Ease of Use. For ease of adoption, we also aim for min-
imal compatibility costs for developers. Mecha-
nisms that would involve writing applications for a
new platform are outside scope.
Scope. We focus on the threat of vulnerabilities in be-
nign HTML5 application. We aim to enable a privilege
separation architecture that benign applications can uti-
lize with ease to provide a strong second line of defense.
We consider malicious applications as out of scope, but
our design improves auditability and may be applicable
to HTML5 malware in the future.
This paper strictly focuses on mechanisms for achiev-
ing privilege separation and on mechanisms for expres-
sive policy-based conﬁnement. Facilitating policy devel-
opment and checking if policies are reasonable is an im-
portant issue, but beyond the scope of this paper.
3 Design
We describe our privilege separation architecture in this
section. We describe the key security invariants we main-
tain in Section 3.2 and the mechanisms we use for en-