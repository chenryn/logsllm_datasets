# 【技术分享】CVE-2016-4656：苹果Pegasus漏洞技术分析详解
|
##### 译文声明
本文是翻译文章，文章来源：turingh.github.io
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
**作者：mrh**
**0x00 摘要**
[Pegasus – 针对iOS设备的APT攻击分析- PanguTeam](http://blog.pangu.io/pegasus-apt/)
[iOS“远程越狱”间谍软件Pegasus技术分析](http://www.freebuf.com/articles/terminal/113128.html)
关心IOS安全的技术人员最近一定都关注了这一次的安全事件，不需要多做描述了，想了解具体细节的可以自行google。
本文内容
  * 了漏洞所在的函数OSUnserializeBinary，了解其二进制格式
  * 理解POC，分析POC执行的流程
  * 
具体的技术背景，可以参考下面这篇文章
[PEGASUS iOS Kernel Vulnerability
Explained](https://sektioneins.de/en/blog/16-09-02-pegasus-ios-kernel-vulnerability-explained.html)
[PEGASUS iOS Kernel Vulnerability Explained – Part
2](https://sektioneins.de/en/blog/16-09-05-pegasus-ios-kernel-vulnerability-explained-part-2.html)
[iOS三叉戟漏洞补丁分析、利用代码 公布（POC）](http://bobao.360.cn/learning/detail/2996.html)
#
**0x01 OSUnserializeBinary**
在软件开发的流程中，在两个模块进行通信时，都会遇到使用序列化和反序列化传递一些数据结构，或者内部数据，比较典型的就是google的protobuf。
在XNU内核之中，自己实现了一套C++的子集，为IOKIT的开发提供支持，其中就提供了一套自己的序列化与反序列化的逻辑。
这次出现问题的OSUnserializeBinary便是这一个模块中的一个函数。
**1.1 OSUnserializeBinary**
下面是对源码的简单分析。
    OSObject *
    OSUnserializeBinary(const char *buffer, size_t bufferSize, OSString **errorString)
    {
    /*
    ...初始化变量
    */
    if (errorString) *errorString = 0;
    /*
    #define kOSSerializeBinarySignature "323"
    */
      // 等待反序列化的二进制数据存在一定的格式
    // 检测是否是是具有签名的内存数据
    if (0 != strcmp(kOSSerializeBinarySignature, buffer)) return (NULL);
    if (3 & ((uintptr_t) buffer)) return (NULL);
    // 检测buffersize的大小要小于kOSSerializeBinarySignature的大小
    if (bufferSize > 2; //计算要用几个word
    end = (0 != (kOSSerializeEndCollecton & key));
            DEBG("key 0x%08x: 0x%04x, %dn", key, len, end);
            newCollect = isRef = false;
    o = 0; newDict = 0; newArray = 0; newSet = 0;
    //根据key的不同对不同的数据结构做操作
    switch (kOSSerializeTypeMask & key)
    {
        case kOSSerializeDictionary:
    o = newDict = OSDictionary::withCapacity(len);
    newCollect = (len != 0);
            break;
        case kOSSerializeArray:
    o = newArray = OSArray::withCapacity(len);
    newCollect = (len != 0);
            break;
      /*
      ...
      */
        default:
            break;
    }
    //退出循环
    if (!(ok = (o != 0))) break;
    //如果反序列化的结果不是一个reference
    //就将结果存放到objsArray之中
    if (!isRef)
    {
    setAtIndex(objs, objsIdx, o);
    //如果ok的值为false，则退出反序列化循环
    //#define kalloc_container(size)
    //kalloc_tag_bt(size, VM_KERN_MEMORY_LIBKERN)
    /*
    typeof(objsArray) nbuf = (typeof(objsArray)) kalloc_container(ncap * sizeof(o));
    if (!nbuf) ok = false;
    */
    //在内核中申请ncap*sizeof（o）大小的内存，如果申请失败的了则ok设为false
    if (!ok) {
    break;
    }
    objsIdx++;
    }
    //对解析出来的o进行不同的操作
    if (dict)
    {
    /*...*/
    }
    else if (array) 
    {
    /*...*/
    }
    else if (set)
    {
       /*...*/
    }
    else
    {
        /*...*/
    }
    if (!ok) break;
          //解析的流程中出现了一些新的容器
    if (newCollect)
    {
    if (!end)
    {
    stackIdx++;
    setAtIndex(stack, stackIdx, parent);
    if (!ok) break;
    }
    DEBG("++stack[%d] %pn", stackIdx, parent);
    parent = o;
    dict   = newDict;
    array  = newArray;
    set    = newSet;
    end    = false;
    }
          //解析结束
    if (end)
    {
    if (!stackIdx) break;
    parent = stackArray[stackIdx];
    DEBG("--stack[%d] %pn", stackIdx, parent);
    stackIdx--;
    set   = 0; 
    dict  = 0; 
    array = 0;
    if (!(dict = OSDynamicCast(OSDictionary, parent)))
    {
    if (!(array = OSDynamicCast(OSArray, parent))) ok = (0 != (set = OSDynamicCast(OSSet, parent)));
    }
    }
    }
    DEBG("ret %pn", result);
    if (objsCapacity)  kfree(objsArray,  objsCapacity  * sizeof(*objsArray));
    if (stackCapacity) kfree(stackArray, stackCapacity * sizeof(*stackArray));
    if (!ok && result)
    {
    result->release();
    result = 0;
    }
    return (result);
    }
**1.2 setAtIndex**
    #define setAtIndex(v, idx, o)
    if (idx >= v##Capacity)
    {
    uint32_t ncap = v##Capacity + 64;
    typeof(v##Array) nbuf = (typeof(v##Array)) kalloc_container(ncap * sizeof(o));
    if (!nbuf) ok = false;
    if (v##Array)
    {
    bcopy(v##Array, nbuf, v##Capacity * sizeof(o));
    kfree(v##Array, v##Capacity * sizeof(o));
    }
    v##Array    = nbuf;
    v##Capacity = ncap;
    }
    if (ok) v##Array[idx] = o;
这一段宏用在代码中大意如下
    if (idx>v##capacity)
    {
      /* 扩充数组*/
    }
    if (ok) 
    {
      v##Array[idx]=o
    }
大意就是讲数据o放置到数组中的idx处，如果数组不够大了就扩充一下数组的大小。
**1.3 源码分析**
该函数的大致流程与我们通常遇到的反序列化函数形式基本相同，分为以下几步
检测二进制文件格式，是否符合要求
依次读取二进制数据，进行分析，并且将解析的结果存放到对应的数据结构之中
**1.3.1 二进制文件格式**
    // 检测是否是是具有签名的内存数据
    if (0 != strcmp(kOSSerializeBinarySignature, buffer)) return (NULL);
    if (3 & ((uintptr_t) buffer)) return (NULL);
    // 检测buffersize的大小要小于kOSSerializeBinarySignature的大小
    if (bufferSize > 2; //计算要用几个word
       end = (0 != (kOSSerializeEndCollecton & key)) //获取end的值;
       /*...*/
    //根据key的不同对不同的数据结构做操作
    switch (kOSSerializeTypeMask & key)
            {
              /*....*/
            }
**1.3.2 数据存放**
解析之后得到的数据，会被存放到对应的数据结构之中去。
            //如果反序列化的结果不是一个reference
    //就将结果存放到objsCapacity之中
    //如果反序列化自后内存申请失败,则退出反序列化
    if (!isRef)
    {
    setAtIndex(objs, objsIdx, o);
    //如果ok的值为false，则退出反序列化循环
    //#define kalloc_container(size)
    kalloc_tag_bt(size, VM_KERN_MEMORY_LIBKERN)
    /*
    typeof(objsArray) nbuf = (typeof(objsArray)) kalloc_container(ncap * sizeof(o));
    if (!nbuf) ok = false;
    */
    //在内核中申请ncap*sizeof（o）大小的内存，如果申请失败的了则ok设为false
    if (!ok) {
    break;
    }
    objsIdx++;
    }
    //如果存在一个解析出来的dict
    if (dict)
    {
    if (sym)
    {
    DEBG("%s = %sn", sym->getCStringNoCopy(), o->getMetaClass()->getClassName());
    if (o != dict) 
    {
    ok = dict->setObject(sym, o);
    }
    o->release();
    sym->release();
    sym = 0;
    }