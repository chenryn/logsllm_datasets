(
e
m
T
i
 160
 140
 120
 100
 80
 60
 40
 20
 0
65536 DB size
131072 DB size
262144 DB size
524288 DB size
 128 256
 512
 1024
 2048
Item Data Size (bits)
Figure 6: Single ORAM lookup times for diﬀerent
database sizes and item data lengths.
5.2 Discussion
Memory Constraints.
Memory is the primary limitation on scaling the computa-
tion to larger values of N . For the linear scan, the problem
stems from the size of the circuit description, which is more
than 23 gigabytes and 850 million wires, if N = 219 and
the data elements are 512 bits. The pipe-lining technique
of Huang et al. [10] prevents the parties from storing all 23
gigabytes in RAM, but the client still stores an 80 bit secret
key for every wire in the circuit, and the server stores two;
this requires 8.5 gigabytes of memory for the client and 17
gigabytes for server. This ends up requiring far more space
than the data itself, which is only 512N = 33 megabytes.
In contrast, when N = 219 and the data size is 512, the
largest circuit in our protocol is less than 50 megabytes, and
contains about 1million wires. On the other hand, each level
of the data storage has a factor of 4 log N overhead (when
our bucket size is 2 log N ), so server storage for the top level
alone is more than 40000N = 2.5 gigabytes. This explains
why we eventually ran into trouble when pre-processing the
data; to broaden the scale of what we can handle, we will
need to improve the way we handle memory while inserting
elements into the ORAM structure.
Pre-processing.
We have not done any calculations regarding the time re-
quired for secure pre-processing. As explained above, when
running our experiments, we populated the ORAM structure
by randomly placing items in the trees. This is of course in-
secure, since the server will know where all the items are
in the ORAM: to ensure security, the insertion of the data
would have to be interactive. One naive way to ensure se-
curity is to insert each item, one at a time, by performing
the “write” protocol inside a secure computation, precisely
as we have described an ORAM lookup.
If we start this
process with a data structure large enough to hold all items,
we can estimate the time it will take to insert 216 elements
of 512 bits each, by multiplying the 13 seconds we require
for a write operation by 216. It seems this would take al-
most 20 days to compute! We leave the problem of ﬁnding
a more eﬃcient method for data insertion to future work.
One natural approach would be to start with smaller struc-
tures, repeatedly doubling their size in some secure manner
as insertion progresses. We stress that the pre-processing
we do in our work is fully secure in a three-party model,
where the database owner pre-processes his data, and then
transfers the encrypted data to a semi-honest third party,
who performs the secure computation on his behalf.
The Recursion Parameter.
In all of our experiments, we have chosen r = 16; that is,
every item in tree i > 1 stores the leaf nodes of 16 items from
tree i − 1. This is a parameter that we could change, and it
may have an impact on performance. However, one parame-
ter we did investigate is the choice of how far to recurse. As
can be seen in Table 1, the best performance occurs when
the bottom level, which requires a linear scan, holds fewer
than 212 items. Interestingly, beyond that, further recursion
does not seem to make a diﬀerence. The ith tree
DB size
2 trees
3 trees
4 trees
5 trees
220
219
218
35
20
12.5
14
11.5
9.5
12.5
12.5
9.5
13
-
-
Table 1: Time in seconds of a single ORAM ac-
cess, with various numbers of recursion levels in the
ORAM structure. The number of items in the bot-
tom level is 2N−4i+4 when there are i trees.
Counting Gates.
Let N be the number of elements, let d be the length
of each element, and let B denote the bucket size of each
node. We calculate the number of non-XOR gates in the
garbled circuits of our ORAM operation, and provide some
relevant observations. We ﬁrst consider the top level tree
that contains the database items. During a lookup we need
to check log N nodes along the path to the leaf associated
with the searched item. Each of these nodes contains B
elements of size log N +d: a virtual address of size log N and
a data element of size d. We use approximately 1 non-XOR
gates for each of these. Therefore, a single lookup consists
of B log N (log N + d) non-free gates. In the eviction process
that follows, we scan 2 log N nodes for eviction, and write to
both children of each node (one write is dummy). Thus, the
eviction circuits require 6B log N (log N + d) non-free gates,
which gives us a total of 7B log N (log N + d) non-free gates
for each ORAM operation in the top level tree. The analysis
at the lower level trees is similar, but asymptotically, this
dominates the computation, since the lower level trees have
only N/16i elements. We provide concrete numbers in Table
2, taken directly from our circuits. We considere B = 2 log N
and d=512. We note that our circuits grow linearly in the
size of each bucket. Also interesting is that it grows linearly
in d. Since the Yao linear scan is also linear in the data size,
with dN gates, we see that varying the length of the data
element will have little impact on our comparison.
6. USING OTHER ORAM SCHEMES
In our concrete protocol we instantiated (and then opti-
mized) our generic construction using the tree-based ORAM
scheme of [19]. However, there are several other oblivious
5227. CONCLUSION
In this work we showed eﬃcient protocols for secure two
party computation achieving only a small polylogarithmic
overhead over the running time of the insecure version of
the same functionality. This is a signiﬁcant asymptotic im-
provement over traditional generic secure computation tech-
niques, which inherently impose computation overhead at
least linear in the input size. Our protocols rely on any (ar-
bitrary) underlying oblivious RAM and generic two party
computation protocols. We further investigate the most eﬃ-
cient instantiation of the protocol and demonstrated, empir-
ically, the expected theoretical improvement. In particular,
we implemented a protocol that performs a single access to
a databases of size 218 elements, outperforming an imple-
mentation of basic secure computation by a factor of 60.
This translates also to a three-fold improvement in the run-
ning time of binary search.
In addition to these concrete
improvements, our work sheds light on many of the details
faced when implementing ORAM and secure computation.
Acknowledgments
This work was supported in part by NSF and DARPA.
DB size XOR gates Non-free gates Wires
220
219
218
217
216
19,159,883
16,519,818
14,219,281
12,185,264
10,377,527
3,730,546
3,166,420
2,700,966
2,302,208
1,954,042
44,039,222
37,656,448
30,941,947
27,366,108
23,655,368
Table 2: Gate and wires counts for diﬀerent size
databases with item data of length 512
RAM schemes which we considered as possible instantia-
tions for our ORAM component. We discovered that these
schemes would entail higher complexity in the context of
a two party computation protocol4 since they involve more
complicated building blocks such as pseudorandom shuﬄing
protocol and Cuckoo hashing.
For example, the ORAM protocol of Goldreich and Os-
trovsky [7] introduced the basic hierarchical structure that
underlies many subsequent ORAM protocols. This approach
crucially relies on two components that turn out to be quite
ineﬃcient when evaluated with a secure two-party compu-
tation: (1) the use of a pseudorandom function (PRF) in
order to consistently generate a random mapping from vir-
tual addresses to physical addresses; and (2) a joint shuﬄing
procedure for mixing the diﬀerent levels in the ORAM data
structure. We direct the reader to [7] for the full details of
the scheme.
Several more-recent ORAM solutions [18, 8, 9, 13] rely
on cuckoo hashing (in addition to also using PRF computa-
tions). For their security, a new construction for a cuckoo
hash table is needed [8], which involves building the corre-
sponding cuckoo graph and conducting breadth-ﬁrst search
on the graph in order to allocate each new item inserted
into the cuckoo table. Compiling this step into a secure
two-party computation protocol seems likely to introduce a
prohibitive performance hit.
4Note that a better performing ORAM protocol does not
necessarily translate to a better performing protocol when
put through a generic secure computation.
5238. REFERENCES
[1] D. Beaver. Precomputing oblivious transfer. In
Advances in Cryptology — Crypto ’95, volume 963 of
LNCS, pages 97–109. Springer, 1995.
[2] S.G. Choi, J. Katz, R. Kumaresan, and H.-S. Zhou.
On the security of the free-XOR technique. In 9th
Theorey of Cryptography Conference — TCC 2012,
volume 7194 of LNCS, pages 39–53. Springer, 2012.
[3] I. Damg˚ard, S. Meldgaard, and J. B. Nielsen. Perfectly
secure oblivious RAM without random oracles. In 8th
Theory of Cryptography Conference — TCC 2011,
volume 6597 of LNCS, pages 144–163. Springer, 2011.
[4] S. Even, O. Goldreich, and A. Lempel. A randomized
protocol for signing contracts. Comm. ACM,
28(6):637–647, 1985.
[5] O. Goldreich. Foundations of Cryptography. Volume I:
Basic Tools. Cambridge University Press, 2001.
[6] O. Goldreich, S. Micali, and A. Wigderson. How to
play any mental game, or a completeness theorem for
protocols with honest majority. In 19th Annual ACM
Symposium on Theory of Computing (STOC), pages
218–229. ACM Press, 1987.
[7] O. Goldreich and R. Ostrovsky. Software protection
and simulation on oblivious RAMs. J. ACM,
43(3):431–473, 1996.
[8] M. T. Goodrich and M. Mitzenmacher.
Privacy-preserving access of outsourced data via
oblivious RAM simulation. In 38th Intl. Colloquium
on Automata, Languages, and Programming (ICALP),
Part II, volume 6756 of LNCS, pages 576–587.
Springer, 2011.
[9] M. T. Goodrich, M. Mitzenmacher, O. Ohrimenko,
and R. Tamassia. Privacy-preserving group data
access via stateless oblivious RAM simulation. In 22nd
Annual ACM-SIAM Symposium on Discrete
Algorithms (SODA), pages 157–167. ACM-SIAM,
2011.
[10] Y. Huang, D. Evans, J. Katz, and L. Malka. Faster
secure two-party computation using garbled circuits.
In 20th USENIX Security Symposium, 2011.
[11] Y. Ishai, J. Kilian, K. Nissim, and E. Petrank.
Extending oblivious transfers eﬃciently. In Advances
in Cryptology — Crypto 2003, volume 2729 of LNCS,
pages 145–161. Springer, 2003.
[12] V. Kolesnikov and T. Schneider. Improved garbled
circuit: Free XOR gates and applications. In 35th Intl.
Colloquium on Automata, Languages, and
Programming (ICALP), Part II, volume 5126 of
LNCS, pages 486–498. Springer, 2008.
[13] E. Kushilevitz, S. Lu, and R. Ostrovsky. On the
(in)security of hash-based oblivious RAM and a new
balancing scheme. In 23rd Annual ACM-SIAM
Symposium on Discrete Algorithms (SODA), pages
143–156. ACM-SIAM, 2012.
[14] Y. Lindell and B. Pinkas. A proof of security of Yao’s
protocol for two-party computation. Journal of
Cryptology, 22(2):161–188, 2009.
[15] L. Malka and J. Katz. VMCrypt — modular software
architecture for scalable secure computation. Available
at http://eprint.iacr.org/2010/584.
[16] M. Naor and B. Pinkas. Eﬃcient oblivious transfer
protocols. In 12th Annual ACM-SIAM Symposium on
Discrete Algorithms (SODA), pages 448–457.
ACM-SIAM, 2001.
[17] R. Ostrovsky and V. Shoup. Private information
storage. In 29th Annual ACM Symposium on Theory
of Computing (STOC), pages 294–303. ACM Press,
May 1997.
[18] B. Pinkas and T. Reinman. Oblivious RAM revisited.
In Advances in Cryptology — Crypto 2010, volume
6223 of LNCS, pages 502–519. Springer, 2010.
[19] E. Shi, T.-H. H. Chan, E. Stefanov, and M. Li.
Oblivious RAM with o((log n)3) worst-case cost. In
Advances in Cryptology — Asiacrypt 2011, volume
7073 of LNCS, pages 197–214. Springer, 2011.
[20] E. Stefanov, E. Shi, and D. Song. Towards practical
oblivious RAM. In NDSS. The Internet Society, 2012.
[21] P. Williams and R. Sion. Usable PIR. In NDSS. The
Internet Society, 2008.
[22] P. Williams, R. Sion, and B. Carbunar. Building
castles out of mud: practical access pattern privacy
and correctness on untrusted storage. In 15th ACM
Conf. on Computer and Communications
Security (CCS), pages 139–148. ACM Press, 2008.
[23] A. C.-C. Yao. How to generate and exchange secrets.
In 27th Annual Symposium on Foundations of
Computer Science (FOCS), pages 162–167. IEEE,
1986.
524