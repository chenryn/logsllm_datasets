愿世间所有漏洞与你环环
相扣 安全
- SecPulse.COM |
脉搏
“ 这是 酒仙桥六号部队 的第 101 篇⽂章。
这是 酒仙桥六号部队 的第 101 篇⽂章。
全⽂共计 2677 个字，预计阅读时⻓ 9 分钟。
翩翩烛夜游，漏洞列表瞅⼀瞅
在前段时间的 HW ⾏动中流传着⼀张红队可利⽤漏洞列
表，其中存在关于某堡垒机的 RCE 漏洞⽐较感兴趣，正
好最近也有空，想来审计审计这个漏洞。
要说这个漏洞，其实也是⼀个古⽼的洞了，CNVD 编号
CNVD-2019-*，虽然是 19 年爆出来的漏洞，但是抱着
试⼀试的⼼态搜了⼀下，成功利⽤漏洞打了两个⼩朋友。
嗯！！！洞是个⽼洞了，但是盖不住管理员不修复啊。
乘着⻛破着浪，⿊暗⾥呀⾛⼀趟
既然想做⼀次代码审计，那没有源码怎么⾏呢？于是⼜⼀
次发起⽩嫖技能，在群⾥找⼤佬要了⼀份堡垒机的源代
码，然后没想到的是这个源代码可不好拿，曲曲折折的就
有了这篇⽂章。
拿到⼤佬给的源代码之后⾮常⾼兴的打开验验货，然后⽴
⻢傻眼了 ···
看着满屏的乱码，直觉告诉我这个玩意被加密了。之前对
某 OA 系统进⾏代码审计时便⻅识到利⽤ zend ⽅法进⾏
加密的 PHP ⽂件，通常这类加密⽂件会在密⽂的最前⾯
标识⾃⼰的加密⽅式，例如 zend 加密的 PHP ⽂件会在
最前⾯显示 “zend” 字样的字符串。
然后再看上⾯的密⽂，可以得到⽂件的加密特征
“PM9SREW”，当不是 zend 的时候就感觉不太好了，是
⼀种之前并不熟悉的加密⽅式 所以需要某度的法⼒加
种之前并不熟悉的加密⽅式，所以需要某度的法⼒加
持，看⼀下这到底是⼀种什么样的加密规则。
根据搜集到的信息判断，这种 PHP 代码加密的技术就叫
PHP_Screw，这种加密技术与 zend 加密不同的是引⼊
了密钥，⽽且可以对特征标识进⾏⾃定义的修改。⽽由于
引⼊了密钥，不能像 zend 加密那样直接使⽤⼯具进⾏解
密，⾸先需要获取到加密使⽤的密钥，然后要⾃⾏编写解
密脚本。
莺 ** ⻓，密钥在来的路上
对于任意⼀个加密后的 PHP 脚本，在被脚本解释器解释
之前肯定是要被解密的，zend 加密⽅式便是如此，那么
同理这个 PHP_Screw 加密也是如此，那它究竟是如何
对脚本进⾏解密然后传递给脚本解释器的呢？秉持着知来
处明去处的精神，我去了解了⼀下使⽤ PHP_Screw 加
密后脚本的部署⽅式。
在部署的第 5 步，需要将⼀个 php_screw_plus.so 的扩
展写⼊ php 的配置⽂件，直觉告诉我这个扩展是⽤来进
⾏解密的。也就是说每⼀个部署了这个 PHP_Screw 加
密后的脚本服务器肯定会存在⼀个类似的 PHP 扩展⽤于
解密，那么我们之前打到的⼏个⼩朋友的⼝袋⾥肯定也是
存在这个扩展的，嗯。。。。我有⼀个⼤胆的想法。
给之前其中⼀个⼩朋友穿个⻢甲，然后去上⾯慢慢找这个
扩展组件。
⾸先找⼀找⼩朋友的配置⽂件，确认⼀下这个组件的名
字。先确定⼀下 PHP 配置⽂件的路径。
果断打开瞅⼀眼，确定扩展的名字是：php_screw.so
使⽤ find 全局搜索⼀下，但是啥都没搜到，这不得⾏
啊。想了想还是开个 phpinfo，查看 php 的扩展组件存
放路径。
然后就是柳暗花明⼜ 村 成功找到这个扩展组件 ⻢上
然后就是柳暗花明⼜⼀村，成功找到这个扩展组件，⻢上
给他下载下来。
有了这个扩展，将 so 拖到 ida ⾥进⾏分析，分析⼀下解
密算法和使⽤的密钥。在之前了解 PHP_Screw 算法的
时候了解到整个解密的关键函数是
_p**screw_ext_fopen，将函数反编译成类 C 代码，如
下：
在代码的第 25 ⾏可以看到解密的⽅式是使⽤
p**screw_mycryptkey 数组⾥的数据进⾏⼀系列处理之
后和明⽂按位取反后的值进⾏异或。上⾯这个
p**screw_mycryptkey ⾥存放的应该就是解密代码使⽤
的 key，为了安全打上厚厚的⻢赛克。
上⾯的代码是 16 进制，在我们进⾏解密的时候需要转换
成 10 进制。为了解密不出问题，还需要将⼩朋友⼝袋⾥
的代码给掏出来，⽤来给我们进⾏审计分析。结合上⾯的
解密算法，使⽤密钥解密整个⼯程⽂件，解密后的效果如
下。
⻛⾬兼程，审计⻢不停蹄
⾸先还是来看我们既定的审计⽬标。前台 RCE 漏洞，⽬
标⽂件为：/ha_request.php。先给张图看看代码先。
在进⾏代码审计之前个⼈⽐较喜欢看⼀下参数获取的⽅
式，这样⽅便判断参数的获取过程是否经过安全处理，以
及参数处理过程中是否会存在安全问题等等。在整个
ha_request.php ⽂件当中没有获取参数的地⽅，那么获
取参数的地⽅应该在 / include/comm.php ⽂件中，跟
进这个⽂件去看⼀眼。
在第 98 ⾏可以看到此处通过 $_REQUEST 的形式获取
参数，然后将参数的键值分别进⾏简单的处理之后重新赋
值，其中参数值通过正则表达式进⾏了简单的过滤，但是
匹配的只是简单的特殊符号，并不算严格。
然后我们回到 ha_request.php ⽂件本身，关注点落在存
在命令执⾏的⼏处地⽅：
在第 37 ⾏中使⽤了 exec 进⾏系统命令执⾏，⽽执⾏的
系统命令中存在两个变量 $url 和 $filename，其中
$filename 是⼀个固定字符串，⽽ $url 变量是通过变量
拼接⽽获取的。然后我们再看 $url 中的两个变量是通过
⽤户输⼊的，还是⾃定义的，中间是否经过变量处理，就
可以判断 $url 变量是否可以由⽤户⾃主控制，从⽽造成
命令执⾏。
从上⾯的代码可以看出 $req_node_id 和 $req_ipaddr
两个变量应该是⽤户输⼊的，中间没有经过任何变量处
理。同时根据代码逻辑，我们需要使变量 $req_action
为 “install”，$res 为 “OK”，才能进⼊第 37 ⾏进⾏命
令执⾏。其中 $req_action 为⽤户输⼊的变量，可控，
⽽ $res 为函数 node_request 函数的返回值，如果返回
值不为”OK”, 就进⼊函数 fatal()。
这两个函数都位于 comm.php，fatal 函数是⼀个⾃定义
的 exit 函数，⽤于退出程序。
函数 node_request 的代码如下：
根据上⾯的代码，该函数的作⽤应该是打开某个链接，读
取⾥⾯的内容，然后返回。⽽整个链接是来源于⽤户输
⼊，那么我们可以⾃⼰搭建⼀个 VPS，让 node_request
去请求 VPS 然后返回 OK 作为请求结果，这样就可以绕
过 fatal 函数进⼊命令执⾏函数。根据之前的传参，应该
构造的⼀个 http://IP/listener/cluster_manage.php 的
VPS ⻚⾯，⾥⾯的内容是 OK。
简单做个测试，构造 VPS 内容如下：
创建⼀个测试代码如下：
访问测试代码，当返回 success 说明 $res 的值确实为
“OK”，可以绕过判断。
通过上⾯的分析，已经可以构造 payload 执⾏到命令执
⾏的位置，⽽可控的变量 $url 中第⼀个变量需要输⼊
VPS 的地址，所以我们执⾏的系统命令需要放⼊
$req_node_id 中，再来看⼀下命令执⾏的代码，然后开
始构造 payload。
要进⾏命令执⾏，⾸先还是需要让 $url 是⼀个完整的
url，使 wget 命令结束，然后采⽤特殊符合执⾏其他命
令，根据上⾯的分析⾃⼰构造⼀个测试环境。
因为审计是在 windows 环境，所以简单的修改⼀下执⾏
的命令，然后构造 payload 如下情况：
http://IP/test.php?
action=install&ipaddr=127.0.0.1&node_id=1|whoami||ec
ho，测试结果如下，成功执⾏了系统命令。
ho，测试结果如下，成功执⾏了系统命令。
当然在 linux 环境下 wget 命令可以执⾏，然后可以通过
其他的⽅式写⼊⼀个 webshell 或者反弹⼀个 shell。
此刻已皓⽉当空，爱的⼈⼿捧漏洞
从最开始的知道漏洞，到成功利⽤漏洞打到⼩朋友；再通
过获取系统源码，分析⽂件的加密算法；通过分析
PHP_Screw 算法知道需要获取到解密密钥，编写解密算
法；再通过给⼩朋友穿⻢甲，翻⼩朋友的⼝袋获取到解密
密钥，算法，源码，最后进⾏漏洞的审计分析，知道漏洞
触发的原理，这⼀路⾛来并不算顺利，在掏⼝袋获取密钥
时找了很久的⽂件最终才找到，然后进⾏算法逆向的过程
中因为⽤了⽐较⽼的 ida 和系统，导致反汇编的类 C 代
码有很⼤区别，⽽且看不懂，⼜折腾了好久。还好最后的
代码分析并不算很难，所以这⼜是⼀个进步啊，以后要多
多加油啦！
本⽂作者： 酒仙桥六号部队
本⽂为安全脉搏专栏作者发布，转载请注明：
https://www secpulse com/archives/145353 html
https://www.secpulse.com/archives/145353.html
全⽂完
本⽂由 简悦 SimpRead 优化，⽤以提升阅读体验
使⽤了 全新的简悦词法分析引擎 beta，点击查看详细说明