count++; 
tail = (tail + l) % buffer.length;
buffer!tail] = cake;
catch (InterruptedException e) ↑
while (true)
wait();
约每隔 1 秒就执行 clear 的清扫人员，ClearThread 类(ClearTnread.java)
"hread.sleep(l0o0);
(head + 1) % buffer.length;
table.clear();
 System.out.println ("=
一
=- " + getName() + " clears ==-==");
Table table)
！
练习问题的解答
385
---
## Page 400
386
EaterThreai-l takes 
MakerThread-l puts 
EaterThread-l takes
MakerThread-3 puts [ Cake No.104 by MakerThread-3 ]
=====ClearThread-O clears ==.
Eaterrhread-2 takes
EaterThread-2 takes
EaterThread-3
MakerThread-3
MakerThread-2
EaterThread-I
MakerThread-l
MakerThread-2
EaterThread-3
Clearrhread-0 clears [ Cake No.98 by MakerThread-3
-====ClearThread-0 clears ===-- 
EaterThread-2 takes [ Cake No.97 by MakerThread-2
MakerThread-3 puts [ Cake No.98 by MakerThread-3
EaterThread-l takes [ Cake No.96 by MakerThreaa-1
MakerThread-2 puts [ Cake No.97 by Makerrhread-2 i
EaterThread-l takes
（前略）
public class Main [
List A5-4
 publie static vcid mair(string[] args) 
lnew
new MakerThread("MakerThread-1", table, 3l415)-start () ;
Table table = new Table(3);
new
new
new
new
new
2 puts [ Cake No.1c2 by MakerThread-2
2 puts [ Cake No.l03 by MakerThread-2
ClearThread("clearThread-0",
EaterThread("EaterThread-3",
I puts 【 Cake No.lol by MakerThread-l
EaterThreadt"EaterThread-2",
EaterThread("EaterThread-l",
MakerThread("MakerThread-3",
MakerThread("MakerThread-2", table,
厨师、客人与清扫人员的Main类(Mainjava)
takes
 puts !
takes [ Cake No.i00 by MakerThread-2
takes [ Cake No.99 by MakerThread-3
[ Cake No.105 by MakerThread-l
[ Cake No.105 by MakerThread-1
[ Cake No.104 by MakerThtead-3
I Cake No.l3 by MakerThreai-3
[ Cake No.l01 b
Cake No.103 by MakerThread-3
Cake No.102
Cake No.95 by MakerThread-3
一在这里虽然想将桌子清掉，
一在这里将桌子清掉(之前放了蛋糕No.98）
by
by MakerThread-1
 MakerThread-2
！/建立一个能放三个蛋糕的桌子
table).start();
table,
table，
table,
table:
62643).start();
.92653).start();
32384).start()
58979).start()
、但是桌上没有放蛋糕
---
## Page 401
方法。
问题5-6的解答
如 List A5-5所示。这样会在使用 slecp 停顿约10秒后，对各个线程调用 interrupt
（按CTRL+C结束）
MakerThread-l takes
MakerThread-l puts [ Cake No.il4 by MakerThread-1
EaterThread-3
EaterThread-l
MakerThread-3
MakerThread-3
ClearThread-0
ClearThread-0
ClearThread-0 Clears [ Cake No.l09 by MakerThread-2
==--ClearThreａd-O cleaｒs 
MakerThread-2 puts { Cake No.1ll by MakerThread-2
EaterThread-2
MakerThread-2
MakerThread-2 puts [ Cake No.1o9 by MakerThread-2
EaterThread-3 takes [ Cake No.107 by MakerThread-3
MakerThread-l puts [ Cake No.l08 by MakerThread-l 
EaterThread-2 takes [ Cake No.106 by MakerThread-3
public class Main ↑ 
List A5-5
110,111)
 public static void main(string[l args) {
！！启动线程
Thread[] threads = {
Table table = new Table(3);
new MakerThread("MakerThread-1",
new
new
new
new
在约 10 秒后结束线程的 Main 类(Main.java)
 takes [ Cake No.l13 by MakerThread-3
puts [ Cake No.ll3 by MakerThread-3
 puts ［
takes [ Cake No.108 by MakerThread-1
 puts [ Cake No.ll0 by MakerThread-2
takes [ Cake No.ll2 by MakerThread-3
Clears
Clears 
EaterThread("EaterThread-3",
EaterThread("EaterThread-2",
EaterThread("EaterThread-1",
MakerThread("MakerThread-3",
MakerThread("MakerThread-2",
: Cake No.-l4 by MakerThread-l 
Cake No.ll2 by MakerThread-3
[ Cake No.lll by MakerThread-2
[ Cake No.ll0 by MakerThread-2
图A5-2执行范例
十在这里将粟子清掉（之前放有蛋糕No.109，
11建立一个只能放三个蛋糕的桌子
table,
table;
table,
table;
 table.
table,
38327),
626431,
32384),
589791
926531,
314151.
练习问题的解答
（续上图）
---
## Page 402
388
InterruptedException.
行范例请看图A5-3。只有确认以 Thread.interrupted 检查interrupted 状态的时机，才
InterruptedException。由于正在执行 Thread.interrupted，线程会变成非 interrupt 状态。
在可以删除的地方加上
问题5-7的解答
List A5-6中的程序会开始执行100次大型的处理，并在大约15秒后取消。执
我们加上 throws 这段，让 execute 方法可以抛出异常 InteruptedException，并
public class Main f
这样一来，现在正在执行操作的线程如果是interrupt 状态，就会被抛出
List A5-6
if (Thread.interrupted()) l
 publie static void main(String[] args) ↑
throw new InterruptedException();
Thread executor = new Thread() {
//执行HoSt的大型处理的线程
for (int i = O; i  System.currentTimeMillis()) {
long start = System.currentTimeMillisi):
System.out.println ("doHeavyJob BEGIN") ;
11（进行约10秒的循环）
/1以下为
for(int i =O; i < count; i++)f
i
executor.interrupt();
/执行取消
try{
/1休息约15秒
executor.start();
二
// busy loop
catch 
“不可取消的大型处理”的代用
Thread.sleep(l5000);
启动
doHeavyJob (l ;
if (Thread.interrupted()) f
大型处理(Host.java)
throw new Interruptedexception():
System.out.println("Host.execute END");
(InterruptedException e)
)catch (InterruptedException e)
é.printStackTrace();
Host.execute(100);
练习问题的解答
附鼎人
389
---
## Page 404
类中，如果我们使用的是 notifyAll 而非 notify方法的话，即使其中参杂了LazyThread
的线程，程序也不会停止而会继续执行操作。
就会如A5-3的执行范例（图5-4）一样，程序执行到一半会停下来。
么都不做的线程。List A5-9的 Main 类内混进LazyThread 的线程并予以执行的话，
问题5-8的解答
这是由于为了调用LazyThread，而随便滥用 notify 方法的调用的原因。Table
notify 方法只会从在waitset 中等待的线程中调用一个。因此，无关的线程进入
public class LazyThread extends Thread
List A5-8 的 LazyThread 类虽然在 Table 的实例上进行 wait，但是实际上却是什
在下面介绍的程序就可以证明这一点。
Host.execute END
doHeavyJob END
***** itezrupt *****
doHeavryJob BEGIN
doHeavryJob END
doHeavyJob END
Host.execute BEGIN
List A5-8
public void run()
public LazyThread(String name, Table tabie) {
private final Table table;
at Mainsl.run(Main.java:8)
at,Host.execute(Host.java:5)
while (true)
this.table  table;
super(name);
try f 
什么都不做的线程(LazyThread.java)
 synchronized (table) !
table.wait();
图A5-3执行范例
←execute执行结束
十在第二次执行之后约10秒即结束执行
←在此主线程执行interrupt
+开始执行第二次大型处理doHeavyJob
+在执行第一次之后约10秒即结束执行
t开始执行第--次大型处理doHeavyJob
←开始执行éxecuté
---
## Page 405
public class Main f
List A5-9
MakerThread-2 puts [ Cake No.28 by MakerThread-2
public static void main(stringil args) l
(按 CTRL+C 结束)
MakerThread-3
MakerThread-2
LazyThread-2 is notified!
LazyThread-l is nctified!
EaterThread-3 takes [ Cake No.2e MakerThread-2 ]
LazyThread-7 is notified!
MakerThread-2 puts [ Cake No.26 by MakerThread-2 ]
Lazyrhread-6 is notified!
LazyThread-5 is notified!
（前略）
Meu
new
tew
new MakerThread("MakerThread-i", table, 3l415).start()
Tabletable=rewTable(3)；!/建立-个只能放3个蛋糕的桌子
hew
new
héw
lew
lew
lew
new
new
léw
LazyThread("Lazyrhread-7",
LazyThread ("lazyTt.read-6",
LazyThread("LazyThread-5",
LazyThread("IazyThreaa-4",
将什么都不做的线程也混进来，移动厨师与客人的Main类(Mainjava)
azyThread("LazyThread-3",
LazyThread("LazyThread-2"
LazyThread("LazyThread-:",
EaterThread ("EaterThread-3",
EaterThread
EaterThread
MakerThread("MakerThread-3",
MakerThread I"MakerThread-2".
catch (InterruptedException e) 
 System.out.println(getName() + " is notified!");
puts
puts
("EaterThread-2",
("EaterThread-l'
阁A5-4执行范例
Cakel
Cake No.29 b
No.30 by MakerThread-3
by MakerThread-2
一在进行到一半时会停下来
tabze).start();
table).start();
table).start()
table).start()
table).start()
table).start(l;
table).start(l;
table, 38327)-start();
table,
 table.
table.
table,
62643).start()
92653).start();
32384).start ();
58979).start();
练习问题的解答
---
## Page 406
问题6-1的解答
A5-5所示。
notifyAll.
lock的实例。由于没有从外部获得这个实例的方法，因此没有办法notify或
变成无限长的休息时间（Time Out)，因此用if语句将0的状况排除在外。
参数所指定的时间。
问题5-9的解答
第6章
List A5-10 中介绍的程序会使用 Something.method 休息约3秒。执行结果如图
此外，为了wait 不会被 notify或 notifyAll 给打断，我们在方法中建立取得
以参数0 调用 sleep时，会暂时停止0毫秒，而以参数0 调用出wait后，又会
×（2）doRead方法不会同时被数个线程来执行。
〇（1）doWrite方法不会同时被数个线程来执行。