### Support for Instance Transformation

The XSL document generated by JXML2OWL can be utilized by any XSLT processor to automatically transform instances of the mapped schema into instances of the ontology. The choice of XSLT is particularly fitting, given that in our approach, OWL is specified using XML syntax.

It is important to note that XML is just one of several possible syntaxes for representing OWL ontologies. Other increasingly popular data representations include Notation3 (N3), Turtle, and JSON. These are all non-XML serializations of RDF graphs. N3 was designed to be more compact and readable than XML/RDF. Turtle, a subset of N3, offers a more compact and readable alternative. JSON, similar to Turtle, has the advantage of being represented in a language that is easier to parse. Regardless of the chosen representation for the organizational internal ontology-based model, XSLT can always be used to perform the transformation of external XML-based documents into internal ontologies.

As illustrated in Figure 6, the JXML2OWL API provides access to the Mapper component, and the XSLT processor is used by the Instance Generator module.

### Structure of Heterogeneous Mappings

This section outlines the structure for specifying mappings between XML and OWL. Several types of mappings are supported: one-to-one, one-to-many, many-to-one, and many-to-many. This notation allows for mappings from one XML node to multiple OWL concepts and from multiple XML nodes to one OWL concept. Additionally, this section highlights various aspects that must be considered when writing an algorithm to perform instance transformations according to the created mappings.

#### Notation for Mappings

The notation for specifying mappings between elements of an XML schema and resources defined by an OWL ontology is detailed in Table 1.

**Table 1: Heterogeneous Mapping Notation**

| **Mapping Type** | **Notation** |
|------------------|--------------|
| Class            | (OWL Class URI, XPath expression) <br> (OWL Class URI, XPath expression, ID XPath expression) |
| Datatype Property | (OWL Datatype Property URI, domain class mapping, XPath expression) |
| Object Property  | (OWL Object Property URI, domain class mapping, range class mapping) |

Just as with OWL ontologies, which are primarily defined by classes, datatype properties, and object properties, heterogeneous mappings are classified into three distinct types:

- **Class Mapping**: Maps an XML node to an OWL concept.
- **Datatype Property Mapping**: Maps an XML node to an OWL datatype property.
- **Object Property Mapping**: Relates two class mappings to an OWL object property.

OWL resources (classes, object properties, and datatype properties) are addressed using their URI references, while XPath expressions are used to address the mapped XML nodes. The use of XPath expressions allows for distinguishing between several XML nodes with the same name but different ancestors, enabling precise mapping to their corresponding OWL concepts. XPath predicates can also be used to enable conditional mappings.

### Example Mappings

An examination of Table 1 reveals that class mappings are defined by pairs containing the URI reference of the mapped OWL class and an XPath expression identifying the mapped XML nodes. This means that an instance of the mapped OWL class is created for each XML node matching the XPath expression. Alternatively, class mappings can be created with triplets where the XML node used to compute the IDs of the generated instances is directly specified. Table 1 also shows that property mappings are specified with triplets, and class mappings are used to define property mappings, enabling comprehensive support for property mappings in the context of many-to-many mappings.

The following example demonstrates how class, datatype, and object property mappings are created. Consider the OWL purchase order ontology from Hiltrix Corp. (Listing 3) and the cXML purchase order transaction (Listing 4).

Eleven mappings were established. Using the notation from Table 1, we have selected the following six representative mappings:

- **cm1**: (Order:Part, /cXML/.../ItemDetail/Classification)
- **cm2**: (Order:Manufacturer, /cXML/.../ManufacturerPartID)
- **dp1**: (Order:www, cm2, /cXML/.../ItemDetail/URL)
- **dp2**: (Order:quantity, cm1, /cXML/.../ItemOut/@quantity)
- **op1**: (Order:hasManufacturer, cm1, cm2)
- **op2**: (Order:hasPart, cm2, cm1)

The `cm1` mapping indicates that an instance of the `Part` class is created for each XML node matching the specified XPath expression, `/cXML/.../ItemDetail/Classification`. Therefore, three instances are created, one for "50202301" (UNSPSC code for water), one for "12352206" (UNSPSC code for tissues), and one for "50202303" (UNSPSC code for frozen juices). The `dp1` and `dp2` mappings indicate that for each instance created from the `cm1` and `cm2` class mappings, two datatype properties, `www` and `quantity`, respectively, are also created. The relative path to find the value used to fill the property is computed, which is `/cXML/.../ItemDetail/URL` for `dp1` and `/cXML/.../ItemOut/@quantity` for `dp2`. The `op1` mapping indicates that each instance created from the `cm1` class mapping is related to an instance created from the `cm2` class mapping using the `hasManufacturer` relationship. An inverse relationship, `hasPart`, also exists. These six mappings are stored internally in JXML2OWL in XML format, as shown in Listing 5.

### The Transformation Engine

The mappings created with JXML2OWL are used by the B2BISS Transformation Engine to automatically transform external incoming syntactic transactions into an internal semantic data representation. The engine determines the transaction type and queries the B2BISS repository for a suitable transformation. Figure 7 illustrates the six mappings previously described: `cm1`, `cm2`, `dp1`, `dp2`, `op1`, and `op2`.

At this stage, the mappings can only be used to transform XML-based transactions to XML/OWL data representations. However, the engine and mapping application can be extended to accommodate other formats used for knowledge representation, such as N3 and Turtle. In our simple example, the 11 mappings established generated an XSLT file with 245 instructions. A complete purchase order typically generates 3,000 to 4,000 instructions. These instructions form the basis for transforming instances from XML to OWL. The number of XSLT instructions required clearly demonstrates that adequate tool support can reduce costs and speed up the integration of heterogeneous schemas.

### Empirical Evaluation

As stated in Section 1, the B2BISS system allows organizations to decrease the time and cost of integration by providing a flexible and easy-to-use graphical tool and a platform for mapping management. Such an infrastructure is crucial for rapid and cost-effective B2B integration [37]. To evaluate the cost and time effectiveness and scalability of the solution, we conducted two experimental evaluations based on two complete case studies:

- Converting cXML business transactions to a semantic data model [46].
- Mapping from HR-XML resumes to a semantic data model [44].

Compared to creating the mappings by developing software modules, we found that graphically defining mappings was faster, less expensive, required less knowledge, and was less error-prone. Listing 1 shows 10% of the XSLT code corresponding to the mappings needed to transform XML-based external representations into internal data representations expressed with OWL ontologies in our running scenario. As seen, the graphical creation of mappings from Figure 5 is easier, faster, less expensive, and less error-prone than manually creating the mappings using XSLT. The advantages became even more pronounced when mappings started to be stored in the repository and reused.

### Scenarios

#### Scenario A: Receiving a Purchase Order for the First Time

In this scenario, we receive a purchase order for the first time. We perform a set of heterogeneous mappings, and the XSLT transformations are imported into the B2BISS system. Initially, the purchase order is classified as a no match. Once the heterogeneous mappings are created, the purchase order is classified as a complete match, and an automated transformation is carried out.

#### Scenario B: Receiving a Purchase Order for the Second Time

In the previous scenario, we received a purchase order for the first time and performed a set of heterogeneous mappings. The XSLT transformations were imported into the B2BISS system. Now, the system has one set of XSLT transformations in the B2BISS repository and can automatically perform transformations on purchase orders from Aldo Corp. Beplus Corp. sends a second purchase order identical to the one from the first scenario. The purchase order is added to the Incoming Files section and processed to determine if it is a partial match, a complete match, or a no match. The purchase order is moved to the complete match section because there is a set of XSLT transformations in the repository that can completely transform it. Since no additional mapping is needed, the transformation is directly applied, and instances of the Hiltrixâ€™s purchase order ontology are automatically created.

#### Scenario C: Receiving a Purchase Order with New Elements

In the previous scenario, Hiltrix Corp. received a purchase order that was automatically transformed upon arrival. In this third scenario, Hiltrix receives a different purchase order from Celsius Corp. that includes one new element compared to the previous orders. This scenario can occur if Celsius decides to use additional optional fields from the cXML specification or if an organization modifies cXML to meet specific business requirements. Celsius Corp. decided to use the `Shipping` element from the cXML specification to request the products (Water, Tissues, and Orange Juice) to be shipped via FedEx at a cost of $35.50. The new cXML element is illustrated in Listing 2.

**Listing 2: The New Added cXML Shipping Element**

```xml
<Shipping>
    <ShipTo>
        <Name>FedEx</Name>
        <Cost>35.50</Cost>
    </ShipTo>
</Shipping>
```

This new element will require an update to the existing mappings to ensure the purchase order can be fully transformed.