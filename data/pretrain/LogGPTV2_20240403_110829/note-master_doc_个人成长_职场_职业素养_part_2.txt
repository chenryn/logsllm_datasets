### 原型与便签
应制作原型的事物：
- 架构
- 新功能
- 外部源
- 性能问题研究
- UI
适当使用原型 节约时间金钱
### 领域语言
计算机语言会影响思考问题的方式
**靠近问题领域进行编程** 站在更高的抽象层面 忽略琐碎的细节
## 基本工具
### 纯文本
**使用纯文本保存知识**
二进制数据的问题在于没有第三方对其解析 这些数据毫无意义
文本的威力：
- 保证不过时 人能阅读的数据 以及自描述的数据 活的更久
- 杠杆作用 计算机世界的许多工具对文本的支持都不错 unix下的小工具 vcs等
- 易于测试 文本测试数据更容易修改 并且无需特殊工具
纯文本在异构系统下十分好用
### shell
shell是不是真的比GUI好 好在哪里？
GUI最要命的一点 那就是使用GUI完成操作受限于GUI设计者 你所做的 都是在设计者给你的条条框框内
**利用命令shell的力量** 你可以使用组合参数 管道等方式得到一些十分强大的命令
### 编辑器
**用好一种编辑器** 这个编辑器应该能横跨所有平台（GUI 与命令行） 我能想到的就只有vim 但是vscode也符合需求 它的确很强大
### 源码控制
**总是使用源码控制** 不仅仅是代码 一切一切都可以存入源码控制系统 他给你了你反悔的能力
### 调试
**要修正问题 而非发出指责**
**不要恐慌 你最容易欺骗的人是你自己**
从何开始：
- 收集更多数据 以清楚bug
策略：
- 把你的数据可视化
- 跟踪程序 跟踪数据
- 橡皮鸭调试法
- 你的程序出错的可能性比外部程序大
- **不要假定 要证明** 出现了令你惊讶的bug就代表你之前的假设是错的
### 文本操纵语言
**学习一门文本操纵语言**可以有效提升效率
### 代码生成器
**编写能生成代码的代码**
被动代码生成器：生成结果 结果可以独立使用
主动代码生成器：需要时进行生成结果 结果用完就扔
代码生成器生成的不仅仅可以是代码
## 练习
用自己的时间练习 保持自己的技能不落伍是自己的责任
## 验收测试
### 需求
过早精细化带来的问题：
- 每次向业务放展示一项功能 他们就获得比之前更多的信息 这些信息又会影响他们的看法 提出新的观点
- 需求一定会变化 过于精确的评估无效
- 但是拒绝过早精细化又会带来模糊性
### 验收测试
其目的确定需求已经完成
何为已经完成：代码都写完了 测试都通过了 QA和需求方都认可
通过沟通确保大家都明白要做的什么
验收测试应当自动化进行 手工测试的成本太高
验收测试的进行越晚越好 需求一定会变化 理想情况下 应该由业务方以及QA来编写这些测试
协商并改进测试时专业开发人员的职责
单元测试与验收测试的区别在单元测试时白盒 验收是黑盒
对于GUI测试 进行时必须使用GUI背后文档的抽象元素 但是GUI测试还是应尽可能减少 设计时做到GUI与业务逻辑的解耦 GUI测试时不稳定的
使用持续集成确保新增的代码不会导致测试失败 否则修复失败是第一重要任务
## 测试策略
开发人员与QA携手保障系统质量
自动化测试金字塔：
![屏幕截图 2020-09-07 091102](/assets/屏幕截图%202020-09-07%20091102.png)
- 单元测试作为持续集成的一部分来运行
- 组件测试需要使用合适的模拟 输入数据 收集输出 验证是否符合预期
- 集成测试主要测试组件装配在一起是否协调
- 系统测试测试系统是否已正确组装完毕 各个组件之间是否能正确交互
- 最后使用人工探索式测试尽可能找出多的古怪之处
## 时间管理
离开没必要的会议
按照真实的紧急程度来执行任务
进入死胡同或者泥潭时 你可以回头修正设计 也可以继续向死路走下去 但走回头路是最简单的办法
## 预估
**估算，以避免发生意外**
**根据实际情况来调整你的估算**
使用的单位会对结果的解读造成影响
承诺是关乎确定性的 预估是一种猜测
尽可能说明预估的概率分布
三元分析法：
- 乐观预估
- 标称预估
- 悲观预估
## 压力
保持冷静的最好方式 便是规避会导致压力的处境
尽力为其他人的承诺找到解决方法 但并非要为别人的承诺付出代价
保持整洁 不能因压力而破坏原则 快而脏是矛盾的
遵循那些仍会在危机时刻遵循的原则 这些原则是避免陷入危机的最好途径
避免产生孤注一掷的想法 仓促鲁莽只会把你代入更深的深渊
## 协作
程序员的工作职责就是要让业务免于陷入困顿
代码共有比代码私有带来的好处要更加多
结对编程不仅促进知识传播 同时也是复查代码的一种手段
**说什么与怎么说同样重要**
**做变化的催化剂**
## 解耦
### 迪米特法则
该法则试图**使各个模块的耦合降至最低**
工程需要平衡各种证明因素和负面因素 带来解耦的好处 就会带来其他代价
### 元程序设计
元数据是描述数据的数据
那幺元程序就是元数据驱动的引用
**将抽象放进代码 细节放进元数据**
好处：
- 耦合更低
- 推迟细节决定
- 无需重新编译
- 更接近于领域模型 可以通过调整元数据实现不同的应用
可配置的应用 配置度越高 就代表程序越抽象 越抽象的程序越容易复用
### 时间耦合
相较于并发程序 顺序程序更符合人的逻辑
如果容许并发 就代表与时间的耦合度降低了 并再设计上予以支持 虽然不符合人的正常思维 但可以获得更强的灵活性
**分析工作流 以改善并发性**
**用定义良好的 接口一致的服务来进行设计**
**为并发而设计**能促使你设计更加简洁的接口
一旦具有了并发的要素 部署起来更加容易 因为不会有强依赖的情况产生 所谓强依赖就是部署a之前必须部署b
### 只是视图
- 发布订阅模式
MVC中的**视图与模型分离**
这条原则不仅适用于GUI 而是一条通用的编码准则 用来降低耦合
## 项目
### 需求
**不要收集需求 而是挖掘它** 深刻明白客户所提的需求可能是表象 要通过表象洞察其本质
建立需求文档：不管是形式化还是非形式化 不管是用例还是普通流程图
避免过度：文档比代码的好处就是可以模糊不清 文档不必过于具体 保持适当抽象 **抽象比细节获得更加长久**
追踪需求：通过建立一系列跟踪计划来避免特性膨胀
**维护一张词汇表**：建立业务领域与技术领域之间的映射
这些需求文档的分发可以借助于VCS以及Web 又厚又大的打印文档不仅费时费力而且容易过时
### 解决问题
一个难题的最终解决方案是一个刚开始看起来不太适用的方案 尝试思考被排除的方案
### 准备好了吗
**对于反复出现的焦虑 需要重视它 准备好再开始**
如使用原型来验证想法是否可行
### 规范陷阱
不应该将需求分析以及编码分裂成不同的过程 这些过程相辅相成 也不应该将规约设计到编码时毫无发挥技巧的余地
### 圆圈与箭头
**不要做形式化方法的奴隶** 编码是一个创造性过程 **昂贵的工具不一定能制作出更好的设计**
### 团队
不要留破窗户 破窗户最终只会越来越破
不要做温水里的青蛙 警惕那些使项目失败的小细节
交流失败的团队注定会失败
DRY:团队成员的工作重复不仅带来浪费 而且维护还可能是噩梦
**围绕功能而非工作职务进行组织人员** 就像围绕业务而非技术
抵抗不断画下去的诱惑
### 自动化
**手工流程是不可靠的**
- 构建自动化
- 自动化管理
  - 网站生成
  - 批准流程
### 无情的测试
**早测试 常测试 测试必无情**