and performs efﬁcient clustering validation using the
Bayesian Information Criterion [31] in order to compute
the best value of K. X-means is fast and scales well
with respect to the size of the dataset [31].
For the ﬁrst-step (coarse-grained) clustering, we ﬁrst
reduce the dimensionality of the feature space from d =
52 features (see Section 2.5.1) into d = 8 features by
simply computing the mean and variance of the distribu-
tion of fph, ppf, bpp, and bps for each C-ﬂow. Then we
apply the X-means clustering algorithm on the obtained
representation of C-ﬂows to ﬁnd the coarse-grained clus-
ters {C
i}i=1..γ1
generated by the ﬁrst-step clustering is relatively small,
we can now afford to perform a more expensive analysis
on each C
i. Thus, for the second-step clustering, we use
all the d = 52 available features to represent the C-ﬂows,
and we apply the X-means clustering algorithm to reﬁne
the results of the ﬁrst-step clustering.
i}i=1..γ1. Since the size of the clusters {C
Of course, since unsupervised learning is a notoriously
difﬁcult task, the results of this two-step clustering algo-
rithm may still be not perfect. As a consequence, the
C-ﬂows related to a botnet may be grouped into some
distinct clusters, which basically represent sub-botnets.
Furthermore, a cluster that contains mostly botnet or
benign C-ﬂows may also contain some “noisy” benign
or botnet C-ﬂows, respectively. However, we would like
to stress the fact that these problems are not necessarily
critical and can be alleviated by performing correlation
with the results of the activity-plane (A-plane) clustering
(see Section 2.7).
Finally, we need to note that it is possible to bootstrap
the clustering from A-plane logs. For example, one may
apply clustering to only those hosts that appear in the A-
plane logs (i.e., the suspicious activity logs). This may
greatly reduce the workload of the C-plane clustering
module, if speed is the main concern. Similarly, one
may bootstrap the A-plane correlation from C-plane logs,
e.g., by monitoring only clients that previously formed
communication clusters, or by giving monitoring pref-
erence to those clients that demonstrate some persistent
C-ﬂow communications (assuming botnets are used for
long-term purpose).
2.6 A-plane Clustering
In this stage, we perform two-layer clustering on ac-
tivity logs. Figure 7 shows the clustering process in
A-plane. For the whole list of clients that perform at
least one malicious activity during one day, we ﬁrst
cluster them according to the types of their activities
(e.g., scan, spam, and binary downloading). This is
the ﬁrst layer clustering. Then, for each activity type,
Cluster according
to activity type
Client list
with
malicious
activity
Cluster according
to activity features
scan activity
spam activity
binary
downloading
exploit
activity
…
…
…
…
Scan cluster 1
Scan cluster n
…
…
…
Figure 7: A-plane clustering.
we further cluster clients according to speciﬁc activity
features (the second layer clustering). For scan activity,
features could include scanning ports, that is, two clients
could be clustered together if they are scanning the same
ports. Another candidate feature could be the target
subnet/distribution, e.g., whether the clients are scanning
the same subnet. For spam activity, two clients could be
clustered together if their SMTP connection destinations
are highly overlapped. This might not be robust when
the bots are conﬁgured to use different SMTP servers
in order to evade detection. One can further consider
the spam content if the whole SMTP trafﬁc is captured.
To cluster spam content, one may consider the similarity
of embedded URLs that are very likely to be similar
with the same botnet [43], SMTP connection frequency,
content entropy, and the normalized compression dis-
tance (NCD [5, 41]) on the entire email bodies. For
outbound exploit activity, one can cluster two clients if
they send the same type of exploit, indicated by the Snort
alert SID. For binary downloading activity, two clients
could be clustered together if they download similar
binaries (because they download from the same URL
as indicated in the command from the botmaster). A
distance function between two binaries can be any string
distance such as DICE used in [20] 8.
In our current implementation, we cluster scanning
activities according to the destination scanning ports.
For spam activity clustering, because there are very few
hosts that show spamming activities in our monitored
network, we simply cluster hosts together if they perform
spamming (i.e., using only the ﬁrst layer clustering here).
For binary downloading, we conﬁgure our binary down-
loading monitor to capture only the ﬁrst portion (packet)
of the binary for efﬁciency reasons (if necessary, we
can also capture the entire binary). We simply compare
8In an extreme case that bots update their binaries from different
URLs (and the binaries are packed to be polymorphic thus different
from each other), one should unpack the binary using tools such as
Polyunpack [37] before calculating the distance. One may also directly
apply normalized compression distance (NCD [5, 41]) on the original
(maybe packed) binaries.
146 
17th USENIX Security Symposium 
USENIX Association
whether these early portions of the binaries are the same
or not. In other words, currently, our A-plane clustering
implementation utilizes relatively weak cluster features.
In the future, we plan to implement clustering on more
complex feature sets discussed above, which are more
robust against evasion. However, even with the current
weak cluster features, BotMiner already demonstrated
high accuracy with a low false positive rate as shown in
our later experiments.
2.7 Cross-plane Correlation
Once we obtain the clustering results from A-plane (ac-
tivities patterns) and C-plane (communication patterns),
we perform cross-plane correlation. The idea is to cross-
check clusters in the two planes to ﬁnd out intersections
that reinforce evidence of a host being part of a botnet. In
order to do this, we ﬁrst compute a botnet score s(h) for
each host h on which we have witnessed at least one kind
of suspicious activity. We ﬁlter out the hosts that have
a score below a certain detection threshold θ, and then
group the remaining most suspicious hosts according to
a similarity metric that takes into account the A-plane
and C-plane clusters these hosts have in common.
We now explain how the botnet score is computed for
each host. Let H be the set of hosts reported in the output
of the A-plane clustering module, and h ∈ H. Also, let
A(h) = {Ai}i=1..mh be the set of mh A-clusters that
contain h, and C(h) = {Ci}i=1..nh be the set of nh C-
clusters that contain h. We compute the botnet score for
h as
s(h) = i,j
j>i
t(Ai )=t(Aj )
w(Ai)w(Aj)
|Ai ∩ Aj |
|Ai ∪ Aj |
+i,k
w(Ai)
|Ai ∩ Ck|
|Ai ∪ Ck|
,
(1)
where Ai, Aj ∈ A(h) and Ck ∈ C(h), t(Ai) is the type of
activity cluster Ai refers to (e.g., scanning or spamming),
and w(Ai)  1 is an activity weight assigned to Ai.
w(Ai) assigns higher values to “strong” activities (e.g.,
spam and exploit) and lower values to “weak” activities
(e.g., scanning and binary download).
h will receive a high score if it has performed multiple
types of suspicious activities, and if other hosts that
were clustered with h also show the same multiple types
of activities. For example, assume that h performed
scanning and then attempted to exploit a machine outside
the monitored network. Let A1 be the cluster of hosts
that were found to perform scanning and were grouped
with h in the same cluster. Also, let A2 be a cluster
related to exploit activities that includes h and other
hosts that performed similar activities. A larger overlap
between A1 and A2 would result in a higher score being
assigned to h. Similarly, if h belongs to A-clusters that
have a large overlap with C-clusters, then it means that
the hosts clustered together with h share similar activities
as well as similar communication patterns.
Given a predeﬁned detection threshold θ, we consider
all the hosts h ∈ H with s(h) > θ as (likely) bots,
and ﬁlter out the hosts whose scores do not exceed θ.
Now, let B ⊆ H be the set of detected bots, A(B) =
{Ai}i=1..mB be the set of A-clusters that each contains at
least one bot h ∈ B, and C(B) = {Ci}i=1..nB be the set
of C-clusters that each contains at least one bot h ∈ B.
Also, let K(B) = A(B) ∪ C(B) = {K (B)
}i=1..(mB +nB )
be an ordered union/set of A- and C-clusters. We then
describe each bot h ∈ B as a binary vector b(h) ∈
{0, 1}|K(B)|, whereby the i-th element bi = 1 if h ∈
K (B)
, and bi = 0 otherwise. Given this representation,
we can deﬁne the following similarity between bots hi
and hj as
i
i
mBk=1
mB +nBk=mB +1
sim(hi, hj ) =
I(b(i)
k = b(j)
k ) + I(
I(b(i)
k = b(j)
k ) ≥ 1),
(2)
where we use b(i) = b(hi) and b(j) = b(hj), for the sake
of brevity. I(X) is the indication function, which equals
to one when the boolean argument X is true, and equals
to zero when X is false. The intuition behind this metric
is that if two hosts appear in the same activity clusters
and in at least one common C-cluster, they should be
clustered together.
This deﬁnition of similarity between hosts gives us the
opportunity to apply hierarchical clustering. This allows
us to build a dendrogram, i.e., a tree like graph (see
Figure 8) that encodes the relationships among the bots.
We use the Davies-Bouldin (DB) validation index [21]
to ﬁnd the best dendrogram cut, which produces the
most compact and well separated clusters. The obtained
clusters group bots in (sub-) botnets. Figure 8 shows
a (hypothetical) example. Assuming that the best cut
suggested by the DB index is the one at height 90,
we would obtain two botnets, namely {h8, h3, h5}, and
{h4, h6, h9, h2, h1, h7}.
Dendrogram
0
4
1
0
0
1
0
8
0
6
0
4
0
2
0
t
i
h
g
e
H
8
h
3
h
5
h
4
h
6
h
9
h
2
h
1
h
7
h
Figure 8: Example of hierarchical clustering for botnet
detection.
In our current implementation, we simply set weight
w(Ai) = 1 for all i and θ = 0, which essentially
USENIX Association  
17th USENIX Security Symposium 
147
means that we will consider all hosts that appear in two
different types of A-clusters and/or in both A- and C-
clusters as suspicious candidates for further hierarchical
clustering.
3 Experiments
To evaluate our BotMiner detection framework and pro-
totype system, we have tested its performance on several
real-world network trafﬁc traces, including both (pre-
sumably) normal data from our campus network and
collected botnet data.
3.1 Experiment Setup and Data Collection
We set up trafﬁc monitors to work on a span port mir-
roring a backbone router at the campus network of the
College of Computing at Georgia Tech. The trafﬁc rate
is typically 200Mbps-300Mbps at daytime. We ran the
C-plane and A-plane monitors for a continuous 10-day
period in late 2007. A random sampling of the net-
work trace shows that the trafﬁc is very diverse, contain-
ing many normal application protocols, such as HTTP,
SMTP, POP, FTP, SSH, NetBios, DNS, SNMP, IM
(e.g., ICQ, AIM), P2P (e.g., Gnutella, Edonkey,
bittorrent), and IRC. This serves as a good back-
ground to test the false positives and detection perfor-
mance on a normal network with rich application proto-
cols.
We have collected a total of eight different botnets
covering IRC, HTTP and P2P. Table 1 lists the basic
information about these traces.
We re-used two IRC and two HTTP botnet traces
introduced in [20],
i.e., V-Spybot, V-Sdbot,
B-HTTP-I, and B-HTTP-II. In short, V-Spybot
and V-Sdbot are generated by executing modiﬁed bot
code (Spybot and Sdbot [6]) in a fully controlled virtual
network.
They contain four Windows XP/2K IRC
bot clients, and last several minutes. B-HTTP-I and
B-HTTP-II are generated based on the description of
Web-based C&C communications in [24, 39]. Four bot
clients communicate with a controlled server and execute
the received command (e.g., spam).
In B-HTTP-I,
the bot contacts the server periodically (about every
ﬁve minutes) and the whole trace lasts for about 3.6
hours. In B-HTTP-II, we have a more stealthy C&C
communication where the bot waits a random time
between zero to ten minutes each time before it visits
the server, and the whole trace lasts for 19 hours. These
four traces are renamed as Botnet-IRC-spybot,
Botnet-IRC-sdbot,
and
Botnet-HTTP-2, respectively.
In addition, we also
generated a new IRC botnet trace that lasts for a longer
time (a whole day) using modiﬁed Rbot [3] source code.
Again this is generated in a controlled virtual network
with four Windows clients and one IRC server. This
Botnet-HTTP-1,
trace is labeled as Botnet-IRC-rbot.
We also obtained a real-world IRC-based botnet C&C
trace that was captured in the wild in 2004, labeled as
Botnet-IRC-N. The trace contains about 7-minute
IRC C&C communications, and has hundreds of bots
connected to the IRC C&C server. The botmaster set
the command “.scan.startall” in the TOPIC of
the channel. Thus, every bot would begin to propagate
through scanning once joining the channel. They report
their successful transfer of binary to some machines, and
also report the machines that have been exploited. We
believe this could be a variant of Phatbot [6]. Although
we obtained only the IRC C&C trafﬁc, we hypothesize
that the scanning activities are easy to detect given the
fact that bots are performing scanning commands in
order to propagate. Thus, we assume we have an A-plane
cluster with the botnet members because we want to see
if we can still capture C-plane clusters and obtain cross-
plane correlation results.
Finally, we obtained a real-world trace containing two
P2P botnets, Nugache [28] and Storm [18,23]. The trace
lasts for a whole day, and there are 82 Nugache bots and
13 Storm bots in the trace. It was captured from a group
of honeypots running in the wild in late 2007. Each
instance is running in Wine (an open source implementa-
tion of the Windows API on top of Unix/Linux) instead
of a virtual or physical machine. Such a set-up is known
as winobot [12] and is used by researchers to track bot-
nets. By using a lightweight emulation environment
(Wine), winobots can run hundreds and thousands of
black-box instances of a given malware. This allows one
to participate in a P2P botnet en mass. Nugache is a TCP-
based P2P bot that performs encrypted communications
on port 8. Storm, originating in January of 2007, is
one of the very few known UDP based P2P bots.
It
is based on the Kademlia [30] protocol and makes use
of the Overnet network [2] to locate related data (e.g.,
commands). Storm is well-known as a spam botnet with
a huge number of infected hosts [27]. In the implemen-
tation of winobot, several malicious capabilities such as
sending spam are disabled for legality reason, thus we
can not observe spam trafﬁc from the trace. However,
we ran a full version of Storm on a VM-based honeypot
(instead of Wine environment) and easily observed that
it kept sending a huge amount of spam trafﬁc, which
makes the A-plane monitoring quite easy. Similarly,
when running Nugache on a VM-based honeypot, we
observed scanning activity to port 8 because it attempted
to connect to its seeding peers but failed a lot of times
(because the peers may not be available). Thus, we
can detect and cluster A-plane activities for these P2P
botnets.
148 
17th USENIX Security Symposium 
USENIX Association
Trace
Botnet-IRC-rbot
Botnet-IRC-sdbot
Botnet-IRC-spybot
Botnet-IRC-N
Botnet-HTTP-1
Botnet-HTTP-2
Botnet-P2P-Storm
Botnet-P2P-Nugache
Size
169MB
66KB
15MB
6.4MB
6MB
37MB
1.2G
1.2G
Duration
24h
9m
32m
7m
3.6h
19h
24h
24h
Pkt
1,175,083
474
180,822
65,111
65,695
395,990
59,322,490
59,322,490
TCP/UDP ﬂows
Botnet clients