title:From System Services Freezing to System Server Shutdown in Android:
All You Need Is a Loop in an App
author:Heqing Huang and
Sencun Zhu and
Kai Chen and
Peng Liu
From System Services Freezing to System Server
Shutdown in Android: All You Need Is a Loop in an App
Heqing Huang†,Sencun Zhu†, Kai Chen‡, Peng Liu†
†The Pennsylvania State University, University Park, PA, USA
‡Institute of Information Engineering, Chinese Academy of Sciences, China
{hhuang, szhu}@cse.psu.edu, {chenkai}@iie.ac.cn, PI:EMAIL
ABSTRACT
The Android OS not only dominates 78.6% of the worldwide smart-
phone market in 2014, but importantly has been widely used for
mission critical tasks (e.g., medical devices, auto/aircraft naviga-
tors, embedded in satellite project). The core of Android, System
Server (SS), is a multi-threaded process that contains most of the
system services and provides the essential functionalities to support
applications (apps). Considering the complicated design of the SS
and its easily-accessible system services (e.g., via Android APIs),
we conjecture that the SS may face DoS attacks. As the SS plays
the important role in Android, serious DoS attacks could cause
single-point-of-failure to the phone system. By studying the source
code, we discovered a general design trait in the concurrency con-
trol mechanism of the SS that could be vulnerable to DoS attacks.
To validate our hypothesis, we design a tool to cost efﬁciently ex-
plore high-risk methods in the SS. After a systematic analysis of
2,154 candidate-risky methods, we found four unknown vulnera-
bilities in critical services (e.g., the ActivityManager and the Win-
dowManager), which are named the Android Stroke Vulnerabili-
ties (ASVs). Exploiting the ASVs would continuously block all
other requests for system services, followed by killing the SS and
soft-rebooting the OS. Results of a further threat analysis show that
by writing a loop to invoke Android APIs in an app, an attacker
can continually freeze (reboot) the device at targeted critical mo-
ments (e.g., when patching vulnerable apps). Furthermore, ASVs
can be exploited to enhance malware with anti-removal capability
or to design the ransomware by putting the devices into continuous
DoS loops. After being informed, Google conﬁrmed our ﬁndings
promptly. We also proposed to their Android framework team sev-
eral improvements in their concurrency control design and a ﬁne-
grained failure recovery mechanism for the SS.
Categories and Subject Descriptors
D.4.1 [Operating Systems]: Process Management–Concurrency;
Synchronization; D.4.6 [Operating Systems]: Security and
Protection–Access controls; Invasive software; C.4 [Performance
of Systems]: Reliability, availability, and serviceability
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS’15, October 12–16, 2015, Denver, Colorado, USA.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-3832-5/15/10 ...$15.00.
DOI: http://dx.doi.org/10.1145/2810103.2813606 .
Keywords
Mobile Security; Denial of Service; Vulnerability Detection; Risk
Measurement
1.
INTRODUCTION
Android is an open-source OS, based on a modiﬁed Linux ker-
nel tailored for mobile devices. Android not only has a signiﬁcant
portion of the current mobile market [8], but has been widely used
in mission critical scenarios (e.g., used for medical devices [1, 11,
21], aircraft navigation [14, 15, 48], Android-auto navigation [2]
and satellite project [18]). One of the fundamental reasons that An-
droid is so popular among users and application (app) developers,
is the unique design of its middleware. This middleware has a set of
system services that abstract away the low-level OS details and pro-
vide the easily-accessible, rich application programming interfaces
(APIs) to support app development for the Android eco-system.
No app can run without the System Server (SS), a special
multi-threaded process of the Android middleware, which contains
most of the core Java-based system services. The SS threads pro-
vide the essential services to Android apps through Binder IPC/RPC.
First, the ActivityManager manages the life cycle of Android app
components, so it maintains the complete running context for each
app. Second, the PackageManager manages the (un)installation of
app packages and parses the apps’ manifest ﬁles, as well as reg-
istering app permissions and other static meta data. Third, main-
taining rich application context information, the SS becomes a crit-
ical building block to support the design of access control mecha-
nisms for app layer (e.g., Android default permission1checks [24],
ASM [36], SEAndroid [52] userspace hooks).
When the ActivityManager is frozen, no app component can be
started. When the WindowManager is frozen, no app can correctly
present its UI onto the screen. In this sense, the SS can be thought
of as the core of Android. Without these functionalities from var-
ious system services, it is obvious that the Android system cannot
run any app in a way acceptable to the user. When part of the SS is
frozen, the smartphone is (partially) broken and becomes unreliable
to support any mission critical tasks.
Considering the importance of the SS, one would expect its code
to be meticulously developed and thoroughly tested so that Android
is robust to failures and resilient to attacks. In this sense, it is ex-
pected that an attacker should take a great deal of effort to freeze
the SS.
In this study, we examine the attack-resilience of the SS from the
angle of denial-of-service (DoS). While researchers have discov-
1Permissions that grant access to low-level capabilities (e.g., ac-
cess camera driver or sdcard) are mapped to Linux group identiﬁers
(GIDs), which is not checked in the SS
1236ered malware samples [9] and vulnerabilities [20] that cause DoS
in the SS, the attack-resilience of the SS has yet to be analyzed
systematically. Due to the complicated design of the SS and the
easily-accessible nature of its system services, we conjecture that
the SS could face various DoS attacks. Considering the important
role the SS plays in Android, the DoS problems, if existing, could
cause various damages to the system (e.g., single-point-of-failure).
By scrutinizing the design of the SS through source code analy-
sis, we ﬁnd the following common design traits in the Java-based
system services. First, most of these services use basic Java con-
currency control mechanisms (i.e., the Java synchronized block) to
coordinate multiple threads (e.g., binder threads in the SS). Second,
most of these services only use a few monitor locks (very coarse
grained) in their services to protect many critical sections or syn-
chronized methods. Note that most of these methods or critical sec-
tions have different functionalities that may access different global
variables. This coarse-grained concurrency control design provides
a chance to cause vulnerable scenarios that lead to DoS attacks on
the SS. We further characterize the exploiting requirements of these
vulnerable scenarios and build a tool to help cost-effectively iden-
tify relevant vulnerabilities. With the help of the tool, we identiﬁed
four highly exploitable and previously unknown vulnerabilities in
two critical services of the SS, namely the ActivityManager and
WindowManager services within a week (about 2 hrs/day).
When exploiting these vulnerabilities, the relevant system ser-
vices are frozen, followed by a soft-reboot of the Android mid-
dleware layer (the SS and zygote are reinitialized). This indicates
that a single-point-of failure exist. We name the newly discovered
vulnerabilities as Android Stroke Vulnerability (ASV). We further
design several proof-of-concept (PoC) attacks by exploiting these
ASVs. The results show that one could write a simple loop to call
normal Android APIs to easily craft several exploits for the ASVs,
which causes various damages in Android. For instance, they can
turn a phone into continuous freezing/rebooting loops at mission
critical moments (e.g., navigating, patient status monitoring), pre-
vent the removal of malware and roll back the patching of app vul-
nerabilities, etc. As these ASVs are easily exploitable and could
cause various consequences, the Google security team has made
a quick response and conﬁrmed our ﬁndings, and accepted some
of the proposed suggestions. Our contributions are summarized as
follows:
• New Understanding and Discovery. Based on new understand-
ing of the core component, the SS in Android, we discover a general
type of design ﬂaw that opens the door for various DoS attacks.
•
Identifying New Vulnerabilities. We characterize the problem
and design a tool, called ASV-Hunter, to assist the hunting of ASVs.
Our tool cost-effectively processed all the methods in Android frame-
work, which enables us to further analyze 2,154 high-risk candi-
date methods within various system services. This helps us iden-
tify and conﬁrmed four unknown ASVs, which are exploited on
Google/Samsung devices ( with OS version 4.0-5.0.2).
• Performing Threat Analyses. We design and implement several
PoC attacks on Android by leveraging the discovered ASVs.
• Defenses. We not only propose short-term remediation for nor-
mal users but also design several improvements for the concurrency
control mechanism and the failure recovery scheme in the SS.
2. ANDROID SYSTEM SERVER
2.1 Android Overview
Android is a mobile operating system built on the top of the
Linux OS. When it boots up, its bootloader ﬁrst performs low-level
system initialization and loads the Linux kernel. The kernel further
initializes the drivers and the ﬁle system, and then starts the kernel
daemons and the ﬁrst userspace process /init. The /init then starts
the Android speciﬁc Zygote process, which is a warm-up template
process that preloads all the relevant libraries, classes and resources
for all the virtual machine (VM) based processes that start later. Af-
ter that, Zygote starts the System Server (SS) process, which con-
tains most critical system services in Android. Finally, various apps
are started to serve users.
An Android app often consists of four types of components,
namely, the activity (user interface), service (background task), the
broadcast receiver (mailbox for broadcast), and the content provider
(local database server). The components of different apps commu-
nicate with each other via the Android speciﬁc Binder interpro-
cess communication (IPC) by exchanging intent messages. Apps
also calls APIs to perform remote procedure calls (RPC) to the
system services via the Binder mechanism, the SS process main-
tains a binder thread pool to handle multiple RPC-based requests
simultaneously.2 Different from apps, the SS does not contain any
user interface. Note that only after the SS starts such critical ser-
vices (Java-based threads) as activitymanager, windowmanager and
etc.,3 Android can serve requests from apps. The activitymanager
manages the running status and life-cycle of all apps. When a user
tries to launch an app for the ﬁrst time, the API stub, startActivity()
is invoked, which creates an RPC into the method implementation
within the ActivityManagerService (AMS) class and relevant app
records are stored in a ProcessRecord list in AMS for references.
Since Android highly depends on the system services in the SS
to fulﬁll various tasks, the SS acts as the core of Android. When
an app is going to send a broadcast to relevant receivers, the activ-
itymanager queries the packagemanager for all the statically reg-
istered receivers, so that the broadcasts can get both dynamically
and statically registered receivers. Because the SS maintains most
running contexts of apps, the access control mechanisms on An-
droid also rely on it. By default, Android enforces part of its per-
mission checking via the SS. It grants permissions to apps through
the packagemanager and performs permission validations through
activitymanager and other services [24]. Moreover, a series of en-
hanced mandatory access control mechanisms (e.g., ASM [36], SE-
Android [52] and XManDroid [26]) also rely on the SS to perform
their userspace enforcements. However, the security and reliability
of the SS itself has not been scrutinized yet.
2.2 System Server Concurrency Control
System services in the SS are usually started as Java threads, and
they help maintain the system-wide states for various aspects (e.g.,
app life-cyles, window states, and registered app permissions). To
guarantee correctness of the program logic (e.g., providing syn-
chronized access to global variables), the SS enforces concurrency
control (CC) among threads (e.g., the binder threads, service threads
and etc.) that handle lots of concurrent IPC requests. Since no de-
tailed study has been done on its CC design, we analyze its source
code to understand its mechanism.
Synchronized Code Blocks in the SS. The most frequently used
CC mechanism in Android SS is based on the synchronized block
mechanism from the Java library, namely, the java.util.concurrent.
synchronized(monitorlock){...access/modify(data)...} is an
2Some system services (e.g., MediaService) are designed to join
the binder thread pool and handles the RPC directly
3After Android 4.0, SurfaceFlinger becomes a native service,
which starts right before the Zygote and runs independently from
other services in the SS. This design renders the boot animation
much faster, as it is responsible for displaying the image surfaces
1237Table 1: Statistics of synchronized critical sections (CSs) with
watchdog monitored locks in different system services
System Services Checked by
Watchdog (Android Versions Ranges)
ActivityManagerService (v1.5-v5.1)
WindowManagerService (v1.5-v5.1)
PowerManagerService (v1.5-v5.1)
MountService (v4.0-v5.1)
Monitor Lock
AMS.this
mWindowMap
mlock object
MountService
InputManagerService (v4.0-v5.1) mInputFilterLock
mDaemonLock
mPackages
mlock object
mlock object
mlock object
The overall ratio
NetwkManagementService (v4.0-v5.1)
PackageManagerService (v4.4-v5.1)
MediaRouterService (v5.0-v5.1)
MediaSessionService (v5.0-v5.1)
MediaProjManagerService (v5.0-v5.1)
Total # of monitored CSs/total # of CSs
Watchdog Monitored CS
Ratio (v5.1)
279/345=81%
185/198=94%
49/60=82%
41/41=100%
4/26=16%
4/7=57%
171/243=70%
13/13=100%
21/21=100%
16/16=100%
783/970=80%
example of a synchronized block. This built-in locking mechanism,
namely the synchronized block (for critical sections) is heavily
used in the SS. Monitor locks are acquired by a thread before it en-
ters an explicitly-programmed synchronized block (each such code
block conducts certain operations on certain global variables). The
Java synchronized block mechanism holds two properties: 1) only
one thread can execute the block of code at each time; 2) each
thread entering a synchronized block of code sees the effects of
all previous modiﬁcations guarded by the same lock. This type
of synchronization is necessary for mutually exclusive access to
global variables when handling multiple threads’ concurrent re-
quests. For example, the getPackageUid method from PackageM-
anagerService.class (PMS) returns the UID based on a given app’s
package name and PMS.removePackageLI removes an app pack-
age. Although these two methods run two different synchronized
blocks, they operate on the same mPackage global variable and
require the same lock, namely the mPackage lock. Hence, these
blocks are mutually exclusive, though they could be called by dif-
ferent apps/services simultaneously (via binder threads in the SS).
In Android 5.0.0, there are 1,917 synchronized code blocks in all
these system services (about 20 services in total), which indicates