use
d at 
run 
tim
e
Disables any kind of reparsing situation (symbolic 
links, NTFS reparse points, registry key redirection), 
and returns 
STATUS_REPARSE_POINT_ENCOUNTERED if any 
such situation occurs. This is a security mitigation for 
certain types of path redirection attacks.
N/A
Def
ault
Sec
urit
yQ
uot
a
Specifies that the object’s security descriptor is using 
the default 2 KB quota.
N/A
Sin
gle
Ha
ndl
eEn
try
Specifies that the handle information subheader 
contains only a single entry and not a database.
N/A
Ne
wO
bje
ct
Specifies that the object has been created but not yet 
inserted into the object namespace.
N/A
Del
Specifies that the object is not being deleted through 
ete
dIn
line
the deferred deletion worker thread but rather inline 
through a call to ObDereferenceObject(Ex).
 Note
When an object is being created through an API in the Windows
subsystem (such as CreateEvent or CreateFile), the caller does not
specify any object attributes—the subsystem DLL performs the work
behind the scenes. For this reason, all named objects created through
Win32 go in the BaseNamedObjects directory, either the global or per-
session instance, because this is the root object directory that
Kernelbase.dll specifies as part of the object attributes structure. More
information on BaseNamedObjects and how it relates to the per-session
namespace follows later in this chapter.
In addition to an object header, each object has an object body whose
format and contents are unique to its object type; all objects of the same type
share the same object body format. By creating an object type and supplying
services for it, an executive component can control the manipulation of data
in all object bodies of that type. Because the object header has a static and
well-known size, the Object Manager can easily look up the object header for
an object simply by subtracting the size of the header from the pointer of the
object. As explained earlier, to access the subheaders, the Object Manager
subtracts yet another well-known value from the pointer of the object header.
For the footer, the extended information subheader is used to find the pointer
to the object footer.
Because of the standardized object header, footer, and subheader
structures, the Object Manager is able to provide a small set of generic
services that can operate on the attributes stored in any object header and can
be used on objects of any type (although some generic services don’t make
sense for certain objects). These generic services, some of which the
Windows subsystem makes available to Windows applications, are listed in
Table 8-21.
Table 8-21 Generic object services
Service
Purpose
Close
Closes a handle to an object, if allowed (more on this later).
Duplicat
e
Shares an object by duplicating a handle and giving it to 
another process (if allowed, as described later).
Inheritan
ce
If a handle is marked as inheritable, and a child process is 
spawned with handle inheritance enabled, this behaves like 
duplication for those handles.
Make 
permane
nt/tempo
rary
Changes the retention of an object (described later).
Query 
object
Gets information about an object’s standard attributes and 
other details managed at the Object Manager level.
Query 
security
Gets an object’s security descriptor.
Set 
security
Changes the protection on an object.
Wait for 
a single 
object
Associates a wait block with one object, which can then 
synchronize a thread’s execution or be associated with an 
I/O completion port through a wait completion packet.
Signal 
an object 
Signals the object, performing wake semantics on the 
dispatcher object backing it, and then waits on a single 
and wait 
for 
another
object as per above. The wake/wait operation is done 
atomically from the scheduler’s perspective..
Wait for 
multiple 
objects
Associates a wait block with one or more objects, up to a 
limit (64), which can then synchronize a thread’s execution 
or be associated with an I/O completion port through a wait 
completion packet.
Although all of these services are not generally implemented by most
object types, they typically implement at least create, open, and basic
management services. For example, the I/O system implements a create file
service for its file objects, and the process manager implements a create
process service for its process objects.
However, some objects may not directly expose such services and could be
internally created as the result of some user operation. For example, when
opening a WMI Data Block from user mode, a WmiGuid object is created,
but no handle is exposed to the application for any kind of close or query
services. The key thing to understand, however, is that there is no single
generic creation routine.
Such a routine would have been quite complicated because the set of
parameters required to initialize a file object, for example, differs markedly
from what is required to initialize a process object. Also, the Object Manager
would have incurred additional processing overhead each time a thread called
an object service to determine the type of object the handle referred to and to
call the appropriate version of the service.
Type objects
Object headers contain data that is common to all objects but that can take on
different values for each instance of an object. For example, each object has a
unique name and can have a unique security descriptor. However, objects
also contain some data that remains constant for all objects of a particular
type. For example, you can select from a set of access rights specific to a type
of object when you open a handle to objects of that type. The executive
supplies terminate and suspend access (among others) for thread objects and
read, write, append, and delete access (among others) for file objects.
Another example of an object-type-specific attribute is synchronization,
which is described shortly.
To conserve memory, the Object Manager stores these static, object-type-
specific attributes once when creating a new object type. It uses an object of
its own, a type object, to record this data. As Figure 8-32 illustrates, if the
object-tracking debug flag (described in the “Windows global flags” section
later in this chapter) is set, a type object also links together all objects of the
same type (in this case, the process type), allowing the Object Manager to
find and enumerate them, if necessary. This functionality takes advantage of
the creator information subheader discussed previously.
Figure 8-32 Process objects and the process type object.
EXPERIMENT: Viewing object headers and type
objects
You can look at the process object type data structure in the kernel
debugger by first identifying a process object with the dx
@$cursession.Processes debugger data model command:
Click here to view code image
lkd> dx -r0 &@$cursession.Processes[4].KernelObject
&@$cursession.Processes[4].KernelObject           : 
0xffff898f0327d300 [Type: _EPROCESS *]
Then execute the !object command with the process object
address as the argument:
Click here to view code image
lkd> !object 0xffff898f0327d300
Object: ffff898f0327d300  Type: (ffff898f032954e0) Process
    ObjectHeader: ffff898f0327d2d0 (new version)
    HandleCount: 6  PointerCount: 215645
Notice that on 32-bit Windows, the object header starts 0x18 (24
decimal) bytes prior to the start of the object body, and on 64-bit
Windows, it starts 0x30 (48 decimal) bytes prior—the size of the
object header itself. You can view the object header with this
command:
Click here to view code image
lkd> dx (nt!_OBJECT_HEADER*)0xffff898f0327d2d0
(nt!_OBJECT_HEADER*)0xffff898f0327d2d0       : 
0xffff898f0327d2d0 [Type: _OBJECT_HEADER *]
    [+0x000] PointerCount     : 214943 [Type: __int64]
    [+0x008] HandleCount      : 6 [Type: __int64]
    [+0x008] NextToFree       : 0x6 [Type: void *]
    [+0x010] Lock             [Type: _EX_PUSH_LOCK]
    [+0x018] TypeIndex        : 0x93 [Type: unsigned char]
    [+0x019] TraceFlags       : 0x0 [Type: unsigned char]
    [+0x019 ( 0: 0)] DbgRefTrace      : 0x0 [Type: unsigned 
char]
    [+0x019 ( 1: 1)] DbgTracePermanent : 0x0 [Type: unsigned 
char]
    [+0x01a] InfoMask         : 0x80 [Type: unsigned char]
    [+0x01b] Flags            : 0x2 [Type: unsigned char]
    [+0x01b ( 0: 0)] NewObject        : 0x0 [Type: unsigned 
char]
    [+0x01b ( 1: 1)] KernelObject     : 0x1 [Type: unsigned 
char]
    [+0x01b ( 2: 2)] KernelOnlyAccess : 0x0 [Type: unsigned 
char]
    [+0x01b ( 3: 3)] ExclusiveObject  : 0x0 [Type: unsigned 
char]
    [+0x01b ( 4: 4)] PermanentObject  : 0x0 [Type: unsigned 
char]
    [+0x01b ( 5: 5)] DefaultSecurityQuota : 0x0 [Type: 
unsigned char]
    [+0x01b ( 6: 6)] SingleHandleEntry : 0x0 [Type: unsigned 
char]
    [+0x01b ( 7: 7)] DeletedInline    : 0x0 [Type: unsigned 
char]
    [+0x01c] Reserved         : 0xffff898f [Type: unsigned 
long]
    [+0x020] ObjectCreateInfo : 0xfffff8047ee6d500 [Type: 
_OBJECT_CREATE_INFORMATION *]
    [+0x020] QuotaBlockCharged : 0xfffff8047ee6d500 [Type: 
void *]
    [+0x028] SecurityDescriptor : 0xffffc704ade03b6a [Type: 
void *]
    [+0x030] Body             [Type: _QUAD]
    ObjectType       : Process
    UnderlyingObject [Type: _EPROCESS]
Now look at the object type data structure by copying the pointer
that !object showed you earlier:
Click here to view code image
lkd> dx (nt!_OBJECT_TYPE*)0xffff898f032954e0
(nt!_OBJECT_TYPE*)0xffff898f032954e0           : 
0xffff898f032954e0 [Type: _OBJECT_TYPE *]
    [+0x000] TypeList         [Type: _LIST_ENTRY]
    [+0x010] Name             : "Process" [Type: 
_UNICODE_STRING]
    [+0x020] DefaultObject    : 0x0 [Type: void *]
    [+0x028] Index            : 0x7 [Type: unsigned char]
    [+0x02c] TotalNumberOfObjects : 0x2e9 [Type: unsigned 
long]
    [+0x030] TotalNumberOfHandles : 0x15a1 [Type: unsigned 
long]
    [+0x034] HighWaterNumberOfObjects : 0x2f9 [Type: 
unsigned long]
    [+0x038] HighWaterNumberOfHandles : 0x170d [Type: 
unsigned long]
    [+0x040] TypeInfo         [Type: 
_OBJECT_TYPE_INITIALIZER]
    [+0x0b8] TypeLock         [Type: _EX_PUSH_LOCK]
    [+0x0c0] Key              : 0x636f7250 [Type: unsigned 
long]
    [+0x0c8] CallbackList     [Type: _LIST_ENTRY]
The output shows that the object type structure includes the
name of the object type, tracks the total number of active objects of
that type, and tracks the peak number of handles and objects of that
type. The CallbackList also keeps track of any Object Manager
filtering callbacks that are associated with this object type. The
TypeInfo field stores the data structure that keeps attributes, flags,
and settings common to all objects of the object type as well as
pointers to the object type’s custom methods, which we’ll describe
shortly:
Click here to view code image
lkd> dx ((nt!_OBJECT_TYPE*)0xffff898f032954e0)->TypeInfo
((nt!_OBJECT_TYPE*)0xffff898f032954e0)->TypeInfo         
[Type: _OBJECT_TYPE_INITIALIZER]
    [+0x000] Length           : 0x78 [Type: unsigned short]
    [+0x002] ObjectTypeFlags  : 0xca [Type: unsigned short]
    [+0x002 ( 0: 0)] CaseInsensitive  : 0x0 [Type: unsigned 
char]
    [+0x002 ( 1: 1)] UnnamedObjectsOnly : 0x1 [Type: 
unsigned char]
    [+0x002 ( 2: 2)] UseDefaultObject : 0x0 [Type: unsigned 
char]
    [+0x002 ( 3: 3)] SecurityRequired : 0x1 [Type: unsigned 
char]
    [+0x002 ( 4: 4)] MaintainHandleCount : 0x0 [Type: 
unsigned char]
    [+0x002 ( 5: 5)] MaintainTypeList : 0x0 [Type: unsigned 
char]
    [+0x002 ( 6: 6)] SupportsObjectCallbacks : 0x1 [Type: 
unsigned char]
    [+0x002 ( 7: 7)] CacheAligned     : 0x1 [Type: unsigned 
char]
    [+0x003 ( 0: 0)] UseExtendedParameters : 0x0 [Type: 
unsigned char]
    [+0x003 ( 7: 1)] Reserved         : 0x0 [Type: unsigned 
char]
    [+0x004] ObjectTypeCode   : 0x20 [Type: unsigned long]
    [+0x008] InvalidAttributes : 0xb0 [Type: unsigned long]
    [+0x00c] GenericMapping   [Type: _GENERIC_MAPPING]
    [+0x01c] ValidAccessMask  : 0x1fffff [Type: unsigned 
long]
    [+0x020] RetainAccess     : 0x101000 [Type: unsigned 
long]
    [+0x024] PoolType         : NonPagedPoolNx (512) [Type: 
_POOL_TYPE]
    [+0x028] DefaultPagedPoolCharge : 0x1000 [Type: unsigned 
long]
    [+0x02c] DefaultNonPagedPoolCharge : 0x8d8 [Type: 
unsigned long]
    [+0x030] DumpProcedure    : 0x0 [Type: void (__cdecl*)
(void *,_OBJECT_DUMP_CONTROL *)]
    [+0x038] OpenProcedure    : 0xfffff8047f062f40 [Type: 
long (__cdecl*)
                  (_OB_OPEN_REASON,char,_EPROCESS *,void 
*,unsigned long *,unsigned long)]
    [+0x040] CloseProcedure   : 0xfffff8047F087a90 [Type: 
void (__cdecl*)
                                   (_EPROCESS *,void 
*,unsigned __int64,unsigned __int64)]
    [+0x048] DeleteProcedure  : 0xfffff8047f02f030 [Type: 
void (__cdecl*)(void *)]
    [+0x050] ParseProcedure   : 0x0 [Type: long (__cdecl*)
(void *,void *,_ACCESS_STATE *,
                           char,unsigned 
long,_UNICODE_STRING *,_UNICODE_STRING *,void *,
_SECURITY_QUALITY_OF_SERVICE *,void * *)]
    [+0x050] ParseProcedureEx : 0x0 [Type: long (__cdecl*)
(void *,void *,_ACCESS_STATE *,
                           char,unsigned 
long,_UNICODE_STRING *,_UNICODE_STRING *,void *,
                 _SECURITY_QUALITY_OF_SERVICE 
*,_OB_EXTENDED_PARSE_PARAMETERS *,void * *)]
    [+0x058] SecurityProcedure : 0xfffff8047eff57b0 [Type: 
long (__cdecl*)
                 (void *,_SECURITY_OPERATION_CODE,unsigned 
long *,void *,unsigned long *,
                                             void * 
*,_POOL_TYPE,_GENERIC_MAPPING *,char)]
    [+0x060] QueryNameProcedure : 0x0 [Type: long (__cdecl*)
(void *,unsigned char,_
                            OBJECT_NAME_INFORMATION 
*,unsigned long,unsigned long *,char)]
    [+0x068] OkayToCloseProcedure : 0x0 [Type: unsigned char 
(__cdecl*)(_EPROCESS *,
void *,void *,char)]
    [+0x070] WaitObjectFlagMask : 0x0 [Type: unsigned long]
    [+0x074] WaitObjectFlagOffset : 0x0 [Type: unsigned 
short]
    [+0x076] WaitObjectPointerOffset : 0x0 [Type: unsigned 
short]
Type objects can’t be manipulated from user mode because the Object
Manager supplies no services for them. However, some of the attributes they
define are visible through certain native services and through Windows API
routines. The information stored in the type initializers is described in Table
8-22.
Table 8-22 Type initializer fields
A
tt
ri
b
ut
e
Purpose
T
y
pe 
na
m
e
The name for objects of this type (Process, Event, ALPC Port, and 
so on).
P
o