---
tags: ['数据库', 'MySQL']
books: [
  {name: '数据库系统概念', chapters: ['第11章']},
  {name: '高性能MySQL'}
]
---
# 索引
## 为什么使用索引
1. 大大减少了服务器需要扫描的数据量
2. 帮助服务器避免排序和临时表
3. 将随机io变成顺序io
## 索引用处
1. 快速查找匹配WHERE子句的行
2. 从consideration中消除行,如果可以在多个索引之间进行选择，mysql通常会使用找到最少行的索引
3. 如果表具有多列索引，则优化器可以使用索引的任何最左前缀来查找行
4. 当有表连接的时候，从其他表检索行数据
5. 查找特定索引列的min或max值
6. 如果排序或分组时在可用索引的最左前缀上完成的，则对表进行排序和分组
7. 在某些情况下，可以优化查询以检索值而无需查询数据行
## 索引使用条件
- 小表全表扫描效率优于索引
- 索引适合中大型表
- 特大型表，建立和维护索引的代价将会随之增长
### 评价
索引好坏的评价维度
- 访问类型：是否支持范围访问、特定值访问
- 访问时间
- 插入时间
- 删除时间
- 空间开销
## 一些索引数据结构
- hash（散列索引）
  - 可以直接根据key访问
  - **但是无法进行范围查询**
- avl（顺序索引）
  - 平衡二叉树，左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值（平衡因子 ） 不超过1
  - 支持范围查询
  - **插入操作可能需要旋转，效率低**
- b+树（顺序索引）
## 散列索引
要求全部的索引要能放入内存
- 静态散列
- 动态散列：散列函数、桶大小可以动态改变，性能不随文件增长降低。空间开销小。并且增加了一个中间层，带来微小的性能损失。
![动态散列](/assets/截屏2023-04-06%2021.24.06.png)
## 位图索引
```sql
性别_男= 10010101
性别_女= 01101010
区_朝阳= 00000100
```
当要获取朝阳的男的时候，将两个向量相与，结果为1的位置的数据，就是搜索命中的结果
### 位图操作的高效实现
### 位图与B+树
采用传统的 B+ 树建立索引，如果数据区分度很低，则B+树效率也不高
## 顺序索引
- 稠密索引: 每个属性都有一个索引项
- 稀疏索引: 只为某些属性建立索引
![稠密索引与稀疏索引](/assets/屏幕截图%202022-04-28%20173324.png)
### 多级索引
![多级索引](/assets/2022428173815.png)
- 通过将一级索引表放置在内存中加快搜索速度
### 索引的更新
#### 插入新记录
对于稠密索引：如果该索引值不存在于索引中，则在合适的位置插入索引值，如果存在于索引中，则找到索引值对应的记录链表，在链表尾部追加新记录
对于稀疏索引：在合适的索引值范围内添加新记录
#### 删除记录
对于稠密索引：如果该记录时该索引值的唯一记录，删除即可。否则执行链表的节点删除操作
对于稀疏索引：如果包含了索引值，则删除索引值对应的记录，并调整索引范围
### 辅助索引
在索引与实际记录之间的一个中间层，也就是非聚簇索引，索引的不是物理位置，而是根据某些列的值建立的一个独立的数据结构
![2022428174651](/assets/2022428174651.png)
## B树
![202271210518](/assets/202271210518.webp)
2-3 树是一种特殊的 B- 树
## B+树
B-tree减少了定位记录时所经历的中间过程，从而加快存取速度。普遍运用在数据库和文件系统
B+树中叶子节点中包含了key和value，非叶子节点中只是包含了key，不包含value
所有叶子节点位于同一层，之间会通过双向指针串联在一起，构成一个双向链表
![批注 2020-03-10 192507](/assets/批注%202020-03-10%20192507.png)
B+ 树可以让整个树状结构变得更加矮胖，而磁盘的预读特性每次都可以加载一整个节点中全部的键，到内存进行二分查找
如果出现了两条或者多条记录在索引属性上拥有相同的值，解决方法：
- 创建包含原始搜索码和其他额外属性的符合搜索码
- 在B+树节点上使用列表来存储
### 文件结构
### 操作
更新操作比较复杂，但是需要较少的 IO 操作
#### 批量加载
如果一次性插入大量数据，在插入前对数据排序再插入到B+树中，可以有效提升性能
同时，如果B+树是空的，还可以使用自底向上的方式来进行构建
#### 查找
首先在根节点进行二分查找，找到一个key的指针，接下来递归地不断向其非叶子节点查找，到了叶子节点，再进行二分查找，找出key所对应的data
#### 修改
查找出要修改节点的位置，由于每个中间节点能容纳的元素是有限的，所以修改之后会进行分裂、合并、旋转
![插入元素导致的节点提升](/assets/2022712105845.webp)
![删除元素导致节点合并](/assets/2022712105943.webp)
### vs红黑树
- 红黑树的出度为2，B树的出度要大很多，所以B树的查找次数更少
- B+ Tree能更好地利用磁盘的预读特性 但操作也会更加复杂
## LSM树
log-structured merge tree
### Memtable
内存中的数据结构，存储的是近期更新的记录值，可以用各种有序高效的数据结构来实现
### Immutable Table
在写入磁盘的过程中，系统很可能仍然在对外工作，所以创建副本，可以很好的地帮助避免读写冲突竞争
### SSTable
它要求key是有序的，并且每个段中每个key只能出现一次，查找key时，可以在稀疏索引中通过排序查找里快速找到
![通过稀疏索引查找](/assets/202258212929.png)
为了实现SSTables，需要在内存中维护一个有序的数据结构，每次写入时都会写到内存表，再由系统周期性刷到磁盘，为避免崩溃导致内存的数据还没刷到磁盘丢失，再维护一个日志文件，每进行一个操作就写到日志，以供恢复时使用
需要查找时，就对段逐个倒叙查找，直到找到
## MYSQL索引
### 技术名词
- 回表：使用索引就能完成查询 无需扫描表数据
- 最左匹配：在检索数据时从联合索引的最左边开始匹配，也代表字符串最左N个字符可以走索引
- 索引下推：在“仅能利用最左前缀索的场景”下，在遍历索引时，使用不在最左前缀索引中的其他联合索引字段，过滤会减少遍历索引查出的主键条数，减少回表
### 分类
- 主键索引
- 唯一索引
- 普通索引
- 全文索引
- 组合索引
### B+ Tree索引
- 是大多数 MySQL 存储引擎的默认索引类型
- 除了用于查找，还可以用于排序和分组
- 适用于全键值、键值范围和键前缀查找
#### 存储引擎的实现
MyISAM: B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”
InnoDB: 其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂
### 哈希索引
- 无法用于排序与分组
- 只支持精确查找，无法用于部分查找和范围查找
- 数据列只能回表查询，无法直接根据索引读取
只有Memory引擎显式支持哈希索引。对于索引比较长的字符序列，哈希索引很好用
InnoDB当某些索引值被使用的非常频繁时，会在B树索引的基础上创建一个哈希索引来提升效率，这个过程是内部且自动的。
为了在InnoDB上模拟出哈希索引，可以考虑使用一个字段存储哈希值，每次查找时对这个哈希值做一个等值比较：