91
â€¢ the ability for plaintext and ciphertext spaces to be deï¬ned over different cyclotomic
rings, which permits certain optimizations;
â€¢ and strict separation of the interface from the computational details, so it is easy to
use our SHE scheme on, e.g., multi-core CPUs, GPUs, etc.
4.1 SHE with Î›âˆ˜ğœ†
Our implementation uses the Î›âˆ˜ ğœ† library deï¬ned in chapter 3 to achieve its advanced
functionality. The high level interfaces exposed in Î›âˆ˜ğœ† make our implementation particularly
simple, closely and concisely matching the SHE schemeâ€™s mathematical deï¬nition.
Using Î›âˆ˜ ğœ†â€™s support for the cyclotomic hierarchy, we also devise and implement a
more efï¬cient variant of ring-switching for HE, which we call ring tunneling. A prior
technique [AP13] homomorphically evaluates a linear function by â€œhoppingâ€ from one
ring to another through a common extension ring. The extension ring can be very large
(dimension 200,000 or more), leading to a signiï¬cant performance bottleneck. Our new
approach avoids this problem by â€œtunnelingâ€ through a common subring, which has a
much smaller dimension resulting in improved performance. Moreover, we show that the
linear function can be integrated into the accompanying key-switching step, thus unifying
two operations into a simpler and even more efï¬cient one. (See section 4.2 for details.)
This implementation is the foundation for the homomorphic evaluation of a lattice-based
symmetric-key primitives (chapter 6).
4.1.1 Example: SHE in Î›âˆ˜ğœ†
For illustration, here we brieï¬‚y give a ï¬‚avor of our SHE implementation in Î›âˆ˜ ğœ†; see
Figure 4.1 for representative code, and section 4.3 for many more details of the schemeâ€™s
mathematical deï¬nition and implementation. While we do not expect the reader (especially
one who is not conversant with Haskell) to understand all the details of the code, it should be
clear that even complex operations like modulus-switching and key-switching/relinearization
92
have very concise and natural implementations in terms of Î›âˆ˜ğœ†â€™s interfaces (which include the
functions errorCoset, reduce, embed, twace, liftDec, etc.). Indeed, the implementations
of the SHE functions are often shorter than their type declarations! (For the reader who
is new to Haskell, section 2.3 gives a brief tutorial that provides sufï¬cient background to
understand the code fragments appearing in this paper.)
As a readerâ€™s guide to the code from Figure 4.1, by convention the type variables z, zp,
zq always represent (respectively) the integer ring Z and quotient rings Zğ‘ = Z/ğ‘Z, Zğ‘ =
Z/ğ‘Z, where ğ‘ â‰ª ğ‘ are respectively the plaintext and ciphertext moduli. The types m, mâ€™
respectively represent the indices ğ‘š, ğ‘šâ€² of the cyclotomic rings ğ‘…, ğ‘…â€², where we need ğ‘š|ğ‘šâ€²
so that ğ‘… can be seen as a subring of ğ‘…â€². Combining all this, the types Cyc mâ€™ z, Cyc m zp,
and Cyc mâ€™ zq respectively represent ğ‘…â€², the plaintext ring ğ‘…ğ‘ = ğ‘…/ğ‘ğ‘…, and the ciphertext
ring ğ‘…â€²
ğ‘ = ğ‘…â€²/ğ‘ğ‘…â€².
The declaration encrypt :: (m â€˜Dividesâ€˜ mâ€™, ...) => ... deï¬nes the type of the
function encrypt (and similarly for decrypt, rescaleCT, etc.). Preceding the arrow =>,
the text (m â€˜Dividesâ€˜ mâ€™, ...) lists the constraints that the types must satisfy at compile
time; here the ï¬rst constraint enforces that ğ‘š|ğ‘šâ€². The text following the arrow => deï¬nes
the types of the inputs and output. For encrypt, the inputs are a secret key in ğ‘…â€² and a
plaintext in ğ‘…â€²
ğ‘. Notice that the full ciphertext
type also includes the types m and zp, which indicate that the plaintext is from ğ‘…ğ‘. This
ğ‘, and the output is a random ciphertext over ğ‘…â€²
aids safety: thanks to the type of decrypt, the type system prevents the programmer from
incorrectly attempting to decrypt the ciphertext into a ring other than ğ‘…ğ‘.
Finally, each function declaration is followed by an implementation, which describes
how the output is computed from the input(s). Because the implementations rely on the
mathematical deï¬nition of the scheme, we defer further discussion to section 4.3.
93
encrypt :: (m â€˜Dividesâ€˜ mâ€™, MonadRandom rnd, ...)
-- secret key âˆˆ ğ‘…â€²
-- plaintext âˆˆ ğ‘…ğ‘
-- ciphertext over ğ‘…â€²
=> SK (Cyc mâ€™ z)
-> PT (Cyc m
zp)
-> rnd (CT m zp (Cyc mâ€™ zq))
ğ‘
encrypt (SK s) mu = do
 SK (Cyc mâ€™ z)
-> CT m zp (Cyc mâ€™ zq)
-> PT (Cyc m zp)
-- secret key âˆˆ ğ‘…â€²
-- ciphertext over ğ‘…â€²
-- plaintext in ğ‘…ğ‘
ğ‘
decrypt (SK s) (CT LSD k l c) =
let e = liftDec $ evaluate c (reduce s)
in l *> twace (iterate divG (reduce e) !! k)
-- homomorphic multiplication
(CT LSD k1 l1 c1) * (CT _ k2 l2 c2) =
CT d2 (k1+k2+1) (l1*l2) (mulG  c1 * c2)
-- ciphertext modulus switching
rescaleCT :: (Rescale zq zqâ€™, ...)
=> CT m zp (Cyc mâ€™ zq )
-> CT m zp (Cyc mâ€™ zqâ€™)
-- ciphertext over ğ‘…â€²
-- to ğ‘…â€²
ğ‘â€²
ğ‘
rescaleCT (CT MSD k l [c0,c1]) =
CT MSD k l [rescaleDec c0, rescalePow c1]
-- key switching/linearization
keySwitchQuad :: (MonadRandom rnd, ...)
=> SK râ€™ -> SK râ€™
-> rnd (CT m zp râ€™q -> CT m zp râ€™q) -- recrypt function
-- target, source keys
keySwitchQuad sout sin = do
-- in randomness monad
hint 
CT MSD k l $ [c0,c1] + switch hint c2
switch hint c =
sum $ zipWith (*>) (reduce  decompose c) hint
Figure 4.1: Representative (and approximate) code from our implementation of an SHE
scheme in Î›âˆ˜ğœ†.
94
4.1.2 Related Work
FHEW. FHEW [DM15] is an implementation of a very fast bootstrapping algorithm for
â€œthird-generationâ€ FHE schemes [GSW13; AP14]. However, it is not intended for general-
purpose homomorphic computations, since the scheme encrypts only one bit per ciphertext.
Our implementation supports large plaintext rings, which allows much higher throughtput.
HElib. HElib [HS] is an â€œassembly languageâ€ for BGV-style HE over cyclotomic rings [BGV14].
It holds speed records for a variety of HE benchmarks (e.g., homomorphic AES compu-
tation [GHS12c]), and appears to be the sole public implementation of many advanced
HE features, like bootstrapping for â€œpackedâ€ ciphertexts [HS15]. However, it does not
use the best known algorithms for cryptographic operations in general (non-power-of-two)
cyclotomics, which results in more complex and less efï¬cient algorithms, and suboptimal
noise growth in cryptographic schemes.
Our SHE scheme is implemented with Î›âˆ˜ğœ†, which uses a much better representation for
arbitrary cyclotomic rings. This results in improved efï¬ciency compared to HELib, despite
its emphasis on performance (see subsection 4.4.2 for details.)
Computational Platform. Several SHE implementations target specialized computational
platforms like FPGAs [Cou+14] and GPUs [Wan+12]. Since our implementation uses Î›âˆ˜ğœ†,
the hardware platform is completely abstracted away from the FHE functionality. This
means it is easy to make our SHE scheme run on FPGAs, GPUs, use vector instruction sets,
multi-core CPUs, and more. In particular, it is possible to include the highly-optimized code
from [HS] for two-power cyclotomic rings into an Î›âˆ˜ğœ† backend to obtain the efï¬ciency
of HELib, while simultaneoulsy enjoying the safety and advanced functionality of our
implementation.
95
4.1.3 Organization
The rest of this chapter is organized as follows:
Section 4.2 describes ring-tunneling for HE, a method of ring-switching which improves
upon prior work of [AP13].
Section 4.3 gives the design and implementation of our SHE scheme using Î›âˆ˜ğœ†, including
the implementation of ring-tunneling.
Section 4.4 uses the SHE implementation to evaluate Î›âˆ˜ğœ† in terms of code quality and
runtime performance, and gives a comparison to HElib [HS].
Acknowledgments. We thank TancrÃ¨de Lepoint for providing HElib benchmark code and
Victor Shoup for helpful discussions regarding HElib performance.
4.2 Efï¬cient Ring-Switching
The term â€œring switchingâ€ encompasses a collection of techniques, introduced in [BGV14;
Gen+13; AP13], that allow one to change the ciphertext ring for various purposes. These
techniques can also induce a corresponding change in the plaintext ring, at the same time
applying a desired linear function to the underlying plaintext.
In this section we describe an new, more efï¬cient instantiation of homomorphic ring-
switching which we call â€œring-tunnelingâ€. This operation was ï¬rst described in [Gen+12],
and an improved version called ring-hopping was given in [AP13]. These prior works focus
mainly on the mathematical description and analysis and the procedures, and do not give
many details regarding efï¬cient algorithms or concrete implementation.
Ring-switching provides the following functionality: given a ciphertext over a certain
cyclotomic ring ğ‘…, it transforms it into a ciphertext over another cyclotomic ring ğ‘†, with
the effect of applying a linear function to the original plaintext coefï¬cients (with respect to
a certain basis of ğ‘…). The transformation is implemented by passing through a sequence
96
of â€œhybridâ€ rings which gradually interpolate between ğ‘… and ğ‘†, while also gradually
transforming the coefï¬cients via a sequence of linear functions..
We observed that the ring-hopping procedure as described in [AP13] has a signiï¬cant
bottleneck in its use of so-called compositum rings, which in practice can be very large (of
dimension 200,000 or more) and thus expensive to work in. Here we describe an alternative
procedure that avoids compositum rings altogether, working entirely within rings whose
dimensions are essentially only as large as they need to be for security (e.g., in the low
thousands in our application). This yields a major runtime improvement, of at least an order
of magnitude (as compared with the procedure described in [AP13]).
In a bit more detail, the relationship between [AP13] and our work is as follows. To
â€œhopâ€ from one hybrid ring to the next, the procedure from [AP13] embeds into their
compositum ring (i.e., smallest common super-ring), and then uses ring-switching [Gen+12]
to map into the target hybrid ring. Here we show how to avoid the compositum by instead
decomposing elements over the largest common subring; this also leaves no explicit need
for key-switching. See Figure 4.2 for a visual comparison of the two methods.
embed
ğ‘‡
ğ¿
ğ‘…
rin
g-s
w
itc
h
(induced)
ğ¸
ğ‘†
ğ‘…
d
e
c
o
ğ¿
(induced)
ğ‘†
combine
embed
m
p
o
s
e
ğ¸
Figure 4.2: Comparison of ring hopping and ring tunneling from a ring ğ» to a ring ğ»â€². On
the left is the method from [AP13], which passes through the (large) compositum ring ğ‘‡ .
On the right is our more efï¬cient version, which decomposes the secret key and ciphertext
into ğ¸-elements, then combines them appropriately while embedding into ğ»â€².
97
4.2.1 Linear Functions
Here we recall the main algebraic facts needed to explain our instantiation of ring-hopping.
This section relies heavily on section 2.2, especially regarding mod-ğ‘ CRT sets (subsec-
tion 2.2.6). In addition, we will need some basic theory of linear functions on rings. Let ğ¸
be a common subring of some rings ğ‘…, ğ‘†. A function ğ¿ : ğ‘… â†’ ğ‘† is ğ¸-linear if for all
ğ‘Ÿ, ğ‘Ÿâ€² âˆˆ ğ‘… and ğ‘’ âˆˆ ğ¸,
ğ¿(ğ‘Ÿ + ğ‘Ÿâ€²) = ğ¿(ğ‘Ÿ) + ğ¿(ğ‘Ÿâ€²)
and ğ¿(ğ‘’ Â· ğ‘Ÿ) = ğ‘’ Â· ğ¿(ğ‘Ÿ).
From this it follows that for any ğ¸-basis âƒ—ğ‘ of ğ‘…, an ğ¸-linear function ğ¿ is uniquely deter-
mined by its values ğ‘¦ğ‘— = ğ¿(ğ‘ğ‘—) âˆˆ ğ‘†. Speciï¬cally, if ğ‘Ÿ = âƒ—ğ‘ğ‘¡ Â· âƒ—ğ‘’ âˆˆ ğ‘… for some âƒ—ğ‘’ over ğ¸, then
ğ¿(ğ‘Ÿ) = ğ¿(âƒ—ğ‘)ğ‘¡ Â· âƒ—ğ‘’ = âƒ—ğ‘¦ğ‘¡ Â· âƒ—ğ‘’.
Extending linear functions. Now let ğ¸â€², ğ‘…â€², ğ‘†â€² respectively be cyclotomic extension
rings of ğ¸, ğ‘…, ğ‘† satisfying certain conditions described below. As part of ring switching we
will need to extend an ğ¸-linear function ğ¿ : ğ‘… â†’ ğ‘† to an ğ¸â€²-linear function ğ¿â€² : ğ‘…â€² â†’ ğ‘†â€²
that agrees with ğ¿ on ğ‘…, i.e., ğ¿â€²(ğ‘Ÿ) = ğ¿(ğ‘Ÿ) for every ğ‘Ÿ âˆˆ ğ‘…. The following lemma gives a
sufï¬cient condition for when and how this is possible.
Lemma 4.2.1. Let ğ‘’,ğ‘Ÿ,ğ‘ ,ğ‘’â€²,ğ‘Ÿâ€²,ğ‘ â€² respectively be the indices of cyclotomic rings ğ¸,ğ‘…,ğ‘†,ğ¸â€²,ğ‘…â€²,ğ‘†â€²,
and suppose ğ‘’ = gcd(ğ‘Ÿ, ğ‘’â€²), ğ‘Ÿâ€² = lcm(ğ‘Ÿ, ğ‘’â€²), and lcm(ğ‘ , ğ‘’â€²)|ğ‘ â€². Then:
1. The relative decoding bases âƒ—ğ‘‘ğ‘Ÿ,ğ‘’ of ğ‘…/ğ¸ and âƒ—ğ‘‘ğ‘Ÿâ€²,ğ‘’â€² of ğ‘…â€²/ğ¸â€² are identical.
2. For any ğ¸-linear function ğ¿ : ğ‘… â†’ ğ‘†, the function ğ¿â€² : ğ‘…â€² â†’ ğ‘†â€² deï¬ned by ğ¿â€²(âƒ—ğ‘‘ğ‘Ÿâ€²,ğ‘’â€²) =
ğ¿(âƒ—ğ‘‘ğ‘Ÿ,ğ‘’) is ğ¸â€²-linear and agrees with ğ¿ on ğ‘….
Proof. First observe that ğ¿â€² is indeed well-deï¬ned and is ğ¸-linear, by deï¬nition of the
ring operations of ğ‘…â€² âˆ¼= ğ‘… âŠ—ğ¸ ğ¸â€². Now observe that ğ¿â€² is in fact ğ¸â€²-linear: any ğ‘’â€² âˆˆ ğ¸â€²
embeds into ğ‘…â€² as 1 âŠ— ğ‘’â€², so ğ¸â€²-linearity follows directly from the deï¬nition of ğ¿â€² and the
98
mixed-product property. Also, any ğ‘Ÿ âˆˆ ğ‘… embeds into ğ‘…â€² as ğ‘Ÿ âŠ— 1, and ğ¿â€²(ğ‘Ÿ âŠ— 1) = ğ¿(ğ‘Ÿ) Â· 1,
so ğ¿â€² agrees with ğ¿ on ğ‘….
Finally, observe that because ğ‘…â€² âˆ¼= ğ‘… âŠ—ğ¸ ğ¸â€², the index of ğ¸ is the gcd of the indices
of ğ‘…, ğ¸â€², and the index of ğ‘…â€² is their lcm. Then by the Kronecker-product factorization
of decoding bases, the relative decoding bases of ğ‘…/ğ¸ and of ğ‘…â€²/ğ¸â€² are the Kronecker
products of the exact same components, in the same order. (This can be seen by considering
each prime divisor of the index of ğ‘…â€² in turn.)
4.2.2 Error Invariant
In cryptographic applications, error terms are combined in various ways, and thereby grow