中，
·“all”显示以上所有信息。
·“help”显示上面的各种可选值的帮助信息。
8.6共享库的创建和安装
8.6.1共享库的创建
创建共享库非常简单，我们在前面已经演示了如何创建一个“so”共享对象。创建共
享库的过程跟创建-般的共享对象的过程基本致，最关键的是使用GCC的两个参数，即
关代码（PositionIndependent Code）技术来生产输出文件。另外还有一个参数是“-W1”参
数，这个参数可以将指定的参数传递给链接器，比如当我们使用“-Wl、-soname、my_soname”
时，GCC会将“-soname my_soname”传递给链接器，用来指定输出共享库的 SO-NAME。
所以我们可以使用如下命令行来生成一个共享库：
library_files
注
如果我们不使用-soname来指定共享库的SO-NAME，那么该共享库默认就没有
意
SO-NAME，即使用Idconfig更新SO-NAME的软链接时，对该共享库也没有效果。
比如我们有 libfool.e和 ibfoo2.c两个源代码文件，希望产生一个 libfoo.so.1.0.0的共享
库，这个共享库依于libbar1.so和 libbar2.so这两个共享库，我们可以使用如下命令行：
$gcc -shared -fpIc -Wl,-8onane,1ibfoo.no.1 -o 1ibfoo.8o.1.0.0 \
-1bar1 -1bar2
libfool.c 1ibfoo2.c\
当然我们也可以把编译和链接的步骤分开，分多步进行：
libfoo1.o 1ibfoo2.o -1bar1 -1bar2
$1d -8hared -soname 11bfoo.so.1 -o 1ibfoo.so.1.0.0\
几个值得注意的事项：
·不要把输出共享库中的符号和调试信息去掉，也不要使用GCC的"-fomit-frame-pointer”
选项，这样做虽然不会导致共享库停止运行，但是会影响调试共享库，给后面的工作
程序员的自我修养一链接、装载与库
---
## Page 269
246
第8章Linux共享库的组织
·在开发过程中，你可能要测试新的共享库，供是你又不希塑影响现有的程序正常运行。
我们前面提到的LD_LIBRARY_PATH是一个很好的方法，用它可以指定共享库的查找
路径。还有一种方法是使用链接器的“-rpath”选项（或者GCC的-WL-rpath），这种方
法可以指定链接产生的目标程序的共享库查找路径。比如我们用如下命令行产生一个
可执行文件：
$1d -rpath /home/mylib =o program.out program.o -lscmelib
这样产生的输出可执行文件program.out在被动态链接器装载时，动态链接器会首先在
“/home/mylib”查找共享库。
·默认情况下，链接器在产生可执行文件时，只会将那些链接时被其他共享模块引用到
的符号放到动态符号表，这样可以减少动态符号表的大小，也就是说，在共享模块中
反向引用主模块中的符号时，只有那些在链接时被共享模块引用到的符号才会被导出。
有一种情况是，当程序使用dlopen0动态加载某个共享模块，面该共享模块须反向引用
主模块的符号时，有可能主模块的某些符号因为在链接时没有被其他共享模块引用而
没有被放到动态符号表里面，导致了反向引用失败，d链接器提供了一个
号导出到动态符号表，以防止出现上述间题。我们也可以在GCC中使用
"-Wl-export-dynamic”将该参数传运给链接器。
8.6.2清除符号信息
正常情况下编译出来的共享库或可执行文件里面带有符号信息和调试信息，这些信息在
调试时非常有用，但是对于最终发布的版本来说，这些符号信息用处并不大，并且使得文件
尺寸变大。我们可以使用一个叫“strip”的工具清除掉共享库或可执行文件的所有符号和调
试信息（“strip”是binutils 的一部分）：
$strip 1ibfoo.80
去除符号和调试信息以后的文件往往比之前要小很多，一般只有原来的一半大小，甚至
不到一半。除了使用“strip”工具，我们还可以使用ld的“-s”和“-S”参数，使得链接器
个参数
8.6.3共享库的安装
创建共享库以后我们须将它安装在系统中，以便于各种程序都可以共享它。最简单的办
法就是将共享库复制到某个标准的共享库目录，如/lib、/usr/ib 等，然后运行 Idconfig即可。
程序员的自我修养一链接、装载与库
---
## Page 270
8.6共享库的创建和安装
247
不过上述方法往往需要系统的root权限，如果没有，则无法往/lib、Ausr/ib等目录添加
文件，也无法运行ldconfig程序。当然我们也有其他办法安装共享库，只不过步骤稍微廉烦
一些，无非是建立相应的SO-NAME软链接，并告诉编译器和程序如何查找该共享库等，以
便于编译器和程序都能够正需运行。建立SO-NAME的办法也是使用 Idconfig，只不过需要
指定共享库所在的目录：
$ldconfig =n shared_library_directory
在编译程序时，也需要指定共享库的位置，GCC提供了两个参数“-L”和“-1”，分别
这儿个参数之间有些细微的区别，我们这里不详细解释了，它们的作用都是用来指定共享库
的位置，其体可以参照GCC的手册。前血提到过的LD_LIBRARY_PATH的方法也可以用
米指定某个共享库的位置。
8.6.4共享库构造和析构函数
很多时候你希望共享库在被装载时能够进行一些初始化工作，比如打开文件、网络连接
等，使得共享库里面的函数接口能够正常工作。GCC提供了一种共享库的构造函数，只要
在函数声明时加上“_attribute_(constructor)”的属性，即指定该函数为共享库构造函数，
拥有这种属性的函数会在共享库加载时被执行，即在程序的main函数之前执行。如果我们
使用dlopen(打开共享库，共享库构造函数会在 dlopen(）返回之前被执行。
与共享库构造函数相对应的是析构函数，我们可以使用在函数声明时加上
“__attribute_（（destructor)）”的属性，这种函数会在mainO函数执行完毕之后执行（或者是
程序调用exitO时执行），如果共享库是运行时加载的，那么我们使用dlcloseO来卸载共享库
时，析构函数将会在dlcloseO返回之前执行。声明构造和析构函数的格式如下：
void attribute((constructor)) init_function (void) ;
void _attribute( (destructor)) fint_function (void) ;
当然，这种_attribute_的语法是GCC对C和C++语言的扩展，在其他编译器上这
种语法并不通用。
值得注意的是，如果我们使用了这种析构或构造函数，那么必须使用系统默认的标准运
行库和启动文件，即不可以使用GCC的“-nostartfiles”或“-nostdlib”这两个参数。因为这
些构造和析构函数是在系统默认的标准运行库或启动文件里面被运行的，如果没有这些辅助
结构，它们可能不会被运行。我们将在后面的关于系统库和启动文件的章节更加详细介绍相
关的机制。
程序员的自我修养一链接、装载与库
---
## Page 271
248
第8章Linux共享库的组织
另外还有一个间题是，如果我们有多个构造函数，那么默认情况下，它们被执行的顺序
是没有规定的。如果我们希望构造和析构函数能够按照一定的顺序执行，GCC为我们提供
了一个参数叫做优先级，我们可以指定某个构造或析构函数的优先级：
void attribute_( (constructor (5))) init_function1(void) ;
void _attribute_((constructor (10))) init_function2 (void) ;
对于构造函数来说，属性中优先级数字越小的函数将会在优光级大的函数之前运行：面
对于析构函数来讲，则刚好相反。这种安排有利于构造函数和析构函数能够匹配，比如某一
对构造函数和析构函数分别用来申请和释放某个资源，那么它们可以拥有一样的优先级，这
样做的结果往往是先中请的资源后释放，符合资源释放的一般规则。
8.6.5共享库脚本
我们前面所提到的共享库都是动态链接的ELF共享对象文件（.so），事实上，共享库还
可以是符合一定格式的链接脚本文件。通过这种脚本文件，我们可以把几个现有的共享库通
过一定的方式组合起来，从用户的角度看就是一个新的共享库。比如我们可以把C运行库
和数学库组合成一个新的库 libfoo.so，那么libfoo.so的内容可以如下：
GROUP ( /11b/1ibc, 8o , 6 /1ib/1ibm.8o. 2)
我们在前面也介绍过LD的链接脚本，这里的脚本与LD的脚本从语法和命令上来讲没
什么区别，它们的作用也相似，即将一个或多个输入文件以一定的格式经过变换以后形成
个输出文件。我们也可以将这种共享库脚本叫做动态链接脚本，因为这个链接过程是动态完
成的，也就是运行时完成的。
8.7本章小结
由于系统中存在大量的共享库，并且每个共享库都会随着更新和升级形成不同的相互兼
容或不兼容的版本。如何管理和维护这些共享库，让它们的不同版本之间不会相互冲突是使
用共享库的一个重要问题。在本章中，我们介绍了Linux/ELF共享库的版本命名方式、共享
库符号版本机制、共享库路径、查找过程、环境变量、共享库创建与安装等这些与共享库组
织相关的内容。
程序员的自我修养一键接、装载与库
---
## Page 272
Windows下的动态链接
9.1DLL简介
9.2符号导出导入表
9.3DLL优化
9.4C++与动态链接
9.5 DLLHELL
9.6本章小结
程序员的自我修养—链接、装载与库
---
## Page 273
250
第9章Windows下的动态链接
Windows下的 PE的动态链接与Linux下的 ELF动态链接相比，有很多类似的地方，但
也有很多不同的地方。我们在前面已经介绍过了PE的基本结构，这一章我们将围绕着PE
与Windows的动态链接来展开，介绍PE的符号导入导出机制、重定位和DLL的创建与安
装以及DLL的性能等一系列问题。
9.1DLL简介
DLL即动态链接库（Dynamic-LinkLibrary）的缩写，它相当于Linux下的共享对象。
Window系统中大量采用了这种 DLL机制，甚至包括Windows 的内核的结构都很大程度依
赖于DLL 机制。Windows下的DLL文件和 EXE文件实际上是一个概念，它们都是有 PE
格式的二进制文件，稍微有些不同的是PE文件头部中有个符号位表示该文件是EXE或是
DLL，而DLL文件的扩展名不一定是.dl，也有可能是别的比如.ocx（OCX控件）或是.CPL
（控制面板程序）
DLL的设计目的与共享对象有些出入，DLL更加强调模块化，即微软希望通过DLL机
制加强软件的模块化设计，使得各种模块之间能够松散地组合、重用和升级。所以我们在
Windows平台上看到大量的大型软件都通过升级DLL的形式进行自我完善，微软经常将这
些升级补丁积累到一定程度以后形成一个软件更新包（ServicePacks）。比如我们常见的微
软 Office 系列、Visual Studio 系列、Intemet Explorer甚至 Windows 本身也通过这种方式升
级。
另外，我们知道ELF的动态链接可以实现运行时加载，使得各种功能模块能以插件的
形式存在。在Windows下，也有类似ELF的运行时加载，这种技术在Windows下被应用得
更加广泛，比如奢名的ActiveX技术就是基于这种运行时加载机制实现的。
9.1.1进程地址空间和内存管理
在早期版本的,Windows 中[ 比如 Windows 1.x,2.x、3.x ), 也就是 16=bit 的 Windows
系统中，所有的应用程序都共享一个地址空间，即进程不拥有自己独立的地址空间（或
者在那个时候，这些程序的运行方式还不能被称作为进程1如果某个DLL被加载到
这个地址空间中，郑么所有的程序都可以共享这个DLL并且随意访问。该DLL中的
数据也是共享的，所以程序以此实现进程间通信。但是由于这种没有任何限制的访问
权限，各个程序之间随意的访问很容易导致DLL中数据被损坏。
后来的Windows改进了这个设计，也就是所谓的32位版本的Windows开始支持进程
拥有独立的地址空间，一个DLL在不同的进程中拥有不同的私有数据副本，就像我们前面
程序员的自我修养一链接、装载与库
---
## Page 274
9.1DLL简介
251
提到过的ELF共享对象一样。在ELF中，由于代码段是地址无关的，所以它可以实现多个
进程之间共享一份代码，但是DLL的代码却并不是地址无关的，所以它只是在某些情况下
可以被多个进程间共享。我们将在后面详细探讨DLL代码段的地址相关问题。
9.1.2基地址和RVA
PE里面有两个很常用的概念就是基地址（Base Address）和相对地址（RVA，Relative
Virtual Address）。当一个PE文件被装载时，其进程地址空间中的起始地址就是基地址。对
于任何一个PE文件来说，它都有一个优先装载的基地址，这个值就是PE文件头中的Image
BasC*
对于一个可执行EXE文件来说，Image Base一般值是0x400000，对于DLL文件来说，
这个值一般是0x10000000。Windows在装载DLL时，会先尝试把它装载到由Image Base
指定的虚拟地址；若该地址区域已被其他模块占用，那PE装载器会选用其他空闲地址。面
相对地址就是一个地址相对于基地址的偏移，比如一个E文件被装载到0x10000000，即基
地址为0x10000000，那么RVA为0x1000 的地址为0x10001000。
9.1.3DLL共享数据段
在Win32下，如果要实现进程间通信，当然有很多方法，Windows系统提供了一系列API
可以实现进程间的通信。其中有一种方法是使用DLL来实现进程间通信，这个原理与16位
Windows中的DLL实现进程间通信十分类似。正常情况下，每个DLL的数据段在各个进程
中都是独立的，每个进程都拥有自已的副本。但是Windows允许将DLL的数据段设置成共享
的，即任何进程都可以共享该DLL的同一份数据段。当然很多时候比较常见的做法是将一些
需要进程间共享的变量分离出来，放到另外一个数据段中，然后将这个数据段设置成进程间
可共享的。也就是说一个DLL中有两个数据段，一个进程间共享，另外一个私有。
当然这种进程间共享方式也产生了一定的安全漏润，因为任意一个进程都可以访问这个
共享的数据段，那么只要破坏了该数据段的数据就会导致所有使用该数据段的进程出现问
题。甚至恶意攻击者可以在GUEST的权限下运行某个进程破坏该共享的数据，从而影响那
些系统管理员权限的用户使用同一个DLL的进程，所以从这个角度讲，这种DLL共享数据
段来实现进程间通信应该尽量避免。
9.1.4DLL的简单例子
我们通过简单的例子来了解最简单的DLL的创建和使用，最基本的概念是导出
（Export）的概念。在ELF中，共享库中所有的全局函数和变量在默认情况下都可以被其
程序员的自我修养一链接、装载与库
---
## Page 275
252
第9章Windows下的动态链接
他模块使用，也就是说ELF默认导出所有的全局符号。但是在DLL中情况有所不同，我们
需要显式地“告诉”编译器我们需要导出某个符号，否则编译器默认所有符号都不导出。当
我们在程序中使用DLL导出的符号时，这个过程被称为导入（Import）。
MicrosoftVisualC++(MSVC）编译器提供了一系列C/C++的扩展来指定符号的导入导
出，对于一些支持Windows平台的编译器比如 Intel C++、GCCWindow版（mingwGCC
cygwinGCC）等都支持这种扩展。我们可以通过“_declspec”属性关键字来修饰某个函数
或者变量，当我们使用“_declspec(dllexport)”时表示该符号是从本DLL导出的符号，
“_declspec（dllimport）”表示该符号是从别的DLL导入的符号。在C++中，如果你希望导
入或者导出的符号符合C语言的符号修饰规范，那么必须在这个符号的定义之前加上
cxtemal“C"，以防止C++编译器进行符号修饰。
件来声明导入导出符号.“def”扩展名的文件是类似于d链接器的链接脚本文件，可以被
当作link链接器的输入文件，用于控制链接过程。“.def”文件中的IMPORT或者EXPORTS
段可以用来声明导入导出符号，这个方法不仅对C/C++有效，对其他语言也有效。
9.1.5创建DLL
假设我们的一个DLL提供3个数学运算的函数，分别是加（Add）、减（Sub）、乘（Mul），
它的源代码如下（Math.c）：
_declspec (dllexport) double Add( double a, double b )
return a + b;
F
_declspec(d1lexport) double Sub( double a, Gouble b )
return a - b;
_declspec (d1lexport) Gouble Mul [ double a, double b )
return a * b;
代码很简单，就是传入两个双精度的值然后返回相应的计算结果（有人能告诉我为什么没
有除法吗？不要着急，我们留着除法到后面用）。然后我们使用MSVC的编译器cl进行编译：
c1 /LDd Hath.c
参数/LDd表示生产Debug版的DLL，不加任何参数则表示生产EXE可执行文件：我
们可以使用/LD来编译生成Release版的 DLL
程序员的自我修养一链接、装载与库