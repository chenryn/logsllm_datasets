User: I wrote a tcp based server with the twisted.internet module. It's a high concurrency environment. 
I usually send data by the instance of protocol.Protocol, and I got a problem with that.
Some of the tcp connections may be closed caused by timeout, and it seems I cannot get any notification so that the data I have written in the closed connection may be lost.
And the data loss problem may caused by some other way. 
Is there any good way to control it? (socket.send could return a state, transport.write seems have no return)
Assistant: This problem is not specific to Twisted.  Your protocol must have some acknowledgement that data was received, if you want to know that it was received.
The result from send() does not tell you that the data was authoritatively received by the peer; it just says that it was queued by the kernel for transport.  From your application's point of view, it really doesn't matter whether the data was queued by Twisted, or by your C runtime, or by your kernel, or an intermediary downstream switch, or the peer's kernel, or whatever.  Maybe it's sent, maybe it's not.  Put another way, transport.write() takes care of additional buffering that send() doesn't, guaranteeing that it always buffers all of your bytes, whereas send() will only buffer some.
You absolutely need to have an application-level acknowledgement message if you care about whether a network peer has seen your data or not.