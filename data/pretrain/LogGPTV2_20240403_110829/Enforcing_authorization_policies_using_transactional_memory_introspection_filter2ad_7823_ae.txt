is an artifact of the library-based DSTM2 implementation, which
is an unoptimized research platform whose main goal is to oﬀer
ﬂexible interfaces. The current DSTM2 prototype is therefore not
tuned for performance and does not oﬀer compiler or language-
runtime support. Transactional memory systems that are compiler-
based [3], language-based [32], or hardware-accelerated [18, 22,
49] incur much lower overheads than DSTM2. The overhead of
future, language-integrated STM systems is likely to be competitive
with other means of concurrency—especially as STM techniques
are widely adopted, and optimized, and accelerated with hardware
support.
We also evaluated the overhead of lazy and eager authorization
managers at diﬀerent contention levels; Figure 8 presents the results
of this experiment. At x% contention, a transaction execution has
x% chance of being retried because it conﬂicts with another, con-
current transaction; thus, 100−x% of execution attempts will return
a response (by commit or authorization failure). We measured the
time for GradeSheet requests to be fully completed (i.e., committed
or aborted with an AccessDeniedException) by simulating con-
tentions from 0–50%; of all requests, 5% failed an authorization
check. At low contention, eager enforcement is more eﬃcient, since
it performs no work in copying metadata into an introspection log.
However, as contention grows, lazy enforcement becomes more ef-
ﬁcient. This is because eager enforcement performs authorization
checks on all accesses, even for transactions that must be retried
because they encounter a conﬂict due to contention. In contrast,
with lazy enforcement, authorization checks happen only once, at
commit, no matter how often the transaction was retried.
Determining the most eﬃcient enforcement strategy requires
measuring factors such as contention, the cost of authorization
checks, the time to execute a transaction body, and the rate of autho-
llllll0102030405025303540455055% contentiontime per request [µs]lLazy enforcementEager enforcementabort the transaction and trigger an application-speciﬁc repair pol-
icy. SEAD implements custom-purpose speculative execution us-
ing binary rewriting and can be applied even to legacy executables.
However, unlike TMI, SEAD does not beneﬁt from STM semantics
and machinery, e.g., through introspection on STM read/write sets,
and does not support general security policy enforcement.
In contrast to TMI, which uses transactions to handle authoriza-
tion failures, Swamy et al. propose Rx [54], a security-typed lan-
guage that uses transactions to handle dynamically-changing poli-
cies. In Rx, a programmer annotates code that must execute under
a single, consistent policy. The runtime system executes this code
transactionally and ensures that any updates to the policy as this
code executes will abort the transaction. Although we have not ex-
plored dynamically-changing policies, TMI can possibly accomo-
date them by assigning transactional semantics to the policy.
Finally, Speck [46], or Speculative Parallel Check, is a recent
system that uses speculation and rollback to overlap security checks
for reduced latency. While not as general as TMI, nor based on
STM techniques, Speck shares many aspects with TMI, such as
its support for overlapped enforcement and I/O based on external
transaction managers.
Virtual machines for security. Virtual machine monitors (VMM)
have recently emerged as a popular location to implement security
enforcement mechanisms [11]. Indeed, at least superﬁcially, they
oﬀer many of the same beneﬁts as a TMI-based security mecha-
nism. They allow introspection of runtime state of the guest oper-
ating system, thereby easing the construction of intrusion detection
systems that resist evasion and attack [29]. They also permit roll-
back and replay of system state, thereby allowing the construction
of malware detection and forensic tools (e.g., [16, 41]).
TMI oﬀers several advantages over the VMM-based approach.
Foremost, TMI extends declarative concurrency control and there-
fore applies at the instruction-level of granularity, in contrast to
VMM-based techniques, which apply at a much coarser level of
granularity. This diﬀerence is signiﬁcant. It allows TMI-based
techniques ﬁner-grained control over program execution, thereby
permitting instruction-level rollback. It also improves application
development by easing the integration of security enforcement
mechanism: TMI eliminates TOCTTOU bugs by construction, sim-
pliﬁes the handling of security exceptions, and ensures complete
mediation of all resource accesses within transactions. Such ﬁne
grained control over program execution may possibly be imple-
mented within a VMM as well, but the engineering overheads of
doing so are much higher.
In contrast, the VMM-based approach provides better control
over system level events, such as I/O. For example, ﬁle system
changes can be undone by simply rolling back to an earlier state;
TMI must be coupled with transactional I/O libraries to support
rollback of system-level events. In addition, the VMM-based ap-
proach can be used to enforce security policies on legacy binaries;
in contrast, TMI requires changes to server code. Combining TMI
with VMM-based techniques to construct security mechanisms is
an interesting area for future work.
Exception handling and recovery. As argued earlier, TMI lever-
ages transaction rollback to simplify the handling of security ex-
ceptions. An IBM survey reports that a large fraction of server code
relates to exception handling [12]. Weimer and Necula [57] found
that up to 46% of code on several Java benchmarks was exception
handling code (or reachable from it) and that SecurityException
was one of the most common exception classes that these bench-
marks handled erroneously. Exception handling code is often com-
plex, especially when it must consider several corner cases [10, 24,
57]. Indeed, there is experimental evidence that exception handling
code is more likely to contain bugs [15]. Because security excep-
tions account for a large fraction of exception handling code, the
TMI-based approach can result in easier-to-maintain, and less clut-
tered code.
The Microreboot [9] approach handles exceptions by oﬀering
ﬁne-grained control over the server, e.g., by allowing parts of it to
be rebooted, without impacting server availability. TMI is similar
to Microreboot in that it also oﬀers ﬁne-grained, instruction-level
control over exception handling in server software.
Aspect-oriented software development. Aspect-oriented pro-
gramming languages, such as AspectJ [5] and AspectC++ [4],
allow concerns that crosscut an application (e.g., security and error-
handling) to be developed separately and integrated with the appli-
cation. An aspect weaver matches the application against a set of
patterns (called pointcuts) and integrates appropriate advice (akin
to actions) at each program point that matches a pattern.
Because TMI enforces authorization policies by introspecting
on the STM’s read/write sets, it is a dynamic aspect weaver. How-
ever, the key advantage that TMI provides over traditional aspect
weavers is that it does not require advice to deal with authoriza-
tions exceptions, which automatically trigger transaction rollback.
In contrast, traditional aspect weavers must be supplied with ad-
vice to restore application state on an exception. In addition, TMI
also provides thread-safe aspect weaving, and does not introduce
TOCTTOU bugs or deadlocks.
7. SUMMARY
Correct implementation of security mechanisms is a diﬃcult task,
due to the challenges of providing complete mediation, prevent-
ing TOCTTOU bugs, and ensuring correct handling of policy vi-
olations. The TMI architecture can signiﬁcantly reduce the diﬃ-
culties of correctly implementing security enforcement. A TMI-
based authorization mechanism can get precise information about
all security-relevant runtime accesses, without having to worry
about race conditions, and can handle security violations by rolling
back to a consistent software state. TMI-based enforcement is ﬂexi-
ble, and can integrate with other, existing security mechanisms. For
some policies and workloads, TMI-based enforcement can lower
the overhead and latency of enforcement; in particular, TMI allows
authorization checks to be overlapped with execution. We believe
that the combination of TMI and declarative concurrency control
is a highly attractive architecture for the creation of future, secure
software.
There are several avenues for future work on the TMI architec-
ture. For instance, while this paper has focused on enforcing au-
thorization policies, TMI can also implement many other security
services, ranging from runtime information-ﬂow tracking to intru-
sion forensics. Similarly, TMI may be combined with static anal-
ysis, in particular, to automatically identify authorization points
(e.g., as in [28]), to determine transaction boundaries, or to elim-
inate unnecessary reference monitor invocations. Finally, TMI en-
forcement might integrate some of the developments in the rapidly-
progressing ﬁeld of STM systems, such as the recently-proposed
techniques for handling I/O within transactions [21, 48].
Acknowledgements. We would like to thank Tim Harris and the
anonymous reviewers for their detailed and insightful comments.
This work was supported in part by grants from the Rutgers Univer-
sity Research Council and the Reykjav´ık University Development
Fund.
REFERENCES
[1] M. Abadi, A. Birrell, T. Harris, and M. Isard. Semantics of
transactional memory and automatic mutual exclusion. In ACM
POPL, Jan 2008.
[2] M. Abadi and C. Fournet. Access control based on execution history.
In NDSS, 2003.
[3] A. Adi-Tabatabai, B. T. Lewis, V. Menon, B. R. Murphy, B. Saha, and
T. Shpeisman. Compiler and runtime support for eﬃcient software
transactional memory. In ACM PLDI, June 2006.
[4] The home of AspectC++. http://www.aspectc.org.
[5] AspectJ project. http://www.eclipse.org/aspectj.
[6] F. Besson, T. Blanc, C. Fournet, and A.D. Gordon. From stack
inspection to access control: a security analysis for libraries. In IEEE
CSFW, June 2004.
[7] A. Birgisson and ´U. Erlingsson. An implementation and semantics
for transactional memory introspection in Haskell. Technical Report
RUTR-CS08007, Reykjav´ık University, Aug 2008.
[8] M. Bishop and M. Digler. Checking for race conditions in ﬁle
accesses. Computer Systems, 9(2):131–152, Spring 1996.
[9] G. Candea, S. Kawamoto, Y. Fujiki, G. Friedman, and A. Fox.
Microreboot: A technique for cheap recovery. In USENIX OSDI, Dec
2004.
[10] T. Cargill. Exception handling: A false sense of security. C++
Report, 6(9), Nov 1994.
USENIX HotOS, May 2001.
Research, 1987.
[11] P. M. Chen and B. Noble. When virtual is better than real. In
[12] F. Christian. Exception handling. Technical Report RJ5724, IBM
[13] J. Chung, M. Dalton, H. Kannan, and C. Kozyrakis. Thread-safe
dynamic binary translaction using transactional memory. In IEEE
HPCA, Feb 2008.
[14] D. D. Clark and D. R. Wilson. A comparison of commercial and
military computer security policies. In IEEE S&P, May 1987.
[15] F. Cristian. Exception handling and tolerance of software faults. In
Software Fault Tolerance. Wiley, 1995.
[16] G. W. Dunlap, S. T. King, S. Cinar, M. Basrai, and P. M. Chen.
ReVirt: Enabling intrusion analysis through virtual-machine logging
and replay. In USENIX OSDI, Dec 2002.
[17] ´U. Erlingsson and F.B. Schneider. SASI enforcement of security
policies: A retrospective. In New Security Paradigms Workshop,
1999.
[18] C. Cao Minh et al.. An eﬀective hybrid transactional memory system
with strong isolation guarantees. In ISCA, June 2007.
[19] K. E. Moore et al.. LogTM: Log-based transactional memory. In
IEEE HPCA, Feb 2006.
[20] L. Hammond et al.. Transactional memory coherence and
consistency. In ISCA, June 2004.
[21] M. J. Moravan et al.. Supporting nested transactional memory in
LogTM. In ACM ASPLOS, Oct 2006.
[22] P. Damron et al.. Hybrid transactional memory. In ACM ASPLOS,
Oct 2006.
[23] Extensible access control markup language.
http://xml.coverpages.org/xacml.html.
[24] C. Fetzer, P. Felber, and K. Hogstedt. Automatic detection and
masking of nonatomic exception handling. IEEE Trans. on Software
Engineering, 30(8):547–560, 2004.
[25] B. Fletcher. Case study: Open source and commercial applications in
a Java-based SELinux cross-domain solution. In Annual SELinux
Symp., Mar 2006.
[26] FreeCS—the free chatserver. http://freecs.sourceforge.net.
[27] V. Ganapathy, T. Jaeger, and S. Jha. Retroﬁtting legacy code for
authorization policy enforcement. In IEEE S&P, May 2006.
[28] V. Ganapathy, D. King, T. Jaeger, and S. Jha. Mining
security-sensitive operations in legacy code using concept analysis.
In ACM/IEEE ICSE, May 2007.
[29] T. Garﬁnkel and M. Rosenblum. A virtual machine introspection
based architecture for intrusion detection. In NDSS, Feb 2003.
[30] L. Gong, G. Ellison, and M. Dageforde. Inside Java 2 Platform
Security. Addison-Wesley, second edition, September 2003.
[31] J. Gray and A. Reuter. Transaction Processing: Concepts and
Techniques. Morgan Kaufmann, 1993.
[32] T. Harris and K. Fraser. Language support for lightweight
transactions. SIGPLAN Not., 38(11):388–402, 2003.
[33] T. Harris, S. Marlow, S. Peyton Jones, and M. Herlihy. Composable
memory transactions. In PPoPP, Feb 2005.
[34] M. Herlihy, V. Luchango, and M. Moir. A ﬂexible framework for
implementing software transactional memory. In ACM SIGPLAN
OOPSLA, Oct 2006.
[35] M. Herlihy, V. Luchango, M. Moir, and W. Scherer. Software
transactional memory for dynamic-sized data structures. In ACM
PODC, July 2003.
[36] M. Hocking, K. Macmillan, and D. Shankar. Case study: Enhancing
IBM Websphere with SELinux. In Annual SELinux Symp., Mar 2006.
[37] T. Jaeger, A. Edwards, and X. Zhang. Consistency analysis of
authorization hook placement in the Linux security modules
framework. ACM TISSEC, 7(2):175–205, May 2004.
[38] Jakarta Apache Commons.
http://commons.apache.org/transaction.
[39] JCraft. WeirdX—pure Java window system server under GPL.
http://www.jcraft.com/weirdx.
[40] D. Kilpatrick, W. Salamon, and C. Vance. Securing the X Window
system with SELinux. Technical Report 03-006, NAI Labs, Mar
2003.
[41] S. T. King and P. M. Chen. Backtracking intrusions. In ACM SOSP,
Oct 2003.
[42] J. R. Larus and R. Rajwar. Transactional Memory. Synthesis
Lectures on Computer Architecture. Morgan Claypool, 2006.
[43] M. E. Locasto, A. Stavrou, G. Cretu, and A. Keromytis. From STEM
to SEAD: Speculative execution for automated defense. In USENIX
Annual Technical, June 2007.
[44] M.D. Matthews. Distributed transactions with MYSQL XA, 2005.
[45] Microsoft. Transactional NTFS in Windows Vista. http:
//msdn2.microsoft.com/en-us/library/aa363764.aspx.
[46] E. Nightingale, D. Peek, P. M. Chen, and J. Flinn. Parallelizing
security checks on commodity hardware. In ACM ASPLOS, March
2008.
[47] S. Peyton-Jones and T. Harris. Transactional memory with data
invariants. In ACM SIGPLAN TRANSACT, 2006.
[48] C. J. Rossbach, O. S. Hofmann, D. E. Porter, H. E. Ramadan,
A. Bhandari, and E. Witchel. TxLinux: Using and managing
transactional memory in an operating system. In ACM SOSP, Oct
2007.
[49] B. Saha, A.-R. Adl-Tabatabai, and Q. Jacobson. Architectural
support for software transactional memory. In IEEE Symp. on
Microarchitecture, Dec 2006.
[50] F. B. Schneider. Enforceable security policies. ACM TISSEC,
3(1):30–50, Feb 2000.
[51] M. I. Seltzer, Y. Endo, C. Small, and K. A. Smith. Dealing with
disaster: Surviving misbehaved kernel extensions. In USENIX OSDI,
Oct 1996.
[52] N. Shavit and D. Touitou. Software transactional memory. In ACM
PODC, Aug 1995.
[53] T. Shpeisman, V. Menon, A. Adl-Tabatabai, S. Balensiefer,
D. Grossman, R. L. Hudson, K. F. Moore, and B. Saha. Enforcing
isolation and ordering in STM. In ACM PLDI, June 2007.
[54] N. Swamy, M. Hicks, S. Tse, and S. Zdancewic. Managing policy
updates in security-typed languages. In Computer Security
Foundations Workshop, July 2006.
[55] Tar for Java: The com.ice.tar package.
http://trustice.com/java/tar/.
[56] E. Walsh. Integrating X.Org with security-enhanced Linux. In
Annual SELinux Symp., Mar 2007.
[57] W. Weimer and G. C. Necula. Exceptional situations and program
reliability. ACM TOPLAS, 30(2), Mar 2008.
[58] C. Wright, C. Cowan, S. Smalley, J. Morris, and G. Kroah-Hartman.
Linux security modules: General security support for the Linux
kernel. In USENIX Security, Aug 2002.
[59] x11perf: The X11 server performance test program suite.
[60] The X11 Server, version X11R6.8 (X.Org Foundation).
[61] A. Yumerefendi, B. Mickle, and L. Cox. TightLip: Keeping
applications from spilling the beans. In USENIX NSDI, April 2007.
[62] X. Zhang, A. Edwards, and T. Jaeger. Using CQUAL for static
analysis of authorization hook placement. In USENIX Security, Aug
2002.