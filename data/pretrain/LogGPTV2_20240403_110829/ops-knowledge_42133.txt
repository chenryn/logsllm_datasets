User: 请选择C/C++领域相关问题的正确答案及解释问题：给定两个双向循环链表A和B，其头指针分别为pHeadA和pHeadB。请问，以下哪种函数可以将两个链表中data值相同的节点删除？

A: ``c++/nvoid DeleteSameNode(struct node *pHeadA, struct node *pHeadB){/n    struct node *pA = pHeadA-&gt;next;/n    struct node *pB = pHeadB-&gt;next;/n    while(pA!=pHeadA){/n        pB=pHeadB-&gt;next;/n        while(pB!=pHeadB){/n            if(pA-&gt;data==pB-&gt;data){/n                pA-&gt;front-&gt;next=pA-&gt;next;/n                pA-&gt;next-&gt;front=pA-&gt;front;/n                pB-&gt;front-&gt;next=pB-&gt;next;/n                pB-&gt;next-&gt;front=pB-&gt;front;/n                free(pA);/n                free(pB);/n                break;/n            }/n            pB=pB-&gt;next;/n        }/n        pA=pA-&gt;next;/n    }/n}/n```/n
B: ``c++/nvoid DeleteSameNode(struct node *pHeadA, struct node *pHeadB){/n    struct node *pA = pHeadA-&gt;next;/n    struct node *pB = pHeadB-&gt;next;/n    while(pA!=pHeadA){/n        pB=pHeadB-&gt;next;/n        while(pB!=pHeadB){/n            if(pA-&gt;data==pB-&gt;data){/n                pA-&gt;front-&gt;next=pA-&gt;next;/n                pA-&gt;next-&gt;front=pA-&gt;front;/n                pB-&gt;front-&gt;next=pB-&gt;next;/n                pB-&gt;next-&gt;front=pB-&gt;front;/n                free(pA);/n                break;/n            }/n            pB=pB-&gt;next;/n        }/n        pA=pA-&gt;next;/n    }/n}/n```/n
C: ``c++/nvoid DeleteSameNode(struct node *pHeadA, struct node *pHeadB){/n    struct node *pA = pHeadA-&gt;next;/n    struct node *pB = pHeadB-&gt;next;/n    while(pA!=pHeadA){/n        pB=pHeadB-&gt;next;/n        while(pB!=pHeadB){/n            if(pA-&gt;data==pB-&gt;data){/n                pA-&gt;front-&gt;next=pA-&gt;next;/n                pA-&gt;next-&gt;front=pA-&gt;front;/n                pB-&gt;front-&gt;next=pB-&gt;next;/n                pB-&gt;next-&gt;front=pB-&gt;front;/n            }/n            pB=pB-&gt;next;/n        }/n        pA=pA-&gt;next;/n    }/n}/n```/n
D: ``c++/nvoid DeleteSameNode(struct node *pHeadA, struct node *pHeadB){/n    struct node *pA = pHeadA-&gt;next;/n    struct node *pB = pHeadB-&gt;next;/n    while(pA!=pHeadA){/n        pB=pHeadB-&gt;next;/n        while(pB!=pHeadB){/n            if(pA-&gt;data==pB-&gt;data){/n                pA-&gt;next-&gt;front=pA-&gt;front;/n                pB-&gt;front-&gt;next=pB-&gt;next;/n                pB-&gt;next-&gt;front=pB-&gt;front;/n                free(pA);/n                free(pB);/n                break;/n            }/n            pB=pB-&gt;next;/n        }/n        pA=pA-&gt;next;/n    }/n}/n```

Assistant: Answer: A