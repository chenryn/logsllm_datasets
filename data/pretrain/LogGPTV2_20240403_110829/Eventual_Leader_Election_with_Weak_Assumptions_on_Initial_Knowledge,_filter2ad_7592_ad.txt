to-point send primitive.
If a point-to-point send primitive was avail-
able the broadcast at Line 05 would be replaced by the statement “send
(suspicion, i, susp leveli[i], 0) to pj”, and all the suspicion messages
would then deﬁne a single message type. In that case each tag would deﬁne
a message type. This shows an interesting tradeoff relating communication
primitives (one-to-one vs one-to-many) and the number of message types.
with Line 16, this allows all the crashed processes to even-
tually disappear from contendersi . When pi receives a
(tag k, k, sl k, silent k, hbc k) message, it allocates new
local variables if that message is the ﬁrst it receives from
pk (Lines 07-10); pi also updates susp level i[k] (Line 11).
Then, the processing of the message depends on its tag.
• The message is a heartbeat message (Lines 12-13). If
it is not an old message (this is checked with the test
last stop leaderi[k] < hbc k), pi resets the corre-
sponding timer and adds k to contendersi.
• The message is a stop leader message (Lines 14-16).
If it is not an old message, pi updates its local counter
last stop leaderi[k], stops the corresponding timer
and suppresses k from contendersi .
• The message is a suspicion message (Lines 17).
If
it increases accordingly
the suspicion concerns pi,
susp level i[i].
4.2 Proof of the Protocol
This section proves that (1) the protocol described in Fig-
ure 2 eventually elects a common correct leader, and (2) no
message carries values that indeﬁnitely grow. The proofs
assume only (K1) as far the process initial knowledge is
concerned. It assumes (C1’) and (C2’) as far as the network
behavioral assumptions are concerned.
Lemma 6 [7] Let pk be a faulty process. There is a ﬁnite
time after which the predicate k /∈ contenders i remains
permanently true at each correct process pi.
Proof Let pk and pi be a faulty process and a correct pro-
cess, respectively. The only line where a process is added to
contenders i is Line 13. If follows that, if pi never receives a
heartbeat message from pk, k is never added to contenders i
and the lemma follows for pk.
So, considering the case where pi receives at least one
heartbeat message from pk, let us examine the last heartbeat
or stop leader message m from pk received and processed
by pi. “Processed” means that the message m carried a ﬁeld
hbc k such that the predicate last stop leaderi[k] < hbc k
was true when the message was received. Let us notice that
there is necessarily such a message, because at least the ﬁrst
heartbeat or stop leader message from pk received by pi sat-
isﬁes the predicate.
Due to the very deﬁnition of m, there is no other mes-
sage from pk such that pi executes Line 13 or Line 16 after
having processed m. There are two cases, according to the
tag of m.
• If m is a stop leader message, pi executes Line
16 and consequently suppresses deﬁnitely k from
contenders i.
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:12:21 UTC from IEEE Xplore.  Restrictions apply. 
Init: allocate susp leveli[i]; susp leveli[i] ← 0;
hbci ← 0; contendersi ← {i}; membersi ← {i}
———————————————————————————————————————
Task T 1:
repeat forever
next periodi ← false;
while leader() = i do every η time units
if (¬next periodi) then next periodi ← true; hbci ← hbci + 1 endif;
broadcast (heartbeat, i, susp leveli[i], ⊥, hbci)
end while;
if (next periodi) then broadcast (stop leader, i, susp leveli[i], ⊥, hbci) end if
(01)
(02)
(03)
(04)
end repeat
———————————————————————————————————————
Task T 2:
when leader() is invoked:
return `` such that (−, `) =lex min({(susp leveli[j], j)}j∈contendersi )´
when timeri[j] expires:
(05)
(06)
timeouti[j] ← timeouti[j] + 1; broadcast (suspicion, i, susp leveli[i], j, 0);
contendersi ← contendersi \ {j}
allocate susp leveli[k] and last stop leaderi[k];
susp leveli[k] ← 0; last stop leaderi[k] ← 0;
allocate timeouti[k] and timeri[k]; timeouti[k] ← η end if;
if (k /∈ membersi ) then membersi ← membersi ∪ {k};
when (tag k, k, sl k, silent k, hbc k) is received with k 6= i :
(07)
(08)
(09)
(10)
(11)
(12)
(13)
(14)
(15)
(16)
(17)
susp leveli [k ] ← max(susp leveli [k ], sl k);
if `(tag k= heartbeat) ∧ last stop leaderi[k] < hbc k)´
then last stop leaderi[k] ← hbc k;
if `(tag k = stop leader) ∧ last stop leaderi[k] < hbc k)´
then set timeri[k] to timeouti[k]; contendersi ← contendersi ∪ {k} endif;
stop timeri[k]; contendersi ← contendersi \ {k} endif;
if `(tag k = suspicion) ∧ (silent k = i)´ then susp leveli[i] ← susp leveli[i] + 1 endif
Figure 2. A communication-efﬁcient eventual leader protocol (code for pi)
• If m is a heartbeat message, pi executes Line 13.
This means that it resets timeri[k] and adds k to
contenders i.
Then, as no more heartbeat mes-
sages from pk are processed by pi, timeri[k] even-
tually expires and consequently pi withdraws k from
contenders i (Line 06), and never adds it again (as m
is the last processed heartbeat message), which proves
the lemma.
2Lemma 6
Given a run, let B be the set of correct processes pi such that
the largest value ever taken by susp leveli[i] is bounded.
Moreover, let Mi denote that value. Let H be the set of cor-
rect processes whose all output links with respect to each
other correct process are eventually timely. Due to the as-
sumption (C2’), we have H 6= ∅.
Lemma 7 [7] B 6= ∅.
Let (M`, `) =lex min({(Mi, i) | i ∈ B}).
Lemma 8 [7] There is a single process p`. Moreover p` is
a correct process.
Lemma 9 [7] Let pi and pj be two correct processes.
There is a ﬁnite time after which (1) the predicate i /∈
is always satisﬁed or (2) (i ∈ B ⇒
contendersj
susp levelj[i] = Mi) ∧ (i /∈ B ⇒ susp levelj[i] ≥ M`).
Lemma 10 [7] There is a time after which p` executes for-
ever the while loop of its Task T 1 (Lines 01-03).
Theorem 2 [7] The protocol described in Figure 2 ensures
that, after some ﬁnite time, all the correct processes have
forever the same correct process p` as common leader.
4.3 Protocol Optimality
Theorem 3 [7] There is a time after which a single process
sends messages forever.
Theorem 4 [7] In an inﬁnite execution, both the local mem-
ory of each process and the size of each message remain
ﬁnite.
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:12:21 UTC from IEEE Xplore.  Restrictions apply. 
References
[1] Aguilera M.K., Delporte-Gallet C., Fauconnier H. and
Toueg S., On Implementing Omega with Weak Reliabil-
ity and Synchrony Assumptions. 22th ACM Symposium
on Principles of Distributed Computing (PODC’03), ACM
Press, pp. 306-314, 2003.
[2] Aguilera M.K., Delporte-Gallet C., Fauconnier H. and
Toueg S., Communication Efﬁcient Leader Election and
Consensus with Limited Link Synchrony. 23th ACM Sym-
posium on Principles of Distributed Computing (PODC’04),
ACM Press, pp. 328-337, 2004.
[3] Anceaume E., Fern´andez A., Mostefaoui A., Neiger G. and
Raynal M., Necessary and Sufﬁcient Condition for Trans-
forming Limited Accuracy Failure Detectors. Journal of
Computer and System Sciences, 68:123-133, 2004.
[4] Chandra T.D. and Toueg S., Unreliable Failure Detectors
the ACM,
for Reliable Distributed Systems. Journal of
43(2):225-267, 1996.
[5] Chandra T.D., Hadzilacos V. and Toueg S., The Weak-
est Failure Detector for Solving Consensus. Journal of the
ACM, 43(4):685-722, 1996.
[6] Chu F., Reducing Ω to 3W. Information Processing Letters,
76(6):293-298, 1998.
[7] Fern´andez A., Jim´enez E. and Raynal M., Eventual Leader
Election with Weak Assumptions on Initial Knowledge,
Communication Reliability, and Synchrony. Tech Report
#1770, IRISA, Universit´e de Rennes (France), 19 pages
2005.
http://www.irisa.fr/bibli/publi/pi/2005/1770.0770.html
[8] Fischer M.J., Lynch N. and Paterson M.S., Impossibility of
Distributed Consensus with One Faulty Process. Journal of
the ACM, 32(2):374-382, 1985.
[9] Guerraoui R., Indulgent Algorithms. 19th ACM Symposium
on Principles of Distributed Computing, (PODC’00), ACM
Press, pp. 289-298, 2000.
[10] Guerraoui R. and Raynal M., The Information Structure
of Indulgent Consensus. IEEE Transactions on Computers,
53(4):453-466, 2004.
[11] Jim´enez E., Ar´evalo S. and Fern´andez A., Implementing Un-
reliable failure Detectors with Unknown Membership. Sub-
mitted to Information Processing Letters, 2005.
[12] Lamport L., The Part-Time Parliament. ACM Transactions
on Computer Systems, 16(2):133-169, 1998.
[13] Lamport L., Shostak R. and Pease L., The Byzantine Gen-
eral Problem. ACM Transactions on programming Lan-
guages and Systems, 4(3):382-401, 1982.
[14] Larrea M., Fern´andez A. and Ar´evalo S., Optimal Imple-
mentation of the Weakest Failure Detector for Solving Con-
sensus. Proc. 19th IEEE Int’l Symposium on Reliable Dis-
tributed Systems (SRDS’00), IEEE Computer Society Press,
pp. 52-60, 2000.
[15] Malkhi D., Oprea F. and Zhou L., Ω Meets Paxos: Leader
Election and Stability without Eventual Timely Links. Proc.
19th Int’l Symposium on DIStributed Computing (DISC’05),
Springer Verlag LNCS #3724, pp. 199-213, 2005.
[16] Mostefaoui A., Mourgaya E., and Raynal M., Asynchronous
Implementation of Failure Detectors. Proc. Int’l IEEE Con-
ference on Dependable Systems and Networks (DSN’03),
IEEE Computer Society Press, pp. 351-360, 2003.
[17] Mostefaoui A., Rajsbaum S., Raynal M. and Travers C.,
From 3W to Ω:
a Simple Bounded Quiescent Reli-
able Broadcast-based Transformation. Tech Report #1759,
7 pages, IRISA, University of Rennes 1 (France), 2005.
[18] Mostefaoui A. and Raynal M., Low-Cost Consensus-Based
Atomic Broadcast. 7th IEEE Paciﬁc Rim Int. Symposium on
Dependable Computing (PRDC’2000), IEEE Computer So-
ciety Press, pp. 45-52, 2000.
[19] Mostefaoui A. and Raynal M., Leader-Based Consensus.
Parallel Processing Letters, 11(1):95-107, 20.0.
[20] Mostefaoui A., Raynal M. and Travers C., Crash-resilient
Time-free Eventual Leadership. Proc. 23th Int’l IEEE
Symposium on Reliable Distributed Systems (SRDS’04),
IEEE Computer Society Press, pp. 208-217, Florianopolis
(Brasil), 2004.
[21] Mostefaoui A., Raynal M., Travers C., Patterson S., Agrawal
A. and El Abbadi A., From Static Distributed Systems to
Dynamic Systems. Proc. 24th Int’l IEEE Symposium on Re-
liable Distributed Systems (SRDS’05), IEEE Computer So-
ciety Press, pp. 109-118, Orlando (Florida), 2005.
[22] Pedone F. and Schiper A., Handling Message Semantics
with Generic Broadcast Protocols. Distributed Computing,
15(2):97-107, 2002.
[23] Raynal M., A Short Introduction to Failure Detectors for
Asynchronous Distributed Systems. ACM SIGACT News,
Distributed Computing Column, 36(1):53-70, 2005.
[24] Yang J., Neiger G. and Gafni E., Structured Derivations
of Consensus Algorithms for Failure Detectors. Proc. 17th
Int. ACM Symposium on Principles of Distributed Comput-
ing (PODC’98), ACM Press, pp. 297-308, Puerto Vallarta
(Mexico), July 1998.
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:12:21 UTC from IEEE Xplore.  Restrictions apply.