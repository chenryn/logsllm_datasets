200 000 000
30001
200 030 001
n= 100,000
20 000 000 000
300001
20 000 300 001
n = 1,000,000 2 000 000 000 000
3 000 001
100000000000
这组数据应该就看得很清楚。当n的值越来越大时，你会发现，3n+1已经没法和
2n²的结果相比较，最终几乎可以忽略不计。也就是说，随着n值变得非常大以后，
算法G其实已经很趋近于算法1。于是我们可以得到这样一个结论，判断一个算法的
效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）
的阶数。
判断一个算法好不好，我们只通过少量的数据是不能做出准确判断的。根据刚才
的几个样例，我们发现，如果我们可以对比这几个算法的关键执行次数函数的渐近增
长性，基本就可以分析出：某个算法，随着n的增大，它会越来越优于另一算法，或
者越来越差于另一算法。这其实就是事前估算方法的理论依据，通过算法时间复杂度
来估算算法时间效率。
2.9算法时间复杂度
2.9.1算法时间复杂度定义
在进行算法分析时，语句总的执行次数T（n）是关于问题规模n
的函数，进而分析T（n）随n的变化情况并确定T（n）的数量
29
---
## Page 54
大适数据结构
级。算法的时间复杂度，也就是算法的时间量度，记作：T（n）
=O（f（n)）。它表示随问题规模n的增大，算法执行时间的增长率和
f（n）的增长率相同，称作算法的渐近时间复杂度，简称为时间复
杂度。其中f（n）是问题规模n的某个函数。
这样用大写0（）来体现算法时间复杂度的记法，我们称之为大0记法。
一般情况下，随着n的增大，T（n)增长最慢的算法为最优算法。
显然，由此算法时间复杂度的定义可知，我们的三个求和算法的时间复杂度分别
为0（n]，0（1），0（n2)。我们分别给它们取了非官方的名称，0（1）叫常数阶、0（n）叫线
性阶、0（n2）叫平方阶，当然，还有其他的一些阶，我们之后会介绍。
2.9.2推导大O阶方法
的推导方法，基本上，这也就是总结前面我们举的例子。
推导大O阶：
1.用常数1取代运行时间中的所有加法常数。
2.在修改后的运行次数函数中，只保留最高阶项。
3.如果最高阶项存在且不是1，则去除与这个项相乘的常数。
得到的结果就是大O阶。
哈，仿佛是得到了游戏攻略一样，我们好像已经得到了一个推导算法时间复杂度
的万能公式。可事实上，分析一个算法的时间复杂度，没有这么简单，我们还需要多
看几个例子。
2.9.3常数阶
首先顺序结构的时间复杂度。下面这个算法，也就是刚才的第二种算法（高斯算
法），为什么时间复杂度不是0（3)，而是0（1）。
intsum-0，n-100;/*执行一次·/
sum-（1+n）*n/2;
1执行一次*/
printf（"d"，sum）;/·执行一次▪/
这个算法的运行次数函数是f（n）=3。根据我们推导大0阶的方法，第一步就是
把常数项3改为1。在保留最高阶项时发现，它根本没有最高阶项，所以这个算法的
30
---
## Page 55
第2章算法
时间复杂度为0（1）。
另外，我们试想一下，如果这个算法当中的语句sum=（1+n）*n/2有10句，
即：
intsum=0,n=100;
/执行1次*/
sum=_（1+n）*n/2;
1执行第1次/
sum=（1+n）*n/2;
/·执行第2次*/
sum=（1+n）*n/2:
/执行第3次*/
sum-（1+n）*n/2;
1执行第4次*/
sum=（1+n）*n/2;
1执行第5次*/
sum-（1+n）*n/2;
1执行第6次·/
sum-（1+n）*n/2;
1执行第7次*/
sum=（1+n）*n/2;
/执行第日次
sum=（1+n）*n/2;
1·执行第9次·
sum=（1+n）*n/2;
/执行第10次/
printf（“ed"，sum）：/*执行1次*/
事实上无论n为多少，上面的两段代码就是3次和12次执行的差异。这种与问
题的大小无关（n的多少），执行时间恒定的算法，我们称之为具有0（1）的时间复杂
度，又叫常数阶。
注意：不管这个常数是多少，我们都记作0（1），而不能是0（3）、0（12）等其他任
何数字，这是初学者常常犯的错误。
对于分支结构而言，无论是真，还是假，执行的次数都是恒定的，不会随着n的
变大面发生变化，所以单纯的分支结构（不包含在循环结构中），其时间复杂度也是
0(1)。
2.9.4线性阶
线性阶的循环结构会复杂很多。要确定某个算法的阶次，我们常常需要确定某个
特定语句或某个语句集运行的次数。因此，我们要分析算法的复杂度，关键就是要分
析循环结构的运行情况。
下面这段代码，它的循环的时间复杂度为0（n），因为循环体中的代码须要执行n
次。
inti;
for（i=0;i<n;i++）
31
---
## Page 56
大语数据结构
时间复杂度为0（1）的程序步骤序列*/
2.9.5对数阶
下面的这段代码，时间复杂度又是多少呢？
int count=1;
while（count<n）
countcount2;
/时间复条度为0（1）的程序步骤序列*
由于每次count乘以2之后，就距离n更近了一分。也就是说，有多少个2相乘
后大于n，则会退出循环。由2x=n得到x=bg2n。所以这个循环的时间复杂度为
O(ogn).
2.9.6平方阶
下面例子是一个循环嵌套，它的内循环刚才我们已经分析过，时间复杂度为
(u)o
inti,j;
for（i-0;1<ni++）
for（j=0；j<n；j++）
/时间复杂度为0（1）的程序步碾序列*/
而对于外层的循环，不过是内部这个时间复杂度为0（n）的语句，再循环n次。所
以这段代码的时间复杂度为0[n2]。
如果外循环的循环次数改为了m，时间复杂度就变为0（m×n）。
inti,j;
for（1-0;i<m1++）
1
32
---
## Page 57
第2章算法
for（j-o；5<nj++）
1
/时间复杂度为0（1）的程序步骤序列*/
所以我们可以总结得出，循环的时间复杂度等于循环体的复杂度乘以该循环运行
的次数。
那么下面这个循环嵌套，它的时间复杂度是多少呢？
int i,3:
for（i-0;i<n:i++)
or（j-i；j<n;j++）/*注意j=i而不是0·/
1
/*时间复杂度为0（1）的程序步骤序列*/
上
由于当i=0时，内循环执行了n次，当i=1时，执行了n-1次，..当i=n-1
时，执行了1次。所以总的执行次数为：
用我们推导大0阶的方法，第一条，没有加法常数不予考虑；第二条，只保留最
高阶项，因此保留n²/2；第三条，去除这个项相乘的常数，也就是去除1/2，最终这
段代码的时间复杂度为0（n²)。
从这个例子，我们也可以得到一个经验，其实理解大0推导不算难，难的是对数
列的一些相关运算，这更多的是考察你的数学知识和能力，所以想考研的朋友，要想
在求算法时间复杂度这里不失分，可能需要强化你的数学，特别是数列方面的知识和
解题能力。
我们继续看例子，对于方法调用的时间复杂度又如何分析。
inti,3:
for（i=0;i<n;i++）
function（i）;
33
---
## Page 58
大语数据结构
上面这段代码调用一个函数function。
void function（int count）
print（count）;
函数体是打印这个参数。其实这很好理解，function函数的时间复杂度是0（1）。
所以整体的时间复杂度为0（n）。
假如function是下面这样的：
void function（int count)
intj1
for（j-count;<n;j++）
/时间复杂度为0（1）的程序步骤序列*/
事实上，这和刚才举的例子是一样的，只不过把嵌套内循环放到了函数中，所以
最终的时间复杂度为0[n2]。
下面这段相对复杂的语句：
n++;
/执行次数为1*/
function（n）;
/执行次数为n*/
inti,3;
for（i-0;1<n:i++）
/执行次数为n²*/
function（1）;
for（i-0;1<ni++）
/执行次数为n（n+1）/2*/
for（j-i=j<n;j++）
/时间复杂度为O（1）的程序步骤序列*/
34
---
## Page 59
第2章算法
#+1，根据推导大0阶的方法，
2
最终这段代码的时间复杂度也是0（n²）。
2.10常见的时间复杂度
常见的时间复杂度如表2-10-1所示。
表2-10-1
执行次数函数
阶
非正式术语
12
0(1)
常数阶
2n+3
O(n)
线性阶
3n²+2n+1
O(n)
平方阶
5log;n+20
O(logn)
对数阶
2n+3nlogn+19
O（nlogn）nlogn阶
6n²+2n²+3n+4
o(a)
立方阶
2
0(2）)
指数阶
常用的时间复杂度所耗费的时间从小到大依次是：
O（1)<O（logn)<O（n）<O（nlogn）<O（n²)<O（n²)<O（2"）<O（nl）)<O（n²)
我们前面已经谈到了0(1）常数阶、0（ogn）对数阶、0（n）线性阶、0（n²）平方阶等，
至于0（nlgn）我们将会在今后的课程中介绍，而像0（n)，过大的n都会使得结果变
得不现实。同样指数阶0（2）和阶乘阶O（nl）等除非是很小的n值，否则哪怕n只是
100，都是噩梦般的运行时间。所以这种不切实际的算法时间复杂度，一般我们都不
去讨论它。
2.11最坏情况与平均情况
你早晨上班出门后突然想起来，手机忘记带了，这年头，钥匙、钱包、手机三大
件，出门哪样也不能少呀。于是回家找。打开门一看，手机就在门口玄关的台子上，
原来是出门穿鞋时忘记拿了。这当然是比较好，基本没花什么时间寻找。可如果不是
放在那里，你就得进去到处找，找完客厅找卧室、找完卧室找厨房、找完厨房找卫生
间，就是找不到，时间一分一秒的过去，你突然想起来，可以用家里座机打一下手
---
## Page 60
大语数据结构
机，听着手机铃声来找呀，真是笨。终于找到了，在床上枕头下面。你再去上班，迟
到。见鬼，这一年的全勤奖，就因为找手机给黄了。
找东西有运气好的时候，也有怎么也找不到的情况。但在现实中，通常我们碰到
的绝大多数既不是最好的也不是最坏的，所以算下来是平均情况居多。
算法的分析也是类似，我们查找一个有n个随机数字数组中的某个数字，最好的
情况是第一个数字就是，那么算法的时间复杂度为0[1），但也有可能这个数字就在最
后一个位置上待着，那么算法的时间复杂度就是0（n)，这是最坏的一种情况了。
最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。在应用中，这是
一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏情况的运行
时间。
而平均运行时间也就是从概率的角度看，这个数字在每一个位置的可能性是相同
的，所以平均的查找时间为n/2次后发现这个目标元素。
平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。也就是说，
我们运行一段程序代码时，是希望看到平均运行时间的。可现实中，平均运行时间很
难通过分析得到，一般都是通过运行一定数量的实验数据后估算出来的。
对算法的分析，一种方法是计算所有情况的平均值，这种时间复杂度的计算方法
称为平均时间复杂度。另一种方法是计算最坏情况下的时间复杂度，这种方法称为最