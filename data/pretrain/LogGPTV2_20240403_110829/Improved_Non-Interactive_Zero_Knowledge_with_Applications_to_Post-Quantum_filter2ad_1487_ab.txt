output wire γ, deﬁne λγ
AND gate with input wires α, β, the parties are given [λα,β], where λα,β
def= zα ⊕ λα.
def= λα · λβ.
A key observation is that the shares of the {λα} are uniform, and so can be generated by having
each party Si apply a pseudorandom generator to a short, random seed seedi given to that party,
and then (implicitly) deﬁning the {λα} based on the resulting shares. All-but-one of the shares
of the {λα,β} can also be generated in this way, but the ﬁnal share is constrained by the values
of λα, λβ. To ensure that the shares of the {λα,β} are correct, Sn can be given an additional |C|
“correction bits” that determine its share of λα,β for each AND gate with input wires α, β.
To summarize: each Si is given a κ-bit seed seedi ∈ {0, 1}κ, and Sn is additionally given |C|
bits denoted by auxn. We refer to this information as the state of the parties, and denote the state
of Si by statei. In the online phase of the protocol, each party Si uses seedi to generate its shares of
the {λα}; for 1 ≤ i ≤ n − 1, party Si also uses seedi to generate its shares of the {λα,β}. Party Sn
uses auxn as its shares of the {λα,β}.
Protocol execution. Note that in our setting, where all parties are semi-honest, we can perform
public reconstruction of a shared value [x] by simply having each party broadcast its share.
We assume the parties begin the protocol holding a masked value ˆzα for each input wire α. (In
our context these masked values will be provided to the parties by the prover who is simulating
execution of the protocol.) These masked values, along with the corresponding {λα}, deﬁne an
eﬀective input to the protocol. During the online phase of the protocol, the parties inductively
compute ˆzα for all wires in the circuit. Speciﬁcally, for each gate of the circuit with input wires
α, β and output wire γ, where the parties already hold ˆzα, ˆzβ, the parties do:
5
• If the gate is an XOR gate, then the parties locally compute ˆzγ := ˆzα ⊕ ˆzβ.
• If the gate is an AND gate, the parties locally compute
[s] := ˆzα[λβ] ⊕ ˆzβ[λα] ⊕ [λα,β] ⊕ [λγ],
and then publicly reconstruct s. Finally, they compute ˆzγ := s ⊕ ˆzα ˆzβ. One can verify that
ˆzγ = zγ ⊕ λγ.
Once the parties have computed ˆzα for the output wire α, the output value zα is computed by
publicly reconstructing λα and then setting zα := ˆzα ⊕ λα.
We remark that the online phase of this protocol is deterministic. Also observe that all com-
munication is due to share reconstruction:
for a circuit with |C| AND gates, at most |C| + 1
share reconstructions are needed. We will see in the following sections that these properties are
advantageous for our application.
2.2 Our Basic HVZK Proof
In this section we describe a basic, 5-round HVZK proof based on the MPC protocol from the
previous section. We defer discussion of further optimizations to the following section, and a
description of a 3-round variant to Section 2.4.
In this section, H is a collision-resistant hash function.
Notation.
(Later in the paper, we
will model H as a random oracle.) We let Com denote a non-interactive2 commitment scheme,
where a commitment to a value x is generated by choosing a uniform r ∈ {0, 1}κ and computing
com := Com(x; r); decommitment is done by simply revealing x and r. Computational binding and
hiding suﬃces.
Overview. Recall from Section 1.2 that, because we rely on an MPC protocol Π designed in
the preprocessing model, we modify the “MPC-in-the-head” approach and construct a 5-round
proof of the following format: First, the prover commits to m executions of the preprocessing
phase, where each such commitment includes a commitment to the state of each party. The veriﬁer
then challenges the prover to open all-but-one of those executions, and veriﬁes that all the state
information given to the parties in the opened executions is correct. The remaining (unopened)
execution of the preprocessing phase is then used by the prover to simulate the online phase of the
n-party protocol Π on a shared input w, and the prover commits to the view of each party in this
execution. The veriﬁer then chooses all-but-one of the parties to be opened; for each opened party,
the prover opens that party’s state from the preprocessing phase as well as its view from the online
phase. The veriﬁer then checks consistency of the parties’ views as well as correct behavior. We
provide details about each of these steps next.
Checking the preprocessing phase. Recall from the previous section that, following the pre-
processing phase, the state of party Si for 1 ≤ i ≤ n− 1 is a seed seedi, while the state of party Sn is
a seed seedn along with a |C|-bit string auxn. Thus, in a naive implementation of the idea outlined
above, for each execution of the preprocessing phase the prover would send (com1, . . . , comn), where
comi is a commitment to the state of Si. Then, for each challenged execution of the preprocessing
phase, the prover would send seed1, . . . , seedn, auxn, r1, . . . , rn, where ri denotes the randomness
2We could also use a two-round commitment scheme by adding one additional round to the proof system.
6
An HVZK proof
Inputs: Both parties have a circuit C; the prover also holds w with C(w) = 1. Values m, n
are parameters of the protocol.
Round 1 For each j ∈ [m], the prover emulates the preprocessing phase as follows:
1. Choose uniform seed∗
j ∈ {0, 1}κ and use it to generate values seedj,1, rj,1,
. . .,
as described in the text. For i =
|C|
seedj,n, rj,n. Also compute auxj,n ∈ {0, 1}
1, . . . , n − 1, let statej,i := seedj,i; let statej,n := seedj,n(cid:107)auxj,n.
2. For i ∈ [n], compute comj,i := Com(statej,i; rj,i).
3. Compute hj := H(comj,1, . . . , comj,n).
Compute h := H(h1, . . . , hm) and send h to the veriﬁer.
Round 2 The veriﬁer chooses uniform c ∈ [m] and sends it to the prover.
Round 3 The prover sends {seed∗
j}j(cid:54)=c to the veriﬁer.
The prover simulates the online phase of the n-party protocol Π (as described in the text)
using the state generated by the cth preprocessing phase, beginning by computing the
masked values {ˆzα} for the input wires (based on w and the {λα} deﬁned by the cth prepro-
cessing phase). Let msgsi denote the messages broadcast by Si in the protocol execution.
The prover sends the initial masked values {ˆzα} as well as h(cid:48) := H(msgs1, . . . , msgsn) to
the veriﬁer.
Round 4 The veriﬁer chooses uniform p ∈ [n] and sends it to the prover.
Round 5 The prover sends {statec,i, rc,i}i(cid:54)=p, comc,p, and msgsp.
Veriﬁcation The veriﬁer accepts iﬀ all the following checks succeed:
hc := H(comc,1, . . . , comc,n).
1. For i (cid:54)= p, the veriﬁer uses statec,i and rc,i to compute comc,i.
2. For j (cid:54)= c, the veriﬁer uses seed∗
checks that h ?= H(h1, . . . , hm).
j to compute hj as an honest prover would. It then
It then computes
3. The veriﬁer simulates the online phase of Π among the {Si}i(cid:54)=p using {statec,i}i(cid:54)=p,
masked input-wire values {ˆzα}, and msgsp. This yields {msgsi}i(cid:54)=p and an output
bit b. The veriﬁer checks that b ?= 1.
4. The veriﬁer checks that h(cid:48) ?= H(msgs1, . . . , msgsn).
Figure 1: Our basic HVZK proof.
used for the ith commitment. For the unchallenged execution (used for the subsequent execu-
tion of Π), the prover will be able to decommit to the states of any subset of the parties. The
7
communication complexity of this approach is O(m|C| + mnκ).
of veriﬁcation in Figure 1):
We improve the communication complexity in several ways (cf. Round 1 and steps (1) and (2)
1. The prover computes H(com1, . . . , comn), and then sends the hash of the results from all m
executions; thus, it sends just a single hash value to the veriﬁer.
2. When opening a challenged execution, it is unnecessary for the prover to send auxn since
the correct value of auxn can be computed from seed1, . . . , seedn. This gives an asymptotic
improvement in the communication in this step.
3. By generating the {seedi} and the {ri} from a “master” seed seed∗
open a challenged execution of the preprocessing phase by simply sending seed∗.
∈ {0, 1}κ, the prover can
The overall communication complexity of the initial checking phase can thus be reduced to O(mκ),
which is independent of |C| and n.
Checking the online execution. An execution of our protocol proceeds gate-by-gate, with
the processing of each AND gate requiring reconstruction of one shared value. Although the
communication complexity of share reconstruction in our protocol is n bits (one bit per party),
for our purposes we do not need the prover to send n bits per gate in order to prove consistent
execution. This is because the veriﬁer only needs to obtain the protocol messages sent by the
(single) unopened party in order to check the execution of the n − 1 opened parties. Thus, it
suﬃces for the prover to send just a single bit per AND gate.
In addition to the protocol messages sent by the unopened party, the prover also needs to reveal
the state (from the preprocessing phase) of every opened party. For each opened party Si, i (cid:54)= n,
this involves just O(κ) bits; if Sn is opened then this requires |C| + O(κ) bits due to auxn.
In
either case the marginal communication complexity per AND gate is independent of the number of
parties n.
The above ideas (with a few optimizations) are encapsulated in Figure 1. Security of the scheme
is given by the following theorem.
Theorem 2.1. Let H be collision-resistant, and Com be a secure commitment scheme. The protocol
in Figure 1 is an honest-veriﬁer ZKPoK with soundness/knowledge error max{ 1
Proof. Completeness of the protocol is immediate, and we thus focus on proving honest-veriﬁer
zero knowledge and soundness.
m , 1
n}.
Honest-veriﬁer zero knowledge follows easily from semi-honest security of Π (for corruption of
any n − 1 parties) and hiding of the commitment scheme. Speciﬁcally, if we let SimΠ denote a
simulator for Π, then we can construct an honest-veriﬁer zero-knowledge simulator for our protocol
as follows:
• Choose uniform c ∈ [m] and p ∈ [n].
• Run SimΠ to simulate the views of parties {Si}i(cid:54)=p in an execution of Π when evaluating C
with output 1. This results in values {statei}i(cid:54)=p, masked input-wire values {ˆzα}, and msgsp.
From the respective views, {msgsi}i(cid:54)=p can be computed. The simulator computes h(cid:48) as the
honest prover would.
8
• For j (cid:54)= c, the simulator computes hj exactly as the honest prover would. For i (cid:54)= p, the
simulator sets statec,i := statei, chooses uniform rc,i, and computes comc,i as the honest prover
would. It computes comc,p as a commitment to a 0-string of the appropriate length. It then
computes hc and h as the honest prover would.
• The simulator outputs the transcript with h, c, {seed∗
j}j(cid:54)=c, {ˆzα}, h(cid:48), p, {statec,i, rc,i}i(cid:54)=p,
comc,p, and msgsp.
A straightforward hybrid argument shows that transcripts output by the simulator are computa-
tionally indistinguishable from transcripts of real executions of the protocol with an honest veriﬁer.
We next show that given accepting transcripts for challenges (c, p), (c(cid:48), (cid:63)), and (c, p(cid:48)), with c (cid:54)= c(cid:48)
and p (cid:54)= p(cid:48), it is possible to extract a witness w for which C(w) = 1 unless there is a hash collision
or binding of the commitment scheme fails. It follows using standard techniques that the protocol
has soundness/knowledge error max{ 1
In the discussion that follows we assume for simplicity that no hash collisions occur and that
binding of the commitment scheme never fails. From the accepting transcript with challenges (c(cid:48), (cid:63)),
we can compute for any c (cid:54)= c(cid:48) values statec,1, . . . , statec,n that are mutually consistent (i.e., are a
correct outcome of the preprocessing phase); moreover, those values are equal to the corresponding
values sent in round 5 of the other two accepting transcripts (with initial challenge c). These values
of the state deﬁne a value λα for each input wire α; from these and the masked inputs {ˆzα} used
in either of the other accepting transcripts we may compute an eﬀective input w.
m , 1
n}.
We now show that C(w) = 1:
• From the transcript with challenges (c, p), we obtain the state of all parties besides Sp; these
will be exactly equal to the values {statec,i}i(cid:54)=p computed above. We also derive {msgsi}i∈[n].
Moreover, these values are all consistent with an honest execution of Π by parties {Si}i(cid:54)=p
resulting in output 1.
• From the transcript with challenges (c, p(cid:48)), we can obtain {statec,i}i(cid:54)=p(cid:48) along with protocol
messages {msgsi}i∈[n] that must be equal to those obtained above. These values are consistent
with an honest execution of Π by parties {Si}i(cid:54)=p(cid:48) resulting in output 1.
Since the masked input-wire values {ˆzα} are ﬁxed in the above, the {statec,i}i∈[n] and the {msgsi}i∈[n]
must all be mutually consistent with an honest execution of Π, beginning with correct state and
eﬀective input w, resulting in output 1. This implies C(w) = 1.
2.3 Additional Optimizations
Here we describe some additional optimizations that can be used to further improve the concrete
performance of our protocol.
Reducing the number of random seeds. In the cth emulation of the preprocessing phase, the
prover generates n seeds seedc,1, . . ., seedc,n from a master seed seed∗
c, commits to the n generated
seeds, and then sends n − 1 of those seeds to the veriﬁer. The second step requires (n − 1) · κ bits
of communication.
Motivated by the NNL scheme for stateless revocation [39], we observe that we can reduce
the communication by generating the seeds in a more structured way. Namely, imagine labeling
the root of a binary tree of depth log n with seed∗
c, and then inductively labeling the children
9
ρ = 128
ρ = 256
n
4
8
16