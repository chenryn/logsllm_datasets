成熟的系统同样倾向于考虑不太可能的事情出错的可能性，并管理这种风险。例如，HDFS 和 Amazon S3 等大规模储存系统并不完全信任磁碟：它们执行后台程序持续回读档案，并将其与其他副本进行比较，并将档案从一个磁碟移动到另一个，以便降低静默损坏的风险【67】。
如果你想确保你的资料仍然存在，你必须真正读取它并进行检查。大多数时候它们仍然会在那里，但如果不是这样，你一定想尽早知道答案，而不是更晚。按照同样的原则，不时地尝试从备份中恢复是非常重要的 —— 否则当你发现备份损坏时，你可能已经遇到了资料丢失，那时候就真的太晚了。不要盲目地相信它们全都管用。
#### 验证的文化
像 HDFS 和 S3 这样的系统仍然需要假设磁碟大部分时间都能正常工作 —— 这是一个合理的假设，但与它们 **始终** 能正常工作的假设并不相同。然而目前还没有多少系统采用这种 “信任但是验证” 的方式来持续审计自己。许多人认为正确性保证是绝对的，并且没有为罕见的资料损坏的可能性做过准备。我希望未来能看到更多的 **自我验证（self-validating）** 或 **自我审计（self-auditing）** 系统，不断检查自己的完整性，而不是依赖盲目的信任【68】。
我担心 ACID 资料库的文化导致我们在盲目信任技术（如事务机制）的基础上开发应用，而忽视了这种过程中的任何可审计性。由于我们所信任的技术在大多数情况下工作得很好，通常会认为审计机制并不值得投资。
但随之而来的是，资料库的格局发生了变化：在 NoSQL 的旗帜下，更弱的一致性保证成为常态，更不成熟的储存技术越来越被广泛使用。但是由于审计机制还没有被开发出来，尽管这种方式越来越危险，我们仍不断在盲目信任的基础上构建应用。让我们想一想如何针对可审计性而设计吧。
#### 为可审计性而设计
如果一个事务在一个数据库中改变了多个物件，在这一事实发生后，很难说清这个事务到底意味著什么。即使你捕获了事务日志（请参阅 “[变更资料捕获](ch11.md#变更资料捕获)”），各种表中的插入、更新和删除操作并不一定能清楚地表明 **为什么** 要执行这些变更。决定这些变更的是应用逻辑中的呼叫，而这一应用逻辑稍纵即逝，无法重现。
相比之下，基于事件的系统可以提供更好的可审计性。在事件溯源方法中，系统的使用者输入被表示为一个单一不可变事件，而任何其导致的状态变更都衍生自该事件。衍生可以实现为具有确定性与可重复性，因而相同的事件日志透过相同版本的衍生程式码时，会导致相同的状态变更。
显式处理资料流（请参阅 “[批处理输出的哲学](ch10.md#批处理输出的哲学)”）可以使资料的 **来龙去脉（provenance）** 更加清晰，从而使完整性检查更具可行性。对于事件日志，我们可以使用杂凑来检查事件储存没有被破坏。对于任何衍生状态，我们可以重新执行从事件日志中衍生它的批处理器与流处理器，以检查是否获得相同的结果，或者，甚至并行执行冗余的衍生流程。
具有确定性且定义良好的资料流，也使除错与跟踪系统的执行变得容易，以便确定它 **为什么** 做了某些事情【4,69】。如果出现意想之外的事情，那么重现导致意外事件的确切事故现场的诊断能力 —— 一种时间旅行除错功能是非常有价值的。
#### 端到端原则重现
如果我们不能完全相信系统的每个元件都不会损坏 —— 每一个硬体都没缺陷，每一个软体都没有 Bug —— 那我们至少必须定期检查资料的完整性。如果我们不检查，我们就不能发现损坏，直到无可挽回地导致对下游的破坏时，那时候再去追踪问题就要难得多，且代价也要高的多。
检查资料系统的完整性，最好是以端到端的方式进行（请参阅 “[资料库的端到端原则](#资料库的端到端原则)”）：我们能在完整性检查中涵盖的系统越多，某些处理阶中出现不被察觉损坏的机率就越小。如果我们能检查整个衍生资料管道端到端的正确性，那么沿著这一路径的任何磁碟、网路、服务以及演算法的正确性检查都隐含在其中了。
持续的端到端完整性检查可以不断提高你对系统正确性的信心，从而使你能更快地进步【70】。与自动化测试一样，审计提高了快速发现错误的可能性，从而降低了系统变更或新储存技术可能导致损失的风险。如果你不害怕进行变更，就可以更好地充分演化一个应用，使其满足不断变化的需求。
#### 用于可审计资料系统的工具
目前，将可审计性作为顶层关注点的资料系统并不多。一些应用实现了自己的审计机制，例如将所有变更记录到单独的审计表中，但是确保审计日志与资料库状态的完整性仍然是很困难的。可以定期使用硬体安全模组对事务日志进行签名来防止篡改，但这无法保证正确的事务一开始就能进入到日志中。
使用密码学工具来证明系统的完整性是十分有趣的，这种方式对于宽泛的硬体与软体问题，甚至是潜在的恶意行为都很稳健有效。加密货币、区块链、以及诸如比特币、以太坊、Ripple、Stellar 的分散式账本技术已经迅速出现在这一领域【71,72,73】。
我没有资格评论这些技术用于货币，或者合同商定机制的价值。但从资料系统的角度来看，它们包含了一些有趣的想法。实质上，它们是分散式资料库，具有资料模型与事务机制，而不同副本可以由互不信任的组织托管。副本不断检查其他副本的完整性，并使用共识协议对应当执行的事务达成一致。
我对这些技术的拜占庭容错方面有些怀疑（请参阅 “[拜占庭故障](ch8.md#拜占庭故障)”），而且我发现 **工作证明（proof of work）** 技术非常浪费（比如，比特币挖矿）。比特币的交易吞吐量相当低，尽管更多是出于政治与经济原因而非技术上的原因。不过，完整性检查的方面是很有趣的。
密码学审计与完整性检查通常依赖 **默克尔树（Merkle tree）**【74】，这是一颗杂凑值的树，能够用于高效地证明一条记录出现在一个数据集中（以及其他一些特性）。除了炒作的沸沸扬扬的加密货币之外，**证书透明性（certificate transparency）** 也是一种依赖 Merkle 树的安全技术，用来检查 TLS/SSL 证书的有效性【75,76】。
我可以想象，那些在证书透明度与分散式账本中使用的完整性检查和审计算法，将会在通用资料系统中得到越来越广泛的应用。要使得这些演算法对于没有密码学审计的系统同样可伸缩，并尽可能降低效能损失还需要一些工作。但我认为这是一个值得关注的有趣领域。
## 做正确的事情
在本书的最后部分，我想退后一步。在本书中，我们考察了各种不同的资料系统架构，评价了它们的优点与缺点，并探讨了构建可靠，可伸缩，可维护应用的技术。但是，我们忽略了讨论中一个重要而基础的部分，现在我想补充一下。
每个系统都服务于一个目的；我们采取的每个举措都会同时产生期望的后果与意外的后果。这个目的可能只是简单地赚钱，但其对世界的影响，可能会远远超出最初的目的。我们，建立这些系统的工程师，有责任去仔细考虑这些后果，并有意识地决定，我们希望生活在怎样的世界中。
我们将资料当成一种抽象的东西来讨论，但请记住，许多资料集都是关于人的：他们的行为，他们的兴趣，他们的身份。对待这些资料，我们必须怀著人性与尊重。使用者也是人类，人类的尊严是至关重要的。
软体开发越来越多地涉及重要的道德抉择。有一些指导原则可以帮助软体工程师解决这些问题，例如 ACM 的软体工程道德规范与专业实践【77】，但实践中很少会讨论这些，更不用说应用与强制执行了。因此，工程师和产品经理有时会对隐私与产品潜在的负面后果抱有非常傲慢的态度【78,79,80】。