# 期中大作业丨题目以及解答剖析你好，今天是期中大作业讲解课。诚如一位同学所言，这次的大作业不是在考察网络编程的细节，而是在考如何使用系统API 完成 cd、pwd、ls 等功能。不过呢，网络编程的框架总归还是要掌握的。我研读了大部分同学的代码，基本上是做得不错的，美中不足的是能动手完成代码编写和调试的同学偏少。我还是秉持一贯的看法，计算机程序设计是一门实战性很强的学科，如果只是单纯地听讲解，没有自己动手这一环，对知识的掌握总归还是差那么点意思。代码我已经 push到[这里](https://github.com/froghui/yolanda/tree/master/mid-homework)，你可以点进链接看一下。
## 客户端程序废话少说，我贴下我的客户端程序：    #include "lib/common.h"#define  MAXLINE     1024 int main(int argc, char **argv) {    if (argc != 3) {        error(1, 0, "usage: tcp_client  ");    }    int port = atoi(argv[2]);    int socket_fd = tcp_client(argv[1], port);     char recv_line[MAXLINE], send_line[MAXLINE];    int n;     fd_set readmask;    fd_set allreads;    FD_ZERO(&allreads);    FD_SET(0, &allreads);    FD_SET(socket_fd, &allreads);     for (;;) {        readmask = allreads;        int rc = select(socket_fd + 1, &readmask, NULL, NULL, NULL);         if (rc `{=html}
## 服务器端程序下面是我写的服务器端程序：    #include "lib/common.h"static int count; static void sig_int(int signo) {    printf("\nreceived %d datagrams\n", count);    exit(0);} char *run_cmd(char *cmd) {    char *data = malloc(16384);    bzero(data, sizeof(data));    FILE *fdp;    const int max_buffer = 256;    char buffer[max_buffer];    fdp = popen(cmd, "r");    char *data_index = data;    if (fdp) {        while (!feof(fdp)) {            if (fgets(buffer, max_buffer, fdp) != NULL) {                int len = strlen(buffer);                memcpy(data_index, buffer, len);                data_index += len;            }        }        pclose(fdp);    }    return data;} int main(int argc, char **argv) {    int listenfd;    listenfd = socket(AF_INET, SOCK_STREAM, 0);     struct sockaddr_in server_addr;    bzero(&server_addr, sizeof(server_addr));    server_addr.sin_family = AF_INET;    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);    server_addr.sin_port = htons(SERV_PORT);     int on = 1;    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));     int rt1 = bind(listenfd, (struct sockaddr *) &server_addr, sizeof(server_addr));    if (rt1 `{=html}select 函数就是这样一种常见的 I/O多路复用技术，我们将在后面继续讲解其他的多路复用技术。使用 select函数，通知内核挂起进程，当一个或多个 I/O事件发生后，控制权返还给应用程序，由应用程序进行 I/O 事件的处理。这些 I/O 事件的类型非常多，比如：-   标准输入文件描述符准备好可以读。-   监听套接字准备好，新的连接已经建立成功。-   已连接套接字准备好可以写。-   如果一个 I/O 事件等待超过了 10 秒，发生了超时事件。
## select 函数的使用方法select 函数的使用方法有点复杂，我们先看一下它的声明：    int select(int maxfd, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout); 返回：若有就绪描述符则为其数目，若超时则为 0，若出错则为 -1在这个函数中，n 表示的是待测试的描述符基数，它的值是待测试的最大描述符加1。比如现在的 select 待测试的描述符集合是{0,1,4}，那么 maxfd 就是5，为啥是 5，而不是 4 呢? 我会在下面进行解释。紧接着的是三个描述符集合，分别是读描述符集合 readset、写描述符集合writeset 和异常描述符集合exceptset，这三个分别通知内核，在哪些描述符上检测数据可以读，可以写和有异常发生。那么如何设置这些描述符集合呢？以下的宏可以帮助到我们。    void FD_ZERO(fd_set *fdset);      void FD_SET(int fd, fd_set *fdset);  void FD_CLR(int fd, fd_set *fdset);   int  FD_ISSET(int fd, fd_set *fdset);如果你刚刚入门，理解这些宏可能有些困难。没有关系，我们可以这样想象，下面一个向量代表了一个描述符集合，其中，这个向量的每个元素都是二机制数中的0 或者 1。    a[maxfd-1], ..., a[1], a[0我们按照这样的思路来理解这些宏：-   FD_ZERO 用来将这个向量的所有元素都设置成 0；-   FD_SET 用来把对应套接字 fd 的元素，a\[fd\] 设置成 1；-   FD_CLR 用来把对应套接字 fd 的元素，a\[fd\] 设置成 0；-   FD_ISSET 对这个向量进行检测，判断出对应套接字的元素 a\[fd\] 是 0    还是 1。其中 0 代表不需要处理，1 代表需要处理。怎么样，是不是感觉豁然开朗了？实际上，很多系统是用一个整型数组来表示一个描述字集合的，一个 32位的整型数可以表示 32 个描述字，例如第一个整型数表示 0-31描述字，第二个整型数可以表示 32-63 描述字，以此类推。这个时候再来理解为什么描述字集合{0,1,4}，对应的 maxfd 是 5，而不是4，就比较方便了。因为这个向量对应的是下面这样的：    a[4],a[3],a[2],a[1],a[0待测试的描述符个数显然是 5， 而不是 4。三个描述符集合中的每一个都可以设置成空，这样就表示不需要内核进行相关的检测。最后一个参数是 timeval 结构体时间：    struct timeval {  long   tv_sec; /* seconds */  long   tv_usec; /* microseconds */};这个参数设置成不同的值，会有不同的可能：第一个可能是设置成空 (NULL)，表示如果没有 I/O 事件发生，则 select一直等待下去。第二个可能是设置一个非零的值，这个表示等待固定的一段时间后从 select阻塞调用中返回，这在[第 12讲](https://time.geekbang.org/column/article/127900)超时的例子里曾经使用过。第三个可能是将 tv_sec 和 tv_usec 都设置成0，表示根本不等待，检测完毕立即返回。这种情况使用得比较少。
## 程序例子下面是一个具体的程序例子，我们通过这个例子来理解 select 函数。    int main(int argc, char **argv) {    if (argc != 2) {        error(1, 0, "usage: select01 ");    }    int socket_fd = tcp_client(argv[1], SERV_PORT);     char recv_line[MAXLINE], send_line[MAXLINE];    int n;     fd_set readmask;    fd_set allreads;    FD_ZERO(&allreads);    FD_SET(0, &allreads);    FD_SET(socket_fd, &allreads);     for (;;) {        readmask = allreads;        int rc = select(socket_fd + 1, &readmask, NULL, NULL, NULL);         if (rc `{=html}    #define    POLLIN    0x0001    /* any readable data available */#define    POLLPRI   0x0002    /* OOB/Urgent readable data */#define    POLLOUT   0x0004    /* file descriptor is writeable */和 select 非常不同的地方在于，poll每次检测之后的结果不会修改原来的传入值，而是将结果保留在 revents字段中，这样就不需要每次检测完都得重置待检测的描述字和感兴趣的事件。我们可以把revents 理解成"returned events"。events 类型的事件可以分为两大类。第一类是可读事件，有以下几种：    #define POLLIN     0x0001    /* any readable data available */#define POLLPRI    0x0002    /* OOB/Urgent readable data */#define POLLRDNORM 0x0040    /* non-OOB/URG data available */#define POLLRDBAND 0x0080    /* OOB/Urgent readable data */一般我们在程序里面有 POLLIN 即可。套接字可读事件和 select 的 readset基本一致，是系统内核通知应用程序有数据可以读，通过 read函数执行操作不会被阻塞。第二类是可写事件，有以下几种：    #define POLLOUT    0x0004    /* file descriptor is writeable */#define POLLWRNORM POLLOUT   /* no write type differentiation */#define POLLWRBAND 0x0100    /* OOB/Urgent data can be written */一般我们在程序里面统一使用 POLLOUT。套接字可写事件和 select 的 writeset基本一致，是系统内核通知套接字缓冲区已准备好，通过 write函数执行写操作不会被阻塞。以上两大类的事件都可以在"returnedevents"得到复用。还有另一大类事件，没有办法通过 poll向系统内核递交检测请求，只能通过"returnedevents"来加以检测，这类事件是各种错误事件。    #define POLLERR    0x0008    /* 一些错误发送 */#define POLLHUP    0x0010    /* 描述符挂起 */#define POLLNVAL   0x0020    /* 请求的事件无效 */我们再回过头看一下 poll 函数的原型。参数 nfds 描述的是数组 fds的大小，简单说，就是向 poll 申请的事件检测的个数。最后一个参数 timeout，描述了 poll 的行为。如果是一个 \0 的数，表示 poll调用方等待指定的毫秒数后返回。关于返回值，当有错误发生时，poll 函数的返回值为-1；如果在指定的时间到达之前没有任何事件发生，则返回0，否则就返回检测到的事件个数，也就是"returned events"中非 0的描述符个数。poll 函数有一点非常好，如果我们**不想对某个 pollfd结构进行事件检测，**可以把它对应的 pollfd 结构的 fd成员设置成一个负值。这样，poll 函数将忽略这样的 events事件，检测完成以后，所对应的"returned events"的成员值也将设置为 0。和 select 函数对比一下，我们发现 poll 函数和 select 不一样的地方就是，在select 里面，文件描述符的个数已经随着 fd_set的实现而固定，没有办法对此进行配置；而在 poll 函数里，我们可以控制pollfd 结构的数组大小，这意味着我们可以突破原来 select函数最大描述符的限制，在这种情况下，应用程序调用者需要分配 pollfd数组并通知 poll 函数该数组的大小。
## 基于 poll 的服务器程序下面我们将开发一个基于 poll的服务器程序。这个程序可以同时处理多个客户端连接，并且一旦有客户端数据接收后，同步地回显回去。这已经是一个颇具高并发处理的服务器原型了，再加上后面讲到的非阻塞I/O 和多线程等技术，基本上就是可使用的准生产级别了。所以，让我们打起精神，一起来看这个程序。    #define INIT_SIZE 128 int main(int argc, char **argv) {    int listen_fd, connected_fd;    int ready_number;    ssize_t n;    char buf[MAXLINE];    struct sockaddr_in client_addr;     listen_fd = tcp_server_listen(SERV_PORT);     // 初始化 pollfd 数组，这个数组的第一个元素是 listen_fd，其余的用来记录将要连接的 connect_fd    struct pollfd event_set[INIT_SIZE];    event_set[0].fd = listen_fd;    event_set[0].events = POLLRDNORM;     // 用 -1 表示这个数组位置还没有被占用    int i;    for (i = 1; i  0) {                    if (write(socket_fd, buf, n)  quitConnection closed.客户端 2：    telnet 127.0.0.1 43211Trying 127.0.0.1...Connected to 127.0.0.1.Escape character is '^]'.bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb^]  telnet> quitConnection closed.可以看到，这两个客户端互不影响，每个客户端输入的字符很快会被回显到客户端屏幕上。一个客户端断开连接，也不会影响到其他客户端。
## 总结poll 是另一种在各种 UNIX 系统上被广泛支持的 I/O多路复用技术，虽然名声没有 select 那么响，能力一点不比 select差，而且因为可以突破 select文件描述符的个数限制，在高并发的场景下尤其占优势。这一讲我们编写了一个基于poll 的服务器程序，希望你从中学会 poll 的用法。
## 思考题和往常一样，给大家留两道思考题：第一道，在我们的程序里 event_set 数组的大小固定为INIT_SIZE，这在实际的生产环境肯定是需要改进的。你知道如何改进吗？第二道，如果我们进行了改进，那么接下来把连接描述字 connect_fd 也加入到event_set 里，如何配合进行改造呢？欢迎你在评论区写下你的思考，也欢迎把这篇文章分享给你的朋友或者同事，一起交流一下。![](Images/5a282807b2a1ff091b7f803e8cef3429.png){savepage-src="https://static001.geekbang.org/resource/image/bf/25/bfc96ae0d8f839919b9d9866cfb8b025.jpg"}
# 22 \| 非阻塞I/O：提升性能的加速器你好，我是盛延敏，这里是网络编程实战第 22 讲，欢迎回来。在性能篇的前两讲中，我分别介绍了 select 和 poll 两种不同的 I/O多路复用技术。在接下来的这一讲中，我将带大家进入非阻塞 I/O模式的世界。事实上，非阻塞 I/O 配合 I/O多路复用，是高性能网络编程中的常见技术。