### 优化后的文本

#### 表3. 使用VMProtect混淆的合成程序的结果
| 指令跟踪 (指令计数) | 所有类型 | 控制流 |
|---------------------|-----------|---------|
| 字节码程序 (指令计数) | 所有类型 | 控制流 |
| 虚拟指令集架构 | 1操作数 | 控制流 (条件) | 0操作数 |
| 497 | 442 | 5709 | 1 | 7 | 54 |
| 497 | 442 | 785 | 1 | 7 | 8 |
| 16 | 18 | 18 | 1 (0) | 2 (0) | 2 (0) |
| 4 | 4 | 4 | 8 | 9 | 9 |
| 2操作数 | 15 | 16 | 18 |
| 2操作数 | 4 | 5 | 5 |

| 程序 | synth1 | synth2 | synth3 |
|-------|---------|---------|---------|
| 程序 | synth1 | synth2 | synth3 |

(a) 原始x86 CFG  
(b) 字节码CFG (Code Virtualizer)  
(c) 字节码CFG (VMProtect)

图4. synth3测试程序的x86和字节码CFG比较

在字节码执行跟踪中，控制流指令的数量与原始x86执行跟踪中的数量相同。这表明Rotalumé能够提取原始程序的控制流信息。

表3显示，对于synth2和synth3，Rotalumé提取的VMProtect虚拟ISA没有条件控制流指令，这与Code Virtualizer的结果不同。我们通过分析VMProtect保护软件的x86执行跟踪，并将其与Rotalumé提供的字节码信息进行比较，研究了这一差异。我们发现，Rotalumé正确识别了模拟器的解码、分发和执行例程。通过对执行例程的跟踪进行手动分析，我们没有找到任何x86条件分支指令。这意味着字节码程序跟踪中没有条件跳转。通过仔细分析控制转移指令之前的指令语义，我们确认VMProtect通过动态计算目标地址并使用单个跳转指令来模拟条件分支。

图4显示，Rotalumé为synth3提取的控制流图与原始x86程序非常相似。图4(a)显示了原始x86程序的CFG，其中包含一个带有两个条件分支的循环。该图显示基本块B11在执行过程中未被执行。图4(b)显示了由Rotalumé从Code Virtualizer字节码程序跟踪中提取的CFG。这两个CFG展示了相同的控制流语义。有趣的是，我们还能够识别出从基本块B7出发的一个未探索路径。这是可能的，因为Code Virtualizer的字节码语言具有被Rotalumé识别但未执行的条件分支指令。这表明我们的方法的一个关键优势是：其他分析（如多路径探索）可以选择性地应用于探索仿真恶意软件字节码中的这些路径，而不是整个模拟器。

图4(c)是VMProtect字节码跟踪的CFG。由于我们发现VMProtect的字节码没有显式的条件分支，因此无法提供关于跟踪中未执行的可能路径的信息。然而，我们可以识别跟踪中的动态计算控制流指令，并标记需要应用可能的分支目标地址分析的位置。因此，我们仍然可以揭示字节码程序的控制流信息。CFG显示了循环和条件的存在，但基本块的数量比原始CFG少。这可能是由于VMProtect对字节码进行了优化。

### 5.2 实际（未打包）程序

接下来，我们测试了一个实际程序，该程序通过与原始x86程序对比来验证提取的字节码信息。我们选择了一个未打包的恶意软件程序，因为它不能自修改代码。我们随机选择了被Avira Antivir反病毒软件识别为特洛伊木马的Killav.PS恶意软件。然后，我们将VMProtect应用于该二进制文件。由于Code Virtualizer需要一个在编译时生成的.map文件，而恶意软件通常没有这个文件，因此我们无法在真实软件上使用Code Virtualizer。表4显示了Rotalumé在不同层次的混淆下对该二进制文件的使用结果。

我们选择了恶意软件中的一个大型函数，并使用VMProtect将其转换为字节码。表格显示，x86代码大小在混淆后增加，因为新二进制文件还包含了模拟器的代码。Rotalumé提取了字节码跟踪和混淆函数的动态CFG。我们将结果与原始x86版本的混淆函数进行了比较。尽管字节码版本只有16个基本块，而原始版本有24个基本块（此处未显示；表格显示了包括模拟器在内的整个二进制文件的大小），但控制流属性非常相似。由于篇幅限制，CFG未在此处列出，但在更详细的技术报告[28]中可以找到。从CFG来看，一些基本块可能因VMProtect对字节码的优化而合并，但类似的循环和分支仍然可识别。这表明Rotalumé确实正确提取了字节码的语法和语义。我们测试了另一个混淆版本的恶意软件，其中我们选择性地混淆了另外四个函数。在这种情况下，x86代码增加较少，Rotalumé成功提取了这些函数的字节码语法和语义。

最后，我们在应用仿真到合法程序CMD.EXE后测试了Rotalumé。表5列出了结果。我们获得的字节码CFG包含31个基本块，而原始函数中有36个基本块。图5显示了CMD.EXE中一个大型函数的控制流图的两个相似部分。图5(a)显示了原始x86代码的部分CFG，图5(b)显示了Rotalumé从VMProtect混淆样本中提取的字节码版本。完整CFG可以在技术报告[28]中找到。我们发现图表的某些部分完全匹配，其他部分的差异可能是由于代码转换和优化的不同。

### 5.3 仿真的恶意软件

接下来，我们在使用基于仿真打包器的真实恶意软件样本上评估了Rotalumé。我们选择了使用Themida、VMProtect和Code Virtualizer这三个已知商业打包器的样本。我们访问了数千个恶意软件样本，并从中识别出使用这三种工具打包的样本。然后，我们对这些恶意软件样本的一个随机子集应用了Rotalumé。

在这三个混淆器中，Themida是最广泛使用的。表6显示了Rotalumé在8个随机选择的样本上的输出结果。我们通过将这些样本提交给VirusTotal[34]并选择AV工具中最常见的名称来获取这些样本的名称。对于每个样本，我们收集了运行20秒后的执行跟踪。表格首先显示了x86执行跟踪的长度。