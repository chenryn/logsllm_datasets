23
27
31
1 (0)
3 (1)
3 (1)
3
4
4
6
8
9
Table 3. Results for synthetic programs obfuscated with VMProtect
Bytecode Trace (inst. count)
All types
C-Flow
Bytecode Program (inst. count)
All types
C-Flow
All types
Virtual Instruction Set Architecture
1 Opr
C-Flow (Cond.)
0 Opr
497
442
5709
1
7
54
497
442
785
1
7
8
16
18
18
1 (0)
2 (0)
2 (0)
4
4
4
8
9
9
2 Opr
15
16
18
2 Opr
4
5
5
Program
synth1
synth2
synth3
Program
synth1
synth2
synth3
(a) Original x86 CFG
(b) Bytecode CFG (Code Virtualizer)
(c) Bytecode CFG (VMProtect)
Figure 4. Comparison of x86 and bytecode CFGs of the synth3 test program
accounted for the same number of control-ﬂow instructions
in the bytecode execution trace as in the original x86
execution trace. This shows that Rotalum´e was able to
extract the control-ﬂow information of the original programs.
Table 3 shows that for both synth2 and synth3, the
VMProtect virtual ISA extracted by Rotalum´e does not
have conditional control-ﬂow instructions, unlike the results
from Code Virtualizer. We investigated this discrepancy by
analyzing the x86 execution traces of VMProtected software
and then comparing with the bytecode information provided
by Rotalum´e. We found that Rotalum´e correctly identiﬁed
the decode, dispatch, and execution routines of the emulator.
We manually analyzed the traces of the execution routines
and did not ﬁnd any x86 conditional branch instruction. This
means that there were no conditional jumps in the bytecode
program traces. By carefully analyzing the semantics of
the instructions before the control-transfer instruction, we
conﬁrmed that VMProtect emulates conditional branches by
dynamically computing the target address and using a single
jump instruction.
Figure 4 shows that the control-ﬂow graphs extracted
by Rotalum´e for synth3 are very similar to that of the
original x86 program. Figure 4(a) shows the original x86
program’s CFG, and it contains a loop with two conditional
104
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:16:46 UTC from IEEE Xplore.  Restrictions apply. 
B0Instructions:7Exec. Count:1B1Instructions:3Exec. Count:11B2Instructions:4Exec. Count:10B3Instructions:12Exec. Count:1B11Instructions:4Exec. Count=0B6Instructions:4Exec. Count:10B10Instructions:4Exec. Count:1B4Instructions:2Exec. Count:10B7Instructions:4Exec. Count:5B8Instructions:3Exec. Count:5B9Instructions:1Exec. Count:10B5Instructions:3Exec. Count:10B0Instructions:83Exec. Count:1B1Instructions:51Exec. Count:11B7Instructions:53Exec. Count:10B8Instructions:147Exec. Count:1unexploredB2Instructions:100Exec. Count:10B9Instructions:92Exec. Count:2B3Instructions:17Exec. Count:10B5Instructions:46Exec. Count:5B6Instructions:62Exec. Count:5B4Instructions:33Exec. Count:10B0Instructions:85Exec. Count:1B1Instructions:446Exec. Count:11B2Instructions:60Exec. Count:10B6Instructions:34Exec. Count:1B3Instructions:77Exec. Count:5B5Instructions:41Exec. Count:5B4Instructions:41Exec. Count:10Table 4. TR/Killav.PS obfuscated by VMProtect
Table 5. Tests on CMD.EXE obfuscated by VMProtect
Description
Dyn. x86 CFG
Dyn. BC CFG
Description
Dyn. x86 CFG
Dyn. BC CFG
Original
1 function packed
5 functions packed
Inst. (BB)
1528 (435)
3618 (738)
4103 (801)
Inst. (BB)
×
2617 (16)
3830 (49)
Original
1 function packed
5 functions packed
Inst. (BB)
8458 (1143)
10429 (1345)
10512 (1394)
Inst. (BB)
×
3488 (31)
12345 (103)
branches. The graph shows that basic block B11 was not
executed during execution. Figure 4(b) shows the CFG of
the Code Virtualizer bytecode program trace as extracted
by Rotalum´e. The two CFGs show identical control-ﬂow
semantics. Interestingly, we also could identify that there
is an unexplored path from basic block B7. This was
possible because Code Virtualizer’s bytecode language has
a conditional branch instruction that was identiﬁed by Ro-
talum´e even though it was not executed. This shows a key
beneﬁt of our approach: other analyses such as multipath
exploration [21] can be selectively applied to explore such
paths in the emulated malware bytecode rather than in the
entire emulator.
The CFG in Figure 4(c) is for the VMProtect bytecode
trace. Since we found that VMProtect’s bytecode has no
explicit conditional branches, we are unable to provide
information about a possible path that was not executed
in the trace. However, we can identify the dynamically
computed control-ﬂow instructions in the trace and mark
where analysis of possible branch target addresses needs
to be applied. Thus, we can still uncover the control-ﬂow
information of the bytecode program. The CFG shows the
existence of the loop and the condition but the number of ba-
sic blocks is fewer than the original CFG. This likely occurs
because VMProtect applies optimization on the bytecode.
5.2. Real (Unpacked) Programs
We next tested on a real program obfuscated with em-
ulation by comparing the extracted bytecode information
against the original x86 program. We selected a malware
program that is not packed because self-modifying code can
not be translated into bytecode. We randomly selected the
Killav.PS malware identiﬁed as a Trojan by Avira Antivir
antivirus software [2]. We then applied VMProtect on the
binary. We were unable to use Code Virtualizer on this
real software because Code Virtualizer requires a .map ﬁle,
which is usually generated at compile time and hence not
available with malware. Table 4 shows the results of using
Rotalum´e with various levels of obfuscation applied to the
binary.
We selected one large function in the malware and used
VMProtect to convert it into bytecode. The table shows
that
the x86 code size grows after obfuscation because
the new binary additionally contains the emulator’s code.
Rotalum´e extracted the bytecode trace and the dynamic CFG
of the obfuscated function. We compared the results with the
original x86 version of the obfuscated function. Although
the bytecode version had only 16 basic blocks compared
to the 24 blocks of the original (not shown here; the table
instead shows the size of the whole binary including the
emulator), the control-ﬂow attributes were very similar. Due
to space limitations, the CFGs are not included here but
may be found in a more extensive technical report [28].
From the CFGs, it seems that some basic blocks may have
been combined due to code optimizations performed on
the bytecode by VMProtect, but similar loops and branches
were identiﬁable. This shows that Rotalum´e indeed correctly
extracted the bytecode syntax and semantics. We tested
another obfuscated version of the malware where we se-
lectively obfuscated four additional functions. In that case,
the x86 code increased less substantially, and Rotalum´e
successfully extracted the bytecode syntax and semantics of
those functions.
Finally, we tested Rotalum´e after applying emulation
to a legitimate program. Using CMD.EXE, we performed
experiments similar to those for the unpacked malware.
Table 5 presents the results. The bytecode CFG that we
obtained contained 31 basic blocks instead of the 36 in the
original function. Figure 5 shows two similar portions of
the control-ﬂow graphs of a large function of CMD.EXE.
We show the original x86 code’s partial CFG in Figure 5(a)
and the bytecode version extracted by Rotalum´e from the
VMProtect obfuscated sample in Figure 5(b). The complete
CFGs of the function can be found in the technical report
[28]. We found that some parts of the graphs matched
perfectly, with differences in other parts likely due to code
transformation and optimization differences.
5.3. Emulated Malware
We next evaluated Rotalum´e on real malware samples
that use emulation based packers. We selected samples that
are packed with Themida, VMProtect, and Code Virtualizer,
the three known commercial packers that use emulation. We
have access to thousands of malware samples, from which
we identiﬁed the ones packed using these three tools. We
then applied Rotalum´e to a randomly selected set of these
malware samples.
Among the three obfuscators, Themida is the most widely
105
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:16:46 UTC from IEEE Xplore.  Restrictions apply. 
Table 6. Malware packed with Themida
Description
Themida5
Themida1
Themida3
Themida7
Themida8
Themida11
Themida13
Themida14
x86
Trace
Dyn. x86
CFG
Inst. (BB)
15.3M 9753 (2156)
1.4M
5961 (1156)
14.8M 10211 (2125)
21.4M 14205 (3529)
3.5M
6011 (2125)
11.1M 9021 (2925)
11.4M 10211 (3194)
17.3M 11492 (2877)
BC
Trace
15232
1339
2142
5171
1534
1784
19642
14219
Dyn. BC
CFG
Inst. (BB)
3421 (57)
1339 (6)
2142 (15)
3042 (28)
1534 (9)
1784 (10)
4142 (65)
3751 (75)
Table 7. Malware packed with VMProtect
Description
x86
Trace
Dyn. x86
CFG
BC
Trace
Win32.KGen.bxp
Win32.KillAV.ahb
Graybird
Win32.Klone.af∗
Win32.Klone.af∗
Inst. (BB)
3.1M
2122 (591)
1.4M 4104 (1156)
131K
823 (275)
4263 (707)
5.0M
3.2M
4123 (484)
1112
1231
2926
1241
1149
Dyn. BC
CFG
Inst. (BB)
1112 (9)
1231 (12)
1584 (18)
1241 (17)
1149 (14)
Table 8. Malware packed with Code Virtualizer
Description
Win32.Delf.Knz∗
Win32.Delf.Knz∗
Win32.Delf.Knz∗
x86
Trace
Dyn. x86
CFG
Inst. (BB)
7.0M 2249 (608)
15.5M 2594 (720)
14.5
2531 (738)
BC
Trace
114526
234012
215892
Dyn. BC
CFG
Inst. (BB)
10054 (343)
25221 (742)
19850 (771)
bytecode CFG. Again, this shows that Themida was not
designed to obfuscate a program completely with emulation.
We then experimented with a group of randomly selected
samples that use VMProtect. We present
the results of
5 samples in Table 7. Rotalum´e was able to detect the
emulation process in each of the samples and produced the
syntactic and semantics information of the bytecode lan-
guage, the bytecode trace, and the CFG. Rotalum´e identiﬁed
18 bytecode instructions in the instruction set for each case.
This matched the output from the synthetic test samples
synth2 and synth3 in Table 3. Interestingly, the syntax
was also the same. Like the Themida samples, these samples
had very small amounts of code emulated. We conjecture
that the malware authors likely had used the demo version
of VMProtect, which only allows conversion of one function
of the binary into bytecode.
We also experimented with recent malware samples that
use Code Virtualizer. Table 8 shows the results. All of the
samples were identiﬁed with the same name in VirusTotal
106
(a) Original x86 CFG
(b) Extracted bytecode CFG (VM-
Protect obfuscated)
Figure 5. The partial dynamic CFGs for the x86 code
and the extracted bytecode of an obfuscated function in
CMD.EXE
used within our malware samples. Themida is known not
to emulate the code of the original program but rather
the unpacking routine. Nevertheless, we wanted to evaluate
whether Rotalum´e can reverse engineer the emulator. Table 6
shows the results of Rotalum´e’s output on 8 randomly
selected samples. We obtained the names of these samples
by submitting them to VirusTotal [34] and selecting the
name that was most common among the AV tools. For each
sample, we gathered the execution trace when running it
for 20 seconds. The table ﬁrst shows the length of the x86