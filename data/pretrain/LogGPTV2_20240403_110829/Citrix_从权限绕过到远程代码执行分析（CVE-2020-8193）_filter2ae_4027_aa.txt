# Citrix 从权限绕过到远程代码执行分析（CVE-2020-8193）
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
近日监测到Citrix 官方发布了Citrix ADC，Citrix Gateway和Citrix SD-WAN WANOP 组件中多个安全漏洞风险通告。  
360灵腾安全实验室判断此次通告中的权限绕过漏洞（CVE-2020-8193）存在远程代码执行风险。该漏洞等级为`高`，利用难度`中`，威胁程度`高`，影响面`广`。
360政企安全客户现可使用 360资产威胁与漏洞管理系统
对该漏洞进行检测，如需帮助可联系[PI:EMAIL](mailto:PI:EMAIL)。
同时，建议使用用户及时安装最新补丁，以免遭受黑客攻击。
## 0x00 漏洞通告详情
Citrix 产品中使用了PHP提供web服务，在其PHP代码中存在多处错误而导致了如下漏洞。
CVE-ID | 漏洞类型 | 影响产品 | 漏洞利用基础  
---|---|---|---  
CVE-2019-18177 | 信息泄漏 | Citrix ADC, Citrix Gateway | 授权VPN用户  
CVE-2020-8187 | 拒绝服务 | Citrix ADC, Citrix Gateway 12.0 & 11.1 | 未授权用户  
CVE-2020-8190 | 用户权限提升 | Citrix ADC, Citrix Gateway | 授权用户  
CVE-2020-8191 | 跨站脚本攻击 | Citrix ADC, Citrix Gateway, Citrix SDWAN WANOP |
未授权用户  
CVE-2020-8193 | 权限绕过 | Citrix ADC, Citrix Gateway, Citrix SDWAN WANOP | 未授权用户  
CVE-2020-8194 | 代码注入 | Citrix ADC, Citrix Gateway, Citrix SDWAN WANOP | 未授权用户  
CVE-2020-8195 | 信息泄漏 | Citrix ADC, Citrix Gateway, Citrix SDWAN WANOP | 授权用户  
CVE-2020-8196 | 信息泄漏 | Citrix ADC, Citrix Gateway, Citrix SDWAN WANOP | 授权用户  
CVE-2020-8197 | 权限提升 | Citrix ADC, Citrix Gateway | 授权用户  
CVE-2020-8198 | 跨站脚本攻击 | Citrix ADC, Citrix Gateway, Citrix SDWAN WANOP |
未授权用户  
CVE-2020-8199 | 本地权限提升 | Citrix Gateway Plug-in for Linux | Linux本地用户  
## 0x01 权限绕过漏洞概述
CVE-2020-8193权限绕过漏洞存在于Citrix ADC，Citrix Gateway和Citrix SD-WAN
WANOP产品的report模块（all_profiles函数），攻击者可通过构造未授权的数据包进行特定读取、删除文件操作，一定条件下可导致远程代码执行，从而获得主机系统root权限。
## 0x02 漏洞分析
###  从权限绕过说起
**创建无验证 Session 会话**
Citrix系统绝大多数组件都需要鉴权访问，经过一番搜寻，发现代码中存在一处未授权即可访问功能点，在
`admin_ui/php/application/controllers/pcidss/  
pcidss.php` 文件中存在如下代码片段：
`report()`
    case 'allprofiles':
        if($genPDF = $this->init($data))
            if(isset($data['set']))
                $this->all_profiles($data['set']);
            else
                $this->all_profiles("0");
    break;
传入url参数即可走到这部分逻辑，该代码处理会先调用`pcidss`类的`init()` 函数，检查请求字段中是否包含 `sid`
字段，并从请求包中取`username`字段赋给SESSION[‘username’]。
`init()`
     private function init($argsList)
    {
        session_cache_limiter('must-revalidate');
        if(isset($argsList['sid']))
        {
            require_once(APPPATH. "controllers/common/utils.php");
            utils::setup_webstart_session($argsList['sid']);
            $this->sid = $argsList['sid'];
            $_SESSION["username"] = $this->username =  $argsList['username'];
        }
    ...
随后带着`sid`和进入`utils.php`中的`setup_webstart_session()`函数，首先经过`validate_sid`检查（长度为32的hex字符串）创建一个未授权的`session`
会话。
`setup_webstart_session()`
    // Validates sid and sets up the webstart user session before invoking a command
    static function setup_webstart_session(&$sid, $redirect_on_error = true)
    {
        $sid = urldecode($sid);
        if(!self::validate_sid($sid))
        {
            if($redirect_on_error)
            {
                self::show_error_page("INVALID_SID");
                exit(0);
            }
            return false;
        }
        $_SESSION['NSAPI'] = $sid;
        $_SESSION['NSAPI_DOMAIN'] = '';
        $_SESSION['NSAPI_PATH'] = "/";
        return true;
    }
至此，代码逻辑已经清晰，只要传入的 `username` 和 `sid` 满足条件判断即可使用任意 `username` 创建 `session` 会话。
接着继续看`pcidss.php`，当设置好session会话后，随即进入`set`参数的检查，这里我们需要给 `set`
赋一个大于0的值，才能进入后续操作，代码片段如下。
`all_profiles()`
       private function all_profiles($set)
        {
            ...
            if($set == "0")
                $this->fwconfig();
            ...
            if($set !== "0")
            {
            $set = intval($set);
            }
                if( $set fwconfig();
                    $set = 0;
                }
                ...
                for($i = $start; $i args['global_pargs']['bindings'] args['global_pargs'];
                        $pargs['set'] = $set;
                        $this->args = array('global_pargs' => $pargs);
                        $this->profile_no = $i + 1;
                        $this->fwProfile($profile['name'], $profile);
                    }
            }
        }
从 `all_profiles => fwProfile => execute_command`
一路跟进，我们发现`admin_uiphpapplicationmodelscommonnitro_model.php` 文件的
`command_execution`函数中存在一些对输入参数的过滤，我们需要一点小trick才能继续执行，首先看这里，不难看出`$query_params`的值是`?view=detail&sessionid=$_GET['sid']&args=`：
`command_execution`
    $query_params = "?view=detail";
    if(isset($_SESSION["NSAPI"]))
    {
        $query_params .= "&sessionid=" . urlencode($_SESSION["NSAPI"]);