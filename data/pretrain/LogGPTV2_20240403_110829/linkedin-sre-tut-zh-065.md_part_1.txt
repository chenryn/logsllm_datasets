# 第一部分:基础知识
> 原文：
## SRE 安全概述介绍
*   如果你仔细观察，站点可靠性工程和安全工程都与保持系统可用有关。
*   像不完整的发布、容量短缺和错误配置这样的问题会使系统不可用(至少暂时不可用)。
*   破坏用户信任的安全或隐私事件也会破坏系统的有用性。
*   因此，系统安全性应该是 SREs 最关心的问题。
![The Wide Area of security](img/6d0eff77b2d4704661816f4c880eea3b.png)
*   SREs 应该参与重要的设计讨论和实际的系统变更。
*   它们在系统设计中有相当大的作用&因此有时是第一道防线。
*   SRE 帮助防止会影响基础设施整体安全性的不良设计和实施。
*   成功地设计、实现和维护系统需要对整个系统生命周期的承诺。只有当安全性和可靠性成为系统架构的核心要素时，这种承诺才有可能实现。
*   信息安全的核心支柱:
*   **保密性**–只允许用户访问被允许访问的数据
*   **完整性**–确保数据不被未授权用户篡改或更改
*   **可用性**–确保授权用户在需要时可以使用系统和数据
*   像安全工程师一样思考
*   启动新的应用或重构现有应用时，您应该考虑每个功能特性，并考虑:
    *   围绕此功能的过程是否尽可能安全？换句话说，这是一个有缺陷的过程吗？
    *   如果我是邪恶的，我会如何滥用这个特性？或者更具体地说，未能解决一个特性如何被滥用会导致设计缺陷。
    *   该功能是否需要默认开启？如果是，是否有限制或选项可以帮助降低此功能带来的风险？
*   OWASP(开放网络应用安全项目)的安全原则
*   最小化攻击表面积:
    *   添加到应用中的每个功能都会给整个应用增加一定的风险。安全开发的目的是通过减少攻击面来降低整体风险。
    *   例如，web 应用通过搜索功能实现在线帮助。搜索功能可能容易受到 SQL 注入攻击。如果帮助功能仅限于授权用户，攻击的可能性就会降低。如果帮助功能的搜索功能是通过集中式数据验证例程实现的，那么执行 SQL 注入的能力就会大大降低。然而，如果帮助功能被重写以消除搜索功能(例如，通过更好的用户界面)，这几乎消除了攻击表面区域，即使帮助功能在互联网上普遍可用。
*   建立安全默认值:
    *   有许多方法可以为用户提供“开箱即用”的体验。然而，默认情况下，体验应该是安全的，如果允许的话，应该由用户决定降低他们的安全性。
    *   例如，默认情况下，应该启用密码老化和复杂性。用户可能被允许关闭这两个功能，以简化他们对应用的使用，并增加他们的风险。
    *   路由器、物联网设备的默认密码应该更改
*   最小特权原则
    *   最小特权原则建议帐户拥有执行其业务流程所需的最小特权。这包括用户权限、资源权限(如 CPU 限制)、内存、网络和文件系统权限。
    *   例如，如果一个中间件服务器只需要访问网络、读取数据库表以及写入日志的能力，那么这就描述了应该授予的所有权限。在任何情况下都不应该授予中间件管理特权。
*   纵深防御原则
    *   深度防御原则表明，在一种控制措施合理的情况下，以不同方式应对风险的更多控制措施会更好。当深入使用控制时，可以使严重的漏洞变得非常难以利用，因此不太可能发生。
    *   对于安全编码，这可能采取基于层的验证、集中审计控制以及要求用户登录所有页面的形式。
    *   例如，如果一个有缺陷的管理界面能够正确地控制对生产管理网络的访问、检查管理用户授权并记录所有访问，那么它就不太可能容易受到匿名攻击。
*   安全失败
    *   由于多种原因，应用经常无法处理事务。它们如何失败可以决定应用是否安全。
    ```sh
    is _ admin = true 请尝试{ code _ which _ may _ faile()；is _ admin = is _ user _ assigned _ role(" Adminstrator ")；} catch(Exception err){ log . error(err . tostring())；}
    ` ` `-如果 codeWhichMayFail()或 isUserInRole 失败或抛出异常，默认情况下，用户是管理员。这显然是一个安全隐患。
*   不要相信服务
    *   许多组织利用第三方合作伙伴的处理能力，这些合作伙伴很可能具有与您不同的安全策略和状态。你不太可能影响或控制任何外部第三方，无论他们是家庭用户还是主要供应商或合作伙伴。
    *   因此，对外部运行系统的隐式信任是没有保证的。所有外部系统都应该被类似地对待。
    *   例如，忠诚计划提供商提供网上银行使用的数据，提供奖励点数和潜在兑换项目的小列表。但是，应该检查数据，以确保向最终用户显示是安全的，并且奖励积分是正数，而不是不可能的大。
*   职责分离
    *   欺诈控制的关键是职责分离。例如，请求计算机的人不能签收，也不应该直接收到计算机。这防止了用户请求许多计算机并声称它们从未到达。
    *   某些角色具有不同于普通用户的信任级别。特别是管理员不同于普通用户。通常，管理员不应该是应用的用户。
    *   例如，管理员应该能够打开或关闭系统，设置密码策略，但不应该能够作为超级特权用户登录店面，例如能够代表其他用户“购买”商品。
*   通过模糊来避免安全
    *   通过模糊实现的安全性是一种弱的安全控制，当它是唯一的控制时，几乎总是失败。这并不是说保守秘密是个坏主意，它只是意味着系统的安全性不应该依赖于隐藏细节。
    *   例如，应用的安全性不应该依赖于对保密源代码的了解。安全性应依赖于许多其他因素，包括合理的密码策略、纵深防御、业务交易限制、稳固的网络架构、欺诈和审计控制。
    *   一个实际的例子是 Linux。Linux 的源代码随处可得，但是如果保护得当，Linux 是一个安全且健壮的操作系统。
*   保持简单的安全性
    *   攻击表面积和简单性是相辅相成的。某些软件工程实践更喜欢过于复杂的方法，而不是相对简单明了的设计。
    *   当更简单的方法会更快更简单时，开发人员应该避免使用双重否定和复杂的架构。
    *   例如，尽管在一个单独的中间件服务器上运行大量的单例实体 beans 可能很流行，但是简单地使用带有适当互斥机制的全局变量来防止竞争情况会更安全、更快。
*   正确修复安全问题
    *   一旦确定了安全问题，就必须对其进行测试，并了解问题的根本原因。当使用设计模式时，安全问题可能在所有代码库中普遍存在，因此开发正确的修复方法而不引入回归是至关重要的。
    *   例如，一个用户发现他们可以通过调整他们的 cookie 来查看另一个用户的余额。修复看起来相对简单，但是由于 cookie 处理代码是在所有应用之间共享的，所以对一个应用的更改会渗透到所有其他应用。因此，必须在所有受影响的应用上测试该修复程序。
*   可靠性和安全性
    *   可靠性和安全性都是真正可信的系统的重要组成部分，但是构建既可靠又安全的系统是很困难的。虽然对可靠性和安全性的要求有许多共同的属性，但它们也需要不同的设计考虑。人们很容易忽略可靠性和安全性之间微妙的相互作用，这可能会导致意想不到的结果
    *   例如:密码管理应用故障是由可靠性问题触发的，即负载平衡和减载策略不佳，其恢复后来因多种措施而变得复杂(HSM 机制需要插入服务器机架，作为一种身份验证& HSM 令牌应该锁在箱子里..&问题可以进一步拉长)设计来增加系统的安全性。
* * *
## 身份验证与授权
*   **认证**是验证用户就是他们所声称的那个人的行为。密码是最常见的身份验证因素，如果用户输入正确的密码，系统会认为身份有效并授予访问权限。
*   其他技术，如一次性 pin 码、认证应用，甚至生物识别技术也可以用于身份认证。在某些情况下，系统要求在授予访问权限之前成功验证多个因素。这种多因素身份验证(MFA)要求通常用于提高安全性，而不仅仅是密码。
*   **系统安全中的授权**是给予用户访问特定资源或功能的许可的过程。该术语通常与访问控制或客户端权限互换使用。授予某人在服务器上下载特定文件的权限，或者为单个用户提供对应用的管理访问权限都是很好的例子。在安全环境中，授权必须总是在身份验证之后，用户应该首先证明他们的身份是真实的，然后组织的管理员才能授予他们访问所请求的资源的权限。
### 通用认证流程(本地认证)
*   用户使用用户名/电子邮件/手机等标识符进行注册
*   应用将用户凭据存储在数据库中
*   应用发送验证电子邮件/消息来验证注册
*   注册成功后，用户输入登录凭证
*   身份验证成功后，用户就可以访问特定的资源
### OpenID/OAuth
***OpenID*** 是一种认证协议，允许我们在不使用本地认证系统的情况下认证用户。在这种情况下，用户必须向 OpenID 提供者注册，并且同一个提供者应该与您的应用的身份验证流集成在一起。为了验证细节，我们必须将身份验证请求转发给提供者。身份验证成功后，我们会收到一条成功消息和/或配置文件详细信息，我们可以使用这些信息执行必要的流程。
***OAuth*** 是一种授权机制，允许你的应用用户访问某个提供商(Gmail/脸书/Instagram/etc)。成功响应后，我们(您的应用)会收到一个令牌，应用可以用它来代表用户访问某些 API。如果您的业务用例需要某些面向用户的 API，比如访问 Google Drive 或代表您发送 tweets，那么 OAuth 非常方便。大多数 OAuth 2.0 提供者可以用于伪认证。话虽如此，如果您在本地身份验证系统之上使用多个 OAuth 提供者来验证用户，事情会变得相当复杂。
* * *
## 密码系统