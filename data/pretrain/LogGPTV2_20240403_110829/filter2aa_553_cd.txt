void show_array(const double *ar, int n);
694
关于指针赋值和const需要注意一些规则。首先，把const数据或非const
数据的地址初始化为指向const的指针或为其赋值是合法的：
double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5};
const double locked[4] = {0.08, 0.075, 0.0725, 0.07};
const double * pc = rates; // 有效
pc = locked;         //有效
pc = &rates[3];       //有效
然而，只能把非const数据的地址赋给普通指针：
double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5};
const double locked[4] = {0.08, 0.075, 0.0725, 0.07};
double * pnc = rates; // 有效
pnc = locked;      // 无效
pnc = &rates[3];    // 有效
这个规则非常合理。否则，通过指针就能改变const数组中的数据。
应用以上规则的例子，如 show_array()函数可以接受普通数组名和 const
数组名作为参数，因为这两种参数都可以用来初始化指向const的指针：
show_array(rates, 5);    // 有效
show_array(locked, 4);   // 有效
因此，对函数的形参使用const不仅能保护数据，还能让函数处理const
数组。
695
另外，不应该把const数组名作为实参传递给mult_array()这样的函数：
mult_array(rates, 5, 1.2);   // 有效
mult_array(locked, 4, 1.2);   // 不要这样做
C标准规定，使用非const标识符（如，mult_arry()的形参ar）修改const
数据（如，locked）导致的结果是未定义的。
const还有其他的用法。例如，可以声明并初始化一个不能指向别处的
指针，关键是const的位置：
double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5};
double * const pc = rates; // pc指向数组的开始
pc = &rates[2];       // 不允许，因为该指针不能指向别处
*pc = 92.99;        // 没问题 -- 更改rates[0]的值
可以用这种指针修改它所指向的值，但是它只能指向初始化时设置的地
址。
最后，在创建指针时还可以使用const两次，该指针既不能更改它所指
向的地址，也不能修改指向地址上的值：
double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5};
const double * const pc = rates;
pc = &rates[2];  //不允许
*pc = 92.99;   //不允许
696
10.7 指针和多维数组
指针和多维数组有什么关系？为什么要了解它们的关系？处理多维数组
的函数要用到指针，所以在使用这种函数之前，先要更深入地学习指针。至
于第 1 个问题，我们通过几个示例来回答。为简化讨论，我们使用较小的数
组。假设有下面的声明：
int zippo[4][2]; /* 内含int数组的数组 */
然后数组名zippo是该数组首元素的地址。在本例中，zippo的首元素是
一个内含两个int值的数组，所以zippo是这个内含两个int值的数组的地址。
下面，我们从指针的属性进一步分析。
因为zippo是数组首元素的地址，所以zippo的值和&zippo[0]的值相同。
而zippo[0]本身是一个内含两个整数的数组，所以zippo[0]的值和它首元素
（一个整数）的地址（即&zippo[0][0]的值）相同。简而言之，zippo[0]是一
个占用一个int大小对象的地址，而zippo是一个占用两个int大小对象的地
址。由于这个整数和内含两个整数的数组都开始于同一个地址，所以zippo
和zippo[0]的值相同。
给指针或地址加1，其值会增加对应类型大小的数值。在这方面，zippo
和zippo[0]不同，因为zippo指向的对象占用了两个int大小，而zippo[0]指向的
对象只占用一个int大小。因此， zippo + 1和zippo[0] + 1的值不同。
解引用一个指针（在指针前使用*运算符）或在数组名后使用带下标的
[]运算符，得到引用对象代表的值。因为zippo[0]是该数组首元素（zippo[0]
[0]）的地址，所以*(zippo[0])表示储存在zippo[0][0]上的值（即一个int类型
的值）。与此类似，*zippo代表该数组首元素（zippo[0]）的值，但是
zippo[0]本身是一个int类型值的地址。该值的地址是&zippo[0][0]，所以
*zippo就是&zippo[0][0]。对两个表达式应用解引用运算符表明，**zippo与
*&zippo[0][0]等价，这相当于zippo[0][0]，即一个int类型的值。简而言之，
zippo是地址的地址，必须解引用两次才能获得原始值。地址的地址或指针
697
的指针是就是双重间接（double indirection）的例子。
显然，增加数组维数会增加指针的复杂度。现在，大部分初学者都开始
意识到指针为什么是 C 语言中最难的部分。认真思考上述内容，看看是否
能用所学的知识解释程序清单10.15中的程序。该程序显示了一些地址值和
数组的内容。
程序清单10.15 zippo1.c程序
/* zippo1.c -- zippo的相关信息 */
#include 
int main(void)
{
int zippo[4][2] = { { 2, 4 }, { 6, 8 }, { 1, 3 }, 
{ 5, 7 } };
printf("  zippo = %p,   zippo + 1 = %p\n",zippo, zippo 
+ 1);
printf("zippo[0] = %p, zippo[0] + 1 = %p\n",zippo[0], 
zippo[0] + 1);
printf(" *zippo = %p,  *zippo + 1 = %p\n",*zippo, *zippo + 1);
printf("zippo[0][0] = %d\n", zippo[0][0]);
printf(" *zippo[0] = %d\n", *zippo[0]);
printf("  **zippo = %d\n", **zippo);
printf("    zippo[2][1] = %d\n", zippo[2][1]);
698
printf("*(*(zippo+2) + 1) = %d\n", *(*(zippo + 2) + 1));
return 0;
}
下面是我们的系统运行该程序后的输出：
zippo = 0x0064fd38,     zippo + 1 = 0x0064fd40
zippo[0]= 0x0064fd38,  zippo[0] + 1 = 0x0064fd3c
*zippo = 0x0064fd38,   *zippo + 1 = 0x0064fd3c
zippo[0][0] = 2
*zippo[0] = 2
**zippo = 2
zippo[2][1] = 3
*(*(zippo+2) + 1) = 3
其他系统显示的地址值和地址形式可能不同，但是地址之间的关系与以
上输出相同。该输出显示了二维数组zippo的地址和一维数组zippo[0]的地址
相同。它们的地址都是各自数组首元素的地址，因而与&zippo[0][0]的值也
相同。
尽管如此，它们也有差别。在我们的系统中，int是4 
字节。前面讨论
过，zippo[0]指向一个4 字节的数据对象。zippo[0]加1，其值加4（十六进制
中，38+4得3c）。数组名zippo 是一个内含2个int类型值的数组的地址，所以
zippo指向一个8字节的数据对象。因此，zippo加1，它所指向的地址加8字节
（十六进制中，38+8得40）。
该程序演示了zippo[0]和*zippo完全相同，实际上确实如此。然后，对
699
二维数组名解引用两次，得到储存在数组中的值。使用两个间接运算符
（*）或者使用两对方括号（[]）都能获得该值（还可以使用一个*和一对
[]，但是我们暂不讨论这么多情况）。
要特别注意，与 zippo[2][1]等价的指针表示法是*(*(zippo+2) + 1)。看上
去比较复杂，应最好能理解。下面列出了理解该表达式的思路：
以上分析并不是为了说明用指针表示法（*(*(zippo+2) + 1)）代替数组
表示法（zippo[2][1]），而是提示读者，如果程序恰巧使用一个指向二维数
组的指针，而且要通过该指针获取值时，最好用简单的数组表示法，而不是
指针表示法。
图10.5以另一种视图演示了数组地址、数组内容和指针之间的关系。
图10.5 数组的数组
10.7.1 指向多维数组的指针
如何声明一个指针变量pz指向一个二维数组（如，zippo）？在编写处
700
理类似zippo这样的二维数组时会用到这样的指针。把指针声明为指向int的
类型还不够。因为指向int只能与zippo[0]的类型匹配，说明该指针指向一个
int类型的值。但是zippo是它首元素的地址，该元素是一个内含两个int类型
值的一维数组。因此，pz必须指向一个内含两个int类型值的数组，而不是指
向一个int类型值，其声明如下：
int (* pz)[2];  // pz指向一个内含两个int类型值的数组
以上代码把pz声明为指向一个数组的指针，该数组内含两个int类型值。
为什么要在声明中使用圆括号？因为[]的优先级高于*。考虑下面的声明：
int * pax[2];   // pax是一个内含两个指针元素的数组，每个元素都指
向int的指针
由于[]优先级高，先与pax结合，所以pax成为一个内含两个元素的数
组。然后*表示pax数组内含两个指针。最后，int表示pax数组中的指针都指
向int类型的值。因此，这行代码声明了两个指向int的指针。而前面有圆括号
的版本，*先与pz结合，因此声明的是一个指向数组（内含两个int类型的
值）的指针。程序清单10.16演示了如何使用指向二维数组的指针。
程序清单10.16 zippo2.c程序
/* zippo2.c -- 通过指针获取zippo的信息 */
#include 
int main(void)
{
int zippo[4][2] = { { 2, 4 }, { 6, 8 }, { 1, 3 }, 
{ 5, 7 } };
int(*pz)[2];
701
pz = zippo;
printf("  pz = %p,   pz + 1 = %p\n",   pz, pz + 1);
printf("pz[0] = %p, pz[0] + 1 = %p\n",  pz[0], pz[0] + 1);
printf(" *pz = %p,  *pz + 1 = %p\n",  *pz, *pz + 1);
printf("pz[0][0] = %d\n", pz[0][0]);
printf(" *pz[0] = %d\n", *pz[0]);
printf("  **pz = %d\n", **pz);
printf("    pz[2][1] = %d\n", pz[2][1]);
printf("*(*(pz+2) + 1) = %d\n", *(*(pz + 2) + 1));
return 0;
}
下面是该程序的输出：
pz = 0x0064fd38,    pz + 1 = 0x0064fd40
pz[0] = 0x0064fd38,  pz[0] + 1 = 0x0064fd3c
*pz = 0x0064fd38,  *pz + 1 = 0x0064fd3c
pz[0][0] = 2
*pz[0] = 2
**pz = 2
pz[2][1] = 3
702
*(*(pz+2) + 1) = 3
系统不同，输出的地址可能不同，但是地址之间的关系相同。如前所
述，虽然pz是一个指针，不是数组名，但是也可以使用 
pz[2][1]这样的写
法。可以用数组表示法或指针表示法来表示一个数组元素，既可以使用数组
名，也可以使用指针名：
zippo[m][n] == *(*(zippo + m) + n)
pz[m][n] == *(*(pz + m) + n)
10.7.2 指针的兼容性
指针之间的赋值比数值类型之间的赋值要严格。例如，不用类型转换就
可以把 int 类型的值赋给double类型的变量，但是两个类型的指针不能这样
做。
int n = 5;
double x;
int * p1 = &n;
double * pd = &x;
x = n;       // 隐式类型转换
pd = p1;      // 编译时错误
更复杂的类型也是如此。假设有如下声明：
int * pt;
int (*pa)[3];
int ar1[2][3];
703
int ar2[3][2];
int **p2; // 一个指向指针的指针
有如下的语句：
pt = &ar1[0][0]; // 都是指向int的指针
pt = ar1[0];    // 都是指向int的指针
pt = ar1;      // 无效
pa = ar1;      // 都是指向内含3个int类型元素数组的指针
pa = ar2;      // 无效
p2 = &pt;     // both pointer-to-int *
*p2 = ar2[0];   // 都是指向int的指针
p2 = ar2;      // 无效
注意，以上无效的赋值表达式语句中涉及的两个指针都是指向不同的类
型。例如，pt 指向一个 int类型值，而ar1指向一个内含3和int类型元素的数
组。类似地，pa指向一个内含2个int类型元素的数组，所以它与ar1的类型兼
容，但是ar2指向一个内含2个int类型元素的数组，所以pa与ar2不兼容。
上面的最后两个例子有些棘手。变量p2是指向指针的指针，它指向的指
针指向int，而ar2是指向数组的指针，该数组内含2个int类型的元素。所以，
p2和ar2的类型不同，不能把ar2赋给p2。但是，*p2是指向int的指针，与
ar2[0]兼容。因为ar2[0]是指向该数组首元素（ar2[0][0]）的指针，所以
ar2[0]也是指向int的指针。
一般而言，多重解引用让人费解。例如，考虑下面的代码：
int x = 20;
704
const int y = 23;
int * p1 = &x;
const int * p2 = &y;
const int ** pp2;
p1 = p2;    // 不安全 -- 把const指针赋给非const指针
p2 = p1;    // 有效 -- 把非const指针赋给const指针
pp2 = &p1;  // 不安全 –- 嵌套指针类型赋值
前面提到过，把const指针赋给非const指针不安全，因为这样可以使用
新的指针改变const指针指向的数据。编译器在编译代码时，可能会给出警
告，执行这样的代码是未定义的。但是把非const指针赋给const指针没问
题，前提是只进行一级解引用：
p2 = p1; // 有效 -- 把非const指针赋给const指针
但是进行两级解引用时，这样的赋值也不安全，例如，考虑下面的代
码：
const int **pp2;
int *p1;
const int n = 13;
pp2 = &p1;  // 允许，但是这导致const限定符失效（根据第1行代码，
不能通过*pp2修改它所指向的内容）
*pp2 
= 
&n;  // 
有效，两者都声明为const，但是这将导致p1指向
n（*pp2已被修改）
705
*p1 = 10;//有效，但是这将改变n的值（但是根据第3行代码，不能修改n
的值）
发生了什么？如前所示，标准规定了通过非const指针更改const数据是
未定义的。例如，在Terminal中（OS X对底层UNIX系统的访问）使用gcc编
译包含以上代码的小程序，导致n最终的值是13，但是在相同系统下使用
clang来编译，n最终的值是10。两个编译器都给出指针类型不兼容的警告。
当然，可以忽略这些警告，但是最好不要相信该程序运行的结果，这些结果
都是未定义的。
C const和C++ const
C和C++中const的用法很相似，但是并不完全相同。区别之一是，