title:BigMap: Future-proofing Fuzzers with Efficient Large Maps
author:Alif Ahmed and
Jason D. Hiser and
Anh Nguyen-Tuong and
Jack W. Davidson and
Kevin Skadron
2
6
0
0
0
.
1
2
0
2
.
7
8
9
8
4
N
S
D
/
9
0
1
1
.
0
1
:
I
O
D
|
E
E
E
I
1
2
0
2
©
0
0
.
1
3
$
/
1
2
/
7
-
2
7
5
3
-
4
5
6
6
-
1
-
8
7
9
|
)
N
S
D
(
s
k
r
o
w
t
e
N
d
n
a
s
m
e
t
s
y
S
e
l
b
a
d
n
e
p
e
D
n
o
e
c
n
e
r
e
f
n
o
C
l
a
n
o
i
t
a
n
r
e
t
n
I
P
I
F
I
/
E
E
E
I
l
a
u
n
n
A
t
s
1
5
1
2
0
2
2021 51st Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN)
BigMap: Future-prooﬁng Fuzzers with Efﬁcient Large Maps
Alif Ahmed, Jason D. Hiser, Anh Nguyen-Tuong, Jack W. Davidson, Kevin Skadron
Department of Computer Science, University of Virginia
{alifahmed, hiser, an7s, jwd, skadron}@virginia.edu
Abstract—Coverage-guided fuzzing is a powerful technique
for ﬁnding security vulnerabilities and latent bugs in software.
Such fuzzers usually store the coverage information in a small
bitmap. Hash collision within this bitmap is a well-known
issue and can reduce fuzzers’ ability to discover potential
bugs. Prior works noted that collision mitigation with na¨ıvely
enlarging the hash space leads to an unacceptable runtime
overhead. This paper describes BigMap, a two-level hashing
scheme that enables using an arbitrarily large coverage bitmap
with low overhead. The key observation is that the overhead
stems from frequent operations performed on the full bitmap,
although only a fraction of the map is actively used. BigMap
condenses these scattered active regions on a second bitmap
and limits the operations only on that condensed area. We
implemented our approach on top of the popular fuzzer AFL
and conducted experiments on 19 benchmarks from FuzzBench
and OSS-Fuzz. The results indicate that BigMap does not
suffer from increased runtime overhead even with large map
sizes. Compared to AFL, BigMap achieved an average of 4.5x
higher test case generation throughput for a 2MB map and
33.1x for an 8MB map. The throughput gain for the 2MB
map increased further to 9.2x with parallel fuzzing sessions,
indicating superior scalability of BigMap. More importantly,
BigMap’s compatibility with most coverage metrics, along with
its efﬁciency on bigger maps, enabled exploring aggressive com-
positions of expensive coverage metrics and fuzzing algorithms,
uncovering 33% more unique crashes. BigMap makes using
large bitmaps practical and enables researchers to explore a
wider design space of coverage metrics.
I. INTRODUCTION
Real-world applications usually have a large codebase,
making it difﬁcult to detect security vulnerabilities while
providing a vast attack surface to the adversaries. Fuzzing
techniques are geared towards automatically generating test
vectors to expose these vulnerabilities or to improve the code
coverage in general. Among different types of fuzzer, black-
box fuzzers blindly generate random test vectors without
resorting to any form of program analysis. Consequently,
these fuzzers scale very well with program size and are
easily parallelizable but are unlikely to ﬁnd rare bugs. On
the other end of the spectrum, white-box fuzzers can do a
directed and exhaustive search of the coverage space with
symbolic execution, but are prohibitively slow to be useful
for large, real-world applications [1]–[4]. Coverage-guided
grey-box fuzzers ﬁll the middle ground and so far have been
most successful in ﬁnding software bugs. At the time of
this writing, Google’s OSS-Fuzz platform uncovered over
20,000 vulnerabilities on 300 projects [5] with the help
of three coverage-guided grey-box fuzzers - libFuzzer [6],
Honggfuzz [7], and American Fuzzy Lop (AFL) [8].
As the name suggests, coverage-guided fuzzers use some
form of a coverage metric to track and guide their test
generation process. For example, libFuzzer and Honggfuzz
use basic block coverage. AFL, on the other hand, tracks
edge hit counts with the help of a coverage bitmap. Each
edge encountered while executing a test case is dynamically
assigned to a location on this bitmap to store and update the
hit count. This coverage bitmap is accessed very frequently
and should occupy faster cache levels to maximize the test
case generation throughput. For this reason, the size of the
bitmap has historically been kept small (the default size is
64kB for AFL). Due to the bitmap’s size limitation and
the randomness of the location assignment, it is possible
to have hash collisions, where two or more edges point to
the same location on the bitmap. Hash collisions introduce
ambiguity in coverage feedback and can severely limit the
fuzzer’s ability to ﬁnd bugs [9]. Our work seeks a better
understanding and efﬁcient mitigation of this issue.
The straightforward way for reducing hash collisions is
to expand the hash space (i.e., increase coverage bitmap
size). Prior works noted that na¨ıvely enlarging the bitmap
can severely diminish the test case generation throughput,
potentially resulting in lower code coverage within the same
time budget [9]. We investigated the reason behind the
throughput drop with larger bitmaps. We observed that for
large bitmaps, most of the time is spent doing a few speciﬁc
operations (e.g., reset, classify, compare, and hash) on the
bitmap. These operations are performed on the full bitmap,
although only a small fraction of the bitmap is actively
used for storing coverage statistics. This type of access
pattern is inefﬁcient and heavily pollutes the processor’s data
cache, ultimately lowering the throughput. In this paper, we
introduce BigMap, a two-level bitmap scheme that optimizes
these map operations. BigMap adds an extra level of indi-
rection to bitmap accesses to condense randomly scattered
coverage metrics in a sequential bitmap, vastly improving
cache locality behavior. Furthermore, the map operations
now only need to be performed on the used portion instead
of the full bitmap. Overall, our proposed approach enables
using large maps without sacriﬁcing throughput.
We integrated BigMap into AFL and conducted exper-
iments with benchmarks from FuzzBench [10] and OSS-
Fuzz [5]. With AFL’s carefully tuned default map size of
978-1-6654-3572-7/21/$31.00 ©2021 IEEE
DOI 10.1109/DSN48987.2021.00062
531
Authorized licensed use limited to: Tsinghua University. Downloaded on October 11,2021 at 09:23:42 UTC from IEEE Xplore.  Restrictions apply. 
64kB, BigMap demonstrated identical throughput, despite
adding an extra level of indirection. The throughput gain
over AFL increased with map size, with up to 13.6x (average
of 4.5x) for a 2MB map and up to 114x (average 33.1x) for
an 8MB map. BigMap also demonstrated better scalability
with concurrent fuzzing instances, achieving an average of
9.2x higher throughput than AFL for a 2MB map and up
to 12 parallel instances. The higher throughput resulted in
uncovering 37% more unique crashes on average.
Interestingly, BigMap is compatible with any coverage
metric (not just edge hit count) as long as it uses some
form of a coverage bitmap. This property, along with the
efﬁciency of BigMap with large maps, enables exploring
aggressive compositions of coverage metrics and algorithms
previously thought infeasible. To demonstrate this capability
of BigMap, we selected a few large applications from OSS-
fuzz [5] as seed benchmarks. Their discoverable edges are
further ampliﬁed by enabling laf-intel transformations1 [11]
and then combining it with a more expressive coverage
metric, N-gram [12]. This combination resulted in fuzzing
harnesses with over 600k discoverable edges (over 5.5 mil-
lion static edges). To put it into context, typical real-world
applications have around 1k - 50k discoverable edges [13]–
[15]. After mitigating hash collisions on these benchmarks
with the help of BigMap, we saw a 33% increase in the
number of unique crashes. In summary, this paper makes
the following contributions:
• We investigate the shortcomings of enlarging bitmap to
mitigate hash collision and identify the following key
reasons: frequent operations on the full coverage map
and excessive cache pollution.
• We leverage our ﬁndings in designing BigMap. BigMap
introduces a two-level mapping scheme to limit the
operations on the used region of the map. With this
adaptive technique, the bitmap can be made arbitrarily
large without sacriﬁcing speed.
• We extend base AFL with our proposed method. Com-
pared to AFL, we see an average of 4.5x higher test
case generation throughput for a 2MB map and 33.1x
for an 8MB map.
• We evaluate the scalability of BigMap with concurrent
fuzzing instances. Compared to AFL, we see an average
throughput gain of 9.2x for a 2MB map. Furthermore,
BigMap was able to uncover 37% more unique crashes.
• BigMap’s enables the aggressive composition of cover-
age metrics. We evaluate the composition of two well-
known coverage metrics, laf-intel and N-gram, and ﬁnd
that unique crash coverage improved by 33%.
The BigMap fuzzing framework is open-source and avail-
able at: https://github.com/alifahmed/BigMap.
1Laf-intel transforms multi-byte comparisons into a cascade of single-
byte comparisons. Laf-intel also deconstructs switch statements and strcm-
p/memcmp functions into if-else statements.
II. BACKGROUND
A. American Fuzzy Lop (AFL)
AFL is one of the most popular fuzzers currently avail-
able. Many prior works [9], [16], [17] built upon AFL,
including our work in this paper. AFL uses an evolutionary
algorithm for fuzzing. Figure 1 illustrates this ﬂow. In
general, this workﬂow is applicable to other coverage-guided
fuzzers as well. At
the beginning of the process, AFL
instruments the target application and populates the seed
pool with user-provided seed inputs. Afterwards, AFL enters
a fuzzing cycle: i) Selects a seed from the seed pool for
mutation. ii) Mutates the seed to generate many new test
cases. A seed is usually mutated tens of thousands of times
before moving to the next seed. iii) Executes the generated
test cases and checks the coverage feedback. If any test case
crashes or hangs, it is reported to the user. If a test case
covers an interesting path dictated by the ﬁtness function
(e.g., improves coverage), it is added to the seed pool as a
potential candidate for future mutations. Otherwise, the test
case is discarded. iv) After ﬁnishing with the current seed,
the ﬂow goes to (i) and selects a new seed for mutation.
Fuzzing cycle continues until the user interrupts, or some
other criteria is met (e.g., coverage goal or time budget).
1) Seed Scheduling and Mutation: This section is kept
short because our approach is orthogonal
to the seed
scheduling and mutation strategy. Seed scheduling policy
determines which seed from the seed pool will be fuzzed
next. AFL prioritizes the seeds based on their execution
speed and input ﬁle length. Short input ﬁles are preferred
because a mutation is more likely to touch important control
structures and not just redundant data blocks on a smaller
ﬁle [13]. As for mutating the seed, AFL applies a few
deterministic (i.e., not random) mutation steps followed
by random mutations. The mutation steps involve bit-ﬂips,
block substitution, splicing, etc. The deterministic mutation
steps usually take a long time to ﬁnish. It is a common
Initial 
Seeds
Add to
Pool
Report
Crash/Hang
Discard
Target 
App
Seed Pool
Seed 
Scheduling
Seed 
Mutation
Testcases
Fitness Function
k
c
a
b
d
e
e
f
Global 
Coverage
Coverage
Execution
Instrument
Instrumented 
Application
Figure 1: The generic workﬂow of a coverage-guided fuzzer.
Authorized licensed use limited to: Tsinghua University. Downloaded on October 11,2021 at 09:23:42 UTC from IEEE Xplore.  Restrictions apply. 
532
practice to skip this deterministic stage and directly apply
random mutations for shorter runs (e.g., 24 hours).
2) Execution and Coverage Feedback: AFL collects the