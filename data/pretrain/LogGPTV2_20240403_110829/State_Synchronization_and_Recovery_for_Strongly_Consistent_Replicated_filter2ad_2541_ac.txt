level  state  (in  terms  of  the  client-server  negotiated  informa- 
tion)  with  that of the  ORBS hosting  operational  replicas of  the 
same server object.  The new  server replica’s response  to  this 
artificially-injected  handshake confirms,  to  Eternal’s  Recovery 
Mechanisms,  the  correct  synchronization of  ORBPOA-level 
state for the new server replica, and can be safely discarded. 
4.3  Infrastructure-Level State 
Infrastructure-level  state.‘ 
is  completely  independent of,  and 
invisible to, the replicated  object as well as to the ORB and the 
POA, and involves only information that Eternal needs for main- 
taining consistent replication.  The infrastructure-level state con- 
tains  information essential  for duplicate detection  and garbage 
collection  of the log. 
For every operational replica that it hosts, Eternal’s Recovery 
Mechanisms (running on the same processor as the replica) store 
information  locally regarding: 
‘A  server’s Interoperable Object Reference (IOR) is a stringified  represenm- 
lion of the server’s host name. port number, ObJeCt key. etc. 
‘Infrastructure-level  state  is  not  unique  to  the Eternal  system.  In  fact.  any 
system  that  provides  fault tolerance  must  maintain  .sonic state  on  behalf  of  the 
replicated objects that it hosts. 
The invocations that  the replica  has  issued, and  for which 
the replica is awaiting responses, 
The  invocations  and  responses  that  have  been  enqueued 
(while  the  replica  is  not  quiescent)  for  delivery  to  the 
replica when it becomes quiescent, 
The  replication  style  of  the  replica,  including whether  it 
is an active, warm  passive primary, warm passive backup, 
cold passive primary or cold passive backup replica, 
The Eternal-generated  operation identifiers that enablc the 
Recovery  Mechanisms to  filter  duplicate  invocations  and 
responses intended for the replica. 
During  recovery,  the  Recovery  Mechanisms  hosting  an  ex- 
isting  replica  “piggyback” the  infrastructure-level  state  for the 
replica  onto the application-level  state and the ORB/POA-level 
state that they transfer to the Recovery Mechanisms hosting the 
new replica. 
The  Recovery  Mechanisms  that  receive  the  three  kinds  of 
state assign the application-level  state first, the ORBIPOA-level 
state next, and finally, the infrasmcture-level state Oefore allow- 
ing the new replica  to become fully operational, and to receive 
or process  any normal  incoming invocations or responses.  The 
retrieval, as well  as the assignment, of the three different  kinds 
of state appears as a single atomic action so that thc state trans- 
fer of the three kinds of state occurs at a single logical point in 
time. 
5  State Transfer 
The frequency of state retrieval or checkpointing is determined 
on a per-replicated-object  basis,  by  the  user,  at  the time  of de- 
ploying the application, when all other fault tolerance properties 
(replication  style,  number of replicas, location  of replicas,  etc) 
for the replicated object are also determined. 
By  no  means  does  the  checkpointing  frequency  guarantee 
that the  replicated  object  will  perform the  state retrieval (via a 
get-state() operation) immediately.  The replicated  object mav 
be in  the middle of another operation, or may be blocked  wait- 
ing  for a response, etc.  To  decide  on  the  appropriate time  to 
deliver the g e t s t a t e ( )  invocation, the Eternal  system must de- 
termine the moment that the object is quiescent, i.e., when  it is 
“safe”, from  the  viewpoint  of  replica consistency,  to deliver a 
new  invocation to the object.  Determining whether an object is 
quiescent is  a  non-trivial  exercise - it  involves examining the 
status of current invocations  on the  object, the  threads  that  are 
currently executing within the process containing the object, and 
data that the object may  share with  other in-process collocated 
objects.  The use  of  oneways, CORBA-supported invocations 
that do not return responses, introduces additional complications 
for  quiescence.  Eternal  provides mechanisms  to  ascertain  the 
quiescence of a CORBA object prior to delivering an invocation 
to it - these mechanisms are outside the scope of this paper. 
5.1  Synchronization of State Transfer Messages 
During recovery, the current application-level  state must first be 
retrieved  from  an existing replica or a log  before  it  can  be  as- 
signed lo a  new  replica.  In  the transfer of  state  from an  exist- 
ing  replica  to  a  new  or recovering replica, it  is  important  that 
the  retrieval  of  state  from  the  existing replica  and  the  assign- 
266 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:04:13 UTC from IEEE Xplore.  Restrictions apply. 
Existing 
Replica A 
(of object A) 
elivered io 
g  Riplica 
New 
Replica A 
(Of object 1) 
grr_rrole() tnggem 
enqueueing of messages 
1 ' 
New 
Replica A 
(of object 1) 
Etemal's 
Mechanisms 
Etmal! 
Mechanisms 
Totally ordered sequence of multicast messages 
Existing 
Replica A 
(Of  object A) 
gerLrtureO reiums !he 
application level state 
(iii) 
IilvMallon X 
Etemal's 
Mechanisms 
Etemal's 
Mechanisms 
Totally ordered sequence of multicast messages 
Existing 
Replica A 
(Of  object A) 
Existing 
Replica A 
(of object A) 
g e l - . ~ l ~ i d )  k i n g  
processed hy replica 
New 
Replica A, 
(Of object A) 
Invocations enqueued UII 
gel-stole(J  BNmS 
(ii) 
Eternal's 
Mechanisms 
IEtemal's 
Mechanisms 
I 
Totally ordered sequence of multicast messages 
Existing 
Replica A 
(of object A) 
lnwcation X dcqueued and 
delivered to the existing replica 
New 
Replica A 
(of object A) 
/ 
Etemal's 
Mechanisms 
Eternal's 
Mechanisms 
[set-stateo  1 
I 
Totally ordered sequence of  multicast messages 
I 
New 
Replica A 
(of object A) 
Existing 
Replica A 
(of object A) 
New 
Replica A 
(Of  Object A) 
Invocation X dequcued md 
delivered lo lhe cxisimg replica 
I  ' 
lnwcaiion Y 
queued when 
Invocalion X 
Mechanisms 
Etemal's 
,etrrr,rr  ""CIw"1CS  &!erL\l'rie 
at the herd oflhe queue md 
IS dclivercd tu the new rephca 
/ 
Mechanisms 
Eternal's 
Mechanisms 
Totally ordered sequence of multicast messages 
Totally ordered sequence of  I I I U I I I L ~ L S I  I I I G ~ L S ~ ~ G ~  
1 
Figure 5: Synchronization of state retrieval and state assignment messages for consistent replication. 
267 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:04:13 UTC from IEEE Xplore.  Restrictions apply. 
ment of  the  retrieved  state at the  new  or recovering replica  be 
seen to occur at  the same logical point  in time.  Otherwise, the 
state retrieved by the get-state() invocation will not be the state 
assigned  by  the  set-state() invocation.  The  tricky  issues  of 
synchronizing the transfer of state are handled by  the Recovery 
Mechanisms. 
The get-state() invocation must be delivered only to the ex- 
isting replicas that have the current consistent state of the repli- 
cated object; the s e t s t a t e ( )  invocation must be delivered only 
to  the  new  replica.  Both  invocations are  received,  in  the  se- 
quence of multicast messages, by the Mechanisms hosting both 
the  new  and  the  existing replicas of  the object.  However,  the 
receipt of the invocations results in different actions, depending 
on whether the receiving Recovery  Mechanisms host either an 
existing or a new replica. 
Figure 5  shows two replicas of a replicated object A, where 
.41 is  an existing replica, and  ’42  is  a  new  replica,  and  the se- 
quence of steps in synchronizing the state transfer of the repli- 
cated object A. 
Step  (i):  At  the  existing  replica  ‘41, Eternal  delivers  the 
get-state()  invocation as  shown  in  Figure 5(i).  However, be- 
cause the new  or recovering replica A2  has not yet been initial- 
ized with the correct consistent state of the replicated object, the 
g e t A a t e ( )  operation  is  not  delivered to  the  new  replica.  In- 
stead, the receipt of the get_state() invocation triggers Eternal 
to  start  the  enqueueing of  normal  incoming  IIOP messages  at 
the new or recovering replica. 
Step  (ii):  While  the  existing  replica  A1  is  performing  the 
get-state()  operation,  regular invocations  (such as  Invocation 
X shown  in  Figure 5(ii)) might arrive for the replicated object 
-4.  Because ill is  in  the middle of  an operation, these  incom- 
ing  invocations are  not  immediately delivered to Al.  Because 
-42 has not yet  been recovered with  the correct state, these  in- 
vocations are not delivered to Az, either. Eternal enqueues such 
regular incoming messages, at both replicas, for later delivery. 
Step (iii):  The get-stute() invocation completes, as shown  in 
Figure  5(iii).  Eternal  extracts  the  return  value  of  the  invoca- 
tion,  and  uses  it as  the  parameter  of  a  set-stnte() invocation 
that  it  fabricates.  Eternal  “piggybacks” the  relevant  pieces  of 
ORB/POA-level state and infrastructure-level state to the fabri- 
cated set-state() invocation. 
Step (iv):  The set-state() invocation is multicast, along  with 
the  piggybacked  ORB/POA-level  state  and  the  infrastructure- 
level state associated with the existing replica -41. Replica AI 
is once again free to process invocations; Eternal delivers to -41 
the  ordered  messages (such as  Invocations X  and  Y )  that  ar- 
rived  for J1 while  il, was processing the get-state() invoca- 
tion.  Figure 5(iv) shows the  first such enqueued  invocation S 
being dequeued and delivered to the existing replica -41. 
Step  (v):  When  the  set_state() invocation  is  received  by 
Eternal  at  the  new  or  recovering  replica,  as  shown  in  Fig- 
ure  5(v), this  invocation  overwrites  the  message  at  the  head 
of  the  message  queue  (a  position  previously  occupied  by 
the  get-state()  invocation).  The  piggybacked  ORBPOA- 
level  state  and  infrastructure-level state  are  extracted  and  as- 
signed to their respective counterparts for replica 242, while the 
set-state()  invocation  containing the application-level state  is 
Recovew Time for a Sewer ReDlica 
* 
* 
* 
* 
* 
* 
* 
* 
- 
60 
- 
55 
- 
p50 
E - 
- 
:45 
- 
- 
> 
_c 5 40 
4 35 
t 
‘--3O- 
25t 
”’ 
t *  
20 
15 
0 5  
2 
2 5  
3 
3 5  
1 
1 5  