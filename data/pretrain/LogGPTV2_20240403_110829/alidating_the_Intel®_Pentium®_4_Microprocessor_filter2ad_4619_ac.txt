full-chip for the  first time,  a validator  took responsibility 
for  running  his  feature  exercise  tests,  debugging  the 
failures and  working with  designers to rapidly  drive fixes 
into  graft  (experimental)  models,  bypassing  the  normal 
code  turn-in  procedure,  until  an  acceptable  level  of 
stability  was  achieved.  Only then  was  the  feature  made 
available  for  more  widespread  use  by  other  validators. 
496 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:57:13 UTC from IEEE Xplore.  Restrictions apply. 
We  found  that  this  methodology  greatly  speeded  up  the 
integration process;  as a side effect, it also helped  the AV 
team develop  their  full-chip  debugging skills much  more 
rapidly than might otherwise have occurred. 
Once  a  fully  functional  full-chip  SRTL  model  was 
available (in mid- 1998) these feature pioneering tests were 
discarded, and replaced by  a new  suite of over  12,000 IA- 
32 tests developed by  the AV team, whose purpose  was to 
fully explore the architecture space.  Previous projects  up 
to and including the Pentium@ Pro processor had relied on 
an  “ancestral”  test base  inherited from the past,  but  these 
tests  had  little  or  no  documentation,  unknown  coverage 
and  doubtful  quality  (in  fact, many  of them turned  out to 
be  bug tests from previous implementations that had  little 
architectural  value).  We  did  eventually 
the 
“ancestral”  suite as a late cross-check, after the new  suite 
had  been  run  and  the  resulting  bugs  fixed, but  we  found 
nothing of consequence as a result, indicating that it can at 
long last be retired. 
run 
9. Coverage-Based Validation 
Recognizing the truth of the saying: “If it isn’t tested, it 
doesn’t  work”  we  attempted  wherever  possible  to  use 
coverage  data to provide feedback  on the effectiveness of 
our tests and tell  us what we had and had not tested.  This 
in  turn  helped  direct  future testing towards the uncovered 
areas.  Since we relied very heavily on direct random test 
generators  for  most  of  our  microarchitectural 
testing, 
coverage feedback was an absolute necessity if we were to 
avoid  “spinning  our  wheels”  and  testing  the  same  areas 
over  and  over  again  while  leaving  others  completely 
In  fact,  we  used  the  tuple  of  cycles  run, 
untouched. 
coverage  gained  and  bugs  found  as  our  first-order  gauge 
of SRTL model health and readiness for tapeout. 
for  a 
By 
Our primary coverage tool was proto from Intel Design 
Technology,  which  we  used  to  create  coverage  monitors 
and  measure  coverage 
large  number  of 
microarchitecture  conditions. 
tapeout  we  were 
tracking  almost  2.5  million  unit-level  conditions,  and 
more than  250,000 inter-unit conditions, and succeeded  in 
hitting  almost  90%  of  the  former  and  75%  of  the  latter. 
thousand 
We  also  used  proro  to  instrument  several 
multiprocessor 
conditions 
(combinations of microarchitecture  states for caches, load 
and store buffers, etc.), and, as mentioned  above, all of the 
clock gating conditions that had been identified in the unit 
power reduction  plans.  We also used  the parhfinder tool 
from  Intel’s  Central  Validation  Capabilities  group  to 
measure  how  well  we  were  exercising  all  the  possible 
microcode paths  in  the  machine.  Much  to  our  surprise, 
running  all  of  the  AV  test  suite  yielded  microcode path 
coverage  of  less than  10%; further analysis revealed  than 
coherency 
memory 
many  of  the  untouched  paths  involved  memory-related 
faults  (e.g.  page  fault)  or  assists  (e.g.  A/D  bit  assist). 
When  we  thought  about  it,  this  made  sense  -  the  test 
writers had set up their page tables and descriptors so as to 
avoid these time-consuming functions (at 3 Hz, every little 
bit  helps!).  We modified  tests  to cause  them  to exercise 
these uncovered paths, and did indeed find several bugs in 
hitherto  untested  logic,  thus  reinforcing  our  belief  in  the 
value  of  using  coverage  feedback  and  not just  assuming 
that specified conditions were being hit. 
10. Bug Discussion 
the 
Comparing 
the  development  of 
the  Pentium@  4 
processor  with the Pentium’  Pro processor, we recorded  a 
350%  increase  in  the  number  of  bugs filed against  SRTL 
prior  to  tapeout.  We  also  saw  a  somewhat  different 
breakdown  by  cluster:  on  the  Pentium’  Pro processor  [4] 
microcode  was 
largest  single  source  of  bugs, 
accounting  for  over  30%  of  the  total,  where  as  on  the 
Pentium’  4  processor  it  was  less  than  14%.  For  both 
designs,  the  Memory  Cluster  was  the  largest  source  of 
hardware  bugs,  accounting  for around 25% of the total in 
both  cases.  This  is  consistent  with  data  from  other 
projects, and indicates that we need to apply more focus to 
preventing bugs in this area. 
We did  a statistical  study  [5] to try  to determine how  the 
bugs came to be in the Pentium’  4 processor design.  The 
major  categories,  amounting  to  over  75%  of  the  bugs 
analyzed, were: 
architects  not  communicating 
Goof  (12.7%)  - these  were  things like typos, cut and 
paste  errors,  careless  coding  when  in  a  hurry,  or 
situations where the designer  was counting on testing 
to find the bugs. 
Miscommunication (1 1.4%) -  these  fall  into  several 
categories: 
their 
expectations  clearly  to  designers,  misunderstandings 
between  microcode  and  design  as  well  as  between 
different  parts  of  design  (e.g.  misassumptions  about 
what another unit was doing). 
Microarchitecture  (9.3%)  -  these  were  problems  in 
the microarchitecture  definition. 
LogicMicrocode  changes  (9.3%)  -  these  were  cases 
where  the design  was  changed, usually  to fix bugs or 
timing  problems,  and  the  designer  did  not  take  into 
account all  the  places that  would be  impacted  by  the 
change. 
Corner cases (8%) - as the name  implies, these were 
specific cases which the designer failed to implement 
correctly. 
Power  down  issues  (5.7%)  - these  were  mostly 
related to clock gating. 
497 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:57:13 UTC from IEEE Xplore.  Restrictions apply. 
- 
(4.4%) 
late  in 
something 
Documentation 
(algorithm, 
microinstruction,  protocol)  was  not  documented 
properly. 
Complexity  (3.9%)  - although  some  of  the  bugs 
categorized  under 
the  “Miscommunication”  or 
“Microarchitecture”  headings  were  undoubtedly  the 
result  of  complexity  in  the  design,  these  were  bugs 
whose cause was  specifically  identified  as being due 
to microarchitectural  complexity. 
Random  initialization  (3.4%)  - these  were  mostly 
bugs  caused  by  state  not  being  properly  cleared  or 
initialized at reset 
Late  definition  (2.8%)  -  certain  features  were  not 
defined  until 
to 
shoehorning them  into working  functionality  (similar 
to  the  logic/microcode  changes  category).  Also, 
because  they  were defined  late,  they  were sometimes 
rushed and were not always complete or fully thought 
out. 
Incorrect  RTL  assertions  (2.8%)  -  these  refer  to 
assertions  (instrumentation in  the  SRTL  code)  that 
were either  wrong,  overzealous, or had  been  working 
correctly but were broken  by a design change (usually 
timing induced). 
Design mistake (2.6%) -  the  designer misunderstood 
what  he/she  was  supposed  to  implement.  Normally 
this was a result  of not fully reading the specification 
or  starting  implementation  before  the  specification 
was complete. 
the  project. 
This  led 
enable Intel  to realize  early revenue from the  PentiumO 4 
processor in today’s highly, competitive marketplace. 
12. Acknowledgments 
The  results  described  in  this  paper  are  the  work  of  a 
large  team  of  people  over  a  4  -year  period. 
It  is 
impossible  to  list  here  the  names  of  everyone  who 
contributed  to  this  effort, but  I  am especially  indebted  to 
Blair Milburn, Keiichi Suzuki, Rick Zucker, Bob Brennan, 
Tom Schubert and John Bauer, both for their leadership of 
the  Pentium’  4  processor  pre-silicon  validation  activities 
and  for  their  valuable  feedback  on  early  drafts  of  this 
paper. 
References 
[I] Clark, D, “Bugs Are Good: A Problem-Oriented Approach 
To  The  Management  Of  Design  Engineering”, Research- 
7echnology Management, 33(3), May  1990, pp. 23-21,. 
[3] 
[2]  Ho,  R, Yang, H,  Horowitz, M, and  Dill, D:  “Architecture 
ISCA  95:  Internaltiorzal 
Validation  for  Processors”, 
Conference on Computer Architecture, June  1995 
Fournier,  L,  Arbetman,  Y  and  Levinger,  M:  “Functional 
Verification  Methodology for  Microprocessors Using  the 
Genesys Test-Program Generator -  Application to  the  x86 
Microprocessors  Family”,  Proceedings  of  the  Design 
,$utomation and  Test in Europe  Conference and Exhibition 
(‘DATE99), March  1999. 
11. Conclusion 
The Pentium”  4 processor was highly functional  on A- 
0 silicon, and received  production  qualification in only  10 
months from tapeout.  The work described here is a major 
reason  why  we were  able to hit such a tight  schedule and 
[4]  Bentley, R,  and  Milbum, B,  “Analysis of  Pentiuma Pro 
l’rocessor  Bugs”,  fntel  Desigil  and  Test  Teclinofog.y 
Conference, June 1996. 
~
~
~
i
[51 ;tucker,  R,  “ B ~
l
hitel  Design  and  Test  Technology  Conference,  August 
:!ooo. 
for  willamette”, 
Root  cause ~
~
~
498 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:57:13 UTC from IEEE Xplore.  Restrictions apply.