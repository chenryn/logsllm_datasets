straction because some correct servers may not receive mes-
sages transmitted to them.
The resulting U-masking (or U-dissemination) protocol
provides safe (or regular) semantics for generic (or self-
verifying) data. The protocol is live because the avail-
ability property guarantees that it must always eventually
stop resending messages: under an unreliable asynchronous
network as deﬁned here, a message sent repeatedly must
eventually reach its destination. Given that, we show that
each send/receive/wait step is equivalent to a reliable asyn-
chronous send to a responsive quorum of servers. Then,
the proof of safety and liveness follows Malkhi and Reiter’s
original proof.
The advantage of managing message retransmission in
the Byzantine quorum protocol as opposed to abstracting it
into the communications layer is that doing so makes it easy
to bound buffer consumption even if a server’s network pro-
tocol software is considered vulnerable to Byzantine fail-
ures of the server.
In particular, under these protocols, a
read or write request may consume client buffer memory
proportional to , the number of servers. If a client issues
c concurrent operations, then the client’s total memory con-
sumption is O(c). Unfortunately, in an asynchronous sys-
tem, each request may take arbitrary time to complete, so
c may, in general, be unbounded. Fortunately, this protocol
is amenable to several techniques for bounding the number
of outstanding requests from each client. For example, if a
client application using the BQS system is single-threaded
and blocks for reads and writes, then system buffer con-
sumption is naturally bounded to O() buffers per client.
A more general solution is for the protocol itself to man-
age allocation and deallocation from a ﬁnite set of buffer
and to block incoming requests when insufﬁcient buffers
are available to complete a request.
In particular, in the
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:26:38 UTC from IEEE Xplore.  Restrictions apply. 
Finite Buffer U-masking or U-dissemination protocol, we
assume  local buffers and add a step FIRST before and a
step LAST after both the read and the write function.
FIRST) Wait for  local buffers to be available then lock 
local buffers.
LAST) Unlock the  local buffers claimed in step FIRST.
We provide the complete proofs for the following three
theorems in our technical report [22].
Theorem 4 The Finite Buffer U-masking protocol
for
generic data follows safe semantics and the Finite Buffer U-
dissemination protocol for self-verifying data follows regu-
lar semantics. (Safety)
The safety of the Finite Buffer protocol follows from the
fact that each send/wait/repeat step is equivalent to a reliable
asynchronous send and the safety properties of Malkhi and
Reiter’s original protocol.
Theorem 5 The Finite Buffer U-masking
and U-
dissemination protocols are live (i.e. all requests eventually
terminate). (Liveness)
This follows from three facts: (1) step FIRST terminates
because the rest of the protocol is live, (2) each network
send/wait/resend step terminates because it must eventually
reach a responsive set of servers, and (3) the original Malkhi
and Reiter protocols terminate.
Theorem 6 The Finite Buffer U-masking
and U-
dissemination protocol consumes at most  buffers.
(Finite Buffering)
This follows from the locking of step FIRST.
5. Related Work
There is a signiﬁcant body of work on quorum systems
[11, 13, 18, 29] but Byzantine failures were ﬁrst considered
by Malkhi and Reiter [19]. They have extended this work
in other directions, for example by distinguishing between
crash and Byzantine failures [21]. In the same work, Malkhi
and Reiter show how to use smaller quorums (as opposed to
smaller quorum systems, as examined here), of size .
These constructions however require as many total servers
as their previous work. Investigating whether our SBQ pro-
tocols can be adapted to these smaller quorums remains fu-
ture work. Malkhi and Reiter also explore the load of the
quorum system and present a quorum construction which
does not require the clients to know about the failure sce-
narios [19]. Exploring these concepts in the context of SBQ
is future work.
The idea of distinct read and write quorums has been ex-
plored before [11] but not in the context of Byzantine fail-
ures.
Bazzi [4] explored Byzantine quorums in a synchronous
environment with reliable channels. In this context it is pos-
sible to require fewer servers (f  1 for self-verifying data,
2f  1 otherwise). Our work shows an alternative asyn-
chronous algorithm that can efﬁciently utilize additional
servers to avoid slow reads.
Bazzi [5] argues that an important metric of a quorum
system is the asynchronous access cost – the number of
servers that are contacted during an operation. In a sense,
SBQ has already optimized its use of messages by using
asymmetric quorums. As a result, the asynchronous cost
cannot be optimized further.
Triantaﬁllou and Taylor [30] have extended work in quo-
rums under a fail-stop assumption by reasoning about the
location of the replicas. They present results which provide
similar availability to quorum systems but with improved
latency. Extending these results to Byzantine environments
remains future work.
Phalanx [20] builds shared data abstractions and pro-
vides a locking service, both of which can tolerate Byzan-
tine failure of servers or clients. It uses dissemination and
masking quorums. Asymmetric quorums would not be ap-
propriate in this case because to implement locks, one must
be able to determine when the write operation completes.
Castro and Liskov [9] also attacked the problem of re-
liable storage under Byzantine failures. They implement a
Byzantine-fault-tolerant NFS service using a technique dif-
ferent from quorum systems. They use self-verifying data
only for the (relatively infrequent) view-change and new-
view messages and can tolerate f Byzantine failures using
3f  1 servers.
When using non-self-verifying data, faulty servers can
force new timestamps to take arbitrarily large values. This
is a problem because in practice timestamps can only take
values from a ﬁnite range and therefore faulty servers can
compromise the safety of the protocol. All the quorum pro-
tocols discussed in this paper are vulnerable to this problem,
but it can be solved by applying known techniques [17].
6. Conclusion
We present two Small Byzantine Quorum (SBQ) proto-
cols for shared variables, one that provides safe semantics
for generic data using 3f  1 servers and the other that pro-
vides regular semantics for self-verifying data using 2f  1
servers. This reduces by f the number of servers needed by
previous protocols in the reliable asynchronous communi-
cation model. Our protocols use the novel a-masking and
a-dissemination quorums. They differ from existing quo-
rums for Byzantine systems in that they make a distinction
between read and write quorums.
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:26:38 UTC from IEEE Xplore.  Restrictions apply. 
The reliable channels required by our protocols can be
difﬁcult to engineer, particularly when Byzantine failures
are a concern. We therefore consider Byzantine quorum
protocols with different system models.
In the case of reliable synchronous networks, protocols
that rely on synchrony can be forced to wait for a time-out
if faulty servers do not reply.
It can therefore be advan-
tageous to use asynchronous protocols and to use the syn-
chrony assumption only in the network layer. We propose
an intermediate protocol for the synchronous model which
tolerates f Byzantine failures but also provides the guaran-
tee of self-timed operation as long as the number of actual
failures does not exceed a threshold   (cid:20) f .
For the case of unreliable asynchronous networks we
show how to adapt Malkhi and Reiter’s protocol to this en-
vironment to provide safe semantics using 4f 1 servers or,
if the data is self-verifying, regular semantics using 3f  1
servers.
A limitation of the asymmetric quorums used by the
SBQ protocols is that the implicit synchronization provided
by blocking writes is lost. We are exploring the beneﬁts and
limitations of solutions that combine SBQ protocols with
explicit end-to-end acknowledgments of writes that have
been successfully read.
References
[1] MQSeries, IBM,
http://www-4.ibm.com/software/ts/mqseries.
[2] L. Alvisi, D. Malkhi, E. Pierce, and R. Wright. Dynamic
Byzantine quorum systems.
In Proceedings of the Inter-
national Conference on Dependable Systems and Networks,
June 2000.
[3] G. Banga and P. Druschel. Measuring the capacity of a web
server. In Usenix Symposium on Internet Technologies and
Systems, Oct. 1997.
[4] R. A. Bazzi. Synchronous Byzantine quorum systems. Dis-
tributed Computing Journal Volume 13, Issue 1, pages 45–
52, January 2000.
[5] R. A. Bazzi. Access cost for asynchronous Byzantine quo-
rum systems. Distributed Computing Journal volume 14, Is-
sue 1, pages 41–48, January 2001.
[6] J. W. Byers, M. Luby, M. Mitzenmacher, and A. Rege. A
digital fountain approach to reliable distribution of bulk data.
In SIGCOMM, pages 56–67, 1998.
[7] M. Castro and B. Liskov. Authenticated Byzantine fault tol-
erance without public-key cryptography. Technical Report
/LCS/TM-595, MIT, 1999.
[8] M. Castro and B. Liskov. Proactive recovery in a Byzantine-
fault-tolerant system.
In Proceedings of the Fourth Sym-
posium on Operating Systems Design and Implementation
(OSDI ’00), San Diego, USA, pages 273–287, October 2000.
[9] M. Castro and N. Liskov. Practical Byzantine fault tolerance.
In Proceedings of the Third Symposium on Operating Sys-
tems Design and Implementation (OSDI ’99), New Orleans,
USA, pages 173–186, February 1999.
[10] B. Chandra, M. Dahlin, L. Gao, and A. Nayate. End-to-end
WAN service availability.
In Third Usenix Symposium on
Internet Technologies and Systems (USITS01), March 2001.
[11] S. Davidson, H. Garcia-Molina, and D. Skeen. Consistency
in a partitioned network: a survey. ACM Computing Sur-
veys (CSUR) Volume 17, Issue 3, pages 341–370, September
1985.
[12] J. Gray and A. Reuter. Transaction processing: Concepts and
techniques, 1993.
[13] M. Herlihy. A quorum-consensus replication method for ab-
stract data types. In ACM Transactions on Computer Systems
(TOCS) Volume 4 , Issue 1, pages 32–53, 1986.
[14] J. Hill, R. Szewczyk, A. Woo, S. Hollar, D. Culler, and
K. Pister. System architecture directions for networked sen-
sors. In Proceedings of the Ninth International Conference
on Architectural Support for Programming Languages and
Operating Systems (ASPLOS ’00), Cambridge, USA, pages
93–104, October 2000.
[15] A. D. Joseph, F. A. deLespinasse, J. A. Tauber, D. K. Gifford,
and F. M. Kaashoek. Rover: A Toolkit for Mobile Informa-
tion Access.
In Proceedings of the 15th ACM Symposium
on Operating Systems Principles, pages 156–171, Copper
Mountain, Co., 1995.
[16] L. Lamport. On interprocess communications. Distributed
Computing, pages 77–101, 1986.
[17] M. Li, . Tromp, and P. M. B. Vit´anyi. How to share concur-
rent wait-free variables. Journal of the ACM, 43(4):723–746,
1996.
[18] N. A. Lynch and A. A. Shvartsman. Robust emulation
of shared memory using dynamic quorum-acknowledged
broadcasts.
In Symposium on Fault-Tolerant Computing,
pages 272–281, 1997.
[19] D. Malkhi and M. Reiter. Byzantine quorum systems. Dis-
tributed Computing, pages 203–213, 1998.
[20] D. Malkhi and M. Reiter. Secure and scalable replication in
In Proc. 17th IEEE Symposium on Reliable Dis-
Phalanx.
tributed Systems, West Lafayette, Indiana, USA, Oct 1998.
[21] D. Malkhi, M. Reiter, and A. Wool. The load and availability
of Byzantine quorum systems. SIAM Journal on Computing
29(6), pages 1889–1906, 2000.
[22] J.-P. Martin, L. Alvisi, and M. Dahlin. Small Byzantine quo-
rum systems. Technical report, University of Texas at Austin,
Department of Computer Sciences, December 2001.
[23] J. Postel. Transmission control protocol. Technical Report
RFC-793, Internet Engineering Task Force Network Work-
ing Group, Sept. 1981.
[24] A. Ricciardi. personal communication, Nov. 2001.
[25] J. Robinson. Reliable link layer protocols. Technical Report
RFC-935, Internet Engineering Task Force Network Work-
ing Group, Jan. 1985.
[26] R. Rodrigues, M. Castro, and B. Liskov. BASE: Using ab-
straction to improve fault tolerance.
In Proceedings of the
18th Symposium on Operating Systems Principles (SOSP
’01), October 2001.
[27] M. Sachs and A. Varma. Fibre channel. IEEE Communica-
tions, pages 40–49, August 1996.
[28] M. Schroeder, A. Birrell, M. Burrows, H. Murray, R. Need-
ham, T. Rodeheffer, E. Satterthwaite, and C. Thacker. Au-
tonet: A high-speed, self-conﬁguring local area network us-
ing point-to-point links. IEEE Journal on Selected Areas in
Communications, 9(8), October 1991.
[29] R. H. Thomas. A majority consensus approach to concur-
rency control for multiple copy databases. Database Sys-
tems, 4(2):180–209, 1979.
[30] P. Triantaﬁllou and D. J. Taylor.
The location-based
paradigm for replication: Achieving efﬁciency and availabil-
ity in distributed systems. In IEEE Transactions on Software
Engineering, 21/1, pages 1–18, January 1995.
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:26:38 UTC from IEEE Xplore.  Restrictions apply.