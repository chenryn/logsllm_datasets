provide the services provided at the previous release. Cer-
tain systems may also have DLL ﬁles that are missing on
other systems. Due to these issues the execution environ-
ment must match that of the protected host as close as pos-
sible. Especially, the DLL ﬁles provided on the protected
system must also reside on the monitoring environment.
The following section examines how the detection sys-
tem is implemented to capture trafﬁc on the network, anal-
yse the payload of the packet to determine whether or not it
may contain executable code, execute and monitor the ex-
ecution to detect potentially executable code in a Windows
environment.
6. Windows Monitoring Environment Imple-
mentation
The analyser resides on the Windows test environment
and is located on a host separate from the IDS. Its func-
tion is to execute the potentially executable code, monitor
its execution and generate a log that the IDS can evaluate
to determine whether or not the packet contains executable
instructions.
Our implementation of the Windows execution environ-
ment is implemented using the VMware GSX Server and
Windows 2000 Professional is installed as a virtual ma-
chine. VMware provides features that are desirable for this
application. A snapshot feature is provided which enables
us to create a backup of the system when it is known to be
in a safe state. The safe state may then be restored at an
arbitrary point in time. VMware can be conﬁgured to revert
to the snapshot instead of shutting down. The GSX version
also has a perl API that makes it possible to build applica-
tions capable of reverting the state of the virtual machine.
Using this feature we are ﬁrstly guaranteed that the system
is restored to the known safe state if some malicious code
attempts to shut the environment down. Secondly the IDS
is able to restore the known safe state of the execution envi-
ronment at any given time.
Ideally the known safe state should be restored after ev-
ery single execution. This operation however does incur
substantial overhead, so unless the system is implemented
with a cluster of identical execution environments, service
would be lost for a few seconds. We therefore create a sep-
arate user on the Windows execution environment with re-
stricted privileges that executes the potentially executable
instructions received from the IDS. The restricted user pro-
vides added protection from malicious code due to its lim-
ited privileges. A restricted user may use the operating en-
vironment and save ﬁles but does not have sufﬁcient privi-
leges to install software or make changes to system ﬁles or
settings or add new users to the system. Despite the fact
that processes in the execution environment are running as
unprivileged processes, we are dealing with untrusted code
and measures must be taken to recover from unforeseen
events. Should some malicious code shut down the sys-
tem, VMware will revert it to the known state. This will
cause loss of service from the execution environment for a
few seconds. The IDS should also return the execution en-
vironment to the known safe state with regular intervals to
compensate for potential Trojans on the system. The time
spent returning the environment to the initial state is rela-
tively short, but to provide the service at all times a sec-
ondary system is needed to fall back on during these time
intervals.
A network server is running in the test environment lis-
tening on a port known to the IDS. The server accepts con-
nections from the IDS once some potentially executable in-
structions have been identiﬁed and the IDS transmits the
potentially executable instructions to the server. The server
creates a process containing the potentially executable in-
structions and executes it. The execution is monitored using
the monitoring approaches identiﬁed in Section 4.
Tracing at the NTAPI level initially promised to be a
compelling technique, promising both a simple implemen-
tation of API hook functions and the isolation of trace im-
plementation away from exploit code. Since the tracing is
implemented in the kernel, there would be no way for the
code to introspect that it was being traced. However, in
practise, we observed that there was no readily observable
way to relate the NTAPI logs to higher level goals such as
TCP bind, listen, accept, etc. Furthermore, strace requires
the loading of drivers to modify the system call table. This
operation complicates the implementation of the execution
environment if the potentially executable code is to be ex-
ecuted with the privileges of a restricted user, as this user
does not have sufﬁcient privileges to perform this task.
The entries in Table 1 compare log entries generated by
Detours and strace. strace provides a much more granu-
lar trace of the payload execution. The trace using this
method only includes calls to the operating system, and
provides no tracing of user space function calling. The
log entries contained in Table 1 represent a trace of the
ws2_32.WSASocketA call used to create a socket. This API
call in turn calls LoadLibraryExW to load msafd.dll.
Although the trace produced by strace is much more
granular than that produced by Detours, it does not provide
us with any more detail useful for analysis. The information
provided by Detours is easier to analyse because the log en-
tries represent the more widely known programming API
provided by Windows. Under certain circumstances strace
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:07:54 UTC from IEEE Xplore.  Restrictions apply. 
Table 1. Detours vs strace trace
Detours
ExpandEnvironmentStringsA(%SystemRoot%\system32\msafd.dll,12f570,104)
ExpandEnvironmentStringsA(,C:\WINNT\system32\msafd.dll,) -> 1c
LoadLibraryA(C:\WINNT\system32\msafd.dll)
LoadLibraryExA(C:\WINNT\system32\msafd.dll,0,0)
LoadLibraryExW(C:\WINNT\system32\msafd.dll,0,0)
Strace
NtFsControlFile (24,0,0x0,0x0,0x90028,0x0,0,0, ... {status=0x0, info=0}, 0x0, ) == 0x0
NtQueryAttributesFile ({24,0,0x40,0,0,"\??\C:\WINNT\system32\msafd.dll"},1240756,..)==0x0
NtFsControlFile (24,0,0x0,0x0,0x90028,0x0,0,0,...{status=0x0, info=0}, 0x0, ) == 0x0
NtFsControlFile (24,0,0x0,0x0,0x90028,0x0,0,0,...{status=0x0, info=0}, 0x0, ) == 0x0
NtOpenFile (0x100020,{24,0,0x40,0,0,"\??\C:\WINNT\system32\msafd.dll"},5,96,...80, {status=0x0,
info=1}, ) == 0x0
NtCreateSection (0xe, 0x0, 0x0, 16, 134217728, 80, ... 84, ) == 0x0
NtClose (80, ...
NtMapViewOfSection (84, -1, (0x0), 0, 0, 0x0, 0, 1, 0, 16, ... (0x450000), 0x0, 57344, ) == 0x0
NtClose (84, ...
NtUnmapViewOfSection (-1, 0x450000, ...
NtFsControlFile (24, 0, 0x0, 0x0, 0x90028, 0x0, 0, 0, ... {status=0x0, info=0}, 0x0, ) == 0x0
NtQueryAttributesFile ({24, 0, 0x40, 0, 0, "\??\C:\WINNT\system32\msafd.dll"}, 1241316, ... )
NtFsControlFile (24, 0, 0x0, 0x0, 0x90028, 0x0, 0, 0, ... {status=0x0, info=0}, 0x0, ) == 0x0
NtFsControlFile (24, 0, 0x0, 0x0, 0x90028, 0x0, 0, 0, ... {status=0x0, info=0}, 0x0, ) == 0x0
NtOpenFile (0x100020, {24, 0, 0x40, 0, 0, "\??\C:\WINNT\system32\msafd.dll"}, 5, 96, ... 84,
{status=0x0, info=1}, ) == 0x0
NtCreateSection (0xf, 0x0, 0x0, 16, 16777216, 84, ...
NtClose (84, ...
NtMapViewOfSection (80, -1, (0x0), 0, 0, 0x0, 0, 1, 0, 4, ... (0x74fd0000), 0x0, 69632, ) == 0x0
NtClose (80, ...
NtOpenSection (0xe, {24, 20, 0x40, 0, 0, "USER32.DLL"}, ... 80, ) == 0x0
NtMapViewOfSection (80, -1, (0x0), 0, 0, 0x0, 0, 1, 0, 4, ... (0x77e10000), 0x0, 413696, ) == 0x0
NtClose (80, ...
NtOpenSection (0xe, {24, 20, 0x40, 0, 0, "GDI32.DLL"}, ... 80, ) == 0x0
NtMapViewOfSection (80, -1, (0x0), 0, 0, 0x0, 0, 1, 0, 4, ... (0x77f40000), 0x0, 245760, ) == 0x0
NtClose (80, ...
80, ) == 0x0
== 0x0
== 0x0
== 0x0
)
== 0x0
)
== 0x0
)
)
)
)
)
== 0x0
== 0x0
== 0x0
may miss events completely. During monitoring tests using
known exploits, strace did not generate any log entries for
the execution of bind, listen or accept. The only instance
strace can provide information Detours is incapable of is a
attack where the whole shellcode is coded to use the Na-
tive API as recently demonstrated by Bania [3]. Encoding
all the instructions needed to accomplish something useful
using this API would require a larger input buffer and due
to space limitations when exploiting a vulnerable process
this method has to date not been favoured. Furthermore,
writing shellcode using the native API limits exploit com-
patibility between versions of Windows. Therefore, due
to the difﬁculty in analysing execution traces generated by
strace and the fact that certain events valuable for analysis
are completely missed, execution tracing using Detours is
the favoured approach for our prototype system.
The process executing the potentially executable instruc-
tions may be terminated in two ways. Firstly the execution
may ﬁnish normally. In this case all the instructions have
been processed and the complete trace of the execution has
been captured by the execution monitor. Some processes
however will never ﬁnish and a second approach to termi-
nate execution is required. An example of code that will
never ﬁnish is code that starts a server listening for incom-
ing connections. The execution will in this circumstance
hang on the accept function call. We therefore terminate all
monitored processes after the execution time exceeds a set
threshold of ﬁve seconds. In this case the captured log may
only contain parts of the instructions contained in an incom-
ing packet but provides sufﬁcient information for analysing
the operations of the attack.
Once the execution is ﬁnished, the log is relayed back to
the IDS. The IDS analyses the log searching for evidence of
calls to DLL functions. A single function call is sufﬁcient
to determine that the incoming packet contained shellcode
formatted executable instructions, and an alert is in this case
generated. The following section contains test results gath-
ered using the Windows execution environment to detect
code injection attacks.
7. Test Results
We have tested our detector on a variety of exploits tar-
geting Windows hosts. The NOP detection method that we
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:07:54 UTC from IEEE Xplore.  Restrictions apply. 
employ is better suited for the UNIX environment due to the
possibility of using return-into-DLL style attack patterns to
gain control of the instruction pointer in the Windows en-
vironment as discussed in Section 3.1. Therefore, although
our system is highly accurate in its detection and generates
few false positives, the completeness property of the system
will never be better than its capability of detecting potential
executable code in the network trafﬁc stream. The approach
will beneﬁt from a more accurate algorithm for detecting
potential executable code in network trafﬁc than the NOP
detection algorithm provides and once such an algorithm is
identiﬁed the completeness property of the system will be
further improved. Despite this fact our approach is capable
of detecting a number of attacks. Examples of attacks de-
tected are buffer overﬂow exploits against the RPCSS ser-
vice (MS03-039), Microsoft FrontPage Server extensions
(MS03-051) and WINS (MS04-045). We now examine the
exploit against Microsoft FrontPage Server extensions with
regards to its operation and detection.
The exploit targeting Microsoft FrontPage Server exten-
sions overﬂows a buffer in fp30reg.dll with executable code
that binds a shell on port 9999 on the vulnerable host. The
attacker is then able to log in by using telnet, browse the
ﬁle system and perform actions identical to a user having
a cmd shell locally on the host. Parts of the machine in-
structions for the exploit are contained in Table 2. The ﬁrst
part of the exploit contains a decoding function which de-
codes the payload of the attack. This function serves two
purposes. Firstly it ensures that the payload does not con-
tain any terminating characters (NULL characters) when the
attack is transmitted across the network. Secondly it ob-
fuscates the payload of the attack and complicates pattern
matching IDSes and IDSes utilising the abstract execution
approach. The decoding function has been bolded in Ta-
ble 2. The bolded decoding function XORs the rest of the
payload with a key, in this case 88h, to obtain the clear text
payload. The assembly instructions are contained in Table
3.
is located.
Then a call
First
Because our approach is based on executing malicious
code in a sandbox, payload obfuscation techniques are
rendered useless as an IDS avoidance measure. Once
the decoding function has completed the attack pay-
the base address
load is ready to be executed.
of kernel32.dll
table is con-
structed and the address of kernel32.LoadLibraryA and
ws2_32.dll
The address of ws2_32.dll
is used to initialise the WinSock API. Once this has
been completed the rest of the call table is populated