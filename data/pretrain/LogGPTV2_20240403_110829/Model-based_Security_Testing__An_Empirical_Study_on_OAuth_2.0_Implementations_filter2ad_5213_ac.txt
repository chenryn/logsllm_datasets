Let’s consider the automatic authorization feature which is not dis-
cussed in the OAuth standard speciﬁcation. While testing OAuth
implementation in action, we observe that Request R2 would im-
mediately lead to State S5 if the user has authorized the applica-
tion. OAuthTester does not expect such a response and thus output
an error notiﬁcation. After inspecting the log information, we ﬁ-
nally identify this feature and manually encode this feature into the
model. For another example, Facebook recently applies a new pa-
rameter signed_request to conﬁrm the identity of a user. Because
many applications adopt this parameter incorrectly, the properties
of this parameter in different applications become different. As
such, OAuthTester helps to identify this parameter is also a key pa-
rameter deﬁned by IdP. With the document of IdP, we then can cor-
rectly initialize its security-related property. OAuthTester thereby
can prompt warnings once its property is changed as if this param-
eter is also deﬁned by the speciﬁcation.
Although the above reﬁnement requires manual intervention, such
manual effort only needs to be done once per IdP under test and
then be reused across all of its real-world implementations.
5.
IMPLEMENTATION
We have implemented OAuthTester in Python with 5668 lines
of code. It takes, on average, 20.3 minutes to complete the testing
of an OAuth-based application, using a machine with a 1.4GHz
dual core CPU and 4GB memory running Ubuntu 12.04. In this
section, we ﬁrst discuss the automation level of OAuthTester and
then present various heuristics to speed up the testing process as
well as to boost the detection accuracy.
5.1 Efﬁciency Consideration
Since every attempted button click or HTTP request involves a
high-latency round-trip with IdP/ App, reducing the number of test
Figure 5: Design Request Sequence to Break Execution Ordering
cases is important to complete the testing within a reasonable time.
We thus utilize the following heuristics to discover as many poten-
tial security ﬂaws as possible within a limited time: (1) For those
features which are shared among applications, we just test them
once (e.g. for only one application). For example, once conﬁrm-
ing the authorization code (in Step R5 of Fig. 3) is one-time used,
it is not necessary to infer the property of this parameter for other
applications of the same IdP. (2) We ﬁrst check the applications
for previously known loopholes to ﬁnd all potential vulnerabilities
for an application as soon as possible. (3) We mainly focus on the
waypoint to construct out-of-order requests.
5.2 Detection Accuracy
In general, OAuthTester should not report any false positives
since we will check whether the system moves to the expected state
after each state transition and re-validate the security properties for
any abnormal behavior. We conﬁrmed this hypothesis by randomly
selecting 40 out of 405 applications for manual validation. And the
manual checking does not ﬁnd any false positives. On the other
hand, false negative is possible because of the following three rea-
sons. First, we can only guarantee to cover all paths deﬁned by
the state machine rather than the real implementation. If the model
is too coarse grained, then we may miss some vulnerabilities in
practice. Second, we only concern the SSO process without pay-
ing attention to the subsequent operations of this application under
test after authentication. Finally, OAuthTester only looks for the
original formats of key parameters or their values (e.g., access to-
ken=xxx) – it cannot ﬁnd any leakage once the key parameter has
been further obfuscated.
6. EMPIRICAL RESULTS
Using OAuthTester, we systematically examined 500 top-ranked
websites in US and China6, of which there are 405 websites im-
plementing the OAuth services provided by 4 major IdPs includ-
ing Facebook, Sina, Renren and Tencent Weibo. OAuthTester has
enabled us to discover different forms of widespread misuses/ mis-
handling of the critical STATE parameter in OAuth and two classes
of previously unknown logic ﬂaws on the IdP side. We also provide
new exploits for a well-known vulnerability, i.e., failure to adopt
TLS protection. Besides discovering these previously unknown vul-
nerabilities, the automated OAuthTester also successfully detected
numerous existing security ﬂaws, some of which were identiﬁed
manually by earlier research.
6.1 Discovered Vulnerability 1: Misuse of the
STATE Parameter
6.1.1 Observed Results
According to RFC6749 [18], the STATE parameter should be
generated and handled as a nonce. In addition, it should be bound to
6Ranked by Alexa: http://www.alexa.com/topsites.
Facebook (79)
Sina (182)
Renren (68)
Tencent Weibo3 (36)
Average (405)
12.50%
13.32%
18.17%
12.50%
13.09%
14.29%
13.32%
9.09%
12.50%
11.85%
21.42%
59.97%
30.31%
12.50%
37.53%
5.37%
38.66%
18.19%
37.50%
18.52%
14.29%
10.68%
12.12%
12.50%
11.36%
Parameter
7.14%
32.01%
24.23%
0
20.00%
35.72%
74.67%
65.13%
50.00%
55.31%
Table 2: Statistics of STATE Parameter Misuse1 2
IdPs (NO. of
Applications)
Lack
STATE
Validation
Lenient
STATE
Validation
STATE
Not Bind
to User
STATE Replay
Summary
Multiple Use
Same STATE
Constant STATE
Until Next Login
for One Browser
• 1 We divide the number of App with speciﬁc problem by the number of tested applications which use the STATE parameter.
• 2 There may be overlaps. For example, applications lacking of validation may also be susceptible to lenient STATE validation.
• 3 Only 8 applications use the STATE parameter, thus the distribution is skewed.
by App.
a session to defend against CSRF attacks reported in [5,20,37]. Un-
fortunately, we have found that 61.23% of applications under study
do not use the STATE parameter. Even worse, for those applica-
tions which support the STATE parameter, 55.31% of them are still
vulnerable to CSRF attacks due to the misuse/ mishandling of the
STATE parameter. In particular, OAuthTester has discovered the
following misuse cases via fuzzing as discussed in Section 4.2.1:
• Lack of STATE Validation: STATE parameter is not validated
• Lenient STATE Validation: If there is a STATE parameter, ap-
plications can verify it correctly. However, App also accepts
requests with missing STATE parameter.
• STATE Does Not Bind to User: The App assumes all the STATE
parameters generated by itself are valid and fails to check
whether this parameter is bound to the user’s session. As a
result, the attacker can substitute the victim’s STATE parame-
ter with her own in a forged request.
• STATE Replay: The STATE parameter can be reused for sev-
eral times. According to the validity of the STATE parameter,
there are three cases. The ﬁrst two cases require an attacker to
possess the victim’s STATE parameter somehow. As shown in
Fig. 6, 43.95% of the tested applications are vulnerable to the
STATE Replay attack and they do not use TLS to protect the
STATE parameter at the same time. Therefore, the attacker
can obtain the STATE parameter by eavesdropping.
– Multiple Use Until Next Login: The STATE parameter
remains valid until the victim tries to login the applica-
tion again. Only at this point would a new STATE value
be generated.
– Same STATE for One Browser: The same value is used
for the same user as long as the user uses the same browser.
– Constant STATE parameter: The parameter remains un-
changed across different sessions and users.
Security Implications
6.1.2
Due to the misuse of the STATE parameter, an attacker can then
launch a CSRF attack7, which can lead to at least two problems.
The ﬁrst one is the so-called “Login CSRF" [6], which allows an at-
tacker to log the victim into an application as the attacker. Depend-
ing on the services provided by the application, the consequence
includes an attacker being able to sniff at the victim’s activities on
the application. Although this attack may seem mild, its impact can
be ampliﬁed by our newly discovered Dual-Role IdP attacks which
will be the subject of Section 6.2.
Besides Login CSRF attack, it can also result in account hijack-
ing, i.e., an attacker can log into the application as the victim as
shown in [20]. Different from previous works [5, 18, 20, 36, 37]
7The attack procedure can be found in the appendix.
which believed that these attacks are only possible when the STATE
parameter is missing, our OAuthTester showed that even if the
STATE parameter is used, it could be misused in many different
forms which could lead to various attacks.
6.1.3 Plausible Root Causes
Surprised by the large percent of applications which cannot han-
dle the STATE parameter correctly, we set out to analyze the under-
lying reason by examining the OAuth software development kits
(SDKs) and programming guides provided by the four IdPs under
study as well as Google. We found that all of the ofﬁcial SDKs
provided by the IdPs do not include routines for application devel-
opers to manage the STATE parameter. Instead, most of the IdPs
merely state that the STATE parameter should be a nonce without
giving a code snippet or providing a routine for checking whether
the STATE parameter is implemented correctly.
In other words,
application developers must implement the STATE parameter by
themselves, which turns out to be more complicated than we ex-
pect. In fact, even some IdPs implement or manage this parameter
incorrectly. For example, the STATE parameter “should be” a con-
ﬁdential knowledge in case of the STATE Replay attack. However,
Renren, one of the major Chinese IdPs, fails to follow this require-
ment and simply redirects the STATE parameter to a non-TLS end-
point. In another example, Sina is a dual-role IdP (see Section 6.2)
and employ Facebook to provide the OAuth service for users out-
side China. However, its implementation for Facebook does not
validate the STATE parameter at all.
6.1.4 Recommended Mitigations
As a remedy, we propose to generate and verify the STATE pa-
rameter in the SDK so that a typical application developer can also
implement this parameter correctly without much effort. As a proof
of concept, we have extended Google’s OAuth Python SDK with
merely 12 lines of code to add two functions, namely, the gen-
eration and veriﬁcation of the STATE parameter. To process the
STATE parameter in the SDK, application developers are required
to explicitly invoke these two functions, respectively. Although
integrating the STATE parameter into the SDK seems straightfor-
ward, this solution has the following limitations, which may ex-
plain why IdPs do not adopt the scheme:
• The process of the STATE parameter is tightly related to ses-
sion management, for which the application developers have
multiple options. It is difﬁcult for the SDK, which is supposed
to deﬁne the core functionality only, to consider the different
operations among numerous session management tools. As a
result, the SDK-based solution may not be applicable to every
programmer.
• While the SDK can help to generate and verify the STATE pa-
rameter, 61.23% Apps under study do not send this parameter
to IdP, which renders the server-side SDK code useless.
To overcome the former limitation, we suggest the SDK designer to
support the popular session management tools (e.g, KVSession of
Python Flask) and provide a template for the programmers to spec-
ify their choice of session management tool. With such support, the
SDK can manage the STATE parameter stored by the session tool
accordingly. To address the latter limitation, IdP should make the
STATE parameter mandatory by checking its presence in speciﬁc
requests (Step 3 in Fig. 1) and warn the programmer if it is missing.
We also observe Google goes one step further by providing a toy
application, which shows the correct usage of the STATE parame-
ter. However, the sample codes for managing the STATE parameter
are scattered across different parts of the application. Without high-
lights, application developers may ignore or miss part of the codes.
Furthermore, the toy application fails to follow the best practice of
deleting the one-time STATE parameter after veriﬁcation. While
the objective of this practice is to allow a logout-user to re-login
the application without reloading the page, such implementation
in turn makes the toy application vulnerable to the STATE Replay
attack, i.e., Multiple Use Until Next Login in Table 2.
In short, it is not straightforward to correctly reuse or adapt the
sample code of a toy application to a real-world one. Worse still,
some applications may implement OAuth in their own ways with-
out using the SDK. Therefore, we propose a complementary so-
lution beyond the modiﬁcation of SDK. Speciﬁcally, we provide
a step-by-step guideline for the programmers to add the following
code snippet to the right place of their application. While we only
use Python and a lightweight Web framework Flask as the example,
the steps can be applicable for other web languages such as PHP.
1. Generate a random STATE value at Step 2 of Fig. 1:
s t a t e = ’ ’ . j o i n ( random . c h o i c e (
s t r i n g . a s c i i _ u p p e r c a s e + s t r i n g . d i g i t s )
f o r x i n x r a n g e ( 3 2 ) )
2. Bind the STATE parameter to the session once the STATE pa-
rameter is generated:
s e s s i o n [ ’ s t a t e ’ ] = s t a t e
3. Compare the STATE parameter when receiving the response
at Step 5 of Fig. 1:
r e q u e s t . a r g s . g e t ( ’ s t a t e ’ ,
i f
s e s s i o n [ ’ s t a t e ’ ] :
r e t u r n e r r o r
’ ’ )
!=
4. After comparison, delete this one-time STATE parameter:
d e l
s e s s i o n [ ’ s t a t e ’ ]
6.2 Discovered Vulnerability 2: Ampliﬁcation
Attack via Dual-Role IdPs
6.2.1 Observed Results
A Dual-Role IdP is an IdP which offers OAuth-based authenti-