a novel variant of a stack unwinding [3] inspecting stack layout invariants.
Control-ﬂow integrity (CFI) [8] provides strong measures to defeat ROP
attacks by strictly checking the control-ﬂow of programs. Recent approaches made
a signiﬁcant progress in the compiler-based techniques [18,56] and achieved practi-
cal solutions by relaxing strict control-ﬂows [60,61]. When only program binaries
are available, the stack frame chain invariant of SLIck provides a practical and
transparent alternative to verify the backward chain of control ﬂow while provid-
ing a performance beneﬁt and high applicability without requiring source code,
program transformation, or a complete control ﬂow.
User-Space-Only Self-hiding ROP Attacks. ROP gadgets are typically
used to achieve a new logic which may not exist in the original program. Most
real exploits typically make use of the OS level services [57], such as allocating
memory and changing its permissions. Technically it is possible to execute ROP
gadgets and recover the manipulation of the stack before the transition to the OS
to hide the evidence from SLIck. Such user-space-only ROP attacks in practice
would be non-trivial to keep track of the manipulated states and implement a
clean up logic without stack pivoting which SLIck detects. The inspections on
system calls will capture any such attempt on system related activities. Non-
deterministic OS events, such as timer interrupts (varying between 4–20 ms in
our experiments), and the inspection events with random intervals will make
it further diﬃcult for the exploit to precisely predict the inspection time. This
advanced attack to hide itself is an aspect that needs further study which is our
future work.
Integrity of Stack Frame Information. For a robust detection of ROP
attacks, SLIck ensures the integrity of stack frame information as follows. The
integrity of this information inside a binary is veriﬁed using a ﬁle integrity checker
[30]. Given the ﬁle integrity, SLIck makes its own shadow copy of the .eh frame
section copied directly from the binary to prevent any manipulation. However,
its copy loaded into the program’s memory for exception handling is subject to
potential attacks [34]. The OS kernel makes it read-only, but it is not immutable.
Thus SLIck enforces the read-only permission on the program’s copy to prevent
the attack [34].
Attacks Using Binaries Without Stack Frame Information. Our study
presented in Sect. 2 shows that most Linux ELF binaries except special binaries,
such as a Linux kernel image and kernel drivers, have stack frame information.
A typical compilation of programs includes stack frame information to support
exceptions and debugging by default. Binaries without stack frame information
are not supported by SLIck due to the lack of required information for stack
walking. Such unusual binaries can be prevented from running using system wide
Detecting Stack Layout Corruptions with Robust Stack Unwinding
89
program execution policies. For instance, SLIck can prevent the execution of
such binaries when stack frame information is lacking.
Implementing SLIck on Other Platforms. This work focuses on the stack
layout information in the ELF binary format, which is popular in Linux and
BSD environments. However, other OS environments have similar informa-
tion for exception handling and debugging. For instance, Windows has the
RtlVirtualUnwind API that can unwind the stack by using the unwind descrip-
tors of the structured exception handling (SEH) tables in the program images,
which can be dumped using the dumpbin utility with the /UNWINDINFO option [7].
Mac OS’ main binary format, Mach-O [4], has similar binary sections, such as
.eh frame, .cfi startproc, .cfi def cfa offset etc. These information can
be used to implement a similar function as SLIck in those OS platforms.
Attacks Using Type A Cases for ROP Gadgets. Based on our study
of diverse binaries, a very small number of common libraries have the missing
unwinding information in a rare portion of their code: the entry point of the
dynamic linker and loader, the ﬁrst stack frame which is the start of the program,
and the init section of the pthread library. Although the portion of code is
small and its capability could be limited, it is possible for the attacker to use
this code for gadgets. While we have not presented a speciﬁc mechanism to
defeat this attack, it can be easily prevented by supplementing the incomplete
unwinding information because the scope of such code is very limited. Similar to
the technique that we used for constructing the TVC, the unwinding information
can be generated by emulating the stack operations of the binary code.
8 Related Work
ROP and Related Attacks. Return oriented programming (ROP) [46] is an
oﬀensive technique that reuses pieces of existing program code to compromise
a vulnerable program and bypass modern security mechanisms, such as DEP
and some ASLR implementations [9] under certain conditions (e.g., memory
disclosure vulnerabilities or low entropy ASLRs). It has also been applied in
other attack vectors, such as rootkits [15,29]. In addition to the local application
of this technique, Bittau et al. proposed the blind ROP (BROP) [9] which can
remotely ﬁnd ROP gadgets to fetch the vulnerable binary over network.
Similar to ROP, another type of control-ﬂow transfer attack based on gadget-
reuse is jump oriented programming (JOP) [10], which uses jumps instead of
returns. Bosman et al. [11] proposed another type of ROP based on the signal
handling function which is universal in UNIX systems. This technique called
SigReturn Oriented Programming (SROP) is triggered by the manipulated signal
frames stored on a user stack.
90
Y. Fu et al.
ROP Defense. Several mitigation techniques were proposed to defend against
ROP attacks such as ASLR [26,28,37,44,53,59,60], compiler techniques [31,35],
runtime instrumentation techniques [14,19], and hardware techniques [16,38].
ASLR has been used to block code reuse attacks by dynamically assigning
the memory addresses of the code and data sections such that the predeter-
mined memory addresses can be illegal. However, in practice some code may
not be compatible with this scheme, thereby leaving attack vectors. Also sev-
eral approaches have shown that it is possible to bypass this scheme based on
information leakage or brute-force attacks [20,47,49,50,52,58].
When source code is available, it is possible to remove attack gadgets through
a compiler transformation as shown in [31,35]. If source code is not available,
dynamic binary instrumentation can be used to monitor the execution and detect
ROP attacks. Drop [14] used the length of gadgets and the contiguous length
of gadget chains to characterize and detect ROP attacks. ROPdefender [19]
uses binary instrumentation to manage a shadow stack which is not tampered by
stack manipulation. These approaches in general have a low runtime eﬃciency
due to a high cost of dynamic binary translation.
RoPecker [16] and kBouncer [38] proposed to utilize the Last Branch
Record (LBR) registers to eﬃciently inspect the runtime history. These
approaches are established on the assumptions of gadget patterns, such as the
short length of gadgets and a long sequence of consecutive gadgets. Unfortu-
nately, new ROP attack techniques showed such gadget-pattern based schemes
can be bypassed [12,25]. ROPGuard [21] (later integrated into the Microsoft
EMET [55]) performs stack inspections for a limited depth at selective critical
Windows APIs. This inspection unwinds the user stack using the heuristic on
the frame pointer which would be limited based on the build conditions; unless
programs are compiled to use the frame pointers, they could not be reliably
inspected. In contrast, the stack frame information in the .eh frame enables a
precise and reliable unwinding regardless of the requirement of the frame pointer.
The comparison between SLIck and related work in Table 3 highlights that
SLIck does not have assumptions on the characterization of ROP gadgets. Hence
it is not aﬀected by recent attacks [12,25]. Also its stack unwinding technique
Table 3. Comparison of ROP detection approaches. CL: without using a chain length,
GL: without using a gadget length. SC: without using source code. RW: without rewrit-
ing. RE: Runtime eﬃciency. RU: Reliable unwinding.
✗
CL GL SC RW RE RU Main techniques
(cid:2) (cid:2)
(cid:2) (cid:2)
✗
✗
(cid:2) -
(cid:2) -
✗
-
✗
Gadget removal based on a compiler technique
Gadget removal based on a compiler technique
ROP detector
Returnless [31]
GFree [35]
✗
✗
(cid:2) ✗
Drop [14]
ROPdefender [19] (cid:2) (cid:2) (cid:2) ✗
(cid:2) ✗
kBouncer [38]
(cid:2) (cid:2)
RoPecker [16]
✗
(cid:2) (cid:2) (cid:2) ✗
ROPGuard [21]
(cid:2) (cid:2) (cid:2) (cid:2)
SLIck
✗
✗
✗
ROP detection based on gadget characteristics
Shadow stack and dynamic instrumentation
Last branch recording and gadget characteristics
✗
-
(cid:2) -
(cid:2) -
(cid:2)
✗
(cid:2) (cid:2) Stack invariants veriﬁed by a reliable stack unwinding
Stack unwinding based on the frame pointer
Last branch recording and sliding window
Detecting Stack Layout Corruptions with Robust Stack Unwinding
91
is more reliable based on the precise stack frame information widely available in
the binaries of mainstream Linux distributions. These unique properties enable
SLIck to achieve a practical solution which does not require source code, or
rewriting of the program binaries for ROP detection.
9 Conclusion
We have presented SLIck, a robust and practical detection mechanism of ROP
exploits that is not aﬀected by recent attacks based on the violation of previous
assumptions on gadget patterns [12,25]. SLIck detects ROP exploits by using
stack layout invariants derived from the stack unwinding information for excep-
tion handling widely available in Linux binaries. Our evaluation on real-world
ROP exploits shows robust and eﬀective detection without any requirements on
source code or recompilation while it incurs low overhead.
Acknowledgments. We would like to thank our shepherd, Michalis Polychronakis,
and the anonymous reviewers for their insightful comments and feedback. Yangchun Fu
and Zhiqiang Lin were supported in part by the AFOSR grant no. FA9550-14-1-0173
and the NSF award no. 1453011. Any opinions, ﬁndings, conclusions, or recommenda-
tions expressed are those of the authors and do not necessarily reﬂect the views of any
organization.
References
1. Dwarf debugging information format, version 4. http://www.dwarfstd.org/doc/
DWARF4.pdf
2. Exception
frames.
https://refspecs.linuxfoundation.org/LSB 3.0.0/LSB-Core-
generic/LSB-Core-generic/ehframechpt.html
3. Exceptions and stack unwinding in C++. http://msdn.microsoft.com/en-us/
library/hh254939.aspx
4. Mach-o executables,
issue 6 build tools. http://www.objc.io/issue-6/mach-o-
executables.html
5. Structured exception handling. http://msdn.microsoft.com/en-us/library/windows/
desktop/ms680657(v=vs.85).aspx
6. System V Application Binary Interface (ABI), AMD64 Architecture Processor Sup-
plement, Draft Version 0.98
7. x64 manual
stack reconstruction and stack walking. https://blogs.msdn.
microsoft.com/ntdebugging/2010/05/12/x64-manual-stack-reconstruction-and-
stack-walking/
8. Abadi, M., Budiu, M., Erlingsson, U., Ligatti, J.: Control-ﬂow integrity. In: Pro-
ceedings of CCS (2005)
9. Bittau, A., Belay, A., Mashtizadeh, A., Mazieres, D., Boneh, D.: Hacking blind.
In: Proceedings of IEEE Security and Privacy (2014)
10. Bletsch, T., Jiang, X., Freeh, V.W., Liang, Z.: Jump-oriented programming: a new
class of code-reuse attack. In: Proceedings of ASIACCS (2011)
11. Bosman, E., Bos, H.: Framing signals - a return to portable shellcode. In: Proceed-
ings of IEEE Security and Privacy (2014)
92
Y. Fu et al.
12. Carlini, N., Wagner, D.: ROP is still dangerous: breaking modern defenses. In:
Proceedings of USENIX Security (2014)
13. Checkoway, S., Davi, L., Dmitrienko, A., Sadeghi, A.R., Shacham, H., Winandy,
M.: Return-oriented programming without returns. In: Proceedings of CCS (2010)
14. Chen, P., Xiao, H., Shen, X., Yin, X., Mao, B., Xie, L.: DROP: detecting return-
oriented programming malicious code. In: Prakash, A., Sen Gupta, I. (eds.) ICISS
2009. LNCS, vol. 5905, pp. 163–177. Springer, Heidelberg (2009)
15. Chen, P., Xing, X., Mao, B., Xie, L.: Return-oriented rootkit without returns (on
the x86). In: Proceedings of ICICS (2010)
16. Cheng, Y., Zhou, Z., Yu, M., Ding, X., Deng, R.H.: ROPecker: a generic and
practical approach for defending against ROP attacks. In: Proceedings of NDSS
(2014)
17. Cowan, C., Pu, C., Maier, D., Hinton, H., Walpole, J., Bakke, P., Beattie, S., Grier,
A., Wagle, P., Zhang, Q.: Stackguard: automatic adaptive detection and prevention
of buﬀer-overﬂow attacks. In: Proceedings of USENIX Security (1998)
18. Criswell, J., Dautenhahn, N., Adve, V.: KCoFI: complete control-ﬂow integrity for
commodity operating system kernels. In: Proceedings of the IEEE Security and
Privacy (2014)
19. Davi, L., Sadeghi, A.R., Winandy, M.: ROPdefender: a detection tool to defend
against return-oriented programming attacks. In: Proceedings of ASIACCS (2011)
20. Durden, T.: Bypassing PaX ASLR protection. Phrack Mag. 59(9), June 2002.
http://www.phrack.org/phrack/59/p59-0x09
21. Fratric,
I.: ROPGuard: runtime prevention of return-oriented programming
attacks. https://code.google.com/p/ropguard/
22. Garﬁnkel, T., Pfaﬀ, B., Chow, J., Rosenblum, M., Boneh, D.: Terra: a virtual
machine-based platform for trusted computing. In: Proceedings of SOSP (2003)
23. Garﬁnkel, T., Rosenblum, M.: A virtual machine introspection based architecture
for intrusion detection. In: Proceedings of NDSS (2003)
24. Goktas, E., Athanasopoulos, E., Bos, H., Portokalidis, G.: Out of control: overcom-
ing control-ﬂow integrity. In: Proceedings of IEEE Security and Privacy (2014)
25. G¨okta¸s, E., Athanasopoulos, E., Polychronakis, M., Bos, H., Portokalidis, G.: Size
does matter: why using gadget-chain length to prevent code-reuse attacks is hard.
In: Proceedings of USENIX Security (2014)
26. Hiser, J., Nguyen-Tuong, A., Co, M., Hall, M., Davidson, J.W.: ILR: where’d my
gadgets go? In: Proceedings of IEEE Security and Privacy (2012)
27. Hofmann, O.S., Dunn, A.M., Kim, S., Roy, I., Witchel, E.: Ensuring operating
system kernel integrity with OSck. In: Proceedings of ASPLOS (2011)
28. Howard, M., Thomlinson, M.: Windows ISV software security defenses. http://
msdn.microsoft.com/en-us/library/bb430720.aspx
29. Hund, R., Holz, T., Freiling, F.C.: Return-oriented rootkits: bypassing kernel code
integrity protection mechanisms. In: Proceedings of USENIX Security (2009)
30. Kim, G.H., Spaﬀord, E.H.: The design and implementation of tripwire: a ﬁle system
integrity checker. In: Proceedings of CCS (1994)
31. Li, J., Wang, Z., Jiang, X., Grace, M., Bahram, S.: Defeating return-oriented rootk-
its with “return-less” kernels. In: Proceedings of EuroSys (2010)
32. Microsoft: A detailed description of the Data Execution Prevention (DEP) feature
in Windows XP Service Pack 2 (2008). http://support.microsoft.com/kb/875352
33. Mudge: How to Write Buﬀer Overﬂows (1997). http://l0pht.com/advisories/
bufero.html
34. Oakley, J., Bratus, S.: Exploiting the hard-working DWARF: trojan and exploit
techniques with no native executable code. In: Proceedings of WOOT (2011)
Detecting Stack Layout Corruptions with Robust Stack Unwinding
93
35. Onarlioglu, K., Bilge, L., Lanzi, A., Balzarotti, D., Kirda, E.: G-free: defeat-
ing return-oriented programming through gadget-less binaries. In: Proceedings of
ACSAC (2010)
36. Aleph One: Smashing the stack for fun and proﬁt. Phrack 7(49), November 1996.
http://www.phrack.com/issues.html?issue=49&id=14
37. Pappas, V., Polychronakis, M., Keromytis, A.D.: Smashing the gadgets: hindering
return-oriented programming using in-place code randomization. In: Proceedings
of IEEE Security and Privacy (2012)
38. Pappas, V., Polychronakis, M., Keromytis, A.D.: Transparent ROP exploit miti-
gation using indirect branch tracing. In: Proceedings of USENIX Security (2013)
39. Petroni Jr., N.L., Fraser, T., Molina, J., Arbaugh, W.A.: Copilot - a coprocessor-
based kernel runtime integrity monitor. In: Proceedings of USENIX Security (2004)
40. Petroni Jr., N.L., Fraser, T., Walters, A., Arbaugh, W.A.: An architecture for
speciﬁcation-based detection of semantic integrity violations in kernel dynamic
data. In: Proceedings of USENIX Security (2006)
41. Petroni Jr., N.L., Hicks, M.: Automated detection of persistent kernel control-ﬂow
attacks. In: Proceedings of CCS (2007)
42. Pietrek, M.: A crash course on the depths of win32 structured exception handling.
Microsoft Syst. J. 12(1), January 1997
43. Prakash, A., Yin, H.: Defeating ROP through denial of stack pivot. In: ACSAC
(2015)
44. Roglia, G.F., Martignoni, L., Paleari, R., Bruschi, D.: Surgically returning to ran-
domized lib(c). In: Proceedings of ACSAC (2009)
45. Seshadri, A., Luk, M., Qu, N., Perrig, A.: SecVisor: a tiny hypervisor to provide
lifetime kernel code integrity for commodity OSes. In: Proceedings of SOSP (2007)
46. Shacham, H.: The geometry of innocent ﬂesh on the bone: return-into-libc without
function calls (on the x86). In: Proceedings of CCS (2007)
47. Shacham, H., Page, M., Pfaﬀ, B., Goh, E.J., Modadugu, N., Boneh, D.: On the
eﬀectiveness of address-space randomization. In: Proceedings of CCS (2004)
48. Smith, N.P.: Stack Smashing Vulnerabilities in the UNIX Operating System (2000)
49. Snow, K.Z., Monrose, F., Davi, L., Dmitrienko, A., Liebchen, C., Sadeghi, A.R.:
Just-in-time code reuse: on the eﬀectiveness of ﬁne-grained address space layout
randomization. In: Proceedings of IEEE Security and Privacy (2013)
50. Sotirov, A., Dowd, M.: Bypassing browser memory protections in windows vista.
http://www.phreedom.org/research/bypassing-browser-memory-protections/
51. Spaﬀord, E.H.: The internet worm program: an analysis. SIGCOMM Comput.
Commun. Rev. 19, 17–57 (1989)
52. Strackx, R., Younan, Y., Philippaerts, P., Piessens, F., Lachmund, S., Walter, T.:
Breaking the memory secrecy assumption. In: Proceedings of EuroSec (2009)
53. PaX Team: http://pax.grsecurity.net/
54. PaX Team: Pax address space layout randomization (ASLR) (2003). http://pax.
grsecurity.net/docs/aslr.txt
55. The Enhanced Mitigation Experience Toolkit, Microsoft. http://technet.microsoft.
com/en-us/security/
56. Tice, C., Roeder, T., Collingbourne, P., Checkoway, S., Erlingsson, ´U., Lozano,
L., Pike, G.: Enforcing forward-edge control-ﬂow integrity in GCC & LLVM. In:
Proceedings of USENIX Security (2014)
57. Tran, M., Etheridge, M., Bletsch, T., Jiang, X., Freeh, V., Ning, P.: On the expres-
siveness of return-into-libc attacks. In: Proceedings of RAID (2011)
58. Vreugdenhil, P.: Pwn2own 2010: Windows 7 internet explorer 8 exploit. http://
vreugdenhilresearch.nl/Pwn2Own-2010-Windows7-InternetExplorer8.pdf
94
Y. Fu et al.
59. Wartell, R., Mohan, V., Hamlen, K.W., Lin, Z.: Binary stirring: self-randomizing
instruction addresses of legacy x86 binary code. In: Proceedings of CCS (2012)
60. Zhang, C., Wei, T., Chen, Z., Duan, L., Szekeres, L., McCamant, S., Song, D., Zou,
W.: Practical control ﬂow integrity and randomization for binary executables. In:
Proceedings of IEEE Security and Privacy (2013)
61. Zhang, M., Sekar, R.: Control ﬂow integrity for cots binaries. In: Proceedings of
the USENIX Security (2013)
62. Zovi, D.A.D.: Return oriented exploitation. In: Blackhat (2010)