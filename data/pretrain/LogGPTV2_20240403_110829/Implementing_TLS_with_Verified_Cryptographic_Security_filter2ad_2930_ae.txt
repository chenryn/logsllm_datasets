p:(;id,d,r) plain → (k’:(;id)key ∗ c:cipher)
{CipherRange(id,r,c) ∧ ENCrypted(id,d,p,c)}
val DEC: id:index → k:(;id) key → d:(;id) data → c:cipher →
o:(k’:(;id) key ∗ r :range {CipherRange(id,r,c)} ∗
{Auth(id) ⇒ !k’,r,p, (o = Some(k’,r,p) ⇔ ENCrypted(id,d,p,c))}
p :(;id,d,r) plain) option
The index id determines the algorithms to use. Keys for a
particular index are created by calling GEN; they encapsulate
the full encryption state, typically an encryption key, a MAC
key, and (when necessary) an IV or stream cipher state.
Encryption ENC takes a plaintext, executes the MAC-
Encode-Encrypt sequence, and returns a cipher and (poten-
tially) updated key. Decryption DEC takes a cipher, decrypts,
decodes, and veriﬁes the MAC; if every check succeeds, it
returns a plaintext and updated key; otherwise it returns an
error. Their logical speciﬁcation is explained below.
CipherRange(id,r,c) is a predicate asserting that the length
of ciphertext c reveals at most that the length of the plaintext
is in the range r. The secret
is
authenticated, but its range at encryption is not: the range at
decryption may be wider (unless id prescribes a stream cipher
and all three lengths coincide).
length of the plaintext
ENCrypted(id,d,p,c) is an abstract predicate speciﬁed as the
postcondition of encryption, stating that c is an authenticated
encryption of p with additional data d. Its appearance also as
a postcondition of decryption expresses ciphertext integrity:
only correctly-generated ciphertexts successfully decrypt.
Authenticity and conﬁdentiality of plaintexts follow from
parametricity for values of the (;id,d,r)plain type when the
predicates Auth(id) and Safe(id) hold. For instance, when Safe
(id) holds, the user (including the adversary) may learn the
values of their indexes id, d, r, but cannot call the repr
function to read their content, nor call the plain function to
forge their content.
Our implementation supports many protocol versions and
ciphersuites, but provides security only for Strong indexes that
use TLS 1.2 with secure ciphersuites, e.g. AES_CBC with
fresh IVs. Our formal development mirrors a well known
result of Krawczyk [39, Theorem 2] that states that IND-
CPA security of encryption and combined INT-CTXT security
of MAC-then-encrypt afford secure channels. Krawczyk also
shows that stream ciphers as used in TLS provide combined
INT-CTXT security. We use the result of Paterson et al. [50]
to show that the block-cipher-based schemes implemented by
our LHAE module are combined INT-CTXT secure, despite the
unauthenticated padding, for strong block ciphers and MAC
algorithms.
(cid:3)
Our concrete implementation of LHAE is a sequence of
= MAC · Encode · ENC · LHAE. Under the com-
modules C
bined INT-CTXT assumption, we prove by typing that C
is Ii
LHAE-secure for IND-CPA secure modules
ENC and for restricted users (using LHAE keys linearly with
pairwise-distinct additional data).
LHAEPlain
; Ii
453
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:52:05 UTC from IEEE Xplore.  Restrictions apply. 
Stateful Length-hiding Authenticated Encryption (StAE) Pro-
grammed and veriﬁed on top of LHAE, StAE authenticates the
position of each plaintext within a stream of messages. To this
end, its ideal plaintext interface Ii
StPlain introduces a fourth
index: a log that records the sequence of preceding plaintexts
and additional data.
type (;id:index, l:(;id) log, ad:(;id) data, r:range) stplain
We omit its plain and repr declarations similar to those of
Ii
LHAE. The ideal interface Ii
StAE for StAE is as follows:
val GEN: id:index →
w:(;id) writer {Log(w) = []} ∗ r:(;id) reader {Log(r) = []}
val ENC: id:index → wr:(;id) writer → d:(;id) data → r:range →
p:(;id,Log(wr),d,r) stplain → c:cipher ∗ wr’:(;id) writer
{Log(wr’) = (d,p)::Log(wr) ∧ ENCrypted(id,wr,d,p,c)
∧ CipherRange(id,r,c)}
val DEC: id:index → rd:(;id) reader → d:(;id) data → c: cipher →
o:(r:range {CipherRange(id,r,c)} ∗ p:(;id,Log(rd),d,r) stplain ∗
rd’:(;id) reader{Log(rd’) = (d,p)::Log(rd)}) option
{Auth(id) ⇒ (!rd’,r,p. o = Some(rd’,r,p) ⇔
(∃wr. ENCrypted(id,wr,d,p,c) ∧ Log(wr) = Log(rd)))}
It uses the same Safe and Auth predicates as LHAE.
Keys and sequence numbers for StAE are encapsulated into
linear writer and reader capabilities that hold the local state of
the encryption and (for speciﬁcation purposes only) the log of
messages written or read so far. Encryption adds a log entry
into the writer, containing the plaintext and its additional data.
If a sequence of plaintexts was encrypted using StAE, then
decryption guarantees that the returned plaintexts arrive in the
right order (unless not(Auth(id))), since each plaintext must be
indexed by the preceding log.
In TLS, the additional data for StAE contains the proto-
col version and content type; StAE adds an 8-byte preﬁx
representing the sequence number to form the additional
data for LHAE. To program StAE using LHAE, we ﬁrst
write an LHAEPlain module that
LHAEPlain
using Ii
StPlain. Then, for instance, StAE.ENC simply adds a
sequence number then invokes LHAE.ENC. By typing (Lemma
StAE.tc7), we show that our StAE code meets its ideal in-
terface, assuming restricted users (using readers and writers
linearly) and given that LHAE meets its ideal interface.
implements Ii
Theorem 3 (Stateful AE): Let I i
LHAE be the
ideal plain interface and ideal interface of LHAE. Let I i
StPlain
and Ii
StAE be the ideal plain interface and ideal interface
of StAE. Let C = MAC · Encode · ENC · LHAE and S =
LHAEPlain · C · StAE.
LHAEPlain and Ii
If C is Ii
LHAEPlain ;Ii
LHAE-secure for restricted users, then
S is Ii
StPlain ;Ii
StAE-secure for restricted users.
Hence, we obtain security for TLS Record streams, under
the cryptographic assumptions discussed for LHAE.
V. THE HANDSHAKE PROTOCOL
This section discusses the ‘control’ part of our TLS API
for managing sessions and connections. Our implementation
delegates these tasks to a component that entirely hides the
Handshake protocol from the rest of our code. We verify it
against a typed interface Ii
HS that speciﬁes key-establishment,
454
∗ SessionInfo
∗ epoch
type Role = Client | Server
type ConnectionInfo = {
role: Role; id rand: random;
id in: epoch;
id out: epoch}
type epoch =
| Init of Role
| Next of random ∗ random
and we independently verify the rest of TLS for any key-
establishment functionality that implements Ii
HS. We discuss
the main features of the Handshake, but we refer to the online
materials for its 750-line F7 speciﬁcation and the details of
the underlying cryptographic assumptions.
Ciphersuites The Handshake protocol depends on both the
TLS version and the preﬁx of the ciphersuite (before WITH).
It has two main mechanisms for establishing a shared pre-
master secret (PMS): (1) the client samples a fresh value and
encrypts it using the server public key; or (2) the client and
server exchange Difﬁe-Hellman exponentials gx, gy and use
their private exponents x and y to compute the value gxy.
Data Structures We give below the public datatypes of the
API that expose information about sessions and epochs to the
application. Our main integrity goal for the handshake is that
clients and servers agree on their content.
type SessionInfo = {
init crand: random;
init srand: random
version: version;
cipherSuite: cipherSuite;
compression: compression;
pms data: bytes;
clientID: cert list;
serverID: cert list;
sessionID: sessionID}
SessionInfo records information for a given session: the initial
client and server random values (used in the full handshake
that generated the session); the protocol version, ciphersuite,
and compression algorithm; the exchanged data for the PMS;
the certiﬁcates used for authenticating each role, if any; and the
session identiﬁer (used for resumption). ConnectionInfo holds
the current epochs, for reading and writing, the local role,
and the local random value, to guarantee that ConnectionInfos
are pairwise distinct. Each epoch is unidirectional and initially
records just the role of the writer (Client or Server); for each
complete handshake, it also records the SessionInfo and client
and server randoms used for key derivation.
Long-term Key Interface The handshake makes use of long-
term keys, which may be either honestly generated and used,
or compromised. The certiﬁcation of long-term keys is outside
the TLS standard, but is crucial for modeling its security. For
this reason, we implement basic certiﬁcate management in the
Cert module, but we leave the interpretation of certiﬁcates
to the TLS application. From the protocol viewpoint, we
only require a function (certkey) to extract public keys from
exchanged certiﬁcate chains, and a predicate (Honest) to
specify which of the long-term keys used by TLS are honest.
Control Interface We now outline the handshake interface.
There is one instance of the Handshake protocol at each TCP
connection, each able to perform a sequence of handshakes
for that connection. At each end of the connection, the local
state has an abstract type (;ci)state indexed by the current
connectionInfo ci. We require that connection states be treated
linearly: each call to the interface takes the current state and
returns the next state.
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:52:05 UTC from IEEE Xplore.  Restrictions apply. 
The interface ﬁrst provides functions to create new instances
of the protocol, as client or server, possibly resuming existing
sessions, and to initiate re-handshakes on established connec-
tions (see Fig. 4 for their counterparts in the main TLS API):
accept creates a server instance (possibly resuming an existing
session, at
the client’s initiative); connect creates a client
instance (with a fresh session); resume creates a client instance
from some existing session. For all of these functions, an
event Conﬁg(ci,c) records the conﬁguration chosen by the user.
With request the server asks the client to start a renegotiation;
rehandshake or rekey let the client start a renegotiation, using
a full or abbreviated handshake (with the same ciphersuite).
Network Interface Once conﬁgured and started, the hand-
shake progresses by sending and receiving fragments of con-
tent types Handshake and CCS. The handshake updates its
internal state and notiﬁes progress gradually, ﬁrst by delivering
the new index and cryptographic materials,
independently
for each direction (using event SentCCS(id) for each epoch)
then, after both (1) accepting the correct Finished message
from its peer and (2) sending its own Finished message, by
conﬁrming that the handshake is complete (using predicate
Complete(ci,cfg) for the full ConnectionInfo) and thus that the
new keys can be used to send and receive application data. In
TLS, whether (1) or (2) above happens ﬁrst depends both on
the role and whether we are resuming a prior session or not.
The Complete predicate in the postcondition of connection
the
establishment (see Handshaken in Fig. 4) states that
incoming and outgoing epochs in the new ConnectionInfo are
synchronized, and relates their common SessionInfo (written si
for SI(ci.id out) below) to the local and remote conﬁgurations.
Provided that (1) both the ciphersuite and all its algorithms in
si are strong (predicate StrongHS(si), explained shortly); and
(2) the long-term keys recorded in si are honest (predicate
Honest), then we have that (a) the negotiated content of the
session si is compatible with the two initial conﬁgurations;
(b) the peer sent a CCS with a matching epoch (event
SentCCS(ci.id in)); and (c) the handshake was actually secure
(predicate SafeHS(si)), thereby enabling secure transport.
By deﬁnition, for connections with an anonymous client,
the server obtains no such guarantees, but the connection may
still provide server authentication, and then be used to run
application-level client authentication—see §VI-D.
Handshake Security We deﬁne security for the ideal hand-
shake interface Ii
HS used in our veriﬁcation, and parameterized
StAE, the ideal interface for StAE in §IV that deﬁnes the
by Ii
type of keys established by the handshake.
Deﬁnition 5: A module HS is a secure handshake when it
StAE
The StAE keys have abstract types, so the module HS in the
deﬁnition can obtain them only by calling GEN and COERCE,
and it can turn bytes into key materials using the latter only
for epochs id such that not(Auth(id)), the pre-condition of
COERCE. Thus, Deﬁnition 5 entails that, whenever Auth (and
a fortiori Safe) holds, a secure handshake establishes ideal,
fresh random key materials (as created by GEN).
HS-secure for restricted users.
is Ii
;Ii
(cid:3)
More precisely, Ii
HS uses a predicate SafeHS on SessionInfo
to indicate the secure runs of the handshake, such that Auth(id)
implies SafeHS(SI(id)). To type the handshake, we let SafeHS
= StrongHS(si) ∧ HonestPMS(si) where HonestPMS(si)
(si)
means that the pre master secret was securely generated
between compliant endpoints using honest long-term keys, and
where StrongHS(si) collects our cryptographic assumptions on
the algorithms selected by the protocol version and ciphersuite
indicated in the SessionInfo si. For the handshake,
these
algorithms are provided by the modules Sig implementing all
signatures used by TLS, RSA and DH implementing the two
sub-protocols for exchanging the PMS, CRE a computational
randomness extractor for deriving master secrets, and PRF
implementing pseudo-random functions for deriving keys and
authenticating ﬁnish messages.
We obtain the security of the pre-master secret exchange
by making strong cryptographic assumptions (RSA-PMS) and
(DH-PMS) on the combined modules CRE·RSA and CRE·DE.