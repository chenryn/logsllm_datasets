triggered with similar inputs a(cid:137)er some mutations.
(cid:135)e undisclosed vulnerability. We discovered an undisclosed
vulnerability when analyzing the (cid:131)aw reported by CVE-2016-3841,
a use-a(cid:137)er-free vulnerability in the networking subsystem. From
the CVE description, we can learn that the vulnerability could be
triggered by using the socket and sendmsg system calls. From its
corresponding patch code, we found multiple functions that are
patched. Even a(cid:137)er (cid:128)ltering using CVE and git log descriptions,
there are still 18 vulnerable functions. A(cid:137)er successfully generating
a PoC exploit, SemFuzz (cid:128)nds that the vulnerability is triggered in
the function udpv6 sendmsg.
In the fuzzing process, SemFuzz mutates parameters values of
the system call socket (i.e., domain and protocol). In a certain
fuzzing instance, the domain is set to AF INET (standing for ipv4)
and the protocol is set to PROT ICMP (standing for the ICMP
protocol). (cid:140)en another memory-related vulnerability (i.e., null
pointer deference) is triggered in another function ping v4 sendmsg.
We have reported this vulnerability to the Linux kernel developer
group [8] and they told us that this bug has been patched in the
latest Linux kernel before we reported to them. However, we could
not (cid:128)nd any publicly released report referring to this bug. So it is
considered to be an undisclosed vulnerability.
7 DISCUSSION
Vulnerability type. In this study, although SemFuzz is able to
handle 16 types of vulnerabilities including double free, use-a(cid:137)er-
free and memory corruption, etc. However, we do not consider
the vulnerabilities that require speci(cid:128)c devices to trigger and the
logical vulnerabilities whose abnormal behaviors cannot be directly
observed by SemFuzz. Actually, such limitations are mostly due to
the fuzzer, but not the semantics-based approach. On the contrary,
the semantic information is really helpful (e.g., for a human analyst
to generate exploits). In particular, to fuzz the device-speci(cid:128)c vul-
nerabilities, one can emulate the required device under the support
of visualization. (cid:140)e information retrieved from the vulnerability
description can be used to guide the emulation of the required de-
vice. For example, CVE-2016-2782 requires a speci(cid:128)c USB device
that lacks a bulk-in or interrupt-in endpoint. With the description
about the target USB device, we can leverage vUSBf [21], a USB
device fuzzer to emulate various USB devices that meet these re-
quirements. For the logical vulnerabilities, the description about
the violations can be used as guidances for constructing detector
under the basic understanding of the target subsystem. For exam-
ple, CVE-2015-8660 describes a logical vulnerability which allows
an a(cid:138)acker to bypass intended access restrictions and to modify
the a(cid:138)ributes of arbitrary overlay (cid:128)les. With such description, as
Session J2:  Fun with FuzzingCCS’17, October 30-November 3, 2017, Dallas, TX, USA2150well as the knowledge of the (cid:128)le system, we can build a detector to
check the behavior of (cid:128)le a(cid:138)ribution modi(cid:128)cation in the overlay
(cid:128)le system.
Vulnerable targets. In this study, we choose Linux kernel as the
target. Although the approach presented in this paper is speci(cid:128)c to
the Linux kernel, the basic idea of leveraging semantic information
to guide fuzzing can be applied to other programs (even without
source code), as long as we can obtain enough guidances. For ex-
ample, CVE-2017-3053 (Adobe Reader) discloses a(cid:130)ected versions
(e.g., 11.0.19 and earlier), vulnerability type (i.e., memory address
leak), vulnerable component (i.e., image conversion engine), and
trigger conditions (i.e., parsing the APP13 segment in JPEG (cid:128)les).
(cid:140)ese information can be leveraged to guide a (cid:128)le format fuzzer
to trigger the vulnerability by mutating the JPEG APP13 segment
and monitoring whether memory address leak occurs in the im-
age conversion engine. Besides CVE, we can also retrieve more
information from other sources of vulnerability descriptions.
In this study, we re-
Sources of vulnerability descriptions.
trieved guidances from both the CVE description and the Linux git
logs. In our experiments, sometimes, we found that only one source
of vulnerability descriptions is enough to support the necessary
guidances. We take the vulnerability description with the commit
ID “2b95fda2c4fcb6d6625963f889247538f247fce0” in the Linux git
log as an example. It is a kernel crash report of a double free vulner-
ability. From the log, we can retrieve the vulnerable function (i.e.,
x509 free certi(cid:128)cate) and the critical variable (i.e., cert->pub->key).
Also, the log presents the call trace of the vulnerable function, from
which we can retrieve the triggering system call (i.e., add key).
Based on the observation, we found that the semantic information
may be obtained from one source, and can also be combined with
the other sources for veri(cid:128)cation, which could help to increase the
performance of fuzzing. In addition, we also found that besides CVE
and git log, there may be other sources of vulnerability descriptions,
which is also helpful for guidance generation. For example, the
source from FullDisclosure [2] contains the vulnerability informa-
tion of CVE-2016-8655, which helps SemFuzz to get extra guidances
that are not disclosed by CVE and git log, such as “we can reach
packet set ring() by calling setsockopt() on the socket using the
PACKET RX RING option”. We will try to crawl more descriptions
from other sources in future work.
8 RELATED WORK
Automatic exploit generation. Brumley et al. [28] proposed an
automatic approach to construct proof-of-concept exploits for input-
validation vulnerabilities by seeking an input that fails the newly
added checks in the corresponding patches. Avgerinos et al. [26]
developed a technique to generate exploits for control (cid:131)ow hijack-
ing a(cid:138)acks by modeling them as formal veri(cid:128)cation problems on
the inputs. Hu et al. [34] developed a data-(cid:131)ow stitching technique
for systematically (cid:128)nding ways to join data (cid:131)ows in the program
to generate data-oriented exploits.
In addition, there are some
other studies, such as Chainsaw [24] and CraxWeb [35], target-
ing on automatically generating exploits for SQLI and XSS a(cid:138)acks
on web applications. On the mobile platform, Centaur [39] lever-
ages symbolic execution of Android framework for vulnerability
discovery and exploit generation. All of them rely on generating
constraints on inputs and leverage symbolic execution to further
solve the constraints which let the program run to the vulnerable
functions. By solving the constrains, an exploit could be generated.
However, as mentioned in the introduction, symbolic execution
and constrains solving have di(cid:129)culties in exploiting deep program
(cid:131)aws on complicated target programs (e.g., non-linear constraints,
multiple threads). Our study leverages semantics-based fuzzing
to support more types of vulnerabilities. Also, using the semantic
information retrieved from non-code text, the fuzzing process can
be well guided for achieving high performance.
Guided fuzzing. Traditional fuzzing without guiding su(cid:130)ers from
redundant executions [44]. (cid:140)at is, an execution instance lets a
program run to the same status as previous instances do, which
greatly reduces the performance of fuzzing. To solve this problem,
previous studies guide the fuzzing process using the running status
of a program and the format of inputs. For example, Sky(cid:128)re [56]
uses a data-driven seed generation approach, which leverages the
knowledge learned from the vast amount of existing samples to
generate well-distributed seed inputs for fuzzing. VUzzer [49] and
AFLFast [27] leverage static control-(cid:131)ow and data-(cid:131)ow analysis to
prioritize deep paths and de-prioritize frequent paths when mutat-
ing the inputs. ArtFuzz [32] dynamically discovers likely memory
layouts to guide the fuzzing process. Our study demonstrates that,
in addition to the running status of a program, the non-code de-
scriptions in CVE and git log also help to avoid redundant runs.
Semantics-based program analysis. Semantic information is
not the (cid:128)rst use in program analysis. iComment [54] leverages
NLP to analyze program comments and compares the semantics
of comments with the code to determine the inconsistency, which
indicates a bug or a bad comment. aComment [55] extracts annota-
tions from both code and comments wri(cid:138)en in natural language
to detect interrupt-related concurrency bugs. In addition to code
comments, developer documents are also a good source for min-
ing knowledge to assist program analysis (e.g., constructing API
models [59], extracting security policies [57] and inferring resource
speci(cid:128)cations [60]). On the mobile platform, some recent studies
apply NLP to understand app descriptions for checking whether
the app requests unnecessary permissions [47] or performs unex-
pected behaviors [33]. Also, some API’s semantics are analyzed
for mapping libraries cross platforms [31]. Di(cid:130)erent from these
semantics-based program analysis studies, our work is the (cid:128)rst to
utilize third-party vulnerability descriptions to guide the generation
of PoC exploits.
Repository analysis. In recent years, various code mining ap-
proaches [37, 38] have been proposed to automatically extract im-
plicit programming rules from source code repositories. In addi-
tion, some studies mine so(cid:137)ware repositories to predict vulnera-
bilities. Neuhaus et al. [46] use the vulnerability database of the
Mozilla project to predict the vulnerable so(cid:137)ware components.
Meneely et al. [41–43] conduct the research on the correlation be-
tween meta data in code repositories (e.g., code churn, lines of
code, number of reviewers, etc.) and the reported vulnerabilities.
(cid:140)e studies of [48, 51] mine so(cid:137)ware repositories to discover the
bug-introducing or (cid:128)x-inducing commits. Di(cid:130)erent from them, we
use the code repositories as an information source for generating
guidances for fuzzing.
Session J2:  Fun with FuzzingCCS’17, October 30-November 3, 2017, Dallas, TX, USA21519 CONCLUSIONS
In this paper, we designed and implemented a semantics-based
approach for automatic generation of proof-of-concept exploits.
Making this end-to-end approach feasible is the intelligent fuzzing
technique guided by the automatically recovered vulnerability-
related knowledge from non-code text reports. Running SemFuzz
over 112 Linux kernel vulnerabilities, 18 of them have been auto-
matically triggered. Interestingly, SemFuzz also found a zero-day
vulnerability and an undisclosed one. Our research extends the au-
tomatic exploit generation for simple input-validation vulnerability
proposed 10 years ago to much more complicated vulnerabilities
including uncontrolled resource consumption, dead lock, memory
corruption, etc. More importantly, our research gives new insights
on the way that vulnerability-related information is shared today.
ACKNOWLEDGMENTS
(cid:140)e authors would like to thank the anonymous reviewers for their
constructive comments. Also, the authors would like to express
their thanks to Dmitry Vyukov for his Syzkaller tool and his help
in solving the issues regarding Syzkaller. IU authors were sup-
ported in part by NSF CNS-1223477, 1223495, 1527141, 1618493 and
ARO W911NF1610127. IIE authors were supported in part by NSFC
U1536106 and 61728209, National Key Research and Development
Program of China (Grant No.2016QY04W0805), Youth Innovation
Promotion Association CAS, and strategic priority research pro-
gram of CAS (XDA06010701). RUC authors were supported in part
by NSFC 91418206, 61170240 and 61472429.
APPENDIX
Table 4 gives a detailed description of the 18 CVEs that can be
successfully auto-exploited by SemFuzz. We present the seman-
tic information retrieved from their CVE descriptions and git logs
as guidance used for fuzzing, including the a(cid:130)ected version, vul-
nerability type, vulnerable functions, critical variables and system
calls.
REFERENCES
[1] 2016. 2016 Financial Industry Cybersecurity Report.
h(cid:138)ps://cdn2.hubspot.net/hubfs/533449/SecurityScorecard 2016 Financial
Report.pdf. (2016).
[2] 2016. FullDisclosure: CVE-2016-8655 Linux af packet.c race condition (local
root). h(cid:138)p://seclists.org/oss-sec/2016/q4/607. (2016).
[3] 2016. Kernel: Add KCOV Code Coverage. h(cid:138)ps://lwn.net/Articles/671640/.
(2016).
[4] 2016. Syzkaller. h(cid:138)ps://github.com/google/syzkaller. (2016).
[5] 2016. Yahoo: Hackers Stole Data On Another Billion Accounts.
h(cid:138)ps://www.forbes.com/sites/thomasbrewster/2016/12/14/yahoo-admits-
another-billion-user-accounts-were-leaked-in-2013. (2016).
[6] 2017. Application Vulnerability: Trend Analysis and Correlation of Coding Pat-
terns across Industries. h(cid:138)ps://www.cognizant.com/whitepapers/Application-
Vulnerability-Trend-Analysis-and-Correlation-of-Coding-Pa(cid:138)erns-Across-
Industries.pdf. (2017).
[7] 2017. Bug 195709. h(cid:138)ps://bugzilla.kernel.org/show bug.cgi?id=195709. (2017).
[8] 2017. Bug 195807. h(cid:138)ps://bugzilla.kernel.org/show bug.cgi?id=195807. (2017).
[9] 2017. Common Vulnerabilities and Exposures. h(cid:138)ps://cve.mitre.org. (2017).
[10] 2017. Common Weakness Enumeration. h(cid:138)ps://cwe.mitre.org. (2017).
[11] 2017. CWE: Improper Input Validation.
[12] 2017. FullDisclosure Mailing List. h(cid:138)p://seclists.org/fulldisclosure. (2017).
[13] 2017. Information Security Resources.
[14] 2017. Krebs on Security. h(cid:138)ps://krebsonsecurity.com. (2017).
[15] 2017. Linux Kernel Git Repositories. h(cid:138)ps://git.kernel.org. (2017).
h(cid:138)ps://www.sans.org/security-resources/blogs. (2017).
h(cid:138)ps://cwe.mitre.org/data/de(cid:128)nitions/20.html. (2017).
(2017).
[36]
h(cid:138)p://man7.org/linux/man-pages/index.html. (2017).
[16] 2017. Linux man pages online.
[17] 2017. National Vulnerability Database. h(cid:138)ps://nvd.nist.gov. (2017).
[18] 2017. pyStatParser. h(cid:138)ps://github.com/emilmont/pyStatParser. (2017).
[19] 2017. STP Constraint Solver. h(cid:138)p://stp.github.io. (2017).
[20] 2017. Vulnerability. h(cid:138)ps://en.wikipedia.org/wiki/Vulnerability (computing).
[21] 2017. vUSBf. h(cid:138)ps://github.com/schumilo/vUSBf. (2017).
[22] 2017. WannaCry Ransomware A(cid:138)ack.
[23] 2017. What is CVE and How Does It Work?
h(cid:138)ps://en.wikipedia.org/wiki/WannaCry ransomware a(cid:138)ack. (2017).
h(cid:138)p://www.csoonline.com/article/3204884/application-security/what-is-
the-cve-and-how-does-it-work.html. (2017).
[24] Abeer Alhuzali, Birhanu Eshete, Rigel Gjomemo, and VN Venkatakrishnan.
2016. Chainsaw: Chained Automated Work(cid:131)ow-Based Exploit Generation.
In Proceedings of the 23rd ACM Conference on Computer and Communications
Security (CCS 2016). ACM, 641–652.
[25] Frances E Allen. 1970. Control Flow Analysis. In ACM SIGPLAN Notices, Vol. 5.
ACM, 1–19.
[26] (cid:140)anassis Avgerinos, Sang Kil Cha, Alexandre Rebert, Edward J Schwartz, Mav-
erick Woo, and David Brumley. 2014. Automatic Exploit Generation. Commun.
ACM 57, 2 (2014), 74–84.
[27] Marcel B¨ohme, Van-(cid:140)uan Pham, and Abhik Roychoudhury. 2016. Coverage-
Based Greybox Fuzzing as Markov Chain. In Proceedings of the 23rd ACM Con-
ference on Computer and Communications Security (CCS 2016). ACM, 1032–1043.
[28] David Brumley, Pongsin Poosankam, Dawn Song, and Jiang Zheng. 2008. Auto-
matic Patch-Based Exploit Generation is possible: Techniques and Implications.
In Proceedings of the 29th IEEE Symposium on Security & Privacy (S&P 2008). IEEE,
143–157.
[29] Yan Cai and Lingwei Cao. 2015. E(cid:130)ective and Precise Dynamic Detection of
Hidden Races for Java Programs. In Proceedings of the 10th Joint Meeting on