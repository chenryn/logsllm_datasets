下面是和网络安全有关的一些系统子程序。
1．I/O 子程序
（1）creat()：建立一个新文件或重写一个暂存文件。
需要两个参数：文件名和存取许可值（8 进方式）。如：
/* 建立存取许可方式为 0666 的文件 */
creat("/usr/pat/read_write"，0666)
调用此子程序的进程必须要有建立的文件的所在目录的写和执行许可，置给 creat()的
许可方式变量将被 umask()设置的文件建立屏蔽值所修改，新文件的所有者和小组由有效的
UID 和 GID 决定。
返回值为新建文件的文件描述符。
（2）fstat()：见后面的 stat()
（3）open()：在 C 程序内部打开文件。
    需要两个参数：文件路径名和打开方式(I，O，I&O)。
    如果调用此子程序的进程没有对于要打开的文件的正确存取许可（包括文件路径上所
有目录分量的搜索许可），将会引起执行失败。如果此子程序被调用去打开不存在的文件，
除非设置了 O_CREAT 标志，调用将不成功。此时，新文件的存取许可作为第三个参数（可
被用户的 umask 修改）。
当文件被进程打开后再改变该文件或该文件所在目录的存取许可，不影响对该文件的
I/O 操作。
（4）read()：从已由 open()打开并用作输入的文件中读信息。
它并不关心该文件的存取许可。一旦文件作为输入打开，即可从该文件中读取信息。
（5）write()：输出信息到已由 open()打开并用作输出的文件中。
同 read()一样，它也不关心该文件的存取许可。
2．进程控制
（1）exec()族：包括 execl()，execv()，execle()，execve()，execlp()和 execvp()。
可将一可执行模快拷贝到调用进程占有的存贮空间。正被调用进程执行的程序将不复
存在，新程序取代其位置。
这是 UNIX 系统中一个程序被执行的唯一方式：用将执行的程序复盖原有的程序。
安全注意事项：
实际的和有效的 UID 和 GID 被传递给由 exec()调入的不具有 SUID 和 SGID 许可
的程序。
如果由 exec()调入的程序有 SUID 和 SGID 许可，则有效的 UID 和 GID 将设置给
该程序的所有者或小组。
文件建立屏蔽值将传递给新程序。
除设了对 exec()关闭标志的文件外，所有打开的文件都传递给新程序。用 fcntl()子
程序可设置对 exec()的关闭标志。
（2）fork()：用来建立新进程。其建立的子进程是与调用 fork()的进程（父进程）完全
相同的拷贝（除了进程号外）
安全注意事项：
子进程将继承父进程的实际和有效的 UID 和 GID。
子进程继承文件方式建立屏蔽值。
第七章 网络安全性
- 213 -
所有打开的文件传给子进程。
（3）signal()：允许进程处理可能发生的意外事件和中断。
需要两个参数：信号编号和信号发生时要调用的子程序。
信号编号定义在 signal.h 中。
信号发生时要调用的子程序可由用户编写，也可用系统给的值，如：SIG_IGN，则信
号将被忽略，SIG_DFL 则信号将按系统的缺省方式处理。
如许多与安全有关的程序禁止终端发中断信息（BREAK 和 DELETE），以免自己被用
户终端终止运行。
有些信号使 UNIX 系统的产生进程的核心转储（进程接收到信号时所占内存的内容，
有时含有重要信息），此系统子程序可用于禁止核心转储。
3．文件属性
（1）access()：检测指定文件的存取能力是否符合指定的存取类型。
需要两个参数：文件名和要检测的存取类型（整数）。
存取类型定义如表 7-1：
表 7-1  acess()存取类型定义
0
检查文件是否存在
1
检查是否可执行（搜索）
2
检查是否可写
3
检查是否可写和执行
4
检查是否可读
5
检查是否可读和执行
6
检查是否可读可写可执行
    这些数字的意义和 chmod 命令中规定许可方式的数字意义相同。
    此子程序使用实际的 UID 和 GID 检测文件的存取能力(一般有效的 UID 和 GID 用于
检查文件存取能力)。
返回值为 0 表示许可，-1 表示不许可。
（2）chmod()：将指定文件或目录的存取许可方式改成新的许可方式。
需要两个参数：文件名和新的存取许可方式。
（3） chown()：同时改变指定文件的所有者和小组的 UID 和 GID。
注意，chown()函数与 shell 中的 chown 命令的功能不同。
由于此子程序可以同时改变文件的所有者和组，故必须要取消所操作文件的 SUID 和
SGID 许可，以防止用户建立 SUID 和 SGID 程序，然后运行 chown()调用去获得别人的权
限。
    （4）stat()：返回文件的状态（属性）。
需要两个参数：文件路径名和一个结构指针，该结构指针被用来指向状态信息的存放
的位置。
结构定义见表 7-2：
表 7- 2  结构定义
st_mode
文件类型和存取许可方式
st_ino
Inode 节点号
st_dev
文件所在设备的 ID
st_rdev
特别文件的 ID
st_nlink
文件链接数
st_uid
文件所有者的 UID
st_gid
文件组的 GID
- 214 -
Linux网络编程
st_size
按字节计数的文件大小
st_atime
最后存取时间（读）
st_mtime
最后修改时间（写）和最后状态的改变
st_ctime
最后的状态修改时间
返回值为 0 表示成功，1 表示失败
（5）umask()：将调用进程及其子进程的文件建立屏蔽值设置为指定的存取许可。
需要一个参数：新的文件建立屏值。
4．UID 和 GID 的处理
（1）getuid()：返回进程的实际 UID。
    （2）getgid()：返回进程的实际 GID。
    以上两个子程序可用于确定是谁在运行进程。
    （3）geteuid()：返回进程的有效 UID。
    （4）getegid()：返回进程的有效 GID。
以上两个子程序在一个程序不得不确定它是否在运行某用户而不是运行它本来的用户
的 SUID 程序时非常有用，可调用它们来检查确认本程序的确是以该用户的 SUID 许可在
运行。
    （5）setuid()：用于改变有效的 UID。
    对于一般用户，此子程序仅对要在有效和实际的 UID 之间变换的 SUID 程序才有用(从
原有效 UID 变换为实际 UID)，以保护进程不受到安全危害。实际上该进程不再是 SUID 方
式运行。
    （6）setgid()：用于改变有效的 GID。
7.3.2  标准 C函数库
下面是一些经常使用的与安全有关的标准 C 函数。
1．标准 I/O
这些函数被用来进行基本的 I/O 操作。
（1）fopen()：打开一个文件供读或写，安全方面的考虑同 open()一样。
（2）fread()，getc()，fgetc()，gets()，scanf()和 fscanf()：从已由 fopen()打开供读的文
件中读取信息。它们并不关心文件的存取许可。这一点同 read()系统调用非常的类似，请
读者注意。
（3）fwrite()、put()、fputc()、puts、fputs()、printf()、fprintf()：写信息到已由 fopen()
打开供写的文件中。
它们也不关心文件的存取许可。同 write()。
    （4）getpass()：从终端上读至多 8 个字符长的口令，不回显用户输入的字符。
需要一个参数：提示信息。
该子程序将提示信息显示在终端上，禁止字符回显功能，从/dev/tty 读取口令，然后再
恢复字符回显功能，返回刚敲入的口令的指针。
    （5）popen()：将在“ 运行 shell” 那节中介绍。
2．/etc/passwd 处理
    有一组子程序可对/etc/passwd 文件进行方便的存取，可对文件读取到入口项或写新的
入口项或更新等等。
（1）getpwuid()：从/etc/passwd 文件中获取指定的 UID 的入口项。
（2）getpwnam()：对于指定的登录名，在/etc/passwd 文件检索入口项。
以上两个子程序返回一指向 passwd 结构的指针，该结构定义在/usr/include/pwd。h 中，
第七章 网络安全性
- 215 -
定义如下：
         struct passwd
             char * pw_name;        /* 登录名 */
             char * pw_passwd;      /* 加密后的口令 */
             uid_t  pw_uid;         /* UID */
             gid_t  pw_gid;         /* GID */
             char * pw_age;         /* 代理信息 */
             char * pw_comment;     /* 注释 */
             char * pw_gecos;
             char * pw_dir;         /* 主目录 */
             char * pw_shell;       /* 使用的 shell */
         };
    （3）getpwent()，setpwent()，endpwent()：对口令文件作后续处理。
     首次调用 getpwent()，打开/etc/passwd 并返回指向文件中第一个入口项的指针，保持
调用之间文件的打开状态。
     再调用 getpwent()可顺序地返回口令文件中的各入口项。
     调用 setpwent()把口令文件的指针重新置为文件的开始处。
     使用完口令文件后调用 endpwent()关闭口令文件。
    （4）putpwent()：修改或增加/etc/passwd 文件中的入口项。
此子程序将入口项写到一个指定的文件中，一般是一个临时文件，直接写口令文件是
很危险的。最好在执行前做文件封锁，使两个程序不能同时写一个文件。算法如下：
建立一个独立的临时文件，即/etc/passnnn，nnn 是 PID 号。
建立新产生的临时文件和标准临时文件/etc/ptmp 的链，若建链失败，则为有人正
在使用/etc/ptmp，等待直到/etc/ptmp 可用为止或退出。
将/etc/passwd 拷贝到/etc/ptmp，可对此文件做任何修改。
将/etc/passwd 移到备份文件/etc/opasswd。
建立/etc/ptmp 和/etc/passwd 的链。
断开/etc/passnnn 与/etc/ptmp 的链。
    注意：临时文件应建立在/et c 目录，才能保证文件处于同一文件系统中，建链才能成功，且临时文
件不会不安全。此外，若新文件已存在，即便建链的是 root 用户，也将失败，从而保证了一旦临时文件
成功地建链后没有人能再插进来干扰。当然，使用临时文件的程序应确保清除所有临时文件，正确地捕捉
信号。
3．/et c/group 的处理
    有一组类似于前面的子程序处理/etc/group 的信息，使用时必须用#include 语句将
/usr/include/grp.h 文件加入到自己的程序中。该文件定义了 group 结构，将由 getgrnam()，
getgrgid()，getgrent()返回 group 结构指针。
    （1）getgrnam()：在/etc/group 文件中搜索指定的小组名，然后返回指向小组入口项的
指针。
    （2）getgrgid()：类似于前一子程序，不同的是搜索指定的 GID。
    （3）getgrent()：返回 group 文件中的下一个入口项。
    （4）setgrent()：将 group 文件的文件指针恢复到文件的起点。
    （5）endgrent()：用于完成工作后，关闭 group 文件。
    （6）getuid()：返回调用进程的实际 UID。
    （7）getpruid()：以 getuid()返回的实际 UID 为参数，确定与实际 UID 相应的登录名，
- 216 -
Linux网络编程
或指定一 UID 为参数。
    （8）getlogin()：返回在终端上登录的用户的指针。
    系统依次检查 STDIN，STDOUT ，STDERR 是否与终端相联，与终端相联的标准输
入用于确定终端名，终端名用于查找列于/etc/utmp 文件中的用户，该文件由 login 维护，
由 who 程序用来确认用户。
    （9 ） cuserid() ： 首 先 调 用 getlogin() ，若 getlogin() 返 回 NULL 指 针， 再 调 用
etpwuid(getuid())。
    以下为 shell 命令：
    （10）logname：列出登录进终端的用户名。
    （11）who am i：显示出运行这条命令的用户的登录名。
    （12）id：显示实际的 UID 和 GID（若有效的 UID 和 GID 和实际的不同时也显示有
效的（UID 和 GID）和相应的登录名）。
4．加密子程序
1977 年 1 月，NBS 宣布一个用于美国联邦政府 ADP 系统的网络的标准加密法：数据
加密标准即 DES 用于非机密应用方面。DES 一次处理 64BITS 的块，56 位的加密键。
（1）setkey()，encrypt()：提供用户对 DES 的存取。
此两子程序都取 64BITS长的字符数组，数组中的每个元素代表一个位，为 0或1。setkey()
设置将按 DES 处理的加密键，忽略每第 8 位构成一个 56 位的加密键。encrypt()然后加密或
解密给定的 64BITS 长的一块，加密或解密取决于该子程序的第二个变元，0：加密 1：解
密。
（2）crypt()：是 UNIX 系统中的口令加密程序，也被/usr/lib/makekey 命令调用。
    crypt()子程序与 crypt 命令无关，它与/usr/lib/makekey 一样取 8 个字符长的关键词，2
个 salt 字符。关键词送给 setkey()，salt 字符用于混合 encrypt() 中的 DES 算法，最终调用
encrypt()重复 25 次加密一个相同的字符串。
     返回加密后的字符串指针。
5．运行 shell
下面这两个函数被用来在程序中运行 shell 命令：
（1）system()：运行/bin/sh 执行其参数指定的命令，当指定命令完成时返回。
（2） popen()：类似于 system()，不同的是命令运行时，其标准输入或输出联到由 popen()
返回的文件指针。
    二者都调用 fork()，exec()，popen()还调用 pipe()，完成各自的工作，因而 fork()和 exec()
的安全方面的考虑开始起作用。
7.3.3  书写安全的 C程序
    一般有两方面的安全问题，在写程序时必须考虑：
    1．确保自己建立的任何临时文件不含有机密数据，如果有机密数据，设置临时文件仅
对自己可读/写。确保建立临时文件的目录仅对自己可写。
    2．确保自己要运行的任何命令(通过 system()，popen()，execlp()，execvp()运行的命令)
的确是自己要运行的命令，而不是其它什么命令，尤其是自己的程序为 SUID 或 SGID 许
可时要小心。
第一方面比较简单，在程序开始前调用 umask(077)。若要使文件对其他人可读，可再
调 chmod()，也可用下述语名建立一个"不可见"的临时文件。
         creat("/tmp/xxx"，0);
         file=open("/tmp/xxx"，O_RDWR);
第七章 网络安全性
- 217 -
         unlink("/tmp/xxx");
    文件/tmp/xxx 建立后，打开，然后断开链，但是分配给该文件的存储器并未删除，直
到最终指向该文件的文件通道被关闭时才被删除。打开该文件的进程和它的任何子进程都