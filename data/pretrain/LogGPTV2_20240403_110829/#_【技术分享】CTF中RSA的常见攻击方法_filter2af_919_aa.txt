# 【技术分享】CTF中RSA的常见攻击方法
##### 译文声明
本文是翻译文章，文章来源：安全客
译文仅供参考，具体内容表达以及含义原文为准。
MathJax.Hub.Config({tex2jax: {inlineMath: [[‘$’,’$’], [‘\\(‘,’\\)’]]}});
大家好，我是FlappyPig的队长bibi，近期因为一些比赛以及其他原因，总结了一些RSA方面的东西，于是在这里与大家分享，希望大家能有所收获，如有不当之处敬请批评指正。
**0x01 前言**
这里就不讨论数论的基础了，进行RSA的题目解答，至少要懂得基本的数论知识的，如果不了解数论的基本知识的话，网上相关内容还是挺多的。
RSA基于一个简单的数论事实，两个大素数相乘十分容易，将其进行因式分解确实困难的。在量子计算机还没有成熟的今天，RSA算法凭借其良好的抵抗各种攻击的能力，在公钥密码体制中发挥着中流砥柱的作用。然而即便RSA算法目前来说是安全可靠的，但是错误的应用场景，错误的环境配置，以及错误的使用方法，都会导致RSA的算法体系出现问题，从而也派生出针对各种特定场景下的RSA攻击方法。
本文针对一些在CTF中常见的RSA攻击方法，从如何识别应该应用那种方法以及如何去解题来介绍CTF中的RSA题目的常见解法。
**RSA算法描述**
RSA算法涉及三个参数，n，e，d，私钥为n，d，公钥为n，e。
其中n是两个大素数p，q的乘积。
d是e模$ varphi(n) $的逆元，$ varphi(n) $是n的欧拉函数。
c为密文，m为明文，则加密过程如下：
$ cequiv m^e mod n $
解密过程如下：
$ mequiv c^d$ $mod$ $n$
n，e是公开的情况下，想要知道d的值，必须要将n分解计算出n的欧拉函数值，而n是两个大素数p，q的乘积，将其分解是困难的。
**RSA题目类型**
在CTF竞赛中，RSA理所当然处在CRYPTO中居多。而且RSA作为典型的加密算法，其出镜率可谓相当高，基本上所有比赛都会有几道RSA的题目出现。
**数据处理**
在进行做题之前，我们要将数据处理成可以做题的模式。基本上来说，RSA的题目都是围绕着c，m，e，d，n，p，q这几个参数展开的，但是题目一般不会直接给这种样子的参数，而是通过别的方式给出，这里就需要我们使用一些工具或者自己手工将这些参数提取出来。
pem文件 **：** 针对此类文件可以直接使用openssl提取，大概使用过的方式有：
    openssl   rsautl -encrypt -in FLAG -inkey public.pem -pubin -out flag.enc
    openssl   rsa -pubin -text -modulus -in warmup -in public.pem
pcap文件：针对此类文件可以使用wireshark follow一下。这种问题一般都是写了一个交互的crypto系统，所以可能产生多轮交互。
PPC模式：这种模式是上述pcap文件的交互版，会给一个端口进行一些crypto的交互，参数会在交互中给出。
第二个需要处理的就是明密文，这个方法多多，不多赘述。
**0x02 模数分解**
说一说
解决RSA题目最简单，最暴力，最好使的方法就是分解模数n。如果能够将n分解成功，成功得到p，q的取值，那么可求n的欧拉函数的值。
$ varphi(n)=(p-1)(q-1) $
而通过e，d与n的欧拉函数满足如下关系：
$ed=1$ $mod$ $varphi(n) $
通过欧几里得算法可以通过e与n的欧拉函数的值轻易求出d，从而计算出解密密钥。
即在知道e，p，q的情况下，可以解出d：
    def egcd(a, b):
        if a == 0:
          return (b, 0, 1)
        else:
          g, y, x = egcd(b % a, a)
          return (g, x - (b // a) * y, y)
      def modinv(a, m):
        g, x, y = egcd(a, m)
        if g != 1:
          raise Exception('modular inverse does not exist')
        else:
          return x % m
modinv函数即为求模拟的函数，在知道e，p，q的情况下，可以：
    d=modinv(e,(p-1)*(q-1))
即可求出解密密钥。
写到这里，要提出一个细节问题，在利用python进行rsa的题目求解过程中：
$ cequiv m^e mod n $
此类运算需要使用pow函数来进行求解，而不是直接m**e %
n，这样会慢死的。Python在处理此类运算进行了优化。比如刚才在已知p，q的时候利用modinv函数求出了d，然后就可以利用pow函数求出明文：
    m=pow(c,d,n)
**例题：**
 (very easy RSA)
题目中直接给了p，q，e。
可以直接求出d：
    p = 3487583947589437589237958723892346254777
    q = 8767867843568934765983476584376578389
    e = 65537
    d = modinv(e, (p-1)*(q-1))
    print d
**  
**
**直接分解n**
**介绍：**
素数分解问题是困难的，但是可以通过计算机进行暴力分解。1999年，名为Cray的超级计算机用了5个月时间分解了512bit的n。2009年，一群研究人员成功分解了768bit的n。2010年，又提出了一些针对1024bit的n的分解的途径，但是没有正面分解成功。通常意义上来说，一般认为2048bit以上的n是安全的。现在一般的公钥证书都是4096bit的证书。
如果n比较小，那么可以通过工具进行直接n分解，从而得到私钥。如果n的大小小于256bit，那么我们通过本地工具即可爆破成功。例如采用windows平台的RSATool2v17，可以在几分钟内完成256bit的n的分解。
如果n在768bit或者更高，可以尝试使用一些在线的n分解网站，这些网站会存储一些已经分解成功的n，比如：[http://factordb.com](http://factordb.com/)
通过在此类网站上查询n，如果可以分解或者之前分解成功过，那么可以直接得到p和q。然后利用前述方法求解得到密文。
**识别：** ****
此类问题一般是分值较小的题目，提取出n之后可以发现n的长度小于等于512bit，可以直接取分解n。如果大于512bit，建议在使用每个题目都用后面所说的方法去解题。
**例题：** ****
比如在某次竞赛中，发现：
    n=87924348264132406875276140514499937145050893665602592992418171647042491658461
利用factordb分解：
**  
**
**利用公约数**
**介绍：** ****
如果在两次公钥的加密过程中使用的$n_1$ 和$n_2$具有相同的素因子，那么可以利用欧几里得算法直接将$n_1$和$n_2$分解。
通过欧几里得算法可以直接求出$n_1$和$n_2$的最大公约数p：
$(n1,n2)=p$
可以得出：
$n_1=p$$q_1$
$n_2=p$$q_2$
直接分解成功。而欧几里得算法的时间复杂度为：O(log n)。这个时间复杂度即便是4096 bit也是秒破级别。
    def gcd(a, b):
       if a < b:
         a, b = b, a
       while b != 0:
         temp = a % b
         a = b
         b = temp
       return a
识别此类题目，通常会发现题目给了若干个n，均不相同，并且都是2048bit，4096bit级别，无法正面硬杠，并且明文都没什么联系，e也一般取65537。
识别：
**例题：** ****
在一个题目中，你拿到了两个n，e都为65537，两个n分别为：
    n1=9051013965404084482870087864821455535159008696042953021965631089095795348830954383127323853272528967729311045179605407693592665683311660581204886571146327720288455874927281128121117323579691204792399913106627543274457036172455814805715668293705603675386878220947722186914112990452722174363713630297685159669328951520891938403452797650685849523658191947411429068829734053745180460758604283051344339641429819373112365211739216160420494167071996438506850526168389386850499796102003625404245645796271690310748804327
    n2=13225948396179603816062046418717214792668512413625091569997524364243995991961018894150059207824093837420451375240550310050209398964506318518991620142575926623780411532257230701985821629425722030608722035570690474171259238153947095310303522831971664666067542649034461621725656234869005501293423975184701929729170077280251436216167293058560030089006140224375425679571181787206982712477261432579537981278055755344573767076951793312062480275004564657590263719816033564139497109942073701755011873153205366238585665743
通过直接分解，上factordb都分解失败。通过尝试发现：
    print gcd(n1,n2)
打印出：
    1564859779720039565508870182569324208117555667917997801104862601098933699462849007879184203051278194180664616470669559575370868384820368930104560074538872199213236203822337186927275879139590248731148622362880471439310489228147093224418374555428793546002109
则此致即为两个n共有的素因子p，然后进一步求出q，求解完毕。
**Fermat方法与Pollard rho方法**