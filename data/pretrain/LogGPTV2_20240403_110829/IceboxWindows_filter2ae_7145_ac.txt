    kd> !pte 7ff743655000
    ... PTE at FFFFE93FFBA1B2A8
    ... contains 000020000891F860
    ... not valid
    ...   Transition: 891F
    ...   Protect: 3 - ExecuteRead
如我们所见，相应的PTE是无效的（000020000891F860）。我们可以很容易地验证内容是否代表`PageFrameNumber`为`0x20000891F`的过渡PTE。但是在`kd`中，却显示了一个不同的过渡PFN值`0x891F`。导致这种差异的原因是什么呢？
微软安全响应中心（MSRC）给出了完整的答案：在这里，引入了一种新的缓解措施，用于缓解一个名为L1终端故障（L1TF）的推测执行侧信道漏洞。
简而言之，英特尔手册中所述的MMU行为与推测的行为不同。当未设置`_MMPTE_HARDWARE.Valid`标志时，CPU会推测性地尝试访问L1高速缓存中以`PageFrameNumber`为目标的页面。如果存在指令，则会预取指令，这可能会导致敏感信息（例如内核地址）泄露。
为了缓解这个CPU漏洞，Windows现在确保每个无效的PTE都有一个`PageFrameNumber`，超出可用物理内存的限制。这是通过`MiSwizzleInvalidPte`函数来实现的。
    _MMPTE __fastcall MiSwizzleInvalidPte(_MMPTE pte)
    {
      if ( gKiSwizzleBit )
      {
        if ( !(gKiSwizzleBit & pte.u.Long) )
          return (_MMPTE)(pte.u.Long | gKiSwizzleBit);
        pte.u.Long |= MMPTE_SWIZZLE_BIT;
      }
      return pte;
    }
`gKiSwizzleBit`全局值是在系统初始化期间，在`MiInitializeSystemDefaults`函数中定义的：
    KiSwizzleBit = 1i64 DeviceObject))
    {
        bIsEjectable = 1;
    }
    //...
    if (bIsEjectable)
    {
        pNewControlArea->u.ImageControlAreaOnRemovableMedia = 1;
    }
基本上，如果目标设备对象被认为是可弹出的，就会在新创建的控制区域中设置`ImageControlAreaOnRemovableMedia`标志。然后，在`MiCreateNewSection`中检查该标志。设置后，将调用`MiSetPagesModified`函数，该函数更新每个PTE的状态，这些状态描述了从原型到过渡的部分。由于禁用了页面文件，这些PTE将始终处于过渡状态，该状态由IceBox处理。
为了实现这一点，`IoIsDeviceEjectable`函数需要返回`true`：
    bool __fastcall IoIsDeviceEjectable(PDEVICE_OBJECT pDeviceObject)
    {
      return (((pDeviceObject->Characteristics & FILE_FLOPPY_DISKETTE) == 0) & !_bittest(&InitWinPEModeType, 31u)) == 0;
    }
因此，我们就有了两种选择：
1、强制在卷设备的属性中添加`FILE_FLOPPY_DISKETTE`标志；
2、修改`InitWinPEModeType`值。
第一个选择需要检测设备的创建时间，并更新其属性。第二个选择似乎更加容易。实际上，`InitWinPEModeType`是在`Phase1InitializationDiscard`函数中初始化的：
    if ( Options && strstr(Options, "MININT") )
      {
        InitIsWinPEMode = 1;
        if ( strstr(Options, "INRAM") )
          InitWinPEModeType |= 0x80000000;
        else
          InitWinPEModeType |= 1u;
      }
这个选项对应于Windows
PE功能，WinPE适用于部署、安装和修复Windows桌面和服务器安装的小型操作系统。由于该系统是从ISO文件启动的，因此Subsection
PTE限制不影响这个选项。还有非常好的一点，这个选项（至少）自Windows XP以来就一直存在。
IceBox当前通过在操作系统启动期间强制将这个`InitWinPEModeType`全局设置为`0x80000000`来启动WinPE模式。
###  3.3 内存压缩
内存压缩是Windows 10中引入的功能，并且已经向后移植到Win 8和Win
7。这个机制可以压缩客户端Windows版本上的私有页面，以增加可用内存大小。内存压缩涉及到内核和用户两个部分：
1、对于内核，核心功能是在名为“存储管理器”（SM，所有公共和私有内核函数均以`Sm`和`Smp`为前缀）的专用组件中实现的；
2、对于用户空间，`Superfetch`服务（托管在`svchost.exe`实例中的`sysmail.dll`）由`NtSetSystemInformation`调用存储管理器来管理存储。
有关内存压缩的更完整说明，请参考Windows Internals第七版的第五章：内存管理。由于压缩只是一种内存优化方式，因此我们想要禁用该功能。
内核使用`SmFirstTimeInit`函数中的`PsCreateMinimalProcess`创建`MemoryCompression`进程。在创建该进程之前，`MmStoreCheckPagefiles`函数确保至少存在一个页面文件，否则会返回状态`STATUS_NOT_SUPPORTED`。
通过禁用页面文件的方式，将隐蔽地禁用内存压缩功能。
## 四、局限性
上述对于页面文件和WinPE模式的修改会影响系统。首先，禁用页面文件存在以下几个限制：
1、页面文件是第二种内存存储方式，实际上可以增加物理内存的大小。因此，禁用页面文件也就直接限制了可用物理内存的总量。通过增加虚拟机的物理内存，可以规避此类影响。
2、如果系统发生崩溃，会使用页面文件来临时存储生成的崩溃转储。禁用页面文件将不会创建故障转储。
3、如前所述，内存压缩需要页面文件的支持。因此，禁用页面文件将影响内存压缩的功能。
其次，从隐蔽性的角度来看，WinPE模式很容易被检测到。目前，在我们的IceBox方案中，没有考虑到这一点。
## 五、总结
这篇文章从VMI的角度分析了虚拟机的内存访问原理。更准确地说，我们描述了一些Windows虚拟地址转换的内部原理和针对漏洞实施的缓解措施，这里涉及到的漏洞是推测执行侧信道漏洞（L1中断故障）。在对内存内部结构有了深入了解之后，我们就可以访问任意存在于内存中的物理页面。同样，我们还可以解决页面没有映射到物理内存中，而是仅存在于文件系统中的情况。
随后，我们描述了VMI如何在其初始化阶段自动允许Windows虚拟机配置，以强制将任何页面以持久性方式映射到内存中。所有这些都在IceBox中实现，可以实现以下自动功能：
1、禁用页面文件，以避免分页机制；
2、启用WinPE模式，避免Subsection PTE直接引用磁盘上的页面。
综合评估对系统的影响以及内存自省带来的优势，我们认为进行以上调整的好处要大于其缺点。