Π(p(c R),p(c A)) *Π(p(c R),p(c A))
S≠(c ,c )=
i R A | p(c )∪p(c )|−Π(p(c ),p(c )) |p(c )|
R A R A A
Π(p(c R),p(c A)) *Π(p(c R), p(c A))
S ≠(c ,c )= S ≠(c ,c ) =
o R A f R A | p(c )∪ p(c )|−Π(p(c ),p(c )) | p(c )|
R A R A R
Function Π establishes a mapping between the properties of two concept classes. Figure 5
illustrates two ontologies involved in a mapping.
For example, when matching the class concepts DepositAccount and Deposit we
need to establish a mapping between the properties of the two classes. The mapping is
owl:Thing owl:Thing
agreementMember
member
agreementPeriod
Contract per Contract
effectiveDate
date
insured
FinancialContract Deposit
sinterest
agreeBalance
FinancialAccount Liability Option money
accountHolder atTheMoney
amountDue inTheMoney
optionHolder
DepositAccount
simpleInterest
agreementBalance
availableCash
Fig. 5. Two ontologies involved in a mapping
258 J. Cardoso, J.A. Miller, and S. Emani
computed with the function Π(p(DepositAccount), p(Deposit)), which is equivalent to
Π({agreementMember, agreementPeriod, effectiveDate, insured, accountHolder,
amountDue, simpleInterest, agreementBalance, availableCash}, {member, per, date,
sinterest, agreedBalance, money}). Possible mappings that can be established are the
following:
Π : (simpleInterest , sinterest)
i,1
Π : (agreementBalance , agreeBalance)
i,2
Π : (availableCash, money)
i,3
Function Π establishes the best mapping between two sets of properties, pl and pl ,
1 2
and it is defined as follows:
∏(pl,pl )=
1 2
⎧Max(∏(pl − p,pl −p )+ss(p,p )), ss(p,p )=1 and pl ≠∅∧pl ≠∅
1 1 2 2 1 2 1 2 1 2
⎪
⎪
⎪
⎨ ∏(pl −p,pl −p ), ss(p,p )=0 and pl ≠∅∧pl ≠∅
1 1 2 2 1 2 1 2
⎪
⎪
⎪⎩ 0, pl =∅∨ pl =∅
1 2
Function ss(p , p ) determines if two properties are considered to be equal using func-
1 2
tion g. If two properties match syntactically then function ss returns 1, otherwise it
returns 0. Properties match syntactically only if function g determines that the syntac-
tic similarly is greater that a constant β.
⎨⎧1, g(p 1,p 2)≥β
ss(p ,p )=
1 2 ⎩0, g(p 1,p 2)<β
Function g(p , p ) is a function that computes the syntactic similarity of two words. In
1 2
our approach, we use “string-matching” as a way to calculate similarity. Function g
can be implemented using several existing methods such as equality of name, canoni-
cal name representations after stemming and other preprocessing, q-grams, syno-
nyms, similarity based on common sub-strings, pronunciation, soundex, abbreviation
expansion, stemming, tokenization, etc. Other techniques borrowed from the informa-
tion retrieval area may also be considered. A very good source of information on
retrieval techniques can be found in [37]. Constant β determines the sensibility of the
matching. As β gets closer to 1, the matching function returns less false positives. As
β gets closer to 0, it returns more false positives.
For example, let us consider the request query with c = “DepositAccount“ and an
R
advertisement with c =”Deposit”. When computing Π(p(“DepositAccount”),
A
p(“Deposit”)) of these inputs, we obtain value 2. This number represents the two
valid mappings obtained:
Π : (simpleInterest , sinterest)
i,1
Π : (agreementBalance , agreeBalance)
i,2
Mapping Π is found since the results of ss(“simpleInterest“, ”sinterest”) and ss
i,1
(agreementBalance , agreeBalance), using the q-grams methodology [38] as an
Web Services Discovery Utilizing Semantically Annotated WSDL 259
implementation of g with β = 0.5, is greater than 0.58 (e.g., g(“agreementBalance“,
”agreeBalance”)=0.58). Please refer to [38] to understand this result from applying
q-grams. As a result, in both cases ss is evaluated to 1.
All the other mappings are not part of Π. For example, if we compute
ss(“agreementBalance”, “money”) we obtain a result of 0 (function g has a value of
0), which means that we do not consider the properties to be syntactically equal.
≠
The result of computing S ( c , c ) is done in the following way. The
i R A
concept DepositAccount has 9 properties (i.e., agreementMember, agreementPeriod,
effectiveDate, insured, accountHolder, amountDue, simpleInterest, agreementBal-
ance, availableCash) and concept Deposit has 6 properties (i.e., member, per, date,
interest, balance, cash). Furthermore, Π(p(“DepositAccount”), p(“Deposit”))=2.
≠
Applying function S (c ,c ) we obtain:
i R A
2 2 2 1 2
S≠ (c ,c )= * = * = =0.2265
i R A (9+6)−2 6 13 3 39
This result corroborates our intuition since only two of the six properties of the con-
cept Deposit are satisfied by the properties of concept DepositAccount. Furthermore,
the concepts DepositAccount and Deposit are rather distinct since only two properties
are shared between the two.
3.4 Ranking Algorithm
In this section we present the actual algorithm for ranking Web service advertise-
ments, following the functions presented previously.
REQ(c , c , c ) = Web service request
i o f
ADV (c , c , c ) = List of advertisement
j ji jo jf
For all j get ADV (c , c , c )
j ji jo jf
If same_ontology(c i , c ji) i =S= (c,c )
i i ji
else i =S≠ (c,c )
i i ji
If same_ontology(c o ,c jo) o =S = (c ,c )
o o jo
else o =S ≠ (c ,c )
o o jo
If same_ontology(c f ,c jf) f =S =(c ,c )
f f jf
else f =S ≠(c ,c )
f f jf
match[j] = (i+o+f)/3;
Forall
Sort match[j]
260 J. Cardoso, J.A. Miller, and S. Emani
The algorithm uses the function same_ontology that determines if two concepts are
defined in the same ontology. Once the matching degree of the input, output, and
functionality between a Web service request and a Web service advertisement is cal-
culated, we define the overall degree of the match as the arithmetic mean of the input
match degree, output match degree, and functionality match degree. Of course, a
weighted function can be implemented if one of the dimensions (inputs, outputs, and
functionality) is more important than the others to a service provider or consumer.
4 Using SM-T with METEOR–S WSDI and Lumina
The SM-T algorithm can be integrated in the implementation of METEOR-S Web
Services Discovery Infrastructure (MWSDI) [7] and Lumina [21]. One of the authors
of this paper was one of the architects of MWSDI and Lumina. Both projects utilize
the METEOR-S Discovery API that matches a semantic Template with closely
matching Web services that, for example, could be plugged into an abstract process
with little or no human intervention. The METEOR-S Discovery API is built on of
jUDDI discovery engine and maps semantic information to the business, service and
tModel components of UDDI. It thus provides a semantically enhanced UDDI.
4.1 UDDI
UDDI [39], sponsored by OASIS, is an XML-based registry for business and Web
services world-wide to list services in the internet. The focus of UDDI is it dynami-
cally allows businesses or enterprises to publish and discover Web services. That is
UDDI provides a foundation for both publicly available Web services as well as those
which present internally in an organization. UDDI model has persistent data struc-
tures called entities expressed in XML and stored in UDDI nodes. The information
model is made of the following entity types:
• businessEntity: represents an business
• businessService: the set of Web services that are provided by a business
• bindingTemplate: provides information on how to use a Web service
• tModel: gives a technical model categorizing Web service type
• publisherAssertion: provides the relationship between business entities
• subscription: reports changes in the business entities
The programming interface of UDDI has two parts: inquiry and publishing. To
inquire for a Web service through the UDDI several methods are available. The com-
binations of these search methods can be used through the registry to get optimized
results. The methods can be used according to the business of interest by keyword
search which gives a set of summarized results for further or deeper search, look for
services based on a particular category a business offers and tModel search which
returns a set of tModels from different services according to the search criteria. As we
go deeper, we can search for the operations a business service offers.
Web Services Discovery Utilizing Semantically Annotated WSDL 261
4.2 Approaches to Discovery
Service registries need to provide suitable discovery mechanisms to consumers. We
can categorize matchmaking approaches according to various criteria. One possible
classification is to take into account what elements are used to match a service adver-
tisement and a service request. We present four approaches: IO matching, multilevel
matching, graph-based approaches, and syntactic matching.
IO matching. One of the first works in the field of service discovery (semantic Web
service discovery) is described in [40] and [6, 41]. Paolucci [40] follow the idea that
“an advertisement matches a request when all the outputs of the request are matched
by the outputs of the advertisement, and all the inputs of the advertisement are
matched by the inputs of the request”. Cardoso also takes into account the semantic
and syntactic similarity of concepts using Tversky model. Thus, these methods takes
into account only the inputs and outputs of services during matchmaking. Cardoso
and Sheth [6] go a step further and include the QoS of services during the matching
process.
Multilevel Matching. Using this matching strategy, presented by Jaeger [42], the
matchmaking process is performed at many levels, that is, between inputs/outputs,
service categories and other custom service parameters (e.g., related to QoS issues).
Such approach reflects the intuition that ideal service discovery should exploit as
much of the available functional and non-functional service information as possible.
A Graph-Based Approach. Trastour [43] proposes a semantic graph matching ap-
proach. A service description (request or advertisement) is represented as a directed
graph (RDF-graph), whose nodes are instances of concepts (i.e., individuals) and arcs
are properties (i.e., concept roles) relating such instances. The root node of each graph
is the individual representing the service advertisement/request itself. The other nodes
refer to concepts borrowed from domain ontologies (capabilities, constraints, etc.).
The matchmaking between two graphs, one representing a service request and another
representing a service advertisement, is performed with a recursive algorithm.
Syntactic matching. While the IO matching, multilevel matching, and graph-based
matching rely on exploiting the subsumption relations in various ontologies in order
to assess the similarity of services, service capabilities, this is not sufficient to enable
an effective discovery. One extension that can be made is to use similarity measures
and information retrieval (IR) techniques. The objective is to use implicit semantics of
services, besides the explicit semantics that are described by the domain ontologies.
The core idea in this approach is that IR similarity measures could be applied when
logic-based (subsumption) matching fails. For example, TFIDF (Term Fre-
quency/Inverse Document Frequency) term weighting schemes [44] can be used to
evaluate the semantic distance/closeness between concepts, words or documents.
4.3 Lumina
The focus of Lumina works closely with MWSDI [7] to provide a user friendly GUI
for specifying semantic templates and discovering matching services. MWSDI is an
infrastructure that addresses the challenge of integrating a large number of registries
262 J. Cardoso, J.A. Miller, and S. Emani
from diverse domains. MWSDI supplies an infrastructure of registries for semantic
publication and discovery of Web services. The primary motivation was the expected
growth in the number of registries and the lack of semantics in Web service represen-
tation. The system provides a scalable architecture to access such registries. In addi-
tion, it provides semantic publication and discovery capabilities by using a domain
specific ontology for each registry. Two algorithms are made available for semantic
publication and discovery using WSDL descriptions. Both these algorithms map in-
puts and outputs of Web services to ontological concepts. Subsequently, searching
can be carried out using constructed templates using the ontological concepts.
MWSDI was implemented with an underlying peer-to-peer network which gives
the scalability and flexibility required for creating an infrastructure for diverse Web
service registries.
Lumina may be viewed as Radiant’s companion. While Radiant annotates and
publishes semantic Web services, Lumina is used for discovering these published
services. It allows to search for services, individual operations or interfaces (i.e.,
combinations of operations). In order to create a semantic template, the GUI provides
input text boxes and selections that can be filled in by data entry, mouse clicking or
dragging a class or property from an ontology. Figure 6 illustrates how to fill in a
semantic template using Lumina.
Fig. 6. Semantic template using Lumina
Lumina was designed to support WSDL-S and this provides a means for specifying
inputs, outputs, functionality/category, preconditions and effects. Later a simplified
SAWSDL mode was added that does not support preconditions and effects.
SM-T, MWSDI and Lumina basically follow the same approach concerning their
vision of Web services. They all treat a Web service as an abstract interface (black
box) consisting of multiple operations which each having its own set of inputs and set
Web Services Discovery Utilizing Semantically Annotated WSDL 263
of outputs as well as functionality. Annotating the inputs, outputs and functionality of
Web service operations gives a significant improvement in discovery and is better
than the approach used by current UDDI registries. This is because current UDDI
implementations are only based on the syntactic matching of properties. Semantic
approaches have already shown in several domains to improve search precision. Sec-
tion 3.2 and section 3.3 show that the SM-T algorithm is able to compare concepts
beyond a simple syntactic match. Let us assume that a user issues a request to a UDDI