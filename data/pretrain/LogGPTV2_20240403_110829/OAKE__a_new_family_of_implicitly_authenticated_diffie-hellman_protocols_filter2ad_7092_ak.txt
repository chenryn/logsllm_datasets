0 .
′
0X bd0+y0e
′
0
30
Corollary G.4 Under the CDH assumption, (public-key free) rOAKE-HDR signatures of ˆB, with of-
ﬂine pre-computed and exposable (y; Y; Ab+cy), are strongly secure in the random oracle model, with
respect to the signer ˆB itself and Y0 = X0.
Now, we consider the case of ˆA = ˆB but X0 ̸= Y0. For this case, the proof of Corollary G.2 can
still be extended to rOAKE-HDR under both the GDH and KEA assumptions, assuming only (y; Y )
can be exposed. The key diﬀerence, in comparison with the proof of Corollary G.2, is that: for rOAKE-
HDR signature, the output of the challenger C during the rewinding experiments is CDH(B; X0) for
the case of d0 posterior to c0 and e0, and is CDH(X d0
0 Bb in the rest two cases. But, it
is easy to check that, given random elements B = gb; X = gx ← G \ 1G, the hardness of computing
CDH(X dB; B) = (X dB)b is equivalent to that of computing CDH(B; X).
Proposition G.1 Given random elements B = gb; X = gx ← G \ 1G, where b; x ← Z
∗
q , the hardness
of computing CDH(B; X) is equivalent to that of computing CDH(X dB; B) = (X dB)b, where d =
h( ˆB; B; X).
0 B; B) = X bd0
Proof (of Proposition G.1). First recall that the hardness of computing Bb from random B = gb is
equivalent to that of the CDH problem [48, 53]. Thus, the ability of computing CDH(B; X) (given
(B; X)) is equivalent to the ability of computing Bb (given B only), which then implies the ability of
computing CDH(X dB; B) = X bdBb.
Suppose there exists an eﬃcient algorithm ˜A that can compute CDH(X d; B) = X dbBb (from B and
X) with non-negligible probability, then there exists another eﬃcient algorithm ˜B that can break the
CDH assumption with also non-negligible probability. The input of ˜B is a random element B ∈ G\ 1G,
and its goal is to break the CDH assumption by computing CDH(B; B) = Bb. Towards this goal, ˜B
∗
q , and then runs ˜A on input (B; X). After
generates X = gx where x is taken uniformly at random from Z
getting CDH(X dB) = X dbBb = BxdBb from the output of ˜A, ˜B computes Bb = CDH(X dB; B)=Bxd.
(cid:3)
But, the key observation for rOAKE-HDR in this case is: as the value gab is involved and c =
h(m1; ˆA; A; Y ), we can have an alternative way to reduce the rOAKE-HDR signature forgery to the abil-
ity of computing CDH(B; A) = CDH(B; B) (rather than CDH(X0; B) as in the analysis of (s)OAKE-
HDR). Recall that B = A in this case, and the hardness of computing CDH(B; B) is equivalent to the
standard CDH assumption. Moreover, in comparison with the proof of Corollary G.2 for (s)OAKE-HDR
in this case, the analysis for rOAKE-HDR in this case is much simpliﬁed without considering the order
among c0; d0; e0 in the repeat experiment. Speciﬁcally, we have the following corollary:
Corollary G.5 Under the GDH assumption, (public-key free) rOAKE-HDR signatures of ˆB, with of-
ﬂine pre-computed and exposed (y; Y ), are strongly secure in the random oracle model, with respect to
the signer ˆB itself and Y0 ̸= X0.
Proof. The proof follows the proof procedures of Theorem G.1 and Corollary G.3. Here, we mainly
highlight the key diﬀerences between them.
(and thus x0 is known to C). Then, C runs the forger F(B; X0).
In the Setup, C only takes the value B as its input, while the value X0 = gx0 is generated by C itself
Until the repeat experiment, C acts just as it does for the case of ˆA ̸= ˆB in the proofs of Corollary
G.3 and Theorem G.1. Denote by (cid:27)0 = Ab+y0c0X bd0+y0e0
the value deﬁned in Steps
F1-F3, where Y0 = gy0 is chosen by F, c0 = h(m1; ˆA; A; Y0) = h(m1; ˆB; B; Y0), d0 = h(m0; ˆB; B; X0)
and e0 = h(X0; Y0) (recall that ˆA = ˆB for this case).
In the repeat experiment, C rewinds F to the point of just querying the RO h with (m1; ˆA; A; Y0) =
̸= c0, and runs F further from this
′
(m1; ˆB; B; Y0), redeﬁnes h(m1; ˆB; B; Y0) to be a random value c
rewinding point. Note that C does not need to consider the order of RO queries among c0; d0; e0 for the
0
= Bb+y0c0X bd0+y0e0
0
0
repeat experiment.
Suppose C outputs another successful forgery, and denote by (cid:27)
0 = h(m1; ˆB; B; Y0) ̸= c0, d
′
deﬁned in the repeat experiment, where c
′
′
0X bd
0 = Bb+y0c
′
0
0; ˆB; B; X0), e
′
0 = h(m
the value
′
0 =
′
0+y0e
′
0
31
0) is identical to (d0; e0) or not). Note that C knows the value x0 such that
′
′
0; e
h(X0; Y0)(whether (d
0; x0), C computes CDH(B; Y0) = [((cid:27)0=(Bd0Y e0
′
−1,
X0 = gx0. From ((cid:27)0; (cid:27)
from which C can then compute CDH(B; B) = (cid:27)0=[(Bd0Y e0
(cid:3).
′
0 )x0)=((cid:27)
0=(Bd
0 )x0CDH(B; Y0)c0].
′
0 )x0)](c0−c
′
0Y e
0
′
0)
G.2 SK-Security Analysis of (s,r)OAKE with Oﬄine Pre-Computation
In the following, we ﬁrst present the SK-security analysis of (s)OAKE in the CK-framework (with
pre-speciﬁed peers), with oﬄine pre-computed and exposed DH-exponents, DH-components, and DH-
secrets derived from one’s DH-component and its peer’s public-key (say, Acy and Bdx) which may be
exposed to the adversary prior to the session involving these pre-computed values. Then, we show how
the analysis can be extended and adapted to that of rOAKE.
^A; ^B
Analysis of (s)OAKE. Using the terminology of HDR signatures, a session of OAKE (resp.,
sOAKE) between two parties ˆA and ˆB consists of a basic Diﬃe-Hellman exchange of DH-components
X = gx and Y = gy; And the session-key K is then computed as the corresponding HDR-signatures,
speciﬁcally, K = HSIGOAKE
(m ^A; m ^B; X; Y )
for sOAKE), where m ^A and m ^B are set to be the empty string for both OAKE and sOAKE.
(m ^A; m ^B; X; Y ) for OAKE and (resp., K = HSIGsOAKE
During a session of (s)OAKE within the CK-framework, with oﬄine pre-computation, a party can be
activated with three types of activations (for presentation simplicity, we assume ˆA denotes the identity
of the party being activated and ˆB the identity of the intended peer to the session):
Initiate( ˆA, ˆB) (i.e., ˆA is activated as the initiator): ˆA generates a value X = gx, x ∈R Z
∗
q , creates
a local session of the protocol which it identiﬁes as the incomplete (open) session ( ˆA; ˆB; X), and
outputs the DH-component X as its outgoing message.
Here (X; x; Bdx), where d = h( ˆB; B; X) for OAKE or d = 1 for sOAKE can be oﬄine pre-computed
by ˆA, which may be exposed to the adversary prior to the session involving them.
^A; ^B
Respond ( ˆA; ˆB; Y ) (i.e., ˆA is activated as the responder): ˆA checks Y ∈ G \ 1G, if so it generates a
∗
q , outputs X, computes the session-key and then completes the session
value X = gx, x ∈R Z
( ˆA; ˆB; X; Y ).
Again, (X; x; Bdx) can be oﬄine pre-computed by ˆA, which may be exposed to the adversary prior
to the session involving them.
Complete( ˆA; ˆB; X; Y ) (i.e., the initiator ˆA receives Y from the responder peer ˆB): ˆA checks that
Y ∈ G \ 1G and that it has an open session with identiﬁer ( ˆA; ˆB; X). If any of these conditions
fails ˆA ignores the activation, otherwise it computes the session-key and completes the session
( ˆA; ˆB; X; Y ).
With the above notation, it is ensured that if ( ˆA; ˆB; X; Y ) is a complete session at ˆA, then its
matching session (if it exists) is unique, which is ( ˆB; ˆA; Y; X) owned by the player ˆB. In the following
analysis, we specify that the values, exposable to the adversary via session-state query (against an
incomplete session), include the DH-component and DH-exponent and the DH-secret of one’s DH-
component and its peer’s public-key, i.e., (Y; y; Acy) and (X; x; Bdx).
Theorem G.2 Under the GDH assumption in the RO model, the OAKE and sOAKE protocols (ac-
tually, the variants with public-keys removed from the inputs of c; d; e), with oﬄine pre-computed DH-
components, DH-exponents, and the DH-secrets of one’s DH-component and its peer’s public-key (say
Acy and Bdx), are SK-secure in the CK-framework w.r.t. any test-session between a pair of diﬀerent
players.
Proof. According to the SK-security deﬁnition in the CK-framework, we need to prove OAKE and
sOAKE satisfy the following two requirements:
Requirement-1. If two parties ˆA; ˆB complete matching sessions, then their session-keys are the same.
32
Requirement-2. Under the GDH assumption, there is no feasible adversary that succeeds in distin-
guishing the session-key of an unexposed session with non-negligible probability.
The Requirement-1 can be trivially checked for both OAKE and sOAKE. In the following, we focus
on establishing the Requirement-2.
Denote by ( ˆA; ˆB; X0 = gx0; Y0 = gy0) the unexposed test-session between a pair of uncorrupted
players ˆA and ˆB where ˆA ̸= ˆB, and by HK(v0) the session-key of the test-session that is referred to
as the test HDR-signature, where v0 = Ac0y0X d0b+e0y0 = Bd0x0Y c0a+e0x0. As HK is a random oracle,
there are only two strategies for the adversary A to distinguish HK(v0) from a random value:
Key-replication attack. A succeeds in forcing the establishment of a session (other than the test-
session or its matching session) that has the same session-key output as the test-session. In this
case, A can learn the test-session key by simply querying the session to get the same key (without
having to learn the value of the test HDR-signature).
Forging attack. At some point in its run, A queries the RO HK with the value v0. This implies that
A succeeds in computing or learning the test HDR-signature (i.e., the session-key of the test-
session) via its attacks. For presentation simplicity, we assume A directly outputs the session-key
of the test-session, referred to as the test HDR-signature, via a successful forging attack.
The possibility of key-replication attack is trivially ruled out unconditionally in the RO model by
the TBSS property of (s)OAKE. Speciﬁcally, for any session-tag ( ˆA; A; ˆB; B; X; Y ) and for any value
(cid:27) ∈ G \ 1G, the probability Pr[K ^A = K ^B = (cid:27)] ≤ 1
2l−1 holds for both OAKE and sOAKE, where the
probability is taken over only the choice of the random function h. Then, by the birthday paradox, any
eﬃcient attacker can succeed in the key-replication attack only with negligible probability (say, with
s2
2l−1 by the birthday paradox, where s is the number of sessions in the system).
probability at most
Actually, as the test-session and its matching session are deﬁned without taking public-keys into account
in the CK-framework, the possibility of key-replication attack is trivially ruled out unconditionally
in the RO model also for the public-key free variant of (s)OAKE. Speciﬁcally, for any test-session
′
( ˆA; ˆB; X; Y ) and any session ( ˆA
) that is unmatched to the test-session (which implies that
at least one of the following inequalities holds: ˆA ̸= ˆA
′
), it holds that
Pr[K ^A = K ^A′] = 1
2l−1 . As the attacker is polynomial-time, it cannot make two unmatched sessions to
output the same session-key with non-negligible probability.6
Then, in the following analysis, we only focus on ruling out the forging attack. Recall that ˆA ̸= ˆB
for the test-session ( ˆA; ˆB; X0; Y0) held by ˆA. In the rest, we make analysis mainly with respect to the
OAKE protocol, the similar and actually simpler holds also for sOAKE.
and Y ̸= Y
, ˆB ̸= ˆB
; ˆB
′
, X ̸= X
′
; X
; Y
′
′