把scope变回来,即得`[ [0,1,2] ]`
换句话,我们得到两个等量代换式:
    [blahblah(x) for x in [y] ] == [blahblah(x) where x = y]
    [blahblah(x) for x in [[y]][0] ] == [blahblah(x) where x = y]
这样相当于haskell的where语句
也就是说,可以用这种形式实现在scope内的赋值操作,在scope内把x赋值为y
比如说,要想得到`[(0, 0)]`我们可以这样写:
    [(x, y) for x in [0] for y in [[0]][0]] == [(0, 0)]
**lambda calculus beta规约(实现let语句)  
**
以下是lambda calculus的beta规约定理的例子:
    python
    (lambda j: j*2)(3) == (3*2) == 6
如果把lambda运算内部视为一个scope,那么就相当于
    lambda:
    let j = 3:
    return j*2
**开始逆向**
trick讲完了,就可以粗粗整理下代码了,加些赋值符号:
    python
    (lambda __g, __y: [[[[[[[(fin.close(), [[(lambda __items, __after, __sentinel: __y(lambda __this: lambda:
    (lambda __i: [(ss.append(c), (sss.append(0), __this())[1])[1]
    for __g['c'] in [(__i)]][0] if __i is not __sentinel else __after())
    (next(__items, __sentinel)))())(iter(s), lambda: [[(lambda __items, __after, __sentinel: __y(lambda __this: lambda: (lambda __i: [(lambda __value: [__this() for __g['sssss'] in [((lambda __ret: __g['sssss'] + __value if __ret is NotImplemented else __ret)(getattr(__g['sssss'], '__iadd__', lambda other: NotImplemented)(__value)))]][0])(chr(c)) for __g['c'] in [(__i)]][0] if __i is not __sentinel else __after())(next(__items, __sentinel)))())(iter(ssss), lambda: [(fout.write(sssss), (fout.close(), None)[1])[1] for __g['fout'] in [(open('flag.enc', 'wb+'))]][0], [])
    for __g['sssss'] in [('')]][0]
    for __g['ssss'] in [(encode(ss, sss))]][0], [])
    for __g['sss'] in [([])]][0]
    for __g['ss'] in [([])]
    ][0])[1]
    for __g['s'] in [(fin.read().strip())]][0]
    for __g['fin'] in [(open('flag.txt', 'r'))]][0]
    for __g['encode'], encode.__name__ in [
    (lambda data, buf:
      (lambda __items, __after, __sentinel:
        __y(lambda __this: lambda:
          (lambda __i:
            [data['i'] = ((table.index(data['i']) + 1))
            if __i is not __sentinel else __after())(next(__items, __sentinel)))())(iter(xrange(__l['_len'])),
            lambda: (lambda __items, __after, __sentinel:
              __y(lambda __this: lambda: (lambda __i: [[[
              __this() for __l['buf'] in [(
                 j=(i / 6) * 8 + (i % 6)
                 setbit(buf, i, getbit(data, j))
                  if __i is not __sentinel else __after())(next(__items, __sentinel)))())
            (iter(xrange((__l['_len'] * 6))), lambda: __l['buf'], []), []) for __l['_len'] in [(len(__l['data']))] )
    ]][0]
    for __g['getbit'], getbit.__name__ in [(lambda p, pos: (lambda __l: [[[((__l['p'][__l['cpos']] >> __l['bpos']) & 1) for __l['bpos'] in [((__l['pos'] % 8))]][0] for __l['cpos'] in [((__l['pos'] / 8))]][0] for __l['p'], __l['pos'] in [(p, pos)]][0])({}), 'getbit')]][0]
     for __g['setbit'], setbit.__name__ in [(lambda p, pos, value: (lambda __l: [[[(lambda __target, __slice, __value: [(lambda __target, __slice, __value: [__l['p'] for __target[__slice] in [((lambda __old: (lambda __ret: __old | __value if __ret is NotImplemented else __ret)(getattr(__old, '__ior__', lambda other: NotImplemented)(__value)))(__target[__slice]))]][0])(__l['p'], __l['cpos'], (__l['value'] >16
        b=(s>>8) & 0xFF
        c=s & 0xff
        sa=tobin(a)
        sb=tobin(b)
        sc=tobin(c)
        return table[int(sa[2:],2)]+table[int(sb[4:]+sa[:2],2)]+table[int(sc[6:]+sb[:4],2)]+table[int(sc[:6],2)]
    >>> a=open('flag.enc','rb')
    >>> a=a.read()
    >>> s=''
    >>> for i in xrange(0, len(a), 3):
    ...     s+=decode3b(int(a[i:i+3].encode('hex'), 16))
    ...
    >>> s
    'yedugr1ofbm2o4epQz8i1op2tpkxft1nf344t000000000000000'
    >>> s=''.join(map(lambda c: table[(table.index(c)+63)%64], s))
    'xdctfq0neal1n3doPy7h0no1sojwes0me233s"""""""""""""""'
由于只保留了最后6位,所以在table里的index大于64的特殊字符是没有的,要手动(脑)补上第7位,
查table+64可知`'q'->'{', 'o'->'_'`等等….
得:
    xdctf{0ne-l1n3d_Py7h0n_1s_@wes0me233}
****
**REVERSE 500**
注册机程序,给定机器码要求key,在string里可以发现openssl之类字样。
这题前半部分是队友看的,发现程序动态hook了GetDlgTextA,在其中首先检查位数是否48位,然后只包含0-9,A-F,接着进行hex解码后,扔到某个函数里处理后,前32位与机器码比较,后16位均为08(其实前部分是机器码移动2位再与0xe4异或后再比较的,还用了xmm0,不过那都是细节)。
关键就是前面的“某个函数”了,多试几次发现输入输出以64bit为一个块单位,结合字符串“libdes…”“解密之前”猜测该函数对输入使用des进行了解密,然后尝试找可疑的des
key,试了好几处发现函数开头的赋值有点奇怪,验证发现des key就是e1723b0b73f4c641,要记得大小端转换。
des操作采用pycrypto库,代码段如下:
c是用key和mode_ecb初始化后的des
    python
    >>> ss='F89AE772A6F990306EB0E82448435BFF'
    >>> t=ss.decode('hex')
    >>> t1=''
    >>> for ch in t:
    ...     t1+=chr(ord(ch)^0xe4)
    ...
    >>> t1
    'x1c~x03x96Bx1dtxd4x8aTx0cxc0xacxa7xbfx1b'
    >>> t1.encode('hex')
    '1c7e0396421d74d48a540cc0aca7bf1b'
    >>> ss='1c7e0396421d74d48a540cc0aca7bf1b0808080808080808'
    >>> ss=ss.decode('hex')
    >>> c.encrypt(ss).encode('hex')
    '9eea87758a647e5d74a376cd6281cfb5970bb701caf237f3'
    >>> s=c.encrypt(ss).encode('hex')
    >>> s.upper()
    '9EEA87758A647E5D74A376CD6281CFB5970BB701CAF237F3'
**CRYPT 100**
密文一眼看上去全是大写字母,略微数了一下发现少J,看来应该是用了什么奇怪的加密方式,GOOGLE一番,可以找到一个比较古典的加密方式,playfair
个人觉得这加密方法还挺复杂的,抓耳挠腮之后还是继续GOOGLE看看有没有现成的playfair破解工具。结果在stackoverflow或者什么Stackexchange之类的网站上找到了一个好像是个大学课程里面提供的C语言程序,http://www.cs.miami.edu/home/burt/learning/Csc609.051/programs/playn/,运行之后就解出了明文,但是明文还是有很多不准确的字母,稍微人肉看了几句话,再搜发现是I
have a dream的内容,稍微比对比对,发现文末就是FLAG。
**CRYPT 200**
首先查看程序,可以发现这题其实就两个操作,mkprof 是将所给字符串加上前后缀后加密,parse
是将所给加密的串解密,只要串中含有一个特定子串(加密的时候不能输入含有这个子串的串)就能拿到 flag。
而这里的加密采取分段的方式,每一段将当前段明文与前一段的密文异或的结果用一个固定的我们不知道的 key 来进行 AES 加密。
那么对于两个串 A 和 B,我们首先拿到 A 的第 n 段和 B 的第 n 段的加密结果(要求两者不一样),然后我们在 B 的第 n+1
段中含有所需特定字符串,由于我们不能直接要求服务器对 B 进行加密,我们可以将 A 的第 n+1 段设为一个特定的字符串,满足此串与 A 的第 n
段加密结果异或的值和 B 的第 n+1 段明文与 B 的第 n 段的加密结果异或的值一样,那么显然此时 A 与 B 第 n+1
段加密出来的结果会是一样的。于是我们将 A 加密得到的第 n+1 段拼在 B 的前 n 段的加密结果后面去解密,就能通过判断,拿到 flag。
## CRYPT 300
这题要求用户指定index和ckey,然后用某些复杂操作计算sha512的hash值,涉及我们不知道的password和某个随机数。
因为题目里存在有限域上的求幂操作,而且N给定,所以可以考虑让求幂结果相对较少,对ckey的检查只要求模N不为0,所以我们可以取1让它计算时不来添麻烦。对index的检查要求它在2-N/2之间,我们希望index的阶尽量小,后来把N-1分解了一下发现有2*2*5*bignum,所以就找了个阶为5的index,这样index不管多少次方最多应该就5个结果,于是其中随便猜一个不停跑就是了。
这题好歹python程序没丢……
    python
    #encoding = utf-8
    import random,sys,struct
    import base64 as b64
    import os
    import hmac
    from hashlib import sha512,sha1
    from time import time
    from pwn import *
    def hash2int(*params): 
    sha=sha512()
    for el in params:
    sha.update("%r"%el)
    return int(sha.hexdigest(), 16)  
    N = 1501763523645191865825715850305314918471290802252408144539280540647301821
    '''