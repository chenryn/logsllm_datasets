the constraint in false branch is symmetric) :
For Î·1, we have Î“s = {q : âˆ—} (we omit the base types and the vari-
ables that have 0 distance for brevity) and both assertions depend
on Î·1. Since both assertions depend on Î·1 and q[i], Algorithm 1
Thus,the algorithm adds q[i] + Î·2 â‰¥ TÎ· into E. Finally, since
q[i] is out of scope at the sampling instruction, expression using
q[i] and variable q[i] are excluded, resulting V ={ } and E ={ }.
(1) assert(q[i] + Î·2 +(cid:98)q[i] + (cid:98)Î·2 â‰¥ TÎ· + (cid:98)TÎ· )
(2) assert((cid:98)q[i] + (cid:98)Î·2 - (cid:98)TÎ· = 0)
adds(cid:98)q[i] into V. Moreover, assertion (1) is generated by rule (T-If).
Î·2 and q[i] and T , Algorithm 1 adds(cid:98)q[i] and(cid:98)TÎ· into V. Similar
expressions and variable are in scope, resulting V ={(cid:98)q[i],(cid:98)TÎ·} and
For Î·2, we have Î“s = {q: *, TÎ·: *}. Since both assertions depend on
to Î·1, the algorithm also adds q[i] + Î·2 â‰¥ TÎ· into E. Finally, all
E ={q[i] + Î·2 â‰¥ TÎ· }.
3.5 Function Signature Rewrite
Finally, CheckDP rewrites the function signature to reflect the
extra parameters and holes introduced in the transformed code.
In general, M(inp) is transformed to a new function signature
Mâ€²(inp,(cid:99)inp, sample, Î¸) where(cid:99)inp are the distance variables associ-
ated with inputs whose distance is not zero (e.g.,(cid:98)q is associated
with q in GapSVT), sample is a list of random values used in M, and
Î¸ are the missing holes in alignment templates.
3.6 Shadow Execution
To tackle challenging mechanisms such as Report Noisy Max [25],
CheckDP uses shadow execution [50]. Intuitively, the shadow exe-
cution tracks another program execution where the injected noises
are always the same as those in the original execution. Therefore,
values computed in the shadow execution incur no privacy cost.
The aligned execution can then switch to shadow execution when
certain conditions are met, allowing extra permissiveness [50].
Supporting shadow execution only requires a few modifications:
(1) Expressions will have a pair of distances (âŸ¨dâ—¦, dâ€ âŸ©), where the
extra distance dâ€  tracks the distance in the shadow execution;
(2) Since the branches and loop conditions in shadow execution
are not aligned, they might diverge from the original execution.
Hence, a separate shadow branch/loop is generated to correctly
update the shadow distances for the variables.
Since the extended transformation rules largely follow the cor-
responding typing rules of ShadowDP, we present the complete set
of rules with detailed explanations in the Appendix.
formed to Mâ€²(inp,(cid:99)inp, sample, Î¸), then M(inp) is differentially pri-
hold for all inp,(cid:99)inp, sample. Recall that an alignment template A
3.7 Soundness
CheckDP enforces a fundamental property: suppose M(inp) is trans-
vate if there is a list of values of Î¸, such that all assertions in Mâ€²
is a function of Î¸. Hence, we have a concrete alignment A(Î¸) (i.e.,
a proof) when such values of Î¸ exist.
We build the soundness of CheckDP based on that of Shad-
owDP [50]. The main difference is that ShadowDP requires every
sampling command Î· := Lap r to be manually annotated. Thus,
we can easily rewrite a program M in CheckDP to a program ËœM in
ShadowDP by adding the following annotations:
Î· := Lap r â†’ Î· := Lap r; â—¦; AÎ·(Î¸)
(CheckDP to ShadowDP)
where AÎ· is the alignment template for Î·. We formalize the
main soundness results next; the full proof can be found in the
Appendix.
Theorem 2 (Soundness). Let M be a mechanism written in
ËœM be the correspond-
CheckDP. With a list of concrete values of Î¸, let
ing mechanism in ShadowDP by rule (CheckDP to ShadowDP). If
(1) M type checks, i.e., âŠ¢ Î“ {M â‡€ Mâ€²} Î“â€² and (2) the assertions in
Mâ€² hold for all inputs. Then ËœM type checks in ShadowDP, and the
assertions in ËœMâ€² (transformed from ËœM by ShadowDP) pass.
Theorem 3 (Privacy). With exactly the same notation and as-
sumption as Theorem 2, M satisfies Ïµ-differential privacy.
8
Figure 4: Overview of the verify-invalidate loop of CheckDP.
4 PROOF AND COUNTEREXAMPLE
GENERATION
Recall that the transformed source code has the form of the fol-
lowing: Mâ€²(inp,(cid:99)inp, sample, Î¸). For brevity, Let I denote a triple of
(inp,(cid:99)inp, sample), and C denote a counterexample in the form of
C = (inp, inpâ€², o) as defined in Section 2.3. Proof/counterexample
generation is divided into two tasks:
â€¢ Proof Generation: find an instantiation of Î¸ such that assertions
in Mâ€² never fail for any input I, or
â€¢ Counterexample Generation: find an instantiation of I, such
that no Î¸ exists to make all assertions in Mâ€² pass, and then
construct a counterexample C based on I.
The key challenge here is the infinite search space of both Î¸
and I. Our insight is to use a verify-invalidate loop, as depicted in
Figure 4, to improve Î¸ and I after each iteration. At a high-level,
the iterative process involves two sub-loops: the (green) verify
sub-loop generates proofs, and the (blue) invalidate sub-loop gener-
ates counterexamples. Moreover, the two sub-loops are integrated:
starting from a default Î¸0 where Î¸0[i] = 0. âˆ€i, the procedure gen-
erates sequences of proofs and invalidating inputs in the form of
Î¸0, I0, Î¸1, I1, Â· Â· Â· . The final Î¸k or Ik is used to construct proof or
counterexamples correspondingly.
4.1 Verify Sub-Loop
The verify sub-loop that involves Invalidating Input Generation
and Proof Generation components is responsible of generating a
sequence of improving alignments Î¸0, Î¸1, Â· Â· Â· , Î¸i such that, if the
mechanism is correct, Î¸i is a privacy proof (i.e, âˆ€I . Mâ€²(I , Î¸i)).
Invalidating Input Generation. This component takes a proof
candidate Î¸i and then tries to find an input Ii such that Â¬Mâ€²(Ii , Î¸i)
(meaning that at least one assertion in Mâ€² fails).
Intuitively, Î¸i is the currently â€œbestâ€ proof candidate (initially,
a default null proof Î¸0 = [0, Â· Â· Â· ] is used to bootstrap the process)
that is able to validate all previously found inputs (I0, Â· Â· Â· , Iiâˆ’1). An
input Ii, if any, shows that Î¸i is in fact not a valid proof (recall
that a proof needs to ensure Mâ€²(I , Î¸i) âˆ€I). Hence, we call such Ii
an invaliding input of Î¸i and feed it with all previously identified
invalidating inputs to the Proof Generation component following
the â€œVerify Sub-loopâ€ edge.
Take GapSVT (Figure 1) for example. Since the initial null proof
Î¸0 = [0, Â· Â· Â· ] does not align any random variable, any input, say I0,
that diverges on the branch q[i] + Î·2 â‰¥ T will trigger an assertion
9
(a) A case where Î¸i cannot be
(b) Iteratively improving the
improved.
Figure 5: Tentative alignments and invalidating inputs.
alignment Î¸i .
violation at Line 22. Hence, the identified invalidating input I0 is
fed to the Proof Generation component.
Proof Generation. This component takes in a series of invalidat-
ing inputs I0, Â· Â· Â· , Ii seen so far, and tries to find an proof candidate
Î¸i such that:
â€²(I0, Î¸i) âˆ§ Â· Â· Â· âˆ§ M
â€²(Ii , Î¸i).
M
random variable Î·2 by âˆ’(cid:98)q[i] to cancel out the difference introduced
Intuitively, the goal is to find a proof candidate Î¸i that success-
fully â€œcoversâ€ all invalidating inputs seen so far. Most likely, an
improved proof candidate Î¸i that is able to align randomness for
more inputs is generated by the component. Then Î¸i is fed back to
the Invalidating Input Generation component, closing the loop.
Consider the GapSVT example again. In order to align random-
ness for the invalidating input I0, one possible Î¸1 is to align the
by q[i]. Note that this tentative proof Î¸1 does not work for all pos-
sible inputs: it only serves as the â€œbestâ€ proof given I0. With the
Verify Sub-loop, such imperfect proof candidates enable the gen-
eration of more invalidating inputs, such as an invalidating input
I1 where the query answers are mostly below the threshold T (I1
invalidates Î¸1 since a privacy cost incurs whenever any branch is
taken, which eventually exhausts the given privacy budget). There-
fore, a more general proof that leverages the conditional expression
q[i] + Î·2 â‰¥ T ? â€¢ : â€¢ in the alignment template can be discovered
by Proof Generation. For GapSVT, the Verify sub-loop eventually
terminates with a correct proof (Section 5).
Exit Edges. The verify loop has two exit edges. First, when no
invalidating input is generated, Î¸i is likely a valid proof. Hence, Î¸i
is passed to a verifier with the following condition: âˆ€I . Mâ€²(I , Î¸i).
Due to the soundness result (Theorem 3), we have a proof of dif-
ferential privacy when the verifier passes (the â€œExitâ€ edge from
Verifier component). Otherwise, CheckDP uses the counterexample
returned by the verifier to construct Ii (the â€œVerify Sub-loopâ€ edge).
We note that the verification step is required since KLEE, the sym-
bolic executor that we use to find invalidating inputs, is unsound
(i.e., it might miss an invalidating input) in theory; however, we did
not experience any such unsound case of KLEE in our experience.
Second, the Proof Generation component might fail to find an
alignment for I0, Â· Â· Â· , Ii, a case that will eventually occur for incor-
rect mechanisms. This exit edge leads to the invalidate sub-loop
that we discuss next.
4.2 Invalidate Sub-Loop
The invalidate sub-loop involves Counterexample Generation and
Restart; it is responsible of generating one single invalidating input
I such that, if the mechanism is incorrect, I cannot be aligned (i.e,
(cid:154)Î¸ . Mâ€²(I , Î¸)). At first glance, it could be attempting to directly use
Invalidating InputGenerationProof Generationğ¼!,â‹¯,ğ¼"ğœƒ"Counterexample GenerationVerifierğœƒ"CheckDPRestartPSIğœƒ!,â‹¯,ğœƒ"ğ¼!"#Verify Sub-loopExitUnknownProofğ¶ğœƒ!ğ¼"ğœƒ"ğ¼"CounterexampleInvalidate Sub-loopInputSpaceğ¼0ğœƒ1ğ¼$ğœƒ2InputSpaceğ¼0ğœƒ1ğ¼$â€¦ğœƒ2Ii from the Verify Sub-Loop. However, this is problematic both in
theory and in practice: no alignment for I0, Â· Â· Â· , Ii does not imply no
alignment of Ii alone. In practice, we found such a naive approach
fails for BadSmartSum and BadGapSVT in Section 5.
Counterexample Generation. This component takes an invali-
dating input Ii and then tries to find an alignment Î¸i such that
Mâ€²(Ii , Î¸i) (meaning that Ii is not a counterexample since it can be
aligned by Î¸i). For example, consider a corner case in Figure 5a,
where Proof Generation fails to find a common proof of both I0
and I1, but each of I0 and I1 has a proof (illustrated by the two solid
circles around them). Mostly likely, this occurs when the program
being analyzed is incorrect (hence, no common proof) but neither
I1 nor I2 is a good candidate for counterexample of differential
privacy, since each of them can be aligned in isolation.
Restart. This component is symmetric to the Invalidating Input
Generation component in the verify sub-loop: it takes all previously
found proof candidates Î¸1, Â· Â· Â· , Î¸i and tries to find an invalidating
input Ii +1 such that:
Â¬M
â€²(Ii +1, Î¸1) âˆ§ Â· Â· Â· Â¬M
â€²(Ii +1, Î¸i).
If found, Ii +1 will intuitively be out of scope of all found proofs
and serve as a â€œbetterâ€ invalidating input. In theory, we can close
the invalidate sub-loop by feeding Ii +1 back to Counterexample
Generation. However, doing so will make proof and counterexample
generation isolated tasks. Instead, we take an integrated approach,
which we discuss shortly, where the verify and invalidate sub-loops
communicate to generate proofs and counterexamples in a more
efficient and simultaneous way.
Exit Edges. If no Î¸ is found to prove Ii = (inp,(cid:99)inp, sample), a
counterexample C = (inp, inp +(cid:99)inp, Mâ€²(inp,(cid:99)inp, sample, Î¸0)) can
be formed and sent to an external exact probabilistic solver PSI [33]
for validation. In theory, the Restart component might fail to find a
new invalidating input given Î¸1, Â· Â· Â· , Î¸i. However, this â€œunknownâ€
state never showed up in our experience.
4.3 Integrating Verify and Invalidate Sub-Loops
We integrate the verify and invalidate sub-loops as follows: follow-
ing the â€œInvalidate Sub-loopâ€ edge of the Proof Generation com-
ponent, the latest invalidating input Ii (i.e., the â€œbestâ€ invalidating
input so far) is passed to the Counterexample Generation compo-
nent to start the invalidate sub-loop. Moreover, the newly generated
invalidating input Ii from the Restart component is fed back to the
Proof Generation component to start the verify sub-loop.
We note that by the design of the verify-invalidate loop, it alter-
natively runs Invalidating Input Generation and Proof Generation
components. By doing so, the proof keeps improving while the in-
validating inputs are getting closer to a true counterexample (since
the most recent one violates a â€œbetterâ€ proof). More intuitively,
consider an invalidating input I0 as a point in the entire input space,
illustrated in Figure 5b. A proof candidate Î¸1 is able to prove the
algorithm for a subset of inputs including I0 (indicated by the circle
around I0). The Invalidating Input Generation component then tries
to find another invalidating I1 that violates Î¸1 (falls outside of the
Î¸1 circle). Next, the Proof Generation component finds better proof
candidate Î¸2 which proves (â€œcoversâ€) both I0 and I1.
10
We also note that it is crucial to consider all invalidating inputs
so far rather than the last input Ii in the Proof Generation compo-
nent: the efficiency of our approach crucially relies on â€œimprovingâ€
the proofs quantified by validating more invalidating inputs. With-
out the improving proofs, the iterative procedure might fail to
terminate in case shown in Figure 5a: the procedure might repeat
I0, Î¸1, I1, Î¸2, I0, Î¸1, Â· Â· Â· . This is confirmed in our empirical study.
Unknown State. Due to the soundness result (Theorem 3), the
program being analyzed is verified whenever CheckDP returns with
a proof. Moreover, a validated counterexample by PSI disproves
an incorrect mechanism. However, two reasons might lead to the
â€œunknownâ€ state in the Figure 4: the generated counterexample
is invalid or the Restart component fails to find a new invalidat-
ing input. However, for all the correct and incorrect examples we
explored, the unknown state never showed up.
5 IMPLEMENTATION AND EVALUATION
We implemented CheckDP in Python3. The Program Transforma-
tion phase is implemented as a trans-compiler from CheckDP code
(Figure 2) to C code. Following the transformation rules in Fig-
ure 3, the trans-compiler tracks the typing environment, gathers
the needed constraints for the expressions, and more importantly,
instruments corresponding statements when appropriate. More-
over, it adds a final assertion assert(vÏµ â‰¤ Ïµb) before each return
command, where Ïµb is the annotated privacy bound to be checked.
Once all assertions are generated, the trans-compiler generates one
alignment template for each sampling instruction as described in
Algorithm 1. For the Proof and Counterexample Generation phase
(i.e., verify-invalidate loop in Section 4), we used an efficient sym-
bolic executor KLEE [18] for most tasks. Due to limited support of
unbounded lists in KLEE, we fix the length of lists to be 5 in our
evaluation. Also, to speed up the search, KLEE is configured to exit
once an assertion is hit. We note that the use of KLEE is to discover
alignments and counterexamples, where alignments are eventu-
ally verified by our sound Verifier component with arbitrary array
length; counterexamples are confirmed by PSI. Moreover, CheckDP
automatically extends the array length until either a verified proof
or verified counterexample is produced.
Finally, we deploy a verification tool CPAChecker [13] for the
Verifier component in CheckDP, which is capable of automatically
verifying C programs with given configuration (predicateAnalysis
is used). Note that CPAChecker is able to generate counterexam-
ples for a failed verification. If the verification fails (which did not
happen in our evaluation), CheckDP can feed the counterexample
back to the Proof and Counterexample Generation component.
5.1 Case Studies
Aside from GapSVT, we also evaluate CheckDP on the standard
benchmark used in previous mechanism verifiers [3, 50, 51] and
counterexample generators [14, 23],4 including correct ones such as
NumSVT, PartialSum, and SmartSum, as well as the incorrect vari-
ants of SVT reported in [40] and BadPartialSum. To show the power
3Publically available at https://github.com/cmla-psu/checkdp.
4We note that like all tools designed for privacy mechanisms (e.g., [3, 14, 23, 50, 51]),
the benchmark do not include iterative programs that are built on those privacy
mechanisms, such as k-means clustering, k-medians, since they are out of scope.
Table 1: Detected counterexamples for the incorrect algorithms and comparisons with other sampling-based counterexample
detectors. #t stands for true and #f stands for false.
Mechanism
BadNoisyMax
BadSVT1
BadSVT2
BadSVT3
BadGapSVT
BadAdaptiveSVT
Imprecise SVT
BadSmartSum
BadPartialSum
q
[0, 0, 0, 0, 0]
[0, 0, 0, 0, 1]
[0, 0, 0, 0, 1]
[0, 0, 0, 0, 1]
[0, 0, 0, 0, 0]
[0, 0, 0, 0, 2]
[0, 0, 0, 0, 1]
[0, 0, 0, 0, 0]
[0, 0, 0, 0, 0]
qâ€²
[âˆ’1, 1, 1, 1, 1]
[1, 1, 1, 1, 0]
[1, 1, 1, 1, âˆ’1]
[1, 1, 1, 1, âˆ’1]
[1, 1, 1, 1, âˆ’1]
[1, 1, 1, 1, âˆ’1]
[1, 1, 1, 1, âˆ’1]