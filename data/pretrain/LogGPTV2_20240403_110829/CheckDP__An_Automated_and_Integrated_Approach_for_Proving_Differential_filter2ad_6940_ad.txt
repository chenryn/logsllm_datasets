the constraint in false branch is symmetric) :
For η1, we have Γs = {q : ∗} (we omit the base types and the vari-
ables that have 0 distance for brevity) and both assertions depend
on η1. Since both assertions depend on η1 and q[i], Algorithm 1
Thus,the algorithm adds q[i] + η2 ≥ Tη into E. Finally, since
q[i] is out of scope at the sampling instruction, expression using
q[i] and variable q[i] are excluded, resulting V ={ } and E ={ }.
(1) assert(q[i] + η2 +(cid:98)q[i] + (cid:98)η2 ≥ Tη + (cid:98)Tη )
(2) assert((cid:98)q[i] + (cid:98)η2 - (cid:98)Tη = 0)
adds(cid:98)q[i] into V. Moreover, assertion (1) is generated by rule (T-If).
η2 and q[i] and T , Algorithm 1 adds(cid:98)q[i] and(cid:98)Tη into V. Similar
expressions and variable are in scope, resulting V ={(cid:98)q[i],(cid:98)Tη} and
For η2, we have Γs = {q: *, Tη: *}. Since both assertions depend on
to η1, the algorithm also adds q[i] + η2 ≥ Tη into E. Finally, all
E ={q[i] + η2 ≥ Tη }.
3.5 Function Signature Rewrite
Finally, CheckDP rewrites the function signature to reflect the
extra parameters and holes introduced in the transformed code.
In general, M(inp) is transformed to a new function signature
M′(inp,(cid:99)inp, sample, θ) where(cid:99)inp are the distance variables associ-
ated with inputs whose distance is not zero (e.g.,(cid:98)q is associated
with q in GapSVT), sample is a list of random values used in M, and
θ are the missing holes in alignment templates.
3.6 Shadow Execution
To tackle challenging mechanisms such as Report Noisy Max [25],
CheckDP uses shadow execution [50]. Intuitively, the shadow exe-
cution tracks another program execution where the injected noises
are always the same as those in the original execution. Therefore,
values computed in the shadow execution incur no privacy cost.
The aligned execution can then switch to shadow execution when
certain conditions are met, allowing extra permissiveness [50].
Supporting shadow execution only requires a few modifications:
(1) Expressions will have a pair of distances (⟨d◦, d†⟩), where the
extra distance d† tracks the distance in the shadow execution;
(2) Since the branches and loop conditions in shadow execution
are not aligned, they might diverge from the original execution.
Hence, a separate shadow branch/loop is generated to correctly
update the shadow distances for the variables.
Since the extended transformation rules largely follow the cor-
responding typing rules of ShadowDP, we present the complete set
of rules with detailed explanations in the Appendix.
formed to M′(inp,(cid:99)inp, sample, θ), then M(inp) is differentially pri-
hold for all inp,(cid:99)inp, sample. Recall that an alignment template A
3.7 Soundness
CheckDP enforces a fundamental property: suppose M(inp) is trans-
vate if there is a list of values of θ, such that all assertions in M′
is a function of θ. Hence, we have a concrete alignment A(θ) (i.e.,
a proof) when such values of θ exist.
We build the soundness of CheckDP based on that of Shad-
owDP [50]. The main difference is that ShadowDP requires every
sampling command η := Lap r to be manually annotated. Thus,
we can easily rewrite a program M in CheckDP to a program ˜M in
ShadowDP by adding the following annotations:
η := Lap r → η := Lap r; ◦; Aη(θ)
(CheckDP to ShadowDP)
where Aη is the alignment template for η. We formalize the
main soundness results next; the full proof can be found in the
Appendix.
Theorem 2 (Soundness). Let M be a mechanism written in
˜M be the correspond-
CheckDP. With a list of concrete values of θ, let
ing mechanism in ShadowDP by rule (CheckDP to ShadowDP). If
(1) M type checks, i.e., ⊢ Γ {M ⇀ M′} Γ′ and (2) the assertions in
M′ hold for all inputs. Then ˜M type checks in ShadowDP, and the
assertions in ˜M′ (transformed from ˜M by ShadowDP) pass.
Theorem 3 (Privacy). With exactly the same notation and as-
sumption as Theorem 2, M satisfies ϵ-differential privacy.
8
Figure 4: Overview of the verify-invalidate loop of CheckDP.
4 PROOF AND COUNTEREXAMPLE
GENERATION
Recall that the transformed source code has the form of the fol-
lowing: M′(inp,(cid:99)inp, sample, θ). For brevity, Let I denote a triple of
(inp,(cid:99)inp, sample), and C denote a counterexample in the form of
C = (inp, inp′, o) as defined in Section 2.3. Proof/counterexample
generation is divided into two tasks:
• Proof Generation: find an instantiation of θ such that assertions
in M′ never fail for any input I, or
• Counterexample Generation: find an instantiation of I, such
that no θ exists to make all assertions in M′ pass, and then
construct a counterexample C based on I.
The key challenge here is the infinite search space of both θ
and I. Our insight is to use a verify-invalidate loop, as depicted in
Figure 4, to improve θ and I after each iteration. At a high-level,
the iterative process involves two sub-loops: the (green) verify
sub-loop generates proofs, and the (blue) invalidate sub-loop gener-
ates counterexamples. Moreover, the two sub-loops are integrated:
starting from a default θ0 where θ0[i] = 0. ∀i, the procedure gen-
erates sequences of proofs and invalidating inputs in the form of
θ0, I0, θ1, I1, · · · . The final θk or Ik is used to construct proof or
counterexamples correspondingly.
4.1 Verify Sub-Loop
The verify sub-loop that involves Invalidating Input Generation
and Proof Generation components is responsible of generating a
sequence of improving alignments θ0, θ1, · · · , θi such that, if the
mechanism is correct, θi is a privacy proof (i.e, ∀I . M′(I , θi)).
Invalidating Input Generation. This component takes a proof
candidate θi and then tries to find an input Ii such that ¬M′(Ii , θi)
(meaning that at least one assertion in M′ fails).
Intuitively, θi is the currently “best” proof candidate (initially,
a default null proof θ0 = [0, · · · ] is used to bootstrap the process)
that is able to validate all previously found inputs (I0, · · · , Ii−1). An
input Ii, if any, shows that θi is in fact not a valid proof (recall
that a proof needs to ensure M′(I , θi) ∀I). Hence, we call such Ii
an invaliding input of θi and feed it with all previously identified
invalidating inputs to the Proof Generation component following
the “Verify Sub-loop” edge.
Take GapSVT (Figure 1) for example. Since the initial null proof
θ0 = [0, · · · ] does not align any random variable, any input, say I0,
that diverges on the branch q[i] + η2 ≥ T will trigger an assertion
9
(a) A case where θi cannot be
(b) Iteratively improving the
improved.
Figure 5: Tentative alignments and invalidating inputs.
alignment θi .
violation at Line 22. Hence, the identified invalidating input I0 is
fed to the Proof Generation component.
Proof Generation. This component takes in a series of invalidat-
ing inputs I0, · · · , Ii seen so far, and tries to find an proof candidate
θi such that:
′(I0, θi) ∧ · · · ∧ M
′(Ii , θi).
M
random variable η2 by −(cid:98)q[i] to cancel out the difference introduced
Intuitively, the goal is to find a proof candidate θi that success-
fully “covers” all invalidating inputs seen so far. Most likely, an
improved proof candidate θi that is able to align randomness for
more inputs is generated by the component. Then θi is fed back to
the Invalidating Input Generation component, closing the loop.
Consider the GapSVT example again. In order to align random-
ness for the invalidating input I0, one possible θ1 is to align the
by q[i]. Note that this tentative proof θ1 does not work for all pos-
sible inputs: it only serves as the “best” proof given I0. With the
Verify Sub-loop, such imperfect proof candidates enable the gen-
eration of more invalidating inputs, such as an invalidating input
I1 where the query answers are mostly below the threshold T (I1
invalidates θ1 since a privacy cost incurs whenever any branch is
taken, which eventually exhausts the given privacy budget). There-
fore, a more general proof that leverages the conditional expression
q[i] + η2 ≥ T ? • : • in the alignment template can be discovered
by Proof Generation. For GapSVT, the Verify sub-loop eventually
terminates with a correct proof (Section 5).
Exit Edges. The verify loop has two exit edges. First, when no
invalidating input is generated, θi is likely a valid proof. Hence, θi
is passed to a verifier with the following condition: ∀I . M′(I , θi).
Due to the soundness result (Theorem 3), we have a proof of dif-
ferential privacy when the verifier passes (the “Exit” edge from
Verifier component). Otherwise, CheckDP uses the counterexample
returned by the verifier to construct Ii (the “Verify Sub-loop” edge).
We note that the verification step is required since KLEE, the sym-
bolic executor that we use to find invalidating inputs, is unsound
(i.e., it might miss an invalidating input) in theory; however, we did
not experience any such unsound case of KLEE in our experience.
Second, the Proof Generation component might fail to find an
alignment for I0, · · · , Ii, a case that will eventually occur for incor-
rect mechanisms. This exit edge leads to the invalidate sub-loop
that we discuss next.
4.2 Invalidate Sub-Loop
The invalidate sub-loop involves Counterexample Generation and
Restart; it is responsible of generating one single invalidating input
I such that, if the mechanism is incorrect, I cannot be aligned (i.e,
(cid:154)θ . M′(I , θ)). At first glance, it could be attempting to directly use
Invalidating InputGenerationProof Generation𝐼!,⋯,𝐼"𝜃"Counterexample GenerationVerifier𝜃"CheckDPRestartPSI𝜃!,⋯,𝜃"𝐼!"#Verify Sub-loopExitUnknownProof𝐶𝜃!𝐼"𝜃"𝐼"CounterexampleInvalidate Sub-loopInputSpace𝐼0𝜃1𝐼$𝜃2InputSpace𝐼0𝜃1𝐼$…𝜃2Ii from the Verify Sub-Loop. However, this is problematic both in
theory and in practice: no alignment for I0, · · · , Ii does not imply no
alignment of Ii alone. In practice, we found such a naive approach
fails for BadSmartSum and BadGapSVT in Section 5.
Counterexample Generation. This component takes an invali-
dating input Ii and then tries to find an alignment θi such that
M′(Ii , θi) (meaning that Ii is not a counterexample since it can be
aligned by θi). For example, consider a corner case in Figure 5a,
where Proof Generation fails to find a common proof of both I0
and I1, but each of I0 and I1 has a proof (illustrated by the two solid
circles around them). Mostly likely, this occurs when the program
being analyzed is incorrect (hence, no common proof) but neither
I1 nor I2 is a good candidate for counterexample of differential
privacy, since each of them can be aligned in isolation.
Restart. This component is symmetric to the Invalidating Input
Generation component in the verify sub-loop: it takes all previously
found proof candidates θ1, · · · , θi and tries to find an invalidating
input Ii +1 such that:
¬M
′(Ii +1, θ1) ∧ · · · ¬M
′(Ii +1, θi).
If found, Ii +1 will intuitively be out of scope of all found proofs
and serve as a “better” invalidating input. In theory, we can close
the invalidate sub-loop by feeding Ii +1 back to Counterexample
Generation. However, doing so will make proof and counterexample
generation isolated tasks. Instead, we take an integrated approach,
which we discuss shortly, where the verify and invalidate sub-loops
communicate to generate proofs and counterexamples in a more
efficient and simultaneous way.
Exit Edges. If no θ is found to prove Ii = (inp,(cid:99)inp, sample), a
counterexample C = (inp, inp +(cid:99)inp, M′(inp,(cid:99)inp, sample, θ0)) can
be formed and sent to an external exact probabilistic solver PSI [33]
for validation. In theory, the Restart component might fail to find a
new invalidating input given θ1, · · · , θi. However, this “unknown”
state never showed up in our experience.
4.3 Integrating Verify and Invalidate Sub-Loops
We integrate the verify and invalidate sub-loops as follows: follow-
ing the “Invalidate Sub-loop” edge of the Proof Generation com-
ponent, the latest invalidating input Ii (i.e., the “best” invalidating
input so far) is passed to the Counterexample Generation compo-
nent to start the invalidate sub-loop. Moreover, the newly generated
invalidating input Ii from the Restart component is fed back to the
Proof Generation component to start the verify sub-loop.
We note that by the design of the verify-invalidate loop, it alter-
natively runs Invalidating Input Generation and Proof Generation
components. By doing so, the proof keeps improving while the in-
validating inputs are getting closer to a true counterexample (since
the most recent one violates a “better” proof). More intuitively,
consider an invalidating input I0 as a point in the entire input space,
illustrated in Figure 5b. A proof candidate θ1 is able to prove the
algorithm for a subset of inputs including I0 (indicated by the circle
around I0). The Invalidating Input Generation component then tries
to find another invalidating I1 that violates θ1 (falls outside of the
θ1 circle). Next, the Proof Generation component finds better proof
candidate θ2 which proves (“covers”) both I0 and I1.
10
We also note that it is crucial to consider all invalidating inputs
so far rather than the last input Ii in the Proof Generation compo-
nent: the efficiency of our approach crucially relies on “improving”
the proofs quantified by validating more invalidating inputs. With-
out the improving proofs, the iterative procedure might fail to
terminate in case shown in Figure 5a: the procedure might repeat
I0, θ1, I1, θ2, I0, θ1, · · · . This is confirmed in our empirical study.
Unknown State. Due to the soundness result (Theorem 3), the
program being analyzed is verified whenever CheckDP returns with
a proof. Moreover, a validated counterexample by PSI disproves
an incorrect mechanism. However, two reasons might lead to the
“unknown” state in the Figure 4: the generated counterexample
is invalid or the Restart component fails to find a new invalidat-
ing input. However, for all the correct and incorrect examples we
explored, the unknown state never showed up.
5 IMPLEMENTATION AND EVALUATION
We implemented CheckDP in Python3. The Program Transforma-
tion phase is implemented as a trans-compiler from CheckDP code
(Figure 2) to C code. Following the transformation rules in Fig-
ure 3, the trans-compiler tracks the typing environment, gathers
the needed constraints for the expressions, and more importantly,
instruments corresponding statements when appropriate. More-
over, it adds a final assertion assert(vϵ ≤ ϵb) before each return
command, where ϵb is the annotated privacy bound to be checked.
Once all assertions are generated, the trans-compiler generates one
alignment template for each sampling instruction as described in
Algorithm 1. For the Proof and Counterexample Generation phase
(i.e., verify-invalidate loop in Section 4), we used an efficient sym-
bolic executor KLEE [18] for most tasks. Due to limited support of
unbounded lists in KLEE, we fix the length of lists to be 5 in our
evaluation. Also, to speed up the search, KLEE is configured to exit
once an assertion is hit. We note that the use of KLEE is to discover
alignments and counterexamples, where alignments are eventu-
ally verified by our sound Verifier component with arbitrary array
length; counterexamples are confirmed by PSI. Moreover, CheckDP
automatically extends the array length until either a verified proof
or verified counterexample is produced.
Finally, we deploy a verification tool CPAChecker [13] for the
Verifier component in CheckDP, which is capable of automatically
verifying C programs with given configuration (predicateAnalysis
is used). Note that CPAChecker is able to generate counterexam-
ples for a failed verification. If the verification fails (which did not
happen in our evaluation), CheckDP can feed the counterexample
back to the Proof and Counterexample Generation component.
5.1 Case Studies
Aside from GapSVT, we also evaluate CheckDP on the standard
benchmark used in previous mechanism verifiers [3, 50, 51] and
counterexample generators [14, 23],4 including correct ones such as
NumSVT, PartialSum, and SmartSum, as well as the incorrect vari-
ants of SVT reported in [40] and BadPartialSum. To show the power
3Publically available at https://github.com/cmla-psu/checkdp.
4We note that like all tools designed for privacy mechanisms (e.g., [3, 14, 23, 50, 51]),
the benchmark do not include iterative programs that are built on those privacy
mechanisms, such as k-means clustering, k-medians, since they are out of scope.
Table 1: Detected counterexamples for the incorrect algorithms and comparisons with other sampling-based counterexample
detectors. #t stands for true and #f stands for false.
Mechanism
BadNoisyMax
BadSVT1
BadSVT2
BadSVT3
BadGapSVT
BadAdaptiveSVT
Imprecise SVT
BadSmartSum
BadPartialSum
q
[0, 0, 0, 0, 0]
[0, 0, 0, 0, 1]
[0, 0, 0, 0, 1]
[0, 0, 0, 0, 1]
[0, 0, 0, 0, 0]
[0, 0, 0, 0, 2]
[0, 0, 0, 0, 1]
[0, 0, 0, 0, 0]
[0, 0, 0, 0, 0]
q′
[−1, 1, 1, 1, 1]
[1, 1, 1, 1, 0]
[1, 1, 1, 1, −1]
[1, 1, 1, 1, −1]
[1, 1, 1, 1, −1]
[1, 1, 1, 1, −1]
[1, 1, 1, 1, −1]