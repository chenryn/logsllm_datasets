192
168
192.168.0.1
用来唯一标识连接到网络的设备。由于让
(subne
司
---
## Page 120
6.2.2
2IPv4头
数据包复杂得多。这其中包含很多额外的信息，以便IP完成其工作。
0000000000000000可以被写成255.255.0.0
后一半（1.22或者0000000100010110）标识着这个网络上的主机，如图6-8
这意味着IP地址的前一半（10.10或者0000101000001010）是网络地址，而
码。在这个例子中，我们的网络掩码是1111111111111110000000000000000
0000000100010110。为了能够区分出IP地址的每一个部分，我们将使用网络掩
用来进行流量的优先排序。
不是你在数据包中能够找到的IP信息的全部。IP头比起我们刚刚介绍过的ARP
10.10.1.22/16的形式。
来说，IP地址10.10.1.22和网络掩码255.255.0.0，在CIDR表示法下就会被写成
会有一个左斜杠（/），以及一个用来表示IP地址中网络部分位数的数字。举例
所示。
源IP地址和目的IP地址都是IPv4数据包头中的重要组成部分，但它们并
IP地址和网络掩码为简便起见，
255.255.0.01111111 1111111
如图6-9所示，IPv4头有着下列几个域。
网络掩码也可以写成点分四组的形式
10.10.122-00001010000010100000000100010110
我们以IP地址10.10.1.22为例，其二进制形式为0000101000001010
标识符
首部长度（Header Length）：IP头的长度
版本号（Version）：IP所使用的版本。
(ldentification）:
图6-8网络掩码决定了IP地址中比特位的分配
网络
一个唯一的标识数字，用来识别一个数据包或者
）的形式。在这个形式下，
0000000000000
通常会被写成无类型域间选路（Classless
主机
比如网络掩码1111111111111
第6章通用底层网络协设103
一个完整的IP地址后面
---
## Page 121
6.2.3
104
被分片数据包的次序。
偏移位0~3
Wireshark数据包分析实战（第2版）
192+
160or
160
128
96
64
0
存活时间
被用来将数据包以正确的顺序重新组装。
数/秒数进行描述。
容没有被损坏或者篡改。
些选项。
标记（Flags）：
版本
首部校验和（HeaderChecksum）：
数据（Data）：使用IP传递的实际数据。
存活时间
首部长度
4~7
标识符
用来标记一个数据包是否是一组分片数据包的一部分
服务类型
8~15
协议
图6-9IPv4数据包结构
目的IP地址
源IP地址
IP协议
数据
选项
16~18
标记
首部校验和
总长度
分段偏移
19~31
---
## Page 122
长度是60字节并且TTL域的值是1280。
过在PacketDetails面板中展开IP头区段看到
头中的TTL域就为了防止出现这个潜在的问题。
包的增多，网络中可用的带宽就会减少，直至拒绝服务（DoS）的情况出现。IP
包的形式发生在网络上。数据包可能会在路由器之间持续循环。随着循环数据
说会导致一个程序或者整个操作系统的崩溃。理论上，同样的事情也会以数据
死循环。
路由器可能会做很多事情，其中一件就是将数据包发向一个网络，而产生一个
被错误配置的路由器，而失去其到达最终目的地的路径。在这种情况下，这个
发往一台主机需要经过数十个路由器。在这个数据包的路径上，它可能会碰到
只是其从源前往目的地所花去的时间。但是考虑到一个数据包想要通过互联网
去1
通常情况下，我们还是可以认为一
上还是基于时间的，
个网络中，那么这个数据包就会被丢弃，如图6-10所示。由于TTL的值在技术
由。这个路由接着会将TTL减为0，这时如果这个数据包的最终目的地不在这
那么当它到达第一个路由器的时候，其TTL会被减为1，并会被发向第二个路
你可以看到IP的版本号为40，IP头的长度是20字节，首部和载荷的总
如果你有任何编程背景，那么你就会知道死循环会导致各种问题，一般来
为什么TTL的值会这样重要？我们通常所关心的一个数据包的生存周期，
图6-10数据包的TTL在每次经过一个路由器的时候减少
TTL2TTL1
TTL3-
一个非常繁忙的路由器可能会将TTL的值减去不止1，但
个路由设备在多数情况下只会将TTL的值减
第6章通用底层网络协议105
---
## Page 123
10.00010.100319216.1281CMPc（pg）
Frame 1 (74 bytes on wire,74 bytes captured)
Ethernet It.
0040
1020
Time to 11ve:128
Differentiated services Field:oxoo （oscp oxoo: Default;ECN: Oxoo)
Protocol:ICMP (Ox01)
1dentificat1on:0x728d (29325)
1000000119103
Ethernet-ll.
的设备。这个原始的捕获文件是在源主机10.10.0.3上被创建的。
所示）
1ength: 20 bytes
Tine
Total
cneck
cato：0x28d（2912）
offset:0
to
ksum:0xooo0 [validat1on disabled]
0506
60
10.10.0
sre
Oxfafe[ealidattan disabTed]
(192.168.0.128)
29:0071940800
图6-11源数据包的IP头
74bytes
Caatur
（319265）
（192.168.0.126)
abcde
---
## Page 124
6.2.4
IP分片
默认MTU是1500.也就是说，以太网的网络上所能传输的最大数据包大小是
配置情况。在多数情况下，第2层所使用的数据链路协议是以太网。以太网的
网络时可靠传输的一个特性。
这台路由器的路径会将TTL值减1。
知道网络的结构，我们也可以知道这两台设备是由一台路由器隔开，并且经过
Packet List面板的Info列中列出了两个被分段的IP数据包。
个地址为192.168.0.128的设备发送ping请求。注意在ICMP（ping）请求之后，
据包分片包括下列的步骤。
及将要把这个数据包传送出去的网络接口MTU，用于决定是否需要将这个数据
管理路由器的界面上修改
MTU是基于接口进行设定，其可以在Windows或者Linux系统上修改，或者在
1500字节（并不包括14字节的以太网头本身）
（MaximumTransmissionUnit，MTU）的大小，以及使用这些第2层协议的设备
包分片
尽管存在着标准的MTU设定，但是一个设备的MTU通常可以手工设定。
一个数据包的分片主要基于第2层数据链路协议所使用的最大传输单元
数据包分片是将一个数据流分为更小的片段，是IP用于解决跨越不同类型
你可以立刻注意到TTL的值变为127了，比原先的TIL减少了1。即使不
根据更多分片和分片偏移域，你可以断定这个数据包是分片数据包的一部分。被
先检查数据包1的IP头（如图6-13所示）
1.设备将数据分为若干个可成功进行传输的数据包。
当一个设备准备传输一个IP数据包时，它将会比较这个数据包的大小，以
数据包被发送出去
IP头中分片部分的分片偏移将会被设置。
更多分片标志将会在数据流的所有数据包中设置为1，除了最后一个数据包。
每个IP头的总长度域会被设置为每个分片的片段长度。
如果数据包的大小大于MTU，那么这个数据包就会被分片。将一个数
第6章通用底层网络协议107
---
## Page 125
1000000201003221012
Ether
rme 1 （1514 b6om
个数据包。
Entet
(bys)
lags:
total
足
的20字节。
ticati
Dxta
seader
Frot
C
13003152168812#
图6-13更多分片和分片偏移值可以用来识别分片数据包
07474（29812)
FTag
®
1500
677[validatlon disab]ed]
Notset
C10.10
1514 bytes
16-14
128
[atidat londtsabTed]
1514-bytes
(192.168.0.126)
分片偏移值会根据数据包的大小而增大
121
CaD
29
66
tt
---
## Page 126
6.3.1TCP头
6.3传输控制协议
30.00011.1003192.10.128ICMPopngequt
Frame(582 bytes）Reasembled
Flags:0x00
EthernetII,
Identif1cat1on:0x7474(29812）
Total Length:
Header
version:
D.
0
是因为它们IP头中的标志位域拥有相同的值。
1480+（1500-20）的结果。这些分片可以被认为是同一个数据序列的一部分，
着整个数据流中的最后一个分片。并且其分片偏移被设定为29609，也就是
以下是TCP头的域。
方。很多普遍使用的应用层协议都依赖于TCP和IP将数据包传输到其最终目
它能够处理数据的顺序和错误恢复，并且最终保证数据能够到达其应到达的地
提供可靠的端到端传输。TCP在RFC793中定义，在OSI模型中的第4层工作。
的地。
che
src:00:21:29:66:71
TCP提供了许多功能，并且反映在了其头部的复杂性上面。如图6-16所示，
第三个数据包（如图6-15所示），并没有设定更多分片标志位0，也就标志
传输控制协议（TransmissionControl Protocol,TCP）的最终目的是为数据
568
图6-15没有设置更多分片标志位意味着这是最后一个分片
oxf 8a9 [validatfon disabled]
1990
(192.168.0.128)
tel
929
(00:2
226
1:29:66:71:94).D5t:00:21:70:C0:56:0（00:21:70:c0:56:f0)
第6章通用底层网络协议109
---
## Page 127
6.3.2
110
Wireshark
TCP端口
保证数据流中的部分没有缺失。
所传输的TCP数据包的类型
得到的下
偏移位0~3
外的指令，告诉CPU从数据包的哪里开始读取数据。
整性。
128
96
中找到。端口就像是老式电话总机上的插口。
序号（SequenceNumber）：这个数字用来表示一个TCP片段。这个域用来
目的端口
源端口（SourcePort）：用来传输数据包的端口。
160
窗口大小（Window Size）：TCP接收者缓冲的字节大小。
数据偏移保留
个数据包的序号。
（Destination Port）：数据包将要被发送到的端口。
4~7
校验和
源端口
8~15
图6-16TCP头
传输控制协议
标记
确认号
选项
序号
日的端口
紧急指针
窗口大小
16~31
一个总机操作员会监视着一
P端口大概
每次呼叫
---
## Page 128
以很简单地从发送过来的原始数据包中得到这个端口（如图6-17所示）。
那么这个通信就会失败。
须知道远程服务所监听的端口。
就是这样工作的。
它的源端口是属于临时端口组的28260（需要记住的是源端口是由操作系统
生的HTTP通信。正如前面所提到的HTTP便用TCP进行通信，所以这将是一
所使用的端口号。在这个文件中，我们会看到一个客户端在浏览两个网站时产
些端口分成两个部分。
个非常典型的TCP流量案例。
在这个文件中的第一个数据包中（如图6-18所示）
这个序列中的源端口并不十分重要，所以可以随机选择。远程服务器也可
为了能够将数据传输到远程服务器或设备的特定应用中去，TCP数据包必
1024~65535是临时端口组（尽管一些操作系统对此有着不同的定义），当
在使用TCP进行通信的时候，我们有65535个端口可供使用，并通常将这
临时端口组。
地选择一个源端口，让这个通信使用唯一源端口。这些源端口通常就位于
一个服务想在任意时间使用端口进行通信的时候，现代操作系统都会随机
于标准端口分组中的标准端口。
1~1023是标准端口组（忽略掉被预留的0），特定服务会用到这些通常位
图6-17
端口25/目的编口3221—
端口3221/日的端口25—
项口80/日的端口1024-
源口1024/日的端口80—
TCP使用端口传输数据
。如果你想要试着连接一个不同于所设置的端口，
在子部件服务部
在端口80上侦听
Web服务器
第6章通用底层网络协议111
一开始的两个值代表着这
---