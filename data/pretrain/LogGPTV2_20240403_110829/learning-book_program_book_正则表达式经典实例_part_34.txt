正则表达式数组来搜索的时候，你可以指定单个字符串作为替代（所有的正则表达式
都用它），也可以指定一个替代数组。如果两个参数都是数组，那么preg_replaceO会遍
历正则式和替代文本2个数组，对每个正则式都使用一次不同的替代文本。当
preg_replace()遍历数组的时候，会按照它们在内存中的存放顺序，而这不一定是按照数
组中的索引的数值顺序。如果你的数组不是照数值顺序来构造的，那么在把它们传递
给preg_replaceO之前需要对正则表达式和替代文本的数组调用ksortO函数。
下面的例子中构造的Sreplace数组就是逆序的：
$regex[0]='/a/';
/a/.=[t]xabaxs
$regex[2]='/c/';
$replace[2]='3';
$replace[1]='2';
$replace[0]='1';
echo preg_replace($regex,$replace,"abc");
ksort($replace);
第一个对preg_replaceO的调用会显示321，而这并不是你所期望的结果。在使用了ksortO
之后，替换结果才变成预期的123。ksort0会修改你传递给它的变量，所以不要把它的
返回值（true或false）传递给preg_replace(。
Perl
在Perl中，s//实际上是一个替代操作符。如果只使用s/I，那么它会对变量S_执
行查找和替换，并把结果保存到变量$中。
如果想要在另外一个变量之上使用替换操作符，那么就需要使用=～绑定操作符来
把替换操作符关联到你的变量之上。把替换操作符绑定到一个字符串会立即执行查
找和替换。结果会被保存回包含目标字符串的变量中。
s//操作符总是会修改你绑定到其上的变量。如果想要把查找和替换的结果保存到
一个新的变量中，而不想去修改原来的变量，那么就需要首先把原来的字符事赋给
使用正则表达式编程167
www.TopSage.com
---
## Page 184
结果变量，然后再把替换操作符绑定到该变量之上。这个实例中Perl的解决方案在
一行代码内完成了这两个步骤。
在实例3.4中讲过，使用/g修饰符会替换所有的正则匹配。如果不使用它，那么Perl
只会替换第一个匹配。
Python
re模块中的sub(函数会使用正则表达式执行查找和替换操作。把你的正则表达式作为
第一个参数，替代文本作为第二个参数，而目标字符事作为第三个参数。全局的sub0
函数并不支持接受正则表达式选项作为参数。
re.subO函数会先调用re.compileO，然后使用编译好的正则表达式对象来调用subO方法。
这个方法有2个必需的参数：替代文本和目标字符串。
subO的两种形式都会返回一个把所有正则表达式替换之后的字符串。它们都会接受一
个可选参数，充许你使用它来限制替换执行的次数。如果略去了这个参数，或者设为0，
那么所有正则匹配都会被替换。如果你传递了一个正整数，那么它就是最大可能会替
换的匹配个数。如果找到的匹配个数小于你指定的参数，那么所有的匹配都会被替换，
而不会产生任何错误。
Ruby
String类中的gsubO函数会使用正则表达式执行查找和替换操作。把你的正则表达式作
为第一个参数，替代文本作为第二个参数。返回值是应用了替换之后的一个新字符事。
如果没有找到任何匹配，那么gsubO会返回原来的字符串。
gsubO函数并不会修改调用它的字符串。如果你想要修改最初的字符串，那么就需要使
用gsub!O。如果没有找到任何正则匹配，那么gsub!O会返回nil。否则，它会返回应用
了替换之后的调用它的学符串。
参见
第1章中的“使用正则表达式查找和替换”小节，以及实例3.15和3.16。
3.15使用匹配的子串来替换匹配
问题描述
你想要在执行查找和替换的时候，在替代文本中重新插入正则匹配的一部分。在你的
正则表达式中，已经把想要重新插人的子串分离到了捕获分组中（参考实例2.9)。
例如，你想要匹配由等号分隔的单词对，然后把等号两边的单词进行交换。
168第3章
www.TopSage.com
---
## Page 185
解决方案
C#
当你打算只使用同一个正则表达式处理少量字符串的时候，可以使用如下的静态调用：
(+)(+x
"$2=$1");
如果想要把同一个正则表达式应用于大量的字符串，那么就需要构造一个Regex对象：
（(+\)=(+m))xabau aoxbxb
x
VB.NET
当你打算只使用同一个正则表达式处理少量字符事的时候，可以使用如下的静态调用：
x
如果想要把同一个正则表达式应用于大量的字符事，那么就需要构造一个Regex对象：
Dim RegexObj As New Regex("(\w+)=(\w+) ")
Java
如果你打算只使用同一个正则表达式处理一个学符串，那么可以调用String.replaceAllO：
String resultString = subjectString.replaceAll("(\\w+)=(\\w+) ", "$2=$1") ;
如果要把同一个正则表达式用于大量字符串，那么就需要构造一个Matcher对象：
Pattern regex =Pattern.compile("(\\w+)=(\\w+)");
Matcher regexMatcher =regex.matcher(subjectString);
JavaScript
PHP
$result =preg_replace('/(\w+)=(\w+)/','$2=$1',$subject）;
Perl
$subject=~ s/(\w+)=(\w+)/$2=$1/g
Python
如果你打算只使用同一个正则表达式处理少量字符事，可以使用如下的全局函数：
使用正则表达式编程
169
www.TopSage.com
---
## Page 186
result= re.sub(r"(\w+)=(\w+)",r"\2=\1",subject)
要想重复使用同一个正则表达式，那么就需要使用一个编译好的对象：
reobj = re.compile(r"(\w+)=(\w+)")
result = reobj.sub(r"\2=\1"，subject)
Ruby
result=subject.gsub(/(\w+)=(\w+)/，'\2=\1')
讨论
正则表达式\w+)=(?\w+)","$(right}=${left}"）;
如果想要把同一个正则表达式应用于大量的字符串，那么就需要构造一个Regex对象：
（（+）=(+<>））xbuxxb
string resultString=regexObj.Replace(subjectString, "$(right)=$(left)");
使用正则表达式编程171
www.TopSage.com
---
## Page 188
VB.NET
当你打算只使用同一个正则表达式处理少量字符串的时候，可以使用如下的静态调用：
Dim ResultString = Regex.Replace(SubjectString,
"(?\w+)=(?\w+)","$(right}=${left}")
如果想要把同一个正则表达式应用于大量的字符串，那么就需要构造一个Regex对象：
+>=(>xx
x
PHP
（+b>（+>
'$2=$1'，$subject);
PHP中的preg函数使用的是PCRE函数库，而后者会支持命名捕获。preg_matchO和
preg_match_allO两个函数会把命名捕获分组添加到匹配结果所在的数组中。不幸的是，
preg_replaceO并没有提供一种方式来在替代文本中使用向后引用。如果你的正则表达式
中包含命名捕获分组，那么就需要从左向右统计所有命名和非命名的捕获分组来确定
每个分组的向后引用编号。在替代文本中使用这些编号。
Perl
$subject =~ s/(?\w+)=(?\w+) /$+(right)=$+{left}/g;
Perl从5.10版开始支持命名捕获分组。“S+hash”会保存上--次用到的正则表达式
中所有命名捕获分组匹配到的文本。同在其他任何地方一样，你也可以在替代文本
学符串中使用这样的哈希（hash）。
Python
如果你打算只使用同一个正则表达式处理少量字符事，可以使用如下的全局函数：
result = re.sub(r"(?P\w+)=(?P\w+)", r"\g=\g",
subject)
要想重复使用同一个正则表达式，那么就需要使用一个编译好的对象：
（+>(+>)
result = reobj.sub(r"\g=\g", subject)
Ruby
result = subject.gsub(/ (?\w+)=(?\w+)/, '\k=\k')
参见
第1章中“使用正则表达式查找和替换”小节中介绍了替代文本的流派。
172第3章
www.TopSage.com
---
## Page 189
实例2.21中讲解了如何在替代文本中引用捕获分组。
3.16使用代码中生成的替代文本来替换匹配
问题描述
你想要把正则表达式的所有匹配都替换为你在过程代码中构造的一个新的字符串。你
想要能够把每个匹配替换为按照实际匹配到的内容来决定的不同字符串。
例如，假设你想要把一个字符串中的所有数字都替换为该数字的2倍。
解决方案
#
当你打算只使用同一个正则表达式处理少量字符串的时候，可以使用如下的静态调用：
new MatchEvaluator(ComputeReplacement));
如果想要把同一个正则表达式应用于大量的字符串，那么就需要构造一个Regex对象：
Regex regexObj = new Regex(@"\d+");
new MatchEvaluator(ComputeReplacement));
这两个代码片段中都调用了函数ComputeReplacement。你应当把这个方法添加到用来
实现这个解答的类中：
int twiceasmuch = int.Parse(matchResult.Value) * 2;
return twiceasmuch.ToString();
VB.NET
当你打算只使用同一个正则表达式处理少量字符串的时候，可以使用如下的静态调用：