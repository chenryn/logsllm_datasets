• 
Interact with other members’ photos and videos (comment, add 
notes, favorite)
Figure A-1. Direct delegation. The resource owner delegates privileges to the client 
application
Snapfish can now access your Flickr account on your behalf with the delegated 
privileges. This model is called direct delegation: the delegator directly delegates a subset 
of his or her privileges to a delegate. The other model is called indirect delegation: the 
delegator first delegates to an intermediate delegate, and that delegate delegates to 
another delegate. This is also known as brokered delegation (see Figure A-2).
Appendix A  The evoluTion of idenTiTy delegATion
323
Let’s say you have a Lucidchart account. Lucidchart is a cloud-based design tool 
that you can use to draw a wide variety of diagrams. It also integrates with Google Drive. 
From your Lucidchart account, you have the option to publish completed diagrams to 
your Google Drive. To do that, Lucidchart needs privileges to access the Google Drive 
API on your behalf, and you need to delegate the relevant permissions to Lucidchart. 
If you want to print something from Lucidchart, it invokes the Snapfish printing 
API. Snapfish needs to access the diagrams stored in your Google Drive. Lucidchart has 
to delegate a subset of the permissions you delegated to it to Snapfish. Even though you 
granted read/write permissions to Lucidchart, it only has to delegate read permission to 
Snapfish to access your Google Drive and print the selected drawings.
 The Evolution
The modern history of identity delegation can be divided into two eras: pre-2006 and 
post-2006. Credential sharing mostly drove identity delegation prior to 2006. Twitter, 
SlideShare, and almost all the web applications used credential sharing to access third-
party APIs. As shown in Figure A-3, when you created a Twitter account prior to 2006, 
Twitter asked for your email account credentials so it could access your email address 
book and invite your friends to join Twitter. Interestingly, it displayed the message “We 
don’t store your login, your password is submitted securely, and we don’t email without 
your permission” to win user confidence. But who knows—if Twitter wanted to read all 
your emails or do whatever it wanted to your email account, it could have done so quite 
easily.
Figure A-2. Brokered delegation. The resource owner delegates privileges to an 
intermediate application and that application delegates privileges to another 
application
Appendix A  The evoluTion of idenTiTy delegATion
324
SlideShare did the same thing. SlideShare is a cloud-based service for hosting and 
sharing slides. Prior to 2006, if you wanted to publish a slide deck from SlideShare to a 
Blogger blog, you had to give your Blogger username and password to SlideShare, as 
shown in Figure A-4. SlideShare used Blogger credentials to access its API to post the 
selected slide deck to your blog. If SlideShare had wanted to, it could have modified 
published blog posts, removed them, and so on.
Figure A-3. Twitter, pre-2006
Figure A-4. SlideShare, pre-2006
Appendix A  The evoluTion of idenTiTy delegATion
325
These are just two examples. The pre-2006 era was full of such applications. Google 
Calendar, introduced in April 2006, followed a similar approach. Any third-party 
application that wanted to create an event in your Google Calendar first had to request 
your Google credentials and use them to access the Google Calendar API. This wasn’t 
tolerable in the Internet community, and Google was pushed to invent a new and, of 
course, better way of securing its APIs. Google AuthSub was introduced toward the end 
of 2006 as a result. This was the start of the post-2006 era of identity delegation.
 Google ClientLogin
In the very early stages of its deployment, the Google Data API was secured with two 
nonstandard security protocols: ClientLogin and AuthSub. ClientLogin was intended 
to be used by installed applications. An installed application can vary from a simple 
desktop application to a mobile application—but it can’t be a web application. For web 
applications, the recommended way was to use AuthSub.
Note The complete google Clientlogin documentation is available at https://
developers.google.com/accounts/docs/AuthForInstalledApps. The 
Clientlogin Api was deprecated as of April 20, 2012. According to the google 
deprecation policy, it operated the same until April 20, 2015.
As shown in Figure A-5, Google ClientLogin uses identity delegation with password 
sharing. The user has to share his Google credentials with the installed application in the 
first step. Then the installed application creates a request token out of the credentials, 
and it calls the Google Accounts Authorization service. After the validation, a CAPTCHA 
challenge is sent back as the response. The user must respond to the CAPTCHA and 
is validated again against the Google Accounts Authorization service. Once the user is 
validated successfully, a token is issued to the application. Then the application can use 
the token to access Google services.
Appendix A  The evoluTion of idenTiTy delegATion
326
 Google AuthSub
Google AuthSub was the recommended authentication protocol to access Google 
APIs via web applications in the post-2006 era. Unlike ClientLogin, AuthSub doesn’t 
require credential sharing. Users don’t need to provide credentials for a third-party web 
application—instead, they provide credentials directly to Google, and Google shares a 
temporary token with a limited set of privileges with the third-party web application. 
The third-party application uses the temporary token to access Google APIs. Figure A-6 
explains the protocol flow in detail.
Figure A-5. Google ClientLogin
Figure A-6. Google AuthSub
Appendix A  The evoluTion of idenTiTy delegATion
327
The end user initiates the protocol flow by visiting the web application. The web 
application redirects the user to the Google Accounts Authorization service with 
an AuthSub request. Google notifies the user of the access rights (or the privileges) 
requested by the application, and the user can approve the request by login. Once 
approved by the user, Google Accounts Authorization service provides a temporary 
token to the web application. Now the web application can use that temporary token to 
access Google APIs.
Note The complete google AuthSub documentation is available at https://
developers.google.com/accounts/docs/AuthSub. how to use AuthSub 
with the google data Api is explained at https://developers.google.com/
gdata/docs/auth/authsub. The AuthSub Api was deprecated as of April 20, 
2012. According to the google deprecation policy, it operated the same until April 
20, 2015.
 Flickr Authentication API
Flickr is a popular image/video hosting service owned by Yahoo!. Flickr was launched in 
2004 (before the acquisition by Yahoo! in 2005), and toward 2005 it exposed its services 
via a public API. It was one of the very few companies at that time that had a public API; 
this was even before the Google Calendar API. Flickr was one of the very few applications 
that followed an identity delegation model without credential sharing prior to 2006. 
Most of the implementations that came after that were highly influenced by the Flickr 
Authentication API. Unlike in Google AuthSub or ClientLogin, the Flickr model was 
signature based. Each request should be signed by the application from its application 
secret.
 Yahoo! Browser–Based Authentication (BBAuth)
Yahoo! BBAuth was launched in September 2006 as a generic way of granting third-party 
applications access to Yahoo! data with a limited set of privileges. Yahoo! Photos and 
Yahoo! Mail were the first two services to support BBAuth. BBAuth, like Google AuthSub, 
borrowed the same concept used in Flickr (see Figure A-7).
Appendix A  The evoluTion of idenTiTy delegATion
328
The user first initiates the flow by visiting the third-party web application. The web 
application redirects the user to Yahoo!, where the user has to log in and approve the 
access request from the third-party application. Once approved by the user, Yahoo! 
redirects the user to the web application with a temporary token. Now the third-party 
web application can use the temporary token to access user’s data in Yahoo! with limited 
privileges.
Note The complete guide to yahoo! BBAuth is available at  http://developer.
yahoo.com/bbauth/.
 OAuth
Google AuthSub, Yahoo! BBAuth, and Flickr Authentication all made considerable 
contributions to initiate a dialog to build a common standardized delegation model. 
OAuth 1.0 was the first step toward identity delegation standardization. The roots of 
OAuth go back to November 2006, when Blaine Cook started developing an OpenID 
implementation for Twitter. In parallel, Larry Halff of Magnolia (a social bookmarking 
site) was thinking about integrating an authorization model with OpenID (around this 
time, OpenID began gaining more traction in the Web 2.0 community). Larry started 
discussing the use of OpenID for Magnolia with Twitter and found out there is no way to 
delegate access to Twitter APIs through OpenID. Blaine and Larry, together with Chris 
Messina, DeWitt Clinton, and Eran Hammer, started a discussion group in April 2007 to 
Figure A-7. Yahoo! BBAuth
Appendix A  The evoluTion of idenTiTy delegATion
329
build a standardized access delegation protocol—which later became OAuth. The access 
delegation model proposed in OAuth 1.0 wasn’t drastically different from what Google, 
Yahoo!, and Flickr already had.
Note openid is a standard developed by the openid foundation for decentralized 
single sign-on. The openid 2.0 final specification is available at http://openid.
net/specs/openid-authentication-2_0.html.
The OAuth 1.0 core specification was released in December 2007. Later, in 2008, 
during the 73rd Internet Engineering Task Force (IETF) meeting, a decision was made 
to develop OAuth under the IETF. It took some time to be established in the IETF, and 
OAuth 1.0a was released as a community specification in June 2009 to fix a security issue 
related to a session fixation attack.1 In April 2010, OAuth 1.0 was released as RFC 5849 
under the IETF.
Note The oAuth 1.0 community specification is available at http://oauth.
net/core/1.0/, and oAuth 1.0a is at http://oauth.net/core/1.0a/. 
Appendix B explains oAuth 1.0 in detail.
In November 2009, during the Internet Identity Workshop (IIW), Dick Hardt of 
Microsoft, Brian Eaton of Google, and Allen Tom of Yahoo! presented a new draft 
specification for access delegation. It was called Web Resource Authorization Profiles 
(WRAP), and it was built on top of the OAuth 1.0 model to address some of its 
limitations. In December 2009, WRAP was deprecated in favor of OAuth 2.0.
Note The WRAp specification contributed to the ieTf oAuth working group is 
available at http://tools.ietf.org/html/draft-hardt-oauth-01.
While OAuth was being developed under the OAuth community and the IETF 
working group, the OpenID community also began to discuss a model to integrate OAuth 
with OpenID. This effort, initiated in 2009, was called OpenID/OAuth hybrid extension 
1 Session fixation, www.owasp.org/index.php/Session_fixation
Appendix A  The evoluTion of idenTiTy delegATion
330
(see Figure A-8). This extension describes how to embed an OAuth approval request 
into an OpenID authentication request to allow combined user approval. For security 
reasons, the OAuth access token isn’t returned in the OpenID authentication response. 
Instead, a mechanism to obtain the access token is provided.
Note The finalized specification for openid/oAuth extension is available at 
http://step2.googlecode.com/svn/spec/openid_oauth_extension/
latest/openid_oauth_extension.html.
Figure A-8. The evolution of identity protocols from OpenID to OpenID Connect
OAuth 1.0 provided a good foundation for access delegation. However, criticism 
arose against OAuth 1.0, mainly targeting its usability and extensibility. As a result, 
OAuth 2.0 was developed as an authorization framework, rather than a standard 
protocol. OAuth 2.0 became the RFC 6749 in October 2012 under the IETF.
Appendix A  The evoluTion of idenTiTy delegATion
331
© Prabath Siriwardena 2020 
P. Siriwardena, Advanced API Security, https://doi.org/10.1007/978-1-4842-2050-4_17
APPENDIX B
OAuth 1.0
OAuth 1.0 was the first step toward the standardization of identity delegation. OAuth 
involves three parties in an identity delegation transaction. The delegator, also known as 
the user, assigns access to his or her resources to a third party. The delegate, also known 
as the consumer, accesses a resource on behalf of its user. The application that hosts the 
actual resource is known as the service provider. This terminology was introduced in the 
first release of the OAuth 1.0 specification under oauth.net. It changed a bit when the 
OAuth specification was brought into the IETF working group. In OAuth 1.0, RFC 5849, 
the user (delegator) is known as the resource owner, the consumer (delegate) is known as 
the client, and the service provider is known as the server.
Note The OAuth 1.0 community specification is available at http://oauth.
net/core/1.0/, and OAuth 1.0a is at http://oauth.net/core/1.0a/. 
OAuth 1.0, RFC 5849, made OAuth 1.0 (community version) and 1.0a obsolete.  
RFC 5849 is available at http://tools.ietf.org/html/rfc5849.
 The Token Dance
Token-based authentication goes back to 1994, when the Mosaic Netscape 0.9 beta 
version added support for cookies. For the first time, cookies were used to identify 
whether the same user was revisiting a given web site. Even though it’s not a strong 
form of authentication, this was the first time in history that a cookie was used for 
identification. Later, most browsers added support for cookies and started using them as 
a form of authentication. To log in to a web site, the user gives his or her username and 
password. Once the user is successfully authenticated, the web server creates a session 
for that user, and the session identifier is written into a cookie. To reuse the already 
332
authenticated session for each request from then onward, the user must attach the 
cookie. This is the most widely used form of token-based authentication.
Note RFC 6265 defines the cookie specification in the context of HTTP:  
see http://tools.ietf.org/html/rfc6265.
Figure B-1. OAuth 1.0 token dance
Token: A unique identifier issued by the server and used by the client to 
associate authenticated requests with the resource owner whose authoriza-
tion is requested or has been obtained by the client. Tokens have a matching 
shared-secret that is used by the client to establish its ownership of the token, 
and its authority to represent the resource owner.
—OAuth 1.0 RFC 5849
APPendix B  OAuTH 1.0
333
This appendix helps you digest the formal definition given for token by RFC 5849. 
OAuth uses tokens at different phases in its protocol flow (see Figure B-1). Three main 
phases are defined in the OAuth 1.0 handshake: the temporary-credential request phase, 
the resource-owner authorization phase, and the token-credential request phase.
Note All three phases in the OAuth 1.0 token dance must happen over Transport 
Layer Security (TLS). These are bearer tokens, so anyone who steals them can use 
them. A bearer token is like cash. if you steal 10 bucks from someone, you can still 
use it at a Starbucks to buy a coffee, and the cashier will not question whether you 
own or how you earned that 10 bucks.
 Temporary-Credential Request Phase
During the temporary-credential request phase, the OAuth client sends an HTTP POST to 
the temporary-credential request endpoint hosted in the resource server:
POST /oauth/request-token HTTP/1.1
Host: server.com
Authorization: OAuth realm="simple",
oauth_consumer_key="dsdsddDdsdsds",
oauth_signature_method="HMAC-SHA1",
oauth_callback="http://client.net/client_cb",
oauth_signature="dsDSdsdsdsdddsdsdsd"
The authorization header in the request is constructed with the following 
parameters:
• 
OAuth: The keyword used to identify the type of the authorization 
header. It must have the value OAuth.
• 
realm: An identifier known to the resource server. Looking at the 
realm value, the resource server can find out how to authenticate the 
OAuth client. The value of realm here serves the same purpose as in 
HTTP Basic authentication, which we discuss in Appendix F.
APPendix B  OAuTH 1.0
334
• 
oauth_consumer_key: A unique identifier issued to the OAuth client 
by the resource server. This key is associated with a secret key that is 
known both to the client and to the resource server.
• 
oauth_signature_method: The method used to generate the 
oauth_signature. This can be PLAINTEXT, HMAC-SHA1, or RSA-SHA1. 
PLAINTEXT means no signature, HMAC-SHA1 means a shared key has 
been used for the signature, and RSA-SHA1 means an RSA private key 
has been used for the signature. The OAuth specification doesn’t 
mandate any signature method. The resource server can enforce any 
signature method, based on its requirements.
• 
oauth_signature: The signature, which is calculated according to the 
method defined in oauth_signature_method.
Note With PLAINTEXT as the oauth_signature_method, the 
oauth_signature is the consumer secret followed by &. For example, if 
the consumer secret associated with the corresponding consumer_key 
is Ddedkljlj878dskjds, then the value of oauth_signature is 
Ddedkljlj878dskjds&.
• 
oauth_callback: An absolute URI that is under the control of the 
client. In the next phase, once the resource owner has authorized the 
access request, the resource server has to redirect the resource owner 
back to the oauth_callback URI. If this is preestablished between the 
client and the resource server, the value of oauth_callback should be 
set to oob to indicate that it is out of band.
The temporary-credential request authenticates the client. The client must be a 
registered entity at the resource server. The client registration process is outside the 
scope of the OAuth specification. The temporary-credential request is a direct HTTP 
POST from the client to the resource server, and the user isn’t aware of this phase. The 
client gets the following in response to the temporary-credential request. Both the 
temporary-credential request and the response must be over TLS:
APPendix B  OAuTH 1.0
335
HTTP/1.1 200 OK
Content-Type: application/x-www-form-urlencoded
oauth_token=bhgdjgdds&
oauth_token_secret=dsdasdasdse&
oauth_callback_confirmed=true
Let’s examine the definition of each parameter:
• 
oauth_token: An identifier generated by the resource server. This 
is used to identify the value of the oauth_token_secret in future 
requests made by the client to the resource server. This identifier 
links the oauth_token_secret to the oauth_consumer_key.
• 
oauth_token_secret: A shared secret generated by the resource 
server. The client will use this in the future requests to generate the 
oauth_signature.