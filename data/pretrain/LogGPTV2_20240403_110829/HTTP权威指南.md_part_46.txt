版本1：
Set-Cookie2: Part="Rocket_Launcher_0001"; Version="1"
Comment 可选。这个属性说明了服务器准备如何使用这个cookie。用户可以通过检查
此策略来确定是否允许使用带有这个cookie的会话。这个值必须采用UTF-8
编码
CommentURL 可选。这个属性提供了一个URL指针，指向详细描述了cookie目的及策略的
文档。用户可以通过查看此策略来判定是否允许使用带有这个cookie的会话
Discard 可选。如果提供了这个属性，就会在客户端程序终止时，指示客户端放弃这
个cookie
Domain 可选。浏览器只向指定域中的服务器主机名发送cookie。这样服务器就可
以将cookie限制在特定域中了。acme.com域与主机名 anvil.acme.com和
shipping.crate.acme.com相匹配，但不匹配于www.cnn.com。域名匹配的规则
基本上与Netscape cookie一样，但有几条附加的规则。细节请参见RFC 2965
286 ｜ 第11章
（续）
Set-Cookie2属性 描述及实例
Max-Age 可选。这个属性的值是一个整数，用于设置以秒为单位的cookie生存期。客
户端应该根据HTTP/1.1的使用期计算规则来计算cookie的使用期。cookie
的使用期比Max-Age大时，客户端就应该将这个cookie丢弃。值为零说明
应该立即将那个cookie丢弃
Path 可选。通过这个属性可以为服务器上的特定文档指定cookie。如果Path属性
是一个URL路径的前缀，就可以附加一个cookie。路径/foo匹配于/foobar
和 /foo/bar.html。路径“/”匹配于域中所有内容。如果没有指定路径，就将
其设置为生成Set-Cookie响应的URL的路径
Port 可选。这个属性可以单独作为关键字使用，也可以包含一个由逗号分隔的、
可以应用cookie的端口列表。如果有端口列表，就只能向端口与列表中的端
口相匹配的服务器提供cookie。如果单独提供关键字Port而没有值，就只
能向当前响应服务器的端口号提供cookie：
Set-Cookie2: foo="bar"; Version="1";
Port="80,81,8080"
Set-Cookie2: foo="bar"; Version="1"; Port
Secure 可选。如果包含这个属性，就只有在HTTP使用SSL安全连接时才能发送
cookie
271
2. 版本1的Cookie首部
版本1的cookie会带回与传送的每个cookie相关的附加信息，用来描述每个cookie
途径的过滤器。每个匹配的cookie都必须包含来自相应Set-Cookie2首部的所有
Domain、Port或Path属性。
比如，假设客户端以前曾收到下列五个来自Web站点www.joes-hardware.com的
Set-Cookie2响应：
Set-Cookie2: ID="29046"; Domain=".joes-hardware.com"
Set-Cookie2: color=blue
Set-Cookie2: support-pref="L2"; Domain="customer-care.joes-hardware.
com"
Set-Cookie2: Coupon="hammer027"; Version="1"; Path="/tools"
Set-Cookie2: Coupon="handvac103"; Version="1"; Path="/tools/cordless"
如果客户端对路径/tools/cordless/specials.html又发起了一次请求，就会同时发送这
样一个很长的Cookie首部：
Cookie: $Version="1";
ID="29046"; $Domain=".joes-hardware.com";
color="blue";
Coupon="hammer027"; $Path="/tools";
Coupon="handvac103"; $Path="/tools/cordless"
客户端识别与cookie机制 ｜ 287
注意，所有匹配cookie都是和它们的Set-Cookie2过滤器一同传输的，而且保留
关键字都是以美元符号（$）开头的。
3. 版本1的Cookie2首部和版本协商
Cookie2请求首部负责在能够理解不同cookie规范版本的客户端和服务器之间进行
互操作性的协商。Cookie2首部告知服务器，用户Agent代理理解新形式的cookie，
并提供了所支持的cookie标准版本（将其称为Cookie-Version更合适一些）：
Cookie2: $Version="1"
如果服务器理解新形式的cookie，就能够识别出Cookie2首部，并在响应首部发送
Set-Cookie2（而不是Set-Cookie）。如果客户端从同一个响应中既获得了Set-
Cookie首部，又获得了Set-Cookie2首部，就会忽略老的Set-Cookie首部。
如果客户端既支持版本0又支持版本1的cookie，但从服务器获得的是版本0的
Set-Cookie首部，就应该带着版本0的Cookie首部发送cookie。但客户端还应
该发送Cookie2: $Version=“1”来告知服务器它是可以升级的。
11.6.8 cookie与会话跟踪
可以用cookie在用户与某个Web站点进行多项事务处理时对用户进行跟踪。电子
商务Web站点用会话cookie在用户浏览时记录下用户的购物车信息。我们以流行
272 的购物网站Amazon.com为例。在浏览器中输入http://www.amazon.com时，就启
动了一个事务链，在这些事务中Web服务器会通过一系列的重定向、URL重写以
及cookie设置来附加标识信息。
图11-5显示了从一次Amazon.com访问中捕获的事务序列。
• 图11-5a——浏览器首次请求Amazon.com根页面。
• 图11-5b——服务器将客户端重定向到一个电子商务软件的URL上。
• 图11-5c——客户端对重定向的URL发起一个请求。
• 图11-5d——服务器在响应上贴上两个会话cookie，并将用户重定向到另一个
URL，这样客户端就会用这些附加的cookie再次发出请求。这个新的URL是个
胖URL，也就是说有些状态嵌入到URL中去了。如果客户端禁止了cookie，只
要用户一直跟随着Amazon.com产生的胖URL链接，不离开网站，仍然可以实
现一些基本的标识功能。
• 图11-5e——客户端请求新的URL，但现在会传送两个附加的cookie。
288 ｜ 第11章
• 图11-5f——服务器重定向到home.html页面，并附加另外两个cookie。
• 图11-5g——客户端获取home.html页面并将所有四个cookie都发送出去。
• 图11-5h——服务器回送内容。
客户端 www.amazon.com
GET / HTTP/1.0 (a)
Host: www.amazon.com
(b) HTTP/1.1 302 Found
Location: http://www.amazon.com:80/exec/obidos/subst/home/redirect.html
GET /exec/obidos/subst/home/redirect.html HTTP/1.0 (c)
Host: www.amazon.com
HTTP/1.1 302 Found
Date: Sun, 02 Dec 2001 03:20:47 GMT
(d) Set-cookie: session-id=002-1145265-8016838; path=/; domain=.amazon.com;
expires=Sunday, 09-Dec-2001 08:00:00 GMT
Set-cookie: session-id-time=1007884800; path=/; domain=.amazon.com;
expires=Sunday, 09-Dec-2001 08:00:00 GMT
GET /exec/obidos/subst/home/redirect.html/002-1145265-8016838 HTTP/1.0
Host: www.amazon.com (e)
Cookie: session-id=002-1145265-8016838; session-id-time=1007884800
HTTP/1.1 302 Found
Date: Sun, 02 Dec 2001 03:45:40 GMT
Set-cookie: ubid-main=430-8248051-6231206; path=/; domain.amazon.com;
(f) expires=Tuesday, 01-Jan-2036 08:00:01 GMT
Location: http://www.amazon.com/exec/obidos/subst/home/home.html/002-1145265-8016838
Set-cookie: x-main="hQ...Bf; path=/; domain=.amazon.com;
expires=Tuesday, 01-Jan-2036 08:00:01 GMT
GET /exec/obidos/subst/home/home.html/002-1145265-8016838 HTTP/1.0
Host: www.amazon.com (g)
Cookie: session-id=002-1145265-8016838; session-id-time=1007884800;
ubid-main=430-8248051-6231206; x-main=hQ...Bf
(h)
图11-5 Amazon.com网站用会话cookie来跟踪用户
客户端识别与cookie机制 ｜ 289
11.6.9 cookie与缓存
缓存那些与cookie事务有关的文档时要特别小心。你不会希望给用户分配一个过去
某些用户用过的cookie，或者更糟糕的是，向一个用户展示其他人私有文档的内容。
cookie和缓存的规则并没有很好地建立起来。下面是处理缓存时的一些指导性规则。
• 如果无法缓存文档，要将其标示出来
文档的所有者最清楚文档是否是不可缓存的。如果文档不可缓存，就显式地注
明——具体来说，如果除了Set-Cookie首部之外文档是可缓存的，就使用
Cache-Control:no-cache="Set-Cookie"。另一种更通用的做法是为可缓存
文档使用Cache-Control:public，这样有助于节省Web中的带宽。
• 缓存Set-Cookie首部时要小心
如果响应中有Set-Cookie首部，就可以对主体进行缓存（除非被告知不要这么
做），但要特别注意对Set-Cookie首部的缓存。如果向多个用户发送了相同的
Set-Cookie首部，可能会破坏用户的定位。
有些缓存在将响应缓存起来之前会删除Set-Cookie首部，但这样也会引发一
273 些问题，因为在没有缓存的时候，通常都会有cookie贴在客户端上，但由缓存
~
274 提供服务的客户端就不会有cookie了。强制缓存与原始服务器重新验证每条请
求，并将返回的所有Set-Cookie首部都合并到客户端的响应中去，就可以改
善这种状况。原始服务器可以通过向缓存的副本中添加这个首部来要求进行这种
再验证：
Cache-Control: must-revalidate, max-age=0
即便内容实际上是可以缓存的，比较保守的缓存可能也会拒绝缓存所有包含
Set-Cookie首部的响应。有些缓存允许使用缓存Set-Cookie图片，但不缓存
文本的模式。
• 小心处理带有Cookie首部的请求
带有Cookie首部的请求到达时，就在提示我们，得到的结果可能是私有的。一
定要将私有内容标识为不可缓存的，但有些服务器可能会犯错，没有将此内容标
记为不可缓存的。
有些响应文档对应于携带Cookie首部的请求，保守的缓存可能会选择不去缓存
这些响应文档。同样，有些缓存允许使用缓存cookie图片，而不缓存文本的模
式。得到更广泛接受的策略是缓存带有Cookie首部的图片，将过期时间设置为
零，强制每次都进行再验证。
290 ｜ 第11章
11.6.10 cookie、安全性和隐私
cookie是可以禁止的，而且可以通过日志分析或其他方式来实现大部分跟踪记录，
所以cookie自身并不是很大的安全隐患。实际上，可以通过提供一个标准的审查方
法在远程数据库中保存个人信息，并将匿名cookie作为键值，来降低客户端到服务
器的敏感数据传送频率。
但是，潜在的滥用情况总是存在的，所以，在处理隐私和用户跟踪信息时，最好还
是要小心一些。第三方Web站点使用持久cookie来跟踪用户就是一种最大的滥用。
将这种做法与IP地址和Referer首部信息结合在一起，这些营销公司就可以构建
起相当精确的用户档案和浏览模式信息。
尽管有这么多负面的宣传，人们通常还是认为，如果能够小心地确认在向谁提供私
人信息，并仔细查阅站点的隐私政策，那么，cookie会话处理和事务处理所带来的
便利性要比大部分风险更重要。
1998年，计算机事故咨询能力组织（Computer Incident Advisory Capability）（美国
能源部的一部分）编写了一份过分使用cookie的风险评估报告。下面是那份报告的
摘要。
CIAC I-034：因特网cookie
（http://www.ciac.org/ciac/bulletins/i-034.shtml）
• 问题
cookie是Web服务器用来识别Web用户的小块数据。关于cookie功能的流行
说法和谣言之间的比例已经达到了令人不解的地步，使用户恐惧，使管理 275
者忧心。
• 脆弱性评估
由于使用Web浏览器cookie使得系统被破坏或窃听，从而带来的系统脆弱
性本质上并不存在。cookie只能告知Web服务器你以前是否到过某个网
站，并在下次访问时将来自Web服务器的一些短小信息（比如用户编码）
回送给它。大部分cookie只会持续到用户退出浏览器为止，然后就会被破
坏掉。第二种名为持久cookie的cookie有一个过期日期，会在你的硬盘上存
储到那个日期为止。无论用户何时返回一个站点，都可以通过持久cookie
来识别其身份，以便跟踪用户的浏览习惯。你来自何处，以及访问过哪些
Web页面等信息已经存储在Web服务器的日志文件中了，也可以用这些信
息来跟踪用户的浏览习惯，只是使用cookie更简单一些罢了。
客户端识别与cookie机制 ｜ 291
11.7 更多信息
这里还有几份有用的资源，介绍了更多与cookie有关的信息。
• Cookies
Simon St.Laurent著，McGraw-Hill公司出版。
• http://www.ietf.org/rfc/rfc2965.txt
RFC 2965，“HTTP State Management Mechanism”（“HTTP状态管理机制”）（废
弃了RFC 2109）。
• http://www.ietf.org/rfc/rfc2964.txt
RFC 2964，“Use of HTTP State Management”（“HTTP状态管理的用途”）。
• http://home.netscape.com/newsref/std/cookie_spec.html
这个经典的网景公司文档“Persistent Client State: HTTP Cookies”（“持久的客户端
276 状态：HTTP Cookies”）描述了现在仍在广泛使用的HTTP cookie的最初形式。
292 ｜ 第11章
第12章
基本认证机制
293
有数百万的人在用Web进行私人事务处理，访问私有的数据。通过Web可以很方便地
访问这些信息，但仅仅是方便访问还是不够的。我们要保证只有特定的人能看到我们
的敏感信息并且能够执行我们的特权事务。并不是所有的信息都能够公开发布的。
未授权用户无法查看我们的在线旅游档案，也不能在未经许可的情况下向Web站点
发布文档，这会让我们感觉舒服一些。我们还要确保，组织中未经授权或不怀好意