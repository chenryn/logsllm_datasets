# 【缺陷周话】第22期：错误的内存释放对象

##### 译文声明
本文为翻译文章，译文仅供参考。具体内容和含义请以原文为准。

## 1. 错误的内存释放对象

C/C++ 程序中的内存分配方式有三种：
1. **静态存储区域分配**：主要存放全局变量和 `static` 变量。这部分内存在程序编译时已经分配，并且在整个运行期间不会被回收。
2. **栈上分配**：由编译器自动分配，用于存放函数的参数值、局部变量等。这些存储单元在函数执行结束时自动释放。需要注意的是，`alloca()` 函数也是向栈申请内存的。
3. **堆上分配**：即动态分配的内存，这种内存需要程序员手动释放。

在这三种情况中，只有第三种（堆上分配）需要程序员手动释放内存。如果对第一种或第二种非动态分配的内存进行释放，会导致“错误的内存释放对象”问题。

本篇文章将分析错误的内存释放对象产生的原因及修复方法。详细信息请参见 CWE-590: Free of Memory not on the Heap (3.2)。

## 2. 错误的内存释放对象的危害

通过对错误的内存释放对象原理的分析，释放非动态分配的内存会导致程序的内存数据结构损坏，从而导致程序崩溃或拒绝服务攻击。在某些情况下，攻击者可以利用这个漏洞修改关键程序变量或执行恶意代码。

CVE 中也有一些与之相关的漏洞信息。从 2018 年 1 月到 2019 年 2 月，CVE 中记录了 9 条相关漏洞信息。以下是部分示例：

| CVE 编号 | 概述 |
| --- | --- |
| CVE-2018-7554 | sam2p 0.49.4 之前的版本中，`input-bmp.ci` 文件的 `ReadImage` 函数存在安全漏洞。攻击者可以通过特制的输入利用该漏洞造成拒绝服务（无效释放和段错误）。 |
| CVE-2018-7552 | sam2p 0.49.4 版本中，`mapping.cpp` 文件的 `Mapping::DoubleHash::clear` 函数存在安全漏洞。攻击者可以通过特制的输入利用该漏洞造成拒绝服务（无效释放和段错误）。 |
| CVE-2018-7551 | sam2p 0.49.4 版本中，`minips.cpp` 文件的 `MiniPS::delete0` 函数存在安全漏洞。攻击者可以通过特制的输入利用该漏洞造成拒绝服务（无效释放和段错误）。 |
| CVE-2018-15857 | xkbcommon 0.8.1 之前的版本中，`xkbcomp/ast-build.c` 文件的 `ExprAppendMultiKeysymList` 函数存在无效释放漏洞。本地攻击者可以通过提交特制的 keymap 文件利用该漏洞造成 xkbcommon 解析器崩溃。 |

## 3. 示例代码

示例代码来源于 Samate Juliet Test Suite for C/C++ v1.3 (https://samate.nist.gov/SARD/testsuite.php)，源文件名：`CWE590_Free_Memory_Not_on_Heap__delete_array_char_alloca_01.cpp`。

### 3.1 缺陷代码

在上述示例代码中，第 32 行使用 `alloca()` 函数申请内存，在第 39 行使用 `delete` 进行释放。由于 `alloca()` 函数申请的内存在栈上，无需手动释放，因此存在“错误的内存释放对象”问题。

使用 360 代码卫士对该示例代码进行检测，可以检出“错误的内存释放对象”缺陷，显示等级为高。如图 1 所示：
```
图1：“错误的内存释放对象”的检测示例
```

### 3.2 修复代码

在修复后的代码中，Samate 给出的修复方式是：在第 33 行通过 `new[]` 动态分配内存，并在第 40 行使用 `delete[]` 进行释放，从而避免了错误的内存释放对象。

使用 360 代码卫士对修复后的代码进行检测，可以看到已不存在“错误的内存释放对象”缺陷。如图 2 所示：
```
图2：修复后检测结果
```

## 4. 如何避免错误的内存释放对象

要避免错误的内存释放对象，需要注意以下几点：
1. **不要对非动态分配的内存进行手动释放**；
2. **当程序结构复杂时（如条件分支较多），进行释放时需要确认释放的内存是否只来自于动态分配**；
3. **明确一些函数的实现**，例如 `alloca()` 申请的内存在栈上，避免由于不清楚函数实现导致错误的内存释放；
4. **`realloc()` 函数的原型为 `void* realloc(void* ptr, size_t size)`**，其中第一个参数 `ptr` 是指向一个要重新分配内存的内存块的指针，该内存块是通过调用 `malloc`、`calloc` 或 `realloc` 进行分配的。如果向 `realloc()` 提供一个指向非动态内存分配函数分配的指针时，也会导致程序未定义行为，在使用时也需要额外注意。