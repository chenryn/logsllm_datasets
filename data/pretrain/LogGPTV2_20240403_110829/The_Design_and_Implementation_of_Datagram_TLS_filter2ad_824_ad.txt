since the handshake layer expects messages to be deliv-
ered in order.
Retransmit Timer Our implementation uses a timer
value of 750ms, which is more than sufﬁcient given that
our experiments were run on a LAN. When using block-
ing sockets, the timeout (set via setsockopt()) causes
recv() to return with an explicit timeout error if data is
not received during the time period. While we chose a
value suitable to our environment, our DTLS API allows
applications to set their own read and write timeout val-
ues.
Sockets that run in non-blocking mode cause DTLS to
return either SSL_ERROR_WANT_READ or
SSL_ERROR_WANT_WRITE which
effectively
are
equivalent to EAGAIN, signalling that data was not im-
mediately available for reading or writing (this is the same
behavior as the TLS API). Non-blocking DTLS appli-
cations are required to call DTLS1_get_timeout()
to determine when the next DTLS I/O call should be
invoked and use their own timers to arrange for the call at
that time.
7. Programmer Experience
The DTLS API is very similar to the API provided by
OpenSSL for operating TLS connections. The only ad-
ditional calls provided by DTLS are related to datagram
transport: setting and getting PMTU, timer values and
datagram socket connection options. For testing purposes,
we ported the s_server and s_client programs that
are part of the OpenSSL distribution to use DTLS. Almost
all the effort required to port these applications to DTLS
was concentrated on making them UDP-capable.
At a high level, one can take an ordinary UDP ap-
plication and render it DTLS-capable by simply replac-
ing all calls to send() and recv() with calls to
SSL_write() and SSL_read(), the default I/O calls
of the OpenSSL library. As with OpenSSL’s ordinary be-
havior, the ﬁrst call to the read or write functions attempts
to negotiate a DTLS connection. This simple approach
works well for applications which use a blocking I/O dis-
cipline but does not work well for those which want to op-
erate in non-blocking mode. Thus, applications that wish
to have a more complicated I/O control discipline need to
either use threads or non-blocking mode.
Thread-based I/O discipline
In case of threaded appli-
cations, calls to the DTLS library are blocking, and the
library is fully responsible for handling timer expiry and
dispatching retransmits. Thus, the application can essen-
tially be oblivious to DTLS being in use, provided that it
uses a separate thread for each DTLS “connection.”
One consequence of protocol logic being abstracted
from applications is a slight break from blocking-socket
convention.
In the case of blocking datagram sockets,
recv() either returns -1 on error, or a non-zero number
of bytes read. However, SSL_read() can return 0. This
happens when the data available on the incoming socket
is not application data, but control information, an Alert
message for example. This behavior of SSL_read() in-
terface is not speciﬁc to DTLS. The TLS programmer has
a similar experience when using OpenSSL.
Non-blocking I/O discipline When DTLS is used in
the context of a non-blocking event driven application,
the application needs to be prepared for timeouts dur-
ing handshake processing. Effectively, any I/O call to
DTLS can return with SSL_ERROR_WANT_READ or
SSL_ERROR_WANT_WRITE, signalling that an I/O op-
eration blocked. An application receiving such an error
needs to determine the current DTLS timeout by calling
DTLS1_get_timeout() and restart the I/O call when
the timer expires. Once the handshake is complete, DTLS
returns a value of 0 for the timer, signalling that it does
not have any pending I/O events. For simplicity, applica-
tions may choose to call DTLS1_get_timeout() re-
gardless of whether the handshake is in progress.
8. Experiments and Results
Our
results from comparing network trafﬁc gen-
erated by TLS and DTLS are listed in Tables 1
and 2.
The cipher negotiated in these tests was
EDH-RSA-DES-CBC3-SHA. This cipher results in a to-
tal of 10 records being exchanged between client and
server for TLS. The DTLS negotiation had at least two
more records due to the cookie exchange phase and the
rest due to message fragmentation.
Each DTLS handshake message fragment has 25 bytes
of overhead from headers (13 for record header and 12 for
message fragment), compared to 9 bytes for TLS. In all,
the headers contribute to most of the overhead in DTLS
(the remainder comes from the the extra padding block
required by CBC with explicit IV). Even though the over-
head for DTLS is close to 35%, the actual size of the over-
head is quite small, since even exchanges with large cer-
tiﬁcates generate less than 3 KB of data. It should also
be noted that the results provided are only for the hand-
shake phase; overhead for data records is lower due to the
absence of the fragment header.
DTLS
Packets Bytes
446
1015
1461
3
3
6
TLS
Packets Bytes
228
857
1085
2
2
4
Client
Server
Total
Table 1. Bytes and Packets transferred with PMTU
1500, Certiﬁcate size 562 bytes
DTLS
Packets Bytes
446
2313
2759
3
4
7
TLS
Packets Bytes
228
2105
2333
2
3
5
Client
Server
Total
easier to incorporate DTLS into an application since the
DTLS implementation can simply be delivered with the
application. This ease of deployment is to a great extent
responsible for the wide use of TLS.
Second, DTLS uses the familiar TLS programming
model in which security contexts are application con-
trolled and have a one-to-one relationship with communi-
cation channels. By contrast, there is no standard IPsec
API or programming model and the widely deployed
IPsec implementations are all extremely difﬁcult to pro-
gram to. As previously noted, this is primarily a result of
the fact that the IPsec key management model is extremely
complex compared to that of TLS.
9.2. WTLS
There has been at least one previous attempt to add data-
gram capability to TLS: the Wireless Application Protocol
Forum’s WTLS [11]. However, WTLS made a large num-
ber of other changes, including integrating network trans-
port with the security protocol, thus making it unsuitable
for deployment on the Internet. In addition, WTLS does
not appear to handle small path MTUs. Finally, the WTLS
designers appear to have made a number of optimizations
that lead to security ﬂaws not in TLS [27] and is therefore
not widely used.
Table 2. Bytes and Packets transferred with PMTU
1500, Certiﬁcate size 1671 bytes
9.3. SRTP
8.1. Latency
We measured latency of the TLS and DTLS handshakes
on a local machine. DTLS and TLS handshakes took
42.9 ms and 41.5 ms respectively. The difference between
these results is small due to the negligible RTT. In order
to differentiate the two protocols, we introduced a 150 ms
delay element, after which the DTLS handshake took 927
ms and the TLS handshake took 627 ms. This is exactly
as expected, since DTLS results include one extra RTT for
cookie exchange. Our measurements do not include the
time taken for TCP connection establishment. Since ses-
sion establishment requires a minimum of one RTT, this
virtually eliminates the latency difference.
9. Related Work
9.1. IPsec
The design of DTLS is probably closest to that of IPsec.
A number of the techniques that we used to make DTLS
records safe for datagram transport were borrowed from
IPsec. However, DTLS differs from IPsec in two impor-
tant respects. First, DTLS is an application layer proto-
col rather than a network layer protocol. Thus, it is far
The Real Time Protocol (RTP) is widely used to carry
multimedia trafﬁc such as voice and video. RTP has
no support for security. The IETF is currently consid-
ering standardization of the Secure Real Time Protocol
(SRTP) [3] which is an application-speciﬁc security pro-
tocol for RTP. SRTP is substantially more limited than
DTLS. First, it cannot be used to protect trafﬁc other than
RTP. Second, it relies on an external signaling protocol
such as SIP to set up the keying material. By contrast,
DTLS can be used to set up its own channel. However, in
extremely bandwidth constrained applications SRTP has
advantages over DTLS because its tight integration with
RTP allows it to have lower network overhead. In situa-
tions where bandwidth is less limited DTLS would be a
potential substitute for SRTP.
10. Future Work
Future work on TLS focuses mostly on integration with
other protocols. Currently, we have an implementation of
DTLS at the early toolkit stage. Our next step is to inte-
grate it with some common datagram-based applications,
which will give us feedback as to the suitability of our de-
sign. Our initial target is SIP. Since SIP already uses TLS
in TCP mode, integrating DTLS in UDP mode is an attrac-
tive design choice and open source SIP implementations
are readily available. Following SIP, we are considering
integrating DTLS with a number of gaming and multime-
dia protocols. Moreover, integrating DTLS with a variety
of other protocols will give us an opportunity to observe
its performance behavior and make changes as appropri-
ate.
We would also like to perform additional performance
tuning on DTLS. Although TLS works well, subsequent
performance analysis has uncovered some unfortunate
interactions with TCP, especially with the Nagle algo-
rithm [24]. As DTLS allows ﬁner control of timers and
record sizes, it is worth doing additional analysis to deter-
mine the optimal values and backoff strategies. Finally,
we intend to do further analysis in an attempt to more
tightly deﬁne the security bounds of DTLS.
11. Summary
We have described Datagram Transport Layer Security,
a generic channel security protocol designed for use in
datagram environments. DTLS is based on the well under-
stood TLS protocol and like TLS is designed to provide a
secure channel that mimics the semantics expected by ex-
isting application protocols. Due to simplicity and ease of
deployment, DTLS provides an attractive alternative to IP
security or custom application layer protocols. We have
implemented DTLS as part of the popular OpenSSL cryp-
tographic library and ﬁnd that it provides acceptable per-
formance and is relatively easy to program to.
12. Acknowledgements
The authors would like to thank Dan Boneh, Eu-Jin
Goh, Constantine Sapuntzakis, and Hovav Shacham for
discussions and comments on the design of DTLS. Thanks
to the anonymous reviewers for their comments, which
helped us improve the paper. Also thanks to Steve Kent
for feedback that helped clarify many points. Dan Boneh,
Lisa Dusseault, and Eu-Jin Goh provided comments on
the paper.
The ﬁrst author is supported by the NSF.
References
[1] F. Andreasen and B. Foster. Media Gateway Control Pro-
tocol (MGCP). RFC 3435, January 2003.
[2] E. B. Ramsdell. S/MIME Version 3 Message Speciﬁca-
tion. RFC 2633, June 1999.
[3] M. Baugher, D. McGrew, D. Oran, R. Blom,
and K. Norrman.
Transport
Protocol.
E. Carrara, M. Naslund,
The
draft-ietf-avt-srtp-08.txt, May 2003.
Real-time
Secure
[4] D. Boneh and D. Brumley. Remote Timing Attacks are
Practical. Proceedings of the 12th USENIX Security Sym-
posium, August 2003.
[5] B. Canvel, A. Hiltgen, S. Vaudenay, and M. Vuagnoux.
Password Interception in a SSL/TLS Channel. In Proceed-
ings of the Crypto, August 2003.
[6] M. Crispin. Internet Message Access Protocol - Version
4rev1 (IMAP). RFC 3501, March 2003.
[7] T. Dierks and C. Allen. The TLS Protocol, Version 1.0.
RFC 2246, January 1999.
[8] D. Eastlake. Domain Name System Security Extensions
(DNSSEC). RFC 2535, March 1999.
[9] R. Fielding, J. Gettys, J. Mogul, H. Frystyk, L. Masinter,
P. Leach, and T. Berners-Lee. Hypertext Transfer Protocol
(HTTP). RFC 2616, June 1999.
[10] S. Fluhrer, I. Mantin, and A. Shamir. Weaknesses in the
In Proceedings of SAC,
Scheduling Algorithm of RC4.
August 2001.
[11] W. A. P. Forum. WAP WTLS. WAP Forum protocol stan-
dard, November 1999.
[12] D. Harkins and D. Carrel. The Internet Key Exchange
(IKE). RFC 2409, November 1998.
[13] P. Karn and W. Simpson. Photuris: Session-Key Manage-
ment Protocol. RFC 2522, March 1999.
[14] D.
Kegel.
The
C10K
Problem.
http://www.kegel.com/c10k.html.
[15] C. A. Kent and J. C. Mogul. Fragmentation considered
In Proceedings of ACM SIGCOMM, August
harmful.
1987.
[16] S. Kent and R. Atkinson. IP Authentication Header (AH).
RFC 2402, November 1998.
[17] S. Kent and R. Atkinson. IP Encapsulating Security Pay-
load (ESP). RFC 2406, November 1998.
[18] S. Kent and R. Atkinson. Security Architecture for the
Internet Protocol (IPsec). RFC 2401, November 1998.
[19] E. Kohler, M. Handley, S. Floyd,
and J. Pad-
hye. Datagram Congestion Control Protocol (DCCP).
draft-ietf-dccp-spec-04.txt, June 2003.
[20] C. Metz and B. Phan. PF_KEY Key Management API,
Version 2. RFC 2367, May 1998.
[21] I. Mironov. (Not So) Random Shufﬂes of RC4. In Pro-
ceedings of Crypto, August 2002.
[22] J. Mogul and S. Deering. Path MTU Discovery. RFC
1191, November 1990.
[23] J. Myers and M. Rose. Post Ofﬁce Protocol - Version 3
(POP). RFC 1939, May 1996.
[24] J. Nagle. Congestion Control in IP/TCP Internetworks.
RFC 896, January 1984.
[25] E. Rescorla. HTTP Over TLS. RFC 2818, May 2000.
[26] J. Rosenberg, H. Schulzrinne, G. Camarillo, A. Johnston,
J. Peterson, R. Sparks, and M. H. E. Schooler. SIP: Session
Initiation Protocol. RFC 3261, June 2002.
[27] M.-J. O. Saarinen. Attacks against the WAP WTLS proto-
col. CMS 99, 1999.
[28] H. Schulzrinne, S. Casner, R. Frederick, and V. Jacobson.
RTP: A Transport Protocol for Real-Time Applications.
RFC 3550, July 2003.
[29] D. Song, D. Wagner, and X. Tian. Timing Analysis of
Keystrokes and SSH Timing Attacks. Proceedings of the
10th USENIX Security Symposium, August 2001.
[30] The OpenSSL Project. http://www.openssl.org/.
[31] S. Vaudenay. Security Flaws Induced by CBC Padding -
Applications to SSL, IPSEC, WTLS . . . . In Proceedings
of Eurocrypt, April 2002.