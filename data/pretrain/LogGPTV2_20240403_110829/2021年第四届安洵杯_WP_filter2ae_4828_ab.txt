    for i in range(len(res)):
        random.seed(seeds[i])
        rands = []
        for j in range(0,4):
            rands.append(random.randint(0,99))
        dp += chr((~(res[i])|rands[i%4]) & ((res[i])|~rands[i%4]))
        del rands[i%4]
    print(dp)
    dp = int(dp)
    #dp = 23458591381644494879596426183878928641891759871602961070839457303969747353773411708437315165237216481430908369709167907047043280248152040749469402814146054871536032870746473649690743697560576735624528397398691515920649222501258921802372365480019200479555430922883680472732415240714991623845227274793947921407
> 后半段中，每次循环中的`P`、`Q`其实都是已知的，因此很容易可以把`dq`的值计算出来
    from gmpy2 import *
    from Crypto.Util.number import *
    dp = ''
    e = 0x10001
    length_dp = 309
    c = [1, 0, 7789, 1, 17598, 20447, 15475, 23040, 41318, 23644, 53369, 19347, 66418, 5457, 0, 1, 14865, 97631, 6459, 36284, 79023, 1, 157348, 44667, 185701, 116445, 23809, 220877, 0, 1, 222082, 30333, 55446, 207442, 193806, 149389, 173229, 349031, 152205, 1, 149157, 196626, 1, 222532, 10255, 46268, 171536, 0, 351788, 152678, 0, 172225, 109296, 0, 579280, 634746, 1, 668942, 157973, 1, 17884, 662728, 759841, 450490, 0, 139520, 157015, 616114, 199878, 154091, 1, 937462, 675736, 53200, 495985, 307528, 1, 804492, 790322, 463560, 520991, 436782, 762888, 267227, 306436, 1051437, 384380, 505106, 729384, 1261978, 668266, 1258657, 913103, 935600, 1, 1, 401793, 769612, 484861, 1024896, 517254, 638872, 1139995, 700201, 308216, 333502, 0, 0, 401082, 1514640, 667345, 1015119, 636720, 1011683, 795560, 783924, 1269039, 5333, 0, 368271, 1700344, 1, 383167, 7540, 1490472, 1484752, 918665, 312560, 688665, 967404, 922857, 624126, 889856, 1, 848912, 1426397, 1291770, 1669069, 0, 1709762, 130116, 1711413, 1336912, 2080992, 820169, 903313, 515984, 2211283, 684372, 2773063, 391284, 1934269, 107761, 885543, 0, 2551314, 2229565, 1392777, 616280, 1368347, 154512, 1, 1668051, 0, 2453671, 2240909, 2661062, 2880183, 1376799, 0, 2252003, 1, 17666, 1, 2563626, 251045, 1593956, 2215158, 0, 93160, 0, 2463412, 654734, 1, 3341062, 3704395, 3841103, 609968, 2297131, 1942751, 3671207, 1, 1209611, 3163864, 3054774, 1055188, 1, 4284662, 3647599, 247779, 0, 176021, 3478840, 783050, 4613736, 2422927, 280158, 2473573, 2218037, 936624, 2118304, 353989, 3466709, 4737392, 2637048, 4570953, 1473551, 0, 0, 4780148, 3299784, 592717, 538363, 2068893, 814922, 2183138, 2011758, 2296545, 5075424, 1814196, 974225, 669506, 2756080, 5729359, 4599677, 5737886, 3947814, 4852062, 1571349, 4123825, 2319244, 4260764, 1266852, 1, 3739921, 1, 5948390, 1, 2761119, 2203699, 1664472, 3182598, 6269365, 5344900, 454610, 495499, 6407607, 1, 1, 476694, 4339987, 5642199, 1131185, 4092110, 2802555, 0, 5323448, 1103156, 2954018, 1, 1860057, 128891, 2586833, 6636077, 3136169, 1, 3280730, 6970001, 1874791, 48335, 6229468, 6384918, 5412112, 1, 7231540, 7886316, 2501899, 8047283, 2971582, 354078, 401999, 6427168, 4839680, 1, 44050, 3319427, 0, 1, 1452967, 4620879, 5525420, 5295860, 643415, 5594621, 951449, 1996797, 2561796, 6707895, 7072739]
    list_p = sieve_base[0 : length_dp]
    list_q = sieve_base[length_dp : 2 * length_dp]
    for i in range(length_dp):
        p = list_p[i]
        q = list_q[i]
        phi = (p-1) * (q-1)
        d = invert(e, phi)
        dp += str(pow(c[i], d, p*q))
    print(dp)
> 接着利用`dp&dq泄露`就能拿到本题的`FLAG`：`D0g3{Welc0me_t0_iSOON_4nd_have_4_go0d_time}`
    import gmpy2
    import binascii
    def decrypt(dp,dq,p,q,c):
        InvQ = gmpy2.invert(q,p)
        mp = pow(c,dp,p)
        mq = pow(c,dq,q)
        m = (((mp-mq) * InvQ)%p) * q + mq
        print(binascii.unhexlify(hex(m)[2:]))
    p = 119494148343917708105807117614773529196380452025859574123211538859983094108015678321724495609785332508563534950957367289723559468197440246960403054020452985281797756117166991826626612422135797192886041925043855329391156291955066822268279533978514896151007690729926904044407542983781817530576308669792533266431
    q = 125132685086281666800573404868585424815247082213724647473226016452471461555742194042617318063670311290694310562746442372293133509175379170933514423842462487594186286854028887049828613566072663640036114898823281310177406827049478153958964127866484011400391821374773362883518683538899757137598483532099590137741
    dp = 23458591381644494879596426183878928641891759871602961070839457303969747353773411708437315165237216481430908369709167907047043280248152040749469402814146054871536032870746473649690743697560576735624528397398691515920649222501258921802372365480019200479555430922883680472732415240714991623845227274793947921407
    dq = 104137587579880166582178434901328539485184135240660490271571544307637817287517428663992284342411864826922600858353966205614398977234519495034539643954586905495941906386407181383904043194285771983919780892934288899562700746832428876894943676937141813284454381136254907871626581989544814547778881240129496262777
    c = 10238271315477488225331712641083290024488811710093033734535910573493409567056934528110845049143193836706122210303055466145819256893293429223389828252657426030118534127684265261192503406287408932832340938343447997791634435068366383965928991637536875223511277583685579314781547648602666391656306703321971680803977982711407979248979910513665732355859523500729534069909408292024381225192240385351325999798206366949106362537376452662264512012770586451783712626665065161704126536742755054830427864982782030834837388544811172279496657776884209756069056812750476669508640817369423238496930357725842768918791347095504283368032
    decrypt(dp,dq,p,q,c)
###  ez_equation
>
> 先手动化简一波`X`和`Y`之间的等式，接着利用化简后的等式可以快速的得到`primelist[0]`、`primelist[1]`和`primelist[2]`三个值
>
>
> 设`primelist[0]`、`primelist[1]`、`primelist[2]`分别为`x`、`y`、`z`，可以根据约数向上推来得到`x`和`z`的值，测试后发现分数化到最简后同时乘以`6`可得到满足`x`和`z`都为质数的值，再把`x`和`z`带入上面的式子可解出`y`
    x = 117379993488408909213785887974472229016071265566403849836216754847295401565166151872329440545598767396499252325133419296775798211888305050776586647999185549171166433935032159605367762650398185050063643611720499373962310459705000471248897299568458251778545586376091559089442503748421906239117101764062329447353
    z = 124117415943883977664751123530312411127969752596554845224788157371311249476587435058606174560086595402130942432433077285727410486606936603436679072115481556559754023776771158788066029212482977191449912364572356973349619609634451941137428490832382800157920373064845282558903378297473815085357523566726409862651
    y = 131159337350604437097260935337908172871918065922429417087300191526860863483450734104610066096933731192226146030815782379368166939404332806989923180544179939143847199925713737334596232430250079326424892252913440273468860901835188784892049729690676730019241424382610694942610558037299924847740715832061165596221
> 由于`n = reduce(lambda a, b:a * b, primelist) * p *
> q`中`p`和`q`是相邻的质数，直接用`yafu`分解`n // (x * y * z)`的值即可
>
> 得到上述需要的参数值后，就是简单的`rsa`解密，拿到本题的`FLAG`：`D0g3{296b680c-7aeb-5272-8b33-7335b411fbcb}`
    import binascii
    import gmpy2
    from Crypto.Util.number import *
    e = 0x10001
    c = 1394946766416873131554934453357121730676319808212515786127918041980606746238793432614766163520054818740952818682474896886923871330780883504028665380422608364542618561981233050210507202948882989763960702612116316321009210541932155301216511791505114282546592978453573529725958321827768703566503841883490535620591951871638499011781864202874525798224508022092610499899166738864346749753379399602574550324310119667774229645827773608873832795828636770263111832990012205276425559363977526114225540962861740929659841165039419904164961095126757294762709194552018890937638480126740196955840656602020193044969685334441405413154601311657668298101837066325231888411018908300828382192203062405287670490877283269761047853117971492197659115995537837080400730294215778540754482680476723953659085854297184575548489544772248049479632420289954409052781880871933713121875562554234841599323223793407272634167421053493995795570508435905280269774274084603687516219837730100396191746101622725880529896250904142333391598426588238082485305372659584052445556638990497626342509620305749829144158797491411816819447836265318302080212452925144191536031249404138978886262136129250971366841779218675482632242265233134997115987510292911606736878578493796260507458773824689843424248233282828057027197528977864826149756573867022173521177021297886987799897923182290515542397534652789013340264587028424629766689059507844211910072808286250914059983957934670979551428204569782238857331272372035625901349763799005621577332502957693517473861726359829588419409120076625939502382579605
    n = 19445950132976386911852381666731799463510958712950274248183192405937223343228119407660772413067599252710235310402278345391806863116119010697766434743302798644091220730819441599784039955347398797545219314925103529062092963912855489464914723588833817280786158985269401131919618320866942737291915603551320163001129725430205164159721810319128999027215168063922977994735609079166656264150778896809813972275824980250733628895449444386265971986881443278517689428198251426557591256226431727934365277683559038777220498839443423272238231659356498088824520980466482528835994554892785108805290209163646408594682458644235664198690503128767557430026565606308422630014285982847395405342842694189025641950775231191537369161140012412147734635114986068452144499789367187760595537610501700993916441274609074477086105160306134590864545056872161818418667370690945602050639825453927168529154141097668382830717867158189131567590506561475774252148991615602388725559184925467487450078068863876285937273896246520621965096127440332607637290032226601266371916124456122172418136550577512664185685633131801385265781677598863031205194151992390159339130895897510277714768645984660240750580001372772665297920679701044966607241859495087319998825474727920273063120701389749480852403561022063673222963354420556267045325208933815212625081478538158049144348626000996650436898760300563194390820694376019146835381357141426987786643471325943646758131021529659151319632425988111406974492951170237774415667909612730440407365124264956213064305556185423432341935847320496716090528514947
    x = 117379993488408909213785887974472229016071265566403849836216754847295401565166151872329440545598767396499252325133419296775798211888305050776586647999185549171166433935032159605367762650398185050063643611720499373962310459705000471248897299568458251778545586376091559089442503748421906239117101764062329447353
    z = 124117415943883977664751123530312411127969752596554845224788157371311249476587435058606174560086595402130942432433077285727410486606936603436679072115481556559754023776771158788066029212482977191449912364572356973349619609634451941137428490832382800157920373064845282558903378297473815085357523566726409862651
    y = 131159337350604437097260935337908172871918065922429417087300191526860863483450734104610066096933731192226146030815782379368166939404332806989923180544179939143847199925713737334596232430250079326424892252913440273468860901835188784892049729690676730019241424382610694942610558037299924847740715832061165596221
    p = 100879187056056327845688098549406745424207361197423093269692717108477600868962896860013904736765795306101216828969899092854909669522132180587302621989436957151756194757478353967989066938767945991388791271155482274102738851937877875741607885045831857778368069892408823414883083227349949611641923542904479146623
    q = 100879187056056327845688098549406745424207361197423093269692717108477600868962896860013904736765795306101216828969899092854909669522132180587302621989436957151756194757478353967989066938767945991388791271155482274102738851937877875741607885045831857778368069892408823414883083227349949611641923542904479147403
    phi=(p-1)*(q-1)*(x-1)*(y-1)*(z-1)
    d=gmpy2.invert(e,phi)
    m=pow(c,d,n)
    print(long_to_bytes(m)[256:-256])
###  Strange
> 分析加密过程后很容易发现是一个`Stereotyped messages`攻击+`z3`求解的问题
    m1 = m | hint => 由于m的值相比于hint小多了，因此这样得到的是hint的高位
    m2 = m & hint => 得到m的位数
> 因此，可以通过`hint & ((1  ((383  接着利用得到的`hint_high`进行`Stereotyped messages`攻击，利用得到的低位与`hint_high`相加得到`m1`的值
>
> 得到`m1`的值后，利用`z3`约束求解即可得到`m`的值，`long_to_bytes`后得到`FLAG`：`D0g3{R54_f4l1_1n_l0ve_with_CopperSmith_w0wow0!!}`
    from z3 import *
    from Crypto.Util.number import *
    m = BitVec('m', 384)
    s = Solver()
    m1 = 9989639419782222444529129951526723618831672627603783728728767345257941311870269471651907118545783408295856954214259681421943807855554571179619485975143945972545328763519931371552573980829950864711586524281634114102102055299443001677757487698347910133933036008103313525651192020921231290560979831996376634906893793239834172305304964022881699764957699708192080739949462316844091240219351646138447816969994625883377800662643645172691649337353080140418336425506119542396319376821324619330083174008060351210933049560781360717427446713646109570038056138652803756149233612618692820860571507613112565167824369560313209417725
    m2 = 9869907877594701353175281930839281485694004896356038595955883788511764488228640164047958227861871572990960024485992
    hint = 9989639419782222444529129951526723618831672627603783728728767345257941311870269471651907118545783408295856954214259681421943807855554571179619485975143945972545328763519931371552573980829950864711586524281634114102102055299443001677757487698347910133933036008103313525651192020921231290560979831996376634906893793239834172305304964022881699764957699708192080739949462316844091240219351646138447816969994625883377800662643645172691649337353080140418336425506119542396319376821324619330083174008060351210307698279022584862990749963452589922185709026197210591472680780996507882639014068600165049839680108974873361895144
    s.add(m1 == (m | hint))
    s.add(m2 == (m & hint))
    s.check()
    m = s.model()
    print(m)
## Reverse
###  signin
>
> 先打开程序，发现是贪吃蛇，`IDA`跟进`sub_40100F`，发现有个花指令和`SMC`，先把SMC解出来，利用用`od`动态调试，断在`0x419054`，此为加密完成的位置，接着回到`0x401d10`，重新分析代码后，将整个函数选中右键复制到可执行文件
> – 选择，保存到新的文件后即可看到逻辑
>
> 解出来发现这是flag的逻辑：程序先进行了异或，矩阵变换，然后就是一个魔改的类似`TEA`思想的算法，由于`dword_42CA44`未知且小于256
    v5 = dword_42CA44 + 1144219440;
> `v5`虽然是一个`int`数组，但是是从`char`赋值来的，所以可以爆破`dword_42CA44`，只要解出来的结果`
    #include 
    #include 
    #include 
    unsigned char Enc[] = { 0xA5, 0xD8, 0x8E, 0xBF, 0xF9, 0xA9, 0x15, 0xE1, 0x8A, 0xF0,
      0xD3, 0xFC, 0x46, 0x89, 0xBF, 0x8B, 0x62, 0xB1, 0x08, 0xC3,
      0x29, 0xCF, 0x19, 0x2B, 0x56, 0x06, 0x77, 0x7A, 0xBA, 0xE4,
      0xBA, 0xA4, 0xE4, 0x8C, 0x3E, 0x4E, 0xD9, 0xE1, 0xA7, 0x01,
      0x04, 0xCE, 0xE9, 0x75, 0xB9, 0x93, 0xB5, 0x22, 0xB4, 0x42,
      0x77, 0x49, 0xF6, 0x15, 0xEB, 0x24, 0x0E, 0xFF, 0xC2, 0xF2,
      0x39, 0x30, 0x97, 0x47, 0x0D, 0xCA, 0x01, 0xC8, 0x61, 0x58,
      0x12, 0x6A, 0xE8, 0x0B, 0x32, 0x80, 0x47, 0xBD, 0x85, 0x03,
      0xDD, 0x6D, 0xF9, 0x69, 0xD1, 0x90, 0x64, 0xE5, 0x4B, 0xAD,
      0x3C, 0x2D, 0xBE, 0x00, 0x42, 0x2D, 0x79, 0x69, 0xEF, 0x89,
      0x5D, 0x88, 0x91, 0x4A, 0xC7, 0xEB, 0x9D, 0x01, 0x96, 0xFD,
      0xF8, 0x3B, 0x57, 0x25, 0xDD, 0x1B, 0xDD, 0x5F, 0x68, 0xB8,
      0x14, 0x66, 0x22, 0x57, 0x28, 0x5C, 0x58, 0x9F };
    DWORD GetMagic1(int time,int x)
    {
        DWORD magic = 0x44336730 + x;
        DWORD v8 = 0;
        for(int i = 0 ; i> 2) & 3;
    }
    DWORD GetMagic2(int time,int x)
    {
        DWORD magic = 0x44336730 + x;
        DWORD v8 = 0;
        for (int i = 0; i  0; j--) {
                DWORD v8 = GetMagic2(j,x);
                DWORD v6 = GetMagic1(j,x);
                DWORD v9 = a1[30];
                a1[31] -= ((v9 ^ (know[(v6 ^ 31) & 3])) + (*a1 ^ v8)) ^ (((16 * v9) ^ (*a1 >> 3))
                    + ((4 * *a1) ^ (v9 >> 5)));
                for (int i = 30; i >= 0; i--) {
                    if (i == 0) {
                        v9 = a1[31];
                    }
                    else {
                        v9 = a1[i - 1];
                    }
                    a1[i] -= ((v9 ^ (know[(v6 ^ i) & 3])) + (a1[i + 1] ^ v8)) ^ (((16 * v9) ^ (a1[i + 1] >> 3))
                        + ((4 * a1[i + 1]) ^ (v9 >> 5)));
                }
            }
            if(ENC[0]  接着再逆矩阵变换，就可以构造一个`{1,2,3,4,5,6,7,...}`的数组然后进行加密拿到置换表
    int j = 0;
    int i = 0;
    int v1[128] = { 0 };
    char table[32] = { 0 };
    for(int sb = 0;sb= 3)
            v1[32 * (3 - j % 3) + i] = table[i];