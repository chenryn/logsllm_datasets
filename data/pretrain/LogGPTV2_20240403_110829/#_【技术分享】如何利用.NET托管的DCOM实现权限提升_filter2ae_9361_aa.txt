# 【技术分享】如何利用.NET托管的DCOM实现权限提升
|
##### 译文声明
本文是翻译文章，文章来源：googleprojectzero.blogspot.tw
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
****
****
翻译：[ **华为未然实验室**](http://bobao.360.cn/member/contribute?uid=2794169747)
**稿费：160RMB**
投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿
**  
**
**前言**
影响互操作技术的漏洞是一类较为有趣的安全漏洞，这是因为这些漏洞通常会影响使用该技术的任何应用程序，无论应用程序实际执行什么操作。同样，在很多情况下，开发人员难以在不使用该技术的情况下推出缓解措施，但有时候却做不到。
我发现.NET的组件对象模型（COM）互操作性层存在此类漏洞，这使.NET跨权限边界用于分布式COM（DCOM）本质上是不安全的。本文将描述一些可对此进行滥用的方法，首先是获得提升的权限，然后是一个远程代码执行漏洞。
**背景知识**
回顾.NET的历史可以知道，很多其早期基础是试图制作一个更好的COM版本。这使微软很注重确保，虽然.NET本身可能不是COM，但其必须能够与COM互操作。因此，.NET可以用于实现和使用COM对象。比如，不用在COM对象上调用QueryInterface，你只需要将对象投射到兼容COM的接口上。以C#实现进程外COM服务器很简单，如下所示：
客户端现在可使用其CLSID（由COMClass上的Guid属性定义）连接到COM服务器。实际上这很简单，因为.NET中的大量核心类被标记为COM可见，并注册为任何COM客户端（即使未以.NET编写）可用。
为了使这一切都有效，.NET运行时向开发人员隐藏了大量的样板。有几种机制可影响此样板互操作性代码，比如InterfaceType属性，其定义COM接口是源自IUnknown还是IDispatch，但大多数情况下，你得到的是所给予的。
开发人员可能没有意识到的一点是，不仅是您指定的接口从.NET
COM对象导出，运行时还会添加一些“管理”接口。这些接口通过将.NET对象包装在COM可调用包装器（CCW）中来实现。
我们可以枚举CCW所暴露的接口。以System.Object为例，下表展示了支持的接口及每个接口实现的方式（在运行时动态实现或在运行时内部静态实现）。
_Object接口指的是System.Object类的COM可见表示，其是所有.NET对象的根，其必须动态生成，因为其依赖于被暴露的.NET对象。另一方面，IManagedObject由运行时本身实现，且实现在所有CCW中共享。
我从2013年开始关注.NET暴露的COM攻击面，彼时我正在研究IE沙箱逃逸。您可以在沙箱之外访问的COM对象之一是.NET[
ClickOnce部署](https://msdn.microsoft.com/en-us/library/t71a733d\(v=vs.80\).aspx)代理（DFSVC），其原来是以.NET实现，这可能并不足为奇。我实际上发现了两个问题，不是在DFSVC本身，而是在由所有.NET
COM对象暴露的_Object接口。_Object接口如下所示（以C++）。
第一个bug（导致CVE-2014-0257）在于GetType方法。该方法返回一个可用于访问[.NET反射API](https://msdn.microsoft.com/en-us/library/f7ykdhsy\(v=vs.110\).aspx)的COM对象。由于返回的_Type
COM对象正在服务器中运行，所以您可以调用一系列方法，从而可访问Process.Start方法，您可以调用该方法实现沙箱逃逸。如欲了解更多细节，请查看我编写并放在Github上的[PoC](https://github.com/tyranid/IE11SandboxEscapes/blob/master/CVE-2014-0257/CVE-2014-0257.cpp)。微软通过阻止通过DCOM访问反射API解决了此问题。
第二个问题更微妙，是.NET互操作特性（大概没有人认为是安全隐患）的副产品。加载.NET运行时需要相当多的额外资源，因此，对于本机COM客户端调用.NET
COM服务器上的方法，默认是让COM和CCW管理通信，即使这样有损性能。微软可以选择使用COM封送器强制.NET在客户端加载，但这样似乎有点过头，更别说客户端甚至可能没有安装兼容的.NET版本了。
当.NET与COM对象交互时，其会创建反向CCW——[运行时可调用包装器](https://msdn.microsoft.com/en-us/library/8bwh56xe\(v=vs.110\).aspx)（RCW）。这是一个.NET对象，其实现COM接口的运行时版本，并将其编组到COM对象。现在COM对象完全有可能实际上是用.NET编写的，甚至可能在相同的应用程序域中。如果.NET无所作为，可能对性能造成双倍影响，在RCW中编组，以调用一个COM对象，这实际上是一个托管对象的CCW。
尝试从CCW“展开”托管对象并获取一个真正的.NET对象是很好的。这是这段中的淘气鬼使坏的地方，[IManagedObject](https://msdn.microsoft.com/en-us/library/cc233673.aspx)接口，如下所示：
当.NET运行时获得一个COM对象时，其将通过一个过程来确定其是否可以从其CCW“展开”对象，并避免创建一个RCW。该过程被[记录](https://msdn.microsoft.com/en-us/library/cc233722.aspx)，但总而言之，运行时将执行以下操作：
1\. 调用COM对象上的QueryInterface来确定其是否实现IManagedObject接口。如果没有，则返回合适的RCW。
2\. 调用接口上的GetObjectIdentity。如果GUID与每次运行时GUID（在运行时启动时生成）匹配，且AppDomain
ID与当前的AppDomain ID匹配，则在运行时表中查找CCW值，并提取指向真实管理对象的指针并将其返回。
3\. 调用接口上的GetSerializedBuffer。运行时将检查.NET对象是否可序列化，如果可以，则其将对象传递给[BinaryFormatter
:: Serialize](https://msdn.microsoft.com/en-us/library/c5sbs8z9\(v=vs.110\).aspx)，并将结果打包到二进制字符串（BSTR）中。这将返回给客户端，客户端现在将尝试通过调用[BinaryFormatter
:: Deserialize](https://msdn.microsoft.com/en-us/library/b85344hz\(v=vs.110\).aspx)将缓冲区反序列化到对象实例。
第2和3步似乎都是坏主意。比如，在第2步中时，每运行时GUID不能被猜到，如果您可以访问同一进程中的任何其他对象（例如由服务器本身暴露的COM对象），则您可以调用对象上的GetObjectIdentity，并将GUID和AppDomain
ID重播回服务器。这并没有给您带来太多好处，CCW值只是一个数字不是一个指针，所以，你最多能提取已经有CCW的对象。
相反，真正棘手的是第3步。无论什么语言（比如Java、PHP、Ruby，等等），任意反序列化都是危险的，.NET亦不例外。显然这是我们可以利用的一个问题，我们先从权限提升角度看一看。