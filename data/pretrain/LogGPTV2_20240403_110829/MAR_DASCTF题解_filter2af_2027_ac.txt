    from secret import flag
    from gmpy2 import gcd
    def lcg(seed,params):
        (m,c,n)=params
        s = seed % n
        while True:
            s = (m * s + c) % n
            yield s
    seed = getPrime(128)
    m = getPrime(128)
    c = getPrime(128)
    n = getPrime(129)
    print(m,c,n)
    key_stream = lcg(seed,(m,c,n))
    num=[]
    for _ in range(6):
        num.append(next(key_stream))
    print(num)
    secret =  next(key_stream)
    e = nextprime(secret)
    p = getPrime(1024)
    q = getPrime(1024)
    _lambda = ((p-1)*(q-1)) / gcd(p-1,q-1)
    flag = bytes_to_long(flag)
    print(_lambda)
    print(p*q)
    print(pow(flag,e,p*q))
`flag`被`rsa`加密，`e`是由`lcg`生成的，由于我们知道`lcg`的之前的状态，所以可以很容易推出`e`的值
然后我们知道`lcm(n)`，通过比较`n`和`lcm(n)`的比特数可以很容易发现它们相差的很小，那么可以通过爆破`gcd(p-1,q-1)`的方式来分解`n`进而解密得到`flag`
    from sympy import nextprime
    from Crypto.Util.number import *
    import gmpy2
    def lcg(seed,params):
        (m,c,n) = params
        s = seed % n
        while True:
            s = (m * s + c) % n
            yield s
    a = 315926151576125492949520250047736865439
    b = 204423972944032372640132172728460755543
    n = 375402477603617093440157245062608289367
    lcg_output = [345100389799760820174075838471701328893, 354616152072197410104284828964580660629, 262223452907927780613453340112396026524, 36884243358932605284421044617284274488, 293840768243490066897038832083154668562, 287868671713011127830359814204794790287]
    l = lcg(lcg_output[-1],(a,b,n))
    secret = next(l)
    e = nextprime(secret)
    _lambda = 457872764421730558978217109311884057410311335293040789670930865953404030084212226269947268155086034859079522508205099945996505165612539895857134158846470122889806235716457030336629794120415334028017836171608283093853784030348654118118278878881245838363354935523654666907698225985634469947076411404657018958617661794208646954882326918608011132295868155254980231015984288966599987516188265570396237695988003707515471895679008794498548940902202079105268931791776841539932961070351617834137017590635300615537152347169984974533340989459692132455611998382465644967355506104871655788359202461542101480022365857889833055840
    n = 27472365865303833538693026558713043444618680117582447380255851957204241805052733576196836089305162091544771350492305996759790309936752393751428049530788207373388374142987421820197787647224920041681070170296496985631227041820919247087096732732874750301801296131419280014461893559138068196824584684279421137517391204355597563871480257589096606865035259322614687417246708249170470689983675108996118328359454354818425772935513344465778617739729440207409124134831968562495435786944862849412776010947330752600405451073822977981611026975129395818269513358936682934286140359273764118787152676411486767003233858544159511154941
    c = 7187920142528335824861143203876908084067528690298329755497671248322277194754277305701102880967402859593937177306927235921616059382304183094350022713118203435560220591865274025991334717202171313133285253575822615616032441398946742994706880814251670668924098240782583026655923033371628284132606950034409888896558825512875084001031123558055489119898334591442547695833103046341283479780998109787754685881665949269402489768629140076361688313079919123642491566639820702501701460474001196941883819620040361365999896847153131825439764785309224799365130821807533936571946283436139142085798584001786665762720472918598961576836
    g = 2
    for i in range(2**7):
        phi = _lambda * g
        d = gmpy2.invert(e,phi)
        m = pow(c,d,n)
        flag = long_to_bytes(m)
        if b"CTF" in flag:
            print(flag)
            exit(0)
        g = nextprime(g)
###  threshold
题目代码如下
    #make.sage
    import random
    flag = bytearray("DASCTF{********************************}".encode())
    flag = list(flag)
    length = len(flag)
    N=53
    p=257
    q=28019
    d=18
    f=[1]*19+[-1]*18+[0]*16
    random.shuffle(f)
    g=[1]*18+[-1]*18+[0]*17
    random.shuffle(g)
    Q. = Zmod(q)[]
    P. = Zmod(p)[]
    fx=Q(f)
    fy=P(f)
    gx=Q(g)
    Fqx=fx.inverse_mod(x^N-1)
    Fpy=fy.inverse_mod(y^N-1)
    hx=(Fqx*gx).mod(x^N-1)
    r=[1]*10+[-1]*22+[0]*21
    random.shuffle(r)
    rx=Q(r)
    mx=Q(flag)
    ex=(p*rx*hx+mx).mod(x^N-1)
    print(ex)
    print(hx)
可以发现本题的内容和[2020SCTF-Lattice](https://ctftime.org/writeup/22161)很像，那么我们可以据此写出`exp`，不过由于这道题中没有`bal_mod`，所以也就可以去掉
    import random
    p = 257
    q = 28019
    n = 53
    Zx. = ZZ[]
    e = 7367*x^52 + 24215*x^51 + 5438*x^50 + 7552*x^49 + 22666*x^48 + 21907*x^47 + 10572*x^46 + 19756*x^45 + 4083*x^44 + 22080*x^43 + 1757*x^42 + 5708*x^41 + 22838*x^40 + 4022*x^39 + 9239*x^38 + 1949*x^37 + 27073*x^36 + 8192*x^35 + 955*x^34 + 4373*x^33 + 17877*x^32 + 25592*x^31 + 13535*x^30 + 185*x^29 + 9471*x^28 + 9793*x^27 + 22637*x^26 + 3293*x^25 + 27047*x^24 + 21985*x^23 + 13584*x^22 + 6809*x^21 + 24770*x^20 + 16964*x^19 + 8866*x^18 + 22102*x^17 + 18006*x^16 + 3198*x^15 + 19024*x^14 + 2777*x^13 + 9252*x^12 + 9684*x^11 + 3604*x^10 + 7840*x^9 + 17573*x^8 + 11382*x^7 + 12726*x^6 + 6811*x^5 + 10104*x^4 + 7485*x^3 + 858*x^2 + 15100*x + 15860
    h = 14443*x^52 + 10616*x^51 + 11177*x^50 + 24769*x^49 + 23510*x^48 + 23059*x^47 + 21848*x^46 + 24145*x^45 + 12420*x^44 + 1976*x^43 + 16947*x^42 + 7373*x^41 + 16708*x^40 + 18435*x^39 + 18561*x^38 + 21557*x^37 + 16115*x^36 + 7873*x^35 + 20005*x^34 + 11543*x^33 + 9488*x^32 + 2865*x^31 + 11797*x^30 + 2961*x^29 + 14944*x^28 + 22631*x^27 + 24061*x^26 + 9792*x^25 + 6791*x^24 + 10423*x^23 + 3534*x^22 + 26233*x^21 + 14223*x^20 + 15555*x^19 + 3381*x^18 + 23641*x^17 + 2697*x^16 + 11303*x^15 + 6030*x^14 + 7355*x^13 + 20693*x^12 + 1768*x^11 + 10059*x^10 + 27822*x^9 + 8150*x^8 + 5458*x^7 + 21270*x^6 + 22651*x^5 + 8381*x^4 + 2819*x^3 + 3987*x^2 + 8610*x + 6022
    def inv_mod_prime(f,p):
        T = Zx.change_ring(Integers(p)).quotient(x^n-1)
        return Zx(lift(1 / T(f)))
    def mul(f,g):
        return (f * g) % (x^n-1)
    def bal_mod(f,q):
        g = list(((f[i] + q//2) % q) - q//2 for i in range(n))
        return Zx(g)
    def decrypt(e,pri_key):
        f,fp = pri_key
        a = bal_mod(mul(e,f),q)
        d = bal_mod(mul(a,fp),p)
        return d
    def get_key():
        for j in range(2 * n):
            try:
                f = Zx(list(M[j][:n]))
                fp = inv_mod_prime(f,p)
                return (f,fp)
            except:
                pass
        return (f,f)
    M = matrix(ZZ, 2*n, 2*n)
    hh = h.list()
    for i in range(n): M[i,i] = 1
    for i in range(n,2*n): M[i,i] = q
    for i in range(n):
        for j in range(n):
            M[i,j+n] = hh[(n-i+j) % n]
    M = M.LLL()
    key = get_key()
    l = decrypt(e, key).list()
    flag = bytes(l)
    print(flag)
###  son_of_NTRU
虽然这道题目说的不是`NTRU`，但是我们还是可以发现题目的代码和`NTRU`基本类似
    #! /bin/bash/env python3
    from random import randrange
    from Crypto.Util.number import *
    from gmpy2 import invert
    def gcd(a,b):
        while b:
            a,b = b,a%b
        return a
    def generate():
        p = getPrime(1024)
        while True:
            f = randrange(1,(p//2)**(0.5))
            g = randrange((p//4)**(0.5),(p//2)**(0.5))
            if gcd(f,p)==1 and gcd(f,g)==1:
                break
        h = (invert(f,p)*g)%p
        return h,p,f,g
    def encrypt(m,h,p):
        assert mint:
        return reduce(lambda x,y: x+y,map(lambda x: x[0]*x[1],zip(c,a))) 
    def enc(m:list,k:list)->list:
        for i in range(len(k)*2):
            m.append(cycle(m[i:i+len(k)],k))
        return m[len(k):]
    if __name__ == "__main__":
        key=[ord(random.choice(hexdigits)) for i in range(len(flag))]
        c=enc(list(flag),key)
        print(c)
可以发现题目的代码逻辑十分像[LFSR](https://ctf-wiki.org/crypto/streamcipher/fsr/lfsr/)，不同的地方是这里的`key`是`hexdigits`的数而非`01`
那么我们可以参考[2019De1CTF-Babylfsr](https://github.com/De1ta-team/De1CTF2019/tree/master/writeup/crypto/Babylfsr)，首先得到如下的关系（假设`n = len(m)
// 2`）
那么我们便可以通过`m`得到`key`，之后再一个一个字节逆推回去即可还原`flag`
    c = [180320, 12795604, 913707946, 65244867544, 4658921499366, 332678259897680, 23755460291939729, 1696299282824525162, 121127152307279309992, 8649291534003765460181, 617617459134250473857819, 44102031285199767595231826, 3149180993372727865351695610, 224872656429052251931507068163, 16057416742916791898621189838002, 1146607313446549338631740275859490, 81875456824588820793005728503088789, 5846457066530480582594997088868317921, 417476268914312098171907310476576578536, 29810607197367740257089118506396936455267, 2128677406710643996313598469435818995764283, 152001851952900202233154866795341968398324618, 10853952282423997785255606215412380976089774602, 775045031593704366379150517314704054142878227755, 55343416422679709865626814221707233611767499083451, 3951891330799176591085237005754672086216649002044116, 282191561344334793283891774610663595748300192924237652, 20150371209182455377207293308509352961052348504530516058, 1438871729308714548579613052036192683042976990785336035213, 102745097443187470470063857372230471012050786200205019335560, 7336689458539737357933680339939811164938123954552946412371136, 523888862345101730958585832445722009143686030486587614405269619, 37409180481229224476184683624742923927721083153229315469794323846, 2671266531631899605156440693785360699681088880751785277451781995127, 190746356675660819059021289711194688989007498945709965975632125093772, 13620569925986012345710256811290898483914841356894501064938828451682289, 972600097542764210429602165761543702875470220807440912087468994318947199, 69450173882625967125859360885466807837084362724230554403206714010957033564, 4959208480970674965771932762141990438694621159829420665293248503741956497339, 354120765763611360372631234091033326236527919343510113669886900852817067794937, 25286599106731127999761204195099137001826484641202640190432847596126102129290177, 1805632869356683189091740036886552559813413339716342384679179468460652986832630119, 128934304100758873373068786008043012614625306314330902439450614878647840309940810799, 9206774564238985792239909901043542380389506567225353556524468058541750913201465442258, 657425488646345934124836595103998888905043390553798696290609052666406363868364633227987, 46944591735815161454850764823066332748372328488810515939042504343121621896260739496814215, 3352158885381868382186614128492698209211597671157972107257901283108688995314288195559935895, 239366640061152248661380413770610731951278310979044705869198442025229868870474962029566786828, 17092384440374810990148000504438682199862673994374786921479630475896214666270304948184067943963, 1220510952499186818225235173267171189892653750839095345581049972346091269304188809141591821528945, 87152672604981875905661244747737456527193455119785950165560211136820203006355054095176767065463607, 6223285687554056604834063330772248822879874758146969128122776216276580479221618865554693862254391145, 444384361274324240336894080988769378714126300500080707977898823502774400070423897702729938853457320554, 31732025566514505285832183071784730973330427403124198140983516899800427456134314554661472009492580417251]
    l = len(c) // 2
    A = Matrix(ZZ,l)
    for i in range(l):
        A[i] = c[i:i+l]
    v = vector(c[l:])
    key = A.solve_right(v)
    for i in range(l):
        cc = c[:l-1]
        s = c[l-1]
        for j in range(l-1):
            s -= cc[j] * key[1+j]
        assert s % key[0] == 0
        r = s // key[0]
        c.insert(0,r)
    print(bytes(c[:l]))
## Reference