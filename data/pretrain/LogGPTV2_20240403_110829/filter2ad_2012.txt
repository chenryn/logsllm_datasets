title:Policy transformation in software defined networks
author:Nanxi Kang and
Joshua Reich and
Jennifer Rexford and
David Walker
Policy Transformation in Software Deﬁned Networks
Nanxi Kang, Joshua Reich, Jennifer Rexford, David Walker
{nkang, jreich, jrex, dpw}@cs.princeton.edu
Princeton University
ABSTRACT
A Software Deﬁned Network (SDN) enforces network-wide
policies by installing packet-handling rules across a distributed
collection of switches. Today’s SDN platforms force pro-
grammers to decide how to decompose a high-level policy
into the low-level rules in each switch. We argue that future
SDN platforms should support automatic transformation of
policies by moving, merging, or splitting rules across multi-
ple switches. This would simplify programming by allowing
programs written on one abstract switch to run over a more
complex network topology, and simplify analysis by consol-
idating a policy spread over multiple switches into a single
list of rules. This poster presents our ongoing work on a
sound and complete set of axioms for policy transformation,
to enable rewriting of rules across multiple switches while
preserving the forwarding policy. These axioms are invalu-
able for creating and analyzing algorithms for optimizing the
rewriting of rules.
Categories and Subject Descriptors
C.2.m [Computer-Communication Networks]: Miscel-
laneous
Keywords
software deﬁned networks, network virtualization, Open-
Flow
1.
INTRODUCTION
The Software Deﬁned Network (SDN) paradigm enables
ﬂexible programming of packet-switched networks. Open-
ﬂow [2] provides a key SDN building-block by deﬁning a
standardized protocol for a controller to interact with switches:
installing rules for forwarding and modifying packets, query-
ing traﬃc counters, and directing packets to a controller
for further processing. Today’s controller applications man-
age the network at the level of individual switches. Yet, a
truly powerful SDN system should enable reasoning about
the rules installed across multiple switches, and their cumu-
lative eﬀect on packets traversing the network.
The goal of our work is to address this challenge by build-
ing machinery for global policy transformation. Global policy
transformation operates by moving, merging, and/or split-
ting rules across multiple switches, while preserving the over-
Copyright is held by the author/owner(s).
SIGCOMM’12, August 13–17, 2012, Helsinki, Finland.
ACM 978-1-4503-1419-0/12/08.
Figure 1: Policy transformation.
can be spread over multiple switches.
all forwarding behavior of a network. Using this machinery,
policies written for a single switch can be distributed across
a set of switches, as shown in Figure 1, and policies already
distributed over multiple switches can be consolidated. This
is important for several reasons:
• Resource usage: Policies too large to ﬁt on any one switch
• Ease of programming: Policies for a single switch are eas-
• Portability: Policies written for one network topology can
• Analysis: A policy spread over multiple switches can be
transformed into a single list of rules, to more easily check
that the policy satisﬁes invariants.
be transformed to run on another.
ier for programmers to write.
Our goal is to enable SDN controllers to transform policies
automatically, shielding the programmer from the details.
For many years, researchers have studied ﬁrewalls repre-
sented as a prioritized list of access-control rules that permit
or deny traﬃc, with the goal of checking whether two poli-
cies are equivalent, or to minimize the number of rules. For
instance, Appelgate et al. [1] show that minimizing a single
access control list is NP hard, and present an optimal al-
gorithm for one particular case of access-control lists, while
Yuan et al.
[4] analyze the correctness of distributed ﬁre-
walls. Other related work [3] develop general algorithms to
optimize a single list. Our work is the ﬁrst to examine the
general problem of network-wide policy transformation.
We identify two critical challenges with respect to pol-
icy transformation. The ﬁrst is correctness: each packet p
must be treated under a transformed policy A’, exactly as
it would under the original policy A. The second is that of
eﬃciency: transformed policies should minimize the total
number of rules, minimize the maximum number of rules
on any switch, or, in the case of a network of switches with
diﬀerent capacities, ﬁnd a way to pack rules in to diﬀer-
309ent switches so that no switch overﬂows its capacity. We
plan to address these problems of correctness and eﬃciency
by developing a general-purpose policy rewriting framework
that characterizes all possible, sound policy transformations.
This framework will provide a formal foundation that can be
used to analyze the correctness of speciﬁc policy rewriting
algorithms.
2. POLICY TRANSFORMATION
We begin our exploration of global network policy op-
timization by analyzing two categories of network policy:
the single switch policy and the chain-of-switches policy.
Other topologies are certainly interesting, but as the topol-
ogy grows in complexity, so too grows the complexity of
the transformation system. We continue by discussing the
rewriting axioms that are necessary and suﬃcient to convert
from one policy to another (in the same category). We con-
clude with a brief mention of our ongoing work to use these
rewriting systems to develop eﬃcient and correct determin-
istic optimization algorithms.
2.1 Policy Categories
A policy is a collection of packet-forwarding rules where
each rule r is a (pattern, action) pair. Typical patterns in-
clude exact-match patterns, wildcard patterns and preﬁx-
match patterns. Since any pattern p will match some set
of packets (perhaps a singleton set), we write p ⊆ p(cid:48) when
p matches a smaller set of packets than p(cid:48). Typical actions
include forward, drop, and modify actions.
A single-switch policy is a list l = r1, r2, . . . , rn of rules.
The rules appear in the list with decreasing priority. There-
fore, to compute the action for a packet h in a rule list l,
one can linearly scan l from left to right until hitting a rule
(p, a) where the packet header h matches p. In such a case,
the action a is applied to the packet.
A chain-of-switches policy c is organized as a list of single-
switch policies (i.e., c = l1; l2; . . . ; lm). Switch chains can be
used to model both cascading ﬂowtables within a switch as
well as a set of switches placed in series.
In general, when describing a generic policy we use an
upper-case letter P . The semantics of a policy P relative
to a packet h, written P [h], is the set of observable actions
applied by the policy to that packet as it traverses the net-
work.
2.2 Policy Rewriting
Policy rewriting is speciﬁed via a collection of simple, lo-
cal rewriting axioms. These simple local axioms may be
composed with one another to produce arbitrary semantics-
preserving policy transformations. As an example, consider
the Shadow axiom below.
p2 ⊆ p1
(p1, a1), (p2, a2) ↔ (p1, a1)
(Shadow)
One should read the statements above the horizontal line as
assumptions and statements below the line as conclusions.
Hence, the axiom states that if pattern p2 is a subset of pat-
tern p1 then the pair of adjacent rules (p1, a1), (p2, a2) can be
rewritten to the single rule (p1, a1), and vice-versa.1 Such
1Note that sometimes an optimization is enabled by ﬁrst ex-
panding a rule in to multiple rules that are easier to manage
or move around.
local rewrites may be applied correctly in a large context
using the Congruence axiom as follows.
l2 ↔ l
(cid:48)
2
l1, l2, l3 ↔ l1, l
(cid:48)
2, l3
(Congruence)
The Congruence axiom states that if a local rewrite applies
then that local rewrite may be used within the context of
a longer list of rules. In addition to Shadow and Congru-
ence, there are a few other axioms for single switch policies
including Reordering and Join.
Rewriting rules for switch chains relies on the rewriting ax-
ioms for the single-switch case to optimize individual switches
in the chain. In addition, there are further axioms for shuf-
ﬂing functionality back and forth along the chain.
2.3 Soundness and Completeness Properties
Any good rewriting system should satisfy two key prop-
erties: (1) A rewriting system is Sound if any combination
of rewriting axioms is guaranteed to produce a semantically
equivalent list of rules, and (2) a rewriting system is com-
plete if any semantically equivalent policy can be produced
by applying the axioms. More precisely:
Deﬁnition 1. Soundness: If P1 ↔ P2 then for all packet
headers h, P1[h] = P2[h].
Deﬁnition 2. Completeness:
P1[h] = P2[h], then P1 ↔ P2.
If for all packet header h,
To date, we have proven our rewrite system for single-
switch policies is sound and complete and our rewrite system
for switch-chains is sound. In the future, we hope to develop
a completeness argument for switch-chain rewriting. We are
also looking at richer topologies including trees and DAGs.
2.4 Ongoing Work: Optimization Algorithms
Our rewrite system does not itself constitute a determin-
istic algorithm for generating optimized policies. Rather, it
describes the search space any such algorithm must navigate,
and provides a framework within which one may analyze the
correctness of such algorithms.
The next phase of the research involves developing multi-
phase algorithms for generating optimized, global network
policies. Our current plan involves three phases:
(1) a
heuristic algorithm to distribute global policy to particular
switches, (2) balancing across neighbors via switch-to-switch
rule movement and (3) optimization on individual switches.
3. REFERENCES
[1] D. L. Applegate, G. Calinescu, D. S. Johnson, H. Karloﬀ,
K. Ligett, and J. Wang. Compressing rectilinear pictures and
minimizing access control lists. In ACM-SIAM SODA, pages
1066–1075, 2007.
[2] N. McKeown, T. Anderson, H. Balakrishnan, G. Parulkar,
L. Peterson, J. Rexford, S. Shenker, and J. Turner. Openﬂow:
Enabling innovation in campus networks. SIGCOMM Computer
Communications Review, 38(2):69–74, Mar. 2008.
[3] C. R. Meiners, A. X. Liu, and E. Torng. TCAM Razor: A
systematic approach towards minimizing packet classiﬁers in
TCAMs. IEEE/ACM Trans. Netw., 18(2):490–500, Apr. 2010.
[4] L. Yuan, J. Mai, Z. Su, H. Chen, C.-N. Chuah, and
P. Mohapatra. FIREMAN: A toolkit for ﬁrewall modeling and
analysis. In IEEE Symposium on Security and Privacy, pages
199–213, 2006.
310