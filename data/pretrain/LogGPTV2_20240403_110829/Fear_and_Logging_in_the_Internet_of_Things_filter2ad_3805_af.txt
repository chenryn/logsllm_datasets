s e v er al r e al- w orl d
c o ul d
We s h o w
e x a m pl es
a n d
M ar c
h o w a
b e
[ 8]
a n d
S m art A p ps
F or e x a m pl e, a c ust o m er
Pr o v T hi n gs c a n b e us e d t o di a g n os e d ef e cti v e d e vi c es [ 1 1],
H a n-
S m art A p p t o t ur n
H o w e v er,
off fr e q u e ntl y a n d
w h et h er it is a h ar d w ar e iss u e or a S m art A p p
Pr o v T hi n gs,
all t h e
w er e cr e at e d d uri n g t h e
mis b e h a vi n g
dl ers [ 9].
o n a n d t ur n
s h e f o u n d
s h e c o ul d n’t t ell
iss u e [ 1 1].
Wit h
o f f a cti viti es of t h e kit c h e n li g ht t h at
kit c h e n li g ht at s p e ci ﬁ c ti m es.
w as r a n d o ml y t ur n e d
u n m at c h e d
us es a
h er
h er li g ht
D e vi c e
c o ul d
q u er y
M ar c
ﬁrst
off
1 0
pattern:{
MATCH (a:SINK)-[:Used]->(b:Entity),
(c:APP_IOT {name:"FaceDoor"})
WHERE a.agentid=c.id and
(a.uri<>"http://trust.me" || b.taint <> "
ImageCapture")
RETURN a
}
check: exist
action: notify
Fig. 13: A policy to detect unintended information ﬂows.
Fig. 14: A provenance graph shows the provenance of a real smoke
event and a fake smoke event.
could use ProvThings to detect unintended information ﬂow
based on their own needs. Bob, another smart home user,
installed two apps. LockManager is an app that allows the
user to update or delete lock pin codes. FaceDoor is an app
that allows unlocking a door via face recognition using the
front door camera. However, a malicious payload in FaceDoor
(see Appendix C for details) steals user’s sensitive information
and sends it to an attacker at midnight every day. It leverages
a privilege escalation vulnerability in SmartThings [44] that
permits a SmartApp to subscribe to all events generated by
a device once the user has authorized the app to access the
device. In this case, FaceDoor subscribes all the events of the
motion sensor, front door lock, front door camera and location.
Hence, it could steal sensitive information such as pin codes
from codeReport events, users’ photos from image events
and the mode of the home from mode events.
Figure 12 shows a provenance graph of how some sensitive
data was leaked by FaceDoor. For simplicity, we do not
show how some events were generated in the provenance
graph. The provenance graph shows that the spyHandler
function subscribed to different events and stored them in the
state.data global variable. A scheduler, which was set at
installation time, triggered the sendData function to send
the data to an attacker at midnight every day. The graph
also explains how the door lock pin code was leaked even
though it was set in the LockManager app. Since FaceDoor
uses a trusted service for face recognition, Bob allows the
information ﬂow from a camera to the trusted site. To detect
other unintended information ﬂows, Bob deﬁnes a policy as
shown in Figure 13. The policy speciﬁes that if an information
ﬂow is not from an entity with ImageCapture taint label
to the trusted site in FaceDoor, Bob will be notiﬁed of the
unintended ﬂow.
C. Typical Consumers
For typical consumers who do not have much computer
skills, a simpliﬁed frontend is needed for them to beneﬁt from
the insights of provenance tracing. Similar with the fake alarm
attack in [44], in this case, we consider a user installed a
benign app (SmokeMonitor) which monitors the events of
Fig. 10: The provenance of an unintended unlock event for a front
door. The app LockItWhenILeave visited a malicious domain to
retrieve a command, then waited until after a speciﬁed time when the
mode was away to execute the command.
pattern:{
RETURN a
MATCH (a:SINK)-[:WasInformedBy]->(:Reflection)-[:Used]->(:
Entity) WasOriginatedFrom (:INPUT_HTTP)
}
check: exist
action: notify
Fig. 11: A policy to detect vulnerable dynamic method invocations
use values from an HTTP input.
suspicious time. If there are such activities, then the random
turning off should be triggered by SmartApps. Marc could then
make backward query with the returned activities to know why
the light was turned off. It could be a misbehaving SmartApp
or the customer’s misconﬁguration. On the other hand, if there
is no such activities, it is very likely there is a hardware issue
with the light. Another use case of ProvThings is to debug
smart home automation issues. In example [7], a customer
uses a SmartApp that will turn off a switch some time after
the switch is turned on. She conﬁgured the SmartApp to turn
off her switch 2 minutes after the switch is turned on. However,
she found that when she turned the switch on, it just stayed
on. With ProvThings, Marc could query the on activity of the
customer’ switch and make a forward query with the activity.
In the returned provenance graph, Marc ﬁnds that the on
activity leads to a onHandler function which invoked a timer
function with a parameter of value 2000. Since a timer had
been set, it is very likely the problem was caused by the timer.
By examining the parameter, Marc realizes that the customer
made a mistake in the conﬁguration. The unit for the timer is
second not millisecond.
B. Techies
Tech users can deploy ProvThings in their own backend
server to specify advanced provenance-aware security policies
for their homes. In this scenario, we show how tech users
11
Event:modevalue:AwayFunctionName:setLocationModearg:'Away'WasGeneratedByFunctionName:modeHandlerUsedLockItWhenILeaveWasAssociatedWithFunctionName:presenceHandlerWasInformedByFunctionName:installedWasAssociatedWithstate.timevalue:'2017-05-01 00:00:00'subtype:memoryHttp Responsesubtype:INPUT_HTTPWasDerivedFromFunctionName:checkUpdateFunctionName:initializeWasInformedBysubtype:EVENT_TIMERFunctionName:runInWasGeneratedBystate.commandvalue:unlockTime:'2017-04-01 09:10:21'subtype:memoryWasDerivedFromFunctionName:httpGeturi:'http://attacker.appspot.com'WasInformedByEvent:presencevalue:not presentUsedWhenEveryoneIsAwayWasAssociatedWithDynamic method invocationTime:'2017-05-01 15:32:44'UsedFunctionName:attackWasInformedByWasGeneratedByAlice's Presence SensorWasAttributedToCommandName:unlockImplicit-UsedWasInformedByFront Door LockWasAssociatedWithWasInformedByUsedWasInformedByEvent:smokevalue:detectedFunctionName:createFakeEventWasGeneratedBySmartLightWasAssociatedWithEvent:smokevalue:detectedFunctionName:parseWasGeneratedByWindowCommandName:openWasAssociatedWithFunctionName:smokeHandlerWasInformedByFire Sprinklervalue:'command: 7105, payload: 01 01'subtype:DEVICE_MSGUsedCommandName:sirenAlarmWasAssociatedWithWasInformedBySmoke DetectorWasAttributedToSmokeMonitorCommandName:onWasAssociatedWithWasInformedByUsedUsedWasAssociatedWithFig. 12: A provenance graph shows how some sensitive information (for example the lock pin code) was leaked. The spyHander function
collected sensitive information and a scheduler triggered the sendData function to send the data to the attacker.
pattern:{
MATCH (a:SINK)-[:WasInformedBy]->(:Activity {name:"
smokeHandler"})-[:Used]->(:EVENT_DEVICE)-[:
WasGeneratedBy]->(b:Activity {name:"createFakeEvent"}),
(c:APP_IOT {name:"SmartLight"})
WHERE b.agentid = c.id
RETURN a
}
check: exist
action: deny
Fig. 16: WhyThis procedurally generates a policy to deny fake smoke
events from SmartLight.
inconsistent with the description of SmartLight, the user may
decide to deny the action. In response, WhyThis will generate
a new policy to deny all future fake events from SmartLight,
as shown in Figure 16. It is important to note that this is only
a proof-of-concept frontend for typical consumers. Future IoT
platforms which adopt the ProvThings approach can design
better presentation such as provenance comics [68] to meet
their usability requirements for typical consumers.
D. Privacy Considerations
IoT platform providers (e.g., SmartThings) host IoT apps
and device handlers and therefore can already observe all
events and control commands, as mentioned in their pri-
vacy policy [27]. They can transparently apply ProvThings
to their platform as it requires no platform modiﬁcation.
However, ProvThings systematizes the auditing of IoT events
and generates new privacy-sensitive insights of causal de-
pendencies. Thus, platform providers that adopt ProvThings
approach should update their privacy policies to reﬂect this. To
protect consumers’ privacy, platform providers should allow
consumers to conﬁgure the granularity of the provenance
collected, how long it can be stored and with whom it can
be shared. They could use access control
to enforce the
provenance metadata that a platform developer or help desk
staff could access. They could also deploy system auditing [38]
to reliably trace how customers’ provenance data had been
accessed. Tech users could have more control over their
provenance data. They could deploy ProvThings to their own
backend servers to manage and use the collected provenance
data. They can protect their privacy as long as their backend
servers are not compromised. Typical consumers do not have
the ability to manage their provenance data and therefore they
should follow the best practices of privacy protection. For
example, they should be aware of the privacy implications of
(a) WhyThis notiﬁcation
(b) WhyThis explanation
Fig. 15: Screenshots of our simpliﬁed frontend for typical consumers.
a smoke detector. If there is smoke detected by the smoke
detector, SmokeMonitor will turn on the ﬁre sprinkler, open
the window and sound the alarm. Another app (SmartLight)
which is embedded with malicious payload could raise a fake
physical device event for the smoke detector which will misuse
the logic of SmokeMonitor to take multiple actions. This fake
event could cause physical damage to the house and allow
burglars to break into the house through a window. For brevity,
provenance graphs of both the real and fake device events are
overlaid in Figure 14. The fake event was generated by the
createFakeEvent method of SmartLight, while the real
event was generated by parsing a device message from the
smoke sensor. However, to the smokeHandler function of
SmokeMonitor, the two smoke events appear to be the same.
Although this graph can be used to establish the illegitimacy of
the fake event, it exposes a variety of low-level system details
that are likely to confuse typical consumers.
In Figure 15, we show screenshots of our simpliﬁed
frontend, the WhyThis app, for typical consumers. It explains
unseen sequence of activities and allows them to “allow”
or “deny” such activities. When the open command (a sink
function) of the window is about to be executed, WhyThis
prompts the user with a dialog as shown in Figure 15a.
The user can click the WhyThis? button to see a simpliﬁed
provenance graph and a paragraph description before making
a decision (Figure 15b). In this case, since this behavior is
12
Event:lockvalue:unlockedFront Door LockWasAttributedToEvent:imagevalue:image dataFront Door CameraWasAttributedToEvent:lockvalue:lockedWasAttributedToname:state.datasubtype:memoryWasDerivedFromWasDerivedFromWasDerivedFromEvent:motionvalue:inactiveWasDerivedFromEvent:motionvalue:activeWasDerivedFromFunctionName:spyHandlerWasGeneratedByEvent:codeReportvalue:'pincode:1234'WasDerivedFromFunctionName:httpPosturi:'http://attacker.appspot.com'UsedFunctionName:sendDataWasInformedByFunctionName:initializeFunctionName:installedWasInformedByLockManagersubtype:INPUT_USERsubtype:EVENT_TIMERUsedFunctionName:schedulearg:'0 0 0 * * ?'WasInformedByMotion SensorWasAttributedToCommandName:setCodeFunctionName:updatePincodeWasInformedByWasAssociatedWithWasGeneratedByFaceDoorWasAttributedToUsedUsedUsedUsedWasAssociatedWithUsedUsedWasAssociatedWithWasAssociatedWithUsedWasGeneratedByprovenance collection and choose IoT services and products
from trusted providers.
VIII. DISCUSSION AND LIMITATIONS
Static Source Code Instrumentation. A general limitation of
static program analysis is its ineffectiveness in dealing with the
dynamic features of a language. However, SmartThings runs its
programs in sandboxes, restricting many dynamic features to
be used, such as Groovy Eval [17]. The only dynamic feature
to consider was GString, which can be used for dynamic
method invocation and dynamic property access. To ensure
the completeness of our provenance records, we conserva-
tively assumed that a dynamic method invocation could be
sink invocation and a dynamic property access on a device
object could access the device’s state. Hence, we instrumented
code on any control-ﬂow path from a program entry to a
GString statement, potentially causing us to perform more
instrumentation than was actually needed. Given access to the
Groovy runtime environment, we could use dynamic program
analysis to further restrain provenance collection.
Usability.
The proliferation of smart home technology has
depended on ease of use. In keeping with this design phi-
losophy, a provenance-aware system must make provenance
useful and salient
to end users. In this work, we sketch
several scenarios in which provenance would be of use to IoT
stakeholders. In our future work, we will perform user studies
to evaluate the usability of ProvThings for different users.
Applicability.
Our approach is generic to provide broad
support for different IoT platforms. In this work, we demon-
strate how we apply ProvThings on the SmartThings platform.
We have also examined how to apply ProvThings on other
IoT platforms in Table I. For Vera [29], we could perform
source code instrumentation to its Lua-based apps. For Android
Things [13], we could perform either source code or bytecode
instrumentation to its Android-based apps. In ProvThings,
the provenance collection module is platform-speciﬁc as it
works on platform chosen languages and platform deﬁned
APIs. Our work demonstrates that the platform API implicitly
identiﬁes sources and sinks, so the only engineering effort
required for porting would be to implement our algorithm
for another language. Moreover, even ProvThings ﬁts best
for centralized platforms, it is not limited to centralized IoT
architectures. For example, in a decentralized setting where
devices communicate directly with each other, provenance
collectors could be developed and deployed on each device to
collect the necessary metadata for building provenance graphs.
Deployability.
ProvThings would be most useful to platform
providers. ProvThings provides a transparent mechanism that
platform providers can use for effective auditing without mod-
iﬁcations to their platforms. Moreover, our approach strikes an
optimal balance between precision and performance overhead.
ProvThings could also be deployed for debugging by develop-
ers or “techies” with source code access, and that typical users
could indirectly beneﬁt from ProvThings’ deployment.
Device Integrity.
In this work, we assume the devices are not
compromised. Thus, compromised devices can generate false
messages to cause ProvThings to create wrong provenance
graphs. However, securing device is a problem orthogonal to
our work. The device integrity assumption enables an practical
method of system-wide monitoring of IoT activities. The
alternative would be invasive and device speciﬁc.
IX. RELATED WORK
IoT Security.
A lot of vulnerabilities have been identiﬁed
in IoT devices [62], [61], [69], [51], [67], [10] and pro-
tocols [46], [6]. Fernandes et al. [44] conducted the ﬁrst
security analysis of the SmartThings platform. They discovered
several design ﬂaws and constructed four proof-of-concept
attacks. In our evaluation, we showed that ProvThings can
efﬁciently detect
these attacks. For IoT security solutions,
Sivaraman et al. [70] proposed a three-party architecture in
which a specialist provider dynamically manages network
access control rules based on MAC addresses to protect IoT
devices. Yu et al. [74] proposed a centralized controller that
monitors the contexts of devices and operating environment
and instantiates specialized middle-boxes that impose on trafﬁc
to devices to enforce security policies. Different from these
network-level protections, ProvThings collects information at
application-level to capture attack provenance. FlowFence [45]
is a system that enforces ﬂow policies for IoT apps to protect
sensitive data. ContextIoT [54] is a context-based permission
system for IoT platforms which collects context information
to identify sensitive actions. As compared in xIV, unlike
FlowFence, ProvThings does not require platform modiﬁca-
tion and additional development effort from app developers.
ContextIoT only collects information within an app, which
we have demonstrated is insufﬁcient for attacks that involve
multiple agents. Our approach tracks data across both apps and
devices, which captures a more complete and accurate context.
IoT Forensics.
Several frameworks/models [65], [55] have
been proposed for IoT forensics. Oriwoh et al. [63] proposed
the Forensics Edge Management System, which is a smart
device that autonomously detects, investigates and indicates
the source of security issues by monitoring the network in
smart homes. Zawoad et al. [76] formally deﬁned IoT forensics
and proposed a Forensics-aware IoT (FAIoT) model to support
forensics investigations in the IoT infrastructure. Similar with
the FAIoT architecture, we also use a centralized server to
process and store evidences. However, different from the
proposed models, our approach uses provenance metadata as
evidence and builds provenance graphs to assist forensics
investigation.
[73],
Provenance-based Solutions. A lot of work has been done
to leverage provenance for forensic analysis [38], [56], [58],
[66], [57], network debugging, auditing [50] and troubleshoot-
ing [36],
[40], and intrusion detection and access
control [37], [64]. Similarly, provenance-based solutions are
proposed for android to provide attack reconstruction [43],
[35], [75], debugging and diagnosing device disorders [53].
ProvThings solves unique challenges associated with build-
ing a general provenance framework for IoT platforms and
further enables provenance-based applications in the domain
of IoT platforms. Provenance solutions have been proposed
in previous works [39], [32], [71] for IoT devices. However,
these solutions are targeted towards IoT devices and cannot
be directly applied to IoT platforms which is the main focus
of this paper. Moreover, none of the existing works provide
13
concrete implementation and are only designed to work on
speciﬁc IoT devices which require changing IoT devices code.
Thus, these solutions are not scalable and practical due to great
heterogeneity of IoT devices.
X. CONCLUSION
In this work, we have presented ProvThings, a general
and platform-centric approach to IoT provenance collection.
ProvThings collects provenance of events and data state
changes from different IoT components to build provenance
graphs of their causal relationships, enabling attack investi-
gation and system diagnosis. We prototyped ProvThings on
Samsung SmartThings, and demonstrated the efﬁcacy and
performance through extensive evaluation of our proof-of-
concept implementation; ProvThings was able to provide com-
plete provenance for a corpus of 26 known IoT attacks, and
offers utility to a variety of professionals and end users.
ProvThings thus provides promising new capabilities that aid
in understanding and defending against IoT security threats.
ACKNOWLEDGEMENTS
We thank our shepherd Aziz Mohaisen and the anonymous
reviewers for their comments and suggestions. This work was
supported in part by NSF CNS grants 15-13939, 13-30491,
and 16-57534. The views expressed are those of the authors
only.
REFERENCES
[1]
[2]
[3]
[4]
[5]
[6]
[7]
[8]
[9]