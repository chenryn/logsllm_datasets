```sql
SELECT * FROM tb_url WHERE hash_code = CRC32('http://baidu.com') AND url = 'http://baidu.com';
```
### 全文索引
- MyISAM 存储引擎支持（innodb 5.6后支持）
- 用于查找文本中的关键词
- 查找条件使用 MATCH AGAINST
- 使用倒排索引
### 空间数据索引
空间数据索引（R-Tree），可以用于地理数据存储
### 索引匹配方式
- 全值匹配 全值匹配指的是和索引中的所有列进行匹配
```sql
explain select * from staffs where name = 'July' and age = '23' and pos = 'dev'
```
- 匹配最左前缀 只匹配前面的几列
```sql
explain select * from staffs where name = 'July' and age = '23';
explain select * from staffs where name = 'July';
```
- 匹配列前缀 可以匹配某一列的值的开头部分
```sql
explain select * from staffs where name like 'J%'; -- 可以用索引
explain select * from staffs where name like '%y'; -- 用不到索引
```
- 匹配范围值 可以查找某一个范围的数据
```sql
explain select * from staffs where name > 'Mary';
```
- 精确匹配某一列并范围匹配另外一列 可以查询第一列的全部和第二列的部分
```sql
explain select * from staffs where name = 'July' and age > 25;
```
- 只访问索引的查询 查询的时候只需要访问索引，不需要访问数据行，本质上就是覆盖索引
```sql
explain select name,age,pos from staffs where name = 'July' and age = 25 and pos = 'dev';
```
### 组合索引
当包含多个列作为索引，需要注意的是正确的顺序依赖于该索引的查询，同时需要考虑如何更好的满足排序和分组的需要
### 聚簇索引与非聚簇索引
一种数据存储方式。
聚簇索引：不是单独的索引类型，而是一种数据存储方式，指的是数据行跟相邻的键值紧凑的存储在一起
![聚簇索引的数据分布](/assets/屏幕截图%202021-03-09%20172129.png)
在InnoDB中，默认会选择主键来做举出索引，若没有主键，会生成一个隐藏的主键，主键最好使用自增的数值类型，这样在插入效率及空间占用都会最优
非聚簇索引：数据文件跟索引文件分开存放
### 使用索引排序
EXPLAIN的type为index时 代表使用索引扫描做排序
只有当ORDER BY子句的列都是索引且排序方向一致时，才会使用索引排序
### 覆盖索引
如果一个索引包含所有需要查询的字段的值，称之为覆盖索引，当需要的数据被索引覆盖时，就不必回表查询。
只使用索引可以减少数据读取量，同时由于索引是顺序存储的，相比直接读取数据，拥有较好的IO性能。
MySQL中只能使用B树索引做覆盖索引
```sql
EXPLAIN SELECT store_id,film_id FROM inventory; -- Extra:Using index 代表可以做覆盖索引
```
### 压缩索引
MyISAM会使用前缀压缩的方式将降低索引空间占用，从而使更多的索引可以放入内存。但代价是牺牲了CPU的运算时间。
### MyISAM和InnoDB对B+Tree的使用
MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录
myisam
![2020325193319](/assets/2020325193319.png)
innodb
![202032519307](/assets/202032519307.png)
## 索引优化
如果表很大，索引反而会造成性能下降
如果有索引，增删改都会变慢
少量查询仍然很快
但是并发大的时候会受到硬盘带宽影响
### 独立的列
进行查询时，索引列不能是表达式的一部分，也不能是函数的参数
```sql
SELECT a FROM B WHERE a+3 = 6; -- 无法用到索引
```
像字符串跟数值比较的隐式类型转换、字段运算、字段是函数的参数、字符集不同等，本质上都是对字段做了转换操作，可能会破坏索引值的有序性，因此优化器就决定放弃走索引树的搜索，但还是会遍历索引
### 前缀索引
可以选择开始的部分字符串来进行索引，索引的列的不重复值数量/总数量=索引的选择性 选择性越高 查询效率越好
前缀索引占用的空间会比较少，但同时会增加扫描次数，为了达到索引空间与查询性能的平衡，需要统计数据整体前缀的区分度，选取一个折中的前缀索引长度
BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引
前缀索引无法进行ORDER BY 或者GEOUP BY，也无法覆盖扫描，需要再回表查询
有时候又需要后缀索引，为了达成这个目的，一种hack的方式是把字符串反转后进行存储
### 多列索引
多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好
MySQL会进行一项称为索引合并的策略，一定程度上可以使用多个单列索引来定位指定的行
#### 组合索引
当一个索引不止一个列时，只有当最左索引（索引的第一个列）出现时，才会走索引查询
#### 索引列的顺序
在不考虑排序和分组时，让选择性最强的索引列放在前面
一个列比另外一个列更越能确定一条数据，则前者选择性更强。但还有一种情况就是数据分布不均匀，也有可能造成索引的效果非常差
### 覆盖索引
索引包含所有需要查询的字段的值
- 只读取索引能大大减少数据访问量
- 一些存储引擎只缓存索引
### 索引扫描
使用EXPLAIN时 ，type为index，代表使用了索引扫描来进行排序
使用索引扫描来排序
只有当索引的列顺序和order by子句的顺序完全一致，并且所有列的排序方式都一样时，mysql才能够使用索引来对结果进行排序
### 冗余索引
大多数情况下应尽量扩展已有的索引而非创建新索引，索引越多，更新的时候越慢。
但有时候为了兼容多个查询情况，为创建冗余索引来提升性能
### 细节
union all,in,or都能够使用索引，但是推荐使用in
范围列可以用到索引 范围条件是：、>=、between 范围列可以用到索引，但是范围列后面的列无法用到索引，索引最多用于一个范围列
强制类型转换会全表扫描
更新十分频繁，数据区分度不高的字段上不宜建立索引 更新会变更B+树，更新频繁的字段建议索引会大大降低数据库性能  区分不大的属性，建立索引是没有意义的，不能有效的过滤数据
创建索引的列，不允许为null，可能会得到不符合预期的结果
当需要进行表连接的时候，最好不要超过三张表，因为需要join的字段，数据类型必须一致
- 三种join实现方式
能使用limit的时候尽量使用limit
单表索引建议控制在5个以内
单索引字段数不允许超过5个（组合索引）
一些错误概念：
- 索引越多越好
- 过早优化
## 索引监控
```sql
show status like 'Handler_read%';
```
- Handler_read_first：读取索引第一个条目的次数
- Handler_read_key：通过index获取数据的次数
- Handler_read_last：读取索引最后一个条目的次数
- Handler_read_next：通过索引读取下一条数据的次数
- Handler_read_prev：通过索引读取上一条数据的次数
- Handler_read_rnd：从固定位置读取数据的次数
- Handler_read_rnd_next：从数据节点读取下一条数据的次数
## 维护索引和表
CHECK TABLE 命令可以找出大多数表和索引的错误，使用REPAIR TABLE来修复损坏的表
使用ANALYZE TABLE 重新生成表的统计信息
使用OPTIMIZE TABLE来整理碎片，对于不支持的存储引擎，执行
```sql
ALTER TABLE table_name ENGINE=old_engine
```