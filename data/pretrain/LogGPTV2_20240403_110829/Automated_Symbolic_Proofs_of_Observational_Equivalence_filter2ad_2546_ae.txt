5.2 Feldhofer’s RFID protocol
The RFID protocol due to Feldhofer et al. [17] is of prac-
tical interest as it can be implemented with relatively few
logic gates using AES encryption and hence it ﬁts well with
the requirements of current RFID chips. We use the descrip-
tion from [26] as the basis of our model, which we present in
R → T : nr
T → R : {|nr, nt|}k(R,T )
R → T : {|nt, nr|}k(R,T )
Figure 5: RFID protocol
Figure 5 using Alice&Bob notation. The protocol is between
a reader R and a tag T that share a key k(R, T ). Note that
{| . . .|}k denotes symmetric encryption in this example.
In the ﬁrst message, the reader sends a random nonce
to the tag. In the second message, the tag sends back that
nonce and one of its own choosing, encrypted with the shared
key. In the third message, the reader responds with the same
nonces in reverse order, also encrypted.
The desired security property for this protocol is privacy
for the tags. Namely, if at least two tags share a key with
a reader (and in practice, there will be many such tags),
then the adversary cannot determine which tag is actually
communicating with the reader. Tamarin veriﬁes this in
under 1.6 seconds.
5.3 TPM_Envelope protocol
We ﬁrst brieﬂy explain the key part of this protocol [13]
and afterwards present the Tamarin rules along with fur-
ther details. A stateful Trusted Platform Module (TPM)
creates a one-use public/private key pair, and publishes the
public key. A participant Alice then encrypts a nonce (the
secret) with the public key (creating an envelope), which she
sends to a participant Bob. Bob then either requests from
the TPM the envelope’s content, learning the secret, or re-
quests a TPM-signed certiﬁcate stating that he did not ask
for the content. In both cases, the TPM complies with the
request and changes its state in such a way that it can after-
wards only comply with repetitions of the ﬁrst request, but
never with the other request. This is where mutable state
is crucial, i.e., the original capability of issuing either the
certiﬁcate or the secret is revoked once the choice is made.
The trace-based secrecy property veriﬁed in [13] states that
the adversary may learn either the certiﬁcate or the secret,
but not both.
We investigated whether this protocol additionally satis-
ﬁes the real–or–random property for the secret. We therefore
added a real–or–random challenge to the end of Alice’s pro-
tocol execution, which sends out either the real secret or a
random value. Tamarin fails to prove this property and in-
stead returns a simple attack, provided the encryption used
is deterministic. The attack is as follows: the adversary (im-
personating Bob) asks for the proof of never having received
the secret from the TPM, and thus he must be unable to
learn the secret. But, he can still distinguish whether the
real–or–random challenge emits the real secret or a random
value. He does this using the previously published public
key, and encrypting the emitted value with it. Afterwards,
he compares the resulting encryption to the envelope, and
he learns that it is the real secret if it matches the envelope
and a random value otherwise.
Inspecting this attack it is easy to see that it fails when
probabilistic encryption is used instead. The adversary can
still encrypt the emitted value with the public key, but the
equality check against the envelope will always fail because
the added randomness is diﬀerent in the envelope and the
adversary-generated comparison encryption.
In Figure 6 we present the rules used to model the pro-
tocol TPM Envelope in Tamarin. Note that we omit here
some details, which can be found in the model ﬁle included
at [1]. First we explain the rules concerning the TPM’s plat-
form conﬁguration registers (PCR). The Init rule initializes
the PCR to the initial string (cid:48)pcr0(cid:48), and generates the fresh
authentication identiﬁcation key aik stored in the persistent
AIK fact and sends out the public key pk(aik). This models
a long-term key for the TPM. The extension rule Extend
allows any PCR to be extended to the hash of the concate-
nation of its previous value and an input. This is used when
a client later either extends the PCR with (cid:48)deny(cid:48) or (cid:48)obtain(cid:48).
This changes the TPM’s state to allow creation of a certiﬁ-
cate that the envelope was not opened ((cid:48)deny(cid:48)), or respec-
tively opens the envelope ((cid:48)obtain(cid:48)). Rule CertK certiﬁes
a public key for which the TPM has stored the associated
private key in the persistent key table fact KT with a par-
ticular lock. Locks are PCR values and the TPM will only
extract the private key when the PCR value matches this
lock. In the rule Quote, the current PCR value is sent out
authentically, signed with the TPM’s long-term key. The
TPM’s last rule is U nbind. It takes an envelope as input,
and if the public key used to encrypt the envelope matches
the private key in the key table, where additionally the lock
in the key table matches the current PCR value, then the
message in the envelope is decrypted and sent out.
The participant Alice requests an envelope key in her ﬁrst
rule A1 by extending the PCR with a nonce n of her choice.
In rule A2, she creates the secret to be put in the enve-
lope encryption and checks that the TPM certiﬁes that the
key can only be obtained if the PCR state is extended with
(cid:48)obtain(cid:48) and then she uses the certiﬁed public key to encrypt
her secret. Alice then publishes the envelope while keeping
state in A2 for her next rule and in A2ror for the real–or–
random challenge. Rule A3 uses the state in A2 to check that
the TPM’s PCR was extended with (cid:48)deny(cid:48) (which means it
has not yet, and can now no longer, decrypt the envelope)
and then notes the action Denied. We are only interested
in traces where the adversary can show this certiﬁcate. The
rule CLKey is used with (cid:48)obtain(cid:48) as the lock input to add
a new private key to the TPM’s key table that is used in
rule A2.
It can of course be used with other inputs, but
the resulting keys are not interesting to us. Now the key
can only be extracted with a PCR extended with (cid:48)obtain(cid:48),
and thus the certiﬁcate with (cid:48)deny(cid:48) is unavailable. The last
rule is the ROR rule; this either outputs the real secret or
a random value.
The Tamarin prover ﬁnds the attack described above for
the observational equivalence of the TPM Envelope proto-
col. Note that this is a stronger property than trace-based
secrecy, which had been veriﬁed by [13], so the two results
are compatible. We therefore conclude that this protocol
should only be used with probabilistic encryption, and not
with deterministic encryption.
This example illustrates Tamarin’s handling of mutable
state, which other tools cannot handle. It also illustrates the
diﬀerence between trace-based properties and observational
equivalence-based properties.
6. RELATED WORK AND CONCLUSION
We have shown how to take the well-established model-
ing formalism of multiset rewriting and extend it with a
novel deﬁnition of observational equivalence. The result is
well-suited for the veriﬁcation of cryptographic protocols,
Init : Fr(aik)−−[]→PCR((cid:48)pcr0(cid:48)), AIK(aik), Out(pk(aik))
Ext : PCR(x), In(y)−−[]→PCR(h(x, y))
CertK : AIK(aik), KT(lock, sk)−−[]→
Quote : PCR(x), AIK(aik)−−[]→
U nbind : PCR(x), KT(x, sk), In(aenc(m, pk(sk)))−−[]→
Out(sign((cid:104)(cid:48)certk(cid:48), lock, pk(sk)(cid:105), aik))
PCR(x), Out(sign((cid:104)(cid:48)certcpr(cid:48), x(cid:105), aik))
PCR(x), Out(m)
A1 : Fr(n), PCR(x)−−[]→PCR(h(x, n)), A1(n)
A2 : Fr(s), A1(n), AIK(aik),
In(sign((cid:104)(cid:48)certk(cid:48), h(h((cid:48)pcr0(cid:48), n),(cid:48) obtain(cid:48)), pk(cid:105), aik))
−−[]→Out(aenc(s, pk)), A2(n, s), A2ror(s)
In(sign((cid:104)(cid:48)certpcr(cid:48), h(h((cid:48)pcr0(cid:48), n),(cid:48) deny(cid:48))(cid:105), aik)),
A2(n, s), AIK(aik)−−[ Denied(s) ]→
A3 :
CLKey : Fr(sk), PCR(x), In(lock)−−[]→
PCR(x), KT(h(x, lock), sk), Out(pk(sk))
ROR : A2ror(s), Fr(f )−−[]→Out(diﬀ[s, f ])
Figure 6: Rule set modeling the TPM envelope
as well as other applications. Based on this, we have imple-
mented an algorithm to prove observational equivalence for
protocols speciﬁed in multiset rewriting and demonstrated
its eﬀectiveness on a number of case studies. Combining
Tamarin’s constraint solving with the bi-system notion re-
sults in our approach’s high degree of automation.
Our equivalence notion has similarities with other notions
of observational equivalence considered in the literature, in-
cluding trace equivalence [11], bisimulation [2], and notions
based on contexts [2, 11, 7]. However, multiset rewriting
and our observational equivalence deﬁnition are more ﬂexi-
ble than the previous approaches as we can choose the en-
vironment as well as the underlying equational theory. As
illustrated in Example 5 in Section 3, this can, for exam-
ple, be used to model diﬀerent types of attackers. In pro-
cess algebras used for protocol veriﬁcation, like the applied
π-calculus, the environment is implicitly deﬁned and can-
not be changed. Moreover, we support mutable state and
a larger set of equational theories than other approaches as
detailed below.
Various other tools exist for verifying notions of obser-
vational equivalence. APTE [9, 11] and AKISS [8] both
verify trace equivalence, but are limited to a bounded num-
ber of sessions. Moreover, AKISS does not support non-
trivial else branches or private channels. ProVerif [7] ver-
iﬁes observational equivalence in the applied π-calculus for
an unbounded number of sessions, but it cannot handle mu-
table state [3], for example, a protocol that switches be-
tween the states a and b. Extensions for ProVerif that
can deal with Diﬃe-Hellman equational theories [20] do not
support observational equivalence. Note that our approach’s
restriction to bi-systems is similar to ProVerif’s restric-
tion to bi-processes. SPEC [25] veriﬁes open bisimulation
in the spi-calculus, but unlike our approach it only supports
a ﬁxed number of cryptographic primitives and is limited to
a bounded number of sessions.
In contrast to the above, there are tools like StatVerif [3]
and SAPIC [19] that support mutable state. However, they
cannot verify observational equivalence. Similarly, Tamarin,
which is used as SAPIC’s back-end, supports mutable state,
an unbounded number of sessions, and also Diﬃe-Hellmann
equational theories. However, prior to our extension,
it
could not prove any notion of observational equivalence.
[13] St´ephanie Delaune, Steve Kremer, Mark Dermot
Another multiset rewriting-based approach that supports
observational equivalence is Maude-NPA [23]. It creates the
synchronous product of two very similar protocols, similar
to our use of bi-systems. Their approach suﬀers from termi-
nation problems [23] and thus presents only attacks.
As future work, we plan to extend our approach so that
the veriﬁcation of observational equivalence is also possi-
ble when one rule must be matched by a diﬀerent rule, or
even by multiple rules. We will also tackle protocols with
loops, where proofs will likely require induction. Moreover,
we intend to look at larger protocols, such as authenticated
key exchange protocols with perfect forward secrecy, such as
NAXOS and its variants.
7. REFERENCES
[1] Tamarin – tool and extended papers. http://www.
infsec.ethz.ch/research/software/tamarin.html.
[2] Mart´ın Abadi and C´edric Fournet. Mobile values, new
names, and secure communication. In Proceedings of
the 28th Symposium on Principles of Programming
Languages (POPL’01), pages 104–115, New York,
2001. ACM.
[3] Myrto Arapinis, Joshua Phillips, Eike Ritter, and
Mark Dermot Ryan. Statverif: Veriﬁcation of stateful
processes. Journal of Computer Security,
22(5):743–821, 2014.
[4] David Basin, Cas Cremers, and Catherine Meadows.
Model checking security protocols. In Handbook of
Model Checking, chapter 24. Springer, 2015. To
appear.
[5] Mihir Bellare, Anand Desai, David Pointcheval, and
Phillip Rogaway. Relations among notions of security
for public-key encryption schemes. In CRYPTO,
volume 1462 of LNCS, pages 26–45. Springer, 1998.
[6] Mihir Bellare and Phillip Rogaway. Entity
authentication and key distribution. In CRYPTO,
volume 773 of LNCS, pages 232–249. Springer, 1993.
[7] Bruno Blanchet, Mart´ın Abadi, and C´edric Fournet.
Automated veriﬁcation of selected equivalences for
security protocols. Journal of Logic and Algebraic
Programming, 75(1):3–51, February–March 2008.
[8] Rohit Chadha, ¸Stefan Ciobˆac˘a, and Steve Kremer.
Automated veriﬁcation of equivalence properties of
cryptographic protocols. In Helmut Seidl, editor,
ESOP, volume 7211 of LNCS, pages 108–127.
Springer, 2012.
[9] Vincent Cheval. APTE: An algorithm for proving
trace equivalence. In TACAS, volume 8413 of LNCS,
pages 587–592. Springer, 2014.
[10] Vincent Cheval and Bruno Blanchet. Proving more
observational equivalences with ProVerif. In Principles
of Security and Trust (POST), volume 7796 of LNCS,
pages 226–246. Springer, 2013.
[11] Vincent Cheval, V´eronique Cortier, and St´ephanie
Delaune. Deciding equivalence-based properties using
constraint solving. Theor. Comput. Sci., 492:1–39,
2013.
[12] St´ephanie Delaune, Steve Kremer, and Mark Ryan.
Verifying privacy-type properties of electronic voting
protocols. Journal of Computer Security, 17:435–487,
December 2009.
Ryan, and Graham Steel. Formal analysis of protocols
based on TPM state registers. In CSF, pages 66–80.
IEEE, 2011.
[14] Jannik Dreier, Pascal Lafourcade, and Yassine
Lakhnech. Deﬁning privacy for weighted votes, single
and multi-voter coercion. In ESORICS, volume 7459
of LNCS, pages 451–468. Springer, 2012.
[15] Jannik Dreier, Pascal Lafourcade, and Yassine
Lakhnech. A formal taxonomy of privacy in voting
protocols. In Proceedings of IEEE International
Conference on Communications (ICC’12), pages
6710–6715, Ottawa, ON, Canada, 2012. IEEE.
[16] Jannik Dreier, Pascal Lafourcade, and Yassine
Lakhnech. Formal veriﬁcation of e-auction protocols.
In Proceedings of the 2nd Conference on Principles of
Security and Trust (POST’13), volume 7796 of LNCS,
pages 247–266, Rome, Italy, 2013. Springer Verlag.
[17] Martin Feldhofer, Sandra Dominikus, and Johannes
Wolkerstorfer. Strong authentication for RFID
systems using the aes algorithm. In Cryptographic
Hardware and Embedded Systems-CHES 2004, pages
357–370. Springer, 2004.
[18] Mich`ele Feltz and Cas Cremers. On the limits of
authenticated key exchange security with an
application to bad randomness. Cryptology ePrint
Archive, Report 2014/369, 2014.
[19] Steve Kremer and Robert K¨unnemann. Automated
analysis of security protocols with global state. In
2014 IEEE Symposium on Security and Privacy, SP
2014, Berkeley, CA, USA, May 18-21, 2014, pages
163–178. IEEE Computer Society, 2014.
[20] Ralf K¨usters and Tomasz Truderung. Using ProVerif
to analyze protocols with Diﬃe-Hellman
exponentiation. In Computer Security Foundations
Symposium (CSF), pages 157–171. IEEE, 2009.
[21] Brian LaMacchia, Kristin Lauter, and Anton
Mityagin. Stronger security of authenticated key
exchange. In Provable Security, pages 1–16. Springer,
2007.
[22] Simon Meier, Benedikt Schmidt, Cas Cremers, and
David Basin. The TAMARIN Prover for the Symbolic
Analysis of Security Protocols. In CAV, volume 8044
of LNCS, pages 696–701. Springer, 2013.
[23] Sonia Santiago, Santiago Escobar, Catherine
Meadows, and Jos´e Meseguer. A formal deﬁnition of
protocol indistinguishability and its veriﬁcation using
Maude-NPA. In Security and Trust Management
(STM) 2014, pages 162–177. Springer, 2014.
[24] Benedikt Schmidt, Simon Meier, Cas Cremers, and
David Basin. Automated analysis of Diﬃe-Hellman
protocols and advanced security properties. In
Computer Security Foundations Symposium (CSF),
pages 78–94. IEEE, 2012.
[25] Alwen Tiu and Jeremy E. Dawson. Automating open
bisimulation checking for the spi calculus. In CSF,
pages 307–321. IEEE Computer Society, 2010.
[26] Ton Van Deursen, Sjouke Mauw, and Saˇsa
Radomirovi´c. Untraceability of RFID protocols. In
Information Security Theory and Practices. Smart
Devices, Convergence and Next Generation Networks,
pages 1–15. Springer, 2008.