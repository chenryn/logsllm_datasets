/* 
和 select 函数相比，poll 函数的改进之处主要就在于
它允许一次监听超过 1024 个文件描述符
 */
int poll (struct pollfd *__fds, nfds_t __nfds, int __timeout);
```
epoll 的优化点在于 epoll_wait 会返回就绪的描述符，而未就绪的描述符不返回
## 磁盘
磁盘驱动器不本身就包含一个微控制器，这允许磁盘驱动器发出一些诸如高速缓存、坏块重映射等高级命令
### 结构
![2020321928](/assets/2020321928.jpg)
- 盘面（Platter）：一个磁盘有多个盘面
- 磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道
- 扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小
- 磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）
- 制动手臂（Actuator arm）：用于在磁道之间移动磁头
- 主轴（Spindle）：使整个盘面转动
### RAID
Redundant Array of Independent Disks，独立磁盘冗余阵列。通过将多个磁盘组合起来，使用RAID控制器代替磁盘驱动器以完成常规的操作。
- RAID0：将磁盘划分为多个条带，若读取多个条带的数据，可以实现并行IO，但对于每次读取一个条带的操作系统，性能不仅同普通磁盘，而且还有故障率更高的风险
- RAID1: 在RAID0的基础上整个数据复制一份，写性能比单个磁盘差，但读性能很高，并且拥有容错性，一旦一个磁盘挂掉，使用副本代替即可
- RAID2：工作在字的基础上，使用了汉明码来进行纠错，即使一个磁盘挂掉，也能恢复出正确数据
- RAID3:在2的基础上，使用奇偶校验码。如果磁盘挂掉，由于挂掉的磁盘位置已知，所以可以推算出丢失的数据位为0还是0 2和3的性能都不比单个磁盘好
- RAID4:重新使用了条带，使用一个驱动器专门存放前面4个条带的奇偶校验。但这种设计对小更新的性能很差，因为每次更新都需要更新校验和。
- RAID5:在4的基础上将校验和平均分布到各个磁盘，但如果某个磁盘挂掉，那就不好恢复了
- RAID6：在5的基础上使用额外的校验块。
![屏幕截图 2021-01-15 161911](/assets/屏幕截图%202021-01-15%20161911.png)
### 磁盘格式化
低级格式化：对每个扇区设置前导码，ECC，由于前导码与ECC需要占用一定空间，所以可用磁盘容量总比宣传的小
↓
磁盘分区：0扇区包含主引导记录（MBR），MBR包含一些引导代码及分区表
↓
高级格式化：设置引导块、空闲存储管理、根目录、文件系统
_系统的启动流程：BIOS运行->读入MBR并跳转->执行引导程序->找到操作系统内核载入内存执行_
### 磁盘臂调度算法
读写磁盘块所需要的时间多少由以下三个因素决定：
- 旋转时间：主轴转动盘面，使得磁头移动到适当的扇区上需要的时间
- 寻道时间：制动手臂移动，使得磁头移动到适当的磁道上需要的时间
- 数据传输时间
调度算法：
- 先来先服务算法
  - 按照磁盘请求的顺序进行调度
  - 公平简单，但是没有对寻道做任何优化，平均寻道时间较长
- 最短寻道优先
  - 优先调度距距离磁头最近的磁道
  - 不够公平，如果一个请求距离当前磁头比较远，会出现饥饿现象
![屏幕截图 2021-01-18 151803](/assets/屏幕截图%202021-01-18%20151803.png)
- 电梯算法
  - 总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向
![20203219747](/assets/20203219747.png)
旋转时间与寻道时间十分影响性能，所以一次只读取一个或者两个扇区效率很低。现代的磁盘控制器都拥有高速缓存，每次读取多个扇区，并将其缓存。
### 错误处理
对于磁盘坏块的处理，可以在控制器或者在操作系统对他们进行处理。
在控制器中，处理的思想都是一样的，都是使用备用块来替代坏块。
而在操作系统级别进行处理，操作系统必须获的所有坏块列表，并将其进行重映射。
### 稳定存储器
保持磁盘的数据一致性。
- 稳定写：对每个磁盘驱动器轮流进行重复写操作
- 稳定读：如果有稳定写总是成功，并且一段时间内数据不会自己变坏的前提下，稳定写就总是成功的
- 崩溃恢复：当写的过程中发生崩溃，后续恢复的原则
  - 两块都是好的且一样，什么也不做
  - 一块有ECC错误，则好的覆盖掉有ECC错误的
  - 两块都是好的但不一样，用第一块覆盖第二块
![屏幕截图 2021-01-18 155800](/assets/屏幕截图%202021-01-18%20155800.png)
### Partial Stroking
磁盘的两个时间：
1. 平均延时：把盘面旋转，把几何扇区对准悬臂位置的时间
2. 平均寻道时间：盘面旋转之后，悬臂定位到扇区的的时间
磁盘转速越高，平均延时就更低，如果不进行寻道，就可以剩下寻道的时间，同时越在磁盘外圈的数据访问越快，相同的角速度下，越外圈线速度越快，同样的时间扫过的扇区就越多
## SSD
![不同的颗粒可以存储更多的数据，但同时也更慢](/assets/20227621357.webp)
SLC 的芯片，可以擦除的次数大概在 10 万次，MLC 就在 1 万次左右，而 TLC 和 QLC 就只在几千次
![SSD会进行磁盘整理](/assets/202276213632.webp)
### 磨损均衡
某些块写入比其他块更加频繁，这些块寿命会更短
![如果一个物理块被擦写的次数多了，FTL 就可以将这个物理块，挪到一个擦写次数少的物理块上](/assets/202276213917.webp)
### TRIM命令
为了避免磨损均衡在搬运很多已经删除了的数据，现在的操作系统和 SSD 的主控芯片，都支持 TRIM 命令。这个命令可以在文件被删除的时候，让操作系统去通知 SSD 硬盘，对应的逻辑块已经标记成已删除了
### 写入放大
当 SSD 硬盘的存储空间被占用得越来越多，每一次写入新数据，可能不得不去进行垃圾回收，合并一些块里面的页，然后再擦除掉一些页
解决写入放大，需要在后台定时进行垃圾回收，在硬盘比较空闲的时候，就把搬运数据、擦除数据、留出空白的块的工作做完
### 最大化SSD使用效率
AeroSpike 这个 KV 数据库利用了 SSD的一些特性来加快读写速度：
1. 尽可能去写一个较大的数据块，而不是频繁地去写很多小的数据块
2. 读取数据的时候就可以读取小数据，不用担心擦写寿命问题
3. 持续地进行磁盘碎片整理，一旦一个物理块里面的数据碎片超过 50%，就把这个物理块搬运压缩，然后进行数据擦除，确保磁盘始终有足够的空间可以写入，保 SSD 硬盘的写放大效应尽可能小
此外：
1. 对于SSD而言，没了HDD的寻址代价，随机读写和顺序读写性能类似，就地更新不会获得任何 IOPS 优
2. SSD对于空间局部性也没有优势，预取这种额外的数据访问，不仅会浪费 I/O 带宽，而且会不必要地磨损 SSD
3. SSD可以执行并行小IO充分利用内部的并行性
## 时钟
### 时钟硬件
可编程时钟：石英晶体每次震荡会将递减计数器，计数器到0时会触发一个中断，软件可以自定义这个计数器来实现对时钟的编程。
![屏幕截图 2021-01-18 160445](/assets/屏幕截图%202021-01-18%20160445.png)
- 一次完成模式：中断发生后等待软件显式启动
- 方波模式：中断一次之后，又重新开始循环
### 时钟软件
- 维护日时间
通过时钟来维护现在的时间，为了防止32位内存溢出，可以使用64位计数器，但代价过高。也可使用以秒为单位。
- 防止进程超时运行
时钟的每次中断就将时间片-1，当时间片为0，就得重新调度程序。
- 对CPU使用情况进行记账
每次滴答对进程表项的某个域+1来实现记录进程运行时间。
- 处理alarm系统调用
进程可以请求操作系统在一定的时间间隔后向它报警。
一个物理时钟为了模拟出多个时钟，可以通过维护一张表，每次时间发生更新就查找是否达到表中所需要的时刻，如果达到了，就进行触发。然后继续重复这个步骤。
- 为系统各部分提供监视定时器
检测死机之类的问题。如果操作系统可以定时清除计数器，当某个时刻计数器超过某个阈值，就可以确定已经死机了，此时软件介入处理。
- 完成信息收集
### 软定时器
IO有两种方式：中断和轮询。
现代CPU的中断开销是很大的，但轮询的响应时间又会比较高。
所以为了达到一个取舍，可以使用一个软定时器定时中断来进行IO。
## 外设
### 输入软件
#### 键盘软件
- 原始模式：向用户提供原始的ASCII码序列
- 加工模式：由键盘驱动处理全部行内编辑，将编辑结果存储在缓冲区回车后写入
#### 鼠标软件
鼠标发送的消息包含：$\Delta$x $\Delta$y 按钮 ，通常为3字节
鼠标单击与双击则是由GUI来进行区分的
### 输出软件
- 文本窗口
为了控制终端进行文字输出，程序使用了一种被称为“转义序列”的东西来控制终端。
- X窗口系统
- 图形用户界面
- 位图
- 字体
- 触摸屏
## 瘦客户机
## 电源管理
有两种方法减少电量消耗：
1. 关闭不用的某些计算机硬件
2. 使应用程序耗能更低
### 硬件问题
- 操作系统问题
  - 显示器
  - 硬盘
  - CPU
  - 内存
  - 无线通信
  - 热量管理
  - 电源管理
  - 驱动程序接口
- 应用程序问题
## 网络IO