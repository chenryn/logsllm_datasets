## 2. 方法表在介绍那篇类加载机制的链接部分中，我曾提到类加载的准备阶段，它除了为静态字段分配内存之外，还会构造与该类相关联的方法表。这个数据结构，便是 Java 虚拟机实现动态绑定的关键所在。下面我将以invokevirtual 所使用的虚方法表（virtual methodtable，vtable）为例介绍方法表的用法。invokeinterface所使用的接口方法表（interface methodtable，itable）稍微复杂些，但是原理其实是类似的。方法表本质上是一个数组，每个数组元素指向一个当前类及其祖先类中非私有的实例方法。这些方法可能是具体的、可执行的方法，也可能是没有相应字节码的抽象方法。方法表满足两个特质：其一，子类方法表中包含父类方法表中的所有方法；其二，子类方法在方法表中的索引值，与它所重写的父类方法的索引值相同。我们知道，方法调用指令中的符号引用会在执行之前解析成实际引用。对于静态绑定的方法调用而言，实际引用将指向具体的目标方法。对于动态绑定的方法调用而言，实际引用则是方法表的索引值（实际上并不仅是索引值）。在执行过程中，Java虚拟机将获取调用者的实际类型，并在该实际类型的虚方法表中，根据索引值获得目标方法。这个过程便是动态绑定。![](Images/92a9663a2c82226d603c43eb4fa92907.png){savepage-src="https://static001.geekbang.org/resource/image/f1/c3/f1ff9dcb297a458981bd1d189a5b04c3.png"}在我们的例子中，Passenger 类的方法表包括两个方法：-   toString-   passThroughImmigration，它们分别对应 0 号和 1 号。之所以方法表调换了 toString 方法和passThroughImmigration 方法的位置，是因为 toString 方法的索引值需要与Object 类中同名方法的索引值一致。为了保持简洁，这里我就不考虑 Object类中的其他方法。ForeignerPassenger 的方法表同样有两行。其中，0 号方法指向继承而来的Passenger 类的 toString 方法。1 号方法则指向自己重写的passThroughImmigration 方法。ChinesePassenger 的方法表则包括三个方法，除了继承而来的 Passenger 类的toString 方法，自己重写的 passThroughImmigration 方法之外，还包括独有的visitDutyFreeShops 方法。    Passenger passenger = ...passenger.passThroughImmigration();这里，Java虚拟机的工作可以想象为导航员。每当来了一个乘客需要出境，导航员会先问是中国人还是外国人（获取动态类型），然后翻出中国人/ 外国人对应的小册子（获取动态类型的方法表），小册子的第 1页便写着应该到哪条通道办理出境手续（用 1作为索引来查找方法表所对应的目标方法）。实际上，使用了方法表的动态绑定与静态绑定相比，仅仅多出几个内存解引用操作：访问栈上的调用者，读取调用者的动态类型，读取该类型的方法表，读取方法表中某个索引值所对应的目标方法。相对于创建并初始化Java 栈帧来说，这几个内存解引用操作的开销简直可以忽略不计。那么我们是否可以认为虚方法调用对性能没有太大影响呢？其实是不能的，上述优化的效果看上去十分美好，但实际上仅存在于解释执行中，或者即时编译代码的最坏情况中。这是因为即时编译还拥有另外两种性能更好的优化手段：内联缓存（inliningcache）和方法内联（method inlining）。下面我便来介绍第一种内联缓存。
## 3. 内联缓存内联缓存是一种加快动态绑定的优化技术。它能够缓存虚方法调用中调用者的动态类型，以及该类型所对应的目标方法。在之后的执行过程中，如果碰到已缓存的类型，内联缓存便会直接调用该类型所对应的目标方法。如果没有碰到已缓存的类型，内联缓存则会退化至使用基于方法表的动态绑定。在我们的例子中，这相当于导航员记住了上一个出境乘客的国籍和对应的通道，例如中国人，走了左边通道出境。那么下一个乘客想要出境的时候，导航员会先问是不是中国人，是的话就走左边通道。如果不是的话，只好拿出外国人的小册子，翻到第1 页，再告知查询结果：右边。在针对多态的优化手段中，我们通常会提及以下三个术语。1.  单态（monomorphic）指的是仅有一种状态的情况。2.  多态（polymorphic）指的是有限数量种状态的情况。二态（bimorphic）是多态的其中一种。3.  超多态（megamorphic）指的是更多种状态的情况。通常我们用一个具体数值来区分多态和超多态。在这个数值之下，我们称之为多态。否则，我们称之为超多态。对于内联缓存来说，我们也有对应的单态内联缓存、多态内联缓存和超多态内联缓存。单态内联缓存，顾名思义，便是只缓存了一种动态类型以及它所对应的目标方法。它的实现非常简单：比较所缓存的动态类型，如果命中，则直接调用对应的目标方法。多态内联缓存则缓存了多个动态类型及其目标方法。它需要逐个将所缓存的动态类型与当前动态类型进行比较，如果命中，则调用对应的目标方法。一般来说，我们会将更加热门的动态类型放在前面。在实践中，大部分的虚方法调用均是单态的，也就是只有一种动态类型。为了节省内存空间，Java虚拟机只采用单态内联缓存。前面提到，当内联缓存没有命中的情况下，Java虚拟机需要重新使用方法表进行动态绑定。对于内联缓存中的内容，我们有两种选择。一是替换单态内联缓存中的纪录。这种做法就好比CPU中的数据缓存，它对数据的局部性有要求，即在替换内联缓存之后的一段时间内，方法调用的调用者的动态类型应当保持一致，从而能够有效地利用内联缓存。因此，在最坏情况下，我们用两种不同类型的调用者，轮流执行该方法调用，那么每次进行方法调用都将替换内联缓存。也就是说，只有写缓存的额外开销，而没有用缓存的性能提升。另外一种选择则是劣化为超多态状态。这也是 Java虚拟机的具体实现方式。处于这种状态下的内联缓存，实际上放弃了优化的机会。它将直接访问方法表，来动态绑定目标方法。与替换内联缓存纪录的做法相比，它牺牲了优化的机会，但是节省了写缓存的额外开销。具体到我们的例子，如果来了一队乘客，其中外国人和中国人依次隔开，那么在重复使用的单态内联缓存中，导航员需要反复记住上个出境的乘客，而且记住的信息在处理下一乘客时又会被替换掉。因此，倒不如一直不记，以此来节省脑细胞。虽然内联缓存附带内联二字，但是它并没有内联目标方法。这里需要明确的是，任何方法调用除非被内联，否则都会有固定开销。这些开销来源于保存程序在该方法中的执行位置，以及新建、压入和弹出新方法所使用的栈帧。对于极其简单的方法而言，比如说 getter/setter，这部分固定开销占据的 CPU时间甚至超过了方法本身。此外，在即时编译中，方法内联不仅仅能够消除方法调用的固定开销，而且还增加了进一步优化的可能性，我们会在专栏的第二部分详细介绍方法内联的内容。
## 总结与实践今天我介绍了虚方法调用在 Java 虚拟机中的实现方式。虚方法调用包括 invokevirtual 指令和 invokeinterface指令。如果这两种指令所声明的目标方法被标记为 final，那么 Java虚拟机会采用静态绑定。否则，Java虚拟机将采用动态绑定，在运行过程中根据调用者的动态类型，来决定具体的目标方法。Java虚拟机的动态绑定是通过方法表这一数据结构来实现的。方法表中每一个重写方法的索引值，与父类方法表中被重写的方法的索引值一致。在解析虚方法调用时，Java虚拟机会纪录下所声明的目标方法的索引值，并且在运行过程中根据这个索引值查找具体的目标方法。Java 虚拟机中的即时编译器会使用内联缓存来加速动态绑定。Java虚拟机所采用的单态内联缓存将纪录调用者的动态类型，以及它所对应的目标方法。当碰到新的调用者时，如果其动态类型与缓存中的类型匹配，则直接调用缓存的目标方法。否则，Java虚拟机将该内联缓存劣化为超多态内联缓存，在今后的执行过程中直接使用方法表进行动态绑定。在今天的实践环节，我们来观测一下单态内联缓存和超多态内联缓存的性能差距。为了消除方法内联的影响，请使用如下的命令。    // Run with: java -XX:CompileCommand='dontinline,*.passThroughImmigration' Passengerpublic abstract class Passenger { abstract void passThroughImmigration();  public static void main(String[] args) {  Passenger a = new ChinesePassenger();Passenger b = new ForeignerPassenger();    long current = System.currentTimeMillis();    for (int i = 1; i `{=html}在程序正常执行的情况下，这段代码会在 try 代码块之后运行。否则，也就是try 代码块触发异常的情况下，如果该异常没有被捕获，finally代码块会直接运行，并且在运行之后重新抛出该异常。如果该异常被 catch 代码块捕获，finally 代码块则在 catch代码块之后运行。在某些不幸的情况下，catch 代码块也触发了异常，那么finally 代码块同样会运行，并会抛出 catch代码块触发的异常。在某些极端不幸的情况下，finally代码块也触发了异常，那么只好中断当前 finally代码块的执行，并往外抛异常。上面这段听起来有点绕，但是等我讲完 Java虚拟机的异常处理机制之后，你便会明白这其中的道理。
## 异常的基本概念在 Java 语言规范中，所有异常都是 Throwable 类或者其子类的实例。Throwable有两大直接子类。第一个是 Error，涵盖程序不应捕获的异常。当程序触发 Error时，它的执行状态已经无法恢复，需要中止线程甚至是中止虚拟机。第二子类则是Exception，涵盖程序可能需要捕获并且处理的异常。![](Images/3ca48039fda3af46807bcbfede6cc756.png){savepage-src="https://static001.geekbang.org/resource/image/47/93/47c8429fc30aec201286b47f3c1a5993.png"}Exception 有一个特殊的子类RuntimeException，用来表示"程序虽然无法继续执行，但是还能抢救一下"的情况。前边提到的数组索引越界便是其中的一种。RuntimeException 和 Error 属于 Java 里的非检查异常（uncheckedexception）。其他异常则属于检查异常（checked exception）。在 Java语法中，所有的检查异常都需要程序显式地捕获，或者在方法声明中用 throws关键字标注。通常情况下，程序中自定义的异常应为检查异常，以便最大化利用Java 编译器的编译时检查。异常实例的构造十分昂贵。这是由于在构造异常实例时，Java虚拟机便需要生成该异常的栈轨迹（stacktrace）。该操作会逐一访问当前线程的 Java栈帧，并且记录下各种调试信息，包括栈帧所指向方法的名字，方法所在的类名、文件名，以及在代码中的第几行触发该异常。当然，在生成栈轨迹时，Java 虚拟机会忽略掉异常构造器以及填充栈帧的 Java方法（Throwable.fillInStackTrace），直接从新建异常位置开始算起。此外，Java虚拟机还会忽略标记为不可见的 Java 方法栈帧。我们在介绍 Lambda的时候会看到具体的例子。既然异常实例的构造十分昂贵，我们是否可以缓存异常实例，在需要用到的时候直接抛出呢？从语法角度上来看，这是允许的。然而，该异常对应的栈轨迹并非throw 语句的位置，而是新建异常的位置。因此，这种做法可能会误导开发人员，使其定位到错误的位置。这也是为什么在实践中，我们往往选择抛出新建异常实例的原因。
## Java 虚拟机是如何捕获异常的？在编译生成的字节码中，每个方法都附带一个异常表。异常表中的每一个条目代表一个异常处理器，并且由from 指针、to 指针、target指针以及所捕获的异常类型构成。这些指针的值是字节码索引（bytecodeindex，bci），用以定位字节码。其中，from 指针和 to 指针标示了该异常处理器所监控的范围，例如 try代码块所覆盖的范围。target 指针则指向异常处理器的起始位置，例如 catch代码块的起始位置。     public static void main(String[] args) {  try {    mayThrowException();  } catch (Exception e) {    e.printStackTrace();  }}// 对应的 Java 字节码public static void main(java.lang.String[]);  Code:    0: invokestatic mayThrowException:()V    3: goto 11    6: astore_1    7: aload_1    8: invokevirtual java.lang.Exception.printStackTrace   11: return  Exception table:    from  to target type      0   3   6  Class java/lang/Exception  // 异常表条目 举个例子，在上图的 main 方法中，我定义了一段 try-catch 代码。其中，catch代码块所捕获的异常类型为 Exception。编译过后，该方法的异常表拥有一个条目。其 from 指针和 to 指针分别为 0 和3，代表它的监控范围从索引为 0 的字节码开始，到索引为 3的字节码结束（不包括 3）。该条目的 target 指针是6，代表这个异常处理器从索引为 6的字节码开始。条目的最后一列，代表该异常处理器所捕获的异常类型正是Exception。当程序触发异常时，Java虚拟机会从上至下遍历异常表中的所有条目。当触发异常的字节码的索引值在某个异常表条目的监控范围内，Java虚拟机会判断所抛出的异常和该条目想要捕获的异常是否匹配。如果匹配，Java虚拟机会将控制流转移至该条目 target 指针指向的字节码。如果遍历完所有异常表条目，Java虚拟机仍未匹配到异常处理器，那么它会弹出当前方法对应的 Java栈帧，并且在调用者（caller）中重复上述操作。在最坏情况下，Java虚拟机需要遍历当前线程 Java 栈上所有方法的异常表。finally 代码块的编译比较复杂。当前版本 Java 编译器的做法，是复制 finally代码块的内容，分别放在 try-catch代码块所有正常执行路径以及异常执行路径的出口中。![](Images/eefc7459a519bcb76b9426e2da6daac3.png){savepage-src="https://static001.geekbang.org/resource/image/17/06/17e2a3053b06b0a4383884f106e31c06.png"}针对异常执行路径，Java 编译器会生成一个或多个异常表条目，监控整个try-catch 代码块，并且捕获所有种类的异常（在 javap 中以 any指代）。这些异常表条目的 target 指针将指向另一份复制的 finally代码块。并且，在这个 finally 代码块的最后，Java编译器会重新抛出所捕获的异常。如果你感兴趣的话，可以用 javap 工具来查看下面这段包含了try-catch-finally代码块的编译结果。为了更好地区分每个代码块，我定义了四个实例字段：tryBlock、catchBlock、finallyBlock、以及methodExit，并且仅在对应的代码块中访问这些字段。    public class Foo {  private int tryBlock;  private int catchBlock;  private int finallyBlock;  private int methodExit;   public void test() {    try {      tryBlock = 0;    } catch (Exception e) {      catchBlock = 1;    } finally {      finallyBlock = 2;    }    methodExit = 3;  }}  $ javap -c Foo...  public void test();    Code:       0: aload_0       1: iconst_0       2: putfield      #20                 // Field tryBlock:I       5: goto          30       8: astore_1       9: aload_0      10: iconst_1      11: putfield      #22                 // Field catchBlock:I      14: aload_0      15: iconst_2      16: putfield      #24                 // Field finallyBlock:I      19: goto          35      22: astore_2      23: aload_0      24: iconst_2      25: putfield      #24                 // Field finallyBlock:I      28: aload_2      29: athrow      30: aload_0      31: iconst_2      32: putfield      #24                 // Field finallyBlock:I      35: aload_0      36: iconst_3      37: putfield      #26                 // Field methodExit:I      40: return    Exception table:       from    to  target type           0     5     8   Class java/lang/Exception           0    14    22   any   ... 可以看到，编译结果包含三份 finally 代码块。其中，前两份分别位于 try代码块和 catch 代码块的正常执行路径出口。最后一份则作为异常处理器，监控try 代码块以及 catch 代码块。它将捕获 try 代码块触发的、未被 catch代码块捕获的异常，以及 catch 代码块触发的异常。这里有一个小问题，如果 catch代码块捕获了异常，并且触发了另一个异常，那么 finally捕获并且重抛的异常是哪个呢？答案是后者。也就是说原本的异常便会被忽略掉，这对于代码调试来说十分不利。
## Java 7 的 Supressed 异常以及语法糖Java 7 引入了 Supressed异常来解决这个问题。这个新特性允许开发人员将一个异常附于另一个异常之上。因此，抛出的异常可以附带多个异常的信息。然而，Java 层面的 finally代码块缺少指向所捕获异常的引用，所以这个新特性使用起来非常繁琐。为此，Java 7 专门构造了一个名为 try-with-resources的语法糖，在字节码层面自动使用 Supressed异常。当然，该语法糖的主要目的并不是使用 Supressed异常，而是精简资源打开关闭的用法。在 Java 7 之前，对于打开的资源，我们需要定义一个 finally代码块，来确保该资源在正常或者异常执行状况下都能关闭。资源的关闭操作本身容易触发异常。因此，如果同时打开多个资源，那么每一个资源都要对应一个独立的try-finally代码块，以保证每个资源都能够关闭。这样一来，代码将会变得十分繁琐。      FileInputStream in0 = null;  FileInputStream in1 = null;  FileInputStream in2 = null;  ...  try {    in0 = new FileInputStream(new File("in0.txt"));    ...    try {      in1 = new FileInputStream(new File("in1.txt"));      ...      try {        in2 = new FileInputStream(new File("in2.txt"));        ...      } finally {        if (in2 != null) in2.close();      }    } finally {      if (in1 != null) in1.close();    }  } finally {    if (in0 != null) in0.close();  } Java 7 的 try-with-resources 语法糖，极大地简化了上述代码。程序可以在try 关键字后声明并实例化实现了 AutoCloseable接口的类，编译器将自动添加对应的 close() 操作。在声明多个 AutoCloseable实例的情况下，编译生成的字节码类似于上面手工编写代码的编译结果。与手工代码相比，try-with-resources还会使用 Supressed 异常的功能，来避免原异常"被消失"。    public class Foo implements AutoCloseable {  private final String name;  public Foo(String name) { this.name = name; }   @Override  public void close() {    throw new RuntimeException(name);  }   public static void main(String[] args) {    try (Foo foo0 = new Foo("Foo0"); // try-with-resources         Foo foo1 = new Foo("Foo1");         Foo foo2 = new Foo("Foo2")) {      throw new RuntimeException("Initial");    }  }} // 运行结果：Exception in thread "main" java.lang.RuntimeException: Initial        at Foo.main(Foo.java:18)        Suppressed: java.lang.RuntimeException: Foo2                at Foo.close(Foo.java:13)                at Foo.main(Foo.java:19)        Suppressed: java.lang.RuntimeException: Foo1                at Foo.close(Foo.java:13)                at Foo.main(Foo.java:19)        Suppressed: java.lang.RuntimeException: Foo0                at Foo.close(Foo.java:13)                at Foo.main(Foo.java:19) 除了 try-with-resources 语法糖之外，Java 7 还支持在同一 catch代码块中捕获多种异常。实际实现非常简单，生成多个异常表条目即可。    // 在同一 catch 代码块中捕获多种异常try {  ...} catch (SomeException | OtherException e) {  ...}
## 总结与实践今天我介绍了 Java 虚拟机的异常处理机制。Java 的异常分为 Exception 和 Error 两种，而 Exception 又分为RuntimeException 和其他类型。RuntimeException 和 Error属于非检查异常。其他的 Exception皆属于检查异常，在触发时需要显式捕获，或者在方法头用 throws 关键字声明。Java 字节码中，每个方法对应一个异常表。当程序触发异常时，Java虚拟机将查找异常表，并依此决定需要将控制流转移至哪个异常处理器之中。Java代码中的 catch 代码块和 finally 代码块都会生成异常表条目。Java 7 引入了 Supressed异常、try-with-resources，以及多异常捕获。后两者属于语法糖，能够极大地精简我们的代码。那么今天的实践环节，你可以看看其他控制流语句与 finally代码块之间的协作。     // 编译并用 javap -c 查看编译后的字节码public class Foo {  private int tryBlock;  private int catchBlock;  private int finallyBlock;  private int methodExit;   public void test() {    for (int i = 0; i `{=html}今天我们便来了解一下反射的实现机制，以及它性能糟糕的原因。如果你对反射API 不是特别熟悉的话，你可以查阅我放在文稿末尾的附录。