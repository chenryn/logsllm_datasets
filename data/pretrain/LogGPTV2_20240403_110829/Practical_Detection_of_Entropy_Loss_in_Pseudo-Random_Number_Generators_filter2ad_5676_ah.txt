I1
S1
R1
In
. . .
next
next
Sn
Rn
Figure 3.5 – Pseudo-Random Number Generator with Input [DHY02]
Deﬁnition 19 (Pseudo-Random Number Generator with Input [DHY02]). A pseudo-random
number generator with input is a couple of algorithms (key, next), where key is a probabilistic
algorithm that takes no input and outputs a key K ∈ {0, 1}n and an initial state S ∈ {0, 1}n,
next is a deterministic algorithm that, given the current state S, the key K and an auxiliary
input I ∈ {0, 1}p, outputs a pair (S0, R) ← next(S, K, I) where S0 ∈ {0, 1}n is the new state and
R ∈ {0, 1}‘ is the output.
Note that the model assumes the existence of an entropy pool in which entropy is accumulated
and that is used as input for algorithm key to generate the key K and a ﬁrst state S. However,
the model does not propose any secure way to accumulate entropy nor capture the potentially
adversarial inputs that may be accumulated. Also note that in Deﬁnition 19, the next algorithm
updates the state S while the key K is not updated.
They denoted their attacks as CIA, for Chosen-Input Attack, CSA, for Chosen-State Attack and
KKA, for Known-Key Attack. Under CIA, the key is hidden, the states are known, but not cho-
sen, and the auxiliary input may be chosen by the adversary. The attack CSA is similar, except
that the auxiliary inputs are not allowed to be chosen while the states may now be chosen. The
attack KKA is diﬀerent in that it allows the key to be known. However, under the attack KKA,
the states are hidden and the auxiliary inputs are not allowed to be chosen.
We now describe their security model. The security games CIA, CSA, KKA use procedures de-
scribed in Figure 3.6. In our description, we denote with i the counter on the auxiliary inputs
and with qr the maximal number of auxiliary inputs the generator is allowed to use. The proce-
dure initialize sets a random key K and a random state S with a call to algorithm key, generates
qr random inputs (I1,··· , Iqr) $← ({0, 1}p)qr, sets a counter i to 0 and sets a random Boolean
parameter b. After all oracle queries, A outputs a bit b∗, given as input to the procedure ﬁnalize,
which compares the response of A to the challenge bit b. The other procedures are deﬁned
below:
— 34 —
3.4. Security Model from [DHY02]
• The procedures getinput / setinput are used by A to get or set the value of the auxiliary
inputs.
• The procedures get-state / set-state are used by A to get or set the current value of the
internal state S.
• The procedure get-key is used by A to get the value of the key K.
• The procedure next-ror challenges A on its capability to distinguish the output of algorithm
next from random, where the real output (R0) is obtained with a call to algorithm next
and the random string (R1) is generated by the challenger. The counter i is incremented
during this procedure. Attacker A responds to the challenge with a bit b∗.
proc. initialize
(K, S) $← key;
(I1,··· , Iqr) $← ({0, 1}p)qr;
i ← 1;
$← {0, 1};
b
proc. ﬁnalize(b∗)
IF b = b∗ RETURN 1
ELSE RETURN 0
proc. getinput
OUTPUT Ii
proc. setinput(I∗)
Ii ← I∗
proc. get-state
OUTPUT S
proc. set-state(S∗)
S ← S∗
proc. next-ror
(S, R0) ← next(S, K, Ii)
R1
i ← i + 1
OUTPUT Rb
$← {0, 1}‘
proc. get-key
OUTPUT K
Figure 3.6 – Procedures in Security Games CIA, CSA, KKA
Deﬁnition 20 (Security of a Pseudo-Random Number Generator with Input [DHY02]). A
pseudo-random number generator with input (key, next) is called ((T = (t, qr), ε)- secure against
Chosen Input Attack (resp. Chosen State Attack or Known Key Attack), if for any adversary A
running in time at most t, that uses at most qr inputs, the advantage of A in game CIA, (resp.
CSA, KKA) is at most ε, where:
• CIA is the restricted game where A is not allowed to make calls to get-key and to set-state
and is allowed to make calls to get-state, setinput, getinput and next-ror.
• CSA is the restricted game where A is not allowed to make calls to get-key and to setinput
and is allowed to make calls to get-state, set-state, getinput and next-ror.
• KKA is the restricted game where A is not allowed to make calls to get-state, set-state and
setinput and is allowed to make calls to get-key, getinput and next-ror.
Hence all security notions allow adversary A to get the content of the auxiliary input through
procedure getinput. In addition, when A does not have access to the key K (through procedure
get-key), A can mount attacks CIA and CSA. Furthermore, when A has access to K, the state
S shall remain secret.
Comparison with previous models. If one drops procedures getinput, setinput, get-state,
set-state and get-key in the security game, the adversary A has only access to the next-ror
procedure. With this single procedure, the objective of the adversary is similar to the objective
in the security games PR and DCA, although the deﬁnition of the generator is diﬀerent.
Concerning input compromise, the model focuses on the diﬀerence between an adversary that
has access to the input (which is possible for all security notions) and an adversary that is able
to choose an input. When the key K remains secret, if A can choose the auxiliary input I, A
only has access to the state S and conversely, if A can choose the state S, A only has access to
— 35 —
Chapter 3. Security Models for Pseudo-random Number Generators
the auxiliary input I. However CIA is closely similar to IBA described in Section 3.2.2, as they
only diﬀer with the addition of procedure get-state for CIA; however, in CIA, the signiﬁcation of
get-state diﬀers from the same procedure in IBA, because in CIA, this procedure implies only a
partial compromise of the internal state (considered as the union of S and K), while in IBA this
procedure implies a complete compromise.
In addition, the adversary A has always access to procedure getinput, therefore CIA, CSA and
KKA can not be compared with FWD (which does not concern pseudo-random number generator
with input). If one wanted to add a deﬁnition of forward security that would be close to FWD,
forward security would be the restricted game where A is not allowed to make calls to getinput
and to setinput and is allowed to make one call to get-state followed with one call to get-key,
which are the two last calls A is allowed to make. However, this notion of forward security is
not described in [DHY02].
Finally, the get-key procedure allows A to get the value of the parameter key and the associated
security property KKA ensures that the generator remains safe even if this parameter key gets
compromised. This can be used to model pseudo-random number generator with input where
a public parameter is used, for instance to select from a family of functions to instantiate a
randomness extractor, as described in Section 2.6. The use of a public parameter that is the
seed of a randomness extractor is the basis of the security models of [BST03] and [BH05].
3.4.2 Secure Constructions
Desai et al. proposed constructions secure against CSA, CIA and KKA, that are based on existing
standard speciﬁcations (ANSI X9.17 [ANS85] and FIPS [DSS00]).
Construction Secure Against CSA and CIA. Let F a pseudo-random function. Let us use
algorithm key to generate a key K for F. This allows to deﬁne a function FK : {0, 1}n →
{0, 1}n and an associated pseudo-random number generator with input ANSI, in accordance
with [ANS85].
$← {0, 1}n; S0
$← {0, 1}n, returns (K, S0),
• ANSI.key : K
• ANSI.next(Si−1, K, Ii) : yi ← FK(Si−1 ⊕ FK(Ii)), Si ← FK(yi ⊕ FK(Ii)), returns (yi, Si).
Theorem 5 shows that if we model F as a pseudo-random function, as in Deﬁnition 13, then the
pseudo-random number generator with input ANSI is secure against CIA and CSA.
Theorem 5 (Security of ANSI [DHY02]). Let F : {0, 1}n × {0, 1}n → {0, 1}n a (t, 3qr, εF)-
pseudo-random function. Let ANSI be the pseudo-random number generator with input associated
to F, as described above. Then ANSI is
• ((t, qr), 2εF + qr(2qr−1)
2n
• ((t, qr), 2εF + (2qr−1)2
2n
) secure against CSA,
) secure against CIA.
As precised in [DHY02], if one models the generator with a pseudo-random permutation, as in
Deﬁnition 15, an additional term 3qr(3qr−1)
shall be added in the previous bounds. This is a
direct application of the ’PRF/PRP Switching Lemma’ (Lemma 5).
Construction Secure against KKA. Let F a pseudo-random function. Let us use algorithm
key to generate a key K for F. This allows to deﬁne a function FK : {0, 1}n → {0, 1}n and an
associated pseudo-random number generator with input FIPS in accordance with [DSS00]:
2n+1
• FIPS.key : K
$← {0, 1}n; S0
$← {0, 1}n, returns (K, S0),
— 36 —
3.5. Security Model From [BST03]
• FIPS.next(Si−1, K, Ii) : yi ← FK(Si−1 + Ii mod 2n), Si ← Si−1 + yi + 1 mod 2n, returns
(yi, Si).
Theorem 6 shows that if we model F as a pseudo-random function, as in Deﬁnition 13, then
the pseudo-random number generator with input FIPS is secure against KKA. The proof of
Theorem 6 is similar to the proof of Theorem 5.
Theorem 6 (Security of FIPS [DHY02]). Let F : {0, 1}n×{0, 1}n → {0, 1}n a (t, qr, εF)-pseudo-
random function. Let FIPS be the pseudo-random number generator with input associated to F,
as described above. Then FIPS is ((t, qr), εF + qr(qr−1)2
2n−1
Remark 1. The argument in [DHY02] to prove these theorems relies on the capability of the
adversary to ’cause collisions in the inputs to the functions computing the outputs or the next
states’. However, the independence between successive inputs can not be completely guaranteed,
therefore we are not conﬁdent with the bounds presented in these theorems.
)-secure against KKA.
Consider now the forward security of the generators ANSI and FIPS. As noticed, this security
notion is not part of the security model of [DHY02], however, one could formalize it at the
restricted game where A is not allowed to make calls to getinput and to setinput and is allowed
to make one call to get-state followed with one call to get-key, which are the two last calls A is
allowed to make. If one used this deﬁnition, then the generator ANSI is not forward secure, as the
complete compromise of state S and K allows adversary A to completely reverse the underlying
block cipher and therefore to compute past outputs. A similar attack can be mounted on the
generator FIPS.
3.5 Security Model From [BST03]
3.5.1 Description
Barak, Shaltiel and Tromer [BST03] deﬁned a resilient pseudo-random number generator with
input. They named their class of pseudo-random number generators with input ’True Random
Number Generators’.
Their objective is to model situations where the entropy source can be inﬂuenced by an adver-
sary who has partial control on it and to model a generator that will be secure against such an
adversary. This model is the ﬁrst that considers potentially adversarial inputs and the distribu-
tion of the inputs instead of their real values.
They intended to model the following scenario: a manufacturer designs a device whose output
is supposed to be a randomness source. Ideally, one would like the adversary not to be able
to inﬂuence the distribution of the randomness source at all. However, in a realistic setting an
adversary can have some control over the environment in which the device operates (tempera-
ture, voltage, frequency, timing, etc.), and it is possible that changes in this environment aﬀect
the source. In their model, they assumed that the adversary can control at most τ Boolean
properties of the environment, and can thus create at most 2τ diﬀerent environments. Their
deﬁnition of pseudo-random number generator with input is not explicitly given in [BST03], but
it simply corresponds to a stateless algorithm that takes two inputs, corresponding to the inputs
of a (k, ε)-resilient extractor, as given in Deﬁnition 5. This notion of extractor assumes the use
of a public parameter seed that shall be selected once for all and therefore can be pre-processed
and even hard-coded. The price for this is that the family F of k-sources is bounded. They
explicitly set the size of the family to 2τ.
— 37 —
Chapter 3. Security Models for Pseudo-random Number Generators
Deﬁnition 21 (Pseudo-Random Number Generator with Input [BST03]). A pseudo-random
number generator with input is an algorithm G that given a ﬁrst input I ∈ {0, 1}p and a second
input seed ∈ {0, 1}s, outputs G(I, seed) = R ∈ {0, 1}‘.
The associated security game allows an adversary A to choose a family of distributions F, of
size 2τ: F = {D1,··· ,D2τ}, such that for all i and all input I sampled with Di, I are k-sources
(H∞(I) ≥ k) for all i ∈ {1, . . . , 2τ}. The security game uses procedures described in Figure 3.7
and is explained below:
1. The procedure initialize allows A to set the family F, the challenger parses F as 2τ dis-
tributions D1,··· ,D2τ , sets the public parameter seed and sets the Boolean parameter b.
The parameter seed is given to the adversary A.
2. The procedure next-ror challenges A on its capability to distinguish the output of G from
random: A chooses a distribution Di ∈ F. Then the challenger samples an input I of
distribution Di and ﬁnally the challenger generates the real output (R0 = G(seed, I)) and
picks a random string (R1). The challenge Rb is returned to the adversary A.
3. Attacker A responds to the challenge with a bit b∗, which is compared with the previously
generated bit b by the challenger in procedure ﬁnalize.
proc. next-ror(i)
$← Di
I
R0 ← G(I, seed)
$← {0, 1}‘
R1
RETURN Rb
proc. initialize(F)
seed $← {0, 1}s;
parse F as {D1,··· ,D2τ}
$← {0, 1};
b
OUTPUT seed
proc. ﬁnalize(b∗)
IF b = b∗ RETURN 1
ELSE RETURN 0
Figure 3.7 – Procedures in Security Game BST-RES(τ)
Deﬁnition 22 (Resilience of Pseudo-Random Number Generator with Input [BST03]). A
pseudo-random number generator with input G : {0, 1}p × {0, 1}s → {0, 1}‘ is (t, τ, ε)-Resilient
if for any adversary running in time t, with probability (1 − ε) over the choice of seed, the
advantage of A in game BST-RES(τ) it at most ε.
Note that if one parses the family F as {D1,··· ,D2τ}, then for all i and all input I sampled
with Di, we have H∞(I) ≥ k for all i ∈ {1, . . . , 2τ}. Recall (Deﬁnition 5) that a function
Extract : {0, 1}p × {0, 1}s → {0, 1}‘ is a (k, ε)-resilient extractor if for all ﬁnite families of k-
sources F, with probability at least (1 − ε) over the choice of seed $← {0, 1}s, the distributions
(seed, Extract(X, seed)) and (seed,U‘) are ε-close, for all X ∈ F. Hence if G is a resilient extractor,
it is a resilient pseudo-random number generator with input.
Comparison with Previous Models.
In this security model, the adversary can choose a
high entropy distribution from a ﬁnite family of distributions. Once the distribution is chosen,
the extraction is processed and the adversary is challenged on its capacity to distinguish the
output of the extraction from random. This security property is closely related to the previous
security properties of IBA (from [KSWH98,Gut98]) and CIA (from [DHY02]), however they are
not equivalent as they are not based on the same deﬁnition of a generator. In particular, here
there is no equivalent to the getinput or setinput procedures, that allows A to get or set the input
given to the extractor. In fact, the security model shall be seen as an extension of the initial
— 38 —
3.5. Security Model From [BST03]
PR model, where the challenger has complete control on the generation of the ﬁrst internal
state, here, we give the adversary some control on this generation as we allow her to choose
the distribution from which the ﬁrst internal state will be generated. The composition of a
randomness extractor and a secure or forward-secure stateful pseudo-random number generator
will be the core of the work of Barak and Halevi in [BH05].
3.5.2 A Secure Construction
Barak, Shaltiel and Tromer proposed several constructions, based on pairwise independent hash
functions families. They proposed two results, that link the length of the parameter seed with the
number of distributions (2τ) that are chosen at the beginning of the security game BST-RES(τ),
with the min-entropy of the distribution k, with the size of the input p and with the size of the
output m.