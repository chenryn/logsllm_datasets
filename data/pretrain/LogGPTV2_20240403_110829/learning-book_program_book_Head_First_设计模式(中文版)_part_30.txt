般来说，宏命令的做法更优雅，也需
栈中取出最上层的命令，然后调用它
且，你也不能够把接收者当做参数传
要较少的新代码。
的undo（）方法。
给命令。
你现在的位置
227
---
## Page 264
队列请求
命令模式的更多用途：队列请求
命令可以将运算块打包（一个接收者和一组动作），
然后将它传来传去，就像是一般的对象一样。现在，
即使在命令对象被创建许久之后，运算依然可以被调
金今
用。事实上，它甚至可以在不同的线程中被调用。我
们可以利用这样的特性衍生一些应用，例如：日程安
实现命今接口的对
排（Scheduler）、线程池、工作队列等。
象被放进队列。
想象有一个工作队列：你在某一端添加命令，然后另
一端则是线程。线程进行下面的动作：从队列中取出一
个命令，调用它的execute（方法，等待这个调用完成，
然后将此命令对象丢弃，再取出下一个命令…
列
这样能有效地把运算限
制在围定数日的线程中
进行。
线程从队列中一个个地删
除命今对象，然后调用命
今对象的execate(）方法。一
显完成了，就金再去处理
下一个新的命今对象。
Thread
线程的
hreac
计算工作
BRAIN
请注意，工作队列类和进行计算的对象之间完全是解耦的。此刻
XPOWER
线程可能在进行财务运算，下一刻却在读取网络数据。工作队列
你认为Web服务器如何应用这样的队
对象不在乎到底做些什么，它们只知道取出命令对象，然后调用其
列方式？还能想到任何其他的应用
executeO方法。类似地，它们只要是实现命令模式的对象，就可以
吗？
放入队列里，当线程可用时，就调用此对象的executeO方法。
228
第6章
---
## Page 265
命令模式
命令模式的更多用途：日志请求
某些应用需要我们将所有的动作都记录在日志中，并能在系统死机之后，重新调
用这些动作恢复到之前的状态。通过新增两个方法（storeO、loadO），命令模式
就能够支持这一点。在Java中，我们可以利用对象的序列化（Serialization）实现
这些方法，但是一般认为序列化最好还是只用在对象的持久化上（persistence）。
要怎么做呢？当我们执行命令的时候，将历史记录储存在磁盘中。一旦系统死机，
我们就可以将命令对象重新加载，并成批地依次调用这些对象的execute0方法。
这种日志的方式对于遥控器来说没有意义，然而，有许多调用大型数据结构的
动作的应用无法在每次改变发生时被快速地存储。通过使用记录日志，我们可以
将上次检查点（checkpoint）之后的所有操作记录下来，如果系统出状况，从检
查点开始应用这些操作。比方说，对于电子表格应用，我们可能想要实现的错
误恢复方式是将电子表格的操作记录在日志中，而不是每次电子表格一有变化
就记录整个电子表格。对更高级的应用而言，这些技巧可以被扩展应用到事务
我们加入两个新方法。
（transaction）处理中，也就是说，一整群操作必须全部进行完成，或者没有进行
用来记录日志。
任何的操作。
在系统死机后，这些
对象会被重新加载。
死机
并以正确的次序执行。
恢复
当每个命今被执行
时，会被储存在磁
盘中。
你现在的位置
229
---
## Page 266
你的设计工具箱
设计箱内的工具
要点
你的工具箱开始变重了！在本章，我们加入了一个模式，这个模
命令模式将发出请求的对
式允许我们将动作封装成命令对象，这样一来就可以随心所欲地
象和执行请求的对象解
储存、传递和调用它们。
耦。
在被解耦的两者之间是通
00基础
过命令对象进行沟通的。
命令对象封装了接收者和
00原则
一个或一组动作。
装
调用者通过调用命令对象
封装变化
态
的execute(）发出请求，这
多用组合，少用继承
承
会使得接收者的动作被调
针对接口编程，不针对实现编
用。
程
为交互对象之间松耦合设计而
调用者可以接受命令当做
努力
参数，甚至在运行时动态
类应该对扩展开放，对修改关
地进行。
闭。
命令可以支持撤销，做法
依赖抽象，不要依赖具体类。
是实现一个undo0方法来回
当需要将发出请求的对象
和执行请求的对象解耦的
到execute(）被执行前的状
时候，使用命今模式。
态。
00模式
■宏命令是命令的一种简单
的延伸，允许调用多个命
令。宏方法也可以支持
位一个类Q套
销。
学性业式
命今模式—将请求封装成
实际操作时，很常见使
对象，这可以让你使用不同的
用“聪明”命令对象，也
请求、队列，或者日志请求来
就是直接实现了请求，
参数化其他对象。命今模式也
而不是将工作委托给接收
可以支持撤销操作。
者。
■命令也可以用来实现日志
和事务系统。
230
第6章
---
## Page 267
命令模式
是时候休息一下了。
这是另一个填字游戏，答案都是来自本章的英文词汇。
横排提示：
竖排提示：
3. The Waitress was one
1.Role of customer in the command pattern
4.A command
_a set of actions and a
2.Our first command object controlled this
receiver
5. Invoker and receiver are
7.Dr. Seuss diner food
6.Company that got us word of mouth business
8.Our favorite city
10. All commands provide this
9.Act as the receivers in the remote control
11. The cook and this person were definitely
13. Object that knows the actions and the
decoupled
receiver
12. Carries out a request
14.Another thing Command can do
16. Waitress didn't do this
15. Object that knows how to get things done
17. A command encapsulates this
你现在的位置》
231
---
## Page 268
习题解答
连连看
习题解答
请将餐厅的对象和方法对应到命令模式的相应名称。
餐厅
命令模式
女招待
Command
快餐厨师
exeeute()
orderUp()
client
订单
lnvoker
顾客
Receiver
take0rder()
setCommand()
public class GarageDoorOpenCommand imple
GarageDoor garageDoor;
public GarageDoorOpenCommand (GarageDoor garageDoor)
this.garageDoor = garageDoor;
public void execute () (
garageDoor,up () ;
syav
Light is on
Garage Door is Open
232
第6章
---
## Page 269
命令模式
为MacroCommand写下undoO方法。
练习
public class MacroCommand 1mp1e
pub1ic MacroCommand (Comnand [1
Command[]  commands;
ands)
习题解答
this,commands = comnands,
public void execute()(
for (int 1 = 0; i 1_(0=_I_3ut)_.01
commands [1] , undo () :
我们也会需要关闭按钮的命令，请在这里写下创
建它们的代码：
LightOffCommand 1ightOff = new LightoffCoemand (1ight);
StereooffCommand stereoOff - new StereoOffCommand(stereo);
TVOffCommand tvOff = new TVoffCommand (tv) ;
HottubOffCommand hottuboff = new HottuboffCommand (hottub) :
C
L
I
NVOKER
E
REENEGGSANDHAM
G
H
A
U
E
S
R
C
C
OMMAND
NDO
PDG
E
RE|Q
S
E
E
你现在的位置》
233
---
## Page 270
PDG
---
## Page 271
7适配器模式与外观模式
随遇而安
你认为读者会觉得我们正在赛
这就是我们专业的地方，我
马，而不是在照相馆内做做样子？
们可以让一件事情看起采像
是另一回事！
你的意思是说，这
不应该是一场足球
赛？
包装在这件外套里
我就变成了一个完全
不同的人！
在本章，我们将要进行一项任务，其不可能的程度，简直就
像是将一个方块放进一个圆洞中。听起来不可能？有了设计模式，就有
可能。还记得装饰者模式吗？我们将对象包装起来，赋予它们新的职责。而现在则是
以不同目的，包装某些对象：让它们的接口看起来不像自己而像是别的东西。为何要这
样做？因为这样就可以在设计中，将类的接口转换成想要的接口，以便实现不同的接
PDG
口。不仅如此，我们还要探讨另一个模式，将对象包装起来以简化其接口。
这是新的一章
235
---
## Page 272
到处都是适配器
我们周围的适配器
OO适配器是什么，你一定不难理解，因为现实中到处都是。比方说：
如果你需要在欧洲国家使用美国制造的笔记本电脑，你可能需要使用
一个交流电的适配器
欧洲壁式插座
交流电适配器
标准的交流电插头
C
美国制造的笔记本电脑
需要另一种接口。
欧洲壁式插座提供一个得到
电力的接口。
适配器将一种接口转换
成另一种接口。
你知道适配器的作用：它位于美式插头和欧式插座的中间，它的工作是将欧式插
座转换成美式插座，好让美式插头可以插进这个插座得到电力。或者也可以这么认
还有师
为：适配器改变了插座的接口，以符合美式笔记本电脑的需求。
某些交流电适配器相当简单，它们只是改变插座的形状来匹配你的插头，直接把
你能想到真实世界中
电流传送过去。但是有些适配器内部则是相当复杂，可能会改变电流符合装置的需
些连配器的例子？
求。
好了，这是真实世界的适配器，那面向对象适配器又是什么？其实，0O适配器和
PDG
真实世界的适配器扮演着同样的角色：将一个接口转换成另一个接口，以符合客户
的期望。
236
第7章
---
## Page 273
适配器模式
面向对象适配器
假设已有一个软件系统，你希望它能和一个新的厂商类库搭配使用，但是这个新厂商
所设计出来的接口，不同于旧厂商的接口：
现
有
统
的
这两个接口无法匹配，所以无法工作！
你不想改变现有的代码，解决这个问题（而且你也不能改变厂商的代码）。所以该怎
么做？这个嘛，你可以写一个类，将新厂商接口转接成你所期望的接口。
现
有
统
的
这个遥配器实现了你的类
所期望的接口。
而且这个适配器也能和厂
商的接口沟逐。
这个适配器工作起来就如同一个中间人，它将客户所发出的请求转换成厂商类能理解
的请求。
现
适
厂
想想看，还有什么解决方案。
系
商
可以不需“你”写“任何”额
有
统
类
外的代码来整合这个新的厂商
的
类：不如就请厂商自行提供这
个
个送配器类，您觉得怎么样！
不需改变代码
不需改变代码