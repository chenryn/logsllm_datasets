title:Linux Security Modules: General Security Support for the Linux Kernel
author:Chris Wright and
Crispin Cowan and
Stephen Smalley and
James Morris and
Greg Kroah-Hartman
USENIX Association
Proceedings of the
11th USENIX Security
Symposium
San Francisco, California, USA
August 5-9, 2002
© 2002 by The USENIX Association
Phone: 1 510 528 8649
FAX: 1 510 548 5738
THE ADVANCED COMPUTING SYSTEMS ASSOCIATION
All Rights Reserved
Email: PI:EMAIL
For more information about the USENIX Association:
WWW: http://www.usenix.org
Rights to individual papers remain with the author or the author's employer.
 Permission is granted for noncommercial reproduction of the work for educational or research purposes.
This copyright notice must be included in the reproduced paper. USENIX acknowledges all trademarks herein.
Linux Security Modules:
General Security Support for the Linux Kernel
Chris Wright and Crispin Cowan
WireX Communications, Inc.
PI:EMAIL, PI:EMAIL
Stephen Smalley
NAI Labs, Network Associates, Inc.
PI:EMAIL
James Morris
Intercode Pty Ltd
PI:EMAIL
Greg Kroah-Hartman
IBM Linux Technology Center
PI:EMAIL
Abstract
The access control mechanisms of existing mainstream
operating systems are inadequate to provide strong sys-
tem security. Enhanced access control mechanisms have
failed to win acceptance into mainstream operating sys-
tems due in part to a lack of consensus within the se-
curity community on the right solution. Since general-
purpose operating systems must satisfy a wide range of
user requirements, any access control mechanism inte-
grated into such a system must be capable of supporting
many different access control models. The Linux Secu-
rity Modules (LSM) project has developed a lightweight,
general purpose, access control framework for the main-
stream Linux kernel that enables many different access
control models to be implemented as loadable kernel
modules. A number of existing enhanced access control
implementations, including Linux capabilities, Security-
Enhanced Linux (SELinux), and Domain and Type En-
forcement (DTE), have already been adapted to use the
LSM framework. This paper presents the design and
implementation of LSM and discusses the challenges
in providing a truly general solution that minimally im-
pacts the Linux kernel.
1 Introduction
The critical role of operating system protection mech-
anisms in providing system security has been well-
understood for over thirty years, yet the access control
mechanisms of existing mainstream operating systems
are still inadequate to provide strong security [2, 39, 28,
17, 26, 6, 30]. Although many enhanced access control
models and frameworks have been proposed and imple-
mented [9, 1, 4, 41, 23, 10, 29, 37], mainstream oper-
ating systems typically still lack support for these en-
hancements. In part, the absence of such enhancements
is due to a lack of agreement within the security com-
munity on the right general solution.
Like many other general-purpose operating systems, the
Linux kernel only provides discretionary access controls
and lacks any direct support for enhanced access control
mechanisms. However, Linux has long supported dy-
namically loadable kernel modules, primarily for device
drivers, but also for other components such as ﬁlesys-
tems.
In principle, enhanced access controls could be
implemented as Linux kernel modules, permitting many
different security models to be supported.
In practice, creating effective security modules is prob-
lematic since the kernel does not provide any infrastruc-
ture to allow kernel modules to mediate access to ker-
nel objects. As a result, kernel modules typically re-
sort to system call interposition to control kernel op-
erations [18, 20], which has serious limitations as a
method for providing access control [41]. Furthermore,
these kernel modules often require reimplementing se-
lected kernel functionality [18, 20] or require a patch
to the kernel to support the module [10, 3, 15], reduc-
ing much of the value of modular composition. Hence,
many projects have implemented enhanced access con-
trol frameworks or models for the Linux kernel as kernel
patches [29, 37, 23, 32, 27].
At the Linux Kernel 2.5 Summit, the NSA presented
their work on Security-Enhanced Linux (SELinux) [29],
an implementation of a ﬂexible access control architec-
ture in the Linux kernel, and emphasized the need for
such support in the mainstream Linux kernel. Linus Tor-
valds appeared to accept that a general access control
framework for the Linux kernel is needed, but favored a
new infrastructure that would provide the necessary sup-
port to kernel modules for implementing security. This
approach would avoid the need to choose among the ex-
isting competing projects.
In response to Linus’ guidance, the Linux Security Mod-
ules (LSM) [45, 40] project has developed a lightweight,
general purpose, access control framework for the main-
stream Linux kernel that enables many different ac-
cess control models to be implemented as loadable ker-
nel modules. A number of existing enhanced access
control implementations, including POSIX.1e capabil-
ities [42], SELinux, and Domain and Type Enforcement
(DTE) [23], have already been adapted to use the LSM
framework.
The LSM framework meets the goal of enabling many
different security models with the same base Linux ker-
nel while minimally impacting the Linux kernel. The
generality of LSM permits enhanced access controls
to be effectively implemented without requiring kernel
patches. LSM also permits the existing security func-
tionality of POSIX.1e capabilities to be cleanly sepa-
rated from the base kernel. This allows users with spe-
cialized needs, such as embedded system developers, to
reduce security features to a minimum for performance.
It also enables development of POSIX.1e capabilities to
proceed with greater independence from the base kernel.
The remainder of this paper is organized as follows.
Section 2 elaborates on the problem that LSM seeks to
solve. Section 3 presents the LSM design. Section 4
presents the current LSM implementation. Section 5 de-
scribes the operational status of LSM, including testing,
performance overhead, and modules built for LSM so
far. Section 6 describes issues that arose during devel-
opment, and plans for future work. Section 7 describes
related work. Section 8 presents our conclusions.
• conceptually simple, minimally invasive, and efﬁ-
cient; and
• able to support the existing POSIX.1e capabilities
logic as an optional security module.
The various Linux security projects were primarily inter-
ested in ensuring that the security framework would be
adequate to permit them to reimplement their existing
security functionality as a loadable kernel module. The
new modular implementation must not cause any signif-
icant loss in the security being provided and should have
little additional performance overhead.
The core functionality for most of these security projects
was access control. However, a few security projects
also desired other kinds of security functionality, such as
security auditing or virtualized environments. Further-
more, there were signiﬁcant differences over the range
of ﬂexibility for the access controls. Most of the secu-
rity projects were only interested in further restricting
access, i.e. being able to deny accesses that would or-
dinarily be granted by the existing Linux discretionary
access control (DAC) logic. However, a few projects
wanted the ability to grant accesses that would ordinar-
ily be denied by the existing DAC logic; some degree
of this permissive behavior was needed to support the
capabilities logic as a module. Some security projects
wanted to migrate the DAC logic into a security module
so that they could replace it.
The “LSM problem” is to unify the functional needs of
as many security projects as possible, while minimizing
the impact on the Linux kernel. The union set of desired
features would be highly functional, but also so invasive
as to be unacceptable to the mainstream Linux commu-
nity. Section 3 presents the compromises LSM made to
simultaneously balance these conﬂicting goals.
2 The Problem: Constrained Design Space
3 LSM Design: Mediate Access to Kernel
Objects
The design of LSM was constrained by the practical and
technical concerns of both the Linux kernel developers
and the various Linux security projects. In email on the
topic, Linus Torvalds speciﬁed that the security frame-
work must be:
• truly generic, where using a different security
model is merely a matter of loading a different ker-
nel module;
The system call interface provides an abstraction for
userspace to interact with the kernel, and is a tempting
location to mediate access. In fact, no kernel modiﬁca-
tions are required to overwrite entries in the system call
lookup table, making it trivial to mediate this interface
using kernel modules [18, 19]. While this is an attrac-
tive feature, mediating the system call interface provides
limited value for a general purpose security framework
Figure 1: LSM Hook Architecture
such as LSM [41]. This level of mediation is not race-
free, may require code duplication, and may not ade-
quately express the full context needed to make security
policy decisions.
The basic abstraction of the LSM interface is to mediate
access to internal kernel objects. LSM seeks to allow
modules to answer the question “May a subject S per-
form a kernel operation OP on an internal kernel object
OBJ?”
LSM allows modules to mediate access to kernel objects
by placing hooks in the kernel code just ahead of the ac-
cess, as shown in Figure 1. Just before the kernel would
have accessed an internal object, a hook makes a call
to a function that the LSM module must provide. The
module can either let the access occur, or deny access,
forcing an error code return.
The LSM framework leverages the kernel’s existing
mechanisms to translate user supplied data — typically
strings, handles or simpliﬁed data structures — into in-
ternal data structures. This avoids time of check to time
of use (TOCTTOU) races [8] and inefﬁcient duplicate
look ups. It also allows the LSM framework to directly
mediate access to the core kernel data structures. With
such an approach, the LSM framework has access to the
full kernel context just before the kernel actually per-
forms the requested service. This improves access con-
trol granularity.
Given the constrained design space described in Sec-
tion 2, the LSM project chose to limit the scope of the
LSM design to supporting the core access control func-
tionality required by the existing Linux security projects.
Figure 2: Permissive LSM hook. This hook allows the security
policy to override a DAC restriction.
This limitation enabled the LSM framework to remain
conceptually simple and minimally invasive while still
meeting the needs of many of the security projects. It
also strengthened the justiﬁcation for adopting the LSM
framework into the Linux kernel, since the need for en-
hanced access controls was more generally accepted by
the kernel developers than the need for other kinds of
security functionality such as auditing.
A consequence of the “stay simple” design decision is
that LSM hooks are primarily restrictive: where the ker-
nel was about to grant access, the module may deny ac-
cess, but when the kernel would deny access, the module
is not consulted. This design simpliﬁcation exists largely
because the Linux kernel “short-circuits” many deci-
sions early when error conditions are detected. Provid-
ing for authoritative hooks (where the module can over-
ride either decision) would require many more hooks
into the Linux kernel.
However, the POSIX.1e capabilities logic requires the
ability to grant accesses that would ordinarily be denied
at a coarse level of granularity. In order to support this
logic as a security module, LSM provides some minimal
support for these permissive hooks, where the module
can grant access the kernel was about to deny. The per-
missive hooks are typically coupled with a simple DAC
check, and allow the module to override the DAC restric-
tion. Figure 2 shows a user access request where a failed
user ID check can be overridden by a permissive hook.
These hooks are limited to the extent that the kernel al-
ready consults the POSIX.1e capable() function.
Although LSM was not designed to explicitly sup-
port security auditing, some forms of auditing can be
supported using the features provided for access con-
trol. For example, many of the existing Linux security
projects provide support for auditing the access checks
performed by their access controls. LSM also enables
error checksDAC checksUser Level processlook up inodeopen system callaccess inodeExamine context.Grant or deny.Does request pass policy?LSM hookYes or No"OK with you?"Kernel spaceUser spaceLSM Module Policy EngineGRANT accessREQUEST accessyesDENY accessyesUID match?nonoDAC override?Permissive LSM hooksupport for this kind of auditing. Some security auditing
can also be supported via existing kernel modules by in-
terposing on system calls, as in the SNARE project [25].
Many security models require binding security attributes
to kernel objects. To facilitate this, LSM provides for
opaque security ﬁelds that are attached to various in-
ternal kernel objects (detailed in Section 4.1.1). How-
ever, the module is completely responsible for manag-
ing these ﬁelds, including allocation, deallocation, and
concurrency control.
Finally, module composition presented a challenge to
the LSM design. On the one hand, there clearly is a need
to compose some modules with complementary func-
tionality. On the other hand, fully generic security pol-
icy composition is known to be intractable [21]. There-
fore, LSM permits module stacking, but pushes most
of the work to the modules themselves. A module that
wishes to be stackable must itself export an LSM-like in-
terface, and make calls to subsequently loaded modules
when appropriate. The ﬁrst module loaded has ultimate
control over all decisions, determining when to call any
other modules and how to combine their results.
4 Implementation
This section describes the implementation of the LSM
kernel patch. It begins with an overview of the imple-
mentation that describes the types of changes made to
the kernel in Section 4.1. Sections 4.2 through 4.7 dis-
cuss the speciﬁc hooks for the various kernel objects or
subsystems.
4.1
Implementation Overview
The LSM kernel patch modiﬁes the kernel in ﬁve pri-
mary ways. First, it adds opaque security ﬁelds to cer-
tain kernel data structures, described in Section 4.1.1.
Second, the patch inserts calls to security hook func-
tions at various points within the kernel code, described
in Section 4.1.2. Third, the patch adds a generic secu-
rity system call, described in Section 4.1.3. Fourth, the
patch provides functions to allow kernel modules to reg-
ister and unregister themselves as security modules, de-
scribed in Section 4.1.4. Finally, the patch moves most
of the capabilities logic into an optional security module,
described in Section 4.1.5.
STRUCTURE
task struct
linux binprm
super block
inode
ﬁle
sk buff
net device
kern ipc perm Semaphore, Shared Memory Segment,
OBJECT
Task (Process)
Program
Filesystem
Pipe, File, or Socket
Open File
Network Buffer (Packet)
Network Device
msg msg
or Message Queue
Individual Message
Table 1: Kernel data structures modiﬁed by the LSM kernel patch
and the corresponding abstract objects.
4.1.1 Opaque Security Fields
The opaque security ﬁelds are void* pointers, which
enable security modules to associate security informa-
tion with kernel objects. Table 1 shows the kernel data
structures that are modiﬁed by the LSM kernel patch and
the corresponding abstract object.
The setting of these security ﬁelds and the management
of the associated security data is handled by the secu-
rity modules. LSM merely provides the ﬁelds and a set
of calls to security hooks that can be implemented by
the module to manage the security ﬁelds as desired. For
most kinds of objects, an alloc security hook and
a free security hook are deﬁned that permit the se-
curity module to allocate and free security data when
the corresponding kernel data structure is allocated and
freed. Other hooks are provided to permit the security
module to update the security data as necessary, e.g. a
post lookup hook that can be used to set security
data for an inode after a successful lookup operation.
It is important to note that LSM does not provide any
locking for the security ﬁelds; such locking must be per-
formed by the security module.
Since some objects will exist prior to the initialization
of a security module, even if the module is built into
the kernel, a security module must handle pre-existing
objects. Several approaches are possible. The simplest
approach is to ignore such objects, treating them as be-
ing outside of the control of the module. These objects
would then only be controlled by the base Linux access
control logic. A second approach is to traverse the kernel
data structures during module initialization, setting the
security ﬁelds for all pre-existing objects at this time.
This approach would require great care to ensure that
all objects are updated (e.g. an open ﬁle might be on a
UNIX domain socket awaiting receipt by a process) and
to ensure that appropriate locking is performed. A third
int vfs_mkdir(struct inode *dir,
struct dentry *dentry, int mode)
{
int error;
down(&dir->i_zombie);
error = may_create(dir, dentry);
if (error)
goto exit_lock;
error = -EPERM;
if (!dir->i_op || !dir->i_op->mkdir)
goto exit_lock;
mode &= (S_IRWXUGO|S_ISVTX);
error =
security_ops->inode_ops->mkdir(dir,
dentry, mode);
if (error)
goto exit_lock;
DQUOT_INIT(dir);
lock_kernel();
error = dir->i_op->mkdir(dir, dentry, mode);
unlock_kernel();
exit_lock:
up(&dir->i_zombie);
if (!error) {
inode_dir_notify(dir, DN_CREATE);
security_ops->inode_ops->post_mkdir(dir,
dentry, mode);
}
return error;
}
Figure 3: The vfs mkdir kernel function with one security hook
call to mediate access and one security hook call to manage the security
ﬁeld. The security hooks are marked by.
approach is to test for pre-existing objects on each use
and to then set the security ﬁeld for pre-existing objects
when needed.
LSM kernel patch has been applied. This kernel func-
tion is used to create new directories. Two calls to secu-
rity hook functions have been inserted into this function.
The ﬁrst hook call, security ops->inode ops-
>mkdir, can be used to control the ability to create new
directories. If the hook returns an error status, then the
new directory will not be created and the error status will
be propagated to the caller. The second hook call, se-
curity ops->inode ops->post mkdir, can be
used to set the security ﬁeld for the new directory’s in-
ode structure. This hook can only update the security
module’s state; it cannot affect the return status.
Although LSM also inserts a hook call into the Linux
kernel permission function, the permission hook
is insufﬁcient to control ﬁle creation operations because
it lacks potentially important information, such as the
type of operation and the name and mode for the new
ﬁle. Similarly, inserting a hook call into the Linux ker-