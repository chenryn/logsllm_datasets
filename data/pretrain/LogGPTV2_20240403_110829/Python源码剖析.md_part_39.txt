---
## Page 268
Python源码剖析
238
代码清单11-9
清单11-9）。
后，参数的默认值被直接写入到新的PyFrameobject对象的f_localsplus中（见代码
PyEval_EvalcodeEx同样也在代码清单11-8的[1]处创建了新的Pyprameobject对象，然
其函数参数中，argcount其实就是na的值，而kwcount就是nk的值，当然这里都是0。
PyEval_EvalCodenx( PyCodeObject *co, Pyobject *glabals,Pyobject *locals,
量的值。
传递了进去。至于这些信息有什么用，我们这里先按下不表，以后会详细考察。图11-16
Python虚拟机在调用PyEval_EvalcodeEx时，同时也将位置参数的信息和键参数的信息
时，我们还会遇到它。从fast=function中对pyEva1_EvalCodeEx的调用形式可以看到，
Pyobject
[ceval.o]
E= PyFrame_New(tstate
回到我们对函数参数默认值的剖析中，在下面列出的PyEval_EvaiCodeEx代码中，
PyEval_EvalcodeEx是一个非常重要的函数，在以后分析扩展位置参数和扩展键参数
第11章Python虚拟机中的函数机制
//[1]:创建PyFrameObject对象
Pyobi
PyThreadstate
register
register
register
returm: FyEval_EvalCodeEx(co, globals, (PyObject *)NULL,
7/这里获得函数参数默认值的信息（1.第一个默认值的地址，
Pyobjectargsyint angcount,
Pyobject
Pyobject
(argdefs I= NULL)
Pyobject
ject
一深度探索动态语言核心技术
=PyTuple_GET
（（PyTupleObject
Pyobject
Pyobiect*retval
PyFrameObject*E:
图11-16在func_2.py中第一次调用f时的函数参数信息
**kwS
PyFunetionGBT_CLosURE(func));
（*PPsack）-2*nk,nk，//键参数的信息
（*pDstack）-n，na，//位置参数的信息
*closure)
**defs, int defcount,
a.nd,
hu:
[cal1_function]:co_argcount=2,co_nlocals=2
>>>dfPy_Func（a=1，b=2）:
[call
*tstate =PyThreadState_GET(）:
7/画数欢认参数的信息
intkwcount，//键参数的信息
funa
paas
coglobals,locals）:
*)argdefs)->ob_size;
na=0,
**freevars:
nk=0,
//函数默认参数的信惠
7/位置参数的信息
2.跌认值的个数）
---
## Page 269
defg（a，b，c=1，a=2），如果调用函数时是如下的调用形式g（3，3，3），那么就不能
递了参数值，这里的m就是我们前面所说的一般位置参数的个数。
指定的参数个数时，说明Python虚拟机需要为函数设定默认参数。
参数
参数。
代码清单11-9的[4]处确定要从哪个默认位置参数开始设定参数的默认值。考虑函数
代码清单11-9的[3]处的判断是为了保证一般位置参数在函数被调用时，
在代码清单11-9的[2]处，Pyhon虚拟机完成了是否需要设置默认参数值的判断，当
在对默认参数的讨论中，我们将位置参数继续细分为两类：一般位置参数和默认位置
1f(co->co_argcount >O 1co->Co_flags&(CO_VARARGS丨 CO_VARKEYWORDS））
returh
retval
fastlocals
默认位置参数是指指定了默认值的位置参数，而没有指定默认值的则称为一般位置
7/n为CALL_EUNCTION的参数指示的传入的位盖参数个数，即na，这里为0
nt n = argcount;
inti：
/[21：判断是否使用参数的账认值
I retval;
/151:
else
//141：n>意味着调用者希望替换一些默认位置参数的默认值
7A131:
(argcount
for
PyEval_EvalRrameRx(f,o);
设置默认位置参数的默认值
函数调用者必须传进一般位置参数的参教值
OF
goto fail;
SETLOCAL(m+i,def）：
(GETLOCAL（m）
(GEPLOCAL（1)
Pyobject
=argcount;
Y_INCRER(def);
def
defcount;
Python源码剖析
11.4
函数参数的实现
一深度探索动态语言核心技术
由调用者传
239
---
## Page 270
Python源码剖析
11.4.4.2
240
机进入PyEval_EvalCodeEx时各个参数的意义。
na的值，而kwcount其实就是nk的值。我们在图11-18中更细致地展现了当Pyhon虚拟
EyalCodeEx。之前我们已经说过，PyEval_EvalCodeEx的参数中，argcount其实就是
经知道，这意味着na=0，而nk=1，这一点在图11-17中非常清晰地展示了出来。
对象3依次压入了运行时栈。同时，CALL_FUNCTION的指令参数变为了256，我们现在已
在CALL_FUNcTIoN之前，Python虚拟机将PyStringObject 对象“b”和PyIntObject
默认值的。第二次调用函数主时，调用形式中的参数形式和键参数的形式是一致的。所以
数时，为默认位置参数传递了一个参数值后，Pyuon虚拟机是如何用我们传递的值来替换
列表的最右端开始，必须连续设置。
这和Pyton中设置函数参数默认值的规则是一致的，即：函数参数的默认值从函数参数
默认值的默认位置参数的位置开始，依次向后，而这个位置之前的参数都不用设置默认值，
f_1ocalsplus中设置默认值的位置，这个i的值有一点值得注意，它从第一个需要设置
放入pyFrameobject对象的f_localsplus所管理的内存块中。在[5]处，i指示了需要在
是这些默认位置参数不需要再设置默认值了
中，有多少个参数不是用于一般位置参数的，那这些参数自然是用于默认位置参数的。于
参数的个数，而m表示一般位置参数的个数，那么n-m就指示了在函数调用时传递的参数
为参数c设置默认参数了，只能对a设置默认参数，由于n代表了函数调用时传递的位置
在fast_function中，Pyhon虚拟机同样不会选择快速通道，而是会进入PyEval
在对王进行第二次调用时，我们重新设置了参数b的值，以此来观察当我们在调用函
当最终需要设置默认值的参数个数确定之后，Python虚拟机会在代码清单11-9的[5]
第11章Python虚拟机中的函数机制
函数f的第二次调用
一深度探索动态语言核心技术
图11-17在func_2.py中第二次调用f时的函数参数信息
(Z=qT=D）ounaAagepco_argcount;j++)
20)
ws[2*1
Python源码剖析
11:
PyFunctionObjec对象
func_defaults
*globals
11.4
>co_varnames,
函数参数的实现
深度探索动态语言核心技术
CO_VARKEYWORDS)
Pyobject *locals,
nm,
defcount=2
PY_EO;
tuple
defs
241
---
## Page 272
Python源码剖析
242
认值的默认位置参数设置默认值的for循环，值得注意的是，这个for循环中设置函数参
b对应的位置设置为3
co_argcount将不成立，最后终于来到我们苦苦寻找的地方，在代码清单11-10的[4]处的
在函数对应的pycodeobject对象中的co_varnames中查找“”，图11-19显示了函数
对象“b”，而value为ryIntobject对象3在代码清单11-10的[2]处的or循环中，会
的值。下面我们结合函数的第二次调用来看看这个过程。
序号信息直接设置_localsplus中的内存，这就为默认位置参数设置了函数调用者希望
数的顺序排列的。所以在co_varnames中搜索到键参数名字后，我们可以根据所得到的
f_localsplus所维护的内存中，用于存储函数参数的内存也是按照def语句中出现的参
的aef语句中出现的参数的顺序是一致的。而且我们知道，在pyFrameObject对象的
co_varnamtes中进行查找。最妙的是，在co_va.rnames中记录的变量名的顺序与在函数
PyEval_EvalCodeEx中就能利用运行时栈中保存的键参数的名字在Python编译时得到的
虚拟机在执行CALL_FUNCTION指令前会将键参数的名字压入运行时栈，那么我们在
都记录在变量名表（co_varnames）中。由于我们已经看到，在（b=3）的指令序列中，Python
代码清单11-10的[5]处的o循环是我们在11.4.1节中就看到过的那个为需要设置默
在代码清单11-10的[1]处的for循环中，i为0时，就有keyword为pyStringobjedt
显然，在序号1处，这个查找动作将成功。而这时j的值正是这个序号1。在图11-17
这里算法的基本思想是：在编译时，Pyhon会将函数的def语句中出现的参数的名称
第11章Python虚拟机中的函数机制
for
//[5]：设置跌认位置参数的默认值
一深度探索动态语言核心技术
(GETLOCAL(m+i)
SETLOCAL(m+1,
PyObiect*def
SETLOCAL(,
INCREF（def):
defcount:
图11-19函数f的变量名表
value);
det):
defslil
NULL)
---
## Page 273
11.4.5
时才会出现这种情况。这种情况意味出现了一个键参数，这个键参数的名字没有在函数的
始的默认参数2。
_1ocalsplus[1]这个位置所代表的参数b已经被设置为3了，所以不会再次设置为b原
co_argcount的值已经不再相同了。从它们的差异我们猜测，扩展位置参数*1st和扩展
进入对扩展键参数的剖析。
de语句中出现，显然，答案已经呼之欲出了，它一定就是扩展键参数。下一节我们就将
数的默认值的动作只有在条件GETLOCAL（m+i）=NULL成立的情况下才能发生，对于
看过了几次，对其中一些变量已经有些熟悉了。下面我们先来看看对扩展位置参数的处理
的指令序列应该很熟悉了，这里就不再列出，仅仅考察与参数相关的重要变量的值。
将深入地剖析Pyhon是如何实现扩展位置参数和扩展键参数的。
*1ist是由PyTupleobject实现的，而**key是由PyDietobject对象实现的。在本节中，
键参数**key，实际是作为一个局部变量来实现的。同时，我们还猜测，在Pyton内部，
个数的变量的值。在那里，我们发现，在函数内部没有使用局部变量时，co_nlocals和
代码清单11-11
[ceval.c]
（见代码清单11-11）
Pyobject
图11-20展示了我们考察的例子。现在我们对图11-20中的函数调用能编译出什么样
扩展位置参数和扩展键参数
*locals,
在11.4.1节的例3和例4中，我们看到了使用扩展位置参数和扩展键参数时指示参数
在代码清单11-10的[3]处，我们看到一个奇特的判断，在什么情况下会出现于>co->
至此，Pyuon中函数的默认参数机制终于大白于天下。
Pyuhon虚拟机的执行路径最终将进入PyEva1_EvalcodeEx，这个函数我们之前已经
Pyobject defs,inE defdount
Pyobject
Pyobject
PyEval_EvalcodeEx(PyCodeobject*co,Pyobject*globals,PyObject
[call_function]:co_argcount=l,co_nlocal=3
KWS
kargs,
图11-20带扩展位置参数和扩展键参数的例子
int
int argcount;
kwaount,
=3
8=3
/健参数相关信息
Python源码剖析