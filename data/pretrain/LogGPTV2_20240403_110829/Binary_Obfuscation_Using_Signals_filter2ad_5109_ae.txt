bytes” inserted by our obfuscator. The outliers in this
ﬁgure might serve as starting points for an attacker, but
there are dozens of such points, they correspond to thou-
sands of actual opcode pairs in the program, and there is
no obvious pattern.
In summary, the individual opcodes and pairs of adja-
cent opcodes have approximately similar distributions in
both unobfuscated and obfuscated programs. Thus, our
obfuscation method is on balance quite stealthy.
6 Related Work
The earliest work on the topic of binary obfuscation that
we are aware of is by Cohen, who proposes overlapping
adjacent instructions to fool a disassembler [7]. We are
not aware of any actual implementations of this proposal,
and our own experiments with this idea proved to be dis-
appointing. More recently, we described an approach to
make binaries harder to disassemble using a combination
of two techniques: the judicious insertion of “junk bytes”
to throw off disassembly; and the use of a device called
“branch functions” to make it harder to identify branch
targets [20]. These techniques proved effective at thwart-
ing most disassemblers, including the commercial IDA
Pro system. Conceptually, this paper can be seen as ex-
tending this work by disguising control transfer instruc-
tions and inserting misleading control transfers. More re-
cently, we described a way to use signals to disguise the
instruction used to make system calls (‘int$0x80’ in In-
tel x86 processors), with the goal of preventing injected
malware code from ﬁnding and executing system calls;
this work required kernel modiﬁcations. By contrast, the
work described in this paper is applicable to arbitrary
control transfers in programs and does not require any
changes to the kernel. These two differences lead to sig-
niﬁcant differences between the two approaches in terms
of goals, techniques, and effects.
There has been some recent work by Kapoor [14] and
Kruegel et al. [15] focusing on disassembly techniques
aimed speciﬁcally at obfuscated binaries. They work
around the possibility of “junk bytes” inserted in the in-
struction stream by producing an exhaustive disassem-
bly for each function, i.e., where a recursive disassem-
286
16th USENIX Security Symposium
USENIX Association
Unobfuscated
Obfuscator
Unobfuscated
IDA Pro
jc-jump
jc-push
jmp-jc
jc-pop
ret-jc
div-jc
mov-div
push-other
leave-push, leave-mov
s
r
i
a
p
n
o
i
t
c
u
r
t
s
n
i
f
o
%
10.00
1.00
0.10
0.01
s
r
i
a
p
n
o
i
t
c
u
r
t
s
n
i
f
o
%
10.00
1.00
0.10
0.01
Opcode pairs
(a) Actual
Opcode pairs
(b) Inferred (IDA Pro)
Figure 8: Obfucation Stealth II: Distribution of Opcode Pairs
bly is produced starting at every byte in the code for that
function. This results in a set of alternative disassem-
blies, not all of which are viable. The disassembler then
uses a variety of heuristic and statistical reasoning to rule
out alternatives that are unlikely or impossible. To our
knowledge, these exhaustive disassemblers are the most
sophisticated disassemblers currently available. One of
the “attack disassemblers” used for our experiments is
an implementation of Kruegel et al.’s exhaustive disas-
sembler.
There is a considerable body of work on code obfus-
cation that focuses on making it harder for an attacker
to decompile a program and extract high level semantic
information from it [9, 10, 31, 32]. Typically, these au-
thors rely on the use of computationally difﬁcult static
analysis problems—e.g., involving complex Boolean ex-
pressions, pointers, or indirect control ﬂow—to make it
harder to construct a precise control ﬂow graph for a pro-
gram. Our work is orthogonal to these proposals, and
complementary to them. We aim to make a program
harder to disassemble correctly, and to thereby sow un-
certainty in an attacker’s mind about which portions of a
disassembled program have been correctly disassembled
and which parts may contain disassembly errors. If the
program has already been obfuscated using any of these
higher-level obfuscation techniques, our techniques add
an additional layer of protection that makes it even harder
to decipher the actual structure of the program.
Even greater security may be obtained by maintain-
ing the software in encrypted form and decrypting it as
needed during execution, as suggested by Aucsmith [1];
or by using specialized hardware, as discussed by Lie et
al. [19]. Such approaches have the disadvantages of high
performance overhead (in the case of runtime decryption
in the absence of specialized hardware support) or a loss
of ﬂexibility because the software can no longer be run
on stock hardware.
7 Conclusions
This paper has described a new approach to obfuscating
executable binary programs and evaluated its effective-
ness on programs in the SPECint-2000 benchmark suite.
Our goals are to make it hard for disassemblers (and hu-
mans) to ﬁnd the real instructions in a binary and to give
them a mistaken notion of the actual control ﬂow in the
program. To accomplish these goals, we replace many
control transfer instructions by traps that cause signals,
inject signal handling code that actually effects the orig-
inal transfers of control, and insert bogus code that fur-
ther confuses disassemblers. We also use randomization
to vary the code we insert so it does not stand out.
These obfuscations confuse even the best disassem-
blers. On average, the GNU objdump program [24]
misunderstands over 43% of the original instructions,
over-reports the control ﬂow edges by 71%, and misses
63% of the original control ﬂow edges. The IDA Pro
system [11], which is considered the best commercial
disassembler, fails to disassemble 57% of the original in-
structions, over-reports control ﬂow edges by 41%, and
under-reports control ﬂow edges by 85%. A recent dis-
USENIX Association
16th USENIX Security Symposium
287
assembler [15] that has been designed to deal with ob-
fuscated programs fails to disassemble over 55% of the
instructions, over-reports control ﬂow edges by 27%, and
under-reports control ﬂow edges by over 60%.
These results indicate that we successfully make it
hard to disassemble programs, even when we only ob-
fuscate code that is in cold code blocks. If we obfuscate
more of the code, we can confuse disassemblers even
more. However, our obfuscation method slows down
program execution, so there is a tradeoff between the de-
gree of obfuscation and execution time. When we ob-
fuscate only cold code blocks, the average slow-down is
21%, and this result is skewed by three benchmarks for
which the training input is not a very good predictor for
execution on the reference input. On many programs,
the slowdown is negligible. An interesting possibility—
which we have not explored but could easily add to our
obfuscator—would be selectively to obfuscate some of
the hot code, e.g., that which the creator of the code es-
pecially wants to conceal.
Acknowledgements
We are grateful to Christopher Kruegel for the use of
the code for his exhaustive disassembler for our exper-
iments.
References
[1] D. Aucsmith. Tamper-resistant software: An im-
plementation. In Information Hiding: First Inter-
national Workshop: Proceedings, volume 1174 of
Lecture Notes in Computer Science, pages 317–
333. Springer-Verlag, 1996.
[2] Black Fenix. Black fenix’s anti-debugging tricks.
http://in.fortunecity.com/
skyscraper/browser/12/sicedete.html.
[3] S. Cesare. Linux anti-debugging techniques (fool-
ing the debugger), January 1999. VX Heavens.
http://vx.netlux.org/lib/vsc04.html.
[4] M. Christodorescu, S. Jha, S. A. Seshia, D. Song,
and R. E. Bryant. Semantics-aware malware detec-
tion. In Proc. 2005 IEEE Symposium on Security
and Privacy (Oakland 2005), pages 32–46, May
2005.
[5] C. Cifuentes. Reverse Compilation Techniques.
PhD thesis, Queensland University of Technology,
Australia, July 1994.
[6] C. Cifuentes and K. J. Gough. Decompilation of
binary programs. Software—Practice and Experi-
ence, 25(7):811–829, July 1995.
program evolution,
[7] F. B. Cohen.
through
Operating system protec-
tion
1992.
http://all.net/books/IP/evolve.html.
[8] R. S. Cohn, D. W. Goodwin, and P. G. Lowney. Op-
timizing Alpha executables on Windows NT with
Spike. Digital Technical Journal, 9(4):3–20, 1997.
[9] C. Collberg and C. Thomborson. Watermarking,
tamper-prooﬁng, and obfuscation – tools for soft-
IEEE Transactions on Software
ware protection.
Engineering, 28(8), August 2002.
[10] C. Collberg, C. Thomborson, and D. Low. Break-
ing abstractions and unstructuring data structures.
In Proc. 1998 IEEE International Conference on
Computer Languages, pages 28–38.
[11] DataRescue sa/nv, Li´ege, Belgium.
IDA Pro.
http://www.datarescue.com/idabase/.
[12] M. L. Fredman, J. Koml´os, and E. Szemer´edi. Stor-
ing a sparse table with O(1) worst case access time.
Journal of the ACM, 31(3):538–544, July 1984.
[13] C. R. Hollander. Decompilation of object pro-
grams. PhD thesis, Stanford University, 1973.
[14] A. Kapoor. An approach towards disassembly of
malicious binaries. Master’s thesis, University of
Louisiana at Lafayette, 2004.
[15] C. Kruegel, W. Robertson, F. Valeur, and G. Vigna.
Static disassembly of obfuscated binaries. In Proc.
13th USENIX Security Symposium, August 2004.
[16] C. Kr¨ugel, E. Kirda, D. Mutz, W. Robertson, and
G. Vigna. Polymorphic worm detection using struc-
In Recent Ad-
tural information of executables.
vances in Intrusion Detection, volume 3858 of Lec-
ture Notes in Computer Science, pages 207–226.
Springer, 2005.
[17] E. U. Kumar, A. Kapoor, and A. Lakhotia. DOC –
answering the hidden ‘call’ of a virus. Virus Bul-
letin, April 2005.
[18] A. Lakhotia, E. U. Kumar, and M. Venable. A
method for detecting obfuscated calls in malicious
binaries. IEEE Transactions on Software Engineer-
ing, 31(11):955–968, 2005.
[19] D. Lie, C. Thekkath, M. Mitchell, P. Lincoln,
D. Boneh, J. Mitchell, and M. Horowitz. Archi-
tectural support for copy and tamper resistant soft-
In Proc. 9th. International Conference on
ware.
288
16th USENIX Security Symposium
USENIX Association
Architectural Support for Programming Languages
and Operating Systems (ASPLOS-IX), pages 168–
177, November 2000.
[20] C. Linn and S.K. Debray. Obfuscation of exe-
cutable code to improve resistance to static disas-
sembly. In Proc. 10th. ACM Conference on Com-
puter and Communications Security (CCS 2003),
pages 290–299, October 2003.
[21] C. M. Linn, M. Rajagopalan, S. Baker, C. Collberg,
S. K. Debray, and J. H. Hartman. Protecting against
unexpected system calls. In Proc. Usenix Security
’05, pages 239–254, August 2005.
[22] R. Muth and S. K. Debray. On the complex-
In Proc.
ity of ﬂow-sensitive dataﬂow analyses.
27th ACM Symposium on Principles of Program-
ming Languages (POPL-00), pages 67–80, January
2000.
[23] R. Muth, S. K. Debray, S. Watterson, and K. De
Bosschere. alto : A link-time optimizer for the
Compaq Alpha. Software—Practice and Experi-
ence, 31:67–101, January 2001.
[24] Objdump.
Software
GNU Manuals Online.
GNU
Foundation.
Project—Free
www.gnu.org/manual/binutils-2.10.1/
html chapter/binutils 4.html.
[25] M. Prasad and T. Chiueh. A binary rewriting de-
fense against stack based buffer overﬂow attacks.
In Proc. USENIX Technical Conference, June 2003.
[26] B. Schwarz, S. K. Debray, and G. R. Andrews. Dis-
In Proc.
assembly of executable code revisited.
IEEE 2002 Working Conference on Reverse Engi-
neering (WCRE), pages 45–54, October 2002.
[27] P. K. Singh, M. Mohammed, and A. Lakhotia. Us-
ing static analysis and veriﬁcation for analyzing
virus and worm programs. In Proc. 2nd. European
Conference on Information Warfare, June 2003.
[28] R. L. Sites, A. Chernoff, M. B. Kirk, M. P. Marks,
and S. G. Robinson. Binary translation. Communi-
cations of the ACM, 36(2):69–81, February 1993.
[29] A. Srivastava and D. W. Wall. A practical sys-
tem for intermodule code optimization at link-time.
Journal of Programming Languages, 1(1):1–18,
March 1993.
[30] H. Theiling. Extracting safe and precise control
In Proc. 7th Conference on
ﬂow from binaries.
Real-Time Computing Systems and Applications,
December 2000.
[31] C. Wang, J. Davidson, J. Hill, and J. Knight. Protec-
tion of software-based survivability mechanisms.
In Proc. International Conference of Dependable
Systems and Networks, July 2001.
[32] C. Wang, J. Hill, J. Knight, and J. Davidson. Soft-
ware tamper resistance: Obstructing static analysis
of programs. Technical Report CS-2000-12, Dept.
of Computer Science, University of Virginia, 12
2000.
[33] Z. Xu, B. P. Miller, and T. Reps. Safety check-
ing of machine code. In Proc. ACM SIGPLAN ’00
Conference on Programming Language Design and
Implementation, pages 70–82, June 18–21, 2000.
Appendix — Randomizing the Com-
putation of Values
The essential idea is to carry out multiple, random, value-
preserving rewritings of the syntax tree for an expression.
We start with a simple expression, e.g., an integer con-
stant or a variable, and repeatedly rewrite it, using value-
preserving transformation rules, to produce an equivalent
expression (i.e., one that will always evaluate to the same
value).
Figure 9 gives a non-exhaustive list of example rewrite
rules. In the rules, we use ‘x’ and ‘y’ to denote variables,
i.e., the values of registers or memory locations; ‘k,’ ‘m’,
and ‘n’ to denote integer constants; and a to denote some-
thing that is either a variable or a constant. Note that
equivalences that hold for integers may not hold at the
machine level, e.g., (x + 1) − 1 need not evaluate to x.
Thus, in general we cannot use associative and distribu-
tive laws for rewriting.
The expression being rewritten is maintained as a syn-
Initially, the tree consists of a single node,
tax tree.
namely, the variable or constant being rewritten. Each
node of the tree has an associated label indicating what
kind of value is being computed (zero, nonzero, arbitrary,
etc.). The rewriting proceeds as follows. We ﬁrst choose
a positive random value as the number of rewriting steps.
Each rewriting step consists of the following:
1. Randomly choose a leaf node X of the tree.
2. Randomly choose a rewrite rule R ≡ Y −→ E from
the set of rules corresponding to the label of the cho-
sen leaf node.
3. Modify the syntax tree by adding the appropriate in-
stance of E (i.e., with all occurrences of Y replaced
by X) as child nodes of X and update the set of leaf
nodes appropriately.
USENIX Association
16th USENIX Security Symposium
289
Zero:
Nonzero k:
0 −→ 0 + 0
0 −→ a ˆ a
0 −→ 0 & a
0 −→ k ? 0 : a
k −→ ˜ 0
k −→ m {rotl, rotr} n m 6= 0, and any n
k −→ k << n
k 6= 0; arbitrary a
(rotr = rotate right; rotl = rotate left)
n = w − m, where m is the position of the
least signiﬁcant ‘1’ bit in k, and w is the machine
word size in bits.
m 6= n
Arbitrary x:
k −→ m ˆ n
x −→ 0 + x
x −→ x * 1
x −→ 0 ? y : x
x −→ m ? x : y
y is any value
y is any value; m 6= 0
Figure 9: A (non-exhaustive) list of rewriting rules (Operators are as in the C language)
The rewritten expression may contain “free variables,”
i.e., variables that are not initialized to any value. The
value of the overall expression does not depend on the
actual value taken on by such a free variable, so any value
will do. In our implementation, we simply use the con-
tents of any arbitrary register or legal memory location
for such variables.
Once the rewritten expression has been generated,
we generate code for it via a straightforward post-order
traversal of the ﬁnal syntax tree.
290
16th USENIX Security Symposium
USENIX Association