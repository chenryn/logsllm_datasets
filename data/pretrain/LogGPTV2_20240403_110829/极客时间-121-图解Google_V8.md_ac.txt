# 01 \| V8是如何执行一段JavaScript代码的？你好，我是李兵。 今天是我们整个课程的第一讲，我会从一个高层的宏观视角来解释什么是V8，以及 V8 又是怎么执行一段 JavaScript代码的。在这个过程中，我会引入一些核心概念，诸如JIT、作用域、词法环境、执行上下文等，理解了这些概念，能够帮助你更好地理解V8 是如何工作的，同时也能帮助你写出更加高效的 JavaScript代码。 由于本节的目的是对 V8 做一个宏观的、全面的介绍，其目的是让你对 V8的执行流程有个整体上的认识，所以涉及到的概念会比较多，如果你对其中一些概念不太理解也没有关系，在后面的章节中我会展开了详细地介绍。 什么是 V8？首先我们来看看什么是 V8。 V8 是一个由 Google 开发的开源 JavaScript 引擎，目前用在 Chrome浏览器和 Node.js 中，其核心功能是执行易于人类理解的 JavaScript代码。 ![](Images/30afb6facea9cb81b045803cc53a30c9.png)savepage-src="https://static001.geekbang.org/resource/image/ca/4d/ca2cf22c8b2b322022666a3183db1b4d.jpg"}V8执行JavaScript那么 V8 又是怎么执行 JavaScript代码的呢？ 其主要核心流程分为编译和执行两步。首先需要将 JavaScript代码转换为低级中间代码或者机器能够理解的机器代码，然后再执行转换后的代码并输出执行结果。 ![](Images/7461474313d2ff77b5e0c0e6be70ad72.png)savepage-src="https://static001.geekbang.org/resource/image/b7/bf/b77593de2fc7754d146e1218c45ef2bf.jpg"}转换为中间代码你可以把 V8看成是一个虚构出来的计算机，也称为虚拟机，虚拟机通过模拟实际计算机的各种功能来实现代码的执行，如模拟实际计算机的CPU、堆栈、寄存器等，虚拟机还具有它自己的一套指令系统。 所以对于 JavaScript 代码来说，V8 就是它的整个世界，当 V8 执行JavaScript代码时，你并不需要担心现实中不同操作系统的差异，也不需要担心不同体系结构计算机的差异，你只需要按照虚拟机的规范写好代码就可以了。 既然 V8 是虚构出来的计算机，用来编译和执行 JavaScript代码，那么接下来我们就看看，为什么计算机需要对 JavaScript这样的高级语言进行编译，以及编译完成后又是如何执行的。 高级代码为什么需要先编译再执行？我们先从 CPU 是怎么执行机器代码讲起，你可以把 CPU看成是一个非常小的运算机器，我们可以通过二进制的指令和 CPU进行沟通，比如我们给 CPU发出"1000100111011000"的二进制指令，这条指令的意思是将一个寄存器中的数据移动到另外一个寄存器中，当处理器执行到这条指令的时候，便会按照指令的意思去实现相关的操作。 为了能够完成复杂的任务，工程师们为 CPU提供了一大堆指令，来实现各种功能，我们就把这一大堆指令称为**指令集（Instructions）**，也就是**机器语言**。 注意，CPU只能识别二进制的指令，但是对程序员来说，二进制代码难以阅读和记忆，于是我们又将二进制指令集转换为人类可以识别和记忆的符号，这就是**汇编指令集**，你可以参考下面的代码：     1000100111011000  机器指令    mov ax,bx         汇编指令那么你可能会问，CPU能直接识别汇编语言吗？ 答案是"不能"，所以如果你使用汇编编写了一段程序，你还需要一个汇编编译器，其作用是将汇编代码编程成机器代码，具体流程你可以参考下图： ![](Images/379fc62ee10db289215a303677dc017a.png)savepage-src="https://static001.geekbang.org/resource/image/6b/1f/6bb6d19ec37ea1a7d2cab2a25ea62b1f.jpg"}汇编编译器虽然汇编语言对机器语言做了一层抽象，减少了程序员理解机器语言的复杂度，但是汇编语言依然是复杂且繁琐的，即便你写一个非常简单的功能，也需要实现大量的汇编代码，这主要表现在以下两点。 首先， **不同的 CPU有着不同的指令集**，如果要使用机器语言或者汇编语言来实现一个功能，那么你需要为每种架构的CPU编写特定的汇编代码，这会带来巨大的、枯燥繁琐的操作，你可以参看下图： ![](Images/2962637311db41b0cff49d024be3811b.png)savepage-src="https://static001.geekbang.org/resource/image/75/70/75f4f88099f82bec62def94541189b70.jpg"}需要为每种架构的CPU编写特定的汇编代码其次，**在编写汇编代码时，我们还需要了解和处理器架构相关的硬件知识**，比如你需要使用寄存器、内存、操作 CPU等。大部分程序员在编写应用的时候，只想专心处理业务逻辑，并不想要过多地理会这些处理器架构相关的细节。 因此我们需要一种屏蔽了计算机架构细节的语言，能适应多种不同 CPU架构的语言，能专心处理业务逻辑的语言，诸如C、C++、Java、C#、Python、JavaScript等，这些"高级语言"就应运而生了。 和汇编语言一样，处理器也不能直接识别由高级语言所编写的代码，那怎么办呢？通常，要有两种方式来执行这些代码。 第一种是解释执行，需要先将输入的源代码通过解析器编译成中间代码，之后直接使用解释器解释执行中间代码，然后直接输出结果。具体流程如下图所示： ![](Images/4b1bd7e4d4d8a0e42e5fdf6d45c3e992.png)savepage-src="https://static001.geekbang.org/resource/image/33/5e/330ad69589d898f6609dfc083bfbe95e.jpg"}解释执行流程图第二种是编译执行。采用这种方式时，也需要先将源代码转换为中间代码，然后我们的编译器再将中间代码编译成机器代码。通常编译成的机器代码是以二进制文件形式存储的，需要执行这段程序的时候直接执行二进制文件就可以了。还可以使用虚拟机将编译后的机器代码保存在内存中，然后直接执行内存中的二进制代码。 ![](Images/45e773cf9bfb78ceaa1c5fa7dfe839d9.png)savepage-src="https://static001.geekbang.org/resource/image/1f/d3/1f933e42e81dacc8f4f2d86e01a914d3.jpg"}编译执行流程图以上就是计算机执行高级语言的两种基本的方式：解释执行和编译执行。但是针对不同的高级语言，这个实现方式还是有很大差异的，比如要执行C语言编写的代码，你需要将其编译为二进制代码的文件，然后再直接执行二进制代码。而对于像Java 语言、JavaScript语言等，则需要不同虚拟机，模拟计算机的这个编译执行流程。执行 Java语言，需要经过 Java 虚拟机的转换，执行 JavaScript 需要经过 JavaScript虚拟机的转换。 即便是 JavaScript一门语言，也有好几种流行的虚拟机，它们之间的实现方式也存在着一部分差异，比如苹果公司在Safari 中就是用 JavaScriptCore 虚拟机，Firefox 使用了 TraceMonkey虚拟机，而 Chrome 则使用了 V8虚拟机。 V8 是怎么执行 JavaScript 代码的？那么，V8 作为 JavaScript 的虚拟机的一种，它到底是怎么执行 JavaScript代码的呢？是解释执行，还是编译执行呢？ 实际上，V8并没有采用某种单一的技术，而是混合编译执行和解释执行这两种手段，我们把这种混合使用编译器和解释器的技术称为JIT（Just In Time）技术。 这是一种权衡策略，因为这两种方法都各自有自的优缺点，解释执行的启动速度快，但是执行时的速度慢，而编译执行的启动速度慢，但是执行时的速度快。你可以参看下面完整的V8 执行 JavaScript 的流程图： ![](Images/c8b336348e17efd5a07dc67c972242ef.png)savepage-src="https://static001.geekbang.org/resource/image/8a/54/8a34ae8c1a7a0f87e19b1384a025e354.jpg"}V8执行一段JavaScript流程图我们先看上图中的最左边的部分，在 V8 启动执行 JavaScript之前，它还需要准备执行 JavaScript时所需要的一些基础环境，这些基础环境包括了"堆空间""栈空间""全局执行上下文""全局作用域""消息循环系统""内置函数"等，这些内容都是在执行JavaScript过程中需要使用到的，比如： 1.  JavaScript    全局执行上下文就包含了执行过程中的全局信息，比如一些内置函数，全局变量等信息；        2.  全局作用域包含了一些全局变量，在执行过程中的数据都需要存放在内存中；        3.  而 V8 是采用了经典的堆和栈的管理内存管理模式，所以 V8    还需要初始化了内存中的堆和栈结构；        4.  另外，要我们的 V8    系统活起来，还需要初始化消息循环系统，消息循环系统包含了消息驱动器和消息队列，它如同    V8    的心脏，不断接受消息并决策如何处理消息。        基础环境准备好之后，接下来就可以向 V8 提交要执行的 JavaScript代码了。 首先 V8 会接收到要执行的 JavaScript 源代码，不过这对 V8来说只是一堆字符串，V8并不能直接理解这段字符串的含义，它需要**结构化**这段字符串。结构化，是指信息经过分析后可分解成多个互相关联的组成部分，各组成部分间有明确的层次结构，方便使用和维护，并有一定的操作规范。 V8 源代码的结构化之后，就生成了抽象语法树 (AST)，我们称为 AST，AST是便于 V8 理解的结构。 这里还需要注意一点，在生成 AST 的同时，V8还会生成相关的作用域，作用域中存放相关变量，我们会在《 06 \|作用域链：V8 是如何查找变量的？》和《12 \| 延迟解析：V8是如何实现闭包的？》这两个节课中详细分析。 有了 AST 和作用域之后，接下来就可以生成字节码了，字节码是介于 AST和机器代码的中间代码。但是与特定类型的机器代码无关，解释器可以直接解释执行字节码，或者通过编译器将其编译为二进制的机器代码再执行。我们会在《13｜字节码（一）：V8为什么又重新引入字节码》这节课中详细介绍字节码的前世今生。 好了，生成了字节码之后，解释器就登场了，它会按照顺序解释执行字节码，并输出执行结果。 相信你注意到了，我们在解释器附近画了个监控机器人，这是一个监控解释器执行状态的模块，在解释执行字节码的过程中，如果发现了某一段代码会被重复多次执行，那么监控机器人就会将这段代码标记为热点代码。 当某段代码被标记为热点代码后，V8就会将这段字节码丢给优化编译器，优化编译器会在后台将字节码编译为二进制代码，然后再对编译后的二进制代码执行优化操作，优化后的二进制机器代码的执行效率会得到大幅提升。如果下面再执行到这段代码时，那么V8会优先选择优化之后的二进制代码，这样代码的执行速度就会大幅提升。 不过，和静态语言不同的是，JavaScript是一种非常灵活的动态语言，对象的结构和属性是可以在运行时任意修改的，而经过优化编译器优化过的代码只能针对某种固定的结构，一旦在执行过程中，对象的结构被动态修改了，那么优化之后的代码势必会变成无效的代码，这时候优化编译器就需要执行反优化操作，经过反优化的代码，下次执行时就会回退到解释器解释执行。 跟踪一段实际代码的执行流程我们以一段最简单的 JavaScript代码为例，如果将这段非常简单的代码提交给 V8 引擎，V8在处理过程中，中间所产生的结果是怎样的呢？下面我们就一步一步详细"追踪"下。 代码如下所示：     var test = 'GeekTime'我们知道，首先这段代码会被解析器结构化称AST，下面我们就来看看第一阶段生成的 AST是什么样子的？ 要查看 V8 中间生成的一些结构，可以使用 V8 提供的调试工具 D8来查看，你可以将上面那段代码保存到 test.js的文件中，然后执行下面命令：     d8 --print-ast test.js执行这段命令之后，D8会打印出如下内容：     --- AST ---    FUNC at 0    . KIND 0    . LITERAL ID 0    . SUSPEND COUNT 0    . NAME ""    . INFERRED NAME ""    . DECLS    . . VARIABLE (0x7ff0e3022298) (mode = VAR, assigned = true) "test"    . BLOCK NOCOMPLETIONS at -1    . . EXPRESSION STATEMENT at 11    . . . INIT at 11    . . . . VAR PROXY unallocated (0x7ff0e3022298) (mode = VAR, assigned = true) "test"    . . . . LITERAL "GeekTime"上面这个结构就是 AST，它就是 JS 源代码的结构化表述，AST是个树状结构，直观地理解，你可以将其转换为一个图形树，如下图所示： ![](Images/d904e15bf3db1e9b3da9f508da10205a.png)savepage-src="https://static001.geekbang.org/resource/image/57/87/57018772d9a93d367c07ce51b91e1f87.jpg"}将源码解析为AST从图中可以看出，AST和代码结构也是一一对应关系，并且后续所有的操作都会直接或者间接基于它。 上面我们还提到了，在生成 AST 的同时，还会生成作用域，同样我们使用 D8来看看它生成的作用域是什么样子，你可以使用下面的命令来查看作用域：     d8 --print-scopes test.js执行这段命令之后，D8会打印出如下内容：     Global scope:    global { // (0x7fd974022048) (0, 24)      // will be compiled      // 1 stack slots      // temporary vars:      TEMPORARY .result;  // (0x7fd9740223c8) local[0      // local vars:      VAR test;  // (0x7fd974022298)    }上面这行代码生成了一个全局作用域，我们可以看到 test变量被添加进了这个全局作用域中。 生成了 AST 和作用域之后，就可以使用解释器生成字节码了，同样你可以使用D8来打印生成后的字节码，打印的命令如下所示：     d8 --print-bytecode test.js执行这段语句，最终打印出来的结果如下所示：     [generated bytecode for function:  (0x2b510824fd55 )    Parameter count 1    Register count 4    Frame size 32             0x2b510824fdd2 @    0 : a7                StackCheck             0x2b510824fdd3 @    1 : 12 00             LdaConstant [0             0x2b510824fdd5 @    3 : 26 fa             Star r1             0x2b510824fdd7 @    5 : 0b                LdaZero             0x2b510824fdd8 @    6 : 26 f9             Star r2             0x2b510824fdda @    8 : 27 fe f8          Mov , r3             0x2b510824fddd @   11 : 61 32 01 fa 03    CallRuntime [DeclareGlobals], r1-r3             0x2b510824fde2 @   16 : 12 01             LdaConstant [1             0x2b510824fde4 @   18 : 15 02 02          StaGlobal [2], [2             0x2b510824fde7 @   21 : 0d                LdaUndefined             0x2b510824fde8 @   22 : ab                Return    Constant pool (size = 3)    0x2b510824fd9d: [FixedArray] in OldSpace     - map: 0x2b51080404b1      - length: 3               0: 0x2b510824fd7d                1: 0x2b510824fd1d                2: 0x2b51081c8549     Handler Table (size = 0)    Source Position Table (size = 0)上面就是这段代码生成的中间字节码，关于字节码，我们会在后续课程《14 \|字节码（二）：解释器是如何解释执行字节码的？》来介绍，在这里我们现有一个大致的认识就可以了。 生成字节码之后，解释器会解释执行这段字节码，如果重复执行了某段代码，监控器就会将其标记为热点代码，并提交给编译器优化执行，如果你想要查看那些代码被优化了，可以使用下面的命令：     d8 --trace-opt test.js如果要查看那些代码被反优化了，可以使用如下命令行来查看：     pt --trace-deopt test.js由于我们这段代码过于简单，没有触发 V8的优化机制，在这里我们也就不展开介绍优化机制了，具体的流程我会在后续课程《15\|隐藏类：如何在内存中快速查找对象属性？》这一节展开详细介绍。 总结V8 是由 Google 开发的开源 JavaScript引擎，也被称为虚拟机，模拟实际计算机各种功能来实现代码的编译和执行。那么，要想搞清楚V8内部的工作流程和原理，我们可以从分析计算机对语言的编译和执行过程入手。 因为计算机只能识别二进制指令，所以要让计算机执行一段高级语言通常有两种手段，第一种是将高级代码转换为二进制代码，再让计算机去执行；另外一种方式是在计算机安装一个解释器，并由解释器来解释执行。 解释执行和编译执行都有各自的优缺点，解释执行启动速度快，但是执行时速度慢，而编译执行启动速度慢，但是执行速度快。为了充分地利用解释执行和编译执行的优点，规避其缺点，V8采用了一种权衡策略，在启动过程中采用了解释执行的策略，但是如果某段代码的执行频率超过一个值，那么V8就会采用优化编译器将其编译成执行效率更加高效的机器代码。 理解了这一点，我们就可以来深入分析 V8 执行一段 JavaScript代码所经历的主要流程了，这包括了： 1.  初始化基础环境；        2.  解析源码生成 AST    和作用域；        3.  依据 AST    和作用域生成字节码；        4.  解释执行字节码；        5.  监听热点代码；        6.  优化热点代码为二进制的机器代码；        7.  反优化生成的二进制机器代码。        这里你需要注意的是，V8是一门动态语言，在运行过程中，某些被优化的结构可能会被 JavaScript动态修改了，这会导致之前被优化的代码失效，如果某块优化之后的代码失效了，那么编译器需要执行反优化操作。 课后思考最后，给你留一道思考题：除了 V8 采用了 JIT 技术，还有那些虚拟机采用了JIT技术？欢迎你在留言区与我分享讨论。 感谢你的阅读，如果你觉得这篇文章对你有所启发，也欢迎把它分享给你的朋友。 
# 02 \| 函数即对象：一篇文章彻底搞懂JavaScript的函数特点你好，我是李兵。这是我们专栏的第二讲，我们来看下"函数是一等公民"背后的含义。如果你熟悉了一门其他流行语言，再来使用 JavaScript，那么 JavaScript中的函数可能会给你造成一些误解，比如在 JavaScript中，你可以将一个函数赋值给一个变量，还可以将函数作为一个参数传递给另外一个函数，甚至可以使得一个函数返回另外一个函数，这在一些主流语言中都很难实现。JavaScript 中的函数非常灵活，其根本原因在于 **JavaScript中的函数就是一种特殊的对象**，我们把 JavaScript中的函数称为**一等公民 (First ClassFunction)。**基于函数是一等公民的设计，使得 JavaScript非常容易实现一些特性，比如闭包，还有函数式编程等，而其他语言要实现这些特性就显得比较困难，比如要在C++中实现闭包需要实现大量复杂的代码，而且使用起来也异常复杂。函数式编程和闭包在实际的项目中会经常遇到，如果不了解这些特性，那么在你使用第三方代码时就会非常吃力，同时自己也很难使用这些特性写出优雅的代码，因此我们很有必要了解这些特性的底层机制。另外，在我们后续课程介绍 V8 工作机制时，会学习 V8是怎么实现闭包的，还会学习 V8 是如何将 JavaScript的动态特性静态化以加快代码的执行速度，这些内容都涉及到 JavaScript中的函数底层特性。今天，我们就来深入分析下，JavaScript中的"函数"到底有怎样的特点。什么是 JavaScript 中的对象？既然在 JavaScript中，函数就是一种特殊的对象，那我们首先要明白，什么是 JavaScript中的"对象"？它和面向对象语言中的"对象"有什么区别？和其他主流语言不一样的是，JavaScript是一门 **基于对象(****Object-Based)** 的语言，可以说 JavaScript中大部分的内容都是由对象构成的，诸如函数、数组，也可以说 JavaScript是建立在对象之上的语言。![](Images/00527a4826362675a977067405badbb0.png)savepage-src="https://static001.geekbang.org/resource/image/9e/f8/9e946bbdc54f5e1347f7b593f8f6fff8.jpg"}基于对象的设计而这些对象在运行时可以动态修改其内容，这造就了 JavaScript的超级灵活特性。不过，因为 JavaScript太灵活了，也加大了理解和使用这门语言的难度。虽然 JavaScript是基于对象设计的，但是它却不是一门**面向对象的语言 (Object-Oriented ProgrammingLanguage)**，因为面向对象语言天生支持**封装、继承、多态，**但是 JavaScript 并没有直接提供多态的支持，因此要在JavaScript中使用多态并不是一件容易的事。![](Images/1427ea91ef683d3c7e4852b367c27f86.png)savepage-src="https://static001.geekbang.org/resource/image/ef/00/eff1c1c773835b79ce597a84b2f94a00.jpg"}面向对象的语言除了对多态支持的不好，JavaScript实现继承的方式和面向对象的语言实现继承的方式同样存在很大的差异。面向对象语言是由语言本身对继承做了充分的支持，并提供了大量的关键字，如public、protected、friend、interface等，众多的关键字使得面向对象语言的继承变得异常繁琐和复杂，而 JavaScript中实现继承的方式却非常简单清爽，**只是在对象中添加了一个称为原型的属性，把继承的对象通过原型链接起来，就实现了继承，我们把这种继承方式称为基于原型链继承。**关于 V8 是如何支持原型的，我们会在《05 \| 原型链：V8是如何实现对象继承的？》这节课做具体介绍。既然"JavaScript 中的对象"和"面向对象语言中的对象"存在巨大差异，那么在JavaScript中，我们所谈论的对象到底是指什么呢？其实 JavaScript中的对象非常简单，每个对象就是由一组组属性和值构成的集合，比如我使用下面代码创建了一个person 对象：    var person=new Object();    person.firstname="John";    person.lastname="Doe";    person.age=50;    person.eyecolor="blue";这个对象里面有四个属性，为了直观理解，你可以参看下图：![](Images/59d30a9881010b8f2a5dd6ba745cf5d1.png)savepage-src="https://static001.geekbang.org/resource/image/d0/23/d07e174001a29765a3575908e3704123.jpg"}对象的构成上图展示了对象 person的结构，我们可以看到蓝色的属性在左边，黄色的值在右边，有多组属性和值组成，这就是JavaScript 中的对象，虽然 JavaScript对象用途非常广泛，使用的方式也非常之多，但是万变不离其宗，其核心本质都就是由一组组属性和值组成的集合，抓住了这一点，当我们再分析对象时，就会轻松很多。在 JavaScript中，之所以它的对象的用途这么广，是因为对象的值可以是任意类型的数据，我们可以改造下上面的那段代码，来看看对象的值都有那些类型？改造后的代码如下所示：    var person=new Object()    person.firstname="John"    person.lastname="Doe"    person.info = new Object()    person.info.age=50    person.info.eyecolor="blue"    person.showinfo = function (){        console.log(/*...*/)    }我们可以先画出这段代码的内存布局，如下图所示：![](Images/aead9ac33e4b5c9adc95ebac6ebfdbb7.png)savepage-src="https://static001.geekbang.org/resource/image/f7/17/f73524e4cae884747ae528d999fc1117.jpg"}属性值类型观察上图，我们可以看出来，对象的属性值有三种类型：第一种是 **原始类型(primitive)**，所谓的原始类的数据，是指值本身无法被改变，比如JavaScript 中的字符串就是原始类型，如果你修改了 JavaScript中字符串的值，那么 V8会返回给你一个新的字符串，原始字符串并没有被改变，我们称这些类型的值为"原始值"。JavaScript 中的原始值主要包括null、undefined、boolean、number、string、bigint、symbol这七种。 第二种就是我们现在介绍的**对象类型(Object)**，对象的属性值也可以是另外一个对象，比如上图中的 info属性值就是一个对象。第三种是 **函数类型(Function)**，如果对象中的属性值是函数，那么我们把这个属性称为方法，所以我们又说对象具备属性和方法，那么上图中的showinfo 就是 person对象的一个方法。![](Images/320e0caef6e11c63400ea467e19d3d2b.png)savepage-src="https://static001.geekbang.org/resource/image/8c/a6/8c33fa6c6e0cef5795292f0a21ee36a6.jpg"}对象属性值的三种类型函数的本质分析完对象，现在我们就能更好地理解 JavaScript中函数的概念了。在这节课开始我就提到，在 JavaScript中，函数是一种特殊的对象，它和对象一样可以拥有属性和值，但是函数和普通对象不同的是，函数可以被调用。我们先来看一段 JavaScript 代码，在这段代码中，我们定义了一个函数foo，接下来我们给 foo 函数设置了 myName 和 uName的属性。     function foo(){        var test = 1    }    foo.myName = 1    foo.uName = 2    console.log(foo.myName)既然是函数，那么它也可以被调用。比如你定义了一个函数，便可以通过函数名称加小括号来实现函数的调用，代码如下所示：    function foo(){        var test = 1        console.log(test)    }    foo()除了使用函数名称来实现函数的调用，还可以直接调用一个匿名函数，代码如下所示：    (function (){        var test = 1        console.log(test)    })()那么，V8内部是怎么实现函数可调用特性的呢？其实在 V8内部，我们会为函数对象添加了两个隐藏属性，具体属性如下图所示：![](Images/55e55ed3d5349aa1bb36ce9b48c208e8.png)savepage-src="https://static001.geekbang.org/resource/image/9e/e2/9e274227d637ce8abc4a098587613de2.jpg"}函数对象具有隐藏属性也就是说，函数除了可以拥有常用类型的属性值之外，还拥有两个隐藏属性，分别是name 属性和 code 属性。隐藏 name属性的值就是函数名称，如果某个函数没有设置函数名，如下面这段函数：    (function (){        var test = 1        console.log(test)    })()该函数对象的默认的 name 属性值就是anonymous，表示该函数对象没有被设置名称。另外一个隐藏属性是 code属性，其值表示函数代码，以字符串的形式存储在内存中。当执行到一个函数调用语句时，V8便会从函数对象中取出 code属性值，也就是函数代码，然后再解释执行这段函数代码。函数是一等公民因为函数是一种特殊的对象，所以在 JavaScript中，函数可以赋值给一个变量，也可以作为函数的参数，还可以作为函数的返回值。**如果某个编程语言的函数可以和它的数据类型做一样的事情，我们就把这个语言中的函数称为一等公民。**支持函数是一等公民的语言可以使得代码逻辑更加清晰，代码更加简洁。但是由于函数的"可被调用"的特性，使得实现函数的可赋值、可传参和可作为返回值等特性变得有一点麻烦。为什么？我们知道，在执行 JavaScript 函数的过程中，为了实现变量的查找，V8会为其维护一个作用域链，如果函数中使用了某个变量，但是在函数内部又没有定义该变量，那么函数就会沿着作用域链去外部的作用域中查找该变量，具体流程如下图所示：![](Images/01e1987ff3ad2b20250ff0f34c0ba410.png)savepage-src="https://static001.geekbang.org/resource/image/8b/fd/8bb90b190362e3a00e5a260bad6829fd.jpg"}查找变量从图中可以看出，当函数内部引用了外部的变量时，使用这个函数进行赋值、传参或作为返回值，你还需要保证这些被引用的外部变量是确定存在的，这就是让函数作为一等公民麻烦的地方，因为虚拟机还需要处理函数引用的外部变量。我们来看一段简单的代码：    function foo(){        var number = 1        function bar(){            number++            console.log(number)        }        return bar    }    var mybar = foo()    mybar()观察上段代码可以看到，我们在 foo 函数中定义了一个新的 bar 函数，并且bar 函数引用了 foo 函数中的变量 number，当调用 foo 函数的时候，它会返回bar 函数。 那么所谓的"函数是一等公民"就体现在，如果要返回函数 bar给外部，那么即便 foo 函数执行结束了，其内部定义的 number变量也不能被销毁，因为 bar函数依然引用了该变量。我们也把这种将外部变量和和函数绑定起来的技术称为闭包。V8在实现闭包的特性时也做了大量的额外的工作，关于闭包的详细实现，我们会在《12\| 延迟解析：V8是如何实现闭包的？》这节课再介绍。另外基于函数是一等公民，我们可以轻松使用 JavaScript来实现目前比较流行的函数式编程，函数式编程规则很少，非常优美，不过这并不是本专栏的重点，所以我们先略开不讲。总结好了，今天的内容就介绍到这里，下面我来总结下本文的主要内容。本文我们围绕 JavaScript 中的函数来展开介绍，JavaScript中的函数非常灵活，既可以被调用，还可以作为变量、参数和返回值，这些特性使得函数的用法非常多，这也导致了函数变得有些复杂，因此本文的目的就是要讲清楚函数到底是什么？因为函数是一种特殊的对象，所以我们先介绍了 JavaScript中的对象，JavaScript中的对象就是由一组一组属性和值组成的集合，既然函数也是对象，那么函数也是由一组组值和属性组成的集合，我们还在文中使用了一段代码证明了这点。因为函数作为一个对象，是可以被赋值、作为参数，还可以作为返回值的，那么如果一个函数返回了另外一个函数，那么就应该返回该函数所有相关的内容。接下来，我们又介绍了一个函数到底关联了哪些内容：1.  函数作为一个对象，它有自己的属性和值，所以函数关联了基础的属性和值；        2.  函数之所以成为特殊的对象，这个特殊的地方是函数可以"被调用"，所以一个函数被调用时，它还需要关联相关的执行上下文。        结合以上两点，JavaScript中的函数就实现了"函数是一等公民"的特性。思考题本文我们从对象聊到了闭包，那么留给你的问题是，哪些语言天生支持"函数是一等公民"？欢迎你在留言区与我分享讨论。感谢你的阅读，如果你觉得这篇文章对你有所启发，也欢迎把它分享给你的朋友。