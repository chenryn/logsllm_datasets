User: 请回答以下安全问题在不等待完全解密的情况下验证加密文件的密码我目前正在使用AES 256加密文件的应用。
问题是，我希望用户在解密文件之前查看密码是否错误。
例如，如果你想解密一个大约1GB大的文件，你需要20分钟才能解密，但只有在解密后，你才会注意到密码是错误的，而你已经等了20分钟！
因此，在解密之前必须有检查密码的可能性。因此，您需要将密码与文件一起传输。
但是怎么做呢？MD5可以被破解。SHA也可能很快被破解。
那么，什么是最好的方法，我如何加密密码超级安全？

Assistant: 我希望用户在解密文件之前查看密码是否错误。
解密不会告诉您密码是否正确。如果你提供了错误的密码，你会得到一个解密的结果。一个错误的，但你怎么知道？
通常，您加密的数据具有一些事先已知的结构。比如说，它是一个文本文件，并且必须只包含可打印的字符。或者它是一个视频文件，必须以一个格式良好的MPEG头开始。如果密码意外出错，那么输出仍然具有这种结构的概率可以忽略不计。在大多数情况下，前几个解密的字节会泄露输出是否正确，从而泄露密码是否正确。但是，除非应用专门用于特定的文件格式，否则应用很难判断是在解密前几个字节后还是在解密所有字节后执行验证。
所以你可以做的是用一个已知的头开始你的明文，就像Elefantosque在密码保护加密中的练习一样。如果前几个解密的字节是正确的，那么您就知道密码是正确的。报头的长度由加密的强度决定；它应该至少是密钥的长度（即这里的32字节）。
顺便说一句，如果解密应用能够以某种通用的方式判断输出是否正确，那么它所做的不仅仅是加密：它还验证其输入的完整性。AES不能做到这一点（如果在特定模式下使用，它可以做到）。因此，要么你的应用正在对你没有告诉我们的数据进行其他加密验证，要么你没有真正验证完整性，尤其是没有检测到错误的密码。
如果您使用上面的已知标头方法，那么您的应用将通过验证标头的完整性来检测错误的密码（这里，完整性检查是标头必须等于已知值）。请注意，您仍然不会验证数据的完整性。
如果你担心攻击者在传输中修改数据，那么你需要的要么是在单个算法中进行某种形式的经过身份验证的加密（可以是AES链接模式），要么是通过MAC将加密与身份验证相结合（先加密后MAC或先MAC后加密）。
另一件你没有说的事情是AES的使用与提供的密码之间的关系。AES-256密钥通常由256个比特组成，攻击者必须完全不知道这些比特（在整个密钥空间上随机生成）。密码是一个字符串，通常由人工选择，它可能具有仅由可打印字符组成的限制，具有最小长度要求等。用密码生成AES密钥是一项不平凡的操作，您的操作方式对应用（或者更确切地说是协议）的安全性至关重要。
根据密码生成AES密钥的一种可接受的方法是密钥拉伸和盐析。密码的问题在于攻击者通常可以通过暴力破解密码。无论你的密码是如何使用的，如果攻击者知道它是密码1234或l33t中的一个，那么攻击者可以尝试所有三种可能性。你所能希望的（在像你这样的场景中）就是让攻击者尝试多种可能性的代价高昂。一个好的拉伸函数需要很长时间来计算。对于合法使用，您只执行一次函数，因此成本无关紧要，而攻击者的成本乘以他执行的尝试次数。至于salting，它减少了想要破解多个加密文件的攻击者的重用量。盐化是指在拉伸数据中包含随机成分（以明文存储）。由于每个文件的salt不同，攻击者无法预先计算从通用密码派生的扩展密钥列表。
更一般地说，您似乎对安全性有一种不平衡的看法（别担心，这在初学者中很常见）。你非常重视算法的选择（AES-256，忽略SHA-1），而对其他重要的部分却没有重视，比如是什么让你得出密码是正确的结论，或者你如何在方案中使用密码。事实上，与在协议中发现漏洞（即信息流和算法的使用方式）相比，在常用的密码算法中发现漏洞是非常罕见的（尤其是实际的弱点）。密码算法很难设计，但其中一些算法就足以满足大多数目的，你不需要了解它们为什么工作（甚至不需要了解如何使用它们）。协议也很难设计，而且它们通常是特定于应用的，至少在一定程度上是这样；因此，您需要在协议设计上多加注意。尽可能重用现有的协议（但要注意正确使用它们！），并在需要设计协议时谨慎行事。同样，您可以打赌您的应用会因为协议损坏（或者实现损坏，如果您不是一个谨慎的实现者的话）而损坏，而不是因为加密算法损坏。
事实上，没有充分的理由不使用AES-128。它将减少解密时间，并且不会明显降低安全性。很长一段时间以来，人们确实不建议使用SHA-1，尽管人们担心的攻击发生的时间比预测的要长。尽管如此，SHA-1并没有因为这里重要的目的而被破坏，即反转哈希（已知的弱点与冲突有关，即找到与某些已知数据具有相同哈希的数据）。尽管如此，如果设计需要密码摘要，建议使用SHA-256。
附言：我想这是一个学习练习。显然，对于真实世界的使用，您将使用现有的、经过充分审查的软件，如PGP/GPG。