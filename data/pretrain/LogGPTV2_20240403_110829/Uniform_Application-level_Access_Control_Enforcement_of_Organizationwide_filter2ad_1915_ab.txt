atively constant within one organization and its speci(cid:2)ca-
tion may be application domain speci(cid:2)c, as it is driven by
the high-level policy rules of the organization. For exam-
ple, in a (cid:2)nancial organization, the value of a transaction
might be important information to decide about an access
request. In a hospital, on the other hand, it is important to
know whether this is an overrule access or not. Through this
access interface, a centrally managed and con(cid:2)gured au-
thorization engine receives noti(cid:2)cations of access attempts
from applications, and can query applications for applica-
tion state to decide whether these accesses should be al-
lowed or not. The authorization engine can be con(cid:2)gured
by means of declarative policy rules that specify the access
control policy in terms of the access interface.
View connectors realize the application-side of the con-
tract. There is a separate view connector per application,
mapping application-speci(cid:2)c concepts to the concepts rep-
resented in the access interface. An important contribu-
tion of this paper is that we show that a view connector
can be realized as a kind of deployment descriptor on an
aspect-oriented application container. This allows to set
the mapping declaratively, without needing to apply inva-
sive changes to the application code. We elaborate on both
concepts in the next sections.
3.1. Access interface
The access interface is an explicit representation of the
contract between the authorization engine and applications.
As such, it speci(cid:2)es the provided and expected functional-
ity and data for both these parties. The authorization en-
gine provides decisions on access requests and expects the
applications to (1) notify the engine of relevant accesses,
(2) provide the necessary information about these accesses,
and (3) enforce the decision on the access request. So in
particular, an access interface must specify what (cid:147)relevant
accesses(cid:148) are, and what information must be provided for
each of these accesses.
Any access request is a request by a subject to perform
some action on an object. Our design starts from the as-
sumption that objects are classi(cid:2)ed by the policy in domains
(such as the medical data domain in our example policy),
and that subjects are classi(cid:2)ed in roles (such as the physi-
cian role), and that the information needed to decide on an
access request, can differ depending on the domain and role
of respectively, the object and subject involved.
This leads to the following formalization: an access in-
terface A consists of a set O of object interfaces (one per
domain) and a set S of subject interfaces (one per role).
Object interfaces. An object interface O for a given do-
main is a pair (attr; act), whereby:
1. attr denotes a set of attribute names, specifying the
information that the authorization engine needs about
objects, and V alues(a) denotes the set of possible val-
ues for a given attribute a 2 O:attr
2. act denotes the set of relevant actions, about which the
authorization engine expects to be noti(cid:2)ed.
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Figure 2. Overview
application A
application B
Application
Developer
Domains
Application 
Deployer
View Connector
view-connector
configuration
Wrapper
View Connector
Domain Specific
Access Interface
Central
Authorization
Engine
Authorization Engine
Provider
Security Officer
Domain Specific Policy DB
(containing rules)
An example of an object interface for the domain of med-
ical data in our example policy is shown below. Note that
the object interface is application-independent: actions and
attributes are speci(cid:2)ed at an appropriate level of abstrac-
tion for making access control decisions. Binding these at-
tributes and actions to actual application concepts, will be
the task of the view connector.
ObjectInterface MedicalDataf
attribute:
attribute:
attribute:
attribute:
fopen, closedg status;
Date closingTime;
LicenseID ResponsiblePhysician;
LicenseID GP;
action:
action:
action:
view;
append;
close;
g
The access control view on an application consists of
a set O of security objects and a set S of security sub-
jects. Each security object o 2 O has one associated ob-
ject interface objectinterf ace(o) and likewise, each se-
curity subject s 2 S has one associated subject inter-
face subjectinterf ace(s). As will be explained in the
next section, the view connector de(cid:2)nes the security state
of each security object and subject. The security state
of a security object or subject is determined by the val-
ues of the attributes, speci(cid:2)ed in their associated object
interface and subject interface respectively. The security
state of a security object o can be written as (cid:27)(o) =
(va)a2objectinterf ace(o):attr, where each va 2 V alues(a).
Similarly, the security state of a security subject can be writ-
ten as (cid:27)(s) = (va)a2subjectinterf ace(s):attr, where each
va 2 V alues(a).
Subject interfaces. A subject interface S for a given role
speci(cid:2)es the information that the authorization engine needs
about subjects in that role in the form of a set of attributes
attr. As for the object interface, V alues(a) denotes the set
of possible values for a given attribute a 2 S:attr
In our example policy, there is a rule that checks whether
a physician is the responsible physician for a given piece of
medical data. Hence, subjects of role physician need an at-
tribute (licenseID) that can be matched with the correspond-
ing attribute on the MedicalData object interface.
SubjectInterface Physicianf
attribute:
attribute:
LicenseID licenseID;
fnormal,overruleg accessmode;
g
Implementing the policy. An access request is a triple
(s; o; a) consisting of a security subject s, a security ob-
ject o and an action name a in the action name set act of
objectinterf ace(o). The access policy is the function that,
given an access request (s; o; a) and the security states (cid:27)(o)
and (cid:27)(s) returns whether the access is allowed or not.
The particular choice of authorization engine, which re-
alizes this function, is irrelevant for the discussion in this
paper, and many good designs of authorization engines are
available (e.g. FAF [15]). Typically, such an authorization
engine will interpret a set of declarative policy rules. In our
example, we use the Ponder [10] policy language to formu-
late the rules in. The following rule states that the responsi-
ble physician for a piece of medical data can view, append
or close that data, as long as its status is open.
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
inst
auth+ openMedicalDataAccess f
subject
target
action
when
 s=/Physician;
 t=/MedicalData;
view, append, close;
t.status.equals(‘‘open’’) and
t.ResponsiblePhysician.equals
(s.licenseID);
g
Ponder does not only provide a policy language, but also
a deployment model for instantiating and distributing poli-
cies. The view connector concept, which is discussed next,
is complementary to this model as it provides a means to
integrate access control enforcement into each application.
3.2. View connectors
The access interface speci(cid:2)es access requests at an ab-
stract level. At some point, this needs to be translated down
to actual application concepts. This is the role of the view
connector. We say that a view connector binds an applica-
tion to the access interface. Each application will need its
own view connector.
To implement a view connector one must:
(cid:15) Decide how application objects map to security objects
and subjects. In our example, we will have to identify
all medical data that the application handles.
(cid:15) Identify all operations on such data and map these op-
erations to the corresponding actions in the object in-
terface. This also determines all places where an ac-
cess check needs to be performed. In our example, we
will have to map all application operations on medical
data to one of the three actions: view, append or close.
(cid:15) Determine how to compute the necessary attributes for
security objects and subjects.
An example view connector is shown in Table 2. We (cid:2)rst
discuss the computation of attributes.
Attribute computation. The view connector will need to
specify how each of the access interface attributes is com-
puted for the given application. For instance, an ICP ob-
ject in our example application (Figure 1) is clearly medical
data. The responsible physician for that object can be com-
puted via a getter on the ICP class. The patient’s GP must
be computed by (cid:2)rst getting the patient associated with the
medical data, and then getting the GP of that patient.
The part of the view connector that computes these
attributes,
is very similar to Beznosov’s attribute func-
tions [5], or to the DynamicAttributeService in CORBA’s
Resource Access Decision (RAD) service [6].
view-connector
type
object-interface
attributes
ICP
MedicalData
(a) attribute computation
ResponsiblePhysician ! getResponsiblePhysician().get-
GP
status
closingTime
actions
view
LicenseID()
! getPatient().getGP().get-
LicenseID()
! if(isClosed()) closed
else open
! getClosingTime()
(b) access enforcement points
! get*
. . .
Table 2. View connector for medical data
Access enforcement points. The access enforcement
points in the applications are the points in the execution,
where an access check needs to be done. The insertion
of access checks at all these points, is technology depen-
dent. This can be done, for example, by inserting the nec-
essary calls to the authorization engine in the application
code. Adding such calls to the application code during de-
ployment/integration of an application, is not straightfor-
ward on typical application platforms such as J2EE, .NET
or CORBA, as it requires access to the application source
code. However, the technology of aspect-orientation makes
it possible to provide an implementation of view connectors
that can be con(cid:2)gured at deployment time.
Our prototype is built on top of an aspect-oriented appli-
cation container. An aspect-oriented application container
offers the concept of pointcuts, expressions that denote sets
of execution points in an application. The container also al-
lows the injection of new code at each point identi(cid:2)ed by
such a pointcut. The use of pointcuts by itself, does not
improve the security of the overall system. However, due
to a modular description of the access enforcement points
it is easier to assess the security of the system than would
be possible if these points were spread all over the code.
Given such support, each action in an object interface can be
mapped on such a pointcut, and the relevant access checks
can be inserted at each point identi(cid:2)ed by that pointcut.
In our prototype, an extensible application container is
extended with a so-called aspect component, which is con-
(cid:2)gured with a view connector. An example of such a view
connector is shown in Table 2. Part (a) con(cid:2)gures how at-
tribute computation should be done. Part (b) shows how
actions are mapped to pointcuts. Based on this con(cid:2)gu-
ration (cid:2)le, the right access checks are injected at each of
these points. In Section 5 our implementation is discussed
in more detail.
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
4. Discussion
In this section, we discuss the presented approach by
evaluating to what extent it ful(cid:2)lls the requirements men-
tioned in Section 2.4. In addition, we will show that our ap-
proach does not negatively in(cid:3)uence other important prop-
erties of an access control infrastructure for distributed ob-
ject systems. The discussion is based on the enumeration of
typical requirements for these systems in [4].
Expressiveness. We found that for practical policies, the
access interface does not impose restrictions on the expres-
siveness of the policies that can be enforced. A trade-off
may need to be made between expressiveness and other re-
quirements. E.g., de(cid:2)ning a large number of object and sub-
ject interfaces should be avoided in order to keep the policy
manageable.
The de(cid:2)nition of the subject interface should be extended
to support more complex principals, as for example pre-
sented in [17]. This would allow, for instance, to take into
consideration the access path of a request.
The access interface is based on the high-level policy.
Further research is required to develop techniques to de-
termine an appropriate access interface for an application
domain.
Separation of concerns and evolution. The responsibil-
ities of security of(cid:2)cer and application deployer are clearly
separated. The former speci(cid:2)es the access interface, the lat-
ter the view connector.
Evolution of the policy is more straightforwardly sup-
ported. Consider for this purpose the additional rules in
Section 2.3: Since Rule 4 fully complies to the access in-
terface introduced in Section 3.1, adding the rule suf(cid:2)ces to
enforce it uniformly.
Rule 5 requires an extension of the medical data access
interface to support a sensitivity attribute and the de(cid:2)nition
of the necessary attribute mappings in the corresponding
view connectors. Our approach provides better support to
apply this extension, as the view connector speci(cid:2)es ex-
plicitly which application objects represent medical data.
A limited consistency check can be carried out to verify
whether mappings have been de(cid:2)ned for each attribute in
the access interface.
If the policy changes more radically, new object and/or
subject interfaces might need to be introduced with corre-
sponding view connectors.
In case the application or its setting changes (e.g. due
to code refactoring), only adapting the corresponding view
connectors suf(cid:2)ces.
View connectors support its enforcement in diverse applica-
tions.
Performance- and administration scalability. The per-
formance overhead incurred by adding support for view
connectors, depends on how they are implemented. An im-
plementation with centralized management but distributed
enforcement will likely achieve good performance.
The good support for separation of concerns between ad-
ministrators and developers/deployers positively in(cid:3)uences
administration scalability.
Requirements that stem from the object paradigm.
These requirements are subdivided in the following
classes [4]:
1. Objects: The access control technology should shield
complex semantics of the diverse methods from the se-
curity of(cid:2)cer. This is one of the main goals of the
access interface, so our approach ful(cid:2)lls this require-
ment.
Secondly, the technology should scale on large num-
ber of objects and methods. As the access interface al-
lows for grouping of objects (in policy domains with
the same object interface) and methods (in actions),
scalability is assured.
2. Collections: Flexibility is required when grouping ob-
jects into collections for security purposes; solely pro-
viding grouping based on names or location is not suf-
(cid:2)cient. Moreover, collocation or similar names should
not imply membership of the same security collections.
Our approach provides for grouping of objects inde-
pendent of any existing structure on the application.
Our current prototype implementation imposes the re-
striction that all objects of the same class should be-
long to the same object interface, but making this more
(cid:3)exible is just an implementation effort.
3. Names: No human intervention should be required to
enforce access control on transient objects.
Our approach is neutral with respect to this require-
ment: whether human intervention is required or not,
depends on the implementation of the view connector.