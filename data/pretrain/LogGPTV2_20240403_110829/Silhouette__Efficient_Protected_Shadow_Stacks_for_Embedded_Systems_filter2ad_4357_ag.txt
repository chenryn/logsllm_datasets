puter and Communications Security, CCS ’15, pages 952–963,
Denver, CO, 2015. ACM.
[26] John Criswell, Nathan Dautenhahn, and Vikram Adve. KCoFI:
Complete control-ﬂow integrity for commodity operating sys-
tem kernels. In Proceedings of the 2014 IEEE Symposium on
Security and Privacy, SP ’14, pages 292–307, San Jose, CA,
2014. IEEE Computer Society.
[27] John Criswell, Andrew Lenharth, Dinakar Dhurjati, and Vikram
Adve. Secure Virtual Architecture: A safe execution environ-
ment for commodity operating systems. In Proceedings of the
21st ACM SIGOPS Symposium on Operating Systems Princi-
ples, SOSP ’07, pages 351–366, Stevenson, WA, 2007. ACM.
[28] Thurston H.Y. Dang, Petros Maniatis, and David Wagner. The
performance cost of shadow stacks and stack canaries. In Pro-
ceedings of the 10th ACM Symposium on Information, Com-
puter and Communications Security, ASIACCS ’15, pages
555–566, Singapore, Republic of Singapore, 2015. ACM.
[29] Lucas Davi, Ahmad-Reza Sadeghi, Daniel Lehmann, and
Fabian Monrose. Stitching the gadgets: On the ineffectiveness
of coarse-grained control-ﬂow integrity protection. In Proceed-
ings of the 23rd USENIX Security Symposium, Security ’14,
pages 401–416, San Diego, CA, 2014. USENIX Association.
[30] Dinakar Dhurjati and Vikram Adve. Backwards-compatible
array bounds checking for C with very low overhead. In Pro-
ceedings of the 28th International Conference on Software En-
gineering, ICSE ’06, pages 162–171, Shanghai, China, 2006.
ACM.
[31] Dinakar Dhurjati, Sumant Kowshik, and Vikram Adve. SAFE-
Code: Enforcing alias analysis for weakly typed languages. In
Proceedings of the 27th ACM SIGPLAN Conference on Pro-
gramming Language Design and Implementation, PLDI ’06,
pages 144–157, Ottawa, ON, Canada, 2006. ACM.
[32] Baozeng Ding, Yeping He, Yanjun Wu, Alex Miller, and John
Criswell. Baggy bounds with accurate checking. In Proceed-
ings of the 23rd IEEE International Symposium on Software
Reliability Engineering Workshops, ISSREW ’12, pages 195–
200, Dallas, TX, 2012. IEEE Computer Society.
[33] CoreMark: An
EEMBC benchmark.
https:
//www.eembc.org/coremark.
[34] CoreMark-Pro: An EEMBC benchmark.
https://
www.eembc.org/coremark-pro.
[35] Isaac Evans, Fan Long, Ulziibayar Otgonbaatar, Howard
Shrobe, Martin Rinard, Hamed Okhravi, and Stelios Sidiroglou-
Douskos. Control Jujutsu: On the weaknesses of ﬁne-grained
In Proceedings of the 22nd ACM
control ﬂow integrity.
SIGSAC Conference on Computer and Communications Secu-
rity, CCS ’15, pages 901–913, Denver, CO, 2015. ACM.
[36] GNU Project. Label as values.
https://gcc.gnu.org/
onlinedocs/gcc/Labels-as-Values.html.
[37] Enes Göktas, Elias Athanasopoulos, Herbert Bos, and Georgios
Portokalidis. Out of control: Overcoming control-ﬂow integrity.
In Proceedings of the 2014 IEEE Symposium on Security and
Privacy, SP ’14, pages 575–589, San Jose, CA, 2014. IEEE
Computer Society.
[38] Jason Hill, Robert Szewczyk, Alec Woo, Seth Hollar, David
Culler, and Kristofer Pister. System architecture directions for
networked sensors. In Proceedings of the 9th International
Conference on Architectural Support for Programming Lan-
guages and Operating Systems, ASPLOS ’00, pages 93–104,
Cambridge, MA, 2000. ACM.
[39] Hong Hu, Shweta Shinde, Sendroiu Adrian, Zheng Leong
Chua, Prateek Saxena, and Zhenkai Liang. Data-oriented pro-
gramming: On the expressiveness of non-control data attacks.
In Proceedings of the 2016 IEEE Symposium on Security and
Privacy, SP ’15, pages 969–986, San Jose, CA, 2016. IEEE
Computer Society.
[40] Yier Jin, Grant Hernandez, and Daniel Buentello. Smart Nest
Thermostat: A smart spy in your home. In Black Hat USA.
2014.
[41] Richard W. M. Jones and Paul H. J. Kelly. Backwards-
compatible bounds checking for arrays and pointers in C
In Proceedings of the 3rd International Work-
programs.
shop on Automatic Debugging, AADEBUG ’97, pages 13–26,
Linköping, Sweden, 1997. Linköping University Electronic
Press; Linköpings universitet.
[42] Chung Hwan Kim, Taegyu Kim, Hongjun Choi, Zhongshu Gu,
Byoungyoung Lee, Xiangyu Zhang, and Dongyan Xu. Se-
curing real-time microcontroller systems through customized
memory view switching. In Proceedings of the 2018 Network
and Distributed System Security Symposium, NDSS ’18, San
Diego, CA, 2018. Internet Society.
[43] Volodymyr Kuznetsov, László Szekeres, Mathias Payer, George
Candea, R. Sekar, and Dawn Song. Code-pointer integrity. In
Proceedings of the 11th USENIX Symposium on Operating
Systems Design and Implementation, OSDI ’14, pages 147–
163, Broomﬁeld, CO, 2014. USENIX Association.
[44] Donghyun Kwon, Jangseop Shin, Giyeol Kim, Byoungyoung
Lee, Yeongpil Cho, and Yunheung Paek. uXOM: Efﬁcient
In Proceedings
execute-only memory on ARM Cortex-M.
of the 28th USENIX Security Symposium, Security ’19, pages
231–247, Santa Clara, CA, 2019. USENIX Association.
1234    29th USENIX Security Symposium
USENIX Association
[45] Chris Lattner and Vikram Adve. LLVM: A compilation frame-
work for lifelong program analysis & transformation. In Pro-
ceedings of the 2nd International Symposium on Code Genera-
tion and Optimization, CGO ’04, Palo Alto, CA, 2004. IEEE
Computer Society.
[46] Chris Lattner, Andrew Lenharth, and Vikram Adve. Making
context-sensitive points-to analysis with heap cloning practical
for the real world. In Proceedings of the 28th ACM SIGPLAN
Conference on Programming Language Design and Implemen-
tation, PLDI ’07, pages 278–289, San Diego, CA, 2007. ACM.
[47] Zhengyang Liu and John Criswell. Flexible and efﬁcient
memory object metadata. In Proceedings of the 2017 ACM
SIGPLAN International Symposium on Memory Management,
ISMM ’17, pages 36–46, Barcelona, Spain, 2017. ACM.
[48] ARMConstantIslandPass ﬁle reference. https://llvm.org/
doxygen/ARMConstantIslandPass_8cpp.html.
[49] IndirectBrExpandPass.cpp ﬁle reference. https://llvm.org/
doxygen/IndirectBrExpandPass_8cpp.html.
[50] LLVM language reference manual.
https://llvm.org/
docs/LangRef.html.
[51] llvm::LivePhysRegs class reference.
https://llvm.org/
doxygen/classllvm_1_1LivePhysRegs.html.
[52] Azure Sphere.
https://azure.microsoft.com/en-us/
services/azure-sphere.
[53] Daniele Midi, Mathias Payer, and Elisa Bertino. Memory safety
for embedded devices with nesCheck. In Proceedings of the
2017 ACM Asia Conference on Computer and Communications
Security, ASIACCS ’17, pages 127–139, Abu Dhabi, United
Arab Emirates, 2017. ACM.
[54] Charlie Miller and Chris Valasek. A survey of remote automo-
tive attack surfaces. In Black Hat USA. 2014.
[55] George C. Necula, Scott McPeak, and Westley Weimer.
CCured: Type-safe retroﬁtting of legacy code. In Proceedings
of the 29th ACM SIGPLAN-SIGACT Symposium on Princi-
ples of Programming Languages, POPL ’02, pages 128–139,
Portland, OR, 2002. ACM.
[56] Newlib. https://sourceware.org/newlib.
[57] Thomas Nyman, Jan-Erik Ekberg, Lucas Davi, and N. Asokan.
CFI CaRE: Hardware-supported call and return enforcement
for commercial microcontrollers. In Proceedings of the 20th
International Symposium on Research in Attacks, Intrusions,
and Defenses, RAID ’17, pages 259–284, Atlanta, GA, 2017.
Springer-Verlag.
[58] James Pallister, Simon Hollis, and Jeremy Bennett. BEEBS:
Open benchmarks for energy measurements on embedded plat-
forms. arXiv preprint arXiv:1308.5174, August 2013.
[59] Ryan Roemer, Erik Buchanan, Hovav Shacham, and Stefan
Savage. Return-oriented programming: Systems, languages,
and applications. ACM Transactions on Information and Sys-
tem Security, 15(1):2:1–2:34, March 2012.
[60] Olatunji Ruwase and Monica S. Lam. A practical dynamic
buffer overﬂow detector. In Proceedings of the 11th Network
and Distributed System Security Symposium, NDSS ’04, San
Diego, CA, 2004. Internet Society.
[61] Ahmad-Reza Sadeghi, Christian Wachsmann, and Michael
Waidner. Security and privacy challenges in industrial Internet
of Things. In Proceedings of the 52nd Annual Design Automa-
tion Conference, DAC ’15, pages 54:1–54:6, San Francisco,
CA, 2015. ACM.
[62] Konstantin Serebryany, Derek Bruening, Alexander Potapenko,
and Dmitriy Vyukov. AddressSanitizer: A fast address sanity
checker. In Proceedings of the 2012 USENIX Annual Techni-
cal Conference, ATC ’12, pages 309–318, Boston, MA, 2012.
USENIX Association.
[63] STMicroelectronics. UM1725 User Manual: Description of
STM32F4 HAL and LL Drivers, February 2017. DocID025834
Rev 5.
[64] STMicroelectronics.
RM0386 Reference Manual:
STM32F469xx and STM32F479xx Advanced Arm®-Based
32-Bit MCUs, June 2018. RM0386 Rev 5.
[65] STMicroelectronics. PM0214 Programming Manual: STM32
Cortex®-M4 MCUs and MPUs Programming Manual, March
2020. PM0214 Rev 10.
[66] STMicroelectronics. UM1932 User Manual: Discovery Kit
with STM32F469NI MCU, April 2020. UM1932 Rev 3.
[67] László Szekeres, Mathias Payer, Tao Wei, and Dawn Song.
SoK: Eternal war in memory. In Proceedings of the 2013 IEEE
Symposium on Security and Privacy, SP ’13, pages 48–62, San
Francisco, CA, 2013. IEEE Computer Society.
[68] Texas Instruments. Hardware abstraction layer code genera-
tor for Hercules MCUs, 2019. https://www.ti.com/tool/
HALCOGEN.
[69] Robert Wahbe, Steven Lucco, Thomas E. Anderson, and Su-
san L. Graham. Efﬁcient software-based fault isolation. In
Proceedings of the 14th ACM Symposium on Operating Sys-
tems Principles, SOSP ’93, pages 203–216, Asheville, NC,
1993. ACM.
[70] Robert J. Walls, Nicholas F. Brown, Thomas Le Baron, Craig A.
Shue, Hamed Okhravi, and Bryan C. Ward. Control-ﬂow in-
tegrity for real-time embedded systems. In Proceedings of the
31st Euromicro Conference on Real-Time Systems, ECRTS ’19,
pages 2:1–2:24, Stuttgart, Germany, 2019. Schloss Dagstuhl–
Leibniz-Zentrum füer Informatik.
[71] Mario Werner, Thomas Unterluggauer, David Schaffenrath,
and Stefan Mangard. Sponge-based control-ﬂow protection
for IoT devices. In Proceedings of the 2018 IEEE European
Symposium on Security and Privacy, EuroSP ’18, pages 214–
226, London, United Kingdom, 2018. IEEE Computer Society.
[72] Yajin Zhou, Xiaoguang Wang, Yue Chen, and Zhi Wang. ARM-
lock: Hardware-based fault isolation for ARM. In Proceedings
of the 2014 ACM SIGSAC Conference on Computer and Com-
munications Security, CCS ’14, pages 558–569, Scottsdale,
AZ, 2014. ACM.
A Design to Support setjmp/longjmp
Calls to setjmp and longjmp can undermine Silhouette’s
return addresses integrity guarantees because longjmp uses
USENIX Association
29th USENIX Security Symposium    1235
Algorithm 1: Silhouette setjmp
Input: A jmp_buf buf
end
e.{sp, lr, . . . } ← {sp, lr, . . . };
return 0;
1 foreach entry e in map do
if e.buf == &buf then
2
3
4
5
6 end
7 if map.size < map.capacity then
8
9
10
11 else
12
13 end
Error(“Map reached its capacity”);
Insert a new entry {&buf, sp, lr, . . . } into map;
map.size ← map.size +1;
return 0;
a return address from its jmp_buf argument which could be
located in corruptible global, heap, or stack memory. Applica-
tions might also misuse setjmp and longjmp, such as calling
longjmp after the function that called setjmp with the corre-
sponding jmp_buf returns, leading to undeﬁned behaviors ex-
ploitable by attackers. Silhouette modiﬁes the implementation
of setjmp and longjmp to support them while maintaining
its return address integrity guarantees.
Speciﬁcally, Silhouette reserves part of the protected
shadow stack region to store a map of active jmp_buf records
in use by the program. Figure 3 shows the format of a map
entry; the address of a jmp_buf passed to setjmp/longjmp
serves as a key, and all callee-saved registers plus sp and lr
are values. Algorithms 1 and 2 depict the design of our cus-
tom setjmp and longjmp, respectively. When the application
calls setjmp, instead of saving the execution context to the
application-speciﬁed jmp_buf, Silhouette’s setjmp saves it
to the map by inserting a new entry or overriding an existing
entry, based on the address of jmp_buf. If we are inserting a
new entry and the number of active jmp_buf records reaches
the map’s capacity, Silhouette’s setjmp reports an error and
aborts the program; this is not a practical problem as we ex-
pect the program to have only a few jmp_bufs. We can also
provide an option for the application developer to specify a
desired size of the map. Our store hardening pass will recog-
Figure 3: Format of jmp_buf Records
end
Error(“Invalid jmp_buf”);
buf_entry ← e;
break;
Algorithm 2: Silhouette longjmp
Input: A jmp_buf buf
Input: An integer val
1 buf_entry ← null;
2 foreach entry e in map do
if e.buf == &buf then
3
4
5
6
7 end
8 if buf_entry == null then
9
10 end
11 foreach entry e in map do
12
13
14
15
16 end
17 {sp, lr, . . . } ← buf_entry.{sp, lr, . . . };
18 if val == 0 then
19
20 else
21
22 end
Invalidate e;
map.size ← map.size −1;
if e.sp < buf_entry.sp then
return 1;
return val;
end
nize this safe version of setjmp and generate regular stores
(instead of unprivileged stores) for it to access the map. Sav-
ing the execution context in the protected region ensures the
integrity of saved stack pointer values and return addresses.
Silhouette’s longjmp checks if the address of the supplied
jmp_buf matches an entry in the map. If no matched entry
is found, either the supplied jmp_buf is invalid or the sup-
plied jmp_buf has expired due to function returns or a call
to longjmp on an outer-deﬁned jmp_buf (both explained be-
low). In both cases, execution is aborted. If a matched entry
is found, Silhouette’s longjmp ﬁrst invalidates all entries in
the map that have a smaller sp value than that of the matched
entry; these jmp_bufs become expired when the control ﬂow
is unwound to an outer call site of setjmp. The execution
context stored in the matched entry is then recovered.
The remaining case is that, when a function that calls
setjmp returns, the jmp_bufs used in the function and in
its callees become obsolete. Silhouette handles this case by
inserting code in the epilogue of such functions to invalidate
all the map entries whose sp value is smaller than or equal to
the current sp value. This ensures that future calls to longjmp
do not use obsolete sp and lr values.
1236    29th USENIX Security Symposium
USENIX Association
Address of  jmp_bufSPLRCallee-Saved Registers...0x20001000.....................0x20002000.........0.....................0.........Activejmp_bufRecordsMapCapacity