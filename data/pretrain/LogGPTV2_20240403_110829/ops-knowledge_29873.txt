User: Lets say I am designing a tool foobuzzle (foobuzzle's exact job is to set up SRPM files for cross-compiling a variety of codes into their own compartmentalized prefix directories, but this is not important).  I would like foobuzzle to take in an input file (buzzle_input) specified by an (intelligent, code-savvy) client, who will tell foobuzzle how they would like it to perform these operations.
I am writing foobuzzle in Python, and it seems to make sense for the user to provide buzzle_input configuration information in either Python or bash.  Which would you choose?  How would you implement it?  I am expecting that Python will need some global environment variables that may need to be set up by executing some other scripts, probably from within the buzzle_input script.
This is not production code, just an internal tool a small team of developers will be using to help manage a fairly large cross-compiled environment of C/C++/FORTRAN codes.
My best guess is to use something to wrap the foobuzzle script so that the $PYTHONPATH variable picks up the current working directory, and to have the foobuzzle_input script imported and executed as set up.  Is there a cleaner way to do this without wrapping foobuzzle?  Any special considerations for executing the bash scripts (assume safety is not really a concern and that these scripts will not be run with system administrator privileges).
Assistant: My interpretation of your context, is that you have a Python script that performs various make- or autoconf-like operations, and you want to allow clients to write their own Makefiles for Foobuzzle.
The problem with directories I don't understand. import will always search the local directory? And you can os.chdir() when you hop around to change current working directory, like make does.
Having it as a bash script has the pro that nobody needs to learn Python or, specifically, the Python-like Foobuzzle DSL. But it is a lot less powerful: you're basically limited to sending and receiving text only. You can't write support functions that the bash code can call (unless you generate that into bash as well), proper error handling might be tough, etc.
Depending on how powerful the configuration needs to be, I would use Python. I'd probably load the file itself and use eval() on it, giving me full control over its namespace. I could pass various utility and helper functions, for example, or provide objects they can manipulate directly.
If it's really simple though, specifying flags and names, that sort of thing, then you could just have it as .ini files and use ConfigParser() in the standard library.