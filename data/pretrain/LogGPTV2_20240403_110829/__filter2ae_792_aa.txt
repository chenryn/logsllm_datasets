# 【技术分享】智能门锁也会得“癌症”？如何通过手机搞定蓝牙门锁
##### 译文声明
本文是翻译文章，文章来源：smartlockpicking.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
译者：[兴趣使然的小胃](http://bobao.360.cn/member/contribute?uid=2819002922)
预估稿费：200RMB
投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿
**一、前言**
看到智能门锁这个词，可能有人会怀疑它是不是真的“智能”，因此，厂商会把这几个字直接印在产品上。厂商会在产品中配有气场强大的扬声器，作为防窃卖点广而告之。但如果在正常的解锁通知中使用这种扬声器，开门时用户不得不捂起耳朵，这并不是一个智能的决定。至于安全性嘛，安全性已经在门锁外壳上体现了。
调侃归调侃，闲话少说，如果想看攻击过程，可直接跳到“演示视频”这部分。
**  
**
**二、拦截BLE传输数据**
出于各种原因，大多数BLE（Bluetooth Low
Energy，低功耗蓝牙）设备（包括我所知道所有智能锁设备）并没有实现链路层上的蓝牙安全机制，不能保护配对、绑定、加密操作。设备通常会在未加密BLE链路上发明自己的通信协议。这种方法会导致攻击者能够轻松拦截蓝牙链路层上的数据包，对这些方案的分析及攻击也可以信手拈来。
为了拦截无线传输数据，你首先想到的可能是使用专用的嗅探器。未来我会在相关教程中介绍这方面内容，但我的第一选择并不是使用这种方法。长话短说，这种方法除了需要使用专用硬件之外，被动嗅探模式也不是特别可靠（通常情况下你会得到离散的数据包），此外想要分析已传输的数据也不是那么简单（比如，需要在Wireshark中进行分析）。
在中间人（MITM）场景中，我使用的是自研的[GATTACKER
MITM代理工具](https://github.com/securing/gattacker)来捕捉传输数据。硬件方面，该工具使用的是价值5美元的蓝牙4适配器。后面有机会的话我会详细介绍这款工具，这里我会跟大家一起看看如何在常见场景中使用这款工具。如果你对此感兴趣，想了解更多细节，你可以参考我在2016黑帽大会上的[演讲](https://github.com/securing/docs/blob/master/slides.pdf)以及[白皮书](https://github.com/securing/docs/blob/master/whitepaper.pdf)资料。
使用一条scan命令，我们就能探测附近所有设备的广播信号：
广播数据很短，通常情况下，BLE设备会不断对外广播数据包，向周围设备告知存活状态。这个工具发现了我们的智能锁，同时返回了智能锁的mac地址以及设备名。接下来，我们可以扫描设备的服务（service）及属性（characteristic）。
这里我不会介绍BLE的服务及属性相关知识。你可以认为BLE属性为一个简单的UID命名变量，存储在设备中，可以被读取及写入，了解这些知识就已足够。
扫描后，我们已经得到了一些数据，这些数据以json文件形式保存在“devices”子目录中，可以用来模拟原始的目标设备（即模拟设备的广播数据及属性特征）。现在，我们已准备就绪，可以运行中间人拦截代理程序。代理可以充当原始设备的软件模拟器，诱导移动应用发起连接操作，随后来回转发BLE数据。在我们的案例中，智能锁移动应用会检查设备的BT
MAC地址，因此我们必须伪造这个地址。请注意：某些蓝牙4适配器并不支持修改MAC地址（这些适配器大多都是笔记本中自带的模块）。我使用的是CSR8510
USB设备，配合一个简单的脚本完成这个任务：
现在，重新插入USB设备，启用新的MAC地址，然后，MITM代理就会开始工作：
如果你看到紫色的“INITIALIZED”文本，表明代理程序与原始设备之间的连接已建立成功，软件设备模拟器已启动，准备拦截数据包。
一旦“受害者”移动应用连接到我们的模拟设备上，代理就开始来回转发数据：
上图中，蓝色的Write代表移动应用将数据发往设备，绿色的Read代表移动应用从设备那收到数据。随后为传输的十六进制数据，括号中为这些数据解码后的ascii值。而ffe0
-> fff1为服务及属性id，目前这些id不是特别重要。我们的设备只使用了一个属性。
通信过程从几段较长的二进制数据包开始，接下来是几个较短的、相同的读写数据包，频率大概是每秒一次。当我在移动应用中按下“unlock（解锁）”按钮时，我看到了一些不同的数据包。
**  
**
**三、明文凭据**
在上图拦截到的通信数据中，可能你首先会注意到一段重复的“6666666”数据（对应的十六进制数据为363636363636）。是的，你没看错，这就是设备当前使用的密码，以明文形式传输。顺便说一句，你也可以使用无源RF嗅探硬件（比如[Ubertooth](https://greatscottgadgets.com/ubertoothone/)以及外接天线）从远处嗅探这段数据。到此为止，游戏其实已经结束。知道密码后，攻击者就可以在自己的移动应用上输入密码，像主人一样正常控制门锁状态。攻击者并不需要进一步分析数据包或者理解应用协议。
然而，我们并不满足于此。
现在，我们可以假装密码还没有泄露，还有一些有趣的漏洞等待我们挖掘。
**  
**
**四、重放攻击**
前面提到过，刚开始时移动应用会与设备交换少量复杂的数据包：
接下来，这段数据每一次都会有所变化：
这段数据用来与设备进行初始化握手，握手完成后，你可以发送真正的控制命令。对于本文使用的这个实验设备，如果你在连接发起时，不经过初始化握手过程，直接发送一条命令（比如发送a136363636363601解锁命令），那么该命令会被设备直接丢弃。因此某种程度上，这种握手过程起到了“身份认证”作用。
我们可以通过各种方式仔细检查这个专有协议的具体细节，通过逆向分析，理解来回传送数据中每个字节代表的含义。你可能已经注意到其中包含重复的十六进制编码“741689”，稍后我们会分析这个信息，目前为止我们还不必了解这个协议的底层实现细节。我们可以先整体看一下政协数据包，宏观了解一下。
可以看到，移动应用发送的第一个数据包如下（蓝色write那一行）：
这些数据开头部分都相同，但结尾部分有点区别。接下来，设备会返回响应数据，开头部分依然相同，结尾部分依然有点区别：
很有可能响应数据会根据初始值的不同而不同。
这看起来像是简单的“挑战-响应”方案。类似的方案在应用层上屡见不鲜，BLE设备专用认证机制中尤为如此。最流行的硬件模块所提供的加密支持方案中仅限于简单的AES加密算法。因此，如果某个开发者想设计自己的加密协议，他通常会使用AES加密算法以及静态密钥，设备以及移动应用会共享同一个密钥。与对称密钥机制类似，这里最令人头疼的是，如何安全地共享及验证密钥，并且不在明文传输数据中泄露密钥信息？由于这种场景没有公钥加密算法提供支持，因此通常会引入“挑战-响应”机制。这里缺乏统一的标准，全凭开发者自己创造。如果“加密”机制出错，会导致什么后果呢？
再来看一下上面那张图。初始的挑战问题由移动手机生成，与设备无关。现在，如果设备仅凭挑战问题来计算响应数据，那么同一个挑战会得到同一个响应。这种场景很容易受到简单的重放攻击影响。攻击者可以记录下交换的数据，然后简单重放这段数据即可，不需要深入理解数据包内容：
我们可以试一下重放攻击。GATTacker工具会将拦截到的所有数据保存在dump子目录中，文件名对应设备的MAC地址。在本文案例中，这个文件内容如下所示：
    2017.10.24 10:50:54.531 |  R | ffe0 | fff1 | a20500f0c77f162e8bd21110841e641e641480 (       .      d d  )
    2017.10.24 10:50:54.980 |  R | ffe0 | fff1 | a20900 (   )
    2017.10.24 10:50:55.610 |  R | ffe0 | fff1 | a206002c010000 (   ,   )
    2017.10.24 10:50:56.645 |  R | ffe0 | fff1 | a206002c010000 (   ,   )
    2017.10.24 10:50:57.277 |  R | ffe0 | fff1 | a206002c010000 (   ,   )
    2017.10.24 10:50:57.951 |  R | ffe0 | fff1 | a20100 (   )
这个文件的[格式](https://github.com/securing/gattacker/wiki/Dump-and-replay)非常简单，
R代表从设备返回的read响应。接下来为服务及属性信息，然后跟着以十六进制表示的传输数据。时间戳以及解码后的ascii值仅供参考，重放攻击中不需要使用这两个信息。  
我们可以调用replay.js脚本，将这个文件作为参数，发起重放攻击：
随后，设备解锁了，同时发出了非常响亮的哔哔声。
我们也可以使用手机来完成这个操作。Android上的[nRF
Connect](https://play.google.com/store/apps/details?id=no.nordicsemi.android.mcp)应用包含一个非常有趣的特性：[macros（宏）](https://github.com/NordicSemiconductor/Android-nRF-Connect/tree/master/documentation/Macros)功能。只要提供一个特殊格式的XML输入文件，这个应用就可以重放任何BLE通信数据。我们只需要[将GATTacker的导出文件转换为对应的nRF宏XML格式](https://github.com/securing/gattacker/wiki/Dump-and-replay)即可：
    # node gattacker2nrf.js -i dump/f0c77f162e8b.log > dump/f0c77f162e8b.xml
你可以访问[此处链接](https://smartlockpicking.com/img/2017/10/f0c77f162e8b.xml)查看结果文件，并将该文件导入nRF
Connect应用。接下来，连接设备，按下播放按钮，开始重放：
这是个很好的技巧，接下来，你不需要使用其他硬件就可以与设备交互。你可以根据需求修改XML输入文件。
关于嗅探及重放攻击，我建议你阅读另一个智能锁厂商公布的这份[安全通知](https://www.thequicklock.com/security-notice.php)。当时这个厂商疲于应付密码嗅探漏洞的指责文章，因此公布了这份通知。我并不赞同里面提到的各种借口，比如，他们说之所以使用明文来发送密码，是为了“厂商在产品集成时更加方便”。但有一点他们说的没错，那就是这种攻击场景需要满足特定条件：在嗅探或者重放攻击场景中，当受害者解锁设备的那一刻，攻击者必须处于蓝牙覆盖范围内。因此，即使考虑到高增益天线以及越来越多的可利用设备，实际生活中这种攻击带来的风险是有限的。随便说一句，从这份通知中，你还可以知道许多用户不会刻意去修改默认密码。
现在，我们来看看更加令人惊悚的攻击场景，这种攻击场景甚至不需要提前嗅探数据包。
**  
**
**五、专有协议**
现在，我们终于要深入分析这种专有通信协议了。分析专有协议的首选方法之一就是逆向移动应用程序。
**5.1 逆向移动应用**
想找到如何逆向Android应用程序的教程并不难。大概步骤是：获取应用的apk二进制文件，反编译这个文件，检查java源码。得到的源码并不是真正的原始代码，不带注释，代码对齐也不是特别规整，但大多数情况下，开发者并没有使用任何混淆技术，因此反编译得到的代码可读性还是很强的。
这个代码中，首先可以看一下“SmartLock”类。这个类文件的开头部分如下所示：
我敢肯定你的眼睛会停留在SUPER_PASSWORD上。这个值被硬编码到应用中，因此很有可能也会内嵌在设备中。显而易见，我们可以将“741689”作为密码来尝试一下。然而，事实证明这不是真正的密码。稍等一下，我记得我们看到过这些数字，没错，初始握手交互中出现过这些数字！
在反编译出来的源码中，使用grep命令，我们可以找到某些代码片段，从中了解握手过程的工作原理：
    byte[] password = "741689".getBytes();
    (...)
    mVerifyData.generateFistRandomData();
    mVerifyState = 1;
    byte[] arrayOfByte2 = mVerifyData.getFirstRandomData();
    ByteBuffer localByteBuffer2 = ByteBuffer.allocate(15);
    localByteBuffer2.put(password);
    localByteBuffer2.put(arrayOfByte2);
    MsgRequestVerify localMsgRequestVerify = new MsgRequestVerify();
    localMsgRequestVerify.sendData(localByteBuffer2.array());
从这段代码中我们可知，移动应用会生成随机的数据，用于初始的“挑战”问题，然后将结果附加到“741689”末尾，以对应MsgRequestVerify格式。在MsgRequestVerify类的源码中，我们可以找到如下代码：
    public static final int MSG_CMD = 5;
    public static final int MSG_LENGTH = 19;
    public static final int MSG_STX = 161;
    public final byte con1 = 120;
    public final byte con2 = -102;