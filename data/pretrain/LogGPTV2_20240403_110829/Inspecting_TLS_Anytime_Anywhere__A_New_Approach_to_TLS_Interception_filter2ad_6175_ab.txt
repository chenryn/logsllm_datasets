â„“ğ¶, â„“ğ‘†
ğ»ğ¶, ğ»ğ‘†
FINğ¶, FINğ‘†
EFINğ¶, EFINğ‘†
Meaning
Serverâ€™s public and private keys (resp.)
Positive integers denoting the bit-length
Clientâ€™s and Serverâ€™s random nonces (resp.)
A certificate for serverâ€™s public key ğ‘ğ‘˜ğ‘† issued
by CA
Hash function
Key Encapsulation Mechanism
Encasulation/Decapsulation algorithm of KEM
(resp.)
Pre-Master Secret
KEM Ciphertext
Key Derivation Function
Master Secret
Pseudo-Random Function
Client and Serverâ€™s encryption keys for stateful
encryption
Encryption/Decryption algorithm of stateful
encryption stE
The current state for encryption and decryption
(resp.)
Length parameters of Client and Server (resp.)
Header data of Client and Server (resp.)
Client and Serverâ€™s finished message (resp.)
Client and Serverâ€™s encrypted finished message
(resp.)
inspection capability. However, as long as this key is kept secret,
the encrypted traffic will not be compromised.
Minimal modification. Our IA2-TLS protocol is based on the original
TLS protocol, especially TLS v1.2 [5]. We wanted to avoid a dramatic
modification of the TLS protocol to keep all of its functionality and
security. IA2-TLS only slightly modifies the handshake protocol,
and the rest of the protocol is identical to those of TLS.
Inspection Key. In our IA2-TLS protocol, the inspector creates a
uniform â€œinspection keyâ€. After being combined with the random
nonces generated by the client and server at the beginning of the
TLS handshake protocol, this key will be used to create a PMS
through a key encapsulation mechanism. The inspection key has
the capacity to recover the PMS without using the serverâ€™s private
key.
The size of the inspection key should reflect the security level
the most of modern symmetric key cryptosystems should provide.
Namely, it should be at least 128 bits long, but we recommend 256
bits. The lifetime of the inspection key depends on the policy, but
it should not be used for an extended period.
Moderated KEM. The key encapsulation mechanism (KEM) is an
essential cryptographic primitive used in TLS to generate the key
material, â€œPre-Master secret (PMS)â€, which the client and server
will use to derive subsequent (symmetric) keys to encrypt their
application data after a handshake. For example, the Diffie-Hellman
key exchange used in TLS can be described as a KEM scheme that
encapsulates the serverâ€™s public key ğ‘¦ = ğ‘”ğ‘¥ into a PMS, ğ‘¦ğ‘Ÿ for
random ğ‘Ÿ, and a corresponding ciphertext, ğ‘”ğ‘Ÿ , which should be
contained in ClientKeyExchange.
Our IA2-TLS is constructed using a usual randomized KEM. Our
idea is to generate a random coin used for randomization via hash-
ing the inspection key together with the client and serverâ€™s random
nonces. If the randomized KEM scheme has the property that the
key generated by its encapsulation algorithm can also be recovered
using the random coin, the inspector will be able to obtain the same
PMS. More formally, we require an additional property from the
KEM: There exists an efficient (polynomial-time) algorithm Î¦ such
that Î¦(ğ‘Ÿ, CT, ğ‘ğ‘˜ğ‘†) outputs PMS, where (CT, PMS) = EKEM(ğ‘ğ‘˜; ğ‘Ÿ).
In fact, many randomized KEM schemes satisfy this property in-
cluding DH-KEM and RSA-KEM, both of which are described in
Section 3.3.
3.2 Description of IA2-TLS
In Figure 2, we describe our IA2-TLS protocol. Note that we extract
necessary cryptographic components from TLS v1.2 [5] and present
them following the style similar to those given in [11] and [15]. In
Table 1, we summarize the notation used in the description.
Note that in Figure 2, the procedure â€œif PMS = âŠ¥, PMS â†$ {0, 1}ğœ†â€²â€
in the server is to hide decryption failure so that it can prevent
Bleichenbacher-style attack [3].
3.3 Instantiations of IA2-TLS
The Diffie-Hellman (DH) and RSA are the two most popular cryp-
tographic primitives for TLS while the former is gathering more
momentum nowadays. The randomized KEM of the IA2-TLS proto-
col can be instantiated using these primitives.
Diffie-Hellman-KEM. The DH-KEM scheme is described in Figure 3,
where ğ‘Ÿ âˆˆ Zğ‘ is chosen uniformly at random.
When IA2-TLS is instantiated by the DH-KEM, the range of hash
function H should be Zğ‘. It is easy to see that PMS of the DH-KEM
can be derived using the random coin instead of the private key,
which is the required property as discussed in Section 3.1: One can
construct a polynomial-time algorithm Î¦ which works as follows.
It first extracts ğ‘¦ from ğ‘ğ‘˜ğ‘† and computes PMS = ğ‘¦ğ‘Ÿ .
RSA-KEM (PKCS #1 v1.5). As far as v1.2 is concerned, TLS supports
RSA PKCS #1 v1.5 encryption [13] in which a uniform value ğ‘Ÿ is used
as PMS, and is encrypted by RSA function, thereby constituting a
RSA-KEM scheme described in Figure 4. (We assume that ğ‘›0 = Î˜(ğ‘›)
and ğ‘›1 = Î˜(ğ‘›) with ğ‘›0 â‰¤ ğ‘›1 âˆ’ 88, where ğ‘›1 is a multiple of 8. We
also assume that ğ‘Ÿ âˆˆ {0, 1}ğ‘›0 is chosen uniformly at random.)
Obviously, this scheme can also be used to construct IA2-TLS
by computing ğ‘Ÿ â† H( Ëœğ‘˜, ğœ‡ğ¶||ğœ‡ğ‘†). In this case, the polynomial-time
algorithm Î¦ simply outputs PMS = ğ‘Ÿ.
4 SECURITY
4.1 Threat Model
As a threat model, we assume the following for an attacker A
trying to break the security of IA2-TLS in which the target client
and server communicate:
Session 3: Network Security ASIA CCS '20, October 5â€“9, 2020, Taipei, Taiwan118Setup Phase The inspector generates an inspection key Ëœğ‘˜ uniformly at random from {0, 1}â„“.
Handshake Phase
Client
ğœ‡ğ¶ â†$ {0, 1}ğœ†
Server
ğœ‡ğ‘† â†$ {0, 1}ğœ†
Certğ‘† â† {IDğ‘† , ğ‘ğ‘˜ğ‘† }CA
ğœ‡ğ¶
ğœ‡ğ‘† ||Certğ‘†
Abort if Certğ‘† is invalid
ğ‘Ÿ â† H( Ëœğ‘˜, ğœ‡ğ¶ ||ğœ‡ğ‘†)
(CT, PMS) â† EKEM(ğ‘ğ‘˜ğ‘†; ğ‘Ÿ)
MS â† KDF(PMS, ğœ‡ğ¶ ||ğœ‡ğ‘†)
ğ¾ğ¶ ||ğ¾ğ‘† â† PRF(MS, 0||ğœ‡ğ¶ ||ğœ‡ğ‘†)
FINğ¶ â† PRF(MS, 1||ğœ‡ğ¶ ||ğœ‡ğ‘† ||Certğ‘† ||CT)
EFINğ¶ â† EncstE(ğ¾ğ¶, â„“ğ¶, ğ»ğ¶, FINğ¶, ğ‘ ğ‘¡ğ‘’)
CT||ğ»ğ¶ ||EFINğ¶
PMS â† DKEM(ğ‘ ğ‘˜ğ‘† , CT)
if PMS = âŠ¥, PMS â†$ {0, 1}ğœ†â€²
MS = KDF(PMS, ğœ‡ğ¶ ||ğœ‡ğ‘†)
ğ¾ğ¶ ||ğ¾ğ‘† â† PRF(MS, 0||ğœ‡ğ¶ ||ğœ‡ğ‘†)
FINğ¶ â† DecstE(ğ¾ğ¶, Hğ¶, EFINğ¶, ğ‘ ğ‘¡ğ‘‘)
if FINğ¶ â‰  PRF(MS, 1||ğœ‡ğ¶ ||ğœ‡ğ‘† ||Certğ‘† ||CT),
set Î“ := reject and abort
FINğ‘† â† PRF(MS, 2||ğœ‡ğ¶ ||ğœ‡ğ‘† ||Certğ‘† ||
CT||FINğ¶)
EFINğ‘† â† EncstE(ğ¾ğ‘† , â„“ğ‘† , ğ»ğ‘† , FINğ‘† , ğ‘ ğ‘¡ğ‘’)
Hğ‘† , EFINğ‘†
Set Î“ := accept
FINğ‘† â† DecstE(Kğ‘† , ğ»ğ‘† , EFINğ‘† , ğ‘ ğ‘¡ğ‘‘)
if FINğ‘† â‰  PRF(MS, 2||ğœ‡ğ¶ ||ğœ‡ğ‘† ||Certğ‘† ||
CT||FINğ¶),
set Î“ := reject and abort
else set Î“ := accept
Inspection Phase The inspector computes ğ‘Ÿ â† H( Ëœğ‘˜, ğœ‡ğ¶||ğœ‡ğ‘†) and PMS â† Î¦(ğ‘Ÿ, CT, ğ‘ğ‘˜ğ‘†).
Figure 2: IA2-TLS Protocol
â€¢ A aims to obtain any partial or entire information about
the target clientâ€™s current pre-master secret (PMS) or master
secret (MS).
â€¢ A does not have access to the current inspection key nor
â€¢ A can pretend to be the target client by choosing the clientâ€™s
nonce value, ğœ‡ğ¶, but cannot do so to the server. (In other
the private key of the server.
words, the serverâ€™s nonce, ğœ‡ğ‘†, is chosen uniformly at ran-
dom.)
â€¢ A is able to obtain all the transcripts of communication
between the target client and server during a handshake.
â€¢ A can get MSâ€™s that corresponds to some CTâ€™s (KEM cipher-
texts) of his choice except for the target clientâ€™s current CT
and MC pair.
Session 3: Network Security ASIA CCS '20, October 5â€“9, 2020, Taipei, Taiwan119GDH-KEM(1ğ‘›)
(ğ‘, ğ‘”, G) â†$ GrGen(1ğ‘›)
ğ‘¥ â†$ Zğ‘; ğ‘¦ â† ğ‘”ğ‘¥
ğ‘ ğ‘˜ğ‘† â† (ğ‘, ğ‘”, ğ‘¥)
ğ‘ğ‘˜ğ‘† â† (ğ‘, ğ‘”, ğ‘¦)
return (ğ‘ ğ‘˜ğ‘† , ğ‘ğ‘˜ğ‘†)
EDH-KEM(ğ‘ğ‘˜ğ‘†; ğ‘Ÿ)
CT â† ğ‘”ğ‘Ÿ
PMS â† ğ‘¦ğ‘Ÿ
return (CT, PMS)
DDH-KEM(ğ‘ ğ‘˜ğ‘†, CT)
PMS â† CTğ‘¥
return PMS
Figure 3: DH-KEM
DRSA-KEM(ğ‘ ğ‘˜ğ‘†, CT)
ğ‘¥ â† CTğ‘‘ mod ğ‘
00||02||ğ‘ƒ ||00||PMS
â† ğ‘¥
return PMS
GRSA-KEM(1ğ‘›)
(ğ‘, ğ‘) â†$ PrmGen(1ğ‘›)
ğ‘ â† ğ‘ğ‘ (|ğ‘ | = ğ‘›1)
Pick ğ‘’, ğ‘‘ such that
ğ‘’ğ‘‘ = 1 mod ğœ™(ğ‘)
ğ‘ ğ‘˜ğ‘† â† (ğ‘‘, ğ‘)
ğ‘ğ‘˜ğ‘† â† (ğ‘’, ğ‘)
return (ğ‘ ğ‘˜ğ‘† , ğ‘ğ‘˜ğ‘†)
ERSA-KEM(ğ‘ğ‘˜ğ‘†; ğ‘Ÿ)
Set PMS = ğ‘Ÿ
ğ‘ƒ â†$ {0, 1}ğ‘›1âˆ’ğ‘›0âˆ’24
ğ‘¥ â†
00||02||ğ‘ƒ ||00||PMS
CT â† ğ‘¥ğ‘’ mod ğ‘
return (CT, PMS)
Figure 4: RSA-KEM
4.2 Formal Analysis
IA2-TLS-KEM. For the formal security analysis, we extract the key
encapsulation (KEM) from the IA2-TLS handshake and define the
following KEM scheme, which we call â€œIA2-TLS-KEMâ€. Our KEM
scheme is based on the usual randomized KEM scheme described
in Section 2.2. A formal description of IA2-TLS-KEM is given as
follows.
GIA2-TLS-KEM(1ğ‘›)
(ğ‘ğ‘˜ğ‘ , ğ‘ ğ‘˜ğ‘†) â† GKEM(1ğ‘›)
Ëœğ‘˜ â†$ {0, 1}â„“
return (ğ‘ğ‘˜ğ‘† , ğ‘ ğ‘˜ğ‘† , Ëœğ‘˜)
EIA2-TLS-KEM(ğ‘ğ‘˜ğ‘†, Ëœğ‘˜, ğœ‡ğ¶||ğœ‡ğ‘†)
ğ‘Ÿ â† H( Ëœğ‘˜, ğœ‡ğ¶ ||ğœ‡ğ‘†)
(CT, PMS) â† EKEM(ğ‘ğ‘˜ğ‘†; ğ‘Ÿ)
MS â† KDF(PMS, ğœ‡ğ¶ ||ğœ‡ğ‘†)
return (CT, MS)
DIA2-TLS-KEM(ğ‘ ğ‘˜ğ‘†, CT, ğœ‡ğ¶||ğœ‡ğ‘†)
PMS â† DKEM(ğ‘ ğ‘˜ğ‘† , CT)
MS â† KDF(PMS, ğœ‡ğ¶ ||ğœ‡ğ‘†)
return MS
Based on the threat model we discussed in Section 4.1, we can
formulate a security notion for the IA2-TLS-KEM, which is given
as follows.
Definition 4.1 (IND-CCA of IA2-TLS-KEM). Let A be an adversary.
Consider the following game:
ğ‘† ,Â·),Decap(ğ‘ ğ‘˜ğ‘† ,Â·,Â·) (ğ‘ğ‘˜ğ‘† , ğ¾ğ›½, CTâˆ—, ğœ‡âˆ—
ğ¶ ||ğœ‡âˆ—
ğ‘†)
ğ¶ ||ğœ‡âˆ—
ğ‘†)
CCAA,IA2-TLS-KEM(ğ‘›)
(ğ‘ ğ‘˜ğ‘† , ğ‘ğ‘˜ğ‘† , Ëœğ‘˜) â†$ GIA2-TLS-KEM(1ğ‘›)
ğœ‡âˆ—
ğ¶ â† A(ğ‘ğ‘˜ğ‘†)
ğœ‡âˆ—