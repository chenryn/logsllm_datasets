ℓ𝐶, ℓ𝑆
𝐻𝐶, 𝐻𝑆
FIN𝐶, FIN𝑆
EFIN𝐶, EFIN𝑆
Meaning
Server’s public and private keys (resp.)
Positive integers denoting the bit-length
Client’s and Server’s random nonces (resp.)
A certificate for server’s public key 𝑝𝑘𝑆 issued
by CA
Hash function
Key Encapsulation Mechanism
Encasulation/Decapsulation algorithm of KEM
(resp.)
Pre-Master Secret
KEM Ciphertext
Key Derivation Function
Master Secret
Pseudo-Random Function
Client and Server’s encryption keys for stateful
encryption
Encryption/Decryption algorithm of stateful
encryption stE
The current state for encryption and decryption
(resp.)
Length parameters of Client and Server (resp.)
Header data of Client and Server (resp.)
Client and Server’s finished message (resp.)
Client and Server’s encrypted finished message
(resp.)
inspection capability. However, as long as this key is kept secret,
the encrypted traffic will not be compromised.
Minimal modification. Our IA2-TLS protocol is based on the original
TLS protocol, especially TLS v1.2 [5]. We wanted to avoid a dramatic
modification of the TLS protocol to keep all of its functionality and
security. IA2-TLS only slightly modifies the handshake protocol,
and the rest of the protocol is identical to those of TLS.
Inspection Key. In our IA2-TLS protocol, the inspector creates a
uniform “inspection key”. After being combined with the random
nonces generated by the client and server at the beginning of the
TLS handshake protocol, this key will be used to create a PMS
through a key encapsulation mechanism. The inspection key has
the capacity to recover the PMS without using the server’s private
key.
The size of the inspection key should reflect the security level
the most of modern symmetric key cryptosystems should provide.
Namely, it should be at least 128 bits long, but we recommend 256
bits. The lifetime of the inspection key depends on the policy, but
it should not be used for an extended period.
Moderated KEM. The key encapsulation mechanism (KEM) is an
essential cryptographic primitive used in TLS to generate the key
material, “Pre-Master secret (PMS)”, which the client and server
will use to derive subsequent (symmetric) keys to encrypt their
application data after a handshake. For example, the Diffie-Hellman
key exchange used in TLS can be described as a KEM scheme that
encapsulates the server’s public key 𝑦 = 𝑔𝑥 into a PMS, 𝑦𝑟 for
random 𝑟, and a corresponding ciphertext, 𝑔𝑟 , which should be
contained in ClientKeyExchange.
Our IA2-TLS is constructed using a usual randomized KEM. Our
idea is to generate a random coin used for randomization via hash-
ing the inspection key together with the client and server’s random
nonces. If the randomized KEM scheme has the property that the
key generated by its encapsulation algorithm can also be recovered
using the random coin, the inspector will be able to obtain the same
PMS. More formally, we require an additional property from the
KEM: There exists an efficient (polynomial-time) algorithm Φ such
that Φ(𝑟, CT, 𝑝𝑘𝑆) outputs PMS, where (CT, PMS) = EKEM(𝑝𝑘; 𝑟).
In fact, many randomized KEM schemes satisfy this property in-
cluding DH-KEM and RSA-KEM, both of which are described in
Section 3.3.
3.2 Description of IA2-TLS
In Figure 2, we describe our IA2-TLS protocol. Note that we extract
necessary cryptographic components from TLS v1.2 [5] and present
them following the style similar to those given in [11] and [15]. In
Table 1, we summarize the notation used in the description.
Note that in Figure 2, the procedure “if PMS = ⊥, PMS ←$ {0, 1}𝜆′”
in the server is to hide decryption failure so that it can prevent
Bleichenbacher-style attack [3].
3.3 Instantiations of IA2-TLS
The Diffie-Hellman (DH) and RSA are the two most popular cryp-
tographic primitives for TLS while the former is gathering more
momentum nowadays. The randomized KEM of the IA2-TLS proto-
col can be instantiated using these primitives.
Diffie-Hellman-KEM. The DH-KEM scheme is described in Figure 3,
where 𝑟 ∈ Z𝑞 is chosen uniformly at random.
When IA2-TLS is instantiated by the DH-KEM, the range of hash
function H should be Z𝑞. It is easy to see that PMS of the DH-KEM
can be derived using the random coin instead of the private key,
which is the required property as discussed in Section 3.1: One can
construct a polynomial-time algorithm Φ which works as follows.
It first extracts 𝑦 from 𝑝𝑘𝑆 and computes PMS = 𝑦𝑟 .
RSA-KEM (PKCS #1 v1.5). As far as v1.2 is concerned, TLS supports
RSA PKCS #1 v1.5 encryption [13] in which a uniform value 𝑟 is used
as PMS, and is encrypted by RSA function, thereby constituting a
RSA-KEM scheme described in Figure 4. (We assume that 𝑛0 = Θ(𝑛)
and 𝑛1 = Θ(𝑛) with 𝑛0 ≤ 𝑛1 − 88, where 𝑛1 is a multiple of 8. We
also assume that 𝑟 ∈ {0, 1}𝑛0 is chosen uniformly at random.)
Obviously, this scheme can also be used to construct IA2-TLS
by computing 𝑟 ← H( ˜𝑘, 𝜇𝐶||𝜇𝑆). In this case, the polynomial-time
algorithm Φ simply outputs PMS = 𝑟.
4 SECURITY
4.1 Threat Model
As a threat model, we assume the following for an attacker A
trying to break the security of IA2-TLS in which the target client
and server communicate:
Session 3: Network Security ASIA CCS '20, October 5–9, 2020, Taipei, Taiwan118Setup Phase The inspector generates an inspection key ˜𝑘 uniformly at random from {0, 1}ℓ.
Handshake Phase
Client
𝜇𝐶 ←$ {0, 1}𝜆
Server
𝜇𝑆 ←$ {0, 1}𝜆
Cert𝑆 ← {ID𝑆 , 𝑝𝑘𝑆 }CA
𝜇𝐶
𝜇𝑆 ||Cert𝑆
Abort if Cert𝑆 is invalid
𝑟 ← H( ˜𝑘, 𝜇𝐶 ||𝜇𝑆)
(CT, PMS) ← EKEM(𝑝𝑘𝑆; 𝑟)
MS ← KDF(PMS, 𝜇𝐶 ||𝜇𝑆)
𝐾𝐶 ||𝐾𝑆 ← PRF(MS, 0||𝜇𝐶 ||𝜇𝑆)
FIN𝐶 ← PRF(MS, 1||𝜇𝐶 ||𝜇𝑆 ||Cert𝑆 ||CT)
EFIN𝐶 ← EncstE(𝐾𝐶, ℓ𝐶, 𝐻𝐶, FIN𝐶, 𝑠𝑡𝑒)
CT||𝐻𝐶 ||EFIN𝐶
PMS ← DKEM(𝑠𝑘𝑆 , CT)
if PMS = ⊥, PMS ←$ {0, 1}𝜆′
MS = KDF(PMS, 𝜇𝐶 ||𝜇𝑆)
𝐾𝐶 ||𝐾𝑆 ← PRF(MS, 0||𝜇𝐶 ||𝜇𝑆)
FIN𝐶 ← DecstE(𝐾𝐶, H𝐶, EFIN𝐶, 𝑠𝑡𝑑)
if FIN𝐶 ≠ PRF(MS, 1||𝜇𝐶 ||𝜇𝑆 ||Cert𝑆 ||CT),
set Γ := reject and abort
FIN𝑆 ← PRF(MS, 2||𝜇𝐶 ||𝜇𝑆 ||Cert𝑆 ||
CT||FIN𝐶)
EFIN𝑆 ← EncstE(𝐾𝑆 , ℓ𝑆 , 𝐻𝑆 , FIN𝑆 , 𝑠𝑡𝑒)
H𝑆 , EFIN𝑆
Set Γ := accept
FIN𝑆 ← DecstE(K𝑆 , 𝐻𝑆 , EFIN𝑆 , 𝑠𝑡𝑑)
if FIN𝑆 ≠ PRF(MS, 2||𝜇𝐶 ||𝜇𝑆 ||Cert𝑆 ||
CT||FIN𝐶),
set Γ := reject and abort
else set Γ := accept
Inspection Phase The inspector computes 𝑟 ← H( ˜𝑘, 𝜇𝐶||𝜇𝑆) and PMS ← Φ(𝑟, CT, 𝑝𝑘𝑆).
Figure 2: IA2-TLS Protocol
• A aims to obtain any partial or entire information about
the target client’s current pre-master secret (PMS) or master
secret (MS).
• A does not have access to the current inspection key nor
• A can pretend to be the target client by choosing the client’s
nonce value, 𝜇𝐶, but cannot do so to the server. (In other
the private key of the server.
words, the server’s nonce, 𝜇𝑆, is chosen uniformly at ran-
dom.)
• A is able to obtain all the transcripts of communication
between the target client and server during a handshake.
• A can get MS’s that corresponds to some CT’s (KEM cipher-
texts) of his choice except for the target client’s current CT
and MC pair.
Session 3: Network Security ASIA CCS '20, October 5–9, 2020, Taipei, Taiwan119GDH-KEM(1𝑛)
(𝑞, 𝑔, G) ←$ GrGen(1𝑛)
𝑥 ←$ Z𝑞; 𝑦 ← 𝑔𝑥
𝑠𝑘𝑆 ← (𝑝, 𝑔, 𝑥)
𝑝𝑘𝑆 ← (𝑞, 𝑔, 𝑦)
return (𝑠𝑘𝑆 , 𝑝𝑘𝑆)
EDH-KEM(𝑝𝑘𝑆; 𝑟)
CT ← 𝑔𝑟
PMS ← 𝑦𝑟
return (CT, PMS)
DDH-KEM(𝑠𝑘𝑆, CT)
PMS ← CT𝑥
return PMS
Figure 3: DH-KEM
DRSA-KEM(𝑠𝑘𝑆, CT)
𝑥 ← CT𝑑 mod 𝑁
00||02||𝑃 ||00||PMS
← 𝑥
return PMS
GRSA-KEM(1𝑛)
(𝑝, 𝑞) ←$ PrmGen(1𝑛)
𝑁 ← 𝑝𝑞 (|𝑁 | = 𝑛1)
Pick 𝑒, 𝑑 such that
𝑒𝑑 = 1 mod 𝜙(𝑁)
𝑠𝑘𝑆 ← (𝑑, 𝑁)
𝑝𝑘𝑆 ← (𝑒, 𝑁)
return (𝑠𝑘𝑆 , 𝑝𝑘𝑆)
ERSA-KEM(𝑝𝑘𝑆; 𝑟)
Set PMS = 𝑟
𝑃 ←$ {0, 1}𝑛1−𝑛0−24
𝑥 ←
00||02||𝑃 ||00||PMS
CT ← 𝑥𝑒 mod 𝑁
return (CT, PMS)
Figure 4: RSA-KEM
4.2 Formal Analysis
IA2-TLS-KEM. For the formal security analysis, we extract the key
encapsulation (KEM) from the IA2-TLS handshake and define the
following KEM scheme, which we call “IA2-TLS-KEM”. Our KEM
scheme is based on the usual randomized KEM scheme described
in Section 2.2. A formal description of IA2-TLS-KEM is given as
follows.
GIA2-TLS-KEM(1𝑛)
(𝑝𝑘𝑠, 𝑠𝑘𝑆) ← GKEM(1𝑛)
˜𝑘 ←$ {0, 1}ℓ
return (𝑝𝑘𝑆 , 𝑠𝑘𝑆 , ˜𝑘)
EIA2-TLS-KEM(𝑝𝑘𝑆, ˜𝑘, 𝜇𝐶||𝜇𝑆)
𝑟 ← H( ˜𝑘, 𝜇𝐶 ||𝜇𝑆)
(CT, PMS) ← EKEM(𝑝𝑘𝑆; 𝑟)
MS ← KDF(PMS, 𝜇𝐶 ||𝜇𝑆)
return (CT, MS)
DIA2-TLS-KEM(𝑠𝑘𝑆, CT, 𝜇𝐶||𝜇𝑆)
PMS ← DKEM(𝑠𝑘𝑆 , CT)
MS ← KDF(PMS, 𝜇𝐶 ||𝜇𝑆)
return MS
Based on the threat model we discussed in Section 4.1, we can
formulate a security notion for the IA2-TLS-KEM, which is given
as follows.
Definition 4.1 (IND-CCA of IA2-TLS-KEM). Let A be an adversary.
Consider the following game:
𝑆 ,·),Decap(𝑠𝑘𝑆 ,·,·) (𝑝𝑘𝑆 , 𝐾𝛽, CT∗, 𝜇∗
𝐶 ||𝜇∗
𝑆)
𝐶 ||𝜇∗
𝑆)
CCAA,IA2-TLS-KEM(𝑛)
(𝑠𝑘𝑆 , 𝑝𝑘𝑆 , ˜𝑘) ←$ GIA2-TLS-KEM(1𝑛)
𝜇∗
𝐶 ← A(𝑝𝑘𝑆)
𝜇∗