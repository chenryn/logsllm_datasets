Trusted Applications
Untrusted Applications
Method Dispatcher
Object Cap.
System
Scheduler
Crypto
Tunnels
Untrusted OS
Trusted Hardware
Untrusted Hardware
Capability Kernel
Network
Other Devices
Figure 1. Software architecture of the ﬁrst
generation Annex Capability Kernel and its
relationship to its untrusted surrogate plat-
form.
may communicate with untrusted applications on their sur-
rogate platform, or also with trusted applications on a dif-
ferent host via a secure tunnelling mechanism.
Firstly, a scheduler allows for multiple method invoca-
tions to be serviced in parallel. This allows the kernel to
efﬁciently process blocking operations like network com-
munication. All methods execute in separate threads that
may only access the target object and the method invoca-
tion parameters. Although our prototype devices do not
strictly enforce this isolation, we are developing hardware
and software features that will guarantee absolute separa-
tion in the future. Our ﬁrst generation scheduler is also non-
preemptive so co-operative multitasking is required, which
causes problems when using synchronous method calls, but
we are updating our programming model and scheduler to
overcome these limitations [11].
Secondly, a tunnels manager provides for mutually au-
thenticated, conﬁdential communication between object-
capability kernels running on different devices. The Difﬁe-
Hellman Station-to-Station protocol using Elliptic-Curve
Cryptography (ECC) provides mutual authentication and
symmetric-key agreement. The Advanced Encryption Stan-
dard (AES) operating in CFB mode ensures conﬁdentiality.
Tunnels can be cached for efﬁciency and different channels
of communication can be multiplexed over one tunnel.
Tunnels are directly connected into the third component,
the dispatcher. The dispatcher provides both network trans-
parent method invocation and enforces capability-based ac-
cess control to local objects. This centralised checking
mechanism makes it possible to avoid error or abuse during
capability veriﬁcation. Furthermore, because Annex capa-
bilities are the exclusive object naming mechanism the dis-
patcher provides mandatory access control that cannot be
bypassed.
To achieve this the dispatcher relies on a number of com-
ponents that make up the object-capability implementation.
Our object-capability implementation comprises an object-
type database, an object store and a password capability
catalogue. Before a method invocation is dispatched the va-
lidity of the capability is checked with the catalogue, com-
paring the permissions it carries against those required by
the method in the object’s type deﬁnition.
If they match
then the object is loaded from the store and the method is
executed.
Finally, our development environment includes tools for
writing and compiling object type deﬁnitions. Each deﬁ-
nition must include the object’s method code as well as a
description of the internal state that the object maintains,
which is saved in the object store. Our initial implementa-
tion relied on static compile-time deﬁnitions of all possible
object types, but we have now prototyped a loader that al-
lows new object types to be instantiated at run time. This
enables packaged collections of object-type deﬁnitions to
be dynamically replaced. Thus the Annex architecture pro-
vides not only an access control framework but the means
by which to develop and deploy arbitrary services to extend
functionality.
2.5 Distribution and Revocation
The Annex security architecture is ﬂexible enough to
support a wide range of capability distribution and revoca-
tion schemes, implemented on top of the object-capability
model. Possibilities for capability distribution mechanisms
include centralised authority hierarchies and decentralised
“webs of trust” as in PGP [30]. Our current proof-of-
concept services, however, only use simple distribution
schemes in order to allow us to experiment with the basic
ideas before constructing more sophisticated mechanisms.
It should be noted that once implemented, any mechanism
should be readily reusable so long as it treats all capabilities
it distributes identically.
Once a capability has been distributed, the only way to
cancel its authority is by revoking that capability. While
it is simple to revoke a capability by removing its record
from the appropriate catalogue, determining which capabil-
ities require revocation is very difﬁcult without information
regarding the propagation of capabilities between devices,
otherwise it is impossible to know who holds any partic-
ular capability. We have developed a kernel-based algo-
rithm for recording this information in a capability propaga-
tion graph, similar to that invented by Gligor [9]. Gligor’s
system, however, was only designed for single host sys-
tems, where the capability propagation graph is completely
available and always correct.
In contrast, the distributed
and mutually suspicious nature of our system makes stor-
ing a global propagation graph impractical and imprudent.
Hence, our revocation system was designed so that only lo-
cal capability propagation information is stored by any one
device. All devices cooperate to process this information
in a distributed manner when revocation operations must be
performed. In this respect our revocation algorithm is also
similar to Miller’s membrane pattern [16], but where our
capability tracking is performed by the kernel rather than
by the objects themselves. This allows our system to en-
force transitive revocation policies, although it does slightly
increase kernel complexity.
Since capabilities are partitioned so that objects only
ever know about handles to capabilities, the dispatcher can
always unambiguously identify capability transfers:
they
only occur as strongly typed parameters during method
calls. When the dispatcher intercepts a capability transfer,
it logs a (sequence number, capability, source object, desti-
nation object) tuple to an ordered list, called the capability
transfer table. Entries in the table must be retained so long
as the objects they point to exist, but old entries could be mi-
grated to specialised log servers to reduce storage require-
ments on end-user devices. Furthermore, because maintain-
ing and processing capability propagation information is ex-
pensive, our revocation system can be selectively enabled or
disabled on a per-capability basis, as deemed appropriate by
the issuer of a capability.
If it is later determined that a capability should be re-
voked – for example when someone no longer needs to per-
form a particular role, when someone no longer needs ac-
cess to a certain resource, when it is discovered that an ob-
ject was buggy or has been compromised, or when a device
may have been lost or compromised – then the issuing de-
vice will be notiﬁed, which will remove the capability from
its catalogue. It will also initiate distributed ﬂushing proce-
dures that recurse through the capability propagation graph
of the affected capability, purging any of the now useless
copies of the capability from other devices.
3 The Annex Network
The Annex network architecture reﬂects our vision of
what an ideal communication network for NCW, unencum-
bered by current practice and technology limitations, will
look like. This is not to say that the Annex network archi-
tecture is radically different from existing network archi-
tectures, but it is certainly far more focused on the future.
Rather than simply taking existing technologies (along with
all of their limitations) and ﬁguring out how they could be
applied to our vision, we ﬁrst developed our architecture
and then looked for any existing or developing technologies
that could fulﬁl any of our requirements; wherever these
technologies are inadequate we have developed our own.
Consequently many aspects of the Annex network architec-
ture closely resemble next generation networking technolo-
gies that are under development, although we have made a
small number of signiﬁcant enhancements that aid transpar-
ent wide-area mobility, robustness and provide strong secu-
rity guarantees.
3.1 Wireless Networks
Wireless networking is becoming increasingly common.
This is partially because wireless networks are easier and
often cheaper to deploy. More importantly, however, it is
because people like to be untethered. The ability for peo-
ple to access the information they require at any time and
place will help them to get their jobs done faster and better
than ever before. There are two key issues that need to be
overcome, however, before wireless networks will live up
to their potential: reliability and security.
While the reliability of current wireless network tech-
nologies is not perfect, the explosion in the number of
wireless network deployments around the world shows
that users are willing to live with occasional performance
glitches in return for the freedom that wireless networks
provide. Furthermore, the reliability of wireless networking
products is improving with every generation of new tech-
nology.
Similarly, the mechanisms available for securing wire-
less networks are also improving. Although these have
been woefully inadequate for many years, leaving wireless
networks dangerously exposed to unauthorised use, denial-
of-service, eavesdropping and impersonation, they have re-
cently matured to the level where they may be adequate
in many circumstances. Taking stock of the lessons learnt
from the ﬂawed design of WEP and the more recent design
compromises made for WPA, and standing back from the
management/deployment complexities of VPNs, the IEEE
has recently ratiﬁed a new security standard for wireless
networks, called 802.11i. The strongest form of protection
in 802.11i is called the Robust Security Network (RSN).
RSN uses 802.1X for authentication, which speciﬁes an
authentication and authorisation mechanism for allowing or
disallowing clients to access a wireless link. It uses a virtual
port-based approach, where both clients and networks must
prove their identity and authority to each other before fur-
ther network access is granted. After authentication, con-
ﬁdentiality and integrity is provided by the Advanced En-
cryption Standard algorithm in Counter mode with Cipher
block chaining Message authentication code (AES-CCMP),
using a key size of 128, 192 or 256 bits.
A number of 802.11i products that utilise 802.1X with
AES-CCMP have already been accredited under the US
Government’s Federal Information Processing Standard
(FIPS) 140-2 for sensitive but unclassiﬁed use. Although
Annex uses 802.11i to protect the wireless link layer, this
is intended to guard against casual interference only; strong
security guarantees are provided by the security architecture
described in Section 2.
3.2
IPv6 Networks
Future military networks are envisaged to operate on
a global scale with multiple levels of mobility between
end user devices and the supporting network infrastructure.
IPv6 [7], the evolutionary successor to IPv4 upon which the
Internet currently depends, is rightly seen as a major en-
abler for NCW and the GIG. A key aspect of this is IPv6’s
very large address space, which will be required to support
the large number of networks and individually addressable
nodes that are envisaged in the GIG. On top of this, Mobile
IPv6 (MIPv6) [14] offers transparent support for computers
that may change their point of attachment to the network.
During the MIPv6 handover period, however, a signiﬁ-
cant number of packets being streamed between highly mo-
bile nodes may arrive late or be lost altogether. Conse-
quently the MIPv6 protocol is not particularly suitable for
real-time data ﬂows between mobile hosts, such as for mo-
bile telephony. Hierarchical Mobile IPv6 (HMIPv6) [25]
is able to ensure faster handovers, but it is limited to ﬁxed
infrastructure deployments with a fairly static routing hier-
archy. While this may be sufﬁcient for most civilian net-
works, it is too limiting for highly mobile and transient mil-
itary networks. We therefore designed several backwards-
compatible enhancements to HMIPv6 for Annex networks
that remove these limitations, as described below.
3.3 Enhanced Addressing
An important IPv6 network allocation policy is that of
route aggregation, where preﬁx allocations are hierarchi-
cally assigned so that the number of routes that must be
remembered by the Internet’s core routers is minimised.
IPv6’s improved routing performance comes at a cost, how-
ever, as route aggregation leads to sparse address allocation.
Annex leverages this sparsity to encode topological network
information in IPv6 addresses, which can enhance address-
ing efﬁciency even for highly mobile nodes and infrastruc-
ture [10].
Annex employs a partitioned address allocation policy.
This is done so that nodes can be uniquely identiﬁed regard-
less of their point of attachment to the network, and to ex-
ploit the structured network topologies that tend to emerge
in large organisations for the purpose of enhancing routing
efﬁciency and functionality.
Table 2 shows the structure of an Annex device’s ad-
dress, with suggested bit allocations. The preﬁx ﬁeld rep-
resents the ﬁxed part of the IPv6 address space that will be
supplied by an Internet allocation authority and represents
the entire Annex domain. We have obtained a provider-
independent IPv6 allocation of 2001:4418/32 from AP-
Table 2. Addressing for Annex networks
Preﬁx
Family
BrickL2
L1
L0
,
,
Reserved DeviceID
32
8
8
8
8
16
48
NIC in which to host a trial version of the Annex network.
The family ﬁeld is used to partition the global Annex ad-
dress space into a number of domains or high level net-
works, where each can maintain its own independent ad-
ministrative control, routing, security, and service require-
ments.
Annex Bricks are network infrastructure devices that
provide a range of network and security services. Each
family assigns their own BrickLn ﬁelds to oversee routing,
service handling, and structure within their own networks.
The example address partitioning scheme promotes a three
level (i.e. fairly ﬂat) routing hierarchy, although more lev-
els could be used. These 3 levels could correspond to global
coverage (such as satellite) routers at L2, capital platforms
at L1 and tactical vehicles at L0.
The host part in the lower 64 bits of the IPv6 address (16
bits of which are currently reserved for future use) contains
the unique identity of any entity within the Annex network.
This address remains unchanged for the lifetime of the unit
and is never re-used. We envisage that these addresses will
be physically burnt into the memory of devices to guaran-
tee that they can not be modiﬁed. In some cases it may even
be desirable to burn an entire 128-bit IPv6 identiﬁer into de-