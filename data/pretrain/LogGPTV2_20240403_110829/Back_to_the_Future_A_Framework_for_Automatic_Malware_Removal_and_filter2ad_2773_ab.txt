(cid:150) If the location contains trusted data, log this write
operation, save the old data, and mark the new
data in this location as untrusted.
(cid:150) If the location contains untrusted data, do noth-
ing.
(cid:150) If the location contains no data, log this write op-
eration, and mark the new data in this location as
untrusted.
During recovery, the framework examines each logged
write operation reverse-chronologically. Recall that the
framework only logs write operations by untrusted pro-
cesses. For each logged write operation, the recovery agents
restores the old data from the log only if the location cur-
rently contains untrusted data.
Proof of Correctness We prove that this re(cid:2)ned approach
achieves the same result as the basic approach. Given a data
location, let the entire sequence of write operations at this
location before system recovery be O1 ; : : : ; On. We consider
two cases, depending on whether the last operation On is
from a trusted or an untrusted process:
† Case 1: The last write operation On is from a trusted
process. Using the basic approach, the framework will
(cid:2)rst undo On ; : : : ; O1, and then redo only the opera-
tions in O1 ; : : : ; On that are from trusted processes, in
that order. Since On is from a trusted process and is
the last operation performed during recovery, this lo-
cation will contain the data written by On after recov-
ery. Using the re(cid:2)ned approach, the framework will
notice that the location already contains trusted data,
so it will do nothing on this location. Since before re-
covery this location already contains data written by
On, after recovery using the re(cid:2)ned approach, this lo-
cation will contain the same data as when using the
basic approach.
Proceedings of the 22nd Annual Computer Security Applications Conference (ACSAC'06)0-7695-2716-7/06 $20.00  © 2006† Case 2: The last write operation On is from an un-
trusted process. Let Ot be the last write operation by
a trusted process in this sequence. Now the sequence
is O1 ; : : : ; Ot ; Ot+1 ; : : : ; On where all Ot+1 ; : : : ; On are
from untrusted processes. Using the basic approach,
the framework will (cid:2)rst undo On ; : : : ; O1, and then
redo only the operations in O1 ; : : : ; Ot that are from
trusted processes. Since Ot is from a trusted process,
it will be the last operation that the framework re-
does on this location, so this location will contain the
data written by Ot after recovery. Using the re(cid:2)ned
approach, during monitoring the framework will log
Ot+1, but will not log any operation after Ot+1, because
Ot+1 writes untrusted data into this location. During
recovery, the framework will (cid:2)rst undo Ot+1 by replac-
ing the data in this location with the data that was in
this location before Ot+1, which was exactly the data
written by Ot. After that, this location contains trusted
data because Ot is from a trusted process, so the frame-
work will not change the data in this location any more.
Therefore, both the basic and the re(cid:2)ned approach re-
store the same data into this location.
3. Implementation
To evaluate our framework, we have developed a proto-
type implementation for the Windows XP operating system.
The implementation consists of the three essential compo-
nents of the framework: a monitor, logger, and recovery
agent. Our monitor is a Windows kernel driver that hooks
relevant system services and can therefore capture most of
the interactions between user processes and the operating
system. The logger and recovery agent are user applications
that interact with the driver.
3.1. Monitoring
3.1.1. System Service Hooking
In Windows NT 4, 2000, and XP, user applications rely
on the interface exposed from a set of libraries, such as
kernel32.dll and user32.dll, to access operating system ser-
vices. This interface is known as the Win32 API. Applica-
tions may also call function in ntdll.dll known as the Native
API [14]. The Native API functions perform system calls in
order to have the kernel provide the requested service.
When the kernel traps system service interrupts, it uses
a unique identi(cid:2)er found in the call to look up a function
pointer in the service dispatch table. Kernel drivers can
modify this table to wrap system services with arbitrary
code. This technique, known as API hooking, allows us
to intercept all the system service calls made by any pro-
cess [13, 21]. Our framework hooks the system services
that access the (cid:2)le system and registry, and those that create
new processes.
3.1.2. Tracking Untrusted Data
A signi(cid:2)cant component of the monitor tracks which
data are untrusted as both trusted and untrusted processes
execute, because our integrity model requires that no trusted
process should read untrusted data. In the implementation
of this component, two key issues are granularity and meta-
data:
to what granularity does this component track un-
trusted data, and how is the trustworthiness recorded?
To determine the best granularity, we need to strike a
balance between precision and overhead. For the registry,
we chose a granularity of one value, because most registry
values are small. On the other hand, (cid:2)les can become very
large, so using a (cid:2)le-level granularity would be too coarse-
grained. Thus, we track the ranges of untrusted data in each
(cid:2)le.
Our implementation maintains a table of all (cid:2)les and reg-
istry entries that contain untrusted values. For each (cid:2)le, an
associated data structure describes which ranges in this (cid:2)le
contain untrusted data. The monitor uses this table to deter-
mine if a trusted process will read untrusted data. The log-
ger (Section 3.2) and the recovery agent (Section 3.3) will
also use this table. Table 1 summarizes the actions taken by
the monitor for various operations.
In addition to tracking untrusted data, the monitor also
tracks and monitors processes spawned by untrusted pro-
cesses, which are also considered as untrusted.
3.2. Logging
The second component of the implementation is logging.
During recovery, the framework uses logged information to
remove malware programs and to restore infected data on
the system. As discussed in Section 2.3, the framework only
needs to log write operations from untrusted processes. The
monitor makes appropriate backups and forwards informa-
tion to the logger.
3.3 Recovery
The (cid:2)nal portion of the implementation is recovery.
Given the data created by the logging mechanism, the re-
covery tool will roll back the eﬁects of each entry until the
desired system state is reached. The tool also uses trustwor-
thiness information about data from the monitor to deter-
mine what portions of data it should restore.
4. Experiments
We evaluated our tool’s eﬁectiveness in detecting mal-
ware, removing malware, and restoring infected data, and
Proceedings of the 22nd Annual Computer Security Applications Conference (ACSAC'06)0-7695-2716-7/06 $20.00  © 2006Process
Process’s Operation Old Status of Target Data Monitor’s Action
Trusted
Untrusted
Delete (cid:2)le
Write data
Read data
Create process
Delete (cid:2)le
Write data
Read data
Create process
Trusted
Untrusted
Trusted
Untrusted
Trusted
Untrusted
Any
Trusted
Untrusted
Trusted
Untrusted
Trusted
Untrusted
Any
Allow
Remove (cid:2)le from watch list
Allow
Mark new data as trusted
Allow
Warn integrity violation
Allow
Mark (cid:2)le as deleted
Mark (cid:2)le as deleted
Mark new data as untrusted
Allow
Allow
Allow
Monitor new process as untrusted
Table 1. Tracking untrusted data and new processes.
its performance during monitoring and recovery. We tested
our tool on a suite of malware programs consisting of:
† Adware and spyware: eZula, Gator, and BonziBuddy.
They are normally bundled with other benign pro-
grams, such as a P2P application. When the user in-
stalls the benign programs, the installers furtively in-
stall these malware programs.
† Trojan horse: NetBus. Trojan horses are normally
packaged with innocuous decoy programs. When the
decoy programs are executed, they install and run the
bundled Trojan horses. NetBus con(cid:2)gures the system
to allow remote access and control.
† Email worms: Netsky and Beagle. Email worms de-
pend on deceived users to execute email attachments
to install and propagate the worms. Netsky and Beagle
caused two major email worm outbreaks in 2004.
† Hybrid malware: Happy99. Happy99 acts both as a
trojan horse and a worm, since it purports to be an
entertaining screen saver, and it propagates via email
behind the scenes.
4.1. Recovery
During recovery, our tool should remove all the (cid:2)les
and registry entries installed by the malware, and restore
the original data in the infected (cid:2)les and registry entries.
We evaluated the eﬁectiveness of our tools’s recovery func-
tion by comparing it with two popular commercial tools:
Spybot[2] and Symantec Norton AntiVirus[1]. Spybot han-
dles eZula, Gator, and BonziBuddy, and Symantec Norton
Anti-Virus handles the rest of the malware programs used in
our experiments. We compared them in two experiments:
† First experiment: after running a malware program, we
(cid:2)rst invoke the recovery function of our tool, and then
we run a commercial tool to detect any residual traces
of this malware.
† Second experiment: after running a malware program,
we (cid:2)rst run a commercial tool to detect and remove the
program, and then we examine whether the commer-
cial tool has removed all the (cid:2)les and registry entries
created by the malware program as logged by our tool.
In the (cid:2)rst experiment, for each malware program, we
found that neither commercial tool could detect the malware
after we ran our tool to remove it. Since both commercial
tools could detect the malware before we removed it using
our tool, we conclude that our tool has removed the mal-
ware to the satisfaction of the commercial tools. In the sec-
ond experiment, we found that the commercial tools failed
to remove all the (cid:2)les and registry entries that the malware
programs had created. Table 2 compares the number of (cid:2)les
and registry entries modi(cid:2)ed by the malware programs that
were detected by our tool with those that were detected by
the commercial tools. The table shows that, for some mal-
ware, our tool can identify more (cid:2)les and registry entries
modi(cid:2)ed by the malware than commercial tools can. These
include:
† Original (cid:2)les and registry keys that malware has
deleted from the system. E.g., W32.Netsky deleted a
registry key associated with a component of Microsoft
Internet Explorer.
† Temporary (cid:2)les created by malware during its installa-
tion. E.g., eZula created temporary (cid:2)les while it was
retrieving data from the network. These (cid:2)les were not
deleted even after the commercial tool claimed to have
removed eZula.
Proceedings of the 22nd Annual Computer Security Applications Conference (ACSAC'06)0-7695-2716-7/06 $20.00  © 2006† Modi(cid:2)cations made by other system components on
behalf of the malware. E.g., Bonzi Buddy asked Mi-
crosoft Agent Services to modify the (cid:2)le system, but
the commercial tool failed to detect the modi(cid:2)ed (cid:2)les.
measurements were conducted on an Intel Pentium 4 2GHz
desktop with 256 MB RAM and a 7200rpm IDE hard disk
running Windows XP Workstation SP1.
4.2. Usability
Our tool monitors read and write operations of both
trusted and untrusted processes. When a trusted process
reads data that were written by an untrusted process, our
tool will stop the process and alert the user.
If this alert
never happens, our tool will allow an untrusted process to
run to completion (the user can still use our tool to remove
the program and its eﬁects at any later time). However, if
this alert happens often, the usability of our tool will suﬁer,
because each alert requires user intervention.
Examining of
We never saw an alert when we used our
tool
to run the seven malware programs mentioned ear-
lier.
the logs carefully, we found
that NetBus, W32.Beagle.AC, and W32.Netsky should
have triggered alerts.
They all write to the reg-
istry key HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\
Windows\CurrentVersion\Run, which is read by Win-
dows during its boot. This modi(cid:2)ed key allows the malware
to survive a system reboot, because the system will auto-
matically restart all the programs listed in this registry key.
These malware programs violate our integrity model, be-
cause they write untrusted data into this registry key, and the
system will read these untrusted data during the next reboot.
Our framework would detect this violation, if our monitor
driver were loaded early in the boot sequence. However,
due to limitations in Windows, no user visible noti(cid:2)cation
could be given at this point of detection, and so the only al-
lowable option would be to restore the previous registry key
value.
4.3. Performance
Our tool monitors the execution of all the processes on
the system.
It intercepts and optionally logs all the sys-
tem services from untrusted processes, and it also monitors
trusted processes to prevent them from reading untrusted
data. However, most system service calls pass through our
monitor very quickly, and only the calls that modify the sys-
tem state (such as the (cid:2)le system and the registry) may no-
tice delays.
The timings in Table 3 reveal that while the overhead
of our implementation does increase execution time for the
tasks, the eﬁect is reasonable when compared with the re-
source usage of a commercial anti-spyware of anti-virus
program. Moreover, the performance numbers for the in-
stallers and unzip should be interpreted as a stress test of
our system since they mainly consist of (cid:2)le operations. All
5. Discussion
5.1. Security of the Framework
Security Goals Security has three main goals: con(cid:2)den-
tiality, integrity, and availability [3]. Our framework fo-
cuses on maintaining integrity:
it allows the user to run
untrusted programs without compromising system integrity,
and it can remove the untrusted programs and all their ef-
fects on the system completely and automatically. Our
framework does not ensure availability directly, because
it does not control resource usage by untrusted programs;
however, since our framework can remove untrusted pro-
grams and their eﬁects on the system, it provides availabil-
ity indirectly. Our framework does not provide con(cid:2)den-
tiality, since it does not prevent untrusted programs from
reading con(cid:2)dential information, nor does it monitor out-
going network tra–c. As we discussed in Section 1, once
the user starts to run untrusted programs, it is very di–cult
to maintain con(cid:2)dentiality in a usable way. However, we
can enhance our framework to provide con(cid:2)dentiality.
If
the user can indicate what information is con(cid:2)dential on his
system, we can incorporate this information by disallowing
untrusted applications from reading con(cid:2)dential informa-
tion. We leave this for future work.
Security of the Logging Mechanism Our framework
logs write operations by untrusted processes so that it can
reverse these operations in the future. An adversarial pro-
cess may try to DOS attack our logging system by mak-
ing numerous write operations. However, our system does
not log each write operation by untrusted processes; it only
logs those write operations that replace trusted data. More
speci(cid:2)cally, we divide the write operations by untrusted
processes into three categories:
† The operation replaces trusted data. Our system logs
this operation and the old data.
† The operation replaces untrusted data (i.e., data writ-
ten earlier by an untrusted process). Our system logs
nothing.
† The operation writes new data. Our system only logs
that this operation took place.
The log size in the (cid:2)rst case may be large because of poten-
tially large old data, the log size in the third case is small,
and the log size for the second case is zero. Therefore, an
adversarial untrusted process cannot eﬁectively DOS attack
Proceedings of the 22nd Annual Computer Security Applications Conference (ACSAC'06)0-7695-2716-7/06 $20.00  © 2006Malware
eZula
Gator
BonziBuddy
NetBus
Happy99.Worm
W32.Beagle.AC
W32.Netsky
Registry Key
Registry Key