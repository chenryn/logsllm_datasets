Overview
Key Findings
Recommendations
Software engineering leaders focused on software engineering strategies should work with their
security and risk counterparts to:
Licensed for Distribution
How Software Engineering Leaders Can Mitigate
Software Supply Chain Security Risks
Published 15 July 2021 - ID G00752454 - 19 min read
By Manjunath Bhat, Dale Gardner, and 1 more
Attackers are targeting software development systems, open-source artifacts and DevOps
pipelines to compromise software supply chains. Software engineering leaders must guide
their teams to protect the integrity of the software delivery process by adopting practices
described in this research.
The increased threats of malicious code injection makes it critical to protect internal code and
external dependencies (both open-source and commercial).
■
Leaked secrets or other sensitive data and code tampering prior to release are consequences
of a compromised software build and delivery pipeline.
■
Failure to enforce least privilege entitlements and ﬂat network architectures enables attackers
to move laterally against the operating environment, putting the enterprise at greater risk.
■
Protect the integrity of internal and external code by enforcing strong version-control policies,
using artifact repositories for trusted content, and managing vendor risk throughout the
delivery life cycle.
■
Harden the software delivery pipeline by conﬁguring security controls in CI/CD tools, securing
secrets and signing code and container images.
■
Secure the operating environment for software engineers by governing access to resources
using principles of least privilege and a zero-trust security model.
■
Strategic Planning Assumption
By 2025, 45% of organizations worldwide will have experienced attacks on their software supply
chains, a three-fold increase from 2021.
Introduction
Software engineering leaders are at the forefront of digital business innovation. They are
responsible not only for software development and delivery, but are also increasingly accountable
for implementing security practices. These practices have traditionally focused on activities such
as scanning code for potential security vulnerabilities and patching software systems.
However, software supply chain attacks are becoming increasingly sophisticated, with malicious
actors exploiting weaknesses at every stage in the software procurement, development and
delivery life cycle. This includes everything from injecting malicious code into open-source
packages to installing back doors in postdeployment software updates.
As a result, software engineering teams must assume that all code (both externally sourced and
internally developed), development environments and tooling may have been compromised. In
addition, security hygiene should now extend to external code dependencies and commercial off
the-shelf (COTS) software, which includes the use of third-party APIs.
This research explains how software engineering leaders can counter the threat of software
supply chain attacks. See Figure 1 for secure development practices to guard against software
supply chain attacks. Figure 2 highlights the potential security risks at each stage of the delivery
process.
Figure 1: Top Practices to Mitigate Supply Chain Security Risks in
Software Development and Delivery
A software supply chain attack is the act of compromising software or one of its dependencies at
any stage throughout its development, delivery and usage. Although the precise attack vector may
vary in each case, the attacker usually gains unauthorized access to development environments and
infrastructure including version control systems, artifact registries, open-source repositories,
continuous integration pipelines, build servers or application servers. This allows the attacker to
modify source code, scripts and packages, and establish back doors to steal data from the victim’s
environment. Attacks are not limited to external actors; they can come from insider threats as well.
The attacks on SolarWinds (2020), NetBeans IDE (2020), Kaseya (2021) and Codecov (2021)
represent four prominent examples of software supply chain attacks (see the Evidence section and
Notes 1 through 5). Gartner believes that By 2025, 45% of organizations worldwide will have
experienced attacks on their software supply chains, a three-fold increase from 2021.
This research will address the following security concerns Gartner encounters in client inquiries:
Figure 2: Potential Software Supply Chain Security Risks
Analysis
Protect the Integrity of Internal and External Source Code
Software engineering teams use version control systems (VCSs) and artifact repositories to
maintain internally developed code and external artifacts. Failing to enforce security controls in
these tools exposes source code and artifacts to potential manipulation and tampering.
We recommend three practices that protect the integrity of internal and external code:
1. Strong version control policies
2. Trusted component registries
3. Third-party risk management
Strong Version Control Policies
Git-based VCSs including BitBucket, GitHub and GitLab provide native security and access
protection capabilities. Software engineering teams must leverage access policy controls, branch
protection and secrets scanning capabilities. These controls are not enabled by default and must
be explicitly set. See Figure 3.
Compromise of continuous integration/continuous delivery (CI/CD) systems
■
Injection of malware into legitimate software
■
Inclusion of vulnerable and malicious dependencies
■
Figure 3: Strong Version Control Policies
Secrets and credentials should never be stored in source code repositories, but software
engineers can accidentally commit secrets to source control. Since any user who has access to
the repository can clone the repository and store it anywhere, the cloned repository becomes a
treasure trove for attackers looking to steal credentials, API keys or secrets. We recommend
continuous scanning of repositories to check for ﬁles embedded with secrets using either open-
source tools or provider-native capabilities (see Table 1).
Table 1: Representative list of Secrets Scanning tools for Git Repositories
Open-Source Tools
Vendors
git-secrets: Open sourced by AWS Labs
GitHub Secrets Scanning
Repo Supervisor: Open sourced by Auth0
GitLab Secret Detection
truffleHog: Searches for secrets in Git repos
Bitbucket Secrets Scan
Gitleaks: Scans repos and commits for secrets
GitGuardian
Source: Gartner
Trusted Component Registries
As software is increasingly assembled using open-source components, third-party packages and
public APIs, the threat of supply chain attacks due to malicious code looms large (see Note 5 for
examples of package typosquatting attacks in popular open-source libraries). We recommend the
use of artifact (and container) repositories, software composition analysis tools and code
scanning tools.
Artifact Repositories
Artifact repositories enable securing, versioning and safely distributing software packages — both
internally built and externally sourced. The repositories act as a trusted source for sanctioned and
vetted artifacts and software components. This enables centralized governance, visibility,
auditability and traceability into software “ingredients.”
Since the repositories can act as proxies to external public registries, it has the added beneﬁt of
keeping the packages continuously updated and patched. One of the defense agencies uses a
centralized artifact repository (“Iron Bank” 1) that stores signed container images for both OSS
and COTS. See Note 2 for open-source container signing tools.
Examples of artifact repositories:
Examples of container registries:
Deadshot: Open sourced by Twilio
SpectralOps
Azure Artifacts
■
AWS CodeArtifact
■
GitHub
■
GitLab
■
Google Artifact Registry
■
JFrog Artifactory
■
Sonatype Nexus Repository
■
Tidelift Catalogs
■
■ Amazon ECR
Software Composition Analysis (SCA)
SCA complements artifact and container registries by analyzing stored artifacts or container
images to uncover known vulnerabilities. Without SCA, it is difﬁcult to manage dependencies at
scale and to identify known vulnerabilities in published components. Gartner recommends pairing
artifact repositories with integrated SCA and open-source governance capabilities. Examples
include Sonatype Nexus Repository with IQ Server or JFrog Artifactory with Xray (see Market
Guide for Software Composition Analysis).
Code Scanning
Although SCA uncovers known vulnerabilities (often CVE IDs) in published software packages, it
will not help with detecting potentially exploitable ﬂaws that exist in custom application code. We
recommend using application security testing tools for static (SAST), dynamic (DAST) and fuzz
testing of application code. Some AST tools offer SCA capabilities (see Magic Quadrant for
Application Security Testing).
Third-Party Risk Management
Software engineering teams not only build their own software but also consume software
developed by other organizations (including vendors, partners and service providers). This section
will focus on assessing and managing the two kinds of supply chain risks typically associated
with third-party software:
Gartner recommends the following practices to mitigate these risks:
Azure Container Registry
■
CNCF Harbor
■
Docker Trusted Registry
■
GitHub
■
GitLab
■
Google Container Registry
■
JFrog Artifactory
■
Red Hat Quay
■
Risks due to known vulnerabilities in third-party or open-source dependencies (for example,
Equifax, SaltStack). 3,4
■
Risks due to back doors/malware implanted in externally procured software (for example,
SolarWinds attacks). 5
■
Check for adherence to standards and certifications: Require software suppliers to be certiﬁed
against relevant security standards such as UL 2900 for IoT certiﬁcation and ISO/IEC 27034 to
ensure adherence to consistent and formalized application security practices. This may include
requiring a speciﬁed level of developer testing and evaluation. For example, static and dynamic
code analysis, threat modeling and vulnerability analysis, third-party veriﬁcation of processes,
manual code review and penetration testing.
See Note 6 for frameworks and standards that help evaluate your provider/partner’s supply chain
security posture.
Audit the provider’s software build, deployment and upgrade process: Ask these questions to
benchmark software providers against a minimal baseline:
In software, the chain isn’t as strong as its weakest link; it’s as weak as all
the weak links multiplied together.
— Steve McConnell
Harden the Software Development and Delivery Pipeline
Gartner recommends three practices to strengthen the security of the software delivery pipelines:
Implement Secrets Management
Does the provider have the necessary controls to secure their SDLC process? (see 12 Things to
Get Right for Successful DevSecOps.)
■
What process does the provider follow to patch its own software and its dependencies?
Request a software bill of materials that helps track nested dependencies. See Note 3 for
tracking open-source dependency chains and assessing security posture of open source
projects (upstream).
■
Is the mechanism to deliver the patch protected from external attacks?
■
What is the SLA for patching a vulnerability discovered in the vendor’s software or its
dependencies?
■
■
Implement secrets management
■
Implement signing and hashing to verify integrity of source code
■
■ Conﬁgure security controls in CI/CD pipelines
Hard-coding secrets in code and conﬁguration ﬁles signiﬁcantly increases the risk of
compromising build pipelines and development environments. In addition, storing any type of
secret in a container image can expose that data inadvertently, particularly if images are stored in
public registries. Software engineering teams must continuously check committed code and
artifacts for embedded secrets.
Secrets management provides a disciplined approach to managing and securing secrets such as
credentials, passwords, API tokens and certiﬁcates. We recommend the use of secrets
management tools to automate creation, storage, retrieval and revocation of secrets. This helps
avoid embedding (hard-coding) secrets in source code, conﬁguration ﬁles and infrastructure
automation scripts. See Table 2 for representative providers of secrets management tools for
multiple development scenarios.
Table 2: Secrets Management Tools
Platform-agnostic tools
Cloud-provider tools
Container-native environments
Configuration Management
Use Case
Secrets Management Tool
Akeyless
■
CyberArk Conjur
■
Thycotic Secrets Vault
■
HashiCorp Vault
■
AWS Secrets Manager
■
Azure Key Vault
■
GCP Secret Manager
■
Kubernetes Secrets (etcd),
■
Sealed Secrets
■
 Ansible Vault
■
 Chef Data Bag
■
 Puppet Hiera
■
Source: Gartner
Secrets such as credential files, private keys, passwords and API tokens
should not be committed to a source control repository. Use a secrets
management tool to securely store and encrypt secrets, enforce access
controls and manage secrets (that is, create, rotate and revoke).
Implement Signing and Hashing to Verify Integrity of Source Code
Hashing and signing can be used to verify integrity of source code and binaries. VCSs generate
hashes (unique identiﬁers) for individual ﬁles during commits. These hashes help validate that the
ﬁles are not altered in transit. Likewise, compilers generate hashes as well. Compiler-generated
hashes (during CI/CD) can be compared with ﬁle hashes generated by static ﬁle analyzers (during
scanning). This ensures that the code being shipped is the same as the code that was scanned.
See Note 7 for hashing and code signing tools.
Commit Signing
Hashing does not address the needs of provenance and authenticity, which is why we recommend
signing. VCSs support signed commits to provide others the assurance that the ﬁles originated
from a trusted source. As examples, GitHub and GitLab attach a “veriﬁed” label against signed
commits when the signature can be veriﬁed for valid users. Think of this like Twitter veriﬁed
accounts — where Twitter conﬁrms the account holder’s identity.
Container Signing
As organizations move to container-based deployments and source containers from different
locations, ensuring the integrity of container images becomes paramount. Gartner recommends
signing container images even if your organization builds and maintains internal images. This is
because any issue in third-party code or dependencies impacts the security posture of your
running applications(see Figure 4). See Note 2 for open-source container signing tools.
Figure 4: Propagation of Container Image Vulnerabilities in
Kubernetes
Configure Security Controls in CI/CD Pipelines
CI/CD systems, if left unsecured, introduce security risks in the software delivery pipeline. For
example, attackers can manipulate build pipeline deﬁnitions to suppress checks, allowing
malicious code to pass through or redirect releases to a malicious delivery target. CI/CD pipelines
must be conﬁgured with the elevated security and access controls, as they may be turned off by
default.
Attackers are increasingly targeting build pipelines as an attack vector. Therefore, software