the Information Flow
Tracking assertion A36-01 for the AES04 design is translated
to the AES-T400 design. In the AES-T400 design, the injected
trojan utilizes an unused pin to generate an RF signal that
can be used to transmit the key bits. The leaked data can
be received by an AM radio, and can be interpreted with a
speciﬁc beep scheme. The trojan is implemented in two addi-
tional modules: AM_Transmission and Trojan_Trigger. When
a predeﬁned plaintext is observed, the trojan will be triggered
and the AM_Transmission module will output the key to the
Antena signal following the beep scheme to leak data.
Ideally, the key will ﬂow only to the output ciphertext
(A36-01). The result of our translation for A36-01 to the
AES-T400 design is: set key[0] := high; assert cipher[0]
== high. This indicates that Transys can successfully translate
the assertion to a new design and is not inﬂuenced by the two
additional modules of the trojan.
E. Performance
We evaluate the total time it takes for Transys to translate
each assertion from a source design to a target design. Fig-
A27-01toA27-10A28-01toA28-04A29-01toA29-02A36-01toA36-04AssertionId.(groupedasranges)020406080100Ratio(%)TypeEquiv.SemanticEquiv.A27-01toA27-10A28-01toA28-04A29-01toA29-02A36-01toA36-04AssertionId.(groupedasranges)020406080100Ratio(%)TypeEquiv.SemanticEquiv.A32-01A33-06A36-05A36-06A37-01A37-02AssertionId.020406080100Ratio(%)TypeEquiv.SemanticEquiv.A01A03A04A08A09A15A17A19A23A26AssertionId.020406080100Ratio(%)TypeEquiv.SemanticEquiv.Assertion
Total Transl.
Valid Ratio
VM Pass
360
14%
ST Pass
352
52%
CR Pass
336
93%
Table XIV: Accumulative valid ratio of each pass for AES designs.
Assertion
Total Transl.
Valid Ratio
VM Pass
46
39%
ST Pass
43
59%
CR Pass
39
85%
Table XV: Accumulative valid ratio of each pass for CPU designs.
Orig Assert No.
A33-01, A33-02
A33-03, A33-04
A33-05
Trans. assert can detect trojans in
AES-T1600, AES-T1700, AES-T400
AES-T100, AES-T1000, AES-T1100, AES-T1200
AES-T200, AES-T700, AES-T800, AES-T900
Table XVI: Results of security impact of translated assertions to detect trojans
in AES cores.
and the translated assertions of A33-03—A33-05 would detect
trojans in eight AES designs. For the remaining nine trojan-
injected designs, we do not have assertions that can detect the
trojans and therefore we cannot determine whether translated
assertions would detect them.
H. Bugs in the Code
We discuss three examples to show the translation results
of Transys when there is a bug in the design. For different
types of bugs, the translation results of Transys can be: failing
to translate, outputting trivially true assertions, or propagating
the bug to the resulting assertions.
1) Translation Failed: The ﬁrst example shows the case
of translation failure. In the AES05 design we mentioned in
Section VII-B, part of the code base is missing. When we use
Transys to translate the assertions to the AES05 design, we get
the error message in the Reﬁnement Pass showing that some
modules or cells are not part of the design. Thus, one possible
reason for translation failure is missing parts of the code. This
corresponds to the case of no reﬁnement output at all.
2) Trivial Assertions: The second example shows the case
that a certain constraint should be explicitly stated in the
design, but it is not. We show the GPR0 bug in the OpenRISC
cores. In the OR1K speciﬁcation, the general purpose register
R0 should always be set to zero [27]. A violation of this
property can lead to malicious modiﬁcation of the memory
data or memory address in calculation. This bug exists in both
the Espresso and the Cappuccino designs [6].
to
simpliﬁed
We translate the assertion that enforces R0 to always
be 0 (A04 in Table VIII) from the OR1200 to both the
Espresso and the Cappuccino designs. The results are shown
in Table XIII. The result assertion for the Espresso design can
(mor1kx_rf_espresso.rfa_adr_i(cid:54)=0)→
be
(mor1kx_rf_espresso.rfa_adr_i(cid:54)=0).
result
assertion
the
be
Cappuccino
(mor1kx_rf_cappuccino.rf_wraddr(cid:54)=0)→
simpliﬁed
(mor1kx_rf_cappuccino.rf_wraddr(cid:54)=0).
the
assertions are trivially true (A → A) and there are no other
valid and meaningful assertions. Thus, a bug in the design
due to missing constraints is reﬂected in translation results
that only have trivially true assertions.
In both cases,
The
design
for
to
can
Fig. 14: Translation time for the AES, RSA and CPU designs.
ure 14 shows the results. The translation times for the trojan-
injected AES designs are similar to the time for the trojan-free
AES design, and are not shown due to space constraints.
We observe that the translation time varies across different
designs, depending on their complexity. The average times
for translating one assertion for AES designs, RSA designs
and CPU designs are 28.8 seconds, 0.46 seconds, and 189
seconds, respectively. For AES and RSA designs, most of
the translation time is spent on the Reﬁnement Pass. For
processor designs, most of the translation time is spent on
the Variable Mapping Pass. The maximum average property-
translation time is 436.8 seconds for the OR1200 design. The
results suggest that Transys is practical enough to be used
by hardware designers on a daily basis to quickly generate
security assertions through translating existing ones.
F. Effectiveness of Each Pass
We evaluate the effectiveness of each pass on translating
assertions across the AES designs and the processor designs.
Tables XIV and XV show the ratio of valid results at the end
of each pass. We observe that each pass increases the valid-to-
invalid ratio substantially, indicating that each pass is effective.
G. Security Impact
In this section, we discuss the security impact of the
translated information ﬂow tracking assertions when there is
a vulnerability in the code. Assertions A33-01—A33-05 in
Table IX can detect trojans in AES-T400 and AES-T1100 [20].
We translate these ﬁve assertions to the AES cores with
trojans.
We do not have access to the information ﬂow tracking
tool [20] needed to add the tracking logic necessary to verify
whether the translated assertions can detect trojans. Therefore,
we instead compare the translated assertions with the original
assertions, and compare the trojans between designs. If the
assertions are logically equivalent, and the information leakage
circuits are the same other than the triggering mechanism, then
we infer that the translated assertions would detect the injected
trojans as well.
Table XVI shows the results. The translated assertions of
A33-01 and A33-02 would detect trojans in three AES designs,
010203040506070809101112131415161718AESDesignNo.020406080Avg.Time(s)Mean010203RSADesignNo.0.00.20.40.6Avg.Time(s)MeanOR1200EspressoCappucinoOpenVPicoRV320100200300400Avg.Time(s)Mean3) Overly Restrictive Assertions: The third example shows
the case that some malicious or buggy code are explic-
itly added in the design. For the AES assertion A29-02
from the AES11 design, Transys successfully translate it to
the AES18 design: aes_sbox.a != aes_sbox.d. This assertion
states the security property that
the S-box should avoid
any ﬁxed points. We then maliciously modify the S-box
design in AES18 such that when the input to the S-box is
8’hff, it should output 8’h16 but instead outputs 8’hff. We
then run Transys to translate this assertion again and we
get the new assertion: (aes_sbox.a[7] (cid:54)= aes_sbox.d[7]) →
(aes_sbox.a (cid:54)= aes_sbox.d). This new assertion is valid for
the buggy design. With the additional antecedent, hardware
experts can easily identify the bug and the condition to trigger
it.Thus, a malicious bug in the design can manifest itself in
the translated assertions (typically as additional antecedents).
VIII. RELATED WORK
Property driven hardware security. There has lately been
a call for “property driven hardware security” [28], [29],
[30] that advocates building security speciﬁcations into the
hardware design workﬂow, automating the process of doing
so, and developing quantiﬁable measures of security. We see
Transys as a contribution in response to this call.
Developing security speciﬁcations. A body of work on the
use of execution monitors in processor designs has pro-
duced a set of security properties for various open source
designs [31], [10], [32], [5]. These properties were developed
manually. Subsequent work showed how to partially automate
the process [7], and tackled temporal properties [33], but still
required an initial set of manually written properties for each
design under consideration. With Transys, the work done to
specify properties for one design can be leveraged to bootstrap
property generation for a second design.
Extracting assertions from hardware designs. Considering
properties beyond those critical to security, there is a body of
work on speciﬁcation mining from hardware designs. The Io-
dine tool looks for possible instances of known design patterns,
such as one-hot encoding or mutual exclusion between signals,
and creates assertions that encode the found patterns [34].
More recent papers use data mining of simulation traces
to extract more detailed assertions [35], [36] or temporal
properties [37]. While these techniques are not concerned with
ﬁnding security properties, they provide lessons on how to
scale assertion extraction effectively.
Assertion based veriﬁcation of hardware designs. The
properties developed by Transys can be encoded as assertions
and added to the design under review, at which point standard
assertion based veriﬁcation (ABV) techniques can be used
to ﬁnd property violations [38]. These techniques include
simulation-based testing [39] and formal static analysis [40],
[41], and are implemented in both commercial [42] and
open source tools [43]. Software-style symbolic execution has
also proven to be effective at ﬁnding property violations in
hardware designs [44], [6].
Language based veriﬁcation. A body of work has emerged
on developing new or extending current hardware descrip-
tion languages for hardware veriﬁcation. One language based
approach uses typed hardware description languages, which
can enforce security policies by construction [16], [45], [14],
[15]. A second language based approach uses a formally
deﬁned language to ﬁrst specify a policy and then reﬁne the
speciﬁcation to a provably correct design [46], [47], [48].
Tracking information ﬂow in hardware. Information Flow
Tracking logic can be added at the gate level [17] or register
transfer level [49] of a hardware design, and can capture timing
ﬂows [18], [19] or data ﬂows [50]. While there is a trade-off
to be made between precision and performance [51], [52],
these techniques can demonstrate whether sensitive inputs to
a design, e.g., the key material input to a cryptographic core,
is directly or indirectly visible in the output signals. As with
language based veriﬁcation, this approach can provide strong
guarantees, but also requires modifying the original design,
either by adding tracking logic or, as in the case of CPUs,
redesigning from the ground up to provide provable isolation
between software contexts [53], [54].
Software code clone detection. Our Variable Mapping Pass
is inspired by research in software code clone detection. The
techniques used are token-based [55], [56], [57], semantic-
based [58], [59], [60], [61], graph-based [62], [63], [64],
and tracelet-based [65] approaches. Genius [63] uses features
extracted from control ﬂow graphs and converted to high-level
numeric feature vectors to conduct searches. The approach
is scalable and robust to code variation. Gemini [64] uses
a graph-based deep learning approach and achieves high
accuracy and high speed. Our approach combines graph and
semantic-based features and adapts them to RTL code.
IX. CONCLUSION
In this work, we advocate building security properties for
new designs by leveraging existing properties. We present
Transys, an automated tool that translates given security asser-
tions from one hardware design to another in three passes—
transformation and constraint
variable mapping, structural
reﬁnement. Transys is able to translate 27 temporal
logic
assertions and 11 information ﬂow tracking assertions across
38 AES designs, 3 RSA designs, and 5 RISC processor
designs. The overall translation success rate is 96%. Among
them, the translations of 23 (64%) assertions achieve semantic
equivalence rates of above 60%. The average translation time
per assertion is about 70 seconds.
ACKNOWLEDGMENTS
We would like to thank our shepherd, Dr. Yan Shoshi-
taishvili, and the anonymous reviewers for their helpful and
insightful feedback. This material is based upon work sup-
ported by the National Science Foundation under Grant No.
CNS-1816637. Any opinions, ﬁndings, conclusions, and rec-
ommendations expressed in this paper are solely those of the
authors.
REFERENCES
[1] P. Kocher, J. Horn, A. Fogh,
, D. Genkin, D. Gruss, W. Haas,
M. Hamburg, M. Lipp, S. Mangard, T. Prescher, M. Schwarz, and
Y. Yarom, “Spectre attacks: Exploiting speculative execution,” in 40th
IEEE Symposium on Security and Privacy (S&P’19), 2019.
[2] M. Lipp, M. Schwarz, D. Gruss, T. Prescher, W. Haas, A. Fogh,
J. Horn, S. Mangard, P. Kocher, D. Genkin, Y. Yarom, and M. Hamburg,
“Meltdown: Reading kernel memory from user space,” in 27th USENIX
Security Symposium (USENIX Security 18), 2018.
[3] J. Van Bulck, M. Minkin, O. Weisse, D. Genkin, B. Kasikci, F. Piessens,
M. Silberstein, T. F. Wenisch, Y. Yarom, and R. Strackx, “Foreshadow:
Extracting the keys to the Intel SGX kingdom with transient out-of-order
execution,” in Proceedings of the 27th USENIX Security Symposium.
USENIX Association, August 2018.
[4] E. M. Koruyeh, K. N. Khasawneh, C. Song, and N. Abu-Ghazaleh,
“Spectre Returns! Speculation Attacks using the Return Stack Buffer,”
in 12th USENIX Workshop on Offensive Technologies (WOOT 18).
Baltimore, MD: USENIX Association, 2018.
[Online]. Available:
https://www.usenix.org/conference/woot18/presentation/koruyeh
[5] M. Hicks, C. Sturton, S. T. King, and J. M. Smith, “SPECS:
A Lightweight Runtime Mechanism for Protecting Software from
Security-Critical Processor Bugs,” in Proceedings of
the Twentieth
International Conference on Architectural Support for Programming
Languages and Operating Systems, ser. ASPLOS ’15. New York,
NY, USA: ACM, 2015, pp. 517–529.