1.1.1.3.2 Base 64
|  p.40
WAPTXv2: Section 1, Module 1 - Caendra Inc. © 2020
https://developer.mozilla.org/en-US/docs/Web/API/Window.btoa
Base 64 Encoding Scheme: JavaScript
Many browsers can handle Base64 natively through 
functions btoa and atob:
window.btoa('encode this string'); //Encode
window.atob('ZW5jb2RlIHRoaXMgc3RyaW5n'); //Decode
1.1.1.3.2 Base 64
|  p.41
WAPTXv2: Section 1, Module 1 - Caendra Inc. © 2020
https://developer.mozilla.org/en-US/docs/Web/API/Window.btoa
Base 64 Encoding Scheme
It is important to notice that if we want to handle Unicode
strings, then we should encode them before using Base64
functions. For example, in JavaScript this is possible as 
follows:
1.1.1.3.2 Base 64
|  p.42
The escapes and encodings are 
required to avoid exceptions with 
characters out of range. Learn 
more here.
WAPTXv2: Section 1, Module 1 - Caendra Inc. © 2020
Unicode (aka ISO/IEC 10646 Universal Character Set) is 
the character encoding standard created to enable people 
around the world to use computers in any language. It supports 
all the world's writing systems.
Because Unicode contains such a large number of characters, 
glyphs, numbers, etc., from a security point of view, it is 
fascinating because incorrect usage can expose web 
applications to possible security attacks. One such example, is 
that it can be useful to bypass filters.
1.1.1.4 Unicode Encoding
|  p.43
WAPTXv2: Section 1, Module 1 - Caendra Inc. © 2020
We are not going to cover the Unicode specifics, 
but if you want to have a better background on the 
argument, character sets and related topics, the following 
link is a great starting point:
http://www.joelonsoftware.com/articles/Unicode.html
1.1.1.4 Unicode Encoding
|  p.44
WAPTXv2: Section 1, Module 1 - Caendra Inc. © 2020
There are three ways to map Unicode character points:
•
UTF-8
•
UTF-16 
•
UTF-32 
UTF means Unicode Transformation Format and the trailing 
number indicates the number of bits to represent code 
points.
1.1.1.4 Unicode Encoding
|  p.45
WAPTXv2: Section 1, Module 1 - Caendra Inc. © 2020
Thus, each UTF has a different representation and it is 
important to understand how to handle these in our tests. The 
following table shows a sample message encoded in the three 
different UTF formats.
1.1.1.4 Unicode Encoding
|  p.46
WAPTXv2: Section 1, Module 1 - Caendra Inc. © 2020
It is also useful to know how Unicode characters are 
handled through different implementations like URLs, 
HTML, JavaScript, etc. We can see some of them below.
1.1.1.4 Unicode Encoding
|  p.47
WAPTXv2: Section 1, Module 1 - Caendra Inc. © 2020
Besides the representation of Unicode characters in 
multiple encoding types, another interesting aspect is the 
interpretation that humans and different implementations 
give to some characters. 
1.1.1.4 Unicode Encoding
|  p.48
WAPTXv2: Section 1, Module 1 - Caendra Inc. © 2020
http://en.wikipedia.org/wiki/Homoglyph
Homoglyph | Visual Spoofing
"In typography, a Homoglyph is one or two or more 
characters, or glyphs, with shapes that either appear 
identical or cannot be differentiated by quick visual 
inspection." [Wikipedia]
An additional classification is:
HOMOGRAPH > a word that looks the same as another word
HOMOGLIPH > a look-alike character used to create homographs
1.1.1.4 Unicode Encoding
|  p.49
WAPTXv2: Section 1, Module 1 - Caendra Inc. © 2020
Homoglyph | Visual Spoofing
One of the possible attacks with Unicode is called:
1.1.1.4 Unicode Encoding
|  p.50
Visual Spoοfing
U+006F
LATIN SMALL 
LETTER O
U+03BF
GREEK SMALL 
LETTER OMICRON
WAPTXv2: Section 1, Module 1 - Caendra Inc. © 2020
http://www.unicode.org/reports/tr39/
http://unicode.org/cldr/utility/confusables.jsp
Homoglyph | Visual Spoofing
If we analyze the characters code points of the string, the 
differences between the o and the ο are evident, but for a 
human this is not so obvious. 
These kind of characters, also known as a confusable, 
received special attention from the Unicode Consortium 
(TR39). So much so, that they have provided a utility, 
whereby given an input string you can see the combinations 
that are confusable with it.
1.1.1.4 Unicode Encoding
|  p.51
WAPTXv2: Section 1, Module 1 - Caendra Inc. © 2020
Homoglyph | Visual Spoofing - Example: google.com
1.1.1.4 Unicode Encoding
|  p.52
U+006F
LATIN SMALL 
LETTER O
U+03BF
GREEK SMALL 
LETTER OMICRON
U+043E
CYRILLIC SMALL
LETTER O
U+043E
CYRILLIC SMALL
LETTER O
U+03F2
GREEK LUNATE
SIGMA SYMBOL
gοоglе.ϲom
U+0435
CYRILLIC SMALL
LETTER IE
google.com
VS
U+0065
LATIN SMALL 
LETTER E
U+0063
LATIN SMALL
LETTER C
WAPTXv2: Section 1, Module 1 - Caendra Inc. © 2020
Homoglyph | Visual Spoofing
To speed the homographs generation, rather than 
searching for look-alike characters in Unicode, there is an 
interesting application made by Adrian “Irongeek” 
Crenshaw:
Homoglyph Attack Generator
http://www.irongeek.com/homoglyph-attack-generator.php
1.1.1.4 Unicode Encoding
|  p.53
WAPTXv2: Section 1, Module 1 - Caendra Inc. © 2020
Homoglyph | Visual Spoofing
This attack generator tool is part of a really interesting 
paper where the author explains the abuse of Unicode 
characters in order to obfuscate phishing attacks through 
the use of Homoglyph and Punycode. 
Punycode and Homoglyph Attacks to Obfuscate URLs for Phishing
http://www.irongeek.com/i.php?page=security/out-of-character-use-of-punycode-and-homoglyph-
attacks-to-obfuscate-urls-for-phishing
1.1.1.4 Unicode Encoding
|  p.54
WAPTXv2: Section 1, Module 1 - Caendra Inc. © 2020
Computer Interpretations
Another interesting aspect is related to string and character 
"evolutions,” which occur during normal software 
processes transformations. 
An example of this is upper and lower casing 
transformations, which are described in the upcoming 
slides.
1.1.1.4 Unicode Encoding
|  p.55
WAPTXv2: Section 1, Module 1 - Caendra Inc. © 2020
Computer Interpretations - Example: Censured Feedback
In a feedback page, the application layer performs a 
censorship check before storing data in a DB. 
There is an input filter that blocks the term EVIL, then 
transform the string to lowercase and store it in DB. 
1.1.1.4 Unicode Encoding
|  p.56
WAPTXv2: Section 1, Module 1 - Caendra Inc. © 2020
Computer Interpretations - Example: Censured Feedback
The input flow could be as follow:
➲ A user sends the following message: 
Evİl intent, as usual!
➲ The filter checks for evil strings, but without success.
Evİl != evil
1.1.1.4 Unicode Encoding
|  p.57
U+0130 (İ)
LATIN CAPITAL LETTER I 
WITH DOT ABOVE
WAPTXv2: Section 1, Module 1 - Caendra Inc. © 2020
Computer Interpretations - Example: Censured Feedback
➲ The casing operation is performed [to lowercase]:
evil intent, as usual!
➲ CENSURED BYPASSED
1.1.1.4 Unicode Encoding
|  p.58
U+0130(İ) to lowercase is
U+0069
LATIN SMALL LETTER I
WAPTXv2: Section 1, Module 1 - Caendra Inc. © 2020
Computer Interpretations - Example: Censured Feedback
This happened because a casing operation is performed in 
the application flow AFTER a security check. 
Of course, it also works by upper casing characters like 
this:
ſ to upper case is S
1.1.1.4 Unicode Encoding
|  p.59
U+017F
LATIN SMALL LETTER LONG S
U+0053
LATIN CAPITAL LETTER S
WAPTXv2: Section 1, Module 1 - Caendra Inc. © 2020
Computer Interpretations- Example: Censured Feedback
It turns out, that this type of vulnerable implementation may 
allow an attacker to bypass filters. For example, they can 
bypass anti cross-site scripting and SQL injection filters and 
so forth.
These are things that never happen in real world! 
Check them out here:
Creative usernames and Spotify account hijacking
http://labs.spotify.com/2013/06/18/creative-usernames/
1.1.1.4 Unicode Encoding
|  p.60
WAPTXv2: Section 1, Module 1 - Caendra Inc. © 2020
Computer Interpretations
There are other ways in which characters and strings can 
be transformed by software processes, such as 
normalization, canonicalization, best fit mapping, etc.
These are brilliantly summarized and explained by Chris 
Weber in his:
Unicode Security Guide
http://websec.github.io/unicode-security-guide/
1.1.1.4 Unicode Encoding
|  p.61
WAPTXv2: Section 1, Module 1 - Caendra Inc. © 2020
Computer Interpretations: Mixed Examples
Normalization:
ⓓⓡⓞⓟ ⓣⓐⓑⓛⓔ becomes drop table
Canonicalization:
becomes  URL
A simple scenario could be a URL sent over URL, like the 
common URL redirects we see daily for surfing web sites:
http://mywebsite/login.php?redirectURL=FORW-URL?is_ok=yes
In this case, the forwarding URL will be URL-encoded 
in order to respect the URL rules:
http://mywebsite/login.php?redirectURL=FORW-URL%3Fis_ok%3Dyes
1.1.2 Multiple (De|En) Codings
|  p.65
WAPTXv2: Section 1, Module 1 - Caendra Inc. © 2020
Example: URL-Encoding > URL
Of course, even if a parameter sent is not a URL, encoding 
is still required:
http://mywebsite/login.php?param=I♥🍻
In this case, the parameter contains Unicode characters, 
hence the URL-encoding will be:
http://mywebsite/login.php?param=I%E2%99%A5%F0%9F%8D%BB
1.1.2 Multiple (De|En) Codings
|  p.66
WAPTXv2: Section 1, Module 1 - Caendra Inc. © 2020
Example: URL-Encoding > URL
Multiple encodings may also occur if the parameter sent is 
previously encoded, like the following:
http://mywebsite/login.php?param=Rk9SVy1VUkw/Y2F0PWNsb3ducw==
In this case, we have a Base64 data encoded to send over 
URL; thus, the result will be:
http://mywebsite/login.php?param=Rk9SVy1VUkw%2FY2F0PWNsb3ducw%3D%3D
1.1.2 Multiple (De|En) Codings
|  p.67
WAPTXv2: Section 1, Module 1 - Caendra Inc. © 2020
Example: URL-Encoding > URL
Sometimes, a simple parameter can be a structured 
parameter. For example, the following cookie value:
SESSION = dXNlcm5hbWU6Y2xvd247cGFzc3dvcmQ6dGhlQ2xvd24h
…may appear like a 'random' value used to identify the user 
session, but it decodes to:
SESSION = username:clown;password:theClown!
1.1.2 Multiple (De|En) Codings
|  p.68
WAPTXv2: Section 1, Module 1 - Caendra Inc. © 2020
It turns out that we can construct several examples based 
on multiple encoding/decoding scenarios, but the topic 
here is to understand that identifying different data 
encoding types is an important skill that may help you to 
detect and exploit multiple scenarios.
All in all, in order to respect the application requirements 
and properly test a web application, we must detect and 
consider multiple encoding and decoding operations.
1.1.2 Multiple (De|En) Codings
|  p.69
WAPTXv2: Section 1, Module 1 - Caendra Inc. © 2020
You’ve been studying quite 
intently. We recommend taking 
a quick break and come back 
refreshed. ^_^ 
|  p.70
WAPTXv2: Section 1, Module 1 - Caendra Inc. © 2020
1.2
Filtering Basics
|  p.71
WAPTXv2: Section 1, Module 1 - Caendra Inc. © 2020
A common, yet often recommended, best practice to 
protect web applications against malicious attacks is the 
use of specific input filtering and output encoding controls.
These kinds of controls may range from naive blacklists to 
experienced and highly restrictive whitelists. What about in 
the real world? We are somewhere in the middle!
1.2 Filtering Basics
|  p.72
WAPTXv2: Section 1, Module 1 - Caendra Inc. © 2020
https://www.owasp.org/index.php/Category:OWASP_Enterprise_Security_API
Controls can be implemented at different layers in a web 
application. They can a be represented as either libraries 
and APIs (by naive developers) or, in the best case, by 
internal specialists or external organizations, like ESAPI by 
OWASP.  
Security controls are also inside most common browsers.
1.2 Filtering Basics
|  p.73
WAPTXv2: Section 1, Module 1 - Caendra Inc. © 2020
Sometimes, because of a multitude of complications and 
standards, it is not possible, or it is too problematic to 
implement internal solutions. These solutions may be in the 
form of libraries or APIs; however, the key is in the adoption 
of external solutions. 