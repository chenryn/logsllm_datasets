> 弘扬中华文化，文体两开花
题目拿到手，一个dll和一个binary。
binary直接用ida打开只是binary，暂时看不出什么。
一开始连这题是干嘛的都不知道，对着dll看了好久也没看出啥来。
不过如果细心点，还是能找到线索的。
先搜字符串，看到一堆666，跟着引用走，最后看到一个叫LPH的结构体。
Google一下LPH结构体，发现它出现在了IDA
Pro权威指南的目录里，刚好手头有一本IDA权威指南，打开一看，这竟然是个IDA的处理器模块，它负责ida内部的反汇编工作。
先将dll放到ida根目录下的procs文件夹中，再用ida打开binary。在Processor
type中多了一个叫0CTF2019的选项。打开后这些binary就能被反汇编了。
按C分析，可以看到所有的指令和寄存器都用6和下划线表示了。这时候应该能大致猜到，我们要做的就是逆处理器模块，找到对应的指令还原出来，然后逆binary。本质上还是一道vm题
### 处理器模块简介
直接逆处理器模块可能有些无从下手，好在手边有IDA Pro权威指南。不过版本有点旧，对应的ida还是5.5版本，我们只需大概了解一下处理器模块的结构就行了。
其次IDA SDK文档也是很重要的，所有结构体和IDA API函数的定义都在里面。
参考资料：权威指南，[IDA SDK文档](https://www.hex-rays.com/products/ida/support/sdkdoc/)
根据权威指南，处理器模块最重要的一个结构体叫processor_t结构体，它包含了所有处理器相关的重要信息，结构体名称为LPH。对比文档我们可以看到LPH的所有成员和数值，比较重要的是指令名，寄存器名，和一个叫notify的函数。
这里我们可以直接用hexeditor把寄存器名改成R0到R39。
notify函数的作用是对事件做出相应，它里面应包含三个最核心的函数：分析器，模拟器，输出器。
分析器：分析指令，填充指令相关的信息，比如指令用到的操作数及操作数种类等。一般叫ana函数
模拟器：基于指令的行为创建代码和数据的交叉引用。在此过程中有模拟执行的部分，我们可以根据此推测出指令的种类。此外模拟器还用于跟踪栈指针的变化，并创建局部变量（这个功能在本题中没用到）一般叫emu函数
输出器：将经过反汇编的指令输出到IDA窗口中。一般叫out函数。
为了方便分析，最好根据文档将op_t和insn_t结构体抄下来导入ida。op_t包括了与每个指令操作数相关的信息，insn_t结构体则包含了每条指令相关的信息。这里以文档上的结构体为主，权威指南上的不全。
notify就在LPH里就能找到。在notify的case
A的函数里有大量的case。参数类型设成insn_t后，可以看到对各种操作数的属性设置，这个函数就是ana了。
notify函数的case B函数里面，对应着看权威指南上的实例emu函数，可以看出一定的相似性，下面还能找到名为add_cref的ida
api，这个大概率就是emu了。
out函数则比较容易找，case 0x13里面出现了"op%d"字符串，之前在binary里出现过“op1”，“op”
### 指令分析
出题人给了[源码](https://github.com/xiaohuajiao/my-ctf/blob/master/2019/0ctf/sixology/IDA/emu.cpp)。
分析指令之前要找对方向。在ana中主要是对操作数的 **类型** 进行修改，这里可以作为一点参考。在emu中有模拟执行的过程，对操作数的 **数值**
进行了修改，这里其实更重要。在emu中到处找找，发现一个函数`sub_1800026E0`很长，有很多case，还有一些关键的数值运算及操作，大概可以猜到这是修改寄存器数值。大多数指令可以从这两个函数中分析出来。
举两个例子 第一条指令：
在ana中，首先用get_bytes获取了四个字节作为一条opcode。insn的itype成员被设置为opcode>>0xC&0x1F，这部分就是每个指令的编号了。指令的编号和在dll中排列的顺序是一致的，可以先在hexeditor将指令名按顺序编号方便之后寻找与修改。
来到binary的第一条指令，在hex中可以看到直接被识别成八个字节一条，EF BA 72 2F 30 43 54 46。ana中读取八个字节的只有case
0xb。而且注意到操作数1的实际大小被设置为了获取到的数值异或了0x46544330，显示出来的却又是0x66546330。对比hex可以看到真实值应该是0x46544330^0x46544330。out中也能看到^0x66546330的字样。
来到emu，之前修改数值的函数的case B里可以看到将操作数1的数值幅给了一个变量。对比其他case大致能猜出这个变量最终去向操作数0。
因此这条指令将一个立即数异或0x46544330，幅值给操作数0。因此这应该是li(当然也可以用mov表示)
再来分析下binary中00000038位置的指令，这里操作数1是op1，不太清楚是什么。opcode是00D3F247
先来到ana，opcode右移12位再与31得到指令编号31，case
31中可以看到根据opcode的对应位置先设置了操作数0的数值类型是dword（查文档看类型编码对应的意义），再根据opcode
switch了三个分支，分别将操作数1设置成了不同的类型，这里设置成的是dword。同时注意到还设置了操作数1对应着一个寄存器R3（D3F247>>22&0x1f），因此这里的Op1应该是寄存器R3。
来到emu，看到这里将操作数1的一个叫地址的成员赋给a4，再对a4调用get_byte/get_word/get_dword。猜测一下应该是从操作数1寻址，找到一个对应类型的数据幅值给操作数0，对应汇编代码里的[R1]这样。
经过分析，可以看出这条指令是load指令（当然也可以用mov表示）
类似的，我们也能得到下方的store指令，与load相反，将操作数0的值保存到操作数1的地址中。
大部分指令都可以用这种方式分析出，比较简单的像add sub nor和cmp。
注意这里有两种cmp，一种是正常的cmp，另一种比较的是字符串的大小（“2”>“1000”），这在之后的逆向中十分重要。
比较不常见的有个exchange指令，交换了两个操作数中的内容。
此外一些不太明白的指令可以在逆binary时联系上下文得到。
逆完的指令直接用hexeditor在dll里修改就行了
### binary逆向
我一开始直接用python抄了一遍代码，然而直接跑就挂了，因为它的算法并没有经过优化，一个循环40多亿，根本顶不住，所以还是老老实实逆算法吧
    ROM:00000000                 li      R5, 0x66546330  ;; 0
    ROM:00000008                 li      R4, 0x66546334  ;; 4
    ROM:00000010                 li      R7, 0x66546372 ;; 'B' ;; 0x42
    ROM:00000018                 li      R8, 0x665468B0  ;; 0xB80
    ROM:00000020                 li      R9, 0x66546F90  ;; 0xCA0
    ROM:00000028                 li      R16, 0x66546BB8 ;; 0x888
    ROM:00000030                 loop    loc_34, R7
    ROM:00000034
    ROM:00000034 loc_34:                                 ;; CODE XREF: ROM:00000054↓j
    ROM:00000034                 add     R3, R8, R5
    ROM:00000038                 load    R0, op1         ;; R3
    ROM:0000003C                 add     R3, R9, R5
    ROM:00000040                 load    R1, op1         ;; R3
    ROM:00000044                 call    sub_1E0
    ROM:00000048                 add     R3, R16, R5
    ROM:0000004C                 store   R0, op1         ;; R3
    ROM:00000050                 add     R5, R5, R4
    ROM:00000054                 endloop loc_34
开头赋值了一些变量，然后进入一个长度位66的循环。从0xB80和0xCA0开始获取两个dword作为参数传入函数
sub_1E0，返回值存入0x888，这里没什么复杂的。
进入sub_1E0函数。
    ROM:000001E0                 in3     0x66546230
    ROM:000001E4                 mov     R10, R0
    ROM:000001E8                 mov     R11, R1
    ROM:000001EC                 li      R25, 0x66544329 ;; 0x2019
    ROM:000001F4                 li      R23, 0x66546330 ;; 0x0
    ROM:000001FC                 li      R24, 0x66546330 ;; 0x0
    ROM:00000204                 li      R19, 0x66546334 ;; 0x4
    ROM:0000020C                 li      R18, 0x66546331 ;; 0x1
    ROM:00000214                 loop    loc_218, R0
    ROM:00000218
    ROM:00000218 loc_218:                                ;; CODE XREF: sub_1E0+54↓j
    ROM:00000218                 add     R6, R23, R1
    ROM:0000021C                 div     R14, R15, R6, R0
    ROM:00000220                 add     R15, R15, R18
    ROM:00000224                 add     R17, R25, R24
    ROM:00000228                 store   R15, op1        ;; R17
    ROM:0000022C                 add     R23, R23, R18
    ROM:00000230                 add     R24, R24, R19
    ROM:00000234                 endloop loc_218
    ROM:00000238                 li      R15, 0x66546331 ;; 1
    ROM:00000240                 li      R23, 0x66546331 ;; 1
    ROM:00000248                 sub     R2, R0, R15
    ROM:0000024C                 loop    loc_250, R2
    ROM:00000250
    ROM:00000250 loc_250:                                ;; CODE XREF: sub_1E0+BC↓j
    ROM:00000250                 li      R24, 0x66546330 ;; 0
    ROM:00000258                 li      R22, 0x66546330 ;; 0
    ROM:00000260                 sub     R3, R0, R23
    ROM:00000264                 loop    loc_268, R3
    ROM:00000268
    ROM:00000268 loc_268:                                ;; CODE XREF: sub_1E0+B4↓j
    ROM:00000268                 add     R26, R25, R22
    ROM:0000026C                 load    R12, op1        ;; R26
    ROM:00000270                 add     R27, R26, R19
    ROM:00000274                 load    R13, op1        ;; R27
    ROM:00000278                 strcmp  op0, R12, R13   ;; R32
    ROM:0000027C                 jmpcmp  R32, loc_28C
    ROM:00000280                 exchange R12, R13
    ROM:00000284                 store   R12, op1        ;; R26
    ROM:00000288                 store   R13, op1        ;; R27
    ROM:0000028C
    ROM:0000028C loc_28C:                                ;; CODE XREF: sub_1E0+9C↑j
    ROM:0000028C                 add     R24, R24, R15
    ROM:00000290                 add     R22, R22, R19
    ROM:00000294                 endloop loc_268
    ROM:00000298                 add     R23, R23, R15
    ROM:0000029C                 endloop loc_250         ;; 0