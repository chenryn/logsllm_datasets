Hacking the Supply Chain 
The Ripple20 Vulnerabilities Haunt Hundreds of Millions of Critical 
Devices 
DEF CON 28 Safe Mode 
1 
Who are we? 
2 
JSOF is a software security consultancy 
• Shlomi Oberman, co-founder, JSOF 
• Moshe Kol, Security researcher, JSOF;  Finder of Ripple20 
• Ariel Schön, Security researcher, JSOF 
Agenda 
3 
• Ripple20 
• CVE-2020-11901 
• Exploiting CVE-2020-11901 
Ripple20 
4 
• Series of 19 zero-day vulnerabilities in Treck TCP/IP* 
• Amplified by the supply chain 
• 100’s of millions of devices 
• Medical, ICS, Home, Enterprise, Transportation, Utilities 
Ripple20 
5 
CVE-2020-11896 
CVE-2020-11897 
CVE-2020-11898 
CVE-2020-11899 
CVE-2020-11900 
CVE-2020-11901 
CVE-2020-11902 
CVE-2020-11903 
CVE-2020-11904 
CVE-2020-11905 
CVE-2020-11906 
CVE-2020-11907 
CVE-2020-11908 
CVE-2020-11909 
CVE-2020-11910 
CVE-2020-11911 
CVE-2020-11912 
CVE-2020-11913 
CVE-2020-11914 
•
4 critical remote code execution vulnerabilities 
Ripple20 
6 
CVE-2020-11896 
CVE-2020-11897 
CVE-2020-11898 
CVE-2020-11899 
CVE-2020-11900 
CVE-2020-11901 
CVE-2020-11902 
CVE-2020-11903 
CVE-2020-11904 
CVE-2020-11905 
CVE-2020-11906 
CVE-2020-11907 
CVE-2020-11908 
CVE-2020-11909 
CVE-2020-11910 
CVE-2020-11911 
CVE-2020-11912 
CVE-2020-11913 
CVE-2020-11914 
•
8 medium-high severity vulnerabilities 
100’s of Millions of Devices Affected 
  And many more... 
7 
• Assumption: Every mid-large US organization has one 
100’s of Millions of Devices Affected 
8 
Medical  
Printers 
Utilities 
Transportation 
Networking  
Datacenter 
Smart 
Buildings 
Industrial 
Supply chain 
9 
Supply chain 
10 
11 
Icon from www.flaticon.com 
Vulnerabilities 
12 
Icon from www.flaticon.com 
Ripple20 
13 
Icon from www.flaticon.com 
Why Treck TCP/IP? 
14 
• Supply chain - mostly unexplored 
• 1 vulnerability == multiple products 
• Large IoT impact 
• Zombie vulnerabilities 
• Good attack surface  
Treck TCP/IP 
15 
• Treck is a small American company 
• Treck TCP/IP is a proprietary TCP/IP stack; Available >20 years 
• Embedded devices and RTOS 
• Very configurable. Each Treck instance is different. 
• Strategically located at the start of a long supply-chain 
Ripple20 Research 
16 
• Reverse engineering of 6 different devices with multiple versions 
• Every device has a different configuration 
• Ongoing research Sep’19 - Jun’20 ( 9 months ) 
• Some strange architectures and firmwares involved 
2 whitepapers released 
About CVE-2020-11901 
• Critical vulnerabilities in Treck’s DNS Resolver component. 
• Once successfully exploited, allows for remote code execution. 
• Can traverse NAT boundaries. 
• 4 vulnerabilities and 1 artifacts. 
• Vary over time and vendor. 
17 
CVE-2020-11901 
AKA “the DNS bugs” 
18 
DNS Primer: The Basics 
• The DNS protocol maps between domain names and IP addresses.  
• Client resolves a name by issuing a query to a DNS server. 
• The DNS server looks up the name and returns a response. 
Name: www.example.com 
Type: A 
Name: www.example.com 
Type: A 
TTL: 86400 
Value: 93.184.216.34 
Client 
DNS Server 
Query 
Response 
19 
DNS Primer: Record Types 
• DNS servers can return multiple answers in the same DNS response. 
• An answer is specified as a resource record: 
 NAME
(var)
TYPE
(2 bytes)
 CLASS
(2 bytes)
TTL
(4 bytes)
RDLENGTH
(2 bytes)
RDATA
(var)
Type 
Description 
A 
IPv4 address for the queried domain. 
CNAME 
Alias (canonical name). 
MX 
Domain name of a mail server for the queried domain. 
• Questions and answers have a type. Common types include: 
20 
Domain Names Encoding 
• Domain names are encoded as a sequence of labels.  
• Each label is preceded by a length byte. 
• Maximum label length is 63. 
 3
 w
 w
 w
 7
 e
 x
 a
 m
 p
 l
 e
 3
 c
 o
 m
0
length 
length 
length 
end 
21 
DNS Message Compression 
• Compression is achieved by replacing a sequence of labels with a 
pointer to prior occurrence of the same sequence. 
• Compression pointer is encoded in two bytes, the first begins with 11. 
 11
offset
0 
2 
16 
22 
0 
1 
2 
3 
4 
5 
6 
7 
8 
9 
a 
b 
+0 
0xabcd 
0x8180 
0x0001 
0x0001 
0x0000 
0x0000 
+0xc 
5 
g 
m 
a 
i 
l 
3 
c 
o 
m 
0 
0x00 
+0x18 0x0f 
0x0001 
0xc0 0x0c 
0x000f 
0x0001 
0x000151 
+0x24 0x80 
0x0009 
0x0000 
4 
s 
m 
t 
p 
0xc0 0x0c 
DNS Parsing Logic: Type MX 
if (cacheEntryQueryType == DNS_TYPE_MX && rrtype == DNS_TYPE_MX) { 
    addr_info = tfDnsAllocAddrInfo(); 
    if (addr_info != NULL) { 
        /* copy preference value of MX record */ 
        memcpy(&addr_info->ai_mxpref, resourceRecordAfterNamePtr + 10, 2); 
        /* compute the length of the MX hostname */ 
        labelLength = tfDnsExpLabelLength(resourceRecordAfterNamePtr + 0xc, pktDataPtr); 
        addr_info->ai_mxhostname = NULL; 
        if (labelLength != 0) { 
            /* allocate buffer for the expanded name */ 
            asciiPtr = tfGetRawBuffer(labelLength); 
            addr_info->ai_mxhostname = asciiPtr; 
            if (asciiPtr != NULL) { 
                /* copy MX hostname to `asciiPtr` as ASCII */ 
                tfDnsLabelToAscii(resourceRecordAfterNamePtr + 0xc, asciiPtr, pktDataPtr); 
                /* ... */ 
            } 
/* ... */ 
1 
2 
3 
23 
*Pseudo-code 
DNS Label Length Calculation 
tt16Bit tfDnsExpLabelLength(tt8BitPtr labelPtr, tt8BitPtr pktDataPtr){ 
    tt8Bit currLabelLength; 
    tt16Bit i = 0, totalLength = 0; 
    while (labelPtr[i] != 0) { 
        currLabelLength = labelPtr[i]; 
        if ((currLabelLength & 0xc0) == 0) { 
            totalLength += currLabelLength + 1; 
            i += currLabelLength + 1; 
        } else { 
            newLabelPtr = pktDataPtr + (((currLabelLength & 0x3f) = labelPtr) { 
                return 0; 
            } 
            labelPtr = newLabelPtr; 
            i = 0; 
        } 
    } 
    return totalLength; 
} 
Only allows jumping 
backwards 
Reads the current 
label length 
Handles the common 
case: no compression 
Reads the 
compression offset 
24 
*Pseudo-code 
Vulnerability #1: Read Out-Of-Bounds 
• tfDnsExpLabelLength might read data out of the packet buffer 
while iterating over the length bytes (stops at a zero length byte). 
• Could result in denial-of-service (e.g., read from unmapped page). 
• Information leakage: 
• tfDnsLabelToAscii has no bounds check either. 
• Data from the heap could be interpreted as an MX hostname. 
• Data is leaked when the client tries to resolve the MX hostname. 
• Affects Treck version 4.7+, fixed later. 
• Sweet! but we want RCE… 
25 
More Issues with tfDnsExpLabelLength 
• Maximum domain name of 255 characters is not enforced. 
• Does not validate the characters of the domain name: should be 
alphanumeric and ‘-’ only. 
• totalLength variable is stored as an unsigned short (tt16Bit). 
26 
tt16Bit tfDnsExpLabelLength(tt8BitPtr labelPtr, tt8BitPtr pktDataPtr){ 
    tt8Bit currLabelLength; 
    tt16Bit i = 0, totalLength = 0; 
    /* ... */ 
    return totalLength; 
} 
More Issues with tfDnsExpLabelLength 
• Maximum domain name of 255 characters is not enforced. 
• Does not validate the characters of the domain name: should be 
alphanumeric and ‘-’ only. 
• totalLength variable is stored as an unsigned short (tt16Bit). 
27 
Vulnerability #2: Integer Overflow 
• We need to construct a name whose length is larger than 65536. 
• Can we overflow the totalLength variable within a DNS response 
packet? 
• Yes! We use the DNS compression feature to achieve this. 
• Idea: nested compression pointers.  
• Two challenges: 
• Maximum size of the DNS response packet allowed is 1460 bytes. 
• We can only jump backwards from our current label pointer. 
28 
Vulnerability #2: Integer Overflow 
0 
1 
2 
3 
4 
5 
6 
7 
8 
9 
a 
b 
c 
d 
e 
f 
+0 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
+16 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
+32 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
+48 
00 
0e 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
+64 
c0 
00 
0d 
0e 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
+80 
c0 
01 
c0 
02 
0b 
0c 
0d 
0e 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
+96 
c0 
03 
c0 
04 
c0 
05 
c0 
06 
07 
08 
09 
0a 
0b 
0c 
0d 
0e 
+112 
c0 
07 
c0 
08 
c0 
09 
c0 
0a 
c0 
0b 
c0 
0c 
c0 
0d 
c0 
0e 
branch byte
compression pointer
29 
totalLength= 0 
Vulnerability #2: Integer Overflow 
0 
1 
2 
3 
4 
5 
6 
7 
8 
9 
a 
b 
c 
d 
e 
f 
+0 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
+16 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
+32 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
+48 
00 
0e 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
+64 
c0 
00 
0d 
0e 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
+80 
c0 
01 
c0 
02 
0b 
0c 
0d 
0e 
0f 
0f 
0f 
0f 
0f 
0f 
0f 
0f 