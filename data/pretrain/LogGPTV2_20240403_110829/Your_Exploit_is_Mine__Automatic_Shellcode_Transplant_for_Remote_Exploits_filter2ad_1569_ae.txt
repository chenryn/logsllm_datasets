victim (or replayer/reﬂector) replays a modiﬁed exploit with
the shellcode replaced.
1) Machines.: Our experimental setup contains two ma-
chines: one machines hosts the DARPA Experimental Cyber
Research Evaluation Environment (DECREE), and the other
runs ShellSwap. DECREE runs on a virtual machine built
using an image provided by DARPA CGC [5, 6], which offers
an isolated environment for running and testing vulnerable
programs. It is assigned 1 CPU core and 1 GB of memory on
a host machine with Intel Core i7 2.8 GHz. The ShellSwap
machine is a standalone server with Intel Xeon E5-2630 v2 as
CPU and 96 GB of memory, running Ubuntu 14.04 LTS.
2) Process.: As is shown in Figure 8, the original exploits
are pre-generated for each vulnerable binary. ShellSwap takes
as input each pair of original exploit and replacement shellcode
and attempts to generate a modiﬁed exploit. We verify the
modiﬁed exploit against the binary in DECREE box to make
sure that it works and that the replacement shellcode is executed
with intended results. For testing and veriﬁcation, we modiﬁed
the utility script cb-replay-pov shipped in DECREE.
3) Reference system for comparison.: To demonstrate the
necessity of our approach in tackling the shellcode transplant
problem, we reimplemented the shellcode placement method
in the work of Cha et al. [12] in a new system on top
of angr and used it as our reference system (codenamed
SystemM). We simulate shellcode transplanting in SystemM by
ﬁrst re-triggering the exploit and then re-constraining individual
symbolic blocks in memory to the replacement shellcode one by
one until the modiﬁed exploit is created. If none of the symbolic
memory blocks is sufﬁciently large to hold the replacement
shellcode, or constraining every symbolic memory block to
replacement shellcode leads to an unsatisﬁable exploitation state
(due to path conﬂicts), then we deem the shellcode transplanting
as having failed.
C. Effectiveness
Table I presents the effectiveness comparison between
SystemM and ShellSwap. There is a signiﬁcant difference
between the number of modiﬁed exploits the two systems
successfully generated: SystemM successfully generated 31
exploits, whereas ShellSwap successfully generated 88 exploits.
The success rate for SystemM and ShellSwap are 31% and
88%, respectively. Not surprisingly, our method generated more
new exploits than previous work.
Statistics for all modiﬁed exploits successfully generated by
SystemM and ShellSwap are shown in Table III. ShellSwap
generated 57 exploits using only Layout Remediation and 31
more by leveraging Path Kneading. For comparison, we also
extended SystemM with Layout Remediation, resulting in, as
expected, an additional 26 more exploits over the base SystemM
implementation. Only 57% of all cases are successfully replaced
with new shellcode without Path Kneading, which demonstrates
the importance of conﬂict identiﬁcation and kneading of the
exploit path during shellcode replacement.
In addition, we evaluate the two-stage fallback on all 20
exploits: we replace the original shellcode in each exploit
with the fallback shellcode and generate new exploits2. In our
experiment, the two-stage fallback worked on 19 out of 20
exploits. This is because the fallback shellcode is shorter (19
bytes) than any instance of the replacement shellcode, and is
thus more likely to ﬁt into buffers under attacker controls.
Meanwhile, we observe that the success rate of shellcode
transplanting varies between different instances of replacement
shellcode (see Table IV). There is an expected negative
correlation between the success rate and the length of the
replacement shellcode. For example, shellcode S4 and S5,
which are both 37 byte long, have lower success rates than
other replacement shellcode that are shorter. This ﬁts with
our intuition that the longer a piece of shellcode is, the more
conﬂicts it might produce during the shellcode transplant step,
and the more difﬁcult it will be to generate a modiﬁed exploit.
Other results are less intuitive. For instance, S5 has a lower
success rate than S4, which is the same size. We looked into
failure cases, and we found that the failure is related to the null
byte in S5. S4 does not contain any null bytes. This conforms
2We do not evaluate all ﬁve instances of shellcode since any shellcode will
work in the second stage.
834
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:18:49 UTC from IEEE Xplore.  Restrictions apply. 
Binary
Size
Vulnerability Type
Original
Exploits
Modiﬁed
Exploits
SystemM ShellSwap
CADET_00001
CROMU_00001
EternalPass
Hug_Game
LUNGE_00002
On_Sale
OTPSim
Overﬂow_Parking
SQL_Slammer
Trust_Platform_Module
WhackJack
Total
Buffer Overﬂow
Integer Overﬂow
Untrusted Pointer
Off-by-one Error
Buffer Overﬂow
83 KB
92 KB
18 MB
3.1 MB Improper Bounds Checking
1.6 MB
125 KB
106 KB Improper Bounds Checking
92 KB
102 KB
89 KB
105 KB
Integer Overﬂow
Buffer Overﬂow
Buffer Overﬂow
Buffer Overﬂow
1
1
2
1
1
4
2
1
3
3
1
20
5
5
10
5
5
20
10
5
15
15
5
100
4
3
0
0
14
10
0
0
0
0
0
31
5
5
8
2
5
20
10
0
15
15
3
88
TABLE I: This table shows the vulnerable binaries, the types of their vulnerabilities, the numbers of original exploits of each
binary, the total number of attempted exploit modiﬁcations (one replacement shellcode per original exploit per binary), and the
number of modiﬁed exploits successfully produced by SystemM and ShellSwap.
Replacement 
Shellcode 
Our System 
Vulnerable Binary 
Original Exploit 
Modified Exploit 
P(cid:85)oof of 
Vulnerability 
DECREE 
Fig. 8: Experiment setup.
Shellcode
Length
# Instruction
Source
Shellcode
Length
# Success
Success Rate
S1
S2
S3
S4
S5
26 Bytes
29 Bytes
22 Bytes
37 Bytes
37 Bytes
7
11
12
8
12
ForAllSecure
ForAllSecure
Shellphish
Shellphish
ShellSwap
TABLE II: The shellcode information.
Shellcode Layout Remediation Path Kneading
S1
S2
S3
S4
S5
Total
12
13
14
9
9
57
7
5
5
8
6
31
TABLE III: The number of the generated exploits for each
shellcode and each approach.
to the common knowledge that null bytes complicate shellcode,
which is why they are generally avoided by exploit authors:
since null bytes are so frequently used as string terminators,
S3
S1
S2
S4
S5
22 Bytes
26 Bytes
29 Bytes
37 Bytes
37 Bytes
19
19
18
17
15
95%
95%
90%
85%
75%
TABLE IV: Success rate for each instance of replacement
shellcode, sorted by length.
the existence of null bytes may negatively impact the success
of the exploit if data is moved around using something like
strcpy.
D. Efﬁciency
Table V shows the time cost for each instance of replacement
shellcode and each approach. The average time cost for Layout
Remediation is 19.73 seconds, while the average time cost for
Path Kneading is 9426.99 seconds. The dramatic difference
between the two is because the latter requires one or more
iterations of symbolic tracing, which, as we have previously
discussed, is an extremely time consuming process. We leave
further performance improvement as future work, and note that
835
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:18:49 UTC from IEEE Xplore.  Restrictions apply. 
Shellcode Layout Remediation Path Kneading
S1
S2
S3
S4
S5
Average
18.85
21.05
20.38
21.01
17.36
19.73
5638.30
10993.84
8017.11
7993.11
14492.62
9426.99
TABLE V: Average time cost (in seconds) for each instance
of replacement shellcode and each approach.
there are example optimizations in related work that could be
applied to this problem.
VII. DISCUSSION
ShellSwap’s results open up new possibilities for the fast
adaptation and analysis of software exploits. In this section,
we explore the implications of these results, the limitations of
the system, and the direction of our future work.
A. Ethical Concerns
ShellSwap raises the concern that it enables malicious
attackers to quickly adapt exploits against unwitting victims
on the internet. Unfortunately, such criticism can be applied to
almost all security research. Similar to known techniques such
as automatic exploit generation [7, 12] or automatic patch-based
exploit generation [11], the merit of the ShellSwap system and
its solution of the shellcode transplant problem is to show the
potential abilities of attackers and to highlight the possibility
that one can automatically modify exploits to tailor attacks to
custom requirements. Our hope is that, by showing that this is
possible, ShellSwap will motivate new research into defenses
against customized exploits.
B. Limitation
While ShellSwap makes fundamental contributions toward
the solution of the shellcode transplant problem, there is still
work left to be done. Here, we discuss speciﬁc weaknesses of
the system that could be addressed by future work.
1) Other types of vulnerabilities: Our system focuses
solely on control-ﬂow hijack vulnerabilities, and we do not
address other vulnerability types, such as Information Leakage
and Denial of Service (DoS). To consider these types of
vulnerabilities, as well as other popular types, the shellcode
transplant problem would need to be redeﬁned, as shellcode
is not utilized in exploits targeting these vulnerabilities. Thus,
to generalize ShellSwap, we must ﬁrst deﬁne the analogous
problem in the context of a different vulnerabilities, and then
discuss possible designs to solve it.
We deﬁne the analogous problem for information leakage
vulnerabilities as the generation of a modiﬁed exploit that leaks
a different piece of data (whether a memory location, a ﬁle,
a variable in the program, etc.) than the original exploit does.
This is a complex task to accomplish: information leakage
exploits are hard to detect in the ﬁrst place because monitoring
the information ﬂow through a program is not EM-enforceable
in general. However, weaker variants such as taint tracking can
ﬁnd a smaller set of information leakage vulnerabilities. For
example, evidence shows that Valgrind can detect information
leakage exploits such as the Heartbleed attack [31], given
test cases that trigger it (i.e., an exploit). Since, by deﬁnition,
ShellSwap receives such an exploit as input, a possible method
for ShellSwap to function on information leakage is to use