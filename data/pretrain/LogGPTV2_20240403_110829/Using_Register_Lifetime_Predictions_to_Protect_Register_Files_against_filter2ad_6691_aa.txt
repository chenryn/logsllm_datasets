title:Using Register Lifetime Predictions to Protect Register Files against
Soft Errors
author:Pablo Montesinos and
Wei Liu and
Josep Torrellas
Using Register Lifetime Predictions to Protect Register Files Against Soft Errors∗
Pablo Montesinos, Wei Liu and Josep Torrellas
Department of Computer Science
University of Illinois at Urbana-Champaign
{pmontesi, liuwei, torrellas}@cs.uiuc.edu
http://iacoma.cs.uiuc.edu
Abstract
To increase the resistance of register ﬁles to soft errors,
this paper presents the ParShield architecture. ParShield is
based on two observations: (i) the data in a register is only
useful for a small fraction of the register’s lifetime, and (ii)
not all registers are equally vulnerable. ParShield selec-
tively protects registers by generating, storing, and check-
ing the ECCs of only the most vulnerable registers while
they contain useful data. In addition, it stores a parity bit
for all the registers, re-using the ECC circuitry for parity
generation and checking. ParShield has no SDC AVF and
a small average DUE AVF of 0.040 and 0.010 for the inte-
ger and ﬂoating-point register ﬁles, respectively. ParShield
consumes on average only 81% and 78% of the power of a
design with full ECC for the SPECint and SPECfp applica-
tions, respectively. Finally, ParShield has no performance
impact and little area requirements.
1. Introduction
With increased chip integration levels, reduced supply
voltages, and higher frequencies, soft errors are becoming a
serious threat for high-performance processors. Such errors
can be due to a variety of events, most notably the impact
of high-energy particles [2, 8, 23]. Since soft errors can
result in program visible errors [20], there have been pro-
posals for several architectural designs that protect different
structures of the processor, such as caches, memories, and
datapaths [6, 13, 16, 21].
One of the critical structures to protect in a processor is
the register ﬁle. It is a sizable structure that stores architec-
tural state. It often stores data for long periods of time and is
read frequently, which increases the probability of spread-
ing a faulty datum to other parts of the machine. For these
reasons, some commercial processors protect their regis-
ter ﬁles with either parity [3, 9] or error correcting codes
(ECC) [18]. Protecting the register ﬁle with only parity en-
ables error detection but not correction. In this case, when
∗
This work was supported in part by the National Science Founda-
tion under grants CHE-0121357 and CCR-0325603; DARPA under grant
NBCH30390004; DOE under grant B347886; and gifts from IBM and In-
tel. Wei Liu is now at Intel Corporation. His email is wei.w.liu@intel.com.
the error is detected, recovery is only possible by invok-
ing a high-level operation at the OS or application level.
Since the software might not always be able to recover from
the error, the application may need to terminate. Full ECC
support, on the other hand, enables on-the-ﬂy detection and
correction of errors. However, it does so at a cost in power
and possibly performance.
A cost-effective protection mechanism for soft errors in
register ﬁles should have no performance impact, keep the
remaining Architectural Vulnerability Factor (AVF) [11] to
a small value, consume modest power, and use little area.
To design such mechanism, we make two key observations
on the use of registers in general-purpose processors. The
ﬁrst one is that the data stored in a physical register is not
always useful. A soft error in a physical register while it is
not useful will not have any impact on the processor’s ar-
chitectural state. Consequently, we only need to protect a
register when it contains useful data. The second observa-
tion is that not all the registers are equally vulnerable to soft
errors. A small set of long-lived registers account for a large
fraction of the time that registers need to be protected. The
contribution of most of the other registers to the vulnerable
time is very small.
Based on these two key observations, this paper proposes
ParShield, a novel architecture that provides cost-effective
protection for register ﬁles against soft errors. ParShield
relies on the Shield concept, which selectively protects a
subset of the registers by generating, storing, and checking
the ECCs of only the most vulnerable registers while they
contain useful data. Such support reduces the AVF of the
integer register ﬁle by an average of 73% to 0.040, and the
AVF of the ﬂoating-point register ﬁle by an average of 85%
to 0.010. ParShield also adds a parity bit for all the regis-
ters and re-uses the ECC circuitry for parity generation and
checking as well. As a result, ParShield has no Silent Data
Corruption (SDC) AVF (all single-bit errors are detected),
has a Detected Unrecoverable Error (DUE) AVF as low as
Shield’s AVF, and consumes on average only 81% and 78%
of the power of a design with full ECC for the SPECint and
SPECfp applications, respectively. Moreover, ParShield has
no performance impact and little area requirements.
The paper is organized as follows. Section 2 describes
the motivation of this work; Sections 3 and 4 describe the
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:33:39 UTC from IEEE Xplore.  Restrictions apply. 
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 2007PreWrite
Useful
PostLastRead
un-ACE period
un-ACE period
ACE period
Allocation
Write Read1
Read2
Readlast
Deallocation
Time
ta
tw
td
Time
ta
tw
tr
1
tr
n
td
Time
n-1
register version n
n+1
(a) Written but not read
(b) Written and read n times
Figure 1. Lifetime of a register version.
Figure 2. ACE periods of two register versions.
design and the implementation of ParShield; Sections 5
and 6 evaluate ParShield; and Section 7 describes related
work.
2. Motivation: Assigning Reliability Resources
2.1. Register Lifetime
Modern out-of-order processors use register renaming
with a large number of physical registers to support many
in-ﬂight instructions [4]. After the processor decodes an in-
struction with a destination register, it allocates a free phys-
ical register, creating a new register version. Later, the in-
struction is executed, and its result is written to the cor-
responding physical register. Subsequent instructions that
use that value are renamed to read from that physical reg-
ister. The register version is kept until the instruction that
redeﬁnes the corresponding logical register retires — this is
necessary to handle precise exceptions. Note that a version
is written to only once but can be read multiple times.
As Figure 1 shows, the lifetime of a register version lasts
from register allocation to deallocation. We divide it into
three different periods: from allocation until write; from
write until last read; and from last read to deallocation. We
call these periods PreWrite, Useful, and PostLastRead, re-
spectively. Note that only the Useful period needs to be
protected.
2.2. Register ACE Analysis
Errors are usually classiﬁed as undetected or detected.
The former are known as Silent Data Corruption (SDC),
while the latter are usually referred to as Detected Unrecov-
erable Errors (DUE) [11]. Errors for which detection and
recovery succeeds are not treated as errors.
A structure’s Architectural Vulnerability Factor (AVF) is
the probability that a fault in that structure will result in an
error [11]. The SDC AVF and DUE AVF are the probabili-
ties that a fault causes an SDC or a DUE error, respectively.
In general, if a structure is protected by an error detection
mechanism, its SDC AVF is zero. If the structure has error
detection and correction capabilities, its DUE AVF is zero.
In this work, we assume that the AVF for a register ﬁle is
the average AVF of all its bits.
Mukherjee et al. [11] proposed the concept of Architec-
turally Correct Execution (ACE) to compute a structure’s
AVF. ACE analysis divides a bit’s lifetime into ACE and
un-ACE periods. A bit is in ACE state when a change in
its value will produce an error. The AVF for a single bit is
the fraction of time that it is in ACE state. To calculate the
total time a bit is in ACE state, we start by assuming that
e
m
i
t
e
f
i
L
%
100
80
60
40
20
0
2
p
z
b
i
y
t
f
a
r
c
p
a
g
i
p
z
g
f
c
m
r
e
s
r
a
p
k
m
b
l
r
e
p
x
e
t
r
o
v
f
l
o
w
t
r
p
v
g −
v
A
n
t
I
t
r
a
e
k
a
u
q
e
a
s
e
m
d
i
r
g
m
i
m
w
s
Figure 3. Integer versions lifetime breakdown.
PreWrite
Useful
PostLastRead
g
v
A
P
F
i
e
s
w
p
u
w
its whole lifetime is in ACE state, and then we remove the
fraction that can be proven un-ACE. The fraction left is an
upper bound on the ACE time.
As an example, Figures 2(a) and (b) show two register
versions and their ACE and un-ACE periods. In both cases,
a free physical register R is allocated at time ta and deal-
located at time td. During its PreWrite period, it remains
in un-ACE state. At time tw, R is written to and, if it will
be consumed at least once, it switches to ACE state. Fig-
ure 2(a) depicts a register version that is never read, so it
remains in un-ACE state for its whole lifetime. Figure 2(b)
shows a register version that is consumed n times, so it en-
ters ACE state at tw and remains in it until it is read for the
last time at tr n. A register version is in un-ACE state during
its PostLastRead period.
There is one case where a register is read and it should
still remain in un-ACE state. This is when the reader in-
structions are eventually squashed and, therefore, are never
committed. For simplicity, however, in this work we do not
consider it; if a register will be read, it is ACE.
2.3. Two Key Observations
Our analysis of SPECint and SPECfp 2000 applications
for an out-of-order superscalar processor with 128 integer
physical registers (Section 5) enables us to make two key
observations.
The Combined Useful Time of All the Registers is
Small. We observe that the time a register version is in
Useful state is only a small fraction of the register’s lifetime.
Figure 3 shows the average integer register’s PreWrite, Use-
ful, and PostLastRead times for both SPECint and SPECfp
applications. As shown in the ﬁgure, on average only 22%
and 15% of the register lifetime is Useful for SPECint and
SPECfp applications, respectively. Therefore, there is no
need to provide protection for the whole lifetime of a regis-
ter version.
Figure 4 shows the average number of integer physi-
cal registers that are in Useful state at a given time. For
SPECint, the average is less than 20 registers out of 128.
For SPECfp, it is approximately 17 out of 128.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:33:39 UTC from IEEE Xplore.  Restrictions apply. 
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 2007s
r
e
t
s
g
e
R
i
l
i
a
c
s
y
h
P
#
30
24
18
12
6
0
2
p
z
b
i
y
t
f
a
r
c
p
a
g
i
p
z
g
f
c
m
r
e
s
r
a
p
k
m
b
l
r
e
p
x
e
t
r
o
v
f
l
o
w
t
r
p
v
g −
v
A
n
t
I
t
r
a
e
k
a
u
q
e
a
s
e
m
d
i
r
g
m
i
m
w
s
g
v
A
P
F
i
e
s
w
p
u
w
Figure 4. Average number of integer physical reg-
isters in useful state.
Long
Short
2
p
z
b
i
y
t
f
a
r
c
p
a
g
i
p
z
g
f
c
m
r
e
s
r
a
p
k
m
b
l
r
e
p
r
p
v
f
l
o
w
t
x
e
t
r
o
v
g .
v
A
t
n
I
t
r
a
a
s
e
m
d
i
r
g
m
i
m
w
s
e
k
a
u
q
e
g
v
A
P
F
i
e
s
w
p
u
w
(a) Allocated register versions
Long
Short
100
80
60
40
20
0
100
80
60
40
20
0
2
p
z
b
i
y
t
f
a
r
c
p
a
g
i
p
z
g
f
c
m
r
e
s
r
a
p
k
m
b
l
r
e
p
f
l
o
w
t
r
p
v
x
e
t
r
o
v
g .
v