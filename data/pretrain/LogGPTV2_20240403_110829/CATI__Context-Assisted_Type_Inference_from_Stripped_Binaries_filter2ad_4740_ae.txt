### 优化后的文本

---

#### 表 V：每个变量类型的评估结果
| 支持数 | cnt-same | cnt-all | c-rate |
| --- | --- | --- | --- |
| 1400 | 1.38 | 5.37 | 25.68% |
| 6874 | 3.60 | 5.46 | 65.85% |
| 2697 | 1.51 | 4.21 | 35.77% |
| 404 | 2.40 | 5.11 | 47.05% |
| 8 | 1.22 | 4.44 | 27.50% |
| 13972 | 4.25 | 6.24 | 68.02% |
| 153 | 2.90 | 6.30 | 45.97% |
| 2654 | 1.18 | 4.92 | 24.03% |
| 38591 | 3.10 | 5.81 | 53.36% |
| 46 | 0.81 | 5.22 | 15.45% |
| 5051 | 3.17 | 5.97 | 53.14% |
| 21 | 1.23 | 3.00 | 41.03% |
| 1808 | 4.72 | 6.72 | 70.16% |
| 70 | 1.02 | 4.17 | 24.54% |
| 6188 | 2.43 | 5.89 | 41.29% |
| 21 | 2.57 | 7.86 | 32.73% |
| 2820 | 3.06 | 4.88 | 62.57% |
| 36876 | 2.01 | 5.02 | 40.09% |

**说明**：
- **支持数 (Support)**: 每个变量类型的支持数。
- **cnt-same**: 每个VUC中与目标变量类型相同的指令数量的平均值。
- **cnt-all**: 每个VUC中的指令数量的平均值。
- **c-rate**: 相同类型变量在所有变量中的比例。

---

### 变量分类性能评估

表 III 显示了从阶段 1 到阶段 3-3 的指针和非指针、指针子类、非指针子类、char 类型子类、float 类型子类以及 int 类型子类的分类性能。P、R 和 F1 分别代表精度、召回率和 F1 分数，这些是机器学习领域常用的指标。

- **阶段 1**：总体表现最佳，指针和非指针之间的特征区分明显。
- **阶段 2-1**：表现不佳，特别是应用 R 在此阶段的表现最差，因为其指针变量的行为难以捕捉。
- **阶段 3**：阶段 3-1 和阶段 3-3 在分类上表现较好，而阶段 3-2 的表现较差，主要是由于某些应用（如 gzip、nano 和 sed）没有 float 家族变量，且数据集不平衡。

---

### 投票机制后的评估结果

表 IV 显示了投票机制后的结果。投票机制通过少数服从多数的原则调整错误分类。经过投票后，阶段 1、阶段 2-2、阶段 3-1 和阶段 3-3 的性能显著提升，但阶段 2-1 和阶段 3-2 的性能有所下降。

---

### 应用程序级别的评估结果

表 VI 显示了每个应用程序在 VUC 和变量粒度上的评估结果。总体加权准确率为：
- VUC 粒度：0.68（测试超过 1,000,000 个 VUC）
- 变量粒度：0.71（测试超过 150,000 个变量）

应用 sed 达到了最高的准确率（0.78），而 wget 的准确率最低（0.66）。

---

### 与 DEBIN 的比较

为了与最先进的方法 DEBIN 进行比较，我们在类似的设置下进行了实验。我们随机选择了 300 个二进制文件，并完成了相同的任务（分类 17 种不同类型的变量）。结果显示，CATI 的性能比 DEBIN 高出约 11%（准确率 0.84 对比 0.73）。

---

### 聚类现象的理解

表 V 显示了每个变量的结果。列 2 至 5 分别表示阶段 1、阶段 2-2、阶段 3 和最终加权平均结果的召回率。cnt-same、cnt-all 和 c-rate 分别表示相同类型变量的平均数量、总变量指令的平均数量和它们的比例。

- **类型 double、int 和 unsigned int**：在所有阶段表现良好，这可以通过高聚类率来解释。
- **类型 bool**：虽然聚类率较低，但表现良好，原因是布尔类型变量的使用模式相对简单。
- **类型 struct**：尽管聚类率较高，但由于结构体变量的使用非常多样化，因此表现较差。

---

### 决定性因素分析

为了找到预测结果的决定性因素，我们引入了一个新的测量指数 ，计算公式如下：

\[ \Lambda_k = \frac{S_u(R(VUC_j, k))}{S_u(VUC_j)}, \quad k \in [1, 21], \quad j \in T \]

其中 \( S_u(VUC_j) \) 表示在阶段 u 中对 VUCj 的置信度，k 表示 VUCj 中第 k 个指令的位置，j 表示数据集 T 中的第 j 个 VUC。函数 R 会遮蔽特定指令。公式 (5) 中，R 会遮蔽 VUCj 中的第 k 个指令并替换为 BLANK。\( S_u(R(VUC_j, k)) \) 表示在没有第 k 个指令信息的情况下，VUCj 在阶段 i 的置信度。

---

希望这些优化后的文本能够更清晰、连贯和专业地传达信息。如果有任何进一步的需求，请随时告知。