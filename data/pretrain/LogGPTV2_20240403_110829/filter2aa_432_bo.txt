signal (SIGHUP,SIG_IGN);
if (( slavefd =open (ling,O_RDWR))h_name,(char * )0);
fataperror(2,“/bin/login”);
}
else  /* 父进程 */
{
close (slavefd);
ioctl (0,FIONBIO,&one);
ioctl (masterfd,FIONBIO,&one);
ioctl (masterfd,TIOCPKT,&one);
signal(SIGTSTP,SIG_IGN);
signal (SIGCHLD,cleanup);
setpgrp (0,0);
protocol (0,masterfd);
signal (SIGHLD,SIG_IGN);
cleanup( );
}
当客户通过 TCP 端口发送来一个登录请求的时候，inted 就激活远程登录服务员
rlogind，由它激活标准 Linux login 程序。如果通过了检查，则由 login 进程激活用户的注
- 248 -
Linux网络编程
册 shell。
代码中函数 cleanup 调用了函数 logout 和 logwtmp，第一个函数把文件 /etc/utmp 的用
户入口删除，该文件为每个当前注册进入系统的用户保持一个入口项。函数 logwtmp 在文
件 /usr/adm/wtmp 中增加了一个入口项，每当用户注册进入或者退出登录的时候，都在该
文件中加入一个入口项。这两个文件一般都由程序 /bin/login 和/etc/init 来维持。事实上，
程序 login 只完成其中一部分，这里文件终止项都由 rlogind 程序来处理。
第十二章  远程过程调用
- 249 -
第十二章  远程过程调用
12.1  引言
本章我们对一些技术和机制进行讨论，这些技术和机制有助于程序员使用客户机-服务
器范例。我们一般性的介绍远程过程调用 RPC（Remote Procedure Call）的概念，还将描述
一个工具（rpcgen），它可以为一个使用远程调用的程序生成它所需要的大部分 C 代码。最
后我们给出一个完整的可以运行的例子，通过这个例子来说明 rpcgen 这个工具是如何生成
一个使用远程过程调用的客户机和服务器的。
所谓过程调用，是指将控制从一个过程 A 传递到另一个过程 B，返回时过程 B 将控制
进程交给调用过成 A。在目前大多数系统中，调用者和被调用者都在给定主机系统中的一
个进程中，他们是在产生程序执行文件时由链接器连接起来的，这类过程调用成为本地过
程调用。而远程过程调用（RPC）指的是由本地系统上的进程激活远程系统上的进程，我
们将此称为过程调用是因为它对程序员来说表现为常规过程调用。我们用“ 请求” 代表客
户调用远程过程，“ 应答” 代表远程过程将其结果返回给客户。
对于编写远程调用程序来说，首先应熟悉与远程调用有关的各个系统调用，这些系统
调用在前面已经使用过很多次，但这里还要再提出一次，因为这是网络通信软件设计的基
础。
远程过程调用和远程命令执行很容易混淆起来，其实它们之间的区别还是很明显的。
远程命令执行是由远程主机开始一个命令程序的执行，而远程过程调用是由本地主机开始
一个程序的执行，在程序执行的中间调用远程主机提供的过程。处理远程过程调用的进程
有两个，一个是本地客户进程，另一个是远程服务器。对本地进程来说，远程过程调用表
现为对客户进程的过程控制，然后由客户进程生成一个消息，通过网络系统调用发往远程
服务器。网络信息中包括过程调用所需的参数，远程服务器接到信息后调用相应过程，然
后将结果通过网络发回客户进程，再由客户进程将结果返回给调用进程。因此，远程系统
调用对调用者表现为本地过程调用，但实际上是调用了远程系统上的过程。
远程系统调用 RPC 使用了若干种不同的传送协议，不了解它们，在使用不同传送协议
的系统之间，就无法实现远程过程调用。这里介绍了三种传送协议：Sun RPC,Xerox Courier
和 Apollo RPC。
对于不同的传送协议，应有不同的通信处理方法，因此对于上面三种传送协议要提供
三种不同的程序。
12.2  远程过程调用模型
我们在描述客户机／服务器程序时，不能只分别查看客户机和服务器的各个构建
（Component）的结构，我们在构建一个客户机／服务器软件时，我们不能一次关注于其
中的一个构建。我们必须考虑整个系统是如何交互的，以及各个构建之间应该如何交互。
为了帮助程序员理解客户机／服务器的交互，研究人员已经为构建分布程序设计出一
套概念性的框架。该框架被称为远程过程调用模型（Remote Procedure Call Model）或 RPC
模型，它把我们所熟悉的来自传统程序的概念作为分布式应用的基础。
远程调用模型主要来自于传统语言中的过程调用机制。过程调用提供了一个强有力的
抽象，它允许程序员将一个程序划分成一些小的，可管理的，易于理解的片段。过程特别
有用，因为它具有一个能给出程序执行的概念性模型的简单明了的实现。下图说明了这个
- 250 -
Linux网络编程
概念。
图 12-1  过程概念
    远程过程调用模型使用了和传统过程一样的抽象。只是，它允许一个过程的边界跨越
两台计算机。图 12-2 表示了远程调用过程模型如何将一个程序划分成两片，每片在一个单
独的计算机上执行。当然，远程过程调用不能有一台计算机传递到另一台上。在程序可以
使用远程过程调用之前，必须加入允许程序与远程过程通信的协议软件。
图 12- 2  分布式程序
12.3  传统过程调用和远程过程调用的比较
一般程序的过程模型提供了一个程序执行的概念性解释，它可以直接扩展到远程过程
调用上。让我们考虑一下内存中那些以编译好的程序代码在执行中的顺序，这将有助于帮
助我们理解这个概念。图 12-3 展示了控制流从主程序传到两个过程，然后返回。
计算机从一个主程序 main 开始执行，它将一直执行下去，直到遇到第一个过程调用。
这个调用使执行转入到某个指定的过程代码并继续执行。如果它遇到了另一个调用，计算
机便转入到第二个调用。
程序继续在所有调用的过程中执行，直到它遇到了 return 语句。这个返回使程序恢复
到紧挨着最后一个调用之后的那个位置。任意的时候，只有一个执行在继续。因此，在计
算机执行对一个过程的调用时，另外一个过程必须暂时停止。计算机挂起调用进程，在调
用过程中，将这个过程的所有变量的值又可以使用了。一个被调用的进程可以进一步使用
过程调用，因为计算机记住了调用的次序，而且总是返回最近执行的调用者。
过程概念：一个传统的程序由一个或多个过程所组成。它们往往按照一种调用等级来
安排。从过程 n 到过程 m 的箭头代表由从 n 到 m 的调用。
图 12-2 是一个分布式程序，它说明了怎样从一个调用本地过程的程序扩展成使用远程过程调
用的程序。划分发生在主程序和过程四之间。实现远程过程调用需要有一个通讯协议。
第十二章  远程过程调用
- 251 -
图 12-3  普通程序的执行过程
下面我们来考虑远程过程。传统过程调用可以帮助我们来理解它。我们现在不考虑一
个客户机程序和服务器程序交换消息，而是想象每个服务器实现了一个（远程的）过程，
而且，客户机和服务器之间的交互对应于过程的调用和返回。由客户机发送给服务器的请
求对应与一个远程过程调用，而由服务器返回的信息，对应与一个过程的返回指令执行。
图 12-4 展示了这个比喻。
图 12-4  远程过程调用的执行模型
    远程过程调用概念提供了一个强有力的类比方法，它允许程序员以一种他所熟悉的环
境来思考客户机和服务器的交互。如同一个传统的过程调用，一个远程过程调用把控制权
传递给被调用的过程。也像传统的过程调用一样，在调用进行中，系统把调用过程的执行
挂起，而只允许被调用过程执行。
当一个远程程序发出一个响应的时候，对应与在传统过程调用执行一个 return。控制
权返回给被调用者，被调用过程停止执行。嵌套的过程调用的想法也可应用到远程过程调
用。一个远程过程也许要调用另一个远程过程。如上图所展示的，嵌套的远程过程调用对
图 12-4 给出了远程过程调用的执行模型。单个执行顺序是建立在分布式环境下的。服务器
和服务器间的尖头代表一个远程过程调用时，控制权是如何由一个客户机传递给一个服务器
的，以及它又是如何在服务器响应后返回给客户机。
- 252 -
Linux网络编程
应与这种情况，既一个服务器变成了另一个服务器的客户机。
当然，远程过程调用和客户机／服务器之间交互的细节不是一个这个类比所能够说明
白的，例如：一个传统的过程会一直保持在完全不活动的状态，直到有调用它的行为。而
远程过程调用，服务器在没有请求的时候必须在那里一直等待接受请求。更大的不同来自
与数据流传向远方的方式。传统的过程调用只能接受几个参数，返回也仅仅可以返回少数
几个结果。而远程过程调用可以接受或返回任意数量的数据。
如果本地调用和远程过程调用的行为是一致的，这样当然是理想的。但是，许多实际
的约束却使他们不能这样。
首先，网络的延时会使一个远程过程调用的开销远远比本地调用要大。
其次，传统的过程调用因为被调用过程和调用过程运行在同一块内存空间上，可
以在过程间传递指针。而远程过程调用不能够将指针作为参数，因为远程过程与调用者运
行在完全不同的地址空间中。
再次，因为一个远程调用不能共乡调用者的环境，所以它就无法直接访问调用者
的 I/O 描述符或操作系统功能。例如远程过程调用不能在其调用者的标准错误记录文件中
直接写入错误信息。
12.4  远程过程调用的定义
Sun Microsystem 公司定义了一个特定形式的远程过程调用，它称为 Sun RPC，开放网
络计算 (Open Network Computing，ONC) RPC，或简称 RPC。ONC 远程过程定义也被业
界所广泛接受。它已经被用来做了许多网络软件的应用机制，其中包括网络文件系统（NFC
Network File System）。
ONC RPC 定义了调用者（客户机）发出的调用服务器中的某个远程过程的格式，参数
的格式，以及被调用过程返回给调用者的结果的格式。它允许调用程序使用 UDP 或 TCP
来装载报文，它利用 XDR 来表示过程的参数以及 RPC 报文首部中的其他条目。最后，除
了协议说明之外，ONC RPC 还包括一个编译系统（rpcgen），它帮助程序员自动建立分布
式程序。
12.5  远程过程调用的有关问题
为了使 RPC 的使用和调用过程一样，应该先解决一些问题，下面分别予以讨论。
1．参数传递
在客户进程和服务器之间的参数传递是可见的，这样，如果参数通过指针引用就会出
现问题，这是因为服务器无法访问客户系统上的内存单元。一个典型的解决方法是 RPC 协
议只允许客户进程传递值参，对于每个远程进程，可以定义一定的格式，如预先定义输入
参数以及返回值的格式是什么。
2．传送协议
有些 RPC 实现仅使用单个传送层协议，有些允许选择，本书中使用的是下面一些协议：
Sun RPC（UDP,TCP）
Xerox Courier（SPP）
Apollo RPC（UDP,DDS）
其中 Sun RPC 可用于面向连接的或非连接的协议，Xerox courier 仅用于面向连接的协
议，Apollo RPC 仅用于非连接协议。
使用非连接协议的时候，client stub 要考虑到丢失信息的问题，而面向连接的协议则无
须考虑这个问题，但另一方面，使用面向连接的协议的开销要大的多。
第十二章  远程过程调用
- 253 -
3．数据表示
对于一个本地进程，客户进程和服务器在同一个系统上执行，因此不存在数据不兼容
的问题，但对于远程过程调用 RPC，如果客户进程和服务器位于不同体系结构的系统上，
则必须有数据转换。
本书讨论的所有实现均通过给 RPC 实现支持的数据类型定义一个或者多个标准格式来
处理这个问题。我们必须考虑所有的数据项，而不仅仅是二进制，客户在使用 ASCII 的系
统上而服务器在使用 EBCDIC 的系统上也应该是可行的。我们可以参考一下本书中的其它
例子是如何处理的。
TCP/IP 协议组在各种协议头中的所有 16 位和 32 位域使用高字节在后的字节顺
序，诸如 32 位的网络和主机 ID 以及 16 位的 UDP 端口号域等。
XNS 协议组也使用 16 位和 32 位域的高位字节在后的字节顺序。
4.3 BSD 打印机假脱机系统将其二进制研制在单字节内，不存在字节序的问题，
对打印机名、文件名、文件大小和登录名等使用 ASCII。
远程登录客户和服务器在处理窗口大小的协议中的 16 位窗口大小域使用高字节在
后的字节序。
4.3 BSD rmt 服务器在除 “ 返回状态” 命令外的所有命令中使用 ASCII 串，这个
特殊命令在不同 UNIX 系统间也不能移植，应完全避免使用。该服务器对读写到磁带的数
据没有限制。
12.5.1  远程过程调用传送协议
现在我们比较一下本书中将要讨论的三个 RPC：
Sun RPC。它使用的数据表示标准是 XDR，XDR 使用高字节在后的字节序，任何
域的最小尺寸是 32 位。例如，当一个 VAX 客户进程要将一个 16 位整数传递给同样运行在
VAX 上的服务器时，该 16 位数首先由客户转换成 32 位高字节在后的整数，然后由服务器
转换回低字节在后的 16 位整数。
Xerox Courier。它使用的标准是高位字节在后的字节序，任何域的最小尺寸是 16
位。字符数据编码成 16 位的 Xerox NS 字符集，该字符集对于常规字符使用 ASCII，对于
其它的专用字符集如希腊语使用转义符。例如，当给某一打印机发送数学文本的时候使用
此字符集。
Apollo RPC。Apollo NDR 并不只是使用单个网络标准，而是支持多个格式。如果
用户的内部格式是其支持的格式之一，它允许发送者使用其自己的内部格式，然后，如果
与发送者的格式不同，接受者将其转换成自己的格式。
这三种 RPC 实现所支持的数据类型和格式如表 12-1。
表 12-1  三种 RPC 实现所支持的数据类型和格式
数据类型
Sun
RPC
Xerox
Courier
Apollo
NDR
8 位逻辑
16 位逻辑
32 位逻辑
        支持
支持
支持
8 位带符号整数
8 位无符号整数
16 位带符号整数
16 位无符号整数
32 位带符号整数
32 位无符号整数
支持
支持
支持
支持
支持
支持
支持
支持
支持
支持
支持
支持
- 254 -
Linux网络编程
64 位带符号整数
64 位无符号整数
支持
支持
支持
支持
字节序
高字节在后
高字节在后
高字节在后