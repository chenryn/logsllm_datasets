### 正则表达式

#### 结果
```
Welcome to my Homepage
Content is divided into two sections:
ColdFusion
Wireless
Information about Macromedia ColdFusion.
---
## Page 81
8.2 回溯引用匹配
71
Information about Bluetooth, 802.11, and more.
WH PTTAOU ST STUZH
分析
在这个例子里，原始文本中有一个标题是以 `<h1>` 开头、以 `</h1>` 结束的。这显然是一个不合法的标题，但它与我们使用的模式匹配上了。出现这种情况的原因是这个模式的第二部分（用来匹配结束标签的部分）对第一部分（用来匹配开始标签的部分）毫无所知。要彻底解决这个问题，只能求助于回溯引用。
```

### 8.2 回溯引用匹配
我们稍后会解决匹配 HTML 标题的问题。先来看一个比较简单的例子，这个问题如果不使用回溯引用将无法解决。

假设你有一段文本，你想找出这段文本中所有连续重复出现的单词（打字错误，其中有一个单词输入了两遍）。显然，在搜索某个单词的第二次出现时，这个单词必须是已知的。回溯引用允许正则表达式模式引用前面的匹配结果（具体到这个例子，就是前面匹配到的单词）。

下面是一段包含三组重复单词的文本，它们是我们要找的目标：
```
文本
This is a block of of text,
several words here are are
repeated, and and they
should not be.
```

#### 正则表达式
```
[ ]+(\w+)[ ]+\1
```

#### 结果
```
This is a block of of text,
several words here are are
repeated, and and they
should not be.
```

### 分析
这个模式找到了我们想要的东西，但它是如何做到这一点的呢？`[ ]+` 匹配一个或多个空格，`\w+` 匹配一个或多个字母数字字符，`[ ]+` 匹配随后的空格。注意，`\w+` 是括在括号里的，它是一个子表达式。这个子表达式不是用来进行重复匹配的，这里根本不涉及重复匹配的问题。这个子表达式只是把整个模式的一部分单独划分出来以便在后面引用。这个模式的最后一部分是 `\1`：这是一个回溯引用，而它引用的正是前面划分出来的那个子表达式。当 `(\w+)` 匹配到单词 `of` 的时候，`\1` 也匹配单词 `of`；当 `(\w+)` 匹配到单词 `and` 的时候，`\1` 也匹配单词 `and`。

#### 提示
你可以把回溯引用想象成变量。

看过回溯引用的用法之后，再回过头来看看应该如何解决匹配 HTML 标题的问题。利用回溯引用，构造一个模式去匹配任何一级标题的开始标签和与之配对的结束标签（忽略任何不配对的标签组合）对我们来说已经不是什么难题了。下面就是一个例子：

#### 文本
```
Welcome to my Homepage
Content is divided into two sections:
Information about Macromedia ColdFusion.
ColdFusion
Wireless
Information about Bluetooth, 802.11, and more.
This is not valid HTML
```

#### 正则表达式
```
<h([1-6])>.*?</h\1>
```

#### 结果
```
Welcome to my Homepage
Content is divided into two sections:
Information about Macromedia ColdFusion.
ColdFusion
Information about Bluetooth, 802.11, and more.
Wireless
This is not valid HTML
```

### 分析
总共找到了三个匹配：一个一级标题 (`<h1>`) 和两个二级标题 (`<h2>` 和 `<h2>` )。匹配任何一级标题的开始标签，但我们这次用 `(<h([1-6])>)` 把 `[1-6]` 括了起来，使它成为一个子表达式。这样一来，我们就可以在用来匹配标题结束标签的 `</h\1>` 中引用这个子表达式。子表达式 `([1-6])` 匹配数字 1 到 6，`\1` 只匹配与之相同的数字。这样一来，原始文本中的 `This is not valid HTML` 就不会被匹配到了。

#### 注意
不同的正则表达式实现中，回溯引用的语法往往有很大的差异。JavaScript 使用 `\` 来标识回溯引用（与 `$` 配合进行替换操作时例外），Macromedia ColdFusion 和 Perl 也是如此。.NET 正则表达式将返回一个对象，该对象的 `Groups` 属性包含所有的匹配。如果你使用的是 C# 语言，`match.Groups[1]` 对应第一个匹配；如果你使用的是 Visual Basic.NET，`match.Groups(1)` 对应第一个匹配。PHP 把这些信息返回为一个名为 `matches` 的数组，`matches[1]` 对应第一个匹配（但这一行为会根据你在匹配操作中具体使用的命令选项发生变化）。Java 和 Python 将返回一个包含 `group` 数组的匹配对象。

有关细节参阅附录 A。

### 警告
回溯引用只能用来引用模式里的子表达式（用 `(` 和 `)` 括起来的正则表达式片段）。

#### 提示
回溯引用通常从 1 开始计数（1、2 等）。在许多实现中，第 0 个匹配（`$0`）可以用来代表整个正则表达式。

#### 注意
正如看到的那样，子表达式是通过它们的相对位置来引用的：`\1` 对应第一个子表达式，`\5` 对应第五个子表达式，等等。虽然受到普遍的支持，但这种语法存在着一个严重的不足：如果子表达式的相对位置发生了变化，整个模式也许就不能再完成原来的工作，删除或添加子表达式的后果可能更为严重。

为了弥补这一不足，一些较新的正则表达式实现还支持“命名捕获”（named capture）：给某个子表达式起一个唯一的名字，然后用这个名字（而不是相对位置）来引用这个子表达式。因为命名捕获还没有得到广泛支持，而且已支持的实现具体的语法也极不统一，所以本书没有对此进行讨论。但是，如果你正在使用的正则表达式实现支持命名捕获功能（如 .NET），你应该充分利用。

### 8.3 回溯引用在替换操作中的应用
到目前为止，你们在这本书里见到的正则表达式都是用来执行搜索的，即在一段文本里查找特定的内容。你在今后的实际工作中也会发现，你所编写的绝大多数正则表达式模式也可以用来搜索文本。但这并不是正则表达式的全部功能：正则表达式还可以用来完成各种复杂的替换操作。

简单的文本替换操作无须使用正则表达式就可以完成。比如说，如果只是把某个文档里的 CA 全部替换为 California 或把 MI 全部替换为 Michigan 的话，用正则表达式来完成这些替换就未免有点儿大材小用了。这句话的意思并不是说正则表达式不能用来执行这种替换，而是这样做没有什么实际价值。事实上，用普通的字符串处理函数来完成这种替换反而会更容易一些。

正则表达式更适用于复杂的替换，尤其是需要使用回溯引用的场合，那才能体现出正则表达式的真正威力。下面是一个我们在第 5 章里见过的例子：

#### 文本
```
Hello, beneforta.com is my email address.
```

#### 正则表达式
```
\w+[\w\.]*@[\w\.]+\.\w+
```

#### 结果
```
Hello, beneforta.com is my email address.
```

### 分析
这个模式可以把原始文本里的电子邮件地址查找出来（详细分析见第 5 章）。

现在，假设你需要把原始文本里的电子邮件地址全都转换为可点击的链接，你该怎么办？在 HTML 文档里，你需要使用 `<a href="mailto:user@address.com">user@address.com</a>` 这样的语法来创建一个可点击的电子邮件地址。能不能用一个正则表达式把一个电子邮件地址转换为这种可点击的地址格式呢？当然能，而且非常容易，但前提是你得使用回溯引用，如下所示：

#### 文本
```
Hello, beneforta.com is my email address.
```

#### 正则表达式
```
(\w+[\w\.]*@[\w\.]+\.\w+)
```

#### 替换
```
<a href="mailto:$1">$1</a>
```

#### 结果
```
Hello, <a href="mailto:beneforta.com">beneforta.com</a> is my email address.
```

### 分析
替换操作需要用到两个正则表达式：一个用来给出搜索模式，另一个用来给出匹配文本的替换模式。回溯引用可以跨模式使用，在第一个模式里被匹配的子表达式可以用在第二个模式里。这里使用的模式 `(\w+[\w\.]*@[\w\.]+\.\w+)` 与我们以前使用的完全一样（匹配电子邮件地址），但这次把它写成了一个子表达式。这样一来，被匹配到的文本就可以用在替换模式里了。`$1` 使用了两次被匹配的子表达式：一次是在 `HREF` 属性里（定义 `mailto:`），另一次是作为可点击文本。具体到这个例子，`<a href="mailto:beneforta.com">beneforta.com</a>` 正是我们想要的结果。

#### 警告
我们刚才讲过，回溯引用语法在不同的正则表达式实现里有很大的差异：JavaScript 用户需要用 `$` 来代替 `\`；ColdFusion 用户在查找和替换操作里都必须使用 `\`。

#### 提示
正如你在上面这个例子里看到的那样，同一个子表达式可以被引用任意多次，只要在需要用到它的地方写出它的回溯引用就行了。

我们再来看一个例子。在一个用来保存用户信息的数据库里，电话号码被保存为 `313-555-1234`，现在，你需要把电话号码重新排版为 `(313) 555-1234`。下面就是这个例子：

#### 文本
```
313-555-1234
810-555-9000
```

#### 正则表达式
```
(\d{3})-(\d{3})-(\d{4})
```

#### 替换
```
($1) $2-$3
```

#### 结果
```
(313) 555-1234
(810) 555-9000
```

### 分析
和刚才一样，这里也使用了两个正则表达式模式。第一个模式看起来很复杂，我们来分析一下。`(\d{3})-(\d{3})-(\d{4})` 用来匹配一个电话号码，它被划分为五个子表达式（五个组成部分）：第一个子表达式 `(\d{3})` 匹配前三位数字，第二个子表达式 `(-)` 匹配 `-` 字符，等等。最终的结果是一个电话号码被划分为五个部分（每个部分分别对应一个子表达式）：区号、一个连字符、电话号码的前三位数字、又一个连字符、电话号码的后四位数字。这五个部分都可以单独拿出来使用，负责重新排版电话号码的替换模式 `($1) $2-$3` 只用到了其中的三个部分，剩下的两个部分没有用到，但这已足以把 `313-555-1234` 转换为 `(313) 555-1234`。

#### 提示
在对文本进行重新排版的时候，把文本分解成多个子表达式的做法往往非常有用，这可以让我们对文本的排版效果做出更精确的控制。

### 大小写转换
有些正则表达式实现允许我们使用表 8-1 列出的元字符对字母进行大小写转换。

#### 表 8-1 用来进行大小写转换的元字符
| 元字符 | 说明 |
|--------|------|
| `\E`   | 结束 `\L` 或 `\U` 转换 |
| `\l`   | 把下一个字符转换为小写 |
| `\L`   | 把 `\L` 到 `\E` 之间的字符全部转换为小写 |
| `\u`   | 把下一个字符转换为大写 |
| `\U`   | 把 `\U` 到 `\E` 之间的字符全部转换为大写 |

`\l` 和 `\u` 只能把下一个字符（或子表达式）转换为小写或大写。`\L` 和 `\U` 将把它后面的所有字符转换为小写或大写，直到遇上 `\E` 为止。

下面是一个简单的例子，把一级标题 (`<h1>`) 的标题文字转换为大写：
```
<h1>Welcome to my Homepage</h1>
```

#### 正则表达式
```
<h1>(.*?)</h1>
```

#### 替换
```
<h1>\U$1\E</h1>
```

#### 结果
```
<h1>WELCOME TO MY HOMEPAGE</h1>
```

### 分析
这个模式找到一级标题的内容，并将其转换为大写。这样，`<h1>Welcome to my Homepage</h1>` 被转换为 `<h1>WELCOME TO MY HOMEPAGE</h1>`。