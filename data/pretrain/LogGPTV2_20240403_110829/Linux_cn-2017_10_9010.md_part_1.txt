---
author: Brad Peabody
category: 技术
comments_data: []
count:
  commentnum: 0
  favtimes: 2
  likes: 0
  sharetimes: 0
  viewnum: 10053
date: '2017-10-31 09:42:59'
editorchoice: false
excerpt: 了解应用程序的输入/输出（I/O）模型意味着理解应用程序处理其数据的载入差异，并揭示其在真实环境中表现。或许你的应用程序很小，在不承受很大的负载时，这并不是个严重的问题；但随着应用程序的流量负载增加，可能因为使用了低效的
  I/O 模型导致承受不了而崩溃。
fromurl: https://www.toptal.com/back-end/server-side-io-performance-node-php-java-go
id: 9010
islctt: true
largepic: /data/attachment/album/201710/31/094307myjfkfnjzjxtfhox.jpg
permalink: /article-9010-1.html
pic: /data/attachment/album/201710/31/094307myjfkfnjzjxtfhox.jpg.thumb.jpg
related: []
reviewer: ''
selector: ''
summary: 了解应用程序的输入/输出（I/O）模型意味着理解应用程序处理其数据的载入差异，并揭示其在真实环境中表现。或许你的应用程序很小，在不承受很大的负载时，这并不是个严重的问题；但随着应用程序的流量负载增加，可能因为使用了低效的
  I/O 模型导致承受不了而崩溃。
tags:
- 性能
thumb: false
title: 服务端 I/O 性能：Node、PHP、Java、Go 的对比
titlepic: true
translator: MonkeyDEcho
updated: '2017-10-31 09:42:59'
---
了解应用程序的输入/输出（I/O）模型意味着理解应用程序处理其数据的载入差异，并揭示其在真实环境中表现。或许你的应用程序很小，在不承受很大的负载时，这并不是个严重的问题；但随着应用程序的流量负载增加，可能因为使用了低效的 I/O 模型导致承受不了而崩溃。
和大多数情况一样，处理这种问题的方法有多种方式，这不仅仅是一个择优的问题，而是对权衡的理解问题。 接下来我们来看看 I/O 到底是什么。
![Cover Photo: Server-side I/O: Node vs. PHP vs. Java vs. Go](/data/attachment/album/201710/31/094307myjfkfnjzjxtfhox.jpg)
在本文中，我们将对 Node、Java、Go 和 PHP + Apache 进行对比，讨论不同语言如何构造其 I/O ，每个模型的优缺点，并总结一些基本的规律。如果你担心你的下一个 Web 应用程序的 I/O 性能，本文将给你最优的解答。
### I/O 基础知识: 快速复习
要了解 I/O 所涉及的因素，我们首先深入到操作系统层面复习这些概念。虽然看起来并不与这些概念直接打交道，但你会一直通过应用程序的运行时环境与它们间接接触。了解细节很重要。
#### 系统调用
首先是系统调用，其被描述如下：
* 程序（所谓“ 用户端   user land ”）必须请求操作系统内核代表它执行 I/O 操作。
* “ 系统调用   syscall ”是你的程序要求内核执行某些操作的方法。这些实现的细节在操作系统之间有所不同，但基本概念是相同的。有一些具体的指令会将控制权从你的程序转移到内核（类似函数调用，但是使用专门用于处理这种情况的专用方式）。一般来说，系统调用会被阻塞，这意味着你的程序会等待内核返回（控制权到）你的代码。
* 内核在所需的物理设备（ 磁盘、网卡等 ）上执行底层 I/O 操作，并回应系统调用。在实际情况中，内核可能需要做许多事情来满足你的要求，包括等待设备准备就绪、更新其内部状态等，但作为应用程序开发人员，你不需要关心这些。这是内核的工作。
![Syscalls Diagram](/data/attachment/album/201710/31/094309ad3ayrpycfe7x6y1.jpg)
#### 阻塞与非阻塞
上面我们提到过，系统调用是阻塞的，一般来说是这样的。然而，一些调用被归类为“非阻塞”，这意味着内核会接收你的请求，将其放在队列或缓冲区之类的地方，然后立即返回而不等待实际的 I/O 发生。所以它只是在很短的时间内“阻塞”，只需要排队你的请求即可。
举一些 Linux 系统调用的例子可能有助于理解：
* `read()` 是一个阻塞调用 - 你传递一个句柄，指出哪个文件和缓冲区在哪里传送它所读取的数据，当数据就绪时，该调用返回。这种方式的优点是简单友好。
* 分别调用 `epoll_create()`、`epoll_ctl()` 和 `epoll_wait()` ，你可以创建一组句柄来侦听、添加/删除该组中的处理程序、然后阻塞直到有任何事件发生。这允许你通过单个线程有效地控制大量的 I/O 操作，但是现在谈这个还太早。如果你需要这个功能当然好，但须知道它使用起来是比较复杂的。
了解这里的时间差异的数量级是很重要的。假设 CPU 内核运行在 3GHz，在没有进行 CPU 优化的情况下，那么它每秒执行 30 亿次 周期   cycle （即每纳秒 3 个周期）。非阻塞系统调用可能需要几十个周期来完成，或者说 “相对少的纳秒” 时间完成。而一个被跨网络接收信息所阻塞的系统调用可能需要更长的时间 - 例如 200 毫秒（1/5 秒）。这就是说，如果非阻塞调用需要 20 纳秒，阻塞调用需要 2 亿纳秒。你的进程因阻塞调用而等待了 1000 万倍的时长！
![Blocking vs. Non-blocking Syscalls](/data/attachment/album/201710/31/094311vnm0fhtzpfjb60l2.jpg)
内核既提供了阻塞 I/O （“从网络连接读取并给出数据”），也提供了非阻塞 I/O （“告知我何时这些网络连接具有新数据”）的方法。使用的是哪种机制对调用进程的阻塞时长有截然不同的影响。
#### 调度
关键的第三件事是当你有很多线程或进程开始阻塞时会发生什么。
根据我们的理解，线程和进程之间没有很大的区别。在现实生活中，最显著的性能相关的差异在于，由于线程共享相同的内存，而进程每个都有自己的内存空间，使得单独的进程往往占用更多的内存。但是当我们谈论 调度   Scheduling 时，它真正归结为一类事情（线程和进程类同），每个都需要在可用的 CPU 内核上获得一段执行时间。如果你有 300 个线程运行在 8 个内核上，则必须将时间分成几份，以便每个线程和进程都能分享它，每个运行一段时间，然后交给下一个。这是通过 “ 上下文切换   context switch ” 完成的，可以使 CPU 从运行到一个线程/进程到切换下一个。
这些上下文切换也有相关的成本 - 它们需要一些时间。在某些快速的情况下，它可能小于 100 纳秒，但根据实际情况、处理器速度/体系结构、CPU 缓存等，偶见花费 1000 纳秒或更长时间。
而线程（或进程）越多，上下文切换就越多。当我们涉及数以千计的线程时，每个线程花费数百纳秒，就会变得很慢。
然而，非阻塞调用实质上是告诉内核“仅在这些连接之一有新的数据或事件时再叫我”。这些非阻塞调用旨在有效地处理大量 I/O 负载并减少上下文交换。
这些你明白了么？现在来到了真正有趣的部分：我们来看看一些流行的语言对那些工具的使用，并得出关于易用性和性能之间权衡的结论，以及一些其他有趣小东西。
声明，本文中显示的示例是零碎的（片面的，只能体现相关的信息）; 数据库访问、外部缓存系统（ memcache 等等）以及任何需要 I/O 的东西都将执行某种类型的 I/O 调用，其实质与上面所示的简单示例效果相同。此外，对于将 I/O 描述为“阻塞”（ PHP、Java ）的情况，HTTP 请求和响应读取和写入本身就是阻塞调用：系统中隐藏着更多 I/O 及其伴生的性能问题需要考虑。
为一个项目选择编程语言要考虑很多因素。甚至当你只考虑效率时，也有很多因素。但是，如果你担心你的程序将主要受到 I/O 的限制，如果 I/O 性能影响到项目的成败，那么这些是你需要了解的。
### “保持简单”方法：PHP
早在 90 年代，很多人都穿着 [Converse](https://www.pinterest.com/pin/414401603185852181/) 鞋，用 Perl 写着 CGI 脚本。然后 PHP 来了，就像一些人喜欢咒骂的一样，它使得动态网页更容易。
PHP 使用的模型相当简单。虽有一些出入，但你的 PHP 服务器基本上是这样：
HTTP 请求来自用户的浏览器，并访问你的 Apache Web 服务器。Apache 为每个请求创建一个单独的进程，有一些优化方式可以重新使用它们，以最大限度地减少创建次数（ 相对而言，创建进程较慢 ）。Apache 调用 PHP 并告诉它运行磁盘上合适的 `.php` 文件。PHP 代码执行并阻塞 I/O 调用。你在 PHP 中调用 `file_get_contents()` ，其底层会调用 `read()` 系统调用并等待结果。
当然，实际的代码是直接嵌入到你的页面，并且该操作被阻塞：
```
<?php
// blocking file I/O
$file_data = file_get_contents(‘/path/to/file.dat’);
// blocking network I/O