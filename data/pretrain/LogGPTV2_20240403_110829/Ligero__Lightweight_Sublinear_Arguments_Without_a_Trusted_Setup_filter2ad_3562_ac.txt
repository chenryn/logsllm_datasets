cases depending on the graph G:
Case 1: There are more than tr edges in G. In this case, we will
argue that with high probability the set of servers opened by the
veri(cid:27)er will hit one of these edges. Recall that the view of R is
provided to the veri(cid:27)er. Therefore, for any edge in G between R
and Vi, if the corresponding server Pi falls in Q, then the veri(cid:27)er
rejects. The probability that all tp servers chosen by the veri(cid:27)er
misses all inconsistent edges is at most(cid:16)1 − tr
(cid:17)tp .
n
Case 2: There are fewer than tr edges in G. In this case, we will
argue that by the statistical tr -robustness of the underlying MPC
protocol Π, the veri(cid:27)er will reject except with probability δ(κ). More
precisely, for every cheating strategy P∗ in the ZK proof we will
demonstrate an adversarial strategy A attacking the underlying
MPC protocol such that the probability with which V accepts a
false statement when interacting with P∗ on a false statement will
be bounded by the probability that R outputs 1 in an execution of
the underlying MPC protocol with adversary A.
More precisely, consider an adversary A that is participating in
the MPC protocol with n servers, a sender and a receiver. Internally,
A incorporates the code of P∗ while emulating the roles of the
oracle and V. When the protocol begins, P∗ set the oracle with the
views of the servers as in Phase 1 of Π. These views simply contain
the inputs sent to the servers (as all computations are local). Upon
obtaining the views of the servers A will corrupt the sender in the
external MPC execution, and acting as the sender, it will send as
input to server Pi the value that was internally generated by P∗
as the view of that server, namely Vi. Next, recall that in the MPC
protocol the servers receive a random string from the coin-(cid:30)ipping
oracle (in our protocol the veri(cid:27)er picks r as the challenge in Step
1). A will internally forward this string r to P∗ as the message
provided by the veri(cid:27)er. Next internally, P∗ will generate the view
of the receiver R from which A computes the inconsistency graph
Session J1:  OutsourcingCCS’17, October 30-November 3, 2017, Dallas, TX, USA2091G. Recall that an edge is present between a server Pi and the receiver
R in this graph if the view of Pi is inconsistent with the view of R
and randomness r. Let T1 be the set of the servers of size t∗ that are
connected to an edge in G. If t∗ > tr , then A aborts.
Otherwise, A proceeds with the internal execution by selecting
tp indices for the veri(cid:27)er’s challenge, for which the oracle will
reveal the views of these corresponding servers. If V rejects in
the internal execution because any of these views are inconsistent,
then A aborts. Otherwise, A continues with the external execution.
Recall that in Phase 2, each server sends a single message to R. Then
just before the servers send these messages, A (adaptively) corrupts
the servers in T1 and replaces their (honestly generated) messages
sent to R by what was internally reported in the view of R, namely
the messages sent by P∗ to the veri(cid:27)er in the proof. Upon sending
the message in Phase 2, let T2 of size t(cid:48)∗ be the set of the servers
that are inconsistent with the view o R. If |T1 ∪ T2| > tr , then A
aborts. Otherwise, A (adaptively) corrupts the servers in t(cid:48)∗ and
continues as above.
It follows from this description that the acceptance condition
of the veri(cid:27)er in the internal emulation with A is identical to the
output of R in the external MPC execution. Since the underlying
MPC protocol is tr -robust and the number of parties corrupted by
A is t∗ such that |t∗| ≤ tr , we have that R outputs 0 except with
probability at most δ(κ).
We conclude that the veri(cid:27)er in the internal emulation by P∗
accepts the proof of a false statement except with probability at
most δ(κ). Next, we observe that the view of the veri(cid:27)er emulated
by A in the internal emulation is identically distributed to the view
of an honest veri(cid:27)er in an interactive with P∗. Therefore, we can
conclude that an honest veri(cid:27)er accepts a false statement in this
case with probability at most δ(κ).
false statement with probability at most(cid:16)1 − tr
Applying a union bound, we conclude that the veri(cid:27)er accepts a
(cid:17)tp
n
+ δ(κ).
Zero-knowledge: The zero-knowledge property follows from the
tp-privacy of the underlying MPC protocol Π. Namely, we construct
a simulator S that invokes the simulator for the MPC protocol,
denoted by SΠ. In the simulation SΠ is required to produce the view
of R upon receiving a challenge r and then, upon obtaining the tp
indexes that the veri(cid:27)er requests to open, outputs the views of these
tp servers, where SΠ simulates an adversary A that adaptively
corrupts these servers at the end of the computation.
(cid:3)
Communication complexity: The main source of complexity is
in revealing the view of R in the third message and revealing the
view of the tp servers in the last message. If the maximum size of
the view of each server Pi for i ∈ tp, is vsize, and the size of the
view of R is vR, then the total communication complexity from the
prover is tp · vsize + vR.
We can adjust the parameters of the protocol we use in Section
4 subject to the constraint that vsizevR = O(|C|). To minimize the
communication complexity, if we set tp · vsize and vR to be roughly
equal then we obtain the optimum complexity of our approach.
4 A DIRECT ZKIPCP CONSTRUCTION
In this section we give a self-contained description of our zero-
knowledge interactive PCP protocol. This protocol is a slightly
optimized version of the protocol obtained by applying our variant
of the general “MPC to ZK” transformation from [30] (see Section 3)
to the honest-majority MPC protocol from [16].
Coding notation. For a code C ⊆ Σn and vector v ∈ Σn, denote
by d(v, C) the minimal distance of v from C, namely the number
of positions in which v di(cid:29)ers from the closest codeword in C,
and by ∆(v, C) the set of positions in which v di(cid:29)ers from such a
closest codeword (in case of ties, take the lexicographically (cid:27)rst
closest codeword). We further denote by d(V , C) the minimal dis-
tance between a vector set V and a code C, namely d(V , C) =
minv ∈V {d(v, C)}. Our ZKIPCP protocol uses Reed-Solomon (RS)
codes, de(cid:27)ned next.
Definition 4.1 (Reed-Solomon Code). For positive integers n, k,
(cid:27)nite (cid:27)eld F, and a vector η = (η1, . . . , ηn) ∈ Fn of distinct (cid:27)eld
elements, the code RSF,n,k,η is the [n, k, n − k + 1] linear code over F
that consists of all n-tuples (p(η1), . . . , p(ηn)) where p is a polynomial
of degree  e. Then, for a random w∗ in the row-span of U ∗, we
have
is, for every j ∈ Q we havem
i =1 rj · Ui, j = wj.
Pr[d(w
∗
, L) ≤ e] ≤ (e + 1)/|F|.
∗
Proof: Let L∗ be the row-span of U ∗. We consider two cases.
Case 1: There exists v∗ ∈ L∗ such that d(v∗, L) > 2e. In this case,
we show that
i
w∗∈R L∗[d(w
Pr
, L) ≤ e] ≤ 1/|F|.
(1)
Indeed, using a basis for L∗ that includes v∗, a random w∗ ∈ L∗
can be written as αv∗ + x, where α ∈R F and x is distributed
independently of α. We argue that conditioned on any choice of x,
there can be at most one choice of α such that d(αv∗ + x, L) ≤ e,
which implies (1). This follows by observing that if d(αv∗+x0, L) ≤ e
and d(α(cid:48)v∗ + x0, L) ≤ e for α (cid:44) α(cid:48), then by the triangle inequality
we have d((α − α(cid:48))v∗, L) ≤ 2e, contradicting the assumption that
d(v∗, L) > 2e.
Case 2: For every v∗ ∈ L∗, d(v∗, L) ≤ 2e. We show that in this case
Prw∗∈R L∗[d(w∗, L) ≤ e] ≤ (e + 1)/|F|. Let U ∗
be the i-th row of U ∗
and let Ei = ∆(U ∗
can be
written uniquely as U ∗
= ui + χi where ui ∈ L and χi is nonzero
i =1Ei. Since d(U ∗, Lm) > e, we
i
exactly in its Ei entries. Let E = ∪m
have |E| > e. We show that for each j ∈ E, except with 1/|F|
probability over a random choice of w∗ from L∗, either j ∈ ∆(w∗, L)
or d(w∗, L) > e, from which the claim will follow.
Suppose j ∈ Ei. As before, we write w∗ = αU ∗
+ x for α ∈R F
i
and x distributed independently of α. Condition on any possible
choice x0 of x. De(cid:27)ne a bad set
i , L). Note that, since 2e  4e, for any z∗ in the linear span of z and z(cid:48) we have j (cid:60) ∆(z∗, L).
Since U ∗
i , L), in contradiction
i
to the assumption that j ∈ Ei.
We have shown that for each j ∈ E, conditioned on every possible
choice of x, either j ∈ ∆(w∗, L) or d(w∗, L) > e except with 1/|F|
probability over the choice of α. It follows that the same holds for
a random choice of x. Taking a union bound over the (cid:27)rst e + 1
is in this linear span, we have j (cid:60) ∆(U ∗
i
elements of E we get that Prw∗∈R L∗[d(w∗, L) ≤ e] ≤ (e + 1)/|F| as
required.
(cid:3)
We now prove the soundness of the testing procedure when the
given oracle is far from Lm.
Theorem 4.3. Let e be a positive integer such that e  e. Then, for any malicious P strategy, the oracle
U ∗ is rejected by V except with ≤ (1− e/n)t +(e + 1)/|F| probability.
Proof: Letting w∗ = rT U ∗, it follows from Lemma 4.2 that
∗
∗] ≤ Pr[V accepts | d(w
, L) > e]
∗
+ Pr[d(w
, L) ≤ e]
≤
+ (e + 1)/|F|
≤ (1 − e/n)t + (e + 1)/|F|
(cid:0)n−e−1
(cid:0)n
(cid:1)
Pr[V accepts U
(cid:1)
t
t
as required.
(cid:3)
In Appendix A we present a simple generalization of the testing
algorithm that uses σ linear combinations to amplify soundness.