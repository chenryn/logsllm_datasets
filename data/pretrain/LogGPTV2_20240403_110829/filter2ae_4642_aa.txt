翻译自：  
翻译：聂心明
# 外部文件访问(Android)
漏洞特征：ANDROID_EXTERNAL_FILE_ACCESS  
应用经常往外部存储上写数据（可能是SD卡），这个操作可能会有多个安全问题。首先应用可以可以通过[READ_EXTERNAL_STORAGE](http://developer.android.com/reference/android/Manifest.permission.html#READ_EXTERNAL_STORAGE)
获取SD卡上存储的文件。而且如果数据中包含用户的敏感信息的话，那么需要把这些数据加密。  
有漏洞的代码：
    file file = new File(getExternalFilesDir(TARGET_TYPE), filename);
    fos = new FileOutputStream(file);
    fos.write(confidentialData.getBytes());
    fos.flush();
更好的措施：
    fos = openFileOutput(filename, Context.MODE_PRIVATE);
    fos.write(string.getBytes());
引用：  
[Android Official Doc: Security
Tips](http://developer.android.com/training/articles/security-tips.html#ExternalStorage)  
[CERT: DRD00-J: Do not store sensitive information on external
storage](https://www.securecoding.cert.org/confluence/display/java/DRD00-J.+Do+not+store+sensitive+information+on+external+storage+%28SD+card%29+unless+encrypted+first)  
[Android Official Doc: Using the External
Storage](http://developer.android.com/guide/topics/data/data-storage.html#filesExternal)  
[OWASP Mobile Top 10 2014-M2: Insecure Data
Storage](https://www.owasp.org/index.php/Mobile_Top_10_2014-M2)  
[CWE-312: Cleartext Storage of Sensitive
Information](https://cwe.mitre.org/data/definitions/312.html)
# Broadcast漏洞(Android)
漏洞规则：ANDROID_BROADCAST  
所有应用通过申请适当权限就可以监听Broadcast的意图，所以尽量不要通过Broadcast传输敏感数据。  
有漏洞的代码：
    Intent i = new Intent();
    i.setAction("com.insecure.action.UserConnected");
    i.putExtra("username", user);
    i.putExtra("email", email);
    i.putExtra("session", newSessionId);
    this.sendBroadcast(v1);
解决方案（如果有可能的话）：
    Intent i = new Intent();
    i.setAction("com.secure.action.UserConnected");
    sendBroadcast(v1);
配置（接收者）
        ...
配置（发送者）
引用：  
[CERT: DRD03-J. Do not broadcast sensitive information using an implicit
intent](https://www.securecoding.cert.org/confluence/display/java/DRD03-J.+Do+not+broadcast+sensitive+information+using+an+implicit+intent)  
[Android Official Doc: BroadcastReceiver
(Security)](http://developer.android.com/reference/android/content/BroadcastReceiver.html#Security)  
[Android Official Doc: Receiver configuration (see
android:permission)](http://developer.android.com/guide/topics/manifest/receiver-element.html)  
[1] [StackOverflow: How to set permissions in broadcast sender and receiver in
android](http://stackoverflow.com/a/21513368/89769)  
[CWE-925: Improper Verification of Intent by Broadcast
Receiver](https://cwe.mitre.org/data/definitions/925.html)  
[CWE-927: Use of Implicit Intent for Sensitive
Communication](https://cwe.mitre.org/data/definitions/927.html)
# 任意文件写 (Android)
创建文件使用MODE_WORLD_READABLE模式，可以让文件写入环境中的任意位置。一些文件文件被改写的话，可能会发生一些不希望发生的事情。  
有漏洞代码：
    fos = openFileOutput(filename, MODE_WORLD_READABLE);
    fos.write(userInfo.getBytes());
解决方案（使用MODE_PRIVATE）：
    fos = openFileOutput(filename, MODE_PRIVATE);
解决方案（使用本地SQLite数据库）  
使用本地SQLite数据库可能是存储结构数据最好的解决方案了。要确定数据库文件不会被创建到外部存储中。见下面的开发文档引用
引用：  
[CERT: DRD11-J. Ensure that sensitive data is kept
secure](https://www.securecoding.cert.org/confluence/display/java/DRD11-J.+Ensure+that+sensitive+data+is+kept+secure)  
[Android Official Doc: Security
Tips](http://developer.android.com/training/articles/security-tips.html#InternalStorage)  
[Android Official Doc:
Context.MODE_PRIVATE](http://developer.android.com/reference/android/content/Context.html#MODE_PRIVATE)  
[vogella.com: Android SQLite database and content provider -Tutorial](http://www.vogella.com/tutorials/AndroidSQLite/article.html#databasetutorial_database)  
[OWASP Mobile Top 10 2014-M2: Insecure Data
Storage](https://www.owasp.org/index.php/Mobile_Top_10_2014-M2)  
[CWE-312: Cleartext Storage of Sensitive
Information](https://cwe.mitre.org/data/definitions/312.html)
# 已激活地理位置的WebView(Android)
漏洞特征：ANDROID_GEOLOCATION  
建议去询问用户是否能获取他们的位置信息  
漏洞代码：
    webView.setWebChromeClient(new WebChromeClient() {
        @Override
        public void onGeolocationPermissionsShowPrompt(String origin, GeolocationPermissions.Callback callback) {
            callback.invoke(origin, true, false);
        }
    });
建议代码：  
限制使用地理位置的例子，并且要得到用户的确认
    webView.setWebChromeClient(new WebChromeClient() {
        @Override
        public void onGeolocationPermissionsShowPrompt(String origin, GeolocationPermissions.Callback callback) {
            callback.invoke(origin, true, false);
            //Ask the user for confirmation
        }
    });
引用：  
[CERT: DRD15-J. Consider privacy concerns when using Geolocation
API](https://www.securecoding.cert.org/confluence/display/java/DRD15-J.+Consider+privacy+concerns+when+using+Geolocation+API)  
[Wikipedia: W3C Geolocation
API](http://en.wikipedia.org/wiki/W3C_Geolocation_API)  
[W3C: Geolocation Specification](http://dev.w3.org/geo/api/spec-source.html)
# 允许JavaScript脚本运行的webview (Android)
漏洞特征：ANDROID_WEB_VIEW_JAVASCRIPT  
WebView如果允许允许JavaScript脚本的话，就意味着它会受到xss的影响。应该检查页面的渲染，以避免潜在的反射型xss，存储型xss，dom型xss。
    WebView myWebView = (WebView) findViewById(R.id.webView);
    WebSettings webSettings = myWebView.getSettings();
    webSettings.setJavaScriptEnabled(true);
有漏洞的代码：  
允许JavaScript运行是一个坏的习惯。这就意味着后端代码需要被审计，以避免xss。xss也会使用dom xss的形式引入到客户端。
    function updateDescription(newDescription) {
        $("#userDescription").html(""+newDescription+"");
    }
引用：  
[Issue: Using setJavaScriptEnabled can introduce XSS
vulnerabilities](http://www.technotalkative.com/issue-using-setjavascriptenabled-can-introduce-xss-vulnerabilities-application-review-carefully/)  
[Android Official Doc:
WebView](http://developer.android.com/guide/webapps/webview.html#UsingJavaScript)  
[WASC-8: Cross Site
Scripting](http://projects.webappsec.org/w/page/13246920/Cross%20Site%20Scripting)  
[OWASP: XSS Prevention Cheat
Sheet](https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet)  
[OWASP: Top 10 2013-A3: Cross-Site Scripting
(XSS)](https://www.owasp.org/index.php/Top_10_2013-A3-Cross-Site_Scripting_%28XSS%29)  
[CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](http://cwe.mitre.org/data/definitions/79.html)
# 带有JavaScript接口的WebView (Android)
漏洞特征:ANDROID_WEB_VIEW_JAVASCRIPT_INTERFACE  
使用JavaScript接口可能会将WebView暴露给有危害的api。如果在WebView中触发xss的话，恶意的JavaScript代码会钓鱼一些敏感的类。  
有漏洞代码：
    WebView myWebView = (WebView) findViewById(R.id.webView);
    myWebView.addJavascriptInterface(new FileWriteUtil(this), "fileWriteUtil");
    WebSettings webSettings = myWebView.getSettings();
    webSettings.setJavaScriptEnabled(true);
    [...]
    class FileWriteUtil {
        Context mContext;
        FileOpenUtil(Context c) {
            mContext = c;
        }
        public void writeToFile(String data, String filename, String tag) {
            [...]
        }
    }
引用：  
[Android Official Doc:
WebView.addJavascriptInterface()](http://developer.android.com/reference/android/webkit/WebView.html#addJavascriptInterface%28java.lang.Object,%20java.lang.String%29)  
[CWE-749: Exposed Dangerous Method or
Function](https://cwe.mitre.org/data/definitions/749.html)
# 没有用secure标志的cookie
漏洞特征：INSECURE_COOKIE  
一个新的cookie的创建应该设置Secure标志。Secure标志命令浏览器确保cookie不会通过不安全的链路发送(http://)  
有漏洞的代码：
    Cookie cookie = new Cookie("userName",userName);
    response.addCookie(cookie);
解决方案（特殊的设置):
    Cookie cookie = new Cookie("userName",userName);
    cookie.setSecure(true); // Secure flag
    cookie.setHttpOnly(true);
解决方案（Servlet 3.0 配置）
    [...]
      true
      true
引用：  
[CWE-614: Sensitive Cookie in HTTPS Session Without 'Secure'
Attribute](https://cwe.mitre.org/data/definitions/614.html)  
[CWE-315: Cleartext Storage of Sensitive Information in a
Cookie](https://cwe.mitre.org/data/definitions/315.html)  
[CWE-311: Missing Encryption of Sensitive