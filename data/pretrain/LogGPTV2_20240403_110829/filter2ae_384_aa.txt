**作者：灵巧@蚂蚁安全实验室**  
**原文链接：**
同济大学教授史扬：
拜占庭将军问题的研究始于1982年，由LeslieLamport等学者提出。它以古代拜占庭帝国的将军们围攻城市为背景，讲述了一个关于忠诚与背叛的故事，并且巧妙的蕴含了现代分布式系统的一致性问题。正是由于在分布式和并行系统的理论与实践方面的巨大成就，
Lamport在2013年成为图灵奖得主。
拜占庭容错（BFT）则给出了存在“叛徒”时解决拜占庭问题的方法，它不仅仅在许可链中受到高度的重视，在公有链中也有广泛的应用，例如由另一位图灵奖得主Sivio
Micali 等设计的Algorand 这一PoS机制中，相关技术也被反复的使用。
蚂蚁安全实验室的这篇分享首先介绍了BFT的基本概念，随后以Fabric和DPoS协议等为例介绍了BFT在区块链中的应用；在此基础上，对BFT协议的威胁模型展开探讨，分别分析了理想世界和现实世界的威胁模型，以及在BFT协议被攻破后，对区块链安全会有哪些影响。文章内容丰富，叙述详尽，可以供研究和开发区块链系统的读者们参考，相信会对分析甚至是提高区块链系统的安全性有所裨益。
关于区块链安全，特别是智能合约的安全性方面，蚂蚁安全实验室还发表了一系列颇有价值的文章。希望蚂蚁安全实验室可以继续为提高区块链系统与应用的安全性做出的贡献，也非常感谢他们的分享。
# 01 引 言
共识算法是区块链的核心基石，是区块链系统安全性的重要保障。区块链的共识算法中，除了常见的工作量证明（PoW，Proof of
Work）和权益证明（PoS，Proof of Stake）外，还有拜占庭容错（Byzantine Fault Tolerance,
BFT）共识算法。拜占庭容错（Byzantine Fault Tolerance, BFT）共识算法是由拜占庭将军问题衍生出来的共识算法。
拜占庭将军问题（Byzantine Generals Problem），首先由 Leslie Lamport
与另外两人在1982年提出。故事大概是这么说的：
一组拜占庭将军分别各率领一支军队共同围困一座城市。为了简化问题，将各支军队的行动策略限定为进攻或撤离两种。因为部分军队进攻、部分军队撤离可能会造成灾难性后果，因此各位将军必须通过投票来达成一致策略，即所有军队一起进攻或所有军队一起撤离。因为各位将军分处城市不同方向，他们只能通过信使互相联系。在投票过程中每位将军都将自己投票给进攻还是撤退的信息通过信使分别通知其他所有将军，这样一来每位将军根据自己的投票和其他所有将军送来的信息就可以知道共同的投票结果而决定行动策略。
这就是拜占庭将军问题。解决拜占庭将军问题的协议称为拜占庭将军协议，也称拜占庭容错协议 Byzantine Fault Tolerance，简称 BFT
协议。
Byzantine错误，或者称为任意错误，指实体(服务器或者客户端)被攻击者完全控制，攻击者可以根据自己的意愿和环境情况执行各种操作。当实体发生Byzantine错误时，行为是不可预测的，常见的可能行为包括:
●停机，错误实体不响应其他服务器和客户端所发送的信息；
●发送正确或错误的消息，造成网络拥塞，使得其它正确的服务器和客户端不能正常地接收、发送和处理信息；
●篡改和转发消息，使得频繁地出现操作冲突，降低系统性能。
BFT 协议讨论的是允许存在少数节点发生 Byzantine 错误的场景下如何达成共识的问题。BFT
协议最主要的目的是保证运行协议的各服务节点保持状态一致，即：
●相同的处理逻辑。通常，各服务器运行相同代码。
●相同的初始状态。在系统初始化时，配置为相同的初始状态。
●执行相同的操作序列。各服务器按照一致顺序处理客户端的多个请求消息，保证状态变化的一致性。
BFT
协议早在区块链提出之前，就在一些行业被广泛应用，如航空、航天、核电行业。这些行业和区块链账本一样，对稳定性和一致性的要求非常之高，要求即使一些节点发生了
Byzantine 错误，也要保证系统稳定和一致地运行下去。这在区块链上就表现为链不停摆、不分叉。
BFT
协议对编程语言没有要求，只要能够实现协议算法，满足实现过程中没有漏洞，可以使用任何编程语言。但是在实际的实现和运行过程中，很难做到没有漏洞，现实世界中
BFT 协议面临多种威胁。当 BFT协议作为区块链的共识算法时，攻击 BFT 会对区块链产生怎样的影响呢？
本文共分为上下两集：上集第 2 节介绍了BFT协议在区块链的应用，我们选取了有代表性的应用案例。下集第 1
节分析BFT协议的威胁模型，分别分析了理想世界和现实世界的威胁模型。第 2 节分析了BFT协议被攻破后，对区块链安全会有哪些影响。第 3 节做了简要总结。
# 02 BFT 协议在区块链的应用
## 2.1 PBFT -- Fabric 共识协议
PBFT 是第一个性能能满足实用要求的协议，也是后续众多变种协议主要的参考对象。PBFT 由 n=3f + 1 台服务器组成，最多容忍 f 台
Byzantine 错误服务器，算法复杂度为O(N²)。由于随着节点的增加，PBFT 的性能会显著下降，所以 PBFT 更多的是应用在联盟链中，如
Fabric。
在正常情况下，PBFT 使用如下通信过程协商请求消息的操作顺序 。由特定的、负责确定顺序的服务器（称为 Primary 图中的 0）发起操作 。当
Primary 收到客户端的请求消息后，确定相应的顺序，转发给其它服务器，通过 2 步通信（Pre-prepare 和 Prepare）保证至少 f+1
台正确服务器就客户端请求的执行顺序达成一致，然后再经 1 步 Commit 通信通知各服务器。
图中 c 表示客户端，0 表示主节点，1表示副本节点1，2表示副本节点2，3表示副本节点3，类似的，i 表示副本节点i
  * 1.REQUEST：
客户端c向主节点p发送``请求。o: 请求的具体操作，t: 请求时客户端追加的时间戳，c：客户端标识。REQUEST:
包含消息内容m，以及消息摘要d(m)。客户端对请求进行签名。
  * 2.PRE-PREPARE：
主节点收到客户端的请求，需要进行以下交验：
a. 客户端请求消息签名是否正确。
非法请求丢弃。正确请求，分配一个编号n，编号n主要用于对客户端的请求进行排序。然后广播一条``,
m>消息给其他副本节点。v：视图编号，d：客户端消息摘要，m：消息内容。``进行主节点签名。n是要在某一个范围区间内的[h, H]，具体原因参见垃圾回收部分。
  * 3.PREPARE：
副本节点i收到主节点的PRE-PREPARE消息，需要进行以下交验：
a. 主节点PRE-PREPARE消息签名是否正确。
b. 当前副本节点是否已经收到了一条在同一v下并且编号也是n，但是签名不同的PRE-PREPARE信息。
c. d与m的摘要是否一致。
d. n是否在区间[h, H]内。
非法请求丢弃。正确请求，副本节点i向其他节点包括主节点发送一条``消息, v, n, d 与上述 PRE-PREPARE消息内容相同，i是当前副本节点编号。``进行副本节点i的签名。记录PRE-PREPARE和PREPARE消息到log中，用于View Change过程中恢复未完成的请求操作。
  * 4.COMMIT：
主节点和副本节点收到PREPARE消息，需要进行以下交验：
a. 副本节点PREPARE消息签名是否正确。
b. 当前副本节点是否已经收到了同一视图v下的n。
c. n是否在区间[h, H]内。
d. d是否和当前已收到PRE-PPREPARE中的d相同。
非法请求丢弃。如果副本节点i收到了2f+1个验证通过的PREPARE消息，则向其他节点包括主节点发送一条``消息，v, n, d, i与上述PREPARE消息内容相同。``进行副本节点i的签名。记录COMMIT消息到日志中，用于View
Change过程中恢复未完成的请求操作。记录其他副本节点发送的PREPARE消息到log中。