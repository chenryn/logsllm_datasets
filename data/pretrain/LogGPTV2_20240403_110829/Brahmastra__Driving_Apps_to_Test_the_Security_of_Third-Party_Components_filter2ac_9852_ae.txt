reduce duplicate exploration. It shows that these heuris-
tics are helpful although the coverage is still around 33%.
SmartDroid [31] uses a combination of static and dy-
namic analysis to ﬁnd the UI elements linked to sensitive
APIs. However, unlike Brahmastra, SmartDroid explores
every UI element at runtime to ﬁnd the right view to
click. A3E [14] also uses static analysis to ﬁnd an activ-
ity transition graph and uses the graph to efﬁciently ex-
plore apps. We leveraged the proposed technique when
building an execution path. However, similarly to the
tools listed above, A3E again uses runtime GUI explo-
ration to navigate through activities. In contrast to these
works, Brahmastra determines an execution path using
static analysis and rewrites an app to trigger a planned
navigation, bypassing known difﬁculties related to GUI
exploration.
Security analysis of in-app ads: Probably because only
recently COPPA [6] had been updated to include mo-
bile apps5, we are not aware of any prior work looking
into the issues around COPPA compliance of advertise-
ments (and the corresponding landing pages) displayed
within apps directed at children. However, several past
works investigated security and privacy issues with re-
spect to Android advertising libraries. AdRisk [22] is a
static analysis tool to examine advertising libraries inte-
grated with Android apps. They report that many ad li-
braries excessively collect privacy-sensitive information
and expose some of the collected information to adver-
tisers. Stevens et al. examine thirteen popular Android
ad libraries and show the prevalent use of tracking iden-
tiﬁers and the collection of private user information [28].
Worse, through a longitudinal study, Book et al. show
that the use of permissions by Android ad libraries has
increased over the past years [18].
Analyzing logic ﬂaws in web services and SDKs: The
authentication vulnerability discussed in §8 falls into the
category of logic ﬂaws in web programming. Recent pa-
pers have proposed several technologies for testing var-
ious types of logic ﬂaws [16, 17, 21]. However, these
techniques mainly target logic ﬂaws in two-party web
programs, i.e., programs consisting of a client and a
server. Logic ﬂaws become more complicated and in-
triguing in multi-party web programs, in which a client
communicating with multiple servers to accomplish a
task, such as the Facebook-based authentication that we
focus in this paper. AuthScan is a recently developed
technique to automatically extract protocol speciﬁcations
from concrete website implementations, and thus dis-
cover new vulnerabilities in the websites [15]. In con-
trast, our goal is not to discover any new vulnerability on
a website, but to scale up the testing of a known vulnera-
bility to a large number of apps.
5The revision was published on July 2013.
10 Discussion
Limitations: Although Brahmastra improves test hit
rates over Monkey-like tools, we discover several id-
iosyncratic behaviors of mobile apps that challenge run-
time testing. Some apps check servers upon launching
and force upgrading if newer versions exist. Some apps
constantly load content from remote servers, showing
transient behaviors (e.g., extremely slow at times). We
also have yet to implement adding callbacks related to
sensor inputs. Another challenge is to isolate dependent
components in the code. We assume that each activity is
more or less independent (except that they pass parame-
ters along with intent) and use our jump start technique
to bypass blocking pages and to speed up testing. How-
ever, we leave as future work a task to statically deter-
mine dependent activities to ﬁnd activities to jump-start
to without affecting the program behavior.
Other runtime security testing of mobile apps: As
mobile apps are highly driven by user interaction with
visual components in the program, it is important to an-
alyze the code behavior in conjunction with runtime UI
states. For instance, malicious third-party components
can trick users into authorizing the components to access
content (e.g., photos) that the users intended to share with
the application. Brahmastra can be used to capture visual
elements when certain APIs are invoked to check against
such click jacking attempts. Brahmastra can also auto-
mate the testing to check whether privacy-sensitive APIs
are only invoked with explicit user interactions.
11 Conclusion
We have presented a mobile app automation tool, Brah-
mastra, that app store operators and security researchers
can use to test third-party components at runtime as they
are used by real applications. To overcome the known
shortcomings of GUI exploration techniques, we analyze
application structure to discover desired execution paths.
Then we re-write test apps to follow a short path that in-
vokes the target third-party component. We ﬁnd that we
can more than double the test hit rate while speeding up
testing by a factor of seven compared to a state-of-the-art
Monkey tool.
We use Brahmastra for two case studies, each of which
contributes new results: checking if third-party ad com-
ponents in kids apps are compliant with child-safety reg-
ulations; and checking whether apps that use Facebook
Login are vulnerable to a known security ﬂaw. Among
the kids apps, we discover 36% of 220 kids apps dis-
play ads deemed inappropriate for children, and 80% of
the apps display ads that point to landing pages which
attempt to collect personal information without parental
consent. Among the apps that use Facebook Login, we
ﬁnd that 13 applications are still vulnerable to the Face-
USENIX Association  
23rd USENIX Security Symposium  1033
book access token attack even though the attack has been
known for almost a year. Brahmastra let us quickly check
the behavior of hundreds of apps for these studies, and
it can easily be used for other studies in the future—
checking whether privacy-sensitive APIs can be invoked
without explicit user interaction, discovering visible UI
elements implicated in click jacking attempts, and more.
Acknowledgments
This material is based on research sponsored in part by
DARPA under agreement number FA8750-12-2-0107,
NSF CCF-1139021, and University of Maryland Part-
nership with the Laboratory of Telecommunications Sci-
ences, Contract Number H9823013D00560002. The
U.S. Government is authorized to reproduce and dis-
tribute reprints for Governmental purposes notwithstand-
ing any copyright notation thereon.
References
[1] A tool for reverse engineering Android apk ﬁles.
http://code.google.com/p/android-
apktool/.
[2] Activity — Android Developers.
http:
//developer.android.com/reference/
android/app/Activity.html.
[3] Amazon Mechanical Turk.
mturk.com.
https://www.
[4] Android Debug Bridge. http://developer.
android.com/tools/help/adb.html.
[5] Android
Developers,
UI/Application
The
Developer’s
Exerciser Monkey.
Guide.
http://developer.android.com/
tools/help/monkey.html.
[6] Complying with COPPA: Frequently Asked
http://business.ftc.gov/
Questions.
documents/Complying-with-COPPA-
Frequently-Asked-Questions.
[7] Dexpler: A Dalvik to Soot Jimple Translator.
http://www.abartel.net/dexpler/.
[8] Fiddler.
fiddler.
http://www.telerik.com/
[9] Web of Trust. https://www.mywot.com/.
[10] Self-Regulatory Program for Childrens Ad-
http://www.caru.org/
vertising, 2009.
guidelines/guidelines.pdf.
[11] AppBrain,
Feb.
2014.
http://www.
appbrain.com/stats/libraries/ad.
[12] A. V. Aho, R. Sethi, and J. D. Ullman. Compilers:
Principles, Techniques and Tools. Addison-Wesley,
1986.
[13] D. Amalﬁtano, A. R. Fasolino, S. D. Carmine,
A. Memon, and P. Tramontana. Using GUI Ripping
for Automated Testing of Android Applications. In
Proceedings of the IEEE Conference on Automated
Software Engineering (ASE), 2012.
[14] T. Azim and I. Neamtiu. Targeted and depth-ﬁrst
exploration for systematic testing of android apps.
In OOPSLA, 2013.
[15] G. Bai, J. Lei, G. Meng, S. S. V. P. Saxena, J. Sun,
Y. Liu, and J. S. Dong. Authscan: Automatic ex-
traction of web authentication protocols from im-
plementations. In NDSS, 2013.
[16] P. Bisht, T. Hinrichs, N. Skrupsky, R. Bobrowicz,
and V. N. Venkatakrishnan. Notamper: Automati-
cally detecting parameter tampering vulnerabilities
in web applications. In CCS, 2010.
[17] P. Bisht, T. Hinrichs, N. Skrupsky, and V. N.
Venkatakrishnan. Waptec: Whitebox analysis of
web applications for parameter tampering exploit
construction. In CCS, 2011.
[18] T. Book, A. Pridgen, and D. S. Wallach. Longitu-
dinal analysis of android ad library permissions. In
IEEE Mobile Security Technologies (MoST), 2013.
[19] J. Dean, D. Grove, and C. Chambers. Optimization
of Object-Oriented Programs Using Static Class
Hierarchy Analysis. In Proceedings of the 9th Eu-
ropean Conference on Object-Oriented Program-
ming, pages 77–101, 1995.
[20] M. Egele, D. Brumley, Y. Fratantonio,
and
C. Kruegel. An Empirical Study of Cryptographic
Misuse in Android Applications. In CCS, 2013.
[21] V. Felmetsger, L. Cavedon, C. Kruegel, and G. Vi-
gna. Toward automated detection of logic vulner-
abilities in web applications. In USENIX Security,
2010.
[22] M. Grace, W. Zhou, X. Jiang, and A.-R. Sadeghi.
Unsafe Exposure Analysis of Mobile In-App Ad-
vertisements. In WiSec, 2012.
[23] S. Hao, B. Liu, S. Nath, W. G. Halfond,
and R. Govindan.
PUMA: Programmable UI-
Automation for Large Scale Dynamic Analysis of
Mobile Apps. In Mobisys, 2014.
1034  23rd USENIX Security Symposium 
USENIX Association
[24] J. Jeon, K. K. Micinski, J. A. Vaughan, A. Fogel,
N. Reddy, J. S. Foster, and T. Millstein. Dr. Android
and Mr. Hide: Fine-grained Permissions in Android
Applications. In ACM CCS Workshop on Security
and Privacy in Smartphones and Mobile Devices,
2012.
[25] B. Liu, S. Nath, R. Govindan, and J. Liu. DECAF:
Detecting and Characterizing Ad Fraud in Mobile
Apps. In USENIX NSDI, 2014.
[26] V. Rastogi, Y. Chen, and W. Enck. Appsplay-
ground: Automatic security analysis of smartphone
applications. In Proceedings of the ACM Confer-
ence on Data and Application Security and Pri-
vacy, 2013.
[27] L. Ravindranath, S. Nath, J. Padhye, and H. Balakr-
ishnan. Automatic and Scalable Fault Detection for
Mobile Applications. In Mobisys, 2014.
[28] R. Stevens, C. Gibler, J. Crussell, J. Erickson, and
H. Chen. Investigating user privacy in android ad
libraries.
In IEEE Mobile Security Technologies
(MoST), 2012.
[29] R. Valle-Rai, P. Co, E. Gagnon, L. J. Hendren,
P. Lam, and V. Sundaresan. Soot - a Java byte-
code optimization framework.
In IBM Centre for
Advanced Studies Conference, 1999.
[30] R. Wang, Y. Zhou, S. Chen, S. Qadeer, D. Evans,
and Y. Gurevich. Explicating SDKs: Uncover-
ing Assumptions Underlying Secure Authentica-
tion and Authorization. In USENIX Security, 2013.
[31] C. Zheng, S. Zhu, S. Dai, G. Gu, X. Gong, X. Han,
and W. Zou. Smartdroid: an automatic system for
revealing ui-based trigger conditions in android ap-
plications. In ACM CCS Workshop on Security and
Privacy in Smartphones and Mobile Devices, 2012.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
A Constant Propagation Analysis
We extend the existing constant propagation analysis so
as to trace intents, UI elements, and listeners. In ad-
dition to traditional value types, such as numerical or
string constant, we add meta-class, object, and intent
sorts, which track class ids, object references, and in-
tent instances, respectively. For instructions that create
objects; load class ids; or invoke special APIs such as
Intent.setClass(), we add their semantics into the data-
ﬂow transfer function.
Figure 12 illustrates how we extend data-ﬂow lattice;
how we conform to meet operation property; and how we
deﬁne semantics of relevant instructions.
for a speciﬁc component ∗)
i1 ,
Intent
Intent
...
transfer
(inn :
l2 with ...
Intent of string (∗ Intent
...
type lattice = ...
| Clazz of string (∗ const−class ∗)
| Object of string (∗ instance ∗)
|
|
let meet l1 l2 = match l1 ,
| Clazz c1, Clazz c2 when 0 = compare c1 c2 → l1
| Object o1, Object o2 when 0 = compare o1 o2 → l1
i2 when 0 = compare i1 i2 → l1
|
|
let
else if OP NEW = op then (∗ NEW ∗)
(
let dst :: id ::[] = opr in
let cname = Dex.get ty name id in
if 0 = compare cname ‘‘ Intent ’’
then Map.add dst ( Intent
inn
‘‘’’)
else Map.add dst (Object cname) inn
...
lattice Map.t) (op, opr) = ...
)
Figure 12: Abbreviated source code of extended constant
propagation analysis. Meta-class, object, and intent sorts
maintain information as string, and they can be merged
only if internal values are identical, hence must-analysis.
As an example, this shows how to handle opcode NEW.
USENIX Association  
23rd USENIX Security Symposium  1035
B Examples of Ads in Kids Apps
(b)
(c)
(d)
(e) clicking 
the banner ad
A1
(a)
Figure 13: a) and (b) offer a free prize and (c) and (d) are sexually suggestive. (e) shows an example where clicking a
banner ad displayed in a kids app opens up a landing page that presents forms to collect personal information.
Figure 14: A screenshot of the Amazon Mechanical Turk task that we created to characterize landing pages pointed
by ads displayed in kids apps
1036  23rd USENIX Security Symposium 
USENIX Association