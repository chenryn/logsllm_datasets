of lower rank than pb in that view. Upon receiving 2f + 1
Ack-New-View messages for a New-View message, a correct
process changes its state to WAITING-PHASE2. If it is a
non-leader, it starts a timer, and expects the leader to take
action before the timer expires. If it is a correct leader, it
broadcasts a signed Commit message. A valid Commit mes-
sage contains the same view speciﬁed in the New-View mes-
sage and includes the 2f + 1 Ack-New-Views as proof that
the majority of the correct processes have acknowledged its
New-View message.
When a valid Commit message is received, a correct
It then broadcasts
process changes its state to PHASE2.
a signed Ready-to-Switch message.
It also starts a timer,
and expects a Ready-to-Switch message from each member
of the new view before the timer expires. When Ready-
to-Switch messages have been received from all members
of the new view, a correct process changes its state to
PHASE3. The members of the current view that are also
members of the next view then begin to form a consensus
on which messages have been delivered by each of them
up to this point. This is the message stabilization phase;
it is needed to ensure that all correct processes deliver the
same set of messages broadcast in the current view. After
that phase, each correct process that is a member of the new
view installs a new protocol stack initialized to the NOR-
MAL state. Each of the three phases of the view installation
has timers to ensure liveness. If a timer expires before the
corresponding action expected from a process is observed,
then a Suspect message is sent for the process.
2.4.2 View Installation when Multiple Faults Occur
An enhanced algorithm is used to remove the earlier as-
sumption that no additional faults occur during a view in-
stallation. An additional fault has occurred during a view
installation if f + 1 Suspect messages have been received
for a member that is not among those processes being re-
moved by the current view installation.
Consider a case in which an additional fault occurred
during the view installation when a correct process pk had
not yet reached the state PHASE2. When pk receives a
Commit message from the leader, it changes its state to
PHASE2, as described in the previous subsection. How-
ever, this time, it broadcasts a signed Need-More-Change
message (instead of a Ready-to-Switch message, as de-
scribed before) indicating that the proposed new view spec-
iﬁed in the last New-View message does not exclude all
known corrupt members. A valid Need-More-Change mes-
sage points out the other corrupt members that need to be
excluded, and provides justiﬁcation in the form of the f + 1
Suspect messages received for each of the other corrupt
members. After sending this Need-More-Change message,
pk starts a timer, and expects a Ready-to-Switch message or
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:28:00 UTC from IEEE Xplore.  Restrictions apply. 
Bring up New Stack
Broadcast
Suspect message
Leader
Broadcasts
New−View message
Broadcast
Ack−New−View
message
Leader
Broadcasts
Commit message
Broadcast
Ready−to−Switch(or)
Need−More−Change
NORMAL
I Suspect
someone
PHASE0
received
f + 1 Suspect
 WAITING
PHASE1
received
New−View
PHASE1
received
2f + 1
WAITING
PHASE2
received
Commit
PHASE2
Ack−New−View
Ready−to−Switch
received from
all proper
processes
Stabilize
Broadcast
Messages
PHASE3
Timeout/Bad New−View:
Sent Suspect for Leader &
got     Suspects for Leader
f
Timeout/Bad Commit:
Sent Suspect for Leader &
got     Suspects for Leader
f
Timeout:
Sent Suspect & got     Suspects for a process
Need−More−Change received
f
(or)
Problems in stabilization:
Sent Suspect & got     Suspects for a process
f
Figure 1. Finite state automaton for view installation
a Need-More-Change message from each of the members
of the view proposed by the last New-View message, ex-
cept the corrupt ones, before timer expiry. After receiving
those Ready-to-Switch or Need-More-Change messages, pk
changes its state to WAITING-PHASE1 (as shown in Fig-
ure 1). pk then starts a timer and waits for another New-
View message from the leader, excluding at least one more
known corrupt member from the next view than it did in
the last New-View message. The last New-View message
received did not result in the installation of a new protocol
stack. That New-View message and the corresponding Com-
mit message (if it was broadcast) are part of what we call a
transitional view. If the additional fault was at the leader,
then a Commit message from the corrupt leader may never
be received. If it is not received, then the deputy takes over
as the new leader, changes its state to WAITING-PHASE1,
and broadcasts a New-View message (as shown in Figure 1).
Other correct processes change their states to WAITING-
PHASE1, start timers, and wait for the New-View message
from the new leader.
If the additional fault occurs when pk is in state PHASE2
or PHASE3 (i.e., after it has responded with a Ready-to-
Switch message), then it reverts back to the state WAITING-
PHASE1. That is shown in Figure 1 by the reverse tran-
sitions from the states PHASE2 and PHASE3 to the state
WAITING-PHASE1. Then, if pk is a leader, it broadcasts
a New-View message that excludes at least one more known
corrupt member from the next view than the last New-View
message did; if pk is a non-leader, it starts a timer and ex-
pects to receive a New-View message from the leader before
the expiration of the timer.
After pk moves to WAITING-PHASE1, the view instal-
lation follows the procedure outlined in 2.4.1, with a cor-
rect process changing state to PHASE1 upon receipt of the
new New-View message, and so on. Should f + 1 Sus-
pects for another process, pj, be received after this latest
New-View message is received, then the New-View message
will become part of another transitional view, and a Need-
More-Change message will be broadcast as the response to
the Commit message in this transitional view. That would
trigger the broadcast of another New-View message, exclud-
ing pj and the processes excluded by the last New-View
message. This cycle of transitional views, in which a pro-
cess keeps changing its state back to WAITING-PHASE1,
would continue until a New-View message ﬁnally excludes
all known corrupt members and all three phases of the view
installation are completed, thus bringing up a new protocol
stack.
3 Performance Measurement
In this section, we quantify the cost of the reliable multi-
cast, total order, and group membership protocols described
in the previous section. The reliable multicast and group
membership protocols frequently use digital signatures to
verify the authenticity of messages received. One of the
changes we had to make to the C-Ensemble infrastructure
was the addition of cryptographic support. We used Peter
Gutmann’s Cryptlib [14] as the core cryptographic library,
and wrote wrapper functions around it.
The tests were carried out on a testbed of ten 1GHz Pen-
tium III computers with 256MB PC133 RAM. The com-
puters were connected by a full-duplex 100 Mbps switched
Ethernet network. The machines were otherwise unloaded,
and, unless speciﬁed otherwise, a single process ran on each
machine. The time measurements were taken in units of
clock cycles, using an assembly-level instruction provided
by the Pentium instruction set. These measurements were
converted into milliseconds for presentation.
3.1 Results for Message Delivery
To measure the different costs associated with the mes-
sage delivery protocols, we devised an application in which
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:28:00 UTC from IEEE Xplore.  Restrictions apply. 
the processes are started and wait for the group size to reach
group size before beginning to transmit messages. Each
process then records the start time and sends num init casts
initial multicasts to all members. After that burst, another
multicast is sent out every time the process receives the
number of messages indicated by group size. RSA cryp-
tography with keys of size key size is used. The end time is
noted when the process has received 10 × group size mes-
sages, and the elapsed time is calculated and written to a
ﬁle. The values of group size, num init casts, and key size
are command-line arguments to the processes.
The results reported here were obtained from 10 inde-
pendent runs; each run collected data for varying parameter
values. The same application was run on top of four differ-
ent protocol stacks:
mnak-no total: This stack has no total-ordering protocol,
and the reliable delivery property is provided by the
mnak protocol from C-Ensemble [13], which tolerates
only crash faults. This stack does not use cryptogra-
phy.
reliable-no total-dummy crypt: This stack includes the
intrusion-tolerant reliable delivery protocol, but has a
dummy version of the cryptography library that returns
from cryptographic function calls immediately without
performing the actual cryptographic operations.
reliable-no total: This stack includes the reliable deliv-
ery protocol (with normal cryptography functions), but
does not provide total-ordering guarantees.
reliable-total: This is the complete stack with both reli-
able delivery (with normal cryptographic functions)
and total-ordering protocols.
For each stack conﬁguration, a run varied the group size
from 4 to 11, and if the stack used cryptography, key sizes
of 512, 768, and 1024 were used.
The stack conﬁgurations were chosen so that we would
be able to compare the individual costs of various fac-
tors.
Comparing the message delivery times for the
reliable-no total and reliable-total stacks gives us a good
estimate of the additional latency caused by the total-
ordering protocol. The difference between delivery times
for reliable-no total-dummy crypt and reliable-no total
represents the overhead caused by computation needed for
cryptography.
It should be noted that the reliable pro-
tocol depends on cryptography for correctness, and that
the reliable-no total-dummy crypt stack does not provide
intrusion tolerance. Another comparison we made was
between the reliable-no total-dummy crypt and mnak-
no total stacks to see the overhead caused by the phases
of sending the digest and collecting replies before sending
the actual message.
The variations in time of completion of the application
with the reliable and total protocols with changing group
and key sizes can be seen in Figure 2(a). It is interesting to
reliable−total − 1024 bit RSA
reliable−no_total − 1024−bit RSA
2600
2400
2200
2000
1800
s
d
n
u
o
r
t
s
a
c
i
t
l
u
m
0
1
/
)
s
m
(
e
m
T
i
reliable−total − 1024 bit RSA
reliable−total − 768−bit RSA
reliable−total − 512−bit RSA
3000
2500
2000
1500
1000
500
0
3
4
5
6
7
10
Number of group members
8
9
11
12
s
d
n
u
o
r
t
s
a
c
i
t
l
u
m
0
1
/
)
s
m
(
e
m
T
i
1600
1400
1200
1000
800
600
3
4
5
7
6
10
Number of group members
8
9
11
12
(a) Effect of increasing group
and key sizes
(b) Cost of total ordering layer
110
100
90
80
70
60
50
40
30
20
10
0
reliable−no_total−dummy_crypt
mnak−no_total
reliable−no_total − 1024−bit RSA
reliable−no_total−dummy_crypt
10000
s
d