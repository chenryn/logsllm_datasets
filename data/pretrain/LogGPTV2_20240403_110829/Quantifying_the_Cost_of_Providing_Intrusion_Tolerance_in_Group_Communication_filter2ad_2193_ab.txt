### View Installation Process

In the context of the view installation process, a process with a lower rank than the primary (PB) receives `2f + 1` `Ack-New-View` messages for a `New-View` message. Upon receiving these messages, a correct process transitions to the `WAITING-PHASE2` state. If the process is not the leader, it starts a timer and expects the leader to take action before the timer expires. If the process is the correct leader, it broadcasts a signed `Commit` message. A valid `Commit` message contains the same view specified in the `New-View` message and includes the `2f + 1` `Ack-New-View` messages as proof that a majority of the correct processes have acknowledged the `New-View` message.

When a valid `Commit` message is received, a correct process transitions to the `PHASE2` state and broadcasts a signed `Ready-to-Switch` message. It also starts a timer, expecting to receive a `Ready-to-Switch` message from each member of the new view before the timer expires. Once all `Ready-to-Switch` messages are received from the members of the new view, the process transitions to the `PHASE3` state. The members of the current view who are also members of the next view then begin to form a consensus on the messages delivered by each of them up to this point. This phase, known as the message stabilization phase, ensures that all correct processes deliver the same set of messages broadcast in the current view. After this phase, each correct process that is a member of the new view installs a new protocol stack initialized to the `NORMAL` state. Each of the three phases of the view installation has timers to ensure liveness. If a timer expires before the expected action is observed, a `Suspect` message is sent for the process.

### View Installation with Multiple Faults

An enhanced algorithm is used to handle the scenario where additional faults occur during the view installation. An additional fault is detected if `f + 1` `Suspect` messages are received for a member that is not among those being removed by the current view installation.

Consider a case where an additional fault occurs during the view installation, and a correct process `pk` has not yet reached the `PHASE2` state. When `pk` receives a `Commit` message from the leader, it transitions to the `PHASE2` state. However, instead of broadcasting a `Ready-to-Switch` message, it broadcasts a signed `Need-More-Change` message. This message indicates that the proposed new view specified in the last `New-View` message does not exclude all known corrupt members. A valid `Need-More-Change` message identifies the other corrupt members that need to be excluded and provides justification in the form of the `f + 1` `Suspect` messages received for each corrupt member. After sending the `Need-More-Change` message, `pk` starts a timer and expects to receive a `Ready-to-Switch` or `Need-More-Change` message from each member of the proposed view, except the corrupt ones, before the timer expires. Upon receiving these messages, `pk` transitions to the `WAITING-PHASE1` state (as shown in Figure 1). `pk` then starts a timer and waits for another `New-View` message from the leader, which should exclude at least one more known corrupt member from the next view than the last `New-View` message did. The last `New-View` message and the corresponding `Commit` message (if broadcast) are part of what we call a transitional view. If the additional fault was at the leader, and a `Commit` message from the corrupt leader is not received, the deputy takes over as the new leader, transitions to the `WAITING-PHASE1` state, and broadcasts a new `New-View` message (as shown in Figure 1). Other correct processes also transition to the `WAITING-PHASE1` state, start timers, and wait for the `New-View` message from the new leader.

If the additional fault occurs when `pk` is in the `PHASE2` or `PHASE3` state (i.e., after it has responded with a `Ready-to-Switch` message), `pk` reverts to the `WAITING-PHASE1` state. This is shown in Figure 1 by the reverse transitions from the `PHASE2` and `PHASE3` states to the `WAITING-PHASE1` state. If `pk` is the leader, it broadcasts a `New-View` message that excludes at least one more known corrupt member from the next view than the last `New-View` message did. If `pk` is a non-leader, it starts a timer and expects to receive a `New-View` message from the leader before the timer expires.

After `pk` moves to the `WAITING-PHASE1` state, the view installation follows the procedure outlined in Section 2.4.1, with a correct process transitioning to the `PHASE1` state upon receipt of the new `New-View` message, and so on. If `f + 1` `Suspect` messages for another process `pj` are received after the latest `New-View` message, the `New-View` message becomes part of another transitional view, and a `Need-More-Change` message is broadcast as the response to the `Commit` message in this transitional view. This triggers the broadcast of another `New-View` message, excluding `pj` and the processes excluded by the last `New-View` message. This cycle of transitional views, in which a process keeps reverting to the `WAITING-PHASE1` state, continues until a `New-View` message finally excludes all known corrupt members and all three phases of the view installation are completed, thus bringing up a new protocol stack.

### Performance Measurement

This section quantifies the cost of the reliable multicast, total order, and group membership protocols described in the previous sections. The reliable multicast and group membership protocols frequently use digital signatures to verify the authenticity of messages received. One of the changes made to the C-Ensemble infrastructure was the addition of cryptographic support. We used Peter Gutmann’s Cryptlib [14] as the core cryptographic library and wrote wrapper functions around it.

The tests were conducted on a testbed of ten 1GHz Pentium III computers with 256MB PC133 RAM, connected by a full-duplex 100 Mbps switched Ethernet network. The machines were otherwise unloaded, and, unless specified otherwise, a single process ran on each machine. Time measurements were taken in units of clock cycles using an assembly-level instruction provided by the Pentium instruction set and converted into milliseconds for presentation.

#### Results for Message Delivery

To measure the different costs associated with the message delivery protocols, we devised an application where processes start and wait for the group size to reach the specified group size before beginning to transmit messages. Each process records the start time and sends `num_init_casts` initial multicasts to all members. After this burst, another multicast is sent out every time the process receives the number of messages indicated by the group size. RSA cryptography with keys of size `key_size` is used. The end time is noted when the process has received `10 × group_size` messages, and the elapsed time is calculated and written to a file. The values of `group_size`, `num_init_casts`, and `key_size` are command-line arguments to the processes.

The results reported here were obtained from 10 independent runs, each collecting data for varying parameter values. The same application was run on top of four different protocol stacks:

- **mnak-no_total**: This stack has no total-ordering protocol, and the reliable delivery property is provided by the `mnak` protocol from C-Ensemble [13], which tolerates only crash faults. This stack does not use cryptography.
- **reliable-no_total-dummy_crypt**: This stack includes the intrusion-tolerant reliable delivery protocol but uses a dummy version of the cryptography library that returns from cryptographic function calls immediately without performing the actual cryptographic operations.
- **reliable-no_total**: This stack includes the reliable delivery protocol (with normal cryptography functions) but does not provide total-ordering guarantees.
- **reliable-total**: This is the complete stack with both reliable delivery (with normal cryptographic functions) and total-ordering protocols.

For each stack configuration, a run varied the group size from 4 to 11, and if the stack used cryptography, key sizes of 512, 768, and 1024 were used.

The stack configurations were chosen to compare the individual costs of various factors. Comparing the message delivery times for the `reliable-no_total` and `reliable-total` stacks gives a good estimate of the additional latency caused by the total-ordering protocol. The difference between delivery times for `reliable-no_total-dummy_crypt` and `reliable-no_total` represents the overhead caused by cryptographic computation. It should be noted that the reliable protocol depends on cryptography for correctness, and the `reliable-no_total-dummy_crypt` stack does not provide intrusion tolerance. Another comparison was made between the `reliable-no_total-dummy_crypt` and `mnak-no_total` stacks to see the overhead caused by the phases of sending the digest and collecting replies before sending the actual message.

The variations in the completion time of the application with the reliable and total protocols, with changing group and key sizes, can be seen in Figure 2(a). It is interesting to observe the impact of increasing group and key sizes on the performance of the `reliable-total` and `reliable-no_total` stacks.