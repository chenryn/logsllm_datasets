445
2429
3314
3190
5645
1142
2438
7025
3048
5334
1920
opt off
1910
1887
440
2366
3122
3090
5863
956
2222
7630
3109
5129
1886
Angora Matryoshka
1855
2102
538
2495
3452
4263
7243
1161
2893
8004
3325
5786
2042
2123
2284
571
2550
3866
4297
7993
1278
2965
8210
3304
7045
2041
Program
djpeg
file
jhead
mutool
nm
objdump
readelf
readpng
size
tcpdump
tiff2ps
xmllint
xmlwf
Table 6: Classification of verified bugs found by Matryoshka.
SBO: stack buffer overflow; HBO: heap buffer overflow;
OOM: out of memory; OBR: out of bound read.
Table 7: Constraints unsolved by Angora, and nested con-
straints unsolved by Angora but solved by Matryoshka
Program
file
jhead
nm
objdump
size
readelf
tiff2ps
Number of bugs
SBO HBO OOM OBR Total
4
2
1
15
1
6
1
4
23
2
4
2
4
2
3
1
1
1
4
1
5.3.2 Effective prior conditional statements. A key insight that al-
lows Matryoshka to solve nested constraints effectively is that it
identifies effective prior conditional statements, whose branch choices
may cause the target conditional statement to become unreachable,
and solves a constraint that consists of only those statements, in-
stead of all the prior conditional statements on the path as done
in traditional symbolic execution. Table 9 compares the average
number of effective prior conditional statements vs all prior con-
ditional statements. It shows that the effective prior conditional
statements account for a very small fraction of all the prior condi-
tional statements (less than 5% on 11 programs, and less than 10%
on all the 13 programs). This fact significantly reduces the complex-
ity of the path constraints that Matryoshka solves and increases
the likehood that the constraints can be solved.
containing the CRC value, so it directed Matryoshka to mutate those input bytes to
reduce the objective function to zero.
Program
djpeg
file
jhead
mutool
nm
objdump
readelf
readpng
size
tcpdump
tiff2ps
xmllint
xmlwf
Unsolved by
Angora
Solved by
Matryoshka
% of nested
constraints
All
1889
610
4923
1883
2564
4418
4012
5353
4359
4343
8923
1838
5233
Nested
1700
527
2853
1523
2162
4000
3375
5033
3830
4079
6564
1437
5033
Nested
345
172
316
249
408
377
621
1170
593
1794
330
271
301
solved
20.3 %
32.6 %
11.1 %
16.3 %
18.9 %
9.4 %
18.4 %
23.2 %
15.5 %
44.0 %
5.0 %
18.9 %
6.0 %
6 DISCUSSION
6.1 Comparison with concolic execution
We compare Matryoshka with QSYM while its last branch solving
is disabled. This directly compares the effectiveness of Matryoshkaâ€™s
optimization strategies to that of a concolic execution engine. Ta-
ble 5 shows that Matryoshka performs better than QSYM in all the
statistics. This demonstrates that prioritizing reachability, satisfia-
bility, and joint optimization can be used on most path constraints
effectively without having to resort to concolic execution.
Table 8: Constraints solved by prioritizing reachability (PR,
Section 3.5.1), prioritizing satisfiability (PS, Section 3.5.2),
and joint optimization (JO, Section 3.5.3).
Program
djpeg
file
jhead
mutool
nm
objdump
readelf
readpng
size
tcpdump
tiff2ps
xmllint
xmlwf
Constraints solved by
JO
72
11
60
12
78
53
86
313
56
59
16
31
97
PS
305
163
243
247
321
343
573
1043
414
1742
323
252
253
PR
1
5
172
1
30
47
2
0
231
20
10
1
1
for (i =1; i  122 ||
(c > 90 && c < 97))
const png_uint_32 chunk_name ) {
png_chunk_error ( png_ptr ,
" invalid chunk type ");
1 // pngrutilc .c
2 void
3 png_check_chunk_name ( png_const_structrp png_ptr ,
4
5
6
7
8
9
10
11
12
13 }
14 // pngerror .c 445
15 void
16 png_format_buffer ( png_const_structrp png_ptr ,
17
18
19
20
21 }
png_charp buffer ,
png_const_charp error_message ) {
...
if ( isnonalpha (c) != 0) { ... }
...
}
..
Table 9: Number of average effective prior conditional state-
ments vs. all prior conditional statements
Figure 7: An example with an unsatisfiable constraint. The
false branch on Line 20 is unsatisfiable because it is pre-
cluded by an earlier check on Line 7.
Program Average prior conditional statements
Effective/all
Effective
djpeg
file
jhead
mutool
nm
objdump
readelf
readpng
size
tcpdump
tiff2ps
xmllint
xmlwf
21.69
22.27
16.81
20.08
27.93
23.93
7.23
21.18
21.72
26.26
30.44
11.80
5.88
All
1217.98
345.25
2425.00
2087.80
842.54
493.24
2498.21
859.02
469.46
268.52
1747.16
502.39
655.31
1.8 %
6.5 %
0.7 %
1.0 %
3.3 %
4.9 %
0.3 %
2.5 %
4.6 %
9.8 %
1.7 %
2.3 %
0.9 %
libraries. We manually modeled the taint flow in common external
libraries for Matryoshka, but this is in no way comprehensive.
6.2.3 Program crashing when applying the strategy for prioritizing
satisfiability and joint optimization. When mutating the input us-
ing the strategy for prioritizing satisfiability (Section 3.5.2) and
joint optimization (Section 3.5.3), Matryoshka artificially keeps the
branch choices of prior conditional statements. This may cause the
program to crash. For example, a conditional statement may serve
to prevent the program from accessing data out of bound. If we mu-
tate the length of the data but artificially keep the branch choice
of the conditional statement, the program may access data out of
bound and crash.
6.2.4 Difficult joint constraints. The joint optimization strategy is
the last resort for mutation. We examined the conditional state-
ments that have at least one effective prior conditional statement
in the program tiff2ps and found that they have on average 30 such
prior statements in Table 9. It is difficult to solve such a complex
joint constraint.
6.2.5 Constraint dependent on order of branches. On xmlwf , Ma-
tryoshka and Angora reached similar branches. The unreached bra-
nches are guarded by predicates that can only be solved through a
specific combination of other branch choices, a situation that none
of the fuzzers we tested are designed to handle. These situations