下面这些值都是等价的。
有分隔符的字符串格式，当月、日、时、分或秒的值小于10时，可以不用指定2位数字。例如，
望是日期值的场合，MySQL也不会把一个包含“”的值解释为具体的时间。此外，对于包含
据的是其上下文，而非分隔符。例如，虽然人们习惯于把“：”当作时间值的分隔符，但是在期
不用“”，时间里可以不用“”。任何一种标点符号都可以用作分隔符。对这些值的解释，依
162
前面这个示例也展示了某些应该引起注意的地方：00会被转换为0000，而不是2000。如
把各种不同的2位数字值存储到YEAR(4)列，然后再把它们检索出来，便可以看到这些转
对于所有那些带有年份值的日期和时间类型（包括DATE、DATETIME、TIMESTAMP和YEAR)，
mysql> SELECT
mysql> INSERT
mysql> CREATE
口年份在70~99之间的值，会被转换为1970~1999。
口年份在00~69之间的值，会被转换为2000~2069。
MySQL提供了很多用于处理日期和时间值的函数。更多相关信息请参考附录C。
口如果把 DATETIME或TIMESTAMP 值赋给 DATE 列，则其中的时间部分会被丢失。
存在以下这样几条限制。
一般情况下，可以在 DATE、DATETIME 和TIMESTAMP类型之间随意地相互赋值，但也请记
对于带有前导零的日期和时间值，MySQL有多种不同的解释方式，具体取决于这些值是以
口
口
2012-02-3 5:4:9
2012-02-035:4:9
2012-02-03
2012-02-0305:04:09
2000
0000
2068
Y
TIMESTAMP 列。
各个类型的取值范围有所不同。尤其是TIMESTAMP 类型，其取值范围仅限于
2012-02-03
行那样做，最终的结果也不会是你所期望的那样。同样，也不能把遥远未来的值赋给
1970~2038。因此，不能把一个早于1970年的DATETIME值赋给TIMESTAMP列。如果强
零（即：00:00:00*）
如果把DATE值赋值给DATETIME或TIMESTAMP列，则结果值的时间部分将会被设置为
第3章
数据类型
05:
*FROM Y_table;
INTO y_table
TABLEy_table(y YEAR(4));
:4:9
VALUES（68）,（69）,(99）,（00）,（00）;
供
作
---
## Page 183
这两种模式有以下效果。
一个错误，语句会中止执行，并进行回滚，就像什么事都未发生过一样。对于不支持事务的表
WARNINGS语句来查看这种警告消息的内容。
述转换，那么MySQL会给出警告消息。在执行完其中的某一条语句之后，便可以使用SHOW
的，
果你对其他数据库系统比较熟悉的话。接下来将首先讨论MySQL默认是如何处理非正常数据
绝“坏”值，并且会在遇到“坏”值时抛出一个错误，这种行为与其他数据库系统的很像，如
么在把它们检索出来时得到的就不一定是你所期望的内容。还好，有几种SQL模式可以让你拒
什么样的数据，它就会存储什么样的数据。但是，如果在存储数据时没有对它们进行验证，那
3.3
纪，因此让MySQL根据2位数的年份值去猜测它们属于哪个世纪，绝非明智之举。
日期都录到president表里，那么必须使用4位数字的年份值。这两个列的值跨越了好几个世
得提供一个无歧义的4位数字年份值。例如，想把自18世纪以来的美国总统的出生日期和去廿
MySQL的年份转换规则适用于很多情形，但如果它们产生的结果与你预期的不一致，那就必须
较合理的猜测。当未指定世纪部分时，MySQL并不知道你的2位数字年份具体指的是哪一年。
还是数字，其结果都一律是字符串。
而非数字，则可以使用CAST（value ASCHAR）函数来插入YEAR值，不管value是字符串，
到2000年的表示结果，那么必须使用字符串+O'或＇00＇。如果想确保MySQL看到的是字符串
果把数字0插到YEAR(4)列，得到的也将是0000。如果要利用某个没有包含世纪部分的值得
，然后会讨论当启用各种SQL模式时会对数据处理产生哪些影响。
在过去，MySQL处理数据的基本原则是“垃圾进来、垃圾出去”。换句话说，你给MySQL
需要注意的是，把2位数字年份值转换为4位数字年份值的转换规则，只是提供了一种比
口
口对于这两种模式，
对于支持事务的表，这两种模式都是一样：如果发现某个值无效或缺失，那么结果会产生
如果需要在插人或更新数据时执行更严格的检查，那么可以启用以下两种SQL模式中的一种：
如果在执行 INSERT、REPLACE、UPDATE、LOAD DATA 和ALTER TABLE 等语句时发生了上
默认情况下，MySQL会按照以下规则处理越界（即超出取值范围的）值和其他非正常值。
口
口
口
sql>
MySQL如何处理无效数据值
行，还是要继续执行。
出现某些行被修改的情况。这两种严格模式决定着，这条语句此时此刻是要停止执
在用于插入或修改多个行的语句里，如果在第一行之后的某个行出现了错误，那么会
很相似。
会产生一个错误，语句会中止执行，就像什么事都未发生过一样。这跟事务表的行为
串会被清理，剩余的成员才会被赋值给列。
把不是枚举成员的值赋给ENUM列，那么列的值会变成“出错”成员（即与零值成员相
给ENUM或SET类型列进行赋值时，需要根据列定义里给出的合法取值列表进行。如果
对于字符串列（不包括 ENUM或 SET）
（见表3.15）
对于除TIME以外的其他时态类型列，非法值会被转换成与该类型相一致的“零”值
点，并把结果值存储起来。
对于数值列或TIME列，超出合法取值范围的那些值将被截断到取值范围最近的那个端
对
1在 STRICT_ALL_TABLES 模式下，会抛出一个错误，并且语句会停止执行。因为受
应的空字符串）。如果把包含非集合成员的子字符串的值赋给SET列，那么这些字符
SET
sgl
mode
，如果在插入或修改第一个行时，发现某个值无效或缺失，那么结果
'STRICT_
，过长的字符串将被截断到该列的最大长度。
3.3MySQL如何处理无效数据值
163
---
## Page 184
3.4.1通用的AUTO_INCREMENT属性
况下，如何生成序列”进行讨论。与MySQL里可用存储引擎有关的更多信息请参考2.6.1节。
用它们，而不会遭遇那些让人感到意外的陷阱。下面还会对“不使用AUTO_INCREMENT列的情
列是如何工作的；对于特定的存储引擎，它
AUTO_INCREMENT列的方式有所不同。
列属性—它会自动生成序列编号。不过，
3.4处理序列
误的语句，将只会导致警告的出现。
INSERT 或 UPDATE 语句里使用IGNORE 关键字。有了IGNORE 之后，那些会因无效值而导致错
1~31（即允许像+2000-02-30＇或'2000-06-31'这样的无效值）。另一个制止错误的办法是，在
式，那么MySQL将不会对日期部分做全面检查。相反，它只会要求月份值在1~12，而天数处于
统的”SQLDBMS在数据检查方面的行为比较接近。
模式：
面这样设置SQL模式：
全部，都可以对输入数据进行更加严格的检查。
164
、bug报告或故障报告表标签等。
口每个表只能有一个列具有AUTO_INCREMENT 属性，并且它应该为整数数据类型。
为达到标识的目的，许多应用都需要生成唯一编号，如成员编号、样品编号或批号、顾客
这些选项能让你灵活地为你的应用选择正确的有效性检查级别。
TRADTIONAL模式的含义是“启用两种严格模式，
如果想启用严格模式，
AUTO_INCREMENT列必须按照以下条件进行定义。
也可以选择性地在某些方面弱化严格模式。如果启用了SQL的ALLOW_INVALID_DATES 模
例如，想让所有的存储引擎启用严格模式，并对“被零除”错误进行检查，那么可以像下
NO_ZERO_IN_DATE：在严格模式下，它会阻止月或日部分为零的不完整日期值进人数
NO_ZERO_DATE：在严格模式下，它会阻止“零”日期值进入数据库。
口ERROR_FOR_DIVISION_BY_ZERO：在严格模式下，如果遇到以零为除数的情况，它会阻
严格模式实际上并不是MySQL能够执行的最严格检查。通过以下模式当中的任何一个或
据库。
NULL。）
止数值进入数据库。
■在 STRICT_TRANS_TABLES 模式下，对于非事务表，MySQL 会中止语句的执行
第3章数据类型
如3.2.3节所述。
所定义的那样。
于非事务表，那些修改是无法撤销的，因此MySQL会继续执行该语句，以避免出现
样的效果；如果错误在后面的某个行上，那么就会出现某些行被修改的情况。由于对
只有这样做，才能达到事务表那样的效果。只有当第一个行发生错误时，才能达到这
该语句影响的许多行都已被修改，所以这将会导致“部分更新”问题。
“部分更新”的问题。它会把所有的无效值转换为与其最接近的合法值，如本节之前
。对于缺失的值，MySQL会把该列设置成其数据类型的隐式默认值，
，以及所有的附加限制，那么最为简单的办法是启用TRADTIONAL
（如果不在严格模式下，那么会产生一条警告消息，并插入
下面的讨论将描述：
它又是如何工作的。有了这些知识，你就可以高效地使
MySQL所支持的那些存储引擎，处理
，外加一大堆的其他限制”。这与其他“传
在一般情况下，AUTO_INCREMENT
---
## Page 185
这时，就不能依靠LAST_INSERT_ID（）来返回序号值了。
只会返回其中的第一个。
你可以生成一个序号，接着在同一个会话连接里调用LAST_INSERT_ID（)来检索它。即使其他
客
客户在此期间生成了它们自己的序号值，也不会出现任何问题。
如果使用INSERT DELAYED，那么要直到实际插入行时，才会生成AUTO_INCREMENT 值。
一次插入多个行的INSERT 语句，将生成多个AUTO_INCREMENT 值，LAST_INSERT_ID（）
LAST_INSERT_ID（）只会依赖于与服务器的当前会话连接所生成的AUTO_INCREMENT 值。
口
口
口
口
口
口
口
口
口列必须建立索引。最常见的情况是使用 PRIMARYKEY或UNIQUE索引，但是也允许使用
者把它设置为O，而且没有启用NO_AUTO_VALUE_ON_ZERO时，该列的值将被更新为一
的值，使用REPLACE 命令来更新行，那么当你把AUTO_INCREMENT列设置为NULL，或
AUTO_INCREMENT值将保持不变。如果根据其他具有 PRIMARY KEY 或 UNIQUE 索引的列
如果根据AUTO_INCREMENT列的值，使用REPLACE来更新行，那么这个行的
且这个列拥有唯一索引，那么会出现一个键重复错误。如果把这个列设置成某个大于
如果使用UPDATE命令把AUTO_INCREMENT列的值设置成某个正被其他行使用的值，
把表里的所有记录都删除，那么所有值都可以重用，并且这个序列会重新从1开始。
AUTO_INCREMENT列值的那行删除，那么在下次生成新值时可以重用这个最大值。如果
对于某些存储引擎，从序列顶端删除的值可以被重用。如果把包含最大
即可以插入一行
这个序列将被重置，对于随后的行，所使用的编号会继续由该值开始生成。换句话说，
AUTO_INCREMENT 列会被设置为那个给定值。
NULL，也不为〇的值，那么将发生这样两种情况中的某一种。如果已存在一行使用
如果要插人一行，并为某个拥有唯一索引的AUTO_INCREMENT列指定一个既不
NO_AUTO_VALUE_ON_ZERO模式，那么插入O则会导致存储值为O，而非下一个序号值。
默认情况下，把O插入AUTO_INCREMENT列，等效于插入NULL值。如果启用了SQL的
值。如果ai_co1是一个AUTO_INCREMENT列，那么下面这两条语句就是等效的：
在插人一行时，如果不为AUTO_INCREMENT列指定值，则等同于向该列插入一个NULL
INSERT INTO
前会话里，还没有生成过AUTO_INCREMENT值，那么LAST_INSERT_ID（）将返回0。
知道AUTO_INCREMENT值到底是多少的时候，也可以在后续的语句里引I用它。如果在当
要获得最近生成的序号值，可以调用LAST_INSERT_ID（）函数。这样，即使在你根本不
显式地设置或重
各行的序号值将为1、2、3，如此等等。在某些场合，根据所用存储引擎的不同，可以
插入列。AUTO_INCREMENT序列通常是从1开始，并依次单步递增，因此连续插人表的
把 NULL值插入AUTO_INCREMENT 列将引发 MySQL 自动生成下一个序列编号，并把它
在创建之后，AUTO_INCREMENT列将具有以下行为。
为NOT NULL。
列必须拥有NOT NULL约束条件。即使没有显式地这样声明，MySQL也会自动把列设置
不唯一的索引。
所
值
INSERT INTO t（ai_col,name)VALUES(NULL,'abc);
（AUTO_INCREMENT也支持浮点类型，但很少那样使用。）
号。如果把该列更新为O，那么它会被设置为0（不管是否启用了NO_AUTO_
有已有列值的编号值，
的记录，那么将会发
一行，让其序号值大于当前计数器值，以此达到增大计数器的目的。
重置下一个序号，或者重复使用已从序列顶端删除的那些序号值。
，那么对于随后的行，这个序列从那个值开始继续生成下一个
发生键重复错误。否则，这行会被正常插入，而那
，如果该值大于当前的下一个序号值，那么
3.4处理序列
165
并
个
该
为
---
## Page 186
用它来同时记录多个软件项目的bug报告，该表的定义如下：
AUTO_INCREMENT 列将生成一组彼此互不干扰的序列值。例如，有一个名为 bugs 的表，你需要
AUTO_INCREMENT的那个列作为其中的最后一个。对于该索引最左边的列构成的每一个相异键，
为利用这个特性，为表创建一个由多列组成的PRIMARY KEY 或UNIQUE 索引，并把包含
3.4.2.1MyISAM表的AUTO_INCREMENT列
记住刚才的讨论。MyISAM为序列处理提供了最大的灵活性，因此这里的讨论便由该引擎开始。
多数引擎实现的行为与上面的描述大体是一致的，因此大家在继续往前阅读时，请一定要好好
3.4.2
166
CREATE TABLE bugs
MyISAM存储引擎支持在同一个表里使用复合（多列）索引，以创建多个相互独立的序列。
刚才介绍的通用AUTO_INCREMENT 特征，是理解各种存储引擎特有序列行为的基础。绝大
口
口MyISAM序列将默认从1开始，不过你可以在CREATETABLE语句里，通过
口MyISAM 表里的序列一般是单调的。在一个自动生成的序列里，这些值都是严格递增
MyISAM存储引擎拥有以下AUTO_INCREMENT 特征。
description V
oug_id
proj_name
置这个计数器，得到的下一个自动值仍然为11，而非5。
如果某个AUTO_INCREMENT列包含的值为1~10，那么使用AUTO_INCREMENT=5来设
不能使用AUTO_INCREMENT选项来把当前计数值设置得，比表里当前的最大计数值还小。
设置到最低，使得下一个编号只比当前最大序号值多1：