Cryptography, 3(1), may 2009.
[9] A. Boldyreva. Threshold Signatures, Multisignatures
and Blind Signatures Based on the
Gap-Diﬃe-Hellman-Group Signature Scheme. In
IACR PKC, pages 31–46, 2003.
[10] D. Boneh. The Decision Diﬃe-Hellman Problem. In
ANTS, pages 48–63, 1998.
[11] D. Boneh, B. Lynn, and H. Shacham. Short Signatures
from the Weil Pairing. In Advances in
Cryptology—ASIACRYPT’01, pages 514–532, 2001.
[12] M. Castro and B. Liskov. Practical Byzantine Fault
Tolerance and Proactive Recovery. ACM Trans.
Computer Systems, 20(4):398–461, 2002.
[13] B. Chor, E. Kushilevitz, O. Goldreich, and M. Sudan.
Private information retrieval. J. ACM, 45(6):965–981,
1998.
[14] Y. G. Desmedt. Threshold cryptography. European
Transactions on Telecommunications, 5(4), 1994.
[15] G. Di Crescenzo, R. Ostrovsky, and S. Rajagopalan.
Conditional oblivious transfer and timed-release
encryption. In EUROCRYPT, pages 74–89, 1999.
[16] R. Dingledine, N. Mathewson, and P. F. Syverson.
Tor: The second-generation onion router. In USENIX
Security Symposium, pages 303–320, 2004.
[17] S. Even, O. Goldreich, and A. Lempel. A randomized
protocol for signing contracts. Commun. ACM,
28:637–647, June 1985.
[18] J. Falkner, M. Piatek, J. P. John, A. Krishnamurthy,
and T. Anderson. Proﬁling a Million User DHT. In
IMC, pages 129 – 134, 2007.
[19] A. Fiat, J. Saia, and M. Young. Making Chord Robust
to Byzantine Attacks. In European Symp. on
Algorithms, pages 803–814, 2005.
[20] R. Geambasu, T. Kohno, A. A. Levy, and H. M. Levy.
Vanish: Increasing Data Privacy with Self-Destructing
Data. In USENIX Security Symposium, pages
299–315, 2009.
[21] R. Gennaro, S. Jarecki, H. Krawczyk, and T. Rabin.
Robust Threshold DSS Signatures. In Advances in
Cryptology - EUROCRYPT, pages 354–371, 1996.
[22] K. Hildrum and J. Kubiatowicz. Asymptotically
Eﬃcient Approaches to Fault-Tolerance in
Peer-to-peer Networks. In DISC, pages 321–336, 2004.
[23] H. Johansen, A. Allavena, and R. van Renesse.
Fireﬂies: Scalable Support for Intrusion-Tolerant
Network Overlays. In EuroSys Conference, pages 3–13,
2006.
[24] A. Kate and I. Goldberg. Distributed Key Generation
for the Internet. In IEEE ICDCS, pages 119–128,
2009.
[25] J. Liang and R. Kumar. Pollution in P2P ﬁle sharing
systems. In IEEE Intl. Conf. on Computer
Communications (INFOCOM), 2005.
[26] J. Liang, N. Naoumov, and K. W. Ross. The Index
Poisoning Attack in P2P File Sharing Systems. In
IEEE Intl. Conf. on Computer Communications
(INFOCOM), pages 1–12, 2006.
[27] H. Lipmaa. An oblivious transfer protocol with
log-squared communication. In ISC, pages 314–328,
2005.
[28] B. Lynn. The Pairing-Based Cryptography (PBC)
Library. http://crypto.stanford.edu/pbc/, 2006.
Accessed March 2012.
[29] J. McLachlan, A. Tran, N. Hopper, and Y. Kim.
Scalable onion routing with Torsk. In ACM CCS,
pages 590–599, 2009.
[30] P. Mittal and N. Borisov. ShadowWalker: Peer-to-peer
Anonymous Communication using Redundant
Structured Topologies. In ACM CCS, pages 161–172,
2009.
[31] A. Nambiar and M. Wright. Salsa: A Structured
Approach to Large-Scale Anonymity. In ACM CCS,
pages 17–26, 2006.
[32] M. Naor and B. Pinkas. Eﬃcient oblivious transfer
protocols. In SODA, pages 448–457, 2001.
[33] M. Naor and U. Wieder. A Simple Fault Tolerant
Distributed Hash Table. In Intl. Workshop on
Peer-to-Peer Sys., pages 88–97, 2003.
[34] R. Narendula, T. G. Papaioannou, Z. Miklos, and
K. Aberer. Tunable Privacy for Access Controlled
Data in Peer-to-Peer Systems. In International
Teletraﬃc Congress (ITC 22), 2010.
[35] A. Panchenko, S. Richter, and A. Rache. NISAN:
network information service for anonymization
networks. In ACM CCS, pages 141–150, 2009.
[36] C. Peikert, V. Vaikuntanathan, and B. Waters. A
Framework for Eﬃcient and Composable Oblivious
Transfer. In CRYPTO, pages 554–571, 2008.
[37] M. Rabin. How to exchange secrets with oblivious
transfer. Technical Report TR-81, Aiken Computation
Lab, Harvard University, Cambridge, MA, 1981.
[38] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and
S. Schenker. A Scalable Content-Addressable Network.
In SIGCOMM, pages 161–172, 2001.
[39] R. Rodrigues and B. Liskov. Rosebud: A Scalable
Byzantine-Fault-Tolerant Storage Architecture.
Technical Report TR/932, MIT LCS, December 2003.
[40] R. Rodrigues, B. Liskov, K. Chen, M. Liskov, and
D. M. Schultz. Automatic reconﬁguration for
large-scale reliable storage systems. IEEE TDSC, 99:1,
2010.
[41] A. I. T. Rowstron and P. Druschel. Pastry: Scalable,
Decentralized Object Location, and Routing for
Large-Scale Peer-to-Peer Systems. In Middleware,
pages 329–350, 2001.
[42] J. Saia and M. Young. Reducing Communication
Costs in Robust Peer-to-Peer Networks. Inform.
Process. Lett., 106(4):152–158, 2008.
[43] D. A. Schultz, B. Liskov, and M. Liskov. MPSS:
Mobile Proactive Secret Sharing. ACM Trans. Inf.
Syst. Secur., 13(4):34, 2010.
[44] V. Shoup. Practical Threshold Signatures. In Advances
in Cryptology - EUROCRYPT, pages 207–220, 2000.
[45] E. Sit and R. Morris. Security Considerations for
Peer-to-Peer Distributed Hash Tables. In Intl.
Workshop on Peer-to-Peer Systems, pages 261–269,
2002.
[46] M. Steiner, T. En-Najjary, and E. W. Biersack. A
Global View of KAD. In IMC, pages 117 – 122, 2007.
[47] I. Stoica, R. Morris, D. Karger, M. F. Kaashoek, and
H. Balakrishnan. Chord: A Scalable Peer-to-peer
Lookup Service for Internet Applications. In ACM
SIGCOMM Conference, pages 149–160, 2001.
[48] V. Pappas and D. Massey and A. Terzis and L. Zhang.
A Comparative Study of the DNS Design with
DHT-Based Alternatives. In IEEE Intl. Conference on
Computer Communications, pages 1–13, 2006.
[49] D. S. Wallach. A Survey of Peer-to-Peer Security
Issues. In Intl. Conf. on Software Security: Theories
and System, pages 253–258, 2002.
[50] Q. Wang, P. Mittal, and N. Borisov. In search of an
anonymous and secure lookup: attacks on structured
peer-to-peer anonymous communication systems. In
ACM CCS, pages 308–318, 2010.
[51] S. Wolchok, O. S. Hofmann, N. Heninger, E. W.
Felten, J. A. Halderman, C. J. Rossbach, B. Waters,
and E. Witchel. Defeating Vanish with Low-Cost Sybil
Attacks Against Large DHTs. In NDSS, 2010.
[52] M. Young, A. Kate, I. Goldberg, and M. Karsten.
Practical Robust Communication in DHTs Tolerating
a Byzantine Adversary. In IEEE ICDCS, pages
263–272, 2010.
[53] M. Young, A. Kate, I. Goldberg, and M. Karsten.
Towards Practical Communication in
Byzantine-Resistant DHTs. To appear in IEEE/ACM
Transactions on Networking (ToN), 2012.
[54] B. Y. Zhao, L. Huang, J. Stribling, S. C. Rhea, A. D.
Joseph, and J. Kubiatowicz. Tapestry: a resilient
global-scale overlay for service deployment. IEEE
Journal on Selected Areas in Communications,
22(1):41–53, 2004.
APPENDIX
A. THE OBLIVIOUS TRANSFER PROTO-
COL
In this appendix, we provide an overview of the 1-out-of-ν
OT protocol of Naor and Pinkas [32]. Security of the con-
struction is based on DDH in a group G of prime order |G|.
The proof of security uses the random oracle model, i.e. the
protocol uses a cryptographic hash function, H, which is
then replaced by the random oracle in the proof. Recall that
the goal is for the server, q, to oﬀer ν strings, S1, . . . , Sν , and
for chooser p to obtain the desired one, Sρ, and nothing else.
The basic idea of the [32] OT protocol is to let p provide en-
cryption keys P Ki for 1 ≤ i ≤ ν; these are constructed
such that p can know at most one of the decryption keys.
The server then supplies p with encryptions of each Si under
P Ki. Details are included in a protocol ﬂow below in Fig-
ure 5. we now elaborate on the intuition behind the three
messages:
1. OT-setup: q picks a random DL instance, α = gr and
sends this to p. Moreover, the parties agree on ν − 1
random group elements, C2, . . . , Cν . It is crucial that
p does not know their DL, hence they are picked by q
(who is allowed but not required to know the DL).
2. OT-request: p will supplies P K1 to q; for 1 < i ≤ ν
P Ki is implicitly set to Ci/P K1. p constructs P K1
such that P Kρ has known DL; however, if p could ﬁnd
the DL of any other key, P Ki, p could solve a DDH
problem in G.
i = C r
i /P K r
3. OT-response: q computes P K r
1 for all i.
Since the C r
i may be precomputed this requires only
a single exponentiation and ν − 1 multiplications. q
then picks a uniformly random (cid:96)-bit string, R, where (cid:96)
is chosen large enough (e.g. 200 bits) to ensure that R
will be distinct. Finally, for each 1 ≤ i ≤ ν q computes
i , R, i) ⊕ Si. R and
an encryption of Si as Ei = H(P K r
the Ei are sent to p, who computes ﬁrst P K r
ρ = αk and
then decrypts to obtain Sρ = Eρ ⊕ H(P K r
ρ , R, ρ).
For more details along with the proof in the random oracle
model, see [32]. As noted, α and the C r
i may be prepro-
cessed during periods of low computational load. Moreover,
the values may be used in multiple instances of the OT pro-
tocol. “Refreshing” r (i.e. α and the C r
i ) every ν execution
provides an amortized complexity of two exponentiations per
party per OT invocation. The setup message consists of ν
group elements, while the OT-request contains only a sin-
gle one. Finally, the reply consists of ν Eis plus R; though
strictly speaking, these are not group elements, they may be
viewed as such for the complexity analysis. Hence, overall
communications is 2ν + 2 group elements.
We remark that since we are transferring AES keys using
OT, we could also directly use (some digest of) P K r
i , R, i as
the AES key. However, such ad hoc optimizations may eas-
ily introduce subtle ﬂaws. The security proof of Naor and
Pinkas may easily be invalidated by even a minor optimiza-
tion, hence, as the gains are marginal, we prefer the original
OT protocol to any ad hoc optimization.
peer p
Setup (for ν invocations)
⇐=
peer q
Pick r ∈ Z|G| uniformly at random and com-
pute α = gr; for 1 < i ≤ ν pick Ci uniformly
at random in G and compute C r
i . Send α and
C2, . . . , Cν to p.
Online (single invocation)
peer p requesting Sρ
Pick k ∈ Z|G| uniformly at random and com-
If ρ (cid:54)= 1 compute P K1 =
pute P Kρ = gk.
Cρ/P Kρ. Send P K1 to q.
=⇒
⇐=
Compute ﬁrst P K r
H(P K r
cryption and output the plaintext, Sρ.
and then
ρ , R, ρ); use this to decrypt the ρth en-
ρ = αk
peer q holding S1, . . . , Sν
i = C r
i /P K r
1 ; then for 1 < i ≤ ν compute
Compute P K r
P K r
1 . Pick a random string R and
for 1 ≤ i ≤ ν compute an encryption of Si,
i , R, i) ⊕ Si; send all ν encryptions to p
H(P K r
along with R.
Figure 5: The 1-out-of-ν OT protocol of Naor and Pinkas