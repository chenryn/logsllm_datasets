    v = u+d
    if v:
       w = e+f
       x = w+g
       y = x+h
这个例子中，以来关系为`t`->`u`->`v`以及`w`->`x`->`y`，因此，如果没有推测执行机制，两路乱序处理器无法填满第二条流水线。处理器需要3个周期才能计算`t`、`u`以及`v`，之后才能知道`if`语句下的代码段能否被执行，如果执行这段分支，则需3个周期来计算`w`、`x`以及`y`。假设`if`语句（由一条分支指令来实现）需要消耗1个周期，那么这个例子需要消耗4个周期（如果`v`为0）或者7个周期（如果`v`不为0）.
如果分支预测器认为`if`语句下的代码分支很有可能会被执行，那么处理器就可以通过推测执行将上述代码变成如下样子：
    t = a+b
    u = t+c
    v = u+d
    w_ = e+f
    x_ = w_+g
    y_ = x_+h
    if v:
       w, x, y = w_, x_, y_
如上代码增加了指令级别的并行度，可以保持流水线处于忙碌状态：
    t, w_ = a+b, e+f
    u, x_ = t+c, w_+g
    v, y_ = u+d, x_+h
    if v:
       w, x, y = w_, x_, y_
经过处理后，推测型乱序处理器可以利用闲置的流水线能力来更新`w`、`x`以及`y`的分支及条件，因此上述代码大约需要3个周期即可完成执行任务。
## 七、缓存
在早些时候，处理器的速度与内存访问速度不相上下。我原来用的是BBC
Micro，这款计算机搭载了2MHz主频的6502处理器，每隔2µs（微秒）就能执行一条指令，内存处理周期为0.25µs。经过35年的发展，现在处理器已经变得非常快，但内存的变化并不大：Raspberry
Pi 3中的Cortex-A53每隔0.5ns（纳秒）就能执行一条指令，但访问主内存却需要100ns。
乍听起来像是一场灾难：每次需要访问内存时，我们都必须等待100ns才能得到结果。我们来看一个例子：
    a = mem[0]
    b = mem[1]
这两条指令需要消耗200ns。
然而，实际生活中，程序访问内存的方式其实存在一定的相关性，某种程度上可以预测，这种相关性表现为时间局部性（如果我访问了一个位置，那么可能我很快就会再次访问该位置）以及空间局部性（如果我访问一个位置，那么可能我很快会访问其临近位置）。缓存（Cache）利用的正是这种相关性，来降低访问内存的平均成本。
高速缓存是一个小型的片上（on-chip）存储器，靠近处理器，用来存储最近使用过的位置（及临近位置）所对应的内容副本，以便在后续访问任务中快速返回这些数据。使用缓存机制后，上述代码的执行时间就会大幅减少，只需消耗100ns出头即可：
    a = mem[0]    # 100ns delay, copies mem[0:15] into cache
    b = mem[1]    # mem[1] is in the cache
从Spectre以及Meltdown的角度来看，关键点在于如果你可以计算出内存访问所需的时间，那么你就可以确定你所访问的目的地址是否在缓存中，位于缓存中则所需时间较短，否则需要较长时间。
## 八、侧信道攻击
根据维基百科的解释：
>
> “……侧信道攻击是利用密码系统设备在运行中所泄露的信息的一种攻击方式，这种攻击并非针对加密算法的暴力破解攻击，也没有用到加密算法本身的理论缺陷（如基于比较的密码分析技术）。侧信道攻击中，时间消耗、功率消耗、电磁辐射或者声音等都可以作为额外的信息来源，攻击者可以利用这些信息突破目标系统的重重防御。”
Spectre以及Meltdown用到的正是侧信道攻击技术，利用时间消耗信息来观察可访问的一个位置是否在缓存中，进而推断通常情况下无法访问的某个内存位置所对应的具体内容。
## 九、综合考虑
现在我们来看看如何有机利用推测执行以及缓存机制，针对处理器发起类似Meltdown之类的攻击。考虑如下一个例子，这段代码是一个用户程序，可能会从非法地址（内核地址）读取数据，导致出现运行错误（即程序崩溃）：
    t = a+b
    u = t+c
    v = u+d
    if v:
       w = kern_mem[address]   # if we get here, fault
       x = w&0x100
       y = user_mem[x]
现在，如果我们能训练分支预测器，使其认为`v`很有可能是一个非零值，那么我们所使用的两路乱序超标量处理器就会重新排序代码，得到如下结果：
    t, w_ = a+b, kern_mem[address]
    u, x_ = t+c, w_&0x100
    v, y_ = u+d, user_mem[x_]
    if v:
       # fault
       w, x, y = w_, x_, y_      # we never get here
虽然处理器总是会推测读取内核地址所对应的数据，但直到它发现`v`为非零值，才会返回异常结果。从表面上来看，这一点无关痛痒，因为有如下两点原因：
1、如果`v`为0，那么非法读取所获得的结果不会提交给`w`。
2、如果`v`不为0，读取结果在提交给`w`之前就会出现错误。
然而，假设我们在执行代码之前刷新了缓存，重新安排`a`、`b`、`c`以及`d`的值，使`v`成功取得0值。那么，第3个周期所执行的推测读取指令为：
    v, y_ = u+d, user_mem[x_]
这条指令会访问用户空间的`0x000`地址或者`0x100`地址，具体结果取决于非法读取结果的第8位值，然后将该地址以及临近地址加载到缓存中。由于`v`为0，推测指令的结果将被处理器丢弃，继续执行流程。如果我们观察推测访问这些地址所需的时间，我们可以确定哪个地址位于缓存中。现在攻击任务已达成，我们成功从内核地址空间中读取出了1比特信息！
真正的Meltdown利用过程远比这个更加复杂（为了避免错误训练分支预测器，作者倾向于无条件执行非法读取操作，再去处理异常结果），但原理相同。Spectre使用了类似的方法来绕过软件数组边界检查机制。
## 十、总结
时至今日，现代处理器在后台做了许多工作，从抽象层面来看这些处理器是可以直接访问内存的有序标量处理器，但实际上它们引入了大量技术，如缓存、指令重排以及推测执行，从而获得了简单处理器无法企及的高性能指标。然而抽象和现实毕竟有所不同，即使差别非常细微，安全性方面依然值得细致推敲，Meltdown以及Spectre正是我们在抽象背景下遇到的安全风险。
Raspberry Pi使用的是ARM1176、Cortex-A7以及Cortex-A53核心，这些处理器并不具备推测执行功能，因此能免受这类攻击影响。