DBBUG: This Is /home/bones/ .bash_profile
$ exit
Logout
终结通信期
DEBUG: This is /home/bones/ .bash_logout
交互式通信期仅引用一个文件：
$ bash
DBBUG: This 18 /home/bones/ ,bashre
开始交互式通信期
$ exit
终结通信期
exit
非交互式通信期通常不会引用任何文件：
$ echo pwd 1 bash
于bash之下执行命令
/home/bones
然而，如果BASH_ENV值指向一个起始文件时，便会这么做：
$ ecbo pwd 1 BASH_ENV=SHcHE/ .bashenv baeb
DEBUG: This is /hone/bones/ ,bashenv
在bash下执行命令
/home/bones
14.7.4Z-Shell起始与终结
Z-Shell-zsh可仿为Bourne Shell或是Korn Shell，在sh或ksh名称下被引用，
或是以字符s或k开头的任何名称被引用时，可选择性地前置单一r（restricted；限制
性），它就会拥有与那些Shell相同的启动行为，且本节的其他部分不能套用（模仿ksh
时，它会遵循总是处理$ENV文件的ksh88行为模式）。
www.TopSage.com
---
## Page 433
Shell可移植性议题与扩展
交互式Shell，或是非交互式Shell，都会试着读取两个初始文件，像这样：
test -r /etc/zshenv && ./etc/zshenv
读取系统面的脚本
if test -n $zDOTDIR*&k test -r SZDOTDIR/.zshenv ;then
.$ZDOTDIR/.zahenv
读取此文件
SHOME/.zshenv
或此文件
ZDOTDIR变量是防止zsh自动读取用户根目录下的启动文件的系统管理手段，相对地，
它会强制读取在管理控制下位于其他地方的文件。如果需使用此变量，则它会被设置
在/etc/zshenv里，所以你可以到那儿看看你的系统处理方式。
假设ZDOTDIR未设置，最好的位置便是将它置于个人定制的地方，其中你希望在每一个
Z-Shell通信期中都能生效。$HOME/.zshenv是可以影响所有Z-Shell通信期的文件。
如为登录Shell，接下来它会执行相当于下列的命令，读取两个启动profile：
test -r /etc/zprofile 6&./etc/zprofile
读取系统面的脚本
.$zDOTDIR/.zprofi1e
elif test -r $HOME/.zprofile : then
读取此文件
.$HoMB/,zprofile
或此文件
fi
如果为登录Shell或交互式Shell，接下来会试图读取两个启动文件，像这样：
test -r /etc/zshrc && ./etc/zshrc
读取系统面脚本
.$ZDOrDIR/.zohrc
elif test -r SHOME/.zshre ; then
读取此文件
.$HOME/.zshrc
fi
或此文件
最后，如果为登录Shell，它还会试着读取两个登录脚本，像这样：
test -r /etc/z1ogin && . /etc/zlogin
if test -n *szDOTDIR && test -r SzDOTDIR/,zlogin:then
读取系统面即本
.$ZDOTDIR/.z1ogin
elif test -r SHOME/.zlogin : then
读取此文件
fi
.$HOM8/.=1ogin
成此文件
zsh离开时，如果为登录Shell，它不会因为由exec执行的其他进程而被终结，而是借
由读取两个终结脚本面结束。依序为一个用户的，一个系统的：
if test -n“$zDOTDIR*&s test -r szDoTDIR/,zlogout ; then
.$2DOTDIR/.zlogout
读取此文件
www.TopSage.com
---
## Page 434
422
第14章
elif test -r SHOMB/.zlogout : then
或此文件
.SHCNE/.zlogout
test -z /etc/z1ogout && ./etc/zlogout
ff
读取系统面脚本
Z-Shel1初始与终结的处理程序相当复杂，为了更了解它做了什么，我们将每个文件搭配
echo命令，且将ZDOTDIR停留在未设置状态。这么一来，只有在/etc与$HOME下的
文件才会被寻找。登录通信期看起来就会像这样：
$1ogin
起始新的登录通信期
login: zabrlak
Pa8sword:
DEBUC: This is /etc/zshenv
DEBUG: This is /home/zabriski/.zshenv
DEBuC: This is /etc/zprofile
DEBUG: Thl8 18/home/zabriski/,.zprofile
DEBUG: This
81s/home/zabriski/.zshrc
: is /etc/zshrc
DEBUG:
Th18
is
/etc/zlogin
DEB0G: Thls 1s /home/zabriski/.zlogin
DEBUG: This’ is /home/zabriski/.zlogout
$ exit
终结通信期
DEBDG: Thls 1s /etc/zlogout
交互式通信期引用较少的文件：
Szeh
开始一个新的交互式通信期
DEBUG: Thi8 18 /etc/zshenv
DEBUG: This is /home/zabriski/.zshenv
DEBUG: This is /home/zabriski/.zshre
D&BUG: This 1s /etc/zshrc
$ exit
静款：未读取任何终结文件
终结通信期
非交互式通信期仅使用两个文件：
tezIpad ouoe s
在zsh下执行命令
DEBUG: This is /etc/zshenv
/home/zabrlskl
14.8
小结
POSIX标准提升了可移植式Shell脚本的可能性。如果你在该定义下做事，那么要完成
一个可移植式脚本是有机会成功的。不过真实世界往往更复杂。虽然bash与ksh93都
提供比POSIX还多很多的扩展，但它们也并非百分之百被此兼容，我们列出了一长串
“迷思（Gotchas）”列表，将它们挑出来，甚至还包括了像set选项或是存储Shell的完
整状态等领域，值得大家注意。
www.TopSage.com
---
## Page 435
Shell可移桂性议题与扩展
423
shopt命令可用以控制bash的行为。我们特别建议你：在交互模式下启用extglob选
项。
bash与ksh93共享许多共通的扩展—在Shell程序化时相当好用：Select循环、扩
展性测试工具（（..））、扩展性样式比对、括弧展开、进程替换及索引式数组。我们也
提到许多其他小型，但很有用的扩展。算术for循环与（（...））算术命令可能是这些
里面最有名的了。
bash与ksh93的源代码可自Internet下载取得，我们还介绍了这两个Shell的建置方式。
除此之外，还有两个广受欢迎的扩展性Bourne式Shell：pdksh与zsh，我们也做了简
短的介绍。
我们让你知道如何确认你所执行的Shel1版本。这在你需要知道正在使用的程序是部个
版本时会用得到，
最后，不同的BourneShell语言实例，在起始与终结时都有不同的定制功能与文件.Shel1
脚本倾向于一般的使用，不要依赖任何个别用户所设置的功能或变量，反而应该由他们
自行处理所有必需的初始化操作。
www.TopSage.com
---
## Page 436
第15章
TopSage.com
安全的Shell脚本：起点
UNIX的安全性一向是恶名在外。几平从每个角度看，UNIX系统都有或多或少的安全
性争议，不过这些大部分都是系统管理者该担心的。
本章，我们会先列出一长串“诀窍”，提醒你编写Shell脚本应该注意的地方，以避开安
全性问题。再者，我们会介绍限制性Shell（restrictedShell），这是对用户环境加以限
制的Shell。接下来，我们还会提到特洛伊木马（Trojanhorse），并说明为什么应该要
避开它。最后，将探讨setuid的Shell脚本，包括KornShell的特权模式（privilegedmode）。
注意：本书主题并非探讨UNIX系统安全性，本章进行的时论也只是冰山一角，而UNIX系统的
安全性除了Shell的设置之外，还有无数的层面必须关切。
如果你想了解更多UNIX的安全性问题，我们建议你看《Internet Security》（O'Reilly）这
本书（见参考书目）。
15.1安全性Shell脚本提示
下面的提示，有助于你编写一个更安全的Shell脚本，感谢PurdueUniversity的Center
for Education and Research in Information Assurance and Security学者Professor Eugene
（Gene）Spafford（注1）所提供的信息：
物将当前目录（点号）置于PATH下
可执行程序应该只能放在标准的系统目录下，将当前目录（点号）放在PATH里，
无疑是打开特洛伊木马（TrojanHorse）的大门，详见15.3节。
设1:
见hmp://www.cerias.purdwe.edu/,
424
www.TopSage.com
---
## Page 437
安全的Shell脚本：起点
425
为bin目录设置保护
确认SPATH下的每一个目录都只有它的拥有者可以写人，其余任何人都不能.同样
的道理也应应用于bin目录里的所有程序。
写程序前，先想清楚
花点时间想想，你想要做的是什么、该如何实行。不要一开始就在文字编辑器上直
接写，而且，在它真的开始运作前，要不断地设法测试。错误与失败的优雅处理，
也应该设计在程序里。
应对所有输人参数检查其有效性
如果你期待的是数字，那就验证你拿到的是数字，检查该数字是否在正确的范围
内。同样的检查也应该出现在其他类型的数据上，Shell的模式匹配工具可以将这
个工作处理得很好。
对所有可返回错误的命令，检查错误处理代码
不在你预期内的失败情况，很可能是有问题的强道失败，导致脚本出现不当的行
为。例如，如果参数为NFS加载磁盘或面向字符的设备文件时，即便是以root的
身份执行，也可能导致有些命令失败。
不要信任传进来的环境变量
如果它们被接下来的命令（例如TZ、PATH、IFS等）使用时，请检查并重设为已
知的值。ksh93会在启动时自动重设IFS为它的默认值，无论当时环境为何，但
其他许多Shell就不会这么微了，无论在什么情况下，最好的方式就是明确地设置
tab-newline).
从已知的地方开始
在脚本开始时，确切cd到已知目录，这么一来，接下来的任何相对路径名称才能
指到已知位置。请确认cd操作成功：
cd app-dir 11 exit 1
在命令上使用完整路径
这么微你才能知道自已使用的是哪个版本，无须理会SPATH设置。
使用syslog（8）保留审计跟踪
记录引l用的日期与时间、username等，参见logger（1）的使用手册。如果你没有
logger，可建立一个函数保留日志文件：
1ogger {1 [
(exep/uta/)s 。xe (s8sns)。(un- p1)s.zosn Aq urg。 za05oT
www.TopSage.com
---
## Page 438
426
第15章
当使用该输人时，一定将用户输人引用起来
例如：*$1"与“$*'，这么做可以防止居心不良的用户输人作超出范围的计算与执
行。
勿在用户输人上使用eval
甚至在引用用户输人之后，也不要使用eval将它交给Shell再处理。如果用户读
了你的脚本，发现你使用eva1，就能很轻松地利用这个脚本进行任何破坏。
引用通配字符展开的结果
你可以将空格、分号、反斜杠等放在文件名里，让棘手的事情交给系统管理员处理。
如果管理的脚本未引用文件名参数，此脚本将会造成系统出问题。
检查用户输人是否有meta字符
如果使用eval或$（...）里的输入，请检查是否有像$或（旧式命令替换）这
类的meta字符。
检测你的代码，并小心谨慎阅读它
寻找是否有可被利用的漏洞与错误。把所有坏心眼的想法都考虑进去，小心研究你
的代码，试着找出破坏它的方式，再修正你发现的所有问题。
留意竞争条件（racecondition）
攻击者是不是可以在你脚本里的任两个命令之间执行任意命令，这对安全性是否有
危害？如果是，换个方式处理你的脚本吧！
对符号性连接心存怀疑
在chmod文件或是编辑文件时，检查它是否真的是一个文件，而非连接到某个关
键性系统文件的符号性连接（利用（-Lfile1或（-hfile1检测file是
否为一符号性连接）。
找其他人重新检查你的程序，看看是否有问题
通常另一双眼睛才能找出原作者在程序设计上陷入的盲点。
尽可能用setgid而不要用setuid
这些术语在本章稍后有探讨。简而言之，使用setgid能将损害范围限制在某个组内。
使用新的用户而不是root
如果你必须使用setuid访间一组文件，请考虑建立一个新的用户，非root的用户
做这件事并设置setuid给它。
尽可能限制使用setuid的代码
尽可能让setuid代码减到最少。将它移到一个分开的程序，然后在大型脚本里有需
要时才引用它。无论如何，请做好代码防护，好像脚本可以被任何人于任何地方引