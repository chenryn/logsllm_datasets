[ WHEN boolean-expression THEN
statements ] ...]
[ ELSE
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 221
Database Compatibility for Oracle® Developers Guide
statements ]
END CASE;
boolean-expression is evaluated in the order in which it appears within the CASE
statement. When the first boolean-expression is encountered that evaluates to TRUE,
the statement(s) in the corresponding THEN clause are executed and control continues
following the END CASE keywords. If none of boolean-expression evaluates to
TRUE, the statement(s) following ELSE are executed. If none of boolean-expression
evaluates to TRUE and there is no ELSE clause, an exception is thrown.
The following example uses a searched CASE statement to assign a department name and
location to a variable based upon the department number.
DECLARE
v_empno emp.empno%TYPE;
v_ename emp.ename%TYPE;
v_deptno emp.deptno%TYPE;
v_dname dept.dname%TYPE;
v_loc dept.loc%TYPE;
CURSOR emp_cursor IS SELECT empno, ename, deptno FROM emp;
BEGIN
OPEN emp_cursor;
DBMS_OUTPUT.PUT_LINE('EMPNO ENAME DEPTNO DNAME '
|| ' LOC');
DBMS_OUTPUT.PUT_LINE('----- ------- ------ ----------'
|| ' ---------');
LOOP
FETCH emp_cursor INTO v_empno, v_ename, v_deptno;
EXIT WHEN emp_cursor%NOTFOUND;
CASE
WHEN v_deptno = 10 THEN v_dname := 'Accounting';
v_loc := 'New York';
WHEN v_deptno = 20 THEN v_dname := 'Research';
v_loc := 'Dallas';
WHEN v_deptno = 30 THEN v_dname := 'Sales';
v_loc := 'Chicago';
WHEN v_deptno = 40 THEN v_dname := 'Operations';
v_loc := 'Boston';
ELSE v_dname := 'unknown';
v_loc := '';
END CASE;
DBMS_OUTPUT.PUT_LINE(v_empno || ' ' || RPAD(v_ename, 10) ||
' ' || v_deptno || ' ' || RPAD(v_dname, 14) || ' ' ||
v_loc);
END LOOP;
CLOSE emp_cursor;
END;
The following is the output from this program.
EMPNO ENAME DEPTNO DNAME LOC
----- ------- ------ ---------- ---------
7369 SMITH 20 Research Dallas
7499 ALLEN 30 Sales Chicago
7521 WARD 30 Sales Chicago
7566 JONES 20 Research Dallas
7654 MARTIN 30 Sales Chicago
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 222
Database Compatibility for Oracle® Developers Guide
7698 BLAKE 30 Sales Chicago
7782 CLARK 10 Accounting New York
7788 SCOTT 20 Research Dallas
7839 KING 10 Accounting New York
7844 TURNER 30 Sales Chicago
7876 ADAMS 20 Research Dallas
7900 JAMES 30 Sales Chicago
7902 FORD 20 Research Dallas
7934 MILLER 10 Accounting New York
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 223
Database Compatibility for Oracle® Developers Guide
3.5.6 Loops
With the LOOP, EXIT, CONTINUE, WHILE, and FOR statements, you can arrange for your
SPL program to repeat a series of commands.
3.5.6.1 LOOP
LOOP
statements
END LOOP;
LOOP defines an unconditional loop that is repeated indefinitely until terminated by an
EXIT or RETURN statement.
3.5.6.2 EXIT
EXIT [ WHEN expression ];
The innermost loop is terminated and the statement following END LOOP is executed
next.
If WHEN is present, loop exit occurs only if the specified condition is TRUE, otherwise
control passes to the statement after EXIT.
EXIT can be used to cause early exit from all types of loops; it is not limited to use with
unconditional loops.
The following is a simple example of a loop that iterates ten times and then uses the EXIT
statement to terminate.
DECLARE
v_counter NUMBER(2);
BEGIN
v_counter := 1;
LOOP
EXIT WHEN v_counter > 10;
DBMS_OUTPUT.PUT_LINE('Iteration # ' || v_counter);
v_counter := v_counter + 1;
END LOOP;
END;
The following is the output from this program.
Iteration # 1
Iteration # 2
Iteration # 3
Iteration # 4
Iteration # 5
Iteration # 6
Iteration # 7
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 224
Database Compatibility for Oracle® Developers Guide
Iteration # 8
Iteration # 9
Iteration # 10
3.5.6.3 CONTINUE
The CONTINUE statement provides a way to proceed with the next iteration of a loop
while skipping intervening statements.
When the CONTINUE statement is encountered, the next iteration of the innermost loop is
begun, skipping all statements following the CONTINUE statement until the end of the
loop. That is, control is passed back to the loop control expression, if any, and the body
of the loop is re-evaluated.
If the WHEN clause is used, then the next iteration of the loop is begun only if the specified
expression in the WHEN clause evaluates to TRUE. Otherwise, control is passed to the next
statement following the CONTINUE statement.
The CONTINUE statement may not be used outside of a loop.
The following is a variation of the previous example that uses the CONTINUE statement to
skip the display of the odd numbers.
DECLARE
v_counter NUMBER(2);
BEGIN
v_counter := 0;
LOOP
v_counter := v_counter + 1;
EXIT WHEN v_counter > 10;
CONTINUE WHEN MOD(v_counter,2) = 1;
DBMS_OUTPUT.PUT_LINE('Iteration # ' || v_counter);
END LOOP;
END;
The following is the output from above program.
Iteration # 2
Iteration # 4
Iteration # 6
Iteration # 8
Iteration # 10
3.5.6.4 WHILE
WHILE expression LOOP
statements
END LOOP;
The WHILE statement repeats a sequence of statements so long as the condition
expression evaluates to TRUE. The condition is checked just before each entry to the loop
body.
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 225
Database Compatibility for Oracle® Developers Guide
The following example contains the same logic as in the previous example except the
WHILE statement is used to take the place of the EXIT statement to determine when to
exit the loop.
Note: The conditional expression used to determine when to exit the loop must be
altered. The EXIT statement terminates the loop when its conditional expression is true.
The WHILE statement terminates (or never begins the loop) when its conditional
expression is false.
DECLARE
v_counter NUMBER(2);
BEGIN
v_counter := 1;
WHILE v_counter <= 10 LOOP
DBMS_OUTPUT.PUT_LINE('Iteration # ' || v_counter);
v_counter := v_counter + 1;
END LOOP;
END;
The same result is generated by this example as in the prior example.
Iteration # 1
Iteration # 2
Iteration # 3
Iteration # 4
Iteration # 5
Iteration # 6
Iteration # 7
Iteration # 8
Iteration # 9
Iteration # 10
3.5.6.5 FOR (integer variant)
FOR name IN [REVERSE] expression .. expression LOOP
statements
END LOOP;
This form of FOR creates a loop that iterates over a range of integer values. The variable
name is automatically defined as type INTEGER and exists only inside the loop. The two
expressions giving the loop range are evaluated once when entering the loop. The
iteration step is +1 and name begins with the value of expression to the left of .. and
terminates once name exceeds the value of expression to the right of ... Thus the two
expressions take on the following roles: start-value .. end-value.
The optional REVERSE clause specifies that the loop should iterate in reverse order. The
first time through the loop, name is set to the value of the right-most expression; the
loop terminates when the name is less than the left-most expression.
The following example simplifies the WHILE loop example even further by using a FOR
loop that iterates from 1 to 10.
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 226
Database Compatibility for Oracle® Developers Guide
BEGIN
FOR i IN 1 .. 10 LOOP
DBMS_OUTPUT.PUT_LINE('Iteration # ' || i);
END LOOP;
END;
Here is the output using the FOR statement.
Iteration # 1
Iteration # 2
Iteration # 3
Iteration # 4
Iteration # 5
Iteration # 6
Iteration # 7
Iteration # 8
Iteration # 9
Iteration # 10
If the start value is greater than the end value the loop body is not executed at all. No
error is raised as shown by the following example.
BEGIN
FOR i IN 10 .. 1 LOOP
DBMS_OUTPUT.PUT_LINE('Iteration # ' || i);
END LOOP;
END;
There is no output from this example as the loop body is never executed.
Note: SPL also supports CURSOR FOR loops (see Section 3.8.7).
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 227
Database Compatibility for Oracle® Developers Guide
3.5.7 Exception Handling
By default, any error occurring in an SPL program aborts execution of the program. You
can trap errors and recover from them by using a BEGIN block with an EXCEPTION
section. The syntax is an extension of the normal syntax for a BEGIN block:
[ DECLARE
declarations ]
BEGIN
statements
EXCEPTION
WHEN condition [ OR condition ]... THEN
handler_statements
[ WHEN condition [ OR condition ]... THEN
handler_statements ]...
END;
If no error occurs, this form of block simply executes all the statements, and then
control passes to the next statement after END. If an error occurs within the
statements, further processing of the statements is abandoned, and control passes to
the EXCEPTION list. The list is searched for the first condition matching the error that
occurred. If a match is found, the corresponding handler_statements are executed,
and then control passes to the next statement after END. If no match is found, the error
propagates out as though the EXCEPTION clause were not there at all. The error can be
caught by an enclosing block with EXCEPTION; if there is no enclosing block, it aborts
processing of the subprogram.
The special condition name OTHERS matches every error type. Condition names are not
case-sensitive.
If a new error occurs within the selected handler_statements, it cannot be caught by
this EXCEPTION clause, but is propagated out. A surrounding EXCEPTION clause could
catch it.
The following table lists the condition names that may be used:
Table 3-2 Exception Condition Names
Condition Name Description
The application has encountered a situation where none of the
CASE_NOT_FOUND cases in a CASE statement evaluates to TRUE and there is no ELSE
condition.
The application has attempted to invoke a collection method on a
COLLECTION_IS_NULL
null collection such as an uninitialized nested table.
The application has attempted to open a cursor that is already
CURSOR_ALREADY_OPEN
open.
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 228
Database Compatibility for Oracle® Developers Guide
Condition Name Description
The application has attempted to store a duplicate value that
DUP_VAL_ON_INDEX
currently exists within a constrained column.
INVALID_CURSOR The application has attempted to access an unopened cursor.
The application has encountered a data exception (equivalent to
INVALID_NUMBER SQLSTATE class code 22). INVALID_NUMBER is an alias for
VALUE_ERROR.
NO_DATA_FOUND No rows satisfy the selection criteria.
The application has encountered an exception that hasn’t been
OTHERS
caught by a prior condition in the exception section.
The application has attempted to reference a subscript of a nested
SUBSCRIPT_BEYOND_COUNT
table or varray beyond its initialized or extended size.
The application has attempted to reference a subscript or extend a
SUBSCRIPT_OUTSIDE_LIMIT
varray beyond its maximum size limit.
The application has encountered more than one row that satisfies
TOO_MANY_ROWS the selection criteria (where only one row is allowed to be
returned).
The application has encountered a data exception (equivalent to
VALUE_ERROR SQLSTATE class code 22). VALUE_ERROR is an alias for
INVALID_NUMBER.
ZERO_DIVIDE The application has tried to divide by zero.
User-defined Exception See Section 3.5.8
Note: Condition names INVALID_NUMBER and VALUE_ERROR are not compatible with
Oracle databases for which these condition names are for exceptions resulting only from
a failed conversion of a string to a numeric literal. In addition, for Oracle databases, an
INVALID_NUMBER exception is applicable only to SQL statements while a
VALUE_ERROR exception is applicable only to procedural statements.
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 229
Database Compatibility for Oracle® Developers Guide
3.5.8 User-defined Exceptions
Any number of errors (referred to in PL/SQL as exceptions) can occur during program
execution. When an exception is thrown, normal execution of the program stops, and
control of the program transfers to the error-handling portion of the program. An
exception may be a pre-defined error that is generated by the server, or may be a logical
error that raises a user-defined exception.
User-defined exceptions are never raised by the server; they are raised explicitly by a
RAISE statement. A user-defined exception is raised when a developer-defined logical
rule is broken; a common example of a logical rule being broken occurs when a check is
presented against an account with insufficient funds. An attempt to cash a check against
an account with insufficient funds will provoke a user-defined exception.
You can define exceptions in functions, procedures, packages or anonymous blocks.
While you cannot declare the same exception twice in the same block, you can declare
the same exception in two different blocks.
Before implementing a user-defined exception, you must declare the exception in the
declaration section of a function, procedure, package or anonymous block. You can then
raise the exception using the RAISE statement:
DECLARE
exception_name EXCEPTION;
BEGIN
...
RAISE exception_name;
...
END;
exception_name is the name of the exception.
Unhandled exceptions propagate back through the call stack. If the exception remains
unhandled, the exception is eventually reported to the client application.
User-defined exceptions declared in a block are considered to be local to that block, and
global to any nested blocks within the block. To reference an exception that resides in an
outer block, you must assign a label to the outer block; then, preface the name of the
exception with the block name:
block_name.exception_name
Conversely, outer blocks cannot reference exceptions declared in nested blocks.
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 230
Database Compatibility for Oracle® Developers Guide
The scope of a declaration is limited to the block in which it is declared unless it is
created in a package, and when referenced, qualified by the package name. For example,
to raise an exception named out_of_stock that resides in a package named
inventory_control a program must raise an error named:
inventory_control.out_of_stock
The following example demonstrates declaring a user-defined exception in a package.
The user-defined exception does not require a package-qualifier when it is raised in
check_balance, since it resides in the same package as the exception:
CREATE OR REPLACE PACKAGE ar AS
overdrawn EXCEPTION;
PROCEDURE check_balance(p_balance NUMBER, p_amount NUMBER);
END;
CREATE OR REPLACE PACKAGE BODY ar AS
PROCEDURE check_balance(p_balance NUMBER, p_amount NUMBER)