(1) Binder Interface Recognition. We determine whether this
function is a member function of a Binder interface, and if so,
we record the member function and its parameter information
for the Binder interface.
(2) Reachability Analysis. For each Binder interface, we check
whether its proxy can be acquired by an application, either
directly replied by ServiceManager or sent by other reachable
Binder interfaces as a sub-interface.
(3) Screening for TBIs and CBIs. For each reachable Binder in-
terface, we check whether it can receive IBinder objects by
recursively decomposing the parameters in its member func-
tions. A Binder Interface is a TBI if it is reachable, and at least
one of its interface functions accepts IBinder objects. The same
process also gives us the list of CBIs, which are IBinder objects
that can be transmitted to TBIs.
4.2 Binder Interface Recognition
Our Method. Previous studies [3, 32] recognize Binder interfaces
and extract their functions in the (un)marshalling process of a
Binder server ( 6 or 7 in Fig. 2). However, this method is gradu-
ally invalidated by the adoption of SafeInterface [5], which hides
the details of (un)marshalling from both the developers and the
analyzers. Therefore, we alternatively recognize Binder interfaces
by analyzing the inheritance relationships, which also guarantees
an accurate list of Binder interfaces. The same process also gives us
the function parameters of each interface function and the types of
these parameters. Compared to previous studies, this approach has
an additional benefit of facilitating vulnerability confirmation and
further exploitation, as the function names and argument types are
preserved, which ensure that the PoRs we generated to confirm
the attacks (Sect. 6.1) are (1) syntactically correct, therefore have
a high success rate, and (2) human-readable, therefore facilitate
the subsequent privilege escalation attacks, whose discovery often
requires human involvement.
Fingerprinting Binder Interfaces. As shown in Fig. 1, there are
five interfaces/classes associated with a Binder interface: a general
interface IInterface deriving all C++ Binder interfaces; an interface
definition class extending IInterface; a Binder proxy class with prefix
Bp; a Binder native class with prefix Bn; the Binder serverâ€™s actual
implementation class extending the Bn class. Among these classes,
we choose the Binder proxy class with prefix Bp as a fingerprint to
identify Binder interfaces and hence their member functions, based
on the following reasoning.
Taking the classes in Fig. 1 as an example, all the functions de-
fined in the Binder interface IAudioFlinger are implemented in its Bp
classes. Consequently, by verifying whether a function is a member
function of a Bp class, we learn the exact set of Binder interface
functions. In contrast, if a function has a Bn class or IInterface in its
class inheritance chain, it may not be a Binder interface function,
as some functions in AudioFlinger are not declared in IAudioFlinger
due to the multiple inheritance feature in C++.
Verifying Binder Interface Functions. We are now ready to de-
scribe our Binder interface recognition process. When LLVM feeds
our plugin with a function, we first recover its original namespace
and class nameâ€”which is available if it is a class member functionâ€”
via a process called demangling. The recovered class name is cross-
checked with the type name extracted from the functionâ€™s this
pointer. If the class name matches the type name, we are certain
that this function is a class member function. We check whether a
class member function is a Binder proxy function by verifying both
of the following conditions: (1) its class inherits IInterface indirectly.
(2) its class does not implement the onTransact function, which is
a symbol of Bn classes. When both conditions are met, we get the
Binder interface name, which is the parent class of the Bp class, and
all interface functions associated with this Binder interface. After
enumerating all Android functions, we now have the complete list
of Binder interfaces and their functions.
4.3 Reachability Analysis
A Binder interface serves as a TBI only if its proxy can be acquired
by an application. The attacker may get the Binder proxy either
by querying ServiceManager or by interacting with a reachable
Binder server, which returns a sub-interface. The latter case has
three caveats: first, sub-interfaces can be nestedâ€”i.e., a sub-interface
may return another sub-interface; second, not all sub-interfaces are
transmitted as return valuesâ€”some are passed to the application
among the out parameters, e.g., those of the TBI ICameraService [6];
third, the received sub-interface may be encapsulated in a sub-field,
either in a Parcelable object or a pointer whose type is opaque and
LLVM fails to extract.
With these caveats in mind, we design our reachability analysis
as follows, whose pseudocode is in Appendix D.
Session 5D: Misc: Android and Vulnerabilities CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1587CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea
Xiaobo Xiang, Ren Zhang, Hanxiang Wen, Xiaorui Gong (cid:66), and Baoxu Liu
Step 1: Querying ServiceManager. We execute the service list
command in a running device, which returns all the Binder inter-
faces registered in ServiceManager. We add them in a set called
Reachables.
Step 2: Listing the Return Values and Out Parameters. Our
results from Sect. 4.2 allow us to list all the member functions of
the newly added elements in Reachables. We then compose a list of
these functionsâ€™ return values and out parameters, named Values.
The return values are extracted by querying the functionâ€™s sret
attribute via an LLVM API. We manually inspect all these functions
to list the out parameters. We observe an interesting fact that could
speed up future processing: out parameters are passed to a function
by pointer, whereas in parameters are passed either by value or by
reference.
Step 3: Decomposing the Return Values and Out Parameters.
Now we screen the list Values for IBinder objects. All primitive types
are dropped. IBinder objects are added to Reachables. A non-IBinder
synthetic type is further decomposed, whose member elements are
added to the end of the list for screening.
Dealing with pointers brings another challenge, as a pointer may
refer to an opaque type, whose definition is in another file. Storing
all the definitions of opaque types would significantly downgrade
the efficiency of our plugin. To tackle this challenge, we introduce
two rounds of pre-processing: the first round records all the opaque
type names in all Binder interface functionsâ€™ arguments and return
values; the second round records the definitions of these opaque
types. Therefore, when encountering an opaque type in Values, we
can look up its definition in our pre-processing results, which are
a lot smaller than all the opaque type definitions in Android. The
decomposition process continues until Values is empty.
Steps 2 and 3 are executed repeatedly until all elements in Reachables
are processed and Values is empty.
4.4 Screening for TBIs and CBIs
After identifying the reachable Binder interfaces, we can now tra-
verse them to get the lists of TBIs and CBIs. We start by composing
a list of all the member functions of Binder interfaces in Reachables.
For each member function in the list, we decompose all its input
parameters to look for attacker-customizable IBinder objects. We
omit the details as the decomposition process is very similar to Step
3 in our reachability analysis. For each customizable IBinder object,
we mark the member function as a TBIF, its corresponding Binder
interface as a TBI, and the IBinder objectâ€™s corresponding Binder
interface as a CBI. The TBIF-CBI connections are also recorded in
a call graph database.
Figure 4: The relationships between TBIs (blue) and CBIs
(red) in Android 11. On average, a TBI uses 2.07 CBIs and
a CBI can be sent to 1.37 TBIs. A TBI uses at least 1 CBI, at
most 7 CBIs.
Table 1: Statistics of recent Android versionsâ€™ initial stable
releases. We use (+29, -16) to denote that there are 29 CTBIFs
newly introduced in Android 9, and 16 CTBIFs from Android
8 are deprecated.
Release
8.0.0_r1
9.0.0_r1
10.0.0_r1
11.0.0_r1
CBI CBIF
279
52
276
51
320
66
84
340
138 (+29, -16)
178 (+50, -10)
203 (+52, -27)
TBI
46
47
55
57
CTBIF
125
numbers of CTBIFs in Appendix C. There are 340 CBIFs reachable
from TBIs, which will be analyzed further in Sect. 5.
Attack Surface Evolution. With the efforts of the Android team,
the attack surfaces of most Android components have been reduced
and will continue to be reduced [29]. This phenomenon inspires
us to analyze how the BiTRe attack surface evolves. The results
from Android 8 to 11 in Table 1 exhibit an increasing trend in all
the metrics, apart from a slight decrease in CBIs and CBIFs from
Android 8 to 9. This decrease results from the introduction of project
Treble [10], which migrates some Binder interfaces to the hardware
Binder framework, so that hardware-related details are separated
from the operating system.
This growing trend is alarming when compared with many other
attack surfaces. Unfortunately, it is impractical to hope that the
BiTRe attack surface would be reduced in future releases, as Android
will grow only more powerful and support more features.
4.5 Enumeration Results
Statistics in Android 11. The latest Android version is 11 in May
2021, the time of this writing. In release android-11.0.0_1r, we count
1465 Binder interface functions in 176 Binder interfaces, among
which we identify 57 TBIs and 84 CBIs, whose relationships are
visualized in Fig. 4. In these TBIs, 203 member functions accept
customizable IBinder objects. We call these member functions cor-
responding TBIFs (CTBIFs), which are crucial for the attacks as they
serve as the attackerâ€™s entry points. We list the TBIs with the highest
5 ATTACK CAPABILITY ANALYSIS
As CBIs interact directly with the target system service, they are
the key components in launching subsequent attacks. The data
sent from and received by CBIs translate directly to the number
of attack strategies. Specifically, the data received/input from the
system service may contain the userâ€™s private information, or leak
some memory addresses, allowing the attacker to bypass Address
Space Layout Randomization and to pinpoint attack locations and
gadgetsâ€”snippets of code in the target program to facilitate the
useuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseusegenusegenuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseuseusegengengengenusegenuseuseuseusegenuseuseuseuseuseuseuseuseusegenuseusegengengengengengengâ€¦useuseusegenuseuseuseuseuseuseuseuseuseSession 5D: Misc: Android and Vulnerabilities CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1588Ghost in the Binder: Binder Transaction Redirection Attacks in Android System Services
CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea
attack. Sending/outputting data to the system service is more dam-
aging as it may directly trigger some undefined behaviors, such as
affecting the serviceâ€™s control flow or causing memory corruption.
Given the importance of CBIsâ€™ input and output capabilities,
in this section, we measure these capabilities via a new metric
called Interface Complexity, and then rank all CBIs based on this
metric, which provides valuable guidance in our later vulnerability
discovery.
5.1 Interface Complexity: Definition
Our Interface Complexity metric generalizes the attack surface met-
ric [34] by decomposing the functions to their inputs and outputs
and assigning weights according to their data types. To compute
Interface Complexity, denoted as ð¶IO, of a CBI ð‘, we first decom-
pose its member functionsâ€™ inputs and outputs into four data types,
whose names are abbreviated from primitive, array, container, and
Binder:
Pr. All primitive types with fixed lengths, such as integer, bool,
char, and float.
Ar. A known number of fixed-size elements, which can either be
of primitive types or fixed-size objects.
Co. A flexible number of fixed-size elements. Typical containers
are vectors, maps, and sets.
B. A transactable element referring to another Binder Interface.
We omit our CBI decomposition process as it is identical to that of
(ð‘), and ð‘›Co
I (ð‘), ð‘›Ar
(ð‘)
TBIs (Steps 2 and 3 in Sect. 4.3). We use ð‘›Pr
I
I
to denote the numbers of primitive, array, and container items after
O (ð‘), and ð‘›Co
O (ð‘), ð‘›Ar
O (ð‘)
ð‘â€™s input decomposition, respectively; ð‘›Pr
denote the corresponding counts in ð‘â€™s output decomposition. The
set of Binder interfaces are represented by ðµI(ð‘) and ðµO(ð‘). Then
we assign a weight value to each decomposed item of the first
three types, based on (1) whether it is decomposed from an input
parameter or an output, and (2) its data type. An intermediate result
(ð‘) is calculated as the total weight of the first three types:
ð¶Pr,Ar,Co
IO
ð¶Pr,Ar,Co
IO
(ð‘) = ð‘¤Pr
Â· ð‘›Pr
I (ð‘) + ð‘¤Ar
Â· ð‘›Ar
(ð‘) + ð‘¤Co
Â· ð‘›Co
(ð‘)
I
I
I
I
I
O (ð‘) .
O Â· ð‘›Co
O (ð‘) + ð‘¤Co
O Â· ð‘›Ar
O (ð‘) + ð‘¤Ar
O Â· ð‘›Pr
+ ð‘¤Pr
(ð‘)
The actual Interface Complexity is calculated by adding ð¶Pr,Ar,Co
IO
with the discounted sum of all decomposed Binder items in its inputs
and outputs:
ð¶IO(ð‘) = ð¶Pr,Ar,Co
IO
(ð‘) + ð›¼I
ð¶Pr,Ar,Co
IO
(ð‘â€²)
+ ð›¼O
ð¶Pr,Ar,Co
IO
(ð‘â€²) ,


ð‘â€²âˆˆðµI(ð‘)
ð‘â€²âˆˆðµO(ð‘)
where ð›¼I and ð›¼O are two discount factors. The last step can be
iterated to incorporate the Binder items referred to by members
of ðµI(ð‘) and ðµO(ð‘). However, such extra complexity does not con-
tribute to the accuracy in our case.
As an initial attempt, we assign weights 1, 2, 2 to the first three
data types, regardless of whether the item is from the inputs or the
outputs, and choose ð›¼I = ð›¼O = 1. This simple Interface Complex-
ity definition already manifests its usefulness in our later attack
confirmation.
5.2 Interface Complexity: Results
CBIs with High ð¶IO(ð‘) and Type I Attacks. We calculated the
Interface Complexity of all CBIs in Android 11, and selectively list
some results in Table 2. Most vulnerabilities we discoveredâ€”20 out
of 26â€”reside in CBIs with the highest Interface Complexity, proving
a strong correlation between Interface Complexity and attack capa-
bility. These 20 vulnerabilities cover all Type I attacks in Sect. 6.2,
which include four CVEs out of the ten CVEs corresponding to this
study. We release the complete Interface Complexity results1 to
help Android developers and security researchers prioritize their
efforts.
CBIs with Non-Empty ðµO(Â·) & ðµI(Â·) and Type II & III Attacks.
By decomposing a CBI ð‘, we get the set of CBIs that ð‘ can send to
TBIs, i.e., ðµO(ð‘), and the set of TBIs ð‘ can receive, i.e., ðµI(ð‘). We
call members of ðµO(ð‘) sub-CBIs and members of ðµI(ð‘) sub-TBIs. We
pay special attention to these sets in our vulnerability discovery, as
these attack portals involving multiple CBIs or TBIs are stealthier
than the others. We use Type II attacks to denote vulnerabilities
involving sub-CBIs, and Type III for sub-TBIs. Of these two types,
we found six vulnerabilities that lead to six CVEs (cf. Sect. 6.2).
6 CONFIRMING THE BITRE ATTACKS
A complete BiTRe attack involves two phases: preparation phase
(Steps 0 to 4 in Sect. 3.3), during which the attacker process
transacts with the TBI and induces it to call a CBIF as a Binder
client, and attacking phase (Step 5 ), during which the CBI launches
various attacks. We explore these two phases separately.
For the preparation phase, as the attacker can almost always
trick a TBI server into transacting with the evil CBI by mimicking a
benign application, there is no need to analyze its feasibility. There-
fore, we turn to demonstrate the attacksâ€™ efficiency by building an
automatic system, which generates PoR programs to transact with
TBIs, hoping to induce them to call CBIFs without any knowledge
of the Binder interfacesâ€™ semantics.
For the attacking phase, we manually review the source code and
perform dynamic tests on more than half of the CBIs, starting from
those with the highest Interface Complexity. We find 26 vulnerabil-
ities listed in Table 5 in Appendix E with different root causes and
crash points, categorize them into three types, and introduce the
characteristics of these types.
6.1 Preparation Phase: PoR Generation
Overview. Our PoRs do not trigger or exploit vulnerabilities; we
consider a PoR successful if a role-reversal transaction involving a
new TBI-CBIF pair is initiated. We leave the fully automatic discov-
ery of BiTRe vulnerabilities to future work. Our system consists of
two components: a PoR generator and a PoR executor. The former
generates executable PoR programs targeting each TBI-CBIF pair,
and feeds them to the PoR executor, which executes the PoR in
an Android device. The process repeats until the CBIF is invoked,
at which time the PoR is recorded. Each PoR is a combination of
a plausible TBIF calling sequence and a set of plausible inputs to
these TBIFs. The success of a PoR relies on generating the correct
calling sequence and the inputs, which is explained next.
1https://github.com/xiangxiaobo/BiTRe
Session 5D: Misc: Android and Vulnerabilities CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1589CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea
Xiaobo Xiang, Ren Zhang, Hanxiang Wen, Xiaorui Gong (cid:66), and Baoxu Liu
Table 2: CBIs with the highest Interface Complexity. Those where we discover vulnerabilities are in bold, with the number of
vulnerabilities in parentheses. CBIs with rankings are from Android 11; IGraphicBufferConsumerâ€™s vulnerabilities are from
Android 7â€”it is no longer a CBI in Android 11. INPUT_CAP and OUTPUT_CAP are the data types involved in the CBIâ€™s input
parameters and outputs, respectively.
Rank CBI Name
Interface Complexity ð¶IO(Â·)
1
2
3
*
4
5
...
30
31
...
IMediaPlayer
IRemoteDisplayClient
IGraphicBufferProducer (11)
IGraphicBufferConsumer (9)
IIdentityCredential
ICredential
...
IDataSource (4)
IPullAtomCallback (2)
...
875
506
492
432
382
282
...
31
28
...
INPUT_CAP
{Pr, Ar, Co, B}
{Pr, Ar, B}
{Pr, Ar, Co, B}
{Pr, Ar, Co, B}
{Pr, Ar, Co}
{Pr, Ar, Co}
...
{Pr}
{Pr, Ar, B}
...
OUTPUT_CAP
{Pr, Ar}
{Pr}
{Pr, Ar}
{Pr}
{Pr, Ar}
{Pr, Ar}
...
{Pr, Ar, B}
{Ar}
...
Calling Sequence Generation. To trigger a CBIF, we first locate
its CTBIF (TBIF that calls the CBIF) by searching the call graph
database established in Sect. 4.4. If we are lucky, a direct invocation
of the CTBIF completes the job already. However, invoking the
CBIF often requires the TBI server to be in a specific state, which
further requires the application to invoke the correct sequence
of TBIFs. Unfortunately, it is infeasible to directly extract such a
sequence, as it requires a deep understanding of the TBIâ€™s semantics.
We observe, after reviewing the documents, that such a calling
sequence usually involves only a small number of TBIFs. Therefore
we adopt a strategy inspired by fuzz testing, which randomly calls
some TBIFs before invoking the CTBIF, hoping to set the TBI server
in the correct state. This simple strategy proves effective.
Input Generation. Our Binder interface recognition (Sect. 4.2)
gave us the syntax information of the TBIF inputs already. We can
therefore utilize this information to generate all the primitive type
inputs and to mutate them during fuzzing.
The remaining challenge is to generate semantically correct
synthetic-type inputsâ€”usually class or structure objects. We first
search for existing TBIFs that output the object. Their outputs
are often semantically correct as these functions are provided by
the system. When such functions are not available, we prefer the
objectâ€™s constructor, as it often presets legal default values of its
members. If the constructor cannot provide a valid object either, our
system constructs the object from scratch. We developed a Clang
plugin during building the AOSP to extract the type information
along with each memberâ€™s name in each class/structure. With the
type information, we decompose the object one layer at a time and
try the aforementioned methods to construct its synthetic type
elements, rather than decomposing the object directly to primitive
type items as in Sect. 4.3. We also manually prepare 15 generators
for some types that are particularly difficult to construct, e.g., those
with magic number fields that must be set to specific values.
Executing the Prototype System. We execute our PoR generator
in a Ubuntu 20.04 system with an Intel Core i7-6700 @ 3.40GHz
processor and 32G RAM. The PoR executor runs on a Google Pixel
3 device with the build tag android-11.0.0_r1.
During the process, we discover another method to affect the
TBIâ€™s control flow from a CBI. Specifically, some TBIs create a death
recipient for their corresponding CBIs, so that they can conduct
garbage collection once the CBI dies. In other words, the CBI affects
the TBIâ€™s state and control flow without a CBIF invocation.
In 24 hours, our system triggers 57 CBIFs and 24 death recipients,
involving 28 CBIs and 12 TBIs. Selected results are in Appendix B.
The attack portals corresponding to seven CVEs are reachable from
our PoRs, including three Type I and four Type II attacks.
6.2 Attacking Phase: Triggering Vulnerabilities
We find and report to Google 26 vulnerabilities in total, each with its
distinct root cause and crash point. Ten of them are assigned CVEs;
most of the others are marked as duplicates with these ten. We do
not claim to exhaust the attack family as we have not covered all the
TBIs and CBIs, but only the ones with high Interface Complexity,
and those involve sub-CBIs and sub-TBIs (cf. Sect. 5.2). All 26 are
fixed in subsequent Android releases based on our reports. These
vulnerabilities involve four â€œTBI â‡’ CBIâ€ pairs:
â€¢ ISurfaceComposer â‡’ IGraphicBufferProducer with 11 cases;
â€¢ IOMX â‡’ IGraphicBufferConsumer with nine cases;
â€¢ IMediaExtractor â‡’ IDataSource with four cases;
â€¢ IStatsd â‡’ IPullAtomCallback with two cases.
We split these vulnerabilities into four types based on the number
of CBIs and TBIs involved and illustrate them in Fig. 5. Type I
attacks involve only two Binder interfaces: a TBI and a CBI. In Type
II attacks, one TBI and multiple CBIs are involved. The sub-CBI
causes the actual damage. In Type III attacks, one CBI and multiple
TBIs are involved. The attacker leverages the evil CBI to attack the
sub-TBI. In Type IV attacks, multiple TBIs and multiple CBIs are
involved. Sub-CBIs are utilized to attack certain sub-TBIs.
Type I: Direct Attack. Type I is the basic pattern of BiTRe attack,
on which the other three types are based. The attacker constructs
evil CBI Servers and sends malformed data to the TBI, triggering
insecure data- and control-flow vulnerabilities in the TBI.
The workflow of Type I attacks is shown at the end of Sect. 3.3.
All 20 vulnerabilities involving TBIs ISurfaceComposer and IOMX
belong to this type.
A typical example is CVE-2017-0665, where the attacker cus-
tomizes the CBI IGraphicBufferProducer to interact with the TBI
Session 5D: Misc: Android and Vulnerabilities CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1590Ghost in the Binder: Binder Transaction Redirection Attacks in Android System Services
CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea
Figure 5: Four types of BiTRe attacks. In Type I attacks, the CBI sends malformed data to reply to the TBIâ€™s requests. In Type
II attacks, the CBI to launch the attack, i.e., the sub-CBI, is sent to the TBI by the upper CBI. In Type III attacks, the TBI under
attack, i.e., the sub-TBI, is sent to the CBI by the upper TBI. In Type IV attacks, multiple CBIs and TBIs are involved.
ISurfaceComposer. We successfully exploit this vulnerability to hi-
jack the control flow of SurfaceFlinger, which is the actual imple-
mentation of the TBI Server. When an application calls BpSur-
faceComposer::captureScreen() of SurfaceFlinger with an evilly cus-
tomized CBI Server IGraphicBufferProducer, SurfaceFlinger does
not sanitize the return values of the dequeueBuffer() implemented
in CBI IGraphicBufferProducer. The replied position is used to ac-
cess an array named mSlot, leading to out-of-bounds access issue.
The out-of-bounds memory is then converted to an ANativeWin-
dowBuffer object which contains two function pointers. In function
eglCreateImageKHR that is invoked indirectly by the BpSurfaceCom-
poser::captureScreen() , there is a blx r2 instruction. The r2 register
is read from the buffer after being dequeued. As we carefully spray
the heap, we can overwrite the register and eventually hijack the
control flow of the SurfaceFlinger context.
Type II: One TBI, Multiple CBIs. Many Binder interfaces have
functions that return another Binder object. Whenever these Binder
interfaces act as CBIs, we can construct a malicious sub-CBI server
and send it to the TBI via these functions. Compared to Type I
attacks, Type II vulnerabilities are more often ignored by the devel-
opers as the attack portal is nested deeply in the code structure.
We extend TService in Sect. 3.3 to illustrate Type II attacks. In
Line 7 to 9 below, setSubCBI function requests another CBI called
mSubCBI from the CBI:
status_t setCBIProxy (sp  cbi ) {
this -> mCBI = cbi ;
return OK ;
1 class TService : public BnTBI {
2 public :
3
4
5
6
7
8
9
10
}
status_t setSubCBI () {
}
status_t bofBug () {
mSubCBI = mCBI -> getSubCBI () ;
mBuffer [ mSubCBI -> getIndex () ] = 'c '; // no range check
}
11
12
13 private :
14
15
16
17 }
sp  mSubCBI ;
sp  mCBI ;
char mBuffer ;
The attacker then implements two Binder serversâ€”EvilCBIServer
in Line 1 to 5 below for providing the sub-CBI and EvilSubCBIServer
in Line 6 to 11 for returning the malformed index:
}
int getIndex () {
return 0 xdeadbeaf ;
1 class EvilSubCBIServer : public BnSubCBI {
2
3
4
5 };
6 class EvilCBIServer : public BnCBI {
7
8
9
10
11 };
12 int main () {
13
14
sp  getSubCBI () {
}
sp  subCBI = new EvilSubCBIServer ;
return subCBI ;
sp  cbi = new EvilCBIServer ;
sp  service = ServiceManager :: getService (" tservice "
);
service -> setCBIProxy ( cbi ); // set evil cbi
service -> setSubCBI () ; // set sub - CBI
service -> bofBug () ;
// trigger the bof bug .
15
16
17
18 }
The four vulnerabilities involving the TBI IMediaExtractorService
are of this type, with four CVEs assigned. In these cases, IMediaEx-
tractorService requests an IMemory proxy from our CBI IDataSource.
The actual attack is launched from the sub-CBI IMemory. Specifi-
cally, IMediaExtractorService requests the same data multiple times
from IMemory, which allows the attacker to reply with inconsis-
tent data and thus cause a heap-based buffer overflow. The four
vulnerabilities differ in the requested data fields.
CBIFCBIFCBISub-CBITBIFTBITBIFTBICBIFCBICBIFTBIFTBICBITBIFSub-TBIAttackerProcessSystem ProcessSystem ProcessAttackerProcessAttackerProcesssystem processType IType IIType IIITransactions between two Binder InterfacesTransmissions of Binder ObjectsTransmissions of Sub Binder objectsTBICBIFCBITBIF SubObject SenderTBICBIFCBITBIFDangeroustransactionsTBIFTBITBIFSub-TBIsystem processType IVCBIFSub-CBICBIFCBIAttackerProcessReceiverSession 5D: Misc: Android and Vulnerabilities CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1591CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea
Xiaobo Xiang, Ren Zhang, Hanxiang Wen, Xiaorui Gong (cid:66), and Baoxu Liu
Type III: One CBI, Multiple TBIs. When a CBIF has a Binder
object among its input parameters, the corresponding TBI must
construct and send the Binder object to invoke the CBIF. The newly
constructed Binder object has the same privileges as its constructor
TBI, thus attacking it is equally rewarding. However, it is neither
registered in ServiceManager, nor considered as a sub-interface
(sub-interfaces are directly sent by TBI to the application, not via a
CBI), therefore more likely to be overlooked by the developers as
an attack target. Moreover, unlike the previous two types where
the CBI passively waits for the TBI serverâ€™s invocations, in Type
III attacks, the attacker can initiate function calls as it has received
the Binder proxy, therefore enables a comprehensive vulnerability
exploration of the Binder object.
We modify TService again to illustrate these attacks. In Line 14
to 18 below, the TBI declares a sendSubTBI function that initializes
another Binder server and sends it to the CBI as a parameter of the
CBIF callback. The buffer overflow bug is in Line 2 to 4 of SubTBI.
mBuffer [ index ] = 'c '; // no range check
}
char mBuffer [];
void bofBug ( int index ){