过调试寄存器设置的代码断点触发的调试异常属于错误类异常，当错误
类异常发生时，CPU会将机器状态恢复到执行导致异常的指令被执行前
的状态，这样，对于某些错误类异常，比如页错误和除零异常，异常处
理例程可以纠正“错误”情况后重新执行导致异常的指令。
在使用WinDBG调试器调试时，我们可以使用ba命令设置硬件断
点。比如执行命令ba w4 0xabcd后，CPU一旦再对内存地址0xabcd开始
的4字节范围内的任何字节执行写访问，便会产生调试异常。如果把w4
换成r4，那么读写这个内存范围都会触发异常。
4.2.9 归纳
因为以上介绍的断点不需要像软件断点那样向代码中插入软件指
令，依靠处理器本身的功能便可以实现，所以人们习惯上把这些使用调
试寄存器（DR0～DR7）设置的断点称为硬件断点（hardware
breakpoint），以便与软件断点区别开来。
硬件断点有很多优点，但是也有不足，最明显的就是数量限制，因
为只有4个断点地址寄存器，所以每个IA-32 CPU允许最多设置4个硬件
断点，但这基本可以满足大多数情况下的调试需要。
在多处理器系统中，硬件断点是与CPU相关的，也就是说，针对一
个CPU设置的硬件断点并不适用于其他CPU。
还有一点需要说明的是，可以使用调试寄存器来实现变量监视和数
据断点。但并非所有调试器的数据断点功能都是使用调试寄存器来实现
的。举例来说，WinDBG的ba命令及VS2005的C/C++调试器都是使用调
试寄存器来设置数据断点的，但VC6调试器不是这样做的。一旦设置并
启用了数据断点，VC6调试器便会记录下每个变量的当前值，然后以单
步的方式恢复程序执行（下一节将详细讨论单步标志）。这样，被调试
程序执行一条汇编指令后便会因为调试异常而中断到VC6调试器，VC6
调试器收到调试事件后会读取断点列表中的每个数据变量的当前值，并
与它们的保存值相比较，如果发生变化，那么就说明该断点命中，VC6
会显示图4-6所示的对话框。如果没有变化，那么便再设置单步标志，
让被调试程序再执行一条指令。
图4-6 VC6显示的数据断点命中对话框
当显示以上对话框时，修改变量的那条指令已经执行完毕，所以单
击OK按钮后，调试器显示的执行位置箭头指向的是导致变量变化的代
码的下一行。
由于VC6的数据断点功能不是使用调试寄存器设置的，因此没有数
量限制，但这种实现方法的明显缺点是效率低，会导致被调试程序的运
行速度变慢。
4.3 陷阱标志
在4.1节和4.2节中，我们分别介绍了通过INT 3指令设置的软件断点
和通过调试寄存器设置的硬件断点。无论是软件断点还是硬件断点，其
目的都是使CPU执行到指定位置或访问指定位置时中断到调试器。除了
断点，还有一类常用的方法可使CPU中断到调试器，这便是调试陷阱标
志（debug trap flag）。可把陷阱标志想象成一面“令旗”，当有陷阱标志
置起时，CPU一旦检测到符合陷阱条件的事件发生，就会报告调试异常
通知调试器。IA-32处理器所支持的调试陷阱标志共有以下3种。
8086支持的单步执行标志（EFLAGS的TF位）。
386引入的任务状态陷阱标志（TSS的T标志）。
奔腾Pro引入的分支到分支单步执行标志（DebugCtl寄存器中的BTF
标志）。
下面分别详细介绍。
4.3.1 单步执行标志
在x86系列处理器的第一代产品8086 CPU的程序状态字
PSW（Program Status Word）寄存器中有一个陷阱标志位（bit 8），名
为Trap Flag，简称TF。当TF位为1时，CPU每执行完一条指令便会产生
一个调试异常（#DB），中断到调试异常处理程序，调试器的单步执行
功能大多是依靠这一机制来实现的。从80286开始，程序状态字寄存器
改称标志寄存器（FLAGS），80386又将其从16位扩展到32位，简称
EFLAGS，但都始终保持着TF位。
调试异常的向量号是1，因此，设置TF标志会导致CPU每执行一条
指令后都转去执行1号异常的处理例程。在8086和286时代，这个处理例
程是专门用来处理单步事件的。从386开始，当硬件断点发生时也会产
生调试异常，调用1号服务例程，但可利用调试状态寄存器（DR6）来
识别发生的是何种事件。为了表达方便，我们把因TF标志触发的调试异
常称为单步异常（single-step exception）。
单步异常属于陷阱类异常（3.2节介绍了异常的3种类别），也就是
说，CPU总是在执行完导致此类异常的指令后才产生该异常。这意味着
当因单步异常中断到调试器中时，导致该异常的指令已经执行完毕了。
软件断点异常（#BP）和硬件断点中的数据及I/O断点异常也是陷阱类异
常，但是硬件断点中的指令访问异常是错误类异常，也就是说，当由于
此异常而中断到调试器时，相应调试地址寄存器（DRn）中所指地址处
的指令还没有执行。这是因为CPU是在尝试执行下一条指令时进行此类
断点匹配的。
CPU是何时检查TF标志的呢？IA-32手册的原文是“while an
instruction is being executed”（IA-32手册卷3的15.3.1.4 Single-Step
Exception Condition），也就是说，在执行一个指令的过程中。尽管没
有说过程中的哪个阶段（开始、中间还是末尾），但是可以推测应该是
一条指令即将执行完毕的时候。也就是说，当CPU在即将执行完一条指
令的时候检测TF位，如果该位为1，那么CPU就会先清除此位，然后准
备产生异常。但是这里有个例外，对于那些可以设置TF位的指令（例如
POPF），CPU不会在执行这些指令期间做以上检查。也就是说，这些
指令不会立刻产生单步异常，而是其后的下一条指令将产生单步异常。
因为CPU在进入异常处理例程前会自动清除TF标志，所以当CPU中
断到调试器中后再观察TF标志，它的值总是0。
既然调试异常的向量号是1，可不可以像INT 3那样通过在代码中插
入INT 1这样的指令来实现手工断点呢？对于应用程序，答案是否定
的。INT 3尽管具有INT n的形式，但是它具有独特的单字节机器码，而
且其作用就是产生一个断点异常（breakpoint exception，即#BP）。因此
系统对其有特别的对待，允许其在用户模式下执行。而INT 1则不然，
它属于普通的INT n指令，机器码为0xCD01。在保护模式下，如果执行
INT n指令时当前的CPL大于引用的门描述符的DPL，那么便会导致通用
保护异常（#GP）。在Windows 2000和XP这样的操作系统下，INT 1对
应的中断门描述符的DPL为0，这就要求只有内核模式的代码才能执行
INT 1指令，访问该中断门。也就是说，用户模式下的应用程序没有权
利使用INT 1指令。一旦使用，就会导致一个一般保护性异常（#GP），
Windows会将其封装为一个访问违例错误（见图4-7）。在内核模式下，
可以在代码（驱动程序）中写入INT 1指令，CPU执行到该指令时会转
去执行 1 号向量对应的处理例程，如果在使用WinDBG进行内核级调
试，那么会中断到WinDBG中，WinDBG会以为是发生了一个单步异
常。
图4-7 应用程序中执行INT 1指令会导致一般保护性异常
4.3.2 高级语言的单步执行
下面谈谈调试高级语言时的单步机制。由于高级语言的一条语句通
常对应多条汇编指令，例如，在清单4-6中，C++的一条语句
i=a+b*c+d/e+f/g+h对应于15条汇编语句，因此容易想到单步执行这条
C++语句的几种可能方法。第一种是用TF标志一步步地“走过”每条汇编
指令，这种方法意味着会产生15次调试异常，CPU中断到调试器15次，
不过中间的14次都是简单地重新设置起TF标志，便恢复被调试程序执
行，不中断给用户。第二种方法是在C++语句对应的最后一条汇编指令
处动态地插入一条INT 3指令，让CPU一下子跑到那里，然后再单步一
次将被替换的那条指令执行完，这种方法需要CPU中断到调试器两次。
第三种方法是在这条C++语句的下一条语句的第一条汇编指令处（即第
18行）替换入一个INT 3，这样CPU中断到调试器一次就可以了。
清单4-6 高级语言的单步跟踪
1    10:      i=a+b*c+d/e+f/g+h;
2    00401028 8B 45 F8       mov     eax,dword ptr [ebp-8]
3    0040102B 0F AF 45 F4    imul    eax,dword ptr [ebp-0Ch]
4    0040102F 8B 4D FC       mov     ecx,dword ptr [ebp-4]
5    00401032 03 C8          add     ecx,eax
6    00401034 8B 45 F0       mov     eax,dword ptr [ebp-10h]
7    00401037 99             cdq
8    00401038 F7 7D EC       idiv    eax,dword ptr [ebp-14h]
9    0040103B 8B F0          mov     esi,eax
10   0040103D 03 75 E0       add     esi,dword ptr [ebp-20h]
11   00401040 8B 45 E8       mov     eax,dword ptr [ebp-18h]
12   00401043 99             cdq
13   00401044 F7 7D E4       idiv    eax,dword ptr [ebp-1Ch]
14   00401047 03 F1          add     esi,ecx
15   00401049 03 C6          add     eax,esi
16   0040104B 89 45 DC       mov     dword ptr [ebp-24h],eax
17   11:      j=i;
18   0040104E 8B 55 DC       mov     edx,dword ptr [ebp-24h]
19   00401051 89 55 D8       mov     dword ptr [ebp-28h],edx
20   12:
21   13:      if(a)
22   0040D6C4 83 7D FC 00    cmp     dword ptr [ebp-4],0
23   0040D6C8 74 0B          je      main+55h (0040d6d5)
24   14:         i+=a;
25   0040D6CA 8B 45 DC       mov     eax,dword ptr [ebp-24h]
26   0040D6CD 03 45 FC       add     eax,dword ptr [ebp-4]
27   0040D6D0 89 45 DC       mov     dword ptr [ebp-24h],eax
28   15:      else if(b)
29   0040D6D3 EB 20          jmp     main+75h (0040d6f5)
30   0040D6D5 83 7D F8 00    cmp     dword ptr [ebp-8],0
31   0040D6D9 74 0B          je      main+66h (0040d6e6)
32   16:         i+=b;
33   0040D6DB 8B 4D DC       mov     ecx,dword ptr [ebp-24h]
34   0040D6DE 03 4D F8       add     ecx,dword ptr [ebp-8]
35   0040D6E1 89 4D DC       mov     dword ptr [ebp-24h],ecx
36   17:      else if(c)
后两种方法较第一种方法速度会快很多，但不幸的是，并不总能正
确地预测出高级语言对应的最后一条指令和下一条语句的开始指令（要
替换为INT 3的那一条指令）。比如对于第28行的else if（b）语句，就
很难判断出它对应的最后一条汇编语句和下一条高级语言语句的起始指
令。因此，今天的大多数调试器在进行高级语言调试时都是使用第一种
方法来实现单步跟踪的。
关于TF标志，还有一点值得注意，INT n和INTO指令会清除TF标
志，因此调试器在单步跟踪这些指令时，必须做特别处理。
4.3.3 任务状态段陷阱标志
除了标志寄存器中的陷阱标志（TF）位以外，386还引入了一种新
的调试陷阱标志，任务状态段（Task-State Segment，TSS）中的T标
志。任务状态段用来记录一个任务（CPU可以独立调度和执行的程序单
位）的状态，包括通用寄存器的值、段寄存器的值和其他重要信息。当
任务切换时，当前任务的状态会被保存到这个内存段里。当要恢复执行
这个任务时，系统会根据TSS中的保存记录把寄存器的值恢复回来。
在TSS中，字节偏移为100的16位字（word）的最低位是调试陷阱
标志位，简称T标志。如果T标志被置为1，那么当CPU切换到这个任务
时便会产生调试异常。准确地说，CPU是在将程序控制权转移到新的任
务但还没有开始执行新任务的第一条指令时产生异常的。调试中断处理
程序可以通过检查调试状态寄存器（DR6）的BT标志来识别出发生的是
否是任务切换异常。值得注意的是，如果调试器接管了调试异常处理，
而且该处理例程属于一个独立的任务，那么一定不要设置该任务的TSS
段中的T位；否则便会导致死循环。
4.3.4 按分支单步执行标志
在IA-32处理器家族中，所有Pentium Pro、Pentium II和Pentium III处
理器，包括相应的Celeron（赛扬）和Xeon（至强）版本，因为都是基
于相同的P6内核（Core）而被统称为P6处理器。P6处理器引入了一项对
调试非常有用的新功能：监视和记录分支、中断和异常，以及按分支单
步执行（Single-step on branch）。奔腾4处理器对这一功能又做了很大
的增强。下面具体介绍按分支单步执行的功能和使用方法。第5章将介
绍分支、中断和异常记录功能。
首先解释按分支单步执行（Branch Trace Flag，BTF）的含义。前
面介绍过，当EFLAGS寄存器的TF位为1时，CPU每执行完一条指令便
会中断到调试器，即以指令为单位单步执行。顾名思义，针对分支单步
执行就是以分支为单位单步执行，换句话说，每步进（step）一次，
CPU会一直执行到有分支、中断或异常发生。为了行文方便，从现在开
始，我们把发生分支、中断或异常的情况统一称为跳转。
那么，如何启用按分支单步执行呢？简单来说，就是要同时置起TF
和BTF标志。众所周知，TF标志位于EFLAGS中而BTF标志位于
MSR（Model Specific Register）中——在P6处理器中，这个MSR的名字
叫DebugCtlMSR，在奔腾4处理器中被称为DebugCtlA，在奔腾M处理器
中被称为DebugCtlB。BTF位是在这些MSR寄存器的位1中。
下面结合清单4-7中的代码进行说明。
清单4-7 按分支单步执行
1    #define DEBUGCTRL_MSR 0x1D9
2    #define BTF 2
3    int main(int argc, char* argv[])
4    {
5       int m,n;
6       MSR_STRUCT msr;
7    