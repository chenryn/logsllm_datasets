**作者：哈霓@蚂蚁安全实验室  
原文链接：**
在今年的Black Hat Asia上，蚂蚁安全实验室共入选了5个议题和3个工具。本期分享的是蚂蚁天宸实验室的议题《自动化挖掘gRPC网络接口漏洞》。
# 01 简介
随着移动互联网和工业互联网的快速发展，大量开发者、厂商不得不关注网络通讯的实效性和效能问题，而gRPC框架正是基于这样的浪潮下应运而生的网络通讯框架。它是一个高可用、开源的网络库，提供了跨平台的接入能力，在网络开销、性能、安全性上相比HTTP通讯有着极大的优势。然而对于这样的基础设施，业界很少有以端到云的协议通讯视角，进行漏洞挖掘技术的文章。
本次蚂蚁安全实验室的曹世杰，在Black Hat Asia 2021的议题《基于gRPC协议封装的移动/ IoT应用程序的安全漏洞狩猎》中，
对这个方向进行了相关技术分享。
在本议题中，我们提出了一种方法，该方法突破了端上在RPC协议漏洞挖掘的限制，可以为使用gRPC框架的应用程序自动挖掘服务器接口漏洞。
# 02 技术挑战
业界针对gRPC框架在RPC协议下的漏洞挖掘，一直缺少相应方案进行介绍，原因是：
  1. 协议包构造问题： gRPC框架具有特定的组包逻辑，并且传输过程中使用了Protobuf进行数据序列化，在没有理解gRPC框架组包过程的情况下，很难构造一个具有攻击效果的网络数据包。
  2. 端上安全机制绕过： 在客户端应用程序中通常会内置数据签名等安全保护机制。该机制导致在不注入应用程序的情况下，构造的网络数据包极有可能会存在安全校验失败的问题。
由于这些特性，使得在RPC协议下的应用程序，漏洞挖掘变得十分困难。而本次我们在会议中提到的方案，正是解决了客户端上RPC通讯的漏洞挖掘问题。
这应该是首个基于gRPC框架的自动化漏洞挖掘的议题，基于这个框架，我们发现了若干gRPC网络服务的RCE漏洞。这套方案的理念是：从端安全技术的视角，实现对不同应用RPC请求的数据获取与重放能力，以及快速拔插的HUB能力，将不同应用接入到该方案，可将传统WEB漏洞挖掘的思路应用到移动终端。另外一方面，将RPC接口的脆弱性分析部署在云端，极大地提高了漏洞挖掘的准确率和效率。
# 03 什么是gRPC
RPC协议称为远程过程调用，此协议已应用于大量的互联网移动应用程序和IoT设备。该协议的优点是，在C/S模式通信过程中，应用程序仅需知道远程服务的名称和访问远程服务的输入参数，即可获取远程服务的资源。
gRPC是Google提供的，高度可用的RPC框架，已经大规模应用于移动App以及工业互联网领域，在Http2.0以及Protobuf的加持下，具有传输更快、并且能够在传输期间压缩网络数据的优点。
# 04 gRPC框架的组包流程
应用程序通过gRPC框架构造RPC请求的示意图如下。一个RPC请求，由不同的SDK参与构造，其中红色部分，代表网络通讯中不可或缺的数据，包含了Cookie与OperationType。OperationType可以理解为是HTTP请求的路径，告诉服务端网关当前请求对应的RPC应用服务。
而橙色部分，是应用在性能与安全层面进行的优化：1.
通过操作系统提供的API如CCCrypt或者SecurityEnclave实现数据的签名，部分注重安全的厂商会使用自研的安全SDK通过黑盒算法进行签名。2.
将部分设备的环境安全检测信息，放入RPC Header中用于后期的风险防控。3. 通过Protobuf生成Proto对象，压缩网络字节，提高网络效率。
# 05 构建测试系统
针对不同的应用程序，我们开发了大量工具链用于快速开发注入的动态库，实现了端上流量获取以及重放的能力，并且可快捷接入到RPC重放网络，提供对外调用接口。这样的好处是，在漏洞挖掘的过程中，我们将不必关注端上的实现逻辑，仅仅通过几行代码就能实现模拟登录、自动重放的能力。
在整个工程中，我们在工具链中实现的技术包括：
  1. IDAPython调用链分析工具：主要基于IDAPython对gRPC网络接口推导应用程序网络库的函数调用关系，寻找封装gRPC的网络库API。并通过叶子节点寻找构造gRPC数据包所依赖的其他接口（如签名接口、安全检测接口），从而寻找Hook切入点，以及方便接入人员构造注入代码。
  2. 安全模块：通用的安全检测对抗模块，集成通用的安全对抗代码，用于绕过证书校验、模块检查机制。另外针对不同应用程序，通过反射调用的方法实现扩展能力：用于构造协议中的数据签名、解析Protobuf数据块。
  3. 网关注册模块：任务网关的接入模块，负责与任务网关进行设备注册、心跳报活、任务执行。
  4. 任务执行模块：执行网关注册模块下发的任务，基于gRPC框架构造通用的RPC报文，借助安全模块实现签名、数据篡改和安全环境绕过，并进行重放。并负责将重放的返回结果，通过网关注册模块返回给任务中心。
  5. 守护进程模块：保障任务执行设备在遇到Crash的情况下能够主动重启任务进程。
  6. 自动登录模块：用于对不同的应用程序实现模拟登录的能力，通过RPC请求的返回值截获Response中所获取的Cookie，从而在任务执行的过程中自动带上获取的登陆态信息。
下面我们会对其中的一些工具链技术进行介绍：
## 5.1 通过IDAPython进行网络库推导
如上图所示，通过对gRPC网络库的分析，需要梳理出一批接口，作为底层函数向上分析的关系链。以iOS为例，这里的难点在于，iOS应用程序使用了objc_msgsend，以消息通知的方式进行函数调用，所以IDA是无法直接获取关系链的。于是，为了自动推到叶子结点（也就是网络库的根函数），我们使用了下面的方法：
技术点：
1.基于消息的调用方式，需要对sel进行2次关系链查询。
2.引入了Symbol Execution,
需要对引用的Position调用idc.GetDisasm获取上下文并执行推导，来校验objc_msgsend的Class是不是Target
Function引用的Class，否则会出现大量的结果不准确问题。
## 5.2 重放能力的构建
为了能够运行大规模的漏洞测试任务，我们使用了真实的设备构建了任务执行平台。这个平台的优势是：
（1）基于gRPC框架，实现了与真实设备的网络通讯，使得任务下发到执行可以在1-2秒完成。
（2）每台设备的应用程序，都具备守护进程和心跳包，保障任务调度的稳定性，保障平台本身的可用性。
当我们的RPC模块集成到应用程序中，就会向网关对当前设备进行注册。我们定义了一种设备注册的网络格式，用于后期对不同设备不同应用的鉴别，使不同的漏洞测试任务能够快速下发到指定的应用。注册设备的报文如下：
    // 客户端
    Client Heartbeat package :
    client = GRPCAgent.instance
    client.worker = nil;
    client.platfrom = @"iOS/Android";
    client.isHeartBeat = True;
    client.isRun = FALSE;
    client.taskLock = Object;
    // 服务端
    Server Side register：
    executor_info = {
                      'tenant': device_tenant,
                      'did': device_id,
                      'type': device_type,
                      'name': device_name,
                      'cluster': device_cluster,
                      'others': device_others,
                      'last_update': now,
                      'metrics': mobilegw_pb2.DeviceMetrics(),
                      'last_sync_timestamp': now,
                      'task_runner': 0,
                      'app_version': device_app_version,
                      'hook_version': device_hook_version
                  }
相比Android设备，iOS的守护进程保护，显得更加困难。在iOS
8的设备中，我们应用了Mirmir（这是Cydia提供的一个多进程运行的越狱程序，在iOS 8以后就不能使用）对程序本身进行了保护。对于iOS
9以后的越狱设备，我们通过注册守护进程，来实现对应用程序的保护监控：
  1. deamon进程通过注册消息通知的方式，监听全局消息。
  2. 应用程序在遇到不可抗力的Crash崩溃时，通知我们的deamon进程，延时2秒后重新唤起我们的应用程序。
相关代码如下：
    void run_cmd(char *cmd)
    {
        pid_t pid;
        const char *argv[] = {"sh", "-c", cmd, NULL};
        int status;
        status = posix_spawn(&pid, "/bin/sh", NULL, NULL, (char* const*)argv, nil);
        if (status == 0) {