title:12 Angry Developers - A Qualitative Study on Developers' Struggles
with CSP
author:Sebastian Roth and
Lea Gr&quot;ober and
Michael Backes and
Katharina Krombholz and
Ben Stock
A Qualitative Study on Developers’ Struggles with CSP
12 Angry Developers
Sebastian Roth †‡, Lea Gröber †‡, Michael Backes †, Katharina Krombholz †, and Ben Stock †
†CISPA Helmholtz Center for Information Security
‡Saarland University Graduate School of Computer Science
{sebastian.roth,lea.groeber,backes,krombholz,stock}@cispa.de
ABSTRACT
The Web has improved our ways of communicating, collaborating,
teaching, and entertaining us and our fellow human beings. How-
ever, this cornerstone of our modern society is also one of the main
targets of attacks, most prominently Cross-Site Scripting (XSS). A
correctly crafted Content Security Policy (CSP) is capable of effec-
tively mitigating the effect of those Cross-Site Scripting attacks.
However, research has shown that the vast majority of all policies
in the wild are trivially bypassable.
To uncover the root causes behind the omnipresent miscon-
figuration of CSP, we conducted a qualitative study involving 12
real-world Web developers. By combining a semi-structured inter-
view, a drawing task, and a programming task, we were able to
identify the participant’s misconceptions regarding the attacker
model covered by CSP as well as roadblocks for secure deployment
or strategies used to create a CSP.
CCS CONCEPTS
• Security and privacy → Web application security; Usability
in security and privacy.
KEYWORDS
Usable Security, Web Security, Content Security Policy, Roadblocks
ACM Reference Format:
Sebastian Roth †‡, Lea Gröber †‡, Michael Backes †, Katharina Krombholz
†, and Ben Stock †. 2021. 12 Angry Developers A Qualitative Study on
Developers’ Struggles with CSP. In Proceedings of the 2021 ACM SIGSAC
Conference on Computer and Communications Security (CCS ’21), November
15–19, 2021, Virtual Event, Republic of Korea. ACM, New York, NY, USA,
19 pages. https://doi.org/10.1145/3460120.3484780
1 INTRODUCTION
Nowadays, Web applications are getting more and more important
for both business and private life. They evolved from documents
presenting information into sophisticated fully-fledged office and
entertainment applications. Thus, the Web as a platform plays an
essential part of our daily lives. Since critical applications like online
banking are implemented on the Web platform, attacks against its
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea
© 2021 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-8454-4/21/11...$15.00
https://doi.org/10.1145/3460120.3484780
users are getting more severe. One of those attacks is Cross-Site
Scripting (XSS), which is one of the most prevalent security issues
present in Web applications [39], with over 750 CVEs in 2021 [13].
This investigation is supported by research that has shown that
client-side XSS can be discovered on around 8-10% of the top Web
sites [48, 50]. By abusing an XSS vulnerability, an attacker can steal
session cookies to impersonate the victim, perform actions on behalf
of the victim like issuing bank transactions, and a plethora of other
devastating actions. To mitigate the effect of those attacks from the
Web application itself, browsers support Content Security Policy
(CSP). By deploying such a policy, a Web developer can specify
a list of allowed JavaScript sources and prohibit the execution of
inline scripts, making it hard or even impossible for an attacker to
execute their malicious payload.
Although CSP may sound like the holy grail of Web Security, it
suffers from several issues. Research has shown that the majority of
all policies deployed by real-world Web sites are trivially bypassable
because they either allow the execution of inline JavaScript or
allow all resources of a specific scheme [44, 58]. If inline code is
allowed, the attacker can directly inject a script tag or an event
handler that executes the attack payload. In case of allowing a
scheme, e.g., https:, the attacker can inject a script tag that loads
a payload via https: that is under their control. Through free
certificate authorities like Let’s Encrypt [24], attackers can easily
host resources under their control at https: URLs without any
cost or travails.
The fact that policies are insecure in the wild has been doc-
umented by numerous works [7, 44, 49, 58, 59], but the reasons
remained largely hidden. In order to understand the nature of such
insecure practices, Roth et al. [44] investigated the HTML docu-
ments of Web applications. Here, they found high reliance on inline
event handlers, which are not trivial to allow by a CSP. To un-
derstand why developers tend to use old and deprecated security
mechanisms like X-Frame-Options instead of using the easy-to-
use features of CSP for that use case, they also sent out a survey to
those sites. Through this, they discovered that developers are often
not knowledgeable about all CSP capabilities and that its complex
content control mechanism is blocking the easy-to-use features of
CSP for framing control and TLS enforcement. Importantly, none of
the prior works actively focus on the developers and their mindset,
experience, and problems when deploying a CSP.
To close this gap in research regarding CSP, we conducted a study
with 12 developers who are familiar with the development of a CSP.
The study consists of (1) a semi-structured interview, including a
drawing exercise, and (2) a coding task involving creating a CSP
for a small Web application. Our findings suggest that not only the
complexity of the mechanism but also inconsistencies in how the
Session 11C: Software Development and Analysis CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea3085different browsers and frameworks handle and support CSP and
how they report and assist the developer during CSP deployment
cause issues. In addition to that information sources regarding CSP
not only push developers in wrong directions but nearly emphasize
the usage of insecure practices in the policy.
To sum up, our work provides the following contributions:
(1) We present the first qualitative study with 12 real-world Web
developers to evaluate the usability of the CSP.
(2) We investigate the Web developers’ mindset regarding the
different attacker models that CSP covers.
(3) We uncover the root cause of insecure CSP deployment in
order to improve the usability of the security mechanisms’
initial deployment.
(4) We provide a methodological discussion of conducting an
online interview study along with coding and drawing tasks
with developers and share the lessons learned from that.
2 BACKGROUND & RELATED WORK
Due to this work’s focus on misconceptions about CSP and the
usability of CSP deployment, this section describes details about
the security mechanism itself, the threat model that is originally
mitigated by CSP, as well as Web-related user studies, and a brief
overview of qualitative methodologies used in usable security.
2.1 Cross-Site Scripting
The most basic security mechanism incorporated in every browser
is the Same-Origin Policy (SOP). In essence, it protects distrusting
pages from each other by ensuring that only documents with the
same Origin [2], i.e., matching protocol, hostname, and port, can
access each other’s content. By performing a Cross-Site Scripting
(XSS) attack, an adversary can execute JavaScript in the origin of
a vulnerable Web page, and this code has the same capabilities
as the document’s legitimate one. It can modify the page content
to the attacker’s liking, exfiltrate sensitive information such as
session cookies, steal login credentials, or perform any action on
behalf of the victimized user. Since its initial discovery back in
1999 [42] a plethora of publications focus on these attacks [20–
22, 25, 28, 33, 34, 41, 45, 48, 52], their different variants, and their
individual impacts, showing that XSS is here to stay.
2.2 Content Security Policy
XSS attacks can cause severe harm to the users of a Web appli-
cation. In order to mitigate the effect of those unintended code
executions, Stamm et al. [47] introduced the Content Security Pol-
icy (CSP). By deploying such a policy, e.g., via an HTTP header, a
developer can control which sources are allowed for certain types
of resources, such as scripts or images. A policy consists of mul-
tiple (semicolon-separated) directives, each followed by a list of
source expressions. Such an expression is a representation of an
allowed content source for the directive. All the so-called fetch di-
rectives, such as script-src or img-src (for images) fall back to
default-src if the more specific directive is missing. As an exam-
ple, a policy that restricts scripts to be hosted on the same origin
as the including page as well as ad.com and disallows any other
content to be loaded from anywhere can be enforced as follows:
default-src ’none’; script-src ’self’ ad.com;
Implicitly, when either script-src or default-src are deployed,
inline scripts, event handlers, and functions that perform a string-
to-code transformation (e.g., eval) are forbidden. In order to re-
enable these dangerous constructs, a developer can specify the
’unsafe-inline’ or ’unsafe-eval’ source expressions, thereby
explicitly opting out of security.
In CSP’s initial version, inline scripts could only be enabled
through a policy that contains ’unsafe-inline’ [54]. However,
the presence of this expression undermines any protection capa-
bility of CSP, as the attacker can simply inject inline JavaScript
into a vulnerable page. Hence, the only solution to this problem
was to externalize inline scripts, requiring significant engineering
effort. Even though academic approaches to automate this task
exist [15, 40], policies remained insecure from the first analyses in
2014 through 2020 [7, 44, 58, 59].
In order to both ease the way of allowing inline script as well as
improving the security of CSPs in the wild, the second version of
CSP [55] added support for nonces and hashes to the script-src
directive. This mechanism allows the developer to explicitly allow
their scripts. Specifically, they can either add hashes of allowed
scripts or a nonce to the policy. While the former implies that any
script which matches an allowed hash is executed, the latter implies
that scripts which carry the nonce in their nonce property can be ex-
ecuted. Since the nonce is randomly generated, it cannot be guessed
by an attacker, leaving them unable to inject a script that would
execute, yet allowing the developer to have their scripts execute.
To still provide backward compatibility for CSP Level 1 browsers,
the ’unsafe-inline’ expression is ignored if nonces are present, such
that the inline scripts are still executed in old browsers that do
not support nonces or hashes. Notably, event handlers cannot be
allowed through nonces. However, the most recent draft of the
CSP Level 3 living standard adds the ’unsafe-hashes’ keyword
to enable hashed event handlers.
Once a script is loaded, it can add arbitrary other scripting re-
sources. On the Web, this frequently occurs, particularly with newly
added hosts, in the context of advertisements. This forces the CSP
author to either regularly update their policy or risk breakage.
To address this problem, Weichselbaum et al. [58] proposed the
’strict-dynamic’ expression, which is, in the meanwhile, present
in the living standard of CSP Level 3 [56]. If this expression is
present, a trusted script – explicitly allowed through its hash or
through being nonced – can propagate its trust to programmati-
cally added scripts, which do not have to be explicitly allowed in
the script-src directive. Because deploying ’strict-dynamic’
only works if hashes or nonces are present, it also means that
’unsafe-inline’ has no effect if it is present.
Since developing and deploying a CSP is a tedious task which
can cause breakage when not properly tested, CSP can also be
delivered as a report-only policy. In that case, violating resources
are not blocked, but instead, a report is generated to address the
potential breakage before it occurs in enforcement mode. For both
enforcement and report-only modes, CSP supports the report-to
and report-uri directives, which specify a logging endpoint to
which violation information is sent.
CSP has been the subject of many studies over the years, which
all showed that policies in practice are mostly insecure [7, 44, 58,
59]. Moreover, even in cases where a CSP is secure, consistent
Session 11C: Software Development and Analysis CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea3086deployment across the entire origin often lacks behind, opening
the door for bypasses [9, 46]. Deploying a functional CSP is made
increasingly harder through browser extensions that inject content,
thereby causing breakage and/or false warnings [19].
As shown by Steffens et al. [49], the vast majority of sites have at
least one third party that interferes with CSP through practices that
require ’unsafe-inline’ or rely on APIs like document.write to
add scripts, making them incompatible with ’strict-dynamic’.
To investigate the evolution of CSP over the course of time, Roth
et al. [44] conducted a longitudinal analysis of deployed CSPs from
2012 until the end of 2018. They found the majority of CSPs were
trivially bypassable, e.g., because of the usage of ’unsafe-inline’
or http://* expressions, for long periods of time, or sites gave up
after experimenting with report-only mode.
We pick up on this notion of a CSP which is not trivially by-
passed, and refer to it as a sane CSP. While other bypasses exist,
e.g., through JSONP endpoints [58] or open redirects [43], such a
sane policy nevertheless indicates that it is not trivial to bypass, but
rather requires certain preconditions to be insecure. While prior
work has documented the technical struggles in deploying CSP
from an empirical and quantitative point-of-view, they fall short
of understanding the reasons behind this failure. Roth et al. [44]
conducted a short survey about CSP in the context of their notifica-
tion around framing control but could only generally report that
developers have misconceptions about CSP.
In this paper, through a qualitative study with developers with
CSP experience, we dive much deeper into the roadblocks of CSP
and outline how they align with technical challenges and human
misconceptions.
2.3 Qualitative Methods
Qualitative and quantitative research methods complement and
benefit from each other. This is due to the different perspectives
that the two approaches offer [1]. Quantitative research follows a
"top-down" approach [26] that requires well-founded hypotheses.
These may be constructed based on theories from qualitative re-
search, among other sources. As a "bottom-up" approach [26], qual-
itative research is particularly useful to explore new areas where
prior research cannot be relied upon, or to explore the origins of
behaviors and misconceptions, for example. In our case, we use the
strengths of qualitative methodology to uncover root causes of the
phenomena that previous quantitative work identified [44]. One of
the most prominent qualitative methods is interviews. In particular,
semi-structured interviews can be used to understand the problems,
perspectives, and needs of administrators [30], developers [31], and
end-users [23, 27, 30] better. While open-ended questions allow
exploring a topic broadly, the interviewer can deviate from the in-
terview guideline as soon as an interesting concept emerges. Upon
appropriate follow-up questions, interviewees provide insights into
their thoughts, reflect and share their insights and ideas. This depth
and data quality distinguishes interviews, and is difficult to obtain
with other methods such as surveys. However, interview studies
are costly, which is reflected in a relatively small sample size [32].
Another methodology that is well-suited for collecting quali-
tative data is a lab study. A particular advantage of lab studies
is the controlled setting, where researchers can change factors at
will to observe possible effects. Thus, lab studies are very versatile
and, depending on the study design, quantitative and/or qualita-
tive data can be collected. For example, study participants’ actions
can be recorded in video and audio, and they can be encouraged
to think-aloud. This helps to understand better the motivations
behind decisions, misunderstandings, and mistakes [32]. Gorski
et al. [18] conducted a between-subjects lab study to investigate if
the enforcement of a CSP per default affects the usability of a Web
framework. They also evaluated the effectiveness of CSP warnings
in the developer console of Chrome and Firefox. They recruited
30 students from their local university and made them use the
Java-based Play framework on Windows via the IntelliJ IDEA IDE
to create a Web site embedding a specific point on Google Maps.