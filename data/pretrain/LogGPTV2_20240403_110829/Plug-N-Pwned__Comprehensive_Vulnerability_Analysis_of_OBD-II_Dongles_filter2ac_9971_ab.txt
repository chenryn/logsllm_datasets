attack goal (which is not necessary for all potential attack
goals as discussed later in §6), the attacker can choose to
launch the attack during common low-speed driving scenarios
such as those when waiting at red light, in a trafﬁc jam, or in
a drive-thru queue.
3.2 Attack Surface
Before we design our automated security analysis tool, it is
necessary to ﬁrst comprehensively identify the attack surface
for these wireless OBD-II dongles. According to our attack
model in §3.1, a successful attack must have the following
three necessary stages: (I) Broadcast Stage, i.e., when the
attacker is scanning for victim dongles before connection,
(II) Connection Stage, i.e., when the attacker is connecting
with the dongle, and (III) Communication Stage, i.e., when
the attacker is injecting malicious messages after connection.
Thus, the attack surface considered in our analysis is deﬁned
as attack vectors at each of these three stages:
(I) Broadcast Stage. Prior to connection, a wireless OBD-II
dongle broadcasts its connection information to nearby de-
952    29th USENIX Security Symposium
USENIX Association
Broadcast InformationConnectInject MessagesDeliver Messages to CAN Bus123Nearby AttackerOBD-II DongleTarget VehicleFigure 4: Design Overview of DONGLESCOPE.
Component
Measurement Objective(s)
(1) Broadcast Information Collection
1 Broadcast information
(2) Connection Setup
(3) CAN Bus Message Test
2 If connection can be successfully established.
3 If multiple access is allowed.
4 If predeﬁned message is injected to CAN bus.
5 If undeﬁned message is injected to CAN bus.
Table 1: Measurement Objectives of DONGLESCOPE.
each component in dynamic analysis, speciﬁc measurement
objectives are deﬁned, as shown in Table 1. During the broad-
cast stage, DONGLESCOPE collects all broadcast information
from the wireless OBD-II dongle. Next, it tries to set up a con-
nection with the dongle at the connection stage. Note that the
tool also tests whether the connection is still successful while
another mobile device is connected with the dongle, which
simulates a real attack scenario (i.e., when the driver is still
inside the vehicle). In this stage, there are two measurement
objectives: if connection can be established and if multiple
connections are allowed. After a connection is established, it
tries to test with predeﬁned and undeﬁned CAN bus messages
at the communication stage. The objective is to check if the
predeﬁned and undeﬁned messages can be injected to the
CAN bus so that corresponding attack consequences can be
observed. Meanwhile, the predeﬁned message generation step
produces predeﬁned messages to help design the messages
for the CAN bus message test.
Prior to our design, there are a few challenges to be solved.
First, since OBD-II dongles can adopt various manufacture-
speciﬁc implementations (e.g., different message patterns and
protocols), it is hard to come up with a fully generic approach.
As a result, we assume all OBD-II dongles are ELM327-
based [20], which is a common implementation for interpret-
ing low-level CAN bus protocol and providing standardized
interfaces for programming. According to the experiment
results in §5.3, over 90% of the dongles in our study are
ELM327-based. To achieve dongle conﬁguration and message
communication with the CAN bus, we leverage the ELM327
command set [20] to design the testing messages.
Second, it is necessary to ﬁnd all predeﬁned messages of
each dongle so that we can make sure that the undeﬁned mes-
sages to be tested are not predeﬁned in the dongle. Inspired
by previous IoT research which leverages companion mobile
app analysis to understand black box IoT devices [21,22], we
introduce a predeﬁned message generation step using back-
ward program slicing to extract all predeﬁned messages of
the tested dongles.
Third, we have to obtain undeﬁned messages that are valid
to the CAN bus so that we are able to observe effects brought
by the injection of the messages. Intuitively, we should use the
control CAN bus messages, because OBD-II dongles should
not provide vehicle control capabilities by design. Therefore,
we need to reverse engineer the CAN bus protocol, which
has long been a tricky but valuable task for automotive re-
searchers since protocols across different manufactures are
highly customized but conﬁdential [10, 13, 23]. The state-
of-the-art for reverse engineering the CAN bus protocol is
through CAN message fuzzing or manually triggering physi-
cal vehicle actions [10, 24]. Inspired by them, we also tried
to analyze the CAN bus protocol on our testing automobile.
Speciﬁcally, we ﬁrst operated the vehicle with some physical
actions (e.g., step on the throttle, apply the brake), and then
observed the changes on the dynamic CAN bus trafﬁc to see
which CAN bus message led to the behavior. Therefore, we
are able to obtain a number of control CAN bus messages on
our testing vehicle.
In the experiment, we select a representative from the unde-
ﬁned messages for testing since it is unrealistic to test them all,
given there are at least 275 possible CAN bus messages in the-
ory. Additionally, we assume the ﬁltering policy is based on
message format, since predeﬁned OBD-II PIDs have distinct
identiﬁers compared with other messages. In other words,
if any message of a speciﬁc format can pass the ﬁlter, then
all messages with the same format can also pass the ﬁlter,
and vice versa. To verify this hypothesis, we conducted an
experiment on 26 dongles by injecting 10 different undeﬁned
messages. We observed that these messages were all either
accepted or ﬁltered by each dongle, which conﬁrms our as-
sumption. Therefore, we can narrow the testing undeﬁned
USENIX Association
29th USENIX Security Symposium    953
(1) Broadcast Information Collection(4) Predefined Message Generation(2) Connection Setup(3) CAN Bus Message TestStatic AnalysisOBD-II DongleAttack  Surface(I) Broadcast Stage(II) Connection Stage Dynamic AnalysisApps(III) Communication Stage messages to just one representative. Furthermore, testing one
predeﬁned message is sufﬁcient since all predeﬁned messages
should be accepted by design, which has also been veriﬁed
by similar experiments.
4.2 Detailed Design and Implementation
(1) Broadcast Information Collection. We categorize
the OBD-II dongles into three types: Wi-Fi, Bluetooth
Classic, and BLE, according to their connections. Since
broadcast information varies across different types of dongles,
DONGLESCOPE deals with them correspondingly. In this
step, we ﬁrst manually plug the dongle into the OBD-II
port. Next, DONGLESCOPE starts to automatically collect
necessary broadcast information from it, and the information
is stored in a conﬁguration JSON ﬁle. To summarize, all
sniffable broadcast information includes Wi-Fi service set
identiﬁer (SSID), device name of Bluetooth Classic and BLE,
as well as the universally unique identiﬁer (UUID) of BLE
dongles, etc. Note that to make sure the collected broadcast
information is from the dongle, there should be no other
broadcasting devices around when we perform the test.
(2) Connection Setup. After identifying an OBD-II dongle
in the broadcast stage, DONGLESCOPE tries to establish a
connection with it for further communication. During the con-
nection, we simulate a real attack scenario by setting up a
mobile device connected with the dongle, which acts as the
driver’s device. If DONGLESCOPE fails to connect with the
dongle, implying that multiple connections are not allowed,
we disconnect the driver’s device with the dongle and try a
single connection. When the system-layer connection is es-
tablished, DONGLESCOPE tries to set up a communication
channel on app-layer with the dongle. To achieve this, some
additional information from the speciﬁcations is needed (e.g.,
IP address, port number), which is pre-loaded into DONGLE-
SCOPE. For a Wi-Fi dongle, DONGLESCOPE follows the IP
address as well as the port number to build up a socket for
communication. For a Bluetooth Classic dongle, DONGLE-
SCOPE ﬁrst queries the Bluetooth address and port number
from the dongle, and tries to setup a Bluetooth socket with it
based on the Radio Frequency Communication (RFCOMM)
protocol [25]. As for a BLE dongle, the process is more com-
plicated, since it requires DONGLESCOPE to obtain the read
and write characteristics which are necessary for communica-
tion with the dongle. These characteristics are the attributes in
BLE devices conveying concrete data and can be identiﬁed by
UUIDs [26]. Our solution is to inject an ELM327 command
AT E0 to each characteristic at a time to check which other
characteristic echos an OK back. These two characteristics are
regarded as the write and read characteristic respectively.
After the connection is established, DONGLESCOPE is able
to communicate with the dongle through the ELM327 in-
terface. We implement the communication process with the
Python socket library [27], PyBluez [28] and PyBLE [29].
Prior to that, DONGLESCOPE still needs to conﬁgure the don-
gle, otherwise it may not get a valid response. Speciﬁcally, it
injects the following ELM327 commands [20] to achieve the
corresponding conﬁguration purposes:
• AT D. Restore the dongle to its default setting.
• AT E0. Stop the messages from echoing.
• AT AT0. Disable timeout.
• AT H1. Show the message header in response.
• AT CAF1. Turn off the auto formatting.
• AT SP 6. Set the ISO 15765-4 CAN protocol as default
(using 11-bit identiﬁer).
(3) CAN Bus Message Test. When the connection is suc-
cessfully set up, DONGLESCOPE is able to send messages
to the CAN bus through the OBD-II dongle. In this step,
DONGLESCOPE tests two representatives from the predeﬁned
and undeﬁned CAN bus messages respectively, since test-
ing all the predeﬁned and undeﬁned messages is unnecessary
(discussed in §4.1). Speciﬁcally, DONGLESCOPE adopts a
standard PID 09 02 as the testing predeﬁned message, which
is a diagnostic message to query the VIN. As for the undeﬁned
message, a CAN bus message 191 04 00 00 is used which
sets the transmission gear to N in our testing vechicle. This
undeﬁned message is obtained through reverse engineering
the CAN bus protocol. During the analysis, we used an ATMA
command to dump the CAN bus trafﬁc, and shifted the gear
to different positions. During this process, we observed the
changes on the CAN bus and determined the message that
triggered the behaviour. After we obtained the undeﬁned mes-
sage, we cross-checked it with our app analysis results and
made sure that it is not predeﬁned for all dongles in our study.
Having obtained the messages of interest, DONGLESCOPE
starts to automatically test them on the dongle. Speciﬁcally,
DONGLESCOPE speciﬁes the headers for the CAN bus mes-
sages to be sent with an AT SH command, and speciﬁes the
respond message header with an AT CRA command. First,
DONGLESCOPE tests with the predeﬁned message 09 02. A
successful query will return back a valid VIN number in hex-
adecimal form. Second, DONGLESCOPE sends an undeﬁned
message 191 04 00 00. If successfully delivered by the don-
gle to the CAN bus, the ECU will echo a CAN bus message
with the same identiﬁer 0x191 showing its status. Otherwise,
the message will be ﬁltered by the dongle, and the tool will
get a NO DATA response.
(4) Predeﬁned Message Generation. In order to design
the testing messages in the communication stage, DON-
GLESCOPE performs static analysis on the corresponding
companion mobile app to generate the predeﬁned messages.
Speciﬁcally, it uses backward program slicing [30], which
is a technique to obtain the program slices that are necessary
for generating the target data. To start the analysis, we ﬁrst
954    29th USENIX Security Symposium
USENIX Association
Algorithm 1: Backward Slicing Algorithm
Input: G: Control ﬂow graph of current function, V : Variable set of our interest
Output: P: A set of data generation paths
l ← left operand of i ;
if l ∈ V then
for edge(i, j) ∈ backward DFS order of E do
V ← V∪ right variable operands of i ;
if i is a library function then
1 P ← /0 ;
2 path ← /0 ;
3 E ← Sub-graph of G ending in the target APIs ;
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19 end
end
if No descendent edge then
path ← path∪ i ;
else
end
Dive into the implementation of i for further slicing;
P ← P∪ path ;
Restore path to the state of the latest branch point;
Restore V to the state of the latest branch point;
end
identify the low-level network target APIs, including the TCP
socket send function, as well as write functions of Bluetooth
Classic and BLE. According to our observation, they are
the only ways for a companion app to communicate with an
OBD-II dongle to perform the designed functions. As a result,
the variables in these APIs denote the messages sent to the
dongle. We then design a backward slicing algorithm which
starts from these identiﬁed APIs and iterates backward to
record the necessary instructions that generate the messages,
which is detailed in algorithm 1.
At a high level, the algorithm takes the control ﬂow graph
of the program (G) as well as a set of variables of our interest
(V ) as input, and produces a set of generation paths (P). First,
it initializes the set of generation paths (P) and the temporary
path (path) as empty (line 1-2). Next, it constructs E as a
sub-graph of G where all leave nodes are the target APIs,
and traverses E in backward DFS order (line 3-4). For each
edge (i, j) where each node of it indicates an instruction, the
algorithm detects if the left operand of node i is in V (line 6).
If it is, the algorithm adds all variable operands on the right
of i to V (line 7). Note that when i is not a library function,
the algorithm needs to dive into the implementation of i and
continue slicing; otherwise it adds the instruction i to the
temporary path path (line 8-12). Afterwards, when the cur-
rent path reaches the end, the algorithm adds path to P (line
14-15). Then, it starts traversing another path and restores
the current path and V to the state of the latest branch point
(line 16-18). Ultimately, the algorithm outputs a number of
data generation paths which contain instructions that generate
the data of our interest. Based on the generation paths, DON-
GLESCOPE performs forward computation to reconstruct the
actual value of the data being sent. The static analysis is built
atop Soot [31], which is a popular static analysis framework
for reverse engineering Android mobile apps.
Dongle Name
Type
App-speciﬁc?
# Review
Vulnerable?
BAFX OBD Reader
BlueDriver Pro
FIXD
VEEPEAK VP01 WIFI
Veepeak Mini
iSaddle WIFI OBD2
Carista
GXG-1987 OBD-II Mini
wsilroon Car WIFI OBD 2
PLX Devices Kiwi 3
Wi-Fi
Bluetooth
BLE
Wi-Fi
Wi-Fi
Wi-Fi
BLE
Wi-Fi
Wi-Fi
BLE
(cid:88)
(cid:88)
(cid:88)
11,523
3,764
3,229
1,571
1,505
1,094
1,044
799
708
640
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
Table 2: Top 10 Popular Dongles in Our Study.
5 Vulnerability Analysis
5.1 OBD-II Dongle and App Collection
OBD-II dongles. To achieve high comprehensiveness of our
study, we bought all wireless OBD-II dongles available in
the US from Amazon by searching combinations of all possi-
ble related keywords (i.e., “OBD-II” or “OBD2” or “OBDII”
combining with “dongle” or “scanner” or “adapter”) in Febru-
ary 2019. In total, this collection ended up with 77 OBD-II
dongles (depicted in Figure 2). Among these 77 dongles, there
are 44 (57.14%) Wi-Fi dongles, 3 (3.90%) Bluetooth Classic
dongles and 30 (38.96%) BLE dongles, which shows Wi-Fi
and BLE based dongles are the most popular ones on the
market today.
The full list of dongles is shown in Table 3. To estimate the
popularity of these dongles, we measure their review counts
on Amazon. In Table 2, we present the top 10 most popu-
lar dongles based on the number of reviews in Amazon. As
shown, the most popular one is a Wi-Fi dongle with over
10,000 reviews. This dongle provides basic diagnostic func-
tions and are compatible with a large number of free third-
party companion mobile apps. Similar dongles such as VEEP-
EAK, iSaddle, and GXG, are also very popular. In addition,
some dongles such as BlueDriver, FIXD and Carista are app-