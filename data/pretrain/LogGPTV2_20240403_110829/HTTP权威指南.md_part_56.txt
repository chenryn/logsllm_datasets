第15章
实体和编码
357
每天都有数以亿计的各种媒体对象经由HTTP传送，如图像、文本、影片以及软件
程序等。只要你能叫出名字，HTTP就可以传送。HTTP还会确保它的报文被正确
传送、识别、提取以及适当处理。具体说来，HTTP要确保它所承载的“货物”满
足以下条件。
• 可以被正确地识别（通过 Content-Type 首部说明媒体格式，Content-
Language首部说明语言），以便浏览器和其他客户端能正确处理内容。
• 可以被正确地解包（通过Content-Length首部和Content-Encoding首部）。
• 是最新的（通过实体验证码和缓存过期控制）
• 符合用户的需要（基于Accept系列的内容协商首部）
• 在网络上可以快速有效地传输（通过范围请求、差异编码以及其他数据压缩方法）
• 完整到达、未被篡改（通过传输编码首部和Content-MD5校验和首部）
为了实现这些目标，HTTP使用了完善的标签来描述承载内容的实体。
本章讨论各种实体、与它们相关的实体首部以及它们是如何运作来传送网站“货物”
的。我们将展示HTTP是如何提供必需的内容大小、类型以及编码的。我们还要解
释HTTP实体的某些更复杂和强大的特性，比如范围请求、差异编码、摘要以及分
块编码等。
本章涵盖了下列内容。
• 作为HTTP数据的容器，HTTP报文实体有哪些格式和行为。
• HTTP如何描述实体的主体大小，HTTP为确定大小制定了哪些规则。
• 为了使客户端正确处理内容，使用了哪些实体首部来描述内容的格式、字母和
341 语言。
• 可逆的内容编码，发送方可以在发送之前用它来转换内容的数据格式，使其占用
更小的空间，或者更安全。
• 传输编码和分块编码。传输编码可以改变HTTP传输数据的方式，以改善某些类
型内容的通信能力。分块编码是一种特殊的传输编码，它把数据切分为若干块，
这样可以更可靠地传输长度未知的内容。
• 标记、标签、时间以及校验和等一整套机制，帮助客户端获取所请求内容的最新
版本。
• 可用作内容版本号的验证码，网站应用可以通过它确保接收最新的内容。还有设
计用来控制对象新鲜度的各种HTTP首部字段。
• 范围，在恢复中断的传输方面很有用。
• HTTP差异编码扩展，它使客户端只需要请求网页中和前一次相比有改变的部分。
• 实体主体的校验和，可以用来检测经过若干代理之后，实体的内容是否发生了改变。
358 ｜ 第15章
15.1 报文是箱子，实体是货物
如果把HTTP报文想象成因特网货运系统中的箱子，那么HTTP实体就是报文中实
际的货物。图15-1展示了一个简单的实体，装在HTTP响应报文中。
HTTP/1.0 200 OK
Server: Netscape-Enterprise/3.6
Date: Sun, 17 Sep 2000 00:01:05 GMT
Content-type: text/plain
实体首部
Content-length: 18
实体
Hi! I'm a message! 实体主体
图15-1 报文实体由实体首部和实体主体组成
实体首部指出这是一个纯文本文档（Content-Type:text/plain），它只有18个
字节长（Content-Length:18）。和往常一样，一个空白行（CRLF）把首部字段
同主体的开始部分分隔开来。
HTTP实体首部（参见第3章）描述了HTTP报文的内容。HTTP/1.1版定义了以下
10个基本字体首部字段。
• Content-Type
实体中所承载对象的类型。
• Content-Length
所传送实体主体的长度或大小。 342
• Content-Language
与所传送对象最相配的人类语言。
• Content-Encoding
对象数据所做的任意变换（比如，压缩）。
• Content-Location
一个备用位置，请求时可通过它获得对象。
• Content-Range
如果这是部分实体，这个首部说明它是整体的哪个部分。
• Content-MD5
实体主体内容的校验和。
实体和编码 ｜ 359
• Last-Modified
所传输内容在服务器上创建或最后修改的日期时间。
• Expires
实体数据将要失效的日期时间。
• Allow
该资源所允许的各种请求方法，例如，GET和HEAD。
• ETag
这份文档特定实例（参见15.7节）的唯一验证码。ETag首部没有正式定义为实
体首部，但它对许多涉及实体的操作来说，都是一个重要的首部。
• Cache-Control
指出应该如何缓存该文档。和ETag首部类似，Cache-Control首部也没有正
式定义为实体首部。
实体主体
实体主体中就是原始货物啦。1任何其他描述性的信息都包含在首部中。因为货
物（也就是实体主体）只是原始数据，所以需要实体首部来描述数据的意义。例
如，Content-Type实体首部告诉我们如何去解释数据（是图像还是文本等），而
Content-Encoding实体首部告诉我们数据是不是已被压缩或者重编码。我们将在
随后的小节中讨论所有这些方面及更多的内容。
首部字段以一个空白的CRLF行结束，随后就是实体主体的原始内容。不管内容是
什么，文本或二进制的、文档或图像、压缩的或未压缩的、英语、法语或日语，都
343 紧随这个CRLF之后。
图15-2展示了两个实际的HTTP报文的例子。一个携带着文本实体，另一个承载的
是图像实体。十六进制的数值中展示的是报文的实际内容。
• 在图15-2a中，实体主体从第65个字节开始，紧随首部末尾的CRLF。实体主体
中包含了“Hi! I'm a message!”这句话的ASCII编码字符。
• 在图15-2b中，实体主体从第67字节开始。实体主体包含了一个GIF格式图像
的二进制内容。GIF文件以6个字节的版本标志开头，后面是16位的宽度和16
位的高度。可以在实体主体中直接看到这3项内容。
注1： 如果有Content-Encoding首部的话，实体主体的内容就已经被指定的内容编码算法进行过编码了，
第一个字节就是编码（比如，压缩）后的货物的第一个字节。
360 ｜ 第15章
(a)HTTP响应报文中的text/plain类型的实体
HTTP/1.0 200 OK
Content-type: text/plain
Content-length: 18
Hi! I'm a message!
首部末尾的LF (0x0A= )主体内容的开始 (0x48= "H")
(b)HTTP响应报文中的image/gif类型的实体
HTTP/1.0 200 OK
Content-Type: image/gif
Content-Length: 34867
首部末 主体内 图像宽度 图像高度
尾的LF 容的开始
(0x0A= ) ("GIF87a")(0x0227= 551)(0x0206= 518)
图15-2 实际报文内容（紧随空白的CRLF之后的原始报文内容）的十六进制转储显示
15.2 Content-Length: 实体的大小
Content-Length首部指示出报文中实体主体的字节大小。这个大小是包含了所有
内容编码的，比如，对文本文件进行了gzip压缩的话，Content-Length首部就是
压缩后的大小，而不是原始大小。
除非使用了分块编码，否则Content-Length首部就是带有实体主体的报文必须使
用的。使用Content-Length首部是为了能够检测出服务器崩溃而导致的报文截
尾，并对共享持久连接的多个报文进行正确分段。
15.2.1 检测截尾
HTTP 的早期版本采用关闭连接的办法来划定报文的结束。但是，没有 Content-
Length的话，客户端无法区分到底是报文结束时正常的连接关闭，还是报文传输 344
中由于服务器崩溃而导致的连接关闭。客户端需要通过Content-Length来检测
报文截尾。
报文截尾的问题对缓存代理服务器来说尤其严重。如果缓存服务器收到被截尾的报
文却没有识别出截尾的话，它可能会存储不完整的内容并多次使用它来提供服务。
缓存代理服务器通常不会为没有显式Content-Length首部的HTTP主体做缓存，
以此来减小缓存已截尾报文的风险。
实体和编码 ｜ 361
15.2.2 错误的Content-Length
错误的Content-Length比缺少Content-Length还要糟糕。因为某些早期的客
户端和服务器在Content-Length计算上存在一些众所周知的错误，有些客户端、
服务器以及代理中就包含了特别的算法，用来检测和纠正与有缺陷服务器的交互过
程。HTTP/1.1规定用户Agent代理应该在接收且检测到无效长度时通知用户。
15.2.3 Content-Length与持久连接
Content-Length首部对于持久连接是必不可少的。如果响应通过持久连接传送，
就可能有另一条HTTP响应紧随其后。客户端通过Content-Length首部就可以知
道报文在何处结束，下一条报文从何处开始。因为连接是持久的，客户端无法依赖
连接关闭来判别报文的结束。如果没有Content-Length首部，HTTP应用程序就
不知道某个实体主体在哪里结束，下一条报文从哪里开始。
我们将在15.6节看到，有一种情况下，使用持久连接时可以没有Content-Length
首部，即采用分块编码（chunked encoding）时。在分块编码的情况下，数据是分为
一系列的块来发送的，每块都有大小说明。哪怕服务器在生成首部的时候不知道整
个实体的大小（通常是因为实体是动态生成的），仍然可以使用分块编码传输若干已
知大小的块。
15.2.4 内容编码
HTTP允许对实体主体的内容进行编码，比如可以使之更安全或进行压缩以节省空
间（本章稍后将详细解释压缩的问题）。如果主体进行了内容编码，Content-Length
首部说明的就是编码后（encoded）的主体的字节长度，而不是未编码的原始主体的
长度。
某些HTTP应用程序在这方面搞错了，发送的是数据编码之前的大小，这会导致严
345 重的错误，尤其是用在持久连接上。不幸的是，HTTP/1.1规范中没有首部可以用来
说明原始的、未编码的主体的长度，这就让客户端难以验证解码过程的完整性。2
15.2.5 确定实体主体长度的规则
下面列出的规则说明了在若干不同的情况下如何正确计算主体的长度和结束位置。
这些规则应当按顺序应用，谁先匹配就用谁。
注2： Content-MD5首部也不行，它用来说明文档的128位MD5值，但这也是针对编码后的文档的。本
章后面会说明Content-MD5首部。
362 ｜ 第15章
（1） 如果特定的HTTP报文类型中不允许带有主体，就忽略Content-Length首
部，它是对（没有实际发送出来的）主体进行计算的。这种情况下，Content-
Length首部是提示性的，并不说明实际的主体长度。（考虑不周的HTTP应用
程序会认为有了Content-Length就有主体存在，这样就会出问题。）
最重要的例子就是HEAD响应。HEAD方法请求服务器发送等价的GET请
求中会出现的首部，但不要包括主体。因为对GET的响应会带有Content-
Length首部，所以HEAD响应里面也有；但和GET响应不同的是，HEAD
响应中不会有主体。1XX、204 以及 304 响应也可以有提示性的 Content-
Length首部，但是也都没有实体主体。那些规定不能带有实体主体的报文，
不管带有什么首部字段，都必须在首部之后的第一个空行终止。
（2） 如果报文中含有描述传输编码的Transfer-Encoding首部（不采用默认的
HTTP“恒等”编码），那实体就应由一个称为“零字节块”（zero-byte chunk）
的特殊模式结束，除非报文已经因连接关闭而结束。我们将在本章后面讨论传
输编码和分块编码。
（3） 如果报文中含有Content-Length首部（并且报文类型允许有实体主体），而
且没有非恒等的Transfer-Encoding首部字段，那么Content-Length的值
就是主体的长度。如果收到的报文中既有Content-Length首部字段又有非恒
等的Transfer-Encoding首部字段，那就必须忽略Content-Length，因为
传输编码会改变实体主体的表示和传输方式（因此可能就会改变传输的字节数）。
（4） 如果报文使用了multipart/byteranges（多部分/字节范围）媒体类型，并且没
有用Content-Length首部指出实体主体的长度，那么多部分报文中的每个部
分都要说明它自己的大小。这种多部分类型是唯一的一种自定界的实体主体类
型，因此除非发送方知道接收方可以解析它，否则就不能发送这种媒体类型。3 346
（5） 如果上面的规则都不匹配，实体就在连接关闭的时候结束。实际上，只有服务
器可以使用连接关闭来指示报文的结束。客户端不能用关闭连接来指示客户端
报文的结束，因为这样会使服务器无法发回响应。4
为了和使用HTTP/1.0 的应用程序兼容，任何带有实体主体的HTTP/1.1请求都必
须带有正确的Content-Length首部字段（除非已经知道服务器兼容HTTP/1.1）。
注3： 因为Range首部可能会被不理解多部分/字节范围的更原始的代理所转发，所以如果发送方不能确
定接收方是否理解这种自定界的格式的话，就必须用本节的方法（1）、（3）或（5）来对报文定界。
注4： 客户端可以使用半关闭，也就是只把连接的输出端关闭，但很多服务器应用程序设计的时候没有考虑
到处理这种情况，会把半关闭当作客户端要从服务器断开连接来处理。HTTP没有对连接管理进行良
好的规范。详情请参见第4章。
实体和编码 ｜ 363
HTTP/1.1规范中建议对于带有主体但没有Content-Length首部的请求，服务器
如果无法确定报文的长度，就应当发送400 Bad Request响应或411 Length Required
响应，后一种情况表明服务器要求收到正确的Content-Length首部。
15.3 实体摘要
尽管HTTP通常都是在像TCP/IP这样的可靠传输协议之上实现的，但仍有很多因
素会导致报文的一部分在传输过程中被修改，比如有不兼容的转码代理，或者中间
代理有误，等等。为检测实体主体的数据是否被不经意（或不希望有）地修改，发
送方可以在生成初始的主体时，生成一个数据的校验和，这样接收方就可以通过检