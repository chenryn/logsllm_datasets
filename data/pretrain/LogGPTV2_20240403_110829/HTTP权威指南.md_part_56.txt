### 第15章 实体和编码

#### 357
每天都有数以亿计的各种媒体对象通过HTTP传送，如图像、文本、视频及软件程序等。无论是什么类型的文件，HTTP都能进行传输，并确保报文的正确传送、识别、提取及处理。具体来说，HTTP需确保其承载的内容满足以下条件：
- **正确识别**：通过`Content-Type`首部说明媒体格式，`Content-Language`首部说明语言，以便浏览器和其他客户端能正确处理内容。
- **正确解包**：通过`Content-Length`首部和`Content-Encoding`首部来实现。
- **最新性**：通过实体验证码和缓存过期控制机制保证内容的时效性。
- **符合用户需求**：基于`Accept`系列的内容协商首部，使内容适应用户的偏好。
- **高效传输**：通过范围请求、差异编码及其他数据压缩方法，在网络上快速有效地传输内容。
- **完整性与未篡改**：通过传输编码首部和`Content-MD5`校验和首部，确保内容完整且未被篡改。

为了实现上述目标，HTTP采用了一系列标签来描述所承载内容的实体。本章将深入探讨这些实体及其相关首部的工作原理，以及它们如何协同作用以成功传递网站“货物”。我们将展示HTTP如何提供必要的内容大小、类型和编码信息，并解释一些更复杂的功能，如范围请求、差异编码、摘要及分块编码等。

本章涵盖的主要内容包括：
- HTTP报文实体的格式与行为；
- HTTP如何描述实体主体的大小及其规则；
- 用于描述内容格式、字符集及语言的实体首部；
- 可逆的内容编码技术，以减小传输数据量或提高安全性；
- 传输编码与分块编码，前者改变数据传输方式以优化特定类型内容的通信能力，后者则将数据分割成若干部分以支持长度未知内容的可靠传输；
- 一系列机制（如标记、时间戳及校验和）帮助客户端获取最新的内容版本；
- 作为内容版本号的验证码及其在控制对象新鲜度中的应用；
- 范围请求，在恢复中断传输方面的作用；
- HTTP差异编码扩展，允许客户端仅请求网页中发生变化的部分；
- 实体主体的校验和，用于检测经过多个代理后内容是否发生变更。

#### 15.1 报文是箱子，实体是货物
如果把HTTP报文比作互联网货运系统中的箱子，那么HTTP实体就是箱子里的实际货物。图15-1展示了一个简单的实体封装于HTTP响应报文中。

```
HTTP/1.0 200 OK
Server: Netscape-Enterprise/3.6
Date: Sun, 17 Sep 2000 00:01:05 GMT
Content-type: text/plain
Content-length: 18
Hi! I'm a message!
```

**图15-1** 报文实体由实体首部和实体主体组成

该实体首部指明了这是一份纯文本文件(`Content-Type: text/plain`)，长度为18个字节(`Content-Length: 18`)。通常情况下，一个空行（CRLF）会将首部字段与主体区分开来。

HTTP实体首部描述了报文的具体内容。HTTP/1.1定义了以下十个基本实体首部字段：
- `Content-Type`：实体中所承载对象的类型。
- `Content-Length`：所传输实体主体的长度或大小。
- `Content-Language`：与所传输对象最匹配的人类语言。
- `Content-Encoding`：对对象数据所做的任意变换（例如，压缩）。
- `Content-Location`：一个备用位置，请求时可通过它获得对象。
- `Content-Range`：若这是部分实体，则此首部说明它是整体的哪个部分。
- `Content-MD5`：实体主体内容的校验和。
- `Last-Modified`：所传输内容在服务器上创建或最后修改的时间。
- `Expires`：实体数据将要失效的时间。
- `Allow`：该资源所允许的各种请求方法（例如，GET 和 HEAD）。
- `ETag`：这份文档特定实例的唯一验证码。（虽然未正式定义为实体首部，但对许多涉及实体的操作至关重要）
- `Cache-Control`：指出应如何缓存该文档。（同样未正式定义为实体首部）

**实体主体**则是原始的数据本身。所有其他描述性的信息均包含在首部中。由于实体主体仅为原始数据，因此需要实体首部来解释数据的意义。例如，`Content-Type`实体首部告知我们如何解析数据（是图片还是文本等），而`Content-Encoding`实体首部则告诉我们数据是否已被压缩或重新编码。后续章节将进一步讨论这些问题及其他更多细节。

首部字段以一个空白的CRLF行结束，紧随其后的便是实体主体的原始内容。无论是文本还是二进制数据、文档抑或是图片、压缩与否、何种语言，都紧跟在这CRLF之后。图15-2展示了两个实际的HTTP报文示例，一个携带文本实体，另一个则为图像实体。十六进制数值显示了报文的实际内容。

- **图15-2a** 中，实体主体从第65个字节开始，紧接着首部末尾的CRLF。主体包含了“Hi! I'm a message!”这句话的ASCII编码字符。
- **图15-2b** 中，实体主体从第67个字节开始。主体是一个GIF格式图像的二进制内容，以6个字节的版本标志开头，随后是16位宽度和16位高度。这些信息可以直接从实体主体中看到。

**注释**：如果有`Content-Encoding`首部的话，实体主体的内容就已经按照指定的内容编码算法进行了编码，第一个字节即为编码（比如，压缩）后的第一个字节。

#### 15.2 Content-Length: 实体的大小
`Content-Length`首部指示出报文中实体主体的字节大小。这个大小是指经过所有内容编码后的大小。例如，如果对文本文件进行了gzip压缩，`Content-Length`首部指的是压缩后的大小，而非原始大小。

除非使用了分块编码，否则带有实体主体的报文必须包含`Content-Length`首部。使用`Content-Length`首部是为了能够检测因服务器崩溃导致的报文截断，并对共享持久连接的多个报文进行正确的分段。

##### 15.2.1 检测截尾
早期版本的HTTP采用关闭连接的方式来划定报文的结束。然而，没有`Content-Length`的话，客户端无法区分正常的连接关闭与由于服务器崩溃而导致的连接关闭。客户端需要依赖`Content-Length`来检测报文是否被截断。

对于缓存代理服务器而言，报文截断问题尤为严重。如果缓存服务器接收到被截断的报文却未能识别出来，可能会存储不完整的内容并多次使用它来提供服务。因此，缓存代理服务器通常不会为没有显式`Content-Length`首部的HTTP主体做缓存，以此降低缓存已截断报文的风险。

##### 15.2.2 错误的Content-Length
错误的`Content-Length`比缺少`Content-Length`还要糟糕。因为某些早期的客户端和服务器在计算`Content-Length`时存在已知的错误，所以有些客户端、服务器及代理实现了特别的算法来检测和纠正与有缺陷服务器的交互过程。HTTP/1.1规定用户代理应在接收并检测到无效长度时通知用户。

##### 15.2.3 Content-Length与持久连接
`Content-Length`首部对于持久连接是必不可少的。如果响应通过持久连接传送，可能紧接着会有另一条HTTP响应。客户端通过`Content-Length`首部可以知道当前报文在哪里结束，下一条报文从哪里开始。由于连接是持久的，客户端不能依赖连接关闭来判断报文的结束。如果没有`Content-Length`首部，HTTP应用程序将不知道某个实体主体在哪里结束，下一条报文从哪里开始。

我们将在15.6节看到，在一种特殊情况下，即使使用持久连接也可以没有`Content-Length`首部，即采用分块编码（chunked encoding）。在分块编码的情况下，数据分为一系列的块来发送，每块都有大小说明。即使服务器在生成首部时不知道整个实体的大小（通常是因为实体是动态生成的），仍然可以使用分块编码传输若干已知大小的块。

##### 15.2.4 内容编码
HTTP允许对实体主体的内容进行编码，使其更安全或进行压缩以节省空间（本章稍后将详细解释压缩的问题）。如果主体进行了内容编码，`Content-Length`首部说明的就是编码后的主体的字节长度，而不是未编码的原始主体的长度。

某些HTTP应用程序在这方面出现了错误，发送的是数据编码之前的大小，这会导致严重的错误，尤其是在持久连接上。不幸的是，HTTP/1.1规范中没有首部可以用来说明原始的、未编码的主体的长度，这就让客户端难以验证解码过程的完整性。

##### 15.2.5 确定实体主体长度的规则
以下列出的规则说明了在不同情况下如何正确计算主体的长度和结束位置。这些规则应当按顺序应用，谁先匹配就用谁。

- 如果特定的HTTP报文类型中不允许带有主体，就忽略`Content-Length`首部，因为它是对（没有实际发送出来的）主体进行计算的。这种情况下，`Content-Length`首部是提示性的，并不说明实际的主体长度。最重要的例子是HEAD响应。HEAD方法请求服务器发送等价的GET请求中会出现的首部，但不要包括主体。因为对GET的响应会带有`Content-Length`首部，所以HEAD响应里面也有；但和GET响应不同的是，HEAD响应中不会有主体。1XX、204 以及 304 响应也可以有提示性的`Content-Length`首部，但是也都没有实体主体。那些规定不能带有实体主体的报文，不管带有什么首部字段，都必须在首部之后的第一个空行终止。
- 如果报文中含有描述传输编码的`Transfer-Encoding`首部（不采用默认的HTTP“恒等”编码），那实体就应由一个称为“零字节块”（zero-byte chunk）的特殊模式结束，除非报文已经因连接关闭而结束。我们将在本章后面讨论传输编码和分块编码。
- 如果报文中含有`Content-Length`首部（并且报文类型允许有实体主体），而且没有非恒等的`Transfer-Encoding`首部字段，那么`Content-Length`的值就是主体的长度。如果收到的报文中既有`Content-Length`首部字段又有非恒等的`Transfer-Encoding`首部字段，那就必须忽略`Content-Length`，因为传输编码会改变实体主体的表示和传输方式（因此可能就会改变传输的字节数）。
- 如果报文使用了`multipart/byteranges`（多部分/字节范围）媒体类型，并且没有用`Content-Length`首部指出实体主体的长度，那么多部分报文中的每个部分都要说明它自己的大小。这种多部分类型是唯一的一种自定界的实体主体类型，因此除非发送方知道接收方可以解析它，否则就不能发送这种媒体类型。
- 如果上面的规则都不匹配，实体就在连接关闭的时候结束。实际上，只有服务器可以使用连接关闭来指示报文的结束。客户端不能用关闭连接来指示客户端报文的结束，因为这样会使服务器无法发回响应。

为了与使用HTTP/1.0的应用程序兼容，任何带有实体主体的HTTP/1.1请求都必须带有正确的`Content-Length`首部字段（除非已经知道服务器兼容HTTP/1.1）。

HTTP/1.1规范中建议对于带有主体但没有`Content-Length`首部的请求，服务器如果无法确定报文的长度，就应当发送400 Bad Request响应或411 Length Required响应，后一种情况表明服务器要求收到正确的`Content-Length`首部。

#### 15.3 实体摘要
尽管HTTP通常都是在像TCP/IP这样的可靠传输协议之上实现的，但仍有很多因素会导致报文的一部分在传输过程中被修改，比如不兼容的转码代理或中间代理出现错误等。为了检测实体主体的数据是否被不经意（或不希望有）地修改，发送方可以在生成初始的主体时生成一个数据的校验和，这样接收方就可以通过检查校验和来验证内容的完整性。