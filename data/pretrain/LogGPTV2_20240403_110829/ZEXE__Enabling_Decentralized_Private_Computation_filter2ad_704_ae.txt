the parameter used to generate the BLS curve EBLS is x =
3 · 246 · (7 · 13 · 499) + 1 (see Section IV for why).
NIZKs. We instantiate the NIZKs used for the NP relation
Re via zero-knowledge succinct non-interactive arguments of
knowledge (zk-SNARKs), which makes our DPC schemes
succinct. Concretely, we rely on the simulation-extractable
zkSNARK of Groth and Maller [GM17], used over the pairing-
friendly elliptic curves EBLS (for proving RBLS and predicates’
satisﬁability) and ECP (for proving RCP).
DLP-hard group.
Several instantiations of cryptographic
primitives introduced below rely on the hardness of extracting
discrete logarithms in a prime order group. We generate these
groups via a group generator SampleGrp, which on input a
security parameter λ (represented in unary), outputs a tuple
(G, q, g) that describes a group G of prime order q generated by
g. The discrete-log problem is hard in G. In our prototype we
ﬁx G to be the largest prime-order subgroup of either EEd/BLS
or EEd/CP, depending on the context.
Commitments. We instantiate (plain and) trapdoor commit-
ments via Pedersen commitments over G. These commitments
are perfectly hiding, and are computationally binding if the
discrete-log problem is hard in G.
Collision-resistant hashing. We instantiate CRH via a
Pedersen hash function over G. Collision resistance follows
from hardness of the discrete-logarithm problem [MRK03].
VII. System evaluation
In Section VII-A we evaluate individual cryptographic
building blocks. In Section VII-B we evaluate the cost of NP
relations expressed as constraints, as required by the underlying
zkSNARK. In Section VII-C we evaluate the running time of
DPC algorithms. In Section VII-D we evaluate the sizes of
DPC data structures. All reported measurements were taken
on a machine with an Intel Xeon 6136 CPU at 3.0 GHz with
252 GB of RAM.
A. Cryptographic building blocks
We are interested in two types of costs associated with
a given cryptographic building block: the native execution
cost, which are the running times of certain algorithms on
a CPU; and the constraint cost, which are the numbers of
constraints required to express certain invariants, to be used
by the underlying zkSNARK.
Native execution cost. The zkSNARK dominates native
execution cost, and the costs of all other building blocks are
negligible in comparison. Therefore we separately report only
the running times of the zkSNARK, which in our case is a
protocol due to Groth and Maller [GM17], abbreviated as
GM17. When instantiated over the elliptic curve EBLS, the
GM17 prover takes 25 μs per constraint (with 12 threads),
while the GM17 veriﬁer takes 250n μs + 9.5 ms on an input
with n ﬁeld elements (with 1 thread). When instantiated over
the elliptic curve ECP, the respective prover and veriﬁer costs
are 147 μs per constraint and 1.6n ms + 34 ms.
Constraint cost. There are three building blocks that together
account for the majority of the cost of NP statements that we
use. These are: (a) the Blake2s PRF, which requires 21792
constraints to map a 64-byte input to a 32-byte output; (b) the
Pedersen collision-resistant hash, which requires 5n constraints
for an input of n bits; and (c) the GM17 veriﬁer, which requires
14n + 52626 constraints for an n-bit input.
B. The execute NP relation
In many zkSNARK constructions, including the one that we
use, one must express all the relevant checks in the given NP
relation as (rank-1) quadratic constraints over a large prime
ﬁeld. Our goal is to minimize the number of such constraints
because the prover’s costs grow (quasi)linearly in this number.
In our DPC scheme we use a zkSNARK for the NP relation
Re in Fig. 10. More precisely, for eﬃciency reasons explained
in Section IV, we split Re into the two NP relations RBLS and
RCP, which we prove via zkSNARKs over the pairing-friendly
curves EBLS and ECP, respectively.
Table III reports the number of constraints that that we use
to express RBLS, as a function of the number of input (m)
and output (n) records, and additionally reports its primary
contributors. Table IV does the same for RCP. These tables
show that for each input record costs are dominated by
veriﬁcation of a Merkle tree path and the veriﬁcation of a
(death predicate) proof; while for each output record costs are
dominated by the veriﬁcation of a (birth predicate) proof. We
also report the cumulative number of constraints when setting
m := 2 and n := 2 because this is a representative instantiation
of m and n that enables useful applications.
C. DPC algorithms
In Table I we report the running times of algorithms in our
DPC implementation for two input and two output records (i.e.,
m := 2 and n := 2). Note that for Execute and Verify, we
have excluded costs of ledger operations (such as retrieving an
authentication path or scanning for duplicate serial numbers)
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:02:38 UTC from IEEE Xplore.  Restrictions apply. 
958
name
curve type
embedding
degree
size of prime-order
subgroup
size of base
ﬁeld
size of compressed group elements
(rounded to multiples of 8 bytes)
G1
EEd/BLS
EBLS
EEd/CP
ECP
twisted Edwards —
BLS
12
twisted Edwards —
short Weierstrass
6
s
r
t
p
r
p
p
q
32
48
48
104
G2
—
96
—
312
Fig. 7: The elliptic curves EBLS, ECP, EEd/BLS, EEd/CP. See Appendix A for details of the underlying ﬁelds.
because these depend on how a ledger is realized, which is
orthogonal to our work. Also, we assume that Execute receives
as inputs the application-speciﬁc SNARK proofs checked by the
NP relation. Producing each of these proofs requires invoking
the GM17 prover, over the elliptic curve EBLS, for the relevant
birth or death predicate; we describe the cost of doing so for
representative applications in Section VII-E.
Observe that, as expected, Setup and Execute are the most
costly algorithms as they invoke costly zkSNARK setup and
proving algorithms. To mitigate these costs, Setup and Execute
are executed on 12 threads; everything else is executed on 1
thread. Overall, we learn that Execute takes less 1 min, Verify
takes roughly 50 ms, and both Setup and Execute use less than
5 GB of RAM. These costs are comparable to those of similar
systems such as Zerocash [BCG+14] and Hawk [KMS+16].
D. DPC data structures
Addresses. An address public key in a DPC scheme is a
point on the elliptic curve EEd/BLS, which is 32 bytes when
compressed (see Fig. 7); the corresponding secret key is 64
bytes and consists of a PRF seed (32 bytes) and commitment
randomness (32 bytes).
Transactions. A transaction in a DPC scheme, with two input
and two output records, is 968 bytes. It contains two zkSNARK
proofs: πBLS, over the elliptic curve EBLS, and πCP, over the
curve ECP. Each proof consists of two G1 and one G2 elements
from its respective curve, amounting to 192 bytes for πBLS and
520 for πCP (both in compressed form). In general, a transaction
with m input and n output records is 32m + 32n + 840 bytes.
Record contents. We set a record’s payload to be 32 bytes
long; if a predicate needs longer data then it can set the payload
to be the hash of this data, and use non-determinism to access
the data. The foregoing choice means that all contents of a
record add up to 224 bytes, since a record consists of an address
public key (32 bytes), the 32-byte payload, hashes of birth and
death predicates (48 bytes each), a serial number nonce (32
bytes), and commitment randomness (32 bytes).
E. Applications
We do not report total costs for producing transactions for
the applications in Section V because the additional application-
speciﬁc costs are negligible compared to the base cost reported
in Table I. This is because all application-speciﬁc proofs are
produced over the eﬃcient elliptic curve EBLS, and moreover,
for each application we consider, the heaviest computation
checked by these proofs is the relatively lightweight one of
opening the local data commitment; the remaining costs consist
of a few cheap range and equality checks. Indeed, with two
input and two output records, these applications require fewer
than 35, 000 constraints (compared to over 350, 000 for RBLS
and RCP), and producing the corresponding proofs takes tens
of milliseconds (compared to tens of seconds for the base cost
of DPC.Execute).
Setup
GenAddress
Execute
Verify
109.62 s
380 μs
52.5 s
46 ms
TABLE I: Cost of
DPC algorithms for
2 inputs and 2 out-
puts.
2 inputs and 2 outputs
m inputs and n outputs
Per input record:
Serial number
Per output record:
Commitment
Memorandum
zkSNARK proof over ECP
zkSNARK proof over EBLS
Predicate commitment
Local data commitment
Ledger digest
968
32m + 32n +
840
32
32
32
520
192
32
32
32
TABLE II: Size of a DPC transaction (in
bytes).
Breakdown of the number of constraints with m input and n output records:
Per input record
117699
Total
Enforce validity of:
Merkle tree path
Address key pair
Serial number computation
Record commitment
Per output record
Total
Enforce validity of:
Serial number nonce
Record commitment
Other
Enforce validity of:
Predicate commitment
Local data commitment
Miscellaneous
81824
3822
22301
9752
15427
5417
10010
2(cid:3)
4 (m + n) + 1
21792 · (cid:2) 3
7168 · m + 6144 · n
7368
Total with 2 inputs and 2 outputs (m = n = 2)
387412
TABLE III: Number of constraints for RBLS.
Breakdown of the number of constraints with m input and n output records:
Per input record
87569
Total
Enforce validity of:
Death predicate ver. key
Death predicate proof
Per output record
Total
Enforce validity of:
Birth predicate ver. key
Birth predicate proof
Other
Enforce validity of:
Predicate commitment
Miscellaneous
45827
41742
87569
45827
41742
21792 · (cid:2) 3
1780
2(cid:3)
4 (m + n) + 1
Total with 2 inputs and 2 outputs (m = n = 2)
439224
TABLE IV: Number of constraints for RCP.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:02:38 UTC from IEEE Xplore.  Restrictions apply. 
959
Appendix A
Details of elliptic curves used in Zexe
In Fig. 8 we report details of the base ﬁelds and prime orders
of the elliptic curves EEd/BLS, EBLS, EEd/CP and ECP.
Construction of decentralized private computation
Appendix B
schemes
We describe our construction of a DPC scheme. In Sec-
tion B-A we introduce the building blocks that we use, and in
Section B-B we describe each algorithm in the scheme. The
security proof is provided in the full version.
A. Building blocks
CRHs. A collision-resistant hash function CRH = (Setup,
Eval) works as follows.
• Setup: on input a security parameter, CRH.Setup samples
public parameters pp
CRH.
CRH
CRH, x) = CRH.Eval(pp
• Hashing: on input public parameters pp
CRH.Eval outputs a short hash h of m.
CRH and message m,
← CRH.Setup(1λ), it is
Given public parameters pp
computationally infeasible to ﬁnd distinct inputs x and y such
that CRH.Eval(pp
PRFs.
A pseudorandom function family PRF =
{PRFx : {0, 1}∗ → {0, 1}O(|x|)}x, where x denotes the seed,
is computationally indistinguishable from a random function
family to anyone who does not know the x.
Commitments. A commitment scheme CM = (Setup,
Commit) enables a party to generate a (perfectly) hiding and
(computationally) binding commitment to a given message.
• Setup: on input a security parameter, CM.Setup samples
CRH, y).
public parameters pp
CM.
• Commitment: on input public parameters pp
CM, message m,
and randomness rcm, CM.Commit outputs a commitment
cm to m.
We also use a trapdoor commitment scheme TCM = (Setup,
Commit), with the same syntax as above. Auxiliary algorithms
(beyond those in CM) enable producing a trapdoor and using
it to open a commitment, originally to an empty string, to an
arbitrary message. These algorithms are used only in the proof
of security, and so we introduce them there.
NIZKs. Non-interactive zero knowledge arguments of knowl-
edge enable a party, known as the prover, to convince another
party, known as the veriﬁer, about knowledge of the witness
for an NP statement without revealing any information about
the witness (besides what is already implied by the statement
being true). This primitive is a tuple NIZK = (Setup, Prove,
Verify) with the following syntax.
• Setup: on input a security parameter and the speciﬁcation
of an NP relation R, NIZK.Setup outputs a set of public
parameters pp
• Proving: on input pp
(x, w) ∈ R, NIZK.Prove outputs a proof π.
• Verifying: on input pp