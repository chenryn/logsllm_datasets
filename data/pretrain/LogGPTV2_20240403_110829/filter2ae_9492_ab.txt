> this vulnerability and execute arbitrary code.
公告没有给出利用详情。不过根据另一份来自 TrendMicro 的公告，CVE-2007-3896, CVE-2007-3845 都是
CVE-2007-4041 的变体：
CVE-2007-4041 的详情在这个 Firefox 浏览器的 issue：  
可以看到多个测试用例，其中一个：
    Mailto:%
因为 url 中的 "%" 导致解析错误，最终当做路径执行了命令。
### MS10-007 (CVE-2010-0027)
2010 年类似的漏洞再次被发现：
> The vulnerability could allow remote code execution if an application, such
> as a Web browser, passes specially crafted data to the ShellExecute API
> function through the Windows Shell Handler.
公告中明确提到漏洞的根本原因是 ShellExecute 函数未能正确地处理传入的 url，错误地把 url 类型当做路径处理。
公开的 poc 如下：
    xyz://www.example.com#://../../C:/windows/system32/calc.exe
只要通过 ShellExecute* 调用即可触发。
### CVE-2007-3670
这是一个 Firefox 浏览器伪协议的参数注入，影响 Firefox 和 ThunderBird。
Firefox 注册了一个 FirefoxURL: 协议：
    [HKEY_CLASSES_ROOT\FirefoxURL\shell\open\command\@]
    C:\\PROGRA~1\\MOZILL~2\\FIREFOX.EXE -url “%1″ -requestPending
这篇文章的作者使用了引号闭合来注入任意参数  
    FirefoxURL://foo" --argument "my value
**看到 PoC 代码是不是非常眼熟？熟悉的引号闭合，熟悉的参数伪造。Electron 这个漏洞完全就是 10 年前 Firefox
曾经出现过的问题的复刻。**
最后通过 -chrome 参数注入的恶意脚本，利用 Firefox 特权域接口，可实现任意代码执行：
### CVE-2007-3186
CVE-2007-3670 的作者还对当时的 Safari Windows 版做了另一个形式的利用：
     bar | foobar "arg1'>
将会执行
    "C:\Program Files\My Application\myprotocol.exe" "someserver.com"  bar | foobar "arg1"
注意这个 poc 是相当过分了。在 Win32 Api 中无论是 CreateProcess _还是 ShellExecute_ 都是不支持管道符等 CMD
的特性的。唯一的解释就是，Safari 在打开外部 url 时使用了 system 函数！
同样地，作者还是使用了 -chrome 参数实现了对 Firefox 特权域的跨浏览器脚本攻击利用。
### 某聊天软件命令执行
在 2012 年某即时通讯软件爆出一个远程命令执行漏洞，在修复前 poc 就被恶作剧式地传播开来：
漏洞成因极有可能是实现打开网址时没有为其加入 `http://` 前缀而直接传给了 ShellExecute
函数，导致域名被系统当成路径名，结合目录遍历技巧可执行程序安装盘符下任意命令。但由于可控的参数仅为 lpFile，无法增加其他参数开关（能够实现参数注入是
url 场景而不是本地文件），实际利用效果不理想。
时至今日，您仍然可以在 Windows 上通过一行代码复现这个问题：
    ShellExecuteW(NULL, L"open", L"www.baidu.com..\\..\\", NULL, NULL, SW_SHOW);
代码将会打开一个资源管理器。将路径指向一个存在的可执行文件，可实现命令执行。
**小贴士**
不想装 VS 编译环境的，Windows 脚本宿主里有一个 COM 接口提供 ShellExecuteEx 的功能：
    var objShell = new ActiveXObject("shell.application");
    WScript.Echo("Attach me...");
    objShell.ShellExecute("www.baidu.com..\\..\\", "", "", "open", 1);
想要测试 ShellExecute* 的诡异特性的，可以直接用这个脚本，或者干脆在开始菜单、运行里输入 url。
### 某游戏客户端命令执行
在 HITB 2017 上，redrain 披露了一个某游戏客户端通过自定义 url scheme 执行命令的漏洞：[Attack Surface
Extended by URL
Schemes](https://conference.hitb.org/hitbsecconf2017ams/materials/D2T2%20-%20Yu%20Hong%20-%20Attack%20Surface%20Extended%20by%20URL%20Schemes.pdf)
在这个伪协议的一个参数中，期望的输入类型是 http(s) 协议的网址。但开发者居然使用 _mbsstr
（是否包含子串）来判断网址的有效性，而不是检查字符串的前缀。
最后的利用通过返回上层路径的方式绕过了其中的关键字检测，成功执行任意路径可执行文件：
    qqgameprotocol://shortcut/# URL=c:/windows/system32/http://qq.com/../../calc.exe ICON=3366xs.ico NAME=AAAAAAAA
    DESC=BBBBB TYPE=1 START=1
又是一个 ShellExecute 留下的坑。
## 寻找 url protocol
Android 下的 BROWSABLE 和 iOS 的 universal link
相信不少漏洞猎手和开发者已经很熟悉了，桌面端的关注度和资料相对少了一些。这大概是 Web 和移动端技术的迅猛发展带来的效应吧。
在分析 CVE-2018-1000006 的过程中就有人提问，如何寻找可用的伪协议。前文提到的一些资料里也出现了 macOS 下通过 url scheme
触发的安全问题。下面介绍一下如何枚举当前系统 url scheme 的方法。
早在 2009 年出版的 [Hacking: The Next
Generation](http://shop.oreilly.com/product/9780596154585.do) 一书中就提到了 url
scheme 在客户端软件中的攻击场景，并给出了三种平台（Windows、OS X、Linux）下枚举系统已注册伪协议的脚本（或程序）。
需要指出的是，书中提到 OSX 传递 url 参数使用了命令行，但目前 macOS 桌面应用传递 url scheme 使用的是 Apple Event：
    -(void)applicationWillFinishLaunching:(NSNotification *)aNotification
    {
        NSAppleEventManager *appleEventManager = [NSAppleEventManager sharedAppleEventManager];
        [appleEventManager setEventHandler:self
                               andSelector:@selector(handleGetURLEvent:withReplyEvent:)
                             forEventClass:kInternetEventClass andEventID:kAEGetURL];
    }
    - (void)handleGetURLEvent:(NSAppleEventDescriptor *)event withReplyEvent:(NSAppleEventDescriptor *)replyEvent
    {
        NSURL *url = [NSURL URLWithString:[[event paramDescriptorForKeyword:keyDirectObject] stringValue]];
        // handle it
    }
书中提供的 vbs 脚本还可以工作，但 mac 版本需要稍作修改才能通过编译。
在此提供一个可用的版本：  
    /*
      to compile: clang -fmodules schemes.m -o schemes
      then run `./schemes`
    */
    #import 
    #import 
    extern OSStatus _LSCopySchemesAndHandlerURLs(CFArrayRef *outSchemes, CFArrayRef *outApps);
    extern OSStatus _LSCopyAllApplicationURLs(CFArrayRef *theList);
    int main(int argc, const char * argv[]) {
        @autoreleasepool {
            CFArrayRef schemes;
            CFArrayRef apps;
            NSWorkspace *workspace = [NSWorkspace sharedWorkspace];
            _LSCopySchemesAndHandlerURLs(&schemes, &apps);
            for (CFIndex i = 0, count = CFArrayGetCount(schemes); i 
可以看到不少有趣的 url：
而他们会不会有新的漏洞呢？
## 参考资料
[1]. [Registering an Application to a URI
Scheme](https://msdn.microsoft.com/en-us/library/aa767914%28v=vs.85%29.aspx)  
[2]. [About Dynamic Data Exchange](https://msdn.microsoft.com/en-us/library/windows/desktop/ms648774%28v=vs.85%29.aspx)  
[3]. [Microsoft Security Bulletin MS07-061 -Critical](https://docs.microsoft.com/en-us/security-updates/SecurityBulletins/2007/ms07-061)  
[4].   
[5]. [Microsoft Security Bulletin MS10-007 -Critical](https://technet.microsoft.com/library/security/ms10-007)  
[6]. [URI Use and Abuse](https://www.blackhat.com/presentations/bh-dc-08/McFeters-Rios-Carter/Presentation/bh-dc-08-mcfeters-rios-carter.pdf)  
[7]. [Attack Surface Extended by URL
Schemes](https://conference.hitb.org/hitbsecconf2017ams/materials/D2T2%20-%20Yu%20Hong%20-%20Attack%20Surface%20Extended%20by%20URL%20Schemes.pdf)