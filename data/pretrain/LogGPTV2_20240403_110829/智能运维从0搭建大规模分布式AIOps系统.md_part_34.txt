第11章数据异常点检测技术
201
---
## Page 228
且k值的选取是全局的，不能处理具有不同密度区域的数据集。
这意味着如果数据量比较大，会导致计算代价过高，效率低下；②对k值的选取非常敏感，并
接用距离来识别异常点。但是,这种基于距离的算法也有其明显的缺点：①时间复杂度为0(m²)，
而错误地把一些小簇识别为异常点。
彼此的距离很近。但若k值选取太大，则点数小于k的集群中的点都有可能被识别为异常点，
如果数据集如图11-4所示，则会导致将圈中的两个异常点识别为正常的数据点，因为这两个点
常点得分的最低值是0，最大值是距离函数的可能最大值，一般为正无穷。
算法。在 KNN 算法中，基本思想是一个对象的异常点得分由到它的 k-最近邻的距离给定。异
易得多。
型，但是它仍能通过距离比较发现异常点。确定数据集的邻近性度量比确定它的统计分布要容
离大部分对象。这种方法比统计方法更一般、更普适。因为尽管数据集不满足任何统计分布模
11.2.2
复杂，基于统计模型的检测效果会比较差。
参数的估计）之上。这类方法对于低维数据效果可能较好，但是对于高维数据，数据分布非常
202
异常点对k 值的选取非常敏感，假设 k-1，则只取与对象点最近的点，求得距离。这样，
本节中，我们将为大家介绍最常用的k-最近邻算法（k-Nearest Neighbor)，下文简称 KNN
基于距离的异常点检测方法拓展了基本统计的思想，即如果一个对象是异常的，那么它远
 综上所述，两种基于统计模型的异常点检测方法，需要建立在标准的统计学技术（如分布
综上所述，KNN算法是基于邻近度的算法，不需要对数据集进行统计模型的拟合，可以直
智能运维：从0搭建大规模分布式 AIOps系统
基于邻近度的异常点检测
-1
图11-4k值选取示意图
4
---
## Page 229
密度的算法可识别局部异常点。
由距离来定义。所以，基于密度的算法时间复杂度也很高，也需要选择k值。但是，基于相对
end
for
end
forallxdo
（指定k值，作为最近邻个数）
测算法，可识别局部异常点。其简单的实现流程如下：
下：
大，那么大多数异常点的密度与正常点类似，则有可能不被识别出来。
这里需要谨慎选择d值，如果d值太小，那么大多数对象的异常点得分都会很低；如果d值太
义密度的方法公式如下：
那么如何定义密度，就直接决定了一个对象的异常点得分。定义密度的方法有以下三种。
11.2.3
综上所述，
其中，N(x,k)是x的k个最近邻的集合，n是该集合的大小。
（3）相对密度：即用点x的密度与它最近邻y的平均密度之比作为相对密度，数学公式如
（2）给定半径d内的个数：即一个对象周围的密度等于该对象指定半径d内对象的个数。
（1）逆距离：一个对象的密度为该对象周围k个最近邻的平均距离的倒数。这种逆距离定
由公式（11-3）计算出 outlier score(x,k）= average relative density(x,k)
allxdo
使用N(xk)中的对象，确定x的密度density(x,k)
其中，N(x,k)是x的k个最近邻的集合，n是该集合的大小。
从基于密度的观点来说，异常点是低密度区域中的对象，即密度越低，异常点得分越高。
for
for
确定x的k最近邻，
基于密度的异常点检测
基于密度的异常点检测算法，与基于距离的检测算法是密切相关的，因为密度
计作N(xk)
 average relative density(x, k) = 
2.
第11章数据异常点检测技术
density(x,k)
这种基于相对密度的异常点检
(11-3)
(11-2)
203
---
## Page 230
近1表示是异常点的可能性越高，越接近0表示是正常点的可能性越高，如果大部分训练样本
节点到根节点的路径 h(x)很短。因此，可以用 h(x)来判断一条记录是否属于异常值。
稀有的，在iTree 中很快会被分到叶子节点上。也就是说，在iTree 中，异常值一般表现为叶子
始搜索，确定测试记录落在哪个叶子节点上。iTree 能检测异常的假设是：异常点一般都是非常
录；②树的高度达到了高度阈值。
的记录放在右子树上。
给定数据集 D，这里 D 的所有属性都是连续型变量，iTree 的构成如下:
叉树，每个节点要么有两个子节点（称为左子树和右子树），要么没有子节点(称为叶子节点)。
时间效率高，能有效处理高维数据和海量数据。
能是异常点。本节中，我们将介绍独立森林（Isolation Forest）算法。
论是基于距离还是基于密度，都会得出一个异常点得分。这个分值越高，则代表该对象越有可
11.3
204
其中，n 为样本的大小，h(x)为记录x在iTree 上的高度。S(x,n)的取值范围为[0, 1]，越接
iTree 构造完成后，接下来对数据进行预测。预测的过程就是把测试记录从iTree 根结点开
(3)根据 A 对每条记录进行分类,把A 小于 value 的记录放在左子树上,把大于或等于value
独立森林是南京大学周志华老师提出的一种异常检测算法,在工业界很实用,算法效果好,
我们用一个归一化公式来计算异常指数S(x,n):
（2）随机选择该属性的一个值value。
首先，要理解独立森林，就必须了解什么是独立树，下文简称 iTree。iTree 是一种随机二
上一节介绍了几种传统的异常点检测方法，其基本思想是计算对象与周围对象的差异，无
（4）递归构造左子树和右子树，直到满足条件：①传入的数据集只有一条或多条一样的记
（1）随机选择一个属性A。
智能运维：从0搭建大规模分布式AIOps系统
独立森林
H(k)=ln(k)+，为欧拉常数
c(n)=2H(n-1)-(
S(x,n) = 2(-)
(2(n - 1))
(11-4)
---
## Page 231
到模型预测结果（y_pred_test, y_pred_outlier），1代表预测为正常点，-1代表预测为异常点。最
首先，有一个训练集 train，用其训练iForest 模型。然后，输入 test 数据集和 outlier 数据集，得
造，
不是把所有的属性都用上，而是通过峰度系数挑选一些有价值的属性，然后再进行iForest 的构
示记录x在每棵树的高度均值，c(n)的定义同公式（11-4)。
得很大，增加无意义的计算消耗。
的最大高度，因为异常值记录比较少，其路径长度也比较小。我们不需要将树的最大高度设置
采样前正常值和异常值有重叠，采样后可以有效区分正常值和异常值。并且，还需要限制iTree
不同树之间的差异。但不同的是，我们需要限制采样样本的大小。这是因为：如图11-5 所示，
iForest 的方法与构建随机森林的方法类似，都是随机采样一部分数据集来构造每一棵树，保证
的S(x,n)都接近 0.5，则说明整个数据集没有明显的异常值。
接下来，我们通过一个示例（Python 实现代码见下文）利用 iForest 算法进行异常点检测
，算法效果会更好。
综上所述，独立森林本质上是一种非监督算法，不需要先验的类标签。在处理高维数据时，
其中，S(x,n)就是记录x在由n个样本的训练数据构成的 iForest 的异常值得分，E(h(x))表
iForest 构建好之后，同样计算记录的异常指数 S(x,n):
当然，随机树是不稳定的，但是把多棵 iTree 结合起来，形成 iForest 就变得强大了。构建
DD
图11-5数据分布图（左图：采样前；右图：采样后）
D
44
第11章
。。
数据异常点检测技术
(11-5）
205
---
## Page 232
Y_pred_train = clf.predict(x_train)
clf.fit(x_train)
clf = IsolationForest(max_samples=100, random_state=rng)
plt.show()
plt.scatter(X_outliers.T[0],X_outliers.T[1])
X_outliers = rng.uniform(low=-4,high=4,size=(20,2))
#Generate some abnormal novel observations
X_test = np.r_[x + 2, X -
X = 0.3 * rng.randn(20,
x_train=np.r_[x+2，X-2]
#生成训练数据
rng = np.random.RandomState(42)
from sklearn.ensemble import IsolationForest
import matplotlib.pyplot as plt
import numpy as np
##独立森林示例实现代码
outlier 数据集完全吻合。
#fit the model
#Generate some regular novel observations
X
越高，颜色越浅代表异常值得分越低。可以看出，模型预测效果不错，颜色分布规律与 test 和
后，我们对整个图形空间的点输入模型，得到如图11-6所示的结果，颜色越深代表异常值得分
206
( = 0.3 * rng.randn(100, 2)
智能运维：从O搭建大规模分布式AIOps 系统
2）
2]
abnormal
regular
图11-6
iForest算法预测结果
---
## Page 233
 Data Mining IEEE, 2009: 413-422
整版．北京：人民邮电出版社，2011年
11.5
致较高的误报率。
是一项具有挑战性的任务，这些挑战通常会导致解决方案不是可扩展的或高度专业化的，也导
如检测、欺诈检测、网络入侵检测等。尽管它至关重要，但是实际上实现全自动异常检测系统
11.4
plt.show()
plt.legend([b2, c],["regular", "abnormal"], loc="upper left")
plt.ylim((-5，5))
plt.xlim（（-5，5）)
plt.axis('tight')
c = plt.scatter(X_outliers[:, 0], X_outliers[:, 1], c='red',
b2 = plt.scatter(x_test[:, 0],X_test[:, 1], c='green',
plt.contourf(xx, yy, Z， cmap=plt.cm.Blues_r)
Z=Z.reshape(xx.shape)
()su(o)su.d)sdu=xx
#plot the line,the samples，and the nearest vectors to the plane
Y_pred_outliers = clf.predict(x_outliers)
Y_pred_test = clf.predict(x_test) 
 [4] F. T. Liu, M. T. Kai, Z. H. Zhou. Isolation Forest. Eighth IEEE International Conference on 
[3]王斌会，陈一非．基于稳健马氏距离的多元异常值检测.统计与决策，3x(2005):4-6
[2] Pang-Ning Tan,Michael Steinbach,Vipin Kumar 著.范明，范宏建等译．数据挖掘导论.完
[1] Yahoo.Generic and Scalable Framework for Automated Time-series Anomaly Detection
异常检测是很多具有故障应用的实时监控系统的核心部分，也被应用到非常广泛的领域，
参考文献
本章小结
s=20, edgecolor='k')
s=20，edgecolor='k')
第11章数据异常点检测技术
207
---
## Page 234
可能会导致一个或多个错误。
根据持续时间故障可以分为如下几种。
中的定义，故障管理领域的基本概念如下。
故障诊断和分析策略
第12
也是各不相同、纷繁复杂的，很难做到统一标准。
套开发语言、框架、容器和流程，因此，每个系统记录的日志格式、发出的告警、自动化手段
支持。
正如读者所看到的，除了上面介绍的智能化辅助方法，故障诊断和定位还需要一些基础工作的
一般情况下，业务系统经过多年的演化，各个环节、不同部门之间已经不太可能采用同一
在前面的章节中已经涉及了部分告警聚合和收敛、异常点检测等和故障分析相关的技术，
症状：失败的外在表现，一般会通过告警、Dashboard 等被观察到。
错误：计算值、观测值与真实的或理论上的正确值之间的差异，错误是故障的后果，故障
事件：定义为软硬件或操作中发生的异常情况。
根据IBM沃森研究中心的论文A survey of fault localization techniques in computer networksl
〇永久的：在修复之前会一直存在。
故障（也称为问题或根源）：
级、扩容、摘除等自动化手段)。
短暂的：瞬时的故障会导致服务暂时性轻微退化，它们通常会自动恢复（通过自动降
间歇性的：发生在不连续和周期性基础上的短时间的服务退化。
章
一类可能导致其他事件发生，但不是由其他事件引起的事件。
---
## Page 235
缩放，使之落入一个小的特定区间，以便不同单位和量级的数据可以进行比较和加权。
据标准化”这个概念，数据标准化是为了对数据进行分析，对数据进行指数化，将数据按比例
在日志收集之前，
“先收上来再说”，导致大量余、无用的日志信息占用空间和带宽，长时间没人使用。所以，
的帮助。
采集/传输程序都支持给日志加标签)，否则这样的日志在分析和定位故障工作中很难有比较大
样，没有标识前后端信息，如果集中处理这些日志，除非在采集/传输过程中增加标识（大部分
些部门前端用的是PHP，后端用的也是PHP，这样通过PHP日志函数记录的日志看起来完全一
接入的日志就可以自动处理，不必为每一类日志都单独做ETL。
大家都按照 Nginx/Apache 格式来规范、记录，那么后面的 ETL 和运算模型可以大大简化，新
日志相对有标准，那么后面的各个环节的通用性和自动化程度就会提高不少。比如，访问日志
ETL 过程和运算模型，在运维实践中，日志的ETL 和运算通常都是付出成本最多的地方。如果
中大部分日志都是这样的）会加重后面的ETL、运算环节的负担，每一类日志都要对应单独的
章节中读者已经了解到日志的采集、传输、ETL、运算环节，非标准化的日志（很遗憾，现实
义就是：
12.1
栈）、效果又明显的基础工作，可以大大提高异构系统之间的关联性，提供相对规范的数据。
在运维实践中，很多时候为了提高日志采集、接收的效率，而不做任何标准化和预处理，
在异构系统的互联互通中，
另外，需要说明的是，日志标准化指的是日志格式和内容要有一定的标准。它不同于“数
其次，如果日志能实现自我标识，那么会大大方便对故障的分析和定位。举一个反例：有
日志标准化的好处是显而易见的。首先，标准化的日志有利于提高自动化程度。在前面的