title:Usage control platformization via trustworthy SELinux
author:Masoom Alam and
Jean-Pierre Seifert and
Qi Li and
Xinwen Zhang
Usage Control Platformization via Trustworthy SELinux
Masoom Alam
IM | Sciences
Peshawar,Pakistan
PI:EMAIL
Qi Li
Dept of Computer Science
Tsinghua University, Beijing, China
PI:EMAIL
Jean-Pierre Seifert
Samsung Information Systems America
San Jose, California,USA
PI:EMAIL
Xinwen Zhang
Samsung Information Systems America
San Jose, California,USA
PI:EMAIL
ABSTRACT
Continuous access control after an object is released into a dis-
tributed environment has been regarded as the usage control prob-
lem and has been investigated by different researchers in various
papers. However, the enabling technology for usage control is
a challenging problem and the space has not been fully explored
yet. In this paper we identify the general requirements of a trusted
usage control enforcement in heterogeneous computing environ-
ments, and also propose a general platform architecture to meet
these requirements.
Categories and Subject Descriptors
K.6 [MANAGEMENT OF COMPUTING AND INFORMA-
TION SYSTEMS]: Security and Protection; K.4.4 [Electronic
Commerce]: Security
General Terms
security
Keywords
Trusted Computing, Usage Control, SELinux
1.
INTRODUCTION
The traditional access control problem [9, 12, 16] is considered
in closed environments where identities of subjects and objects can
be fully authenticated and enforcement mechanisms are trusted by
system administrators which deﬁne access control policies. How-
ever, with increasing distributed and decentralized computing sys-
tems, more computing cycles and data are processed on leaf nodes.
This leads to two distinct access control problem spaces. The ﬁrst
one focuses on the reasoning of authorizations with subject at-
tributes from different authorities. For example, in trust manage-
ment [4, 8, 13, 17] systems, a user presents a set of attributes or
credentials and another subject (e.g., a resource or service provider)
can determine the permissions of the user based on the presented
credentials.
In this problem, objects are typically protected in a
centralized server. The second problem focuses on continuous con-
trol on accesses to an object after it is distributed to other (decen-
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ASIACCS ’08, March 18-20, Tokyo, Japan
Copyright 2008 ACM 978-1-59593-979-1/08/0003 ...$5.00.
tralized) locations or platforms, which is called the usage control
problem proposed by researchers in literatures [14, 19, 20, 23].
Although there is no precise deﬁnition in the literature, the main
goal of usage control is to enable continuous access control to ob-
jects after an object is released to a different control domain from
its owner or provider, especially in highly distributed and hetero-
geneous environments. Typically, a usage control policy is deﬁned
for a target object by its stakeholder, which speciﬁes the conditions
that accesses to the object on a target platform can be allowed. A
stakeholder can be the owner of a target object, or a service provider
that is delegated by the object owner to protect the object. An ob-
ject in usage control can be static data, various types of messages,
or user or subject attribute or even a credential. Thus, this makes
the problem pervasive in many distributed computing applications
such as healthcare information systems, Web Services, and iden-
tity management systems. Different from other distributed access
control problems, such as trust management, in usage control, an
object is located out of the controlling domain of a policy stake-
holder such that (1) there are many aspects of access control deci-
sions other than subject identities and attributes, and (2) an object
stakeholder needs high assurance on the enforcement of the policy.
As Figure 1 shows, an object and its usage control policy are
distributed from a data provider to a target platform. The policy is
enforced in the platform to control the access to the object within
a trusted subsystem. Typically, an access control decision is deter-
mined according to pre-deﬁned factors speciﬁed in a policy, which,
logically, can be deﬁned based upon the information of the sub-
ject and the object of an access request, where the subject is an
active entity trying to perform actions on the passive entity object.
In closed access control systems such as in a local platform, poli-
cies are deﬁned based upon the identities of subjects and objects.
In traditional distributed access control systems such as trust man-
agement, policies are deﬁned based on attributes or credentials that
are certiﬁed by external authorities. However, in usage control,
access control policies can be deﬁned by very general attributes
of subjects and objects, such as application-speciﬁc attributes and
temporal status. Furthermore, as an object can be located on vari-
ous platforms in a heterogeneous environment such as a mobile de-
vice, environmental restrictions and system conditions are manda-
tory decision factors in many applications, such as location-based
service and time-limited access. An ongoing access should be ter-
minated if these environmental or system conditions change which
violate policies. For example, a mobile application might require
that a service can be used only if a mobile device is in a particu-
lar location, which itself is activated by a user through the service
agent deployed on the mobile device. Simply relying on traditional
access control mechanisms in a target platform cannot satisfy these
245
requirements since the decision factors (i.e., subject and object at-
tributes) of these approaches are mostly static and pre-deﬁned and
cannot ﬁt a dynamic computing environment.
Figure 1: Abstract architecture
As usage control is naturally distributed, another challenge to
enforce usage control policies is the trustworthy of the security
enforcement mechanism. Typically, an access control decision is
made and enforced by a reference monitor, which has the require-
ments of being tamper-proof, always-invoked, and small enough [5,
10] — which is relatively easy to achieve at least in closed systems.
Note that in trust management systems, policy enforcement is still
within the stakeholder’s control domain of an object. However,
as objects or services are deployed to different domains from its
stakeholder, a mandatory requirement for usage control is the trust-
worthy enforcement of security policies by the reference monitor.
Here, through trustworthiness, a stakeholder needs to ensure that
(1) all factors for usage control decisions can be obtained and their
information (e.g., attribute values or environmental conditions) are
authentic, (2) correct decisions are made based on these factors, (3)
the reference monitor enforces access control decisions correctly,
and (4) all accesses to a target object on a target platform have to
go through the reference monitor. Overall, by a “trusted subsys-
tem” we mean that it is expected to behave in a “good” manner and
this manner can be especially veriﬁed by the policy stakeholder.
Previous work on usage control focus on high level policy spec-
iﬁcations and conceptual architectures [14, 19, 20, 23], while the
enabling and trusted mechanisms are mainly relied on digital rights
management (DRM) approaches. However, DRM mechanisms
cannot support general attributes and trusted enforcement in ubiq-
uitous environments. Most importantly, DRM approaches cannot
provide an overall solution for usage control in open and general-
purpose target platforms, since they usually rely on software-
enabled payment-based enforcement in relatively closed environ-
ments, e.g., through a media player by connecting to a dedicated
license server. Another intuitive solution is to use cryptography
algorithm. For example, a stakeholder can encrypt a target object
such that it only can be decrypted on a target platform with a par-
ticular application. Fundamentally, this has the same problems as
the DRM approach, since a typical DRM scheme relies on encryp-
tion/decryption with a unique key shared between a client and con-
tent server [1, 3]. Particularly, cryptography alone cannot protect
the key during the runtime on a target platform such as to build a
trusted subsystem [18]. For example, malicious software can eas-
ily steal a secret by exploring some vulnerability of the protection
system, either when the secret is loaded in some memory location,
or when the secret is stored locally.
As one of the main contributions of this work, we consider the
integrity of a subsystem in access control mechanisms. With this,
not only traditional subject and object attributes are considered in
access control decisions, but also the integrity information of sub-
jects and objects, and any other components necessary in a trusted
subsystem. The overall goal of our approach is to build a “virtu-
ally closed” and trusted subsystem for remote usage control policy
enforcement.
The present paper is organized as follows. Section 2 summa-
rizes the principles to build a distributed usage control system. We
describe a platform architecture to build a trusted subsystem in Sec-
tion 3. We eventually conclude this paper and present our ongoing
work in Section 4.
2. DESIGN PRINCIPLES
In our work, we have identiﬁed the following general security
requirements and design principles for usage control.
Requirement 1: Need high assured but usable security mechanism
Typically in usage control, objects are located out of the domain
of a stakeholder such that high assurance of policy enforcement
is desired. However, as usage control is such pervasive that it
happens in open and general-purpose platforms and “usable secu-
rity” mechanism is strongly desired for cost-effective objective.
For example, leveraging local host access control mechanism to
enforce usage control policy is desirable if the mechanism can be
trusted to do the “right” thing. That is, the goal of pervasive usage
control is not to provide a perfect solution for security but to be
“good-enough” [22].
Requirement 2: Need a comprehensive policy model Traditional
security systems distinguish policy and mechanism [15]. However,
early policy systems such as Bell-LaPadula [6] and Biba [7] are too
restrictive for convenient use of applications. They support simple
policies such as one-way information ﬂow but provide insufﬁcient
and inﬂexible support for general data and application integrity,
separation of duty and least privilege requirements. Besides these,
usage control considers many constraints or conditional restrictions
such as time and location as aforementioned. Traditional policy
models cannot supports these and we need a comprehensive policy
model to support the variants of security requirements.
Requirement 3: Need MAC mechanism for trusted subsystem on a
target platform As in discretionary access control model (DAC),
a root-privileged subject has the capability to change security
conﬁguration of the whole system such that the subsystem can be
compromised either by malicious user or software. For example,
a virus or worm can obtain the root permission of a system by
exploring some vulnerabilities, e.g., with buffer-over-ﬂow attacks.
Thus, mandatory access control (MAC) mechanism is needed.
For example, with SELinux, one can label the applications and
all resources of a subsystem with a particular domain and deﬁne
policies to control the interactions between this domain and others
for isolation and information ﬂow control purposes.
Requirement 4: Need a polity transformation mechanism from high
level usage control policies to concrete MAC policies Typically, a
stake holder’s policy is speciﬁed in different format and semantics
from those of the MAC policies on a target platform. For example,
a stakeholder can be implemented as a Web Service, where a
security policy is speciﬁed in XACML. This policy has to be
transformed to a concrete policy that can be enforced on a target
platform, which follows its local MAC policy model. Efﬁcient and
convenient policy transformation mechanism is needed such that
security properties are preserved during the transformation, which
means, the allowable permissions and information ﬂows are the