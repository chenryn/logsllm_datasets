since it skips many of the expensive public-key operations
of a full key exchange. For example, the vast majority of
TLS connections between web browsers and major websites
like Google perform session resumptions rather than full key
exchanges.
A full key exchange followed by re-keying or resumption
can be treated as a compound authentication protocol, except
that the re-keying protocol does not change the client or server
credentials. Instead, it simply performs a key conﬁrmation
of the previous session key sk and generates a new session
(cid:48). For example, in TLS resumption, the new key is
key sk
7
computed from the old master secret plus the new random
nonces generated by the client and the server:
params(cid:48) = (ci = cr = ⊥, cr(cid:48), sr(cid:48), sid , nego)
secrets(cid:48) = sk
(ms, cr(cid:48), sr(cid:48))
= kdf TLS
(cid:48)
2
The compound authentication goal for re-keying is that if
the session secrets and peer credentials in the original session
are not compromised, then the two principals agree upon both
the old and new session parameters (params, params(cid:48)) and
session keys (sk , sk
(cid:48)).
Re-exchange and re-authentication:
In addition to re-
keying, many key exchange protocols also allow the initia-
tor and responder to perform a second key-exchange to re-
authenticate each other. In TLS, this is called renegotiation
while in SSH it is called re-exchange. For IKEv2, there is a
proposed extension that allows re-authentication in the style of
TLS [30].
The TLS renegotiation is a full key exchange and both
the client and server may authenticate themselves using cre-
dentials that differ from the previous exchange. This feature
was famously subject to a man-in-the-middle attack [3], [4]
and in response to this attack all TLS libraries implement a
mandatory channel binding countermeasure [12] that binds the
renegotiation key exchange to the the transcript of the previous
handshake. More precisely, each TLS handshake generates a
channel binding of the form:
cb = (verifydata(log 1, ms), verifydata(log 2, ms))
The subsequent handshake agrees on this channel binding
value, and by including it in the key exchange, the chain of
channel bindings on a connection guarantees agreement on the
full sequence of protocol assignments on a connection [15].
The SSH re-exchange is also a full server-authenticated key
exchange where the server’s host key and other parameters may
be different from the previous exchange. Unlike TLS, however,
SSH uses the sid, that is the hash H of the ﬁrst exchange on
the connection, as a channel binding for all subsequent key
exchanges on the connection. In particular, during the second
SSH key exchange, a new set of parameters and secrets are
generated, but the session id does not change. Hence, the new
session key is computed as
sk = kdf SSH (gxy mod π, H(cid:48), sid )
where H(cid:48) is the hash computed during the new exchange the
sidis still the hash computed in the ﬁrst exchange.
The proposed re-authentication protocol for IKEv2 [30]
is inspired by TLS renegotiation and treats the AUTH I and
AUTH R payloads as channel bindings for re-authentication. It
runs a new IKE_SA_INIT protocol and within this protocol
and a new IKE_AUTH protocol that binds the initiator and
responder credentials to the AUTH I and AUTH R payloads
of the previous IKEv2 session.
III. CHANNEL SYNCHRONIZATION ATTACKS
In the previous section, we described a number of com-
pound authentication protocols that implement the channel
binding pattern of Figure 3 in order to prevent man-in-the-
middle attacks like the one in Figure 2. Now we will evaluate
a number of these channel binding mechanisms to see if they
succeed in preventing such attacks.
A channel binding countermeasure only works if the
channel binding values for independent protocol sessions are
different. Hence, we observe that if the man-in-the-middle
attacker manages to synchronize the channel bindings on its
protocol sessions to two different principals, it can re-enable
the credential forwarding attack. We call such attacks channel
synchronization attacks. More generally,
if two principals
engage in a sequence of protocols, we say that they are subject
to a channel synchronization attack if the channel binding
generated by the ﬁnal protocol is the same at both principals
and each principal used an honest credential to authenticate
itself (somewhere in the protocool sequence), but the two
principals do not agree on some protocol parameter.
A channel synchronization attack typically leads to an
impersonation attack on compound authentication after one
more protocol, since agreement on the ﬁnal channel binding no
longer guarantees agreement on all previous protocol instances.
It may be easier to understand such attacks by example, and
we shall see several concrete examples below.
A. Triple Handshake Attacks on TLS
First,
they show that
The triple handshake attacks [16] show that a number
of TLS channel bindings fail to prevent man-in-the-middle
attacks. For the full details of the attacks we refer the reader
to the original paper and to our ProVerif models. Here, we
summarize their impact and identify their general principles.
the master secrets ms in TLS-
RSA and TLS-DHE can be synchronized across two different
TLS connections. This means that
the EAP cryptographic
binding (based on (ms, cr, sr)) does not provide compound
authentication and still leads to man-in-the-middle attacks on
protocols like PEAP, EAP-TTLS, and EAP-FAST. The fact that
RSA-based key transport protocols like TLS-RSA allow key
synchronization was well-known (see e.g. the famous attack on
the Needham Schroeder public-key protocol [31]). However,
the impact of key synchronization on compound authenti-
cation was identiﬁed only in [16]. The key synchronization
attack on TLS-DHE is more surprising since Difﬁe-Hellman
key exchanges are expected to be contributive: both parties
contribute to the established key. But TLS allows servers to
choose arbitrary DH groups, even ones with non-prime orders,
and clients do not validate the group, enabling the attack.
Second, they show that the handshake transcripts (log 1,
log 2) can be synchronized across two different TLS connec-
tions that use session resumption after an initial TLS-RSA
or TLS-DHE key exchange. In particular, this means that the
tls-unique channel binding (derived from the transcript)
can be synchronized after session resumption. Hence, if we run
SCRAM after resuming a TLS-RSA session, a credential for-
warding attack on SCRAM becomes possible, despite its use of
channel bindings. Moreover, the channel binding used by TLS
renegotiation (verifydata(log 1, ms), verifydata(log 2, ms)) can
also be synchronized and hence mutually authenticated TLS
renegotiation after session resumption is also subject to a MitM
impersonation attack. Since the transcripts of the two connec-
tions have been synchronized, it means that countermeasures
such as [6], [14], [5] are also broken after session resumption.
8
The triple handshake attacks had a strong impact: ﬁxes to
major TLS libraries and web browsers and a new protocol-level
countermeasure that is being standardized and implemented
as a protocol extension [19]. In the rest of this section, we
investigate whether such synchronization attacks apply to other
key exchanges used within TLS, IKEv2 and SSH.
B. Key Synchronization via Small Subgroup Conﬁnement
Difﬁe-Hellman key exchange protocols are based on prime-
order groups, typically written (π, q, g) where q is a prime less
than π and g generates a q-order subgroup of [1..p − 1]. All
participants are expected to choose private keys in the range
[1..q−1]. However, such protocols are known to be vulnerable
to various attacks when the group has small subgroups (see
e.g. [32]). In particular, we show that small subgroups can be
exploited for key synchronization.
For all π, there is at least two subgroups of size 1 ({0},{1})
and one subgroup of size 2 ({1, p − 1}). So, if one of the
participants chooses a Difﬁe-Hellman public key of 0, no
matter what exponent y the other participant chooses, the
resulting shared secret will be 0x mod π = 0. Similarly, by
choosing 1 or p − 1 as a public key, one of the participants
of the key exchange can force the shared secret to be a ﬁxed
value, no matter what the other participant chose. This is called
a small subgroup conﬁnement attack: rather than honestly
choosing a public key in the q-order subgroup, a malicious
participant can force its peer to compute in a smaller subgroup
where the resulting shared secrets are predictable (or at least
guessable from a small set of values).
We advocate that, in order to eradicate such attacks, both
participants should validate the groups and public keys they
receive, say using the rules in [33]. The tests ensure that the
public key is in the q-order subgroup and is not equal to 1. Still
many protocol implementations do not perform these checks:
either because the protocol itself does not provide enough
information (e.g. a TLS server provides the generator g and
the prime π, but not the order q); or for efﬁciency (the checks
require an exponentiation by q); or because it is commonly
believed that small subgroup conﬁnement attacks only matter
when keys are reused [34]. We show that these attacks can
break compound authentication even if keys are never reused.
1) Key Synchronization in IKEv2:
IKEv2 can be used
with a number of well-known MODP groups including the
groups 22-24 that have many small subgroups [35]. However,
the speciﬁcation for IKEv2 public-key validation [34] only
requires implementations to check for 0, 1 and p − 1, but
does not require it to check that the public key is in the q-
order subgroup, as long as it does not reuse private exponents.
Indeed, a number of open source IKEv2 implementations that
implement these groups skip the q-order check. This leads to
the following key synchronization attack.
Suppose an initiator I connects to a malicious responder
M, which then in turn connects to an honest responder
R. During the IKE_SA_INIT key exchange, M forwards
messages between I and R but it uses its own Difﬁe-Hellman
public key. M chooses as its public key a generator g(cid:48) of
a small k-order subgroup and sends it
to both I and R.
Consequently the resulting Difﬁe-Hellman shared secrets on
both connections is in the k-order subgroup and there is a 1/k
chance of both secrets being the same.
Since M has also synchronized the nonces NI and NR,
the session key sk on both connections also has a 1/k chance
of being the same. So any compound authentication protocol
that relies on a channel binding derived from (sk , NI , NR) (as
proposed in [36]) is vulnerable to a man-in-the-middle attack.
2) Key Synchronization in ECDHE with Curve25519: The
named elliptic curves used with TLS and other protocols
typically do not have any small subgroups, but
there are
many new proposals and prototype implementations that use
Curve25519 [37], because its implementations are faster and
because it does not require any public key validation (all
32-byte strings are said to be valid public keys). However,
Curve25519 has a subgroup of size 8, and hence there are 12
points that fall in small subgroups. Yet, implementations of the
curve typically do not forbid these values, trusting that “these
exclusions are unnecessary for Difﬁe-Hellman”.1
Hence, if a client C and server S both allow Curve25519
public keys in the 8-order subgroup, a man-in-the-middle M
can mount a key-synchronization attack to obtain the same key
on two connections with probability at least 1/8. Consequently,
TLS-ECDHE with Curve25519 also becomes vulnerable to the
ﬁrst stage of the triple handshake attacks.
More generally, checking that a public key point
lies
on a curve is quite efﬁcient (one scalar multiplication) and
we advocate that
this check should always be performed,
otherwise a similar attack becomes possible on any curve.
3) Key Synchronization in SRP: The SRP protocol uses a
Sophie-Germain prime π that has only the usual small sub-
group values 0, 1, p − 1. The initiator and responder exchange
two values A = ga mod π and B = (gb + kvu) mod π where
vu = gxu mod π is the password veriﬁer. The SRP speciﬁcation
says that A and B must not be 0 but does not otherwise require
any public key validation. Indeed the OpenSSL implementation
of TLS-SRP does not perform any additional checks on A and
B. This leads to a key synchronization attack.
Suppose a malicious server M registers its own username
and password at S and suppose it chooses xu = 0; that is, the
veriﬁer vM = 1. Now, suppose the client C connects to M
using SRP. M chooses B = 1 + kvu (i.e. b = 0) so that the
resulting session key sk = gb(a+hxu) = 1. Meanwhile, suppose
M separately connects to S using its own credential xM , and
chooses A = 1 (a = 0). Again, on this connection the resulting
session key sk = gb(a+hxu) = 1. The two connections have
different client and server credentials, but the resulting session
key is the same. Consequently, using TLS-SRP in the initial
handshake also leads to the triple handshake attacks.
C. Transcript Synchronization via Session Resumption
A number of compound authentication protocols use the
transcript of the previous (outer) authentication protocol as
a channel binding. For example, both TLS renegotiation and
the tls-unique binding use a channel binding derived
from the TLS handshake log. IKEv2 authentication and re-
authentication both use AUTH payloads derived from the
1http://cr.yp.to/ecdh.html
preceding IKE_SA_INIT transcript as a channel binding. In
contrast, SSH only uses the transcript of the ﬁrst exchange on
the connection, not the most recent exchange.
Protocols that rely on transcript for channel bindings must
be wary of session resumption, since the transcript of a
resumption (or re-keying) handshake is necessarily abbreviated
and does not authenticate all
the session parameters. For
example, the transcripts of both TLS and IKEv2 resumption
only guarantee agreement on the previous session keys sk, but
not on other parameters. Consequently, like TLS resumption,
IKEv2 resumption leads to a transcript synchronization attack.
Suppose a man-in-the-middle M has managed to imple-
ment a key synchronization attack across two connections as
described above, one from C to M and the other from M to S.
At the end of this key exchange, the values (sk , NI , NR) on
the two connections are the same. Now suppose C resumes
its session with M and M resumes its session with S.
M can simply forward the IKE_SA_INIT and IKE_AUTH
messages of session resumption between C and S since the
original session keys are the same. M will not know the
new session keys, but at the end of the resumption exchange,
the two authentication payloads (channel bindings) AUTH I
and AUTH R are the same (even though the identities and
credentials used in the original key exchange were different.)
Consequently, if this channel binding is used in a subsequent
user authentication protocol or by IKEv2 re-authentication, it
will lead to a man-in-the-middle credential forwarding attack.
In other words, we have reconstructed a variant of the TLS
triple handshake attack on the composition of IKEv2, IKEv2
session resumption and IKEv2 re-authentication. The impact
of this attack is not as strong as the TLS attack since both
IKEv2 re-authentication and IKEv2 channel bindings are not
yet widely implemented or used.
D. Breaking Compound Authentication for SSH Re-Exchange
The SSH re-exchange protocol uses the session id sid as
a channel binding, where sid is derived from the transcript
of the ﬁrst key exchange on the connection. Consequently,
each exchange on an SSH connection is bound to the ﬁrst
exchange; however, these subsequent exchanges are not bound
to each other. This is in contrast to the TLS renegotiation
countermeasure [12] which chains together the whole sequence
of key exchanges on a given connection.
We show that a sequence of three SSH exchanges may
break compound authentication, if the attacker succeeds in
compromising the session secrets of the ﬁrst exchange.
The protocol ﬂow that exhibits the vulnerability is depicted
in Figure 7. Suppose a client C executes an SSH key exchange
and user authentication with a server S. Now suppose a
malicious server M compromises the session key sk and
session id sid (by exploiting a bug at the client or at the server,
for example.) Suppose C initiates a second key exchange.
Since M knows the session key, it can intercept this key
exchange and return its own host key (SSH allows a change
of host keys during re-exchange). At the end of the second
key exchange, the session keys and other parameters at C
and at S are now different, but the session id remains the