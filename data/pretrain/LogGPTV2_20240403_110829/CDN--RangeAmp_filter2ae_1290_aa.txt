# CDN安全-论文复现-RangeAmp攻击
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
论文名称：《CDN Backfired: Amplification Attacks Based on HTTP Range Requests》
论文链接：
论文简介：2020年清华大学巨佬发布在IEEE/IFIP International Conference on Dependable Systems
and Networks (DSN)上，同时被获得2020年DSN最佳论文。本文主要介绍了基于HTTP Range
Request机制下的HTTP放大攻击，同时本文的实验结果表明，能将原始流量放大至数万倍。可以利用此种方式发送高效率的DDos攻击。
文章简介：本文主要对论文内容进行阐述，最后我对作者所提及的漏洞进行了复现，并详细的撰写复现过程。
## 0x01:摘要
首先简单介绍CDN的当前在网络中的现状，其次介绍HTTP-RANG的由来，并且着重介绍：在RFC文件中建议CDN厂商都支持，当前CDN厂商确实都支持，但是在部署上存在严重的问题。接着引出他们发现的攻击类型（OBR）(SBR)，介绍他们提出的攻击在实验中的结果。最后他们提出简单的防护措施，并将漏洞和防御方法都发给供应商和用户。最后总结介绍论文的三个贡献：
> 1.作者发现了两种基于RangeAmp的两种攻击方式。  
>  2.作者测试了13个CDN厂商并且确定了攻击的可行性。  
>  3.作者提出了短时间的解决方案。
## 0x02:背景
###  0x01:CDN的背景
CDN(内容分发网络)：是指一种透过[互联网](https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%AF%E7%B6%B2)互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户（维基百科）。简单的来说，假如你有一台服务器在北京，而你本人在广东，你访问服务器时，你的请求需要从广东发送到北京，这之间经过多个网络设备以及长距离的传输，存在较高的网络延迟。如果你使用CDN，CDN将会为你在全国各地区分配多台服务器，每台服务器上缓存你服务器上的资源。此时你从广东访问你的服务器，如果请求的目标资源被缓存至CDN节点，那就可以直接访问广东的CDN节点的缓存，来获得响应，降低了网络延迟。
作者拿一次客户端请求服务端的完整过程做了详细的介绍。其请求过程如下：用户对服务器请求目标资源。DNS解析将最终跳转到CDN服务商。CDN服务商根据IP的地址为其分配最近的CDN节点。CDN检查目标资源是否被缓存，如果被缓存，直接返回缓存信息。如果目标资源没有被缓存，则将去请求源服务器，同时缓存目标资源。
同时作者指出下图中的CDN，可能不止是一个CDN厂商，可能是多个CDN厂商相互套用加速。如果多个厂商相互套用的情景下，图中的Ingress
Node称之为FCDN，Egress Node称为BCDN。在本章节的最后，作者提出在请求CDN资源末尾加上随机的get参数，能够绕过CND的缓存。例如
1M.zip?adasda=1，能够使CDN去请求源站资源。
###  0x02：HTTP Range Requset机制
由于请求被取消或者TCP连接丢失，HTTP在传输过程中往往发生中断，HTTP协议却又是无状态的应用程序。而HTTP Range
Request就是为了解决这一问题，它能够快速恢复，重新传输丢失的部分。HTTP Range
Requset机制，允许用户请求目标资源的部分内容。只要在请求中加入`Range:`请求头。作者介绍了两种Rang请求的用法：
    请求一个文件的部分通常在HTTP请求头中加上Range: bytes=[first_byte-last_byte]或者Range: bytes=[-suffix_length]。
    多段式Range请求，在Range中分多段请求部分数据，在第一部分的基础之上加上逗号进行分割。
图中a请求对应着图c响应，同样的b对应d。在图a中`Range:bytes=0-0`为请求目标资源中第一个字节数据。在图C中服务端响应客户端请求，返回206状态码，以及目标资源一个字节的数据。图b中`Range:bytes
=
1-1,-2`请求目标资源第二个字节,和文件的最后两个字节。图d服务端对图b做出了响应，返回206状态码，和两段资源，其中可以发现每段响应都带着`Content-Range`和`Content-Type`这个请求头，`Content-Range`包含目标文件的大小，`Content-Type`包含目标文件的格式。作者提出可以通过发送一个`Range:
bytes=0-0`来判断是否支持Range请求，如果支持则response中状态码为216，如果不支持则返回200。
## 0x03:CDN中的 HTTP -Range-Request
在作者测试的13个CDN中发现目前存在的CDN中对HTTP Range请求存在三种响应方式。
    Laziness:对于用户发来的Range请求，直接转发给源主机。
    Deletion：直接将请求头的Range删除，然后请求整个资源。
    Expansion：将Range的范围扩大至一定的范围。
经过试验作者发现大部分的CDN都是采取删除方案或者扩大方案，因为CDN厂商坚信既然请求部分数据，那必定会请求其他数据，所以不如直接把用户请求的资源完整的缓存在CDN服务器上。本章节的最后作者介绍了下Range请求在RFC文档中定义的变化：在RFC2616中并没有对Range请求做限制，但是由于攻击者发现CVE-2011-3192漏洞：“Apache
Killer”，攻击者发现通过创建大量的多范围的Range请求的线程，可以消耗尽Apache服务器上的内存。因此在RFC7233中对Range请求做了一些限制：”对于大量小范围的Range请求，以及两个以上请求范围有重复的Range请求，服务器应该忽略、合并或者拒绝”。但是显然作者测试的13个CDN并没有这样做。
## 0x04：攻击模型介绍
这一部分作者主要详细介绍了两种攻击模型。一种是SBR攻击，另一种是OBR攻击。首先简单的阐述了两种攻击的攻击方式以及目标。
    SBR攻击：图中的a线路，用户利用攻击者构造Range请求发送给CDN，CDN请求源主机完整的资源。用户只发送了很少的请求，而CDN却向服务器请求完整的资源。攻击对象为用户源主机，主要消耗源主机和CDN之间的带宽。
    OBR攻击：图中的b线路，应用场景是一个网站被多个CDN嵌套加速(这里的FCDN，BCDN为CDN服务器)。用户发送攻击者构造的Range请求，服务器收到的是很小的流量，但是CDN直接传输却有着很大的流量。攻击对象为CDN主机，主要消耗BCDN或FCNB的带宽
###  0x01: SBR攻击
如果主机CDN利用Dletetion策略和Expansion策略去处理Range请求，那么他就可能遭受SBR攻击。在SBR攻击中源主机收到的流量将远远大于用户的Range请求。由于以上两种处理Range请求的策略，用户请求部分目标资源，而CDN去请求服务器完整资源，导致攻击者构造的Range请求被CDN放大，攻击者能够通过请求CDN主机而对源主机发动Dos攻击。具体参考作者的图解。
从图中看，攻击者在请求头中加入`Range:
bytes=0-0`(表示请求目标资源第一个字节的数据)，CDN假如采取Deletetion策略或Expansion策略，CDN将会向源主机请求完整的目标资源。源主机返回完整目标资源给CDN，CDN对资源进行缓存，同时CDN返回状态码为206的部分主机资源。可以看到如果目标资源越大，则源主机消耗的流量越多。如果利用前面提到的绕过CDN的缓存，多线程的RANGE请求，理论上可以占满服务器的带宽。
###  0x02:OBR攻击
如果在多CDN加速场景下，如果FCDN采用Laziness策略同时BCDN在处理多段范围重叠Range请求时，没有对范围重叠字段进行检查，同时会对多段范围重叠Range请求，做出相应。那么该场景下CDN将会被OBR攻击方式攻击。具体的攻击方式如下。
在我们假设的两种策略都被实现下，攻击者发送多段范围重叠Range请求，例如`Range:
bytes=0-,0-,0-...`(0-的含义是N)。FCND由于是Laziness策略直接将源请求转发给BCDN。BCDN对目标资源进行完整的请求。源服务器将完整的目标资源发送给BCDN，同时BCDN将响应FCDN的多段范围重叠请求，会返回n段完整的数据资源。那么在BCDN和FCDN之间将会有大量的流量产生。而且多段范围重叠Range请求，能够一次返回多个资源，能够更快的占满带宽。
## 0x04：现实世界的CDN安全测试
###  0x01:第一次试验