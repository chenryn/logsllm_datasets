与Autotools（Autoconf/Automake）和一般的UNIX上C语言开发环境很
容易地整合在一起。（参见例20-3）
例20-3：对ClamAV中一个模式匹配器的测试范例
START_TEST(test_bm_scanbuff)
struct cli_matcher *root;
const char *virname=NULL;
int ret;
root=(struct cli_matcher*)cli_calloc(1,sizeof(struct cli_matcher));
fail_unless(root!=NULL,"root==NULL");
#ifdef USE_MPOOL
root->mempool=mpool_createO;
#endif
ret=cli_bm_init(root);
fail_unless(ret==CL_SUCCESS,"cli_bm_init()failed");
ret=cli_parse_add(root,"Sig1","deadbabe",0,0,NULL,O,NULL,0);
fail_unless(ret==CL_SUCCESS,"cli_parse_add(Sig1)failed");
ret=cli_parse_add(root,"Sig2","deadbeef",0,0,NULL,0,NULL,0);
fail_unless(ret==CL_SUCCESS,"cli_parse_add(Sig2)failed");
ret=cli_parse_add(root,"Sig3","babedead",0,0,NULL,0,NULL,0);
fail_unless(ret==CL_SUCCESS,"cli_parse_add(Sig3)failed");
ret=cli_bm_scanbuff("blah'xdexadxbexef",12,& virname,root,0,0,-1);
fail_unless(ret==CL_VIRUS,"cli_bm_scanbuff()failed");
2113
---
## Page 2115
fail_unless(!strncmp(virname,"Sig2",4),Incorrect signature matched in
cli_bm_scanbuffOn);
cli_bm_free(root);
#ifdef USE_MPOOL
mpool_destroy(root->mempool);
#endif
free(root);
END_TEST
测试脚本
测试脚本是一系列逐步运行的指令集合，它再现各种不同的条件来
检查程序各项功能是否正常。我们使用一些脚本程序来模仿对应用
程序的日常使用，检查在给定一系列配置环境和输入数据的情况下
是否能输出正确的结果。这是一种基于软件说明书的一种黑盒测试
方法，不关心程序的内部细节。幸好ClamAV包中的所有应用都是基
于命令行的，创建这种在命令行自动复现的测试样例要相对简单。
与单元测试类似，测试脚本的优点是它一旦创建就可以自动运行，
这使得测试过程更为轻松，速度也更快。然而，这些测试脚本是必
须要经过认真设计的，并使其尽量覆盖广泛，否则它的功效就会非
常有限。
模糊测试
模糊就是制造混乱一—非常有用的一种方式，一些艺术性的混乱常
常有助于让一些错误显现出来。模糊方法的一个主要规则就是没有
规则！这使得这一理念简单而漂亮。测试一个程序最好的方法之一
就是以不同于标准的方式进行检查测试，这能帮助我们发现在常规
使用时不会出现的各种缺点。
2114
---
## Page 2116
病毒扫描器需要处理上百种文件格式，而且经常是很复杂的文件格
式。这里我们以.zip或.rar等压缩文件为例。为了解压和扫描这些文
件中的内容，扫描器首先要分析一些特殊的文件标题。这些文件标
题中存储了被压缩文件的列表以及所有这些文件的特性（如名称、
原始大小、在压缩流中的文件偏移量、校验和等）。如果这些文件
标题中包含一些伪造的数据或者进行处理的代码没有得到正确的校
验结果，如缓冲区大小的计算错误和之后的溢出，那么试图采取某
些动作的代码就会异常退出。虽然通过对输入数据的适当预处理这
些问题可以避免，但在现实实践之中程序员在初始的并发时不能处
理所有的用例，尽管他们非常努力地这样做。这些情况就是模糊测
试的用武之地！
我们使用的是文件模糊器，它根据原始文件生成指定数量的对应文
件副本。这些副本相对原始文件是经过了一些随机修改的，与原文
件有所不同。文件模糊器的质量对于测试过程非常重要。最好的文
件模糊器是那些专门为特定任务服务，能够处理目标程序所使用的
文件格式和协议的模糊器程序。当模糊器对输入格式理解之后，它
就对文件进行修改。它通过对改变原始数据中最重要部分来产生高
质量的修改。然而，实现一个专用的模糊器是非常耗时的。并且由
于这种模糊器只能处理单一的文件格式，它们的应用前景也是非常
有限的。
在很多情况下，使用一个通用的模糊测试器是较为理想的。一个好
的解决方案是使用Fusil，它实际上是一个完整的模糊器框架，可以
在http://freshmeat.net/projects/fusil下载得到。它是用Python语言编写
的，并与一些所谓的“模糊项目”集成在一起，这些项目包括
ClamAV、Firefox和MPlayer等一些非常流行的应用软件。创建其他的
模糊测试器或者根据你自已的需要调整Fusil都是相对简单的。该框
架通过监视退出代码、日志和标准输出信息、CPU使用、数据处理
的时间等多种方法来检测程序的崩溃和数据死锁。而且，Fusil还通
过监视负载情况和内存使用情况来努力保持操作系统的稳定，并且
它还确保会话结束时可以被测试程序所在进程终止。开始测试时，
Fusil创建原始文件的变异文件，并在此之上建立独立的会话对程序
进行测试。对于每一个这样的会话，测试器都计算一个分值来预测
探测到的错误。
测试单个文件处理程序需要创建多少个模糊后的文件呢？答案是多
多益善。由于模糊测试是一种暴力测试方法，因此测试前很难说需
要多长时间能够给出我们感兴趣的结果，或者判断出它是否能测试
2115
---
## Page 2117
出什么结果。模糊测试软件也许能在五分钟内发现出问题，但是这
些问题却不一定是最重要的缺陷。从另一方面说，如果模糊测试经
过了几个小时也一无所获，这也并不能意味着你可以停止测试，认
为代码是安全的。耐心是成功的关键。不过，如果被测试的程序能
够处理几百万个模糊处理过的文件而没有任何问题，这就说明编程
人员出色地完成了他的工作。
收集有问题的文件
我们对所有导致扫描器崩溃的文件都进行了收集。这些文件来自我
们的用户或者我们自己的发现（例如前边提到了模糊处理后的文
件），我们会用它们做进一步的测试。经验告诉我们，一些问题在
各种不同的情况下可能会重复产生。例如，我们会对一些复杂的代
码进行清理，或者为了提高性能将一些粗糙的程序进行重写，那么
由于设计或实现上的错误，一些重要的安全性检查就被忽略了。通
过保留有问题的文件，并以这些文件为基准对我们的软件进行测
试，就能确保我们不会再引入以前的缺陷。这样的文件常常是做进
一步模糊测试的宝贵资源。
环境的测试
Autoconf是一款广泛流行的测试工具，它能够为源代码包的自动配置
生成专门的配置脚本。像其他开源项目一样。ClamAV也使用了这一
工具。通过Autoconf创建的配置脚本可以进行大量的测试，用以检查
软件的功能特性在目标系统中的状态，这使得可移植程序的开发变
得更为简单。除了检查各种与平台相关的功能特性的可用性之外，
我们还用配置脚本来测试系统库甚至是编译器可能存在的缺陷，它
们的缺陷可能会导致ClamAV易于受到安全性威胁。例如，在2007年
我们发现，受到缺陷PR27603影响的GCC的一系列版本（4.0.x版、
4.1.0版以及4.1.1的某些版本）不能正确编译我们的边界检查程序，
导致从完全安全的源代码生成了安全性脆弱的二进制程序。我们因
此增加了一个配置检查来检测这一特别的编译器缺陷，而且我们还
为libclamav中重要的边界检查程序的有效代码生成增加了一个更为
一般性的测试。不久之后，得益于我们的配置文件，SunStudio中的
另一个编译器被发现也有同样的问题，在代码优化阶段会生成被破
坏的二进制程序。
Buildbot
2116
---
## Page 2118
Buildbot可以对代码树自动地进行重新编译和测试，这使得对新的代
码修改进行验证变得更为简单。这一工具与CVS或SVN等版本控制
工具整合在一起，当开发人员提交新的代码时就会触发。它对代码
进行通常的编译过程和单元测试。如果有错误发生，开发人员就会
立即得到通知和一个完整的失败报告。Buildbot采用的是客户端-服
务器端的软件架构。Buildbot的核心是BuildMaster，它管理着一个或
多个BuildSlave。BuildSlave完成指令的执行，并将结果送回给
BuildMaster。这一架构使得增加更多的BuildSlave更加容易，并简化
了测试的操作（我们在不同的UNIX系统和架构上运行该工具）。将
此工具搭建好之后，Buildbot就能提供完全自动化的测试系统，并有
效地帮助代码远离那些明显的错误。这真是太美了！
兼容性测试
ClamAV中的兼容性测试是多层次的，对软件部分和病毒登记库部分
都要覆盖到。由于ClamAV一个开源项目，所以它需要能够在大量不
同的系统平台和架构上正确地编译和运行。我们有时会进行手动的
兼容性测试，并使用Buildbot在每次更新时自动测试，通过这些手段
对当前的代码在一些主要平台上进行检查。除此之外，我们还开发
了一个半自动的编译farm系统，它可以日常性地或者根据需要来执
行许多不同系统（包括Linux、Solaris、MacOSX、FreeBSD以及其
他系统）之上的测试，并为我们展示详细的编译和单元测试结果，
以及测试的脚本（见图20-1）。
2117
---
## Page 2119
备注
测试用例：编辑摘要一输入第二个摘要
wait for element_present oksteditsur
图20-1ClamAV的在http://farm.0xacab.net编译farm结果
防病毒技术需要不断地改进，这就是为什么每一版ClamAV的发布都
有比较短的生命周期，以及为什么我们会对ClamAV定期地发布具有
改进检测机制的新版本。在很多情况下，我们的用户不能立即跟进
这些更新，因为他们要等操作系统发行商对更新做好准备，或者需
要政策管理者批准软件的更新。我们尽了很大努力来确保病毒登记
库的向后兼容性。通过在当前和以往ClamAV引擎上对每一个病毒数
据库的测试，我们可以保证更新不会破坏旧版本的安装程序。
性能测试
防病毒软件需要处理几十万个病毒特征和几百种文件格式，而且所
有任务的执行速度要足够快，以保证不会令计算机系统难以支撑。
有时当扫描器花费大量时间处理某种特殊数据的时候，性能问题甚
至会导致拒绝服务攻击（DoS）。攻击者会向软件系统发送大量的
数据使其不能及时对数据进行处理，从而利用这种性能问题使某些
2118
---
## Page 2120
重要的服务瘫痪，比如说邮件投递服务。这就是为什么性能测试和
消除各种瓶颈是ClamAV开发人员需要面对的另一个重要问题。
在防病毒软件中，有很多地方都有可能出现这样的性能瓶颈。这些
瓶颈不仅会出现在特殊文件的处理器中，而且还可能出现在模式四
配和其他专门的检测引擎中。有一些称为profiler（分析器）的特殊
工具可用来对代码的执行性能进行分析，以对存在的瓶颈定位。
profiler对程序生成一个执行配置文件，记录每个被调用函数的统计
信息，说明了每个函数的被调用次数以及每个函数内所花费的时
间。大多数profiler能生成详细的调用图来说明函数是如何被调用
的，以及在每个特定的函数体所花费的时间。通过这些信息，就使
我们能够更好地找到可能存在瓶颈的位置。然而，即使有了
profiler，想要确认是哪一段代码可能导致运行缓慢仍然是个很艰难