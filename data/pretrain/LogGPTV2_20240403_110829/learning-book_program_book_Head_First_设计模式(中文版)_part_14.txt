whip
现在，Beverase类中的cost（）不再是一个抽象方法
getDescription()
我们提供了cost(）的实现，让它计算要加入各种饮
cost0<
科的调科价钱。子类仍将覆盖cost.但是金调用
hasMilk()
超类的cost(）.计算出基本饮科加上调科的价钱。
setMik0
hasSoy0
hasMocha()
setSoy)
setMocha()
hasWhip0
这些方法取得和设置调科的
setWhip()
布尔值。
其他有用的方法
82
第3章
---
## Page 119
装饰者模式
Beverage
现在加人子类，每个类代表菜单
description
milk
上的一种饮料：
soy
mocha
whip
超类cost(）将计算所有调科的价钱，而子
getDescription()
类覆盖过的cost（）全扩最超类的功能.把
cost
指定的饮科类型的价钱也加进来。
hasMilk()
setMik()
hasSoy0
setSoy()
hasMocha()
每个cost（）方法需要计算该饮科的价钱，
setMocha()
hasWhip()
然后通过调用超类的cost（）实现，加入调
setWhip0
科的价钱。
其他有用的方法
HouseBlend
DarkRoast
Decaf
Espresso
cost()
cost()
cost)
cost)
Sharpenyourpencil
L
请为下面类的cost(方法书写代码（用伪Java代码即可）。
public class Beverage{
public class DarkRoast extends Beverage{
public double cost(){
publicDarkRoast(）
description=“Most Excellent DarkRoast”:
publicdoublecost()
你现在的位置
83
---
## Page 120
改变的影响
看吧！一共只需要五
个类，这正是我们要的做
法。
我不确定耶！通过思考设计将
采可能需要的变化，我可以忌出
来这种方法有一些潜在的问题。
Sharpenyour pencil
当哪些需求或因素改变时会影响这个设计？
调科价钱的改变会使我们更改现有代码。
一显出现新的调料。我们就需要加上新的方法，并改变超类中的cost(）方法。
以后可能会开发出新伙料。对这些饮科而言（例如：冰茶），某些调科可能并不适合，但是在这
们在第1章就得到了
个设计方式中，Tea（茶）子类仍将继承那些不适合的方法，例如：hasWhip(）（加奶港）
这个数训
常
万一顾客想要双倍摩卡如明，怎么办：
轮到你了：
PDG
84
第3章
---
## Page 121
装饰者模式
大师与门徒
大师：我说蚱呀！距离我们上次见面已经有些时日，你对于继
承的冥想，可有精进？
门徒：是的，大师。尽管继承威力强大，但是我体会到它并不总是能够实现最有
弹性和最好维护的设计。
大师：啊！是的，看来你已经有所长进。那么，告诉我，我的门徒，不通过继承
又能如何达到复用呢？
门徒：大师、我已经了解到利用组合（composition）和委托（delegation）可以在
运行时具有继承行为的效果。
大师：好、好，继续.….
门徒：利用继承设计子类的行为，是在编译时静态决定的，而且所有的子类都会
继承到相同的行为。然而，如果能够利用组合的做法扩展对象的行为、就可以在
运行时动态地进行扩展。
大师：很好，蚌猛，你已经开始看到组合的威力了。
门徒：是的，我可以利用此技巧把多个新职责，甚至是设计超类时还没有想到的
职责加在对象上。而且，可以不用修改原来的代码。
大师：利用组合维护代码，你认为效果如何？
门徒：这正是我要说的。通过动态地组合对象，可以写新的代码添加新功能，而
无须修改现有代码。既然没有改变现有代码，那么引进bug或产生意外副作用的
机会将大幅度减少。
大师：非常好。蚱，今天的谈话就到这里。希望你能在这个主题上更深人
牢记，代码应该如同晚霞中的莲花一样地关闭（免于改变），如同晨曦中的莲花
一样地开放（能够扩展）。
你现在的位置
85
---
## Page 122
开放-关闭原则
开放-关闭原则
此刻，蚱面临最重要的设计原则之一：
设计原则
类应该对扩展开放，对修改关闭。
in
We're
Come
OPEN
CLOSED
请进，现在“开
BUSINESS HOURS:
放”中。欢迎用任何
你想要的行为来扩展我们的类。如果你的需要
或需求有所改变（我们知道这一定会发生的），
那就来吧！动手扩展吧！
抱歉，现在是“关
闭”状态。没错。我
们花了许多时间得到了正确的代码，还解决了所
有的bug，所以不能让你修改现有代码。我们必
须关闭代码以防止被修改。如果你不喜欢，可以
找经理谈。
我们的目标是允许类容易扩展，在不修改现有代码的情况下，就可搭配
新的行为。如能实现这样的目标，有什么好处呢？这样的设计具有弹性
可以应对改变，可以接受新的功能来应对改变的需求。
PDG
86
第3章
---
## Page 123
装饰者模式
起来很矛盾。设计如何兼顾两者？
循开放-关闭原则？
下，的确感到矛盾，毕竞、越难修改的事
计同时具备开放性和关闭性，又不修改现
物，就越难以扩展，不是吗？
有的代码，需要花费许多时间和努力。一
般来说，我们实在没有闲工夫把设计的每
但是，有一些聪明的OO技巧，充许系统
个部分都这么设计（而且，就算做得到，
在不修改代码的情况下，进行功能扩展。
也可能只是一种浪费）。遵循开放-关闭原
想想观察者模式（在第2章）通过加
则，通常会引入新的抽象层次，增加代码
入新的观察者，我们可以在任何时候扩展
的复杂度。你需要把注意力集中在设计中
Subject（主题），而且不需向主题中添加
最有可能改变的地方，然后应用开放-关闭
代码。以后，你还会陆续看到更多的扩展
原则。
行为的其他00设计技巧。
是更重要呢？
-able），但是该如何将某件东西设计成可
以扩展，又禁止修改？
答：
和对你工作领域的了解。多看一些其他的
许多模式是长期经验的实证，
例子可以帮你学习如何辨别设计中的变化
可通过提供扩展的方法来保护代码免于被
区。
修改。在本章，将看到使用装饰者模式的
虽然似乎有点矛盾，但是的确有一些
一个好例子，完全遵循开放-关闭原则。
技术可以充许在不直接修改代码的情
况下对其进行扩展。
在选择需要被扩展的代码部分时要小
心。每个地方都采用开放一关闭原则，
是一种浪费，也没必要，还会导致代
码变得复杂且难以理解。
你现在的位置，87
---
## Page 124
认识装饰者模式
够了！你们这些“面向对象
设计俱乐部”的家伙。快来解决真
正的问题吧！还记得我们吗？星巴
就咖啡？你认为这些设计原则有实
认识装饰者模式
质的帮助吗？
好了，我们已经了解利用继承无法完全解决问题，在星巴兹遇到的问
题有：类数量爆炸、设计死板，以及基类加入的新功能并不适用于所
有的子类。
所以，在这里要采用不一样的做法：我们要以饮料为主体，然后在运
行时以调料来“装饰”（decorate）饮料。比方说，如果顾客想要摩卡
和奶泡深焙咖啡，那么，要做的是：
①拿一个深焙咖啡（DarkRoast）对象
②以摩卡（Mocha）对象装饰它
③以奶泡（Whip）对象装饰它
④调用cost()方法，并依赖委托（delegate）将调料的价
钱加上去
用呢？给一个暗示：把装饰者对象当成“包装者”。让我们看看这是
如何工作的....
PDG
88
第3章
---
## Page 125
装饰者模式
以装饰者构造饮料订单
①
以DarkRoast对象开始
别忘了，DazkRoast继承自
Bevetase，且有一个用来计算饮
costO
科价钱的cost(）方法。
2
顾客想要摩卡（Mocha），所以建立一个
Mocha对象，并用它将DarkRoast对象包
(wrap）起来。
Mocha对象是一个装饰老，它的类型“反
映”了它所装锦的对象（本例中，就是
Beverase）。所调的“反映”，指的就是两
老类型一致。
costO
costO
DarkRoast
所以Mocha也有一个cost(）方法。逐过多态
也可以把Mocha所包裹的任何Bevenage它成
Mocha
是Bevease（因为Mocha是Beverase的子类
型）。
3
顾客也想要奶泡（Whip），所以需要建立一个Whip装饰者，并用它将Mocha对象包起来。
别忘了，DarkRoast继承自Beverage，且有一个cost(）方法，用来计算饮料价钱。
costO
costO
Whip是一个装筛者，所以它也
DarkRoos
反映了DarkRoast类型，并包括一
Mocha
个cost(方法。
所，被Mocha和oWhip包起来的DatkRoast对象仍然
PDG
是一个Beverase，仍然可以具有DakRoast的一切行为
包括调用它的cost（）方法。
你现在的位置
89
---
## Page 126
装饰者的特性
4现在，该是为顾客算钱的时候了。通过调用最外圈装饰者（Whip）的cost()就可
以办得到。Whip的cost(）会先委托它装饰的对象（也就是Mocha）计算出价钱，
然后再加上奶泡的价钱。
再过几页，你就会
知道这是如何办
②Whip调用Mocha的costO。
到的。
首先，调用最外圈装饰者
Whip的costO。
cost()。
cost(.20
.99
Mocha
4
DrakRoast返回它的价
Whip
钱$0.99。
Whip在Mocha的返回结果上加
上自己的价钱$0.10，然后返回
③Mocha在DarkRoast的结果上，
最后结果$1.29。
加上自己的价钱S0.20，返回新
的价钱$1.19。
好了，这是目前所知道的一切.
·装饰者和被装饰对象有相同的超类型。
■你可以用一个或多个装饰者包装一个对象。
■既然装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象（被包装的）的场合，
可以用装饰过的对象代替它。
关键点
装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为，以达到特定的目的。
■对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰
对象。
现在，就来看看装饰者模式的定义，并写一些代码，了解它
到底是怎么工作的。
90
第3章
---
## Page 127
装饰者模式
定义装饰者模式
让我们先来看看装饰者模式的说明：
装饰者模式动态地将责任附加到对象上。
若要扩展功能，装饰者提供了比继承更有弹性
的替代方案。
实际“应用”它。我们来看看类图，会有些帮助（下一页，我们会将此
结构套用在饮料问题上）。
每个组件都可以单独使用，或者被
装饰者包起来使用。
Comp
component
mehodAD
mehodB(
其他方法
每个装饰者都“有一个”
ConcreteComponent是我们将
（包装一个）组件，也就是
要动态地加上新行为的对
说，装饰者有一个实例变
象，它扩展自Component。
量以保存某个Component的
Decorator
引用。
methodAO
methodA)
methodB0
methodB(
其他方法
W其他方法
这是装饰老共同实现的摄
口（也可以是抽象类）。
ConcreteDecoratorA
ConcreteDecoratorB
Component wrappedObj
Raopoddeam jauoduo
methodA0
Object newState
ConcteteDecorator有一个实例变量
methodB0
methodAD
装饰者可以扩展
可以记录所装饰的事物
(eagmau
其他方法
methodB()
Component的状态
（装饰老色着的Component）。
其他方法
C
PD
装饰者可以加上新的方法。新行为是通过在回
行为前面或后面做一些计算来添加的。
你现在的位置，
91
---