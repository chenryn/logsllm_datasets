c n Q o M S k 8 L 3 N j c m l w d D 4 8 L 3 N 2 Z z 4 N C g %3 D %3 D " / >
Listing 2: Example for uncommon SVG-based
JavaScript execution via  tag
These and other ways of executing JavaScript from within
an SVG ﬁle were used to bypass the ﬁlter used by the Me-
diaWiki software, which is the most commonly used open
source wiki software and, among many others, the platform
used by Wikipedia. We established contact with the Media-
Wiki team and work together with them on mitigation and
defense strategies against such attacks.
We also tried to load SVG images via a Canvas element
in an HTML website and steal information by using the
canvas.toDataURL() feature. This method is capable of
freezing the optical state of a canvas element and trans-
forming it into a dataURI for easy saving and later usage.
This attack technique to steal data cross domains has been
published by Lawrence in 2009 [30], but speciﬁcally aimed
to steal pixel data cross domain for attacking CAPTCHA
mechanisms and similar security instrumentations involv-
ing images. We attempted to use this attack technique in
a novel context and steal whole website screenshots from
SVG images being applied with a  tag and
cross domain Iframes. Surprisingly, this did not work at all.
All tested web browsers reacted with the expected behav-
ior and threw security errors on attempting to execute the
243canvas.toDataURL() method when accessing the SVG with
cross domain content.
3.4 Facilitating Filter Bypasses
One feature distinguishing the rendering behavior of HTML
from XHTML and XML based websites and documents in
browsers is the handling of entities in plain text tags. Plain
text tags are HTML elements considered to contain plaintext
information (such as  and  tags, as well as
,  and  tags). While in
HTML documents entities such as &#x61; will be treated as
such, XHTML and XML documents will have the entity be
treated like its canonical representation (e.g., the character
a).
In practice, this implies that within a XHTML/XML
document the code  will
execute the alert method, while an HTML document with
the same content causes the script engine to throw an error.
Of course, this behavior applies for SVG ﬁles as well, since
they are regular XML documents. Interesting in terms of
web security, though, is the fact that the same applies for
most web browsers to inline SVG. This implies that this
behavior can be transported to regular HTML documents
as soon as they contain an opening  tag somewhere
in the markup tree. While the aforementioned 
tag example will not execute in an HTML document, the
variation of &#61;lert(1) will do.
Note that the browser’s parsers are also very tolerant
about well-formedness of inline SVG, and neither require at-
tribute delimiters nor balanced tags, nor even closing tags.
The  element at the end of the example shown above in-
dicates to the parser that the inline SVG just ended and an
HTML section has started. Thus, the browser automatically
closes both the  and  tags, and thereby trig-
gers the alert method to execute. This technique, combined
with an injection, has been tested against the most common
XSS ﬁlters and we managed to bypass most of them.
3.5 Active Image Injection
Several ways of abusing SVG ﬁles to execute JavaScript
in situations where no script execution should happen at
all have been ﬁxed after we reported them back to browser
vendors. Some vendors even completely restricted access to
the DOM from an SVG context. This makes it very hard
to execute same-domain JavaScript from within SVG ﬁles
delivered via CSS, image tags, CSS fonts, or other ways in
which browsers deliver images. Even if a web browser can
be tricked into executing JavaScript via SVG deployment
methods unintended for this, the script will run in the con-
text of about:blank and cannot get access to the deploying
website’s DOM. This eﬀectively disables XSS attacks, since
they require their payload to execute on the targeted domain
and not on a bogus fully qualiﬁed domain name (FQDN)
such as about:blank.
A yet unsolved problem for several state-of-the-art web
browsers is plugin content. The Opera browser, for instance,
allows to use SVG ﬁles in order to deploy plugin content such
as Flash, Java, and PDF ﬁles, depending on which plugins
have been installed and registered on the user’s system. This
does not only hold for SVG ﬁles embedded via tags such as
, , or , but also for  tags and
CSS. This means that an attacker can execute arbitrary plu-
gin code on a victim’s machine without any user interaction
by just having the victim browse a website containing an
image tag. The image can be delivered from any arbitrary
domain, thus most high-traﬃc websites and web applica-
tions allowing user generated image content are aﬀected by
this problem.
The Opera security team has been informed about this
issue in summer 2010, but so far this vendor did not address
the issue with a suﬃcient ﬁx. This leaves applications such
as Facebook, Google Mail, Yahoo! Mail, and many other
websites prone to this kind of Active Image Injection attack
– in case their users visit the page with Opera version 9 to
11. An example showcase has been set up to demonstrate
the severity of the vulnerability, also trying to enforce an
urgent ﬁx from the Opera team [22].
Early versions of the Firefox 4 beta browser were prone to
AII attacks as well, but these bugs have been spotted and
ﬁxed with Firefox 4 Beta 9, and did not surface in the ﬁ-
nal release version. Nevertheless, all browser vendors should
monitor the security boundaries of SVG deployment closely,
since small changes can cause vulnerabilities aﬀecting a ma-
jority of web applications at once.
3.6 Browser Vulnerabilities
So far we covered attacks utilizing malicious SVG ﬁles to
be instrumented in attacks against websites. We demon-
strated how SVG ﬁles can be used to facilitate XSS attacks
that bypass existing and well-conﬁgured ﬁlter mechanisms
and security best practices, such as encoding user-generated
data into HTML entities. SVG ﬁles can have other pur-
poses for attackers, though, and be used to leverage attacks
against the browser itself, or even against the underlying
operating system. During our tests, it became evident that
especially complex SVGs or SVG chameleons containing ex-
ecutable plugin code have the potential of easily crashing
web browsers. We observed and reported several cases of
memory corruption occurring in state-of-the-art browsers,
which were caused by faulty or incomplete implementation
of SVG features, or interference eﬀects between the browser
components delivering the SVG data and other components
delivering embedded plugin code and Iframes.
One signiﬁcant example showing the dangers of SVG ﬁles
when used as attack tools against browsers is a speciﬁc bug
in Opera version 11.50 24581. This version marked a turn-
ing point in the Opera browser history, since it was the ﬁrst
oﬃcially released version supporting inline SVG so far. We
investigated an attack scenario where an attacker creates a
website providing an SVG image as favicon. This SVG im-
age deployed malicious content in form of a Flash ﬁle and
a Java applet, as well as, an embedded PDF ﬁle. When
opening the malicious website, the Opera browser attempted
to load the favicon to decorate the loaded page’s tab and
address bar, as shown in Figure 2. Although this context
should never execute plugin content or JavaScript at all, the
browser started to play the Flash video we used for testing,
and delivered the applet and PDF ﬁle – within the address
bar as can be seen in Figure 2. The code was executed in
the browser context, thus an exploit like this could easily
haven been escalated from a proof of concept to a full at-
tack, demonstrating how arbitrary vulnerabilities in browser
plugins can be triggered via image ﬁles.
Furthermore, SVG-based attack vectors should be consid-
ered relevant for another category of software as well: mail
clients such as Thunderbird and Opera Mail make use of
the same (or only slightly modiﬁed) rendering and layout
244cluded this is insuﬃcient for eﬀectively ﬁltering malicious
SVG contents, such as those exempliﬁed above.
For once, there is no feasible way to restrict the xlink:href
attribute of URI data type to point to same-domain loca-
tions only, which would have been essential for resisting cer-
tain XSS attacks. The only viable way to perform such a
veriﬁcation while using XML Schema or RelaxNG capabil-
ities comes down to setting the attribute’s data type to a
restricted string value that must conform to a given reg-
ular expression pattern. Expressing a value restriction as
stated above would thus require a regular expression to be
crafted for each type of restriction necessary for fending oﬀ
the attacks. Although this might be (somehow and some-
what) feasible for same-domain URIs, it is easy to imagine
this approach to fail for complete CSS declarations, Base64-
encoded contents, and the like.
& lt ; img src = null onerror = alert (1) & gt ; 
Listing 3: XML Entity Resolution leading to
element injection
Another example that demonstrates the impossibility of
XML Schema to remove suspicious content from a given
ﬁle is shown in Listing 3. When processing this code frag-
ment, Firefox 4 resolves the &lt; entity automatically, re-
sulting in the alert being triggered. The crux is that the
XML entity introduces an additional HTML element “on
the ﬂy” during parsing. An XML Schema validator would
seen a  element with odd contents, but nothing to
be alerted about (note that the missing closing tags and
attribute value quotations are added automatically by the
parser engine.). However, the HTML renderer resolves the
entities, hence introducing the additional  tag, and
triggering the onerror event due to the missing null ﬁle.
To summarize, we established that common XML valida-
tor techniques, like XML Schema or RelaxNG validation are
not capable of fending the speciﬁc SVG attack vectors de-
scribed above. Especially in the case of inline SVG, where
HTML, CSS, JavaScript, and SVG elements are mixed ar-
bitrarily, the approach of XML Schema validation must be
revoked as completely ineﬀective in practice.
4.2 SVG Puriﬁcation
Due to the limitations discussed above, we require another
way to prevent the attacks introduced in Section 3. The ba-
sic idea of our methodology is to purify SVG images, i.e., re-
move all suspicious content from a given ﬁle and preserve as
much content as possible. As a result of this transformative
process, the visual impact is minimized and the suspicious
content is removed. Next, we discuss the overall design and
present some implementation details.
The open source market provides a lot of tools claiming to
possess the skills to ﬁlter user generated input for web appli-
cations in order to eliminate active markup and script code.
Their main purpose is usually XSS mitigation and markup
sanitation, as well as restructuring for validity and well-
formedness’ sake. For PHP-based web applications, several
ﬁltering solutions are available and those most commonly
used include:
Figure 2: An SVG containing plugin content deliv-
ered via favicon
engines as their respective browser counterparts. We tested
the latest versions of Opera Mail and Thunderbird 3.3, and
discovered that both products allow usage of inline SVG
inside HTML mails. One attack vector we crafted caused
Thunderbird 3.3 alpha 3 to automatically store an SVG ﬁle
in the temporary folder, open it, and execute JavaScript in
the ﬁle:// context. The only required user interaction is a
click on an arbitrary part of the displayed mail body. At-
tacks like this can be used to place malicious software or
to steal sensitive information from the /tmp folder or other
directories, depending on the location of the SVG ﬁle and
the post-exploitation techniques used by the attacker.
4. MITIGATION TECHNIQUES
In the following section, we cover mitigation techniques to
fend the attacks presented in the previous part. We start
with a discussion of the common XML ﬁltering and sanitiza-
tion techniques, point out which problems occur when SVG
is being used in modern web browsers, and list arguments as
to why the classic and formerly approved approaches cannot
be applied to SVGs used on the Internet. Based on these in-
sights, we introduce and discuss SVGPuriﬁer , a PHP-based,
server-side SVG ﬁlter software we have developed to mit-
igate the identiﬁed attacks. What is more, we outline a
set of recommendations for browser vendors addressing non-
standard behavior that causes security problems with ma-
licious SVG images and inline SVG parsing. Some of the
listed issues have already been adopted by browser vendors
during the preparatory phase of this paper completion.
4.1 XML Sanitization
The most common approach for verifying an XML doc-
ument’s validity is the use of Document Type Deﬁnitions
(DTDs), XML Schema, or RelaxNG descriptions. All of
these languages authorize a precise speciﬁcation of which
XML elements, attributes, and other tokens may be used
within a speciﬁc XML document. For instance, the SVG
Tiny speciﬁcation provides a RelaxNG description of all
XML elements and attributes that may be used in “Tiny”-
compliant SVG documents. We have investigated these de-
scriptions for practical usage in terms of removing malicious
contents from SVG ﬁles. Unfortunately, we determined that
their capabilities of restricting SVG contents are more fo-
cused on the XML documents’ structure rather than re-
stricting the content values of the SVG elements and at-
tributes. Though both XML Schema and RelaxNG provi-
sion the means to restrict an SVG attribute value’s data
type to integer, string, URI, or other data types, we con-
245• kses [21], that has been incorporated into a highly cus-
tomized version by the popular WordPress software.
Listing 4:
set/animate elements
Initiating JavaScript execution via
• htmlLawed [37], which claims to be the fastest and
most compact, yet complete solution.
• HTMLPuriﬁer [43], which not only sanitizes data from
possibly malicious code fragments, but also generates
valid and well-formed XHTML output.
We analyzed all three XSS ﬁlters and have managed to
bypass each of them, demonstrating that even the most so-
phisticated ﬁltering software can never be able to fully pro-
tect against malicious markup. Some of the bypasses worked
only for injections into SVG ﬁles, some even in a HTML/X-
HTML context.
Despite these drawbacks of the server-side ﬁltering ap-
proaches, we have decided to choose HTMLPuriﬁer as the
foundation for our SVG attack mitigation tool. One major
reason for this determination was the fact that HTMLPuri-