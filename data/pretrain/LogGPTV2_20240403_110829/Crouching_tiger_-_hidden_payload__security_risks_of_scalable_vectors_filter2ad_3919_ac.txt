### Listing 2: Example of Uncommon SVG-Based JavaScript Execution via `<script>` Tag

These and other methods of executing JavaScript from within an SVG file were used to bypass the filter employed by MediaWiki, the most commonly used open-source wiki software and the platform for Wikipedia, among others. We established contact with the MediaWiki team and collaborated on mitigation and defense strategies against such attacks.

We also attempted to load SVG images via a `Canvas` element in an HTML website and steal information using the `canvas.toDataURL()` feature. This method can capture the visual state of a canvas element and convert it into a data URI for easy saving and later use. This attack technique, which was published by Lawrence in 2009 [30], was originally aimed at stealing pixel data across domains for attacking CAPTCHA mechanisms and similar security features. We tried to adapt this technique to steal entire website screenshots from SVG images embedded with a `<script>` tag and cross-domain iframes. Surprisingly, this did not work. All tested web browsers exhibited the expected behavior and threw security errors when attempting to execute the `canvas.toDataURL()` method on SVGs with cross-domain content.

### 3.4 Facilitating Filter Bypasses

One key difference in the rendering behavior between HTML and XHTML/XML-based documents in web browsers is the handling of entities in plain text tags. Plain text tags, such as `<pre>`, `<textarea>`, and `<style>`, are treated differently in HTML and XHTML/XML. In HTML, entities like `&#x61;` are treated as literal characters, whereas in XHTML/XML, they are interpreted as their canonical representation (e.g., the character 'a').

In practice, this means that within an XHTML/XML document, the code `&lt;script&gt;alert(1)&lt;/script&gt;` will execute the `alert` method, while an HTML document with the same content will cause the script engine to throw an error. This behavior applies to SVG files as well, since they are XML documents. Notably, this behavior is also observed in inline SVG in most web browsers. Therefore, this behavior can be transported to regular HTML documents as soon as they contain an opening `<svg>` tag somewhere in the markup tree. While the aforementioned `<script>` tag example will not execute in an HTML document, the variation `&lt;scr&#61;lert(1)&gt;` will.

It is important to note that browser parsers are very tolerant of poorly formed inline SVG. They do not require attribute delimiters, balanced tags, or even closing tags. The `<div>` element at the end of the example above indicates to the parser that the inline SVG has ended and an HTML section has started. Thus, the browser automatically closes both the `<svg>` and `<script>` tags, triggering the `alert` method to execute. This technique, combined with an injection, has been tested against the most common XSS filters, and we managed to bypass most of them.

### 3.5 Active Image Injection

Several methods of abusing SVG files to execute JavaScript in situations where no script execution should occur have been fixed after we reported them to browser vendors. Some vendors have even restricted access to the DOM from an SVG context, making it very difficult to execute same-domain JavaScript from within SVG files delivered via CSS, image tags, CSS fonts, or other methods. Even if a web browser can be tricked into executing JavaScript via unintended SVG deployment methods, the script will run in the context of `about:blank` and cannot access the deploying website’s DOM, effectively disabling XSS attacks.

A yet unsolved problem for several modern web browsers is plugin content. For example, the Opera browser allows the use of SVG files to deploy plugin content such as Flash, Java, and PDF files, depending on the installed and registered plugins on the user's system. This applies not only to SVG files embedded via tags like `<object>`, `<embed>`, or `<iframe>`, but also to `<img>` tags and CSS. This means that an attacker can execute arbitrary plugin code on a victim’s machine without any user interaction, simply by having the victim browse a website containing an image tag. The image can be delivered from any domain, affecting high-traffic websites and web applications that allow user-generated image content.

The Opera security team was informed about this issue in summer 2010, but a sufficient fix has not been implemented. This leaves applications such as Facebook, Google Mail, Yahoo! Mail, and many other websites vulnerable to this type of Active Image Injection attack, especially if users visit the page with Opera versions 9 to 11. An example showcase has been set up to demonstrate the severity of the vulnerability and to encourage an urgent fix from the Opera team [22].

Early versions of the Firefox 4 beta browser were also susceptible to AII attacks, but these bugs were identified and fixed with Firefox 4 Beta 9 and did not appear in the final release version. Nevertheless, all browser vendors should closely monitor the security boundaries of SVG deployment, as small changes can lead to vulnerabilities affecting a majority of web applications.

### 3.6 Browser Vulnerabilities

So far, we have covered attacks using malicious SVG files to target websites. We demonstrated how SVG files can facilitate XSS attacks that bypass existing and well-configured filter mechanisms and security best practices, such as encoding user-generated data into HTML entities. However, SVG files can also be used to leverage attacks against the browser itself or even the underlying operating system. During our tests, it became evident that complex SVGs or SVG chameleons containing executable plugin code can easily crash web browsers. We observed and reported several cases of memory corruption in modern browsers, caused by faulty or incomplete implementation of SVG features or interference effects between the browser components delivering SVG data and other components delivering embedded plugin code and iframes.

A significant example of the dangers of SVG files as attack tools against browsers is a specific bug in Opera version 11.50 24581. This version marked a turning point in Opera browser history, as it was the first officially released version supporting inline SVG. We investigated an attack scenario where an attacker creates a website providing an SVG image as a favicon. This SVG image deployed malicious content in the form of a Flash file, a Java applet, and an embedded PDF file. When opening the malicious website, the Opera browser attempted to load the favicon to decorate the loaded page’s tab and address bar. Although this context should never execute plugin content or JavaScript, the browser played the Flash video, delivered the applet and PDF file, and executed the code in the browser context. This could easily escalate from a proof of concept to a full attack, demonstrating how arbitrary vulnerabilities in browser plugins can be triggered via image files.

Furthermore, SVG-based attack vectors are relevant for mail clients such as Thunderbird and Opera Mail, which use the same or slightly modified rendering and layout engines as their respective browser counterparts. We tested the latest versions of Opera Mail and Thunderbird 3.3 and discovered that both products allow the use of inline SVG inside HTML emails. One attack vector we crafted caused Thunderbird 3.3 alpha 3 to automatically store an SVG file in the temporary folder, open it, and execute JavaScript in the `file://` context. The only required user interaction is a click on any part of the displayed email body. Attacks like this can be used to place malicious software or steal sensitive information from the `/tmp` folder or other directories, depending on the location of the SVG file and the post-exploitation techniques used by the attacker.

### 4. Mitigation Techniques

In the following section, we discuss mitigation techniques to counter the attacks presented earlier. We start by examining common XML filtering and sanitization techniques, highlighting the problems that arise when SVG is used in modern web browsers, and explaining why classic approaches are insufficient for SVGs used on the Internet. Based on these insights, we introduce and discuss SVGPuriﬁer, a PHP-based, server-side SVG filter software we developed to mitigate the identified attacks. We also outline recommendations for browser vendors addressing non-standard behavior that causes security issues with malicious SVG images and inline SVG parsing. Some of the listed issues have already been addressed by browser vendors during the preparatory phase of this paper.

### 4.1 XML Sanitization

The most common approach for verifying an XML document’s validity is the use of Document Type Definitions (DTDs), XML Schema, or RelaxNG descriptions. These languages allow precise specification of which XML elements, attributes, and tokens may be used within a specific XML document. For instance, the SVG Tiny specification provides a RelaxNG description of all XML elements and attributes that may be used in "Tiny"-compliant SVG documents. We investigated these descriptions for practical usage in removing malicious content from SVG files. Unfortunately, we determined that their capabilities are more focused on the structure of XML documents rather than restricting the content values of SVG elements and attributes. While both XML Schema and RelaxNG provide means to restrict an SVG attribute value’s data type to integer, string, URI, or other types, they are insufficient for effectively filtering malicious SVG contents.

### 4.2 SVG Puriﬁcation

Due to the limitations discussed above, we require another method to prevent the attacks introduced in Section 3. The basic idea of our methodology is to purify SVG images, i.e., remove all suspicious content from a given file while preserving as much content as possible. This transformative process minimizes the visual impact and removes suspicious content. Next, we discuss the overall design and present some implementation details.

The open-source market offers various tools claiming to filter user-generated input for web applications to eliminate active markup and script code. Their primary purpose is usually XSS mitigation and markup sanitation, as well as restructuring for validity and well-formedness. For PHP-based web applications, several filtering solutions are available, and the most commonly used include:

- **kses** [21], which has been incorporated into a highly customized version by the popular WordPress software.
- **htmlLawed** [37], which claims to be the fastest and most compact, yet complete solution.
- **HTMLPuriﬁer** [43], which not only sanitizes data from possibly malicious code fragments but also generates valid and well-formed XHTML output.

We analyzed all three XSS filters and managed to bypass each of them, demonstrating that even the most sophisticated filtering software cannot fully protect against malicious markup. Some bypasses worked only for injections into SVG files, while others worked in an HTML/XHTML context.

Despite these drawbacks of server-side filtering approaches, we chose HTMLPuriﬁer as the foundation for our SVG attack mitigation tool. One major reason for this choice was the fact that HTMLPuriﬁer not only sanitizes data but also generates valid and well-formed XHTML output.