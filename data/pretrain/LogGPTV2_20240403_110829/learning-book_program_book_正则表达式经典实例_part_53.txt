包含或者不包含国家代码的VAT代码。如果想要把国家代码变成必需的，那么你可以
去掉正则表达式中的所有问号。如果你这样做，那么就要记住在提供给用户的错误消
息中说明你要求必须使用国家代码。
如果你只接受来自某些特定国家的订单，那么可以去掉一些不会出现在订购表单的国
家选择列表中的国家代码。当你删除一个选择分支的时候，一定记住同时删除分隔不
同选择分支的管道操作符。否则，你就可能会在正则表达式中出现。会添加一
个匹配空字符串的选择分支，这样就意味着你的订购表单会接受没有输人的VAT代码
作为合法的VAT代码。
这27个选择分支都被放到了一个分组中。这个分组被放到了一个脱字符和一个美元符
号之间，这样就把正则表达式定位到了目标字符串的开始和结束位置。因此整个输人
必须被确认为一个合法的VAT代码。
如果你要在更大的文本中搜索VAT代码，那么就需要把定位符替换成单词边界\b>。
变体
使用一个正则表达式来检查所有27个国家代码的好处是，你只需要在订购表单中
合法性验证和格式化
269
www.TopSage.com
---
## Page 286
添加一个正则表达式验证。你也可以使用27个分别的正则表达式来改进订购表单。
首先，检查客户在账单地址中所列出的国家。然后，根据国家来查找合适的正则表
达式：
奥地利
比利时
保加利亚
塞浦路斯
（(CY)？[0-9](8}L$>
捷克共和国
德国
爱沙尼亚
希腊
西班牙
芬兰
法国
英国
匈牙利
270
第4章
www.TopSage.com
---
## Page 287
爱尔兰
意大利
立陶宛
卢森堡
拉脱维亚
马耳他
荷兰
波兰
葡萄牙
罗马尼亚
瑞典
斯洛文尼亚
斯洛伐克
按照实例3.6在代码中可以实现用选定的正则表达式来验证VAT代码。这会告诉你该
代码对于客户声称他所在的国家是否合法。
使用单独的正则表达式的主要好处是你可以要求VAT代码必须以正确的国家代码开
头，而不用要求客户自己来输入国家代码。当正则表达式成功匹配所给的号码的时候，
接下来需要检查第一个捕获分组的内容。在实例3.9中的代码示例讲解了这该如何做。
合法性验证和格式化
271
www.TopSage.com
---
## Page 288
如果第一个捕获分组是空的，那么客户并没有在VAT代码的开头输人国家代码。这样
你可以在把验证过的代码添加到订单数据中之前，把国家代码添上。
希腊的VAT代码支持两个国家代码。EL传统上被用于希腊的VAT代码，但是GR是
ISO标准中的希腊国家代码。
参见
本节中的正则表达式只会检查代码看起来是不是-一个合法的VAT代码。这对于清除无心
的过错就足够了。显然我们无法使用正则表达式来检查VAT代码是不是分配给了下订单
的那个企业。欧盟提供了一个网页http://ec.europa.eu/taxation_customs/vies/vieshome.do，
你可以使用它来检查某个特定的VAT代码属于哪家企业。
关于在本节的正则表达式中使用的技巧，请参考实例2.3、实例2.5和实例2.8。
272
第4章
www.TopSage.com
---
## Page 289
第5章
单词、文本行和特殊字符
本章中的实例会讲解如何在各种不同上下文中查找和处理文本。其中一些实例会展示
如何完成一些高级搜索引擎中的任务，例如查找几个单词中的任意一个，或者查找位
置临近的单词。其他例子则会帮助你查找包含特定单词的整行内容，删除重复单词，
或者对正则表达式中的元字符进行转义。两
本章的中心议题是展示各种不同的正则表达式结构，以及在实际应用中会用到的技巧。
阅读本章的过程就好像是使用大量正则表达式语法特性的十次热身练习，它将会有助
你应用正则表达式来解决今后遇到的实际问题。在本章的许多例子中，虽然要查找的
内容都比较简单，但是我们在解答中提供的模板则可以通过定制来解决你遇到的具体
问题。
5.1查找一个特定单词
问题描述
你接到一个简单的任务，要查找单词“cat”出现的所有地方，并且不区分大小写。这
里的关键点是它必须以整个单词的形式出现。在结果中不能包括它作为更长单词的一
部分的情形，例如hellcat、application或Catwoman。
解决方案
使用单词边界记号就可以很容易地解决这个问题：
\bcat\b
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
实例3.7中会讲解如何使用这个正则表达式来找到所有的匹配。实例3.14中会讲解如
何使用其他文本来替换匹配。
273
www.TopSage.com
---
## Page 290
讨论
这个正则表达式两端使用了单词边界，以保证只有当cat以整个单词的形式出现时，才
会产生匹配。更精确地来说，单词边界要求在cat与其他文本之间必须由字符串的开始
或结束、空格、标点符号或者其他非单词字符分隔开。
正则表达式引擎会把学母、数学和下划线都当作是单词字符。关于单词边界的详细讨
论，请参考实例2.6。
如果使用这个正则表达式在JavaScript、PCRE和Ruby中处理国际化文本时，就可能
会遇到一些问题，这是因为这些正则表达式流派中，只有位于ASCII字符表中的字母
才会创建单词边界。换句话说，单词边界只会匹配到（个A-Za-z0-9]和
之间，或者和之间的位置。在Python
中，在没有设置UNICODE或U选项的时候，也是如此。这样就会使八\b>无法用于在
包含带读音符号的字母或使用非拉丁字母表的单词的文本中进行“全字匹配”的查找。
举例来说，在JavaScript、PCRE和Ruby中，《\buiber\b>会在dariber中找到一个匹配，
但是在daruiber中却无法找到匹配。在大多数情况下，这刚好与读者的期望相反。问
题的根源在于被当作一个非单词字符，因此在ru两个字符之间就找到了一个单词
边界。而在空格字符和之间却无法找到单词边界，这是因为它们被当作是非单词字
符的一个连续序列。
你可以通过不采用单词边界，而是使用顺序环视和逆序环视（两个加起来统称为环视）
解决这个问题。与单词边界一样，环视也会匹配一个宽度为0的位置。在PCRE（使用
UTF-8支持进行编译）和Ruby1.9中，你可以使用环视来模拟基于Unicode的单词边
界，例如可以使用(?）。如果要了解更多关于环视的
讲解，请参考实例2.16。如果你想要让环视也把数字和下划线当作单词字符（就像b）
样），那么可以把P{L的两次出现都替换成[p{L}p{N}]。
JavaScript和Ruby1.8既不支持逆序环视，也不支持Unicode属性。对于不支持逆序
环视的问题，你可以通过下面的方式来解决：先匹配每个匹配之前的非单词字符，然
字符串中如何使用匹配到的子串，请参考实例3.15中的示例）。至于不支持Unicode
属性的问题（再加上事实上这两种编程语言中的记号，它会匹
中所有的Unicode字母字符。这个字符类会允许你匹配位于7比特ASCII地址空间之
274第5章
www.TopSage.com
---
## Page 291
外的各种常用的带读音符号的字符，或者也可以使用它的否定形式来排除这些字符。
123456789ABCDEF
8
H
KLMNO
Q
D
Y
Z
3
2
k
n
Y
A
B
F
D
Q
n
1
D
下面是-一个JavaScript的例子，用来把所有出现的单词“cat”都替换为“dog”。它能够
正确处理常见的包含读音符号的字符，所以并不会对ecat进行修改。要完成这样的任
务，你就需要构造自已的字符类，而不能采用JavaScript提供的\b或者w>：
// 8-bit-wide letter characters
（/）/).([）]）（1[）.=ud
//replace cat with dog,and put back any
// additional matched characters
subject =subject.replace(regex,'$1dog$2');
需要注意的是，JavaScript字符串字面量中可以使用\xHH（其中HH是两位的十六进制
数）来插人特殊字符。因此，传递给正则表达式的变量L中实际上会包含该字符的字
面版本。如果想要把元字符序列xHH传递给正则表达式，那么你就需要在字符串字面
量中对反斜杠进行转义（例如，"lxHH"）。然而，这样做在这个具体例子中并不会产生
任何作用，也不会改变正则表达式的匹配结果。
参见
实例5.2、实例5.3和实例5.4。
5.2查找多个单词之一
问题描述
你想要查找一个单词列表中的任意一个单词，但是不要对目标字符串进行多遍搜索。
单词、文本行和特殊字符
275
www.TopSage.com