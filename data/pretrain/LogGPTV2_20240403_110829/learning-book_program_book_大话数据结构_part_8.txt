■必须依据算法事先编制好程序，这通常需要花费大量的时间和精力。如果
编制出来发现它根本是很糟糕的算法，不是竹篮打水一场空吗？
■时间的比较依赖计算机硬件和软件等环境因素，有时会掩盖算法本身的优
劣。要知道，现在的一台四核处理器的计算机，跟当年286、386、486等
老爷爷辈的机器相比，在处理算法的运算速度上，是不能相提并论的；而
所用的操作系统、编译器、运行框架等软件的不同，也可以影响它们的结
果；就算是同一台机器，CPU使用率和内存占用情况不一样，也会造成细
微的差异。
■算法的测试数据设计困难，并且程序的运行时间往往还与测试数据的规模
有很大关系，效率高的算法在小的测试数据面前往往得不到体现。比如10
个数字的排序，不管用什么算法，差异几乎是零。面如果有一百万个随机
数字排序，那不同算法的差异就非常大了。那么我们为了比较算法，到底
用多少数据来测试，这是很难判断的问题。
基于事后统计方法有这样那样的缺陷，我们考虑不予采纳。
---
## Page 49
第2章算法
2.7.2事前分析估算方法
我们的计算机前辈们，为了对算法的评判更科学，研究出了一种叫做事前分析估
算的方法。
事前分析估算方法：在计算机程序编制前，依据统计方法对算法进行估算。
经过分析，我们发现，一个用高级程序语言编写的程序在计算机上运行时所消耗
的时间取决于下列因素：
1.算法采用的策略、方法。
2.编译产生的代码质量。
3.问题的输入规模。
4.机器执行指令的速度。
第1条当然是算法好坏的根本，第2条要由软件来支持，第4条要看硬件性能。
也就是说，抛开这些与计算机硬件、软件有关的因素，一个程序的运行时间，依赖于
算法的好坏和问题的输入规模。所谓问题输入规模是指输入量的多少。
我们来看看今天刚上课时举的例子，两种求和的算法：
第一种算法：
inti,sum-0,n-100;
执行1次/
for（i=1;i2时，算法A就开始优于算法B了，随着n的增加，算法A比
---
## Page 52
大诺数据结构
算法B越来越好了（执行的次数比B要少）。于是我们可以得出结论，算法A总体上
要好过算法B。
此时我们给出这样的定义，输入规模n在没有限制的情况下，只要超过一个数值
N，这个函数就总是大于另一个函数，我们称函数是渐近增长的。
函数的渐近增长：给定两个函数f（n）和g（n），如果存在一个整数N，
使得对于所有的n>N，f（n）总是比g（n）大，那么，我们说f（n）
的增长渐近快于g（n）。
从中我们发现，随着n的增大，后面的+3还是+1其实是不影响最终的算法变化
的，例如算法A与算法B'，所以，我们可以忽略这些加法常数。后面的例子，这
样的常数被忽略的意义可能会更加明显。
我们来看第二个例子，算法C是4n+8，算法D是2n²+1（如表2-8-2所示）。
表2-8-2
次数
算法C（4n+8）算法C'（n）算法D（2n²+1）算法D'（n²）
n=1
12
1
3
1
n=2
16
2
9
n=3
20
3
19
9
n=10
48
10
201
100
n=100
408
100
20001
10000
n=1000
4 008
1 000
2 000 001
1 000 000
当n≤3的时候，算法C要差于算法D（因为算法C次数比较多），但当n>3
后，算法C的优势就越来越优于算法D了，到后来更是远远胜过。而当后面的常数去
掉后，我们发现其实结果没有发生改变。甚至我们再观察发现，哪怕去掉与n相乘的
常数，这样的结果也没发生改变，算法C'的次数随着n的增长，还是远小于算法
D”。也就是说，与最高次项相乘的常数并不重要。
我们再来看第三个例子。算法E是2n²+3n+1，算法F是2n²+3n+1（如表
2-8-3所示）。
表2-8-3
次数算法E（2n²+3n+1）算法E'（n²）算法F（2n²+3n+1）算法F'（n²）
n=1
6
1
6
1
n=2
15
4
23
8
n =3
28
9
64
27
n =10
231
100
2 031
1000
n=100
20 301
10 000
2 000 301
1000 000
28
---
## Page 53
第2章算法
当n=1的时候，算法E与算法F结果相同，但当n>1后，算法E的优势就要开
始优于算法F，随着n的增大，差异非常明显。通过观察发现，最高次项的指数大
的，函数随着n的增长，结果也会变得增长特别快。
我们来看最后一个例子。算法G是2n²，算法H是3n+1，算法1是2n²+3n+1
（如表2-8-4所示）。
表2-84
次数
算法G（2n²）算法H（3n+1）算法1（2n²+3n+1）
n=1
2
4
6
n=2
8
7
15
n =5
50
16
66
n =10
200
31
231
n=100
20 000
301
20 301
n= 1,000
2 000 000
3001
2 003 001
n=10,000