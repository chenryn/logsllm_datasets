.B \-ffoo\c
\&\|' 开关选项 的 否定格式 应该是 `\|\c
.B \-fno\-foo\c
\&\|'.  下面的 列表 只展示了 一种 格式 \(em\& 那个 不是 默认选项 的 格式.
你 可以 通过 去掉 或 添加 `\|\c
.B no\-\c
\&\|' 构造出 另一种 格式.
.TP
.B \-ffloat\-store
不要 在 寄存器 中 存放 浮点变量. 这样 可以 防止 某些 机器 上 不希望
的 过高 精度, 如 68000 的 浮点寄存器 (来自 68881) 保存的 精度 超过了 \c
.B double\c
\& 应该 具有的 精度.
.Sp
对于 大多数 程序, 过高 精度 只有 好处. 但是 有些 程序 严格 依赖于 IEEE 浮点数
的 定义. 对 这样的 程序 可以 使用 `\|\c
.B \-ffloat\-store\c
\&\|' 选项.
.TP
.B \-fmemoize\-lookups
.TP
.B \-fsave\-memoized
使用 探索法 (heuristic) 进行 更快的 编译 (仅对 C++). 
默认情况下 不使用 探索法. 由于 探索法 只对 某些 输入文件 有效, 
其他程序 的 编译速度 会变得 更慢.
.Sp
第一次 编译器 必须 对 成员函数 (或对 成员数据 的 引用) 建立 一个 调用.
它 必须 (1) 判断出 这个类 是否 实现了 那个 名字 的 成员函数; (2) 决定
调用 哪个 成员函数 (涉及到 推测 需要 做 哪种 类型转换); (3) 检查 成员函数
对 调用者 是否 可见. 所有 这些 构成 更慢的 编译.
一般情形, 第二次 对 成员函数 (或对 成员数据 的 引用) 建立 的 调用, 必须
再次 经过 相同 长度 的 处理. 这 意味着 象 这样的 代码
.Sp
\&  cout << "This " << p << " has " << n << " legs.\en";
.Sp
对 整个 三步骤 要做 六次 遍历. 通过 使用 软件缓存, \*(lq命中\*(rq 
能够 显著地 减少 这种 代价. 然而 不幸的 是, 使用 这种 缓存 必须
实现 其他 机制, 带来了 它 自己的 开销. `\|\c
.B \-fmemoize\-lookups\c
\&\|' 选项 打开 软件缓存.
.Sp
因为 函数 的 正文环境 不同, 函数 对 成员 和 成员函数 的 访问权 (可见性)
也可能 不同,
.B g++
可能 需要 刷新 缓存. 使用 `\|\c
.B \-fmemoize\-lookups\c
\&\|' 选项, 每 编译完 一个 函数 就 刷新 缓存. 而 `\|\c
\-fsave\-memoized\c
\&\|' 选项 也 启用 同样的 缓存, 但是 当 编译器 发觉 最后 编译 的 函数
的 正文环境 产生 的 访问权 和 下一个 待编译的 函数 相同, 编译器 就 保留
缓存 内容.
这对 某个类 定义 许多 成员函数 时 非常 有用: 除了 某些 其他类 的 友函数,
每个 成员函数 拥有 和 其他 成员函数 完全一样 的 访问权, 因而 无需 刷新 缓存.
.TP
.B \-fno\-default\-inline
默认为 不要 把 成员函数 内嵌, 因为 它们 定义在 类的 作用域 内 (仅C++).
.TP
.B \-fno\-defer\-pop
一旦 函数 返回, 参数 就 立即 弹出. 对于 那些 调用 函数 后 必须 弹出 参数
的 机器, 编译器 一般情况下 让 几次 函数调用 的 参数 堆积 在 栈 上,
然后 一次 全部 弹出.
.TP
.B \-fforce\-mem
做 数学运算 前 把 将要 使用的 内存操作数 送入 寄存器. 通过 把 内存访问
转换成 潜在的 公共子表达式, 它 可能 产生 较好的 目标码. 如果 它们 不是
公共子表达式, 指令组合 应该 消除 各自的 寄存器载荷. 我 乐意 倾听 不同意见.
.TP
.B \-fforce\-addr
做 数学运算 前 把 将要 使用的 内存地址常数 送入 寄存器. 它 可能 和 `\|\c
.B \-fforce\-mem\c
\&\|' 一样 产生 较好的 目标码. 我 乐意 倾听 不同意见.
.TP
.B \-fomit\-frame\-pointer
对于 不需要 帧指针 (frame pointer) 的 函数, 不要 在 寄存器 中 保存 帧指针.
这样 能够 避免 保存, 设置 和 恢复 帧指针 的 指令; 同时 对 许多 函数 提供
一个 额外的 寄存器. \c
.I 但是 在 大多数 机器 上将 无法 调试\c
\&.
.Sp
某些机器上, 如 Vax, 这个 选项 无效, 因为 标准调用序列 自动 处理 帧指针,
通过 假装 不存在 而 不保存 任何 东西. 机器描述宏 \c
.B FRAME_POINTER_REQUIRED\c
\& 控制 目标机 是否 支持 这个选项.
.TP
.B \-finline\-functions
把 所有 简单的 函数 集成进 调用者. 编译器 探索式地 决定 哪些 函数 足够
简单, 值得 这种 集成.
.Sp
如果 集成了 所有 给定函数 的 调用, 而且 函数 声明为 \c
.B static\c
\&, 那么 一般说来 GCC 有权 不按 汇编代码 输出 函数.
.TP
.B \-fcaller\-saves
允许 在 寄存器 里 分配 数值, 但是 这个方案 通常 受到 各个 函数调用 的 冲击,
因此 GCC 生成 额外的 代码, 在 函数调用 的 前后 保存 和 复原 寄存器 内容.
仅当 生成代码 看上去 优于 反之结果 时 才 实现 这样 的 分配.
.Sp
某些 机器 上 该选项 默认为 允许, 通常 这些 机器 没有 调用保护寄存器 
代替 使用.
.TP
.B \-fkeep\-inline\-functions
即使 集成了 某个 函数 的 所有 调用, 而且 该函数 声明为 \c
.B static\c
\&, 仍然 输出 这个函数 一个 独立的, 运行时 可调用 的 版本.
.TP
.B \-fno\-function\-cse
不要 把 函数地址 存入 寄存器; 让 调用 固定函数 的 指令 显式 给出 函数地址.
.Sp
这个选项 产生 效率 较低 的 目标码, 但是 如果 不用 这个选项, 某些 不寻常
的 hack, 改变 汇编器 的 输出, 可能 因 优化 而 带来 困惑.
.TP
.B \-fno\-peephole
禁止 任何 机器相关的 peephole 优化.
.TP
.B \-ffast-math
这个选项 出于 速度优化, 允许 GCC 违反 某些 ANSI 或 IEEE 规则/规格.
例如, 它 允许 编译器 假设 \c
.B sqrt\c
\& 函数 的 参数 是 非负数.
.Sp
这个选项 不被 任何 `\|\c
.B \-O\c
\&\|' 选项 打开, 因为 对于 严格 依靠 IEEE 或 ANSI 规则/规格 实现
的 数学函数, 程序 可能 会产生 错误的 结果.
.PP
下列 选项 控制 特定的 优化. `\|\c
.B \-O2\c
\&\|' 选项 打开 下面的 大多数 优化项, 除了 `\|\c
.B \-funroll\-loops\c
\&\|' 和 `\|\c
.B \-funroll\-all\-loops\c
\&\|' 项.
.PP
而 `\|\c
.B \-O\c
\&\|' 选项 通常 打开 `\|\c
.B \-fthread\-jumps\c
\&\|' 和 `\|\c
.B \-fdelayed\-branch\c
\&\|' 优化项, 但是 特定的 机器 上的 默认优化项 有可能 改变.
.PP
如果 特别情况 下 非常 需要 \*(lq微调\*(rq 优化, 你 可以 使用 下面的 选项.
.TP
.B \-fstrength\-reduce
执行 循环强度缩小 (loop strength reduction) 优化, 并且 消除 重复变量.
.TP
.B \-fthread\-jumps
执行 优化 的 地点 是, 如果 某个 跳转分支 的 目的地 存在 另一个 条件比较,
而且 该 条件比较 包含在 前一个 比较语句 之内, 那么 执行 优化.
根据 条件 是 true 或者 false, 前面 那条 分支 重定向 到 第二条 分支
的 目的地 或者 紧跟在 第二条 分支 后面.
.TP
.B \-funroll\-loops
执行 循环展开 (loop unrolling) 优化. 仅对 循环次数 能够 在 编译时 或
运行时 确定 的 循环 实行.
.TP
.B \-funroll\-all\-loops
执行 循环展开 (loop unrolling) 优化. 对 所有 循环 实行. 通常 使 
程序 运行的 更慢.
.TP
.B \-fcse\-follow\-jumps
在 公共子表达式消元 (common subexpression elimination) 的 时候,
如果 没有 其他 路径 到达 某个 跳转 的 目的地, 就 扫过 这条 jump 指令.
例如, 如果 CSE 遇到 带有 \c
.B else\c
从句 的 \c
.B if\c
\& 语句, 当 条件测试 为 false 时, CSE 就 跟在 jump 后面.
.TP
.B \-fcse\-skip\-blocks
它 类似于 `\|\c
.B \-fcse\-follow\-jumps\c
\&\|' 选项, 但是 CSE 跟在 条件跳转 后面, 条件跳转 跳过了 语句块(block).
如果 CSE 遇到 一条 简单的 \c
.B if\c
\& 语句, 不带 else 从句, `\|\c
.B \-fcse\-skip\-blocks\c
\&\|' 选项 将导致 CSE 跟在 \c
.B if\c
\& 产生 的 跳转 后面.
.TP
.B \-frerun\-cse\-after\-loop
执行 循环优化 后, 重新 进行 公共子表达式消元.
.TP
.B \-felide\-constructors
如果 看上去 合理 就 省略 构造子 (仅C++). 
根据 这个选项, 对于 下面的 代码, GNU C++ 直接 从 调用 \c
.B foo\c
\& 初始化 \c
.B y\c
\&, 而无需 通过 临时变量: 
.Sp
A foo ();
A y = foo ();
.Sp
如果 没有 这个选项, GNU C++ 首先 通过 调用 类型 \c
.B A \c
合适的  构造子 初始化 \c
.B y\c
\&; 然后 把 \c
.B foo\c
\& 的 结果 赋给 临时变量; 最后, 用 临时变量 替换 `\|\c
.B y\c
\&\|' 的 初始值.
.Sp
ANSI C++ 标准草案 规定了 默认行为 (`\|\c
.B \-fno\-elide\-constructors\c
\&\|'). 如果 程序的 构造子 存在 副效应, `\|\c
.B \-felide-constructors\c
\&\|' 选项 能够 使 程序 有 不同的 表现, 因为 可能 忽略 一些 构造子 的 调用.
.TP
.B \-fexpensive\-optimizations
执行 一些 相对 开销 较大 的 次要 优化.
.TP
.B \-fdelayed\-branch
如果 对 目标机 支持 这个 功能, 它 试图 重新 排列 指令, 以便 利用
延迟分支 (delayed branch) 指令 后面的 指令 空隙.
.TP
.B \-fschedule\-insns
如果 对 目标机 支持 这个 功能, 它 试图 重新 排列 指令, 以便 消除 因
数据未绪 造成的 执行停顿. 这可以 帮助 浮点运算 或 内存访问 较慢 的 机器
调取 指令, 允许 其他 指令 先执行, 直到 调取 指令 或 浮点运算 完成.
.TP
.B \-fschedule\-insns2
类似于 `\|\c
.B \-fschedule\-insns\c
\&\|' 选项, 但是 在 寄存器分配 完成后, 需要 一个 额外的 指令调度 过程.
对于 寄存器 数目 相对 较少, 而且 取内存指令 大于 一个周期 的 机器,
这个选项 特别 有用.
.SH "目标机选项 (TARGET OPTION)"
缺省情况下, GNU CC 编译出 本机 类型 的 目标码. 然而 也可以 把他 安装成
交叉编译器, 为 其他 机型 编译 程序. 事实上, 针对 不同的 目标机, 可以 
同时 安装 GNU CC 相应 的 配置. 然后 用 `\|\c
.B \-b\c
\&\|' 选项 指定 目标机种.
.PP
顺便提一下, 新版本 和 旧版本 的 GNU CC 可以 共存. 其中一个 版本 (可能是
最新的 那个) 为 缺省 版本, 但是 有时候 你 希望 使用 其他 版本.
.TP
.BI "\-b " "machine"
参数 \c
.I machine\c
\& 指出 编译的 目标机种. 这个 选项 用于 安装为 交叉编译器 的 GNU CC.
.Sp
参数 \c
.I machine\c
\& 的 值 和 配置 GNU CC 交叉编译器 时 设置 的 机器类型 一样.
例如, 如果 交叉编译器 配置有 `\|\c
.B configure
i386v\c
\&\|', 意思是 编译 80386 上的 System V 目标码, 那么 你 可以 通过 `\|\c
.B \-b i386v\c
\&\|' 运行 交叉编译器.
.Sp
如果 没有 指定 `\|\c
.B \-b\c
\&\|' 选项, 通常 指 编译 本机 目标码.
.TP
.BI "\-V " "version"
参数 \c
.I version\c
\& 指出 运行 哪个 版本 的 GNU CC. 这个 选项 用于 安装了 多个 版本 的 GCC.
例如, 如果
.I version\c
\& 是 `\|\c
.B 2.0\c
\&\|', 意味着 运行 GNU CC 2.0 版.
.Sp
如果 没有 指定 `\|\c
.B \-V\c
\&\|' 选项, 缺省版本 取决于 GNU CC 的 安装方式, 一般说来 推荐 使用 通用版本.
.SH "机器相关选项 (MACHINE DEPENDENT OPTION)"
每一种 目标机型 都有 自己的 特别选项, 这些 选项 用 `\|\c
.B \-m \c
\&\|' 开关 引导, 选择 不同的 硬件 型号 或 配置 \(em\& 例如, 68010 还是 68020, 
有没有 浮点协处理器. 通过 指定 选项, 安装 编译器 的 一个 版本 能够 为 所有的
型号 或 配置 进行 编译.
.PP
此外, 编译器 的 某些 配置 支持 附加的 特殊选项, 通常 是 为了 在 命令行 上
兼容 这个 平台 的 其他 编译器.
.PP
下面是 针对 68000 系列 定义 的 `\|\c
.B \-m\c
\&\|' 选项:
.TP
.B \-m68000
.TP
.B \-mc68000
输出 68000 的 目标码. 
如果 编译器 按 基于 68000 的 系统 配置, 这个 选项 就是 缺省选项.
.TP
.B \-m68020
.TP
.B \-mc68020
输出 68020 的 目标码 (而不是 68000).  
如果 编译器 按 基于 68020 的 系统 配置, 这个 选项 就是 缺省选项.
.TP
.B \-m68881
输出 包含 68881 浮点指令 的 目标码.
对于 大多数 基于 68020 的 系统 这是 缺省选项, 除非 设置 编译器 时 指定了
.B \-nfp .
.TP
.B \-m68030
输出 68030 的 目标码.  
如果 编译器 按 基于 68030 的 系统 配置, 这个 选项 就是 缺省选项.
.TP