if (1preg_match(*/^[a-zA-2] (8, 12)s/D*, Susername)(
//处理验证失败的情况
8.5.6在移动应用程序中检验输入
之前曾经介绍过，移动应用程序中的数据既可以存储在远程服务器上，也可以存储在本地
的应用中。对于这两种情况都需要在本地检验输入。但是对于远程存储的数据，还需要在远程
服务器端对输入进行检查，因为我们无法保证另外一端一定是个实际的移动应用程序。也有可
能是攻击者，他正在使用自定义的攻击程序
可以采用两种方式对输入搜索（in-deviceinput)的输入数据进行检验。可以使用一种仅支持
我们所期望数据类型的输入域类型（ficldtype)。比如使用仅支持输入数字的输入域。另外也可
以订阅输入域的change事件，当接收到无效输入时由事件处理程序进行处理。Android支持输
入过滤器（inputfilter)的概念，它可以将一个或多个InputFilter的实现自动地应用于数据，并且
可以拒绝无效的输入。
8.5.7在HTML5中检验输入
在开发HTML5应用程序时，对于移动应用，也必须考虑数据存储在什么地方。数据可以
存储在Web测览器的本地存储中，也可以存储在承载HTML5Web应用程序的远程Web服务
·器上。对于存储在浏览器本地存储中的数据，可以使用JavaScript检验数据，或者使用HTML5
提供的薪类型的输入域进行检验。这些输入域支持required属性，该属性指示浏
览器检查在该输入域中必须具有输入值。此外，还支持pattem属性，允许开发人员设置一个正
则表达式，输入的数据必须满足该正则表达式的约束：
<input type=text" required="required" pattern=*^ [0-9](4)" ***
但是必须记住，攻击者在他自己的浏览器中，可以操纵 HTML、JavaScript 和存储在Web
浏览器本地存储中的数据。因此，如果客户端应用程序正把数据发送回服务器端的应用程序，
那么服务器端代码必须总是重新检验它从HTML5应用程序中接收到的输入数据。
309
---
## Page 324
SQL注入攻击与防御(第2版)
8.6编码输出
除了验证应用程序收到的输入以外，通常还需要对在应用程序的不同模块或部分间传递的
内容进行编码。在SQL注入语境中，将发送给数据库的内容进行编码或“引用”是必需的操
作，这样可以保证内容被正确地处理。不过，这并不是唯一需要进行编码的情形。
通常会被忽视的情况是对来自数据库的信息进行编码，尤其是当正在使用的数据未经过严
格验证或审查，或者来自第三方数据源时。虽然严格来说，这种情况与SQL注入无关，但还
是建议您考虑采用与前面类似的编码方法来防止出现其他安全问题（比如XSS)。
编码发送给数据库的内容
即便使用了白名单输入验证，有时发送给数据库的内容也仍然是不安全的，尤其是当在动
态SQL中使用了该内容时。例如，像O'Boyle 这样的名称是有效的，应该允许在白名单输入
验证中使用。但如果使用该输入动态产生一个SQL查询，该名称就会引发严重的问题，如下
所示：
(.+ 9ueuT + .. + oweug + .) S30TA Soueu OLNI 3SNI。 = be 5uT29
此外，可以向名称字段添加恶意输入，例如：
′,**) ; DROP TABLE names-*
它可以将执行的SQL修改为下列内容：
INSERT INTO names VALUES (**,**); DROP TABLE names--*,**) ;
可以使用本章前面介绍的参数化语句来防止出现这种情况。不过，对于无法或不适合使用
参数化语句的情况，有必要对发送给数据库的数据进行编码（或引用)。这种方法的局限性在于：
每次在数据库查询中使用这些值时都要进行编码。如果某个值没有编码，那么应用程序仍然易
受到SQL注入攻击。
1.针对 Oracle 的编码
由于Oracle使用单引1号作为字符串的结束符，因而有必要对包含在字符串（动态SQL中将
包含该字符串）中的单引号进行编码。在Oracle 中，可以通过使用两个单引号替换单个单引号
的方法来实现编码目的。这将导致单引号被当作字符串的一部分，而不是字符申结束符，从而
有效阻止恶意用户在特定的查询中利用SQL注入。可以使用与下面类似的代码在Java中实现
该目的：
sql - sql.replace (**=, ***=);
例如，上述代码会导致字符串O"Boyle变成O"Boyle。如果将其保存到数据库中，那么该
字符申将被保存成O'Boyle，因面不会在进行引I用操作时引发字符串结束问题。不过在PL/SQL
代码中进行字符申替换时应该格外小心。由于在PL/SQL中需要为单引号添加引用符（因为它是
字符串结束符），因而在PL/SQL中需要使用两个单引号来替换单个单引号。要实现该操作，只
需稍微花点儿功夫使用两对引用符（由4个单引号表示）替换一对引用符（由两个单引号表示）脚
310
---
## Page 325
第8章代码层防御
可，如下所示：
sq1 - replace(sql, **, .*.***);
使用字符编码表示上述内容逻辑性会更强，也更加清楚：
sq] = replace (sq1, CHR (39), CHR (39) 11 CHR (39)) ;
通配符的位置）添加引用符。根据应用程序所使用逻辑的不同，攻击者有可能通过利用用户输
入中的通配符（之后用在LIKE子句中）来修改应用程序逻辑的工作原理。在Oracle中，表8-2
列出的通配符在LIKE子句中是有效的。
表8-2Oracle 申LIKE子旬的通配符
字符
含义
%
匹配0个或多个任意字符
精确匹配任意一个字符
对于用户输入中包含表8-2列出的字符的示例，可以通过为查询定义一个转义字符、在通
配符前面添加该转义字符并使用ESCAPE子句在查询中加以指定来确保这些示例得到正确处
理。下面是个例子：
--易受攻击。返回所有以'a'字符开头的用户
-不容易受攻击，返回用户a'，如果存在一个这样的用户的话
请注意，使用ESCAPE子句时，可以指定任何单个字符作为转义字符。上述例子中使用了
反斜线，这是转义内容时常用的一种约定。
此外，在Oracle10gR1及之后的版本中，还存在另外一种引用字符串的方法一“q”引
用，采用q'【QUOTE CHARJstring/QUOTE CHAR/的格式。引用字符（quote character)可以是任
何未出现在字符串中的单个字符，除非Oracle期望匹配括号（例如，如果正在使用“[”作为起
始引用字符，将期望使用匹配的“]”作为结束引用字符）。下面是一些按照这种方式构造的引
用字符串的例子：
q* (5%) *
o,ov,b
Oracle dbms_assert
在Oracle 10g R2中，Oracle 引入了新的 dbms_assert包。这个包之后被移植到了较l旧的数据
库版本（直到Oracle8i)中。如果无法使用参数化查询（例如，在FROM子句中)，就应该使用dbms
assert 米执行输入验证。dbms_assert 提供了7个不间的函数(ENQUOTE_LITERAL、ENQUOTE
NAME、 NOOP、QUALIFIED_SQL_NAME、 SCHEMA_NAME、SIMPLE_SQL_NAME 和I SQL
_OBJECT_NAME)来验证不同类型的输入。
警告：
不要使用NOOP函数。这个函数不做任何事情并且无法保护我们免受SQL注入攻击。
Oracle在内部使用这个函数来避免自动源代码扫描过程中的误判。
311
---
## Page 326
SQL注入攻击与防御（第2版）
可以在下面i的例子中使用前面介绍的函数。第一段代码是一个未使用dbms_assert的非安
全查询(FIELD、OWNER 和 TABLE中存在 SQL 注入)：
下面是相同的查询，不过使用了dbms_assert进行输入验证：
execute immediate *select *IIsys .dbms_assert,SIMPLE_SQL_NAME (FIELD) 11
from'1Isys . dbms_assert .ENQUOTE_NAME
(sys , dbms_assert SCHEXA_NAME (OwNER) , FALSE)
11* . *11sys , dbms_assert , QUALIFIED_SQL_NAXE (TABLE) ;
表8-3列出了dbms_assert 支持的各种函数。
表8-3dbms_assert 函数
函数
描述
DBMS_ASSERT. SCHEMA_NAME
该函数检查传递的字符串是否为数据库中存在的对象
该函数检查SQL元素中是否只包含A-Z、a-Z、0-9、S、
DBMS_ASSERT. SIMPLE_SQL_NAME
#和_这样的字符。如果使用双引号来引用参数，那么允
许使用除双引号之外的所有字符
DBMS_ASSERT. SQL_OBJECT_NAME
该函数检查传递的字符串是否为数据库中存在的对象
DBMS_ASSERT. QUALIFIED_SQL_NAME
该函数与 SIMPLE_SQL_NAME非常类似，不过它还允
许数据库连接
该函数使用双引号来引用传递的参数。如果参数已被引
DBMS_ASSERT. ENQUOTE_LITERAL
用，就不做任何事情
如果未使用单引号引用用户提供的字符串，那么该函数
DBMS_ASSERT. ENQUOTE_NAME
会使用单引号来引用它
Oracle 在关于防御 SQL注入攻击的指南中详细介绍了如何使用 dbms_assert(http://st-
cumiculum.oracle.com/tutorial/SQLInjection/index.htm)。为避免通过修改公共同义词(public symonym)
发动的攻击，您应该坚持通过完全限定名(fully qualified name)调用该包。
2.针对 Microsoft SQLServer 的编码
由于SQL Server同样使用单引号作为字符串字面值的结束符，因而有必要对包含在字符串
（动态SQL中将包含该字符申）中的单引号进行编码。在SQLServer中，可以通过使用两个单引
号替换单个单引号米实现编码目的。这样一米，单引号会被当作字符串的一部分，而不是字符
串结束符，从而有效阻止恶意用户在特定的查询中利用SQL注入。可以借助与下面类似的代
码在C#中实现该目的：
sq] - sq] .Replace ("**, "***) 
例如，上述代码会导致字符串O"Boyle变成O"Boyle。如果将其保存到数据库中，该字符
中会被保存成O'Boyle，因而不会在添加引用符时引发字符串结束问题。不过，在存储过程的
Transact-SQL代码中进行字符串替换时应该格外小心。由于在Transact-SQL中需要为单引号添
加引用符（因为它是字符串结束符)，因而在Transact-SQL中需要使用两个单引号来替换单个单
312
---
## Page 327
第8章代码层防御
引号。要实现该操作，只需稍微花点儿功夫使用两对引用符（由4个单引号表示）替换一对引用
符（由两个单引号表示）即可，如下所示：
SET Benc - replace (@input, ****, ******)
使用字符编码表示上述内容逻辑性会更强，也更加清楚：
SET 8enc - rep1ace (einput., CHAR (39)。 CHAR (39) + CHAR (39)) ;
通配符的位置添加引用符。根据应用程序所使用逻辑的不同，攻击者有可能通过在输入中提
供通配符（之后用在LIKE子句中)来颠覆应用逻辑。在 SQL Server中，表8-4列出的通配符在
LIKE子句中是有效的。
表8-4SQLServer LIKE子句的通配符
字符
含义
%
匹配0个或多个任意字符
精确匹配任意一个字符
位于指定范围[a-d]或[abed]集合中的任意单个字符
[≤]
未位于指定范围[a-d]或[abcd]集合中的任意单个字符
对于需要在动态SQL的LIKE子句中使用这些字符的示例，可以使用方括号“D”来引用
该字符。请注意，只有百分号(%)、下划线（）和起始方括号（D需要被引用。在结束方括号①）、^
和连字符（-)前面添加的起始方括号则具有特殊含义。可以像下面这样做：
([1]。*])ooetdeg*(bs = {bs
sq1 - sq1 .Replace (*%*, * [%]*) 
sq] = sql.Replace ("_", "[_1") ;
此外，为防止出现与上述字符的匹配情况，还可以为查询定义一个转义字符，然后在通配
符前面添加该转义字符并使用ESCAPE子句在查询中加以指定。下面是个例子：
易受攻击。返回所有以'a'字符开头的用户
--不容易受攻击，返回用户a'，如果存在一个这样的用户的话
请注意，使用ESCAPE子句时，可以指定任何单个字符作为转义字符。上述例子中使用了
反斜线，这是转义内容时常用的一种约定。
提示：
在Transact-SQL中（例如，在存储过程中）将单引号编码为双单引号时，一定要注意为目标
字符事分配足够的存储空间，通常情况下，期望输入最大值的两倍再加1应该足够了，这是因
为存储的值过长时，Microsoft SQLServer会截断它，这会导致在数据库级的动态SQL中出现
问题。根据使用的查询的逻辑不同，这还会导致用于防止SQL注入漏洞的过滤器引发SQL注
入漏洞。
313
---
## Page 328
SQL注入攻击与防御（第2版）
出于同样的原因，建议使用replace0而非quotenameO来执行编码，因为quotename(无法
正确处理超过128个字符的字符串。
3.针对MySQL的编码
由于MySQL同样使用单引号作为字符串字面量的结束符，因而有必要对包含在字符串（动
态SQL中将包含该字符串）中的单引号进行编码，在MySQL中，可以像其他数据库系统那样
通过使用两个单引号替换单个单引号来实现编码目的，也可以使用反斜线（）来引用单引号。不
管使用哪种方法，单引号都会被当作字符串的一部分（面不是字符串结束符），从而有效阻止恶
意用户在特定的查询中利用SQL注入。可以借助与下面类似的代码在Java中实现该目的：
f(.\。'-.)eoetdex*Tbs = [bs
此外，PHP还提供了mysql_real_escapeO函数。该函数会自动使用反斜线来引用单引号及
其他具有潜在危害的字符，例如0x00(NULL)、换行符(n)、回车符(r)、双引号（)、反斜线()
和 0x1A(Ctrl+Z):
mysq]_real_escape_string($user) ;
例如，上述代码会导致字符串O'Boyle变成O'Boyle。如果将其保存到数据库中，该字符
串将被保存成O'Boyle，因面不会在添加引用符时引发字符串结束问题。不过，在存储过程代
码中进行字符申替换时应该格外小心。由于需要为单引号添加引用符（因为它是字符串结束符），
因而在存储过程代码中需要使用两个单引号来替换单个单引号。要实现该操作，只需稍微花点
儿功夫使用引用单引号（使用一个引用反斜线和一个引用单引号表示）替换引用符（使用一个引
用单引号表示即可，如下所示：
SET @sq1 = REPLACE (8sq1, *\**, *\\\*')
使用字符编妈表示上述内容连辑性会更强，也史加清楚：
SET Benc = REPLACE (e1nput, CHAR (39), CHAR (92, 39) );
对于其他类型的SQL功能，同样有必要对在动态SQL中提交的信息（即LIKE子句中使用
通配符的位置）添加引用符。根据应用所使用逻辑的不同，攻击者有可能通过在输入中提供通
配符（之后用在LIKE子句中)来颠覆应用逻辑。在MySQL中，表8-5列出的通配符在LIKE子