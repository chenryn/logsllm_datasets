程序都已经自动提供了对 distroff 完整的兼容性
.
.
.\" --------------------------------------------------------------------
.SS "商业化 Commercialization"
.\" --------------------------------------------------------------------
.
免费的 Unix\~7 操作系统商业化之后，出现了严重的退步。
.
一大批不同的操作系统浮出水面，为他们所作的扩展间的互不兼容而争斗。
.
幸好，这种不兼容没有影响到原始的 troff。
.
所有不同的商业版本的 roff 系统都大量使用了 
Osanna/\:Kernighan 的开放的源代码和文档，但是却将其作为
.BI "它们的" 
系统 (\[lq]their\[rq] system) 出售\[em] 只有很少的修改
.
.P
古老的 Unix 和传统的 troff 的源代码在长达 20 年时间里不再可以自由获得。
.
.P
幸运的是，Caldera 收购了 SCO UNIX (2001).
.
随后，Caldera 使得源代码可以在网上获得，允许用于非商业用途。参见
.BR "SEE ALSO" 
段
.
.P
(译注：谁能想到，现在，2003 年，SCO会成为自由软件和开源软件界共同的敌人呢？
而Caldera 又在什么地方呢？)
.
.
.\" --------------------------------------------------------------------
.SS "自由的 Free roff"
.\" --------------------------------------------------------------------
.
任何商业的 roff 系统都无法成为 roff 开发中的后继者。
.
商业社会中的每个人都只对他们自己的事情感兴趣。
.
这使得曾经如此优秀的 Unix 操作系统在 80 年代一蹶不振
.
.P
作为对如此快速的商业化过程的补救
(As a counter-measure to the galopping commercialization，还请重新翻译)，
AT&T Bell Labs 贝尔实验室试图发起一个恢复性的项目 (？，a rescue project) ，使用他们的
.I Plan\~9
操作系统。
.
它可以免费用于非商业用途，甚至包含了源代码。
但是它有一个专利许可证，that empedes the free development ( 还请解释词义)。
.
这种想法早已过时，因此 Plan\~9 没有被主流开发者接受为自己的平台
.
.P
真正的补救措施 (？， remedy) 是不断出现的自由操作系统
(386BSD, GNU/\:Linux, 等等.) 和 80 年代到 90 年代的自由软件工程。
.
他们实现了传统的 Unix 的特性和很多扩展，因此旧的 “XP体验” 不会丢掉
(such that the old experience is not lost)。
.
进入 21 世纪，类 Unix 系统重新成为计算机工业中的主导因素 \[em] 这要感谢自由软件
.
.P
最重要的自由 roff 计划是 GNU 移植版本的 troff，
由 James Clark 建立，使用
.URL http://\:www.gnu.org/\:copyleft "GNU Public License" .
.
它叫做
.I groff
.RI ( "GNU roff" ).
参见
.BR groff (1)
中的概述
.
.P
groff 系统仍然在继续开发。
.
它与传统 troff 兼容，但是还添加了很多扩展。
.
它是第一个可以在几乎所有操作系统上运行的 roff 系统并且 \[em] 它是自由开放的。
.
这使得 groff 成为现在 roff 的事实标准
.
.
.\" --------------------------------------------------------------------
.SH "使用 USING ROFF"
.\" --------------------------------------------------------------------
.
很多人不会注意到他们在使用 roff。
.
当你阅读一份手册页 (man page) 时，roff 工作在后台。
.
roff 文档可以使用
.BR xditview (1x)
程序查看，它是一个 X 发行版的标准程序。参见
.BR X (7x).
.
但是显式地使用 roff 也不困难
.
.P
一些 roff 实现提供了包装程序，使得人们可以简单地在命令行使用 roff 系统。
.
例如，GNU 的 roff 实现
.BR groff (1)
提供了命令行选项来避免传统 troff 中过长的的命令管道；
.BR grog (1)
程序试着从文档猜测应当使用什么参数来运行 groff；
不习惯于指定命令行选项的人应当用
.BR groffer (1)
程序来图形化地显示 groff 文件和手册页
.
.
.\" --------------------------------------------------------------------
.SS "管道 The roff Pipe"
.\" --------------------------------------------------------------------
.
roff 系统由预处理器 (preprocessor)，roff 排版程序和后处理器 (postprocessor) 组成。
.
这种结构使用了大量的管道
.I piping
机制，意思是，一系列的程序陆续地被调用，
队列中的每个程序的输出就作为下一个程序的输入
.
.CodeSkip
.
.ds @1 "cat \f[I]file\f[P] |\""
.ds @2 "\*[Ellipsis] | \f[I]preproc\f[P] | \*[Ellipsis] |\""
.ds @3 "troff \f[I]options\f[P] | \f[I]postproc\f[P]\""
.
.ShellCommand "\*[@1] \*[@2] \*[@3]"
.
.rm @1
.rm @2
.rm @3
.P
预处理器产生 roff 代码，传给一个 roff 处理器 (例如，troff)，
然后 roff 处理器接下来产生中间输出，传给一个后处理器程序，
用来打印或者产生最终输出
.
.P
所有这些组件都使用它们自己的程序语言；
每种语言是与其他组件完全无关的。
.
此外，还可以包括为特殊目标而制作 (tailor) 的 roff 宏包
.
.P
大多数 roff 文档中掺杂着使用一些包中的宏、
一个或多个预处理器的代码，还会添加 roff 语言中的一些元素。
.
用户很少需要用到 roff 排版语言的完整功能；
只有宏包的作者需要知道底层细节 (gory details)
.
.
.
.\" --------------------------------------------------------------------
.SS "预处理器 Preprocessors"
.\" --------------------------------------------------------------------
.
预处理器是任何产生符合 roff 排版语言语法的输出的程序。
.
每个预处理器都有它自己的语言，在预处理器运行时被翻译为 roff 代码。
.
roff 文档中可以包含以这种语言写成的片段；
它们可以被特殊的 roff 命令或宏识别
(they are identified by special roff requests or macros)。
.
加入了预处理器代码的文档必须通过所有相应的预处理器处理之后，
才能传给真正的 roff 排版程序，
因为真正的 roff 排版程序会忽略所有陌生的代码。
.
预处理器只会分析并转换指定由它处理的文档部分
.
.P
有大量的自由/商业 roff 预处理器。
.
一些不能在所有系统上使用，
还有一些预处理器被认为是 roff 系统不可分割的部分。
.
传统的预处理器有
.
.de @TP
.\" local indent for .TP
.TP \\w'\\f[B]soelim\\f[P]'u+2n
..
.P
.RS
.PD 0
.@TP
.B tbl
制表 (table)
.@TP
.B eqn
数学公式 (mathematical formul\[ae])
.@TP
.B pic
绘图 (diagram)
.@TP
.B refer
书目索引 (bibliographic references)
.@TP
.B soelim
包含标准位置的宏文件 (macro)
.PD
.RE
.
.P
其他已知预处理器，但不是在所有系统上都可用，包括
.
.P
.RS
.PD 0
.@TP
.B chem
化学公式 (chemical formul\[ae])
.@TP
.B grap
构造图元 (graphical elements)
.@TP
.B grn
插入
.BR gremlin (1)
图片
.PD
.RE
.
.rm @TP
.
.\" --------------------------------------------------------------------
.SS "排版程序 Formatter Programs"
.\" --------------------------------------------------------------------
.
A
.I roff formatter
排版程序是一个解释用 roff 排版语言或 roff 宏包写成的文档的程序。
.
它产生中间结果
.IR "intermediate output" ,
将送入单一设备后处理器。后处理器必须在排版程序的命令行选项中指定。
.
文档必须已经通过了所有需要的预处理器处理
.
.P
roff 排版程序的输出以另外一种语言表示：
.IR "intermediate output format"
或
.IR "troff output" .
这种语言最初详述在
.IR "[CSTR\~#97]" 
中；它的 GNU 扩展记载在
.BR groff_out (5)
中。
.
中间输出语言与高级的 roff 语言相比像一种汇编指令语言。
.
产生的中间输出是为一种特定的设备优化过的，
但是对于所有设备，这种语言都适用
.
.P
roff 排版程序是整个 roff 系统的核心。
.
传统 roff 有两个排版程序：
对应字符设备的
.B nroff
和对应图形设备的
.B troff
.
.P
通常，
.I troff
这个名字泛指这两种排版程序
(is used as a general term to refer to both formatters)。
.
.
.\" --------------------------------------------------------------------
.SS "设备 后处理器 Devices and Postprocessors"
.\" --------------------------------------------------------------------
.
设备是类似打印机、字符或图形终端等的硬件接口，
或者是用于转换为另一种字符或图形设备的软件接口
.
.P
后处理器是将 troff 输出转化为一种适于某种特殊设备的格式的程序。
.
对于输出目标来说，roff 后处理器像是它们的设备驱动
.
.P
每种设备都有为其优化的后处理器程序。.
.
后处理器解释中间输出，产生设备相关的代码，传送给设备
.
.P
设备名和后处理器程序的名称是不固定的，
因为它们依赖于计算机的软硬件的能力。
.
例如，
.I [CSTR\~#54]
中提到的传统的设备名已经有了极大的改变。
.
旧的硬件不再存在，旧的图形转换程序与现代同等功能的程序相比太不精确了
.
.P
例如，Postscript 设备
.I post
在传统 troff 中分辨率是 720，而 groff 的
.I ps
设备是 72000, 提高了 100 倍
.
.P
现在，操作系统为大多数类似打印机的硬件提供了设备驱动，
因此不必为每个打印机写一个特殊的后处理器
.
.
.\" --------------------------------------------------------------------
.SH "roff 编程 ROFF PROGRAMMING"
.\" --------------------------------------------------------------------
.
roff 文档是加入了 roff 排版元素的普通文档。
.
roff 排版语言非常强大；
它几乎是一个完整的程序语言，并且提供了扩充自身的元素。
.
使用这些元素，就可以开发为特殊程序定制的宏包。
.
这样的宏包比普通的 roff 要容易上手得多。
.
所以大多数人会选择一中宏包，
不用去关心 roff 语言的内部实现
.
.
.\" --------------------------------------------------------------------
.SS "宏包 Macro Packages"
.\" --------------------------------------------------------------------
.
宏包是一些适于以便利的办法格式化某种特殊文档的宏的集合。
.
它们简化了 roff 的使用。
.
一个包的宏定义保存在一个叫做
.IB name .tmac
的文件中 (传统的命名是
.BI tmac. name\c
).
.
所有 tmac 文件保存在标准位置的一个或多个目录中。
.
有关宏包的命名和位置的细节可以看
.BR groff_tmac (5).
.
.P
文档中用到的宏包可以使用命令行选项
.ShortOpt m 
提供给排版程序, 参见
.BR troff (1),
它们也可以在文档中指定，使用 roff 语言的 “包含文件” 命令，参见
.BR groff (7).
.
.P
著名的传统宏包有
.I man
用来处理传统手册页
.I mdoc
处理 BSD 样式的手册页；此类书籍、文档和信件的宏集合是
.I me
(命名也许是根据它的创造者之名
.I Eric
Allman 而来),
.I ms
(命名来自
.IR "Manuscript Macros\/" ),
还有
.I mm
(命名来自
.IR "Memorandum Macros\/" ).
.
.
.\" --------------------------------------------------------------------
.SS "roff 排版语言 The roff Formatting Language"
.\" --------------------------------------------------------------------
.
传统的 roff 排版语言记述在 troff 用户手册
.I Troff User's Manual
.IR "[CSTR\~#54]" 
中.
.
roff 语言是完整的编程语言，提供了命令 (request)，宏定义，转义序列 (escape sequence)，
字符串变量，数字或数量寄存器 (number or size registers)，还有流程控制语句
.
.P
.I Requests
“命令” 是预定义的基础的排版命令，与 shell 提示下的命令类似。
.
用户可以定义类似 “命令” 的元素，使用 roff 的 “预定义” 元素。
.
用户定义的命令就被叫做 “宏”
.IR macros .
.
文档作者不会体会到 命令和宏 之间用法的任何区别；
它们都写在一行中，并以一个点 (dot, `.') 开始