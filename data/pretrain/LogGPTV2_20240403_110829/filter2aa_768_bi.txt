概而言之，应用软件与操作系统之间既有统治关系，又有共生关系，应用软件对操作
系统来说可谓是“船可载舟，亦能覆舟”。理解了这层意义之后，对于一个操作系统来说，
它存活的关键就是要能运行尽可能多的应用软件，而且这些软件最好是用户离不开的，最
好是在其它操作系统上无法运行的，最好是不断更新的，最好是高质量的，而且最好这样
的软件会层出不穷、源源不断的涌出来....... 
或者说，对一个操作系统来说，光把自己的代码弄好还远远不够，还要有能力跑缤纷
多彩的应用软件，有魄力为应用软件搭建一个宽广伟岸的运行平台，有魅力吸引软件开发
商（ISV）前仆后继的为其开发应用软件。深刻理解这一点不容易，做到这一点就更不容
易了。 
要有高质量的应用软件不容易，为了做到这一点，操作系统需要提供基础设施来支持。
有点像很多好的公司都为员工准备健身房一样，操作系统也要给应用软件建设好磨练筋骨
的地方，让它们身强体壮，身手敏捷，能适应各种复杂甚至恶劣的运行环境。 
当然对于不守纪律的人，也要有纪律来惩罚，吊起来上刑（图中右侧那个）。对于生
病了人，应该有医生帮助它治疗。 
《软件调试》补编 
- 143 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
让 ISV 愿意在一个系统上做软件开发不是件容易的事，吸引一个 ISV 可能很简单，
但是吸引成千上万的 ISV 就不容易了。软件开发不是请客吃饭，一个软件开发团队的日常
开销不是小数目。还活着 ISV 大多懂得不能在螺蛳壳里做道场的道理。就像选择开发区做
投资要考察它的基础设施一样，要在一个系统上做开发，也应该衡量下这个系统的基础设
施怎么样。对于开发区来说，交通、水、电、煤气、网络等等都是头等重要的基础设施。
而对一个操作系统来说，API、开发工具和调试设施可谓是直接影响软件开发效率的关键
基础设施。 
《软件调试》将操作系统的调试设施分为如下几类： 
支持调试器的系统设施：因为调试器是软件调试的核心工具，所以支持调试器是操作
系统支持调试的首要任务。在 DOS 这样的单任务系统中，调试器可以直接使用硬件中的
调试设施，因此基本不需要操作系统的支持，但是在一个多任务的操作系统中，调试器可
能也同时运行很多个，这就要求操作系统必须来统一管理和协调调试资源。另外，多任务
环境下的诸多保护机制使得让操作系统来实现必要的“调试器功能”是最合适的，比如收集
和分发调试事件。从运行模式角度来看，多任务环境下的软件有的运行在搞特权的内核模
式下，有的运行在低特权的用户模式下。调试这两种不同模式下的软件有着很多不同，因
此通常使用不同的调试器，即内核态调试器（第 18 章）和用户态调试器（第 9 章和第 10
章）。 
异常处理：处理异常是软件开发中一个老生常谈的话题。也是很多程序员觉得难以理
解和棘手的问题。操作系统能不能减轻程序员这方面的负担呢？如果能又是如何做的呢？
在这个问题上，不同操作系统的做法有挺大的不同。举例来说，同样是 C++语言规范中的
try{}catch()结构，在某些系统下就可以捕捉到 CPU 产生的异常（有时称异步异常），而在
某些系统上就不能捕捉。《软件调试》的第 11 章详细介绍了 Windows 操作系统中管理和
分发异常的方法。如果应用软件自己没有处理异常又怎么样呢？第 12 章介绍了未处理异
常的处置方法。很多人对 Windows 下异常处理机制的一个困惑是搞不清楚所谓的第一轮
（First Chance）和第二轮（Last Chance）。看过上面两章后，可以把这个问题彻底搞清楚。 
错误通知机制：指实时的向用户通报错误信息（第 13 章），通过对话框、声音、闪动
窗口等。 
错误报告机制：软件是要给客户用的，而且发布到客户手里的软件也会出问题。从
BUG 的成本曲线（《软件调试》图 1-9，P23）来看，解决发布后的 BUG 的成本是最高的。
如何降低这个成本呢？普遍认可的一种方法就是让位于客户那里的软件为自己产生一份
“生病”报告，整理，然后借助互联网发送出来（第 14 章）。 
错误记录机制：指永久记录软件的运行过程，特别是遇到异常和错误时的情况（第
15 章）。 
事件追踪机制：错误记录机制通常不适合频繁的输出，如果频繁输出那么不仅会明显
影响系统的性能，而且可能导致记录文件很大，难以检索有用的信息。而事件追踪机制就
是针对这一需求而设计的，因为是使用专门的内存缓冲区，而且具有动态开启机制，所以
它能够承受频繁的信息输出，而且开销不大（第 16 章）。 
验证机制：根据 BUG 的成本曲线，越早发现问题越好，但是做到早发现问题并不容
易。一种方法就是一个更严格的标准进行测试，让被测试软件在更苛刻的条件下运行，故
意为其设置障碍来考验它。如何实施这些考验呢？操作系统的验证机制就是满足这一需要
的（第 19 章）。 
《软件调试》补编 
- 144 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
硬件错误管理机制：有些严重的崩溃和挂住是与硬件有关的，但是却找不到进一步的
信息来定位到根源，以便排除或者在以后的产品中改进。PCIe 总线标准中制定了报告错
误的通用机制，CPU 中也有机器检查设施（第 6 章），但是这些硬件设施是需要软件，特
别是系统软件的配合才能发挥作用的（第 17 章）。 
打印调试信息：打印调试信息（Output debug info 或者 Print）是一种简单易用的辅助
调试方法。这种方法的不足就是效率比较低，不仅运行效率低，而且增加和减少需要重新
编译，时间成本很高（10.7 节）。 
崩溃和转储机制：转储是最古老的调试方法之一，简单说就是把内存数据“拍张照片”
保存下来。在 Jack Dennis 为《软件调试》写的《历史回眸》短文中就提到了这种方法，
当年是先使用一个工具程序将内存中的数据显示到 CRT 上，然后用照相机拍下 CRT 上的
内容，最后再使用胶卷阅读器来阅读冲洗出来的胶片。这可真是给内存“拍照”（12.9 节和
13.3 节）。 
为了让读者对以上调试设施有一个全面的理解，《软件调试》使用了三分之一的篇幅
进行介绍，分 12 章，总页数达 376 页之多。这样的篇幅也使这一篇成为全书六篇中最长
的一篇。为什么花这么大篇幅呢？ 
1）第 9、10、18 章分别介绍的是用户态和内核态调试模型，是理解调试器的基础，
因此理当不惜笔墨。这三章分别是 34 页、46 页和 52 页，加起来为 132 页，占这一篇的
三分之一。 
2）第 11 章和 12 章介绍异常分发和未处理异常，这些内容不仅与调试器有着密切关
系，而且是本书的“异常”主题的核心内容。这两章一共有 86 页。 
3）其它 7 章肩负着介绍上面提到的其它辅助调试设施的责任，一共用了 158 页，平
均每章 22 页。介绍这些内容一则是对调试有全面的理解，在软件工程中使用这些设施，
另外也可以帮助大家更好的理解操作系统，提高综合调试能力。 
另一个问题是以什么方式来介绍这些调试设施。是以一个具体的操作系统为例详细介
绍，还是以抽象理论为主，偶尔举例。《软件调试》采用的是前一种方法，而且选择的是
Windows。为什么选择 Windows 呢？主要原因是它的广泛性。为什么没有选择 LINUX 呢？
主要原因是它在调试方面还有很多足。很多资深的 LINUX 也不讳言 LINUX 在调试方面
的缺欠，直至今天，LINUX 下最普遍使用的调试方法依然是 PRINT。事实上，选择 LINUX
来写，会好写很多，毕竟有现成的源代码可以读。 
尽管书中多次明显提到选择 Windows 只是将其作为一个操作系统实例来介绍操作系
统对软件调试的支持，但是还有一些人无法理解。不过，在买了书的读者中，还是理解的
人多，其中也有一些专业做 LINUX 的工程师或者讲师。 
上面介绍了这一篇的写作目的、主要内容和结构布局，下面再推荐一下阅读的顺序。
对于初级读者，建议先泛读第 9、10 两章之外的所有章节，然后仔细读第 11 章和 12 章，
再后则读第 13 章中的《硬错误和蓝屏》。对于有一定调试基础的中级读者，可以根据自己
的兴趣仔细读感兴趣的章节。对于高级读者，可以先读第 9、10 和 18 章，然后浏览其它
章节，遇到感兴趣的仔细阅读。 
[12 月 31 晨略作修改，增加插图] 
《软件调试》补编 
- 145 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
补编内容
补编内容
补编内容
补编内容 11 “
“
“
“调试之剑
调试之剑
调试之剑
调试之剑”
”
”
”专栏之启动系列
专栏之启动系列
专栏之启动系列
专栏之启动系列 
补编说明： 
大约从 2005 年开始，我陆续在《程序员》杂志上发表一些关于软件调试
的文章，最早的一个系列是“CPU 的调试支持”，而后又写了几期后便中
断了。2008 年 9 月，《软件调试》出版后，《程序员》杂志建议我继续以前
的调试专栏，并命名为调试之剑。 
新的“调试之剑”专栏开始后，我写的第一个系列便是“系统启动系列”，
已经发表了下面四篇文章： 
举步维艰——如何调试显示器点亮前的故障 
权利移交——如何调试引导过程中的故障 
步步为营——如何调试操作系统加载阶段的故障 
百废待兴——如何调试内核初始化阶段的故障 
以上文章发表后，虽然收到几封读者的来信（通过编辑），总的来说反响
甚是冷淡。可能大多数人都提不起来兴趣学习这些没用的东西。 
《软件调试》补编 
- 146 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
举步维艰——如何调试显示器点亮前的
故障 
显示器是个人计算机（PC）系统中必不可少的输出设备，它是计算机向用户传递信
息的首要媒介。用户也正是通过显示器来观察计算机所作的“工作”，与其交流。离开了
显示器，我们便很难知道计算机在干什么。因为这个原因，在计算机系统启动的早期，要
做的一个重要任务就是初始化显示系统以便可以通过显示器输出信息，俗称点亮显示器。 
对于今天的大多数个人计算机，从用户按下电源按钮到显示器被点亮通常在一秒钟左
右。对人类而言，这是一个稍纵即逝的时间。但对计算机系统和 CPU 而言，这一秒钟要
完成很多任务。如果中间遇到障碍，那么便可能停滞不前，出现显示器迟迟没有被点亮的
现象。今天我们就由浅入深的谈一谈遇到这种情况时该如何处理。考虑到笔记本系统的差
异性较大，我们将以典型的台式机系统（即所谓的 IBM 兼容 PC）为例。为了辅助记忆，
我们不妨套用一下我国中医使用的“望闻问切”方法。 
望
望
望
望——
——
——
——不要闹笑话
不要闹笑话
不要闹笑话
不要闹笑话 
首先，应该“望一望”主机和显示器的电源是否都插上了，它们的指示灯是否正常，
它们之间的连线是不是连接妥当。这样做的目的是在“大动干戈”之前做好基本的检查，
防止费了很多力气最终才发现是插头松了这样的低级问题，闹出笑话。不过这些检查靠常
识就足够，没有什么技术含量，我们不去赘述。 
闻
闻
闻
闻——
——
——
——听声识原委
听声识原委
听声识原委
听声识原委 
中医中的“闻”既包含用耳朵听，也包含用鼻子闻——嗅。这两种途径对我们也都适
用。 
我们先来谈如何靠听来了解计算机系统的病在哪里。尽管今天的个人计算机主要是靠
声卡（或者集成在芯片组中集成音频设备）来播放声音的，但是在个人计算机诞生之初并
没有声卡，甚至到了上世纪九十年代初笔者购买电脑时，典型的 PC 系统仍没有声卡，原
因是价格很贵。在声卡出现之前，图 1 所示的扬声器是 PC 系统上的主要发声设备。 
《软件调试》补编 
- 147 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
图 1 位于机箱上的 PC 喇叭 
图 1 中的照片是从一台大约购于 2000 年的旧电脑中拍摄的。那时声卡设备便比较普
及，PC 喇叭的用途变得越来越少，为了节约成本，今天的 PC 系统通常用一个位于主板
上的小蜂鸣器（Beeper）来代替 PC 喇叭（图 2），二者虽然外观有很大的不同，但是工作
原理是完全一样的。因此我们仍使用统一的名字来称呼它们。 
图 2 位于主板上的蜂鸣器 
对程序员来说，使用 PC 喇叭的方法非常简单，只要将 I/O 端口 0x61 的最低两位都写
为 1 便可以让 PC 喇叭开始鸣叫；将最低两位中的某一位置为 0 便可以让它停止鸣叫。通
过一个小实验可以很方便的感受一下。使用 WinDBG 启动一个本地内核调试会话，然后
使用端口输出命令来读写 0x61 端口，这样便可以开关 PC 喇叭。具体来讲，首先使用 ib
命令读出端口 0x61 的当前内容： 
lkd> ib 0x61 
00000061: 30 
然后，把读到值的低三位置为 1，使用 ob 命令输出（执行前做好心理准备，叫声可
能很刺耳）： 
lkd> ob 0x61 30|3 
此时读取这个端口的内容，可以看到端口值的低两位都为 1。听得不耐烦了吧，那么
赶紧执行下面的命令将其停止： 
lkd> ob 0x61 30 
事实上，端口 0x61 的位 0 的含义是启用 PC 系统中的可编程时钟计数器（Programmable 
Interval-Timer/Counter，通常称为 8253/8254）的 2 号通道（共有三个，分别为 0、1 和 2）
使其输出一定频率的方波脉冲，刚才听到的鸣叫声正是这个方波输出给 PC 喇叭而发出的。
端口 0x61 的位 1 相当于给时钟控制器的输出加一个开关，或者说加了个与门（图 3）。 
《软件调试》补编 
- 148 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
图 3  PC 喇叭的工作原理示意图 
时钟控制器的输出频率是可以改变的，以变换的频率来驱动 PC 喇叭可以使其发出一
些简单的“旋律”。 
因为大多数 PC 系统都有 PC 喇叭，而且对软件来说，使用 PC 喇叭输出声音非常简单，
所以计算机系统的设计者们很自然地想到了在 PC 启动早期使用蜂鸣器来报告系统遇到的
错误情况。虽然播放复杂的声音很困难，但是可以使用蜂鸣的次数或者每次蜂鸣的长短不
同来代表不同的含义。因为这种错误信息是通过 PC 喇叭以鸣叫的方式报告的，所以通常
称为蜂鸣代码（Beep Code）。 
当按下 PC 机的电源按钮后，首先运行的是固化在系统主板上的固件程序（firmware），
通常称为 POST 程序，POST 是 Power On Self Testing 的缩写，含义是上电自检。不同的
POST 程序（固件），定义蜂鸣代码的方式也有所不同。表 1 中列出的是英特尔主板通常
使用的蜂鸣代码。 
表 1  英特尔主板所使用的蜂鸣代码 
蜂鸣代码 
含义 
鸣叫 1 声 
DRAM 刷新失败 
鸣叫 2 声 
校验电路失败 
鸣叫 3 声 
基础 64K 内存失败，可能是没有插内存条或者内存条松动 
鸣叫 4 声 
系统时钟失败 
鸣叫 5 声 
处理器（CPU）失败 
鸣叫 6 声 
键盘控制器失败 
鸣叫 7 声 
CPU 产生异常 