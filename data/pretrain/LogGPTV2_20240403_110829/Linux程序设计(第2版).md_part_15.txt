2.4.6命令的执行
在我们编写脚本程序的时候，经常需要铺获某个命令的执行结果并把它用在shell脚本程序
里，也就是说，我们希望执行一条命令并把这条命令的输出放到一个变量里去。通过
“S（command）”语法可以实现这一目的，我们在前面介绍set命令的示例中见过这样的用法。还
有一种比较老式语法形式，“command”，还有不少人仍在使用着。
请注意，在脚本程序语句里执行命令的老办法里使用的是反引号（）而不是我们
前面用来括住shell变量的单引号（）（单引号的作用是防止变量进行扩展）。请只在你
需要使自己的脚本程序具备高移植性的时候才使用这种老办法。
新脚本程序使用的都是“$（。.)”形式，引人这一形式的目的是为了回避在用反引号括起来
的命令中使用“S”、"”、“”等字符时相当复杂而又琐碎的规则。如果在“”结构里需要
用到反引号，就必须通过“”字符进行转义。这些规则往往会让程序员头疼不已，有时即使是
程序设计老手也会栽在这个问题上，不得不逐字逐句地改正在反引号结构里用错了的引号。
“S（command）”的结果就是其中的命令的输出。注意，那不是该命令的退出状态而是它的字
符串输出结果。请看下面的例子：
#1/bin/sh
echo The current directory is SPWD
echo The current users are $(who)
exit 0
因为当前子目录是一个shell环境变量、所以第一行不涉及在脚本程序语句里执行命令的结
构。可who命令就不同了，如果需要在脚本程序里使用它的执行输出，就必须用上这种结构。
把某个命令的执行结果放到一个变量里去这一概念有很大的意义，因为这使在脚本程序里
加入jaVa编程群：524621833
---
## Page 72
第2章shell程序设计
53
使用现有命令并捕获其输出的工作变得很容易。如果读者需要把某个命令对标准输出的输出转
换为一组参数，或者需要把它们用做另一个程序的参数，就会发现xargs命令能够替你做好这一
切。具体细节请参考相应的使用手册。
有时这样做也会遇到一个问题，就是我们打算调用的命令在输出我们想要的内容之前先输
出了一些空白字符，或者它输出的东西比我们要求的多。在这种情况下，可以利用前面介绍的
set命令加以解决。
1.算术扩展
我们已经介绍过expr命令，它允许对简单的算术命令进行处理，但这种做法执行起来是相当
慢的，因为需要调用一个新shell来处理expr命令。
一种更新颖更适用的办法是“$（（...)”扩展。把准备求值的表达式括在“$（...)”里能够
让我们更高效地完成简单的算术计算。如下所示：
qs/uTq/i#
x=0
op0ta-xs、1
x=$（（$x+1))
echo $x
done
exit 0
2.参数扩展
我们已经见过最简单的参数赋值和扩展情况了，即：
foo=fred
ecbo $foo
当我们想在变量名里额外添加字符的时候就会遇到问题。假设我们想编写一个简短的脚本
程序来处理名为1_tmp和2_mp的两个文件。我们试试下面的办法：
#1/bin/sh
for i in 1 2
10
done
但在每次循环里，我们都会看到如下所示的出错信息：
By_secret_process: too few argument8
哪儿出错了呢？
问题在于shell试图替换变量“$i_tmp”的值，而这个变量其实并不存在。但shell并不会认识
到这一错误，相反，它会把一个空值做为这个并不存在的变量的值，因此根本不会有参数被传
递到my_secret_process。为了解决变量名里类似于“si”这样的扩展情况，我们需要把“i”括
在一对花括号（11）里，就像下面这样：
:/bin/sh
for 1 in 1 2
do
done
my_secret_process $(i)_tomp
加入jaVva编程群：524621833
---
## Page 73
54
Linux程序设计
以后，在每次循环里，“”的值被替换为“$（i)”、从面给出了正确的文件名。也就是说，我
们把参数的值替换为一个字符串了。
在shel里我们可以来用很多种参数替换办法。这样做通常都会让我们得到一个精巧的解决
方案。
常见的参数扩展替换见表2-12：
表2-12
参数扩展
说明
S{param:-default)
如果param是空，就把它设置为defauht的值
S (#param)
给出param的长度
S (parameword)
从param的尾部开始剧除匹配word的最小部分并返回朝余部分
S(paramtsword)
从parm的尾部开始题除匹配word的最大部分并返同剩余部分
$ {param#word)
从param的头部开始剧除匹配word的最小部分并返回剩余部分
$(param##word)
从param的头部开始到除匹配word的最大部分并返同剩余部分
在对字符串进行处理的时候，这些扩展替换经常是很有用的。特别是对字符串进行部分制
除的那后四个，在对文件名和路径进行处理时作用极大。请看下面的例子。
动手试试：参数的处理
下面这个脚本程序的各个段落演示了各种参数匹配操作符的用法：
+1/bin/sh
unset foo
foo=fud
foo=/usr/bin/x11/startx
echo s(foo##*/)
echo $(foo#*/)
ber=/usr/local/etc/local/networks
echo $(barblocal*)
echo $(bare8loca]*)
exit 0
它将给出如下所示的输出：
bar
usr/bin/X11/startx
fud
/usr/1ocal/etc
startx
/usr
操作注释：
第一个语句“S(foo:-bar1”给出的值是“bar"，因为在这条语句被执行的时候foo没有任何
值。但变量foo并没有发生什么变化，它还停留在unset状态。
加入jaVva编程群：524621833
---
## Page 74
第2章shell程序设计
55
如果这条语句是“S[foo：=bar}”，就会把此变量设置为Sfoo.这个字符串操作将的
作用是检查foo是否存在且不为空：如果是这样的，它就返回变量的值：否则就把foo赋
值为bar并返回它。
条命令。
“$[foo:+bar}”会在foo存在并不为空的情况下返回bar。选择可太多了！
“foo#*/）”语句匹配并删除最靠尾部的那个“”字符（因为“*”匹配的是零个以上的字
符）。“foo##"/)”语句尽量匹配并删除最多的东西，所以它删除了最靠右边的“”字符及其之
前的一切内容。
“{bar%local*}”语句从字符串的末尾开始匹配，它会一直匹配到从尾部算起第一次出现的
“local”（及跟在它后面的全部字符）：而“{bar%%local*)”会从尾部开始尽量匹配最多的东西，
直到它找到最靠左边的“local”。
根据UNIX操作系统中的管道概念，前一个操作的结果经常需要通过人工进行重定向。假设
读者需要用cjpeg程序把一个gif文件转换为一个jpeg文件。
S cjpeg image.gif > image.jpg
但有时，读者需要对很多的文件进行这类操作。怎样才能让重定向工作自动进行呢？很简
单，这样做就行：
for image in *.gif
!/bin/sh
do
cjpeg Simage > S(inageggif}pg
done
我们可以给这个脚本程序起名为giftojpeg，它会在当前子目录里为每一个gif文件创建出一个
jpeg文件。
2.4.7即时文档
从一个shel脚本程序向一条命令传送输人数据有一个特殊的办法，这就是使用一个即时文
档（here文档）。允许命令在执行时就好像是在读一个文件或读键盘一样，而它实际上是从脚本
程序里得到输人数据的。
即时文档的开始是两个连续的小于号“
set -o noexec
只检查语法错误，不执行命令
set -n
sh -v <script
set -o verbose
在执行命令之前回显它们
set -V
sh -x <script
set -v xtrace
在处理完命令行之后回显它们
set -x
set -o nounset
如果使用了未定义变量就给出一条出错信息
n-1as
用“-o”选项置位set命令的选项标志，用“+o”取消设置；也可以使用简化的单字符选项。
加上xtrace选项就能看到一份简单的执行跟踪报告。在刚开始调试检查工作时，我们可以
先用命令行选项跟踪命令的执行情况；然后随着调试的细化和深人，逐步缩小跟踪范围，把
xtrace标志（用来开、关跟踪执行命令的功能）放到我们认为有毛病的脚本程序代码的前后。
执行命令跟踪功能的作用是让shell在执行脚本程序中的每行程序之前先显示已经对变量做了扩
展的代码。在每行代码的前面用“+”号的个数指出变量扩展的层次数（这是它的缺省设置情
况）。我们可以通过对shell配置文件里的PS4shel变量进行设置的办法把“+”修改为更有意义
的文字说明。
在shell里，我们还可以通过陷落EXIT信号在脚本程序退出执行时查看到它的状态，具体做
法是在脚本程序的开始放上一条如下所示的语句：
trap 'echo Sxiting: critical variable = $critical_variable′ EXI7
加入jaVa编程群：524621833