title:AndrEnsemble: Leveraging API Ensembles to Characterize Android Malware
Families
author:Omid Mirzaei and
Guillermo Suarez-Tangil and
Jos&apos;e Mar&apos;ıa de Fuentes and
Juan Tapiador and
Gianluca Stringhini
AndrEnsemble: Leveraging API Ensembles
to Characterize Android Malware Families
Omid Mirzaei, Guillermo Suarez-Tangil♣, Jose M. de Fuentes,
Universidad Carlos III de Madrid, ♣King’s College London, ♠Boston University
Juan Tapiador, and Gianluca Stringhini♠
{omid.mirzaei,jfuentes,jestevez}@uc3m.es, PI:EMAIL, PI:EMAIL
ABSTRACT
Assigning family labels to malicious apps is a common practice
for grouping together malware with identical behavior. However,
recent studies show that apps labeled as belonging to the same
family do not necessarily behave similarly: one app may lack or
have extra capabilities compared to others in the same family, and,
conversely, two apps labeled as belonging to different families may
exhibit close behavior. To reveal these inconsistencies, this paper
presents AndrEnsemble, a characterization system for Android
malware families based on ensembles of sensitive API calls extracted
from aggregated call graphs of different families. Our method has
several advantages over similar characterization approaches, in-
cluding a greater reduction ratio with respect to original call graphs,
robustness against transformation attacks, and flexibility to be ap-
plied at different granularity levels. We experimentally validate our
approach and discuss three specific use cases: mobile ransomware,
SMS Trojans and banking Trojans. This left us with some inter-
esting findings. First of all, malicious operations in these types of
malware are not necessarily exercised by using several sensitive
API calls all together. Second, SMS Trojans have larger ensembles
of API calls compared to the other types. Last but not least, we
identified several samples with identical ensembles though being
labeled as part of different families.
KEYWORDS
Android Malware, Malware Analysis, Malware Classification
1 INTRODUCTION
Android is the most popular Operating System (OS) worldwide,
with a larger market share than Windows PC and Windows phone
together [1]. Android is a complex system that can integrate third-
party software from on-line markets, some of which are weakly
vetted [2]. This altogether poses several security and privacy con-
cerns. In terms of security, new attack vectors are discovered at
an unprecedented rate [3], while, in terms of privacy, apps have
access to a wide range of information they often collect in bulk [4].
Some Android apps also impact the integrity of web resources in a
negative way by manipulating them in various ways [5].
Permission to make digital or hard copies of part or all of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for third-party components of this work must be honored.
For all other uses, contact the owner/author(s).
ASIACCS’19, July 2019, Auckland, New Zealand
© 2019 Copyright held by the owner/author(s).
ACM ISBN 978-x-xxxx-xxxx-x/YY/MM.
https://doi.org/10.1145/nnnnnnn.nnnnnnn
Malicious or potentially unwanted applications are programs
purposely designed to attack the security and privacy of the devices
and their users. Moreover, Android apps are commonly hardened
with advanced anti-analysis techniques, including obfuscation [3, 6]
and packing [7], which turn their analysis into a really challenging
task. To cope with this challenge, Anti-Virus (AV) vendors and cy-
ber security firms characterize newly discovered threats, label them
with a family name, and share the specimens together with associ-
ated Indicators of Compromise (IoC) with the security community.
Labels are usually assigned based on some static information, in-
cluding code structures [8] and other IoCs which are easy to modify
using different transformation attacks [9, 10].
Despite the importance of the labeling process, AV vendors use
different criteria to name samples and families [11]. As a result, re-
cent studies have shown that not all samples associated to a family
are always related [12]. Furthermore, it is common to find the op-
posite: two apps in different families with related behaviors [13]. In
addition, the majority of the labels assigned are not consistent with
the actual behavior of apps [14] and, in most cases, each AV engine
produces a different security report and risk score for a malicious
application. Two main strategies are proposed to deal with these
inconsistencies: i) considering sub-families (or variants) to divide
families into smaller groups of apps with more akin behavior [13],
and ii) extracting a unique behavioral core from each malware fam-
ily. Both of these strategies suffer from important limitations as we
explain next.
On the one hand, methods proposed for dividing families into
sub-families are error-prone and inaccurate due to their depen-
dence on either uncontextualized features or manual inspection.
First, features extracted by related work are currently not robust
enough to address this problem as they are easy to manipulate and
bypass [15]. Second, human-dependent systems cannot keep up
with the amount of malware being processed nowadays [16–18].
Moreover, the accuracy of manual inspection has been repeatedly
questioned [19]. On the other hand, some systems are designed to
extract a semantic core from a number of Android applications [20]
or from their corresponding families [21, 22]. While promising, they
suffer from a number of limitations, including scalability issues [20],
memory complexity [21], and their excessive reliance on features
extracted from specific code structures (e.g., loops) [22].
In this paper, we propose AndrEnsemble, an approach to char-
acterize Android malware families. Unlike previous works, our
method does not rely on a precise human-vetting process, which
makes it more scalable and more suitable for learning in the pres-
ence of concept drift [23]. Also, instead of operating on a per-app
granularity, it looks at groups of apps and leverages differential anal-
ysis to extract common family behavior [24]. Thus, AndrEnsemble
is more resilient to feature perturbations and manipulations. Our
approach to build up a semantic-based core works as follows: we
first create an aggregated call graph where each node represents a
method and each edge shows an invocation between two different
methods. Methods are represented as hashes computed with a cus-
tom fuzzy hashing function. Thus, similar methods across a group
of samples are treated as a single node in the aggregated call graph.
Aggregated call graphs have fewer nodes (since common hashes
are considered as a single node) and connections as compared to
individual call graphs. Both of these improve the performance of
graph mining algorithms. Second, AndrEnsemble can deal with
repackaged apps [25] more effectively. By looking at common meth-
ods in malware, non-popular methods (typically attributed to the
original repackaged app) are discarded [24]. Additionally, a greedy
algorithm is used to mine paths from the aggregated call graph
depending on the maximum length which is justified. This makes
the method applicable at different granularity levels similar to re-
cent works [26, 27]. Each path may contain one or more calls to
sensitive API methods. Therefore, less frequent edges in a family
are also pruned to speed up the mining process.
Contributions. This work makes the following contributions:
• We propose a new characterization approach for Android
malware families based on common ensembles of sensitive
API calls. Contrarily to other related works which rely on
individual API methods, we consider ensembles of API meth-
ods that are shared by a number of samples in each family.
Also, our approach can be tuned to different granularity
levels.
• We study and report common and rare ensembles of API
methods in three types of Android malware: ransomware,
SMS Trojans and banking Trojans. We discuss real examples
for each type by linking these ensembles to apps’ behavior.
• We report some anomalies that exist in the current family
labeling of Android malware. In particular, we give examples
of apps with identical and with very similar behavior despite
belonging to different families.
2 APPROACH
This section presents our approach in detail. We first provide an
overview of our system and then describe each component in detail.
2.1 System Overview
The system proposed in this work is composed of five main steps
as depicted in Fig. 1. Given a specific Android malware family, it
first computes the fuzzy hash values (h1, h2, . . . , hn) of all extracted
methods from applications (a1, a2, . . . , an) using a number of fea-
tures (f1, f2, . . . , fn). In parallel, we obtain the method call graphs
of all apps (д1, д2, . . . , дn). Next, the method call graph of each appli-
cation is converted to a hash graph (HG), where nodes are hashes
and edges are connections between hashes, all of which are re-
constructed based on the methods connections of the method call
graph. In the third step, hash graphs of different apps are all merged
into an aggregated hash graph (AHG). We then extract paths using
graph mining algorithms and we record ensembles of sensitive API
methods (s1, s2, . . . , sn) observed in these paths. Finally, app feature
vectors (v1, v2, . . . , vn) are created based on these ensembles. These
vectors can be used as signatures to characterize family behavior.
2.2 Method Hashing (Step #1)
The first step involves computing fuzzy hash values of all methods
extracted from the apps which do belong to the same family (see
step #1 in Fig. 1). These values are used later to build call graphs
and to extract sensitive API calls which are shared among a number
of methods that resemble each other. This makes the system more
resilient to transformation attacks compared to similar systems that
rely on common sensitive API calls of identical method call graphs.
To generate a fuzzy hash value for each method (mj) we con-
sider several features, including the control flow graph signature
created by Cesare’s grammar (Gj) [28], a method’s name (Nj) and
its class name (Cj), a method’s intents (Ij), its sensitive API calls
(Sj), and, finally, native and incognito methods (Mj) found within
the method. Thus, the method hashing process is performed by ap-