clustering constraint Cc(A1, A2) evaluates to True for h1 and h2 if there exists a tuple
t1 ∈ h1 and t2 ∈ h2 such that Cc(A1, A2) is True with the attribute names in A1 and A2
replaced with the values of the corresponding attributes of t1 and t2, respectively; oth-
erwise, Cc(A1, A2) evaluates to False. For example, consider the clustering constraint
Cc(A1, A2) : (A1.SrcIP = A2.SrcIP ) ∧ (A1.DestIP = A2.DestIP ), and hyper-
alerts h1 = {(SrcIP = 129.174.142.2, SrcP ort = 1234, DestIP = 152.1.14.5,
DestP ort = 80)}, h2 = {(SrcIP = 129.174.142.2, SrcP ort = 65333, DestIP =
152.1.14.5, DestP ort = 23)}, we can easily have that Cc(A1, A2) = True for h1 and
h2. For brevity, we write Cc(h1, h2) = True if Cc(A1, A2) = True for h1 and h2.
Our clustering method is very simple with a user-speciﬁed clustering constraint
Cc(A1, A2). Two hyper-alerts h1 and h2 are in the same cluster if Cc(A1, A2) evaluates
to True for h1 and h2 (or h2 and h1). Note that Cc(h1, h2) implies that h1 and h2 are
in the same cluster, but h1 and h2 in the same cluster do not always imply Cc(h1, h2)
= True or Cc(h2, h1) = True. This is because Cc(h1, h2) ∧ Cc(h2, h3) does not imply
Cc(h1, h3), nor Cc(h3, h1).
4.4 Discussion
The alert correlation method is developed to uncover the high-level strategies behind
a sequence of attacks, not to replace the original alerts reported by an IDS. However,
as indicated by our initial experiments [7], alert correlation does provide evidence to
differentiate between alerts. If an alert is correlated with some others, it is more possible
that the alert corresponds to an actual attack.
It is desirable to develop a technique which can comprehend a hyper-alert correlation
graph and generate feedback to direct intrusion detection and response processes. We
consider such a technique as a part of our future research plan. However, given the current
status of intrusion detection and response techniques, it is also necessary to allow human
users to understand the attacks and take appropriate actions.
Analyzing Intensive Intrusion Alerts via Correlation
85
Table 1. General statistics of the initial analysis
# total hyper-alert types
# correlated hyper-alert types
# uncorrelated hyper-alert types
# partially correlated hyper-alert types 51 % correlated
115 # total hyper-alerts 65054
9744
95 # correlated
20 # uncorrelated
55310
15%
The three utilities developed in this section are intended to help human users analyze
attacks behind large amounts of alerts. They can make attack strategies behind intensive
alerts easier to understand, but cannot improve the performance of alert correlation.
5 Analyzing DEF CON 8 CTF Dataset: A Case Study
To study the effectiveness of the alert correlation method and the utilities proposed in
Section 4, we performed a series of experiments on the network trafﬁc collected at the
DEF CON 8 CTF event [10]. In our experiments, we used NetPoke1 to replay the network
trafﬁc in an isolated network monitored by a RealSecure Network Sensor 6.0 [23]. In
all the experiments, the Network Sensor was conﬁgured to use the Maximum Coverage
policy with a slight change, which forced the Network Sensor to save all the reported
alerts. Our alert correlator [7] was then used to process the alerts to discover the hyper-
alert correlation graphs. The hyper-alert correlation graphs were visualized using the
GraphViz package [24]. For the sake of readability, transitive edges are removed from
the graphs.
In these experiments, we mapped each alert type reported by the RealSecure Network
Sensor to a hyper-alert type (with the same name). The prerequisite and consequence of
each hyper-alert type were speciﬁed according to the descriptions of the attack signatures
provided with the RealSecure Network Sensor 6.0.
It would be helpful for the evaluation of our method if we could identify false alerts,
alerts for sequences of attacks, and alerts for isolated attacks. Unfortunately, due to the
nature of the dataset, we are unable to obtain any of them. Thus, in this study, we focus
on the analysis of the attack strategies reﬂected by hyper-alert correlation graphs, but
only discuss the uncorrelated alerts brieﬂy.
5.1
Initial Attempt
In our initial analysis of the DEF CON 8 CTF dataset, we tried to correlate the hyper-alerts
without reducing the complexity of any hyper-alert correlation graphs. The statistics of
the initial analysis are shown in Table 1.
Table 1 shows that only 15% alerts generated by RealSecure are correlated. In addi-
tion, 20 out of 115 hyper-alert types that appear in this data set do not have any instances
correlated. Among the remaining 95 hyper-alert types, 51 types have both correlated and
uncorrelated instances.
1 NetPoke is a utility to replay packets to a live network that were previously captured with the
tcpdump program.
http://www.ll.mit.edu/IST/ideval/tools/tools index.html
86
P. Ning, Y. Cui, and D.S. Reeves
Table 2. Statistics of top 10 uncorrelated hyper-alert types.
Hyper-alert # uncorrelated # correlated
Hyper-alert
# uncorrelated # correlated
type
IPHalfScan
HTTP Cookie
IPDuplicate
SSH Detected
ServiceScan
alerts
33745
2119
1063
731
667
alerts
958
0
0
0
2156
type
Windows Access Error
SYNFlood
PingFlood
Port Scan
Satan
alerts
11657
1306
1009
698
593
alerts
0
406
495
725
280
HTTP_MachineInfo30822
Generic_Intel_Overflow89044
Generic_Intel_Overflow31886
IPHalfScan68574
IPHalfScan68073
Generic_Intel_Overflow89032
POP_QPopAuth_Overflow89028
IPHalfScan68084
POP_QPopCommand_Overflow89039
IPHalfScan68568
POP_QPopAuth_Overflow89040
POP_QPopCommand_Overflow89027
Fig. 3. A small hyper-alert correlation discovered in initial analysis
Table 2 shows the statistics of the top 10 uncorrelated hyper-alert types (in terms
of the number of uncorrelated hyper-alerts). Among these hyper-alert types, uncorre-
lated IPHalfScan counted 61% of all uncorrelated hyper-alerts. Windows Access Error
counted 21% of all uncorrelated alerts. According to the description provided by Re-
alSecure, a Windows Access Error represents an unsuccessful ﬁle sharing connection to
a Windows or Samba server, which usually results from an attempt to brute-force a login
under another account’s privileges. It is easy to see that the corresponding attacks could
hardly prepare for any other attacks (since they failed). The third largest hyper-alert
type HTTP Cookie counted for 3.3% of the total alerts. Though such alerts have certain
privacy implications, we do not treat them as attacks, considering the nature of the DEF
CON CTF events. These three hyper-alert types counted for 74.5% of all the alerts. We
omit the discussion of the other uncorrelated hyper-alerts.
Figure 3 shows one of the small hyper-alert correlation graphs. The text in each node
is the type followed by the ID of the hyper-alert. All the hyper-alerts in this ﬁgure were
destined to the host at 010.020.001.024. All the IPHalfScan attacks were from source IP
010.020.011.240 at source port 55533 or 55534, and destined to port 110 at the victim
host. After these attacks, all the attacks in the second stage except for 31886 were from
010.020.012.093 and targeted at port 110 of the victim host. The only two hyper-alerts
that were not targeted at port 110 are hyper-alert 30882, which was destined to port 80
of the victim host, and hyper-alert 31886, which was destined to port 53. Thus, it is very
possible that all the hyper-alerts except for 30882 and 31886 were related.
Not all of the hyper-alert correlation graphs are as small and comprehensible as
Figure 3. In particular, the largest graph (in terms of the number of nodes) has 2,940
nodes and 25,321 edges, and on average, each graph has 21.75 nodes and 310.56 edges.
Analyzing Intensive Intrusion Alerts via Correlation
87
Obviously, most of the hyper-alert correlation graphs are too big to understand for a
human user.
5.2 Graph Reduction
We further analyzed the hyper-alert correlation graphs with the three utilities proposed
in Section 4. Due to space reasons, we only report our analysis results about the largest
hyper-alert correlation graph in this section.
We ﬁrst applied graph reduction utility to the hyper-alert correlation graphs. Figure
4 shows the fully reduced graph. Compared with the original graph, which has 2,940
nodes and 25,321 edges, the fully reduced graph has 77 nodes and 347 edges (including
transitive edges).
The fully reduced graph in Figure 4 shows 7 stages of attacks. The layout of this
graph was generated by GraphViz [24], which tries to reduce the number of cross edges
and make the graph more balanced. As a result, the graph does not reﬂect the actual
stages of attacks. Nevertheless, Figure 4 provides a much clearer outline of the attacks.
The hyper-alerts in stage 1 and about half of those in stage 2 correspond to scanning
attacks or attacks to gain information of the target systems (e.g., ISS, Port Scan). The
upper part of stage 2 include attacks that may lead to execution of arbitrary code on a
target system (e.g., HTTP WebSite Sample). Indeed, these hyper-alerts directly prepare
for some hyper-alerts in stage 5, but GraphViz arranged them in stage 2, possibly to
balance the graph. Stages 3 consists of a mix of scanning attacks (e.g., Nmap Scan),
attacks that reveal system information (e.g„ HTTP PHP Read), and attacks that may
lead to execution of arbitrary code (e.g., HTTP Campas). Stage 4 mainly consists of
buffer overﬂow attacks (e.g., POP QPopCommand Overﬂow), detection of backdoor
programs (e.g., BackOriﬁce), and attacks that may lead to execution of arbitrary code.
The next 3 stages are much cleaner. Stage 5 consists of attacks that may be used to copy
programs to target hosts, stage 6 consists of detection of two types of DDOS (Distributed
Denial of Service) daemon programs, and ﬁnally, stage 7 consists of the detection of an
actual DDOS attack.
Note that the fully reduce graph in Figure 4 is an approximation to the strategies
used by the attackers. Hyper-alerts for different, independent sequences of attacks may
be aggregated together in such a graph. For example, if two individual attackers use the
sequence of attacks (e.g., using the same script downloaded from a website) to attack
the same target, the corresponding hyper-alerts may be correlated and aggregated in the
same fully reduced graph. Nevertheless, a fully reduced graph can clearly outline the
attack strategies, and help a user understand the overall situation of attacks.
As we discussed earlier, the reduction of hyper-alert correlation graphs can be con-
trolled with interval constraints. Figure 5 shows the numbers of nodes and edges of the
reduced graphs for different interval sizes. The shapes of the two curves in Figure 5
indicate that most of the hyper-alerts that are of the same type occurred close to each
other in time. Thus, the numbers of nodes and edges have a deep drop for small interval
thresholds and a ﬂat tail for large ones. A reasonable guess is that some attackers tried
the same type of attacks several times before they succeeded or gave up. Due to space
reasons, we do not show these reduced graphs.
88
P. Ning, Y. Cui, and D.S. Reeves
ISS
CyberCop
_Scanner
Kerberos_
User_Snarf
HTTP_WebSite
_Sample
HTTP_Web
sendmail
FTP_Args
FTP_Root
HTTP_WebSite
_Uploader
UDP_Port_Scan
Nmap_Scan
FTP_Syst
Queso_Scan
DNS_Iquery
FTP_Pass
FTP_User
Port_Scan
FTP_Format_String
TelnetEnvAll
TelnetTerminaltype
TelnetXdisplay
HTTP_TestCgi
HTTP_WebFinger
HTTP_NphTestCgi
HTTP_Any
FormPost
HTTP_IE_BAT
HTTP_Carbo
_Server
HTTP_DotDot
HTTP_Guestbook
HTTP_Netscape
_PageServices
HTTP_ColdFusion
_SourceWindow
HTTP_ColdFusion
_FileExists
HTTP_Head
SYNFlood
FTP_Bounce
HTTP_EZMall2000
HTTP_PDGSoft
HTTP_WebStore
HTTP_Campas
HTTP_FaxSurvey
HTTP_PHF
HTTP_FormMail
HTTP_Info2WWW
HTTP_Novell_Files
HTTP_PHP_Read
HTTP_Cdomain
HTTP_MachineInfo
HTTP_Cachemgr
IPHalfScan
ServiceScan
Sun_SNMP
_Backdoor
HP_OpenView
_SNMP_Backdoor
Cisco_Syslog_DoS
SNMP_Set
HTTP_Unix
_Passwords
FTP_Privi
legedBounce
FTP_Privi
legedPort
BackOrifice
NetBus
HTTP_ColdFusion
_Admin
PmapDump
HTTP_Shells
HTTP_BAT
_Execute
HTTP_SGI_Wrap
Generic_Intel
_Overflow
HTTP_Cold
_Fusion
POP_QPop
Command_Overflow
POP_QPop
Auth_Overflow
HTTP_ColdFusion
_ViewExample
HTTP_Site