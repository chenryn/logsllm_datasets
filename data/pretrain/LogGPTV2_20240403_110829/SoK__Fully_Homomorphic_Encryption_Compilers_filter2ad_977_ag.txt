encryption accessible to all,” in Proceedings of the 6th Workshop on
Encrypted Computing & Applied Homomorphic Cryptography. ACM,
Oct. 2018, pp. 49–60. [Online]. Available: https://dl.acm.org/citation.
cfm?doid=3267973.3267978
[51] S. Carpov, P. Dubrulle, and R. Sirdey, “Armadillo: A compilation
chain for privacy preserving applications,” in Proceedings of the 3rd
International Workshop on Security in Cloud Computing, ser. SCC ’15.
New York, NY, USA: ACM, 2015, pp. 13–19. [Online]. Available:
http://doi.acm.org/10.1145/2732516.2732520
[52] E. Crockett and C. Peikert, “Λoλ: Functional lattice cryptography,”
in Proceedings of the 2016 ACM SIGSAC Conference on Computer and
Communications Security. ACM, 2016, pp. 993–1005.
[Online].
Available: https://dl.acm.org/doi/abs/10.1145/2976749.2978402
[53] I. Chillotti, M.
Joye, D. Ligier,
operates
and S. Tap,
by
“CONCRETE: Concrete
in WAHC 2020 – 8th Workshop on Encrypted
extending TfhE,”
Computing & Applied Homomorphic Cryptography, 15 Dec. 2020.
[Online]. Available:
https://homomorphicencryption.org/wp-content/
uploads/2020/12/wahc20 demo damien.pdf
J.-B. Orﬁla,
on
ciphertexts
rapidly
[54] L. Ducas and D. Micciancio, “FHEW: Bootstrapping homomorphic
encryption in less than a second,” in Advances in Cryptology –
EUROCRYPT 2015. Springer Berlin Heidelberg, 2015, pp. 617–640.
[Online]. Available: http://dx.doi.org/10.1007/978-3-662-46800-5 24
[55] CryptoExperts, “FV-NFLlib,” May 2016. [Online]. Available: https:
//github.com/CryptoExperts/FV-NFLlib
[56] S. Halevi and V. Shoup, “Algorithms
in HElib,” in Advances
in Cryptology – CRYPTO 2014,
in Computer
Springer, Berlin,
Science,
Heidelberg / Springer, Aug. 2014, pp. 554–571. [Online]. Available:
http://link.springer.com/chapter/10.1007/978-3-662-44371-2 31
J. A. Garay and R. Gennaro, Eds.
ser. Lecture Notes
[57] C. Mouchet and J.-P. Bossuat, “Lattigo: A multiparty homomorphic
in WAHC 2020 – 8th Workshop on
encryption
Encrypted Computing & Applied Homomorphic Cryptography, 15 Dec.
2020.
https://homomorphicencryption.org/wp-
content/uploads/2020/12/wahc20 demo christian.pdf
[Online]. Available:
library
go,”
[58] Y. Polyakov, K. Rohloff, and G. W. Ryan, “PALISADE Lattice
Cryptography Library User Manual (v1.6.0),” Tech. Rep., Sep. 2019.
[Online]. Available: https://palisade-crypto.org/documentation
in
[59] Vernam Group, “cuFHE,” Mar. 2018.
[Online]. Available: https:
[60] NuCypher, “nufhe,” 19 Jul. 2019. [Online]. Available: https://github.
//github.com/vernamlab/cuFHE
com/nucypher/nufhe
[61] V. Shoup and Others, “NTL: A library for doing number theory,” Aug.
2016. [Online]. Available: http://www.shoup.net/ntl/
[62] S. Halevi and V. Shoup, “Bootstrapping for HElib,” in Advances
in Cryptology – EUROCRYPT 2015, ser. Lecture Notes in Computer
Science, E. Oswald and M. Fischlin, Eds., Springer. Springer, Berlin,
Heidelberg / Springer, Apr. 2015, pp. 641–670. [Online]. Available:
http://link.springer.com/chapter/10.1007/978-3-662-46800-5 25
[63] ——, “HElib design principles,” Tech. Rep., 2020. [Online]. Avail-
able: https://homenc.github.io/HElib/documentation/Design Document/
HElib-design.pdf
[64] R. Player, “Parameter selection in lattice-based cryptography,” Ph.D.
dissertation, PhD thesis, Royal Holloway, University of London,
2018. [Online]. Available: https://pure.royalholloway.ac.uk/portal/ﬁles/
29983580/2018playerrphd.pdf
[65] E. Chielle, O. Mazonka, N. G. Tsoutsos, and M. Maniatakos, “E3: A
Framework for Compiling C++ Programs with Encrypted Operands,”
IACR Cryptology ePrint Archive, vol. 2018, p. 1013, 2018. [Online].
Available: https://eprint.iacr.org/2018/1013
[66] D. W. Archer, J. M. Calder´on Trilla, J. Dagit, A. Malozemoff,
Y. Polyakov, K. Rohloff, and G. Ryan, “RAMPARTS: A Programmer-
Friendly system for building homomorphic encryption applications,”
in Proceedings of the 7th ACM Workshop on Encrypted Computing &
Applied Homomorphic Cryptography - WAHC’19. New York, New
York, USA: ACM Press, 2019, pp. 57–68.
[Online]. Available:
http://dl.acm.org/citation.cfm?doid=3338469.3358945
[67] R. Dathathri, O. Saarikivi, H. Chen, K. Laine, K. Lauter, S. Maleki,
M. Musuvathi, and T. Mytkowicz, “CHET: an optimizing compiler
for fully-homomorphic neural-network inferencing,” in Proceedings of
the 40th ACM SIGPLAN Conference on Programming Language Design
and Implementation. New York, NY, USA: ACM, 8 Jun. 2019, pp. 142–
156. [Online]. Available: https://dl.acm.org/citation.cfm?doid=3314221.
3314628
[68] T. van Elsloo, G. Patrini, and H. Ivey-Law, “SEALion: A Framework
for Neural Network Inference on Encrypted Data,” arXiv preprint
arXiv:1904.12840, 2019. [Online]. Available: https://arxiv.org/abs/1904.
12840
[69] E. Crockett, “Simply safe lattice cryptography,” Ph.D. dissertation,
[Online]. Available: https:
Georgia Institute of Technology, 2017.
//smartech.gatech.edu/handle/1853/58734
[70] V. Herbert, “Automatize parameter
tuning in Ring-Learning-With-
Errors-based leveled homomorphic cryptosystem implementations,”
2019. [Online]. Available: https://eprint.iacr.org/2019/1402
[71] A. Mishchenko, “ABC: System for sequential logic synthesis and formal
[Online]. Available: https://github.com/berkeley-
veriﬁcation,” 2018.
abc/abc
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:31:21 UTC from IEEE Xplore.  Restrictions apply. 
1106
[72] S. Carpov, P. Aubry, and R. Sirdey, “A multi-start heuristic for
multiplicative depth minimization of boolean circuits,” in International
Workshop on Combinatorial Algorithms.
Springer, 2017, pp. 275–
286. [Online]. Available: https://link.springer.com/chapter/10.1007/978-
3-319-78825-8 23
[73] P. Aubry, S. Carpov, and R. Sirdey, “Faster homomorphic encryption is
not enough: Improved heuristic for multiplicative depth minimization
of boolean circuits,” in Topics in Cryptology – CT-RSA 2020. Springer
International Publishing, 2020, pp. 345–363.
[Online]. Available:
http://dx.doi.org/10.1007/978-3-030-40186-3 15
[74] D. Lee, W. Lee, H. Oh, and K. Yi, “Optimizing homomorphic
evaluation circuits by program synthesis and term rewriting,” in
Proceedings of the 41st ACM SIGPLAN Conference on Programming
Language Design and Implementation, ser. PLDI 2020. New York,
NY, USA: Association for Computing Machinery, Nov. 2020, pp.
503–518. [Online]. Available: https://doi.org/10.1145/3385412.3385996
[75] F. Boemer, Y. Lao, R. Cammarota, and C. Wierzynski, “nGraph-HE:
A Graph Compiler for Deep Learning on Homomorphically Encrypted
Data,” in Proceedings of the 16th ACM International Conference on
Computing Frontiers, ser. CF ’19. New York, NY, USA: ACM, 2019,
pp. 3–13. [Online]. Available: https://dl.acm.org/doi/10.1145/3310273.
3323047
[76] S. Cyphers, A. K. Bansal, A. Bhiwandiwalla, J. Bobba, M. Brookhart,
A. Chakraborty, W. Constable, C. Convey, L. Cook, O. Kanawi et al.,
“Intel nGraph: An intermediate representation, compiler, and executor
for deep learning,” arXiv preprint arXiv:1801.08058, 2018. [Online].
Available: https://arxiv.org/abs/1801.08058
[77] S. Carpov, T. H. Nguyen, R. Sirdey, G. Constantino, and F. Martinelli,
“Practical Privacy-Preserving medical diagnosis using homomorphic
in 2016 IEEE 9th International Conference on Cloud
encryption,”
Computing (CLOUD), Jun. 2016, pp. 593–599. [Online]. Available:
http://dx.doi.org/10.1109/CLOUD.2016.0084
[78] Y. LeCun and C. Cortes, “MNIST handwritten digit database,” 2010.
[Online]. Available: http://yann.lecun.com/exdb/mnist/
[79] R. Gilad-Bachrach, N. Dowlin, K. Laine, K. Lauter, M. Naehrig,
and J. Wernsing, “CryptoNets: Applying neural networks to encrypted
data with high throughput and accuracy,” in Proceedings of the 33rd
International Conference on Machine Learning, vol. 48. New York,
New York, USA: PMLR, 2016, pp. 201–210. [Online]. Available:
http://proceedings.mlr.press/v48/gilad-bachrach16.html
[80] Y. LeCun, L. Bottou, Y. Bengio, and P. Haffner, “Gradient-
based learning applied to document recognition,” Proceedings of the
IEEE, vol. 86, no. 11, pp. 2278–2324, 1998. [Online]. Available:
https://ieeexplore.ieee.org/document/726791
[81] J. E. Savage, Models of Computation: Exploring the Power of Comput-
ing, 1st ed. Boston, MA, USA: Addison-Wesley Longman Publishing
Co., Inc., 1997.
[82] I. Chillotti, N. Gama, M. Georgieva, and M. Izabach`ene, “TFHE:
Fast fully homomorphic encryption over the torus,” 2018. [Online].
Available: https://eprint.iacr.org/2018/421
[83] J. H. Cheon, S. Hong, and D. Kim, “Remark on the security of ckks
scheme in practice,” Cryptology ePrint Archive, Report 2020/1581,
2020, https://eprint.iacr.org/2020/1581.
[84] B. Li and D. Micciancio, “On the security of homomorphic encryp-
tion on approximate numbers,” Cryptology ePrint Archive, Report
2020/1533, 2020, https://eprint.iacr.org/2020/1533.
[85] J. H. Cheon, K. Han, A. Kim, M. Kim, and Y. Song, “A full RNS
variant of approximate homomorphic encryption,” in Selected Areas in
Cryptography – SAC 2018.
Springer International Publishing, 2019,
pp. 347–368. [Online]. Available: http://dx.doi.org/10.1007/978-3-030-
10970-7 16
APPENDIX A
In this appendix, we brieﬂy introduce the notion of FHE and
outline three important modern schemes. We focus primarily
on aspects relevant to FHE application developers, i.e., plain-
text spaces, encodings, and aspects that impact performance.
A. Fully Homomorphic Encryption
A homomorphic encryption scheme is a (most frequently
public-key) encryption scheme where there exists a homomor-
phism between operations on the plaintext and operations on
the ciphertext:
Dec(Enc(x + y)) = Dec(Enc(x) ⊕ Enc(y))
where + and ⊕ are operations over the plaintext and ciphertext
space, respectively. A fully homomorphic encryption scheme
is one that is homomorphic in regards to both addition and
multiplication. We omit a more formal treatment here and
instead refer to [11] for a formal deﬁnition, including several
constraints that apply to exclude trivial constructions.
Addition and multiplication allow us to compute any poly-
nomial function over the encrypted data but many frequently-
used functions like comparisons or sorting are non-polynomial,
i.e., cannot (easily) be expressed as polynomial functions.
However, multiplication and addition in Z2 can be used to
emulate AND- and XOR-gates, respectively. Together with
memory, this is Turing-complete, i.e., one can emulate arbi-
trary computations [81].
B. FHE Schemes
We brieﬂy introduce three of the most widely used homo-
morphic encryption schemes.
The
1) CGGI:
Chillotti-Gama-Georgieva-Izabachene
scheme [38], [39] is part of a third generation of FHE schemes
based on the Gentry-Sahai-Waters (GSW) scheme [37]. More
commonly known as TFHE, we refer to it here by the author
initials in order to avoid confusion with the TFHE library.
In CGGI, the plaintext and ciphertext space T is a group of
polynomials (modulo some irreducible polynomial) of degree
up to n − 1 over the torus T = R/Z (i.e., the real num-
bers mod 1). The message space is generally chosen so that
the computation emulates binary circuits and homomorphic
addition becomes XOR and multiplication becomes AND.
Since T is not a ring, it supports addition but has no native
multiplication operation. However, multiplications are deﬁned
between GSW ciphertexts and ciphertexts in T . This is used
to perform multiplications and non-linear operations over ci-
phertexts in T during the bootstrapping process, by encrypting
the bootstrapping key as a GSW ciphertext. Multiplications
between ciphertexts in T are realized as one speciﬁc type of
such a non-linear transformation applied during bootstrapping.
In this gate-bootstrapped version of the scheme, every non-
linear gate therefore inherently includes bootstrapping.
Chillotti et al. also show how to construct a MUX gate
that selects between two ciphertexts in T dependent on a
GSW ciphertext and introduce efﬁcient designs for Look-Up-
Tables (LUTs). Finally, they show how to use weighted Finite
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:31:21 UTC from IEEE Xplore.  Restrictions apply. 
1107
2) BFV: The Brakerski/Fan-Vercauteren
scheme is a
second-generation scheme. Fan and Vercauteren [32] ported
a scheme by Brakerski [33] to the ring-LWE domain and
improved its performance. In BFV, the plaintext space Rt is
a ring of polynomials (modulo some irreducible polynomial)
of degree up to n − 1 with coefﬁcients in Zt. Note that
for t = 2, we are in the binary circuit setting. Messages
m ∈ Zt can be encoded into this plaintext space as a constant
polynomial f (x) = m. However, this is inefﬁcient as only
one of n coefﬁcients is utilized. Simply encoding messages
into additional coefﬁcients raises issues when performing
computations: while polynomial additions work coefﬁcient-
wise, multiplications combine different coefﬁcients in un-
desired ways. Instead, one can achieve SIMD-style batch-
ing via the Chinese Remainder Theorem [34]. By choosing
i=0ni , a degree-n polynomial can be reinterpreted as
n = Πk
the multiplication of k lower-degree polynomials. Using this
technique, k messages can be packed into a single plaintext,
where k (cid:29) 1000 in practice, while maintaining meaningful
semantics. Automorphisms additionally enable homomorphic
rotations of the elements [35].
Automata to emulate binary multiplication [82]. However,
these techniques are not implemented in the TFHE library.
The ciphertexts, meanwhile, are made up of at elements
from Rq, which has the same structure as Rp, but with a
different coefﬁcient modulus q. Each ciphertexts consists of
at least two elements, i.e., c = [c0, c1]. These polynomials ci
can themselves be interpreted as coefﬁcients of a polynomial
3) CKKS: The Cheon-Kim-Kim-Song scheme [36], also
known as Homomorphic Encryption for Arithmetic of Approx-
imate Numbers (HEAAN), focuses on homomorphic encryp-
tion for approximate numbers. Formally speaking it is not an
FHE scheme since it only fulﬁlls the requirements approxi-
mately, i.e., Dec(Enc(x + y)) ≈ Dec(Enc(x) ⊕ Enc(y)), for
some operations + and ⊕. While this slight relaxation has led
to an extremely efﬁcient scheme, some care must be taken
when using approximate FHE schemes [83], [84]. CKKS is
designed primarily for computations with ﬁxed point numbers,
i.e., a number x is represented as m = (cid:98)x ∗ ∆(cid:101) for scale
∆, usually a large integer. While any integer-based scheme
can be used for ﬁxed-point computations, they quickly run
into overﬂow issues. CKKS addresses this by introducing a
homomorphic rounding operation that reduces the scale of a
product back to the original scale ∆.
C(X). Homomorphic addition and multiplication between
ciphertexts correspond to addition and multiplication between
the C(X)’s, respectively. As a consequence, the result of a
multiplication is a quadratic polynomial, i.e., a ciphertext with
three elements c = [c0, c1, c2]. During further multiplications
the noise term would ﬁrst become squared, then cubed, etc.
growing excessively. Therefore, BFV and similar schemes
introduce a relinearization procedure to transform ciphertexts
back to linear form. We omit a description of bootstrapping
and instead note that BFV is more commonly used in leveled
mode where the parameters are chosen sufﬁciently large to
complete the computation without bootstrapping.
In CKKS, the logical message space is Cn, i.e., vectors over
the complex numbers, although most applications use only the
real part. The plaintext space R is a ring of polynomials (mod-
ulo some irreducible polynomial) of degree up to n − 1 with
coefﬁcients in Z. Given a scaling factor ∆ ∈ R, we represent
m ∈ R as m(cid:48) = (cid:98)∆m(cid:101) ∈ Z. For brevity, we skip a description
of the encoding of such representations into a plaintext poly-
nomial and simply note that the encoding introduces small
additional approximation errors. During encryption, noise is
intentionally introduced, but this noise overlaps with the least
signiﬁcant bits of the plaintext. Therefore, the approximation
error and noise are treated as one, and rather than suddenly
losing the message when the noise reaches a threshold, we
gradually lose accuracy.
Like in BFV, ciphertexts in CKKS are arrays of elements
ci ∈ Rq and multiplications require relinearization. However,
different to BFV, the noise e grows quadratically with each
subsequent multiplication. After (cid:96) multiplications, it has grown
to e2(cid:96) and a modulus q ≈ e2(cid:96) would be required to decrypt
the resulting ciphertext correctly. Instead, one can scale the
ciphertext down by a factor ω, i.e., go from Rq to Rq/ω.
This is known as rescaling and is similar to the modulus
switching operation in the Brakerski-Gentry-Vaikuntanathan
(BGV) scheme [31] but rescaling also affects the plaintext.
Using rescaling, a modulus of size ((cid:96) + 1)ωe sufﬁces to
evaluate (cid:96) subsequent multiplications. During this operation,
the plaintext encrypted in the ciphertext is also effectively
rescaled to ∆(cid:48) = (cid:98)∆/ω(cid:101). Choosing q = Πk
i=0qi where qi are
roughly equally sized primes improves both performance [85]
and, by setting ω = qi, ensures a (nearly) constant scale
throughout the computation.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:31:21 UTC from IEEE Xplore.  Restrictions apply. 
1108