these two games can be reduced to IND-CPA security of the sym-
metric encryption. That is, there exists an efficient adversary B2,
such that Pr[G2 = 1] − Pr[G1 = 1] ≤ poly(λ) · AdvIND−CPA
Game3: in this game BF and xtoken are generated in an alterna-
tive but equivalent way, which is shown in Algorithm 5. Loosely
speaking, all possible values gfX (w)fI(id) for each identifier id ∈
DB(w) and keyword w ∈ W are pre-computed and stored in an
array A. Moreover, some xtoken values in transcripts, which corre-
spond to impossible matches, are generated and stored in another
array B.
Then arrays A and B are used to compute BF and xtoken. In
particular, for a given w and id ∈ DB(w) the element A[w, id]
instead of gfX (w)fI(id) is added to BF. Note that A[w, id] is exactly
B2,Sym (λ).
Algorithm 3 : Game0
(idi , Wi)d
for w ∈ W do
i =1 ← DB; κS , κI , κZ , κX
( ¯id1 , . . . , ¯idTw ) ← DB(w); σ
t ← {}; κe ← F(κS , w)
for c = 1 : Tw do
$←− {0, 1}λ
$←− Perm([Tw]); WPerms[w] ← σ
xid ← Fp(κI , ¯idσ(c)); e = Sym.Enc(κe , ¯idσ(c))
z ← Fp(κZ , w ||c); y ← xid · z−1 (mod p); t[c] ← (y , e)
end for
T[w] ← t
end for
(TSet, κT ) ← TSet.Setup(T)
for i = 1 : Q do STags[i] ← TSet.GenTag(κT , s[i]) end for
BF ← 0m
for w ∈ W do
η ← Fp(κX , w)
for id ∈ DB(w) do
xid ← Fp(κI , id)
for j = 1 : k do
hj(id, w) ← Hj
end for
end for
(cid:16)
дη·xid(cid:17) ; BF[hj(id, w)] ← 1
end for
c ← HVE.Enc(msk , µ = ‘True’, BF); EDB ← (TSet, c)
for i = 1 : Q do
t ← TSet.Retrieve(EDB(1), STags[i]); E[i] ← {}
for c = 1 : T do
(yc , ec) ← t; zc ← Fp(κZ , s[i]||c); vc ← ∗m
for ℓ = 2 : n do
ηℓ ← Fp(κX , xℓ[i]); xtoken[c , ℓ] ← дzc ·ηℓ
for j = 1 : k do vc[Hj (xtoken[c , ℓ]yc )] = 1 end for
end for
tokenc[i] ← HVE.KeyGen(msk , vc)
resc[i] ← HVE.Query(tokenc[i], ec)
if resc[i] = True then
E[i] ← E[i] ∪ {ec }
end if
Res ← E[i]; ResInds ← DB(s[i]) ∩n
end for
tr[i] ← (Res, ResInds, ((STags[i], xtoken[i], token[i])))
ℓ=2 DB(xℓ[i])
end for
return (EDB, tr)
the value gfX (w)fI(id), so BF is the same as in previous game. In
addition, it is easy to see that the transcript tr[i] will be the same
only if xtoken[i] and token[i] are the same in both games. We
note that token[i] depends on xtoken[i], so we only focus on the
generation of xtoken[i] array in the following.
In Game2, the xtoken[c, ℓ] for the ℓ-th xterm xℓ[i] (of the i-
th query) and c ∈ [T] is set to be gfZ (s[i]||c)·fX (xℓ[i]). In the cur-
rent game, however, xtoken[c, ℓ] is generated by first looking up
DB[s[i]] = ( ¯id1, . . . , ¯idTs), WPerms[s[i]] = σ and t, where t =
(fI( ¯idσ(c))/fZ(s[i]||c), ec)c∈[Ts] by the correctness of TSet. Then
for c ∈ [Ts] and ℓ ∈ [2, n], it retrieves (yc , ec), such that yc =
fI( ¯idσ(c))/fZ(s[i]||c), and sets xtoken[c, ℓ] to be A[ ¯idσ(c), xℓ[i]]1/yc =
gfZ (s[i]||c)·fX (xℓ[i]). For c ∈ [T] \ [Ts], xtoken[c, ℓ] is set to be
B[s[i], xℓ[i], c] = gfX (xℓ[i])·fZ (s[i]||c).
It is easy to observe from the above that the xtoken[c, ℓ] is exactly
the same as in Game2. Therefore, we have Pr[G3 = 1] = Pr[G2 = 1].
Game4: this game is almost identical to the previous one, except
that the single boxed code in Algorithm 5 is also included: the values
y are now drawn randomly from Z∗
p. Due to the modifications made
in Game3, the random function fZ is chosen during the first steps of
the algorithm and never evaluated again later, so z is uniformly and
independently distributed. Moreover, since y = xid · z−1, for any
w ∈ W and c ∈ [Tw], the value of y is also uniform and independent
of the rest of the randomness in the game. Thus replacing y with
Algorithm 4 : Game1 and Game2
(idi , Wi)d
for w ∈ W do
i =1 ← DB; fS , fI , fZ , fX
( ¯id1 , . . . , ¯idTw ) ← DB(w); σ
t ← {}; κe
for c = 1 : Tw do
$←− {0, 1}λ
$←− Func({0, 1}λ , Z∗
p)
$←− Perm([Tw]); WPerms[w] ← σ
xid ← fI ( ¯idσ(c)); e = Sym.Enc(κe , ¯idσ(c))
e = Sym.Enc(κe , 0λ)
z ← fZ (w ||c); y ← xid · z−1 (mod p); t[c] ← (y , e)
end for
T[w] ← t
end for
(TSet, κT ) ← TSet.Setup(T)
for i = 1 : Q do STags[i] ← TSet.GenTag(κT , s[i]) end for
BF ← 0m
for w ∈ W do
η ← fX (w)
for id ∈ DB(w) do
xid ← fI (id)
for j = 1 : k do
(cid:16)
дη·xid(cid:17) ; BF[hj(id, w)] ← 1
hj(id, w) ← Hj
end for
end for
end for
c ← HVE.Enc(msk , µ = ‘True’, BF); EDB ← (TSet, c)
for i = 1 : Q do
t ← TSet.Retrieve(EDB(1), STags[i]); E[i] ← {}
for c = 1 : T do
(yc , ec) ← t; zc ← fZ (s[i]||c); vc ← ∗m
for ℓ = 2 : n do
ηℓ ← fX (xℓ[i]); xtoken[c , ℓ] ← дzc ·ηℓ
for j = 1 : k do vc[Hj (xtoken[c , ℓ]yc )] = 1 end for
end for
tokenc[i] ← HVE.KeyGen(msk , vc)
resc[i] ← HVE.Query(tokenc[i], ec)
if resc[i] = True then
E[i] ← E[i] ∪ {ec }
end if
Res ← E[i]; ResInds ← DB(s[i]) ∩n
end for
tr[i] ← (Res, ResInds, ((STags[i], xtoken[i], token[i])))
ℓ=2 DB(xℓ[i])
end for
return (EDB, tr)
G,B3(λ).
random values does not affect the distribution of the resulted game,
so we have Pr[G4 = 1] = Pr[G3 = 1].
Game5: this game is similar to the previous game, except that it
also includes the doubly boxed code in Algorithm 5. That is, all the
values of A and B arrays are selected at random from G. Under the
DDH assumption, there exists an efficient algorithm B3 such that
Pr[G5 = 1] − Pr[G4 = 1] ≤ AdvDDH
To show the indistinguishability between these two games, a
simple reduction can be conducted similarly as in [12]. Briefly
speaking, the values of X array in G4 are the ga values, and the X
values are raised to the power of xid when computing A and to the
power of fZ(w||c) when computing B, where xid and fZ(w||c) act
as the b values of the DDH tuple. Thus, A and B in G4 have values
of the form gab, while in G5 they are replaced with random values.
Differentiating between them can be easily reduced to breaking the
DDH assumption, we omit the details here.
Game6: in this game TSet is generated by using simulator ST ,
which is shown in Algorithm 6. The existence of such a simulator is
guaranteed by the security notion of T-Sets. In addition, we remove
some irrelevant code (some selecting random functions) and other
routines remained the same as G5. Similar to the analysis shown
Algorithm 5 : Game3, Game4 , and Game5
i =1 ← DB; fS , fI , fZ , fX
$←− Func({0, 1}λ , Z∗
p)
(idi , Wi)d
for w ∈ W do
for id ∈ DB(w) do
η ← fX (w); X[w] ← дη ; xid ← fI (id); A[w , id] ← X[w]xid
A[w , id] $←− G
$←− Perm([Tw]); WPerms[w] ← σ
end for
end for
for w ∈ W do
( ¯id1 , . . . , ¯idTw ) ← DB(w); σ
t ← {}; κe
for c = 1 : Tw do
$←− {0, 1}λ
xid ← fI ( ¯idσ(c)); e = Sym.Enc(κe , 0λ)
z ← fZ (w ||c); y ← xid · z−1 (mod p)
y
t[c] ← (y , e)
$←− Z∗
p
end for
T[w] ← t
for u ∈ W \ {w } do
for c = Tw + 1, . . . , T do
B[w , u , c] ← X[u]fZ (w||c)
B[w , u , c] $←− G
end for
end for
end for
(TSet, κT ) ← TSet.Setup(T)
for i = 1 : Q do STags[i] ← TSet.GenTag(κT , s[i]) end for
BF ← 0m
for w ∈ W do
hj(id, w) ← Hj (A[w , id]) ; BF[hj(id, w)] ← 1
for id ∈ DB(w) do
for j = 1 : k do
end for
end for
end for
c ← HVE.Enc(msk , µ = ‘True’, BF); EDB ← (TSet, c)
for i = 1 : Q do
t ← TSet.Retrieve(EDB(1), STags[i]); E[i] ← {}
( ¯id1 , . . . , ¯idTs ) ← DB[s[i]]; σ ← WPerms[s[i]]
for c = 1 : T do
vc ← ∗m
for ℓ = 2 : n do
if c ≤ Ts then
else
(yc , ec) ← t[c]; xtoken[c , ℓ] ← A[ ¯idσ(c) , xℓ[i]]1/yc
xtoken[c , ℓ] ← B[s[i], xℓ[i], c]
end if
for j = 1 : k do vc[Hj (xtoken[c , ℓ]yc )] = 1 end for
end for
tokenc[i] ← HVE.KeyGen(msk , vc)
resc[i] ← HVE.Query(tokenc[i], ec)
if resc[i] = True then
E[i] ← E[i] ∪ {ec }
end if
Res ← E[i]; ResInds ← DB(s[i]) ∩n
end for
tr[i] ← (Res, ResInds, ((STags[i], xtoken[i], token[i])))
ℓ=2 DB(xℓ[i])
end for
return (EDB, tr)
in [12], there exists an efficient algorithm B4, under the security
definition of TSet, such that Pr[G6 = 1] − Pr[G5 = 1] ≤ AdvTSetB4 (λ).
Game7: this game is like the previous one, except that the boxed
codes are also included in Algorithm 6. In this game, the second
part of EDB (i.e., EDB(2) = c) and the search tokens token[i] are
generated by running the simulator SHVE of HVE. To show the
indistinguishability between Game7 and Game6, we let α(vc) =
[m] \ {Hj[xtoken[c, ℓ]yc]}j∈[1,k]
(BF). Now
ℓ∈[2,n] and β(vc , BF) = P HVE
vc
p ; t[c]←(y , e) end for
i =1 ← DB
Algorithm 6 : Game6 and Game7
(idi , Wi)d
for w ∈ W and id ∈ DB(w) do A[w , id] $←− G end for
for w ∈ s do WPerms[w] ← Perm([Ts]) end for
for w ∈ W do
t ← {}; κe
for c =1:Tw do e =Sym.Enc(κe , 0λ); y
T[w] ← t
for u ∈ W \ {w } do
$←− {0, 1}λ
$←− Z∗
for c = Tw + 1, . . . , T do B[w , u , c] $←− G end for
end for
end for
(TSet, STags) ← ST (LT (DB, s), T[s])
BF ← 0m
for w ∈ W do
for id ∈ DB(w) do
for j = 1 : k do
hj(id, w) ← Hj (A[w , id]) ; BF[hj(id, w)] ← 1
end for
end for
end for
c ← HVE.Enc(msk , µ = ‘True’, BF); EDB ← (TSet, c)
c ← SHVE(µ = ‘True’)
for i = 1 : Q do
t ← TSet.Retrieve(EDB(1), STags[i]); E[i] ← {}
( ¯id1 , . . . , ¯idTs ) ← DB(s[i]); σ ← WPerms[s[i]]
for c = 1 : T do
vc ← ∗m
for ℓ = 2 : n do
if c ≤ Ts then
if ¯idσ(c) ∈ DB(s[i]) ∩n
(yc , ec) ← t[c]
(BF) = 1
P HVE
vc
else // β(vc , BF) = 0 ⇐ P HVE
vc
xtoken[c , ℓ] ← A[ ¯idσ(c) , xℓ[i]]1/yc
(BF) = 0