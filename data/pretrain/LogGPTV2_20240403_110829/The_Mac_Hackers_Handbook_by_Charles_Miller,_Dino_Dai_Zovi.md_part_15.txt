Luckily, this mechanism is easily circumvented. In Chapter 12, “Rootkits,”
we’ll show you a method which could be used to defeat it using kernel modules.
For now we can use GDB manually. The basic idea is to ensure that iTunes never
(successfully) calls ptrace() with the PT_DENY_ATTACH request. We’ll inter-
cept this function call in the debugger and make sure that when the parameter
PT_DENY_ATTACH is passed; the function doesn’t do anything. To accomplish
this goal, make sure iTunes isn’t running, start up GDB, and set a conditional
breakpoint at ptrace(). (Really, this is overkill, because iTunes has no business
calling ptrace(), but better safe than sorry.) Then, when it hits, have GDB make
the function return without actually executing. Place these commands in a
GDB init fi le.
break ptrace
condition 1 *((unsigned int *) ($esp + 4)) == 0x1f
commands 1
return
c
end
9955336633cc0044..iinndddd 110099 11//2255//0099 44::4400::4477 PPMM
110 Part II ■ Discovering Vulnerabilities
You simply set a breakpoint at ptrace, and when it is hit you tell GDB to return
to the previous function in the call chain, thus not executing the ptrace code.
After starting iTunes, you can safely detach from the process and debug/trace
to your heart’s content.
$ gdb /Applications/iTunes.app/Contents/MacOS/iTunes
GNU gdb 6.3.50-20050815 (Apple version gdb-768) (Tue Oct 2 04:07:49 UTC
2007)
Copyright 2004 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you
are
welcome to change it and/or distribute copies of it under certain
conditions.
Type “show copying” to see the conditions.
There is absolutely no warranty for GDB. Type “show warranty” for
details.
This GDB was configured as “i386-apple-
darwin”…/Users/cmiller/.gdbinit:2: Error in sourced command file:
No symbol table is loaded. Use the “file” command.
Reading symbols for shared libraries ........................ done
(gdb) source itunes.gdb
Breakpoint 1 at 0xf493b24
(gdb) run
Starting program: /Applications/iTunes.app/Contents/MacOS/iTunes
Reading symbols for shared libraries
+++++++++++++++++++++++.................................................
................................ done
Breakpoint 1 at 0x960ebb24
Breakpoint 1, 0x960ebb24 in ptrace ()
Reading symbols for shared libraries .. done
Reading symbols for shared libraries . done
Reading symbols for shared libraries . done
…
^C
Program received signal SIGINT, Interrupt.
0x960b04a6 in mach_msg_trap ()
(gdb) detach
Detaching from program:
`/Applications/iTunes.app/Contents/MacOS/iTunes’, process 6340 local
thread 0x2d03.
Notice how the breakpoint is hit early in the processes lifetime. You now
have a running iTunes and it doesn’t have the evil P_LNOTRACE fl ag set. This
means you can attach to it again at your leisure.
$ gdb -p 3757
GNU gdb 6.3.50-20050815 (Apple version gdb-768) (Tue Oct 2 04:07:49 UTC
2007)
9955336633cc0044..iinndddd 111100 11//2255//0099 44::4400::4477 PPMM
Chapter 4 ■ Tracing and Debugging 111
Copyright 2004 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you
are
welcome to change it and/or distribute copies of it under certain
conditions.
Type “show copying” to see the conditions.
There is absolutely no warranty for GDB. Type “show warranty” for
details.
This GDB was configured as “i386-apple-
darwin”./Users/cmiller/.gdbinit:2: Error in sourced command file:
No symbol table is loaded. Use the “file” command.
/Users/cmiller/Desktop/3757: No such file or directory.
Attaching to process 3757.
Reading symbols for shared libraries . done
Reading symbols for shared libraries
.......................................................................
......................................................................
done
0x967359e6 in mach_msg_trap ()
(gdb)
DTrace works as well now, as apparently iTunes is displaying an episode of
Chuck from Season 1:
$ sudo dtrace -qs filemon.d 3757
open(/dev/autofs_nowait) = 20
open(/System/Library/Keyboard
Layouts/AppleKeyboardLayouts.bundle/Contents/Info.plist) = 21
close(21)
close(20)
open(/dev/autofs_nowait) = 20
open(/System/Library/Keyboard
Layouts/AppleKeyboardLayouts.bundle/Contents/Resources/English.lproj/
InfoPlist.strings) = 21
close(21)
close(20)
close(20)
open(/.vol/234881026/6117526/07 Chuck Versus the Alma Mater.m4v)
= 20
Order is restored to the universe.
Conclusion
Before diving in to learn about exploitation techniques, it is important to know
how to dig into the internals of applications. We discussed GDB and ptrace on
Mac OS X and how it differs from more-common implementations. We then
9955336633cc0044..iinndddd 111111 11//2255//0099 44::4400::4477 PPMM
112 Part II ■ Discovering Vulnerabilities
talked about the DTrace mechanism built into the kernel. DTrace allows kernel-
level runtime application tracing. We wrote several small D programs that per-
formed some useful functions for a security researcher, such as monitoring fi le
usage, system calls, and memory allocations. The next topic was the Mac OS X
port of PyDbg. This allowed us to write several Python scripts that performed
debugging functions. The scripts included such things as searching memory
and in-memory fuzzing. We also showed how Pai Mei could be used to help
reverse-engineer a binary. Finally we discussed and showed how to circumvent
Leopard’s attempt at anti-debugging.
References
http://landonf.bikemonkey.org/code/macosx/Leopard_PT_DENY_
ATTACH.20080122.html
http://www.phrack.com/issues.html?issue=63&id=5
http://steike.com/code/debugging-itunes-with-gdb/
http://www.sun.com/bigadmin/content/dtrace/
http://www.mactech.com/articles/mactech/Vol.23/23.11/
ExploringLeopardwithDTrace/index.html
http://dlc.sun.com/pdf/817-6223/817-6223.pdf
http://www.blackhat.com/presentations/bh-dc-08/Beauchamp-
Weston/Whitepaper/bh-dc-08-beauchamp-weston-WP.pdf
https://www.blackhat.com/presentations/bh-usa-07/Miller/
Whitepaper/bh-usa-07-miller-WP.pdf
http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-3944
http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-1026
9955336633cc0044..iinndddd 111122 11//2255//0099 44::4400::4477 PPMM
CHAPTER
5
Finding Bugs
In the process of exploitation, vulnerabilities are what everything else builds
upon. You can’t have an exploit without an underlying bug. In this case, a bug
is an error in the functioning of a program, and a vulnerability is a bug that has
security implications. The reliability and robustness of an exploit depends greatly
on the qualities of the vulnerability that it takes advantage of. You can’t install a
rootkit without fi rst running an exploit. So every aspect of taking over a computer
begins with a bug. If software were perfect, security researchers would all be
out of a job. Luckily, it isn’t, and Apple’s code is no exception. In this chapter we
look at some basic approaches to fi nding bugs in Leopard. Many of these tech-
niques are general-purpose and would be valid for any piece of software; some
are specifi c to the intricacies of Apple. Since Mac OS X contains both open- and
closed-source components, we present approaches for fi nding vulnerabilities in
source code and in binaries for which we don’t have the source code. In addi-
tion, we present some clever ways of taking advantage of the open-source public
development process used by Apple to identify vulnerabilities in Leopard.
Bug-Hunting Strategies
Finding bugs, especially security-critical bugs, is both an art and a science.
Some superb bug hunters have diffi culty explaining exactly how they fi nd their
vulnerabilities; they just follow their gut. Others use a thorough, systematic
113
9955336633cc0055..iinndddd 111133 11//2255//0099 44::4411::0066 PPMM
114 Part II ■ Discovering Vulnerabilities
approach to uncover these hard-to-fi nd bugs. Since it is diffi cult to write about
instinct, we will spend some time introducing various techniques for fi nding
software bugs. The majority of these techniques will be valid for any software
(or hardware), but when possible we will discuss the particular tools available
to carry them out on Leopard. We’ll also discuss some ways to fi nd bugs eas-
ily by taking advantage of some of the intricacies of the way Apple designs,
develops, and tests its software.
In general, there are two methods of searching for bugs in software: static
and dynamic. In static analysis, the source code or a disassembly of the binary
is analyzed for problems. This may be done with tools that look for various
common errors, such as buffer overfl ows, or by hand. Even in the presence
of sophisticated tools, at some point an experienced analyst will have to sort
through the results and fi gure out which of the identifi ed areas of code are actu-
ally vulnerabilities. Sometimes this may be as diffi cult as fi nding the potential
problem in the fi rst place. For example, consider the following function:
char *foo(char *src, int len){
char *ret = malloc(len);
strcpy(ret, src);
return ret;
}
It is impossible to comment on the security of this function in isolation. It cer-
tainly has the potential to be problematic, but it might take signifi cant effort to
determine whether a user has control over the inputs to this function. Can a user
control src? Can the user control len? Most importantly, can a user control src
and len independently? These are some of the diffi culties with static analysis.
On the other hand, dynamic analysis, often called fuzzing, consists of send-
ing invalid inputs to the program and observing whether critical errors occur.
Invalid inputs for an HTTP GET request could consist of the following:
GET / HTTP/1.0000
GET //////////////////HTTP/1.0
GET / HT%n%nP/1.0
…
Obviously, there are infi nite such inputs to try. Dynamic analysis carries
the advantage of not having false positives. If the program crashes, it crashes.
However, dynamic analysis does not usually understand the internals of the
program. For example, fuzzing consists of testing an application with invalid
inputs. If these inputs are too abnormal, the program may quickly reject them,
and so only a few functions of the program will actually be tested. An example
of this might be a checksum that is incorrect. Likewise, if the inputs are not
invalid enough, they may not cause any problems in the program under test.
It can be very diffi cult to fi nd the right balance and generate the most effective
fuzzed inputs.
9955336633cc0055..iinndddd 111144 11//2255//0099 44::4411::0066 PPMM
Chapter 5 ■ Finding Bugs 115
Oftentimes, the best solution is to use a combination of these two techniques.
Use static analysis to fi nd suspicious-looking areas of code and then use dynamic
analysis to try to test these regions. Or use dynamic analysis to fi nd areas of code
that are hard to reach and thus hard to test, and then analyze those methods
carefully using static techniques. This latter method is often helped with the
use of code coverage, which we will cover shortly.
Old-School Source-Code Analysis
One of the oldest approaches of static analysis consists of simply reading the
source code and looking for problems. Some of Apple’s code is open source.
Unfortunately, most of it isn’t. In general, the nongraphical components of
the operating system (Darwin)—including the kernel, command-line utili-
ties, system daemons, and shared libraries—tend to be open source. The GUI
applications and libraries in Mac OS X are almost exclusively closed source.
Nevertheless, they make use of open-source libraries and frameworks. For
example, Safari is closed source, but relies heavily on the WebKit framework,
which is open source. The following is an incomplete list of programs with
security implications for which the source code is available. For a more detailed
list, check out http://www.opensource.apple.com/darwinsource/.
■ WebKit
■ mDNSResponder
■ SecurityTokend
■ dyld
■ launchd
■ XNU
Some notable exceptions to the open-source policy include QuickTime Player,
Preview, Mail, iTunes, and others. With the source code available, a dedicated
attacker can simply sit down and start reading through it, looking for bugs.
This doesn’t require any specialized tools or techniques, just a little skill and
a lot of patience.
Getting to the Source
The Apple open-source site tends to be a little outdated, but Apple’s source-code
repositories are always up-to-date. The following are two examples of how to
get the source code using CVS and SVN.
9955336633cc0055..iinndddd 111155 11//2255//0099 44::4411::0066 PPMM
116 Part II ■ Discovering Vulnerabilities
To get most projects, CVS can be used. Here is an example of downloading
mDNSResponder:
export CVSROOT=:pserver:PI:EMAIL:/cvs/root
$ cvs login
Logging in to
:pserver:PI:EMAIL:2401/cvs/root
CVS password: anonymous
$ cvs co mDNSResponder
To get WebKit, use the WebKit SVN server:
$ svn checkout http://svn.webkit.org/repository/webkit/trunk WebKit
From here, the source code is available to be read, audited, and compiled. For
an exhaustive treatment of fi nding vulnerabilities in source code, consult The Art
of Software Security Assessment: Identifying and Preventing Software Vulnerabilities
(Addison-Wesley, 2006). Keep in mind that the source code is often newer than
the actual binaries found in Leopard on the system. More on that in a bit.
Code Coverage
Code coverage is used to determine which lines of code in an application have
been executed. This has been used for years by testers and quality-control engi-
neers to fi nd which code has been tested and which hasn’t. Security researchers
can take advantage of it, too. Consider the case of code coverage used in con-
junction with dynamic analysis, i.e., fuzzing. After fuzzing the system under
test, code-coverage information can be obtained. This information can be used
to fi nd which portions of the code have not been tested yet with the fuzzing.
(It cannot determine, in a meaningful way, whether a given executed line has
been well tested, but it can determine which lines have not been tested). Such
information can be used in refi ning the fuzzed inputs to improve their quality
and execute additional code. Furthermore, fi nding the untested lines means
they can be analyzed more carefully statically, or the dynamic analysis can
be suitably improved to test those sections. Either way, code coverage can be a
useful metric to analyze dynamic testing.
Therefore, one thing you can do with the Apple source code, besides read it,
is to collect code-coverage information on it. For example, the WebKit regres-
sion-testing page (http://webkit.org/quality/testing.html) states the
following:
If you are making changes to JavaScriptCore, there is an additional test suite you
must run before landing changes. This is the Mozilla JavaScript test suite.
9955336633cc0055..iinndddd 111166 11//2255//0099 44::4411::0066 PPMM
Chapter 5 ■ Finding Bugs 117
Since WebKit is a very big project to look through for bugs, it might help to
focus on the areas that are not well tested with these regression tests. That is to
say, some code is not as well tested as others and the code that is not well tested
probably has more bugs to fi nd. To collect code-coverage information, WebKit
needs to be built with the proper fl ags.
$ WebKit/WebKitTools/Scripts/build-webkit –coverage
This should build the whole package with code-coverage information built in,
i.e., with the GCC fl ags -fprofi le-arcs and -ftest-coverage. The build will likely fail
at one point with an error complaining that warnings are treated as errors. In
that case, you have to fi nd and remove the -Werror fl ag from the compilation. For
example, open the Xcode project fi le JavaScriptGlue.xcodeproj. Select Project ➯
Edit Project Settings and unclick the box by Treat Warnings as Errors. Make
sure Confi guration is set to All Confi gurations. Then quit Xcode and rebuild the
WebKit project. It should build all the way through without errors. The build
succeeds if you see a message like the following:
===========================================================
WebKit is now built. To run Safari with this newly-built
code, use the “WebKitTools/Scripts/run-safari” script.
NOTE: WebKit has been built with SVG support enabled.
Safari will have SVG viewing capabilities.
Your build supports the following (optional) SVG features:
* Basic SVG animation.
* SVG foreign object.
* SVG fonts.
* SVG as image.
* SVG  support.
===========================================================
If the code is really instrumented to do code coverage, it should have created
a bunch of .gcno fi les that contain information about the code, such as basic
block and control-fl ow information.