# 04 \| 容器汇编 I：比较简单的若干容器你好，我是吴咏炜。上几讲我们学习了 C++ 的资源管理和值类别。今天我们换一个话题，来看一下C++ 里的容器。关于容器，已经存在不少的学习资料了。在 cppreference上有很完备的参考资料（\[1\）。今天我们采取一种非正规的讲解方式，尽量不重复已有的参考资料，而是让你加深对于重要容器的理解。对于容器，学习上的一个麻烦点是你无法直接输出容器的内容------如果你定义了一个`vector v`，你是没法简单输出 `v`的内容的。有人也许会说用 `copy(v.begin(), v.end(), ostream_iterator(…))`，可那既啰嗦，又对像 `map` 或`vector>`这样的复杂类型无效。因此，我们需要一个更好用的工具。在此，我向你大力推荐xeus-cling \[2\。它的便利性无与伦比------你可以直接在浏览器里以交互的方式运行代码，不需要本机安装任何编译器（点击"Tryingit online"下面的 binder链接）。下面是在线运行的一个截图：![](Images/96bb110bbf96833a2cc42483aad75229.png)savepage-src="https://static001.geekbang.org/resource/image/71/ca/7199bb5b1394fe1aa9f91b850c309eca.png"}xeus-cling 也可以在本地安装。对于使用 Linux的同学，安装应当是相当便捷的。有兴趣的话，使用其他平台的同学也可以尝试一下。如果你既没有本地运行的条件，也不方便远程使用互联网来运行代码，我个人还为本专栏写了一个小小的工具\[3\。在你的代码中包含这个头文件，也可以方便地得到类似于上面的输出。示例代码如下所示：    #include     #include     #include     #include "output_container.h"    using namespace std;    int main()    {      map mp{        {1, 1}, {2, 4}, {3, 9}};      cout > vv{        {1, 1}, {2, 4}, {3, 9}};      cout   > `{ 1 => 1, 2 => 4, 3 => 9 }`>>>  > `{ { 1, 1 }, { 2, 4 }, { 3, 9 } }`>这个代码中用到了很多我们目前专栏还没有讲的知识，所以你暂且不用关心它的实现原理。如果你能看得懂这个代码，那就太棒了。如果你看不懂，唔，不急，慢慢来，你会明白的。工具在手，天下我有。下面我们正式开讲容器篇。string`string` 一般并不被认为是一个 C++的容器。但鉴于其和容器有很多共同点，我们先拿 `string`类来开说。 `string` 是模板 `basic_string` 对于 `char`类型的特化，可以认为是一个只存放字符 `char`类型数据的容器。"真正"的容器类与 `string`的最大不同点是里面可以存放任意类型的对象。跟其他大部分容器一样， `string`具有下列成员函数：1.  `begin`    可以得到对象起始点        2.  `end`    可以得到对象的结束点        3.  `empty`    可以得到容器是否为空        4.  `size`    可以得到容器的大小        5.  `swap`    可以和另外一个容器交换其内容        （对于不那么熟悉容器的人，需要知道 C++ 的 `begin` 和 `end`是半开半闭区间：在容器非空时，`begin` 指向一个第一个元素，而 `end`指向最后一个元素后面的位置；在容器为空时，`begin` 等于 `end`。在 `string` 的情况下，由于考虑到和 C字符串的兼容，`end` 指向代表字符串结尾的 `\0`字符。） 上面就几乎是所有容器的共同点了。也就是说：1.  容器都有开始和结束点        2.  容器会记录其状态是否非空        3.  容器有大小        4.  容器支持交换        当然，这只是容器的"共同点"而已。每个容器都有其特殊的用途。`string`的内存布局大致如下图所示：![](Images/6995794ce0dec04598dead461192f9b9.png)savepage-src="https://static001.geekbang.org/resource/image/ee/62/eec393f933220a9998b7235c8acc1862.png"}下面你会看到，不管是内存布局，还是成员函数，`string` 和 `vector`是非常相似的。`string` 当然是为了存放字符串。和简单的 C字符串不同：1.  `string`    负责自动维护字符串的生命周期        2.  `string` 支持字符串的拼接操作（如之前说过的        `+` 和           `+=`）        3.  `string` 支持字符串的查找操作（如        `find` 和           `rfind`）        4.  `string` 支持从         `istream` 安全地读入字符串（使用           `getline`）        5.  `string` 支持给期待         `const char*` 的接口传递字符串内容（使用           `c_str`）        6.  `string`    支持到数字的互转（        `stoi` 系列函数和           `to_string`）        7.  等等    推荐你在代码中尽量使用 `string`来管理字符串。不过，对于对外暴露的接口，情况有一点复杂。我一般不建议在接口中使用`const string&`，除非确知调用者已经持有`string`：如果函数里不对字符串做复杂处理的话，使用 `const char*`可以避免在调用者只有 C 字符串时编译器自动构造`string`，这种额外的构造和析构代价并不低。反过来，如果实现较为复杂、希望使用 `string`的成员函数的话，那就应该考虑下面的策略：1.  如果不修改字符串的内容，使用           `const string&` 或 C++17 的           `string_view`    作为参数类型。后者是最理想的情况，因为即使在只有 C    字符串的情况，也不会引发不必要的内存复制。        2.  如果需要在函数内修改字符串内容、但不影响调用者的该字符串，使用        `string`    作为参数类型（自动拷贝）。        3.  如果需要改变调用者的字符串内容，使用        `string&`    作为参数类型（通常不推荐）。        估计大部分同学对 `string`已经很熟悉了。我们在此只给出一个非常简单的小例子：    string name;    cout     #include     using namespace std;    class Obj1 {    public:      Obj1()      {        cout  v1;      v1.reserve(2);      v1.emplace_back();      v1.emplace_back();      v1.emplace_back();      vector v2;      v2.reserve(2);      v2.emplace_back();      v2.emplace_back();      v2.emplace_back();    }我们可以立即得到下面的输出：>  > `Obj1()`>>>  > `Obj1()`>>>  > `Obj1()`>>>  > `Obj1(const Obj1&)`>>>  > `Obj1(const Obj1&)`>>>  > `Obj2()`>>>  > `Obj2()`>>>  > `Obj2()`>>>  > `Obj2(Obj2&&)`>>>  > `Obj2(Obj2&&)`>`Obj1` 和 `Obj2` 的定义只差了一个`noexcept`，但这个小小的差异就导致了 `vector`是否会移动对象。这点非常重要。C++11 开始提供的 `emplace…`系列函数是为了提升容器的性能而设计的。你可以试试把`v1.emplace_back()` 改成`v1.push_back(Obj1())`。对于 `vector`里的内容，结果是一样的；但使用 `push_back`会额外生成临时对象，多一次拷贝构造和一次析构。现代处理器的体系架构使得对连续内存访问的速度比不连续的内存要快得多。因而，`vector`的连续内存使用是它的一大优势所在。当你不知道该用什么容器时，缺省就使用 `vector`吧。 `vector` 的一个主要缺陷是大小增长时导致的元素移动。如果可能，尽早使用 `reserve` 函数为 `vector`保留所需的内存，这在 `vector`预期会增长很大时能带来很大的性能提升。deque`deque` 的意思是 double-endedqueue，双端队列。它主要是用来满足下面这个需求：1.  容器不仅可以从尾部自由地添加和删除元素，也可以从头部自由地添加和删除。        `deque` 的接口和 `vector`相比，有如下的区别：1.  `deque` 提供         `push_front`、        `emplace_front` 和        `pop_front`    成员函数。        2.  `deque` 不提供         `data`、        `capacity` 和        `reserve`    成员函数。        `deque`的内存布局一般是这样的：![](Images/d1d28e183870c3067efe963196adfe58.png)savepage-src="https://static001.geekbang.org/resource/image/ae/a1/aea92e7e005d65fa56d6332bb7706fa1.png"}可以看到：1.  如果只从头、尾两个位置对        `deque`    进行增删操作的话，容器里的对象永远不需要移动。        2.  容器里的元素只是部分连续的（因而没法提供        `data`    成员函数）。        3.  由于元素的存储大部分仍然连续，它的遍历性能是比较高的。        4.  由于每一段存储大小相等，        `deque` 支持使用下标访问容器元素，大致相当于           `index[i / chunk_size][i % chunk_size]`，也保持高效。        如果你需要一个经常在头尾增删元素的容器，那 `deque`会是个合适的选择。list`list` 在 C++ 里代表双向链表。和 `vector`相比，它优化了在容器中间的插入和删除：1.  `list` 提供高效的、O(1)    复杂度的任意位置的插入和删除操作。        2.  `list`    不提供使用下标访问其元素。        3.  `list` 提供         `push_front`、        `emplace_front` 和        `pop_front`    成员函数（和         `deque`    相同）。        4.  `list` 不提供         `data`、        `capacity` 和        `reserve`    成员函数（和         `deque`    相同）。        它的内存布局一般是下图这个样子：![](Images/070b87f02cdd4bb7fec99f9aeb0385ee.png)savepage-src="https://static001.geekbang.org/resource/image/ad/14/addb521e20de1a302206f4286eac3914.png"}需要指出的是，虽然 `list`提供了任意位置插入新元素的灵活性，但由于每个元素的内存空间都是单独分配、不连续，它的遍历性能比 `vector` 和 `deque`都要低。这在很大程度上抵消了它在插入和删除操作时不需要移动元素的理论性能优势。如果你不太需要遍历容器、又需要在中间频繁插入或删除元素，可以考虑使用`list`。另外一个需要注意的地方是，因为某些标准算法在 `list`上会导致问题，list提供了成员函数作为替代，包括下面几个：1.  merge        2.  remove        3.  remove_if        4.  reverse        5.  sort    6.  unique        下面是一个示例（以 xeus-cling的交互为例）：    #include     #include     #include     using namespace std;    list lst{1, 7, 2, 8, 3};    vector vec{1, 7, 2, 8, 3};    sort(vec.begin(), vec.end());     //  正常    // sort(lst.begin(), lst.end());  //  会出错    lst.sort();                       //  正常    lst  //  输出  { 1, 2, 3, 7, 8 }    vec  //  输出  { 1, 2, 3, 7, 8 }如果不用 xeus-cling的话，我们需要做点转换：1.  把        `using namespace std;` 后面的部分放到        `main`    函数里。        2.  文件开头加上         `#include "output_container.h"` 和           `#include `。        3.  把输出语句改写成         `cout     #include     #include     #include     using namespace std;    int main()    {      list lst{1, 7, 2, 8, 3};      vector vec{1, 7, 2, 8, 3};      sort(vec.begin(), vec.end());    //  正常      // sort(lst.begin(), lst.end()); //  会出错      lst.sort();                      //  正常      cout     #include     int main()    {      std::queue q;      q.push(1);      q.push(2);      q.push(3);      while (!q.empty()) {        std::cout     #include     int main()    {      std::stack s;      s.push(1);      s.push(2);      s.push(3);      while (!s.empty()) {        std::cout     struct less      : binary_function {      bool operator()(const T& x,                      const T& y) const      {        return x  struct hash;    template <>    struct hash      : public unary_function {      size_t operator()(int v) const        noexcept      {        return static_cast(v);      }    };这当然是一个极其简单的例子。更复杂的类型，如指针或者 `string`的特化，都会更复杂。要点是，对于每个类，类的作者都可以提供 `hash`的特化，使得对于不同的对象值，函数调用运算符都能得到尽可能均匀分布的不同数值。我们用下面这个例子来加深一下理解：    #include    // std::sort    #include   // std::less/greater/hash    #include     // std::cout/endl    #include       // std::string    #include       // std::vector    #include "output_container.h"    using namespace std;    int main()    {      //  初始数组      vector v{13, 6, 4, 11, 29};      cout ());      cout ();      cout (v.data())           ();      cout   > `{ 13, 6, 4, 11, 29 }`>>>  > `{ 4, 6, 11, 13, 29 }`>>>  > `{ 29, 13, 11, 6, 4 }`>>>  > `hash(nullptr) = a8c7f832281a39c5`>>>  > `hash(v.data()) = 7a0bdfd7df0923d2`>>>  > `v.data() = 000001EFFB10EAE0`>>>  > `hash("hello") = a430d84680aabd0b`>>>  > `hash("hellp") = a430e54680aad322`>可以看到，在这个实现里，空指针的哈希值是一个非零的数值，指针的哈希值也和指针的数值不一样。要注意不同的实现处理的方式会不一样。事实上，我的测试结果是GCC、Clang 和 MSVC对常见类型的哈希方式都各有不同。在上面的例子里，我们同时可以看到，这两个函数对象的值不重要。我们甚至可以认为，每个 `less`（或 `greater` 或`hash`）对象都是等价的。关键在于其类型。以 `sort`为例，第三个参数的类型确定了其排序行为。对于容器也是如此，函数对象的类型确定了容器的行为。priority_queue`priority_queue`也是一个容器适配器。上一讲没有和其他容器适配器一起讲的原因就在于它用到了比较函数对象（默认是 `less`）。它和 `stack`相似，支持 `push`、`pop`、`top`等有限的操作，但容器内的顺序既不是后进先出，也不是先进先出，而是（部分）排序的结果。在使用缺省的 `less` 作为其 `Compare`模板参数时，最大的数值会出现在容器的"顶部"。如果需要最小的数值出现在容器顶部，则可以传递 `greater` 作为其 `Compare`模板参数。 下面的代码可以演示其功能：    #include   // std::greater    #include     // std::cout/endl    #include       // std::pair    #include        // std::priority_queue    #include       // std::vector    #include "output_container.h"    using namespace std;    int main()    {      priority_queue,        vector>,        greater>>        q;      q.push({1, 1});      q.push({2, 2});      q.push({0, 3});      q.push({9, 4});      while (!q.empty()) {        cout   > `(0, 3)`>>>  > `(1, 1)`>>>  > `(2, 2)`>>>  > `(9, 4)`>关联容器关联容器有 `set`（集合）、`map`（映射）、`multiset`（多重集）和`multimap`（多重映射）。跳出 C++的语境，`map`（映射）的更常见的名字是关联数组和字典\[3\，而在 JSON 里直接被称为对象（object）。在 C++外这些容器常常是无序的；在 C++里关联容器则被认为是有序的。我们可以通过以下的 xeus-cling交互来体会一下。    #include     #include     #include     #include     using namespace std;    set s{1, 1, 1, 2, 3, 4};    s>  > `{ 1, 2, 3, 4 }`>    multiset> ms{1, 1, 1, 2, 3, 4};    ms>  > `{ 4, 3, 2, 1, 1, 1 }`>    map mp{      {"one", 1},      {"two", 2},      {"three", 3},      {"four", 4}    };    mp>  > `{ "four" => 4, "one" => 1, "three" => 3, "two" => 2 }`>    mp.insert({"four", 4});    mp>  > `{ "four" => 4, "one" => 1, "three" => 3, "two" => 2 }`>    mp.find("four") == mp.end()>  > `false`>    mp.find("five") == mp.end()>  > `(bool) true`>    mp["five"] = 5;    mp>  > `{ "five" => 5, "four" => 4, "one" => 1, "three" => 3, "two" => 2 }`>    multimap mmp{      {"one", 1},      {"two", 2},      {"three", 3},      {"four", 4}    };    mmp>  > `{ "four" => 4, "one" => 1, "three" => 3, "two" => 2 }`>    mmp.insert({"four", -4});    mmp>  > `{ "four" => 4, "four" => -4, "one" => 1, "three" => 3, "two" => 2 }`>可以看到，关联容器是一种有序的容器。名字带"multi"的允许键重复，不带的不允许键重复。`set` 和 `multiset` 只能用来存放键，而 `map` 和 `multimap`则存放一个个键值对。与序列容器相比，关联容器没有前、后的概念及相关的成员函数，但同样提供`insert`、`emplace` 等成员函数。此外，关联容器都有`find`、`lower_bound`、`upper_bound`等查找函数，结果是一个迭代器：1.  `find(k)` 可以找到任何一个等价于查找键 k    的元素（        `!(x ```    mp.find("four")->second>  > `4`>    mp.lower_bound("four")->second>  > `4`>    (--mp.upper_bound("four"))->second>  > `4`>    mmp.lower_bound("four")->second>  > `4`>    (--mmp.upper_bound("four"))->second>  > `-4`>如果你需要在 `multimap` 里精确查找满足某个键的区间的话，建议使用`equal_range`，可以一次性取得上下界（半开半闭）。如下所示：    #include     multimap::iterator      lower, upper;    std::tie(lower, upper) =      mmp.equal_range("four");    (lower != upper)  //  检测区间非空>  > `true`>    lower->second>  > `4`>    (--upper)->second>  > `-4`>如果在声明关联容器时没有提供比较类型的参数，缺省使用 `less`来进行排序。如果键的类型提供了比较算符 `        // std::complex    #include        // std::cout/endl    #include   // std::unordered_map    #include   // std::unordered_set    #include "output_container.h"    using namespace std;    namespace std {    template     struct hash> {      size_t      operator()(const complex& v) const        noexcept      {        hash h;        return h(v.real()) + h(v.imag());      }    };    }  // namespace std    int main()    {      unordered_set s{        1, 1, 2, 3, 5, 8, 13, 21      };      cout ,                    double>        umc{{{1.0, 1.0}, 1.4142},            {{3.0, 4.0}, 5.0}};      cout   > `{ 21, 5, 8, 3, 13, 2, 1 }`>>>  > `{ (3,4) => 5, (1,1) => 1.4142 }`>请注意我们在 `std` 名空间中添加了特化，这是少数用户可以向 `std`名空间添加内容的情况之一。正常情况下，向 `std`名空间添加声明或定义是禁止的，属于未定义行为。从实际的工程角度，无序关联容器的主要优点在于其性能。关联容器和 `priority_queue`的插入和删除操作，以及关联容器的查找操作，其复杂度都是O(log(n))，而无序关联容器的实现使用哈希表\[5\，可以达到平均O(1)！但这取决于我们是否使用了一个好的哈希函数：在哈希函数选择不当的情况下，无序关联容器的插入、删除、查找性能可能成为最差情况的O(n)，那就比关联容器糟糕得多了。array我们讲的最后一个容器是 C 数组的替代品。C 数组在 C++里继续存在，主要是为了保留和 C 的向后兼容性。C 数组本身和 C++的容器相差是非常大的：1.  C 数组没有         `begin` 和         `end` 成员函数（虽然可以使用全局的        `begin` 和        `end`    函数）    2.  C 数组没有         `size`    成员函数（得用一些模板技巧来获取其长度）        3.  C 数组作为参数有退化行为，传递给另外一个函数后那个函数不再能获得    C 数组的长度和结束位置        在 C的年代，大家有时候会定义这样一个宏来获得数组的长度：    #define ARRAY_LEN(a) \      (sizeof(a) / sizeof((a)[0]))如果在一个函数内部对数组参数使用这个宏，结果肯定是错的。现在 GCC会友好地发出警告：    void test(int a[8])    {      cout   > warning: sizeof on array function parameter will return size of> 'int \*' instead of 'int \[8\]'> \[-Wsizeof-array-argument\> > >>>  >     cout \ endl;> >C++17 直接提供了一个 `size`方法，可以用于提供数组长度，并且在数组退化成指针的情况下会直接失败：    #include   // std::cout/endl    #include   // std::size    void test(int arr[])    {      //  不能编译      // std::cout   // std::map    typedef char mykey_t[8];    int main()    {      std::map mp;      mykey_t mykey{"hello"};      mp[mykey] = 5;      //  轰，大段的编译错误    }如果不用 C数组的话，我们该用什么来替代呢？我们有三个可以考虑的选项：1.  如果数组较大的话，应该考虑           `vector`。        `vector`    有最大的灵活性和不错的性能。        2.  对于字符串数组，当然应该考虑           `string`。        3.  如果数组大小固定（C 的数组在 C++    里本来就是大小固定的）并且较小的话，应该考虑           `array`。        `array` 保留了 C 数组在栈上分配的特点，同时，提供了           `begin`、        `end`、        `size`    等通用成员函数。        `array` 可以避免 C 数组的种种怪异行径。上面的失败代码，如果使用 `array`的话，稍作改动就可以通过编译：    #include      // std::array    #include   // std::cout/endl    #include        // std::map    #include "output_container.h"    typedef std::array mykey_t;    int main()    {      std::map mp;      mykey_t mykey{"hello"};      mp[mykey] = 5;  // OK      std::cout   > `{ hello => 5 }`>内容小结本讲介绍了 C++的两个常用的函数对象，`less` 和 `hash`；然后介绍了用到这两个函数对象的容器适配器、关联容器和无序关联容器；最后，通过例子展示了为什么我们应当避免C 数组而考虑使用 `array`。通过这两讲，我们已经完整地了解了 C++提供的标准容器。课后思考请思考一下：1.       为什么大部分容器都提供了           `begin`、        `end`    等方法？        2.       为什么容器没有继承一个公用的基类？        欢迎留言和我交流你的看法。参考资料\[1\] cppreference.com, "Containers library".https://en.cppreference.com/w/cpp/containerslate-object="mark"} \[1a\] cppreference.com, "容器库".https://zh.cppreference.com/w/cpp/containerslate-object="mark"} \[2\] cppreference.com, "Explicit (full) template specialization".https://en.cppreference.com/w/cpp/language/template_specializationslate-object="mark"} \[2a\] cppreference.com, "显式（全）模板特化".https://zh.cppreference.com/w/cpp/language/template_specializationslate-object="mark"} \[3\] Wikipedia, "Associative array".https://en.wikipedia.org/wiki/Associative_arrayslate-object="mark"} \[3a\] 维基百科, "关联数组". slate-object="mark"}https://zh.wikipedia.org/zh-cn/关联数组  [ \[4\] Wikipedia, "Weak ordering".https://en.wikipedia.org/wiki/Weak_orderingslate-object="mark"} \[5\] Wikipedia, "Hash table". slate-object="mark"}https://en.wikipedia.org/wiki/Hash_tableslate-object="mark"} \[5a\] 维基百科, "哈希表". slate-object="mark"}https://zh.wikipedia.org/zh-cn/哈希表  [ 