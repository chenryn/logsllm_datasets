chains from gadgets in real binaries, where the number of in-
dividual gadgets is large, and intractable for manual analysis.
Constraint handling SpecROP gadget chains have to re-
spect constraints to prevent scenarios which stop speculation.
For example, a gadget which loads an rip relative offset into
register rax prevents speculation on a later indirect jump us-
ing the same register. Another constraint is that the register
holding the secret must not be overwritten. A ﬁnal constraint
is that the gadget chain must make the secret available at the
location (register/memory) disclosed by the leakage gadget.
Other constraints are important for speciﬁc side-channels, for
example a NetSpectre attacker requires intermediate gadgets
to not use AVX instructions.
SpecFication uses symbolic representation of x86_64 in-
structions to model their effects on processor state. This ap-
proach allows us to both compose the effects of instructions
to express the effects of a gadget and to express constraints
over our gadgets. As in ROP-chain tools [9], SpecFication
starts by enumerating every address which can be interpreted
as a valid instruction sequence ending in an indirect jump or
return instruction. For each of these sequences, we model the
semantics of the instructions over the registers. Currently, we
only handle certain classes of instructions such as data move-
ment, logic, arithmetic and branch instructions. SpecFication
uses the Z3 theorem prover [10] for testing constraints over
each sequence.
5.1 SpecFication architecture
SpecFication works in three phases: (i) binary disassembly
and preprocessing, (ii) gadget characterization, and (iii) con-
straint enforcement.
In the binary disassembly phase, the Capstone [11] frame-
work disassembles our target binaries. We create instruction
sequences, including unintended instructions, which end in a
return or indirect jump. Since we prioritize short gadgets, we
limit the length of explored sequences to 6 instructions. We
also remove gadgets containing speciﬁc instructions such as
unintended control-ﬂow and privileged instructions.
Based on the intermediate representation of the gadgets
provided by Capstone, we map gadget semantics of the gad-
gets in the characterization phase. We express the semantics
of each instruction in the Hoare logic space and compose the
effects of all constituent instruction to generate the overall
effect of the gadgets. This makes the gadgets amenable to
processing by the Z3 theorem prover [10] in the solving phase.
An alternate approach would be to leverage previous work
which provide the formal speciﬁcation of x86_64 instructions,
such as Strata [12] and Dasgupta et. al. [13]. For determining
the effect of a gadget chain, the code for each of the individual
gadgets must be composed after removing the terminating
control-ﬂow instructions (which the attacker will poison).
5.2 Evaluation and Results
We now evaluate the effectiveness of SpecFication in ﬁnding
usable SpecROP gadgets in common libraries. Particularly,
USENIX Association
23rd International Symposium on Research in Attacks, Intrusions and Defenses    9
testq	0x400,	(rdx)rdx	=&plaintext+0x40Start ofspeculationProcessinggadgetLeakagegadgetEVP_EncryptUpdate:call	*0x20(rax)rdx	=	&plaintextadd	0x40,	rdxBase attackSMoTherSpectreSpecROP + SMoTherSpectre variantsrdi	=	*(&plaintext+0x50)mov	0x50(rdx),rditestq	0x10,	rdirax	=&plaintext+0xflea	0xf(rdx),raxrdx	=&plaintext+0xfmov	rax,rdxrax	=&plaintext+7lea	0x7(rdx),raxrdx	=&plaintext+7mov	rax,rdxas per the register on which the operation is done. There
are a larger number of arithmetic gadgets operating on
the ﬁrst eight registers (rax to rbp) than on the remaining
(r8 to r15). We do ﬁnd a large number of gadgets, spe-
cially in libc which operate on the ﬁrst four argument
registers used by the System-V calling convention: rdi,
rsi, rdx and rcx. This enables a SpecROP attacker to
perform ample range of computation with function argu-
ments: for example, if these arguments are pointers to
secrets, the attacker can manipulate and access different
parts of the secret. Finally, some gadgets target registers
rsp and rbp which allow the attacker to access secrets
on the stack.
• Shift gadgets: We found a smaller number of gadgets
performing bit movement on registers: 25 in libcrypto,
95 in libc and a handful in other libraries. A detailed
breakdown of the occurrence of such gadgets is shown
in Appendix A.
• Data movement gadgets: We searched for gadgets in the
target libraries which can move data between unique
pairs of source and destination registers. Overall, there
are a maximum of 240 unique pairs from the 16 general
purpose registers (ignoring sub-registers) in x86_64. Ta-
ble 3 reports the number of such gadgets in each library,
as well as the number of gadgets which result from unin-
tended instructions (one in ﬁve gadgets, on average). By
chaining more than one such gadget, we can increase the
number of register pairs, allowing greater ﬂexibility in
data movement. The column labeled "Chained" shows
the number of register pairs possible by chaining two
data-movement gadgets. In line with the general aim
of gadget chaining, most libraries exhibit a signiﬁcant
increase in data-movement possibilities with increased
chain length. In fact, chaining two gadgets allows 84%
of the register pairs possible with chains of any length.
• Leakage gadgets: Table 4 also reports (in even rows) the
occurrence of gadget leaking information into cache-
based side channels, assuming that loads to secret-
dependent addresses can leak information.
The results in this section not only illustrate the abun-
dance of usable SpecROP gadgets in real libraries, but also
demonstrate the practicality of using binary analysis for per-
forming automated gadget search with formally speciﬁable
constraints. This methodology has allowed us to construct
practical SpecROP chains against OpenSSL (Figure 2) and
similar to Spectre (Listing 1). We have demonstrated that
this methodology can streamline the often manual process of
ﬁnding gadgets in new binaries, and for newer side-channel
attacks.
6 Mitigation
Figure 7: Example of an unaligned SpecROP gadget found in
libcrypto
we look at instances of generic gadget types discussed in
Section 3.1.1.
Target libraries We have chosen a set of target libraries
based on their ubiquity and security criticality. Speciﬁcally,
we analyze:
• libcrypto from OpenSSL v1.1.1d,
• mod_ssl, mod_proxy and mod_http2 from Apache
v2.4.41,
• libdl v2.30, and
• libc v2.30.
Testing setup SpecFication is written in Python, and de-
pends on Capstone v4.0 and Z3 v4.8. All reported running
times were measured on an i7-8700 processor with 16GB of
memory running Debian 10 and Linux v5.4.
Results
In the binary disassembly phase, SpecFication cre-
ates SpecROP gadgets: sequences of instructions ending in a
return or indirect jump (an endpoint). For the analyzed bina-
ries (which range from a few kilobytes to a few megabytes),
the number of gadgets we analyze range from a few hundreds
to thousands. Table 2 highlights statistics about the number
of gadgets processed by SpecFication. Note that there are
roughly 10 gadgets for each unique endpoint in these bina-
ries. A large fraction of the gadgets also contain at least one
unintended instruction.
As a particular use case, we report statistics for a run in
which we search for data movement gadgets which load from
memory at any address with register r12 as a base. We can see
that the tool ﬁnds at least one usable gadget in each library,
the exception being the smallest library (libdl). The running
time for the tool ranges from a few seconds to a few minutes
depending on the size of the binary. The constraint solving
phase, which involves calling the Z3 solver, is the largest
contributor to the runtime.
We report statistics on the occurrence of gadgets classiﬁed
as per the classes described in Section 3.1.1.
• Arithmetic gadgets: Table 4 highlights the number of
arithmetic gadgets found in our target libraries, separated
The mitigations against a SpecROP attack include generic
defenses against SEA, such as preventing speculation, pre-
10    23rd International Symposium on Research in Attacks, Intrusions and Defenses
USENIX Association
4d8b4a4d8b0241ff521008movq	0x08(r10),r9movq	(r10),r8callq		*0x10(r10)mov0x08(r10),ecxmovq	(r10),r8callq		*0x10(r10)Aligned sequence of instructionsUnaligned gadgetLibrary
Binary size
libcrypto
libc
libdl
mod_ssl
mod_proxy
mod_http2
3.3M
1.8M
15K
235K
131K
244K
Endpoints Gadgets Unaligned
9,545
10,130
205
332
246
796
13,437
15,044
266
490
338
1,113
1,209
1,282
22
48
30
112
Data-movement gadgets addressing r12
Endpoints Gadgets Analysis time (s)
233
333
4
8
5
18
19
5
0
2
1
3
65
13
0
4
1
8
Table 2: Number of endpoints, gadgets, and unaligned gadgets found per library. We also show statistics for a particular use-case:
searching for gadgets which load from an address based on register r12
Library
libcrypto
libc
libdl
mod_ssl
mod_proxy
mod_http2
Data movement
gadgets (unaligned) Chained
210
116
101
204
2
2
47
32
46
34
27
72
(9)
(23)
(2)
(10)
(11)
(5)
Analysis
time (s)
5,644
8,432
305
419
295
875
Table 3: Occurrence of data movement gadgets moving data
between registers. We report how many unique combinations
of source and destination x86_64 registers were found in each
library.
venting branch predictor poisoning and control ﬂow integrity.
Other defenses particular to SpecROP might include limits on
the number of branches followed speculatively. Static binary
analysis techniques are inherently limited in their ability to
detect whether usable SpecROP chains exist in binaries due
to the large number of possible targets for a poisoned indirect
jump or return instruction, and the exponential explosion in
the number of possible sequences with the number of chained
gadgets.
Preventing speculation in software The simplest protec-
tion against SEA is to restrict speculation following sensitive
branches (where there is access to secrets). This can be done
by using serializing instructions (for example cpuid), or mem-
ory fences (for example lfence) when the side-channel uses
load instructions. If implemented by a shotgun approach, the
performance implications are signiﬁcant. However, we have
shown how SpecROP chains expand the reach of SEA to
access secrets, precluding ﬁne-grained application of specu-
lation barriers. Another mitigation, retpolines [14], protects
indirect jumps by replacing them with return instructions. It
also pollutes the Return Stack Buffer with the address of an
inﬁnite loop to prevent speculation on the ret. A practical,
though partial, mitigation would be to identify code which
might access secrets (e.g., array accesses following a bounds
check), and insert retpolines on subsequent indirect calls and
returns. This approach would still be vulnerable to gadget
chains where the attacker is able to manipulate existing state
to access secret state in unforeseen, and therefore unprotected,
gadgets.
Limiting speculation in hardware Architectural propos-
als which limit the number of speculative control-ﬂow in-
structions will effectively constrain the maximum length of
a SpecROP chain, reducing the attack surface. However, the
typical speculation window on a modern, high-performance
processor extends to hundreds of instructions, where it is
likely to contain tens of speculative control-ﬂow instructions.
We have already seen that it is impractical to chain more than
4-5 gadgets on these processors Figure 3a. A smaller limit on
speculative control-ﬂow instructions (say 2-3) may have an
unacceptable performance overhead.
Preventing leakage Numerous proposals exist for mitigat-
ing SEA by closing the leakage channels, particularly for
memory-based channels. InvisiSpec [15] proposes an sepa-
rate buffer to hold speculatively loaded values, preventing
them from affecting cache state. DAWG [16] dynamically
partitions the cache to prevent cross-context cache channels.
Other proposals which restrict execution of instructions de-
pendent on speculatively accessed values [17] will effectively
close all speculative side-channels, even if they do not prevent
the chaining of gadgets.
Preventing branch poisoning Existing processors offer
some degree of protection against control-ﬂow hijacking
across processes, and between different processor privilege
levels (particularly userspace and the kernel) [18–20], either
in hardware or through microcode updates. However, as we
can see from results in Table 1, these measures do not com-
pletely mitigate all branch poisoning attack scenarios.
Enforcing control-ﬂow integrity Any control-ﬂow in-
tegrity mechanism aiming to mitigate SpecROP must ac-
count for speculative control-ﬂow. Therefore, off-the-shelf
USENIX Association
23rd International Symposium on Research in Attacks, Intrusions and Defenses    11
Library
Type
libcrypto
libc
libdl
mod_ssl
mod_proxy
mod_http2
A
L
A
L
A
L
A
L
A
L
A
L
rax
665
218
889
188
25
9
12
2
12
8
46
32
rbx
259
255
317
171
6
11
8
38
6
2
5
48
rcx
34
137
128
65
0
0
0
0
0
0
0
6
rdx
78
192
171
96
0
8
4
2
0
0
5
22
rdi
69
238
419
570
0
0