和cmp命令组合使用。跳转到标签行
jmp
标签名
将控制无条件跳转到指定标签行
mov
A,B
把B的值赋值给A
pop
A
从核中读取出数值并存入A中
push
A
把A的值存入栈中
ret
无
将处理返回到调用源
xor
A,B
A和B的位进行异或比较，并将结果存入A中
正如本章前半部分所讲的那样，编译后的程序，会被归类到名为
段定义的组。初始化的全局变量，会像代码清单10-7的（1）那样被汇
总到名为_DATA的段定义中，没有初始化的全局变量，会像（2）那样
被汇总到名为_BSS的段定义中。指令则会像（3）那样被汇总到名为
TEXT的段定义中。这些段定义的名称是由BorlandC++的使用规范来
决定的。_DATA segment 和_DATA ends、_BSS segment 和_BSS ends、
TEXTsegment和_TEXTends，这些都是表示各段定义范围的伪指令。
首先让我们来看一下_DATA段定义的内容。（4）中的_allabel
dword定义了_al这个标签。标签表示的是相对于段定义起始位置的位
置。由于_al在_DATA段定义的开头位置，所以相对位置是0。_al
就相当于全局变量al。编译后的函数名和变量名前会附加一个下划线
（_）.这也是BorlandC++的规定。（5）中的dd1指的是，申请分配了
4字节的内存空间，存储着1这个初始值。dd（define doubleword）表
示的是有两个长度为2的字节领域（word），也就是4字节的意思。
---
## Page 210
BorlandC++中，由于int类型的长度是4字节，因此汇编器就把int al
=1；变换成了_al label dword和dd1。同样，这里也定义了相当于全局
变量a2~a5的标签_a2~_a5，它们各自的初始值2~5也都被存储在
了4字节的领域中。
接下来，让我们来看一下_BSS段定义的内容。这里定义了相当于
全局变量b1~b5的标签_b1~_b5。（6）的db4dup（7）表示的是申请分
配了4字节的领域，但值尚未确定（这里用？来表示）的意思。db
（define byte）表示有1个长度是1字节的内存空间。因面，db4 dup(?)
的情况下，就是4字节的内存空间。这里大家要注意不要和dd4混淆
了。db4dup（？)表示的是4个长度是1字节的内存空间。而db4表示
的则是双字节（=4字节）的内存空间中存储的值是4。
在_DATA和_BSS的段定义中，全局变量的内存空间都得到了确
保，这一点大家想必都清楚了吧。因面，从程序的开始到结束，所有
部分都可以参阅全局变量。面这里之所以根据是否进行了初始化把全
局变量的段定义划分为了两部分，是因为在BorlandC++中，程序运行
时没有初始化的全局变量的领域（_BSS段定义）都会被设定为0进行
初始化。可见，通过汇总，初始化很容易实现，只要把内存的特定范
围全部设定为0就可以了。
10.10临时确保局部变量用的内存空间
为什么局部变量只能在定义该变量的函数内进行参阅呢？这是因
为，局部变量是临时保存在寄存器和栈中的。正如本章前半部分讲的
那样，函数内部利用的栈，在函数处理完毕后会恢复到初始状态，因
此局部变量的值也就被销毁了，而寄存器也可能会被用于其他目的
因此，局部变量只是在函数处理运行期间临时存储在寄存器和栈上。
---
## Page 211
10.10临时确保局部变量用的内存空间
在代码清单10-6中定义了10个局部变量。这是为了表示存储局部
变量的不仅仅是栈，还有寄存器。为确保c1～c10所需的领域，寄存器
空闲时就使用寄存器，寄存器空间不足的话就使用栈。
下面让我们来看一下代码清单10-7中_TEXT段定义的内容。（7）
表示的是MyFunc函数的范围。在MyFunc函数中定义的局部变量所需
要的内存领域，会被尽可能地分配在寄存器中。大家可能会认为用高
性能的寄存器来代替普通的内存是很奢侈的事情，不过编译器不会这
么认为，只要寄存器有空间，编译器就会使用它。因为与内存相比，
使用寄存器时访问速度会高很多，这样就可以更快速地进行处理。局
部变量利用寄存器，是BorlandC++编译器最优化的运行结果。旧的编
译器没有类似的最优化功能，局部变量就可能会仅仅使用栈。
代码清单中的（8）表示的是往寄存器中分配局部变量的部分。仅
仅对局部变量进行定义是不够的，只有在给局部变量赋值时，才会被
分配到寄存器的内存区域。（8）就相当于给5个局部变量c1~e5分别
赋予数值1~5这一处理。cax、edx、ccx、ebx、esi是Pentium等x86
系列32位CPU寄存器的名称（参考表10-2）。至于使用哪一个寄存器，
则要由编译器来决定。这种情况下，寄存器只是被单纯地用于存储变
量的值，和其本身的角色没有任何关系。
x86系列CPU拥有的寄存器中，程序可以操作的有十几个。其中
空闲的，最多也只有几个。因而，局部变量数目很多的时候，可分配
的寄存器就不够了。这种情况下，局部变量就会申请分配栈的内存空
间。虽然栈的内存空间也是作为一种存储数据的段定义来处理的，但
在程序各部分都可以共享并临时使用这一点上，它和_DATA段定义及
BSS段定义在性质上还是有些差异的。例如，在函数入白处为变量申
请分配栈的内存空间的话，就必须在函数出口处进行释放。否则，经
---
## Page 212
第10章通过汇编语言了解程序的实际构成
过多次调用函数后，栈的内存空间就会被用光了。
在（8）这一部分中，给局部变量cl~c5分配完寄存器后，可用的
寄存器数量就不足了。于是，剩下的5个局部变量c6~c10就被分配了
栈的内存空间，如（9）所示。函数入口（10）处的addesp,-20指的是、
对栈数据存储位置的esp寄存器（栈指针）的值做减20的处理。为了
确保内部变量c6~c10在栈中，就需要保留5个int类型的局部变量
（4字节x5=20字节）所需的空间。（11）中的movebp,esp这一处理，
指的是把当前esp寄存器的值复制到ebp寄存器中。之所以需要（11）
这一处理，是为了通过在函数出口处的（12）这一move esp,cbp的处
理，把esp寄存器的值还原到原始状态，从面对申请分配的栈空间进行
释放，这时栈中用到的局部变量就消失了。这也是栈的清理处理。在
使用寄存器的情况下，局部变量则会在寄存器被用于其他用途时自动
消失（图10-6）。
未使用的
未使用的
空间
申请分配内存空间
mov ebp.esp
空间
用于局部
esp
栈·段定义
add esp,20
20字节
变量的内
esp=ebp
存空间
ebp
使用的
使用的
空间
mov esp.ebp
释放内存空间
空间
图10-6用于局邮变量的栈空间的申请分配和释放
（9）中的5行代码是往栈空间中代人数值的部分。由于在向栈申
请内存空间前，借助movebp.esp这个处理，esp寄存器的值被保存
到了ebp寄存器中，因此，通过使用[ebp-4]、[ebp-8]、[ebp-12]、
---
## Page 213
10.11环处理的实现方法
[ebp-16]、[ebp-20]这样的形式，就可以将申请分配的20字节的栈内
存空间切分成5个长度分别是4字节的空间来使用（图10-7）。例如，
（9）中的movdword ptr[ebp-4].6表示的就是，从申请分配的内存空
间的下端（ebp寄存器指示的位置）开始往前4字节的地址（[ebp-4]）
中.存储着6这一4字节的数据。
ebp-20
局部变量c10的内存空间
eb-16
局都变量c9的内存空间
ebp-12
20字节
局都变量c8的内存空间
ebp-B
局部变量c7的内存空间
ebp-4
局部变量c6的内存空间
ebp
图10-7将栈的内存空间进行分割
关于往全局变量中代人局部变量的数值这一内容，这里不再进行
说明。这时可能有读者会产生疑问，既然不进行说明，那为什么代码
清单10-6中没有省略掉该部分呢？这是为了避免编译器的最优化功能。
如果仅进行定义局部变量并代人数值这一处理的话，编译器的最优化
功能就会启动，届时编译器就会认为某些代码没有意义，从而导致汇
编语言的源代码无法生成。这样看来，编译器还是很聪明的吧！
10.11循环处理的实现方法
接下来，让我们继续解析汇编语言的源代码，看一下for循环及f
条件分支等C语言程序的流程控制是如何实现的。代码清单10-8是将
①通过利用for语句及计语句来改变程序流程的积制称为“流程控制”。
更多资料请关注裁的新浪薄客http：//blog
---
## Page 214
第10章通过汇编语言了解程序的实际构成
局部变量i作为循环计数器连续进行10次循环的C语言源代码。在
for语句中，调用了不做任何处理的MySub函数。这里我们把代码清单
10-8转换成汇编语言，然后仅把相当于for处理的部分摘出来，如代码
清单10-9所示。
代码清单10-8执行循环处理的C语言源代码
//定义bySub函数
()qngH PTOA
//不做任何处理
//定义HyPunc 函数
Void MyFunc ()
int i;
for
[1=0:1<10;++}
//重复调用nySub函数10次
MySub () ;
代码清单10-9将代码清单10-8中的1or语句转换成汇编语言的结果
xor
ebx, ebx
：//调用Myub函数
：将eax寄存据清0
84
ca11
_MySub
Ine
ebx
：//特ebx寄存器的值和10进行比较
：//ebx奇存器的值加1
cmp
ebx,10
51
short 94
：//如果小于10就跳转到84
C语言的for语句是通过在括号中指定循环计数器的初始值（i=
0）、循环的继续条件（1<10）、循环计数器的更新（i++）这3种形式来
进行循环处理的。与此相对，在汇编语言的源代码中，循环是通过比
较指令（cmp）和跳转指令（jl）来实现的。
①用来计算循环次数的变量称为“循环计数器”。
---
## Page 215
10.11环处建的实现方法
下面就让我们按照代码清单10-9的内容的顺序来进行说明。
MyFunc函数中用到的局部变量只有i，变量i申请分配了ebx寄存器的
内存空间。for语句的括号中的i=0;被转换成了xorebx,ebx这一处理。
xor指令会对左起第一个操作数和右起第二个操作数进行XOR运算，
然后把结果存储在第一个操作数中。由于这里把第一个操作数和第二
个操作数都指定为了ebx，因此就变成了对相同数值进行XOR运算。
也就是说，不管当前cbx寄存器的值是什么，结果肯定都是0。虽然用
mov指令的movebx,0也会得到同样的结果，但与mov指令相比，xor
指令的处理速度更快。这里，编译器的最优化功能也会启动。
ebx寄存器的值初始化后，会通过call指令调用MySub函数
（_MySub）。从MySub函数返回后，则会通过inc指令对cbx寄存器的值
做加1处理。该处理就相当于for语句的i+，是当前数值加1的意思。
下一行的cmp指令是用来对第一个操作数和第二个操作数的数值
进行比较的指令。cmpebx,10就相当于C语言的k10这一处理，意思
是把ebx寄存器的数值同10进行比较。汇编语言中比较指令的结果，
会存储在CPU的标志寄存器中。不过，标志寄存器的值，程序是无法
直接参考的。那么，程序是怎么来判断比较结果的呢？
实际上，汇编语言中有多个跳转指令，这些跳转指令会根据标志
寄存器的值来判定是否需要跳转。例如，最后一行的jl，是jumpon
lessthan（小于的话就跳转）的意思。也就是说，jlshont@4的意思就
是，前面运行的比较指令的结果若“小”的话就跳转到@4这个标签。
①相同数值进行XOR运算，运算结果为0。XOR远算的规则是，值不同时
结果为1，值相同时结果为0。例如，01010101和01010101进行XOR运算
的话，就会分别对该数字的各数字位进行XOR运算。因为这两个数的每个
位都相同，因此，运算结果就是0000000。
更多资料请关注裁的新浪薄客http：//blo
---
## Page 216
第10章通过汇编语言了解程序的实际构成
代码清单10-10是按照代码清单10-9中汇编语言源代码的处理顺
序重写的C语言源代码（由于C语言中无法使用@字符开头的标签，
因此这里用了L4这个标签名），也是对程序实际运行过程的一个直接
描述。不过看来看去还是觉得使用for语句的代码清单10-8的源代码
更智能些。人们经常说“汇编语言是对CPU的实际运行进行直接描述
的低级编程语言，C语言是用与人类的感觉相近的表现来描述的高级编
程语言”，此时，想必大家都能深切体会这句话的意思了吧。此外，代
码清单10-10的第一行中的P=f，意思是对i和/进行XOR运算，并把
结果代人i。为了和汇编语言的源代码进行同样的处理，这里把将变量
i的值清0这一处理，通过对变量i和变量1进行XOR运算来实现了。
借助r=i，i的值就变成了0。
代码清单10-10用C语言来表示代码清单10-9的处理顺序
L4: MyBub() :
if (i < 10) goto L4;
1++/
10.12条件分支的实现方法
下面让我们来看一下条件分支的实现方法。条件分支的实现方法
同循环处理的实现方法类似，使用的也是cmp指令和跳转指令，这一