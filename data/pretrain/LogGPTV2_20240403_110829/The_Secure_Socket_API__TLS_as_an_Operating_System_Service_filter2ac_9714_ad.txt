the SSA.
In many cases, a developer writing TLS client code
only needs to write or change a few lines of code
to create a secure connection.
The developer sim-
ply uses IPPROTO TLS as the third parameter of their
call to socket and then calls setsockopt with the
TLS REMOTE HOSTNAME option to provide a destination
hostname. Use of this option allows SSA to auto-
matically include the SNI extension and properly vali-
date the hostname for a certiﬁcate offered by a server.
To streamline this process, we add a new sockaddr
type, AF HOSTNAME, which can be supplied to connect.
Some languages, such as Python, have already made this
change to their analog of connect, allowing hostnames
to be provided in place of IP addresses. When supplied
with a hostname address type, the connect function will
perform the necessary host lookup and perform a TLS
handshake with the resulting address, also using the pro-
vided hostname for certiﬁcate validation and the SNI ex-
USENIX Association
27th USENIX Security Symposium    807
Program
wget
lighttpd
ws-event
netcat
LOC
Modiﬁed
LOC
removed
Familiar
with code
Time
Taken
15
8
5
5
1,020
2,063
0
0
No
No
Yes
No
5 Hrs.
5 Hrs.
5 Min.
10 Min.
Table 4: Summary of code changes required to port a
sample of applications to use the SSA. wget and lighttpd
used existing TLS libraries, ws-event and netcat were not
originally TLS-enabled. LOC = Lines of Code
tension. This also obviates the need for developers to ex-
plicitly call gethostbyname or getaddrinfo for host-
name lookups, which further simpliﬁes their code.
The SSA enables a useful split between administra-
tor and developer responsibilities for secure servers. An
administrator can use software from Let’s Encrypt to au-
tomatically obtain certiﬁcates for the hostnames associ-
ated with a given machine, and associate those certiﬁ-
cates (and keys) with an SSA proﬁle for the application.
All the developer needs to do to create a secure server
is to specify IPPROTO TLS in their call to socket, and
then bind to all interfaces on a given machine. When
incoming clients specify a hostname with SNI, the SSA
automatically supplies the appropriate certiﬁcate for the
hostname. If an incoming socket does not use SNI, then
the SSA defaults to the ﬁrst certiﬁcate listed in its con-
ﬁguration. If the developer wishes to bind to a particu-
lar hostname, then they may use setsockopt with the
TLS HOSTNAME option on their listening socket.
The options listed in Table 3 are useful primarily in
special cases, such as for client certiﬁcate pinning, or
specifying a particular certiﬁcate and private key to use
in the TLS handshake.
5.4 Porting Applications to the SSA
To obtain metrics on porting applications to use the SSA,
we modiﬁed the source code of four network programs.
Two of these already used OpenSSL for their TLS func-
tionality, and two were not built to use TLS at all. Table 4
summarizes the results of these efforts.
We modiﬁed the command-line wget web client to
use the SSA for its secure connections. Normally, wget
links with either GnuTLS or OpenSSL for TLS support,
based on compilation conﬁguration. Our modiﬁcations
required only 15 lines of source code. These changes
involved using IPPROTO TLS in the socket call when
the URL scheme was secure (e.g., HTTPS, FTPS) and
then assigning the appropriate hostname to the socket,
using setsockopt with the TLS REMOTE HOSTNAME op-
tion. The resulting binary could then be compiled with-
out linking with either GnuTLS or OpenSSL, removing
1,020 lines of OpenSSL-using code and allowing the ad-
ministrator to dictate the parameters of TLS connections
made. This modiﬁcation was made in ﬁve hours by a
programmer with no prior experience with wget’s source
code or OpenSSL, but who had a working knowledge of
C and POSIX sockets.
We also modiﬁed lighttpd, a light-weight event-
to use the SSA instead of
driven TLS webserver,
OpenSSL. This required only the modiﬁcation of four
lines of code, which merely speciﬁed IPPROTO TLS in
places where sockets were created. We also made op-
tional calls to setsockopt to specify the private key and
certiﬁcate chain (and check errors), with an additional
four lines of code. We removed 2,063 lines of code used
for interfacing with OpenSSL. These software packages
were then tested to ensure that they functioned properly
and used the TLS settings enforced by the SSA. This
modiﬁcation was made in ﬁve hours by another indi-
vidual with no prior experience with lighttpd’s source
code or OpenSSL, but who had a working knowledge of
C and POSIX sockets. In porting this and wget, most
of the time spent was used to become familiar with the
source code and remove OpenSSL calls.
We also modiﬁed two applications that did not previ-
ously use TLS, an in-house webserver and the netcat
utility. The webserver required modifying only one line
of code—the call to socket to use IPPROTO TLS on its
listening socket. Under these circumstances, the certiﬁ-
cate and private key used are from the SSA conﬁguration.
However, these can be speciﬁed by the application with
another four lines of code to set the private key and cer-
tiﬁcate chain and check for corresponding errors. In to-
tal, this TLS upgrade required less than ﬁve minutes. The
TLS upgrade for netcat for both server and client con-
nections required modifying ﬁve lines of code and was
accomplished in under ten minutes, with the developer
not being familiar with the code beforehand.
These efforts suggest that porting insecure programs to
use the SSA can be accomplished quickly and that port-
ing OpenSSL-using code to use the SSA can be relatively
easy, even without prior knowledge of the codebase.
5.5 Language Support
One of the beneﬁts of using the POSIX socket API as the
basis for the SSA is that it is easy to provide SSA support
to a variety of languages, which is in line with our fourth
design goal. This beneﬁt accrues if an implementation
of the SSA instruments the POSIX socket functionality
in the kernel through the system call interface, which all
network-using languages already rely upon. Any lan-
guage that uses the network must interface with network
system calls, either directly through machine instructions
808    27th USENIX Security Symposium
USENIX Association
or indirectly by wrapping another language’s implemen-
tation. Therefore, given an implementation in the kernel,
it is trivial to add SSA support to other languages that
have networking support. We describe how our imple-
mentation accomplishes this in Section 6.
To illustrate this beneﬁt, we have added SSA support
to three additional languages beyond C/C++: Python,
PHP, and Go. We chose these languages due to the fact
that each uses a different approach for requesting net-
work communication from the kernel. The modiﬁcations
required to provide SSA support for these languages are
as follows.
• Python: The reference implementation of the Python
interpreter is written in C and uses the POSIX socket
API for networking support. Adding SSA support to
Python required modiﬁcation of socketmodule.c,
which was done by merely adding SSA con-
stants (i.e., IPPROTO TLS and option values for
setsockopt/getsockopt.)
• PHP: The common PHP interpreter passes parame-
ters from its socket library directly to its system call
implementation. This means that modiﬁcation of the
interpreter isn’t strictly necessary to support the SSA;
applications can supply constants themselves to use
for IPPROTO TLS and the values for options. Adding
these values to the interpreter required the deﬁnition
of SSA constants.
• Go: Go is a compiled language and thus uses sys-
tem calls directly. Adding SSA support to Go merely
required adding a new constant, “tls”, and an asso-
ciated numerical value, to the net package of the
language. Go also provides functions to interface
with the setsockopt and getsockopt system calls
(e.g., SetsockoptInt), which allow light-weight
wrappers of options (e.g., setNoDelay) to be made.
Adding an SSA option function in a similar fash-
ion requires only 2-3 lines of Go code. With these
changes to the Go standard library, application de-
velopers can create a TLS socket by specifying “tls”
when they Dial a connection. To test and demon-
strate these changes, we ported Caddy [14], a popu-
lar Go-based HTTP/2 webserver, to the SSA for its
Internet connections.
Together these efforts illustrate the ease of adding SSA
support to various languages. The majority of the work
required is to deﬁne a few constants for existing system
calls or their wrappers.
5.6 TLS 1.3 0-RTT
TLS 1.3 provides a “0-RTT” mode, which allows clients
to resume an existing TLS session and provide appli-
cation data with a single TLS message. Used incor-
rectly this feature may be vulnerable to replay attacks,
Figure 2: Data ﬂow for traditional TLS library by net-
work applications. The application shown is using TCP.
but nonetheless offers a signiﬁcant latency beneﬁt when
employed correctly. The 0-RTT mode is unique in that
it combines connect and send operations. Fortunately,
the socket API has already been adapted to deal with
previous protocol changes that combined these opera-
tions, such as TCP Fast Open (TFO). TFO is supported
by clients via the sendto (or sendmsg) function with the
MSG FASTOPEN ﬂag. This allows the developer to specify
a destination for the connection and data to send using a
single function. TFO is supported by servers by setting
the TCP FASTOPEN option on their listening socket. Al-
ternatively, the TCP FASTOPEN CONNECT option allows
TFO client functionality using a lazy connect and sub-
sequent send. The SSA can support TLS 1.3 0-RTT us-
ing similar mechanisms, leveraging sendto with a ﬂag
or the TLS 0RTT socket option.
6
Implementation Details
We have developed a loadable Linux kernel module that
implements the Secure Socket API. Source code is avail-
able at owntrust.org.
A high-level view of a typical network application us-
ing a security library for TLS is shown in Figure 2. The
application links to the security library, such as OpenSSL
or GnuTLS, and then uses the POSIX Socket API to
communicate with the network subsystem in the kernel,
typically using a TCP socket.
A corresponding diagram, shown in Figure 3, illus-
trates how our implementation of the SSA compares to
this normal usage. We split our SSA implementation into
two parts: a kernel component and a user space encryp-
tion daemon accessible only to the kernel component. At
a high-level, the kernel component is responsible for reg-
istering all IPPROTO TLS functionality with the kernel
and maintaining state for each TLS socket. The kernel
component ofﬂoads the tasks of encryption and decryp-
tion to an encryption daemon, which uses OpenSSL and
USENIX Association
27th USENIX Security Symposium    809
Network ApplicaonSecurity LibraryKernelUserspaceNetworkNetwork SubsystemTCPUDPRAWPOSIX Socket APISystem Call BoundaryNetwork ApplicaonSecurity LibraryKernelUserspaceNetworkNetwork SubsystemTCPUDPRAWPOSIX Socket APISystem Call Boundaryplaintext application data to the user space daemon for
encryption, and the encrypted data are then transmitted
to the intended remote endpoint. In the reverse direction,
encrypted data from the remote endpoint are decrypted
by the daemon and then sent to the kernel to be deliv-
ered to the client application. The user space encryption
daemon is a multi-process, event-driven service that in-
teracts with the OpenSSL library to perform TLS opera-
tions. The kernel load balances TLS connections across
active daemon processes to take advantage of the paral-
lelism provided by multicore CPUs.
To accomplish its tasks, the kernel component must
inform the daemon of important events triggered by ap-
plication system calls. A selection of these events and
their descriptions are as follows:
• Socket creation When a TLS socket is created by
an application, the kernel informs the daemon that it
must create a corresponding socket of the appropri-
ate transport protocol, known as the external socket.
Unknown to the application, this external socket is
used for direct communication with the intended re-
mote host. The TLS socket created by the applica-
tion, known as the internal socket, is used to transfer
plaintext data to and from the daemon.
• Binding After TLS socket creation, an application
may choose to call bind on that socket, requesting
that the socket use the speciﬁed source address and
port. Since the daemon interfaces directly with re-
mote hosts, the kernel directs the daemon to bind on
the external socket.
• Connecting When an application calls connect, the
kernel informs the daemon to connect its external
socket to the address speciﬁed by the application, and
then connects the internal socket to the daemon.
• Listening Server applications may call listen on
their socket. In this case, the kernel informs the dae-
mon of this action, and both the external and internal
socket are placed into listening mode.
• Socket options Throughout a TLS socket’s life-
time, an application may wish to use setsockopt
or getsockopt to assign and retrieve information
about various socket behaviors. Notiﬁcation of these
options and their values is provided by the kernel
to the daemon. Setting socket options with level
IPPROTO TLS are directly handled by the daemon,
which appropriately sets and retrieves TLS state de-
pending on the requested option. Setting options at
other levels, such as IPPROTO TCP or SOL SOCKET,
are performed on both internal and external sockets,
where appropriate.
Handling of these application requests using the en-
cryption daemon is done in a manner invisible to the ap-
plication. Special care is given to error returns and state
to guarantee consistency between external and internal
Figure 3: Data ﬂow for SSA usage by network applica-
tions. The application shown is using the TLS (which
uses TCP internally for connection-based SOCK STREAM
sockets).
obeys administrator preferences.
Note that our prototype implementation moves the use
of a security library to the encryption daemon. The ap-
plication interacts only with the POSIX Socket API, as
described in Section 5, and the encryption daemon estab-
lishes TLS connections, encrypts and decrypts data, im-