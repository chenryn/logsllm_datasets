# 【iOS安全系列】iOS 8.1.2 越狱过程详解及相关漏洞分析
|
##### 译文声明
本文是翻译文章，文章来源：360安全播报
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
本文主要介绍了:1、自己对越狱的理解;2、iOS 8.1.2
越狱工具的工作过程;3、越狱过程所使用的漏洞;4、每个漏洞的利用方法。希望通过这篇文章让大家了解越狱的过程,越狱需要的漏洞类型以及一些利用技巧,具体内容如下。
**什么是越狱**
要说明什么是越狱,我们首先来看下越狱后可以做哪些原来做不了的事情:
1、安装任意签名的普通应用和系统应用;
2、安装 SSH;
3、添加命令行程序;
4、添加 Daemon;
5、任意添加、删除文件;
6、获取任意 Mach Task;
7、伪造 Entitlements;
8、使内存页同时具有可写、可执行属性;
9、……
如上的列表给出了越狱后才可以在 iDevice 做的事情,如果单从表象上去罗列,这个列表可以很长,下面我们从技术方面来做下归纳,具体看看破坏了 iOS
系统的哪些保护机制才可以做到上面的事情:
1、破坏代码签名机制;
2、破坏对内存页的保护机制(W+X);
3、破坏对磁盘分区(/dev/disk0s1s1)的保护;
4、破坏Rootless 保护机制,主要用于保护系统的完整性;
因此,越狱中“狱”只要指 iOS 的如上三条保护机制,越狱是指破坏这些保护机制。
**确定目标**
越狱的过程实际上就是攻击 iOS 系统的过程,在发起攻击之前我们首先需要确定攻击的目标,当然从大的方面来说目标就是 iOS
系统,但是这个目标太大了不足以引导攻击过程,我们需要更确切的目标。如何确定确切的攻击目标?我们只要找到系统的哪些部分负责相关的保护机制便可以确定最终的攻击目标,下面是个人总结的攻击目标:
1、内核、amfid、libmiss.dylib:三者配合实现了代码签名;
2、内核:对内存页属性的保护完全在内核中实现;
3、获取 root 权限:重新 mount 磁盘分区需要 root 权限;
当然在攻击最终的目标之前,我们还会遇到一些阻碍(系统有多道防线),这些阻碍可以作为阶段目标,不同的攻击路径所遇到的阶段目标也不同,但是通过 USB
发起的攻击首先需要突破沙盒,因此沙盒也是一个重要的目标。
如上是个人对越狱的理解,下面会以 iOS 8.1.2 的越狱为例来详细描述下攻击过程,所使用的漏洞,以及漏洞的利用方法。
**攻击概述**
对于通过 USB 发起的攻击首先要解决的一个问题是如何突破沙盒。这里的沙盒不单单指由 Sandbox.kext
约束的进程行为,而是广义上的概念,比如可以将整个 iOS 理解为一个沙盒。默认沙盒只是开启了如下几个服务:
[](http://nirvan.360.cn/blog/wp-content/uploads/2016/01/iOSJB812-ServiceList.png)
图1 :沙盒开启的服务
iOS 8.1.2 的越狱工具利用 Mobile Backup 的漏洞(CVE-2015-1087) 与 AFC
的漏洞(CVE-2014-448)来过沙盒,然后利用 Image Mounter
的漏洞(CVE-2015-1062)来为用户空间的任意代码执行创造条件。如果想在用户空间执行任意代码,需要解决代码签名验证问题,越狱工具利用 dyld
的漏洞(CVE-2014-4455)解决了让 afmid 加载假的 libmiss.dylib
的问题,从而过掉了代码签名。这样用户空间任意代码执行的条件都具备了,接下来越狱工具通过一个辅助工具(root权限)来执行 Untecher,Untether
的主要工作内容是首先重新 mount 磁盘的只读分区到可写状态,然后将 /var/mobile/Media 中的 Payload
拷贝到系统的相关目录。接下来 Untether 行为主要是攻击内核,这里主要有两种方式:
方式一:
首先利用内核漏洞(CVE-2014-4491)得到内核的起始地址,KASLR 的 Slide,然后结合内核漏洞(CVE-2014-4496)和
IOHIDFamily 的漏洞(CVE-2014-4487)来制造内核空间任意代码执行、内核写,接下来利用 Kernel Patch Finder
找到如上提到的保护机制的代码点以及一些 ROP Gadgets,构造 ROP Chain 来 Patch 内核。
方式二:
首先利用内核漏洞(CVE-2014-4496)得到 KASLR 的 Slide,然后利用 IOHIDFamily 的漏洞(CVE-2014-4487)
构造一个内核任意大小读的利用,读取某个已知对象的虚函数表,进而计算出内核加载的基地址,接下来与方式一相同。相当于方式二可以少利用一个漏洞。
如上是对整个越狱过程的大概描述,为的是让大家有一个大致的印象,接下来会介绍详细的越狱攻击过程。
**攻击过程**
**一、突破沙盒**
**相关漏洞**
**CVE-2014-4480**
**AppleFileConduit – Fixed in iOS 8.1.3**
Available for: iPhone 4s and later, iPod touch (5th generation) and later,
iPad 2 and later
Impact: A maliciously crafted afc command may allow access to protected parts
of the filesystem
Description: **A vulnerability existed in the symbolic linking mechanism of
afc**.This issue was addressed by adding additional path checks.
CVE-ID
**CVE-2014-4480** : TaiG Jailbreak Team  
---  
表1:CVE-2014-4480
**CVE-2015-1087**
**Backup – Fixed in iOS 8.3**
Available for: iPhone 4s and later, iPod touch (5th generation) and later,
iPad 2 and later
Impact: An attacker may be able to use the backup system to access restricted
areas of the file system
Description: **An issue existed in the relative path evaluation logic of the
backup system**.This issues was addressed through improved path evaluation.
CVE-ID
**CVE-2015-1087** : TaiG Jailbreak Team  
---  
表2:CVE-2015-1087
**准备目录结构**
利用 AFC 服务创建目录、文件、软链接:
1\. 创建目录:
PublicStaging/cache/mmap
__proteas_ex__/a/b/c
__proteas_ex__/var/mobile/Media/PublicStaging/cache
__proteas_mx__/a/b/c/d/e/f/g
__proteas_mx__/private/var
2\. 创建空文件:
__proteas_ex__/var/mobile/Media/PublicStaging/cache/mmap
__proteas_mx__/private/var/run
3\. 创建软链接:
__proteas_ex__/a/b/c/c -> ../../../var/mobile/Media/PublicStaging/cache/mmap
__proteas_mx__/a/b/c/d/e/f/g/c -> ../../../../../../../private/var/run  
---  
表3:目录结构
[](http://nirvan.360.cn/blog/wp-content/uploads/2016/01/iOSJB812-CreateDirLog.png)
图2:创建目录的日志
这里利用的是 CVE-2014-4480,在修补后的设备上,比如:iOS 8.3 上,创建如上的目录的结构 AFC 会报错:
afcd[395] :
AFCFileLine=”1540″
AFCFileName=”server.c”
AFCCode=”-402636793″
NSDescription=” **Request path cannot contain dots** :
../../../var/mobile/Media/PublicStaging/cache/mmap”
AFCVersion=”232.5″  
---  
表4:AFC 报错信息
**触发备份恢复**
我们先看下触发备份恢复的结果:
iPhone5s:~ root# ls -al /var/run/mobile_image_mounter
lrwxr-xr-x 1 mobile mobile 50 Jun 26 17:29
**/var/run/mobile_image_mounter - >
../../../var/mobile/Media/PublicStaging/cache/mmap**  
---  
表5:备份恢复的结果
在 mount DDI 时会生成一些临时目录,利用备份恢复的漏洞,这个临时目录被暴露到 Media 的子目录中,从而为利用 DDI 的漏洞创造条件。
1848 BackupAgent Chowned /private/var/.backup.i/var/Keychains
1848 BackupAgent Created dir /private/var/.backup.i/var/Managed Preferences
1848 BackupAgent Created dir /private/var/.backup.i/var/Managed
Preferences/mobile
1848 BackupAgent Chowned /private/var/.backup.i/var/Managed Preferences/mobile
1848 BackupAgent Created dir /private/var/.backup.i/var/MobileDevice
1848 BackupAgent Created dir
/private/var/.backup.i/var/MobileDevice/ProvisioningProfiles
1848 BackupAgent Chowned
/private/var/.backup.i/var/MobileDevice/ProvisioningProfiles
1848 BackupAgent Created dir /private/var/.backup.i/var/mobile/Media
1848 BackupAgent Created dir /private/var/.backup.i/var/mobile/Media/PhotoData
1848 BackupAgent **Renamed
/private/var/mobile/Media/__proteas_mx__/a/b/c/d/e/f/g/c
/private/var/.backup.i/var/mobile/Media/PhotoData/c**
1848 BackupAgent Chowned /private/var/run
1848 BackupAgent Chowned /private/var/run
1848 **Renamed /private/var/mobile/Media/__proteas_ex__/a/b/c/c
/private/var/run/mobile_image_mounter**
1848 Chowned /private/var/mobile/Media/PublicStaging/cache/mmap  
---  
表6:备份恢复的日志
关于 CVE-2015-1087 苹果的说明非常简单,但是写出 PoC 后发现还是相对比较麻烦的,编写利用时需要注意:
1、如果利用 libimobiledevice 来写利用的话,需要重写 mobilebackup_client_new,以便控制版本号交换,否则无法启动
BackupAgent。
2、需要自己根据 Mobile Backup 的协议构造恶意 Payload(PList 数据),从而使 BackupAgent 创建如上的链接。
3、使用 mobilebackup_send 发送 PList,使用 mobilebackup_receive 接收响应,并判断是否执行成功。
为了方便大家调试,给出一个打印 plist 内容的函数:
|
    //-- Debug
    void debug_plist(plist_t plist)
    {
        if (!plist) {
            printf("[-] debug_plist: plist handle is NULLn");
            return;
        }
        char *buffer = NULL;
        uint32_t length = 0;
        plist_to_xml(plist, &buffer, &length);
        if (length == 0) {
            printf("[-] debug_plist: length is zeron");
            return;
        }
        char *cstr = (char *)malloc(length + 1);
        memset(cstr, 0, length + 1);
        memcpy(cstr, buffer, length);
        printf("[+] DEBUG PLIST:n");
        printf("--------------------------------------------n");
        printf("%sn", cstr);
        printf("--------------------------------------------n");
        free(buffer);
        free(cstr);
    }  
---|---  
表7:代码 debug plist
**当前进程**
至此,通过对上面两个漏洞的利用,把 Image Mounter 在 mount dmg 时的临时目录暴露到了
/var/mobile/Media/PublicStaging/cache/mmap,为下一步利用 DDI 的漏洞做好了准备。
**二、利用 DDI 的漏洞**
**相关漏洞**