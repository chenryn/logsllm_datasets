把A作为类类型，使用ref修饰符，传递对引用的引用（在C++术语中，是一个指向指
针的指针），它允许分配一个新对象，Main（）方法显示了结果3：
    public static void ChangeA(ref A a)
    {
      a.X = 2;
      a = new A { X = 3 };
    }
最后，一定要理解，C#对传递给方法的参数继续应用初始化要求。任何变量传递给
方法之前，必须初始化，无论是按值还是按引用传递。
3.6.2 out参数
如果方法返回一个值，该方法通常声明返回类型，并返回结果。如果方法返回多个
值，可能类型还不同，该怎么办？这有不同的选项。一个选项是声明类和结构，把应该返
回的所有信息都定义为该类型的成员。另一个选项是使用元组类型。第三个选项是使用
out关键字。
下面的例子使用通过Int32类型定义的Parse方法。ReadLine方法获取用户输入的字符
串。假设用户输入一个数字，int.Parse方法把它转换为字符串，并返回该数字（代码文件
OutKeywordSample /Program.cs）：
    string input1 = ReadLine();
    int n = int.Parse(input1);
    WriteLine($"n: {n}");
然而，用户并不总是输入希望他们输入的数据。如果用户没有输入数字，就会抛出一
个异常。当然，可以捕获异常，并相应地处理用户，但“正常”情况不这么做。也许可以认
为，“正常”情况就是用户输入了错误的数据。处理异常参见第14章。
要处理类型错误的数据，更好的方法是使用Int32类型的另一个方法：TryParse。
TryParse声明为无论解析成功与否，都返回一个bool类型。解析的结果（如果成功）是使
用out修饰符返回一个参数：
    public static bool TryParse(string s, out int result);
调用这个方法，result变量需要在调用这个方法之前定义。使用out参数，变量不需要
预先初始化，变量在方法中初始化。类似于ref关键字，out关键字也需要在调用方法时提
供，而不仅仅在声明方法时提供：
    string input2 = ReadLine();
    int result;
    if (int.TryParse(input2, out result)
)
    {
      WriteLine($"n: {n}");
    }
    else
    {
      WriteLine("not a number");
    }
3.7 可空类型
引用类型（类）的变量可以为空，而值类型（结构）的变量不能。在一些情况下，这
可能是一个问题，如把C#类型映射到数据库或XML类型。数据库或XML数量可以为空，
而int或double不能为空。
处理这个冲突的一个方法是使用映射到数据库数字类型的类（这由Java实现）。使用
引用类型，映射到允许空值的数据库数字，有一个重要的缺点：它带来了额外的开销。对
于引用类型，需要垃圾收集器进行清理。值类型不需要用垃圾收集器清理；变量超出作用
域时，从内存中删除。
C#有一个解决方案：可空类型。可空类型是可以为空的值类型。可空类型只需要在
类型的后面添加“？”（它必须是结构）。与基本结构相比，值类型唯一的开销是一个可以
确定它是否为空的布尔成员。
在下面的代码片段中，x1是一个普通的int, x2是一个可以为空的int。因为x2是可以为
空的int，所以可以把null分配给x2：
    int x1 = 1;
    int? x2 = null;
因为int值可以分配给int?，所以给int？传递一个int变量总是会成功，编译器会接受
它：
    int? x3 = x1;
反过来是不正确的。int？不能直接分配给int。这可能失败，因此需要一个类型转
换：
    int x4 = (int)x3;
当然，如果x3是null，类型转换操作就会生成一个异常。更好的方法是使用可空类型
的HasValue和Value属性。HasValue返回true或false，这取决于可空类型是否有值，Value
返回底层的值。使用条件操作符填充x5，不会抛出异常。如果x3是null, 
HasValue就返回
false，这里给变量x5提供-1：
    int x5 = x3.HasValue
 ? x3.Value
 : -1;
使用合并操作符，可空类型可以使用较短的语法。如果x3是null，则用变量x6给它设
置-1，否则提取x3的值：
    int x6 = x3 ??
 -1;
  注意： 对于可空类型，可以使用能用于基本类型的所有可用操作符，例如，
可用于int？的+、-、*、/等。每个结构类型都可以使用可空类型，而不仅是预定义的C#
类型。
3.8 枚举
枚举是一个值类型，包含一组命名的常量，如这里的Color类型。枚举类型用enum关
键字定义（代码文件EnumSample/Color. cs）：
    public enum Color
    {
      Red,
      Green,
      Blue
    }
可以声明枚举类型的变量，如变量c1，用枚举类型的名称作为前缀，设置一个命名常
量，来赋予枚举中的一个值（代码文件EnumSample/Program.cs）：
    Color c1 = Color.Red;
    WriteLine(c1);
运行程序，控制台输出显示Red，这是枚举的常量值。
默认情况下，enum的类型是int。这个基本类型可以改为其他整数类型（byte、short、
int、带符号的long和无符号变量）。命名常量的值从0开始递增，但它们可以改为其他
值：
    public enum Color : short
    {
      Red = 1,
      Green = 2,
      Blue = 3
    }
使用强制类型转换可以把数字改为枚举值，把枚举值改为数字。
    Color c2 = (Color)2;
    short number = (short)c2;
还可以使用enum类型把多个选项分配给一个变量，而不仅仅是一个枚举常量。为
此，分配给常量的值必须是不同的位，Flags属性需要用枚举设置。
枚举类型DaysOfWeek为每天定义了不同的值。要设置不同的位，可以使用用0x前缀
指定的十六进制值轻松地完成，Flags属性是编译器创建值的另一个字符串表示的信息，
例如给DaysOfWeek的一个变量设置值3，结果是Monday，如果使用Flags属性，结果就是
Tuesday（代码文件EnumSample/ DaysOfWeek.cs）：
    [Flags]
    public enum DaysOfWeek
    {
      Monday = 0x1,
      Tuesday = 0x2,
      Wednesday = 0x4,
      Thursday = 0x8,
      Friday = 0x10,
      Saturday = 0x20,
      Sunday = 0x40
    }
有了这个枚举声明，就可以使用逻辑或运算符为一个变量指定多个值（代码文件
EnumSample /Program.cs）：
    DaysOfWeek mondayAndWednesday = DaysOfWeek.Monday | DaysOfWeek.Wednesday;
    WriteLine(mondayAndWednesday);
运行程序，输出日期的字符串表示：
    Monday, Tuesday
设置不同的位，也可以结合单个位来包括多个值，如Weekend的值0x60是用逻辑或运
算符结合了Saturday和Sunday。Workday则结合了从Monday到Friday的所有日子，AllWeek
用逻辑或运算符结合了Workday和Weekend （代码文件EnumSample / DaysOfWeek.cs）：
    [Flags]
    public enum DaysOfWeek
    {
      Monday = 0x1,
      Tuesday = 0x2,
      Wednesday = 0x4,
      Thursday = 0x8,
      Friday = 0x10,
      Saturday = 0x20,
      Sunday = 0x40,
      Weekend = Saturday | Sunday
      Workday = 0x1f,
      AllWeek = Workday | Weekend
    }
有了这些代码，就可以把DaysOfWeek.Weekend直接分配给变量，指定用逻辑或运算
符结合DaysOfWeek.Saturday和DaysOfWeek.Sunday的单个值，也可以得到相同的结果。输
出会显示Weekend的字符串表示。
    DaysOfWeek weekend = DaysOfWeek.Saturday | DaysOfWeek.Sunday;
    WriteLine(weekend);
使用枚举，类Enum有时非常有助于动态获得枚举类型的信息。枚举提供了方法来解
析字符串，获得相应的枚举常数，获得枚举类型的所有名称和值。
下面的代码片段使用字符串和Enum.TryParse来获得相应的Color值（代码文件
EnumSample/Program.cs）：
    Color red;
    if (Enum.TryParse("Red", out red))
    {
      WriteLine($"successfully parsed {red}");
    }
  注意： Enum.TryParse （）是一个泛型方法，其中T是泛型参数类型。这
个参数类型需要用方法调用定义。
Enum.GetNames方法返回一个包含所有枚举名的字符串数组：
    foreach (var day in Enum.GetNames(typeof(Color)))
    {
      WriteLine(day);
    }
运行应用程序，输出如下：
    Red
    Green
    Blue
为了获得枚举的所有值，可以使用方法Enum.GetValues。Enum.GetValues返回枚举值
的一个数组。为了获得整数值，需要把它转换为枚举的底层类型，为此应使用foreach语
句：
    foreach (short
 val in Enum.GetValues(typeof(Color))
)
    {
      WriteLine(val);
    }
3.9 部分类
partial关键字允许把类、结构、方法或接口放在多个文件中。一般情况下，某种类型
的代码生成器生成了一个类的某部分，所以把类放在多个文件中是有益的。假定要给类添
加一些从工具中自动生成的内容。如果重新运行该工具，前面所做的修改就会丢失。
partial关键字有助于把类分开放在两个文件中，而对不由代码生成器定义的文件进行修
改。
partial关键字的用法是：把partial放在class、struct或interface关键字的前面。在下面的
例子中，SampleClass类驻留在两个不同的源文件SampleClassAutogenerated.cs和
SampleClass.cs中：
    //SampleClassAutogenerated.cs
    partial class SampleClass
    {
      public void MethodOne() { }
    }
    //SampleClass.cs
    partial class SampleClass
    {
      public void MethodTwo() { }
    }
编译包含这两个源文件的项目时，会创建一个SampleClass类，它有两个方法
MethodOne（）和MethodTwo（）。
如果声明类时使用了下面的关键字，则这些关键字就必须应用于同一个类的所有部
分：
● public
● private
● protected
● internal
● abstract
● sealed
● new
● 一般约束
在嵌套的类型中，只要partial关键字位于class关键字的前面，就可以嵌套部分类。在
把部分类编译到类型中时，属性、XML注释、接口、泛型类型的参数属性和成员会合
并。有如下两个源文件：
    // SampleClassAutogenerated.cs
    [CustomAttribute]
    partial class SampleClass: SampleBaseClass, ISampleClass
    {
      public void MethodOne() { }
    }
    // SampleClass.cs
    [AnotherAttribute]
    partial class SampleClass: IOtherSampleClass
    {
      public void MethodTwo() { }
    }
编译后，等价的源文件变成：
    [CustomAttribute]
    [AnotherAttribute]
    partial class SampleClass: SampleBaseClass, ISampleClass, IOtherSampleClass
    {
      public void MethodOne() { }
      public void MethodTwo() { }
    }
  注意： 尽管partial关键字很容易创建跨多个文件的巨大的类，且不同的开发
人员处理同一个类的不同文件，但该关键字并不用于这个目的。在这种情况下，最好
把大类拆分成几个小类，一个类只用于一个目的。
部分类可以包含部分方法。如果生成的代码应该调用可能不存在的方法，这就是非常
有用的。扩展部分类的程序员可以决定创建部分方法的自定义实现代码，或者什么也不
做。下面的代码片段包含一个部分类，其方法MethodOne调用APartialMethod方法。
APartialMethod方法用partial关键字声明；因此不需要任何实现代码。如果没有实现代码，
编译器将删除这个方法调用：
    //SampleClassAutogenerated.cs
    partial class SampleClass
    {
      public void MethodOne()
      {
        APartialMethod();
      }
      public partial void APartialMethod();
    }
部分方法的实现可以放在部分类的任何其他地方，如下面的代码片段所示。有了这个
方法，编译器就在MethodOne内创建代码，调用这里声明的APartialMethod：
    // SampleClass.cs
    partial class SampleClass: IOtherSampleClass
    {
      public void APartialMethod()
      {
        // implementation of APartialMethod
      }
    }
部分方法必须是void类型，否则编译器在没有实现代码的情况下无法删除调用。
3.10 扩展方法
有许多扩展类的方式。继承就是给对象添加功能的好方法。扩展方法是给对象添加功
能的另一个选项，在不能使用继承时，也可以使用这个选项（例如类是密封的）。
  注意： 扩展方法也可以用于扩展接口。这样，实现该接口的所有类就有了公
共功能。
扩展方法是静态方法，它是类的一部分，但实际上没有放在类的源代码中。
假设希望用一个方法扩展string类型，该方法计算字符串中的单词数。GetWordCount
方法利用String.Split方法把字符串分割到字符串数组中，使用Length属性计算数组中元素
的个数（代码文件ExtensionMethods / Program.cs）：
    public static class StringExtension
    {
      public static int GetWordCount(this string s) =>
        s.Split().Length;
    }
使用this关键字和第一个参数来扩展字符串。这个关键字定义了要扩展的类型。
即使扩展方法是静态的，也要使用标准的实例方法语法。注意，这里使用fox变量而
没有使用类型名来调用GetWordCount （）。
    string fox = "the quick brown fox jumped over the lazy dogs down " +
        "9876543210 times";
    int wordCount = fox.GetWordCount();
    WriteLine($"{wordCount} words");
在后台，编译器把它改为调用静态方法：
    int wordCount = StringExtension.GetWordCount(fox);
使用实例方法的语法，而不是从代码中直接调用静态方法，会得到一个好得多的语
法。这个语法还有一个好处：该方法的实现可以用另一个类取代，而不需要更改代码——
只需要运行新的编译器。
编译器如何找到某个类型的扩展方法？this关键字必须匹配类型的扩展方法，而且需
要打开定义扩展方法的静态类所在的名称空间。如果把StringExtensions类放在名称空间