is the signature of A on T2 (excluding the wit field
witness sigK(A)
itself), as required by T1.out(0).
If T1 is on the blockchain and its out(0) is unspent, A can update
the blockchain by appending T2. This moves v0B1 from T1 to T2.
The transaction T2 has only one output, which can be redeemed by
any transaction providing a witness having hash k. The time t in
T2.absLock represents the earliest moment when T2 can be put on
the blockchain. A subsequent transaction can redeem (v1 + v0)B in
a single shot. This requires two inputs, (T1, 1) and (T2, 0), and two
witnesses. The witness associated to the first input is a signature of
B; the other is a preimage of k.
We assume that Bitcoin uses secure cryptographic primitives,
i.e. ideal hash functions (which hereafter are modelled according
to the random oracle model [21]), and a digital signature scheme
which is robust against existential forgery attacks.
Blockchain. A blockchain B is a sequence (T0, t0) · · · (Tn, tn ),
where T0 · · · Tn are transactions (T0 is the coinbase transaction, i.e.
T0.in = ⊥, meaning that is does not point to a previous transaction),
and t0 · · · tn are timestamps, with ti ≤ tj for all i ≤ j. Hereafter,
we assume that blockchains are append-only, without forks, and
consistent, i.e. obtained by appending transactions that respect the
Bitcoin protocol (as formalised in [16]). Essentially, these ideal
properties are coherent with the results in [17, 34, 40], as long as
the adversary does not control a very large mining pool [13, 33].
1In the actual Bitcoin, the value the outputs of T2 must be strictly smaller than v0, and
the difference is paid to the Bitcoin network. For simplicity, in this paper (as in [16])
we neglect these transaction fees.
8
Computational runs. We now introduce the computational coun-
terparts of symbolic runs. These are sequences of computational
labels λc, namely bitstrings encoding one of the following actions,
where A ∈ Part ∪ {Adv}, and m is a bitstring:
A → ∗ : m A broadcasts message m
T
δ
append a Bitcoin transaction to the blockchain
perform a delay
To compute the hash of a message m, A sends m to the oracle
O (cid:60) Part, and waits for the reply H (m). Also these actions are
included in the computational labels. Note that reliable message
broadcasts can be effectively obtained through the Bitcoin network.
We postulate that a computational run begins with a coinbase
transaction T0, followed by the broadcasts of the public keys of all
participants. Each A has two key pairs: KA for signing messages,
and ˆKA for redeeming deposits. For each A (either honest or not), we
assume that T0 has an output redeemable with the private key ˆKs
.
A
In this way, each participant starts with some funds (possibly 0), and
knows the public keys of the others. By extracting the transactions
from a computational run Rc, and assigning their time according to
the accumulated delays, we obtain a blockchain, denoted as BRc .
Stripping. Analogously to the stripping of symbolic runs, we
define the A-stripping of a computational run Rc as the run obtained
by removing from Rc all the messages not visible by A, i.e. the
messages between O and some other B (cid:44) A.
Computational participant strategies. We now introduce the
computational counterparts of symbolic strategies. A computational
strategy Σc
for A is a PPTIME algorithm which receives as input
A
a (A-stripped) computational run Rc∗, and outputs is a finite set of
computational labels. The choice among these labels is controlled
by the adversary strategy, specified below. We impose a few sanity
constraints: (i) we forbid A to impersonate another participant;
(ii) if the strategy outputs a transaction T, then T must be a consis-
tent update of the blockchain BRc∗ obtained from the run in input,
and all the witnesses of T have already been broadcast in the run;
(iii) finally, strategies must be persistent, similarly to the symbolic
case. The condition on the witnesses of T in (ii) is not a limitation,
since these witnesses become public once T is broadcast on the
Bitcoin network. We put this condition since it helps to obtain a
sharp correspondence between computational and symbolic runs:
indeed, the symbolic counterpart of broadcasting a witness is to
give an authorization.
Computational adversary strategies. A computational adver-
sary strategy Σc
is a PPTIME algorithm taking as input a (Adv-
stripped) computational run Rc∗ and the moves chosen by each
honest participant. The strategy gives as output a single computa-
tional label, to be appended to the run. We require Σc
to obey
sanity constraints similar to those of participants strategies, with
two differences: (i) Adv can impersonate any other participant (ex-
cept the oracle O); (ii) Adv can perform a time delay only if all the
honest participants agree.
This assumption prevents the adversary from delaying the ac-
tions of honest participants, who can therefore always meet their
deadlines, without interference by the adversary. Note that, even if
the adversary controlled a large portion of the mining power of the
Adv
Adv
Adv
Bitcoin network — so being able to delay the transactions sent by
honest participants — honest participants could still protect them-
selves by setting far enough deadlines in their contracts, making
the delay attacks ineffective2.
Computational conformance. For each participant A, we in-
dicate with rA the stream of random bits implicitly used by Σc
.
A
Similarly, we indicate with rO the stream available to the oracle.
Fixing a set of computational strategies Σc — both for the honest
participants and for the adversary — and a function r from partici-
pants to streams, we obtain a unique computational run, made by
the sequence of actions chosen by Σc
when taking as input the
outputs of the honest participants’ strategies, and enforcing that
the queries to the oracle are always answered. We say that this run
is conformant to Σc and r.
7 COMPILING BITML TO BITCOIN
We now describe how to implement BitML on top of Bitcoin. This
is done by compiling BitML contract advertisements {G}C into a fi-
nite set Tof Bitcoin transactions3, signed by all participants (except
from those whose authorizations are required after stipulation, via
A :· · ·). In Bitcoin, appending (a subset of) these transactions to
the blockchain mimics, in BitML, the semantics of {G}C (assuming,
as usual, that at least one participant is honest). More precisely, the
first transaction in Tto be published (called Tinit), redeems all the
permanent deposits, correspondingly to the stipulation of {G}C.
After that, Tinit can only be redeemed by one of the transactions in
Twhich corresponds to the subsequent computation step of ⟨C , v⟩
in BitML. This is enforced by requiring, in the output script of Tinit,
suitable signatures by all the participants involved in {G}C. The
same principle is followed for the other transactions in T: they
can be appended to the blockchain only when this corresponds
to a computation step in BitML. The only transactions in Tthat
can be redeemed by transactions not in Tare those which corre-
spond to the deposits ⟨A, v⟩ obtained by reducing a withdraw A
contract. Indeed, these transactions can be redeemed by standard
transactions signed by A.
We illustrate the compiler through a series of examples, which
cover all the primitives of BitML. We refer to Appendix A.5 for a
formal definition and further examples.
Before running the compiler, participants generate the following
key pairs, and exchange their public parts:
• K(A), used in the compilation of a withdraw A contract.
We exploit this to guarantee that the deposit obtained after
the execution of withdraw A can be redeemed with a
signature of A (using the private part of K(A)).
• K(D , A) (for each subterm D of C), used in the compilation
of the subterms of C of the form D +C ′ to enable the firing
of the (initial) action in the D branch. The private part of
2For the sake of simplicity, we do not model such delays. At the price of adding
further complexity, we could extend our model to relax this assumption, by allowing
the adversary to perform delays under reasonable constraints. As long as the same
delays are allowed in both the symbolic and computational models, computational
soundness still holds. In such extended model, deadlines in contracts must be chosen
so to compensate for these delays.
3 An implementation of the BitML compiler is under way, at https://github.com/
bitml-lang/bitml-compiler. This implementation generates standard Bitcoin transac-
tions by exploiting our BALZaC tool [8]. This is crucial, since the Bitcoin network
currently discards non-standard transactions.
K(D , A) is used to compute the witness of the transaction
corresponding to the compilation of D.
For a set of participants P = {A1, . . . , An}, we denote with
K(D , P ) the set of key pairs {K(D , A1), . . . , K(D , An )}.
Withdraw. As a first example, we show how to compile:
{G}C = {A:! 1B @ x | B:! 1B @ y} withdraw B
The transactions obtained from the compiler are the following,
where Tx is the transaction associated to A’s deposit ⟨A, 1B⟩x and
Ty is the transaction associated to B’s deposit ⟨B, 1B⟩y:
TB
Tinit
, 1 (cid:55)→ sigK(B)
in: 0 (cid:55)→ Tx , 1 (cid:55)→ Ty
in: Tinit
wit: 0 (cid:55)→ sigK(A)
wit: sigK(withdraw B,{A,B})
out: (λ⃗ς . versigK(withdraw B,{A,B}) (⃗ς ), 2B)
out: (λς . versigK(B) (ς ), 2B)
In BitML, the stipulation of the contract requires a few steps:
⟨A, 1B⟩x | ⟨B, 1B⟩y | {G}C
−→4⟨A, 1B⟩x | ⟨B, 1B⟩y | {G}C | A[x ▷ {G}C] | B[y ▷ {G}C]
| A[# ▷ {G}C] | B[# ▷ {G}C] = Γ
In Bitcoin, these steps correspond to obtaining the transactions
above from the compiler, and exchanging the signatures shown
there (signing Tinit last). The BitML authorization A[x ▷ {G}C]
corresponds to the broadcast of A’signature in the first witness of
Tinit. The authorization A[# ▷ {G}C] in this case is immaterial: in
general, it corresponds to the commit of A’s secrets. The autho-
rizations B[y ▷ {G}C] and B[# ▷ {G}C] are similar, for B. In BitML,
the stipulation is then completed with the following step:
Γ −→ ⟨withdraw B , 2B⟩
In Bitcoin, this corresponds to appending Tinit to the blockchain,
which redeems Tx and Ty. The last computation step in BitML is:
⟨withdraw B , 2B⟩ −→ ⟨B, 2B⟩z
In Bitcoin, this corresponds to appending TB to the blockchain,
4. After that, 2B are under B’s con-
which redeems 2B from Tinit
trol, since the output script of TB only requires B’s signature. The
unspent transaction TB corresponds to the BitML deposit ⟨B, 2B⟩z.
Note that, during the stipulation phase, it is crucial to exchange
the signatures on Tinit after the ones on TB, otherwise we would lose
the correspondence with the BitML semantics. Indeed, were Tinit
signed first, A could refuse to sign TB, and yet be able to complete
the stipulation, by appending Tinit to the blockchain. Then, B would
be prevented to append TB, i.e. the Bitcoin counterpart of the BitML
withdraw B action, which would transfer 2B to him.
Authorizations. We exploit the previous example to illustrate the
compilation of authorizations. Compiling A : withdraw B requires
only minor changes: in the witness of TB, the compiler only inserts
B’s signature sigK(A : withdraw B,B)
, while the output script of Tinit
still requires both signatures, so to prevent TB from being appended
4 Note that in the example above, an optimized version of our compiler could omit the
transaction Tinit, and transfer the deposit to B directly through TB (with the in field as
in Tinit). However, this optimization is only possible when withdraw does not occur
within a choice; further, the semantics of withdraw should be revised accordingly to
preserve computational soundness. For the sake of simplicity, we prefer to ignore this
optimization in the definition of our compiler.
9
the blockchain before obtaining A’s authorization. In BitML, to
perform the withdraw action, A must authorize it:
Γ −→ Γ | A[A : withdraw B]
In Bitcoin, this step corresponds to broadcasting A’s signature
. After that, the signature can be added to the
sigK(A : withdraw B,A)
witness of TB, which can now be appended to the blockchain.
After. Similarly, compiling after t : withdraw B requires only
a small change to our first example: the transaction TB now has an
absLock field set to time t. In this way, TB can not be appended to
the blockchain until time t — coherently to the BitML semantics,
where the withdraw B action can not be fired until such time.
Split. To illustrate the compilation of the split primitive, let:
Cs = split (1B → withdraw A | 2B → withdraw B )
Compiling {A:! 2B @ x | B:! 1B @ y} Cs produces the following
transactions, where Tx and Ty correspond to the deposits ⟨A, 2B⟩x
and ⟨B, 1B⟩y, and KW p = K(withdraw p, {A, B}) for p ∈ {A, B}:
Tinit
in: 0 (cid:55)→ Tx , 1 (cid:55)→ Ty
wit: 0 (cid:55)→ sigK(A)
out: (λ⃗ς .versigK(C s,{A,B}) (⃗ς ), 3B)
, 1 (cid:55)→ sigK(B)
Tsplit
in: Tinit
wit: sigK(C s,{A,B})
out: 0 (cid:55)→ (λ⃗ς .versigKW A (⃗ς ), 1B)
1 (cid:55)→ (λ⃗ς .versigKW B (⃗ς ), 2B)
TA
TB
in: (Tsplit, 0)
wit: sigK(withdraw A,{A,B})
out: (λς . versigK(A) (ς ), 1B)
in: (Tsplit, 1)
wit: sigK(withdraw B,{A,B})
out: (λς . versigK(B) (ς ), 2B)
As before, Tinit gathers A’s and B’s deposits and starts the con-
tract. Then, appending Tsplit to the blockchain splits the contract
balance between two different outputs, indexed with 0 and 1. In
BitML, this would correspond to the computation step:
⟨Cs , 3B⟩ −→ ⟨withdraw A , 1B⟩ | ⟨withdraw B , 2B⟩
where the two contracts in the parallel composition can be exe-
cuted independently (as usual in process calculi). Similarly, the two
outputs of Tsplit can be independently redeemed by TA and TB. The
in field of these transactions specifies, besides the input transaction
Tsplit, also the index of the output they want to redeem. For instance,
appending TA corresponds, in BitML, to the step:
⟨withdraw A , 1B⟩ | ⟨withdraw B , 2B⟩ −→ ⟨A, 1B⟩ | ⟨withdraw B , 2B⟩
Put. To illustrate the compilation of the put primitive, let:
Cp = put x . withdraw B
Compiling {A:? 1B @ x | A:! 1B @ y | B:! 1B @ z} Cp produces the
following transactions, where Tx , Ty, Tz are the Bitcoin counterpart
of the BitML deposits:
Tinit
in: 0 (cid:55)→ Ty , 1 (cid:55)→ Tz
wit: 0 (cid:55)→ sigK(A)
out: (λ⃗ς .versigK(Cp,{A,B}) (⃗ς ), 2B)
, 1 (cid:55)→ sigK(B)
TB
in: Tput
wit: sigK(withdraw B,{A,B})
out: (λς . versigK(B) (ς ), 3B)
10
Tput
in: 0 (cid:55)→ Tinit, 1 (cid:55)→ Tx
wit: 0 (cid:55)→ sigK(Cp,{A,B})
out: (λ⃗ς .versigK(withdraw B,{A,B}) (⃗ς ), 3B)
, 1 (cid:55)→ sigK(A)
The transaction Tinit gathers only the persistent deposits. Tput
has two inputs: Tinit, which can be redeemed with the signatures of
both A and B, and Tx, which can be redeemed with A’s signature
only. All these signatures are exchanged before stipulation, hence
any participant can append Tput to the blockchain — provided that
Tx is still unspent. Instead, if Tx has been spent, the contract gets
stuck, and the deposit within Tinit is frozen — coherently with the