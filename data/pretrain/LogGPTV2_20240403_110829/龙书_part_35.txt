114
空串ε可以区分任何一个接受状态和非接受状态。在图3-36 中，串 bb 区分状态A 和
图3-63 根据图 3-57 构造得到的 DFA
61
一在输人α上转到 B，在输入
第3章
---
## Page 131
D"的状态。D'的其他部分按如下步骤构建：
受状态组。
算法3.39
必然存在某个串可以区分p和g。因此可知αx 能够区分和t。
人α上分别进入状态p和q。并且p和g必定已经被放到不同的组中了。那么根据归纳假设
此ε就可以区分它们。归纳步骤如下：必然存在-个输人符号α和状态p、9，使得s和在输
当s和t放在初始分划的不同组中时，它们必然一个是接受状态,另一个是非接受状态。因"
状态和t被放在不同的组中，那么必然存在一个串可以区分它们。归纳的基础很容易证明：
小于等于i的串可以将s和t区分开。请读者自行完成这个归纳证明。
存在于不同子集中的状态之间是可区分的。要证明第一个性质，需要对算法3-39中步骤2的
词法分析
 D'的接受状态是那些包含了D 的接受状态的组的代表。请注意，每个组中要么只包含接
@ D'的开始状态是包含了 D 的开始状态的组的代表。
4）在分划Ⅱna的每个组中选取一个状态作为该组的代表。这些代表构成了状态最少 DFA
1）首先构造包含两个组 F和S－F的初始划分Ⅱ,这两个组分别是 D 的接受状态组和非接
输入：
第二个性质的证明也是通过对迭代次数的归纳来完成的。如果在步骤2 的第i次迭代时
这个最小化算法有时会产生带有一个死状态的 DFA。所谓死状态就是在所有输人符号上都转
方法：
输
我们需要证明两个性质：仍然位于Ⅱnat的同一组中状态不可能被任意串区分，以及最后
3-64 的过程分割成更小的组了。
令 s是Ⅱinal中某个组 G 的代表，并令 DFA D 中在输入α 上离开s的转换到达状态t。令
的过程总是通过分解已经构造得到的组来得到新的组。
出：一-个 DFA D'，它和 D 接受相同的语言，且状态数最少。
组G中的每一个状态必然在输入α上进人组H中的某个状态，否则，组G应该已经被图
为所在组H的代表。那么在D'中存在一个从s到r在输入α上的转换。注意，在D中
受状态，要么只包含非接受状态，因为我们一开始就将这两类状态分开了，而图3-64！
最小化一个 DFA 的状态数量。
在IInew中将G替换为对G进行分划得到的那些小组；
/*在最坏情况下，
每个状态各自组成一个组*
状态最小化算法的原理
图3-64Inw的构造
消除死状态
115
中
---
## Page 132
3.9.8DFA 模拟中的时间和空间权衡
同时我们把所有消失的转换当作结束词法单元识别过程的信号。
别这三个词法单元的状态最少 DFA。请记住，被用作词法分析器的 DFA 通常会丢掉它的死状态，
因为它们在输人b上转到不同的组。这样，所有的状态都自成--组。图3-54 所示的 DFA 就是识
和b 时会转到它自身。这个死状态同时也是状态8、58 和68 在输人α上的目标状态。
的原因是它们都识别词法单元a*b+。请注意，我们添加了一个死状态α，我们假设它在输人a
其中，状态0137和7分在同一组的原因是它们都没有识别任何词法单元；状态8和58分在一组
例3.41
态放到另一级
态放到对应于此词法单元的一个组中，同时把所有不识别任何词法单元的状
法3.39 中使用不同的初始分划。我们会将识别某个特定词法单元的所有状
3.9.7词法分析器的状态最小化
回到 A 本身，而其他的转换都和图 3-36 中的相同。
中，E在输人上到达C，而A是C所在组的代表。因为同样的原因，在输人上离开A 的状态
转换函数如图 3-65 所示。例如，在输人b上离开状态E的转换到达状态 A，因为在原来的 DFA
A、B、D和E作为这四个组的代表。其中，状态 A 是开始状态，状态E是唯－-的接受状态。它的
{D}{E。
D”E}。在第三轮中，我们不能够再分割当前分划中唯--一个包含多个状态的组（A，C”，因为
B，C}中的元素，但 B却转到另一个组中的元素 D上。因此在第二轮之后，Ⅱnew=丨A，C}B}
{A，B,C, D}被分割为A,B,C}和D}。这--轮得到的 Inew是{A,B，C}{D{E}。
和 C都转换到组IA,B，C, D}的某个成员上，而 D转到另--个组中的成员 E上。因此在 IⅡncw中，组
这些状态中的每一个都转到B，因此使用以α开头的串无法区分这些状态。但对于输入b，状态A、B
号α和b。因为组}E”只包含一个状态，不能再被分割，所以{E}被原封不动地保留在 Ⅱncw中。
它们分别是非接受状态组和接受状态组。构造Ⅱncw时，图3-64 中的过程考虑这两个组和输人符
例3.40
我们必须将 0137 和7分开，因为它们在输人α上转到不同的组。我们也要把8和58 分开,
个,但是因为缺少了一些到达死状态的转换，所以严格地讲它并不是一个DFA。
消除死状态，并使用一个缺少某些转换的自动机。这个自动机的状态比状态最少 DFA 的状态少-
存在被这个DFA接受的可能性了，这样我们才能知道已经识别到了正确的词素。因此，我们希望
每个输人符号上都必须有--个转换。然而，如3.8.3节所讨论的，我们需要知道在什么时候已经不
向自已的非接受状态。从技术上来讲，这个状态是必须的，因为在--个DFA中，从每个状态出发在
116
最简单和最快捷的表示一个 DFA 的转换函数的方法是使用一个以状态和字符为下标的二维表。
如果要将状态最小化算法应用于3.8.3 节中生成的 DFA，我们必须在算
在下一轮中，我们可以把A，B，C}分割为}A，C”B”，因为A和C在输人上都到达}A
另一个组A，B，C，D}是可以被分割的，因此我们必须考虑各个输人符号的作用。在输人α上，
对于图3-54 的 DFA，初始分划为
一组。下面用一个例子来说明这个扩展。
让我们重新考虑图3-36 中给出的DFA。初始分划包括两个组“A，B，C，D”，“E}
{0137,7}{247}{8,58}{68}{0}
图3-65状态最少
DFA的转换表
状态
AB
第3章
口
---
## Page 133
3.9.93.9节的练习
最小可能值多一点点。
设置为最小的、能够使得状态s的特殊条目的位置都尚未被占用的值。这个策略需要的空间只比
态记住我们已经看到了the；当输入字符不等于e时，状态s的动作和状态t的动作相同。因此，
过程。函数 nextStaie 的定义如下：
态t= defaut[s]，并把t当作当前的状态重复这
nex[]；如果 check[］]≠s，那么我们得到另--个状
目是有效的，状态在输人α上的后继状态就
0～127之间的整数。如果 check[l”=s，那么这个
在位置l=base[s”+α上的条目，其中α被当作
上的后继状态时，我们首先查看数组 next 和 check 中
表的压缩特性。我们可以把这个结构看作四个数组，如图 3-66 所示。其中的 base 数组用于确
出现在这个链表中的字符，我们总是选择这个状态作为目标状态。
涉及 ASCHI字母表中的 128个输入字符，因此这个数组需要的空间少于--兆字节。
动作，比如将一个词法单元返回给语法分析器。由于词法分析器的 DFA 中通常包含数百个状态，并且
.给定一个状态和下一个输人字符，我们访间这个数组就可以找出下一个状态以及我们必须执行的特殊
采用下述简单策略就可以有很好的效果：按照顺序将 base 值赋给各个状态，将各个 base[s］的值
[base[s”+e］的值置为前面提到的特殊状态。同时 default[s]被设置为t。
我们将check［base［s］+e］的值设置为s（以确认这个条目对于状态s有效），并将 nex
一个标识符的词素的前缀。当输人字符为é 时，我们必须从状态 s 到达一个特别的状态。该状
可能是在读人字母 th 之后进入的状态。这里 th 既是关键字 then 的--个前缀，同时也可能是
在实战中可能还有另一个以状态为下标的数组，如果某个状态相关的动作，那么这个数组的相应元素会指明这个动作。
个状态，这个转换链表由字符－状态对组成。我们在链表的最后存放-一-个默认状态：对于没不
但是，在一些小型的设备中也可能使用编译器。对于这些设备来说，即使一兆内存也显得
词法分析
虽然我们可能无法选择适当的 base 值，使 next－ check 的所有条目都被充分利用。经验表明
在计算 nextstate(s，α）时，即计算状态s在输人α
还有一个更加巧妙的数据结构，它既利用了数组表示法的访问速度，又利用了带默认值的链
练习 3.9.2：使用算法3.36 将练习3.7.3 中的正则表达式直接转换成 DFA。
2）
练习3.9.1：扩展图3-58中的表，使得它包含如下运算符：
使用图 3-66 中所示数据结构的目的是利用状态之间的相似性来缩短 next-check 数组。例
int nertState(s,a)  
+
else return nextState( default[s], a);
if?
个
是
条
defaul!
图3-66表示转换表的数据结构
base
next
check
117
如
是
---
## Page 134
3.10第3 章总结
示：观察练习3.9.4中的规律。各个状态分别表示了关于已输人串的哪些信息？
相互等价。注意：你可能已经在完成练习3.7.3 时构造出了这些表达式的 DFA。
则表达式等价。使用这种方法来证明下面的正则表达式（alb）*，（a*lb*）*以及（（ela)b*）
118
?·词法单元。词法分析器扫描源程序并输出--个由词法单元组成的序列。这些词法单元通
的任何 DFA 至少具有2个状态。在这个正则表达式中，（alb)在其尾部出现了n-1次。提
(a(b)*a(a/b)(a/b)...(a]b)
你有没有看出什么规律？
3) (alb) *a(alb)(a!b) (alb)
2) (alb) *a(alb)(alb)
1) (alb) *a(alb)
！练习3.9.4：为下列的正则表达式构造最少状态 DFA：
！！练习3.9.5：为了证明例3.25 中非正式给出的结论，说明正则表达式
！练习3.9.3：我们只需要说明两个正则表达式的最少状态 DFA 同构，就可以证明这两个正
也可以在空输人上执行转换。
词法单元对应的词素。与状态转换图不同，有穷自动机既可以在输人字符上执行转换，
状态，以及状态集、输人字符集和状态间的转换集合。接受状态表明已经发现了和某个
有穷自动机。它是状态转换图的形式化表示。它指明了一个开始状态、一个或多个接受
个可能的输入字符，该字符将使词法分析器改变当前状态。
态。在搜寻可能与某个模式匹配的词素的过程中，各个状态代表了已读人字符的历史信
状态转换图。一个词法分析器的行为经常可以用一个状态转换图来描述。它有多个状
特定字符集中单个字符组成的字符串的集合)。
作为缩写在正则表达式中使用。比如+（一个或多个）、？（零个或一个)以及字符类（由
扩展的正则表达式表示法。为了使正则表达式更易于表达模式，一些附加的运算符可以
示某正则表达式的变量。定义一个变量的正则表达式时可以使用已经定义过的变量。
常是通过正则定义来描述的。一个正则定义是一个语句序列，其中的每个语句定义了－-个表
正则定义。多个语言的复杂集合，比如用以描述一-个程序设计语言所有词法单元的多个模式常
接、Kleene 闭包、“重复多次"等运算符构造得到的。
正则表达式。
单元的词素。那些和一个给定模式匹配的字(或者说字符串)的集合称为该模式的语言。
模式。每个词法单元都有--个模式，它描述了什么样的字符序列可以组成对应于此词法
分析器已经到达了缓冲区末尾。
用一对缓冲区，以及在每个缓冲区末尾放置特殊的哨兵标记字符。该字符可以通知词法
分析器往往需要对输人字符进行缓冲。可以使用两个技术来加速输人扫描过程：循环使
缓冲技术。为了判断下一个词素在何处结束，常常需要预先扫描输人字符。因此，词法
词素，即该词法单元所代表的输入字符串。
词素。每次词法分析器向语法分析器返回一个词法单元时，该词法单元都有一个关联的
有
常会逐个传送给语法分析器。有些词法单元只包含一个词法单元名，而其他词法单元还
一个关联的词法值，它给出了在输人中找到的这个词法单元的某个实例的有关信息。
这些表达式常用于描述模式。正则表达式是从单个字符开始，通过并、连
第3章
---
## Page 135
的概述。
Java 版本包括 JFlex[7]和 JLex[8］。
[10]。此后出现了 Lex 的很多变体。GNU 版本的 Flex 及其文档可以在[4]下载。流行的 Lex 的
于文本编辑器QED 中。
Thompson[17]提出。该文还提出了直接模拟 NFA 的算法（算法 3.22）。这个算法被 Thompson 用
awk[3]中的正则表达式模式匹配例程。将不确定自动机用作中间表示的匹配方法首先由
[14]给出。而 Rabin 和 Scot[15]最先提出了不确定有穷自动机的概念，他们还给出了子集构造
常相近，只有少量例外，比如字符类的助记表示方式。许多脚本语言，像 Perl、Python 和 Tcl，都
IEEE1003 和ISO/IEC 9945 中定义了POSIX 扩展正则表达式，它们和最初的UNIX 正则表达式非
sed、sh 和vi等。可移动操作系统接口（Portable Operating System Interface，POSIX）的标准文档
从那以后，正则表达式和有穷自动机在计算机科学中得到了广泛应用。
种描述神经活动的有穷自动机模型，而Kleene 的兴趣就是描述那些可以用这些模型表示的事件。
3.11 第3 章参考文献
法