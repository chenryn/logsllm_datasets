更严格的排放标准是个好玩意儿，但驾驶员也需要考虑更多，同时更加小心（至少对汽油
车来说如此）。不过坦白说，新标准对大多数人没有什么影响，因为其他州不会施行加州的
标准。
所以你知道，四种类型的发动机其实可以分为三类：两类是汽油机，一类是电动机。虽然
它们都是驱动车轮的，但你明白了其中的差异。你不知道的是，这堆复杂的玩意与正则表
达式有什么关系！其实这里面的关系远比你能想象的要复杂。
注1：加州对汽车尾气排放的限制非常严格。因此，美国市场上的不少汽车都标明“达到加州标
准”或“未达到加州标准”。
---
## Page 171
发动引擎
145
正则引擎的分类
KegexEngineTypes
正则引擎主要可以分为基本不同的两大类：一种是DFA（相当于之前说的电动机），另一种
是NFA（相当于前面的汽油机)。我们很快就会知道DFA和NFA的具体含义，但是现在读
DFA和NFA都有很长的历史，不过，正如汽油机一样，NFA的历史更长一些。使用NFA
的工具包括.NET、PHP、Ruby、Perl、Python、GNU Emacs、ed、sec、vi、grep的多数版本，
甚至还有某些版本的egrep和awk。而采用DFA的工具主要有egrep、awk、lex和flex。也
有些系统采用了混合引擎，它们会根据任务的不同选择合适的引擎（甚至对同一表达式中
的不同部分采用不同的引擎，以求得功能与速度之间的最佳平衡）。表41列出了少量常用
的工具及其大多数版本使用的引擎。如果你最喜欢的工具没有名列其中，可以参考下一页
的“测试引擎的类型”来找到容案。
表4-1：部分程序及其所使用的正则引|擎
引擎类型
程序
DFA
awk（大多数版本）、egrep（大多数版本）、flex、lex、MySQL、Procmail
GNU Emacs、Java、grep（大多数版本）、less、more、.NET语言、PCRElibrary、
传统型NFA
Perl、PHP（所有三套正则库）、Python、Ruby、sed（大多数版本）、vi
POSIX NFA
mawk、MorticeKern Systems'utilities、GNUEmacs（明确指定时使用）
DFA/NFA混合
GNU awk、GNU grep/egrep、Tcl
第3章已经讲过，NFA和DFA都发展了二十多年，产生了许多不必要的变体，结果，现在
的情况比较复杂。POSIX标准的出台，就是为了规范这种现象，POSIX标准不但清楚地规
定了前一章中提到的引擎应该支持的元字符和特性，还明确规定了使用者期望由表达式获
得的准确结果。除开表面细节不谈，DFA（也就是电动机）显然已经符合新的标准，但是
NFA风格的结果却与此不一，所以NFA需要修改才能符合标准。这样一来，正则引I擎可以
租略地分为3类：
·DFA（符合或不符合POSIX标准的都属此类）。
·传统型NFA。
POSIX NFA。
这里提到的POSIX是匹配意义上的，也就是说，POSIX标准规定的某个正则表达式的应有
行为（本章稍后部分将讨论）；而不是指POSIX标准引入的匹配特性。许多程序支持这些特
性，但结果与POSIX规范不完全一致。
---
## Page 172
146
第4章：表达式的匹配原理
老式（功能极少的）程序，比如egrep、awk、lex之类，一般都是使用DFA引I擎（电动机），
所以，新的标准只是肯定了既有的情况，而没有大的改变。但是也存在一些汽油机版本的
此类程序，如果它们需要达到POSIX标准，就需要做些修改。通过了加州排放标准测试（POSIX
NFA）的汽油机能够产生符合标准的结果，但是这些必要的修改会增加保养的难度。以前，
错位的火花塞也能应付着使用，但现在根本就点不着火。以前还能“凑合”的汽油，现在
会弄得发动机砰砰乱响。不过，一且掌握其中的门道，发动机就能平稳安静地运转了。
几句题外话
FromtheDepartmentofRedundancyDepartment
现在，我请读者回过头去，重薪思考关于引擎的故事。其中的每句话都涉及某些与正则表
达式相关的事实。读第二遍会引起许多思考。尤其是，为什么说电动机（DFA引擎）只是“能
够运行”。什么影响了汽油机（NFA）？使用NFA引率时，应该如何调整才能获得期望的结
果？通过（排放）测试的POSIXDFA有什么特别之处？现实中“熄火的引I率”又是什么？
测试引擎的类型
Testing the Engine Type
工具所采用的引辜的类型，决定了引擎能够支持的特性以及这些特性的用途。所以，通常
情况下，我们只需要几个测试用的表达式，就能判断出程序所使用的引擎类型（毕竟，如
果你不能分辨引率的类型，这种分类就没有意义）。现在，我并不期望读者理解下面的这些
测试原理，我只是提供一些测试表达式，即使读者最喜欢使用的软件没有出现在表41之内，
也可以判断出引率的类型，继续阅读本章的其他内容。
是否传统型NFA
传统型NFA是使用最广泛的引擎，而且它很容易识别。首先，看看忽略优先量词（141）
是否得到支持？如果是，基本就能确定这是传统型NFA。我们将要看到，忽略优先量词是
DFA不支持的，在POSIXNFA中也没有意义。为了确认这一点，只需要简单地用正则表达
式'nfaInfa*not来匹配字符串nfa*not’，如果只有nfa’匹配了，这就是传统型NFA。
如果整个‘nfanot’都能匹配，则此引擎要么是POSIXNFA，要么是DFA。
---
## Page 173
匹配的基础
147
DFA还是POSIXNFA
某些情况下，DFA与POSIXNFA的区别是很明显的。DFA不支持捕获型括号（capturing
parentheses）和回溯（backreferences），这一点有助于判断，不过，也存在同时使用两种引
擎的混合系统，在这种系统中，如果没有使用捕获型括号，就会使用DFA。
下面这个简单的测试能说明很多问题，用'x（.+）+X来匹配形如=XX========
======’的字符串，例如使用egrep命令：
如果执行需要花很长时间，就是NFA（如果上一项测试显示这不是传统型NFA，那么它肯
定是POSIXNFA)。如果时间很短，就是DFA，或者是支持某些高级优化的NFA。如果显
示堆栈超溢（stackoverflow），或者超时退出，那么它是NFA引擎。
匹配的基础
Match Basics
在了解不同引擎的差异之前，我们先看看它们的相似之处。汽车的各种动力系统在某些方
面是一样的（或者说，从实用的角度考虑，它们是一样的），所以，下面的范例也能够适用
于所有的引擎。
关于范例
Abont tlte Examples
本章关注的是一般的提供所有功能的正则引擎，所以，某些程序并不能完全支持它们。在
本书所说的汽车里，机油油尺（dipstick）可能挨在机油滤清器（oilfilter）的左边，而在读
者那里，它却装在分电盘盖（distributorcap）的后面。不过，读者要做的只是理解这些概念，
能够使用和维护自己最喜欢（以及他们最感兴趣）的正则表达式包。
在大部分例子中，我仍然使用Perl表示法，虽然我偶尔会用一些其他的表示法来提醒读者，
表示法并不重要，我们讨论的问题与程序和表示法不属于一个层次。为节省篇幅，如果读
者遇到不熟悉的构建方式，请查阅第3章（114)。
本章详细阐释了匹配执行的实际流程。理想的情况是，所有的知识都能归纳为几条容易记
忆的简单规则，使用者不需要了解这些规则包含的原理。很不幸，事实并非如此。整个第4
章只能列出两条普适的原则：
1.优先选择最左端（最靠开头）的匹配结果。
2.标准的匹配量词（*、+、？和（m，n}1）是匹配优先的。
在本章中，我们将考察这些规则，它们的结果，以及其他许多内容。首先我们详细讨论第
一条规则。
---
## Page 174
148
第4章：表达式的匹配原理
规则1：优先选择最左端的匹配结果
Rule 1: The Matchi That Begins Earliest Wins
根据这条规则，起始位置最靠左的匹配结果总是优先于其他可能的匹配结果。这条规则并
没有规定优先的匹配结果的长度（稍后将会讨论），而只是规定，在所有可能的匹配结果中，
优先选择开始位置最左端的。实际上，因为可能有多个匹配结果的起始位置都在最左端，
也许我们应该把这条规则中的“某个匹配结果（amatch）”改为“该匹配结果（thematch）”，
不过这听起来有些别扭。
这条规则的由来是：匹配先从需要查找的字符串的起始位置尝试匹配。在这里，“尝试匹配
（attempt）”的意思是，在当前位置测试整个正则表达式（可能很复杂）能匹配的每样文本。
如果在当前位置测试了所有的可能之后不能找到匹配结果，就需要从字符串的第二个字符
之前的位置开始重新尝试。在找到匹配结果以前必须在所有的位置重复此过程。只有在尝
试过所有的起始位置（直到字符串的最后一个字符）都不能找到匹配结果的情况下，才会
报告“匹配失败”。
所以，如果要用ORA来匹配FLORAL，从字符串左边开始第一轮尝试会失败（因为ORA不
能匹配FLO），第二轮尝试也会失败（ORA同样不能匹配LOR），从第三个字符开始的尝试
能够成功，所以引擎会停下来，报告匹配结果FLORAL。
如果不了解这条规则，有时候就不能理解匹配的结果。例如，用cat来匹配：
The dragging belly indicates that your catis too fat.
结果是indicates，而不是后来出现的cat。单词cat是能够被匹配的，但indicates中
的cat出现的更早，所以得到匹配的是它。对于egrep之类的程序来说，这种差别是无关紧
要的，因为它只关心“是否”能够匹配，而不是“在哪里”匹配。但如果是进行其他的应
用，例如查找和替换，这种差别就很重要了。
这里有一个小测验（应该不困难）：如果用fatIcatIbellylyour;来匹配字符串‘The
draggingbellyindicatesthatyourcatistoofat.，结果是什么呢？请着下
一页。
“传动装置（transmission）”和驱动过程（bump-along）
或许汽车变速箱（译注1）的例子有助于理解这条规则，驾驶员在换档时，变速箱负责连接
引擎和动力系统。引擎是真正产生动力的地方（它驱动曲轴），而变速箱把动力传送到车轮。
“变速箱”，在涉及正则表达式时译为“传动装置”。
---
## Page 175
匹配的基础
149
传动装置的主要功能：驱动
如果引擎不能在字符串开始的位置找到匹配的结果，传动装置就会推动引擎，从字符串的
下--个位置开始尝试，然后是下一个，再下一个，如此继续。不过，如果某个正则表达式
是以“字符串起始位置锚点（start-of-stringanchor）”开头的，传动装置就会知道，不需要
更多的尝试，因为如果能够匹配，结果肯定是从字符串的头部开始的。在第6章中，我们
会讲解这一点，以及更多的内部优化措施。
引擎的构造
EnginePieces andParts
所有的引擎都是由不同的零部件组合而成的。如果对这些零件缺乏了解，也就不可能真正
理解引擎的工作原理。正则引擎中的这些零件分为几类--文字字符（literalcharacters）、
量词（qualifiers）、字符组（characterclasses）、括号，等等，我们在第3章介绍过（114）。
这些零件的组合方式（以及正则引擎对它们的处理方式）决定了引擎的特性，所以，这些
零件的组合方式，以及它们之间的配合，是我们主要关注的东西。首先，让我们来看看这
些零件：
文字文本（LiteralText）例如a.\*、！、枝.
对于非元字符的文字字符，尝试匹配时需要考虑就是“这个字符与当前尝试的字符相
同吗？”。如果一个正则表达式只包含纯文本字符，例如usa，那幺正则引擎会将其
视为：一个‘u，接着一个's，接着一个al。进行不区分大小写的匹配时的情况要复杂
一点，因为bi能够匹配B，而'Bi也能匹配b，不过这仍然不难理解（Unicode的情况
梢微复杂一些110）。
字符组、点号、Unicode属性及其他
通常情况下，字符组、点号、Unicode属性及其他的匹配是比较简单的：无论字符组的
长度是多少，它都只能匹配一个字符（注2）。
点号可以很方便地表示复杂的字符组，它几乎能匹配所有字符，所以它的作用也很简
单，其他的简使方式还包括w，w和d。
捕获型括号
注2：其实，正如我们在前一章看到的（128），POSIX的collating序列能够匹配多个宇符，但
这并不常见。同样，在进行不区分大小写的匹配时，某些Unicode字符可以匹配多个宇符
（110）、尽管大多数实现并不支持此功能。
---
## Page 176
150
第4章：表达式的匹配原理
测验答案
148页测验的答案
请记住，正则表达式的每一次尝试都要进行到底，所以fat|catlbellylyour：用来匹
配‘The dragging belly indicates your cat is too fat’的结果不是fat，尽
管fat：在所有可能选项中列在最前头。
当然，正则表达式应该也能够匹配fat和其他可能，但它们都不是最免出现的匹配结
果（除现在最左边的结果），所以不会被选择。在进行下一轮尝试之前，正则表达式的
所有可能都会尝试，也就是说，在移动之前，fat、cat、bellyi和youri都必须尝试。
锚点（e.g，~\z)（？<=\d))
锚点可以分为两大类：简单锚点（^、$、\G、\b、129）和复杂锚点（例如顺序环视
和逆序环视133)。简单锚点之所以得名，就在于它们只是检查目标字符串中的特定
位置的情况（~、\z），或者是比较两个相邻的字符（\<、\b、）。相反，复杂锚点（环
视）能包含任意复杂的子表达式，所以它们也可以任意复杂。
非“电动”的括号、反向引用和忽略优先量词
虽然本章希望讲解的是引擎之间的相似之处，但为了方便读者理解本章余下的内容，这里
必须指出一些有意义的差异。捕获括号（以及相应的反向引用和$1表示法）就像汽油添加
剂一样--它们只对汽油机（NFA）起作用，对电动机（DFA）不起作用。忽略优先量词也
是如此。这种情况是由DFA的工作原理决定的（注3)。这解释了，为什么DFA引擎不支
持这些特性。读者会看到，awk、lex和egrep都不支持反向引l用和s1功能（表示法）。
也许读者会注意到，GNU版本的egrep确实支持反向引用。这是因为它包含了两台不同的
引擎。它首先使用DFA查找可能的匹配结果，再用NFA（支持包括反向引I用在内的所有特
性）来确认这些结果。接下来，我们将看到DFA不能支持反向引I用及捕获括号的原因，以
及这种引擎能够存在的理由（DFA有很多显著的优势，例如匹配速度非常快）。
注3：这并非是说，我们不能棵合两种引擎的长处以求最佳。请参考第182页的补充内容。
---
## Page 177
匹配的基础
151
规则2：标准量词是匹配优先的
Kule2:TheStandardQuanfifhersAreGreedy
至今为止，我们看到的特性都非常易懂。但仅仅靠它们还很不够一一要完成复杂点的任务，
就需要使用星号、加号、多选结构之类功能更强大的元字符。要彻底理解这些功能，需要
学习更多的知识。
读者首先需要记住的是，标准匹配量词（？、*、+，以及（min，max））都是“匹配优先（greedy）”
中的[0-9]，在匹配成功之前，进行尝试的次数是存在上限和下限的。在前面的章节中我
们已经提到过这一点一而规则2表明，这些尝试总是希望获得最长的匹配（一些工具提
供了其他的匹配量词，但是本节只讨论标准的匹配优先量词）。
简而言之，标准匹配量词的结果“可能”并非所有可能中最长的，但它们总是尝试匹配尽
可能多的字符，直到匹配上限为止。如果最终结果并非该表达式的所有可能中最长的，原
因肯定是匹配字符过多导致匹配失败。举个简单的例子：用b\w+s\b来匹配包含‘s’的
字符串，比如说‘regexes'，w+i完全能够匹配整个单词，但如果用w+i来匹配整个单词，
si就无法匹配了。为了完成匹配，\w+必须匹配regexes'，把最后的's\bi留出来。
如果表达式的其他部分能够成功匹配的唯一条件是，匹配优先的结构不匹配任何字符，在
容许零匹配（译注2）的情况下（例如使用星号、向号，或者（0，max），这是没有问题的。
不过，这种情况只有在表达式的后续部分强迫下才能发生。匹配优先量词之所以得名，是
因为它们总是（或者，至少是尝试）匹配多于匹配成功下限的字符。
匹配优先的性质可以非常有用（有时候也非常讨厌）。它可以用来解释（0-91+为什么能匹
配March·1998中的所有数字。1匹配之后，实际上已经满足了成功的下限，但此正则表达
式是匹配优先的，所以它不会停在此处，而会继续下去，继续匹配998，直到这个字符
审的末尾（因为[0-9）不能匹配字符事最后的空档，所以会停下来）。
邮件主题
显然，这种匹配方式并非只能用于匹配数字。举例来说，如果我们需要判断E-mail的header
中的某行字符是否标题行（subjectline)。前面（55）我们已经说过，可以用~Subject：