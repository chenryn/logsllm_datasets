data written by the external code (through function calls)
on its behalf. Then we keep track of the impacts propa-
gating through the whole system. During the execution,
if we observe that the instruction pointer (i.e., EIP in
x86 CPUs) is loaded with a marked impact, and the exe-
cution jumps immediately into the malicious code, then
we identify a hook. Furthermore, in this case, we have
determined that the jump target is the hook entry F , the
memory location that the instruction pointer is loaded
from is the hook site L, and the content within L is the
hook H.
Hooking Mechanism Analysis: Semantics-aware Im-
pact Dependency Analysis Once identifying a hook
H, we want to understand the hooking mechanism. Dur-
ing the impact propagation, we record into a trace the de-
tails about how the impacts are propagated in the system.
Therefore, from the trace entry corresponding to the de-
tected hook H, we can perform backward dependency
analysis on the trace. The result gives how the hook H is
formulated and installed into the hook site L. However,
such a result is difﬁcult to understand, because it only
provides hardware-level information and sometimes can
be enormous. We combine OS-level semantics informa-
tion with the result, and perform several optimizations to
hide unnecessary details. The ﬁnal output is a succinct
and intuitive graphical representation, assisting malware
analysts to understand its hooking mechanism.
Note that our approach would catch “normal” hook-
ing behaviors. Windows provides a number of APIs,
such as CreateThread and CreateWindow, for ap-
plications to register their callback functions. Windows
will invoke these callbacks on certain events. These
function calls that register normal hooks can be com-
piled into a white-list. Then if one of these normal
hooks is captured by our detection step, we can clas-
sify it as normal, by extracting its hooking mechanism
and comparing it with the white-list.
In practice, we
ﬁnd this white-listing approach very effective. Note that
“normal” hooks are not considered false positives in our
case, since our goal is to extract and analyze any hook-
ing mechanism which may be employed by the sample
of interest.
3 System Design and Implementation
To demonstrate the feasibility of our approach, we
design and implement a system, HookFinder, to identify
the hooking behavior and understand the hooking mech-
anism. In this section, we give an overview of Hook-
Finder and describe its components.
3.1 System Overview
The overview of HookFinder is illustrated in Fig-
ure 2. HookFinder is based on a whole-system emula-
tor. It emulates an x86 computer and runs a Windows
guest system on top of it. The malware to be analyzed
is executed in the Windows guest system. There are
two reasons why we employ a whole-system emulator.
First, it facilitates instrumenting CPU instructions in a
ﬁne-grained manner. In particular, we are able to instru-
ment every CPU instruction executed in the Windows
guest system. Second, it provides an excellent protection
line between the analysis environment and the malware.
Malware
Windows
Impact
Engine
Hook
Detector
Semantics
Extractor
Impact Trace
Hook 
Analyzer
Whole−system Emulator
Figure 2. System Overview
Hook Graph and
Hooking Mechanism
Therefore, it is relatively more difﬁcult for malicious
code to interfere with our detection and analysis pro-
cedure and affect the analysis results. In the implemen-
tation, we develop HookFinder on top of TEMU [29],
which is the dynamic analysis component in the Bit-
Blaze project [2].
Within the emulator, we build three components: im-
pact analysis engine, semantics extractor, and hook de-
tector. The impact analysis engine is a central compo-
nent, which performs ﬁne-grained impact analysis.
It
marks the impacts made by the malware, and keeps track
of impacts propagating over the whole system. A whole-
system emulator only provides a hardware-level view of
the system, such as the states of CPU registers, physical
memory, and I/O devices. However, malware analysts
need to understand the malware and system behaviors at
the operating-system level. The semantics extractor im-
plements the functionality of extracting OS-level seman-
tics information from the emulated environment. For ex-
ample, it provides process and module information of
the current instruction executed. It can also provide in-
formation about external function calls. The hook detec-
tor behaves like a controller, cooperating with the impact
analysis engine and the semantics extractor to identify
hooks.
To analyze hooking mechanisms, the impact propa-
gation events, as well as necessary OS-level semantics
information, are recorded into a trace, called the impact
trace. The hook analyzer analyzes the impact trace and
generates a succinct and intuitive graphical representa-
tion, hook graph. The hook graph conveys essential in-
formation for malware analysts to easily understand the
hooking mechanism.
3.2 Impact Analysis Engine
The impact analysis engine performs ﬁne-grained im-
pact analysis, and is composed of two sub-components:
impact marker and impact tracker. The impact marker
is responsible for marking the initial impacts made by
the malicious code, and the impact tracker keeps track
of the impacts propagation.
Impact Marker
In the impact marker, we aim to iden-
tify all the initial impacts that can be used to install
hooks. This is important, because if we fail to mark
some initial impacts, malware writers may exploit this
fact to evade our detection.
First, we consider that an instruction from malicious
code directly makes an impact. When an executable bi-
nary is loaded into the system, a module space is allo-
cated for it, and the code and data segments from the
binary are copied into this module space and initialized.
The semantics extractor mentioned in Section 3.3 is able
to tell which module space belongs to the sample under
analysis. Then, for an instruction located in that mod-
ule, we need to mark its impact accordingly. That is, we
mark the destination operand, either a memory location
or a CPU register, if it is not marked already.
In addition, we consider that malicious code may
make an impact by calling an external function. For
example, it may call ReadFile to obtain the address
of the hook entry F from a conﬁguration ﬁle, and then
install it as the hook H into the hook site L by calling
memcpy. If we do not consider this situation, H will
not be marked. Therefore, we need to mark the output
of that external function too. Again, we will discuss in
Section 3.3 how the semantics extractor determines if an
instruction is executed under the context of an external
function call.
To identify the impacts made in an external function,
we treat memory writes and register writes differently.
For memory writes, we mark a memory location if it is
written under the context of the external function call,
and it is not a local variable on the stack. To determine
a local variable, we obtain the stack range for the cur-
rent thread from the semantics extractor, and compare
the memory location with the value of ESP on the en-
try of the external function call: if the memory location
is smaller than the value of ESP and within the stack
range, then it is a local variable. For register writes,
we only need to consider EAX. According to the func-
tion calling conventions (i.e., cdecl and stdcall)
in Windows, EAX contains the return value when appli-
cable, while the other general-purpose registers (except
the stack pointer ESP) remain unchanged. Now we need
to determine if EAX contains the return value and mark
it accordingly. We save the value of EAX on the entry
of an external function call, and then on the exit of the
function, check if EAX is changed. If so, we mark this
EAX.
Furthermore, malware may dynamically generate
new code. Since self-generated code is also part of im-
pacts made by the malicious code, the memory region
occupied by it must have already been marked. Thus,
we can determine if an instruction is generated from
the original malicious binary by simply checking if the
memory region occupied by that instruction is marked.
If so, we also treat that code region as malicious code,
and mark the inputs taken by the self-generated code too.
Impact Tracker The impact tracker keeps track of
the impacts propagating throughout the system.
It
tracks data dependencies between source and destina-
tion operands. That is, if any byte of any source operand
is marked, the destination operand is also marked. In
addition, for a memory source operand, if its address
becomes marked, we also mark the destination operand.
This policy enables us to track how the malicious code
walks through a data structure, starting from a marked
pointer to the data structure. These two policies are sim-
ilar to those in the dynamic taint analysis systems [7,
10, 11, 22, 33]. Note that the impact tracker keeps track
of impacts propagating over the whole system, includ-
ing the disk.
It still keeps track of the impacts that
are swapped out to disk, or written to the registry and
ﬁlesystem. Therefore, HookFinder is able to detect the
hooks that are registered through the registry and ﬁlesys-
tem.
What makes the impact tracker different from dy-
namic taint analysis is the way it checks immediate
operands. That is, if an instruction has an immediate
operand, the impact tracker checks if the memory re-
gion occupied by this immediate is marked and if so,
propagates the impact accordingly. In contrast, the dy-
namic taint analysis systems treat immediate operands
as clean. In our scenario, the malicious code may over-
write the system code with manipulated immediate num-
bers in the instructions. For example, in the code hook
case, the malicious code may inject into the system code
a jump instruction with a hard-coded target address, to
redirect the execution to the malicious code. This im-
mediate operand is a crucial impact that is deliberately
injected by the malicious code to set up a hook. There-
fore, we need to check immediate operands.
To enable dependency analysis, the impact tracker
performs an extra operation during the impact propa-
gation. That is, we assign a unique identiﬁer to each
marked byte of the destination operand. We refer to
this identiﬁer as dependency ID. Then for each instruc-
tion that creates or propagates the marked data, we
write a record into the impact trace. The record con-
tains the relationships between the dependency IDs of
marked source and the destination operand, associated
with other detailed information about that instruction.
3.3 Semantics Extractor
The semantics extractor bridges the semantic gap be-
tween the hardware-level view and the software-level
view. Speciﬁcally, the purposes of the semantics extrac-
tor are three-fold: (1) determine the process, thread, and
module information for the current instruction; (2) deter-
mine if an instruction is executed in the context of an ex-
ternal function call, and if so, resolve its function name
and arguments; and (3) determine the symbol name if a
memory read is to a symbol.
Several previous systems [10, 14–16, 33] have dis-
cussed extracting OS-level semantics from a virtual ma-
chine monitor or a whole-system emulator. There are
mainly two types of approaches. First, we can directly
examine the guest system states from outside, with com-
plete knowledge of crucial data structures [10, 14, 15].
Second, we can insert a kernel module into the guest
system to collect the necessary information [16,33]. Our
implementation is based on TEMU, which combines
these two approaches.
Process, Thread, and Module Information The
other two systems [16, 33] that are also based on TEMU
have described how we extract process, thread and mod-
ule information. To summarize,
the kernel module
loaded in the guest system registers several callback rou-
tines. Whenever a process is created or deleted or a mod-
ule is loaded into a process memory space, the corre-
sponding callback routine is invoked. The callback rou-
tines gather the information such as the value of CR3
for each process and the memory region for each mod-
ule, and then pass it to the underneath emulator via a
predeﬁned I/O port. Obtaining thread information is
fairly straightforward, as the data structure for the cur-
rent thread is mapped into a well-known virtual address
in Windows. We can simply read the thread information,
such as the thread ID and stack base and size, directly
from outside.
External Function Call Previous systems [10, 33]
have also discussed how to determine external functions
called by the malicious code, by comparing the stack
pointers. The intuition is that the malicious code has to
push the arguments and the return address onto the stack
to call an external function. Thus by comparing the stack
pointer when the execution enters the malicious code,
and the one when the execution leaves, we can deter-
mine if the execution jumping out of the malicious code
is because of an external function call.
Then given the entry address of an external function,
we want to resolve its function name. We achieve this by
parsing the PE header of a module whenever it is loaded
into the system. Each binary in the PE format contains
an export table that for each of its exported functions
maps its name with its offset within the binary. Combin-
ing the offset with the base address that the module is
actually loaded in, we can infer the actual address of an
external function.
Symbol Name When an instruction reads a memory
location, we want to determine if it is reading a sym-
bol, and if so, resolve the symbol name. This is useful
in generating an OS-level hook graph. Similarly to re-
solving external function name, we parse the PE header
of a module whenever it is loaded into the system. We
extract symbol names with their offsets in both export
table and import Table, and infer the actual address of a
symbol using the module base address and its offset.
3.4 Hook Detector
The hook detector works by checking if the con-
trol ﬂow is affected by some marked value, which redi-
rects the execution into the malicious code. More pre-
cisely, we observe whether the instruction pointer EIP
is marked, and the execution jumps immediately from
the system code into the malicious code region, or the