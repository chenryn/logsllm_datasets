j=1
P rj
j
This is essentially a random linear combination of the t original constraints. Legitimate signatures
pass such a check with probability 1, while invalid signatures pass with probability at most 1/p.
Eﬃciency The total public key data consists of 3(tmax + 1) group elements, which we emphasize
is independent of the number of possible attributes in the system. Signatures have linear size,
consisting of (cid:96) + t + 2 group elements, where (cid:96) and t are the dimensions of the claim-predicate’s
monotone span program. Signing can be done using a maximum of 2w+(cid:96)(1+2t)+3 exponentiations
in G and H, where w is the minimum number of attributes needed for the signer to satisfy Υ.
D.1 Security Proof
In this section we prove the following theorem.
Theorem 6. Instantiation 3 is a secure ABS scheme in the generic group model.
We break the security proof into the following two lemmas.
Lemma 1. Instantiation 3 is a correct (Deﬁnition 5) and perfectly private (Deﬁnition 6) ABS
scheme.
Proof. Correctness can be seen by straight-forward substitutions. To prove perfect privacy it
suﬃces to show that for any claim-predicate Υ and any attribute set A that satisﬁes Υ, the
output of ABS.Sign(P K, SKA, m, Υ) is uniformly distributed among signatures σ, subject to the
constraint that ABS.Ver(P K, m, Υ, σ) = 1. For σ = (Y, W, S1, . . . , Sn, P1, . . . , Pt) it is easy to see
that for any setting of Y (cid:54)= 1 and S1, . . . , Sn, there is a unique value of W, P1, . . . , Pt for which the
signature successfully veriﬁes. We conclude by observing that Y and S1, . . . , Sn output by ABS.Sign
are distributed uniformly in their respective domains and that the signature output by ABS.Sign
successfully veriﬁes.
Lemma 2. Instantiation 3 is unforgeable (Deﬁnition 7) in the generic group model.
Proof. We ﬁrst observe that the distribution AltSign(ASK, m, Υ) can be sampled in the following
way:
Let M ∈ (Zp)l×t be the monotone span program for Υ, with row labeling u : [l] → A; let
µ = H(m(cid:107)Υ).
1. Pick random s1, . . . , sl ← Zp and y ← Z∗
2. For all j ∈ [t], compute
p
(cid:34) l(cid:88)
(cid:35)
,
si(a + u(i)b)Mi,j − yzj
pj =
1
(c + µ)
i=1
where (cid:126)z = [1, 0, . . . , 0].
3. Output σ = (gy, gy/a0, gs1, . . . , gsl, hp1
1 , . . . , hpt
t )
23
It is straight-forward to check that this distribution matches AltSign(ASK, m, Υ). WLOG, we
assume that in the security experiment, responses to signature queries are generated in this way.
We now proceed with the proof of unforgeability, following the standard approach for generic
groups. Let Lin(S) be the set of functions that are linear in the terms in the set S. Let Hom(S)
be the subset of Lin(S) of homogenous functions whose constant coeﬃcient is zero. In the generic
group model, the forgery generated by the adversary is a ﬁxed function of the inputs given in the
security experiment.
Since it can only beneﬁt an adversary, we assume that the groups G and H coincide. Suppose
the adversary outputs a purported forgery signature σ∗ on a policy Υ∗ and message m∗ such
that (m∗, Υ∗) (cid:54)= (m(q), Υ(q)) for all q. Let M∗ ∈ Zp
be the corresponding monotone span
program with row labeling u∗(·). Let µ∗ = H(m∗(cid:107)Υ∗), and suppose the signature has the form
σ∗ = (gy∗
1 , . . . , gp∗
1 , . . . , gs∗
l∗ , gp∗
, gw∗
, gs∗
l∗×t∗
t∗ ).
To be a forgery, we need y∗ (cid:54)= 0, and w∗ = y∗/a0, and
s∗
i M∗
i,j(a + u∗(i)b)∆j = y∗zj∆j + (c + µ∗)p∗
j
(∀j ∈ [t∗])
WLOG we can assume that these constraints are functionally satisﬁed (when viewing y∗, w∗, s∗
i ,
etc. as appropriate functions in the random variables generated in the experiment); otherwise
equality holds only with negligible probability. The rest of our proof proceeds by assuming these
constraints are functionally equivalent, and eventually obtaining a contradiction: that there exists
a k0 ∈ [n] such that Υ(Ak0) = 1. In other words, the adversary could have generated a signature
legitimately with the signing key for Ak0, and thus the output is not a forgery.
We know that y∗, w∗, s∗
1, . . . , s∗
l∗, p∗
1, . . . , p∗
t∗ ∈ Lin(Γ), where
l∗(cid:88)
i=1
Γ ={1, a0, ∆0, c} ∪ {∆j, a∆j, b∆j | j ∈ [tmax]}
∪ {xk, xk/a0, xk/(a + bu) | k ∈ [n], u ∈ Ak}
∪ {s(q)
, y(q), w(q), p(q)
| q ∈ [ν], i ∈ [l(q)], j ∈ [t(q)]}
i
j
The rest of our analysis proceeds by comparing terms in these constraints. We can show that the
multilinear functions given by the adversary’s forgery cannot contain terms of certain kinds. Since
y∗ = w∗a0, we get that:
y∗ ∈ Hom
It is easy to see that ∆j|(c + µ∗)p∗
(cid:16){∆0a0} ∪ {xk : k ∈ [n]} ∪ {y(q) : q ∈ [ν]}(cid:17)
: q ∈ [ν]}(cid:17)
(cid:16){∆j, ∆ja, ∆jb} ∪ {p(q)
j and hence ∆j|p∗
j. So,
j ∈ Hom
p∗
Consider j0 such that zj0
i s∗
∆0a0∆j0 monomial in y∗zj∆j0. This monomial cannot occur in (c + µ∗)p∗
(cid:54)= 0. Then suppose y∗ has a ∆0a0 term. Then there is a
, nor can it occur
i Mi,j0(a + u∗(i)b)∆j0, since all monomials from the sum have a factor of a or b. Hence,
in(cid:80)l∗
j0
j
(cid:16){xk : k ∈ [n]} ∪ {y(q) : q ∈ [ν]}(cid:17)
y∗ ∈ Hom
j has ∆j term. Then the right hand side contributes monomials ∆j and b∆j. Because
y∗ has no constant term, y∗zj∆j can not contribute a ∆j monomial. And similar to above,
Suppose p∗
(cid:80)l∗
i Mi,j(a + u∗(i)b)∆j can not contribute a monomial with ∆j alone, hence
i s∗
(cid:16){∆ja, ∆jb} ∪ {p(q)
j
: q ∈ [ν]}(cid:17)
j ∈ Hom
p∗
24
j has a p(q)
Suppose p∗
term. Then on the right hand side we will have a contribution of (c+µ∗)p∗
j,
producing a term with a factor of (c + µ∗)/(c + µ(q)). Since µ∗ (cid:54)= µ(q) for any q, this is a proper
rational. No setting of y∗ or {s∗
i}i∈[l∗] can yield terms in the ﬁnal equation with a factor of
(c + µ∗)/(c + µ(q)). Hence:
j
nor(cid:80)l∗
Consider j0 such that zj0 (cid:54)= 0. Now, y∗ can not have a y(q) term, because neither (c + µ∗)p∗
i s∗
i Mi,j0(a + u∗(i)b)∆j0 can contribute a monomial of this form. Hence:
j0
j ∈ Hom ({∆ja, ∆jb})
p∗
y∗ ∈ Hom ({xk : k ∈ [n]})
Finally we conclude that:
j ∈ Hom ({∆ja, ∆jb})
p∗
and
y∗ ∈ Hom({xk : k ∈ [n]})
Observe that any term which appears in y∗ must also be contributed from the left hand side, to
make the expression equal. So, we can split s∗
i into two parts; one whose terms involve xk variables,
and one which does not. Let
(cid:111)
i (Xi) + δ∗(Γ \ Xi)
s∗
i = t∗
(a+u∗(i)b) : u(i) ∈ Ak, k ∈ [n]
. Observe that t∗
l∗(cid:88)
i ∈ Hom(Xi), and satisﬁes the following
where Xi =
equation for all j ∈ [t]:
(cid:110)
xk
Consider any xk0 such that it has a non-zero coeﬃcient in y∗. Construct v∗
i , for i ∈ [l], by deﬁning
t∗
i M∗
i=1
i,j(a + u∗(i)b) = y∗zj
(cid:21)
(cid:20)
xk0
a + u∗(i)b
t∗
i
v∗
i =
1
[xk0]y∗
where the [x]π notation denotes the coeﬃcient of the term x in π. We see that v∗ is a vector of
constant coeﬃcients which satisﬁes the equation v∗M∗ = [z1 . . . zt] = [1, 0 . . . , 0]. Further, in every
(cid:54)= 0, the set Ak0 surely contained the attribute u∗(i). By the properties of the
position where v∗
monotone span program, it must be the case that Υ∗(Ak0) = 1, and thus the signature is not a
forgery.
i
E Simulation-Extractable Identity-Based NIZK and ABS
Our technique of augmenting a NIWI proof with a digital signature scheme can be used to make
any NIWI argument of knowledge into a simulation-extractable, identity-based NIZK argument of
knowledge. Identity-based NIZK was deﬁned in [24] as a NIZK proof with an associated identity.
The soundness deﬁnition requires that seeing a proof under one identity does not help one to
construct proofs under another identity (even proofs of the same statement).
Simulation-soundness [32], informally, requires that seeing a simulated proof does not help one
to violate the soundness property of a proof system.
In the case of proofs (or arguments) of
knowledge, the corresponding notion is termed “simulation-extractability.” We are interested in
incorporating simulation-extractability into identity-based NIZK arguments of knowledge. We note
that the identity-based NIZK from [24] is not simulation-sound.
25
Theorem 7. Any statement provable in via Groth-Sahai proofs can be made an identity-based,
simulation extractable, NIZK argument of knowledge, with overhead linear in the number of
variables (independent of the number of constraints).
Proof. The identity-based, simulation extractable NIZK scheme in the above theorem is described
as follows:
ID-NIZK.Setup: Run crs ← ID-NIZK.Setup and (vk, sk) ← DS.KeyGen. Publish crs(cid:48) = (crs, vk).
ID-NIZK.SimSetup: Run (crs, ψ) ← ID-NIZK.SimSetup and (vk, sk) ← DS.KeyGen. Publish
crs(cid:48) = (crs, vk), and use ψ(cid:48) = (ψ, sk) as the trapdoor.
ID-NIZK.Prove(crs(cid:48); Φ; id; w): Deﬁne Φ(cid:48)
encoding of (id, Φ). Output the result of NIWI.Prove(crs; Φ(cid:48)
ID-NIZK.Verify(crs(cid:48); Φ; id; π): Deﬁne Φ(cid:48)
ID-NIZK.Extract(crs(cid:48), ψ(cid:48), π): Output the result of NIWI.Extract(crs, ψ; π).
ID-NIZK.Simulate(crs(cid:48), ψ(cid:48); id; Φ): Deﬁne Φ(cid:48)
(id, Φ)). Output the result of NIWI.Prove(crs; Φ(cid:48)
vk,id; σ).
vk,id := ∃ w, σ : Φ(w) ∨ DS.Ver(vk, µ, σ) = 1, where µ is an
vk,id as above, then output the result of NIWI.Verify(crs; Φ(cid:48)
vk,id; w).
vk,id; π).
vk,id as above, then compute σ ← DS.Sign(sk, µ =
Now we argue that the above construction indeed gives an ID-NIZK.
First, the crs(cid:48) output by ID-NIZK.Setup is indistinguishable from that of ID-NIZK.SimSetup,
directly by the security of NIWI.Setup, NIWI.SimSetup. Next, simulated proofs are indistinguishable
from legitimate proofs by the witness indistinguishability of NIWI.Prove.
Finally, we must show that if an adversary has access to an oracle for ID-NIZK.Simulate and
outputs a valid (verifying) proof π∗ on Φ∗ under id∗, where (id∗, Φ∗) have never been queried to