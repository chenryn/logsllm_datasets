# 业务补偿的设计重点业务补偿主要做两件事。1.  努力地把一个业务流程执行完成。2.  如果执行不下去，需要启动补偿机制，回滚业务流程。所以，下面是几个重点。-   因为要把一个业务流程执行完成，需要这个流程中所涉及的服务方支持幂等性。并且在上游有重试机制。-   我们需要小心维护和监控整个过程的状态，所以，千万不要把这些状态放到不同的组件中，最好是一个业务流程的控制方来做这个事，也就是一个工作流引擎。所以，这个工作流引擎是需要高可用和稳定的。这就好像旅行代理机构一样，我们把需求告诉它，它会帮我们搞定所有的事。如果有问题，也会帮我们回滚和补偿的。-   补偿的业务逻辑和流程不一定非得是严格反向操作。有时候可以并行，有时候，可能会更简单。总之，设计业务正向流程的时候，也需要设计业务的反向补偿流程。-   我们要清楚地知道，业务补偿的业务逻辑是强业务相关的，很难做成通用的。-   下层的业务方最好提供短期的资源预留机制。就像电商中的把货品的库存预先占住等待用户在    15    分钟内支付。如果没有收到用户的支付，则释放库存。然后回滚到之前的下单操作，等待用户重新下单。
# 小结好了，我们来总结一下今天分享的主要内容。首先，我介绍了 ACID 和 BASE两种不同级别的一致性。在分布式系统中，ACID有更强的一致性，但可伸缩性非常差，仅在必要时使用；BASE的一致性较弱，但有很好的可伸缩性，还可以异步批量处理；大多数分布式事务适合BASE。要实现 BASE事务，需要实现补偿逻辑，因为事务可能失败，此时需要协调各方进行撤销。补偿的各个步骤可以根据具体业务来确定是串行还是并行。由于补偿事务是和业务强相关的，所以必须实现在业务逻辑里。下篇文章中，我们讲述重试设计。希望对你有帮助。也欢迎你分享一下你的分布式服务用到了怎样的一致性？你是怎么实现补偿事务的？文末给出了《分布式系统设计模式》系列文章的目录，希望你能在这个列表里找到自己感兴趣的内容。-   弹力设计篇    -   [认识故障和弹力设计](https://time.geekbang.org/column/article/3912)    -   [隔离设计        Bulkheads](https://time.geekbang.org/column/article/3917)    -   [异步通讯设计        Asynchronous](https://time.geekbang.org/column/article/3926)    -   [幂等性设计        Idempotency](https://time.geekbang.org/column/article/4050)    -   [服务的状态        State](https://time.geekbang.org/column/article/4086)    -   [补偿事务 Compensating        Transaction](https://time.geekbang.org/column/article/4087)    -   [重试设计 Retry](https://time.geekbang.org/column/article/4121)    -   [熔断设计 Circuit        Breaker](https://time.geekbang.org/column/article/4241)    -   [限流设计        Throttle](https://time.geekbang.org/column/article/4245)    -   [降级设计        degradation](https://time.geekbang.org/column/article/4252)    -   [弹力设计总结](https://time.geekbang.org/column/article/4253)-   管理设计篇    -   [分布式锁 Distributed        Lock](https://time.geekbang.org/column/article/5175)    -   [配置中心 Configuration        Management](https://time.geekbang.org/column/article/5819)    -   [边车模式        Sidecar](https://time.geekbang.org/column/article/5909)    -   [服务网格 Service        Mesh](https://time.geekbang.org/column/article/5920)    -   [网关模式        Gateway](https://time.geekbang.org/column/article/6086)    -   [部署升级策略](https://time.geekbang.org/column/article/6283)-   性能设计篇    -   [缓存 Cache](https://time.geekbang.org/column/article/6282)    -   [异步处理        Asynchronous](https://time.geekbang.org/column/article/7036)    -   [数据库扩展](https://time.geekbang.org/column/article/7045)    -   [秒杀 Flash        Sales](https://time.geekbang.org/column/article/7047)    -   [边缘计算 Edge        Computing](https://time.geekbang.org/column/article/7086)![](Images/1c1e992cf41f5294df097aabed82f9e4.png){savepage-src="https://static001.geekbang.org/resource/image/fc/e9/fcc761001867c60f526665e237f831e9.jpg"}
# 47 \| 弹力设计篇之"重试设计"关于重试，这个模式应该是一个很普遍的设计模式了。当我们把单体应用服务化，尤其是微服务化，本来在一个进程内的函数调用就成了远程调用，这样就会涉及到网络上的问题。网络上有很多的各式各样的组件，如：DNS服务、网卡、交换机、路由器、负载均衡等设备，这些设备都不一定是稳定的，在数据传输的整个过程中，只要一个环节出了问题，那么都会导致问题。
# 重试的场景所以，我们需要一个重试的机制。但是，我们需要明白的是，**"重试"的语义是我们认为这个故障是暂时的，而不是永久的，所以，我们会去重试**。我认为，设计重试时，我们需要定义出什么情况下需要重试，例如，调用超时、被调用端返回了某种可以重试的错误（如繁忙中、流控中、维护中、资源不足等）。而对于一些别的错误，则最好不要重试，比如：业务级的错误（如没有权限、或是非法数据等错误），技术上的错误（如：HTTP的 503 等，这种原因可能是触发了代码的 bug，重试下去没有意义）。``{=html}
# 重试的策略关于重试的设计，一般来说，都需要有个重试的最大值，经过一段时间不断的重试后，就没有必要再重试了，应该报故障了。在重试过程中，每一次重试失败时都应该休息一会儿再重试，这样可以避免因为重试过快而导致网络上的负担加重。在重试的设计中，我们一般都会引入，Exponential Backoff的策略，也就是所谓的 \" 指数级退避\"。在这种情况下，每一次重试所需要的休息时间都会成倍增加。这种机制主要是用来让被调用方能够有更多的时间来从容处理我们的请求。这其实和TCP 的拥塞控制有点像。如果我们写成代码应该是下面这个样子。首先，我们定义一个调用返回的枚举类型，其中包括了 5 种返回错误------成功SUCCESS、维护中 NOT_READY、流控中 TOO_BUSY、没有资源NO_RESOURCE、系统错误 SERVER_ERROR。    public enum Results {    SUCCESS,     NOT_READY,     TOO_BUSY,    NO_RESOURCE,    SERVER_ERROR} 接下来，我们定义一个 Exponential Backoff 的函数，其返回 2的指数。这样，每多一次重试就需要多等一段时间。如：第一次等200ms，第二次要 400ms，第三次要等 800ms......    public static long getWaitTimeExp(int retryCount) {    long waitTime = ((long) Math.pow(2, retryCount) );    return waitTime;}下面是真正的重试逻辑。我们可以看到，在成功的情况下，以及不属于我们定义的错误下，我们是不需要重试的，而两次重试间需要等的时间是以指数上升的。    public static void doOperationAndWaitForResult() {        // Do some asynchronous operation.long token = asyncOperation();     int retries = 0;    boolean retry = false;     do {        // Get the result of the asynchronous operation.        Results result = getAsyncOperationResult(token);         if (Results.SUCCESS == result) {            retry = false;        } else if ( (Results.NOT_READY == result) ||                      (Results.TOO_BUSY == result) ||                      (Results.NO_RESOURCE == result) ||                      (Results.SERVER_ERROR == result) ) {            retry = true;        } else {            retry = false;        }        if (retry) {            long waitTime = Math.min(getWaitTimeExp(retries), MAX_WAIT_INTERVAL);            // Wait for the next Retry.            Thread.sleep(waitTime);        }    } while (retry && (retries++ `{=html}换句话来说，我觉得熔断器模式就像是那些容易导致错误的操作的一种代理。这种代理能够记录最近调用发生错误的次数，然后决定允许操作继续，或者立即返回错误。![](Images/2ee6418089681d6ad560e947befe12c8.png){savepage-src="https://static001.geekbang.org/resource/image/85/93/850b613bae392236fdd097c70f7a5093.png"}\（本图来自 Martin Fowler 的 Circuit Breaker）熔断器可以使用状态机来实现，内部模拟以下几种状态。-   **闭合（Closed）状态**：我们需要一个调用失败的计数器，如果调用失败，则使失败次数加    1。如果最近失败次数超过了在给定时间内允许失败的阈值，则切换到断开    (Open)    状态。此时开启了一个超时时钟，当该时钟超过了该时间，则切换到半断开（Half-Open）状态。该超时时间的设定是给了系统一次机会来修正导致调用失败的错误，以回到正常工作的状态。在    Closed    状态下，错误计数器是基于时间的。在特定的时间间隔内会自动重置。这能够防止由于某次的偶然错误导致熔断器进入断开状态。也可以基于连续失败的次数。-   **断开 (Open)    状态**：在该状态下，对应用程序的请求会立即返回错误响应，而不调用后端的服务。这样也许比较粗暴，有些时候，我们可以    cache    住上次成功请求，直接返回缓存（当然，这个缓存放在本地内存就好了），如果没有缓存再返回错误（缓存的机制最好用在全站一样的数据，而不是用在不同的用户间不同的数据，因为后者需要缓存的数据有可能会很多）。-   **半开（Half-Open）状态**：允许应用程序一定数量的请求去调用服务。如果这些请求对服务的调用成功，那么可以认为之前导致调用失败的错误已经修正，此时熔断器切换到闭合状态，同时将错误计数器重置。    如果这一定数量的请求有调用失败的情况，则认为导致之前调用失败的问题仍然存在，熔断器切回到断开状态，然后重置计时器来给系统一定的时间来修正错误。半断开状态能够有效防止正在恢复中的服务被突然而来的大量请求再次拖垮。![](Images/7c23fd33b17645536a6dad80e4bf3e86.png){savepage-src="https://static001.geekbang.org/resource/image/34/7f/34151c1a1caa1bd57a6fcdd3c92b7d7f.png"}\（本图来自 Martin Fowler 的 Circuit Breaker）实现熔断器模式使得系统更加稳定和有弹性，在系统从错误中恢复的时候提供稳定性，并且减少了错误对系统性能的影响。它快速地拒绝那些有可能导致错误的服务调用，而不会去等待操作超时或者永远不返回结果来提高系统的响应时间。如果熔断器设计模式在每次状态切换的时候会发出一个事件，这种信息可以用来监控服务的运行状态，能够通知管理员在熔断器切换到断开状态时进行处理。下图是 Netflix的开源项目[Hystrix](https://github.com/Netflix/Hystrix)中的熔断的实现逻辑（[其出处在这里](https://github.com/Netflix/Hystrix/wiki/How-it-Works#CircuitBreaker)）。![](Images/63494dc366d68c60d35835dd6ecce14f.png){savepage-src="https://static001.geekbang.org/resource/image/90/e4/908a291d5698db2dc4734119371241e4.png"}从这个流程图中，可以看到：1.  有请求来了，首先 allowRequest()    函数判断是否在熔断中，如果不是则放行，如果是的话，还要看有没有到达一个熔断时间片，如果熔断时间片到了，也放行，否则直接返回出错。2.  每次调用都有两个函数 markSuccess(duration) 和 markFailure(duration)    来统计一下在一定的 duration 内有多少调用是成功还是失败的。3.  判断是否熔断的条件 isOpen()，是计算一下 failure/(success+failure)    当前的错误率，如果高于一个阈值，那么打开熔断，否则关闭。4.  Hystrix    会在内存中维护一个数组，其中记录着每一个周期的请求结果的统计。超过时长长度的元素会被删除掉。