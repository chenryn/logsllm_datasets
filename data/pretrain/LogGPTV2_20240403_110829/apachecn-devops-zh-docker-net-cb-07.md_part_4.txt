--- web1.weave.local ping statistics ---
2 packets transmitted, 2 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.486/0.534/0.582/0.048 ms
user@docker2:~$ 
```
只要两个容器都在 Weave 网络上并且有适当的设置，Weave 就会自动生成一个带有容器名称的 DNS 记录。我们可以从任何启用了 Weave 的主机上使用`weave status dns`命令查看 Weave 知道的所有名称记录:
```
user@docker2:~$ weave status dns
web1         10.32.0.1       86029a1305f1 12:d2:fe:7a:c1:f2
web2         10.44.0.0       56927d3bf002 e6:b1:90:cd:76:da
user@docker2:~$ 
```
在这里，我们可以看到目的主机的 Weave 网络接口的容器名称、IP 地址、容器 ID 和 MAC 地址。
这种方法效果很好，但是依赖于使用适当的设置配置容器。这是另一个使用 Weave 命令行界面相当有帮助的场景，因为它确保这些设置在容器运行时就位。例如，如果我们用 Docker CLI 在主机`docker3`上启动另一个容器，然后将其附加到 Docker，它将不会获得 DNS 记录:
```
user@docker3:~$ docker run -dP --name=web1 jonlangemak/web_server_1
cd3b043bd70c0f60a03ec24c7835314ca2003145e1ca6d58bd06b5d0c6803a5c
user@docker3:~$ weave attach web1
10.36.0.0
user@docker3:~$ docker exec -it web1 ping web2
ping: unknown host
user@docker3:~$
```
这不起作用有两个原因。首先，容器不知道从哪里寻找 Weave DNS，它试图通过 Docker 提供的 DNS 服务器来解决这个问题。在本例中，这是在 Docker 主机上配置的:
```
user@docker3:~$ docker exec -it web1 more /etc/resolv.conf
# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)
#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
nameserver 10.20.30.13
search lab.lab
user@docker3:~$
```
其次，当容器被附加时，Weave 没有在 WeaveDNS 中注册记录。为了让 Weave 在 WeaveDNS 中为容器生成记录，容器必须在同一个域中。为此，当 Weave 通过其 CLI 运行容器时，它会传递容器的主机名和域名。我们可以通过在 Docker 中运行容器时提供主机名来模拟这种行为。例如:
```
user@docker3:~$ docker stop web1
user@docker3:~$ docker rm web1
user@docker3:~$ docker run -dP --hostname=web1.weave.local \
--name=web1 jonlangemak/web_server_1
04bb1ba21b692b4117a9b0503e050d7f73149b154476ed5a0bce0d049c3c9357
user@docker3:~$
```
现在，当我们将容器附加到 Weave 网络时，我们应该会看到为其生成的 DNS 记录:
```
user@docker3:~$ weave attach web1
10.36.0.0
user@docker3:~$ weave status dns
web1         10.32.0.1       86029a1305f1 12:d2:fe:7a:c1:f2
web1         10.36.0.0       5bab5eae10b0 ae:af:a6:36:18:37
web2         10.44.0.0       56927d3bf002 e6:b1:90:cd:76:da
user@docker3:~$
```
### 注
如果你想让这个容器也能够解析 Weave 域名系统中的记录，你还需要将`--dns=172.17.0.1`标志传递给容器，以确保它的域名系统服务器被设置为`docker0`桥的 IP 地址。
您可能已经注意到，我们现在在 WeaveDNS 中有两个条目用于相同的容器名称。这就是 Weave 在 Weave 网络中提供基本负载平衡的方式。例如，如果我们返回到`docker2`主机，让我们尝试 ping 名称`web1`几次:
```
user@docker2:~$ docker exec -it web2 ping web1 -c 1
PING web1.weave.local (10.32.0.1): 48 data bytes
56 bytes from 10.32.0.1: icmp_seq=0 ttl=64 time=0.494 ms
--- web1.weave.local ping statistics ---
1 packets transmitted, 1 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.494/0.494/0.494/0.000 ms
user@docker2:~$ docker exec -it web2 ping web1 -c 1
PING web1.weave.local (10.36.0.0): 48 data bytes
56 bytes from 10.36.0.0: icmp_seq=0 ttl=64 time=0.796 ms
--- web1.weave.local ping statistics ---
1 packets transmitted, 1 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.796/0.796/0.796/0.000 ms
user@docker2:~$ docker exec -it web2 ping web1 -c 1
PING web1.weave.local (10.32.0.1): 48 data bytes
56 bytes from 10.32.0.1: icmp_seq=0 ttl=64 time=0.507 ms
--- web1.weave.local ping statistics ---
1 packets transmitted, 1 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.507/0.507/0.507/0.000 ms
user@docker2:~$
```
注意在第二次 ping 尝试期间，容器如何解析到不同的 IP 地址。由于在织入域名系统中有多个相同名称的记录，我们可以只使用域名系统来提供基本的负载平衡功能。Weave 还将跟踪容器的状态，并将死容器从 WeaveDNS 中拉出。例如，如果我们在主机`docker3`上杀死容器，我们应该看到其中一个`web1`记录从 DNS 中掉出，只留下一个记录给`web1`:
```
user@docker3:~$ docker stop web1
web1
user@docker3:~$ weave status dns
web1         10.32.0.1       86029a1305f1 12:d2:fe:7a:c1:f2
web2         10.44.0.0       56927d3bf002 e6:b1:90:cd:76:da
user@docker3:~$
```
### 注
有许多不同的配置选项可供您定制 Weave 域名系统的工作方式。要查看整个指南，请查看[https://www.weave.works/docs/net/latest/weavedns/](http:// https://www.weave.works/docs/net/latest/weavedns/)的文档。
# 织安全
Weave 提供了几个属于安全范畴的特性。由于 Weave 是一种基于覆盖的网络解决方案，它能够在覆盖流量穿过物理或底层网络时对其进行加密。当您的容器可能需要穿越公共网络时，这可能特别有用。此外，Weave 允许您在某些网段内隔离容器。Weave 依赖于为每个隔离网段使用不同的子网来实现这一点。在本食谱中，我们将介绍如何配置覆盖加密，以及如何在 Weave 网络中为不同的容器提供隔离。
## 做好准备
假设您正在构建我们在本章第一个食谱中创建的实验室。还假设主机安装了 Docker 和 Weave。Docker 应该处于默认配置，Weave 应该已安装但尚未对等。如果需要删除前面示例中定义的对等，请在每台主机上发出`weave reset`命令。
## 怎么做…
配置 Weave 来加密覆盖网络非常简单；但是，必须在 Weave 的初始配置期间完成。使用前面配方中相同的实验拓扑，让我们运行以下命令来构建 Weave 网络:
*   主机上`docker1` :
    ```
    weave launch-router --password notverysecurepwd \
    --trusted-subnets 192.168.50.0/24 --ipalloc-range \
    172.16.16.0/24 --ipalloc-default-subnet 172.16.16.128/25
    ```
*   在主机`docker2`、`docker3`和`docker4` :
    ```
    weave launch-router --password notverysecurepwd \
    --trusted-subnets 192.168.50.0/24 --ipalloc-range \
    172.16.16.0/24 --ipalloc-default-subnet \
    172.16.16.128/25 10.10.10.101
    ```
    上
您会注意到，我们在主机上运行的命令基本上是相同的，除了最后三个主机指定`docker1`作为对等体，以便构建 Weave 网络。无论是哪种情况，在 Weave 初始化期间，我们都向路由器传递了一些额外的参数:
*   `--password`:这就是启用 Weave 节点之间通信加密的原因。与我的示例不同，您应该选择一个非常安全的密码来使用。这需要在运行 Weave 的每个节点上相同。
*   `--trusted-subnets`:这个可以让你把主机的子网定义为可信的，也就是说它们不需要对它们的通信进行加密。当 Weave 进行加密时，它会退回到比通常使用的更慢的数据路径。由于使用`--password`参数会端到端开启加密，因此将一些子网定义为不需要加密可能是有意义的
*   `--ipalloc-range`:这里我们把更大的 Weave 网定义为`172.16.16.0/24`。我们在早期的食谱中看到了这个命令:
*   `--ipalloc-default-subnet`:这指示 Weave，默认情况下，从较大 Weave 分配的较小子网中分配容器 IP 地址。在这种情况下，那就是`172.16.16.128/25`。
现在，让我们在每台主机上运行以下容器:
*   `docker1` :
    ```
    weave run -dP --name=web1tenant1 jonlangemak/web_server_1
    ```
*   `docker2` :
    ```
    weave run -dP --name=web2tenant1 jonlangemak/web_server_2
    ```
*   `docker3` :
    ```
    weave run net:172.16.16.0/25 -dP --name=web1tenant2 \
    jonlangemak/web_server_1
    ```
*   `docker4` :
    ```
    weave run net:172.16.16.0/25 -dP --name=web2tenant2 \
    jonlangemak/web_server_2
    ```
你会注意到在主机`docker3`和`docker4`上，我增加了`net:172.16.16.0/25`参数。回想一下，当我们开始 Weave 网络时，我们告诉 Weave 默认情况下从`172.16.16.128/25`中分配 IP 地址。我们可以在容器运行时覆盖它，并为 Weave 提供一个新的子网，只要它在更大的 Weave 网络中就可以使用。在这种情况下，`docker1`和`docker2`上的容器将在`172.16.16.128/25`内获得一个 IP 地址，因为这是默认的。`docker3`和`docker4`上的容器将在`172.16.16.0/25`内获得一个 IP 地址，因为我们覆盖了默认值。我们可以在您启动所有容器后确认这一点:
```
user@docker4:~$ weave status dns
web1tenant1  172.16.16.129   26c58ef399c3 12:d2:fe:7a:c1:f2
web1tenant2  172.16.16.64    4c569073d663 ae:af:a6:36:18:37
web2tenant1  172.16.16.224   211c2e0b388e e6:b1:90:cd:76:da
web2tenant2  172.16.16.32    191207a9fb61 42:ec:92:86:1a:31
user@docker4:~$
```
正如我前面提到的，使用不同的子网是 Weave 提供容器分段的方式。在这种情况下，拓扑如下所示:
![How to do it…](img/B05453_07_06.jpg)
虚线象征着 Weave 在覆盖网络中为我们提供的隔离。由于`tenant1`容器是独立于`tenant2`容器的子网，因此它们不会有连接。通过这种方式，Weave 使用基本网络来实现容器隔离。我们可以通过一些测试来证明这一点:
```
user@docker4:~$ docker exec -it web2tenant2 curl http://web1tenant2
    Web Server #1 - Running on port 80
user@docker4:~$ docker exec -it web2tenant2 curl http://web1tenant1
user@docker4:~$ docker exec -it web2tenant2 curl http://web2tenant1
user@docker4:~$
user@docker4:~$ docker exec -it web2tenant2 ping web1tenant1 -c 1