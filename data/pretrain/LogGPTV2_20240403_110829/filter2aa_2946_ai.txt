    // 3. 读取数据
16
    DWORD dwReadLength;
17
    ReadFile(hFile, pszBuffer, fileSize, &dwReadLength, NULL);
18
    // 4. 释放内存
19
    free(pszBuffer);
20
    // 5. 关闭文件
21
    CloseHandle(hFile);
22
    return 0;
23
}
24
滴水逆向课程笔记  –  Win32
文件系统  –  112
22.3.6 查找文件
函数FindFirstFile、FindNextFile用于查找文件，其语法格式如下：
示例代码如下：
HANDLE FindFirstFile(
1
  LPCTSTR lpFileName,               // file name 输入类型，文件名
2
  LPWIN32_FIND_DATA lpFindFileData  // data buffer 输出类型，WIN32_FIND_DATA结构体指针，找到的文件数据
3
);
4
5
BOOL FindNextFile(
6
  HANDLE hFindFile,                // search handle  输入类型，搜索句柄
7
  LPWIN32_FIND_DATA lpFindFileData // data buffer 输出类型，WIN32_FIND_DATA结构体指针，存放找到的文件数
据
8
);
9
滴水逆向课程笔记  –  Win32
文件系统  –  113
WIN32_FIND_DATA firstFile;
1
WIN32_FIND_DATA nextFile;
2
// 在C盘下搜索.txt后缀的文件
3
HANDLE hFile = FindFirstFile(TEXT("C:\\*.txt"), &firstFile);
4
printf("第一个文件名: %s 文件大小: %d\n", firstFile.cFileName, firstFile.nFileSizeLow);
5
if (hFile != INVALID_HANDLE_VALUE) {
6
    // 有搜索到，就使用FindNextFile寻找下一个文件，FindNextFile函数返回为真则表示搜索到了
7
    while (FindNextFile(hFile, &nextFile)) {
8
        printf("文件名: %s 文件大小: %d\n", nextFile.cFileName, nextFile.nFileSizeLow);
9
    }
10
}
11
滴水逆向课程笔记  –  Win32
内存映射文件  –  114
1.
2.
23 内存映射文件
23.1 什么是内存映射文件
内存映射文件就如下图，将硬盘某个文件映射到物理页上，然后再将物理页映射到虚拟内存中。
优点：
访问文件就像访问内存一样简单，想读就读，想怎么样就怎么样，不用那么繁杂；
当文件过大时，使用内存映射文件的方式，性能相对于普通I/O的访问要好很多。
23.2 内存映射文件读写
之前我们学习过用CreateFileMapping函数来创建共享内存，这个函数同样也可以将文件映射到物理页，只不过
在这之前我们需要传递一个文件句柄。
如下代码我们写了一个读取文件最开始第一个字节的值：
滴水逆向课程笔记  –  Win32
内存映射文件  –  115
调用函数运行之后成功输出，并获取到对应内容：
DWORD MappingFile(LPSTR lpcFile) {
1
    HANDLE hFile;
2
    HANDLE hMapFile;
3
    LPVOID lpAddr;
4
5
    // 1. 创建文件（获取文件句柄）
6
    hFile = CreateFile(lpcFile, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 
FILE_ATTRIBUTE_NORMAL, NULL);
7
8
    // 判断CreateFile是否执行成功
9
    if(hFile == NULL) {
10
        printf("CreateFile failed: %d \n", GetLastError());
11
        return 0;
12
    }
13
14
    // 2. 创建FileMapping对象
15
    hMapFile = CreateFileMapping(hFile, NULL, PAGE_READWRITE, 0, 0, NULL);
16
17
    // 判断CreateFileMapping是否执行成功
18
    if(hMapFile == NULL) {
19
        printf("CreateFileMapping failed: %d \n", GetLastError());
20
        return 0;
21
    }
22
23
    // 3. 物理页映射到虚拟内存
24
    lpAddr = MapViewOfFile(hMapFile, FILE_MAP_COPY, 0, 0, 0);
25
26
    // 4. 读取文件
27
    DWORD dwTest1 = *(LPDWORD)lpAddr; // 读取最开始的4字节
28
    printf("dwTest1: %x \n", dwTest1);
29
    // 5. 写文件
30
    // *(LPDWORD)lpAddr = 0x12345678;
31
32
    // 6. 关闭资源
33
    UnmapViewOfFile(lpAddr);
34
    CloseHandle(hFile);
35
    CloseHandle(hMapFile);
36
    return 0;
37
}
38
MappingFile(TEXT("C:\\A.txt"));
1
滴水逆向课程笔记  –  Win32
内存映射文件  –  116
小技巧 → 在VC6中想要以HEX的形式查看某个文件的话可以在打开文件的时候这样设置：
举一反三，写文件也很简单，但是需要注意的是写文件不是立即生效的，而是先将写入的存放到缓存中，只有
等到你释放资源了才会把缓存里的值真正的写入到文件。
如果你希望修改可以立即生效，我们可以通过FlushViewOfFile函数来强制更新缓存，其语法格式如下：
示例代码：
BOOL FlushViewOfFile(
1
  LPCVOID lpBaseAddress,         // starting address 你要刷新的地址
2
  SIZE_T dwNumberOfBytesToFlush  // number of bytes in range 要刷新的大小（字节）
3
);
4
FlushViewOfFile(((LPDWORD)lpAddr), 4);
1
滴水逆向课程笔记  –  Win32
内存映射文件  –  117
23.3 内存映射文件之共享
内存映射文件可以让2个进程同时共享一个文件：
其实本质很简单，我们只需要在创建FileMapping对象时候给其一个对象名称即可。
现在我们来A进程写入，B进程读取看看到底能不能跨进程恭喜，写入代码：
滴水逆向课程笔记  –  Win32
内存映射文件  –  118
读取代码：
#define MAPPINGNAME "Share File"
1
2
DWORD MappingFile(LPSTR lpcFile) {
3
    HANDLE hFile;
4
    HANDLE hMapFile;
5
    LPVOID lpAddr;
6
7
    // 1. 创建文件（获取文件句柄）
8
    hFile = CreateFile(lpcFile, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 
FILE_ATTRIBUTE_NORMAL, NULL);
9
10
    // 判断CreateFile是否执行成功
11
    if(hFile == NULL) {
12
        printf("CreateFile failed: %d \n", GetLastError());
13
        return 0;
14
    }
15
16
    // 2. 创建FileMapping对象
17
    hMapFile = CreateFileMapping(hFile, NULL, PAGE_READWRITE, 0, 0, MAPPINGNAME);
18
19
    // 判断CreateFileMapping是否执行成功
20
    if(hMapFile == NULL) {
21
        printf("CreateFileMapping failed: %d \n", GetLastError());
22
        return 0;
23
    }
24
25
    // 3. 物理页映射到虚拟内存
26
    lpAddr = MapViewOfFile(hMapFile, FILE_MAP_ALL_ACCESS, 0, 0, 0);
27
28
    // 4. 读取文件
29
    // DWORD dwTest1 = *(LPDWORD)lpAddr; // 读取最开始的4字节
30
    // printf("dwTest1: %x \n", dwTest1);
31
    // 5. 写文件
32
    *(LPDWORD)lpAddr = 0x41414142;
33
    FlushViewOfFile(((LPDWORD)lpAddr), 4);
34
    printf("Process A Write");
35
    getchar();
36
    // 6. 关闭资源
37
    UnmapViewOfFile(lpAddr);
38
    CloseHandle(hFile);
39
    CloseHandle(hMapFile);
40
    return 0;
41
}
42
滴水逆向课程笔记  –  Win32
内存映射文件  –  119
分别使用getchar函数挂住了运行，A进程写入0x41414142，B进程也成功读取到了这个值：
#define MAPPINGNAME "Share File"
1
2
DWORD MappingFile(LPSTR lpcFile) {
3
    HANDLE hMapFile;
4
    LPVOID lpAddr;
5
6
    // 1. 打开FileMapping对象
7
    /*
8
    OpenFileMapping 函数语法格式：
9
    HANDLE OpenFileMapping(
10
        DWORD dwDesiredAccess,  // access mode 访问模式
11
        BOOL bInheritHandle,    // inherit flag 继承标识，为真则表示这个可以被新进程继承，为假反之
12
        LPCTSTR lpName          // object name 对象名称
13
    );
14
    */
15
    hMapFile = OpenFileMapping(FILE_MAP_ALL_ACCESS, FALSE, MAPPINGNAME);
16
17
    // 2. 物理页映射到虚拟内存
18
    lpAddr = MapViewOfFile(hMapFile, FILE_MAP_ALL_ACCESS, 0, 0, 0);
19
20
    // 3. 读取文件
21
    DWORD dwTest1 = *(LPDWORD)lpAddr; // 读取最开始的4字节
22
    printf("dwTest1: %x \n", dwTest1);
23
    // 4. 写文件
24
    // *(LPDWORD)lpAddr = 0x41414142;
25
    printf("Process B Read");
26
    getchar();
27
    // 5. 关闭资源
28
    UnmapViewOfFile(lpAddr);
29
    CloseHandle(hMapFile);
30
    return 0;
31
}
32
滴水逆向课程笔记  –  Win32
内存映射文件  –  120
23.4 内存映射文件之写拷贝
我们知道了内存映射文件可以共享，但是这样也有弊端，如下图所示，实际上我们程序调用的user32.dll这类dll
文件，也是通过这种方式进行调用的，如果我们进场A修改了某个DLL，就会导致进程B出问题。
为了解决这种隐患，我们可以使用写拷贝的方式来处理。
写拷贝的实现就是MapViewOfFile函数中的第二个参数值为FILE_MAP_COPY，它的意思表示当你在写的时候进
行拷贝。
当我们设置为该熟悉时，则多进程之间读取的是同一块物理页，但是当进程A写入的时候则会将这份物理页拷
贝为一个新的物理页进行写：
滴水逆向课程笔记  –  Win32
内存映射文件  –  121
写拷贝属性时候，写入时并不会影响原本的文件内容。
滴水逆向课程笔记  –  Win32
静态链接库  –  122
24 静态链接库
软件随着更迭会越来越复杂，包含的功能会很多，一个大型软件参与开发的人会非常多，因为不可能一个把所
有事情干了，这样就会把软件分为多个模块，每个模块有对应的人去写，静态链接库就是软件模块化的一种解
决方案。
24.1 编写静态链接库文件
在VC6中创建静态链接库项目：
创建项目A，然后新建A.cpp和A.h，在A.h中声明一个add方法，在A.cpp中实现该方法：
滴水逆向课程笔记  –  Win32
静态链接库  –  123
编译一下，在项目目录的Debug目录下会有一个A.lib文件，这就是我们的静态链接库：
滴水逆向课程笔记  –  Win32
静态链接库  –  124
如果我们需要给别人用的话那就需要A.lib + A.h这个头文件一起给别人。
24.2 静态链接库的使用
静态链接库的使用有两种方法：
24.2.1 项目根目录
第一种方法：将生成的.h与.lib文件复制到项目根目录，然后在代码中引用：
#include "xxxx.h"
1
#pragma comment(lib, "xxxx.lib")
2
滴水逆向课程笔记  –  Win32
静态链接库  –  125
•
•
24.2.2 VC6安装目录
第二种方法：将xxxx.h与xxxx.lib文件复制到VC6安装目录，与库文件放在一起，然后在工程->设置->连接->对象/
库模块中添加xxxx.lib，最后就可以像使用C语言库一样使用它了
头文件路径：C:\Program Files\Microsoft Visual Studio\VC98\Include
静态链接库路径：C:\Program Files\Microsoft Visual Studio\VC98\Lib
滴水逆向课程笔记  –  Win32
静态链接库  –  126
在编辑框中写入A.lib，多个lib文件以空格隔开：
24.3 静态链接库的缺点
第一个：使用静态链接生成的可执行文件体积较大，例如我们从汇编层面来看，是根本无法区分哪个是静态库
中的代码的：
同时我们也了解了静态链接库的本质，那就是把你想要调用的接口（函数）直接写入到你的程序中。
滴水逆向课程笔记  –  Win32
静态链接库  –  127
第二个：包含相同的公共代码，造成浪费，假设我们在多个项目中使用同一个静态链接库，其实也就表示相同
的代码复制多份。
滴水逆向课程笔记  –  Win32
动态链接库  –  128
25 动态链接库
动态链接库弥补了静态链接库的两个缺点，动态链接库（Dynamic Link Library，缩写为DLL），是微软公司在
微软Windows操作系统中对共享函数库概念的一种实现方式，这些库函数的文件扩展名称为：.dll、.ocx（包含
ActiveX控制的库）。
25.1 创建动态链接库
25.1.1 extern的方式
VC6创建项目：
与静态链接库的创建方式一样，我们创建一个新的类MyDLL，这样就会自动创建MyDLL.h和MyDLL.cpp：
滴水逆向课程笔记  –  Win32
动态链接库  –  129
在头文件MyDLL.h中我们要声明接口（函数），需要使用固定格式来声明而不能像静态链接库那样直接使用，
格式如下：
在MyDLL.cpp中实现方法，需要在开头写上一致的调用约定：
extern "C" _declspec(dllexport) 调用约定 返回类型 函数名 (参数列表);
1
滴水逆向课程笔记  –  Win32
动态链接库  –  130
编译后在Debug目录就会生成B.dll文件：