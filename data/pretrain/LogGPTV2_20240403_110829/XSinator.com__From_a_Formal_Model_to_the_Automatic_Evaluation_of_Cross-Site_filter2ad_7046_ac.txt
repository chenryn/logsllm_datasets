Frames
Pop-ups
Frames
Frames
Fetch API
HTML Elements
Frames
Frames
Table 1: Overview of XS-Leaks attacks sorted by their detectable difference integrated into our formal model. We contribute
novel attack techniques indicated by +.
Afterwards, the website can query the API to request payment.
The browser then shows a UI pop-up to the user, and the user can
confirm the purchase with one single click on a button. Similar
to the WebSocket API, the standard specification recommends a
global limit of one singular UI element [28]. If the target website is
using the Payment Request API, any further attempts to show this
UI will be blocked, and cause a JavaScript exception. The attacker
can exploit this by periodically attempting to show the Payment
API UI. If one attempt causes an exception, the target website is
currently using it. The attacker can hide these periodical attempts
by immediately closing the UI after creation. Instead of opening
the UI and then closing it, the browser never shows the UI, and the
user takes no notice of the attack.
Example Attack: A specific product provided by the website
shop.org is advertised on a website, for example, blog.com, using an
affiliate link. The operator of shop.org can use our attack to identify
if a customer bought the product after clicking on provided affiliate
link.
Session 6B: Web Vulnerabilities CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea17775.2 Leak Technique: Performance API
We developed new XS-Leak attacks based on the Performance API,
which allows an attacker to leak various characteristics of the target
page.
Details: The Performance API is used to access the performance
information of the current page. This includes detailed network
timing data for the document and every resource the page loads.
Terjanq [55] showed how to detect the X-Frame-Options header in
GC. We used his work as a base to create novel attacks that allow to
differentiate between status codes, to detect empty pages, to detect
if the XSS-Auditor is executed, and we improved terjanq’s work to
detect X-Frame-Options in non-Chromium-based browsers. The
Performance API specifies that all fetched resources must create a
performance entry [29]. We identified cases where browsers will
not create an entry for a specific request. That means an attacker
can differentiate requests by checking if a performance entry is
created. The following 8 new XS-Leak attacks are based on this
observation:
• Error Leak: It is possible to differentiate between HTTP re-
sponse status codes because requests that lead to an error do
not create a performance entry. This has a similar impact to
XS-Leak described in Section A.1. We also identified two cases
where browser bugs in GC lead to resources being loaded twice
when they fail to load. This will result in multiple entries in the
Performance API and can thus be detected.
• Empty Page Leak: An attacker can detect if a request resulted
in an empty HTTP response body because empty pages do not
create a performance entry in some browsers.
• XSS-Auditor Leak: In SA, it is possible to detect if the XSS-
Auditor was triggered and thus leak sensitive information. The
XSS-Auditor is a built-in feature of SA and GC (now removed [10])
designed to mitigate Cross-Site Scripting (XSS) attacks. It aims
to protect against reflected XSS by checking query parameters.
In 2013, Braun and Heiderich [7] showed that the XSS-Auditor
can be used to block benign scripts with false positives. Based
on their technique, researchers exfiltrate information and detect
specific content on a cross-origin page. These XS-Leaks were
first described in a bug report by Terada [52] and later in a blog
post by Heyes [24]. However, the discovered techniques applied
only to the XSS-Auditor in GC and do not work in SA. We found
that blocked pages will not create Performance API entries. That
means an attacker can still leak sensitive information with the
XSS-Auditor in SA.
• X-Frame Leak: If a page is not allowed to be rendered in an
iframe it does not create a performance entry. As a result, an
attacker can detect the response header X-Frame-Options.
• Download Detection: Similar, to the XS-Leak described in Sec-
tion A.5, a resource that is downloaded because of the Content-
Disposition header, also does not create a performance entry.
This technique works in all major browsers.
• Redirect Start Leak: We found one XS-Leak instance that abuses
the behavior of some browsers which log too much information
for cross-origin requests. The standard defines a subset of at-
tributes that should be set to zero for cross-origin resources.
However, in SA it is possible to detect if the user is redirected by
the target page, by querying the Performance API and checking
for the redirectStart timing data.
• Duration Redirect Leak: In GC, the duration for requests that
result in a redirect is negative and can thus be distinguished from
requests that do not result in a redirect.
• CORP Leak: In some cases, the nextHopProtocol entry can be
used as a leak technique. In GC, when the CORP header is set, the
nextHopProtocol will be empty. Note that SA will not create a
performance entry at all for CORP-enabled resources.
5.3 Leak Technique: Error Messages
CORS Error. This technique allows an attacker to leak the target
of a redirect that is initiated by a cross-origin site.
Details: CORS is used to explicitly allow access between cross-
origin sites that would otherwise be forbidden by the SOP. Access
-Control headers let servers describe which origins are permitted
to access the response and whether credentials should be included
with the request. CORS allows publicly accessible web resources to
be read and used from any website. In Webkit-based browsers, it is
possible to access CORS error messages when a CORS request fails.
An attacker can send a CORS-enabled request to a target website
which redirects based on the user state. When the browser denies
the request, the full URL of the redirect target is leaked in the error
message. With this attack, it is possible to detect redirects, leak
redirect locations, and sensitive query parameters.
SRI Error. An attacker can leak the size of cross-origin responses
due to verbose error messages.
Details: The integrity attribute defines a cryptographic hash
by which the browser can verify that a fetched resource has not
been manipulated. This security mechanism is called Subresource
Integrity (SRI) [3]. It is used for integrity verification of resources
served from content delivery networks (CDNs). To prevent data
leaks, cross-origin resources must be CORS-enabled. Otherwise, the
response is not eligible for integrity validation. Similar to the CORS
error XS-Leak, it is possible to catch the error message after a fetch
request with an integrity attribute fails. An attacker can forcefully
trigger this error on any request by specifying a bogus hash value.
In SA, this error message leaks the content length of the requested
resource. An attacker can use this leak to detect differences in
response size, which enables powerful XS-Leak attacks.
5.4 Leak Technique Readable Attributes
COOP. An attacker can leak if the Cross-Origin Opener Policy
(COOP) header is available within an cross-origin HTTP response.
Details: Web applications can deploy COOP response header to
prevent other websites from gaining arbitrary window references
to the application. However, this header can easily be detected by
trying to read the contentWindow reference. If a site only deploys
COOP in one state, this property is undefined, otherwise it is defined.
6 EVALUATION RESULTS
Table 2 shows evaluation results which are automatically generated
by using XSinator. We used browsers that are available on Browser-
Stack in our evaluation. This ensures two aspects. First, the results
Session 6B: Web Vulnerabilities CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1778 Chrome
 Edge
 Firefox
 Opera
 Safari
Tor Browser
)
r
e
f
a
s
(
.
0
7
8
.
0
3
3
.
1
0
6
.
3
0
5
7
.
.
2
0
3
.
.
0
4
1
.
0
4
1
.
5
1
0
0
1
.
.
6
1
0
0
1
.
.
6
1
0
0
1
.
.
0
9
8
.
0
9
8
.
0
6
8
.
4
3
6
4
.
.
0
0
9
.
7
3
6
4
.
.
4
1
1
8
.
(cid:240) B B
(cid:240) B 
(cid:240) B 
(cid:240) B 
(cid:240) B  B 
○␣ ○␣ ○ ○ ○␣ ○ ○␣ ○␣ ○ ○␣ ○␣ ○ ○ ○ ○␣ ○␣ ○␣
○ ○ ○ ○ ○ ○ ○␣ ○␣ ○ ○ ○ ○ ○ ○ ○␣ ○␣ ○␣
○ ○ ○ ○ ○ ○ ○␣ ○␣ ○ ○ ○ ○ ○ ○ ○␣ ○␣ ○␣
○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○
○␣ ○␣ ○␣ ○␣ ○␣ ○␣ ○␣ ○␣ ○␣ ○␣ ○␣ ○␣ ○␣ ○␣ ○␣ ○␣ ○␣
○␣ ○␣ ○ ○␣ ○␣ ○ ○␣ ○␣ ○ ○␣ ○␣ ○ ○ ○ ○␣ ○␣ ○␣
○␣ ○␣ ○ ○␣ ○␣ ○ ○␣ ○␣ ○ ○␣ ○␣ ○ ○ ○ ○␣ ○␣ ○␣
○␣ ○␣ ○␣ ○␣ ○␣ ○␣ ○␣ ○␣ ○␣ ○ ○␣ ○␣ ○␣ ○␣ ○␣ ○␣ ○␣
○ ○ ○␣ ○␣ ○ ○␣ ○␣ ○␣ ○␣ ○ ○ ○␣ ○␣ ○␣ ○␣ ○␣ ○␣
○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○
○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○
○ ○ ○ ○ ○ ○ ○␣ ○␣ ○ ○ ○ ○ ○ ○ ○␣ ○␣ ○␣
○␣ ○␣ ○ ○ ○␣ ○ ○␣ ○␣ ○ ○␣ ○␣ ○ ○ ○ ○␣ ○␣ ○␣
○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○␣ ○␣ ○␣
XS-Leak
OS
Detectable Difference: Status Code
Performance API Error
Style Reload Error
Request Merging Error
Event Handler Error
MediaError
Detectable Difference: Redirects
CORS Error Leak
Redirect Start
Duration Redirect
Fetch Redirect
URL Max Length
Max Redirect
History Length
CSP Violation
CSP Redirect
Detectable Difference: API Usage
WebSocket
Payment API
Detectable Difference: Page Content
Performance API Empty Page ○␣ ○␣ ○ ○␣ ○␣ ○ ○␣ ○␣ ○ ○␣ ○␣ ○ ○ ○ ○␣ ○␣ ○␣
Performance XSS Auditor
○␣ ○␣ ○ ○␣ ○␣ ○ ○␣ ○␣ ○ ○␣ ○␣ ○ ○ ○ ○␣ ○␣ ○␣
Cache
○␣ ○␣ ○ ○ ○␣ ○ ○ ○␣ ○ ○ ○␣ ○ ○ ○ ○␣ ○␣ ○␣
Frame Count
○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○
Media Dimensions
○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○
Media Duration
○ ○ ○␣ ○ ○ ○␣ ○ ○ ○␣ ○ ○ ○␣ ○␣ ○␣ ○ ○ ○␣
Id Attribute
○ ○ ○␣ ○ ○ ○␣ ○␣ ○␣ ○␣ ○ ○ ○␣ ○␣ ○␣ ○␣ ○␣ ○␣
CSS Property
○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○
Detectable Difference: Header
SRI Error
Performance API Download
Performance API CORP
COOP Leak
Performance API XFO
CSP Directive
CORP
CORB
ContentDocument XFO
Download Detection
○␣ ○␣ ○ ○␣ ○␣ ○ ○␣ ○␣ ○ ○␣ ○␣ ○ ○ ○ ○␣ ○␣ ○␣
○ ○ ○␣ ○ ○ ○␣ ○ ○ ○␣ ○ ○ ○ ○ ○ ○␣ ○␣ ○␣
○ ○ ○ ○ ○ ○ ○␣ ○␣ ○ ○ ○ ○ ○ ○ ○␣ ○␣ ○␣
○ ○ ○␣ ○␣ ○ ○␣ ○␣ ○␣ ○␣ ○␣ ○ ○␣ ○␣ ○␣ ○␣ ○␣ ○␣
○␣ ○␣ ○ ○ ○␣ ○ ○␣ ○␣ ○ ○ ○␣ ○ ○ ○ ○␣ ○␣ ○␣
○ ○ ○␣ ○ ○ ○␣ ○␣ ○␣ ○␣ ○ ○ ○␣ ○␣ ○␣ ○␣ ○␣ ○␣
○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○
○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○ ○
○ ○ ○␣ ○ ○ ○␣ ○␣ ○␣ ○␣ ○ ○ ○␣ ○␣ ○␣ ○␣ ○␣ ○␣
○ ○ ○␣ ○ ○ ○␣ ○ ○ ○␣ ○ ○ ○ ○ ○ ○ ○ ○
22
10
○ ○ ○␣ ○ ○ ○␣ ○ ○ ○␣ ○ ○ ○␣ ○␣ ○␣ ○ ○ ○
○␣ ○ ○␣ ○␣ ○ ○␣ ○␣ ○␣ ○␣ ○␣ ○ ○␣ ○␣ ○␣ ○␣ ○␣ ○␣
 Attackable (max. 34)
23
22
14
22
24
24
24
11
11
23
22
24
13
23
24
Table 2: Evaluation results overview categorized by its detectable differences. Successful attacks are depicted with full circuits
(○), safe browser are indicated with empty circuits (○␣). The results for Android (cid:240) in comparison with Desktop B Browsers are
almost identical, while iOS  browsers behave differently. Only a few XS-Leaks are susceptible to all browsers. More detailed
evaluation tables found in the Appendix, Tables 3 and 4. The used inclusion methods and leak techniques are listed in Table 1.
Session 6B: Web Vulnerabilities CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1779are generated in a fully automatic fashion; including different op-
erating systems combined with Selenium for browser automation.
Second, the results can be reproduced by other researchers. We
additionally evaluated Tor using XSinator because of its privacy
goals that are directly targeted with XS-Leaks. More browser re-
sults, including a real-time browser evaluation, are available on
XSinator’s website and in the Appendix (Tables 3 and 4).
First, we identified clear differences between each browser fam-
ily, although GC and SA still have certain similarities. On mobile
devices, it is evident how restricted the iOS browser ecosystem is,
while browsers on Android often behave just like their desktop
counterparts. Second, we analyze how vulnerabilities propagate be-
tween different browser versions over time. For this, we compared
the results from XSinator for all popular desktop browsers over the
last year, which gave interesting insights into the adoption of new
features and the effectiveness of security patches.
6.1 Browser Comparison
Blink vs. Webkit. On the Desktop, GC 90, MSE 90, and OP 75,
which are based on Chromium’s Blink engine, behave equal in our
test suite. Moreover, we detected that Blink-based browsers are
vulnerable to the fetch redirect XS-Leak. This vulnerability was
surprising since it was a known bug in SA that was fixed in February
2020 [73]. Blink- and Webkit-based browsers are vulnerable to
multiple Performance API XS-Leaks. Although Google developers
have been addressing theses XS-Leaks (cf. Table 3), it is still possible
to detect new security headers like the CORP header. In contrast,
Webkit-based browsers are still vulnerable to a variety of XS-Leaks
based on the Performance API. XSinator shows the possibility to
detect empty pages and therefore pages that the XSS-Auditor blocks
in Webkit.
Desktop Tor vs. Firefox. Two of the main targets of Tor are to
defend surveillance and resist fingerprinting. To verify its resilience
to XS-Leaks, we used XSinator to evaluate the behavior of Tor in the
default and safer mode. We compared Tor browser (based on FF78)
with FF due to the same underlying browser engine called Gecko.
Tor has more restrictive browser settings; some APIs are not acti-
vated because they are explicitly deactivated using Tor browser’s
configuration flags. Despite this hardening, our evaluation shows
that a subset of FF XS-Leaks still works. Regarding XS-Leak attacks,
Tor’s secure mode is more restrictive than the default mode; for
example, attackers cannot automatically fingerprint sound and im-
age files due to an activated click-to-play functionality. However,
eleven XS-Leaks like the WebSocket XS-Leak still work in Tor’s
secure mode. While FF is already quite resistant against XS-Leaks
based on the Performance API leak technique, our tests show that
the Performance API is completely disabled in Tor. This restric-
tion drastically limits the attack surface, even for undiscovered
XS-Leaks.