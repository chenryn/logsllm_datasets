Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 05:35:32 UTC from IEEE Xplore.  Restrictions apply. 
tions and matching the extracted specification to theoriginal specification. The final refactored AES pro-gram contained 25 functions and was 506 lines long.6.2.2. Complexity Metrics Analysis. Using the heu-ristics mentioned earlier, we selected and orderedtransformations to use with AES. Rather than examin-ing the effects of each transformation separately, wegrouped the transformations into the following 14blocks: (1) loop rerolling for major loops in the encryp-tion and decryption functions; (2) reversal of wordpacking to use four-byte arrays; (3) reversal of tablelookups; (4) packing four words into a state; (5) rever-sal of the inlining of the major encryption and decryp-tion functions; (6) reversal of the inlining of the keyexpansion functions; (7) moving statements into condi-tionals to reveal three distinct execution paths followedby procedure splitting; (8) adjustment of loop forms;(9) reversal of additional inlined functions; (10) looprerolling for sequential state updates; (11) proceduresplitting; (12) adjustment of intermediate variables;(13) adjustment of loop forms; and (14) additional pro-cedure splitting.Blocks 7-11 were for the subprogram that set upthe key schedule for encryption, and blocks 12-14 werefor the subprogram that modified the key schedule fordecryption. As well as the main transformations, eachblock of transformations involved smaller transforma-tions that modified redundant or intermediate computa-tions and storage.As part of determining whether further refactoringwas required, we periodically attempted the proofs anddetermined the source-code metrics. Some of theresults of the effect of applying the transformations onthe values of the metrics are shown in Figure 2. Thehistograms show the values of different metrics afterthe application of the 14 blocks of transformationswhere block 0 is the original code. As the transformations were applied, the primaryelement metric, code size, dropped from over 1365 to412. The average McCabe cyclomatic complexity alsodeclined, dropping from 2.4 to 1.48. Statement com-plexity, essential complexity, etc. also declined. Thereis no evidence that these complexity metrics are relatedto verification difficulty, but their reduction suggeststhat the refactored program might generate less ver-bose VCs and be easier to analyse.Since we would not undertake full annotation untilrefactoring was complete, we had no way to assess thefeasibility of the proofs. To gain some insight, we setthe postconditions for all subprograms to true for eachversion of the refactored code, generated verificationconditions (VCs) using the SPARK examiner, and sim-plified the generated VCs using the SPARK simplifier.We measured the number of VCs, the size of VCs, themaximum length of VCs, and the time that the SPARKtools took to analyze the code. These data did not nec-essarily represent the actual proof effort needed for theimplementation proof, but they were an indication.The times required for analysis with the SPARKtools after the various refactorings are shown as Figure2(c). Some blocks are shown with no value because theVCs were too complicated to be handled by theSPARK tools. After the first loop rerolling at block 1,the tools completed the analysis but took 7 hours and23 minutes on a 2.0 GHz machine. At block 2 withword packing reversed, the analysis again becameinfeasible. Analysis by the SPARK tools became feasi-ble again by block 8 after we had adjusted the loopforms. The required analysis reached 1 minute 42 sec-onds for the final refactored program.Figure. 2. Metric analysis with AES verification refactorings(a) Lines of code020040060080010001200140001234567891011121314(b) Average McCabe cyclomatic complexity00.511.522.5301234567891011121314(c) SPARK analysis time0:00:000:01:000:02:000:03:000:04:000:05:000:06:000:07:00012345678910111213147:23:55(d) Size of generated VCs01234560123456789101112131451.16 MBMB(e) Size of simplified VCs00.050.10.150.2012345678910111213142.59 MBMB(f) Specification structure match ratio0%20%40%60%80%100%01234567891011121314978-1-4244-4421-2/09/$25.00 c(cid:13)2009 IEEE
60
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 05:35:32 UTC from IEEE Xplore.  Restrictions apply. 
In block 1, 51.16 MB VCs were generated and2.59 MB were left after simplification. For the finalrefactored code, 1.90 MB VCs were generated and 86KB were left after simplification (Figs 2(d) and 2(e)).The simplified VCs were those that needed humanintervention to prove. After block 1, the maximum VClength was over 10,000 lines. In the final refactoredcode, the maximum was 68 lines. When the implemen-tation annotation was complete, the maximum lengthof VCs needing human intervention was 126 lines.We extracted a skeleton specification from thecode after applying each block of transformations.These specifications were skeletons because they wereobtained before the code had been annotated. We com-pared the structure of the skeleton extracted specifica-tion with that of the original specification by visuallyinspection and evaluated a match-ratio metric. This isdefined as the percentage of key structural elements—data types, operators, functions and tables—in the orig-inal specification that had direct counterparts in theextracted specification. We hypothesize that this mea-sure is an indication of the likelihood of successfullyestablishing the implication proof.The values of the match ratio are shown in Figure2(f). The ratio increased gradually from 25.9% to96.3% as the transformation blocks were applied.There is only a small increase in its value after theblock 8 transformations were applied, and the implica-tion proof could have been attempted at that point.However, since the time required for the SPARK anal-ysis was still declining, we chose to continue refactor-ing until all metrics stabilized.6.2.3. Implementation Proof. After refactoring, thecode was examined and annotated manually. Theactual numbers of annotations are shown in Table 1:The implementation proof was carried out usingthe SPARK Ada toolset. A total of 306 VCs were gen-erated, of which 86.6% were discharged automaticallyin 145 seconds on a 2.0 GHz machine. 15 out of 25functions had all VCs discharged automatically. Theremaining VCs required quite straightforward manualintervention, usually involving either the application ofpreconditions or induction on loop invariants. Theinteractive proof process for each remaining VC wasfinished within a few minutes by a single individualwho has a good level of SPARK Ada experience.Throughout the proof process, the length of theVCs remained completely manageable. No difficultieswere encountered in reading or understanding them, orin manipulation of them with the SPARK tools.6.2.4. Implication Proof. The extracted specification(in PVS) produced by the Echo specification extractiontool was 1685 lines long. It was much larger than theoriginal specification because the implementation con-tained tables for multiplication in the GF(28) fieldwhich were not present in the original specification.When typechecking the extracted specification,the PVS theorem prover generated 147 Type Correct-ness Conditions (TCCs), of which 79 were dischargedautomatically by the theorem prover in 23.5 seconds ona dual 1.0 GHz machine and the remaining 68 were allsubsumed by the proved ones.As a result of verification refactoring, the architec-ture of the extracted specification was sufficiently sim-ilar to the architecture of the original specification thatwe were able to identify the matching elements easily.To prove the extracted specification implied the origi-nal one, we created an implication theorem using ageneral process that is part of Echo[17].There were 32 major lemmas in the implicationtheorem. Type checking of the implication theoremresulted in 54 TCCs, 29 of which were dischargedautomatically in 4.2 seconds on a dual 1.0 GHzmachine and 25 were subsumed by the proved ones.In most cases, the PVS theorem prover could notprove the lemmas completely automatically. However,the human guidance required was short and straightfor-ward, typically including expansion of function defini-tions, introduction of predicates over types, orapplication of extensionality. In some cases, introduc-ing other previously proved supporting lemmas andstructuring the proof as cases were required. Each lem-mas was established and proved interactively in a fewminutes (thus the implication theorem discharged). 7.Refactoring and Defect DetectionWhen using formal verification, defects in the sub-ject programs are revealed by a failure to complete theproof. Proof failures always present the dilemma thateither the program or the proof could be wrong. Thisdilemma is present with any method, including testing.Verification refactoring might make the dilemmaworse or introduce other forms of difficulty in identify-ing defects. In order to investigate this issue, we seededdefects into the original AES implementation and thenTable 1: Annotations in implementation proofTypeLinesPreconditions8Postconditions123Loop Invariants & Assertions54Proof Functions, Proof Rules, & Other32978-1-4244-4421-2/09/$25.00 c(cid:13)2009 IEEE
61
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 05:35:32 UTC from IEEE Xplore.  Restrictions apply. 
determined the effect of each defect on verification. Wepresent the results of that experiment in this section.7.1.The Seeding ProcessThe seeding process was done by randomly choos-ing a line number and performing a change in the code.Each defect in the program was a change in either: (a) anumeric value; (b) an array index; (c) an operator (forcomputation or predicate); (d) a variable or table refer-ence; or (e) a statement or function call.These types of defect are not equivalent to thoseintroduced by programmers. However, they do reflectcommon errors that might be introduced, and there issome evidence that simple seeded defects share impor-tant properties with actual defects[9].Code and therefore the defects are closely tied intothe annotations that document the low-level specifica-tion. The defective code could be annotated so as toeither describe its desired behavior rather than itsactual behavior, or vice versa. We used both scenariosin this experiment and evaluated them separately.7.2.Defect LocationThere are three stages in the proof process thatcould expose defects in the code:Verification refactoring. A defect could change thecode such that it did not match a particular transforma-tion template and the transformation could not beapplied. For example, a defect in only one iteration ofan unrolled loop rather than in all interactions wouldmake loop rerolling inapplicable.Implementation proof. Any inconsistency betweenthe code and the annotations would be detected by theSPARK Ada tools. An inconsistency could arisebecause of a defect in either or both.Implication proof. Defects in the code but with con-sistent annotations, or postcondition annotations thatare not strong enough, would cause the implication the-orems to be unprovable and so would be detected bythe implication proof.7.3.Experimental ResultsWe seeded 15 defects, three defects of each basictype, one at a time into the AES implementation, andthen we ran the Echo verification process twice foreach defect. In the first (setup 1), we assumed that thedefects were caused by misunderstandings of the speci-fication when implementing the code, and the annota-tions corresponded to the functional behavior of thecode. In the second (setup 2), we assumed that thedefects were introduced by implementation errors, andthe annotations corresponded to the high-level specifi-cation. The results are shown in tables 2 and 3.For setup 1, most defects were caught during theimplication proof since the annotation matched thecode. The two defects that were caught in the imple-mentation proof were found during the proof of excep-tion freedom because they caused possible out-of-bound array references. The remaining defect that wasnot caught at any stage was benign. We discuss it later.For setup 2, most defects were caught during theimplementation proof since the annotation did notmatch defective code. The remaining defect was thesame benign defect.In both setups, verification caught the same 14seeded defects. The remaining (benign) defect changedan array of keys. The length of the array had been set toaccommodate the maximum number of rounds in thecase of a 256-bit key length. However for key lengthsof 128 bits or 192 bits, the last several entries in thearray were not used in the computation. This waspurely an implementation decision, and the specifica-tion did not impose any restrictions. Thus, for shorterkey lengths these entries could be allowed to have arbi-trary values without affecting functional correctness.Echo does require that the developer annotate thecode, and, whenever there is an unprovable proof obli-gation, the user has to determine whether it is the resultof a defect in the code or the annotations. However, theuse of architectural and direct mapping in the creationof the extracted specification means that the location ofdefects can be restricted to the function that cannot beproved. In the AES case, each function is quite smalland manageable after verification refactoring, makingdefect location quite simple.Table 2: Defect detection for setup 1Verification StageDefects CaughtDefects LeftInitial state15Verification refactoring411Implementation proof in SPARK29Implication proof in PVS81Table 3: Defect detection for setup 2Verification StageDefects CaughtDefects LeftInitial state15Verification refactoring411Implementation proof in SPARK101Implication proof in PVS01978-1-4244-4421-2/09/$25.00 c(cid:13)2009 IEEE
62
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 05:35:32 UTC from IEEE Xplore.  Restrictions apply. 
8.Related WorkRetrieval of abstract specifications from sourcecode through formal transformations has been reportedin the reverse-engineering domain[5, 16]. The goal isto improve the structure of poorly-engineered code andto facilitate further analyses.Paul et al.[13] are developing an approach to thedetermination of how refactorings affect the verifiabil-ity of a program. Their focus is object-oriented design,and the goal is to see whether a syntactic change canmake more properties amenable to analysis.Smith et al.[15] have developed an infrastructurefor verifying properties of block ciphers, includingAES, and they have verified AES implementations inJava byte code. They noted different representationsbetween the specification and the implementation, andprovided transformation functions between the two. Kuehlmann1 et al.[10] have developed anapproach called transformation-based verification forsequential verification of circuit-based designs. Theapproach uses structural transformation that relocatesregisters in a circuit-based design representation with-out changing its actual input-output behavior, toincrease the capacity of symbolic state traversal. Verifi-cation refactoring adopts similar idea to transform thetarget being verified, but for software.9.ConclusionRefactoring deals with many of the issues thatlimit the applicability of formal verification includingunworkably large verification conditions and the rigiddevelopment process necessary for refinement.We have demonstrated the efficacy and utility ofrefactoring by verifying a moderate-sized programwritten by others and not designed for verification. Therefactoring process was guided by a set of complexitymetrics that helped both select transformations anddetermine when the program was likely to be amenableto proof. Off-the-shelf verification was impossibleusing conventional tools, but the addition of refactor-ing made the task both feasible and straightforward. Inan experiment using seeded defects, we have also dem-onstrated that locating defects in software for whichverification is being attempted is fairly straightforward,even when verification refactoring is being applied.10.AcknowledgementsWork funded in part by NASA grants NAG-1-02103 & NAG-1-2290, and NSF grant CCR-0205447.11.References[1]Abrial, J.R., The B-Book: Assigning Programs to Mean-ings, Cambridge University Press, 1996.[2]Adacore, GNAT Metric Tool, http://www.adacore.com[3]Barnes, J., High Integrity Software: The SPARKApproach to Safety and Security, Addison-Wesley, 2003.[4]Bravenboer, M., K.T. Kalleberg, R. Vermaas, and E.Visser, “Stratego/XT 0.16. A Language and Toolset for Pro-gram Transformation”, Science of Comp. Progr., 2007.[5]Chung, B. and G.C. Gannod, “Abstraction of FormalSpecifications from Program Code”, IEEE 3rd Int. Confer-ence on Tools for Artificial Intelligence, 1991, pp. 125-128.[6]Croxford, M., and R. Chapman, “Correctness by con-struction: A manifesto for high-integrity software”,CrossTalk, The Journal of Defense Soft. Engr, 2005, pp. 5-8.[7]Daemen, J. and V. Rijmen, “AES Proposal: Rijndael.AES Algorithm Submission”, 1999.[8]FIPS PUB 197, “Advanced Encryption Standard”,National Institute of Standards and Technology, 2001.[9]Knight J.C., and P.E. Ammann, “An Experimental Eval-uation of Simple Methods For Seeding Program Errors”,ICSE-8: Eighth Int. Conf. on Soft. Engr, London, UK, 1985.[10]Kuehlmann, A., and J. Baumgartner, “Transformation-based verification using generalized retiming”, ComputerAided Verification, Paris, France, 2001, pp. 104-117.[11]Liskov, B. and J. Wing, “A Behavioral Notion of Sub-typing”, ACM Transactions on Programming Languages andSystems, 16(6):1811--1841, 1994.[12]Owre, S., N. Shankar, and J. Rushby, “PVS: A PrototypeVerification System”, CADE 11, Saratoga Springs, NY, 1992.[13]Paul, J., N. Kuzmina, R. Gamboa, and J. Caldwell,“Toward a Formal Evaluation of Refactorings”, Proc. of TheSixth NASA Langley Formal Methods Workshop, 2008.[14]Strunk, E.A., X. Yin, and J.C. Knight, “Echo: A Practi-cal Approach to Formal Verification”, FMICS05, Lisbon,Portugal, 2005.[15]Smith, E., and D. Dill, “Formal Verification of BlockCiphers, A Case Study: The Advanced Encryption Standard(AES)”, Stanford University.[16]Ward, M., “Reverse Engineering through Formal Trans-formation”, The Computer Journal, 37(9):795-813, 1994.[17]Yin, X., J.C. Knight, E.A. Nguyen, and W. Weimer,“Formal Verification By Reverse Synthesis”, the 27th SAFE-COMP, Newcastle, UK, September 2008.