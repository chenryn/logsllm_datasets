0x0000
they steal a way innocence and peace
tho i'm  a king i'm a king on my knees
and i know they are wrong when they say i 
am strong
as the darkness covers me
j knapp
remedial heap overflows
dlmalloc style buffer overflows
by atlas
PI:EMAIL
http://atlas.r4780y.com
0x0100 - Intro to Buffer Overflows
● gets() / fgets())
– Man Page Notes:  “Never use gets(). Because it is 
impossible to tell without knowing the data in advance 
how many characters gets() will read, and because 
gets() will continue to store characters past the end of 
the buffer, it is extremely dangerous to use. It has been 
used to break computer security. Use fgets() instead.“
● str(n)cpy()  /  memcpy()
● rep movs (opcode)
● s/f/scanf()
0x0200 - The Heap
● Dynamically allocated storage
● Created using some sort of allocator - eg. malloc()
● Cleaned up using a deallocator – eg. free()
● Stack overflows are typically a matter of 
writing enough bytes to change RET
● Heap options are slightly different:
● Overwrite another variable on the heap
● EOS (NULL) Overwrite (var combination)
● Overwrite the Heap descriptors
– delicate
– implementation-specific
– totally cool
0x0201-Kernel Chunk/Malloc Buffer
● The Operating System assigns a raw 
chunk of memory to a process, for 
dynamic allocation.  
– This is typically referred to as a Chunk
● The user-space management of this 
memory is up to the implementor.  
● Each OS has a default, but you can write your own
● For this preso, I will use “chunk” and 
“buffer” both to refer to a malloc()ed 
memory buffer
0x0202 – buf = malloc(1024)
● This call allocates at least 1024 bytes 
from the kernel-provided memory-space.
● The virtual memory address where this 
buffer starts is stored in “buf”
● Because malloc() is low-level and called 
so frequently, the algorithms cannot do 
much processing, like sanity checking. 
● For dlmalloc, *(buf-4)  accesses the length 
of the buffer
0x0203 - free(buf)
● This call takes a previously malloc()ed 
buffer and marks it available for use by 
another call to malloc()
● Often, this memory chunk is inserted into 
a linked-list or array of “recycled” buffers 
for speedy reuse
● Because free() is low-level and called so 
frequently, the algorithms cannot do 
much processing, like sanity checking.
0x0204 - Example: Microsoft GDI
● JPEG  buffer overflow
● September 2004
● GDIscan 
– (major props  to Tom Liston from Intelguardians)
0x0300 - Varietous Implementations
– Doug Lea's Malloc / Free (our focus)
● Linux default
– RTL and the Windows Heap
– BSD phk
● BSDi, FreeBSD, OpenBSD
– BSD kingsley
● 4.4BDS, AIX (compat), Ultrix
– System V AT&T 
● Solaris, IRIX
– Yorktown
● AIX (default)
0x0301 - Doug Lea's Malloc (linux)
● Allocated chunks are preceded by a size 
● Recycled chunks - basic doubly-linked list
● malloc() adds 4 bytes to the requested 
length, then pads to the next quadword 
(8-byte) boundary
● malloc(101) - allocates 112 bytes (0x70)
● sets aside 105 bytes  (101+4)
● pads to next 8-byte multiple, which is 112
0x0302 - RTL and Win32 Heap
● For grins and to make lin0xx happy...
● RtlAllocateHeap() / RtlFreeHeap()
● Free()d chunks are maintained in an array 
of 127 doubly-linked lists
– lists 2-127 store 16-1024 byte chunks
● ie. 
– for list 2, chunk size is 2*8 = 16bytes
– for list 100, chunk size is 2*100 = 200bytes
– list 0 stores >1024 byte chunks
0x0400 - Heap Descriptor
● Inband Allocation Descriptor
– Duh!  Was this architected for exploitation?
● If a heap chunk is in use, the allocation 
descriptor is one 32-bit integer 
immediately preceding the chunk
● If a heap chunk is not in use, the first 8 
bytes and the last 4 bytes of the data are 
also used as 32-bit integers.  Remember 
this...
0x0401 - Allocation Descriptor (used)
● malloc(101)
struct heapchunk {
long len
char[101]
char[padsize]
}
– Note: if the heapchunk is unused, it stays in 
memory (hoping to be recycled and further 
contribute to the environment).  
0x0402 - Allocation Descriptor (free()-d)
● malloc(101)
struct heapchunk {
long len   (this is |PREV_INUSE)
long prev  next->prev = node->prev
– node->prev->next = node->next
● hmmmm...  prev and next for the next 
buffer come from the inband descriptor... 
which we just overwrote...
● Devil is in the details...  pay close 
attention
0x0501 – ok.  I'm lost.
● In-use memory buffer (adapted from “Once upon a free()”)
             +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
    chunk ­> | prev_size (32bit long)  *        |
             +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
             | size | PREV_INUSE (32bit long) **|
             +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
      mem ­> | data                             |
             : ...                              :
             +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
nextchunk ­> | prev_size (32bit long)           |
             :      ...                         :
* If prev buffer is used, prev_size is just part of the 
buffer.  If not, it is the length of the previous chunk.  
** The least­significant­bit indicates whether the previous 
chunk is in use.  If the number is odd, PREV_INUSE is set
0x0502 – Still lost...
● Unused memory buffer (also adapted)
             +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
    chunk ­> | prev_size (32bit long) *         |
             +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
             | size | PREV_INUSE (32bit long)** |
             +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
      mem ­> | fd                               |
             +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
             | bk                               |
             +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
             | (old memory, can be zero bytes)  |
nextchunk ­> | prev_size ...                    |
             :                                  :
* If prev buffer is used, prev_size is just part of the 
buffer.  If not, it is the length of the previous chunk.
** The least­significant­bit indicates whether the previous 
chunk is in use.  If the number is odd, PREV_INUSE is set
0x0503 – Got a map...
● fd and bk are used to write to memory 
when unlink() is called to collapse two 
chunks together.  Basically:
*(fd+12) = bk
*(bk+8) = fw
● This happens when collapsing “forward”
● This happens when collapsing “backward”
0x0504 – Got two hands...
● bk = 0x80496c4 
● Imagine this is the GOT entry for “free()”
● fw = 0x804a0e8
● imagine this is the location of another buffer we 
control
● mem=
”\xb8\x96\x04\x08” + “\xe8\xa0\x04\x08” 
+ "D"*92 + “\xfc\xff\xff\xff" + ”PAD0” + 
“\xfc\xff\xff\xff" + 
”\xb8\x96\x04\x08” + “\xe8\xa0\x04\x08” 
0x0505 – Flashlight Anyone?
● We are basically setting the following 
chunk to be “unused”, and setting both 
up for collapse, which works the magic
● This approach allows for both forward 
collapsing and reverse collapsing...  
– If our chunk is free()-d, we're good
– If the following chunk is free()-d, we're good
● The end result is our 32bit integer being 
placed virtually anyplace we like.
● GOT is writeable, so why not?
0x0506 - Gotchas...
● There are a couple gotchas with 
exploiting unlink()...
– shellcode + 8 is clobbered.  Can't help it.
– I put “\xeb\x0eAA” + “AAAA” + ”AAAA” + 
”AAAA” to start off shellcode.
● 0xeb is the 'jmp byte-offset' opcode