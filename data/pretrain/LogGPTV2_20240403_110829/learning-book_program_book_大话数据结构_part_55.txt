作为例子，而这个算法一般就是冒泡排序。并不是它的名称很好听，面是说这个算法
的思路最简单，最容易理解。因此，哪怕大家可能都已经学过冒泡排序了，我们还是
从这个算法开始我们的排序之旅。
378
---
## Page 403
第9章排序
图 9-3-1
9.3.1最简单排序实现
冒泡排序（BubbleSort）一种交换排序，它的基本思想是：两两比较相邻记录的
关键字，如果反序则交换，直到没有反序的记录为止。冒泡的实现在细节上可以有很
多种变化，我们将分别就3种不同的冒泡实现代码，来讲解冒泡排序的思想。这里，
我们就先来看看比较容易理解的一段。
/对顺序表L作交换排序（冒池换序初级版）·/
void BubbleSorto(SqList*L)
inti,3;
for（i=1/ilength;i++）
for(j=i+l;jlength:j++)
if（L->r[i]>L->r[3]）
swap（L,i,3）；/交换L->r[i]与L->r[5]的值*/
379
---
## Page 404
大据数据结构
这段代码严格意义上说，不算是标准的冒泡排序算法，因为它不满足“两两比较
相邻记录”的冒泡排序思想，它更应该是最最简单的交换排序而已。它的思路就是让
每一个关键字，都和它后面的每一个关键字比较，如果大则交换，这样第一位置的关
键字在一次循环后一定变成最小值。如图9-3-2所示，假设我们待排序的关键字序列
是{9,1,5,8,3.7,4,6,2}，当1=1时，9与1交换后，在第一位置的1与后面的关键字比较
都小，因此它就是最小值。当i=2时，第二位置先后由9换成5，换成3，换成2，完
成了第二小的数字交换。后面的数字变换类似，不再介绍。
下标
口
口
口
9
2
35
9
9
9
8
8
8
8
8
8
3
3
3
3
，
5
5
7
7
7
7
7
7
7
4
4
4
4
4
4
6
6
6
6
6
6
2
2
2
2
3
当i=1时，9与1交换后，1与
当i=2时，9与5，5与3，3与2交换，
其余关键字比较均最小，因
最终将2放置在第二位
此1即最小值放置在首位
图9-3-2
它应该算是最最容易写出的排序代码了，不过这个简单易懂的代码，却是有缺陷
的。观察后发现，在排序好1和2的位置后，对其余关键字的排序没有什么帮助（数
字3反而还被换到了最后一位）。也就是说，这个算法的效率是非常低的。
9.3.2冒泡排序算法
我们来看看正宗的冒泡算法，有没有什么改进的地方。
对顺序表L作冒池排序/
（7.b）eqqg P
inti,j;
for（i=1;ilength;i++)
380
---
## Page 405
第9章排序
for（j=L->length-1;j>=i;j--）/·注意}是从后往前德环*/
if（L->r[j]>L->r[j+1]）/*若前者大于后者（注意这里与上一算法差异）*/
1
swap（L，j，j+1）;/·交换L->r[5]与L->r[j+1]的值
依然假设我们待排序的关键字序列是{9,1,5.8,3,7，4,6.2），当i=1时，变量1由8反
向循环到1，逐个比较，将较小值交换到前面，直到最后找到最小值放置在了第1的
位置。如图9-3-3所示，当i=1、j=8时，我们发现6>2，因此交换了它们的位置，j=7
时，4>2，所以交换·…直到j=2时，因为11，交换，
最终得到最小值1放置第一的位置。事实上，在不断循环的过程中，除了将关键字1
放到第一的位置，我们还将关键字2从第九位置提到了第三的位置，显然这一算法比
前面的要有进步，在上十万条数据的排序过程中，这种差异会体现出来。图中较小的
数字如同气泡般慢慢浮到上面，因此就将此算法命名为冒泡算法。
下标
口
2
1
1
9
5
5
5
8
8
8
8
2
5
3
3
3
3
2
8
8
8
7
7
7
2
3
3
3
3
4
4
2
7
1
7
7
6
2
4
4
4
2
6
6
6
6
6
6
当i-1时将最小值1泡到顶端
图 9-3-3
当i=2时，变量）由8反向循环到2，逐个比较，在将关键字2交换到第二位置
的同时，也将关键字4和3有所提升。
381
---
## Page 406
大语数据结构
下标
1
口
∞
n∞m
∞
1
1
2
3
，
9
6
6
6
6
当i-2时将次小值2冒泡到第二位置
图9-3-4
后面的数字变换很简单，这里就不在详述了。
9.3.3冒泡排序优化
这样的冒泡程序是否还可以优化呢？答案是肯定的。试想一下，如果我们待排序
的序列是{2.1,3,4,5,6,7,8,9），也就是说，除了第一和第二的关键字需要交换外，别的都
已经是正常的顺序。当i=1时，交换了2和1，此时序列已经有序，但是算法仍然不
依不饶地将i=2到9以及每个循环中的1循环都执行了一遍，尽管并没有交换数据，
但是之后的大量比较还是大大地多余了，如图9-3-5所示。
下标
2
口
1
2
[
3
X
3
4
4
6
6
7
8
8
8
length66flag:i++）/*若flag为true则选出循环/
flag-FALSE;
/初始为false*/
for(j=L->length-1;j>=i;j--)
if（L->r[j1>L->r[j+1])
swap（L,3,j+1）；/·交换L->r[3]与L->r[j+1]的值/
flag=TRUE;
/如果有数据交换，则flag为tzue*/
代码改动的关键就是在i变量的for循环中，增加了对fag是否为true的判断。
经过这样的改进，冒泡排序在性能上就有了一些提升，可以避免因已经有序的情况下
的无意义循环判断。
9.3.4冒泡排序复杂度分析
分析一下它的时间复杂度。当最好的情况，也就是要排序的表本身就是有序的，
那么我们比较次数，根据最后改进的代码，可以推断出就是n一1次的比较，没有数
据交换，时间复杂度为0（n）。当最坏的情况，即待排序表是逆序的情况，此时需要比
次，并作等数量级的记录移动。因此，
2
2
总的时间复杂度为0（n²]。
383
---
## Page 408
大语数据结构
9.4简单选择排序
爱炒股票短线的人，总是喜欢不断的买进卖出，想通过价差来实现盈利。但通常
这种频繁操作的人，即使失误不多，也会因为操作的手续费和印花税过高而获利很
少。还有一种做股票的人，他们很少出手，只是在不断的观察和判断，等到时机一
到，果断买进或卖出。他们因为冷静和沉着，以及交易的次数少，而最终收益颇丰。