## Page 170
156
剑指Offer-
个组合。比如ab 和 ba 是不同的排列，但只算一个组合。
当交换字符串中的两个字符时，虽然能得到两个不同的排列，但却是同一
还是输入三个字符a、b、c，则它们的组合有a、b、c、ab、ac、bc、abc。
的字符串递归地做排列操作，直至 pBegin指向字符串的末尾。
向的字符）。在交换 pBegin 和 pCh 指向的字符之后，我们再对pBegin 后面
在每一次递归的时候，我们从 pBegin 向后扫描每一个字符（即指针 pCh 指
串的第一个字符，pBegin 指向当前我们做排列操作的字符串的第一个字符。
如果不是求字符的所有排列，而是求字符的所有组合，应该怎么办呢？
本题完整的源代码详见 28_StringPermutation项目。
在函数Permutation(char*pStr,char*pBegin)中，指针pStr指向整个字符
本题扩展：
本题考点：
测试用例：
考查思维能力。当整个问题看起来不能直接解决的时候，应聘者
考查对递归的理解和编程能力。
能否想到把字符串分成两部分，从而把大问题分解成小问题来解
特殊输入测试（输入的字符串的内容为空或者是NULL指针)。
功能测试（输入的字符串中有1个或者多个字符）。
一名企面试官精讲典型编程题（纪念版）
决，是能否顺利解决这个问题的关键。
temp =*pCh;
Permutation (pStr, pBegin + 1);
*pBegin=
*pBegin=temp;
temp;
---
## Page 171
符合条件的摆法？
格子表示一个皇后，这就是一种符合条件的摆放方法。请问总共有多少种
个皇后不得处在同一行、同一列或者同一对角线上。图4.16中的每个黑色
a1+a3+a5+a7=a2+a4+a6+a8，并且a1+a2+a5+a6—a3+a4+a7+a8。
后判断有没有某一个的排列符合题目给定的条件，即al+a2+a3+a4—a5+a6+a7+a8，
图4.15把8个数字放到正方体的8个顶点上
的4个顶点的和都相等。
放到正方体的8个顶点上（如图4.15所示），使得正方体上三组相对的面上
个字符的长度为m的组合。这两个子问题都可以用递归的方式解决。
分解成两个子问题，分别求n-1个字符串中长度为m-1的组合，以及求n-1
m个字符。也就是说，我们可以把求n个字符组成长度为m的组合的问题
符；如果组合里不包含第一个字符，则下一步在剩余的 n-1个字符里选取
符。如果组合里包含第一个字符，则下一步在剩余的字符里选取m-1个字
组合的时候，我们把这n个字符分成两部分：第一个字符和其余的所有字
的组合、……、长度为n的组合。在求n个字符的长度为m（1≤m≤n）的
这相当于先得到al、a2、a3、a4、a5、a6、a7和a8这8个数字的所有排列，然
1．输入一个含有8个数字的数组，判断有没有可能把这8个数字分别
2.在8×8的国际象棋上摆放8个皇后，使其不能相互攻击，即任意两
如果输入 n 个字符，则这 n 个字符能构成长度为1 的组合、长度为 2
a5
a
相关题目：
8
9
第4章解决面试题的思路157
---
## Page 172
158
剑指Offer-—
够帮助我们解决复杂的问题（如图4.17所示)。
本章小结
字的所有排列，然后再一一判断每个排列是不是满足题目给定的要求。
i-j—ColumnIndex[i]-ColumnIndex[j]或者 j-iColumnIndex[ij]-ColumnIndex[j]。
同一对角线上，也就是对于数组的两个下标i和j，是不是
以任意两个皇后肯定不同列。我们只需判断每一个排列对应的8个皇后是不是在
来就是对数组ColumnIndex做全排列。因为我们是用不同的数字初始化数组，所
i行的皇后的列号。先把数组ColumnIndex的8个数字分别用0~7初始化，接下
行。于是我们可以定义一个数组ColumnIndex[8]，数组中第i个数字表示位于第
一行、同一列或者同一对角线上
图4.168×8的国际象棋棋盘上摆着8个皇后（黑色小方格），任意两个皇后不在同
面试的时候我们难免会遇到难题，画图、举例子和分解这三种办法能
如果面试题是按照一定要求摆放若干个数字，我们可以先求出这些数
由于8个皇后的任意两个不能处在同一行，那么肯定是每一个皇后占据一
-名企面试官精讲典型编程题（纪念版）
---
## Page 173
思路。
归地解决这些小问题。分治法、动态规划等方法都是应用分解复杂问题的
如果我们遇到的问题很大，可以尝试先把大问题分解成小问题，然后再递
模拟运行的过程，说不定就能发现其中的规律，从而找到解决问题的窍门。
未必一眼就能看出它们的规律。这个时候我们不妨举几个例子，
时，
图4.17解决复杂问题的三种方法：画图、举例子和分解。
把复杂问题分解成若干个小问题，是解决很多复杂问题的有效方法。
，如果在纸上画几张草图，题目中隐藏的规律就有可能变得很直观。
图形能使抽象的问题形象化。当面试题涉及链表、二叉树等数据结构
举例子
一两个例子能使抽象的问题具体化。很多与算法相关的问题都很抽象
画图
分解
第4章解决面试题的思路159
一步一步
---
## Page 174
的问题，这能够体现一个应聘者较好的编程素质和能力。”
面试官谈效率
“通常针对一些 senior dev 的 candidates 会问一些关于时间、空间效率
优化时间和空间效率
“面试时一般会直接要求空间和时间复杂度，
-刘景勇（Autodesk，软件工程师）
-张珺（百度，高级软件工程师）
，这两者都很重要。
第5章
---
## Page 175
因为存储空间太少了。”
许这么做。但对于现在的一般嵌入式设备，很多时候空间换时间就不现实了，
一般是空间换时间，因为通常用户更关心速度，而且一般有足够的存储空间允
复杂度对算法的要求更高。”
者限定，然后让他给出解决方案。”
“空间换时间还是时间换空间，这要看具体的题目了。对于普通的应用，
“只要不是特别大的内存开销，时间复杂度比较重要。因为改进时间
“我们有很多考查时间、空间效率这方面的问题。通常两者都给应聘
一吴斌（NVidia，GraphicsArchitect）
第5章
-张晓禹（百度，技术经理）
优化时间和空间效率161
-陈黎明（微软，SDEII）
---
## Page 176
剑指Offer—名企面试官精讲典型编程题（纪念版）
法很有可能不是最优的，但也不妨在第一时间告诉面试官，这样面试官至
听到题目的时候，我们一般很快就能想到最直观的算法。这个最直观的办
需要的时候选择合适的数据结构和算法来解决问题。
O(1)时间就能完成。我们只有对常见的数据结构和算法都了然于胸，才能在
的数组则只需要O(logn)的时间；如果事先已经构造好了哈希表，那查找在
程度。同样是查找，如果是顺序查找需要O(n)的时间；如果输入的是排序
分动态规划算法的分析和代码实现都是分这两个步骤完成的。
可以用数组（一维或者多维数组）来保存中间结果基于循环实现。绝大部
于这种类型的题目，我们可以用递归的思路来分析问题，但写代码的时候
码显得很简洁，但时间效率可能会非常差（详细讨论见本书2.4.2节）。对
单的问题。如果小问题中有相互重叠的部分，那么直接用递归实现虽然代
大不一样。递归的本质是把一个大的复杂问题分解成两个或者多个小的简
节，没有养成好的编码习惯，那么我们的代码可能就会让面试官大失所望。
方法来完成字符串的拼接。如果我们平时不太注意这些影响代码效率的细
时实例，造成时间和空间的浪费。更好的办法是用 StringBuilder 的Append
要多次用 String 的+运算符来拼接字符串，因为这样会产生很多 String 的临
我们应该尽量避免。再举个例子，如果用C#做多次字符串的拼接操作，不
递的方式，从形参到实参会产生一次复制操作。这样的复制是多余的操作，
序员要养成采用引用（或指针）传递复杂类型参数的习惯。如果采用值传
优化效率、
重点。面试官除了考查应聘者的编程能力之外，还关注应聘者有没有不断
也就不难理解为什么很多公司的面试官都把代码的时间效率当做一个考查
视软件的时间性能，都会在发布软件之前花不少精力做时间效率优化。这
时间效率
最后，应聘者在面试的时候要展示敏捷的思维能力和追求完美的激情
再次，代码的时间效率还能体现应聘者对数据结构和算法功底的掌握
其次，即使同一个算法用循环和递归两种思路实现的时间效率可能会
首先，我们的编程习惯对代码的时间效率有很大影响。比如C/C++程
由于每个人都希望软件的响应时间尽量短一些，所以软件公司都很重
、追求完美的态度和能力。
---
## Page 177
右边，我们可以接着在它的右边部分的数组中查找。这是一个典型的递归
左边部分的数组中查找。如果它的下标小于n/2，那么中位数应该位于它的
果它的下标大于n/2，那么中位数应该位于它的左边，我们可以接着在它的
果这个选中的数字的下标刚好是n/2，那么这个数字就是数组的中位数。如
数字小数字都排在它的左边，比选中的数字大的数字都排在它的右边。如
在数组中随机选择一个数字，然后调整数组中数字的顺序，使得比选中的
中任意第k大的数字。
即长度为n的数组中第n/2大的数字。我们有成熟的O(n)的算法得到数组
数超过数组长度一半的数字。也就是说，这个数字就是统计学上的中位数，
把这个数组排序，那么排序之后位于数组中间的数字一定就是那个出现次
数组的特性：数组中有一个数字出现的次数超过了数组长度的一半。如果
试着找出更快的算法。
杂度是O(nlogn)。最直观的算法通常不是面试官满意的算法，接下来我们
目给出的数组没有说是排序的，因此我们需要先给它排序。排序的时间复
果是排好序的数组，那么我们就能很容易统计出每个数字出现的次数。题
在数组中出现了5次，超过数组长度的一半，因此输出2。
个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字
面试题29：数组中出现次数超过一半的数字
面试的时候，应聘者的态度和激情对最终的面试结果也有很重要的影响。
应聘者能够有激情、有耐心去尝试新的思路，而不是碰到难题就退缩。在
面试官甚至不期待应聘者在短短几十分钟里想出完美的解法，但他会希望
表现出积极思考的态度，努力从不同的角度去思考问题。有些题目很难，
意，还在提示我们有更好的办法。这个时候我们一定不能轻言放弃，而要
少会觉得我们思维比较敏捷。我们想到几种思路之后面试官可能仍然不满
这种算法是受快速排序算法的启发。在随机快速排序算法中，我们先
如果我们回到题目本身仔细分析，就会发现前面的思路并没有考虑到
看到这道题很多应聘者就会想要是这个数组是排序的数组就好了。如
题目：数组中有一个数字出现的次数超过数组长度的一半，请找出这
第5章优化时间和空间效率163
---
## Page 178
164
剑指Offer-
bool CheckInvalidArray(int* numbers,int length)
bool g_bInputInvalid = false;
更多关于出错处理的讨论，详见本书3.3节。
能让面试官完全满意。下面的代码用一个全局变量来表示输入无效的情况，
CheckMoreThanHalf函数的原因。面试的时候我们要全面考虑这些情况，才
的数字都没有达到这个标准那该怎么办？这就是我们定义了一个
一个数字出现次数超过数组长度的一半，如果输入的数组中出现频率最高
CheckInvalidArray 用来判断输入的数组是不是无效的。题目中说数组中有
递的时候退化为指针)，就要考虑这个指针可能为NULL。下面的函数
要考虑一些无效的输入。如果函数的输入参数是一个指针（数组在参数传
节详细讨论了这个函数，这里不再重复。
int MoreThanHalfNum(int*numbers
过程，可以用如下代码实现：
g_bInputInvalid = false;
在面试的时候，除了要完成基本功能即找到符合要求的数字之外，还
上述代码中的函数Partition是完成快速排序的基础。我们在本书的2.4.1
return result;
if(!CheckMoreThanHalf(numbers,
int result = numbers[middle];
while(index
if(CheckInvalidArray(numbers,length))
nt
nt
int
int middle=length>>1;
result=0;
if(index
index
start=0;
returno;
end
Lse
名企面试官精讲典型编程题（纪念版）
index
start=index+1;
index
end=
length-1;
=Partition(numbers,length,start,end);
 = Partition(numbers, length, start, end);
index-1;
(>middle)
!=middle)