只知道它是一个数，像整数、小数一样可以加减乘除，甚至连它有直角坐标和极坐标也不需要
具有实部、虚部模和辐角的复数
图7.3.数据抽象
，但函数接口不改变，
add_complex sub_complex
仍然可以用，
struct complex_struct make_from_mag_ang(double r, double A)
可以加减柔除的复数
 把所有这些层组合在一起就是一个完整的系统。组合使得系统可以任意复杂，
real_part
return z;
z.r = sgrt(x * x + y * y);
return z; 
，因此也不依赖于它有哪些成员。我们结合下图具体分析一下。
复数的直角座标或极座标表示
原因在于这几个函数只把结构体complex_struct当作一个整体来使用，而没
其它使用复数运算的程序
img_part
 复数有可能用直角坐标或极坐标来表示，我们把这个有可能变动的因素
mul_complex div_complex
magnitude
知道它有直角坐标和极坐标,
或者r和A,
angle
，如果改变了结构体的实现就要改变这一层函娄
复数运算层
复数存储表示层
简单地说就是“提取公因
可以调用复数存储表示层白
从底层往上层来看，
三
复
数
数
---
## Page 118
抽象层应该由哪些函数组成。
归"练习题中的Euclid算法来约分。在动手编程之前先思考一下这个问题实现了什么样的数据抽象,
注意要约分为最简分数，
之间可以做加减乘除运算，
2、实现一个用分子分母的格式来表示有理数的结构体rationa1以及相关的函数，rational结构体
印函数应该属于上图中的哪一层？
如：1.0、-2.0i、-1.0+2.0i、1.0-2.0i。最后编写一
习题 请点评
1.复合类型与结构体
1、在本节的基础上实现一个打印复数的函数，
int main(void)
return 0;
print_rational(mul
print
struct rational 
struct rational 
 例如1/8和-1/8相减的打印结果应该是1/4而不是2/8，可以利用第3 节“递
 rational
，运算的结果仍然是rational。测试代码如下：
(sub
/* 8/-=q */ (8 '-)euoexayew = q 
全国嵌入式人才培训基地
= make_rational(l,
[rational(a)
，打印的格式是x+yi，
起始页
上一级
一个main函数测试本节的所有代码。想一想这个打
“(8
/* a=1/8 */ 
如果实部或虚部为0则省略，
3.数据类型标志
118
例
---
## Page 119
就不会影响到上层函数。例如：
complex_struct结构体的格式变了，就需要修改复数存储表示层的函数，但只要保持函数接口不变
在同一命名空间中，所以会出现命名冲突。例如这样是不合法的：
定，因此也可以出现在常量表达式中，可以用于初始化全局变量或者作为case分支的判断条件。
3.数据类型标志 请点评
有一点需要注意,
这样,
后
型。枚举类型的成员是常量，
complex_struct表示一个结构体类型,
个浮点数就表示极坐标。这样，
同时支持两种存储格式，
在上一节中，我们通过一个复数存储表示抽象层把complex_struct结构体的存储格式和上层的复类
上一页
，RECTANGULAR就表示常量O，POLAR表示常量1。如果不希望从O开始分配，可以这样定义:
有些数据是以直角坐标存储的，
RECTANGULAR就表示常量1，而POLAR表示常量2。枚举常量也是一种整型，
int main(void)
struct complex_
enum coordinate_type { RECTANGULAR, POLAR };
return 0;
printf(
 虽然结构体的成员名和变量名不在同一命名空间中，但枚举的成员名却和变量名
double a, b;
 enum coordinate_type t;
int 
 RECTANGULAR;
 比如先前已经采集了一些数据存在计算机中，有些数据是以极坐标存储
"%d %d\n"， RECTANGULAR, POLAR);
struct
而极坐标的数据先转成直角坐标再存，
它们的值由编译器自动分配，
直角坐标和极坐标的数据都可以适配
全国嵌入式人才培训基地
3.数据类型标志
第7章结构体
 直角坐标的数据可以直接存 
例如定义了上面的枚举类型之
，但由于浮点数的精度有限，
，其值在编译时确
119
，转换
下一
数
贝
---
## Page 120
2.数据抽象
结果是什么？并解释一下为什么是这样的结果。
2、编译运行下面这段程序:
习题 请点评
页
enum coordinate_type  RECTANGULAR = 1, POLAR };
struct complex_struct make_from_mag_ang(double r, double A)
 struct complex_struct make_from_real_img(double x, double Y)
int main(void)
#include 
return 0;
z.a = r;
struct complex_struct z;
return 
z.t = RECTANGULAR;
z aonsxaduo aoas
Z;
-
RECTANGULAR， POLAR);
全国嵌入式人才培训基地
起始页
上一级
4.嵌套结构体
2
下一页
---
## Page 121
访问嵌套结构体的成员要用到多个.运算符，例如：
利用C99的新特性也可以做Memberwise Initilization，例如[15] :
甚至可以把两种方式混合使用 (这样可读性很差，应该避免)
也可以平坦（Flat）地初始化。例如：
体可以嵌套地初始化，例如：
4.嵌套结构体 请点评
3.数据类型标志
[15] 为了便于理解，第1节"复合类型与结构体"讲的Initializer语法并没有描述这种复杂的用法。
义复平面上的线段：
结构体也是一种递归定义：结构体的成员具有某种数据类型，
人第1节“复合类型与结构体"讲的Initializer的语法可以看出，
上一页
S.start.b =
S.Start.t = RECTANGULAR;
struct segment s = { .start.x = 1.0, .end.x = 2.0 };
struct segment s = {{ 1.0, 2.0 }, 4.0, 6.0 }
struct segment s = { 1.0, 2.0, 4.0, 6.0 };
struct segment {
struct complex_struct end;
struct
全国嵌入式人才培训基地
第7章结构体
4.嵌套结构体
起始页
上一级
，Initializer也可以嵌套，因此嵌套结构
，而结构体本身也是一种数据类型。换
--..-..-..----..-..-..
................
第8章数组
121
下一
上一页
贝
---
## Page 122
全国嵌入式人才培训基地
---
## Page 123
5.多维数组
4.字符串
3.数组应用实例：直方图
2.数组应用实例：
第 8 章 数组 请点评
4.嵌套结构体
1.数组的基本概念
目
录
统计随机数
全国嵌入式人才培训基地
全国嵌入式人才培训基地
部分I.C语言入门
第8章数组
起始页
1.数组的基本概念
123
---
## Page 124
表达式不仅可以表示存储单元中的值，也可以表示存储单元本身，也就是说可以做左值，因此以
元素占4个字节，
据（假设都是0），而框外面的数字是下标，这四个单元分别
整个数组占了4个int型的存储单元，
数组类型的长度应该用一个整数常量表达式来指定[16]。
也可以定义一个包含数组成员的结构体:
构体元素组成的数组：
型，也可以是复合数据类型，数组中的元素也是如此。根据组合规则，我们可以定义一个由4个结
和结构体成员类似，
个由4个int型元素组成的数组count：
数组（Array）也是一种复合数据类型，它由一系列相同类型的元素（Element）组成。例如定义一
1.数组的基本概念 请点评
作
（Bracket）中的数字4表示数组的长度,
计算机术语中有Zeroth这个词。这样规定使得访问数组元素非常方便，
素。和我们平常数数不同，
上一页
count
图8.1.数组count
struct
int count[4];
a[4];
0
，数组count的4个元素的存储空间也是相邻的。结构体成员可以是基本数据类
0
0
，数组元素是从“第0个"开始数的，
m
，存储单元用小方框表示，
全国嵌入式人才培训基地
而在访问数组时，
1.数组的基本概念
第8 章数组
，数组中的元素通过下标（或者叫索
，方括号中的数字表示访问数组的第几个
大多数编程语言都是这么规定的，
里面的数字是存储在这个单元中的数
，比如count数组中的每个
124
方括号
下一页
---
## Page 125
Initialization : 
编译器会根据Initializer有三个元素确定数组的长度为3。利用C99的新特性也可以做Memberwise
不指定数组的长度，
数组也可以像结构体一样初始化，未赋初值的元素也是用0来初始化，例如：
码时就要小心避免出问题，事后依靠调试来解决问题的成本是很高的。
正确的语句时却有可能突然崩溃（
误[17]。但有时候这种错误很隐蔽,
不检查count[-1]或是count[100]这样的访问越界错误，编译时能顺利通过，所以属于运行时错 
使用数组下标不能超出数组的长度范围，
数组下标也可以是表达式，但表达式的值必须是整型的。例如：
非！。在C语言中后缀运算符的优先级最高，单目运算符的优先级仅次于后缀运算符，比其它运算符
到目前为止我们学习了五种后缀运算符：后缀++、后缀--、结构体取成员、数组取下标口、函数调
语句都是正确的:
下面举一个完整的例子：
例8.1.定义和访问数组
int count[4] = { [2] = 3 };
int count[] = { 3， 2，
int count[4] = { 3，2，};
count[i]:
int 
count[o]
1
int main(void)
#include 
=
10;
=
例如：
count[1]等于2，后面两个元素等于0。如果定义数组的同时初始化它，也可以
:count[i+l];
count[0] ＊ 2;
......
7;
return 0;
for (i = 0; i 
int main(void)
return 0;
gen random(10);
int
是用数学公式算出来的确定的数，
，没有一条指令产生的是随机数,
2.数组应用实例：统计随机数
，但可以肯定它是一个非常大的整数。通常我们用到的随机数是
，但是用计算机生成完全随机的数却不是那么容易。计算机执
全国嵌入式人才培训基地
，使用这个函数需要包含头文件stdlib.h,
第8章数组
，a[i]);
 检查这些数字的随机性如何。
，调用C标准库得到的随机数其实
只不过这些数看起来很随机，
它没有参数，返
，随机数在某些
6
下二
存
贝
---
## Page 129
说，它们也可以用作标识符，
注意，
预处理阶段处理的，
那么用#define定义的常量和第3节“数据类型标志"讲的枚举常量有什么区别呢？首先，define不
把#define定义的标识符n替换成它的定义20（在代码中做了三处替换，
这里介绍一种新的语法：用#define定义一个常量。实际上编译器的工作分为两个阶段，
成下面这样是什么结果。