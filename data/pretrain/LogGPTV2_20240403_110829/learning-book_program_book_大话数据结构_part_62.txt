low
aigt
下标
201040
30
06090800
pivotkey=50
下标
0
060908000001020
pivotkey=50
low
high
注意这里Lr{low]=L.r[0];
图 9-9-9
425
---
## Page 450
大语数据结构
3.优化小数组时的排序方案
对于一个数学科学家、博士生导师，他可以攻克世界性的难题，可以培养最优秀
的数学博士，但让他去教小学生“1+1=2”的算术课程，那还真未必会比常年在小学
里耕耘的数学老师教得好。换句话说，大材小用有时会变得反而不好用。刚才我谈到
了对于非常大的数组的解决办法。那么相反的情况，如果数组非常小，其实快速排序
反而不如直接插入排序来得更好（直接插入是简单排序中性能最好的）。其原因在于快
速排序用到了递归操作，在大量数据排序时，这点性能影响相对于它的整体算法优势
而言是可以忽略的，但如果数组只有几个记录需要排序时，这就成了一个大炮打蚊子
的大问题。因此我们需要改进一下QSort函数。
defineMAX_LENGTH_INSERT_SORT7/数组长度阔值*/
/对顺序象L中的子序列L.z[low..high]作快迪排序*/
void QSort（SqList &L,int low,int high)
int pivot;
if（（high-1ow）>X_LENGTH_INSERT_SORT)
（/*当high-1ow大子常数时用快速排序*/
pivot=Partition（L,low,high）；/将L.r[1ow..high]-分为二，*/
/并算出枢柚值pivot*/
QSort（L，low，pivot-1）；/·对低子表递归排序*/
QSort（L，pivot+1,high）；/·对高子表通归排序·/
else/·当high-low小于等于常数时用直楼入排序/
InsertSort(L):
我们增加了一个判断，当high-low不大于某个常数时（有资料认为7比较合适，
也有认为50更合理，实际应用可适当调整），就用直接插入排序，这样就能保证最大
化地利用两种排序的优势来完成排序工作。
4.优化递归操作
大家知道，递归对性能是有一定影响的，QSort函数在其尾部有两次递归操作。
如果待排序的序列划分极端不平衡，递归深度将趋近于n，面不是平衡时的bgzn，这
就不仅仅是速度快慢的问题了。栈的大小是很有限的，每次递归调用都会耗费一定的
栈空间，函数的参数越多，每次递归耗费的空间也越多。因此如果能减少递归，将会
大大提高性能。
426
---
## Page 451
第9章排序
于是我们对QSort实施尾递归优化。来看代码。
/对顺序表L中的子序列L.r[low..high]作快速排序*/
void QSorti（SqList*L,int low,int high）
int pivot;
if（（high-low）>MAX_LENGTH_INSERT_SORT）
while（low<high)
pivot=Partition1（L,1ow,high）;/*L.r[1ow..high]-分为二,*/
/算出框轴值pivot*/
QSort1（L,low,pivot-1);
对低子表递归排序·
1ow=pivot+1;
1尾递归/
/
else
InsertSort（L);
当我们将if改成while后（见加粗代码部分），因为第一次递归以后，变量kw就
没有用处了，所以可以将pivot+1赋值给ow，再循环后，来一次Partition
（Lbowhigh），其效果等同于“QSort（Lpivot+1high）：”。结果相同，但因采用选代而
不是递归的方法可以缩减堆栈深度，从面提高了整体性能。
在现实的应用中，比如C++、java、PHP、C#、VB、JavaScript等都有对快速排序
算法的实现”，实现方式上略有不同，但基本上都是在我们讲解的快速排序法基础上
的精神体现。
5.了不起的排序算法
我们现在学过的排序算法，有按照实现方法分类命名的，如简单选择排序、直接
插入排序、归并排序，有按照其排序的方式类比现实世界命名的，比如冒泡排序、堆
排序，还有用人名命名的，比如希尔排序。但是刚才我们讲的排序，却用“快速”来
命名，这也就意味着只要再有人找到更好的排序法，此“快速”就会名不符实，不
过，至少今天，TonyHoare发明的快速排序法经过多次的优化后，在整体性能上，依
注”：有兴地可以想办法到网上下载阅读它们的源代码。
427
---
## Page 452
大语数据结构
然是排序算法王者，我们应该要好好研究并掌握它。33
9.10
总结回顾
本章内容只是在讲排序，我们需要对已经提到的各个排序算法进行对比来总结回
顾。
首先我们讲了排序的定义，并提到了排序的稳定性，排序稳定对于某些特殊需求
来说是至关重要的，因此在排序算法中，我们需要关注此算法的稳定性如何。
我们根据将排序记录是否全部被放置在内存中，将排序分为内排序与外排序两
种，外排序需要在内外存之间多次交换数据才能进行。我们本章主要讲的是内排序的
算法。
根据排序过程中借助的主要操作，我们将内排序分为：插入排序、交换排序、选
择排序和归并排序四类。之后介绍的7种排序法，就分别是各种分类的代表算法。
排序
插入排序类
选择排序类
交换排序类
归并排
序类
直接插入
希尔排序
简单选择
排序
排序
堆排序
冒泡排序
快速排序
归并排序
图9-10-1
事实上，目前还没有十全十美的排序算法，有优点就会有缺点，即使是快速排序
法，也只是在整体性能上优越，它也存在排序不稳定、需要大量辅助空间、对少量
数据排序无优势等不足。因此我们就来从多个角度来剖析一下提到的各种排序的长
与短。
我们将7种算法的各种指标进行对比，如表9-10-1所示。
注”：美于快速排序算法更详细讲解，请参考（翼法导论）第二部分第七章“快进排序”的内容。
8Z
---
## Page 453
第9章排序
1-01-6
排序方法
平均情况
最好情况最坏情况
辅助空间
稳定性
冒泡排序
O(n)
O(n)
O(n)
O(1)
稳定
简单选择排序O（n）
O(n)
O(n)
0(1)
稳定
直接插入排序O（n²）
O（n)
0(n²)
0(1)
稳定
希尔排序
O（alogn）~O（n）O(n)
O(n)
0(1)
不稳定
堆排序
O(rlogn)
O（nlogn）O（nlogn）O（1)
不稳定
归并排序
O(rlogm)
O(logn)O(nlogn)O(n)
稳定
快速排序
O(nlogn)
O（nlogn）O（n²）)
O(logn）~O(n)
不稳定
从算法的简单性来看，我们将7种算法分为两类：
■简单算法：冒泡、简单选择、直接插入。
■改进算法：希尔、堆、归并、快速。
从平均情况来看，显然最后3种改进算法要胜过希尔排序，并远远胜过前3种简
单算法。
从最好情况看，反面冒泡和直接插入排序要更胜一筹，也就是说，如果你的待排
序序列总是基本有序，反而不应该考虑4种复杂的改进算法。
从最坏情况看，堆排序与归并排序又强过快速排序以及其他简单排序。
从这三组时间复杂度的数据对比中，我们可以得出这样一个认识。堆排序和归并
排序就像两个参加奥数考试的优等生，心理素质强，发挥稳定。而快速排序像是很情
绪化的天才，心情好时表现极佳，碰到较精糕环境会变得差强人意。但是他们如果都
来比赛计算个位数的加减法，它们反面算不过成绩极普通的冒泡和直接插入。
从空间复杂度来说，归并排序强调要马跑得快，就得给马吃个饱。快速排序也有
相应的空间要求，反而堆排序等却都是少量索取，大量付出，对空间要求是0（1）。如
果执行算法的软件所处的环境非常在乎内存使用量的多少时，选择归并排序和快速排
序就不是一个较好的决策了。
从稳定性来看，归并排序独占整头，我们前面也说过，对于非常在乎排序稳定性
的应用中，归并排序是个好算法。
从待排序记录的个数上来说，待排序的个数n越小，采用简单排序方法越合适。
反之，n越大，采用改进排序方法越合适。这也就是我们为什么对快速排序优化时，
增加了一个阀值，低于阀值时换作直接插入排序的原因。
从表9-10-1的数据中，似乎简单选择排序在3种简单排序中性能最差，其实也不
429
---
## Page 454
大话数据结构
完全是，比如，如果记录的关键字本身信息量比较大（例如，关键字都是数十位的数
字），此时表明其占用存储空间很大，这样移动记录所花费的时间也就越多，我们给出
3种简单排序算法的移动次数比较，如表9-10-2所示。
表9-10-2
排序方法平均情况最好情况最坏情况
冒泡排序
10
0(m)
简单选择排序O（m）
O(n)
直接格入排序O（n）
O（m）
o（n）
你会发现，此时简单选择排序就变得非常有优势，原因也就在于，它是通过大量
比较后选择明确记录进行移动，有的放矢。因此对于数据量不是很大而记录的关键字
信息量较大的排序要求，简单排序算法是占优的。另外，记录的关键字信息量大小对
那四个改进算法影响不大。
总之，从综合各项指标来说，经过优化的快速排序是性能最好的排序算法，但是
不同的场合我们也应该考虑使用不同的算法来应对它。
9.11结尾语
学完排序，你能够感受到，我们的算法研究者们都是在“似乎不可能”的情况
下，逐步提高排序算法的性能的。在剩下的几分钟时间里，我们再来做一道智力题，
感受一下把不可能变为可能。
请问如何把图9-11-1中用四段直线一笔将这九个点连起来？
图9-11-1
大家举手很快，因为绝大多数同学应该都看过这道题目。没有做过题目的同学通
常十有八九会落入一个小小的陷阱，在九个点围成的框中打转转，然后发现至少要五
430
---
## Page 455
第9章排序
段以上的直线才能连成。结果是，要找到答案，必须在思维上突破这九个点所围成的
框框的限制，如图9-11-2所示。
图9-11-2
如果智力题这就结束了，那就不考大家了。现在我的问题是如何做到三段直线一
笔将这九个点连起来？
此时，大家都在交头接耳，心里一定想着，“这怎么可能？”我来公布答案，那就
是用一条“Z”字线即可一笔连成。也许，最快找出这个答案的是那些没有学过数学
的孩子。作为成人，我们已被另一些“框框”所框住大脑。那就是数学上有一条基本
公理：两条平行线永不相交。另外数学上有另一个基本假设：点没有大小。可在现实
中任何一点都会有大小。突破这一限制，只要无限延长“2”字三段线，九点必可一
笔连。来看图9-11-3。
）
（
图9-11-3
有同学说，我图中的点比刚才的要大，这不符合题意。我想有这样想法的同学，
可能还是没有理解我想表达的意思，事实上，刚才的小黑点再小，它也是有大小的，
你可以想像三根直线足够长，它们就可以将这九个点相连了。
别急，题目没完，我现在要求只用一条直线将这九点一笔连，如何做？
431
---
## Page 456
大话数据结构
显然，大家的思维已经被打开。我们可轻易找到答案，因为只要再次突破几何学
中“线没粗细”的框框，用一条很粗的线，比如蘸了墨水的大刷子，面一条粗粗的直
线将九点全部包含其中即可。
不是不可能用四段、三段、一段直线一笔连九点，只是暂时还没有找到方法而
已。现实生活中所有的发明创造都是建立在打破前人所认定的“框框”的思维定势基
础上的。这道智力题当然不是要挑战数学的权威，它只是在给我们启示：“所有的事情
都是可能的，只是我们暂时还没有找到方法而已。
本章的结束，其实也就是数据结构这门课的结束了。数据结构和算法，还有很多
内容我们并没有涉及。要想真正掌握数据结构，并把它应用到工作中，你们的路还很
长。