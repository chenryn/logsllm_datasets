For most primitives, our HACL∗ implementations are as fast as
(and sometimes faster than) the fastest unvectorized C implementa-
tions in OpenSSL, Libsodium, and SUPERCOP. Notably, all our code
is significantly faster than the naive reference implementations
included in TweetNaCl and SUPERCOP. However, some assembly
implementations and vectorized C implementations are faster than
HACL∗. Our vectorized Chacha20 implementation was inspired by
Krovetz’s 128-bit vectorized implementation, and hence is as fast
as that implementation, but slower than implementations that use
256-bit vectors. Our Poly1305 and Curve25519 implementations
rely on 64x64 bit multiplication; they are faster than all other C
implementations, but slower than vectorized assembly code. Our
Ed25519 code is not optimized (it does not precompute fixed-base
scalar multiplication) and hence is significantly slower than the
fast C implementation in Libsodium, but still is much faster than
the reference implementation in TweetNaCl.
Table 5 measures performance on a cheap ARM device (Rasp-
berry Pi 3) running a 64-bit operating system. The cycle counts
were estimated based on the running time, since the processor
does not expose a convenient cycle counter. The performance of
all implementations is worse on this low-end platform, but on the
whole, our HACL∗ implementations remain comparable in speed
with Libsodium, and remains significantly faster than TweetNaCl.
OpenSSL Poly1305 and SHA-512 perform much better than HACL∗
on this device.
Performance on 32-bit Platforms. Our HACL∗ code is tailored
for 64-bit platforms that support 128-bit integer arithmetic, but our
code can still be run on 32-bit platforms using our custom library
for 128-bit integers. However, we expect our code to be slower
on such platforms than code that is optimized to use only 32-bit
instructions. Table 6 shows the performance of our code on an
ARM device (Raspberry Pi 3) running a 32-bit OS. In the Appendix,
Table 7 ranks the top SUPERCOP implementations on this device.
For symmetric primitives, HACL∗ continues to be as fast as (or
faster than) the fastest C implementations of these primitives. In
fact, our vectorized Chacha20 implementation is the second fastest
implementation in SUPERCOP. However, the algorithms that rely
on Bignum operations, such as Poly1305, Curve25519, and Ed25519,
suffer a serious loss in performance on 32-bit platforms. This is
because we represent 128-bit integers as a pair of 64-bit integers,
and we encode 128-bit operations in terms of 32-bit instructions.
Using a generic 64-bit implementation in this way results in a 3x
penalty. If performance on 32-bit machines is desired, we recom-
mend writing custom 32-bit implementations for these algorithms.
As an experiment, we wrote and verified a 32-bit implementation
of Poly1305 and found that its performance was close to that of
Libsodium. We again note that even with the performance penalty,
our code is faster than TweetNaCl.
CompCert Performance. Finally, we evaluate the performance
of our code when compiled with the new 64-bit CompCert com-
piler (version 3.0) for Intel platforms. Although CompCert sup-
ports 64-bit instructions, it still does not provide 128-bit integers.
Consequently, our code again needs to encode 128-bit integers as
Algorithm
SHA-256
SHA-512
Salsa20
ChaCha20 (ref)
Poly1305
Curve25519
Ed25519 sign
Ed25519 verify
Chacha20Poly1305
NaCl SecretBox
NaCl Box
HACL*
25.71
16.15
13.63
10.28
13.89
980,692
276.66
272.39
23.28
27.51
94.63
Libsodium TweetNaCl
30.87
26.08
43.75
17.69
10.79
458,561
70.71
58.37
28.21
54.31
83.64
97.80
99.07
-
-
111.42
4,866,233
736.07
1153.42
-
206.36
527.07
Table 3: Intel64-CompCert: Performance Comparison in cy-
cles/byte on an Intel(R) Xeon(R) CPU E5-1630 v4 @ 3.70GHz
running 64-bit Debian Linux 4.8.15. Code was compiled with
CompCert 3.0.1 with a custom library for 128-bit integers.
pairs of 64-bit integers. Furthermore, CompCert only includes veri-
fied optimizations and hence does not compile code that is as fast
as GCC. Table 3 depicts the performance of HACL∗, Libsodium,
and TweetNaCl, all compiled with CompCert. As with 32-bit plat-
forms, HACL∗ performs well for symmetric algorithms, and suffers
a penalty for algorithms that rely on 128-bit integers. If CompCert
supports 128-bit integers in the future, we expect this penalty to
disappear.
9 CONCLUSION
We presented the design, implementation, and evaluation of HACL∗,
an open-source verified cryptographic library that implements the
full NaCl API and many of the core primitives used in TLS 1.3.
All our code is verified to be memory safe, secret independent,
and functionally correct with respect to high-level, concise RFC-
based specifications. We deliver verified C code that can be readily
integrated into existing software. Our code is already being used
in larger verification projects like miTLS. In collaboration with
Mozilla, parts of HACL∗ code are also being incorporated within
the NSS cryptographic library, and should soon be used by default
in the Firefox web browser.
HACL∗ continues to evolve as we add more primitives and faster
implementations. The performance of our library is already compa-
rable to state-of-the-art C implementations and is within a small
factor of hand-optimized assembly code. Our results indicates that
security researchers should expect far more than auditability from
modern cryptographic libraries; with some effort, their full formal
verification is now well within reach.
ONLINE MATERIALS
The HACL∗ library is being actively developed as an open source
project at:
https://github.com/mitls/hacl-star/
All the code, specifications, and benchmarks mentioned in this
paper are available at the above URL, along with instructions for
installing our verification and compilation tools.
REFERENCES
[1] 2015. ChaCha20 and Poly1305 for IETF Protocols. IETF RFC 7539. (2015).
[2] 2016. Elliptic Curves for Security. IETF RFC 7748. (2016).
[3] 2017. Edwards-Curve Digital Signature Algorithm (EdDSA) . IETF RFC 8032.
[4] 2017. The Transport Layer Security (TLS) Protocol Version 1.3. IETF Internet
(2017).
Draft 20. (2017).
[7]
[6]
[5] Danel Ahman, Cătălin Hriţcu, Kenji Maillard, Guido Martínez, Gordon Plotkin,
Jonathan Protzenko, Aseem Rastogi, and Nikhil Swamy. 2017. Dijkstra Mon-
ads for Free. In 44th ACM SIGPLAN Symposium on Principles of Programming
Languages (POPL). ACM, 515–529. https://doi.org/10.1145/3009837.3009878
José Bacelar Almeida, Manuel Barbosa, Gilles Barthe, and François Dupres-
soir. 2015. Verifiable side-channel security of cryptographic implementations:
constant-time MEE-CBC.
IACR Cryptology ePrint Archive 2015 (2015), 1241.
http://eprint.iacr.org/2015/1241
José Bacelar Almeida, Manuel Barbosa, Gilles Barthe, François Dupressoir, and
Michael Emmi. 2016. Verifying Constant-Time Implementations. In USENIX
Security Symposium. 53–70.
[8] Andrew W Appel. 2015. Verification of a cryptographic primitive: SHA-256.
ACM Transactions on Programming Languages and Systems (TOPLAS) 37, 2 (2015),
7.
[9] Gilles Barthe, Gustavo Betarte, Juan Campo, Carlos Luna, and David Pichardie.
2014. System-level non-interference for constant-time cryptography. In Pro-
ceedings of the 2014 ACM SIGSAC Conference on Computer and Communications
Security. ACM, 1267–1279.
[10] Gilles Barthe, Benjamin Grégoire, Sylvain Heraud, and Santiago Zanella Béguelin.
2011. Computer-aided security proofs for the working cryptographer. In Annual
Cryptology Conference. 71–90.
[11] David Benjamin. 2016. poly1305-x86.pl produces incorrect output. https://mta.
openssl.org/pipermail/openssl-dev/2016-March/006161. (2016).
[14] Daniel J Bernstein. 2006. Curve25519: new Diffie-Hellman speed records. In
[12] Lennart Beringer, Adam Petcher, Katherine Q. Ye, and Andrew W. Appel. 2015.
Verified Correctness and Security of OpenSSL HMAC. In USENIX Security Sym-
posium. 207–221.
[13] Daniel J. Bernstein. 2005. The Poly1305-AES Message-Authentication Code. In
Fast Software Encryption (FSE). 32–49.
Public Key Cryptography-PKC 2006. Springer, 207–228.
[15] Daniel J Bernstein. 2008. ChaCha, a variant of Salsa20.
[16] Daniel J Bernstein, Niels Duif, Tanja Lange, Peter Schwabe, and Bo-Yin Yang.
High-speed high-security signatures. Journal of Cryptographic Engineering (????),
1–13.
[17] Daniel J Bernstein, Tanja Lange, and Peter Schwabe. 2012. The security impact
of a new cryptographic library. In International Conference on Cryptology and
Information Security in Latin America (LATINCRYPT). Springer, 159–176.
[18] Daniel J Bernstein and Peter Schwabe. 2012. NEON crypto. In International
Workshop on Cryptographic Hardware and Embedded Systems. Springer, 320–339.
[19] Daniel J Bernstein, Bernard Van Gastel, Wesley Janssen, Tanja Lange, Peter
Schwabe, and Sjaak Smetsers. 2014. TweetNaCl: A crypto library in 100 tweets. In
International Conference on Cryptology and Information Security in Latin America
(LATINCRYPT). Springer, 64–83.
[20] Karthikeyan Bhargavan, Antoine Delignat-Lavaud, Cédric Fournet, Catalin
Hritcu, Jonathan Protzenko, Tahina Ramananandro, Aseem Rastogi, Nikhil
Swamy, Peng Wang, Santiago Zanella-Béguelin, and Jean-Karim Zinzindohoué.
2017. Verified Low-Level Programming Embedded in F*. In ACM SIGPLAN
International Conference on Functional Programming (ICFP).
[21] Karthikeyan Bhargavan, Cédric Fournet, Markulf Kohlweiss, Alfredo Pironti,
and Pierre-Yves Strub. 2013. Implementing TLS with Verified Cryptographic
Security. In IEEE Symposium on Security & Privacy (Oakland). 445–462.
org/pipermail/openssl-dev/2016-March/006413. (2016).
[22] Hanno Böck. 2016. Wrong results with Poly1305 functions. https://mta.openssl.
[23] Barry Bond, Chris Hawblitzel, Manos Kapritsos, K. Rustan M. Leino, Jacob R.
Lorch, Bryan Parno, Ashay Rane, Srinath Setty, and Laure Thompson. 2017. Vale:
Verifying High-Performance Cryptographic Assembly Code. In Proceedings of
the USENIX Security Symposium.
[24] Billy B Brumley, Manuel Barbosa, Dan Page, and Frederik Vercauteren. 2012.
Practical realisation and elimination of an ECC-related software bug attack. In
Topics in Cryptology–CT-RSA 2012. Springer, 171–186.
[25] Yu-Fang Chen, Chang-Hong Hsu, Hsin-Hung Lin, Peter Schwabe, Ming-Hsien
Tsai, Bow-Yaw Wang, Bo-Yin Yang, and Shang-Yi Yang. 2014. Verifying
Curve25519 Software. In Proceedings of the 2014 ACM SIGSAC Conference on
Computer and Communications Security. ACM, 299–309.
[26] Quynh H Dang. 2008. The Keyed-Hash Message Authentication Code (HMAC).
NIST FIPS-198-1. (2008).
[27] A. Delignat-Lavaud, C. Fournet, M. Kohlweiss, J. Protzenko, A. Rastogi, N. Swamy,
S. Zanella-Beguelin, K. Bhargavan, J. Pan, and J. K. Zinzindohoue. 2017. Imple-
menting and Proving the TLS 1.3 Record Layer. In IEEE Symposium on Security
and Privacy (Oakland). 463–482.
PERFORMANCE BENCHMARKS
Implementation
moon/avx2/64
dolbeau/amd64-avx2
Language
assembly
Architecture
[28] Martin Goll and Shay Gueron. 2014. Vectorization on ChaCha stream cipher. In
Information Technology: New Generations (ITNG). 612–615.
[29] Chris Hawblitzel, Jon Howell, Jacob R Lorch, Arjun Narayan, Bryan Parno,
Danfeng Zhang, and Brian Zill. 2014. Ironclad apps: End-to-end security via
automated full-system verification. In 11th USENIX Symposium on Operating
Systems Design and Implementation (OSDI 14). 165–181.
[30] Gerwin Klein, Kevin Elphinstone, Gernot Heiser, June Andronick, David Cock,
Philip Derrin, Dhammika Elkaduwe, Kai Engelhardt, Rafal Kolanski, Michael
Norrish, et al. 2009. seL4: Formal verification of an OS kernel. In Proceedings of the
ACM SIGOPS 22nd symposium on Operating systems principles. ACM, 207–220.
[31] Xavier Leroy. 2009. Formal verification of a realistic compiler. Commun. ACM
52, 7 (2009), 107–115.
[32] Erick Nascimento, Łukasz Chmielewski, David Oswald, and Peter Schwabe. 2016.
Attacking embedded ECC implementations through cmov side channels. In
Selected Areas in Cryptology – SAC 2016 (Lecture Notes in Computer Science).
[33] Pierre-Yves Strub, Nikhil Swamy, Cedric Fournet, and Juan Chen. 2012. Self-
Certification: Bootstrapping Certified Typecheckers in F* with Coq. In ACM
SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL).
571–584.
[34] Nikhil Swamy, Cătălin Hriţcu, Chantal Keller, Aseem Rastogi, Antoine Delignat-
Lavaud, Simon Forest, Karthikeyan Bhargavan, Cédric Fournet, Pierre-Yves Strub,
Markulf Kohlweiss, Jean-Karim Zinzindohoue, and Santiago Zanella-Béguelin.
Dependent Types and Multi-Monadic Effects in F*. In ACM SIGPLAN-SIGACT
Symposium on Principles of Programming Languages (POPL). 256–270.
[35] A. Tomb. 2016. Automated Verification of Real-World Cryptographic Implemen-
tations. IEEE Security and Privacy 14, 6 (2016), 26–33.
[36] National Institute of Standards US Department of Commerce and Technology
(NIST). 2012. Federal Information Processing Standards Publication 180-4: Secure
hash standard (SHS). (2012).
Jean Karim Zinzindohoue, Evmorfia-Iro Bartzia, and Karthikeyan Bhargavan.
2016. A Verified Extensible Library of Elliptic Curves. In IEEE Computer Security
Foundations Symposium (CSF). 296–309.
[37]
Algorithm
ChaCha20
Poly1305
Curve25519
SHA-512
Ed25519
goll_guerin
krovetz/avx2
moon/avx/64
moon/ssse3/64
krovetz/vec128
hacl-star/vec128
moon/sse2/64
e/amd64-xmm6
e/x86-xmm6
hacl-star/ref
e/amd64-3
e/ref
moon/avx2/64
moon/avx/64
moon/sse2/64
hacl-star
amd64
x86
53
avx
ref
amd-64-64
sandy2x
amd-64-51
hacl-star
donna_c64
donna
ref10
athlon
ref
openssl
ref
sphlib
hacl-star
amd64-64-24k
ref10
hacl-star
ref
assembly
assembly
assembly
assembly
assembly
assembly
assembly
assembly
assembly
assembly
assembly
assembly
assembly
assembly
assembly
assembly
assembly
assembly
assembly
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
AVX2
AVX2
AVX2
AVX2
AVX
SSSE3
SSSE3
SSSE3
SSE2
SSE
SSE
x86_64
x86_64
x86
AVX2
AVX
SSE2
x86_64
x86_64
x86
x86
AVX
x86
x86_64