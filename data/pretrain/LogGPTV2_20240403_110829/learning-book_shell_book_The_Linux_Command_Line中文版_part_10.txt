有时候，我们需要查看参考手册的特定章节，从而找到我们需要的信息。如果我们要查找一
种文件格式，而同时它也是一个命令名时，这种情况尤其正确。没有指定章节号，我们总是得
到第一个匹配项，可能在第一章节。我们这样使用man命令，来指定章节号：
man section search_tern
例如：
[neglinuxbox -]$ man 5 passd
命令运行结果会显示文件/etc/passwd的文件格式说明手册。
6.9apropos一显示适当的命令
也有可能搜索参考手册列表，基于某个关键字的匹配项。虽然很粗糙但有时很有用。下面是一
个以“foppy”为关键词来搜索参考手册的例子：
[nellinuxbox -]$ apropos floppy
create_floppy_devices (8)
- udev callout to create all possible
输出结果每行的第一个字段是手册页的名字，第二个字段展示章节。注意，man命令加上
"-k”选项，和apropos完成一样的功能。
9
---
## Page 65
6.10
）whatis一显示非常简洁的命令说明
whatis程序显示匹配特定关键字的手册页的名字和一行命令说明：
最晦涩难懂的手册页
正如我们所看到的，Linux和类Unix的系统提供的手册页，只是打算作为参考
手册使用，而不是教程。许多手册页都很难阅读，但是我认为由于阅读难度而能拿
到特等奖的手册页应该是bash手册页。因为我正在为这本书做我的研究，所以我
很仔细地浏览了整个bash手册，为的是确保我讲述了大部分的bash主题。当把
bash参考手册整个打印出来，其篇幅有八十多页且内容极其紧密，但对于初学者来
说，其结构安排毫无意义。
另一方面，bash参考手册的内容非常简明精确，同时也非常完善。所以，如果
你有胆量就查看一下，并且期望有一天你能读懂它。
6.11info一显示程序Info条目
GNU项目提供了一个命令程序手册页的替代物，称为“info”。info内容可通过info阅读器程
序读取。info页是超级链接形式的，和网页很相似。这有个例子：
File: coreutils.info,
Bode: ls invocation,
Next: dir invocation,
Up: Directory listing
info程序读取info文件，info文件是树型结构，分化为各个结点，每一个包含一个题目。
info文件包含超级链接，它可以让你从一个结点跳到另一个结点。一个超级链接可通过它开头
的星号来辨别出来，把光标放在它上面并按下enter键，就可以激活它。
输入"info”，接着输入程序名称，启动info。下表中的命令，当显示一个info页面时，用来
控制阅读器
命令
行为
64
---
## Page 66
？
显示命令帮助
PgUp or Backspace
显示上一页
PgDn or Space
显示下一页
n
下一个-显示下一个结点
P
上一个-显示上一个结点
u1
Up-显示当前所显示结点的父结点，通常是个
菜单
Enter
激活光标位置下的超级链接
q
退出
表6-2:info命令
到目前为止。我们所讨论的大多数命令行程序，属于GNU项目“coreutils”包，所以输入：
[ne@linuxbox -]$info coreutils
将会显示一个包含超级链接的手册页.这些超级链接指向包含在coreutils包中的各个程序。
6.12README和其它程序文档
许多安装在你系统中的软件，都有自己的文档文件，这些文件位于/usr/share/doc目录下。这
些文件大多数是以文本文件的形式存储的，可用less阅读器来浏览。一些文件是HTML格式，
可用网页浏览器来阅读。我们可能遇到许多以“gz”结尾的文件。这表示gzip压缩程序已经压
缩了这些文件。gzip 软件包包括一个特殊的less版本，叫做zless，zless 可以显示由gzip压缩
的文本文件的内容。
6.13用别名（alias）创建你自己的命令
现在是时候，感受第一次编程经历了！我们将用alias命令创建我们自己的命令。但在开始之
前，我们需要展示一个命令行小技巧。可以把多个命令放在同一行上，命令之间用“：”分开。
它像这样工作：
65
---
## Page 67
cormand1; conmand2; conmand3.
我们会用到下面的例子：
[ne@linuxbox -]$ cd /usr; 1s; cd
bingases
kerberos lib64
1ocal
share
tm
[ne@linuxbox -]$
正如我们看到的，我们在一行上联合了三个命令。首先更改目录到/usr，然后列出目录内容
最后回到原始目录（用命令“cd-"），结束在开始的地方。现在，通过alias命令把这一串命令
转变为一个命令。我们要做的第一件事就是为我们的新命令构想一个名字。比方说“test”。在
使用"test”之前，查明是否“test”命令名已经存在系统中，是个很不错的主意。为了查清此事，
可以使用type命令：
[ne@linuxbox -]$ type test
test is a shell builtin
哦！“test”名字已经被使用了。试一下"foo"：
[ne@linuxbox -]$ type foo
bash: type: foo: not found
太棒了！“foo”还没被占用。创建命令别名：
[ne@linuxbox -]$ alias foo=′cd /usr; ls; cd -*
注意命令结构：
66
---
## Page 68
alias nane=
'string
在命令“alias”之后，输入“name”，紧接着（没有空格）是一个等号，等号之后是一串用引
号引起的字符串，字符串的内容要赋值给name。我们定义了别名之后，这个命令别名可以使
用在任何地方。试一下：
[ne@linuxbox -]$ foo
bin
ganes
kerberoslib64
localshare tap
[nedlinuxbox -]$
我们也可以使用type命令来查看我们的别名：
[nedlinuxbox -]$ type foo
-p>:st 1xsm/ po.04 poseTte sT oo
删除别名，使用unalias命令，像这样：
[ne@linuxbox -]$ unalias foo
[ne@linuxbox -]$ type foo
bash: type: foo: not found
虽然我们有意避免使用已经存在的命令名来命名我们的别名，但这是常做的事情。通常，会
把一个普遍用到的选项加到一个经常使用的命令后面。例如，之前见到的1s命令，会带有色彩
支持：
[ne@linuxbox -]$ type 1s
1oto-- s, 0 pe s s
要查看所有定义在系统环境中的别名，使用不带参数的alias命令。下面在Fedora系统中
默认定义的别名。试着弄明白，它们是做什么的：
67
---
## Page 69
[ne@linuxbox -]$ alias
alias 1.='ls -d .* --color=tty
在命令行中定义别名有点儿小问题。当你的shell会话结束时，它们会消失。随后的章节里
我们会了解怎样把自已的别名添加到文件中去，每次我们登录系统，这些文件会建立系统环境。
现在，好好享受我们刚经历过的，步入shell编程世界的第一步吧，虽然微小。
6.14拜访老朋友
既然我们已经学习了怎样找到命令的帮助文档，那就试着查阅，到目前为止，我们学到的所有
命令的文档。学习命令其它可用的选项，练习一下！
6.15拓展阅读
·在网上，有许多关于Linux和命令行的文档。以下是一些最好的文档：
·Bash参考手册是一本bashshell的参考指南。它仍然是一本参考书，但是包含了很多实
例，而且它比bash手册页容易阅读。
http:/www.gnu.org/software/bash/manual/bashref.html
·BashFAQ包含关于bash，而经常提到的问题的答案。这个列表面向bash的中高级用
户，但它包含了许多有帮助的信息。
http://mywiki.wooledge.org/BashFAQ
·GUN项目为它的程序提供了大量的文档，这些文档组成了Linux命令行实验的核心。这
里你可以看到一个完整的列表：
http:/www.gnu.org/manual/manual.html
·Wikipedia有一篇关于手册页的有趣文章：
http://en.wikipedia.org/wiki/Man_page
89
---
## Page 70
重定向
这堂课，我们来介绍可能是命令行最酷的特性。它叫做I/O重定向。“I/O”代表输入/输出，通
过这个工具，你可以将命令的输入来源以及输出地点重定向为文件。也可以把多个命令连接起
来组成一个强大的命令管道。为了展示这个工具，我们将叙述以下命令：
·cat一连接文件
·sort一排序文本行
·uniq-报道或省略重复行
·grep-打印匹配行
·wc一打印文件中换行符，字，和字节个数
·head一输出文件第一部分
·tail-输出文件最后一部分
·tee-从标准输入读取数据，并同时写到标准输出和文件
7.1标准输人输出和错误
到目前为止，我们用到的许多程序都会产生某种输出。这种输出，经常由两种类型组成。第一，
程序运行结果；这是说，程序要完成的功能。第二，我们得到状态和错误信息，这些告诉我们
程序进展。如果我们观察一个命令，像1s，会看到它的运行结果和错误信息显示在屏幕上
与Unix主题“任何东西都是一个文件”保持一致，程序，比方说ls，实际上把他们的运行
结果输送到一个叫做标准输出的特殊文件（经常用stdout表示），而它们的状态信息则送到另
一个叫做标准错误的文件（stderr）。默认情况下，标准输出和标准错误都连接到屏幕，而不是
保存到磁盘文件。除此之外，许多程序从一个叫做标准输人（stdin）的设备得到输人，默认情
况下，标准输入连接到键盘。
69
---
## Page 71
I/O重定向允许我们更改输出地点和输入来源。一般地，输出送到屏幕，输入来自键盘，但
是通过I/O重定向，我们可以做出改变。
7.2标准输出重定向
I/O重定向允许我们来重定义标准输出的地点。我们使用“>”重定向符后接文件名将标准输
出重定向到除屏幕以外的另一个文件。为什么我们要这样做呢？因为有时候把一个命令的运
行结果存储到一个文件很有用处。例如，我们可以告诉shell把ls命令的运行结果输送到文件
ls-output.txt中去，由文件代替屏幕。
[ne@linuxbox -]$ 1s -1 /usr/bin > 1s=output .txt
这里，我们创建了一个长长的目录/usr/bin列表，并且输送程序运行结果到文件ls-output.txt
中。我们检查一下重定向的命令输出结果：
[ne@linuxbox -]$ 1s -1 1s-output.txt
---
167878 2008-02-01 15:07 1s-output .txt
好；一个不错的大型文本文件。如果我们用less阅读器来查看这个文件，我们会看到文件
ls-output.txt的确包含ls命令的执行结果。
[ne@linuxbox -]$ less ls-output.txt
现在，重复我们的重定向测试，但这次有改动。我们把目录换成一个不存在的目录。
4x*4ndno-sT ”重定向符来重定向输出结果时，目标文件总是
从开头被重写。因为我们Is命令没有产生运行结果，只有错误信息，重定向操作开始重写文件，
然后由于错误而停止，导致文件内容清空。事实上，如果我们需要清空一个文件内容（或者创
建一个新的空文件），可以使用这样的技巧：
[nedlinuxbox -]$ > 1s-output.txt
简单地使用重定向符，没有命令在它之前，这会清空一个已存在文件的内容或是创建一个新
的空文件。
所以，怎样才能把重定向结果追加到文件内容后面，而不是从开头重写文件？为了这个目
的，我们使用“>>”重定向符，像这样：
x*4ndano-at>”操作符，将导致输出结果添加到文件内容之后。如果文件不存在，文件会被创
建，就如使用了“>”操作符。把它放到测试中：
x*4ndsno-st 1s-output.txt 2>k1
使用这种方法，我们完成两个重定向。首先重定向标准输出到文件ls-output.txt，然后重定
向文件描述符2（标准错误）到文件描述符1（标准输出）使用表示法2>&1。
注意重定向的顺序安排非常重要。标准错误的重定向必须总是出现在标准输出重定向之后
要不然它不起作用。上面的例子，
>1s-output.txt 2>&1
重定向标准错误到文件ls-output.txt，但是如果命令顺序改为：
72
---
## Page 74
2>k1 >ls-output.txt
则标准错误定向到屏幕。
现在的bash版本提供了第二种方法，更精简合理的方法来执行这种联合的重定向。
[ne@linuxbox -]$ ls -1 /bin/usr &> 1s-output.txt
在这个例子里面，我们使用单单一个表示法&>来重定向标准输出和错误到文件s
output.txt °