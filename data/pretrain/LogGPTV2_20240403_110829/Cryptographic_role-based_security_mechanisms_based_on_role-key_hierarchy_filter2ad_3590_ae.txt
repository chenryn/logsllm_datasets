1. Re-derive S as:
S′ =(cid:18) e (Wi, C2) · e (C1, H)
V
(cid:19)c
· e(Wi, H)s; (14)
2. Computes c′ = Hash(pk, M, C1, C2, T, S′);
3. Check that the challenge c is correct if and only
if c = c′. If matched, accept and reject otherwise.
The correctness of the veriﬁcation procedure is guar-
anteed by using Equation (9) and (10).
• T race(ski,j, σ): The tracing algorithm takes a set of
suspicious users RL = {(labi,j, Bi,j)}. For each el-
ement (labi,j, Bi,j) ∈ RL, it checks whether Bi,j is
encoded in (T, C2) by evaluating if
e(Wi, C2 − Bi,j) = e(T, H).
(15)
The algorithm outputs are valid if this veriﬁcation is
accepted.
The security of the system is guaranteed by the fact that
Ai,j and Bi,j are kept private. The diﬀerent witnesses are
generated to ensure the unlinkability as a result of the ran-
dom parameters α and β. The Wi in Equation (14) and (15)
determines that the role of a user cannot be modiﬁed.
The tracing algorithm may be used to realize the check
of revoked users: Given a set of revoked users RL, it ﬁrst
veriﬁes that the signature σ is valid by using V erif y algo-
rithm; then it ensures that σ is not generated by a revoked
user in terms of T race algorithm.
It accepts only if both
conditions are held. We reiterate the user’s secret key ski,j
is also secure after (labi,j, Bi,j) ∈ RL. The reason is that
the tracing or revocation check is based on Bi,j, as Ai,j still
keeps secret. Hence, the adversary cannot obtain the user’s
secret keys from a set of suspicious users RL.
5.4 Role-based Encryption Scheme
We can also adopt the RBC framework to build a lightweight
role-based encryption (RBE) scheme, as follows:
• Encrypt(pki, M ): To encrypt the message M ∈ {0, 1}∗,
given any pki = hH, V, Wi, {Uk}∇k∈⊥ri i and an empty
set of revoked users R = ∅, the algorithm randomly
picks t ∈ Z∗
p and then computes
C1 = [t] Wi
C2 = [t] H
C3 = M · V t
U ′
k = [t] Uk ∈ G1 ∃rk ∈↑ ri
∈ G1
∈ G2
∈ GT
.
(16)
Finally, it outputs Ci = hC1, C2, C3, {U ′
k}rk∈↑ri i.
• Decrypt(skj,k, Ci): Given a ciphertext Ci from the role
ri, the k-th user in the role rj can utilize the fol-
lowing equation to recover M from Ci with dkj,k =
hAj,k, Bj,ki, where ri (cid:22) rj:
i,j = e
V t
C1 + Xrl∈Γ(rj ,ri)
U ′
l , Bj,k
· e (Aj,k, C2) ,
(17)
9
Application Module
Authentication 
Service
Encryption 
Service
Key-label
Management
Access
Control
Module
RBC
Module
Figure 7: Cryptographic access control system
based on role-key hierarchy.
where Γ(rj, ri) denotes ∪ri(cid:22)rk≺rj {rk}, and we have
Γ(rj, ri) = ∪rj 6(cid:22)rk {rk} \ ∪ri6(cid:22)rk {rk}
= ∪ri(cid:22)rk {rk} \ ∪rj (cid:22)rk {rk}
= ∪ri(cid:22)rk≺rj {rk}
(18)
in terms of Theorem 1. The algorithm outputs the
session key M = C3/V t
i,j.
The validity of this algorithm is guaranteed by Equa-
tion (19). Given a ﬁxed role-key hierarchy, this algorithm
achieves the constant length of ciphertexts and the optimal
length of the user’s secret keys, where the hidden constant
relates to a couple of elements of a pairing-friendly group.
6. PERFORMANCE EVALUATION
An experimental role-based cryptosystem was implemented
to test the feasibility of our schemes. This system was
developed with a standard C++ language in QT environ-
ment, which supports cross-platform deployment. As shown
in Figure 7, this system consists of three modules: RBC
module, access control module and application module. In
RBC module, we adopted GNU multiple precision arith-
metic library (GMP) to handle integers of arbitrary preci-
sion. Then, a ﬁnite ﬁelds arithmetic library was constructed
to realize the run-time environment of elliptic curve and
pairing-based cryptosystems. In addition, a cryptographic
access control library was developed based on the ﬁnite ﬁelds
arithmetic library to realize various proposed RBC algo-
rithms. Finally, the RBE/RBA/RBS algorithms worked
with a lightweight access control module to provide encryp-
tion, authentication and key-label management services for
the application module.
Scalability. The experimental results show our construc-
tions are able to provide better scalability, which is an im-
portant requirement for RBAC [13]. The notion of scala-
bility is multi-dimensional. In our schemes we can achieve
scalability with respect to the number of roles, the size of
role hierarchy, cardinality on user-role assignments, and so
V t
U ′
i,j = e
l , Bj,k
C1 + Xrl∈Γ(rj ,ri)
 · e (Aj,k, C2)
= e
 G,
 t
τl
τ0 + Xrl6(cid:22)ri
τ0 + Prl6(cid:22)ri
(τ0 +P rl 6(cid:22)rj
τ0 +P rl 6(cid:22)rj
τl +xj,k · e(G, H)
= e(G, H)
τl )·t
1
τ0 +P rl 6(cid:22)rj
τl + xi,j
t·xi,j
H
· e
xi,j
τl + xi,j
G, [t]H
τ0 + Prl6≺ri
τl+xj,k = e(G, H)t.
(19)
on. Moreover, our constructions support a large-size of role
hierarchy with arbitrary structures. Therefore, we believe
our schemes can be applied to large-scale role-based cryp-
tosystems, such as healthcare and ﬁnancial systems.
Table 1: Parameters choosing under diﬀerent scales.
Parameters
Small size Medium size
Large size
number of roles
number of users
height of hierarchy
10’s
10-50
1-4
100’s
50-100
5-8
1000’s
100-200
9-12
total number of users
100-1,000
1,000-10,000
10,000-100,000
We can consider several degrees to measure the scalability
of our method as follows: 1) small scale (10’s), 2) medium
scale (100’s), and 3) large scale (1000’s). We estimate dif-
ferent parameters under diﬀerent scales shown in Table 1,
in which we assume that the size of relations is proportional
to the size of roles.
Computation Cost. The basic operation of our schemes
is the computation of a multiple elliptic point in elliptic
curve, namely, [k]P , where k is a positive integer and P
is an elliptic curve point. We neglect the computation costs
of an addition of elliptic points and simple modular arith-
metic operations because they run fast enough. Another
important operation is the computation of a bilinear map
e(·, ·) between two elliptic points. Then, we use the costs of
multiple operation and bilinear map operation to measure
the computation complexity of our schemes.
Table 2: Comparison of computation costs on RBC.
(The number of roles is m in RKH.)
Setup
GetRkey
AddUser
0/0
2/0
Encrypt/Sign
(m + 3)/0
Decrypt/Verify
/Trace
1/2
/
RBE
RBS/RBA
(m + 1)/1
(m + 1)/1
0/0
2/0
4/1
5/3
1/2
In Table 2, the costs of various algorithms in RBC, RBE,
and RBS/RBA schemes are listed, where the value n/m de-
notes the number of multiple operations n and the number
of bilinear map operations m, respectively. It is quite clear
that all schemes have the low computational costs.
Communication Overhead. With the same assump-
tion of scalability, we estimate the inﬂuence of communica-
10
tion overloads under the diﬀerent scales. Suppose the secu-
rity parameter s is 80-bits, we need the elliptic curve domain
parameters over Fq with |q| = 160-bits 3. This means that
the length of integer is l0 = 2s in Zp. Similarly, we have
l1 = 4s in G1, l2 = 20s in G2, and lT = 10s in GT
4.
For RBS/RBA scheme, the communication overloads of
Sign/Interact is 2l0 + 2l1 + l2 = 32s = 320 bytes. For
RBE scheme, the length of ciphertext is ml1 + l2 + lT =
4ms + 30s = 300 + 40m bytes. In terms of Table 1, we can
easily compute that the overheads are increased from 0.7
KBytes(10 roles) to 40 KBytes(1000 roles).
i
e
z
s
t
x
e
t
r
e
h
p
C
i
160.0k
140.0k
120.0k
100.0k
80.0k
60.0k
40.0k
20.0k
0.0
10
1,000
 RBE
 R-EFS(1/2)
 R-EFS(1/3)
 R-EFS(1/4)
 R-EFS(1/5)
1000
100,000
System scale (number of roles (up) and users (down))
100
1,0000
Figure 8: The ciphertext size under diﬀerent scales
(The size of roles changes from 10 to 1000. The
number of revoked users is equal to 1/2, 1/3, 1/4,
and 1/5 the number of roles.)
Figure 8 shows the change rate of ciphertext size for the
RBE scheme and the R-EFS scheme. Moreover, the revo-
cation mechanism is considered in R-EFS as well. Figure
8 indicates that the size of revoked users has more impact
than other factors. Our results also indicate that the en-
cryption based on RBE scheme performs far better than the
conventional encryption ﬁle systems (EFS) with the follow-
ing parameters:
• Even if we deal with a large-scale organization of 500,000
users the header of a ﬁle only requires 256 KBytes in
theory (using a standard 10-bytes (80-bits) security
parameter); and
3Elliptic curve domain parameters over Fp with ⌈log2 p⌉ = 2t
supply approximately t bits of security, which means that
solving the logarithm problem on associated elliptic curve is
believed to take approximately 2t operations.
4Let the embedding degree be 5.
• The EFS with our scheme can revoke an approximate
1,000 users (some intermediate data are saved to de-