private linear branching programs with medical
applications. ESORICS 2009, volume 5789 of LNCS,
pages 424–439. Springer, 2009.
[10] D. Beaver, S. Micali, and P. Rogaway. The round
complexity of secure protocols. Proceedings of the
twenty-second annual ACM symposium on Theory of
computing, pages 503–513. ACM, 1990.
[11] M. Bellare, V. Hoang, and P. Rogaway. Foundations of
garbled circuits. Cryptology ePrint Archive, Report
2012/265, 2012.
[12] M. Bellare and P. Rogaway. The security of triple
encryption and a framework for code-based
game-playing proofs. EUROCRYPT 2006, volume
4004 of LNCS, pages 409–426. Springer, 2006.
[13] C. Cachin, J. Camenisch, J. Kilian, and J. M¨uller.
One-round secure computation and secure autonomous
mobile agents. 27th Intl. Colloquium on Automata,
Languages, and Programming — ICALP 2000, pages
512–523. Springer, 2000.
[14] M. Chase and S. Kamara. Structured encryption and
controlled disclosure. ASIACRYPT 2010, volume 6477
of LNCS, pages 577–594. Springer, 2010.
[15] U. Feige, J. Kilian, and M. Naor. A minimal model for
secure computation (extended abstract). 26th ACM
STOC, pages 554–563. ACM Press, 1994.
[16] K. Frikken, M. Atallah, and C. Zhang.
Privacy-preserving credit checking. Proceedings of the
6th ACM conference on Electronic commerce, pages
147–154. ACM, 2005.
[17] R. Gennaro, C. Gentry, and B. Parno. Non-interactive
veriﬁable computing: Outsourcing computation to
untrusted workers. CRYPTO 2010, volume 6223 of
LNCS, pages 465–482. Springer, 2010.
[18] O. Goldreich. Cryptography and cryptographic
protocols. Manuscript, 2001.
[19] O. Goldreich, S. Micali, and A. Wigderson. How to
play any mental game, or a completeness theorem for
protocols with honest majority. 19th ACM STOC,
pages 218–229. ACM Press, 1987.
[20] S. Goldwasser, Y. Kalai, and G. Rothblum. One-time
programs. CRYPTO 2008, volume 5157 of LNCS,
pages 39–56. Springer, 2008.
[21] V. Goyal, P. Mohassel, and A. Smith. Eﬃcient two
party and multi party computation against covert
adversaries. EUROCRYPT 2008, volume 4965 of
LNCS, pages 289–306. Springer, 2008.
[22] A. Herzberg and H. Shulman. Secure guaranteed
computation. Cryptology ePrint Archive, Report
2010/449, 2010.
[23] Y. Huang, D. Evans, J. Katz, and L. Malka. Faster
secure two-party computation using garbled circuits.
USENIX Security Symposium, 2011.
[24] Y. Huang, C. Shen, D. Evans, J. Katz, and A. Shelat.
Eﬃcient secure computation with garbled circuits.
ICISS, volume 7093 of Lecture Notes in Computer
Science, pages 28–48. Springer, 2011.
[25] Y. Ishai and E. Kushilevitz. Randomizing polynomials:
A new representation with applications to
round-eﬃcient secure computation. 41st FOCS, pages
294–304. IEEE Computer Society Press, 2000.
794[26] Y. Ishai and E. Kushilevitz. Perfect constant-round
[44] B. Pinkas, T. Schneider, N. P. Smart, and S. C.
secure computation via perfect randomizing
polynomials. ICALP, volume 2380 of Lecture Notes in
Computer Science, pages 244–256. Springer, 2002.
[27] Y. Ishai, E. Kushilevitz, R. Ostrovsky, and A. Sahai.
Cryptography with constant computational overhead.
40th ACM STOC, pages 433–442. ACM Press, 2008.
[28] S. Kamara, P. Mohassel, and M. Raykova.
Outsourcing multi-party computation. Cryptology
ePrint report 2011/272, 2011.
[29] S. Kamara and L. Wei. Special-purpose garbled
circuits. Unpublished manuscript.
[30] J. Katz and R. Ostrovsky. Round-optimal secure
two-party computation. CRYPTO 2004, volume 3152
of LNCS, pages 335–354. Springer, 2004.
[31] V. Kolesnikov and T. Schneider. Improved garbled
circuit: Free XOR gates and applications. ICALP
2008, Part II, volume 5126 of LNCS, pages 486–498.
Springer, 2008.
[32] B. Kreuter, A. Shelat, and C. Shen. Billion-gate secure
computation with malicious adversaries. Proceedings of
the 21th USENIX Security Symposium (USENIX
2012), 2012.
[33] L. Kruger, S. Jha, E. Goh, and D. Boneh. Secure
function evaluation with ordered binary decision
diagrams. ACM CCS 06, pages 410–420. ACM Press,
2006.
[34] Y. Lindell and B. Pinkas. An eﬃcient protocol for
secure two-party computation in the presence of
malicious adversaries. EUROCRYPT 2007, volume
4515 of LNCS, pages 52–78. Springer, 2007.
[35] Y. Lindell and B. Pinkas. A proof of security of Yao’s
protocol for two-party computation. Journal of
Cryptology, 22(2):161–188, 2009.
[36] Y. Lindell and B. Pinkas. Secure two-party
computation via cut-and-choose oblivious transfer.
TCC 2011, volume 6597 of LNCS, pages 329–346.
Springer, 2011.
[37] D. Malkhi, N. Nisan, B. Pinkas, and Y. Sella.
Fairplay — a secure two-party computation system.
Proceedings of the 13th conference on USENIX
Security Symposium-Volume 13, pages 20–20. USENIX
Association, 2004.
[38] P. Mohassel and M. Franklin. Eﬃciency tradeoﬀs for
malicious two-party computation. PKC 2006, volume
3958 of LNCS, pages 458–473. Springer, 2006.
[39] M. Naor and K. Nissim. Communication preserving
protocols for secure function evaluation. 33rd ACM
STOC, pages 590–599. ACM Press, 2001.
[40] M. Naor, B. Pinkas, and R. Sumner. Privacy
preserving auctions and mechanism design.
Proceedings of the 1st ACM conference on Electronic
commerce, pages 129–139. ACM, 1999.
[41] A. Paus, A. Sadeghi, and T. Schneider. Practical
secure evaluation of semi-private functions. ACNS 09,
volume 5536 of LNCS, pages 89–106. Springer, 2009.
[42] K. Pietrzak. A leakage-resilient mode of operation.
EUROCRYPT 2009, volume 5479 of LNCS, pages
462–482. Springer, 2009.
[43] B. Pinkas. Cryptographic techniques for
privacy-preserving data mining. ACM SIGKDD
Explorations Newsletter, 4(2):12–19, 2002.
Williams. Secure two-party computation is practical.
ASIACRYPT 2009, volume 5912 of LNCS, pages
250–267. Springer, 2009.
[45] P. Rogaway. The round complexity of secure protocols.
MIT Ph.D. Thesis, 1991.
[46] A. Sahai and H. Seyalioglu. Worry-free encryption:
functional encryption with public keys. ACM CCS 10,
pages 463–472. ACM Press, 2010.
[47] T. Schneider. Engineering Secure Two-Party
Computation Protocols – Advances in Design,
Optimization, and Applications of Eﬃcient Secure
Function Evaluation. PhD thesis, Ruhr-University
Bochum, Germany, February 9, 2011.
http://thomaschneider.de/papers/S11Thesis.pdf.
[48] T. Schneider. Engineering Secure Two-Party
Computation Protocols. Springer, Berlin Heidelberg,
2012.
[49] J. R. Troncoso-Pastoriza, S. Katzenbeisser, and
M. Celik. Privacy preserving error resilient dna
searching through oblivious automata. ACM CCS 07,
pages 519–528. ACM Press, 2007.
[50] A. Yao. How to generate and exchange secrets.
Foundations of Computer Science, 1986., 27th Annual
Symposium on, pages 162–167. IEEE, 1986.
[51] A. C. Yao. Protocols for secure computations. 23rd
FOCS, pages 160–164. IEEE Computer Society Press,
1982.
APPENDIX
A. RELATED WORK
We do not attempt a comprehensive review of the litera-
ture (easily a monograph-length undertaking), but elaborate
on some selected prior work.
Randomized encodings.
Loosely related to garbling
schemes, randomized encodings (initially randomized polyno-
mials) begin with Ishai and Kushilevitz [25] and continue,
with many deﬁnitional variants,
in work by Applebaum,
Ishai, Kushilevitz, and others [2–6, 26, 27, 46]. The authors
function F (·,·) is
employ language like the following [3]:
a randomized encoding of f (·) if:
(correctness) there’s a
PT algorithm De such that De(F (x, r)) = f (x) for almost
all r; and (privacy) there’s a PT algorithm Sim such that
ensembles F (x,·) and Sim(f (x)) are computationally indis-
tinguishable. To be useful, encodings must have some extra
properties, for example, that every bit of F (x, r) depends on
at most one bit of x, a property that has been called decom-
posability [27]. Proven realizations meeting these require-
ments [3, 4] do not closely resemble conventional realizations
of garbled circuits [35, 40].
There is a large gap, even syntactically, between the no-
tion just given and a garbling scheme. Above, no language is
provided to speak of the algorithm that transforms f to F ;
in contrast, the thing doing this transformation is at the cen-
ter of a garbling scheme. Likewise absent from the syntax
of randomized encodings is anything to speak to the repre-
sentation of functions; for garbling schemes, representations
are explicit and central. Finally, the syntax, unlike that of
a garbling scheme, does not separate the garbling of a func-
tion and the creation of a garbled input, and indeed there is
nothing corresponding to the latter, the same input x being
795and obv.sim require one to hide both the input and the func-
tion.
Obscuring topology. We are not the ﬁrst to observe that
conventional means to garble a circuit obscure each gate’s
function but not its topology. A 2002 paper of Pinkas [43]
(Section 2.3) already remarks that “In this form the represen-
tation reveals nothing but the wiring of the circuit”. Later,
Paus, Sadeghi, and Schneider [41] use the phrase “circuit
topology” to name that which is revealed by conventional
garbled circuits. Nevertheless, the topology of a circuit is
never formalized, and nobody ever proves that that some
particular scheme reveals only the topology. We are also
the ﬁrst to explain the equivalence between the prv.sim and
prv.ind notions relative to Φtopo.
Eclectic representations.
Scattered through the lit-
erature one ﬁnds computational objects other than boolean
circuits that are being garbled; examples include arithmetic
circuits [6], branching programs [9], circuits with lookup ta-
bles [39], DFAs [49], and ordered binary decision diagrams
[33]. The range suggests, to us, that general-purpose deﬁni-
tions for garbling schemes ought not be tied to circuits.
Concurrent work.
Concurrent work by Kamara and
Wei (henceforth KW) investigates the garbling of structured
circuits [29], a computational model they put forward resem-
bling ordinary circuits except that gates perform operations
on an arbitrary data structure. As part of this work, KW
deﬁne what they too call a garbling scheme. Their syntax
is similar to ours, but without the function ev. Over this
syntax KW deﬁne Ind1 and Sim1 security. These notions,
unlike ours, ask only for input-hiding, not function hiding.
They show these deﬁnitions are equivalent for sampleable
circuits. KW go on to give dynamic versions of their deﬁni-
tions, Ind2 and Sim2, and an unforgeability notion, Unf2.
These deﬁnitions resemble the weaker form of the dynamic-
security deﬁnitions (prv1, obv1, and aut1) mentioned in our
Introduction and the subject of separate work.
Although KW speak of circuits as ﬁnitary objects de-
scribed by DAGs, they appear to have in mind families of
circuits, indexed by a security parameter (otherwise, we do
not know how to make sense of samplability, or phrases like
polynomial size circuits). Unlike our treatment, circuits are
not provided by the adversary; security notions are with re-
spect to a given circuit. A garbling scheme is provided in
KW, but not a “conventional” one:
it garbles a structured
circuit and is based on a collection of structured encryption
schemes, a notion from Chase and Kamara [14]. For the
protocol to make sense with respect to the deﬁnitions given,
the latter should be reinterpreted as applying to structured
circuits.
fed to f or F . The minimalist syntax of randomized en-
codings works well for some theory-centric applications, but
does not allow one to speak of obliviousness and authentic-
ity, to investigate the low-level eﬃciency of diﬀerent garbling
schemes, and to architect schemes to useful-in-practice ab-
straction boundaries.
1 , X 1
1 , . . . , X xm
m, X 1
1 , . . . , X xm
Given the variety of related deﬁnitions, let us sketch an-
other, the decomposable randomized encodings deﬁned and
used by Sahai and Seyalioglu [46]. (Despite identical names,
this deﬁnition is diﬀerent from that above, and diﬀerent
again from the decomposable randomized encodings of [27],
say). The object of interest can be regarded as a pair of
PT algorithms (En, De) where En maps the encoding of a
boolean circuit f : {0, 1}n → {0, 1}m to a vector of strings
m) ← En(1k, f ) for which decoding al-
(X 0
1 , . . . , X 0
m ) returns f (x1 ···x n). The au-
gorithm De(X x1
thors demand a PPT algorithm Sim for which the ensem-
m ) tuples induced by En(1k, f ) and x is
ble of (X x1
computationally indistinguishable from Sim(1k, n,| f|, f (x)).
Translating to our language, one has eﬀectively assumed a
projective scheme, a boolean circuit as input, and prv.sim
security over Φsize. The garbled function itself has been
abstracted out of existence (in a realization,
it would be
dropped in the X j
i values). Compared to a garbling scheme,
one might note the lack of representation independence, gran-
ularity inadequate to speak of obliviousness, authenticity,
garbled inputs, and low-level eﬃciency. The syntax can’t
handle the dynamic setting, where the adversary receives
the garbled circuit before it speciﬁes the input.
Obliviousness and authenticity.
Some prior papers
exploit obliviousness and authenticity of garbled circuits to
achieve desired applications: private medical diagnostics [9],
veriﬁable computation and private veriﬁable computation
[17], and correctable veriﬁable computation [5]. The no-
tions are not seen as properties of a stand-alone primitive
corresponding to a garbling scheme.
In the last of the works mentioned, Applebaum, Ishai,
Kushilevitz [5] describe the following generic transformations
from privacy to obliviousness and to authenticity. (1) Obliv-
instead of garbling a circuit f , let g be a circuit
iousness:
such that g(x (cid:13) r) = f (x) ⊕ r for every x ∈ {0, 1}n and
r ∈ {0, 1}m, where n = f.n and m = f.m. Then, choose
r (cid:2){0, 1}m, run (F, e, d) ← Gb(g) and output (F, (e, r), d).
The garbled input corresponding to x will be e(x (cid:13) r).
instead of garbling a circuit f , let g be
(2) Authenticity:
a circuit such that g(x (cid:13) K) = f (x) (cid:13) MACK (f (x)) for any
x ∈ {0, 1}n and any key K. Then, choose a random key K,
run (F, e, d) ← Gb(g), and output (F, (e, K), d). The garbled
input corresponding to x will be e(x (cid:13) K). Applied to Gar-
ble1, the transformations lead to schemes slightly (for (1))
or substantially (for (2)) less eﬃcient that Garble2; and (2)
requires a cryptographic assumption. More fundamentally,
Applebaum et al. do not formalize any deﬁnition for the
obliviousness or authenticity of a garbling scheme.
The only work that explicitly deﬁnes obliviousness and
authenticity in this domain is a recent paper of Kamara,
Mohassel, and Rakova [28]. Still, their syntax is designed
speciﬁcally for their application; for example, a circuit’s in-
put is a pair (x1, x2), a garbled circuit’s input is (X1, X2),
and the encoding function takes an input x and an index
i ∈ {1, 2} and outputs the corresponding Xi. Their notion
of obliviousness requires hiding only the input, while obv.ind
796