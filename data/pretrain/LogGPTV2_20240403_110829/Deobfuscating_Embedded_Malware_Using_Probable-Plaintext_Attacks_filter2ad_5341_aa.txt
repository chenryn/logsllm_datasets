title:Deobfuscating Embedded Malware Using Probable-Plaintext Attacks
author:Christian Wressnegger and
Frank Boldewin and
Konrad Rieck
Deobfuscating Embedded Malware
Using Probable-Plaintext Attacks
Christian Wressnegger1,2, Frank Boldewin3, and Konrad Rieck2
1 idalab GmbH, Germany
2 University of G¨ottingen, Germany
3
www.reconstructer.org
Abstract. Malware embedded in documents is regularly used as part
of targeted attacks. To hinder a detection by anti-virus scanners, the
embedded code is usually obfuscated, often with simple Vigen`ere ci-
phers based on XOR, ADD and additional ROL instructions. While for
short keys these ciphers can be easily cracked, breaking obfuscations with
longer keys requires manually reverse engineering the code or dynami-
cally analyzing the documents in a sandbox. In this paper, we present
Kandi, a method capable of eﬃciently decrypting embedded malware
obfuscated using Vigen`ere ciphers. To this end, our method performs a
probable-plaintext attack from classic cryptography using strings likely
contained in malware binaries, such as header signatures, library names
and code fragments. We demonstrate the eﬃcacy of this approach in dif-
ferent experiments. In a controlled setting, Kandi breaks obfuscations
using XOR, ADD and ROL instructions with keys up to 13 bytes in less
than a second per ﬁle. On a collection of real-world malware in Word,
Powerpoint and RTF ﬁles, Kandi is able to expose obfuscated malware
from every fourth document without involved parsing.
Keywords: embedded malware, obfuscation, cryptanalysis.
1
Introduction
Documents containing malware have become a popular instrument for targeted
attacks. To inﬁltrate a target system, malicious code is embedded in a benign
document and transfered to the victim, where it can—once opened—unnoticeably
inﬁltrate the system. Two factors render this strategy attractive for attackers:
First, it is relatively easy to lure even security-aware users into opening an un-
trusted document. Second, the complexity of popular document formats, such
as Word and PDF, constantly gives rise to zero-day vulnerabilities in the respec-
tive applications, which provide the basis for unnoticed execution of malicious
code. Consequently, embedded malware has been used as part of several targeted
attack campaigns, such as Taidoor [28], Duqu [1] and MiniDuke [6].
To hinder a detection by common anti-virus scanners, malicious code em-
bedded in document ﬁles is usually obfuscated, often in multiple layers with
increasing complexity. Although there exist a wide range of possible obfuscation
S.J. Stolfo, A. Stavrou, and C.V. Wright (Eds.): RAID 2013, LNCS 8145, pp. 164–183, 2013.
c(cid:2) Springer-Verlag Berlin Heidelberg 2013
Deobfuscating Embedded Malware Using Probable-Plaintext Attacks
165
strategies, many attackers resort to simple cryptographic ciphers when imple-
menting the ﬁrst obfuscation layer in native code. Often these ciphers are vari-
ants of the so-called Vigen`ere cipher using XOR and ADD/SUB instructions for
substitution and ROL/ROR for transposition. The resulting code can ﬁt into
less than 100 bytes and, in contrast to strong ciphers, exposes almost no de-
tectable patterns in the documents [see 4]. As an example, Figure 1 shows a
simple deobfuscation loop using XOR that ﬁts into 28 bytes.
Due to the simplicity and small size, such native code seems suﬃcient for
a ﬁrst obfuscation layer, yet the resulting encryption is far from being crypto-
graphically strong. For short keys up to 2 bytes the obfuscation can be trivially
broken using brute-force attacks. However, uncovering malware obfuscated with
longer keys, as for example the 4-byte key in Figure 1, still necessitates manually
reverse engineering the code or dynamically analyzing the malicious document
in a sandbox with vulnerable versions of the target application [e.g., 7, 17, 20].
While both approaches are eﬀective in removing the obfuscation layer, they re-
quire a considerable amount of time in practice and are thus not suitable for
analyzing and detecting embedded malware at end hosts.
In this paper, we present Kandi, a method capable of eﬃciently breaking
Vigen`ere-based obfuscations and automatically uncovering embedded malware
in documents without the need to parse the document’s ﬁle format. The method
leverages concepts from classic cryptography in order to conduct a probable-
plaintext attack against common variants of the Vigen`ere cipher. To this end,
the method ﬁrst approximates the length of possible keys and then computes
so-called diﬀerence streams of the document and plaintexts likely contained in
malware binaries. These plaintexts are automatically retrieved beforehand and
may include fragments of the PE header, library names and common code stubs.
Using these streams it is possible to look for the plaintexts directly in the ob-
fuscated data. If suﬃcient matches are identiﬁed, Kandi automatically derives
the obfuscation key and reveals the full embedded code for further analysis, for
example, by an anti-virus scanner or a human expert.
We demonstrate the eﬃcacy of this approach in an empirical evaluation with
documents of diﬀerent formats and real malware. In a controlled experiment
Kandi is able to break obfuscations using XOR and ADD/SUB with keys up
to 13 bytes. On a collection of real-world malware in Word, Powerpoint and
RTF documents with unknown obfuscation, Kandi is able to deobfuscate every
fourth document and exposes the contained malware binary, including several
00:
05:
07:
0e:
14:
1a:
be XX XX XX XX
31 db
81 34 1e XX XX XX XX
81 c3 04 00 00 00
81 fb XX XX XX XX
7c eb
mov
xor
start: xor
add
cmp
jl
edx, ADDRESS
ebx, ebx
dword [edx + ebx], KEY
ebx, 0x04
ebx, LENGTH
start
Fig. 1. Example of native code for a Vigen`ere-based obfuscation. The code snippet
deobfuscates data at ADDRESS of length LENGTH using the 4-byte key KEY. For simplicity
we omit common tricks to avoid null bytes in the code.
166
C. Wressnegger, F. Boldewin, and K. Rieck
samples of the recent attack campaign MiniDuke [6]. Moreover, Kandi is sig-
niﬁcantly faster than dynamic approaches and enables scanning documents and
deobfuscating malware at a throughput rate of 16.46 Mbit/s, corresponding to
5 documents of ∼400 kB per second.
It is necessary to note that Kandi targets only one of many possible obfus-
cation strategies. If a diﬀerent form of obfuscation is used or no plaintexts are
known in advance, the method obviously cannot uncover obfuscated data. We
discuss these limitations in Section 5 speciﬁcally. Nonetheless, Kandi defeats a
prevalent form of obfuscation in practice and thereby provides a valuable ex-
tension to current methods for the analysis of targeted attacks and embedded
malware in the wild.
The rest of this paper is organized as follows: Obfuscation using Vigen`ere
ciphers and classic cryptanalysis are reviewed in Section 2. Our method Kandi
is introduced in Section 3 and an empirical evaluation of its capabilities is pre-
sented in Section 4. We discuss limitations and related work in Section 5 and 6,
respectively. Section 7 concludes the paper.
2 Obfuscation and Cryptanalysis
The obfuscation of code can be achieved using various techniques, ranging from
simple encodings to strong ciphers and emulator-based packing. Implementations
of complex techniques, however, often contain characteristic patterns and thus
increase the risk of detection by anti-virus scanners [4]. As a consequence, simple
encodings and weak ciphers are still widely used for obfuscation despite their
shortcomings. In the following section we investigate a speciﬁc type of such
basic obfuscation, which is frequently used to hide malware in documents.
2.1 Vigen`ere-Based Obfuscation
The substitution of bytes using XOR and ADD/SUB—a variant of so-called
Vigen`ere ciphers [19]—is one of the simplest yet widely used obfuscation tech-
niques. These ciphers are regularly applied for cloaking shellcodes and embedded
malware. Figure 1 and 2 show examples of these ciphers in x86 code.
start:
mov
add
rol
mov
inc
cmp
jl
al, byte [edx]
al, ADD_KEY
al, ROL_KEY
byte [edx], al
edx
edx, LENGTH
start
start:
mov
sub
inc
and
inc
cmp
jl
al, byte [PTR + ebx]
byte [edx], al
ebx
ebx, 0x0f
edx
edx, LENGTH
start
(a) Obfuscation using ADD and ROL
(b) Obfuscation with 16-byte key
Fig. 2. Code snippets for Vigen`ere-based obfuscation: (a) Data stored at [edx] is
obfuscated using ADD and ROL, (b) Data stored at [edx] is obfuscated using SUB
with the 16-byte key at PTR.
Deobfuscating Embedded Malware Using Probable-Plaintext Attacks
167
Due to the implementation with only a few instructions, Vigen`ere-based ob-
fuscation keeps a small footprint in the code, thereby complicating the task of
extracting reliable signatures for anti-virus scanners. Additionally, this obfusca-
tion is fast, easily understandable and good enough to seemingly protect mali-
cious code in the ﬁrst layer of obfuscation. Despite these advantages Vigen`ere
ciphers suﬀer from several well-known weaknesses.
Deﬁnition of Vigen`ere Ciphers. Before presenting attacks against Vigen`ere-
based obfuscation, we ﬁrst need to introduce some notation and deﬁne the family
of Vigen`ere ciphers studied in this work. We consider the original code of a mal-
ware binary as a sequence of n bytes M1 . . . Mn and similarly represent the re-
sulting obfuscated data by C1 . . . Cn. When referring to cryptographic concepts,
we sometimes denote the original code as plaintext and refer to the obfuscated
data as ciphertext. The Vigen`ere-based obfuscation is controlled using a key
K1 . . . Kl of l bytes, where l usually is much smaller than n. Moreover, we use
ˆKi = K(i mod l) to access the individual bytes of the key.
Using this notation, we can deﬁne a family of Vigen`ere ciphers, where each
byte Mi is encrypted with the key byte ˆKi using the binary operation ◦ and
decrypted using its inverse operation ◦−1, as follows:
Ci = Mi ◦ ˆKi
and Mi = Ci ◦−1 ˆKi.
This simple deﬁnition covers several variants of the Vigen`ere cipher, as im-
plementations only diﬀer in the choice of the two operations ◦ and ◦−1. For
example, if we deﬁne ◦ as addition and ◦−1 as subtraction, we obtain the classic
form of the Vigen`ere cipher. Table 1 lists binary operations that are frequently
used for obfuscating malicious code. Note that a subtraction can be expressed
as an addition with a negative element and thus is handled likewise.
Table 1. Operators of Vigen`ere ciphers used for obfuscation
Decryption ◦−1
(X − Y ) mod 256
(X + Y ) mod 256
Encryption ◦
(X + Y ) mod 256
(X − Y ) mod 256
Operation
Addition (ADD)
Subtraction (SUB)
Exclusive-Or (XOR)
X ⊕ Y
X ⊕ Y
Theoretically, any pair of operations that is inverse to each other can be
used to construct a Vigen`ere cipher. In practice, most implementations build
on logic and arithmetic functions that induce a commutative group over bytes.
That is, the operation ◦ is commutative and associative as well as there exists an
identity element and inverse elements providing the operation ◦−1. These group
properties are crucial for diﬀerent types of eﬃcient attacks as we will see in
Sections 2.2 and 2.4. Note that ROL and ROR instructions are not commutative
and thus are treated diﬀerently in the implementation of our method Kandi
presented in Section 3.
168
C. Wressnegger, F. Boldewin, and K. Rieck
Another important observation is that some bytes are encrypted with the
same part of the key. In particular, this holds true for every pair of bytes Mi
and Mj whose distance is a multiple of the key length, that is, i ≡ j (mod l).
This repetition of the key is a critical weakness of Vigen`ere ciphers and can be
exploited to launch further attacks that we discuss in Sections 2.3 and 2.4.
With these few basic deﬁnitions in mind, we can pursue three fundamentally
diﬀerent approaches for attacking Vigen`ere ciphers: (1) brute-force attacks and
heuristics, (2) ciphertext-only attacks and (3) probable-plaintext attacks. In the
following, we discuss each of these attack types in detail and check whether they
are applicable for deobfuscating embedded malware.
2.2 Brute-Force Attacks and Heuristics
A straightforward way of approaching malware obfuscations is to brute-force
the key used by the malware author. There are two basic implementations for
such an attack: First, one encrypts all plaintext patterns that are assumed to
be present in the original binary with each and every key and tries to match
those. Second, one decrypts the binary or parts of it and looks for the presence
of the plaintext as a usual signature engine would do. In both cases a valid key
is derived if a certain amount of plaintexts match. For short keys, this approach
is both fast and eﬀective. In practice, brute-force attacks prove to be a valuable
tool for analyzing malware obfuscated using keys up to 2 bytes [3, 26].
Theoretically, an exhaustive search over the complete key space can be used
to also derive keys with more than 2 bytes. However, this obviously comes at
the price of runtime performance. For a key length of only 4 bytes there are
more than 4.2 billion combinations that need to be checked in the worst case.
This clearly exceeds the limits of what is possible in the scope of the deobfusca-
tion of embedded malware. Even worse, 4-byte and 8-byte keys ﬁt the registers of
common CPU architectures and therefore, do not require much diﬀerent deobfus-
cation routines. In fact, the underlying logic is identical to the use of single-byte
keys and the code size is only marginally larger as illustrated in Figure 1.
A more clever way of approaching the problem is by relying on the structure of
embedded malware binaries, which are often PE ﬁles. In this format \x00 bytes
are used as padding for sections and headers which gives rise to a heuristic.
We recall from Section 2.1 that the binary operation ◦ has an identity element,
which simply is 0 for XOR as well as ADD instructions. Therefore, whenever
a large block of \x00 bytes is encrypted, the key is revealed multiple times
and can be read oﬀ without extra eﬀort. Hence, once a highly repetitive string is
spotted in obfuscated data, deobfuscation is a simple task for a malware analyst.
According to our tests the very same technique is leveraged in a proprietary
system for the analysis of malware called Cryptam [16]. While eﬀective in many
cases when a full binary including padding is obfuscated, this heuristic fails when
a malware does not encrypt \x00 bytes. Furthermore, such an approach cannot
diﬀer between variants of Vigen`ere ciphers. Since XOR and ADD have the same
identity element, there is no way to decide which one was used for obfuscation
in this setting.
Deobfuscating Embedded Malware Using Probable-Plaintext Attacks
169
2.3 Ciphertext-Only Attacks
A more advanced type of classic attacks against Vigen`ere ciphers only makes
use of the ciphertext. Some of these attacks can be useful for determining the
length of the obfuscation key, whereas others even enable recovering the key if
certain conditions hold true in practice.
Index of Coincidence. A classic approach for determining the key length
from ciphertext only is the index of coincidence, commonly denoted as κ [9, 10].
Roughly speaking it represents the ratio of how many bytes happen to appear
at the same positions if you shift data against itself. Formally, the index of
coincidence is deﬁned as
(cid:2)
κ =
fi(fi − 1)
,
256
i=1
n(n − 1)
where fi are the byte frequencies in data of n bytes. Under the condition that
we know the index of some plaintext κp we are able to infer the key length l of
the Vigen`ere cipher. It is estimated as the ratio of the diﬀerences of κp to the
index of random data κr and the ciphertext κc:
l ≈ κp − κr
κc − κr
.
The Kasiski Examination. Another ciphertext-only attack for determining
the key length is the so-called Kasiski examination [12]. The underlying as-
sumption of this method is that the original plaintext contains some identical
substrings. Usually these patterns would be destroyed by the key; however, if two
instances of such substrings are encrypted with the same portion of the key, the
encrypted data contains a pair of identical substrings as well. This implies that
the distance between the characters of these substrings is a multiple of the key
length. Thus, by gathering identical substrings in the ciphertext, it is possible
to support an assumption about the key length.
Key Recovery Using Frequency Analysis. Natural languages tend to have
a very characteristic frequency distribution of letters. For instance, in the English
language the letter e is with more than 12% the signiﬁcantly most frequent letter
in the alphabet [14]. Only topped by the space character, which is used in written
texts in order to separate words.
This frequency distribution can be exploited to derive the key used for the
encryption. As one can easily imagine, the actual frequency distribution does
not change by simply replacing one character with another as in the case of a
key of length l = 1. The larger the key length gets, the more the distribution is
ﬂattened out because identical letters may be translated diﬀerently depending
on their position in the text. However, since it is possible to determine the length
of the key beforehand, one can perform the very same frequency analysis on all