title:Automatic Reverse Engineering of Malware Emulators
author:Monirul I. Sharif and
Andrea Lanzi and
Jonathon T. Giffin and
Wenke Lee
2009 30th IEEE Symposium on Security and Privacy
Automatic Reverse Engineering of Malware Emulators
Monirul Sharif Andrea Lanzi
Jonathon Gifﬁn Wenke Lee
School of Computer Science, Georgia Institute of Technology
{msharif, andrea, gifﬁn, wenke}@cc.gatech.edu
Abstract
Malware authors have recently begun using emulation
technology to obfuscate their code. They convert native
malware binaries into bytecode programs written in a ran-
domly generated instruction set and paired with a native
binary emulator that interprets the bytecode. No existing
malware analysis can reliably reverse this obfuscation tech-
nique. In this paper, we present the ﬁrst work in automatic
reverse engineering of malware emulators. Our algorithms
are based on dynamic analysis. We execute the emulated
malware in a protected environment and record the entire
x86 instruction trace generated by the emulator. We then
use dynamic data-ﬂow and taint analysis over the trace to
identify data buffers containing the bytecode program and
extract the syntactic and semantic information about the
bytecode instruction set. With these analysis outputs, we
are able to generate data structures, such as control-ﬂow
graphs, that provide the foundation for subsequent malware
analysis. We implemented a proof-of-concept system called
Rotalum´e and evaluated it using both legitimate programs
and malware emulated by VMProtect and Code Virtualizer.
The results show that Rotalum´e accurately reveals the syntax
and semantics of emulated instruction sets and reconstructs
execution paths of original programs from their bytecode
representations.
1. Introduction
Malware authors often attempt to defeat state-of-the-art
malware analysis with obfuscation techniques that are be-
coming increasingly sophisticated. Anti-analysis techniques
have moved from simple code encryption, polymorphism,
and metamorphism to multilayered encryption and page-by-
page unpacking. One new alarming trend is the incorporation
of emulation technology as a means to obfuscate malware
[23], [35]. With emulation techniques maturing, we believe
that the widespread use of emulation for malware obfusca-
tion is imminent.
Emulation is the general approach of running a program
written for one underlying hardware interface on another.
An obfuscator that utilizes emulation would convert a binary
program for a real instruction set architecture (ISA), such as
x86, to a bytecode program written for a randomly generated
virtual ISA and paired with an emulator that emulates this
1081-6011/09 $25.00 © 2009 IEEE
DOI 10.1109/SP.2009.27
94
ISA on the real machine. Figure 1 shows an example of this
obfuscation process. The obfuscator has complete freedom
to choose the semantics of the bytecode instructions, and
entities such as virtual registers and memory addresses
can be independent from the underlying real machine. For
example, the Java virtual machine executes on commodity
register machines but emulates a stack machine ISA. The
obfuscated program is the generated emulator together with
a data block containing bytecode. Code protection tools such
as Code Virtualizer [23] and VMProtect [35] are real-world
examples of this class of obfuscators.
Without knowledge of the source bytecode language,
many existing malware analysis schemes are crippled in the
face of malware obfuscated with emulation. At one end of
the spectrum, emulators completely defeat any pure static
analysis, including symbolic execution. The code analyzed
by static analyzers is that of the emulator; the true malware
logic is encoded as bytecode contained in some memory
buffer that is treated as data by the analysis. At the other
extreme, pure dynamic analysis based approaches that treat
the emulated malware as a black box and simply observe
external events are not affected. However, pure dynamic
analysis schemes cannot perform ﬁne-grained instruction
level analysis and can discover only a single execution path
of the malware. More advanced analysis techniques employ-
ing dynamic tainting, information ﬂow analysis, or other
instruction level analysis fall in the middle of the spectrum.
In the context of malware emulators, these techniques ana-
lyze the instructions and behaviors of the generic emulator
and not of the target malware. As an example, multi-path
exploration [21] may explore all possible execution paths of
the emulator. Unfortunately, these paths include all possible
bytecode instruction semantics and all possible bytecode
programs, rather than the paths encoded in the speciﬁc
bytecode program of the malware instance. In short, we need
new techniques to analyze emulated malware.
The key challenges in analyzing a malware emulator
are the syntactic and semantic gaps between the observ-
able (x86) instruction trace of the emulator and the non-
observable (interpreted) bytecode trace. Theoretically, pre-
cisely and completely identifying an emulator’s bytecode
language is undecidable. Practically, the manner in which
an emulator fetches, decodes, and executes a bytecode in-
struction may enable us to extract useful information about a
bytecode program. By analyzing a malware emulator’s (x86)
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:16:46 UTC from IEEE Xplore.  Restrictions apply. 
Figure 1. Using emulation for obfuscation
trace, we can identify portions of the malware’s bytecode
program along with syntactic and semantic information of
the bytecode language.
In this paper, we take the ﬁrst leap toward automatic
reverse engineering of unknown malware emulators. Our
goal is to extract the bytecode malware trace (program)
and the syntax and semantics of the bytecode instructions
to enable further malware analysis, such as multi-path ex-
ploration, across the bytecode program. We have developed
an approach based on dynamic analysis. We execute the
malware emulator and record the entire x86 instruction
trace generated by the malware. Applying dynamic data-
ﬂow and taint analysis techniques to these traces, we identify
data regions containing the bytecode program and extract
information about the bytecode instruction set. Our approach
identiﬁes the fundamental characteristic of decode-dispatch
emulation: an iterative main loop that fetches bytecode
based upon the current value of a virtual program counter,
decodes opcodes from within the bytecode, and dispatches to
bytecode handlers based upon opcodes. This analysis yields
the data region containing the bytecode, syntactic informa-
tion showing how bytecodes are parsed into opcodes and
operands, and semantic information about control transfer
instructions.
We have implemented a prototype called Rotalum´e that
uses a QEMU [6] based component to perform dynamic
analysis. The analysis generates both an instruction trace in
an intermediate representation (IR) and a dynamic control-
ﬂow graph (CFG) for ofﬂine analysis. Rotalum´e reverse
engineers the emulator using a collection of techniques:
abstract variable binding analyzes memory access patterns;
clustering ﬁnds associated memory reads, such as those
fetching bytecode during the emulator’s main loop; and
dynamic tainting identiﬁes the primary decode, dispatch, and
execute operations of the emulator. The output of our system
is the extracted syntax and semantics of the source bytecode
language suitable for subsequent analysis using traditional
malware analyses. We have evaluated Rotalum´e on legiti-
mate programs and on malware emulated by VMProtect and
Code Virtualizer. Our results show that Rotalum´e accurately
identiﬁed the bytecode buffers in the emulated malware and
reconstructed syntactic and semantic information for the
bytecode instructions.
The main contributions of our paper are:
• We formulate the research problem of automatic reverse
engineering of malware emulators. To the best of our
knowledge, this is the ﬁrst work in this area. Although
our current work assumes a decode-dispatch emulation
model, we believe that our ideas and techniques are
applicable to other emulation models: by analyzing
an emulator’s execution trace using a given emulation
model on how a bytecode instruction is fetched and
executed, we can identify the bytecode region and
discover the syntax and semantics of the bytecode
instructions.
• We develop a framework and working prototype system
that
includes: a novel method to identify candidate
memory regions containing bytecode, a method for
identifying dispatch and instruction execution blocks,
and a method for discovering bytecode instruction
syntax and semantics. The output of our system can be
used by existing analysis tools to analyze and extract
malware behavior; for example, the identiﬁed bytecode
can be converted to x86 instructions for static and/or
dynamic analysis.
• Although our work is in the context of malware, we
believe that this line of research will help spawn work
in several other areas. For example, similar techniques
may help reverse engineer script interpreters, providing
novel ways to analyze scripting languages with binary
analysis.
Section 2 provides a background of program emulation
techniques. Section 3 provides the details of our algorithms
that identify bytecode regions as well as bytecode syntax
and semantics. Section 4 describes our prototype system,
Rotalum´e. Section 5 reports results on evaluating Rotalum´e
on VMProtect and Code Virtualizer using both real-world
and synthetic malware programs. Section 6 discusses open
problems of reverse engineering malware emulators. Section
7 compares our work with other relevant research. Section
8 discusses future directions and concludes the paper.
2. Background
The term emulation generally expresses the support of
a binary instruction set architecture (ISA) that is different
from that provided by the computer system’s hardware.
This section describes the use of emulation in program
obfuscation and the various possible emulation techniques.
2.1. Using Emulation for Obfuscation
Code authors, including malware authors, are now using
emulation to obfuscate programs. In Figure 1, malicious
software M consists of a program Px86 written in native
x86 code and directly executable on x86 processors. Ana-
lyzers with knowledge of x86 can therefore perform various
95
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:16:46 UTC from IEEE Xplore.  Restrictions apply. 
x86.
analyses on the malware. In order to impede analysis, an
adversary can choose a new ISA L and translate Px86 to PL
that uses only instructions of L. In order to execute PL on
the real x86 machine, the adversary introduces an emulator
x86 that emulates the ISA L on x86. The adversary can
EM L
now spread a new malware instance M(cid:48) that is a combination
of PL and EM L
To further impede possible analysis, a malware author can
choose a new, randomly-generated bytecode language for
every instance of the malware and make tools to automati-
cally generate a corresponding emulator. Therefore, results
found about the bytecode language after reverse engineering
one instance of the emulator will not be useful for another
instance. Thus, automated reverse engineering of EM L
x86
is essential to malware analysis given that each malware
instance has a completely unknown bytecode instruction set
L and a previously unseen emulator instance.
2.2. Emulation Techniques
interfaces for high-level
Various emulation techniques are widely used in software-
based virtual machines, script interpretation, run-time ab-
stract
languages (e.g. Java vir-
tual machine (JVM)), and other environments. Although
these are very complex systems, they are all variations of
the simple-interpreter method, also known as the decode-
dispatch approach [31]. Decode-dispatch is used in envi-
ronments where performance overhead is not an issue. The
simple interpreter utilizes a main loop that iterates through
three phases for every bytecode instruction: opcode decode,
dispatch, and execute. The decode phase fetches the part
of an instruction (opcode) that represents the instruction
type. The dispatch phase uses this information to invoke
appropriate handling routines. The execute phase, which
is performed by the dispatched handling routine, performs
additional fetches of operands and executes the semantics
of the instruction. We ﬁrst provide an illustration of how a
decode-dispatch emulator works and then discuss the other
broad variations in emulation methods.
We show the design of the simple interpreter based
emulators using an illustrative running example. Figure 2
shows a fraction of a simple decode-dispatch based emu-
lator [11] written in a pseudo-C like language; it executes
programs written in a bytecode language for a hypothetical
machine. For conciseness, we describe only the aspects of
this machine relevant to the example. This machine supports
variable length instructions similar to x86. There are general
purpose registers named R1 to R24. A special register called
RF maintains a ﬂag that can be either 0 or 1 based on
some previously executed instruction, and it is used for
performing conditional jumps. We show three instructions
supported by the machine: ADD, JUMP and CJMP. While the
ADD instruction takes three operands, both jump instructions
take an immediate target address. The conditional
jump
instruction CJMP jumps to the target if RF is 1, otherwise
control ﬂows to the next instruction.
In this example, the emulator fetches instructions from
the emulated program stored in the buffer P. An emulator
maintains a run-time context of the emulated program,
which includes the necessary storage for virtual registers
and scratch space. The emulator maintains execution context
via a pointer to the next bytecode instruction to be executed,
which we denote throughout the paper as the virtual program
counter or VPC. For the example emulator, the VPC is an
index into the buffer P. Here, decoding is performed by
fetching the opcode from P[VPC], i.e. the ﬁrst byte of
the instruction. Dispatch uses a jump table resulting from
switch-case constructs in C. Three execution routines
for the three instructions are shown in the example. The
execADD routine updates the register store by adding
relevant virtual register values. The execJUMP routine
updates the VPC with an immediate address contained in the
instruction. Finally, execCJMP shows how the conditional
branch updates the VPC depending on the ﬂag RF. It is
interesting to note that
the branch is emulated without
using any conditional jump, but rather with a direct address
computation. This shows how an emulator provides a way to
remove identiﬁable conditional branches, making it hard for
analysis approaches such as multi-path exploration to even
explore any branch related to the emulated program.
More sophisticated emulation approaches often improve
efﬁciency. The threaded approach [16] improves perfor-
mance by removing the central decode-dispatch loop. The
decoding and dispatching logic is appended to the execution
semantics by adding a copy of that code to the end of
each execution routine. This removes several branches and
improves execution performance on processors that have
branch prediction. By using pre-decoding [19], the logic
of decoding instructions to their opcodes and operands
executes only once per unique instruction, and the pro-
gram subsequently reuses the decoded results. Hence, the
opcode decoding phase is not executed for each executed
bytecode instruction. The direct
threading approach [5]
removes jump table lookups by storing the function address
that executes the instruction semantics together with the
predecoded results. Therefore,
the dispatch of the next
instruction’s execution routine is an indirect control transfer
at the end of the previous bytecode instruction’s routine.
Finally, dynamic translation [30], one of the most efﬁcient
methods of emulation, converts blocks of the emulated
program into executable instructions for the target machine
and caches them for subsequent execution. These categories
of emulators maintain a VPC that is updated after blocks of
the translated native instructions are executed.
Dynamic translation based emulators have very complex
behavioral phases. They may seem attractive to malware
authors because of their analysis and reverse engineering
difﬁculty. However, like page-level unpacking used in some
96
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:16:46 UTC from IEEE Xplore.  Restrictions apply. 
Figure 2. An example of a simple-interpreter (decode-dispatch) based emulator
packers [29], dynamic translation reveals large blocks of
translated code as a program’s execution proceeds. This
approach reduces the advantage of using emulation as an
obfuscation because the heuristics used by automated un-
packers can capture the fact that new code was generated
and executed. In this paper, we focus our methods on
automatically reverse engineering the decode-dispatch class
of emulators.
Several challenges complicate automatic reverse engi-
neering of interpreter-based emulators. First, no informa-
tion of the bytecode program, such as its location, are
known beforehand. Second, no information regarding the
emulator’s code corresponding to the decode, dispatch, and
execution routines is known. Finally, we anticipate that
emulator code varies in terms of how it fetches opcodes
and operands, maintains context related to the emulated
program, dispatches code, executes semantics, and so on. An
adversary may even intentionally attempt to complicate the
identiﬁcation of bytecode by storing the bytecode program in
non-contiguous memory or use multiple correlated variables
to maintain the VPC.
Our current work, as a ﬁrst step, advances the state-of-
the-art and signiﬁcantly challenges attackers. It also lays
the foundation for reverse engineering of emulators that are
based on other (more advanced and efﬁcient) approaches.
3. Reverse Engineering of Emulation
In order to enable malware analysis of an emulated
malware instance, it is necessary to understand the unknown
bytecode language used by the instance. We have developed
algorithms to systematically and automatically extract the
syntax and semantics of unknown bytecode based upon
the execution behavior of the decode-dispatch based em-
ulator within a malware instance. Our approach identiﬁes
fundamental characteristics of decode-dispatch emulation:
an iterative main loop, bytecode fetches based upon the
current value of a virtual program counter, and dispatch to
bytecode handlers based upon opcodes within the bytecode.
This analysis yields the data region within the malware
97
containing the bytecode, syntactic information showing how