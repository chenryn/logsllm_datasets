**提升权限**
我们如何让以.NET编写的COM服务器进行任意反序列化？我们需要服务器尝试为通过COM暴露的可序列化.NET对象创建RCW。如果一般而言可以做到这一点的话是很好的，就是这么凑巧，在标准_Object接口上存在一个我们可以传递任何对象的函数，Equals方法。Equals的目的是比较两个对象的等同性。如果我们将.NET
COM对象传递给服务器的Equals方法，则运行时必须尝试将其转换为RCW，以便托管实现可以使用它。在这一点上，运行时需要有所帮助，并检查其是否真的是一个CCW包装的.NET对象。服务器运行时调用GetSerializedBuffer，导致服务器进程中的任意反序列化。
这是我第二次利用ClickOnce部署代理（导致CVE-2014-4073）。利用这一点的技巧是将序列化的Hashtable发送到包含IHashCodeProvider接口的COM实现的服务器。当Hashtable运行其自定义反序列化代码时，其需要重建其内部散列结构，其通过在每个密钥上调用IHashCodeProvider
::
GetHashCode来实现。通过添加一个可序列化的Delegate对象，作为其中一个密钥，我们将把它传递给客户端。通过以本地代码编写客户端，通过IManagedObject的自动序列化将不会在将委托传回给我们时发生。委托对象卡在服务器进程内，但CCW暴露给我们，我们可以调用。调用委托会导致在服务器上下文中执行指定的函数，这样我们能以服务器权限启动新进程。因为这一般都有效，所以我还编写了一个工具来为任何.NET
COM服务器完成此工作，请见[github](https://github.com/tyranid/ExploitDotNetDCOM/tree/master/ExploitDotNetDCOMSerializer)。
微软本可以通过更改IManagedObject ::
GetSerializedBuffer的行为来修复CVE-2014-4073，但是没有。相反，微软以本机代码重写了代理。还发布了一篇博客文章，警告开发人员[.NET
DCOM的危险](https://blogs.technet.microsoft.com/srd/2014/10/14/more-details-about-cve-2014-4073-elevation-of-privilege-vulnerability/)。然而，他们并没有弃用任何API以在.NET中注册DCOM对象，因此除非开发人员的安全意识极高，并且碰巧阅读了微软的安全博客，否则他们可能不会意识到这是一个问题。
这类bug到今天一直存在，比如，当我最近收到一个新的工作笔记本电脑时，我做了我通常会做的事情，枚举安装了什么OEM“增值”软件，看看是否有什么可以利用。结果表明，作为音频驱动程序包的一部分安装了由杜比编写的COM服务。经过几分钟的检查，基本上枚举COM服务器的可访问接口，我发现其是用.NET编写的（IManagedObject的存在总是一个大的赠品）。我启动了我的利用工具，在不到5分钟的时间内，实现了在本地系统中的代码执行。现在已作为CVE-2017-7293被修复。由于.NET
DCOM基本上不安全，杜比唯一可以做的是以本地代码重写服务。
**攻击Caller**
找到IManagedObject
bug类的一个新实例让我开始关注其其他影响。首先要强调的是，服务器本身并无漏洞，只有当我们能强制服务器充当回调攻击应用程序的DCOM客户端时，该漏洞才能被利用。通过托管COM互操作调用DCOM对象的任何.NET应用程序都应该有类似的问题，而不仅仅是服务器。DCOM可能有什么常见的用例，特别是在现代企业环境中？
我首先想到的是Windows Management Instrumentation（WMI）。现代版本的Windows可以使用WS-Management（WSMAN）协议连接到远程WMI实例，但由于遗留原因，WMI仍然支持DCOM传输。WMI的一个用例是扫描企业机器是否有恶意行为。这种复苏的原因之一是Powershell（在.NET中实现）具有易于使用的WMI支持。如果PS或者.NET尝试访问网络中受影响的工作站，那么或许PS或.NET本身容易受到此种攻击？
查看MSDN后可知，.NET通过[System.Management](https://msdn.microsoft.com/en-us/library/system.management\(v=vs.110\).aspx)命名空间支持WMI。这从.NET的开始就一直存在。其支持对WMI的远程访问，考虑到类的年代，其先于WSMAN，因此几乎可以肯定在后台使用DCOM。在PS前端，通过诸如[Get-WmiObject](https://technet.microsoft.com/en-us/library/ee176860.aspx)之类的cmdlet支持WMI。PS版本3（在Windows 8和Server
2008中引入）添加了一组新的cmdlet，包括[Get-CimInstance](https://technet.microsoft.com/en-us/itpro/powershell/windows/cimcmdlets/get-ciminstance)。阅读相关链接可知，引入CIM
cmdlet、支持WSMAN的原因显而易见，并且链接明确指出“旧”WMI cmdlet使用DCOM。
WMI cmdlets：
优点：相比WsMan Cmdlets提供更好的任务抽象，输出是一个.NET对象
缺点：使用非标准DCOM协议，不适用于非Windows
在这一点上，我们可以直接进入.NET和PS类库的RE，但有一个更简单的方法。通过观察到WMI服务器的DCOM
RPC流量，可能能够看到.NET客户端是否查询IManagedObject。Wireshark已经有一个DCOM解析器，为我们节省了很多麻烦。出于测试目的，我设置了两个虚拟机，一个是用Windows
Server 2016（作为域控制器），另一个是用Windows 10（作为域上的客户端）。然后我从客户端的域管理员发出一个简单的WMI PS命令‘Get-WmiObject Win32_Process -ComputerName dc.network.local’，
同时使用Wireshark监控网络。以下图片显示了我观察到的内容：
屏幕截图显示了来自PS客户端（192.168.56.102）的DC服务器上WMI
DCOM对象（192.168.56.50）的初始创建请求。我们可以看到其在查询IWbemLoginClientID接口，这是初始化过程的一部分（如[MS-WMI](https://msdn.microsoft.com/en-us/library/dd208060.aspx)中所述）。然后，客户端尝试请求其他几个接口;
尤其是其请求IManagedObject。这几乎肯定表明使用PS WMI cmdlet的客户端是有漏洞的。
为了测试这是否真的是一个漏洞，我们需要一个假的WMI服务器。似乎这是一个很大的挑战，但是我们需要做的就是修改winmgmt服务的注册，以指向我们的假实现。只要该服务随后用CLSID
{8BC3F05E-D86B-11D0-A075-00C04FB68820}注册一个COM类，COM启动器将启动服务，并为任何客户端提供我们的假WMI对象的实例。回顾我们的网络捕获，结果是对IManagedObject的查询没有发生在主类上，而是在从IWbemLevel1Login
::
NTLMLogin返回的IWbemServices对象上。但是没关系，其只是添加了一些额外的样板代码。为了确保其有效，我们将实现以下代码，其将告诉反序列化代码来查找一个名为Badgers的未知程序集。
如果我们成功注入序列化流，那么我们可以预期PS进程尝试查找Badgers.dll文件，并使用我们发现的Process Monitor。
**链接解串器**
当利用反序列化实现本地权限提升时，我们可以确保我们可以连接到服务器并运行任意代理。在RCE案例中我们没有这样的保证。如果WMI客户端启用了默认Windows防火墙规则，那么我们几乎肯定无法连接到委托对象所做的RPC端点。我们还需要被允许通过网络登录到运行WMI客户端的机器，我们的受攻击机器可能无法登录到域，或者企业策略可能会阻止除所有者外的任何人登录到客户端机器。
因此，我们需要一个稍微不同的计划，不是通过暴露一个新的委托对象来主动攻击客户端，相反，我们将给它传递一个字节流（反序列化时会执行所需的操作）。在理想的世界中，我们会发现一个可以为我们执行任意代码的可序列化类。可悲的是（据我所知）没有这样的类存在。因此，我们需要找到一系列“Gadget”类，这些类链接在一起可执行所需的效果。
所以在这种情况下，我倾向于编写一些快速分析工具，.NET支持相当不错的反射API，因此找到基本信息（比如一个类是否可序列化或一个类支持哪个接口）很容易做到。我们还需要一个要检查的程序集的列表，我知道的最快的方法是使用作为.NET
SDK一部分安装的gacutil实用程序（并随Visual Studio一起安装）。运行命令gacutil / l>
assemblies.txt来创建可以加载和处理的程序集名称列表。对于第一遍，我们将寻找可序列化且其中有委托的任何类，这些可能是执行操作时执行任意代码的类。使用我们的程序集列表，我们可以编写一些如下所示的简单代码来找到这些类，为每个程序集名称字符串调用FindSerializableTypes：
在我的系统中，该分析只产生了大约20个类，其中许多类实际上是在不分布在默认安装中的F＃库中。但一个类确实引起了我的注意——System.Collections.Generic.ComparisonComparer。您可以在[参考源](https://github.com/Microsoft/referencesource/blob/90b323fe52bec428fe4bd5f007e9ead6b265d553/mscorlib/system/collections/generic/comparer.cs#L157)中找到该实现，但其很简单，全貌如下：
这个类包装了一个Comparison委托——使用两个通用参数（相同类型），并返回一个整数，调用委托来实现[IComparer
](https://msdn.microsoft.com/en-us/library/8ehhxeaf%28v=vs.110%29.aspx)接口。虽然类是内部的，但其创建通过[Comparer::Create](https://msdn.microsoft.com/en-us/library/hh737198%28v=vs.110%29.aspx)静态方法暴露。这是链的第一部分，通过这个类和一些序列化代理的推拿，我们可以将[IComparer::Compare](https://msdn.microsoft.com/en-us/library/bb346115%28v=vs.110%29.aspx)链接到Process::Start，并获得创建的任意进程。现在我们需要链的下一部分，用任意的参数来调用该比较器对象。