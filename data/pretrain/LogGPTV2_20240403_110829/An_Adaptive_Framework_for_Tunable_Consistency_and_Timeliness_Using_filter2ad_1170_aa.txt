title:An Adaptive Framework for Tunable Consistency and Timeliness Using
Replication
author:Sudha Krishnamurthy and
William H. Sanders and
Michel Cukier
An Adaptive Framework for Tunable Consistency and Timeliness
Using Replication ∗
Sudha Krishnamurthy, William H. Sanders
Michel Cukier
Coordinated Science Laboratory,
Dept. of Computer Science, and
Dept. of Electrical & Computer Engineering
University of Illinois at Urbana-Champaign
Center for Reliability Engineering
Dept. of Materials & Nuclear Engineering
University of Maryland, College Park
E-mail: {krishnam,whs}@crhc.uiuc.edu, PI:EMAIL
Abstract
One of the well-known challenges in using replication to ser-
vice multiple clients concurrently is that of delivering a timely and
consistent response to the clients. In this paper, we address this
problem in the context of client applications that have speciﬁc tem-
poral and consistency requirements. These applications can toler-
ate a certain degree of relaxed consistency, in exchange for better
response time. We propose a ﬂexible QoS model that allows these
clients to specify their temporal and consistency constraints.
In
order to select replicas to serve these clients, we need to control
the inconsistency of the replicas, so that we have a large enough
pool of replicas with the appropriate state to meet a client’s timeli-
ness, consistency, and dependability requirements. We describe an
adaptive framework that uses lazy update propagation to control
the replica inconsistency and employs a probabilistic approach to
select replicas dynamically to service a client, based on its QoS
speciﬁcation. The probabilistic approach predicts the ability of a
replica to meet a client’s QoS speciﬁcation by using the perfor-
mance history collected by monitoring the replicas at runtime. We
conclude with experimental results based on our implementation.
1. Introduction
Replicating distributed services enables us to service mul-
tiple clients concurrently, and deliver good response times,
by selecting different replicas to service different clients.
However, since concurrency has the potential to introduce
replica inconsistency, one of the challenges in replicating
distributed services is the problem of supporting concur-
rent client operations while ensuring that the replicated state
does not diverge in an unacceptable manner. Traditional
replica consistency models provide a binary view of consis-
tency: strong consistency with immediate convergence, or
weak consistency with eventual convergence. Both of these
∗
0187.
This research has been supported by DARPA contract F30602-98-C-
consistency models have been studied extensively. In the
strong consistency model, concurrent operations on repli-
cated data are equivalent to a sequential execution on non-
replicated data. Pessimistic replication algorithms, such as
active and passive replication (e.g., [1, 11, 8, 12]), have tra-
ditionally been used to maintain strong consistency among
replicated data. Although these algorithms, which provide
single-copy semantics, ensure correctness for a wide class
of applications (e.g., banking transactions), the performance
overheads incurred in maintaining mutually consistent repli-
cas may be unreasonably high for clients that do not require
strong consistency. Further, strong consistency may not be a
viable option in environments in which some of the replicas
run on hosts and links that either are inherently slow, or tend
to become slow due to transient overloads and failures.
On the other hand, in the weak consistency model, op-
erations are performed on some subset of replicas, and the
updates are propagated to the other replicas either lazily or
on demand. Typically, the only guarantee provided to the
clients is that the replicated state will eventually converge,
if update activity ceases. Several optimistic replication al-
gorithms (e.g., [2, 9]) have been proposed for applications
that can tolerate relaxed consistency. These algorithms al-
low a client to access any replica in order to provide bet-
ter responsiveness, unlike the pessimistic algorithms, which
allow access to only those servers that have the most up-
to-date state. However, if the clients access different servers
before their states converge, the resulting inconsistency may
lead to conﬂicts.
In this work, our goal is to support applications that have
speciﬁc time constraints. These applications can relax their
consistency requirements in exchange for improving the prob-
ability that their response time constraints can be met. How-
ever, in order for the response to be meaningful, they need
some bounds on the inconsistency in the response they re-
ceive. Examples of applications that beneﬁt from relaxed
but bounded inconsistency in exchange for timeliness in-
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:10:23 UTC from IEEE Xplore.  Restrictions apply. 
clude real-time database applications, such as online stock-
trading and trafﬁc-monitoring applications. In order to sup-
port such applications that have speciﬁc temporal and con-
sistency requirements effectively, we use an approach that
allows the users to express their timeliness and consistency
requirements as a quality-of-service (QoS) speciﬁcation. To
study the trade-offs between timeliness and consistency, we
propose an adaptive middleware framework that allows us
to explore the intermediate space between the above binary
views of consistency. We have implemented this framework
in AQuA, a CORBA-based middleware that supports trans-
parent replication of objects across a LAN [11].
We now list the main contributions of this paper. In Sec-
tion 2, we propose a QoS model that allows a broad spec-
trum of applications to express their timeliness and consis-
tency requirements.
In Section 3 we describe our frame-
work that allows us to build protocols for providing differ-
ent consistency guarantees. These protocols use a combi-
nation of immediate and lazy update propagation to ensure
that the states of the replicas do not diverge in an unac-
ceptable manner. As a proof-of-concept, in Section 4, we
describe the protocol we have implemented to maintain se-
quential consistency among the replicas. In Section 5 we
describe a probabilistic approach that allows a middleware
to dynamically select replicas to service the clients based
on the QoS speciﬁcation of the clients. Similar to the work
we presented in [5], this approach uses the performance his-
tory of replicas obtained by online performance monitoring
to predict a replica’s ability to meet a client’s QoS speci-
ﬁcation. However, while our previous work assumed that
the replicas were stateless, our current model addresses this
selection problem in the context of replicas with state. In
Section 6, we present a few experimental results based on
our implementation.
2. QoS Model for Timeliness and Consistency
Several other researchers have extended traditional con-
sistency models by incorporating the notion of time in order
to bound the degree of inconsistency. For example, the no-
tion of epsilon-serializability (deﬁned in [10]), and timed
consistency models (deﬁned in [13, 6]), require that if a
write is executed at time t, then the effect of the write should
be visible to others by t + x, where x is the maximum ac-
ceptable delay for propagating the effect of the write. The
TACT middleware [15] is another related work that attempts
to provide a middleware framework for tunable consistency
and availability. The consistency measures used by TACT
to bound the level of inconsistency include the order er-
ror, which limits the number of tentative writes that can
be outstanding at any replica; the numerical error, which
bounds the difference between the value delivered to the
client and the most consistent value; and staleness, which
places a real-time bound on the delay of propagating the
writes among the replicas. However, while these models
provide a way to quantify consistency, they do not address
the problem of tuning consistency requirements in the pres-
ence of speciﬁc transaction deadlines or response time con-
straints. We now describe our QoS model that allows the
clients to express their consistency and response time re-
quirements.
Our request model enables a middleware to distinguish
invocations that modify the state of the object they invoke
from those that merely retrieve the state. To do this, a client
application has to explicitly specify all the read-only meth-
ods it invokes on an object by their names. If an operation
is not speciﬁed as read-only, then our middleware considers
it to be an update operation. An update operation is any in-
vocation that modiﬁes the state of the object on which the
operation is performed, and may be either a write-only op-
eration or a read-write operation.
Our QoS model regards consistency as a two-dimensional
attribute: . The
ordering guarantee is a service-speciﬁc attribute that de-
notes the guarantee provided by a service to all of its clients
about the order in which their requests will be processed by
the servers, so as to prevent conﬂicts between operations.
Some well-known ordering guarantees that a service can of-
fer are sequential (or total), causal, and FIFO [1]. In this
paper, we target services that provide sequential ordering
guarantees.
The staleness threshold, which is speciﬁed by the client,
is a measure of the maximum degree of staleness a client is
willing to tolerate in the response it receives. In our frame-
work, the staleness of a response denotes the staleness of
the state of the replica that sent the response. We compute
the staleness of a replica by associating a timestamp with
each update operation. We use timestamps based on “logical
clocks” [7] because this obviates the need for synchronized
clocks across the distributed replicas. These logical times-
tamps make it possible to specify the staleness in terms of
“versions.” A replica whose staleness is x has a state that
has not yet been updated to reﬂect the modiﬁcations en-
suing from the most recent x updates. The replica’s state,
however, reﬂects the modiﬁcations of all updates committed
prior to that. In order to meet a client’s QoS speciﬁcation, a
response delivered to the client should be no more stale than
the staleness threshold speciﬁed by the client.
The timeliness speciﬁcation includes a pair of attributes:
. This pair
speciﬁes the time by which a client expects a response after
it has transmitted its request, and the probability with which
it expects its temporal constraint to be met. Failure to meet
a client’s deadline results in a timing failure for the client.
In our QoS model, the timeliness attribute is applicable only
for read-only requests and not for update operations.
As an example of the use of the above QoS model, con-
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:10:23 UTC from IEEE Xplore.  Restrictions apply. 
QoSGroup
Service S
Primary Replication Group
Leader
Service S
Secondary Replication Group
Client1                     Client2                     
Client3                    
Figure 1. Replica organization
sider a document-sharing application in which multiple read-
ers and writers concurrently access a document that is up-
dated in sequential mode. Using the above model, a client
of such an application can specify that he wishes to obtain
a copy of the document that is not more than 5 versions old
within 2.0 seconds with a probability of at least 0.7.
3. Framework for Tunable Consistency
Given the above QoS model, our goal is to build a frame-
work that can be tuned to support the different application-
speciﬁc requirements at the middleware layer. In order to
design this framework, we address three main issues: 1) or-
ganization of the replicas, 2) development of the protocols
that implement different consistency semantics and design
of an infrastructure that would allow these protocols to be
used on demand, and 3) development of a mechanism to
select replicas dynamically to service a client based on the
client’s QoS requirements. We now describe the approach
we have used to address these issues in the context of AQuA.
All the replicas offering the same service are organized
into two groups: a primary replication group and a sec-
ondary replication group, as shown in Figure 1. We also
have a QoS group, which encompasses all of the replicas of a
service and their clients. In our implementation, all of these
groups are derived from Maestro groups [14], and members
of a group communicate with each other by making use of
the Maestro-Ensemble group communication protocol [3].
For each group, Ensemble elects one of the members of the
group as the leader. However, only the leader of the pri-
mary group is relevant to this work. We depend on Maestro-
Ensemble to provide reliable, virtual synchrony, and FIFO
messaging guarantees, and we build upon these guarantees
to provide the different end-to-end consistency guarantees.
We also depend on Maestro-Ensemble to inform the group
members when changes in the group membership occur.
The primary group is used to implement strong consis-
tency semantics, whereas the secondary group implements
weaker consistency semantics. The size of these groups can
be tuned to implement a range of consistency semantics.
The above two-level replica organization was motivated by
the need to favor the operations that can tolerate relaxed
consistency to a certain degree in exchange for a timely re-
sponse. We reduce the overheads incurred by a write-all
scheme, such as an active replication scheme, by perform-
ing the updates on the smaller primary group, while allow-
ing the secondary replicas, which are greater in number, to
handle the read-only operations. The primary replicas sub-
sequently bring the state of the secondary replicas up-to-date
using lazy update propagation. The degree of divergence
between the states of primary and secondary replicas can be
bounded by choosing an appropriate frequency for the lazy
update propagation. Thus, while clients that need the most
up-to-date state to be reﬂected in their response may have to
depend more on the response from a primary replica, clients
that are willing to tolerate a certain degree of staleness in
their response can achieve better response times, due to the
higher availability of the secondary replicas.
4. Tunable Consistency Protocols
In Section 2, we mentioned that to maintain replica con-
sistency, the replicas should serve their clients by respect-
ing the ordering guarantee associated with the service. Our
framework allows different ordering guarantees to be im-
plemented as timed consistency handlers in the AQuA gate-
way, as shown in Figure 2. A client can communicate with
a replicated service by using the gateway handler appropri-
ate for the service. For example, Figure 2 shows a client
communicating with two different services. Service A is
an example of an application, such as a document-editing
application, that guarantees sequential consistency using to-
tal ordering. Service B represents an application, such as
a banking transaction, that guarantees FIFO ordering. The
client uses the sequential consistency handler to communi-
cate with service A, while it uses the FIFO handler to com-
municate with service B. In this paper, we will describe the
sequential consistency handler we have implemented in the
AQuA middleware. The protocol processing in the handler
is divided into a client-side protocol and a server-side proto-
col. In this section we will describe the processing involved
on the server side in order to maintain sequential consistency
across the two groups of replicas, and in the next section we
will describe how the client-side protocol uses these replicas
to meet the client’s QoS speciﬁcation.
4.1. Sequential Consistency Protocol
In our sequential consistency model, the update requests
of the clients are executed by all of the primary replicas in
the same order. The secondary replicas do not directly ser-
vice a client’s update request. Instead, the secondary repli-
cas update their state when one of the members of the pri-
mary group lazily propagates its updated state to the sec-
ondary group. We call this member the lazy publisher. Thus,
although the replicas may update their state at different points
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:10:23 UTC from IEEE Xplore.  Restrictions apply. 
Gateway Handlers
Server A
S
Client
Server B
S
TOTAL
W
TOTAL
FIFO
Server  Gateway
Gateway
Maestro/Ensemble
Maestro/Ensemble
LAN
Maestro/Ensemble
G
FIFO
W