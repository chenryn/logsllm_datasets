increases to 181.7 s for [31] (173 Âµs amortized) and 92.1 s for [33]
(87.8 Âµs amortized).
Our Z2ğ‘˜ Zero-Knowledge proofs achieve amortized communication
costs of ğ‘˜ + ğ‘  bits and consume one VOLE to open a commitment
(where ğ‘  is a statistical security parameter and ğ‘˜ + ğ‘  bits are nec-
essary to represent committed ring element), and 2ğ‘˜ + 4ğ‘  bits plus
three VOLEs, to verify a multiplication. This is competitive with
state-of-the-art protocols for large fields such as [4, 31], which need
to transfer 2â€“3 field elements .
1.2 Related Work
Our work builds upon concretely efficient zero-knowledge proto-
cols from VOLE, which were first given in [4, 15, 31]. While [4, 31]
use VOLE-based information-theoretic MACs in a black-box way,
Line-Point ZK [15] takes a non-black-box approach, which reduces
communication to just 1 field element per multiplication in a large
field. More recently, Quicksilver [33] extends this to arbitrary fields,
including boolean circuits. Since the core of our protocol uses po-
tentially faulty information to verify edaBits, the techniques from
QuickSilver could be plugged in to cheaply verify these faulty com-
ponents, which would simplify much of our security analysis and
slightly reduce costs. We analyze this approach in Section 6. This
is very similar to the approach taken in the concurrent work Mys-
tique [32], which uses Quicksilver directly for conversions. Since
QuickSilver and Mystique make non-black-box use of VOLE-based
MACs, these would not be applicable in settings based on other
types of homomorphic commitments, or applications such as proofs
of disjunctions in [4], which assumes a black-box commitment
scheme. Thus, while our protocol has higher communication costs,
it is more general and may be of use in a wider range of applications.
Another related work is Rabbit [26], which provided improved
protocols for secure comparison and truncation based on edaBits,
in the MPC setting. Similarly to our work in ZK, Rabbit allows to
avoid the large â€œgapâ€ between the field size and the desired message
space when running these protocols; however, our techniques in
the ZK setting are different.
In LegoSNARK [10] the authors show how to combine different
succinct ZK proof systems. Our work differs as we focus on the
setting where data is represented in different rings of possibly
constant size for each subtask, whereas [10] relies on large groups.
2 PRELIMINARIES
In this section we introduce several primitives which are used
throughout the constructions in this paper.
2.1 Notation
We use ğ‘€ to denote a modulus which is either a large prime ğ‘,
or 2ğ‘˜. As a short hand, â‰¡ğ‘˜ denotes equality modulo 2ğ‘˜. We use
[ğ‘¥]ğ‘€ or [ğ‘¥]2 to denote authenticated values (see Sections 2.3 and
2.4) from the plaintext space Zğ‘€ or Z2, and write just [ğ‘¥] when
the modulus is clear from the context. We let ğ‘  denote a statistical
security parameter and [ğ‘›] denote the set {1, . . . , ğ‘›}.
2.2 Zero-Knowledge Proofs
Zero-knowledge proofs (of knowledge) are interactive two-party
protocols that allow the prover P to convince a verifier V that a
certain statement is true (and that it possesses a witness to this
fact). This happens in a way such that V does not learn anything
else besides this fact that it could not compute by itself. Instead of
using the classical definition by Goldwasser et al. [19], we define
zero-knowledge using an ideal functionality FZK for satisfiability
of circuits C: On input (Prove, C, ğ‘¤) from P and (Prove, C) from
V the functionality FZK outputs âŠ¤ to V iff. C(ğ‘¤) = 1 holds, and
sends âŠ¥ otherwise [31].
Following previous works (e.g. [4, 31]), we use the commit-and-
prove strategy to instantiate FZK using homomorphic commitments
(see Section 2.4). These allow the prover P to commit to its witness
ğ‘¤. Then the circuit C can be evaluated on the committed witness
to obtain a commitment to the output, which is opened to prove
that indeed C(ğ‘¤) = 1 holds.
2.3 VOLE and Linearly Homomorphic MACs
Oblivious transfer (OT) [17] is a two-party protocol, where the re-
ceiver can obliviously inputs a bit ğ‘ to choose between two messages
ğ‘š0, ğ‘š1 held by the sender to obtain ğ‘šğ‘. In correlated OT (COT) [2]
the messages are chosen randomly given a sender-specified corre-
lation function, e.g. ğ‘¥ â†¦â†’ ğ‘¥ + ğ›¿ such that ğ‘š1 = ğ‘š0 + ğ›¿ holds over
some domain. Thus, the receiver obtains ğ‘šğ‘ = ğ›¿ Â· ğ‘ + ğ‘š0.
While OT inherently requires relatively costly public key cryp-
tography [22], OT extension [23] allows to expand a small number
of regularly computed OTs into a large number of OTs using only
relatively cheap symmetric key cryptography.
Oblivious linear-function evaluation (OLE) [24, 27] is an arith-
metic generalization of COT allowing a receiver to evaluate a secret
linear equation ğ›¼ Â· ğ‘‹ + ğ›½ (over a field Fğ‘ or ring Z2ğ‘˜ ) held by the
Session 1C: Zero Knowledge I CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea194sender at a point of its choice ğ‘¥ to obtain ğ‘¦ = ğ›¼ Â· ğ‘¥ + ğ›½. This can
be extended into vector OLE (VOLE) [1] where ğ‘¥ and ğ›½ are vec-
tors of the same length rather than single field elements. Subfield
VOLEs [9] extends this concept such that the elements of ğ›¼ and ğ›½
live in an extension field Fğ‘ğ‘Ÿ âŠƒ Fğ‘. Random (subfield) VOLE, where
inputs are chosen randomly by the functionality, is easier to realize
and can be used to instantiate normal VOLE, by sending correction
values.
We use information-theoretic message authentication codes (MACs)
to authenticate values in finite fields Zğ‘ and rings Z2ğ‘˜ . The case
Z2ğ‘˜ is discussed in Section 5.2 where we adapt the work of [12] to
the zero-knowledge setting. For fields Zğ‘, we use BeDOZa-style
MACs [6] which can be generated as follows: To authenticate values
ğ‘¥1, . . . , ğ‘¥ğ‘› âˆˆ Zğ‘ known to P, random keys Î”, ğ¾[ğ‘¥1], . . . , ğ¾[ğ‘¥ğ‘›] âˆˆğ‘…
Zğ‘ are chosen by V, and then P obtains the MACs ğ‘€[ğ‘¥ğ‘–] â†
Î” Â· ğ‘¥ğ‘– + ğ¾[ğ‘¥ğ‘–] âˆˆ Zğ‘. We use the notation [ğ‘¥ğ‘–]ğ‘ for this. To open
[ğ‘¥]ğ‘, P sends ğ‘¥ and ğ‘€[ğ‘¥] toV, who checks that ğ‘€[ğ‘¥] = Î”Â·ğ‘¥+ğ¾[ğ‘¥]
holds. These authentications are linearly homomorphic: Given au-
thenticated values [ğ‘¥]ğ‘ and [ğ‘¦]ğ‘ and public values ğ‘, ğ‘, P and
V can locally compute [ğ‘§]ğ‘ for ğ‘§ := ğ‘ Â· ğ‘¥ + ğ‘¦ + ğ‘ by setting
ğ‘€[ğ‘§] := ğ‘ Â· ğ‘€[ğ‘¥] + ğ‘€[ğ‘¦] and ğ¾[ğ‘§] := ğ‘ Â· ğ¾[ğ‘¥] + ğ¾[ğ‘¦] âˆ’ Î” Â· ğ‘.
For large enough ğ‘, this is secure since forgery would imply cor-
rectly guessing a random element of Zğ‘. For smaller ğ‘, the keys Î”
and ğ¾[ğ‘¥ğ‘–] are instead chosen from an extension field Zğ‘ğ‘Ÿ such that
ğ‘ğ‘Ÿ is large enough. The MACs can be efficiently computed with
(subfield) VOLE [4, 31].
2.4 Homomorphic Commitment Functionality
As discussed in Section 2.2, we use the commit-and-prove paradigm
for our zero-knowledge protocols. To this end, we define a com-
mitment functionality. It allows the prover P to commit to values,
and choose to reveal them at a later point in time, such that the
verifier V is convinced that the values had not been modified in the
meantime. Moreover, the functionality allows to perform certain
operations of the underlying algebraic structure on the committed
values, and to check if these satisfy certain relations.
The commitment functionality can be instantiated using linearly
homomorphic information-theoretic MACs (see Section 2.3). For
finite fields Zğ‘, this was shown with the protocols Wolverine [31]
and Macâ€™nâ€™Cheese [4]. We refer to their works for details. For rings
Z2ğ‘˜ , we present an instantiation in Section 5.2.
We formally define the homomorphic commitments using the
ideal functionality F ğ‘…
given in Appendix A, Figure 15. The
parameter ğ‘… denotes the message space, which is in our case either
a ring Z2ğ‘˜ or a field Zğ‘. In addition to the common Input and Open
operations, which enables P to commit to a value and reveal it to V
at a later point, we also model Random and CheckZero, for generat-
ing commitments of random values and verifying that a committed
value equals zero, respectively, which enables more efficient imple-
mentations. Moreover, F ğ‘…
allows via Affine to compute affine
combinations of committed values with public coefficients yielding
again a commitment of the result. Finally, CheckMult allows to ver-
ify that a set of committed triples satisfy a multiplicative relation,
i.e. for each triple, the third commitment contains the product of
the first two committed values.
ComZK
ComZK
Since the commitment functionality is based on information-
theoretic MACs, we use the same notation [ğ‘¥] to denote a com-
mitted value ğ‘¥ âˆˆ ğ‘…. We use this shorthand to to simplify the pre-
sentation of higher-level protocols without explicitly mentioning
the commitment identifiers. We use also shorthands for the dif-
ferent methods of F ğ‘…
, e.g. we write something like [ğ‘§] â†
ğ‘ Â· [ğ‘¥] + [ğ‘¦] + ğ‘ when invoking the Affine method. We write [ğ‘¥]ğ‘€,
if the domain Zğ‘€ of the committed values is not clear from the
context, or if we have to distinguish commitments over multiple
different domains.
ComZK
2.5 Extended Doubly-Authenticated Bits
A doubly-authenticated bit (or daBit for short) is a bit ğ‘ that is
authenticated in both a binary and arithmetic domain, i.e. a tuple
([ğ‘]2, [ğ‘]ğ‘€). daBits can be used to convert a single bit from the
binary to the arithmetic domain or vice versa [26, 28].
Their generalization, called edaBits (due to Escudero et al. [16]),
is defined as ğ‘š bits ğ‘0, . . . , ğ‘ğ‘šâˆ’1 which are each authenticated in the
binary domain while their sum is authenticated in the arithmetic
one, i.e. ([ğ‘0]2, . . . , [ğ‘ğ‘šâˆ’1]2, [ğ‘]ğ‘€), for some ğ‘š â‰¤ âŒˆlog ğ‘€âŒ‰. These
edaBits allow for optimized conversions of authenticated values,
and allow to securely compute truncations or extract the most
significant bit of a secret value in MPC.
We now quickly recap their edaBits generation protocol (origi-
nally defined in the multi-party computation context) as we build
upon their construction later. The construction of [16] consists of
two different phases: in the first phase, each party locally samples
edaBits and proves to all other parties that they were computed
correctly. Then, in a second phase, these local contributions are
combined to global, secret edaBits. In our setting however, only
the prover will use edaBits, thus it is clear that the second phase
can be omitted. Our sampling protocol will only have to ensure
that each edaBit ([ğ‘¥0]2, . . . , [ğ‘¥ğ‘šâˆ’1]2, [ğ‘¥]ğ‘€) is indeed consistent,
The first phase of the edaBit sampling routine of [16] then
works as follows (when adapted to the zero-knowledge setting):
i.e. that ğ‘¥ =ğ‘šâˆ’1
ğ‘–=0 ğ‘¥ğ‘–2ğ‘– mod ğ‘€.
ues ğ‘Ÿ ğ‘— â†ğ‘šâˆ’1
(1) The prover locally samples (ğ‘ ğµ +ğ¶)ğ‘š bits ğ‘Ÿğ‘–,ğ‘— for ğ‘— âˆˆ [ğ‘ ğµ +ğ¶]
and ğ‘– âˆˆ {0, . . . , ğ‘šâˆ’1}. It then combines these into the ğ‘ ğµ+ğ¶ val-
ğ‘–=0 , ğ‘Ÿ ğ‘—} ğ‘— âˆˆ[ğ‘ ğµ+ğ¶].
(2) The prover then commits to the binary values ğ‘Ÿğ‘–,ğ‘— over Z2 and
ğ‘–=0 2ğ‘–ğ‘Ÿğ‘–,ğ‘— yielding edaBits {(ğ‘Ÿğ‘–,ğ‘—)ğ‘šâˆ’1
to the combined values ğ‘Ÿ ğ‘— over Zğ‘€.
(3) The prover and verifier engage in a check that ensures that
the committed values of the prover are consistent. For this, the
prover first opens ğ¶ of the ğ‘ ğµ + ğ¶ committed tuples to show
consistency (where the choice is made by the verifier). Then the
ğ‘ ğµ edaBits are distributed into ğ‘ buckets of size ğµ. ğµ âˆ’ 1 of
the edaBits are then used to verify that the remaining edaBit
per bucket is consistent without leaking information about it.
(4) If the check passes, then the remaining edaBit in each of the
ğ‘ buckets is known to be consistent.
The main challenge in this protocol is the bucket check in the
penultimate step; [16] show that certain consistency checks can be
performed in an unreliable manner, while still being hard to cheat
overall, which leads to a complicated analysis.
Session 1C: Zero Knowledge I CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1953 CONVERSIONS BETWEEN Z2 AND Zğ‘€
In this section we present our protocol for performing proofs of
consistent conversions in mixed arithmetic-binary circuits that will
work with any such ZK protocol as described in the preliminaries.
3.1 Conversions and edaBits in ZK
In secure multi-party computation, edaBits are used to compute a
conversion of a value [ğ‘¥]ğ‘€ that is secret-shared among multiple
parties. In the zero-knowledge setting, the prover knows the under-
lying value ğ‘¥, so there is no need to convert [ğ‘¥]ğ‘€ securely into its
bit decomposition ([ğ‘¥0]2, . . . , [ğ‘¥ğ‘šâˆ’1]2) online. Instead, the prover
can commit to ([ğ‘¥0]2, . . . , [ğ‘¥ğ‘šâˆ’1]2, [ğ‘¥]ğ‘€) in advance, which would
itself form a valid edaBit if the conversion is correct. We call the
inputs and outputs of conversion operations conversion tuples.
Definition 3.1 (Conversion Tuple). Let ğ‘€ âˆˆ N+, ğ‘š â‰¤ âŒˆlog2(ğ‘€)âŒ‰,
ğ‘¥ âˆˆ Zğ‘€ and ğ‘¥ğ‘– âˆˆ Z2. Then the tuple ([ğ‘¥0]2, . . . , [ğ‘¥ğ‘šâˆ’1]2, [ğ‘¥]ğ‘€) is
called a conversion tuple. We call ([ğ‘¥0]2, . . . , [ğ‘¥ğ‘šâˆ’1]2, [ğ‘¥]ğ‘€) consis-
tent iff ğ‘¥ =ğ‘šâˆ’1
ğ‘–=0 2ğ‘–ğ‘¥ğ‘– mod ğ‘€.
Our conversion protocol in this section provides an efficient way
to verify that a large batch of conversion tuples are consistent, i.e.
that the committed values are indeed valid edaBits. We note that
an alternative approach would be to directly apply the method
of [16] â€” here, first a set of random, verified conversion tuples is
created, and then one of these is used to check the actual conversion
tuple in an online phase. Unfortunately, this online phase check
itself involves verifying a binary circuit for addition mod ğ‘€, which
introduces additional expense. We therefore design a new protocol
to avoid this, with further optimizations.
Our protocols perform conversions on committed values in Z2
and Zğ‘€, where we recall that ğ‘€ is either a large prime or 2ğ‘˜. We
model these commitments using the functionality F 2,ğ‘€
in Fig-
ComZK
ure 16in Appendix A, which extends two instances of F ğ‘…
for
ğ‘… = Z2 and ğ‘… = Zğ‘€ and simply parses all method calls to the
respective instance.
Finally, we define the ideal functionality for verifying conver-
sions FConv in Figure 1. This functionality extends F 2,ğ‘€
with a
single method VerifyConv. It essentially checks whether or not the
two representations of some hidden value are consistent.
ComZK
ComZK
3.2 The Conversion Verification Protocol Î Conv
The following protocol Î Conv verifies the correctness of a batch of
ğ‘ conversion tuples. Î Conv uses FDabit (Figure 2) to verify correct-
ness of daBits (recall, a daBit is an edaBit of length 1), which is
needed in one stage of the protocol. Later, we show how to remove
most of the daBit check to improve efficiency.
Î Conv also uses multiplication triples, namely, random values
[ğ‘¥]2, [ğ‘¦]2, [ğ‘§]2 where ğ‘§ = ğ‘¥ Â·ğ‘¦; one multiplication triple can then be
used to verify a multiplication on committed inputs at a cost of two
openings in Z2, using a standard technique. In our case, however,
we allow the prover to choose all the triples, without verifying their
consistency.
, thus con-
ğ‘–
ComZK
for all ğ‘— âˆˆ [ğ‘] then output