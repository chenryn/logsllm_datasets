## 如何给亚洲球队做聚类对于机器来说需要数据才能判断类中心点，所以我整理了 2015-2019年亚洲球队的排名，如下表所示。我来说明一下数据概况。其中 2019 年国际足联的世界排名，2015 年亚洲杯排名均为实际排名。2018年世界杯中，很多球队没有进入到决赛圈，所以只有进入到决赛圈的球队才有实际的排名。如果是亚洲区预选赛12 强的球队，排名会设置为 40。如果没有进入亚洲区预选赛 12强，球队排名会设置为 50。![](Images/b07ddfe566c5a536b699524438d00724.png){savepage-src="https://static001.geekbang.org/resource/image/d8/4a/d8ac2a98aa728d64f919bac088ed574a.png"}\针对上面的排名，我们首先需要做的是数据规范化。你可以把这些值划分到\[0,1\] 或者按照均值为 0，方差为 1的正态分布进行规范化。具体数据规范化的步骤可以看下 13篇，也就是[数据变换](https://time.geekbang.org/column/article/77059)那一篇。我先把数值都规范化到 \[0,1\] 的空间中，得到了以下的数值表：![](Images/82fb65bf1e35ef57a87d3536b176c374.png){savepage-src="https://static001.geekbang.org/resource/image/a7/17/a722eeab035fb13751a6dc5c0530ed17.png"}\如果我们随机选取中国、日本、韩国为三个类的中心点，我们就需要看下这些球队到中心点的距离。距离有多种计算的方式，有关距离的计算我在 KNN 算法中也讲到过：-   欧氏距离-   曼哈顿距离-   切比雪夫距离-   余弦距离欧氏距离是最常用的距离计算方式，这里我选择欧氏距离作为距离的标准，计算每个队伍分别到中国、日本、韩国的距离，然后根据距离远近来划分。我们看到大部分的队，会和中国队聚类到一起。这里我整理了距离的计算过程，比如中国和中国的欧氏距离为0，中国和日本的欧式距离为 0.732003。如果按照中国、日本、韩国为 3个分类的中心点，欧氏距离的计算结果如下表所示：![](Images/d7e764e2c09c372f70fc0c72283daa15.png){savepage-src="https://static001.geekbang.org/resource/image/b6/e9/b603ccdb93420c8455aea7278efaece9.png"}\然后我们再重新计算这三个类的中心点，如何计算呢？最简单的方式就是取平均值，然后根据新的中心点按照距离远近重新分配球队的分类，再根据球队的分类更新中心点的位置。计算过程这里不展开，最后一直迭代（重复上述的计算过程：计算中心点和划分分类）到分类不再发生变化，可以得到以下的分类结果：![](Images/a205c76448ff96bc17e3836a509bfd4b.png){savepage-src="https://static001.geekbang.org/resource/image/12/98/12c6039884ee99742fbbebf198425998.png"}\所以我们能看出来第一梯队有日本、韩国、伊朗、沙特、澳洲；第二梯队有中国、伊拉克、阿联酋、乌兹别克斯坦；第三梯队有卡塔尔、泰国、越南、阿曼、巴林、朝鲜、印尼、叙利亚、约旦、科威特和巴勒斯坦。
## 如何使用 sklearn 中的 K-Means 算法sklearn 是 Python 的机器学习工具库，如果从功能上来划分，sklearn可以实现分类、聚类、回归、降维、模型选择和预处理等功能。这里我们使用的是sklearn 的聚类函数库，因此需要引用工具包，具体代码如下：    from sklearn.cluster import KMeans当然 K-Means 只是 sklearn.cluster 中的一个聚类库，实际上包括 K-Means在内，sklearn.cluster 一共提供了 9 种聚类方法，比如Mean-shift，DBSCAN，Spectralclustering（谱聚类）等。这些聚类方法的原理和 K-Means不同，这里不做介绍。我们看下 K-Means 如何创建：    KMeans(n_clusters=8, init='k-means++', n_init=10, max_iter=300, tol=0.0001, precompute_distances='auto', verbose=0, random_state=None, copy_x=True, n_jobs=1, algorithm='auto')我们能看到在 K-Means 类创建的过程中，有一些主要的参数：-   **n_clusters**: 即 K 值，一般需要多试一些 K    值来保证更好的聚类效果。你可以随机设置一些 K    值，然后选择聚类效果最好的作为最终的 K 值；-   **max_iter**：    最大迭代次数，如果聚类很难收敛的话，设置最大迭代次数可以让我们及时得到反馈结果，否则程序运行时间会非常长；-   **n_init**：初始化中心点的运算次数，默认是    10。程序是否能快速收敛和中心点的选择关系非常大，所以在中心点选择上多花一些时间，来争取整体时间上的快速收敛还是非常值得的。由于每一次中心点都是随机生成的，这样得到的结果就有好有坏，非常不确定，所以要运行    n_init 次, 取其中最好的作为初始的中心点。如果 K    值比较大的时候，你可以适当增大 n_init 这个值；-   **init：** 即初始值选择的方式，默认是采用优化过的 k-means++    方式，你也可以自己指定中心点，或者采用 random    完全随机的方式。自己设置中心点一般是对于个性化的数据进行设置，很少采用。random    的方式则是完全随机的方式，一般推荐采用优化过的 k-means++ 方式；-   **algorithm**：k-means 的实现算法，有"auto"    "full""elkan"三种。一般来说建议直接用默认的\"auto\"。简单说下这三个取值的区别，如果你选择\"full\"采用的是传统的    K-Means    算法，"auto"会根据数据的特点自动选择是选择"full"还是"elkan"。我们一般选择默认的取值，即"auto"    。在创建好 K-Means 类之后，就可以使用它的方法，最常用的是 fit 和 predict这个两个函数。你可以单独使用 fit 函数和 predict 函数，也可以合并使用fit_predict 函数。其中 fit(data) 可以对 data 数据进行 k-Means 聚类。predict(data) 可以针对 data 中的每个样本，计算最近的类。现在我们要完整地跑一遍 20支亚洲球队的聚类问题。我把数据上传到了[GitHub](https://github.com/cystanford/kmeans)上，你可以自行下载。    
# coding: utf-8from sklearn.cluster import KMeansfrom sklearn import preprocessingimport pandas as pdimport numpy as np
# 输入数据data = pd.read_csv('data.csv', encoding='gbk')train_x = data[["2019 年国际排名 ","2018 世界杯 ","2015 亚洲杯 "]]df = pd.DataFrame(train_x)kmeans = KMeans(n_clusters=3)
# 规范化到 [0,1] 空间min_max_scaler=preprocessing.MinMaxScaler()train_x=min_max_scaler.fit_transform(train_x)
# kmeans 算法kmeans.fit(train_x)predict_y = kmeans.predict(train_x)
# 合并聚类结果，插入到原数据中result = pd.concat((data,pd.DataFrame(predict_y)),axis=1)result.rename({0:u'聚类'},axis=1,inplace=True)print(result)运行结果：    国家  2019 年国际排名  2018 世界杯  2015 亚洲杯  聚类0       中国         73       40        7   21       日本         60       15        5   02       韩国         61       19        2   03       伊朗         34       18        6   04       沙特         67       26       10   05      伊拉克         91       40        4   26      卡塔尔        101       40       13   17      阿联酋         81       40        6   28   乌兹别克斯坦         88       40        8   29       泰国        122       40       17   110      越南        102       50       17   111      阿曼         87       50       12   112      巴林        116       50       11   113      朝鲜        110       50       14   114      印尼        164       50       17   115      澳洲         40       30        1   016     叙利亚         76       40       17   117      约旦        118       50        9   118     科威特        160       50       15   119    巴勒斯坦         96       50       16   1
## 总结今天我给你讲了 K-Means 算法原理，我们再来看下开篇我给你提的三个问题。如何确定 K类的中心点？其中包括了初始的设置，以及中间迭代过程中中心点的计算。在初始设置中，会进行n_init次的选择，然后选择初始中心点效果最好的为初始值。在每次分类更新后，你都需要重新确认每一类的中心点，一般采用均值的方式进行确认。如何将其他点划分到 K类中？这里实际上是关于距离的定义，我们知道距离有多种定义的方式，在K-Means 和 KNN中，我们都可以采用欧氏距离、曼哈顿距离、切比雪夫距离、余弦距离等。对于点的划分，就看它离哪个类的中心点的距离最近，就属于哪一类。如何区分 K-Means 和 KNN 这两种算法呢？刚学过 K-Means 和 KNN算法的同学应该能知道两者的区别，但往往过了一段时间，就容易混淆。所以我们可以从三个维度来区分K-Means 和 KNN 这两个算法：-   首先，这两个算法解决数据挖掘的两类问题。K-Means 是聚类算法，KNN    是分类算法。-   这两个算法分别是两种不同的学习方式。K-Means    是非监督学习，也就是不需要事先给出分类标签，而 KNN    是有监督学习，需要我们给出训练数据的分类标识。-   最后，K 值的含义不同。K-Means 中的 K 值代表 K 类。KNN 中的 K 值代表    K 个最接近的邻居。![](Images/48381c9b3471ec5de75ef8d99710fc3f.png){savepage-src="https://static001.geekbang.org/resource/image/eb/c5/eb60546c6a3d9bc6a1538049c26723c5.png"}\那么学完了今天的内容后，你能说一下 K-Means的算法原理吗？如果我们把上面的 20 支亚洲球队用 K-Means 划分成 5类，在规范化数据的时候采用标准化的方式（即均值为 0，方差为1），该如何编写程序呢？运行的结果又是如何？欢迎你在评论区与我分享你的答案，也欢迎点击"请朋友读"，把这篇文章分享给你的朋友或者同事。![](Images/8b75105190797b2e4f7be2536b6543db.png){savepage-src="https://static001.geekbang.org/resource/image/48/96/48cb89aa8c4858bbc18df3b3ac414496.jpg"}
# 27丨K-Means（下）：如何使用K-Means对图像进行分割？上节课，我讲解了 K-Means 的原理，并且用 K-Means 对 20支亚洲球队进行了聚类，分成 3 个梯队。今天我们继续用 K-Means进行聚类的实战。聚类的一个常用场景就是对图像进行分割。图像分割就是利用图像自身的信息，比如颜色、纹理、形状等特征进行划分，将图像分割成不同的区域，划分出来的每个区域就相当于是对图像中的像素进行了聚类。单个区域内的像素之间的相似度大，不同区域间的像素差异性大。这个特性正好符合聚类的特性，所以你可以把图像分割看成是将图像中的信息进行聚类。当然聚类只是分割图像的一种方式，除了聚类，我们还可以基于图像颜色的阈值进行分割，或者基于图像边缘的信息进行分割等。
## 将微信开屏封面进行分割上节课，我讲了 sklearn 工具包中的 K-Means 算法使用，我们现在用 K-Means算法对微信页面进行分割。微信开屏图如下所示：![](Images/5f6f4d1e586ccda335bfab889be64aa8.png){savepage-src="https://static001.geekbang.org/resource/image/50/a2/50457e4e1fbd288c125364a6904774a2.png"}\我们先设定下聚类的流程，聚类的流程和分类差不多，如图所示：![](Images/a59d4ba830d25df0b3f89484da685a98.png){savepage-src="https://static001.geekbang.org/resource/image/8a/78/8af94562f6bd3ac42036ec47f5ad2578.jpg"}\在准备阶段里，我们需要对数据进行加载。因为处理的是图像信息，我们除了要获取图像数据以外，还需要获取图像的尺寸和通道数，然后基于图像中每个通道的数值进行数据规范化。这里我们需要定义个函数load_data，来帮我们进行图像加载和数据规范化。代码如下：``{=html}    
# 加载图像，并对数据进行规范化def load_data(filePath):    