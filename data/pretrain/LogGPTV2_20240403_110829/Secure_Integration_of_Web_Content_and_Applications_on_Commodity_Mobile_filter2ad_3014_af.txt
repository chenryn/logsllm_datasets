and CNS-1228620), and a joint United States Air Force/-
DARPA Contract (# FA-8650-15-C-7562). Any opinions,
ﬁndings, and conclusions or recommendations expressed in
this paper are those of the authors and do not necessarily
reﬂect the views of the funding agencies.
662
10. CONCLUSION
As discussed in this work and others, Web-embedding
apps increasingly attract attacks from di↵erent angles. Sev-
eral current threat vectors remain unprotected, due to the
lack of practical security mechanisms that can meet security
requirements of all parties, including app developers, app
users and web content providers.
We propose the use of a secure, third-party app called
WIREframe to provide trustworthy web-embedding while
enforcing conﬁgurable and origin-based security policies on
the interactions between Android apps and embedded web
content. WIREframe allows both apps and web content
to secure their own resources at ﬁne-granularities. We have
shown that our solution is e↵ective in preventing abuses of
the app-web bridge by either malicious web content or ma-
licious apps. At the same time, our system maintains the
appearance and functionality of client apps.
Our solution is easy to deploy. It requires no modiﬁcation
to the Android operating system or framework. Through
the use of our o✏ine app-rewriting tool, WIRE, we can re-
target legacy apps to beneﬁt from the enhanced security of
WIREframe without developer intervention.
11. REFERENCES
[1] Android-Apktool. https://ibotpeaches.github.io/Apktool/.
[2] Android Isolated Service. http://developer.android.com/
guide/topics/manifest/service-element.html#isolated.
[3] Apache Cordova. https://cordova.apache.org.
[4] A. Bartel, J. Klein, et al. Dexpler: Converting Android
Dalvik Bytecode to Jimple for Static Analysis with Soot.
Proceedings of the 1st International Workshop on the State
Of the Art in Program Analysis, SOAP ’12. ACM, 2012.
[5] E. Bursztein, C. Soman, et al. Sessionjuggler: Secure Web
Login from an Untrusted Terminal Using Session
Hijacking. In Proceedings of the 21st International
Conference on World Wide Web, WWW ’15, 321–330.
ACM, 2012.
[6] E. Chin & D. Wagner. Bifocals: Analyzing WebView
Vulnerabilities in Android Applications. In Information
Security Applications, LNCS, 138–159. Springer
International, 2014.
[7] J. Dean, D. Grove, et al. Optimization of Object-Oriented
Programs Using Static Class Hierarchy Analysis. ECOOP
’95, Berlin, Heidelberg.
[8] M. Egele, C. Kruegel, et al. PiOS: Detecting Privacy Leaks
in iOS Applications. In Proceedings of the 2011 Network
and Distributed System Security Symposium, NDSS ’11,
177–183. 2011.
[9] M. Georgiev, S. Jana, et al. Breaking and Fixing
Origin-Based Access Control in Hybrid Web/Mobile
Application Frameworks. 2014.
[10] M. C. Grace, W. Zhou, et al. Unsafe Exposure Analysis of
Mobile In-app Advertisements. In Proceedings of the 5th
ACM Conference on Security and Privacy in Wireless and
Mobile Networks, WISEC 12, 101–112. ACM, 2012.
[11] B. Hassanshahi, Y. Jia, et al. Web-to-Application Injection
Attacks on Android: Characterization and Detection. In
Proceedings of the 2015 European Symposium on Research
in Computer Security, ESORICS ’15, 577–598. Springer,
2015.
[12] J. Jeon, K. K. Micinski, et al. Dr. Android and Mr. Hide:
Fine-grained Permissions in Android Applications. In
ACM CCS Workshop on Security and Privacy in
Smartphones and Mobile Devices (SPSM), 3–14. 2012.
[13] X. Jin, X. Hu, et al. Code Injection Attacks on
HTML5-based Mobile Apps: Characterization, Detection
and Mitigation. In Proceedings of the 2014 ACM
Conference on Computer and Communications Security,
CCS ’14, 66–77. ACM.
[14] G. A. Kildall. A Uniﬁed Approach to Global Program
Optimization. In Proceedings of the 1st Annual ACM
SIGACT-SIGPLAN Symposium on Principles of
Programming Languages, POPL ’73, 194–206. ACM, 1973.
[15] D. Liu & L. P. Cox. VeriUI: Attested Login for Mobile
Devices. In Proceedings of the 15th Workshop on Mobile
Computing Systems and Applications, 7. ACM, 2014.
[16] T. Luo, H. Hao, et al. Attacks on WebView in the Android
system. In Proceedings of the 2011 Annual Computer
Security Applications Conference, 343–352. ACM, 2011.
[17] P. Mutchler, A. Doup´e, et al. A Large-Scale Study of
Mobile Web App Security. In Proceedings of the Mobile
Security Technologies Workshop (MoST). 2015.
[18] A. Nadkarni, V. Tendulkar, et al. NativeWrap: Ad Hoc
Smartphone Application Creation for End Users. In
SPWM 2014, WiSec ’14, 13–24. ACM, 2014.
[19] M. Neugschwandtner, M. Lindorfer, et al. A View to a Kill:
WebView Exploitation. In LEET 2013. USENIX, 2013.
[20] P. Pearce, A. P. Felt, et al. Addroid: Privilege Separation
for Applications and Advertisers in Android. In SICCS
2012.
[21] V. Rastogi, R. Shao, et al. Are these Ads Safe: Detecting
Hidden Attacks through the Mobile App-Web Interfaces. In
Proceedings of the 2016 Network and Distributed System
Security Symposium, NDSS ’16. 2016.
[22] B. Reaves, N. Scaife, et al. Mo(bile) Money, Mo(bile)
Problems: Analysis of Branchless Banking Applications in
the Developing World. In Proceedings of the 24th USENIX
Security Symposium (2015), 17–32. 2015.
[23] T. Reps, S. Horwitz, et al. Precise Interprocedural Dataﬂow
Analysis via Graph Reachability. In Proceedings of the
22Nd ACM SIGPLAN-SIGACT POPL Symposium, POPL
’95, 49–61. ACM, 1995.
[24] F. Roesner & T. Kohno. Securing Embedded User
Interfaces: Android and Beyond. In Proceedings of the
22nd USENIX Security Symposium, Security ’13, 97–112.
USENIX, 2013.
[25] M. Shehab & F. Mohsen. Towards enhancing the security
of oauth implementations in smart phones. In ICMS 2014,
39–46. IEEE, 2014.
[26] S. Shekhar, M. Dietz, et al. AdSplit: Separating
Smartphone Advertising from Applications. In USENIX
Security Symposium, 553–567. 2012.
[27] S. Son, D. Kim, et al. What Mobile Ads Know About
Mobile Users. In NDSS. 2016.
[28] D. R. Thomas, A. R. Beresford, et al. Security Protocols
XXIII: 23rd International Workshop, Cambridge, 2015,
126–138. Springer International, 2015.
[29] G. S. Tuncay, S. Demetriou, et al. Draco: A System for
Uniform and Fine-grained Access Control for Web Code on
Android. In Proceedings of the 2016 Conference on
Computer and Communications Security, CCS ’16,
104–115. ACM, New York, NY, USA, 2016.
[30] R. Vall´ee-Rai, P. Co, et al. Soot - a Java Bytecode
Optimization Framework. In Proceedings of the 1999
Conference of the Centre for Advanced Studies on
Collaborative Research, CASCON ’99. IBM Press, 1999.
[31] R. Wang, L. Xing, et al. Unauthorized Origin Crossing on
Mobile Platforms: Threats and Mitigation. In Proceedings
of the 2013 ACM SIGSAC conference on Computer &
Communications Security, 635–646. ACM, 2013.
[32] L. Xing, X. Bai, et al. Cracking App Isolation on Apple:
Unauthorized Cross-App Resource Access on MAC OS. In
Proceedings of the 2016 Conference on Computer and
Communications Security, 31–43. ACM, 2015.
[33] X. Zhang, A. Ahlawat, et al. AFrame: Isolating
Advertisements from Mobile Applications in Android. In
Proceedings of the 2013 Annual Computer Security
Applications Conference, ACSAC ’13, 9–18. ACM, 2013.
663
APPENDIX
A. APP REWRITING
A key goal of our work is that it is backwards-compatible
with existing apps without modifying the OS. In this section,
we discuss the details of how we accomplish this goal through
app rewriting.
The security policies discussed in Section 4 only take e↵ect
if WIREframe is used by a web-embedding app in place
of its regular WebViews. While benign developers might
choose to deploy our mechanisms, malicious developers have
no incentive to do so. Our o✏ine rewriting tool, WIRE,
addresses this concern by replacing all uses of WebView with
uses of the secure WIREframe proxy. This section provides
details on the design and implementation of WIRE. As space
constraints prevent us from providing a full discussion of
the implementation of WIRE, we highlight the novel and
challenging aspects of the tool.
Packaged App Analysis: One of the key advantages of
our approach is that it does not require assistance from de-
velopers. This means that the tool can rely only on the
packaged app (.apk ﬁle) and compiled bytecode. To handle
this challenge, WIRE leverages previous work on reverse-
engineering and re-compiling Dalvik bytecode. In particular,
we use the open source Apktool to unpackage and repack-
age code and resources from an apk [1]. We use the Soot
Java Optimization Framework [30] and Dexpler [4] to extract
Dalvik to an intermediate representation and recompile the
rewritten code.
WIRE is designed as a modular pipeline, with the rewrit-
ing phase decoupled from unpackaging and repackaging the
app. Thus, improvements to the underlying tools can be
easily integrated into our workﬂow.
Identifying WebView Usage: Because WIREframe pre-
vents the use of the default WebView, it is crucial for the
proper operation of the client app that all legitimate We-
bView uses of are identiﬁed and replaced. Unfortunately,
this identiﬁcation can be challenging.
In addition to We-
bViews that are programmatically constructed and conﬁg-
ured at runtime, an app can deﬁne the WebView UI and its
layout using an XML manifest which the system loads at
runtime. Thus, WIRE introspects and modiﬁes not just the
app code, but also the applications resource XML ﬁles and
support code.
Figure 9 presents simpliﬁed pseudocode for the rewriting
algorithm. The goal the main loop is to transform a tar-
get web-embedding app A to use the secure webview proxy
instead of the default WebView class of Android. The ﬁrst
step of our algorithm (Line 2) is to invoke a custom ex-
tension to the standard class hierarchy analysis (CHA [7]),
which we refer to as CHA’. This extension ensures that class
loading from the resources (i.e. the app manifest) is also
included. Once we have identiﬁed all instances and sub-
classes of WebView, denoted W , we create a proxy w0 for
each w 2 W (Line 4). The main rewriting loop (Lines 3-
13) is concerned with substituting w with w0: we identify
the set the set Uw of all uses of w 2 W (Line 5) using a
standard dataﬂow [14] over the supergraph of A [23]. Note
that we use the term use to refer to all operations that refer-
ence w, as opposed to the typical use/def relations in which
usually only refer to the right-hand side of an operation.
For notational convenience, we represent each such use in
the form c(w, v1, v2, . . . , vn) where v1, . . . , vn are additional
1: Let A be the target web-embedding app
2: W   CHA’(WebView,A)
3: for all w 2 W do
Create proxy w0 of w
4:
5:
Let Uw be the set of uses of w in A
6:
for all c(w, v1, . . . , vn) 2 Uw do
7:
8:
9:
10:
11:
12:
Let suw be the shadow object of vi
S   S [ suw
for all suw 2 S do
replace(w, w0)
for all i 2{ 1, . . . , n} do
marshal(suw )
Figure 9: Rewriting loop simpliﬁed pseudocode
variables involved in the use, such as arguments to methods
of w. These additional variables are exactly the ones that
need to be shadowed or serialized (c.f. section 4). Thus, we
replace the reference to w itself with a reference to w0 using
the pseudofunction replace (Line 7) and keep an object suw
to shadow each vi (Lines 9-10). Finally, all the Webviews
have been replaced, we call the marshal pseudofunction with
each shadow object to inject the marshaling code necessary
to transfer the used value shadowed by suw into the proxy
(Lines 11-12).
Satisfying Lifecycle Constraints: Android apps execute
in an event-driven lifecycle managed by the system. Events
are ﬁred by the Operating System in response to events or
system notiﬁcations. An implicit ordering exists between the
lifecycle events: one event cannot happen until the compo-
nent’s lifecycle has gone through preceding events. Without
considering component lifecycle and the implicit constraints,
app rewriting can cause erroneous or interrupted app execu-
tion. Thus, WIRE includes a model of the Android lifecycle,
which is referenced during the calls to inject and marshal so
that the WIREframe is properly running and bound before
each invocation.
B. FUTURE WORK
In this section, we discuss limitations of our current im-
plementation and consider future work to them.
App Updates: A consequence of using o✏ine rewriting to
induce enforcement mechanisms on apps is that apps can no
longer be automatically updated on the device. This is an
inconvenience for users who enable automatic updates, since
they have to re-apply the WIRE rewriting. However, this
inconvenience can be justiﬁed by the much enhanced secu-
rity of web-embedding apps without requiring OS changes.
Furthermore, we expect that WIRE will mostly be applied
to legacy apps (which are updated less frequently) and un-
trusted apps that beneﬁt from additional static checking
before install time in any case. Apps that do not include
WebViews or adopt WIREframe during development do
not need to be rewritten. In cases where app markets can
adopt WIRE and perform app rewriting before app release,
such as in an enterprise app store, app users can enjoy the
security beneﬁts of WIREframe without facing app update
inconvenience.
WebView State Sharing: As shown by the attack in §2,
allowing multiple WebViews to run in the same process en-
ables implicit sharing of states, such as history and cookies.
WIREframe runs each mediated WebView in a separate
process to disable cross-WebView attacks. It also restricts
664
• Performance improvements: By implementing We-
bView isolation within the app, fewer context switches
and less data marshalling is required.
• Mandatory enforcement: Our system is only e↵ec-
tive if users apply the app rewriting tool WIRE or de-
velopers explicitly target WIREframe. By integrating
WIREframe-like protections into the OS itself, web
developers can be more conﬁdent that WebView poli-
cies are actually enforced on the client side.
• Enhanced functionality: As noted in Section 7, some
visual di↵erences may occur if the app attempts to
“pop under” content on the WebView. While disallow-
ing this behavior can help defend against clickjacking,
it prevents a benign app overlay of app content over
web content. The OS might support an app-deﬁned
Z-order of elements within an app, such as proposed
in [24]. Furthermore, the VPNService used by WIRE-
frame, which exists to prevent an app from spoof-
ing the WIREframe service, could use in-app anti-
spooﬁng methods.
We plan to explore this avenue in future work.
each WebView’s ﬁle system access to a per-origin private
path by default. However, sharing states among WebView
instances created by a same app may be required for legiti-
mate functionalities. While we did not encounter any such
cases in our experiments, WIREframe could be extended
to allow multiple WebViews to share a process. We leave
this implementation detail, and the design of when to allow
sharing, to future work.
OS-level Extension of WebView: While one of the key
contributions of our work is that it provides support for apps
without updating the OS, this approach comes with a num-
ber of tradeo↵s: the WIREframe service is isolated, but
comes with the overhead of running a background service
fulltime, as well as incurring the cost of object shadowing to
communicate with the the client app. A natural alternative
to our approach is to modify the OS directly to implement
our proposed protections.
An obvious way to protect web-embedding app attacks is
to extend the WebView class in Android framework to sup-
port a “trusted mode”. Either an embedding app or embed-
ded web content may switch a WebView instance into the
trusted mode by calling newly introduced Java or JavaScript
APIs. When in this mode, the web-embedding app runs the
WebView, but the OS can suppress the app’s introspection
capabilities and dynamically regulating method invocations
from embedded web content. In the Android security model
processes are the atomic security principal [12]. Therefore,
this approach is likely to require major changes to the se-
curity model of the OS, or at least rendering the trusted
WebView in a separate process. Nevertheless, there are sev-
eral beneﬁts to this approach:
665