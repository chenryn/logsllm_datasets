54.6%
30.2%
4.7%
87.3%
#goto
1661.3
NA
15479.3
3766.4
NA
8023.2
1709.6
NA
6026.5
8971.5
NA
9367.0
LOC
142.3
NA
282.7
374.3
NA
595.1
168.7
NA
247.6
276.6
NA
554.6
44.3
6661.4(12978)
245824.2(478924.3)
1820(20078.2)
61677(680419.3)
6344.1(27894.4)
70947.1(311947.6)
1635(3448.7)
3188.4
36256.7(76476.1)
VIII. CROSS-COMPILER & OPTIMIZATION EVALUATION
Sec. V has mentioned that we use clang without any
optimizations to launch experiments in Sec. VI. Although the
lifted IR exhibits poor support for pointer analysis, we ﬁnd that
lifters can generate IR code from non-optimized executables
that has quality comparable to that of compiled IR used for
discriminability analysis and C decompilation. This section
further assesses the generalizability of our ﬁndings in terms
of cross-compiler and cross-optimization settings. We use gcc
(ver. 7.5.0) and we also use full compiler optimizations (-O3)
for the evaluation. McSema0 gives notably worse results than
McSema, and is thus not evaluated. We report the binary lifting
results in Appx. D, and these are generally consistent with the
lifting results reported in Table V.
We summarize the results for different settings in Table XI;
the last row represents clang-generated LLVM IR. For
the decompilation evaluation of BinRec, a dynamic tool,
data in the parentheses denotes the estimation of induced
#goto and LOC if full coverage was achieved. mctoll
fails to lift all SPEC programs, and its results are “NA”. For
discriminability analysis, RetDec manifests high robustness
toward different compilation/optimization settings. In contrast,
mctoll and McSema show worse performance when apply-
ing full optimizations or using the gcc compiler. mctoll
gives relatively poor support for gcc compiled executable;
speciﬁcally, our manual study shows that lifting some gcc
compiled executables silently generates broken IR fragments,
without giving any warning. As admitted by the mctoll
developers [13], lifting gcc compiled executable is not fully
tested yet. McSema reuses and extends the optimization passes
of the LLVM framework (see [14]) which are generally
more correct and effective in processing clang-compiled
executables. In fact, we ﬁnd that IR lifted from gcc-compiled
executables is generally more lengthy than those lifted from
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:56:18 UTC from IEEE Xplore.  Restrictions apply. 
1111
clang compiled executables. This observation accounts for
the low effectiveness of McSema optimizations in lifting gcc-
compiled executables, and may also explain the lower dis-
criminability analysis accuracy for the gcc settings. BinRec
shows generally low support for discriminability analysis,
which is aligned with ﬁndings in Sec. VI-C.
Table XI implies that applying full optimizations (-O3) in
the decompilation analysis generates less structured programs,
given the higher #goto and greater LOC. Compiler optimiza-
tions create extra challenges for reverse engineering. However,
in Sec. IX and Appx. C, we will discuss observations that the
popular (commercial) decompilers, IDA-Pro and Ghidra [86],
exhibit similar trends w.r.t. optimized executables. For exam-
ple, Table XIV in Appx. C shows a comparison of the -O3
and -O0 settings, which reveals that #goto is increased for
5.4 times in IDA-Pro’s decompiled C code. In contrast, a
comparison of -O3 and -O0 settings in the decompilation
evaluation of RetDec-lifted IR code shows an even smaller
increase of #goto (3.8 times; smaller is better). Apparently,
neither lifters nor (commercial) decompilers can give fool-
proof solutions to solve C decompilation. Evaluations in
this section, however, imply the encouraging and practical
value of lifter-driven (particularly RetDec-based) solutions.
C code decompiled from McSema-lifted IR and BinRec-
lifted IR contain an unusually high #goto for the gcc -O0
setting; this is because several large SPEC programs, including
403.gcc and 400.perlbench, can only be correctly lifted
when -O0 is used, which results in many goto statements
and thereby increases the average #goto.
IX. COMPARISON WITH BINARY-ONLY TOOLS
We aim to study whether the lifted IR code exhibits good
support for downstream security tasks that is comparable to
that of clang generated IR code. To do so, Sec. VI has
studied three tasks that serve as the core building blocks of
many downstream security applications. Nonetheless, to di-
rectly compare with binary security analysis (without lifting),
we compare binary-only tools with lifter-enabled solutions in
three tasks, i.e., sanitization, binary difﬁng, and decompilation.
This section summarizes key ﬁndings, and we present details
in Appx. A, Appx. B, and Appx. C, respectively.
Appx. A compares RetroWrite [43], a binary rewrit-
ing framework, and lifters in applying address sanitizer
(ASan) [98] to executable. In principle, RetroWrite does not
strive to recover variables whereas binary lifters, particularly,
RetDec, can (imprecisely) recover variables and function
local stacks. This conceptually differentiates RetroWrite from
lifters given that RetroWrite only enables coarse-grained stack
frame-level ASan insertion. At the empirical level, we compare
McSema and RetDec with RetroWrite by inserting ASan
checks into the Juliet test programs. Due to the low function-
ality correctness of RetDec-lifted IR code (see Sec. VI-E),
many RetDec-lifted IR programs are mal-functional; it be-
comes meaningless to benchmark its stack sanitization quality.
Out of 3,497 Juliet test cases containing heap vulnerabilities,
McSema can correctly lifts 2,187 cases. For these cases,
McSema achieves promising heap sanitization accuracy which
is comparable with RetroWrite. Nevertheless, the original pro-
gram stack is not protectable, as McSema uses an emulation
stack in its generated IR code. With further enhancement
on functionality correctness, McSema has great potential to
sanitize executable and detect heap exploitations. In sum, our
study in Appx. A, from conceptual and empirical perspectives,
illustrates that neither binary-only nor lifter-driven solutions
can enable full-ﬂedged sanitization. We also discuss strengths
(e.g., cross-platform support) and weaknesses (e.g., perfor-
mance penalty) of lifter-driven sanitization compared with
RetroWrite in Appx. A.
Appx. B compares lifter-enabled binary difﬁng with the
state-of-the-art research tool, DeepBinDiff [46], and the
industrial standard tool, BinDiff [2]. The lifter-enabled ap-
proaches exhibit encouraging performance in binary difﬁng,
which is comparable to that of DeepBinDiff. This indicates
the good potential of lifters for use in security tasks such
as malware clustering and CVE/patch searching [120], [124],
[121]. In addition, Appx. C assesses the quality of decompiled
code, and compares lifter-enabled decompilation with that
of (commercial) decompilers, IDA-Pro and Ghidra. These
(commercial) decompilers generate more structured code than
the lifter-enabled solutions in most settings (see Table XIV),
but the latter exhibit reasonable decompilation quality and
appealing extensibility, and are cost-free.
X. DISCUSSION
Analyzing Binary Code with LLVM: Are We There
Yet? As clariﬁed in Sec. IV, “recompilation” is challenging.
However, the research community and industry have provided
lifters that can generally pass functionality testing and for-
mal veriﬁcations [38], [66]. Our study in Sec. VI-E further
shows that emulation-style lifters can generate functionality-
preserving IR code. These ﬁndings have laid a solid foundation
to use lifters for code patching, migration, and reuse.
IR lifting, similar with most reverse engineering tasks,
is not decidable. Therefore, people may be pessimistic that
lifted IR code is invariably lower in quality. However, in
daily security tasks, how much of a problem is, for instance,
applying some analysis utilities toward the lifted IR code?
This SoK paper aims to understand the status quo of lifter-
driven static security tasks. We summarize current knowledge
and explicate further efforts required to link low-level security
analysis with the LLVM framework. We also show that lifters
exhibit rather inconsistent support for analysis tasks. Our study
enhances the conﬁdence of using lifters in many security
tasks related to discriminability analysis, decompilation, and
sanitization. While to date one might not expect an “out-of-
the-box” usage of lifters for rigorous static analysis, Appx. E
explores enhancement using Debin.
Fostering Other Security Tasks. In addition to tasks eval-
uated in this paper, we also envision using lifters to foster
other security tasks. For instance, recent works [84] have
studied using lifters in binary-only fuzzing. Given code has
been lifted into LLVM IR,
is also a natural extension
it
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:56:18 UTC from IEEE Xplore.  Restrictions apply. 
1112
to explore bug detection, security patching, and migration
using many industrial-strength LLVM-driven solutions [88],
[96], [27], [50], [94]. Nonetheless, some of these applications
require the correctness of lifted IR code. While our study in
Sec. VI-E shows encouraging correctness of emulation-style
lifters, this lifting scheme can likely introduce more overhead
given that computations are emulated in LLVM IR.
Future Works. As a future research direction, we envision
proposing “lifter-oriented” static analysis algorithms. For in-
stance, emulation-style lifting (e.g., McSema) uses a global
array to emulate the access of the physical memory stack
in machine code. This puts scalable ﬁeld-sensitive static
analysis [90] as a basic requirement which supports tracking
contents within each array element separately. We plan to
benchmark and potentially calibrate standard ﬁeld-sensitive
pointer analysis in analyzing McSema lifted IR.
Emulation-style IR (EIR) can promisingly guarantee the
functional correctness, but lacks expressiveness. High-level IR
(HIR), on the other end of the spectrum, strives to recover
high-level code features, but can generate mal-functional code.
It thus becomes critical to enhance the quality of EIR and HIR,
for which the compiled-IR (CIR) might help. In particular,
Transforming EIR To HIR (EIR → HIR). EIR is conserva-
tively lifted in a (mostly) functionality-correct manner. In-
tuitively, one may explore using a sequence of semantics-
preserving transformations to gradually change a piece of
EIR into HIR, e.g., by ﬁnding combinations of certain LLVM
passes w.r.t. objective functions like minimizing distances
between EIR and HIR. However, we point out that this task,
EIR → HIR, is not fundamentally easier than lifting assembly
into EIR. As clariﬁed in Reﬁnement of Sec. II, well-known
challenges, e.g., variable and type recovery, are required in EIR
→ HIR. In fact, the SecondWrite papers [19], [47] aim to solve
EIR → HIR with (sound) techniques; see further information
about SecondWrite in Sec. XI.
Learning from CIR to Fix HIR (HIR ← CIR). HIR is lifted
in a more expressive manner and is (visually) closer to CIR. To
enhance the functional correctness, one may wonder pinpoint-
ing and ﬁxing mal-functional code snippets in HIR, by learn-
ing from corresponding CIR. Recent advances in binary-to-
source matching with neural models might be inspiring [119].
In fact, the authors tentatively investigated the feasibility of
“HIR ← CIR”; we ﬁnd that this direction, although look
promising, is much harder than expected. We manually com-
pared some mal-functional HIR with their corresponding CIR.
Line-by-line comparison can easily expose inconsistencies.
Such inconsistencies, however, are primarily due to uncertainty
of reverse engineering, which are not erroneous. Defects in
HIR, e.g., ill-lifted local variables, are stealthy. It is difﬁcult,
even for human experts,
to recognize certain wrong code
snippets, let alone machine learning models.
XI. RELATED WORK
binary lifters either lift an executable into a standard compiler
IR (LLVM or GCC) or customized IR. SecondWrite [19], [47]
lifts machine code into LLVM IR code and reﬁnes it with type
inference and symbolic execution. Their proposed technique is
demonstrated to generate LLVM IR code of high quality and
support code optimization.1 Egalito [115] proposes the new
design of binary layout agnostic IR, which is shown to support
fool-proof recompilation on even complex SPEC programs
with negligible cost. Inception [37] proposes a “lift-and-
merge” process which lifts ARM32 binary code into LLVM
IR, and then merges the lifted IR with LLVM bitcode compiled
from source code to smoothly enable symbolic execution.
BinRec enhances dynamic lifting using symbolic execution
and path merging [18]. Instrew proposes to maintain a code
cache [48], which maps machine instruction addresses to the
already lifted code fragments during dynamic lifting to avoid
repeatedly lifting the same code. LISC [58] automates the
generation of assembly to IR lifting rules by learning from how
compilers translate IR into assembly instructions. Similarly,
Wang et al. [113] propose to learn translation rules for existing
dynamic binary translators and use symbolic execution to
validate the correctness of the learned rules.
[93] studies the difference of using compiled IR, lifted
IR, or assembly code for symbolic execution. Our work has
different focuses with [93]: [93] compares the symbolic engine
of S2E [35], which is speciﬁcally designed for lifted LLVM IR
with KLEE [29], a symbolic execution engine designed from
compiled LLVM IR. In contrast, our systematic study takes
one step further by exploring whether analysis facilities in the
LLVM compiler framework can be directly reused to analyze
LLVM IR code lifted by the state-of-the-art binary lifters.
Promising support will, to certain extent, push the community
to the edge of a breakthrough that allowing to leverage full sets
of compiler passes built up over decades to analyze low-level
machine code without reinventing the wheel.
XII. CONCLUSION
We present a study of binary lifters regarding their support
for downstream applications. We set up three tasks used by
many security applications and study different compilation set-
tings. We also compare lifter-enabled approaches and binary-
only solutions over three security tasks. We ﬁnd that the lifted
LLVM IR code exhibits promising support for discriminability
analysis and C decompilation, but has much worse support for
static analysis. Our ﬁndings can provide insights for users and
developers that aim to use and enhance lifters.
ACKNOWLEDGEMENT
We thank anonymous reviewers and our shepherd, Michael
Franz, for their valuable feedback. We also thank Fabian
Parzefall and Joseph Nash who provided us with much help
and advice in setting up BinRec. The research was supported
in part by a RGC ECS grant under the contract 26206520.
Typical applications of binary lifters include optimiza-
tion [19], [47], [115], code reuse [67], [41], and security
analysis [55], [67], [37], [63]. Existing static and dynamic
1SecondWrite was seen as commercialized [9]. However, it was conﬁrmed
by their engineers that the so-called “SecondWrite” is a malware sandbox.
They do not provide any static binary lifter for research study or comparison.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:56:18 UTC from IEEE Xplore.  Restrictions apply. 
1113
REFERENCES
[1] Research Artifact. https://github.com/monkbai/ir
[2] BinDiff. https://www.zynamics.com/bindiff.html, 2014.
[3] radare2. http://www.radare.org/r/, 2016.
[4] Bin2LLVM. https://github.com/cojocar/bin2llvm, 2017.
[5] Possible to access higher-level IR in decompilation process. https:
lifting data.
//github.com/NationalSecurityAgency/ghidra/issues/978, 2019.
[6] RetDec data types propagation.
https://github.com/avast/retdec/
blob/567c30e3dd4c572fa825d8781ed69652306a961e/src/bin2llvmir/
optimizations/types propagator/types propagator.cpp, 2020.
[7] RetDec function prototype inference. https://github.com/avast/retdec/
blob/567c30e3dd4c572fa825d8781ed69652306a961e/src/bin2llvmir/
optimizations/param return/param return.cpp, 2020.
[8] RetDec simple types
recovery.