### VIII. CROSS-COMPILER & OPTIMIZATION EVALUATION

In Section V, we mentioned that our experiments in Section VI were conducted using Clang without any optimizations. Despite the lifted IR exhibiting poor support for pointer analysis, we found that lifters can generate IR code from non-optimized executables with a quality comparable to compiled IR used for discriminability analysis and C decompilation. This section further evaluates the generalizability of our findings across different compilers and optimization settings.

For this evaluation, we use GCC (version 7.5.0) and apply full compiler optimizations (-O3). McSema0, which consistently produces inferior results compared to McSema, is not included in this evaluation. The binary lifting results are detailed in Appendix D and generally align with those reported in Table V.

Table XI summarizes the results for various settings, with the last row representing Clang-generated LLVM IR. For the decompilation evaluation of BinRec, a dynamic tool, the data in parentheses represents the estimated #goto and LOC if full coverage was achieved. mctoll fails to lift all SPEC programs, resulting in "NA" values. In terms of discriminability analysis, RetDec shows high robustness across different compilation and optimization settings. Conversely, mctoll and McSema perform poorly when full optimizations are applied or when using the GCC compiler. Specifically, mctoll generates broken IR fragments when lifting some GCC-compiled executables, often without issuing warnings. The mctoll developers [13] acknowledge that lifting GCC-compiled executables is not fully tested. McSema leverages and extends the optimization passes of the LLVM framework [14], which are more effective for Clang-compiled executables. We observed that IR lifted from GCC-compiled executables is generally longer than that from Clang-compiled executables, which explains the lower effectiveness of McSema optimizations and the reduced accuracy in discriminability analysis for GCC settings. BinRec also shows low support for discriminability analysis, consistent with findings in Section VI-C.

Table XI suggests that applying full optimizations (-O3) in decompilation leads to less structured programs, as indicated by higher #goto and greater LOC. Compiler optimizations pose additional challenges for reverse engineering. However, in Section IX and Appendix C, we discuss how popular commercial decompilers, such as IDA-Pro and Ghidra [86], exhibit similar trends with optimized executables. For example, Table XIV in Appendix C shows that #goto increases by 5.4 times in IDA-Pro's decompiled C code when comparing -O3 and -O0 settings. In contrast, the increase in #goto for RetDec-lifted IR code is only 3.8 times, indicating better performance. Neither lifters nor commercial decompilers provide foolproof solutions for C decompilation, but our evaluations suggest the practical value of lifter-driven, particularly RetDec-based, solutions. The high #goto in C code decompiled from McSema-lifted IR and BinRec-lifted IR for the gcc -O0 setting is due to the need for -O0 to correctly lift several large SPEC programs, leading to many goto statements and increased average #goto.

### IX. COMPARISON WITH BINARY-ONLY TOOLS

Our goal is to determine whether lifted IR code supports downstream security tasks as effectively as Clang-generated IR code. Section VI evaluated three core tasks for downstream security applications. To directly compare with binary-only security analysis, we assess binary-only tools and lifter-enabled solutions in three tasks: sanitization, binary diffing, and decompilation. This section summarizes key findings, with details provided in Appendices A, B, and C, respectively.

Appendix A compares RetroWrite [43], a binary rewriting framework, with lifters in applying AddressSanitizer (ASan) [98] to executables. While RetroWrite does not aim to recover variables, binary lifters, especially RetDec, can (imprecisely) recover variables and function local stacks. Conceptually, this differentiates RetroWrite, which only enables coarse-grained stack frame-level ASan insertion. Empirically, we compare McSema and RetDec with RetroWrite by inserting ASan checks into the Juliet test programs. Due to the low functionality correctness of RetDec-lifted IR code (see Section VI-E), many RetDec-lifted IR programs are non-functional, making it meaningless to benchmark their stack sanitization quality. Out of 3,497 Juliet test cases containing heap vulnerabilities, McSema correctly lifts 2,187 cases and achieves promising heap sanitization accuracy comparable to RetroWrite. However, the original program stack is not protectable, as McSema uses an emulation stack in its generated IR code. With further enhancements in functionality correctness, McSema has the potential to sanitize executables and detect heap exploitations. Our study in Appendix A, both conceptually and empirically, illustrates that neither binary-only nor lifter-driven solutions can enable full-fledged sanitization. We also discuss the strengths (e.g., cross-platform support) and weaknesses (e.g., performance penalty) of lifter-driven sanitization compared to RetroWrite in Appendix A.

Appendix B compares lifter-enabled binary diffing with the state-of-the-art research tool, DeepBinDiff [46], and the industrial standard tool, BinDiff [2]. Lifter-enabled approaches show encouraging performance in binary diffing, comparable to DeepBinDiff, indicating their potential for security tasks such as malware clustering and CVE/patch searching [120], [124], [121]. Additionally, Appendix C assesses the quality of decompiled code, comparing lifter-enabled decompilation with commercial decompilers, IDA-Pro and Ghidra. These commercial decompilers generate more structured code in most settings (see Table XIV), but lifter-enabled solutions exhibit reasonable decompilation quality and appealing extensibility, and are cost-free.

### X. DISCUSSION

#### Analyzing Binary Code with LLVM: Are We There Yet?

As clarified in Section IV, "recompilation" is challenging. However, the research community and industry have provided lifters that generally pass functionality testing and formal verifications [38], [66]. Our study in Section VI-E further shows that emulation-style lifters can generate functionality-preserving IR code, laying a solid foundation for code patching, migration, and reuse.

IR lifting, like most reverse engineering tasks, is not decidable. This may lead to pessimism about the quality of lifted IR code. However, in daily security tasks, the impact of applying analysis utilities to lifted IR code is a critical consideration. This Systematization of Knowledge (SoK) paper aims to understand the current status of lifter-driven static security tasks, summarizing existing knowledge and identifying further efforts needed to link low-level security analysis with the LLVM framework. Our study enhances confidence in using lifters for security tasks related to discriminability analysis, decompilation, and sanitization. While out-of-the-box usage of lifters for rigorous static analysis is not yet feasible, Appendix E explores enhancements using Debin.

#### Fostering Other Security Tasks

Beyond the tasks evaluated in this paper, we envision using lifters to foster other security tasks. For instance, recent works [84] have studied using lifters in binary-only fuzzing. Given that code has been lifted into LLVM IR, it is natural to explore bug detection, security patching, and migration using industrial-strength LLVM-driven solutions [88], [96], [27], [50], [94]. However, these applications require the correctness of lifted IR code. While our study in Section VI-E shows encouraging correctness of emulation-style lifters, this lifting scheme can introduce more overhead due to emulated computations in LLVM IR.

#### Future Works

As a future research direction, we propose developing "lifter-oriented" static analysis algorithms. For example, emulation-style lifting (e.g., McSema) uses a global array to emulate physical memory stack access in machine code. This necessitates scalable field-sensitive static analysis [90] to track contents within each array element separately. We plan to benchmark and potentially calibrate standard field-sensitive pointer analysis for analyzing McSema-lifted IR.

Emulation-style IR (EIR) can guarantee functional correctness but lacks expressiveness. High-level IR (HIR), on the other hand, aims to recover high-level code features but can generate mal-functional code. Enhancing the quality of EIR and HIR is crucial, and compiled-IR (CIR) might help. Specifically, transforming EIR to HIR (EIR → HIR) involves conservatively lifting in a functionality-correct manner. One approach is to use a sequence of semantics-preserving transformations to gradually change EIR into HIR, minimizing the distance between EIR and HIR. However, this task is not fundamentally easier than lifting assembly into EIR, as it requires addressing well-known challenges like variable and type recovery. The SecondWrite papers [19], [47] aim to solve EIR → HIR with sound techniques; see Section XI for more information.

Learning from CIR to fix HIR (HIR ← CIR) involves enhancing the functional correctness of HIR by learning from corresponding CIR. Recent advances in binary-to-source matching with neural models might be inspiring [119]. We tentatively investigated the feasibility of "HIR ← CIR" and found it to be much harder than expected. Manual line-by-line comparisons of mal-functional HIR with CIR exposed inconsistencies primarily due to reverse engineering uncertainties, not errors. Defects in HIR, such as ill-lifted local variables, are difficult to recognize, even for human experts.

### XI. RELATED WORK

Binary lifters can lift an executable into a standard compiler IR (LLVM or GCC) or customized IR. SecondWrite [19], [47] lifts machine code into LLVM IR and refines it with type inference and symbolic execution, generating high-quality LLVM IR that supports code optimization. Egalito [115] proposes a binary layout-agnostic IR, supporting fool-proof recompilation on complex SPEC programs with negligible cost. Inception [37] introduces a "lift-and-merge" process, lifting ARM32 binary code into LLVM IR and merging it with LLVM bitcode compiled from source code to enable symbolic execution. BinRec enhances dynamic lifting using symbolic execution and path merging [18]. Instrew maintains a code cache [48] to avoid repeatedly lifting the same code during dynamic lifting. LISC [58] automates the generation of assembly-to-IR lifting rules by learning from how compilers translate IR into assembly instructions. Wang et al. [113] propose learning translation rules for existing dynamic binary translators and use symbolic execution to validate the learned rules.

[93] studies the differences between using compiled IR, lifted IR, or assembly code for symbolic execution. Our work differs from [93] in that it compares the S2E symbolic engine, designed for lifted LLVM IR, with KLEE, a symbolic execution engine for compiled LLVM IR. Our systematic study explores the direct reuse of LLVM analysis facilities for lifted IR, which could push the community towards leveraging decades of compiler passes for low-level machine code analysis without reinventing the wheel.

### XII. CONCLUSION

We present a study of binary lifters regarding their support for downstream applications. We set up three tasks commonly used in security applications and evaluate them under different compilation settings. We also compare lifter-enabled approaches with binary-only solutions across three security tasks. Our findings indicate that lifted LLVM IR code shows promising support for discriminability analysis and C decompilation but performs poorly for static analysis. These insights can guide users and developers aiming to use and enhance lifters.

### ACKNOWLEDGEMENT

We thank anonymous reviewers and our shepherd, Michael Franz, for their valuable feedback. We also thank Fabian Parzefall and Joseph Nash for their significant help and advice in setting up BinRec. This research was supported in part by a RGC ECS grant under the contract 26206520.

### REFERENCES

[1] Research Artifact. https://github.com/monkbai/ir
[2] BinDiff. https://www.zynamics.com/bindiff.html, 2014.
[3] radare2. http://www.radare.org/r/, 2016.
[4] Bin2LLVM. https://github.com/cojocar/bin2llvm, 2017.
[5] Possible to access higher-level IR in decompilation process. https://github.com/NationalSecurityAgency/ghidra/issues/978, 2019.
[6] RetDec data types propagation. https://github.com/avast/retdec/blob/567c30e3dd4c572fa825d8781ed69652306a961e/src/bin2llvmir/optimizations/types propagator/types propagator.cpp, 2020.
[7] RetDec function prototype inference. https://github.com/avast/retdec/blob/567c30e3dd4c572fa825d8781ed69652306a961e/src/bin2llvmir/optimizations/param return/param return.cpp, 2020.
[8] RetDec simple types recovery.