The client’s ﬁrst message to the server is shown in ﬁgure 2b. It
begins with a randomly chosen Möller key encapsulation, followed
Rekeying is very similar to key derivation for a new link, but uses
blocks rather than special handshake messages. Rekeying resets
the sequence number but does not change the link ID. Either peer
may initiate a rekeying cycle at any time by transmitting an rki
block. Peers are required to rekey before the sequence number
wraps around, and encouraged to rekey considerably sooner.
An rki block’s data section is simply an ECDH message on curve
112P-256. The recipient of this message responds with an rkr block,
whose data section is another ECDH message. Upon receipt of rkr,
both peers derive new link keys from the Diﬃe-Hellman exchange,
just as they would have for a new link. It is a protocol error to
transmit any blocks after rki until receipt of rkr, or to transmit
blocks using the old keys after transmitting rkr.
3.4 Link Termination
When both sides have sent and received a fin block, the link is
closed; however, both sides must remember the link ID for some
time, to guard against replay attacks or delayed block arrival. It is a
protocol error to transmit a data block with a nonzero d ﬁeld after
transmitting a fin block; however, data blocks with d = 0 may still
be sent, and other function codes may be used if appropriate. For
instance, the rki block requires a response, even if the recipient has
already transmitted a fin.
4. STEGANOGRAPHY
In this section, we describe two proof-of-concept steganography
modules: one that duplicates the packet sizes and timings of en-
crypted peer-to-peer protocols, and one that mimics HTTP. These
modules illustrate the ﬂexibility and feasibility of the StegoTorus
framework. However, they are not expected to resist sophisticated,
targeted attacks that might be launched by a nation-state adver-
sary. To underscore this, for each module we also describe potential
attacks and the level of sophistication each requires.
More diverse and resilient modules are under development, both
by us and the larger community, as the arms race continues. The
StegoTorus client can be conﬁgured to use whichever modules the
adversary has not yet blocked; therefore, ultimately, the adversary
will have to detect and block traﬃc generated by all of the steganog-
raphy modules in order to block StegoTorus.
4.1 Embed Module
The embed steganography module conceals Tor traﬃc within an
encrypted, peer-to-peer cover protocol, such as the popular Skype
and Ventrilo protocols for secure voice over IP. (Ventrilo is not
strictly a peer-to-peer protocol, but its users typically set up their
own servers, so there is no small, stable set of server IPs that could
be whitelisted.) Since the audio payload of each packet is encrypted,
we can substitute our own encrypted data without fear of payload
inspection. This leaves cleartext headers, packet sizes, and inter-
packet timings as the characteristics visible to the censor.
4.1.1 Packet Traces
This module relies on a database of packet traces, pre-recorded
sequences of packet sizes and timings from real sessions of the cover
protocol. Client and server match the recorded packet sizes exactly,
and timings to the nearest millisecond. If there is no data available
when a packet should be sent, they will fabricate padding-only
blocks to maintain the deception.
The server does not maintain its own database of traces; instead,
the client transmits its chosen trace to the server as a special control
message, immediately after link setup. Some of these traces are
distributed with the software, but users are encouraged to capture
their own use of the cover protocol, so that the censor cannot block
StegoTorus by pattern-matching against the distributed set of traces.
(Packet timings seen by the client may or may not correspond to
packet timings as actually transmitted by the server. For greater
realism, one should capture a trace from both ends, but we have not
implemented this yet.)
Potential Attacks: Some VoIP protocols permit an eavesdropping
adversary to learn much about the speech being transmitted, just
from packet sizes and timings [68]. Therefore, if traces are reused
too often, the censor might become suspicious of users apparently
having the exact same conversation over and over again.
4.1.2 Application Headers
The packet trace does not attempt to capture application headers,
as these may depend on the substituted contents. Instead, the embed
module includes emulation code for each potential cover protocol.
Unfortunately, neither the Skype nor the Ventrilo protocol has a
public speciﬁcation, necessitating reverse engineering. To date this
has been done by hand, but we are investigating the possibility of
automating the process [12, 15, 44].
Potential Attacks: If the censor has access to the true protocol
speciﬁcation for a protocol we have reverse engineered, they may
be able to detect deviations on our part.
Even if the censor doesn’t have this information, it might choose
to block all apparent VoIP protocols, or all peer-to-peer traﬃc that
appears to contain encrypted data. These are popular, but not yet
so popular that this would amount to “turning oﬀ the Internet,”
and there are plausible political cover stories for such actions by
a nation-state: preserving telephone revenue, combating copyright
infringement, etc.
4.2 HTTP Module
The HTTP steganography module simulates unencrypted HTTP
traﬃc. Since the censor can observe the overt content of this mod-
ule’s traﬃc, and protocol decoders for HTTP are ubiquitous, we take
care to mimic “real” browser and website behavior as accurately as
possible.
HTTP [28] follows a strict pattern: the client sends a request,
waits for the server to produce a response, can then send another
request, and so on. HTTP 1.1 allows the client to send several
requests in a row without waiting for responses (“pipelining”) but
this is rarely used, due to server bugs [55]. Instead, clients achieve
parallelism by opening multiple connections to the same server.
Each request contains a “method” (get, post, etc) that controls what
the server will do to prepare the response.
The HTTP module also relies on a database of pre-recorded HTTP
requests and responses; we also refer to these as “traces.” Like the
embed module’s traces, some are distributed with the program, and
users are encouraged to record their own. Unlike embed, requests
and responses are not organized into a temporal sequence, and client
and server use independent databases. However, the server generates
responses that are consistent with client requests; for instance, if a
client sends a request for a PDF document, the server will produce
a PDF covertext.
4.2.1 Request Generator
Normal HTTP client-to-server traﬃc consists almost entirely
of get requests. Unfortunately, these provide very little space to
conceal our hiddentexts. Here is a typical request template from our
database:
GET /  HTTP /1.1
Accept : text / html , application / xhtml +xml ,
application / xml ;q =0.9 ,*/*; q =0.8
Accept - Encoding : gzip , deflate
Accept - Language : en -us , en ;q =0.5
Connection : keep - alive
Host : 
User - Agent : Mozilla /5.0 ( X11 ; Linux x86_64 ; rv :10.0)
Gecko /20100101 Firefox /10.0
Cookie : 
Nearly all of this is boilerplate that must be sent verbatim in every
request. Data can be inserted at each position marked , but it
must be properly encoded.
113At present we only store hiddentext in the  and 
positions, which can carry arbitrary textual data. We encode the
binary chopper output in a modiﬁed base64 alphabet [39] that
avoids characters with special meaning in URIs or cookies: ‘+’ is
replaced by ‘-’, ‘/’ by ‘_’, and ‘=’ by ‘.’. We then insert characters
at random positions in the encoded string, to make it look more like
a genuine URI or cookie header: for URIs we insert ‘/’, for cookies
we alternate between ‘=’ and ‘;’.
The  can theoretically also carry hiddentext, but with
more diﬃculty:  must have the form of a DNS hostname
or IP address [28], and the censor could block HTTP connections
where it was not a registered hostname for the IP address to which
the client was connected. Presently, we do not attempt this; instead
we do a reverse DNS lookup on the server’s IP address, and use the
ﬁrst reported name in every request to that address.
Potential Attacks: To the human eye, the HTTP request generator’s
URIs and cookies likely look diﬀerent from normal URIs or cookies.
The pattern of requests that it generates is also potentially diﬀerent
from the pattern of requests generated by a visit to a real website.
Hence, it would be possible for an adversary to build a machine
classiﬁer that can make the same judgment. The cookie string we
send changes on every request, without the server sending back
Set-Cookie: directives; this could also be a distinguisher, as a
real web browser only changes cookies when instructed to. If such
attacks become common, they we may be limited in our use of
cookies as a carrier channel. More sophisticated cookie, URI, and
request pattern generation is also possible; Infranet [27], for instance,
devotes some eﬀort to this problem. However, substantially more
overhead will be required.
The User-Agent header identiﬁes the browser and operating
system in use. If the same client IP address consistently produces
one user-agent, except during a handful of browsing sessions, that
handful might attract attention. Generating a database of client
requests on each user’s machine ensures that we generate user-agent
headers matching the browser that that user normally uses.
The censor may conduct active attacks by replaying HTTP re-
quests; a real web server would normally produce the same response,
but StegoTorus will not. To mitigate this we could place an oﬀ-the-
shelf HTTP “accelerator” cache in front of the StegoTorus server
so that, for a short time, replayed requests would produce the same
response as the original.
4.2.2 Response Generator
HTTP responses begin with a few headers, similar to the ones
shown above, but oﬀering even less space for hiddentext. However,
they continue with a “response body” which is designed to carry ar-
bitrary data. That data typically conforms to some known ﬁle format,
which must be consistent with the contents of the request. We have
developed response generators that embed StegoTorus hiddentexts
in three common ﬁle formats: JavaScript, PDF, and Flash. These
data formats are complex enough to conceal hiddentexts easily, and
pervasive enough that blocking them would break far too many
popular websites to be politically tenable. Generators for HTML
and various image, audio, and video formats are under development.
JavaScript Generator: JavaScript is a programming language,
human-readable in its original form, but frequently “miniﬁed” to
reduce its size on the wire. Miniﬁcation involves removing all white
space and replacing variable names with shorter machine-generated
identiﬁers. There is an enormous volume of JavaScript in use on the
open web: 2.5% of all bytes transferred by HTTP in early 2009 [46].
This generator picks a response containing JavaScript, scans it
for identiﬁers and numbers, and replaces them with characters from
the hexadecimal encoding of the hiddentext. To preserve syntactic
validity, the encoder will not change the ﬁrst character of an identiﬁer
or a number, and there is a blacklist of JavaScript keywords and
built-in functions that should not be replaced. The decoder simply
reverses the process. Our objective with this module is to produce
syntactically valid JavaScript that cannot be trivially detected by a
parser.
PDF Generator: PDF documents consist of a sequence of “ob-
jects,” which deﬁne pages, images, fonts, and so on. Many of these
objects will normally be compressed, using the ubiquitous “deﬂate”
algorithm, to save space. The PDF response generator locates com-
pressed objects within a PDF document from the HTTP response
database, and replaces their contents with our hiddentexts. Chopper
output is incompressible, but we apply the “deﬂate” transformation
to it anyway, so that each modiﬁed object’s contents is still superﬁ-
cially what it ought to be. The overall ﬁle structure is adjusted to
match.
SWF Generator: Adobe (formerly Shockwave) Flash is a format
for vector-graphic animations, and is also frequently used as a con-
tainer for video. Flash ﬁles consist of a sequence of tagged data
blocks, containing shapes, buttons, bitmaps, ActionScript byte code,
etc. [1] Flash ﬁles may be compressed (CWS) or uncompressed
(FWS). In the more common CWS format, the entire ﬁle (with the
exception of a short initial header, but including the block framing)
is compressed with “deﬂate.” The SWF response generator uncom-
presses a template CWS ﬁle, replaces block contents with encrypted
data, and recompresses the result.
Potential Attacks: The HTTP response generator attempts to pre-
serve the syntactic validity of JavaScript, PDF and SWF ﬁles that
it modiﬁes. However, it does not attempt to preserve the semantics
of JavaScript or the original content of PDF or SWF. Therefore,
adversaries might be able to detect the use of the present HTTP gen-
erator by attempting to execute JavaScript, render PDF documents,
or play back Flash animations. However, doing so at line rate on
a border router would be quite challenging. The ﬁlter would have
to extract HTTP response bodies of interest, reassemble packets
into streams, and then parse and decode the contents of the ﬁle;
all of these are expensive and complicated operations. Providing
the appropriate execution environment for JavaScript requires the
adversary to assemble and process all the data of the surrounding
webpage, just as a browser would.
Nonetheless, we do expect that if StegoTorus comes into wide use,
ﬁltering routers will gain the ability to detect these simple schemes.
In particular, a natural escalation of the arms race might involve the
use of cascading detectors, where a series of fast ﬁlters select traﬃc
to subject to more expensive analyses. If this happens, we would
have to implement more sophisticated steganography.
5. DETECTION RESISTANCE
To evaluate how well StegoTorus can conceal a Tor stream, we
developed two attacks upon Tor, which StegoTorus ought to defeat
if it is functioning as intended. We designed these attacks to be
practical in the resource-constrained environment of a perimeter
ﬁlter (as described in Section 2.2.2) so they are deliberately quite
simple. The ﬁrst attack picks Tor streams out of other TCP streams,
based on a fundamental characteristic of the Tor wire protocol that
is cheap to detect. The second attack operates on known Tor streams
and extracts information about the sites being visited covertly. In
each case we will ﬁrst describe the attack and how it fares against
Tor, then discuss its eﬀectiveness against StegoTorus. As we did for
the steganography modules, we will also discuss potential improve-
ments to the attacks that might be implemented by an adversary
determined to detect StegoTorus.
114Not Tor (63,518 ﬂows)
Tor (67 ﬂows)
% of col.
20%
40%
60%
80%
1500
1250
1172
1098
586
100
0
e
z
i
s
t
e
k
c
a
P
1
5
10
15
20
1
5
10
15