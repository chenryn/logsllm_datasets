views? Consider replica r votes for Bk at time t − 3∆ and syn-
chronously commits at time t. Note that no honest replica has
entered a higher view by time t − ∆. This implies all honest replicas
receive Cv(Bk) by time t − ∆. Any view-change after t − ∆ will
receive Cv(Bk) or higher and honest replicas will lock on chain
certificate CC such that tip(CC) extends Cv(Bk) before entering a
higher view.
Why is it safe to vote for a valid new-view message with a
lower ranked lock? The commit rules in the protocol ensure that
there does not exist an equivocating chain certificate CC′ such that
tip(CC′) does not extend committed blocks. This implies honest
replicas lock on chain certificates that extend the committed blocks.
After entering a higher view, honest replicas send their locked
chain certificates via a status message. The new leader collects a
status certificate S of f + 1 status messages, extends on the highest
ranked certified block in S. Note that an honest replica sends a
status message only after entering a higher view and has locked on
a chain certificate that extends committed blocks in the previous
view. As S contains status from at least one honest replica, the
highest ranked chain certificate lock′ in S will extend committed
blocks in the previous view. Thus, it is safe for replicas to unlock a
lock with a rank higher than lock′.
In the new view, due to the status certificate, all honest replicas
will vote for the new-view message sent by an honest leader. Sub-
sequently, in the steady state, honest replicas will keep committing
new blocks.
6.3 Safety and Liveness
Claim 21. If a block Bk is committed directly in view v using the
responsive commit rule, then there does not exist a chain certificate
CC′ in view v such that CC′ > CC where tip(CC) extends Bk and
a block in CC′ equivocates Bk .
Proof. If a replica r responsively commits a block Bk in view v, then
r must have received ⌊3n/4⌋ + 1 distinct commit messages out of
which at least a set R of ⌊(n − f )/2 + 1⌋ are from honest replicas.
An honest replica (say, r′ ∈ R) sends commit message only if it
pre-commits and has not sent a blame message.
Replica r′ can pre-commit in two ways. First, r′ received ⌊3n/4⌋+
1 votes for Bk in view v and pre-committed responsively. This case
is identical to responsive commit rule for the protocol in Section 4.
By Claim 8, an equivocating chain certificate CC′ of rank higher
than (C3/4
v (Bk),⊥) cannot exist in view v. Second, replica r′ voted
for Bk at time t − 2∆ and received no equivocation or blame cer-
tificate by time t and synchronously pre-commits at time t. This
case is identical to synchronous commit rule for the protocol in
Section 4. By Claim 9, there does not exist a block certificate for
an equivocating block in view v. Thus, chain certificate CC′ with
an equivocating block such that CC′ > CC cannot exist in view
v.
□
Claim 22. If a block Bk is directly committed in view v, using the
synchronous commit rule then there does not exist a chain certificate
CC′ in view v such that CC′ > CC where tip(CC) extends Bk and
a block in CC′ equivocates Bk .
Proof. Replica r synchronously commits a block Bk when its commit-timerv,k
expires. Replica r could pre-commit in two ways. First, replica r
pre-commits responsively. The responsive pre-commit rule is iden-
tical to the responsive commit rule for the protocol in Section 4. By
Claim 8, an equivocating chain certificate CC′ of rank higher than
(C3/4
v (Bk),⊥) cannot exist in view v.
Second, replica r synchronously pre-commits at time t, i.e., it
voted for Bk at time t − 2∆ and received no equivocation or blame
certificate by time t. This case is identical to synchronous commit
rule for the protocol in Section 4. By Claim 9, there does not exist a
block certificate for an equivocating block in view v. Thus, chain
certificate CC′ with an equivocating block cannot exist in view
v.
□
Lemma 23. If a block Bk is directly committed in view v, then there
does not exist a chain certificate CC′ in view v such that CC′ > CC
where tip(CC) extends Bk and a block in CC′ equivocates Bk .
Proof. Straightforward from Claim 21 and Claim 22.
all honest replicas enter view v at time ≤ t + ∆. We note that no
honest replica has quit view v at time ≤ t + ∆; otherwise, replica r
receives a blame certificate at time ≤ t + 2∆. This proves part (i) of
the claim.
Replica r received a proposal for Bk which contains Cv(Bk−1) at
time t. Replica r’s vote and forwarded proposal for Bk arrives at all
honest replicas at time ≤ t + ∆. No honest replica has voted for an
equivocating block or received a blame certificate at time ≤ t + ∆;
otherwise replica r would have received an equivocation or blame
certificate at time ≤ t + 2∆. Thus, all honest replicas will vote for
Bk at time ≤ t + ∆. This proves part (ii) of the claim.
□
Claim 25. Let Bk be a block proposed in view v using Step 1 in
Figure 5. If an honest replica votes for Bk at time t in view v and
detects no equivocation or blame certificate at time ≤ t + 3∆, then
(i) all honest replicas are still in view v at time t + 2∆ (ii) all honest
replicas receive Cv(Bk) at time ≤ t + 2∆.
Proof. Suppose an honest replica r votes for a block Bk at time t
in view v and detects no equivocation or blame certificate by time
t +3∆. Trivially, replica r has not received an equivocation or blame
certificate by time t + 2∆. By Claim 24 (i), all honest replicas are
in view v at time t + ∆. No honest replica has quit view v by time
t + 2∆; otherwise replica r must receive blame certificate by time
t + 3∆ contradicting our hypothesis. Thus, all honest replicas are
still in view v at time t + 2∆. This proves part (i) of the claim.
If replica r receives no equivocation or blame certificate at time
≤ t + 3∆, it is easy to see that replica r receives no equivocation or
blame certificate by time t + 2∆. By Claim 24, all honest replicas
vote at time ≤ t + ∆. By synchrony assumption, all honest replicas
receive at least f + 1 votes for Bk i.e., Cv(Bk) at time ≤ t + 2∆. This
proves part (ii) of the claim.
□
Claim 26. If an honest replica directly commits a block Bk in view
v using the responsive commit rule, then all honest replicas receive
a chain certificate CC before entering view v + 1 such that tip(CC)
extends Bk .
Proof. We first discuss the case where some replica performs a view-
change due to a responsive quit-view certificate, and then discuss a
view-change due to a synchronous blame certificate. Suppose an
3/4
of ⌊3n/4⌋ + 1 commit messages
honest replica r receives a set Q
C
for block Bk in view v and responsively commits Bk at time t.
3/4
must have received Cv(Bk) before
Thus, all honest replicas in Q
C
sending the commit message. By Claim 21, there does not exist
a chain certificate CC′ in view v such that CC′ > CC where
tip(CC) extends Bk and a block in CC′ equivocates Bk. Consider
that made some honest replica r′ enter view v + 1.
the quorum Q
r′ receives a responsive quit-view certificate of ⌊3n/4⌋ + 1 quit-
view messages each of which contains a chain certificate when the
quit-view message was sent. By quorum intersection argument,
3/4
must intersect in at least one honest replica. Thus,
Q
C
the intersecting honest replica must include a higher ranked chain
certificate CC where tip(CC) extends Bk in quit-view message.
This implies any replica that makes a responsive view-change must
receive CC before entering view v + 1.
Consider a view-change due to a synchronous blame certificate.
Observe that any honest replica (say, replica u) that quits view v
and Q
3/4
B
3/4
B
□
Claim 24. Let Bk be a block proposed in view v using Step 1 in
Figure 5. If an honest replica votes for Bk at time t in view v and
detects no equivocation or blame certificate at time ≤ t + 2∆, then (i)
all honest replicas are in view v at time t + ∆, (ii) all honest replicas
vote for Bk at time ≤ t + ∆.
Proof. Suppose an honest replica r votes for Bk at time t in view
v and detects no equivocation or blame certificate by time t + 2∆.
This implies two facts. First, replica r entered view v at time ≤ t. If
r entered view v responsively, i.e., by receiving a responsive quit-
of ⌊3n/4⌋ + 1 quit-view messages, it must
view certificate, Q
have sent Q
and
enter view v at time ≤ t + ∆. If r quit the previous view due to
f + 1 blame messages, it must have sent the blame certificate at
time ≤ t − 2∆ which arrives all honest replicas at time ≤ t − ∆.
Due to the 2∆ wait after receiving f + 1-sized blame certificate,
at time ≤ t. All honest replicas receive Q
3/4
B
3/4
B
3/4
B
due to a synchronous blame certificate has not entered view v + 1
at time t + ∆; otherwise replica u must have sent a blame certificate
at time ≤ t − ∆ (due to the 2∆ wait in the status step) and r must
receive the blame certificate at time ≤ t and r wouldn’t commit.
Let t′ be the time in which replica u enters view v + 1 (with
t′ > t + ∆). If some honest replica r′ in Q
pre-committed respon-
sively, r′ must have received a blame certificate between time t
and t′ − ∆ and sent a quit-view message containing CC and replica
u receives CC at time ≤ t′. Similarly, if replica r′ synchronously
pre-commits Bk by time t, it votes for Bk by time t − 2∆ and de-
tects no equivocation or blame certificate by time t. By Claim 24
(ii), all honest replicas vote for Bk by time t − ∆. Hence, replica u
receives Cv(Bk) by time t before entering view v + 1. This implies
any replica that makes a synchronous view-change has CC before
entering view v + 1 such that tip(CC) extends Bk.
□
3/4
C
Claim 27. If an honest replica directly commits a block Bk in view
v using the synchronous commit rule, then all honest replicas receive
a chain certificate CC before entering view v + 1 such that tip(CC)
extends Bk .
Proof. Suppose an honest replica r synchronously commits a block
Bk at time t in view v. Its commit-timerv,k for Bk expires at time
t without detecting an equivocation or blame certificate.
Replica r waits for 3∆ before its commit-timerv,k expires. Replica
r votes for Bk in view v at time t − 3∆ and detects no equivocation
or blame certificate by time t. By Claim 25, all honest replicas are
in view v at time t − ∆ and receive Cv(Bk) by time t − ∆. Thus,
all honest replicas receive Cv(Bk) before entering view v + 1. This
implies all honest replicas have a chain certificate CC such that
tip(CC) extends Bk.
□
Lemma 28. If an honest replica directly commits a block Bk in
view v, then all honest replicas have lockv +1 before entering view
v + 1 such that tip(lockv +1) extends Bk .
Proof. By Claim 26 and Claim 27, all honest replicas receive a certifi-
cate chain CC such that tip(CC) extends Bk. By Lemma 23, there
does not exists an equivocating chain certificate CC′ in view v
such that CC′ > CC. Since, honest replicas lock on highest ranked
chain certificate, all honest replicas update lockv +1 to CC with
tip(lockv +1) extending Bk.
□
Claim 29. If an honest replica directly commits a block Bk in view
v, the tip of a highest ranked chain certificate CC in a view v status
certificate, i.e., tip(CC) must extend Bk .
Proof. Suppose an honest replica r commits a block Bk in view v.
By Lemma 28, all honest replicas lock on CC before entering view
v + 1 such that tip(CC) extends Bk. An honest replica sends status
message containing their CC only after entering view v + 1. A view
v status certificate contains a set S of f + 1 status messages which
includes the status message from at least one honest replica. By
Lemma 23, there does not exist a chain certificate CC′ in view v
such that CC′ > CC where tip(CC) extends Bk and a block in CC′
equivocates Bk. Thus, the tip of highest ranked chain certificate
CC in S, i.e., tip(CC) must extend Bk.
□
Corollary 30. If the tip of highest ranked chain certificate CC
in a view v status certificate, i.e., tip(CC) does not extend a block Bk ,
then Bk has not been committed in view v.
Lemma 31 (Uniqe Extensibility). If an honest replica directly
commits a block Bk in view v, and Cv′(Bk′) is a view v′ > v block
certificate, then Bk′ extends Bk . Moreover, all honest replicas have
lockv′ such that tip(lockv +1) extends Bk .
Proof. The proof is by induction on the view v′ > v. For a view
v′, we prove that if Cv′(tip(lock′)) exists then it must extend Bk. A
simple induction then shows that all later block certificates must
also extend tip(lock′), this follows directly from the Vote rule in
line 2.
For the base case, where v′ = v +1, the proof that Cv′(tip(lock′))
extends Bk follows from Lemma 28 because the only way such a
block can be certified is if some honest replica votes for it. However,
all honest replicas are locked on a block that extends Bk and a
chain certificate with a higher rank for an equivocating block does
not exist. Although, honest replicas unlock on their locked chain
certificates lockv +1 and lock on a highest ranked chain certificate
lock′ in a status certificate S, by Claim 29, tip(lock′) must extend
Bk. Thus, no honest replica will first vote (Figure 2 step iii)) for
a block that does not extend Bk. The second part follows directly
from Lemma 28.
Given that the statement is true for all views below v′, the proof
that Cv′(tip(lock′)) extends Bk follows from the induction hypoth-
esis because the only way such a block can be certified is if some
honest votes for it. An honest party with a lock lock will vote only
if tip(lockv′) has a valid block certificate and lock ≥ lockv′. Due to
Lemma 28 and the induction hypothesis on all block certificates of
view v < v′′ < v′ is must be that Cv′(tip(lock)) extends Bk.
□
Safety. The safety proof remains identical to that of Theorem 14
except Lemma 23 and Lemma 31 needs to be invoked.
Theorem 32 (Liveness). All honest replicas keep committing new
blocks.
Proof. In a view, a leader has to propose at least p blocks that trigger
honest replica’s votes in (2p + 4)∆ time. As long as the leader
proposes at least p valid blocks, honest replicas will keep voting
for the blocks and keep committing the proposed blocks. If the
Byzantine leader equivocates or proposes less than p blocks, a view-
change will occur. Eventually, there will be an honest leader due to
round-robin leader election.
Next, we show that once the leader is honest, a view-change
will not occur and all honest replicas keep committing new blocks.
If a block Bk has been committed in a previous view, by Lemma