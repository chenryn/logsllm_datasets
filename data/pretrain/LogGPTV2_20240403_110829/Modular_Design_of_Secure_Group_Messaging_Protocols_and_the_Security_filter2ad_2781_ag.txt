Heidelberg, Feb. 2007.
[26] E. Rescorla. Subject: [MLS] TreeKEM: An alternative to ART. MLS Mailing List,
2018. https://mailarchive.ietf.org/arch/msg/mls/WRdXVr8iUwibaQu0tH6sDnqU1no.
[27] D. G. Steer, L. Strawczynski, W. Diffie, and M. J. Wiener. A secure audio telecon-
[28] D. Wallner, E. Hardner, and R. Agee. Key management for multicast: Issues and
ference system. In S. Goldwasser, editor, CRYPTO ’88, 1988.
architectures. IETF RFC2676, 1999. https://tools.ietf.org/html/rfc2627.
[29] M. Weidner. Group messaging for secure asynchronous collaboration. MPhil
Session 5C: Messaging and Privacy CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1476A CONTINUOUS GROUP KEY AGREEMENT
A.1 Syntax
This section introduces the formal syntax of a CGKA scheme. Par-
ties are identified by unique party IDs ID chosen from an arbitrary
fixed set. In the following, 𝛾 and 𝛾′ denote the internal state of the
CGKA scheme before and after an operation, respectively. A CGKA
scheme CGKA consists of eight algorithms:
• For PKI:
– (ipk, isk) ← Gen-IK: generates and outputs a new initial
key pair.
• For group creation:
– 𝛾′ ← Create(ID, isk): initializes the state and creates group
with self, using as init secret key isk.
• For proposals:
– (𝛾′, 𝑃) ← Add(𝛾, ID′, ipk′): generates a proposal to add
– (𝛾′, 𝑃) ← Remove(𝛾, ID′): generates a proposal to remove
– (𝛾′, 𝑃) ← Update(𝛾): generates a proposal for self to up-
party ID′ using initial public key ipk′;
party ID′;
date.
• For commits:
– (𝛾′, 𝐼,𝑊pub, Wpriv,𝑇 ) ← Commit(𝛾, P): creates a commit
corresponding to a vector P of proposals and outputs the
resulting commit secret 𝐼, a public welcome message 𝑊pub
as well as a vector Wpriv of private welcome messages
(for newly added parties), and a control message 𝑇 (for
existing group members);
– (𝛾′, GI, 𝐼) ← Proc-Com(𝛾,𝑇 , P): used by existing group
members to process control message 𝑇 w.r.t. vector of
proposals P, and reach new epoch; outputs updated group
information GI (where GI = ⊥ if 𝑇 is considered invalid)
and a commit secret 𝐼;
– (𝛾, GI, 𝐼) ← Join(𝛾, orig,𝑊pub,𝑊priv, isk): used by newly
added group members to process welcome message 𝑊pub
and 𝑊priv, generated via a commit operation by orig, and
join a group using initial secret key isk; outputs group
information GI (where GI = ⊥ if 𝑊pub or 𝑊priv are consid-
ered invalid) and a commit secret 𝐼.
A.2 Security
CGKA schemes must satisfy correctness, i.e., all group members
output the same keys in every epoch. Furthermore, the keys must
be private, and the CGKA scheme must satisfy post-compromise
forward secrecy (PCFS).
Similarly to the SGM game, the CGKA game allows adversary A
to control the execution of and attack a single group. In particular,
A controls who creates the group, who is added and removed, who
updates, who commits, etc. The attacker is also allowed to leak the
state of any party (whether currently part of the group or not) at
any time. The privacy of keys is captured by considering a challenge
that outputs either the actual key output by the CGKA scheme or a
truly random one—which one is determined by an internal random
bit 𝑏, which must be guessed by A at the end of the game.
A.2.1 Bookkeeping. Similarly to SGM schemes, the CGKA security
game keeps track of all the relevant execution data with the help
of a so-called history graph, and the recorded data informs a safety
predicate (pertaining to privacy) evaluated at the end of the game.
The following paragraphs outline the differences in bookkeeping
between the CGKA game and the SGM game.
History graphs. A history graph is again a directed tree whose
nodes correspond to the group state in the various epochs of an
execution. As with the SGM game, there are three types of nodes:
𝑣root, 𝑣create nodes, and commit nodes 𝑣. A node consists of the
following values:
𝑣 = (vid, orig, pid) ,
where
• vid is the node’s (unique) ID,
• orig is the party that caused the node’s creation, i.e., orig is
• pid is the vector of (IDs of) proposals (see below) that were
either the group creator or the committer,
included in the commit.
The history graph is accessed by the security-game oracles via the
“HG object” HG, which provides information via several methods
(explained later as they are needed). The (ID of the) node corre-
sponding to a party’s current state is stored by the array V-Pt[ID].
Proposals. Similarly to HG and the history graph, the object Props
keeps track of proposals. The information recorded about each
proposal is a vector
𝑝 = (pid, vid, op, orig, data) ,
where
in which the proposal was created,
• pid is the proposal’s (unique) ID,
• vid is the (ID of) the HG node corresponding to the epoch
• op ∈ {add, rem, upd} is the type of proposal,
• orig is the party that issued the proposal, and
• data is additional data.
Similarly to the HG object, Props will also export several useful
methods (also explained later) to the oracles of the security game.
PKI bookkeeping. The PKI is significantly simpler in the CGKA
game: it only handles so-called init keys (IKs), each of which has an
ID ikid. Arrays are maintained to map ikids to the corresponding
public init key (IK-PK) and secret init key (IK-SK). Moreover, IK-St
records the IKs stored by each party, and IK-Tr and IK-Lk keep track
of “trash” IKs (old secret init keys not deleted) and leaked IKs.
Keys and Challenges. The array Key[vid] stores, for each vid the cor-
responding key, and (the Boolean arrays) Reveal[vid] and Chall[vid]
store whether the key was revealed and challenged, respectively.
Initialization. The initialization of the CGKA game proceeds
A.2.2
along very similar lines to that of the SGM game. It is depicted in
Figure 9.
Session 5C: Messaging and Privacy CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1477// General
𝑏 ← {0, 1}
idCtr++
∀ID : 𝛾[ID] ← Init(ID)
// Communication
CM[·, ·] ← 𝜖
PM[·, ·] ← 𝜖
WMpub[·, ·] ← 𝜖
WMpriv[·, ·] ← 𝜖
WM-Lk ← ∅
// History Graph
vidroot ← HG.init
V-Pt[·] ← vidroot
V-Tr[·] ← ∅
Figure 9: Initialization of the security game for CGKA schemes.
V-Lk ← ∅
P-St[·] ← ∅
// Miscellaneous
Key[·] ← ∅
Reveal[·] ← ∅
Chall[·] ← ∅
Del[·] ← true
BR[·] ← false
// PKI
IK-PK[·] ← 𝜖
IK-SK[·] ← 𝜖
IK-St[·] ← ∅
IK-Tr ← ∅
IK-Lk ← ∅
A.2.3 Oracles. All adversary oracles described below proceed ac-
cording to the same pattern: (a) verifying the validity of the oracle
call, (b) retrieving values needed for (c), (c) running the correspond-
ing SGM algorithm, and (d) updating the bookkeeping. Validity
checks (a) are described informally in the text below; a formal de-
scription is provided in Figure 14. Note that, most of the time, (b) and
(c) are straight-forward and are not mentioned in the descriptions.
To improve readability, lines (c) are highlighted.
A.2.4 PKI.. The spirit of the PKI (Figure 10) in the CGKA game
differs somewhat from the SGM case. Init keys (IKs) are either
honestly generated by a party, via oracle gen-new-ik, or registered
by the attacker A, via oracle reg-ik. Note that the CGKA game will
allow the attacker to pick which IK a new group member is added
with; hence, there is no association between IKs and identities.
Oracle gen-new-ik(ID) runs the IK-generation algorithm Gen-IK
and stores the resulting key pair with a new ikid. The oracle also
records in IK-St that ID now stores the IK with ID ikid. Oracle
reg-ik(ipk) allows A to register an IK public key ipk with the game
(and get an ikid for it).
A.2.5 Main oracles. The main oracles of the CGKA game are split
into two figures: oracles related to (i) group creation, proposals, and
commits (Figure 11), and (ii) message processing, corruption, and
challenges (Figure 13). The validity of all oracle calls is checked by
the corresponding compatibility functions (Figure 14).
Group creation. The attacker can instruct a party ID to create a
new group by calling the group-creation oracle (Figure 3), which
works analogously to the corresponding oracle in the SGM game.
The bookkeeping is updated as follows: A call is made to the
HG.create(ID, skid) method. This causes HG to create a node
𝑣 = (cid:169)(cid:173)(cid:171)
.vid
.orig
.pid
←
←
←
idCtr++
ID
⊥
(cid:170)(cid:174)(cid:172)
// Instruct ID to generate a new initial key
gen-new-ik(ID)
(𝛾[ID], (ipk, isk)) ← Gen-IK(𝛾[ID])
ikid ← idCtr++
IK-PK[ikid] ← ipk
IK-SK[ikid] ← isk
IK-St[ID] +← ikid
return (ikid, ipk)
// Allows attacker to register IKs with game
reg-ik(ipk)
req ̸∃ ikid : IK-PK[ikid] = ipk
ikid ← idCtr++
IK-Lk +← ikid
IK-PK[ikid] ← ipk
return ikid
Figure 10: PKI-related oracles of the security game for contin-
uous group key agreement schemes.
as a child of 𝑣root and return vid = 𝑣.vid. Note that the CGKA group-
creation oracle also stores the key 𝐼 output by Create in the array
Key.
Proposal oracles. The oracles prop-{add, rem, up}-user (Figure 11)
allow the attacker to instruct a party ID to issue add/remove/update
proposals. These oracles work much like their counterparts in the
SGM game. Bookkeeping is updated by calling Props.new(op, ID, data),
which records proposal data
(cid:169)(cid:173)(cid:173)(cid:173)(cid:173)(cid:173)(cid:171)
𝑝 =
.pid
.vid
.op
.orig
.data
←
←
←
←
←
idCtr++
V-Pt[ID]
op
ID
data
(cid:170)(cid:174)(cid:174)(cid:174)(cid:174)(cid:174)(cid:172) ,
where op ∈ {add, rem, upd} is the proposal type and where data
stores
• (add proposals) data = (ID′, ikid′), where ikid′ is the (ID of
the) init key ID′ is to be added with;
• (remove proposals) data = ID′;
• (update proposals) data = ⊥.
Observe that one crucial difference between the CGKA and SGM
games is that the CGKA game does not explicitly model the delivery
of proposals. This is due to the fact that a CGKA is assumed to be
run over authenticated channels, and hence there is no way for A
to inject malicious proposals, and, consequently, the proper delivery
of proposals can be outsourced to the higher-level protocol.
Creating commits. The commit oracle (Figure 11) allows A to
instruct a party ID to execute a commit operations. It works analo-
gously to its SGM-game counterpart. Bookkeeping calls
HG.commit(ID, pid), which creates a new HG node
𝑣 = (cid:169)(cid:173)(cid:171)
.vid
.orig
.pid
←
←
←
(cid:170)(cid:174)(cid:172)
idCtr++
ID
pid
Session 5C: Messaging and Privacy CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1478// ID creates new group
create-group(ID, ikid, 𝑟)
req *compat-create(ID, ikid)
isk ← IK-SK[ikid]
(𝛾[ID], 𝐼) ← Create(𝛾[ID], isk; 𝑟)
vid ← HG.create(ID, 𝑟)
Key[vid] ← 𝐼
BR[vid] ← (𝑟 ̸= ⊥)
V-Pt[ID] ← vid
return vid
// ID proposes to add ID′
prop-add-user(ID, ID′, ikid′)
req *compat-prop(add, ID, ID′, ikid′)
ipk′ ← IK-PK[ikid′]
(𝛾[ID], 𝑃) ← Add(𝛾[ID], ID′, ipk′)
pid ← Props.new(add, ID, (ID′, ikid′))
PM[pid] ← 𝑃
return (pid, 𝑃)
// ID proposes to remove ID′
prop-rem-user(ID, ID′)
req *compat-prop(rem, ID, ID′,⊥)
(𝛾[ID], 𝑃) ← Remove(𝛾[ID], ID′)
pid ← Props.new(rem, ID, ID′)
PM[pid] ← 𝑃
return (pid, 𝑃)
// ID proposes to update
prop-up-user(ID, 𝑟)
req *compat-prop(upd, ID,⊥,⊥)
(𝛾[ID], 𝑃) ← Update(𝛾[ID]; 𝑟)
pid ← Props.new(upd, ID,⊥)
BR[vid] ← (𝑟 ̸= ⊥)
PM[pid] ← 𝑃
return (pid, 𝑃)
// ID commits proposals pid
commit(ID, pid, 𝑟)