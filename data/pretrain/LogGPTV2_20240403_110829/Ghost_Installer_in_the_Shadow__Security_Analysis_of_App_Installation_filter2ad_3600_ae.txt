9.4/91.4
(10.32%)
developed a suite new techniques that enable secure use of the
external storage for app installation (Section V-B).
Phishing through the redirect Intent attack (Section III-D)
is also an intricate problem fundamentally caused by the design
of Android, which enables a background app to send an Intent
to a foreground app, forcing it to change its activity (UI)
before it can display its current UI triggered by the preceding
Intent from a different app. In our research, we propose an
enhancement to Android, which enables the recipient of an
Intent
the origin of the Intent, and a novel
mechanism to detect malicious Intents.
to ﬁgure out
B. User-level Protection of AIT
We developed a user-level app, called DAPP, to defend
against the installation hijacking threat. This approach does not
change the operating system (OS) or the vulnerable app, but
provides the protection through a third-party app that can be
distributed through Google Play, which we plan to do. The idea
behind DAPP is simple: as soon as an APK is downloaded,
our app grabs its signature and compares the signature against
that of the package once it has been installed by the PMS to
detect the replacement attack. Further, DAPP can identify any
ﬁle access operations on the SD-Card that may lead to the
compromise of target apk before the completion of its instal-
lation. The app is activated through the startForeground
API, leaving a notiﬁcation in the Android Notiﬁcation Center.
This protects it from being terminated by a malicious app with
the KILL_BACKGROUND_PROCESSES permission.
Covering the attack window. At the center of DAPP is
a situation-awareness module that captures ﬁle-access events
on the SD-Card. This is done through the FileObserver,
which reports the completion of target apk download using the
CLOSE_WRITE event. Note that attacker, also using this event
(Section III-B), needs to wait until the checksum veriﬁcation
completes, whereas DAPP grabs the signature as soon as the
APK is downloaded. The completion of the APK installation is
found from the PACKAGE_INSTALL and PACKAGE_ADDED
Intent broadcasted by the OS.
Finding race conditions. Also any attempt to replace tar-
get apk will be announced by FileObserver and therefore
discovered by our app, which protects the installers that do
not check the integrity of target apk after the download (note
that leading installers like DTIgnite, Amazon, Xiaomi and etc.
perform integrity check).
Speciﬁcally,
to move a ﬁle to replace tar-
get apk is exposed by the MOVED_TO event. Deleting the
APK and copying the replacement here can be detected from
the attempt
the DELETE (which happens immediately after the download)
and CLOSE_WRITE events. Even a more subtle trick, opening
the target apk and gradually modifying the content (imitating
the download process) triggers the OPEN and CLOSE_WRITE
events. DAPP considers any CLOSE_WRITE that happens
shortly after target apk download completion to be suspicious.
C. System Level Protection
In addition to the user-level approach, we also developed
a system-level solution for the GIA risk, which addresses the
root causes. Our approach includes changes to the FUSE dae-
mon to prevent installation hijacking and IntentFirewall
to defend against redirect Intent attacks and support Intent
origin identiﬁcation. We evaluate our approach in Section VI.
Guarding SD-Card with the FUSE daemon. In Android,
SD-Card is wrapped in a FUSE daemon, which uses FUSE
(Filesystem in Userspace) to enforce external storage related
access control policy and permission. In our research, we
modiﬁed the daemon to change the Linux discretionary access
control (DAC) scheme to protect an APK in an external
storage. Our approach makes an APK read-only but
writable only by its owner, that is, the app that requests the
download (e.g., appstore app). We altered the derive_perm
issions_locked method and made it set an APK ﬁle’s
permission to 640 (rw- r– –) as soon as an APK is created.
This prevents an unauthorized app from overwriting an APK
before installation, as described in Section III-B. Interestingly,
changing the ﬁle permission failed, since Android allows any
app with SD-Card permission to write on the external storage,
regardless the ﬁle permission (DAC) set to the ﬁle. To address
this issue, we modiﬁed the check_caller_access_to_n
ame method to enforce our policy, which protects APKs. This
ensures that all non-system apps, except the owner, cannot
alter the ﬁle, even with the WRITE_EXTERNAL_STORAGE
permission. The access setting of the APK is kept after it is
installed, in case the APK needs to be re-installed later. In the
meantime, the protected ﬁle can always be written by a system
process, which allows, for example, the user to delete the ﬁle
to release the space through Android system settings.
Also, an unauthorized app may attempt to bypass such
protection by altering (move, delete or rename) the entire path
which includes the target apk. To prevent such attacks, we
maintain a list, called APK list, to keep track of 1) the owner
(UID) of each APK and 2) the ﬁle path of all APKs on the
SD-Card. Before any path alteration requests are processed, we
look up the list and revoke the request if the requested path
contains any APKs that are not owned by the requester UID.
This is done by modifying the handle_rename method
which is part of the FUSE daemon as well.
Redirect Intent attack detection. To detect
the redirect
Intent attack, we modiﬁed the IntentFirewall class of
411
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:04:31 UTC from IEEE Xplore.  Restrictions apply. 
TABLE VII: Effectiveness & Complexity
Strategy
Tackled Attack
User-level app (DAPP)
FUSE DAC scheme
Intent Detection scheme
Intent origin scheme
Installation Hijacking
Installation Hijacking
Redirect Intent
Redirect Intent
AIT Step LOC
127
156
61
82
3,4
3,4
1
1
the Android framework to add a new class intentRecord
(IR) for keeping track of an Intent’s recipient package name,
delivery time and the caller’s Linux User ID (UID). Within the
IntentFirewall, our code creates an IR record for each
Intent sent through the startActivity API and keeps it in
a hash map using its recipient’s package name as the key (so
only the last Intent received by the package is preserved). For
each new record created, we ﬁrst retrieve from the hash map
the IR for the last Intent going to the same app. If the time
interval between these two consecutive Intents is found below
a threshold (1 second in our implementation), our approach
reports the event to the user as a possible attack. To avoid false
positives, we do not raise an alarm for such an Intent pair if
(1) they all come from the same app, or (2) they are sent and
received by the same app or (3) the sender is a system app
or service. Further, since our detection mechanism focuses on
the Intents from the startActivity API, which is typically
used to respond to the user-triggered event (such as a click), we
do not expect any benign app to send such an Intent within 1
second after another event also generated by the user’s activity.
Note that apps belonging to the same author (i.e., shared UID)
would not be affected by our detection approach since we
record the intent recipient’s package name and caller’s UID.
Intent-origin identiﬁcation. As mentioned earlier, the fun-
damental cause of the redirect Intent threat is the lack of
origin information for an Intent received. Otherwise, an Intent
recipient, e.g., an appstore, can display the name of the sender
to the user to get her conﬁrmation. To address this issue, we
enhanced Android to support the delivery of the Intent origin
information to the recipient. To this end, we modiﬁed Inten
t.java and IntentFirewall.java to add a ﬁeld mIn
tentOrigin that keeps the package name of the sender
within the Intent class, together with a pair of new methods
getIntentOrigin and setIntentOrigin (as hidden
API) to manage the ﬁeld. When an Intent passes through the
IntentFirewall, the modiﬁed checkIntent function
calls setIntentOrigin to put the sender information in
mIntentOrigin, which can be inspected by the recipient
by calling getIntentOrigin.
VI. EVALUATION
A. Effectiveness and Complexity
Table VII lists the lines of code (LOC) for DAPP and the
modiﬁcations on the FUSE daemon for mitigating hijacking
installations, detecting redirect Intents and identifying Intent
origins. As we see, our defense mechanisms are lightweight
and could be easily adopted. Moreover, DAPP is a regular
Android app and will be uploaded to Google Play. Our system-
level defenses just include 61-156 LOC of Java and C code.
To understand the effectiveness of our protection mech-
anisms, we tested them against the attacks described in Sec-
tion III. As depicted in Table VII, DAPP and our FUSE patches
successfully thwarted the installation hijacking attacks and
1To replace the prior Intent’s resulting screen, a malicious app needs to
send an Intent in 200ms-500ms after the legitimate Intent.
TABLE VIII: FUSE DAC scheme performance
Read
Write
Write
Read
Unit:ns
Average 1772.06
(org DAC)
(mod DAC) *%
1768.44
(org DAC)
99.80% 750.53
(mod DAC) *%
765.7
102.02%
*%: Percentage mod DAC compared to org DAC.
TABLE IX: Intent Detection Scheme Performance
Unit:ns *Total Time Our Logic **Percentage
Average 4804339.08 175247.52
0.30%
*Total Time: Time taken from sending intent to receiving intent.
**Percentage: Average of percentage value from all test cases.
our Intent detection scheme successfully captured malicious
Intents. Further, with all the protection mechanisms on a Nexus
5, for 45 days we installed 924 new apps and used it for daily
operations (email, web browsing, social networking, etc.).
During this period, no false alarms were reported and none of
the legitimate operations were disrupted by our mechanisms.
B. Performance
We further evaluated the performance of our techniques.
Speciﬁcally, to ﬁnd out the delay incurred by our detection and
access control protection, we utilized the SystemClock.el
apsedRealtimeNanos() API, which returns the time
since boot, including time spent in sleep. The evaluation was
conducted on a Nexus 5 device running Android 5.1.
Overhead of DAPP. We measured the CPU and RAM usage
of DAPP during app installation and when the system was
idle. Using OS Monitor app [9], DAPP was found to work
efﬁciently, on average using only 0.1%-0.7% of CPU and
6.3MB of RAM during installation and 0% of CPU and 6.2MB
of RAM on idle. Note that when DAPP extracts signatures
from a target apk, because the target apk is read into memory,
DAPP’s CPU and RAM usage rose to 1.5%-45% and 10.7MB-
76.2MB, but for only 214.7ms in average. Using GSam Battery
Monitor [10], we measured the battery consumption by in-
stalling 21 apps in 1 hour: with the total consumption hovering
around 20% during the experiment, DAPP was responsible for
only 0.08%. On idle, DAPP consumed nearly 0% from total
11% in 1 hour. With this level of power consumption, one
can use the device downloading 21 apps within an hour and
use the device throughout the day, with only 0.08% of battery
being spent on DAPP, which is indeed negligible.
Security enhanced DAC. We evaluated the performance of
the modiﬁed DAC scheme, in terms of the time it takes to
perform a write and a read operation on a protected ﬁle. For
this purpose, we built an app that creates a ﬁle and writes
1 MB to it. We repeated it 100 times. Similarly, the app also
read a ﬁle with 1 MB repeatedly, 100 times. Table VIII reports
the average time for each operation on the modiﬁed Android
5.1 vs. the original one. As we can see from the table, the
overhead of the modiﬁed FUSE was so small that it could not
even be measured: our implementation on average ran even
slightly faster (1%) than the AOSP for the write operation,
due to the variations of the execution time.
Redirect Intent detection. To ﬁnd out the overhead caused
by our Intent detection scheme, we built an app that sends an
Intent which starts an activity within the other, and recorded
the time it takes for the Intent to be delivered (from the moment
the sender calls startActivity till the recipient gets the
Intent but before it displays the view). We compare the time
delay caused by our logic to the total time taken to deliver
the Intent. We repeated the test 50 times. Table IX shows
the delay caused by our Intent inspection logic within the
412
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:04:31 UTC from IEEE Xplore.  Restrictions apply. 
TABLE X: Intent Origin Scheme Performance
Unit:ns
Average 64881655.14 828131.06
*Total Time Our Logic **Percentage
1.67%
*Total Time: Time taken from sending intent to receiving intent.
**Percentage: Average of percentage value from all test cases.
modiﬁed IntentFirewall.checkIntent(). Again, we
cannot observe any statistically signiﬁcant delay caused by our
logic, indicating that the overhead is negligible.
Intent origin. To evaluate the performance of the Intent origin
scheme we conducted the above experiment (on the Intent
detection scheme) again, with our origin mechanism on the
modiﬁed Android 5.1. The result presented in Table X, again,