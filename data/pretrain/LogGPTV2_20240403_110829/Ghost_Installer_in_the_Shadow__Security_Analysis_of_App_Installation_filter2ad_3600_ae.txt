### 9.4/91.4 (10.32%)
We developed a suite of new techniques that enable the secure use of external storage for app installation (Section V-B). Phishing through the redirect Intent attack (Section III-D) is a complex problem fundamentally caused by the design of Android, which allows a background app to send an Intent to a foreground app, forcing it to change its activity (UI) before it can display its current UI triggered by a preceding Intent from a different app. In our research, we propose an enhancement to Android that enables the recipient of an Intent to determine the origin of the Intent and introduces a novel mechanism to detect malicious Intents.

### B. User-level Protection of AIT
We developed a user-level app called DAPP to defend against the installation hijacking threat. This approach does not modify the operating system (OS) or the vulnerable app but provides protection through a third-party app that can be distributed via Google Play, which we plan to do. The idea behind DAPP is straightforward: as soon as an APK is downloaded, our app grabs its signature and compares it with the signature of the installed package to detect any replacement attacks. Additionally, DAPP can identify file access operations on the SD-Card that may lead to the compromise of the target APK before its installation is complete. The app is activated using the `startForeground` API, leaving a notification in the Android Notification Center, which protects it from being terminated by a malicious app with the `KILL_BACKGROUND_PROCESSES` permission.

#### Covering the Attack Window
At the core of DAPP is a situation-awareness module that captures file-access events on the SD-Card using the `FileObserver`. This module reports the completion of the target APK download using the `CLOSE_WRITE` event. Note that an attacker, also using this event (Section III-B), needs to wait until the checksum verification completes, whereas DAPP grabs the signature as soon as the APK is downloaded. The completion of the APK installation is determined from the `PACKAGE_INSTALL` and `PACKAGE_ADDED` Intents broadcasted by the OS.

#### Finding Race Conditions
Any attempt to replace the target APK will be detected by the `FileObserver` and discovered by our app, protecting installers that do not check the integrity of the target APK after the download (leading installers like DTIgnite, Amazon, and Xiaomi perform integrity checks). Specifically, attempts to move a file to replace the target APK are exposed by the `MOVED_TO` event. Deleting the APK and copying a replacement can be detected from the `DELETE` (which happens immediately after the download) and `CLOSE_WRITE` events. Even a more subtle trick, such as opening the target APK and gradually modifying its content (imitating the download process), triggers the `OPEN` and `CLOSE_WRITE` events. DAPP considers any `CLOSE_WRITE` event that occurs shortly after the target APK download completion to be suspicious.

### C. System Level Protection
In addition to the user-level approach, we developed a system-level solution for the GIA risk, addressing the root causes. Our approach includes changes to the FUSE daemon to prevent installation hijacking and an `IntentFirewall` to defend against redirect Intent attacks and support Intent origin identification. We evaluate our approach in Section VI.

#### Guarding SD-Card with the FUSE Daemon
In Android, the SD-Card is managed by a FUSE daemon, which uses FUSE (Filesystem in Userspace) to enforce external storage-related access control policies and permissions. In our research, we modified the daemon to change the Linux discretionary access control (DAC) scheme to protect an APK in external storage. Our approach makes an APK read-only but writable only by its owner, i.e., the app that requests the download (e.g., an app store app). We altered the `derive_permissions_locked` method to set an APK file's permission to 640 (rw-r-----) as soon as the APK is created. This prevents unauthorized apps from overwriting an APK before installation, as described in Section III-B. Interestingly, changing the file permission failed because Android allows any app with SD-Card permission to write on the external storage, regardless of the file permission (DAC) set to the file. To address this issue, we modified the `check_caller_access_to_name` method to enforce our policy, ensuring that all non-system apps, except the owner, cannot alter the file, even with the `WRITE_EXTERNAL_STORAGE` permission. The access setting of the APK is maintained after it is installed, in case the APK needs to be re-installed later. Meanwhile, the protected file can always be written by a system process, allowing the user to delete the file to release space through Android system settings.

Additionally, an unauthorized app may attempt to bypass this protection by altering (moving, deleting, or renaming) the entire path that includes the target APK. To prevent such attacks, we maintain an `APK list` to track 1) the owner (UID) of each APK and 2) the file path of all APKs on the SD-Card. Before processing any path alteration requests, we look up the list and revoke the request if the requested path contains any APKs not owned by the requester UID. This is done by modifying the `handle_rename` method, which is part of the FUSE daemon.

#### Redirect Intent Attack Detection
To detect the redirect Intent attack, we modified the `IntentFirewall` class of the Android framework to add a new `intentRecord` (IR) class for tracking an Intent's recipient package name, delivery time, and the caller's Linux User ID (UID). Within the `IntentFirewall`, our code creates an IR record for each Intent sent through the `startActivity` API and keeps it in a hash map using the recipient's package name as the key (so only the last Intent received by the package is preserved). For each new record created, we first retrieve from the hash map the IR for the last Intent going to the same app. If the time interval between these two consecutive Intents is below a threshold (1 second in our implementation), our approach reports the event to the user as a possible attack. To avoid false positives, we do not raise an alarm for such an Intent pair if:
1. They both come from the same app.
2. They are sent and received by the same app.
3. The sender is a system app or service.

Since our detection mechanism focuses on Intents from the `startActivity` API, which is typically used to respond to user-triggered events (such as a click), we do not expect any benign app to send such an Intent within 1 second after another event generated by the user's activity. Apps belonging to the same author (i.e., shared UID) would not be affected by our detection approach since we record the intent recipient's package name and caller's UID.

#### Intent-Origin Identification
As mentioned earlier, the fundamental cause of the redirect Intent threat is the lack of origin information for a received Intent. Otherwise, an Intent recipient, such as an app store, could display the name of the sender to the user for confirmation. To address this issue, we enhanced Android to support the delivery of Intent origin information to the recipient. To this end, we modified `Intent.java` and `IntentFirewall.java` to add a field `mIntentOrigin` that keeps the package name of the sender within the `Intent` class, along with a pair of new methods, `getIntentOrigin` and `setIntentOrigin` (as hidden APIs) to manage the field. When an Intent passes through the `IntentFirewall`, the modified `checkIntent` function calls `setIntentOrigin` to put the sender information in `mIntentOrigin`, which can be inspected by the recipient by calling `getIntentOrigin`.

### VI. Evaluation

#### A. Effectiveness and Complexity
Table VII lists the lines of code (LOC) for DAPP and the modifications on the FUSE daemon for mitigating hijacking installations, detecting redirect Intents, and identifying Intent origins. As shown, our defense mechanisms are lightweight and can be easily adopted. Moreover, DAPP is a regular Android app and will be uploaded to Google Play. Our system-level defenses include 61-156 LOC of Java and C code.

To understand the effectiveness of our protection mechanisms, we tested them against the attacks described in Section III. As depicted in Table VII, DAPP and our FUSE patches successfully thwarted the installation hijacking attacks and our Intent detection scheme successfully captured malicious Intents. Further, with all the protection mechanisms on a Nexus 5, for 45 days, we installed 924 new apps and used it for daily operations (email, web browsing, social networking, etc.). During this period, no false alarms were reported, and none of the legitimate operations were disrupted by our mechanisms.

#### B. Performance
We further evaluated the performance of our techniques. Specifically, to find out the delay incurred by our detection and access control protection, we utilized the `SystemClock.elapsedRealtimeNanos()` API, which returns the time since boot, including time spent in sleep. The evaluation was conducted on a Nexus 5 device running Android 5.1.

**Overhead of DAPP:**
We measured the CPU and RAM usage of DAPP during app installation and when the system was idle. Using the OS Monitor app [9], DAPP was found to work efficiently, on average using only 0.1%-0.7% of CPU and 6.3MB of RAM during installation and 0% of CPU and 6.2MB of RAM on idle. Note that when DAPP extracts signatures from a target APK, because the target APK is read into memory, DAPP's CPU and RAM usage rose to 1.5%-45% and 10.7MB-76.2MB, but for only 214.7ms on average. Using GSam Battery Monitor [10], we measured the battery consumption by installing 21 apps in 1 hour: with the total consumption hovering around 20% during the experiment, DAPP was responsible for only 0.08%. On idle, DAPP consumed nearly 0% from the total 11% in 1 hour. With this level of power consumption, one can use the device to download 21 apps within an hour and use the device throughout the day, with only 0.08% of the battery being spent on DAPP, which is indeed negligible.

**Security Enhanced DAC:**
We evaluated the performance of the modified DAC scheme in terms of the time it takes to perform a write and a read operation on a protected file. For this purpose, we built an app that creates a file and writes 1 MB to it. We repeated this 100 times. Similarly, the app also read a file with 1 MB repeatedly, 100 times. Table VIII reports the average time for each operation on the modified Android 5.1 vs. the original one. As shown in the table, the overhead of the modified FUSE was so small that it could not even be measured: our implementation on average ran slightly faster (1%) than the AOSP for the write operation, due to variations in execution time.

**Redirect Intent Detection:**
To find out the overhead caused by our Intent detection scheme, we built an app that sends an Intent to start an activity within another app and recorded the time it takes for the Intent to be delivered (from the moment the sender calls `startActivity` till the recipient gets the Intent but before it displays the view). We compared the time delay caused by our logic to the total time taken to deliver the Intent. We repeated the test 50 times. Table IX shows the delay caused by our Intent inspection logic within the modified `IntentFirewall.checkIntent()`. Again, we observed no statistically significant delay caused by our logic, indicating that the overhead is negligible.

**Intent Origin:**
To evaluate the performance of the Intent origin scheme, we conducted the above experiment (on the Intent detection scheme) again, with our origin mechanism on the modified Android 5.1. The result presented in Table X, again, shows no significant delay, confirming that the overhead is negligible.