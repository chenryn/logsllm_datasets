言取真值的事实。
一组布尔变量的真假赋值，BDD 表示的函数为真当且仅当它的布尔变量表示了使这个断
BDD 和关系：一个 BDD 可以作为 Datalog 程序中的断言的简洁表示方法。常量被编码为
变量取值为0，那么我们就走到低子结点，否则走到高子结点。
根
二分决策图：BDD 是一种使用带根的DAG表示布尔函数的简洁方法。内部结点对应于布
改过程内指针分析的规则，使断言中包含上下文信息。这个方法模拟了基于克隆的分析。
限
上下文相关分析：当过程具有递归特性时，我们必须把调用串中所包含的信息浓缩到有
型，并利用下面的事实：一个虚方法调用所指向的实际方法必须属于适当的类。
个给定调用点上被调用。找出哪里可以调用哪些程序的限制的基本方法是分析对象的类
寻找调用图：因为 Java 具有虚方法，过程间分析要求我们首先界定有哪些过程可能在-
相同。
回值是如何被赋给变量的。这些规则实质上和把一个引用变量复制到另一个引用变量的规则
过程间指针分析：为了进行过程间分析，我们必须增加一些规则来反映参数是如何传递的，返
量类型的子类型。如果我们能够利用这个事实，我们就可以得到更加精确的指针分析结果。
使用类型信息改进指针分析：引用变量所指向的堆对象的类型要么和变量类型相同，要么是变
个变量可能指向一个堆对象，以及一个堆对象的字段可能指向另一个堆对象。
个 Datalog 程序写出一个上下文无关的指针分析方法。这个分析可以推导出两种事实：
指向堆对象的引用变量，而这些堆对象中又有一些字段可以指向其他堆对象。可以用一
Java 指针分析：我们可以用--个框架对Java 中的指针分析建模。在这个框架中，有…一些
中至少有一个原子是刚刚在上一轮中被发现的事实。
Datalog 程序的增量求值：通过增量求值的方法可以改进 Datalog 程序的求值效率。我们将
Datalog 程序的求值：我们应用规则的方法是把规则中的变量替换为--些能够使该规则体
结点有一条如下的路径到达叶子结点1。这条路径从根结点开始，如果一个结点上白
分别为0和1的两个叶子结点。一个真假赋值使得被表示函数取真值当且仅当从图的
变量，并且有两个子结点，即低子结点(表示0值)和高子结点(表示1值)。图中有
多个上下文中。做这件事的有效方法之一是从调用串中删除某个过程调用与之相互递
607
标
---
## Page 624
va
等[19]描述了如何动态扩展数组大小来应对溢出缓冲区的内容。Avots 等[3]把上下文相关的Ja-
SQL 漏洞。Ruwase 和Lam[20］描述了如何跟踪数组长度并自动加人动态边界检查代码。Rinard
工具，并通过把 BDD 应用到模型检查中，在C 语言的设备驱动程序中寻找 API 的使用错误。
技术来模拟一个系统的所有可能行为。Ball 等[5]已经基于 SLAM 建立了一个被称为 SDV 的静态分析
[10]创建。Ball 和 Rajamani[4]开发了一个名为 SLAM 的程序分析引擎，它使用了模型检查和符号执行
据流分析和 Datalog 联系起来的讨论。
描述的分析自动地转化成为 BDD 代码。对象相关性首先由 Milanova、Rountev 和 Ryder[18］提出。
明可以用于实际应用的算法。这篇文章描述了一个称为 bddbddb 的工具，它可以把使用 Datalog
Lam［24］描述了第--个上下文相关、控制流无关、基于包含关系的算法。这个算法是第一个被证
[4]等人提出的。DBB在无关性指针分析中的应用由 Zhu[25]和 Berndl 等人[8]报告。Whaley 和
相关、基于包含的指针指向分析算法。
提的是Emami、Ghiya 和Hendren[13］的工作。他们的工作是一个基于克隆的上下文相关、控制流
序，比如 gcc。在之前针对上下文相关的、基于包含关系的指针指向分析的各种尝试中，值得
给出了一个上下文相关、控制流无关且基于等价的分析技术，这个技术可以处理很大规模的程
出。之后，Heintze 和Tardieu[15］描述了实现这个分析的高效算法。Fahndrich、Rehof 和 Das[14]
无关的且基于等价关系。基于包含的指针指向分析的--个上下文无关版本首先由 Andersen[2］提
指针指向分析扩展到C语言中，并说明了如何使用它来降低动态检测缓冲区溢出的开销。
Livshits 和 Lam[17]描述了如何使用上下文相关的指针指向分析来寻找 Java Web 应用中的
Metal 代码检查工具在 Engler 等的著作[12］中描述，而 PREfix 检查程序由 Bush、Pincus 和 Sielaff
对 Datalog 的讨论见 Ullman 和 Widom[23］。在 Lam.等人的工作[16］中也可以看到有关把数
608
Steensgaard[22］发布了第一-个可仲缩的指针别名分析技术。这个技术是上下文无关、控制流
8. Berndl, M., O. Lohtak, F. Qian, L. Hendren, and N. Uinanee, “Points-
5.
4. Ball, T. and S. K. Rajamani, “A symbolic model checker for boolear
3. Avots, D., M. Dalton, V. B. Livshits, and M. S. Lan, “Improving software
 2. Andersen, L., Program Analysis and Specialization for the C Programming
 1974, pp. 398-402, North Holland, Amsterdam, 1974.
pp. 113-130.
programs,"
security with a C pointer analysis,"
 Proc. SPIN 2000 Workshop on Model Checking of Software,
ICSE 2005: Proc.27th. International
第12章
---
## Page 625
过程间分析
 20. Ruwase, O. and M. S. Lam, “"A practical dynamic buffer overfow detec-
19.
15.
14.
12.
11.
10.
9.1
 Heintze, N. and O. Tardieu, * Ultra-fast aliasing analysis using CLA: a
Fahndrich, M., J. Rehof, and M. Das,
(1994); pp. 224-256.
 Engler, D., B. Chelf, A. Chou, and S. Hallem1, “"Checking system rules us-
Callahan, D., K. D. Cooper, K. Kennedy, and L. Torczon, “Interprocedu-
Bush, W. R., J. D. Pincus, and D. J. Sielaff, “A static analyzer for finding
tion," IEEE Trans. on Computers C-35:8 (1986), pp. 677-691.
posium (2004), Pp. 159-169.
tor," Proc. 11th Annual Network and Distributed System Security Sym-
ory errors), Proc. 2004 Annual Computer Security Applications Confer-
technique for eliminating buffer overflow vulnerabilities (and other mem-
Rinard, M.,
Pp. 1--11.
SIGSOFT
sitivity for points-to and side-effect analyses for Java" Proc. 2002 ACM
Milanova, A., A. Rountev, and B. G. Ryder, “Parameterized object sen-
sium (2005), pp. 271-286.
Livshits, V. B. and M. S. Lam, "Finding security vulnerabilities in Java
Lam, M. S., J. Whaley, V. B. Livshits, M. C. Martin, D. Avots, M. Carbin,
99g-89z dd (000z) uouuardu1 puo u6isag abon5uog buzuuniboid
(2000). pp. 1-16.
Construction, SIGPLAN Notices, 21:7 (1986), pp. 152-161.
ral constant propagation,
, C. Cadar, D. Dumitran, D. Roy, and T. Leu, “A dynamic
"Scalable context-sensitive flow
609
---
## Page 626
610
25. Zhu, J., "Symbolic Pointer Analysis," "Proc. International Conference in
24.
22.
 21. Sharir, M. and A. Pnueli, “Two approaches to interprocedural data fow
Whaley, J. and M. S. Lam, 
tice-Hall, Upper Saddle River NJ, 2002.
Ullman, J. D. and J. Widom, A First Course in Database Systems, Pren-
 Steensgaard, B., “Points-to analysis in linear time," Twenty-Third ACM
131-144.
Conference on Programming Language Design and Implementation, pp.
Saddle River NJ, 1981.
analysis," in S. Muchnick and N. Jones (eds.)
, “"Cloning-based context-sensitive pointer alias
Proc. ACM SIGPLAN 2004
第12章
---
## Page 627
把赋值当作一个语句(而不是表达式中的运算符)可以简化翻译工作。
基本类型。
A.1源语言
生成三地址中间代码（见包inter）。
结构或结点被实现为对象。这些对象负责处理下列工作:构造一个抽象语法树结点、类型检查、
分析器的代码之间没有什么关系。当由语法分析器输出时，源程序就是一棵抽象语法树，树中的
所以它将在最后描述。每个包存放在一个独立的目录中，每个类都有一个单独的文件。
ter 中包含的类处理用抽象语法表示的语言结构。因为语法分析器的代码和其他各个包交互,
转代码。我们首先给出源语言的语法。描述这个语法所用的文法需要进行调整，以适应自顶向
下的语法分析技术。
器编写的。和第2 章的主要不同之处在于，这个前端像6.6节中描述的那样为布尔表达式生成跳
的方式时，增加一个新构造可能会引起各个步骤中的多个过程的改变。
改变一个步骤，比如插人自动类型转换的代码，就需要改变所有受影响的类。使用面向步骤
易。使用对象来实现时，增加一个新的构造可以通过写一个自包含的类来实现；但是如果要
变得较容易；而使用面向步骤的方法会使得改变或增加一个步骤(比如类型检查)变得比较容
每个构造都有一个 case 分支，且-一个代码生成过程对每个构造也都有一个case 分支，等等。
面向步骤的方法中，这个方法中的代码是按照步骤进行组织的，因此一个类型检查过程中
这个语言的一个程序由一个块组成，该块中包含可选的声明和语句。语法符号 basic 表示
这个翻译器的 Java 代码由五个包组成:main、lexer、symbol、parser 和 inter。包in-
对这两者进行衡量，可知使用面向对象方法会使得改变或增加一个构造（比如 for 语句）
作为语法分析器的输人时，源程序就是一个由词法单元组成的流，因此面向对象特性和语法
这个附录给出了一个完整的编译器前端，它是基于2.5 节至2.8节中非正式描述的简单编译
在一个面向对象方法中，-一-个构造的所有代码都集中在这个与构造对应的类中。但是在
附录A 一个完整的编译器前端
↑
loc 【 bool”丨id
while ( bool)
if(bool） stmt 
loc = bool ;
↑↑
面向对象与面向步骤
对
---
## Page 628
间代码中运算符的书写形式；比如单目减号。例如，源文本中的－2 的中间形式是minus 2。
类 Word 用于管理保留字、标识符和像 &&这样的复合词法单元的词素。它也可以用来管理在中
其中的三个常量 INDEX、MINUS 和 TEMP 不是词法单元,它们将在抽象语法树中使用。
常量：
A. 3
析器，然后调用语法分析器中的方法 program。
终结符号，而非终结符号factor 用来表示括号中的表达式、标识符、数组引用和常量。
包lexer 是2.6.5节中的词法分析器的代码的扩展。类 Tag 定义了各个词法单元对应的
程序的执行从类 Main 的方法 main 开始。方法 main 创建了一个词法分析器和一个语法分
2
612
类 Token 和 Num 和 2.6.5节的相同，但是增加了方法 toString：
表达式的产生式处理了运算符的结合性和优先级。它们对每个优先级级别都使用了－-个非
package lexer;
词法分析器
Main
public String toString() { return
public
OR
8
System.out.write('\n');
Parser parse
 java.
↑↑
↑
↑↑
Num(int v)
(bool )
join&
11
boot
Token
Tag{
&&equality
|| join 丨join
 int value;'
term
FALSE
rel
new Parser(lex);
tag= t；}
fironba
//文件 Num.java
// 文件 Token.java
// 文件·Main.java