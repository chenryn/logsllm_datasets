title:Dynamic Cross-Realm Authentication for Multi-Party Service Interactions
author:Dacheng Zhang and
Jie Xu and
Xianxian Li
Dynamic Cross-Realm Authentication for Multi-Party Service Interactions 
            Dacheng Zhang  
School of Computing, University of Leeds, UK    School of Computer, Beihang University, China 
           {dcz, jxu}@comp.leeds.ac.uk                                    
Jie Xu                                                  Xianxian Li 
       PI:EMAIL 
Abstract 
Modern distributed applications are embedding an 
increasing degree of dynamism, from dynamic supply-
chain management, enterprise federations, and virtual 
collaborations  to  dynamic  service  interactions  across 
organisations.  Such  dynamism  leads  to  new  security 
challenges.  Collaborating  services  may  belong  to 
different security realms but often have to be engaged 
dynamically at run time. If their security realms do not 
have  in  place  a  direct  cross-realm  authentication 
relationship,  it  is  technically  difficult  to  enable  any 
secure  collaboration  between  the  services.  A  typical 
solution  to  this  is  to  locate  at  run  time  intermediate 
realms  that  serve  as  an  authentication-path  between 
the  two  separate  realms.  However,  the  process  of 
generating  an  authentication  path  for two  distributed 
services can be very complex. It could involve a large 
number  of  extra  operations  for  credential  conversion 
and require a long chain of invocations to intermediate 
services.  In  this  paper,  we  address  this  problem  by 
presenting  a  new  cross-realm  authentication  protocol 
for  dynamic  service  interactions,  based on the  notion 
of multi-party business sessions. Our protocol requires 
neither credential conversion nor establishment of any 
authentication  path  between  session  members.  The 
correctness  of 
is  analysed,  and  a 
comprehensive empirical study is performed using two 
production  quality  Grid  systems,  Globus  4  and 
CROWN.  The  experimental  results  indicate  that  our 
protocol and its implementation have a sound level of 
scalability  and  impose  only  a  limited  degree  of 
performance overhead, which is comparable with those 
security-related overheads in Globus 4.  
the  protocol 
Key  Words:  Authentication,  Multi-Party  Interactions, 
Secure  Service  Collaborations,  Web  Services, 
Workflow Business Sessions 
1. Introduction  
Dynamism  and  flexibility  are  becoming  the  core 
large-scale  distributed 
characteristics  of  modern 
its  activities 
applications,  such  as  business  application  integration, 
distributed  auction  services,  and  order  processing 
[5][9]. A business process does not have to follow in 
many  cases  a  strict  business  specification; 
the 
executing  order  of 
is  sometimes 
unpredictable,  and  on  some  occasions,  the  actual 
execution of a process can even be “one-of-a-kind” [7]. 
The applications  and  services  involved  in  the  process 
are typically heterogeneous and may  be provided and 
maintained  by  different  organisations.  As  an 
organisation  has  its  own  security  mechanisms  and 
policies  to  protect  its  local  resources,  the  application 
across  multiple  organisations  has  to  operate  amongst 
multiple,  heterogeneous  security  realms.  A  security 
realm  is  a  group  of  principals  (people,  computers, 
services  etc.)  that  are  registered  with  a  specified 
authentication  authority  and  managed 
through  a 
consistent set of security processes and policies.  
Because  organisations  and  services  can  join  a 
collaborative process in a highly dynamic and flexible 
way,  it  cannot  be  expected  that  every  two  of  the 
collaborating  security  realms  always  have  a  direct 
cross-realm  authentication  relationship.  A  possible 
solution to this problem is to locate some intermediate 
realms that serve as an authentication-path between the 
two  separate realms  that are  to  collaborate.  However, 
the  overhead  of  generating  an  authentication-path  for 
two distributed realms is not trivial. The process could 
involve  a 
large  number  of  extra  operations  for 
credential  conversion  and  require  a  long  chain  of 
invocations to intermediate services.  
to  establish 
In  this  paper  we  present  a  new  solution  for 
dynamically authenticating the services from different 
realms.  The  main  contributions  of  our  work  are:  (1) 
using  the  multi-party  session  concept  to  structure 
dynamic business processes, (2) a simple but effective 
way 
the 
members  of  a  business  session,  and  (3)  a  set  of 
protocols 
session  management, 
supported by empirical evaluation and formal analysis. 
In  Section  2  we  discuss 
fundamentals  of 
constructing multi-party service interactions. Section 3 
describes  our  proposed  authentication  protocols  and 
trust  relationships  between 
for  multi-party 
the 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:53:10 UTC from IEEE Xplore.  Restrictions apply. 
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 2007system with formal proofs. In Section 4 we present an 
empirical  evaluation  of  our  system  using  GT4  and 
CROWN middleware systems. Section 5 discusses the 
related work while Section 6 concludes the paper. 
2. Multi-Party Service Interactions 
can  be 
execution 
In  a  distributed  application,  a  session  is  a  lasting 
collaboration involving several participating principals, 
called session partners. A session is often typified by a 
state  which  includes  variables  that  hold  information 
from messages transferred within the collaboration. A 
business  process 
regarded 
conveniently  as  a  business  session.  In  terms  of  a 
Service-Oriented  Architecture  (SOA)  [11],  a  business 
session  is  a  collaboration  involving  two  or  more 
collaborative services, and has service instances as its 
session partners (a service instance is here referred to 
as  a  stateful  execution  of  a  service.)  In  practice,  a 
session  may  discover  and  select  services  at  runtime. 
After  receiving  an  initial  request  from  a  business 
session,  a  service  normally  spawns a  service  instance 
to handle the request. Once this instance is accepted as 
a session partner, it is entitled to collaborate with other 
partners within the same session. 
2.1 Two-Party Session 
As  implied  by  the  name,  a  two-party  session 
consists of two session partners only, i.e. a client and a 
server.  For  the  security  of  a  two-party  session,  an 
authentication process is required when the client sends 
an initial request to the server. A short-term secret key 
between the  session  partners is then  agreed upon and 
generated. The secret key, also called session key, can 
be  used  in  further  communications  to  encrypt  the 
messages transferred between the session partners [8]. 
The  two-party  session  technique  is  practically 
effective,  and  it  is  used  widely  in  many  distributed 
systems  and  integrated  with  the  design  of  most 
authentication protocols (e.g. SSL and Kerberos [17]). 
However, new problems arise if the two-party session 
technique  is  applied  directly  to  the  construction  of  a 
multi-party  session.  Hada  and  Maruyama  in  [9] 
demonstrate that, if a multi-party session is constructed 
out  of  multiple  two-party  sessions,  it  is  difficult  in 
some cases for a session partner to verify whether the 
service instance it contacts is actually a member of the 
same  session.  From  the  perspective  of  cross-realm 
authentication,  the  two-party  session  technique  does 
not address the issue with Heterogeneous Cross-Realm 
Authentication  (HCRA),  which  requires  credential 
conversion  and  the  establishment  of  authentication 
paths.  
Figure 1 A business session scenario 
Figure 1 illustrates an example of a business session 
constructed with two two-party sessions. The business 
session  consists  of 
three  participating  services, 
Consumer,  Producer,  and Shipper.  At  the  start  of  the 
business session, an instance of Consumer, CI, contacts 
Producer to  order  some  products.  After receiving  the 
request from CI, Producer creates a service instance PI 
to  handle  it.  PI  then  selects  Shipper  to  deliver  the 
products  to  Consumer.  An instance  of  Shipper,  SI,  is 
thus  generated  to  do  this  job,  and  it  is  required  to 
negotiate with CI about delivery options and details. In 
this case, an HCRA process for authentication between 
SI and CI has to be performed by means of a new two-
party session as SI and CI do not know each other and 
belong  to  different  security  realms.  This  HCRA 
process  is  both  costly  and  complex  due  to  credential 
conversion  and  possibly  a  long  authentication  path 
between the two local authentication systems of SI and 
CI.  For  a  business  session 
involved  with  n 
heterogeneous security realms, the HCRA process has 
to be repeated n × (n – 1)/2 times to allow all possible 
partner interactions with the session. 
2.2 Multi-Party Session 
A multi-party session may have two or more session 
partners  for  the  intended  collaboration.  A  partner  can 
search for and invoke new services at runtime. Before 
a  service  (instance)  is  accepted  as  a  new  partner,  an 
HCRA process is needed. However, unlike a two-party 
session,  authentication  for  the  existing  partners  of  a 
multi-party  session  could  be  simplified  significantly 
without  requiring  credential  conversion  and 
the 
establishment  of  any  authentication  path.  This  is 
because session partners can make use of their session 
memberships  to  authenticate  each  other  even  if  they 
belong  to  different  security  realms.  A  shared  session 
key or individual secret keys may be used to enforce a 
session  partners. 
secure 
collaboration 
amongst 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:53:10 UTC from IEEE Xplore.  Restrictions apply. 
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 2007called 
Consider  the  example  of  Figure  1  again.  When  SI 
attempts to contact CI, it does not have to authenticate 
itself  with  the  local  authentication  system  of  CI 
because  both  SI  and  CI  are  members  of  the  same 
session.  SI  can  simply  use  its  session  membership  to 
prove its identity to CI. This simplified authentication 
process 
Cross-Realm 
Authentication (SCRA). The HCRA process has to be 
repeated (n – 1) times for a multi-party session with n 
security  realms,  but  up  to  (n  –  1)  ×  (n  –  2)/2 
authentication  processes  can  be  simplified  as  SCRA 
based on session memberships, thereby reducing both 
cost and complexity significantly.  
Simplified 
However, managing and coordinating a multi-party 
session is more complex in nature, in comparison with 
handling  two  parties  only.  A  multi-party  session 
management  system  needs  to  address  the  issues  with 
message  routing  and  secret  keys  for communications. 
A  Session  Authority  (SA)  is  also  required  to  provide 
reliable real-time information (e.g. memberships) about 
session partners [9].   
2.3 Message Routing  
Message  routing  is  concerned  with  the  issues  of 
dispatching  messages to  the  intended  service  instance 
which  maintains  corresponding  states.  In  practice,  a 
service may handle requests from different requestors 
concurrently.  When  all 
invoke 
operations provided by the same port, the messages are 
sent to the same address (e.g. the same URL). In this 
case,  additional  correlated  information  is  needed, 
which  helps  the  underlying  middleware  to  determine 
which interaction a message is related to and to locate 
the  corresponding  service  implementation  object  to 
handle the message. 
requestors 
related  messages 
transported  within 
A simple approach is to exploit a correlated token, 
shared by the communicating partners, for identifying 
the 
the 
collaboration.  A  shared  token  is  sufficient  to  the 
identification of session partners on the both sides of a 
two-party collaboration. However, session partners (i.e. 
service  instances)  in  a  multi-party  session  may  be 
generated by the same service with the same address. It 
is difficult to distinguish them using a single token. In 
contrast  with  the  token-based  solution,  an  ID-based 
solution  assigns  every  session  partner  with  a  unique 
identifier, 
the  partners 
unambiguously.  In  practice, a  token-based  solution  is 
usually used to decide whether an instance is actually 
working  within a  business  session  while  an  ID-based 
scheme  is  employed  to  identify  individual  session 
the  case 
partners 
instance 
identification is needed. 
thereby  distinguishing  all 
fine-grained 
that 
the 
is 
in 
2.4 Secret Keys 
In  a  two-party  session,  authentication  typically 
consists  of  several  rounds  of  operations  and  message 
passing,  and  the  session  key  used  in  the  subsequent 
communication between the two partners is normally a 
by-product of the authentication process. However, in a 
multi-party  session,  SCRA  is  a  highly  simplified 
process and does not include the automatic generation 
of secret keys.  
An obvious approach is to generate a single secret 
key for a given multi-party session and then distribute 
it to  all  the  session  partners.  Once  the  session  key  is 
generated, it can be used to simplify the authentication 
process amongst the existing session partners, thereby 
avoiding HCRA. Hada and Maruyama’s protocols in [9] 
are an example of this type of solution with the support 
of a Session Authority. However, if a partner loses the 
secret  key,  the  security  of  the  whole  session  will  be 
compromised.  Moreover,  session  partners  may  leave 
and join a session dynamically. When a partner leaves 
from  its  session,  the  shared  secret  key  must  be 
refreshed in order to ensure that any previous partner 
cannot  gain any  further  information  from the  session. 
Similarly,  when  a  new  partner  joins  the  session,  the 
secret  key  must  also  be  refreshed  in  order  to  ensure 
that  any  new  partner  cannot  obtain  any  previous 
information  transferred  within  the  session. The issues 
related with secret key revocation have been discussed 
in many papers on secure group communications (e.g. 
[15][20]). 
Another  possible  solution  is  to  generate  a  shared 
secret key for every pair of session partners (e.g. using 
the  Diffie-Hellman  public  key  algorithm  [18]).  This 
scheme is more costly but it avoids the issue with key 
revocation.    
2.5 Session Authority 
real-time 
information 
A Session Authority (SA) is a service that provides 
reliable 
session 
memberships)  for  a  given  multi-party  session.  For 
example,  the  SA  may  be  employed  to  notify  that  a 
partner has left from the session, by contacting all the 
partners  that  have  collaborated  with  the  previous 
partner.  An  SA 
service  could  be  associated 
conveniently with, or implemented as part of, a multi-
party  management  system.  This  can  be  implemented 
using  different  methods  with  different  features  and 
characteristics  such  as  fault-tolerance,  scalability  and 
cost-effectiveness.  These  methods  include  centralised 
management,  decentralised  architecture  for  better 
scalability, and fully distributed information provision 
for improved fault-tolerance. As an example of the SA 
(e.g. 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:53:10 UTC from IEEE Xplore.  Restrictions apply. 
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 2007In 
this 
to 
to  conform 
implementation,  our  authentication  protocols  are 
designed 
the  WS-Coordination 
specification [3] in which an SA is an extension of a 
coordinator. In WS-Coordination both centralised and 
decentralised  coordinators  are  discussed.  An  SA  may 
act as a centralised service that handles requests from 
all  the  session  partners  within  a  business  session; 
alternatively, an SA may manage the session partners 
within  a 
local  domain  only,  and  a  group  of 
decentralised  SA’s  can  then  manage  collectively  the 
whole business session, thereby avoiding the problem 
of concentrating the SA operations in a single place.  
3. Authentication Protocols 
section  we  provide 
a  multi-party 
authentication system and use the business scenario in 
Section  2  to  explain  the  structure  of  the  system.  The 
related protocols are described and analysed formally.  
3.1 Example 
Consider  an  SA-based  multi-party  authentication 
system.  In  this  system  each  business  session  is 
associated  with  a  unique  session  identifier.  Every 
service  instance  within  a  session  is  associated  with  a 
unique instance identifier so that every session partner 
can  be  identified  unambiguously.  The  Diffie-Hellman 
public  key  algorithm  is  used  to  generate  a  pair  of 
public/private  keys  for  each  service  instance.  The 
public  key  of  an  instance  is  identical  to  its  identifier 
and  can  be  transferred  over  the  network  while  its 
private key is kept securely and can be used to prove 
the  possession  of  the  identifier.  The  Diffie-Hellman 
algorithm  is  also  exploited  for  generating  a  shared 
secret key for every pair of collaborative partners of a 
session.  
Figure  2  illustrates  how  the  authentication  system 
performs  multi-party 
session  authentication  and 
management  using  the  example  of  Figure  1.  First,  CI 
contacts an SA to start a new business session, S. The 
SA service then generates an instance, SA, to manage 
the new session. CI thus becomes a session partner of S, 
and  its  identifier  is  recorded  in  SA.  CI  then  contacts 
Producer.  Producer  sends  back  the  identifier  of  the 
instance PI in Step (2) while PI is introduced by CI to 
SA in  Step  (3).  Next,  CI  starts  to  collaborate  with  PI 
after receiving the confirmation from SA (Step (4)). In 
the  same  way,  PI  invokes  a  new  shipper  instance  SI 
and  introduces  it  to  SA  (Steps  (5)  to  (7)).  After 
receiving the request  from  SI,  CI  first  contacts  SA to 
check whether SI is a legal business session partner of 
S (Steps (8) and (9)). Once this is confirmed by SA, CI 
and SI can use the Diffie-Hellman algorithm to agree 
upon a shared secret key for further communications. 
Figure 2 A business scenario  
3.2 Formal Definitions  
In this section we will define two core protocols in 
our  multi-party  authentication  system  using  the  well-
known  Logic  of  Authentication  (or  BAN  logic)  [2]. 
Protocol 1 is concerned with the introduction of a new 
session partner, and Protocol 2 performs authentication 
between two existing session partners. For the brevity 
of discussion, we use the following notation for formal 
definitions and proofs (which is a simplified version of 
the notation used in [14]). 
p 
a 
A, B, C 
SA 
IDA 
S 
Pri(A) 
Pub(A) 
K(A, B) 
(M, N) 
MAC(M)K 
Secure(M)  
Valid(M)K 
↑Pub(A) 
#M  
SP(A, S) 
large prime number 
exponentiation base 
session partners 
session authority  
identifier of A 
multi-party session with identifier IDS 
private key of principal A 
public key of principal A, i.e. (aPri(A) mod 
p) = IDA 
secret  key  generated  with  Pri(A)  and 
Pub(B); K(A, B) = (Pub(B))Pri(A) = aPri(A) Pri(B)  
mod p; K(A, B) =K(B, A) 
composite message composed of messages 
M and N  
message 
generated with secret key K  
message  M  is  transmitted  by  a  secure 
channel 
composite message (M, MAC(M)K) 