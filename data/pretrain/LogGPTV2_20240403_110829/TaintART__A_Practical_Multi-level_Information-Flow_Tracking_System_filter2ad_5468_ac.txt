Set base[offset] ﬁeld taint to value taint
to store taint tag and loads into taint tag storage register
when the spilled registers is needed. At the frame exit, R5
will be popped and restored ﬁnally.
3.3.3 Binder IPC & Native Code Taint Propagation
Binder mechanism is one common way to exchange mes-
sages between apps. Because the binder implementation in
Android framework is stable, we employ previous methodol-
ogy. We track taint tag propagation in message-level gran-
ularity for performance concern. We add an extra ﬁeld in
binder parcel to indicate the taint status of this message.
When sending a binder message, the TaintART runtime
will append taint status into the parcel message and unpack
the taint status when a message arrives. Because Taint-
ART mainly focus on tracking information ﬂows within
ART environment. We can employ existing work such as
NDroid [42] which mainly focuses on tracing information
ﬂow through JNI.
4.
IMPLEMENTATION
In this section, we discuss implementations on taint
sources and sinks, taint interface library and some deploy-
ment details of TaintART.
4.1 Taint Sources and Sinks
Taint analysis system is a general methodology which
is widely used in vulnerability detection, privacy tracking,
and malware analysis. Based on our design, we implement
TaintART for tracking multi-level information ﬂows. This
will help users to monitor sensitive information and assist
analysts to dissect malware behaviors. Moreover, we can
also adopt TaintART for enforcing policy on sensitive data
leakage.
In our implementation, we track four types of data from
ﬁfteen diﬀerent sources. Table 2 lists all data sources. We
categorize them as device identity, sensor data, sensitive
content and location data. We place taint source logic in
corresponding classes to track these data. For example, de-
vice identity such as IMEI number can be obtained from
TelephonyManager. TelephonyManager is one of many sys-
tem services in system server process. Apps can acquire
telephony data by sending request message to the telephony
manager through binder IPC. Therefore, our sources are
placed at a method in the TelephonyManager class for han-
dling requests of device identity from binder. The Taint-
ART source logic will attach a taint tag in that binder par-
cel.
For sink placements, we consider leakage to network and
external storage. If tainted data is passed to sink functions,
TaintART will record this event as data leakage. Because
we provide interfaces for placing sources and sinks, analysts
can focus and track data they are interested in.
In Section 3, we use one bit for taint tag to explain our
system design. For some scenarios, we need to track multi-
ple data sources. Therefore, we can use more bits for taint
storage to represent multiple taint tag states. For tracking
sensitive data in multiple levels, we use two bits for storing
one taint tag. We categorize data leakage in four levels. The
level zero indicates that there is data leakage. Because de-
vice identity information are always used for advertisement
tracking and account identity in current apps, these data are
less sensitive and are classiﬁed in the ﬁrst level. Sensor data
such as accelerometer and rotation information is in the sec-
ond level. At last, location data and sensitive content such
as messages, contact lists and call logs are categorized in
the third level. We consider data in level three as the most
sensitive data.
4.2 Taint Analysis Interface
Because TaintART is designed for general data ﬂow anal-
ysis, analysts can develop new tools or services based on
TaintART. We provide two basic interfaces for taint anal-
ysis which are addTaint() and getTaint(). Developers can
use addTaint() to update taint tag of a speciﬁc local vari-
able or objects, and inspect taint tag later. To achieve better
performance, we implement these two primitive interfaces as
intrinsic functions so that the TaintART compiler can in-
line the functions at the compilation time.
4.3
Implementation & Deployment Details
We prototype TaintART based on the current latest
Android version (Android 6.0.1 Marshmallow AOSP tag
android-6.0.1_r1) for Nexus 5 (target aosp_hammerhead).
We customize the ART compiler and ART runtime sources
to implement taint tag propagation. We also add sources
tracking logic in Android framework sources. To support
taint propagation through JNI, we also customize binder-
related sources in Android framework.
In summary, we
provide customized binary and libraries such as dex2oat,
Table 2: Taint Sources and Privacy Leakage Levels
Level
Leaked Data
Source
Class/Service
0 (00) No Leakage
1 (01) Device Identity
N/A
IMSI
IMEI
ICCID
SN
N/A
TelephonyManager
TelephonyManager
TelephonyManager
TelephonyManager
2 (10)
Sensor Data
Accelerometer
Rotation
SensorManager
SensorManager
Location Data
Last Seen Location
LocationManager
GPS Location
LocationManager
Network Location
LocationManager
3 (11)
Sensitive Content
SMS
MMS
Contacts
Call log
File content
Camera
Microphone
ContentResolver
ContentResolver
ContentResolver
ContentResolver
File
Camera
MediaRecorder
libart.so and libart-compiler.so. For the implementa-
tion, we reuse the peer-reviewed code from AOSP as much as
possible to ensure the stability and security of TaintART.
Since the code base of ART environment is stable after An-
droid 5.0, our implementation is generic for Android 5.0 and
6.0 versions.
To deploy TaintART on devices, we do not require users
or analysts to reinstall the customized systems from scratch.
Instead, analysts can overwrite our customized binary and
libraries to a target device with root privilege. Because we
modiﬁed Android framework code to place taint sources,
TaintART needs to re-compile framework code again so
that taint tags can transit through the framework code.
5. CASE STUDY
In this section, we study several popular apps and analyze
the possibility of privacy leakage using TaintART.
Experimental Setup We download and compile the lat-
est TaintDroid targeting aosp_arm-eng, which is based on
Android 4.3 released in July 2013 (android-4.3_r1). We
run our TaintART system on Android 6.0.1 which was re-
leased in December 2015 (android-6.0.1_r1). Apps in our
dataset used for the case study are downloaded from the
Google oﬃcial market (Google Play) in May 2016.
Privacy Tracking We test popular apps to study po-
tential privacy leakage in the “top chart” for various cate-
gories including shopping, payment, social, entertainment,
etc. We execute and manually interact with each app in
TaintDroid and TaintART respectively and record the re-
ports of privacy leakage. Table 3 illustrates details of our
analysis. By default, TaintDroid will deny loading all ex-
ternal native libraries. This makes some apps crashed
at launch time. We comment out those codes and al-
low JNI invocations for TaintDroid. However, some func-
tions of Taobao and Alipay are broken because of com-
patibility issues. One reason is that they try to use
Figure 7: Screenshots of privacy policy enforcement.
MultiDex class in their apps and this interface is not sup-
ported in Android 4.3. For privacy tracking, we found
that shopping apps such as Taobao and JD.COM accesses
device identity and sensor data. By inspecting the out-
bound packets, we found some packets sent to remote
server contain tainted identity and sensor data. For ex-
ample, all HTTP requests of JD.COM contain a device id
ﬁeld: “client.action?functionId=jshopUrlAdapter&body
=%7B%7D&uuid=[IMEI]&clientVersion=5.1.0”. Taobao will
include device orientation information in the “User-Agent”
ﬁeld for all requests. Both TaintDroid and TaintART can
capture these leakage events.
It is worth noting that the
latest Facebook app no longer supports Android version less
than 5.0. Therefore, TaintDroid cannot analyze new Face-
book app. This shows TaintART is more versatile.
Policy Enforcement Because TaintART supports the
latest Android runtime and provides an eﬃcient, extensible,
as well as easy-to-deploy methodology, it is also suitable
for policy enforcement. Unlike systems enforcing sensitive
API invocations, TaintART knows the sensitivity of data
passing to enforced functions. Based on TaintART, we
prototype a privacy policy enforcement function. In essence,
users can pre-deﬁne multi-level policy rules. For instance,
we have already deﬁned four privacy leakage levels in the
previous section. For each level, users can deﬁne diﬀerent
policies. Table 4 shows policies in four levels. We only record
level 1 data leakage in a log because many apps use on device
identity for authentication. For level 2, we alert users with
a notiﬁcation and replace sensitive information as random
values. Figure 7 depicts a screenshot of a notiﬁcation of the
level 2 privacy leakage event. For sensitive data in level 3,
TaintART will block any access to the data. Finally, we
also provide interfaces for developers to customize actions
for diﬀerent policies.
6. EVALUATION
In this section, we perform macrobenchmarks for common
apps and microbenchmarks for the compiler, Java environ-
ment, and investigate the memory usage of TaintART. We
also evaluate the compatibility of TaintART against An-
droid oﬃcial compatibility test suite. The device used in
our evaluation is a Nexus 5 device with Quadcore 2.3 GHz
CPU, 2 GB memory and 16 GB internal storage. The test
device runs the Google oﬃcial Android ﬁrmware, which is
Marshmallow 6.0.1 with build number MMB29K and the Linux
kernel version 3.4.0.
App Name
Version
Min/Target
SDK
TaintDroid Result (Error Message)
TaintART Result
Table 3: Privacy Leakage Analysis on Popular Apps.
Taobao
5.7.2
14/23
Some functions are broken:
method” in conﬁg error
“cannot ﬁnd
2: device identity, sensor data, location data
9.6.6.051201
15/23
Cannot login: “It is crowed” error
2: device identity, sensor data, location data
Alipay
JD.COM
Facebook
Skype
Instagram
Spotify
5.1.0
77.0.0.20.66
6.34.0.715
8.1.0
5.3.0.995
14/14
21/23
15/23
16/23
15/23
11/23
Device identity and accelerometer leakage
2: device identity, sensor data, location data
Cannot install: the minimum SDK is Android
5.0
1: device identity
Device identity leakage
Device identity leakage
No leakage
No leakage
1: device identity
1: device identity
0: no leakage
0: no leakage
Amazon Shopping
6.6.0.100
Table 4: Privacy Enforcement Policy.
Table 5: Macrobenchmark Results.
Level Description of Enforcement Policy
0
1
2
3
N/A
record events
record events, alert users and rewrite sensitive information
record events, alert users and prevent accesses
Macrobenchmark Name
(ms)
Original (with Opti-
mizing Backend)