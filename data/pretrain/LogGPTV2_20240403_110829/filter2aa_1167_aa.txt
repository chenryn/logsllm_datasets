A Bridge Too Far
Defeating Wired 802.1X with a 
Transparent Bridge Using Linux
Alva Lease ‘Skip’ Duckwall IV
Exorcyst at gmail d0t com
Who Is This Guy?
• Been working with Linux since before the 1.0 
kernel (1993ish)
• Unix admin by trade – transitioned to IT security
• Likes alphabet soup:
– CISSP, CISA, GCIH, GCIA, GCFW, GPEN, GWAPT
– GCUX, GSEC, GCFA, RHCE, SCSA (missing 12 letters)
– Sitting for the GSE written in the middle of August
• Works for Northrop Grumman on a team that 
performs full scope penetration tests ☺
THE BASICS
The Objective
To introduce a device on a wired 802.1X secured 
network with the following properties:
1. Transparent (undetectable) to the network 
administrators
2. Remote communication and interaction
3. The ability to inject traffic on to the network
What We Need
• Linux Box with 2 network ports
• Extra Ethernet Cable
• A Workstation authenticating to the local 
network using wired 802.1X of some sort 
• Another box that we use to handle the 
callbacks
A laptop/Netbook with an additional 
USB network device running Linux
– Obviously Difficult to Hide
– Powerful x86 CPU/memory/HD
– Best used for in person demos ☺
Small x86 Computer (industrial/mini pc)
– Atom CPU (x86) with 1-2gb memory
– Storage via laptop HD or flash
– Fanless in many cases
– Built in Dual Gig Ethernet in some
– 4”x4.5”x1” approximately
Plug Computer
• Embedded Marvell CPU (ARM) running Linux
• 512mb ram/512mb internal flash
• Can use SD cards for storage / Boot
• Fanless
• Built in Ethernet/USB port
• Looks like a weird “wall wart”
Choice of Linux Distro
• Backtrack 4r2 for x86 CPUs
– Quiet by default (no services start by default, no 
network by default, etc)
– Well tested and used
– Lots of built-in toys
– Yes, I know 5 is out.  Already had it working with 4.
• Ubuntu 9.04 for my plug computer
– Newer versions of the hardware might not support it
– Moving forward will probably switch to Debian or roll 
my own distribution
Quick Review: Ethernet Frame
For TCP/IP (without using 802.1q VLANS) this is 
what an Ethernet frame looks like
– Destination/Source Addresses are MAC addresses
– Either an Ethernet frame or Address Resolution 
Protocol
Preamble
Destination 
Address
Source 
Address
Length / 
Ethertype
Data
FCS
8 bytes
6 bytes
6 bytes
2 bytes
variable 46-
1500 bytes
4 bytes
Quick Review: ARP
Address Resolution Protocol
• Maps 32-bit IP addresses (192.168.0.1) to a 48-bit 
physical address (04:05:06:11:11:11)
• Question/reply protocol
– Question gets broadcast on the local segment
– Any reply usually comes from the IP being asked about 
– Replies are typically cached on the local machine for 
potential future use
Quick Review: ARP Cache
All operating systems keep a local cache of ARP 
entries to prevent flooding the local network 
segment with ARP requests for every packet sent
Example timeouts for ARP Caches:
Windows XP – up to 10 minutes
Vista/2008 – random interval between 15-45s
Linux – 60s (tunable)
Quick Review: IP
IP encapsulates the higher level protocols such 
as TCP and UDP
• Uses IP addresses for source and destinations
• What happens if the destination is outside the 
local network?
0
4
8
16
19
31
Version
IHL
TOS
Total Length
Identification
Flags
Fragment Offset
TTL
Protcol
Header Checksum
Source IP Address
Destination IP Address
Options
Padding
Quick Review: Routing
Devices have a routing table to decide what to 
do with packets that leave the device. 
• Typically, the local network is the only place 
the device knows how to route to
• There is also usually a default gateway to 
route packets out of the network.
Quick Review: Routing (Contd)
When an IP packet gets routed to its next hop, the 
following happens:
1. The local routing table is consulted for the next hop
2. The local ARP cache is checked to see if the MAC 
address is known for the next hop, if not the next hop 
is ARP’d
3. The Ethernet frame is constructed with the destination 
MAC address and the source MAC address and the 
checksum calculated
4. The frame is fired off towards the next hop on the wire
Extensible Authentication Protocol
Framework for authentication
• Guidelines, not a specific implementation
• Multiple methods
– EAP-TLS
– EAP-MD5
– 40 or more so far 
EAP over LAN (EAPOL) is used by 802.1X
Quick Overview: 802.1X
802.1X is an IEEE standard for port-based network 
access control.  It consists of 3 main pieces.
1. Supplicant – The client authenticating
2. Authenticator – Device to which the client 
connects 
3. Authentication server – Determines whether the 
credentials provided are valid
802.1X Illustrated
1.
Supplicant (client) packages up authentication information in an 
EAPOL (EAP over LAN) packet and sends it to the switch
2.
The switch takes the EAPOL traffic and repackages the 
authentication traffic into a RADIUS request and passes it to the 
RADIUS server
3.
If the RADIUS request is approved, the traffic is allowed on the 
network
Client EAPOL Exchange
802.1X:Supplicant Policy Enforcement
The supplicant can be used to make policy decisions on the 
network through the assistance of an agent.
For Example:
• Check AV/Patch status
– Allow on the network or on a remediation subnet for 
updates
• Req. account/membership in a windows domain
– If the machine is in the local domain, allow access to 
network, otherwise a guest VLAN (or no access at all)
• Load Balance to the least populated VLAN
Common 802.1X Problems
• Equipment / Overhead
– Requires authentication server(s)
• More power
• More licenses
– Requires supported equipment (printers and other 
oddballs out there can cause issues)
• Complicated to set up
– Often a long-term project
– Phased deployment
– Really need an existing robust/mature infrastructure 
first
Common 802.1X Problems (Cont)
• Almost always exceptions
– Devices that can’t conform (printers/copiers)
• Backup Plan : Sticky MAC or MAC Auth Bypass (MAB)
– General exceptions to policy
• PXE booting items
• Hardware/software test networks
– Temporary exceptions to policy
• OS reloads
• Booting from windows -> linux
Common 802.1X Problems (Cont)
• Client side problems
– How often does the link actually go down on the 
client?
• Kicked cables
• Power fluctuations 
• Machine shutdown/suspend at COB
• Reboots (think reboot Wednesday!)
– Additional configuration on the software side for 
the supplicant
Classic Attack on 802.1X
In 2004 a security researcher demonstrated an attack 
against wired 802.1X with a hub.  By inserting a hub, a 
rogue device could simply wait until the connection was 
authenticated and then piggyback once the connection 
was approved by spoofing the authorized client. I’ve 
provided links to the sources at the end. 
Problems with the Attack
By default, could only really use UDP because TCP 
causes a race condition:
1. Rogue device sends out a SYN to the far end
2. Far end sends back a SYN/ACK which hits both devices
3. The legit device should respond with a RST/ACK
4. The rogue device responds with an ACK
It’s a race!  Who will win?
The Update to the Attack
How can we improve upon the classical attack?
• Hubs don’t really exist anymore so we need 
something else
• Want to be able to use TCP as well as UDP
• Want to maintain invisibility on the network
PROOF OF CONCEPT
Demo Configuration 
What’s a Bridge?
A Network Bridge connects multiple network 
segments at the Data Link Layer (layer 2 OSI)
• IEEE 802.1D standard defines bridges
• A switch is a special kind of bridge, namely it 
has multiple ports 
Bridges in Linux
• Kernel module
– Integrated into the 2.6 series kernel
– Standard in most distributions
• User-land utilities
– Bridge-utils
• Usually available in most distributions, although not 
always installed
Bridge Utils in Linux
Use Bridge Utils to create a transparent bridge in Linux on 
a machine with 2 or more Ethernet cards.  By default 
the bridge will have the highest MAC address.
brctl is the main utility to configure a bridge in Linux:
brctl addbr br0               # create a bridge device called br0
brctl addif br0 eth1       # add eth1 to br0
brctl addif br0 eth2        # add eth2 to br0
ifconfig 0.0.0.0 eth1 up   # bring up the eth1 interface
ifconfig 0.0.0.0 eth2 up   # bring up the eth2 interface
ifconfig 0.0.0.0 br0 up     # bring up the bridge interface
It Can’t Be THAT Easy…
It’s not… no traffic on the bridge interface
Why Not?  To The Google!!
The 802.1D standard
Turns out that standards compliant bridges aren’t 
supposed to pass MAC addresses in the range of 
01-80-C2-00-00-00 to 01-80-C2-00-00-0F.  In our 
case 01:80:c2:00:00:03 is used
Simply Back Out the Patch
Seems like a simple fix, back out the patch that 
blocks the MAC addresses we care about.
Unfortunately the bridge module code has 
changed a fair amount in the past 4 years.  
Fortunately, Abb of Gremwell security already 
fixed the problem.
Abb of Gremwell’s Research
Abb provided a patch to forward the MAC 
addresses that are dropped by the 802.1D spec to 
the Gremwell Blog.
Abb also posted the code for an app called Marvin 
where he “decided to write a tool, capable to divert 
and re-inject a network connections while 
preserving the original network addresses, including 
layer 2 ones… but it already can be used to tap into 
a wired network protected with 802.1X”
Abb from Gremwell’s Marvin
“The tool will bridge the traffic between the first and the 
second interface and inject traffic it receives from the third 
interface into the first two.”
Marvin at a glace:
• Written in Java
• Requires 3 network ports: source, dest and injection
• Requires manual setting of MAC/IP
• Allows interaction with traffic going across the bridge
Not quite what we want, but it works and for some 
assessments, it might be worth a look.  I’ve included the link 
at the end in the ‘Links’ section
Abb’s Patch
The patch just comments out the code that 
drops the EAPOL.  Simply recompile the module 
with the code commented out. 
Recompile the Bridge Module
It Works!
Truly Transparent Config
#!/bin/bash
BRINT=br0
SWINT=eth0
COMPINT=eth3
#enable ip_forwarding
echo 1 > /proc/sys/net/ipv4/ip_forward
# create the bridge
brctl addbr $BRINT
brctl addif $BRINT $COMPINT
brctl addif $BRINT $SWINT
Transparent Config (2)
#bring up the interfaces
ifconfig $COMPINT 0.0.0.0 up promisc
ifconfig $SWINT 0.0.0.0 up promisc
ifconfig $BRINT 0.0.0.0 up promisc
#mii-tool -r will reset the auto negotiation 
essentially resetting the link
mii-tool -r  $SWINT
mii-tool -r  $COMPINT
Quick Transparent Demo
WORKING TOWARDS INTERACTION
On Towards Interaction
Right now the bridge looks like a piece of wire 
on the network, completely transparent.
From a proof of concept point we’ve introduced 
a rogue device onto a wired network secured by 
802.1X.
However, being able to remotely interact with 
the device would be a lot more fun!
Requirements For Interaction
So, what do we need to make our rogue device 
more interactive?
• Don’t trip up any additional security measures 
(MAC security on top of 802.1X) and kill the 
connection
• Make the traffic look like the computer whose 
connection we’re stealing