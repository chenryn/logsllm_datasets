class Horse : Mammal
{
    ...
Download from finelybook PI:EMAIL
424
    public override string GetTypeName()
    {
        return "This is a horse";
    }
}
class Whale : Mammal
{
    ...
    public override string GetTypeName()
    {
        return "This is a whale";
    }
}
class Aardvark : Mammal
{
    ...
}
There are two things that you should note: first, the override
keyword used by the GetTypeName method in the Horse and Whale
classes, and second, the fact that the Aardvark class does not have a
GetTypeName method.
Now examine the following block of code:
Click here to view code image
Mammal myMammal;
Horse myHorse = new Horse(...);
Whale myWhale = new Whale(...);
Aardvark myAardvark = new Aardvark(...);
Click here to view code image
myMammal = myHorse;
Console.WriteLine(myMammal.GetTypeName()); // Horse
myMammal = myWhale;
Console.WriteLine(myMammal.GetTypeName()); // Whale
myMammal = myAardvark;
Console.WriteLine(myMammal.GetTypeName()); // Aardvark
What will the three different Console.WriteLine statements output?
At first glance, you would expect them all to print “This is a mammal”
because each statement calls the GetTypeName method on the
myMammal variable, which is a Mammal. However, in the first case,
you can see that myMammal is actually a reference to a Horse.
(Remember, you are allowed to assign a Horse to a Mammal variable
Download from finelybook PI:EMAIL
425
because the Horse class inherits from the Mammal class.) Because the
GetTypeName method is defined as virtual, the runtime works out that it
should call the Horse.GetTypeName method, so the statement actually
prints the message “This is a horse.” The same logic applies to the
second Console.WriteLine statement, which outputs the message “This
is a whale.” The third statement calls Console.WriteLine on an
Aardvark object. However, the Aardvark class does not have a
GetTypeName method, so the default method in the Mammal class is
called, returning the string “This is a mammal.”
This phenomenon of the same statement invoking a different method
depending on its context is called polymorphism, which literally means
“many forms.”
Understanding protected access
The public and private access keywords create two extremes of accessibility:
public fields and methods of a class are accessible to everyone, whereas
private fields and methods of a class are accessible only to the class itself.
These two extremes are sufficient when you consider classes in isolation.
However, as all experienced object-oriented programmers know, isolated
classes cannot solve complex problems. Inheritance is a powerful way of
connecting classes, and there is clearly a special and close relationship
between a derived class and its base class. Frequently, it is useful for a base
class to allow derived classes to access some of its members while also
hiding these members from classes that are not part of the inheritance
hierarchy. In this situation, you can mark members with the protected
keyword. It works like this:
If a class A is derived from another class B, it can access the protected
class members of class B. In other words, inside the derived class A, a
protected member of class B is effectively public.
If a class A is not derived from another class B, it cannot access any
protected members of class B. So, within class A, a protected member
of class B is effectively private.
Download from finelybook PI:EMAIL
426
C# gives programmers the complete freedom to declare methods and
fields as protected. However, most object-oriented programming guidelines
recommend that you keep your fields strictly private whenever possible and
only relax these restrictions when necessary. Public fields violate
encapsulation because all users of the class have direct, unrestricted access to
the fields. Protected fields maintain encapsulation for users of a class, for
whom the protected fields are inaccessible. However, protected fields still
allow encapsulation to be violated by other classes that inherit from the base
class.
Note You can access a protected base class member not only in a
derived class but also in classes derived from the derived class.
In the following exercise, you will define a simple class hierarchy for
modeling different types of vehicles. You will define a base class named
Vehicle and derived classes named Airplane and Car. You will define
common methods named StartEngine and StopEngine in the Vehicle class,
and you will add some methods to both of the derived classes that are specific
to those classes. Finally, you will add a virtual method named Drive to the
Vehicle class and override the default implementation of this method in both
of the derived classes.
Create a hierarchy of classes
1. Start Microsoft Visual Studio 2017 if it is not already running.
2. Open the Vehicles solution, which is located in the \Microsoft
Press\VCSBS\Chapter 12\Vehicles folder in your Documents folder.
The Vehicles project contains the file Program.cs, which defines the
Program class with the Main and doWork methods that you have seen in
previous exercises.
3. In Solution Explorer, right-click the Vehicles project, point to Add, and
then click Class.
Download from finelybook PI:EMAIL
427
The Add New Item – Vehicles dialog box opens.
4. In the Add New Item – Vehicles dialog box, verify that the Class
template is highlighted. In the Name box, type Vehicle.cs, and then click
Add.
The file Vehicle.cs is created and added to the project and appears in the
Code and Text Editor window. The file contains the definition of an
empty class named Vehicle.
5. Add the StartEngine and StopEngine methods to the Vehicle class, as
shown next in bold:
Click here to view code image
class Vehicle
{
    public void StartEngine(string noiseToMakeWhenStarting)
    {
        Console.WriteLine($"Starting engine: ");
    }
    public void StopEngine(string noiseToMakeWhenStopping)
    {
        Console.WriteLine($"Stopping engine: ");
    }
}
All classes that derive from the Vehicle class will inherit these methods.
The values for the noiseToMakeWhenStarting and
noiseToMakeWhenStopping parameters will be different for each type of
vehicle and will help you to identify which vehicle is being started and
stopped later.
6. On the Project menu, click Add Class.
The Add New Item—Vehicles dialog box opens again.
7. In the Name box, type Airplane.cs, and then click Add.
A new file containing a class named Airplane is added to the project and
appears in the Code and Text Editor window.
8. In the Code and Text Editor window, modify the definition of the
Airplane class so that it inherits from the Vehicle class, as shown in bold
Download from finelybook PI:EMAIL
428
here:
Click here to view code image
class Airplane : Vehicle
{
}
9. Add the TakeOff and Land methods to the Airplane class, as shown in
bold in the following:
Click here to view code image
class Airplane : Vehicle
{
    public void TakeOff()
    {
        Console.WriteLine("Taking off");
    }
    public void Land()
    {
        Console.WriteLine("Landing");
    }
}
10. On the Project menu, click Add Class.
The Add New Item – Vehicles dialog box opens again.
11. In the Name text box, type Car.cs, and then click Add.
A new file containing a class named Car is added to the project and
appears in the Code and Text Editor window.
12. In the Code and Text Editor window, modify the definition of the Car
class so that it derives from the Vehicle class, as shown here in bold:
Click here to view code image
class Car : Vehicle
{
}
13. Add the Accelerate and Brake methods to the Car class, as shown in
bold in the following:
Click here to view code image
class Car : Vehicle
Download from finelybook PI:EMAIL
429
{
    public void Accelerate()
    {
        Console.WriteLine("Accelerating");
    }
    public void Brake()
    {
        Console.WriteLine("Braking");
    }
}
14. Display the Vehicle.cs file in the Code and Text Editor window.
15. Add the virtual Drive method to the Vehicle class, as presented here in
bold:
Click here to view code image
class Vehicle
{
    ...
    public virtual void Drive()
    {
        Console.WriteLine("Default implementation of the Drive
method");
    }
}
16. Display the Program.cs file in the Code and Text Editor window.
17. In the doWork method, delete the // TODO: comment and add the code
shown in bold to create an instance of the Airplane class and test its
methods by simulating a quick journey by airplane, as follows:
Click here to view code image
static void doWork()
{
    Console.WriteLine("Journey by airplane:");
    Airplane myPlane = new Airplane();
    myPlane.StartEngine("Contact");
    myPlane.TakeOff();
    myPlane.Drive();
    myPlane.Land();
    myPlane.StopEngine("Whirr");
}
18. Add the statements that follow (shown in bold) to the doWork method
after the code you just wrote. These statements create an instance of the
Download from finelybook PI:EMAIL
430
Car class and test its methods.
Click here to view code image
static void doWork()
{
    ...
    Console.WriteLine();
    Console.WriteLine("Journey by car:");
    Car myCar = new Car();
    myCar.StartEngine("Brm brm");
    myCar.Accelerate();
    myCar.Drive();
    myCar.Brake();
    myCar.StopEngine("Phut phut");
}
19. On the Debug menu, click Start Without Debugging.
In the console window, verify that the program outputs messages
simulating the different stages of performing a journey by airplane and
by car, as shown in the following image:
Notice that both modes of transport invoke the default implementation
of the virtual Drive method because neither class currently overrides this
method.
20. Press Enter to close the application and return to Visual Studio 2017.
21. Display the Airplane class in the Code and Text Editor window.
Override the Drive method in the Airplane class, as follows in bold:
Download from finelybook PI:EMAIL
431
Click here to view code image
class Airplane : Vehicle
{
    ...
    public override void Drive()
    {
        Console.WriteLine("Flying");
    }
}
Note IntelliSense displays a list of available virtual methods. If
you select the Drive method from the IntelliSense list, Visual
Studio automatically inserts into your code a statement that calls
the base.Drive method. If this happens, delete the statement,
because this exercise does not require it.
22. Display the Car class in the Code and Text Editor window. Override the
Drive method in the Car class, as shown in bold in the following:
Click here to view code image
class Car : Vehicle
{
    ...
    public override void Drive()
    {
        Console.WriteLine("Motoring");
    }
}
23. On the Debug menu, click Start Without Debugging.
In the console window, notice that the Airplane object now displays the
message Flying when the application calls the Drive method, and the
Car object displays the message Motoring:
Download from finelybook PI:EMAIL
432
24. Press Enter to close the application and return to Visual Studio 2017.
25. Display the Program.cs file in the Code and Text Editor window.
26. Add the statements shown here in bold to the end of the doWork
method:
Click here to view code image
static void doWork()
{
    ...
    Console.WriteLine("\nTesting polymorphism");
    Vehicle v = myCar;
    v.Drive();
    v = myPlane;
    v.Drive();
}
This code tests the polymorphism provided by the virtual Drive method.
The code creates a reference to the Car object by using a Vehicle
variable (which is safe because all Car objects are Vehicle objects) and
then calls the Drive method by using this Vehicle variable. The final two
statements refer the Vehicle variable to the Airplane object and call what
seems to be the same Drive method again.
27. On the Debug menu, click Start Without Debugging.
Download from finelybook PI:EMAIL
433
In the console window, verify that the same messages appear as before,
followed by this text:
Click here to view code image
Testing polymorphism
Motoring
Flying
The Drive method is virtual, so the runtime (not the compiler) works out
which version of the Drive method to call when invoking it through a
Vehicle variable, based on the real type of the object referenced by this
variable. In the first case, the Vehicle object refers to a Car, so the
application calls the Car.Drive method. In the second case, the Vehicle
object refers to an Airplane, so the application calls the Airplane.Drive
method.
28. Press Enter to close the application and return to Visual Studio 2017.
Creating extension methods
Inheritance is a powerful feature that makes it possible for you to extend the
functionality of a class by creating a new class that derives from it. However,
sometimes using inheritance is not the most appropriate mechanism for
adding new behaviors, especially if you need to quickly extend a type without
affecting existing code.
For example, suppose you want to add a new feature to the int type, such
as a method named Negate that returns the negative equivalent value that an
integer currently contains. (I know that you could simply use the unary minus
operator [–] to perform the same task, but bear with me.) One way to achieve
this is to define a new type named NegInt32 that inherits from System.Int32
(int is an alias for System.Int32) and adds the Negate method:
Click here to view code image
class NegInt32 : System.Int32  //
{
    public int Negate()
    {
        ...
    }
}
Download from finelybook PI:EMAIL
434
The theory is that NegInt32 will inherit all the functionality associated
with the System.Int32 type in addition to the Negate method. There are two
reasons why you might not want to follow this approach:
This method applies only to the NegInt32 type, and if you want to use
it with existing int variables in your code, you have to change the
definition of every int variable to the NegInt32 type.
The System.Int32 type is actually a structure, not a class, and you
cannot use inheritance with structures.
This is where extension methods become very useful.
Using an extension method, you can extend an existing type (a class or
structure) with additional static methods. These static methods become
immediately available to your code in any statements that reference data of
the type being extended.
You define an extension method in a static class and specify the type to
which the method applies as the first parameter to the method, along with the
this keyword. Here’s an example showing how you can implement the
Negate extension method for the int type:
Click here to view code image
static class Util
{
    public static int Negate(this int i)
    {
        return -i;
    }
}
The syntax looks a little odd, but it is the this keyword prefixing the
parameter to Negate that identifies it as an extension method, and the fact that
the parameter that this prefixes is an int means that you are extending the int
type.
To use the extension method, bring the Util class into scope. (If necessary,
add a using statement that specifies the namespace to which the Util class
belongs, or a using static statement that specifies the Util class directly.) Then
you can simply use dot notation (.) to reference the method, like this:
Click here to view code image
Download from finelybook PI:EMAIL
435
int x = 591;
Console.WriteLine($"x.Negate {x.Negate()}");
Notice that you do not need to reference the Util class anywhere in the
statement that calls the Negate method. The C# compiler automatically
detects all extension methods for a given type from all the static classes that
are in scope. You can also invoke the Util.Negate method by passing an int as
the parameter, using the regular syntax you have seen before, although this
use obviates the purpose of defining the method as an extension method:
Click here to view code image
int x = 591; Console.WriteLine($"x.Negate {Util.Negate(x)}");
In the following exercise, you will add an extension method to the int
type. With this extension method, you can convert the value in an int variable
from base 10 to a representation of that value in a different number base.
Create an extension method
1. In Visual Studio 2017, open the ExtensionMethod solution, which is
located in the \Microsoft Press\VCSBS\Chapter 12\ExtensionMethod
folder in your Documents folder.
2. Display the Util.cs file in the Code and Text Editor window.
This file contains a static class named Util in a namespace named
Extensions. Remember that you must define extension methods inside a
static class. The class is empty apart from the // TODO: comment.
3. Delete the comment and declare a public static method in the Util class,
named ConvertToBase. The method should take two parameters: an int
parameter named i, prefixed with the this keyword to indicate that the
method is an extension method for the int type, and another ordinary int
parameter named baseToConvertTo.
The method will convert the value in i to the base indicated by
baseToConvertTo. The method should return an int containing the
converted value.
The ConvertToBase method should look like this:
Click here to view code image
Download from finelybook PI:EMAIL
436
static class Util
{
    public static int ConvertToBase(this int i, int
baseToConvertTo)
    {
    }
}
4. Add an if statement to the ConvertToBase method that checks that the
value of the baseToConvertTo parameter is between 2 and 10.
The algorithm used by this exercise does not work reliably outside this
range of values. Throw an ArgumentException exception with a suitable
message if the value of baseToConvertTo is outside this range.
The ConvertToBase method should look like this:
Click here to view code image
public static int ConvertToBase(this int i, int baseToConvertTo)
{
    if (baseToConvertTo  10)
    {
        throw new ArgumentException("Value cannot be converted