| br c
| c := *p
| *p := c
| p := q + offset
| p := alloc x
| p := *q
| *p := q
(1)
(2)
(3)
(4)
(5)
(6)
(7)
(8)
(9)
(10)
(11)
Figure 9: The instructions, Instrs, of our target language. x, y, and z
range over data registers RegsD, c ranges over code-pointer registers
RegsC , and p and q range over data-pointer registers RegsP .
compute a data pointer by adding a data pointer to an integer offset
(Equation 8), allocate a memory object with size in a given data
register (Equation 9), load a data pointer from memory into a regis-
ter, or store a data pointer in a register to memory (Equation 11).
Although all arithmetic operations are assumed to be binary, when
convenient we will depict operations as using fewer registers.
A program is a map from instruction addresses to instructions.
That is, for space of instruction addresses AddrsC containing a
designated initial address ι ∈ AddrsC, the language of programs is
Lang = AddrsC → Instrs.
Instrs does not contain instructions similar to those in an ar-
chitecture with a complex instruction-set, which may, e.g., perform
operations directly on memory or call to and return from a proce-
dure. The design of µCFI directly generalizes to analyze programs
that use such an instruction set. In particular, the actual implemen-
tation of µCFI monitors programs compiled for the x86 architecture.
A.2 Semantics
Each program P ∈ Lang defines a language of sequences of program
states, called runs, that are generated by executing a sequence of
instructions in P from an initial state. A state is a frame that binds
registers to values, paired with a heap that maps data addresses to
values. Let Words be a space of data words, let Objs be a space of
data objects. A data address is a data object paired with an integer
offset; i.e., the space of data addresses is denoted AddrsD = Objs ×
Words. The space of values is denoted Values = Words ∪ AddrsC ∪
AddrsD.
A data frame is a map from data registers to words paired with
an offset value; i.e, the space of data-register frames is denoted
FramesD = (RegsD → Words) × Words. The spaces of code-pointer
frames (FramesC = RegsC → AddrsC) and data-pointer frames
(FramesP = RegsP → AddrsD) are defined similarly. The code-
pointer and data-pointer frames of each initial program state map
each code and data-pointer register to null.
A heap is a pair consisting of (1) a map s : Objs → Z from each
object to its size and (2) a map m : AddrsD (cid:44)→ Values that for each
o ∈ Objs and i ∈ Z with 0 ≤ i < s (o), maps address (o, i) to some
value. The space of all heaps is denoted Heaps.
A state is a tuple consisting of (1) the address of the current
instruction, (2) a data frame, (3) a code-pointer frame, (4) a data-
pointer frame, and (5) a heap. The space of states is denoted States.
Each instruction in Instrs implements a transition function τ
that maps each pre-state and instruction to the resulting post-state.
The definition of τ is standard and is thus omitted in order to
simplify the presentation; the instructions that refer to symbol
offset update and use the offset value in the data frame of the
current state. For each program P ∈ Lang and sequence of states
r such that each pair of adjacent states in r are in the transition
relation of a corresponding instruction in P, r is a run of P. The runs
of P are denoted Runs(P).
A.3 Problem definition
In this section, we define the problem that we address in this work
in formal detail. We first define spaces of program instrumenters
and precise monitors, and then define conditions under which they
are valid control-security monitors.
C → AddrsC.
A procedure that, given a program, generates another program is
a program instrumenter; i.e., the space of all program instrumenters
is denoted Instrumeters = Lang → Lang. A procedure that, given a
program and sequence of instruction addresses, outputs an instruc-
tion address is a control monitor; i.e., the space of control monitors
is denoted Mons = Lang × Addrs∗
The control trace of a run r is the sequence of targets of indirect
branches taken by r. Our formal definition of a valid control monitor
is expressed in terms of the code addresses visited over program
runs and conditions under which one run of program simulates a
run of another program. For each P ∈ Lang and r ∈ Runs(P), the
sequence of targets of indirect control branches taken at states of r
is the control trace of r, and is denoted Trace(r ).
A run r is simulated by a run r′ if for each state in r, there
is a corresponding state in r′ that maintains all state of r, and
may optionally maintain additional state. Let r be a sequence of
states q0, q1, . . . , qn ∈ States. For P′ ∈ Lang, let r′ ∈ Runs(P′) be
a concatenation of n non-empty subsequences of states such that
for each 0 ≤ i < n and each state q′ in the ith subsequence, q′
has the data-register frame, code-pointer frame, and data-pointer
frames of qi over all registers bound in qi (although q′ may bind
registers that are unbound in qi), and q′ has the heap of qi. Then r
is simulated by r′, denoted r ∼ r′.
Our work is intended to be applied in a security context in
which one may both instrument a program before it is run and
monitor the control branches taken by the instrumented program.
Thus, we will address the problem of designing control frameworks,
consisting of both a static program instrumenter and a dynamic
control monitor, which may read the control branches chosen by
an instrumented program and output a single instruction address
to which the instrumented program may next transfer control.
Definition 1. Let P ∈ Lang, r ∈ Runs(P), q ∈ States be such
that r · q ∈ Runs(P), and let a ∈ AddrsC be such that Trace(r · q) =
Trace(r ) · a. Let I ∈ Instrumeters and M ∈ Mons be such that there
is some r′ ∈ Runs(I (P)) such that (1) r ∼ r′; (2) M (Trace(r′)) = a.
Then I and M are a valid control framework for P and r · q.
The definition of a valid control framework ensures that any
framework that exists is precise. In particular, because each control
monitor is a function, each monitor in a framework, given a control
trace of a program, may output only a single code address that
may be the valid target of the monitored program’s not indirect
branch. Such a definition is not satisfied by previous approaches to
online control-security enforcement, such as PittyPat [21]. Such
approaches, after reading a control trace, may potentially allow any
control target from a non-singular set. Thus, the analysis cannot
implement a function from each trace to a single control target
allowed next.
The problem that we address in this work is to develop a valid
control framework for each program and its runs. To address this
problem, we define a program instrumenter Instrumenter (§A.4.1)
and a program monitor Monitor (§A.4.2) such that Instrumenter
and Monitor are a valid control framework for each program and
each of its runs.
A.4 Protecting control security
In this section, we formally define a program instrumenter (§A.4.1)
and program monitor (§A.4.2).
A.4.1 Program instrumentation. Instrumenter, given a program
P, generates a program P’ such that each offset used to compute
a pointer in P determines the target of an indirect branch in P’. P’
uses two code registers that we assume, without loss of generality,
are not used by P, namely offsetTgt and nextInstr. P’ also con-
tains a region of code starting at a fixed address offsetCode; the
size of the region is the maximum value of a data word, denoted
|Words|. The range of instruction addresses between offsetCode
and offsetCode + |Words| is called the offset-code region. Each in-
struction in the code region is a noop, except for the final instruction,
which indirectly branches to the code address stored in nextInstr.
P’ is an instrumentation of P that, before each instruction that
performs pointer arithmetic, translates the offset used to compute
the new pointer to a corresponding indirect branch. Let p, q ∈ RegsP
be such that q:=p+offset ∈ P. P’ includes the following additional
instructions immediately before P:
(1) An instruction that computes a branch target of offsetCode
plus x: offsetTgt:=offsetCode+offset.
(2) An instruction that binds the address of the next instruction
to nextInstr: nextInstr:=ip+1.
(3) An instruction that transfers control to the instruction at
offsetTgt: br offsetTgt.
Instrumenter is a valid program instrumenter: given a program
P, Instrumenter generates a program that simulates each run of P.
Lemma 1. For each P ∈ Lang and r ∈ Runs(P), there is some
r′ ∈ Runs(Instrumenter(P)) such that r ∼ r′.
Proof. Proof by induction on r. For the base case, r is an ini-
tial state σ, which is a data frame paired with an empty heap.
σ is also an initial state of Instrumenter(P). Thus r is a run of
Instrumenter(P) such that r ∼ r.
For the inductive case, r is a initial run s, followed by states σ
and σ ′. By the inductive hypothesis, s · σ is simulated by some s′ ∈
Runs(Instrumenter(P)). The instruction i ∈ Instrs on which σ
transitions to σ ′ may have one of the following forms. If i is any
instruction other than one that performs pointer arithmetic, then
s′·σ ′ is in Runs(Instrumenter(P)) and s·σ ·σ ′ ∼ s′·σ ′. Otherwise,
if i performs pointer arithmetic, then from σ, Instrumenter(P)
steps through a bounded sequence of states Σ with instruction
addresses in the offset-code region, and then the state σ ′. s · Σ is in
Runs(Instrumenter(P)) and s · σ · σ ′ ∼ s′ · Σ.
□
The key idea behind our approach is to monitor programs in a
specific form that reflect values used in pointer arithmetic as targets
of control branches. In particular, if each instruction that performs
pointer arithmetic in each run of program P is a preceded by an
instruction that branches to a target that encodes that encodes the
offset, then we say that P reflects pointer-arithmetic offsets.
Definition 2. Let P ∈ Lang be such that for each r ∈ Runs(P)
and each σ ∈ r that steps using an instruction that performs pointer
arithmetic, there is some σ ′ ∈ r before σ and c ∈ RegsC such that σ ′
steps on instruction br c, σ (offset) = σ ′(offsetCode+c), and there
is no σ ′′ ∈ r between σ ′ and σ and d ∈ RegsC such that σ ′′ steps on
instruction br d and offsetCode ≤ σ ′′(d) < offsetCode + |Words|.
Then P reflects pointer-arithmetic offsets.
Instrumenter only generates programs that reflect pointer-
arithmetic offsets.
Lemma 2. For each P ∈ Lang, Instrumenter(P) reflects pointer-
arithmetic offsets.
Lemma 2 follows directly from the definition of Instrumenter.
A.4.2 Control monitoring. Monitor, given a program P and con-
trol trace T , outputs the only control target that may be taken next
by a valid run of P that has executed T . We now define the domain of
information about program states maintained by Monitor (§A.4.2)
and then define how domain information is updated by simulating
each instruction executed by P (§A.4.3).
Monitor States. Monitor maintains a code-pointer frame, data-
pointer frame, and heap that soundly models the structure of data
objects and code pointers in the P’ heap, while retaining no informa-
tion about the data values in the heap. I.e., let the countably-infinite
space of monitor objects (used by the monitor to model data objects
allocated by the monitored program) be denoted ObjsM . Let a mon-
itor address be a monitor object paired with an offset; i.e., the space
of monitor addresses is denoted AddrsM = ObjsM × Z. A moni-
tor pointer frame binds data pointer to monitor addresses; i.e., the
space of monitor pointer frames is denoted FramesM = RegsP →
AddrsM . A monitor heap is a partial map from monitor addresses to
code addresses and monitor address; i.e, the space of monitor heaps
is denoted HeapsM = AddrsM (cid:44)→ AddrsC ∪ AddrsM . A monitor
state is a tuple (a, o, C, D, H ), where
instruction.
(1) The address a ∈ AddrsC of the current instruction.
(2) The offset o ∈ Z to be used in the next pointer-arithmetic
(3) The code-pointer frame C ∈ FramesC (§A.2) of the moni-
(4) A monitor-pointer frame D ∈ FramesM (§A.2) isomorphic
(as defined below) to the data-pointer frame of the monitored
program.
(5) A monitor heap H ∈ HeapsM isomorphic (as defined below)
tored program.
to the heap of the monitored program.
.
The space of monitor states is denoted StatesM .
Each monitor state represents an infinite set of program states
with identical code-pointer frames and isomorphic heaps. Let Q ∈
FramesP , Q′ ∈ FramesM , H ∈ Heaps, H′ ∈ HeapsM , and f
:
Objs → ObjsM be such that (1) f is one-to-one, (2) for each p ∈
RegsP , f (Q (p)) = Q′(p), (3) for each o ∈ Objs and i ∈ Z, if H (o, i) ∈
AddrsC, then H′(o, i) = H′( f (o), i) and if H (o, i) ∈ AddrsD, then
f (H (o, i)) = H′( f (o), i). Then for a ∈ AddrsC, D ∈ FramesD,
C ∈ FramesC, state q = (a, D, C, Q, H ) is object-abstracted by mon-
itor state q′ = (a, D, C, Q′, H′), denoted q ⪯O q′. If in addition,
q(offset) = q′(offset), then q is fully abstracted by q′, denoted
q ⪯ q′.
M ∈ StatesM con-
sists of the initial instruction pointer of P, a default offset value, the
initial code-pointer and data-pointer frames, and an empty monitor
heap. For each initial state σ ∈ States of P, σ ⪯ ιP
M
Interpretations of instructions over monitor states. Monitor,
A.4.3
given P and a sequence of code addressesT , determines the sequence
of instructions I that must be executed by any run of P that branches
to the addresses in T in sequence. After reading the sequence, the
monitor outputs the single valid control target of the next indirect
branch of the monitored run.
For each P ∈ Lang, the initial monitor state ιP
To do so, Monitor models the effect of each instruction in I on
the current state of P by appropriately updating a monitor state that
it maintains. For a ∈ AddrsC, o ∈ Z, C ∈ FramesC, D ∈ FramesM ,
and H ∈ HeapsM , each monitor pre-state q = (a, o, C, D, H ) and in-
struction i ∈ Instrs define a unique monitor post-state, as follows.
• Each instruction i that performs arithmetic on data, loads
from memory, stores data to memory only updates the in-
struction address of q to be the address following i.
• For each c ∈ RegsC, instruction br c updates the instruction
address of the maintained monitor to be C (c). If the branch
target is within the offset code region (i.e., if
offsetCode ≤ C (c) < offsetCode + |Words|), then o is up-
dated to be C (c) − offsetCode.
• For each c ∈ RegsC and p ∈ RegsP , instruction c:=*p updates
C to bind c to H (p). Instruction *p:=c updates H to map
address H (D(p) to C (c).
• For all p, q ∈ RegsP and each x ∈ RegsD, instruction p:=q+x
updates D to bind p to D(q) + o.
• For each x ∈ RegsD, instruction p:=alloc x updates D to
bind a monitor object not in the domain of H to p.
• For all p, q ∈ RegsP , instruction q:=*p updates D to bind q
to H (D(p)). Instruction *q:=p updates H to map H (D(q)) to
D(p).
For each q ∈ StatesM and i ∈ Instrs, the monitor state resulting
from executing i on q is denoted τM (q, i).
Interpretations of instructions over monitors preserve two key
properties. First, the interpretation of each instruction preserves
object abstraction.
Lemma 3. For each q ∈ States, qM ∈ StatesM such that q ⪯O
qM , and i ∈ Instrs, it holds that τ (q, i) ⪯O τM (qM , i).
Proof. Proof by cases on the structure of i. The proof follows
directly from the definition of object abstraction offsets and τM on
i.
□
Second, interpretation of pointer arithmetic preserves full ab-
straction.
Lemma 4. For each q ∈ States, qM ∈ StatesM such that q ⪯
qM , p, q ∈ RegsD, it holds that τ (q, i) ⪯ τM (qM , i), where i ≡
p:=q+offset.
Proof. The proof follows immediately from the definition of
full abstraction and the interpretations of pointer arithmetic over
concrete states and monitor states.
□
The fact that the transformer over monitor states soundly models
the effect of each instruction supports the fact that the analysis
monitor always soundly determines the unique next valid control-
transfer target.
Lemma 5. Let P ∈ Lang be such that P reflects pointer-arithmetic
, and a ∈ AddrsC be such that
offsets, r ∈ Runs(P), T ∈ Addrs∗
Trace(r ) = T · a. Then Monitor(T ) = a.
C
, and σ ⪯ ιP
M
Proof. Proof by induction on r. The key property established
by induction on r is that after Monitor analyzes r with final state
σ, monitor maintains a monitor state σM such that σ ⪯O σM ; if σ
has the instruction pointer of an instruction that performs pointer
arithmetic, then σ ⪯ σM . For the base case, where r is a sequence
consisting of only an initial state σ, the monitor state maintained
by Monitor is ιP
M
For the inductive case, r is a sequence of states s, followed by
states σ and then σ ′. Monitor, given Trace(s · σ ), maintains a
monitor state σM such that σ ⪯ σm, by the inductive hypothesis.
If σ has the instruction pointer of an instruction that does not
perform pointer arithmetic, then for σ ′
= τM (σ , i) the monitor
state maintained by Monitor, it holds that σ ′ ⪯O σ ′
M
, by Lemma 3.
Otherwise, if σ has the instruction pointer of an instruction i that
performs pointer arithmetic, then s contains a step on a branch
instruction into the offset code region, and the most recent such
instruction branches to offsetCode + offset, by the assumption
that P reflects pointer-arithmetic offsets. Thus the offset in σM is
offset in σ, by the definition of τM for branch instructions. Thus
σ ′ ⪯ σ ′
M
The property proved by induction, combined with the definition
of object abstraction, entail that Monitor(T ) = a.
□
, by Lemma 4.
.
M
The components of µCFI correctly enforce control security.
Theorem 1. For each P ∈ Lang and r ∈ RunsP, the system
(Instrumenter, Monitor) is a valid control framework.
Proof. The fact that (Instrumenter, Monitor) is a valid con-
trol framework follows directly from the definition of a valid con-
trol framework (Defn. 1), the fact that Instrumenter is a valid
instrumenter (Lemma 1) that only generates programs that reflect
pointer-arithmetic offsets (Lemma 2), and the fact that Monitor
soundly determines each control target (Lemma 5).
□