27:
28:
29:
30:
31: return ğ‘†2
B Algorithm 9 (FindExtremePairs)
Let D be a database with ğ‘… records and let RS(D) be its response
set. Algorithm 9 (FindExtremePairs) returns all configurations of
extreme points (left, right, top, bottom) such that no points are dom-
inated by left and bottom, and no points dominate right and top.
if ğ‘ âˆˆ ğ‘€ âˆ’ ğ‘†2 then
ğ‘ƒğ‘,top, ğ‘†ğ‘,top, ğ‘ƒtop,ğ‘ = Boxes(top, ğ‘)
ğ‘† = ğ‘ƒğ‘,top âˆª ğ‘†ğ‘,top âˆª ğ‘ƒtop,ğ‘
if left, right âˆˆ ğ‘† then
return ğ‘†2 // ğ‘ and top are collinear
else if left âˆˆ ğ‘† then
return ğ‘†2 // top dominates ğ‘
else if right âˆˆ ğ‘† then
// top anti-dominates ğ‘
ğ¸ = Edges(ğ‘€ âˆ’ {ğ‘}, RS(D))
ğ‘†2 = ğ‘†2 âˆ’ ğ‘€
Add all ğ‘ in an edge in ğ¸ not containing top or ğ‘â€² âˆˆ ğ´0 to ğ‘†2.
return ğ‘†2
else if ğ‘ âˆˆ ğ‘€ âˆ’ ğ‘†1 then
ğ‘ƒğ‘,ğ‘, ğ‘†ğ‘,ğ‘, ğ‘ƒğ‘,ğ‘ Boxes(ğ‘, ğ‘)
ğ‘† = ğ‘ƒğ‘,ğ‘ âˆª ğ‘†ğ‘,ğ‘ âˆª ğ‘ƒğ‘,ğ‘
if left, right âˆˆ ğ‘† then
return ğ‘†2 // ğ‘ and top are collinear
else if right âˆˆ ğ‘† then
return ğ‘†2 // top dominates ğ‘
else if left âˆˆ ğ‘† then
// top anti-dominates ğ‘
ğ¸ = Edges(ğ‘€ âˆ’ {ğ‘}, RS(D))
ğ‘†2 = ğ‘†2 âˆ’ ğ‘€
Add all ğ‘ in an edge in ğ¸ not containing top or ğ‘â€² âˆˆ ğ´0 to ğ‘†2.
return ğ‘†2
[48] Boyang Wang, Yantian Hou, Ming Li, Haitao Wang, and Hui Li. 2014. Maple:
Scalable Multi-Dimensional Range Search over Encrypted Cloud Data with Tree-
Based Index. In Proc. ACM Symp. on Information, Computer and Communications
Security (ASIA CCS).
[49] Zheguang Zhao, Seny Kamara, Tarik Moataz, and Stan Zdonik. 2021. Encrypted
Databases: From Theory to Systems. In Conf. on Innovative Data Systems Research
(CIDR).
A Algorithm 8 (DominanceID)
We describe how given the response set RS(D) and the ID ğ‘ of
a point with height 0, we compute the full set of IDs of points
that dominate D[ğ‘]. Let ğ‘, ğ‘ âˆˆ [ğ‘…] be the IDs of two points in
D. Algorithm Boxes, takes as input a pair (ğ‘, ğ‘) and returns the
following responses of RS(D) (see Figure 11):
â€¢ ğ‘†ğ‘,ğ‘: minimal response containing ğ‘ and ğ‘.
â€¢ ğ‘ƒğ‘,ğ‘: D minus the maximal responses containing ğ‘ but not ğ‘;
i.e., set of points ğ‘ such that every response containing ğ‘
and ğ‘ contains also ğ‘.
â€¢ ğ‘ƒğ‘,ğ‘: D minus the maximal responses containing ğ‘ but not ğ‘;
i.e., set of points ğ‘ such that every response containing ğ‘
and ğ‘ contains also ğ‘.
Algorithm 6: Boxes(ğ‘, ğ‘)
1: Let ğ‘†ğ‘,ğ‘ be the smallest response in RS(D) containing ğ‘ and ğ‘,
2: Let ğ¿ = D and ğ‘ƒğ‘,ğ‘, ğ‘ƒğ‘,ğ‘ be empty lists
3: for ğ‘ âˆˆ ğ¿ do
4:
5:
6:
7:
8: return ğ‘ƒğ‘,ğ‘, ğ‘†ğ‘,ğ‘ and ğ‘ƒğ‘,ğ‘
if (cid:154)ğ‘Ÿ âˆˆ RS(D), s.t. ğ‘, ğ‘ âˆˆ ğ‘Ÿ and ğ‘ âˆ‰ ğ‘Ÿ then
Add ğ‘ to ğ‘ƒğ‘,ğ‘
if (cid:154)ğ‘Ÿ âˆˆ RS(D), s.t. ğ‘, ğ‘ âˆˆ ğ‘Ÿ and ğ‘ âˆ‰ ğ‘Ÿ then
Add ğ‘ to ğ‘ƒğ‘,ğ‘
Figure 11: Sets output by Algorithm 6 for ğ‘, ğ‘ âˆˆ D, when ğ‘
strictly anti-dominates ğ‘ (left) and they are co-linear (right).
Given a pair of IDs (ğ‘, ğ‘), there are at most two distinct maximal
responses containing ğ‘ but not ğ‘ (or ğ‘ but not ğ‘). These responses
comprise the points in the maximal horizontal and vertical strips
of the domain that contain ğ‘ but not ğ‘ (or ğ‘ but not ğ‘). If ğ‘ and
ğ‘ share the same horizontal or vertical coordinate, only one of
the above strips is nonempty. Algorithm 8 (DominanceID) uses
Boxes to determine if top dominates ğ‘. If yes, then we return the
minimal response containing ğ‘, top and right. Else top must strictly
antidominate ğ‘. Let ğ‘† be the smallest response containing ğ‘, top
and right and let ğ‘€ be the smallest response containing ğ‘ and top.
It is clear that ğ‘† âˆ’ ğ‘€ contains all IDs of points that strictly dominate
ğ‘. To find the IDs of points that are colinear with ğ‘, we run Edges
with ğ‘€ âˆ’ {ğ‘} as input; the IDs of points that are colinear with ğ‘
must be one of the edges in the output. In particular, the colinear
points must be ğ‘ âˆˆ ğ¸ such that ğ¸ is the edge not containing top, left,
or any element of ğ´0. And so the algorithm outputs (ğ‘† âˆ’ ğ‘€) âˆª ğ¸.
bPa,bSa,bPb,aabPa,bSa,bPb,aaSession 7C: Database and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2257Algorithm 9: FindExtremePairs(RS(D))
Input: Response set RS(D) of database D
1: ğ¸1, ğ¸2, ğ¸3, ğ¸4 = Edges(D, RS(D))
2: Let PossibleConfigs be all possible combinations of ğ¸1, ğ¸2, ğ¸3 and ğ¸4
into LeftE, RightE, TopE, BottomE.
3: Initialize empty dictionary config.
4: for LeftE, RightE, TopE, BottomE in PossibleConfigs do
5:
6:
7:
for ğ¸1, ğ¸2 âˆˆ {LeftE, BottomE}, {RightE, TopE} do
for ğ‘, ğ‘ âˆˆ ğ¸1 Ã— ğ¸2 do
if the smallest response in RS(D) that contains ğ‘ and ğ‘ does not
contain any other element of ğ¸1 or ğ¸2 then
Add ğ‘, ğ‘ to config under their corresponding key left, right,
top, or bottom.
Return to line 5.
8:
Add config to PosExtremes.
9:
10:
11: Return PosExtremes
C Proofs
C.1 Proof of Proposition 2
Proof. Let D[ğ‘–] = ğ‘, D[ ğ‘—] = ğ‘, Dâ€²[ğ‘–] = ğ‘â€², and Dâ€²[ ğ‘—] = ğ‘â€².
We first show that RS(D) âŠ† RS(Dâ€²). Consider a response ğ´ in
RS(D) that contains ğ‘– and not ğ‘—. We will exemplify a query to
Dâ€² with response ğ´. Consider the set ğµ = (ğ´ âˆ’ {ğ‘–}). Since D[ğ‘–]
has a unique maximal value in the second coordinate the set ğµ
must be an element of RS(ğ·). By assumption, RS(D âˆ’ {ğ‘, ğ‘}) =
RS(Dâ€²âˆ’{ğ‘â€², ğ‘â€²}) and so we have that ğµ âˆˆ RS(Dâ€²). Let (ğ‘, ğ‘‘) âˆˆ D2 be
a query that generates the response ğµ in Dâ€². Now consider the query
((ğ‘šğ‘–ğ‘›0, 1), (ğ‘šğ‘ğ‘¥0, ğ‘‘1)) where ğ‘šğ‘–ğ‘›0 = min(ğ‘0, ğ‘0, ğ‘â€²
0) and ğ‘šğ‘ğ‘¥0 =
max(ğ‘‘0, ğ‘0, ğ‘â€²
0). Since the only additional identifier contained in this
region is ğ‘–, then the response generated by this query is ğ´ = ğµ âˆª{ğ‘–}
which implies ğ´ âˆˆ RS(Dâ€²). A similar argument holds for queries
that contain ğ‘— and not ğ‘–, as well as queries that contain both ğ‘– and ğ‘—,
which concludes the forward direction of the proof. One can also
extend this reasoning to show that RS(Dâ€²) âŠ† RS(D).
â–¡
C.2 Proof of Proposition 3
Proof. Let D[ğ‘–] = ğ‘ and Dâ€²[ğ‘–] = ğ‘â€². By assumption RS(D âˆ’
{ğ‘}) = RS(Dâ€² âˆ’ {ğ‘â€²}). We first show that RS(D) âŠ† RS(Dâ€²). We
claim that for any response ğ´âˆª{ğ‘–} in RS(D) there exists a response
ğ´ âˆª {ğ‘–} âˆˆ RS(Dâ€²). Let ğ´ âˆª {ğ‘–} be a response in RS(D) and let
(ğ‘, ğ‘‘) âˆˆ D2 be a query to D that produces such a response. We will
consider two possible cases and in each case explicitly give a query
to Dâ€² that must result in the response ğ´ âˆª {ğ‘–}.
Case 1: ğ‘0 < ğ‘0. Consider the query ((ğ‘0, ğ‘šğ‘–ğ‘›1), ğ‘‘) issued to Dâ€² such
that ğ‘šğ‘–ğ‘›1 = min(ğ‘â€²
since all points ğ‘Ÿ âˆˆ ğ´ are identical in both D and Dâ€² and ğ‘â€² is
contained in this query. Else if ğ‘šğ‘–ğ‘›1 = ğ‘â€²
1 then by definition of
close pair, ğ‘, ğ‘â€² must minimally dominate ğ‘. So no additional points
beside ğ‘â€² are contained in the response generated by ((ğ‘0, ğ‘šğ‘–ğ‘›1), ğ‘‘)
thus Resp(Dâ€², ((ğ‘0, ğ‘šğ‘–ğ‘›1), ğ‘‘)) = ğ´ âˆª {ğ‘–}.
Case 2: ğ‘0 â‰¤ ğ‘0. Since the query (ğ‘, ğ‘‘) contains ğ‘ then we have ğ‘ âª¯ ğ‘
and ğ‘ âª¯ ğ‘‘. Moreover ğ‘ âª¯ ğ‘â€² âª¯ ğ‘ and so Resp(Dâ€², (ğ‘, ğ‘‘)) = ğ´ âˆª {ğ‘–}.
That proves the forward direction of the proof. A similar ar-
gument holds for the backward direction and we conclude that
RS(D) = RS(Dâ€²).
â–¡
Resp(Dâ€², ((ğ‘0, ğ‘šğ‘–ğ‘›1), ğ‘‘)) = Resp(Dâ€², (ğ‘, ğ‘‘)) = ğ´ âˆª {ğ‘–}
1, ğ‘1). If ğ‘šğ‘–ğ‘›1 = ğ‘1 then
C.3 Proof of Lemma 5.1
Proof. We first show that Algorithm 7 returns the correct edges
i.e. the sets ğ¸ğ‘– for ğ‘– â‰¤ 4 contain IDs of all points with an extreme
coordinate value. Note that the second largest response in RS(D)
must exclude the ID of some extreme point ğ‘. For a contradiction,
suppose ğ‘ is not extreme. Then we could minimally extend the
query to include ğ‘ and the resulting query would have a response
strictly larger than the original query and strictly smaller than [ğ‘…]
since it is not extreme, hence a contradiction. Now consider the
second largest response containing the ID of ğ‘. The remaining ID(s)
must correspond to points with an extreme coordinate value in
another direction, else we could minimally extend the query to
include the non-extreme point(s). By extending this reasoning, we
recover the IDs of all points with an extreme coordinate.
In Algorithm 9, line 2 stores the at most 4! assignments of the
ğ¸ğ‘– to LeftE, RightE, TopE, and BottomE. The for loop on line 4 then
iterates through each possible assignment to identify the correct
IDs within each edge set. We want to find the IDs for the left-
most point, ğ‘, and bottom-most point, ğ‘, such that no points are
dominated by D[ğ‘] or D[ğ‘]. This corresponds to finding ğ‘ âˆˆ LeftE
and ğ‘ âˆˆ BottomE such that the minimal response containing them
contains no other extreme points. Suppose for a contradiction that
some edge point ğ‘ was dominated by either ğ‘ or ğ‘, then the minimal
query must also contain ğ‘. A similar argument holds for the top-
most and right-most points.
The algorithm terminates in ğ‘‚(ğ‘…|RS(D)|) time. It takes ğ‘‚(ğ‘…2 Â·
|RS(D)|) time to find the edges. Then, we iterate through pairs of
edges and look through RS(D) to find a smallest response.
â–¡
C.4 Proof of Lemma 5.2
Proof. Let left, right, top and bottom be the points defined by
config. Without loss of generality, assume that right dominates left
and bottom. We first show that lines 2 to 7 find a set of IDs of points
that are not dominating any point in D (i.e. a minimal antichain
ğ´0 of D up to rotation/reflection). By Algorithm 9, no point is
dominated by either left or bottom. Let ğ‘† be the smallest response
in RS(D) containing left and bottom. All points not dominated by
left and bottom must be in ğ‘†, and thus ğ´0 = ğ‘†.
By assumption, right must dominate all points with IDs in ğ‘†. Let
ğ‘ be a point with ID in ğ‘† and consider the response ğ‘‡ of query
(ğ‘, right). If there is a point ğ‘ with ID in ğ‘† such that ğ‘ âª¯ ğ‘, then
its ID must also be in response ğ‘‡ . In line 6 we find the set ğ‘„ of all
such IDs and delete ğ‘„ from ğ´0. Since the for loop on line 4 iterates
through all IDs in ğ‘†, and deletes the IDs of all points that must
dominate at least one other point in ğ‘†, then at the end of the loop
ğ´0 must be the set of all points not dominating any other point.
On lines 10 to 18, we construct the dominance graph. Let ğ‘† be the
IDs output by DominanceID(RS(D), ğ‘) for some ğ‘ âˆˆ ğ´0. Note that
ğ‘† âˆ’ {ğ‘} corresponds to the IDs of all records that dominate D[ğ‘].
The for loop starting on line 14 correctly builds the dominance
subgraph on all IDs in ğ‘†. We show that the following loop invariant
is maintained: at the end of iteration â„“ (1) no point with ID in
ğ‘† \ ğ‘‰ (ğºğ‘) is dominated by a point with a vertex in ğºğ‘ and (2) if ğ‘–
and ğ‘— are in ğ‘‰ (ğºğ‘) and D[ ğ‘—] minimally dominates D[ ğ‘—], then edge
(ğ‘–, ğ‘—) is in ğºğ‘. At the start ğºğ‘ = {ğ‘}; this is correct since ğ‘ âˆˆ ğ´0 and
ğ´0 is the set of IDs of points that do not dominate any other point.
Assume that at iteration â„“ the invariant holds. Find the next smallest
Session 7C: Database and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2258response ğ‘‡ that contains ğ‘ and only other IDs in ğ‘†. If ğ‘‡ contains ğ‘£
not in ğºğ‘ then add it to ğºğ‘. (1) holds since no point in ğ‘† \ ğ‘‰ (ğºğ‘)
dominates D[ğ‘£], otherwise it would be contained in ğ‘‡ and we could
form a strictly smaller response contradicting the minimality of ğ‘‡ .
For each sink ğ‘¡ âˆˆ ğºğ‘ such that ğ‘¡ âˆˆ ğ‘‡ we add (ğ‘¡, ğ‘£) to ğºğ‘. (2) holds
since D[ğ‘£] must dominate all points with IDs in ğ‘‡ âˆ© ğ‘‰ (ğºğ‘) and
must minimally dominate all sinks ğ‘¡ in ğºğ‘ that are contained in ğ‘‡ .
Suppose there is some ID ğ‘— in ğ‘‰ (ğºğ‘) that is minimally dominated
by ğ‘£ but is not a sink. Then this would violate the correctness of
ğºğ‘ at the end of iteration â„“ and hence this cannot happen.
Putting it all together, we want to show that taking the union of
all ğºğ‘ gives us the complete dominance graph ğº. Let ğ‘, ğ‘ âˆˆ D be
any points such that ğ‘ âª¯ ğ‘. By correctness of ğ´0, there exists some
ğ‘ âˆˆ ğ´0 such that D[ğ‘] âª¯ ğ‘, ğ‘, and thus ğ‘ and ğ‘ are contained in the
minimal query of ğ‘, right, and top. By the correctness of ğºğ‘, then
an edge from the IDs of ğ‘ to ğ‘ must be added when constructing ğºğ‘.
Since every dominance edge is added to a graph ğºğ‘ of some ğ‘, then
taking the union over all ğºğ‘ gives the complete dominance graph
of D. The Algorithm terminates in ğ‘‚(ğ‘…3|RS(D)|) time. It takes
ğ‘‚(ğ‘… Â· |RS(D)|) time to find the first antichain. Then, Algorithm 8
takes ğ‘‚(ğ‘…2 Â· |RS(D)|) and may be run ğ‘… times.