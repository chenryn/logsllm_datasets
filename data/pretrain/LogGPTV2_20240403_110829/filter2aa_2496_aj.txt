beef-xss
使用 beef：beef
查看 http://127.0.0.1:3000/hook.js
完整 payload 文件：
查看位于 http://127.0.0.1:3000/hook.js 上的 hook.js 文件，你应该会看到类似于长混淆的 JavaScript 文件的内容。
这是连接受害者返回命令和控制服务器的客户端 payload 。
一旦在目标应用程序上识别出 XSS，而不是原始的 alert(1) 样式的 payload，就可以修改   payload 来利用此漏洞。一旦你的受害者陷入此 XSS 陷阱，将导
致他们的浏览器连接回你这边并成为你的僵尸网络的一部分。
BeEF 支持哪些类型的后渗透攻击？一旦你的受害者受到你的控制，你就可以做任何 JavaScript 可以做的事情。你可
以通过 HTLM5打开相机并拍摄受害者的照片，你可以在屏幕上显示覆盖图以捕获凭据，也可以将其重定向到恶意网
站以执行恶意软件。
以下是 BeEF 从 XSS 攻击中引发大量问题的快速演示：
首先，确保你的 BeEF 服务器在攻击者计算机上运行。在我们的易受攻击的聊天支持系统的应用程序中，你可以访问
http://chat:3000/xss 并在练习2的字段中输入你的 payload：
一旦你的受害者连接到你的僵尸网络，你就可以完全控制他们的浏览器。你可以根据设备，浏览器和目标机器启用的
功能进行各种攻击。通过社会工程学演示 XSS 影响力的一个好方法是通过 Flash 更新提示将恶意软件推送到他们的计
算机。
一旦执行，将在受害者的计算机上显示弹出窗口，强制他们安装更新，其中包含我们准备的恶意软件。
我建议花一些时间熟悉所有 BeEf 的后渗透模块，并了解 JavaScript 的强大功能。由于我们会控制浏览器，因此我们
必须弄清楚如何在红队活动中使用它。一旦你通过 XSS 感染了受害者，你还想做些什么？我们将在后面的“从 XSS 到
shell”部分讨论这个问题。
Blind XSS 漏洞
Blind XSS 漏洞很少被讨论，因为它是需要耐心的游戏。什么是 Blind XSS 漏洞？正如攻击的名称所表示的那样，攻
击者/用户看不到存储的 XSS payload 的执行（无回显），只有管理员或后台员工才能看到。由于其攻击后端用户的
能力，所以这种攻击可能危害很大，但尽管如此，它还是经常被遗忘。
例如，我们假设某个应用程序有一个“联系我们”页面，允许用户向管理员提供联系信息，以便以后联系。由于该数据
的结果只能由管理员手动查看而不是用户请求查看，所以如果应用程序易受 XSS 攻击，攻击者不会立即看到他们的
“alert(1)” 攻击的回显。在这些情况下，我们可以使用 XSSHunter 来帮助我们验证 Blind XSS 漏洞。
XSSHunter 的工作原理是，当我们的 JavaScript payload 执行时，它将截取受害者屏幕（他们正在查看的当前页
面）的屏幕截图，并将该数据发送回 XSSHunter 的站点。发生这种情况时，XSSHunter 将发送一个警报，告知我们
的 payload 已执行并向我们提供所有详细信息。我们现在可以回去创建一个恶意 payload 并重新进行我们的攻击。
XSS Hunter：
禁用任何代理（即 Burp Suite）
在 https://xsshunter.com 创建帐户
登录 https://xsshunter.com/app
转到 Payload 模块以获得你的 Payload
修改 payload 以适应你的攻击或使用它构建 Polyglot
检查 XSS hunter 以查看 payload 执行情况
基于 DOM 的 XSS
对反射 XSS 和存储 XSS 的理解相对简单。我们已经知道，如果服务器没有为用户/数据库提供足够的输入/输出验证，
我们的恶意脚本代码就会通过源代码呈现给用户。然而，在基于 DOM 的 XSS 中，它略有不同，这导致了一些常见的
误解。因此，让我们花些时间专注于基于 DOM 的 XSS。
当攻击者可以操纵 Web 应用程序的客户端脚本时，就可以使用基于文档对象模型（DOM）的 XSS。如果攻击者可以
将恶意代码注入 DOM 并由客户端的浏览器读取，则可以在从 DOM 读回数据时执行 payload。
DOM 究竟是什么？文档对象模型（DOM）是 HTML 属性的一个特性。由于你的浏览器不理解 HTML，因此它会使
用将 HTML 转换为 DOM 模型的解释器。
让我们在聊天支持网站上试一下吧。查看易受攻击的 Web 应用程序，你应该能够看到聊天支持网站受到 XSS 攻击的
流程：
创建一个帐户
登录
去聊天
尝试  ，然后尝试一些更疯狂的 XSS 攻击！
在我们的示例中，我们在服务器端有 Node.js，socket.io（Node.js 的库）在用户和服务器之间设置 Web 套接字，
客户端 JavaScript 和我们的恶意 msg.msgText JavaScript。正如你在下面和页面的源代码中看到的那样，你不会像
在标准的反射/存储的 XSS 中那样直接引用你的“弹窗” payload。在这个例子里，我们将得知唯一指示可以调用
payload 的位置来自 msg.name 引用。这有时会使我们很难确定执行 XSS payload 的位置，或者是否需要打破任何
HTML 标记。
NodeJS 中的高级 XSS
XSS 可以不断用于攻击的一个重要原因是，仅靠过滤标签或某些字符防御它的话要困难得多。当 payload 特定于某种
语言或框架时，XSS 很难防御。由于每种语言在此漏洞方面都有其独到之处，因此 NodeJS 也不会有什么不同。
在高级 XSS 部分中，你将学习一些特定语言的 XSS 漏洞发挥作用的示例。我们的 NodeJS Web 应用程序将使用一种
更常见的 Web 堆栈和配置。此实现包括 Express Framework 和 Pug 模板引擎。重要的是要注意一点，默认情况
下，Express 确实没有内置的 XSS 防护，除非通过模板引擎进行渲染。当使用像 Pub 这样的模板引擎时，有两种常
见的方法可以找到 XSS 漏洞：(1)通过字符串插值，以及(2)缓冲代码。
模板引擎有一个字符串插值的概念，这是一种定义“字符串变量的占位符”的奇特方式。例如，让我们将字符串分配给
Pug 模板格式的变量：
- var title = "This is the HTML Title" 
- var THP = "Hack the Planet"  
h1 #{title} 
p The Hacker Playbook will teach you how to #{THP} 
请注意， #{THP}  是 THP 之前分配的变量的占位符。我们通常会在电子邮件分发消息中看到这些模板。你是否收到
过来自 ${first_name} ...的自动化系统发送的电子邮件而不是你的真实名字？这正是模板引擎的用途。
当上面的模板代码呈现为 HTML 时，它将如下所示：
This is the HTML Title 
The Hacker Playbook will teach you how to Hack the Planet 
幸运的是，在这种情况下，我们使用 #{}  字符串插值，这是 Pug 插值的转义版本。如你所见，通过使用模板，我们
可以创建可重用性非常高的代码并使模板非常轻量级。
Pug 支持转义和非转义字符串插值。隐藏和未转义之间的区别是什么？好吧，使用转义字符串插值将对   ， '
和 "  之类的字符进行 HTML 编码。这将有助于向用户提供输入验证。如果开发人员使用非转义字符串插值，这通常
会导致 XSS 漏洞。
此外，字符串插值（或变量插值，变量替换或变量扩展）是评估包含一个或多个占位符的字符串文字的过程，从而产
生一个结果，其中占位符替换为其对应的值。[https://en.wikipedia.org/wiki/String_interpolation]
在 Pug 隐藏和非转义字符串插值（ https://pugjs.org/language/interpolation.html ）：
!{}  - 非转义字符串插值
#{}  - 转义字符串插值 * 虽然这是转义的，但如果直接通过 JavaScript 传递它仍然可能容易受到 XSS 的攻
击
在 JavaScript 中，未转义的缓冲区代码以“!=”开头。“!=”之后的任何内容都将自动作为 JavaScript 执行。 [http
s://pugjs.org/language/code.html#unescaped-buﬀered-code]
最后，只要允许插入原始 HTML，就有可能存在 XSS。
在现实世界中，我们已经看到许多易受 XSS 攻击的案例，基于上述说明的方法，开发人员忘记了他们所处的上下文
以及输入的参数的传递位置。让我们看看我们易受攻击的聊天支持系统应用程序中的一些示例。转到虚拟机上的以下
URL： http://chat:3000/xss 。我们将逐步完成这些练习中的每一个，以了解 NodeJS/Pug XSS。
练习1：（ http://chat:3000/xss ）
在这个例子中，我们将字符串插值转义为段落标记。这是不可利用的，因为我们在 HTML 段落上下文中使用了正确
的转义字符串插值符号。
转到 http://chat:3000/xss ，然后单击练习＃1
Pug 模板源代码
p No results found for #{name1}
尝试输入并提交以下 payload ：
单击练习＃1并查看无结果输出
查看 HTML 响应（查看页面的源代码）：
点击提交后，查看页面源代码（ctrl+u）并搜索“alert”一词。你将看到我们的 payload 中的特殊字符被转换为 HTML
实体。脚本标签仍可通过我们的浏览器在我们的网站上看到，但不会呈现为 JavaScript。这种字符串插值的使用是正
确的，并且实际上没有办法通过这种情况来找到 XSS。这个工作评分会是 A+！让我们看一些糟糕的例子。
练习2
在这个例子中，我们在段落标记中用 !{}  表示非转义字符串插值。这很容易受到被精心设计的 XSS 攻击。任何基本
的 XSS payload 都会触发此操作，例如： 
打开练习2
Pug 模板源代码
p No results found for !{name2}
尝试输入 payload：
返回：
点击提交后，我们应该看到弹出窗口。你可以通过查看页面源代码并搜索“alert”进行验证。
因此，使用未提交用户输入的非转义字符串插值（ !{name2} ）会导致很多麻烦。这是一种不好的做法，不应该用于
用户提交的数据。因为我们输入的任何 JavaScript 都将在受害者的浏览器上执行。
练习3
这个例子中，我们在动态生成的行内 JavaScript 中加入了转义后的字符串。这意味着我们成功了，因为它已经隐藏
了，不是吗？由于我们所处的代码上下文，这个例子很容易受到攻击。我们将在 Pug 模板中看到，在我们的转义插
值之前，我们实际上是在一个 script 标签内。因此，任何 JavaScript 都会自动执行。更棒的是，因为我们位于 Script
标签内，所以我们不需要将   标签用作 payload 的一部分。我们可以使用直接的 JavaScript 代码，例如：
alert(1)：
打开练习3
Pug 模板源代码
script.
var user3 = #{name3};
p No results found for #{name3}
此模板将在 HTML 中进行转义，如下所示：
No results found for [escaped user input]
尝试输入 payload：
1;alert(1);
点击提交后，我们应该看到弹出窗口。你可以通过查看页面源代码并搜索“alert”进行验证。