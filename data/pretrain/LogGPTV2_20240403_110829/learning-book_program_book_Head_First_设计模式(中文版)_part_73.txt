//做更多事
新的装置被加入系统内，其所有需要用到
日历
的逻辑也都被加进了中介者内。
中介者的优点
中介者的用途和缺点
通过将对象彼此解耦，可以增加对象的复用
中介者常常被用来协调相关的GUI组件。
性。
中介者模式的缺点是，如果设计不当，中介
通过将控制逻辑集中，可以简化系统维护。
者对象本身会变得过于复杂。
可以让对象之间所传递的消息变得简单而且
大幅减少。
你现在的位置
623
---
## Page 660
备忘录模式
备忘录
当你需要让对象返回之前的状态时（例如，你的用户请求“撤
销”），就使用备忘录模式（MementoPattern）。
场景
你的交互式角色扮演游戏获得了巨大的成功，大家都很沉
迷，想要进人“第13关”。当用户进入到更高的游戏关卡
时，游戏结束的机率就会提高。对于那些花了许多日子才
进人到高级关卡的游戏迷，当他们的角色死在游戏中时，
他们简直是气炸了，他们一定会重新再来的。于是他们强
烈要求你提供“储存进度”的命令，好让玩家能够储存游
戏进度，至少不要损失得太严重。这个“储存进度”的功
小心，储存游戏状态可不是小
能需要设计成能够抛出一个复活的角色，而进度停留在上
事一桩，这其实很复杂。我可
不希望别人能访问我的代码，还在
一次过关的关卡上。
里面搞破坏。
PDG
624
附录A
---
## Page 661
剩下的模式
使用备忘录
备忘录模式有两个目标：
·储存系统关键对象的重要状态。
■维护关键对象的封装。
请不要忘记单一责任原则，不要把保持状态的工作和关
GameMemento
键对象混在一起，这样比较好。这个专门掌握状态的对
savedGameState
象，就称为备忘录。
Client
MasterGameObject
//进入新关卡时
gameState
Object saved =
(Object)mgo.getCurrentState();
//收集状态
//需要回到先前进度时
return(gameState) :
mgo.restoreState(saved) :
尽管这不是一个很炫的实
restoreState(Object saved-
现，但是请注意客户没有
//恢复状态
接触到备忘录数据。
1
！!
游戏其他的动作
备忘录的优点
备忘录的用途和缺点
将被储存的状态放在外面，不要和关键对象
备忘录用于储存状态。
混在一起，这可以帮助维护内聚。
使用备忘录的缺点：储存和恢复状态的过
保持关键对象的数据封装。
程可能相当耗时。
提供了容易实现的恢复能力。
在Java系统中，其实可以考虑使用序列化
（serialization）机制储存系统的状态。
你现在的位置
625
---
## Page 662
原型模式
原型
当创建给定类的实例的过程很昂贵或很复杂时，就使用原型模式
（PrototypePattern)。
场景
你的交互式角色扮演游戏中，怪兽有着贪得无厌的胃口。当英雄人物在动态创建
的场景中闯荡时，遇到了庞大的敌军有待歼灭。你希望怪兽的特征能够随着场景
的变换而演化。毕竞，如果让鸟一般的怪兽跟随你的角色进入海底世界，实在是
没有道理。最后，你还希望能够让高级用户创建他们自己的怪兽。
创建各式各样的慢善实例，已经越来越麻烦
了将各种状态细节放在构造器中，看起
来一点都不内辈。如累能够在单一区域内封装所
有的实例化细节，那该有多好….
如果我们能够将负责处理创建怪善的
细节代码，从实际需要动态创建实例的
O
代码中解耦，那么程际将变得相当干
邮
626
附录A
---
## Page 663
剩下的模式
原型来拯救你了
原型模式允许你通过复制现有的实例来创建新的实例（在
>
Java中，这通常意味着使用clone（）方法，或者反序列化）。
Monster
这个模式的重点在于，客户的代码在不知道要实例化何种
特定类的情况下，可以制造出新的实例。
WellKnownMonster
MonsterMaker
客户常要一个连合当前情况的
makeRandomMonster()(
新怪等。（客户不知道所得到的
Monster m =
MonsterRegistry.get-
怪等会是什么。）
Monster():
MonsterRegistry
Monster getMonster()(
//找到正确的怪兽
这个注册表（Resistry）金找到合连的
return correctMonster.clone();
怪善，然后复制一份，并返回复制的
版本
原型的优点
原型的用途和缺点
向客户隐藏制造新实例的复杂性。
在一个复杂的类层次中，当系统必须从其中
提供让客户能够产生未知类型对象的选项。
的许多类型创建新对象时，可以考虑原型。
在某些环境下，复制对象比创建新对象更有
使用原型模式的缺点：对象的复制有时相当
效。
复杂。
你现在的位置
627
---
## Page 664
访问者模式
访问者
当你想要为一个对象的组合增加新的能力，且封装并不
重要时，就使用访问者模式（VisitorPattern）。
场景
对象村餐厅和对象村煎饼屋的常客，近来变得非常重视养生之
道。在订餐之前，他们会询问营养信息。因为两个商家都非常
愿意迎合顾客的需求，有些顾客甚至详细得连每种原料的营养
成分也不放过。
菜单
//新方法
Lou提出的解决方案......
getHealthRating
getCalories
getProtein
getCarbs
菜单项
菜单项
//新方法
getHealthRat-
ing
getCalories
getProtein
getCarbs
原料
原料
Mel的考虑......
“老天，看样子我们简直是打开了潘多拉的盒子。天晓得我们接
下来要加入什么新方法，而每次一有新方法加人，就必须加到
两个地方。还有，万一我们想要加强基本系统，比方说多了食
谱类，那又该怎么办呢？我们就必须改变三个地方…"
PDG
628
附录A
---
## Page 665
剩下的模式
访问者来访
访问者必须参观组合内的每个元素；这样的功能是在导游
（Traverser）对象中，访问者通过导游的引导，收集组合中
所有对象的状态。一旦状态被收集了，客户就可以让访问
者对状态进行各种操作。当需要新的功能时，只要加强访
问者即可。
所有的这些组合类必须
做的事情，就是加入一个
访问老需要能调用每个类的setState).
setState(）方法（而不必担
而这也正是你能够加入新方法以让客
心暴露他们自己）
客户要求访问老从组合
户使用的地方。
结构中取得信息…新
菜单
方法可以被加入到访问
getstate ()
老中，而不会影响组合。
访问者
getState()
99
菜单项
菜单项
客户/
导游
导游知道如何引导访问者走访
原料
原料
组合的结构。
访问者的优点
访问者的用途和缺点
允许你对组合结构加入新的操作，而无需改
当采用访问者模式的时候，就会打破组合类
变结构本身。
的封装。
■想要加人新的操作，相对容易。
因为游走的功能牵涉其中，所以对组合结构
■访问者所进行的操作，其代码是集中在一起
的改变就更加困难。
的。
你现在的位置》
629
---
## Page 666
PDG
---
## Page 667
索引
AbstractFactoryPattern（抽象工厂模式）156.参见
CDCoverViewer（CD封面浏览器）463
FactoryPattern（工厂模式）
Chain ofResponsibilityPattern（责任链模式）
AdapterPattern（适配器模式）
616~617
优点242
change（改变）339
类适配器244
提前14
类图243
软件开发的不变真理8
结合模式504
识别53
定义243
Choc-O-Holic,Inc.（Choc-O-Holic公司）175
鸭子帖245
class explosion（类爆炸）81
枚举选代器适配器248
code magnets（代码帖）69,179,245,350
习题251
cohesion（内聚）339一340
解释241
CombiningPatterns（结合模式）500
围炉夜话247，252~253
抽象工厂模式508
介绍237
适配器模式504
对象适配器244
类图524
Alexander,Christopher 602
组合模式513
annihilatingevil（歼灭恶势力）606
装饰者模式506
Anti-Patterms（反模式）606~607
观察者模式516
黄金榔头607
CommandPatterm（命令模式）
application patterms（应用模式）604
类图207
architecturalpatterns（架构模式）604
命令对象203
定义206~207
介绍196
BridgePattern（桥接模式）612~613
加载调用者201
BuilderPattern（生成器模式）614~615
日志请求229
bullet points （要点）32,74,105,162,186,230,270，
宏命令224
311,380,423,491,560,608
空对象214
business process patterns（业务流程模式）605
队列请求228
撒销216,220,227
这是索引
631
---
## Page 668
D-F
Composite Pattern（组合成模式）
DependencyInversionPrinciple（依赖倒置原则）
与选代器模式368
139 ~143
类图358
好莱坞原则298
结合模式513
Design Patterns（设计模式）
组合行为363
抽象工厂模式156
默认行为360
适配器模式243
定义356
优点599
访谈376~377
桥接模式612-613
安全性367
生成器模式614~615
安全性vs.透明性515
类目589.592~593
透明性367，375
责任链模式616~617
composition（组合）23,85,93,247,309
类模式591
compoundpattern（复合模式）500,522
命令模式206
controlling access（控制访问）
460.参见
组合模式356
（ProxyPattern代理模式）
装饰者模式91
creatingobjects（创建对象）
134
定义579,581
crossword puzzle（填字游戏）33,76,163,187,231，
发掘自己的模式586~587
271, 310, 378, 490
外观模式264
cubicle conversation（办公室隔间对话）55,93，195，
工厂方法模式134
208,387,397, 433,583~584
绳量模式618~619
解释器模式620~621
选代器模式336
DecoratorPattern（装饰者模式）
中介者模式622~623
与代理模式472~473
备忘录模式624～625
类图91
空对象214
结合模式506
对象模式591
办公室隔间对话93
观察者模式51
定义91
组织589
缺点 101,104
原型模式626~627
围炉夜话252~253
代理模式460
访谈104
简单工厂114
介绍88
单件模式177
在JavaI/O中100~101