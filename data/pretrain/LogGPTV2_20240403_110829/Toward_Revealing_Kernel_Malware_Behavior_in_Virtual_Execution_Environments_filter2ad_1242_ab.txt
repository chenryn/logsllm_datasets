to-External) and E2I (External-to-Internal) to describe the function-level control
ﬂow transferring between malicious code and benign code. Here, internal and ex-
ternal functions refer to the malicious function code and benign function code
respectively. Function calls and returns are two types of events that Rkproﬁler
monitors. For example, I2E call indicates the event that an internal function
invokes an external function; I2E return refers to the event that an internal
function returns to its caller that is an external function. Capturing these func-
tion events is important for Rkproﬁler to reveal the activity of the malware.
Further, in an instance, the kernel malware may directly call the registry func-
tions exported by ntoskrnl.exe like zwSetKeyValue to manipulate local registry
entries. Rkproﬁler is also designed to capture the I2I (Internal-to-Internal) call
and return events. By doing so, Rkproﬁler is able to construct (partial) call
graphs of the kernel malware, which helps a security professional understand
the code structure of the malware. This capability is important, especially when
the malware is obfuscated to resist static code analysis. Note, E2E (External-
to-External) function events are not monitored here because Rkproﬁler does not
inspect benign kernel code.
To completely monitor the function-level activity of malware, a data structure
called function descriptor is deﬁned to represent a stack frame (activation record)
of a kernel call stack, allowing Rkproﬁler to track the call stacks of the kernel
malware. When a function that is called by malware is detected, Rkproﬁler
creates a new function descriptor object and pushes it to the stack. Conversely,
when the function is returned, its function descriptor object is popped from the
stack and is deleted. One function descriptor has a pointer that points to the
function descriptor of the caller. This pointer is used by Rkproﬁler to construct
the caller-callee relationships in the post-analysis phase.
The method of detecting a function call event depends on the calling direc-
tions. For I2I and I2E calls, Rkproﬁler monitors the CALL instructions executed
by the malware. Further, it can obtain the function address from the operand of
a CALL instruction and the return address that is next to the CALL instruc-
tion. For E2I calls, a CALL instruction belongs to TCZ and is not monitored by
Rkproﬁler. So, the detection point is moved to the ﬁrst instruction of the callee
function. To capture E2I calls, Rkproﬁler adds extra data members to the TB
descriptor TranslationBlock. The ﬁrst data member indicates what the last in-
struction of this TB is: CALL, JMP, RET or others. If it is a CALL instruction,
the second data member records the return address of the call. Rkproﬁler ﬁlls in
the two data members of a TB when it is being translated. In addition, Rkproﬁler
creates a global pointer that points to the last TB descriptor whose code was
just executed by the virtual CPU. Before translating a malicious TB, Rkproﬁler
312
C. Xuan, J. Copeland, and R. Beyah
queries the last TB descriptor to decide if it is an E2I call event. The decision
is based on three criteria: 1) if the last TB is benign; 2) if the last instruction
of the last TB is CALL; and 3) if the return address stored in the kernel stack
is equal to the one stored in the last TB descriptor. The reason for criterion 3
is that the return address is always constant for both direct and indirect calls.
On the other hand, Rkproﬁler processes the function return events in a similar
way to the call events: for I2I and E2I returns, Rkproﬁler captures these events
by directly monitoring the RET instructions executed by the malware; for I2E
returns, Rkproﬁler detects them at the instructions directly following the RET
instructions and the criteria of the decision are similar to that for the E2I calls.
Two problems complicate the call event detection methods described above.
The ﬁrst one is a pseudo function call, which is caused by JMP instructions.
When a kernel module attempts to invoke one function exported by another
kernel module, it ﬁrst executes the CALL instruction to invoke an internal stub
function and the stub function then jumps to the external function by running
the JMP instruction. Normally, the internal stub function is automatically gen-
erated by a compiler and the operand of the JMP function is an IAT entry of this
module, whose value is determined and inserted by the system loader. Without
recognition of these JMP instructions, Rkproﬁler incorrectly treats an I2E call as
an I2I call: labeling the new function descriptor with the internal stub function
address. One example of such functions is DbgPrint. To address a pseudo func-
tion call, Rkproﬁler ﬁrst creates an I2I function descriptor and labels it with the
internal stub function address. When detecting if an internal JMP instruction
is executed in order to jump to an external address, Rkproﬁler locates the I2I
function descriptor from the top of the function tracking stack, and replaces the
internal address with the external address. The second problem is an interrupt
gap. This is where an interrupt is sent to the (virtual) CPU while it is executing
an E2I CALL (or I2E RET) instruction. Consequently, some interrupt handling
instructions are executed between the E2I CALL (or I2E RET) instruction and
the subsequent internal instruction that Rkproﬁler monitors. In this situation,
the last TB descriptor does not record the expected CALL (or RET) instruction,
so Rkproﬁler is unable to track the E2I call (or I2E return) event and observes
an unpaired return-call event. The solution to this problem is part of our future
work. Fortunately, we did not see interrupt gaps in the experiments.
4.3 Memory Access Tracking
Rkproﬁler observes the hardware-level activity of kernel malware, however it
should be translated to software-level activity to be understandable to users.
Thus, given a virtual address that the malware visits, Rkproﬁler is required to
ﬁnd its symbols (e.g., variable name and type). In this paper, we name the pro-
cess of ﬁnding symbols for kernel objects as memory tagging. A memory tag
is composed of tag id, virtual address, type ID, variable name (optional) and
parent tag id (optional). If a kernel object is owned by the malware, it is an in-
ternal kernel object; otherwise, it is an external kernel object. If a kernel object
is located in the dynamic memory area (stack and heap), it is a dynamic kernel
Toward Revealing Kernel Malware Behavior
313
object; otherwise, it is a static kernel object. Rkproﬁler tags four types of kernel
objects: static internal, dynamic internal, static external and dynamic external.
Static external kernel objects include global variables and Windows kernel func-
tions. Their symbols are stored in a system map. Tagging a static kernel object
is straightforward. Rkproﬁler searches the system map by its virtual address and
the hit entry contains the target symbols. However, tagging a dynamic kernel
object is challenging because its memory is dynamically allocated at run time
and the memory address cannot be predicted. Attackers often strip oﬀ the sym-
bols of their malware in order to delay reverse engineering, so Rkproﬁler assumes
that malware samples do not contain valid symbols.
Previous Linux rootkit detection systems [19] [4] present one approach of
tracking dynamic kernel objects. A rootkit detector ﬁrst generates a kernel type
graph and identiﬁes a group of global kernel variables. At run time, it periodi-
cally retrieves the dynamic objects from the global variables based on the graph
type. For example, if a global variable is a linked list head, the detector traverses
the list under the direction of the data structure type of list elements. Unfortu-
nately, this approach cannot be applied to the task of proﬁling kernel malware.
First, it covers a limited number of kernel objects, and many other kernel objects
such as functions and local variables are not included. Second, since the creation
and deletion of dynamic kernel objects could occur at any time, the time gap
between every two searches in this approach will produce inaccurate monitoring
results. Last, this approach may track many kernel objects that the malware
never visits. In this paper, we propose a new symbol exploration approach, Ag-
gressive Memory Tagging (AMT), that can precisely ﬁnd symbols for all kinds
of static and dynamic kernel objects at a low computation cost.
AMT Description. We deﬁne a kernel object as contagious if another kernel
object can be derived from it. Tag inferring is a process where a kernel object
(child object) is derived from another (parent object). Two types of kernel ob-
jects are considered contagious: pointers and functions. A pointer kernel object
could be a pointer variable or a structure variable containing a pointer mem-
ber. The child object of a pointer is the pointee object. For a function, its child
objects are the parameters and return value of this function. AMT follows the
principle of the object tracking approach described above: tracing the dynamic
objects from the static objects. Speciﬁcally, Rkproﬁler ﬁrst tags all static kernel
objects that the malware accesses (memory reads/writes and function calls) by
querying the system map. Then, the child objects of the existing contagious tags
are tagged via tag inferring. This process is repeated until the malware stops
execution or the user terminates monitoring. Note, a tag could become invalid
in two scenarios: 1) if when a function returns, the tags of its local variables are
invalidated; and 2) if a memory buﬀer is released, the associated tag becomes
out of date as well. Only valid tags can generate valid child tags.
Rkproﬁler performs tag inferring through a pointer object at the time that
the malware reads or writes the pointer object. The reason is as follows: when
reading a pointer, the malware is likely to visit the pointee object through the
pointer; when writing a pointer, the malware will possibly modify the pointer to
314
C. Xuan, J. Copeland, and R. Beyah
point to another object if the new value is a valid memory address. Because the
executions of benign kernel code are not monitored by Rkproﬁler, both read and
write operations over a pointer have to be tracked here. If only read operations
are monitored, Rkproﬁler cannot identify the kernel objects whose pointers are
written by malicious code and read by benign code. Many hooks implanted by
rootkits fall into this scenario. Similarly, if only write operations are monitored,
Rkproﬁler can miss the reorganization of kernel objects whose pointers are writ-
ten by benign code and read by malicious code. Many external kernel objects
that are visited by rootkits fall into this scenario. The procedure of tag inferring
through a pointer object is as follows: 1) Rkproﬁler detects a memory read or
write operation and searches the tag queue to check if the target memory corre-
sponds to a contagious tag; 2) if yes, Rkproﬁler obtains the up-to-date pointer
value and veriﬁes that it is a valid memory address; 3) Rkproﬁler searches the
tag queue to check if the pointee object is tagged; 4) if not, Rkproﬁler obtains
the symbols of the pointee object from the type graph and creates a new tag.
On the other hand, when a recognizable function is called, tag inferring through
the function object is carried out by identifying the function parameters. Input
parameters are tagged when the function is called; output parameters are tagged
when the function returns.
Implementation. Rkproﬁler creates a data structure called tag descriptor to
represent memory tags. A tag descriptor includes the virtual address of the tag,
type ID, a boolean variable, a num variable for memory type, one pointer to
the parent tag and one pointer to the function descriptor. The Boolean variable
indicates if a tag is contagious or not. The memory type member tells if the
tagged object is on the stack, heap or another memory object. Rkproﬁler moni-
tors the kernel memory management functions called by malware and records it
to a heap list (the memory buﬀers allocated to the malware). When a buﬀer is
released, Rkproﬁler removes it from the heap list. The function descriptor mem-
ber of a tag helps identify which function is running when this tag is generated.
Finally, Rkproﬁler maintains a tag queue that contains all the tags that have
been created. When a tag is created, its tag descriptor is inserted into the tag
queue. The tag is removed from the tag queue after it becomes invalid. Because
malware’s memory accesses are frequent events, Rkproﬁler needs to search the
tag queue frequently as well. The tag queue describes a group of various-sized
memory segments. If it is organized as a list structure like a linked list, its linear
searching time is expensive. To address the problem, Rkproﬁler applies the ap-
proach presented in [29] that converts a group of various-sized memory segments
to a hash table. The basic idea is to break a memory segment into a number of
ﬁx-sized memory segments (buckets). A list structure is stored in one bucket to
handle the case that some portions of the bucket should not be counted. In this
way, the time for searching the tag queue becomes constant.
The Windows kernel provides built-in supports for linked lists via two data
structures: SINGLE_LIST_ENTRY (for single linked list) and LIST_ENTRY (for dou-
ble linked list). Several kernel APIs are available to simplify driver developers’
tasks when managing linked lists (e.g., adding or removing elements). However,
Toward Revealing Kernel Malware Behavior
315
this support causes problems to the memory tagging process of Rkproﬁler. For
example, in a double linked list, each element contains a data member whose data
type is LIST_ENTRY. Two pointers of this data member point to the LIST_ENTRY
data members of two neighbor elements. When one list element is tagged and mal-
ware tries to visit the next list element from this one, Rkproﬁler just tags the
LIST_ENTRY data member of the next list element with the type LIST_ENTRY. This
is not acceptable because what Rkproﬁler wants to tag is the next list element
with its type. In the pre-analysis stage, we annotated the SINGLE_LIST_ENTRYand
LIST_ENTRY data members with the type names of list elements and their oﬀsets.
When parsing the type header ﬁle, the generator replaces the SINGLE_LIST_ENTRY
and LIST_ENTRY data members with pointers to list elements. The oﬀset values
are also stored in the type graph, allowing the monitor to ﬁnd the actual addresses
of neighbor elements. Another problem is relative pointers. The Windows kernel
sometimes uses relative pointers to traverse a list in the following way: the ad-
dress of the next element is computed by adding the relative pointer and the ad-
dress of the current element. One example is the data buﬀer that contains the disk
ﬁle query result by kernel function NtQueryDirectoryFile. Because these relative
pointers are deﬁned as unsigned integer, we also need to label the relative pointers
in the kernel type header ﬁle such that Rkproﬁler can recognize them and properly
compute the element addresses.
Rkproﬁler has to handle two ambiguous data types that the Windows kernel
source uses. The ﬁrst one is union. Union is a data type that contains only one of
several alternative members at any given time, and the memory storage required
for a union is decided by its largest data member. Unfortunately, guessing which
data member of a union should be used at a given time depends on code context,
which is hard to automate in Rkproﬁler. The second one is generic pointer pvoid.
Pvoid can be caste to another data type by developers. The actual data type
that pvoid points to at a given time is context dependent too. Automatically
predicting the pointee data type for pvoid is another challenge. The current
default solution is to replace a union with one of its largest members and leave
pvoid alone. While performing the analysis, a user can modify the kernel data
type header ﬁle and change the deﬁnition of union or pvoid in terms of his
understanding of their running contexts. An automated solution to this problem
is part of our future work.
4.4 Hardware Access Monitoring
In comparison to user-space malware, kernel malware is able to bypass the me-
diation of the OS and directly access low-level hardware resources. In X86 ar-
chitectures, in addition to the memory and general-purpose registers that kernel
malware access through instructions like MOV and LEA, other types of system
storage resources could also be visited and manipulated by kernel malware. CPU
caches (e.g., TLB) dedicate registers and buﬀers of I/O controllers. Attackers
have developed techniques that take advantage of these hardware resources to
devise new attacks. For example, upon a system service (system call) invoca-
tion made by a user-space process, Windows XP uses instruction SYSENTER
316
C. Xuan, J. Copeland, and R. Beyah
(for Intel processor) to perform the fast transition from user space to kernel
space. The entry point of kernel code (a stub function) is stored in a dedicated
register called IA32_SYSENTER_EIP, which is one of Model-Speciﬁc Registers
(MSRs). When executing SYSENTER, the CPU sets the EIP register with the
value of IA32_SYSENTER_EIP. Then, the kernel stub function is called and it
transfers the control to the target system service. To compromise Windows sys-
tem services, a rootkit could alter the system control-ﬂow path by resetting the
IA32_SYSENTER_EIP to the starting address of a malicious stub function, and
this function can invoke a malicious system service. So, capturing the malware’s
accesses to these sensitive hardware resources could be essential to comprehend
its attacking behavior. Currently, Rkproﬁler monitors twenty system instruc-
tions that malware might execute. They are not meant to be complete at this
point and can be expanded in the future if necessary.
5 Case Studies
5.1 FUTo
FUTo is an enhanced version of the Windows kernel rootkit FU, which uses the
technique called Direct Kernel Object Manipulation (DKOM) to hide processes
and drivers and change the process privileges. DKOM allows rootkits to directly
manipulate kernel objects, avoiding the use of kernel hooks to intercept events
that access these kernel objects. For example, a rootkit can delete an item from
the MODULE_ENTRY list to hide a device driver without aﬀecting the execution of
the system. This technique has been applied to many rootkit attacks, such as
hiding processes, drivers and communication ports, elevating privilege levels of
threads or processes and skewing forensics [12]. In this experiment, FUTo was
downloaded from [21] and it included one driver (msdirectx.sys) and one exe-
cutable (fu.exe). The fu.exe was a command-line application that installed the
driver and sent commands to the driver according to the user’s instructions. Dur-
ing the test, we executed the fu.exe to accomplish the following tasks: querying
the command options, hiding the driver (msdirect.sys) and hiding the process
(cmd.exe). After that, we used Windows native system utilities (task manager
and driverquery) to verify that the target driver and process did not show up in
their reports. The test took less than 3 minutes.
We compared the call graph created by Rkproﬁler with the call graph created
by IDA-Pro (which uses the static code analysis technique). It was found that
the former was the sub-graph of the latter, which is as expected. The tag trace
graph of this test is shown in Table 1. The driver msdirectx was executed in
four process contexts in the graph. Process 4 (System) is the Windows native
process that was responsible for loading the driver misdirectx. The driver initial-
ization routine (with tag_id 0) was executed in this process context. The other
three processes were associated with FUTo.exe and they communicated with
the misdirectx driver to perform the tasks of hiding the driver and process. One
important observation is that the major attacking activities have been recorded
by Rkproﬁler and can be easily identiﬁed in the tag trace table by users. To
Toward Revealing Kernel Malware Behavior
317
Table 1. FUTO tag trace table
Tag ID Address
Type
Parent Category Size(bytes) Process ID Process Name
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31