# 【系列分享】ARM 汇编基础速成4：ARM汇编内存访问相关指令
|
##### 译文声明
本文是翻译文章，文章来源：azeria-labs.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
译者：[arnow117](http://bobao.360.cn/member/contribute?uid=941579989)
预估稿费：200RMB
投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿
传送门
[【系列分享】ARM
汇编基础速成1：ARM汇编以及汇编语言基础介绍](http://bobao.360.cn/learning/detail/4070.html)
**[【系列分享】ARM
汇编基础速成2：ARM汇编中的数据类型](http://bobao.360.cn/learning/detail/4075.html)**
[**【系列分享】ARM
汇编基础速成3：ARM模式与THUMB模式**](http://bobao.360.cn/learning/detail/4082.html)
ARM使用加载-存储模式控制对内存的访问，这意味着只有加载/存储(LDR或者STR)才能访问内存。尽管X86中允许很多指令直接操作在内存中的数据，但ARM中依然要求在操作数据前，必须先从内存中将数据取出来。这就意味着如果要增加一个32位的在内存中的值，需要做三种类型的操作(加载，加一，存储)将数据从内存中取到寄存器，对寄存器中的值加一，再将结果放回到内存中。
为了解释ARM架构中的加载和存储机制，我们准备了一个基础的例子以及附加在这个基础例子上的三种不同的对内存地址的便宜访问形式。每个例子除了STR/LDR的偏移模式不同外，其余的都一样。而且这个例子很简单，最佳的实践方式是用GDB去调试这段汇编代码。
第一种偏移形式：立即数作为偏移
地址模式：用作偏移
地址模式：前向索引
地址模式：后向索引
第二种偏移形式：寄存器作为偏移
地址模式：用作偏移
地址模式：前向索引
地址模式：后向索引
第三种偏移形式：寄存器缩放值作为偏移
地址模式：用作偏移
地址模式：前向索引
地址模式：后向索引
**基础样例代码**
通常，LDR被用来从内存中加载数据到寄存器，STR被用作将寄存器的值存放到内存中。
    LDR R2, [R0]   @ [R0] - 数据源地址来自于R0指向的内存地址
    @ LDR操作：从R0指向的地址中取值放到R2中
    STR R2, [R1]   @ [R1] - 目的地址来自于R1在内存中指向的地址
    @ STR操作：将R2中的值放到R1指向的地址中
样例程序的汇编代码及解释如下：
    .data          /* 数据段是在内存中动态创建的，所以它的在内存中的地址不可预测*/
    var1: .word 3  /* 内存中的第一个变量 */
    var2: .word 4  /* 内存中的第二个变量 */
    .text          /* 代码段开始 */ 
    .global _start
    _start:
        ldr r0, adr_var1  @ 将存放var1值的地址adr_var1加载到寄存器R0中 
        ldr r1, adr_var2  @ 将存放var2值的地址adr_var2加载到寄存器R1中 
        ldr r2, [r0]      @ 将R0所指向地址中存放的0x3加载到寄存器R2中  
        str r2, [r1]      @ 将R2中的值0x3存放到R1做指向的地址 
        bkpt             
    adr_var1: .word var1  /* var1的地址助记符 */
    adr_var2: .word var2  /* var2的地址助记符 */
在底部我们有我们的文字标识池(在代码段中用来存储常量，字符串，或者偏移等的内存，可以通过位置无关的方式引用)，分别用adr_var1和adr_var2存储着变量var1和var2的内存地址(var1和var2的值在数据段定义)。第一条LDR指令将变量var1的地址加载到寄存器R0。第二条LDR指令同样将var2的地址加载到寄存器R1。之后我们将存储在R0指向的内存地址中的值加载到R2，最后将R2中的值存储到R1指向的内存地址中。
当我们加载数据到寄存器时，方括号“[]”意味着：将其中的值当做内存地址，并取这个内存地址中的值加载到对应寄存器。
当我们存储数据到内存时，方括号“[]”意味着：将其中的值当做内存地址，并向这个内存地址所指向的位置存入对应的值。
听者好像有些抽象，所以再来看看这个动画吧：
同样的再来看看的这段代码在调试器中的样子。
    gef> disassemble _start
    Dump of assembler code for function _start:
     0x00008074 :      ldr  r0, [pc, #12]   ; 0x8088 
     0x00008078 :      ldr  r1, [pc, #12]   ; 0x808c 
     0x0000807c :      ldr  r2, [r0]
     0x00008080 :     str  r2, [r1]
     0x00008084 :     bx   lr
    End of assembler dump.
可以看到此时的反汇编代码和我们编写的汇编代码有出入了。前两个LDR操作的源寄存器被改成了[pc,#12]。这种操作叫做PC相对地址。因为我们在汇编代码中使用的只是数据的标签，所以在编译时候编译器帮我们计算出来了与我们想访问的文字标识池的相对便宜，即PC+12。你也可以看汇编代码中手动计算验证这个偏移是正确的，以adr_var1为例，执行到8074时，其当前有效PC与数据段还有三个四字节的距离，所以要加12。关于PC相对取址我们接下来还会接着介绍。
PS：如果你对这里的PC的地址有疑问，可以看外面第二篇关于程序执行时PC的值的说明，PC是指向当前执行指令之后第二条指令所在位置的，在32位ARM模式下是当前执行位置加偏移值8，在Thumb模式下是加偏移值4。这也是与X86架构PC的区别之所在。
**第一种偏移形式：立即数作偏移**
    STR    Ra, [Rb, imm]
    LDR    Ra, [Rc, imm]
在这段汇编代码中，我们使用立即数作为偏移量。这个立即数被用来与一个寄存器中存放的地址做加减操作(下面例子中的R1)，以访问对应地址偏移处的数据。
    .data
    var1: .word 3
    var2: .word 4
    .text
    .global _start
    _start:
        ldr r0, adr_var1  @ 将存放var1值的地址adr_var1加载到寄存器R0中 
        ldr r1, adr_var2  @ 将存放var2值的地址adr_var2加载到寄存器R1中 
        ldr r2, [r0]      @ 将R0所指向地址中存放的0x3加载到寄存器R2中  
        str r2, [r1, #2]  @ 取址模式：基于偏移量。R2寄存器中的值0x3被存放到R1寄存器的值加2所指向地址处。
        str r2, [r1, #4]! @ 取址模式：基于索引前置修改。R2寄存器中的值0x3被存放到R1寄存器的值加4所指向地址处，之后R1寄存器中存储的值加4,也就是R1=R1+4。
        ldr r3, [r1], #4  @ 取址模式：基于索引后置修改。R3寄存器中的值是从R1寄存器的值所指向的地址中加载的，加载之后R1寄存器中存储的值加4,也就是R1=R1+4。
        bkpt
    adr_var1: .word var1
    adr_var2: .word var2
让我们把上面的这段汇编代码编译一下，并用GDB调试起来看看真实情况。
    $ as ldr.s -o ldr.o
    $ ld ldr.o -o ldr
    $ gdb ldr
在GDB(使用GEF插件)中，我们对_start下一个断点并继续运行程序。
    gef> break _start
    gef> run
    ...
    gef> nexti 3     /* 向后执行三条指令 */
执行完上述GDB指令后，在我的系统的寄存器的值现在是这个样子(在你的系统里面可能不同)：
    $r0 : 0x00010098 -> 0x00000003
    $r1 : 0x0001009c -> 0x00000004
    $r2 : 0x00000003
    $r3 : 0x00000000
    $r4 : 0x00000000
    $r5 : 0x00000000
    $r6 : 0x00000000
    $r7 : 0x00000000
    $r8 : 0x00000000
    $r9 : 0x00000000
    $r10 : 0x00000000
    $r11 : 0x00000000
    $r12 : 0x00000000
    $sp : 0xbefff7e0 -> 0x00000001
    $lr : 0x00000000
    $pc : 0x00010080 ->  str r2, [r1]
    $cpsr : 0x00000010
下面来分别调试这三条关键指令。首先执行基于地址偏移的取址模式的STR操作了。就会将R2(0x00000003)中的值存放到R1(0x0001009c)所指向地址偏移2的位置0x1009e。下面一段是执行完对应STR操作后对应内存位置的值。
    gef> nexti
    gef> x/w 0x1009e 
    0x1009e : 0x3
下一条STR操作使用了基于索引前置修改的取址模式。这种模式的识别特征是(!)。区别是在R2中的值被存放到对应地址后，R1的值也会被更新。这意味着，当我们将R2中的值0x3存储到R1(0x1009c)的偏移4之后的地址0x100A0后，R1的值也会被更新到为这个地址。下面一段是执行完对应STR操作后对应内存位置以及寄存器的值。
    gef> nexti
    gef> x/w 0x100A0
    0x100a0: 0x3
    gef> info register r1
    r1     0x100a0     65696
最后一个LDR操作使用了基于索引后置的取址模式。这意味着基础寄存器R1被用作加载的内存地址，之后R1的值被更新为R1+4。换句话说，加载的是R1所指向的地址而不是R1+4所指向的地址，也就是0x100A0中的值被加载到R3寄存器，然后R1寄存器的值被更新为0x100A0+0x4也就是0x100A4。下面一段是执行完对应LDR操作后对应内存位置以及寄存器的值。
    gef> info register r1
    r1      0x100a4   65700
    gef> info register r3
    r3      0x3       3
下图是这个操作发生的动态示意图。
**第二种偏移形式：寄存器作偏移**
    STR    Ra, [Rb, Rc]
    LDR    Ra, [Rb, Rc]
在这个偏移模式中，寄存器的值被用作偏移。下面的样例代码展示了当试着访问数组的时候是如何计算索引值的。
    .data
    var1: .word 3
    var2: .word 4
    .text
    .global _start
    _start:
        ldr r0, adr_var1  @ 将存放var1值的地址adr_var1加载到寄存器R0中 
        ldr r1, adr_var2  @ 将存放var2值的地址adr_var2加载到寄存器R1中 
        ldr r2, [r0]      @ 将R0所指向地址中存放的0x3加载到寄存器R2中  
        str r2, [r1, r2]  @ 取址模式：基于偏移量。R2寄存器中的值0x3被存放到R1寄存器的值加R2寄存器的值所指向地址处。R1寄存器不会被修改。 
        str r2, [r1, r2]! @ 取址模式：基于索引前置修改。R2寄存器中的值0x3被存放到R1寄存器的值加R2寄存器的值所指向地址处，之后R1寄存器中的值被更新,也就是R1=R1+R2。
        ldr r3, [r1], r2  @ 取址模式：基于索引后置修改。R3寄存器中的值是从R1寄存器的值所指向的地址中加载的，加载之后R1寄存器中的值被更新也就是R1=R1+R2。