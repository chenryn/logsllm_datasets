以购物车为例，一种合理的合并值的方法就是做并集。在 [图 5-14](../img/fig5-14.png) 中，最后的两个兄弟是 [牛奶，面粉，鸡蛋，培根] 和 [鸡蛋，牛奶，火腿]。注意牛奶和鸡蛋虽然同时出现在两个并发值里，但他们每个只被写过一次。合并的值可以是 [牛奶，面粉，鸡蛋，培根，火腿]，不再有重复了。
然而，如果你想让人们也可以从他们的购物车中 **移除** 东西，而不是仅仅新增东西，那么把并发值做并集可能不会产生正确的结果：如果你合并了两个客户端的购物车，并且只在其中一个客户端里面移除了一个专案，那么被移除的专案将会重新出现在这两个客户端的交集结果中【37】。为了防止这个问题，要移除一个专案时不能简单地直接从资料库中删除；相反，系统必须留下一个具有适当版本号的标记，以在兄弟合并时表明该专案已被移除。这种删除标记被称为 **墓碑（tombstone）**（我们上一次看到墓碑是在 “[杂凑索引”](ch3.md#杂凑索引) 章节的日志压缩部分）。
因为在应用程式程式码中做兄弟合并是复杂且容易出错的，所以有一些资料结构被设计出来用于自动执行这种合并，比如在 “[自动冲突解决](#自动冲突解决)” 中讨论过的那些。举例来说，Riak 的资料型别就支援使用称为 CRDT 【38,39,55】的能以合理方式自动进行兄弟合并的资料结构家族，包括对保留删除的支援。
#### 版本向量
[图 5-13](../img/fig5-13.png) 中的示例只使用了一个副本。当有多个副本但又没有主库时，演算法该如何修改？
[图 5-13](../img/fig5-13.png) 使用单个版本号来捕获操作之间的依赖关系，但是当多个副本并发接受写入时，这是不够的。相反，除了对每个键，我们还需要对 **每个副本** 使用版本号。每个副本在处理写入时增加自己的版本号，并且跟踪从其他副本中看到的版本号。这个资讯指出了要覆盖哪些并发值，以及要保留哪些并发值或兄弟值。
所有副本的版本号集合称为 **版本向量（version vector）**【56】。这个想法的一些变体正在被使用，但最有趣的可能是在 Riak 2.0 【58,59】中使用的 **虚线版本向量（dotted version vector）**【57】。我们不会深入细节，但是它的工作方式与我们在购物车示例中看到的非常相似。
与 [图 5-13](../img/fig5-13.png) 中的版本号一样，当读取值时，版本向量会从资料库副本传送到客户端，并且随后写入值时需要将其传送回资料库。（Riak 将版本向量编码为一个字串，并称其为 **因果上下文**，即 causal context）。版本向量允许资料库区分覆盖写入和并发写入。
另外，就像在单个副本中的情况一样，应用程式可能需要合并并发值。版本向量结构能够确保从一个副本读取并随后写回到另一个副本是安全的。这样做虽然可能会在其他副本上面建立资料，但只要能正确合并就不会丢失资料。
> #### 版本向量和向量时钟
>
> 版本向量有时也被称为向量时钟，即使它们不完全相同。其中的差别很微妙 —— 细节请参阅参考资料【57,60,61】。简而言之，在比较副本的状态时，版本向量才是正确的资料结构。
## 本章小结
在本章中，我们考察了复制的问题。复制可以用于几个目的：
* 高可用性
  即使在一台机器（或多台机器，或整个资料中心）停机的情况下也能保持系统正常执行
* 断开连线的操作
  允许应用程式在网路中断时继续工作
* 延迟
  将资料放置在地理上距离使用者较近的地方，以便使用者能够更快地与其互动
* 可伸缩性
  透过在副本上读，能够处理比单机更大的读取量
尽管是一个简单的目标 - 在几台机器上保留相同资料的副本，但复制却是一个非常棘手的问题。它需要仔细考虑并发和所有可能出错的事情，并处理这些故障的后果。至少，我们需要处理不可用的节点和网路中断（这还不包括更隐蔽的故障，例如由于软体错误导致的静默资料损坏）。
我们讨论了复制的三种主要方法：
* 单主复制
  客户端将所有写入操作传送到单个节点（主库），该节点将资料更改事件流传送到其他副本（从库）。读取可以在任何副本上执行，但从库的读取结果可能是陈旧的。
* 多主复制
  客户端将每个写入传送到几个主库节点之一，其中任何一个主库都可以接受写入。主库将资料更改事件流传送给彼此以及任何从库节点。
* 无主复制
  客户端将每个写入传送到几个节点，并从多个节点并行读取，以检测和纠正具有陈旧资料的节点。
每种方法都有优点和缺点。单主复制是非常流行的，因为它很容易理解，不需要担心冲突解决。在出现故障节点、网路中断和延迟峰值的情况下，多主复制和无主复制可以更加健壮，其代价是难以推理并且仅提供非常弱的一致性保证。
复制可以是同步的，也可以是非同步的，这在发生故障时对系统行为有深远的影响。尽管在系统执行平稳时非同步复制速度很快，但是要弄清楚在复制延迟增加和伺服器故障时会发生什么，这一点很重要。如果主库失败后你将一个非同步更新的从库提升为新的主库，那么最近提交的资料可能会丢失。
我们研究了一些可能由复制延迟引起的奇怪效应，我们也讨论了一些有助于决定应用程式在复制延迟时的行为的一致性模型：
* 写后读一致性
  使用者应该总是能看到自己提交的资料。
* 单调读
  使用者在看到某个时间点的资料后，他们不应该再看到该资料在更早时间点的情况。
* 一致字首读