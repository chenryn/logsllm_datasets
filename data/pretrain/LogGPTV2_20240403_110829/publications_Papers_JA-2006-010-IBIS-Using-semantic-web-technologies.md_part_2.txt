### Database Table Creation and Schema Changes

Database tables that store the data are created manually. If changes occur in the database schema, the mappings must be manually updated. The primary advantage of this approach is that, in most cases, if the database changes (whether externally or internally developed), the ontology remains unchanged. This implies that client applications do not need to be modified.

### Architecture

The architecture of our middleware is composed of three layers: the data source layer, the domain layer, and the presentation layer, as depicted in Figure 3. In the following sections, we will describe each of these layers in detail.

#### Data Source Layer

This layer is responsible for communication with relational databases (RDBMS). Our solution utilizes Hibernate [HIB], which aims to reduce the developer's workload by automating 95% of common data persistence tasks. Hibernate eliminates the need for manual, hand-crafted data processing using SQL and JDBC, thereby increasing developer productivity and allowing them to focus more on business logic. Hibernate is an open-source product developed in Java and is interoperable with any JDBC-compliant database. It supports over 20 popular SQL dialects, including Oracle, DB2, Sybase, MS SQL Server, PostgreSQL, MySQL, HSQLDB, Mckoi SQL, SAP DB, Interbase, PointBase, Progress, FrontBase, Ingres, Informix, and Firebird [J06].

As shown in Figure 3, the data source layer contains a set of classes that provide an interface (access point) to the database objects. This layer is responsible for executing SQL statements to retrieve data from the database.

#### Domain Layer

The domain layer contains the domain model described in OWL. This includes domain concepts, their relationships, and associated rules. The ontology is queried using SPARQL [PS06], a W3C standard query language for ontologies. The domain layer also contains mappings to the data sources, which are stored in instances of the ontology, as illustrated in Figure 3. This will be described in more detail in the "Querying the Middleware" section.

The domain layer receives SPARQL requests and executes queries to extract mapping data from the ontology instances. A "query generator module" then generates the necessary SQL statements to retrieve data from the data source layer using the information stored in the ontology and its instances. The retrieved data is then transformed into XML format, which will be further detailed in the subsequent sections.

#### Presentation Layer

The presentation layer receives XML request messages from clients and provides responses in XML. Web Services are used to encapsulate the responses in SOAP [W3CSP]. This layer is also responsible for transforming the data to be returned to clients according to a specific XML format using XSLT style sheets [W3CXS]. As shown in Figure 3, this layer sends SPARQL statements to the domain layer. The SPARQL expression is generated by transforming the client request, which is described in detail in the "Query Language" section.

### Ontology to Represent Domain and Instances to Store Mappings

In this section, we discuss the ontology that resides in the domain layer. First, we describe important domain classes and their respective attributes. Examples are illustrated in Figure 4. All attributes are defined as string types because the instances of the created classes will contain mappings to the data sources. Each ontology instance will include the name of the database table that stores the data, as will be described in more detail in the next section. Ontology relations describe the relationships between domain concepts. For example, the domain class `Person` is connected to `Address` through the property `hasAddress`, as depicted in Figure 5. The ontology also includes rules. For example, we can use the ontology to describe the relationship between the `Address` and `Person` classes using a cardinality restriction: one person must have at least one address.

#### Mappings to Data Source Layer

After creating the ontology (or reusing an existing one), instances containing mappings to the data sources should be created. These mappings store information to allow the construction of SQL statements that will be executed in the data source layer to retrieve the desired information.

To generate the correct SQL statement, two types of mappings are required:
1. **Domain classes and attributes to database tables and fields.**
2. **Domain relations to database relations.**

Several scenarios may exist when mapping domain classes to database tables:
- One class in the ontology may map to only one database table.
- One class in the ontology may map to two or more database tables.
- One database table may provide data to two or more domain classes.

In all cases, the name of the instance should match the name of the object in the data source layer that allows access to the table in the database. Fields belonging to the table are mapped starting with `field=???;` (where `???` represents variable text). Fields that do not belong to the instance should be mapped using the following nomenclature: `table=???;field=???;path={???}`:
- `table` represents the name of the table containing the specified field.
- `field` represents the name of the field stored in the table.
- `path` represents the path to reach the table. The content of `path` is `field=???;table=???;field=???...field=???;table=???;field=???;`. It should always start and end with `field`, and at least one `field` attribute is required.

For example, in a domain class to database table mapping (illustrated in Figure 6), the name of the instance of the class `Person` should match the respective object in the data source layer (e.g., `TabPerson`). Attributes of the created instances should contain the name of the field in the specified table, as shown in Figure 6 by `birthDate`.

While the domain model (described in OWL) uses relations to connect domain concepts, the database uses relations to connect tables. To map ontology relations to database relations, we annotate the ontology relations. The content of the annotation property, named `relationAttribute`, should follow the format `field=???table=???field=???...field=???table=????field=???`. It should start and end with `field=`, and the number of `tables=` depends on the number of intermediary tables that exist.

For example, in Figure 7, the domain classes `Person` and `Address` are shown. These two ontology classes are mapped to the tables `TablPerson` and `TablAddress` (depicted in Figure 8), respectively. As illustrated in Figure 8, an intermediary table named `TablPersonAddress` exists. Therefore, we need to store information about this table to generate the SQL to obtain the data. In this case, the property `hasAddress` should be annotated with the following content in the `relationField`: `field=IdPerson;table=TablPersonAddress;field=IdAddress;`. The `IdPerson` field connects `TablPerson` to `TablPersonAddress`, and the `IdAddress` field connects `TablPersonAddress` to `TablAddress`.

### Querying the Middleware

As depicted in Figure 3, our middleware is accessible through Web Services, and the message content of the request and response is structured in XML and encapsulated in a SOAP envelope. Users interact with our system by making requests (which specify the needed data) using a XML structure named CQL (Client Query Language) defined by the XSD schema illustrated in Figure 9. CQL allows users to specify:
- **Fields (ontology attributes) to be returned** using the `outputFields` element.
- **The order of the output fields (ascending, descending)** using the `orderFields` element.
- **Filters** (e.g., return only names starting with the letter A) using the `filters` element.
- **The path that connects domain classes** using the `outputProperties` element.

These XML elements are described in more detail in the XSD schema in Figure 10.

For example, to obtain the birth date and name of a person, the user should make the following request:

```xml
<request>
  <outputFields>
    <field>birthDate</field>
    <field>usualName</field>
  </outputFields>
  <orderFields>
    <field>usualName</field>
    <order>ascending</order>
  </orderFields>
</request>
```

This request is processed by the middleware, which automatically generates the necessary SQL statement to retrieve the data. The required data to build the SQL statement is obtained by executing a SPARQL query (generated by transforming the XML request from the user) on the ontology. The result of the SPARQL query will contain the table name, attribute, and relations between tables.

The response to this request will be the `birthDate` and `usualName` of all persons stored in the database, formatted in XML and sorted by `usualName`. As we will illustrate in the following section, the response is a hierarchical XML structure that describes the ontology.

### Example

Suppose we want to get the names of all our students and their addresses. The first step is to locate the relevant concepts in the ontology. Next, we need to formulate the request. By invoking the service, we will receive the data, structured in XML according to the ontology.

#### Ontology

In Figure 11, we illustrate the ontology classes `Person` and `Address` belonging to the personal data ontology. Some of the fields associated with each class are also shown.

#### Database Schema

Next, we illustrate an extract from the personal data database schema. In the example, we will focus on the `TablPerson`, `TablPersonAddress`, and `TablAddress` tables, as shown in Figure 12.

#### Mappings â€“ Instances

In this section, we illustrate the mapping instances of the domain classes `Address` and `Person`, highlighting the `TablPerson` and its attribute `birthDate` and the `TablAddress` and its attribute `address`. The `hasAddress` object property is annotated with the following content in the `relationField`:

```plaintext
field=IdPerson;table=BDMest.dbo.TablPersonAddress;field=IdAddress;
```

This annotation relates the two tables through the `TablPersonAddress` table. The attributes that relate `TablPerson` with `TablPersonAddress` (which is `IdPerson`) and `TablPersonAddress` with `TablAddress` (which is `IdAddress`) are also stored in the annotation.