database tables that store the data are created manually, and if changes occur in
© IBIS – Issue 3 (3), 2006
http://www.ibis-journal.net ISSN:1862-6378 IBIS – Issue 3 (3), 2006
the database schema, the mappings have to be redone manually. The advantage
that motivated its use is that in most cases, if the database changes (databases
externally or internally developed) the ontology remains the same, which imply
that clients do not have to be changed.
Architecture
The architecture of our middle-tier is three layered (data source, domain and
presentation layer), as depicted in Figure 3. In the next sections, we describe each
of the three layers.
Data Source Layer
This layer is responsible for the communication with databases (RDBMS). Our
solution uses Hibernate [HIB]. Hibernate design goal is to relieve the developer
from 95% of common data persistence related programming tasks by eliminating
the need for manual, hand-crafted data processing using SQL and JDBC [HIB]. It is
an open-source product developed in java and increases the developer productivity
enabling developers to focus more on the business problem. It is interoperable with
any JDBC compliant database and supports more than 20 popular dialects of SQL
including Oracle, DB2, Sybase, MS SQL Server, PostgreSQL, MySQL, HypersonicSQL,
Mckoi SQL, SAP DB, Interbase, Point base, Progress, Front Base, Ingres, Informix
and Firebird [J06].
As outlined in Figure 3, the data source layer contains a set of classes that
represent an interface (access point), allowing access to the objects of database
servers. This layer is responsible for executing SQL statement in order to get data
from the database.
Domain Layer
This layer contains the domain model described in OWL. Domain concepts,
relations between them and the rules associated are all presented in the OWL
model. The ontology is queried using SPARQL [PS06], which is a W3C ontology query
language. Our domain layer also contains the mapping to the data sources, stored
in the instances of the ontology, as illustrated in Figure 3. This is going to be
described in more detail in the ‘Querying the Middleware’ section. This layer
receives requests in SPARQL and executes the queries in order to extract the
mapping data from the instances. Then, using a developed “query generator
module” the SQL statement that allows getting the data from the data sources
layer is generated using the data stored in the ontology and in the ontology
instances. Then, Data is transformed to a XML format. This is going to be illustrated
in more detail in the next sections.
© IBIS – Issue 1 (1), 2006
IBIS – Interoperability in Business Information Systems
Figure 3: Middleware architecture
Presentation Layer
This layer receives the request message in XML from clients and provides responses
in XML. Web Services are used in order to provide the services, which mean that
responses are encapsulated in SOAP [W3CSP]. This layer also has the responsibility
to transform data that is going to be returned to clients (according to a specific
XML format) using XSLT style sheets [W3CXS]. As shown in Figure 3, this layer sends
a SPARQL statement to the domain layer. The SPARQL expression is generated by
© IBIS – Issue 3 (3), 2006
http://www.ibis-journal.net ISSN:1862-6378 IBIS – Issue 3 (3), 2006
transforming the client request that is described in detail in the Query Language
section.
Ontology to Represent Domain and Instances to Store
Mappings
In this section, we discuss the ontology that resides in the domain layer. First,
important domain classes and respective attributes were described. Examples are
illustrated in Figure 4. All attributes should be as string type because the instances
of the created classes will contain the mappings to the data sources. This way,
each ontology instance will contain the database table name that stores the data,
as is going to be described in more detail in the next section. Ontology relations
describe the relations that exist between domain concepts. For example, the
domain class Person is connected to Address through the property hasAddress, as
depicted in Figure 5. The ontology also contains rules. For example, we can use the
ontology to describe the relation between the address and the Person classes using
a cardinality restriction: one person must have at least one address.
Figure 5: Person and Address
Figure 4: Partial view of the classes of Personal Data ontology
domain concepts (using Ontoviz)
(using TGViz)
Mappings to Data Source Layer
After the creation of the ontology (or reuse of an already defined ontology),
instances containing the mappings to the data sources should be created. The
mappings will store information in order to allow the construction of an SQL
statement that will be executed in the data source layer in order to get the desired
information.
© IBIS – Issue 1 (1), 2006
IBIS – Interoperability in Business Information Systems
In order to generate the correct SQL statement, two types of mappings should be
created: domain classes and attributes to database tables and fields, and domain
relations to database relations.
Figure 6: Ontology Class (left side), Database table (centre) and Ontology Instance (right)
Several cases may exist in mapping domain classes to database tables:
• One class of the ontology may contain data from only one database table.
• One class of the ontology may contain data from two or more database
tables.
• One table from the database provides data to two or more domain classes.
In all of these cases, the name of the instance should be equal to the name of the
object in the data source layer that allows access to the table in the database. The
fields that belong to the table are mapped starting by field=???; (??? Represents
variable text). The fields that do not belong to the instance, should be mapped
using the following nomenclature: table=???;field=???;path={???}:
• table represents the name of the table that contains the specified field.
• field represents the name of the field that is stored in the table (previously
presented).
• path represents the path to reach the table. The content of Path is
field=???;table=???;field=???...field=???;table=???;field=???;. It should always
start and end with field. At least one field attribute is required.
As an example, using a domain class to database table mapping (illustrated in
Figure 6), the name of the instance of the class Person should be equal to the
respective object in the data source layer (TabPerson in this case). Attributes of
the created instances should contain the name of the field in the specified table
name, as depicted in Figure 6 by birthDate.
While in the domain model (described In OWL) relations connect domain concepts,
in the database relations connect tables. In order to map ontology relations to
database relations, our solution is to annotate the ontology relations. The content
of the annotation property, named relationAttribute, should follow the format
field=???table=???field=???...field=???table=????field=???. It should start and end with
‘field=’. The number of ‘tables=’ depends of the number of intermediary tables
that exist.
Exemplifying, in Figure 7, the domain classes Person and Address are shown. These
two ontology classes will be mapped to the tables TablPerson and TablAddress
(depicted in Figure 8), respectively. As illustrated in Figure 8, an intermediary
table named TablPersonAddress exists. Therefore, we need to store information
© IBIS – Issue 3 (3), 2006
http://www.ibis-journal.net ISSN:1862-6378 IBIS – Issue 3 (3), 2006
about this table, because other way it will not be possible to generate the SQL to
obtain the data. In this case, the property hasAddress should be annotated with the
following content in the relationField:
field=IdPerson;table=TablPersonAddress;field=IdAddress;. The IdPerson is the field
that connects the TablPerson to TablPersonAddress. The IdAddress connects the
table TablPersonAddress to TablAddress.
Figure 7: Domain class Contact and Person and
Address
Figure 8: Table Person,
Address and the intermediary
relation table
Querying the Middleware
As already mentioned and depicted in Figure 3, our middleware is accessible
through Web Services and the message content of the request and response is
structured in XML and encapsulated in a SOAP envelope. Users interact with our
system making requests ( which contains ‘what data’ is needed), using a XML
structure named CQL (Client Query Language) defined by the XSD schema
illustrated in Figure 9. CQL allow users to specify:
• Fields (ontology attributes) to be returned, using the outputFields element.
• The order of the output fields (ascending, descending), using the
orderFields.
• Filters (for example, return only names started by letter A), using the filters
element.
• Choose the path that connects domain classes, using the outputProperties
element.
These XML elements are described in more detail in the Figure 10 XSD Schema.
© IBIS – Issue 1 (1), 2006
IBIS – Interoperability in Business Information Systems
Figure 9: Schema of the XML request (Dashed rectangles represent optional XML elements. All the
others are required.)
For example to obtain the birth date and name of a person, the user should make
the following request:
© IBIS – Issue 3 (3), 2006
http://www.ibis-journal.net ISSN:1862-6378 IBIS – Issue 3 (3), 2006
Figure 10: Ontology Class Person
The above-illustrated request is processed by the middleware, therefore generating
automatically and on the fly the needed SQL statement to get the data. The
needed data in order to build the SQL statement is obtained by executing a SPARQL
query (generated by transforming the XML request from the user) on the ontology.
The return of the SPARQL query will contain the table name, attribute and
relations between tables.
The result of this request (the response) will be the birthDate and usualName of all
‘persons’ stored in the database, formatted in XML, sorted by usualName. As we
will illustrate in the following section, the response of this request is a XML
structure that hierarchical describes the ontology.
In the next section, we will illustrate a running example, which shows a small
ontology, the database schema that stores the data described by the ontology, the
instances that map the ontology concepts to the tables in the database, the
request and the response.
Example
Let us suppose that we are interested in getting the name of all our students and
their address. The first step is to locate the concepts in the ontology. Next, we
need to formulate the request. By invoking the service, we will get the data,
structured in XML accordingly to the ontology.
Ontology
In Figure 11, we illustrate the ontology classes Person and Address belonging to the
personal data ontology. Some of the fields associated to each class are also
illustrated.
© IBIS – Issue 1 (1), 2006
IBIS – Interoperability in Business Information Systems
Figure 11: Extract from the complete Person Data ontology
Database Schema
Next, we illustrate an extract from the personal data database schema. In the
example, we will focus in the TablPerson, TablPersonAddress e TablAddress.
Figure 12: Extract from the Personal Data database
Mappings – Instances
In this section, we illustrate the mapping instances of the domain classes Address
and Person, highlighting the TablPerson and its attribute birthDate and the
TablAddress and its attribute address. The hasAddress object property is annotated
with the following content in the relationField:
field=IdPerson;table=BDMest.dbo.TablPersonAddress;field=IdAddress;. This
annotation relates the two tables through the table TablPersonAddress. The
attributes that relate TablPerson with TablPersonAddress (which is IdPerson) and
TabkPersonAddress with TablAddress (which is IdAddress) are also stored in the
annotation.
© IBIS – Issue 3 (3), 2006