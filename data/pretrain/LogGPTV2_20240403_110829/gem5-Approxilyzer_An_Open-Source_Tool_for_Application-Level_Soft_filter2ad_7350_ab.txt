U
U
U
U
U
U
U
U
U
U
U
U
U
U
UU
UUU
+
Quality Threshold (Optional)
(cid:19)(cid:17)(cid:23)(cid:49)(cid:40)(cid:2)(cid:26)(cid:26)(cid:28)(cid:25)(cid:33)(cid:21)(cid:22)(cid:34)(cid:35)(cid:17)(cid:28)
Comprehensive 
error outcome 
profile
(cid:6)(cid:33)(cid:13)(cid:23)(cid:26)(cid:22)(cid:17)(cid:1)(cid:17)(cid:28)(cid:28)(cid:25)(cid:28)(cid:1)(cid:25)(cid:31)(cid:30)(cid:15)(cid:25)(cid:23)(cid:17)(cid:1)
(cid:41)(cid:18)(cid:25)(cid:28)(cid:1)(cid:25)(cid:24)(cid:17)(cid:1)(cid:17)(cid:28)(cid:28)(cid:25)(cid:28)(cid:1)(cid:29)(cid:21)(cid:30)(cid:17)(cid:42)
(cid:4)(cid:34)(cid:15)(cid:22)(cid:17)(cid:1)(cid:24)(cid:31)(cid:23)(cid:14)(cid:17)(cid:28)
(cid:41)(cid:16)(cid:34)(cid:24)(cid:13)(cid:23)(cid:21)(cid:15)(cid:1)(cid:21)(cid:24)(cid:29)(cid:30)(cid:13)(cid:24)(cid:15)(cid:17)(cid:1)(cid:25)(cid:18)(cid:1)(cid:10)(cid:4)(cid:42)(cid:1)
(cid:3)(cid:21)(cid:30)(cid:1)(cid:10)(cid:25)(cid:29)(cid:21)(cid:30)(cid:21)(cid:25)(cid:24)
(cid:9)(cid:26)(cid:17)(cid:28)(cid:13)(cid:24)(cid:16)(cid:1)(cid:30)(cid:34)(cid:26)(cid:17)(cid:1)
(cid:41)(cid:12)(cid:25)(cid:31)(cid:28)(cid:15)(cid:17)(cid:39)(cid:5)(cid:17)(cid:29)(cid:30)(cid:21)(cid:24)(cid:13)(cid:30)(cid:21)(cid:25)(cid:24)(cid:42)
(cid:6)(cid:28)(cid:28)(cid:25)(cid:28)(cid:1)(cid:25)(cid:31)(cid:30)(cid:15)(cid:25)(cid:23)(cid:17)
(cid:44)(cid:33)(cid:48)(cid:44)(cid:45)(cid:13)(cid:51)(cid:51)(cid:36)(cid:1)(cid:46)(cid:46)(cid:49)(cid:44)(cid:48)(cid:48)(cid:47)(cid:52)(cid:50)(cid:45)(cid:44)(cid:47)(cid:44)(cid:44)(cid:44)(cid:36)(cid:1)(cid:28)(cid:51)(cid:36)(cid:1)(cid:45)(cid:36)(cid:1)(cid:7)(cid:24)(cid:30)(cid:17)(cid:19)(cid:17)(cid:28)(cid:36)(cid:1)(cid:5)(cid:17)(cid:29)(cid:30)(cid:21)(cid:24)(cid:13)(cid:30)(cid:21)(cid:25)(cid:24)(cid:37)(cid:37)(cid:1)(cid:12)(cid:5)(cid:4)(cid:40)(cid:8)(cid:13)(cid:34)(cid:14)(cid:17)(cid:1)(cid:37)(cid:1)(cid:48)(cid:38)(cid:46)(cid:49)(cid:55)
(cid:10)(cid:4)
(cid:11)(cid:17)(cid:19)(cid:21)(cid:29)(cid:30)(cid:17)(cid:28)(cid:1)(cid:24)(cid:13)(cid:23)(cid:17)
(cid:11)(cid:17)(cid:19)(cid:21)(cid:29)(cid:30)(cid:17)(cid:28)(cid:1)(cid:30)(cid:34)(cid:26)(cid:17)
(cid:9)(cid:31)(cid:30)(cid:26)(cid:31)(cid:30)(cid:1)(cid:27)(cid:31)(cid:13)(cid:22)(cid:21)(cid:30)(cid:34)(cid:1)(cid:16)(cid:17)(cid:32)(cid:21)(cid:13)(cid:30)(cid:21)(cid:25)(cid:24)(cid:1)(cid:15)(cid:13)(cid:31)(cid:29)(cid:17)(cid:16)(cid:1)
(cid:14)(cid:34)(cid:1)(cid:17)(cid:28)(cid:28)(cid:25)(cid:28)(cid:1)(cid:13)(cid:30)(cid:1)(cid:30)(cid:20)(cid:21)(cid:29)(cid:1)(cid:17)(cid:28)(cid:28)(cid:25)(cid:28)(cid:1)(cid:29)(cid:21)(cid:30)(cid:17)
Fig. 1. Overview of gem5-Approxilyzer inputs and outputs.
(cid:29)
(cid:27)
(cid:29)
(cid:29)
(cid:6)
(cid:12)(cid:19)(cid:30)(cid:1)(cid:37) (cid:10)(cid:27)(cid:36)(cid:1)(cid:1)(cid:2)(cid:28)(cid:28)(cid:29)(cid:27)(cid:33) (cid:37) (cid:10)(cid:27)
(cid:5)(cid:19)(cid:31)(cid:19)(cid:17)(cid:31)(cid:19)(cid:18)
(cid:11)(cid:32)(cid:31)(cid:28)(cid:32)(cid:31)(cid:1)(cid:4)(cid:27)(cid:29)(cid:29)(cid:32)(cid:28)(cid:31)(cid:22)(cid:27)(cid:26)(cid:1)
(cid:38)(cid:11)(cid:4)(cid:39)
(cid:9)(cid:15)(cid:30)(cid:23)(cid:19)(cid:18)
(cid:12)(cid:19)(cid:30)(cid:1)(cid:37) (cid:10)(cid:27)(cid:36)(cid:1)(cid:1)(cid:2)(cid:28)(cid:28)(cid:29)(cid:27)(cid:33) (cid:37) (cid:14)(cid:19)(cid:30)
(cid:12)(cid:19)(cid:30)(cid:1)(cid:37) (cid:10)(cid:27)(cid:36)(cid:1)(cid:1)(cid:2)(cid:28)(cid:28)(cid:29)(cid:27)(cid:33) (cid:37) (cid:10)(cid:27)
(cid:5)(cid:19)(cid:31)(cid:19)(cid:17)(cid:31)(cid:15)(cid:16)(cid:24)(cid:19)(cid:1)(cid:5)(cid:15)(cid:31)(cid:15)(cid:1)
(cid:4)(cid:27)(cid:29)(cid:29)(cid:32)(cid:28)(cid:31)(cid:22)(cid:27)(cid:26)(cid:1)(cid:38)(cid:5)(cid:5)(cid:4)(cid:39)
(cid:13)(cid:22)(cid:24)(cid:19)(cid:26)(cid:31)(cid:1)(cid:5)(cid:15)(cid:31)(cid:15)(cid:1)(cid:4)(cid:27)(cid:29)(cid:29)(cid:32)(cid:28)(cid:31)(cid:22)(cid:27)(cid:26)(cid:1)
(cid:38)(cid:13)(cid:5)(cid:4)(cid:39)
(cid:12)(cid:19)(cid:30)(cid:1)(cid:37)(cid:40)(cid:1)(cid:5)(cid:27)(cid:19)(cid:30)(cid:1)(cid:31)(cid:21)(cid:22)(cid:30)(cid:1)(cid:17)(cid:24)(cid:15)(cid:30)(cid:30)(cid:1)(cid:27)(cid:20)(cid:1)(cid:19)(cid:29)(cid:29)(cid:27)(cid:29)(cid:1)(cid:30)(cid:22)(cid:31)(cid:19)(cid:30)(cid:1)(cid:26)(cid:19)(cid:19)(cid:18)(cid:1)(cid:29)(cid:19)(cid:30)(cid:22)(cid:24)(cid:22)(cid:19)(cid:26)(cid:17)(cid:34)(cid:1)(cid:28)(cid:29)(cid:27)(cid:31)(cid:19)(cid:17)(cid:31)(cid:22)(cid:27)(cid:26)(cid:35)
(cid:2)(cid:28)(cid:28)(cid:29)(cid:27)(cid:33) (cid:37)(cid:40)(cid:1)(cid:8)(cid:30)(cid:1)(cid:31)(cid:21)(cid:22)(cid:30)(cid:1)(cid:17)(cid:24)(cid:15)(cid:30)(cid:30)(cid:1)(cid:27)(cid:20)(cid:1)(cid:19)(cid:29)(cid:29)(cid:27)(cid:29)(cid:1)(cid:30)(cid:22)(cid:31)(cid:19)(cid:30)(cid:1)(cid:15)(cid:28)(cid:28)(cid:29)(cid:27)(cid:33)(cid:22)(cid:25)(cid:15)(cid:16)(cid:24)(cid:19)(cid:35)
(cid:12)(cid:19)(cid:30)(cid:1)(cid:37) (cid:14)(cid:19)(cid:30)(cid:36)(cid:1)(cid:1)(cid:2)(cid:28)(cid:28)(cid:29)(cid:27)(cid:33) (cid:37) (cid:10)(cid:27)
(cid:13)(cid:5)(cid:4)(cid:37)(cid:3)(cid:15)(cid:18)
(cid:12)(cid:19)(cid:30)(cid:1)(cid:37) (cid:9)(cid:15)(cid:34)(cid:16)(cid:19)(cid:36)(cid:1)(cid:2)(cid:28)(cid:28)(cid:29)(cid:27)(cid:33) (cid:37) (cid:9)(cid:15)(cid:34)(cid:16)(cid:19)
(cid:13)(cid:5)(cid:4)(cid:37)(cid:9)(cid:15)(cid:34)(cid:16)(cid:19)
(cid:12)(cid:19)(cid:30)(cid:1)(cid:37) (cid:10)(cid:27)(cid:36)(cid:1)(cid:1)(cid:2)(cid:28)(cid:28)(cid:29)(cid:27)(cid:33) (cid:37) (cid:14)(cid:19)(cid:30)
(cid:13)(cid:5)(cid:4)(cid:37)(cid:7)(cid:27)(cid:27)(cid:18)
Fig. 2. A classiﬁcation of error outcomes [25] and their implications for
approximation and resiliency.
gem5-Approxilyzer outputs a comprehensive error outcome
proﬁle (simply referred to as an error proﬁle) for the program. It
lists all the error sites in the program as well as the outcome of
an error (injected) at this error site, referred to as error outcome.
gem5-Approxilyzer distinguishes error outcomes as masked,
detected, or output corruptions (OCs). Instead of considering
all OCs as silent data corruptions (SDCs), gem5-Approxilyzer
analyzes the quality (degradation) of the corrupted outputs to
separate outcomes that are tolerable to the user from those that
are not. Figure 2 shows the various error outcome categories:
(1) Detected: An error that raises observable symptoms (e.g.,
fatal traps, segmentation faults, timeout etc.) that can be caught
using various low-cost detectors [6], [29]–[34] before the end
of execution. (2) DDC: An OC that is detectable via low-cost
mechanisms such as range detectors [35]. (3) SDC-Bad: An
OC with very large (unacceptable) output quality degradations.
(4) SDC-Maybe: An OC that may be tolerable if the output
quality degradation is within a user-provided quality threshold
(if no threshold is provided, all SDC-Maybe’s default to
SDC-Bad). (5) SDC-Good: An OC that produces negligibly
small (acceptable) output quality degradation. (6) Masked:
Errors that produce no OC.
Approxilyzer uses two different types of quality thresholds:
(1) obvious domain-speciﬁc thresholds for SDC-Good/SDC-
Bad/DDC categorization [25] and (2) user-speciﬁed quality
threshold to decide if an SDC-Maybe is acceptable. For
example, for ﬁnancial applications, dollar outputs of negative
value are obvious DDC, and quality differences of less than
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:56:27 UTC from IEEE Xplore.  Restrictions apply. 
one-hundredth of a cent could be assumed to be SDC-Good.
Beyond this, a user can optionally specify that for their
use-case, outputs within, say, 1 cent of the error-free value are
tolerable which will deﬁne if an SDC-Maybe is acceptable.
Thus, the error outcome associated with each error site is
composed of the error-outcome category as well as the output
quality degradation (QD) for OC class of errors. For the exam-
ple error site output shown in Figure 1, the error produces an
output corruption that is measured (using the quality metric pro-
vided, say, for example, average relative error) to have a quality
degradation of 4.25% from the error-free output. Because this
value is neither small enough to be labeled SDC-Good nor large
enough for SDC-Bad, the error outcome is categorized as SDC-
Maybe (in the absence of a user-speciﬁed quality threshold).
C. Use Cases of gem5-Approxilyzer
techniques that
The application error proﬁle that gem5-Approxilyzer
produces can be used by different
trade
accuracy in the program output for gains in other system
parameters. We discuss two such techniques: low cost resiliency
and approximate computing. Based on the knowledge of the
output quality produced by perturbing each error site in the
program, gem5-Approxilyzer can help decide which error site
needs protection from transient errors, or alternatively, which
error sites could be approximable.
Figure 2 shows how various error categories can be can
be grouped or equalized based on whether the context is
resiliency analysis (Res) or approximate computing (Approx).
Masked (no quality degradation), SDC-Good (acceptable
quality degradation), DDC (caught by low-cost detectors
of output), and Detected (caught by low-cost detectors of
execution) error sites can be equalized together as error sites
that do not need expensive resiliency protection. SDC-Bad
error sites, on the other hand, need to be protected (hardened).
Similarly, in the context of approximate computing, Masked
and SDC-Good can be equalized together and considered
approximable, while DDC, Detected, and SDC-Bad error sites
produce egregious outputs and so are not approximable [25].
Decisions for SDC-Maybe outcomes can be made based on
the quality thresholds provided by the user. For example, if the
quality degradation of the SDC-Maybe is below the acceptable
quality threshold, then the error site need not be protected
and is considered approximable. In the absence of quality
thresholds, SDC-Maybe can be conservatively equalized with
SDC-Bad. The reasoning about individual error sites can be
extended to instructions (both dynamic and static) based on
the error outcome of their constituent error sites.
D. Pruning Techniques
Compared to a na¨ıve campaign that performs an error
injection for every error site, gem5-Approxilyzer dramatically
reduces the number of error injections to predict the error
outcome for all error sites. gem5-Approxilyzer implements
two sets of pruning techniques from prior work [25], [26]:
equivalence-based and known-outcome. This section brieﬂy
describes these techniques; detailed explanations and examples
can be found in prior work [26].
216
Equivalence-based pruning techniques use program analysis
(static and dynamic) and heuristics to prune errors that are
likely equivalent to others. These techniques partition error sites
into equivalence classes, where each class requires an error
injection into just a single representative error site (called pilot)
to predict the error outcome for all other error sites in the class.
gem5-Approxilyzer implements two equivalence-based pruning
techniques. Control equivalence groups error sites based on
the observation that errors that propagate through similar code
sequences are likely to have similar error outcomes. This
technique records the next N branches for dynamic instances
of a given static instruction in the original execution (with no
error injection). Corresponding error sites of dynamic instances
that share the same control path (up to depth N) are grouped
in an equivalence class. Store equivalence is used to equalize
dynamic instances of store instructions (and instructions
that a store depends on within a basic block) based on the
observation that errors in a store instruction propagate through
the loads that read the erroneous value. This technique records
the subsequent loads that read from a store address and groups
(corresponding error sites of) dynamic instances of store
instructions that have the same list of subsequent loads together.
Known-outcome pruning techniques largely use static (and
some dynamic) program analyses to determine the outcome of
an error. gem5-Approxilyzer uses two known-outcome pruning
techniques. Address-bound pruning uses the observation
that single-bit errors that appear outside the address range
of an application result in Detected outcomes. Thus, their
outcomes are known a priori and these errors can be pruned.
Def-use pruning uses the observation that an injection in a
def is equivalent to an injection in the ﬁrst use at the same
register and bit position, so only one needs to be explored.
By combining all
these pruning techniques, gem5-
Approxilyzer can dramatically reduce the total number of error
sites that need error injections. In Section V-B, we validate
the effectiveness of these heuristics for both the resiliency and
approximate computing use cases.
III. GEM5-APPROXILYZER: IMPLEMENTATION
This section describes the implementation details and
associated challenges of gem5-Approxilyzer. We also brieﬂy
discuss future extensions to the tool.
A. Error Model used in gem5-Approxilyzer
The error model we use is single-bit transient errors in
architectural registers. We study errors in bits of both source
and destination registers of instructions.
In this work, we undertake error injection in registers
of x86 macro-instructions. Modern CISC implementations
like x86 often implement the complex machine instructions
(macro-instructions) using low-level
called
micro-instructions or micro-operations. Micro-instructions are
generally speciﬁc and proprietary to the micro-architecture
and not faithfully recreated in publicly available simulators.
Hence, we restrict our analysis to macro-instructions.
instructions
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:56:27 UTC from IEEE Xplore.  Restrictions apply. 
For this study, we only consider general-purpose registers
and SSE2 registers in x86. We do not inject errors in special-
purpose, status, and control registers (e.g., %rsp, %rbp, rﬂags)
to simplify our error model and reduce the number of error in-
jections required for a ﬁrst-order analysis. We assume that these
always need protection and can be hardened in hardware (e.g.,
with ECC). We also do not inject in implicit3 registers in this
work. Extending gem5-Approxilyzer to support these registers
is relatively straightforward and we leave it to future work.
B. Implementation Details
To execute gem5-Approxilyzer end-to-end, the user provides
an application, its inputs, and associated quality metrics that
evaluate the application output. The user can optionally mark
the beginning and end of a code region of interest (ROI)
– either by annotating the source or providing static PCs
marking the beginning and end of the ROI – for analysis. In
the absence of an ROI, the full application is analyzed.
gem5-Approxilyzer executes four phases to produce an
application’s error proﬁle.
(1) Phase 1 extracts static and dynamic properties of
instructions executed within the ROI. An instruction parser
module analyzes static instructions in the application’s
disassembly to identify registers used, determine if the
instruction affects control ﬂow (jumps, conditional branches,
function calls, etc.), and identify any registers that contain
memory addresses (these are marked for address-bound
pruning). Information from this static pass is used to build the
def-use chains that are used by pruning techniques in Phase 2.
Next, gem5 is used to produce a full dynamic execution trace
of user-mode instructions and memory accesses. From this
trace, only the (dynamic) instructions that are found within
the static disassembly, along with their corresponding memory
accesses, are extracted for analysis; gem5-Approxilyzer does
not analyze external library code, system code, or calls to
them. gem5-Approxilyzer further simpliﬁes the trace to only
contain the execution within the ROI (if an ROI is provided).
(2) Phase 2 prunes error sites as mentioned in Section II-D
by applying control- and store-equivalence as well as address-
bound and def-use techniques. gem5-Approxilyzer processes
the execution trace from Phase 1 to build control-equivalence
classes and def-use chains. The memory accesses recorded
in the trace are used to build store equivalence classes and
perform address-bound pruning. At the end of this phase,
gem5-Approxilyzer picks a pilot for each equivalence class
and creates the set of error sites for error injections.
(3) Phase 3 performs the error-injection experiments
using our error injector module built for gem5. The error
injector takes as input the error-site description: dynamic
instruction described using the cycle number of the simulation,
register information (register name and whether it is used as
a source/destination operand) and register bit number. The
error injector pauses the simulation at the speciﬁed dynamic
2The binaries we study do not explicitly use ﬂoating point stack registers
(st0-st7) in the region of interest and hence we do not study them.
3For example, the instruction imul rbx performs the following signed multipli-
cation: rdx:rax←−rax∗rbx. We only inject errors in rbx and not in rax and rdx.
217
instruction and ﬂips the bit in the register. For source registers,