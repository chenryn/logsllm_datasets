NSSet Child
TTL NS Parent
TTL NS Child
Date
Probes
VPs
Queries
Answers
20191003 20191003 20191025 20191025 20191025 20191026 20191027 20191027
8875
15586
186472
174504
84709
85739
1545
2511
From ns1, ns3
From ns2, ns4
From ns5, ns6
fail
8879
15611
185015
174804
83607
86804
N/A
4393
8875
15557
182992
174288
53944
83100
31740
5504
9031
15950
190333
178416
175124
322
N/A
2970
9028
15956
190434
178428
109661
65527
N/A
3240
8888
15639
184364
169224
132179
31753
N/A
5292
8883
15657
185706
175200
169482
1557
N/A
4161
8892
15647
186960
175080
52233
118835
N/A
4012
4.1 Disjoint Parent and Child NSSet
We have conﬁgured our test domain (marigliano.xyz) for the disjoint NSSet
experiment as shown in Fig. 2. For this experiment, we set the NSSet at the
Parent Auth
Child Auth
ns1.marigliano.xyz
ns3.marigliano.xyz
ns2.marigliano.xyz
ns4.marigliano.xyz
Fig. 2. Disjoint NSSset experiment for marigliano.xyz
Diving into DNS Delegation Inconsistency
181
parent to [ns1, ns3].marigliano.xyz, while on the child authoritative servers,
we set the NSSet to [ns2, ns4].marigliano.xyz (Table 2).
Zone ﬁles: we then conﬁgure the zone ﬁles of [ns1–ns4] to answer NS queries
with [ns2, ns4], if explicitly asked, i.e.,the same records pointed to by the child
authoritative servers. By doing that, we are able to single out resolvers that are
parent-centric, since they will only contact [ns1, ns3].
As vantage points, we use ∼9k Atlas probes, and conﬁgure them to send
A queries through each of their resolvers for $probeid-$timestamp.marigliano.
xyz, which encodes the unique Atlas probe ID and query timestamp, thus avoid-
ing queries of multiple probes interfering with each other. We also set the TTL
value of the record to 30 s, and probe every 600 s, so resolver caches are expected
to be empty for each round of measurements [13].
Our goal is to determine, indirectly, which NS records were used to answer
the queries. To do that, we conﬁgure [ns1, ns3] to answer our A queries with the
IP 42.42.42.42, and [ns2, ns4] with the IP 43.43.43.43. We use this approach
instead of inspecting the query log on the server-side to speed up parsing and
to avoid duplicated detection.
Figure 3a shows the results of the experiment. In round 0 of the measure-
ments, we have a warm-up phase of RIPE Atlas probes, where not all the probes
participate. Furthermore, we expect resolvers to have a cold cache and to use
the NSSet provided by the parent. As the ﬁgure shows, this is mostly the case
although 253 unique resolver IPs (diﬀerent probes can share the same resolver)
do contact the child name servers. This can be either due to them sending explicit
NS queries (and thus learning about [ns2, ns4]) or because some probes share
upstream caches. In subsequent rounds, we expect more traﬃc to go to the child
name servers [ns2, ns4]. This is because resolvers learn about the child delega-
tion from the “authority section” included in the response to the A query to ns1
or ns3. According to RFC2181 resolvers may prefer this information over the
delegation provided by the parent. Indeed, in rounds [1–11] we see traﬃc also
going to the child name servers. However, not all traﬃc goes to servers in the
child NSSet, because not all resolvers trust data from the “authority section”
due to mitigations against the so-called Kaminsky attack [8]. A key takeaway of
this experiment is that domain owners may mistakenly assume traﬃc to go to
the name servers in the child NSSet if they change it, whereas for this change to
be eﬀective, they must also update the parent NSSet.
The situation is even worse in our second experiment. Here, we conﬁgure [ns1–
ns4] to answer with minimal responses, which prevents these servers from includ-
ing “extra” records in the authority and additional sections of DNS answers. This
means we do not expect resolvers to learn about the existence of [ns2, ns4] at
all, since they are no longer present in the “authority section” of responses to
the A queries. Only if resolvers perform explicit NS queries will they learn about
[ns2, ns4]. As Fig. 3b shows, as expected, almost all resolvers exclusively send
their queries to the name servers in the NSSet of the parent. Only about 40
vantage points receive data from the name servers in the child NSSet, indicating
182
R. Sommese et al.
Parent
Child
Parent
Child
)
k
(
s
r
e
w
s
n
a
 20
 15
 10
 5
 0
0 1 2 3 4 5 6 7 8 9
0
1
1
1
)
k
(
s
r
e
w
s
n
a
 20
 15
 10
 5
 0
0 1 2 3 4 5 6 7 8 9
0
1
1
1
iteration (each 10 minutes)
iteration (each 10 minutes)
(a) Results for normal responses
(b) Results with minimal responses
Fig. 3. Disjoint NSSet experiments
their resolvers likely performed explicit NS queries. Authoritative name servers
are increasingly conﬁgured to return minimal responses to dampen the eﬀect
of DNS ampliﬁcation attacks, especially for DNSSEC-signed domains [19]. A
key takeaway from this experiment is with this conﬁguration becoming more
and more prevalent, it becomes even more important to keep parent and child
NSSets correctly synchronized.
Real-World Case: On 2019-10-30, we notiﬁed India’s .in, given they had
ns[1–6].neustar.in as NS records at the parent, and [ns1-ns6].registry.in at
the child. However, altogether, both NSSets pointed to the same A/AAAA records
and, as such, resolvers ended up reaching the same machines. After our notiﬁca-
tion, .in ﬁxed this inconsistency on 2019-11-02 (we analyzed DNS OARC’s root
zone ﬁle repository [4]). Besides .in, 15 other internationalized ccTLDs run by
India had the same issue with their NSset, and were also ﬁxed.
4.2 Parent NSSet Is a Subset of Child
Recall from Table 1 that the majority (69–73%) of cases in which parent and
child NSSets diﬀer fall into the category where the child NSSets contains one or
more additional NS records not present in the parent NSSet. A common reason
to add additional NS records is to spread load over more name servers, and we
assume this to be one of the reasons for this common misconﬁguration.
We set up experiments to determine the consequences on query distribution
if you have this setup. In other words: how many queries will eventually be
answered by the extra NS record? We conﬁgure our test domain with [ns1, ns3]
at the parent and [ns1, ns2, ns3, ns4] at the child. Like in the previous section,
we conﬁgure [ns1, ns3] to give a diﬀerent response to the A queries sent by the
Atlas probes than [ns2, ns4], so we learn how many queries were answered by
the name servers that are only in the child NSSet.
Figure 4a shows the results. Similary to the results shown in Sect. 4.1, most
resolvers will use the NS records provided by the parent. Given that the child
NSSet includes the NSSet at the parent, we see that the extra name servers
Diving into DNS Delegation Inconsistency
183
ns1 and ns3
ns2 and ns4
ns1 and ns3
ns2 and ns4
)
k
(
s
r
e
w
s
n
a
 20
 15
 10
 5
 0
0 1 2 3 4 5 6 7 8 9
0
1
1
1
)
k
(
s
r
e
w
s
n
a
 20
 15
 10
 5
 0
0 1 2 3 4 5 6 7 8 9
0
1
1
1
iteration (each 10 minutes)
iteration (each 10 minutes)
(a) Results for normal responses
(b) Results with minimal responses
Fig. 4. Subset NS sets experiments
receive only ∼24% of the queries. If in addition we conﬁgure the name servers to
return minimal responses, we see that, just as in Sect. 4.1 virtually no resolvers
contact the extra name servers in the child NSSet (Fig. 4b). A key takeaway
from these two experiments is that the, perhaps, expected even load distribu-
tion domain owners are hoping to see will not occur if only the child NSSet is
updated. This again underlines the importance of keeping parent and child in
sync.
Real-World Case: att.com: A real-world example that demonstrates that this
type of misconﬁguration also occurs for prominent domains is the case of att.com.
We discovered that AT&T’s main domain att.com had a parent NSSet contain-
ing [ns1...ns3].attdns.com, whereas the child had [ns1...ns4].attdns.com. We
notiﬁed AT&T of this misconﬁguration and on 2019-10-24 the issue was resolved
when the fourth name server (ns4.attdns.com) was also added to the parent.
4.3 Parent NSSet Is a Superset of Child
Roughly 14–18% of domain names that have diﬀerent NSSet at parent and child
have, one or more extra NS records at the parent (P ⊃ C in Table 1). This could
be due to operators forgetting to remove name servers that are no longer in use
at the parent, but also the reverse case of the previous section in which a new
name server is added at the parent but not added at the child.
To investigate the consequences of this for resolvers, we carry out experiments
using Atlas VPs, setting four NS records at the parent ([ns1, ns2, ns3, ns4], as in
Table 2) and only two at the child ([ns2, ns4]). Our goal is to identify the ratio
of queries answered by the extra NS records at the parent.
Figure 5a shows the results for the experiment. As can be seen, the servers
listed both in the parent and in the child ([ns2, ns4]) answer, on average, 68% of
the queries. In case minimal responses are conﬁgured (Fig. 5b), we see the queries
being distributed evenly among the NS records in the parent. Consequently,
having authoritative servers include an authority section in their answer to the
A queries seems to cause some resolvers to prefer the child NSSet over the one
in the parent. For example, Atlas VP (21448, 129.13.64.5) distributes queries
184
R. Sommese et al.
ns1 and ns3
ns2 and ns4
ns1 and ns3
ns2 and ns4
)
k
(
s
r
e
w
s
n
a
 20
 15
 10
 5
 0
0 1 2 3 4 5 6 7 8 9
0
1
1
1
)
k
(