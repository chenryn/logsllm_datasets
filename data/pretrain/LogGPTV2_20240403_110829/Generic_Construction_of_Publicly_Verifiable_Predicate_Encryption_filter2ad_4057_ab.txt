concludes the paper.
2. PRELIMINARIES
2.1 Predicate Encryption Scheme
Deﬁnition 1. (Predicate Encryption Deﬁnition 2.1 in [17])
A predicate encryption scheme for the class of predicate F
890over the set of Σ consists of the following probabilistic poly-
nomial time (PPT) algorithms:
• (PE.pk, PE.msk) ← PE.Setup(1λ): Take as input a se-
curity parameter 1λ. Output the public parameter
PE.pk a secret key sk. This algorithm initializes the
public parameter pk and generates a master secret key
PE.msk.
• PE.skf ← PE.KeyGen(PE.msk, f ): Take as input a se-
cret key sk and the predicate f ∈ F . Output the
secret key PE.skf . This algorithm generates a secret
key PE.skf for decryption according to predicate f .
• PE.c ← PE.Enc(PE.pk, I, m): Take as input public key
PE.pk, the attribute I ∈ Σ and the message m. Output
the ciphertext PE.c. This algorithm encrypts attribute
to obtain ciphertext PE.c.
• m/⊥ ← PE.Dec(PE.c, PE.skf ): Take as input a cipher-
text PE.c and the secret key PE.skf for a predicate.
Output m if f (I) = 1, otherwise output ⊥.
For correctness, we require that for all (PE.pk, PE.msk)
generated by PE.Setup(1λ), all f ∈ F, any key PE.skf ←
PE.KeyGen(PE.msk, f ), and all I ∈ Σ:
− If f (I) = 1, then PE.Dec(PE.c, PE.skf ) = m;
− If f (I) = 0, then PE.Dec(PE.c, PE.skf ) =⊥; with all
but negligible probability.
2.2 Bloom Filter
Bloom Filter is an eﬀective data structure for succinctly
representing a static set, which allows membership queries.
To express an n-element set S = {x1, ..., xn} using an m-bit
bloom ﬁlter. A m-bit bloom ﬁlter is an array of m bits which
were initialized as 0. The bloom ﬁlter uses k independent
hash functions H1, ..., Hk. Each element in S is mapped to
the same range {0, ..., m − 1}. For a random element x,
the bit in array corresponding to Hi(x) (1 (cid:54) i (cid:54) k) are
set to 1. If the position in array is already equal to 1, no
change is made. To determine whether y belongs to S, we
compute H1(y), ....Hk(y). once check whether all bits in the
array corresponding to Hi(x) (1 (cid:54) i (cid:54) k) equal to 1.
If
not, it is certainly that y (cid:54)∈ S; otherwise, y ∈ S with a
high probability because there is a non-zero false positive
rate in bloom ﬁlter. The false positive rate in an m-bit
bloom ﬁlter is (1 − 1
. Note that when
k = ln 2(m/n), hash functions lead to the minimal false
positive rate (0.6185)m/n.
k ≈ (1 − e− kn
k
m )
kn)
m
Deﬁnition 2. (Bloom Filter) A Bloom Filter is a space-
eﬃcient randomized data structure for representing a set in
order to support membership queries. There are two asso-
ciated algorithms:
• BF ← BFGen({H1, ..., Hk},{x1, ..., xn}): This algo-
rithm generates a m-bit bloom ﬁlter by hashing a data
set S = {x1, ..., xn} with H1, ..., Hk.
• {0, 1} ← BFVerify({H1, ..., Hk}, BF, y): This algorithm
performs membership queries, returns 1 if y ∈ S. Oth-
erwise, return 0.
3. PUBLICLY VERIFIABLE PREDICATE EN-
CRYPTION
Our main idea is as follows: To verify the correctness
of the returned results, we execute the predicate encryp-
tion two times: One for PE.Enc(I, m, pk) and the other for
PE.Enc(I, m, pk). Obviously there could only be one de-
cryption that succeeds. If the former decryption succeeds,
it means that f (I) = 1. if the latter succeeds, it means that
f (I) = 0. And if both succeed or fail, it means that the
cloud system is cheating.
3.1 Deﬁnition and Security
This section introduction the deﬁnition and security model
of Publicly Veriﬁable Predicate Encryption.
Deﬁnition 3. (Publicly Veriﬁable Predicate Encryption)
A Publicly Veriﬁable Predicate Encryption (PVPE) scheme
comprises the following ﬁve probabilistic polynomial time
(P P T ) algorithms:
• (pk, msk) ← Setup(1λ) : It takes as input a security
parameter 1λ and outputs the public parameter pk, a
master secret key msk.
• (c, vk) ← Enc(pk, I): It take as input the attribute I.
Output the ciphertext c and the verify key vk.
• skf ← KeyGen(msk, f ): It take as input a predicate f
and the master secret key msk. Output the secret key
skf .
• σout ← Dec(c, skf ): It take as input the ciphertext c
and the secret key skf . Output the result σout .
• y ← Verify(σout, vk): It take as input the result σout
and the verify key vk, output y ∈ {0, 1}/⊥. Here the
special symbol ⊥ signiﬁes that the veriﬁcation algo-
rithm cheating.
Deﬁnition 4. (Security Model of PVPE) Let PVPE be a
publicly veriﬁable predicate encryption scheme for a class
of attribute f ∈ F, and let AO be any pair of probabilis-
tic polynomial time machines. Consider the experiment
ExpsP ubV erif
[PVPE, f, 1k] as follows:
A
Experiment ExpsP ubV erif
[PVPE, f, 1k]
A
f ← A(1λ)
(pk, msk) ← Setup(1λ)
skf ← KeyGen(f, msk)
(c∗, vk∗) ← Enc(I∗, pk)
out ← AO(c∗, skf )
σ∗
y∗ ← Verify(σ∗
out, vk∗)
If y∗ (cid:54)= ⊥ and y∗ (cid:54)= f (I∗), ExpsP ubV erif
[PVPE, f, 1k] out-
A PVPE is secure if for every function f ∈ F and for every
A
put ’1’, else ’0’.
PPT adversary A
A
Pr[ExpsP ubV erif
[PVPE, f, 1k] = 1] ≤ ε,
where ε denotes a negligible function of its input.
3.2 Generic Construction
We achieve the feature of veriﬁability in predicate encryp-
tion. First we need to prepare public parameter pk and se-
cret key msk. Then we encrypt twice to get a veriﬁed key vk
891and two ciphertexts. One of the ciphertext is corresponding
to the attribute value I, the other ciphertext is correspond-
ing to the attribute value I. Finally, we use the verify key
vk to verify the correctness of results. The description of
our scheme in detail shows below.
• (sk, mpk) ← Setup(1λ): Given the security parameter
λ, it executes
(PE.pk, PE.msk) ← PE.Setup(1λ).
Randomly choose a one-way function g(·) : {0, 1}∗ →
{0, 1}l. It returns pk = (PE.pk, g(·)) and msk = PE.msk.
• (c, vk) ← Enc(pk, I): Given the attribute set I, choose
random m0, m1 in the message space M, run
PE.c0 ← PE.Enc(I, m0, PE.pk),
PE.c1 ← PE.Enc(I, m1, PE.pk).
It outputs the ciphertext c = (PE.c0, PE.c1) and pub-
lishes the veriﬁcation key vk = (g(m0), g(m1)).
• skf ← KeyGen(msk, f ): Given msk and a predicate
f ∈ F , it generates the secret key
skf = PE.skf ← PE.KeyGen(msk, f ).
• σout ← Dec(c, skf ): It computes
d0 ← PE.Dec(skf , PE.c0),
d1 ← PE.Dec(skf , PE.c1).
and returns the decrypted result σout = (d0, d1).
• y ← Verify(σout, vk): Given σout = (d0, d1) and vk =
(g(m0), g(m1)), output
 0,
1,
⊥,
y =
g(d0) (cid:54)= g(m0) and g(d1) = g(m1),
g(d0) = g(m0) and g(d1) (cid:54)= g(m1),
otherwise.
Correctness.
− If f (I) = 1 then f (I) = 0, thus the result of Verify is
that d0 = m0 and d1 =⊥. The algorithm Verify outputs
y = 1 since g(d0) = g(m0) and g(d1) (cid:54)= g(m1), as excepted;
− If f (I) = 0 then f (I) = 1, thus the result of Verify
is that d0 =⊥ and d1 = m1. The algorithm Verify output
y = 0 since g(d0) (cid:54)= g(m0) and g(d1) = g(m1), as excepted;
3.3 Security
Theorem 1. If predicate encryption PE is attribute-hiding,
g is a one-way function, then PVPE is secure in the sense
of Deﬁnition 4.
Proof. Assume that we are given an adversary APVPE
which breaks selectively-secure publicly veriﬁability deﬁned
in Deﬁnition 4 of our scheme Σ(cid:48) with running time τ , qE
key-extraction queries, advantage δ to break the security
and advantage ρ to break a one-way function. We use APVPE
to construct another adversary APE which breaks attribute-
hiding of the PE scheme with advantage ADVAP E .
• Init. APVPE is given the security parameter λ by the envi-
ronment, and publishes its choice of input attribute f∗. APE
must send the challenge attribute to challenger C: APE(1λ)
output I, I(cid:48) ∈ Σ subject to the restriction that f∗(I) =
f∗(I(cid:48)). Set k = f∗(I). If k = 0 construct two diﬀerent at-
tribute sets I0 = I and I1 = I(cid:48); else k = 1. Construct two
diﬀerent attributes I0 = I and I1 = I(cid:48);
• Setup. The challenger C runs PE.Setup to generate PE.pk
and PE.sk, then gives PE.pk to APE. APE simulates to run
PVPE.Setup such that the outcome is consistent with PE.pk.
And publish pk = PE.pk.
• Phase 1.
APVPE may adaptively request SKf for query predicate
f1, ...fl ∈ F, which subjects to the restrict that f∗(I) =
f∗(I(cid:48)). APE makes use of O(PE.KeyGen) to provide the cor-
responding keys skfi = PE.skfi ← KeyGen(sk, fi) for APVPE.
• Challenge. To generate the challenge input, APE begins
by choosing three random messages m0, m1 and m(cid:48) from
M, and a random bit t. APE sends m0, m1 to C as the
challenge message for the PE game. C chooses a random bit
b and returns the ciphertext c∗ ← PE.Enc(mb, Ib, PE.pk).
1. If b = 0 (that is f∗(I0) = f∗(I1) = 0), APE sets c0
∗ =
∗ ← PE.Enc(I, m(cid:48), PE.pk), vkf =
c∗ and computes c1
(g(mt), g(m(cid:48)));
2. If b = 1 (that is f∗(I0) = f∗(I1) = 1), APE sets c0
∗ ←
∗ = c∗, vkf =
PE.Enc(I, m(cid:48), PE.pk) and compute c1
(g(m(cid:48)), g(mt)).
Finally, APE sends (c0
∗), vkf to APVPE.
∗, c1
• Phase 2. APE answers APVPE’s query as in Phase 1.
Guess. APVPE outputs (d0, d1) by making use of the PVPE.Dec
oracle. APE gets the result (d0, d1). APVPE simulates as fol-
lows: We note that we set an opposite condition in Challenge,
that means the cheating succeeds if APVPE passes the veriﬁ-
cation. Thus there are only two kinds of results: a message
R for success and ⊥ for fail. So if g(R) = g(t), APE sends a
guess b∗ = t to C, otherwise b∗ = 1 − t.
Now, we consider the advantage of this constructed APVPE
playing the attribute-hiding game for PE: recall by assump-
tion, APVPE has a non-negligible advantage δ to succeed.
P r[ExpsP ubV erif
A
[PVPE, f, 1k] = 1] ≥ ε
which means APVPE succeeds in cheating.
∗
P r(b
= b)
= P r(t = b)P r(b
∗
= b|t = b) + P r(t (cid:54)= b)P r(b
∗
= b|t (cid:54)= b)
(δ − ρ) +
≥ 1
2
1
2