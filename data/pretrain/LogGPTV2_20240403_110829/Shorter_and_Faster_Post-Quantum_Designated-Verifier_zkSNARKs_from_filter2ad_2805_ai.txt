tion via Multi-key FHE. In EUROCRYPT. 735â€“763.
[86] Anca Nitulescu. 2019. Lattice-Based Zero-Knowledge SNARGs for Arithmetic
Circuits. In LATINCRYPT. 217â€“236.
[87] Bryan Parno, Jon Howell, Craig Gentry, and Mariana Raykova. 2013. Pinocchio:
Nearly Practical Verifiable Computation. In IEEE Symposium on Security and
Privacy. 238â€“252.
[88] Chris Peikert. 2016. A Decade of Lattice Cryptography. Found. Trends Theor.
Comput. Sci. 10, 4 (2016), 283â€“424.
[89] Chris Peikert, Vinod Vaikuntanathan, and Brent Waters. 2008. A Framework
for Efficient and Composable Oblivious Transfer. In CRYPTO. 554â€“571.
[90] Charles M Rader. 1968. Discrete Fourier transforms when the number of data
samples is prime. Proc. IEEE 56, 6 (1968), 1107â€“1108.
[91] Oded Regev. 2005. On lattices, learning with errors, random linear codes, and
cryptography. In STOC. 84â€“93.
1253â€“1298.
[92] Omer Reingold, Guy N. Rothblum, and Ron D. Rothblum. 2016. Constant-round
interactive proofs for delegating computation. In STOC. 49â€“62.
[93] Jacob T. Schwartz. 1980. Fast Probabilistic Algorithms for Verification of Poly-
nomial Identities. J. ACM 27, 4 (1980).
[94] SCIPR Lab. 2021. libfqfft: C++ library for FFTs in finite fields. https://
[95] SCIPR Lab. 2021. libiop: a C++ library for IOP-based zkSNARKs. https:
[96] SCIPR Lab. 2021. libsnark: a C++ library for zkSNARK proofs. https://
[97] Srinath Setty. 2020. Spartan: Efficient and General-Purpose zkSNARKs Without
github.com/scipr-lab/libfqfft/.
//github.com/scipr-lab/libiop.
github.com/scipr-lab/libsnark/.
Trusted Setup. In CRYPTO. 704â€“737.
[98] Srinath T. V. Setty, Benjamin Braun, Victor Vu, Andrew J. Blumberg, Bryan
Parno, and Michael Walfish. 2013. Resolving the conflict between generality
and plausibility in verified computation. In EuroSys. 71â€“84.
[99] Srinath T. V. Setty and Jonathan Lee. 2020. Quarks: Quadruple-efficient trans-
parent zkSNARKs. IACR Cryptol. ePrint Arch. 2020 (2020), 1275.
[100] Srinath T. V. Setty, Victor Vu, Nikhil Panpalia, Benjamin Braun, Andrew J.
Blumberg, and Michael Walfish. 2012. Taking Proof-Based Verified Computation
a Few Steps Closer to Practicality. In USENIX. 253â€“268.
[101] StarkWare Team. 2021. ethSTARK Documentation. IACR Cryptol. ePrint Arch.
2021 (2021), 582.
ethSTARK.
CRYPTO. 71â€“89.
[102] StarkWare Team. 2021. ethSTARK. https://github.com/starkware-libs/
[103] Justin Thaler. 2013. Time-Optimal Interactive Proofs for Circuit Evaluation. In
[104] Llewellyn H Thomas. 1963. Using a computer to solve problems in physics.
Applications of digital computers (1963), 44â€“45.
[105] Riad S. Wahby, Srinath T. V. Setty, Zuocheng Ren, Andrew J. Blumberg, and
Michael Walfish. 2015. Efficient RAM and control flow in verifiable outsourced
computation. In NDSS.
[106] Riad S. Wahby, Ioanna Tzialla, Abhi Shelat, Justin Thaler, and Michael Walfish.
2018. Doubly-Efficient zkSNARKs Without Trusted Setup. In IEEE Symposium
on Security and Privacy. 926â€“943.
[107] Michael Walfish and Andrew J. Blumberg. 2015. Verifying computations without
reexecuting them. Commun. ACM 58, 2 (2015), 74â€“84.
[108] Tiancheng Xie, Jiaheng Zhang, Yupeng Zhang, Charalampos Papamanthou, and
Dawn Song. 2019. Libra: Succinct Zero-Knowledge Proofs with Optimal Prover
Computation. In CRYPTO. 733â€“764.
[109] Jiaheng Zhang, Weijie Wang, Yinuo Zhang, and Yupeng Zhang. 2020. Doubly
Efficient Interactive Proofs for General Arithmetic Circuits with Linear Prover
Time. IACR Cryptol. ePrint Arch. 2020 (2020), 1247.
[110] Jiaheng Zhang, Tiancheng Xie, Yupeng Zhang, and Dawn Song. 2020. Trans-
parent Polynomial Delegation and Its Applications to Zero Knowledge Proof.
In IEEE Symposium on Security and Privacy. 859â€“876.
[111] Yupeng Zhang, Daniel Genkin, Jonathan Katz, Dimitrios Papadopoulos, and
Charalampos Papamanthou. 2017. A Zero-Knowledge Version of vSQL. IACR
Cryptol. ePrint Arch. 2017 (2017), 1146.
[112] Richard Zippel. 1979. Probabilistic algorithms for sparse polynomials. In EU-
ROSAM.
A ADDITIONAL PRELIMINARIES
In this section, we recall additional preliminaries.
Lemma A.1 (Schwartz-Zippel [93, 112]). Let ğ‘“ âˆˆ F[ğ‘¥1, . . . , ğ‘¥ğ‘›]
be a multivariate polynomial of total degree at most ğ‘‘ over F, not
identically zero. Then for any set ğ‘† âŠ† F,
Pr[ğ‘“ (ğ›¼1, . . . , ğ›¼ğ‘›) = 0 | ğ›¼1, . . . , ğ›¼ğ‘›
râ† ğ‘†] â‰¤ ğ‘‘/|ğ‘†| .
Lemma A.2 (Smudging Lemma). Let ğµ, ğµâ€² be integers. Fix any value
|ğ‘’1| â‰¤ ğµâ€² and sample ğ‘’2
râ† [âˆ’ğµ, ğµ]. The statistical distance between
the distributions of ğ‘’1 + ğ‘’2 and ğ‘’2 is at most ğµâ€²/ğµ.
Discrete Gaussians and tail bounds. We also recall some prelimi-
naries on the discrete Gaussian distribution. We refer to Peikertâ€™s
survey [88] for additional details and references. For a real value
ğ‘  > 0, the Gaussian function ğœŒğ‘  : R â†’ R+ with width ğ‘  is the func-
tion ğœŒğ‘ (ğ‘¥) := exp(âˆ’ğœ‹ğ‘¥2/ğ‘ 2). The discrete Gaussian distribution
ğ·Z,ğ‘  over Z with mean 0 and width ğ‘  is the distribution where
Pr[ğ‘‹ = ğ‘¥ : ğ‘‹ â† ğ·Z,ğ‘ ] =
(A.1)
ğ‘¦âˆˆZ ğœŒğ‘ (ğ‘¦) .
ğœŒğ‘ (ğ‘¥)
Session 1C: Zero Knowledge I CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea226A real random variable ğ‘‹ is subgaussian with parameter ğ‘  if for
every ğ‘¡ â‰¥ 0, Pr[|ğ‘‹| > ğ‘¡] â‰¤ 2 exp(âˆ’ğœ‹ğ‘¡2/ğ‘ 2). The following two facts
will be useful in our analysis.
â€¢ If ğ‘‹ is subgaussian with parameter ğ‘  and ğ‘ âˆˆ R, then ğ‘ğ‘‹ is
â€¢ If ğ‘‹1, . . . , ğ‘‹ğ‘š are independent subgaussian random variables with
parameters ğ‘ 1, . . . , ğ‘ ğ‘š, respectively, thenğ‘–âˆˆ[ğ‘š] ğ‘‹ğ‘– is subgaus-
subgaussian with parameter |ğ‘| ğ‘ .
sian with parameter âˆ¥sâˆ¥2 where s = (ğ‘ 1, . . . , ğ‘ ğ‘š).
Rank-1 constraint satisfiability. We recall the definition of the
R1CS language introduced implicitly by Gennaro et al. [64] and
formalized explicitly in [20, 21, 98]:
Definition A.3 (Rank-1 Constraint Satisfiability [21, 64, 98]). A
rank-1 constraint satisfiability (R1CS) system over a finite field F
is specified by a tuple CS = (cid:0)ğ‘›, ğ‘ğ‘”, ğ‘ğ‘¤, {ağ‘–, bğ‘–, cğ‘–}ğ‘–âˆˆ[ğ‘ğ‘”](cid:1) where
ğ‘›, ğ‘ğ‘”, ğ‘ğ‘¤ âˆˆ N, ğ‘› â‰¤ ğ‘ğ‘¤, and ağ‘–, bğ‘–, cğ‘– âˆˆ Fğ‘ğ‘¤+1. The system CS is
satisfiable for a statement x âˆˆ Fğ‘› if there exists a witness w âˆˆ Fğ‘ğ‘¤
such that
â€¢ x = (ğ‘¤1, . . . , ğ‘¤ğ‘›) and
â€¢ [1 | wT]ağ‘– Â· [1 | wT]bğ‘– = [1 | wT]cğ‘– for all ğ‘– âˆˆ [ğ‘ğ‘”].
We denote this by writing CS(x, w) = 1, and refer to ğ‘› as the state-
ment size, ğ‘ğ‘¤ as the number of variables, and ğ‘ğ‘” as the number of
constraints. Given an R1CS system CS, we define the correspond-
ing relation RCS = {(x, w) âˆˆ Fğ‘› Ã— Fğ‘ğ‘¤ : CS(x, w) = 1}.
Remark A.4 (Boolean and Arithmetic Circuit Satisfiability). As
shown in [20, 64], the language of R1CS capture Boolean and arith-
metic circuit satisfiability as special cases. Namely, a Boolean circuit
satisfiability instance for a Boolean circuit ğ¶ : {0, 1}ğ‘› Ã— {0, 1}â„ â†’
{0, 1} with ğ›¼ wires and ğ›½ bilinear gates yields an R1CS instance
with ğ‘ğ‘¤ = ğ›¼ variables and ğ‘ğ‘” = ğ›½ + â„ + 1 constraints. Similarly,
an arithmetic circuit ğ¶ : Fğ‘› Ã— Fâ„ â†’ Fâ„“ with ğ›¼ wires and ğ›½ bilinear
gates corresponds to an R1CS instance with ğ‘ğ‘¤ = ğ›¼ variables and
ğ‘ğ‘” = ğ›½ + â„“ constraints. In this work, we focus exclusively on linear
PCPs and SNARKs for R1CS.
A.1 Linear PCPs
We now recall the notion of a linear PCP (LPCP) from [30, 76]. In
this work, we only consider linear PCPs for R1CS systems, so we
specialize all of our definitions to this setting:
Definition A.5 (Linear PCP [30, 76, adapted]). Let ğ‘ be a polyno-
mial and let CS = {CSğœ…}ğœ…âˆˆN be a family of R1CS systems over a
has size at most |CSğœ…| â‰¤ ğ‘(ğœ…). In the following, we write ğ‘› = ğ‘›(ğœ…)
to denote a polynomially-bounded function where ğ‘›(ğœ…) = ğ‘›ğœ… for
all ğœ… âˆˆ N. We define ğ‘ğ‘” = ğ‘ğ‘”(ğœ…) and ğ‘ğ‘¤ = ğ‘ğ‘¤(ğœ…) similarly. A
ğ‘˜-query input-independent linear PCP for CS with query length
â„“ = â„“(ğœ…) and knowledge error ğœ€ = ğœ€(ğœ…) is a tuple of algorithms
Î LPCP = (QLPCP, PLPCP,VLPCP) with the following properties:
â€¢ QLPCP(1ğœ…) â†’ (st, Q): The query-generation algorithm takes
as input the system index ğœ… âˆˆ N and outputs a query matrix
Q âˆˆ Fâ„“Ã—ğ‘˜ and a verification state st.
â€¢ PLPCP(1ğœ…, x, w) â†’ ğ…: On input the system index ğœ… âˆˆ N, a state-
ment x âˆˆ Fğ‘›, and a witness w âˆˆ Fğ‘ğ‘¤ , the prove algorithm
outputs a proof ğ… âˆˆ Fâ„“.
finite field F where CSğœ… =(cid:0)ğ‘›ğœ…, ğ‘ğ‘”,ğœ…, ğ‘ğ‘¤,ğœ…, {ağ‘–,ğœ…, bğ‘–,ğœ…, cğ‘–,ğœ…}ğ‘–âˆˆ[ğ‘ğ‘”,ğœ… ](cid:1)
(cid:21)
(st, Q) â† QLPCP(1ğœ…),
ğ… â† PLPCP(1ğœ…, x, w)
= 1.
â€¢ VLPCP(st, x, a): On input the verification state st, the statement
x âˆˆ Fğ‘›, and a vector of responses a âˆˆ Fğ‘˜, the verification algo-
rithm outputs a bit ğ‘ âˆˆ {0, 1}.
In addition, Î LPCP should satisfy the following properties:
â€¢ Completeness: For all ğœ… âˆˆ N, x âˆˆ Fğ‘›, and w âˆˆ Fğ‘ğ‘¤ where
(cid:20)
CSğœ…(x, w) = 1,
VLPCP(st, x, QTğ…) = 1(cid:12)(cid:12)
Pr
â€¢ Knowledge: There exists an efficient extractor ELPCP such that
for all ğœ… âˆˆ N, x âˆˆ Fğ‘›, and ğ…âˆ— âˆˆ Fâ„“, if
Pr[VLPCP(st, x, QTğ…âˆ—) = 1 | (st, Q) â† QLPCP(1ğœ…)] > ğœ€,
then
{(st, Q, QTğ…)} â‰¡ {((cid:101)st, ËœQ, Ëœa)},
Pr[CSğœ…(x, w) = 1 | w â† EâŸ¨ğ…âˆ—,Â·âŸ©
LPCP (1ğœ…, x)] = 1.
We refer to ğœ€ as the knowledge error of the linear PCP.
â€¢ Perfect honest-verifier zero knowledge (HVZK): There ex-
ists an efficient simulator SLPCP = (S1,S2) such that for all
ğœ… âˆˆ N and all instances (x, w) where CSğœ…(x, w) = 1,
where (st, Q) â† QLPCP(1ğœ…), ğ… â† PLPCP(1ğœ…, x, w), ((cid:101)st, ËœQ, stS) â†
CSğœ… =(cid:0)ğ‘›ğœ…, ğ‘ğ‘”,ğœ…, ğ‘ğ‘¤,ğœ…, {ağ‘–,ğœ…, bğ‘–,ğœ…, cğ‘–,ğœ…}ğ‘–âˆˆ[ğ‘ğ‘”,ğœ… ](cid:1). We write ğ‘› = ğ‘›(ğœ…)
S1(1ğœ…), and Ëœa â† S2(stS, x).
Linear PCPs for R1CS. The quadratic arithmetic programs (QAPs)
introduced by Gennaro et al. [64] immediately imply a 4-query
linear PCP for R1CS [20]. Note that Ben-Sasson et al. [20] described
the construction as a 5-query linear PCP with statistical HVZK (over
large fields); however, it is straightforward to adapt the construction
to obtain a 4-query LPCP with perfect HVZK (over any field). These
changes incur a slight increase in the verification complexity and
the knowledge error. We state the main result below and describe
the construction from [20] and our modifications in Appendix B.
Claim A.6 (Linear PCPs for R1CS [20, 64, adapted]). Let CS =
{CSğœ…}ğœ…âˆˆN be a family of R1CS instances over a finite field F, where
to denote a function where ğ‘›(ğœ…) = ğ‘›ğœ… for all ğœ… âˆˆ N; we define
ğ‘ğ‘” = ğ‘ğ‘”(ğœ…) and ğ‘ğ‘¤ = ğ‘ğ‘¤(ğœ…) correspondingly. Then, there exists
a 4-query linear PCP for CS with knowledge error 2ğ‘ğ‘”/(|F| âˆ’ ğ‘ğ‘”),
query length 4 + ğ‘ğ‘¤ + ğ‘ğ‘” âˆ’ ğ‘›, and satisfying perfect HVZK.
Remark A.7 (Knowledge Amplification for Linear PCPs). Claim A.6
gives a 4-query linear PCP for any R1CS system with ğ‘ğ‘” con-
straints that has knowledge error ğœ€ = 2ğ‘ğ‘”/(|F| âˆ’ ğ‘ğ‘”). To achieve
negligible knowledge error, this necessitates working over a field
of super-polynomial size. In our lattice-based instantiation, it is
more efficient to work over smaller fields. To amplify knowledge,
we use standard parallel repetition. Namely, for a ğ‘˜-query LPCP
with query length ğ‘š and knowledge error ğœ€, we can obtain a (ğ‘˜ğœŒ)-
query LPCP with the same query length and knowledge error ğœ€ğœŒ.
In more detail, the setup algorithm samples ğœŒ independent sets
of queries Q1, . . . , QğœŒ âˆˆ Fğ‘šÃ—ğ‘˜ and constructs its query matrix Q
as Q = [Q1 | Â· Â· Â· | QğœŒ] âˆˆ Fğ‘šÃ—ğ‘˜ğœŒ. The verifier accepts a response
a = [a1 | Â· Â· Â· | ağœŒ] only if all ğœŒ sets of responses are valid.
Session 1C: Zero Knowledge I CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea227A.2 Succinct Non-Interactive Arguments
We recall the definitions of a succinct non-interactive argument of
knowledge (SNARK) for R1CS:
Definition A.8 (Succinct Non-Interactive Argument of Knowl-
edge). Let CS = {CSğœ…}ğœ…âˆˆN be a family of R1CS systems over a
finite field F, where |CSğœ…| â‰¤ ğ‘ (ğœ…) for some fixed polynomial ğ‘ (Â·).
A succinct non-interactive argument (SNARK) in the preprocessing
model9 for CS is a tuple Î SNARK = (Setup, Prove, Verify) with the
following properties:
â€¢ Setup(1ğœ†, 1ğœ…) â†’ (crs, st): On input the security parameter ğœ†
and the system index ğœ…, the setup algorithm outputs a common
reference string crs and verification state st.
â€¢ Prove(crs, x, w) â†’ ğœ‹: On input a common reference string crs,
a statement x, and a witness w, the prove algorithm outputs a
proof ğœ‹.
â€¢ Verify(st, x, ğœ‹) â†’ {0, 1}: On input the verification state st, a
statement x and a proof ğœ‹, the verification algorithm outputs a
bit ğ‘ âˆˆ {0, 1}.
Moreover, Î SNARK should satisfy the following properties:
â€¢ Completeness: For all security parameters ğœ† âˆˆ N, system in-
dices ğœ… âˆˆ N, and instances (x, w) where CSğœ…(x, w) = 1,
Pr[Verify(st, x, ğœ‹) = 1] = 1,
where (crs, st) â† Setup(1ğœ†, 1ğœ…), ğœ‹ â† Prove(crs, x, w).
â€¢ Knowledge: For all polynomial-size provers Pâˆ—, there exists
a polynomial-size extractor E such that for all security param-
eters ğœ† âˆˆ N, system indices ğœ… âˆˆ N, and auxiliary inputs ğ‘§ âˆˆ
{0, 1}poly(ğœ†),
Pr[Verify(st, x, ğœ‹) = 1 âˆ§ CSğœ…(x, w) â‰  1] = negl(ğœ†),
where (crs, st) â† Setup(1ğœ†, 1ğœ…), (x, ğœ‹) â† Pâˆ—(1ğœ†, 1ğœ…, crs; ğ‘§), and
w â† E(1ğœ†, 1ğœ…, crs, st, x; ğ‘§).
â€¢ Efficiency: There exist a universal polynomial ğ‘ (independent
of CS) such that Setup and Prove run in time ğ‘(ğœ† + |CSğœ…|),
Verify runs in time ğ‘(ğœ† + |x| + log |CSğœ…|), and the proof size is
ğ‘(ğœ† + log |CSğœ…|).
Remark A.9 (Public Verification vs. Designated Verifier). We say
a SNARK is publicly-verifiable if st can be efficiently computed from
crs (i.e., verification only depends on the public common reference
string). Otherwise, the SNARK is designated-verifier (i.e., only the
holder of the secret verification state st can check proofs). In this
work, we focus on designated-verifier SNARKs.
Definition A.10 (Zero Knowledge). A SNARK Î SNARK = (Setup,
Prove, Verify) for an R1CS system CS = {CSğœ…}ğœ…âˆˆN is computa-
tional zero knowledge (i.e., a zkSNARK) if there exists an efficient
simulator SSNARK = (S1,S2) such that for all ğœ… âˆˆ N and all efficient
and stateful adversaries A, we have that
Pr[ExptZKÎ SNARK,A,SSNARK
(1ğœ†, 1ğœ…) = 1] â‰¤ 1/2 + negl(ğœ†),
where the experiment ExptZKÎ SNARK,A,SSNARK
follows:
9In the preprocessing model, we allow for a statement-independent setup algorithm that