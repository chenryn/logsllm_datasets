Yes
Yes
NA
NA
NA
NA
Table 4: A list of public exploits hardened by Q. For each exploit, we record how long the trace and analysis components
took to run, and report if Q produced hardened exploits that call 1) a linked function, and 2) system or WinExec.
striving for Turing-completeness.
9 Related Work
Return Oriented Programming Krahmer was the ﬁrst
to propose using borrowed code chunks [25] from the pro-
gram text to perform meaningful actions. Later, Shacham
showed in his seminal paper [41] on ROP that a set of
Turing complete gadgets can be created using the pro-
gram text of libc. Shacham developed an algorithm that
put instruction sequences into trie form to help a human
manually select useful instruction sequences.
Since then, several researchers have investigated how
to more fully automate ROP [16, 21, 38]. Dullien and
Kornau [16, 24] automatically found gadgets in mobile
support libraries (on order of 1,000KB), and Roemer [38]
demonstrated it was possible to automatically discover
gadgets in libc (1,300KB). Hund [21] used gadgets
from ntoskrnl.exe (3,700KB) and win32k.sys
(2,200KB). In contrast, our techniques often only have
20KB of binary code to create gadgets from, because
generally only small code modules are unrandomized in
user-mode exploitation contexts. Previous work focusing
on such small code bases was mostly or entirely manual;
for instance, Checkoway, et al. manually crafted a Turing
complete set of gadgets from 16KB of Z80 BIOS [9].
Automatic Exploitation Our exploit hardening system
(Section 5) is related to existing automatic exploitation
research [2, 5, 20, 26]. In automatic exploitation, the goal
is to automatically ﬁnd an exploit for a bug when given
some starting information (such as a patch [5], guiding
input [20, 26], or program precondition [2]). Some auto-
matic exploitation research focuses on creating an input
that triggers a particular vulnerability [5, 18, 26], but does
not focus on control ﬂow exploitation, which is one of the
focuses of our work. Our techniques can use the inputs
produced by these projects as an input exploit, and harden
them so that they bypass W⊕X and ASLR.
We are only aware of one other project that considers
creating an exploit given another exploit [20]; in this case
the input exploit only causes a crash. Our work uses
symbolic execution to reason about other inputs that take
the same path as the input exploit. In contrast, Heelan [20]
tracks data dependencies between the desired payload
bytes and the input bytes, but does not ensure that control
ﬂow will stay the same and preserve the observed data
dependencies. As a result, his approach is heuristic in
nature, but is likely to be faster than ours.
Related Attacks Other researchers have previously
used simple ROP gadgets in the .text section of bi-
naries to calculate the address of functions in libc [39].
Unfortunately, this is insufﬁcient to make arbitrary func-
tion calls when ASLR is enabled, because many functions
require pointers to data. Recall from Section 2 that all
modern operating systems except for Mac OS X random-
ize the stack and heap, thus making it difﬁcult for an
attacker to introduce argument data and know a pointer to
its address. QooL (Section 4.3.1) allows target programs
to write payloads to known addresses, typically in the
.data segment, which eliminates this problem.
A recent attack developed concurrently with Q [27] can
also write data to known constant memory locations, and
thus can also make arbitrary function calls in the W⊕X
and ASLR setting. This attack uses repeated strcpy
return-to-libc calls to copy data from the binary itself to
a speciﬁed location. In contrast, our attack uses ROP
gadgets discovered by Q.
There are specialized attacks against W⊕X and ASLR
14
that are only applicable inside of a browser, such as JIT
spraying [4, 43]. The downside is that they are not appli-
cable to all programs.
Related Defenses The most natural way of defeating
ROP is to randomize all executable code. For instance, we
are not able to deterministically attack position indepen-
dent executables in Linux, because we do not know where
any instruction sequences will be in memory. Operating
systems have chosen not to randomize all code in the past
because of performance and compatibility issues; these
reasons should now be reevaluated considering the new
evidence that allowing even small amounts of unrandom-
ized code can enable an attacker to use ROP payloads.
Other defenses against ROP exist. One defense is to
dynamically instrument running programs and look for
sequences of instructions that contain returns with few
instructions spaced between [10, 12]. The assumption
is that normal code will generally execute non-trivial
amounts of code in between ret instructions, whereas
ROP code will not.
A similar defense is to ensure that the call chain of a
program respects the stack semantics, i.e., that a ret will
only transfer control to a program location that previously
executed a call instruction. Such techniques [13, 37]
are implemented using a shadow stack that is maintained
outside of normal memory space. Both of these defenses
make the assumption that ROP must be performed using
the ret instruction.
Unfortunately for defenders, researchers [8] have re-
cently shown that it is possible to perform ROP on x86
without using ret instructions at all, which is enough to
bypass these schemes without modiﬁcations. However,
the proof of concept techniques required access to large
libraries, which are randomized in modern operating sys-
tems. It remains an open question whether such attacks
are possible in modern user-mode exploitation contexts,
when little unrandomized code is available.
10 Conclusion
We developed return oriented programming (ROP) tech-
niques that work on small, unrandomized code bases as
found in modern systems. We demonstrated that it is pos-
sible to synthesize ROP payloads for 80% of programs
larger than 20KB, implying that even a small amount of
unrandomized code is harmful. We also built an end-
to-end exploit hardening system, Q, that reads as input
an exploit that does not bypass defenses, and automati-
cally hardens it to one that bypasses ASLR and W⊕X.
Our techniques and experiments demonstrate that current
15
ASLR and W⊕X implementations, which allow small
amounts of code to be unrandomized, continue to allow
ROP attacks. Operating system designers should weigh
the dangers of such attacks against the performance and
compatibility penalties imposed by randomizing all code
by default.
References
[1] A. Appel. Modern Compiler Implementation in ML. Cam-
bridge University Press, 1998.
[2] T. Avgerinos, S. K. Cha, B. L. T. Hao, and D. Brumley.
AEG: Automatic exploit generation. In Proceedings of the
Network and Distributed System Security Symposium, Feb.
2011.
[3] Binary Analysis Platform (BAP). http://bap.ece.
cmu.edu.
[4] D. Blazakis. Interpreter exploitation. In Proceedings of
the USENIX Workshop on Offensive Technologies, 2010.
[5] D. Brumley, P. Poosankam, D. Song, and J. Zheng. Au-
tomatic patch-based exploit generation is possible: Tech-
niques and implications. In Proceedings of the IEEE Sym-
posium on Security and Privacy, May 2008.
[6] E. Buchanan, R. Roemer, H. Shacham, and S. Savage.
When good instructions go bad: Generalizing return-
oriented programming to RISC. In Proceedings of the
ACM Conference on Computer and Communications Se-
curity, pages 27–38, 2008.
[7] C. Cadar, D. Dunbar, and D. Engler. Klee: Unassisted and
automatic generation of high-coverage tests for complex
systems programs. In Proceedings of the USENIX Sym-
posium on Operating System Design and Implementation,
2008.
[8] S. Checkoway, L. Davi, A. Dmitrienko, A.-R. Sadeghi,
H. Shacham, and M. Winandy. Return-oriented program-
ming without returns. In Proceedings of the ACM Confer-
ence on Computer and Communications Security, 2010.
[9] S. Checkoway, J. A. Halderman, U. Michigan, A. J. Feld-
man, E. W. Felten, B. Kantor, and H. Shacham. Can DREs
provide long-lasting security? The case of return-oriented
programming and the AVC advantage. In Proceedings of
the Electronic Voting Technology Workshop/Workshop on
Trustworthy Elections, Aug. 2009.
[10] P. Chen, H. Xiao, X. Shen, X. Yin, B. Mao, and L. Xie.
DROP: Detecting return-oriented programming malicious
code. In Proceedings of the Information Systems Security
Conference, 2009.
[11] J. Clause, W. Li, and A. Orso. Dytan: a generic dynamic
taint analysis framework. In International Symposium on
Software Testing and Analysis, pages 196–206, New York,
NY, USA, 2007. ACM.
[12] L. Davi, A.-R. Sadeghi, and M. Winandy. Dynamic
integrity measurement and attestation: towards defense
against return-oriented programming attacks. In Proceed-
ings of the ACM workshop on Scalable Trusted Computing,
2009.
[13] L. Davi, A.-R. Sadeghi, and M. Winandy. ROPdefender:
a detection tool to defend against return-oriented program-
In Proceedings of the ACM Symposium
ming attacks.
on Information, Computer, and Communication Security,
2011.
[14] Debian Developers.
Debian hardening.
http:
//wiki.debian.org/Hardening?action=
recall&rev=34. Accessed: August 8th, 2010.
[15] E. Dijkstra. A Discipline of Programming. Prentice Hall,
Englewood Cliffs, NJ, 1976.
[16] T. Dullien and T. Kornau. A framework for automated
architecture-independent gadget search. In Proceedings
of the USENIX Workshop on Offensive Technologies, Aug.
2010.
[17] C. Flanagan and J. Saxe. Avoiding exponential explo-
sion: Generating compact veriﬁcation conditions. In Pro-
ceedings of the Symposium on Principles of Programming
Languages, 2001.
[18] V. Ganapathy, S. A. Seshia, S. Jha, T. W. Reps, and R. E.
Bryant. Automatic discovery of api-level exploits.
In
Proceedings of the International Conference on Software
Engineering (ICSE), May 2005.
[19] V. Ganesh and D. L. Dill. A decision procedure for bit-
vectors and arrays. In Proceedings of the Conference on
Computer Aided Veriﬁcation, pages 524–536, July 2007.
[20] S. Heelan. Automatic generation of control ﬂow hijack-
ing exploits for software vulnerabilities. Master’s thesis,
University of Oxford, 2009.
[21] R. Hund, T. Holz, and F. C. Freiling. Return-oriented
rootkits: Bypassing kernel code integrity protection mech-
anisms. In Proceedings of the USENIX Security Sympo-
sium, 2009.
[22] Intel Corporation. Intel 64 and IA-32 architectures soft-
ware developer’s manual – volume 3A: System program-
ming guide, part 1. Document number 253668, 2010.
[23] I. Jager and D. Brumley. Efﬁcient directionless weakest
preconditions. Technical Report CMU-CyLab-10-002,
Carnegie Mellon University, CyLab, Feb. 2010.
[24] T. Kornau. Return oriented programming for the arm
architecture. Master’s thesis, Ruhr-Universit¨at Bochum,
2009.
[25] S. Krahmer. x86-64 buffer overﬂow exploits and the
borrowed code chunks exploitation technique. http:
//www.suse.de/˜krahmer/no-nx.pdf, 2005.
[26] Z. Lin, X. Zhang, and D. Xu. Convicting exploitable soft-
ware vulnerabilities: An efﬁcient input provenance based
approach. In International Conference on Dependable
Systems and Networks, 2008.
[27] L. D. Long. Payload already inside: data re-use for ROP
exploits. Technical report, Blackhat, 2010.
[28] C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser,
G. Lowney, S. Wallace, V. J. Reddi, and K. Hazelwood.
Pin: Building customized program analysis tools with
In Proceedings of the ACM
dynamic instrumentation.
Conference on Programming Language Design and Imple-
mentation, June 2005.
[29] Microsoft Software Developer Network. Windows
vista ISV security. http://msdn.microsoft.com/
en-us/library/bb430720.aspx.
[30] Microsoft Support. A detailed description of the data
execution prevention (dep) feature in windows xp service
pack 2, windows xp tablet pc edition 2005, and windows
server 2003. http://support.microsoft.com/
kb/875352/EN-US/.
[31] I. Molnar. exec-shield linux patch. http://people.
redhat.com/mingo/exec-shield/.
[32] T. M¨uller. ASLR smack & laugh reference. Tech-
2008.
nical
http://www-users.rwth-aachen.de/Tilo.
Mueller/ASLRpaper.pdf.
RWTH-Aachen University,
report,
[33] J. Newsome and D. Song. Dynamic taint analysis for
automatic detection, analysis, and signature generation of
exploits on commodity software. In Proceedings of the
Network and Distributed System Security Symposium, Feb.
2005.
[34] PaX Team.
Pax address space layout randomiza-
tion (aslr). http://pax.grsecurity.net/docs/
aslr.txt.
[35] PaX Team. Pax non-executable stack (nx). http://
pax.grsecurity.net/docs/noexec.txt.
[36] A. R. Pop. DEP/ASLR implementation progress in popular
third-party windows applications. http://secunia.
com/gfx/pdf/DEP_ASLR_2010_paper.pdf,
2010. Secunia.
[37] M. Prasad and T. cker Chiueh. A binary rewriting defense
again stack-based buffer overﬂow attacks. In Proceedings
of the USENIX Annual Technical Conference, 2003.
[38] R. G. Roemer. Finding the bad in good code: Automated
return-oriented programming exploit discovery. Master’s
thesis, University of California, San Diego, 2009.
[39] G. F. Roglia, L. Martignoni, R. Paleari, and D. Bruschi.
Surgically returning to randomized lib(c). In Proceedings
of the Annual Computer Security Applications Conference,
pages 60–69, 2009.
[40] E. J. Schwartz, T. Avgerinos, and D. Brumley. All you ever
wanted to know about dynamic taint analysis and forward
symbolic execution (but might have been afraid to ask).
In Proceedings of the IEEE Symposium on Security and
Privacy, pages 317–331, May 2010.
[41] H. Shacham. The geometry of innocent ﬂesh on the bone:
Return-into-libc without function calls (on the x86). In
Proceedings of the ACM Conference on Computer and
Communications Security, 2007.
[42] H. Shacham, M. Page, B. Pfaff, E.-J. Goh, N. Modadugu,
and D. Boneh. On the effectiveness of address-space
randomization. In Proceedings of the ACM Conference on
Computer and Communications Security, pages 298–307,
2004.
[43] A. Sotirov and M. Dowd.
memory protections.
hat,
bh08sotirovdowd.pdf.
2008.
Bypassing browser
report, Black-
http://taossa.com/archive/
Technical
[44] Ubuntu Developers.
Ubuntu
security/features.
https://wiki.ubuntu.com/Security/
Features?action=recall&rev=52. Accessed:
August 8th, 2010.
16