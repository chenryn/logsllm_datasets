### 4.4. 协议分析

我们接下来将进行非正式的分析，以支持第4.1节中关于安全保证的断言。为了实现这一保证，协议必须能够抵御来自成员的篡改行为，无论这些行为是故意还是意外的故障，也包括外部入侵者的攻击。

任何试图通过生成不一致的消息内容来破坏协议运行的行为都可以被检测到。在这种情况下，提议的状态转换将被视为无效，并且会生成不可否认的不当行为证据。可以通过验证协议消息中的签名部分与未签名部分的一致性，从而检测出内部不一致的消息。由于所有消息都与其前驱消息相关联，因此可以检测到消息之间的不一致性。`Sidk` 提供了每个协议运行的唯一标签，该标签与运行中的每条消息关联。因此，可以检测到从先前运行中重放消息的任何尝试。（注意：唯一性指的是标识状态提议的元组 `Sidk`，而不是提议的状态 `Sk` —— 提议重新安装较早的状态可能是合法的。）我们现在展示如何通过协议检测其他由成员发起的篡改尝试：

- **成员遗漏发送消息**：如果 `Pk` 没有发送 `M`，那么 `Pk` 将无法证明新状态的有效性。如果 `Rk` 的成员 `Pj` 没有发送 `Mj`，则 `Pj` 虽然获得了提议的新状态，但未能提供不可否认的接收证据，也无法证明状态的有效性。如果 `Pk` 没有发送 `Mc`，则 `Pk` 将知道并可基于群体决策采取行动，但 `Rk` 中的所有成员持有证据表明协议运行仍在进行中。任何后续的协调状态尝试都将揭示状态标识符元组之间的不一致性。
  
- **选择性发送给 `Rk` 成员**：如果 `Pk` 向 `Rk` 中的不同成员发送不同的消息，则在后续的协议步骤中将检测到这种不一致性。如果 `M` 未发送给 `Rk` 的某个子集，则无法就提议状态的有效性达成一致意见，`Pk` 也无法为 `Rk` 的任何成员生成有效的 `Mc`。如果 `Mc` 未发送给 `Rk` 的某个子集，则该子集可以显示协议运行仍然活跃。此外，任何收到 `Mc` 的诚实方可以将其转发给 `Rk` 的任何其他成员。如果能保证多播语义，可以防止 `Pk` 的选择性发送。在缺乏这种保证的情况下，`Rk` 的成员可以检测到选择性发送。

- **提议空状态转换**：任何 `Rk` 的成员在收到 `M` 时，可以检测到 `ASj = Sk` 并拒绝空状态转换。

假设签名未被破解，在协议运行期间生成的不可否认证据将绑定各方对其行为（无论是好是坏）的责任，这些行为不能被错误表示。控制 `Pk` 的入侵者可以像上述那样充当不当行为方。没有任何情况可以迫使正确行为方同意（并安装）无效状态。

在 `Pk` 成员之间存在不安全通道的情况下，著名的 Dolev-Yao 入侵者（完全控制网络但无法进行密码分析）可以获得提议对象状态和关于提案决策的完整知识。此外，他们可以修改任何消息的未签名部分。这会导致不一致的消息内容（已在上文讨论）。如果 `Pk` 成员之间有安全通道，入侵者只能删除、延迟或重放消息。无论是否有安全通道，都无法在 `Pk` 成员之间不可检测地修改消息，也没有 `Pk` 成员可以被迫同意无效状态。因此，最多只能实现对协议的可检测干扰（包括因等待消息而阻塞协议运行）。

在一个协议运行结束时，一个正确行为的方将要么：(i) 能够安装一个新的有效对象状态，并持有其已被一致同意的证据；或者 (ii) 持有证据表明提议的状态转换已被否决。一个不当行为方可能在当地安装无效状态，但无法将其表示为有效状态。同样，他们也不能支持声称有效（一致同意）状态无效的说法。不当行为方可能会阻止协议运行的终止。这必须在应用层通过使用生成的证据来调用争议解决程序来解决。

### 5. B2BObjects API 和实现

本节描述了 B2BObjects API 及其中间件的原型实现。该原型是用 Java 编写的，并使用 Java RMI 进行远程调用。已开发了两个概念验证应用程序，这两个应用程序展示了两方同步协调。然而，API 和协调协议并不特定于这种操作模式。

B2BObjects API 的主要类是 B2BObject——本地对象的应用特定增强，以及 B2BObjectController——配置、启动和控制信息共享的本地接口。这些类的接口及其与 B2BCoordinator 包的关系如图4所示。协调包管理跨组织的对象连接和通信，并实现协调协议。它还提供状态检查点、证书管理和不可否认服务。

B2BObject 接口由应用程序程序员实现。程序员决定是否创建一个新的应用程序对象，该对象同时实现 B2BObject 接口和应用程序逻辑，扩展现有应用程序对象，或将对象包装在一个实现 B2BObject 接口的实现中。例如，ApplicationObject 操作：
```java
setAttribute(AType a);
```
在图4中有一个对应的 B2BObjectImpl 包装器操作，可以如下实现：
```java
setAttribute(AType a) {
    // 开始状态访问
    controller.enter();
    // 表示覆盖对象状态
    controller.overwrite();
    // 设置属性
    appObject.setAttribute(a);
    // 结束状态访问
    controller.leave();
}
```
类似地，B2BObjectImpl 的 getAttribute 包装器是：
```java
AType getAttribute() {
    // 开始状态访问
    controller.enter();
    // 表示读取对象状态
    controller.examine();
    // 获取属性
    AType attr = appObject.getAttribute();
    // 结束状态访问
    controller.leave();
    return attr;
}
```
给定应用程序对象的状态访问操作的知识，B2BObjectImpl 类的包装方法可以自动生成。如前所述，B2BObjectController 的 enter 和 leave 操作用于划定对象状态访问的范围。这些调用可以嵌套，只要每次 enter 都有一个对应的 leave。嵌套允许应用程序程序员将一系列状态更改“汇总”成单个协调事件。如果在当前状态更改范围内调用了 overwrite（如 setAttribute 示例），则在最终 leave 调用时启动状态协调。

控制器获取对象状态的副本（使用 B2BObject 的 getState 操作），并将该状态传递给协调器，以传播给远程方进行状态验证。B2BCoordinatorLocal 提供以下传播接口：
```java
public interface B2BCoordinatorLocal {
    public void propagateConnect(String coordAlias);
    public void propagateDisconnect(String subjectAlias);
    public void propagateNewState(NewStateRequest stateRequest);
    ...
    ...
}
```
调用 propagateNewState 会在远程方通过调用 validateState 对其共享对象副本进行状态验证。B2BObjectController 的 validationResponse 传达此应用程序特定验证的结果。它可以作为本地控制器上的回调同步或异步调用。如果提议的更改被所有方接受，则在每个副本上调用 applyState 安装新验证的状态。因此，leave 操作隐式地通过本地协调器调用状态协调协议，并验证或否定状态更改提议。

如果提议的更改被判定为无效，提议者的协调器将通过调用 applyState 使用之前商定的状态回滚其本地对象状态。对于对象状态的更新（而非覆盖），类似的流程适用。在这种情况下，使用 B2BObjectController 的 update 操作指示所需的状态协调类型。examine 操作表示在当前范围内将读取但不会写入对象状态。与 enter 和 leave 一起，这三个访问类型指示操作（examine、overwrite 和 update）可以用作并发控制机制和事务访问对象的挂钩。

B2BObjectController 的实现作为中间件的一部分提供。B2BObject 和 B2BObjectController 一起提供了连接管理；状态更改范围和访问类型指示；以及应用程序级别的验证回调。connect 和 disconnect 操作分别启动和断开与正在协调的对象集的连接（通过 B2BCoordinatorLocal 传播接口启动连接和断开连接协议）。validateConnect 和 validateDisconnect 允许应用程序特定验证连接和断开请求。

connect、disconnect 和 leave 的语义随通信模式而变化。在同步模式下，它们会阻塞直到相关的协调过程完成（如果验证失败则抛出异常）。在异步模式下，它们立即返回，完成信号通过协调器调用 coordCallback 发送。在延迟同步模式下，它们立即返回，可以通过调用 coordCommit 进行阻塞调用来完成。