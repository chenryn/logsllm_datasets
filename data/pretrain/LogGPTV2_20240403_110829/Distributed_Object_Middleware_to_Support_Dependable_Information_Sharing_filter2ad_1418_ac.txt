(or otherwise) of  Sk with respect to the hash sent as part
of  Sidk.
Message c is the aggregation of all decisions and of the
non-repudiation evidence in the form of signed proposals
and responses. Any party can compute the group’s decision
over  ej and . c requires no signature since
only k can produce the authenticator k. c is linked
to the other messages in the same protocol run through the
authenticator and the concatenated, signed responses.
 e’s authenticated decision on k’s proposal is:
k; ;  ej ;
 igi h ;  igj h ej
i 2 f1 : g ; j 2 f1 :  ad j 6= kg
This is non-repudiable evidence of acceptance or rejection
of a proposed state transition and of the consistency, or oth-
erwise, of the information provided during a protocol run.
A successful protocol run allows the consistent installation
of a new, validated object state at all replicas. An unsuc-
cessful run results in the consistent view that a proposed
state is invalid. In this case, the replicas remain in the state
last agreed by all parties (and the proposer can rollback to
that state).
4.4. Protocol analysis
We now present an informal analysis to support the as-
sertion of the safety guarantee in Section 4.1. To deliver the
guarantee, the protocol must withstand subversion by mem-
bers of  e, whether through deliberate or accidental fault,
as well as by intruders.
Any attempt to subvert a protocol run by generating in-
consistent message content can be detected. In which case,
the proposed state transition is invalidated and irrefutable
evidence of misbehaviour is generated. It is possible to ver-
ify that the signed parts of protocol messages are consistent
with the unsigned parts and, therefore, to detect internally
inconsistent messages. It is possible to detect inconsistency
between messages because all messages are linked to their
predecessor(s) in a protocol run.  Sidk provides a unique
label for each protocol run that is linked to each message in
the run. It is therefore possible to detect any attempt to re-
play messages from a prior run. (Note: uniqueness refers to
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:21:46 UTC from IEEE Xplore.  Restrictions apply. 
the tuple that identiﬁes a state proposal  Sidk and not to
the proposed state  Sk — it may be legitimate to propose
the re-installation of an earlier state.) We now show how the
protocol allows detection of other attempts at subversion by
members of  e:
(cid:15) A member of  e omits to send a message: If k does
not send  then, by deﬁnition, k is unable to show
that the new state is valid. If a member, j, of Rek
does not send j, then j will have obtained the pro-
posed new state without providing non-repudiable evi-
dence of its receipt but cannot demonstrate the validity
of the state. If k fails to send c, then k will know,
and can act upon, the group’s decision but all members
of Rek hold evidence that the protocol run is active.
Any subsequent attempt to coordinate state will reveal
inconsistencies between state identiﬁer tuples.
(cid:15) k selectively sends to members of Rek: If different
messages are sent to different members of Rek, then
the inconsistency will be detected in subsequent proto-
col steps. If  is not sent to a subset of Rek, then
it is not possible to reach a unanimous decision on the
validity of the proposed state and k cannot produce a
valid c for any member of Rek. If c is not sent
to a subset of Rek, then this subset can show that the
protocol run is still active. Further, any honest party
who receives c can relay it to any other member of
Rek. Selective sending by k can be prevented if
multicast semantics are guaranteed. In the absence of
such a guarantee, members of Rek can detect selec-
tive sending.
(cid:15) k proposes a null state transition: On receipt of 
any member of Rek can detect that ASj =  Sk and
can reject a null state transition.
Assuming signatures are not compromised,
the non-
repudiation evidence generated during a protocol run binds
a party to their actions (good or bad) and those actions can-
not be misrepresented. An intruder in control of a member
of  e can act as a misbehaving party as outlined above.
In no case can a correctly behaving party be forced to agree
(and install) an invalid state.
With insecure channels between members of  e, the
well-known Dolev-Yao intruder [7] (who has full control
over the network but cannot perform cryptanalysis) can ob-
tain complete knowledge of proposed object state and of
decisions with respect to proposals. In addition, they are
able to modify the unsigned parts of any message. This
results in inconsistent message content (dealt with above).
Given secure channels between members of  e, this in-
truder can only remove, delay or replay messages. With or
without secure channels, it is not possible to undetectably
modify messages between members of  e and no mem-
ber of  e can be forced to agree invalid state. Thus the
most that can be achieved is the detectable disruption of the
protocol (including the blocking of a protocol run pending
receipt of messages).
At the end of a protocol run a correctly behaving party
will either: (i) be able to install a new, valid object state, and
hold evidence that it has been unanimously agreed; or (ii)
hold evidence that the proposed state transition has been ve-
toed. A misbehaving party may locally install invalid state
but is not able to misrepresent it as valid. Similarly, they
cannot support a claim that valid (unanimously agreed) state
is invalid. A misbehaving party may prevent termination of
a protocol run. This must be resolved at the application
level by, for example, using the evidence generated to in-
voke a dispute resolution procedure.
5. B2BObjects API and implementation
This section describes the B2BObjects API and a pro-
totype implementation of the middleware. The prototype
is written in Java using Java RMI for remote invocation.
Two proof-of-concept applications have been developed us-
ing the prototype. Both applications illustrate two-party,
synchronous coordination. However, neither the API, nor
coordination protocols, are speciﬁc to this mode of opera-
tion.
The primary B2BObjects API classes are B2BObject —
the application-speciﬁc augmentation of a local object, and
B2BObjectController — the local interface to conﬁgura-
tion, initiation and control of information sharing. The in-
ApplicationObject
+getAttribute()
+setAttribute()
+............()
1
1
B2BObjectImpl
+getAttribute()
+setAttribute()
+............()
1
1
«interface»
B2BObject
+setController()
+connect()
+disconnect()
+syncCoord()
+getState()
+getUpdate()
+validateConnect()
+validateDisconnect()
+validateState()
+validateUpdate()
+applyState()
+applyUpdate()
+coordCallback()
«interface»
B2BObjectController
+connect()
+disconnect()
+syncCoord()
+enter()
+examine()
+overwrite()
+update()
+leave()
+validationResponse()
1
B2BObjectControllerImpl
«package»
B2BCoordinatorLocal
B2BCoordinator
inter-enterprise coord.
cert. mgt & non-repudiation
state checkpointing
B2BCoordinatorRemote
A
B
A
B
1
A
B
A interface
A implements B
A is component of B
A depends on B
A exports "interface"
Figure 4. B2BObjects API
terfaces to these classes and the relationship between them
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:21:46 UTC from IEEE Xplore.  Restrictions apply. 
and the B2BCoordinator package are shown in Figure 4.
The coordinator package manages inter-organisational con-
nection to and communication between objects, and imple-
ments coordination protocols. It also provides state check-
pointing, certiﬁcate management and non-repudiation ser-
vices.
The B2BObject interface is implemented by the appli-
cation programmer. The programmer decides whether to
produce a new application object that implements both the
B2BObject interface and the application logic, or to extend
an existing application object, or to wrap the object with an
implementation of the B2BObject interface. For example,
the ApplicationObject operation:
setAttribute(AType a);
shown in Figure 4 has a corresponding B2BObjectImpl
wrapper operation that could be implemented as follows:
setAttribute(AType a) {
// start of state access
controller.enter();
// indicate overwriting object state
controller.overwrite();
// set the attribute
appObject.setAttribute(a);
// end of state access
controller.leave();
}
Similarly, the B2BObjectImpl getAttribute wrapper
is:
AType getAttribute() {
// start of state access
controller.enter();
// indicate reading object state
controller.examine();
// get the attribute
AType attr = appObject.getAttribute();
// end of state access
controller.leave();
return attr;
}
Given knowledge of an application object’s state access
operations,
the wrapper methods of a B2BObjectImpl
class could be generated automatically. As indicated, the
B2BObjectController enter and leave operations are
used to demarcate the scope of access to object state. These
calls may be nested provided that a leave is invoked for
each enter. Nesting allows the application programmer to
“roll-up” a series of state changes into a single coordination
event. If overwrite has been called within the current
state change scope (as in the setAttribute example),
then state coordination is initiated at invocation of the ﬁnal
leave, as we describe now.
The controller obtains a copy of the object’s state (us-
ing the B2BObject getState operation) and passes that
state to the coordinator for propagation to remote parties
for state validation. B2BCoordinatorLocal provides the fol-
lowing propagation interface :
public interface B2BCoordinatorLocal {
public void propagateConnect(String
coordAlias);
public void propagateDisconnect(String
subjectAlias);
public void propagateNewState(
NewStateRequest stateRequest);
...
...
}
A call to propagateNewState results in state val-
idation at the remote parties via invocation of vali-
dateState on their copy of the shared object. The
B2BObjectController validationResponse commu-
nicates the result of this application-speciﬁc validation. It
can be invoked synchronously or asynchronously as a call-
back on the local controller. If a proposed change is ac-
cepted by all parties, an applyState call on each replica
installs the newly validated state. Thus the leave opera-
tion implicitly invokes the state coordination protocol, via
the local coordinator, and the validation, or otherwise, of
a state change proposal.
If a proposed change is invali-
dated, the proposer’s coordinator will rollback their local
object state using a call to applyState with the previ-
ously agreed state. A similar process to that outlined ap-
plies to update, as opposed to overwrite, of object state.
In this case, the B2BObjectController update operation
is used to indicate the type of state coordination required.
The examine operation indicates that object state will be
read but not written in the current scope. Together with
enter and leave, the three access type indication opera-
tions (examine, overwrite and update) can be used
as hooks for concurrency control mechanisms and transac-
tional access to objects.
The implementation of the B2BObjectController is pro-
vided as part of the middleware. Together, B2BObject
and B2BObjectController provide connection management;
state change scoping and access type indication; and up-
calls for application-level validation. connect and dis-
connect operations initiate connection to and discon-
nection from the set of objects being coordinated (lead-
ing to initiation of connection and disconnection proto-
cols via the B2BCoordinatorLocal propagation interface).
validateConnect and validateDisconnect al-
low application-speciﬁc validation of connection and dis-
connection requests.
The semantics of connect, disconnect and leave
vary with the communication mode. In synchronous mode,
they block until the relevant coordination process completes
(an exception is raised if validation fails). In asynchronous
mode, they return immediately and completion is signalled
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:21:46 UTC from IEEE Xplore.  Restrictions apply. 
by the coordinator through invocation of coordCall-
back. In deferred synchronous mode they return immedi-
ately and a blocking call to coordCommit can be used to