整个函数的结构是switch
case，通过宏`Z_TYPE_P`解析struc变体的类型(此宏展开为struc->u1.v.type)，来判断要序列化的类型，从而进入相应的CASE部分进行操作。下图为类型定义。
根据上图红框中的数字8，我们可知此时需要要序列化为一个对象`IS_OBJECT`，进入相应的CASE分支
我们在上图中看到了魔法函数`__sleep`的调用时机，因为我们写的Demo中并没有此函数，所以流程并不会进入此分支。不同的分支代表不同的处理流程，我们稍后再看带有魔法函数`__sleep`的流程。
因上面`case
IS_OBJECT`分支中没有流程命中，case中又没有break语句，继续执行进入`IS_ARRAY`分支，在这里从struc结构中提取出类名，计算其长度并赋值到buf结构中，并提取出类中要序列化的结构存入哈希数组中。
接下来就是利用`php_var_serialize_intern`函数递归解析整个哈希数组的过程，从中分别提取出变量名和值进行格式解析并将解析完成的字符串拼接到buf结构中。最后当整个过程结束后，整个字符串讲完全存进柔性数组结构buf中。
从上图红框中可看出跟最终结果是相吻合的。我们接下来稍微修改下Demo，添加魔法函数`__sleep`，根据官方文档中描述，`__sleep`函数必须返回一个数组。我们并在该函数中调用了一个类的成员函数。观察其具体行为。
前面流程完全相同，此处不再重复，我们从分支点开始看。
我们直接跟进`php_var_serialize_call_sleep`函数。
我们这里继续跟进`call_user_function`，根据宏定义，它实际上是调用了`_call_user_function_ex`函数，在这里做了一些拷贝动作，故不做截图，流程接下来进入`zend_call_function`函数的调用。
函数`zend_call_function`中，实际情况下，在`__sleep`中需要做一些我们自己的事情，这里PHP将要做的操作压入PHP自己的`zend_vm`引擎堆栈中，稍后会进行一条条解析(就是解析相应的OPCODE)。
这里流程会命中此分支，我们跟进`zend_execute_ex`函数。
我们这里可以看到在`ZEND_VM`中，整体体处理流程为while(1)循环，不断解析ZEND_VM栈中的操作。上图红框中ZEND_VM引擎会利用`ZEND_FASTCALL`方式派发到到相应的处理函数。
因为我们在`__sleep`中调用了成员函数show,这里首先定位出了show，接着会将接下来的操作继续压入`ZEND_VM`堆栈中进行下一轮新的解析(这里是处理show中的操作)，直到解析完整个操作为止。我们这里不再继续跟进。
还记得上面的传出参数retval么，也就是`__sleep`的返回值，上图为返回数组的第一个元素x，当然你也可以从变量中直接查看。
绕了这么大一圈，殊途同归，在处理完`_sleep`函数中的一系列操作之后，接下来用`php_var_serialize_class`函数来序列化类名，递归序列化其`_sleep`函数返回值中的结构。最终都把结果存在了buf结构中。至此序列化的整个流程完毕。
##### 3.1.1 SERIALIZE流程小结。
我们总结下序列化的流程 ：
当没有魔法函数时，序列化类名–>利用递归序列化剩下的结构
当存在魔法函数时，调用魔法函数`__sleep`–>利用ZEND_VM引擎解析PHP操作—>返回需要序列化结构的数组–>序列化类名–>利用递归序列化`__sleep`的返回值结构。
#### 3.2 unserialize源码分析
看完serialize的流程，接下来，我们还是从最简单的一个Demo来看unserialize流程。此例子不含魔法函数。
方法跟上面相同，unserialize源码也在var.c文件中。
上图中涉及到了PHP7中的新特性，带过滤的反序列化，根据`allowed_classes`的设置情况来过滤相应的PHP对象，防止非法数据注入。被过滤的对象会被转化成`__PHP_Incomplete_Class`对象不能被直接使用，但是这里对反序列化流程没有影响，这里不做详细探讨。我们跟进`php_var_unserialize`函数。
我们这里继续跟入`php_var_unserialize_internal`函数。
此函数内部主要操作流程为对字符串进行解析，然后跳转到相应的处理流程。上图中解析出第一个字母0，代表此次反序列化为一个对象。
这里首先会解析出对象名字，并进行查表操作确定此对象确实存在，我们继续向下看。
上述操作做完之后，我们这里根据对象名称new出了自己新的对象并进行了初始化，但是我们的反序列化操作还是没有完成，我们跟进`object_common2`函数。
在这里我们看到了对魔法函数的判断与检测，但是调用部分并不在此。我们继续跟进process_nested_data函数。
看来这个函数利用WHILE循环来嵌套解析剩余的部分了，·其中包含两个`php_var_unserialize_internal`函数，第一个会解析名称，第二个是解析名称所对应的值。`process_nested_data`函数运行完毕后，字符串解析完毕，反序列化操作主要内容已经完成，流程即将进入尾声了。
逐层返回至最初的函数PHP_FUNCTION中，我们看到就是一些扫尾工作了，释放申请的空间，反序列化完毕。这里并没有调用到我们的魔法函数`__wakeup`。为了找出`__wakeup`的调用时机，我们这里修改下Demo。
这里开始新的一轮调试。发现在序列化完成后，在`PHP_VAR_UNSERIALIZE_DESTROY`释放空间处出现了我们所希望看到的调用。
还记得反序列化流程中当发现有`__wakeup`时对其进行的`VAR_WAKEUP_FLAG`标志么，在这里当遍历`bar_dtor_hash`数组遇到这个标志时，正式开启对`__wakeup`调用，后期的调用手法和前面所介绍的`__sleep`调用手法完全相同，这里不再做重复说明。至此，反序列化所有流程完毕。
##### 3.2.1 UNSERIALIZE流程小结。
我们可以从上面可以看到，反序列化流程相对于序列化流程来说并没有因为是否出现魔法函数来对流程造成分歧。Unserialize流程如下：
获取反序列化字符串–>根据类型进行反序列化—>查表找到对应的反序列化类–>根据字符串判断元素个数–>new出新实例–>迭代解析化剩下的字符串–>判断是否具有魔法函数__wakeup并标记—>释放空间并判断是否具有具有标记—>开启调用。
### 四、 PHP反序列化漏洞
有了上面源码基础的铺垫，我们现在再来探究漏洞CVE-2016-7124(绕过`__wakeup`)魔法函数。因此漏洞对版本有一定要求，我们使用上面编译好的另一个PHP版本(5.6.10)来复现和调试此漏洞。
首先我们进行一下漏洞复现：
我们这里可以看到，TEST类中只包含一个元素$a，我们这里在反序列化时当修改元素字符串中代表元素个数的数值时，会触发此漏洞，该类避过了魔法函数`__wakeup`的调用。
当然在触发漏洞的过程中也发现了一个有趣的现象，触发手段并不只有这一种.
上图中4个payload所对应的反序列化操作都会触发此漏洞。虽然说下方这四个都会触发漏洞，但是其中还有一些微小的差别。这里我们稍微修改下代码：
我们根据上图可以看到，在反序列化的字符串中，只要在解析类中的元素出现错误时，都会触发此漏洞。但是更改类元素内部操作(如上图的修改字符串长度，类变量类型等)会导致类成员变量赋值失败。只有修改类成员的个数(比原有成员个数大)时，才能保证类成员赋值时成功的。
我们下面来通过调试来看问题所在：
根据第三部分我们对反序列化源码的分析，猜测可能是在最后解析变量那里出了问题。我们这里直接上调试器动态调试下：
我们可以看到，与7.3.0版本的源码对比，此版本没有过滤参数，且经过这么多版本的迭代，低版本的处理过程现在看来也相对简略。但是整体谐逻辑并没有改变，我们这里直接跟进`php_var_unserialize`函数，此后相同逻辑不再进行重复说明，我们直接跟到差异处(object_common2函数)也就是处理类中成员变量的代码
在函数`object_common2`中，存在两个主要操作，`process_nested_data`迭代解析类中的数据和魔法函数`__wakeup`的调用，且当`process_nested_data`函数解析失败后，直接返回0值，后面的`__wakeup`函数将没有调用的机会。
这里就解释了为何触发漏洞不止一种payload。
当只修改类成员的个数时，while循环可以完成的进行一次，这使得我们类中成员变量能被完整的赋值。当修改成员变量内部时，`pap_var_unserialize`函数调用失败，紧接着会调用`zval_dtor`
和`FREE_ZVAL`函数释放当前key(变量)空间，导致类中的变量赋值失败。
反观在PHP7.3.0版本中此处并没有出现调用过程，只是做了简单的标记，整个魔法函数的调用过程的时机移至释放数据处。这样就避免了这个绕过的问题。
此漏洞应该属于逻辑上的缺陷导致的。
* * *