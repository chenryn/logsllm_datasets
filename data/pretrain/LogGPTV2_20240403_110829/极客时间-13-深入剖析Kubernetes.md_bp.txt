# 在 node-1 上$ ls /mnt/disks/vol1test.txt而如果你重新创建这个 Pod的话，就会发现，我们之前创建的测试文件，依然被保存在这个持久化 Volume当中：    $ kubectl delete -f local-pod.yaml  $ kubectl create -f local-pod.yaml  $ kubectl exec -it example-pv-pod -- /bin/sh
# ls /usr/share/nginx/html
# touch test.txt这就说明，像 Kubernetes 这样构建出来的、基于本地存储的Volume，完全可以提供容器持久化存储的功能。所以，像 StatefulSet这样的有状态编排工具，也完全可以通过声明 Local 类型的 PV 和PVC，来管理应用的存储状态。**需要注意的是，我们上面手动创建 PV 的方式，即 Static 的 PV管理方式，在删除 PV 时需要按如下流程执行操作：**1.  删除使用这个 PV 的 Pod；2.  从宿主机移除本地磁盘（比如，umount 它）；3.  删除 PVC；4.  删除 PV。如果不按照这个流程的话，这个 PV 的删除就会失败。当然，由于上面这些创建 PV 和删除 PV 的操作比较繁琐，Kubernetes其实提供了一个 Static Provisioner 来帮助你管理这些 PV。比如，我们现在的所有磁盘，都挂载在宿主机的 /mnt/disks 目录下。那么，当 Static Provisioner 启动后，它就会通过DaemonSet，自动检查每个宿主机的 /mnt/disks 目录。然后，调用 KubernetesAPI，为这些目录下面的每一个挂载，创建一个对应的 PV对象出来。这些自动创建的 PV，如下所示：    $ kubectl get pvNAME                CAPACITY    ACCESSMODES   RECLAIMPOLICY   STATUS      CLAIM     STORAGECLASS    REASON    AGElocal-pv-ce05be60   1024220Ki   RWO           Delete          Available             local-storage             26s $ kubectl describe pv local-pv-ce05be60 Name:  local-pv-ce05be60...StorageClass: local-storageStatus:  AvailableClaim:  Reclaim Policy: DeleteAccess Modes: RWOCapacity: 1024220KiNodeAffinity:  Required Terms:      Term 0:  kubernetes.io/hostname in [node-1]Message: Source:    Type: LocalVolume (a persistent volume backed by local storage on a node)    Path: /mnt/disks/vol1这个 PV 里的各种定义，比如 StorageClass的名字、本地磁盘挂载点的位置，都可以通过 provisioner的[配置文件指定](https://github.com/kubernetes-incubator/external-storage/tree/master/local-volume/helm)。当然，provisioner也会负责前面提到的 PV 的删除工作。而这个 provisioner 本身，其实也是一个我们前面提到过的[ExternalProvisioner](https://github.com/kubernetes-incubator/external-storage/tree/master/local-volume)，它的部署方法，在[对应的文档里](https://github.com/kubernetes-incubator/external-storage/tree/master/local-volume#option-1-using-the-local-volume-static-provisioner)有详细描述。这部分内容，就留给你课后自行探索了。
## 总结在今天这篇文章中，我为你详细介绍了 Kubernetes 里 Local Persistent Volume的实现方式。可以看到，正是通过 PV 和 PVC，以及 StorageClass这套存储体系，这个后来新添加的持久化存储方案，对 Kubernetes已有用户的影响，几乎可以忽略不计。作为用户，你的 Pod 的 YAML 和 PVC 的YAML，并没有任何特殊的改变，这个特性所有的实现只会影响到 PV的处理，也就是由运维人员负责的那部分工作。而这，正是这套存储体系带来的"解耦"的好处。其实，Kubernetes 很多看起来比较"繁琐"的设计（比如"声明式API"，以及我今天讲解的"PV、PVC体系"）的主要目的，都是希望为开发者提供更多的"可扩展性"，给使用者带来更多的"稳定性"和"安全感"。这两个能力的高低，是衡量开源基础设施项目水平的重要标准。
## 思考题正是由于需要使用"延迟绑定"这个特性，Local Persistent Volume目前还不能支持 Dynamic Provisioning。你是否能说出，为什么"延迟绑定"会跟Dynamic Provisioning 有冲突呢？感谢你的收听，欢迎你给我留言，也欢迎分享给更多的朋友一起阅读。![](Images/e870b7df0db49509e735e6becd4a9a9a.png){savepage-src="https://static001.geekbang.org/resource/image/47/55/47a6f3bf6b92d58512d5a2ed0a556f55.jpg"}