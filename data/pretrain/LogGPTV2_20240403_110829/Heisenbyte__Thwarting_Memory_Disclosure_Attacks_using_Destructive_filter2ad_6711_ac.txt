location of the relocated data. Relying on the relocation ta-
bles allows us to transparently move bytes around within a
PE ﬁle without breaking the functionality of the program.
Overcoming Windows binary protection To evalu-
ate our rewritten Windows native library ﬁles with Heisen-
byte, we need to replace the original ﬁles. However, on Win-
dows, critical shared libraries and program binaries are pro-
tected by a mechanism called Windows Resource Protection
(WRP) [17]. WRP prevents unauthorized modiﬁcation of
essential library ﬁles, folders and registry entries by conﬁg-
uring the Access Control Lists (ACLs) for these protected
resources. Only the Windows Installer service, TrustedIn-
staller, has full permissions to these resources.
To get around this problem, we rely on the fact that we
have administrative privileges on the system. We take con-
trol of the ownership of the protected ﬁles from the Truste-
dInstaller account using the command takeown.exe, and
grant to our account full access rights for the protected ﬁles
using icacls.exe. At this point, we can rename the ﬁles
but we cannot replace the ﬁles because they are still in use.
We rename the ﬁles and copy our rewritten binaries with
the original ﬁlename. When the system is rebooted, our
rewritten libraries will be then loaded into the system. To
ensure integrity of the binaries, the modiﬁed ACLs of the
protected binaries are restored after the rewritten binaries
are replaced.
This technique of deploying rewritten Windows native
ﬁles work for most of the binaries with one exception – nt-
dll.dll. The integrity of this ﬁle is veriﬁed when the system
starts up. We solve this by disabling the boot-time integrity
Figure 5: Nested paging structure using virtualiza-
tion hardware support (using Intel-speciﬁc terms).
in the bootloader [11], so that the rewritten ntdll.dll bi-
nary can be loaded.
4.2 Heisenbyte Core Monitoring Components
4.2.1 Review of Intel Extended Page Tables (EPT)
Before we discuss each of the components in the two modes,
we ﬁrst describe the key hardware virtualization feature we
use to achieve our goals.
Heisenbyte needs to be able to detect when executable
memory is being read. There are a number of ways to do
this: mediating at the page fault handler [2] or leveraging the
split-TLB microarchitecture of systems [10]. These solutions
stem from the limitation of current OSes not being able to
enforce execute-only permissions on memory pages. Fortu-
nately, hardware virtualization support – hardware-assisted
nested paging – on commodity processors provides a means
for us to enforce ﬁne-grained execute-only permissions on
memory pages. This hardware feature augments existing
page walking hardware with the ability to traverse in hard-
ware the paging structures mapping guest physical (P) to
host machine (M) addresses. This eliminates the overhead
involved in maintaining shadow page tables using software.
A virtualization-enabled MMU maps virtual (V) addresses
in the guest to machine physical addresses in the host, using
both the guest page tables and the host second-level page
tables4. This is done transparently of the guest OS.
We show three address spaces spanning across the guest
and host modes in Figure 5. In the guest, the page tables
store the V→P address mappings, as well as the correspond-
ing permission bits. These guest page tables, described ear-
lier, cannot be conﬁgured with solely the execute bit set.
Conversely, in the host, the EPTs maintain the P→M ad-
dress mappings. The key diﬀerence between the EPTs and
guest page tables is that the EPTs can conﬁgure each page
mapping as execute-only. When an access to a memory page
violates the permissions conﬁgured for that page, an #EPT
violation is invoked, transferring control to the hypervisor.
This mechanism is instrumental in our system to detect
read operations to executable memory.
In our work, like
Readactor [5], we rely on hardware-assisted EPT to conﬁg-
ure guest physical memory pages as execute-only with no
read or write access. Since this is a virtualization-assisted
technology, virtualization has to be enabled on the system
4Intel terms this Extended Page Tables(EPT), and AMD
calls this Nested Page Tables (NPT)
Guest Virtual (V) Addr SpaceCodeDataGuest Physical (P)Addr SpaceHost Machine (M)Addr SpaceCodeDataCodeDataGUESTGuest Page TablesV         PHost EPTP         MHOST __XR_XRW_RW_we are trying to protect. On systems that need to protect
existing virtualized guests, Heisenbyte can be implemented
within the Virtual Machine Monitor (VMM) software, such
as Xen or KVM. However, the need for virtualization does
not preclude the protection of non-virtualized systems.
To demonstrate this, we make a conscientious eﬀort to
implement Heisenbyte for a non-virtualized OS. We develop
Heisenbyte as a Windows driver that will conﬁgure the EPT
paging structures, enable virtualization mode and place the
execution of the non-virtualized OS into virtualized guest
mode (non-root VMX mode). Heisenbyte does this on a
live running system, without requiring any system reboot.
The host mode component (shown in Figure 6) of our driver
ensures that the running system functions as usual, by con-
ﬁguring the EPT structures to use identity mappings from
the guest physical to host machine addresses. At this point,
our host mode component is in a position to conﬁgure the
execute-only permissions transparently of the guest OS.
4.2.2 Identifying Executable Memory
Before we can conﬁgure the EPT execute-only permis-
sions, we need to ﬁrst identify which executable memory
pages to monitor. To do that, we have to track when and
where executable memory from processes are loaded and
mapped. Since the treatment of dynamic code tracking is
more involved, we will describe them in detail separately.
Static program binaries To deal with static code,
Heisenbyte guest mode component (as shown in Figure 6) be-
gins its initialization by registering Windows kernel-provided
callback functions associated with the creation/exiting of
processes and loading/unloading of shared libraries. Us-
ing the callback registration APIs, PsSetCreateProcessNo-
tifyRoutine and PsSetLoadImageNotify, our driver guest
component is informed whenever a new static code process
or library gets loaded. This callback mechanism applies to
both executable ﬁles and shared library ﬁles.
If a newly
loaded static image matches within a whitelist of binaries
we are protecting, our guest mode component parses the
memory-mapped PE header to get the list of guest virtual
addresses and sizes of the executable sections in each loaded
image.
With the guest virtual addresses, we need to retrieve the
corresponding guest page table and guest physical addresses
for each virtual memory page to conﬁgure the EPT entries.
However, since the OS performs a lazy allocation when do-
ing the memory mapping, these memory pages may not be
paged into memory yet. As a workaround, Heisenbyte sched-
ules a thread within the context of the target process and ac-
cesses one byte in each memory page to invoke the paging-in
mechanism. Further, Heisenbyte uses the MmProbeAndLock-
Pages kernel API to make the pages resident in the physical
memory, so that they cannot be paged out. This necessarily
increases the memory working set of a program. We will
investigate this in § 5.2.2.
These information is stored in a queue buﬀer shared by
the guest mode and host mode components. It is notewor-
thy that since the guest mode component runs in the VMX
non-root guest mode, it has no access to the EPTs. The
conﬁguration of the EPT mappings has to be performed by
the host mode component.
Dynamic JIT code Unlike the loading of static binaries
into memory, dynamic memory buﬀer creation/freeing does
not have convenient kernel-provided callbacks. Furthermore,
Figure 6: Overview of system architecture (Heisen-
byte components are shaded grey).
the protection bits of a dynamic buﬀer may change at run-
time during the generation and execution of dynamic code.
For example, a modern JIT-enabled browser, like Safari, ﬁrst
allocates a writable (read/write RW) buﬀer as a code cache
to ﬁll with generated native code. With our assumption that
hardware W⊕X DEP is enforced, the JIT engine has to re-
move the writable permission and make the code cache exe-
cutable (read/execute RX) before executing the code cache.
If the dynamic code cache subsequently needs to be mod-
iﬁed, the buﬀer is restored to a writable (read/write RW)
one before changes to the code cache can be made.
Based on the lifetime of the buﬀer during which the code
is ready to be executed, we observe that we only need to
monitor the buﬀer during this period of time. Speciﬁcally,
we begin tracking a dynamic buﬀer when the protection bits
changes from non-executable to executable, and stop track-
ing a dynamic executable buﬀer when it is freed or when its
executable bit is removed.
Windows-speciﬁc implementation Next we discuss
how we detect when dynamic memory buﬀers are turned
executable and when they are freed. All operations that
are used to free or change protection bits of memory result
in two functions in ntdll.dll, NtFreeVirtualMemory, and
NtProtectVirtualMemory respectively, just before invoking
the system calls to the kernel services. When ntdll.dll is
loaded into our target process, we modify the entry points of
these two functions with trampolines to a Virtual Memory
(VM)-tracking code that resides on a dynamically allocated
page. Since the function hooking is performed in-memory,
the OS Copy-on-Write mechanism ensures that these hooks
only apply to the target process.
In practice, dynamic memory buﬀers are created and freed
very frequently. Since we are only interested in executable
buﬀers, we use an auxiliary bitmap data page to indicate if
an executable buﬀer of a given virtual address has been pre-
viously tracked. This added optimization enables the VM-
tracking code to decide if it should handle speciﬁc events.
The VM-tracking code that monitors the changing of pro-
tection bits of buﬀers performs a hypercall to our host mode
component whenever an executable buﬀer is conﬁgured to be
non-executable and vice versa. The host mode component
updates the address bitmap depending on whether a new
executable page is being tracked or removed from tracking.
Conversely, the VM-tracking code that monitors the freeing
of executable buﬀers will perform a hypercall when it de-
termines from the bitmap that a buﬀer with a given virtual
address is being freed. The host mode component will then
Heisenbyte.relocRelocateddata.relocOriginal program binaryEPTRewrittenbinaryOﬄine AnalysisStatic binary rewriterGuest modecomponentHost modecomponentGuest page tablesGuest KernelHostGuest UserLoadedapplicationLive Target SystemIDA Proreset the EPT mapping for the physical pages of the buﬀer
to an identity mapping, essentially stopping the tracking of
this dynamic executable buﬀer.
Protecting VM-tracking code and data The VM-
tracking code resides on a dynamically allocated executable
page, and is protected by Heisenbyte just like any typical
executable memory page. Conversely, by being conﬁgured
to be read-only from the userspace, the auxiliary bitmap is
protected from any tampering attacks originating from the
userspace; it can only be modiﬁed in the host kernel mode
(speciﬁcally by the host mode driver component. Further-
more, a XOR-based checksum of the bitmap is maintained
and veriﬁed before the bitmap is updated in the host mode
component.
4.2.3 Overcoming Challenges in using EPT
Problem of shared physical memory pages One key
challenge in using EPT to enforce execute-only memory is
that the guest physical memory pages may be shared by mul-
tiple processes due to the OS’s Copy-on-Write (COW) opti-
mization. This COW mechanism is a common OS optimiza-
tion applied to static binaries to conserve physical memory
and make the startup of programs faster. Thus the OS lazily
duplicates the original page into a newly allocated physical
page only when the process writes to the memory page. Be-
fore these physical memory pages are duplicated by COW,
they are shared by multiple processes. Enforcing execute-
only permissions on these shared guest physical pages may
result in many #EPT violations triggered by processes we do
not care about and cause unnecessary overhead.
Inducing COW on physical pages Heisenbyte over-
comes this problem by inducing COW on the executable
memory pages of target processes. We leverage the guest
OSes’ innate COW capability to transparently allocate new
physical memory pages for the static code regions of pro-
cesses we want to protect. To invoke COW on the memory
pages of processes, the write operation must occur in the
context of the process; a write operation originating from
the hypervisor into the memory space of a user process will
not trigger the copy-on-write mechanism.
When a static binary is loaded into memory, Heisenbyte
schedules an Asynchronous Procedure Call thread [16] to
execute in the context of the target process. This thread
suspends the execution of the original target process, enu-
merates the static code regions of the process using the
PE headers mapped in the address space, and performs a
read and write operation on each executable memory page.
This identity-write operation is very eﬃcient since we only
“touch” one byte in each 4kB memory page. The OS detects
this memory write and invokes the COW mechanism.
In
this manner, each executable static page in a process will no
longer share a physical page with another process.
The executable memory pages are then conﬁgured to be
read-only using EPT by the host mode component only after
the COW-inducing thread has completed processing all the
executable memory pages of the newly loaded binary.
Intervention with Code Garbling
4.2.4
Maintaining separate code views To enable our de-