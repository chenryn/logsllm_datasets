### Location of the Relocated Data
Relying on relocation tables allows us to transparently move bytes within a PE file without compromising the program's functionality.

### Overcoming Windows Binary Protection
To evaluate our rewritten Windows native library files with Heisenbyte, we need to replace the original files. However, critical shared libraries and program binaries on Windows are protected by Windows Resource Protection (WRP) [17]. WRP prevents unauthorized modifications of essential library files, folders, and registry entries by configuring Access Control Lists (ACLs) for these protected resources. Only the Windows Installer service, TrustedInstaller, has full permissions to these resources.

To overcome this, we leverage administrative privileges on the system. We use `takeown.exe` to take ownership of the protected files from the TrustedInstaller account and `icacls.exe` to grant our account full access rights to these files. At this point, we can rename the files but cannot replace them because they are still in use. We rename the files and copy our rewritten binaries with the original filenames. After a system reboot, our rewritten libraries will be loaded into the system. To ensure the integrity of the binaries, the modified ACLs of the protected binaries are restored after the rewritten binaries are replaced.

This technique works for most binaries, with one exception: `ntdll.dll`. The integrity of this file is verified at system startup. We solve this by disabling the boot-time integrity check in the bootloader [11], allowing the rewritten `ntdll.dll` binary to be loaded.

### 4.2 Heisenbyte Core Monitoring Components

#### 4.2.1 Review of Intel Extended Page Tables (EPT)
Before discussing the components in the two modes, we first describe the key hardware virtualization feature used to achieve our goals.

Heisenbyte needs to detect when executable memory is being read. This can be done through page fault handlers [2] or by leveraging the split-TLB microarchitecture of systems [10]. These solutions address the limitation of current operating systems not being able to enforce execute-only permissions on memory pages. Fortunately, hardware virtualization support, specifically hardware-assisted nested paging, provides a way to enforce fine-grained execute-only permissions on memory pages. This feature enhances existing page walking hardware, allowing it to traverse the paging structures that map guest physical (P) to host machine (M) addresses. This eliminates the overhead of maintaining shadow page tables using software.

A virtualization-enabled MMU maps virtual (V) addresses in the guest to machine physical addresses in the host, using both the guest page tables and the host second-level page tables. This is done transparently to the guest OS.

Figure 5 shows three address spaces spanning across the guest and host modes. In the guest, the page tables store V→P address mappings and corresponding permission bits. These guest page tables cannot be configured with only the execute bit set. Conversely, in the host, the EPTs maintain P→M address mappings. The key difference is that EPTs can configure each page mapping as execute-only. When an access to a memory page violates the permissions, an #EPT violation is triggered, transferring control to the hypervisor. This mechanism is crucial for detecting read operations to executable memory.

In our work, like Readactor [5], we use hardware-assisted EPT to configure guest physical memory pages as execute-only with no read or write access. This requires virtualization to be enabled on the system. For systems with existing virtualized guests, Heisenbyte can be implemented within the Virtual Machine Monitor (VMM) software, such as Xen or KVM. However, virtualization is not necessary for non-virtualized systems.

To demonstrate this, we implement Heisenbyte as a Windows driver that configures EPT paging structures, enables virtualization mode, and places the execution of the non-virtualized OS into virtualized guest mode (non-root VMX mode). This is done on a live running system without requiring a reboot. The host mode component ensures the system functions normally by configuring EPT structures to use identity mappings from guest physical to host machine addresses. This allows the host mode component to configure execute-only permissions transparently to the guest OS.

#### 4.2.2 Identifying Executable Memory
Before configuring EPT execute-only permissions, we need to identify which executable memory pages to monitor. We track when and where executable memory from processes is loaded and mapped. Static program binaries are handled by registering Windows kernel-provided callback functions associated with process creation/exiting and loading/unloading of shared libraries. Using `PsSetCreateProcessNotifyRoutine` and `PsSetLoadImageNotify`, our driver is informed whenever a new static code process or library is loaded. If a newly loaded static image matches a whitelist of binaries we are protecting, our guest mode component parses the memory-mapped PE header to get the list of guest virtual addresses and sizes of the executable sections in each loaded image.

With the guest virtual addresses, we retrieve the corresponding guest page table and guest physical addresses for each virtual memory page to configure the EPT entries. Since the OS performs lazy allocation during memory mapping, these pages may not be paged into memory yet. As a workaround, Heisenbyte schedules a thread within the context of the target process to access one byte in each memory page, invoking the paging-in mechanism. Additionally, Heisenbyte uses the `MmProbeAndLockPages` kernel API to make the pages resident in physical memory, preventing them from being paged out. This increases the memory working set of a program, which we will investigate in § 5.2.2.

This information is stored in a queue buffer shared by the guest and host mode components. The guest mode component, running in VMX non-root guest mode, has no access to the EPTs. The configuration of EPT mappings is performed by the host mode component.

**Dynamic JIT Code**
Unlike static binaries, dynamic memory buffer creation/freeing does not have convenient kernel-provided callbacks. The protection bits of a dynamic buffer may change at runtime during the generation and execution of dynamic code. For example, a modern JIT-enabled browser, like Safari, first allocates a writable (RW) buffer as a code cache. With hardware W⊕X DEP enforced, the JIT engine must remove the writable permission and make the code cache executable (RX) before executing it. If the dynamic code cache needs modification, the buffer is restored to a writable (RW) one before changes can be made.

We only need to monitor the buffer during the period when the code is ready to be executed. Specifically, we start tracking a dynamic buffer when its protection bits change from non-executable to executable, and stop tracking when it is freed or when its executable bit is removed.

**Windows-Specific Implementation**
To detect when dynamic memory buffers are turned executable and when they are freed, we modify the entry points of `NtFreeVirtualMemory` and `NtProtectVirtualMemory` in `ntdll.dll` with trampolines to a VM-tracking code. This in-memory function hooking ensures the hooks apply only to the target process due to the OS Copy-on-Write mechanism.

Dynamic memory buffers are created and freed frequently. We use an auxiliary bitmap data page to indicate if an executable buffer of a given virtual address has been previously tracked. This optimization enables the VM-tracking code to handle specific events. The VM-tracking code monitors the changing of protection bits of buffers and performs a hypercall to the host mode component whenever an executable buffer is configured to be non-executable and vice versa. The host mode component updates the address bitmap based on whether a new executable page is being tracked or removed from tracking. The VM-tracking code also monitors the freeing of executable buffers and performs a hypercall when a buffer with a given virtual address is being freed. The host mode component then resets the EPT mapping for the physical pages of the buffer to an identity mapping, stopping the tracking of the dynamic executable buffer.

**Protecting VM-Tracking Code and Data**
The VM-tracking code resides on a dynamically allocated executable page and is protected by Heisenbyte like any other executable memory page. The auxiliary bitmap, configured to be read-only from userspace, is protected from tampering attacks originating from userspace and can only be modified in the host kernel mode. A XOR-based checksum of the bitmap is maintained and verified before the bitmap is updated in the host mode component.

#### 4.2.3 Overcoming Challenges in Using EPT
**Problem of Shared Physical Memory Pages**
One key challenge in using EPT to enforce execute-only memory is that guest physical memory pages may be shared by multiple processes due to the OS's Copy-on-Write (COW) optimization. This COW mechanism conserves physical memory and speeds up program startup by lazily duplicating the original page into a newly allocated physical page only when the process writes to the memory page. Before these physical memory pages are duplicated, they are shared by multiple processes. Enforcing execute-only permissions on these shared pages can result in many #EPT violations and unnecessary overhead.

**Inducing COW on Physical Pages**
Heisenbyte overcomes this problem by inducing COW on the executable memory pages of target processes. We leverage the guest OS's COW capability to allocate new physical memory pages for the static code regions of processes we want to protect. To invoke COW, the write operation must occur in the context of the process. When a static binary is loaded into memory, Heisenbyte schedules an Asynchronous Procedure Call (APC) thread to execute in the context of the target process. This thread suspends the execution of the original target process, enumerates the static code regions using the PE headers, and performs a read and write operation on each executable memory page. This identity-write operation is efficient, touching only one byte in each 4kB memory page. The OS detects the memory write and invokes the COW mechanism, ensuring each executable static page in a process no longer shares a physical page with another process. The executable memory pages are then configured to be read-only using EPT by the host mode component after the COW-inducing thread has processed all the executable memory pages of the newly loaded binary.

### 4.2.4 Intervention with Code Garbling
**Maintaining Separate Code Views**
To enable our de-garbling mechanism, we maintain separate code views.