了名。同理，如果需要明确知道是谁生产的AMQP消息的话，就要看生产者是否把
发送方信息放人有效载荷中。
---
## Page 38
16
第2章理解消息通信
整个过程其实很简单：生产者创建消息，消费者接收这些消息。你的应用程序
可以作为生产者，向其他应用程序发送消息。或者作为一个消费者，接收消息。也
可以在两者之间进行切换。不过在此之前，它必须先建立一条信道（channel）。等等！
什么是信道呢？
你必须首先连接到Rabbit，才能消费或者发布消息。你在应用程序和Rabbit代
序就可以创建一条AMQP信道。信道是建立在“真实的”TCP连接内的虚拟连接。
AMQP命令都是通过信道发送出去的。每条信道都会被指派一个唯一ID（AMQP
库会帮你记住ID的）。不论是发布消息、订阅队列或是接收消息，这些动作都是通
过信道完成的。你也许会问为什么我们需要信道呢？为什么不直接通过TCP连接发
送AMQP命令呢？主要原因在于对操作系统来说建立和销毁TCP会话是非常昂贵
的开销。假设应用程序从队列消费消息，并根据服务需求合理调度线程。假设你只
进行TCP连接，那么每个线程都需要自行连接到Rabbit。也就是说高峰期有每秒成
百上千条连接。这不仅造成TCP连接的巨大浪费，而且操作系统每秒也就只能建立
这点数量的连接。因此，你可能很快就碰到性能瓶颈了。如果我们为所有线程只使
用一条TCP连接以满足性能方面的要求，但又能确保每个线程的私密性，就像拥有
独立连接一样的话，那不就非常完美吗？这就是要引入信道概念的原因。线程启动
后，会在现成的连接上创建一条信道，也就获得了连接到Rabbit上的私密通信路径，
而不会给操作系统的TCP栈造成额外负担，如图2.2所示。因此，你可以每秒成百
上千次地创建信道而不会影响操作系统。在一条TCP连接上创建多少条信道是没有
限制的。把它想象成一束光纤电缆就可以了。
信道
信道
AMQP连接
信道
图2.2理解AMQP信道和连接
每条电缆中的光纤束都可以传输（就像一条信道）。一条电缆有许多光纤束，
允许所有连接的线程通过多条光纤束同时进行传输和接收。TCP连接就像电缆，而
AMQP信道就像一条条独立光纤束。
我们来举个例子吧。假设你正在编写一个服务用来跟踪代客泊车。所有人都和
---
## Page 39
2.2从底部开始构造：队列
17
RabbitMQ进行交流。服务必须要完成两个任务：
（1）存储代客票ID以及对应的车辆停放泊车位。
（2）返回指定代客票ID对应的泊车位。
就第一个任务而言，你提供的服务将扮演消费者的角色。它订阅Rabbit队列，
等待“存放票”消息。该消息包含票ID和泊车位号码。对于第二个任务，你提供
的服务既是消费者也是生产者。它需要接收消息来获取特定代客票ID，然后它需要
发布一个包含对应泊车位号码的应答消息。
为了实现第二个任务，应用程序要扮演生产者的角色。一旦建立到RabbitMQ
代理服务器的连接，应用程序将创建多条信道：chan_recv信道用于服务接收消
息的线程，chan_sendX（X就是线程号）信道用于服务每一个应答线程。你使用
chan_recv设置队列的订阅，用来接收包含“票查询”请求的消息。当应用程序通
过chan_recv信道收到一条票查询消息时，它检查消息中包含的票ID。一旦确认了
对应的泊车位号，应用程序将创建线程发送应答（原始线程则继续接收新的请求）
然后新的应答线程创建包含泊车位号的消息。最终，新线程为应答消息设置标签并
通过chan_sendX信道将其发送给Rabbit。如果只有一条信道，新应答线程将无法分
享TCP连接。你有两个选择。其一，每个线程使用一个连接。这意味着你的应用程
序在响应当前请求前无法处理新的票查询请求。其二，为每个发送线程都分配TCP
连接，这样会浪费TCP资源。使用多个信道，线程可以同时共享连接。这意味着对
请求的应答不会阻塞消费新的请求，而且也不会浪费TCP连接。有时，你可能会选
择仅使用一条信道，但是有了AMQP，你可以灵活地使用多个信道来满足应用程序
的需求，而不会有众多TCP连接的开销。
重要的是记住消费者和生产者是消息发送和消息接收概念的体现，而非客服端
和服务器端。从总体上来说，消息通信，特别是AMQP，可以被当作加强版的传输层。
使用信道，你能够根据应用需要，尽可能多地创建并行的传输层，而不会被TCP连
接约束所限制。当你理解了这些概念时，你就能把RabbitMQ看作软件的路由器了。
2.2从底部开始构造：队列
你已对消费者和生产者有了一定的了解，已经急着要开始了吧？先别急。首先
你需要理解什么是队列。从概念上来讲，AMQP消息路由必须有三部分：交换器、
---
## Page 40
18
第2章理解消息通信
队列和绑定。生产者把消息发布到交换器上；消息最终到达队列，并被消费者接收；
绑定决定了消息如何从路由器路由到特定的队列。在你研究交换器和绑定之前，需
要先理解队列的概念和工作原理。看一下图2.3。
 Messages in
Topic
Fanout
Direct
交换器
'sbol
绑定
call
Q1Q2Q3Q4Q5Q6
队列
虚拟主机
图2.3AMQP栈：交换器、绑定，以及队列
就像我们之前在讨论生产者和消费者时说的那样，队列就如同具名邮箱。消息
最终达到队列中并等待消费。消费者通过以下两种方式从特定的队列中接收消息：
（1)通过AMQP的basic.consume命令订阅。这样做会将信道置为接收模式，
直到取消对队列的订阅为止。订阅了消息后，消费者在消费（或者拒绝）最近接收
的那条消息后，就能从队列中（可用的）自动接收下一条消息。如果消费者处理队
列消息，并且/或者需要在消息一到达队列时就自动接收的话，你应该使用basic.
consume。
（2）某些时候，你只想从队列获得单条消息而不是持续订阅。向队列请求单条
消息是通过AMQP的basic.get命令实现的。这样做可以让消费者接收队列中
的下一条消息。如果要获得更多消息的话，需要再次发送basic.get命令。你不
应该将basic.get放在一个循环里来替代basic.consume。因为这样做会影响
Rabbit的性能。大致上讲，basic.get命令会订阅消息，获得单条消息，然后取消
订阅。消费者理应始终使用basic.consume来实现高吞吐量。
---
## Page 41
2.2从底部开始构造：队列
19
如果至少有一个消费者订阅了队列的话，消息会立即发送给这些订阅的消费者。
但是如果消息到达了无人订阅的队列呢？在这种情况下，消息会在队列中等待。一
旦有消费者订阅到该队列，那么队列上的消息就会发送给消费者。更有趣的问题是，
当有多个消费者订阅到同一队列上时，消息是如何分发的。
当Rabbit队列拥有多个消费者时，队列收到的消息将以循环（round-robin）的
方式发送给消费者。每条消息只会发送给一个订阅的消费者。假设有seed_bin队列，
消费者FarmerBob和消费者FarmerEsmeralda订阅到seed_bin队列。当消息到达
seedbin队列时，消息投递方式如下：
（1）消息Message_A到达seed_bin队列。
（2）RabbitMQ把消息Message_A发送给FarmerBob。
（3）Farmer Bob 确认接收到了消息 Message_A。
（4）RabbitMQ把消息Message_A从seed_bin中删除。
（5）消息Message_B到达seed_bin队列。
（6）RabbitMQ把消息Message_B发送给FarmerEsmeralda。
（7）FarmerEsmeralda确认接收到了消息Message_B。
（8）RabbitMQ把消息Message_B从seed_bin中删除。
你可能注意到了FarmersBob和Esmeralda做了一些我们还未讨论过的事情：他
们对消息进行了确认。消费者接收到的每一条消息都必须进行确认。消费者必须通
过AMQP的basic.ack命令显式地向RabbitMQ发送一个确认，或者在订阅到队
列的时候就将auto_ack参数设置为 true。当设置了auto_ack时，一旦消费者接
收消息，RabbitMQ会自动视其确认了消息。需要记住的是，消费者对消息的确认
和告诉生产者消息已经被接收了这两件事毫不相关。因此，消费者通过确认命令告
诉RabbitMQ它已经正确地接收了消息，同时RabbitMQ才能安全地把消息从队列
中删除。
如果消费者收到一条消息，然后确认之前从Rabbit断开连接（或者从队列上取
消订阅），RabbitMQ会认为这条消息没有分发，然后重新分发给下一个订阅的消费者。
如果你的应用程序崩溃了，这样做可以确保消息会被发送给另一个消费者进行处理。
---
## Page 42
20
第2章理解消息通信
另一方面，如果应用程序有bug而忘记确认消息的话，Rabbit将不会给该消费者发
送更多消息了。这是因为在上一条消息被确认之前，Rabbit会认为这个消费者并没
有准备好接收下一条消息。你可以好好利用这一点。如果处理消息内容非常耗时，
则你的应用程序可以延迟确认该消息，直到消息处理完成。这样可以防止Rabbit持
续不断的消息涌向你的应用而导致过载。
在收到消息后，如果你想要明确拒绝而不是确认收到该消息的话，该如何呢？
举例来说，假设在处理消息的时候你遇到了不可恢复的错误，但是由于硬件问题，
只影响到当前的消费者（这就是一个很好的示例，直到消息处理完成之前，你绝不
能进行确认）。只要消息尚未确认，则你有以下两个选择：
（1）把消费者从RabbitMQ服务器断开连接。这会导致RabbitMQ自动重新把
消息人队并发送给另一个消费者。这样做的好处是所有的RabbitMQ版本都支持。
缺点是，这样连接／断开连接的方式会额外增加RabbitMQ的负担（如果消费者在
处理每条消息时都遇到错误的话，会导致潜在的重大负荷）。
（2）如果你正使用RabbitMQ2.0.0或者更新的版本，那就使用AMQP的basic，
reject命令。顾名思义：basic.reject允许消费者拒绝RabbitMQ发送的消息。
如果把reject命令的requeue参数设置成true的话，RabbitMQ会将消息重新发
送给下一个订阅的消费者。如果设置成false的话，RabbitMQ立即会把消息从队列中
移除，而不会把它发送给新的消费者。你也可以通过对消息确认的方式来简单地忽略
该消息（这种忽略消息的方式的优势在于所有版本的RabbitMQ都支持）。如果你检测
到一条格式错误的消息而任何一个消费者都无法处理的时候，这样做就十分有用。
注意：当去弃一条消息时，为什么要使用basic.reject命令，并将
requeue参数设置成false来替代确认消息呢？在将来的RabbitMQ版本中
会支持一个特殊的“死信”（deadletter）队列，用来存放那些被拒绝而不
重入队列的消息。死信队列让你通过检测拒绝／未送达的消息来发现问题。
如果应用程序想自动从死信队列功能中获益的话，需要使用reject命令
并将requeue参数设置成falseo
还有一件更重要的事情：如何创建队列。消费者和生产者都能使用AMQP的
队列的话，就无法再声明队列了。必须首先取消订阅，将信道置为“传输”模式。
---
## Page 43
2.2从底部开始构造：队列
21
当创建队列时，你常常想要指定队列名称。消费者订阅队列时需要队列名称，并在
创建绑定时也需要指定队列名称。如果不指定队列名称的话，Rabbit会分配一个随
机名称并在queue.declare命令的响应中返回（对于构建在AMQP上的RPC应
用来说，使用临时“匿名”队列很有用，我们会在第4章学习它）。以下是队列设置
中另一些有用的参数：
■exclusive一如果设置为true 的话，队列将变成私有的，此时只有你的应
用程序才能够消费队列消息。当你想要限制一个队列只有一个消费者的时候
很有帮助。
如果你需要临时队列只为一个消费者服务的话，请结合使用auto-delete
和exclusive。当消费者断开连接时，队列就被移除了。
如果尝试声明一个已经存在的队列会发生什么呢？只要声明参数完全匹配现存
的队列的话，Rabbit就什么都不做，并成功返回，就好像这个队列已经创建成功一
样（如果参数不匹配的话，队列声明尝试会失败）。如果你只是想检测队列是否存在，
则可以设置queue.declare的passive选项为 true。在该设置下，如果队列存在，
那么queue.declare命令会成功返回；如果队列不存在的话，queue.declare
命令不会创建队列而会返回一个错误。
当设计应用程序时，你最有可能会问自己，是该由生产者还是消费者来创建所
需的队列呢？看起来最自然的答案是由消费者来创建队列。毕竟，消费者才需要订
阅队列，而且总不能订阅一个不存在的队列，是吧？先别这么快下结论。你首先需
要想清楚消息的生产者能否承担得起丢失消息。发送出去的消息如果路由到了不存
在的队列的话，Rabbit会忽略它们。因此，如果你不能承担得起消息进人“黑洞”
而丢失的话，你的生产者和消费者就都应该尝试去创建队列。另一方面，如果你能
承担得起丢失消息，或者你实现一种方法来重新发布未处理的消息的话（我们会向
你展现如何做到这一点），你可以只让自己的消费者来声明队列。
队列是AMQP消息通信的基础模块：
·为消息提供了处所，消息在此等待消费。
·对负载均衡来说，队列是绝佳方案。只需附加一堆消费者，并让RabbitMQ
以循环的方式均匀地分配发来的消息。
---
## Page 44
22
第2章理解消息通信
■队列是Rabbit中消息的最后的终点（除非消息进入了“黑洞”）
在掌握了队列之后，你已经准备好进人下一个Rabbit构造块：交换器和绑定！
2.3联合起来：交换器和绑定
就像在前几节看到的那样，你想让消费者从队列中获取消息。现在的问题是，
消息是如何到达队列的呢？让我们来认识一下AMQP的交换器和绑定。当你想要将
消息投递到队列时，你通过把消息发送给交换器来完成。然后，根据确定的规则，
队列通过路由键绑定到交换器。当你把消息发送到代理服务器时，消息将拥有一个
路由键一即便是空的一—RabbitMQ也会将其和绑定使用的路由键进行匹配。如
果相匹配的话，那么消息将会投递到该队列。如果路由的消息不匹配任何绑定模式
的话，消息将进入“黑洞”。
为何要如此大费周章？你也许会这么说：“我只想让消息到达队列而已。”让我
们看一个例子，以便理解上述概念的优势。
你可以将这个场景和邮件进行比较：如果你想把一条消息发送给任何一个联系
人，则只需把消息发送到对方的邮件地址，SMTP服务器会检查消息是发送给谁的
并会负责投递到用户的收件箱。但是，如果你的联系人想要把来自你的每条消息都
归档到商务文件夹下的话会如何呢？为了能达成这个自标，他们需要根据消息内容
设置明确的规则。举例来说，他们可能也想通过设置基于主机名的规则，将某些商
业供应商归类到同一个文件夹中。通过交换器、绑定和队列的概念，AMQP实现上
述以及更多的使用场景，因此你能将队列绑定到交换器上，而不使用路由键，然后
你发送给交换器的每一条没有路由键的消息会投递到上述的队列中去。这一点和邮
件系统非常类似。如果你需要复杂的使用案例，例如发布/订阅或者多播，则也能
够轻易完成。一会儿你就能看到。
除了可以用交换器和绑定来完成不同的使用场景之外，还有另一个好处是：对
于发送消息给服务器的发布者来说，它不需要关心服务器的另一端（整个消息处理
环节中的队列和消费者）的逻辑。就如你将看到的那样，这可以导致有趣的消息通
信场景。如果服务器只允许你直接发布消息到队列的话，是无法实现这些场景的
或者说非常难以实现。
---
## Page 45
2.3联合起来：交换器和绑定
23
就像你之前看到的那样，服务器会根据路由键将消息从交换器路由到队列，但
它是如何处理投递到多个队列的情况的呢？协议中定义的不同类型交换器发挥了作
用。一共有四种类型：direct、fanout、topic和headers。每一种类型实现了不同的路
由算法。我们会讲解除了headers交换器外的其他三种。headers交换器允许你匹配
AMQP消息的header 而非路由键。除此之外，headers交换器和direct交换器完全一
致，但性能会差很多。因此它并不太实用，而且几乎再也用不到了。让我们仔细看
看其他几种类型的交换器吧。
direct交换器非常简单：如果路由键匹配的话，消息就被投递到对应的队列。
请参考图2.4。
direct交换器
香蕉
黄瓜