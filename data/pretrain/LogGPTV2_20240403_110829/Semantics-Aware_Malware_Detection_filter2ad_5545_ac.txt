4
5
6
7
A = const_addr1
B = const_addr2
A > const_addr3 ?
false
true
mem[B] = mem[A] ^ key
A = A + c
B = B + d
jump const_address2
eax = 0x403000
ebx = 0x400000
val
(eax) = val
pre
post
(ecx−1)
nop
ecx = eax + 1
ecx − 1 > 0x406000
true
false
eax = ecx − 1
mem[ebx] = mem[eax]^5
eax = eax + 1
1
2
3
4
5
6
7
8
9
ebx = ebx + 2
10
jump 0x400000
Figure 3. Example of program (on the right) satisfying a template (on the left) according to
our algorithm AMD. Gray arrows connect program nodes to their template counterparts. The
dashed arrow on the left marks one of the def-use relations that does hold true in the template,
while the corresponding dashed arrow on the right marks the def-use relation that must hold true
in the program.
match the program with the template as the ordering of
memory updates in the template loop is different from
that in the program loops.
Local uniﬁcation. The uniﬁcation step addresses
the ﬁrst condition of algorithm AMD, by producing an
assignment to variables in an instruction at a template
node such that it matches a program node instruction (if
such an assignment exists). Since a program node ex-
pression contains only ground terms, the algorithm uses
one-way matching that instantiates template variables
with program expressions. In Figure 3, template node
3 matches program node 5, with the binding { A ← ecx
- 1, const addr3 ← 0x406000 }. In the prototype we
implemented, a template can contain expressions with
variables, symbolic constants, predeﬁned functions (see
the operators in Appendix B), and external function
calls. The matching algorithm takes these restrictions
into account:
• A variable in the template can be uniﬁed with any
program expression, except for assignment expres-
sions.
• A symbolic constant in the template can only be uni-
ﬁed with a program constant.
• The predeﬁned function memory : F (1) (traditionally
written in array notation memory[. . . ]) can only be
uniﬁed with the program function memory : F (1).
Proceedings of the 2005 IEEE Symposium on Security and Privacy (S&P’05) 
1081-6011/05 $ 20.00 IEEE
• A predeﬁned operator in the template can only be
uniﬁed with the same operator in the program.
• An external function call in the template can only be
uniﬁed with the same external function call in the
program.
Standard uniﬁcation rules apply in all other cases: for
example, an operator expression in the template uniﬁes
with an expression in the program if the program oper-
ator is the same as the template operator and the cor-
responding operator arguments unify. Template node 1
(A = const addr1) can unify with program nodes 1
(eax = 0x403000) or 2 (ebx = 0x400000) but not
with program nodes 8 or 9, since template node 1 ex-
pression has a symbolic constant as the right-hand side.
The result of the local uniﬁcation step is a binding
relating template variables to program expressions. The
binding for the example in Figure 3 is shown in Table 1.
Note that the bindings are different at various program
points (at program node 1, template variable A is bound
to eax, while at program node 5, template variable A is
bound to (ecx - 1)). Requiring bindings to be consis-
tent (monomorphic) seems like an intuitive approach,
but leads to an overly restrictive semantics – any obfus-
cation attack that reassigns registers in a program frag-
ment would evade detection. We want to check pro-
gram expressions bound to the same template variable
(e.g. eax and (ecx - 1) are both bound to A) and verify
they change value in the same way the template vari-
able changes values. We employ a mechanism based
on def-use chains and value preservation to answer this
problem.
P1
P2
P5
P7
P8
T3
T2
Uniﬁed nodes Bindings
A ← eax
const addr1 ← 0x403000
T1
B ← ebx
const addr2 ← 0x400000
A ← ecx - 1
const addr3 ← 0x406000
A ← eax
B ← ebx
A ← eax
increment1 ← 1
B ← ebx
increment2 ← 2
const addr2 ← 0x400000
P9
P10
T6
T7
T4
T5
Table 1. Bindings generated from the uni-
ﬁcation of template and program nodes in
Figure 3. Notation Tn refers to node n of
the template, and Pm refers to node m of
the program.
Value preservation on def-use chains. The sec-
ond condition of algorithm AMD requires template vari-
ables and the corresponding program expressions to
have similar update patterns (although not necessarily
the same values). For each def-use chain in the tem-
plate, the algorithm checks whether the value of the pro-
gram expression corresponding to the template-variable
use is the same as the value of the program expression
corresponding to the template-variable deﬁnition. Con-
sider Figure 3, where template nodes 1 and 3 are def-
use related. Program nodes 1 and 5 map to template
nodes 1 and 3, respectively. Denote by R the program
fragment between nodes 1 and 5, such that R contains
only program paths from program node 1 to node 5 that
correspond to template paths between template nodes 1
and 3 (i.e., any path in R has nodes that either map to
template paths between 1 and 3, or have no correspond-
ing template node). A def-use chain for template vari-
able A connects template node 1 with template node 3:
in the program, the expressions corresponding to tem-
plate variable A after program node 1 and before pro-
gram node 5 must be equal in value, across all paths in
R. This condition can be expressed in terms of value
predicates: for each path I in program fragment R (e.g.
I = (cid:5)P2, P3, P4(cid:6)), val pre(cid:2)I(cid:3)(eax) = val post(cid:2)I(cid:3)(ecx − 1),
where val pre(cid:2)I(cid:3) represents the variable-valuation func-
tion for the program state before path I and val post(cid:2)I(cid:3)
is the variable-valuation function for the program state
after path I. We can formulate this query about pre-
serving def-use chains as a value preservation prob-
Proceedings of the 2005 IEEE Symposium on Security and Privacy (S&P’05) 
1081-6011/05 $ 20.00 IEEE
.
(cid:1)
lem: given the program fragment R, we want to check
whether it maintains the value predicate φ ≡ ∀I ∈
R .
(cid:2)
val pre(cid:2)I(cid:3)(eax) = val post(cid:2)I(cid:3)(ecx − 1)
The algorithm uses decision procedures to determine
whether a value predicate holds. We discuss these de-
cision procedures in Section 3.3; for now, we treat the
decision procedures as oracles that can answer queries
of the form “Does a program fragment R maintain an
invariant φ?” For each match considered between a pro-
gram node and a template node, the algorithm checks
whether the def-use chain is preserved for each program
expression corresponding to a template variable used at
the matched node (see Appendix C for a listing of all
the def-use chains checked for the example shown in
Figure 3). This approach eliminates a large number of
matches that cannot lead to a correct template assign-
ment.
3.3. Using decision procedures to check value-
preservation
A value-preservation oracle is a decision procedure
that determines whether a given program fragment is
a semantic nop with respect to certain program vari-
ables. Formally, given a program fragment P and pro-
gram expressions e1, e2, a decision procedure D deter-
mines whether the value predicate φ(P, e1, e2) ≡ ∀I ∈
P . val pre(cid:2)I(cid:3)(e1) = val post(cid:2)I(cid:3)(e2) holds.
D(P, e1, e2) =
true
⊥
if P is a semantic nop,
i.e. φ(P, e1, e2) holds
otherwise
Similarly, we can deﬁne decision procedures that de-
termine whether ¬φ(P, e1, e2) holds (in this case, the
result of D(P, e1, e2) is “false” or ⊥). We denote by
D+ a decision procedure for φ(P, e1, e2), and by D− a
decision procedure for ¬φ(P, e1, e2).
As the value preservation queries are frequent in our
algorithm (possibly at every step during node match-
ing), the prototype use a collections of decision proce-
dures ordered by their precision and cost. Intuitively,
the most na¨ıve decision procedures are the least precise,
but the fastest to execute. If a D+-style decision proce-
dure reports “true” on some input, all D+-style deci-
sion procedures following it in the ordered collection
will also report “true” on the same input. Similarly, if a
D−-style decision procedure reports “false on some in-
put, all D−-style decision procedures following it in the
ordered collection will also report “false” on the same
input. As both D+- and D−-style decision procedures
are sound, we deﬁne the order between D+ and D− de-
cision procedures based only on performance.
This collection of decision procedures provides us
with an efﬁcient algorithm for testing whether a pro-
gram fragment P preserves expression values: iterate
through the ordered collection of decision procedures,
querying each Di, and stop when one of them returns
“true”, respectively “false” for D−-style decision pro-
cedures. This algorithm provides for incrementally ex-
pensive and powerful checking of the program frag-
ment, in step with its complexity: program fragments
that are simple semantic nops will be detected early by
decision procedures in the ordered collection. Complex
value preserving fragments will require passes through
multiple decision procedures. We present, in order, four
decision procedures that are part of our prototype.
Nop Library D+
NOP. This decision procedure iden-
tiﬁes sequences of actual nop instructions, which are
processor-speciﬁc instructions similar to the skip state-
ment in some high-level programming languages, as
well as predeﬁned instruction sequences known to be
semantic nops. Based on simple pattern matching, the
decision procedure annotates basic blocks as nop se-
quences where applicable. If the whole program frag-
ment under analysis is annotated, then it is a semantic
nop. The nop library can also act as a cache for queries
already resolved by other decision procedures.
RE. This ora-
cle is based on a D−-style decision procedure using ran-
domized execution. The program fragment is executed
using a random initial state (i.e. the values in registers
and memory are chosen to be random). At completion
time, we check whether it is true that ¬φ(P, e1, e2): if
true, at least one path in the program fragment is not a
semantic nop, and thus the whole program fragment is
not a semantic nop.
Randomized Symbolic Execution D−
Theorem Proving D+
ThSimplify. The value preser-
vation problem can be formulated as a theorem to be
proved, given that the program fragment has no loops.
We use the Simplify theorem prover [14] to implement
this oracle:
the program fragment is represented as a
state transformer δ, using each program register and
memory expression converted to SSA form. We then
use Simplify to prove the formula δ ⇒ φ(P, e1, e2), in
order to show that all paths through the program frag-
ment are semantic nops under φ(P, e1, e2). If Simplify
conﬁrms that the formula is valid, the program fragment
is a semantic nop. One limitation of the Simplify the-
orem prover is the lack of bit-vector arithmetic, which
binary programs are based on. Thus, we can query Sim-
plify only on programs that do not use bit-vector opera-
tions.
Theorem Proving D+
ThUCLID. A second theorem
proving oracle is based on the UCLID inﬁnite-state
bounded model checker [22]. For our purposes, the
logic supported by UCLID is a superset of that sup-
ported by Simplify.
In particular, UCLID precisely
models integer and bit-vector arithmetic. We model the
program fragment instructions as state transformers for
each register and for memory (represented as an unin-
terpreted function). UCLID then simulates the program
Proceedings of the 2005 IEEE Symposium on Security and Privacy (S&P’05) 
1081-6011/05 $ 20.00 IEEE
Obfuscation transformation
Instruction reordering
Register renaming
Garbage insertion
Instruction replacement
Equivalent functionality
Reordered memory accesses
Handled
by AMD?



limited


Table 3. Obfuscation transformations ad-
dressed by our malware detection algo-
rithm and some limitations.
fragment for a given number of steps and determines
whether φ(P, e1, e2) holds at the end of the simulation.
For illustration, consider Figure 3: the value preser-
vation problem consists of the program fragment R, cre-
ated from program nodes 2, 3, and 4, and the value pred-
icate φ ≡ ∀I ∈ R . val pre(cid:2)I(cid:3)(eax) = val post(cid:2)I(cid:3)(ecx−1).
To use the Simplify theorem proving oracle, the formula
shown in Table 2 is generated from program fragment
R.
3.4. Strengths and limitations
For the algorithm to be effective against real-life at-
tacks, it has to “undo” various obfuscations and other
program transformations that a malware writer might
use. We list the strengths and weaknesses of our algo-
rithm in Table 3. We discuss below in detail four classes
of obfuscations algorithm AMD can handle: code re-
ordering, equivalent instruction replacement, register
renaming, and garbage insertion.
Code reordering is one of the simplest obfuscations
hackers use to evade signature matching. The obfus-
cation changes the order of instructions on disk, in the
binary image, while maintaining the execution order us-
ing jump instructions. This obfuscation is handled by
the use of control ﬂow graphs. Register renaming is a
simple obfuscation that reassigns registers in selected
program fragments. As a result, a signature matching
tool will fail to detect any obfuscated variant as long as
it searches for a signature with a speciﬁc register. Our
template matching algorithm avoids this pitfall by us-
ing templates. The uninterpreted variables are assigned
corresponding program registers and memory locations
only during uniﬁcation and, thus, the matching algo-
rithm can identify any program with the same behavior
as the template, irrespective of the register allocation.
Garbage insertion obfuscates a program by inserting
instruction sequences that do not change the behavior
of the program. Algorithm AMD tackles this class of
obfuscations through the use of decision procedures to
reason about value predicates on def-use chains. Equiv-
alent instruction replacement uses the rich instruction
set available on some architectures, notably on the Intel
Instruction sequence:
2: ebx = 0x400000
3: nop
4: ecx = eax + 1
Simplify formula:
( IMPLIES (AND (EQ ebx 1 4194304)
(EQ ecx 4 ( + eax pre 1 )
(EQ ecx post ecx 4 )
)
Value predicate:
∀I ∈ R . val pre(cid:2)I(cid:3)(eax ) = val post(cid:2)I(cid:3)(ecx − 1)
)
)
(EQ eax pre ( − ecx post 1 )
)
Table 2. Example of Simplify query corresponding to program fragment R and value predicate
φ.
IA-32 (x86), to replace groups of consecutive instruc-
tions with other short instruction sequences that have
the same semantics. For example, to add 1 to register
X in the x86 architecture, one can use the inc X (in-
crement) instruction, or the add X, 1 instruction, or
the sub X, -1 instruction. We handle a limited kind
of instruction replacement by normalizing the code into
an intermediate representation (IR) with semantically-
disjoint operations.