following: If, in an initiated TC message, an attacker node fails to include a legitimate 
MPR selector, this may potentially deny service to this MPR selector; this denial of 
service  may  be  partial  or  total  depending  on  the  topology  around  the  victim  node. 
Similarly, if, in a forwarded TC message, an attacker modifies the ANSN field, or the 
MPR selector list, then it effectively alters how the routing table is established at other 
nodes  around  the  network.  This  may  affect  not  only  the  network  service  at  the 
neighborhood of the victim node that originated the TC, but may result in cascading 
network effects that arise from how routing decisions are made by nodes around the 
network.  
These modifications of OLSR control message fields used by a single attacker as 
described  above  follow  the  basic  format  specifications  of  OLSR  messages.  This 
makes them hard to detect. However, they conflict with other OLSR control messages 
from  other  nodes.  We  call  these  conflicts  “inconsistencies”.  In  the  next  section,  we 
define  constraints  to  be  employed  within  the  proposed  intrusion  detection  model  to 
detect those control message inconsistencies that lead to the possible attacks. 
3   Intrusion Detection Model 
This section describes our specification-based approach to detecting attacks in OLSR. 
In general, specification-based detection recognizes attacks by comparing the activity 
of  an  object  with  a  model  of  correct  behavior  of  the  object.  It  has  been  applied  to 
detect  attacks  on  computer  programs  and  network  protocols.  Specification-based 
detection  is  particularly  suitable  for  detecting  attacks  on  network  protocols  because 
the correct behavior of a protocol is well defined and is documented in the protocol 
specification. The challenge is to extract a suitable correct behavior model from the 
protocol specification that can be checked at runtime using network monitoring. We 
first list assumptions employed, and then present the correct behavior model of OLSR 
under these assumptions. 
3.1   Assumptions 
We  assume  a  distributed  intrusion  detection  architecture  that  allows  cooperative 
detectors  to  promiscuously  monitor  all  Hello  and  TC  messages,  and  exchange  their 
local data if necessary. IDS detectors in this architecture can monitor all Hello and TC 
messages sent by each node of the network, always exchange IDS data successfully, 
and will not be compromised.  
A Specification-Based Intrusion Detection Model for OLSR 
335 
In addition, we assume that cryptographic protection, such as TESLA, is employed to 
guard  against  spoofing  attacks.  Furthermore,  we  assume  OLSR  is  the  only  routing 
protocol in the network and each node has only one network interface. In other words, 
Multiple  Interface  Declaration  (MID)  and  Host  and  Network  Association  (HNA) 
messages are not used here. Lastly, we assume nodes forward TC messages following 
OLSR Default Forwarding Algorithm and nodes forward normal packets to the correct 
next hop. Our ongoing work, discussed in section 6, attempts to relax these assumptions. 
3.2   Correct Behavior Model of OLSR 
Figure  2  shows  the  FSA  model  of  the  OLSR  protocol  that  defines  the  correct 
operation of an OLSR node in handling control traffic. When a node receives a Hello 
control  message, it  will  update its neighbor list and MPR set. Upon receiving a TC 
control message, a node updates the topology and routing table. In addition, the node 
will  forward  the  TC  if  it  is  a  MPR  node.  In  addition,  a  node  will  periodically 
broadcast Hello and TC messages.  
We  describe  the  constraints  on  the  control  traffic  between  neighbor  nodes  for 
detecting inconsistencies within the control messages. 
C1:  Neighbor  lists  in  Hello  messages  must  be  reciprocal.  E.g.,  if  node  2  is  the 
neighbor of node 1, then node 1 must be node 2’s neighbor. 
C2:  The MPR nodes of a node must reach all 2-hop neighbors of the node and the 
MPR nodes must transmit TC messages periodically. 
C3:  MPR  selectors  of  a  TC  message  must  match  corresponding  MPR  sets  of 
Hello messages. E.g., if node 2 is node 1’s MPR selector, node 1 must be in 
node 2’s MPR set. 
C4:  Fidelity of forwarded TC messages must be maintained. 
Send
Hello
Hello Interval
Expire
Receive
Hello
Receive
Hello
Broadcast
Hello
TC Interval
Expire
Initiate
TC
Broadcast
Initiated TC 
Listen
Update Neighbor list
with MPR Set
Receive TC
1) Update Routing Tables
2) Forward TC if it is an MPR
Receive
TC
Fig. 2. OLSR Routing Finite State Automata (FSA) 
336 
C.H. Tseng et al. 
C1  ensures  that  1-hop  neighbor  lists  of  Hello  messages  from  all  nodes  are 
consistent.  According  to  the  OLSR  routing  specification,  since  1-hop  neighbor  lists 
are consistent, nodes can produce correct 1-hop and 2-hop neighbor lists. 
C2 ensures that MPR nodes of each node connect all 2-hop neighbors of the node. 
By definition of MPR, MPR sets are correct. 
C3 ensures that MPR selector sets are consistent with MPR sets and therefore are correct. 
C4 ensures that the forwarded MPR selector sets are correct. 
Send 
Hello 
Violate    
C1 or C2
Modified
Hello
Report 
Violation
Initiate 
TC 
Violate   
C3 
Modified
Init TC
Listen 
Receive 
TC 
Violate 
C4  
Report  
Violation 
Modified 
Forward 
TC
Fig. 3. Security Specification Finite State Automata 
Figure  3  (an  extension  of  the  FSA  in  Figure  2)  depicts  the  FSA  used  by  the 
specification-based  intrusion  detection  system.  When  a  OLSR  control  message 
violates  one  of  the  constraints,  the  FSA  moves  from  a  normal  state  into  one  of  the 
alarm  states  (Modified  Hello  State,  Modified  Init  TC  State,  Modified  Forward  TC 
State)  To  recovery  from  the  errors,  a  detector  may  broadcast  the  corrected  TC 
message,  or  force  the  node  causing  the  violation  to  resend  the  corrected  Hello 
message,  and  thereby  recover  corrupted  routing  tables  of  infected  nodes.  Thus,  the 
“report  violation”  actions  in  the  FSA  can  be  enhanced  to  perform  the  corrective 
action. Since our proposed model is only dealing with intrusion detection, we do not 
explore  such  recovery  actions  further  in  this  paper.  However,  this  preliminary 
recovery model is incorporated into our simulation experiments using GloMoSim, as 
described in Section 5. 
3.3   Temporary Inconsistency 
Temporary violation of constraints C1, C2 and C3 may occur in a short period of time 
as links are created or removed when the topology changes. To avoid false alarms, a 
detector  must  wait  for  the  two  nodes  on  both  sides  of  a  link  to  learn  the  new  link 
status  before  asserting  the  inconsistency  as  an  attack.  For  example,  if  a  new  link 
between node A and node B is created, node A may update the status of link A-B and 
send a Hello message that is not consistent with the previous Hello message of node B, 
which  does  not  claim  that  link  A-B  exists.  The  detector  should  wait  for  node  B  to 
receive the new Hello message from A and send a new Hello message that reflects the 
addition of link A-B. In case of broken links, (leading to lost messages), the detector 
A Specification-Based Intrusion Detection Model for OLSR 
337 
should  wait  for  the  expiration  of  the  old  records  at  the  nodes.  In  other  words,  if  a 
detector detects violation of constraint 1, 2 or 3 with regard to nodes A and B, and the 
violation continues to occur after a certain threshold, then  the detector  will raise an 
alarm.  In  addition,  because  temporary  inconsistency  duplicates  due  to  unstable 
asymmetric link, constraints 1 and 2 requires 12 seconds and constraint 3 requires 15 
seconds because of 5 second TC interval time. For constraints C4, since the validation 
of  new  messages  depends  on  the  messages  from  the  originators,  temporary 
inconsistency does not occur. 
Each node of the link sends a new message to allow the other receivers 
to respond to new status. This takes 2 seconds (Hello Interval) 
A 
B
If the link is down or messages are lost, wait for 6 seconds (Hello Valid 
Time) to allow old records to expire.  
Fig. 4. Resolving temporary inconsistency between nodes of a link 
Table 2. Important Parameters for Temporary Inconsistency 
Constraint Alert thresholds 
OLSR Default Parameters 
C1 (1-hop neighbors) 
C2 (2-hop neighbor vs MPR) 
C3 (MPR vs MPR selector ) 
C4 (Forwarded TC) 
12 sec  Hello message sending interval 
12 sec  Hello message valid time 
15 sec  TC message sending interval 
0 sec 
TC message valid time 
2 sec 
6 sec 
5 sec 
15 sec 
3.4   Limitations 
For a single attack or non-correlated attacks, the model can detect all attacks since we 
capture all possible  ways to  modify a  single  message at a time. But if two or  more 
attackers try to make a correlated lie the constraints may not be able to detect it. For 
example, if two attackers are not neighbors but both claim they are neighbors, there 
may  be  no  detectable  violation.  This  is  because  since  Hello  messages  are  1-hop 
broadcast messages and detectors do not know who actually receive them, detectors 
are  not  able  to  employ  constraint  C1  to  detect  violations.  This  attack  is  a  tunneling 
attack— attackers build up a virtual link between them.  
We  plan  to  address  this  issue  by  developing  constraints  monitoring  forwarding 
behavior in MANET to allow detectors detecting some types of correlated attacks.  
4   Analysis of the OLSR Detection Model 
In this section,  we analyze the OLSR protocol and the proposed detection model to 
show  that  the  set  of  constraints  C1  –  C4  can  identify  attacks  in  MANETs.  As 
illustrated  in  Section  2,  a  malicious  node  can  disrupt  the  integrity  of  the  network 
338 
C.H. Tseng et al. 
(causing  good  nodes  to  change  their  routing  table  to  its  advantage)  by  intentionally 
generating and forwarding incorrect control messages. In particular, we show that in 
an OLSR network consisting of only one malicious node, these constraints ensure that 
the malicious node cannot compromise the integrity of the routing tables of all good 
nodes. 