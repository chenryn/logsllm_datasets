在本文中，它们service_user以systemd我们绝对无法定位的名称为目标。因此，我们在分配之前设置了一个断点来检查链表。然后，我们搜索systemd并向后遍历该列表，直到找到靠近我们的分配的第一个service_user为止。（结合A的一些反复试验，以了解其崩溃的结构)）
在这里，我service_user在内存中显示了不同的名称，并在vmmaps下面显示了相同的名称。如图所示，第二个vmmap对应于systemd，其偏移量为距堆基0x47e0。这显然是一个问题，因为我们service_user在列表0x4790之前的列表中看到了另一个，而两个结构之间只有0x50的空间，所以两个结构之间只有0的空间。这使得不可能针对这一目标，但是我们可以只选择之前的目标。但是，为什么不针对其他一些fx某些0x2000结构呢？好吧……您根本无法进行那么早的分配。
## 堆修饰
那么，如何在接近目标的内存区域分配内存呢？因此，这篇文章中的任务似乎并不明确，听起来好像他们“蛮力”尝试了很多，直到解决方案崩溃。如果不正确，请随时与我们的团队联系。
无论如何，我们都不希望尝试各种不同的分配方式。但是，他们确实提到了在我们控制大小的sudo进程中尽早进行分配的巧妙方法。
此技巧利用了以下事实：setlocale被称为第一件事，并且它们声明：在154行的setlocale（）中，我们malloc（）ate和free（）几个LC环境变量（LC_CTYPE，LC_MESSAGES，LC_TIME等），从而在sudo堆的开始处创建了小洞（空闲的fast或tcache块）
这是一个巧妙的技巧，我们通过打破setlocale和以下所有免费代码来研究此大小，以检查将要释放的大小块。
第一个有趣的测试：
第二个有趣的测试：
现在，实际上第二个被分配并在setlocale内不久之后再次释放。这使我相信它比第一个更加不可靠（可能是因为它同样稳定）。
但是有趣的是，我们没有发现本文所期望的其他LC变量中的其他自由变量，这很可能是libc依赖的，或者我完全不在本地使用。
这意味着我们只有这个分配可以使用。令人遗憾的是，现在可以使用的malloc更少了，但同时也限制了搜索空间。
现在，您还记得我说过的关于前向和后向指针的事情，我们应该不在乎。是的..现在我们需要这些知识。因此，这里介绍了世界上最快的垃圾箱介绍。
实际上，释放的块并不存储在单个链表中，而是分成多个链表，这些链表按边上的块大小排序。更糟糕的是，我们提供了5种不同的列表：
  * tcache适用于大小从0x20到0x408的超快速分配
  * fast bins也是从0x20到0x80的超快速分配
  * small bins比tcache和fastbins大的小分配
  * large bins大的可变大小的块
  * unsorted bin一个包含尚未分类到其他箱中的块的箱
我们将仅关注tcache和fast
bins，因为其他箱中的数据块可能会合并，这意味着连续的数据块可以合并为一个更大的数据块，这使得以后很难预测垃圾箱的状态。在这两类箱中，块大小每0x10增量存在一个箱。（bin==链表）
现在，我们要使用LC_MESSAGE分配一个块，并在setlocale中再次释放它，以使该块可在以后执行溢出时使用。这样，我们就可以在堆上获得更大的块。
我不希望在我的分配之前释放的容器中的块，而当我们进行最终的溢出分配时，容器中的块仍然存在，因为它们可能来自sudo中的其他位置。
因此，在setlocale的末尾和最后的分配之前中断，让我对sudo期间使用了哪些bin有了一个了解。请注意，这并不能说明所有分配情况，实际上与分配情况相去甚远，因此仍会涉及一些反复试验。
我试图说明搜索空间，我们将首先尝试:
现在，这是一个粗略的计划，我没有完全坚持下去。
经过令人惊讶的几次尝试之后，我们就在溢出分配之前将这一块可用了：
上面的是我们的分配，下面是目标字符串mymachine。仅相隔0x4790-0x4370 == 0x420字节。不错，这似乎可行。
现在，我们只需要使用null进行溢出，直到命中该结构并重新组合具有ni-library null和另一个名称的相同结构即可。
我们首先通过如下设置args来进行分配，以匹配之前找到的大小。以前面所述的分配取决于提供给sudoedit的第一个参数的长度。我们将尝试将此大小与LC_MESSAGE释放的块进行匹配。[核对原件]
    char *args[] = {
           "/usr/bin/sudoedit",       
           "-s",
    "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAA\",       
           NULL
    }; //B and A's to match the chunk size we want freed in thebeginning
然后，我们创建一长串环境变量以放入null并以伪造的service_user结构结尾：
    char *extra_args[] = {        "\\",               "\\",               "\\",               "\\",               "\\",               "\\",               "\\",               "\\",              "\\",               "\\",               "\\",               "\\",               "\\",               "\\",               "\\",              "\\",               "\\",               "\\",               "\\",               "\\",               "\\",               "\x01\\",               "\\",               "\\",               "\x01\\",               "\\",               "\\",               "\\",               "\\",               "\\",               "\\",               "\\",               "\\",               "\\",               "\\",               "\\",               "\\",               "\\",               "\\",               "\\",               "\\",               "\\",               "\\",               "\\",               "\\",               "\\",               "\\",               "X/X\\",               "a",            "LC_MESSAGES=C.UTF-8@AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",               NULL, };
然后，nss_load_library中的_st***y序列将基于上面的X/X\arg创建路径libnss_X/X.so.2：
现在我们只需要创建一个简单的库即可加载。我们只是创建一个带有初始化函数设置ID（不确定是否需要）的小型库，并执行/bin/sh并在nss_load_library中的ld_open时生成根shell。使用gcc-Os-Wall-Wextra-fPIC-sharednss.c-oX.so.2进行编译。
看到这个我真高兴！！
shell终于弹出了
## 结论
最终的利用是100％可靠的，并且可以在我的环境中使用libc2.32启用ASLR，这在ubuntu
20.10中也可以找到，并且可能很容易在许多发行版中进行了重新设计。由于许多系统仍然容易受到攻击，我们目前尚未发布最终的利用代码。感谢所有参与发现此漏洞并加以利用的研究人员。
## 参考链接
  * https://www.sudo.ws/download.html
  * https://blog.qualys.com/vulnerabilities-research/2021/01/26/cve-2021-3156-heap-based-buffer-overflow-in-sudo-baron-samedit
  * https://www.kalmarunionen.dk/writeups/sudo/