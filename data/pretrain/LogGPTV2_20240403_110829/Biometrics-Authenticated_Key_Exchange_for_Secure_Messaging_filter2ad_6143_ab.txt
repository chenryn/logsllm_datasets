ğœ†) is negligible.
ğœ†
(1) On input a security parameter 1
, A outputs an appropriate
threshold ğœ such that it satisfies the privacy and robustness
properties for the secret key, and sends ğœ to C.
(2) C executes Setup(1
ğœ†, ğœ) â†’ ğ‘ğ‘ğ‘Ÿ , PubGen(ğ‘ğ‘ğ‘Ÿ, ğ‘ ğ‘˜) â†’ ğ‘ğ‘˜, and
sends ğ‘ğ‘˜ to A.
, ğ‘ğ‘ğ‘Ÿ , and oracle access to Enc(Â·).
ğœ†
(3) A is given input 1
(4) C generates a new secret key ğ‘ ğ‘˜ (cid:4) such that ğ‘‘ğ‘–ğ‘  (ğ‘ ğ‘˜, ğ‘ ğ‘˜ (cid:4)) < ğœ. Fur-
ther, C sends the encapsulated message ğ‘ â† AFEM.Enc(ğ‘ğ‘˜, ğ‘)
for ğ‘ â† {0, 1} to A.
(5) A outputs a guess ğ‘ (cid:4) âˆˆ {0, 1}. The advantage of the adversary
is denoted as |Pr[ğ‘ = ğ‘ (cid:4)] âˆ’ 1/2|.
3.2 Construction for Biometric Vector
We propose the first AFEM construction for secret keys in the form
of biometric vectors, which means that the biometric characteristics
of a participant can be converted into a string. Assuming the secret
ğ‘š
key is ğ‘ ğ‘˜ = u âˆˆ F
ğ‘ , where ğ‘ is a prime and Fğ‘ is a finite field, and
the closeness is defined by Hamming distance, we give the technical
description and construction as follows.
3.2.1 Generating Public Key. The key idea is to exploit the Learning
With Errors (LWE) problem to securely encode a traditional secret
key into a vector with the help of a biometric vector. Specifically, a
ğ‘šÃ—ğ‘™
ğ‘™
ğ‘ is encoded by e = Ax + u, where A âˆˆ F
random vector x âˆˆ F
is
ğ‘
a random matrix and u is the biometric vector. Then, x is mapped
to Zğ‘ through a hash function ğ» : {0, 1}âˆ— â†’ Zğ‘, which allows us
Session 10B: Crypto and Protocol Security CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2620Algorithm 1: Decoding algorithm Decodeğœ
1 Input A, b
2 Randomly select rows without replacement
ğ‘—1, . . . , ğ‘—
2ğ‘™ â† [1, ğ‘š]
3 Restrict A, b to rows ğ‘—1, . . . , ğ‘—
2ğ‘™ and denote as A
ğ‘—1,...,ğ‘—2ğ‘™ ,
ğ‘—1,...,ğ‘—2ğ‘™
b
4 if there exist ğ‘™ linearly independent rows of A
5
ğ‘—1,...,ğ‘—2ğ‘™
(cid:4) = A
Let A
Compute x
ğ‘—1,...,ğ‘—2ğ‘™ , b
(cid:4) = A
(cid:4)âˆ’1b
(cid:4) = b
(cid:4)
6
ğ‘—1,...,ğ‘—2ğ‘™ then
7 else
Abort
8
(cid:4)
9 if b âˆ’ Ax
10
11 Output x
(cid:4)
Go to step 2
has more than ğœ nonzero coordinates then
to adopt an ElGamal-like encryption. Therefore, the public key is
(A, e, ğ‘¦ = ğ‘”ğ» (x) ), where ğ‘” is a generator of a group.
3.2.2 Encapsulating Message. To encapsulate a message ğ‘ , we en-
crypt it with an ElGamal-like encryption. Specifically, for the public
key ğ‘¦, a random value ğ‘Ÿ âˆˆ Zğ‘ is selected. Then, the encrypted
message is (ğ‘”ğ‘Ÿ , ğ‘¦ğ‘Ÿ âŠ• ğ‘ ).
3.2.3 Decapsulating with Implicit Authentication. To decapsulate
the encapsulated message, we need to recover the traditional se-
cret key. Due to the difficulty of the LWE problem, the key can
be recovered only if the two biometric vectors are similar, which
realizes implicit authentication. Specifically, we employ a decoding
algorithm Decodeğœ as shown in Algorithm 1, which can decode a
random linear code with at most ğœ errors [24].
ğ‘š
3.2.4 Putting it All Together. Let ğ‘ ğ‘˜, ğ‘ ğ‘˜ (cid:4) âˆˆ F
ğ‘ and ğ‘  âˆˆ G. The
AFEM construction for the biometric vector is as follows.
â€“ Setup(1
ğœ†, ğœ). Output ğ‘ğ‘ğ‘Ÿ = (ğœ†, G, ğ‘, ğ‘”, ğœ, ğ‘š, ğ‘™, ğ» ) where G is a
cyclic group of prime order ğ‘, ğ‘” is a generator of G, ğ‘š â‰¥ 3ğ‘™ âˆˆ N,
and ğ» : {0, 1}âˆ— â†’ Zğ‘ is a hash function.
ğ‘šÃ—ğ‘™
â€“ PubGen(ğ‘ ğ‘˜). Parse ğ‘ ğ‘˜ as u. Choose a random matrix A âˆˆ F
ğ‘
ğ‘. Compute e = Ax + u and ğ‘¦ = ğ‘”ğ» (x)
ğ‘™
and a random vector x âˆˆ F
and output ğ‘ğ‘˜ = (A, e, ğ‘¦).
â€“ Enc(ğ‘ğ‘˜, ğ‘ ). Parse ğ‘ğ‘˜ as (A, e, ğ‘¦). Choose a random ğ‘Ÿ âˆˆ Zğ‘. Com-
pute ğ‘0 = ğ‘”ğ‘Ÿ
and ğ‘1 = ğ‘¦ğ‘Ÿ âŠ• ğ‘  and output ğ‘ = (A, e, ğ‘0, ğ‘1).
â€“ Dec(ğ‘ ğ‘˜ (cid:4), ğ‘). Parse ğ‘ ğ‘˜ (cid:4) as u
(cid:4) =
(cid:4)). Output âŠ¥ if the decoding algorithm is aborted
(cid:4) and ğ‘ as (A, e, ğ‘0, ğ‘1). Compute x
Decodeğœ (A, eâˆ’u
and otherwise ğ‘  = ğ‘1 âŠ• ğ‘ğ» (x(cid:4))
Since the correctness is clear, below, we sketch the security.
Theorem 3.2. The AFEM scheme is semantic secure guaranteed
by the decisional-LWE assumption and DDH assumption under the
random oracle model.
0
.
Our goal is to show that any PPT adversary A can only break
the semantic security with negligible advantage. Next, we show the
security via the following hybrids.
Hy.0. This is the real game with any PPT adversary A and a
challenger C. The game outputs 1 if ğ‘ (cid:4) = ğ‘ and 0 otherwise. We
define the advantage Adv
(ğœ†) = ğ‘ƒğ‘Ÿ [ğ‘ = ğ‘ (cid:4)].
Hy.1. Hy.1 is identical to Hy.0 except that we use e
(cid:4) from the
uniform distribution to replace the second element e = Ax + u in
Hy0
A
Hy1
A
Hy0
A
(ğœ†) â‰¤ Adv
(cid:4) is com-
ğ‘ğ‘˜. Under the decisional-LWE assumption, the uniform e
putationally indistinguishable from e = Ax + u with computational
distance ğ‘›ğ‘’ğ‘”ğ‘™ (ğœ†). Thus, we have Adv
(ğœ†) +ğ‘›ğ‘’ğ‘”ğ‘™ (ğœ†).
Hy.2. Hy.2 is identical to Hy.1 except that we use â„ from the
uniform to replace ğ» (x), and the random oracle guarantees no
PPT adversary can distinguish ğ» (x) from the uniform. Further, the
discrete-logarithm assumption guarantees no one has the ability to
obtain x given ğ‘¦ and ğ‘”, which implies that no PPT adversary can
tell the diffidence between ğ‘¦ = ğ‘”ğ» (x) and ğ‘¦ (cid:4) = ğ‘”â„
. Thus, we have
Adv
Hy1
A
Hy.3. Hy.3 is identical to Hy.2 except that we use ğ‘§ from the
uniform to calculate ğ‘ (cid:4)
. Under the decisional Diffie-Hellman
1
(DDH) assumption, ğ‘ (cid:4)
1 is computationally indistinguishable from ğ‘1
(ğœ†) â‰¤
with computational distance ğ‘›ğ‘’ğ‘”ğ‘™ (ğœ†), thus, we have Adv
(ğœ†) + ğ‘›ğ‘’ğ‘”ğ‘™ (ğœ†).
(ğœ†) â‰¤ Adv
= ğ‘  âŠ•ğ‘”ğ‘§
Hy2
A
Hy2
A
Hy3
A
(ğœ†) + ğ‘›ğ‘’ğ‘”ğ‘™ (ğœ†). In Hy.3, all the elements of both the public
Adv
key and the ciphertext are uniformly random and independent of
Hy3
the message. Hence, Adv
A
Hy0
(ğœ†) â‰¤ 1/2+ğ‘›ğ‘’ğ‘”ğ‘™ (ğœ†). Therefore, the adver-
A
sary A can break the semantic security with negligible advantage.
This completes the sketched proof.
Finally, we have Adv
(ğœ†) = 1/2.
3.3 Construction for Biometric Vector Set
We propose the second AFEM construction for secret keys in the
form of biometric vector sets, which means that the biometric
characteristics of a participant can be converted into a set of strings.
Assuming the secret key is ğ‘ ğ‘˜ = {u1, . . . , uğ‘› } where uğ‘— âˆˆ {0, 1}âˆ—
for ğ‘— âˆˆ [1, ğ‘›] and the closeness is defined by set difference, we give
the technical description and construction as follows.
3.3.1 Generating Public Key. Different from biometric vector, bio-
metric vector set usually consists of many relatively short vectors
(but each vector still has enough entropy) that are not suitable for
LWE-based constructions. Fortunately, we can obtain many of the
same biometric vectors in two captures due to the relatively short
length. Then, these biometric vectors can be treated as traditional
secret keys as in Section 3.2. Specifically, for uğ‘— âˆˆ ğ‘ ğ‘˜ (ğ‘— âˆˆ [1, ğ‘›]),
the corresponding partial public key is ğ‘¦ ğ‘— = ğ‘”ğ» (uğ‘— ) , where ğ‘” is
a generator of a group and ğ» : {0, 1}âˆ— â†’ Zğ‘ is a hash function.
Considering the relatively short length, we can further require ğ»
to be a computationally expensive hash function.
3.3.2 Encapsulating Message. To encapsulate a message ğ‘ , we also
employ an ElGamal-like encryption as in Section 3.2. Instead of en-
crypting ğ‘  with each partial public key, we first divide ğ‘  into ğ‘› shares
with a (ğ‘¡, ğ‘›) Verifiable Secret Sharing (VSS) scheme [23] and then
encrypt each share with one partial public key. To further protect
the encrypted shares, we transform them into a set of points and ob-
tain a polynomial through interpolation. Specifically, we employ the
VSS scheme proposed by Paul Feldman whose share generation algo-
rithm is VSS.ShareGen(ğ‘ , ğ‘¡, ğ‘›) â†’ ({ğ‘ 1, . . . , ğ‘ ğ‘› }, {ğ‘ğ‘œğ‘š0, . . . , ğ‘ğ‘œğ‘šğ‘¡ âˆ’1}).
A random value ğ‘Ÿ âˆˆ Zğ‘ is selected for encrypting each share as
(ğ‘”ğ‘Ÿ , ğ›½ ğ‘— = ğ‘¦ğ‘Ÿ
ğ‘— âŠ• ğ‘  ğ‘— ) (ğ‘— âˆˆ [1, ğ‘›]). Then, another random value ğ‘Ÿ (cid:4) âˆˆ Zğ‘
is selected and each ğ›½ ğ‘— is transformed into a point (ğ›¼ ğ‘— = ğ‘¦ğ‘Ÿ (cid:4)
ğ‘— , ğ›½ ğ‘— ). Fi-
nally, we interpolate the unique polynomial ğ‘ğ‘œğ‘™ğ‘¦ of degree ğ‘›âˆ’1 over
the points {(ğ›¼1, ğ›½1), . . . , (ğ›¼ğ‘›, ğ›½ğ‘›)} that consists of ğ‘› coefficients.
Session 10B: Crypto and Protocol Security CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2621P0
P1
Init Phase
Run AFEM.Setup(ğœ†, ğ‘¡ ) â†’ ğ‘ğ‘ğ‘Ÿ
Set
ğ‘ğ‘ = ğ‘ğ‘ğ‘Ÿ
Generate
Run AFEM.PubGen(ğ‘ ğ‘˜0) â†’ ğ‘ğ‘˜0
ğ‘ ğ‘˜0 âˆˆ SK
$â† S
ğ‘ 0
Choose
Run AFEM.Enc(ğ‘ğ‘˜1, ğ‘ 0) â†’ ğ‘0
ğ‘ ğ‘˜ (cid:4)
0
âˆˆ SK
Generate
Run AFEM.Dec(ğ‘ ğ‘˜ (cid:4)
0
Output ğ‘˜0 = ğ» (ğ‘ğ‘˜0 ||ğ‘ğ‘˜1 ||ğ‘0 ||ğ‘1 ||ğ‘ 0 ||ğ‘  (cid:4)
1
, ğ‘1) â†’ ğ‘  (cid:4)
1
KeyGen Phase
ğ‘ğ‘˜0
ğ‘ğ‘˜1
AKE Phase
ğ‘0
ğ‘1
-
-


)
Generate
Run AFEM.PubGen(ğ‘ ğ‘˜1) â†’ ğ‘ğ‘˜1
ğ‘ ğ‘˜1 âˆˆ SK
$â† S
ğ‘ 1
Choose
Run AFEM.Enc(ğ‘ğ‘˜0, ğ‘ 1) â†’ ğ‘1
ğ‘ ğ‘˜ (cid:4)
1
âˆˆ SK
Generate
Run AFEM.Dec(ğ‘ ğ‘˜ (cid:4)
1
Output ğ‘˜1 = ğ» (ğ‘ğ‘˜0 ||ğ‘ğ‘˜1 ||ğ‘0 ||ğ‘1 ||ğ‘  (cid:4)
0
, ğ‘0) â†’ ğ‘  (cid:4)
0
||ğ‘ 1)
Figure 2: Detail of our BAKE framework.
3.3.3 Decapsulating with Implicit Authentication. Generally, a (ğ‘¡, ğ‘›)
VSS scheme has the property that any ğ‘¡ or more than ğ‘¡ shares can
recover ğ‘  while any less than ğ‘¡ shares reveal no information about
ğ‘ , and check whether the shares can be used to reconstruct the mes-
sage. Therefore, the authentication is guaranteed implicitly. Specifi-
cally, ğ‘› encrypted shares are obtained from the polynomial ğ‘ğ‘œğ‘™ğ‘¦ and
are decrypted as in Section 3.2. Then, each share can be verified by
running the verification algorithm VSS.Verify({ğ‘ğ‘œğ‘š0, . . . , ğ‘ğ‘œğ‘šğ‘¡ âˆ’1},
ğ‘  ğ‘— ), where the output 1 means that ğ‘  ğ‘— is valid. If the number of valid
shares is not less than the threshold ğ‘¡, all valid shares could be recov-
ered as the original message ğ‘  by running the share reconstruction
algorithm VSS.ShareRecon.
3.3.4 Putting it All Together. Let ğ‘ ğ‘˜ = {u1, . . . , uğ‘› }, ğ‘ ğ‘˜ (cid:4) = {u
(cid:4)
, . . . ,
1
(cid:4)
ğ‘› }, and ğ‘  âˆˆ G. The AFEM construction for the biometric vector
u
set is as follows.
â€“ Setup(1
ğœ†, ğœ). Output ğ‘ğ‘ğ‘Ÿ = (ğœ†, G, ğ‘, ğ‘”, ğœ, ğ‘›, ğ» ) where G is a cyclic
group of prime order ğ‘, ğ‘” is a generator of G, and ğ» : {0, 1}âˆ— â†’
Zğ‘ is a hash function.
â€“ PubGen(ğ‘ ğ‘˜). Parse ğ‘ ğ‘˜ as {u1, . . . , uğ‘› }. Compute ğ‘¦ ğ‘— = ğ‘”ğ» (uğ‘— ) for
ğ‘— âˆˆ [1, ğ‘›] and output ğ‘ğ‘˜ = {ğ‘¦1, . . . , ğ‘¦ğ‘› }.
(cid:4)
(cid:4)
1
(cid:2)
â€“ Enc(ğ‘ğ‘˜, ğ‘ ). Parse ğ‘ğ‘˜ as {ğ‘¦1, . . . , ğ‘¦ğ‘› }. Run VSS.ShareGen(ğ‘ , ğ‘› âˆ’
ğœ, ğ‘›) â†’ ({ğ‘ 1, . . . , ğ‘ ğ‘› }, {ğ‘ğ‘œğ‘š0, . . . , ğ‘ğ‘œğ‘šğ‘›âˆ’ğœ âˆ’1}). Interpolate a poly-
nomial ğ‘ğ‘œğ‘™ğ‘¦ on the point set {(ğ‘¦ğ‘Ÿ (cid:4)
ğ‘›, ğ‘¦ğ‘Ÿ
ğ‘› âŠ•ğ‘ ğ‘›)} where
1
ğ‘Ÿ (cid:4), ğ‘Ÿ $â† Zğ‘, and output ğ‘ = (ğ‘ğ‘œğ‘™ğ‘¦, ğ‘”ğ‘Ÿ (cid:4), ğ‘”ğ‘Ÿ, {ğ‘ğ‘œğ‘š0,. . ., ğ‘ğ‘œğ‘šğ‘›âˆ’ğœ âˆ’1}).
(cid:3)
â€“ Dec(ğ‘ ğ‘˜ (cid:4), ğ‘). Parse ğ‘ ğ‘˜ (cid:4) as {u
âŠ•ğ‘ 1),. . . , (ğ‘¦ğ‘Ÿ (cid:4)
, ğ‘¦ğ‘Ÿ
1
)ğ» (u(cid:4)
ğ‘— )
. . . , ğ‘ğ‘œğ‘šğ‘›âˆ’ğœ âˆ’1}). Compute ğ‘  (cid:4)
and run VSS.Verify({ğ‘ğ‘œğ‘š0, . . . , ğ‘ğ‘œğ‘šğ‘›âˆ’ğœ âˆ’1}, ğ‘  (cid:4)
ğ‘— ) to check the va-
lidity for ğ‘— âˆˆ [1, ğ‘›]. Output âŠ¥ if the number of valid shares is less
than ğ‘› âˆ’ ğœ and otherwise the output of VSS.ShareRecon on the
ğ‘› âˆ’ ğœ valid shares.
The correctness is clear and the semantic security is guaranteed