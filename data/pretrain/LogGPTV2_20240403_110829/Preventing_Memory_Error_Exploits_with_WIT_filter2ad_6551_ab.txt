ferent ﬁelds in a structure, union, or class). We use Phoenix
to compile each source ﬁle to MIR and write points-to con-
straints to a ﬁle. The analysis reads the constraints ﬁle, com-
putes the points-to sets, and stores them in a ﬁle.
The analysis assumes that the relative layout of inde-
pendent objects in memory is undeﬁned [9]. For exam-
ple in Figure 2, it assumes that correct programs will not
use t276, which is a pointer into the cgiCommand array,
to write to cgiDir. Compilers already make this assump-
tion when implementing standard optimizations. Under this
assumption, the analysis is conservative: a points-to set in-
cludes all objects that the pointer may refer to in executions
that do not violate memory safety (but it may include addi-
tional objects). Therefore, WIT has no false positives.
The write safety analysis classiﬁes instructions as safe
or unsafe: an instruction is marked safe if it cannot violate
write integrity. The analysis marks safe all MIR instruc-
tions without an explicit destination operand or whose des-
tination operand is a temporary, a local variable, or a global.
These instructions are safe because they either modify reg-
isters or they modify a constant number of bytes starting at
a constant offset from the frame pointer 1 or the data seg-
ment. Assuming the constants generated by the compiler
1The frame pointer is safe even with recursion and calls to alloca
because there is a guard page at the end of the stack to prevent stack
overﬂows. The prologues of functions with frames larger than a page and
alloca check if the pages they need are resident. Therefore, they fault
on the guard page to trigger stack growth when necessary. If the operating
system cannot grow the stack, it raises an exception.
and linker are correct, the write safety analysis does not in-
troduce false negatives because control-ﬂow integrity pre-
vents the attacker from bypassing our checks or changing
the data segment or the frame pointer. In the example in
Figure 2, all instructions are safe except instruction 6.
In addition,
the write safety analysis runs a simple
intra-procedural pointer-range analysis to compute writes
through pointers that are always in bounds. The instructions
that perform these writes are marked safe. Our pointer-
range analysis is a simpliﬁed version of the one described
in [47]. It collects sizes of aggregate objects (e.g., structs)
and arrays that are known statically. Then it uses sym-
bolic execution to compute the minimum size of the ob-
jects each pointer can refer to and the maximum offset of
the pointer into these objects. When the analysis cannot
compute this information or the offset can be negative, it
conservatively assumes a minimum size of zero. Our cur-
rent implementation can track constant offsets and offsets
that can be bound using Phoenix’s built-in value range in-
formation for numeric variables. Given information about
the minimum sizes, the maximum offsets, and the size of
the intended write, the analysis checks if writes through the
pointer are always in bounds. If they are, the corresponding
instruction is marked safe.
While making the global pass over all source ﬁles to col-
lect constraints for the points-to analysis, we also run the
write safety analysis. We write unsafe pointers to a ﬁle. A
pointer is unsafe if it is dereferenced for writing by an un-
safe instruction.
We use the results of the points-to and write safety anal-
ysis to assign colors to objects and to unsafe instructions.
We use an iterative process to compute color sets, which in-
clude objects and unsafe pointer dereferences that must be
assigned the same color because they may alias each other.
Initially, there is a separate color set for each points-to set
of an unsafe pointer: the initial color set for a points-to set
p → {o1, ..., on} is {[p], o1, ..., on}. Then we merge color
sets that intersect until we reach a ﬁxed point. We assign a
distinct color to each color set: we assign this color to all
objects in the color set and all instructions that write pointer
dereferences in the set. All the other objects in the origi-
nal program are assigned color zero. By only considering
points-to sets of unsafe pointers when computing colors, we
reduce the false negative rate and the overhead to maintain
the color table.
WIT uses a similar algorithm to assign colors to func-
tions that may be called indirectly. The differences are that
this version of the algorithm iterates over the points-to sets
of pointers that are used in indirect call instructions (except
indirect calls to functions in dynamically linked libraries),
and that it only considers the objects in these sets that are
functions. We can exclude indirect calls to library functions
because they use a pointer that our write checks protect from
being corrupted by the attacker. We assign a different color
to each color set. These colors are different from 0, 1, and
the colors assigned to unsafe objects. The rest of the code
is assigned color zero.
4. Instrumentation
We implemented WIT for 32-bit x86 machines running
Windows. We chose this architecture and operating sys-
tem because they are the most common today but it should
be easy to retarget our implementation to other architec-
tures and operating systems. We used several Phoenix plug-
ins [30] to generate WIT’s instrumentation. This section
starts by describing the color table. Then it explains in more
detail how we instrument the code.
4.1. Color table
WIT maintains a color table that maps memory ad-
dresses to colors. The color table must cover the whole
user virtual address space and it is accessed often by write
and indirect call checks. To achieve low space and time
overhead, we designed the color table to be compact and to
enable efﬁcient lookups and updates.
To keep the color table small, we divide the virtual mem-
ory of the instrumented program into aligned eight-byte
slots. The color table is implemented as an array with an
eight-bit color identiﬁer for each of these slots. Therefore,
it introduces a space overhead of only 12.5%.
We are able to record a single color for each eight-byte
slot because we generate code such that no two objects with
distinct colors ever share the same slot.
It is easy to en-
force this requirement for heap objects because they are
eight-byte aligned and for functions because they are 16-
byte aligned. But since the stack and data sections are only
four-byte aligned in 32-bit x86 architectures, we cannot cur-
rently force eight byte alignment of objects in these sections
without introducing runtime overhead.
Instead, we force unsafe objects and guard objects in the
stack and data sections to be four-byte aligned and we insert
a four-byte aligned pad after unsafe objects. For an unsafe
object of size s, the pad is eight-bytes long if (cid:2)s/4(cid:3) is even
and four-bytes long if (cid:2)s/4(cid:3) is odd. We set (cid:2)s/8(cid:3) color
table entries to the color of the unsafe object when the pad
is four-bytes long and (cid:2)s/8(cid:3)+1 when the pad is eight-bytes
long. We should be able to reduce the space overhead when
targeting 64-bit x86 architectures because the stack and data
sections are eight-byte aligned in these architectures.
Figure 3 shows how padding works. Depending on the
alignment at runtime, the pad gets the color of the unsafe
object, the guard, or both. All these conﬁgurations are legal
because the pads and guards should not be accessed by cor-
rect programs and the storage locations occupied by unsafe
objects are always colored correctly. Conceptually, the pads
allow the guards to “move” to ensure that they do not share
a slot with the unsafe objects.
Since our points-to analysis does not distinguish between
different ﬁelds in objects and between different elements in
arrays, we always assign the same color to all the elements
of an array and to all the ﬁelds of an object. Therefore, it
is not necessary to change the layout of arrays and objects,
which is important for backwards compatibility.
We only require eight bits to represent colors because
the write safety analysis is very effective at reducing the
number of objects that we must assign colors to. However,
it is possible that more bits will be required to represent
colors in very large programs. If this ever happens, there are
several things we can do. For example, we can increase the
size of color table entries to 16-bits and increase memory
slot sizes to 16-bytes, or use 8-bit color identiﬁers at the
expense of worse coverage.
The color table can be accessed efﬁciently. Since there
are 2 GB of virtual address space available for the user in
Windows XP and Windows Vista, we allocate 256 MB of
virtual address space for the color table 2. We rely on the
operating system to allocate physical pages for the color ta-
ble on demand when they are ﬁrst accessed. The base of
the color table is currently at address 40000000h. So to
compute the address of the color table entry for a storage
location, we take the address of the storage location, shift it
right by three, and add 40000000h.
The base of the color table can be at a different address.
For example, we changed the linker to place the base of
the table at address 0h. This reduces the number of bytes
needed to encode the instructions that access the table be-
cause we can omit the large constant. However, it had little
impact on the runtime overhead in our experiments.
To protect the color table from being overwritten by an
attacker, we read-protect the pages in the table that con-
tain the entries for the virtual address range occupied by
the table itself. With the base of the table at 40000000h,
we protect the pages in the address range 48000000h to
4A000000h to prevent reads and writes. Since we add
checks before unsafe writes and control-ﬂow integrity en-
sures that the attacker cannot bypass these checks, the at-
tacker cannot overwrite the color table because the write
check would trigger a read fault on the protected address
range. This technique was ﬁrst described in [44].
4.2. Inserting guards
We insert small guards before and after unsafe objects
in the vulnerable program. This improves WIT’s coverage
2It is possible to use a boot option to increase the user virtual address
space to 3 GB. In this case, we need to allocate more virtual address space
for the color table.
d
r
a
u
g
l
e
b
a
i
r
a
v
d
r
a
u
g
l
e
b
a
i
r
a
v
d
r
a
u
g
l
e
b
a
i
r
a
v
d
r
a
u
g
l
e
b
a
i
r
a
v
Memory Layout Color Table
Memory Layout Color Table
8-aligned
⎡s/4⎤is even
not 8-aligned
Memory Layout Color Table
8-aligned
Memory Layout Color Table
not 8-aligned
⎡s/4⎤is odd
Figure 3. Ensuring that two objects with distinct colors never share the same eight-byte slot. The pad after
unsafe objects takes the color of the guard, the unsafe object, or both depending on the alignment. The lowest
addresses are at the bottom of the ﬁgure.
when the points-to analysis is imprecise while adding little
runtime overhead. WIT is guaranteed to detect overﬂows
and underﬂows that write array elements sequentially until
an object boundary is crossed, which are the most common.
The guards are eight-bytes long to match the size of the
slots that we record colors for in the color table. The instru-
mentation to insert these guards is different for the stack,
heap, and global data sections.
To insert guards in the stack, we replace the compiler
phase that lays out local variables in a stack frame by our
implementation. We segregate safe local variables from un-
safe ones to reduce the space overhead. First, we allocate
contiguous storage for the safe local variables. Then we
allocate storage for the guards, pads, and unsafe local vari-
ables. This allows us to insert only n+1 guards and pads for
n unsafe local variables: the guard that prevents overﬂows
of a variable prevents underﬂows of the next variable.
In the rare case where a function argument is written by
an unsafe instruction, we cannot easily insert guards and
pads around it. Therefore, we copy the argument to a local
variable and rewrite the instructions to refer to the copy.
This local variable is marked unsafe and we insert guards
and pads around it.
We mark all heap-allocated objects as unsafe but we do
not insert pads or guards around them. The standard heap
allocator in Windows Vista, Windows XP SP2, and Win-
dows 2003 inserts an eight-byte header before each allo-
cated object. We use this header as a guard by simply setting
its color to 1 in the color table. Since heap objects and head-
ers are eight-byte aligned, we do not need pads either. This
optimization avoids space overhead, which could be signif-
icant for programs with many small allocations. In systems
with different heap allocators, we can achieve similarly low
overhead by modifying the allocator.
We add guards and pads between all variables in the
.data section and .bss sections but not in the read-only
data section (.rdata). We could use the same optimiza-
tions that we used for the stack but our results show that
they would have little impact on overall performance when
applied to globals.
We plan to implement an optimization that avoids the
need for most guards by laying out stack and global objects
such that adjacent objects have different colors.
4.3. Maintaining the color table
We rely on the operating system to initialize color table
pages to zero when they are ﬁrst accessed. This ensures
security by default: unsafe writes and indirect calls to an
address are not allowed unless we explicitly set the corre-
sponding color table entry.
We initialize the color table entries for global variables
and their guards at program start up. We use color zero for
guards of global variables. We also initialize the color ta-
ble entries corresponding to the ﬁrst instructions of allowed
indirect call targets at program start up. But we update the
color table dynamically when objects are allocated on the
stack or the heap.
We use an optimization to reduce the cost of updating
the color table when we allocate a new stack frame. Instead
of updating the color table entries for all objects in the stack
frame, we only update entries corresponding to unsafe local
variables and their guards on function entry. On function
exit, we reset the entries that we updated on function entry
to zero. This works because all safe objects have color zero,
which is the initial color of all color table entries. We use
color zero for guards of unsafe local variables.
We instrument function prologues and epilogues to set
and reset color table entries. This instrumentation is added
after the phase that lays out the stack frames. Therefore, it is
dependent on the target architecture. For example, we add
the following code sequence to the prologue of a function
with a single unsafe local variable with 12 bytes:
# 1 byte
push ecx
# 4 bytes
lea ecx,[esp+3Ch]
shr ecx,3
# 3 bytes
mov dword ptr [ecx+40000000h],00020200h #10 bytes
pop ecx
# 1 byte
This sequence saves ecx on the stack to use it as a tempo-
rary. Then it loads the address of the ﬁrst guard into ecx
and shifts it by three to obtain the index of the guard’s color
table entry. It uses this index to set the color table entries to
the appropriate colors. We set one color table entry for each
guard. For an unsafe object of size s, we set (cid:2)s/8(cid:3) color ta-
ble entries when (cid:2)s/4(cid:3) is odd and (cid:2)s/8(cid:3) + 1 when (cid:2)s/4(cid:3) is
even (see section 4.1). We use 2-byte and 4-byte moves to
reduce the space and time overhead of the instrumentation
In our example, the mov updates the
whenever possible.
four color table entries: the entries corresponding to guard
objects are set to 0 and those corresponding to the unsafe
local variable are set to two. The base of the color table is at
address 40000000h. If the base was at address 0h the mov
would be 6 bytes long. The ﬁnal instruction restores the
original value of ecx. The instrumentation for epilogues is
identical but it sets the color table entries to zero.
An alternative would be to update color table entries only
on function entry for all objects in the stack frame. This
alternative adds signiﬁcantly higher overhead because on
average only a small fraction of local variables are unsafe.
Additionally, WIT incurs no overhead to update the color
table when functions have no unsafe locals or arguments,