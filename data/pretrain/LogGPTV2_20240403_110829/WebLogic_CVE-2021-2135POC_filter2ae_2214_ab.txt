            if (map.put(o, NO_VALUE) == null) {
                return true;
            }
        }
        // 调用map.put
        map.put(this.wrap(o), NO_VALUE);
        return true;
    }
TreeMap.put()调用TreeMap.compare，最终会调用`comparator.compare((K)k1, (K)k2)`。
    public V put(K key, V value) {
        Entry t = root;
        if (t == null) {
            // 调用TreeMap.compare
            compare(key, key); // type (and possibly null) check
            ......
            return null;
        }
        int cmp;
        Entry parent;
        ......
        return null;
    }
    final int compare(Object k1, Object k2) {
        return comparator==null ? ((Comparable)k1).compareTo((K)k2) : comparator.compare((K)k1, (K)k2);
    }
如果这里comparator是我们构造的MvelExtractor实例，MvelExtractor继承了AbstractExtractor，便可以调用`AbstractExtractor.compare`，从而调用`MvelExtractor.extract`达到命令执行的目的。
    # AbstractExtractor.compare
    public int compare(Object o1, Object o2) {
        return SafeComparator.compareSafe((Comparator)null, this.extract(o1), this.extract(o2));
    }
    # MvelExtractor.extract
    public Object extract(Object oTarget) {
        // 调用MVEL.executeExpression执行命令
        return oTarget == null ? null : MVEL.executeExpression(this.getCompiledExpression(), oTarget);
    }
## 三、反序列化载体分析：
### 1、`SimpleBinaryEntry.toString()`的触发
反序列化到`SimpleBinaryEntry.toString()`的触发，在[360CERT](https://mp.weixin.qq.com/s/eyZfAPivCkMbNCfukngpzg)中提到用`com.sun.org.apache.xpath.internal.objects.XString.equals()`。当`XString.equals()`的参数是SimpleBinaryEntry实例时，可以调用`SimpleBinaryEntry.toString`。
    public boolean equals(Object obj2)
    {
      if (null == obj2)
        return false;
      else if (obj2 instanceof XNodeSet)
        return obj2.equals(this);
      else if(obj2 instanceof XNumber)
          return obj2.equals(this);
      else
        return str().equals(obj2.toString());//，当传入的是simpleBinaryEntry，调用SimpleBinaryEntry.toString
    }
这时候需要触发`XString.equals(simpleBinaryEntry)`，我们可以考虑Map的put方法，因为Map一般在插入元素时做比较会调用equal，并且Map有个特别之处就是它一般不限制对象的类型，我们可以构造Map的Key或者Value为不同的对象如XString实例或者simpleBinaryEntry实例。
`com.tangosol.util.LiteMap`继承了`com.tangosol.util.InflatableMap`，`InflatableMap.put`中当`InflatableMap.m_nImpl==1`，通过调用`Objects.equals(xString,
simpleBinaryEntry)`可以调用`xString.equals(simpleBinaryEntry)`。所以LiteMap构造时传入的Map是`map`和`map`。
    public V put(K key, V value) {
        switch(this.m_nImpl) {
        case 0:
            this.m_nImpl = 1;
            this.m_oContents = this.instantiateEntry(key, value);
            return null;
        case 1:
            Entry entry = (Entry)this.m_oContents;
            K entryKey = entry.getKey();
            V prevValue = null;
            // this.m_nImpl==1，调用Objects.equals(key, entryKey)，Objects.equals(xString, simpleBinaryEntry)
            if (Objects.equals(key, entryKey)) {
                prevValue = entry.getValue();
                entry.setValue(value);
            } else {
                Entry[] aEntry = new Entry[8];
                aEntry[0] = entry;
                aEntry[1] = this.instantiateEntry(key, value);
                this.m_nImpl = 3;
                this.m_oContents = aEntry;
            }
            return prevValue;
        ...
        ...
        }
    }
    public static boolean equals(Object a, Object b) {
        // 当a!=b，返回a.equals(b)，当a是xString，b是simpleBinaryEntry，a肯定不等于b，调用xString.equals(simpleBinaryEntry)
        return (a == b) || (a != null && a.equals(b));
    }
###  2、反序列化入口
那么接下来是找到反序列化入口，必然涉及到readObject或readExternal等类似读取的方法，如何在这些方法中调用`LiteMap.put`。`com.tangosol.util.processor.ConditionalPutAll`实现了`com.tangosol.io.ExternalizableLite`并重写了readExternal，在readExternal中构造了LiteMap实例，并且调用了`com.tangosol.util.ExternalizableHelper.readMap`将map的属性读取赋值给LiteMap实例。
    public void readExternal(DataInput in) throws IOException {
        this.m_filter = (Filter)ExternalizableHelper.readObject(in);
        // 创建LiteMap对象
        Map map = this.m_map = new LiteMap();
        // 调用ExternalizableHelper.readMap处理map的反序列化
        ExternalizableHelper.readMap(in, map, (ClassLoader)null);
    }
`com.tangosol.util.ExternalizableHelper.readMap`中调用了`map.put`，假如oKey=xString、oVal=simpleBinaryEntry，刚好就能调用这里的map是LiteMap的实例，所以会调用`com.tangosol.util.InflatableMap.put(xString,simpleBinaryEntry)`，跟前面的链就连上了。
    public static int readMap(DataInput in, Map map, ClassLoader loader) throws IOException {
        int cEntries;
        if (in instanceof PofInputStream) {
            PofInputStream inPof = (PofInputStream)in;
            inPof.getPofReader().readMap(inPof.nextIndex(), map);
            cEntries = map.size();
        } else {
            cEntries = in.readInt();
            for(int i = 0; i   