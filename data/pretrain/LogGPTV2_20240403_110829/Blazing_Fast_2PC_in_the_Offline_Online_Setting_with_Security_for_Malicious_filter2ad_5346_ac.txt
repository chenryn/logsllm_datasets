i=1 and ∆ = x1 ⊕ x2 to P2, who checks that for every i it holds that δ 0
(cid:16)
(cid:17)
i ⊕ δ 1
i ⊕ δ 1
i = x1 ⊕ x2)
i = ∆.
3. P2 decommits to W = W1, . . . ,Ws.
4. For i = 1, . . . ,s, party P1 sends decommitments Decom
(cid:16)
(cid:17)
(cid:17)⊕ Decom
cWi
i
(cid:16)
(cid:16)
cWi
i
, Decom
to P2.
(cid:17)
dWi
i
= δWi
i
.
dWi
i
5. For i = 1, . . . ,s, party P2 veriﬁes that Decom
6. If all checks pass, then P2 outputs ∆.
we are given an input (c,d,∆) and we are guaranteed that there
exist x1,x2 such that c ∈ SC(x1) and d ∈ SC(x2). The “aim” is then
just to determine if x1⊕x2 = ∆ or x1⊕x2 (cid:54)= ∆. (Note that if c and d
are such that they are not valid commitments at all, then this will be
detected in the checks carried out in the cut-and-choose protocol;
i.e., when b = 1.)
We follow the deﬁnition of [12] regarding interactive proofs for
promise problems. Informally, completeness must hold for every
(c,d,∆) ∈ P∩ Q, soundness guarantees that the veriﬁer will reject
for any (c,d,∆) ∈ P\ Q, and nothing is required for (c,d,∆) /∈ P.
In addition to the above, we prove that Protocol 3.2 securely
computes the functionality FCom∆ZK, deﬁned in Figure 3.1, in the
presence of a corrupt P2. We stress that in the case that P1 is cor-
rupted we rely on the soundness property of the proof (since Pro-
tocol 3.2 does not securely compute FCom∆ZK in the presence of a
corrupt P1).
In the full version we prove the following:
THEOREM 3.3. If commit is a perfectly-binding commitment
scheme and ExtractCom is a perfectly-hiding extractable commit-
ment scheme, then the commitment phase of Protocol 3.2 is a
perfectly-binding commitment scheme, and the proof phase is an
interactive proof system for the promise problem (P,Q) deﬁned
above. In addition, Protocol 3.2 securely computes FCom∆ZK in
the presence of a corrupt P2.
3.1.2 Replacing the Perfectly-Binding Commitment
Note that so far we have assumed that commit(·) is a perfectly-
binding commitment. In practice, perfectly-binding commitments
are less efﬁcient than computationally binding ones. For example,
with an appropriate assumption on the cryptographic hash function,
commit(x) = H(x;r) is a computationally binding and computa-
tionally hiding commitment. If we model H as a random oracle,
then commit is still only computationally binding. However, it is
extractable, and thus we can prove the interactive proof of Proto-
col 3.2 to be a proof of knowledge. This achieves the same effect
as soundness. (Note that once we model H as a random oracle, we
can also use it as the statistically-hiding extractable commitment.)
In order to use any computationally-binding commitments, in-
cluding like that above but without resorting to the random ora-
cle model, the following change can be made to Protocol 3.2. Let
σ be a seed to a pseudorandom generator G, and deﬁne SC(x) as
(i.e., SC(x) = (cid:104)SCom(x,r1), . . . , SCom(x,rs)(cid:105)) where the underly-
ing commitment uses H, but all of the randomness in generating
SC is taken from G(σ ), and a perfectly-binding extractable com-
mitment is given to σ alone. This has the advantage that a single
perfectly-binding commitment to a short string sufﬁces to deﬁne
all of SC as perfectly binding. The promise problem used to model
the interactive proof, and the proof of soundness then remains the
same (with the additional requirement that P1 is polynomial time
and cannot efﬁciently open any of the individual commitments to
anything else). This adds one extractable commitment per circuit
(which can be implemented via El Gamal and so costs 2 exponen-
tiations per circuit), plus a single zero-knowledge proof of knowl-
edge of the El Gamal private key generated by P1 (that is done only
once for all circuits and costs just 9 exponentiations).
3.2 Extending to Many Messages
The functionality of Figure 3.1 works with only two messages
from P1 (and so only for two circuits). We would like to use it
for a larger number of messages, where P2 can choose any subset
of them to be revealed and learn the XOR differences between the
remaining ones (as in the cut-and-choose case where a random sub-
set of the circuits are evaluated and consistency must be proved for
them). In addition, for our online/ofﬂine 2PC protocol we would
like P2 to be able to pick different subsets of the unrevealed mes-
sages, and learn the XOR differences for all the messages in each
subset (in the online/ofﬂine setting, the evaluated circuits are ran-
domly thrown into buckets and each bucket is used for a different
execution; thus the XOR differences is needed inside each bucket).
The extended functionality is deﬁned in Figure 3.4. The subsets
I1, . . . ,IN are the buckets of circuits to be evaluated in the online
phase (each bucket is of size B). Thus, P2 learns the XOR differ-
ences between every pair in each bucket; this enables it to verify
consistency as described above. Observe that the indices of values
not in any of I1, . . . ,IN are circuits that are checked; thus, the values
corresponding with these indices are revealed.
The main difference between the protocol that securely computes
the extended functionality in Figure 3.4 and the protocol in Fig-
583ure 3.2 is that in the general case, P2 commits to all of the subsets
I1, . . . ,IN initially (and not just a single bit b). The detailed protocol
appears in the full version.
FIGURE 3.4
(FUNCTIONALITY FExCom∆ZK).
FExCom∆ZK runs with parties P1 and P2, a public index M (saying
how many inputs there are), a public constant N (saying how many
subsets there are), and a public constant B (saying how big each
subset is), as follows:
Input: FExCom∆ZK receives M messages (x1, . . . ,xM) from P1, and
a series of subsets I1, . . . ,IN ⊂ [M] from P2.
Output: For j ∈ [N], let Ij = {i1
⊕
}B−1
k=1 . Then, FExCom∆ZK sends ∆1, . . . ,∆N to P2. In addition,
xik+1
. Finally,
FExCom∆ZK sends P2 the value xi, for every i /∈(cid:16)(cid:83)N
j } and let ∆ j be the set {xik
FExCom∆ZK sends I1, . . . ,IN to P1.
The Extended Commit-and-Difference Proof Functionality
j , . . . ,iB
j
j
(cid:17)
j=1 Ij
3.3 Using FExCom∆ZK in Cut-and-Choose
As we have mentioned, for every circuit in the cut-and-choose,
P1 commits to the string m which contains all of the “signal” bits σ
on its input wires (this requires 2s basic commitments commit). In
addition, the input garbled labels are committed; the commitments
are in the correct order (with the 0 label ﬁrst) if σ = 0, and in the
opposite order if σ = 1. When checking a circuit, these commit-
ments are also veriﬁed. For the evaluation circuits, let gc1, . . . ,gcl
be the circuits to be evaluated, and let m1, . . . ,ml be their commit-
ted signal bit labels. Then, for every i = 1, . . . ,l, party P1 sends P2
the string ˆxi = mi⊕x, where x is its input to the secure computation.
In addition, for every i = 1, . . . ,l − 1, it deﬁnes ∆i = ˆxi ⊕ ˆxi+1 and
proves that mi ⊕ mi+1 = ∆i (using FExCom∆ZK). The overall cost
is 2s basic commitments commit per circuit plus two extractable
commitments, which is very cheap.
Advantages Over Previous Input Consistency Proofs. Note that
the number of commitments in Protocol 3.2 is only 2s for every
circuit. In the online/ofﬂine setting, the number of circuits is very
small (typically 5-10, depending on the parameters) and thus this
costs signiﬁcantly less than a single commitment per input bit (un-
less the input is very small). When commit is implemented as
described above using computationally-binding commitment, the
resulting protocol is more efﬁcient than those of [25, 30], and sig-
niﬁcantly more simple to understand and implement. From a theo-
retical standpoint, our protocol can also be based on very standard
assumptions (though with the additional negligible overhead of the
two exponentiations needed by the El Gamal encryption used to
implement a perfectly-binding commitment), whereas [25] requires
correlation robustness and [30] requires Free-XOR.
Another advantage of our new consistency check is for amortized
cut-and-choose protocols like [15, 23] in the online/ofﬂine setting.
Both works use inefﬁcient solutions for the input-consistency is-
sue (i.e., using discrete-log ZK proofs). It is unclear how to adapt
those results to work with the protocol of [30] (when P1 has many
different inputs). Note that [23] mentions that its protocol can be
adapted to work with the protocol [25]. However, the resulting pro-
tocol seems to be very complicated and difﬁcult to implement. We
believe that simplicity is a very important factor for secure proto-
cols, and we ﬁnd our solution to be more simple to describe and
implement than the one of [25].
4. OPTIMIZED 2PC IN THE ONLINE/ OF-
FLINE SETTING
We base our protocol on the results of [23], where a protocol
for multiple 2PCs in the online/ofﬂine model is shown. First, we
adapt it to use the technique of [20, 25, 30] for protecting against
selective-OT attacks. Next, we plug in our new technique for check-
ing P1’s input consistency as discussed in Section 3.3. These two
modiﬁcations essentially replace all the exponentiations required
by the protocol of [23] for the input wires with cheaper crypto-
graphic operations (and a small number of exponentiations that is
independent of the input size).
Since our goal is to minimize the cost of the online stage, we
chose to work in the random-oracle model, so we could construct
adaptively secure garbled circuits in an efﬁcient way. We there-
fore further utilize the power of the random-oracle model and op-
timize other parts of the protocol. For example, we replace all ex-
tractable commitments (that require exponentiations) with random-
oracle based commitments (that requires only hash function calls),
and we reduce the number of encryptions needed for the cheating
recovery method presented in [23].
The protocol is described in Appendix A in Figures A.2 and A.3
and uses the sub-protocols of Figure A.1. In the full version we
prove the following:
THEOREM 4.1. Let commit and ExtractCom be implemented
using a random oracle H (i.e., commit(m,r) = ExtractCom(m,r) =
H(m;r)). For any function f , if PRF is a secure pseudorandom
function and the garbling scheme in use is adaptively secure, then
Protocols A.2-A.3 securely compute f with multiple executions (ac-
cording to the deﬁnition of [23]).
We remark that the protocol can be slightly modiﬁed to be secure
given an adaptively secure garbling scheme and without utilizing
the random oracle for commit and ExtractCom. The only modi-
ﬁcation needed is to commit on all the commitments of the input
labels using a trapdoor commitment, so that in the simulation in
case P1 is corrupted, the simulator could change the commitments
on the input labels after it learns P1’s input. The cost of this mod-
iﬁcation is small – only one additional trapdoor commitment per
garbled circuit.
5. PROTOTYPE IMPLEMENTATION
Our goal is to provide an end-to-end system for multiple 2PC
executions in the online/ofﬂine setting. First, the system can pro-
vide the user very good sets of parameters. Next, the system is
optimized both crypto-wise (e.g., using the random-oracle where
suitable) and engineering-wise (e.g., using parallelism where pos-
sible). Some key parts of the system are the following:
Additional optimizations in the random-oracle model. First, re-
call that everywhere we use an extractable commitment, we actu-
ally use commit(x;r) = H(x;r). Second, since the labels of P2’s
input wires are random, we can use a second random-oracle H2,
and ask P1 to commit on label W just by sending H2(W ). This re-
duces P1’s inputs to the OTs by a factor of two, and still preserves
security as H2(W ) does not reveal any information about W if W
has enough entropy (which happens in our case, as W is at least 80
bits long random string).
Finding good parameters. We implemented a program that is
given the values of s (statistical security parameter) and N (the over-
all number of executions desired), and calculates the parameters
(based on Lemmas 2.2 and 2.3) that minimize the overall number
of circuits (to minimize the run-time of the ofﬂine stage) or the
number of evaluation circuits per bucket (to minimize the run-time
of the online stage). Similarly to what was observed by [23], the
parameters we get are much better than what the upper bounds of
[23] give. See Table 1 for several example sets of parameters for
584N
8
32
128
1024
4096
Total number of
circuits
136
165
362
437
998
1143
5627
5689
18005
25600
Number of eval
circuits per 2PC
10
8
7
6
6
5
5
4
4
3
Number of
circuits per 2PC
16.95
20.51
11.29
13.63
7.79
8.92