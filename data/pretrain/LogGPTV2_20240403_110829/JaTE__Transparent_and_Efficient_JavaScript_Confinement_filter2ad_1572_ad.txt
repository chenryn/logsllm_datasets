dertook a large-scale evaluation involving all sites from the
Alexa Top 500. Using the same extension used to calculate
Benchmark
JaTE Caja ES5 Caja ES5/3
Canvas Clock
Markdown
Game of Life
16.8%
3%
4.1%
64.9%
136%
566%
1091%
2310%
640%
Figure 9: JaTE vs Caja Overhead Comparison
Feature
Strict mode error
Use of direct eval
Native prototype extension
Top 500
87.4%
30.9%
48.5%
Figure 10: Related Work Transparency
page load overheads, we loaded each site, waited 5 seconds
after the load event, took a screenshot and logged Java-
Script errors, both with and without JaTE. To automate
the inspection of a large number of sites and minimize false
negatives, we compared the error logs and the screenshots of
both runs for each site. If we found diﬀerent error messages
in the two logs, we inspected the screenshots side-by-side
for missing content. If content appeared to be missing, we
conﬁrmed the test results manually. We did not ﬁnd any
page that could not be loaded correctly due to a shortcom-
ing of our approach. Thus, we conclude that JaTE achieves
transparency for today’s web sites.
6.2.2 Related Work Transparency
To estimate the transparency of related work, we used the
test extension again to load the same set of pages while con-
ﬁning all code in the strict mode subset used by Caja ES5
mode, SES and JSand. As shown in Figure 10, over 80%
of sites use third-party scripts that break in strict mode,
and hence these sites are not transparent with the afore-
mentioned solutions.
Forcing strict mode is not their only shortcoming. For
example, they also prevent the use of direct eval seman-
tics and freeze native prototypes. To estimate the trans-
parency impact of these two features, we ran our testing
harness again and logged the use of these features in each
web site, as shown in Figure 10. Both restrictions causes
enough transparency problems to discourage websites from
adopting these conﬁnement solutions.
We also estimated the impact of strict mode on the social
media buttons conﬁned in Section 6.1.1. All the buttons
failed to load.
6.3 Security Evaluation
To evaluate the security of JaTE, we tested it against a
collection of attack vectors maintained by Google Caja [4],
which contains 48 diﬀerent attacks. 23 of these attacks are
not applicable as they rely on non-standard features and do
not work on Firefox. We augmented the test suite with 5
attacks of our own. These attacks either attempt to obtain
unmediated access to cross-compartment references or intro-
duce unconﬁned code into the page. For example, the Func-
tion constructor can be accessed through the constructor
property of the prototype of Number, to create dynamic code,
such as (3).constructor.constructor("return window").
We put these attacks into categories as shown in Figure 11.
JaTE successfully stopped all other attack vectors, medi-
ating all accesses and running dynamically generated code
using the correct principal.
158
Category
# of attacks
Prototype poisoning
Global object leak
Dynamic Code
Private data access and poisoning
Code obfuscation
caller and arguments stealing
Lexer confusing
Policy related
4
3
7
4
3
3
2
5
Figure 11: Caja Attack Vectors
7. RELATED WORK
In this section, we discuss previous related research, fo-
cusing our attention on eﬀorts that have not already been
discussed in detail.
7.1 Language-based isolation
ADsafe [11] and GateKeeper [13] deﬁne a subset of Java-
Script amenable to static analysis to enforce policies using
static veriﬁcation. Gatekeeper [13] restricts JavaScript to
perform static points-to analysis to reason about unreacha-
bility of security-sensitive resources. ADsafe [11] provides
controlled DOM access to third-party code by oﬀering a
narrow interface through the ADSAFE object, while impos-
ing signiﬁcant language restrictions aimed at ensuring that
all DOM interaction happens through the object. For exam-
ple, ADsafe prevents access to eval and the use of subscript
notation. Despite these restrictions, bugs were found [28]
in ADsafe, demonstrating the diﬃculty of realizing object-
granularity access control in JavaScript.
BrowserShield [29] was one of the earliest works in this
area. It avoided language restrictions by relying primarily
on runtime checking. They were the ﬁrst to propose the
idea of runtime rewriting to handle eval that we have used
in JaTE as well. Caja [20] also relies heavily on rewriting
and runtime checking. In particular, accesses to identiﬁers,
attributes and functions need to be checked for safety, which
can lead to slowdowns by an order of magnitude or more for
some programs.
7.2 Frame-based isolation
AdJail [34] isolates third-party code in an iframe and uses
postMessage to transparently cooperate with the ﬁrst-party
page. The advantage of this approach is that it is easier
to reason about complete mediation, since every communi-
cation must explicitly pass through the postMessage prim-
itive. Speciﬁcally, it sets up a shadow iframe containing
third-party code and DOM data from the real page that
was explicitly shared by the ﬁrst-party. Any modiﬁcation
to the shadow DOM by the third-party code is transmit-
ted to the real page and subject to a policy check before it
is reﬂected there. Treehouse [14] is a conceptually similar
approach using Web Workers instead of iframes.
Instead of propagating DOM changes, Mashic [17] and
Pivot [23] provide a transparent, synchronous interface for
cross- domain operations on top of postMessage, to support
conﬁnement of general-purpose code. Mashic rewrites all
code to continuation-passing style, while Pivot uses Gener-
ators to achieve the same goal using minor rewriting. How-
ever, they still fail to support complex interactions, such as
pass-by-reference.
AdSentry’s [12] goal is not only to fully mediate access
to DOM resources, but also to protect against drive-by-
downloads. To meet both goals, AdSentry runs third-party
code on a separate JavaScript engine secured using Native
Client sandbox [43]. DOM resources are kept in the main
engine, and complete mediation is achieved by forwarding all
DOM accesses from the shadow engine to the main engine.
MashupOS [42] criticizes the all-or-nothing approach of
the SOP and extends it to better support the trust re-
lationships commonly found in web mashups.
It identi-
ﬁes four modes of interaction and introduces new HTML
elements and security abstractions. On the other hand,
COWL [32] leverages traditional mandatory access control
and tracks the secrecy labels of each frame, preventing the
leakage of conﬁdential information to unauthorized parties.
However, both MashupOS and COWL still only support
coarse-grained policies; they don’t tackle object-granularity
access control that we seek in this paper.
The main problem with solutions in this category is that
they are not able to support complex interactions involving
passing object references or cross-frame function calls. As
a result, to preserve functionality, people are taking risk to
run third-party code directly in their websites.
7.3 Other
BEEP [15] allows a browser to examine and approve scripts
before they are executed, according to a policy provided by
the website as a JavaScript function. Content-Security Poli-
cies (CSPs) [31] are a mechanism developed by Mozilla to
restrict the inclusion of resources such as scripts, images and
frames into the web page to a speciﬁc subset of third-party
servers. These works were motivated at preventing code in-
jection attacks, e.g., cross-site scripting (XSS). Thus, their
mechanisms are helpful for classifying entire scripts as “al-
lowed” or “disallowed,” but they don’t help with the object-
level isolation and access control problem faced by JaTE.
Indeed, policy enforcement is not a promising approach for
blocking XSS since the inferred origin of the malicious script
would be the same as that of the ﬁrst-party. This is why XSS
defenses are mainly focused on detecting invalid script con-
tent, such as whole script [10] or partial script [27] content
that has been reﬂected from HTTP parameters.
ConScript [22] augments Internet Explorer with policy
check callbacks embedded directly in the JavaScript engine.
Its goal is to securely mediate the operations made by a
script, and apply a user-speciﬁed policy. WebJail [38] uses
an approach similar to ConScript but implemented on Fire-
fox. Its goal is to provide a higher-level interface to express
policies that impose further restrictions over the SOP, e.g.,
restricting access to local storage, or network operations.
The new HTML 5 speciﬁcation [3] includes coarse-grained
support for sandboxing iframes by specifying a subset of
capabilities for the contained document, such as running
JavaScript code or opening pop-up windows. While all of
these techniques are helpful for further restricting untrusted
scripts, note that they still only provide a single security
context (such as a frame) for the code. In contrast, JaTE
requires distinct security contexts to be maintained for the
host and third-parties, and distinct policies to be enforced
on them, while allowing them all to run within the same
frame.
8. CONCLUSION
This paper presented JaTE, a compartment-based solu-
tion for conﬁning third-party JavaScript code. Although
this problem is of great practical signiﬁcance, previous solu-
tions to this problem have not been amenable to real-world
159
deployment because they impose signiﬁcant restrictions that
break existing sites, or due to performance considerations.
In contrast, by leveraging JavaScript language features and
using a novel combination of code transformation and run-
time checking, JaTE can safely support the full JavaScript
language and full interaction among principals. Our evalu-
ation shows that JaTE is eﬃcient at conﬁning third-party
code on a range of web sites. Finally, JaTE requires no
browser modiﬁcation, and thus provides an easy path for
deployment on today’s web sites.
The focus of this paper has been on the development of
a policy enforcement framework. The next important chal-
lenge is the development of policies that achieve high-level
security objectives, without requiring undue amount of hu-
man eﬀort. An important advantage of JaTE is that it in-
tercepts every security relevant operation, and these can be
logged for subsequent analysis using techniques for policy
generation from such logs [30, 33, 40, 44].
9. REFERENCES
[1] Ad blocking with ad server hostnames.
http://pgl.yoyo.org/as/.
[2] Direct and indirect eval. http:
//perfectionkills.com/global-eval-what-are-the-options/.
[3] HTML5. http://www.w3.org/TR/html5/.
[4] JavaScript Attack Vectors. https:
//code.google.com/p/google-caja/wiki/AttackVectors.
[5] Lexer confusing attack. https://code.google.com/p/
google-caja/wiki/JsControlFormatChars.
[6] New York Times Latest Victim of Malware Ad Injections.
http:
//mashable.com/2009/09/15/new-york-times-malware/.
[7] Security advisory 201308013. https://code.google.com/p/
google-caja/wiki/SecurityAdvisory201308013.
[8] Yahoo’s malware-pushing ads linked to larger malware
scheme. http://www.pcworld.com/article/2086700/
yahoo-malvertising-attack-linked-to-larger-malware-scheme.
html.
[9] P. Agten, S. Van Acker, Y. Brondsema, P. H. Phung,
L. Desmet, and F. Piessens. JSand: Complete client-side
sandboxing of third-party javascript without browser
modiﬁcations. ACSAC ’12.
[10] D. Bates, A. Barth, and C. Jackson. Regular expressions
considered harmful in client-side XSS ﬁlters. In ACM
WWW, 2010.
[11] D. Crockford. ADsafe. http://www.adsafe.org, 2011.
[12] X. Dong, M. Tran, Z. Liang, and X. Jiang. AdSentry:
comprehensive and ﬂexible conﬁnement of JavaScript-based
advertisements. ACSAC ’11.
[13] S. Guarnieri and B. Livshits. GATEKEEPER: mostly static
enforcement of security and reliability policies for
JavaScript code. USENIX SECURITY ’09.
[14] L. Ingram and M. Walﬁsh. Treehouse: JavaScript sandboxes
to help web developers help themselves. USENIX ATC ’12.
[15] T. Jim, N. Swamy, and M. Hicks. Defeating script injection
attacks with browser-enforced embedded policies. In
Proceedings of the 16th international conference on World
Wide Web, pages 601–610. ACM, 2007.
[16] Z. Liang, W. Sun, V. Venkatakrishnan, and R. Sekar.
Alcatraz: An isolated environment for experimenting with
untrusted software. ACM TISSEC, 2009.
[17] Z. Luo and T. Rezk. Mashic compiler: Mashup sandboxing
based on inter-frame communication. CSF ’12.
[18] S. Maﬀeis, J. C. Mitchell, and A. Taly. Object capabilities
and isolation of untrusted web applications. S&P ’10.
[19] S. Maﬀeis and A. Taly. Language-based isolation of
untrusted JavaScript. In CSF, CSF ’09, Washington, DC,
USA, 2009. IEEE Computer Society.
[20] M. S. Mark S Miller, B. Laurie, I. Awad, and M. Stay.
Caja: Safe active content in sanitized JavaScript, 2008.
[21] A. Mettler, D. Wagner, and T. Close. Joe-E: A
security-oriented subset of java. NDSS ’10.
[22] L. A. Meyerovich and B. Livshits. ConScript: specifying
and enforcing ﬁne-grained security policies for JavaScript in
the browser. S&P ’10.
[23] J. Mickens. Pivot: Fast, synchronous mashup isolation
using generator chains. S&P ’14.
[24] M. Miller. Secure EcmaScript 5.
http://code.google.com/p/es-lab/wiki/SecureEcmaScript.
[25] M. S. Miller. Robust Composition: Towards a Uniﬁed
Approach to Access Control and Concurrency Control. PhD
thesis, 2006.
[26] N. Nikiforakis, L. Invernizzi, A. Kapravelos, S. Van Acker,
W. Joosen, C. Kruegel, F. Piessens, and G. Vigna. You are
what you include: large-scale evaluation of remote
JavaScript inclusions. CCS ’12.
[27] R. Pelizzi and R. Sekar. Protection, usability and
improvements in reﬂected XSS ﬁlters. In ACM ASIACCS,
2012.
[28] J. G. Politz, S. A. Eliopoulos, A. Guha, and
S. Krishnamurthi. ADsafety: Type-based veriﬁcation of
JavaScript sandboxing. USENIX SECURITY ’11.
[29] C. Reis, J. Dunagan, H. J. Wang, O. Dubrovsky, and
S. Esmeir. BrowserShield: vulnerability-driven ﬁltering of
dynamic HTML. OSDI ’06.
[30] R. Sekar, V. Venkatakrishnan, S. Basu, S. Bhatkar, and
D. C. DuVarney. Model-carrying code: a practical approach
for safe execution of untrusted applications. In ACM SOSP,
2003.
[31] S. Stamm, B. Sterne, and G. Markham. Reining in the web
with content security policy. WWW ’10.
[32] D. Stefan, E. Z. Yang, P. Marchenko, A. Russo, D. Herman,
B. Karp, and D. Mazieres. Protecting users by conﬁning
JavaScript with COWL. OSDI ’14.
[33] W. Sun, R. Sekar, G. Poothia, and T. Karandikar. Practical
proactive integrity preservation: A basis for malware
defense. In IEEE S&P, 2008.
[34] M. Ter Louw, K. T. Ganesh, and V. N. Venkatakrishnan.
Adjail: Practical enforcement of conﬁdentiality and
integrity policies on web advertisements. USENIX
SECURITY ’10.
[35] M. Ter Louw and V. Venkatakrishnan. Blueprint: Robust
prevention of cross-site scripting attacks for existing
browsers. S&P ’09.
[36] T. Tran and R. Pelizzi. JaTE System. Available for
download from
http://www.seclab.cs.sunysb.edu/seclab/download.html.
[37] T. Tran, R. Pelizzi, and R. Sekar. Jate: Transparent and
eﬃcient javascript conﬁnement.
http://seclab.cs.sunysb.edu/seclab/pubs/jate.pdf.
[38] S. Van Acker, P. De Ryck, L. Desmet, F. Piessens, and
W. Joosen. WebJail: least-privilege integration of
third-party components in web mashups. ACSAC ’11.
[39] T. Van Cutsem and M. S. Miller. Trustworthy proxies:
Virtualizing objects with invariants. ECOOP’13.
[40] V. Venkatakrishnan, R. Peri, and R. Sekar. Empowering
mobile code using expressive security policies. In
Proceedings of the 2002 workshop on New security
paradigms, 2002.
[41] G. Wagner, A. Gal, C. Wimmer, B. Eich, and M. Franz.
Compartmental memory management in a modern web
browser. ISMM ’11.
[42] H. J. Wang, X. Fan, J. Howell, and C. Jackson. Protection
and communication abstractions for web browsers in
MashupOS. SIGOPS ’07.
[43] B. Yee, D. Sehr, G. Dardyk, J. B. Chen, R. Muth,
T. Ormandy, S. Okasaka, N. Narula, and N. Fullagar.
Native client: A sandbox for portable, untrusted x86 native
code. S&P ’09.
[44] Y. Zhou and D. Evans. Understanding and monitoring
embedded web scripts. IEEE S&P ’15.
160