[10] J. Devietti, C. Blundell, M. M. K. Martin, and
S. Zdancewic. Hardbound: Architectural support for
spatial safety of the c programming language. In
ASPLOS, 2008.
[11] A. Francillon and C. Castelluccia. Code injection
attacks on harvard-architecture devices. In ACM CCS,
2008.
[12] A. Francillon, D. Perito, and C. Castelluccia.
Defending embedded systems against control ﬂow
attacks. In 1st ACM workshop on Secure execution of
untrusted code, 2009.
[13] D. Gay, P. Levis, R. von Behren, M. Welsh,
E. Brewer, and D. Culler. The nesc language: A
holistic approach to networked embedded systems. In
ACM SIGPLAN PLDI, 2003.
[14] T. Giannetsos and T. Dimitriou. Spy-sense: Spyware
tool for executing stealthy exploits against sensor
networks. In ACM HotWSN Workshop, 2013.
[15] T. Giannetsos, T. Dimitriou, I. Krontiris, and N. R.
Prasad. Arbitrary code injection through
self-propagating worms in von neumann architecture
devices. Comput. J., 53(10):1576–1593, Dec. 2010.
[16] T. Goodspeed. Stack overﬂow exploits for wireless
sensor networks over 802.15.4, 2008.
[17] T. Jim, J. G. Morrisett, D. Grossman, M. W. Hicks,
J. Cheney, and Y. Wang. Cyclone: A safe dialect of c.
In USENIX Annual Technical Conference, 2002.
[18] C. Lattner and V. Adve. LLVM: A Compilation
Framework for Lifelong Program Analysis &
Transformation. In CGO, 2004.
[19] P. Levis. Experiences from a decade of tinyos
development. In USENIX OSDI, 2012.
[20] P. Levis, N. Lee, M. Welsh, and D. Culler. Tossim:
Accurate and scalable simulation of entire tinyos
applications. In SenSys. ACM, 2003.
[21] P. Levis, S. Madden, J. Polastre, R. Szewczyk,
K. Whitehouse, A. Woo, D. Gay, J. Hill, M. Welsh,
E. Brewer, and D. Culler. Tinyos: An operating
system for sensor networks. In Ambient Intelligence,
2005.
[22] Memsic. Micaz datasheet.
http://www.memsic.com/userﬁles/ﬁles/Datasheets/
WSN/micaz datasheet-t.pdf.
[23] Memsic. Telosb datasheet. http://www.memsic.com/
userﬁles/ﬁles/Datasheets/WSN/telosb datasheet.pdf.
[24] S. Nagarakatte, J. Zhao, M. M. Martin, and
S. Zdancewic. Softbound: highly compatible and
complete spatial memory safety for c. In ACM Sigplan
Notices, pages 245–258. ACM, 2009.
[25] S. Nagarakatte, J. Zhao, M. M. Martin, and
S. Zdancewic. Cets: Compiler enforced temporal safety
for c. SIGPLAN Notices, 45(8):31–40, June 2010.
[26] G. C. Necula, S. McPeak, and W. Weimer. Ccured:
Type-safe retroﬁtting of legacy code. ACM SIGPLAN
Notices, 37(1), 2002.
[27] H. Patil and C. Fischer. Low-cost, concurrent checking
of pointer and array accesses in c programs. Softw.
Pract. Exper., 27(1):87–110, Jan. 1997.
[28] J. Polastre, J. Hill, and D. Culler. Versatile Low
Power Media Access for Wireless Sensor Networks. In
ACM SenSys, pages 95–107, 2004.
[29] R. Sasnauskas, O. Landsiedel, M. H. Alizai, C. Weise,
S. Kowalewski, and K. Wehrle. Kleenet: discovering
insidious interaction bugs in wireless sensor networks
before deployment. In ACM/IEEE IPSN, 2010.
[30] V. Shnayder, M. Hempstead, B.-r. Chen, G. W. Allen,
and M. Welsh. Simulating the power consumption of
large-scale sensor network applications. In ACM
SenSys, 2004.
[31] Softbound website.
http://www.cis.upenn.edu/acg/softbound/.
[32] B. Sun, D. Shrestha, G. Yan, and Y. Xiao.
Self-propagate mal-packets in wireless sensor
networks: Dynamics and defense implications. In
IEEE GLOBECOM, 2008.
[33] V. Sundaram, P. Eugster, and X. Zhang. Prius:
Generic hybrid trace compression for wireless sensor
networks. In ACM SenSys, 2012.
[34] L. Szekeres, M. Payer, T. Wei, and D. Song. Sok:
Eternal war in memory. In 2013 IEEE Symposium on
Security and Privacy, 2013.
[35] W. Xu, D. C. DuVarney, and R. Sekar. An eﬃcient
and backwards-compatible transformation to ensure
memory safety of c programs. In ACM FSE, 2004.
[36] Y. Yang, S. Zhu, and G. Cao. Improving sensor
network immunity under worm attacks: a software
diversity approach. In ACM MobiHoc, 2008.
[37] R. Z¨uger. Paging in tinyos, 2006.
APPENDIX
A. PROOF OF SAFETY
In this section, we sketch a formal proof of memory safety
for nesCheck. First, we give the intuition of the rules for
type inference. Then, we follow the general structure of
the proof of SoftBound [31], while focusing on the features
relevant for nesCheck. We tackle the complexity of the nesC
language by focusing the proof on an abstract subset of nesC
that captures most of the fundamental primitives. We keep
the formalism, operational semantics tractation and proof
short, while still remaining sound in showing safety.
A.1 Grammar and Operational Semantics
The syntax we use models programs in their processed
IR form, already reduced to atomic data types (int and
pointers) and simple operations. Table 2 shows the grammar
we consider for our proof. We use LHS and RHS to denote
left-hand side and right-hand side, respectively. Note that,
while most WSN applications do not use dynamic memory
allocation, we include it in our formal grammar for the sake
of generality.
In our simpliﬁed operational semantics, we
consider an environment E that models the stack with a
map S from variable names to addresses and types, models
the type inference with a map Γ from variable names to
pointer categories, and models the heap with a partial map
M from addresses to values.
Atomic Types
Pointer Types
Struct Types
Struct Fields
LHS Expr.
RHS Expr.
t
p
s
f
lhs
rhs
Commands
c
::= int | p*
::= t | s | void
::= struct{f ; f }
::= (id:t)
::= x | *lhs | lhs.id | lhs->id
::= val | rhs+rhs | &lhs | (a)rhs
|
sizeof(p) | malloc(rhs) | lhs
::= c ; c | lhs = rhs
Table 2: Grammar used in the formal proof of safety.
Using some and none to denote presence or absence of a
value, we model nesC’s memory access primitives as follows:
(i) read M l:
if l is an allocated memory location, return
some, otherwise return none; (ii) write M l v:
if l is an
allocated memory location, set the content to the value v;
(iii) malloc M s:
if M has an available region of size s,
allocate and return it, otherwise fail.
The normal C operational semantics processes assignments
by writing the result of the expression in the RHS operand
to the address calculated from the LHS operand. For this
proof, we extend the traditional operational semantics of
C by including new outcomes for operations (that include
memory errors) and tracking of pointers metadata. A result
r can therefore be: (i) v(sl,sh), a value v with the attached
metadata for the size of the memory region towards the lower
(sl) and higher (sh) memory addresses (see Section 4.1.2);
(ii) a memory address l; (iii) Success; (iv) MemoryError if
a bounds check failed; (v) MemoryExhaustion if M did not
have enough free memory upon a malloc operation.
Using the above deﬁnitions, we formalize nesCheck’s oper-
ational semantics with four classes of rules. First, the rules
for type inference and propagation. Second, the (E, lhs) ⇒l
r : a rule speciﬁes how LHS expressions are evaluated (no
changes to the environment). Third, the (E, rhs) ⇒r (E(cid:48), r :
a) rule speciﬁes how RHS expressions are evaluated (poten-
tial changes to the environment; if successful, r is v(sl,sh)).
Lastly, (E, c) ⇒c (E(cid:48), r : a) is the rule to execute commands
(r must be a success or failure result). Here we omit rules
straightforwardly representing standard C semantics, and
just show the rules most relevant for nesCheck’s semantics.
A.2 Type Inference
We present some of the rules for type inference, that for-
malize the rules presented in Section 4.1.1. For example,
pointer arithmetic on a Safe or Sequence pointer causes the
result to be of Sequence kind, while casting a Safe or Se-
quence pointer to an incompatible type (Section 4.1.1 deﬁnes
two types as “incompatible” when, for example, they have
diﬀerent levels of indirection or have same level of indirection
but diﬀerent root types) results in a Dynamic pointer:
Γ(x) = τ
τ ∈ {Safe, Seq, Dyn}
Γ (cid:96) x : τ
T
Γ (cid:96) e1 : τ
τ ∈ {Safe, Seq}
Γ (cid:96) e2 : int
Γ (cid:96) e1 + e2 : Seq
ArithT1
Γ (cid:96) e1 : τ
τ = Dyn
Γ (cid:96) e2 : int
ArithT2
Γ (cid:96) e1 + e2 : Dyn
(E, x) ⇒l l : t
incompatible(t, t(cid:48))
Γ (cid:96) (t(cid:48))x : Dyn
IllegCast
No memory access to Safe pointers is subject to dynamic
bounds checks; conversely, all memory accesses to Dynamic
pointers are instrumented with runtime checks. For a mem-
ory access to a Sequence pointer, if nesCheck can statically
determine that it will never result in an out of bounds op-
eration, it will not be instrumented with a dynamic check.
We therefore deﬁne a predicate saf e(∗p) that is true ((cid:62)) iﬀ
the memory access ∗p does not require bounds checks, false
(⊥) otherwise:
(cid:62) if Γ (cid:96) p : Safe ∨
⊥ otherwise
(Γ (cid:96) p : Seq ∧ ∗p not out of bounds)
saf e(∗p) =
nesCheck declares a memory access as never out of bounds
only if the in-memory metadata propagated up to that ac-
cess statically indicates the safety of the operation. The re-
sult of the predicate saf e(∗p) for memory accesses on that
pointer removes the need to carry the pointer type over
to the dynamic bounds checks rules. The formal proof of
CCured [26] shows it is safe to leave memory accesses unin-
strumented, and the same proof also applies in our case to
statically-provable Sequence pointers accesses.
A.3 Dynamic Bounds Checks
The bounds checking operational rules are very similar to
those of SoftBound, so we omit most of them for brevity.
We present here the rules for the evaluation of a pointer
dereference operation, both in case of success:
(E, lhs) ⇒l p : t∗
ones in the SoftBound paper allows for a proof by reduc-
tion, with the aim of presenting a set of theoretical concepts
that the reader is already familiar with, and that can rely
on the full formalization of SoftBound.
While adding bounds checks to every memory access is
surely sound, as shown by the proof in SoftBound, by com-
bining the latter with the proof in CCured we improve the
performance overhead by removing unnecessary checks while
still remaining sound. Thus, given the operational seman-
tics rules above, every memory access in nesCheck is either
safe at runtime – resulting in a correct access – or causes
the application to stop – due to a detected memory error.
Therefore, the nesC applications analyzed and instrumented
by nesCheck fulﬁll the set memory safety goals.
B. SOURCE CODE
The source code for our implementation of nesCheck will
be made available at https://github.com/HexHive/nesCheck.
DerefSuccess
read (E.M ) p = some v(sl,sh)
saf e(p) ∨ (sl ≥ 0 ∧ sh ≥ sizeof (t))
(E,∗lhs) ⇒l v : t
and in the case of memory error (failed bounds check):
(E, lhs) ⇒l p : t∗
sl < 0 ∨ sh < sizeof (t)
read (E.M ) p = some v(sl,sh)
(E,∗lhs) ⇒l MemoryError : t
DerefFail
Other rules, such as those for type casts and pointer arith-
metic, need to ensure that metadata information is propa-
gated correctly:
(E, ptr) ⇒r (E(cid:48), l(sl,sh) : p∗)
(E(cid:48), val) ⇒r (E(cid:48)(cid:48), of f(sl(cid:48),sh(cid:48)) : int)
l(cid:48) = l + of f ∗ sizeof (p)
sl(cid:48) = sl + of f ∗ sizeof (p)
sh(cid:48) = sh − of f ∗ sizeof (p)
PtrArithm
(E, ptr + val) ⇒r (E(cid:48), l(cid:48)
(sl(cid:48),sh(cid:48)) : p∗)
(E, rhs) ⇒r (E(cid:48), v(sl,sh) : t)
(E, (t(cid:48))rhs) ⇒r (E(cid:48), v(sl,sh) : t(cid:48))
t(cid:48) (cid:54)= int
TypeCast
For the formal rule for integer-to-pointer cast, we follow
SoftBound’s approach of zeroing out the metadata to avoid
potentially undeﬁned behaviors:
(E, rhs) ⇒r (E(cid:48), v(sl,sh) : t)
TypeCastIntToPtr
t = int
(sl(cid:48), sh(cid:48)) = (0, 0)
(E, (t(cid:48))rhs) ⇒r (E(cid:48), v(sl(cid:48),sh(cid:48)) : t(cid:48))
With this support infrastructure of rules in place, we note
that the operational rules for values that are valid at run-
time and need runtime bounds checks are fully equivalent to
their corresponding rules in SoftBound’s formal model [24].
Therefore, they satisfy the same safety invariants and ensure
memory safety for those values, as proven for SoftBound (in
Theorems 4.1 and 4.2, and Corollary 4.1 in [24]). Reducing
our formal deﬁnitions and methodology to the respective