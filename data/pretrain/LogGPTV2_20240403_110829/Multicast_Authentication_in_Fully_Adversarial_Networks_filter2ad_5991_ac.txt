GIDi = GID, ni = n, and ﬁi = ﬁ. Let
DP i = fp1; : : : ; png = DP be the data pack-
ets associated with that query, and let AP i =
fa1; : : : ; ang = AP be the response of the au-
thenticator.
† At
least ﬁn of
the authenticated packets
(a1; : : : ; an) are included in the received pack-
ets RP, i.e., jRP \ AP j ‚ ﬁn.
† The number of received packets is at most ﬂn,
i.e., jRP j • ﬂn.
† For some 1 • j • n, pj is the j’th packet in
the original set of data packets DP, such that
the corresponding authenticated packet aj was
received, i.e., aj 2 RP \ AP, and yet was not
decoded correctly. Namely, let (p0
n) ˆ
Decode(P K; GID; n; ﬁ; ﬂ; RP ). For pj it holds
that pj 6= p0
j.
1; : : : ; p0
Violation of the security property: The
adversary
did
managed to construct RP in such a way that the de-
coder will output packets OP = fp0
ng that
were never authenticated by the authenticator al-
gorithm for the group identiﬁcation tag GID. More
precisely, the adversary wins if one of the follow-
ing happens:
1; : : : ; p0
† The authenticator was never queried with group
identiﬁcation tag GID and the size n, and yet the
decoder algorithm does not reject. I.e., reject 6=
OP = Decode(P K; GID; n; ﬁ; ﬂ; RP ).
† The authenticator was queried with the group
identiﬁcation tag GID, the values n, ﬁ and ﬂ,
and the data packets DP = fp1; : : : ; png. How-
ever, some output packet p0
6= ? is different
j
from the corresponding data packet pj, where
OP = fp1; : : : ; png.
4. Construction
In this section we describe a multicast authentication
scheme (KeyGen; Auth; Decode) that meets the deﬁnitions
of the previous section. In the sequel, we denote with † > 0
the tolerance parameter of the decoder, which yields a
trade-off between the error-tolerance ability of the decoder
and its performance. By –, we denote concatenation and by
? we appropriately denote either a packet that is empty or
the empty string. We also often omit the ﬂoor and ceiling
notation in order to avoid notational overload.
4.1. Key Generation
We assume that a signature scheme (G(¢), Sign(¢)(¢),
Verify(¢)(¢; ¢)) and a collision-resistant hash function H are
given (see Deﬁnitions 2.1 and 2.2). If (P K (cid:190); S K (cid:190)) ˆ
G(1k), we set P K = (P K (cid:190); H) and S K = S K (cid:190).
4.2. Authenticator Auth
Input: The secret key S K, the public key P K, the group
identiﬁcation tag GID, the data stream size n, parame-
ters ﬁ and ﬂ of the network and the data packets DP =
fp1; : : : ; png.
Algorithm: For 1 • i • n, compute the hash value
hi = H(pi). The concatenation of all the hash values,
together with the value GID, is digitally signed: (cid:190) ˆ
SignS K(GID–h1 –: : :–hn). The string S = h1 –: : :–hn –(cid:190)
is called the authentication information. We want to guar-
antee that, even if only an ﬁ fraction of the packets survive,
and a large number of packets (ﬂ ¡ ﬁ)n are injected, the re-
ceiver still gets all the authentication information. To that
end, we encode S using a Reed-Solomon code in a man-
ner that is tolerant to packet loss and insertion; namely:
1. Let the rate of the code be ‰ = ﬁ2
(1+†)ﬂ . Recall that
ﬁ and ﬂ are the survival and ﬂood rates of the net-
work, respectively, whereas † is the tolerance parame-
ter of the decoder. Observe that since ﬁ • 1, ﬂ ‚ 1
and † > 0, we have ‰  ﬂn, reject.
2. Else if there are fewer than ﬁn distinct values of xi,
reject.
3. Else,
is,
run the GS-Decoder,
let L ˆ
GSDecode†(m; ‰n; ﬁn; f(xi; yi)j1 • i • mg),
where ‰ = ﬁ2
(1+†)ﬂ . If L is empty, reject.
that
4. Process L = fQ1(x); : : : ; Q‘(x)g as follows: for each
Q(i) 2 L, evaluate Q(i) for 1 • i • ‰n + 1 and let
the string Qj(1) – Qj(2) – ¢ ¢ ¢ – Qj(‰n + 1) be a can-
didate ci.
Output: List of all computed candidates fc1; : : : ; c‘g or
reject.
Lemma 4.1. MGSDecoder† runs in time ~O(n2), where
~O(n2) ﬁeld operations are involved, and outputs the con-
stant size list of all candidate inputs that are consistent with
ﬁn of the received points.
Proof. All claims follow from Theorem 2.1, Corollary 2.3
and the fact that GS-Decoder operates even when the xi’s
are not distinct (see Guruswami and Sudan [14]). Observe
that Corollary 2.3 holds, since, if m = (cid:176)n, ﬁ • (cid:176) • ﬂ, then
t ‚ ﬁn ‚ q (cid:176)
ﬂ ﬁn = p(1 + †)‰nm. (Note that the correct
input is guaranteed to be contained in the output list, since it
is a polynomial of degree at most ‰n that is consistent with
ﬁn points.)
Now, we are ready to describe our decoder:
Decoder Decode†
Input: The public key P K, a group identiﬁcation tag GID,
n, parameters ﬁ and ﬂ and the received packets RP =
fr1; : : : ; rmg.
Algorithm:
1. View packets in RP as ri = GIDi – ji – pi – si.
2. Discard all non-conforming packets, i.e., all packets
for which GIDi 6= GID or packets with ji =2 [1::n]. Let
(r1; : : : ; rm0 ) be the remaining packets in RP. Each of
them is viewed as ri = GID – ji – pi – si, such that
ji 2 [1::n].
3. If m0  ﬂn, then reject.
4. For 1 • i • m0, set (xi; yi) = (ji; si)
5. Run algorithm MGSDecoder† with input parameters
n, ﬁ, ﬂ and the m0 points (xi; yi), 1 • i • m0.
If MGSDecoder† rejects, reject; otherwise, obtain the
candidate codewords fc1; : : : ; c‘g.
6. For 1 • i • n, set hi = ?. Let j = 1. While j • ‘:
† Parse the codeword cj as string hj
† If VerifyP K(GID – hj
n – (cid:190).
n; (cid:190)) = 1, then set
i for 1 • i • n and break out of the loop;
1 – : : : – hj
1 – : : : – hj
hi = hj
otherwise, increment j.
7. If (h1; : : : ; hn) = (?; : : : ; ?), reject. Else, compute
the output packets OP as follows:
1; : : : ; p0
† Initialize OP = fp0
n, set p0
i = ?.
ng: for each 1 • i •
† For 1 • i • m0:
– view ri as ri = GID – j – pj – sj, such that
j 2 [1::n].
– if H(pj) = hj, set p0
j = pj.
8. Let OP = fp0
Output: OP = fp0
1; : : : ; p0
1; : : : ; p0
ng.
ng or reject.
We postpone the analysis of the running time of these al-
gorithms until the next section.
4.4. Correctness and Security Proofs
Let us show that our scheme satisﬁes Deﬁnition 3.4. Sup-
pose that we have an adversary A who manages to break
the (ﬁ; ﬂ)-correctness or security of our scheme with (non-
negligible) probability …(k). Then one of the following is
true:
† With probability …(k)=2, the adversary A violates the
(ﬁ; ﬂ) correctness property.
† With probability …(k)=2, the adversary A violates the
security property.
Let us show that a non-negligible probability of either
event contradicts the security properties of the underlying
signature scheme and hash function.
Claim 4.2. If a polynomial-time adversary A violates the
(ﬁ; ﬂ)-correctness property of our scheme, then the under-
lying signature scheme is not secure, or the underlying hash
function is not collision-resistant.
Proof. Let us prove the claim by exhibiting a reduction
which transforms an attack that violates the correctness
of our scheme, into an attack on the underlying signature
scheme.
Reduction. The input to the reduction is the public key
P K (cid:190) of the signature scheme. Our reduction is also given
oracle access to the corresponding signer SignS K. The re-
duction sets up the public key P K = (P K (cid:190); H).
reduction does not know the corresponding se-
Our
cret key. Our
reduction invokes the adversary A on
input P K. It now needs to be able to answer the ad-
versary’s queries to the authenticator Auth. In order to
respond to a query (GIDi; ni; ﬁi; ﬂi; DP i), run the algo-
rithm Auth with the following modiﬁcation: at the begin-
ning of the algorithm Auth, instead of computing the signa-
ture (cid:190)i, obtain it by querying the signature oracle SignS K.
Everything else is carried out as prescribed by the algo-
rithm Auth.
It is clear that the view of the adversary in this reduction
will be identical to the view that the adversary obtains in
real life. Therefore, with the same probability as in real life,
the adversary violates the correctness property. Namely, it
outputs values GID, n, ﬁ, ﬂ and the set of received pack-
ets RP, such that all of the following hold:
1. GID = GIDi, n = ni, ﬁ = ﬁi, and ﬂ = ﬂi for
some i. Let DP i = fp1; : : : ; png be the data pack-
ets associated with that query, and let AP be the re-
sponse that we gave to the adversary. In particular, let
(cid:190)i be the signature associated with this query, that is,
(cid:190)i ˆ SignS K(GID – h(p1) – : : : – h(pn)).
2. jRP \ AP j ‚ ﬁn and jRP j • ﬂn.
3. For some j such that rj 2 RP, pj
6= p0
j,where
(p0
1; : : : ; p0
n) ˆ Decode(P K; GID; n; ﬁ; ﬂ; RP ).
j into OP if and only if h(p0
j 6= ?. From 3, we get that either
Case 1. Suppose that p0
j), or it is easy to ﬁnd a collision to the hash
h(pj) 6= h(p0
function. By deﬁnition of Decode, if ? 6= p0
j 2 RP, then,
in Step 6, the algorithm Decode processes a candidate c =
h1–: : :–hn–(cid:190) such that VerifyP K(GID–h1–: : :–hn; (cid:190)) = 1.
We must argue that our signature oracle was never queried
on input (GID – h1 – : : : – hn). Note that the only time
it was queried with this GID, it was when we obtained (cid:190)i
on input (GID – h(p1) – : : : – h(pn)). Moreover, in Step 7,
Decode includes p0
j) = hj.
Therefore, hj 6= h(pj), and so our signature oracle was
never queried with (GID – h1 – : : : – hn), and yet our ad-
versary has caused us to compute a signature (cid:190) such that
VerifyP K(GID – h1 – : : : – hn; (cid:190)) = 1. Thus, the underly-
ing signature scheme is insecure.
Case 2. So, suppose that p0
j = ?. From 1 and 2, we
know that ﬁn of the original authenticated packets were re-
ceived, among the total of ﬂn packets. Then, by the prop-
erties of MGSDecoder† (Lemma 4.1), Step 5 of the algo-
rithm Decode includes the candidate value c = h(p1) – : : : –
h(pn) – (cid:190)i. Then, by construction, it cannot be the case that
in Step 7, (h1; : : : ; hn) = (?; : : : ; ?). If (h1; : : : ; hn) =
(h(p1); : : : ; h(pn)), then by construction of Decode, if (as
j 6= ?, be-
is the case according to 3) rj 2 RP, then p0
cause p0
j is set to pj when the packet rj is considered in
Step 7. Therefore, (h1; : : : ; hn) 6= (h(p1); : : : ; h(pn)), and
yet VerifyP K(GID–h1 –: : :–hn; (cid:190)) = 1. But the only query
with GID that we ever issued to the signer was for the mes-
sage (GID – h(p1) – : : : – h(pn)) 6= (GID – h1 – : : : – hn).
Thus (cid:190) is a successful forgery.
Claim 4.3. If a polynomial-time adversary A violates the
security property of our scheme, then the underlying signa-
ture scheme is not secure, or the underlying hash function
is not collision-resistant.
Proof. Consider setting up the reduction in exactly the same
way as in the proof of Claim 4.2. Again, the adversary’s
view in the reduction is the same as in real life. So, just
as often as in real life, the adversary will violate the secu-
rity property of our scheme, namely, one of the following
will hold:
1. The authenticator was never queried with group
and yet
I.e.,
identiﬁcation tag GID and size n,
the
reject 6= OP = Decode(P K; GID; n; ﬁ; ﬂ; RP ).
algorithm does
decoder
reject.
not
2. The authenticator was queried with the group identiﬁ-
cation tag GID, with the values n, ﬁ and ﬂ, and data
packets DP = fp1; : : : ; png. However, some output
packet p0
j 6= ? is different from the corresponding data
packet pj, where OP = fp0
1; : : : ; p0
ng.
Suppose 1 holds. Then, from the description of the de-
coder, we know that the only way that it will produce some
non-empty set of output packets is if, in Step 6, it sees a