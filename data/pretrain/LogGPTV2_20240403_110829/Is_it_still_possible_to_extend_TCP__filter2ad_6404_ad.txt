not independently acking data. Its reasons for doing so are unclear—
perhaps it is attempting to analyze the stream contents and is un-
willing to pass an ack for data it has not seen? Whatever the reason,
we still see more such middleboxes on port 80.
In the ack-ﬁrst sequence hole test (Fig. 2, right), the initiator
acks a segment beyond that which is received (i.e., proactive ack).
The responder skips the data acked and sends an ack packet the se-
quence number of which follows on from the point that was acked.
To receive a response packet from the responder, the segment from
the initiator to the responder also contains data, but what we are
interested in is whether the proactive ack is received, and subse-
quently whether the packet following the hole is received. Table 11
shows the results.
The results of this test were a surprise—even on port 34343, mid-
dleboxes interfered with end-to-end behavior 24% of the time. As
before, seven paths on port 80 could not be tested. Of those that
could be tested, we saw three distinct behaviors:
• On around 20% of paths we saw no response to the proac-
tive ack. Either the proactive ack was dropped or the packet
186Table 11: Ack-ﬁrst Sequence Hole Test
Behavior
Passed
No response
Ack ﬁxed
Retransmitted
Test Error
Total
34343
102 (76%)
28 (21%)
4 (3%)
1 (1%)
0 (0%)
135 (100%)
TCP Port
80
95 (67%)
28 (20%)
5 (4%)
7 (5%)
7 (5%)
443
105 (74%)
29 (20%)
3 (2%)
5 (4%)
0 (0%)
142 (100%)
142 (100%)
above the hole was dropped, but the lack of a response does
not allow us to distinguish.
• On quite a few paths (labeled Ack ﬁxed), an ack packet is
received, but the sequence number of which follows the last
packet sent by the responder as if we sent an ack without a
hole. Perhaps the proactive ack was re-written by the outgo-
ing middlebox to indicate the highest data cumulatively seen
by the middlebox.
• On some paths, the middlebox itself actually retransmitted
the last data packet sent by the responder from before the
hole. These paths also sent back ack packets observed on
Ack ﬁxed paths, except for one path on port 80 and 443.
It is clear from these results that TCP extensions relying on se-
quence number holes are unsafe. Although some of the results can
be explained by proxy behavior at middleboxes, some paths that did
not exhibit clear proxy behavior (by performing separate acknowl-
edgment) do affect both sequence holes and proactive acking. Per-
haps some ﬁrewalls attempt to protect the initiator from potentially
malicious proactive acks? [27].
One interesting observation is that around 10% of home net-
works give no response in the ack-ﬁrst sequence hole test. This
is striking because none of the home networks strip unknown op-
tions.
4.4 Proxy Acknowledgments
In Tables 6 and 7 we observed that a subset of the paths that
remove TCP options appear to show TCP proxy behavior. We now
elaborate on the tests we used to elicit this information.
A hypothetical TCP proxy[2] would likely split the TCP con-
nection into two sections; one from the client to the proxy and one
from the proxy to the server. Each section would effectively run its
own TCP session, with only payload data passed between the two
sections. Are the proxies we observed of this form, which is fairly
easy to reason about, or is their behavior more complex?
One symptom of a TCP proxy would be that acknowledgments
for data are locally generated by the middlebox. We performed two
tests examining this behavior:
• Proxy SYN-ACK: Is the SYN/ACK locally generated by
the proxy? In its SYN/ACKs, our responder generates quite
characteristic values for the initial sequence number, adver-
tised receive window, maximum segment size, and Window
Scale options. It is improbable that a proxy would generate
these values. We simply check the value of these ﬁelds in the
SYN/ACK received by the initiator—if they differ then this
is symptomatic of a proxy that crafts its own SYN/ACKs.
• Proxy Data Ack: Is data acknowledged by the proxy before
delivering it to the destination? Our initiator sends a data
packet to the responder, requesting the ack is sent on a packet
Figure 3: Retransmission Test
that includes data. If the ack received does not include data,
it is extremely likely it was generated by the proxy rather
than the responder.
Neither test is conclusive by itself, but taken together they give a
good picture of proxy behavior. As before, there are seven paths
which have HTTP-level proxies; on port 80, all seven sent proxy
SYN/ACKs, but could not be tested for proxy data acks. Tables
6 and 7 show the number of proxies identiﬁed. The set of paths
showing Proxy SYN/ACK behavior is precisely the same as those
showing either Proxy Data Ack or HTTP proxy behavior. Taken
together, these tests provide good evidence for proxies of the form
described above.
4.5 Inconsistent Retransmission
If a TCP sender retransmits a packet, but includes different data
than the original in the retransmission, what happens? This might
seem like a strange thing to do, but it might be advantageous for
extensions that do not need stale data (such as VoIP over TCP).
Given that we know sequence holes are a bad idea (see Sec. 4.3), it
might make sense to ﬁll the sequence hole with previously unsent
data.
Such inconsistent retransmissions would be explicitly “corrected”
by a trafﬁc normalizer[15], as its role is to ensure that any down-
stream intrusion detection system sees a consistent picture. Equally,
depending on their implementation, TCP proxies might reassert the
original data. We set out to test what happens in reality.
Fig. 3 shows our retransmission test. The initiator sends two
consecutive segments, but we request that the responder sends a cu-
mulative ack only for the ﬁrst segment, then a duplicate Ack. Any
stateful middlebox will infer that the second segment has not been
received by the responder, and depending on its implementation,
it may retain the unacked segment. We then send a “retransmis-
sion” of the second packet, but with a different payload (one that
requests the responder echo the packet headers so we can see what
is received).
We also repeat the test, but with the “retransmitted” packet being
either 16 bytes smaller or 16 bytes longer than the original packet.
From the responses, we can distinguish four distinct middlebox
behaviors, as listed in Table 12:
• Most paths passed the inconsistent retransmission to the re-
sponder unmodiﬁed. In the case of port 34343, only one path
did not do this.
• On some paths the initiator observes that the cumulative Ack
advanced, but the headers were not echoed. This implies
that the middlebox cached the original segment and resent
it. Most of these paths were ones that we had previously
identiﬁed as TCP proxies, but one on port 80 was not—it
caches segments but does not separately ack data. We cannot
know for sure, but this would be symptomatic of a trafﬁc
187Table 12: Results of Retransmission Test
TCP Port / Retransmitting size
132 (98%)
124 (87%)
123 (87%)
138 (97%)
Observed
Behavior
Passed
No response
Ack adv’ced
Reset conn
Error
Total
same
134 (99%)
0 (0%)
1 (1%)
0 (%)
0 (0%)
34343
smaller
134 (99%)
0 (0%)
1 (1%)
0 (0%)
0 (0%)
135 (100%)
larger
1 (1%)
1 (1%)
0 (0%)
1 (1%)
same
0 (0%)
10 (7%)
1 (1%)
7 (5%)
80
smaller
124 (87%)
0 (0%)
10 (7%)
1 (1%)
7 (5%)
142 (100%)
larger
1 (1%)
10 (7%)
1 (1%)
7 (5%)
same
0 (0%)
4 (3%)
0 (0%)
0 (0%)
443
smaller
138 (97%)
0 (0%)
4 (3%)
0 (0%)
0 (0%)
142 (100%)
larger
136 (96%)
1 (1%)
4 (3%)
0 (0%)
1 (1%)
normalizer or a snoop [3]. For port 443, one path in fact
echoed headers after the separate cumulative ack packet for
the retransmission of the 16 byte longer packet. However,
what the responder received is a 16 byte piece that does not
overlap with the original—the other part is probably cached
by the middlebox.
• One path returned no response at all when the inconsistent re-
transmit was larger than the original, and did so for all ports.
There is no obvious reason for such behavior, so we specu-
late it might be a minor bug in a middlebox implementation.
• One path on port 80 reset the connection. This seems to be a
fairly draconian response.
The usual seven paths with HTTP proxies could not be tested. One
path on port 34343 and one on port 443 also failed to complete the
test due to high packet loss.
Overall, any extension that wished to use inconsistent retrans-
missions would encounter few problems, so long as it did not mat-
ter greatly whether the original or the retransmission actually ar-
rives. The one path that resets connections might however give the
designers of extensions cause for concern.
We note that the proposal for TCP extended options might result
in retransmissions that appear inconsistent to legacy middleboxes,
even if the payload is consistent. This might occur if the value of
an extended option such as a selective acknowledgment changes
between the original and the retransmission.
4.6 Re-segmentation
TCP provides a reliable bytestream abstraction to applications,
and makes no promises that message boundaries are preserved.
Some
as
TcpCrypt wish to associate a new option with a particular data
segment—in the case of TcpCrypt to carry a MAC for the data.
How will such extensions be affected by middleboxes?
extensions
TCP
such
We expect that TCP proxies will coalesce small segments if a
queue builds in the proxy, and might split segments if the proxy
negotiates a larger MSS with the client than that negotiated by the
server. However, our results show such proxies remove unknown
options from the SYN exchange, so any adverse interaction (be-
yond falling back to regular TCP) is unlikely. Our concern there-
fore is whether there are middleboxes that are not proxies that re-
segment packets. In particular, any middlebox that passes new op-
tions and also re-segments data might be problematic.
To test segment splitting, we simply send a full-sized segment.
Our responder advertises a relatively small 512 byte MSS. Any
middlebox advertising a more normal (larger) MSS will be forced
to resegment larger data packets into smaller ones. In fact, MSS ad-
vertised by 16 SYN proxies we observed at port 80 varied between
1372 – 1460 bytes. We perform the test without option, that with
Figure 4: In-order Segment Coalescing Test
Figure 5: Queued Segment Coalescing Test
the known option (TIMESTAMP) and that with the unknown option
(MP_DATA) to see if options are copied to the split segments.
We found that 1 path on port 34343, 9 paths on port 80 and 4
paths on port 443 split segments in this way. These are the same
paths identiﬁed as proxies in Table 7. None passed options to the
split segments.
The opposite of segment splitting is segment coalescing, where a
middlebox combines two or more segments into a larger segment.
To test for this, we must send two consecutive small segments and
observe whether a single larger segment arrives. However, a mid-
dlebox that has the ability to coalesce might still not do so unless it
is forced to queue the segments. We therefore perform two versions
of the test, as shown in Figures 4 and 5.
• We test if segments are coalesced if the two small segments
arrive in order (Fig. 4).
• We reorder the segments so that the small segments arrive
after a gap in the sequence space, creating an opportunity for
middleboxes to queue them (Fig. 5). We then send the seg-
ment which ﬁlls the sequence hole. If a middlebox queued
the small segments, this will release them, potentially allow-
ing coalescing to occur.
As before, we repeat the tests without options and with both known
and unknown options.
Table 13 shows the results. Most middleboxes running TCP
proxies coalesced segments in both in-order and queued cases (la-
beled Coal. both), and the other proxies did so in only the queued
case (labeled Coal. queued). No middlebox copies either known or
unknown options to the coalesced segments. One non-proxy path
did coalesce segments in the in-order test on ports 80 and 34343 (la-
beled Coal. ordered), but passed all the other tests. Interestingly, it
only coalesced when options were not present.
As before, on port 80 seven HTTP proxy paths could not be
tested. Three other cases gave unexpected results. One path on
port 34343 failed in the queued test that does not contain options,
188Table 13: Results of Segment Coalescing Test
123 (87%)
138 (97%)
135 (100%)
142 (100%)
142 (100%)
Observed
Behavior
Passed
Coal. ordered
Coal. queued
Coal. both
Error
Total
34343
132 (98%)
1 (1%)
1 (1%)
0 (0%)
1 (0%)
TCP Port
80
1 (1%)
3 (2%)
6 (4%)
9 (6%)
443
0 (0%)