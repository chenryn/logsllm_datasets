那么想到的就是添加代码waitForDebugger，这个方法就是等待debug，还记得在之前的调试smali代码的时候，就是用这种方式让程序停在了启动初，然后等待去用jdb进行attach操作。
这一次可以在System.loadLibrary方法之前加入waitForDebugger代码即可，但是这里不这么干了。还有一种更简单的方式就是用am命令，am命令本身可以启动一个程序，当然可以用debug方式启动：
这里一个重要参数就是-D，用debug方式启动：
运行完之后，设备是出于一个等待Debugger的状态，如图22-36所示。
图22-36  程序处于等待调试状态
这时候，再次使用IDA进行进程的附加，然后进入调试页面，同时设置一下Debugger Option选项，然后定位到JNI_OnLoad函数的绝对地址，如图22-37所示。
但是发现，这里没有RX权限的so文件，说明so文件没有加载到内存中，想一想还是对的，因为现在的程序是wait Debugger，也就是还没有走System.loadLibrary方法，so文件当然没有加载到内存中，所以需要让程序跑起来，这时候可以使用jdb命令去attach等待的程序，命令如下：
图22-37 定位到JNI_OnLoad绝对地址
其实这条命令的功能类似于前一章中说到用Eclipse调试smali源码的时候，在Eclipse中设置远程调试工程，选择Attach方式，调试机的ip地址和端口，还记得8700端口是默认的端口，但是运行这个命令之后，出现了一个错误：
无法连接到目标的VM，那么这种问题大部分都出现在被调试程序不可调试。可以查看apk的android：debuggable属性：
果不其然，这里没有debug属性，所以这个apk是不可以调试的。需要添加这个属性，然后再回编译即可：
回编译：
签名apk：
然后再次安装，使用am命令启动。
1）运行命令：
出现Debugger的等待状态。
2）启动IDA进行目标进程的Attach操作。
3）运行命令：
4）设置Debugger Option选项。
5）点击IDA运行按钮，或者F9快捷键，运行。
看到了，这次jdb成功的attach住了，debug消失，正常运行了，但是同时弹出了一个选择提示，如图22-38所示。
图22-38 so文件选择框
这时候不用管它，全部选择Cancel按钮，然后就运行到了linker模块了，如下所示：
说明so已经加载进来了，再去获取JNI_OnLoad函数的绝对地址，如图22-39所示。
图22-39 获取JNI_OnLoad函数的绝对地址
用Ctrl+S查找到了基地址7515A000，用静态方式IDA打开so查看相对地址1B9C，如下所示：
绝对地址加上相对地址为7515A000+1B9C=7515BB9C，然后点击G键跳转，如图22-40所示。
图22-40 跳转到运行的内存地址
跳转到指定的函数位置，如下所示：
这时候再次点击运行，进入了JNI_OnLoad处的断点，如下所示：
下面就开始单步调试了，但是每次到达BLX R7这条指令执行完之后，JNI_OnLoad就退出了，如下所示：
经过好几次尝试都是一样的结果，发现这个地方有问题，可能就是反调试的地方了，再次进入调试，看见BLX跳转的地方R7寄存器中是pthread_create函数，这个是Linux中新建一个线程的方法。
阿里的反调试就在这里开启一个线程进行轮询操作，如图22-41所示，去读取/proc/[pid]/status文件中的TrackerPid字段值，如果发现不为0，就表示有人在调试本应用，在JNI_OnLoad中直接退出。关于反调试代码在前面已经详细介绍了。
图22-41 反调试代码
问题找到了，现在怎么操作呢？只要把BLX R7这段指令干掉即可，如果是smali代码的话，可以直接删除这行代码即可。但是so文件不一样，它是汇编指令，如果直接删除这条指令的话，文件会发生错乱，因为本身so文件就有固定的格式，比如很多段的内容，每个段的偏移值也是保存的，如果这样去删除会影响这些偏移值，会破坏so文件格式，导致so加载出错的，所以这里不能手动去删除这条指令。还有另外一种方法，就是把这条指令变成空指令，在汇编语言中，nop指令就是一个空指令，它什么都不干，所以这里直接改一下指令即可，arm中对应的nop指令是：00 00 00 00；那么看到BLX R7对应的指令位置为：1C58，如下所示：
查看它的Hex内容是37 FF 2F E1，如下所示：
可以使用一些二进制文件软件进行内容的修改，这里使用010Editor工具进行修改，如下所示：
直接修改成00 00 00 00，如下所示：
保存修改之后的so文件，再次使用IDA进行打开查看，如下所示：
指令被修改成了ANDEQ R0，R0，R0。
修改了之后，替换原来的so文件，再次重新回编译，签名安装。再次按照之前的逻辑给主要的加密函数下断点，这里不需要在给JNI_OnLoad函数下断点了，因为已经修改了反调试功能了，所以这里只需要按照如下简单几步操作即可：
1）启动程序。
2）使用IDA进行进程的attach。
3）找到Java_com_yaotong_crackme_MainActivity_securityCheck函数的绝对地址。
4）打上断点，点击运行，进行单步调试，如下所示：
这里可以单步调试进来了，说明修改反调试指令成功了。
下面就继续用F8单步调试，如下所示：
调试到这里，发现一个问题，就是CMP指令之后，BNE指令就开始跳转到loc_74FAF2D0处，那么就可以猜到了，CMP指令比较的应该就是输入的密码和正确的密码。再次重新调试，看看R3和R1寄存器的值，如下所示：
这里的R3寄存器的值就是用寄存器寻址方式赋值字符串的，这里R2寄存器就是存放字符串的地址，看到的内容是aiyou...但是这里肯定不是全部字符串，因为没看到字符串的结束符：'\0'，点击R2寄存器，进入查看完整内容，如下所示：
这里是全部内容aiyou，bucuoo。继续查看R1寄存器的内容，如下所示：
这里同样用寄存器寻址，R0寄存器存储的是R1中字符串的地址，看到这里的字符串内容是jiangwei，这个就是输入的内容，那么到这里就豁然开朗了，密码是上面的aiyou，bucuoo；再次输入这个密码，就可见到破解成功。如图22-42所示。
图22-42 破解成功效果图
提示：项目下载地址为
http://download.csdn.net/detail/jiangwei0910410003/9531957
注意：时刻需要注意BL/BLX等跳转指令，在它们执行完之后，肯定会有一些CMP/CBZ等比较指令，这时候就可以查看重要的寄存器内容来获取重要信息。
22.5 本章小结
本章主要介绍用IDA调试so文件，这也是一种全新的方式去破解native层的代码。现在有些程序依然把关键代码放在了Java层，那么可以使用Eclipse调试samli文件去破解；如果程序把关键代码放到native层，那么这时候，可以使用IDA来调试so文件去破解。当然破解和加密总是相生相克的。
第23章 逆向加固应用
本章主要介绍如何应对Android中一些apk加固的安全防护，在之前的两章中，可以看到一个是针对于Java层的逆向，一个是针对于native层的逆向，还没有涉及apk的加固，那么本章就要来介绍一下如何应对现在市场中一些加固apk的逆向方法，现在市场中加固apk的方式有两种：一种是对源apk整体做一个加固，放到指定位置，运行的时候再解密动态加载；还有一种是对so进行加固，在so加载内存的时候进行解密释放。本章主要介绍第一种加固方式，就是对apk整体进行加固。
23.1 逆向加固应用的思路
按照逆向惯例，用一个案例来分析讲解，这次依然采用的是阿里的CTF比赛的第三题，如图23-1所示。
图23-1 破解应用界面
题目是：要求输入一个网页的URL，然后跳转到这个页面，但是必须要求弹出指定内容的Toast提示，这个内容是：祥龙！
了解到题目，就来简单分析一下。这里大致的逻辑应该是，输入的URL会传递给一个WebView控件，进行展示网页。如果按照题目的逻辑的话，应该是网页中的JavaScript会调用本地的一个Java方法，然后弹出相应的提示。那么下面就开始操作。
按照之前的破解步骤：
第一步：先用解压软件解压出它的classes.dex文件，然后使用dex2jar+jd–gui查看Java代码，如图23-2所示。
这里只有一个Application类，这个apk可能被加固了，为什么这么说呢？因为一个apk加固，外面肯定得套一个壳，这个壳必须是自定义的Application类，它需要做一些初始化操作，那么一般现在加固的apk壳的Application类都喜欢叫StubApplication。这里可以看到，除了一个Application类，没有其他任何类了，包括入口Activity类都没有了，那么这时候会发现，无处下手了。
图23-2 应用的classes.dex文件
第二步：会使用Apktool工具进行apk的反编译，得到apk的AndroidManifest.xml和资源内容，如下所示：
反编译之后，看到程序会有一个入口的Activity，就是MainActivity类，记住一点，不管最后的apk如何加固，即使看不到代码中的四大组件的定义，也肯定会在AndroidManifest.xml中声明，因为如果不声明的话，运行是会报错的。这里还是没发现入口Activity类，而且知道它肯定是放在本地的一个地方，因为需要解密动态加载，所以不可能是放在网上的，肯定是本地。
这里的技巧如下：当发现apk中主要的类都没有了，肯定是apk被加固了，加固的源程序肯定是在本地，一般会有这么几个地方需要注意的：
·应用程序的assets目录，知道这个目录是不参与apk的资源编译过程的，所以很多加固的应用喜欢把加密之后的源apk放到这里。
·把源apk加密放到壳的dex文件的尾部，这个方式肯定不是本文的案例，但是也有这样的加固方式，遇到这种加固方式会导致用dex2jar工具解析dex失败，这时候就知道了，肯定对dex做了手脚。
·把源apk加密放到so文件中，这就比较难了，一般都是把源apk进行拆分，存到so文件中，分析难度会加大的。
一般都是这三个地方。记住一点，不管源apk被拆分，被加密了，被放到哪了，只要是在本地，都有办法得到它。
按照这上面的三个思路来分析一下，这个apk中加固的源apk放在哪了？通过刚刚的dex文件分析，发现第二种方式肯定不可能，那么会放在assets目录中吗？查看assets目录，如图23-3所示。
图23-3 应用的assets目录
assets目录中的确有两个jar文件，而且第一反应是使用jd-gui来查看jar，可惜的是打开失败，所以猜想这个jar是经过处理了，应该是加密，这里很有可能是存放源apk的地方。但是上面也说了还有第三种方式，去看看libs目录中的so文件，如图23-4所示。
图23-4 应用的libs目录
这里有三个so文件，而上面的Application中加载的只有一个so文件：libmobisec.so，那么其他的两个so文件很有可能是拆分apk文件的藏身之处。
通过上面的分析之后，大致知道了两个地方很有可能是源apk的藏身之处，一个是assets目录，一个是libs目录。那么分析完了之后发现现在面临两个问题：
·assets目录中的jar文件被处理了，打不开，也不知道处理逻辑。
·libs目录中的三个so文件，唯一加载了libmobisec.so文件了。
这里现在的唯一入口就是这个libmobisec.so文件，因为上层的代码没有，没法分析，下面来看一下so文件，如图23-5所示。
图23-5 so中的函数列表
这里没有特殊的方法，比如Java_开头的方法，所以猜测这里应该是自己注册了native方法，混淆了native方法名称。那么到这里，会发现遇到的问题用现阶段的技术是没法解决了。
23.2 获取解密之后的dex文件
分析完上面的破解流程之后，发现首要的任务是先得到源apk程序，通过分析知道，处理源apk程序很难找到，所以就要引出本章的内容了：使用动态调试，给libdvm.so中的函数dvmDexFileOpenPartial下断点，然后得到dex文件在内存中的起始地址和大小，然后dump出dex数据即可。
这里会有人提出几个问题。
第一个问题：为何要在dvmDexFileOpenPartial函数下断点？
不管之前的源程序如何加固，放到哪了，最终都是需要被加载到内存中然后运行，而且是没有加密的内容，那么只要找到dex的内存位置，把这部分数据弄出来就可以了，管它之前是如何加固的，那么问题就变成了，如何获取加载到内存中的dex的地址和大小。这要用到函数dvmDexFileOpenPartial，因为这个函数是最终分析dex文件，加载到内存中的函数：
第一个参数是dex内存起始地址，第二个参数是dex大小。
第二个问题：如何使用IDA给这个函数下断点
在前一章中介绍了动态调试so，下断点的时候必须知道一个函数在内存中的绝对地址，而函数的绝对地址是：这个函数在so文件中的相对地址+so文件映射到内存中的基地址。这个函数肯定是存在libdvm.so文件中的，因为一般涉及dvm有关的函数功能都是存在这个so文件中，那么可以从这个so文件中找到这个函数的相对地址，运行程序之后，再找到libdvm.so的基地址，相加即可。如何获取到libdvm.so文件呢？这个文件是存放在设备的/system/lib目录下的：
只需要使用adb pull命令把这个so文件弄出来就可以了。
解决了这两个问题，下面就开始操作了。
第一步：运行设备中的android_server命令，使用adb forward进行端口转发：
这里的android_server工具可以去ida安装目录中dbgsrv文件夹中找到：
第二步：使用命令以debug模式启动apk：
因为需要给libdvm.so下断点，这个库是系统库，所以加载时间很早。需要像之前给JNI_OnLoad函数下断点一样，采用debugger模式运行程序，这里通过上面的AndroidManifest.xml中得到应用的包名和入口Activity：
而且这里的android：debuggable=true可以进行debug调试的。
第三步：双开IDA，一个用于静态分析libdvm.so，一个用于动态调试libdvm.so。
通过IDA的Debugger菜单，如图23-6所示。进行进程附加操作，如图23-7所示。
图23-6 设置调试端口
图23-7 搜索附加进程