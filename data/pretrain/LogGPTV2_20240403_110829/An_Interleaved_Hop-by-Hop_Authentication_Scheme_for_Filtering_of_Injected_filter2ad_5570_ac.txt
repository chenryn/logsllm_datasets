it ﬁrst receives the beaconing message during the cur-
rent epoch, and then rebroadcasts the beaconing message.
Thus, the path between a cluster head and the base sta-
tion is changed when an intermediate node chooses differ-
ent parent nodes in two consecutive time epochs.
To adapt to path changes, our scheme can execute the
base station hello step for each epoch by piggybacking node
ids in every beaconing message. The cluster acknowledg-
ment process can also be omitted by letting a lower associ-
ation node enclose its id with its pairwise MAC when it for-
wards a report. This strategy works well for networks where
the topology changes frequently at the additional bandwidth
expense of t + 1 ids per beaconing message. For less dy-
namic networks, this overhead should be reduced. Espe-
cially, if a path does not change during different epochs,
it is not necessary for a node to attach its id to the beacon-
ing message.
We adopt a reactive approach for association mainte-
nance in relatively static networks. Recall that in the base
station hello step, every node records s ids that are the ids
of the nodes that are on its path to the base station. Here
s = t + 1 if a node is more than t hops away from the base
station; otherwise s is the actual number of hops from the
base station. A node can infer that its own s upstream nodes
are unchanged if it receives a beaconing message from the
same parent node and the beaconing message is in its orig-
inal format (i.e., no node ids are added), and if a node for-
wards the original beaconing message only if its own s − 1
upstream nodes are unchanged. We can see that if a path
is unchanged during different epochs, our scheme will not
incur any additional bandwidth overhead. However, when
a node selects a parent node that is different from the one
Proceedings of the 2004 IEEE Symposium on Security and Privacy (S&P’04)  
1081-6011/04 $ 20.00 © 2004 IEEE 
in the previous epoch, it sends a request to the new parent
node to get the ids of s − 1 upstream nodes, and then at-
taches these s − 1 node ids and its own id to the beaconing
message it is forwarding.
2.6.2. Local Repair In the base station initiated repair
scheme, if the underlying routing protocol has a large bea-
coning period, the failure of an intermediate node on a path
may cause many reports to be dropped. Therefore, it is nec-
essary for the nodes detecting the failure of a neighbor to
locally repair a path that avoids the failed node. This will
result in inconsistent node association relationship in our
scheme. Thus, we need a scheme to locally repair the asso-
ciation relationship adaptively.
Our approach for local repair is based on the right-hand
rule in the greedy parameter stateless routing (GPSR) pro-
tocol [11]. Here we assume every node knows the locations
or relative locations of its neighbors (e.g., because of GPS).
Fig. 5 illustrates the approach. When node u4 detects its
parent node u5 has failed (the issue of node failure detec-
tion is out of our scope), it sends a REPAIR message to w1,
which is the ﬁrst node counterclockwise about u4 from edge
(u4, u5). The REPAIR message includes the ids of t + 1
upstream nodes of u4 except u5; that is, it includes the id
list {u6, u7, u8}. w1 and w2 forward the REPAIR message
based on the same rule. When w3 receives the message, it
ﬁnds that its next node is u6 based on this rule and u6 is in
the list {u6, u7, u8}, which means that the failed node has
been bypassed. w3 then requests an id list from u6, which
includes the ids of t upstream nodes of node u6 and u6.
Node w3 then forwards the list to its downstream nodes in
the same way as in the base station hello step. Thus, every
node whose associations have been changed reestablishes
its association relationship proactively.
Note that although a local repair process is necessary
to maintain path connectivity, it is also very important to
limit the frequency with which the process is invoked. Oth-
erwise, a compromised node may invoke this process very
frequently to consume the energy of the involved nodes. To
thwart this attack, for instance, we can limit the number of
invocations to be at most one within one beaconing epoch.
2.7. Interaction with Routing Protocols
The advantage of the two-way association discovery pro-
tocol described above is its independence from the underly-
ing protocols, making it applicable for various sensor net-
work applications. On the other hand, we note that the as-
sociation discovery process usually overlaps with the route
discovery process in a routing protocol. Therefore, in prac-
tice we can combine the association discovery protocol with
the underlying routing protocol if it is beneﬁcial. As de-
scribed earlier, we can integrate the base station hello pro-
cess with the TinyOS beaconing protocol [10] by piggy-
backing the ids of the upper association nodes in a bea-
coning message. As another example, if we want to adapt
our scheme to the GPSR [11] protocol, in addition to pig-
gybacking node ids, the base station should unicast (instead
of broadcast) its HELLO messages to the next node towards
the cluster head, based on the location of the cluster head.
3. Security Analysis
We discuss the security of our scheme with respect to our
two design goals, i.e., the ability of the base station to de-
tect a false report and the ability of the en-route nodes to ﬁl-
ter false reports.
3.1. Base Station Detection
Our authentication scheme requires that each of t + 1
cluster nodes compute an individual MAC based on its au-
thentication key that is only shared with the base station.
Thus, it guarantees that an adversary has to compromise at
least t + 1 nodes to be able to forge a report to deceive the
base station. Note that our scheme compresses t + 1 indi-
vidual MACs into one MAC based on the bitwise XOR op-
eration (instead of attaching t + 1 individual MACs) to re-
duce message overhead. This compression scheme is secure
because it is a special case of the XOR-MAC scheme [1]
which is proven to be secure.
3.2. En-route Filtering
In this section, we discuss the en-route ﬁltering capabil-
ity of our scheme for two attack models, namely, outsider
attacks launched by an adversary that has not compromised
any nodes, and insider attacks launched by an adversary that
has compromised up to t nodes.
3.2.1. Outsider Attacks In our scheme, every message is
authenticated in a hop-by-hop fashion during its transmis-
sion. Thus, an unauthorized node cannot inject false data
without it being detected. Moreover, because an event also
contains a timestamp, an attack in which an outsider replays
an old report will be detected.
3.2.2. Insider Attacks We consider several insider at-
tacks by up to t compromised nodes. We ﬁrst discuss
the security of our scheme under the assumption that ev-
ery node knows the authentic ids of its upper association
and its lower association. This corresponds to the situa-
tions in which every node is loaded with correct associa-
tion knowledge before it is deployed, or every node learns
the ids of its association nodes through the association dis-
covery process before any nodes are compromised. A com-
promised node can provide an authenticated pairwise MAC
over any data to deceive its upper association node. Thus,
Proceedings of the 2004 IEEE Symposium on Security and Privacy (S&P’04)  
1081-6011/04 $ 20.00 © 2004 IEEE 
u10
u9
u8
u7
u6
BS
w3
u3
u2
u1
3
u4
w1
u5
1
w2
2
v1
CH
v2
v3
Figure 5. An example showing the local repair process when node u5 fails and node u4 establishes a
new path towards BS. The new path includes nodes w1, w2 and w3.
if totally t nodes are compromised, they can provide t au-
thenticated pairwise MACs over a false report, which will
bypass the veriﬁcations of t noncompromised upper asso-
ciation nodes. However, in our scheme every report must
provide t + 1 pairwise MACs; therefore, one noncom-
promised node will ﬁlter out the false report because the
pairwise MAC from its lower association node will be in-
valid. Thus, our scheme guarantees that a false report will
be dropped after it is forwarded by at most t noncompro-
mised nodes.
The above analysis indicates that the security of our
scheme relies on the assumption of authenticated associa-
tion knowledge. Thus, we need to analyze the security of
the association discovery process that provides association
knowledge to nodes. More speciﬁcally, the security of the
cluster acknowledgment process is critical because it pro-
vides the lower association knowledge that is used as the ba-
sis for en-route ﬁltering to the nodes. The cluster acknowl-
edgment process is subject to attack if it is executed at any
time after t nodes have been compromised.
Before we show two types of attacks on the cluster ac-
knowledgment process, we ﬁrst clarify the attack model.
Recall that in the cluster acknowledgment phase, when a
node u receives an acknowledgment message ACK from
its downstream neighbor ( authenticated with their pairwise
key), it veriﬁes the ACK and then checks if all the ids in the
id list in the ACK are distinct. If the check is successful, it
will set the id of its lower association node to the last id in
the list. Then it removes the last id and adds its own id to the
beginning of the list. The goal of an attack on this process is
to lower associate more than t noncompromised nodes to t
compromised nodes, under the constraint that t + 1 distinct
ids must appear in the list when the ACK is forwarded.
This attack is possible mainly because in a multi-hop pair-
wise key establishment process, two nodes do not know the
actual number of hops between them. In other words, when
a node u establishes a pairwise key with another node v, it
trusts v only because v can compute the same secret key –
it does not know where v is.
Proceedings of the 2004 IEEE Symposium on Security and Privacy (S&P’04)  
1081-6011/04 $ 20.00 © 2004 IEEE 
Cluster Insider Attacks In this attack, all the t compromised
nodes are from the cluster (possibly including the cluster
head); that is, no nodes on the path to the base station are
compromised. Because the ACK from the cluster head to-
wards the base station must contain t + 1 distinct node ids,
it must include the id of a noncompromised or nonexistant
node. Therefore, one of the t + 1 relaying nodes closest
to the cluster head (e.g., node u1, u2, u3 and u4 in Fig. 4)
will be lower associated to a noncompromised or nonexis-
tant node. This node will drop a false report. Thus, we reach
the same conclusion that a false report will be dropped af-
ter it is forwarded by at most t noncompromised nodes.
En-route Insider Attacks In this attack, t compromised
nodes that lie on the path to the base station collude to at-
tack the cluster acknowledgment process. The worst case
scenario occurs when the cluster head CH and t − 1 for-
warding nodes are compromised, and these t compro-
mised nodes are equally separated by t noncompromised
nodes. In other words, t compromised nodes isolate t2 non-
compromised nodes into t blocks of t nodes each. Let the
ids of the nodes from CH to BS be
CH,{u1,1, u1,2, ..., u1,t}, X1,{u2,1, u2,2, ..., u2,t},
X2, ..., Xt−1,{ut,1, ut,2, ..., ut,t}, ..., BS.
of
the
the
ids
nodes
compromised
Here
are
CH, X1, X2, ..., Xt−1, and two consecutive compro-
mised nodes are segregated by t noncompromised nodes
ui,j(1 ≤ i, j ≤ t). The cluster head CH ﬁrst forges
a list of t + 1 ids, among which the ﬁrst one is a ran-
domly picked legitimate id y and the other t ids are
the ids of the t compromised nodes. For example, the
id list could be {y, CH, X1, X2, ..., Xt−1}. Accord-
ing to the cluster acknowledgment process, every noncom-
promised node between u1,1 and u1,t sets its lower as-
sociation node as the last id in the list, removes the last
id and then inserts its own id to the beginning of the list.
Thus, each of nodes u1,1, u1,2, ..., u1,t is lower associ-
ated to a compromised node. The id list node u1,t out-
puts is {u1,t, ..., u1,2, u1,1, y}; therefore, the next en-route
node will be lower associated to y. If the next node has
not been compromised yet, it will drop any false data im-
mediately because it will not see a valid pairwise MAC
provided by y. To resume the forwarding of the false re-
port,
the adversary has to compromise the next node,
here X1. X1 does not forward this id list
to its up-
stream neighbor u2,1; instead, it forges the same or a
similar id list as the one generated by CH. Thus, simi-
larly each of u2,1, u2,2, ..., u2,t is lower associated with one
compromised node. Repeatedly, we can easily see that to-
tally t2 nodes (t in each block) are associated with the same
set of t compromised nodes. Thus, in this case, a false re-
port will be dropped after it is forwarded by at most t2
noncompromised nodes. We note, however, that this up-
per bound corresponds to the worst case; an adversary
has to compromise t nodes selectively to achieve this up-
per bound.
Enhancements to the Basic Scheme The above conclusion
that in the worst case t compromised nodes can collude to
deceive t2 noncompromised nodes is drawn based on the as-
sumption that every node only checks if an id list includes
t+1 distinct ids. We can further reduce this upper bound by
adding more constraints that are easy to implement in prac-
tice.
First, we can exploit the fact that in our scheme each
node knows its authenticated neighbor set. When an en-
route node receives an id list in an acknowledgment mes-
sage from a downstream node, it additionally checks if the
downstream node is the ﬁrst one in the list because in our
scheme a node adds its own id to the beginning of an id list.
Consider the ﬁrst block in the above worst case. Under
this constraint the cluster head CH has to place CH at the
beginning of the list and y as the second id in the list when
it sends a false list to u1,1. As a result, the adversary has to
compromise the node that is t hops away from CH to re-
generate a false list because y becomes the last one in the
id list after the list is forwarded for t − 1 hops. In other
words, there are at most t − 1 noncompromised nodes be-
tween them (i.e., no u1,t). Thus, the upper bound t2 is re-
duced to t(t − 1).
Furthermore, instead of simply adding its own id to the
list, a node can add an id pair that includes its id and the
id of its lower association. Consider the ﬁrst block again. If
the list which CH sends to u1,1 includes X1, then one of
u1,1, u1,2, ..., u1,t−1, say u1,i(1 ≤ i ≤ t − 1), will have X1
as its lower association node. Since a node also adds the id
of its lower association node to the list, node u1,t−1 will see
the pair {u1,i, X1} in the list. Because X1 is its neighbor,
u1,t−1 knows that X1 cannot be a lower association node
of one of its downstream nodes. Therefore, to avoid being
detected by u1,t−1, the adversary will not include X1 in the
list in this block. Similarly, the adversary will not include
the id of one of the compromised nodes in the list in other
blocks. Thus, we achieve the upper bound t(t − 2).
Second, our scheme can add a node feedback mecha-
nism to facilitate compromise detection. For example, after
a node receives a certain number of false data packets, it will
send an ALERT report to the base station. An ALERT report
contains information such as the id of the node from which
a node received false data. The base station can then take
necessary actions such as traceback to identify the compro-
mised node. Traceback is possible in our scheme because
every packet is authenticated during its transmission and a
compromised node is localized (see Section 3.3 for details).
A compromised node may drop any ALERT report going
through it, but it cannot force the nodes between itself and
the base station to do the same. Thus, to avoid being de-
tected for false data injection, the compromised node that is
closest to the base station will need to drop the false data in-
jected by a colluding compromised node.
Consider the above worst case scenario again. Node
Xt−1 will need to drop any false data injected by its coali-
tion. Thus, the adversary can mount false data injection at-
tacks to consume the energy of the relaying nodes between
CH and Xt−1 without being known by the base station. To
this end, if the adversary wants to achieve this goal, it can at
most deceive (t − 1)(t − 2) noncompromised nodes to re-
lay false data. For example, if t = 4, we have the upper
bound 6; if t = 5, the upper bound is 12.
Third, if all sensor nodes possess GPS devices, our
scheme can further reduce the upper bound greatly, at the