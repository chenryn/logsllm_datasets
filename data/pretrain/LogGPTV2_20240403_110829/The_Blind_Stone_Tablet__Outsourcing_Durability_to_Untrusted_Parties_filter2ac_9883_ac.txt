### 4.3 隐私
在不知道共享对称密钥K的情况下，服务器无法从加密的交易描述中获取任何信息，除了时间和大小。交易槽请求不包含任何额外的信息。

### 5 无锁外包序列化和持久性
上述协议的一个明显缺点是它需要一个全局锁，这限制了交易处理，因为每次只能有一个客户端处于活动状态。我们现在将从上述协议中移除所有锁定机制，并用一种乐观冲突检测机制来替代。这允许客户端同时运行交易，但要求在发生冲突时回滚并重新提交交易。

总体来看，该协议的工作流程如下：
1. 客户端首先发出其待处理交易的通知（加密），通过不可信的服务器转发给其他客户端。通知中包含足够的信息，使其他客户端能够判断是否可能与自己的待处理交易发生冲突。
2. 在此通知（“预提交”）之后，客户端检查其待处理交易是否可能与任何预定在其之前运行的交易发生冲突。如果没有冲突，它们会提交；否则，它们会使用新的请求重试。
3. 与之前的协议一样，客户端维护一个交易哈希链以保证对行为不当的服务器的一致性。

在这种解决方案中，执行交易涉及以下步骤（如图1所示）：
1. 客户端在其本地数据库副本上模拟预期交易，然后在其自己的数据库副本上撤销该交易（即发出Model部分定义的`RollbackLocal`命令）。只有在应用了所有待处理交易后，才会正确应用该交易。
2. 当准备提交时，客户端向服务器发出“请求槽位”命令，并附上其预期交易的加密预提交描述P以及最新的已知槽位号l。
3. 服务器分配一个槽位s，并返回从Pl到Ps-1的所有新预提交描述列表。服务器还可以选择发送客户端尚未看到的任何先前提交的交易（例如，如果客户端刚刚加入或离线了一段时间）。
4. 客户端验证每个预提交的签名，并检查其交易是否与这些预提交交易发生冲突（冲突语义在第3节中讨论）。例如，如果预提交Pj与客户端d的交易发生冲突，且l < j，则客户端d会在k处应用来自客户端c的更新。
5. 如果没有冲突，客户端提交交易；否则，它会回滚并重新尝试。

### 证明
假设客户端d已经应用了来自客户端c的更新k。因此，客户端d计算HC(k)的结果与Ck.pre-hashchain一致，且交易内容一致。因此，不一致性在于交易j的提交/中止状态。由于客户端c在发出更新k之前已经应用了交易j，所以Ck.commit-hashchain-position ≥ j。同样，由于客户端d已经应用了交易i，客户端d会验证Ck.commit-hashchain与其自己计算的链链接一致。然而，由于这两个链链接有不同的输入值（一个表示交易j已提交，另一个表示未提交），因此会产生哈希冲突。

通过这种方式，我们可以确保即使在并发环境下，交易的一致性和持久性也能得到保证。