crypt and reveal the relevant N from OV ’s show protocol
transcript. There may be several de-anonymizing organiza-
tions in the system, from which U may be able to chose. By
including also a de-anonymization condition, U can decide
under which condition he consents to the transcript being
de-anonymized. Later, when deemed necessary by OV , OV
can send the transcript to OD. OD can then decide whether
this condition is fulﬁlled and, if so, de-anonymize the tran-
script and returns N (local de-anonymization).
Global de-anonymization uses essentially the same tech-
nique.
It requires, in addition, the existence of a special
credential issuing organization, a Root Pseudonym Author-
ity, which only issues credentials on pseudonyms of which
it knows the mapping with a real user identity. A user typ-
ically has a single pseudonym (root pseudonym) with the
Root Pseudonym Authority, and one credential (root cre-
dential) on that root pseudonym (additional pseudonyms or
credentials with the Root Pseudonym Authority would any-
way be linkable to the user).
2.3.2
Showing a Credential Relative to a Pseudonym
Using this option, U , who has obtained a credential C by
OI on NI , and who is known under pseudonym NV to OV ,
proves possession of C to OV , while also proving that the
pseudonym to which C was issued belongs to the same user
as does NV . More precisely, the user proves that the same
master secret key SU that is linked to NV is also linked to
the credential C and the pseudonym (NI ) the credential C
is issued on.
This option is mandatory for U to convince OV of posses-
sion of several credentials. Without using the option, two
users each possessing a diﬀerent credential could each show
their credential to OV and fool OV into believing that it
talked to a single user possessing both credentials.
Furthermore, this option is also mandatory if showing of
a credential is a precondition for a user to get another cre-
dential. The reason for this can be seen from the following
example. Let us assume that U wants to obtain a credential
from OVI; OVI, in order to issue such a credential, requires
U to show a credential by OI . If U has such a credential, he
ﬁrst registers a pseudonym NVI with OVI, and then shows
the credential by OI to OVI, upon which OVI considers the
precondition to be satisﬁed and issues the new credential on
NVI. If U has no such credential, he can try to collaborate
with U0 (who does own the credential) by asking U0 to per-
form the second step (showing the credential by OVI). And
indeed, if OVI does not require U to show the OI credential
relative to a speciﬁc pseudonym, U will obtain the credential
from OVI without fulﬁlling the precondition. By requiring
to show the OI credential relative to NVI, OVI enforces that
the same user who showed the OI credential gets the new
OVI credential.
3. CREDENTIAL SYSTEM PRIMITIVES
In this section, we start out by describing representa-
tions for pseudonyms and credentials, and then deﬁne rep-
resentations of credential attributes and protocol options.
Subsequently, we describe the high-level primitives of the
pseudonym system.
3.1 Pseudonyms
A pseudonym N of user U with OI cannot be mapped to
a data representation shared by U and OI : U has a secret
value (other than the user’s master secret) attached to each
pseudonym N - knowledge of this secret value is required
to make any operation with pseudonym N , such as obtain-
ing a credential. Thus, an implementation of the credential
system needs diﬀerent representations (or data types) for
23Nym(N, Ns, U, O, X) is represented in reality by two sets
O verifyCredential
U registerNym
O registerNym
U getCredential
O issueCredential
U showCredential
IN: UserSecret
OUT: UserNym
IN: -
OUT: Transcript (incl. OrgNym)
IN: UserSecret,UserNym, CredInfo
OUT: UserCred
IN: OrgKeys, OrgNym, CredInfo
OUT: Transcript (incl. OrgCred)
IN: UserSecret, UserCred, CredInfo,
CredShowFeatures, [UserNym]
OUT: -
IN: OrgKeys, CredInfo,
CredShowFeatures, [OrgNym]
OUT: Transcript
a pseudonym, depending on the role of the actor (user or
organization).
Nym(N, Ns, U, O, X) could be an abstract representation
of a pseudonym of user U with organization O. N is common
to U and O and uniquely identiﬁes the pseudonym to both
U and O. Ns is the secret value associated by the user with
the pseudonym. X is a statement or set of statements which
O attaches to N : information obtained during registration
(e.g., a real user identity in the case of root pseudonym regis-
tration) as well as up-to-date information about credentials
issued to N .2
of data:
UserNym(N, Ns, O), and OrgNym(N, X).3
Note that the user’s master secret SU , though essential in
using the UserNym, is common to all a user’s pseudonyms
and is not considered part of the UserNym representation.
Note also that the statement X is application-speciﬁc, and
is not explicitly supported by the core of the pseudonym
system as it is introduced in Section 4.
O does not authenticate to U during pseudonym registra-
tion. While this is not a security threat, as the registration
does not reveal any information about U , SU or Ns, the
registration of a pseudonym with an impersonator of O can
lead to denial of service when U then tries to obtain a cre-
dential on N from O. For this and other reasons discussed
in Section 6, we assume every O to have a certiﬁcate with
which to authenticate communication with users.
3.2 Credentials
Credentials have a diﬀerent representation at the user and
at the organization side as well: when a credential C is issued
by OI on N , user and organization get to store diﬀerent
values associated with it.
Cred(N, Ns, U, OI , C, T ) represents a credential, issued by
organization OI on pseudonym N of user U . T represents
the credential’s type (CredInfo), including the speciﬁc issu-
ing key (PKI ) options and attributes:
CredInfo(PKI , MultiShow, Expiration, Subtype, Age, ...).
Using a similar reasoning as for pseudonyms, Cred(N, Ns,
U, OI , C, T ) expresses a relationship between
UserCred(UserNym, C, T, OI ) and OrgCred(OrgNym, T ).
3.3 CredShowFeatures
The parameters of a credential showing are expressed in
a CredShowFeatures parameter array. The parameter Rel-
Nym indicates whether the show is relative to a pseudonym
known to the verifying organization (in which case an addi-
tional argument NV will indicate this pseudonym). Another
2Nym(N, Ns, U, O, X) is the equivalent of following state-
ment: The value N is known by U and O to be a valid
pseudonym according to the credential system speciﬁcation.
This means that there has been a pseudonym registration
procedure between U and O, during which both U and O
contributed to the value of the pseudonym, and during which
O veriﬁed that N is based on a well-formed secret SU . Dur-
ing that registration procedure, O associated X with N . U ’s
contribution is linked to U s master secret SU as well as to
the new pseudonym-speciﬁc user secret Ns in a way that
credentials issued on N are linked to these secrets.
3The term DataType(Field1, Field2, . . .) informally deﬁnes
the contents of a data set of type DataType.
Primitive
Inputs/Outputs
O checkDoubleSpendingIN: OrgKeys, Transcript, Transcript
DO deAnonymize
OUT: OrgNym
IN: DeAnOrgKeys, Transcript
OUT: OrgNym
Figure 3: Protocol Primitives
parameter contains de-anonymization information specify-
ing whether, under which condition and by which de-anony-
mization organization OD (or which public key PKD) the
show transcript will be de-anonymizable (local or global de-
anonymization):
CredShowFeatures(RelNym, [PKD, ConditionLocal],
[PKD, ConditionGlobal])
3.4 Protocol Primitives
Figure 3 lists the basic protocol primitives for regis-
tering pseudonyms, issuing and verifying credentials, ver-
ifying double-spending of one-show credentials, and de-
anonymizing. Primitives invoked by a user (respectively org,
de-anonymizing org) carry the preﬁx U (O , DO ).
In the user-invoked (U ) primitives, the identiﬁer of the
targeted organization (OI , OV ) is not listed as parameter:
it is assumed that the application calling the user primitives
has set up a communication channel with the correct organi-
zation, using addressing information obtained at application
level.
The organization (O ) versions of these primitives result
in a Transcript of the protocol which, among the crypto-
graphic transcript and other application data, includes also
the newly established OrgNym or OrgCred. The calling ap-
plication is responsible for extracting this information and
store it in appropriate persistent storage.
When showing a credential with CredInfo T , a user can
choose which subset of attributes he wants to prove, and
what to prove about them, by setting the CredInfo pa-
rameter T 0 in the UserShowCredential() primitive. This T 0
is communicated to the verifying organization and used as
CredInfo parameter also in OrgVerifyCredential(). E.g., if
T .Age=‘55’, T .Expiration=‘20020831’,
T 0.Age=‘>18’, T 0.Expiration=‘any’
then the show protocol will only prove that T .Age>18.
plication should verify whether canFulﬁll(T , T 0) holds.
Before executing the show protocol, the calling user ap-
The de-anonymization primitive does not check the con-
dition for de-anonymization (which is included in the tran-
script to be de-anonymized): this is assumed to be the ap-
plication’s responsibility.
24The NymSystem library is stateless and consists of static
methods: i.e., the calling application is responsible for pro-
viding all the cryptographic information (including system
parameters, such as key lengths, and the actual key ma-
terial) when calling the library methods5. E.g., when a
user master secret is generated using createUser(), the result
(UserNymSysData) contains the master secret as well as the
system parameters, and is a parameter to any of the cryp-
tographic protocols. For ease of application programming
and to avoid repeated ﬁle access for key material by User-
App and OrgApp, the synchronous extensions which are de-
scribed in the next section were given a non-persistent state:
the classes implementing them contain static variables with
handles to system parameters and key material. The organi-
zation’s public key can be extracted from the OrgNymSys-
Data (and distributed to users upon system setup or up-
date).
4.2 UserSyncNymSystem and OrgSyncNym-
System Synchronous Interfaces
The token-based interfaces of UserNymSystem and Org-
NymSystem leave the task of driving the protocols to the
calling application. It is also the calling application’s respon-
sibility to communicate the meta-information that allows
user and organizations to initialize their respective protocol
state machines; e.g., it is up to the calling user application to
communicate to the organization which kind of credentials
and with which options/features it wants to prove possession
of, or what type of credential or data it wants to get.
To enable easy programming of synchronous applications
on top of this token-based interface, the synchronous inter-
faces (Figure 5) UserSyncNymSystem and OrgSyncNymSys-
tem take care of the signalling of meta-information as well
as of driving the protocol state machines. They require the
respective UserApp and OrgApp to pass a communication
(ClientCommSession, ServerCommSession) object. This al-
lows the calling application to decide whether to create a
new communication session for the exchange, or to re-use
a communication channel in use by the application; it also
allows the calling application to decide which protocols are
run within the same communication session. This allows
maximal ﬂexibility when hooking idemix as an authentica-
tion mechanism into an existing application.
4.3 DeAnonOrgNymSystem
A deanonymizing organization does not carry out in-
teractive protocol.
It may receive a transcript to be
deanonymized from any out-of-band communication chan-
nel, and may be operating in batch or asynchronous mode.
Therefore, DeAnOrgNymSystem only has an asynchronous
interface (Figure 5): it provides methods for creation of the
organization and for de-anonymizing a transcript. Also here,
the public key in DeAnOnOrgNymSysData (resulting from
the createDeAnOrg()) can be extracted in order to be dis-
tributed to users.
4.4 Communication
ClientCommSession and ServerCommSession are deﬁned
as interfaces oﬀering generic read and write methods.
It
is up to the calling applications to pass a communication
5This diﬀers slightly from the earlier version described in [5],
where NymSystem was parametrized with ﬁle locations of
secret keys
Figure 4: User, Org, and DeAnOrg components
Additional primitives, such as for generating parties’ key
pairs and master secrets (and extracting the public informa-
tion from them), are described in the next section.
4. THE IDEMIX PROTOTYPE
In this Section, we describe design and implementation
(Java) of the idemix prototype. The core of the idemix
system is the NymSystem package as described in [5] im-