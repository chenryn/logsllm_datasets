10
20
30
40
Worm Samples in Suspicious Pool
50
Figure 6. Number of worm samples required
when under ‘coincidental-pattern’ attack.
We used between 2 and 50 samples generated in this way in
Polygraph’s suspicious pool, and another 1000 generated in
this way to measure the false negative rates.
Figure 6 shows the false negative rates of Polygraph’s
signatures generated for this attack. Bayes is resilient to the
attack, because it does not require every one of the com-
mon tokens to be present to match. However, the conjunc-
tion and subsequence algorithms need a greater number of
worm samples than before to create a sufﬁciently general
signature.
Another concern is the red herring attack, where a worm
initially speciﬁes some ﬁxed tokens to appear within the
wildcard bytes, causing them to be incorporated into sig-
natures. Over time, the worm can stop including these
tokens, thus causing previously produced signatures to no
longer match. Again, Bayes should be resilient to this at-
tack, because it does not require every token in its signature
to be present to match a worm ﬂow. For the other signa-
ture classes, the signature must be regenerated each time
the worm stops including a token.
Innocuous Pool Poisoning: After creating a polymorphic
worm, an attacker could determine what signatures Poly-
graph would generate for it. He could then create otherwise
innocuous ﬂows that match these signatures, and try to get
them into Polygraph’s innocuous ﬂow pool. If he is suc-
cessful, then the worm signature will seem to cause a high
false positive rate. As a result, the signature may not be
generated at all (when using clustering), or the system may
conclude that the signature is insufﬁciently speciﬁc.
This problem can be addressed in several ways. One way
is for Polygraph to collect the the innocuous pool using a
sliding window, always using a pool that is relatively old
(perhaps one month). The attacker must then wait for this
time period between creating a worm and releasing it. In
the case of a non-zero-day exploit, a longer window gives
time for other defenses, such as patching the vulnerability.
Another defense is to deploy distributed Polygraph mon-
itors, each using a locally collected innocuous pool. This
would make it signiﬁcantly more difﬁcult for the attacker to
poison all innocuous pools. It also offers other added ben-
eﬁts, such as decreasing the time needed to detect a new
worm.
Long-tail Attack: Matching on network ﬂows is tricky, be-
cause we cannot examine the entire ﬂow at once—we must
let packets through. Sometimes an exploit could have al-
ready occurred by the time we see a full signature match.
For the token-subsequence signature, it may be desirable
to prune off the end of the signature, and keep just enough
to ensure few false positives. For a Bayes signature, the
ﬂow can be matched before we see every token in the signa-
ture. In either case, it may also be desirable to buffer/throttle
streams that are in the middle of a partial match.
7. Discussion
We have presented three classes of signatures, and an
algorithm to generate signatures for each class. The ques-
tion remains—which algorithm and signature class should
be used?
All three signature classes have advantages and disad-
vantages. The token-subsequence signature class produces
ordered signatures that are more speciﬁc than the equivalent
unordered conjunction signatures. However, some exploits
may contain invariants that can appear in different orders.
In that case, the token-subsequence signature will consist of
only the tokens that appear in a consistent order, and may
actually be less speciﬁc than a conjunction signature for the
same worm. The Bayes signature class can be generated
more quickly than the others, and is more useful when there
are tokens that only appear some of the time.
All three algorithms are promising, but no one algorithm
is superior to the others for every worm. The most resilient
approach for using these algorithms is to consider all three,
and use the signature that appears to have the fewest false
positives and false negatives.
8. Related Work
The Bro [20] and Snort [21] IDSes monitor network traf-
ﬁc, and search the monitored trafﬁc for signatures of known
worms and other intrusions; Polygraph solves the comple-
mentary problem of how to provide the signature database
required by an IDS automatically. We note that both Bro
and Snort support matching regular expression signatures
in reassembled TCP ﬂows, and thus already support match-
ing the token subsequence signatures generated by Poly-
Proceedings of the 2005 IEEE Symposium on Security and Privacy (S&P’05) 
1081-6011/05 $ 20.00 IEEE
graph. Shield [26] uses manually generated vulnerability-
based signatures to ﬁlter out attack ﬂows on a host. These
vulnerability-based signatures could be effective against
polymorphic worms, however, they need to be manually
generated.
Honeycomb [14], Autograph [13], and EarlyBird [22] all
generate signatures for novel worms automatically. While
these three systems produce signatures by different means,
they share a common signature type: a single, contiguous
string. As discussed in Section 2.4, these signatures often
fail to match polymorphic worm payloads robustly.
TaintCheck [18] is a tool for automatic exploit detec-
tion and signature generation. Besides being able to de-
tect very accurately when monitored software is exploited,
it proposes a novel method for automatic signature gen-
eration, semantic-based signature generation—instead of
the pattern-based signature generation methods in Honey-
Comb [14], EarlyBird [22], Autograph [13], and Polygraph,
which is based on extracting common patterns in sample
ﬂows, TaintCheck proposes to automatically generate sig-
natures using information about the vulnerability and how
it is exploited. As a ﬁrst step, TaintCheck demonstrated
how to automatically extract values used to overwrite the
high-order bytes of the jump target and use that as an in-
variant part of a signature. Extensions to such semantic-
based signature generation could be used to identify other
invariant parts for signatures such as protocol framing [18].
Semantic-based signature generation could serve as a com-
plimentary approach for signature generation for polymor-
phic worms.
Finally, the problem of motif-ﬁnding in computational
biology is reminiscent of that of ﬁnding a signature for a
polymorphic worm: given long strings, ﬁnd extremely sim-
ilar short strings (motifs) contained in them [16, 8, 27, 28].
The underlying assumption in motif-ﬁnding, however, is
that differences in non-motif regions of the strings are
changes caused by random perturbations that occur at a sig-
niﬁcantly lower rate in the motif regions.
9. Conclusion
The growing consensus in the security community is
that polymorphic worms portend the death of content-based
worm quarantine—that no sensitive and speciﬁc signatures
may exist for worms that vary their content signiﬁcantly
on every infection. We have shown, on the contrary, that
content-based ﬁltering holds great promise for quaran-
tine of polymorphic worms—and moreover, that Polygraph
can derive sensitive and speciﬁc signatures for polymor-
phic worms automatically. We observe that it is the rigid-
ity of many software vulnerabilities that enables matching
of polymorphic worms by ﬁxed signatures; exploits fre-
quently must incorporate invariant byte sequences in order
to function correctly. We have deﬁned the signature gen-
eration problem for polymorphic worms; provided exam-
ples that illustrate the presence of invariant content in poly-
morphic worms; proposed conjunction, token-subsequence,
and Bayes signatures classes that speciﬁcally target match-
ing polymorphic worms’ invariant content; and offered and
evaluated Polygraph, a suite of algorithms that automati-
cally derive signatures in these classes. Our results indi-
cate that even in the presence of misclassiﬁed noise ﬂows,
and multiple worms, Polygraph generates high-quality sig-
natures. We conclude that the rumors of the demise of
content-based ﬁltering for worm quarantine are decidedly
exaggerated.
10. Acknowledgments
Thanks to Dan Ferullo, David Brumley, and Hyang-
Ah Kim for their help in dissecting exploits. Thanks to
Shobha Venkataraman for feedback and pointers into ma-
chine learning literature. Thanks to Lisa Sittler and James
Gurganus for their assistance in gathering network traces.
Finally, thanks to the anonymous reviewers for their insight-
ful feedback.
References
[1] CERT advisory CA-2002-27. http://www.cert.org/
advisories/CA-2002-27.html.
[2] CERT advisory CA-2003-04. http://www.cert.org/
advisories/CA-2003-04.html.
[3] K2,
admmutate.
http://www.ktwo.ca/c/
ADMmutate-0.8.4.tar.gz.
[4] The Metasploit project.
http://www.metasploit.
com.
[5] SANS Institute: Lion worm. http://www.sans.org/
y2k/lion.htm.
[6] Symantec
Security Response:
CodeRed Worm.
http://www.sarc.com/avcenter/venc/data/
codered.worm.html.
[7] Viruslist.com: Net-Worm.Linux.Adm.
http://www.
viruslist.com/en/viruses/encyclopedia?
virusid=23854.
[8] T. L. Bailey and C. Elkan. Fitting a mixture model by expec-
tation maximization to discover motifs in biopolymers.
In
Proceedings of the Second International Conference on In-
telligent Systems for Molecular Biology, pages 28–36. AAAI
Press, Menlo Park, California, 1994.
[9] C. CAN-2003-0245. Apache apr-psprintf memory cor-
ruption vulnerability. http://www.securityfocus.
com/bid/7723/discussion/.
[10] T. Detristan, T. Ulenspiegel, Y. Malcom, and M. V. Under-
duk. Polymorphic shellcode engine using spectrum analysis.
http://www.phrack.org/show.php?p=61&a=9.
[11] D. Gusﬁeld. Algorithms on Strings, Trees and Sequences.
Cambridge University Press, 1997.
[12] L. Hui. Color set size problem with applications to string
matching. In Proceedings of the 3rd Symposium on Combi-
natorial Patttern Matching, 1992.
[13] H.-A. Kim and B. Karp. Autograph: toward automated, dis-
tributed worm signature detection. In Proceedings of the 13th
USENIX Security Symposium, August 2004.
Proceedings of the 2005 IEEE Symposium on Security and Privacy (S&P’05) 
1081-6011/05 $ 20.00 IEEE
to ﬁnd the longest substring common to a set of suspi-
cious samples [15]. We wish to quantify how much bet-
ter a longer substring is than a shorter substring. This
can help to answer questions such as, “Which is a more
speciﬁc signature- a twenty byte string or the conjunc-
tion of two twelve byte strings?” Additionally, consider-
ing the length of a string alone can be quite misleading.
While the string “HTTP/1.1\r\n” is longer than the string
“\xBF\xFF\xFE”, it is still much more likely to appear in
innocuous requests on port 80.
To calculate the probability that pattern string P occurs
in some input text T , we construct a ﬁnite state machine that
takes T as input, and reaches the accept state if and when P
is found. In this machine, there is a state for each character
in P, plus the initial state. We denote the probability that the
machine is in state i after processing n characters as Pri(n).
Our goal, then, is to calculate Prl(P)(l(T )), where l(P) is
the length of the pattern P, and l(T ) is the length of the
text T . To calculate Prl(P)(l(T )), we iteratively compute the
probability of being in each state after processing each input
character. This calculation can be performed in O(l(P)
l(T ))time.
To calculate the probability that text matching an input
with a uniform-random byte distribution, we set the proba-
bility that a transition is taken equal to the number of char-
acters on its label, divided by the size of the alphabet.
We can use the same technique to estimate the proba-
bility that a string occurs in a network ﬂow of a particular
protocol. Instead of assuming that each character in the al-
phabet is equally likely, we can use traces of the protocol
to measure the relative frequency of each character. We
can use these measurements to estimate the probability of
each transition in the ﬁnite state machine. This model can
be further improved by measuring the relative frequency
of each character, given the current context. For example,
if the ﬂow consists of English text, and the last character
matched was “q”, it is very likely that the next character
will be “u”. Again, these statistics can easily be measured
from traces of a protocol. Compared to simply measuring
the frequency of the string in the trace, this technique of-
fers a more generalized view of the protocol. For exam-
ple, while the trace might not have any requests contain-
ing the exact string “www.obscuresite.com”, this technique
can calculate that it is more plausible than the equally long
string “dJesOuruhamjRhoEfvi”, since substrings including
“www.” and “.com” are common, it ﬁts the model for En-
glish words, etc.
[14] C. Kreibich and J. Crowcroft. Honeycomb - creating intru-
sion detection signatures using honeypots. In Proceedings of
the Second Workshop on Hot Topics in Networks (HotNets-
II), November 2003.
[15] C. Kreibich and J. Crowcroft. Honeycomb - creating intru-
sion detection signatures using honeypots. In Proceedings of
the Second Workshop on Hot Topics in Networks (HotNets-
II), November 2003.
[16] C. E. Lawrence, S. S. Altschul, M. S. Boguski, J. S. Liu, A. F.
Neuwald, and J. C. Wootton. Detecting subtle sequence sig-
nals: A gibbs sampling sequence strategy for multiple align-
ment. Science, 262:208–214, 1993.
[17] C. Nachanberg. Computer virus-antivirus coevolution. Com-
munications of The ACM, 1997.
[18] J. Newsome and D. Song. Dynamic taint analysis for auto-
matic detection, analysis, and signature generation of exploits
on commodity software. In Proceedings of the 12th Annual
Network and Distributed System Security Symposium (NDSS
05), Feb. 2005.
[19] A. Pasupulati, J. Coit, K. Levitt, and F. Wu. Buttercup: On
network-based detection of polymorphic buffer overﬂow vul-
nerabilities. In IEEE/IFIP Network Operation and Manage-
ment Symposium, May 2004.
[20] V. Paxson. Bro: a system for detecting network intruders in
real-time. Computer Networks, 31(23-24), December 1999.
[21] T. S. Project. Snort, the open-source network intrusion de-
tection system. http://www.snort.org/.
[22] S. Singh, C. Estan, G. Varghese, and S. Savage. Automated
worm ﬁngerprinting. In Proceedings of the 6th ACM/USENIX
Symposium on Operating System Design and Implementation
(OSDI), Dec. 2004.
[23] T. Smith and M. Waterman. Identiﬁcation of common molec-
ular subsequences. Journal of Molecular Biology, 147:195–
197, 1981.
[24] P. Szor. Hunting for metamorphic.
In Proceedings of the
Virus Bulletin Conference, 2001.
[25] G. Vigna, W. Robertson, and D. Balzarotti. Testing Network-
based Intrusion Detection Signatures Using Mutant Exploits.
In Proceedings of the ACM Conference on Computer and
Communication Security (ACM CCS), Washington, DC, Oc-
tober 2004.
[26] H. Wang, C. Guo, D. Simon, and A. Zugenmaier. Shield:
Vulnerability-driven network ﬁlters for preventing known
vulnerability exploits. In Proceedings of ACM SIGCOMM,
Portland, OR, Aug. 2004.
[27] E. P. Xing and R. M. Karp. Motifprototyper: a proﬁle
bayesian model for motif family. In Proceedings of National
Academy of Sciences, volume 101, 2004.
[28] E. P. Xing, W. Wu, M. Jordan, and R. Karp. Logos: A mod-
ular bayesian model for de novo motif detection. Journal
of Bioinformatics and Computational Biology, 2(1):127–154,
2004.
A. Token Distinguishability
We ﬁnd that it is useful to estimate how likely a token
is to appear in innocuous network trafﬁc. This information
can be used as a relative measure of how distinguishing one
token is compared to another. That is, given two tokens that
appear in worm samples equally as often, the one that ap-
pears in innocuous trafﬁc less often is more distinguishing
than the other. Such information can also be used to help
estimate the false positive rate of a signature.
One often-used heuristic is that, in general, longer strings
are more useful in a signature than short strings.
In par-
ticular, one automatic signature generation algorithm is
Proceedings of the 2005 IEEE Symposium on Security and Privacy (S&P’05) 
1081-6011/05 $ 20.00 IEEE