### 主要内容
大家好。 我是`Mat`，我是一名`fuzzing`的爱好者。
对于`fuzzing`，我渴望新版本的更新与漏洞的修补。我时刻期待着模糊工具使用者的详细报告。
Dharma是由Mozilla提供的基于迭代器的语法模糊器。 它允许用户定义一个被称为语法文件的模板。 但是如何用这个来进行下一步的操作呢？我们看下面。
为了实现这一目标，我们首先需要来看上一步操作。 在过去的几个月里，我的很多工作研究都集中在`Foxit Software`上。
在2018年，Foxit通过ZDI计划获得了发布公告的头条位置。
这不仅能帮助供应商加强应用程序的安全，而且能够帮助我们实时了解研究人员最近的有趣的技术发现。
让我们来看看`ZDI-18-1157`的概念。这是在`Foxit
Reader`在使用文档对象的`createIcon()`方法后紧接着使用，这种方法是由趋势科技研究员`Kamlapati Choubey`发现。
上述代码定义了数组`arg1`。之后，它为数组的第一个部分定义了一个`getter`，其带有一个执行`app.activeDoc [0]
.closeDoc()`的回调函数。值得注意的是`app.activeDoc [0]
.closeDoc()`会强制释放Doc对象。最后，系统调用`createIcon`，并将`arg1`作为第一个参数传递。`createIcon`函数遍历`arg1`，一旦它遍历arg1的元素，就会触发`getter`。
如果在上述过程中产生了系统崩溃，那么我们便可以看到`ECX`指向的一个被释放的堆对象被移动到`EAX`中，并立即在一个可执行远程代码中调用。
那么，使用这种概念验证，Dharma如何帮助我使用这种逻辑找到额外的错误？
首先，我们需要从语法文件开始。`Dharma`将用于生成`JavaScript`内容的“模板”。 我们来看一个基本模板：
基本模板由三个部分构成：值，变量和方差。 值部分用来构造我们将要模糊的逻辑格式。 如果需要利用动态变量，此处就是我们定义这些变量的地方。
最后，方差部分充当值的构建器，并且我们还将额外添加新的逻辑用以进行排列。对于这个例子，我们将主要关注其最有价值的部分。
让我们来看看Dharma的命令行参数。
看起来十分简洁。为了简单起见，我们将使用-`grammars`参数调用`Dhama`，它应该返回给我们以下信息：
我们通过定义`Dharma`用来打印“`hello`”，然后使用在 stuff中定义的值之一来填充空白。
现在，让我们开始构建吧。
作为基准，我将使用Adobe，并利用`Adobe Acrobat API
Reference`来帮助生成`Document`对象的`addField()`模板。选用此模板是因为这样非常简便。从利用这种方法进入程序时的提交数量来看，它足够灵活，对开始使用Dharma的我们来说这是一个很好的选择。为了读者阅读方便，我们今天的例子都十分简便易懂，但却能突出`Dharma`的闪光点。
根据API文档，`addField()`能接受四个参数并返回一个`Field`对象。
    var foo = this.addField（cName，cFieldType，nPageNum，oCoords）
以下是Adobe文档中对这些参数的描述。
基于此，我们用`Dharma`构建了一个粗略的代码。
将此文件传递给Dharma将产生下面的结果：
接下来，我们只添加几个属性并将它们包含在`try/catch`块中。这可以解决我们生成的JavaScript问题，并能在发生错误时继续处理文档。然后，我们创建一个构建器，它将在所需的参数中调用`addField()`并尝试在返回的Field对象上设置属性。
将此扩展文件传递给Dharma将产生以下结果：
最后，我们需要将应用设计为免费。所以我们将修改应用的定义，如下所示：
同样重要的是，我们需要将自由变量指定为模板中的值。
将新的语法文件传递给Dharma后为我们提供了如下输出：
现在我们有了一个可用的语法文件。这个文件可以通过`Dharma`根据我们期望的内容生成JavaScript进行测试。接下来，我们将这些`JavaScript`文件嵌入到`PDF`中，最终将其输入`Foxit
Reader`。有几种工具可以帮助我们自动完成以上步骤， 就个人而言，我偏向于使用`Didier Stevens`的PDF工具。
测试工具加载完成后，让我们开始测试。
在几秒钟内，我们就会遇到第一次冲突。 一旦我们最小化POC，我们最终会得到以下信息：
[ZDI-18-1198](https://www.zerodayinitiative.com/advisories/ZDI-18-1198/)
浏览冲突内容，我们可以看到EBX引用了放入EAX的释放堆对象，然后EAX立即用于执行调用指令。
### 结论
Dharma是一个功能强大的基于语法的迭代模糊器。使用类似技术的不同模板可以帮助我们避免更多的bug，并将它们报告给Foxit，如`ZDI-18-1183`，`ZDI-18-1162`和`ZDI-18-1208`。
为了便于阅读，本示例中使用的语法文件只显示了部分内容，但其主体是相同的。 有了这样的工具，接下来你有什么看法？ 如果你有任何好的建议，请务必将其提交给我们！
    本文为翻译稿件，稿件来源为：https://www.zerodayinitiative.com/blog/2019/1/31/implementing-fuzz-logics-with-dharma