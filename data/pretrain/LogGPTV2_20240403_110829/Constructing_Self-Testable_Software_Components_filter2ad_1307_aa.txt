title:Constructing Self-Testable Software Components
author:Eliane Martins and
Cristina Maria Toyota and
Rosileny Lie Yanagawa
Constructing Self-Testable Software Components 
Eliane Martins 
PI:EMAIL 
Cristina Maria Toyota 
PI:EMAIL 
Rosileny Lie Yanagawa 
PI:EMAIL 
State  University of Campinas (Unicainp) 
Institute of Computing (IC) 
Campinas - SP - Brazil 
during  development  or  maintenance,  and  by  their  consumers, 
every time they are reused. For that  reason, testing  should not  be 
the  cause  of  a  reduction  in  productivity  in  component-based 
development. The use of testable components is one of the means 
to efficiently achieve a well-tested  software, yet  guaranteeing the 
high reliability required. 
Software  testability  encompasses  all  aspects 
that  eases 
software  testing,  from  the  quality  of  its  specification,  design, 
code,  and  tests,  to  the  availability  of  test  support.  Design  for 
testability  techniques  have  long  been  using  to  improve  the 
testability  of  hardware  components.  These  techniques,  used  in 
conjunction  with  the  self-testing  concept,  have  lead  to  built-in 
self-testing  (or  BIST)  hardware  components,  which  embed  test 
pattern generation  capabilities. 
In  this paper  we present  an approach for the construction  and 
use  of  self-testable  components.  A  self-testable  component 
contains, in  addition  to its  implementation,  a  specification  from 
which  test  cases can be  derived.  Our concern  in  this  study  was 
00 components that  are a  unique class.  A  prototyping  tool  was 
developed to support some activities  of the  proposed  approach  to 
show  its  feasibility.  This  prototyping  tool,  named  Concat  [33], 
supports  the  construction  and  use  of  self-testable  components 
implemented with the Ci+ language. 
The text  is organized  as  follows: next  section  presents  some 
basic  concepts  which  are  used  in  the  remainder  of  the  text. 
Section  3  describes  the  proposed  approach.  Section  4  presents 
preliminary  results  obtained  with the empirical evaluation  carried 
out to assess the effectiveness of the test selection technique used. 
Section 5 compares our approach to some related  work. Section 6 
concludes the text, presenting  also some future work. 
2.  Background 
In  this  section  we  present  an  overview  of  the  concepts  and 
terminology  used throughout  this paper. The section ends with a 
Abstract 
Component-based  sofware  engineering 
techniques  are 
gaining substantial interest because  of  their potential  to improve 
productiviy  and  lower  development  costs  of  new  software 
applications, yet  satisJying high  reliabiliy  requirements. A first 
step  IO  address  such  high  reliabilig  requirements  consists  in 
reusing  reliable components. To merit the attribute  “reliable”, A 
component  should  be  extensively  validated.  As far as  testing  is 
the technique most commonly used for validation, this means  that 
reusable components should  well  tested. For tests  I O  be  applied 
efficiently  and  on  time,  A  component  should  be  testable.  This 
paper presents an approach to improve component  testabilily by 
integrating  testing  resources  into it,  and hence  obtaining n  self- 
testable component. A prototyping tool, Concat, WAS developed to 
support  the  proposed  approach.  The  tool  is  intended for  00 
components implemented in C i  i. Sotne preliminaty results of an 
empirical  evaluation  of  the fault  detection  effectiveness  of the 
proposed testing approach are also discussed. 
Keywords: component  testability  - design  for  testability  - 
self-testable  component - 00 testing 
1.  Introduction 
Software  components  are  gaining  substantial  interest  in  the 
development  of  new  applications.  The  main  motivation  is  the 
possibility 
to  reduce  development  time  and  cost  by  using 
components developed  by  third-parties  or  even  available in  the 
commercial market  (the so called Commercial-Off-The-Shelf  or 
COTS components). A  first  step for a successful reuse  is to use 
reliable  components. To guarantee such quality,  among others, a 
component should  undergo extensive validation.  This means that 
components  should  be  well  tested,  as  far  as  testing  is  the 
technique most commonly used for validation. 
As  pointed  out  by  different  authors  [9,  411,  a  reusable 
component  should  be  tested  many  times:  by  their  producers, 
0-7695-1101-5/01 $10.00 0 2001 IEEE 
151 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:02:37 UTC from IEEE Xplore.  Restrictions apply. 
brief description of a self-testable component. 
2.1.  Components 
in 
and 
There  are  different  definitions  for  components 
the 
literature.  We will  consider  here  the  one from  C.  Szyperski  [32, 
ch4. I SI:  “A sofware  component  is a  unit  of  composition  with 
contractimlly 
context 
dependencies  only.  A  software  component  can  be  deployed 
independently and is subject to composition by third parties ”. 
intei$aces 
specfled 
explicit 
A  component  is  then  a  reusable  software  artifact.  In  00 
context,  which  is  our  concern  here,  the  basic reusable  unit  is  a 
class.  A  class  can  be  reused  in  different  ways  [6,  cll.I]:  by 
inheritance 
the  case  with  abstract  classes),  by 
parameterization  (as is the case with  generic or template  classes) 
or by composition  (an attribute is declared as a class). 
Whatever  the  reuse  mechanism,  adequate  testing from  both 
producer  and  consumer  is  required  for  reuse  to  be  successful. 
Testing aspects are described next. 
(as 
is 
2.2.  Software testing objectives and activities 
Software testing is the execution of a code in the presence of 
preselected inputs with the goal to reveal faults [27].  A software 
fault  (or  bug)  is  introduced  into  the  software  due  to  errors 
committed  by  developers  during  the  development  process.  The 
execution  of  a  faulty  software  may  lead  to  the  occurrence  of 
failures, in  which  case the delivered  services no longer  complies 
with  the  specification.  When  performing  testing  the  following 
issues should be considered: 
in 
tested 
The testing level: software systems should go through  at 
least three testing level [4,41]: (i) unit testing, in which 
individual  components  are 
isolation;  (ii) 
integration testing, in  which  the subsystems  formed  by 
integrating the individually tested components  are tested 
as  an  entity;  and  (iii)  system  testing,  in  which  the 
system composed by already tested  subsystems  is tested 
as a whole.  Our focus is the unit testing of components, 
as this is  a first  step a  user  should made before  using  a 
component in an application. 
The test  criteria:  test  input  selection  is generally guided 
by  criteria  [40] derived  from  an  abstract representation 
of the software (test model). They define the elements of 
the test  model that should  be covered  by  the  tests. Most 
commonly  used 
the 
implementation  or  the  specification  of  the  software 
system.  When 
an 
implementation-based  (or 
implementation,  we  have 
white-box)  testing  techniques.  A  criterion  in  this  case 
might be: cover all nodes of  a control  flow graph. When 
a 
represents  a  specification,  we  have 
specification-based  (or black-box)  testing techniques;  a 
criterion  in  this case  might  be:  all  transitions  coverage 
on  a  finite  state machine,  in  case  this  is  used  as  a  test 
model.  In  this study we  used  specification-based testing 
since our purpose is to allow a component’s consumer to 
its 
test  whether 
required  features.  The  test  model  used  as well  as  the 
criterion  for test generation are given in section 3.2. 
Test case  design:  a  test  case consists of  test  inputs and 
the  expected  outputs.  Test  inputs  may  be  obtained 
the  component  addresses  each  of 
represent  either 
test  model 
test  models 
test  model 
represents 
a 
according  to  the  testing  criteria  presented  above.  The 
mechanism 
to  produce  the  expected  outputs  is  the 
oracle.  Various  approach  exist  for  oracle  development 
(see  [6, c18] for a  g o d  survey  on  this  subject). In  this 
study  the  oracle is based  on  the  component’s  contract. 
Contracts establish what the consumer should do to use a 
component,  and  what  the  producer  should  implement to 
provide  the  services required  [31,  c5.1.31.  The  design- 
by-contract  method  [25,  261  is  commonly  used 
to 
specify  contracts  in  the  form  of  assertions,  or  logical 
conditions.  For  00  components,  assertions  can  be 
associated  to  methods  (pre and  post  conditions) as well 
as to a class (class invariant).  Assertions are used in  this 
study as a  partial  oracle,  as will  be  presented  in  section 
3.3. 
The  test  support: it  may  be  necessary  to define support 
for  test  execution.  Among  other  things,  this  support 
comprises  test  drivers  and  test  stubs.  A  test  driver  (or 
simply  driver)  activates  the  component  under  test, 
providing 
inputs  and  other 
information  necessary  for its proper  functioning. A stub 
is a  partial,  temporary  implementation  of  a  component 
whose  services  are  used  by  the  component  under  test. 
The  use  of  a  formal  specification  model  may  be  useful 
for  the  automatic  construction  of  drivers  and  stubs.  In 
this study we  use  the  component  specification to derive 
test drivers, as is explained in 3.4. 
the  necessary 
it  with 
Testability  is  relative  to  the  ease  with  which  the  activities 
mentioned  above are executed,  and is an important  quality factor 
since  a  component  should  be  tested  many  times.  These  aspects 
are presented next. 
2.3.  Components testability 
According to IEEE std. 610.12 [23], testability can be defined 
as: “(i)  ttie degree to which a system or component facilitates ttie 
establishment  of  test  criteria  and  the  performance  of  tests  to 
determine whether those criteria have been met. (ii) the degree io 
which a requirement is stated  in ternis that permit establishment 
of test criteria and the performance of rests to determine whether 
those criteria have been met”. This definition is more concerned 
with the ease to establish test criteria and to have them  met,  so it 
can  be  viewed  as  a  measure  of  how  hard  it  is  to  satisfy  a 
particular testing criterion. 
Another  definition of  testability  states it in  terms of  the easy 
with which  faults are revealed during testing,  that  is, the capacity 
of a system to fail during testing, indicating the presence  of faults 
[36]. So testability is viewed as a measure of the likelihood  that a 
system hides faults during testing. 
As  pointed out by different authors  [8, 18,  19, 281, a testable 
software  might  possess  a  set  of  attributes,  among 
them, 
observability,  controllability  and  understandability.  Roughly 
speaking,  the  more  we  can  observe  the  states and  outputs  of  a 
component, the  more  we  can  control  it  during  testing;  and  the 
more  information  we have about a component,  more easy it is to 
effectively testing it. 
From the above  it can be concluded  that  embedding  inside a 
component  its  specification  and  other  facilities  allowing  its 
monitoring  and  testing,  is  a  way  to  improve  components 
testability.  This  is  especially  true  for  00  software,  whose 
intrinsic  characteristics  such  as encapsulation  and  information 
152 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:02:37 UTC from IEEE Xplore.  Restrictions apply. 
hiding  reduce  both  observability  and  controllability.  That  is  the 
reason  why  some  studies  proposed  the  use  of  built-in  test 
capabilities to obtain a self-testable component.  This is explained 
in the item that follows. 
2.4.  Self-testable components 
testing, 
thereby 
Design  for testability  (DFT) techniques  have  been  using  for 
integrated circuit (IC) engineers  to reduce test cost and effort  yet 
achieving the required quality  level. With  D F I  techniques,  extra 
pins  are added to an  IC  to allow access  to intemal  circuit  points 