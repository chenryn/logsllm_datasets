even into forms containing only input ﬁelds without
any name. In terms of adhering to the autocomplete
attribute, Internet Explorer did respect the value by
not saving any information if either ﬁeld had the au-
tocomplete value set to oﬀ.
• Maxthon Cloud Browser: Not unlike the insecure be-
haviour it showed regarding matching the URL, the
Maxthon Cloud Browser was not at all strict in match-
ing the form, even ﬁlling in input ﬁelds that had no
name and – most notably – that had autocomplete set
to oﬀ.
188To sum up: Most browsers are very relaxed in terms of
matching criteria. All but Internet Explorer would still ﬁll
in passwords if only the origins matched, whereas the Max-
thon Cloud Browser even only took the second-level domain
into consideration for its decision. Similar to that, matching
against a form was mostly performed on a structural level,
i.e. meaning that any two ﬁelds were ﬁlled out if the lat-
ter was a password. According to Mozilla[6], this is done
by design as a convenience feature. Looking at the results,
the tests with diﬀerent forms showed that the attacker only
has to create a minimal form as shown in Listing 1 to trick
the browser’s password managers into providing the stored
passwords from any site that uses two input ﬁelds for its
login dialogue.
All the previously discussed results are depicted in Ta-
ble 1, whereas ’Yes’ denotes that the criterion must match.
For the minimal form, ’Yes’ denotes that the minimal form
was suﬃcient, whereas ’Yes’ for autocomplete means that
the browsers would not save passwords if the autocomplete
attribute was set to oﬀ.
Listing 1: Minimal HTML form used in our tests
5.2 Password ﬁelds
To obtain a realistic picture on how password ﬁelds are
currently used in practice and to which degree real-world
password dialogs are susceptible to the attacks discussed in
Section 3, we conducted a survey on the password ﬁelds of
the top ranked Web sites according to the Alexa index [1].
5.2.1 Methodology
To locate and analyze password ﬁelds in real-world Web
sites, we conducted a lightweight crawl of the top 4000 Alexa
sites. As many modern sites rely on client-side markup cre-
ation and DOM manipulation via JavaScript, we chose a
full ﬂedged browser engine as the technical foundation of
our crawling infrastructure: We implemented an extension
for the Chrome browser, that pulls starting URLs from a
backend component, which are subsequently visited by the
browser. This way, we not only can examine the same ﬁ-
nal DOM structure that is also presented to the browser, it
also gives us the opportunity to observe client-side actions
after a password has been entered (more on this below).
Our Chrome extension consists of the following JavaScript
components [10]:
• A single background script, which is able to monitor
network traﬃc and distribute the crawling process over
multiple browser tabs,
• and multiple content script instances, one for each Web
document that is rendered by the browser. A content
script is instantiated as soon as a new document is
created by the browser engine. This script has direct
access to this document’s DOM tree. However, the
script’s execution context is strictly isolated from the
scripts running in the document.
• Thus, the content script injects a user script directly
into the documents’ DOM. Unlike the content script,
Criteria
Password found
PW on HTTPS page
Secure action1
Autocomplete oﬀ
X-Frame-Options
JavaScript access
# Sites % rel. % abs.
100 % 53,6 %
38,31 % 20,5 %
55,9 % 29,9 %
7,3 %
13,6 %
4,7 %
8,9 %
15,1 %
8,1 %
2143
821
1197
293
189
325
1: Password form submitted to an HTTPS URL
Table 2: Recorded characteristics of the Alex Top
4K password ﬁelds
which is cleanly separated from the document’s script
environment, the user script runs directly in the same
global context as the document’s own script content.
This in turn grants us the ability to wrap and intercept
native JavaScript functions [17], such as XMLHttpRe-
quest or getter/setter properties of HTML objects.
Using this infrastructure, our extension conducted the fol-
lowing steps:
The homepage URL of the next examination candidate is
pulled from the backend and loaded into one of the browsers
tabs. After the rendering process has terminated, the DOM
tree is traversed to ﬁnd password ﬁelds. However, most sites
do not immediately contain the login dialog (if they have one
at all) on their homepages. Instead, it is usually contained
in a dedicated subpage, linked from the homepage. Hence,
in case no password ﬁeld could be found on the homepage,
all hyperlinks on this page are examined, if they contain
indicators that the linked subpage leads to the site’s login
functionality. This is done via a list of indicative keywords,
consisting of e.g., “sign in”, “login”, or “logon”. If such a link
was found, the browser tab is directed to the correspond-
ing URL and this document is examined for password ﬁelds.
While this methodology is apparently incomplete, e.g., due
to the keyword list only containing terms derived from the
English language, turned out to be suﬃcient to ﬁnd a rep-
resentative number of password ﬁelds (see Sec. 5.2).
If a password ﬁeld was found, important characteristics
of the document were recorded, including the hosting doc-
ument’s URL, the corresponding HTML form’s action at-
tribute, as well as the presence of autocomplete attributes
and X-Frame-Option headers.
Furthermore, to observe potential client-side processing
after a password has been entered, we instrumented the
get-property of the password ﬁeld using JavaScript’s Ob-
ject.defineProperty API [22], after the page’s rendering
process has terminated, but before the page’s own scripts
executed.
Subsequently, after the page’s scripts have been run, the
user script simulates user interaction with the password ﬁeld
to potentially activate JavaScripts that access the password
value legitimately. More precisely, our script triggers Java-
Script events, that would occur if a user clicks into the ﬁeld,
changes its values, and leaves the password ﬁeld, i.e., moves
the focus to a diﬀerent ﬁeld. Finally, the script submits the
form, in order to activate any JavaScript that is tied to the
onsubmit event.
5.2.2 Results
During our crawl, we could successfully detect a login form
In the following, we will
on 2,143 of the 4,000 domains.
189Port Path
Chrome 31
Yes
Internet Expl. 11 Yes
Firefox 25
Yes
Yes
Opera 18
Yes
Safari 7
Maxthon 3
No
No
Yes
No
No
No
No
sub domain
Yes
Yes
Yes
Yes
Yes
No
any name req.
Yes
No
No
Yes
Yes
No
name match
No
No
No
No
No
No
input type match min form autocomp.
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
No
Yes
Yes
No
Yes
No
Table 1: Overview of tested browsers and their matching criteria
outline the analysis of the data we gathered from these ﬁelds
with respect to diﬀerent, security-relevant questions.
As discussed in Section 4.1, the use of the autocomplete
attribute on input ﬁelds allows an application to ensure that
no data is persisted into the password manager’s storage.
We therefore investigated how often this was explicitly set
to off, essentially instructing the browser to neither store
login data nor auto-ﬁlling these forms. Out of the 2,143
domains we examined, a total of 293 domains prohibited
password managers from storing the credentials this way.
In respect to the ClickJacking attack on a password man-
ager that requires user interaction (see Sec 3.3), the appli-
cable remedy is the usage of the HTTP’s X-Frame-Options
response header [26]. By using this header an application
can explicitly tell the browser that a page may not be ren-
dered inside a frame. However, this only helps against the
discussed attacks if the header is set to DENY, since we must
assume that the XSS attacker is capable of positioning an
iframe containing the login form on a page located in the
same application, thus running under the same origin. In our
investigation, we found that only 189 domains set the header
to DENY, while another 173 had set it to the SAMEORIGIN,
which is useless in the context of the discussed attacks.
Furthermore, to gain insight on the extent of legitimate
client-side functionality that uses JavaScript to read pass-
word ﬁelds, we instrumented the password ﬁeld, such that
we were able to record read access (see above). For a total of
325 password ﬁelds, we were able to witness read operations
via JavaScript.
Finally, we examined to which degree the sites were poten-
tially susceptible to network attackers. To do so, we checked
how many forms containing password ﬁelds are delivered via
plain HTTP rather than HTTPS. In the attacks scenario de-
scribed by Gonzalez et al. [9], enabling HTTPS eﬀectively
blocks their attacker.
In our study, we found that only
821 domains utilize HTTPS when transmitting the pass-
word ﬁeld itself. The remaining 1,289 domains are hence
susceptible to the network-based attacker who directly in-
serts JavaScript into the server’s response to retrieve the
password data from the victim.
Additionally, a network-based attacker may also retrieve
passwords from users once they log in to an application if
the credentials are sent to the server using HTTP and not
HTTPS. Investigating how many applications send out se-
cret login data in an unencrypted manner, we found that in
total, 1197 sites used HTTPS to send the password data to
the server, leaving 946 sites with unencrypted communica-
tion.
5.3 Assessment
As shown in Section 5.1, most browsers only store the
origin of a password and not the complete URL of the form
it was initially stored from. Thus, placing a form on an
arbitrary page with the same origin as the login form is
suﬃcient to extract credentials from the victim.
The Cross-Site Scripting attacker, which we discussed in
the previous sections, is capable of injecting his malicious
payload into applications that are delivered via HTTP as
well as over HTTPS. Thus, the only line of defense in this
case is the autocomplete feature. As discussed earlier, this
is only used in 293 login pages, thus resulting in a total
number of 1,850 out of 2,143 domains which are potentially
vulnerable to password stealing by an XSS attacker. This
amounts to a total of 86.3% of analyzed pages which are
susceptible to the attack scenario we outlined. Apart from
Microsoft’s Internet Explorer, the built-in password man-
agers of all browsers we examined automatically ﬁlled out
forms presented to them and would also behave in the same
manner if the login page was put into a frame. In order to
successfully conduct an attack on Internet Explorer, the at-
tacker would have to have found a vulnerability on the exact
login page and would also have to rely on the victim actively
selecting the credentials to insert.
The network-based attacker, who is only capable of in-
jecting his malicious payload into login pages which are not
served using HTTPS, can only successfully attack 1,029 dif-
ferent domains, summing up to 48% of all applications we
analyzed.
These observations lead us to the conclusion that the
current implementation of browsers’ password managers is
highly vulnerable with respect to password stealing – both
by a network and a XSS attacker. Also, the server-side mea-
sures we discussed in Section 4.1 are not employed in prevail-
ing web applications in a satisfactory manner. Therefore, in
the following section, we will discuss a new approach to the
concept and implementation of a password manager capable
of tackling these issues.
6. CLIENT-SIDE PROTECTION
Our analysis has shown that popular browsers implement
password managers in a way that is susceptible to Cross-
Site Scripting attacks. We have shown that most of the
browsers neither save information on the URL the password
was initially stored for nor do they require user interaction to
ﬁll out forms. This allows the attacker to retrieve passwords
in the presence of an XSS vulnerability.
In the following,
we propose a simple yet eﬀective solution to counter these
types of attacks on password managers.
6.1 Concept
The common enabling factor of the documented attack
types (see Sec. 3) is the fact that the secret data is directly
inserted into the forms when the page is loaded, and can
subsequently be retrieved by JavaScript.
The underlying problem is that concept and implemen-
tation of password managers are not aligned. Abstracting
190what a password manager’s task is, we see that it should aid
users in the login process to Web applications. This process
can be seen as the credentials being sent to the login page.
The implementation of that paradigm however aims at ﬁlling
out forms before the actual, clear-text login data is required.
A XSS attacker aims speciﬁcally at this conceptual ﬂaw, ex-
tracting the credentials from the auto-ﬁlled form.
In our
notion, a password manager should ensure that only once
the login data is sent to the server, the plain-text password
is contained in the request. Hence, in the following, the
propose an enhanced password manager which tackles this
conceptual ﬂaw.
Our proposal is that a password manager should only in-
sert placeholding nonces into a form. Once the user then
submits the form towards the application, the password man-
ager replaces the nonce with the original, clear-text pass-
word. Thus, if an attacker can extract the content of this
form utilizing a XSS vulnerability, he is nevertheless unable
to retrieve the real password of the targeted user.
Furthermore, our mechanism requires strict matching of
the password ﬁeld name attribute and the corresponding
POST value. For better understanding of the rationale be-
hind this, consider the following scenario: The attacker is