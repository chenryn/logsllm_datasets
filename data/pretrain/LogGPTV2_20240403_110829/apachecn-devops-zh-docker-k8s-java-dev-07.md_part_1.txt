# 七、Kubernetes 简介
在阅读了[第 6 章](06.html)、*用 Java 应用运行容器*之后，您现在已经对使用 Docker 打包您的 Java 应用有了很多了解。现在是时候更进一步，专注于我们缺少的东西——容器管理和编排。市场上有一些合适的工具，例如 Nomad、Docker Swarm、Apache Mesos 或 AZK。在这一章中，我们将集中讨论可能最受欢迎的一个，Kubernetes。Kubernetes(有时也称为 k8s)是一个面向 Docker 容器的开源编排系统，由 Google 在 2015 年创建。谷歌开发的第一个统一容器管理系统是内部称为博格的系统；库本内斯是它的后代。本章涵盖的主题列表为:
*   为什么以及什么时候我们需要容器管理
*   《Kubernetes 的概论》
*   基本立方结构概念
让我们从回答这个问题开始，为什么我们甚至需要 Kubernetes？我们将研究容器管理和编排背后的原因。
# 为什么我们需要 Kubernetes？
正如您已经知道的，Docker 容器为运行打包成小型独立软件的 Java 服务提供了极大的灵活性。Docker 容器使应用的组件可移植——您可以跨不同的环境移动单个服务，而无需担心依赖关系或底层操作系统。只要操作系统能够运行 Docker 引擎，您的 Java 容器就可以在这个系统上运行。
此外，正如您从[第 1 章](01.html)*对 Docker* 的介绍中所记得的，Docker 隔离容器的概念与传统的虚拟化相去甚远。不同之处在于 Docker 容器利用了主机操作系统的资源——它们轻便、快速且易于启动。一切都很好，但也有一些风险。您的应用由多个独立的微服务组成。服务的数量可能会随着时间的推移而增长。此外，如果您的应用开始经历更高的负载，增加具有相同服务的容器的数量会很好，只是为了分配负载。这并不意味着你只需要使用你自己的服务器基础设施——你的容器可以上云。今天我们有很多云提供商，比如谷歌或亚马逊。通过有可能在云中运行您的容器，它给了您很多优势。首先，您不需要管理自己的服务器。其次，在大多数云中，您只为真正的使用付费。如果负载达到峰值，云服务的成本当然会增加，因为您将使用更多的计算能力。但是如果没有负荷，你就什么都不会付出。这说起来容易，但是监控您的服务器使用情况，尤其是在一个或多个应用运行大量组件的情况下，可能会很棘手。你需要仔细查看云公司的账单，确保你没有一个容器坐在云上旋转而无所事事。如果特定服务对您的应用不那么重要，并且不需要快速响应，您可以将其转移到最便宜的机器上。另一方面，如果另一个服务经历了更高的负载并且很关键，您将希望将其移动到一个更强大的机器上，或者启动更多的实例。最重要的是，通过使用 Kubernetes，它可以实现自动化。通过拥有管理 Docker 容器的正确工具，这可以在运行中完成。您的应用可以以非常敏捷的方式自我调整——最终用户可能甚至不知道他们正在使用的应用驻留在哪里。容器管理和监控软件可以通过更好地利用您支付的硬件来大大降低硬件成本。Kubernetes 处理计算集群中节点的调度，并主动管理工作负载，以确保它们的状态与用户声明的意图相匹配。使用标签和 Pods 的概念(我们将在本章后面介绍)，Kubernetes 将组成应用的容器分组到逻辑单元中，以便于管理和发现。
让您的应用以一组容器的形式在托管环境中运行也改变了软件开发的视角。您可以开发一个新版本的服务，当它准备好的时候，您可以动态地进行滚动更新。这也意味着将重点放在应用运行的机器上，因此，允许开发团队以更灵活、更小和模块化的方式进行操作。它允许软件开发真正敏捷，这是我们一直想要的。微服务规模小且独立，构建和部署时间大大缩短。此外，发布的风险更小，因此您可以更频繁地发布更小的更改，最大限度地降低了一次发布所有内容可能发生的巨大失败的可能性。
在开始介绍基本的 Kubernetes 概念之前，让我们总结一下 Kubernetes 给我们的列表:
*   快速、可预测地部署应用
*   动态缩放
*   无缝发布新功能
*   防故障
*   将硬件使用仅限于所需的资源
*   敏捷应用开发
*   操作系统、主机和云提供商之间的可移植性
这是一个不能轻易击败的特征列表。为了理解这是如何实现的，我们需要理解 Kubernetes 的核心概念。到目前为止，我们只知道一个来自 Docker 的概念——容器——它是一个可移植的、独立的软件单元。容器可以包含我们想要的任何东西，无论是数据库还是 Java REST 微服务。让我们了解剩下的部分。
# 基本立方结构概念
集群是一组节点；它们可以是安装了 Kubernetes 平台的物理服务器或虚拟机。下图显示了基本的 Kubernetes 体系结构:
![](img/5d7e68f1-5a68-42f5-96aa-c4c6957793a4.png)
如您所见，Kubernetes 集群由一个主节点和多个工作节点组成，其中包含一些组件。虽然乍一看它可能看起来很可怕和复杂，但如果我们从 Pod 开始逐一描述概念，就会更容易理解。
# 分离舱
Pod 由一个或多个 Docker 容器组成。这是 Kubernetes 平台的基本单元，也是 Kubernetes 工作的基本执行部分。吊舱的示意图如下所示:
![](img/fde2f3f8-461a-4eaa-b257-b8f121bc1c54.png)
在同一个 Pod 中运行的容器共享相同的公共网络命名空间、磁盘和安全上下文。事实上，建议在同一 Pod 上运行的容器之间通过 localhost 进行通信。每个容器还可以与集群中的任何其他 Pod 或服务进行通信。
正如您从[第 2 章](02.html)、*网络和持久存储*中所记得的，您可以在 Docker 容器中装载卷。Kubernetes 也支持卷的概念。连接到容器的卷可以安装在该容器上运行的一个或多个容器内。Kubernetes 支持许多不同的卷类型，作为挂载 GitHub 存储库、网络磁盘、本地硬盘等的本机支持。
如果您的应用需要分布式存储并且需要处理大量数据，那么您不仅仅局限于本地硬盘。Kubernetes 还支持批量提供商。目前，可用的持久卷提供程序列表包括:
*   **GCE** :哪个是谷歌云平台
*   **AWS** :亚马逊网络服务
*   **GlusterFS** :可扩展的网络文件系统。使用免费的开源软件 GlusterFS，您可以使用现有的存储硬件来创建大型分布式存储解决方案
*   **OpenStack child**:面向 OpenStack Nova 计算平台用户的块存储服务
*   **CephRBD** :一个**可靠的自主分布式对象存储** ( **RADOS** )，它在单个统一存储集群中为您的应用提供对象、数据块和文件系统存储
*   QuoByte
*   立方体-阿里云
网络命名空间和卷不是 Pod 的唯一属性。正如您在 Pod 的图表上看到的，Pod 可以附加标签和注释。标签在 Kubernetes 中非常重要。它们是附加到对象的键/值对，在本例中是附加到 Pods。标签背后的想法是，它们可以用来识别对象——标签对用户来说是有意义和相关的。标签的一个例子可以是:
```
app=my-rest-service 
layer=backend  
```
稍后，我们将使用标签选择器来选择具有指定标签的对象(如 Pods)。通过标签选择器(Kubernetes 中的核心分组原语)，客户端或用户可以识别一个对象或一组对象。选择器类似于标签，也是使用匹配标签标识资源的键值表达式。例如，选择器表达式`app = my-rest-service`将选择所有带有标签`app = my-rest-service`的豆荚。另一方面，注释是一种可以附加到 Pods 的元数据。它们不是用来识别属性的；它们是可以被库工具读取的属性。注释应该包含什么没有规则，这取决于你。注释可以包含诸如构建或发布版本、时间戳、Git 分支名称、Git `pull`请求号等信息，或者任何其他信息，如手机号码。
标签旨在识别有关 Kubernetes 对象(如 Pods)的信息。注释只是附加到对象的元数据。
我们之前说过，Pod 是 Kubernetes 中的一个基本执行单元。它可以包含多个容器。一个真实的例子是一个带有多个 Docker 容器的 Pod，它可以是我们的 Java REST 微服务 Pod。出于前面几章的示例目的，我们的微服务一直将其数据库数据存储在内存中。在现实生活中，数据可能应该进入真实的数据库。我们的 Pod 可能有一个包含 Java JRE 和 Spring Boot 应用本身的容器，以及第二个包含 PostgreSQL 数据库的容器，微服务使用该数据库来存储其数据。其中两个容器组成了一个 Pod——一个独立的、解耦的执行单元，包含我们的 REST 服务需要操作的所有内容。
Pod 的定义是一个名为`Pod`清单的 JSON 或 YAML 文件。看一个简单的例子，有一个容器:
```
apiVersion: v1
kind: Pod
metadata:
 name: rest_service
spec:
 containers:
 name: rest_service
 image: rest_service
 ports:
 - containerPort: 8080
```
JSON 文件中相同的`pod`清单看起来如下:
```
{
 "apiVersion": "v1", 
 "kind": "Pod",
 "metadata":{
 "name": ”rest_service”,
 "labels": {
 "name": "rest_service"
 }
 },
 "spec": {