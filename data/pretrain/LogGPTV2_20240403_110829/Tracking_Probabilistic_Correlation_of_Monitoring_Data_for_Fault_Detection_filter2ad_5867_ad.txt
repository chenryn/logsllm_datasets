ir t =  if  the  residual 
iR t 
<
F
F
                         (12) 
h
h
h
=
(
)
C
h
−
1
=
θ
( ))
θ
( ))
f F
(
v
f F
(
h
⋅
θ
( ) (
− +
1)
h
After  receiving  the  monitoring  data  for  h  of  such 
time  windows  (with  a  fixed  window  size),  we  can 
hC θ , with the following 
calculate a confidence score,
equation: 
∑
θ =
( )
v
1
C
h
Our automated model search and validation procedure 
starts  to  build  a  model  for  any  pair  of  measurements 
first and then incrementally validates these models with 
new data points. After a time period, if the confidence 
score  of  a  specific  relationship  is less  than a  selected 
threshold, the model for this relationship is considered 
to be invalid and we abandon this model. Meanwhile, 
we  continue  to  test  the  set  of  good  models  and  use 
these models as oracles in fault detection. Note that a 
robust  model  is  more  credible  in  fault  detection  than 
those  models  with  low  confidence  scores.  In  an 
operational  environment  like  Internet  services,  we 
always  have  endless  new  incoming  data  for  model 
sequential testing.   
8. Fault detection experiments 
Our  test  bed  system  has  typical  three-tier  system 
architecture as shown in Figure 1. The system includes 
Apache  web  server,  JBoss  application  server  and 
MySQL  database  server.  The  application  software 
running  on  the  system  is  Pet  Store  [13],  which  is  a 
blueprint J2EE application. Pet Store has 27 Enterprise 
Java Beans (EJBs), some Java Server Pages (JSPs) and 
Java Servlets.  
Just like other Internet services, users can go to the 
Pet Store website to buy various pets. A client emulator 
has  been  developed  to  generate  a  large  class  of 
different user scenarios and workload patterns. Various 
user actions  such  as  browsing  items,  searching  items, 
account  login,  adding  an  item  to  a  shopping-cart, 
payment and checkout are included in our workloads. 
Certain  randomness  of  user  behaviours 
is  also 
considered  in  the  workload.  The  time  between  two 
actions is randomly selected from a reasonable range. 
Note  that  workloads  are  dynamically  generated  with 
much randomness and variance so that we never get a 
similar  workload  twice  in  our  experiments.  The 
magnitude  of  workloads  is  between  0  and  100  user 
requests per second.  
As  discussed  before,  various  faults  could  affect 
complex information systems in very different ways. In 
this  section,  we  inject  a  list  of  faults  into  the  system 
and then use the collected monitoring data to compute 
residuals.  Further  we  check  whether  these  residuals 
become  abnormal  in  the  faulty  cases  to  verify  the 
feasibility  of  our approach.  Note  that  our  approach  is 
not specifically designed to detect these faults and here 
we just use these known faults for validation purpose.  
In  addition,  the  effectiveness  of  our  approach  is  also 
dependent  on  the  granularity  of  available  monitoring 
data. In our future work, we will need a large pool of 
injected faults to quantitatively verify the performance 
of  our  approach.  The  following  experiments  are  only 
designed  to  illustrate  the  feasibility  of  our  approach.  
For convenience, in the following experiments, we use 
R1, R2 and R3, respectively, to represent the following 
three data relationships: Java thread-CPU usage; SQL 
queries-Memory  usage;  Web  requests-Memory  usage. 
Here we assume that the clocks of different monitoring 
points are synchronized. 
A.  Busy Loop 
Infinite loop is a notorious software bug that could 
be  made  by  novices  as  well  as  experienced 
 (13)                            
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:26:44 UTC from IEEE Xplore.  Restrictions apply. 
programmers.  Typically,  unexpected  behaviour  of  a 
terminating condition can cause this problem. Here we 
use a general ``busy loop'' fault to simulate this type of 
faults.  The  process  injected  with  ``busy  loop''  faults 
will enter a busy loop procedure for a period of time. 
Figure 10 shows the residuals resulting from busy loop 
faults. In this experiment, we choose one specific user 
request to inject this failure by modifying source code. 
Whenever  this  specific  request  is  submitted,  it  will 
enter  a  busy  loop.  Figure  10  shows  that  all  three 
residuals  have  strong  evidence  of 
fault’s 
occurrence.  The  busy 
loop  fault  consumes  high 
percentage  of  CPU  power  so  that  it  blocks  the 
execution  of  other  user  requests  in  the  application 
server.  Therefore  the  memory  usage  is  not  well 
correlated with the number of HTTP and SQL requests 
after 
the 
relationships R2 and R3 are also affected.   
fault  occurs.  This  explains  why 
this 
the 
Figure 10.  Residuals in a busy loop fault 
B.  Memory Leaking 
Memory  leaking  is  a  common  software  bug  with 
which a program repeatedly allocates heap memory to 
an  object  but  never  releases  it.  The  accumulation  of 
leaked memory may eventually exhaust all the memory 
available. A program with memory leaking bug could 
run  correctly  for  a  long  period  of  time  before  it 
eventually causes something bad to happen. A memory 
leaking bug may not manifest itself in the same way all 
the  time.  Though  Java  supports  garbage  collection, 
memory  leaking  could  still  happen  because  allocated 
objects  which  are  no  longer  needed  can  remain 
reachable from useful and long-lived objects, and thus 
they are not garbage collected. Figure 11 illustrates the 
residuals of three relationships resulting from memory 
leaking  faults.  In  this  experiment,  we  injected  this 
failure  into  the  “ShoppingCart”  EJB  of  the  Pet  Store 
application  by 
repeatedly  allocating  some  heap 
memory and make it reachable from a long-lived object. 
Memory leaking eventually leads to heavy operation of 
JVM garbage collection.  
Essentially  this  abnormal  operation  affects  the 
probabilistic  correlation  characterized  in  those  three 
models. For example, many requests and processes are 
delayed to yield the garbage collection during the time 
of this operation. Therefore, all of three residuals show 
strong  signal  revealing  the  existence  of  a  fault. 
Compared  with  the  continuous  distorted  segments  of 
residuals  in  busy  loop  faults  shown  in  Figure  11, 
memory leaking faults only lead to discrete downward 
“spikes”  periodically.  This  is  because  the  heavy 
garbage  collection  operations  only  occur  once  in  a 
while. Each time  after an  operation is  completed,  the 
system goes back to the normal situation and therefore 
the downward spikes appear periodically. 
Figure 11.  Residuals in a memory leaking fault 
C.  Deadlock 
Deadlocks are a common problem in multi-threaded 
processing  where  several  processes  share  a  mutually 
exclusive  resource,  commonly  protected  by  a  lock.  A 
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:26:44 UTC from IEEE Xplore.  Restrictions apply. 
deadlock  could  cause  multiple  participating  processes 
to  enter  an  endless  waiting  loop.  Here  we  use  a 
“waiting  loop”  in  our  experiments  to  simulate  the 
impact  of  deadlock  problems.  Compared  to 
the 
experiment of “busy loop” faults, the only difference is 
that we changed the “busy loop logic” to the “waiting 
loop  logic”  in  the  related  source  code.  For  a  specific 
user request, it will enter a waiting loop that randomly 
lasts  from  4  to  12  seconds  with  no  operation  in  our 
experiment.  In  the  busy  loop  fault  case,  all  three 
residuals  become  abnormal  after  the  fault  occurs. 
Conversely, as shown in Figure 12, only R3 becomes 
abnormal in the deadlock case while R1 and R2 seem 
to be normal. This is because the “waiting loop” fault 
only  affects  the  total  number  of  the  injected  requests 
but has no impacts on other requests at all.  
Figure 12.  Residuals in deadlock faults 
9.  Discussions 
In  this  paper,  we  report  our  preliminary  results  of 
tracking  probabilistic  relationship  of  monitoring  data 
for  fault  detection  in  complex  systems.  Note  that  the 
above  experimental  results  only  demonstrate 
the 
feasibility of our approach though all experiments are 
repeated. In our future work, we need to design a wide 
class  of  fault 
injection  methods  and  run  many 
experiments to quantitatively verify the robustness and 
effectiveness of our approach such as false positive and 
negative rates in fault detection.                
Implementation 
References 
[1] M. Chen, A. Accardi, E. Kiciman, J. Lloyd, D. Patterson, 
A.  Fox  and  E.  Brewer,  “Path-based  failure  and  evolution 
management”,  in  1st  USENIX  Symposium  on  Networked 
Systems  Design  and 
(NSDI’04),  San 
Francisco, CA, March 2004. 
[2] G. Jiang, H. Chen and K. Yoshihira, “Discovering likely 
invariants  of  distributed  transaction  systems  for  autonomic 
system  management”,  The  3rd  International  Conference  on 
Autonomic Computing, Dublin, Ireland, June, 2006. 
[3] J. Bilmes, “A gentle tutorial of the EM algorithm and its 
application to parameter estimation for Gaussian mixture and 
hidden  Markov  models,”  Technical  Report,  U.C.  Berkeley, 
April, 1998. 
[4]  Z.  Zivkovic  and  F.  Heijden,  “Recursive  unsupervised 
learning  of  finite  mixture  models”,  IEEE  Transactions  on 
Pattern Analysis and Machine Intelligence, vol. 26, no. 5, pp. 
651–656, May, 2004.  
[5]  A.  Yemini  and  S.  Kliger,  “High  speed  and robust event 
correlation”, IEEE Communication Magazine, vol. 34, no. 5, 
pp. 82-90, May, 1996. 
[6]  C.  Chao,  D.  Yang  and  A.  Liu,  “An  automated  fault 
diagnosis  system  using  hierarchical  reasoning  and  alarm 
correlation”,  Journal of  Network  and  Systems Management, 
vol.9, no.2, pp. 183-202, June, 2001. 
[7] A. Benveniste, E. Fabre, C. Jard and S. Haar, “Diagnosis 
of  asynchronous  discrete  event  systems,  a  net  unfolding 
approach”, IEEE Transactions on Automatic Control, vol. 48, 
no. 5, pp. 714-727, May, 2003. 
[8]  R.  Vaarandi,  “A  data  clustering  algorithm  for  mining 
patterns from event logs,” in Proc. of 2003 IEEE Workshop 
on IP Operations & Management (IPOM2003), Kansas City, 
Missouri, October, 2003. 
[9]  K.  Yamanishi,  J.  Takeuchi,  G.  Williams  and  P.  Milne, 
“On-line unsupervised outlier detection using finite mixtures 
with discounting learning algorithms”, in Proceedings of the 
sixth ACM international conference on Knowledge discovery 
and data mining, pp. 320-324, Boston, MA, August, 2000. 
[10] http://java.sun.com/products/JavaMangement/ 
[11] P. Filzmoser, “A multivariate outlier detection method”, 
in  Proc.  of 
the  Seventh  International  Conference  on 
Computer Data Analysis and Modeling, volume 1, pp. 18-22, 
Minsk, Belarus, 2004. 
[12]  A.  Gelman,  J.B.  Carlin,  H.S.  Stern  and  D.B.  Rubin, 
Bayesian data analysis, Chapter 16, Chapman and Hall, 1995. 
[13] Http://java.sun.com/deveoper/releases/petstore/. 
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:26:44 UTC from IEEE Xplore.  Restrictions apply.