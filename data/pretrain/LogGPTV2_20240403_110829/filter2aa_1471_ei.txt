time by a trusted entity (an intermediate or root certificate), the firmware
could assume that even the inner public key must be considered trusted. This
mechanism is shown in Figure 12-3 and is called the chain of trust. It relies
on the fact that a digital certificate (used for code signing) can be signed
using the public key of another trusted higher-level certificate (a root or
intermediate certificate). The model is simplified here because a complete
description of all the details is outside the scope of this book.
Figure 12-3 A simplified representation of the chain of trust.
The allowed/revoked UEFI certificates and hashes have to establish some
hierarchy of trust by using the entities shown in Figure 12-4, which are stored
in UEFI variables:
■    Platform key (PK) The platform key represents the root of trust and
is used to protect the key exchange key (KEK) database. The platform
vendor puts the public portion of the PK into UEFI firmware during
manufacturing. Its private portion stays with the vendor.
■    Key exchange key (KEK) The key exchange key database contains
trusted certificates that are allowed to modify the allowed signature
database (DB), disallowed signature database (DBX), or timestamp
signature database (DBT). The KEK database usually contains
certificates of the operating system vendor (OSV) and is secured by
the PK.
Hashes and signatures used to verify bootloaders and other pre-boot
components are stored in three different databases. The allowed signature
database (DB) contains hashes of specific binaries or certificates (or their
hashes) that were used to generate code-signing certificates that have signed
bootloader and other preboot components (following the chain of trust
model). The disallowed signature database (DBX) contains the hashes of
specific binaries or certificates (or their hashes) that were compromised
and/or revoked. The timestamp signature database (DBT) contains
timestamping certificates used when signing bootloader images. All three
databases are locked from editing by the KEK.
Figure 12-4 The certificate the chain of trust used in the UEFI Secure
Boot.
To properly seal Secure Boot keys, the firmware should not allow their
update unless the entity attempting the update can prove (with a digital
signature on a specified payload, called the authentication descriptor) that
they possess the private part of the key used to create the variable. This
mechanism is implemented in UEFI through the Authenticated Variables. At
the time of this writing, the UEFI specifications allow only two types of
signing keys: X509 and RSA2048. An Authenticated Variable may be
cleared by writing an empty update, which must still contain a valid
authentication descriptor. When an Authenticated Variable is first created, it
stores both the public portion of the key that created it and the initial value
for the time (or a monotonic count) and will accept only subsequent updates
signed with that key and which have the same update type. For example, the
KEK variable is created using the PK and can be updated only by an
authentication descriptor signed with the PK.
 Note
The way in which the UEFI firmware uses the Authenticated Variables in
Secure Boot environments could lead to some confusion. Indeed, only the
PK, KEK, and signatures databases are stored using Authenticated
Variables. The other UEFI boot variables, which store boot configuration
data, are still regular runtime variables. This means that in a Secure Boot
environment, a user is still able to update or change the boot configuration
(modifying even the boot order) without any problem. This is not an
issue, because the secure verification is always made on every kind of
boot application (regardless of its source or order). Secure Boot is not
designed to prevent the modification of the system boot configuration.
The Windows Boot Manager
As discussed previously, the UEFI firmware reads and executes the Windows
Boot Manager (Bootmgfw.efi). The EFI firmware transfers control to
Bootmgr in long mode with paging enabled, and the memory space defined
by the UEFI memory map is mapped one to one. So, unlike wBIOS systems,
there’s no need to switch execution context. The Windows Boot Manager is
indeed the first application that’s invoked when starting or resuming the
Windows OS from a completely off power state or from hibernation
(S4 power state). The Windows Boot Manager has been completely
redesigned starting from Windows Vista, with the following goals:
■    Support the boot of different operating systems that employ complex
and various boot technologies.
■    Separate the OS-specific startup code in its own boot application
(named Windows Loader) and the Resume application (Winresume).
■    Isolate and provide common boot services to the boot applications.
This is the role of the boot libraries.
Even though the final goal of the Windows Boot Manager seems obvious,
its entire architecture is complex. From now on, we use the term boot
application to refer to any OS loader, such as the Windows Loader and other
loaders. Bootmgr has multiple roles, such as the following:
■    Initializes the boot logger and the basic system services needed for the
boot application (which will be discussed later in this section)
■    Initializes security features like Secure Boot and Measured Boot,
loads their system policies, and verifies its own integrity
■    Locates, opens, and reads the Boot Configuration Data store
■    Creates a “boot list” and shows a basic boot menu (if the boot menu
policy is set to Legacy)
■    Manages the TPM and the unlock of BitLocker-encrypted drives
(showing the BitLocker unlock screen and providing a recovery
method in case of problems getting the decryption key)
■    Launches a specific boot application and manages the recovery
sequence in case the boot has failed (Windows Recovery
Environment)
One of the first things performed is the configuration of the boot logging
facility and initialization of the boot libraries. Boot applications include a
standard set of libraries that are initialized at the start of the Boot Manager.
Once the standard boot libraries are initialized, then their core services are
available to all boot applications. These services include a basic memory
manager (that supports address translation, and page and heap allocation),
firmware parameters (like the boot device and the boot manager entry in the
BCD), an event notification system (for Measured Boot), time, boot logger,
crypto modules, the Trusted Platform Module (TPM), network, display
driver, and I/O system (and a basic PE Loader). The reader can imagine the
boot libraries as a special kind of basic hardware abstraction layer (HAL) for
the Boot Manager and boot applications. In the early stages of library
initialization, the System Integrity boot library component is initialized. The
goal of the System Integrity service is to provide a platform for reporting and
recording security-relevant system events, such as loading of new code,
attaching a debugger, and so on. This is achieved using functionality
provided by the TPM and is used especially for Measured Boot. We describe
this feature later in the chapter in the “Measured Boot” section.
To properly execute, the Boot Manager initialization function (BmMain)
needs a data structure called Application Parameters that, as the name
implies, describes its startup parameters (like the Boot Device, BCD object
GUID, and so on). To compile this data structure, the Boot Manager uses the
EFI firmware services with the goal of obtaining the complete relative path
of its own executable and getting the startup load options stored in the active
EFI boot variable (BOOT000X). The EFI specifications dictate that an EFI
boot variable must contain a short description of the boot entry, the complete
device and file path of the Boot Manager, and some optional data. Windows
uses the optional data to store the GUID of the BCD object that describes
itself.
 Note
The optional data could include any other boot options, which the Boot
Manager will parse at later stages. This allows the configuration of the
Boot Manager from UEFI variables without using the Windows Registry
at all.
EXPERIMENT: Playing with the UEFI boot variables
You can use the UefiTool utility (found in this book’s
downloadable resources) to dump all the UEFI boot variables of
your system. To do so, just run the tool in an administrative
command prompt and specify the /enum command-line parameter.
(You can launch the command prompt as administrator by
searching cmd in the Cortana search box and selecting Run As
Administrator after right-clicking Command Prompt.) A regular
system uses a lot of UEFI variables. The tool supports filtering all
the variables by name and GUID. You can even export all the
variable names and data in a text file using the /out parameter.
Start by dumping all the UEFI variables in a text file:
Click here to view code image
C:\Tools>UefiTool.exe /enum /out Uefi_Variables.txt
UEFI Dump Tool v0.1
Copyright 2018 by Andrea Allievi (AaLl86)
Firmware type: UEFI
Bitlocker enabled for System Volume: NO
Successfully written “Uefi_Variables.txt” file.
You can get the list of UEFI boot variables by using the
following filter:
Click here to view code image
C:\Tools>UefiTool.exe /enum Boot
UEFI Dump Tool v0.1
Copyright 2018 by Andrea Allievi (AaLl86)
Firmware type: UEFI
Bitlocker enabled for System Volume: NO
EFI Variable  “BootCurrent”
   Guid      : {8BE4DF61-93CA-11D2-AA0D-00E098032B8C}
   Attributes: 0x06 ( BS RT )
   Data size : 2 bytes
   Data:
   00 00                                           |
EFI Variable  “Boot0002”
   Guid      : {8BE4DF61-93CA-11D2-AA0D-00E098032B8C}
   Attributes: 0x07 ( NV BS RT )
   Data size : 78 bytes
   Data:
   01 00 00 00 2C 00 55 00 53 00 42 00 20 00 53 00 |    , U 
S B   S
   74 00 6F 00 72 00 61 00 67 00 65 00 00 00 04 07 | t o r a 
g e
   14 00 67 D5 81 A8 B0 6C EE 4E 84 35 2E 72 D3 3E | g ü¿ ⌉ 
Nä5.r >
   45 B5 04 06 14 00 71 00 67 50 8F 47 E7 4B AD 13 | E q 
gPÅG K¡
   87 54 F3 79 C6 2F 7F FF 04 00 55 53 42 00       | çT≤y /   
USB
EFI Variable  “Boot0000”
   Guid      : {8BE4DF61-93CA-11D2-AA0D-00E098032B8C}
   Attributes: 0x07 ( NV BS RT )
   Data size : 300 bytes
   Data:
   01 00 00 00 74 00 57 00 69 00 6E 00 64 00 6F 00 |    t W 
I n d o
   77 00 73 00 20 00 42 00 6F 00 6F 00 74 00 20 00 | w s   B 
o o t
   4D 00 61 00 6E 00 61 00 67 00 65 00 72 00 00 00 | M a n a 
g e r
   04 01 2A 00 02 00 00 00 00 A0 0F 00 00 00 00 00 | * á
   00 98 0F 00 00 00 00 00 84 C4 AF 4D 52 3B 80 44 |  ÿ     
ä »MR;ÇD
   98 DF 2C A4 93 AB 30 B0 02 02 04 04 46 00 5C 00 | ÿ  
,ñô½0 F \
   45 00 46 00 49 00 5C 00 4D 00 69 00 63 00 72 00 | E F I \ 
M i c r
   6F 00 73 00 6F 00 66 00 74 00 5C 00 42 00 6F 00 | o s o f 
t \ B o
   6F 00 74 00 5C 00 62 00 6F 00 6F 00 74 00 6D 00 | o t \ b 
o o t m
   67 00 66 00 77 00 2E 00 65 00 66 00 69 00 00 00 | g f w . 
e f i
   7F FF 04 00 57 49 4E 44 4F 57 53 00 01 00 00 00 |    
WINDOWS
   88 00 00 00 78 00 00 00 42 00 43 00 44 00 4F 00 | ê   x   
B C D O
   42 00 4A 00 45 00 43 00 54 00 3D 00 7B 00 39 00 | B J E C 
T = { 9
   64 00 65 00 61 00 38 00 36 00 32 00 63 00 2D 00 | d e a 8 
6 2 c -
   35 00 63 00 64 00 64 00 2D 00 34 00 65 00 37 00 | 5 c d d 
- 4 e 7
   30 00 2D 00 61 00 63 00 63 00 31 00 2D 00 66 00 | 0 - a c 
c 1 - f
   33 00 32 00 62 00 33 00 34 00 34 00 64 00 34 00 | 3 2 b 3 
4 4 d 4
   37 00 39 00 35 00 7D 00 00 00 6F 00 01 00 00 00 | 7 9 5 }   
o
   10 00 00 00 04 00 00 00 7F FF 04 00             |
EFI Variable "BootOrder"
   Guid      : {8BE4DF61-93CA-11D2-AA0D-00E098032B8C}
   Attributes: 0x07 ( NV BS RT )
   Data size : 8 bytes
   Data:
   02 00 00 00 01 00 03 00                         |
The tool can even interpret the content of each boot variable.
You can launch it using the /enumboot parameter:
Click here to view code image
C:\Tools>UefiTool.exe /enumboot
UEFI Dump Tool v0.1
Copyright 2018 by Andrea Allievi (AaLl86)
Firmware type: UEFI
Bitlocker enabled for System Volume: NO
System Boot Configuration
   Number of the Boot entries: 4
   Current active entry: 0
   Order: 2, 0, 1, 3
Boot Entry #2
   Type: Active
   Description: USB Storage
Boot Entry #0
   Type: Active
   Description: Windows Boot Manager
   Path: Harddisk0\Partition2 [LBA: 
0xFA000]\\EFI\Microsoft\Boot\bootmgfw.efi
   OS Boot Options: BCDOBJECT={9dea862c-5cdd-4e70-acc1-
f32b344d4795}
Boot Entry #1
   Type: Active
   Description: Internal Storage
Boot Entry #3
   Type: Active
   Description: PXE Network
When the tool is able to parse the boot path, it prints the relative
Path line (the same applies for the Winload OS load options). The
UEFI specifications define different interpretations for the path
field of a boot entry, which are dependent on the hardware
interface. You can change your system boot order by simply setting
the value of the BootOrder variable, or by using the /setbootorder
command-line parameter. Keep in mind that this could invalidate
the BitLocker Volume master key. (We explain this concept later
in this chapter in the “Measured Boot” section):
Click here to view code image
C:\Tools>UefiTool.exe /setvar bootorder {8BE4DF61-93CA-11D2-
AA0D-00E098032B8C}
0300020000000100
UEFI Dump Tool v0.1
Copyright 2018 by Andrea Allievi (AaLl86)
Firmware type: UEFI
Bitlocker enabled for System Volume: YES
Warning, The "bootorder" firmware variable already exist.
Overwriting it could potentially invalidate the system 
Bitlocker Volume Master Key.
Make sure that you have made a copy of the System volume 
Recovery Key.
Are you really sure that you would like to continue and 
overwrite its content? [Y/N] y
The "bootorder" firmware variable has been successfully 
written.
After the Application Parameters data structure has been built and all the
boot paths retrieved (\EFI\Microsoft\Boot is the main working directory), the
Boot Manager opens and parses the Boot Configuration Data file. This file
internally is a registry hive that contains all the boot application descriptors
and is usually mapped in an HKLM\BCD00000000 virtual key after the
system has completely started. The Boot Manager uses the boot library to
open and read the BCD file. The library uses EFI services to read and write
physical sectors from the hard disk and, at the time of this writing,
implements a light version of various file systems, such as NTFS, FAT,
ExFAT, UDFS, El Torito, and virtual file systems that support Network Boot
I/O, VMBus I/O (for Hyper-V virtual machines), and WIM images I/O. The
Boot Configuration Data hive is parsed, the BCD object that describes the
Boot Manager is located (through its GUID), and all the entries that represent
boot arguments are added to the startup section of the Application Parameters
data structure. Entries in the BCD can include optional arguments that
Bootmgr, Winload, and other components involved in the boot process
interpret. Table 12-2 contains a list of these options and their effects for
Bootmgr, Table 12-3 shows a list of BCD options available to all boot
applications, and Table 12-4 shows BCD options for the Windows boot
loader. Table 12-5 shows BCD options that control the execution of the
Windows Hypervisor.
Table 12-2 BCD options for the Windows Boot Manager (Bootmgr)
Reada
ble 
name
V
a
l
u
e
s
BCD 
Element 
Code1
Meaning
bcdfile
path
P
at
h
BCD_FILE
PATH
Points to the BCD (usually \Boot\BCD) 
file on the disk.
display
bootm
enu
B
o
o
le
a
DISPLAY_
BOOT_ME
NU
Determines whether the Boot Manager 
shows the boot menu or picks the default 
entry automatically.
n
noerror
display
B
o
o
le
a
n
NO_ERRO
R_DISPLA
Y
Silences the output of errors encountered 
by the Boot Manager.
resume
B
o
o
le
a
n
ATTEMPT_
RESUME
Specifies whether resuming from 
hibernation should be attempted. This 
option is automatically set when 
Windows hibernates.
timeou
t