While we can initially set Ëœğ‘¥ = ğ‘¥, a result of a computation (here Ëœğ‘§)
might be larger than 2ğ‘˜ âˆ’ 1, but for the computation we only care
about the lower ğ‘˜ bits of Ëœğ‘§ (denoted as ğ‘§).
As in SPDZ2ğ‘˜ , the MACs are obtained using vector OLE over
rings. We describe the protocols in the F ğ‘ ,ğ‘Ÿ
-hybrid model (cf. Fig-
ure 11); in Section 5.4, we discuss how to instantiate this VOLE
functionality. To open a commitment [ğ‘¥], first the upper ğ‘  bits
of Ëœğ‘¥ need to be randomized, by computing [ğ‘§] â† [ğ‘¥] + 2ğ‘˜ Â· [ğ‘Ÿ]
with random Ëœğ‘Ÿ âˆˆğ‘… Z2ğ‘˜+ğ‘  . Then, Ëœğ‘§ and ğ‘€[ğ‘§] are published and the
MAC equation (Equation (1)) is verified. Following [13, 31], we
implement more efficient batched checks based on a random ora-
cle in protocol Î 
(Figure 14).
(Figures 12 & 13) and protocol Î 
Z2ğ‘˜
ComZK-b
Z2ğ‘˜
ComZK-a
vole2k
Vector Linear Oblivious Evaluation for Z2ğ‘˜ : F ğ‘ ,ğ‘Ÿ
vole2k
Init This method needs to be the first one called by the
parties. On input (Init) from both parties the functionality
(1) If V is honest, it samples Î” âˆˆğ‘… Z2ğ‘  and sends Î” to V.
(2) If V is corrupt, it receives Î” âˆˆ Z2ğ‘  from S.
(3) Î” is then stored by the functionality.
All further Input queries are ignored.
Extend On input (Extend) from both parties the function-
ality proceeds as follows:
(1) If both parties are honest, sample ğ‘¥, ğ¾[ğ‘¥] âˆˆğ‘… Z2ğ‘Ÿ and
compute ğ‘€[ğ‘¥] â† Î” Â· ğ‘¥ + ğ¾[ğ‘¥] âˆˆğ‘… Z2ğ‘Ÿ .
(2) If V is corrupted, it receives ğ¾[ğ‘¥] âˆˆ Z2ğ‘Ÿ from S in-
stead.
(3) If P is corrupted, it receives ğ‘¥, ğ‘€[ğ‘¥] âˆˆ Z2ğ‘Ÿ from S
instead, and computes ğ¾[ğ‘¥] â† ğ‘€[ğ‘¥] âˆ’ Î” Â· ğ‘¥ âˆˆ Z2ğ‘Ÿ .
(4) (ğ‘¥, ğ‘€[ğ‘¥]) is sent to P and ğ¾[ğ‘¥] is sent to V.
Figure 11: Functionality for vOLE with key size ğ‘  and message
size ğ‘Ÿ. Based on F ğ‘,ğ‘Ÿ
sVOLE from [31, Fig. 2].
Session 1C: Zero Knowledge I CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea200ComZK
ComZK
and Î 
Z2ğ‘˜
ComZK-a
5.2 Instantiation of F Z2ğ‘˜
Z2ğ‘˜
In this section, we present two protocols Î 
ComZK-b
which instantiate the F Z2ğ‘˜
functionality (Figure 15). These are
adaptions of the Wolverine [31] and Macâ€™nâ€™Cheese [4] protocols
to the Z2ğ‘˜ setting and differ mainly in the implementation of the
CheckMult method.
For CheckZero, we use in both variants the batched check from
[13, 31] based on a random oracle ğ» : {0, 1}âˆ— â†’ {0, 1}ğ‘ : First, the
) of each value [ğ‘¥ğ‘–]
upper ğ‘  bits (resp. the upper 2ğ‘  bits in Î 
are randomized by computing [ğ‘¦ğ‘–] â† [ğ‘¥ğ‘–] + 2ğ‘˜ Â· [ğ‘Ÿğ‘–] with random
ğ‘Ÿğ‘–. Then P sends the upper bits ğ‘ğ‘– of all the Ëœğ‘¦ğ‘– and a hash â„ :=
ğ»(ğ‘€[ğ‘¦1], . . . , ğ‘€[ğ‘¦ğ‘›]) to V. Finally, V uses the ğ‘ğ‘– to recompute
?
the MAC tags ğ‘€[ğ‘¦ğ‘–]â€² â† Î” Â· 2ğ‘˜ Â· ğ‘ğ‘– + ğ¾[ğ‘¦ğ‘–] and verifies that â„
=
ğ»(ğ‘€[ğ‘¦1]â€², . . . , ğ‘€[ğ‘¦ğ‘›]â€²) holds.
A previous version of this paper used a version of the batched
check described in SPDZ2ğ‘˜ [12] based on a random linear com-
bination. This would have been more efficient since it does not
require sending the randomized upper bits of each value separately.
Unfortunately, due to a bug in their proof this check is not sound,
so we cannot use it here. A less efficient adaption of the check could
be used if one wants to avoid using a random oracle, though.
Z2ğ‘˜
ComZK-b
Î 
Z2ğ‘˜
ComZK-a
(Figures 12 & 13) adapts the bucketing approach from
Wolverine [31]: Let ğ¶, ğµ âˆˆ N be the parameters of the bucketing
scheme. To check that a collection of triples ([ğ‘ğ‘–], [ğ‘ğ‘–], [ğ‘ğ‘–])ğ‘›
ğ‘–=1
satisfy a multiplicative relation, i.e. ğ‘ğ‘– Â· ğ‘ğ‘– = ğ‘ğ‘– for ğ‘– = 1, . . . , ğ‘›, the
prover creates a set of â„“ := ğ‘›Â· ğµ+ğ¶ unchecked multiplication triples
of commitments. After randomly permuting the â„“ triples according
to the choice of the verifier, ğ¶ triples are opened and checked
by the verifier. The remaining ğ‘›ğµ triples are evenly distributed
?
into ğ‘› buckets. Then, each multiplication (ğ‘ğ‘– Â· ğ‘ğ‘–
= ğ‘ğ‘–) is verified
with the ğµ triples of the corresponding bucket with a variant of
Beaverâ€™s multiplication trick [5]. For the check to pass despite an
invalid multiplication ğ‘ğ‘– Â· ğ‘ğ‘– â‰  ğ‘ğ‘–, the adversary needs to corrupt
exactly those triples that end up in the corresponding bucket for
that multiplication.
For Î 
Z2ğ‘˜
ComZK-b
(Figure 14), we have adapted the multiplication
check of Macâ€™nâ€™Cheese [4], which is similar to the Wolverine [31]
optimization for large fields and SPDZ-style [14] sacrificing of mul-
tiplication triples. The soundness of this type of check is based on
the difficulty of finding a solution to a randomized equation. If a
multiplicative relation does not hold, the adversary needs to guess
a random field element in order to pass. Thus the original scheme
needs a large field to be sound. In the Z2ğ‘˜ -setting, there are multiple
obstacles that we have to overcome. First, we would like to also
support small values of ğ‘˜ (e.g. ğ‘˜ = 8 or 16). Simultaneously, we
also have to deal with zero divisors (which complicate the check)
which were no issue in the field setting. Moreover, even though the
commitment scheme (see Section 5.1) uses the larger ring Z2ğ‘˜+ğ‘  it
only authenticates the lower ğ‘˜ bits of Ëœğ‘¥ and cannot prevent modifi-
cations of the upper bits, which might lead to additional problems.
We overcome these challenges by further increasing the ring size
from Z2ğ‘˜+ğ‘  to Z2ğ‘˜+2ğ‘  , so that the commitment scheme provides au-
thenticity of values modulo 2ğ‘˜+ğ‘ . We use the additional ğ‘  bits to
avoid overflows when checking correctness of the multiplicative
relations modulo 2ğ‘˜ with an ğ‘  bit random challenge. Increasing
the ring leads to larger storage and communication requirements â€“
the values Ëœğ‘¥, ğ‘€[ğ‘¥], ğ¾[ğ‘¥] now require ğ‘˜ + 2ğ‘  bits. We discuss the
communication complexity of both variants in Section 6.1.1.
5.3 Proofs of Security
In this section we formally state the security guarantees of our
protocols. and give an overview of the corresponding proofs. Due
to space limits, the complete proofs are given in Appendix E.
Protocol Î 
Z2ğ‘˜
ComZK-a (Part 1)
vole2k
Each party can abort the protocol by sending the message
(abort) to the other party and terminating the execution.
Init For (Init), the parties send (Init) to F ğ‘ ,ğ‘˜+ğ‘ 
. V re-
ceives its global MAC key Î” âˆˆ Z2ğ‘  .
Random For (Random), the parties send (Extend) to
F ğ‘ ,ğ‘˜+ğ‘ 
so that P receives ğ‘€[ğ‘Ÿ], ğ‘Ÿ âˆˆ Z2ğ‘˜+ğ‘  and V receives
ğ¾[ğ‘Ÿ] âˆˆ Z2ğ‘˜+ğ‘  so that ğ‘€[ğ‘Ÿ] = Î” Â· ğ‘Ÿ + ğ¾[ğ‘Ÿ] holds. This is
vole2k
denoted as [ğ‘Ÿ].
ğ‘–=1 ğ›¼ğ‘– Â· [ğ‘¥ğ‘–], the
Affine Combination For [ğ‘§] â† ğ›¼0 +ğ‘›
â€¢ Ëœğ‘§ â† ğ›¼0 +ğ‘›
â€¢ ğ‘€[ğ‘§] â†ğ‘›
â€¢ ğ¾[ğ‘§] â† âˆ’Î” Â· ğ›¼0 +ğ‘›
ğ‘–=1 ğ›¼ğ‘– Â· Ëœğ‘¥ğ‘– (by P),
ğ‘–=1 ğ›¼ğ‘– Â· ğ‘€[ğ‘¥ğ‘–] (by P),
ğ‘–=1 ğ›¼ğ‘– Â· ğ¾[ğ‘¥ğ‘–] (by V).
CheckZero Let ğ» : {0, 1}âˆ— â†’ {0, 1}ğ‘  denote a random or-
acle. For (CheckZero, [ğ‘¥1], . . . , [ğ‘¥ğ‘›]), the parties proceed
as follows:
(1) If one of the ğ‘¥ğ‘– is not equal to 0, then P aborts.
(2) They run [ğ‘Ÿ1], . . . , [ğ‘Ÿğ‘›] â† Random() and compute
parties locally set
[ğ‘¦ğ‘–] â† [ğ‘¥ğ‘–] + 2ğ‘˜ Â· [ğ‘Ÿğ‘–] for ğ‘– = 1, . . . , ğ‘›.
(3) P sends ğ‘1, . . . , ğ‘ğ‘› to V where ğ‘ğ‘– := ( Ëœğ‘¦ğ‘– âˆ’ ğ‘¦ğ‘–)/2ğ‘˜ de-
notes the upper ğ‘  bits of Ëœğ‘¦ğ‘–.
(4) P computes â„ â† ğ»(ğ‘€[ğ‘¦1], . . . , ğ‘€[ğ‘¦ğ‘›]) and sends â„ âˆˆ
{0, 1}2ğœ† to the verifier.
(5) Finally,V computes ğ‘€[ğ‘¦ğ‘–]â€² â† Î”Â·2ğ‘˜Â·ğ‘ğ‘–+ğ¾[ğ‘¦ğ‘–] âˆˆ Z2ğ‘˜+ğ‘ 
?
= ğ»(ğ‘€[ğ‘¦1]â€², . . . , ğ‘€[ğ‘¦ğ‘›]â€²)
for ğ‘– = 1, . . . , ğ‘›, checks â„
and outputs (success) if the equality holds and aborts
otherwise
Input For (Input, ğ‘¥), where ğ‘¥ âˆˆ Z2ğ‘˜ is known by P, the
parties first run [ğ‘Ÿ] â† Random(). Then P sends ğ›¿ :=
ğ‘¥ âˆ’ ğ‘Ÿ mod 2ğ‘˜ to V, and they compute [ğ‘¥] â† [ğ‘Ÿ] + ğ›¿.
Open For (Open, [ğ‘¥1], . . . , [ğ‘¥ğ‘›]), P sends ğ‘¥1, . . . , ğ‘¥ğ‘› to V,
and they compute [ğ‘§ğ‘–] â† [ğ‘¥ğ‘–]âˆ’ğ‘¥ğ‘– for ğ‘– = 1, . . . , ğ‘›, followed
by CheckZero([ğ‘§1], . . . , [ğ‘§ğ‘›]). The result of the latter is
returned.
Figure 12: Protocol Î 
Wolverine-like [31] multiplication check.
ComZK-a instantiating F Z2ğ‘˜
Z2ğ‘˜
ComZK using a
Session 1C: Zero Knowledge I CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea201Z2ğ‘˜
ComZK-a (Part 2)
Protocol Î 
MultiplicationCheck Let ğµ, ğ¶ âˆˆ N be parameters of the
ğ‘–=1) the
protocol. On input (CheckMult, ([ğ‘ğ‘–], [ğ‘ğ‘–], [ğ‘ğ‘–])ğ‘›
parties proceed as follows:
(1) P aborts if ğ‘ğ‘– Â· ğ‘ğ‘– â‰  ğ‘ğ‘– (mod 2ğ‘˜) for some ğ‘– = 1, . . . , ğ‘›.
(2) Let â„“ := ğ‘› Â· ğµ + ğ¶, and initialize lst â† âˆ…
(3) They compute ([ğ‘¥ğ‘–], [ğ‘¦ğ‘–])â„“
ğ‘–=1 â† Random() so that P
(4) P computes ğ‘§ğ‘– â† ğ‘¥ğ‘– Â· ğ‘¦ğ‘– for ğ‘– = 1, . . . , â„“, and they run
receives (ğ‘¥ğ‘–, ğ‘¦ğ‘–)â„“
ğ‘–=1.
([ğ‘§ğ‘–])â„“
ğ‘–=1 â† Input((ğ‘§ğ‘–)â„“
ğ‘–=1).
ğ‘–=1, lst).
(5) V samples a permutation ğœ‹ âˆˆğ‘… ğ‘†â„“ and sends it to P.
(6) They run (ğ‘¥ğœ‹ (ğ‘–), ğ‘¦ğœ‹ (ğ‘–), ğ‘§ğœ‹ (ğ‘–))ğ¶
ğ‘–=1 â†
Open(([ğ‘¥ğœ‹ (ğ‘–)], [ğ‘¦ğœ‹ (ğ‘–)], [ğ‘§ğœ‹ (ğ‘–)])ğ¶
aborts otherwise.
(7) V checks if ğ‘¥ğœ‹ (ğ‘–) Â· ğ‘¦ğœ‹ (ğ‘–) = ğ‘§ğœ‹ (ğ‘–) for ğ‘– = 1, . . . , ğ¶, and
(8) For each (ğ‘ ğ‘— , ğ‘ ğ‘— , ğ‘ ğ‘—) with ğ‘— = 1, . . . , ğ‘› and for each
(ğ‘¥ğœ‹ (ğ‘˜), ğ‘¦ğœ‹ (ğ‘˜), ğ‘§ğœ‹ (ğ‘˜)) with ğ‘˜ = ğ¶ +( ğ‘— âˆ’1) Â· ğµ+1, . . . , ğ¶ +
ğ‘— Â· ğµ, they compute
(a)ğ‘‘ â† Open([ğ‘ ğ‘—] âˆ’ [ğ‘¥ğœ‹ (ğ‘˜)], lst) and ğ‘’ â†
(b)[ğ‘¤ğ‘˜] â† [ğ‘§ğœ‹ (ğ‘˜)]âˆ’[ğ‘ ğ‘—]+ğ‘’Â·[ğ‘¥ğœ‹ (ğ‘˜)]+ğ‘‘Â·[ğ‘¦ğœ‹ (ğ‘˜)]+ğ‘‘Â·ğ‘’
ğ‘˜=ğ¶+1). If suc-
cessful and the check in Step 7 also passed, V outputs
(success) and aborts otherwise.
(9) Finally, they run (CheckZero, lst, ([ğ‘¤ğ‘˜])â„“
Open([ğ‘ ğ‘—] âˆ’ [ğ‘¦ğœ‹ (ğ‘˜)], lst) and
Figure 13: Protocol Î 
Wolverine-like [31] multiplication check.
ComZK-a instantiating F Z2ğ‘˜
Z2ğ‘˜
ComZK using a
5.3.1 Proof of Î 
follows:
Z2ğ‘˜
ComZK-a. We state the security of our protocol as
ğµ
(cid:1)âˆ’1
(ğ‘cz + ğ‘cm) Â· 2âˆ’ğ‘ +1 + ğ‘cm Â·(cid:0)ğ‘›ğµ+ğ¶
Z2ğ‘˜
Theorem 5.1. The protocol Î 
ComZK-a(Figures 12 & 13) securely
realizes the functionality F Z2ğ‘˜
ComZK: No environment can distinguish
the real execution from a simulated one except with probability
, where ğ‘cz is the sum of calls to
CheckZero and Open, and ğ‘cm the number of calls to CheckMult.
We prove the theorem in the UC model by constructing a simula-
tor that generates a view indistinguishable to that in a real protocol
execution. In the case of a corrupted verifier, the simulation is per-
fect. For a corrupted prover, the distinguishing advantage depends
on the soundness properties of the CheckZero and CheckMult pro-
. These are stated in the following two lemmata.
tocols in Î 
The full proof of Theorem 5.1 is given in Appendix E.1.
Z2ğ‘˜
ComZK-a
Lemma 5.2. If Pâˆ— and V run the CheckZero protocol of Î 
Z2ğ‘˜
comâˆ’a
with commitments [ğ‘¥1], . . . , [ğ‘¥ğ‘›] and ğ‘¥ğ‘– (cid:46)ğ‘˜ 0 for some ğ‘– âˆˆ {1, . . . , ğ‘›}
then V outputs (success) with probability at most ğœ€cz := 2âˆ’ğ‘ +1.
The CheckZero protocol is based on the batch check from [13,
31], and the proof of Lemma 5.2 is given in Appendix E.2.
Protocol Î 
Z2ğ‘˜
ComZK-b
Z2ğ‘˜
ComZK-a
, although using F ğ‘ ,ğ‘˜+2ğ‘ 
(Figures 12
Much of the protocol is identical to Î 
and 13) with the exception that the MACs are now com-