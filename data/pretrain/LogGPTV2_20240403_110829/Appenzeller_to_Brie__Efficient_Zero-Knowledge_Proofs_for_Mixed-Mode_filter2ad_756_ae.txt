While we can initially set ˜𝑥 = 𝑥, a result of a computation (here ˜𝑧)
might be larger than 2𝑘 − 1, but for the computation we only care
about the lower 𝑘 bits of ˜𝑧 (denoted as 𝑧).
As in SPDZ2𝑘 , the MACs are obtained using vector OLE over
rings. We describe the protocols in the F 𝑠,𝑟
-hybrid model (cf. Fig-
ure 11); in Section 5.4, we discuss how to instantiate this VOLE
functionality. To open a commitment [𝑥], first the upper 𝑠 bits
of ˜𝑥 need to be randomized, by computing [𝑧] ← [𝑥] + 2𝑘 · [𝑟]
with random ˜𝑟 ∈𝑅 Z2𝑘+𝑠 . Then, ˜𝑧 and 𝑀[𝑧] are published and the
MAC equation (Equation (1)) is verified. Following [13, 31], we
implement more efficient batched checks based on a random ora-
cle in protocol Π
(Figure 14).
(Figures 12 & 13) and protocol Π
Z2𝑘
ComZK-b
Z2𝑘
ComZK-a
vole2k
Vector Linear Oblivious Evaluation for Z2𝑘 : F 𝑠,𝑟
vole2k
Init This method needs to be the first one called by the
parties. On input (Init) from both parties the functionality
(1) If V is honest, it samples Δ ∈𝑅 Z2𝑠 and sends Δ to V.
(2) If V is corrupt, it receives Δ ∈ Z2𝑠 from S.
(3) Δ is then stored by the functionality.
All further Input queries are ignored.
Extend On input (Extend) from both parties the function-
ality proceeds as follows:
(1) If both parties are honest, sample 𝑥, 𝐾[𝑥] ∈𝑅 Z2𝑟 and
compute 𝑀[𝑥] ← Δ · 𝑥 + 𝐾[𝑥] ∈𝑅 Z2𝑟 .
(2) If V is corrupted, it receives 𝐾[𝑥] ∈ Z2𝑟 from S in-
stead.
(3) If P is corrupted, it receives 𝑥, 𝑀[𝑥] ∈ Z2𝑟 from S
instead, and computes 𝐾[𝑥] ← 𝑀[𝑥] − Δ · 𝑥 ∈ Z2𝑟 .
(4) (𝑥, 𝑀[𝑥]) is sent to P and 𝐾[𝑥] is sent to V.
Figure 11: Functionality for vOLE with key size 𝑠 and message
size 𝑟. Based on F 𝑝,𝑟
sVOLE from [31, Fig. 2].
Session 1C: Zero Knowledge I CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea200ComZK
ComZK
and Π
Z2𝑘
ComZK-a
5.2 Instantiation of F Z2𝑘
Z2𝑘
In this section, we present two protocols Π
ComZK-b
which instantiate the F Z2𝑘
functionality (Figure 15). These are
adaptions of the Wolverine [31] and Mac’n’Cheese [4] protocols
to the Z2𝑘 setting and differ mainly in the implementation of the
CheckMult method.
For CheckZero, we use in both variants the batched check from
[13, 31] based on a random oracle 𝐻 : {0, 1}∗ → {0, 1}𝑠: First, the
) of each value [𝑥𝑖]
upper 𝑠 bits (resp. the upper 2𝑠 bits in Π
are randomized by computing [𝑦𝑖] ← [𝑥𝑖] + 2𝑘 · [𝑟𝑖] with random
𝑟𝑖. Then P sends the upper bits 𝑝𝑖 of all the ˜𝑦𝑖 and a hash ℎ :=
𝐻(𝑀[𝑦1], . . . , 𝑀[𝑦𝑛]) to V. Finally, V uses the 𝑝𝑖 to recompute
?
the MAC tags 𝑀[𝑦𝑖]′ ← Δ · 2𝑘 · 𝑝𝑖 + 𝐾[𝑦𝑖] and verifies that ℎ
=
𝐻(𝑀[𝑦1]′, . . . , 𝑀[𝑦𝑛]′) holds.
A previous version of this paper used a version of the batched
check described in SPDZ2𝑘 [12] based on a random linear com-
bination. This would have been more efficient since it does not
require sending the randomized upper bits of each value separately.
Unfortunately, due to a bug in their proof this check is not sound,
so we cannot use it here. A less efficient adaption of the check could
be used if one wants to avoid using a random oracle, though.
Z2𝑘
ComZK-b
Π
Z2𝑘
ComZK-a
(Figures 12 & 13) adapts the bucketing approach from
Wolverine [31]: Let 𝐶, 𝐵 ∈ N be the parameters of the bucketing
scheme. To check that a collection of triples ([𝑎𝑖], [𝑏𝑖], [𝑐𝑖])𝑛
𝑖=1
satisfy a multiplicative relation, i.e. 𝑎𝑖 · 𝑏𝑖 = 𝑐𝑖 for 𝑖 = 1, . . . , 𝑛, the
prover creates a set of ℓ := 𝑛· 𝐵+𝐶 unchecked multiplication triples
of commitments. After randomly permuting the ℓ triples according
to the choice of the verifier, 𝐶 triples are opened and checked
by the verifier. The remaining 𝑛𝐵 triples are evenly distributed
?
into 𝑛 buckets. Then, each multiplication (𝑎𝑖 · 𝑏𝑖
= 𝑐𝑖) is verified
with the 𝐵 triples of the corresponding bucket with a variant of
Beaver’s multiplication trick [5]. For the check to pass despite an
invalid multiplication 𝑎𝑖 · 𝑏𝑖 ≠ 𝑐𝑖, the adversary needs to corrupt
exactly those triples that end up in the corresponding bucket for
that multiplication.
For Π
Z2𝑘
ComZK-b
(Figure 14), we have adapted the multiplication
check of Mac’n’Cheese [4], which is similar to the Wolverine [31]
optimization for large fields and SPDZ-style [14] sacrificing of mul-
tiplication triples. The soundness of this type of check is based on
the difficulty of finding a solution to a randomized equation. If a
multiplicative relation does not hold, the adversary needs to guess
a random field element in order to pass. Thus the original scheme
needs a large field to be sound. In the Z2𝑘 -setting, there are multiple
obstacles that we have to overcome. First, we would like to also
support small values of 𝑘 (e.g. 𝑘 = 8 or 16). Simultaneously, we
also have to deal with zero divisors (which complicate the check)
which were no issue in the field setting. Moreover, even though the
commitment scheme (see Section 5.1) uses the larger ring Z2𝑘+𝑠 it
only authenticates the lower 𝑘 bits of ˜𝑥 and cannot prevent modifi-
cations of the upper bits, which might lead to additional problems.
We overcome these challenges by further increasing the ring size
from Z2𝑘+𝑠 to Z2𝑘+2𝑠 , so that the commitment scheme provides au-
thenticity of values modulo 2𝑘+𝑠. We use the additional 𝑠 bits to
avoid overflows when checking correctness of the multiplicative
relations modulo 2𝑘 with an 𝑠 bit random challenge. Increasing
the ring leads to larger storage and communication requirements –
the values ˜𝑥, 𝑀[𝑥], 𝐾[𝑥] now require 𝑘 + 2𝑠 bits. We discuss the
communication complexity of both variants in Section 6.1.1.
5.3 Proofs of Security
In this section we formally state the security guarantees of our
protocols. and give an overview of the corresponding proofs. Due
to space limits, the complete proofs are given in Appendix E.
Protocol Π
Z2𝑘
ComZK-a (Part 1)
vole2k
Each party can abort the protocol by sending the message
(abort) to the other party and terminating the execution.
Init For (Init), the parties send (Init) to F 𝑠,𝑘+𝑠
. V re-
ceives its global MAC key Δ ∈ Z2𝑠 .
Random For (Random), the parties send (Extend) to
F 𝑠,𝑘+𝑠
so that P receives 𝑀[𝑟], 𝑟 ∈ Z2𝑘+𝑠 and V receives
𝐾[𝑟] ∈ Z2𝑘+𝑠 so that 𝑀[𝑟] = Δ · 𝑟 + 𝐾[𝑟] holds. This is
vole2k
denoted as [𝑟].
𝑖=1 𝛼𝑖 · [𝑥𝑖], the
Affine Combination For [𝑧] ← 𝛼0 +𝑛
• ˜𝑧 ← 𝛼0 +𝑛
• 𝑀[𝑧] ←𝑛
• 𝐾[𝑧] ← −Δ · 𝛼0 +𝑛
𝑖=1 𝛼𝑖 · ˜𝑥𝑖 (by P),
𝑖=1 𝛼𝑖 · 𝑀[𝑥𝑖] (by P),
𝑖=1 𝛼𝑖 · 𝐾[𝑥𝑖] (by V).
CheckZero Let 𝐻 : {0, 1}∗ → {0, 1}𝑠 denote a random or-
acle. For (CheckZero, [𝑥1], . . . , [𝑥𝑛]), the parties proceed
as follows:
(1) If one of the 𝑥𝑖 is not equal to 0, then P aborts.
(2) They run [𝑟1], . . . , [𝑟𝑛] ← Random() and compute
parties locally set
[𝑦𝑖] ← [𝑥𝑖] + 2𝑘 · [𝑟𝑖] for 𝑖 = 1, . . . , 𝑛.
(3) P sends 𝑝1, . . . , 𝑝𝑛 to V where 𝑝𝑖 := ( ˜𝑦𝑖 − 𝑦𝑖)/2𝑘 de-
notes the upper 𝑠 bits of ˜𝑦𝑖.
(4) P computes ℎ ← 𝐻(𝑀[𝑦1], . . . , 𝑀[𝑦𝑛]) and sends ℎ ∈
{0, 1}2𝜆 to the verifier.
(5) Finally,V computes 𝑀[𝑦𝑖]′ ← Δ·2𝑘·𝑝𝑖+𝐾[𝑦𝑖] ∈ Z2𝑘+𝑠
?
= 𝐻(𝑀[𝑦1]′, . . . , 𝑀[𝑦𝑛]′)
for 𝑖 = 1, . . . , 𝑛, checks ℎ
and outputs (success) if the equality holds and aborts
otherwise
Input For (Input, 𝑥), where 𝑥 ∈ Z2𝑘 is known by P, the
parties first run [𝑟] ← Random(). Then P sends 𝛿 :=
𝑥 − 𝑟 mod 2𝑘 to V, and they compute [𝑥] ← [𝑟] + 𝛿.
Open For (Open, [𝑥1], . . . , [𝑥𝑛]), P sends 𝑥1, . . . , 𝑥𝑛 to V,
and they compute [𝑧𝑖] ← [𝑥𝑖]−𝑥𝑖 for 𝑖 = 1, . . . , 𝑛, followed
by CheckZero([𝑧1], . . . , [𝑧𝑛]). The result of the latter is
returned.
Figure 12: Protocol Π
Wolverine-like [31] multiplication check.
ComZK-a instantiating F Z2𝑘
Z2𝑘
ComZK using a
Session 1C: Zero Knowledge I CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea201Z2𝑘
ComZK-a (Part 2)
Protocol Π
MultiplicationCheck Let 𝐵, 𝐶 ∈ N be parameters of the
𝑖=1) the
protocol. On input (CheckMult, ([𝑎𝑖], [𝑏𝑖], [𝑐𝑖])𝑛
parties proceed as follows:
(1) P aborts if 𝑎𝑖 · 𝑏𝑖 ≠ 𝑐𝑖 (mod 2𝑘) for some 𝑖 = 1, . . . , 𝑛.
(2) Let ℓ := 𝑛 · 𝐵 + 𝐶, and initialize lst ← ∅
(3) They compute ([𝑥𝑖], [𝑦𝑖])ℓ
𝑖=1 ← Random() so that P
(4) P computes 𝑧𝑖 ← 𝑥𝑖 · 𝑦𝑖 for 𝑖 = 1, . . . , ℓ, and they run
receives (𝑥𝑖, 𝑦𝑖)ℓ
𝑖=1.
([𝑧𝑖])ℓ
𝑖=1 ← Input((𝑧𝑖)ℓ
𝑖=1).
𝑖=1, lst).
(5) V samples a permutation 𝜋 ∈𝑅 𝑆ℓ and sends it to P.
(6) They run (𝑥𝜋 (𝑖), 𝑦𝜋 (𝑖), 𝑧𝜋 (𝑖))𝐶
𝑖=1 ←
Open(([𝑥𝜋 (𝑖)], [𝑦𝜋 (𝑖)], [𝑧𝜋 (𝑖)])𝐶
aborts otherwise.
(7) V checks if 𝑥𝜋 (𝑖) · 𝑦𝜋 (𝑖) = 𝑧𝜋 (𝑖) for 𝑖 = 1, . . . , 𝐶, and
(8) For each (𝑎 𝑗 , 𝑏 𝑗 , 𝑐 𝑗) with 𝑗 = 1, . . . , 𝑛 and for each
(𝑥𝜋 (𝑘), 𝑦𝜋 (𝑘), 𝑧𝜋 (𝑘)) with 𝑘 = 𝐶 +( 𝑗 −1) · 𝐵+1, . . . , 𝐶 +
𝑗 · 𝐵, they compute
(a)𝑑 ← Open([𝑎 𝑗] − [𝑥𝜋 (𝑘)], lst) and 𝑒 ←
(b)[𝑤𝑘] ← [𝑧𝜋 (𝑘)]−[𝑐 𝑗]+𝑒·[𝑥𝜋 (𝑘)]+𝑑·[𝑦𝜋 (𝑘)]+𝑑·𝑒
𝑘=𝐶+1). If suc-
cessful and the check in Step 7 also passed, V outputs
(success) and aborts otherwise.
(9) Finally, they run (CheckZero, lst, ([𝑤𝑘])ℓ
Open([𝑏 𝑗] − [𝑦𝜋 (𝑘)], lst) and
Figure 13: Protocol Π
Wolverine-like [31] multiplication check.
ComZK-a instantiating F Z2𝑘
Z2𝑘
ComZK using a
5.3.1 Proof of Π
follows:
Z2𝑘
ComZK-a. We state the security of our protocol as
𝐵
(cid:1)−1
(𝑞cz + 𝑞cm) · 2−𝑠+1 + 𝑞cm ·(cid:0)𝑛𝐵+𝐶
Z2𝑘
Theorem 5.1. The protocol Π
ComZK-a(Figures 12 & 13) securely
realizes the functionality F Z2𝑘
ComZK: No environment can distinguish
the real execution from a simulated one except with probability
, where 𝑞cz is the sum of calls to
CheckZero and Open, and 𝑞cm the number of calls to CheckMult.
We prove the theorem in the UC model by constructing a simula-
tor that generates a view indistinguishable to that in a real protocol
execution. In the case of a corrupted verifier, the simulation is per-
fect. For a corrupted prover, the distinguishing advantage depends
on the soundness properties of the CheckZero and CheckMult pro-
. These are stated in the following two lemmata.
tocols in Π
The full proof of Theorem 5.1 is given in Appendix E.1.
Z2𝑘
ComZK-a
Lemma 5.2. If P∗ and V run the CheckZero protocol of Π
Z2𝑘
com−a
with commitments [𝑥1], . . . , [𝑥𝑛] and 𝑥𝑖 (cid:46)𝑘 0 for some 𝑖 ∈ {1, . . . , 𝑛}
then V outputs (success) with probability at most 𝜀cz := 2−𝑠+1.
The CheckZero protocol is based on the batch check from [13,
31], and the proof of Lemma 5.2 is given in Appendix E.2.
Protocol Π
Z2𝑘
ComZK-b
Z2𝑘
ComZK-a
, although using F 𝑠,𝑘+2𝑠
(Figures 12
Much of the protocol is identical to Π
and 13) with the exception that the MACs are now com-