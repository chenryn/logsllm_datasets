### 优化后的文本

#### 优于Squirrel [!semantic] 的优势
Squirrel [!syntax＆!semantic] 相较于Squirrel [!semantic] 的主要优势在于生成速度更快。具体而言，Squirrel [!feedback] 需要700分钟才能找到第一个崩溃点。而总崩溃次数方面，Squirrel、Squirrel [!semantic]、Squirrel [!syntax＆!semantic] 和 Squirrel [!feedback] 分别检测到600、30、10和3次崩溃。这些结果表明，Squirrel 的三个因素（语法、语义和反馈）对崩溃检测至关重要。特别是基于覆盖率的反馈起着最重要的作用，而仅依赖语法测试无法胜过AFL。

**独特错误:**
我们采用了相同的策略来测量独特错误，并且每小时都会修补检测到的错误。图10(b) 展示了结果。全功能版 Squirrel 检测到了9个独特错误，而其他变体仅检测到一个独特错误。如表4所示，全功能版本还涵盖了Squirrel [!feedback&!semantic] 发现的独特错误。

**新边缘:**
图10(c)、(f) 和 (i) 显示了一种（几乎）一致的模式，即在 SQLite、PostgreSQL 和 MySQL 中寻找新的边缘：Squirrel > Squirrel[!semantic] > Squirrel[!syntax&semantic] > Squirrel[!feedback]。基于覆盖率的反馈使 SQLite、PostgreSQL 和 MySQL 在模糊测试中找到了2.0倍的新边缘。与AFL相比，语法正确性帮助找到多1.0×-1.5×的边缘，而语义正确性则增加了0.3×-1.7×。这表明提高语法或语义正确性有助于达到更多的DBMS状态。

**语法有效性和语义有效性:**
图10(d)、(g) 和 (j) 显示了在测试三个DBMS期间的语法变化，而图10(e)、(h) 和 (k) 显示了语义变化。大多数情况下，Squirrel 的有效性最高，AFL 的有效性最低。这一结果是合理的，因为我们设计 Squirrel 以获得更好的语言有效性，而 AFL 则随机变异 SQL 查询。然而，从图中可以看到一些有趣的异常。首先，Squirrel[!semantic] 的语法准确性与 Squirrel 相似，表明提高语义正确性并不会增加语法正确性。实际上，实例化可能会降低语法正确性，如图10(j) 所示，因为它倾向于删除短查询。短查询在语法上更可能正确，但我们的实例化程序无法修复其语义。例如，`SELECT a FROM b` 在语义上不正确，因为不存在表 `b`。由于 SQLsmith 的性能类似甚至优于 Squirrel，因此 PostgreSQL 和 MySQL 的 p 值大于0.05。

其次，在图10(j) 中，Squirrel[!feedback] 与 Squirrel 具有相似的语义正确性。这个结果似乎表明反馈对 MySQL 的语义正确性没有影响。但是，进一步检查发现，Squirrel[!feedback] 会产生非常不同的语义正确性：在五个实验中，有两个实验的正确率超过40%，而其他三个实验的正确率低于10%。我们发现 MySQL 中的初始种子比 SQLite 和 PostgreSQL 中的种子小。这些小种子可能导致 Squirrel[!feedback] 继续为 MySQL 生成正确但简单且重复的输入。由于 MySQL 结果的随机性，附录表6中的 p 值大于0.05。然而，图10(i) 显示，与 Squirrel[!feedback] 相比，Squirrel 生成的查询在结构上更加多样化，因为 Squirrel 发现了更多具有相似语义正确性的执行路径。

总体而言，语法、语义和反馈在 Squirrel 中起着至关重要的作用，以从 DBMS 中发现更多的内存错误。基于覆盖率的反馈影响最大，而语法正确性和语义正确性则具有不同的影响。最终结果是这三个因素之间的相互作用。

## 9 讨论
我们讨论了当前 Squirrel 实施的局限性以及我们在未来工作中解决这些局限的计划。

**DBMS 特定逻辑:**
尽管 Squirrel 设计与 DBMS 无关，但我们发现合并特定于程序的功能始终有助于获得更好的测试结果。每个 DBMS 都实现其特有的 SQL 方言，该方言可能与正式版本的 SQL 几乎相同（例如 SQLite），或者在许多功能方面显著不同（例如 PostgreSQL）。Squirrel 完全支持 SQL 的通用语法，并包含针对不同方言的补丁。因此，Squirrel 在 SQLite 上运行良好（51 个错误），但在 PostgreSQL、MySQL 和 MariaDB 中仅触发了几个错误。我们计划对不同的 SQL 方言实施更准确的语法，以提高模糊测试的效率。此外，DBMS 在执行查询之前可能会进行额外的检查。例如，PostgreSQL 要求所有操作数之间的类型正确，并且不允许在整数和浮点数之间进行比较。SQLite 不会检查任何内容，但会在执行过程中自动进行类型转换，而 MySQL 仅警告类型不匹配。我们计划在语义指导实例中实现类型一致性关系，以测试 PostgreSQL。

**关系规则构建:**
Squirrel 依赖关系规则来推断不同操作数之间的数据依赖关系。目前，我们基于领域知识编写关系规则。两位作者花费了两个小时编写了涵盖133个条款的规则。为了减轻开发人员的工作负担，我们计划采用自动推断这些规则的技术。例如，通过数据流分析，我们可以找出每个操作数之间的预期关系。另外，我们可以尝试使用机器学习技术来自动从大量正常执行中捕获关系。

**代码覆盖中的冲突:**
Squirrel 依靠 AFL 的反馈机制来指导查询选择，但不幸的是，它受到冲突问题的困扰。默认情况下，AFL 使用具有64K条目的位图记录分支覆盖范围，每个分支覆盖一个。对于分支很少的小型程序，此方法效果很好。但对于包含成千上万分支的 DBMS，使用 AFL 测试时存在严重的冲突问题。例如，SQLite 有大约20,000个不同的分支，其中14%的分支与其他分支共享位图条目。在评估过程中，我们将位图放大到256K以减轻冲突问题。下一步，我们计划采用 CollAFL 提出的解决方案来消除碰撞问题。

**替代反馈机制:**
最近的软件测试实践广泛采用代码覆盖率来指导基于突变的模糊测试。然而，在我们的评估中，我们发现了潜在有害的代码覆盖率，这阻碍了语义正确查询的生成。特别是在测试语法开始时，不正确的查询会在错误处理代码中触发许多新分支。基于覆盖率的反馈指导 Squirrel 专注于这些输入，而不是原始的语义正确查询。模糊语言编译器和解释器的最新著作也提到了类似的观察。我们计划调查此问题并开发解决方案以减轻此问题，例如删除在短时间内触发新分支的输入。

## 10 相关工作
**在 DBMS 中检测逻辑和性能错误:**
DBMS 已经针对逻辑和性能缺陷进行了严格的测试。RAGS 通过差异测试来检测 DBMS 中的正确性错误。它在多个 DBMS 中生成并执行查询，结果之间的任何不一致都表明至少一个 DBMS 包含错误。SQLancer 构造查询以从表中获取随机选择的行。如果测试的 DBMS 无法获取该行，则可能包含错误。QTune 是基于深度强化学习模型的数据库调优系统，可以有效地调整数据库配置以获得最佳性能。Apollo 使用差异测试来发现性能错误。它在同一 DBMS 的两个版本中生成并运行查询。如果两次执行所花费的时间明显不同，则该查询将触发性能回归错误。BmPad 在目标 DBMS 中运行预定义的测试套件，并在执行时间超过阈值时报告性能错误。Squirrel 与这些作品的不同之处在于，它专注于检测可能导致严重安全后果的内存损坏错误。

**基于生成的 DBMS 测试:**
基于生成的测试通常用于测试 DBMS。它可以有效地生成语法正确的测试用例，但很少保证语义的正确性。QAGen 表明，确保完美的语义正确性是一个 NP 完全问题。相反，它提供了一种近似的解决方案来提高语义正确性。一些工作减少了 SAT 问题的产生，并使用 SAT 解算器（例如 Alloy）提供了潜在的解决方案。基于世代的模糊器通常需要一些初始数据库的架构才能生成查询。Bikash Chandra 等提出了一种生成初始数据库的方法，该数据库可以覆盖大多数类型的 SQL 查询。SQLsmith 是最新的基于生成的 DBMS 测试器。它从初始数据库收集模式，并生成有限类型的查询（例如 SELECT），以确保数据库不变，这限制了代码覆盖率。相反，Squirrel 生成无上下文的测试用例，并且不依赖于特定的数据库或架构。它从一个空的数据库开始，并在使用它们进行测试之前创建适当的内容。

**基于突变的 DBMS 测试:**
最近，基于突变的模糊器在发现内存错误方面取得了巨大的成功。然而，它们被实现为通用的模糊器，并且不知道输入的结构。尽管它们中的一些采用了诸如污点分析或符号执行之类的高级技术，但它们仍然无法深入测试像 DBMS 这样的程序，这些程序接受具有正确语义的高度结构化的输入。Tim Blazytko 等提出了一种利用类似语法的组合来合成高度结构化的输入的方法，但它在 SQL 中生成的大多数测试用例在语法上仍然不正确。Hardik Bati 等提出通过添加或删除语法组件来变异 SQL 语句。它们可能保留语法正确性，但不能保证语义正确性。最近的工作倾向于提高生成的输入的语义正确性，但由于 SQL 对语义的要求更加严格，这些模糊器在测试 DBMS 方面并未显示出有效性。因此，由这些模糊器生成的大多数测试用例都无法通过语法检查或语义检查，并且没有机会触发深层逻辑，例如优化或执行。Squirrel 通过保留语法的变异和语义指导的实例化克服了这些缺点，并设法检测出深层逻辑背后的错误。

## 11 总结
我们已经提出并实现了 Squirrel 来对数据库管理系统进行模糊测试，以查找与内存相关的错误。我们的系统采用了两种新颖的技术，即保留语法的变异和语义指导的实例化，以帮助生成正确的 SQL 查询。我们在四种流行的 DBMS（SQLite、MySQL、MariaDB 和 PostgreSQL）上评估了 Squirrel，并发现 SQLite 中有51个错误，MySQL 中有7个错误，MariaDB 中有5个错误。Squirrel 在语义正确性方面的改进至少是当前基于突变和基于生成的模糊器的3.4倍，并且触发的代码覆盖率是当前基于突变的模糊器的12倍。结果表明，Squirrel 在测试数据库管理系统方面是有效且高效的。

> **致谢**
我们感谢匿名审稿人的有益反馈。这项工作得到了美国国家科学基金会（NSF）在 CNS-1652790 项下的部分支持，以及海军研究办公室（ONR）在 N00014-16-1-2912、N00014-16-1-2265、N00014-17-1-2894、N00014-17-1-2895 和 N00014-18-1-2662 项下的支持。本材料中表达的任何观点、发现、结论或建议均为作者的观点，不一定反映 NSF 或 ONR 的观点。

## 备注
模糊测试工具通常可以被分为两类。变异测试（Mutation-based）通过改变已有的数据样本生成测试数据。生成测试（Generation-based）则通过对程序输入的建模来生成新的测试数据。
- **P值**: P值是用来判定假设检验结果的一个参数，也可以根据不同的分布使用分布的拒绝域进行比较。P值越小，代表结果越显著。
- **NP-hard**: 指一些很难的非确定性的问题，具体可参考相关文献。
- **论文中的附录** 还对文中的具体算法进行了阐述，鉴于篇幅限制，有兴趣的读者可自行查阅。