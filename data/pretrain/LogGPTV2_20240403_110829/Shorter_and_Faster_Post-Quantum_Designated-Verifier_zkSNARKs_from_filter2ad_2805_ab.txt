Lattices
PV R1CS
Size
216
220
216
216
220
216
220
216
219
216
220
216
220
216
220
Size
CRS
12.4 MB
199 MB
17.3 MB†
—
—
—
—
1.4 GB
11 GB
–
–
191 MB
5.3 GB
104 MB
1.9 GB
Proof
128 B
128 B
640 KB
4.3 MB
14 MB
121 KB
169 KB
178 KB
215 KB
77.5 KB
127 KB
15.2 KB
16.4 KB
19.9 KB
20.8 KB
Setup
5.6 s
72 s
167 s
—
—
—
—
12 s
116 s
–
–
88 s
2240 s
53 s
877 s
Time
Prover Verifier
3.3 ms
5.5 s
79 s
3.4 ms
3.5 ms
235 s
1.3 s
2.5 s
22 s
38 s
380 ms
18 s
304 s
6.3 s
8.3 ms
21 s
9.5 ms
184 s
2.5 ms
0.3 s
4.5 s
4.1 ms
0.69 ms
3.9 s
1.2 ms
68 s
0.37 ms
3.4 s
56 s
0.43 ms
∗As we discuss in Appendix E (Remark E.4), the parameter instantiation proposed in Gennaro et al. [65] only provides 15 bits of provable soundness. If
we use parallel repetition to amplify to 128-bits of soundness, then all of the parameters should be scaled by a factor of 8.5×. In the table, we report the
numbers as they were presented in the original paper. Their work also does not provide measurements for instances with more than 216 gates.
†Gennaro et al. [65] do not report the CRS size for an instance of size 216. We estimate the size by doubling the size of the CRS for an instance of size 215.
‡The “Setup” time and “CRS” size for Fractal refers to the running time of the indexer and the size of the resulting proving state. Our system ran out of
memory when running Fractal on an R1CS instance of size 220. Thus, we report the results for an instance of size 219 instead.
§Performance numbers for ethSTARK are based on verifying a Rescue hash chain [4, 25] (specifically Rescue122). The length of the hash chain is chosen
to match the size of the corresponding R1CS system. Specifically, we use hash chains of length 270 and 4200 to represent R1CS systems with 216
and 220 constraints, respectively (see Section 4.3 for more detail). The ethSTARK implementation [102] does not currently support verifying general
computations.
Table 1: Concrete performance comparison of our zkSNARK to the pairing-based construction of Groth [75] and several recent post-quantum zkSNARKs
with polylogarithmic-size proofs. For each scheme, we report the running time and parameter sizes for an R1CS instance with 216 and 220 constraints.
We measure the running times for an R1CS instance over each scheme’s preferred field. With the exception of the Gennaro et al. [65] construction, all
measurements are taken on the same system (see Section 4.3 for details of our setup). For our scheme, we consider two different parameter settings. The
“Shorter Proofs” instantiation works over the field F𝑝2 where 𝑝 = 213 − 1 and the “Shorter CRS” instantiation works over the field F𝑝2 where 𝑝 = 219 − 1 (see
Table 2 for the lattice parameters in these instantiations). The “PQ” column specifies whether the construction is post-quantum (
), the
“TP” column specifies whether the construction has a transparent setup (
), and the “PV” column specifies whether the scheme
is publicly-verifiable (
) or relies on a trusted setup (
) or pre-quantum (
) or designated-verifier (
).
prover to submit a super-constant number of “bad” proofs to the
verifier. This means that the verifier is able to detect a malicious
prover trying to attack the scheme (this is reminiscent of the
notion of covert security from [8]). Alternatively, these “selective
failure” attacks can be avoided altogether if the verifier does not
reveal whether a proof is valid or not to the prover.
More generally, it is a fascinating question to construct publicly-
verifiable lattice-based zkSNARKs with comparable concrete ef-
ficiency. Existing lattice-based constructions [11, 37] that are
publicly verifiable have an expensive verifier (i.e., the verifier
runs in time linear in the size of the underlying NP relation). We
refer to Section 5 for further comparison with related work.
• Field characteristic. In this work, we consider lattice-based
zkSNARKs for R1CS systems over finite fields of moderate char-
acteristic (i.e., between 12 and 20 bits). Specifically, we consider
quadratic extension fields, which enable a number of concrete
optimizations (see Sections 1.2 and 4.3).
For some applications, it may be helpful to consider R1CS sys-
tems over fields of higher characteristic. For example, validity
of a 32-bit addition gate (on 32-bit inputs) can be expressed as a
single R1CS constraint over any finite field with characteristic
𝑝 > 232. Thus, when verifying computations that make extensive
use of 32-bit or 64-bit integer arithmetic, it can be advantageous
to encode the computation in an R1CS system over a higher char-
acteristic field. Both the pairing-based construction [75] as well
as the hash-based constructions [5, 21, 47, 75] operate over base
fields of high characteristic (i.e., at least 128 bits). The hash-based
constructions [5, 21, 47] also efficiently support R1CS systems
on high-degree extensions of the binary field, or more generally,
any field that supports efficient fast Fourier transforms.
While our lattice-based instantiation can in principle support
fields of higher characteristic, doing so will require using larger
lattice parameters, which in turn, increases the proof size. More-
over, some of our concrete optimizations (e.g., implementing all
arithmetic operations using 128-bit integer arithmetic) can no
longer be applied when the field characteristic increases. We refer
to Section 4.3 and Fig. 2 for more discussion on how the field
characteristic affects the concrete efficiency of our scheme.
1.1 Background
The basis of our work is the compiler of Bitansky et al. [30] (also im-
plicit in the work of Gennaro et al. [64]), and more specifically, the
Session 1C: Zero Knowledge I CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea214vector generalization by Boneh et al. [31]. These works provided
a general template for constructing SNARKs in the preprocessing
model by combining a “linear PCP” with a “linear-only” encryption
scheme. A linear PCP [76] for an NP language L is defined by a lin-
ear oracle 𝝅 : Fℓ → F over a finite field F. On input a statement 𝑥, a
verifier can submit a query matrix Q ∈ Fℓ×𝑘 to the oracle and obtain
the responses a ← QT𝝅 ∈ F𝑘. Based on the responses, the verifier
decides whether to accept or reject. We refer to 𝑘 as the number of
queries and ℓ as the query length of the linear PCP. The linear PCP
is sound if for a false statement 𝑥 ∉ L and any proof vector 𝝅 ∈ Fℓ,
the probability that the verifier accepts is negligible (where the prob-
ability is taken over the choice of Q). Concretely-efficient 4-query
linear PCPs for R1CS can be constructed using the quadratic arith-
metic programs (QAPs) introduced by Gennaro et al. [64]. QAPs
are the basis for the most succinct pairing-based preprocessing
zkSNARKs [20, 30, 64, 75, 87].
To obtain a preprocessing zkSNARK for L from a linear PCP
for L, the Bitansky et al. compiler encrypts the linear PCP queries
(i.e., the entries of Q) using a “linear-only” encryption scheme and
publishes the resulting ciphertexts as part of the common reference
string (CRS). As the name suggests, a linear-only encryption scheme
is an encryption scheme that only supports linear homomorphism
(i.e., it is possible to add ciphertexts, but no other homomorphic
operation on ciphertexts is supported). Given the encrypted queries,
the prover can homomorphically compute the encrypted responses
a = QT𝝅. Here, the linear-only property restricts the prover to lin-
ear strategies and by semantic security, the prover’s choice of linear
combination is essentially independent of the linear PCP queries.
This binds the prover to respect the constraints of the linear PCP
model. To verify the proof, the verifier decrypts the encrypted re-
sponses and evaluates the linear PCP verification procedure. This
yields a designated-verifier preprocessing SNARK. For zero knowl-
edge, it suffices that the linear PCP be honest-verifier zero knowledge
and the linear-only encryption scheme be “re-randomizable” (i.e.,
ciphertexts output by the homomorphic evaluation are computa-
tionally indistinguishable from fresh ciphertexts).
Lattice-based instantiations of Bitansky et al. Gennaro et al. [65],
following Boneh et al. [31, 32], introduced candidate linear-only
encryption schemes based on lattices. In these works, the under-
lying linear-only encryption scheme is adapted from basic Regev
encryption [91]. For our purposes, a Regev-based encryption of a
value 𝑥 ∈ Z𝑝 is a pair (a, c) where a ∈ Z𝑛
𝑞 and c = sTa+ 𝑝𝑒 +𝑥 ∈ Z𝑞,
where s ∈ Z𝑛
𝑞 is the secret key, 𝑒 ∈ Z𝑞 is an error term, and 𝑛, 𝑞
are lattice parameters. Observe that this scheme is linearly homo-
morphic: if (a1, c1) and (a2, c2) encrypt values 𝑥1, 𝑥2, respectively,
then (a1 + a2, c1 + c2) encrypts the value 𝑥1 + 𝑥2 mod 𝑝, albeit with
slightly larger error. As long as the error magnitude in the final
ciphertext is less than 𝑞/(2𝑝), decryption succeeds.
Gennaro et al. [65] provided the first lattice-based implemen-
tation of the Bitansky et al. compiler using Regev encryption.1
Compared to the best pairing-based constructions that followed
a similar methodology [75], the lattice-based implementation is
significantly less efficient. For an R1CS instance of size 216, the
1Gennaro et al. used square span programs [53] instead of QAPs as the underlying
linear PCP, but this distinction is not important for the main discussion here.
proof size is 640 KB, over 5000× larger than the pairing-based con-
struction of Groth [75]; similarly, the prover time for a similar-sized
instance is roughly 40× slower than the pairing-based analog. In
fact, as we discuss in Appendix E, because Gennaro et al. consider
linear PCPs over a small field F (log |F| = 32), the specific parame-
ter instantiation they consider provides at most 15 bits of provable
soundness. Working over a larger field or using parallel repetition
for soundness amplification would incur even more overhead.
Lattice parameter sizes. The main obstacle to the concrete ef-
ficiency of lattice-based zkSNARKs following the Bitansky et al.
compiler [30] is the size of the lattice parameters. The length of a
QAP for an R1CS instance with 𝑁 constraints over a finite field F is
𝑂(𝑁), and the soundness error is 𝑂(𝑁/|F|). This means we need
to work over a field F where |F| > 𝑁 , and we need a linear-only
encryption scheme over F that supports 𝑂(𝑁) homomorphic opera-
tions. In the Gennaro et al. construction [65], they consider a prime
field F𝑝 where 𝑝 > 𝑁 . For correctness then, the modulus 𝑞 for a
Regev-based encoding must satisfy 𝑞 > 2𝑝2𝑁 . Zero knowledge
adds a further multiplicative factor of 2𝜅 where 𝜅 is a statistical
security parameter.
To achieve 128 bits of soundness, one approach is to set 𝑝 >
2128𝑁 . If we take 𝑞 ≈ 2300 (and a typical error distribution), then