In most kernels, there exist a special type of structure which contains a length ﬁekld controlling 
the size of a kernel buﬀer. This type of structure is really useful when there are channels to leak 
the content in the kernel buﬀer to the userland. For example, copy_to_user  is one of the leaking 
channels in Linux kernel. When copy_to_user  is invoked, if the size  parameter is propagated 
from the length ﬁeld and the src  parameter is the address of a kernel buﬀer, the content of the 
kernel buﬀer can be read in the userland. We call this type of structures as leakable elastic 
structure . 
Leakable elastic structures can be used for overreading through enlarging its length ﬁeld using 
the vulnerability. In this challenge, we already have the primitive overwriting the adjacent data, 
what we need to do is to ﬁnd a leakable elastic structure  , put it after the vulnerable object, 
overwrite the length ﬁeld with a large value, and ﬁnally leak the kernel information through the 
channel. In this challenge, we use the leakable elastic structure user_key_payload  to leak kernel 
base address. user_key_payload  is very powerful because it can be allocated in many general 
caches. Its ﬂexibility allows us to spray it in diﬀerent caches to cater to diﬀerent vulnerabilities. 
Please refer to here to see our exploit utilizing struct user_key_payload  to bypass KASLR.
Regarding this type of magic object, there is more to explore. (1) How many leakable elastic 
structures are there in diﬀerent kernels? (2) Is this leaking technique general? (3) Do we need 
mitigation mechanism to prevent such leaking? (4) etc. To answer these questions, we researched 
on this leaking technique and published the results in our paper.
Crypto
VSS
I found an interesting threshold scheme called Visual Threshold Scheme from a cryptography 
textbook and then implemented it in Python with the builtin random module which is 
implemented using MT19937. There are already several tools to recover the most likely state of 
the prng with 624 32-bit integers known and predict using that state, e.g. randcrack. In this 
challenge, we can use the information that the border of the qrcode is white to obtain the ﬁrst 
624 32-bit integers generated by the prng. 
My Solution:
BabyProof
Zero-knowledge proof
Zero-knowledge proof is a hot topic in the ﬁeld of Cryptography, and has many applications in 
Blockchain. There are, however, few CTF chanlleges on this topic. So, I made this challenge for 
fun, though the key point to solve the challenge has no relation with zero-knowledge proof.
Actually, the construction of the challenge is similar to that of the Schnorr Signature Scheme, 
which uses a technique, known as Fiat–Shamir heuristic, to convert an interactive proof of 
knowledge into a non-interactive one by applying a cryptographic hash function as the random 
oracle.
The signature scheme works in that the randomly (uniformly) selected scalar r  masks the 
multiplication of h  and a  over the prime-order group. Therefore, the veriﬁer acquires zero 
knowledge about the secret key a , while can be convinced that the prover really knows a .
HNP
from PIL import Image
from randcrack import RandCrack
import random
share = Image.open('share2.png')
width = share.size[0]//2
res = Image.new('L', (width, width))
bits = ''
for idx in range(width*width-624*32, width*width):
    i, j = idx//width, idx % width
    if share.getpixel((2*j, 2*i)) == 255:
        bits += '0'
    else:
        bits += '1'
rc = RandCrack()
for i in range(len(bits), 0, -32):
    rc.submit(int(bits[i-32:i], 2))
flipped_coins = [int(bit)
                 for bit in bin(rc.predict_getrandbits(width*width-624*32))
[2:].zfill(width*width-624*32)] + list(map(int, bits))
data = []
for idx in range(width*width):
    i, j = idx//width, idx % width
    if share.getpixel((2*j, 2*i)) == 255:
        data.append(0 if flipped_coins[idx] else 255)
    else:
        data.append(255 if flipped_coins[idx] else 0)
res.putdata(data)
res.save('ans.png')
However, in this task, we can see that the distribution of the secret selected scalar $v$ over the 
prime-order group $\mathbb{Z}_q^*$ is not uniform:
It always falls in the interval $[1, x]$, where $x$ is a 247-bit integer and the prime $q$ is about 
256-bit, thus making $v$ relatively small compared to $q$. And this leads to a well-known 
problem in Cryptanalysis -- the hidden number problem.
From the instance, we can continuously get some data that satisfying
where only $v_i$ and $x$ are unknown.
By some transformation, it can be rewritten as
Then, we can construct the lattice
It is easy to show that the linear combination $[-k_1, -k_2, \cdots, -k_n, x, 1]$ of the lattice basis 
can result in a quite short lattice point $[v_1, v_2, \cdots, v_n, x, 2^{248}]$. By applying lattice 
reduction algorithm such as LLL to $L$, we can easily ﬁnd this short lattice point, from which $x$ 
is recovered.
Code
The script to gather suﬃcient data (stored in the ﬁle data ):
v = getRandomRange(1, x)
import json
from hashlib import sha256
from string import ascii_letters, digits
from pwn import *
from pwnlib.util.iters import bruteforce
def proof_of_work(r):
    r.recvuntil(b"XXXX+")
    suffix = r.recv(16).decode()
    r.recvuntil(b"== ")
    _hexdigest = r.recvline().strip().decode()
    print(f"suffix: {suffix}\nhexdigest: {_hexdigest}")
    prefix = bruteforce(
        lambda x: sha256((x+suffix).encode()).hexdigest() == _hexdigest,
        ascii_letters + digits,
        4,
        "fixed"
And the script to solve the HNP:
    )
    print(prefix)
    r.sendline(prefix)
def main():
    # Get data
    qs = []
    cs = []
    rs = []
    for i in range(50):
        print(i)
        conn = remote("101.32.203.233", 23333)
        # context.log_level = "debug"
        proof_of_work(conn)
        conn.recvline_endswith(b"I really have knowledge of x.")
        g, y, _, q, t, r = conn.recvall().decode().strip().split("\n")[-6:]
        gyt = b"".join(
            map(
                lambda x: int.to_bytes(len(str(x)), 4, 'big') + str(x).encode(),
                (g, y, t)
            ))
        c = int.from_bytes(sha256(gyt).digest(), 'big')
        qs.append(int(q))
        cs.append(int(c))
        rs.append(int(r))
        print(q, c, r)
        conn.close()
    json.dump([qs, cs, rs], open("data", "w"))
if __name__ == "__main__":
    main()
# SageMath 9.1
import json
from Crypto.Util.number import long_to_bytes
qs, cs, rs = json.load(open("data", "r"))
# HNP
N = 50
M = matrix(ZZ, N+2, N+2)
# q1
#    q2
#       ...
#           qn
# c1 c2 ... cn  1
# r1 r2 ... rn    2^248
Curve
This is a challenge about generating speciﬁc elliptic curves. Apparently I f-ed up with parameter 
checking so there's some unintended solutions, I guess I'll spend more time on challenge 
proofreading next time.
for i in range(N):
    M[i,i]  = qs[i] # qi
    M[-2,i] = cs[i] # ci
    M[-1,i] = rs[i] # ri
M[-2,-2] = 1
M[-1,-1] = 2^248
M_lll = M.LLL()
x = M_lll[0,-2]
print(long_to_bytes(x))
# b'n1ctf{S0me_kn0wl3dg3_is_leak3d}'
#!/usr/bin/env sage
import signal, hashlib, string, random, os 
os.chdir(os.path.dirname(os.path.abspath(__file__)))
FLAG = open("./flag.txt", 'r').read()
ROUNDS = 30
def PoW():
  s = ''.join([random.choice(string.ascii_letters + string.digits) for _ in 
range(20)])
  h = hashlib.sha256(s.encode()).hexdigest()
  prefix = s[:16]
  print("sha256(%s+XXXX) == %s" % (prefix, h))
  c = input("Give me XXXX: ")
  if hashlib.sha256((prefix + c).encode()).hexdigest() == h:
    return True 
  return False
def chall():
  p = ZZ(input("P: "))  # of course we are using sage >= 9
  a = ZZ(input("A: "))
  b = ZZ(input("B: "))
  if not is_prime(p) or p.nbits() < 512:
    print("No bad parameters.")
    return
  E = EllipticCurve(GF(p), [a, b])
  if E.is_supersingular():
    print("No this is not good enough.")
    return
  q = E.order()
  x1 = ZZ(input("X1: "))
  y1 = ZZ(input("Y1: "))
  x2 = ZZ(input("X2: "))
The intended solution: Let's ﬁrst look at the latter part of the challenge source, there are 30 
rounds that checks if you input the correct guess. If you know Decisional Diﬃe-Hellman 
assumption, you may ﬁnd it somewhat similar, instead using a single generator $g$, the check 
uses two user-provided points $g_1, g_2$. 
From the wiki we can see some interesting quotes: "The DDH assumption does not hold on 
elliptic curves over $GF(p)$ with small embedding degree ... because the Weil pairing or Tate 
pairing can be used to solve the problem directly ...". Basically it means we can exploit bilinearity 
(i.e., $e_n([a]P, [b]Q)=e_n(P,Q)^{ab}, \forall a,b \in \mathbb{Z}$.) of bilinear pairings to solve DDH 
problem.
But how can Weil pairing help us solve this challenge? One important property of Weil pairing is 
$e_n(P,P)=1, \forall P \in E[n]$. But under the restrictions ($p$ being prime) given by the challenge, 
if the group of points of $E$ is cyclic, we can never distinguish the pairs given by the server. So we 
need to generate some special elliptic curves over $GF(p)$ where $p$ is a prime, has a small 
embedding degree and also being non-cyclic.
  y2 = ZZ(input("Y2: "))
  G1 = E((x1, y1))
  G2 = E((x2, y2))
  for _ in range(ROUNDS):
    a0 = randint(1, q - 1)
    a1 = randint(1, q - 1)
    c = -1
    while c == -1 or c == a0 * a1:
      c = randint(1, q - 1)
    g0, g1 = G1 * a0, G2 * a1 
    c0, c1 = G1 * (a0 * a1), G1 * c
    b = randint(0, 1)
    if b == 0:
      print(g0, g1, c0)
    else:
      print(g0, g1, c1)
    choice = ZZ(input("Choice: "))
    if choice != b:
      print("Wrong choice.")
      return
  print(f"Thank you! Here's your reward: {FLAG}")
  return 
if __name__ == '__main__':
  if not PoW():
    print("Invalid PoW.")
    exit()
  signal.alarm(90)
  try:
    chall()
  except:
    print("oof...")
    exit()
About generating the curve, I used Complex Multiplication method. I've also used the algorithm 
from this paper to generate valid parameters. You can check out my solution here.
The unintended solutions: Though I'm not aware of all the unintended solutions, I think basically 
you can construct some anomalous curves where ECDLP can be solved eﬃciently. You can check 
out the writeup by @rkm0959.
Easy RSA?
To accomplish this challenge, we need to solve the following two problems:
1. Factor N which generated using vulnerable random prime generators
2. Solve LWE with the "linear" array
Factor N
Let v be an unknown number, the above code can be represented by the following formula
$$a * p = v_4 * x^4 + v_3 * x^3 + v_2 * x^2 + v_1 * x + v_0$$
Thus, N can be expressed as
$$a * b * N =  w_8x^8 + w_7x^7 + w_6x^6 + w_5x^5 + w_4x^4 + w_3x^3 + w_2x^2 + w_1x + w_0$$
The degree of the above polynomial is only 8, we can use a lattice to help us.
Consider the following lattice
$$\begin{bmatrix} 1 & 0 & 0 & \ldots & 0 & x^{2k} \ 0 & 1 & 0 & \ldots & 0 & x^{2k-1} \ \vdots & 
\vdots & \vdots & \ddots & \vdots & \vdots \ 0 & 0 & 0 & \ldots & 1 & x \ 0 & 0 & 0 & \ldots & 0 & -
N \end{bmatrix}$$
Using LLL algorithm, we can get a set of vector $v = (w{2k}, w{2k-1},\ldots,w_1,-w_0)$
Now factor degree 8 polynomial into two degree 4 polynomials
$$a * p = 3053645990x^4 + 3025986779x^3 + 2956649421x^2 + 3181401791x + 4085160459 \ 
b * q = 2187594805x^4 + 2330453070x^3 + 2454571743x^2 + 2172951063x + 3997404950$$
Substituting $x = 3^{66}$ into the above formula, and then using GCD, we can get p and q.
solve LWE
Split the matrix by rows, and a single row can be expressed by the following formula
$$a_i * secret + b = linear \pmod{upper} \ \Downarrow \ a_i * secret + k * upper = linear - b$$
Since there are 127 such formulas, a new matrix can be constructed
What we need to do is to ﬁnd a vector that approximates b on a lattice similar to the matrix on 
the left, that is, CVP.
def get_random_prime():
    total = 0
    for i in range(5):
        total += mark**i * getRandomNBitInteger(32)
    fac = str(factor(total)).split(" * ")
    return int(fac[-1])
code
solve RSA
solve LWE
C = 1