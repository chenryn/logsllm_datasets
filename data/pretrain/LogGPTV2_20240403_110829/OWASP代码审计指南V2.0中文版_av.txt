的建模。它还允许管理员细化和重新审计角色权限，同时确保每个角色都拥有它应该拥有的
权限(不多也不少)。 
因此，给用户分配角色应该减少人为错误的机会。许多 web 框架允许将角色分配给登
录的用户，并且自定义代码可以审计会话信息，以基于当前用户角色来授权功能。 
3.7.2 描述 
在页面/视图级别限制用户似乎是合理的，因为他们不能在应用程序中执行任何操作。
但是，如果不是请求页面/视图，而是未经授权的用户试图请求内部操作，如添加/修改应用
程序中的任何数据，该怎么办？这种情况下，操作将被处理，但结果视图会拒绝给用户。这
里的缺陷在于应用程序中只有基于视图的访问控制。许多业务逻辑处理(对于请求)是在“视
图”执行之前完成的。因此，处理任何操作的请求都可以在没有授权的情况下成功处理。 
在一个基于 MVC 的系统中，这个问题显示在下面的图中，其中验证审计出现在视图操
作中。 
203 
 图: MVC 访问控制 
在这个例子中，控制器 servlet(中央处理实体)和动作类都没有任何访问控制审计。如
果用户请求一个内部操作，如添加用户详细信息，而不进行身份验证，它将被正常处理，但
唯一的区别是，用户将显示一个错误页面，因为结果视图将不允许用户使用。在 ASP.NET
的应用程序中也观察到类似的缺陷，开发人员倾向于混合处理 POSTBACK 和身份验证审计
的代码。通常可以观察到，ASP.NET 页面中的身份验证审计不适用于 POSTBACK，如下所
示。在这里，如果攻击者试图在没有验证的情况下访问页面，将呈现一个错误页面。相反，
如果攻击者试图在没有身份验证的情况下直接发送内部 POSTBACK，就会成功。 
配置文件中可能存在未使用或未声明的操作或功能。这种未在应用程序中作为有效功能
公开(或测试)的配置会扩大攻击面，并增加应用程序的风险。下面的示例中显示了配置文件
中存在的一个未使用的配置，其中文件末尾的“test”是测试周期遗留下来的，将向外部用
户公开。很可能不会在每个版本中都审计此操作，并且可能会暴露漏洞。 
204 
示例： 
/InsecureDesign/action/AddUserDetails 
Action.UserAction 
JSP_WithDesign/Success.jsp 
/InsecureDesign/action/ChangePassword 
Action.ChangePasswordAction 
JSP_WithDesign/Success.jsp 
/InsecureDesign/action/test 
Action.TestAction 
JSP_WithDesign/Success.jsp 
当今大多数设计框架中的另一个流行特性是数据绑定，其中，请求参数直接绑定到相应
业务/命令对象的变量。这里的绑定是指这样的类的实例变量根据它们的名字自动用请求参
数值初始化。这种设计的问题是业务对象可能有不依赖于请求参数的变量。这些变量可能是
关键变量，如价格、最高限价、角色等。具有静态值或者依赖于某些服务器端处理逻辑。这
种情况下的一个威胁是攻击者可能会在请求中提供额外的参数，并试图为业务对象类的未公
开变量绑定值。在这种情况下，攻击者可以在请求中发送一个附加的“价格”参数，该参数
与业务对象中未公开的变量“价格”绑定，从而操纵业务逻辑。 
3.7.3 审计什么 
在处理任何业务逻辑之前，以及在 ASP.NET 应用程序独立于 POSTBACK 之前，必须
205 
进行所有验证审计。在处理任何请求之前，必须进行身份验证审计等安全控制。 
当在 MVC 3 及以上版本中实现授权时，建议使用过滤器.NET MVC 3 在 global.asax
中引入了一个名为 RegisterGlobalFilters 的方法，可以用来默认拒绝访问应用程序中的网
址。 
示例： 
public static void RegisterGlobalFilters(GlobalFilterCollection filters){ 
filters.Add(new HandleErrorAttribute()); 
filters.Add(new System.Web.Mvc.AuthorizeAttribute()); 
} 
建议在审计 MVC3/4 .NET 的时候来看看授权是如何实现的。上面那行 filters.Add(new 
System.Web.Mvc.AuthorizeAttribute())；"默认拒绝访问任何没有有效会话的请求。如果
实现了这一点，我们可能需要提供对某些页面的未授权访问，如注册页面、公共欢迎页面或
登录页面。 
指令“AllowAnonymous”用于提供对不需要有效会话的公共页面的访问。代码如下
所示: 
示例： 
[AllowAnonymous] 
public ActionResult LogMeIn(string returnUrl) 
审计授权代码时，可以审计以下注意事项: 
⚫ 
每个入口点都应得到授权。每个功能都要授权。 
206 
⚫ 
授权审计应该是高效的，并在一个中心代码库中实现，以便能够一致地应用。 
⚫ 
如果授权失败，应该返回一个未经授权的页面。 
⚫ 
使用 RBAC 时，应用程序必须有某种方式来报告系统当前提供的用户及其相关角
色。这允许企业定期审核用户对系统的访问，并确保其准确性。例如，如果某个用
户在系统上被设置为管理员，那么该用户将工作更改到另一个部门时，管理员角色
可能需要回收。 
⚫ 
应该有一个简单的方法来更改或删除用户的角色(在 RBAC 系统中)。添加、修改用
户或从角色中删除用户需要记录在审计日志中。 
⚫ 
对于风险较高的角色，这些角色的添加、修改和删除应涉及多级授权(例如，
maker/checker)，这可以在应用程序本身中进行跟踪，或者通过某个集中式角色
应用程序进行跟踪。系统控制角色的功能和代码都应该是审计范围的一部分。 
⚫ 
在设计层面，尝试保持简单的角色范围。具有多个权限级别/角色的应用程序通常
会增加权限集冲突的可能性，从而导致意外的权限。 
⚫ 
在具有胖客户端的应用架构中(即，运行在个人电脑上的移动应用程序或二进制文
件)不会试图在客户端代码中执行任何授权，因为攻击者可能会绕过这一点。在基
于浏览器的应用程序中，不要在 JavaScript 中执行任何授权决定。 
⚫ 
绝不要将授权决策建立在不可信数据的基础上。例如，不要使用客户端请求中的标
头或隐藏字段来确定用户将拥有的授权级别，这也可能被攻击者操纵。 
⚫ 
遵循“完全调解”的原则，即在职能的每个阶段审计授权。例如，如果一个应用程
序 有 四 个 页 面 需要 浏 览才 能 购 买 一 个 项目 (browse.html ， browse.html，
207 
inputpay-ment.html，makePayment.html)，那么在每个页面审计用户授权，
并在页面内进行分级，而不是只在第一页执行审计。 
⚫ 
默认情况下，拒绝访问任何页面，然后使用授权逻辑根据角色/ ACL 规则授予访问
权限。 
⚫ 
授权数据、数据库或会话存放在哪里？ 
⚫ 
从文件中删除所有冗余/测试/未公开的业务逻辑配置。 
⚫ 
业务/表单/命令对象必须只有那些依赖于用户输入的实例变量。 
3.8 A8 跨站点请求伪造（CSRF） 
CSRF 攻击诱导已登录的受害者通过浏览器向易受攻击的网络应用程序发送伪造的
HTTP 请求，请求会携带包括受害者的会话 cookie 和任何其他自动包含的身份验证信息。
这会让后台应用程序认为是来自受害者的合法请求。 
3.8.1 描述 
CSRF 是一种攻击，它迫使最终用户在他们当前经过身份验证的 web 应用程序上执行
不需要的操作。在社会工程的帮助下(比如通过电子邮件/聊天发送链接)，攻击者可能会迫
使网络应用程序的用户执行非自愿选择的操作。在普通特权用户的情况下，成功的 CSRF 利
用可能会危及用户数据和受保护的功能。如果目标用户是管理员帐户，这可能会危及整个
web 应用程序。 
CSRF 与 XSS(跨站点脚本)不同，后者迫使可信网站向毫无防备的受害者提供恶意内容。
如果攻击者知道目标是通过基于网络的系统验证的，则跨站点请求伪造(CSRF，也称为
208 
CSURF 或混乱代理)攻击被认为是有用的。只有当目标登录到系统中时，它们才起作用，因
此攻击范围很小。同时需要存在其他逻辑弱点，例如用户不需要交易授权。实际上，攻击者
利用 CSRF 攻击使目标系统执行一项功能(资金转移、表单提交等..)。在目标用户不知情的
情况下通过目标的浏览器，主要目标是利用网络应用程序的“易用”特性(一键购买)。 
基于受害者的角色，CSRF 成功开发的影响差异很大。当以普通用户为目标时，成功的
CSRF 攻击会危及最终用户数据及其相关功能。如果目标终端用户是管理员帐户，CSRF 攻
击可能会危及整个网络应用程序。更容易受到攻击的网站是社区网站(社交网络、电子邮件)
或拥有高美元价值账户的网站(银行、股票经纪公司、账单支付服务)。即使用户使用强加密
(HTTPS)登录网站，也可能发生这种攻击。利用社交工程，攻击者将在电子邮件或网站中嵌
入恶意的超文本标记语言或超文本标记语言代码，以请求特定的“任务网址”。然后，任务
在用户不知情的情况下执行，或者直接执行，或者利用跨站点脚本漏洞(例如:Samy 
MySpace 蠕虫)执行。 
3.8.1.1 它们是如何工作的 
CSRF 攻击通过从经过身份验证的用户的浏览器向应用程序发送恶意的 HTTP 请求来工
作，利用应用程序在没有目标用户授权的情况下提交事务。只要用户经过身份验证，并且用
户的浏览器向目标应用程序发送了一个有意义的 HTTP 请求，应用程序就不知道该请求的来
源是有效的交易还是用户点击的链接(也就是说，来自电子邮件还是浏览器点击)。与此同时，
用户向应用程序进行了身份验证，因为来自用户浏览器的请求将自动包含“Cookie”头，
这是验证的基础。所以，攻击者让受害者执行他们不想做的动作，例如购买物品。下面示例
展示了一个向票贩子发出的购买多张票的请求。 
示例： 
209 
POST http://TicketMeister.com/Buy_ticket.htm HTTP/1.1 
Host: ticketmeister 
User-Agent: Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O;) Firefox/1.4.1 
Cookie: JSPSESSIONID=34JHURHD894LOP04957HR49I3JE383940123K 
ticketId=ATHX1138&to=PO BOX 1198 DUBLIN 2&amount=10&date=11042008 
供应商的响应是确认购票： 
HTTP/1.0 200 OK 
Date: Fri, 02 May 2008 10:01:20 GMT 
Server: IBM_HTTP_Server 
Content-Type: text/xml;charset=ISO-8859-1 
Content-Language: en-US 
X-Cache: MISS from app-proxy-2.proxy.ie 
Connection: close 
 Ticket Purchased, Thank you for your custom. 
3.8.1.2 审计什么 
这个问题很容易检测，但是在应用程序的功能周围可能有补偿控件，这可能会提醒用户
CSRF 攻击风险。只要应用程序接受一个格式良好的 HTTP 请求，并且该请求符合应用程序
的一些业务逻辑，CSRF 就会产生。 
通过审计页面呈现，我们需要查看用户浏览器中的应用程序呈现的链接是否附加了任何
唯一的标识符。如果没有与每个 HTTP 请求相关的唯一标识符来将一个 HTTP 请求绑定到
用户，我们就容易受到攻击。会话标识是不够的，因为如果用户点击欺诈链接，会话标识将
自动发送，因为用户已经通过身份验证。 
210 
3.8.1.3 不起作用的预防措施 
表 21 列出了攻击者可以绕过的尝试性 CSRF 防范技术的示例，这些措施不应用于敏感
应用程序，并且不能通过代码审计。 
表:针对 CSRF 攻击的不成功对策 
措施 
描述 
使用秘密的 Cookie 
请记住，所有 cookie，即使是秘密的 cookie，都将
随每个请求一起提交。 无论最终用户是否被欺骗提
交请求，都将提交所有身份验证令牌。 此外，会话
标识符仅由应用程序容器使用，以将请求与特定的会
话对象相关联。 会话标识符不会验证最终用户是否
打算提交请求。 
只使用 POST 请求 
将应用程序开发为仅接受 POST 请求以执行业务逻
辑，这样的误解是认为攻击者无法构建恶意链接，因
此无法执行 CSRF 攻击。 不幸的是，这种逻辑是不正
确的。 攻击者可以通过多种方法诱骗受害者提交恶
意攻击。伪造的 POST 请求，例如攻击者网站中托管
的带有隐藏值的简单表单。 此表单可以由 JavaScript
自动触发，也可以由认为该表单还会执行其他操作的
受害人触发。 
211 
将交易拆分为多步 
多步骤交易不足以防止 CSRF。 只要攻击者可以预测
或推断完成的交易的每一步，那么 CSRF 就是可能的。 
URL 重写 
这可能被视为一种有用的 CSRF 预防技术，因为攻击
者无法猜测受害者的会话 ID。 但是，用户的凭据会
面临泄露的风险（日志或者历史记录中）。 
密码、转移资金、购买，应用程序可能不会简单地执行请求，而是应该用另一个用户密
码请求或带外(即，双因素)验证项目。 
3.8.2 预防 CSRF 
审计请求是否有一个有效的会话 cookie 是不够的，应用程序需要有一个与发送给应用
程序的每个 HTTP 请求相关联的唯一标识符。CSRF 请求(来自攻击者的电子邮件)将没有这
个有效的唯一标识符。CSRF 请求之所以没有这个唯一的请求标识符，是因为这个唯一的标