变量。
5.7.3 重定向标准错误
为了重定向标准错误，可以指定文件描述符 2。让我们先来看一个例子，因为举例子往往
会让人更容易明白。在这个例子中，g r e p命令在文件m i s s i l e s中搜索t r i d e n t字符串：
g r e p命令没有找到该文件，缺省地向终端输出了一个错误信息。现在让我们把错误重定
向到文件/ d e v / n u l l中(实际就上是系统的垃圾箱)：
$ grep "trident" missiles 2>/dev/null
这样所有的错误输出都输送到了/ d e v / n u l l，不再出现在屏幕上。
如果你在对更重要的文件进行操作，可能会希望保存相应的错误。下面就是一个这样的
例子，这一次错误被保存到g r e p . e r r文件中：
加入java编程群：524621833
43
第5章 s h e l l输入与输出
下载
还可以把错误追加到一个文件中。在使用一组命令完成同一个任务时，这种方法非常有
用。在下面的例子中，两个g r e p命令把错误都输出到同一个文件中；由于我们使用了 > >符号
进行追加，后面一个命令的错误(如果有的话)不会覆盖前一个命令的错误。
5.8 结合使用标准输出和标准错误
一个快速发现错误的方法就是，先将输出重定向到一个文件中，然后再把标准错误重定
向到另外一个文件中。下面给出一个例子：
我有两个审计文件，其中一个的确存在，而且包含一些信息，而另一个由于某种原因已
经不存在了(但我不知道)。我想把这两个文件合并到a c c o u n t s . o u t文件中。
$ cat account_qtr.doc account_end.doc 1>accounts.out 2>accounts.err
现在如果出现了错误，相应的错误将会保存在a c c o u n t s . e r r文件中。
我事先并不知道是否存在a c c o u n t _ e n d . d o c文件，使用上面的方法能够快速发现其中的错
误。
5.9 合并标准输出和标准错误
在合并标准输出和标准错误的时候，切记 s h e l l是从左至右分析相应的命令的。下面给出
一个例子：
$ cleanup >cleanup.out 2>&1
在上面的例子中，我们将c l e a n u p脚本的输出重定向到c l e a n u p . o u t文件中，而且其错误也
被重定向到相同的文件中。
$ grep "standard"* > grep.out 2>&1
在上面的例子中，g r e p命令的标准输出和标准错误都被重定向到 g r e p . o u t文件中。你在使
用前面提到的“此处”文挡时，有可能需要把所有的输出都保存到一个文件中，这样万一出
现了错误，就能够被记录下来。通过使用2 > & 1就可以做到这一点，下面给出一个例子：
上面的例子演示了如何把所有的输出捕捉到一个文件中。在使用 c a t命令的时候，这可能
加入java编程群：524621833
44
第一部分 shell
下载
没什么用处，不过如果你使用“此处”文挡连接一个数据库管理系统 (例如使用i s q l连接
s y b a s e )或使用f t p，这一点就变得非常重要了，因为这样就可以捕捉到所有的错误，以免这些
错误在屏幕上一闪而过，特别是在你不在的时候。
5.10 exec
e x e c命令可以用来替代当前s h e l l；换句话说，并没有启动子s h e l l。使用这一命令时任何现
有环境都将会被清除，并重新启动一个s h e l l。它的一般形式为：
exec command
其中的c o m m a n d通常是一个s h e l l脚本。
我所能够想像得出的描述e x e c命令最贴切的说法就是：它践踏了你当前的s h e l l。
当这个脚本结束时，相应的会话可能就结束了。 e x e c命令的一个常见用法就是在用户
的. p r o f i l e最后执行时，用它来执行一些用于增强安全性的脚本。如果用户的输入无效，该
s h e l l将被关闭，然后重新回到登录提示符。e x e c还常常被用来通过文件描述符打开文件。
记住，e x e c在对文件描述符进行操作的时候（也只有在这时），它不会覆盖你当前的
s h e l l。
5.11 使用文件描述符
可以使用e x e c命令通过文件描述符打开和关闭文件。在下面的例子中，我选用了文件描
述符4，实际上我可以在4到9之间任意选择一个数字。下面的脚本只是从 s t o c k . t x t文件中读了
两行，然后把这两行回显出来。
该脚本的第一行把文件描述符 4指定为标准输入，然后打开 s t o c k . t x t文件。接下来两行的
作用是读入了两行文本。接着，作为标准输入的文件描述符 4被关闭。最后，l i n e 1和l i n e 2两个
变量所含有的内容被回显到屏幕上。
下面是这个小小的股票文件s t o c k . t x t的内容：
下面是该脚本的运行结果：
上面是一个关于文件描述符应用的简单例子。它看起来没有什么用处。在以后讲解循环
的时候，将会给出一个用文件描述符代替c p命令拷贝文本文件的例子。
加入java编程群：524621833
45
第5章 s h e l l输入与输出
下载
5.12 小结
本书通篇可见重定向的应用，因为它是 s h e l l中的一个重要部分。通过重定向，可以指定
命令的输入；如果有错误的话，可以用一个单独的文件把它们记录下来，这样就可以方便快
捷地查找问题。
这里没有涉及的就是文件描述符的应用( 3～9 )。要想应用这些文件描述符，就一定会涉及
循环方法，在后面讲到循环方法的时候，我们会再次回过头来讲述有关文件描述符的问题。
加入java编程群：524621833
下载
第6章 命令执行顺序
在执行某个命令的时候，有时需要依赖于前一个命令是否执行成功。例如，假设你希望
将一个目录中的文件全部拷贝到另外一个目录中后，然后删除源目录中的全部文件。在删除
之前，你希望能够确信拷贝成功，否则就有可能丢失所有的文件。
在本章中，我们将讨论：
• 命令执行控制。
• 命令组合。
如果希望在成功地执行一个命令之后再执行另一个命令，或者在一个命令失败后再执行
另一个命令，& &和| |可以完成这样的功能。相应的命令可以是系统命令或 s h e l l脚本。
S h e l l还提供了在当前s h e l l或子s h e l l中执行一组命令的方法，即使用（）和{ }。
6.1 使用&&
使用& &的一般形式为：
命令1 && 命令2
这种命令执行方式相当地直接。& &左边的命令（命令1）返回真(即返回0，成功被执行）
后，& &右边的命令（命令2）才能够被执行；换句话说，“如果这个命令执行成功& &那么执
行这个命令”。
这里有一个使用& &的简单例子：
在上面的例子中，& &前面的拷贝命令执行成功，所以 & &后面的命令（e c h o命令）被执
行。
再看一个更为实用的例子：
$ mv /apps/bin /apps/dev/bin && rm -r /apps/bin
在上面的例子中，/ a p p s / b i n目录将会被移到/ a p p s / d e v / b i n目录下，如果它没有被成功执行，
就不会删除/ a p p s / b i n目录。
在下面的例子中，文件q u a r t e r _ e n d . t x t首先将被排序并输出到文件q u a r t e r. s o r t e d中，只有
这一命令执行成功之后，文件q u a r t e r. s o r t e d才会被打印出来：
$ sort quarter_end.txt > quarter.sorted && lp quarter.sorted
6.2 使用||
使用| |的一般形式为：
命令1 || 命令2
加入java编程群：524621833
47
第6章 命令执行顺序
下载
| |的作用有一些不同。如果 | |左边的命令（命令1）未执行成功，那么就执行 | |右边的命令
（命令2）；或者换句话说，“如果这个命令执行失败了 || 那么就执行这个命令”。
这里有一个使用| |的简单例子：
在上面的例子中，拷贝命令没有能够被成功执行，因此 | |后面的命令被执行。
这里有一个更为实用的例子。我希望从一个审计文件中抽取第 1个和第5个域，并将其输
出到一个临时文件中，如果这一操作未成功，我希望能够收到一个相应邮件：
在这里不只可以使用系统命令；这里我们首先对 m o n t h _ e n d . t x t文件执行了一个名为c o m e t
的s h e l l脚本，如果该脚本未执行成功，该s h e l l将结束。
$ comet month_end.txt || exit
6.3 用（）和{ }将命令结合在一起
如果希望把几个命令合在一起执行， s h e l l提供了两种方法。既可以在当前 s h e l l也可以在
子s h e l l中执行一组命令。
为了在当前s h e l l中执行一组命令，可以用命令分隔符隔开每一个命令，并把所有的命令
用圆括号（）括起来。
它的一般形式为：
（命令1;命令2;. . .）
如果使用{ }来代替（），那么相应的命令将在子s h e l l而不是当前s h e l l中作为一个整体被执
行，只有在{ }中所有命令的输出作为一个整体被重定向时，其中的命令才被放到子 s h e l l中执
行，否则在当前s h e l l执行。它的一般形式为：
{命令1;命令2;. . . }
我很少单独使用这两种方法。我一般只和& &或| |一起使用这两种方法。
再回到前面那个c o m e t脚本的例子，如果这个脚本执行失败了，我很可能会希望执行两个
以上的命令，而不只是一个命令。我可以使用这两种方法。这是原先那个例子：
$ comet month_end.txt || exit
现在如果该脚本执行失败了，我希望先给自己发个邮件，然后再退出，可以用下面的方
法来实现：
在上面的例子中，如果只使用了命令分隔符而没有把它们组合在一起， s h e l l将直接执行
最后一个命令（e x i t）。
我们再回头来看看前面那个使用& &排序的例子，下面是原来的那个例子：
$ sort quarter_end.txt > quarter.sorted && lp quarter.sorted
使用命令组合的方法，如果 s o r t命令执行成功了，可以先将输出文件拷贝到一个日志区，
加入java编程群：524621833
48
第一部分 shell
下载
然后再打印。
6.4 小结
在编写s h e l l脚本时，使用& &和| |对构造判断语句非常有用。如果希望在前一个命令执行
失败的情况不执行后面的命令，那么本章所讲述的方法非常简单有效。使用这样的方法，可
以根据& &或| |前面命令的返回值来控制其后面命令的执行。
加入java编程群：524621833
下载
第二部分 文 本 过 滤
第7章 正则表达式介绍
随着对U N I X和L I N U X熟悉程度的不断加深，需要经常接触到正则表达式这个领域。使用
s h e l l时，从一个文件中抽取多于一个字符串将会很麻烦。例如，在一个文本中抽取一个词，
它的头两个字符是大写的，后面紧跟四个数字。如果不使用某种正则表达式，在 s h e l l中将不
能实现这个操作。
本章内容包括：
• 匹配行首与行尾。
• 匹配数据集。
• 只匹配字母和数字。
• 匹配一定范围内的字符串集。
当从一个文件或命令输出中抽取或过滤文本时，可以使用正则表达式（ R E），正则表达式
是一些特殊或不很特殊的字符串模式的集合。
为了抽取或获得信息，我们给出抽取操作应遵守的一些规则。这些规则由一些特殊字符
或进行模式匹配操作时使用的元字符组成。也可以使用规则字符作为模式中的一部分进行搜
寻。例如，A将查询A，x将查找字母x。
系统自带的所有大的文本过滤工具在某种模式下都支持正则表达式的使用，并且还包括
一些扩展的元字符集。这里只涉及其中之一，即以字符出现情况进行匹配的表达式，原因是
一些系统将这类模式划分为一组形成基本元字符的集合。这是一个好想法，本书也采用这种
方式。
本章设计的基本元字符使用在g r e p和s e d命令中，同时结合{ \ \ }（以字符出现情况进行匹配
的元字符）使用在a w k语言中。
表7-1 基本元字符集及其含义
^ 只只匹配行首
$ 只只匹配行尾
* 只一个单字符后紧跟*，匹配0个或多个此单字符
[ ] 只匹配[ ]内字符。可以是一个单字符，也可以是字符序列。可以使用 -
表示[ ]内字符序列范围，如用[ 1 - 5 ]代替[ 1 2 3 4 5 ]
\ 只用来屏蔽一个元字符的特殊含义。因为有时在 s h e l l中一些元字符有
特殊含义。\可以使其失去应有意义
. 只匹配任意单字符
p a t t e r n \ { n \ } 只用来匹配前面p a t t e r n出现次数。n为次数
p a t t e r n \ { n，\ } m 只含义同上，但次数最少为n
p a t t e r n \ { n，m \ } 只含义同上，但p a t t e r n出现次数在n与m之间
现在详细讲解其中特殊含义。
加入java编程群：524621833
50