s ← r + c
(cid:3) · tsk and output (nt, s).
from
(cid:3) ← H(“FS ”, nt ⊕ nh, c) and
it
Fig. 1. Our proposed modiﬁed TPM 2.0 interface (changes w.r.t. the current speciﬁcation are highlighted in blue).
TPM:
Prove:
Variable
tsk
tpk
¯g
˜g
hsk
y1
bsn E
Type
Zp
G1
G1
G1
Zp
G1 or GT
{0, 1}∗ or ⊥
Explanation
secret key held inside the TPM (in DAA part of the platform secret key)
public key corresponding to tsk, i.e., tpk = ¯gtsk
ﬁxed generator in all TPMs
cleared generator created in TPM.Commit, with ˜g ← HG1 (bsn E) if bsn E (cid:4)= ⊥ and ˜g ← ¯g else
secret key held by the host (in DAA part of the platform secret key), set hsk = 1 if not needed
see SPK (1), if y1 ∈ GT then ˆg2 is a mandatory input
basename for generator ˜g ← HG1 (bsn E), if bsn E = ⊥ then ˜g ← ¯g
see SPK (1), set δ = 1 if not needed
δ
ˆg2
γ
bsn L
y3
αi
bi
(cid:3)
b
i
(cid:3)(cid:3)
b
i
mh
mt
Zp
G2 if y1 ∈ GT , or ⊥ if ˆg2 (cid:4)= ⊥, it moves proof to GT by setting ˆg ← e(˜g, ˆg2); if ˆg2 = ⊥ then ˆg ← ˜g
Zp
{0, 1}∗ or ⊥
G1, G2, GT , or ⊥
Zp
same group as y1
G1
same group as y3
{0, 1}∗ or ⊥
{0, 1}∗ or ⊥
see SPK (1), set γ = 1 if not needed
(bsn L) if bsn L (cid:4)= ⊥
basename for generator j ← HG1
see SPK (1), set y3 = ⊥ if not needed
i )}i
see SPK (1), input given as part of {(αi, bi, b
(cid:3)(cid:3)
(cid:3)
i, b
see SPK (1), set bi = 1G if αi is not needed in the ﬁrst equation of (1)
(cid:3)
see SPK (1), set b
i = 1G1 if αi is not needed in the second equation (1)
(cid:3)(cid:3)
see SPK (1), set b
i = 1G if αi is not needed in the third equation (1)
message that the host adds to an attestation
message the TPM attests to
Fig. 2. Overview of variables used within the TPM and in our Prove protocol.
The protocol allows the host to add a key hsk to the witness
for tsk because, as we will see in the later sections, this can
improve the privacy of DAA schemes. Note that we could
trivially generalize the proof statement (1) to include additional
terms that do not contain γ · (tsk + hsk ) as witness, but for
ease of presentation we omit these additional terms.
The host can add any message mh to the proof. It also
chooses mt, but this is a value the TPM attests to and will be
checked by the TPM.
The host can create such a proof using the Prove protocol
described in Fig. 3. We assume a perfectly secure channel
between the host and TPM, i.e., the adversary does not notice
the host calling TPM commands. Note that before starting the
proof, the host may not know y2, as it does not know tsk,
but learns this value during the proof because it is given as
output of the Prove protocol. How to verify such proofs using
the VerSPK algorithm is shown in Fig. 3 as well. Note that
veriﬁcation does not require any participation of the TPM.
Fig. 2 gives a brief overview of the required parameters and
their respective types and conditions.
The completeness of these proofs can easily be veriﬁed.
The proof is sound as we can extract a valid witness using the
standard rewinding technique.
Example for Using Prove. We now give a simple example to
show how the Prove protocol must be invoked and give some
intuition on how the ﬁnal proof is assembled by our protocol.
Suppose we want to prove:
SPK
∗{(tsk + hsk ) : d
(cid:3) = (HG1
nym = HG1
(bsn E)δ)(tsk +hsk ) ∧
(bsn L)(tsk +hsk )}(mh, mt),
where the TPM holds tsk and the host knows hsk. The host
will add hsk to the witness for tsk, which is the ﬁrst input to
Prove. The second argument is the left hand side of the ﬁrst
(cid:3). The generator for the witness tsk + hsk
equation, which is d
is (HG1 (bsn E)δ), which is passed on to the Prove protocol by
giving bsn E and δ as the next arguments. The protocol has
the option to move the proof to GT by passing a value ˆg2,
but as this proof takes place in G1, we enter ˆg2 = ⊥. We can
prove knowledge of γ · (tsk + hsk ), but as we want to use
witness tsk + hsk, we pass γ = 1. In the second equation,
we use HG1 (bsn L) as generator, so we give argument bsn L.
906
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:27:02 UTC from IEEE Xplore.  Restrictions apply. 
Prove(hsk , y1, bsn E, δ, ˆg2, γ, bsn L, y3,
{(αi, bi, b
i )}i, mh, mt) :
(cid:3)(cid:3)
(cid:3)
i, b
rαi
i
i b
rαi
i
(cid:3)
i
if bi ∈ G1, or
(bsn E), otherwise set ˜g ← ¯g.
• If bsn E (cid:4)= ⊥, set ˜g ← HG1
• If ˆg2 (cid:4)= ⊥, set ˆg ← e(˜g, ˆg2), otherwise set ˆg ← ˜g.
• If bsn L (cid:4)= ⊥, set j ← HG1 (bsn L).
• Call TPM.Commit(bsn E, bsn L) → (commitId , ¯nt, E, K, L).
(cid:3) ← (E · ˜grhsk )γ·δ. If bsn L (cid:4)= ⊥, set
• Take rhsk ←$ Zp, set E
(cid:3) ·(cid:5)
(cid:3) ← (K · jhsk )γ and L
(cid:3) ← (L · jrhsk )γ.
K
(cid:3) · (cid:5)
• If bsn L (cid:4)= ⊥, set y2 ← K
(cid:3)
αi.
i b
, ˆg2) ·(cid:5)
i=1 ←$ Zl
• Take {rαi}l
p. Set t1 ← E
i
(cid:3)(cid:5)
if bi ∈ GT .
t1 ← e(E
(cid:3)
i b
• If y3 (cid:4)= ⊥, set t3 ← (cid:5)
rαi and t2 ← ⊥ else.
• If bsn L (cid:4)= ⊥, set t2 ← L
i b
rαi and t3 ← ⊥ else.
(cid:3)(cid:3)
i b
h ← (mh, y1, ˆgδ,{(bi, b
i )}, t1, y2, bsn L, t2, y3, t3).
i
(cid:3)
(cid:3)
(cid:3)(cid:3)
• Set m
i, b
h) → c.
(cid:3)
• Call TPM.Hash(mt, m
• Take nh ←$ {0, 1}ln.
• Call TPM.Sign(commitId , c, nh) → (nt, s).
• Check that ¯nt = H(“nonce”, nt) and set n ← nh ⊕ nt,
c
(cid:3) · αi for
• Set s
i = 1, . . . , l.
and if bsn E (cid:4)= ⊥, check
• Check (ˆgδ)s(cid:2)
= E
(cid:3) · K
(cid:3)c(cid:2)
js(cid:2)
.
• Set proof π ← (c
(cid:3)
VerSPK(π, y1, ˆgδ, y2, bsn L, y3,{(αi, bi, b
i )}i, mh, mt) :
(cid:3)(cid:3)
(cid:3)
i, b
· (ˆgδ)s(cid:2) ·(cid:5)
,{sαi}).
(cid:3)
• Parse π as (c
· HG1 (bsn L)s(cid:2) · (cid:5)
• Set t1 ← y
−c(cid:2)
i bi
1
• If bsn L (cid:4)= ⊥, set t2 ← y
−c(cid:2)
·(cid:5)
t2 ← ⊥ else.
2
• If y3 (cid:4)= ⊥, set t3 ← y
sαi and t3 ← ⊥ else.
−c(cid:2)
3
• Output 1 if c
i )}, t1, y2, bsn L, t2, y3, t3))), and 0 otherwise.
{(bi, b
(cid:3)(cid:3)
(cid:3)
i, b
(cid:3) ← γ · (s + rhsk + c
(cid:3) · (y1/(
(cid:3)
, n, s
(cid:3) = H(“FS ”, n, H(“TPM ”, mt, (mh, y1, ˆgδ,
,{sαi}) and output (y2, π).
(cid:3) · hsk ) and sαi
(cid:5)
(cid:3) ← H(“FS ”, n, c).
αi
i )c(cid:2)
i b
← rαi
(cid:3)
i
i b
sαi , and
sαi .
(cid:3)(cid:3)
i
i b
(cid:3)
, n, s
+ c
= L
Fig. 3. Prove protocol and VerSPK algorithm to create and verify zero-
knowledge proofs via the TPM interfaces from Fig. 1.
Since our proof omits the third equation, we set y3 ← ⊥.
The protocol supports an additional list of witnesses with
generators in the three equations, but since this equation only
uses witness tsk +hsk, we pass an empty list as next argument.
Finally, we specify mt, the message the TPM attests to, and
mh, the additional data added by the host. Therefore, we call
(cid:3)
Prove(hsk , d
, bsn E, δ,⊥, 1, bsn L,⊥,∅, mh, mt).
(bsn E)rtsk and L = HG1
The protocol calls TPM.Commit with basenames bsn E and
(bsn L)rtsk
bsn L to receive E = HG1
for some rtsk , and K = HG1
(bsn L)tsk , along with ¯nt =
H(“nonce”, nt), that commits the TPM to TPM nonce nt. The
host must change the generator for the ﬁrst proof equation
to HG1 (bsn L)δ instead of HG1 (bsn L), and add randomness
to both values to prevent a malicious TPM from altering
the distribution of the resulting proof. It sets t1 ← Eδ ·
(bsn E)δ)rtsk +rtsk , and t2 ← L ·
(HG1
HG1 (bsn L)rhsk = HG1 (bsn E)rtsk +rtsk . Next, it hashes the t-
values along with the proof parameters and messages mt and
(bsn E)δ)rhsk = (HG1
mh using TPM.Hash. The TPM inspects mt and returns c,
which can only be passed to TPM.Sign if the TPM agrees to
signing mt. The host now calls TPM.Sign with c and a fresh
(cid:3)·tsk.
host nonce nh, upon which it receives nt and s = rtsk +c
The host checks whether nt matches the committed TPM
nonce, and computes the joint nonce n ← nh ⊕ nt and Fiat-
(cid:3) ← H(“FS ”, n, c). The host must now add
Shamir challenge c
its randomness and hsk to the s-value, which it does by setting
(cid:3)·hsk. Finally, it checks whether the resulting
(cid:3) ← s+rhsk +c
s
proof is valid, to make sure that the TPM contributions did
not invalidate the proof. The resulting proof consists of nonce
n, Fiat-Shamir challenge c
(cid:3), and s-value s
(cid:3).
4.1.1 Security of Prove
We now show that proofs generated by our generic Prove
protocol speciﬁed in Fig. 3 and using the TPM interfaces as
described in Fig. 1 are unforgeable, device-bound and remain
zero-knowledge even if the TPM is subverted.
Zero-knowledge of SPKs with a Corrupt TPM. An SPK
created with the Prove protocol is zero knowledge in the
random oracle model, even when the TPM is corrupt. That
is, we prove the absence of any subliminal channel that a
malicious TPM could use to break the privacy of the platform.
In Sec. 5 we show that this allows one to devise DAA schemes
that guarantee privacy even when the TPM is malicious.
Lemma 1 (Privacy of SPKs with a TPM). The signature
proofs of knowledge generated by Prove as deﬁned in Fig. 1,
are zero-knowledge, even when the TPM is corrupt.
Proof (sketch). A corrupt TPM may block the creation of the
proof, but if it succeeds, it is zero knowledge. The TPM is
involved in proving knowledge of γ · (tsk + hsk ). The host
changes the r-value to γ · (rtsk + rhsk ), with rhsk chosen by
the host. It takes rhsk ←$ Zp, so rtsk + rhsk is uniform in
Zp regardless of how the TPM chooses rtsk . Since γ (cid:4)= 0,
γ · (rtsk + rhsk ) is still uniform in Zp.
The TPM also chooses a nonce nt. It must ﬁrst commit to
this nonce with ¯nt = H(“nonce”, nt). The host then chooses
a nonce nh uniformly at random in {0, 1}ln, and the TPM
must work with n = nh ⊕ nt, and show that it computed this
correctly. Clearly, n is uniform if nh is uniform.
Since we know the distribution of every part of the zero-
knowledge proof, even when the TPM is corrupt, we can
simulate proofs of an honest host with a corrupt TPM.
Unforgeability of SPKs with an Honest TPM. We now show
that proofs generated by Prove are unforgeable with respect
to mt, i.e., if the TPM is honest, a corrupt host cannot create
a SPK for message mt that the TPM did not approve to sign.
We consider a corrupt host with oracle access to an honest
TPM. The TPM executes TPM.Create, outputting tpk ← ¯gtsk .
The corrupt host cannot create SPKs of structure (1) where tsk
is protected by the TPM and γ and hsk are known and the
TPM never signed mt. We require the host to output γ and
hsk along with his forgery. In a protocol, this means that these
907