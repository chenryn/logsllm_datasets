代理模式
为监视器编码
我们先为GumballMachine加上处理位置的支持：
位置用Sttins记录。
public class GumballMachine {
//其他实例变量
String location;
public GumballMachine(String location,
int count)
R
位置被传入构造器内，然后存到
//构造器内的其他代码
此实例变量中。
this.location=location;
public String getLocation()
让我们也加上一个setter方法，以便在
return location;
需要位置时可以取得。
//其他方法
1
现在让我们创建另一个类，GumballMonitor（糖果监视器），以便取得机器
的位置、糖果的库存量以及当前机器的状态，并打印成一份可爱的报告。
public class GumballMonitor (
此监视器的构造器需要被传入糖集机，它
GumballMachine machine;
会将糖果机记录在machine实例变量中。
public GumballMonitor (GumballMachine machine)
this.machine = machine;
public void report(){
System.out.println("Gumball Machine: "+ machine.getLocation());
System.out.println("Current inventory: "+ machine.getCount()
+
gumballs") ;
System.out.println("Current state:"+ machine.getState());
负责打印报告的report方法，会将位置、库
存、机器状态打印出来。
你现在的位置》
431
---
## Page 468
本地糖果监视器
测试监视器
我们一下就搞定了，CEO将对我们的开发能力感到折服。
现在我们需要实例化一个GumbalIMonitor（糖果监视器），并传入一个糖果机：
public class GumballMachineTestDrive {
public static void main(String[] args){
利用命今行传入位置和一开始的糖
int count =0;
果数日。
if (args.length  ")
入构造器
System.exit (1) ;
count = Integer.parseInt (args [1]) ;
GumballMachine gumballMachine = new GumballMachine (args [0], count) ;
GumballMonitor monitor = new GumballMonitor (gumballMachine) ;
个
….然后实例化一个监视器，传给它一
//其他的测试代码
个机器来提供报告。
monitor.report () ;
File Edt Windc
&java GumballMachineTestDrive Seattle 112
当我们需要机器的报告的时
Gumball Machine:Seattle
候，调用teporr(）方法即可。
Current Inventory:112 gumballs
Current State:waiting for quarter
输出是这样的
监报器的输出系起来虽然很不错，但
可能是我之前说的不够清慧，我需要的是
在远程监控糖票机！事实上，我们已经把网
络准备好了。拜托，你们这些人不是号
称lnternet一代吗？
432
第11章
---
## Page 469
代理模式
别担心！我已经会许多
设计模式了，我们其实只是
需要运程代理（remoteproxy）
i
这让我们学到了一个教训：在开始
编码之前，要先收集需求。命望我
们不要再从头开始…
2im
Joe：你说远程什么？
20e
Ftank
Frank：远程代理。你想想：我们已经写好监视器代码，对吧？我们给GumballMonitor一个糖果机的引用，
它给我们一份报告。问题在于监视器和糖果机在同一个JIVM上面执行，但是CEO希望在他的桌面上远程监
控这些机器！所以我们可以不要变化GumballMonitor，不要将糖果机交给GumballMonitor，而是将一个远
程对象的代理交给它。
Joe：我不太懂。
Jim：我也不懂。
Frank：让我从头开始说.…….所谓的代理（proxy），就是代表某个真实的对象。在这个案例中，代理就像
是糖果机对象一样，但其实幕后是它利用网络和一个远程的真正糖果机沟通。
Jim：你是说，不需要改我们的代码，只要将GumballMachine代理版本的引用交给监视器就可以了
Joe：然后这个代理假装它是真正的对象，但是其实一切的动作是它利用网络和真正的对象沟通。
Frank：差不多就是这样。
Joe：这好像说的比做的容易。
Frank：或许吧！但是我不认为有这么难。我们必须确定糖果机能够通过网络接受请求并且提供服务；我
们也需要让监视器有办法取得代理对象的引用，这方面，幸好Java已经有一些很棒的内置工具可以帮助我
们。我们先看看远程代理
你现在的位置
433
---
## Page 470
远程代理
远程代理的角色
对象，活在不同的Java虚拟机（JVM）堆中（更一般的说法为，在不同的
法调用的对象，其行为会转发到远程对象中。
CEO的面。
带3VM的远程糖果机。
代理可以假装自己是选程
对象，但其实只是一个中间
的角色。
本地堆
远程堆
糖果监视器是客户对
代理
象，它以为沟通的对
糖果机
象是真正的糖果机，
但真正与它沟通的是
代理，再由代理通过
远程对象才是真东西，它
网络和真正的糖果机
拥有真正做事的一些方
淘通。
和旧的代码一样，只不过变成
法。
和代理沟通。
你的客户对象所做的就像是在做远程方法调用，但其实只是调用
本地堆中的“代理”对象上的方法，再由代理处理所有网络通信
的低层细节。
PDG
434
第11章
---
## Page 471
代理模式
真是个妙主意。我们要写一些代码
竭用本地方法，然后传送到网络上，调用
远程对象的一些方法。我猜想，当调用完毕，结
累值也通过网络从运程送回我们的客户。我觉
得这样的代码可能不好写。
C
等等，我们可没有要自已写这些代码，
√ava已经内置远程调用的功能了，我们
只需要修改一下代码，让它符合RMI的
要求就行了。
BRAIN
X.POWER
在我们进下一步之前，想想看要如何设计一个支持远程方法调用的系统。你要怎样才能让开
发人员不用写太多代码？让远程调用看起来就好像本地调用一样，毫无瑕疣？
BRAIN?
XPOWER
你现在的位置
435
---
## Page 472
RMI浏览
将远程代理加到糖果机的监视代码中
构想上，这一切都很不错，但是要如何创建一个代理，知道如何调用在另一个JIVM中的对象的方法？
这个嘛！你不能取得另一个堆的对象的引用，换句话说，你不可以这么写：
Duckd=
变量d只能引用当前代码语句的同一堆空间的对象。那该怎么办？该是Java远程方法调用出现的时刻
了.RMI可以让我们找到远程JVM内的对象，并允许我们调用它们的方法。
你可能在《HeadFirstJava》书中看过RMI。如果你还不懂RMI，我们现在就稍微介绍一下，然后我们
为糖果机代码添加代理支持。
我们打算这么做：
首先，我们先浏览并了解一下RMI。即使你熟
悉RMI，你可能还想复习顺便跟着浏览一下风
景。
RMI浏览
②接着，我们会把GumballMachine变成远程服
务，提供一些可以被远程调用的方法。
如果你是RM新手，仔细阅读下
面几页。否则快速地扫一下就
可以了。
③然后，我们将创建一个能和远程的
GumballMachine沟通的代理，这需要用到
RMI。最后再结合监视系统，CEO就可以监视
任何数量的远程糖果机了。
436
第11章
---
## Page 473
代理模式
远程方法101
RMI浏览
假如我们想要设计一个系统，能够调用本地对象，然后将每个请求转发到远程对象上进
行。要如何设计？我们需要一些辅助对象，帮我们真正进行沟通。这些辅助对象使客户就
像在调用本地对象的方法（事实也是如此）一样。客户调用客户辅助对象上的方法，仿佛
客户辅助对象就是真正的服务。客户辅助对象再负责为我们转发这些请求。
换句话说，客户对象以为它调用的是远程服务上的方法，因为客户辅助对象乔装成服务对
象，假装自已有客户所要调用的方法。
但是客户辅助对象不是真正的远程服务。虽然操作看起来很像（因为具有服务所宣称的相
同的方法），但是并不真正拥有客户所期望的方法逻辑。客户辅助对象会联系服务器，传
送方法调用信息（例如，方法名称、变量等），然后等待服务器的返回。
在服务器端，服务辅助对象从客户辅助对象中接收请求（透过Socket连接），将调用的信息
解包，然后调用真正服务对象上的真正方法。所以，对于服务对象来说，调用是本地的，
来自服务辅助对象，而不是远程客户。
服务辅助对象从服务中得到返回值，将它打包，然后运回到客户辅助对象（通过网络
Socket的输出流），客户辅助对象对信息解包，最后将返回值交给客户对象。
这一切悉起来应试很熟悉
客户辅助对象假装自己就是
服务，但其实它只是真东
客户堆
西”的一个代理。
服务器堆
易
客户对象以为在和
服务对象
真正的服务沟通，以
客户对象
为客户辅助对象就
是能够真正做事情的
服务辅助对象从客户转助
服务对象是卖正提供
东西。
这是我们的
对象处取得请求，对它解
服务的地方，它的方
C
代理。
包，调用真正服务上的方
法真正在做事情
法。
你现在的位置
437
---
## Page 474
远程方法调用
方法调用是如何发生的
①客户对象调用客户辅助对象的doBigThingO方法。
服务器堆
客户堆
doBigThingO
象
服务对
客户对象
②客户辅助对象打包调用信息（变量、方法名称等），然后通过网
络将它运给服务辅助对象。
1
服务器堆
客户堆
“客户想要调用一个方法”
doBigThingO
服务对象
客户对象
③
服务辅助对象把来自客户辅助对象的信息解包，找出被调用的方法（以
及在哪个对象内），然后调用真正的服务对象上的真正方法。
服务器堆
客户堆
“客户想要调用一个方法”
doBigThingO
doBigThingO
请记住：这是含有真
正方法逻辑、真正做
事的对象！
象
服务对象
客户对象
438
第11章
---
## Page 475
代理模式
④服务对象上的方法被调用，将结果返回给服务辅助对象。
RMI浏览
客户堆
服务器堆
结果
象
服务对象
5
服务辅助对象把调用的返回信息打包，然后通过网络运回给客户
辅助对象。
客户堆
服务器堆
打包结果
象
客户对象
服务对象
6
客户辅助对象把返回值解包，返回给客户对象。对于客户来说，这
是完全透明的。
服务器堆
客户堆
结果
PDG
服务对象
客户对象
你现在的位置
439
---
## Page 476
RMI：概观
JavaRMI概观
现在你已经知道远程方法如何工作的要点，你还需
这个服务用来寻找和访问远程对象。
要了解如何利用RMI进行远程方法调用。
关于RMI调用和本地（正常的）的方法调用，有一
RMI提供了客户辅助对象和服务辅助对象，为客户
个不同点。虽然调用远程方法就如同调用本地方
辅助对象创建和服务对象相同的方法。RMI的好处
法一样，但是客户辅助对象会通过网络发送方法
在于你不必亲自写任何网络或I/O代码。客户程序
调用，所以网络和I/O的确是存在的。关于网络和
调用远程方法（即真正的服务所在）就和在运行在
I/O部分，我们知道些什么？
客户自己的本地JVM上对对象进行正常方法调用一
我们知道网络和I/O是有风险的，容易失败的，所以
样。
随时都可能抛出异常，也因此，客户必须意识到风
RMI也提供了所有运行时的基础设施，好让这一切
险的存在。再过几页我们就会讨论这部分。
正常工作。这包括了查找服务（lookupservice），
RMl称呼（译注：terminology，术语，重点在概念本身：nomenclature，称呼，重点在概念上贴的标签）：
RMI将客户辅助对象称为stub（桩），服务辅助对象称为skeleton（骨架）。
它即将扮演我们
的代理！
服务器堆
客户堆
RMISTUB
RMISKELETON
服务对象
客户对象
较新版的avu不需要一个显
式的skeleton对象，但是尽
管如此，在服务器端仍然
有一些东西页责skeleton的
现在，我们就来看看如何将对象变成服务一一可以接受远程调用的服务。也看
行为。
看，如何让客户做远程调用。
接下来会有一堆步骤和一些颠簸、大转弯你可得系好安全带坐稳了，不过别
太担心！
440
第11章
---
## Page 477
代理模式
制作远程服务
这里有用来制作远程服务的五个步骤的概要。换句话说，这些步骤将一个普通
RMI浏览
的对象变成可以被远程客户调用的远程对象。我们稍后会把这些步骤应用于
GumbalIMachine。现在，就让我们看看这些步骤的细节。