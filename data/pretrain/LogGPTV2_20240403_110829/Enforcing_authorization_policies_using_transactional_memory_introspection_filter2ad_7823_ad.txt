ments over traditional authorization.
5.1 GradeSheet: A grade management system
As discussed in Section 3.2, GradeSheet is a simple client/server
Java application to manage student grades, containing about 900
lines of code. Principals are either graders (professors or TAs) or
students. GradeSheet enforces the following authorization policy:
(1) a professor may read/write all grades and read all grade aver-
ages; (2) a TA may read/write grades for projects that she super-
vised and read any project’s grade average; and (3) a student can
only read her own grades and project grade averages.
We ported GradeSheet to use TMI-based authorization policy
enforcement and converted all shared objects to their transactional
equivalents. The @sensitive GradeCell objects must be autho-
rized based upon their security-relevant attributes, namely grades,
student IDs and project IDs. We integrated the TMI authorization
module with both a custom-built policy engine as well as another
one that used XACML [23] policies.
5.2 A Tar archive service
We experimented with a 5,000 line Java service that allows standard
Tar archives to be created and processed [55]. We converted this
code to use TMI-enhanced DSTM2, and perform each service
invocation within a transaction. Few lines were changed in this
conversion: we used a simple, static escape analysis to establish
that most state was transaction-local, and that ﬁles were the only
security-relevant, shared resources.
Subsequently, we added TMI-based enforcement of ﬁle-system
authorization policies to the converted Tar service. We imple-
mented this enforcement with an authorization manager that is also
installed as, and inherits from, the Java SecurityManager [30].
Thus, our TMI reference monitor accurately models system-level
access control in Java.
In particular, our TMI reference monitor is invoked whenever
any ﬁles are opened for reading or writing. As before, it can per-
form authorization checks lazily or in an overlapped fashion, by
copying into an introspection log any security-relevant metadata,
including the Java stack-based security context.
We have used our implementation for lazy and overlapped en-
forcement of existing Java stack inspection security policies. We
used java.security.AllPermission, the simplest policy avail-
able for Java stack inspection. Coupled with overlapped enforce-
ment, more complex policies would amplify the trends shown in
our experiments. In particular, potentially more work could be per-
formed in parallel with the main execution.
5.3 FreeCS: A chat server
FreeCS is a Java-based chat server that consists of about 22,000
lines of code [26]. FreeCS allows its users to broadcast messages;
a message broadcast by a user is visible to all other users in the
same group (FreeCS’s equivalent of a chat room). A user can issue
several commands via a FreeCS interface, including commands to
join a new group, invite other users to her group and ban members
from her group; in all, FreeCS supports 47 such commands.
A FreeCS user is associated with a privilege level, e.g., Super-
User, Guest, Punished, Banned; the set of commands that a user
can issue is based upon her privileges. Similarly, a group can also
be Open or Locked: users can freely join Open groups, while spe-
cial privileges are required to join Locked groups. FreeCS enforces
a variety of policies on users and groups. However, these poli-
cies are hard-coded in FreeCS (using language constructs, such as
if. . .then. . .else).
We ported FreeCS to use TMI-based authorization policy en-
forcement. We used the TMI reference monitor to both replace
FreeCS’s enforcement mechanisms for several commands, as well
as augment FreeCS to enforce several policies that it currently does
not; we describe a few examples below.
(1) Punished users are disallowed from joining other groups. We
modiﬁed FreeCS to use TMI to enforce this existing policy.
(2) Superusers are disallowed from joining a Locked group. This
extends FreeCS policy, in which no restrictions are placed on users
with Superuser privileges.
(3) Bound the number of users who can join a group; as with the
previous policy, this extends FreeCS, which imposes no upper limit
on the number of users in a group.
Our implementation uses the XACML framework to express
FreeCS authorization policies. In each case, if a user is not autho-
rized to perform an operation (e.g., join a group), FreeCS rolls back
the failed operation, and sends a failure message to the user; no ad-
ditional failure-handling code was required.
write G.usrList → write U.grp
Figure 6. Fingerprint for the operation corresponding to user
U joining a group G in the FreeCS chat server.
Overall, our port of FreeCS to use TMI-based enforcement
required about 860 changes in seven classes. In all, we introduced
transactions for all 47 FreeCS client requests. Most of the changes
to FreeCS involved replacing reads/writes of transactional objects
with DSTM2 accessor functions. As described in Section 4, this is
a limitation of any library-based STM, which can be overcome with
compiler-based or language-based support for transactions.
Several security-relevant operations in FreeCS consisted of
multiple low-level object accesses. We therefore supplied the TMI
reference monitor with ﬁngerprints to recognize these security-
relevant operations. These ﬁngerprints were also sensitive to the
order of accesses; we therefore used introspection logs as the ba-
sis for TMI-based enforcement. For example, the security-relevant
operation corresponding to a user joining a group involves the fol-
lowing sequence of low-level accesses, in sequence: adding the
user to the usrList of the Group; and setting the grp ﬁeld of the
User object to the group that the user just joined. The TMI ref-
erence monitor matches the ﬁngerprint for this operation (shown
in Figure 6) against the introspection log to determine whether a
user has attempted to join a group; if so, it consults the policy to
determine whether the operation is authorized.
5.4 WeirdX: A window management server
WeirdX is a Java-based X window server that consists of about
27,000 lines of code [39]. WeirdX supports the X protocol; there-
fore X clients can connect to WeirdX, and communicate with each
other and with WeirdX in much the same way that they do on the
X11 server [60].
Much like the X11 server, WeirdX does not enforce any policies
on X clients that connect to it. Therefore, a malicious X client can
access/modify resources that belong to other clients of WeirdX.
This has serious consequences; an X client can register to receive
events (e.g., keystrokes) sent to other clients, or even shut them
down. Prior work has motivated the need for window management
servers to enforce authorization policies on clients to prevent such
attacks [40].
We ported WeirdX to enforce authorization policies using TMI.
We used TMI in conjunction with the XACML framework to for-
mulate and enforce several policies that have been discussed in
prior work [40], including preventing a rogue X client from killing
arbitrary X clients, and mediating copy/paste operations. For exam-
ple, we enforced the Bell-LaPadula policy on how data copied from
an X client can be pasted to other X clients.1 Overall, our port of
WeirdX required about 4,800 changes in 25 classes, and introduced
108 transactions to the code that dispatches X protocol requests to
handlers; as with FreeCS, most of these changes were related to re-
placing reads/writes of transactional objects with DSTM2 accessor
functions. We also had to make a few changes to WeirdX code that
handled output to the screen. In particular, we modiﬁed WeirdX to
buﬀer writes that happen within transactions, and ﬂush the buﬀers
only upon a transaction commit.
5.5 Performance
We evaluated the performance of three variants of the GradeSheet,
Tar, FreeCS and WeirdX servers. The ﬁrst variant, No-STM, is an
unmodiﬁed server. The second variant, STM-only, is a server that
1 We used IP addresses of X clients as their security labels, though ﬁner-
grained security labels are possible with OS support [56].
has been ported to use an unmodiﬁed DSTM2, for concurrency
control only. The third server variant, STM-TMI, is the server
ported to use our modiﬁed DSTM for concurrency control and to
use TMI-based authorization. In this variant, each client request
to the server is handled as an STM transaction, the TMI reference
monitor mediates on all access to security-relevant resources, and
a server authorization manager performs security checks.
The same authorization policy is enforced in all three server
variants. In the STM-TMI variant, enforcement uses our added
TMI-based enforcement mechanisms, while the No-STM and
STM-only variants use the original server authorization mecha-
nisms. However, only the STM-TMI variant of WeirdX performs
enforcement, since the unmodiﬁed server had no security policy.
We ran experiments and measured the performance of the four
servers and their variants. Furthermore, for the STM-TMI variant,
we ran three experiments, using implementations of eager, lazy and
overlapped authorization managers. Figure 7 reports the arithmetic
mean of the measured wall-clock execution time for the following
processing: the handling of a client request in GradeSheet (avg.
over 60,000 requests), the archiving of 10,000 empty ﬁles to/from
a ramdisk using Tar (avg. over 10 runs), the addition of a user to
a FreeCS forum (avg. over 750 runs), and creating and mapping
subwindows (as performed by the x11perf/create benchmark [59]).
These experiments included no contention and no authorization
failures; they ran on a quiescent system with Intel Core 2 Duo
processors. The measurements did not signiﬁcantly vary from the
reported averages.
As Figure 7 shows, lazy TMI enforcement (STM-TMI/Lazy)
always incurs acceptable overheads—under 21% in all cases. Ea-
ger TMI-based enforcement (STM-TMI/Eager) has even lower
overhead for GradeSheet and Tar (which shows a not-statistically-
signiﬁcant 1% speedup). However, eager enforcement is not a good
strategy for FreeCS and WeirdX, where it results in a signiﬁcant
slowdown. This is because both FreeCS and WeirdX use a complex
ﬁngerprint to identify security-relevant operations, such as joining
a forum and creating/mapping windows. While lazy enforcement
can match ﬁngerprints once and for all, before commit, eager en-
forcement checks for a match on every security-relevant access. In
particular, the x11perf/create benchmark creates and maps several
hundred subwindows; with eager enforcement, each of the create
and map operations entails ﬁngerprint matching and policy lookup,
which results in a very signiﬁcant slowdown of WeirdX. Thus, the
choice between lazy and eager TMI-based enforcement can depend
on the authorization strategy, as well as the server software and its
workload.
With overlapped TMI enforcement (STM-TMI/Overlapped),
our implementation creates a thread for each transaction. There-
fore, one may expect signiﬁcant overhead on short transactions;
indeed, as shown in Figure 7, we measured 54% overhead for
GradeSheet. However, we observed a speedup of 15.8% for Tar;
this is because expensive stack-inspection-based authorization of
Tar can be usefully overlapped with transaction execution. FreeCS
and WeirdX can similarly beneﬁt from having ﬁngerprint match-
ing performed on a parallel thread. (However, for FreeCS, the
best strategy is still lazy, one-shot matching upon commit.) Thus,
whether to overlap TMI-based enforcement can depend on trans-
action length, the cost of thread creation and synchronization, and
the cost of authorization checks.
As shown in Figure 7, TMI-based authorization has acceptable
overhead when applied to servers written to use STM techniques;
TMI-based enforcement can even improve the performance of such
software. However, the No-STM and STM-only columns show
that simply using DSTM2 for concurrency control results in a
very substantial performance overhead. It must be emphasized that
this high overhead (11× for FreeCS and 28× for WeirdX) does
GradeSheet
Tar
FreeCS
WeirdX
No-STM STM-only
398 µs
4.96 s
321 µs
0.23 ms
451 µs
15.40 s
3907 µs
6.40 ms
STM-TMI/Eager
452 µs
(0.3%)
(−1.0%)
15.24 s
5471 µs
(40%)
(10.8×)
69.12 ms
STM-TMI/Lazy
458 µs
(1.4%)
(9.5%)
16.87 s
(4.3%)
4075 µs
7.74 ms
(21%)
STM-TMI/Overlapped
(54%)
(−15.8%)
(8.6%)
(11%)
694 µs
12.96 s
4244 µs
7.15 ms
Figure 7. Performance measurements for servers. The overhead of using TMI (shown in parentheses) is calculated by comparing the
STM-TMI variant against the STM-only variant. Numbers in bold show the most eﬃcient TMI variant for each server.
rization failures. We have implemented simple measure-and-adapt
authorization managers that switch between eager and lazy en-
forcement. Our experiments with such adaptive enforcement con-
ﬁrms that it can dynamically adapt and follow the more eﬃcient of
the two curves shown in Figure 8.
6. RELATED WORK
We focus our discussion of related work to four areas: applications
of transactions to security; comparing TMI and virtual machine in-
trospection; work on exception handling and recovery; and aspect-
oriented software development.
Applications of transactions to security. Clark and Wilson’s in-
ﬂuential model for commercial security policies is deﬁned in terms
of separation of duty and well-formed transactions that preserve
data integrity [14]. Our TMI-based approach is well-suited to en-
forcing such security policies: TMI can ensure that transactions
never commit unless all actions are authorized, e.g., based upon
separation of duty policies, and that application data is consistent,
i.e., the integrity of all data items has been veriﬁed.
The Vino operating system [51] used transactions to isolate the
eﬀects of misbehaving and/or malicious kernel extensions, such as
device drivers, by executing them in the context of a transaction.
If an extension fails or violates system policy (e.g., by hoarding
resources), Vino simply terminates the corresponding transaction,
thereby isolating the extension. In contrast to TMI, which uses
existing STM mechanisms to enforce policies, Vino used a custom-
built transaction manager in the kernel. Further, Vino only relied on
transactions for remediation; though resources accessed during a
transaction are logged, they are only used to restore system state. In
contrast, TMI uses access logging in a key way to achieve complete
mediation.
Chung et al. recently used transactional memory to imple-
ment thread-safe binary translation and applied it to implement
information-ﬂow tracking [13]. This work primarily uses transac-
tional memory to ensure thread-safe access to security metadata
(i.e., taint bits). The TMI architecture, coupled with a dynamic bi-
nary translation system, can also be applied to track information
ﬂow; in this role, TMI will primarily help avoid TOCTTOU bugs
when accessing security metadata. However, Chung et al. show that
information-ﬂow tracking can be implemented using hardware-
only transactional memory techniques as well; in contrast, the TMI
architecture requires software support.
Peyton-Jones and Harris proposed a framework to support
programmer-supplied data invariants in the Haskell STM [47].
These invariants are Boolean functions that are evaluated just be-
fore a transaction commits. Much like TMI, any invariants that
are violated result in a transaction abort. However, this framework
does not allow security checks at each access to a security-relevant
resource, or the maintenance of introspection logs. Even so, a TMI
reference monitor could potentially beneﬁt from its supporting
mechanisms.
Locasto et al. propose SEAD, a system that uses transactions
to build self-healing software [43]. In SEAD, each function is ex-
ecuted as a transaction; faults due to bugs or exploits in a function
Figure 8. Comparing lazy versus eager enforcement in the
presence of contention.
not apply in general to other STM systems (see [42]). Rather, it