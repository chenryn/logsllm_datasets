2.1 Discussion
Related works. The use of HIBE schemes for forward se-
crecy originates in the context of encryption [22] and has
been used in signatures [18,26], key exchange [33] and proxy
re-encryption [30]. Our signature scheme is quite similar
to the forward-secure signatures of Boyen et al. [18] and
achieves the same asymptotic complexity; their construction
is more complex in order to achieve security against untrusted
updates. The way we achieve aggregation is similar to the
multi-signatures in [43].
Alternative approaches to posterior security. There are
two variants of the posterior attack: (i) a short-range vari-
ant, where an adversary tries to corrupt a committee mem-
ber prior to completion of the consensus sub-protocol, and
(ii) a long-range variant as explained earlier. Dﬁnity [34],
Ouroboros [39] and Casper [21] cope with the short-range
attacks by assuming a delay in attacks that is longer than the
running time of the consensus sub-protocol. For long-range
attacks, Casper adopts a fork choice rule to never revert a ﬁnal-
ized block, and in addition, assumes that clients log on with
sufﬁcient regularity to gain a complete update-to-date view of
the chain. We note that forward-secure signatures provide a
clean solution against both attacks, without the need for fork
choice rules or additional assumptions about the adversary
and the clients.
Application to permissioned blockchains. Consensus
protocols, such as PBFT, are also at the core of many per-
missioned blockchains (e.g. Hyperledger), where only ap-
proved parties may join the network. Our signature scheme
can similarly be applied to this setting to achieve forward
secrecy, reduce communication bandwidth, and produce com-
pact block certiﬁcates.
3 Preliminaries
Let G1,G2,Gt be multiplicative groups of prime order q with
a non-degenerate pairing function e : G1 × G2 → Gt. Let g1
and g2 be generators of G1 and G2, respectively.
In analogy with the weak bilinear Difﬁe-Hellman inver-
sion problem (cid:96)-wBDHI∗ [14], which was originally deﬁned
for Type-1 pairings (i.e., symmetric pairings where we have
G1 = G2), we deﬁne the following variant for Type-3 pairings
denoted (cid:96)-wBDHI∗
3.
, . . . , A(cid:96) = g(α(cid:96))
, . . . , B(cid:96) = g(α(cid:96))
1
2
,
,
1
1 , A2 = g(α2)
2 , B2 = g(α2)
2
1 , C2 = gγ
2
Input: A1 = gα
B1 = gα
C1 = gγ
for α,γ ←$ Zq
Compute: e(g1,g2)(γ·α(cid:96)+1)
3
The advantage Adv(cid:96)-wBDHI∗
G1×G2
as its probability in solving this problem.
linear group model, with a lower bound of Ω((cid:112)q/(cid:96)) (with
As shown in [14], the assumption holds in the generic bi-
(A) of an adversary A is deﬁned
a matching attack in [25]). Concretely, for the BLS12-381
pairing-friendly curve with (cid:96) = 32, the best attack has com-
plexity roughly 2125.
Alternatively, our scheme could be proved secure under a
variant of the above assumption where the adversary has to
output g(α(cid:96)+1)
given as input A1, . . . ,A(cid:96),B1, . . . ,B(cid:96) and given
access to an oracle ψ : gx
1. Because of the ψ oracle,
this assumption is incomparable to the (cid:96)-wBDHI assumption
described above.
2 (cid:55)→ gx
1
2096    29th USENIX Security Symposium
USENIX Association
4 Forward-Secure Signatures
Security.
We begin by describing a forward-secure signature scheme,
and then extend the construction to a multi-signature scheme
in Section 5.
4.1 Deﬁnition
We use the Bellare-Miner model [9] to deﬁne syntax and
security of a forward-secure signature scheme. A forward-
secure signature scheme FS for a message space M consists
of the following algorithms:
Setup: pp ←$ Setup(T ). All parties agree on the public pa-
rameters pp. The setup algorithm mainly ﬁxes the distribu-
tion of the parameters given the maximum number of time
periods T . The parameters may be generated by a trusted
third party, through a distributed protocol, or set to “nothing-
up-my-sleeve” numbers. The public parameters are taken to
be an implicit input to all of the following algorithms.
Key generation: (pk,sk1) ←$ Kg. The signer runs the key
generation algorithm on input the maximum number of time
periods T to generate a public veriﬁcation key pk and an
initial secret signing key sk1 for the ﬁrst time period.
Key update: skt+1 ←$ Upd(skt ). The signer updates its secret
key skt for time period t to skt+1 for the next period using
the key update algorithm. The scheme could also offer a
“fast-forward” update algorithm skt(cid:48) ←$ Upd(cid:48)(skt ,t(cid:48)) for any
t(cid:48) > t that is more efﬁcient than repetitively applying Upd.
Signing: σ ←$ Sign(skt ,M). On input the current signing key
skt and message M ∈ M, the signer uses this algorithm to
compute a signature σ.
Veriﬁcation. b ← Vf(pk,t,M,σ). Anyone can verify a sig-
nature σ for on message M for time period t under public
key pk by running the veriﬁcation algorithm, which returns 1
to indicate that the signature is valid and 0 otherwise.
Correctness.
Correctness requires that for all messages M ∈ M and for all
time periods t ∈ [T ] it holds that
Pr[Vf(pk,t,M, Sign(skt ,M)) = 1] = 1
where the coin tosses are over pp ←$ Setup(T ), (pk,sk1) ←$
Kg, and ski ← Upd(ski−1) for i = 2, . . . ,t.
Moreover, if the scheme has a fast-forward update algo-
rithm, then the keys it produces must be distributed identically
to those produced by repetitive application of the regular up-
date algorithm. Meaning, for all t,t(cid:48) ∈ [T ] with t  t∗.
We deﬁne A’s advantage Advfu-cma
(A) as its probability in
winning the above game.
FS
We also deﬁne a selective variant of the above notion, re-
ferred to as sfu-cma, where the adversary ﬁrst has to commit
to ¯t, t∗, and M∗. More speciﬁcally, A ﬁrst outputs (¯t,t∗,M∗),
then receives the public key pk, is allowed to make signature
and key update queries until time period t = ¯t is reached, at
which point it is given sk¯t and outputs its forgery σ∗.
4.2 Encoding time periods
Following [22], we associate time periods with all nodes of
the tree according to a pre-order traversal. Prior tree-based
forward-secure signatures [9, 46] associate time periods with
the only leaf nodes; using all nodes allows us to reduce the
amortized complexity of key updates from O(logT ) exponen-
tiations to O(1) exponentiations.
Recall that a tree of depth (cid:96)− 1 has 2(cid:96) − 1 nodes, which
then correspond to time periods in [2(cid:96) − 1]. We will identify
the nodes of the tree of depth (cid:96)− 1 with strings in {1,2}≤(cid:96)−1
where 1 denotes taking the left branch and 2 denotes taking
the right branch. We work with {1,2} instead of {0,1} for
technical reasons: roughly speaking, in the scheme, we need
to work with strings of length exactly (cid:96)− 1, which we obtain
by padding strings in {1,2}≤(cid:96)−1 with zeroes.
We can also describe the association explicitly as a bijec-
tion between t = t1(cid:107)t2(cid:107) . . . ∈ {1,2}≤(cid:96)−1 and t ∈ [2(cid:96) − 1] for
USENIX Association
29th USENIX Security Symposium    2097
any integer (cid:96) given by
t(t) = 1 +
|t|
∑
i=1
(1 + 2(cid:96)−i(ti − 1)) .
For instance, for (cid:96) = 3, this maps ε,1,11,12,2,21,22 to
1,2,3,4,5,6,7. The inverse of the bijection can be described
as
t(1) = ε
t(t) = t(t − 1)(cid:107)1
t(t) = ¯t(cid:107)2
if |t(t − 1)| < (cid:96)− 1
if |t(t − 1)| = (cid:96)− 1
where ¯t is the longest string such that ¯t(cid:107)1 is a preﬁx of t(t−1).
The bijection induces a natural precedence relation over
{1,2}≤(cid:96)−1 where t (cid:22) t(cid:48) iff either t is a preﬁx of t(cid:48) or exists ¯t
s.t. ¯t(cid:107)1 is a preﬁx of t and ¯t(cid:107)2 is a preﬁx of t(cid:48). We also write
t,t + 1 corresponding to t,t + 1.
Next, we associate any t ∈ {1,2}≤(cid:96)−1 with a set Γt ⊂
{1,2}≤(cid:96)−1 given by
Γt :=(cid:8)t(cid:9)∪(cid:8)¯t(cid:107)2 : ¯t(cid:107)1 preﬁx of t(cid:9)
that corresponds to the set containing t and all the right-hand
siblings of nodes on the path from t to the root, which also
happens to be the smallest set of nodes that includes a preﬁx
of all t(cid:48) (cid:23) t. For instance, for (cid:96) = 3, we have
Γ1 = {1,2},Γ11 = {11,12,2},Γ12 = {12,2} .
The sets Γt satisfy the following properties:
• t(cid:48) (cid:23) t iff there exists u ∈ Γt s.t. u is a preﬁx of t(cid:48);
• For all t, we have Γt+1 = Γt\{t} if |t| = (cid:96)−1 or Γt+1 =
(Γt \{t})∪{t(cid:107)1,t(cid:107)2} otherwise;
• For all t(cid:48) (cid:31) t, we have that for all u(cid:48) ∈ Γt(cid:48), there exists
u ∈ Γt such that u is a preﬁx of u(cid:48).
The ﬁrst property is used for veriﬁcation and for reasoning
about security; the second and third properties are used for
key updates.
4.3 Construction
We assume the bound T is of the form 2(cid:96) − 1. We use
the above bijection so that the algorithms take input t ∈
{1,2}≤(cid:96)−1 instead of t ∈ [T ]. The following scheme is roughly
the result of applying the Canetti-Halevi-Katz technique to
obtain forward security from hierarchical identity-based en-
cryption (HIBE) [23] to the signature scheme determined by
the key structure of the Boneh-Boyen-Goh HIBE scheme [14];
we describe the differences at the end of this subsection.
Setup. Let M be the message space of the scheme and let
Hq : M → {0,1}κ be a hash function that maps messages
to bit strings of length κ such that 2κ < q. Apart from the
description of the groups, the common system parameters
also contain the maximum number of time slots T = 2(cid:96) − 1
and random group elements h,h0, . . . ,h(cid:96) ←$ G1. These pa-
rameters could, for example, be generated as the output of a
hash function modeled as a random oracle.
Key generation. Each signer chooses x ←$ Zq and computes
y ← gx
2. It sets its public to pk = y and computes its initial
1, . . . ,hr
for r ←$ Zq.
(cid:96)
Key update. We associate with each w ∈ {1,2}k with k ≤
secret key sk1 ← {(cid:101)skε} where (cid:101)skε =(cid:0)gr
(cid:96)− 1 a key (cid:101)skw of the form
(cid:101)skw = (c,d,ek+1, . . . ,e(cid:96))
(cid:19)
∏
for r ←$ Zq. Given (cid:101)skw, one can derive a key for any w(cid:48) ∈
k+1 , . . . , hr
hw j
j )r , hr
gr
2 , hx(h0
2 , hxhr
0 , hr
(cid:18)
(cid:1)
(1)
j=1
=
k
(cid:96)
{1,2}k(cid:48)
which contains w as a preﬁx as
(cid:18)
(c(cid:48),d(cid:48),e(cid:48)
k(cid:48)+1, . . . ,e(cid:48)
(cid:96)) =
c·gr(cid:48)
2 , d·
ew j
j
·(h0
k(cid:48)
∏
k(cid:48)
(cid:19)
∏
k(cid:48)+1 , . . . , e(cid:96) · hr(cid:48)
j=k+1
j=1
(cid:96)
j )r(cid:48)
hw j
,
(2)
ek(cid:48)+1 · hr(cid:48)
for r(cid:48) ←$ Zq.
The secret key skt at time period t is given by
skt = {(cid:101)skw : w ∈ Γt} ,
(cid:101)skt(cid:107)1 ← (c,d · e|t|+1,e|t|+2, . . . ,e(cid:96)) ,
preﬁx w of all nodes t(cid:48) (cid:23) t.
To perform a regular update of skt to skt+1, the signer users
the second property of Γt. Namely, if |t| < (cid:96)− 1, then the
which, by the ﬁrst property of Γt, contains a key (cid:101)skw for a
signer looks up (cid:101)skt = (c,d,e|t|+1, . . . ,e(cid:96)) ∈ skt, computes
and derives (cid:101)skt(cid:107)2 from (cid:101)skt using Equation (2). The signer
then sets skt+1 ← (skt \(cid:101)skt) ∪ {(cid:101)skt(cid:107)1,(cid:101)skt(cid:107)2} and securely
in the derivation of (cid:101)skt(cid:107)2.
If |t| = (cid:96)− 1, then the signer simply sets skt+1 ← skt \{(cid:101)skt}
the signer derives keys (cid:101)skw(cid:48) for all nodes w(cid:48) ∈ Γt(cid:48) \ Γt by
applying Equation (2) to the key (cid:101)skw ∈ skt such that w is a
Γt. The signer then sets skt(cid:48) ← {(cid:101)skw(cid:48) : w(cid:48) ∈ Γt(cid:48)} and securely
and securely deletes skt.
To perform a fast-forward update of its key to any time t(cid:48) (cid:23) t,
deletes skt as well as the re-randomization exponent r(cid:48) used
preﬁx of w(cid:48), which must exist due to the third property of
deletes skt as well as all re-randomization exponents used in
the key derivations.
2098    29th USENIX Security Symposium
USENIX Association
in time period t ∈ {1,2}≤(cid:96)−1, the signer looks up (cid:101)skt =
Signing. To generate a signature on message M ∈ M
(c,d,e|t|+1, . . . ,e(cid:96)) ∈ skt , chooses r(cid:48) ←$ Zq, and outputs
(cid:19)
(cid:18)
(cid:1)r(cid:48)
(σ1,σ2) =
d · eHq(M)
(cid:96)
j · hHq(M)
ht j
(cid:96)
, c· gr(cid:48)
2
.
·(cid:0)h0 ·
|t|
∏
j=1
Veriﬁcation. Anyone can verify a signature (σ1,σ2) ∈ G1 ×
G2 on message M under public key pk = y in time period t
by checking whether
e(σ1,g2) = e(h,y)· e(cid:0)h0 ·
(cid:1) .
|t|
∏
j=1
j · hHq(M)
ht j
(cid:96)
, σ2
Note that the pairing e(h,y) can be pre-computed from the