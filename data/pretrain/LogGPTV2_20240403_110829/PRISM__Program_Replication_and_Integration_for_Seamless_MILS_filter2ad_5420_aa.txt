# PRISM: Program Replication and Integration for Seamless MILS

**Authors:**
- Chris A. Owen
- Duncan A. Grove
- Tristan Newby
- Alex Murray
- Chris J. North
- Michael Pope

**Institution:**
C3I Division, Defence Science and Technology Organisation, Edinburgh, Australia

**Email:**
{Chris.Owen, Duncan.Grove, Tristan.Newby, Alex.Murray, Chris.North, Michael.Pope}@dsto.defence.gov.au

**Abstract:**
We present a method to integrate a minimal Trusted Computing Base (TCB) with polyinstantiated and slightly augmented Commercial Off The Shelf (COTS) software programs in separate Single Level Secure (SLS) partitions to create Multi-Level Secure (MLS) applications. These MLS applications can enforce fine-grained (intra-document) Bell LaPadula (BLP) separation between information at multiple security levels. Untrusted COTS programs in the SLS partitions send at-level file edits as diff transactions to the TCB. The TCB verifies that BLP semantics will be maintained and then patches these transactions into its canonical representation of the file. Finally, it releases appropriately filtered versions back to each SLS partition for re-assembly into the COTS program’s standard file format. By carefully restricting user interactions, the multiple SLS instances of the COTS program can appear as a single MLS instance. We demonstrate the utility of this approach using Microsoft Word and DokuWiki.

**Keywords:**
Computer security, Data security, Information security, Multilevel systems, Software architecture, Application virtualization, Military computing, Data storage systems, File systems, Information entropy

## 1. Introduction

Traditional Multi-Level Secure (MLS) information systems have either labeled individual files with the highest security level of the information they contain or relied on MLS databases. The latter requires the entire database engine to be trusted, which is beyond the current state of the art to prove formally. The former precludes trusted, fine-grained (intra-document) labeling of content. For example, Starlight [3] enforces strictly separate enclaves for information at different security levels but provides mechanisms to access that information in isolated domains. Although highly secure, this approach hinders users from combining information from different classifications, leading to fragmented user experiences. The MYSEA architecture [14] demonstrates a more integrated, albeit less trustworthy, approach using a wiki environment, but the granularity for different security levels is still limited to a page. Other approaches, like Compartmented Mode Workstation (CMW) [5], [18], apply a high-water mark model, "floating" files up to the highest security level of other processes that touch them. This over-classification quickly elevates everything to the highest level, constraining data availability and forcing users into frustrating and risky upgrade/downgrade cycles.

Unlike these approaches, our system, PRISM, uses a minimal cross-domain component to provide trustworthy separation of security levels while maintaining cross-domain structure within individual files, providing much finer-grained partitioning of MLS data. In this respect, our approach is similar to Galois' Trusted Services Engine (TCE) [12], although little detail has been published about how it works, making it difficult to understand its usability and security properties. The TCE is described as implementing a trusted "read down" mechanism where low-level data can be accessed from higher-level domains. High-side users can make high-level modifications to the data, presumably using some form of copy-on-write semantics. Separate TCB-mediated disks store information at different security levels. Additional untrusted "DocServer" software on the high side monitors the low-side file for modifications and merges those changes onto the high-level version of the document, though no details are provided.

Using this approach, high-level edits that alter low-level content (but within the high-level domain) are implicitly allowed. This is demonstrated in the TCE's main use case, where high-level users can edit both low- and high-level wiki content from the same high-level workstation. This drives the need for a fallible downgrading process, where ostensibly low-level information entered at a high security level needs to be examined, filtered, and resynchronized downwards to the low level.

Conversely, PRISM provides users with a simple mechanism for always editing MLS content at the appropriate security level, avoiding the need for risky downgrade procedures. PRISM generates fine-grained edit transactions and "pushes" them through a TCB to higher levels. In addition to providing the user with the apparent synchronization of data between security levels, frequent, fine-grained edit transactions help PRISM avoid merge conflicts. The interposed TCB also maintains a trusted, canonical MLS version of the file, assisting with trusted labeling and tracking of MLS information, simplifying release checking procedures, and allowing MLS documents to be cryptographically sealed and exported for offline use.

Section II outlines the architecture of our solution. Section III explains the underlying MLS file format, and Section IV describes the trusted processing required. For completeness, Section V briefly presents the cross-domain infrastructure we used to develop our prototypes. Sections VI and VIII demonstrate how we augmented Microsoft Word and DokuWiki to make them compatible with our approach. Section VII shows how we built upon these platforms to deliver a seamless user experience. Section IX analyzes the security properties of our solution, including potential covert channels and susceptibility to other threats. We conclude with possible avenues for further work.

## 2. The PRISM Architecture

The Multiple Independent Levels of Security (MILS) architecture [2] provides a robust framework for separating untrusted code (typically COTS software) from trusted, security-critical code. This enables the construction of complex yet highly assured applications by placing large and complex parts of applications in untrusted system-high partitions, while security-critical functions are separated into small, trusted components. This minimizes the Trusted Computing Base (TCB) comprising the security-critical functionality and greatly eases evaluation and certification efforts. For example, it substantially reduces the amount of formal mathematical modeling required to achieve Common Criteria (CC) certifications of Evaluation Assurance Level (EAL) 6+ and above, transforming an intractable problem into a manageable one.

The Annex Minisec device (versions 2 and 3) – on which we aim to publish details soon [10] – applies the MILS concept at both coarse and fine-grained levels. At the macroscopic level, a Minisec is composed of multiple self-contained computing systems (including CPU, RAM, storage, etc.) for running complete system-high COTS operating systems and associated software stacks. Each of these self-contained systems, called a partition, is typically associated with a distinct security level and may also form part of a wider network at that level, called an enclave. At the microscopic level, the Minisec’s dedicated TCB CPU runs an Annex Object Capability Reference Monitor (OCRM), an updated version of the Annex TCB described in [9] that we will describe more fully in [13]. Layered on top of this is a suite of objects implementing MLS critical functions that, in conjunction with the Minisec’s labeled networking mechanism, dynamically mediate each partition’s access to:
1. Local I/O devices such as a screen, keyboard, mouse, and audio.
2. Partitioned networking services for communicating with corresponding partitions in the same enclave on remote devices.
3. Between partitions (of inherently different security levels) on the same device.

This paper focuses on interactions of the third kind.

As shown in Figure 1, our PRISM architecture uses Program Replication and Integration for Seamless MILS (PRISM). It combines a minimal TCB with polyinstantiated and augmented COTS programs (rather than data) in separate SLS partitions to create MLS applications. The untrusted COTS applications in the separate system-high partitions are augmented with untrusted PRISM add-in modules that facilitate communication and synchronization with trusted components in the TCB, allowing coordinated fine-grained (intra-document) editing of MLS documents with Bell LaPadula (BLP) [6] separation by single or multiple users operating at multiple security levels.

This fusion of COTS software running in MILS domains under the policy control of a true MLS TCB delivers the best of all worlds: the power of COTS, the security properties of MILS, and the usability of native MLS. While this style of composition was anticipated in early MILS publications [2], [23], the modern concept of MILS appears to have degenerated to Multiple SLS (MSLS) type systems aimed at consolidating what are currently "air-gapped" guest operating systems. We suggest that our fine-grained PRISM architecture is returning to MILS' original roots, but propose that "Multiple Integrated Levels of Security" might better explain this type of architecture.

Figure 2 shows how an untrusted COTS application in the SLS partitions creates or edits a file. An untrusted but MLS-aware Differ applies delta compression [11] to translate any at-level modifications into diff transactions. These are communicated to the TCB, where a tiny MLS Verifier checks whether BLP security semantics will be preserved by the modifications. If so, the Patcher merges the changes into the canonical version of the file. The canonical version of the file may be maintained within the TCB partition, stored in a dedicated MLS storage partition, or hosted in what we term system-low mode as a TCB-encrypted file on one of the untrusted partitions. A tiny MLS Releaser then creates sanitized versions of the canonical file at each security level, stripping any higher-level content. Each of these sanitized versions is communicated back to the appropriate SLS partition, where an untrusted Assembler uses the filtered canonical representation to reconstruct the file into the COTS application’s standard file format.

This enables trusted separation of information at different security levels without needing to trust the COTS applications or the operating system partitions in which they reside. Our key insight was to combine program replication with a delta compression interface in a MILS framework to separate the untrusted editing application(s) from a minimal, trustworthy update and coordination mechanism.

Furthermore, all data is permanently classified at the security level of the edit session that created it. However, by making data easily accessible from any security level dominating partition, the need to upgrade and downgrade information is completely avoided in everyday use. Instead, upgrade and downgrade operations become rare, necessary only when explicitly re-grading data to a different level.

## 3. The MLSDoc File Format

Our canonical container file format for storing MLS data, called MLSDoc, prescribes a sequence of objects, each of which is simply a byte sequence at a particular security level. Where consecutive objects at the same classification occur—due to at-level additions or deletions of intervening higher-level content—these become merged into a single object. Consequently, each data byte of an MLSDoc is permanently linked within a data structure at the security level of the edit session that created it, resulting in strongly associated security labels at byte-level granularity.

Conceived with hierarchically arranged national security classifications in mind, the MLSDoc file format is ideally suited to storing application layer files that contain nested collections of objects in a tree structure, like XML files. Figure 3 depicts a conceptual example of such a file.

In general, we require that the root object be at the lowest security level of the document, as it is required to place other objects in context. Higher-level objects will exist near the leaves of the tree, for example, as annotations or additional paragraphs. At the byte level of the underlying canonical representation, these higher-level objects should appear to be embedded within low-level neighbors.

Figure 4 shows the MLSDoc file structure for the conceptual example in Figure 3. Data from each security level is segregated into different sections, with an Object Table containing the information required to assemble the various pieces from each section into the application file format. Each row of the section table contains a pointer to the start of data associated with that classification, the length of that data, and a version field. The version field, along with the UUID contained in the header, ensures that patches are applied to the correct version of an underlying MLSDoc. The rows of the object table indicate the sequence of objects, their classifications, and lengths; the pointers shown in Figure 4 are implicit, as any object follows straight after the previous one within any single security level.

Using a section-based structure allows layered encryption to be applied, safely and easily embedding higher-level data within a single file. It also assists with storing the information associated with any particular security level in separate memory pages or disk blocks if desired.

## 4. Trusted Processing

We required the code on the TCB that maintains separation to be minimal to allow assurance to a high level. Hence, the trusted patching process does not have any application file-specific awareness. The TCB simply treats each MLSDoc file as a sequence of objects, each represented as a byte string, where each object belongs to a single security level.

As indicated in Figure 2, several distinct components work in concert to provide the trusted functionality within PRISM. Because the underlying MLSDoc file format separates the classification structure of the document from the data itself, trusted release to any particular security level is simple: the TCB simply strips the sections and object table entries of any higher-level objects. This mode, which we call paranoid mode, permits coordinated MLS file editing with zero-bit-rate downwards covert channels. It provides at-level editors with read-only visibility of lower-level content and keeps them oblivious to higher-level content.

Although very usable, paranoid mode does leave the user open to making ordering errors with higher-level content. Instead, where security requirements are less stringent, the trusted release mechanism can export files in convenience mode, where higher-level content is instead replaced by inline markers indicating the presence of higher-level content. This helps prompt the user to avoid damaging—or assists them in mending—any higher-level structures altered by lower-level edits. While these markers can introduce potential covert channels or draw unwanted attention to otherwise innocuous statements, Section IX shows that the former can be managed, while protective briefings could be useful where the latter is of concern.

Lastly, the trusted releaser can export MLSDoc files in what we call system-low mode. Here, a signed and encrypted copy of the entire canonical MLSDoc is coupled with a paranoid mode file, potentially by embedding it in an application-file-specific comment field. This allows the document to be hosted within the enclave, transported to and imported through another TCB, or sent for offline processing by legacy systems elsewhere within the enclave. For example, a system-low file may be emailed or even transferred via CD or memory stick to someone else for editing on a system not equipped with PRISM capability. When the MLSDoc returns to a PRISM-capable environment, any changes can be merged via the TCB into the embedded system-low version of the canonical file.

To explain the trusted verification and patching components, it is necessary to first understand the structure of the MLS-aware patches these components are designed to receive from the untrusted differencing modules hosted in the SLS partitions.

We have adopted BSDiff [15] as a base for our PRISM patch format, as it matched our needs well. BSDiff provides a simple representation for encoding XOR-based differences (and hence copies in the degenerative case) and insertions to binary executable files. To further reduce the size of the trusted codebase, however, we constrained the existing specification to disallow differences and permit only copies and insertions.

Figure 5 shows the binary form, including a human-readable transliteration of the BSDiff-formatted patch corresponding to the delta between the Unclassified and Secret documents depicted in Figure 6. The patch consists of a header section identifying the MLSDoc and section version that the patch applies to, followed by the actual patch data.