title:Using Safety Properties to Generate Vulnerability Patches
author:Zhen Huang and
David Lie and
Gang Tan and
Trent Jaeger
2019 IEEE Symposium on Security and Privacy
Using Safety Properties to Generate Vulnerability Patches
Zhen Huang∗†, David Lie†, Gang Tan∗, Trent Jaeger∗
∗ Pennsylvania State University † University of Toronto
PI:EMAIL, PI:EMAIL, PI:EMAIL, PI:EMAIL
ABSTRACT
Security vulnerabilities are among the most critical software
defects in existence. When identiﬁed, programmers aim to
produce patches that prevent the vulnerability as quickly as
possible, motivating the need for automatic program repair
(APR) methods to generate patches automatically. Unfortu-
nately, most current APR methods fall short because they
approximate the properties necessary to prevent the vulner-
ability using examples. Approximations result in patches that
either do not ﬁx the vulnerability comprehensively, or may
even introduce new bugs. Instead, we propose property-based
APR, which uses human-speciﬁed, program-independent and
vulnerability-speciﬁc safety properties to derive source code
patches for security vulnerabilities. Unlike properties that
are approximated by observing the execution of test cases,
such safety properties are precise and complete. The primary
challenge lies in mapping such safety properties into source
code patches that can be instantiated into an existing program.
To address these challenges, we propose Senx, which, given
a set of safety properties and a single input that triggers
the vulnerability, detects the safety property violated by the
vulnerability input and generates a corresponding patch that
enforces the safety property and thus, removes the vulner-
ability. Senx solves several challenges with property-based
APR: it identiﬁes the program expressions and variables that
must be evaluated to check safety properties and identiﬁes
the program scopes where they can be evaluated, it generates
new code to selectively compute the values it needs if calling
existing program code would cause unwanted side effects,
and it uses a novel access range analysis technique to avoid
placing patches inside loops where it could incur performance
overhead. Our evaluation shows that the patches generated
by Senx successfully ﬁx 32 of 42 real-world vulnerabilities
from 11 applications including various tools or libraries for
manipulating graphics/media ﬁles, a programming language
interpreter, a relational database engine, a collection of pro-
gramming tools for creating and managing binary programs,
and a collection of basic ﬁle, shell, and text manipulation tools.
I. INTRODUCTION
Fixing security vulnerabilities in a timely manner is critical
to protect users from security compromises and to prevent
vendors from losing user conﬁdence. A recent study has shown
that creating software patches is often the bottleneck of ﬁxing
security vulnerabilities [19]. As a result, an entire line of
This work is mostly done while the ﬁrst author was a Ph.D candidate in the
Department of Electrical and Computer Engineering, University of Toronto.
research has studied Automated Program Repair (APR) [16],
[20], [26], [27], [30], [34], [39], [40], [54], [55], which takes
a program and a vulnerability and automatically provides a
patched program that ﬁxes the vulnerability.
Like patches produced by human developers, patches gen-
erated by APR tools aim to ﬁx a defect or vulnerability. Most
existing tools rely on a set of positive/negative example inputs
to ﬁnd a patch that makes the program behaves correctly on
those examples. They check if the patched program satisﬁes
the positive example inputs but result in errors on the negative
example inputs [30], [34], [36]. However, it is often difﬁcult
to obtain a complete set of example inputs, and the patched
program may not behave correctly on other inputs or the vul-
nerability that the patch intends to ﬁx may still be exploitable
given other inputs. Therefore, they can result in generating
patches that either do not ﬁx the vulnerability, or even worse,
introduce new bugs. We call this traditional method “example-
based”.
In this paper, we advocate a different approach, which we
term “property-based” APR. Property-based APR relies on
program-independent, vulnerability-speciﬁc, human-speciﬁed
safety properties. An example of such a safety property might
be that a program should not access beyond the end of a buffer
to rule out a buffer overﬂow vulnerability. The advantage
of this property-based approach is that a small set of safety
properties can be speciﬁed once and used on a vast number of
programs without the need to specify anything speciﬁc about
each of the programs, or collect a comprehensive set of test
cases. Moreover, such properties are inherently precise and
complete. In comparison to example-based APR, property-
based APR produces patches that work for all possible inputs;
this is especially important for security, which requires us not
leave holes for attackers.
Property-based APR differs from previous tools that enforce
a safety property comprehensively. Instead, APR enforces each
property with respect to a particular vulnerability and thus
can take advantage of the vulnerability’s context to generate
an efﬁcient and custom patch. For instance, SoftBound [32]
instruments a program to enforce memory safety on all buffers
and often results in high performance overhead. Property-
based APR in contrast takes a speciﬁc vulnerability (e.g., a
buffer-overﬂow vulnerability) as input and generates a patch
that targets that vulnerability.
The challenge of property-based APR boils down to de-
veloping a method that ensures that the appropriate safety
property is enforced. Unfortunately, property-based APR has
received limited attention in the literature [24], and has several
outstanding challenges that limit its applicability.
© 2019, Zhen Huang. Under license to IEEE.
DOI 10.1109/SP.2019.00071
539
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:43:21 UTC from IEEE Xplore.  Restrictions apply. 
the
First,
safety
because
properties
the APR tool must
enforced
are
vulnerability-speciﬁc,
identify the
correct property to enforce for a given vulnerability. In this
work, we assume that the input to the APR tool is only an
input
triggers the vulnerability, possibly crashing the
program. As a result, the APR tool must also correctly identify
the vulnerability and the corresponding safety property to
enforce.
that
Second, our goal is to generate source code patches that can
be adopted by developers. Because the safety properties are
generic and program-independent, they must be mapped onto
the variables in a program to generate a source code patch.
However, sometimes not all program constructs corresponding
to a safety property are available in the same program scope.
For example, the size of a buffer may be stored in a variable
available only in the function that allocates the buffer but not
in the function accesses the buffer. This requires a program
analysis that is able to generate equivalent expressions for
those safety property and select an intersecting set that is in
scope at a point in the program.
Third, some terms in a safety property may have to be
mapped onto expressions involving not only program variables
and constants, but also function calls. For example, a program
may always calculate the size of an object by making a
function call because the size is dynamic. Because function
calls may have side-effects, a patch must be careful not to
call any function with side-effects. As a result, an APR tool
need to check if a function has side-effects and may even need
to generate new functions in a program that compute required
values without introducing unwanted side effects.
Finally, many vulnerabilities depend on the number of times
a loop iterates. A naïve approach would simply check the
safety property on each loop iteration, resulting in performance
overhead. To reduce the performance impact of generated
patches, an APR tool should be aware of loops and generate a
patch that checks the safety property once outside of the loop
to avoid performance overhead.
In this paper, we propose Senx, which addresses the above
challenges to generate source code patches for security vulner-
abilities automatically using such vulnerability-speciﬁc safety
properties. Although Senx can in theory generate patches for
vulnerability for which a safety property can be speciﬁed, we
demonstrate Senx for three important classes of vulnerabilities:
buffer overﬂow, bad cast, and integer overﬂow. We ﬁnd that
Senx is able to produce correct patches for over 76% of the
vulnerabilities. The main reason Senx fails to generate a patch
for the rest is that it is unable to ﬁnd a place in the program
source code where all variables needed to evaluate the safety
property are in scope, which would require changes to function
prototypes to allow those variables to cross those scopes.
This paper makes the following main contributions:
• We describe how safety properties are speciﬁed in Senx
and demonstrate three example safety properties for
buffer overﬂow, bad cast, and integer overﬂow vulner-
abilities.
1 char * r e v ( const char * inp , char * o u t ) {
2
3
4
5
6
7
r e v e r s e a s t r i n g
i n p i s
o u t
( i n p != NULL) {
i n t
/ / F a i l e d t o c h e c k
s t r i n g
i s an o u t p u t b u f f e r
l e n = s t r l e n ( i n p ) ;
/ /
/ /
/ /
i f
i n p u t
t h e
i ,
i f
( l e n + 1  s i z e )
. . .
Listing 1: A program that reverses an input string. It contains
a buffer overﬂow in function rev.
• We describe the design of Senx, a property-based auto-
matic patch generation system that uses novel program
analysis techniques: expression translation, loop cloning,
and access range analysis.
• We prototype Senx on top of the KLEE symbolic exe-
cution engine and evaluate it on a corpus of 42 vulner-
abilities across 11 popular applications, including PHP
interpreter, sqlite database engine, binutils utilities for
creating and managing binary programs, and various
tools or libraries for manipulating graphics/media ﬁles.
Senx generates correct patches in 32 of the cases and
aborts the remainder because it is unable to determine
semantic correctness in the other cases. The evaluation
demonstrates that all three techniques are required to
generate patches, and that failure to ﬁnd a common
function scope in which to place a patch is the most
frequent reason for failure.
The structure of this paper is as follows. We motivate our
work in Section II. In Section III, we deﬁne and characterize
the problem Senx addresses. Section IV and Section V de-
scribe the design and implementation of Senx respectively.
Particularly we describe how Senx addresses the second
challenge in Section IV-D, the third and fourth challenges in
Section IV-C. We present evaluation results in Section VII and
discuss related work in Section VIII. Finally we conclude in
Section IX.
II. MOTIVATION
We discuss the limitations of state-of-art automatic patch
generation tools that Senx aims to address in this section. We
use the program in Listing 1 as the target program, which is
adopted from a real-world buffer overﬂow vulnerability CVE-
2012-0947 in a popular media stream processing library [42].
This program reverses an input string. It takes two inputs
from the command line, a string and an integer that speciﬁes
540
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:43:21 UTC from IEEE Xplore.  Restrictions apply. 
Type
P
P
N
N
argv[1]
1
2
1
2
argv[2]
A
AB
ABC
ABC
output
A
BA
CBA
CBA
expected output
A
BA
###
###
TABLE I: Test inputs and outputs for the program in Listing 1.
Type ’P’ test inputs are positive test inputs, while type ’N’ test
inputs are negative test inputs.
the length of the string, and outputs the reversed string. If
an error occurs, the program outputs "###". To do this, it
dynamically allocates a temporary buffer based in a value
passed to it, and copies the input into the buffer. Like the
real vulnerability, the allocation of the output buffer and the
processing of the input string are implemented in two different
functions. This example is typical of programs that process
audio/video streams.
The buffer overﬂow occurs when the speciﬁed length, from
the input integer, is smaller than the actual length of the input
string. The buffer overﬂow can be ﬁxed by adding a check that
enforces that the actual length of the string is smaller than the
allocated size of the buffer it is being copied into. Because the
buffer size is only known in main, the check should be added
at line 19 and compare size with strlen(argv[2]).
While such checks are easily added by human developers to
patch vulnerabilities — indeed such a check is found in the
human-generated patch for the vulnerability this code example
is based on [42] — it poses challenges for current APR tools.
We describe these challenges in more detail below.
Example-based approaches. Many APR tools use example
inputs as the basis for ﬁxing vulnerabilities [29], [30], [34],
[55]. For example, SemFix and Angelix collect path con-
straints to generate ﬁxes [30], [34].
This approach leads to two problems. First, the constraints
generated often only capture constraints based on the concrete
values used in the test cases and not constraints on the
relationships between program variables. To illustrate, Table I
lists typical test inputs needed to use such tools, which we
imagine might be used by such tools for our example in
Listing 1.
Given these test cases, SemFix and Angelix would see that
argv[1] having a value of 1 or 2 are not correlated with
the negative test cases, since they take on those values in both
positive and negative test cases. Thus, it would incorrectly
infer that strlen(argv[2])  2. This illustrates the
shortcoming of example-based systems as they can easily fall
prey to missing cases in the test suite, which are notoriously
difﬁcult to make complete.
Property-based approaches. AutoPaG [24] also uses a safety
property-like predicate to create patches. However, AutoPaG
only handles one type of vulnerability, buffer overﬂows, so
it does not need to identify the type of vulnerabilities to
enforce the appropriate safety property—it fails to generate
a correct patch if the vulnerability is any type other than a
buffer overﬂow.
In addition, AutoPaG cannot generate a patch if the location
that the safety property needs to be enforced is not in the same
function where the vulnerability occurs. In our example, the
buffer overﬂow occurs in the rev function, but the patch must
be places in main.
Finally, AutoPaG enforces its safety property by instru-
menting the code at runtime. In Listing 1, AutoPaG would
instrument and check the buffer size inside the for loop
on line 8, causing performance overhead. In contrast, Senx
symbolically extracts the memory range the loop accesses by
analyzing the loop bounds, allowing it to check the safety
property outside of the loop.
III. PROBLEM DEFINITION
We begin by deﬁning what a Senx patch is, what guarantees
a Senx patch provides and how Senx’s vulnerability-speciﬁc
safety properties are deﬁned.
A. Patch
To generate a patch, Senx requires an input that can trigger
the target vulnerability. Typically, this is the type of input that
one could derive from a proof-of-concept exploit or an input
generated by a fuzzer that can crash the program. From this,
Senx generates a patch that ensures that all safety properties
it supports hold, where each safety property corresponds to a
particular type of vulnerability. A Senx patch can take one of
two forms: a) detects if a safety property no longer holds and
if so, raises an error to direct program execution away from the
path where the vulnerability resides (we call this a check-and-
error patch); b) prevents a safety property from being violated
(we call this a repair patch).
B. Safety Properties
Each safety property corresponds to a vulnerability type,
and is an abstract boolean expression that when mapped to
concrete variables in a program can be evaluated. We describe
the two types of safety properties Senx currently supports.
Buffer overﬂows. A buffer overﬂow occurs when a series of
memory accesses traversing a buffer crosses from a memory
location inside the buffer to a memory location outside of the
buffer. The corresponding Senx safety property deﬁnes two
abstract values: a memory access and a buffer. Senx uses the
term buffer to refer to any bounded memory region, which
may include structs, objects or arrays. A memory access may
correspond to an array dereference or pointer dereference, but
must occur inside a loop. This safety property covers both the
case when the memory access exceeds the upper range of the
buffer and the case when the memory access falls below the
lower range (sometimes called a buffer underﬂow).
Bad casts. This safety property checks that a memory accesses