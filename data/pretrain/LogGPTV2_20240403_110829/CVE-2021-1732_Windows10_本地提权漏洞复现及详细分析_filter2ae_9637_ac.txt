往后，微软去掉了 pdb 文件中很多内核符号，其中就包括 tagWND。所以目前，我们只能通过参考 Win7 及以前的符号，并结合 API 逆向分析来推测
Win10 中 tagWND 各字段的含义。
值得庆幸的是，已经有人在这方面做了很多工作了。在前辈们的经验总结下[8][9][10]，我们可以得知，在 Win10 中，
**对于每个窗口，系统为用户层和内核层各维护了一个 tagWND 结构体** ，用户层的 &tagWND + 0x28 处的 8 字节为一个指针，指向内核层
tagWND 结构体。后文将使用 tagWND/tagWNDk 来表示 用户层/内核层 tagWND 结构体，ptagWND/ptagWNDk 来表示
用户层/内核层 tagWND 结构体指针。
下面列出 tagWND 结构体中与漏洞相关的字段（一个 “Tab 缩进 + 偏移量”表示一次 **父级的值加偏移后访存** ）：
    ptagWND(user layer)
        0x10 unknown
            0x00 pTEB
                0x220 pEPROCESS(of current process)
        0x18 unknown
            0x80 kernel desktop heap base
        0x28 ptagWNDk(kernel layer)
            0x00 hwnd
            0x08 kernel desktop heap base offset
            0x18 dwStyle
            0x58 Window Rect left
            0x5C Window Rect top
            0x98 spMenu(uninitialized)
            0xC8 cbWndExtra
            0xE8 dwExtraFlag
            0x128 pExtraBytes
        0x90 spMenu(analyzed by myself)
            0x00 hMenu
            0x18 unknown0
                0x100 unknown
                    0x00 pEPROCESS(of current process)
            0x28 unknown1
                0x2C cItems(for check)
            0x40 unknown2(for check)
            0x44 unknown3(for check)
            0x50 ptagWND
            0x58 rgItems
                0x00 unknown(for exploit)
            0x98 spMenuk
                0x00 pSelf
后面的分析在用到 tagWND 时，可以翻回这个部分进行查阅。
###  3.3 以结果为导向
本 CVE 的 POC 所达到的效果，就是可以在用户态调用 SetWindowLong 来造成一次 **内核桌面堆的越界写** 。SetWindowLong
实际调用 user32!SetWindowLongW，其中又调用了 win32u!NtUserSetWindowLong：
之后通过系统调用进入内核态，调用 win32kfull!NtUserSetWindowLong，并最终调用
win32kfull!xxxSetWindowLong，传入根据窗口句柄找到的 tagWND
结构体地址（ptagWND）、写入的扩展内存的偏移（nIndex）、要写入的值（value）：
调用栈我也贴在这里：
进入 xxxSetWindowLong 后，在 59 行获得了内核 tagWND 结构体指针：
从 117 行可以看出 **nIndex 的值必须小于 ptagWNDk- >cbWndExtra**（窗口扩展内存大小，该值在注册窗口类时指定）：
由 157、158、162 行可知当 `ptagWNDk->dwExtraFlag & 0x800 != 0` 时， **内核桌面堆起始地址 +
pExtraBytes + nIndex** 处的 4 字节会被赋值成 value：
POC 就是通过控制 pExtraBytes 为任意值来实现桌面堆越界写的。从上图的 160 行也可以看出，当 `ptagWNDk->dwExtraFlag
& 0x800 == 0` 时，pExtraBytes 就解释为一个 **可写内存的地址** ，直接通过 `pExtraBytes + nIndex`
来寻址。
故我们发现，tagWNDk 实际上使用 **两种模式** 来保存 **窗口扩展内存的地址** ：
  * 1.dwExtraFlag & 0x800 == 0：在 **用户空间系统堆** 中，pExtraBytes 解释为 **扩展内存** 在 **用户空间堆** 中的地址指针
  * 2.dwExtraFlag & 0x800 != 0：在 **内核空间桌面堆** 中，pExtraBytes 解释为该 **扩展内存起始地址** 相对于 **内核桌面堆基址** 的偏移量
下一部分就将介绍正常情况下两种模式对应的 pExtraBytes 是如何被赋值的。
###  3.4 两种模式下 pExtraBytes 正常赋值流程
> 3.4.1 模式 1 – 在用户空间系统堆中（直接寻址模式）
该模式下，tagWNDk.pExtraBytes 在调用 CreateWindowEx 创建窗口的过程中被赋值。前半部分的调用链没有什么信息量：
    [用户态]
    - CreateWindowEx 实际调用 user32!CreateWindowExW
    - user32!CreateWindowExW 调用 user32!CreateWindowInternal
    - user32!CreateWindowInternal 中调用 user32!VerNtUserCreateWindowEx
    - user32!VerNtUserCreateWindowEx 中调用 win32u!NtUserCreateWindowEx
    - win32u!NtUserCreateWindowEx 中通过系统调用进入内核态，调用 win32kfull!NtUserCreateWindowEx
    [内核态]
    - win32kfull!NtUserCreateWindowEx 中调用 win32kfull!xxxCreateWindowEx
调用栈：
xxxCreateWindowEx 506 行调用 win32kbase!HMAllocObject 创建了一个 tagWND 结构体并返回其指针：
521 行设置 ptagWNDk->pExtraBytes 初值为 0（`*(ptagWND + 0x28)` 为 ptagWNDk）：
从 821、822 行可以看出，当 ptagWNDk->cbWndExtra 不为 0 时，会调用
win32kfull!xxxClientAllocWindowClassExtraBytes 来设置 ptagWNDk->pExtraBytes：
821 行的不等号重载（0xA1 – 0x79 = 0x28）：
win32kfull!xxxClientAllocWindowClassExtraBytes 实现：
阅读代码后，不难发现：
  * 22 行：通过 nt!KeUserModeCallback[11] 回调记录在 **PEB.KernelCallbackTable 表中第 123 项** 的用户层函数，该项是 **user32!_xxxClientAllocWindowClassExtraBytes** 函数的指针
  * 26 行：user32!_xxxClientAllocWindowClassExtraBytes **返回信息的长度应该为 0x18 字节**
  * 29 行：存储返回信息的地址需小于 MmUserProbeAddress（0x7fffffff0000）
  * 31 行： **返回信息的第一个指针类型指向在用户态申请的用户堆空间**
  * 34 行：调用 ProbeForRead 验证申请的用户堆地址 + 长度是否小于 MmUserProbeAddress（0x7fffffff0000）
  * 32、35 行：xxxClientAllocWindowClassExtraBytes 返回用户堆空间地址
user32!_xxxClientAllocWindowClassExtraBytes 函数：
该回调函数所做的事情就是调用 ntdll!RtlAllocateHeap 申请 cbWndExtra
大小的用户堆空间，并将申请到的堆地址作为返回信息的第一个 8 字节， **调用 ntdll!NtCallbackReturn
修正堆栈后重新返回内核层执行** 。
win32kfull!xxxClientAllocWindowClassExtraBytes 返回后，ptagWNDk->pExtraBytes
就会被赋值为申请到的用户空间堆地址：
以上过程用 iamelli0t 博客[12]的一张图来总结：
> 3.4.2 模式 2 – 在系统空间桌面堆中（offset 间接寻址模式）
在该模式下想要赋值 pExtraBytes，须在用户态调用未公开的 user32!ConsoleControl（或
**win32u!NtUserConsoleControl** ），调用栈：
win32kfull!NtUserConsoleControl 函数：
由上图可知，要想调用 xxxConsoleControl，需满足：
  * 14 行：第一个参数（ **功能号** ）不大于 6
  * 16 行：第三个参数（ **参数信息的长度** ）不大于 0x18
win32kfull!xxxConsoleControl 根据传入的功能号进行不同的操作，一共有 6 种功能（功能号为 1 – 6）， **第 6
个功能才会赋值 pExtraBytes** ：
由上图分析可得，功能 6 调用 DesktopAlloc
在内核空间桌面堆中分配窗口扩展内存，计算已分配的扩展内存地址到内核桌面堆基址的偏移量，并将偏移量保存到 tagWNDk.pExtraBytes，最后修改
`tagWNDk.dwExtraFlag |= 0x800`。
###  3.5 POC 攻击手法及难点解决
经过上面的分析我们已经知道：
  * 1.使用 CreateWindowEx 创建窗口的过程中内核会回调用户层函数 user32!_xxxClientAllocWindowClassExtraBytes，由它代为申请用户空间堆，内核用这个地址赋值 pExtraBytes 后， **并未重新设置 dwExtraFlag** （`tagWNDk.dwExtraFlag &= ~0x800`）
  * 2.使用 user32!ConsoleControl 的第 6 个功能，除了能赋值 pExtraBytes，还能设置 `tagWNDk.dwExtraFlag |= 0x800`
  * 3.调用 SetWindowLong 写窗口扩展内存时，如果 `dwExtraFlag & 0x800 != 0`，则使用 offset 间接寻址方式写桌面堆
在 POC 中，攻击者对 user32!_xxxClientAllocWindowClassExtraBytes 进行挂钩， **在钩子函数中手动调用
win32u!NtUserConsoleControl** ，将 pExtraBytes 的解释方式从模式 1 修改为模式 2，然后调用
ntdll!NtCallbackReturn 向内核返回一个能过读写检查的可控值，用于设置 tagWNDk.pExtraBytes。最后调用
SetWindowLong 写附加空间时，就能实现基于内核空间桌面堆基址的可控偏移量越界写。
还是借用 iamelli0t[12] 的图来直观感受：
设想是美好的，实践起来还会遇到细节上的问题 —— 上个部分所提到的 win32kfull!xxxConsoleControl 功能 6 需要传入
**窗口句柄** ：
可攻击需要在 CreateWindowEx 过程里调用 user32!ConsoleControl，此时 CreateWindowEx 还没有返回窗口句柄
HWND，这就需要我们来分析 CreateWindowEx 是怎么创建的窗口句柄。其实在 **3.4.1 节** 我提了一下
xxxCreateWindowEx 506 行调用 win32kbase!HMAllocObject 创建了一个 tagWND 结构体并返回其指针：
窗口句柄就是在这个函数中创建并赋值到 tagWND 结构体中的，该函数首先通过 DesktopAlloc 从内核桌面堆申请存储 tagWNDk 的空间：
然后选出一个 **窗口句柄** [13]并 **存储到 &tagWNDk + 0**：
此外，结合上两张图可以发现 **& tagWNDk + 8 保存了 tagWNDk 相对于桌面堆基址的偏移**。
幸运的是， user32!_xxxClientAllocWindowClassExtraBytes 之前，win32kbase!HMAllocObject
就已经在 win32kfull!xxxCreateWindowEx 中被调用了，我们要是能把创建的窗口句柄泄露出来就可以补全 POC 链了，问题就转化为
**如何泄露 tagWNDk 的内容** 。
这就不得不提起 Windows 内核利用领域使用了 10 年的一项技术 —— 通过未公开函数 user32!HMValidateHandle
泄露内核信息[14]，只要把窗口句柄传递给这个函数，它就会 **返回 tagWNDk 在用户空间的只读映射指针** （HMAllocObject
创建了桌面堆类型句柄后，会把tagWNDk 对象放入到内核模式到用户模式的映射内存中）。此外，HMValidateHandle 函数的地址可以由
user32!IsMenu 的第一个 call 计算[14]。
那么泄露窗口句柄的难点就迎刃而解了，直接来看完整的 POC 思路：
  * 1.将 PEB.KernelCallbackTable 的第 123 项替换成自定义挂钩函数的指针
  * 2.创建一些窗口（都属于窗口类 1），并通过 user32!HMValidateHandle 泄露这些窗口对应 tagWNDk 在用户空间的地址
  * 3.销毁在步骤 2 中创建的部分窗口，使得桌面堆能回收这些窗口对象所占用的空间。再使用与窗口类 1 cbWndExtra 不同的窗口类 2 创建一个新窗口，这个新窗口的 tagWNDk 对象可能会 **使用之前释放掉的空间** 。因此，通过在自定义挂钩函数中使用窗口类 2 的 cbWndExtra 搜索先前泄露的 tagWNDk 对象用户空间地址，便可以找到新窗口的 tagWNDk 在用户空间的地址，读取第一个 8 字节即可泄露窗口句柄。
  * 4.在自定义挂钩函数中调用 user32!ConsoleControl 来修改新窗口 `tagWNDk.dwExtraFlag |= 0x800`
  * 5.在自定义挂钩函数中调用 ntdll!NtCallbackReturn 将可控的虚假偏移量分配给新窗口的 tagWNDk.pExtraBytes
  * 6.调用 SetWindowLong 将数据写入内核空间桌面堆基址 + 可控偏移量的地址，这可能会导致超出堆范围的内存访问冲突
这些步骤都会在 **04 部分** 体现。
###  3.6 EXP 利用手法及难点解决
对于内核漏洞利用，攻击目标通常是获得 System 令牌，常见的方法如下：
  * 1.利用漏洞在内核空间中获得任意地址读写的原语
  * 2.泄露一些内核对象的地址，通过 EPROCESS 链找到 System 进程
  * 3.将 System 进程的令牌复制到攻击进程以完成权限提升
我们所面临的困难主要是步骤 1 —— 如何利用”在内核空间桌面堆基地址 +
可控偏移量计算出的地址中写数据”的机会来获取内核空间任意地址读写的原语。本部分将注重逻辑分析，具体实施细节在 **04 部分** 。
> 3.6.1 任意地址写
由 **3.3 节** 的分析，调用 SetWindowLong 时，传递的 nIndex 必须小于
tagWNDk.cbWndExtra，若是能把该值改大，就能轻松造成内存访问越界。参考 **3.5 节** ，tagWNDk + 8 的地方保存着该
tagWNDk 相对于桌面堆基址的偏移。结合这两点，可以构造如下的内存布局：
首先通过漏洞将 tagWNDk2.pExtraBytes 设置为 offset 模式寻址（dwExtraFlag |= 0x800），并将其赋值为
tagWNDk0 相对于桌面堆基址的偏移（`*(&tagWNDk0 + 8)`），于是窗口 2 的扩展内存变成了 tagWNDk0 所在的空间。对窗口 2
调用 SetWindowLong，nIndex 为 **cbWndExtra 在结构体中的偏移（0xC8）** ，就能修改到
tagWNDk0.cbWndExtra 了，我们把它改成 0xFFFFFFFF，cbWndExtra 过小的限制就解除了！为了能通过窗口 0
的扩展内存写到窗口 1 的 tagWNDk，还需要提前使用 win32u!NtUserConsoleControl 来让窗口 0 也进入 offset
寻址模式。
现在对窗口 0 调用 SetWindowLongPtr，nIndex 为 **窗口 0 扩展内存与窗口 1 tagWNDk 的偏移 +
pExtraBytes 在结构体中的偏移（0x128）** ，修改 tagWNDk1.pExtraBytes 为任意值。又因为
tagWNDk1.pExtraBytes 处于直接寻址模式，再对窗口 1 调用 SetWindowLongPtr 就能实现任意地址写了。
> 3.6.2 任意地址读
EXP 中使用 user32!GetMenuBarInfo[15] 函数与伪造的 tagMENU
结构体进行内核读取，一次可以读取16个字节，这种巧妙的手法此前未被公开过。该 API 最终会调用
win32kfull!xxxGetMenuBarInfo，并传入 4 个参数 ptagWND，idObject，idItem，&mbi[16]：
结合 **3.2 节** ：
    ptagWND(user layer)
        0x28 ptagWNDk(kernel layer)
            0x18 dwStyle
            0x58 Window Rect left