### 优化后的文本

#### 4. CBASE与BASE的开销对比
图4展示了CBASE和BASE在不同客户端数量下的CPU开销。CBASE运行时使用16个执行线程，而BASE仅使用1个线程。图中所有数据点均为3次运行结果的平均值，方差小于15%。CBASE并行器将所有请求视为独立的，但由于硬件资源有限，并发请求带来的好处受到限制——这些请求在一个单处理器上运行并立即返回。从图4可以看出，CBASE和BASE的曲线非常接近，说明在没有并发执行请求的情况下，CBASE引入的开销很小。

#### 6.1.2. 应用程序并行性和资源对吞吐量可扩展性的影响
服务的吞吐量不仅取决于应用程序中的并行性，还取决于系统可用的硬件资源（例如处理器、磁盘、带宽）。在这一系列实验中，我们评估了吞吐量随应用程序并行性和硬件资源变化的可扩展性。

首先，我们评估了吞吐量随资源增加的扩展能力。通过修改基准测试代码，使其在处理每个请求时暂停20毫秒后返回响应，我们模拟了对一组并行磁盘的访问。CBASE并行器假设应用程序具有无限的并行性，并将所有请求视为独立的。我们通过配置CBASE以不同的执行线程数来模拟不同的“磁盘”资源。值得注意的是，BASE仍然只使用一个线程，因为它不会同时向执行阶段发出多个请求。图5(a)显示，当每个操作的服务时间为20毫秒时，BASE的吞吐量饱和于50 ops/sec，这与CBASE使用1个线程时的吞吐量一致。随着客户端数量的增加，CBASE的吞吐量也逐渐增加，但最终会达到饱和，因为只有当吞吐量受限于硬件资源时，增加客户端数量才能提高并发性。随着“磁盘”（线程）数量的增加，CBASE的吞吐量几乎呈线性增长——128个“磁盘”可以达到4700 requests/second的吞吐量。

接下来，我们评估了吞吐量随应用程序并行性增加的扩展能力。我们在固定资源数量的情况下进行实验，改变应用程序的并行性。通过将CBASE的执行线程数固定为100，我们模拟了100个资源。我们将并行因子定义为允许并发执行的请求数量，并通过改变这个参数来模拟不同的应用程序并行性。并行器随机将每个传入请求分配到并行因子桶中，并在同一桶内的所有请求之间创建依赖关系，从而在任何时间点只允许一定数量的请求是独立的。图5(b)显示，当应用程序并行因子为1时，BASE的吞吐量饱和于50 ops/sec，CBASE在此情况下的性能与此相同。随着并行因子的增加，CBASE的最大吞吐量几乎呈线性增长，直到并行因子达到100。由于受模拟的100个硬件资源限制，CBASE的吞吐量在并行因子超过100后不再提升。

#### 6.2. NFS微基准测试
在本小节中，我们评估了CBASE-FS（一种使用CBASE的复制NFS）的性能，并将其与BASE-FS和未复制的NFS进行了比较。

##### 6.2.1. 本地磁盘
在这个基准测试中，每个客户端向文件系统导出目录中的不同文件写入4KB的数据。我们改变并发客户端的数量，并测量系统的响应时间和吞吐量。如第4节所述，对不同文件的请求被视为独立的。

希望这些改进能够使您的文本更加清晰、连贯和专业。如果还有其他需要优化的部分，请告诉我！