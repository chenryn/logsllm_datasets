while (getline(line, MAXLINE) > 0)
if (strindex(line, pattern) >= 0) { printf("%s", line);
found++;
}
return found;
}
/* getline:              get line into s, return length */ int getline(char s[], int lim)
{
int c, i;
i = 0;
while (••lim > 0 && (c=getchar()) != EOF && c != '\n') s[i++] = c;
if (c == '\n')
s[i++] = c; s[i] = '\0'; return i;
}
/* strindex:              return index of t in s, •1 if none */ int strindex(char s[], char t[])
{
int i, j, k;
for (i = 0; s[i] != '\0'; i++) {
for (j=i, k=0; t[k]!='\0' && s[j]==t[k]; j++, k++)
;
if (k > 0 && t[k] == '\0') return i;
}
return •1;
}
函数的定义形式如下:
返回值类型 函数明(参数声明表)
{
声明和语句
}
函数定义中的各构成部分都可以省略。最简单的函数如下所示:
dummy() {}
该函数不执行任何操作也不返回任何值。这种不执行任何操作的函数有时很有用，它可以在 程序开发期间用以保留位置(留待以后填充代码)。如果函数定义中省略了返回值类型，则默 认为 int 类型。
程序可以看成是变量定义和函数定义的集台。函数之间的通信可以通过参数、函数返回 值以及外部变量进行。函数在源文件中出现的次序可以是任意的。只要保证每一个函数不被 分离到多个文件中，源程序就可以分成多个文件。
被调用函数通过 return 语句向调用者返回值，return 语句的后面可以跟任何表达式:
return 表达式; 在必要时，表达式将被转换为函数的返回值类型。表达式两边通常加一对圆括号，此处的括
号是可选的。
调用函数可以忽略返回值。并且，return 语句的后面也不一定需要表达式。当 return 语句的后面没有表达式时，函数将不向调用者返回值。当被调用函数执行到最后的右花括号 而结束执行时，控制同样也会返回给调用者(不返回值)。如果某个函数从一个地方返回时有 返回值，而从另一个地方返回时没有返回值，该函数并不非法，但可能是一种出问题的征兆。 在任何情况下，如果函数没有成功地返回一个值，则它的"值"肯定是无用的。
在上面的模式查找程序中，主程序 main 返回了一个状态，即匹配的数目。该返回值可以 在调用该程序的环境中使用。
在不同的系统中，保存在多个源义件中的 C 语言程序的编译与加载机制是不同的。例如， 在 UNIX 系统中，可以使用第 1 章中提到过的 cc 命令执行这一任务。假定有 3 个函数分别存 放在名为 main.c、getline.c 与 strindex.c 的 3 个文件中，则可以使用命令
cc main.c getline.c strindex.c
来编 译这 3 个 文件 ，并把 生成 的目标 代码 分别存 放在 文件 main.o 、 getline.o 与
strindex.o 中，然后再把这 3 个文件一起加载到可执行文件 a.out 中。如果源程序中存在 错误(比如文件 main.c 中存在错误)，则可以通过命令
cc main.c getline.o strindex.o
对 main.c 文件重新编译，并将编译的结果与以前已编译过的目标文件 getline.o 和 strindex.o 一起加载到可执行文件中。cc 命令使用“ .c"与“ .o"这两种扩展名来区分 源文件与目标文件。
练习 4•1             编写函数 strindex(s, t)，它返回字符串 t 在 s 中最右边出现的位置。 如果 s 中不包含 t，则返回•1。
4.2 返回非整型值的函数
到目前为止，我们所讨论的函数都是不返回任何值(void)或只返回  int 类型值的函数。 假如某个函数必须返回其它类型的值，该怎么办昵?许多数值函数(如  sqrt、sin 与  cos 等函数)返回的是  double 类型的值，某些专用函数则返回其它类型的值。我们通过函数 atof(s)来说明函数返回非整型值的方法。该函数把字符串 s 转换为相应的双精度浮点数。 atof 函数是 atoi 函数的扩展，第 2 章与第 3 章已讨论了 atoi 函数的几个版本。atof 函 数需要处理可选的符号和小数点，并要考虑可能缺少整数部分或小数部分的情况。我们这里 编写的版本并不是一个高质量的输入转换函数，它占用了过多的空间。标准库中包含类似功 能的 atof 函数，在头文件中声明。
首先，由于 atof 函数的返回值类型不是 int，因此该函数必须声明返回值的类型。返回 值的类型名应放在函数名字之前，如下所示:
#include 
/* atof:              convert string s to double */ double atof(char s[])
{
double val, power; int i, sign;
for (i = 0; isspace(s[i]); i++)              /* skip white space */
;
sign = (s[i] == '•') ? •1 : 1;
if (s[i] == '+' || s[i] == '•') i++;
for (val = 0.0; isdigit(s[i]); i++) val = 10.0 * val + (s[i] • '0');
if (s[i] == '.') i++;
for (power = 1.0; isdigit(s[i]); i++) {
val = 10.0 * val + (s[i] • '0'); power *= 10;
}
return sign * val / power;
}
其次，调用函数必须知道 atof 函数返回的是非整型值，这一点也是很重要的。为了达到 该目的，一种方法是在调用函数中显式声明 atof 函数。下面所示的基本计算器程序(仅适用
于支票簿计算)中有类似的声明。该程序在每行中读取一个数(数的前面可能有正负号)，并 对它们求和，在每次输入完成后把这些数的累计总和打印出来:
#include 
#define MAXLINE 100
/* rudimentary calculator */ main()
{
double sum, atof(char []); char line[MAXLINE];
int getline(char line[], int max);
sum = 0;
while (getline(line, MAXLINE) > 0) printf("\t%g\n", sum += atof(line));
return 0;
}
其中，声明语句
double sum, atof(char []);
表明 sum 是一个 double 类型的变量，atof 函数带有个 char[]类型的参数，且返回一个 double 类型的值。
函数 atof 的声明与定义必须一致。如果 atof 函数与调用它的主函数 main 放在同一源 文件中，并且类型不一致，编译器就会检测到该错误。但是，如果 atof 函数是单独编译的(这 种可能性更大)，这种不匹配的错误就无法检测出来，atof 函数将返回 double 类型的值， 而 main 函数却将返回值按照 int 类型处理，最后的结果值毫无意义。
根据前面有关函数的声明如何与定义保持一致的讨论，发生不匹配现象似乎很令人吃惊。 其中的一个原因是，如果没有函数原型，则函数将在第一次出现的表达式中被隐式声明，例 如:
sum += atof(line)
如果先前没有声明过的一个名字出现在某个表达式中，并且其后紧跟一个左圆括号，那么上 下文就会认为该名字是一个函数名字，该函数的返回值将被假定为 int 类型，但上下文并不 对其参数作任何假设。并且，如果函数声明中不包含参数，例如:
double atof();
那么编译程序也不会对函数 atof 的参数作任何假设，并会关闭所有的参数检查。对空参数表 的这种特殊处理是为了使新的编译器能编译比较老的 C 语言程序。不过，在新编写的程序中 这么做是不提倡的。如果函数带有参数，则要声明它们;如果没有参数，则使用 void 进行声 明。
在正确进行声明的函数 atof 的基础上，我们可以利用它编写出函数 atoi(将字符串转 换为 int 类型):
/* atoi:              convert string s to integer using atof */ int atoi(char s[])
{
double atof(char s[]);
return (int) atof(s);
}
请注意其中的声明和 return 语句的结构。在下列形式的 return 语句中:
return(表达式);
其中，表达式的值在返回之前将被转换为函数的类型。因为函数 atoi 的返回值为 int 类型， 所以，return 语句中的 atof 函数的 double 类型值将被自动转换为 int 类型值。但是， 这种操作可能会丢失信息，某些编译器可能会对此给出警告信息。在该函数中，由于采用了 类型转换的方法显式表明了所要执行的转换操作，因此可以防止有关的警告信息。
练习 4•2             对 atof 函数进行扩充，使它可以处理形如
123.45e•6
的科学表示法，其中，浮点数后面可能会紧跟一个 e 或 E 以及一个指数(可能有正负号)。
4.3 外部变量
C 语言程序可以看成由一系列的外部对象构成，这些外部对象可能是变量或函数。形容词 external 与 internal 相对的，internal 用于描述定义在函数内部的函数参数及变量。外部变量定 义在函数之外，因此可以在许多函数中使用。由于 C 语言不允许在一个函数中定义其它函数， 因此函数本身是"外部的"。默认情况下，外部变量与函数具有下列性质:通过同一个名字对 外部变量的所有引用(即使这种引用来自于单独编译的不同函数)实际上都是引用同一个对 象(标准中把这一性质称为外部链接)。在这个意义上，外部变量类似于   Fortran   语言的 COMMON 块或 Pascal 语言中在最外层程序块中声明的变量。我们将在后面介绍如何定义只能 在某一个源文件中使用的外部变量与函数。
因为外部变量可以在全局范围内访问，这就为函数之间的数据交换提供了一种可以代替 函数参数与返回值的方式。任何函数都可以通过名字访问一个外部变量，当然这个名字需要 通过某种方式进行声明。
如果函数之间需要其享大量的变量，使用外部变量要比使用一个很长的参数表更方便、 有效。但是，我们在第 1 章中已经指出，这样做必须非常谨慎，因为这种方式可能对程序结 构产生不良的影响，而且可能会导致程序中各个函数之间具有太多的数据联系。
外部变量的用途还表现在它们与内部变量相比具有更大的作用域和更长的生存期。自动 变量只能在函数内部使用，从其所在的函数被调用时变量开始存在，在函数退出时变量也将 消失。而外部变量是永久存在的，它们的值在一次函数调用到下一次函数调用之间保持不变。 因此，如果两个函数必须共享某些数据，而这两个函数互不调用对方，这种情况下最方便的 方式便是把这些共享数据定义为外部变量，而不是作为函数参数传递。
下面我们通过一个更复杂的例子来说明这一点。我们的目标是编写一个具有加(+)、减 (•)、乘(*)、除(/)四则运算功能的计算器程序。为了更容易实现，我们在计算器中使用 逆波兰表示法代替普通的中辍表示法(逆波兰表示法用在某些袖珍计算器中，Forth 与 Postscript 等语言也使用了逆波兰表示法)。
在逆波兰表示法中，所有运算符都跟在操作数的后面。比如，下列中缀表达式:
(1 – 2) * (4 + 5)
采用逆波兰表示法表示为:
1 2 • 4 5 + *
逆波兰表示法中不需要圆括号，只要知道每个运算符需要几个操作数就不会引起歧义。 计算器程序的实现很简单。每个操作数都被依次压入到校中;当一个运算符到达时，从
校中弹出相应数目的操作数(对二元运算符来说是两个操作数)，把该运算符作用于弹出的操
作数，并把运算结果再压入到校中。例如，对上面的逆波兰表达式来说，首先把 1 和 2 压入
到校中，再用两者之差•1 取代它们;然后，将 4 和 5 压入到校中，再用两者之和 9 取代它们。 最后，从校中取出校顶的•1 和 9，并把它们的积•9 压入到校顶。到达输入行的末尾时，把校顶 的值弹出并打印。
这样，该程序的结构就构成一个循环，每次循环对一个运算符及相应的操作数执行一次 操作:
while (下一个运算符或操作数不是文件结束指示符) if (是数)
将该数压入到找中
else if (是运算符)
弹出所需数目的操作数
执行运算
将结果压入到找中
else if (是换行符)
弹出并打印找顶的值
else
出错
校的压入与弹出操作比较简单，但是，如果把错误检测与恢复操作都加进来，该程序就 显得很长了，最好把它们设计成独立的函数，而不要把它们作为程序中重复的代码段使用。 另外还需要一个单独的函数来取下一个输入运算符或操作数。
到目前为止，我们还没有讨论设计中的一个重要问题:把校放在哪儿?也就是说，哪些 例程可以直接访问它?一种可能是把它放在主函数 main 中，把校及其当前位置作为参数传递 给对它执行压入或弹出操作的函数。但是，main 函数不需要了解控制校的变量信息，它只进 行压入与弹出操作。因此，可以把校及相关信息放在外部变量中，并只供 push 与 pop 函数 访问，而不能被 main 函数访问。
把上面这段话转换成代码很容易。如果把该程序放在一个源文件中，程序可能类似于下 列形式:
#include...              /* 一些包含头文件 */
#define...              /* 一些 define 定义 */
main 使用的函数声明
main() { ... }
push 与 pop 所使用的外部变量
void push( double f) { ... }
double pop(void) { ... }
int getop(char s[]) { ... }
被 getop 调用的函数
我们在后面部分将讨论如何把该程序分割成两个或多个源文件。
main 函数包括一个很大的 switch 循环，该循环根据运算符或操作数的类型控制程序的 转移。这里的 switch 语句的用法比 3.4 节中的例子更为典型。