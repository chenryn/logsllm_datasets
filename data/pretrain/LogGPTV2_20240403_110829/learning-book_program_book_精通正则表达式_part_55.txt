328页的程序讲解了如何使用动态表达式匹配任意深度的嵌套结构。一般来说，这都是最简
单的方法，但是来看看只使用内嵌代码的办法也没坏处，所以接下来我会给出这种办法。
办法很简单：记录已经遇到的未配对开括号的数量，只有此数量大于0时，才容许出现闭
括号。在匹配文本的过程中，我们使用内嵌代码来计数，不过在这之前必须得看看（目前
还不能运行的）正则表达式的框架。
my SNestedGuts = qr{
#固化分组，提高效率
(? :
#除括号以外的字符
[~()] +
#开括号
1\((?($OpenParens++))
#闭括号
1\）（?(?{ $OpenParens !=0})（?{ $OpenParens--}）1（?!）)
) *
（？（？（SOpenParens！=0））（？!））#①如果还有开括号、则匹配未结束
)x;
这段程序的使用方法与第330页的sLeve1N完全相同。
为了分离正则表达式中的sOpenParens和程序中可能出现的其他全局变量，这里使用了
local。但1ocal的用法与之前的不同，这里不需要避免回溯，因为正则表达式使用了固化
分组，一旦某个多选分支能够匹配，就不会变为“交还”。这样，固化分组既保证了效率，
又保证了内嵌代码结构附近匹配的文本不会在回溯中交还（这样sOpenParens就与实际匹
配的开括号数目一致）。
正则文字重载
Overloading Regex Literals
通过重载，用户可以通过自己喜欢的方式预先处理正则文字中的文字部分。下面几节给出
了例子。
添加单词起始/结束元字符
Perl没有提供作为单词起始/结束元字符的和>，可能是因为绝大多数情况下\bi已经
够用了。不过，如果我们希望使用这两个元字符，我们可以通过重载，将表达式中的‘\）（M\=）（M\1>）/(?
return $RegexLiteral;
#返回修改后的字符串
）
“（=）（>），.>，串
replacement部分类似双引l号字符串，所以需要用“\\w’表示‘\w”。
为了让它能够自动处理正则文字的每个文字部分，我们将其存人文件MyRegexSruf.pm，供
Perl重载：
packageMyRegexStuff；#起个特珠的名字
usestrict；#这是个好习惯
usewarnings；#这也是个好习惯
useoverload;#启用Perl的重载机制
#载人regexhandler....
sub import(overload::constant qr =>\&MungeRegexLiteral}
sub MungeRegexLiteral($)
my（SRegexLiteral）=@_：#参数是字持串
$RegexLiteral=~S/\1/(?
returnSRegexLiteral；#返回修改后的字符事
1 ;
#标准做法，‘use'此文件肯定会返回true
将MyRegexStuff.pm放在Perl的库路径（library path，请参考Perl文档中的PERLLIB）下，
所有需要使用此功能的Perl脚本都可调用。如果只是为了测试，可以将其放在测试脚本同
一目录内，这样调用：
use1ib'.';
#在当前目录中寻找库文件
use MyRegexStuff;
#现在可以使用此功能了
stext =~s/\s+\regex*）：（173）。
占有优先量词限定的部分可以是括号内的表达式，也可以是w或者x（1234）之类的元
序列，或是普通字符。要处理所有情况并不容易，所以为简便起见，我们只关注作用于括
号的？+、*+和++。有了330页的SLeve1N，我们可以把这段程序：
SRegexLiteral =~8/(\(SLeve1N\)[*+?])\+/(?>$1)/gx;
添加到MungeRegexLiteral函数。
现在，它成为overloadpackage的一部分，我们可以在正则文字中使用占有优先量词，例如
第198页的这个例子：
//+（[]1\）。/S~=x$
#去掉双引号宇符串
如果要处理的情况不只是括号，就要复杂很多，因为正则表达式中的变数很多，下面是一
种尝试：
$RegexLiteral ~ s{
#匹配可能的限定对象
(？:\[\\abCdDefnrsStwwx]
#\n、\w之类
1\\C.#\cA
1\\x[\da-fA-F](1 , 2}
\xFF
1\\x\([\dafA-F] *\}
#\x(1234}
1\[pP]\{[(}]+\}
#\p(Letter}
[]？[]]+]
#宇符组
111W
#
1*
\（SLeve1N\)
#(.…)
[\+（）]1
#其他任何字符
#...标准量词...
(？：[*+？]1\{\d+(？：,\d*)？\）)
\+#..和量词之后的‘+”
}{(?>$1)}gx;
这个表达式的大体形式和之前一样：使用占有优先量词匹配一些内容，去掉最后的“+，
将整个表达式用（？>）围起来。要想识别Perl正则表达式的复杂语法，这样还很不够。
匹配字符组的部分函需改进，因为它并不能识别字符组内部的转义。更槽糕的是，这个表
达式的基本思路有问题，因为它不能完整识别Perl的正则表达式。比如，它就不能正确处
理‘\（blah\)++’中作为普通字符的开括号，而是认为++仅仅限定）1。
---
## Page 370
344
第7章：Perl
解决这个问题得花许多工夫，或许得想办法从前往后仔细遍历整个正则表达式（类似第132
页的补充内容中的办法）。我本来希望改善处理字符组的元素，但是最后觉得没必要处理其
他复杂情况，原因有两个。第一个是，这个表达式能应付大部分正常的情况，所以修正处
理字符组的元素就能满足实用要求了。更重要的一点是，目前Perl的正则表达式重载有严
重问题，结果它的用途大打折扣，讨论见下一节。
正则文字重载的问题
Problems uitht Regex-Literal Orerloading
正则文字重载的功能非常有用，至少在理论上是如此，不幸的是实际情况并非如此。问题
在于，它只对正则文字中的文字部分有效，而不会影响插值部分。例如，在m/（$MyStuff）*+/
中MungeRegexLiteral函数调用了两次，一次是在变量插值之前（“（”）；另一次是插值
之后（“)*+”）。（它永远不会影响sMyStuff的值）。因为重载必须同时找到两个部分，而
插人的值又是不确定的，所以实际上重载不会生效。
对之前添加的\来说，这不是个问题，因为变量替换不太可能把它们切段。但是因为
重载不会影响插值变量，包含“’或“>’的字符串或regex对象就不会受重载影响。上
一节已经提到，如果由重载来处理正则文字，就很难每次都保证完整性和准确性。即使是
与\>一样简单也会出问题，例如‘\1>'，它表示反斜线‘\’之后紧跟尖括号‘>。
另一个问题是，重载不知道正则表达式所使用的修饰符。表达式是否使用了/x是很重要的
问题，但重载没有确切的办法知道。
模拟命名捕获
MinickingNamed Capture
讲完了重载的不便之后，我们来看看综合了许多特殊结构的复杂例子。Perl没有提供命名捕
获（138）的功能，但是我们可以使用捕获型括号和S^N变量（301）来模拟，这个变量
引用的是最近结束的捕获型括号匹配的内容（现在我假扮Perl开发人员，使用s^N，特意为
Perl增加命名捕获的功能）。
---
## Page 371
巧用Perl的专有特性
345
来看个简单的例子：
href\s*=\s*($HttpUr1)(?( $ur1=S~N })
这里使用了303页的regex对象SHttpUr1。下画线部分是一段内嵌代码，把sHttpUr1匹配
的内容保存到Sur1中。在这里用s^N取代S1似乎有些多此一举，甚至不必要使用内嵌代码，
因为在匹配之后使用s1更加方便。但是如果把其中一部分封装到regex对象，然后多次使
用：
my $SaveUrl = qr(
($HttpUrl)
#匹配HTTP URL...
（？{$ur1=$N ））
#...保存到Surl
}×;
$text =~m(
http\s*=\s*($SaveUrl)
1Src\s*=\s*（$SaveUrl）
)xi ;
无论SHttpUr1是怎么匹配的，Sur1都会被设置为URL。在这个简单应用中可以使用其他
办法（例如s+变量301），但是在更复杂的情况中，$SaveUr1之外的办法更难维护，所以
将它保存到命名变量中方便得多。
(unwritten）”。所以要在初始匹配时修改本地化的临时变量，只有在整体匹配真正确认之后
才保存“真正”的变量，就像第338页的例子一样。
下面给出了一种解决办法。从用户的角度来看，在（?\d+）之后，\d+匹配的数值仍
然可以以s^N（Num)访问。尽管未来版本的Perl可能会把^N转换为某种特殊的系统变量，
现在仍然不是特殊的，所以我们可以随意使用。
我们可以使用&NamedCapture之类的名字，但选择^N是有理由的。之一是它类似s^N。另
一个理由是，如果写明了use strict，它不需要预声明。最后，我希望Perl最终会内建对
命名捕获的支持，所以我认为N是个好办法。如果果真如此，~N就能够和正则表达式的
其他变量（299）一样，自动使用动态作用域。但是目前，它只是普通的全局变量，所以
不会自动使用动态作用域。
当然，即便是这个程序也会出现正则文字重载的办法所具有的问题，例如不能处理插值变
量。
---
## Page 372
346
第7章：Perl
模拟命名捕获
package MyRegexStuff;
use strict;
use warnings;
use overload;
sub import（overload::constant('qr'=>\&MungeRegexLiteral）}
mySNestedStuffRegex；#在自身定义中使用，必须预声明
$NestedStuffRegex = qr{
(?>
(?:
#非括号非转义的宇符..
[（)\#\]+
转义字持..
(？s：\\.)
#正则表达式注释...
#.*\n