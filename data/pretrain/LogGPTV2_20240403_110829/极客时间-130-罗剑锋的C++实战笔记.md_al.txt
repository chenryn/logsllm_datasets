# 14 \| 十面埋伏的并发：多线程真的很难吗？你好，我是 Chrono。今天，我们来聊聊"并发"（Concurrency）、"多线程"（multithreading）。在 20年前，大多数人（当然也包括我）对这两个词还是十分陌生的。那个时候，CPU的性能不高，要做的事情也比较少，没什么并发的需求，简单的单进程、单线程就能够解决大多数问题。但到了现在，计算机硬件飞速发展，不仅主频上G，还有了多核心，运算能力大幅度提升，只使用单线程很难"喂饱"CPU。而且，随着互联网、大数据、音频视频处理等新需求的不断涌现，运算量也越来越大。这些软硬件上的变化迫使"并发""多线程"成为了每个技术人都不得不面对的课题。通俗地说，"并发"是指在一个时间段里有多个操作在同时进行，与"多线程"并不是一回事。并发有很多种实现方式，而多线程只是其中最常用的一种手段。不过，因为多线程已经有了很多年的实际应用，也有很多研究成果、应用模式和成熟的软硬件支持，所以，对这两者的区分一般也不太严格，下面我主要来谈多线程。认识线程和多线程要掌握多线程，就要先了解线程（thread）。线程的概念可以分成好几个层次，从CPU、操作系统等不同的角度看，它的定义也不同。今天，我们单从语言的角度来看线程。**在 C++语言里，线程就是一个能够独立运行的函数**。比如你写一个 lambda表达式，就可以让它在线程里跑起来：    auto f = []()                // 定义一个lambda表达式    {        cout   > 最好的并发就是没有并发，最好的多线程就是没有线程。> > >这又是什么意思呢？简单来说，就是在大的、宏观的层面上"看得到"并发和线程，而在小的、微观的层面上"看不到"线程，减少死锁、同步等恶性问题的出现几率。多线程开发实践下面，我就来讲讲具体该怎么实践这个原则。在 C++里，有四个基本的工具：仅调用一次、线程局部存储、原子变量和线程对象。仅调用一次程序免不了要初始化数据，这在多线程里却是一个不大不小的麻烦。因为线程并发，如果没有某种同步手段来控制，会导致初始化函数多次运行。为此，C++提供了"仅调用一次"的功能，可以很轻松地解决这个问题。这个功能用起来很简单，你要先声明一个**once_flag**类型的变量，最好是静态、全局的（线程可见），作为初始化的标志：    static std::once_flag flag;        // 全局的初始化标志然后调用专门的 **call_once()** 函数，以函数式编程的方式，传递这个标志和初始化函数。这样C++ 就会保证，即使多个线程重入call_once()，也只能有一个线程会成功运行初始化。下面是一个简单的示例，使用了 lambda表达式来模拟实际的线程函数。你可以把GitHub 仓库slate-object="inline"里的代码下到本地，实际编译运行看看效果：    auto f = []()                // 在线程里运行的lambda表达式    {           std::call_once(flag,      // 仅一次调用，注意要传flag            [](){                // 匿名lambda，初始化函数，只会执行一次                cout ;    // 原子化的bool    using atomic_int  = std::atomic;      // 原子化的int    using atomic_long = std::atomic;    // 原子化的long这些原子变量都是模板类 atomic的特化形式，包装了原始的类型，具有相同的接口，用起来和 bool、int几乎一模一样，但却是原子化的，多线程读写不会出错。注意，我说了"几乎"这个词。它还是有些不同的，一个重要的区别是，**原子变量禁用了拷贝构造函数，所以在初始化的时候不能用"="的赋值形式，只能用圆括号或者花括号**：    atomic_int  x {0};          // 初始化，不能用=    atomic_long y {1000L};      // 初始化，只能用圆括号或者花括号    assert(++x == 1);           // 自增运算    y += 200;                   // 加法运算    assert(y  v = {1,2,3};                   // vector容器    j["numbers"] = v;                          // "numbers":[1,2,3    map m =                       // map容器        {{"one",1}, {"two", 2}};               // 初始化列表     j["kv"] = m;                               // "kv":{"one":1,"two":2}添加完之后，用成员函数 dump() 就可以序列化，得到它的 JSON文本形式。默认的格式是紧凑输出，没有缩进，如果想要更容易阅读的话，可以加上指示缩进的参数：    cout  v = {1,2,3,4,5};              // vector容器    msgpack::sbuffer sbuf;                    // 输出缓冲区    msgpack::pack(sbuf, v);                   // 序列化从代码里你可以看到，它的用法不像 JSON那么简单直观，**必须同时传递序列化的输出目标和被序列化的对象**。输出目标 sbuffer是个简单的缓冲区，你可以把它理解成是对字符串数组的封装，和`vector`很像，也可以用 data() 和 size()方法获取内部的数据和长度。    cout  v2;                       // vector容器    obj.convert(v2);                      // 转换反序列化的数据    assert(std::equal(                    // 算法比较两个容器          begin(v), end(v), begin(v2)));因为 MessagePack 不能直接打包复杂数据，所以用起来就比 JSON麻烦一些，你必须自己把数据逐个序列化，连在一起才行。好在 MessagePack 又提供了一个 packer类，可以实现串联的序列化操作，简化代码：    msgpack::sbuffer sbuf;                         // 输出缓冲区    msgpack::packer packer(sbuf);  // 专门的序列化对象    packer.pack(10).pack("monado"s)                // 连续序列化多个数据          .pack(vector{1,2,3});对于多个对象连续序列化后的数据，反序列化的时候可以用一个偏移量（offset）参数来同样连续操作：    for(decltype(sbuf.size()) offset = 0;          // 初始偏移量是0        offset != sbuf.size();){                   // 直至反序列化结束        auto handle = msgpack::unpack(            // 反序列化                sbuf.data(), sbuf.size(), offset);  // 输入二进制数据和偏移量        auto obj = handle.get();                  // 得到反序列化对象    }但这样还是比较麻烦，能不能像 JSON那样，直接对类型序列化和反序列化呢？MessagePack为此提供了一个特别的宏：MSGPACK_DEFINE，把它放进你的类定义里，就可以像标准类型一样被MessagePack 处理。下面定义了一个简单的 Book类：     class Book final                       // 自定义类    {    public:        int         id;        string      title;        set tags;    public:        MSGPACK_DEFINE(id, title, tags);   // 实现序列化功能的宏    };它可以直接用于 pack() 和 unpack()，基本上和 JSON差不多了：     Book book1 = {1, "1984", {"a","b"}};  // 自定义类    msgpack::sbuffer sbuf;                    // 输出缓冲区    msgpack::pack(sbuf, book1);              // 序列化    auto obj = msgpack::unpack(              // 反序列化          sbuf.data(), sbuf.size()).get();   // 得到反序列化对象    Book book2;    obj.convert(book2);                      // 转换反序列化的数据    assert(book2.id == book1.id);    assert(book2.tags.size() == 2);    cout                // 包含头文件    auto curl = curl_easy_init();        // 创建CURL句柄    assert(curl);    curl_easy_setopt(curl, CURLOPT_URL, "http://nginx.org"); // 设置请求URI    auto res = curl_easy_perform(curl);   // 发送数据    if (res != CURLE_OK) {                // 检查是否执行成功        cout                             // 包含头文件    auto res = cpr::Get(                           // GET请求                   cpr::Url{"http://openresty.org"}   // 传递URL    );你也不用写回调函数，HTTP 响应就是函数的返回值，用成员变量url、header、status_code、text就能够得到报文的各个组成部分：    cout "            // 类似map的结构             (), msg.size()};        cout         // pybind11的头文件    PYBIND11_MODULE(pydemo, m)            // 定义Python模块pydemo    {      m.doc() = "pybind11 demo doc";      // 模块的说明文档    }                                     // Python模块定义结束代码里的 pydemo 就是 Python 里的模块名，之后在 Python脚本里必须用这个名字才能import。 第二个参数"m"其实是 pybind11::module的一个实例对象，封装了所有的操作，比如这里的 doc()就是模块的说明文档。它只是个普通的变量，起什么名字都可以，但为了写起来方便，一般都用"m"。假设这个 C++ 源文件名是"pybind.cpp"，现在你就可以用 g++ 把它编译成在Python里调用的模块了，不过编译命令比较复杂：    g++ pybind.cpp               \                  #编译的源文件       -std=c++11 -shared -fPIC   \                 #编译成动态库      `python3 -m pybind11 --includes` \            #获得包含路径      -o pydemo`python3-config --extension-suffix`  #生成的动态库名字我来稍微解释一下。第一行是指定编译的源文件，第二行是指定编译成动态库，这两个不用多说。第三行调用了Python，获得 pybind11 所在的包含路径，让 g++能够找得到头文件。第四行最关键，是生成的动态库名字，**前面必须是源码里的模块名**，而后面那部分则是 Python 要求的后缀名，否则 Python运行时会找不到模块。编译完后会生成一个大概这样的文件：pydemo.cpython-35m-x86_64-linux-gnu.so，现在就可以在Python 里验证了，使用 import 导入，然后用 help就能查看模块说明：    $ python3    >>> import pydemo    >>> help(pydemo)刚才的代码非常简单，只是个空模块，里面什么都没有，现在，我们来看看怎么把C++ 的函数导入 Python。你需要用的是 **def() 函数**，传递一个 Python 函数名和 C++ 的函数、函数对象或者是lambda 表达式，形式上和 Python的函数也差不多：    namespace py = pybind11;               // 名字空间别名，简化代码    PYBIND11_MODULE(pydemo, m)             // 定义Python模块pydemo    {      m.def("info",                        // 定义Python函数        []()                              // 定义一个lambda表达式        {          py::print("c++ version =", __cplusplus);  // pybind11自己的打印函数          py::print("gcc version =", __VERSION__);          py::print("libstdc++   =", __GLIBCXX__);        }      );        m.def("add",                       // 定义Python函数        [](int a, int b)                 // 有参数的lambda表达式        {          return a + b;        }      );      }                                     // Python模块定义结束这样我们就非常轻松地实现了两个 Python 函数，在 Python里可以验证效果：    import pydemo            
# 导入pybind11模块    pydemo.info()            