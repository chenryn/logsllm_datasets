oracle CH(am, h, σ)
1: if b = 0 then d ← Cκ
h
2: return (d, σ)
else (d, σ) ← S.Enc(ak, am, h, σ)
Algorithm 3: Chosen-Hiddentext experiment with security
parameter κ.
A stegosystem S is called secure against chosen-hiddentext attacks
if for every warden Ward, there is a negligible function negl such
that
Advcha
Ward,S, C(κ) := Pr[SS-CHA-DistWard,S, C(κ) = true]
≤ negl(κ).
InSeccha
The maximal advantage of any warden against S is the insecurity
S, C(κ) and defined as maxWard{Advcha
Ward,S, C(κ)}.
A very common technique in the design of secure stegosystems
called rejection sampling goes back to an idea of Anderson, pre-
sented in [1]. The basic concept is that the stegoencoder samples
from the channel until he finds a document that already encodes
the hiddentext. This was first used by Cachin in [10] to construct a
secure stegosystem in the information-theoretic sense.
In the following, let F be pseudorandom function that maps
input strings of length F.in(κ) (documents) to strings of length
F.out(κ) = log(ml(κ)) + 1 (message parts). To simplify notation,
we treat the output of F.Evalk as a pair (b, j) with |b| = 1 and
|j| = log(ml(κ)). The encoder of the rejection sampling stegosystem,
which we denote as RejSamF, is defined as follows:
Session H1:  Crypto AttacksCCS’17, October 30-November 3, 2017, Dallas, TX, USA1653RejSamF.Enc(ak, am, h, σ)
Input: key ak, message am, history h, state σ
1: i := 0;
2: repeat
d ← Ch
3:
i := i + 1
4:
(b, j) := F.Evalak(d)
5:
6: until am[j] = b or i > s
7: return (d, σ)
▷ am[j] is the j-th bit of am
Algorithm 4: Stegoencoder of RejSam with security parame-
ter κ and s ≥ 1.
The key generator RejSamF.Gen is equal to F.Gen and the de-
coder derives am, as long as its input documents contain every bit
am[j], by applying F.Evalak to these documents. Below we present
the description of the decoder. Note that the stegosystem is stateless.
RejSamF.Dec(ak, d1, . . . , dS.ol(κ))
Input: key ak, documents d1, . . . , dS.ol(κ)
1: for j = 1, . . . , ml(κ) do
let amj := ⊥
2:
3: for i = 1, 2, . . . , S.ol(κ) do
(b, j) := F.Evalk(di)
4:
let amj := b
5:
6: if all amj (cid:44) ⊥ then
7:
8: else
9:
return am = am1am2 . . . amml(κ)
return ⊥
Algorithm 5: Decoder of RejSam.
In [16], Hopper et al. were the first to prove the security of this
stegosystem in the complexity-theoretic model. Their argument
was simplified by Dedić et al. in [12] and by Backes and Cachin in
[3]. The version given here is based upon the stateless construction
of Dedić et al. and also uses the idea of Bellare et al. in [6] to apply
the coupon collector’s problem to completely get rid of the state by
randomly choosing an index to embed.
The analysis of the coupon collector’s problem shows that by
sending ml(κ)·(ln ml(κ) + β) documents – for an appropriate value
β – one only introduces a term exp(−β) into the unreliability (see
e. g. [19] for a proof of this fact), which can be made negligible by
setting β ≥ ml(κ) − ln(ml(κ)). The output length on messages of
length ml(κ) will thus be bounded by ml(κ)2.
The security of this system directly follows from the analysis of
Dedić et al. in [12]:
Theorem 4.1 ([12, Theorems 4 and 5]). For every polynomial
ml(κ), there exists a universal history-ignorant stegosystem S =
RejSamF with security parameter κ and s ≥ 1 such that for every
channel Cκ we have
• S.ml(κ) = ml(κ),
• InSeccha
InSecprf
• UnRel⋆
InSecprf
S, C(κ) ≤ O(ml(κ)4 · 2−H∞(Cκ) + ml(κ)2 · exp(−s)) +
F, C(κ), and
S, C(κ) ≤ ml(κ)2(2· exp(−2H∞(Cκ)−3) + exp(−2−2s)) +
F, C(κ).
The notation InSecprf
F, C(κ) indicates the insecurity of the pseudo-
random function F relative to the channel C. Informally, this means
that the attacker against F also has sampling access to C (for a
formal definition, see [12]). For an efficiently sampleable channel
C (i. e. one that can be simulated by a PPTM), it clearly holds that
F (κ). All channels used in this work are ef-
InSecprf
ficiently sampleable and we will thus omit the index C from the
term InSec.
F, C(κ) = InSecprf
5 ENCRYPTION SCHEMES AS
STEGANOGRAPHIC CHANNELS
Let SES = (Gen, Enc, Dec) be a symmetric encryption scheme that
encodes messages of length ml(κ) into ciphertexts of length cl(κ) ≥
ml(κ) and let ℓ be a polynomial of κ. For SES we define a channel
family, named Cκ
SES(ℓ), indexed with parameter κ ∈ N, where the
documents will correspond to the input of generalized algorithm
substitution attack against encryption schemes. The essential idea
behind the definition of the channel Cκ
SES(ℓ) is that for all k ∈
supp(Gen(1κ)) and every sequence of messages m1, m2, . . . , mℓ(κ),
with mi ∈ {0, 1}ml(κ), for the history
h = k || m1 || m2 || . . . || mℓ(κ)
the distribution of the sequences of documents
c1 || c2 || . . . || cℓ(κ)
generated by the channel is exactly the same as the distribution for
Enc(k, m1) || Enc(k, m2) || . . . || Enc(k, mℓ(κ)).
To give a formal definition of {Cκ
SES(ℓ)}κ∈N we need to specify
the probability distributions for any history h. Thus, we define the
family, on the alphabet {0, 1}, as follows.
For the empty history h = ∅, define
Cκ
SES(ℓ)∅
as the distribution of all keys generated by Gen(1κ). For a key
k ∈ supp(Gen(1κ)) and a (possibly empty) sequence of messages
m1, m2, . . . , mr , with mi ∈ {0, 1}ml(κ) and 0 ≤ r ≤ ℓ(κ) − 1, the
distribution
Cκ
SES(ℓ)k ||m1||m2||...||mr
is the uniform distribution on all messages mr +1 ∈ {0, 1}ml(κ). For
k ∈ supp(Gen(1κ)), a sequence of messages m1, m2, . . . , mℓ(κ) with
mi ∈ {0, 1}ml(κ), and a (possibly empty) sequence of ciphertexts
c1, . . . , cr , with ci ∈ supp(Enc(k, m((i−1) mod ℓ(κ))+1)), the distribu-
tion
SES(ℓ)k ||m1||m2||...||mℓ(κ)||c1||c2||...||...||cr
Cκ
is the distribution of Enc(k, m(r mod ℓ(κ))+1).
Session H1:  Crypto AttacksCCS’17, October 30-November 3, 2017, Dallas, TX, USA16546 ASAS AGAINST ENCRYPTION IN THE
STEGANOGRAPHIC MODEL
We prove first indistinguishability of the system. Let Watch be
a watchdog against the above ASA with maximal advantage, i. e.
The main message of our paper is that algorithm substitution attacks
against a primitive Π are equivalent to the use of steganography on a
corresponding channel CΠ determined by the protocol Π. Focusing
on symmetric encryption schemes as a common cryptographic
primitive, we will show in this section exemplary proofs for the
general relations between ASAs and steganography.
In the previous section we showed a formal specification of
the family of communication channels Cκ
SES(ℓ) determined by a
symmetric encryption scheme SES. We will now prove that a secure
and reliable stegosystem on Cκ
SES(ℓ) implies the existence of an
indistinguishable and successful algorithm substitution attack on
SES. On the other hand, we will also show that the existence of an
indistinguishable and successful algorithm substitution attack on
SES implies a secure and reliable stegosystem on Cκ
As a consequence we get a construction of an ASA against any
encryption scheme using a generic stegosystem like e. g. this pro-
posed by Dedić et al. [12]. Thus, we can conclude Theorem 1 and
Theorem 3 proposed by Bellare et al. in [7] that there exist in-
distinguishable and successful ASAs against encryption schemes.
Moreover we obtain Theorem 4 in [7] which says that an ASA is
impossible for unique ciphertext symmetric encryption schemes.
SES(ℓ).
6.1 Steganography implies ASAs
Theorem 6.1. Assume SES is a symmetric encryption scheme
SES(S.ol(κ)) deter-
and let S be a stegosystem on the channel C := Cκ
mined by SES. Then there exists an algorithm substitution attack ASA
against SES of indistinguishability, resp. reliability such that:
ASA,SES (κ) ≤ InSeccha
InSecenc-watch
UnRelASA,SES(κ) = UnRel⋆
S, C(κ)
S, C(κ).
and
Proof. Let SES = (Gen, Enc, Dec) be a symmetric encryption
scheme and S = (SGen, SEnc, SDec) be a stegosystem on the chan-
nel C. To simplify notation, let ℓ = ℓ(κ) := S.ol(κ). We will con-
struct the algorithm substitution attack ASA = (AGen, AEnc, AExt)
on SES from the stegosystem S and show the indistinguishability
and success of ASA depending on security and reliability of S. The
components of the ASA are defined as follows.
The key generator AGen just simulates SGen – the key generator
of the stegosystem. It will output the attack key ak. The encoding
algorithm AEnc on input ak ∈ supp(AGen(1κ)), am ∈ {0, 1}S.ml(κ),
k ∈ supp(Gen(1κ)), and m ∈ {0, 1}SES.ml(κ) simulates SEnc on
channel C with input key ak, the message am and the history
h = k || mℓ, where mℓ is the string of length ℓ · |m| containing ℓ
copies of m. Whenever SEnc makes a query to its channel oracle,
algorithm AEnc uses Enc on input k and m to produce a correspond-
ing ciphertext and sends it to SEnc. The encoder AEnc then outputs
the document d generated by SEnc. Finally, the extraction algorithm
AExt on input ak ∈ supp(AGen(1κ)) and documents d1, . . . , dℓ just
simulates SDec on the same inputs.
As one can see from the definitions, ASA is a generalized algo-
rithm substitution attack against SES. We will now prove that it is
indistinguishable from SES and that it is successful.
Watch,ASA,SES(κ) = InSecenc-watch
Advenc-watch
Watch,ASA,SES(κ) is equal to the success probability that
where Advenc-watch
ASA-DistWatch,ASA,SES(κ) = true. We will now construct a warden
Ward from Watch such that
ASA,SES (κ),
Advcha
Ward,S, C(κ) = Advenc-watch
Watch,ASA,SES(κ).
Thus, we will get that
InSecenc-watch
ASA,SES (κ) ≤ InSeccha
S, C(κ).
(1)
The warden Ward on input 1κ just simulates the watchdog Watch
and gives the same output as Watch at the end of the simulation.
Whenever the watchdog makes a query on input am, k, and m
to its challenging oracle (that is either equal to SES’s encryption
algorithm Enc(k, m) or to ASA’s encryption AEnc(ak, am, k, m, σ)
for ak ← AGen(1κ)), the warden Ward queries its own challenging
oracle with message am, state σ and history h = k || mℓ. Note that
the challenging oracle of Ward is either equal to the channel C or
to SEnc(ak, am, h, σ) for ak ← SGen(1κ).
If the challenging oracle of Ward is equal to the steganographic
encoding SEnc(ak, am, h, σ) (i. e. the bit b in SS-CHA-Dist equals 1,
denoted by SS-CHA-DistWard,S, C(κ)⟨b = 1⟩), the answer of Ward
is the same as the output of the Watch in case it queries the ASA’s
encoding algorithm AEnc(ak, am, k, m) by construction. Thus,
Pr[SS-CHA-DistWard,S, C(κ)⟨b = 1⟩ = true]
= Pr[ASA-DistWatch,ASA,SES(κ)⟨b = 1⟩ = true].
If the challenging oracle of Ward is equal to the channel (the
bit b in SS-CHA-Dist equals 0), by the definition of the channel
C for the symmetric encryption scheme SES, the answer of the
challenging oracle is equal to the output of Enc(k, m). Hence,
Pr[SS-CHA-DistWard,S, C(κ)⟨b = 0⟩ = true]
= Pr[ASA-DistWatch,ASA,SES(κ)⟨b = 0⟩ = true].
We thus have
Advcha
Ward,S, C(κ) = Pr[SS-CHA-DistWard,S, C(κ) = true]
= Pr[ASA-DistWatch,ASA,SES(κ) = true
= Advenc-watch
Watch,ASA,SES(κ)
which completes the proof of (1).
We still need to prove that AExt is reliably able to extract the
attacker message am from the ciphertext. But, as AExt = SDec, the
reboot-reliability of SDec directly implies that AExt is successful
with probability of 1 − negl(κ).
□
By combining Theorem 6.1 and Theorem 4.1, we can conclude
the following corollary.
Corollary 6.2. For every symmetric encryption scheme SES, there
exists an algorithm subsection attack ASA with message length ml(κ)
Session H1:  Crypto AttacksCCS’17, October 30-November 3, 2017, Dallas, TX, USA1655and parameter s ≥ 1 such that
InSecenc-watch
ASA,SES (κ) ≤ O(ml(κ)4 · 2−H∞(Cκ))+