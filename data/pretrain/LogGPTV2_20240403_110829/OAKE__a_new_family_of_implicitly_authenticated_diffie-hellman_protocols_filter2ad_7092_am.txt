exposed to the attacker) but the value Y0 may be generated by the attacker impersonating ˆB (in this
case, the matching session does not exist). In this section, we consider the security damage caused by
compromising static secret-keys of players, i.e., one or both of the secret-keys a; b of the test-session are
exposed to the attacker.
Firstly, we note that if both the peer ˆB (in the test-session) is corrupted and the value Y0 is
generated by the attacker itself, then no security can be guaranteed for the test-session within the
CK-framework (as the attacker can now compute the session-key by itself). In this section, we mainly
investigate the resistance against key-compromise impersonation (KCI) attacks, and perfect forward
security (PFS). Roughly speaking, a key-compromise impersonation attack is deemed successful if the
attacker, knowing the private key a of a party ˆA (which of course allows the attacker to impersonate ˆA),
is able to impersonate another diﬀerent uncorrupted party ˆB ̸= ˆA (for which the attacker does not know
the secret-key b) to ˆA. Note that for KCI attacks, the attacker still can generate the DH-component
Y0 for the test-session (without the matching session then). The PFS property says that the leakage of
7We note that some modiﬁcations to (s,r)OAKE may be needed to give a formal proof in the public computation
model, in accordance with the work of [44]. Here, we stress that (s,r)OAKE, particularly sOAKE, very well supports the
public-computation model even without such modiﬁcations.
37
the static secret-key of a party should not compromise the security of session-keys ever established by
that party, and erased from memory before the leakage occurred.
Deﬁnition H.1 (clean session [42]) We say that a complete session of a key-exchange protocol is
clean, if the attacker did not have access to the session’s state at the time of session establishment (i.e.,
before the session is complete), nor it issued a session-key query against the session after completion.
Note that, for a clean session at an uncorrupted party, the attacker did not issue a state-reveal query
while the session was incomplete or a session-key query after completion. Moreover, the attacker was
not actively controlling or impersonating the party during the session establishment (neither by making
any choices on behalf of that party in that session or eavesdropping into the session’s state).
Deﬁnition H.2 [42] We say that a KE-attacker A that has learned the static secret-key of ˆA succeeds
in a KCI attack against ˆA, if A is able to distinguish from random the session-key of a complete session
at ˆA for which the session peer ˆB ̸= ˆA is uncorrupted (which implies the private-key of ˆB is not exposed
to A ) and the session and its matching session (if it exists) are clean.
In other words, the deﬁnition says that, as long as the attacker is not actively controlling or ob-
serving the secret choices (particularly the ephemeral DH-exponent x) of the test-session, then even the
knowledge of ˆA’s private-key still does not allow A to compromise the session-key. In particular, in
such a protocol A cannot impersonate an uncorrupted party ˆB to ˆA in a way that allows A to learn
any information about the resultant session-key [42] (even if the attacker impersonates ˆB and generates
the DH-component, say Y0, by itself).
Proposition H.1 Under the GDH assumption in the random oracle model, the (s,r)OAKE protocols
(actually, their public-key free variants), with oﬄine pre-computation, resist KCI attacks in the CK-
framework.
The resistance of (s,r)OAKE to KCI attacks is essentially implied by the proofs of Theorem G.1,
Theorem G.2 and Corollary G.8 for the case of ˆA ̸= ˆB, from the observations that: for KCI attacks the
test-session is between a pair of diﬀerent uncorrupted peers ˆA ̸= ˆB, and the security of the underlying
(s,r)OAKE-HDR holds even if the forger learns the private-key of the uncorrupted peer (the party ˆA
here).
Weak PFS (wPFS). It is clariﬁed in [42] that, no 2-round DHKE protocols with implicit key
conﬁrmation can fully render PFS security (the 3-round versions of HMQV and (s,r)OAKE, with explicit
key-conﬁrmation and mutual authentications, do fully provide PFS property). The work [42] formulates
a weak notion of PFS, named weak PFS (wPFS), and shows that HMQV satisﬁes this wPFS property.
Roughly speaking, wPFS property says that if the attacker is not actively involved with the choices of
X; Y at a session (particularly if it does not get to choose or learn the DH-exponent x or y), then the
resultant session-key does enjoy forward security. Formally,
Deﬁnition H.3 [42] A key-exchange protocol provides wPFS, if an attacker A cannot distinguish from
random the key of any clean session ( ˆA; ˆB; X; Y ), where Y is also generated by an uncorrupted party in
a clean session, even if A has learned the private keys of both ˆA and ˆB.
Proposition H.2 Under the CDH assumption, the (s,r)OAKE protocols provide wPFS property in the
random oracle model.
For establishing the wPFS property for (s,r)OAKE, we do not need here to construct a (s,r)OAKE-
HDR forger from the attacker violating the wPFS property. Actually, we can directly reduce the loss
of wPFS to the CDH assumption, from the following observations: given the knowledge of both a
and b, the computation of K ^A or K ^B is reduced to the computation of gxye from the random DH-
components X; Y . Recall that, for wPFS property, we assume the attacker is not actively involved with
the choices of X; Y . Then, we can simply guess the test-session, and set the DH-components as some
given random elements X; Y , and then reduce the ability of the attacker to violate wPFS directly to
the CDH assumption. More details are omitted here.
38
I More on Computational Fairness
We ﬁrst present more discussions on the formulation of session-key computational fairness.
We note that the issue of computational fairness can apply to interactive protocols in general,
as long as the honest players have the same computational operations under protocol speciﬁcations.8
For implicitly authenticated DHKE protocols like (H)MQV and OAKE, we only considered here the
session-key computational fairness. In general, for key-exchange protocols with explicit authentication
(e.g., via signatures and/or MACs), besides session-key computational fairness, we need also consider
authentication computational fairness. The formulation of session-key computational fairness is also
instrumental in formulating authentication computational fairness, which is beyond the scope of this
work.
Computational fairness vs. contributiveness. A related notion, called contributiveness, was
also introduced in the literature of group key-exchange (see e.g., [52, 11]. Roughly speaking, the notion of
contributiveness for group key-exchange says that a subset of players cannot pre-determine the session-
key output. But, contributiveness says nothing about computational fairness in computing the session-
key output. As clariﬁed in Section 5, computational fairness says that each player needs to compute
the same number of non-malleably independent dominant-operation values in generating the session-key
output. To our knowledge, the notion of non-malleably independent dominant-operation values was not
previously considered in the literature. If we view each non-malleably independent dominant-operation
value as a proof-of-knowledge of the corresponding secrecy, our notion of computational fairness ensures
that a subset of malicious players cannot set the session-output to be some value that can be publicly
computed from the session transcript. From these observations, we can see that computational fairness
and contributiveness are two fundamentally diﬀerent notions. Based on this work, computationally-fair
group key-exchange is investigated in another separate work.
Dominant operation values for OAKE and (H)MQV. Before proceeding to analyze the com-
putational fairness of OAKE and (H)MQV, we ﬁrst specify the underlying dominant operation values.
Recall that it is the task of the protocol designer to specify the dominant operation values, with respect
to which computational fairness will be provably proved. For OAKE and any complete session-tag
T ag = ( ˆA; ˆB; X = gx; Y = gy), the dominant operation values speciﬁed for the player ˆA (resp.,
ˆB) are V ^A
2 = X db+ey), where
c = h( ˆA; A; Y ); d = h( ˆB; B; X); e = h(X; Y ). For (H)MQV, as they were not designed for computa-
tional fairness, dominant operation values were unspeciﬁed. We consider two natural speciﬁcations of
dominant operation values for (H)MQV:
2 = Y ca+ex ∈ G (resp., V ^B
1 = Bdx ∈ G \ 1G and V ^A
1 = Acy and V ^B
• Speciﬁcation-1: For any complete session-tag T ag = ( ˆA; ˆB; X; Y ), the dominant operation values
speciﬁed for the player ˆA (resp., ˆB) are V ^A
1 =
2 = y + eb ∈ Zq), where d = h(X; ˆB); e = h(Y; ˆA) for HMQV (resp., d = 2l + (X
XAd ∈ G and V ^B
mod 2l) and e = 2l + (Y mod 2l) for MQV). The key derivation function FK, in this case, is
speciﬁed to be FK(V1; V2; T ag) = HK(V V2
2 = x + da ∈ Zq (resp., V ^B
1 = Y Be ∈ G and V ^A
1 ) for both OAKE and (H)MQV.
• Speciﬁcation-2: For any complete session-tag T ag = ( ˆA; ˆB; X; Y ), the dominant operation values
2 = Be(x+da) ∈ G (resp.,
speciﬁed for the player ˆA (resp., ˆB) are V ^A
V ^B
1 = X y+eb and V ^B
2 = Ad(y+eb)), where d = h(X; ˆB); e = h(Y; ˆA) for HMQV (resp., d = 2l + (X
mod 2l) and e = 2l + (Y mod 2l) for MQV). The key derivation function FK, in this case, is
speciﬁed to be FK(V1; V2; T ag) = HK(V1 · V2) for both OAKE and (H)MQV.
1 = Y x+da ∈ G and V ^A
Proposition I.1 In the random oracle model where the hash function h : {0; 1}∗ → Z
∗
q is assumed to
be a random oracle, OAKE is session-key computationally fair assuming, while (H)MQV is not, with
respect to the above speciﬁed dominant operations.
8In particular, most key-exchange protocols are protocols of such type, while key distribution protocols (e.g., via public-
key encryption) are not.
39
2 ), for both I ∈ { ˆA; ˆB}, is statistically
Proof. For OAKE, we show that the distribution of (V I
1 ; V I
indistinguishable from that of (U1; U2) in the random oracle model, where U1 (resp., U2) is taken
1 distributed uniformly over G \ 1G assuming
uniformly at random from G \ 1G (resp., G). Clearly, V I
h : {0; 1}∗ → Z
2 is not identical to the uniform
distribution of U2 over G. Speciﬁcally, in the random oracle model, Pr[V I
q−1 , while for any
(cid:11) ∈ G \ 1G Pr[V I
(q−1)2 . But, by straightforward calculation, we have that the statistical
distance between V I
2 ) are statistically
non-malleably independent. Thus, for OAKE, the session-key computation by each(whether honest
or not) user involves the same number, say two, statistically non-malleably independent dominant
operation values, and computational fairness property follows.
∗
q to be a random oracle. But, the distribution of V I
2 = (cid:11)] = q−2
2 and U2 is
q(q−1) , which is negligible in l = |q|. That is, (V I
1
2 = 1G] = 1
1 ; V I
For (H)MQV, our concrete EDA attacks presented in Section 5 demonstrate that both MQV
and HMQV do not satisfy computational fairness, with respect to either the above Speciﬁcation-1
or Speciﬁcation-2 of dominant operation values. Speciﬁcally, consider the following speciﬁc relations
(corresponding to the two speciﬁc cases of our attack):
• For Speciﬁcation-1, R(V1; V2; T ag) = 1 iﬀ V V2
V1 ∈ G, V2 ∈ Zq and Y Be can be publicly computed from the session-tag T ag.
• For Speciﬁcation-2, R(V1; V2; T ag) = 1 iﬀ V1 · V2 = 1G, or, R(V1; V2; T ag) = 1 iﬀ V1 · V2 = Y Be,
where V1 ∈ G, V2 ∈ G and Y Be can be publicly computed from the session-tag T ag.
1 = 1G, or, R(V1; V2; T ag) = 1 iﬀ V V2
1 = Y Be, where
For all these speciﬁc relations, there exist complete session-tags T ag (corresponding to the session-
s caused by the EDA attacks presented in Section 5) such that Pr[R(V1; V2; T ag) = 1] = 1, while
Pr[R(U1; U2; T ag) = 1] = 1 is always negligible where (U1; U2) are taken uniformly at random fromG×Zq
(resp., G × G) for Speciﬁcation-1 (resp., Speciﬁcation-2).
(cid:3)
Remark: By the session-key computational fairness property of OAKE, the session-key computation
involves two non-malleably independent values Acy and X db+ey no matter how a malicious ˆB does (i.e.,
ˆB is infeasible to make the values Acy and X db+ey correlated under any predetermined polynomial-time
computable relation). If we view each non-malleably independent exponentiation value as a proof-of-
knowledge of the corresponding exponent, then to compute the session-key any PPT player has to
”know” both cy and db + ey, from which both the static secret-key b and the ephemeral DH-exponent
y can be eﬃciently derived. In this sense, the session-key computation of OAKE itself can be viewed
as a non-malleable join proof-of-knowledge of both b and y. This further implies that a malicious
player is infeasible to set the session-key to some values that can be publicly computed from the session
transcript.
On ﬁxing HMQV to achieve computational fairness.
In [67, 66], we proposed some variants
of (H)MQV, just in the spirit of (s,r)OAKE and NMJPOK to prevent our EDA attacks and to render
the property of session-key computational fairness. The key point is to put A (resp., B) into the input
of d (resp., e). Speciﬁcally, we have the following ﬁxing approaches, by setting (1) d = h(X; ˆB; A) and
e = h(Y; ˆA; B); or (2) d = h( ˆA; A; ˆB; B; X; Y ) and e = h(d); or (3) d = h( ˆA; A; X) and e = h( ˆB; B; Y ),
etc. Other components remain unchanged. For the above third ﬁxing solution, in order to get only one
exponentiation online eﬃciency, we can make some further modiﬁcations by setting K ^A = (Y eB)xd+a,
K ^B = (X dA)ye+b, where d = h( ˆA; A; X) and e = h( ˆB; B; Y ). The session-key is still K = HK(K ^A) =
HK(K ^B). For presentation simplicity, we refer to this solution as the fourth ﬁxing solution (this protocol
variant is named as OAKE-MQV in [67, 66]).
Unfortunately, we failed in providing the provable security for any of the above HMQV variants in
the CK-framework. In particular, we do not know how to extend the security proof of HMQV in [42]
to any of the above four ﬁxing solutions. Indeed, HMQV was very carefully designed to enjoy provable
security in the CK-framework, and the HMQV structure is quite sensitive to the security analysis in
the CK-framework. Besides lacking provable security in the CK-framework, many other advantageous
features enjoyed by (s,r)OAKE (as clariﬁed in Section 4) are also lost with the above ﬁxing solutions.
The surrounding issues are quite subtle and tricky, and indeed (s,r)OAKE was very carefully designed
40
to achieve all these advantageous features (with a new protocol structure, some new design rationales
and building tools, and also inspired by the analysis of HMQV and the design of deniable IKE [68]).
41