the intended way, while those vulnerable objects should be
released by triggering a use-after-free vulnerability. After
de-allocating all allocated objects, the memory previously
occupied by these objects is released and small pieces of
continuous freed memory might be merged into a larger
piece, which is later provided for expansion of the physmap.
SLABSLABSLAB0xffffffff0xc0000000PhysmapKernel Address SpaceFreeAllocatedNote that the re-ﬁlling step should be conducted immedi-
ately to avoid freed memory to be corrupted by allocations
of kernel from some other active tasks running on the sys-
tem. And this time we use the physmap to introduce mem-
ory collisions with vulnerable kernel objects.
In order to
ﬁll the physmap in kernel space with data completely user-
controlled, mmap is repeatedly called with a large size as
many times as possible. And for every piece of virtual mem-
ory returned back from mmap, we ﬁll that memory with
user-speciﬁed data and call mlock on it. As the physmap
ﬁlled with proper payload grows, the freed memory previ-
ously occupied by vulnerable objects is eventually covered
and memory collisions are successfully achieved.
The following code shows the exploiting part of the pro-
posed physmap-based attack against the malicious kernel
module.
Listing 3: Physmap-based Attack
1 /* exploiting
2
D: Number of objects for defragmentation
E: Iterations of object spraying
P: Number of objects for padding in one group
V: Number of allocated vulnerable objects in one
3
4
5
group
6 */
7
8 /* Step 1: defragmenting */
9 for (int i = 0; i < D; i++)
10
11 /* Step 2: object spraying */
12
13 for (int i = 0; i < E; i++) {
14
p = 0; v = 0;
for (int j = 0; j < P; j++)
syscall(NR_SYS_UNUSED, 1, 0);
15
16
17
pad[p++] = syscall(NR_SYS_UNUSED, 1, 0);
for (int j = 0; j < V; j++)
vuln[v++] = syscall(NR_SYS_UNUSED, 1, 0);
for every vulnerable object, one value inside it is read out
at each stage after calling mmap. If it is directly equal to
that magic value or correctly reﬂects the magic value once
ﬁlled in, then a memory collision happens and the physmap
spraying should be stopped.
5. EFFECTIVENESS OF THE ATTACK
In this section, we evaluate the eﬀectiveness of the pro-
posed object-based memory collision attack and physmap-
based memory collision attack.
5.1 Object-based Attack
5.1.1 Feasibility Analysis
For the attack based on memory collisions between the
kernel objects, the generated message of a custom kernel
module shown in Figure 4 illustrates the details.
In the
module a speciﬁc cache which holds objects of size 576 is
created, then several kernel objects are allocated which be-
long to this cache and the virtual addresses of these objects
are recorded. Then the kernel module frees all the objects
in that cache and allocate 1024 buﬀers of size 512 by invok-
ing kmalloc and their virtual address are also recorded. By
viewing the kernel messages that the kernel module printed
out, it can be seen that a memory collision happens when
the 716th kmalloc-512 buﬀer is created because its virtual
address is the same as the virtual address of the ﬁrst ob-
ject of size 576, which shows the feasibility of object-based
attack.
syscall(NR_SYS_UNUSED, 2, pad[i]);
}
18
19 /* Step 3: freeing */
20 for (int i = 0; i < p; i++)
21
22 for (int i = 0; i < v; i++)
23
24 /* Step 4: creating collisions */
25 unsigned long base = 0x10000000;
26 while (base < SPRAY_RANGE) {
27
syscall(NR_SYS_UNUSED, 2, vuln[i]);
unsigned long addr = (unsigned long)mmap((void
*)base, 0x10000000, PROT_READ | PROT_WRITE
| PROT_EXEC, MAP_SHARED | MAP_FIXED |
MAP_ANONYMOUS, -1, 0);
unsigned long i = addr;
for (; i < addr + 0x10000000; i += 4) *(unsigned
long *)(i) = shellcode;
mlock((void *)base, 0x10000000);
base += 0x10000000;
28
29
30
31
}
32
33 /* Step 5: using freed objects (executing shellcode)
*/
34 for (int i = 0; i < v; i++)
35
syscall(NR_SYS_UNUSED, 3, vuln[i]);
Note that if values stored inside target vulnerable objects
can be read out by speciﬁc syscalls, then an additional pro-
cess in step 4 can be used to improve the eﬃciency and
accuracy of physmap-based attack. First, besides some im-
portant values sprayed in the physmap to overwrite key
entries at certain oﬀset of freed vulnerable objects to avoid
kernel crashes and execute kernel codes, we also spray a
speciﬁc magic value like 0xdeadbeef in the physmap. Then
Figure 4: Memory Collision between Kernel Ob-
jects
5.1.2 Advantages
The object-based attack described in Section 3 uses ob-
jects allocated by kmalloc to re-ﬁll the memory of vulnera-
ble freed objects. Since hundreds of ﬂows in Linux kernel in-
volve creating kmalloc-size buﬀers, objects of kmalloc-size
type are the most controllable candidates to make memory
collisions since it is easy for attackers to allocate in user
programs by syscalls. For example, a buﬀer is created by
kmalloc during the process of sendmmsg in kernel, which is
used to hold control messages during message passing. And
when one writes to one side of the pipe from the other side,
kmalloc-size buﬀers are allocated to hold temporary data.
Kernel objects of size 576[   72.979750] (576)0: f2e0c000 [*][   72.979752] (576)1: f2e0c240[   72.979753] (576)2: f2e0c480[   72.979754] (576)3: f2e0c6c0...Kernel objects of size 512[   72.980204] (512)0: f6b36200[   72.980205] (512)1: f6b36e00[   72.980205] (512)2: f6b34800[   72.980206] (512)3: f6b34000...[   72.980771] (512)716: f2e0c000 [*][   72.980772] (512)717: f2e0c200[   72.980773] (512)718: f2e0c400...The second advantage of these kmalloc-size buﬀers is
that both the content and the size are user-controlled. Since
target vulnerable objects have diﬀerent sizes in diﬀerent
cases, the size of a candidate object should be controlled to
follow the size of a vulnerable object. For many kinds of
kmalloc-size objects, they are often seen as buﬀers which
store data from user space. That brings the full control
of the overwriting content and thus attackers are able to
set addresses of their injected codes or kernel ROP gadgets
inside vulnerable objects.
5.1.3 Limitations
The object-based attack still faces some serious limita-
tions in practice.
• For the attack based on collisions between kernel ob-
jects of the same size, the size of a vulnerable object
has to be aligned to one possible kmalloc sizes, oth-
erwise no valid kmalloc buﬀers can be found to cover
that freed vulnerable object.
• For the attack based on collisions between kernel ob-
jects of diﬀerent sizes, the main problem is its un-
certainty. Without information leakage, deﬁnitely at-
tackers do not clearly know whether target vulnera-
ble objects have been covered by other objects of dif-
ferent sizes, the probability of a successful overwrit-
ing sharply decreases compared to the former object-
based attack.
5.2 Physmap-based Attack
5.2.1 Feasibility Analysis
The feasibility of physmap-based attack depends on whether
the physmap could eventually cover the SLAB caches where
vulnerable objects store.
It is discussed for two diﬀerent
platforms as follows:
32-bit Linux kernel : For 32-bit Linux platforms on most
desktop PCs and Android devices nowadays, kernel space
starts at 0xc0000000 and ends at 0xffffffff as shown in
Figure 3. As described in [17], the physmap starts at
0xc0000000 and is supposed to have a size of 891MB on
x86 architecture and 760MB on ARM architecture, which
indicates that the physmap ends at 0xf7b00000 on x86 and
0xef800000 on Android (ARM). Based on the fact that ker-
nel objects start to be allocated at virtual addresses which
are in range of 0xd0000000 ∼ 0xf0000000 in SLAB caches
and after the object spraying step of physmap-based at-
tack, the vulnerable objects are supposed to be uniformly
allocated in kernel space. Thus when the physmap grows
through spraying, it has large probability to cover target
SLAB caches.
64-bit Linux kernel : For 64-bit Linux platforms, kernel
space starts at 0xffff880000000000 on x86 64 architecture
and for ARM architecture, it starts at 0xffffffc000000000.
As described in [17], the physmap starts at the location
where kernel space starts and is supposed to have a size of
64TB on x86 64 and 256GB on Android (ARM). Consider-
ing the fact that 64-bit systems only use 48 bits for address-
ing, the range of the physmap covers the entire kernel space.
Although allocations of kernel objects on 64-bit Linux plat-
forms behave more random than they do on 32-bit Linux
platforms, kernel objects are still placed in an area of certain
size in kernel space when no memory pressure exists. For
x86 64, kernel objects usually start to be allocated at vir-
tual addresses which are in range of 0xffff880000000000
∼ 0xffff8800ffffffff and for ARM, kernel objects start
to be allocated at virtual addresses which are in range
of 0xffffffc000000000 ∼ 0xffffffc0ffffffff. However,
for any device or PC which has a 64-bit kernel inside, it has
a relatively large RAM size which is commonly not less than
2GB. And after the object spraying step of our physmap-
based attack, there is a substantial probability that memory
collisions happens between the physmap and target SLAB
caches.
Generally speaking, physmap-based attack is considered
to be eﬀective both for 32-bit kernel and 64-bit kernel. In
fact, the size of the entire kernel space is not the only fac-
tor to successful collisions. The size of the RAM size also
plays an important role. Low RAM size may hurt the ef-
fectiveness of physmap-based attack since it limits the total
amount of data an attacker is able to spray in the physmap.
5.2.2 Advantages
Stability: The attack through the physmap is much more
stable than object-based attack.
In fact, the only thing
requiring an attacker to do is to repeatedly map memory
in user space and ﬁll it with proper payload which can be
easily operated in the user program. Overwriting through
the physmap does not allocate any kernel object by kernel
allocators and attackers do not need to be informed of kernel
memory layout at any time.
Note that the physmap and all SLAB caches are stored
in kernel space simultaneously, and surly they do not have
their own private space due to limited virtual address space
for Linux kernel. Considering the certain distance between
initial locations of the SLAB caches storing vulnerable ker-
nel objects and the physmap, the object spraying step makes
the vulnerable objects not gather in one place but appear at
diﬀerent places in the kernel. That also ensures the stability
of such a probabilistic attack strategy.
Finally, the additional step of physmap-based attack also
improves stability. When attackers can be informed that
vulnerable kernel objects have already been correctly over-
written then further kernel spraying which may bring un-
expected results is no longer needed.
Separation: The physmap is like a nightmare since it cir-
cumvents the separation of kernel objects provided by ker-
nel allocators not from the internal mechanism but from an
overall view on the memory management of Linux kernel.
The key point is that kernel needs to recycle freed memory
for future use and do not have the ability to divide the whole
kernel memory space into diﬀerent parts for diﬀerent uses
due to limited memory size and the eﬃciency requirement
of the kernel. That leaves the physmap, one of the best
candidates, an opportunity to overwrite the freed mem-
ory once occupied by vulnerable objects and create stable
memory collisions.
Note that physmap-based attack does not care about
whatever the size of a vulnerable object is and the type of
a vulnerable object is, which means a thorough bypassing
of the separation protection provided by Linux kernel.
Data control : Since the data sprayed in the physmap
all comes from the data ﬁlled in mmaped memory in user
space, it is for sure fully user-controlled. Any malicious
content attackers desire for is able to be ﬁlled into the freed
memory once occupied by a target vulnerable object.
Wide applicable scenarios: Although the physmap-based
attack is designed to achieve a generic approach to exploit-
ing use-after-free vulnerabilities, it can be applied to exploit
other types of vulnerabilities in Linux kernel based on the
fact that the physmap has the ability to cover nearly any
free space in kernel. One possible usage of physmap-based
attack is to exploit uninitialized memory vulnerabilities. In
fact, the physmap-based attack is deﬁnitely helpful and ef-
fective when a free space is needed to be occupied when
exploiting diﬀerent kinds of kernel vulnerabilities.
5.2.3 Comparison with Previous Techniques
Previous techniques to achieve overwriting on kernel ob-
jects which have use-after-free vulnerabilities always try
to leverage the features of kernel allocators. For exam-
ple in [6], attackers manage to overwrite a speciﬁc kernel
object of size 224 with another kernel object of a close
size, 256. For this case, the stable overwriting can also
be achieved by physmap-based attack. However, previous
techniques become useless in the following situations mean-
while physmap-based attack keeps performing well:
Various sizes: Previous techniques always try to place
a diﬀerent kernel object of similar size into the area once
occupied by a vulnerable object to exploit kernel use-after-
free vulnerabilities. However the size of a target vulnera-
ble object always varies. Take the CVE-2015-3636 as an
example (details are introduced in Section 6.2), vulnera-
ble PING socket objects may have at least four diﬀerent
sizes on Android devices of diﬀerent kinds of brands. And
also the sizes of a vulnerable kernel object are not identical
in 32-bit kernel and 64-bit kernel. Facing such situations,
previous techniques have to hard-code in exploit codes to
achieve stable overwriting for diﬀerent kernels. Thus sev-
eral diﬀerent versions of the attack programs are required.
If the size information cannot be known in advance, then
previous techniques become much less eﬀective since what