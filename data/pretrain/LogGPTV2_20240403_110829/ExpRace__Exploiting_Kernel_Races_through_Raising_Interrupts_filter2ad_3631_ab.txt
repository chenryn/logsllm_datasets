USENIX Association
30th USENIX Security Symposium    2365
Control dependencyData dependency(a) Single-variable raceUser thr for Taskyy:User thr for Taskxx:Kernel thr for Taskxx:Kernel thr for Taskyy:Core 1 (C1C1)Core 0 (C0C0)Syscallxx()Syscallyy() TyTy W(M)W(M)B R(M)R(M)C R(M)R(M)A(c) Non-inclusive multi-variable race( Tx≥TyTx≥Ty ) TxTxUser thr for Taskyy:User thr for Taskxx:Kernel thr for Taskxx:Kernel thr for Taskyy:Core 1 (C1C1)Core 0 (C0C0)Syscallxx()Syscallyy()BC TyTy W(M1)W(M1) W(M2)W(M2)D R(M2)R(M2)A  R(M1)R(M1) TxTx(b) Inclusive multi-variable race( Txlist), which shown in A . Then the buffer
(i.e., port->name) is initialized as user input in D .
Simultaneously, Taskx attempts to free the port, which is
allocated by Tasky through ioctl() with a free command (i.e.,
SND_SEQ_DELETE_PORT). In response to the free request, the
kernel thread for Taskx finds the corresponding buffer (i.e.,
port) from the list (i.e., p->list), which was also referenced
by Tasky ( B ). Then it frees the buffer ( C ).
Suppose these two tasks perform the behaviors above. In
that case, it may result in a multi-variable race, which involves
the following two variables: i) p->list, which is accessed by
A and B , and ii) port, which is accessed by C and D . More
specifically, the atomicity is violated if the execution order
follows A ≫ B ≫ C ≫ D . Under this execution order, Tasky
assumes that when it invokes D , port is active. However, port
is already freed by Taskx since no synchronization method,
such as spinlock is used to retain port. Therefore, Tasky uses
port after being freed, resulting in a well-known memory
2366    30th USENIX Security Symposium
USENIX Association
    Environment Setting TxTxUser thr for Taskyy :User thr for Taskxx :Kernel thr for Taskxx :ioctl(fd, SND_SEQ_CREATE_PORT);kfree(FHJ);Kernel thr for Taskyy :list_for_each_entry( ... p->list)) {    if (p->addr.port == input) {        port = p;list_add_tail(&port->list, &p->list);strlcpy(port->name, info->name,      sizeof(port->name));)*,+Race-stage1    Create two tasksInitialization-stagethread/forkTaskxxTaskyy(≈≈ 35)Core 1 (C1C1)Core 0 (C0C0) TyTyport = kzalloc();(≈≈ 450)ioctl(fd, SND_SEQ_DELETE_PORT);2fd = open("/dev/snd/seq”)corruption issue, use-after-free.
to
leak the
struct snd_seq_queue
To fully exploit this vulnerability, we need to trigger the use-
after-free vulnerability three times. We first spray the file
pointers through msgsnd(). Next, we trigger the vulnerability
to partially overwrite the struct snd_seq_prioq *tickq
within
sprayed
struct file pointer. Then, we trigger the vulnerabil-
ity to overwrite struct iovec [52] to perform the arbitrarily
address read attack, which reads struct *f_cred within
struct file. Finally, we trigger the vulnerability to
overwrite struct iovec once more to perform the arbi-
trary address write with the value zero, which eventually
overwrites the root privilege to the credential structure
(i.e., struct cred). This completes the privilege escalation
attack.
However, exploiting CVE-2017-15265 through bruteforc-
ing is virtually infeasible because Pmulti is zero when Tx > Ty.
More specifically, we observed that Tx is about 12 times longer
than Ty, according to our evaluation (§7.1), because there are
many instructions executed in between B and C . Our eval-
uation also has shown that the brute-force exploitation fails
even after trying for 24 hours, confirming that it is nearly
impossible to meet the violation execution order.
3 Problem Scope and Research Approaches
3.1 Problem Scope
This paper proposes EXPRACE, which aims at developing
a practical exploitation method for a non-inclusive multi-
variable race (i.e., when Tx > Ty as shown in §2). EXPRACE
assumes a typical privilege escalation attack scenario—
escalating its privilege from the user to the kernel privilege,
where an adversary already has access to the user privilege
so that she/he can invoke system calls that an underlying ker-
nel provides. As such, EXPRACE does not assume that the
adversary has the kernel privilege, meaning that the adversary
cannot leverage any kernel debugging features. Under this as-
sumption, EXPRACE develops user-level applications which
are designated to attack race issues. In particular, EXPRACE
presents exploitation methods for such race issues in the mod-
ern kernel, including Linux (§5), Microsoft Windows (§6.1),
and Mac OS X (§6.2).
A privilege escalation attack exploiting a race vulnerability
mostly takes the following two steps: 1) triggering a race,
which leads to memory corruption (such as buffer overflows,
double-free, use-after-free, etc.); 2) exploiting a memory cor-
ruption, which accordingly hijacks the control-flow (such as
ROP attacks [48]) or data-flow (such as DOP attacks [25]) to
escalate the privilege eventually. We focus on the first step,
triggering the race, and we do not cover the second step, ex-
ploiting memory corruption. This is because the second step
is not related to generic race issues but related to an exploita-
tion technique for a specific memory corruption issue studied
Figure 3: A research approach of EXPRACE to exploit a non-
inclusive multi-variable race. Using Taskint, EXPRACE indirectly
causes the kernel to raise an interrupt, which in turn enlarges the
original Ty and thus transformed into exploiting an inclusive multi-
variable race.
by many previous works [14, 25, 48, 51, 64].
3.2 Research Approaches
The key insight behind EXPRACE is in intentionally enlarging
Ty in order to transform the hard-to-exploit non-inclusive
multi-variable race into the easy-to-exploit inclusive multi-
variable race (illustrated in Figure 3). To this end, EXPRACE
attempts to enlarge Ty by raising an interrupt. Specifically, Ty
can be enlarged if following two conditions meet: 1) correct
interrupt destination: an interrupt should be delivered to the
CPU core running the kernel thread of Tasky; and 2) precise
interrupt timing: an interrupt should be delivered when the
kernel thread of Tasky executes an instruction between A
and D ; If these two conditions were met, the core received
the interrupt will switch to the interrupt handler (so as to
immediately handle the interrupt), and after completing the
interrupt handling, that core will switch back to the kernel
thread of Tasky. As a result, due to the time handling the
interrupt (annotated as TE), the original Ty will be enlarged.
We denote such an enlarged time window as Ty′ such that
Ty′ = Ty + TE, and we call Ty′ as a race window.
To clearly understand the theoretical aspect of this exploita-
tion method, we model the probability of successful exploita-
tion as PEXPRACE
. This probability is modeled under the as-
sumption that EXPRACE can control that the interrupt can
be delivered to the destined core. We further assume that for
each Syscally invocation, both Syscallx and Syscallint kept
being executed without any noise.
multi
Ty
TSyscallint
Ty′−Tx
TSyscallx
if TSyscallx ≤ Ty′
if TSyscallx > Ty′ and Tx  Ty′ and Tx ≥ Ty′.
For the first case (i.e., TSyscallx ≤ Ty′), the exploitation
would be successful if an interrupt is raised within Ty, be-
USENIX Association
30th USENIX Security Symposium    2367
User thr for Taskyy:User thr for Taskxx:Kernel thr for Taskxx:Kernel thr for Taskyy:Core 1 (C1C1)Core 0 (C0C0)Syscallxx()Syscallyy()D R(M2)R(M2)User thr for Taskintint :Kernel thr for Taskintint :Core 2 (C2C2)Syscallintint() TxTxC W(M2)W(M2) W(M1)W(M1)BSend interrupt to C1C1Interrupthandler Ty′Ty′ TETE TyTyA R(M1)R(M1)Control dependencyData dependencycause Tx is always overlapped within the race window Ty′. For
the second case (i.e., TSyscallx > Ty′ and Tx  Ty′ and Tx < Ty′), the proba-
bility is zero because Tx is too large to be overlapped within
the extended race window, so the race would never occur.
Research Challenges. Since an interrupt mechanism is only
controllable from the kernel and thus non-controllable from
the user, following research challenges are arising to accom-
plish EXPRACE. First, how to raise an interrupt which can
be used with user privileges and affect kernel mode execu-
tion? There is no direct way to raise an interrupt since modern
kernels limit user’s control over interrupts. Moreover, there
are many different types of interrupts (from IPI to hardware
interrupts), and we do not know if any of those are control-
lable at some extent by users. Second, suppose EXPRACE is
somehow able to raise an interrupt, but how does EXPRACE
deliver the interrupt to the destined core? Modern kernels
are heavily optimizing its interrupt handling mechanism, as
it is very critical to its runtime responsiveness. As such, its
core affinity with respect to interrupt handling can be very
different for each type of interrupt, challenging EXPRACE for
exploiting non-inclusive multi-variable races.
4 Interrupt Handling in Linux
The exploitation mechanism of EXPRACE highly depends on
how it triggers an interrupt. Hence, this section provides the
necessary background on the interrupt handling mechanism
before presenting EXPRACE’s exploitation methods using an
indirect interrupt raising mechanism (§5). Specifically, we
describe the basic mechanism of interrupts and its different
types in this section. Note that most of the descriptions in
this section are Linux specific. Since its general working
mechanism is similar in other OSes, we will clearly state
its differences when describing the exploitation methods for
non-Linux systems in §6.
An interrupt is an input signal delivered to the processor,
notifying an event that requires immediate attention. As such,
an interrupt diverts the normal execution flow since a CPU
core, which received the interrupt, first handles the interrupt
after temporarily stopping the execution. While there are
many different types of interrupts, we focus on hardware in-
terrupts and inter processor interrupts (IPIs), which are the
most relevant to EXPRACE’s exploitation techniques. Hard-
ware interrupt request (IRQ) is an electric signal sent from
an external hardware device to a processor through IO-APIC.
This facilitates communication with operating systems. Inter
Processor Interrupt (IPI) is a special type of an interrupt in
multi-processor systems, which delivers the command from
a CPU core to another. In Linux, there are several different
Method
Relation b/w
Taskx & Tasky
User functions
to send an interrupt
Metadata determining
a core to receive interrupts
Resched IPI
thread or
process
sched_setaffinity(),
read() – write()
cpu_set_t *mask,
Wait process’s core affinity
Func Call IPI
(TLB shootdown)
process
mprotect(),
munmap()
Func Call IPI
(membarrier)
HW interrupt
process
membarrier()
thread or
process
Send request to a device
struct mm_struct’s
cpu_bitmap
struct mm_struct’s
membarrier_state
HW interrupt’s
affinity
Table 2: A list of EXPRACE’s exploitation methods in Linux
types of IPIs, rescheduling IPI, wake-up IPI, stop IPI, function
call IPI, etc., and each IPI transfers its own command across
CPU cores. Similar to the hardware interrupt, upon receiving
the IPI the respected CPU core immediately starts processing
the IPI.
It is worth noting that both hardware interrupts and IPIs
cannot be raised from user-level code, which we attempt to
address in the next section (§5).
5 Exploiting Kernel Races in Linux
This section proposes EXPRACE, a new race exploitation tech-
nique, which extends the race window by indirectly raising in-
terrupts. The rest of this section presents various exploitation
methods, particularly focusing on Linux systems: (i) using
reschedule IPI (§5.1); (ii) using non-reschedule IPI (TLB
Shootdown IPI (§5.2.1) and membarrier IPI (§5.2.2)); and
(iii) using hardware interrupts (§5.3).