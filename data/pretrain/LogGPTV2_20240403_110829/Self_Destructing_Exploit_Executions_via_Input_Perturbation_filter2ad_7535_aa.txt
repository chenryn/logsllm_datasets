title:Self Destructing Exploit Executions via Input Perturbation
author:Yonghwi Kwon and
Brendan Saltaformaggio and
I Luk Kim and
Kyu Hyung Lee and
Xiangyu Zhang and
Dongyan Xu
A2C: Self Destructing Exploit Executions via Input Perturbation
Yonghwi Kwon*, Brendan Saltaformaggio*, I Luk Kim*, Kyu Hyung Lee†, Xiangyu Zhang*, and Dongyan Xu*
*Department of Computer Science, Purdue University
{kwon58, bsaltafo, kim1634, xyzhang, dxu}@cs.purdue.edu
†Department of Computer Science, University of Georgia
PI:EMAIL
Abstract—Malicious payload injection attacks have been a
serious threat to software for decades. Unfortunately, protec-
tion against these attacks remains challenging due to the ever
increasing diversity and sophistication of payload injection and
triggering mechanisms used by adversaries. In this paper, we
develop A2C, a system that provides general protection against
payload injection attacks. A2C is based on the observation that
payloads are highly fragile and thus any mutation would likely
break their functionalities. Therefore, A2C mutates inputs from
untrusted sources. Malicious payloads that reside in these inputs
are hence mutated and broken. To assure that the program
continues to function correctly when benign inputs are provided,
A2C divides the state space into exploitable and post-exploitable
sub-spaces, where the latter is much larger than the former, and
decodes the mutated values only when they are transmitted from
the former to the latter. A2C does not rely on any knowledge of
malicious payloads or their injection and triggering mechanisms.
Hence, its protection is general. We evaluate A2C with 30 real-
world applications, including apache on a real-world work-load,
and our results show that A2C effectively prevents a variety of
payload injection attacks on these programs with reasonably low
overhead (6.94%).
I.
INTRODUCTION
Attacks which exploit software vulnerabilities are among
the most prevalent cyber-security threats to date. This is due,
in part, to many complex combinations of potential attack
vectors: Buffer overﬂow attacks, Return-to-libc attacks [58],
ROP [50], Jump-oriented programming (JOP) [10], and Heap
spraying [60], [27] to name just a few. Unfortunately, this ever
expanding variety of exploit attack vectors has led to a constant
“cat and mouse game” of building defenses as each new attack
is released.
In light of this, many existing protection mechanisms focus
on speciﬁc attack vectors and become less effective (or even
completely ineffective) for others. For example, non-executable
stack and heap have difﬁculty preventing code reuse (e.g.,
ROP) attacks because the executable payload is constructed
from the original code of the application. Shellcode detec-
tion techniques are only effective against injection of binary
executable code and are often bypassable [32], [26], [39],
[65]. Control Flow Integrity [66], [31], [73], [43] prevents
attacks which exhibit certain abnormal control ﬂows within a
Permission  to  freely  reproduce  all  or  part  of  this  paper  for  noncommercial 
purposes is granted provided that copies bear this notice and the full citation 
on the ﬁrst page. Reproduction for commercial purposes is strictly prohibited 
without the prior written consent of the Internet Society, the ﬁrst-named author 
(for  reproduction  of  an  entire  paper  only),  and  the  author’s  employer  if  the 
paper  was  prepared  within  the  scope  of  employment.
NDSS  ’17,  26  February  -  1  March  2017,  San  Diego,  CA,  USA
Copyright  2017  Internet  Society,  ISBN  1-891562-46-0
http://dx.doi.org/10.14722/ndss.2017.23476
victim program. Further, some defense techniques may entail
non-trivial overhead (e.g., [6]) or require hardware support
(e.g., [41]), which affects their application in practice. Based
on this trend of attack-speciﬁc defense, we are motivated
to look for an entirely new, more fundamental weakness of
software exploits to provide an attack vector independent
protection mechanism.
It
turns out
that all software exploit attacks invariably
have two common characteristics: First, they all need to inject
an exploit payload into the target application. This payload
could be a piece of executable code (shellcode) or information
that allows constructing the malicious instruction sequence at
runtime (e.g., a ROP chain that contains the entry addresses
these payloads are famously brittle.
of gadgets). Second,
Speciﬁcally, exploit payloads are designed with very strict
semantic assumptions about the environment (e.g., memory
layout, libraries, or known binary instructions) which require
each byte of the payload to be carefully tailored to a victim.
In this paper, we will show that these invariant characteris-
tics of exploit attacks make it possible to protect applications
from exploit injections independent of the attack vector they
use. Speciﬁcally, we leverage the observation that exploit
payloads (regardless of their attack vector) are so brittle that
any mutation would break their execution — i.e., cause the
execution to crash. For example, even simple mutation of
x86 shellcode results in invalid instructions. Similarly, most
sequences of ROP addresses no longer form an executable
gadget chain if even a single byte is changed. Secondly,
since these exploit payloads must be injected into a victim
application, their behavior eventually diverges from that of
the application’s legitimate inputs. Therefore, we propose that
exploit payloads may be easily disabled via a “shoot ﬁrst
and ask questions later” policy, whereby all input to a victim
program is immediately mutated and only those that are
beyond the control of the adversary are decoded.
Based on the above observations, we have developed the
A2C (or “Attack to Crash”) technique. A2C naturally exploits
the brittleness of attack payloads by setting these attacks on
track to crash before malicious logic is executed. First, any
buffer inputs from untrusted sources are securely encoded
using A2C’s One-Time Dictionary, which varies for each input
buffer to prevent memory disclosure/value guessing based
attacks. Since all the untrusted inputs are mutated, malicious
payloads that reside in these inputs are also mutated, resulting
in broken payloads which will induce crashes when executed.
Later, A2C must undo the mutation in the buffer inputs,
when the program begins using these inputs to compute new
values, so that our mutation does not cause any exceptions for
legitimate input.
Fig. 1. Overall procedure of A2C.
Our evaluation shows that A2C is able to protect a variety
of applications against a wide spectrum of exploit attacks
regardless of their injection methods, without affecting the
normal functionalities of the program. Further, because A2C
requires no knowledge of the speciﬁc attacks (only leveraging
the two invariant characteristics mentioned above) it may even
prevent currently unknown injection attack types in the future.
The detailed threat model considered in this paper is presented
in Section V.
Our contributions are summarized in the following:
• We propose the novel idea of partitioning program
state space into the exploitable and post-exploitable
sub-spaces so that we only need to protect the smaller
exploitable sub-space, which is critical to A2C’s efﬁ-
ciency and effectiveness.
• We develop a novel constraint solving based approach
that can determine the boundary of the two sub-spaces.
This serves as the basis to compute the execution
points where the mutation can be safely undone.
• We develop a ﬂow-, context-, and ﬁeld-sensitive static
analysis to identify the places at which A2C needs
to undo the mutation so that execution on legitimate
inputs is not affected.
• We develop an efﬁcient runtime that leverages a One-
Time Dictionary, which projects a value to another
unique value. The dictionary varies for each input
buffer to prevent memory disclosure based attacks.
A2C also features efﬁcient calling context encoding
to support undoing input mutation.
• We develop a prototype A2C. The evaluation results
show that A2C effectively prevents a number of known
payload injection attacks with low overhead (6.94%).
II. SYSTEM OVERVIEW
In this section, we present an overview of A2C, which is
based on the following two observations. (1) Most malicious
payloads reside in buffers and they only go through copy
operations or simple transformations before the attack is
launched. It is very rare for these payloads to undergo complex
transformations in the victim program before being executed.
This is due to the difﬁculty in controlling the transformations
(in the victim program) to generate meaningful payloads. (2)
Malicious payloads are very fragile. Any mutation often leads
to an unsuccessful attack. For example, changing a few bits at
the beginning of a shellcode can easily throw off the sequence
of executed instructions, leading to a crash.
The overarching idea of A2C is to protect a program
from malicious injection attacks by perturbing or encoding
inputs from untrusted sources. However, inputs from untrusted
sources (e.g., packets from remote IPs) are not necessarily
malicious. We need to ensure that our perturbation does not
fail executions based on non-exploit inputs. According to ob-
servation (1), we aim to undo the perturbation when the buffer
2
Fig. 2. Decoding frontiers.
data goes beyond copy operations/simple transformations and
starts being used in benign computation.
In the following, we use the diagram in Fig. 2 to illustrate
the life cycle of buffer data and hence the intuition behind
A2C. After the buffer data are loaded through input functions,
they may undergo a number of transformations, including copy
operations (e.g., memcpy() and strcpy()) that copy a buffer to
another target buffer, constant table lookup (e.g., in iconv(),
toupper(), mbtowc(), and wctomb()), and simple transfor-
mative operations (e.g., additions with a constant). Then, the
buffer data will eventually encounter one of the following three
kinds of operations: (1) Comparative operations, in which
elements in the buffer are used in comparisons; (2) Terminal
operations,
in which the buffer data are passed to output
library functions (e.g., write(), send(), and printf()); (3)
Uncontrollable transformative operations, in which elements
in the buffer undergo transformations that disallow the attacker
to control the values beyond these transformations to construct
meaningful payloads. For instance, type widening copies a
value of smaller type (e.g., char) to an array element of larger
type (e.g., integer) so that each element in the array is padded
with leading 0’s. As such, the resulting byte sequence denoted
by the array cannot serve as a meaningful payload.
We call
these three kinds of operations the decoding
frontier (DF) because A2C should undo the perturbation for
the buffer elements involved before executing the operations.
Intuitively, we consider the space before the frontier the
exploitable space where the malicious payloads are supposed
to take effect and without perturbation would successfully
exploit the program. Therefore, we use perturbation to achieve
protection in this space. The space after the frontier is referred
to as the post-exploitable space. This is because controlling the
payload becomes infeasible if it has gone through these benign
transformations conducted by the victim program. Therefore, it
is safe to undo our perturbation before the decoding frontier so
that benign inputs can be used in computation as usual1. The
core technical challenge for A2C is hence to identify the DF
of a subject program and perform instrumentation accordingly.
More discussion about the decoding frontier can be found in
Section IV-A.
Another interesting observation that makes our solution
1Here we assume that output library functions are hardened and thus cannot
be exploited by the decoded buffers.
Static Analysis PhaseFlow/Context/Field Sensitive Static AnalysisDecoding/Encoding Sets (DE Sets)Instrumentation PhaseInstrument Acc. The DE SetsInstrumentedProgramTarget (Original) ProgramRuntime PhaseOne-Time Dictionary Based EncodingInstrument Calling Context EncodingDecoding Frontier Computation PhaseConstraint SolverUntrusted Input SpecificationTarget (Original) ProgramStatic Taint AnalysisUntrusted Input SpecificationTarget (Original) ProgramUncontrollable Operations Setchar Input[...];Input = read(...);Input[...] == 'C'; ...x = (int) Input[...];x = Input[...] & 1;x = Input[...] * y / ... ; ...ComparativeUncontrollable Transformativewrite(Input, ✁); ...TerminalDecoding Frontiersmemcpy(..., Input);strcpy(✁, Input);toupper(Input);iconv(..., Input, ...);mbtowc(..., Input, ...);x = Input[...] + 3;x = Input[...] * 2; ...Controllable Transformative(Copy operations)*...exitExploitable spacePost-exploitable spaceFig. 3. Original and instrumented programs of demonstrative example.
feasible is that the exploitable space is usually much smaller
than the post-exploitable space as most computation happens
in the post-exploitable space. As such, the frontier tends to be
small and shallow and as explained above, operations beyond
the frontier do not need our attention.
Overall Procedure. Fig. 1 shows the complete procedure of
A2C. There are four phases: constraint solving based decoding
frontier computation, static analysis for determining encoding
and decoding places which are a superset of the decoding
frontier, instrumentation, and runtime.
First, we leverage constraint solving to determine the
uncontrollable operations. These operations, together with the
comparative and terminal operations, form the decoding fron-
tier. This phase simply marks all the operations on the frontier.
Second, a ﬂow-, context-, and ﬁeld-sensitive analysis is
applied to determine the places to instrument. It takes three
inputs: the LLVM IR of the program, the decoding frontier
from the ﬁrst phase, and the untrusted input speciﬁcation that
identiﬁes a set of library functions that read inputs, such as
recv() for network inputs and read() for ﬁle streams. In this
phase, A2C produces two outputs. Speciﬁcally, the decoding
set is a superset of the decoding frontier and the encoding
set contains the statements to encode (input) values, such
as recv() in network programs. Interestingly, the encoding
set may also contain instructions that load constant values.
Explanations about why we need to encode constants can
be found in Section IV-C. The computation of decoding and
encoding sets (DE sets for short) is iterative as new elements on
encoding sets may introduce additional decoding operations.
Third, the instrumentation phase statically instruments the
program according to the DE sets. An important observation
is that the decoding frontier is context sensitive. Different
inputs may lead to different calling contexts of a function
invocation. The membership of a statement in the DE set may
change with those contexts. As such, upon the execution of a
statement in the DE set, we need to know the current calling
context to determine if the instrumented version or the original
version of the statement should be executed. Therefore, part
of the instrumentation phase handles the problem of efﬁciently
tracking the current calling context.
Lastly, the runtime supports execution of the instrumented
program. It features encoding based on a One-Time Dictionary,
which projects a plaintext value to a unique encoded value.
Different input buffers use different dictionaries to prevent
memory exposure based exploits.
III.
ILLUSTRATIVE EXAMPLE
In this section, we use a real-world example to illustrate
A2C’s operation. We use the nginx 1.4.0 web-server as the
subject program. It has two known heap buffer overﬂow and
integer overﬂow vulnerabilities, which can be triggered by pro-
viding crafted HTTP requests containing malicious payloads.
Fig. 3 shows two code snippets with part of the original nginx
program on the left and the corresponding instrumented ver-
sion on the right. The column in the middle shows how the
two code snippets process the request differently.
First, both programs receive a POST request at Line 136 in
ngx_recv.c. Since the request is from an untrusted source,
the instrumented program encodes the buffer. For simplicity of
discussion, the encoding here is to subtract 1 from every byte.
Encode() denotes this modiﬁcation. The HTTP request “PO
ST /index.php HTTP/1.1\r\nHost:...” is hence
encoded as “ONRS..hmcdw-ogo.GSSO.0-0..Gnrs9.
..”. The request is parsed at Lines 160 and 182 in ngx_
http_parse.c, which contain comparative operations on
some buffer data and are hence part of the decoding frontier.
Therefore, the instrumented program calls Decode() to undo
the perturbation so that the program can parse and process the
request correctly. Note that it only decodes a few bytes (of
ﬁxed length) at a time so that the decoded data cannot be
run as any meaningful payload. Also observe that the original
buffer remains encoded. This is achieved by only decoding the
3
3. Comparing the first 4 bytes ("POST")2. Comparing the first byte ('P')         ssize_t   ngx_unix_recv( … ) {             …136:      n = recv(c->fd, buf, size, 0); Encode(buf, n);File: ngx_recv.c139:  for (p = b->pos; p last; p++) {140:    ch =   *p;           …160:    if (  Decode(ch, 1)  == ' '  ) {             ...179       case 4:               ...182:        if (  ngx_str30_cmp(  Decode(m, 4)  , 'P','O','S','T')  ) {183:           r->method = NGX_HTTP_GET;File: ngx_http_parse.cPOST /index.php HTTP/1.1\r\nHost:...ONRS..hmcdw-ogo.GSSO.0-0 . .Gnrs9...POST..hmcdw-ogo.GSSO.0-0 . .Gnrs9...PNRS..hmcdw-ogo.GSSO.0-0 . .Gnrs9...Encoding/Decoding a request1. Encoding a request         ssize_t   ngx_unix_recv( … ) {             …136:      n = recv( c->fd,  buf,  size,  0);File: ngx_recv.c139:   for (p = b->pos; p last; p++) {140:     ch = *p;            …160:     if (  ch == ' '  ) {              ...179:       case 4:                 ...182:          if (  ngx_str30_cmp( m, 'P','O','S','T' )  ) {183:             r->method = NGX_HTTP_POST;File: ngx_http_parse.cPOST /index.php HTTP/1.1\r\nHost:...POST /index.php HTTP/1.1\r\nHost:...Original ProgramInstrumented Program        int ngx_http_do_read_client_request_body( … ) {             …302:      n = c->recv(c, rb->buf->last, size);File: ngx_http_request_body.c        int ngx_http_do_read_client_request_body( … ) {            …302:     n = c->recv(c, rb->buf->last, size); Encode(rb->buf->last, n);            …File: ngx_http_request_body.c\x90\x90\x90\x90\x90\x90\x90\x90\x90...\x89\x89\x89\x89\x89\x89\x89\x89\x89...4. Injected Code by Heap overflow/spraying        int ngx_http_request_handler( … ) {             …2133:       r->read_event_handler(r);File: ngx_http_request.ccall r->read_event_handler (= 0x00b7c010)call r->read_event_handler (= 0xffb6bf0f)5. Jump to the injected code        int ngx_http_request_handler( … ) {             …2133:       r->read_event_handler(r);File: ngx_http_request.cvalues after they are loaded into variables of primitive types