the  AspectC++Ext programs as for the other programs. The 
main reason is a higher number of read and write operations 
on  invalid  memory  addresses.  This  in  turn  is  due  to  the 
higher  frequency  of  memory  operations  in  the  code 
generated by AspectC++Ext.  
The  TTR-FR  mechanism  executes  the  main  program 
loop three times and performs a majority vote on the three 
produced  outputs.  Most  often  the  mechanism  can  recover 
from  a  detected  error,  but  occasionally  it  produces  three 
different  outputs  and  the  mechanism  therefore  cannot 
recover. In this case the error is signaled as a detected error. 
Although  somewhat  larger  for  the  brake-by-wire  than  for 
the Fibonacci, the portion of detected errors (CoverageDSW) 
is small for all implementations.  
Considering  CoverageTotal,  AspectC++Opt  produces 
slightly  better  results  than  the  C  implementation,  and 
AspectC++Ext  produce  slightly  less  for  the  brake-by-wire 
system but gives the best results for the Fibonacci.  
However, the differences are very small. For the break-
by-wire  system    they  are  within  1%  and  for  the  Fibonacci 
almost  within  2%.  Hence,  the  choice  of  implementation 
language  can  not  in  this  case  be  seen  as  having  any 
significant  impact  on  the  fault  tolerance  of  the  target 
applications. 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:29:31 UTC from IEEE Xplore.  Restrictions apply. 
310TABLE VII.   FAULT COVERAGE FOR PROGRAMS EQUIPPED WITH THE 
TTR-FR MECHANISM PRODUCED WITH THE LOW LEVEL OF COMPILER 
OPTIMIZATION 
TABLE VIII.   FAULT COVERAGE FOR PROGRAMS EQUIPPED WITH THE 
TTR-FR MECHANISM PRODUCED WITH THE HIGH LEVEL OF COMPILER 
OPTIMIZATION 
Coverage 
Fibonacci 
   C 
 AspectC++Ext 
 AspectC++Opt 
Brake-by-wire 
   C 
 AspectC++Ext 
 AspectC++Opt 
NE 
12.3% 
15.8% 
13.6% 
34.5% 
26.3% 
33.2% 
CSW 
33.4% 
27.2% 
32.6% 
15.2% 
12.0% 
17.1% 
DSW  DHW 
0.5% 
0.2% 
0.4% 
0.9% 
0.8% 
0.5% 
49.0% 
55.0% 
50.3% 
45.6% 
56.3% 
45.3% 
TO 
1.3%
0.3%
1.0%
0.2%
0.1%
0.3%
Total
96.4%
98.5%
97.8%
96.4%
95.5%
96.5%
the  programs  were  produced  with 
2)  Experiments using high compiler optimization level 
Table VIII shows the results for the TTR-FR mechanism 
when 
the  high 
optimization  level.  The  differences  in  the  total  coverage 
(CoverageTotal)  are  small  except  for  the  C  version  of  the 
Fibonacci application. This program obtains a  CoverageTotal 
which is almost 19% lower than the best result. The reason 
is that this implementation is small enough that the compiler 
can reduce it to a single function. One could suspect that the 
compiler  would  then  identify  and  completely  remove  the 
time redundancy – but this is not the case, as can be seen by 
the high error correction coverage (CoverageCSW). However, 
it does destroy the integrity of the mechanism, creating new 
single  points  of  failure  causing  the  low  CoverageTotal.  We 
tried  to  add  the  “fno-inline-functions”  option  forcing  the 
compiler not to inline functions. This restored the integrity 
of  the  mechanism  and  raised  the  CoverageTotal  by  almost 
10%.  Yet  the  CoverageTotal  is  still  significantly  lower  than 
for  the  aspect-oriented   implementations.   Hence,  for  the  
Coverage 
Fibonacci 
   C 
   C (no inline) 
  AspectC++Ext 
  AspectC++Opt 
Brake-by-wire 
   C 
  AspectC++Ext 
  AspectC++Opt 
CSW 
NE 
43.0% 
4.6% 
10.9% 31.2%
17.1% 21.9% 
38.8% 
18.4% 
34.2% 
18.4% 
28.7% 16.6% 
32.6% 
20.7% 
DSW  DHW 
0.9%  
0.0% 
1.3%  
2.2%  
1.3%  
1.5%  
1.7%  
31.2% 
44.8% 
57.5% 
37.1% 
41.9% 
46.5% 
40.4% 
TO 
0.0% 
2.4%
0.6% 
0.3% 
0.1% 
0.2%
0.2% 
Total
79.6% 
89.4%
98.4% 
96.8% 
95.9% 
93.5% 
95.6% 
Fibonacci application they produce much better results than 
the  C  implementation.  In  the  case  of  the  brake  by  wire 
application  the  difference  between  the  programs  is  small. 
AspectC++Ext has a slightly lower CoverageTotal than the 
others but did on the other hand produce the best results for 
Fibonacci.  
D.  Effects from using compiler optimization 
For  the  experiments  we  used  two  different  levels  of 
compiler optimization together  with GCC.  As described in 
Section II.B, the low level has all optimizations turned off 
except  that  inline  statements  within  the  source  code  are 
honored. The high level is equal to GCC optimization level 
three except that strict aliasing is turned off. In this section 
we  discuss  the  general  fault  coverage  patterns  that  can  be 
observed  when  comparing  the  two  optimization  levels.  As 
can be seen in Fig. 4, using GCC optimizations reduced the 
effectiveness of the hardware mechanisms.  
0.0%
10.0%
20.0%
30.0%
40.0%
50.0%
60.0%
70.0%
Brake-by-wire; TTR-FR; C
Brake-by-wire; TTR-FR; AspectC++-Ext
Brake-by-wire; TTR-FR; AspectC++-Opt
Fibonacci; TTR-FR; C
Fibonacci; TTR-FR; AspectC++-Ext
Fibonacci; TTR-FR; AspectC++-Opt
Brake-by-wire; DS-CFC; C
Brake-by-wire; DS-CFC; AspectC++-Ext
Brake-by-wire; DS-CFC; AspectC++-Opt
Fibonacci; DS-CFC; C
Fibonacci; DS-CFC; AspectC++-Ext
Fibonacci; DS-CFC; AspectC++-Opt
31.2%
45.6%
41.9%
40.4%
46.5%
45.3%
49.0%
56.3%
55.0%
57.5%
50.3%
46.8%
37.1%
44.5%
40.2%
39.1%
41.1%
40.9%
35.8%
35.4%
36.0%
48.5%
49.2%
47.4%
Low High
Figure 4.   Optimization level comparison of CoverageDHW 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:29:31 UTC from IEEE Xplore.  Restrictions apply. 
311  
In  all  but  one  case  the  CoverageDHW  is  significantly 
lower when using the high level. The average difference for 
all experiments  is 8.1%. As with the higher CoverageDHW 
for AspectC++Ext discussed in Section V.C, the differences 
are mainly due to less read and write operations on invalid 
adresses. This is not surprising since compiler optimizations 
greatly reduce the use of the memory stack.   
led 
reduced 
CoverageTotal.  Fig. 
in 
CoverageTotal for the two optimization levels. The average 
reduction of 2.4% is small but consistent in all but one case. 
Hence 
that  using  compiler 
optimizations has a negative impact on fault coverage.  
these  experiments  show 
low  CoverageDHW 
difference 
shows 
also 
The 
These were the only consistent differences that could be 
observed between using the different optimization levels. 
E.  Implementation overhead 
the 
to 
5 
When  implementing  fault  tolerance  in  software,  the 
overhead  in  terms  of  memory  consumption  and  execution 
time  depends  on  a  number  of  things.  In  these  experiments 
we  have  used  different  target  programs,  different  fault 
tolerance  mechanisms, different implementation languages, 
and  different  levels  of  compiler  optimization.  All  of  these 
variables  impact  the  overhead.  The  results  discussed  here 
only  concern  the  brake-by-wire  application. The  Fibonacci 
program  was  specifically  written  so 
final 
implementations  should  mainly  consist  of  fault  tolerance 
that 
the 
code.  Because  of  this,  the  overhead  data  for  that  program 
are unlikely to be relevant to any real-life application.  
In all different implementations, the space in bytes used 
on the onboard flash memory was measured. This is labeled 
code  in  the  tables  but  includes,  apart  from  program  code, 
also constants, and initial values to dynamic variables. The 
memory  usage  for  data  is  measured  dynamically  and 
includes data segments, stack, and heap. Execution time is 
approximated with the number of traced instructions in the 
longest path through a complete control loop. All values are 
measured without the presence of faults. Table IX shows the 
the  TTR-FR  mechanism.  The  C 
overhead  data  for 
implementation  causes  around  300%  execution 
time 
overhead  for  both  optimization  levels.  Of  this,  200%  is  a 
direct consequence of executing the loop 3 times. Hence the 
actual mechanism implementation gives additionally around 
100% overhead. As we have also shown in an earlier study 
[13] the use of AspectC++Ext causes a lot of extra overhead. 
This  was  the  reason  for  creating  the  optimizations  used  in 
AspectC++Opt.  
In accordance with the earlier study AspectC++Opt here 
produced higher overhead than C when using the low level 
of  compiler  optimization.  In  that  study,  overhead  was 
measured on a fault tolerance implementation consisting of 
both  time  redundancy  and  control  flow  checking.  There, 
AspectC++Opt had less overhead than C when using the high 
level  of  optimization.  Here,  when  applied  to  a  pure  time
0.0%
20.0%
40.0%
60.0%
80.0%
100.0%
120.0%
Brake-by-wire; TTR-FR; C
Brake-by-wire; TTR-FR; AspectC++-Ext
Brake-by-wire; TTR-FR; AspectC++-Opt
Fibonacci; TTR-FR; C
Fibonacci; TTR-FR; AspectC++-Ext
Fibonacci; TTR-FR; AspectC++-Opt
Brake-by-wire; DS-CFC; C
Brake-by-wire; DS-CFC; AspectC++-Ext
Brake-by-wire; DS-CFC; AspectC++-Opt
Fibonacci; DS-CFC; C
Fibonacci; DS-CFC; AspectC++-Ext
Fibonacci; DS-CFC; AspectC++-Opt
79.6%
96.4%
95.9%
95.5%
93.5%
96.5%
95.6%
96.4%
98.5%
98.4%
97.8%
96.8%
88.9%
88.3%
91.5%
89.3%
90.2%
88.0%
95.3%
93.4%
90.9%
91.1%
94.8%
94.3%
Low High
Figure 5.   Optimization level comparison of CoverageTotal 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:29:31 UTC from IEEE Xplore.  Restrictions apply. 
312TABLE IX.   OVERHEAD FOR THE TTR-FR MECHANISM 
VI.  RELATED WORK 
Code 
(byte) 
% 
# 
Data 
(byte) 
% 