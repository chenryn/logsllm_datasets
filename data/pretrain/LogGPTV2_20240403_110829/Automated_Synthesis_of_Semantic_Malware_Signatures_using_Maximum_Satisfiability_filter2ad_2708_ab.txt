are isomorphic to each other. In this case, there are multiple
such subgraphs; three are shown in the bottom half of Figure 1.
For instance, the red graph labeled Signature candidate (S1) is
isomorphic to the red subgraphs of G1 and G2. Similarly, the
yellow graph labeled Signature candidate (S2) is isomorphic
to the yellow subgraphs of G1 and G2. The key insight in
deciding between these candidates is to ﬁnd the maximally
suspicious common subgraph (MSCS). Intuitively, an MSCS is
the signature candidate that maximizes the number of metadata
edges, where each edge is weighted by its suspiciousness.
Continuing our example, S2 does not exhibit any “suspi-
cious” behaviors such as suspicious information ﬂows from
conﬁdential sources to public sinks. On the other hand, S1
contains multiple suspicious behaviors, such as calling the
sendSMS API and leaking conﬁdential data. Based on these
suspicious features, ASTROID decides that among the three
candidates S1-S3, the candidate S1 most likely encodes the
malicious behavior characterizing malware in the GoldDream
family.
Internally, ASTROID uses a MaxSAT solver to ﬁnd MSCSs.
Since each suspicious behavior is encoded as a soft constraint,
an optimal satisfying assignment
to the MaxSAT problem
corresponds to a maximally suspicious common subgraph of
the malware samples. Once ASTROID infers an MSCS of the
malware samples, it automatically converts this MSCS into a
signature. Hence, ASTROID allows a security auditor like Alice
to automatically detect future instances of the GoldDream
family without having to manually write malware signatures.
IV. SEMANTIC ANDROID MALWARE SIGNATURES
We now formally deﬁne our malware signatures and state
what it means for an app to match a signature. Intuitively, a
signature for a family F is an ICCG (V0, X0, Y0) that captures
semantic properties common to all malware in F. Ideally,
G0 = (V0, X0, Y0) would satisfy the following:
• G0 occurs as a subgraph (deﬁned below) of the ICCG
• G0 does not occur as subgraph of the ICCG GS =
GS = (VS, XS, YS) of every malware sample S ∈ F.
(VS, XS, YS) of any sample S (cid:54)∈ F.
By “occurs as a subgraph”, we mean there exists an embedding
FS : V0 → VS such that the following properties hold:
• One-to-one. For every v, v(cid:48) ∈ V0 where v (cid:54)= v(cid:48), FS
i.e.,
to the same vertex,
cannot map both v and v(cid:48)
FS(v) (cid:54)= FS(v(cid:48)).
• Type preserving. For every v ∈ V0, FS must map v to a
• Edge preserving. For every v, v(cid:48) ∈ V0, FS must map an
vertex of the same type, i.e., T (v) = T (FS(v))
edge (v, v(cid:48)) ∈ X0 to an edge in XS:
(v, v(cid:48)) ∈ X0 ⇒ (FS(v), FS(v(cid:48))) ∈ XS.
• Metadata preserving. For every v, v(cid:48) ∈ V0, FS must map
metadata (v, v(cid:48), d) ∈ Y0 to metadata in YS:
(v, v(cid:48), d) ∈ Y0 ⇒ (FS(v), FS(v(cid:48)), d) ∈ YS.
Example 2: Consider
the candidate signature S1 with
ICCG (V0, X0, Y0) and the GoldDream sample G1 with ICCG
(V1, X1, Y1) from Figure 1. Now, let us consider the following
candidate embeddings F (a)
from V0 to V1:
and F (b)
1
1
(cid:40)
(cid:40)
1
(receiver0) = zjReceiver
(service0) = zjService
F (a)
F (a)
1
F (b)
1 (receiver0) = zjReceiver
F (b)
1 (service0) = GameAct.
1
1
does not preserve types. Furthermore, F (b)
Here, candidate F (b)
is not a valid embedding because the
types of service0 and GameAct are not compatible, since
service0 is a service whereas GameAct is an activity.
Thus, F (b)
is also
invalid for another reason: There is an edge receiver0 →
service0 ∈ X0 in S1, but there is no corresponding edge
zjReceiver → GameAct in G1. Therefore, F (b)
also does
not preserve edges. On the other hand, F (a)
satisﬁes all the
1
properties above and is a valid embedding.
1
1
Given signature G0 = (V0, X0, Y0) and app S with ICCG
GS = (VS, XS, YS), we say that G0 exactly matches (or
simply matches) S if G0 occurs as a subgraph of GS. In
other words, given a signature (V0, X0, Y0) and a sample S
with ICCG (VS, XS, YS), we can check whether (V0, X0, Y0)
matches S. If so, we have determined that S ∈ F; otherwise,
S (cid:54)∈ F.
In general, our signature may not exactly capture the se-
mantic properties of the malware family F. As a consequence,
there may be samples S ∈ F such that (V0, X0, Y0) does not
match S (called false negatives), or samples S (cid:54)∈ F such that
(V0, X0, Y0) matches S (called false positives). In practice, a
signature should minimize both the false positive rate and the
false negative rate, even though there is a tradeoff between
optimizing these two values in practice. When detecting mal-
ware, we use approximate matching, which enables our tool to
detect partial matches; tuning the cutoff for what constitutes an
approximate match allows us to balance the tradeoff as desired.
See Section VII for details.
V. SIGNATURE INFERENCE PROBLEM
Our goal is to infer a signature from few samples of a
malware family. Suppose we are given n malware samples
from a single family F. Na¨ıvely, we can search for any
signature that matches each of the n malware samples; then,
the resulting signature would intuitively have a low false
negative rate. However, even the empty signature ﬁts this
criterion (since it can be embedded in any sample), but the
empty signature has a high false positive rate.
4
Instead, we want to maximize the amount of semantic
information contained in the signature. More precisely, we seek
to ﬁnd a signature (V0, X0, Y0) that is:
• A common subgraph:
ciousness |X0| +(cid:80)
should match
(V0, X0, Y0)
each given sample i ∈ {1, ..., n}.
Intuitively,
the
common subgraph requirement seeks to minimize false
negatives. If the inferred signature S was not a common
subgraph of all the samples, then S would not match
some samples of F, meaning that we have false negatives.
• Maximally suspicious: (V0, X0, Y0) has maximal suspi-
wy, where weight wy indicates
indicates the relative importance of metadata edge y.
Intuitively, maximal suspiciousness seeks to minimize
false positives: The less frequently a metadata edge y
appears in benign apps (i.e., the more “suspicious” y
the higher the weight associated with it. Hence,
is),
wy makes
it less likely that a benign app will match the inferred
signature. We describe how the weights wy are chosen in
Section VI-C.
maximizing the suspiciousness score (cid:80)
y∈Y0
y∈Y0
In summary, given a set of samples SF of malware
family F, we refer to the problem of computing a signature
(V0, X0, Y0) that is both maximally suspicious and a common
subgraph of all G ∈ SF as signature synthesis.
VI. SIGNATURE SYNTHESIS AS MAXSAT
As mentioned earlier, our approach reduces the signature
synthesis problem to MaxSAT [17]. Given a boolean formula
in conjunctive normal form (CNF), the MaxSAT problem is
to ﬁnd satisfying assignments to the variables in the formula
that maximizes the number of clauses that evaluate to true. For
example, given the unsatisﬁable formula
(x0 ∨ x1) ∧ (¬x0 ∨ x1) ∧ (x0 ∨ ¬x1) ∧ (¬x0 ∨ ¬x1),
the assignment {x0 (cid:55)→ 0, x1 (cid:55)→ 0} achieves the maximum of
three satisﬁed clauses.
In addition, we can specify that certain clauses must be
satisﬁed; these clauses are referred to as hard constraints and
the remaining clauses are referred to as soft constraints. We
encode the common subgraph requirement of the signature
synthesis problem using hard constraints. In contrast, since the
maximally suspicious requirement corresponds to optimizing
an objective function, we encode this requirement using soft
constraints that should be maximally satisﬁed.
A. Variables in Encoding
Before we describe how to reduce the signature synthesis
problem to MaxSAT, we introduce some terminology and
describe the propositional variables used by our encoding.
First, we denote the ICCG of a given sample i ∈ {1, ..., n}
of malware family F as (Vi, Xi, Yi). Recall that the common
subgraph criterion requires that
the signature (V0, X0, Y0)
matches each i (i.e., we can ﬁnd isomorphic embeddings
Fi : V0 → Vi). The ﬁrst difﬁculty in encoding the common
subgraph requirement is that the number of vertices |V0| in
the signature is unknown. However, for each type r ∈ T , we
know that V0 cannot contain more vertices of type r than any
5
sample (since it must be embedded in each sample). Hence,
we can give an upper bound on the number of vertices of type
r in V0:
|{v ∈ V0 | T (v) = r}| ≤ mr.
Here, mr denotes the minimum number of vertices of type r
in any sample. This observation immediately gives us an upper
bound on the total number of vertices:
|V0| ≤ m =
mr.
(cid:88)
r∈T
Our approach is to ﬁx a large set of vertices V , and then
think of V0 as an unknown subset of V in our encoding. Since
there are at most m vertices in the signature, it sufﬁces to take
V = {v1, ..., vm}. Furthermore, for each type r, we assign
type r to exactly mr of the vertices in V . Now, we can think
of each embedding Fi as a partial function Fi : V → Vi,
where we require that the domain of Fi is the same for each
sample i. Then, V0 is exactly the common domain of the Fi’s,
and we have X0 ⊆ V0 × V0 as well as Y0 ⊆ V0 × V0 × D.
Example 3: Consider the two GoldDream samples shown
in Figure 1. The ﬁrst sample has only 6 activities, 1 service,
and 1 receiver, so mactivity = 6, mservice = mreceiver = 1, and
m = mactivity + mservice + mreceiver = 8.
Therefore, we take V = {v1, ..., v8}, with 6 activities v1, ..., v6,
1 service v7, and 1 receiver v8. Note that the vertices V0 used
in the candidate signature must be a subset of V , and X0 must
be a subset of V0 × V0.
In our description of the variables in our encoding, we use
indices i, j ∈ {1, ..., n} to enumerate over the samples and
k, h ∈ {0, 1, ..., n} to enumerate over both the samples and
the signature. Also, we use the indicator function:
(cid:26)1 if C holds
0 otherwise
.
I[C] =
For readability, we use the notation x(a, b, ...) to denote
a boolean variable xa,b,... indexed over a ∈ A, b ∈ B, and
so forth. Our constraint system is deﬁned using the following
constants and free variables:
• Domain indicators. For every v ∈ V , a boolean variable
d(v) indicates whether v is in the domain of the embed-
dings Fi. These are all free variables.
• Embedding indicators. For each v ∈ V ,
fi(v, u) = I[Fi(v) = u].
In other words, fi(v, u) indicates whether the embedding
Fi maps v to u. These are all free variables.
• Type indicators. For each v ∈ Vk (or V if k = 0) and
r ∈ T , tk(v, r) indicates whether the type of v is r:
tk(v, r) = I[T (v) = r].
Since the types of all components are known, each
tk(v, r) is a boolean constant.
• Control-ﬂow indicators. For each v, u ∈ Vk (or V if
k = 0), xk(v, u) indicates whether there is an edge (v, u)
in Xk:
xk(v, u) = I[(v, u) ∈ Xk].
For k = 0, these are free variables; the remainder are
constants (since the control-ﬂow edges Xi are known).
• Metadata indicators: For every v, v(cid:48) ∈ Vk (or V if k =
0) and d ∈ D, yk(v, v(cid:48), d) indicates whether there is a
metadata (v, v(cid:48), d) ∈ Yk:
yk(v, v(cid:48), d) = I[(v, v(cid:48), d) ∈ Yk].
For k = 0, these are free variables; the remainder are
constants (since the metadata edges Yi are known).
Each assignment to the free variables corresponds to a
into the
candidate signature together with embeddings Fi
ICCG of each given sample i.
Example 4: Consider the ICCGs of samples from the
GoldDream malware family shown in Figure 1. Recall that,
given these samples, our algorithm uses V = {v1, ..., v8}. We
ﬁrst describe the constants constructed by our algorithm, and
then the free variables.
The constants include type indicators both for the samples
and for the signature, as well as control-ﬂow and metadata
indicators for the samples. For the signature, the non-zero type
indicators are
t0(v(cid:96), activity) = t0(v7, service)
= t0(v8, receiver) = 1,
for 1 ≤ (cid:96) ≤ 6, and the remaining type indicators are zero. For
the vertex zjReceiver in ﬁrst sample G1, the type indicators
are:
t1(zjReceiver, receiver) = 1
t1(zjReceiver, service)
= t1(zjReceiver, activity)
= 0
For the outgoing edges from zjReceiver, the control-
ﬂow indicators are
x1(zjReceiver, zjService)
= 1
and
x1(zjReceiver, zjReceiver)
= x1(zjReceiver, ISniper)
= x1(zjReceiver, moreGame)
= x1(zjReceiver, HighScore)
= x1(zjReceiver, Profile)
= x1(zjReceiver, UserAct)
= x1(zjReceiver, GameAct)
= 0
Assignments to the free variables correspond to candidate
signatures along embeddings F1 and F2 into the samples
G1 and G2 respectively. For example, consider the candidate
signature S1, along with the candidate embedding F (a)
into
G1 described in Example 2, and the candidate embedding
1
(cid:40)
2
F (a)
F (a)
2
(receiver0) = MyReceiver
(service0) = BoolService
6
into G2. Then,
represented as V0 =
{service0, receiver0}, so the assignments to the domain