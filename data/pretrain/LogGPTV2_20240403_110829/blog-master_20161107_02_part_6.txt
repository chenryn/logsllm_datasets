digoal 49250 49230 23 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50024)                                                          
digoal 49251 49230 23 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50025)                                                          
digoal 49252 49230 23 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50026)                                                          
digoal 49253 49230 23 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50027)                                                          
digoal 49254 49230 23 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50028)                                                          
digoal 49255 49230 22 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50029)                                                          
digoal 49256 49230 22 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50030)                                                          
digoal 49257 49230 21 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50031)                                                          
digoal 49258 49230 23 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50032)                                                          
digoal 49259 49230 24 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50033)                                                          
digoal 49260 49230 23 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50034)                                                          
digoal 49261 49230 23 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50035)                                                          
digoal 49262 49230 23 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50036)                                                          
digoal 49263 49230 23 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50037)                                                          
digoal 49264 49230 23 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50038)                                                          
digoal 49265 49230 23 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50039)                                                          
digoal 49266 49230 23 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50040)                                                          
digoal 49267 49230 21 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50041)                                                          
digoal 49268 49230 23 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50042)                                                          
digoal 49269 49230 21 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50043)                                                          
digoal 49270 49230 23 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50044)                                                          
digoal 49271 49230 23 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50045)                                                          
digoal 49272 49230 22 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50046)                                                          
digoal 49273 49230 23 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50047)                                                          
digoal 49274 49230 22 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50048)                                                          
digoal 49275 49230 23 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50049)                                                          
digoal 49276 49230 22 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50050)                                                          
digoal 49277 49230 23 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50051)                                                          
digoal 49278 49230 22 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50052)                                                          
digoal 49279 49230 21 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50053)                                                          
digoal 49280 49230 22 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50054)                                                          
digoal 49281 49230 21 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50055)                                                          
digoal 49282 49230 23 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50056)                                                          
digoal 49283 49230 23 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50057)                                                          
digoal 49284 49230 23 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50058)                                                          
digoal 49285 49230 23 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50059)                                                          
digoal 49286 49230 23 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50060)                                                          
digoal 49287 49230 23 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50061)                                                          
digoal 49288 49230 23 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50062)                                                          
digoal 49289 49230 23 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50063)                                                          
digoal 49290 49230 23 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50064)                                                          
digoal 49291 49230 21 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50065)                                                          
digoal 49292 49230 23 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50066)                                                          
digoal 49293 49230 21 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50067)                                                          
digoal 49294 49230 22 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50068)                                                          
digoal 49295 49230 23 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50069)                                                          
digoal 49296 49230 22 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50070)                                                          
digoal 49297 49230 23 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50071)                                                          
digoal 49298 49230 23 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50072)                                                          
digoal 49299 49230 23 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50073)                                                          
digoal 49300 49230 22 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50074)                                                          
digoal 49301 49230 23 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50075)                                                          
digoal 49302 49230 22 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50076)                                                          
digoal 49303 49230 23 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50077)                                                          
digoal 49304 49230 22 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50078)                                                          
digoal 49305 49230 23 16:13 ?        00:00:00 postgres: postgres postgres xxx.xxx.xxx.182(50079)  
```
```
pg_ctl stop -m fast
```
```
进入同步流复制的wal sender进程目录
cd $PGDATA/gprof/49239
gprof -b /home/digoal/pgsql9.6/bin/postgres ./gmon.out |less
Flat profile:
Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total           
 time   seconds   seconds    calls   s/call   s/call  name    
 71.65      7.96     7.96                             WalSndLastCycleHandler
  4.14      8.42     0.46  8551565     0.00     0.00  SetLatch
  1.35      8.57     0.15  1469690     0.00     0.00  SyncRepWakeQueue
  1.08      8.69     0.12   947868     0.00     0.00  SyncRepReleaseWaiters
  0.99      8.80     0.11  3165081     0.00     0.00  AddWaitEventToSet
  0.90      8.90     0.10        1     0.10     2.66  WalSndLoop
  0.72      8.98     0.08  7468536     0.00     0.00  appendBinaryStringInfo
  0.63      9.05     0.07  8551570     0.00     0.00  SHMQueueDelete
  0.63      9.12     0.07  1055029     0.00     0.00  WaitEventSetWait
  0.63      9.19     0.07                             palloc_extended
  0.63      9.26     0.07   947870     0.00     0.00  pq_getmessage
  0.63      9.33     0.07   933557     0.00     0.00  XLogRead
  0.54      9.39     0.06  1895626     0.00     0.00  elog_start
  0.54      9.45     0.06  1055155     0.00     0.00  ResetLatch
  0.54      9.51     0.06  1055154     0.00     0.00  ProcessRepliesIfAny
  0.54      9.57     0.06  1055026     0.00     0.00  WaitLatchOrSocket
  0.54      9.63     0.06  1054913     0.00     0.00  GetFlushRecPtr
  0.54      9.69     0.06   396610     0.00     0.00  LWLockWakeup
  0.45      9.74     0.05  7582944     0.00     0.00  pq_copymsgbytes
  0.45      9.79     0.05  1055034     0.00     0.00  MemoryContextAllocZero
  0.45      9.84     0.05  1055026     0.00     0.00  FreeWaitEventSet
  0.45      9.89     0.05  1054911     0.00     0.00  XLogSendPhysical
  0.45      9.94     0.05  1008169     0.00     0.00  LWLockAttemptLock
  0.45      9.99     0.05                             ProcessInterrupts
  .......略...........
                        Call graph
granularity: each sample hit covers 2 byte(s) for 0.09% of 11.11 seconds
index % time    self  children    called     name
[1]     71.6    7.96    0.00                 WalSndLastCycleHandler [1]
                0.00    0.00       1/8551565     SetLatch [16]
-----------------------------------------------
[2]     24.6    0.00    2.74                 main [2]
                0.00    2.74       1/1           PostmasterMain [3]
                0.00    0.00       1/1           MemoryContextInit [363]
                0.00    0.00       6/6           init_locale [539]
                0.00    0.00       1/1           get_progname [964]
                0.00    0.00       1/1           save_ps_display_args [1001]
                0.00    0.00       1/1           startup_hacks [1012]
                0.00    0.00       1/1           set_pglocale_pgservice [1003]
                0.00    0.00       1/1           check_strxfrm_bug [955]
                0.00    0.00       1/1           check_root [953]
-----------------------------------------------
.....................略
-----------------------------------------------
                0.12    0.98  947868/947868      ProcessStandbyReplyMessage [13]
[14]     9.9    0.12    0.98  947868         SyncRepReleaseWaiters [14]
                0.15    0.53 1469690/1469690     SyncRepWakeQueue [15]
                0.02    0.09  947744/947817      LWLockRelease [22]
                0.02    0.06  947744/947817      LWLockAcquire [27]
                0.01    0.03  947744/947744      SyncRepGetOldestSyncRecPtr [47]
                0.01    0.02  947744/1895626     elog_finish [32]
                0.03    0.00  947744/1895626     elog_start [34]
                0.00    0.01       1/4           errfinish [56]
                0.00    0.00       1/4           errmsg [131]
                0.00    0.00       1/1895685     errstart [46]
-----------------------------------------------
                0.15    0.53 1469690/1469690     SyncRepReleaseWaiters [14]
[15]     6.1    0.15    0.53 1469690         SyncRepWakeQueue [15]
                0.46    0.00 8551561/8551565     SetLatch [16]
                0.07    0.00 8551561/8551570     SHMQueueDelete [29]
                0.00    0.00 10021251/10021300     SHMQueueNext [405]
-----------------------------------------------
                0.00    0.00       1/8551565     WalSndLastCycleHandler [1]
                0.00    0.00       1/8551565     SwitchToSharedLatch [309]
                0.00    0.00       1/8551565     SwitchBackToLocalLatch [308]
                0.00    0.00       1/8551565     handle_sig_alarm [319]
                0.46    0.00 8551561/8551565     SyncRepWakeQueue [15]
[16]     4.1    0.46    0.00 8551565         SetLatch [16]
                0.00    0.00       1/284359      sendSelfPipeByte [415]
-----------------------------------------------
                0.00    0.00       1/1054911     WalSndKeepaliveIfNecessary [224]
                0.05    0.37 1054910/1054911     WalSndLoop [10]
[17]     3.8    0.05    0.37 1054911         XLogSendPhysical [17]
                0.02    0.11 3734228/3734228     pq_sendint64 [20]
                0.07    0.02  933557/933557      XLogRead [25]
                0.06    0.00 1054911/1054913     GetFlushRecPtr [36]
                0.03    0.03  933557/933557      socket_putmessage_noblock [37]
                0.02    0.00 1867114/3762896     resetStringInfo [51]
                0.01    0.00  933557/933560      pq_sendbyte [100]
                0.00    0.00  933557/9349963     enlargeStringInfo [48]
                0.00    0.00  933557/2320270     GetCurrentTimestamp [408]
                0.00    0.00     641/18658       s_lock [423]
.............略
-----------------------------------------------
                0.00    0.00       1/1           ProcKill [64]
[308]    0.0    0.00    0.00       1         SwitchBackToLocalLatch [308]
                0.00    0.00       1/8551565     SetLatch [16]
                0.00    0.00       1/5           ModifyWaitEvent [347]
-----------------------------------------------
                0.00    0.00       1/1           InitProcess [94]
[309]    0.0    0.00    0.00       1         SwitchToSharedLatch [309]
                0.00    0.00       1/8551565     SetLatch [16]
                0.00    0.00       1/5           ModifyWaitEvent [347]
-----------------------------------------------
.............略
-----------------------------------------------
[319]    0.0    0.00    0.00                 handle_sig_alarm [319]
                0.00    0.00       1/8551565     SetLatch [16]
............略
```
## release waiting session锁相关代码
1\. SetLatch    
```
/*-------------------------------------------------------------------------
 *
 * latch.c
 *        Routines for inter-process latches
 *
 * The Unix implementation uses the so-called self-pipe trick to overcome
 * the race condition involved with select() and setting a global flag
 * in the signal handler. When a latch is set and the current process
 * is waiting for it, the signal handler wakes up the select() in
 * WaitLatch by writing a byte to a pipe. A signal by itself doesn't
 * interrupt select() on all platforms, and even on platforms where it
 * does, a signal that arrives just before the select() call does not
 * prevent the select() from entering sleep. An incoming byte on a pipe
 * however reliably interrupts the sleep, and causes select() to return
 * immediately even if the signal arrives before select() begins.
 *
 * (Actually, we prefer epoll_wait() over poll() over select() where
 * available, but the same comments apply.)
 *
 * When SetLatch is called from the same process that owns the latch,
 * SetLatch writes the byte directly to the pipe. If it's owned by another
 * process, SIGUSR1 is sent and the signal handler in the waiting process
 * writes the byte to the pipe on behalf of the signaling process.
 *
 * The Windows implementation uses Windows events that are inherited by
 * all postmaster child processes.
 *
 * Portions Copyright (c) 1996-2016, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *        src/backend/storage/ipc/latch.c
 *
 *-------------------------------------------------------------------------
 */
...
/*
 * Sets a latch and wakes up anyone waiting on it.
 *
 * This is cheap if the latch is already set, otherwise not so much.
 *
 * NB: when calling this in a signal handler, be sure to save and restore
 * errno around it.  (That's standard practice in most signal handlers, of
 * course, but we used to omit it in handlers that only set a flag.)
 *
 * NB: this function is called from critical sections and signal handlers so
 * throwing an error is not a good idea.
 */
void
SetLatch(volatile Latch *latch)
{
#ifndef WIN32
        pid_t           owner_pid;
#else
        HANDLE          handle;
#endif
        /*
         * The memory barrier has to be placed here to ensure that any flag
         * variables possibly changed by this process have been flushed to main
         * memory, before we check/set is_set.
         */
        pg_memory_barrier();
        /* Quick exit if already set */
        if (latch->is_set)
                return;
        latch->is_set = true;
#ifndef WIN32
        /*
         * See if anyone's waiting for the latch. It can be the current process if
         * we're in a signal handler. We use the self-pipe to wake up the select()
         * in that case. If it's another process, send a signal.
         *
         * Fetch owner_pid only once, in case the latch is concurrently getting
         * owned or disowned. XXX: This assumes that pid_t is atomic, which isn't
         * guaranteed to be true! In practice, the effective range of pid_t fits
         * in a 32 bit integer, and so should be atomic. In the worst case, we
         * might end up signaling the wrong process. Even then, you're very
         * unlucky if a process with that bogus pid exists and belongs to
         * Postgres; and PG database processes should handle excess SIGUSR1
         * interrupts without a problem anyhow.
         *
         * Another sort of race condition that's possible here is for a new
         * process to own the latch immediately after we look, so we don't signal
         * it. This is okay so long as all callers of ResetLatch/WaitLatch follow
         * the standard coding convention of waiting at the bottom of their loops,
         * not the top, so that they'll correctly process latch-setting events