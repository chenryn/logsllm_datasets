### References

1. **James C. Corbett, Jeffrey Dean, Michael Epstein, Andrew Fikes, Christopher Frost, J. J. Furman, Sanjay Ghemawat, Andrey Gubarev, Christopher Heiser, Peter Hochschild, Wilson Hsieh, Sebastian Kanthak, Eugene Kogan, Hongyi Li, Alexander Lloyd, Sergey Melnik, David Mwaura, David Nagle, Sean Quinlan, Rajesh Rao, Lindsay Rolig, Yasushi Saito, Michal Szymaniak, Christopher Taylor, Ruth Wang, and Dale Woodford.** Spanner: Google’s globally distributed database. *ACM Trans. Comput. Syst.*, August 2013.

2. **Lisa Glendenning, Ivan Beschastnikh, Arvind Krishnamurthy, and Thomas Anderson.** Scalable consistency in scatter. In *Proceedings of the Twenty-Third ACM Symposium on Operating Systems Principles (SOSP '11)*, pages 15–28, New York, NY, USA, 2011. ACM.

3. **Jason Baker, Chris Bond, James C. Corbett, JJ Furman, Andrey Khorlin, James Larson, Jean-Michel Leon, Yawei Li, Alexander Lloyd, and Vadim Yushprakh.** Megastore: Providing scalable, highly available storage for interactive services. In *Proceedings of the Conference on Innovative Data System Research (CIDR)*, pages 223–234, 2011.

4. **Intel.** Intel distributed ledger. http://intelledger.github.io/, 2016.

5. **Chain Inc.** Chain open standard: A secure blockchain protocol for high-scale financial networks. http://chain.com/os/, 2016.

6. **Rhett Creighton.** Domus tower blockchain. http://domustower.com/domus-tower-blockchain-latest.pdf, 2016.

7. **David Mazieres.** The stellar consensus protocol: A federated model for internet-level consensus. April 2015.

8. **Arthur Britto, David Schwartz, Noah Youngs.** The ripple protocol consensus algorithm. Ripple Labs Inc., 2014.

9. **Bitcoin client.** https://github.com/bitcoin/bitcoin.

10. **Rachid Guerraoui, Florian Huc, and Anne-Marie Kermarrec.** Highly dynamic distributed computing with Byzantine failures. In *Proceedings of the 2013 ACM Symposium on Principles of Distributed Computing (PODC '13)*, 2013.

11. **Gopal Pandurangan, Peter Robinson, and Amitabh Trehan.** Self-healing deterministic expanders. *CoRR*, abs/1206.1522, 2012.

12. **John R. Douceur.** The sybil attack. In *Proceedings of the 1st International Workshop on Peer-to-Peer Systems (IPTPS)*, 2002.

13. **James Newsome, Elaine Shi, Dawn Song, and Adrian Perrig.** The sybil attack in sensor networks: Analysis & defenses. In *Proceedings of the 3rd International Symposium on Information Processing in Sensor Networks (IPSN '04)*, pages 259–268, New York, NY, USA, 2004. ACM.

14. **Baruch Awerbuch and Christian Scheideler.** Robust random number generation for peer-to-peer systems. *Theor. Comput. Sci.*, 410(6-7):453–466, February 2009.

15. **Bitcoin wiki.** Proof of stake. https://en.bitcoin.it/wiki/Proof_of_Stake, 2015.

16. **Stefan Dziembowski, Sebastian Faust, Vladimir Kolmogorov, and Krzysztof Pietrzak.** Proofs of space. *Cryptology ePrint Archive*, Report 2013/796, 2013. http://eprint.iacr.org/.

17. **Giuseppe Ateniese, Ilario Bonacina, Antonio Faonio, and Nicola Galesi.** Proofs of space: When space is of the essence. *Cryptology ePrint Archive*, Report 2013/805, 2013. http://eprint.iacr.org/.

18. **Nancy Lynch.** *Distributed Algorithms*. Morgan Kaufmann, 1996.

19. **Seth Gilbert, Calvin Newport, and Chaodong Zheng.** Who are you? Secure identities in ad hoc networks. In *Distributed Computing*, pages 227–242. Springer, 2014.

20. **Marcin Andrychowicz and Stefan Dziembowski.** Distributed cryptography based on the proofs of work. *Cryptology ePrint Archive*, Report 2014/796, 2014. http://eprint.iacr.org/2014/796.

21. **Juan Garay, Aggelos Kiayias, and Nikos Leonardos.** The bitcoin backbone protocol: Analysis and applications. *Cryptology ePrint Archive*, Report 2014/765, 2014. http://eprint.iacr.org/.

22. **Jae Kwon.** Tendermint: Consensus without mining.

23. **IBM.** IBM blockchain. http://www.ibm.com/blockchain/, 2016.

24. **Digital Asset Holdings.** Digital asset. https://digitalasset.com/, 2016.

25. **Ethereum Foundation.** Ethereum’s white paper. https://github.com/ethereum/wiki/wiki/White-Paper, 2014.

26. **George Danezis and Sarah Meiklejohn.** Centrally banked cryptocurrencies. *Cryptology ePrint Archive*, Report 2015/502, 2015. http://eprint.iacr.org/.

27. **Yonatan Sompolinsky and Aviv Zohar.** Accelerating bitcoin’s transaction processing. Fast money grows on trees, not chains. *Cryptology ePrint Archive*, Report 2013/881, 2013. http://eprint.iacr.org/.

28. **Loi Luu, Jason Teutsch, Raghav Kulkarni, and Prateek Saxena.** Demystifying incentives in the consensus computer. *Cryptology ePrint Archive*, Report 2015/702, 2015. http://eprint.iacr.org/.

29. **Thaddeus Dryja and Joseph Poon.** The bitcoin lightning network: Scalable off-chain instant payments. http://lightning.network/lightning-network-paper.pdf, 2015.

30. **Adam Back, Matt Corallo, Luke Dashjr, Mark Friedenbach, Gregory Maxwell, Andrew Miller, Andrew Poelstra, Jorge Timon, and Pieter Wuille.** Enabling blockchain innovations with pegged sidechains. https://blockstream.com/sidechains.pdf, 2014.

31. **Pieter Wuille.** Would sidechains help bitcoin scale? 2015.

32. **Vitalik Buterin, Gavin Wood, Vlad Zamfir, Jeff Coleman, Matthew Wampler-Doty, and John Cohn.** Notes on scalable blockchain protocols (version 0.3.2). https://github.com/vbuterin/scalability_paper/raw/master/scalability.pdf, 2015.

33. **Gabriel Bracha.** An O(log n) expected rounds randomized Byzantine generals protocol. *J. ACM*, 34:910–920, October 1987.

34. **Seth Gilbert and Dariusz R. Kowalski.** Distributed agreement with optimal communication complexity. In *Proceedings of the Twenty-first Annual ACM-SIAM Symposium on Discrete Algorithms*, pages 965–977. Society for Industrial and Applied Mathematics, 2010.

35. **Leslie Lamport.** Fast Paxos. *Distributed Computing*, 19(2):79–103, October 2006.

36. **Allen Clement, Edmund Wong, Lorenzo Alvisi, Mike Dahlin, and Mirco Marchetti.** Making Byzantine fault tolerant systems tolerate Byzantine faults. In *Proceedings of the 6th USENIX Symposium on Networked Systems Design and Implementation*, pages 153–168. USENIX Association, 2009.

37. **Ramakrishna Kotla, Lorenzo Alvisi, Mike Dahlin, Allen Clement, and Edmund Wong.** Zyzzyva: Speculative Byzantine fault tolerance. *ACM Trans. Comput. Syst.*, 27(4):7:1–7:39, January 2010.

38. **Pierre-Louis Aublin, Rachid Guerraoui, Nikola Knežević, Vivien Quéma, and Marko Vukolić.** The next 700 BFT protocols. *ACM Trans. Comput. Syst.*, 32(4):12:1–12:45, January 2015.

39. **V. King, J. Saia, V. Sanwalani, and E. Vee.** Towards secure and scalable computation in peer-to-peer networks. In *Foundations of Computer Science, 2006. FOCS '06. 47th Annual IEEE Symposium on*, pages 87–98, 2006.

40. **Valerie King and Jared Saia.** From almost everywhere to everywhere: Byzantine agreement with \(\tilde{O}(n^{3/2})\) bits. In *Proceedings of the 23rd International Conference on Distributed Computing*, pages 464–478. Springer-Verlag, 2009.

41. **Valerie King, Steven Lonargan, Jared Saia, and Amitabh Trehan.** Load balanced scalable Byzantine agreement through quorum building, with full information. In *Distributed Computing and Networking, volume 6522 of Lecture Notes in Computer Science*, pages 203–214. Springer Berlin Heidelberg, 2011.

42. **Nicolas Braud-Santoni, Rachid Guerraoui, and Florian Huc.** Fast Byzantine agreement. In *Proceedings of the 2013 ACM Symposium on Principles of Distributed Computing*, pages 57–64. ACM, 2013.

43. **U. Feige.** Noncryptographic selection protocols. In *Foundations of Computer Science, 1999. 40th Annual Symposium on*, pages 142–152, 1999.

44. **Valerie King and Jared Saia.** Breaking the \(O(n^2)\) bit barrier: Scalable Byzantine agreement with an adaptive adversary. *J. ACM*, 58:18:1–18:24, July 2011.

45. **Jonathan Katz, Andrew Miller, and Elaine Shi.** Pseudonymous broadcast and secure computation from cryptographic puzzles. *Cryptology ePrint Archive*, Report 2014/857, 2014. http://eprint.iacr.org/2014/857.

46. **Christian Decker, Jochen Seidel, and Roger Wattenhofer.** Bitcoin meets strong consistency. In *Proceedings of the 17th International Conference on Distributed Computing and Networking (ICDCN '16)*, pages 13:1–13:10, New York, NY, USA, 2016. ACM.

47. **James Aspnes, Collin Jackson, and Arvind Krishnamurthy.** Exposing computationally-challenged Byzantine impostors. Department of Computer Science, Yale University, New Haven, CT, Tech. Rep, 2005.

48. **Wikipedia.** Coupon collector's problem. https://en.wikipedia.org/wiki/Coupon_collector%27s_problem.

49. **Donald J. Newman.** The double dixie cup problem. *The American Mathematical Monthly*, 67(1):58–61, 1960.

50. **Christina Garman, Matthew Green, and Ian Miers.** Decentralized anonymous credentials. *Cryptology ePrint Archive*, Report 2013/622, 2013. http://eprint.iacr.org/.

51. **Seth Gilbert and Nancy Lynch.** Brewer's conjecture and the feasibility of consistent, available, partition-tolerant web services. *SIGACT News*, 33(2):51–59, June 2002.

52. **Seth Gilbert and Nancy Lynch.** Perspectives on the CAP theorem. *Computer*, 45(2):30–36, February 2012.

### Appendix

#### 10.1 The Scalability of ELASTICO

We now explain why ELASTICO achieves the desired asymptotic \(O\left(\frac{n}{\log \log n}\right)\) scalability by calculating the expected number of Proof-of-Work (PoW) solutions that \(n\) processors have to generate such that each of \(2s\) committees has \(c\) members. This problem is equivalent to the extended coupon collector problem [62], where there are \(2s\) types of coupons in some urn, and we want to calculate the number of draws to collect \(c\) copies of each coupon. It is shown in [63] that the expected number of PoW solutions \(E\) is:

\[ E = 2s \log 2s + (c - 1)2s \log \log 2s + O(2s) \]
\[ = \frac{s \cdot n}{c} + n \log s - \frac{n}{c} \log s + O\left(\frac{n}{c}\right) \]

If \(c \geq s\), we have:

\[ \frac{s \cdot n}{c} \approx 24 \cdot \ln(2s) \]

This gives us the desired scalability.

**Lemma 8 (Balls to Bins):** We throw balls uniformly at random into a collection of \(X\) bins. When \(c > 24 \cdot \ln X\), the expected number of balls to ensure each bin has at least \(c\) balls is \(O(cX)\).

**Proof:** Consider throwing \(cX\) balls uniformly at random into \(X\) bins. The expected number of balls in each bin is \(c\). Let \(x_i\) be a random variable that equals 1 if ball \(i\) lands in a particular bin, and 0 otherwise. Let \(C = \sum x_i\). Notice that the expected value \(E(C) = c\), and all \(x_i\) are independent. Using the Chernoff bound, we have:

\[ \Pr\left[C < \frac{c}{2}\right] \leq \exp\left(-\frac{c}{8}\right) \]

For \(c > 24 \cdot \ln X\), we get:

\[ \Pr\left[C < \frac{c}{2}\right] \leq \frac{1}{X^3} \]

Considering all \(X\) bins, taking a union bound, the probability that any bin has less than \(\frac{c}{2}\) balls is at most \(\frac{1}{X^2}\). This means that with probability \(\frac{1}{X^2}\), we need to throw \(cX\) more balls. Repeating this calculation, the expected number of balls we have to throw to ensure each bin has at least \(\frac{c}{2}\) balls is:

\[ cX + \frac{cX}{X^2} + \frac{cX}{X^4} + \frac{cX}{X^6} + \ldots \leq 2cX \]

Thus, the number of balls to throw to ensure each bin has at least \(c\) balls is \(O(cX)\).

#### 10.2 Verification Checks in ELASTICO

Different blockchain applications may require different verification checks on transactions (e.g., [64]). In the presence of sharding, supporting arbitrary checks within local committees is not possible, as is well-known in sharded databases [65, 66]. In a cryptocurrency, the most important checks are ensuring that the payer signs the coin transfer and that the transaction is not double-spending. We next discuss how one can efficiently implement such verification checks for transactions in a hypothetical cryptocurrency built on top of ELASTICO.

In Bitcoin and popular cryptocurrencies, a regular transaction sends some amount of coins from a sender to a recipient. Each transaction has two parts: an Input and an Output. The Input specifies the source of the coin and a proof (by digital signatures) showing the sender is a valid coin owner. The Output names the recipient; later, the recipient can use this Output as the source of the coin in a new transaction. Checking if a transaction is double-spending entails checking if it uses some coin that has been spent in a previous transaction. A naive implementation of such a check would require scanning the entire history of the blockchain. In Bitcoin, to avoid such costs, each node maintains a local database containing all "unspent transaction outputs" (UTXOs) to check if an Output has been spent or not. Bitcoin nodes frequently update the UTXO database after each new block based on the set of transactions included in the block. Thus, if a transaction is finalized in the Bitcoin blockchain, it is guaranteed to be valid.

In ELASTICO, our transaction verification is similar: nodes also maintain a local database of UTXOs and update this database after each epoch when they download data blocks from committees. To avoid the scenario where two committees process the same transaction, each committee in ELASTICO processes a separate list of transactions with specific ranges of Inputs. For example, if there are 4 committees, they will handle transactions with Inputs' IDs (i.e., the hashes of the Inputs) with different prefixes of 00, 01, 10, and 11, respectively. As a result, within an epoch, all shards will include disjoint transaction inputs (thus disjoint transaction sets).

The verification in ELASTICO is superior to other solutions like GHOST [40] and Bitcoin-NG [9] in several aspects. First, ELASTICO nodes do not need to verify data blocks from other committees. Instead, they only need to check if a block is committed in the consensus block (from the final committee) to decide if the block is valid. This is because the committee corresponding to that shard already verifies its block, and the final committee has verified if a block is agreed upon by a committee before committing the block to the final (consensus) block. On the other hand, in other solutions, nodes have to verify all transactions included in the blockchain, thus higher throughput will require more local computation from nodes. Further, increasing the amount of verification check will slow down the block broadcast, and further pose a security threat in the consensus protocol as pointed out by previous work [41].

Thus, ELASTICO scales up the throughput as the network allows, without requiring more local computation for verification at each node or affecting the consensus security. Note that ELASTICO still permits bandwidth efficiency in its consensus step for a cryptocurrency application but has to broadcast all the data blocks to all nodes (as done in all solutions today). However, in applications where the consistency checks can themselves be sharded and checked locally, there would be no need to broadcast the data blocks to the network.