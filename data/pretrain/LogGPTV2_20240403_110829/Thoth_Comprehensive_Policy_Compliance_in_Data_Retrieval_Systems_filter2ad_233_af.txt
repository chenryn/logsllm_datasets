USENIX Association  
25th USENIX Security Symposium  651
Systems (EuroSys), 2015.
[41] Kevin Walsh and Fred B. Schneider. Costs of se-
curity in the PFS ﬁle system. Technical report,
Computing and Information Science, Cornell Uni-
versity, 2012.
[42] Wikimedia Foundation.
Image Dump. http://
archive.org/details/wikimedia-
image-dump-2005-11.
[43] Wikimedia Foundation.
Static HTML dump.
http://dumps.wikimedia.org/.
[44] Wikipedia.
Data breach: Major
incidents.
http://en.wikipedia.org/wiki/Data_
breach#Major_incidents.
[45] Edward Wobber, Martín Abadi, Michael Burrows,
and Butler Lampson. Authentication in the Taos
operating system. ACM Transactions on Computer
Systems (TOCS), 12(1), 1994.
[46] Alexander Yip, Xi Wang, Nickolai Zeldovich, and
Improving application secu-
M Frans Kaashoek.
rity with data ﬂow assertions.
In Proceedings of
the ACM SIGOPS 22nd Symposium on Operating
Systems Principles (SOSP), 2009.
[47] Nickolai Zeldovich, Silas Boyd-Wickizer, Eddie
Kohler, and David Mazières. Making information
ﬂow explicit in HiStar. In Proceedings of the 7th
USENIX Symposium on Operating Systems Design
and Implementation (OSDI), 2006.
[48] Qing Zhang, John McCullough, Justin Ma, Nabil
Schear, Michael Vrable, Amin Vahdat, Alex C.
Snoeren, Geoffrey M. Voelker, and Stefan Sav-
age. Neon: System support for derived data man-
agement.
In Proceedings of the 6th ACM SIG-
PLAN/SIGOPS International Conference on Vir-
tual Execution Environments (VEE), 2010.
A Thoth policies for data ﬂows in a search
engine
In this Appendix we provide details of the policies used
in our Thoth-compliant search engine. All policies are
represented in the read, update and declassify rules on
source conduits (documents that the search engine in-
dexes, the user proﬁle, etc.). We describe these rules in-
crementally: We start from a set of base rules, which we
reﬁne to include more policies.
Base rules Our base rules allow anyone to read, update
or destroy the source conduit they are attached to.
read :- T RU E
update :- T RU E
destroy :- T RU E
declassify :- isAsRestrictive(read,
until FALSE
this
.read)
The read, update and destroy rules have condition
T RU E, which always holds, so these rules do not re-
strict access at all. The declassify rule insists that the
read rule on any conduit containing data derived from
the source conduit be at least as restrictive as the read
rule above, which will always be the case (because the
read rule above is the most permissive read rule possi-
ble). This base policy is pointless in itself, but it serves
as the starting point for the remaining policies.
A.1 Client policies
First, we describe policies to represent client privacy
preferences.
Private data policy A user Alice may wish that her
private ﬁles (e.g., her e-mails) be accessible only to her.
This can be enforced by requiring that accesses to Alice’s
private ﬁles happen in the context of a session authenti-
cated with Alice’s key. Technically, this is accomplished
by replacing the conditions in the base read, update and
destroy rules as shown below and attaching the result-
ing rules to Alice’s private ﬁles. The predicate sKeyIs(k)
means that the current session is authenticated using the
public key k.
read :- sKeyIs(kAlice)
update :- sKeyIs(kAlice)
destroy :- sKeyIs(kAlice)
The declassify rule remains unchanged. It ensures that
any conduit containing data derived from Alice’s private
ﬁles is subject to a read rule that is at least as restrictive
as the revised read rule above. Hence, no such conduit
can be read by anyone other than Alice.
Friends only policy Alice might want that her blog
and online social network proﬁle be readable by her
friends. To do this, she could add a disjunctive (“or”-
separated) clause in the read rule requiring that read ac-
cesses happen in the context of a session authenticated
with a key kX of one of Alice’s friends. Alice’s friends
are assumed to be listed in the ﬁle Alice.acl, which con-
tains an entry of the form isFriend(kX , XACL) for each
public key kX that belongs to a friend of Alice. The
isFriend entry also states the ﬁle XACL which lists the
friends of the key kX ’s owner. Note that the isFriend en-
try format presented in the paper was slightly simpliﬁed
for readability.
read :- sKeyIs(kAlice) ∨
[sKeyIs(kX ) ∧ (“Alice.acl”, off ) says isFriend(kX , XACL)]
The
predicate
says
isFriend(kX , XACL)) checks that kX exists in the list
of Alice’s friends (ﬁle “Alice.acl”) at some offset off.
((‘Alice.acl”, off)
Friends of friends policy To additionally allow read
access to friends of friends, the policy would require read
accesses to happen in the context of an authenticated ses-
sion whose key is present in the friend list of any of Al-
ice’s friends.
652  25th USENIX Security Symposium 
USENIX Association
read :- sKeyIs(kAlice) ∨
[sKeyIs(kX ) ∧ (“Alice.acl”, off ) says isFriend(kX , XACL)]
∨
[sKeyIs(kY ) ∧ (“Alice.acl”, off1) says isFriend(kX , XACL)
∧ (XACL, off2) says isFriend(kY ,YACL)]
The
predicate
((‘Alice.acl”, off1)
says
isFriend(kX , XACL)) checks that kX exists in the list
of Alice’s friends (ﬁle “Alice.acl”) at some offset
It also binds the variable XACL to the friend
off1.
list of
the key kX ’s owner.
the predicate
((XACL , off2) says isFriend(kY ,YACL)) checks that
the
public key that authenticated the session kY exists in the
list of friends for the kX ’s owner at some offset off2.
Next,
A.2 Provider policies
Next, we describe two policies that a provider may wish
to impose, possibly to comply with legal requirements.
Mandatory Access Logging (MAL) The MAL policy
allows an authorized employee of the provider read ac-
cess to a source conduit F if the access is logged. The
log entry must have been previously written to the ﬁle
k.log, where k is the public key of the employee. The
log entry must mention the employee’s key, the ID of the
accessed conduit and the time at which the conduit is ac-
cessed with a tolerance of 60 seconds. To enforce these
requirements, a new disjunctive condition is added to the
last read rule above. The . . . in the rule below abbreviate
the conditions of the last read rule above.
read :- . . . ∨
sKeyIs(k) ∧ cIdIs(F) ∧
(“auth_employees”, off) says isEmployee(k) ∧
(LOGk = concat(k, “.log”)) ∧
(LOGk , off1) says readLog(k, F, T ) ∧ timeIs(curT ) ∧
gt(curT , T ) ∧ sub(di f f , curT , T ) ∧ lt(di f f , 60)
Next,
to F.
source conduit
The predicate sKeyIs(k) binds the public key that
the public key of
authenticated the session (i.e.,
the employee) to the variable k, and cIdIs(F) binds
the name of
the
predicate ((“auth_employees”, off) says isEmployee(k))
checks that k exists in the list of authorized employ-
ees (ﬁle “auth_employees”) at some offset off, to ver-
ify that the source conduit’s reader is really an em-
ployee. Next, LOGk is bound to the name of the em-
ployee’s log ﬁle, k.log. The predicate ((LOGk , off1) says
readLog(k, F, T )) checks that the log ﬁle contains an ap-
propriate entry with some time stamp T and the remain-
ing predicates check that the current time, curT , satisﬁes
T ≤ curT ≤ T + 60s.
Every log ﬁle has a read rule that allows only autho-
rized auditors to read the ﬁle (the public keys of all au-
thorized auditors are assumed to be listed in the ﬁle “au-
ditors”). It also has an update rule that allows appends
only, thus ensuring that a log entry cannot be removed or
overwritten.
read :- sKeyIs(k) ∧ (“auditors”, off ) says isAuditor(k)
update :- sKeyIs(k) ∧
(“auth_employees”, off ) says isEmployee(k) ∧
cCurrLenIs(cLen) ∧ cNewLenIs(nLen) ∧
gt(nLen, cLen) ∧ (this, 0, cLen) hasHash (h) ∧
(this, 0, cLen) willHaveHash (h)
In the append-only policy (rule update above), the
predicate cCurrLenIs(cLen) binds the current length of
the log ﬁle to cLen and the predicate cNewLenIs(nLen)
binds the new length of the log ﬁle to nLen. Next, the
predicate gt(nLen, cLen) ensures that the update only
(c, off, len) hasHash
increases the log ﬁle’s length.
(or willHaveHash) is a special mode of using says (or
willsay) which allows the policy interpreter to refer to the
hash of the conduit c’s content (or updated content in a
write transaction) from offset off with length len. In the
update rule, hasHash and willHaveHash are used to ver-
ify that the existing ﬁle content is not modiﬁed during an
update by checking that the hashes of the ﬁle from offset
0 to cLen, originally and after the prospective update, are
equal.
A more efﬁcient
implementation of
the append-
only policy could rely on a specialized predicate
unmodiﬁed(off, len), which checks that the conduit con-
tents from offset off with length len were not modiﬁed.
The update rule could then be simpliﬁed to:
update :- sKeyIs(k) ∧
(“auth_employees”, off ) says isEmployee(k) ∧
cCurrLenIs(cLen) ∧ cNewLenIs(nLen) ∧
gt(nLen, cLen) ∧ unmodiﬁed(0, cLen)
Region-based censorship Legal requirements may
force the provider to blacklist certain source ﬁles in cer-
tain regions. Accordingly, the goal of the censorship pol-
icy is to ensure that content from a document F can only
reach users in regions whose blacklists do not contain F.
The policy relies on a mapping from IP addresses to re-
gions and a per-region blacklist ﬁle. The blacklist ﬁle is
maintained in a sorted order to efﬁciently lookup whether
it contains a given document or not.
The censorship policy is expressed by modifying the
declassify rule of every source conduit cndID as follows:
declassify :- isAsRestrictive(read,
(CENSOR(cndID) ∧ isAsRestrictive(read,
this
.read) until
this
.read))
The rule says that
the read rule on any con-
duit to which cndID ﬂows must be as restrictive as
cndID’s read rule until a conduit at which the condition
CENSOR(cndID) holds is reached. CENSOR(cndID) is
a macro deﬁned below. The predicate sIpIs(IP) checks
USENIX Association  
25th USENIX Security Symposium  653
that the IP address of the connecting (remote) party is
IP and the predicate IpPreﬁx(IP, R) means that IP be-
longs to region R. The blacklist ﬁle for region R is
R.BlackList. In words, CENSOR(cndID) means that the
remote party’s IP belongs to a region R and cndID lies
strictly between two two consecutive entries in R’s black-
list ﬁle (and, hence, cndID does not exist in R’s blacklist
ﬁle).
sIpIs(IP) ∧ IpPreﬁx(IP, R) ∧
(FBL = concat(R, “.BlackList”)) ∧
(FBL , off1) says isCensored(cnd1) ∧
add(off2 , off1 , CENSOR_ENTRY_LEN) ∧
(FBL , off2) says isCensored(cnd2) ∧
lt(cnd1 , cndID) ∧ lt(cndID, cnd2)
A.3 Search engine ﬂows
Indexing ﬂow The indexer reads documents with pos-
sibly contradictory policies and, in the absence of a
dedicated provision for declassiﬁcation, the index (and
any documents derived from it) cannot be served to any
client. To prevent this problem, searchable documents al-
low typed declassiﬁcation. The declassify rule for each
searchable document is modiﬁed with a new clause that
allows complete declassiﬁcation into an (internal) con-
duit whose update rule allows the conduit to contain
only a list of object ids. The modiﬁed declassify rule
of each source document has the form:
declassify :- . . . until (. . . ∨ (cIsIntrinsic ∧
isAsRestrictive(update, ONLY_CND_IDS)))
The macro ONLY_CND_IDS stipulates that only a list
of valid conduit ids can be written and it expands to:
cCurrLenIs(cLen) ∧ cNewLenIs(nLen) ∧
each in(this,
nLen) says(cndId)
cLen
,
{cIdExists(cndId)}
In the macro above, the predicate cNewLenIs(nLen)
binds the new length of the output ﬁle to nLen. The pred-
icate willsay checks that the content update from offset 0
and length nLen is a list of conduit IDs, and the predi-
cate cIdExists(cndId) checks that cndId corresponds to
an existing conduit.
So far we have assumed that the conduit ids are not
themselves conﬁdential. If the presence or absence of a
particular conduit id in the search results may leak sensi-
tive information, then the source declassiﬁcation policy
can be augmented to require that the list of conduit ids
is accessible only to a principal who satisﬁes the conﬁ-
dentiality policies of all listed conduits. Then, the macro
ONLY_CND_IDS can be re-written to:
cLen
cCurrLenIs(cLen) ∧ cNewLenIs(nLen) ∧
nLen) willsay(cndId)
each in(this,
{cIdExists(cndId) ∧ hasPol(cndId
P) ∧
isAsRestrictive(read,
isAsRestrictive(declassify,
.read) ∧
.declassify)}
P
,
,
P
,
Additionally in the macro above,
the predicate
P) binds P to the policy of the conduit
hasPol(cndId
.read)
cndId, and the predicate isAsRestrictive(read,
requires that the conﬁdentiality of the list of conduit ids
is as restrictive as the conﬁdentiality requirements of the
source conduit ids themselves.
P
Proﬁle aggregation ﬂow Since raw user activity logs
are typically private, a declassiﬁcation is required that
enables a proﬁle generator to produce a user preferences
vector (a vector of ﬁxed length) from the activity logs.
However, this preferences vector must further be re-
stricted so that it can be used to produce only a list of
conduit ids (the search results). Further, the user might
also want to ensure that only activity logs generated in
the past 48 hours be used for personalization. This can be
achieved by allowing the declassiﬁcation into the ﬁxed-
size vector to happen only within 172800 seconds of the
log’s creation. Suppose an activity log is created at time
t and that the preferences vector has length n. Then, the
relevant policy rules on the activity log are the following
(note that t and n are constants, not variables).
read :- sKeyIs(kAlice)
declassify :- [isAsRestrictive(read,
this
.read) until
isAsRestrictive(update, ONLY_FLOATS(n)) ∧
cIsIntrinsic ∧ timeIs(curT ) ∧ gt(curT ,t) ∧
sub(di f f , curT ,t) ∧ lt(di f f , 172800)] ∧
[isAsRestrictive(read,
isAsRestrictive(update, ONLY_CND_IDS)]
this
.read) until cIsIntrinsic ∧
This policy ensures that the raw user logs can only be
transformed into the user preferences vector, which in
turn can only be declassiﬁed into the search results of the
search engine.
The macro ONLY_FLOATS(n) stipulates that only a
vector of n ﬂoats can be written. It expands to:
cNewLenIs(nLen) ∧
each in(this, 0,
{vType(value
eq(Cnt
, n)
nLen) willsay(value)
, FLOAT) ∧ (Cnt + +)} ∧
In the macro above, the predicate cNewLenIs(nLen)
binds the new length of the output ﬁle to nLen. The pred-
icate willsay checks that the content update from offset
0 and length nLen is a list of values, and the predicate
vType(value, FLOAT) checks that each value in the list
is of type FLOAT. The predicate eq(cnt , n) checks that
the update contains n ﬂoats.
654  25th USENIX Security Symposium 
USENIX Association