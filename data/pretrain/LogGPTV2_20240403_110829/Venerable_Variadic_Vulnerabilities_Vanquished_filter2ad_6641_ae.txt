125
0
22
198
Table 4: Performance overhead in micro-benchmarks.
7 Related work
HexVASAN can either be used as an always-on runtime
monitor to mitigate exploits or as a sanitizer to detect
bugs, sharing similarities with the sanitizers that exist
primarily in the LLVM compiler. Similar to HexVASAN,
these sanitizers embed run-time checks into a program
by instrumenting potentially dangerous program instruc-
tions.
AddressSanitizer [54] (ASan), instruments memory
accesses and allocation sites to detect spatial memory
errors, such as out-of-bounds accesses, as well as tem-
poral memory errors, such as use-after-free bugs. Unde-
ﬁned Behavior Sanitizer [52] (UBSan) instruments vari-
ous types of instructions to detect operations whose se-
mantics are not strictly deﬁned by the C and C++ stan-
dards, e.g., increments that cause signed integers to over-
ﬂow, or null-pointer dereferences. Thread Sanitizer [55]
(TSAN) instruments memory accesses and atomic opera-
tions to detect data races, deadlocks, and various misuses
of synchronization primitives. Memory Sanitizer [58]
(MSAN) detects uses of uninitialized memory.
CaVer [32] is a sanitizer targeted at verifying correct-
ness of downcasts in C++. Downcasting converts a base
class pointer to a derived class pointer. This operation
may be unsafe as it cannot be statically determined, in
general, if the pointed-to object is of the derived class
type. TypeSan [25] is a reﬁnement of CaVer that reduces
overhead and improves the sanitizer coverage.
UniSan [34] sanitizes information leaks from the ker-
nel. It ensures that data is initialized before leaving the
kernel, preventing reads of uninitialized memory.
All of these sanitizers are highly effective at ﬁnding
speciﬁc types of bugs, but, unlike HexVASAN, they do
not address misuses of variadic functions. The aforemen-
tioned sanitizers also differ from HexVASAN in that they
typically incur signiﬁcant run-time and memory over-
head.
Different control-ﬂow hijacking mitigations offer par-
tial protection against variadic function attacks by
preventing adversaries from calling variadic functions
through control-ﬂow edges that do not appear in legit-
imate executions of the program. Among these miti-
gations, we ﬁnd Code Pointer Integrity (CPI) [30], a
mitigation that prevents attackers from overwriting code
pointers in the program, and various implementations of
Control-Flow Integrity (CFI), a technique that does not
prevent code pointer overwrites, but rather veriﬁes the in-
tegrity of control-ﬂow transfers in the program [6, 7, 11,
14–16,21,22,28,35,37,38,41–44,46,49–51,59,61–66].
Control-ﬂow hijacking mitigations cannot prevent at-
tackers from overwriting variadic arguments directly.
At best, they can prevent variadic functions from be-
ing called through control-ﬂow edges that do not ap-
pear in legitimate executions of the program. We there-
fore argue that HexVASAN and these mitigations are
orthogonal. Moreover, prior research has shown that
many of the aforementioned implementations fail to fully
prevent control-ﬂow hijacking as they are too impre-
cise [8, 17, 19, 23], too limited in scope [53, 57], vulner-
able to information leakage attacks [18], or vulnerable
to spraying attacks [24, 45]. We further showed in Sec-
tion 6.1 that variadic functions exacerbate CFI’s impre-
cision problems, allowing additional leeway for adver-
saries to attack variadic functions.
Defenses that protect against direct overwrites or mis-
use of variadic arguments have thus far only focused on
format string attacks, which are a subset of the possible
attacks on variadic functions. LibSafe detects potentially
dangerous calls to known format string functions such
as printf and sprintf [60]. A call is considered dan-
gerous if a %n speciﬁer is used to overwrite the frame
pointer or return address, or if the argument list for the
printf function is not contained within a single stack
frame. FormatGuard [12] instruments calls to printf
and checks if the number of arguments passed to printf
matches the number of format speciﬁers used in the for-
mat string.
Shankar et al. proposed to use static taint analysis to
detect calls to format string functions where the format
string originates from an untrustworthy source [56]. This
approach was later reﬁned by Chen and Wagner [10] and
used to analyze thousands of packages in the Debian 3.1
Linux distribution. TaintCheck [39] also detects untrust-
worthy format strings, but relies on dynamic taint analy-
sis to do so.
FORTIFY SOURCE of glibc provides some lightweight
checks to ensure all the arguments are consumed. How-
ever, it can be bypassed [2] and does not check for type-
mismatch. Hence, none of these aforementioned solu-
tions provide comprehensive protection against variadic
argument overwrites or misuse.
USENIX Association
26th USENIX Security Symposium    195
8 Conclusions
Variadic functions introduce an implicitly deﬁned con-
tract between the caller and callee. When the program-
mer fails to enforce this contract correctly, the violation
leads to runtime crashes or opens up a vulnerability to
an attacker. Current tools, including static type check-
ers and CFI implementations, do not ﬁnd variadic func-
tion type errors or prevent attackers from exploiting calls
to variadic functions. Unfortunately, variadic functions
are prevalent. Programs such as SPEC CPU2006, Fire-
fox, Apache, CPython, nginx, wireshark and libraries
frequently leverage variadic functions to offer ﬂexibility
and abundantly call these functions.
We have designed a sanitizer, HexVASAN, that ad-
dresses this attack vector. HexVASAN is a light weight
runtime monitor that detects bugs in variadic functions
and prevents the bugs from being exploited. It imposes
negligible overhead (0.45%) on the SPEC CPU2006
benchmarks and is effective at detecting type viola-
tions when calling variadic arguments. Download Hex-
VASAN at https://github.com/HexHive/HexVASAN.
9 Acknowledgments
We thank the anonymous reviewers for their insightful
comments. We also thank our shepherd Adam Doup´e
for his informative feedback. This material is based
in part upon work supported by the National Science
Foundation under awards CNS-1513783, CNS-1657711,
and CNS-1619211, by the Defense Advanced Research
Projects Agency (DARPA) under contracts FA8750-15-
C-0124 and FA8750-15-C-0085, and by Intel Corpora-
tion. We also gratefully acknowledge a gift from Oracle
Corporation. Any opinions, ﬁndings, and conclusions or
recommendations expressed in this material are those of
the authors and do not necessarily reﬂect the views of
the National Science Foundation, the Defense Advanced
Research Projects Agency (DARPA) and its Contracting
Agents, or any other agency of the U.S. Government.
References
[1] http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=
CVE-2015-8617.
[2] A eulogy for format strings. http://phrack.org/issues/67/
9.html.
[3] Kraken benchmark. https://wiki.mozilla.org/Kraken.
[4] Octane benchmark.
https://developers.google.com/
octane/faq.
[5] Using the gnu compiler collection (gcc)
function at-
https://gcc.gnu.org/onlinedocs/gcc-3.2/gcc/
-
tributes.
Function-Attributes.html.
[7] BOUNOV, D., KICI, R., AND LERNER, S. Protecting C++ dy-
In Symposium on
namic dispatch through vtable interleaving.
Network and Distributed System Security (NDSS) (2016).
[8] CARLINI, N., BARRESI, A., PAYER, M., WAGNER, D., AND
GROSS, T. R. Control-ﬂow bending: On the effectiveness of
control-ﬂow integrity. In USENIX Security Symposium (2015).
[9] CASTRO, M., COSTA, M., MARTIN, J.-P., PEINADO, M.,
AKRITIDIS, P., DONNELLY, A., BARHAM, P., AND BLACK, R.
Fast byte-granularity software fault isolation. In ACM Symposium
on Operating Systems Principles (SOSP) (2009).
[10] CHEN, K., AND WAGNER, D. Large-scale analysis of format
string vulnerabilities in debian linux. In Proceedings of the 2007
workshop on Programming languages and analysis for security
(2007).
[11] CHENG, Y., ZHOU, Z., MIAO, Y., DING, X., AND DENG,
R. H. ROPecker: A generic and practical approach for defending
against ROP attacks. In Symposium on Network and Distributed
System Security (NDSS) (2014).
[12] COWAN, C., BARRINGER, M., BEATTIE, S., KROAH-
HARTMAN, G., FRANTZEN, M., AND LOKIER, J. Formatguard:
Automatic protection from printf format string vulnerabilities. In
USENIX Security Symposium (2001).
[13] COWAN, C., PU, C., MAIER, D., WALPOLE, J., BAKKE, P.,
BEATTIE, S., GRIER, A., WAGLE, P., ZHANG, Q., AND HIN-
TON, H. Stackguard: Automatic adaptive detection and preven-
tion of buffer-overﬂow attacks. In USENIX Security Symposium
(1998).
[14] CRISWELL, J., DAUTENHAHN, N., AND ADVE, V. KCoFI:
Complete control-ﬂow integrity for commodity operating system
In IEEE Symposium on Security and Privacy (S&P)
kernels.
(2014).
[15] DAVI, L., DMITRIENKO, A., EGELE, M., FISCHER, T., HOLZ,
T., HUND, R., N ¨URNBERGER, S., AND SADEGHI, A.-R.
MoCFI: A framework to mitigate control-ﬂow attacks on smart-
phones. In Symposium on Network and Distributed System Secu-
rity (NDSS) (2012).
[16] DAVI, L., KOEBERL, P., AND SADEGHI, A.-R. Hardware-
assisted ﬁne-grained control-ﬂow integrity: Towards efﬁcient
protection of embedded systems against software exploitation. In
Annual Design Automation Conference (DAC) (2014).
[17] DAVI, L., SADEGHI, A.-R., LEHMANN, D., AND MONROSE,
F. Stitching the gadgets: On the ineffectiveness of coarse-grained
control-ﬂow integrity protection. In USENIX Security Symposium
(2014).
[18] EVANS, I., FINGERET, S., GONZ ´ALEZ, J., OTGONBAATAR, U.,
TANG, T., SHROBE, H., SIDIROGLOU-DOUSKOS, S., RINARD,
M., AND OKHRAVI, H. Missing the point (er): On the effective-
ness of code pointer integrity. In IEEE Symposium on Security
and Privacy (S&P) (2015).
[19] EVANS, I., LONG, F., OTGONBAATAR, U., SHROBE, H., RI-
NARD, M., OKHRAVI, H., AND SIDIROGLOU-DOUSKOS, S.
Control jujutsu: On the weaknesses of ﬁne-grained control ﬂow
integrity. In ACM Conference on Computer and Communications
Security (CCS) (2015).
[20] EXPLOIT DATABASE. sudo debug privilege escalation. https:
//www.exploit-db.com/exploits/25134/, 2013.
[21] GAWLIK, R., AND HOLZ, T. Towards Automated Integrity
Protection of C++ Virtual Function Tables in Binary Programs.
In Annual Computer Security Applications Conference (ACSAC)
(2014).
[6] ABADI, M., BUDIU, M., ERLINGSSON, U., AND LIGATTI, J.
In ACM Conference on Computer and
Control-ﬂow integrity.
Communications Security (CCS) (2005).
[22] GE, X., TALELE, N., PAYER, M., AND JAEGER, T. Fine-
In IEEE
Grained Control-Flow Integrity for Kernel Software.
European Symp. on Security and Privacy (2016).
196    26th USENIX Security Symposium
USENIX Association
[23] G ¨OKTAS, E., ATHANASOPOULOS, E., BOS, H., AND POR-
TOKALIDIS, G. Out of control: Overcoming control-ﬂow in-
In IEEE Symposium on Security and Privacy (S&P)
tegrity.
(2014).
[24] G ¨OKTAS, E., GAWLIK, R., KOLLENDA, B., ATHANASOPOU-
LOS, E., PORTOKALIDIS, G., GIUFFRIDA, C., AND BOS, H.
Undermining information hiding (and what to do about it).
In
USENIX Security Symposium (2016).
[25] HALLER, I., JEON, Y., PENG, H., PAYER, M., GIUFFRIDA,
C., BOS, H., AND VAN DER KOUWE, E. Typesan: Practical
type confusion detection. In ACM Conference on Computer and
Communications Security (CCS) (2016).
[26] Information technology – Programming languages – C++. Stan-
dard, International Organization for Standardization, Geneva,
CH, Dec. 2014.
[27] Information technology – Programming languages – C. Standard,
International Organization for Standardization, Geneva, CH, Dec.
2011.
[28] JANG, D., TATLOCK, Z., AND LERNER, S. SAFEDISPATCH:
Securing C++ virtual calls from memory corruption attacks. In
Symposium on Network and Distributed System Security (NDSS)
(2014).
[29] JELINEK, J. FORTIFY SOURCE. https://gcc.gnu.org/ml/
gcc-patches/2004-09/msg02055.html, 2004.
[30] KUZNETSOV, V., SZEKERES, L., PAYER, M., CANDEA, G.,
SEKAR, R., AND SONG, D. Code-pointer integrity. In USENIX
Symposium on Operating Systems Design and Implementation
(OSDI) (2014).
[31] LATTNER, C., AND ADVE, V. Llvm: A compilation framework
In IEEE/ACM
for lifelong program analysis & transformation.
International Symposium on Code Generation and Optimization
(CGO) (2004).
[32] LEE, B., SONG, C., KIM, T., AND LEE, W. Type casting veriﬁ-
cation: Stopping an emerging attack vector. In USENIX Security
Symposium (2015).
[33] LINUX PROGRAMMER’S MANUAL. va start (3) - Linux Manual
Page.
[34] LU, K., SONG, C., KIM, T., AND LEE, W. Unisan: Proactive
kernel memory initialization to eliminate data leakages. In ACM
Conference on Computer and Communications Security (CCS)
(2016).
[35] MASHTIZADEH, A. J., BITTAU, A., BONEH, D., AND
MAZI `ERES, D. Ccﬁ: cryptographically enforced control ﬂow
integrity. In ACM Conference on Computer and Communications
Security (CCS) (2015).
[36] MATZ, M., HUBICKA, J., JAEGER, A., AND MITCHELL, M.
System v application binary interface. AMD64 Architecture Pro-
cessor Supplement, Draft v0.99 (2013).
[37] MICROSOFT CORPORATION. Control Flow Guard (Windows).
https://msdn.microsoft.com/en-us/library/windows/
desktop/mt637065(v=vs.85).aspx, 2016.
[38] MOHAN, V., LARSEN, P., BRUNTHALER, S., HAMLEN, K.,
AND FRANZ, M. Opaque control-ﬂow integrity. In Symposium
on Network and Distributed System Security (NDSS) (2015).
[39] NEWSOME, J., AND SONG, D. Dynamic taint analysis for auto-
matic detection, analysis, and signature generation of exploits on
commodity software. In Symposium on Network and Distributed
System Security (NDSS) (2005).
[40] NISSIL, R. http://cve.mitre.org/cgi-bin/cvename.cgi?
name=CVE-2009-1886.
[41] NIU, B., AND TAN, G. Monitor integrity protection with space
efﬁciency and separate compilation. In ACM Conference on Com-
puter and Communications Security (CCS) (2013).
[42] NIU, B., AND TAN, G. Modular control-ﬂow integrity. In ACM
SIGPLAN Conference on Programming Language Design and
Implementation (PLDI) (2014).
[43] NIU, B., AND TAN, G. RockJIT: Securing just-in-time compila-
tion using modular control-ﬂow integrity. In ACM Conference on
Computer and Communications Security (CCS) (2014).
[44] NIU, B., AND TAN, G. Per-input control-ﬂow integrity. In ACM
Conference on Computer and Communications Security (CCS)
(2015).
[45] OIKONOMOPOULOS, A., ATHANASOPOULOS, E., BOS, H.,
In
AND GIUFFRIDA, C. Poking holes in information hiding.
USENIX Security Symposium (2016).
[46] PAPPAS, V., POLYCHRONAKIS, M., AND KEROMYTIS, A. D.
Transparent ROP exploit mitigation using indirect branch tracing.
In USENIX Security Symposium (2013).
[47] PAX TEAM. Pax address space layout randomization (aslr).
[48] PAX TEAM. PaX non-executable pages design & implementa-
tion. http://pax.grsecurity.net/docs/noexec.txt, 2004.
[49] PAYER, M., BARRESI, A., AND GROSS, T. R. Fine-grained
control-ﬂow integrity through binary hardening. In Conference
on Detection of Intrusions and Malware & Vulnerability Assess-
ment (DIMVA) (2015).
[50] PEWNY, J., AND HOLZ, T. Control-ﬂow restrictor: Compiler-
based CFI for iOS. In Annual Computer Security Applications
Conference (ACSAC) (2013).
[51] PRAKASH, A., HU, X., AND YIN, H. vfGuard: Strict Protection
for Virtual Function Calls in COTS C++ Binaries. In Symposium
on Network and Distributed System Security (NDSS) (2015).
[52] PROJECT,
G. C.
https://www.chromium.org/developers/testing/
undefinedbehaviorsanitizer.
Undeﬁned
behavior
sanitizer.
[53] SCHUSTER, F., TENDYCK, T., LIEBCHEN, C., DAVI, L.,
SADEGHI, A.-R., AND HOLZ, T. Counterfeit object-oriented
programming: On the difﬁculty of preventing code reuse attacks
in c++ applications. In IEEE Symposium on Security and Privacy
(S&P) (2015).
[54] SEREBRYANY, K., BRUENING, D., POTAPENKO, A., AND
VYUKOV, D. Addresssanitizer: a fast address sanity checker.
In USENIX Annual Technical Conference (2012).
[55] SEREBRYANY, K., AND ISKHODZHANOV, T. Threadsanitizer:
Data race detection in practice. In Workshop on Binary Instru-
mentation and Applications (2009).
[56] SHANKAR, U., TALWAR, K., FOSTER, J. S., AND WAGNER,
D. Detecting format string vulnerabilities with type qualiﬁers. In
USENIX Security Symposium (2001).
[57] SNOW, K. Z., MONROSE, F., DAVI, L., DMITRIENKO, A.,
LIEBCHEN, C., AND SADEGHI, A. Just-in-time code reuse: On
the effectiveness of ﬁne-grained address space layout randomiza-
tion. In IEEE Symposium on Security and Privacy (S&P) (2013).
[58] STEPANOV, E., AND SEREBRYANY, K. Memorysanitizer: Fast
detector of uninitialized memory use in c++. In IEEE/ACM In-
ternational Symposium on Code Generation and Optimization
(CGO) (2015).
[59] TICE, C., ROEDER, T., COLLINGBOURNE, P., CHECKOWAY,
S., ERLINGSSON, ´U., LOZANO, L., AND PIKE, G. Enforcing
forward-edge control-ﬂow integrity in gcc & llvm. In USENIX
Security Symposium (2014).
USENIX Association
26th USENIX Security Symposium    197
[60] TSAI, T., AND SINGH, N. Libsafe 2.0: Detection of format string
vulnerability exploits. white paper, Avaya Labs (2001).
[61] VAN DER VEEN, V., ANDRIESSE, D., G ¨OKTAS¸, E., GRAS, B.,
SAMBUC, L., SLOWINSKA, A., BOS, H., AND GIUFFRIDA,
C. PathArmor: Practical ROP protection using context-sensitive
CFI. In ACM Conference on Computer and Communications Se-
curity (CCS) (2015).
[62] WANG, Z., AND JIANG, X. Hypersafe: A lightweight approach
In IEEE
to provide lifetime hypervisor control-ﬂow integrity.
Symposium on Security and Privacy (S&P) (2010).
[63] YUAN, P., ZENG, Q., AND DING, X. Hardware-assisted ﬁne-
grained code-reuse attack detection. In International Symposium
on Research in Attacks, Intrusions and Defenses (RAID) (2015).
[64] ZHANG, C., SONG, C., CHEN, K. Z., CHEN, Z., AND SONG,
D. VTint: Defending virtual function tables’ integrity. In Sympo-
sium on Network and Distributed System Security (NDSS) (2015).
[65] ZHANG, C., WEI, T., CHEN, Z., DUAN, L., SZEKERES, L.,
MCCAMANT, S., SONG, D., AND ZOU, W. Practical control
ﬂow integrity and randomization for binary executables. In IEEE
Symposium on Security and Privacy (S&P) (2013).
[66] ZHANG, M., AND SEKAR, R. Control ﬂow integrity for cots
binaries. In USENIX Security Symposium (2013).
198    26th USENIX Security Symposium
USENIX Association