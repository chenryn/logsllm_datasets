原文：
在这篇文章中，我们将为读者介绍一种非常罕见的漏洞类型，通常情况下，这种类型的漏洞只会影响图形渲染库（当然，有时候它们也会出现在其他类型的软件中）。之所以会出现这种问题，究其根本原因，是因为精度误差能够令应用程序所做的安全性假设失效，致使其转而使用有限精度算法。
这种类型的漏洞与整数溢出非常相似，主要区别在于：对于整数溢出来说，是出现在这样的算术运算过程中——由于运算的结果太大而无法以给定的精度来准确表示。对于本文描述的安全漏洞来说，则出现在这样的算术运算过程中——因运算结果或结果的一部分太小而无法以给定的精度准确表示。
在运算结果对安全非常敏感的运算中，这类问题通常是由浮点运算所致，但是，正如我们稍后将演示的那样，在某些情况下，这类安全问题也可能出现在整数运算中。
下面，先让我们来看一个简单的例子：
    float a = 100000000;
     float b = 1;
     float c = a + b;
对于上述计算，如果采用任意精度的话，结果应该是100000001。但是，由于[浮点数](https://en.wikipedia.org/wiki/IEEE_754
"浮点数")通常只允许使用24位精度，因此，结果实际上将是100000000。所以，如果应用程序假设a>0并且b>0的话（通常都会这样合理地假设），则意味着a+b>a，那么，这种假设就很可能导致问题。
在上面的例子中，a和b之间的差异非常大，并且b在计算结果中完全消失；然而，即使差异较小，也会发生精度误差，例如
    float a = 1000;
     float b = 1.1111111;
     float c = a + b;
上述计算的结果将是1001.111084，而非1001.1111111，而后者才是准确的结果。在这种情况下，虽然b的只有很小一部分丢失，但即使如此，有时也会带来有趣的后果。
在上面的示例中，使用的是浮点类型，如果使用双浮点类型的话，虽然能够获得更精确的计算结果，但是，类似的精度错误仍然无法消除。
在本文的其余部分中，我们将展示几个有安全影响的精度问题例子。这些安全问题由两位Project Zero成员独立发现的：一位是Mark
Brand，他研究的对象是SwiftShader，它是OpenGL的软件实现，用于Chrome浏览器；另一位是Ivan
Fratric，他考察的对象是Chrome和Firefox中使用的Skia图形库。
**SwiftShader**
* * *
SwiftShader是“OpenGL ES和Direct3D
9图形API基于CPU的高性能实现”。所有平台上的[Chrome](https://blog.chromium.org/2016/06/universal-rendering-with-swiftshader.html
"Chrome")浏览器都将其作为备选渲染库，用于突破图形硬件或驱动程序的限制，使其可以在更广泛的设备上应用WebGL和其他高级JavaScript渲染API。
SwiftShader中的代码需要对通常由GPU执行的各种操作进行模拟。例如，通常由GPU执行的一种操作是upscaling，即将一段小的源纹理绘制到更大的区域，例如铺满屏幕。这需要使用非整数值计算内存索引，实际上，[漏洞](https://bugs.chromium.org/p/project-zero/issues/detail?id=1584 "漏洞")往往就出现在这里。
就像最初的漏洞报告中所指出的那样，我们在这里看到的代码，未必就是实际运行的代码--SwiftShader会使用基于LLVM的JIT引擎在运行时对关键代码进行性能优化，而优化后的代码，要比优化前的代码更难以理解，但是两者都包含相同的错误，因此，我们不妨先从简单的代码入手，即先考察未经优化的代码。实际上，这些代码就是用于在渲染过程中将像素从一个表面复制到另一个表面的复制循环：
    source->lockInternal((int)sRect.x0, (int)sRect.y0, sRect.slice, sw::LOCK_READONLY, sw::PUBLIC);
     dest->lockInternal(dRect.x0, dRect.y0, dRect.slice, sw::LOCK_WRITEONLY, sw::PUBLIC);
     float w = sRect.width() / dRect.width();
     float h = sRect.height() / dRect.height();
     const float xStart = sRect.x0 + 0.5f * w;
     float y = sRect.y0 + 0.5f * h;
     float x = xStart;
     for(int j = dRect.y0; j copyInternal(source, i, j, x, y, options.filter);
         x += w;
       }
       y += h;
     }
     source->unlockInternal();
     dest->unlockInternal();
    }
那么，这段代码有什么问题吗？我们知道，在进入这个函数之前就已经完成了所有的边界检查，并且在dRect中使用 (i, j)和sRect中使用(x,
y)调用copyInternal也都是安全的。
实际上，在上面的示例中，出现的精度误差是下舍入导致的——就本例而言，还不足以产生让我们感兴趣的安全漏洞。我们能否利用浮点数的精度误差，获得一个比正确值更大的值，从而导致（x，y）的值大于预期值呢？
如果我们仔细阅读代码，就会发现，开发人员的本意为：
    for(int j = dRect.y0; j copyInternal(source, i, j, x, y, options.filter);
       }
     }
即使使用这种方式，仍然会存在精度误差——但是，由于没有进行迭代计算，误差无法传播，这样的话，最终的预期精度误差的大小就是稳定的，并且与操作数大小成正比。相反，如果代码执行迭代计算的话，误差就会迅速传播，像滚雪球一样，越滚越大。
对于浮点计算来说，有多种方法都可以估算其最大误差；如果你真的、真的需要避免进行额外的边界检查的话，那么可以使用这种方法，但是一定确保这种方法的最大误差具有足够的安全边际量。说实话，对于这个问题来说，这可能是一种太过复杂且容易出错的解决方案。在这里，我们想要做的，是寻找一些用来展示这种类型的漏洞的“带病”数值，因此，这种方式显然不太合适；所以，接下来，我们会采取一种简单粗暴的方法。
我们觉得，使用乘法的实现的话，得到的结果将是大致准确的，而带有迭代加法的实现得到的结果则不那么准确。鉴于可能的输入空间很小（Chrome不允许使用宽度或高度大于8192的纹理），因此，不妨对源宽度与目标宽度的所有比率进行蛮力搜索，从而对这两种算法做个比对，看看结果有什么不同。（请注意，SwiftShader也限制我们使用偶数）。这样，我们得到的结果为5828,8132；下面是对这两种方法的比较（左侧使用的是迭代加法，右侧使用的是乘法）：
    0:    1.075012 1.075012
    1:    1.791687 1.791687
    ...
    1000: 717.749878 717.749878   到目前为止，这两个值仍然完全相等(就所示的精度来说) 
    1001: 718.466553 718.466553
    ...
    2046: 1467.391724 1467.391724 从这里开始，第一个有效位误差开始出现，但请注意 
    2047: 1468.108398 1468.108521“不精确”的结果小于更精确的结果。
    ...
    2856: 2047.898315 2047.898438
    2857: 2048.614990 2048.614990 在这里，两个计算结果再次一致，简单地说，
    2858: 2049.331787 2049.331787 从这里开始，精度误差总是倾向于产生
    2859: 2050.048584 2050.048340 更大的结果而不是更精确的计算。