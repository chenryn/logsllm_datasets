        union {
            uint32_t opreg[0x44/sizeof(uint32_t)];
            struct {
                uint32_t usbcmd;
                uint32_t usbsts;
                uint32_t usbintr;
                uint32_t frindex;
                uint32_t ctrldssegment;
                uint32_t periodiclistbase;
                uint32_t asynclistaddr;
                uint32_t notused[9];
                uint32_t configflag;
            };
        };
        uint32_t portsc[NB_PORTS];
        /*
         *  Internal states, shadow registers, etc
         */
        QEMUTimer *frame_timer;
        QEMUBH *async_bh;
        bool working;
        uint32_t astate;         /* Current state in asynchronous schedule */
        uint32_t pstate;         /* Current state in periodic schedule     */
        USBPort ports[NB_PORTS];
        USBPort *companion_ports[NB_PORTS];
        uint32_t usbsts_pending;
        uint32_t usbsts_frindex;
        EHCIQueueHead aqueues;
        EHCIQueueHead pqueues;
        /* which address to look at next */
        uint32_t a_fetch_addr;
        uint32_t p_fetch_addr;
        USBPacket ipacket;
        QEMUSGList isgl;
        uint64_t last_run_ns;
        uint32_t async_stepdown;
        uint32_t periodic_sched_active;
        bool int_req_by_async;
        VMChangeStateEntry *vmstate;
    };
**USBPort**
    struct USBPort {
        USBDevice *dev;
        int speedmask;
        int hubcount;
        char path[16];
        USBPortOps *ops;
        void *opaque;
        int index; /* internal port index, may be used with the opaque */
        QTAILQ_ENTRY(USBPort) next;
    };
**USBEndpoint**
    struct USBEndpoint {
        uint8_t nr;
        uint8_t pid;
        uint8_t type;
        uint8_t ifnum;
        int max_packet_size;
        int max_streams;
        bool pipeline;
        bool halted;
        USBDevice *dev;
        QTAILQ_HEAD(, USBPacket) queue;
    };
**IRQState**
    struct IRQState {
        Object parent_obj;
        qemu_irq_handler handler;
        void *opaque;
        int n;
    };
**EHCIqtd**
    typedef struct EHCIqtd {
        uint32_t next;                    /* Standard next link pointer */
        uint32_t altnext;                 /* Standard next link pointer */
        uint32_t token;
    #define QTD_TOKEN_DTOGGLE             (1 ehci;
        s->caps[0x09] = 0x68;        /* EECP */
        s->capsbase = 0x00;
        s->opregbase = 0x20;
        s->portscbase = 0x44;
        s->portnr = NB_PORTS;
        if (!dc->hotpluggable) {
            s->companion_enable = true;
        }
        usb_ehci_init(s, DEVICE(obj));
    }
对应的我们用到的两个写函数代码如下
    ---------------------------------------------------------------------------------------------------------------------------    static void ehci_opreg_write(void *ptr, hwaddr addr,
                                 uint64_t val, unsigned size)
    {
        EHCIState *s = ptr;
        uint32_t *mmio = s->opreg + (addr >> 2);
        uint32_t old = *mmio;
        int i;
        trace_usb_ehci_opreg_write(addr + s->opregbase, addr2str(addr), val);
        switch (addr) {
        case USBCMD:
            if (val & USBCMD_HCRESET) {
                ehci_reset(s);
                val = s->usbcmd;
                break;
            }
            /* not supporting dynamic frame list size at the moment */
            if ((val & USBCMD_FLS) && !(s->usbcmd & USBCMD_FLS)) {
                fprintf(stderr, "attempt to set frame list size -- value %d\n",
                        (int)val & USBCMD_FLS);
                val &= ~USBCMD_FLS;
            }
            if (val & USBCMD_IAAD) {
                /*
                 * Process IAAD immediately, otherwise the Linux IAAD watchdog may
                 * trigger and re-use a qh without us seeing the unlink.