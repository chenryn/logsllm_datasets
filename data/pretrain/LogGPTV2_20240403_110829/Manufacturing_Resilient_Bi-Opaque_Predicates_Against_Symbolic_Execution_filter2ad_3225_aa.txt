title:Manufacturing Resilient Bi-Opaque Predicates Against Symbolic Execution
author:Hui Xu and
Yangfan Zhou and
Yu Kang and
Fengzhi Tu and
Michael R. Lyu
2018 48th Annual IEEE/IFIP International Conference on Dependable Systems and Networks
Manufacturing Resilient Bi-Opaque Predicates
against Symbolic Execution
Hui Xu
∗†
, Yangfan Zhou
‡§
, Yu Kang
‡
, Fengzhi Tu
∗
, Michael R. Lyu
∗†
Shenzhen Research Institute, The Chinese University of Hong Kong
Dept. of Computer Science and Engineering, The Chinese University of Hong Kong
‡
School of Computer Science, Fudan University
∗
†
§
Engineering Research Center of Cyber Security Auditing and Monitoring, Ministry of Education
Abstract—Control-ﬂow obfuscation increases program com-
plexity by semantic-preserving transformation. Opaque predi-
cates are essential gadgets to achieve such transformation. How-
ever, we observe that real-world opaque predicates are generally
very simple and engage little security consideration. Recently,
such insecure opaque predicates have been severely attacked by
symbolic execution-based adversaries and jeopardize the security
of control-ﬂow obfuscation. This paper,
therefore, proposes
symbolic opaque predicates which can be resilient to symbolic
execution-based adversaries. We design a general framework
to compose such opaque predicates, which requires introducing
challenging symbolic analysis problems (e.g., symbolic memory)
in each opaque predicate. In this way, we may mislead symbolic
execution engines into reaching false conclusions. We observe
a novel bi-opaque property about symbolic opaque predicates,
which can incur not only false negative issues but also false
positive issues to attackers. To evaluate the efﬁcacy of our
idea, we have implemented a prototype obfuscation tool based
on Obfuscator-LLVM and conduct experiments with real-world
programs. Our evaluation results show that symbolic opaque
predicates demonstrate excellent resilience to prevalent symbolic
execution engines, such as BAP, Triton, and Angr. Moreover,
although the costs of symbolic opaque predicates may vary for
different problem settings, some predicates can be very efﬁcient.
Therefore, our framework is both secure and usable. Users can
follow the framework to introduce symbolic opaque predicates
into their obfuscation tools and made them more powerful.
I. INTRODUCTION
Obfuscation is a widely employed technique which protects
software from reverse engineering. It transforms programs into
unintelligible versions while preserving their original function-
alities. Obfuscation can be achieved via lexical transformation,
control-ﬂow transformation, data-ﬂow transformation, etc [1].
Such obfuscation transformation techniques are orthogonal to
each other and can be employed simultaneously.
This paper focuses on control-ﬂow obfuscation, which
increases software complexity (e.g., by adding bogus con-
trol ﬂows) against
reverse control-ﬂow analysis. Opaque
predicates are essential gadgets to achieve such obfuscation
transformation. An opaque predicate is a predicate whose
value is known before obfuscation time but difﬁcult
to
be deduced by reverse analysis. Because it holds some
deterministic properties, we can employ opaque predicates
to transform a program without changing its semantics.
For example, we can add a bogus code block after a
constantly false opaque predicate and guarantee the code block
would never be executed. In practice, opaque constant (e.g.,
x2 (cid:2)= −1) is the most prevalent type of opaque predicates
adopted by obfuscation tools, such as Obfuscator-LLVM [2].
Although other approaches (e.g., unsolved conjectures [3])
may demonstrate better security, they are not widely adopted
due to either implementation or performance issues [4].
Recently, the security of opaque predicates has been greatly
challenged due to the development of symbolic execution
techniques. Notably, Ming et al. have proposed an opaque
predicate detection approach based on symbolic execution [5];
Yadegari et al. have demonstrated the effectiveness of deob-
fuscation attacks based on symbolic execution [6]. Symbolic
execution is a program analysis approach that models the
conditions for executing alternative control ﬂows. It attempts
to ﬁnd test cases that can satisfy such conditions. If a condition
cannot be satisﬁed,
it may indicate a bogus control ﬂow
or an opaque predicate. Symbolic execution-based attacks
may not be new to the research community. But due to the
development of symbolic execution techniques, such attacks
become practical recently and jeopardize the robustness of
obfuscated software.
In this work, we propose a novel framework to manu-
facture symbolic opaque predicates which are resistant
to
symbolic execution-based adversaries. A key procedure in our
framework is to introduce challenging problems for symbolic
execution to analyze, such as employing symbolic memory and
parallel programming [7]. Moreover, we observe a bi-opaque
property of such opaque predicates, i.e., it may either mislead
an attacker into falsely recognizing an opaque predicate as a
normal predicate, or to falsely recognizing a normal predicate
as an opaque predicate.
We have implemented a prototype tool based on Obfuscator-
tool1 automatically replaces the opaque
LLVM [2]. Our
predicates generated by Obfuscator-LLVM with symbolic
opaque predicates in IR (intermediate representative) level. It
employs a repository-based mechanism to manage different
templates of symbolic opaque predicates. Currently, we have
implemented several templates in the repository, which attack
symbolic execution with symbolic memory, ﬂoating-point
numbers, covert propagation, and parallel programming. The
1Our project url is https://github.com/hxuhack/symobfuscator
2158-3927/18/$31.00 ©2018 IEEE
DOI 10.1109/DSN.2018.00073
666
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:23:23 UTC from IEEE Xplore.  Restrictions apply. 
tool is ﬂexible such that users to extend the repository with
their own templates.
We have evaluated the resilience of our idea against three
prevalent symbolic execution engines,
including BAP [8],
Triton [9], and Angr [10]. The results demonstrate that
symbolic opaque predicates have excellent resilience against
symbolic execution-based attacks. Then we evaluate the stealth
of symbolic opaque predicates against human adversaries
when obfuscating real programs, including both general Linux
programs and encryption programs. Our experimental results
show that the implemented opaque predicates do not incur
obvious abnormal instruction patterns. We also evaluate the
cost of
the implemented predicates. Experimental results
show that some symbolic opaque predicates incur almost no
overhead in comparison with the default opaque predicates
adopted in Obfuscator-LLVM, such as those employing
symbolic memory and ﬂoating-point numbers. Other opaque
predicates may incur obvious execution overhead, such as
those employing covert propagation and parallel programming.
However, this does not degrade the usability of our framework
as long as there are some efﬁcient symbolic opaque predicates.
The cost issue can be mitigated in practice by allowing users
to ﬁlter inefﬁcient predicates or to prioritize the predicates
according to their preferences. Our approach is thus promising
to be adopted by real-world obfuscation tools.
We conclude our primary contributions as follows.
• This paper proposes symbolic opaque predicates and
demonstrates a framework to manufacture such pred-
icates. Our experimental results show that symbolic
opaque predicates are secure against symbolic execution-
based attacks and they are usable.
• We observe the novel bi-opaque property of such opaque
predicates, which extends the classic understanding about
opaque predicates.
The rest of the paper is organized as follows. Section II-A
discusses our motivating examples and deﬁnes the adversary
model of this paper. Section III introduces our framework for
composing symbolic opaque predicates. Section IV evaluates
the security and cost of our approach. Section V discusses the
related work. Finally, Section VI concludes the paper.
II. BACKGROUNDS
A. Motivation
Our investigation is mainly motivated by the vulnerability of
real-world opaque predicates. Opaque predicates are essential
gadgets for control-ﬂow obfuscation. As stated by Collberg et
al. [1], the security of opaque predicates largely determines
the security of control-ﬂow obfuscation. However, we notice
that many real-world opaque predicates are not very strong.
Below, we use two examples to demonstrate the issue.
The ﬁrst example is from a highly cited paper [11], which
proposes an approach to obfuscate programs with NP-hard
security. To compose NP-hard problems, the authors introduce
pointer analysis problems and control pointer alignments with
opaque predicates. In this way,
they can compose 3-SAT
(cid:883)