title:OS-level Side Channels without Procfs: Exploring Cross-App Information
Leakage on iOS
author:Xiaokuan Zhang and
Xueqiang Wang and
Xiaolong Bai and
Yinqian Zhang and
XiaoFeng Wang
OS-level Side Channels without Procfs:
Exploring Cross-App Information Leakage on iOS
Xiaokuan Zhang∗, Xueqiang Wang†, Xiaolong Bai‡, Yinqian Zhang∗§ and XiaoFeng Wang†
∗{zhang.5840,zhang.834}@osu.edu, The Ohio State University
†{xw7,xw48}@indiana.edu, Indiana University at Bloomington
‡PI:EMAIL, Tsinghua University
Abstract—It has been demonstrated in numerous previous
studies that Android and its underlying Linux operating systems
do not properly isolate mobile apps to prevent cross-app side-
channel attacks. Cross-app information leakage enables malicious
Android apps to infer sensitive user data (e.g., passwords),
or private user information (e.g., identity or location) without
requiring speciﬁc permissions. Nevertheless, no prior work has
ever studied these side-channel attacks on iOS-based mobile
devices. One reason is that iOS does not implement procfs—
the most popular side-channel attack vector; hence the previously
known attacks are not feasible.
In this paper, we present the ﬁrst study of OS-level side-
channel attacks on iOS. Speciﬁcally, we identiﬁed several new
side-channel attack vectors (i.e., iOS APIs that enable cross-app
information leakage); developed machine learning frameworks
(i.e., classiﬁcation and pattern matching) that combine multiple
attack vectors to improve the accuracy of the inference attacks;
demonstrated three categories of attacks that exploit these vectors
and frameworks to exﬁltrate sensitive user information. We
have reported our ﬁndings to Apple and proposed mitigations
to the attacks. Apple has incorporated some of our suggested
countermeasures into iOS 11 and MacOS High Sierra 10.13 and
later versions.
I.
INTRODUCTION
Android and iOS are the two most popular operating
systems (OS) used in smartphones, wearables, and tablets.
Security of such mobile systems has been widely studied in
the past decade, mostly in the context of Android [31], [36],
[42], [45], [66], [67], with some limited effort on iOS [34],
[37]. Of particular interest here are a series of side-channel
attacks, which empower an untrusted third-party app (e.g., free
games) to infer private user information by monitoring the
execution of OS services or trusted apps (e.g., banking apps).
Side-channel attacks typically do not exploit software vulnera-
bilities to acquire secret data directly. Instead, conﬁdential user
information is inferred from vectors (features of the target as
§Corresponding author.
Network and Distributed Systems Security (NDSS) Symposium 2018
18-21 February 2018, San Diego, CA, USA
ISBN 1-1891562-49-5
http://dx.doi.org/10.14722/ndss.2018.23260
www.ndss-symposium.org
observed by the adversary) that are considered harmless but
actually reveal some artifacts of the target app or service’s
executions. Examples of such vectors include the use of shared
CPU caches (i.e., cache side channels), mobile sensors (i.e.,
sensor-based side channels), and public APIs provided by the
OS to third-party apps for querying the status of the mobile
device, the OS, or other apps (i.e., OS-level side channels).
This paper focuses on OS-level side channels. So far, this
line of research has only been conducted on Android, with
numerous studies [31], [36], [42], [45], [64], [67] showing that
the OS and its underlying Linux kernel fail to properly control
the information leaks from seemingly harmless sources—
procfs, a pseudo ﬁlesystem available on UNIX-like op-
erating systems (including Android) to export some kernel
statistics (e.g., virtual and physical memory, CPU and network
usage) to the user space. These statistics can be classiﬁed
into two categories: per-process statistics and global statistics.
Per-process statistics reveals the information pertaining to
a speciﬁc process, while global statistics reports aggregated
information from all processes and the entire kernel. Most
existing side-channel attacks exploit per-process statistics in
procfs [31], [42], [45], [64], [67].
Unlike Android, iOS is known for its more aggressive
security controls, which render many attacks that succeed on
Android less likely to happen on iOS. Speciﬁc for the OS-level
side-channel threats, the iOS kernel is built on top of Mach [22]
and FreeBSD [38], which does not have a procfs, essentially
shutting down the main avenue for the Android-style inference
attacks. Although a small amount of procfs-alike resources
are still available on iOS (e.g., through sysctl()) [15],
they are under heavy scrutiny and facing increasingly stringent
restrictions: as a prominent example, since iOS 9, Apple
has modiﬁed sysctl() to disallow a sandboxed app from
accessing information about other running processes [16]. As a
result, it is impossible today to conduct a side-channel analysis
on iOS by exploiting per-app statistics, which completely
defeats most demonstrated attacks on Android [31], [42], [45],
[64], [67]. Therefore, to our knowledge, there was no reported
OS-level side-channel attack on iOS.
As such, in this paper, we make the ﬁrst step towards
understanding cross-app side-channel risks on iOS. More
speciﬁcally, we started with an inspection of new attack vectors
on iOS. Our study has led to the discovery of several APIs
reporting global statistics of the entire system, including CPU
usage, memory usage, network usage, and storage usage, with
examples of a subset of them described in Sec. III. These
ﬁndings,
though new to the research community, are not
extremely surprising, as such functionalities are supposed to
be provided by the OS to the userspace. Also, as one can
anticipate, these global statistic counters are noisier than per-
app statistic counters; when used individually in side-channel
attacks, they do not expose sufﬁciently intelligible information
about a speciﬁc target (e.g., a process). However, our study
shows that collectively, these counters can actually be utilized
together to deduce surprisingly detailed user data, once we
have addressed the machine learning challenges in integrating
the information from these individual sources, which have
never been considered in previous side-channel studies.
Speciﬁcally, we developed machine learning frameworks
that combine multiple noisy side-channel attack vectors in a
novel way. Particularly, we designed a classiﬁcation framework
that samples time series of the data from 6 global statistic
counters, reduces their dimensions and further extracts their
key features from training traces by using Symbolic Aggregate
approXimation (SAX), Bag-of-Pattern (BOP) representation,
and Support Vector Machine (SVM) classiﬁers. Also we de-
veloped a pattern matching framework that employs a kNN
classiﬁer with a multi-dimensional Dynamic Time Wrapping
(DTW) algorithm to calculate distance metrics. Our evaluation
demonstrates that these frameworks are effective (high accu-
racy), efﬁcient (short execution time), and robust (e.g., models
trained on one device can be used on other devices, as shown
in Sec. VII).
More concretely, we demonstrate three categories of attacks
on iOS 10, the latest iOS version as of the time of writing
this paper: classifying user activities, detecting sensitive in-
app activities, and bypassing iOS sandbox restrictions to
infer cross-container ﬁle existences using a timing-based side
channel. Speciﬁcally, we found that an unprivileged malicious
app is able to accurately identify the foreground running apps,
the websites Safari visits, and the location searched through
Apple Maps. It can further collect enough information to link
Bitcoin addresses, Venmo users, and Twitter users to a device,
and identify a set of installed sensitive apps that reveal private
information about the user, etc.
Although the focus of our study is iOS, our ﬁndings raise
a broader question important
to the design of the operat-
ing systems hosting mutually-distrusting entities: What is the
proper means to isolate these entities and prevent cross-app
side channel leaks, given the huge amount, complex interfaces
between them? As we can imagine, this question will be very
important to iOS, to Android, and to other platforms such as
clouds and IoT frameworks.
Responsible disclosure and Apple’s adoption of our coun-
termeasures. In May 2017, we reported our demonstrated
side-channel attacks to Apple, which, slightly to our surprise
(given the conventional attitudes from other vendors towards
side channels), attached high importance to our ﬁndings and
assembled a team of engineers from different groups to spe-
cially work on mitigations of these side-channel threats for the
next iOS release. We had several technical meetings with these
engineers and discussed several solutions to the problems. As
we will detail in Sec. VIII, some of the countermeasures have
been adopted in iOS/MacOS to defend against our attacks. We
are glad to see that Apple is seriously committed to mitigating
these threats by making several major updates in the OS kernel.
The threats have been fully addressed in iOS 11.1 and macOS
High Sierra 10.13.1.
Contributions. In summary, our paper makes the following
technical contributions:
• New attack vectors. We identiﬁed several iOS APIs that can
be exploited for side-channel inferences, which suggests
that even on an OS without procfs, it is very challenging
to eliminate all vectors for cross-app information leaks.
• New attack methods. We developed new frameworks to
integrate the thin information recovered from individual
vectors into serious side-channel leaks, by leveraging a
set of machine learning techniques. We also demonstrated
the robustness of our approach by training and testing on
different devices.
• New targets. We presented the attacks on a set of targets
never exploited in previous side-channel studies, such as
location inference through map loading, user identiﬁcation
via Bitcoin transaction correlation, etc.
• Proposed countermeasures integrated in iOS and MacOS.
Through responsible disclosure and technical discussions
with Apple, some of our proposed countermeasures have
been integrated into iOS 11.1 and macOS High Sierra
10.13.1.
Roadmap: Sec. II summarizes the background of iOS cross-
app isolation. Sec. III highlights our threat model and lists
several new side-channel attack vectors on iOS. Three attacks
exploiting these attack vectors were presented in Sec. IV,
Sec. V, and Sec. VI. Practical issues related to the attacks
are discussed and evaluated in Sec. VII. We discuss and
evaluate several countermeasures to the demonstrated attacks
in Sec. VIII, and summarize related work in Sec. IX. Sec. X
concludes the paper.
II. BACKGROUND: IOS CROSS-APP ISOLATION
Side channels on Android mobile devices have been ex-
tensively studied in the past [31], [36], [42], [45], [66], [67],
however, little or even no attention has been paid to iOS cross-
app side channels. In this section, we ﬁrst brieﬂy introduce the
cross-app isolation on iOS. We then describe how side-channel
attacks on iOS devices are different from those on Android,
and why they are more challenging to conduct in practice.
Sandboxing with respect to ﬁle access. Each iOS app is
by default conﬁned in a sandbox at
installation. A sand-
box speciﬁes how an app is allowed to access ﬁlesys-
tem resources and communicate with other apps or
in-
teract with the operating system. Particularly,
the app is
only allowed to access ﬁles in its own bundle container
directory and a few other public directories
[3]. The
path name of each bundle container directory contains a
UUID, which is a 32-digit random hexadecimal string (e.g.,
7E698227-C8B6-4044-A215-B4CBCB8A97AB). Cross-
container ﬁle accesses are prevented by both the randomness
of the UUIDs and the sandbox isolation.
System resources. The Info.plist ﬁle of an application
describes system resources that are needed for an application
to run properly. The ﬁrst time an app attempts to access certain
sensitive system resources (e.g., Location Services), the user is
2
asked to grant the permission explicitly. Only apps authorized
by the user are allowed to access the speciﬁc resource. This
user-centric access control can be conﬁgured on a per-app
basis. Since iOS 8, Apple has introduced ﬁner-grained access
control policies to some system resources. For instance, users
can control an app to access Location Service at any time (i.e.,
Always) or only when the app is in the foreground (i.e., While
Using) [7].
Cross-app communication. Apps commonly communicate
with each other through schemes. An app may register a cus-
tom URL scheme with the system (through its Info.plist
ﬁle). Other apps may use openURL API to send data to the
app who has registered the custom URL. For example, URL
scheme “comgooglemaps://?center=[Latitude,Longitude]” will
launch Google Map and navigate the maps’ center to the
speciﬁed location. Another means to share data between apps
is the pasteboard. The general pasteboard provides system-
wide read/write access to all apps, while the named pasteboard
is only accessible by apps with same team ID.
App vetting. Information leakage may happen when iOS APIs
are used in unexpected manners or when some undocumented
APIs are used by a malicious app. To defeat these API-misuse
attacks, all iOS apps, before reaching the market, must be
vetted by Apple, who will examine both the functionality of
the app and its potential malicious activities [21]. Although
Apple’s code review process is kept private and continuously
changing,
is believed this process includes determining
whether private APIs are used by the submitted apps [28],
whether private data is collected and transmitted without
notifying the users [21], etc. Apps that fail the vetting will
be rejected by Apple.
it
III. SIDE-CHANNEL ATTACK VECTORS ON IOS
In this section, we describe the threat model considered in
this paper, and new attack vectors that we have discovered to
enable OS-level side-channel attacks on iOS without procfs.
A. Threat Model
In this paper, we only consider side-channel information
leakage on the OS level. That
is, we aim to explore the
API interfaces that allow one iOS app to query information
regarding the entire OS or a particular app running on the
same device (e.g., iPhones and iPads), and the methods to
exploit the leakage to infer private information about the user
of the device. More particularly, we assume that the user
downloads a monitoring app from iOS App Store. As will be
discussed in Sec. VII, our monitoring app disguises itself as an
audio player, and registers the Audio background mode in its
Info.plist ﬁle to run in the background. No additional
permission request needs to be made at runtime. We will
show how this monitoring app can utilize some OS-level side-
channel attack vectors on iOS (to be discussed shortly) to
breach user privacy. Out of the scope are CPU cache side
channels [66], electronic magnetic side channels [24], [39],
[40], and mobile sensor based side channels [50], [52], [53],
[57]. As they explore leakage through micro-architectures,
electronic magnetic emission, or device orientation, which are
not speciﬁc to iOS.
B. New Attack Vectors
We have identiﬁed several new attack vectors on iOS
that enable cross-app information leakage. Particularly, these
vectors will allow an iOS app to learn the global usage
statistics of memory and network resources, and the existence
of ﬁles without any access permissions.
Memory resources: host_statistics64(). The global usage of
memory resources, such as the number of free memory pages
(free_count) and the cumulative number of page faults
(faults), can be queried through this API. Apps do not need
special entitlements to access host_statistics64(),
which is an interface used by iOS apps to access memory
information of the current device. We statically analyzed 7,418
iOS apps1 using a static tool based on Capstone [6], and found
that 1,230 of them include this API.
Network resources: getifaddrs(). The usage of the global
network resource can be queried through this API without spe-
cial entitlements. The getifaddrs() API returns a linked
list data structure describing each of the network interfaces
of the local system, by storing the address of the ﬁrst item
of the list in *ifap, the argument passed to the API. One
can iterate through ifap->ifap_next to enumerate all the
interfaces. For each item in this linked list, one can read