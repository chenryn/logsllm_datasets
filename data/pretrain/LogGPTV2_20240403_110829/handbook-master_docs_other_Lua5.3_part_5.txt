- 所有三个控制表达式都只被运算一次， 表达式的计算在循环开始之前。这些表达式的结果必须是数字。
- `var`，`limit`，以及 `step` 都是一些不可见的变量。 这里给它们起的名字都仅仅用于解释方便。
- 如果第三个表达式（步长）没有给出，会把步长设为` 1` 。
- 你可以用 `break` 和 `goto` 来退出 `for` 循环。
- 循环变量 `v` 是一个循环内部的局部变量； 如果你需要在循环结束后使用这个值，在退出循环前把它赋给另一个变量。
通用形式的 `for` 通过一个叫作 迭代器 的函数工作。每次迭代，迭代器函数都会被调用以产生一个新的值， 当这个值为 `nil` 时，循环停止。 通用形式的 `for` 循环的语法如下：
```lua
stat ::= for namelist in explist do block end
namelist ::= Name {',' Name}
```
这样的 `for` 语句
```lua
for var_1, ···, var_n in explist do block end
```
它等价于这样一段代码：
```lua
do
    local f, s, var = explist
    while true do
        local var_1, ···, var_n = f(s, var)
        if var_1 == nil then break end
        var = var_1
        block
    end
end
```
注意以下几点：
- `explist` 只会被计算一次。 它返回三个值， 一个 迭代器 函数， 一个 状态， 一个 迭代器的初始值。
- `f`， `s`，与 `var` 都是不可见的变量。 这里给它们起的名字都只是为了解说方便。
- 你可以使用 break 来跳出 for 循环。
- 环变量 `var_i` 对于循环来说是一个局部变量； 你不可以在 `for` 循环结束后继续使用。如果你需要保留这些值，那么就在循环跳出或结束前赋值到别的变量里去。
### 函数调用语句
为了允许使用函数的副作用， 函数调用可以被作为一个语句执行：
```lua
stat ::= functioncall
```
在这种情况下，所有的返回值都被舍弃。 函数调用在 §3.4.10 中解释。
### 局部声明
局部变量可以在语句块中任何地方声明。 声明可以包含一个初始化赋值操作：
```lua
stat ::= local namelist ['=' explist]
```
如果有初始化值的话，初始化赋值操作的语法和赋值操作一致 （参见 §3.3.3 ）。 若没有初始化值，所有的变量都被初始化为 `nil`。
一个代码块同时也是一个语句块（参见 §3.3.2）， 所以局部变量可以放在代码块中那些显式注明的语句块之外。
局部变量的可见性规则在 §3.5 中解释。
## 表达式
`Lua` 中有这些基本表达式：
```lua
exp ::= prefixexp
exp ::= nil | false | true
exp ::= Numeral
exp ::= LiteralString
exp ::= functiondef
exp ::= tableconstructor
exp ::= '...'
exp ::= exp binop exp
exp ::= unop exp
prefixexp ::= var | functioncall | '(' exp ')'
```
数字和字面串在 §3.1 中解释； 变量在 §3.2 中解释； 函数定义在 §3.4.11 中解释； 函数调用在 §3.4.10 中解释； 表的构造在 §3.4.9 中解释。 可变参数的表达式写作三个点（`...`）， 它只能在有可变参数的函数中直接使用；这些在 §3.4.11 中解释。
二元操作符包含有数学运算操作符（参见 §3.4.1）， 位操作符（参见 §3.4.2）， 比较操作符（参见 §3.4.4）， 逻辑操作符（参见 §3.4.5）， 以及连接操作符（参见 §3.4.6）。 一元操作符包括负号（参见 §3.4.1）， 按位非（参见 §3.4.2）， 逻辑非（参见 §3.4.5）， 和取长度操作符（参见 §3.4.7）。
函数调用和可变参数表达式都可以放在多重返回值中。 如果函数调用被当作一条语句（参见 §3.3.6）， 其返回值列表被调整为零个元素，即抛弃所有的返回值。 如果表达式被用于表达式列表的最后（或是唯一的）一个元素， 那么不会做任何调整（除非表达式被括号括起来）。 在其它情况下， Lua 都会把结果调整为一个元素置入表达式列表中， 即保留第一个结果而忽略之后的所有值，或是在没有结果时， 补单个 nil。
这里有一些例子：
```lua
f()                -- 调整为 0 个结果
g(f(), x)          -- f() 会被调整为一个结果
g(x, f())          -- g 收到 x 以及 f() 返回的所有结果
a,b,c = f(), x     -- f() 被调整为 1 个结果 （c 收到 nil）
a,b = ...          -- a 收到可变参数列表的第一个参数，
                   -- b 收到第二个参数（如果可变参数列表中
                   -- 没有实际的参数，a 和 b 都会收到 nil）
a,b,c = x, f()     -- f() 被调整为 2 个结果
a,b,c = f()        -- f() 被调整为 3 个结果
return f()         -- 返回 f() 的所有返回结果
return ...         -- 返回从可变参数列表中接收到的所有参数parameters
return x,y,f()     -- 返回 x, y, 以及 f() 的所有返回值
{f()}              -- 用 f() 的所有返回值创建一个列表
{...}              -- 用可变参数中的所有值创建一个列表
{f(), nil}         -- f() 被调整为一个结果
```
被括号括起来的表达式永远被当作一个值。 所以， `(f(x,y,z))` 即使 `f` 返回多个值， 这个表达式永远是一个单一值。 `((f(x,y,z))` 的值是 f 返回的第一个值。 如果 `f` 不返回值的话，那么它的值就是 `nil` 。）
### 数学运算操作符
Lua 支持下列数学运算操作符：
- `+:` 加法
- `-:` 减法
- `*:` 乘法
- `/:` 浮点除法
- `//:` 向下取整除法
- `%:` 取模
- `^:` 乘方
- `-:` 取负
除了乘方和浮点除法运算， 数学运算按如下方式工作： 如果两个操作数都是整数， 该操作以整数方式操作且结果也将是一个整数。 否则，当两个操作数都是数字或可以被转换为数字的字符串 （参见 §3.4.3）时， 操作数会被转换成两个浮点数， 操作按通常的浮点规则（一般遵循 IEEE 754 标准） 来进行，结果也是一个浮点数。
乘方和浮点除法 `/` 总是把操作数转换成浮点数进行，其结果总是浮点数。 乘方使用 ISO C 函数 `pow`， 因此它也可以接受非整数的指数。
向下取整的除法 `//` 指做一次除法，并将商圆整到靠近负无穷的一侧， 即对操作数做除法后取 `floor` 。
取模被定义成除法的余数，其商被圆整到靠近负无穷的一侧（向下取整的除法）。
对于整数数学运算的溢出问题， 这些操作采取的策略是按通常遵循的以 2 为补码的数学运算的 环绕 规则。 （换句话说，它们返回其运算的数学结果对 264 取模后的数字。）
### 位操作符
`Lua` 支持下列位操作符：
- `&:` 按位与
- `|:` 按位或
- `~:` 按位异或
- `>>:` 右移
- `: ` 大于
- `=:` 大于等于
这些操作的结果不是 `false` 就是 `true`。
等于操作 （==）先比较操作数的类型。 如果类型不同，结果就是 `false`。 否则，继续比较值。 字符串按一般的方式比较。 数字遵循二元操作的规则： 如果两个操作数都是整数， 它们按整数比较； 否则，它们先转换为浮点数，然后再做比较。
表，用户数据，以及线程都按引用比较： 只有两者引用同一个对象时才认为它们相等。 每次你创建一个新对象（一张表，一个用户数据，或一个线程）， 新对象都一定和已有且存在的对象不同。 相同引用的闭包一定相等。 有任何可察觉的差异（不同的行为，不同的定义）一定不等。
你可以通过使用 `eq` 元方法（参见 §2.4） 来改变 Lua 比较表和用户数据时的方式。
等于操作不会将字符串转换为数字，反之亦然。 即，"0"==0 结果为 false， 且 t[0] 与 t["0"] 指代着表中的不同项。
`~=` 操作完全等价于 (==) 操作的反值。
大小比较操作以以下方式进行。 如果参数都是数字， 它们按二元操作的常规进行。 否则，如果两个参数都是字符串， 它们的值按当前的区域设置来比较。 再则，Lua 就试着调用 "lt" 或是 "le" 元方法 （参见 §2.4）。 `a > b` 的比较被转译为 `b = b` 被转译为 `b  10
10 or error()       --> 10
nil or "a"          --> "a"
nil and 10          --> nil
false and error()   --> false
false and nil       --> false
false or nil        --> nil
10 and 20           --> 20
```
（在这本手册中， --> 指前面表达式的结果。）
### 字符串连接
Lua 中字符串的连接操作符写作两个点（'..'）。 如果两个操作数都是字符串或都是数字， 连接操作将以 §3.4.3 中提到的规则把其转换为字符串。 否则，会调用元方法 __concat （参见 §2.4）。
### 取长度操作符
取长度操作符写作一元前置符 #。 字符串的长度是它的字节数（就是以一个字符一个字节计算的字符串长度）。
程序可以通过 __len 元方法（参见 §2.4） 来修改对字符串类型外的任何值的取长度操作行为。
如果 __len 元方法没有给出， 表 t 的长度只在表是一个 序列 时有定义。 序列指表的正数键集等于 {1..n} ， 其中 n 是一个非负整数。 在这种情况下，n 是表的长度。 注意这样的表
     {10, 20, nil, 40}
不是一个序列，因为它有键 4 却没有键 3。 （因此，该表的正整数键集不等于 {1..n} 集合，故而就不存在 n。） 注意，一张表是否是一个序列和它的非数字键无关。
### 优先级
Lua 中操作符的优先级写在下表中，从低到高优先级排序：
```lua
 or
 and
      =    ~=    ==
 |
 ~