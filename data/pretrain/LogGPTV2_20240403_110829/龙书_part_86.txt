部性。
是存储管理器的-个重要子系统。
效捷径。
码执行时创建和销毁的对象。
和在编译时刻创建的静态数据对象。同时它还有动态的栈区和堆区，用来管理在目标代
知
示表是一个和访问链联合使用的辅助数组，它提供了一个不需要使用访问链链路的高
针。可以顺着访问链组成的链路到达正确的活动记录，从而找到期待的非局部数据，
言，我们可以通过访问链来访问栈中的非局部数据。访问链是加在各个活动记录中的
控制栈中有一个活动记录(或者说帧)。活动树的根结点位于栈底，而栈中的全部活
323
空
存
---
## Page 340
代回收器，它是拷贝回收方法的--个扩展。列车算法由 Hudson 和 Moss[9］首先提出。
拷贝算法的非递归版本。
的标记－清扫式算法。管理空闲空间的边界标记由 Knuth 在1962 年提出并在[11]中出版。
Collin[4]。基于跟踪的回收技术则最早由 McCaithy[13］提出。他描述了一个针对固定长度单元
显示表的使用、数组动态分配等概念。Johnson 和 Ritchie[10］讨论了一个调用代码序列的设计，
访问非局部数据的思想来源于 Dijkstra[5］。在 Randell 和 Russell[ 16］中更具体地描述了栈分配、
重要特征。McCarthy［14］介绍了这段历史。
言，包括C 和Java，使用词法作用域。动态作用域首先由 Lisp 语言引人，随后成为该语言的--个
演算[3]使用词法作用域。这个方法曾被用作研究程序设计语言的模型。Algol 60 及其后续语
7.10第7章参考文献
该设计支持一个过程在不同的调用中使用不同数量的参数。
增量式可达性分析由 Dijkstra 等[6]进行了详细研究。Lieberman 和 Hewitt[ 12］给出了－个世
垃圾回收的研究一直是一个活跃的研究领域，例如 Wilson[17]。引用计数技术可以追溯到
很多与栈分配相关的概念来源于 Algol60 中的块和递归。在词法作用域语言中使用显示表来
324
在数理逻辑中，作用域规则和通过替换进行参数传递最导由 Frege[8］提出。Church 的 lamda
●拷贝回收器将跟踪过程和发现空闲空间过程之间的依赖关系打破。它将存储分为两个半
·标记并压缩回收器改进了标记并清扫算法。它们把堆区中的可达对象重新定位，从而消
一个部分回收器。该回收器对较年轻对象使用世代算法，对较成熟的对象使用列车算法。
中最终只剩下垃圾，因此可以将其从该列车中删除。这两种算法可以－-起使用，创建出
的当前的第一节车厢。当一节车厢被回收时，可达对象被移动到其他车厢中，这节车厢
频繁的回收操作，因为它们的生命期通常较短。另一个算法列车算法使用固定长度的被
法是世代垃圾回收方法，它根据对象已分配时间的长短对对象分区，对新建对象进行
删除。
估计可达对象集合，达到安全工作的目标。所有的“漂浮垃圾”可以在下一轮回收中被
可达性分析，因为它可能改变之前已扫描对象中的引用。因此，增量式回收器通过超量
式回收器让垃圾回收过程和用户程序(或者说增变者)交错运行。增变者可能干扰增量式
增量式回收器。简单的基于跟踪的回收器在垃圾回收期间会停止用户程序的执行。增量
角色。
圾回收器开始工作，将可达对象拷贝到另－-个半空间，也就是B，然后对换两个半空间的
空间A 和B。首先使用某个半空间，比如说A。来满足分配请求，直到它被填满。此时垃
除存储碎片。
1
称为车厢的区域。这些车厢被组织成列车。每-一个回收步骤都处理尚存的第一辆列车中
收不可达对象。
1. Baker, H. G. Jr.,
2.0
 Cheney, C. J., "A nonrecursive list cormpacting algorithm," Comm. ACM
motion sickness,"
 real-time garbage collection without
第7章
---
## Page 341
运行时刻环境
17. Wilson, P. R., “Uniprocessor garbage collection techniques,"
15.
12.
1
10.
9.
5. Dijkstra, E. W., “Recursive programming," Numerische Math. 2 (1960),
 3. Church, A., The Calculi of Lambda Conversion, Annals of Math. Studies,
History of Programming Languages, Academic Press, New York, 1981.
McCarthy, J., “History of Lisp." See pp. 173-185 in R. L. Wexelblat (ed.)
 McCarthy, J., "Recursive functions of symbolic expressions and their com-
New York, 1964.
Randell, B. and. L. J. Russell, Algol 60 Implementation, Academic Press,
putation by machine," Comm. ACM 3:4 (Apr., 1960), pp. 184-195.
 Algorithms, Addison-Wesley, Boston MA, 1968.
NJ, 1981.
Johnson, S. C. and D. M. Ritchie, "The C language calling sequence,"
Hudson, R. L. and J. E. B. Moss, “Incremental Collection of Mature
to Godel, Harvard Univ. Press, Cambridge MA, 1967.
Frege, G., “Begrifsschrift, a formula language, modeled upon that of
arithmetic, for pure thought,"
M. Steffens,
Dijkstra, E. W., L. Lamport, A. J. Martin, C. S. Scholten, and E. F.
Pp. 312-318.
No. 6, Princeton University Press, Princeton, N. J., 1941.
ftp://ftp.cs.utexas.edu/pub/garbage/bigsurv.ps
(1879).
, Volume 1: Fundamental
325
---
## Page 342
接下来的8.7节中将讨论窥孔优化技术。
长时间地保留在寄存器中。这种代码生成器的输出可以很容易地使用窥孔优化技术进行优化。
层次上寻找公共子表达式，然后相应地把算术运算替换为更简单的拷贝运算。
化理论，但这种转换已经是代码优化的初步形式。一个有用的局部转换的例子是在中间代码的
换得到的基本块出发可以生成更加高效的代码。虽然要到第9章才开始考虑更加深人的代码优
IR划分成基本块是8.4节的主题。接下来介绍了针对基本块的一些简单的局部转换方法。从转
的实现方法，并说明如何把IR中的名字转换成为目标代码中的地址。
标代码，以支持常见源语言中所包含的抽象机制。在8.3节，我们概述了静态和栈式数据区分配
论了复杂的现代机器的代码生成问题，这些现代机器支持在单一指令中的大量并行性。
要性将在8.1节中概述。指令选择考虑的问题是选择适当的目标机指令来实现IR语句。寄存器
后端(back end)。它们可能在生成目标程序之前对 IR 作多趟处理。代码优化将在第9 章中详细
射为另一个可用于产生高效代码的 IR。编译器的代码优化和代码生成步骤通常被称为编译器的
使用那些能够产生良好但不一定最优的代码的启发性技术。幸运的是，启发性技术已经非常成熟，
码生成中碰到的很多子问题(比如寄存器分配)都具有难以处理的计算复杂性。在实践中，我们必须
高效运行。
的质量。也就是说，它必须有效地利用目标机器上的可用资源。此外，代码生成器本身必须能够
间表示(IR)和相关的符号表信息作为输人，输出语义等价的目标程序。
简单寄存器机器的目标语言指令序列。这些算法将使用8.2 节中的机器模型来解释。第10 章讨
安排指令的执行。
分配和指派考虑的问题是把哪个值放在哪个寄存器中。指令排序考虑的问题是按照什么顺序来
一个精心设计的代码生成器所产生的代码要比那些由简单的生成器生成的代码快好几倍。
本章给出了一些和代码生成相关的算法，代码生成器可以使用这些算法把输入的 IR 翻译成
论。不论代码生成之前有没有优化步骤，都可以使用本章所讨论的技术。
8.6节给出了一个简单的代码生成算法。它依次为每个语句生成代码，并把运算分量尽可能
很多代码生成器把IR指令分成“基本块”，每个基本块由一组总是一-起执行的指令组成。
在讨论了代码生成器设计中的众多难题之后，我们给出了一-个编译器需要生成什么样的目
代码生成器有三个主要任务：指令选择、寄存器分配和指派、以及指令排序。这些任务的重
要产生高效目标程序的编译器都会在代码生成之前包含一个优化步骤。优化器把一个IR 映
其余的部分将研究指令选择和寄存器分配。
具有挑战性的是，从数学上讲，为给定源程序生成一个最优的目标程序是不可判定问题，在代
对代码生成器的要求是很严格的。目标程序必须保持源程序的语义含义，还必须具有很高
我们的编译器模型的最后一个步骤是代码生成器。如图8-1所示，它以编译器前端生成的中
源程序一
第8章代码生成
前端
图8-1代码生成器的位置
—
---
## Page 343
并立即执行。程序可以很快地进行编译和执行。
上的本地硬件指令集。另一个提高 Java 程序性能的方法是建立-个编译器，把 Java 程序直接编
码的软件解释器。字节码是由 Java 编译器生成的一种中间语言。这个解释器提供了跨平台的软
构。相反，CISC 机通常具有较少寄存器、两地址指令、多种寻址方式、多种类型的寄存器、可变
的极大影响。最常见的目标机体系结构是 RISC(精简指令集计算机）、CISC(复杂指令集计算机)
8.1.2目标程序
完成，而类型转换运算已经被插人到必要的地方。因此，代码生成器可以在工作过程中假设它白
形式，因此在IR中出现的名字的值可以用能被目标机直接处理的量来表示。这些量可以是整数，
式；也包括诸如字节代码和堆栈机代码的虚拟机表示方式；包括诸如后缀表示的线性表示方式;
些信息用来确定 IR 中的名字所指的数据对象的运行时刻地址。
8.1.1代码生成器的输入
译成目标机器指令，彻底绕过字节码。
创造了即时(Just-In-Time，JIT)Java 编译器。这些即时编译器在运行时刻把字节码翻译成目标机
件兼容性。这是Java 成功的一个重要因素。
多，并且需要太多的交换和拷贝操作，所以基于堆栈的机器几乎已经消失了。
输人已经排除了这些错误。
其他的中间表示形式。
设计得易于实现、测试和维护。
会碰到很多种特殊情况。在优先考虑正确性的情况下，另-一个重要的设计目标是把代码生成器
择、寄存器分配和指派以及指令排序等任务会在几乎所有的代码生成器设计中碰到。
8. 1
完成的。为了获得高性能，栈顶元素通常保存在寄存器中。因为人们觉得堆栈组织的限制太
解释执行会引起很高的性能损失，有时可能达到10 倍的数量级。为了克服这个问题，人们
度的指令和具有副作用的指令。
基于堆栈的结构。
点数等。我们还假设所有的语法和静态语义错误都已经被检测出来，必要的类型检查都已：
法来表示的。这些表示方法包括：三地址代码、树和DAG。然而，我们讨论的技术也可以用
包括诸如语法树和 DAG 的图形表示方式。本章中的多个算法都是根据第6章中所考虑的表
代码生成器的最重要的标准是生成正确的代码。正确性问题非常突出的原因是代码生成器
代码生成
输出一个使用绝对地址的机器语言程序的优点是程序可以放在内存中的某个固定位置上，
但是，基于堆栈的体系结构随着 Java 虚拟机( JVM）的出现又复活了。JVM 是一个 Java 字
在本章中，我们假设前端已经扫描、分析了源程序，并把它转换成为相对低层次的中间表示
IR 的中间表示形式的选择有很多，包括诸如四元式、三元式、间接三元式等三地址表示方
代码生成器的输人是由前端生成的源程序的中间表示形式以及符号表中的信息组成的。
输出可重定位的机器语言程序(通常称为目标模块，object module)可以使各个子程序能够被
在基于栈的机器中，运算是通过把运算分量压人一个栈，然后再对栈顶的运算分量进行运算
虽然代码生成器设计依赖于中间表示形式、目标语言和运行时刻系统的特定细节，但指令选
代码生成器设计中的问题
327
护
经
H
1K
这
---
## Page 344
使用，那么第三个语句也是冗余的。
这里的第四个语句是兀余的，因为它加载了--个刚刚保存到内存的值。并且如果a以后不再被
会被翻译成
是静态分配的)可以被翻译成如下的代码序列：
这个构造生成什么样的目标代码。比如，每一个形如x=+z 的三地址语句(其中x、和z 都
指令选择是很简单的。对于每一种三地址语句，我们可以生成一个代码骨架。此骨架定义了对
个例外都需要进行特别处理。比如，在某些机器上，浮点数运算使用单独的寄存器完成。
性是两个很重要的因素。如果目标机没有以统一的方式支持每种数据类型，那么总体规则的每
加高效的代码序列。
但是，这种逐个语句生成代码的方式通常会产生质量不佳的代码。这些代码需要进一步优化。
性由如下的因素决定：
8.1.3指令选择
息计算出来，代码生成器就可以为源程序中的名字生成可重定位地址或绝对地址。这和生成符
号
了一些类CISC的寻址方式。这样我们就可以讨论CISC 机器的代码生成技术了。为了增加可读
编器的宏机制来帮助生成代码。这么做的代价是代码生成之后还需要增加一个汇编步骤。
分开编译的程序模块链接起来。
程序。如果目标机没有自动处理重定位，编译器就必须向加载器提供明确的重定位信息，以便把
很多的灵活性。我们可以把子程序分开编译，并能够从一-个目标模块中调用其他已经编译好的
要生成可重定位的目标模块，我们就必须为链接和加载付出代价。但是这样做可以使我们得到
分别编译。
果IR中反映了相关计算机的某些低层次细节，那么代码生成器就可以使用这些信息来生成更
地址一样，都是很简单的事情。
，我们把汇编代码用作目标语言。只要变量地址可以通过偏移量和存放于符号表中的其他信
指令速度和机器的特有用法是另外一些重要因素。如果我们不考虑目标程序的效率，那么
目标机指令集本身的特性对指令选择的难度有很大的影响。比如，指令集的统一性和完整
代码生成器必须把 IR 程序映射成为可以在目标机上运行的代码序列。完成这个映射的复杂