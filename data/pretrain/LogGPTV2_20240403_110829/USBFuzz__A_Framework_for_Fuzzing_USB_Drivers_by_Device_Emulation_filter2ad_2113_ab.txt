(FaceDancer [13]) to inject random hardware input into the
host USB stack. Though easily portable to other OSes, they
are dumb fuzzers and cannot leverage coverage information
to guide their input mutation, rendering them inefﬁcient.
The recent usb-fuzzer [14] (an extension of the kernel
fuzzer syzkaller [16]) injects fuzz inputs into the IO stack
of the Linux kernel using a custom software-implemented
host controller combined with a coverage-guided fuzzing tech-
nique. The adoption of coverage-guided fuzzing has led to
the discovery of many bugs in the USB stack of the Linux
kernel [14]. However, usb-fuzzer is tightly coupled with the
Linux kernel, making it hard to port to other OSes.
All existing USB fuzzers focus exclusively on the probe
routines of drivers, not supporting fuzzing of the remaining
function routines. The status-quo of existing USB fuzzers
motivates us to build a ﬂexible and modular USB fuzzing
framework that is portable to different environments and eas-
ily customizable to apply coverage-guided fuzzing or dumb
fuzzing (in kernels where coverage collection is not yet sup-
ported), and allows fuzzing a broad range of probe routines
or focusing on the function routines of a speciﬁc driver.
3 Threat Model
Our threat model consists of an adversary that attacks a com-
puter system through the USB interface, leveraging a software
vulnerability in the host software stack to achieve goals such
as privilege escalation, code execution, or denial of service.
Attacks are launched by sending prepared byte sequences
over the USB bus, either attaching a malicious USB device to
a physical USB interface or hijacking a connection to a net-
worked USB interface (e.g., in USBIP [46] or usbredir [43]).
4 USBFuzz Design
Device drivers handle inputs both from the device side and
from the kernel. The kernel is generally trusted but the device
may provide malicious inputs. The goal of USBFuzz is to ﬁnd
bugs in USB drivers by repeatedly testing them using random
inputs generated by our fuzzer, instead of the input read from
the device side. The key challenge is how to feed the fuzzer
generated inputs to the driver code. Before presenting our
approach, we discuss the existing approaches along with their
respective drawbacks.
Approach I: using dedicated hardware. A straight-
forward solution is to use dedicated hardware which re-
turns customizable data to drivers when requested. For USB
devices, FaceDancer [13] is readily available and used by
umap2 [18]. This approach follows the data paths in real hard-
ware and thus covers the complete code paths and generates
reproducible inputs. However, there are several drawbacks in
such a hardware-based approach. First, dedicated hardware
parts incur hardware costs. While $85 for a single FaceDancer
2562    29th USENIX Security Symposium
USENIX Association
is not prohibitively expensive, fuzzing campaigns often run
on 10s to 1000s of cores, resulting in substantial hardware
cost. Similarly, connecting physical devices to fuzzing clus-
ters in a server center results in additional complexity. Second,
hardware-based approaches do not scale as one device can
only fuzz one target at a time. Hardware costs and lack of
scalability together render this approach expensive. Finally,
this approach is hard to automate as hardware operations (e.g.,
attaching and detaching a device to and from a target system)
are required for each test iteration.
Approach II: data injection in IO stack. This approach
modiﬁes the kernel to inject fuzz data to drivers at a certain
layer of the IO stack. For example, usb-fuzzer in syzkaller [16]
injects fuzz data into the USB stack through a software host
controller (dummy hcd), replacing the driver for the hardware
host controller. PeriScope [50] injects fuzzer generated input
to drivers by modifying MMIO and DMA interfaces.
Compared to hardware-based approaches, this approach
is cheap, scalable, and can be automated to accommodate
fuzzing. However, this solution struggles with portability as
its implementation is tightly coupled to a given kernel layer
(and sometimes kernel version). In addition, it requires deep
understanding of the hardware speciﬁcation and its implemen-
tation in the kernel. As input is injected at a speciﬁc layer of
the IO stack, it cannot test code paths end-to-end, and thus
may miss bugs in untested code paths (as we show in § 6.4).
Design Goals. After evaluating the above approaches, we
present the following design goals:
G1. Low Cost: The solution should be cost-effective and
hardware-independent.
G2. Portability: The solution should be portable to test other
OS and platforms, avoiding deep coupling with a speciﬁc
kernel version.
G3. Minimal Required Knowledge: The interaction be-
tween the driver, the USB device, and the rest of the
system is complex and may be different from device to
device. The solution should require minimal knowledge
of the USB standard and the device.
USBFuzz’s approach. At a high-level, USBFuzz lever-
ages an emulated USB device to feed random input to device
drivers. The target kernel (hosting the tested device drivers)
runs in a virtual machine (VM) and the emulated USB de-
vice is integrated into the VM. The hypervisor in the VM
transparently sends read/write requests from the drivers of the
guest kernel to the emulated device (and not to real hardware)
without any changes to the USB system in the target kernel.
The emulated USB device, on the other hand, responds to
kernel IO requests using the fuzzer-generated input, instead
of following the speciﬁcation of a device.
As a software-based solution, an emulated device does not
incur any hardware cost and is highly scalable, as we can
Figure 2: Overview of USBFuzz
easily run multiple instances of a virtual machine to fuzz
multiple instances of a target kernel in parallel, satisfying
G1—low cost. Because our solution implements an emulated
hardware device, it is decoupled from a speciﬁc kernel or ver-
sion. One implementation of the emulated device can be used
to provide random input to device drivers running on different
kernels on different platforms, satisfying G2—portability. As
this solution works at the device level, no knowledge of the
software layers in the kernel is required. In addition, based
on mature emulators such as QEMU, a developer only needs
to understand the data communication protocol, satisfying
G3—minimal required knowledge.
Based on these goals, we designed USBFuzz, a modular
framework to fuzz USB device drivers. Figure 2 illustrates the
overall design of USBFuzz. The following list summarizes
high level functionalities of its main components.
Fuzzer: The fuzzer runs as a userspace process on the host
OS. This component performs the following tasks: (i)
mutating the data fed to device drivers in the target ker-
nel; and (ii) monitoring and controlling test execution.
Guest System: The guest system is a virtual machine that
runs a target kernel containing the device drivers to test.
It provides support for executing the guest code, emulat-
ing the fuzzing device as well as the supporting commu-
nication device.
Target Kernel: The target kernel contains the code (impor-
tantly, device drivers) and runs inside the guest system.
The drivers in the kernel are tested when they process
the data read from the emulated fuzzing device.
Fuzzing Device: The fuzzing device is an emulated USB
device in the guest system. It is connected through the
emulated USB interface to the guest system. However,
instead of providing data according to the hardware spec-
iﬁcation, it forwards the fuzzer-generated data to the
USENIX Association
29th USENIX Security Symposium    2563
FuzzerKernel Virtual Machine (KVM)Host KernelVirtualized HardwareFuzzing DeviceComm.DeviceTarget Kernel(CPU, Memory etc)User Mode AgentGuest SystemFuzzer Generated InputTest Control & Exec Feedbackhost when the target kernel performs IO operations on it
(shown in § 4.1).
Communication Device: The communication device is an
emulated device in the guest system intended to facilitate
communication between the guest system and the fuzzer
component. It shares a memory region and provides
synchronization channels between the fuzzer component
and the guest system. The shared memory region also
shares coverage information in coverage-guided fuzzing
(shown in § 4.2).
User Mode Agent: This userspace program runs as a dae-
mon process in the guest system. It monitors the execu-
tion of tests (shown in § 4.3). Optionally, it can be cus-
tomized to perform additional operations on the fuzzing
device to trigger function routines of drivers during fo-
cused fuzzing (demonstrated in § 6.4).
The modular design of USBFuzz, in combination with
the emulated fuzzing device, allows fuzzing USB device
drivers on different OSes and applying different fuzzing tech-
niques with ﬂexible conﬁguration based on the target system,
e.g., coverage-guided fuzzing to leverage feedback, or dumb
fuzzing without any feedback to explore certain provided
USB traces (dumb fuzzing is useful when coverage infor-
mation is not available). In this work, we applied coverage-
guided fuzzing to the Linux kernel (discussed in § 4.4), and
dumb fuzzing to FreeBSD, MacOS, and Windows using cross-
pollination seeded by inputs generated from fuzzing Linux.
4.1 Providing Fuzzed Hardware Input
Our input generation component extends AFL, one of the
most popular mutational coverage-guided fuzzing engines.
AFL [72] uses a ﬁle to communicate the fuzzer generated
input with the target program. The fuzzing device responds to
read requests from device drivers with the contents of the ﬁle.
As mentioned in § 2.1, when a USB device is attached
to a computer, the USB driver framework reads the device
descriptors and conﬁguration descriptors and uses the appro-
priate driver to interact with it. However, depending on the
implementation of the USB stack, the device descriptor and
conﬁguration descriptor may be read multiple times (e.g., the
Linux kernel reads the device descriptor both before and after
setting the address of the USB device). To improve fuzzing
efﬁciency and considering that throughput is relatively low
compared to simple user space fuzzing (see § 6.3), these two
requests are handled separately: they are loaded (either from
a separate ﬁle or the fuzzer generated ﬁle) once when the
fuzzing device is initialized and our framework responds with
the same descriptors when requested. All other requests are
served with bytes from the current position of the fuzzer gen-
erated ﬁle until no data is available, in which case, the device
responds with no data. Note that as we are fuzzing the device
drivers using data read from the device side, write operations
to the device are ignored.
This design allows either broad fuzzing or focused fuzzing.
By allowing the fuzzer to mutate the device and conﬁguration
descriptors (loading them from the fuzzer generated ﬁle), we
can fuzz the common USB driver framework and drivers for
a wide range of devices (broad fuzzing); by ﬁxing the device
and conﬁguration descriptor to some speciﬁc device or class
of devices (loading them from a separate conﬁguration ﬁle),
we can focus on fuzzing of a single driver (focused fuzzing).
This ﬂexibility enables different scenarios, e.g., it allows bug
hunting in the USB driver framework and all deployed USB
device drivers, or it can be used to test the driver of a speciﬁc
USB device during the development phase. We demonstrate
focused fuzzing on a USB webcam driver in § 6.4.
4.2 Fuzzer – Guest System Communication
Like all existing fuzzers, the fuzzer component in USBFuzz
needs to communicate with the target code to exert control
over tests, reap coverage information, and so forth. As shown
in Figure 2, the fuzzer component runs outside the guest
system and cannot gain information about the target system
directly. The communication device is intended to facilitate
the communication between the fuzzer and the guest system.
In a coverage-guided fuzzer, coverage information needs
to be passed from the guest system to the fuzzer. To avoid
repeated memory copy operations, we map the bitmap, which
is a memory area in the fuzzer process, to the guest system
using a QEMU communication device. After the guest system
is fully initialized, the bitmap is mapped to the virtual memory
space of the target kernel, to which the instrumented code
in the target kernel can write the coverage information. As
it is also a shared memory area in the fuzzer process, the
coverage information is immediately accessible by the fuzzer
component, avoiding memory copy operations.
In addition, the fuzzer component needs to synchronize
with the user mode agent running in the guest system
(see § 4.3) in each fuzz test iteration. To avoid heavy-weight
IPC operations, a control channel is added to the communica-
tion device to facilitate the synchronization between the user
mode agent and the fuzzer component.
4.3 Test Execution and Monitoring
Existing kernel fuzzers execute tests using the process ab-
straction of the target kernel. They follow an iterative pattern
where, for each test, a process is created, executed, monitored,
and the fuzzer then waits for the termination of the process to
detect the end of the test. In USBFuzz, as tests are performed
using the fuzzing device, in each iteration, a test starts with
virtually attaching the (emulated) fuzzing device to the guest
system. The kernel then receives a request for the new USB
device that is handled by the low-end part of the kernel device
2564    29th USENIX Security Symposium
USENIX Association
management which loads the necessary drivers and initializes
the device state. However, without support from the kernel
through, e.g., process abstractions similar to the exit system
call, it is challenging to monitor the execution status (e.g.,
whether a kernel bug is triggered or not) of the kernel during
its interaction with the device.
In USBFuzz, we follow an empirical approach to monitor
the execution of a test by the kernel: by checking the kernel’s
logged messages. For example, when a USB device is attached
to the guest system, if the kernel is able to handle the inputs
from the device, the kernel will log messages containing a set
of keywords indicating the success or failure of the interaction
with the device. Otherwise, if the kernel cannot handle the
inputs from the device, the kernel will freeze or indicate that a
bug was triggered. The USBFuzz user mode agent component
monitors the execution status of a test by scanning kernel
logs from inside the virtualized target system, synchronizing
its status with the fuzzer component so that it records bug
triggering inputs and continues to the next iteration.
To avoid repeatedly booting the guest system for each iter-
ation, USBFuzz provides a persistent fuzzing technique, simi-
lar to other kernel fuzzers (syzkaller [16], TriforceAFL [19],
trinity [22], or kAFL [48]), where a running target kernel is
reused for multiple tests until it freezes, in which case, the
fuzzer automatically restarts the kernel.
4.4 Coverage-Guided Fuzzing on Linux
So far, the USBFuzz framework provides basic support for
fuzzing USB device drivers on different OSes. However, to
enable coverage-guided fuzzing, the system must collect ex-
ecution coverage. A coverage-guided fuzzer keeps track of
code coverage exercised by test inputs and mutates interesting
inputs which trigger new code paths.
Coverage collection is challenging for driver code in ker-
nel space. On one hand, inputs from the device side may
trigger code executions in different contexts, because drivers
may contain code running in interrupts and kernel threads.
On the other hand, due to the kernel performing multitask-
ing, code executed in a single thread may be preempted by
other unrelated code execution triggered by timer interrupts
or task scheduling. To the best of our knowledge, the Linux
kernel only supports coverage collection by means of static
instrumentation through kcov [67]. However, kcov coverage
collection is limited to a single process, ignoring interrupt
contexts and kernel threads. Extending the static instrumenta-
tion of kcov, we devised an AFL-style edge coverage scheme
to collect coverage in USB device drivers of the Linux kernel.
To collect coverage across different contexts, (i) the previous
executed block is saved in the context of each thread of code
execution (interrupts or kernel threads), so that edge transi-
tions are not mangled by preempted ﬂows of code execution;
and (ii) instrumentation is limited to related code: USB core,
host controller drivers, and USB drivers.
5
Implementation Details
The implementation of the USBFuzz framework extends sev-
eral open source components including QEMU [4, 57] (where
we implement the communication device and the emulated
USB device), AFL [72] (which we modify to target USB
devices by collecting coverage information from our virtual-
ized kernel and interacting with our User Mode Agent), and
kcov [67] (which we extend to track edge coverage across the
full USB stack, including interrupt contexts). We implement
the user mode agent from scratch. The workﬂow of the whole
system, illustrating the interaction among the components, is
presented in Figure 3. The implementation details of individ-
ual components are discussed in the following sections.
When the fuzzer starts, it allocates a memory area for the
bitmap and exports it as a shared memory region, with which
the communication device is initialized as QEMU starts. After
the target kernel is booted, the user mode agent runs and
notiﬁes the fuzzer to start testing.
In each iteration of the fuzzing loop, the fuzzer starts a test
by virtually attaching the fuzzing device to the target system.
With the attachment of the fuzzing device, the kernel starts its
interaction with the device and loads appropriate USB drivers
for it. The loaded USB driver is tested with the fuzz input
as it interacts with the fuzzing device. The user mode agent
monitors execution by scanning the kernel log and notiﬁes
the fuzzer of the result of the test. The fuzzer completes the
test by virtually detaching the fuzzing device from the target
system.
communication device
5.1 Communication Device
The
in USBFuzz facilitates
lightweight communication between the fuzzer component
and the target system, which includes sharing the bitmap
area and synchronization between the user mode agent
and the fuzzer component. The implementation of the
communication device is built on the IVSHMEM (Inter-VM
shared memory) device [56], which is an emulated PCI
device in QEMU. The shared memory region from the fuzzer
component is exported to the guest system as a memory area
in IVSHMEM device and mapped to the virtual memory
Figure 3: Workﬂow of USBFuzz.
USENIX Association
29th USENIX Security Symposium    2565
FuzzerQEMUTarget KernelUser Mode AgentSetup shared memorystartbootexecutesystem readystart testirqIO operationend of teststop testFuzzing loopspace of the guest system. One register (BAR2, the Base
Address Register for a memory or IO space) is used for the
communication channel between the fuzzer component and
the user mode agent.
5.2 Fuzzer
The fuzzer uses two pipes to communicate with the VM: a
control pipe and a status pipe. The fuzzer starts a test by
sending a message to the VM via the control pipe, and it
receives execution status information from the VM via the
status pipe.
On the VM side, two callbacks are registered for the pur-
pose of interfacing with the fuzzer component. One callback
attaches a new instance of the fuzzing device to the hyper-
visor with the fuzzer-generated input when a new message