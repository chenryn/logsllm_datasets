F
F
4) Assigning Symbolic Values
UChecker introduces symbolic values to the heap graph
through three sources including i) uninitialized variables,
ii) built-in functions, and iii) PHP superglobal variables.
Some variables are uninitialized since UChecker conducts
symbolic execution on a fraction of PHP programs identiﬁed
by locality analysis. UChecker also performs light-weight
type inference to assign a type to a symbolic value based
on its associated operator or built-in function.
UChecker handles $_FILES as a special case since its
587
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:57:41 UTC from IEEE Xplore.  Restrictions apply. 
Operation
Constant c
Symbolc s
String concat
String replace
String to int
Index of string
String length
PHP
tr l(c : t)
tr l(s : t)
tr l((“.",e1 : t1,e2 : t2))
tr l(“str _r epl ace",e1 : t1,e2 : t2,e3 : t3))
tr l((
tr l((“str pos",e1 : t1,e2 : t2))
tr l(“str len",e : t)
i nt val",e : t))
(cid:7)(cid:7)
Logical Not
tr l(“!",e : t)
Logical AND
tr l(“And",e1 : t1,e2 : t2)
Logical Equal
tr l(“ == ",e1 : t1,e2 : t2)
Array Check
tr l((“i n_ar r ay",needle,hay st ack : ar r ay))
Substring
Substring
Tail Element
tr l((“substr ", str : t1, st ar t : t2))
tr l((“substr ", str : t1, st ar t : t2,len : t3))
tr l((“end",hay st ack : ar r ay))
File Name
tr l((“basename",e : str i ng ))
Z3
c
s (a symbol value in Z3 with type t)
(str.++ tr l(e1 : t1) tr l(e2 : t2)) where t1 = t2 = str i ng
(str.replace tr l(e3 : t3) tr l(e1 : t1) tr l(e2 : t2)), where t1 = t2 = t3 = str i ng
(str.to.int tr l(e : t)) where t = str i ng
(str.indexof tr l(e1 : t1) tr l(e2 : t2)) where t1 = t2 = str i ng
(str.len tr l(e : t)) where t = str i ng
(not tr l(e : t)) if e:boolean
(not (= tr l(e : i nt) 0) if e:int
(= (str.len tr l(e : str i ng )) 0) if e:string
(and tr l(e1 : t1) tr l(e2 : t2)) if t1 = t2 = boolean
(and (not (= tr l(e1 : t1) 0)) tr l(e2 : t2)) if t1 = i nt and t2 = boolean
(and (> (str.len tr l(e1 : t1)) 0) tr l(e2 : t2)) if t1 = str i ng and t2 = boolean
(and (> (str.len tr l(e1 : t1)) 0) (not (= tr l(e2 : t2) 0))) if t1 = str i ng and t2 = i nt
(= tr l(e1 : t1) tr l(e2 : t2)) if t1 = t2 = boolean
(= tr l(e1 : t1) tr l(e2 : t2)) if t1 = t2 = i nteg er
(= tr l(e1 : t1) tr l(e2 : t2)) if t1 = t2 = str i ng
(= tr l(e1 : t1) (> tr l(e2 : t2) 0)) if t1 = boolean and t2 = i nteg er
(= tr l(e1 : t1) (> (str.len tr l(e2 : t2)) 0)) if t1 = boolean and t2 = str i ng
(= tr l(e1 : t1) (str.to.int tr l(e2 : t2)) ) if t1 = i nteg er and t2 = str i ng
(or tr l(“ = ",needle,e1 : t1),..., tr l(“ = ",needle,en : tn ) if hayst ack is recognized
as {e1 : t1,...,e n : tn };
a symbol value in Z3 with the type of string otherwise.
(str.substr tr l(str ), tr l(st ar t), (str.len tr l(str ))) where t1 = t2 = str i ng
(str.substr tr l(str ), tr l(st ar t), tr l(len)) where t1 = t2 = str i ng and t3 = i nt
tr l(en : tn ) if hayst ack is recognized as {e1 : t1,...,e n : tn };
a symbol value in Z3 with the type of string otherwise.
the ﬁlename if e can be recognized as an absolute ﬁle path;
a symbol value in Z3 with the type of string otherwise.
TABLE II: Examples of rules to translate PHP-based constraints into Z3-based constraints.
reachability constraint, respectively. For the s-expression
of ed st , we will evaluate whether it is possible to ﬁnd
assignments for symbolic values so that it ends up with
the string “.php”; for that of the reachability constraint, we
will evaluate the feasibility to ﬁnd assignments for symbolic
values to make it as true. We leverage Z3 with string
extensions [14] to verify the last two constraints.
1 $path_array = wp_upload_dir () ;
2 $filename = $_FILES [ ’ upload_file ’][ ’ name ’];
3 $pathAndName = $path_array [ ’ path ’] ."/"
4 if ( strlen ( $filename ) > 5) {
5
move_uploaded_file ( $_FILES [" upload_file " ][ ’ tmp_name ’],
. $filename ;
$pathAndName ) ;}
Listing 4: An example PHP ﬁle with unrestricted ﬁle upload
vulnerability
4
a
Listing
presents
vulnerable
a pre-structured array
example.
wp_upload_dir() returns a symbolic value denoted as
to which the variable $path_array maps. Since
sdi r ,
_FILES is modeled as
(see
Section III-B4), $_FILES[’upload_ﬁle’][’tmp_name’] returns
(i.e., (“.", sname, sext )), which is the concatenation of two
symbolic values for the name and the extension of a
ﬁle,
respectively. Since $path_array itself maps to an
undeﬁned symbolic value sdi r , $path_array[’path’] returns
spath. $pathAndName
a symbolic value denoted as
$path_array[’path’],
maps
concatenation
of
“/”,
is
(“.", spath, (“.", “/", (“.", sname, sext ))).
the
_FILES[’upload_ﬁle’][’tmp_name’], which
to
and
For constraint-1, esr c is $_FILES[’upload_ﬁle’][’tmp_name’],
which is directly tainted by $_FILES. Therefore, constraint-
1 is satisﬁed. For constraint-2 and constraint-3, we can
use the heap graph to derive the s-expression of ed st ,
denoted as sed st , and that for the reachability, denoted as
ser eachabi l i t y , which are listed as follows:
• sed st = (“.", spath, (“.", “/", (“.", sname, sext ))), where
“.” is the concatenation operator in PHP.
588
• ser eachabi l i t y = (>,
where “>” and “strlen” are operators in PHP.
(str len,
sname,
(“.",
sext )), 5),
D. Z3-Oriented Constraint Translation
Despite the fact that both sed st and ser eachabi l i t y are
in s-expressions, their semantics, however, are based on
PHP rather than Z3, forming a semantic gap. We design
a translation function, namely tr l(), to recursively translate
PHP-based s-expressions into Z3-based ones. With the ap-
plication of tr l(), two constraints can be expressed as below,
where “str.sufﬁxof” is Z3’s operator for sufﬁx checking.
• Constraint-2: (str.suffixof ".php" tr l(sed st ))
• Constraint-3: tr l(ser eachabi l i t y )
tr l() implements a set of translation rules, where the
core translation rules are presented in Table II. These
translation rules focus on solving four problems including
i) different operation names, ii) order of parameters and
missing parameters,
iii) dynamic typing of PHP, and iv)
missing operations in Z3. One example is the logical “And”
operator in PHP, which works for different types such as
string, integer, and boolean. However, the “and” operator
in Z3 can only handle boolean variables. Therefore, we
translate the “And” operation in PHP into a set of “and”
operations depending on the type of the variable.
It is worth noting that exceptions might be observed
when translating s-expressions in PHP. On the one hand, the
type matching might not be satisﬁed. On the other hand,
internal structures of certain expected inputs are invisible to
UChecker. In this case, tr l() returns a symbolic value with
the expected type of the operator. For example, if “/” in an
expression cannot be determined in e, tr l((“basename",e :
str i ng )) will return a new symbol value with the string type.
Using these translation rules, UChecker
translates
constraints-2 and constraint-3 in PHP for the example in
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:57:41 UTC from IEEE Xplore.  Restrictions apply. 
Listing 4 into those in Z3 as listed below:
• Constraint-2: (str.suffixof ".php" (str.++ spath
(str.++ ‘‘/" (str.++, sname, sext ))))
• Constraint-3: (> (str.len (str.++ sname sext )) 5)
IV. EVALUATION
We have implemented UChecker with approximately 30K
LoC in PHP. UChecker leverages PHP-Parser [15] to parse
source code for AST generation and Z3 [14] as the SMT
solver. UChecker is deployed on a Windows-10 workstation
with Intel i7-5500U CPU and 16GB of memory. PHP 7 is
used as the runtime environment.
A. Ground-Truth-Available Experiments
We have collected totally 13 publicly-reported vulnera-
ble PHP applications. The vulnerable samples include 11
WordPress plugins [16], a Joomla extension (i.e., Joomla-
Bible-study 9.1.1 [17]), and a Drupal module (i.e., Avatar
Uploader 6.x-1.2 [18]). We have manually identiﬁed 28
vulnerability-free WordPress plugins that supports ﬁle up-
load. We have manually audited or tested the code to
assure they are free from unrestricted ﬁle upload vulnera-
bilities. It is practically challenging to collect source code of
publicly-available, real-world vulnerable applications; iden-
tifying and verifying vulnerability-free applications are also
highly labor-intensive considering the diversity of plugins,
their highly-customized interfaces, and a large number of
functions. This dataset represents our current best-effort
practices. The second and third columns of the top 13 rows
in Table III present the names and LoC of all 13 vulnerable
applications. For brevity, we only present 2 out of 28 non-
vulnerable samples. Again, it is worth noting that all 28
non-vulnerable plugins we used for false-positive evaluation
support ﬁle uploading.
Performance: UChecker starts with locality analysis to re-
duce lines of code for symbolic execution. The third column
of Table III presents LoC of each application and the fourth
column shows the percentage of LoC that are actually
symbolically executed. Experiments have shown that the
locality analysis drastically reduced the LoC, ranging from
67% (see Avatar Uploader) to 99.7% (see WP Marketplace).
For example, “WP Market place” has 10,850 LoC while only
32 LoC are symbolically executed.
UChecker then performs AST-based symbolic execution
for the selected fraction of code. The ﬁfth column of
Table III shows the number of paths generated by symbolic
execution. Despite the small LoC for symbolic execution,
certain applications still yield a large number of paths.
For example, the analysis of WP-Powerplaygallery, Simple
Ad Manager, and Avatar Uploader leads to 1,224, 1,476,
and 9,216 paths, respectively. UChecker also generates a
considerably large number of objects in the heap graph.
However, thanks to the design of heap graph that enables
the sharing of objects across different environments, the
average number of objects for each path is small for the
vast majority of evaluated applications. Speciﬁcally, except
“Cimy User Extra Fields”, each path has less than 100
objects on average. Such design also results in the small
memory footprint of UChecker, where all applications result
in less than 65 MB of maximal memory consumption (see
the “memory” column in Table III). The analysis of each
application is completed within 60 seconds as shown in the
“Time” column. All these measures imply that UChecker can
operate efﬁciently in a typical runtime environment.
Detection Results: UChecker has detected 12 out of 13
vulnerable applications as shown in the last column of
Table III. It introduced one false negative (i.e., “Cimy User
Extra Fields”). A large number of branches in the “Cimy”
plugin resulted in a massive number of paths and objects
(i.e., around 248K paths and 278K objects) during the
symbolic execution, which eventually exceeded the memory
capacity. UChecker has caused 2 false positives out of 28
vulnerability-free applications.
False Positive Analysis: Two false positives are Event
Registration Pro Calendar 1.0.2 and Tumult Hype
Animations 1.7.1. Both plugins indeed allow the upload
of PHP scripts. However, accessing both plugins requires
admin privilege. Since an administrator has the highest priv-
ilege of a system and she can upload arbitrary ﬁles anyway,
it is acceptable for an admin script to allow the upload of
arbitrary ﬁles including PHP scripts. We therefore label these
two detected plugins as false positives. Listing 5 presents the
WordPress built-in function add_action(‘‘admin_menu’’,
func_name), which is used by both scripts to make the ﬁle-
upload function (speciﬁed by func_name) only accessible to
admins through “admin_menu’.
1 
Listing 5: add_action( "admin_menu", ’func’) makes
func only accessible to the administrator in the plugin
Event Registration Pro Calendar 1.0.2
While UChecker successfully models and identiﬁes the
upload of PHP scripts, it, unfortunately, does not currently
model “add_action()” to consider whether a script is run-
ning under admin’s privilege. However, we believe such
false positives are acceptable since such alerts are helpful
to encourage developers to specify and reassure types of
uploaded ﬁles (even for the administrator).
B. Identifying New Vulnerable PHP Applications
We have employed UChecker to detect new vulner-
able PHP applications by scanning WordPress plugins.
WordPress features a large repository of PHP-based, open-
source plugins that are contributed from a variety of
sources. We have crawled and tested 9,160 WordPress
plugins in a reverse chronological order (starting from
4/22/2018) based on their last updated time. We have
detected 3 vulnerable plugins including “File Provider 1.2.3”,
“WooCommerce Custom Proﬁle Picture 1.0”, and “WP Demo
Buddy 1.0.2”. To the best of our knowledge, these 3 vul-
nerable plugins have not been previously reported. The
589
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:57:41 UTC from IEEE Xplore.  Restrictions apply. 
System
Adblock Blocker 0.0.1
WP Marketplace 2.4.1
Foxypress 0.4.1.1-0.4.2.1
Estatik 2.2.5
Uploadify 1.0.0
MailCWP 1.100
WooCommerce Catalog Enquiry
3.0.1
N-Media Website Contact Form
with File Uploader 1.3.4
Simple Ad Manager 2.5.94
wp-Powerplaygallery 3.3
Joomla-Bible-study 9.1.1
Avatar Uploader 6.x-1.2