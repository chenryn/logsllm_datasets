as a contextual bandits problem.
arXiv:1806.03806, 2018.
[27] Hui Peng, Yan Shoshitaishvili, and Mathias Payer. T-
fuzz: fuzzing by program transformation. In 2018 IEEE
Symposium on Security and Privacy (SP), pages 697–
710. IEEE, 2018.
[28] Van-Thuan Pham, Marcel Böhme, Andrew E San-
tosa, Alexandru R˘azvan C˘aciulescu, and Abhik Roy-
choudhury. Smart greybox fuzzing. arXiv preprint
arXiv:1811.09447, 2018.
[29] Sanjay Rawat, Vivek Jain, Ashish Kumar, Lucian Co-
jocar, Cristiano Giuffrida, and Herbert Bos. Vuzzer:
Application-aware evolutionary fuzzing. In NDSS, vol-
ume 17, pages 1–14, 2017.
[30] Alexandre Rebert, Sang Kil Cha, Thanassis Avgerinos,
Jonathan Foote, David Warren, Gustavo Grieco, and
David Brumley. Optimizing seed selection for fuzzing.
In 23rd {USENIX} Security Symposium ({USENIX}
Security 14), pages 861–875, 2014.
[31] Konstantin Serebryany, Derek Bruening, Alexander
Potapenko, and Dmitriy Vyukov. Addresssanitizer:
In Presented as part
A fast address sanity checker.
of the 2012 {USENIX} Annual Technical Conference
({USENIX}{ATC} 12), pages 309–318, 2012.
[32] Michael Sutton, Adam Greene, and Pedram Amini.
Fuzzing: brute force vulnerability discovery. Pearson
Education, 2007.
[33] Junjie Wang, Bihuan Chen, Lei Wei, and Yang Liu. Sky-
ﬁre: Data-driven seed generation for fuzzing. In 2017
IEEE Symposium on Security and Privacy (SP), pages
579–594. IEEE, 2017.
[34] Tielei Wang, Tao Wei, Guofei Gu, and Wei Zou.
Taintscope: A checksum-aware directed fuzzing tool
for automatic software vulnerability detection. In 2010
IEEE Symposium on Security and Privacy, pages 497–
512. IEEE, 2010.
[35] Peter Whittle. Multi-armed bandits and the gittins in-
dex. Journal of the Royal Statistical Society: Series B
(Methodological), 42(2):143–149, 1980.
[36] Maverick Woo, Sang Kil Cha, Samantha Gottlieb, and
Scheduling black-box mutational
David Brumley.
In Proceedings of the 2013 ACM SIGSAC
fuzzing.
conference on Computer & communications security,
pages 511–522. ACM, 2013.
[37] Bo Yu, Pengfei Wang, Tai Yue, and Yong Tang. Poster:
Fuzzing iot ﬁrmware via multi-stage message genera-
tion. In Proceedings of the 2019 ACM SIGSAC Confer-
ence on Computer and Communications Security, pages
2525–2527. ACM, 2019.
[38] Insu Yun, Sangho Lee, Meng Xu, Yeongjin Jang, and
Taesoo Kim. {QSYM}: A practical concolic execution
engine tailored for hybrid fuzzing. In 27th {USENIX}
Security Symposium ({USENIX} Security 18), pages
745–761, 2018.
[39] Michal Zalewski. Aﬂ vulnerability trophy case. Website,
2014. http://lcamtuf.coredump.cx/afl/#bugs.
[40] Michal Zalewski. American fuzzy lop.(2014). Website,
2014. http://lcamtuf.coredump.cx/afl.
[41] Michał Zalewski.
Fidgetyaﬂ.
Website, 2016.
https://groups.google.com/forum/#!msg/
afl-users/fOPeb62FZUg/CES5lhznDgAJ.
[42] Michał Zalewski. American fuzzy lop technical details.
Website, 2018. http://lcamtuf.coredump.cx/afl/
technical_details.txt.
[43] Gen Zhang, Xu Zhou, Yingqi Luo, Xugang Wu, and
Erxue Min. Ptfuzz: Guided fuzzing with processor trace
feedback. IEEE Access, 6:37302–37313, 2018.
[44] Lei Zhao, Yue Duan, Heng Yin, and Jifeng Xuan. Send
hardest problems my way: Probabilistic path prioritiza-
tion for hybrid fuzzing. In NDSS, 2019.
USENIX Association
29th USENIX Security Symposium    2321
Appendix
8.1 More Analysis of Average-Cost Evalua-
tion
In this subsection, we implement a more in-depth analysis of
the evaluation results in Section 5.2.
Path Coverage. From Fig. 6, EcoFuzz outperforms the
other six fuzzers on most programs except cxxfilt, readelf,
djpeg, xmllint and infotocap. For these ﬁve programs,
on xmllint and infotocap, EcoFuzz ﬁnds more paths than
other tools in the same number of executions. The path cover-
age EcoFuzz achieves is only slightly lower than FidgetyAFL
or AFLFast.new. The reason is that they generate more test
cases than EcoFuzz. On cxxfilt, EcoFuzz performs bet-
ter than AFLFast.new and FidgetyAFL when the number
of paths is below 7,000. After that, AFLFast.new and Fid-
getyAFL generate more test cases than EcoFuzz so that the
paths discovered by AFLFast.new and FidgetyAFL are more
than EcoFuzz. On readelf, EcoFuzz performs similarly to
AFLFast.new and FidgetyAFL in the early stage. In the later
stage, the number of paths discovered by EcoFuzz is slightly
less than that of AFLFast.new and FidgetyAFL. On djpeg, as
can be seen from Fig. 6, there are two signiﬁcant increases in
the curve of AFLFast.new and FidgetyAFL in the latter stage,
which makes the numbers of paths found by AFLFast.new
and FidgetyAFL exceed that of EcoFuzz. We analyze the re-
sult of each run on djpeg and ﬁnd that there are two runs of
AFLFast.new and FidgetyAFL discovering over 4,500 paths
on djpeg, respectively. In other cases, the number of paths
they found is approximate to that of EcoFuzz. We regard this
as the impact of experimental contingency.
In addition, in most cases, fuzzers without indeterministic
strategies (EcoFuzz, FidgetyAFL, and AFLFast.new) were
noted to perform better than FairFuzz, AFL, AFLFast, and
MOPT-AFL. This proves that the indeterministic mutation
strategies are efﬁcient in general. Particularly, EcoFuzz ﬁnds
signiﬁcantly more paths than these four tools, and overall,
EcoFuzz performs better than six other techniques in path
exploration and energy saving.
Average-Cost and Total Executions. From Table 2, no-
tice that, on most cases, under the same testing hours, the num-
ber of test cases produced by EcoFuzz is far fewer than other
techniques, especially on the subjects cxxfilt, xmllint and
infotocap. The reason is that when EcoFuzz assigns energy
to a seed, EcoFuzz does not take the execution time or length
of the seed into consideration. That leads EcoFuzz to allo-
cate energy on a long execution time seed as same as other
some fast seed, which costs EcoFuzz more time to fuzz it than
some other seeds. Besides, EcoFuzz has fuzzed all seeds from
the queue, with implementing more executions on the trim
strategy than other techniques. Different from our scheduling
algorithm, the power schedules of other fuzzers we compare
against to EcoFuzz are mainly based on that of AFL and
maintain most features. As introduced in Section 2.1, dur-
ing the indeterministic strategies, AFL assigns energy to the
seed according to its performance score, which is calculated
based on the execution time, coverage, and discovery time.
The longer its execution time is, the less energy is allocated.
This mechanism guarantees that AFL will not spend a lot of
time on fuzzing these long execution time seeds. However, it
makes sense to allocate energy to these long execution time
seeds, which also helps us to improve the coverage.
More Statistical Analysis. In Section 5.2, we have re-
ported the results of statistical analysis and pointed out that
EcoFuzz outperforms other tools in general. In this subsection,
we analyze the statistical results of p value and extremum in
detail.
From Table 6, on the path coverage, p1 is smaller than
10−4 in all evaluations, indicating that the distribution of
total paths found by EcoFuzz and AFL differs signiﬁcantly.
Further, p3, p5, and p6 are also mostly tend to be smaller than
10−3, which proves that EcoFuzz also outperforms AFLFast,
FairFuzz, and MOPT-AFL notably in path exploration. In
the majority of evaluation, p4 is approximately the same as
10−1, this indicating that the paths EcoFuzz and AFLFast.new
ﬁnd are not signiﬁcantly different. However, on the average-
cost, p4 is smaller than 10−2 on 11 evaluations, thus proving
that EcoFuzz’s average-cost is signiﬁcantly lower than that of
AFLFast.new.
From Table 7, EcoFuzz and AFLFast.new outperform the
other ﬁve tools on most programs, whether in the maximum or
the minimum of discovered paths. EcoFuzz achieves the up-
per bound of the maximum of path coverage on six programs,
minimum of path coverage on eight programs. Compared to
AFLFast.new, though EcoFuzz achieves the path coverage ap-
proximate to AFLFast.new, the energy depletion of EcoFuzz
is lower than AFLFast.new.
8.2 Analysis of Vulnerabilities Detected by
EcoFuzz
In Section 5.4, we evaluated the validity of EcoFuzz on detect-
ing vulnerabilities and reported some vulnerabilities found by
EcoFuzz in general. We state some detailed analysis of these
vulnerabilities in this subsection.
In addition to the bugs found in GNU Binutils, Eco-
Fuzz also found 5 vulnerabilities on some programs tested
in Section 5.2, with 2 heap-buffer-overﬂow in gif2png,
and tcpdump, as well as 3 memory leak in libpng and
jhead, which were only found by EcoFuzz, FidgetyAFL and
AFLFast.new. In detail, there are 2 vulnerabilities found in
gif2png, a heap-buffer-overﬂow in the writeﬁle function in
gif2png.c and a memory leek in the xalloc function in mem-
ory.c. In addition, since gif2png is built on libpng, Eco-
Fuzz also found a memory leak in png_malloc_warn in png-
mem.c of libpng when recurred a crash in gif2png. More-
over, EcoFuzz found a heap-buffer-overﬂow in jhead, which
2322    29th USENIX Security Symposium
USENIX Association
Table 6: The p-value result in each evaluation
Subjects
nm
objdump
readelf
size
cxxﬁlt
djpeg
xmllint
gif2png
readpng
tcpdump
infotocap
jhead
magick
bsdtar
p1
1.2*10−7
5.0*10−8
9.2*10−7
9.2*10−7
5.8*10−6
7.6*10−5
9.3*10−9
4.2*10−7
7.1*10−6
1.8*10−6
4.5*10−6
5.7*10−6
1.8*10−10
1.0*10−10
p2
1.2*10−2
1.4*10−1
5.2*10−1
2.8*10−5
4.4*10−3
2.3*10−1
6.6*10−3
6.3*10−4
4.3*10−2
2.3*10−3
2.7*10−1
1.5*10−4
3.8*10−2
6.7*10−3
Number of total paths
p3
p4
1.3*10−4
1.9*10−7
2.4*10−5
4.6*10−6
3.3*10−5
9.3*10−4
1.7*10−7
4.6*10−4
9.1*10−5
7.1*10−6
7.0*10−5
6.9*10−5
3.3*10−9
9.4*10−6
6.4*10−1
2.6*10−1
4.6*10−2
9.5*10−3
7.1*10−4
1.4*10−1
6.1*10−2
1.5*10−1
3.2*10−1
9.1*10−1
1.6*10−1
1.8*10−4
4.4*10−1
7.8*10−1
p5
1.2*10−4
2.2*10−6
2.8*10−4
1.3*10−6
6.1*10−8
9.2*10−6
1.9*10−3
2.2*10−6
9.8*10−2
3.6*10−2
8.7*10−5
7.9*10−6
1.6*10−5
3.3*10−7
p6
3.9*10−7
3.6*10−8
1.4*10−6
4.8*10−6
3.2*10−1
4.4*10−2
1.9*10−3
1.8*10−4
4.8*10−2
2.6*10−5
3.3*10−2
1.8*10−4
7.1*10−7
6.1*10−7
p1
1.5*10−5
9.5*10−8
4.9*10−8
1.0*10−5
4.4*10−7
7.4*10−4
2.0*10−5
1.2*10−1
3.6*10−3
3.9*10−7
6.4*10−6
8.4*10−7
5.6*10−9
2.9*10−10
p2
8.5*10−3
1.9*10−3
6.2*10−1
7.2*10−6
5.1*10−8
4.8*10−2
5.5*10−6
9.2*10−4
2.0*10−4
1.4*10−2
3.3*10−5
3.0*10−4
2.3*10−2