title:The Join Problem in Dynamic Network Algorithms
author:Kishori M. Konwar and
Dariusz R. Kowalski and
Alexander A. Shvartsman
The Join Problem in Dynamic Network Algorithms∗
Kishori M. Konwar 1
PI:EMAIL
Dariusz R. Kowalski 2,3
PI:EMAIL
Alexander A. Shvartsman 1,4
PI:EMAIL
1 Department of Computer Science and Engineering, University of Connecticut, Unit 2155, Storrs, CT 06269, USA
2 Max-Planck-Institut f¨ur Informatik, Stuhlsatzenhausweg 85, Saarbr¨ucken, 66123, Germany
3 Instytut Informatyki, Uniwersytet Warszawski, Banacha 2, 02-097 Warszawa, Poland
4 MIT Computer Science and Artiﬁcial Intelligence Laboratory, The Stata Center, Cambridge, MA 02139, USA
Abstract
1. Introduction
Distributed algorithms in dynamic networks often em-
ploy communication patterns whose purpose is to dissemi-
nate information among the participants. Gossiping is one
form of such communication pattern. In dynamic settings
the set of participants can change substantially as new par-
ticipants join, and as failures and voluntary departures re-
move those who have joined previously. A natural question
for such settings is: how soon can newly joined nodes dis-
cover each other by means of gossiping? This paper ab-
stracts and studies the Join Problem for dynamic systems
that use all-to-all gossip. The problem is studied in terms of
join-connectivity graphs where vertices represent the par-
ticipants and where each edge represents one participant’s
knowledge about another. Ideally, such a graph has diam-
eter one, i.e., all participants know each other. The diam-
eter can grow as new participants join, and as failures re-
move edges from the graph. Gossip helps participants dis-
cover one another, decreasing the diameter. The results de-
scribe the lower and upper bounds on the number of com-
munication rounds such that the participants who have pre-
viously joined discover one another, under a variety of as-
sumptions about the joining and failures. For example, in
the case when new participants join at multiple participants
and participants may crash, the number of rounds cannot be
bounded. In the more benign cases when the failures can be
controlled or when new participants join at only one par-
ticipant, the bound on rounds is shown to be logarithmic in
the diameter of the initial conﬁguration.
∗
This work is supported in part by the NSF Grant 0121277. The work of
the second author is supported in part by the KBN Grant 4T11C04425
and by the NSF-NATO Award 0209588. The work of the third author
is supported by the NSF CAREER Award 9984778 and NSF Grants
9988304, and 0311368.
In order to be deployable over dynamic networks, dis-
tributed algorithms must include facilities for new partic-
ipants to join the computation and to discover each other.
There are two immediate distinct challenges that must be
faced in joining a dynamic computation: (a) discovering
a system access point allowing new participants to join,
and (b) joining the computation and acquiring information
about the computation. This work studies the latter prob-
lem of joining the computation, when the former problem,
of ﬁnding where to join the computation, is solved.
In a realistic networked system, the knowledge describ-
ing the state of a distributed computation is inherently dis-
tributed. For example, in systems with dynamic participa-
tion, it may be impossible to know globally and precisely
who the participants are. This is especially true if new par-
ticipants can join the computation at arbitrary times. Thus
the safety of sophisticated distributed algorithms must not
depend on the global knowledge about the participants. At
the same time, the system performance concerns may be
well served by participants knowing about each other. This
motivates our introduction and study of the Join Problem
that we state as follows:
For any two participants that join a dynamic system,
how long does it take for them to discover each other?
We study this question for distributed systems that use
periodic all-to-all gossip whose purpose is to disseminate
information among the participants. While all-to-all gos-
sip may not be bandwidth-efﬁcient, it is fault-tolerant and
is the fastest form of gossip when bandwidth is of no con-
cern. Furthermore, the undertstanding of the limitations of
information propagation in all-to-all gossip patterns helps
understanding gossip using more restricted communication
patterns. We focus on an abstract model of the join algo-
rithm, modelled after the join protocol of the reconﬁgurable
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 11:50:34 UTC from IEEE Xplore.  Restrictions apply. 
atomic memory service for dynamic networks presented by
Lynch and Shvartsman [11], and Gilbert et al. [4]. As is typ-
ical for dynamic systems, the performance of this memory
service depends on how quickly the new participants be-
come integrated.
The problem is studied in terms of join-connectivity
graphs where vertices represent the participants and where
each edge represents one participant’s knowledge about an-
other. Ideally, such a graph has diameter one, i.e., all par-
ticipants know each other. The diameter can grow as new
participants join, and as failures remove edges from the
graph. Gossip helps participants discover one another, de-
creasing the diameter. The results describe the lower and
upper bounds on the number of communication rounds such
that the participants who have previously joined discover
one another, under a variety of assumptions about the join-
ing and failures. We now review our contributions in detail.
Summary of contributions. In this paper we study the Join
Problem with the help of an abstract join algorithm that we
call the Join-Protocol (Section 2). We use the algorithm to
study the upper and lower bounds of the Join Problem un-
der a variety of scenarios.
In our model, nodes asynchronously join the system
and leave the system (by failing), while the knowledge of
the participants about one another is represented by a dy-
namically evolving communication graph, called the join-
connectivity graph (Section 2.2). A new node joins the sys-
tem by sending a request to join at one or more nodes
that are already participating. The knowledge of the joined
nodes about each other is propagated by means of perpet-
ual gossip with known nodes.
We formally state the Join-Protocol (Section 2) using the
Input/Output Automata [12] notation. The protocol is spec-
iﬁed as a non-deterministic algorithm for asynchronous en-
vironments with arbitrary message delays and node crashes
that may cause network partitions. In such environments
it is not possible to quantify how information is propa-
gated throughout the “known universe.” For the purpose of
analysis, we restrict asynchrony, resolve some of the non-
determinism of the algorithm, and impose constraints sufﬁ-
cient to guarantee that the universe is connected.
We restrict our attention to the timed executions of the
protocol, in which the initial period of arbitrary instabil-
ity is followed by a period of stability. We call such exe-
cutions normal. Starting with admissible timed executions
(that allow time to pass to inﬁnity), we instrument the exe-
cutions with states of interest, called the milestone states, by
means of time-passage reﬁnements. In order to make plau-
sible a performance analysis, for the stable sufﬁx of an ex-
ecution, we introduce the notion of a timed communication
round (Section 3).
Given a normal execution and a state s in the stable suf-
ﬁx of the execution, we deﬁne the join-delay jd(s) to be
the maximum number of rounds required for any two nodes
that have joined the computation by state s to learn about
each other (Section 3.2). For each state s we deﬁne the join-
connectivity graph s.G = (s.J, s.E), where s.J is the set
of nodes that have joined, and the edges in s.E represent
the nodes’ knowledge about each other. Since we are inter-
ested in results for networks that do not partition, it is suf-
ﬁcient to assume that these graphs are connected. We study
join-delay for the cases with and without node failures, and
the cases where new participants join at only one node or
at multiple nodes. Thus we consider four distinct classes of
executions (Section 4). Our result are as follows.
1. Joining at a single node in the absence of failures: For
any state s in the stable segment of a normal execu-
tion, jd(s) = Θ (log (s.G.diam)), where s.G.diam
is the diameter of the join-connectivity graph. (Θ nota-
tion here speciﬁes upper and lower bounds deﬁned to
be the minimum over all algorithms of the maximum
join-delay in all relevant executions.)
2. Joining at multiple nodes in the absence of failures:
For any state s in the stable segment of a normal exe-
cution, jd(s) = Θ (log (s.G.diam)). This is similar to
the case (1), but the analysis is different.
3. Joining at a single node in the presence of failures: For
any state s in the stable segment of a normal execution,
we show an upper bound of jd(s) = O (log (|s.J|)),
and a lower bound of jd(s) = Ω (log (s.G.diam)).
4. Joining at multiple nodes in the presence of failures:
We show that an adversary can force join-delay to be
unbounded even in normal executions. Thus, in order
to get an upper bound we constrain the adversary so
that the rate at which it fails nodes in certain regions
of the join-connectivity graphs is not more than expo-
nential in the number of rounds. In this case, for any
state s in the stable segment of a normal execution, we
show an upper bound of jd(s) = O (log (s.G.diam)).
Note that, surprisingly, joining at multiple nodes in the pres-
ence of failures leads to worse (unbounded) join-delay as
compared to joining at a single node. The reason for this
is that when joining at multiple nodes the system can tol-
erate larger patterns of node failures since we require that
join-connectivity graphs remain connected. However this
improved fault-tolerance can cause unbounded join-delays.
Constraining the adversary allows to bound join-delays.
Relevant landscape. Gossip and broadcast are among the
basic communication problems (e.g., [5, 14, 6, 3]). The goal
of broadcasting is to spread a message known at one node
to all other known nodes, while in the case of gossiping we
are interested in all nodes exchange their initial messages.
The most interesting metrics used in comparing commu-
nication algorithms are time and message complexity, that
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 11:50:34 UTC from IEEE Xplore.  Restrictions apply. 
is, the number of elementary transmissions required by the
communication process. The dynamic version of gossiping,
called perpetual gossiping, was introduced by Liestman and
Richards [9]. Here the new information is generated contin-
uously and the goal is to update the received information,
hence the gossiping-like protocol must be repeated.
A related problem is maintaining consistency among the
sites in the face of updates in the replicated database. De-
mers et al. [2] developed randomized algorithms for dis-
tributing updates and driving the replicas toward consis-
tency. They use epidemic-like approach to model and an-
alyze the performance of designed protocols.
Peer-to-peer systems provide decentralized access to the
stored information. In a dynamic peer-to-peer environment,
the time required to disseminate new information can vary
greatly owing to rapid changes in the membership of indi-
vidual peers that perpetually join and leave the system. This
dynamic nature of the peer-to-peer network also creates the
problem of residual peers that do not receive updates before
they leave or fail [13]. Cuenca-Acuna et al. [1] introduce
PlanetP, a content addressable publish/subscribe service for
unstructured peer-to-peer communities. The simplicity of
PlanetP may be illustrated by the fact that each peer must
only perform a periodic, randomized, point-to-point mes-
sage exchange with other peers. Liben-Nowell et al. [8] ad-
dressed the issue of assumption of an ideal connected over-
lay network across the Internet that goes with many peer-
to-peer protocols that uses key lookups. They pointed out
that most of these approaches ignore the very fact that peer-
to-peer networks are dynamically evolving systems. The au-
thors develop a theoretical analysis of peer-to-peer networks
in the presence of concurrent joins and unexpected failures
with a focus on Chord [15].
Kumar et al. [7] proposed and analyzed the statistical
properties of Internet-like dynamic topology. They consid-
ered the structures different than previously used random
graphs, requiring that the adding of new units/links to the
network does not change the stochastic properties of the dy-
namic structure.
Lynch, Shvartsman, and Gilbert [11, 4] proposed a re-
conﬁgurable atomic memory service for dynamic networks.
Our Join-Protocol is based on their join algorithm. The per-
formance of the memory service depends largely on the
gossip protocol that goes on perpetually as a background
process at every participating node. The analysis of perfor-
mance of the service makes assumptions about join-delays
in the system. Our new work establishes speciﬁc bounds
that can be used in lieu of those assumptions.
Document structure. In Section 2 we deﬁne the join pro-
tocol and the join-connectivity graphs. We give the models
and deﬁnitions used in our analysis in Section 3. Section 4
deals with the analysis of the protocol. Finally, we summa-
rize our contribution in Section 5.
2. The Join Protocol
We abstract the join protocol from the reconﬁgurable
atomic memory service of Lynch and Shvartsman [11]. This
service, called RAMBO (Reconﬁgurable Atomic Memory
for Basic Objects), implements atomic read/write memory.
The objects are replicated at multiple nodes in an asyn-
chronous dynamic network, where new nodes may join the
service, and previously joined nodes may leave the system
or fail. The implementation is speciﬁed using Input/Output
Automata [12] formalism. Correctness (atomicity) is guar-
anteed for any patterns of asynchrony and failures. The efﬁ-
ciency of reads and writes depends on the nodes that join the
system learning about each other. A new node joins the sys-
tem by contacting any previously joined node. The knowl-
edge of the joined nodes about each other is propagated by
means of all-to-all gossip. The goal here is for each joined
node to ﬁnd out about all other joined nodes.
2.1. Description of the Join Protocol
We specify the behavior of each node v (v ∈ P ) par-
ticipating in the join protocol as an I/O automaton, called
Join-Protocol v. The complete I/O Automaton speciﬁca-
tion of Join-Protocol v is given in Figure 1, and it in-
cludes the signature, the state variables, and the transitions.
We now discuss the speciﬁcation. To disambiguate among
the state variables of different automata when these vari-
ables appear outside of the scope of their deﬁnition, we use
the shorthand v.(cid:3)state-variable(cid:4) to refer to the state vari-
able Join-Protocol v.(cid:3)state-variable(cid:4), i.e., the state vari-
able (cid:3)state-variable(cid:4) of Join-Protocol v. Also, for a state
s, we use the notation s.v.(cid:3)state-variable(cid:4) to denote the
value of v.(cid:3)state-variable(cid:4) in that state.
The join protocol is simple. Initially, a distinguished sin-
gle node c (the “creator”) constitutes the entire system.
When some other node v receives join(H) request from its
environment, it sends out join requests to the set of pro-
cesses in H, representing a reasonable guess of what nodes
may have already joined. Join-Protocol v then waits for ac-
knowledgements.
Initially, v.status = idle in Join-Protocol v, for each
v ∈ P − {c}, which results in all of its output actions be-
ing disabled, and v.f ailed = f alse, meaning that the node
has not crashed. However, when Join-Protocol v receives a
join(H) request from its environment, it changes its status
to joining and initializes its set hints to the set H. We im-
pose the well-formedness condition on the environment that
H is a ﬁnite subset of P . Join-Protocol v then can send a
join request to each node in H using action send(join)v,u,
u ∈ H. This happens as long as v.f ailed = f alse and
v.status = joining.
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 11:50:34 UTC from IEEE Xplore.  Restrictions apply. 
Data-types:
P , the set of node identiﬁers
c ∈ P , a distinguished node (the “creator”)
Signature: