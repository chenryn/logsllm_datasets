---
author: ''
category: 软件开发
comments_data:
- date: '2014-06-24 10:03:01'
  message: '[ok]'
  postip: 66.249.79.57
  username: 微博评论
- date: '2014-06-24 10:03:01'
  message: 这篇真是累死人了，但是必须学习~因为正在的精华就是这类文章[good]
  postip: 66.249.79.57
  username: 微博评论
- date: '2014-06-24 10:03:01'
  message: Repost
  postip: 66.249.79.57
  username: 微博评论
- date: '2014-06-24 10:33:04'
  message: 马克杯
  postip: 10.189.62.118
  username: 微博评论
- date: '2014-06-24 17:03:00'
  message: //@Linux_cn:转发微博
  postip: 68.180.225.109
  username: 微博评论
- date: '2014-06-26 15:37:13'
  message: "对于译文最好加上原文链接http://www.linuxvoice.com/be-a-kernel-hacker/有时候英较好的的同学可以去查看原文以及弥补翻译的不足,\r\n还有就是文章里曼涉及到的重要链接不要丢失了,这是其中项目的github链接https://github.com/vsinitsyn/reverse"
  postip: 155.69.225.84
  username: Zhang_Longqi
- date: '2014-07-03 11:32:47'
  message: "新装的ubuntu10.04, git上的源码编不通, 什么情况\r\nroot@leo-laptop:/home/root/code/git/reverse#
    make\r\nmake -C /lib/modules/2.6.32-53-generic/build M=/home/root/code/git/reverse
    modules\r\nmake[1]: Entering directory `/usr/src/linux-headers-2.6.32-53-generic'\r\n&nbsp;&nbsp;CC [M]&nbsp;&nbsp;/home/root/code/git/reverse/reverse.o\r\n/home/root/code/git/reverse/reverse.c:206:
    error: ‘noop_llseek’ undeclared here (not in a function)\r\nmake[2]: ***
    [/home/root/code/git/reverse/reverse.o] Error 1\r\nmake[1]: *** [_module_/home/root/code/git/reverse]
    Error 2\r\nmake[1]: Leaving directory `/usr/src/linux-headers-2.6.32-53-generic'\r\nmake: *** [all] Error 2"
  postip: 112.91.118.232
  username: breakersun
- date: '2014-07-03 13:17:58'
  message: 有译文的原文链接的，只是文章较长，原文链接和翻译者等信息，都在最后一页。
  postip: 61.148.243.51
  username: linux
- date: '2014-07-03 13:24:30'
  message: "文末的这种信息，在我们的CMS里面没有单独拎出来，所以很难每页都显示，我想想办法~\r\n另外，这个GIT链接，我查看了原文了，可能是翻译过程给漏了，我现在给补上，谢谢您。"
  postip: 61.148.243.51
  username: linux
- date: '2014-07-04 13:12:47'
  message: 不明学厉呀！我也就编辑过自己笔记本的驱动，还是就是升级了一个LINUX内核。
  postip: 221.216.21.155
  username: wuanshou
- date: '2014-07-22 13:51:03'
  message: 不明觉厉呀。我只会编译，还真不会编写
  postip: 221.220.205.80
  username: wuanshou
- date: '2014-07-22 15:05:05'
  message: 啊哈，我觉得照着这篇文章，可以写一个~
  postip: 123.114.35.197
  username: linux
- date: '2014-08-27 23:08:27'
  message: '为什么kali linux make 出现make: ***/lib/modules/3.12-kali1-686-pae/build:没有那个文件或目录。停止。'
  postip: 60.247.46.187
  username: ''
- date: '2014-11-27 16:45:43'
  message: 我也遇到了这个问题,你搞明白了嘛???
  postip: 222.174.213.193
  username: 来自 - 山东威海 的 Chrome/Windows 用户
- date: '2015-02-13 16:11:14'
  message: 没有安装内核源码
  postip: 155.69.225.48
  username: Zhang_Longqi
count:
  commentnum: 15
  favtimes: 15
  likes: 0
  sharetimes: 12
  viewnum: 64924
date: '2014-06-24 09:00:00'
editorchoice: false
excerpt: 曾经多少次想要在内核游荡？曾经多少次茫然不知方向？你不要再对着它迷惘，让我们指引你走向前方  内核编程常常看起来像是黑魔法，而在亚瑟 C 克拉克的眼中，它八成就是了。Linux内核和它的用户空间是大不相同的：抛开漫不经心，你必须小心翼翼，因为你编程中的一个bug就会影响到整个系统。浮点运算做起来可不容易，堆栈固定而狭小，而你写的代码总是异步的，因此你需要想想并发会导致什么。而除了所有这一切之外，Linux内核只是一个很大的、很复杂的C程序，它对每个人开放，任何人都去读它、学习它并改进它，而你也可以是其中之一。  学
fromurl: http://www.linuxvoice.com/be-a-kernel-hacker/
id: 3251
islctt: true
largepic: /data/attachment/album/201406/24/012730cu0k0hhwcu5w5az0.jpg
permalink: /article-3251-1.html
pic: /data/attachment/album/201406/24/012730cu0k0hhwcu5w5az0.jpg.thumb.jpg
related: []
reviewer: ''
selector: ''
summary: 曾经多少次想要在内核游荡？曾经多少次茫然不知方向？你不要再对着它迷惘，让我们指引你走向前方  内核编程常常看起来像是黑魔法，而在亚瑟 C 克拉克的眼中，它八成就是了。Linux内核和它的用户空间是大不相同的：抛开漫不经心，你必须小心翼翼，因为你编程中的一个bug就会影响到整个系统。浮点运算做起来可不容易，堆栈固定而狭小，而你写的代码总是异步的，因此你需要想想并发会导致什么。而除了所有这一切之外，Linux内核只是一个很大的、很复杂的C程序，它对每个人开放，任何人都去读它、学习它并改进它，而你也可以是其中之一。  学
tags:
- 内核
- 开发
- 模块
thumb: false
title: 黑客内核：编写属于你的第一个Linux内核模块
titlepic: false
translator: GOLinux
updated: '2014-06-24 09:00:00'
---
> 
> 曾经多少次想要在内核游荡？曾经多少次茫然不知方向？你不要再对着它迷惘，让我们指引你走向前方……
> 
> 
> 
内核编程常常看起来像是黑魔法，而在亚瑟 C 克拉克的眼中，它八成就是了。Linux内核和它的用户空间是大不相同的：抛开漫不经心，你必须小心翼翼，因为你编程中的一个bug就会影响到整个系统。浮点运算做起来可不容易，堆栈固定而狭小，而你写的代码总是异步的，因此你需要想想并发会导致什么。而除了所有这一切之外，Linux内核只是一个很大的、很复杂的C程序，它对每个人开放，任何人都去读它、学习它并改进它，而你也可以是其中之一。
![](/data/attachment/album/201406/24/012730cu0k0hhwcu5w5az0.jpg)
学习内核编程的最简单的方式也许就是写个内核模块：一段可以动态加载进内核的代码。模块所能做的事是有限的——例如，他们不能在类似进程描述符这样的公共数据结构中增减字段（LCTT译注：可能会破坏整个内核及系统的功能）。但是，在其它方面，他们是成熟的内核级的代码，可以在需要时随时编译进内核（这样就可以摒弃所有的限制了）。完全可以在Linux源代码树以外来开发并编译一个模块（这并不奇怪，它称为树外开发），如果你只是想稍微玩玩，而并不想提交修改以包含到主线内核中去，这样的方式是很方便的。
在本教程中，我们将开发一个简单的内核模块用以创建一个**/dev/reverse**设备。写入该设备的字符串将以相反字序的方式读回（“Hello World”读成“World Hello”）。这是一个很受欢迎的程序员面试难题，当你利用自己的能力在内核级别实现这个功能时，可以使你得到一些加分。在开始前，有一句忠告：你的模块中的一个bug就会导致系统崩溃（虽然可能性不大，但还是有可能的）和数据丢失。在开始前，请确保你已经将重要数据备份，或者，采用一种更好的方式，在虚拟机中进行试验。
### 尽可能不要用root身份
> 
> 默认情况下，**/dev/reverse**只有root可以使用，因此你只能使用**sudo**来运行你的测试程序。要解决该限制，可以创建一个包含以下内容的**/lib/udev/rules.d/99-reverse.rules**文件：
> 
> 
> 
> ```
> SUBSYSTEM=="misc", KERNEL=="reverse", MODE="0666"
> 
> ```
> 
> 别忘了重新插入模块。让非root用户访问设备节点往往不是一个好主意，但是在开发其间却是十分有用的。这并不是说以root身份运行二进制测试文件也不是个好主意。
> 
> 
> 
#### 模块的构造
由于大多数的Linux内核模块是用C写的（除了底层的特定于体系结构的部分），所以推荐你将你的模块以单一文件形式保存（例如，reverse.c）。我们已经把完整的源代码放在[GitHub上](https://github.com/vsinitsyn/reverse)——这里我们将看其中的一些片段。开始时，我们先要包含一些常见的文件头，并用预定义的宏来描述模块：
```
#include 
#include 
#include 
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Valentine Sinitsyn ");
MODULE_DESCRIPTION("In-kernel phrase reverser");
```
这里一切都直接明了，除了**MODULE\_LICENSE()**：它不仅仅是一个标记。内核坚定地支持GPL兼容代码，因此如果你把许可证设置为其它非GPL兼容的（如，“Proprietary”[专利]），某些特定的内核功能将在你的模块中不可用。
### 什么时候不该写内核模块
> 
> 内核编程很有趣，但是在现实项目中写（尤其是调试）内核代码要求特定的技巧。通常来讲，在没有其它方式可以解决你的问题时，你才应该在内核级别解决它。以下情形中，可能你在用户空间中解决它更好：
> 
> 
> * 你要开发一个USB驱动 —— 请查看[libusb](http://www.libusb.org/)。
> * 你要开发一个文件系统 —— 试试[FUSE](http://fuse.sf.net/)。
> * 你在扩展Netfilter —— 那么[libnetfilter\_queue](http://www.linuxvoice.com/be-a-kernel-hacker/www.netfilter.org/projects/libnetfilter_queue)对你有所帮助。
> 
> 
> 通常，内核里面代码的性能会更好，但是对于许多项目而言，这点性能丢失并不严重。
> 
> 
> 
由于内核编程总是异步的，没有一个**main()**函数来让Linux顺序执行你的模块。取而代之的是，你要为各种事件提供回调函数，像这个：
```
static int __init reverse_init(void)
{
    printk(KERN_INFO "reverse device has been registered\n");
    return 0;
}
static void __exit reverse_exit(void)
{
    printk(KERN_INFO "reverse device has been unregistered\n");
}
module_init(reverse_init);
module_exit(reverse_exit);
```
这里，我们定义的函数被称为模块的插入和删除。只有第一个的插入函数是必要的。目前，它们只是打印消息到内核环缓冲区（可以在用户空间通过**dmesg**命令访问）；**KERN\_INFO**是日志级别（注意，没有逗号）。**\_\_init**和**\_\_exit**是属性 —— 联结到函数（或者变量）的元数据片。属性在用户空间的C代码中是很罕见的，但是内核中却很普遍。所有标记为**\_\_init**的，会在初始化后释放内存以供重用（还记得那条过去内核的那条“Freeing unused kernel memory…[释放未使用的内核内存……]”信息吗？）。**\_\_exit**表明，当代码被静态构建进内核时，该函数可以安全地优化了，不需要清理收尾。最后，**module\_init()**和**module\_exit()**这两个宏将**reverse\_init()**和**reverse\_exit()**函数设置成为我们模块的生命周期回调函数。实际的函数名称并不重要，你可以称它们为**init()**和**exit()**，或者**start()**和**stop()**，你想叫什么就叫什么吧。他们都是静态声明，你在外部模块是看不到的。事实上，内核中的任何函数都是不可见的，除非明确地被导出。然而，在内核程序员中，给你的函数加上模块名前缀是约定俗成的。
这些都是些基本概念 - 让我们来做更多有趣的事情吧。模块可以接收参数，就像这样：
```
# modprobe foo bar=1
```
**modinfo**命令显示了模块接受的所有参数，而这些也可以在**/sys/module//parameters**下作为文件使用。我们的模块需要一个缓冲区来存储参数 —— 让我们把这大小设置为用户可配置。在**MODULE\_DESCRIPTION()**下添加如下三行：
```
static unsigned long buffer_size = 8192;
module_param(buffer_size, ulong, (S_IRUSR | S_IRGRP | S_IROTH));
MODULE_PARM_DESC(buffer_size, "Internal buffer size");
```