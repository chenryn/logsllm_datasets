trim (both from
'yxJohnxx',
'xyz')
--> John
ASCII Returns the decimal ASCII ASCII code of the first Yes
representation in the character of the
database character set of argument:
the first character of char: ascii('a') --> a
ascii('a') --> a
INSTR Search string for N/A Oracle’s INSTR function No
substring can be simulated using
PostgreSQL built-in
function.
LANGTH Return the length of char: LANGTH Number of characters in Yes
length ('John string:
S.') --> 7 length ('John
S.') --> 7
REGEXP_COU Returning the number of N/A The REGEXP_COUNT No
NT times, a pattern occurs in function can be used
a source string. with Amazon Redshift if
necessary.
REGEXP_INST Search a string position N/A The REGEXP_INSTR No
R for a regular expression function can be used
pattern. with Amazon Redshift if
necessary.
DATETIME FUNCTIONS
ADD_MONTH Returns the date plus PostgreSQL can No
S integer months: implement the same
add_months( functionality using the
sysdate, 1) ‘+ interval month’
statement:
now () + interval
'1 month'
CURRENT_DA Returns the current date CURRENT_DATE PostgreSQL Partly
TE in the session time zone: CURRENT_DATE will
select return date with no time,
current_date from use the now() or the
dual --> current_timestamp
2017-01-01 function to achieve the
13:01:01 same results:
select
current_timestamp
-->
2017-01-01
13:01:01
69
CURRENT_TI Returns the current date CURRENT_TIMESTAM Current date and time: Yes
MESTAMP and time in the session P select current_
time zone: timestamp; -->
select current timestamp 2017-01-01
from dual; 13:01:01
-->
2017-01-01
13:01:01
EXTRACT Returns the value of a EXTRACT (date part) Retrieves subfields such Yes
(date part) specified datetime field as year or hour from
from a datetime or date/time values:
interval expression: EXTRACT (YEAR
EXTRACT (YEAR FROM DATE '2017-
FROM DATE '2017- 03-07') --> 2017
03-07') --> 2017
LAST_DAY Returns the date of the N/A The LAST_DAY function No
last day of the month that can be used with Amazon
contains date Redshift if necessary or
can be created using
PostgreSQL built-in
functions.
MONTHS_BE Returns number of N/A As an alternative solution No
TWEEN months between dates create a function from
date1 and date2: PostgreSQL built-in
MONTHS_BETWEEN ( functions to achieve the
sysdate, sysdate- same functionality.
100) --> 3.25 Example for a possible
solution without decimal
values:
DATE_PART
('month', now())
-
DATE_PART('month'
, now()- interval
'100 days')--> 3
SYSDATE Returns the current date NOW() Current date and time No
and time set for the including fractional
operating system on seconds and time zone:
which the database select now () -
server resides: -> 2017-01-01
select sysdate 13:01:01.123456+0
from dual --> 0
2017-01-01
13:01:01
SYSTIMESTA Returns the system date, NOW() Current date and time No
MP including fractional including fractional
seconds and time zone: seconds and time zone:
Select select now () --> 2017-
systimestamp from 01-01
dual --> 2017-01- 13:01:01.123456+0
01 0
13:01:01.123456
PM +00:00
LOCALTIMES Returns the current date LOCALTIMESTAMP Current date and time: Yes
TAMP and time in the session select
time zone in a value of localtimestamp --
data type TIMESTAMP: > 2017-01-01
10:01:10.123456
70
select
localtimestamp
from dual --> 01-
JAN-17
10.01.10.123456
PM
TO_CHAR Converts a datetime or TO_CHAR (datetime) Convert time stamp to Yes
(datetime) timestamp to data type string:
to a value of VARCHAR2 TO_CHAR(now(), 'DD-
data type in the format MON-YYYY HH24:MI:SS')
specified by the date -->
01-JAN-2017
format: 01:01:01
to_char(sysdate,
'DD-MON-YYYY
HH24:MI:SS')
--> 01-JAN-2017
01:01:01
TRUNC (date) Returns date with the DATE_TRUNC Truncate to specified No
time portion of the day precision:
truncated to the unit date_trunc('day',
specified by the format now()) -->
model: 2017-01-01
trunc(systimestam 00:00:00
p) -->
2017-01-01
00:00:00
ENCODING AND DECODING FUNCTIONS
DECODE Compares expr to each DECODE PostgreSQL Decode No
search value one by one function acts differently
using the functionality of from Oracle’s,
an IF-THEN-ELSE PostgreSQL decode
statement binary data from textual
representation in string
and does not have the
functionality of an IF-
THEN-ELSE statement
DUMP Returns a VARCHAR2 N/A N/A No
value containing the data
type code, length in
bytes, and internal
representation of expr.
ORA_HASH Computes a hash value N/A N/A No
for a given expression.
NULL FUNCTIONS
CASE The CASE statement CASE The PostgreSQL CASE Yes
chooses from a sequence expression is a generic
of conditions and runs a conditional expression,
corresponding statement: similar to if/else
CASE WHEN statements in other
condition THEN programming languages:
result
71
[WHEN ...] CASE WHEN
[ELSE condition THEN
result] result
END [WHEN ...]
[ELSE
result]
END
COALESCE Returns the first non-null COALESCE Returns the first of its Yes
expr in the expression arguments that is not
list: null:
coalesce (null, coalesce (null,
'a', 'b') 'a', 'b')
--> a --> a
NULLIF Compares expr1 and NULLIF Returns a null value if Yes
expr2. If they are equal, value1 equals value2
then the function returns otherwise it returns
null. If they are not equal, value1:
then the function returns NULLIF ('a', 'b')
expr1: --> a
NULLIF('a', 'b')
--> a
NVL Replace null (returned as COALESCE Returns the first of its No
a blank) with a string in arguments that is not
the results of a query: null:
NVL (null, 'a') coalesce (null,
--> a 'a') --> a
NVL2 Determine the value N/A Can use the CASE No
returned by a query statement instead.
based on whether a
specified expression is
null or not null.
ENVIRONMENT AND IDENTIFIER FUNCTIONS
SYS_GUID Generates and returns a UUID_GENERATE_V1() Generates a version 1 No
globally unique identifier UUID:
(RAW value) made up of select
16 bytes: uuid_generate_v1(
select sys_guid() ) -->
from dual 90791a6-a359-
--> 11e7-a61c-
5A280ABA8C76201EE 12803bf1597a
0530100007FF691
UID Returns an integer that N/A Consider using the No
uniquely identifies the PostgreSQL current_user
session user (the user function along with other
who logged on): PostgreSQL buit-in
select uid from function to generate a
dual --> 84 UID.
USER Returns the name of the USER User name or schema of No
session user: SESSION_USER current execution
select user from CURRENT_USER context:
dual CURRENT_SCHEMA() Select user;
or
select
current_schema();
72
USERENV Returns information N/A Please refer to the No
about the current session PostgreSQL
using parameters: documentation for a list
SELECT of all system functions:
USERENV('LANGUAGE https://www.postgresql.
') "Language" org/docs/9.1/static/funct
FROM DUAL ions-info.html
CONVERSION FUNCTIONS
CAST Converts one built-in data CAST Converting one data type Yes
type or collection-typed into another:
value into another built- cast (
in data type or collection- '10' as int) + 1
typed value: --> 11
cast ('10' as
int) + 1 --> 11
CONVERT Converts a character N/A N/A No
string from a one-
character set to another:
select convert
('Ä Ê Í Õ Ø A B C
D E ',
'US7ASCII',
'WE8ISO8859P1')
from dual
TO_CHAR Converts NCHAR, TO_CHAR Converts the first No
(string / NVARCHAR2, CLOB, or argument to the second
numeric) NCLOB data to the argument:
database character set: select
select to_char(01234,
to_char('01234') '00000') -->
from dual --> 01234
01234
TO_DATE Converts char of CHAR, TO_DATE Convert string to date: Partly
VARCHAR2, NCHAR, or to_date('01Jan201
NVARCHAR2 data type to 7', 'DDMonYYYY')
a value of DATE data --> 2017-01-01
type:
to_date('01Jan201
7', 'DDMonYYYY')
--> 01-JAN-17
TO_NUMBER Converts expr to a value TO_NUMBER Convert string to Partly
of NUMBER data type: numeric:
to_number('01234' to_number('01234'
) --> 1234 , '99999') -->
or 1234
to_number('01234'
, '99999') -->
1234
AGGREGATE FUNCTIONS
AVG AVG returns average AVG Average (arithmetic Yes
value of expr: mean) of all input values:
select select
avg(salary) avg(salary)
from employees from employees
73
COUNT Returns the number of COUNT The number of input Yes
rows returned by the rows:
query: select count(*)
select count(*) from employees
from employees
LISTAGG Orders data within each STRING_AGG Input values No
group specified in the concatenated into a
ORDER BY clause and string, separated by
then concatenates the delimiter:
values of the measure select
column: string_agg(firstn
select ame, ' ,')
listagg(firstname from customer
, ' ,') within order by 1;
group (order by
customerid)
from customer
MAX Returns maximum value MAX Maximum value of Yes
of expr: expression across all
select input values:
max(salary) select
from employees max(salary)
from employees
MIN Returns minimum value MIN Minimum value of Yes
of expr: expression across all
select input values:
min(salary) select
from employees min(salary)
from employees
SUM Returns the sum of values SUM Sum of expression across Yes
of expr: all input values:
select select
sum(salary) sum(salary)
from employees from employees
Top-N Query Oracle 12c
FETCH Retrieves rows of data FETCH Retrieve just a portion of Yes
from the result set of a OR the rows that are
multi-row query: LIMIT generated by the rest of
select * from the query:
customer select * from
fetch first 10 customer
rows only fetch first 10
rows only
For additional details:
https://www.postgresql.org/docs/current/static/functions.html
https://www.postgresql.org/docs/current/static/functions-math.html
https://www.postgresql.org/docs/current/static/functions-string.html
https://www.postgresql.org/docs/current/static/uuid-ossp.html
74
Migrating from: Oracle Merge SQL Syntax
[Back to TOC]
Overview
The statement provides a way to specify single SQL statements that can conditionally perform
MERGE
, , or operations on the target table – a task that would otherwise require multiple
INSERT UPDATE DELETE
logical statements. The statement selects record(s) from the source table and then, by specifying a
MERGE
logical structure, automatically performs multiple DML operations on the target table. Its main advantage is to
help avoid the use of multiple inserts, updates or deletes. It is important to note that is a deterministic
MERGE
statement. That is, once a row has been processed by the statement, it cannot be processed again
MERGE
using the same Statement. is also sometimes known as UPSERT.
MERGE MERGE
Example
Using Oracle to insert or update employees who are entitled to a bonus (by year):
MERGE
SQL> CREATE TABLE EMP_BONUS
(
EMPLOYEE_ID NUMERIC,
BONUS_YEAR VARCHAR2(4),
SALARY NUMERIC,
BONUS NUMERIC,
PRIMARY KEY (EMPLOYEE_ID, BONUS_YEAR)
);
SQL> MERGE INTO EMP_BONUS E1
USING (SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, DEPARTMENT_ID
FROM EMPLOYEES) E2
ON (E1.EMPLOYEE_ID = E2.EMPLOYEE_ID)
WHEN MATCHED THEN
UPDATE SET E1.BONUS = E2.SALARY * 0.5
DELETE WHERE (E1.SALARY >= 10000)
WHEN NOT MATCHED THEN
INSERT (E1.EMPLOYEE_ID, E1.BONUS_YEAR, E1.SALARY, E1.BONUS)
VALUES (E2.EMPLOYEE_ID, EXTRACT(YEAR FROM SYSDATE), E2.SALARY,
E2.SALARY * 0.5)
WHERE (E2.SALARY  SELECT * FROM EMP_BONUS;
EMPLO YEE_ID BONU SALARY BONUS
----------- ---- ---------- ----------
103 2017 9000 4500
104 2017 6000 3000
105 2017 4800 2400
106 2017 4800 2400
107 2017 4200 2100
109 2017 9000 4500
110 2017 8200 4100
111 2017 7700 3850
112 2017 7800 3900
113 2017 6900 3450
115 2017 3100 1550
Fo r additional details:
htt ps://docs.oracle.com/cd/B28359_01/server.111/b28286/statements_9016.htm#SQLRF01606
75
Migration to: PostgreSQL Merge SQL Syntax
[Back to TOC]
Overview
Currently, PostgreSQL version 9.6 does not support the use of the SQL command. As an alternative,
MERGE
consider using the clause, which can handle cases where insert clauses might
INSERT… ON CONFLICT
cause a conflict, and then redirect the operation as an update.
Example
Using the clause to handle a similar scenario as shown for the Oracle command:
ON ONFLICT MERGE
demo=> CREA TE TABLE EMP_BONUS (
EMPLOYEE_ID NUMERIC,
BONUS_YEAR VARCHAR(4),
SALA RY NUMERIC,
BONU S NUMERIC,
PRIMARY KEY (EMPLOYEE_ID, BONUS_YEAR));
demo=> INSERT INTO EMP_BONUS (EMPLOYEE_ID, BONUS_YEAR, SALARY)
SELE CT EMPLOYEE_ID,
EXTRACT(YEAR FROM NOW()),
SALARY
FROM EMPLOYEES
WHER E SALARY  SELE CT * FROM EMP_BONUS;
employee_id | bonus_year | salary | bonus
-------------+------------+---------+----------
103 | 2017 | 9000.00 | 4500.000
10 4 | 2017 | 6000.00 | 3000.000
10 5 | 2017 | 4800.00 | 2400.000
106 | 2017 | 4800.00 | 2400.000
107 | 2017 | 4200.00 | 2100.000
10 9 | 2017 | 9000.00 | 4500.000
11 0 | 2017 | 8200.00 | 4100.000
111 | 2017 | 7700.00 | 3850.000
112 | 2017 | 7800.00 | 3900.000
113 | 2017 | 6900.00 | 3450.000
11 5 | 2017 | 3100.00 | 1550.000
11 6 | 2017 | 2900.00 | 1450.000
117 | 2017 | 2800.00 | 1400.000
118 | 2017 | 2600.00 | 1300.000
…
Running the same operation multiple times using the clause does not generate an error
ON CONFLICT
because the existing records are redirected to the update clause.
76