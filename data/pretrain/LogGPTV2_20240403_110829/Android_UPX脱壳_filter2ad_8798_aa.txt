# Android UPX脱壳
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 写在前面
因为我不是pc平台过来的，而是直接从Android入门的，所以upx壳其实一开始并不了解，后来接触到，但是可以直接动态调试或者做个内存快照，对我来说加没加upx其实对我逆向分析影响不大。另一方面upx壳因为开源且其实有很多脱壳的教程，所以一直觉得有些过时、保护力度不足，似乎不值得花太多时间再去深入。但是有些公司的面试官不这么觉得，似乎对于他来说，你说会写vmp但是不了解upx脱壳修复很可笑，所以趁着假期把这个坑补上。
基于快速解决问题的原则，搜了一些upx脱壳的文章，大概可以分为两类。  
1：是基于你熟悉upx源码的情况下，梳理出逻辑和数据结构，dump修复等。  
2：是基于经验、特征，直接定位特征代码，断点、dump修复等。
对于1是我想要的，但是大概看了下upx源码似乎还挺大，Android加upx壳问题很多且并没有修复，加上没想过修复upx壳的bug(我的强迫症比较严重，如果看完源码我很难能停下不去修复bug)，所以最后放弃了这条路。
对于2，找到的一些文章很多是pc平台的，Android的还是较少的，且似乎有些藏着掖着的嫌疑，当然也许是个人的主观判断，我也不想再搜或者去推敲不明确的地方，不如直接自己来吧，看能不能黑盒推理出来。
## 分析
找了个第三方app内加了upx壳的so，没有clone upx对自己的so加壳。
首先看一下这个加了upx壳的so的数据结构，第一个可读可执行的段包含了代码段，干脆就叫代码段吧。
代码段大小为136728=0x21618，加载到内存是4096/一页对齐，那么占用内存大小为0x22000。而接下来的数据段在内存中偏移是0x3dee8，那么起始页应该是0x3d000，0x3d000-0x22000=0x1b000，数据段和代码段隔了27页，太不正常了，一般编译出来的so相隔1页，所以应该是upx改的，但是这个数据段的偏移是编译时确定的，upx肯定不可能反汇编所有代码修改偏移，所以这个数据段的偏移是没有问题的，而且p_offset=0x21ee8，和p_vaddr也是相差一页的。所以可以推理出应该是改了代码段的大小，原来的代码段大小肯定不是0x21618，应该是在0x3b000-0x3d000之间(考虑到一般正常so会设置一页的间隔，那么可以缩小范围到0x3b000-0x3c000之间)。
###  为什么数据段的偏移是不能改的
如果对elf不是特别熟悉的话，这里我以一个正常的so为例来看下为什么说这个数据段的偏移是不能改的，
代码中从是偏移为3f004的地址取数据，这是经过ida优化的，实际指令含义不是这样，我们去掉优化(当然这样也还没完全去掉优化，你可以自己再解析指令，0x3a8c0是存储在指令后面的，现在是条LDR伪指令)。
可以看到R1寄存器存储的是0x3a8c0，0x3a8c0+0x4740+4(流水线)=0x3f004。指向的是.data节(这个节在数据段)。
通过上面的例子可以发现代码中取数据是写死的偏移值，而这个.data中的数据实际是在so文件的0x23000偏移开始的，但是在内存中是加载到0x3f000偏移处的。
所以这个偏移值在代码里面写死了，除非反汇编所有代码，解析出所有对内存的访问修改偏移值，基本上是不现实的，因为有花指令、运行时确定pc等操作会导致反汇编无法正确区分汇编指令和数据(这也是写arm
vmp遇到无法完美解决的问题)。所以.data以至整个数据段都是要符合这个偏移的。
###  观察内存
经过推理得出代码段大小被修改了，结合着之前听说的upx壳的原理，那么应该是真实代码段被压缩或者加解了，之后会覆盖内存中的代码段。
写一个app把so加载到内存中
    c948e000-c9491000 r-xp 00000000 103:37 693882                            /data/app/com.zhuo.tong.elf_fix-rnY3xpLMrzuqsfXFyaWTRw==/lib/arm/libxx.so
    c9491000-c94ca000 r-xp 00000000 00:00 0
    c94ca000-c94cb000 ---p 00000000 00:00 0
    c94cb000-c94cd000 r--p 00021000 103:37 693882                            /data/app/com.zhuo.tong.elf_fix-rnY3xpLMrzuqsfXFyaWTRw==/lib/arm/libxx.so
    c94cd000-c94ce000 rw-p 00023000 103:37 693882                            /data/app/com.zhuo.tong.elf_fix-rnY3xpLMrzuqsfXFyaWTRw==/lib/arm/libxx.so
    c94ce000-c9521000 rw-p 00000000 00:00 0                                  [anon:.bss]
0xc94ca000-0xc948e000=0x3c000,符合之前的推测：0x3b000-0x3c000之间。所以这部分才是真实的代码段。数据段的起始就是c94cb000+0xee8，再加上内存占用344964，得到0xC952026C，内存对齐后得到0xC9521000，刚好对的上。所以可以把0xc948e000-0xc9521000都dump下来(修改内存权限，间隔的部分没有读的权限)，也可以不dump
c94ce000-c9521000，因为这部分是bss节，不占用so空间，也可以只dump代码段0xc948e000-0xc94ca000。
dump的区间不同那么修复起来也是有些差别的。为了文章逻辑不乱掉，把修复放在后面。
###  验证
对dump下来的文件进行验证，拖入ida，忽略解析错误。
未脱壳之前的so，导出了JNI_OnLoad,记下地址，跳到dump的so的相应地址。
可以确定已经解密出真实的指令了，所以对于dump来说完全是可以脱离其他分析、调试的。