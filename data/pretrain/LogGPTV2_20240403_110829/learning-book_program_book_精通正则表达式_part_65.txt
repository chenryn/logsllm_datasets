1.4.2和1.5.0之间的差异
Differences Betueen 1.4.2 and 1.5.0
相对Java1.4.2，Java1.5.0添加了许多新的方法。大多数新的方法主要是为了支持Matcher
的检索范围。此外，Unicode支持也升级并提高了效率。所有的变化都在下面两节详细介绍
（注9)。
1.5.0中的新方法
与检索范围相关的Matcher方法都没有出现在Java1.4.2中：
region
regionStart
regionEnd
useAnchoringBounds
hasAnchoringBounds
useTransparentBounds
hasTransparentBounds
Java1.4.2也不包含下面的方法：
toMatchResult
hitEnd
requireEnd
usePattern
tostring
Java1.4.2不包含下面这个static方法：
Pattern.quote
1.4.2和1.5.0关于Unicode支持的差异
1.4.2和1.5.0在Unicode相关的问题上有这些变化：
·Java1.4.2的Unicode使用的是UnicodeVersion3.0.0，1.5.0使用的是UnicodeVersion
4.0.0。这个改变影响到很多方面，例如字符的定义（例如，在Version3.0.0中，\uFFFF
之后是没有代码点的），以及属性和Unicode区块的定义。
增强了通过\p（）和“\P{…）引用区块的方式（参加Java关于character.
UnicodeBlock的文档，得到区块列表及其正式名称）。
注9：递归结构（?1）：未在文档中说明，在Java1.4.2中是非正式提供的，在1.5.5中已经不再包
含。PCRE也是如此，但是Java没有在文档中说明，我们在这里用脚注来说明。
---
## Page 429
Java版本差异
403
Java1.4.2中的规则是“去掉官方代码块名字中的空格，和开头的In”。这样，区块引
用就类似\p（InHangulJamo）和\p(InArabicPresentationForms-A)。
1.5.0添加了两种新的区块命名。可以在官方块名称之前直接添加‘In'，所以名字可
以为\p(InHangul·Jamo）和\p{InArabic·Presentation*Forms-A)。也可以给Java的
区块标识符添加前缀“In”（是官方名称，将空格和连字符替换为下画线）
p(InHangul_Jamo}和\p(InArabic_Presentation_Forms_A)。
Java1.4.2存在一个古怪的bug，ArabicPresentationForms-B和LatinBxtended-B
结尾的“B”必须写作“Bound”，也就是说\p（InArabicPresentationForms-Bound）
和\p(InLatinExtended-Bound)。
·
Java1.5.0中character类的isSomeing方法支持正则表达式（369）。
1.5.0和1.6之间的差异
Differences Befoeen 1.5.0 and 1.6
写作本书时已经发布的1.6和1.5.0在正则表达式的问题上只有两个细微的差别：
·Java1.6提供了之前没有的对Pi和Pf的Unicode分类的支持。
Q…\Ei结构的bug已经修正了，所以在字符组中可以正常工作。
---
## Page 431
第
章
.NET
NET
Microsoft的.NETFramework中可以使用VisualBasic、C#和C++（以及其他许多语言），.NET
提供了公用的正则表达式库，统一了不同语言之间的正则表达式语意。它的引擎特性完备，
功能强大，容许我们在速度和便利之间求得最大的均衡（注1）。
每种语言在处理对象和方法时都有不同的语意，但是某些基本的对象和方法在所有语言中
都是相通的，所以不管使用哪种语言编写的复杂例子，都可以直接转换到.NET语言套件中
的其他语言中。本章中的例子使用VisualBasic。
与之前各章的联系在开始本章的内容之前必须说明，第1到6章的基础知识对理解本章非
常重要。我猜测，有些只对NET有兴趣的读者可能会从本章开始阅读这本书，我希望他们
认真地读一读前言（尤其是体例部分）和前面的章节：第1、2、3章介绍了与正则表达式
相关的基本概念、特性和技术，第4、5、6章介绍了一些理解正则表达式的关键知识，它
们可以直接应用到.NET的正则表达式中。前几章讲解的重要概念包括NFA引擎进行匹配的
接下来要强调的是，除了用于速查列表一例如本章的第407页，和第3章从第114页到
第123页，我并不希望这本书成为参考手册，而希望它成为精通正则表达式的详细教科书。
注1：本书针对.NETFrameworkVersion2.0（随同VisualStudio2005一起发售）。
---
## Page 432
406
第9章：.NET
本章首先介绍.NET的正则流派，包括元字符的支持事宜，以及.NET程序员必须面对的特殊
问题。然后是总括.NET中正则表达式相关的对象模型，详细讲解居于核心地位的，与正则
表达式相关的类。最后用例子来说明，如何将预先构建好的正则表达式封装到共享的装配
件（assembly）中，组成个人的正则表达式库。
.NET的正则流派
NET's Regex Flavor
NET使用的是传统型NFA引擎，所以第4、5、6章讲解的NFA的知识都适用于.NET。下
一页的表9-1简要说明了.NET的正则流派，其中大部分已经在第3章介绍过。
在接收正则表达式的函数和结构中设置标志位（flag），或是在正则表达式之内使用
（?modes-modes）和（?mods-mods：")结构，可以使用不同的匹配模式，流派的许多方
面也会因此发生变化（110)。408页的表9-2列出了这些模式。
（）电1N，中其
C#的verbatim字符串（@"\w"）中。C++的语言没有提供针对正则表达式的字符串文字，所
以正则表达式中的反斜线在字符事文本中需要双写（-\\w"）。请参考“作为正则表达式的
字符事”（101）。
下面是对表9-1的补充说明：
①\b只有在字符组内部才作为退格符。在字符组之外，\b匹配单词分界符（133)。
\x##容许出现两位十六进制数字，例如\xPCberi匹配‘aber”。
\u####容许且只容许四位十六进制数字，例如\u00rCber;匹配‘aber’，\u20AC匹
配心。
②.NETFrameworkVersion2.0中的字符组支持集合减法，例如[a-z-[aeiou]]i表示小写
的非元音ASCII字母（125）。在字符组内部，连字符之后又跟着字符组表示字符组的
减法运算，减去后面字符组内部的字符。
③\w、\d和\s（以及对应的\w、\D和\s）通常能处理所有合适的Unicode字符，但是如
果启用了RegexOptions.ECMAScript（412），就只能处理ASCII字符。
在此默认模式下，\w匹配Unicode属性\p（Ll）、\p（Lu）、\p（Lt）、\p（Lo）、\p（Nd）
和\p（Pc）。请注意，其中井没有\p（Lm）（请参考第123页的属性列表）。
---
## Page 433
NET的正则流派
407
表9-1：NET正则表达式流派概览
字符缩略表示法
115 (c)
\a[\b]\e\f\n\r\t\v\octal\x##\u####\cchar
字符组及相关结构
118
字符组：【…][]（可包含集合运算符125）
119
几乎任何字符：点号（根据模式的不同，有各种含义）
120 (c)
字符组缩略表示法：\w\d\s\W\D\S
121(c)
Unicode属性和区块：\p（Prop）\P（Prop)
锚点及其他零长度断言
129
行/字符串起始位置：\A
129
行/字符串结束位置：S\z\Z
130
当前匹配的起始位置：IG
133
单词分界符：\b\B
133
环视结构：（？=….）（？1….）（？.）
409
命名捕获及回潮：（?…）\k
137
仅分组的括号：（？：…）
139
固化分组：（?>）
139
多选结构：1
141
匹配优先量词：*+？（n）（n，）（x,y）
141
忽略优先量词：*？+？？？（n）？（n，）？（x,y）？
109
条件判断：（?ifthenlelse）-“if”部分可以是环视、（num）或（name）
（c）—可用于字符组内部
①.…见说明
在默认模式下，\s匹配[\f\n\r\t\v\x85\p（Z）]s,U+0085是Unicode中的NEXTLINE
控制字符，\p（Z）匹配Unicode的“分隔符”字符（122）。
④\p(…)和\P(…)支持标准的Unicode属性和区块（针对UnicodeVersion4.0.1）。不支持
Unicode字母表。
区块名要求出现‘Is’前缀（参考第125页的表格），只能够使用含有空格或者下画线
的格式。例如，\p（Is_Greek_Extended）和\p(Is Greek Extended）是不容许的，正
确的只有\p{IsGreekExtended）。
---
## Page 434
408
第9章：.NET
.NET只支持\p（Lu)之类的短名称，而不支持\p(Lowercase_Letter）之类的长名称。
单字母属性也要求使用花括号（也就是说，不能把\p（L）简记为\pL)。请参考第122
和第123页的表格。
.NET也不支持特殊的复合属性\p(L&），以及特殊属性\p（All）、\p（Assigned）和
\p{Unassigned)。相反，你可以使用（?s：.）、\P(Cn）、\p(Cn）分别来代替。
③\G表示上一次匹配的结束位置，虽然文档介绍说它表示本次匹配的开头位置（130）。
顺序环视和逆序环视中都可以使用任意形式的正则表达式。就我所知，.NET正则引擎
是唯一容许在逆序环视中出现能够匹配任意长度文本表达式的引擎（?133）。
RegexOptions.ExplicitCapture选项（也可通过模式修饰符（?n)设定）会禁止普通
的（…）括号的捕获功能。不过明确命名的捕获型括号一例如（?\d+）一仍
然有效（138）。如果使用了命名分组，此选项容许你使用更加美观的（），而不是
（？："），来进行纯粹的分组。
表9-2：NET的匹配模式和正则表达式模式
RegexOptions选项
（?mode）说明
.Singleline
S
点号能匹配任何字符（111）
.Multiline
扩展和'S的匹配（111）
.IgnorePatternWhitespace
设置宽松排列和注释模式（72）
.IgnoreCase
1
进行不区分大小写的匹配
.ExplicitCapture
n
关闭（….)的捕获功能，只有（?….）能
够捕获（412）
.ECMAScript
限制w、\s和d只对ASCII字符有效（r412）
.RightToLeft
传动装置的驱动过程不变，但是方向相反（从字
符串的末尾开始，向开头移动）。不幸的是这个
选项会有问题（411）
.Compiled
多花些时间优化正则表达式，这样应用时匹配更
迅速（410）
---
## Page 435
.NET的正则流派
409
对于流派的补充
AdditionalCommentsontheFlaoor
下面介绍一些其他的相关细节。
命名捕获
.NET支持命名捕获（138），它通过（?）或是（？'name"…）实现。这两种办法
是等价的，可以随意选用其中一种，不过我更喜欢，因为我相信使用它的人多一些。
要反向引用命名捕获匹配的文本，可以使用ki或是k'name'l。
在匹配之后（也就是Match对象生成之后；下文从第416页开始概要介绍.NET的对象模型），
命名捕获匹配的文本可以通过Match对象的Groups（name）属性来访问（C#使用
Groups[name])。
在replacement字符串中（424)，命名捕获的结果通过s(name）来访问。
某些情况下，可能需要按数字顺序访问所有的分组，所以命名捕获的分组也会被标上序号。
它们的编号从所有未命名的分组之后开始：
113
322
[（+B\）（+P\）（M\）
本例中，我们可以用Groups（“Num")或Groups（3）来访问d+i匹配的文本。这两个名字对
应同一个分组。
不幸的结果
一般情况下不应该把正常的捕获型括号和命名捕获混合起来，不过如果你这样做了，就必
须彻底理解捕获分组的编号顺序。如果捕获型括号用于Split（425），或者在replacement
字符串中使用了S+’（424)，编号就很重要。
条件测试
使用捕获分组的编号，或者是命名分组的名字。这里出现的纯文本（或者纯正则表达式）
会被自动当作肯定型顺序环视来处理（也就是说，可以将其看作（？=…)包围的结构）。这