### Blocking Computation Until Client Time is Delivered
The computation can be blocked until the time measured on the client is delivered to the server, allowing the process to continue.

### Accessing Third-Party Servers
A systematic approach to handling client-side code accessing third-party servers involves tunneling these accesses through the server. This is necessary for servers in different domains due to JavaScript's same-origin policy. Centralizing access to external data benefits both the replica and the client-side code. Since calls to external services are made only once, this also addresses the issue of non-idempotent calls with side effects. We assume that the client-side code does not interact with other JavaScript, as replicating such interactions is complex. All client-side JavaScript code is generated by Volta.

### Scheduling Issues
JavaScript provides a single-threaded execution environment, but non-determinism can still arise from the use of timers (e.g., `setTimeout` and `setInterval`). Other projects have focused on deterministic replay of multi-threaded software. For simplicity, we currently disallow timers in RIPLEY. Logging and replaying event processing order is possible, but it adds complexity.

### Offline Storage
Our emulator supports a cookie-based data store, faithfully replicating the data stored in the browser. While we have not experimented with other forms of offline storage like Gears, we believe they can be supported similarly. RIPLEY provides a model for offline execution: events and RPCs are buffered until the client reconnects, at which point the entire offline client-side execution is replayed within the replica. Offline persistent storage can also be supported by RIPLEY, provided the user has no privacy objections to sending their data to the server.

### Browser Enhancements
Small changes to the JavaScript interpreter can help secure event capture and delivery, addressing sources of non-determinism. Instrumenting `Math.Random` and `Date` routines, as well as event handlers, ensures that malicious JavaScript code cannot access this data. Event capture outside of JavaScript can reduce overhead.

### Plugins and Other Client-Side Code
RIPLEY is not designed to interoperate with plugins running within the page. The RIPLEY model targets standalone deployment within an HTML frame. Allowing other code to co-exist within the same frame, as in a mash-up, can compromise agreement with the replica, as co-located scripts can modify global data structures and client-side code.

## Performance and Scalability
The RIPLEY model offers several optimization opportunities:

### 0-Latency RPCs
An advantage of the RIPLEY architecture is that, once computed, RPC results can be actively pushed to the client. When the RPC is finally issued, its result will already be available, leading to 0-latency RPCs. This form of pre-fetching makes the application more responsive, especially for CPU-intensive workloads.

### MAC-ing RPCs
To reduce network overhead, we can send message authentication codes (MACs) of RPCs instead of their actual values.

### Deployment Strategy
RIPLEY integrates well with traditional load-balancing approaches for large-scale Web 2.0 applications. A load balancer can direct the same user to the server where both the replica and the corresponding server threads run. This functionality is implemented in the RIPLEY checker, which looks up the appropriate APPDOMAIN for a user session. To save memory, both the server thread and the replica can be serialized during high server load and brought back from disk.

### Dependency Analysis
Not all client-side code needs to be included in the replica. Display code, for example, does not need to run on the server because the replica is "headless." To further reduce the amount of code the replica must run, we can use a slicing analysis to include only the portion of the client-side code that contributes to values in RPCs. This is left as future work.

## Related Work
The security of web infrastructure has been extensively studied, with approaches categorized into four main areas: static and runtime protection, web programming models, untrusted clients, and replication and replay for security.

### Analysis and Monitoring
Static and runtime protection techniques have been used to improve the security of traditional "Web 1.0" applications. Static analysis helps avoid issues like cross-site scripting, while runtime analysis allows for exploit prevention and recovery. Projects like WebSSARI, Griffin, and others have improved static and dynamic analysis for PHP and Java. These techniques can be used in conjunction with RIPLEY by applying them to the complete code base, including the client and server subprograms.

### Web Programming Models
Tier-splitting has been proposed in various systems, such as Links, Hop, and Hilda. RIPLEY is the first realistic security solution for these frameworks. BASS, another recent attempt, builds security into a declarative high-level web programming model. However, BASS does not deal with client-side scripting, whereas RIPLEY works in a model where a significant portion of the application runs on the client for enhanced responsiveness.

### Untrusted Clients
Protection against untrusted clients and eavesdropping over the network has been a focus, especially in online gaming. Jha et al. propose random audits of the client state to ensure integrity. RIPLEY, in contrast, provides a non-probabilistic guarantee of integrity, though at a potentially higher cost.

### Replication and Replay for Security
Replication is a known way to increase security assurance, previously studied in file systems and replicated state machines. Zheng et al.'s work is closest to ours, focusing on splitting programs while conforming to integrity and privacy policies. Unlike their approach, RIPLEY avoids using annotations, making it easier to retrofit into existing code. RIPLEY also addresses benign users in a "malicious environment," such as a propagating JavaScript worm, by detecting discrepancies between the client and the replica.

### Conclusion
RIPLEY is the first fully automated approach to ensuring the integrity of distributed web applications. We have applied RIPLEY to five realistic AJAX applications, demonstrating minimal performance overhead in terms of CPU, memory, and network usage. While our work is demonstrated in the context of the Volta compiler, the ideas of code replication can be extended to other runtime environments like Silverlight or server-side JavaScript. We believe RIPLEY may become an important building block for trustworthy distributed applications, following the secure-by-construction philosophy.