* **线性化（linearizable）**
  表现为系统中只有一份透过原子操作更新的资料副本。请参阅“[线性一致性](ch9.md#线性一致性)”。
* **区域性（locality）**
  一种效能最佳化方式，如果经常在相同的时间请求一些离散资料，把这些资料放到一个位置。请参阅“[查询的资料区域性](ch2.md#查询的资料区域性)”。
* **锁（lock）**
  一种保证只有一个执行绪、节点或事务可以访问的机制，如果其它执行绪、节点或事务想访问相同元素，则必须等待锁被释放。请参阅“[两阶段锁定](ch7.md#两阶段锁定)”和“[领导者和锁](ch8.md#领导者和锁)”。
* **日志（log）**
  日志是一个只能以追加方式写入的档案，用于存放资料。预写式日志用于在储存引擎崩溃时恢复资料（请参阅“[让B树更可靠](ch3.md#让B树更可靠)”）；结构化日志储存引擎使用日志作为它的主要储存格式（请参阅“[SSTables和LSM树](ch3.md#SSTables和LSM树)”）；复制型日志用于把写入从领导者复制到追随者（请参阅“[领导者与追随者](ch5.md#领导者与追随者)”）；事件性日志可以表现为资料流（请参阅“[分割槽日志](ch11.md#分割槽日志)”）。
* **物化（materialize）**
  急切地计算并写出结果，而不是在请求时计算。请参阅“[聚合：资料立方体和物化检视](ch3.md#聚合：资料立方体和物化检视)”和“[物化中间状态](ch10.md#物化中间状态)”。
* **节点（node）**
  计算机上执行的一些软体的例项，透过网路与其他节点通讯以完成某项任务。
* **规范化（normalized）**
  以没有冗余或重复的方式进行结构化。在规范化资料库中，当某些资料发生变化时，你只需要在一个地方进行更改，而不是在许多不同的地方复制很多次。请参阅“[多对一和多对多的关系](ch2.md#多对一和多对多的关系)”。
* **OLAP（Online Analytic Processing）**
  线上分析处理。透过对大量记录进行聚合（例如，计数，总和，平均）来表征的访问模式。请参阅“[事务处理还是分析？](ch3.md#事务处理还是分析？)”。
* **OLTP（Online Transaction Processing）**
  线上事务处理。访问模式的特点是快速查询，读取或写入少量记录，这些记录通常透过键索引。请参阅“[事务处理还是分析？](ch3.md#事务处理还是分析？)”。
* **分割槽（partitioning）**
  将单机上的大型资料集或计算结果拆分为较小部分，并将其分布到多台机器上。也称为分片。见[第六章](ch6.md)。
* **百分位点（percentile）**
  透过计算有多少值高于或低于某个阈值来衡量值分布的方法。例如，某个时间段的第95个百分位响应时间是时间t，则该时间段中，95%的请求完成时间小于t，5%的请求完成时间要比t长。请参阅“[描述效能](ch1.md#描述效能)”。
* **主键（primary key）**
  唯一标识记录的值（通常是数字或字串）。在许多应用程式中，主键由系统在建立记录时生成（例如，按顺序或随机）; 它们通常不由使用者设定。另请参阅次级索引。
* **法定人数（quorum）**
  在操作完成之前，需要对操作进行投票的最少节点数量。请参阅“[读写的法定人数](ch5.md#读写的法定人数)”。
* **再平衡（rebalance）**
  将资料或服务从一个节点移动到另一个节点以实现负载均衡。请参阅“[分割槽再平衡](ch6.md#分割槽再平衡)”。
* **复制（replication）**
  在几个节点（副本）上保留相同资料的副本，以便在某些节点无法访问时，资料仍可访问。请参阅[第五章](ch5.md)。
* **模式（schema）**
  一些资料结构的描述，包括其栏位和资料型别。可以在资料生命周期的不同点检查某些资料是否符合模式（请参阅“[文件模型中的模式灵活性](ch2.md#文件模型中的模式灵活性)”），模式可以随时间变化（请参阅[第四章](ch4.md)）。
* **次级索引（secondary index）**
  与主要资料储存器一起维护的附加资料结构，使你可以高效地搜寻与某种条件相匹配的记录。请参阅“[其他索引结构](ch3.md#其他索引结构)”和“[分割槽与次级索引](ch6.md#分割槽与次级索引)”。
* **可序列化（serializable）**
  保证多个并发事务同时执行时，它们的行为与按顺序逐个执行事务相同。请参阅第七章的“[可序列化](ch7.md#可序列化)”。
* **无共享（shared-nothing）**
  与共享记忆体或共享磁碟架构相比，独立节点（每个节点都有自己的CPU，记忆体和磁碟）透过传统网路连线。见[第二部分](part-ii.md)的介绍。
* **偏斜（skew）**
  各分割槽负载不平衡，例如某些分割槽有大量请求或资料，而其他分割槽则少得多。也被称为热点。请参阅“[负载偏斜与热点消除](ch6.md#负载偏斜与热点消除)”和“[处理偏斜](ch10.md#处理偏斜)”。
  时间线异常导致事件以不期望的顺序出现。请参阅“[快照隔离和可重复读](ch7.md#快照隔离和可重复读)”中的关于读取偏差的讨论，“[写入偏差与幻读](ch7.md#写入偏差与幻读)”中的写入偏差以及“[有序事件的时间戳](ch8.md#有序事件的时间戳)”中的时钟偏斜。
* **脑裂（split brain）**
  两个节点同时认为自己是领导者的情况，这种情况可能违反系统担保。请参阅“[处理节点宕机](ch5.md#处理节点宕机)”和“[真相由多数所定义](ch8.md#真相由多数所定义)”。
* **储存过程（stored procedure）**
  一种对事务逻辑进行编码的方式，它可以完全在资料库伺服器上执行，事务执行期间无需与客户端通讯。请参阅“[真的序列执行](ch7.md#真的序列执行)”。
* **流处理（stream process）**
  持续执行的计算。可以持续接收事件流作为输入，并得出一些输出。见[第十一章](ch11.md)。
* **同步（synchronous）**
  非同步的反义词。
* **记录系统（system of record）**
  一个储存主要权威版本资料的系统，也被称为真相的来源。首先在这里写入资料变更，其他资料集可以从记录系统衍生。请参阅[第三部分](part-iii.md)的介绍。
* **超时（timeout）**
  检测故障的最简单方法之一，即在一段时间内观察是否缺乏响应。但是，不可能知道超时是由于远端节点的问题还是网路中的问题造成的。请参阅“[超时与无穷的延迟](ch8.md#超时与无穷的延迟)”。
* **全序（total order）**
  一种比较事物的方法（例如时间戳），可以让你总是说出两件事中哪一件更大，哪件更小。总的来说，有些东西是无法比拟的（不能说哪个更大或更小）的顺序称为偏序。请参阅“[因果顺序不是全序的](ch9.md#因果顺序不是全序的)”。
* **事务（transaction）**
  为了简化错误处理和并发问题，将几个读写操作分组到一个逻辑单元中。见[第七章](ch7.md)。
* **两阶段提交（2PC, two-phase commit）**
  一种确保多个数据库节点全部提交或全部中止事务的演算法。请参阅“[原子提交与两阶段提交](ch9.md#原子提交与两阶段提交)”。
* **两阶段锁定（2PL, two-phase locking）**
  一种用于实现可序列化隔离的演算法，该演算法透过事务获取对其读取或写入的所有资料的锁，直到事务结束。请参阅“[两阶段锁定](ch7.md#两阶段锁定)”。
* **无边界（unbounded）**
  没有任何已知的上限或大小。反义词是边界（bounded）。