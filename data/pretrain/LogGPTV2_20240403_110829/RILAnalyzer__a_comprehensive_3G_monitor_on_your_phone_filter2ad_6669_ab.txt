chose to extend and improve NetworkLog [20], an open source
tool that uses iptables with Nflog target to log packets in
user space. A daemon called Nflog reads and parses netlink
sockets to extract full network and transport layer headers
(Figure 2). Once parsed, the information is sent to Net-
workLogService (Java background service) to identify the
process name for a given PID using the PackageManager
public API. This solution provides a more accurate traﬃc
to app mapping than other approaches that are based on
information available on the /proc ﬁlesystem [7], especially
for short-lived TCP connections and UDP traﬃc.
4.1 Validation
To verify accuracy of the tool we cross-checked the packets
reported by RILAnalyzer against the ones captured by tcp-
dump. We ran 10 series of 100 ICMP packets, at 1 second and
10 ms intervals, DNS lookups to google.com, and HTTP
requests (BBC’s front-page), as well as a full over-night exe-
cution with real user-traﬃc. Exactly the same packets were
logged by both RILAnalyzer and tcpdump.
Accurate packet timing is a hard problem to solve at
the user space: Nflog only reports timestamps for outgo-
ing packets as recorded by the Linux kernel. Consequently,
they need to be added at the time of processing packets
in user-space, which may be signiﬁcantly later than the ac-
tual packet arrival time. This granularity is suﬃcient for
analysing app traﬃc and control-plane interactions as base-
band polling interval is currently limited to 1 second. To
record more accurate timing information both modem ﬁrmware
and Linux kernel require improvements.
Because of the diﬃculty of obtaining control plane infor-
mation, we had to verify that RILAnalyzer correctly logs
such events in two steps. First, we veriﬁed that the vendor-
speciﬁc tool xgoldmon [17] logs control-plane information
correctly by comparing its traces against control-plane traces
obtained from a cellular network testbed. Given xgoldmon’s
verbosity when compared against RILAnalyzer (e.g. it logs
RRC messages which indicate RNC state changes while RIL-
Analyzer logs only RNC states), we only had to verify that
the polling frequency is compatible with the frequency of
occurrence of state changes for basic network operations in
several locations under controlled conditions, and that the
state reported by the tool is correct.
We used the following technique as both tools cannot run
simultaneously on the same handset (due to exclusive use of
the same modem interface). We observed that despite the
diﬀerent types of loads (ICMP pings and TCP packets of dif-
ferent size) and diﬀerent events (3G activation/deactivation)
the resulting RNC state events extracted from xgoldmon
traces were all separated at least by 3-4 seconds, hence the
polling frequency of 1 second is not a limiting factor.
4.2 Performance and limitations
Current RILAnalyzer version is limited to Intel Inﬁneon
XGold chipsets. Some of the most popular Android de-
vices use the chipsets: Samsung Galaxy SII, SIII, Note 2
and Nexus. We tested our system with the SII and SIII
versions. Although the same commands work for LTE net-
works, we could not test them given limited deployment in
Europe. Focusing on single chipsets may induce particular
behavior and interaction problems on its own due to Ven-
dor RIL implementation diﬀerences, however we perform our
case-study (Section 5) on devices shipped with the same ra-
dio baseband, hence we still discover network and applica-
tion diﬀerences accurately. As licensed monitoring tools for
Qualcomm chipsets are available, we expect ﬁnding similar
features in other product vendors. Providing support for
other chipsets is limited by the eﬀort it takes to reverse-
engineer the hidden commands. A more eﬃcient solution
would be for vendors to expose the information to the OS.
We observed CPU and memory consumption of RILAn-
alyzer both idle and under stress conditions on a Samsung
Galaxy S2 (Dual-core 1.2 GHz Cortex-A9). The idle ex-
periment was conducted over three hours with Google Ser-
vices, Skype and Facebook apps active in the background
but without any user interaction. Stress conditions were
simulated using Speedtest application [21]. During the idle
experiment, RILAnalyzer consumed an average of 0.16% of
CPU and 22 MB of physical memory. In this period, appli-
cations generated periodic traﬃc that produced variations
on the CPU consumption that remained below 10%. In the
stress test, at the maximum observed download throughput
(+5 Mbps) the maximum observed CPU consumption was
47% using close to 42 MB of physical memory. The high
memory load is due to the number of diﬀerent components
logging all aspects of the running systems as well as polling
the radio periodically for its state.
The increase is due to the way network packets are logged
by our iptables-based approach: each packet is duplicated
and forwarded to Nflog, annotated with the additional in-
formation as described above and recorded. Because of plat-
form limitations, the current version of the tool is forced to
rely on polling mechanisms to achieve association between
applications, network traﬃc, and cellular state. This adds
computational and energy overheads on embedded systems
like Android, which have aggressive sleeping policies [22].
Although such overheads are not desirable, they would only
be decreased if vendors open their APIs to eﬃciently gather
control plane data within the system.
The current version relies on suﬃcient internal storage to
log data for mid-term studies. The volume of logs generated
is 62±2 bytes per RNC promotion, and 130±10 bytes per
logged packet (including process name). In its current iter-
ation, RILAnalyzer is meant to be used for limited duration
studies as a measurement tool in a real environment, rather
than a data collection app adopted by a large userbase. Nev-
ertheless, we plan to extend the control-plane traces using
other hidden codes, and build an online facility for collect-
ing and processing anonymized data for users, researchers
and developers interested in identifying network and apps
ineﬃciencies.
5. CASE STUDIES
In order to demonstrate RILAnalyzer’s capabilities, we
instrumented eight Samsung Galaxy SII handsets owned by
experienced Android users subscribed to diﬀerent mobile op-
erators. They were asked to run the tool for one complete
week, with their normal set of apps. The logged data ac-
counts for more than 1200 hours of mobile activity. During
this period of time, 70 applications sent or received more
than 2.6M packets, causing +138K RNC transitions (29K
promotions to connected states such as FACH (shared) - and
DCH (dedicated)). Using the data collected with RILAna-
lyzer, we characterize the diversity of RNC state machines
across the diﬀerent networks and their eﬀects on resource
consumption (Section 5.1). Finally, we evaluate the network
costs associated to TCP operations to reach the back-end in-
frastructure in four popular applications (Section 5.2).
5.1 RNC state machine dynamics
In the past, RNC state machine has been modeled using
probes and external power meters [1,9]. Although this iden-
tiﬁed one of the main energy sinks of mobile systems, they
are static and inaccurate as they are obtained “in situ”. In
contrast, we have used RILAnalyzer to record actual device
RNC states and demonstrate that RNC state machines are
much more diverse, necessitating more complex solutions
for improving device performance and energy consumption.
AccuWeather
1 90.9 10.3 12 0.5
0.2
Twitter
Skype
1.5
0.1
Whatsapp
69.2
30 16.4 3.5
3.5
82.5 18.9
n
o
i
t
a
c
i
l
p
p
A
92.7
20.4
0.7
65.6
0.6
0.4
App
Facebook
Google GCM
Skype
WhatsApp
All apps
Hearbeats & FIN (%)
Server-side (%)
3.2
6.1
15.9
47.1
41.0
12.6
69.6
40.2
3.0
58.9
Table 3: Per-App promotions triggered by TCP operations
and initiated by a server
ing RILAnalyzer that TCP heartbeats and FINs (messages
that are driven by these restrictions) alone account for a
signiﬁcant proportion of RNC promotions (Table 3). In the
case of WhatsApp, a large fraction of RNC promotions as-
sociated with these operations are due to TCP hearbeats
maintaining connections, while the others often also include
application-level information.
For network-intensive applications such as Skype and push
notiﬁcation mechanisms, a large portion of total promotions
are triggered by packets sent from the server-side, indicating
where connection maintenance logic is located. On the other
hand, applications such as Facebook rely on Google’s push
notiﬁcations, thus reducing the need to maintain their own
TCP connections. These observations suggest that to reduce
the energy and network overheads of mobile traﬃc, it is
essential to control downlink traﬃc (e.g. using middleboxes
or enhancement proxies) in addition to the classic approach
of controlling uplink on the mobile handset [1, 3, 4, 9, 28].
6. CONCLUSION
In this work we presented a tool which facilitates researchers
to analyze cellular network issues in a new light without re-
quiring access to the internal components of the cellular net-
work. We prototyped the tool, RILAnalyzer, on the Android
platform for popular smartphone devices. RILAnalyzer is
meant to be used outside of laboratory environment and
therefore allows open accurate mobile device measurement
studies across many users, applications, networks and geo-
graphical regions. We evaluated performance of the tool and
discussed its limitations - some of them inherent to running
within a mobile device and not relying on external resources.
We have demonstrated the ability of RILAnalyzer to accu-
rately perform cross-layer analysis on mobile systems. First,
we demonstrated important RNC state machines diﬀerences
across 4 mobile operators in two European countries. Sec-
ond, to demonstrate the strengths of RILAnalyzer, we ex-
posed ineﬃcient connection maintenance logic for a few pop-
ular applications, caused by the large number of backend
systems they rely on and sub-optimal use of TCP. We are
releasing the tool publicly [18] for the mobile research com-
munity to use, extend and improve.
Acknowledgments
This material is based upon work supported by the EPRSC
INTERNET Project, the Department Homeland Security
under Contract N66001-12-C-0128, by the NSF under grant
1213157, and by the European Commission under grant
agreement FP7-318627 (mPlane). The authors would also
like to thank the volunteers, the anonymous reviewers and
our shepherd Aditya Akella (University of Wisconsin-Madison)
for constructive feedback on preparation of the ﬁnal version
of this paper.
Facebook
9.7
0.5
99.4
Google GCM
Gmail
100
100
l
e
g
o
o
G
k
o
o
b
e
c
a
F