respectively, the body e3 is checked with the additional assumption that p (cid:22) q.
Because delegation is a privileged operation, it needs the static authority of
principal p. We extend the set of privileges I to include additional identiﬁers of
the form delegatep(cid:22)q. The constraint ∆ ‘ p (cid:22) π(delegatep(cid:22)q) ensures that
the capability to extend the acts-for hierarchy has been granted by p (T-LetDel in
Figure 8).
E-LetDel says that the body of a let-delegation term is evaluated to a value
ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.
·
28
Stephen Tse and Steve Zdancewic
under the extended acts-for hierarchy, but the original acts-for hierarchy is restored
afterwards. This ensures that the delegation is local to e3.
For simple values that are fully evaluated such as units, injections, principal
names and capabilities (to be introduced in the next subsection), we can forget the
extended delegation (see E-LetUnit, E-LetInl, E-LetInr, E-LetName and E-LetCap
in Figure 9).
For closure values that may contain a delayed computation such as function
closures, polymorphic generalizations and packages, the delayed computation may
capture the delegation constraint. Therefore, for our dynamic semantics to be type-
preserving (Theorem 14), let (X1 (cid:22) X2) in v for such values v becomes a closure
value (see the deﬁnition of values in Figure 6) and auxiliary evaluation rules (see E-
LetApp, E-LetInst and E-LetOpen in Figure 9) are necessary to lift or re-associate
such closures with each computation rule.
4.3 Acquiring capabilities
So far, this paper has not addressed how capability objects are obtained by the
running program. Because capabilities represent privileges conferred to the pro-
gram by run-time principals, they must be provided by the run-time system—they
represent part of the dynamic execution environment. In practice, capabilities may
be created in a variety of ways: the operating system may create an appropriate
set of capabilities after authenticating a user. If the capabilities are implemented
via digital certiﬁcates, then they may be obtained over the network using the un-
derlying PKI. Capabilities may also be generated by the system in response to user
input, for instance after prompting for user conﬁrmation via a secure terminal.
To hide the details of the mechanism for producing capabilities, we model the
external environment as a black box E and write E ‘ X{i} to indicate that envi-
ronment E produces the capability X{i}. Using the expression acquire e . i, where
e evaluates to a run-time principal, the program can query the environment to see
whether a given capability is available. This operation either returns the corre-
sponding capability object X{i} or indicates failure by returning *. See T-Acq,
E-AcqYes and E-AcqNo in Figure 8 and Figure 9.
A common programming idiom is to obtain a run-time capability using acquire,
certify the capability, and, if both checks succeed, act using the newly acquired
abilities:
case (acquire user . declassify)
λcap : C. if (cap ⇒ user . declassify)
(declassify data t) (. . .)
λx : 1. . . .
When written in this way, there appears to be a lot of redundancy in these
constructs. However, for the sake of modularity and ﬂexibility, we separate the
introduction of a capability (acquire) from its validation (the if test) and the
use of the conferred privileges (the declassify). A surface language like Jif, would
provide syntactic sugar that combines the ﬁrst two, the last two, or even all three of
these operations. Treating these features independently also allows more ﬂexibility
for the programmer. For instance, the ability to pass capabilities as ﬁrst class
objects is important in distributed settings, where one host may manufacture a
ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.
Run-time Principals in Information-ﬂow Type Systems
·
29
capability and send it to a second host that can verify the capability and act using
the privileges (see Section 6.2).
5. TYPE-SAFETY
As another theoretical contribution of this paper, we have extended the type-safety
result (Theorem 1) in Section 2 to the full language with downgrading and authority.
This property is speciﬁed as follows.
Theorem 6 (Type-safety).
(1 ) Progress: If A; ; π ‘ e : t, then e = v or A, e −→ A, e0 for some e0.
(2 ) Preservation: If A; ; π ‘ e : t and A, e −→ A, e0, then A0; ; π0 ‘ e0 : t for some
A0 and π0 such that A (cid:22) A0 and π (cid:22) π0.
Remark 7. We have not proved a corresponding noninterference result for λRP
with the run-time authority because in this setting we are primarily concerned with
regulating declassiﬁcation, which intentionally breaks noninterference. Other work
on a very similar language [Tse and Zdancewic 2005] formally proves that well-typed
programs not containing declassiﬁcation or delegation satisfy noninterference.
The rest of this section sets up lemmas necessary to prove progress and preser-
vation of our full language.
5.1 Progress
The canonical form of a value can be uniquely determined by the inversion of typing
rules, except that any value can also be a delegation closure let X1 (cid:22) X2 in v (as
discussed at the end of Section 4.2).
Lemma 8 (Canonical forms).
If A; ; π ‘ v : t, then either v = let X1 (cid:22)
X2 in v0, or one of the following holds:
(1 ) If A; ; π ‘ v : (t1 + t2)l, then v = inl v1, or v = inr v2.
(2 ) If A; ; π ‘ v : ([π2] t1 → t2)l, then v = λx: t. e.
(3 ) If A; ; π ‘ v : (PX)l, then v = X.
(4 ) If A; ; π ‘ v : Cl, then v = X{i}.
(5 ) If A; ; π ‘ v : (∀α (cid:22) p. t)l, then v = Λα (cid:22) p0. e, or v = let X1 (cid:22) X2 in v0.
(6 ) If A; ; π ‘ v : (∃α (cid:22) p. t)l, then v = pack (p (cid:22) p0, e).
(7 ) If A; ; π ‘ v [p] : t, then p = X
Theorem 9 (Progress). If A; ; π ‘ e : t, then e = v or A, e −→ A, e0.
Proof. By induction on typing derivations. In case of T-Unit, T-Name, T-Cap,
T-Fun, or T-All, the expression is a value.
For the subcases when Lemma 8 (canonical forms) is applied, if the form is a
delegation closure, then progress is satisﬁed with some lifting rule described at the
end of Section 4.2. For example, if the term is e = v1 v2 where v1 = let X1 (cid:22)
X2 in v0
1 v2).
1, then e0 = let X1 (cid:22) X2 in (v0
A; ; π ‘ x : t
x : t ∈ ·
—T-Var:
Since the empty term context · cannot contain any variable binding x : t, this
case does not apply.
ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.
·
30
—T-Inl:
Stephen Tse and Steve Zdancewic
A; ; π ‘ e1 : t1
‘ l
A; ; π ‘ inl e1 : (t1 + t2)l
By the induction hypothesis on e1,
(1) e1 = v: e = inl v is a value.
(2) A, e1 −→ A, e0
1: by evaluation context E = inl E, we have e0 = inl e0
1.
—T-Inr: symmetric to T-Inl.
A; ; π ‘ e0 : (t1 + t2)l
A; ; π ‘ v1 : ([π2] t1 → t0)l
A ‘ π2 (cid:22) (π|l)
A; ; π ‘ v2 : ([π2] t2 → t0)l
A; ; π ‘ case e0 v1 v2 : t0 t l
—T-Case:
0: by evaluation context E = case E v1 v2, we have e0 =
By the induction hypothesis on e0,
(1) A, e0 −→ A, e0
0 v1 v2.
case e0
(2) e0 = v: by Lemma 8 (canonical forms),
(a) e0 = inl v0: by E-CaseInl, e0 = v1 v0.
(b) e0 = inr v0: by E-CaseInr, e0 = v2 v0.
A; ; π ‘ e1 : ([π2] t1 → t2)l A; ; π ‘ e2 : t1 A ‘ π2 (cid:22) (π|l)
A; ; π ‘ e1 e2 : t2 t l
—T-App:
By the induction hypothesis on e1 and e2,
(1) A, e1 −→ A, e0
(2) e1 = v and A, e2 −→ A, e0
1: by evaluation context E = E e2, we have e0 = e0
1 e2.
2: by evaluation context E = v E, we have
(3) e1 = v1 and e2 = v2: by Lemma 8 (canonical forms), e1 = λx : t. e0: by
e0 = v e0
2.
E-Fun, e0 = e0{v2/x}.
A; ; π ‘ e1 : (Pp1)l
A, p1 (cid:22) p2; ; π ‘ e3 : t0
A; ; π ‘ e2 : (Pp2)l
A; ; π ‘ e4 : t0
A; ; π ‘ if (e1 (cid:22) e2) e3 e4 : t0 t l
—T-IfDel:
1 (cid:22) e2) e3 e4.
1: by evaluation context E = if (E (cid:22) e2) e3 e4, we have
2: by evaluation context E = if (v (cid:22) E) e3 e4, we
By the induction hypothesis on e1 and e2,
(1) A, e1 −→ A, e0
(2) e1 = v and A, e2 −→ A, e0
2) e3 e4.
e0 = if (e0
have e0 = if (v (cid:22) e0
(a) e1 = X1, e2 = X2 and A ‘ X1 (cid:22) X2: by E-IfDelYes, e0 = e3.
(b) e1 = X1, e2 = X2 and A ‘ X1 6(cid:22) X2: by E-IfDelNo, e0 = e4.
(3) e1 = v1 and e2 = v2: by Lemma 8 (canonical forms),
A; ; π ‘ e1 : (Pp1)l
A, p1 (cid:22) p2; ; π ‘ e3 : t0
A; ; π ‘ e2 : (Pp2)l
A ‘ p1 (cid:22) π(delegatep1(cid:22)p2)
A; ; π ‘ let (e1 (cid:22) e2) in e3 : t0 t l
—T-LetDel:
By the induction hypothesis on e1 and e2,
ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.
Run-time Principals in Information-ﬂow Type Systems
·
31
(1) A, e1 −→ A, e0
(2) e1 = v and A, e2 −→ A, e0
1 (cid:22) e2) in e3.
e0 = let (e0
we have e0 = let (v (cid:22) e0
1: by evaluation context E = let (E (cid:22) e2) in e3, we have
2: by evaluation context E = let (v (cid:22) E) in e3,
(3) e1 = v1 and e2 = v2: by Lemma 8 (canonical forms), e1 = X1 and e2 = X2.
2) in e3.
Then, by induction hypothesis on e3:
(a) A, e3 −→ A, e0
(b) e3 = v: e = let (X1 (cid:22) X2) in v is a value.
3: by E-LetDel, e0 = let (X1 (cid:22) X2) in e0
3.
A ‘ e1 : Cl A ‘ e2 : (Pp)l A; ; (π, p . i)|l ‘ e3 : t0 A; ; π|l ‘ e4 : t0
A ‘ if (e1 ⇒ e2 . i) e3 e4 : t0 t l
—T-IfCert:
By the induction hypothesis on e1 and e2,
(1) A, e1 −→ A, e0
1 ⇒ e2 . i) e3 e4.
(2) e1 = v and A, e2 −→ A, e0
1: by evaluation context E = if (E ⇒ e2 . i) e3 e4, we have
2: by evaluation context E = if (v ⇒ E . i) e3 e4,
e0 = if (e0
we have e0 = if (v ⇒ e0
(a) e1 = X1{i}, e2 = X2 and A ‘ X1{i} ⇒ X2 . i: by E-IfCertYes, e0 = e3.
(b) e1 = X1{i1}, e2 = X2 and A ‘ X1{i1} 6⇒ X2 . i2: by E-IfCertNo,
(3) e1 = v1 and e2 = v2: by Lemma 8 (canonical forms),
2 . i) e3 e4.
e0 = e4.
A ‘ e0 : t2 A ‘ t2 − t1 = s A ‘ s (cid:22) π(declassify)
A ‘ declassify e0 t1 : t1
By the evaluation context E = declassify E t1, or by E-Dcls.
—T-Dcls:
∆; Γ; π ‘ e : t ∆ ‘ p (cid:22) π(endorse)
∆; Γ; π ‘ endorse e p : t u {!p}
—T-Endr:
By the evaluation context E = endorse E t1, or by E-Endr.
A; ; π ‘ e0 : (Pp)l
—T-Acq:
A; ; π ‘ acquire e0 . i : (Cl + 1l)l
0: by evaluation context E = acquire E . i, we have e0 =
By the induction hypothesis on e0,
(1) A, e0 −→ A, e0
0 . i.
(2) e0 = v: by Lemma 8 (canonical forms), e0 = X{i}. Then, either
acquire e0
(a) E ‘ X{i}: by E-AcqYes, e0 = inl X{i}.
(b) E 6‘ X{i}: by E-AcqNo, e0 = inr *.
A; ; π ‘ e0 : (∀α (cid:22) p. t0)l
A; ; π ‘ e0 [p] : t0 t l
—T-Inst:
By the induction hypothesis on e0,
(1) A, e0 −→ A, e0
(2) e0 = v: by Lemma 8 (canonical forms), e0 = Λα (cid:22) p. e1 and p = X: by
0: by evaluation context E = E [p], we have e0 = e0
0 [p].
E-All, e0 = e1{X/α}.
ACM Transactions on Programming Languages and Systems, Vol. TBD, No. TDB, Month Year.
·
32
Stephen Tse and Steve Zdancewic