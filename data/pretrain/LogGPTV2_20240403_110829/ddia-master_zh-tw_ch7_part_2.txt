ACID 一致性的概念是，**对资料的一组特定约束必须始终成立**，即 **不变式（invariants）**。例如，在会计系统中，所有账户整体上必须借贷相抵。如果一个事务开始于一个满足这些不变式的有效资料库，且在事务处理期间的任何写入操作都保持这种有效性，那么可以确定，不变式总是满足的。
但是，一致性的这种概念取决于应用程式对不变式的理解，应用程式负责正确定义它的事务，并保持一致性。这并不是资料库可以保证的事情：如果你写入违反不变式的脏资料，资料库也无法阻止你（一些特定型别的不变式可以由资料库检查，例如外来键约束或唯一约束，但是一般来说，是应用程式来定义什么样的资料是有效的，什么样是无效的。—— 资料库只管储存）。
原子性、隔离性和永续性是资料库的属性，而一致性（在 ACID 意义上）是应用程式的属性。应用可能依赖资料库的原子性和隔离性来实现一致性，但这并不仅取决于资料库。因此，字母 C 不属于 ACID [^i]。
[^i]: 乔・海勒斯坦（Joe Hellerstein）指出，在 Härder 与 Reuter 的论文中，“ACID 中的 C” 是被 “扔进去凑缩写单词的”【7】，而且那时候大家都不怎么在乎一致性。
#### 隔离性
大多数资料库都会同时被多个客户端访问。如果它们各自读写资料库的不同部分，这是没有问题的，但是如果它们访问相同的资料库记录，则可能会遇到 **并发** 问题（**竞争条件**，即 race conditions）。
[图 7-1](../img/fig7-1.png) 是这类问题的一个简单例子。假设你有两个客户端同时在资料库中增长一个计数器。（假设资料库没有内建的自增操作）每个客户端需要读取计数器的当前值，加 1 ，再回写新值。[图 7-1](../img/fig7-1.png) 中，因为发生了两次增长，计数器应该从 42 增至 44；但由于竞态条件，实际上只增至 43 。
ACID 意义上的隔离性意味著，**同时执行的事务是相互隔离的**：它们不能相互冒犯。传统的资料库教科书将隔离性形式化为 **可序列化（Serializability）**，这意味著每个事务可以假装它是唯一在整个资料库上执行的事务。资料库确保当多个事务被提交时，结果与它们序列执行（一个接一个）是一样的，尽管实际上它们可能是并发执行的【10】。
![](../img/fig7-1.png)
**图 7-1 两个客户之间的竞争状态同时递增计数器**
然而实践中很少会使用可序列的隔离，因为它有效能损失。一些流行的资料库如 Oracle 11g，甚至没有实现它。在 Oracle 中有一个名为 “可序列的” 隔离级别，但实际上它实现了一种叫做 **快照隔离（snapshot isolation）** 的功能，**这是一种比可序列化更弱的保证**【8,11】。我们将在 “[弱隔离级别](#弱隔离级别)” 中研究快照隔离和其他形式的隔离。
#### 永续性
资料库系统的目的是，提供一个安全的地方储存资料，而不用担心丢失。**永续性** 是一个承诺，即一旦事务成功完成，即使发生硬体故障或资料库崩溃，写入的任何资料也不会丢失。
在单节点资料库中，永续性通常意味著资料已被写入非易失性储存装置，如硬碟或 SSD。它通常还包括预写日志或类似的档案（请参阅 “[让 B 树更可靠](ch3.md#让B树更可靠)”），以便在磁碟上的资料结构损坏时进行恢复。在带复制的资料库中，永续性可能意味著资料已成功复制到一些节点。为了提供永续性保证，资料库必须等到这些写入或复制完成后，才能报告事务成功提交。
如 “[可靠性](ch1.md#可靠性)” 一节所述，**完美的永续性是不存在的** ：如果所有硬碟和所有备份同时被销毁，那显然没有任何资料库能救得了你。
> #### 复制与永续性
>
> 在历史上，永续性意味著写入归档磁带。后来它被理解为写入磁碟或 SSD。再后来它又有了新的内涵即 “复制（replication）”。哪种实现更好一些？
>
> 真相是，没有什么是完美的：
>
> * 如果你写入磁碟然后机器宕机，即使资料没有丢失，在修复机器或将磁碟转移到其他机器之前，也是无法访问的。这种情况下，复制系统可以保持可用性。
> * 一个相关性故障（停电，或一个特定输入导致所有节点崩溃的 Bug）可能会一次性摧毁所有副本（请参阅“[可靠性](ch1.md#可靠性)”），任何仅储存在记忆体中的资料都会丢失，故记忆体资料库仍然要和磁碟写入打交道。
> * 在非同步复制系统中，当主库不可用时，最近的写入操作可能会丢失（请参阅“[处理节点宕机](ch5.md#处理节点宕机)”）。
> * 当电源突然断电时，特别是固态硬碟，有证据显示有时会违反应有的保证：甚至 fsync 也不能保证正常工作【12】。硬碟韧体可能有错误，就像任何其他型别的软体一样【13,14】。
> * 储存引擎和档案系统之间的微妙互动可能会导致难以追踪的错误，并可能导致磁碟上的档案在崩溃后被损坏【15,16】。
> * 磁碟上的资料可能会在没有检测到的情况下逐渐损坏【17】。如果资料已损坏一段时间，副本和最近的备份也可能损坏。这种情况下，需要尝试从历史备份中恢复资料。
> * 一项关于固态硬碟的研究发现，在执行的前四年中，30% 到 80% 的硬碟会产生至少一个坏块【18】。相比固态硬碟，磁碟的坏道率较低，但完全失效的机率更高。
> * 如果 SSD 断电，可能会在几周内开始丢失资料，具体取决于温度【19】。
>
> 在实践中，没有一种技术可以提供绝对保证。只有各种降低风险的技术，包括写入磁碟，复制到远端机器和备份 —— 它们可以且应该一起使用。与往常一样，最好抱著怀疑的态度接受任何理论上的 “保证”。
### 单物件和多物件操作
回顾一下，在 ACID 中，原子性和隔离性描述了客户端在同一事务中执行多次写入时，资料库应该做的事情：
* 原子性
  如果在一系列写操作的中途发生错误，则应中止事务处理，并丢弃当前事务的所有写入。换句话说，资料库免去了使用者对部分失败的担忧 —— 透过提供 “**宁为玉碎，不为瓦全（all-or-nothing）**” 的保证。
* 隔离性
  同时执行的事务不应该互相干扰。例如，如果一个事务进行多次写入，则另一个事务要么看到全部写入结果，要么什么都看不到，但不应该是一些子集。
这些定义假设你想同时修改多个物件（行，文件，记录）。通常需要 **多物件事务（multi-object transaction）** 来保持多块资料同步。[图 7-2](../img/fig7-2.png) 展示了一个来自电邮应用的例子。执行以下查询来显示使用者未读邮件数量：
```sql
SELECT COUNT（*）FROM emails WHERE recipient_id = 2 AND unread_flag = true
```
但如果邮件太多，你可能会觉得这个查询太慢，并决定用单独的栏位储存未读邮件的数量（一种反规范化）。现在每当一个新讯息写入时，必须也增长未读计数器，每当一个讯息被标记为已读时，也必须减少未读计数器。
在 [图 7-2](../img/fig7-2.png) 中，使用者 2 遇到异常情况：邮件列表里显示有未读讯息，但计数器显示为零未读讯息，因为计数器增长还没有发生 [^ii]。隔离性可以避免这个问题：透过确保使用者 2 要么同时看到新邮件和增长后的计数器，要么都看不到，而不是一个前后矛盾的中间结果。
[^ii]: 可以说邮件应用中的错误计数器并不是什么特别重要的问题。但换种方式来看，你可以把未读计数器换成客户账户余额，把邮件收发看成支付交易。
![](../img/fig7-2.png)
**图 7-2 违反隔离性：一个事务读取另一个事务的未被执行的写入（“脏读”）。**
[图 7-3](../img/fig7-3.png) 说明了对原子性的需求：如果在事务过程中发生错误，邮箱和未读计数器的内容可能会失去同步。在原子事务中，如果对计数器的更新失败，事务将被中止，并且插入的电子邮件将被回滚。