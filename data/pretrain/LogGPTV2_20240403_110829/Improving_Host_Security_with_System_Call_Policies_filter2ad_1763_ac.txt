If requested, Systrace reports the return value of a sys-
tem call to indicate if it was successfully executed or
not. In the case of execve, success indicates that the
monitored process is running a new program and we al-
low the policy to specify if we should detach from the
process or allow a diﬀerent policy to take eﬀect. After
these changes take eﬀect, the execution of the process
is resumed.
Because the security of our system relies on the in-
tegrity of the ﬁlesystem, we assume that it is secure. If
an adversary can control the ﬁlesystem, she may mod-
ify the policies that determine the permissible opera-
tions for monitored applications or replace trusted pro-
grams with malicious code.
2 This does not prevent faulty applications that are written
without proper error handling from misbehaving. In that case,
Systrace may help to identify incorrect exception handling.
Audit trails may be generated by adding the log
modiﬁer to policy statements. An an example, for an
audit trail of all commands a user executes, it is suﬃ-
cient to Systrace her shell and log all the executions of
execve.
The beneﬁt of privilege elevation is the reduction
of privilege an application requires for its execution.
Applications that formerly required root privilege for
their entire lifetime now execute only speciﬁc system
calls with elevated privilege. Other system calls are
executed with the privilege of the user who invoked
the application. The semantics of setuid prevent a user
from debugging privileged applications via ptrace. We
apply the same semantics when policy elevates an ap-
plication’s privilege.
6.2 Policy generation
Policy generation is an often neglected problem. In
order for a sandbox to function correctly, it requires
a policy that restricts an application to a minimal set
of operations without breaking its functionality. To
facilitate policy generation, our policy language allows
policies to be improved iteratively by appending new
policy statements.
We can generate policies automatically by execut-
ing applications and recording their normal behavior.
Each time we encounter a system call that is not part of
the existing policy, we append a new policy statement
that matches the current translated system call.
The resulting policy covers the executed code path
of the application. For applications that randomize
arguments, we post process the policy to make it inde-
pendent of arguments with random components.
For example, when mkstemp("/tmp/confXXXXXX")
creates the ﬁle /tmp/confJ31A69, automatic policy
generation appends a corresponding policy statement:
fswrite: filename eq "/tmp/confJ31A69" then permit
Post processing changes the policy statement so
that it is independent of the randomness and thus
applies to subsequent executions of the application:
fswrite: filename match "/tmp/conf*" then permit
Automatic policy generation and the process of pro-
ﬁling normal application behavior by Hofmeyr et al.[21]
face similar problems. We need to make sure that no
abnormal behavior occurs during policy training and
try to exhaust all possible code paths. However, in-
teractive and automatic policy generation go hand in
hand. We do not require a complete policy to sandbox
an application because we may request a policy deci-
sion from the user if an operation is not covered by the
USENIX Association
12th USENIX Security Symposium 
265
y
c
n
e
u
q
e
r
F
60
50
40
30
20
10
0
65
70
60
50
40
30
20
10
0
85
90
75
80
Number of system calls in policy
Figure 4: Analysis of the number of system calls that
applications are allowed to execute. Most applications
use only sixty to ninety diﬀerent system calls. As average
Unix systems support several hundred system calls, we
disallow the execution of all other system calls to prevent
an adversary from using them to cause damage. Note
that the abscissa origin is not zero.
Figure 5: The cross correlation of the number of policy
violations and the number of program executions allows
us to identify users that exhibit unusual behavior. The
user with the most policy violations is the web server at-
tempting to execute user created CGI scripts.
existing policy.
The feasibility of our approach is demonstrated by
monkey.org, a Unix shell provider in Ann Arbor, who
uses Systrace to sandbox over two hundred users. They
generated separate policies for approximately 250 ap-
plications.
An analysis of the policies shows that applications
are allowed to call seventy one diﬀerent system calls on
average; see Figure 4. Usually Unix systems support
several hundred system calls. When an adversary gains
control over an application, she may attempt to obtain
higher privileges by using all possible system calls3.
By limiting the adversary to only those system calls
required by the application, we reduce her potential to
cause damage.
We notice two peaks, one at sixty four system calls
and the other one at eighty seven. The ﬁrst peak
is caused by policies for standard Unix utilities like
chmod, cat, rmdir or diﬀ all of which have similar poli-
cies. The second peak is caused by identical policies for
the diﬀerent utilities in the MH message system, which
require more system calls for establishing network con-
nections and creating ﬁles in the ﬁlesystem.
Most of the policy statements specify access to the
ﬁlesystem: 24% of them control read access, 6% write
access and 5% the execution of other programs.
3Recently discovered vulnerabilities in Unix operating sys-
tems allow an adversary to execute code in kernel context due
to incorrect argument checking on system calls [9, 29].
6.3
Intrusion Detection and Prevention
The capability for intrusion detection and preven-
tion follows automatically from our design. System
calls that violate the policy are denied and recorded
by the operating system. This prevents an adversary
from causing damage and creates an alert that contains
the restricted operation.
A correct policy restricts an application to only
those operations required for its intended functional-
ity. While this prevents an adversary from harming
the operating system arbitrarily, she may still abuse
an application’s innate functionality to cause damage.
We employ audit trails to log potentially malicious ac-
tivity not prevented by policy.
At monkey.org, Systrace generated approximately
350,000 log entries for 142 users over a time period of
two months. The system is conﬁgured to log all denied
system calls as well as calls to execve and connect. By
correlating the number of programs executed with the
number of policy violations for all users, we identify
those users that exhibit unusual behavior. In Figure 5,
we notice a few users that generate an unproportion-
ally high number of policy violations compared to the
number of programs they execute.
In this case, the
user with the most policy violations is the web server
attempting to execute user created CGI scripts. The
user that executes the most applications without fre-
quent policy violations uses MH to read her email.
266
12th USENIX Security Symposium 
USENIX Association
Mode
Normal
In-kernel
User space
Real time
in µsec
0.35 ± 0.00
0.46 ± 0.01
37.71 ± 0.18
User time
in µsec
0.14 ± 0.03
0.17 ± 0.04
0.30 ± 0.07
System time
in µsec
0.22 ± 0.03
0.28 ± 0.04
5.60 ± 0.61
Figure 6: A microbenchmark to compare the overhead of
a single geteuid system call for an unmonitored process
and for process conﬁnement with diﬀerent policies. Mak-
ing a policy decision in the kernel is considerably faster
than requesting a policy decision from the user space pol-
icy daemon.
6.4 Limitations
Although powerful, policy enforcement at the sys-
tem call level has inherent limitations. Monitoring the
sequence of system calls does not give complete in-
formation about an application’s internal state. For
example, system services may change the privilege of
a process on successful authentication but deny ex-
tra privilege if authentication fails. A sandboxing tool
at the system call level cannot account for such state
changes. However, it is still possible to enforce global
restrictions that state, for example, that root should
never be allowed to login. This is possible because
those restrictions do not depend on an application’s
internal state.
To increase the security of authentication services
like SSH, it is possible to use a combination of privi-
lege separation [30] and system call policy enforcement.
With privilege separation, the majority of an appli-
cation is executed in an unprivileged process context.
Vulnerability in the unprivileged code path should not
lead to privilege escalation. However, in a Unix sys-
tem an unprivileged process can still execute system
calls that allow local network access. Using Systrace
to sandbox the application, we can prevent the unpriv-
ileged process from executing any system calls that are
not necessary for its functionality.
7 Performance
To determine the performance impact of Systrace,
we measured its overhead on the execution time of
single system calls and on several applications. All
measurements were repeated at least ﬁve times on a
1.14 GHz Pentium III running OpenBSD. The results
are displayed as averages with corresponding standard
deviation.
We conduct the microbenchmarks of a single system
Mode
Normal
In-kernel
1-deep
2-deep
3-deep
4-deep
Real time
in µsec
5.52 ± 0.01
5.88 ± 0.03
139.20 ± 0.09
167.72 ± 0.41
198.34 ± 0.67
231.121 ± 0.27
User time
in µsec
0.34 ± 0.20
0.31 ± 0.22
0.56 ± 0.12
0.64 ± 0.18
0.40 ± 0.17
0.43 ± 0.13
System time
in µsec
5.08 ± 0.16
5.55 ± 0.22
15.80 ± 1.01
15.84 ± 1.10
18.28 ± 0.38
19.40 ± 1.39
Figure 7: A microbenchmark to compare the overhead
of the open system call. Due to ﬁlename normalization,
the time to make a policy decision in user space depends
on the number of components in the ﬁlename. Every
component adds about 30 µsec.
call by repeating the system call several hundred thou-
sand times and measuring the real, system, and user
time. The execution time of the system call is the time
average for a single iteration.
As a baseline, we measure the time for a single ge-
teuid system call without monitoring the application.
We compare the result with execution times obtained
by running the application under Systrace with two
diﬀerent policies. The ﬁrst policy permits the geteuid
via the in-kernel policy table. For the second policy,
the kernel consults the user space policy daemon for
a decision. We see that the in-kernel policy evalua-
tion increases the execution time by 31% ± 3% and
that slightly more time is spent in the kernel. When
the kernel has to ask the user space daemon for a pol-
icy decision, executing a single system call takes much
longer, mostly due to two context switches required for
every policy decision. The results are shown in Fig-
ure 6.
The open system call requires more work in the ker-
nel than getuid. A microbenchmark shows that the
in-kernel evaluation of the policy increases the execu-
tion time by 7%± 0.6%. The execution time for a user
space policy decision depends on the depth of the ﬁle
in the directory tree. When the path to the ﬁlename
has only one component, the increase in execution time
is over 25-fold. Each directory component in the path
adds approximately thirty microseconds to the execu-
tion time due to ﬁlename normalization, as shown in
Figure 7.
The last microbenchmark measures the overhead of
using the read system call to read a 1 kbyte buﬀer from
/dev/arandom, which outputs random data created by
a fast stream cipher. There is no noticeable diﬀerence
in execution time and system time increases by less
than 1% for in-kernel policy evaluation. We omit mea-
surement of user space because read requires no user
USENIX Association
12th USENIX Security Symposium 
267
Mode
Normal
In-kernel
in µsec
Real time
37.61 ± 0.03
37.61 ± 0.03
User time
in µsec
0.11 ± 0.11
0.14 ± 0.16
in µsec
System time
37.34 ± 0.10
37.45 ± 0.21
Figure 8: A microbenchmark to compare the overhead
of the read system call when reading a 1 kbyte buﬀer
from /dev/arandom. In this case, there is no measurable
performance penality for the in-kernel policy decision.
File size
in MByte
0.5
1.4
2.3
3.2
4.0
4.9
Normal
0.88 ± 0.04
2.51 ± 0.01
4.15 ± 0.01
5.62 ± 0.01
7.18 ± 0.03
8.55 ± 0.01
Systrace
0.92 ± 0.07
2.52 ± 0.01
4.17 ± 0.01
5.64 ± 0.01
7.18 ± 0.03
8.57 ± 0.02
Increase
in percent
4.5 ± 9.3
0.4 ± 0.6
0.5 ± 0.3
0.4 ± 0.3
0.0 ± 0.6
0.2 ± 0.3
Figure 9: A macrobenchmark comparing the runtime of
an unmonitored gzip process to gzip running under Sys-
trace. Because this benchmark is computationally inten-
sive, policy enforcement does not add a signiﬁcant over-
head.
space policy decision. The results are shown in Fig-
ure 8.
Enforcing system call policies adds overhead to an
application’s execution time, but the overall increase is
small, on average.
Figure 9 compares the runtime of gzip for diﬀerent
ﬁle sizes from 500 kByte to 5 MByte. Gzip executes
thirty system calls per second on average, most of them
read and write. In this case, the execution time is not
signiﬁcantly eﬀected by Systrace, because the applica-
tion spends most of its time computing, and executes
relatively few system calls.
To assess the performance penality for applications
that frequently access the ﬁlesystem, we created a
benchmark similar to the Andrew benchmark [22]. It
consists of copying a tar archive of the Systrace sources,
untarring it, running conﬁgure, compiling the sources
and then deleting all ﬁles in the source code sub-
directory.
During the benchmark, forty four application pro-
grams are executed. We use Systrace to generate poli-
cies automatically, then improve the policies that result
with a simple script. The benchmark executes approx-
imately 137, 000 system calls. A decomposition of the
most frequent system calls is shown in Figure 10. The
system call with the highest frequency is break which is
used to allocate memory. System calls that access the
k
a
e
r
b
40000
35000
30000
25000
20000
15000
10000
5000
y
c
n
e
u
q
e
r
f
l
l
a
c
m