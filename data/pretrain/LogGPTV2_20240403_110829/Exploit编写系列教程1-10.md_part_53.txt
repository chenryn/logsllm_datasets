"\x68\x59\x6f\x75\x20" //
"\x8b\xcc" //movecx,esp=
// thisputsapointertothetextintoecx
//nowputtheparameters/pointersontothestack
//lastparameterishwnd=0.
//clearouteaxandpushittothestack
"\x33\xc0" //xoreax,eax=>eaxisnow00000000
"\x50" //pusheax
//2ndparameteriscaption.Pointerisinebx,sopushebx
"\x53"
//nextparameteristext.Pointertotextisinecx,sodopushecx
"\x51"
//nextparameterisbutton(OK=0).eaxisstillzero
//sopusheax
"\x50"
//stackisnowsetupwith4pointers
//butweneedtoadd8morebytestothestack
//tomakesuretheparametersarereadfromtheright
//offset
//we'lljustaddanoterpusheaxinstructionstoalign
"\x50"
//callthefunction
"\xc7\xc6\xea\x07\x45\x7e" //movesi,0x7E4507EA
"\xff\xe6"; //jmpesi=launchMessageBox
注意：你可以通过简单的指令（ImmunityDebugger：lpvefindaddr）来得到机器码
例子：
或者，你可以从Metasploit工具文件夹用nasm_shell来把汇编指令转化为机器码：
xxxx@bt4:/pentest/exploits/framework3/tools#./nasm_shell.rb
nasm>xoreax,eax
00000000 31C0 xoreax,eax
nasm>quit
回到shellcode，将这个c数组黏贴到“shellcodetest.c”程序中，编译。
然后将shellcode.exe程序载入ImmunityDebugger并在main（）函数开始的地方设个断点（在
这个例子中，比如0x004012D4）。然后按F9，调试器就会侦测到那个断点。
现在步入（F7），在特定的点，一个到[ebp-4]的函数调用。这个是跳转去执行我们的shellcode--
相应的在（int）（*func）（）；在c源代码里有陈述。
在这个调用完之后，CPU窗口是这样的：
这确实是我们的shellcode。首先将“Corelan”入栈，然后把地址存到EBX。然后将另一个
字符串入栈并保存地址到ECX。
接下来，将eax清零（设eax=0），然后将四个参数入栈：第一个0（pusheax），然后指向标
题的指针（pushebx），然后指向Message文本的指针（pushecx），最后是又是0（pusheax）。
然后将另外的4字节入栈（用来对齐）。最后将MessageBoxA的地址放到ESI然后跳到ESI。
按F7直到JMPESI。在JMPESI执行后，查看堆栈窗口：
这就是我们所期待的。继续按F7直到达到CALLUSER32.MessageBoxExA指令（就在5个
PUSH操作后，将参数入栈）。堆栈必须指向正确的参数。
按F9你将会得到这个：
太好了。我们的shellcode工作了。
另一种测试我们的shellcode的方法是用skylined的“Testival”工具。只要将shellcode写入
到一个bin文件中（用pveWritebin.pl），然后运行Testival。我们假设你已经将代码写入到
shellcode.bin：
w32-testival[$]=ascii:shellcode.bineip=$
（不要吃惊这个命令会产生一个崩溃--我将会在一会儿之后解释为什么会发生这个）
这很简单。因此这就是它所有的吗？
很不幸不是。这个shellcode有一些主要的问题：
1、shellcode调用MessageBox函数后，没有做扫尾工作。因此当MessageBox函数返回后，
父进程就会死亡/崩溃，而不是正常退出（或者连崩溃都没有，当它是一个真正的exploit）。
好的，这个不是最主要的问题，但也是一个问题。
2、Shellcode包含null字节。因此如果你想在现实的exploit中用这个shellcode，目标是字符
串缓冲区溢出，它可能不会工作因为null字节会将字符串阻断。这个事实上是主要的问题。
3、Shellcode能工作是因为user32.dll已经映射到当前进程中。如果user32.dll没有加载时，
那个API地址将不会指向MessageBoxA函数，代码将会失败。主要问题--突出问题。
4、Shellcode包含了一个MessageBoxA函数地址的硬编码。如果在其他的windows版本时，
这个地址将会不一样，因此这个shellcode将不会工作。有是主要问题--突出问题。
问题3是用w32-testival命令时shellcode不能工作的主要原因。在w32-testival进程中，
user32.dll没有加载，因此shellcode会失败。
SSSShhhheeeellllllllccccooooddddeeeeeeeexxxxiiiittttffffuuuunnnncccc
在我们的C程序中，调用完MessageBoxAPI后，将会用2个指令退出进程：LEAVE和
RET。在独立的应用程序中shellcode能工作良好，但是我们的shellcode要注入到另一个应
用程序中。因此在调用MessageBox后调用leave/ret很有可能破坏原来的程序，使程序崩溃。
有两种方法来退出我们的shellcode：我们可以尽可能悄无声息的结束一切，但是我们也
可以试着保持父进程继续运行...可能下次还能再次被exploit。
很明显的，如果有特殊的原因不能退出shellcode/进程，那就不要随便这么做。
我将会讨论第三种能够用来退出shellcode的方法：
process:用ExitProcess（）
SEH：强制产生一个异常调用。记住这种方法可能会使exploit代码不停的运行。（如
果那个原始的bug是专门为这个例子设的SEH）
thread：用ExitThread（）
明显的，上面的方法没有一个能确保父进程不会崩溃或者当它被exploit时会继续保持可利
用性。我只是讨论三种技术（顺便提一下，这些在Metasploit上都是有的）：））
EEEExxxxiiiittttPPPPrrrroooocccceeeessssssss（）
这个技术是基于一个windowsAPI“ExitProcess”，可以在kernel32.dll中找到。只有一个
参数：ExitProcess的退出码。它的值在调用这个API前（0意味着一切OK）必须入栈。
在XPSP3上，ExitProcess（）这个API能在0x7c81cb12地址处找到。
因此为了使shellcode正常退出，我们必须把下面的指令加到shellcode的底部，在
MessageBox函数被调用之后。
xoreax,eax ;zeroouteax(NULL)
pusheax ;putzerotostack(exitcodeparameter)
moveax,0x7c81cb12 ;ExitProcess(exitcode)
calleax ;exitcleanly
或者用字节/机器码：
"\x33\xc0" //xoreax,eax=>eaxisnow00000000
"\x50" //pusheax
"\xc7\xc0\x12\xcb\x81\x7c" //moveax,0x7c81cb12
"\xff\xe0" //jmpeax=launchExitProcess(0)
同样的，我们假设kernel32.dll已经被自动加载，因此你可以调用ExitProcessAPI，不用
再做其他的操作。
SSSSEEEEHHHH
退出shellcode的第二种方法（同时使父进程继续运行）是触发一个异常（比如call0x00）
--就像这样：
xoreax,eax
calleax
因为这个代码明显比其他的短，它可能导致不可预期的结果。如果一个异常处理函数已经设
置好，就可以在你的exploit中利用异常处理函数（基于SEH的exploit），然后这个shellcode
就会循环。这在特定的情况下会OK（比如说，举个例子，你试着使机器可利用而不是只exploit
一次）。
EEEExxxxiiiittttTTTThhhhrrrreeeeaaaadddd（）
这个kernel32的函数格式可以http://msdn.microsoft.com/en-us/library/ms682659(VS.85).aspx
处找到。正如你可以看到的，这个函数需要一个参数：退出码（跟ExitProcess（）函数很像）。
除了用IDA查看这个函数的地址外，你也可以用arwin，SteveHanna写的一个小脚本。
（注意：函数名是大小写敏感的）
C:\shellcode\arwin>arwinkernel32.dllExitThread
arwin-win32addressresolutionprogram-bystevehanna-v.01
ExitThreadislocatedat0x7c80c0f8inkernel32.dll
因此只要简单的用ExitThread替换掉ExitProcess后就行了。
从 ddddllllllll文件中提取函数////导入表
正如上面所解释的，你可以用IDA或者arwin来得到函数/函数指针。如果你已经装了
MicrosoftVisualStudioC++Express，你也可以用dumpbin。这个命令行功能可以再C:\Program
Files\MicrosoftVisualStudio9.0\VC\bin中找到。在你用这个功能之前，你将需要获得一份
mspdb80.dll的拷贝（从这里下载here），然后将它放在（bin）文件夹下。
你也可以在一个给定的dll中列出所有的导入表（函数）：dumpbinpath_to_dll/exports
dumpbin.exec:\windows\system32\kernel32.dll/exports
从windows\system32文件夹导出所有的导入表可以这样做：
remScriptwrittenbyPeterVanEeckhoutte
remhttp://www.corelan.be:8800
remWilllistallexportsfromalldll'sinthe
rem%systemroot%\system32andwritethemtofile
rem
@echooff
cls echoExports>exports.log
for/f%%aIN('dir/b%systemroot%\system32\*.dll')
doecho[+]Processing%%a&&
dumpbin%systemroot%\system32\%%a/exports
>>exports.log
（将所有的东西都放在“for/f"这句后面成一行--我把它弄成几行是为了增加可读性）
将这个批处理文件放在bin文件夹下保存。运行这个批处理文件，结束后你将会得到
system32文件夹下的所有dll中的导入表并放在一个文本文件里。因此当你需要一个特定的
函数时，你只要简单的从文本文件中搜素一下就可以了。（记住，输出的地址是用RVA显示
的（相对虚拟地址），因此你需要加上模块/dll的基地址来得到给定函数的绝对地址）。
旁注：用 nnnnaaaassssmmmm来写////产生 sssshhhheeeellllllllccccooooddddeeee
在前面的章节里，我们用C代码转化到汇编指令。只要你对这些汇编指令比较熟悉，你
可以很简单的用汇编来写这些东西，并把它转化为机器码，而不是先解析机器码然后将一切
都直接写入机器码...那种方法比较麻烦，这里有种简单的方法：
先用产生一个由[BITS32]开头的文本文件（不要忘了这个和nasm不会去检测这个是需
要为32位的X86CPU编译的），接着是汇编指令（可以再反汇编/调试器输出中找到）：
[BITS32]
PUSH0x006e616c ;push"Corelan"tostack
PUSH0x65726f43
MOVEBX,ESP ;savepointerto"Corelan"inEBX
PUSH0x00206e61 ;push"YouhavebeenpwnedbyCorelan"
PUSH0x6c65726f
PUSH0x43207962
PUSH0x2064656e
PUSH0x7770206e
PUSH0x65656220
PUSH0x65766168
PUSH0x20756f59
MOVECX,ESP ;savepointerto"Youhavebeen..."inECX
XOREAX,EAX
PUSHEAX ;putparametersonthestack
PUSHEBX
PUSHECX
PUSHEAX
PUSHEAX
MOVESI,0x7E4507EA
JMPESI ;MessageBoxA
XOREAX,EAX ;cleanup
PUSHEAX
MOVEAX,0x7c81CB12
JMPEAX ;ExitProcess(0)
将这个文件保存成msgbox.asm
用nasm编译：
C:\shellcode>"c:\ProgramFiles\nasm\nasm.exe"msgbox.asm-omsgbox.bin
现在用pveReadbin.pl脚本将.bin里的C格式输出成字节：
#!/usr/bin/perl
#PerlscriptwrittenbyPeterVanEeckhoutte
#http://www.corelan.be:8800
#Thisscripttakesafilenameasargument
#willreadthefile #andoutputthebytesin\xformat
# if($#ARGVne0){
print" usage:$0".chr(34)."filename".chr(34)."\n";
exit(0);
}
#openfileinbinarymode
print"Reading".$ARGV[0]."\n";
open(FILE,$ARGV[0]);
binmodeFILE;
my($data,$n,$offset,$strContent);
$strContent="";
my$cnt=0;
while(($n=readFILE,$data,1,$offset)!=0){
$offset+=$n;
}
close(FILE);