title:Policy algebras for access control: the propositional case
author:Duminda Wijesekera and
Sushil Jajodia
Policy Algebras for Access Control – The Propositional
Case∗
Duminda Wijesekera
PI:EMAIL
Sushil Jajodia
PI:EMAIL
Center for Secure Information Systems
George Mason University
Fairfax, VA 22030–4444
ABSTRACT
Although diﬀerent organizations operate under diﬀerent re-
quirements for protection of their data, increasingly there
is a need for organizations to connect their computing re-
sources together to achieve common goals. The fundamental
problem addressed in this paper is to capture the algebra
used in composing access control policies of collaborating
organizations. In doing so, we seek a framework that can be
viewed at many levels of abstraction (such as abstract vs. ex-
plicit or propositional vs. predicate), independent of imple-
mentation mechanisms and environments, and is expressive
enough to model existing practices of policy compositions.
Propositional version consists of a syntax where policies
are viewed as abstract symbols, and semantics consists of au-
thorization state transformers, where an authorization state
is a collection of (subject, object, access set) triples and a set
of propositions satisﬁed by them. Syntactic rules are pro-
vided to simplify policy expressions without knowing their
semantics, thereby supporting algebraic manipulations of
uninterpreted policies. Because our algebra is at an ab-
stract level, it can model any policy independent of the lan-
guage that is used to implement it. We show how to reason
about completeness, consistency, unambiguity and of ab-
stractly speciﬁed policies and their semantic equivalence.
Categories and Subject Descriptors
H.2.7 [Database Management]: Database Administra-
tion—Security, integrity, and protection; K.6.5 [Management
of Computing and Information Systems]: Security and
protection
General Terms
Security, Theory
∗
This work was partially supported by the National Science
Foundation under grant ITR-01113515.
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’01, November 5-8, 2001, Philadelphia, Pennsylvania, USA.
Copyright 2001 ACM 1-58113-385-5/01/0011 ...$5.00.
Keywords
Access control, Security policy, policy composition, policy
algebra
1.
INTRODUCTION
Security policy plays an important role in this era where
computing resources of organizations with diverse privacy
protection and information sharing requirements are increas-
ingly connected together to carry out joint or common tasks.
Examples include coalitions that are formed and torn apart
to carry out joint missions, such as coordinated operations of
the NATO in Bosnia or United Nations forces against Iraq.
Similar requirements exist in the commercial world where
mergers and breakups of organizations are increasingly fre-
quent. Since diﬀerent organizations operate under diﬀerent
requirements for protection and control of their data, in-
evitably their security mechanisms do not share common
principles, are not implemented in similar languages and do
not run on compatible operating platforms.
In order to maintain conceptual coherence of security poli-
cies among collaborating organizations, and to have a com-
mon basis for comparison, we propose an algebra to reﬂect
composition of security policies at a higher level. Towards
achieving this goal, this paper - the ﬁrst of a series - presents
a policy composition framework at the propositional level for
access control policies.
Propositional level refers to the fact that we view policies
as abstract symbols and semantics of policies as nondeter-
ministic transformers of collection of (subject, object, access
set) triples. Accordingly, operations on policies are inter-
preted as relational operators such as union, intersection,
and composition. Advantages of having such a framework
are many. Firstly, it provides descriptions of policies that
are language and implementation mechanism independent.
Such descriptions can be examined for completeness, consis-
tency, and unambiguity. For example, there are well known
examples of policies that are individually consistent, but
taken together they are contradictory. A framework such
as ours facilitate identifying such fallacies. Secondly, it al-
lows speciﬁers of policies to examine if two policies in fact
result in same accesses, which we call semantic equivalence.
Thirdly, it allows speciﬁcation of policies to be decentralized
- i.e., it is possible to specify parts or compositions that are
to be speciﬁed by a particular person or at a a given time,
and leave the rest for appropriate people or times. Fourthly,
it facilitates reuse or compositions of policies that are well-
38speciﬁed and blessed to be error-free.
This work is closely related to the composition framework
for access control policies proposed by Bonatti et al. [5],
where an access control policy is a set of ground (variable-
free) terms over an alphabet for subject, object and action
terms, closed under set theoretical operators of union, inter-
section, diﬀerences, scoping restrictions, etc. and recursive
closure under Horn Clauses. They have policy variables for
yet to be speciﬁed polices in expressions that are replaced
by a collection of (subject, object, action) triples supplied
by an environment. A detailed comparisons to this work
appears in Section 7. Other work in this area are [13, 17],
where a security policies that can be enforced by monitoring
systems encoded as B¨uchii automata. Although the proposi-
tional version of our framework is very close to an automata
theoretic model, our interests are not in fairness or safety
characteristics of their implementations. Again, details ap-
pear in Section 7.
Summary of results reported here are as follows. We
present a propositional version of a policy composition alge-
bra with a syntax consisting of abstract symbols for atomic
policy expressions and composition operators of conjunc-
tion, disjunction, sequencing, recursive closure under rules,
provisioning and scoping. The semantics of policies are in-
terpreted as relational transformers of (subject, object, ac-
cess set) with controlled non-determinism. We provide alge-
braic identities, and show how they can be used to determine
equivalent policies (i.e., policies that permit the same sets
of access for same subject, object pairs). We also show how
these identities can be used to derive suﬃcient conditions
for consistency, completeness, and determinism. Finally, we
compare our work to those of others, and provide a summary
of extensions that are under way currently.
The rest of the paper is organized as follows. Sections 2
and 3 introduce the syntax and semantics of our algebra,
respectively. Section 4 provides properties of our algebra,
and Section 5 provides properties of deterministic policies
and suﬃcient conditions for policy expressions to yield con-
sistent, complete and deterministic policies. Section 6 shows
how some example policies can be modeled using our alge-
bra, and Section 7 compares our work with those of other.
Finally, Section 8 concludes the paper.
2. SYNTAX
This section describes the syntax of the algebra, consisting
of a collection of policies, a collection of operators to combine
them, and a collection of propositions to model condition-
als. Semantically, policies map authorization triples (sub-
ject, object, action set) to collections of such authorization
triples. Operators on policies are mapped to set theoreti-
cal operators, and propositions are abstract uninterpreted
symbols. Semantic details are given in Section 3.
Definition 1
(Atomic Policies and Propositions).
Let P = {pi : i ∈ Integer} be a collection of atomic poli-
cies and Φ = {φi : i ∈ Integer} be a collection of atomic
propositions.
minimum and maximum possible permissions. Disjunction,
conjunction sequential composition and diﬀerences are bi-
nary operators, while the others are unary operators. Sev-
eral of these operators, but not all, are included in [5].
Definition 2
(Algebra of Policies). Let P = {pi :
i ∈ Integer} be a set of atomic policies. If p1, p2 are policies
and φ is a proposition, then the following are policies:
• Every atomic policy is a policy.
• (p1 ∪ p2): Union of policies.
• (p1 ∩ p2): Intersection of policies.
• (p1 − p2): Diﬀerence of policies.
• (p1; p2): Sequential composition of policies.
• (¬p1): Negation of policies.
• ((cid:9)p1): Invalidation of all access decisions made by p1.
• (p
• (φ : p1): Adding provisions to policies.
• (p1 | φ): Restricting the scope of policies.
• max(p1), min(p1): Lattice max and lattice min with
∗
1): Iterative closure of policies.
respect to actions.
Intended semantics of our policy operators are as follows.
The disjunction operator permits accesses that are allowed
under either of its components, while conjunction operator
allows only those that are permitted by both components.
The diﬀerence operator permits accesses that are allowed
under the ﬁrst, but not under the second component. Se-
quential operator permits accesses that are allowed as a con-
sequence of its second component after the ﬁrst is applied.
The negation operator changes all positive authorizations to
negative ones and vice versa. Applying the invalidate oper-
ator (cid:9) to a policy removes all authorizations granted under
that policy. Closure operator (*) allows accesses permitted
under repeated application of policies, and is an extension of
the composition operator. The reason for recursion is to al-
low accesses that are permitted by some rules in a rule base.
Addition of provisions [9] allow accesses that are allowed
provided that speciﬁed provisions are met. For example,
an e-commerce web site may not release information to any
user, but will do so provided that the user registers with the
site. The scoping operator allows only those authorizations
that meet the scoping restrictions. An example application
of the scoping operator is that price discount on items is
given to only those salesmen that have two or more years of
work experience in a department store. In case both positive
and negative permissions are granted, maximum and mini-
mum operators resolve conﬂicts by selecting the positive and
negative permissions, respectively.
3. SEMANTICS
Policy composition operators in our algebra are conjunc-
tion, disjunction, sequential composition, negation, invali-
dating all granted accesses, negating access given by a pol-
icy, diﬀerence, iterative closure under a set of rules, adding
provisions, restricting the scope of policies, and granting
Semantically access control policies allow speciﬁed sub-
jects to execute desired actions over given objects. Accord-
ingly, policies are interpreted as abstract transformers of
(subject, object, action set) triples. We formulate them as
follows.
39Definition 3
(Authorization States).
Subjects, Objects and Actions: Let S = {si : i ∈ Integer},
O = {oi : i ∈ Integer}, and A = {ai : i ∈ Integer}
be a collection of subjects, objects, and actions respec-
tively. Let ˆA = A+ ∪ A−
where A+ = {+a : a ∈ A}
= {−a : a ∈ A}. The subjects in S belong to
and A−
three diﬀerent sorts, referred to as individuals, groups
and roles.
Authorization Triples: (s, o, B) is an authorization triple
where s, o and B are respectively subject, object and a
set of signed action terms.
State: (Auth, T ruth) is a state if Auth is a set of autho-
rization triples satisfying the property that for each s ∈
S and o ∈ O, there is some signed subset B ⊆ ˆA such
that (s, o, B) ∈ Auth. T ruth ⊆ Φ, i.e., T ruth is a
collection of atomic propositions. We use the symbol
S for the set of states.
The above deﬁnition is used to interpret policies and their
composition operators as given in Deﬁnition 4.
Definition 4
(Models of Policy Algebras). A
model M of policy algebra is a tuple (S,M), where S is a
set of states, and M is a mapping from the set of atomic
policies P to a subset of S × S. We say that a state s =
(P, Q) ∈ S of the model M satisfy the atomic proposition φi
if φi ∈ Q. Satisfaction of propositions are deﬁned as in the
case of classical propositional logic. A state S ∈ S satisfying
the proposition φ is denoted by S |= φ. We extend M to
non-atomic policies using the following recursive deﬁnition:
• If (((s1, o1, A1), T1), ((s1, o1, A2), T2)) ∈ M (pi) and
(((s1, o1, A1), T1), ((s1, o1, A3), T2)) ∈ M (pj), then
(((s1, o1, A1), T1), ((s1, o1, A2 ∪ A3), T2)) ∈ M (pi ∪ pj).
• If (((s1, o1, A1), T1), ((s1, o1, A2), T2)) ∈ M (pi) and
(((s1, o1, A1), T1), ((s1, o1, A3), T2)) ∈ M (pj), then
(((s1, o1, A1), T1), ((s1, o1, A2 ∩ A3), T2)) ∈ M (pi ∩ pj).
• If (((s1, o1, A1), T1), ((s1, o1, A2), T2)) ∈ M (pi) and
(((s1, o1, A1), T1), ((s1, o1, A3), T2)) ∈ M (pj), then
(((s1, o1, A1), T2), ((s1, o1, A2− A3), T2)) ∈ M (pi− pj).
• If (((s1, o1, A1), T1), ((s1, o1, A2), T2)) ∈ M (pi) and
(((s1, o1, A2), T2), ((s1, o1, A3), T3)) ∈ M (pj), then
(((s1, o1, A1), T1), ((s1, o1, A3), T3)) ∈ M (Pi; Pj).
• If (((s1, o1, A1), T1), ((s1, o1, A2), T2)) ∈ M (p) then
(((s1, o1, A1), T1), ((s1, o1,{−a : +a ∈ A2} ∪ {+a :
−a ∈ A2}), T2)) ∈ M (¬p).
• If (((s1, o1, A1), T1), ((s1, o1, A2), T2)) ∈ M (p) then
(((s1, o1, A1), T1), ((s1, o1,∅), T2)) ∈ M ((cid:9)p).
• If (((s1, o1, A1), T1), ((s1, o1, A2), T2)) ∈ M (p) then
(((s1, o1, A1), T1), ((s1, o1, A2), T2)) ∈ M (φ : p) pro-
vided T2 |= φ, else (((s1, o1, A1)T1), ((s1, o1,∅), T2)) ∈
M (φ : p).
• If (((s1, o1, A1), T1), ((s1, o1, A2), T2)) ∈ M (p), then
there are subsets B1 ⊆ A1 and B2 ⊆ ˆA such that
(((s1, o1, B1), T1), ((s1, o1, B2), T2)) ∈ M (p | φ).
∗
• If (((s1, o1, A1), T1), ((s1, o1, A2), T2)) ∈ M (p), then in-
ductively deﬁne M (ˆpn) given as M (ˆp0) = M ((cid:9)p),
M (ˆp1) = M (p), M (ˆpn+1) = M ((p : ˆpi
Now deﬁne M (p
) as Sn M (ˆpn).
n) ∪ ˆpn)
• If (((s1, o1, A1), T1), ((s1, o1, A2), T2)) ∈ M (p) then
(((s1, o1, A1), T1), ((s1, o1, {+a : if + a,−a ∈ A2} ∪