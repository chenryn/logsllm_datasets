MEMINFO_WS
Working set info
Base and ReferenceSet
MEMORY
Memory tracing
ResidentSet and ReferenceSet
NETWORKTRACE
Network events (e.g., tcp/udp send/receive)
Network
OPTICAL_IO
Optical I/O
None
OPTICAL_IO_INIT
Optical I/O initiation
None
PERF_COUNTER
Process perf counters
Diag and DiagEasy
PMC_PROFILE
PMC sampling events
None
POOL
Pool tracing
None
POWER
Power management events
ResumeTrace
PRIORITY
Priority change events
None
PROC_THREAD
Process and thread create/delete
Base
PROFILE
CPU sample profile
SysProf
REFSET
Support footprint analysis
ReferenceSet
REG_HIVE
Registry hive tracing
None
REGISTRY
Registry tracing
None
SESSION
Session rundown/create/delete events
ResidentSet and ReferenceSet
SHOULDYIELD
Tracing for the cooperative DPC mechanism
None
SPINLOCK
Spinlock collisions
None
SPLIT_IO
Split I/O
None
SYSCALL
System calls
None
TIMER
Timer settings and its expiration
None
VAMAP
MapFile info
ResidentSet and ReferenceSet
VIRT_ALLOC
Virtual allocation reserve and release
ResidentSet and ReferenceSet
WDF_DPC
WDF DPC events
None
WDF_INTERRUPT  
WDF Interrupt events
None
When the system session starts, events are immediately logged. There is no provider that needs 
to be enabled. This implies that a consumer application has no way to generically decode the event. 
System logger events use a precise event encoding format (called NTPERF), which depends on the 
event type. However, most of the data structures representing different NT kernel logger events are 
usually documented in the Windows platform SDK.
CHAPTER 10 Management, diagnostics, and tracing
519
EXPERIMENT: Tracing TCP/IP activity with the kernel logger
In this experiment, you listen to the network activity events generated by the System Logger 
using the Windows Performance Monitor. As already introduced in the “Enumerating ETW ses-
sions” experiment, the graphical tool is not just able to obtain data from the system performance 
counters but is also able to start, stop, and manage ETW sessions (system session included). To 
enable the kernel logger and have it generate a log file of TCP/IP activity, follow these steps:
1.
Run the Performance Monitor (by typing perfmon in the Cortana search box) and click
Data Collector Sets, User Defined.
2.
Right-click User Defined, choose New, and select Data Collector Set.
3.
When prompted, enter a name for the data collector set (for example, experiment),
and choose Create Manually (Advanced) before clicking Next.
4.
In the dialog box that opens, select Create Data Logs, check Event Trace Data, and
then click Next. In the Providers area, click Add, and locate Windows Kernel Trace. Click
OK. In the Properties list, select Keywords (Any), and then click Edit.
5.
From the list shown in the Property window, select Automatic and check only net for 
Network TCP/IP, and then click OK.
EXPERIMENT: Tracing TCP/IP activity with the kernel logger
In this experiment, you listen to the network activity events generated by the System Logger 
using the Windows Performance Monitor. As already introduced in the “Enumerating ETW ses-
sions” experiment, the graphical tool is not just able to obtain data from the system performance 
counters but is also able to start, stop, and manage ETW sessions (system session included). To 
enable the kernel logger and have it generate a log file of TCP/IP activity, follow these steps:
1.
Run the Performance Monitor (by typing perfmon in the Cortana search box) and click 
Data Collector Sets, User Defined.
2.
Right-click User Defined, choose New, and select Data Collector Set.
3.
When prompted, enter a name for the data collector set (for example, experiment), 
and choose Create Manually (Advanced) before clicking Next.
4.
In the dialog box that opens, select Create Data Logs, check Event Trace Data, and 
then click Next. In the Providers area, click Add, and locate Windows Kernel Trace. Click 
OK. In the Properties list, select Keywords (Any), and then click Edit.
5.
From the list shown in the Property window, select 
Property window, select 
Property
Automatic and check only net for 
Network TCP/IP, and then click OK.
520 
CHAPTER 10 Management, diagnostics, and tracing
6.
Click Next to select a location where the files are saved. By default, this location is
%SystemDrive%\PerfLogs\Admin\experiment\, if this is how you named the data
collector set. Click Next, and in the Run As edit box, enter the Administrator account
name and set the password to match it. Click Finish. You should now see a window
similar to the one shown here:
7. 
Right-click the name you gave your data collector set (experiment in our example), and
then click Start. Now generate some network activity by opening a browser and visiting
a website.
8.
Right-click the data collector set node again and then click Stop.
If you follow the steps listed in the “Decoding an ETL file” experiment to decode the acquired 
ETL trace file, you will find that the best way to read the results is by using a CSV file type. This 
is because the System session does not include any decoding information for the events, so the 
netsh.exe has no regular way to encode the customized data structures representing events in 
the EVTX file.
Finally, you can repeat the experiment using XPERF with the following command (optionally 
replacing the C:\network.etl file with your preferred name):
xperf -on NETWORKTRACE -f c:\network.etl
After you stop the system trace session and you convert the obtained trace file, you will get 
similar events as the ones obtained with the Performance Monitor.
6.
Click Next to select a location where the files are saved. By default, this location is 
%SystemDrive%\PerfLogs\Admin\experiment\, if this is how you named the data 
collector set. Click Next, and in the Run As edit box, enter the Administrator account 
name and set the password to match it. Click Finish. You should now see a window 
similar to the one shown here:
7.
Right-click the name you gave your data collector set (experiment in our example), and 
then click Start. Now generate some network activity by opening a browser and visiting 
a website.
8.
Right-click the data collector set node again and then click Stop.
If you follow the steps listed in the “Decoding an ETL file” experiment to decode the acquired 
ETL trace file, you will find that the best way to read the results is by using a CSV file type. This 
is because the System session does not include any decoding information for the events, so the 
netsh.exe has no regular way to encode the customized data structures representing events in 
the EVTX file.
Finally, you can repeat the experiment using XPERF with the following command (optionally 
replacing the C:\network.etl file with your preferred name):
xperf -on NETWORKTRACE -f c:\network.etl
After you stop the system trace session and you convert the obtained trace file, you will get 
similar events as the ones obtained with the Performance Monitor.
CHAPTER 10 Management, diagnostics, and tracing
521
The Global logger and Autologgers
Certain logger sessions start automatically when the system boots. The Global logger session records 
events that occur early in the operating system boot process, including events generated by the NT 
kernel logger. (The Global logger is actually a system logger, as shown in Table 10-16.) Applications 
and device drivers can use the Global logger session to capture traces before the user logs in (some 
device drivers, such as disk device drivers, are not loaded at the time the Global logger session be-
gins.) While the Global logger is mostly used to capture traces produced by the NT kernel provider 
(see Table 10-17), Autologgers are designed to capture traces from classic ETW providers (and not 
from the NT kernel logger).
You can configure the Global logger by setting the proper registry values in the GlobalLogger key, which 
is located in the HKLM\SYSTEM\CurrentControlSet\Control\WMI root key. In the same way, Autologgers 
can be configured by creating a registry subkey, named as the logging session, in the Autologgers key (lo-
cated in the WMI root key). The procedure for configuring and starting Autologgers is documented at  
https://docs.microsoft.com/en-us/windows/win32/etw/configuring-and-starting-an-Autologger-session.
As introduced in the “ETW initialization” section previously in this chapter, ETW starts the Global log-
ger and Autologgers almost at the same time, during the early phase 1 of the NT kernel initialization. The 
EtwStartAutoLogger internal function queries all the logger configuration data from the registry, validates 
it, and creates the logger session using the EtwpStartLogger routine, which has already been extensively 
discussed in the “ETW sessions” section. The Global logger is a system logger, so after the session is cre-
ated, no further providers are enabled. Unlike the Global logger, Autologgers require providers to be 
enabled. They are started by enumerating each session’s name from the Autologger registry key. After a 
session is created, ETW enumerates the providers that should be enabled in the session, which are listed 
as subkeys of the Autologger key (a provider is identified by a GUID). Figure 10-36 shows the multiple pro-
viders enabled in the EventLog-System session. This session is one of the main Windows Logs displayed 
by the Windows Event Viewer (captured by the Event Logger service).
FIGURE 10-36 The EventLog-System Autologger’s enabled providers.
After the configuration data of a provider is validated, the provider is enabled in the session through 
the internal EtwpEnableTrace function, as for classic ETW sessions.
522 
CHAPTER 10 Management, diagnostics, and tracing
ETW security
Starting and stopping an ETW session is considered a high-privilege operation because events can in-
clude system data that can be used to exploit the system integrity (this is especially true for system log-
gers). The Windows Security model has been extended to support ETW security. As already introduced 
in previous sections, each operation performed by ETW requires a well-defined access right that must 
be granted by a security descriptor protecting the session, provider, or provider’s group (depending on 
the operation). Table 10-18 lists all the new access rights introduced for ETW and their usage.
TABLE 10-18 ETW security access rights and their usage
Value
Description
Applied to 
WMIGUID_QUERY
Allows the user to query information about the trace session
Session
WMIGUID_NOTIFICATION
Allows the user to send a notification to the session’s notification provider
Session
TRACELOG_CREATE_
REALTIME
Allows the user to start or update a real-time session
Session
TRACELOG_CREATE_ONDISK
Allows the user to start or update a session that writes events to a log file
Session
TRACELOG_GUID_ENABLE
Allows the user to enable the provider
Provider
TRACELOG_LOG_EVENT
Allows the user to log events to a trace session if the session is running in 
SECURE mode
Session
TRACELOG_ACCESS_
REALTIME
Allows a consumer application to consume events in real time
Session
TRACELOG_REGISTER_GUIDS
Allows the user to register the provider (creating the EtwRegistration 
object backed by the ETW_REG_ENTRY data structure)
Provider
TRACELOG_JOIN_GROUP
Allows the user to insert a manifest-based or tracelogging provider to 
a Providers group (part of the ETW traits, which are not described in 
this book)
Provider
Most of the ETW access rights are automatically granted to the SYSTEM account and to members of 
the Administrators, Local Service, and Network Service groups. This implies that normal users are not 
allowed to interact with ETW (unless an explicit session and provider security descriptor allows it). To 
overcome the problem, Windows includes the Performance Log Users group, which has been designed 
to allow normal users to interact with ETW (especially for controlling trace sessions). Although all the 
ETW access rights are granted by the default security descriptor to the Performance Log Users group, 
Windows supports another group, called Performance Monitor Users, which has been designed only 
to receive or send notifications to the session notification provider. This is because the group has been 
designed to access system performance counters, enumerated by tools like Performance Monitor and 
Resource Monitor, and not to access the full ETW events. The two tools have been already described in 
the “Performance monitor and resource monitor” section of Chapter 1 in Part 1. 
As previously introduced in the “ETW Sessions” section of this chapter, all the ETW security descrip-
tors are stored in the HKLM\System\CurrentControlSet\Control\Wmi\Security registry key in a binary 
format. In ETW, everything that is represented by a GUID can be protected by a customized security 
descriptor. To manage ETW security, applications usually do not directly interact with security descrip-
tors stored in the registry but use the EventAccessControl and EventAccessQuery APIs implemented 
in Sechost.dll.
CHAPTER 10 Management, diagnostics, and tracing
523
EXPERIMENT: Witnessing the default security descriptor of ETW sessions
A kernel debugger can easily show the default security descriptor associated with ETW sessions 
that do not have a specific one associated with them. In this experiment, you need a Windows 10 
machine with a kernel debugger already attached and connected to a host system. Otherwise, 
you can use a local kernel debugger, or LiveKd (downloadable from https://docs.microsoft.com/
en-us/sysinternals/downloads/livekd.) After the correct symbols are configured, you should be 
able to dump the default SD using the following command:
!sd poi(nt!EtwpDefaultTraceSecurityDescriptor)
The output should be similar to the following (cut for space reasons):
->Revision: 0x1
->Sbz1    : 0x0
->Control : 0x8004
SE_DACL_PRESENT 
SE_SELF_RELATIVE 
->Owner   : S-1-5-32-544 
->Group   : S-1-5-32-544 
->Dacl    :  
->Dacl    : ->AclRevision: 0x2 
->Dacl    : ->Sbz1       : 0x0 
->Dacl    : ->AclSize    : 0xf0 
->Dacl    : ->AceCount   : 0x9 
->Dacl    : ->Sbz2
: 0x0 
->Dacl    : ->Ace[0]: ->AceType: ACCESS_ALLOWED_ACE_TYPE 
->Dacl    : ->Ace[0]: ->AceFlags: 0x0 
->Dacl    : ->Ace[0]: ->AceSize: 0x14 
->Dacl    : ->Ace[0]: ->Mask : 0x00001800 
->Dacl    : ->Ace[0]: ->SID: S-1-1-0 
->Dacl    : ->Ace[1]: ->AceType: ACCESS_ALLOWED_ACE_TYPE 