✓
✓
✓(n)
✓
×(n)
×(n)
✓(n)
✓(n)
×
✓
✓
✓
✓
✓
✓
✓
×((cid:44)c)
✓(n)
✓
×(n)
×(n)
×(n)
✓(n)
×
×
×
×
×
t1 · · · tl · · · te · · · tl2 ∈ Traces(DBToy′) ∧
Send(V , n2) ∈ ti2 ∧ Recv(V , f (n2, m, P)) ∈ tk2 ∧
DBSec(V , P, n2, f (n2, m, P)) ∈ tl2 ∧
(∄j ∈ {i2 + 1, . . . , k2 − 1}. Action(P) ∈ tj) ∧
(∄j ∈ {1, . . . , l2}. Compromise(V) ∈ tj) ∧
(∄j ∈ {1, . . . , l2}. Compromise(P) ∈ tj).
(13)
Therefore, from Equations 12 and 13 we deduce that DBToy′ ̸|=⋆
□
dbsec_hnst, which completes the proof3.
The reasoning about the least-disclosing messages is supported
by the observation that any follow-up, collusion-free trace which
the adversary can lead to with less knowledge, they can also lead
to with further knowledge.
6 A SURVEY OF DISTANCE BOUNDING
In this section we show how the Tamarin tool can be used to con-
struct proofs of security or attacks on distance-bounding protocols.
In Section 6.1, we describe the results of our analysis of a number
of distance-bounding protocols. In Section 6.2 we show how the
results of our approach differ from those of Chothia et al. [20]. Fi-
nally, in Section 6.3 we analyse three industrial protocols based on
the ISO/IEC 14443 standard and propose Tamarin-verified repaired
protocols.
6.1 Case Studies
We conducted a security analysis in Tamarin of a number of
distance-bounding protocols from the literature. For each of them,
we verify whether it satisfies dbsec_hnst (without collusion), whether
it satisfies dbsec (also without collusion) and whether it resists ter-
rorist fraud (Definition 6). The results are shown in Table 1.
To identify the type of attack against a given protocol, we provide
two hints: (1) if the protocol does not satisfy dbsec_hnst, then a
mafia fraud exists; and (2) if the protocol satisfies dbsec_hnst but
it does not satisfy dbsec, then a distance fraud and/or a distance
hijacking exist. In this second case, it is highly recommended to
run Tamarin in interactive mode and inspect the trace invalidates
the property dbsec in order to visually assert the existence of the
attack. Further details on this can be found in our repository.
Out of the analysed protocols, only three protocols are distance-
bounding secure and resist terrorist fraud. These protocols are Reid
et al.’s [53], DBPK [17], and Swiss Knife [37]. A total of nineteen
protocols were found vulnerable to terrorist fraud.
The authors of UWB impulse radio based protocol [39] do not
give precise specifications of their secure channel. Hence we em-
ployed two schemes: asymmetric encryption/decryption and a mes-
sage authentication code (MAC). We found a mafia fraud against
3A Tamarin proof for a given DBToy′ is also available in our repository.
(2) Every valid extension Proto′ of Proto such that Proto′
TREAD [4] with asymmetric encryption, and both versions
of UWB [39].
̸|=
dbsec_hnst leads to replay of an attack on dbsec_hnst, there-
fore Proto′
̸|=⋆ dbsec_hnst. The protocol of this type is
TREAD [4] with symmetric encryption.
̸|=
dbsec_hnst leads to disclosure of the symmetric key shared
by the prover and verifier, therefore Proto′ ̸|=⋆ dbsec_hnst.
The protocols of this type are Reid et al. [53], DBPK [17],
and Swiss-Knife [37].
(3) Every valid extension Proto′ of Proto such that Proto′
The proofs of terrorist fraud resistance of the four protocols from
the last two cases were constructed by following the semi-automatic
approach based on least-disclosing messages, applied to the DBToy
protocol proof of Section 5.4. It is a semi-automatic approach, be-
cause Tamarin alone cannot faithfully verify that Definition 6 holds
for any protocol. This is because of the complexity of handling the
universal quantifier over all valid collusion extensions. However, a
simple manual proof analogous to that of the DBToy protocol, in
combination with the tool successfully led to security proofs of the
referred protocols.
On average, a Tamarin model of a protocol consists of about 260
lines of code, out of which 170 are of generic code, approximately.
On a modern laptop, the analysis of all lemmas for a given protocol
takes about half of a minute on average and a few seconds in most
cases. All (in)security proofs were constructed without any proof
oracles for speeding up the automatic analysis.
6.2 Our Approach vs. Chothia et al.’s
As mentioned in Section 2, a recent publication [20] at the USENIX
Security Symposium 2018 analysed a number of distance-bounding
protocols. Our findings show incorrectness in their results. In this
section we will briefly explain and interpret three inconsistencies
between this work and ours. Furthermore, a more detailed discus-
sion can be found in Appendix B.
The first inconsistency is regarding the DBToy protocol of Ex-
ample 2. By employing Chothia et al.’s framework, we analysed
this protocol4 and identified a terrorist fraud attack against it. This
is in contradiction with Theorem 1. The inconsistency arises from
Chothia et al. using a different definition of terrorist fraud than
us. Their terrorist fraud prover colludes as long as their long-term
key(s) are not revealed. It does not consider the (non-)repeatability
of the resulting attacks.
Chothia et al. [20] also produce results which contradict those
widely accepted and reiterated in the literature. For example, Hancke
and Kuhn’s protocol [34] is widely agreed to admit a terrorist fraud
attack (see e.g. [2, 3, 5, 6, 14, 16, 37]). Chothia et al. report otherwise,
without any discussion on the topic. Such inconsistency is due to
an over-approximation on the symbolic abstraction the authors
make of the protocol.
Lastly, Chothia et al. do not report no attack, other than terrorist
fraud, against versions of Meadows et al.’s protocol [46] and the
MAD protocol [19]. Our analysis, however, identifies a valid dis-
tance hijacking attack against each of these protocols. We note that
Figure 8: Mastercard’s PayPass protocol.
such attacks are not new, as they have been reported by a number
of previous works, e.g. [6, 26, 27, 44].
6.3 On the ISO/IEC 14443 Protocols
The ISO/IEC 14443 standard is used in more than 80% of today’s
contactless smart cards. Within our case studies, we analysed 3
protocols based on this standard. Those protocols are:
• NXP’s MIFARE Plus5 (versions X and EV1) with proximity
check (patent [58]) with worldwide applications in public
transport, access management, school and campus cards,
citizen cards, employee cards, and car parking.
• PaySafe [21], which is a distance-bounding-enabled version
of Visa’s contactless payment protocol payWave (in qVSDC
mode) [32].
• PayPass [31], which is Mastercard’s contactless payment
protocol with relay resistance.
To demonstrate our analysis, we have chosen the PayPass proto-
col, represented in Figure 8. The analyses of the other two protocols
are analogous. In the context of these protocols, the verifier R is
the reader terminal and the prover C is the card.
PayPass is a relay-resistance-enabled version of the EMV6 pay-
ment protocol implemented in Mastercard’s contactless cards. EMV
(which stands for Europay, Mastercard and Visa) has become the
international standard for smart cards/chips payment protocols.
4Our repository contains the ProVerif model of this and several other protocols.
5https://www.mifare.net/en/products/chip-card-ics/mifare-plus
6https://www.emvco.com
counterATCsharedKMRcounterATCsharedKMCfreshUNfreshamountfreshnCTiminginfotiSELECT,PayPassSELECTEDGPOAIP,AFLEXCHANGERRD,UNRTTnC,tiREADRECORDGENERATEAC,UN,amount,...KS:=senc(ATC,KM)AC:=MAC(KS,amount,ATC,UN)SDAD:=sign(hnC,UN,AC,tii,skC)SDAD,AC,ATCCiscloseIn a regular EMV session, a transaction is initiated by the ex-
change of SELECT and SELECTED commands along with the se-
lected EMV applet that will be used for the transaction (PayPass in
this case). Then, the terminal issues the GPO command to inform
the card on the terminal’s capabilities. The card then responds to
this command with the Application Interchange Profile (AIP) and
Application File Locator (AFL) which indicate the card’s capabilities
and the location of data files, respectively. Then, the terminal issues
the GENERATE_AC command, which includes an Unpredictable
Number UN, the amount of the transaction, the currency code,
and other data. The cards responds with the Application Cryp-
togram (AC), the Signed Dynamic Application Data (SDAD) and
the Application Transaction Counter (ATC). The AC is a the result
of keyed-MAC on the transaction information whose key is an
encryption of the Application Transaction Counter (ATC, equal to
the number of transactions previously made by the card) with a
long-term symmetric key shared between the terminal and the card.
The AC is the proof of the transaction, which can be verified by
the card issuer. The SDAD is the card’s signature of the transaction
information.
To ensure the EMV protocol satisfies relay resistance, after the
AIP and AFL commands, the terminal issues the new Exchange
Relay Resistance Data EXCHANGE_RRD command, along with
the Terminal Relay Resistance Entropy number (which equals UN).
This message initiates the fast phase of the protocol. The card must
respond on time with their nonce nC (Device Relay Resistance
Entropy) and three timing estimates: minimum time for processing,
maximum time for processing and estimated transmission time.
When modelling the PayPass protocol in Tamarin, and also the
other ISO/IEC 14443 protocols, we made the following abstractions:
(1) the timing information is considered a nonce; and (2) we did not
model any exchanged messages that are fully composed of constant
terms, e.g. the first message ⟨SELECT, PayPass⟩.
As Table 1 shows, PayPass satisfies dbsec_hnst, which means
that it does resist mafia fraud and in particular, relay attacks. In-
deed, defending against relay is a fundamental security goal of
this protocol. However, PayPass fails to defend against distance
fraud [28] and distance hijacking [26]. Those attacks refer to a re-
mote and compromised card which successfully tricks the reader
into believing they are co-located, and thus the reader accepts the
transaction.
One might argue that those attacks are irrelevant for payment
systems. After all, it is the compromised card’s owner’s bank ac-
count which ends up being charged. However, suppose an attacker
has acquired the payment card of a victim and wishes to cause them
harm. After compromising the card, they might place a concealed
device near the checkout area of a store that performs a distance
hijacking attack using the compromised card. Shoppers at the store
would then perform transactions, believing that they were paying
for products, whilst in fact all payments came from the one cor-
rupted card. The attacker could even mix in several transactions
of their own, which would be indistinguishable from the honest
shoppers. As a result of this “Robin Hood” style attack, the victim
will be charged for these illegitimate transactions with no clear
perpetrator.
Fixing the ISO/IEC 14443 Protocols. As before, we will focus on
the PayPass protocol. Before giving the fixes, let us motivate the
reasons for which it does not satisfy dbsec. As noted by Mauw et
al. in [44] when analysing PaySafe, a distance fraud is possible due
to the lack of a causal relation between the fast phase challenge
and response. That is, the fast phase response can be produced
prior to reception of the challenge. To solve this issue, Mauw et al.
suggested the inclusion of the reader’s nonce UN within the card’s
response.
Mauw et al.’s suggestion applied to PayPass does prevent dis-
tance fraud, but it does not prevent distance hijacking. To prevent
the latter, we must bind the fast phase messages to the card’s iden-
tity. We do so by adding to the card’s fast phase response, besides
UN, the card’s signature on the nonce nC. Thus, the card’s fast
phase response becomes:
⟨nC , ti, sign(nC , skC), UN⟩ .
This modification results in a protocol PayPass_Fix that satisfies
dbsec. Observe that the signature sign(nC , skC) can be computed
prior to the fast phase, so it does not delay the card’s response.
The very same solution of adding ⟨sign(nC , skC), UN⟩ into the
card’s fast phase response works for both the PaySafe and MIFARE
Plus protocols as well. Though, to keep consistency with the usage
of cryptographic operations in the case of the latter protocol, we
propose a keyed-MAC message MAC(KM , nC , ‘1’, ‘2’) instead of the
signature sign(nC , skC). As before, the keyed-MAC message can be
computed prior to the fast phase.
The modified protocol PayPass_Fix does not resist terrorist fraud
because the card’s leakage of ⟨nC , ti, sign(nC , skC)⟩ prior to the fast
phase leads to a valid attack. To prevent terrorist fraud, we propose
to further modify the PayPass protocol by changing the card’s fast
phase response and SDAD messages so that they become:
⟨nC , ti, f (UN, nC ⊕ KM)⟩
and sign(⟨UN, AC⟩ , skC),
respectively; where f is an irreversible function. The referred modi-
fication on PayPass results in a protocol PayPass_FixTF that satisfies
dbsec and resists terrorist fraud.
Similar constructions can be performed on PaySafe and MIFARE
Plus in order to repair them. The Tamarin models and security
proofs of the two versions of each protocol are available in our
repository. We give two different repaired versions of each protocol
in order to leave the choice up to the requirements of the application
system. For example, if terrorist fraud is not a critical issue, then the
first modification (i.e. Protocol_Fix) is suggested over the second
one (i.e. Protocol_FixTF) as the latter modifies the standard more
“aggressively”. We do always suggest the first modified version over
the original protocol, regardless of the application.
Other modifications for the ISO/IEC 14443 protocols that make
them resistant to terrorist fraud possibly exist, and likely all of
them (like ours) would require major changes to the standard. For
example, the composition of the SDAD message would likely have