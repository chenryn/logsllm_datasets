8
9
10
11
12
13
14
15
16 End :
17
18
}
h r = AddOption ( pElem , pElem−>s t r , FALSE ) ;
return ( S e t E r r o r I n f o ( h r ) ) ;
R e l e a s e I n t e r f a c e ( pUnk ) ;
i f
(S OK != h r ) {
h r = E INVALIDARG ;
goto End ;
( void ∗∗) &pUnk ) ;
}
Fig. 11. A real interface reference counting vulnerability (obfuscated)
In this example, this mechanism is used to guarantee that
a given browser element pElem is of the intended type.
However, the interface is never used as the looked up content is
automatically discarded via the call to ReleaseInterface
and the element is simply passed to method AddOption for
storage. A vulnerability exists when the QueryInterface
method fails and ReleaseInterface is still being called.
This is due to (1) the pUnk pointer being uninitialized
and (2) the return check being placed after the call
to
ReleaseInterface. The combination of those two bad
coding practices leads to a security vulnerability due to calling
method Release on an initialized interface pointer that will
later trigger in the form of a use-after-free vulnerabilities.
In order to exploit this ﬂaw for untrusted code execution,
an attacker would need to control the content of the stack
and make the stack offset used by local variable pUnk
coincides with the stack offset used by another reference-
counted class in a previous stack context (for example, in
a function previously called and already returned from, that
held a local variable at
just before
the call to CSomeElement::add was performed). Such
security exploits have already been demonstrated by industry
researchers.
the same stack offset
2) VARIANT type confusion: The second vulnerability class
(Figure 12) that we present
in this article is related to
the VARIANT data structure. The VARIANT data structure
is used in COM applications to transfer data items across
generic interfaces. A generic container for arrays of VARIANT
structures used in such COM programs is the DISPPARAMS
structure. This container type is used, among others, by the
IDispatch::Invoke interface method. A vulnerable spe-
cialization of this method is shown below. The CBrowserOp
class derives from IDispatch and overloads its Invoke
method. This derived method then assumes that
the ﬁrst
44
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:54:10 UTC from IEEE Xplore.  Restrictions apply. 
( ! dParams
| |
! dParams−>r g v a r g | |
! dParams−>r g v a r g [ 0 ] . p d i s p V a l ) {
switch ( d i s p I d ) {
case DISPID ONPROCESSINGCOMPLETE :
i f
return E INVALIDARG ;
}
e l s e {
IUnknown ∗pUnk = dParams−>r g v a r g [ 0 ] . p d i s p V a l ;
I N e e d e d I n t e r f a c e ∗ pRes = NULL;
HRESULT h r = pUnk−>Q u e r y I n t e r f a c e ( IID N e e d e d I f a c e ,
i f
1 STDMETHODIMP CBrowserOp : : Invoke ( DISPID d i s p I d , DISPPARAMS ∗ dParams )
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
( h r == S OK) {
P e r f o r m A c t i o n ( pRes , dParams ) ;
R e l e a s e I n t e r f a c e ( pRes ) ;
break ;
d e f a u l t : return DISP E MEMBERNOTFOUND;
}
return S OK ;
{
}
}
}
( void ∗∗) &pRes ) ;
Fig. 12. A real VARIANT type confusion vulnerability (obfuscated)
VARIANT array element is an IUnknown interface pointer
(which is the base interface for all COM classes and COM
interfaces) and looks up the desired interface (using a call to
QueryInterface) needed to perform the effective COM
operation. The rest of the VARIANT array elements is then
passed to this newly looked-up interface. On success, the
action is performed and the interface is properly released.
The safety of VARIANT manipulation relies on test-
the contained pointer
ing its vt ﬁeld to make sure that
the interface is expect-
corresponds to a data type that
ing and able to treat. Failure to perform such check can
be devastating for the security of code, especially if the
input parameters are user-controlled. This method fails to
perform such check before calling QueryInterface on
the IUnknown pointer pUnk. If the ﬁrst VARIANT struc-
ture ﬁeld dParams→rgvarg[0].pdispVal were to con-
tain another
interface, a different method than
QueryInterface would be called. An attacker could redi-
rect execution onto an instruction pointer of its choice, leading
to a likely exploitable memory corruption in the program.
The appropriate ﬁx for this vulnerability is to extend the
conditional predicate to insert a test vt == VT_UNKNOWN
|| vt == VT_DISPATCH to make sure that the VARIANT
structure holds the appropriate interface pointer into which
the QueryInterface method is implemented, and returns
E_INVALIDARG if this is not the case.
type of
VI. RELATED WORK
Extended static checking was pioneered for Java by the
work of ESC/Java [1] as a means to use program veriﬁcation
methods to provide high coverage of user deﬁned assertions.
It has since then been applied to other languages such as
Spec# for C# [21], and HAVOC for C [2]. Unlike these
tools, HAVOC-LITE provides a rich set of instrumentation and
inference capabilities to reduce the manual burden for large
modules. HAVOC-LITE provides support for most common
C++ features used in legacy applications.
Software model checkers such as SLAM [22] offer auto-
matic annotation inference based on predicate abstraction for
sparse type-state properties. However, these approaches are not
known to scale to modules greater than 100KLOC, thus cannot
be applied to most of the modules in this work. Since these
tools strive for complete automation, their architecture does
not provide mechanisms for users to conﬁgure the analysis
by providing the set of candidates as HAVOC-LITE provides.
Saturn [23] provides precise intra-procedural analysis using
SAT solvers, and uses procedure summaries over a set of
ﬁxed vocabulary. The tool developer provides appropriate
summaries for various properties such as memory leaks, and is
not easily conﬁgurable. Saturn has been used to check speciﬁc
security properties such as validation of user-land pointers
passed to the kernel [24]; however, this required the careful
conﬁguration of the Saturn checker that cannot be expected of
an average security expert. Chen et al. [25] apply the model
checker MOPS to check similar type-state properties on a
million lines of code. However, the properties are restricted
to ﬁnite state machines and its harder for the users to describe
type-state properties on ﬁelds of objects.
Hackett et al. [26] provide a checker for buffer overruns
in legacy applications using a combination of buffer length
annotation and a set of custom rules to check these annota-
tions. The checker uses a custom constraint solver (not modern
SMT solvers) using a few simple rules. However, they provide
useful heuristics to infer buffer annotations (relating buffers to
their lengths) that signiﬁcantly reduces the annotation effort.
However, the technique cannot be readily extended to the
properties we discuss in this work and therefore not a good
match for security auditors.
45
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:54:10 UTC from IEEE Xplore.  Restrictions apply. 
Theorem provers have recently been quite successful in
dynamic test generation tools such as DART [27], EXE [28]
and SAGE [29]. These techniques leverage existing tests to
create path constraints that can be negated to obtain tests for
alternate paths. These techniques have revealed several bugs
in large applications (in integration testing) or small libraries
(in unit testing). However, these approaches are oblivious of
the property being checked and aim at providing higher path
coverage. These techniques do not use procedure summaries
(such as those provided by our candidate annotations) and
therefore cannot provide coverage guarantees on the entire
attack surface. Since these techniques are primarily based on
testing, they suffer from few false alarms. On the other hand,
they require setting up complex harnesses and have difﬁculty
being exhaustive for deep components. Besides, several of the
security properties (e.g. double free) do not lead to crashes
and are consequently harder to detect by testing based tools.
Recent work on Automated Exploit Generation [30] attempts
both vulnerability checking and input crafting in order to ﬁnd a
code defect and force execution to be redirected on malicious
code. Such an approach has been focused on basic security
properties such as buffer overﬂow induced by insecure APIs
like strcpy . Such combination of SMT solvers and dynamic
test generation is an interesting approach guaranteeing that
identiﬁed vulnerabilities are real and does not require warning
triage. Improvements in performance and expressiveness (such
as extending preconditioned symbolic execution [31]) will al-
low more properties to be checked. However, such framework
provides very limited conﬁgurability for a security auditor and
does not guarantee as much coverage as an extended static
checker.
Security properties such as the VARIANT type consis-
tency [32] and the reference counting invariants [33] have pre-
viously been studied for COM programs and web browsers via
run-time monitoring and unit testing. However, no systematic
program analysis was performed to the extent of this work.
As such, no guarantee of coverage could be made based upon
concrete executions of the program under scrutiny. HAVOC-
LITE provides security auditors with extended security audit
abilities and allow focusing on code locations where such
security properties could not be proved. As such, extended
static checking provides a much stronger guarantee that no
instance of such vulnerability has been left behind.
VII. CONCLUSIONS
Extended static checking is a good complement to fuzz
testing and other data-ﬂow based static analysis techniques. In
particular, the inter-procedural inference is a key component
in diminishing the number of false positives (sometimes up
to 45%) to an acceptable level for security experts to review.
Nonetheless, the cost associated to running the inference is still
high. Our goal is to extend the two-level Houdini algorithm to
a distributed version that can invoke multiple versions of the
inner Houdini algorithm in parallel. HAVOC-LITE currently
does not weigh warning conﬁdence and users have to go
through the entire list of alerts to have a faithful understanding
of the results — performing warning prioritization is an
important next step for HAVOC-LITE.
ACKNOWLEDGMENTS
We would like to thank the anonymous reviewers and our
shepherd Patrick McDaniel for improving the presentation of
the paper. We are grateful to Mark Wodrich and Ali Rahbar
from the MSRC team for their help in deploying the tool, and
to Shaz Qadeer for his help in porting the tool to the latest
build environment in Windows.
REFERENCES
[1] C. Flanagan, K. R. M. Leino, M. Lillibridge, G. Nelson, J. B. Saxe, and
R. Stata, “Extended static checking for Java,” in Programming Language
Design and Implementation (PLDI’02), 2002, pp. 234–245.
[2] T. Ball, B. Hackett, S. K. Lahiri, S. Qadeer, and J. Vanegue, “Towards
scalable modular checking of user-deﬁned properties,” in Veriﬁed Soft-
ware: Theories, Tools, Experiments (VSTTE ’10), vol. LNCS 6217, 2010,
pp. 1–24.
[3] Satisﬁability Modulo Theories Library (SMT-LIB), “Available at
http://goedel.cs.uiowa.edu/smtlib/.”
[4] C. Flanagan and K. R. M. Leino, “Houdini, an annotation assistant
for ESC/Java,” in International Symposium of Formal Methods Europe
(FME ’01), 2001, pp. 500–517.
[5] M. Dahlweid, M. Moskal, T. Santen, S. Tobies, and W. Schulte, “Vcc:
Contract-based modular veriﬁcation of concurrent c,” in International
Conference on Software Engineering, (ICSE ’09), Companion Volume,
2009, pp. 429–430.
[6] B. Chess, “Improving computer security using extended static checking,”
in IEEE Symposium on Security and Privacy, 2002, pp. 160–.
[7] Component
Object
Model
(COM),
“Available
at
http://www.microsoft.com/com/default.mspx.”
[8] C. Flanagan, K. R. M. Leino, M. Lillibridge, G. Nelson, J. B. Saxe, and
R. Stata, “Extended static checking for Java,” in Programming Language
Design and Implementation (PLDI’02), 2002, pp. 234–245.
[9] R. DeLine and K. R. M. Leino, “BoogiePL: A typed procedural language
for checking object-oriented programs,” Microsoft Research, Tech. Rep.
MSR-TR-2005-70, 2005.
[10] J. Condit, B. Hackett, S. K. Lahiri, and S. Qadeer, “Unifying type
checking and property checking for low-level code,” in Principles of
Programming Languages (POPL ’09), 2009, pp. 302–314.
[11] M. Barnett and K. R. M. Leino, “Weakest-precondition of unstructured
programs.” in Program Analysis For Software Tools and Engineering
(PASTE ’05), 2005, pp. 82–87.
[12] S. K. Lahiri, S. Qadeer, and Z. Rakamaric, “Static and precise detection
of concurrency errors in systems code using smt solvers,” in Computer
Aided Veriﬁcation (CAV ’09), vol. LNCS 5643, 2009, pp. 509–524.
bulletin ms10-054
-
[Online]. Available: http://technet.microsoft.com/en-
[13] MSRC MS10-054,
“Microsoft
security
critical,” 2010.
us/security/bulletin/MS10-054
[14] MSRC MS11-092,
critical,” 2011.
us/security/bulletin/MS11-092
[15] MSRC MS09-034,
critical,” 2009.
us/security/bulletin/MS09-034
“Microsoft
-
[Online]. Available: http://technet.microsoft.com/en-
bulletin ms11-092
security
“Microsoft
-
[Online]. Available: http://technet.microsoft.com/en-
bulletin ms09-034
security
[16] MSRC MS11-093,
-
important,” 2011. [Online]. Available: http://technet.microsoft.com/en-
us/security/bulletin/MS11-093
bulletin ms11-093
“Microsoft
security
[17] MSRC MS11-018,
“Microsoft
-
[Online]. Available: http://technet.microsoft.com/en-
bulletin ms11-018
security
[20] MSRC MS08-066,
-
important,” 2008. [Online]. Available: http://technet.microsoft.com/en-
us/security/bulletin/MS08-066
bulletin ms08-066
“Microsoft
security
critical,” 2011.
us/security/bulletin/MS11-018
[18] MSRC MS12-074,
critical,” 2012.
us/security/bulletin/MS12-074
[19] MSRC MS11-050,
critical,” 2011.
us/security/bulletin/MS11-050
“Microsoft
-
[Online]. Available: http://technet.microsoft.com/en-
bulletin ms12-074
security
“Microsoft
-
[Online]. Available: http://technet.microsoft.com/en-
bulletin ms11-050
security
46
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:54:10 UTC from IEEE Xplore.  Restrictions apply. 
[21] M. Barnett, K. R. M. Leino, and W. Schulte, “The Spec# programming
system: An overview.” in Construction and Analysis of Safe, Secure and
Interoperable Smart Devices (CASSIS ’05), 2005, pp. 49–69.
[22] T. Ball, R. Majumdar, T. Millstein, and S. K. Rajamani, “Automatic
predicate abstraction of C programs,” in Programming Language Design
and Implementation (PLDI ’01), 2001, pp. 203–213.
[23] A. Aiken, S. Bugrara, I. Dillig, T. Dillig, B. Hackett, and P. Hawkins,
“An overview of the Saturn project,” in Workshop on Program Analysis
for Software Tools and Engineering (PASTE ’07), 2007, pp. 43–48.
Blackhat USA brieﬁngs, 2009.
[33] S. Chen, H. Chen, and M. Caballero, “Residue objects: a challenge to
web browser security,” in Proceedings of the 5th European conference
on Computer systems, ser. EuroSys ’10. ACM, 2010, pp. 279–292.
[24] S. Bugrara and A. Aiken, “Verifying the safety of user pointer derefer-
ences,” in IEEE Symposium on Security and Privacy, 2008, pp. 325–338.
[25] H. Chen, D. Dean, and D. Wagner, “Model checking one million lines of
c code,” in Proceedings of the Network and Distributed System Security
Symposium (NDSS’04), 2004.
[26] B. Hackett, M. Das, D. Wang, and Z. Yang, “Modular checking for
buffer overﬂows in the large,” in International Conference on Software
Engineering (ICSE ’06), 2006, pp. 232–241.
[27] P. Godefroid, N. Klarlund, and K. Sen, “DART: Directed automated
random testing.” in Programming Language Design and Implementation
(PLDI ’05). ACM, 2005, pp. 213–223.
[28] C. Cadar, V. Ganesh, P. M. Pawlowski, D. L. Dill, and D. R. Engler,
“Exe: automatically generating inputs of death,” in ACM Conference on
Computer and Communications Security, 2006, pp. 322–335.
[29] P. Godefroid, M. Y. Levin, and D. A. Molnar, “Sage: whitebox fuzzing
for security testing,” Commun. ACM, vol. 55, no. 3, pp. 40–44, 2012.
[30] H. B. L. T. Avgerinos Thanassis, Cha Sang Kil and B. David, “Aeg:
Automatic exploit generation,” ser. Network and Distributed System
Security Symposium, 2011.
[31] S. K. Cha, T. Avgerinos, A. Rebert, and D. Brumley, “Unleashing
mayhem on binary code,” in Proceedings of the 2012 IEEE Symposium
on Security and Privacy, ser. SP ’12. Washington, DC, USA:
IEEE Computer Society, 2012, pp. 380–394.
[Online]. Available:
http://dx.doi.org/10.1109/SP.2012.31
[32] M. Dowd, R. Smith, and D. Dewey, “Attacking interoperability,” ser.
47
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:54:10 UTC from IEEE Xplore.  Restrictions apply.