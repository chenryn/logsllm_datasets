Session 5B: Fault Attacks and Side Channel AnalysisAsiaCCS ’19, July 9–12, 2019, Auckland, New Zealand431For a given message m, let I (m) be the number of iterations of
the non-faulted signing procedure. For our attack, we only consider
single faults injected over addition in the last iteration I (m) of the
signing procedure. Let If (m, t ) denote the number of iterations
th coefficient and let
when faulting the addition operation for the t
∆(I , If )m,t = I (m) − If (m, t ) be the difference between the number
of iterations of the non-faulted and faulted signing procedures.
Since we consider only single faults, the attacker uses a faulty
pair Pi = (ϵt , (ˆz)t ) for the attack if and only if ∆(I , If )m,t = 0. If
∆(I , If )m,t (cid:44) 0, it means that the faulty signature ˆz corresponding
to the last iteration has been rejected by the check on ∥z∥∞ and
subsequently the signing procedure outputs another valid signature
corresponding to another iteration N > I (m), which cannot be used
for our attack.
We address the issue of precisely targeting the addition operation
of the last iteration for fault injection in Section 6.3, but for now
we assume that the attacker is capable in doing so. Upon faulting,
the attacker can easily estimate whether ∆(I , If )m,t = 0 by simply
checking the equality of challenge polynomials c output as part
of the faulty and non-faulty signatures. When ∆(I , If )m,t = 0 the
challenge polynomials are the same, but are otherwise different. The
goal of the attacker is to finally collect n pairs Pi for i ∈ {0, . . . , n −
1} by faulting across different coefficients and possibly different
message inputs. There is no restriction on both the aforementioned
variables. Once collected, they can build a well defined system of
linear equations as follows:
s1C = L
(5)
where the columns of matrix C (size n×n) correspond to the vectors
ϵt and the vector L (length n) is formed using the correspondingly
faulty signature coefficients (ˆz)t . The above system can be trivially
solved using Gaussian elimination to recover the primary secret s1.
Considering the possibility of rejecting the faulty signature, the
faulty coefficient (ˆz)t which is equal to the corresponding coeffi-
cient (s1c)t always lies in the allowable range for coefficient of z,
that is, ∥z∥∞ ≤ γ1 − β while ∥s1c∥∞  0. Then,
given any r ∈ Zq and HBq (u+r , α ), it is easy to compute MHq (u, r , α ).
Proof: The algorithm in Figure 2, given below, illustrates this claim.
The correctness of the algorithm follows immediately from Lemma
2.1 and Lemma 5.2.
:q, r , α, θ = HBq (u + r , α )
Algorithm 2: Inverting UHq for the hint bit h
Input
Output: MHq (u, r , α )
Set h = 0
Compute ϕ = UHq (h, r , α )
if ϕ = θ then
return h
return 1
else
end
Lemma 5.2 ([19]). Let r ∈ Zq and h, h′ ∈ {0, 1}. If UHq (h, r , α ) =
UHq (h′, r , α ), then h = h′.
Thus, in order to compute h, A must ensure that it has access to
HBq (u + r, 2γ2) = HBq (w− cs2), and r = w− cs2 + ct0. Computing
r is easy as w−cs2 +ct0 = Az−ct12d. To compute HBq (w−cs2) all
A has access to is w1. But it is known that HBq (w− cs2, 2γ2) = w1
provided ∥LBq (w−cs2, 2γ2)∥∞ ≤ γ2−β. A valid signer could ensure
this check, but for A it is not possible as it requires knowledge of s2.
Thus, the signer has to ignore the conditional checks on ∥r0∥ and
∥c · t0∥. Thus, it is natural for our forgery scheme to produce some
invalid signatures with certain non-negligible probability. We now
finally present complete details of our existential forgery attack in
Alg.3.
flags
gcc-4.2.1
compilation
We present the results of our forgery signing algorithm when
implemented on an Intel Core-i5 (Haswell) processor running at 2.6
GHz with Turbo Boost and hyper-threading disabled and compiled
with
and
-march=native
4. We obtained an average signing time
-mtune=native -O0 -g
of about 0.3253 msecs for our forgery signing procedure which is
about 2.67 times faster than the original signing procedure which
runs at 0.8689 msec. The improved speed can be attributed to the re-
duced number of operations, but also to the removal of conditional
checks over ∥r0∥ and ∥c· t0∥. We attempted to empirically compute
the failure probability of our forgery signing procedure. We ran
our forgery algorithm for a total of 228 times while not obtaining a
single invalid signature. This along with its increased signing rate
leads us to hypothesize if our forgery algorithm can be used as an
alternative signing procedure for Dilithium. Concrete estimation
of its error-probability and security of the generated signatures is
left for future work.
6 EXPERIMENTAL RESULTS
In this section, we perform an experimental validation of our pro-
posed attacks on a real device. We start by introducing our ex-
perimental setup, providing details of our device under target, im-
plementation details and our attack setup. We analyze several im-
plementation variants of the zgen operation and its susceptibility
to our proposed skipping fault attacks. We demonstrate practical
faults over the different implementation variants with very high
repeatability.
6.1 Experimental Setup
For our experiments, we target the reference implementation of
Dilithium taken from the pqm4 library, a benchmarking and testing
framework for PQC schemes on the ARM Cortex-M4 family of mi-
crocontrollers [17]. We ported its reference implementation to the
STM32F4DISCOVERY board (DUT) housing the STM32F407, ARM
Cortex-M4 microcontroller. Our implementation (compiled with
-O3
-mfloat-abi=hard
-mfpu=fpv4-sp-d16) runs at a clock frequency of 24 MHz. We use
the ST-LINK/v2.1 add-on board for USART communication with
our DUT. We used the OpenOCD framework for flash configuration
4Code is available online on https://github.com/jameshoweee/dilithium_forgery
-mcpu=cortex-m4
-mthumb
Session 5B: Fault Attacks and Side Channel AnalysisAsiaCCS ’19, July 9–12, 2019, Auckland, New Zealand433Algorithm 3: Forgery(pk, s1, M )
input :public-key pk = (q, ρ, t1), Primary secret = s1, A
message M
q
γ1−1
output:A forged Dilithium signature
A ∼ Rk×ℓ
:= Sam(ρ)
µ = H (H (ρ∥t1)∥M )
$← S ℓ
y
w = Ay
w1 = HBq (w, 2γ2)
c = H (µ, w1)
z = y + cs1
for i = 1 to k do
hi, j = 0
for j = 0 to n − 1 do
end
end
for i = 1 to k do
for j = 0 to n − 1 do
θi, j = UHq (hi, j , [Az − ct12d]i, j
end
end
for i = 1 to k do
for j = 0 to n − 1 do
Set hij = 1
if θij (cid:44) [w1]ij then
end
end
Go to 3
end
if UHq (h, Az − ct12d , 2γ2) (cid:44) w1 or ∥z∥∞ ≥ γ1 − β or
wt(h) > ω then
else
end
return (σ = (z, h, c))
and on-chip hardware debugging with the aid of the GNU debug-
ger for ARM (arm-none-eabi-gdb). We use Electromagnetic Fault
injection (EMFI) to inject faults into our device.
Refer Figure 2 for our EMFI setup. The EMFI setup injects elec-
tromagnetic pulses with high voltage (upto 200 V) with low rise
time (<4ns) in order to disturb the target operation. A controller
software running on the laptop controls both the EM pulse genera-
tor and the DUT and synchronizes their operation through serial
communication. The EM pulse generator is directly triggered by