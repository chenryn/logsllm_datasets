static int i = 0;
i ++;
}
void fun2（void）
- 11 -
{
j = 0;
j++;
}
int main()
{
for(k=0; k<10; k++)
{
fun1();
fun2();
}
return 0;
}
i 和j 的值分别是什么,为什么？
1.3.2 修饰函数
第二个作用：修饰函数。函数前加static 使得函数成为静态函数。但此处‚static‛
的含义不是指存储方式，而是指对函数的作用域仅局限于本文件(所以又称内部函数)。使
用内部函数的好处是：不同的人编写不同的函数时，不用担心自己定义的函数，是否会与其
它文件中的函数同名。
关键字static 有着不寻常的历史。起初，在C 中引入关键字static 是为了表示退出
一个块后仍然存在的局部变量。随后，static 在C 中有了第二种含义：用来表示不能被其
它文件访问的全局变量和函数。为了避免引入新的关键字，所以仍使用static 关键字来表
示这第二种含义。当然，C++里对static 赋予了第三个作用，这里先不讨论，有兴趣的可
以找相关资料研究。
1.4 基本数据类型----short、int、long、char、float、double
C 语言包含的数据类型如下图所示：
- 12 -
1.4.1 数据类型不“模子”
short、int、long、char、float、double 这六个关键字代表C 语言里的六种基本
数据类型。怎么去理解它们呢? 举个例子：见过藕煤球的那个东西吧？(没见过？煤球总见
过吧)。那个东西叫藕煤器，拿着它在和好的煤堆里这么一咔，一个煤球出来了。半径12cm，
12 个孔。不同型号的藕煤器咔出来的煤球大小不一样，孔数也不一样。这个藕煤器其实就
是个模子。
现在我们联想一下，short、int、long、char、float、double 这六个东东是不是
很像不同类型的藕煤器啊？拿着它们在内存上咔咔咔，不同大小的内存就分配好了，当然别
忘了给它们取个好听的名字。在32 位的系统上short 咔出来的内存大小是2 个byte；int
咔出来的内存大小是4 个byte；long 咔出来的内存大小是4 个byte；float 咔出来的内
存大小是4 个byte；double 咔出来的内存大小是8 个byte；char 咔出来的内存大小是1
个byte。（注意这里指一般情况，可能不同的平台还会有所不同，具体平台可以用sizeof 关
键字测试一下）
很简单吧？咔咔咔很爽吧？是很简单，也确实很爽，但问题就是你咔出来这么多内存块，
你总不能给他取名字叫做x1,x2,x3,x4,x5…或者长江1 号，长江2 号…吧。它们长得这么像
(不是你家的老大，老二，老三…)，过一阵子你就会忘了到底哪个名字和哪个内存块匹配了
(到底谁嫁给谁了啊？^_^)。所以呢，给他们取一个好的名字绝对重要。下面我们就来研究
研究取什么样的名字好。
1.4.2 变量的命名规则
一般规则：
【规则1-1】命名应当直观且可以拼读，可望文知意，便于记忆和阅读。
标识符最好采用英文单词或其组合，不允许使用拼音。程序中的英文单词一般不要太复
杂，用词应当准确。
【规则1-2】命名的长度应当符合“min-length && max-information”原则。C 是
一种简洁的语言, 命名也应该是简洁的。例如变量名MaxVal 就比
MaxValueUntilOverflow 好用。标识符的长度一般不要过长，较长的单词可通过去掉‚元
音‛形成缩写。
另外，英文词尽量不缩写，特别是非常用专业名词，如果有缩写，在同一系统中对同一
单词必须使用相同的表示法，并且注明其意思。
【规则1-3】当标识符由多个词组成时，每个词的第一个字母大写，其余全部小写。比
如：
int CurrentVal；
这样的名字看起来比较清晰，远比一长串字符好得多。
【规则1-4】尽量避免名字中出现数字编号，如Value1,Value2 等，除非逻辑上的确
需要编号。比如驱动开发时为管脚命名，非编号名字反而不好。初学者总是喜欢用带编号的
变量名或函数名，这样子看上去很简单方便，但其实是一颗颗定时炸弹。这个习惯初学者一
定要改过来。
【规则1-5】对在多个文件之间共同使用的全局变量或函数要加范围限定符(建议使用
模块名(缩写)作为范围限定符)。(GUI_ ，etc)
标识符的命名规则：
- 13 -
【规则1-6】标识符名分为两部分：规范标识符前缀(后缀) + 含义标识。非全局变量
可以不用使用范围限定符前缀。
【规则1-7】作用域前缀命名规则。
【规则1-8】数据类型前缀命名规则。
- 14 -
【规则1-9】含义标识命名规则，变量命名使用名词性词组，函数命名使用动词性词组。
例如：
变量含义标识符构成：目标词+ 动词(的过去分词)+ [状语] + [目的地]；
- 15 -
函数含义标识符构成：动词(一般现时)+目标词+[状语]+[目的地]；
【规则1-10】程序中不得出现仅靠大小写区分的相似的标识符。
例如：int x, X; 变量x 与X 容易混淆
void foo(int x); 函数foo 与FOO 容易混淆
void FOO(float x);
这里还有一个要特别注意的就是1（数字1）和l（小写字母l）之间，0（数字0）和o
（小写字母o）之间的区别。这两对真是很难区分的，我曾经的一个同事就被这个问题折腾
了一次。
【规则1-11】一个函数名禁止被用于其它之处。
例如：
#include "c_standards.h"
void foo(int p_1)
{
int x = p_1;
}
void static_p(void)
{
int foo = 1u;
}
【规则1-12】所有宏定义、枚举常数、只读变量全用大写字母命名，用下划线分割单
词。
例如：
const int MAX_LENGTH = 100; //这不是常量，而是一个只读变量，具体请往后看
#define FILE_PATH “/usr/tmp”
【规则1-13】考虑到习惯性问题，局部变量中可采用通用的命名方式，仅限于n、i、j
等作为循环变量使用。一定不要写出如下这样的代码：
int p;
char i;
int c;
char * a;
一般来说习惯上用n,m,i,j,k 等表示int 类型的变量；c，ch 等表示字符类型变量；
a 等表示数组；p 等表示指针。当然这仅仅是一般习惯，除了i,j,k 等可以用来表示循环
变量外，别的字符变量名尽量不要使用。
【规则1-14】定义变量的同时千万千万别忘了初始化。定义变量时编译器并不一定清
空了这块内存，它的值可能是无效的数据，内存管理那章有非常详细的讨论，请参看。
【规则1-15】不同类型数据之间的运算要注意精度扩展问题，一般低精度数据将向高
- 16 -
精度数据扩展。
1.5 最冤枉的关键字----sizeof
1.5.1 常年被人误认为函数
sizeof 是关键字不是函数，其实就算不知道它是否为32 个关键字之一时，我们也可
以借助编译器确定它的身份。看下面的例子：
int i=0；
A),sizeof(int)； B)，sizeof(i)； C)，sizeof int； D)，sizeof i；
毫无疑问，32 位系统下A)，B)的值为4。那C)的呢？D)的呢？
在32 位系统下，通过Visual C++6.0 或任意一编译器调试，我们发现D)的结果也为4。
咦？sizeof 后面的括号呢？没有括号居然也行，那想想，函数名后面没有括号行吗？
由此轻易得出sizeof 绝非函数。
好，怎么怎再看C)。编译器么提示出错呢？不是说sizeof 是个关键字，其后面的括号
可以没有么？那你想想sizeof int 表示什么啊？int 前面加一个关键字？类型扩展？明
显不正确，我们可以在int 前加unsigned，const 等关键字但不能加sizeof。好，记住：
sizeof 在计算变量所占空间大小时，括号可以省略，而计算类型(模子)大小时不能省略。
一般情况下，咱也别偷这个懒，乖乖的写上括号，继续装作一个“函数”，做一个“披着函
数皮的关键字”。做我的关键字，让人家认为是函数去吧。
1.5.2 sizeof（int）*p 表示什么意思？
sizeof（int）*p 表示什么意思？
留几个问题(讲解指针与数组时会详细讲解)，32 位系统下：
int *p = NULL;
sizeof(p)的值是多少？
sizeof(*p)呢？
int a[100];
sizeof (a) 的值是多少？
sizeof(a[100])呢？ //请尤其注意本例。
sizeof(&a)呢？
sizeof(&a[0])呢？
int b[100];
void fun(int b[100])
{
sizeof(b); // sizeof (b) 的值是多少？
}
- 17 -
1.6 signed、unsigned 关键字
我们知道计算机底层只认识0、1.任何数据到了底层都会变计算转换成0、1.那负数怎
么存储呢？肯定这个“-”号是无法存入内存的，怎么办？很好办，做个标记。把基本数据
类型的最高位腾出来，用来存符号，同时约定如下：最高位如果是1，表明这个数是负数，
其值为除最高位以外的剩余位的值添上这个“-”号；如果最高位是0，表明这个数是正数，
其值为除最高位以外的剩余位的值。
这样的话，一个32位的signed int类型整数其值表示法范围为：- 231～231 -1；8 位
的char类型数其值表示的范围为- 27～27 -1。一个32位的unsigned int类型整数其值表
示法范围为：0～ 232 -1；8位的char类型数其值表示的范围为0～28 -1。同样我们的
signed 关键字也很宽恒大量，你也可以完全当它不存在，编译器缺省默认情况下数据为
signed 类型的。
上面的解释很容易理解，下面就考虑一下这个问题：
Int main()
{
char a[1000];
int i;
for(i=0; i<1000; i++)
{
a[i] = -1-i;
}
printf("%d",strlen(a));
return 0;
}
此题看上去真的很简单，但是却鲜有人答对。答案是255。别惊讶，我们先分析分析。
for 循环内，当i 的值为0 时，a[0]的值为-1。关键就是-1 在内存里面如何存储。
我们知道在计算机系统中，数值一律用补码来表示（存储）。主要原因是使用补码，可
以将符号位和其它位统一处理；同时，减法也可按加法来处理。另外，两个用补码表示的数
相加时，如果最高位（符号位）有进位，则进位被舍弃。正数的补码与其原码一致；负数的
补码：符号位为1，其余位为该数绝对值的原码按位取反，然后整个数加1。按照负数补码
的规则，可以知道-1 的补码为0xff，-2 的补码为0xfe……当i 的值为127时，a[127]的值
为-128，而-128 是char 类型数据能表示的最小的负数。当i 继续增加，a[128]的值肯定
不能是-129。因为这时候发生了溢出，-129 需要9 位才能存储下来，而char 类型数据只
有8 位，所以最高位被丢弃。剩下的8 位是原来9 位补码的低8 位的值，即0x7f。当i 继
续增加到255 的时候，-256 的补码的低8 位为0。然后当i 增加到256 时，-257 的补码
的低8 位全为1，即低八位的补码为0xff，如此又开始一轮新的循环……
按照上面的分析，a[0]到a[254]里面的值都不为0，而a[255]的值为0。strlen 函数
是计算字符串长度的，并不包含字符串最后的‘\0’。而判断一个字符串是否结束的标志
就是看是否遇到‘\0’。如果遇到‘\0’，则认为本字符串结束。
分析到这里，strlen(a)的值为255 应该完全能理解了。这个问题的关键就是要明白
char类型默认情况下是有符号的，其表示的值的范围为[-128,127]，超出这个范围的值会