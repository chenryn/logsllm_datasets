User: 请选择C/C++领域相关问题的正确答案及解释编写C++代码建立一个链式队列？

A: ``C++/nstruct Node {/n    int data;/n    struct Node *next;/n};/n/nclass Queue {/n    struct Node *front, *rear;/npublic:/n    Queue() {/n        front = NULL;/n        rear = NULL;/n    }/n    void enqueue(int data) {/n        struct Node* temp = new Node();/n        temp-&gt;data = data;/n        temp-&gt;next = NULL;/n        if(front == NULL &amp;&amp; rear == NULL){/n            front = rear = temp;/n            return;/n        }/n        rear-&gt;next = temp;/n        rear = temp;/n    }/n    void dequeue() {/n        if(front == NULL) /n            return;/n        struct Node* temp = front;/n        if(front == rear) /n            front = rear = NULL;/n        else /n            front = front-&gt;next;/n        delete(temp);/n    }/n};/n```/n
B: ``C++/nclass Queue {/n    int front, rear, size;/n    unsigned capacity;/n    int* array;/n};/n```/n
C: ``C++/nstruct Node {/n    int data;/n    struct Node *prev, *next;/n};/n/nclass Queue {/n    struct Node *front, *rear;/npublic:/n    Queue() {/n        front = NULL;/n        rear = NULL;/n    }/n    void enqueue(int data) {/n        struct Node* temp = new Node();/n        temp-&gt;data = data;/n        temp-&gt;next = NULL;/n        if(front == NULL &amp;&amp; rear == NULL){/n            front = rear = temp;/n            return;/n        }/n        rear-&gt;next = temp;/n        rear = temp;/n    }/n    void dequeue() {/n        if(front == NULL) /n            return;/n        struct Node* temp = front;/n        if(front == rear) /n            front = rear = NULL;/n        else /n            front = front-&gt;next;/n        delete(temp);/n    }/n};/n```/n
D: ``C++/nstruct Node {/n};/n/nclass Queue {/n};/n```

Assistant: Answer: A