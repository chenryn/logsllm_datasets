We have shown that none of the inputs to the hash chain, namely
hi can be modi(cid:27)ed. The other inputs (0x1) are constants. As for
each record, the chunk size and its Merkle root hash is now (cid:27)xed
due to the results above, we can use the CES-unforgeability proof of
Steinfeld et al. for documents on each record. Note, that records and
documents are slightly di(cid:29)erent. Most importantly, for records the
length and the originator information is hashed into the Merkle root
node. However, the proof and the arguments about hash collisions
apply in the same manner.
Using these lemmas we can prove our theorem about the pre-
served integrity of TLS records and originator information.
Theorem A.7. The TLS records, the originator information and
the (cid:27)nal evidence inputs included in a proof are integrity protected
through the evidence signature. Any modi(cid:27)cation to them will lead to
an invalid proof.
Proof. Any modi(cid:27)cation of the records or originator informa-
tion, leads to modi(cid:27)ed Merkle root hash unless due to the biding
property of C() and the collision resistance of H().These lead to a
modi(cid:27)ed hash chain output due to Lemmas A.6 and A.5. A di(cid:29)erent
hash chain output or another modi(cid:27)ed (cid:27)nal evidence input leads
13
to a di(cid:29)erent evidence hash due to Lemma A.4, which ultimately
leads to an invalid proof due to A.3.
Note that this is true for proof with both record-level and chunk-
level granularity. In proofs with record-level granularity the Merkle
tree consists of a single node and there is only a single commitment.
However, the proofs equally apply.
(cid:3)
A.3 P1 : Con(cid:27)dentiality of Hidden Chunks
The con(cid:27)dentiality of hidden chunks has to be preserved against
an adversary even if these chunks have low entropy. To show that
the con(cid:27)dentiality is provided we show that:
• The TLS tra(cid:28)c secret is not leaked.
• All disclosed salts are pseudorandom and independent from
• The commitments do not leak information about the hid-
each other.
den chunks.
Lemma A.8. The TLS tra(cid:28)c secret is not leaked to the adversary
through any proof.
Proof. By its de(cid:27)nition, E() does not leak the pseudorandom
input key. In our design the TLS tra(cid:28)c secret is only fed as an input
key to E() and never revealed. Therefore, even though proofs might
contain the salt secrets, which are derived from the TLS tra(cid:28)c
secret, they do not leak the tra(cid:28)c secret to the adversary.
(cid:3)
Lemma A.9. All salts are pseudorandom values of su(cid:28)cient length.
Proof. We assume that the TLS tra(cid:28)c secret is a pseudorandom
key, which is a core assumption of TLS [11]. E() is de(cid:27)ned so that
given a pseudorandom input, it will provide a pseudorandom output
of a given length. Each salt is generated by alternating calls to E()
and Slice(), e.g. Slice(E(Slice(E(TLS traffic secret, ctx,
2 · lS ), 0), ctx, 2 · lS ),1). The Slice() function takes two
inputs x, y so that |x| ≥ 2 · lS and lS is the salt size. Slice() is
de(cid:27)ned as follows:
(cid:40)
Slice(x, y)=
x[0 : lS − 1]
x[lS : 2 · lS − 1]
if y = 0
if y = 1
Clearly, Slice() has a pseudorandom output given a pseudo-
random input, as it only selects a part of the input.
Therefore, each function in the call chain generates pseudoran-
dom output of size ≥ lS and thereby all salts are pseudorandom
values with su(cid:28)cient length as the salt size lS is chosen as a secu-
rity parameter.
Note, that repeated application of E() might increase the at-
tacker’s distinguishing advantage. However, in our design the salt
tree can have at most 17 levels and therefore salts are the result of
at most 17 consecutive calls to E(). Therefore, salts are still pseudo-
random, as an attacker could otherwise use this constant overhead
in a distinguishing attack. Our salt tree has at most 17 levels as in
the worst case, a record would have 216 − 1 bytes and the chunksize
would be 1 byte leading to 216 leaf nodes.
(cid:3)
Lemma A.10. The adversary cannot distinguish the values of two
neighbouring nodes inside the salt tree from two random values of
the same length.
Proof. Two neighbouring nodes Sx , Sy are the result of Sx =
Slice(E(Kp , ctx, 2 · lS ), 0) and Sy = Slice(E(Kp , ctx,
14
2·lS ), 1) based on a parent node Kp. We prove their independence
using a reduction to the pseudorandomness property of E().
Assuming the existence of a polynomial-time adversary A, able
to determine Sx , Sy from two random values of the same length
with non-negligible probability, we can distinguish E() from a
random oracle [3] as follows.
(1) Query the oracle Fn() using a random x for length 2 ∗ lS
(2) Compute Sx = Slice(Fn(x), 0), Sy = Slice(Fn(x), 1)
(3) Query A using Sx , Sy
(4) If A detects dependent values, output 1
(5) Else, output 0
If the adversary A detects dependent values, they must be gen-
erated by E(), hence the algorithm outputs 1 to signal that it is
in the real world. Thereby, the polynomial-time algorithm has a
signi(cid:27)cant advantage.
(cid:3)
Lemma A.11. Two salt values that are included in (potentially
di(cid:29)erent) proofs are independent from each other. In particular the
adversary obtains no information about a salt Si, j from a salt of a
di(cid:29)erent session, a di(cid:29)erent record (e.g. Si(cid:48), j ) or a di(cid:29)erent chunk (e.g.
Si, j(cid:48)).
Proof. Given a salt from a di(cid:29)erent session, the adversary can
not obtain any information about Si, j, because they are derived from
independent tra(cid:28)c secrets. By the TLS design [11], each session has
a fresh tra(cid:28)c secret that is independent from previous tra(cid:28)c secrets.
Given a salt from a di(cid:29)erent record inside the same session, the
adversary obtains no information about a salt Si, j because they are
derived from independent salt secrets. We prove this using a case
separation: Either the two salt secrets are based on di(cid:29)erent tra(cid:28)c
secrets, as tra(cid:28)c secrets can change [38]. In that case the derived
salts are independent. Otherwise the nonce is di(cid:29)erent for the dif-
ferent. In this case, E() is designed to generate independent outputs
even for correlated inputs, such as nonces, given a pseudorandom
key (the tra(cid:28)c secret) [23].
Given a salt from the same record but for a di(cid:29)erent chunk Si, j(cid:48),
the adversary obtains no information about Si, j. As E() does not
leak its input key, the adversary cannot compute a parent node of
Si, j(cid:48) that could be used to derive Si, j. What is left to prove is that
there is no dependency between Si, j and Si, j(cid:48). If Si, j and Si, j(cid:48) are
direct neighbours, Lemma A.10 proves the independence. Otherwise
they have to have respective parent nodes that are direct neighbours.
These parent nodes are independent according to Lemma A.10 and
therefore the derived values are independent. The discussed parent
nodes exist in this case, as both nodes are from the same tree but
not from the same branch and therefore must have parent nodes
that are direct neighbours. They cannot be from the same branch as
no two salts from the same branch are included into a proof given
that one discloses the other and only a minimal number of salts is
included in the proof.
(cid:3)
Lemma A.12. A commitment leaks no information about an un-
derlying chunk to an e(cid:28)cient adversary.
Proof. A chunk might have low entropy. In the worst case the
entropy of the chunk might be a single bit. Therefore, our com-
mitment scheme uses the salts to provide the hiding property. As
Lemma A.9 shows, these salts are pseudorandom. Additionally, as
A.11 shows, the salts are independent, so that the adversary cannot
learn about a salt from other salts in the proof or di(cid:29)erent proofs.
Using these properties, the commitment scheme C() provides the
desired property as we assume that it is hiding.
(cid:3)
Theorem A.13. No information is leaked about sensitive chunks
that are hidden in a proof.
Proof. The adversary might obtain information about sensitive
chunks in di(cid:29)erent ways. Given its network capabilities, the adver-
sary can capture the encrypted TLS tra(cid:28)c and decrypt later given
the TLS tra(cid:28)c secret. However, Lemma A.8 shows that the tra(cid:28)c
is not leaked by the proofs. Alternatively, the adversary could try
to derive information about sensitive chunks given the commit-
ments contained in a proof. However, Lemma A.12 shows that the
commitments leak no information about the underlying sensitive
chunks.
(cid:3)
A.4.1
A.4 P2: Structure of Hidden Data
In this section we show the observable structure of hidden data.
Structure of Hidden Chunks. As the chunk size and the
record length are unforgeable the Merkle tree structure is (cid:27)xed.
Therefore, no second-preimage attacks on the Merkle tree are possi-
ble and whenever a chunk is hidden, a Merkle tree node is inserted
into the proof. The Merkle tree node reveals the index of the hidden
chunk and together with the chunk size and record length also its
size.
A.4.2
Incomplete Conversations. For the conversation in Fig-
ure 3a, a proof might simply include hc1, Salt Secret2 and record 2.
(For this example we ignore data sensitivity as shown in the Figure.)
The proof can be veri(cid:27)ed by computing hcn−1 and verifying the
signature. However, the conversation is incomplete as it is unclear
how many records were part of the conversation. This incomplete-
ness is clearly observable due to the inclusion of the hash chain
element hc1 in the proof.
REFERENCES
[1]
ISO/IEC JTC 1. 2009. ISO/IEC 13888-1:2009. (2009). Information technology -
Security techniques - Non-repudiation - Part 1: General.
Internet Archive. 2017. Wayback Machine. https://archive.org/web/. (2017).
Accessed: 2017-05-19.
[3] Mihir Bellare and Phillip Rogaway. 2005. Introduction to Modern Cryptography.
[4] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars
Virza. 2013. SNARKs for C: Verifying Program Executions Succinctly and in Zero
Knowledge. Springer Berlin Heidelberg, Berlin, Heidelberg, 90–108. https://doi.
org/10.1007/978-3-642-40084-1_6
[5] Alex Beregszaszi. 2016. Ethereum ECVerify. (2016). https://gist.github.com/axic/
[2]
5b33912c6f61ae6fd96d6c4a47afde6d.
[6] Mark Brown and Russ Housley. 2006. Transport Layer Security (TLS) Evidence
Extensions. Internet-Draft draft-housley-evidence-extns-01. IETF Secretariat.
https://tools.ietf.org/html/draft-housley-evidence-extns-01 https://tools.ietf.
org/html/draft-housley-evidence-extns-01.
[7] Christina Brzuska, Heike Busch, Oezguer Dagdelen, Marc Fischlin, Martin Franz,
Stefan Katzenbeisser, Mark Manulis, Cristina Onete, Andreas Peter, Bertram Poet-
tering, and Dominique Schröder. 2010. Redactable Signatures for Tree-structured
Data: De(cid:27)nitions and Constructions. In Proceedings of the 8th International Con-
ference on Applied Cryptography and Network Security (ACNS’10). Springer-Verlag,
Berlin, Heidelberg, 87–104. http://dl.acm.org/citation.cfm?id=1894302.1894310
15
[9]
[8] Christina Brzuska, Marc Fischlin, Tobias Freudenreich, Anja Lehmann, Marcus
Page, Jakob Schelbert, Dominique Schröder, and Florian Volk. 2009. Security of
Sanitizable Signatures Revisited. Springer Berlin Heidelberg, Berlin, Heidelberg,
317–336. https://doi.org/10.1007/978-3-642-00468-1_18
Jon Callas, Lutz Donnerhacke, Hal Finney, David Shaw, and Rodney Thayer. 2007.
OpenPGP message format. Technical Report.
[10] Premkumar T. Devanbu, Michael Gertz, Charles U. Martel, and Stuart G. Stub-
blebine. 2001. Authentic Third-party Data Publication. In Proceedings of the IFIP
TC11/ WG11.3 Fourteenth Annual Working Conference on Database Security: Data
and Application Security, Development and Directions. Kluwer, B.V., Deventer,
The Netherlands, The Netherlands, 101–112. http://dl.acm.org/citation.cfm?id=
646118.758638
[11] Tim Dierks. 2008. The Transport Layer Security (TLS) Protocol Version 1.2. RFC
5246. (Aug. 2008). https://doi.org/10.17487/rfc5246
(2017).
[12] D. Dolev and A. Yao. 2006. On the Security of Public Key Protocols. IEEE Trans.
Inf. Theor. 29, 2 (Sept. 2006), 198–208. https://doi.org/10.1109/TIT.1983.1056650
[13] Marina Fang. 2017.
Former Trump Adviser Roger Stone Admits Collu-
sion With WikiLeaks, Then Deletes It.
Available from: http:
//www.hu(cid:28)ngtonpost.com/entry/roger-stone-donald-trump-julian-assange_
us_58bc24cae4b0d2821b4ec16c.
[14] Oded Goldreich, Sha(cid:27) Goldwasser, and Silvio Micali. 1986. How to Construct
Random Functions. J. ACM 33, 4 (Aug. 1986), 792–807. https://doi.org/10.1145/
6490.6503
[15] Andreas Haeberlen, Petr Kouznetsov, and Peter Druschel. 2007. PeerReview:
Practical accountability for distributed systems. In ACM SIGOPS operating systems
review, Vol. 41. ACM, 175–188.
Ibrahim Hajjeh and Mohamad Badra. 2007. TLS Sign. Internet-Draft draft-hajjeh-
tls-sign-04. IETF Secretariat. https://tools.ietf.org/html/draft-hajjeh-tls-sign-04
https://tools.ietf.org/html/draft-hajjeh-tls-sign-04.
[17] D. Hardt. 2012. The OAuth 2.0 Authorization Framework. RFC 6749. RFC Editor.
http://www.rfc-editor.org/rfc/rfc6749.txt http://www.rfc-editor.org/rfc/rfc6749.
txt.
[18] Christian Heimes. 2017. mod_nss. (2017). Available from: https://pagure.io/
[16]
[19] Christian Heimes. 2017. mod_nss branch TLS 1.3. (2017). https://pagure.io/fork/
cheimes/mod_nss/branch/tls13.
mod_nss.
[20] Siegfried Herda. 1995. Non-repudiation: Constituting evidence and proof in
digital cooperation. Computer Standards & Interfaces 17, 1 (1995), 69 – 79. https:
//doi.org/10.1016/0920-5489(94)00044-H
[21] Simitator.com Social Imitator. 2017. Fake Twitter Tweet. (2017). http://simitator.
com/generator/twitter/tweet.
[22] Robert Johnson, David Molnar, Dawn Xiaodong Song, and David Wagner. 2002.
Homomorphic Signature Schemes. In Proceedings of the The Cryptographer’s Track
at the RSA Conference on Topics in Cryptology (CT-RSA ’02). Springer-Verlag,
London, UK, UK, 244–262. http://dl.acm.org/citation.cfm?id=646140.680938
[23] Hugo Krawczyk. 2010. Cryptographic Extraction and Key Derivation: The HKDF
Scheme. Springer Berlin Heidelberg, Berlin, Heidelberg, 631–648. https://doi.
org/10.1007/978-3-642-14623-7_34
[24] Ashish Kundu and Elisa Bertino. 2008. Structural Signatures for Tree Data
Structures. Proc. VLDB Endow. 1, 1 (Aug. 2008), 138–150. https://doi.org/10.
14778/1453856.1453876
IETF TLS mail-
[25] Sergio Lerner. 2015.
Available from: https://mailarchive.ietf.org/arch/msg/tls/
Renegotiation and TLSNotary.
ing list. (2015).
8ZK37bSWPvHf0p0X9nFzVAoT-04.
[26] Oraclize Limited. 2017. Oraclize - blockchain oracle service, enabling data-rich
smart contracts. http://www.oraclize.it. (2017). Accessed: 2017-05-19.
[27] Luigi Lo Iacono and Hoai Viet Nguyen. 2015. Authentication Scheme for REST.
Springer International Publishing, Cham, 113–128. https://doi.org/10.1007/
978-3-319-19210-9_8
[28] D. McGrew. 2008. An Interface and Algorithms for Authenticated Encryption.
RFC 5116. RFC Editor. http://www.rfc-editor.org/rfc/rfc5116.txt http://www.
rfc-editor.org/rfc/rfc5116.txt.
[29] Ralph C. Merkle. 1988. A Digital Signature Based on a Conventional Encryption
Function.
All the reasons why that James Comey’s
[30] Gianluca Mezzo(cid:27)ore. 2017.
’pee tape’ tweet is fake.
(2017).
http://mashable.com/2017/05/10/
james-comey-fake-tweet-pee-tape-debunk/.
[31] Andrew Miller, Michael Hicks, Jonathan Katz, and Elaine Shi. 2014. Authenticated
Data Structures, Generically. SIGPLAN Not. 49, 1 (Jan. 2014), 411–423. https:
//doi.org/10.1145/2578855.2535851
(2017). Available from: https://
[32] Mozilla. 2017. Network Security Services.
developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS.
[33] Satoshi Nakamoto. 2008. Bitcoin: A peer-to-peer electronic cash system. (2008).
[34] Erik Nygren, Samuel Erb, Alex Biryukov, Dmitry Khovratovich, and Ari Juels.
2016. TLS Client Puzzles Extension. Technical Report. Internet Engineering Task
Force. https://datatracker.ietf.org/doc/html/draft-nygren-tls-client-puzzles-02
shattered.pdf.
[41] TLSnotary. 2014. TLSnotary - a mechanism for independently audited https
sessions. (2014). Available from: https://tlsnotary.org/TLSNotary.pdf.
[42] Trustworthy Internet Movement. 2017. SSL Pulse.
https://www.trustworthyinternet.org/ssl-pulse/.
(2017). Available from:
[43] Gavin Wood. 2014. Ethereum: A secure decentralised generalised transaction
[44] XE. 2017. XE Currency Data Feed. http://www.xe.com/datafeed/. (2017). Ac-
ledger. Ethereum Project Yellow Paper (2014).
cessed: 2017-05-19.
[45] Fan Zhang, Ethan Cecchetti, Kyle Croman, Ari Juels, and Elaine Shi. 2016. Town
Crier: An Authenticated Data Feed for Smart Contracts. In Proceedings of the
2016 ACM SIGSAC Conference on Computer and Communications Security (CCS
’16). ACM, New York, NY, USA, 270–282. https://doi.org/10.1145/2976749.2978326
Jianying Zhou and Dieter Gollmann. 1997. Evidence and non-repudiation. Journal
of Network and Computer Applications 20, 3 (1997), 267 – 281. https://doi.org/10.
1006/jnca.1997.0056
[46]
[36]
[35] OANDA. 2017. Exchange Rate API for Businesses and Corporates. https://www.
oanda.com/solutions-for-business/feed.html. (2017). Accessed: 2017-05-19.
Jose Antonio Onieva, Javier Lopez, and Jianying Zhou. 2009. Secure Multi-Party
Non-Repudiation Protocols and Applications. Advances in Information Security,
Vol. 43. Springer. https://doi.org/10.1007/978-0-387-75630-1
[37] Bill Palmer. 2016. Did Bernie Sanders really dare Trump to send protesters? Its
not on Twitter. Deleted or hoax? (2016). Available from: http://bit.ly/1MgB9Ol.
[38] Eric Rescorla. 2016. The Transport Layer Security (TLS) Protocol Version 1.3.
Internet-Draft draft-ietf-tls-tls13-18. IETF Secretariat. https://tools.ietf.org/html/
draft-ietf-tls-tls13-18 https://tools.ietf.org/html/draft-ietf-tls-tls13-18.
[39] Ron Steinfeld, Laurence Bull, and Yuliang Zheng. 2002. Content Extraction
Signatures. In Proceedings of the 4th International Conference Seoul on Information
Security and Cryptology (ICISC ’01). Springer-Verlag, London, UK, UK, 285–304.
http://dl.acm.org/citation.cfm?id=646283.687991
[40] Marc Stevens, Elie Bursztein, Pierre Karpman, Ange Albertini, and Yarik Markov.
(2017). https://shattered.io/static/
2017. The (cid:27)rst collision for full SHA-1.
16