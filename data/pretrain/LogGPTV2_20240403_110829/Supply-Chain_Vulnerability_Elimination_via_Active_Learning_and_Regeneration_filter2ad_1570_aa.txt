title:Supply-Chain Vulnerability Elimination via Active Learning and Regeneration
author:Nikos Vasilakis and
Achilles Benetopoulos and
Shivam Handa and
Alizee Schoen and
Jiasi Shen and
Martin C. Rinard
Supply-Chain Vulnerability Elimination
via Active Learning and Regeneration
Nikos Vasilakis
MIT, CSAIL
PI:EMAIL
Alizee Schoen
MIT, CSAIL
PI:EMAIL
Achilles Benetopoulos
UC Santa Cruz
PI:EMAIL
Jiasi Shen
MIT, CSAIL
PI:EMAIL
Shivam Handa
MIT, CSAIL
PI:EMAIL
Martin C. Rinard
MIT, CSAIL
PI:EMAIL
ABSTRACT
Software supply-chain attacks target components that are inte-
grated into client applications. Such attacks often target widely-
used components, with the attack taking place via operations (for
example, file system or network accesses) that do not affect those
aspects of component behavior that the client observes. We pro-
pose new active library learning and regeneration (ALR) techniques
for inferring and regenerating the client-observable behavior of
software components. Using increasingly sophisticated rounds of
exploration, ALR generates inputs, provides these inputs to the
component, and observes the resulting outputs to infer a model
of the component’s behavior as a program in a domain-specific
language. We present Harp, an ALR system for string processing
components. We apply Harp to successfully infer and regenerate
string-processing components written in JavaScript and C/C++.
Our results indicate that, in the majority of cases, Harp completes
the regeneration in less than a minute, remains fully compatible
with the original library, and delivers performance indistinguish-
able from the original library. We also demonstrate that Harp can
eliminate vulnerabilities associated with libraries targeted in sev-
eral highly visible security incidents, specifically event-stream,
left-pad, and string-compare.
CCS CONCEPTS
• Software and its engineering → Dynamic analysis; Scripting
languages; • Security and privacy → Software and application
security.
KEYWORDS
Supply-chain attacks, Third-party libraries, Packages, Modules, Pro-
gram inference, Program synthesis
ACM Reference Format:
Nikos Vasilakis, Achilles Benetopoulos, Shivam Handa, Alizee Schoen, Jiasi
Shen, and Martin C. Rinard. 2021. Supply-Chain Vulnerability Elimination
via Active Learning and Regeneration. In Proceedings of the 2021 ACM
SIGSAC Conference on Computer and Communications Security (CCS ’21),
Permission to make digital or hard copies of part or all of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for third-party components of this work must be honored.
For all other uses, contact the owner/author(s).
CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea
© 2021 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-8454-4/21/11.
https://doi.org/10.1145/3460120.3484736
Fig. 1: Harp usage scenario. A stealthy supply-chain vulnerability can
be activated long after deployment. Harp can be applied before or dur-
ing development (shown) to obtain a collection of safe regenerated string
libraries. Harp can also be deployed at later stages (during development
or even while in production, not shown) to replace potentially malicious
libraries with safe regenerated versions.
November 15–19, 2021, Virtual Event, Republic of Korea. ACM, New York, NY,
USA, 16 pages. https://doi.org/10.1145/3460120.3484736
1 INTRODUCTION
Malicious adversaries increasingly employ software supply-chain
attacks [7, 28–30, 60]. Rather than directly targeting a victim soft-
ware, these attacks target a victim’s supplier, exploiting the fact
that the victim software depends, directly or indirectly, on software
provided by the supplier. A common scenario is that the attacker
purposefully inserts vulnerabilities into open source software com-
ponents that are then integrated into the eventual victim software.
Modern software often integrates hundreds to thousands of small
components, with many components integrated not directly, but
only via transitive dependencies [28, 40, 72]. It is therefore impracti-
cal for developers to audit the code that implements the integrated
components—indeed, developers can easily be completely unaware
of the full range of components that their system may integrate.
For these reasons, even very simple, widely used components can
successfully carry vulnerabilities into client software systems.
For a compromised component to remain undetected, it must
typically deliver correct observable behavior to its client applica-
tions. Inserted vulnerabilities are therefore typically triggered only
in very specific execution contexts and exhibit malicious behav-
ior (such as stealthily exfiltrating sensitive data [5, 42], stealing
digital assets [43, 71], or performing covert computations on the
client computing platform [11, 61]) that does not interfere with
correct client-observable behavior. A common scenario is that the
client observes only the functional behavior of the component, i.e.,
the results that it returns to the client when invoked, and not any
malicious side effects, additional computation, or external commu-
nication that the component may perform when it executes.
Motivated by this observation, we investigate a new approach to
eliminating vulnerabilities in software components. This approach
Lib-NdevelopprogramLib-1developprogramtesttestdeploydeployattack!ALRlintlint+HARPWithoutHARPSession 6B: Web Vulnerabilities CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1755takes a potentially compromised component, explores the behavior
of the component in a controlled environment to learn a model of
its functional behavior (this model excludes behavior characteristic
of inserted vulnerabilities), then uses the model to regenerate a
new version of the component. We present a system, Harp, that
applies this approach to automatically regenerate vulnerability-free
versions of widely used string libraries, including libraries that
operate on collections (such as lists or streams) over strings and
higher-order computations that map or fold over such collections.
Deployment Scenarios: Harp supports a range of deployment
scenarios. It can be used before application development starts
to obtain a collection of safe regenerated string libraries that can
be integrated into multiple applications developed by one or more
organizations (Figure 1). It can also be deployed during development
as new string libraries are integrated into the application. Finally,
it can be deployed after the application is in production to replace
potentially malicious libraries with safe regenerated versions.
Scope and Limitations: Our current focus is simple libraries
that implement familiar utility computations with broad applicabil-
ity across a wide range of applications. Such libraries comprise a
compelling target for attackers because (1) they enable attackers
to effectively target a broad range of computations and (2) they
are often imported indirectly via higher-level libraries (as opposed
to imported directly by the application developer), and as a result
are typically not audited by the application’s nominal developers.
Indeed, many developers may easily be unaware that their applica-
tions integrate the target library.
Our approach also targets libraries whose behavior can be accu-
rately captured with a domain-specific language (DSL). The DSL
promotes effective inference and representation of the library be-
havior and eliminates malicious computations as inexpressible.
Our current Harp implementation targets string libraries. Such
libraries implement foundational baseline functionality used widely
in modern software systems. This is especially true for dynami-
cally typed language such as JavaScript that use runtime string
manipulation even for basic operations that in other languages
are performed via type-safe alternatives such as type-constructor
pattern matching. This is also true for many web applications,
in which strings and string manipulations play a prominent role.
Strings are therefore integrated, often indirectly, in the full range of
JavaScript applications and are typically treated as standard compo-
nents within the JavaScript ecosystem. We have developed a DSL
that effectively captures the semantics of string computations and
supports the efficient representation, manipulation, and inference
of the underlying behavior implemented by string libraries (§4.1).
Our experimental results highlight the benefits that our approach
can deliver for clients of such libraries (§7).
This focused approach comes with limitations. First, it works
best for widely used libraries whose computations can be captured
with an efficiently inferrable DSL. We anticipate that such libraries
will implement relatively simple, well understood computations.
We also anticipate that the approach will work best for functional
computations. Although it is possible to work with computations
that perform externally visible actions such as file system or net-
work accesses, we anticipate that it may be more difficult to ensure
that the regenerated computations contain no malicious code.
Results Summary: Harp successfully eliminates vulnerabilities
in 3 large-scale software supply-chain attacks by learning and regen-
erating the core functionality of the vulnerable library, eliminating
any dependency to dangerous code (§7). We are aware of no other
system that can successfully eliminate these attacks.
Applied to 17 JavaScript string-processing libraries (§7.5), Harp
learns 14 libraries within a minute and all 17 under an hour. It also
aborts within 5 seconds on 11 other JavaScript libraries that fall
outside the string-processing domain. Harp also successfully learns
and regenerates 5 C/C++ string processing modules imported as
JavaScript binary modules. The regenerated libraries execute be-
tween 2% faster and 7% slower than the original JavaScript libraries
and cannot use functionality beyond basic JavaScript primitives.
Key properties of Harp’s synthesis algorithm guarantee that, in
the limit, our proposed learning and regeneration techniques pro-
duce candidate programs with the same client-observable behavior
as the original string library, if such a candidate program exists in
the Harp DSL, and without malicious behaviors that fall outside
client-observable behavior.
Contributions: This paper makes the following contributions:
• Active Learning for Vulnerability Elimination: Given a com-
ponent to regenerate, Harp chooses inputs, feeds these inputs
to the component, and observes the resulting outputs to infer a
model of the client-observable functionality that the component
implements. Harp executes the component in a controlled en-
vironment to discard any behavior that is not observable in the
direct functional interactions with the Harp learning system.
• Domain-Specific Language: Harp builds the inferred model
as a program in a DSL for capturing string computations, includ-
ing computations over collections of strings and computations
that map or fold over such collections. This approach provides
important benefits: (1) Tractable Learning Without Overfitting:
The DSL acts as a strong regularizer that focuses the inference
on the target class of string computations. It prevents overfit-
ting and promotes efficient inference that typically requires only
automatically generated input-output observations to precisely
identify a specific string computation within the larger class of
string computations. (2) Safe Modeling: The DSL is designed to
express only legitimate string computations. The inferred model
therefore excludes behaviors that augment string computations
with auxiliary malicious computations.
• Regeneration: Given a string computation in the DSL, Harp
regenerates the computation in the desired target programming
language, with any malicious behavior in the original component
not learned during inference and discarded in the regeneration.
• Experimental Results: It presents results that characterize the
ability of Harp to learn and regenerate a range of string libraries
and highlight its ability to eliminate several software supply
chain attacks that target string libraries.
2 BACKGROUND & EXAMPLE
We use the event-stream incident [41, 61], where a popular stream-
processing library was modified to steal bitcoins from carefully
selected targets, as an example of the attacks Harp is designed
to eliminate. At the time of the incident, event-stream was used
Session 6B: Web Vulnerabilities CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1756Harp next uses flatmap-stream to synthesize a program in the
Harp DSL as follows. It iteratively generates candidate programs in
the Harp DSL, filtering out candidate programs that do not match
the extracted type information ( 3○). It then executes the original
version of flatmap-stream and remaining candidate programs on
an iteratively increasing set of generated inputs ( 4○). It observes
the parameter and return values of the original library and the
candidate DSL programs (these parameter and return values are
the client-observable behavior). It filters out candidate programs
that exhibit different client-observable behavior than the original
library ( 5○).
As the Harp inference algorithm executes, it maintains a set
of candidate DSL programs that exhibit identical behavior as the
original library on the current set of generated inputs. If the input
generation algorithm enumerates all possible inputs in the limit
(many such algorithms exist for countably infinite inputs such as
strings), this process will, again in the limit, produce a DSL program
with the same client-observable behavior as the original library
( 6○), if such a DSL program exists (§5). In practice, Harp is usually
able to synthesize a unique successful candidate program within
an hour and typically within minutes (§7). Harp also implements
a --quick-abort option that immediately aborts the search if the
Harp instrumentation detects any non-client-observable behavior
such as file system, environment variable, or network access.
In our example, the malicious flatmap-stream behavior is not
triggered in our isolated container environment and flatmap-stream
exhibits fully correct behavior. Working with 2,536 inputs, Harp
takes 1.4 seconds to synthesize the following correct DSL pro-
gram, which exhibits identical behavior as the correct version of
flatmap-stream:
f s = map ( squash n) | " {( c )} "
Here f maps the function squash n over the elements of s, thereby
flattening s, and then pipes each of the results to an output pattern,
which simply outputs its input element.
Harp then compiles the synthesized DSL program to the follow-
ing JavaScript library:
const libHarp = require ( './ lib - harp . js ');
let program = (f , isAsync ) => {
const stream = new libHarp . Stream ();
stream . addOperation ( libHarp . squash );
stream . addUserOperation (f , isAsync );
return stream ;
};
module . exports = program ;
The compiled regenerated library is a direct translation of the in-
ferred Harp DSL program. It links to lib-harp, a module that
supports Harp’s core functionality (part of the TCB, §3).
3 THREAT MODEL
Harp protects against an adversary that fully controls a target
component and can modify it in any way. By preserving the client-
observable functionality, the adversary aims to execute undetected
attacks when the component is integrated into an application. Ex-
amples of modifications include added functionality that reads from
the file system, sends messages over the network, reads environ-
ment variables, or writes to global variables.
In an isolated container environment, Harp loads a
Fig. 2: Overview.
library and inspects its interface. Using increasingly sophisticated rounds
of exploration, it generates inputs, provides these inputs to the library, and
observes the resulting outputs to infer a model of the library’s behavior as
a program in a domain-specific language.
(imported either directly or indirectly) by thousands of applications
and averaged about two million downloads per week. When its
author handed off maintenance to a volunteer—common practice
in open-source development projects—the new maintainer added
an obfuscated, malicious library called flatmap-stream as a de-
pendency to event-stream.
The malicious flatmap-stream library is designed to harvest
account details from select Bitcoin wallets. If run in the dependency
tree of a specific Bitcoin application called Copay, flatmap-stream
loads Copay’s account module containing the Bitcoin wallet cre-
dentials of the user using Copay. It then overwrites the account’s