cess to an Oblivious Database Using Stateful Anonymous
Credentials. In Proceedings of PKC 2009, Irvine, CA, March
2009.
[24] R. Cramer, I. Damgård, and B. Schoenmakers. Proofs of Par-
tial Knowledge and Simpliﬁed Design of Witness Hiding Pro-
tocols. In Proceedings of CRYPTO 1994, Santa Barbara, CA,
August 1994.
[25] I. Damgård, M. Fitzi, E. Kiltz, J. B. Nielsen, and T. Toft. Un-
conditionally Secure Constant-Rounds Multi-party Computa-
tion for Equality, Comparison, Bits and Exponentiation. In
Proceedings of TCC 2006, New York, NY, March 2006.
[26] B. Doe. The Kindle in Australia, October 2009.
[27] P. Feldman. A Practical Scheme for Non-interactive Veriﬁ-
able Secret Sharing. In Proceedings of FOCS 1987, Los An-
geles, CA, October 1987.
[28] A. Fiat and A. Shamir. How to Prove Yourself: Practical So-
lutions to Identiﬁcation and Signature Problems. In Proceed-
ings of CRYPTO 1986, Santa Barbara, CA, 1986.
[29] Free Software Foundation. The GNU Multiple Precision
(GMP) Arithmetic Library. Version 5.0.1.
[30] Y. Gertner, S. Goldwasser, and T. Malkin. A Random Server
Model for Private Information Retrieval. In Proceedings of
RANDOM 1998, Barcelona, Spain, October 1998.
[31] Y. Gertner, Y. Ishai, E. Kushilevitz, and T. Malkin. Protecting
In
Data Privacy in Private Information Retrieval Schemes.
Proceedings of STOC 1998, Dallas, TX, May 1998.
[32] I. Goldberg. Percy++ / PIR in C++. Version 0.7.1.
[33] I. Goldberg. Improving the Robustness of Private Information
Retrieval. In Proceedings of IEEE S&P 2007, Oakland, CA,
May 2007.
[34] S. Guha, B. Cheng, and P. Francis. Privad: Practical Privacy
in Online Advertising. In Proceedings of NSDI 2011, Boston,
MA, March 2011.
[35] V. Guruswami and M. Sudan. Improved Decoding of Reed-
Solomon and Algebraic-Geometric Codes. In Proceedings of
FOCS 1998, Palo Alto, CA, November 1998.
[36] R. Henry, F. Olumoﬁn, and I. Goldberg. Practical PIR for
Electronic Commerce. Tech. Report CACR 2011-04, Univer-
sity of Waterloo, 2011.
[37] Y. Ishai, E. Kushilevitz, R. Ostrovsky, and A. Sahai. Batch
Codes and Their Applications. In Proceedings of STOC 2004,
Chicago, IL, June 2004.
[38] A. Juels. Targeted Advertising. . . And Privacy Too. In CT-
RSA, San Francisco, CA, April 2001.
[39] A. Kate. PBCWrapper: C++ Wrapper Classes for the Pairing-
Based Cryptography Library. Version 0.8.0.
[40] A. Kate, G. M. Zaverucha, and I. Goldberg. Constant-Size
Commitments to Polynomials and Their Applications. In Pro-
ceedings of ASIACRYPT 2010, Singapore, December 2010.
[41] A. Kate, G. M. Zaverucha, and I. Goldberg. Polynomial Com-
mitments. Tech. Report CACR 2010-10, University of Water-
loo, 2010.
[42] E. Kushilevitz and R. Ostrovsky. Replication Is Not Needed:
Single Database, Computationally-Private Information Re-
In Proceedings of FOCS 1997, Miami Beach, FL,
trieval.
October 1997.
[43] B. Lynn. PBC Library: The Pairing-Based Cryptography Li-
brary. Version 0.5.11.
[44] D. McCullagh. Amazon Fights Demand for Customer
In CNET News. April 2010. http://news.
Records.
cnet.com/8301-13578_3-20002870-38.html.
[45] A. J. Menezes, P. C. van Oorschot, and S. A. Vanstone. Hand-
book of Applied Cryptography. CRC Press, 2001.
[46] T. Nishide and K. Ohta. Constant-Round Multiparty Compu-
tation for Interval Test, Equality Test, and Comparison. IE-
ICE Transactions, 90-A(5):960–968, 2007.
[47] F. Olumoﬁn and I. Goldberg. Preserving Access Privacy Over
Large Databases. Tech. Report CACR 2010-33, University of
Waterloo, 2010.
[48] F. G. Olumoﬁn and I. Goldberg. Privacy-Preserving Queries
over Relational Databases. In Privacy Enhancing Technolo-
gies, Berlin, Germany, July 2010.
[49] Ookla Net Metrics. Canada and US Source Data. http:
//www.netindex.com/source-data/.
[50] OpenSSL Project. OpenSSL: The Open Source toolkit for
SSL/TLS. Version 1.0.0.
[51] R. Ostrovsky and W. E. Skeith III. A Survey of Single-
Database Private Information Retrieval: Techniques and Ap-
plications. In Proceedings of PKC 2007, Beijing, China, April
2007.
[52] T. P. Pedersen. Non-Interactive and Information-Theoretic
Secure Veriﬁable Secret Sharing. In Proceedings of CRYPTO
1991, Santa Barbara, CA, August 1991.
[53] C.-P. Schnorr. Efﬁcient Identiﬁcation and Signatures for
Smart Cards. In Proceedings of CRYPTO 1989, Santa Bar-
bara, CA, August 1989.
[54] A. Shamir. How to Share a Secret. Communications of the
ACM, 22(11):612–613, November 1979.
[55] V. Shoup. NTL: A Library for doing Number Theory. Version
5.5.2.
[56] V. Toubiana, H. Nissenbaum, A. Narayanan, S. Barocas, and
D. Boneh. Adnostic: Privacy Preserving Targeted Advertis-
ing. In Proceedings of NDSS 2010, San Diego, CA, February
2010.
[57] Y. Zhang, M. H. Au, D. S. Wong, Q. Huang, N. Mamoulis,
D. W. Cheung, and S.-M. Yiu. Oblivious Transfer with Ac-
cess Control : Realizing Disjunction without Duplication. In
Proceedings of Pairing 2010, Yamanaka Hot Spring, Japan,
December 2010.
APPENDIX
A. PROVING EQUALITY OF 1-OUT-OF-r
DISCRETE LOGARITHMS
Let g and h be (known) generators of a group G (of order q)
with logg(h) unknown to the veriﬁer, and let g1, g2, . . . , gr and
h1, h2, . . . , hr be given. The proof works as follows:
Prover knows: x = logg gj = logh hj and index j
Veriﬁer learns: that logg gj(cid:48) = logh hj(cid:48) for at least one j(cid:48)
1, . . . , c(cid:48)
1. The prover chooses γ1, . . . , γr ∈R Zq and c(cid:48)
then computes and sends the commitments ηi = gγi gc(cid:48)
and ζi = hγi hc(cid:48)
to the veriﬁer, for 1 ≤ i ≤ r.
r ∈ Z2κ,
¯δij
¯δij
i
i
i
i
2. The veriﬁer chooses and sends c ∈R Z2κ to the prover.
3. The prover sets ci = c(cid:48)
i and υi = γi for i ∈ [1, r] − {j}
¯δij mod 2κ and υj = γj −
cjx mod q, then sends the pair ((cid:126)c, (cid:126)υ) to the veriﬁer, where
(cid:126)c = (cid:104)c1, . . . , cr(cid:105) and (cid:126)υ = (cid:104)υ1, . . . , υr(cid:105).
and computes cj = c −(cid:80)r
putes υ = (cid:126)υ·(cid:126)b. The veriﬁer accepts if and only if(cid:81)r
4. The veriﬁer chooses (cid:126)b = (cid:104)b1, . . . , br(cid:105) ∈R (Z2κ )r and com-
?=
i=1 c(cid:48)
i
i=1 ηbi
i
688gυ(cid:16)(cid:81)r
(cid:80)r
i=1 gbici
i
i=1 ci mod 2κ all hold.
(cid:17)
, (cid:81)r
i=1 ζ bi
i
?= hυ(cid:16)(cid:81)r
i=1 hbici
i
(cid:17)
and c
?≡
Note that the above batch veriﬁcation equation is more efﬁcient
than checking each of the r veriﬁcation equations independently,
since both bi and ci are short exponents; moreover, in our own
application (see §3.5.2), we take advantage of some properties of
the special case we are proving to further reduce veriﬁcation costs.
B. PROVING THAT A VECTOR OF COM-
MITMENTS OPENS TO A STANDARD
BASIS VECTOR
Prover knows: a length-r vector of polynomials (cid:126)f ∈ (Zq[x])r
Veriﬁer learns: a length-r vector (cid:126)C of component-wise commit-
ments to polynomials in (cid:126)f and that (cid:126)f evaluates component-wise to
a standard basis vector at x = 0
i
Ca =(cid:81)r
1. The prover computes and sends (cid:126)C to the veriﬁer.
2. The veriﬁer chooses a vector of challenges (cid:126)a ∈R (Z2κ )r
and sends it to the prover; meanwhile, the veriﬁer computes
, where Ci and ai are the ith components of
(cid:126)C and (cid:126)a, respectively. Note that Ca is a commitment to the
dot product fa = (cid:126)f · (cid:126)a.
i=1 C ai
3. The prover computes the dot product fa = (cid:126)f · (cid:126)a and engages
in a zero-knowledge proof of knowledge of the evaluation of
fa at x = 0 with the veriﬁer, such as by using the technique
described in [41, Appendix D].
4. Let Y = gγ·y
T
be the (blinded) commitment to y = fa(0)
from this last proof of knowledge. The prover sends ν = hγ
together with proof that γ is the same randomness used to
blind Y , and engages in a batch proof of equality of 1-out-of-
r discrete logarithms to prove(cid:87)r
(cid:0)loggT Y = logh νai(cid:1).
i=1
Remark 2. Because we are dealing with the special case of the
batch proof of equality of 1-out-of-r discrete logarithms in which
g1 = g2 = ··· = gr = Y and logν (hi) = ai is known to the
veriﬁer, the following optimizations apply: instead of checking
r(cid:89)
(cid:32) r(cid:89)
(cid:33)
ηdi
i
?= gυ
gcidi
i
and
i=1
i=1
and w2 =(cid:80)r
in the veriﬁcation equation, the veriﬁer computes w1 = (cid:126)c· (cid:126)d mod q
i=1 aicidi mod q and checks if
r(cid:89)
i=1
ζ di
i
?= hυ
(cid:33)
hcidi
i
(cid:32) r(cid:89)
i=1
r(cid:89)
r(cid:89)
i=1
ηdi
i
?= gυY w1 and
ζ di
i
?= hυνw2 .
i=1
This reduces the cost of veriﬁcation from 2 full length exponen-
tiations and 6r ‘short’ exponentiations (i.e., exponentiations with
κ-bit exponents) to 4 full length exponentiations and 2r short ex-
ponentiations.
C. VERIFYING EVALUATIONS OF POLY-
NOMIAL COMMITMENTS AT A COM-
MON POINT
Prover knows: a length-r vector of polynomials (cid:126)f ∈ (Zq[x])r
Veriﬁer learns: a length-r vector (cid:126)C of component-wise commit-
ments to polynomials in (cid:126)f, a component-wise evaluation (cid:126)ρ of (cid:126)f at
x = x0, and the evaluation point x0
1. The prover computes and sends (cid:126)C and (cid:126)ρ to the veriﬁer.
2. The veriﬁer chooses (cid:126)a = (cid:104)a1, . . . , ar(cid:105) ∈R (Z2κ )r and sends
it to the prover; meanwhile, the veriﬁer computes the dot
product ρa = (cid:126)ρ · (cid:126)a and the commitment Ca =(cid:81)r
.
i=1 C ai
i
3. The prover computes the dot product fa = (cid:126)f · (cid:126)a and the wit-
ness wa = CreateWitness (fa, x0), then sends wa to the
veriﬁer.
4. The veriﬁer checks if Ver (Ca, x0, ρa, wa) ?= true.
The noninteractive form of batch veriﬁcation works similarly,
except the prover computes and sends a vector of witnesses to the
veriﬁer (one for each polynomial commitment), and the veriﬁer
i ; in
particular, the vector (cid:126)a is local to the veriﬁer and the prover never
sees it.
combines the witnesses locally by computing wa =(cid:81)r
i=1 wai
689