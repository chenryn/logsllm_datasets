in Table XII. We ﬁnd that M2Crypto and Keyczar are
signiﬁcantly less usable than the baseline PyCrypto; Py-
NaCl is signiﬁcantly more usable. Unsurprisingly, symmetric-
condition participants reported signiﬁcantly more usability
than asymmetric-condition participants. The ﬁnal model in-
dicates that security background and having seen the assigned
library before were both associated with a signiﬁcant increase
in usability. Having used the library before was associated
with an increase relative to no familiarity, but this trend was
not signiﬁcant, probably because of the very small sample size:
only 18 participants reported having used their assigned library
before. Python experience was included in the ﬁnal model but
was not a signﬁciant covariate; the ﬁnal model did not include
any interactions between library and encryption mode.
We compiled our additional usability questions, drawn from
prior work as described in Section III-G, into a score out of
100 points. The results were similar to the SUS, and in fact,
the two scores were signiﬁcantly correlated (Kendall’s τ=0.65,
Factor
M2Crypto
cryptography.io
Keyczar
PyNaCl
asymmetric
experienced
sec. bkgrd.
seen lib
used lib
Coef. C.I.
-20.57
5.04
-18.07
7.56
-9.60
3.79
6.22
6.62
3.33
p-value
[-27.62, -13.52] <0.001*
[-1.52, 11.61]
0.131
<0.001*
[-25.85, -10.3]
[0.48, 14.64]
0.036*
<0.001*
[-14.13, -5.08]
0.146
[-1.33, 8.91]
[0.98, 11.46]
0.02*
0.037*
[0.39, 12.85]
[-5.95, 12.6]
0.481
Linear regression model examining SUS scores. The coefﬁcient indicates the
average difference in score between the listed factor and the base case.
Signiﬁcant values indicated with *. R2 = 0.376. See Section IV-B for
TABLE XII
further details.
p < 0.001). Using Cronbach’s alpha, we determined that the
scale’s internal reliability was high (α = 0.98).
Table XIII shows the results of a linear regression exam-
ining score on our scale. As before, M2Crypto and Keyczar
are signiﬁcantly worse than PyCrypto. Using this measure,
cryptography.io is signiﬁcantly better than PyCrypto, while
PyNaCl is better than PyCrypto but not signiﬁcantly so. Also
as before, signiﬁcantly higher scores were correlated with
symmetric tasks and with having seen the assigned library
before. Having used the library before was again correlated
with higher scores, but not signiﬁcantly so, probably due to
sample size. Security background was included in the ﬁnal
model but not signiﬁcant; Python experience and interactions
between library and encryption mode were not included in the
ﬁnal model.
The answers to questions about the API documentation indi-
cate that Keyczar and M2Crypto have a sizable problem with
their documentation: Our participants consistently answered
that they found neither helpful explanations nor helpful code
examples in the documentation, and that they had to spend a lot
of time reading the documentation before they could solve the
tasks. Altogether, they found the documentation for Keyczar
and M2Crypto not helpful. This corresponded to responses
saying that the tasks were not straightforward to implement
165
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:21:34 UTC from IEEE Xplore.  Restrictions apply. 
Factor
M2Crypto
cryptography.io
Keyczar
PyNaCl
asymmetric
sec. bkgrd.
seen lib
used lib
Coef. C.I.
-22.44
7.21
-21.59
5.66
-8.00
3.94
6.60
6.74
p-value
[-28.54, -16.35] <0.001*
[1.45, 12.97]
0.014*
[-28.41, -14.77] <0.001*
[-0.5, 11.82]
0.072
<0.001*
[-11.99, -4.02]
[-0.66, 8.54]
0.093
0.019*
[1.12, 12.09]
[-1.41, 14.88]
0.104
Linear regression model examining scores on our cognitive-dimension-based
scale. The coefﬁcient indicates the average difference in score between the
listed factor and the base case (PyCrypto and symmetric, respectively).
Signiﬁcant values indicated with *. R2 = 0.466. See Section IV-B for
TABLE XIII
further details.
for these two libraries. Interestingly, for cryptography.io, the
perceived effort that had to be invested into understanding the
library in order to be able to work on the tasks was the lowest.
For cryptography.io, PyNaCl, and PyCrypto, the developers
felt that after having used the library to solve the tasks, they
had a pretty good understanding of how the library worked.
For color, we include a few exemplar quotes from our
participants who chose to comment on the documentation.
One participant said the Keyczar documentation was “awful
and doesn’t seem to document its Python API at all.” A second
said, “I don’t understand why you have an API with no search
feature and functional descriptions. This is insane,“ and a third
commented that “The linked document is so unkind that I must
read the code.” A third Keyczar participant left an ASCII-art
comment spelling out “Your documentation is bad and you
should feel bad.”
One participant assigned to M2Crypto called the docu-
mentation “solidly awful,” “just
terrible,” and “completely
unusable.” The same participant inquired whether our request
to use this library was “a joke” or “part of the study.”
Other M2Crypto participants said “the linked documentation
is wildly insufﬁcient” and M2Crypto’s “interface is arcane
and documentation hard to understand.” Several participants
assigned to this library commented that they had to revert to
Stack Overﬂow posts or blog entries found via search engines
to be able to work on the tasks at all.
In contrast, one participant working with cryptography.io
called a tutorial contained in the documentation “amazing!”
while stating that “The comparable OpenSSL docs make one
want to jump off a cliff.” Another said the documentation “was
confusing at ﬁrst, but later I got the hang of it.”
G. Examining individual tasks
Success in solving the tasks varied not only across libraries,
but also across individual tasks, as illustrated in Figure 5.
We analyze these results for trends, rather than statistical
signiﬁcance, to avoid diluting our statistical power by testing
the same results in multiple ways.
166
Encryption proved easiest. Symmetric participants achieved
85.2% functional success, with 70.1% of those rated secure;
72.0% of asymmetric encryption tasks were functional, with
78.8% of those rated secure. In contrast, the hardest task
to solve overall dealt with certiﬁcate validation. Only 22.4%
of asymmetric participants were able to provide a functional
solution, and not a single one was secure. Key generation tasks
fell in the middle.
Investigating security errors. We also examined trends in
the types of security errors made by our participants. (For a
full accounting, see Table XIV in Appendix B.)
We ﬁrst consider symmetric cryptography, and in particular
situations where participants were allowed to make security
choices. Only M2Crypto and PyCrypto allow developers to
choose an encryption algorithm; interestingly, all 11 PyCrypto
participants selected DES (insecure), but no M2Crypto partic-
ipants chose an insecure algorithm. While M2Crypto’s ofﬁcial
API documentation does not provide code examples, the ﬁrst
results on Google when searching “m2crypto encryption” pro-
vide code snippets that use AES. The PyCrypto documentation
does provide code examples for symmetric encryption and
discourages the use of DES as a weak encryption algorithm.
However, the ﬁrst Google results when searching “pycrypto
encryption” provide code examples that use DES. Nine of the
11 participants who used DES mentioned speciﬁc blog posts
and Stack Overﬂow posts that we later determined to have
insecure code snippets.
Similarly, allowing developers to pick modes of operation
resulted in relatively many vulnerabilities. PyCrypto partici-
pants chose the insecure ECB as mode of operation explicitly
or did not provide a mode of operation parameter at all (ECB
is the default). As with selecting an encryption algorithm,
affected participants reported using blog posts and Stack Over-
ﬂow posts containing insecure snippets as information sources.
PyCrypto participants chose static IVs more frequently than
those using other libraries; interestingly, this corresponds to
not mentioning the importance of a truly random IV in the
documentation. Relatedly, requiring developers to pick key
sizes manually frequently resulted in too-small keys, across
libraries.
Interestingly, PyCrypto participants were most
likely to
fail
to use any key derivation function, possibly because
the documentation uses a plain string for an encryption key.
PyNaCl and PyCrypto participants used an insecure custom
key derivation function more frequently than participants in
other conditions: they frequently used a simple hash function
for key stretching. cryptography.io participants, in contrast,
performed exceedingly well on this task, likely because the
included PBKDF2 function is well documented and close
to the symmetric encryption example. On the negative side,
cryptography.io users picked static salts for PBKDF2 more
frequently than others, even though the code example in the
API documentation uses a random salt; however, no expla-
nation on the importance of using a random value is given.
Storing encryption keys in plaintext rather than encrypted was
also common across all libraries.
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:21:34 UTC from IEEE Xplore.  Restrictions apply. 
Fig. 5. Percentage of tasks with functionally correct solutions (left), and percentage of functional solutions that were rated secure (right), organized by library
and task type.
Generating and storing asymmetric keys was signiﬁcantly
less vulnerable to weak cryptographic choices. Only PyCrypto
and M2Crypto participants failed to pick sufﬁciently secure
RSA key sizes, potentially due again to insecure code exam-
ples (mentioning 1024-bit keys) among the top Google search
results. Since all libraries but Keyczar and PyNaCl provide a
private-key export function that offers encryption, asymmetric
private-key storage had comparably few insecurities. However,
PyNaCl users had to manually encrypt their private key and
ran into similar security problems as the symmetric-encryption
users mentioned above. Asymmetric encryption produced rel-
atively few security errors.
Certiﬁcate validation was the most challenging task. Across
all libraries, participants had trouble properly implementing
signature validation, hostname veriﬁcation, CA checks, and
validity checks. This may be caused by task complexity and
insufﬁcient API support.
V. DISCUSSION AND CONCLUSION
Our results suggest that usability and security are deeply
interconnected in sometimes surprising ways. We distill some
high-level ﬁndings derived from our individual results and sug-
gest future directions for library design and further research.
Simplicity does promote security (to a point). In general,
the simpliﬁed libraries we tested produced more secure results
than the comprehensive libraries, validating the belief that
simplicity is better. Further, cryptography.io proved secure
for the symmetric tasks (primarily doable via the simpliﬁed
“recipes” layer) but not for the asymmetric tasks (primarily
requiring use of the complex “hazmat” layer). This reinforces
both the idea that simplicity promotes security and the need
for simpliﬁed libraries to offer a broader range of features.
However, even simpliﬁed libraries did not entirely solve the
security problem; in all but one condition, the rate of security
success was below 80%. These security errors were frequently
caused by missing features (discussed next). Worse, for 20% of
functional solutions, the participant rated their code as secure
when it was not; this indicates a dangerous gap in recognition
of potential security problems.
Features and documentation matter for security. Several
of the libraries we selected did not (or not well) support tasks
auxiliary to encryption and decryption, such as secure key
storage and password-based key generation. These missing
features caused many of the insecure results in the otherwise-
successful simpliﬁed libraries. We argue that to be usably
secure, a cryptographic API must support such auxiliary tasks,
rather than relying on the developer to recognize the potential
for danger and identify a secure alternate solution. Further, we
suggest that cryptographic APIs should be designed to support
a reasonably broad range of use cases; requiring developers to
learn and use new APIs for closely related tasks seems likely
to drive them back to comprehensive libraries like PyCrypto
or M2Crypto, which pose security risks.
Documentation is also critical. PyCrypto, for example,
contains symmetric encryption examples that use AES in
ECB mode, which is prima facie insecure. Participants who
left the PyCrypto documentation to search for help on Stack
Overﬂow and blogs often ended up with insecure solutions;
this suggests the importance of creating ofﬁcial documentation
that is useful enough to keep developers from searching out
unvetted, potentially insecure alternatives. Many participants
copied these examples in their solutions. In contrast,
the
excellent code examples for PyNaCl and in the cryptography.io
“recipes” layer appear to have contributed to high rates of
security success.
What do we mean by usable? Despite claims of usability
and a simpliﬁed API, Keyczar proved the most difﬁcult to
use of our chosen libraries. This was caused primarily by two
issues: poor documentation (as measured by our API usability
scale) and the lack of documented support for key generation
167
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:21:34 UTC from IEEE Xplore.  Restrictions apply. 
in code, rather than requiring interaction at the command line.
Those few participants who successfully achieved functional
code had very high rates of security, but in practice developers
who give up on a library because they cannot make it work for
the desired task will not be able to take advantage of potential
security beneﬁts. For example, developers who have difﬁculty
with Keyczar might
turn to PyCrypto, which participants
preferred but which showed poor security results.
A blueprint
for future libraries. Taken together, our
results suggest several important considerations for designers
of future cryptographic libraries. First, the recent emphasis on
simplifying APIs (and choosing secure defaults) has provided
improvement; we endorse continuing in this direction. We
suggest, however, that library designers go further, by treating
documentation quality as a ﬁrst-class requirement, with partic-
ular emphasis on secure code examples. We also recommend
that library designers consider a broad range of potential tasks
users might need to accomplish cryptographic goals, and build
support for each of them into a more comprehensive whole.
Our results suggest that supporting holistic, application-
level tasks with ready-to-use APIs is the best option. That
said, we acknowledge that it may be difﬁcult or impossible to
predict all tasks API users may want or need. Therefore, where
lower-level features are necessary, they should be intentionally
designed to make combining them into more complex tasks
securely as easy as possible.
Looking forward, further research is needed to design and
evaluate libraries that meet these goals. Some changes can also
be made within existing libraries—for example, improving
documentation, changing insecure defaults to secure defaults,
or even adding compiletime or runtime warnings for insecure
parameters. These changes should be evaluated involving
future users both before they are deployed and longitudinally
to see how they affect outcomes within real-world code. We
also hope to reﬁne and expand the usability scale developed
in this paper to create an evaluation framework for security
APIs generally, providing both feedback and guidance for
improvement.
VI. ACKNOWLEDGMENTS
The authors would like to thank Mary Theofanos, Julie
Haney, Jason Suagee, and the anonymous reviewers for pro-
viding feedback; Marius Steffens and Birk Blechschmidt for
helping to test the infrastructure; Matt Bradley and Andrea
Dragan for help managing multi-institution ethics approvals;
and all of our participants for their contributions. This work
was supported in part by the German Ministry for Educa-
tion and Research (BMBF) through funding for the Center
for IT-Security, Privacy and Accountability (CISPA) (FKZ:
16KIS0344,16KIS0656), and by the U.S. Department of Com-
merce, National Institute for Standards and Technology, under
Cooperative Agreement 70NANB15H330.
REFERENCES
[1] Amnesty International USA, “Encryption - A Matter of Human Rights,”
2016.
[Online]. Available: https://www.amnestyusa.org/sites/default/
ﬁles/encryption - a matter of human rights - pol 40-3682-2016.pdf
168
[2] R. J. Anderson, “Why cryptosystems fail,” Communications of the ACM,
vol. 37, 1994.
[3] M. Georgiev, S.
Iyengar, S. Jana, R. Anubhai, D. Boneh, and
V. Shmatikov, “The most dangerous code in the world: validating SSL
certiﬁcates in non-browser software,” in Proceedings of the 2012 ACM
Conference on Computer and Communications Security (CCS 2012).
ACM, 2012.
[4] B. Reaves, N. Scaife, A. Bates, P. Traynor, and K. R. Butler, “Mo(bile)
money, mo(bile) problems: analysis of branchless banking applications
in the developing world,” in Proceedings of the 24th USENIX Security
Symposium (USENIX Security 2015). USENIX Association, 2015.
[5] M. Egele, D. Brumley, Y. Fratantonio, and C. Kruegel, “An empirical
study of cryptographic misuse in Android applications,” in Proceedings
of the 2013 ACM SIGSAC Conference on Computer and Communica-
tions Security (CCS 2013). ACM, 2013.
[6] S. Fahl, M. Harbach, T. Muders, M. Smith, and U. Sander, “Helping
Johnny 2.0 to encrypt his Facebook conversations,” in Proceedings of
the Eighth Symposium on Usable Privacy and Security (SOUPS 2012).
ACM, 2012.
[7] J. Viega, M. Messier, and P. Chandra, Network Security with OpenSSL.
O’Reilly Media, 2002.
[8] “Cryptography.io.” [Online]. Available: https://cryptography.io
[9] D. J. Bernstein, T. Lange, and P. Schwabe, “The security impact of
a new cryptographic library,” in Proceedings of the 2nd International
Conference on Cryptology and Information Security in Latin America
(LATINCRYPT 2012). Springer-Verlag, 2012.
[10] S. Fahl, M. Harbach, T. Muders, L. Baumg¨artner, B. Freisleben, and
M. Smith, “Why Eve and Mallory love Android: an analysis of Android
SSL (in)security,” in Proceedings of the 2012 ACM Conference on
Computer and Communications Security (CCS 2012). ACM, 2012.
[11] L. Onwuzurike and E. De Cristofaro, “Danger is My Middle Name:
Experimenting with SSL Vulnerabilities in Android Apps,” arXiv.org,
2015.
[12] M. Oltrogge, Y. Acar, S. Dechand, M. Smith, and S. Fahl, “To pin or
not to pin—helping app developers bullet proof their tls connections,” in
Proceedings of the 24th USENIX Security Symposium (USENIX Security
2015). USENIX Association, 2015.
[13] H. Perl, S. Fahl, and M. Smith, “You won’t be needing these any more:
On removing unused certiﬁcates from trust stores,” in Proceedings of
18th International Conference on Financial Cryptography and Data
Security (FC 2014). Springer Berlin Heidelberg, 2014.
[14] Y. Acar, M. Backes, S. Bugiel, S. Fahl, P. McDaniel, and M. Smith,
“SoK: Lessons Learned from Android Security Research for Appiﬁed
Software Platforms,” in Proceedings of the 37th IEEE Symposium on
Security and Privacy (SP 2016), 2016.
[15] S. Fahl, M. Harbach, M. Oltrogge, T. Muders, and M. Smith, “Hey, you,
get off of my clipboard,” in Proceedings on Financial Cryptography and
Data Security (FC 2013). Springer, 2013.
[16] S. Fahl, M. Harbach, H. Perl, M. Koetter, and M. Smith, “Rethinking
SSL development in an appiﬁed world,” in Proceedings of the 2013
ACM SIGSAC Conference on Computer and Communications Security
(CCS 2013). ACM, 2013.
[17] D. Lazar, H. Chen, X. Wang, and N. Zeldovich, “Why does crypto-
graphic software fail?” in Proceedings of the 5th Asia-Paciﬁc Workshop
on Systems. ACM, 2014.
[18] S. Nadi, S. Kr¨uger, M. Mezini, and E. Bodden, ““Jumping Through
Hoops”: Why do Java Developers Struggle With Cryptography APIs?”
in Proceedings of the 37th International Conference on Software Engi-
neering (ICSE 2016), 2016.
[19] Y. Acar, M. Backes, S. Fahl, D. Kim, M. L. Mazurek, and C. Stransky,
“You Get Where You’re Looking For: The Impact of Information
Sources on Code Security,” in Proceedings of the 37th IEEE Symposium
on Symposium on Security and Privacy (SP 2016), 2016.
[20] S. Arzt, S. Nadi, K. Ali, E. Bodden, and S. Erdweg, “Towards secure
integration of cryptographic software,” in Proceedings of the 2015 ACM
International Symposium on New Ideas, New Paradigms, and Reﬂections
on Programming and Software (Onward! 2015), 2015.
[21] S. Indela, M. Kulkarni, K. Nayak, and T. Dumitra, “Helping Johnny
encrypt: Toward semantic interfaces for cryptographic frameworks,”
in Proceedings of the 2016 ACM International Symposium on New
Ideas, New Paradigms, and Reﬂections on Programming and Software
(Onward! 2016), 2016.
[22] B. A. Myers and J. Stylos, “Improving API usability,” Communications