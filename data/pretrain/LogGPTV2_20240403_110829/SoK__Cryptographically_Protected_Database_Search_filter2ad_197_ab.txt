(joins), projection, and selection. Complex queries can typi-
cally be generated by composing these operations. Relational
algebra and the composability of operations allow a server-
side query planner to optimize query execution by rearranging
operations to still produce the same result [68].
2) Associative Arrays: Associative arrays are a mathe-
matical basis for several styles of database engines [50].
They provide a mathematical foundation for key-value store
NoSQL databases. Associative array algebra consists of the
following base operations: construction, ﬁnd, associative array
addition, associative array element-wise multiplication, and
array multiplication [47]. Associative arrays are built on top of
the algebraic concept of a semiring (a ring without an additive
inverse). Addition or multiplication in an associative array can
denote any two binary operations from an algebraic semiring.
Usually, these two operations are the traditional × and +, but
in the min-plus algebra the two operations are min and + (in
the max-plus algebra the two operations are max and +).
3) Linear Algebra: A number of newer NewSQL databases
support linear algebraic operations. GraphBLAS is a current
standardization eﬀort underway for graph algorithms [69].
In GraphBLAS, graph data is stored using sparse matrices,
and the linear algebraic base operations of construction, ﬁnd,
matrix addition, matrix multiplication, and element-wise mul-
tiplication are composed to create graph algorithms. Examples
of how the GraphBLAS can be applied to popular graph
algorithms are given in [70], [71].
C. Database Roles and Operations
We consider ﬁve important database roles, analogous to
roles in database systems like Microsoft SQL Server 2016
[72]:
∙ A provider, who provides and modiﬁes the data.
∙ A querier, who wishes to learn things about the data.
∙ A server, who handles storage and processing.
174
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:23:00 UTC from IEEE Xplore.  Restrictions apply. 
Query Basis
Rel. Algebra
Set Union
Set Diﬀerence
Products/Joins
Projection
Selection
Assoc. Array Alg.
Construct
Find
Array (+, ×)
Element-wise ×
Linear Algebra
Construct
Find
Matrix (+, ×)
Element-wise ×
Multiple bases
Technology
SQL [36]:
Relational
NewSQL [42]:
Relational
Federated [58]
NoSQL [41]:
Key-value
NoSQL [64]:
Graph
Databases
NewSQL [66]:
Array
Databases
Polystore [43]
Transaction support,
ACID guarantees,
Table representation of data
Use of in-memory,
new system arch.
or simpliﬁed data model
Relational model,
Partitioned/replicated tables
Horizontal scalability,
Data rep. as key-value pairs,
BASE guarantees [60]
Data represented as adjacency
or incidence matrix,
Horizontal scalability,
Graph operation API
ACID guarantees,
Data represented as arrays
(dense or sparse)
Disparate DBMSs
Popular interface,
Common data model [51]
Upfront schema design,
Low insert & query rate
Popular interface,
Transactional support,
ACID guarantees
Transactional support,
High performance,
ACID guarantees
High insert rates,
Cell-level security
Flexible schema
Req. expensive hardware,
Often only relational data
model
Upfront schema design,
Often only relational data
model
Sacriﬁce one of the fol-
lowing: consistency, avail-
ability, or partition toler-
ance
Natural data representation,
Amenable to graph algs.
Performance,
Diverse data models,
Diﬃcult to optimize
Examples
MySQL [52]
Oracle DB [53]
Postgres [54]
Spanner [55]
MemSQL [56]
Spark SQL [57]
Garlic [58]
DB2 [59]
BigTable [41]
Accumulo [61]
HBase [62]
mongoDB [63]
Neo4j [64]
System G [65]
Fundamental characteristics
Strengths
Weaknesses
High performance,
Transactional support,
Good for scientiﬁc comp.
High performance,
Flexible data stores,
Diverse data/programming
models
TABLE I
Data model restrictions,
Lack of iterator support
SciDB [66]
TileDB [67]
Requires middleware
BigDAWG [43]
Myria [45]
SUMMARY OF A (NOT EXHAUSTIVE) SET OF POPULAR CURRENT AND EMERGING QUERY BASES TOGETHER WITH THEIR CORRESPONDING DATABASE
TECHNOLOGIES. CHARACTERISTICS, STRENGTHS, WEAKNESSES, AND EXAMPLES REFER TO THE TECHNOLOGIES, NOT THE QUERY BASES.
∙ An authorizer, who speciﬁes data- and query-based rules.
∙ An enforcer, who ensures that rules are applied.
Databases provide an expressive language for representing
permissions, or rules. Rules are enforced by authenticating the
roles possessed by a valid user and granting her the appropriate
powers. In general, each user may perform multiple roles, and
each role may be performed by multiple users.
While databases oﬀer a wide range of features, we focus on
four operations: 𝐈𝐧𝐢𝐭, 𝐐𝐮𝐞𝐫𝐲, 𝐔𝐩𝐝𝐚𝐭𝐞, and 𝐑𝐞𝐟𝐫𝐞𝐬𝐡. These op-
erations are common across the database paradigms described
above; we describe them below in the context of protected
search.
∙ 𝐈𝐧𝐢𝐭: The initialization protocol occurs between the
provider (who has data to load) and the server. The server
obtains a protected database representing the loaded data.
∙ 𝐐𝐮𝐞𝐫𝐲: The query protocol occurs between the querier
(with a query), the server (with the protected database),
the enforcer (with the rules), and possibly the provider.
The querier obtains the query results if the rules are
satisﬁed.
∙ 𝐔𝐩𝐝𝐚𝐭𝐞: The update protocol occurs between the provider
(with a set of updates) and the server. The server obtains
an updated protected database. Updates include insertions,
deletions, and record modiﬁcations.
∙ 𝐑𝐞𝐟𝐫𝐞𝐬𝐡: The refresh protocol occurs between the
provider and the server. The server obtains a new pro-
tected database that represents the same data but
is
designed to achieve better performance and/or security.
All systems considered in this work support 𝐈𝐧𝐢𝐭 and 𝐐𝐮𝐞𝐫𝐲,
but only some systems support 𝐔𝐩𝐝𝐚𝐭𝐞 and 𝐑𝐞𝐟𝐫𝐞𝐬𝐡; see
Tables II and V for details.
D. Protected Database Search Systems
Informally, a protected search system is a database system
that supports the roles and operations deﬁned above, in which
each party learns only its intended outputs and nothing else. In
particular, a protected search system aims to ensure that the
server learns nothing about the data stored in the protected
database or about the queries, and the querier learns nothing
beyond the query results. These security goals can be formal-
ized using the real-ideal style of cryptographic deﬁnition. In
this paradigm, one imagines an ideal version of a protected
search system, in which a trusted external party performs
storage, queries, and modiﬁcations correctly and reveals only
the intended outputs to each party. The real system is said
to be secure if no party can learn more from its real world
interactions than it can learn in the ideal system.
We restrict our attention in this work to protected database
search systems that provide formally deﬁned security guaran-
tees based upon the strength of their underlying cryptographic
primitives. Some of the commercial systems mentioned in the
introduction lack formal security reductions; although they
are based on techniques with proofs of security, analysis is
required to determine whether diﬀerences from those proven
techniques aﬀect security.
Scenarios: Only a few existing protected search systems
consider the enforcement of rules (i.e., include an authorizer
and enforcer). Therefore, in this paper we focus primarily on
two scenarios: a three-party scenario comprising a provider,
a querier, and a server, and a two-party scenario in which a
single user acts as both the provider and the querier (we denote
175
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:23:00 UTC from IEEE Xplore.  Restrictions apply. 
this combined entity as the client). The latter scenario models a
cloud storage outsourcing application in which a client uploads
ﬁles to the cloud that she can later request. In the two-party
setting, the client has the right to know all information in the
database so it is only necessary to consider security against an
adversarial server. In this work, we focus on protected search
in the case of a single provider and a single querier; for the
more general setting in which multiple users can perform a
single role, see Section V and [73].
We stress that a secure search system for one scenario does
not automatically extend to another scenario. Additionally,
despite the limited attention in the literature thus far, we
believe that the authorizer and enforcer roles are an important
aspect of the continued maturation of protected search systems;
see Section V-A for additional discussion.
Threats: There are two types of entities that may pose
security threats to a database: a valid user known as an insider
who performs one or more of the roles, and an outsider who
can monitor and potentially alter network communications
between valid users. We distinguish between adversaries that
are semi-honest (or honest-but-curious), meaning they follow
the prescribed protocols but may passively attempt to learn
additional information from the messages they observe, and
those that are malicious, meaning they are actively willing to
perform any action necessary to learn additional information
or inﬂuence the execution of the system. An outsider adversary
(even a malicious one) can be thwarted using secure point-to-
point channels. Furthermore, we distinguish between adver-
saries that persist for the lifetime of the database and those
that obtain a snapshot at a single point in time [74]. The bulk
of active research in protected search technology considers
semi-honest security against a persistent insider adversary.
Performance and Leakage: While unprotected databases
are often I/O bound, protected systems may be compute
or network bound. We can measure the performance of a
protected operation by calculating the computational overhead
and the additional network use (in both the number of mes-
sages and the total amount of data transmitted). The type of
cryptographic operations matters as well: whenever possible,
slower public-key operations should be avoided or minimized
in favor of faster symmetric-key primitives.
In order to improve performance, many protected search
systems reveal or leak information during some or all oper-
ations. Leakage should be thought of as an imperfection of
the scheme. The real-ideal security deﬁnition is parameterized
by the system’s speciﬁc leakage proﬁle, which comprises a
sequence of functions that formally describe all information
that is revealed to each party beyond the intended output. A
security proof demonstrates that the claimed leakage proﬁle is
an upper bound on what is actually revealed to an adversary.
Protected search systems’ security is primarily distinguished
by their leakage proﬁle; our security discussion focuses on
leakage.
While leakage proﬁles are comprehensive, it is often diﬃ-
cult to interpret them and to assess their impact on the security
of a particular application (see Section III-B). To help with
this task, the next section identiﬁes common types of leakage.
E. Common Leakage Proﬁles
This section provides a vocabulary (partially based on
Kamara [75]) to describe common features of leakage system-
atically. While the exact descriptions of leakage proﬁles are
often complex, their essence can mostly be derived from four
characteristics: the objects that leak, the type of information
leaked about them, which operation leaks, and the party that
learns the leakage.
The following types of objects within a protected search
system are vulnerable to leakage.
1) Data items, and any indexing data structures.
2) Queries.
3) Records returned in response to queries, or other rela-
tionships between the data items and the queries (e.g.,
records that partially match a conjunction query).
4) Access control rules and the results of their application.
Next, we categorize the information leaked from each
object. The leakage may occur independently for each query or
response, or it may depend upon the prior history of queries
and responses. For complex queries like Booleans, leakage
may also depend on the connections between the clauses of a
query. While the details of leakage may depend on the speciﬁc
data structures used for representing and querying the data, we
list ﬁve general categories of information that may be leaked
from objects, ranked from the least to most damaging. We use
this ranking throughout our discussion of base queries.
(cid:2) Structure: properties of an object only concealable via
padding, such as the length of a string, the cardinality of
a set, or the circuit or tree representation of an object.
◔ Identiﬁers: pointers to objects so that their past/future
(cid:3)(cid:2) Predicates: identiﬁers plus additional information on ob-