函数签名：
函数的返回类型和形参列表构成了函数签名。因此，函数签名指定了传
入函数的值的类型和函数返回值的类型。
示例：
double duff(double, int); // 函数原型
int main(void)
{
double q, x;
int n;
...
q = duff(x,n);     //函数调用
...
}
double duff(double u, int k)  //函数定义
632
{
double tor;
...
return tor;  //返回double类型的值
}
633
9.8 关键概念
如果想用C编出高效灵活的程序，必须理解函数。把大型程序组织成若
干函数非常有用，甚至很关键。如果让一个函数处理一个任务，程序会更好
理解，更方便调试。要理解函数是如何把信息从一个函数传递到另一函数，
也就是说，要理解函数参数和返回值的工作原理。另外，要明白函数形参和
其他局部变量都属于函数私有，因此，声明在不同函数中的同名变量是完全
不同的变量。而且，函数无法直接访问其他函数中的变量。这种限制访问保
护了数据的完整性。但是，当确实需要在函数中访问另一个函数的数据时，
可以把指针作为函数的参数。
634
9.9 本章小结
函数可以作为组成大型程序的构件块。每个函数都应该有一个单独且定
义好的功能。使用参数把值传给函数，使用关键字return把值返回函数。如
果函数返回的值不是int类型，则必须在函数定义和函数原型中指定函数的类
型。如果需要在被调函数中修改主调函数的变量，使用地址或指针作为参
数。
ANSI 
C提供了一个强大的工具——函数原型，允许编译器验证函数调
用中使用的参数个数和类型是否正确。
C 函数可以调用本身，这种调用方式被称为递归。一些编程问题要用递
归来解决，但是递归不仅消耗内存多，效率不高，而且费时。
635
9.10 复习题
复习题的参考答案在附录A中。
1.实际参数和形式参数的区别是什么？
2.根据下面各函数的描述，分别编写它们的ANSI C函数头。注意，只需
写出函数头，不用写函数体。
a.donut()接受一个int类型的参数，打印若干（参数指定数目）个0
b.gear()接受两个int类型的参数，返回int类型的值
c.guess()不接受参数，返回一个int类型的值
d.stuff_it()接受一个double类型的值和double类型变量的地址，把第1个
值储存在指定位置
3.根据下面各函数的描述，分别编写它们的ANSI C函数头。注意，只需
写出函数头，不用写函数体。
a.n_to_char()接受一个int类型的参数，返回一个char类型的值
b.digit()接受一个double类型的参数和一个int类型的参数，返回一个int类
型的值
c.which()接受两个可储存double类型变量的地址，返回一个double类型
的地址
d.random()不接受参数，返回一个int类型的值
4.设计一个函数，返回两整数之和。
5.如果把复习题4改成返回两个double类型的值之和，应如何修改函数？
6.设计一个名为alter()的函数，接受两个int类型的变量x和y，把它们的
636
值分别改成两个变量之和以及两变量之差。
7.下面的函数定义是否正确？
void salami(num)
{
int num, count;
for (count = 1; count 
#define MONTHS 12
643
int main(void)
{
int days[MONTHS] = { 31, 28, 31, 30, 31, 30, 31, 31, 
30, 31, 30, 31 };
int index;
for (index = 0; index 
#define SIZE 4
645
int main(void)
{
int no_data[SIZE]; /* 未初始化数组 */
int i;
printf("%2s%14s\n",   "i", "no_data[i]");
for (i = 0; i < SIZE; i++)
printf("%2d%14d\n", i, no_data[i]);
return 0;
}
该程序的输出如下（系统不同，输出的结果可能不同）：
i   no_data[i]
0          0
1      4204937
2      4219854
3   2147348480
使用数组前必须先初始化它。与普通变量类似，在使用数组元素之前，
必须先给它们赋初值。编译器使用的值是内存相应位置上的现有值，因此，
读者运行该程序后的输出会与该示例不同。
注意 存储类别警告
数组和其他变量类似，可以把数组创建成不同的存储类别（storage
646
class）。第12章将介绍存储类别的相关内容，现在只需记住：本章描述的数
组属于自动存储类别，意思是这些数组在函数内部声明，且声明时未使用关
键字static。到目前为止，本书所用的变量和数组都是自动存储类别。
在这里提到存储类别的原因是，不同的存储类别有不同的属性，所以不
能把本章的内容推广到其他存储类别。对于一些其他存储类别的变量和数
组，如果在声明时未初始化，编译器会自动把它们的值设置为0。
初始化列表中的项数应与数组的大小一致。如果不一致会怎样？我们还