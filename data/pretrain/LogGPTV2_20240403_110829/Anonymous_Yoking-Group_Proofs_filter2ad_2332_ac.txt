raphy pre-deﬁne a group by sharing a group key, identity or
distinctive counters. Similar method is employed, especially
in some protocols which intend to protect the tag’s identity
and provide anonymity proofs. One reason for this is that
the symmetric-key based protocols normally require exhaus-
tive key search to check the validity of proofs and undeﬁned
groups may cause eﬃciency problems as the veriﬁer has to
618Tag Tl Tag Tr
Reader R
a, modif ied yoking−proof
←−−−−−−−−−−−−−−−−−−−−→
m = (σl, σ(cid:48)
l, ∆l, σr, σ(cid:48)
r, ∆r, σj , ∆j )
ΣG = (a, σi, σ(cid:48)
i, ∆i, σj , σ(cid:48)
j , ∆j )
Tag Ti (i, Ki
I , Ki
A, Ki
D)
a
−−−−−−−−−−−−→
←−−−−−−−−−−−− bi
−−−−−−−−−−−−→
i,σi ,∆i
m
$←− {0, 1}k, σi = Ki
A ⊕ bi, ∆i = H(bi||a)
ml = σr||σi, mr = σl||σi, Kl(cid:48)
If σ(cid:48)
else Kr(cid:48)
r (cid:54)= 0, Kr(cid:48)
N = 0, Ki
N = σ(cid:48)
N = σ(cid:48)
r ⊕ H(σr ⊕ Ki
N||Kr(cid:48)
N ||Ki
I )
N ⊕ H(mi)
N = H(Kl(cid:48)
i = Ki
l ⊕ H(σl ⊕ Ki
D||mr||∆l)
D||ml||∆r)
σ(cid:48)
←−−−−−−−−−−−− mi = bi||σj||∆j , σ(cid:48)
i
Figure 4: Yoking-group proof with group anonymity for two groups.
test all the possible combinations of tags. Hence, in our pro-
tocol, we assume that the groups are deﬁned prior to being
authenticated.
An important consideration to a grouping-proof protocol
which needs to prevent group’s identity is that the compu-
tational cost to a veriﬁer shall be lower than the way of
exhaustive key search for each tag. As one phase of yoking-
group proof protocol, the group authentication in our pro-
tocol only requires constant computational cost O(1) in ver-
ifying the validity of a group. Moreover, the total cost of
proof veriﬁcation equals to the cost of authenticating our
yoking proof. To reduce the computational cost and guar-
antee the integrity of a group, we employ a binary tree as a
logical structure to represent tags and each tag is assigned a
diﬀerent index in the speciﬁc group. The veriﬁer only needs
to check the validity of a proof generated by the root tag
instead of all the tags.
The size of a proof inﬂuences the performance of a pro-
tocol. Normally, a larger size indicates that more compo-
nents should be checked during the veriﬁcation. Regardless
whether the proof is a compressed message, it is undesir-
able if the tags are veriﬁed individually. As a feature of
our anonymous yoking-group proof protocol, the length of a
proof remains the same size of our yoking-proof.
5.2 Constructions
Our protocol is described as in Figure 4 that it shows
the proof for two groups. To simplify our protocol, we only
consider that each group consist of three tags, while the pro-
tocol can be extended to groups which contain any number
of tags.
Without loss of generality, we ﬁrstly introduce a binary
tree which represents the logical structure of a group of tags.
According to Figure 5, each node, including leaves and root,
represents a tag. From top to down and left to right in
each level, a tag T is assigned to an index i and the root is
labelled as 1. For a tag Ti, it stores three keys which are
identiﬁcation key K i
A and decryption
key K i
D. Initially, the tag owner sets these keys as follows.
I , authentication key K i
K i
I
$←− K, K i
D
$←− K, K i
A = K p
D,
D ∈ K is the decryption key of Ti’s parent. In case
where K p
that if Ti is the root of a tree, the owner randomly chooses
A from K. The group key KG is constructed as
a key K i
in a Merkle tree that for each non-leaf node Ni, set K i
N =
N||K i
N||K r
H(K l
N are node keys of Ni’s left
and right child respectively and K i
I is the identiﬁcation key
of Ti in Ni. If Ti is in a leaf of a tree, we set K i
N = K i
I .
I ), where K l
N , K r
Figure 5: Labeled tree for a group of tags.
Clearly, apart from the leaves, a tag does not keep a node
key, instead, the node keys are built during the protocol
Indeed, the protocol rebuilds the Merkle tree
execution.
and outputs the group key K 1
N at the root T1. The veriﬁer
maintains the group key and it indicates the identity of a
speciﬁc group of tags.
In the grouping phase of our protocol, tags generate a
proof of group. As an example, we show a single round of
grouping-proof via our yoking-group proof protocol and the
grouping-proof can be accomplished recursively for a larger
group. We denote that T1 is a root and T2, T3 are respec-
tively left and right child of T1. Without loss of generality,
we refer tags T2 and T3 to Tl and Tr, respectively.
To start with, the reader R broadcasts a request along
with a nonce a. A tag sends its index as a part of the
ﬁrst response to R. According to our system model, the
reader builds a hash tree structure based on the indexes and
maintains a link to each tag.
In terms of one group, Tl,
Tr and R ﬁrstly run the yoking-proof protocol illustrated in
Section 4. The only diﬀerence is that the reader sets the
message
σl = σl||σi,
σr = σr||σi,
l, ∆l, σr, σ(cid:48)
where σi is generally the response of challenge a from the
tags’ parent. The reader collects a yoking-proof Σ and Ti’s
response (σi, ∆i). Concurrently, the reader obtains the reply
(σj, ∆j) form Tj, which is the root of another group.
After compiling proofs, the reader sends the message m =
(σl, σ(cid:48)
r, ∆r, σj, ∆j) to the root Ti and starts the
yoking phase. Upon receiving the message m, Ti extracts
the node keys K l
N , K r
N of two tags and computes the node
key K i
N . In a case that if node Ni of a tree only has left child,
the reader sets (σr, σ(cid:48)
r) = (σi, 0), where σi is a response
of Ni. Accordingly, the tag Ti ignores a message σ(cid:48)
r and
simply sets K r
N = 0. We should note that this step does not
guarantee the correctness of node keys as a tag handles the
received message without authentication. Since the goal of
619[8] H.-Y. Chien, C.-C. Yang, T.-C. Wu, and C.-F. Lee.
Two RFID-based solutions to enhance inpatient
medication safety. J. Medical Systems, 35(3):369–375,
2011.
[9] D. N. Duc and K. Kim. Grouping-proof protocol for
RFID tags: Security deﬁnition and scalable
construction. IACR Cryptology ePrint Archive,
2009:609, 2009.
[10] J. Hermans and R. Peeters. Private yoking proofs:
Attacks, models and new provable constructions. In
RFIDSec, LNCS, pages 96–108. Springer, 2012.
[11] H.-H. Huang and C.-Y. Ku. A RFID grouping proof
protocol for medication safety of inpatient. J. Medical
Systems, 33(6):467–474, 2009.
[12] A. Juels. ”yoking-proofs” for RFID tags. In PerCom
Workshops, pages 138–143. IEEE Computer Society,
2004.
[13] Y. K. Lee, L. Batina, D. Singel´ee, and I. Verbauwhede.
Low-cost untraceable authentication protocols for
RFID. In WISEC, pages 55–64. ACM, 2010.
[14] Y. K. Lee, L. Batina, D. Singel´ee, and
I. Verbauwhede. Wide-weak privacy-preserving RFID
authentication protocols. In MOBILIGHT, volume 45
of LNCS, Social Informatics and Telecommunications
Engineering, pages 254–267. Springer, 2010.
[15] T. Li, G. Wang, and R. H. Deng. Security analysis on
a family of ultra-lightweight RFID authentication
protocols. JSW, 3(3):1–10, 2008.
[16] Y. Lien, X. Leng, K. Mayes, and J. Chiu. Reading
order independent grouping proof for RFID tags. In
ISI 2008, pages 128–136. IEEE, 2008.
[17] H. Liu, H. Ning, Y. Zhang, D. He, Q. Xiong, and L. T.
Yang. Grouping-proofs-based authentication protocol
for distributed RFID systems. IEEE Trans. Parallel
Distrib. Syst., 24(7):1321–1330, 2013.
[18] P. Peris-Lopez, J. C. Hernandez-Castro, J. M.
Est´evez-Tapiador, and A. Ribagorda. Solving the
simultaneous scanning problem anonymously:
Clumping proofs for RFID tags. SECPerU, pages
55–60. IEEE Computer Society, 2007.
[19] P. Peris-Lopez, A. Orﬁla, J. C. Hernandez-Castro, and
J. C. A. van der Lubbe. Flaws on RFID
grouping-proofs. Guidelines for future sound protocols.
J. Network and Computer Applications,
34(3):833–845, 2011.
[20] J. Saito and K. Sakurai. Grouping proof for RFID
tags. In AINA, pages 621–624. IEEE Computer
Society, 2005.
[21] B. Song and C. J. Mitchell. RFID authentication
protocol for low-cost tags. In WISEC’08, pages
140–147. ACM, 2008.
our protocol is to check the simultaneous scanning of groups
and the hash tree ensures the integrity of a group, there is no
need to verify messages during the proof. The veriﬁer is able
to verify the group’s integrity when it checks the validity of
a yoking-group proof.
Finally, Ti outputs a reply σ(cid:48)
N and Tj outputs
σ(cid:48)
j via the same approach. Upon receiving two responses
(σi, σ(cid:48)
j, ∆j), the reader compiles a yoking-
group proof ΣG. The veriﬁer checks the validity of proofs
by searching key pairs (K i
i, ∆i) and (σj, σ(cid:48)
i by using K i
A, K i
N ) and (K j
A, K j
N ).
Extension for Multi-group Proof. Assume that there
are n groups. In the grouping phase, a reader collects each
root tag’s response (σi, ∆i), where i = 1, 2,··· , n. For ex-
ample, (σ1, ∆1) is the response of the root tag of group G1.
In the yoking phase, the reader transmits (σk, ∆k), where
k = 1, 2,··· , n − 1, from group Gk to Gk+1, then trans-
mits (σn, ∆n) to G1. Note that this step can be performed
concurrently and the following steps are the same as in two-
group version.
6. SECURITY ANALYSIS
Due to the page limitation, the proof is in the full version.
Theorem 1. Our anonymous yoking-proof protocol and
anonymous yoking-group proof protocol UC-realizes the func-
tionality Fayp and Faygp with random oracles, respectively.
7. CONCLUSION
In this paper, we introduced a novel concept of anonymous
yoking-group proofs. The proposed anonymous yoking-proof
protocol achieves computational eﬃciency on tags and re-
mains the required security properties. Our anonymous
yoking-group proofs convince a veriﬁer that multiple groups
of tags are simultaneously scanned. We discussed some com-
mon attacks to RFID protocols and the security and privacy
are formally proved in the UC framework.
8. REFERENCES
[1] L. Batina, Y. K. Lee, S. Seys, D. Singel´ee, and
I. Verbauwhede. Privacy-preserving ecc-based
grouping proofs for RFID. In ISC, LNCS, pages
159–165. Springer, 2010.
[2] L. Batina, Y. K. Lee, S. Seys, D. Singel´ee, and
I. Verbauwhede. Extending ecc-based RFID
authentication protocols to privacy-preserving
multi-party grouping proofs. Personal and Ubiquitous
Computing, 16(3):323–335, 2012.
[3] L. Bolotnyy and G. Robins. Generalized
”yoking-proofs” for a group of RFID tags. In
MobiQuitous’05, pages 1–4.
[4] M. Burmester, B. de Medeiros, and R. Motta.
Provably secure grouping-proofs for RFID tags. In
CARDIS, volume 5189 of LNCS, pages 176–190, 2008.
[5] M. Burmester and J. Munilla. Lightweight RFID
authentication with forward and backward security.
ACM Trans. Inf. Syst. Secur., 14(1):11, 2011.
[6] M. Burmester and J. Munilla. Distributed group
authentication for RFID supply management. IACR
Cryptology ePrint Archive, 2013:779, 2013.
[7] R. Canetti. Universally composable security: A new
paradigm for cryptographic protocols. In FOCS, pages
136–145. IEEE Computer Society, 2001.
620