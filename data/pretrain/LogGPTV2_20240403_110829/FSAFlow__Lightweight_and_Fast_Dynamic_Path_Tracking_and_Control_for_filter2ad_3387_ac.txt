rithm  performs  width-first  traversal  of  the  ICFG  from  the 
source statement and searches for all paths ending with the sink 
statement in  E*. Therefore, if there is a path from node  to node  in G*, the sequence 
of statements corresponding to the nodes on the path constitutes 
the information flow path from source to sink.  
FSAFlow continues to extend G* to G^=(N^,E^), where N^= 
N*×String and E^={→ | (u, v)∈E*, dy
∈fu(dx)}. PFSA records the key information to identify the path 
so far, including the context of branch statements and call/return 
statements, etc. The search and recording are performed con-
currently. The specific static analysis is shown in Algorithm 1. 
In Algorithm 1, The inputs Sourcelist and Sinklist are ob-
tained by reading user policy files, and G# is generated by call-
ing the SOOT tool. First, G# is searched to find the source state-
ment set. Then, each source is taken as a starting point to search 
E^ for the paths to the target sinks. The searched edges are rec-
orded in the variable pathedge and will not be searched again 
②
①
public class DoLogin ... {
   protected void onCreate(...) {……
     Intent data = getIntent();//source
     password = data.…;
     new RequestTask().execute("password");
     ……}
   class RequestTask ... {        
      protected String doInBackground(...) {
        postData(...);
        …… }
      public void postData(...){
         ……
         result = convertStreamToString( in );
         ……
         Loginfo=Loginfo_tmpt1;
         Loginfo_tmpt2=Loginfo_tmpt1;
         if (...) {
           if(...){
③
④
⑧
1
2
3
4
5
6
7
8
9
10
11
14
15
16
17
18
19
20
21
22
⑥
⑦
⑤
Loginfo[0]=username + password;
}else{
⑨
   Loginfo[0]="...";}
  …
Log.d(Loginfo_tmpt2[0]);//sink
(a)
               …
       }  }
      private String convertStreamToString(... ) {
         ……  }
 }  }
25
26
27
28
29
30
com.android.insecurebankv2.DoLogin---->>
void onCreate(android.os.Bundle)---->
sourcestart￥￥$r2 = virtualinvoke 
$r0.()
com.android.insecurebankv2.DoLogin$RequestTask---->>
java.lang.String doInBackground(java.lang.String[])---->
##newinvoke
##|branchmid|￥1￥9￥9￥x￥-1
void (com.android.insecurebankv2.DoLogin)---->
##newinvoke
java.lang.Object doInBackground(java.lang.Object[])---->
##newinvoke
java.lang.String convertStreamToString(java.io.InputStream)---->
##newinvoke
##|branchmid|￥3￥2￥1￥x￥-1
##|branchmid|￥4￥2￥2￥x￥-1
void postData(java.lang.String)---->
##newinvoke
##|branchmid|￥2￥2￥1￥x￥-1
##|branchmid|￥5￥2￥1￥x￥-1
##|branchmid|￥6￥2￥1￥x￥-1
##sinkend￥7￥￥staticinvoke ("Successful Login:", $r1)￥$r1(java.lang.String) * | >>
(b)
Fig. 4.  Information flow analysis and path coding 
(lines 12-13). The variable Worklist records the set of edges that 
remain to be searched. The newly found edges will be added to 
Worklist (lines 7, 23,27, etc.), and the old edges that have been 
searched will be removed from the worklist (line 11).  
The string array PFSA stores the information of each key node 
sequentially. In PFSA, different nodes are segmented with a spe-
cial separator. FSAFlow extracts different key information for 
different statement types. 
1)  The statement type sink (lines 16-18). It indicates that a 
flow path has been found. At this time, the path expansion is 
terminated and PFSA is output. 
2)  The statement type function call (lines 19-27). When this 
node is first encountered, the caller’s and callee’s call-site in-
formation is appended to PFSA, and the path is extended to the 
callee.  Otherwise,  the  new  extended  path  fragment  PartFSA 
about the callee can be extracted from the function summary 
Summaryhash, and the search is then performed on the return-
site node. 
3)  The  statement  type  function  return  (lines  28-33).  The 
function summary is appended to Summaryhash for reuse. Then, 
the algorithm returns to the call node and continues to expand 
the next statement. Summaryhash stores the path fragment of 
the information flow when it flows through the function.  
4)  The statement type assignment (lines 34-38). PFSA will 
not be updated. The assignment statement is not the key infor-
mation for FSAFlow, but, in this case, the alias problem is con-
sidered. FSAFlow performs on-demand alias analysis. When-
ever a variable is tainted, FSAFlow searches backwards for its 
aliases and then taints them as well. The result variable output 
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 13:12:26 UTC from IEEE Xplore.  Restrictions apply. 
2117
by the function of backward alias analysis, the current statement, 
and PFSA combined form a new node in N^. This node will be 
exploited to continue the forward data flow analysis.  
5)  The  statement  type  branch  (lines  39-47).  The  infor-
mation mp of the first statement ms of a subsequent branch path 
is appended to PFSA as a node. The node mp consists of a tuple 
, where sn represents mp’s position 
in PFSA, size represents the branching number of the branch, no 
is for the branch serial number of the target path, and type is for 
the  node  type,  indicating  to  which  branch  type  the  selected 
branch belongs. The node type can be in (entering loop body), 
out (the type of exiting loop body), and x (others). If ms appears 
more than once on the path within the current function, sn' is 
used to record the first corresponding position of ms in PFSA. m 
is for the statement itself. Finally, when PFSA is output, m is re-
moved from this node in PFSA. Refer to Section III-D and C for 
the use of branch information. 
Taking the code snippet in section II as an example, algo-
rithm 1’s path analysis process is given. The polluted process 
at the sink can be abstracted as the process steps ①-⑧ in Figure 
4(a). Meanwhile, the main structure of the path obtained by the 
static analysis is shown in Figure 4(b). FSAFlow operates on 
the Jimple code, therefore, to facilitate subsequent instrumen-
tation, the output path is also represented by Jimple statements. 
In step ①, the tainted variable password starts to propagate 
forward. At ②, the class RequestTask is tainted. Step ③ con-
tinues tracking when the tainted variable is called by postData. 
At ④, the tainted variable is called by ConvertStream ToString. 
Step ⑤ represents the return of the function call. The tainted 
variable continues to propagate forward through ⑥ and passes 
through two branches due to the if statements. At ⑥, loginfo is 
tainted. This triggers the backward alias analysis through steps 
⑦ and ⑧, the alias loginfo_tmpt2 for loginfo is found and then 
propagates forward as a normal taint. Finally, at ⑨, the tainted 
variable loginfo_tmpt2 leaks at the sink.  
FSAFlow adjusts the output format of PFSA and aggregates 
the  nodes  according  to  classes  and  methods.  After  the  static 
analysis is completed, the key information of paths is output 
and written into path files.  
C.  Static instrumentation 
The  static  instrumentation  stage  aims  to  embed  the 
lightweight  code  for  path  monitoring  into  the  apps,  which 
transforms untrusted apps into policy-enforcing apps. Accord-
ing to the results of static analysis and user-defined flow policies, 
the  disallowed  paths  are  extracted  and  instrumented  for  the 
source nodes, branch nodes, and sink nodes. 
Before instrumentation, FSAFlow preprocesses the path file. 
Because there is a loop structure, a statement may repeatedly 
appear on the path, thus let SN be the set of all the positions (sn) 
on the path where a statement m appears. FSAFlow appends SN 
to the node where m first appears on the path for m’s location 
to  be  instrumented  only  once.  After  appending,  other  nodes 
about m remain on the path to ensure the consistency of the con-
trol flow when the following nodes are instrumented. Moreover, 
each loop structure involved in the path is assigned a unique ID 
that is used for status monitoring in nested loops. Refer to Sec-
tion III-D for the use of loop ID. 
Furthermore, all paths are managed hierarchically and uni-
formly by a multilevel hash table HashMappolicy according to 
Algorithm 2  Code Instrumentation 
1: Input:    HashMappolicy  //the paths  stored with hash table 
2: Input:    classfiles  //the class files of the target program 
3: Output:  instrumented classfiles 
4: for each class c in HashMappolicy do  
5:    for each Method m in c do 
6:       for each pathid in hash(c,m) do 
7:          for each path fragement f in hash(c,m,id) do 
8:             for each node n in f do 
9:                if n is source type then 
10:                   stmtn = seek n in m 
11:                   insert source-control-code before stmtm to  control the source 
12:                else if n is branch type and n.sn’=-1 then 
13:                   Continue; 
14:                   for each following path  p at the next branch 
15: 
16:                     insert branch-control-code before stmtm to control the branch 
17:                else if  n is sink type  then 
18:                   stmtn = seek n in m 
19:                   insert sink-control-code before  stmtm  to control  the sink 
20:       output  instrumented class c 
21: end 
1
2
stmtm = the first statement of p 
3
4
7
8
public class DoLogin ... {
   protected void onCreate(...) {……
      detail_embeded_code.source_logic(114, 0,"Source information");          
      Intent data = getIntent();//source
      password = data...;
      …… }
   class RequestTask ... {        
      protected String doInBackground(...) { 
         ……}
      public void postData(...){
         ……
         detail_embeded_code.branch_logic(114, 5, "accept");
         if (...) {
           detail_embeded_code.branch_logic(114, 6,"accept");
           if(...){
11
12
18
19
20
21
22
25
                ……
Fig. 5.  Code instrumentation  
Loginfo[0]=username + password;
}else{
   Loginfo[0]="...";  }
……
detail_embeded_code.sink_logic(114, 7,"Sink information");  
Log.d(Loginfo_tmpt2[0]);//sink
class,  method,  and  path  identification.  Hereby,  the  involved 
classes and methods are each traversed only once. HashMappol-
icy has a data structure of >>, and is directly accessed through the multi-level 
key-value. Each key value of the method index can store the 
fragment  information  of  multiple  paths  while  pathfragment 
only stores branch nodes. The nodes associated with function 
calls on the path can be removed and will not occur in HashMap-
policy. Subsequent instrumentation is based on HashMappolicy.  
FSAFlow  extends  SOOT’s  BodyTransformer  and  the 
method internalTransform is implemented to traverse the units 
(statements) of all method bodies and insert the monitoring code 
in the specified location. Algorithm 2 describes the process of 
code instrumentation in detail. 
The classes that appear in HashMappolicy are loaded item by 
item from the actual class files. Then, the methods in the class 
file are individually parsed. For each method, the corresponding 
path identification and path segment are extracted from the hash 
table, and there are three contexts for node processing:  
1)  If it matches  the source type, the corresponding state-
ment is located and the control code is inserted before it, which 
can activate the monitoring of the specified path at runtime. 
2)  If it matches the branch type, the next branch from the 
current location is located. For different following paths, the re-
sponding control codes are inserted before the first statement of 
the subsequent target path as shown in Table I in Section III-D. 
If a node is the non-first repeated node (sn’=-1), it means that 
this node has been processed and can be ignored. 
3)   If it matches the sink type, the corresponding statement 
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 13:12:26 UTC from IEEE Xplore.  Restrictions apply. 
2118
is located and the control code is inserted before this statement, 
which allows information flow control and auditing.  
In  a  path,  a  method  may  be  called  more  than  once.  The 
newinvoke type is used for updating the current instrument loca-
tion to the method’s initial node. Due to limited space, the details 
of the relevant newinvoke nodes in the description of Algorithms 
1 and 2 are omitted. 
After completing the code instrumentation for related class 
files by traversing HashMappolicy, a set of new class files is ob-
tained. Then, all the new class files are repacked into .dex files 
to replace the .dex files in the original APK file. Using the com-
pression package, a new APK file is generated.  
The  code  instrumentation  example  of  InsecureBankv2  is 
shown in Figure 5. Only the statements before and after the in-
strumentation node are retained in this figure, and part of the 
instrumentation  for  the  branch  node  is  omitted.  The  inserted 
code is actually a function call code. Considering the hierarchy 
and interface of the project, the functions needed for actual op-
eration are encapsulated into separate classes. When these func-
tions are called in the running process, the related functions can 
be realized. 
D.  Runtime control 
The  runtime  control  stage  aims  to  efficiently  monitor  the 
change  of  path  states  and  dynamically  prevent  information 
leakage when the leakage path occurs. This section describes 
the specific control principle based on a finite state machine. 
The code snippet shown in Figure 1 is taken as an example to 
illustrate the runtime control mechanism. 
If the IFDS algorithm is used to analyze this example, after 
it traverses the loop body from s2 to s5 three times, the nodes 
, , , ,  in N* of the pro-
gram will be found. When IFDS tries to traverse s3 for the fourth 
time, it will find that there is no new node available for the path 
expansion. Then, IFDS stops traversing the loop body and con-
tinues to traverse s6. Finally, it will output a path s0-s1-s21-s31-
s41-s51-s22-s32-s42-s52-s23-s33-s43-s53-s6 (sin represents the n-th 
execution of si), while the actual execution path is s0-s1-s21-s31-
s41-s51-s22-s32-s42-s52-s23-s33-s43-s53-s24-s34-s44-s54-s6, which 
leads to information leakage and causes false negatives in IFDS. 
However, all STA techniques may face this problem.  
To deal with this problem effectively, the process of taint 
propagation is divided into three periods along the path: 1) For-
ward propagation period (N): The executed statement is outside 
the loop, corresponding to the execution period of s1 and s6. 2) 
Loop propagation period (P): The execution statement is in the 
loop body. According to IFDS, there are still new node exten-
sions in the current loop round that corresponds to the execution 
period  of  “s21-s31-s41-s51-s22-s32-s42-s52-s23-s33-s43-s53”.  3) 
Loop stable period (S): The executed statement is in the loop 
body structure. According to IFDS, the current loop round has 
no new node extension. The execution is then no longer tracked 
by IFDS, which corresponds to the execution period of " s24-s34-