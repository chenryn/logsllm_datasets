ğ‘ and return the pre-
To show that Scheme 1 supports split signing let:
ğ‘ and sends it together with (Sig1
ğ‘, set (stsecr, stpub) = (ğ‘˜, (ğ‘”ğ‘˜
, i.e., it can send ğ‘”ğ‘¢
, ğ‘¤),
1 , ğ‘”ğ‘˜
, ğ‘ˆ ğ‘¤
SFPK
SFPK
.
SFPK
SFPK
It is easy to see that the only difference between SFPK.Sign and
the combination (SFPK.Sign1, SFPK.Sign2, SFPK.Sign3) is the way
Sig2
are computed. However, since ğ‘Ÿ is chosen at
random in SFPK.Sign2 and ğ‘ˆ ğ‘¤
2 are distributed
identical to the output of SFPK.Sign. The main difficulty is to show
that unforgeability holds in the sense as defined in Definition 3.1.
1 and ğ‘ˆ ğ‘¤
and Sig3
1 = ğ‘”ğ‘Ÿ
2 = ğ‘”ğ‘Ÿ
SFPK
SFPK
Theorem 3.2 (Unforgeability). Scheme 1 is an unforgeable
SFPK scheme with split signing in the random oracle model assuming
the bilinear decisional Diffie-Hellman assumption.
Proof. The proofs follows a similar strategy to the proof in [2],
but with small changes due to split signing. For completeness we
present the full proof of Theorem 3.2 in Appendix B.1.
â–¡
The following readily follows from [2].
Theorem 3.3 (Class-hiding). Scheme 1 is class-hiding with key
corruption in the random oracle model assuming the decisional Diffie-
Hellman assumption.
Lemma 3.4 (Canonical Representative). A predicate defined
as canon((ğ´, ğµ)) := ğ´ â‰¡ ğ‘”1 can be used to identify canonical rep-
resentatives in Scheme 1. Note that by defining canon this way the
SFPK.KeyGen algorithm outputs keys in canonical representation.
Third party re-randomization. A useful property that was not
defined in previous work on SFPK is re-randomization of the full
signature/public key pair. In the original work, the authors consider
changing representation of the public key before the actual signa-
ture. We show that there exists an algorithm (pkâ€²
, Sigâ€²
SFPK) â†
SFPK.ReRand(pkSFPK, ğ‘š, SigSFPK, ğ‘Ÿ) for which we have pkâ€²
SFPK â†
SFPK.ChgPK(pkSFPK, ğ‘Ÿ) and SFPK.Verify(pkâ€²
, ğ‘š, Sigâ€²
SFPK) = 1
where for the original signature SFPK.Verify(pkSFPK, ğ‘š, SigSFPK) =
1. We can define this algorithm as part of Scheme 1 as follows:
SFPK.ReRand(pkSFPK, ğ‘š, SigSFPK, ğ‘Ÿ): parse SigSFPK = (Sig1
ğ‘, compute pkâ€²
SFPK = ((Sig1
SFPK), choose random ğ‘˜ â†$ Zâˆ—
Sig2
â† SFPK.ChgPK(pkSFPK, ğ‘Ÿ) and set Sigâ€²
H(ğ‘š)ğ‘˜, (Sig2
SFPK)ğ‘Ÿ Â· ğ‘”ğ‘˜
2).
SFPK)ğ‘Ÿ Â· ğ‘”ğ‘˜
SFPK)ğ‘Ÿ Â·
1 , (Sig3
, Sig3
SFPK
SFPK
SFPK
SFPK
SFPK
,
3.2 Tag-Based Equivalence Class Signatures
Now, we introduce a variant of SPS-EQ or more precisely equiva-
lence class signatures (as they are not strictly structure-preserving
anymore) that in addition to the message ğ‘€ being a representa-
tive of class [ğ‘€] support an auxiliary tag ğœ âˆˆ {0, 1}âˆ—. Therefore,
we adapt the security model from SPS-EQ as follows. The task of
the adversary is to forge a signature for a message (ğ‘€âˆ—, ğœâˆ—) where
the adversary did not query a signature for the class [ğ‘€âˆ—] and ğœâˆ—
combination (cf. Appendix A.4). Moreover, for the adaption notion
which guarantees that signatures from ChgRep and Sign are identi-
cally distributed, we only require it to hold with respect to identical
auxiliary tags ğœ. Our construction is a modification of the SPS-EQ
scheme from [44] (denoted FHS15 henceforth) which is proven
to be EUF-CMA secure in the generic group model and provides
perfect adaption even under malicious keys. We do not provide an
abstract definition as the only changes to the SPS-EQ interface are
the additional input ğœ to the Sign and Verify algorithms. Our con-
struction of a tag-based equivalence class signature scheme (TBEQ)
is provided in Scheme 2 and it basically extends the FHS15 scheme
by a fourth signature element ğ‘‰2 = ğ»(ğœ) 1
ğ‘¦ where ğ» : {0, 1}âˆ— â†’ G2
is modeled as a random oracle and ğ‘¦ is the signing randomness.
Note that ğ‘‰2 can be considered as a BLS signature [16] with the
signing randomness 1/ğ‘¦ acting as a one-time signing key.
We will now show the unforgeability and perfect adaption of the
TBEQ in Scheme 2.
Session 6D: Authentication and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2010TBEQ.Setup(1ğœ†): generate BG â†$ BGGen(ğœ†), ğ» : {0, 1}âˆ— â†’ G2 and
TBEQ.KeyGen(params, â„“): choose (cid:174)ğ‘¥ â†$
ğ‘)â„“ and set sk = (cid:174)ğ‘¥ and pk =
(Zâˆ—
TBEQ.Sign(sk, ğ‘€, ğœ): parse sk = (cid:174)ğ‘¥, ğ‘€ âˆˆ (Gâˆ—
1)â„“ , ğœ âˆˆ {0, 1}âˆ— and choose
return params = (BG, ğ»).
2 = (ğ‘”ğ‘¥1
2 , . . . , ğ‘”ğ‘¥â„“2 ).
ğ‘”(cid:174)ğ‘¥
ğ‘¦ â†$ Zğ‘. Compute
(cid:33) ğ‘¦
(cid:32) â„“
ğ‘–=1
Return ğœ = (ğ‘1, ğ‘Œ1, ğ‘Œ2, ğ‘‰2).
ğ‘1 =
ğ‘€ğ‘¥ğ‘–
ğ‘–
, ğ‘Œ1 = ğ‘”
1
ğ‘¦
1
, ğ‘Œ2 = ğ‘”
1
ğ‘¦
2 ğ‘ğ‘›ğ‘‘ ğ‘‰2 = ğ» (ğœ) 1
ğ‘¦ .
TBEQ.ChgRep(ğ‘€, ğœ, ğœ‡, pk): Choose ğœ“ â†$ Zâˆ—
ğ‘ and return (ğ‘€ ğœ‡, ğœâ€²) with
ğœâ€² = (ğ‘ğœ“ ğœ‡
1
, ğ‘Œ
1
ğœ“
1 , ğ‘Œ
1
1
ğœ“
ğœ“
2 , ğ‘‰
2
).
TBEQ.Verify(pk, ğ‘€, ğœ, ğœ): parse pk = (pk1 = ğ‘”ğ‘¥1
2 , . . . , pkâ„“ = ğ‘”ğ‘¥â„“2 ), ğ‘€ âˆˆ
1)â„“ , ğœ âˆˆ {0, 1}âˆ— and ğœ = (ğ‘1, ğ‘Œ1, ğ‘Œ2, ğ‘‰2). Return 1 if the following
(Gâˆ—
checks hold and 0 otherwise:
â„“
ğ‘–=1
ğ‘’(ğ‘€ğ‘–, pkğ‘–) = ğ‘’(ğ‘1, ğ‘Œ2) âˆ§
ğ‘’(ğ‘Œ1, ğ‘”2) = ğ‘’(ğ‘”1, ğ‘Œ2) âˆ§ ğ‘’(ğ‘”1, ğ‘‰2) = ğ‘’(ğ‘Œ1, ğ» (ğœ))
Scheme 2: Our TBEQ Signature Scheme
Theorem 3.5. The TBEQ in Scheme 2 is EUF-CMA secure and
provides perfect adaption (under malicious keys) assuming that ğ» is
a random oracle.
We argue unforgeability in the generic bilinear group model
(following the proof of the FHS15 SPS-EQ in [45]) for a version of
our TBEQ without random oracles and a polynomially bounded tag-
space. Then, we will argue our modification in the random oracle
model with an unbounded tag space and constant size public keys.
The idea for a polynomially bounded tag space T = {ğœ1, . . . , ğœğ‘˜} for
a ğ‘˜ âˆˆ poly(ğœ†) is to include additional uniformly random elements
(â„ğ‘– âˆˆ G2)ğ‘–âˆˆ[ğ‘˜] into pk and use the corresponding value â„ğ‘– when
signing for tag ğœğ‘– instead of the hash evaluation ğ»(ğœğ‘–).
Lemma 3.6. The TBEQ in Scheme 2 with the above modifications
is EUF-CMA secure in the Type-3 generic bilinear group model.
We provide this proof in Appendix B.2.
Lemma 3.7. The TBEQ in Scheme 2 is EUF-CMA secure for an
unbounded tag-space when modeling ğ» as a random oracle.
Proof. Up to collisions in the random oracle, which happen with
negligible probability, the TBEQ in Scheme 2 and in particular the
security analysis is identical to the proof of Lemma 3.6, but without
the restriction of the tag space being polynomial in size.
â–¡
Lemma 3.8. The TBEQ in Scheme 2 provides perfect adaption
(under malicious keys).
We provide this proof in Appendix B.3.
What we require for our further constructions is a derandom-
ized version of the TBEQ scheme. Subsequently, we formulate as
Lemma 3.9 (cf. [17]) a frequently used technique (see e.g., [9, 52]) to
derandomize any signature scheme, which in particular also holds
for TBEQ. Thus, we omit the proof.
and return ((sk, ğ‘˜), pk).
Lemma 3.9. Let Î£ = (Setup, KeyGen, Sign, ChgRep, Verify) be an
EUF-CMA secure TBEQ scheme and ğ¹ : K Ã—MTBEQ â†’ RTBEQ be a
secure PRF, then Î£â€² = (Î£.Setup, KeyGenâ€², Signâ€², Î£.ChgRep, Î£.Verify)
is also EUF-CMA secure, where:
KeyGenâ€²(BG, â„“): Run (sk, pk) â† Î£.KeyGen(BG, â„“), choose ğ‘˜ â†$ K
Signâ€²(sk, ğ‘€, ğœ): Compute ğ‘Ÿ := ğ¹(ğ‘˜, ğ‘€) and return Î£.Sign(sk, ğ‘€, ğœ; ğ‘Ÿ).
We denote the derandomized TBEQ by TBEQd. Note that in
Scheme 2 this means that in Sign we have ğ‘¦ â† ğ¹(ğ‘˜, ğ‘€).
3.3 Aggregatable Attribute-Based EQs
We now introduce another variant of equivalence class signatures
called aggregatable attribute-based equivalence class (AAEQ) sig-
natures, that will represent one core building block for our CHAC
system. In such a scheme there is a main key pair, which is akin
to identity-based signatures [71]. The main secret key can issue
signing keys for attributes (Attr), e.g., Attr =â€œageâ€. When signing a
message ğ‘€ (a representative of a class [ğ‘€]) with respect to such an
attribute signing key, signing additionally takes an attribute value
ğ‘£Attr, e.g., ğ‘£Attr =â€œ21â€. The scheme is required to be aggregatable in
a sense that signatures under different attribute signing keys for the
same representative ğ‘€ of a class can be aggregated into a compact
signature. Like in SPS-EQ, the signatures are with respect to classes
and there is a ChgRep algorithm to publicly change representatives
(i.e., adapt). For the sake of simplicity, below we assume that the
set of attributes represents the integers [ğ‘¡] with domain {0, 1}âˆ— for
each attribute.
Definition 3.10 (Aggregatable Attribute-Based EQs). An aggregat-
able attribute-based equivalence class (AAEQ) signature scheme
consists of the following PPT algorithms:
Setup(1ğœ†, ğ‘¡, â„“): on input security parameter 1ğœ†, the number of at-
tributes ğ‘¡ (distinct attribute names) and length parameter â„“ this
algorithm outputs main key pair (msk, mpk).
AKGen(msk, Attr): on input a main secret key msk and an attribute
Attr, outputs an attribute secret key skAttr.
Sign(skAttr, ğ‘£Attr, ğ‘€): on input an attribute secret key skAttr, an
attribute value ğ‘£Attr and a representative ğ‘€, this algorithm
outputs a signature ğœ.
ChgRep(ğ‘€, ğœ, ğœ‡, mpk): on input a representative ğ‘€, a signature ğœ,
a scalar ğœ‡ and a main public key mpk, this algorithm outputs
an updated signature ğœâ€² for representative ğ‘€ ğœ‡.
Agg(mpk, {ğœğ‘–}): on input a main public key mpk and a set of valid
signatures {ğœğ‘–}, outputs an aggregated signature ğœâ€².
Verify(mpk, {Attrğ‘–}, ğœâ€², ğ‘€): on input a public key mpk, a set of
attributes {(Attrğ‘–, ğ‘£Attrğ‘–)}, an aggregated signature ğœâ€² and a
representative ğ‘€, outputs either accept(1) or reject(0).
We require an AAEQ to be correct, unforgeable and to provide
perfect adaption. We present the formal definitions in Appendix A.5.
Intuition of our construction. We now present a construction
with ğ‘‚(ğœ†) sized mpk and msk as Scheme 3 which is based upon the
TBEQ in Scheme 2 using the de-randomization (TBEQd). The idea
is simple and uses parallel instances of the derandomized TBEQd
scheme, where every pk represents a different attribute Attr (for
simplicity just integers in the set [ğ‘¡], but this can easily be changed
Session 6D: Authentication and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2011to arbitrary strings, e.g., Attr =â€œageâ€). Now the basic idea is to use
the attribute value ğ‘£Attr as the tag in the TBEQ scheme.
The intuition is that signatures for multiple different attributes
and the same representative ğ‘€ of class [ğ‘€] share the same random-
ness ğ‘¦ = ğ¹(ğ‘˜, ğ‘€) and thus from the set of ğ‘¤ signatures {(ğ‘1,ğ‘–, ğ‘Œ1,ğ‘–,
ğ‘Œ2,ğ‘–, ğ‘‰2,ğ‘–)}ğ‘–âˆˆ[ğ‘¤] aggregation can easily be done by aggregating the
ğ‘1,ğ‘– components of all single signatures as well as the ğ‘‰2,ğ‘– compo-
nents and use the ğ‘Œ1, ğ‘Œ2 values of one of the signatures (note that all
with respect to the same mpk and same representative ğ‘€ use the
same randomness ğ‘¦ and are thus identical). Aggregate verification
is the verification of the TBEQ scheme using the componentwise
aggregation of the attribute public keys (see Scheme 3 for details).
Finally, the change representative algorithm is identical to the al-
gorithm of the underlying TBEQ. Note that for the simplicity of
presentation we assume that ChgRep and Agg only take valid sig-
natures as input (this can easily be handled by adding verification
of all input signatures to the respective algorithms).
ğ‘€ âˆˆ (Gâˆ—
compute
(cid:32) â„“
(cid:33) ğ‘¦
(pkAttrğ‘–
AAEQ.Setup(1ğœ†, ğ‘¡, â„“): generate BG â†$ BGGen(ğœ†), choose ğ» : {0, 1}âˆ— â†’
G2 and set params = (BG, ğ») . Choose PRF key ğ‘˜ â†$ K and for ğ‘– âˆˆ [ğ‘¡]
ğ‘)â„“ , set pkAttrğ‘– = (ğ‘”(cid:174)ğ‘¥ğ‘–2 ) and set skAttrğ‘– =
â€¢ choose (cid:174)ğ‘¥ğ‘– â†$
(Zâˆ—
, (cid:174)ğ‘¥ğ‘–, k).