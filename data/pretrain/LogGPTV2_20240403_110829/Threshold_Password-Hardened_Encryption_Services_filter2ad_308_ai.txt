𝑇 :=𝑗∈𝑃∪{0}𝑇
𝜆𝑃,𝑗
𝑗
(cid:19)
(cid:19)
(cid:19)
(cid:19)
𝐾𝑖
𝑇𝑖
𝐾𝑖
𝑇′
𝑖
(cid:18)
, 𝑘𝑖
, 𝑘𝑖
(cid:18)𝐺
˜𝑈
¯𝐾 𝑗ℓ
ℓ
, ∀𝑗 ∈ 𝑃 \ {𝑖}
(cid:19)
𝐾𝑗
𝑇𝑗
(cid:19)(cid:19)
, 𝜋3,𝑗
if ( ˜𝑉 ≠ 𝑇) then return 𝜖
𝑀 := (𝐶1/( ˜𝑉′ · 𝑇′−1))
return 𝑀
if (𝑏𝑖 = 1) ∧ ( ˜𝑉 · 𝑇−1 = 𝐼) then return 𝜖
return 𝑛
Figure 8: Joint Decryption with Fine-Grained Rate-Limiting
has an additional benefit that the rate-limiters stay oblivious to
whether the password was correct. For practical purposes this can
also be interpreted as follows: For a login process, server and rate-
limiters first execute the 6-round protocol, and the server considers
the user as successfully authenticated. The last message (the 7-th
round) can then be sent in the background to the rate-limiters, who
will then “refund” the login attempt.
Both variants are covered by our security definitions and proofs:
While the fine-grained variant is covered natively,the coarse-grained
variant is also covered as it only penalizes the adversary for addi-
tional (successful) decryption attempts.
B.2 Further Optimizations
We note that the proofs 𝜋1,𝑖, 𝜋2,𝑖, 𝜋′
2,𝑖 can be merged into a single
proof in a non-blackbox way. Conceptually, until the joint decryp-
tion phase, the parties only compute on random group elements
and thus verifying the integrity of the messages can be delayed
until right before the joint decryption phase. Merging the proofs
14
saves some communication cost by not sending duplicating commit-
ments corresponding to the same witness. However doing so would
further complicate the presentation of our protocol and hide its
structure. Therefore we choose to not incorporate this optimization.
B.3 More General Access Structures and
Dynamic Rate-Limiters
We discuss extensions of our (𝑡, 𝑚)-PHE scheme obtained by ex-
tending the underlying secret sharing scheme.
The scheme we presented only supports a basic threshold access
structure. In real-world deployments, more complex access struc-
tures might be desirable (e.g., to have a single backup rate-limiter
who is normally offline, or to require rate-limiters from different
geographic areas in addition to a threshold of them).
To this end, observe that the Shamir secret sharing scheme we are
using can be replaced by any linear secret sharing scheme without
further changing the protocol. The resulting construction supports
any access policies specified by monotone span programs [11].
In a real-world application of (𝑡, 𝑚)-PHE, it might happen that
the keys of some rate-limiters are lost due to an incident or malicious
intervention. If too many rate-limiter keys are lost, the server risks
losing all the user data as they can no longer be decrypted. To
prevent such situations, it is useful to consider natural extensions
of (𝑡, 𝑚)-PHE which allows recovery of lost rate-limiter keys and
changing the set of rate-limiters (to a new set of possibly different
size) dynamically.
While standard methods [3] exist for dynamic resharing, due to
our more relaxed security requirements, the round complexity of
dynamic resharing can be improved: Let 𝑠𝑖 be the 𝑖-th share of the
conceptual rate-limiter secret key ¯𝑠0 generated by a (𝑡, 𝑚)-secret
sharing scheme. To convert to a new (𝑡′, 𝑚′) system, a 𝑡-subset
𝐼 ⊂ [𝑚] of the previous share-holders create 𝑚′ shares {𝑠𝑖,𝑗} 𝑗 ∈[𝑚′]
of their shares 𝑠𝑖 as follows. Each 𝑖 ∈ 𝐼 sets ¯𝑠𝑖,0 := 𝑠𝑖 and samples
𝑘=0 ¯𝑠𝑖,𝑘 𝑗𝑘 for each
𝑗 ∈ [𝑚′], and ¯𝑆𝑖,𝑘 for 𝑘 ∈ [𝑡′ − 1]. The share 𝑠𝑖,𝑗 is sent to the
new 𝑗-th rate-limiter, while { ¯𝑆𝑖,𝑘 = 𝐺 ¯𝑠𝑖,𝑘 }𝑡′−1
𝑘=0 is broadcasted. Upon
𝑖∈𝐼 , each new shareholder 𝑗 ∈ [𝑚′] can
recover their share 𝑠′
¯𝑠𝑖,𝑘 for 𝑘 ∈ [𝑡′ − 1]. It then computes 𝑠𝑖,𝑗 :=𝑡′−1
receiving the shares(cid:8)𝑠𝑖,𝑗(cid:9)
using a linear function L𝐼 determined by the set 𝐼. To see that
{𝑠′
𝑗} 𝑗 ∈[𝑚′] are valid shares of the conceptual secret key ¯𝑠0, note
that for any 𝑡′-subset 𝐽 ⊆ [𝑚′], we have
(cid:16){𝑠′
L𝐽
𝑗} 𝑗 ∈𝐽
𝑗 as
𝑠′
𝑗 = L𝐼(cid:0)𝑠𝑖1,𝑗 , . . . , 𝑠𝑖𝑡 ,𝑗(cid:1)
(cid:16)(cid:8)𝑠𝑖,𝑗(cid:9)
(cid:17)
(cid:16)(cid:8)𝑠𝑖,𝑗(cid:9)
=L𝐽
=L𝐼
𝑗 ∈𝐽
=L𝐼 ({𝑠𝑖 }𝑖∈𝐼) = ¯𝑠0.
(cid:18)(cid:110)L𝐼
(cid:16)(cid:110)L𝐽
𝑖∈𝐼
(cid:19)
(cid:17)
(cid:17)(cid:111)
(cid:17)(cid:111)
𝑗 ∈𝐽
𝑖∈𝐼
𝑘
for 𝑘 ∈ [0, 𝑡′−1]
All parties can also compute the new public key ¯𝑆′
as a power product of { ¯𝑆𝑖,𝑘}𝑖∈𝐼 with coefficients given by L𝐼 . The
well-formedness of 𝑠′
𝑗 can then be publicly verified using the new
public keys ¯𝑆′
0, . . . , ¯𝑆′
𝑡′−1.
B.4 Cold Storage
One of the applications of (𝑡, 𝑚)-PHE concerns cold storage: The
server operator spawns a number of additional rate-limiters which
suffices to perform decryption, and stores their keys offline. In case
of irresponsive rate-limiters, the server operator can always recover
its data. If these keys are well-protected (e.g., physically) this does
not reduce the security of the deployed system.
The non-interactive nature of our key-rotation protocol helps
with this use-case. As long as key-rotations happen infrequently,
it is possible to store (a sequence of) key-rotation materials for
each rate-limiters in cold-storage along with the rate-limiter keys.
Once needed these materials can the be recombined to restore an
up-to-date set of rate-limiter keys.
B.5 On Round Complexity
The round complexity of (𝑡, 𝑚)-PHE is critical as network latency
is the main efficiency bottleneck. A theoretical way to reduce the
round complexity is to use a round-optimal MPC to emulate a
PHE scheme. In our communication model where the rate-limiters
are not allowed to communicate, this approach leads to a 3-round
15
(resp. 4-round) decryption protocol with fine-grained (resp. coarse-
grained) rate-limiting. For practical purposes,however,using general-
purpose round-optimal MPC protocols are highly inefficient for
group operations which are extensively used in PHE. From a more
foundational perspective, such an approach would require evaluat-
ing hash functions which are modeled as random oracles over an
MPC. This makes the scheme regrettably unprovable from standard
assumptions, even in the random oracle model.
While we strongly believe that reducing the round-complexity
(and thereby the latency) of (𝑡, 𝑚)-PHE is of considerable practical
interest, we believe that the improved efficiency and security guar-
antees make the special-purpose protocol presented in this paper
the more desirable variant.
B.6 Non-Interactive Rotation
The key-rotation protocol in our construction is a non-interactive
protocol initiated by the server. This is useful in practice as it means
that not all rate-limiters need to be reachable to execute the key-
rotation protocol. Instead, the server can initiate key-rotation ahead
of time, and cache the messages supposed to be sent the rate-limiters
until they become available. It is even possible to queue several
key-rotations while a rate-limiter is unavailable (e.g., due to main-
tenance) and later apply all the changes in one shot.
We emphasize that leaking the key-rotation materials will defeat
the self-healing properties of key-rotation. An adversary who learns
this information can construct the new (resp. old) keys associated
with this key-rotation material if it also has knowledge of the old
(resp. new) keys. Therefore caching the key-rotation materials has
to be based on a balanced decision in practical deployments.
C ON FULL-ADAPTIVE HIDING
In this section we outline the impossibility of proving the construc-
tion in Section 3 fully-adaptively hiding via a reduction from any
reasonable computational assumptions, with a mild assumption on
the reduction. We also give evidence suggesting that an efficient
and fully-adaptive solution seems unlikely to exist.
C.1 Impossibility Result
We show that if there exists a PPT reduction R from the problem of
deciding any NP language L to the full-adaptive hiding property
of the construction in Section 3, then L is PPT decidable, with a
mild assumption that the reduction simulates the environment of
the hiding experiment to any PPT adversary A with non-negligible
probability.8 The latter essentially says that the reduction should
not rely on the unpredictable behavior of the adversary when the
simulation is not faithful, which holds virtually for all known re-
ductions in cryptography. The impossibility holds even if we do
not allow the adversary to make key-rotation queries.
The impossibility can be shown by constructing a PPT meta-
reduction M which decides the language L when given non-black-
box access to the PPT reduction R,if it were to exist. The main idea is
to exploit the property of the secret keys sk𝑖 = (𝑠𝑖, 𝑘𝑖, 𝐾0, { ¯𝑆 𝑗 , ¯𝐾𝑗}𝑡−1
𝑗=0)
8More precisely, we require that for any statement 𝑥 and any PPT algorithm A, the
probability of A failing to distinguish whether it is interacting with R(𝑥) or Hid𝑏
for some 𝑏 ∈ {0, 1} is non-negligible.
fully with non-negligible probability, we have 𝐺𝑠𝑖 =𝑡−1
that { ¯𝑆 𝑗}𝑡−1
𝑗=0 is fixed for all keys and acts as a perfectly binding com-
mitment to the “logical” secret keys {¯𝑠 𝑗}𝑡−1
𝑗=0. In the following, we
assume that PW is a password space with 0 < |PW| = poly(𝜆).
This assumption can be made without loss of generality since, if the
construction in Section 3 is adaptively hiding, there should exist a
reduction R for this particular password space PW.
To decide if 𝑥 ∈ L, M runs R on 𝑥 while playing the role of the
adversary A, who interacts with R(𝑥). M first instructs A to cor-
rupt the server,and receives a secret key sk0 = (𝑠0, 𝑘0, 𝐾0, { ¯𝑆 𝑗 , ¯𝐾𝑗}𝑡−1
𝑗=0).
M then forks R into two parallel instances. In the 𝛽-th instance,
M samples a random (𝑡 − 1)-subset 𝐼𝛽 of [𝑚], instructs A to cor-
rupt the subset 𝐼𝛽 of rate limiters, and receives sk𝑖 for 𝑖 ∈ 𝐼𝛽. With
non-negligible probability, we have 𝐼0 ≠ 𝐼1, and hence |𝐼0 ∪ 𝐼1| ≥ 𝑡.
With the assumption that R simulates the hiding experiment faith-
for
all 𝑖 ∈ 𝐼𝛽 and for all 𝛽 ∈ {0, 1} with non-negligible probability,
for otherwise we can construct a distinguisher which only fails to
distinguish R(𝑥) from Hid𝑏 with negligible probability.
Using Gaussian elimination, we can extract ¯𝑠0 such that ¯𝑆0 = 𝐺 ¯𝑠0.
Next, M instructs A to query the challenge oracle (say in the
first instance) on (𝑀∗
0 and
𝑀∗
1, and receives 𝑛∗ and 𝐶∗. Suppose the simulation is faithful,
which we assume to happen with non-negligible probability, then
SKE.Dec(𝑠0, 𝐶∗) is of the form
(𝐶∗
1) = (𝐻0(pw∗, 𝑛∗) · 𝐻0(𝑛∗)¯𝑠0, 𝐻1(pw∗, 𝑛∗) · 𝐻1(𝑛∗)¯𝑠0 · 𝑀∗
0, 𝐶∗
𝑏)
for some password pw∗ ∈ PW and 𝑏 ∈ {0, 1}. Using the knowledge
of ¯𝑠0, M can obtain 𝐻0(pw∗, 𝑛∗) from 𝐶∗
0. Then, using brute-force,
M finds pw† ∈ PW such that 𝐻0(pw†, 𝑛∗) = 𝐻0(pw∗, 𝑛∗). Since
|PW| = poly(𝜆), this can be done in polynomial time. Since 𝐻0 is
modeled as a random oracle, it holds that pw† = pw∗ except with
1 , ∅, ∅) for some random messages 𝑀∗
0 , 𝑀∗
¯𝑆𝑖 𝑗
𝑗
𝑗=0
𝑏
negligible probability. M can then obtain 𝑀∗
, and hence 𝑏, from 𝐶∗
1
and pw∗. Since M correctly guesses 𝑏 with non-negligible proba-
bility, without querying the decryption oracle even once, R should
be able to decide whether 𝑥 ∈ L with non-negligible probability,
so does M. This however means that L is PPT decidable (by MR).
C.2 Implausibility of Efficient Construction
The meta-reduction exploits the perfectly binding property of the
commitments that are part of a secret key and prevents the reduction
from generating fresh secret keys once parties get corrupted. This
particular issue can be fixed by replacing the perfectly binding
commitments (e.g.,𝐺 ¯𝑠 𝑗 ) with perfectly hiding commitments: Instead
of 𝐺 ¯𝑠 𝑗 we have Com(¯𝑠 𝑗; ¯𝑟 𝑗) for some commitment scheme Com,
and instead of 𝑠𝑖 we have (𝑠𝑖, 𝑟𝑖) where 𝑟𝑖 is the randomness of the
commitment to 𝑠𝑖.
However there are other similar issues, e.g., in the encryption
protocol, (𝑌𝑖,0, 𝑌𝑖,1) is a perfectly binding commitment of 𝑠𝑖. This
does not seem to be easily fixable using the above trick: Abstractly
speaking, the above trick introduces one degree of freedom by
increasing the key length by 1 (there is only one commitment to 𝑠 𝑗
generated as part of the setup). To fix the problem in the encryption
protocol, however, we would need to increase the key length by
𝑄Enc, where 𝑄Enc is the total number of encryption queries as each
encryption query commits independently to the secret key which
makes this solution clearly impractical.
In general, this seems to be related to the problem of constructing
a kind of non-committing encryption, where a ciphertext is non-
committing to the secret key. Virtually the only way we know how
to build practical (non-interactive) non-committing encryption is to
break the algebraic structure of the ciphertext using a random oracle.
However, such a technique seems incompatible with (t-)PHE since
the algebraic structure is crucial for thresholding and key-rotation.
16