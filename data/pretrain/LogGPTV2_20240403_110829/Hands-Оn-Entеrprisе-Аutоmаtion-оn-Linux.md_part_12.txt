[ 112 ]
Using Ansible to Build Virtual Machine Templates for Deployment Chapter 5
Let's take a look at building a CentOS 7.6 virtual machine image using an Ubuntu 18.04
Server host:
1. The first step before we begin is to ensure that the build host is capable of
running virtual machines—this is normally a set of CPU extensions that are
included with most modern x86 systems. It is also possible to build virtual
machine images using nested virtualization, that is, to create a virtual machine
within another virtual machine. However, to do this, you will have to enable
virtualization support in your build VM. The process for this varies from one
hypervisor to another, and so we will not go into detail on this here.
If you are using a VMware hypervisor to perform nested virtualization,
you will need to enable code profiling support for the CPU as well as
enabling hypervisor applications—some of the steps in this process will
fail otherwise.
2. Once you have your build host up and running, you will need to install the
Linux Kernel-based Virtual Machine (KVM) toolset—the commands to do this
will vary depending upon your build host version of Linux, but on our Ubuntu
host, we need to run the following commands:
$ sudo apt-get install libvirt-bin libvirt-doc libvirt-clients
virtinst libguestfs-tools libosinfo-bin
$ sudo gpasswd -a  libvirt
$ sudo gpasswd -a  kvm
$ logout
Note the need to add your user account to two KVM-related groups—you will
also need to log out and back in again for these group changes to take effect.
3. Once this is complete, you will also need to download a local copy of the ISO
image for your chosen Linux image. I use the following command to download
an ISO image as it is sufficient for the CentOS 7.6 SOE image I am going to
create:
$ wget
http://vault.centos.org/7.6.1810/isos/x86_64/CentOS-7-x86_64-Minima
l-1810.iso
4. With all of these pieces in place, you will now create an empty virtual machine
disk image. The best format to choose for this is the Quick Copy On
Write (QCOW2) format, which is compatible with OpenStack and most public
cloud platforms. Hence, we will make this image as generic as possible to enable
the widest array of support possible.
[ 113 ]
Using Ansible to Build Virtual Machine Templates for Deployment Chapter 5
To create a blank 20 GB QCOW2 image in the current directory, we would run the
following command:
$ qemu-img create -f qcow2 centos76-soe.qcow2 20G
Note that other image formats are available. If, for example, you were building exclusively
for VMware, it would make sense to use the VMDK format instead:
$ qemu-img create -f vmdk centos76-soe.vmdk 20G
Note that both these commands create sparse images—that is, they are only as big as the
data and metadata they contain. They can be turned later into pre-allocated images by your
chosen hypervisor platform if you wish:
With the empty disk images created, it's time to install the VM image:
1. We will use the virt-install command to achieve this, which basically runs
up a temporary VM for OS installation. Don't worry about parameters such as
CPU and memory—as long as these are sufficient for the OS installation to be
run, they will be fine—they do not have any bearing on the deployed virtual
machine.
Note the use of VNC in the --graphics
vnc,listen=0.0.0.0 option—we will use this to remotely control the
virtual machine and complete the installation. You can choose another
graphics option, such as SPICE, if you prefer.
2. The following command is an example of how to use virt-install to create a
CentOS 7 image from the ISO we downloaded earlier, using the preceding 20 GB
QCOW2 disk image we created:
$ virt-install --virt-type kvm \
--name centos-76-soe \
--ram 1024 \
[ 114 ]
Using Ansible to Build Virtual Machine Templates for Deployment Chapter 5
--cdrom=CentOS-7-x86_64-Minimal-1810.iso \
--disk path=/home/james/centos76-soe.qcow2,size=20,format=qcow2 \
--network network=default \
--graphics vnc,listen=0.0.0.0 \
--noautoconsole \
--os-type=linux \
--os-variant=centos7.0 \
--wait=-1
Most of these parameters are self-explanatory, but pay particular attention to your
environment. For example, if you have edited or removed the default network,
the preceding command will fail. Similarly, ensure the correct paths for all files
referenced.
To see the list of supported --os-variant parameters, run the osinfo-
query os command.
Naturally, you would vary these parameters according to the operating system
you are installing, your disk image name, and so on.
3. For now, let's run this command—when successful, it should inform you that
you can connect to the virtual machine console to continue:
4. We will now connect to it from another shell using the virt-viewer utility:
$ virt-viewer centos-76-soe
[ 115 ]
Using Ansible to Build Virtual Machine Templates for Deployment Chapter 5
From here, you will install the operating system in the normal way. As we have discussed
in Chapter 4, Deployment Methodologies, try to go for the most minimal install that you can.
Don't worry too much about hostname and such, as these should get set later as part of the
deployment process; specify the following:
1. Choose KEYBOARD and LANGUAGE SUPPORT most relevant to your locale.
2. Choose the appropriate DATE & TIME settings for your country.
3. Ensure SOFTWARE SELECTION is Minimal Install (this is the default).
4. Set INSTALLATION DESTINATION—there will only be one virtual hard drive
attached to this VM using the preceding virt-install command, so this is
simply a matter of selecting it.
5. Enable or disable KDUMP as appropriate.
6. Ensure networking is enabled under NETWORK & HOST NAME.
The resulting CentOS 7 installation settings screen should look something like the following
screenshot:
[ 116 ]
Using Ansible to Build Virtual Machine Templates for Deployment Chapter 5
Allow the installation to complete as normal, and then log into the VM you have just
created. Once logged into the running VM, you should perform any and all customization
that you want to appear in the final version of the VM template. In the next section of this
chapter, we will go into the use of Ansible for configuring deployed virtual machines, and
using it to build templates is no different—hence, to prevent overlap with later chapters, we
will not go into details of Ansible configuration work here.
When your VM goes to reboot after the initial installation, you may find that it shuts down.
If it does, you will need to undefine it using the virsh utility, and then run it again using a
slight variant on our previous virt-install command, telling virt-install to boot
this time from the hard drive image rather than the CD:
$ virsh undefine centos-76-soe
$ virt-install --virt-type kvm \
--name centos-76-soe \
--ram 1024 \
--disk path=/home/james/centos76-soe.qcow2,size=20,format=qcow2 \
--network network=default \
--graphics vnc,listen=0.0.0.0 \
--noautoconsole \
--os-type=linux \
--os-variant=centos7.0 \
--boot=hd
It is worth noting at this stage that most cloud platforms, whether OpenStack, Amazon
Web Services (AWS) or otherwise, all make use of the cloud-init utility to perform the
initial configuration of the virtual machine image once it is deployed and running. Hence,
as a bare minimum, we will install this in our VM image before we shut it down. The
following are the listed commands required to install this manually and, in the next section,
we will turn this into an Ansible role for installation:
$ yum -y install epel-release
$ yum -y install cloud-init cloud-utils-growpart dracut-modules-growroot
[ 117 ]
Using Ansible to Build Virtual Machine Templates for Deployment Chapter 5
When you have completed these commands successfully, you will probably need to
customize /etc/cloud/cloud.cfg to configure cloud-init for the environment you
will use it in, although the default configuration serves as a good start for many
environments.
Configuring cloud-init is left as an exercise for you, given the wide
variety of cloud platforms.
Finally, when you have performed any other customization you need, you can now shut
the virtual machine down. Make sure to shut it down cleanly rather than simply powering
it off, as this is going to become a template to be deployed at scale.
Once the virtual machine has been shut down, the next step is to run system preparation
(sysprep) on the image, and then to compact the sparse image file to make it as small as
possible for distribution and archival.
The process of sysprepping is to prepare an image for deployment at scale. Hence, all
uniquely identifiable parameters will be wiped to produce a clean image for deployment at
scale, such as the following:
SSH host keys
History files
Local session configuration
Log files
MAC address references in network configuration
The preceding list is not exhaustive though—there are numerous items to clean up for an
image to be considered truly clean and ready for deployment, and it would warrant an
entire chapter by itself to explain them all. Fortunately for us, there are two commands in
the suite of KVM tools that perform exactly these tasks for us:
$ sudo virt-sysprep -a centos76-soe.qcow2
$ sudo virt-sparsify --compress centos76-soe.qcow2 centos76-soe-final.qcow2
[ 118 ]
Using Ansible to Build Virtual Machine Templates for Deployment Chapter 5
Although the output from the first command is too lengthy to fit in a single screenshot, it
shows the wide variety of tasks that are considered necessary as part of sysprep, and if you
find yourself running through this process either manually or with Ansible, the virt-
sysprep utility should give you a good guideline as to the tasks you should perform:
[ 119 ]
Using Ansible to Build Virtual Machine Templates for Deployment Chapter 5
Finally, we re-sparsify the disk image, effectively compacting it for efficient storage. Note
that if you get any free space warnings when running this tool (it requires a great deal of
space in /tmp by default—the exact amount will be determined by the size of your virtual
disk image), you should generally not ignore them, as there is a chance the utility will fill
up your partition, hence stopping your build host from working correctly:
The steps performed in this part of this chapter should work for just about any Linux
distribution, being built on just about any Linux host. As ever, refer to the documentation
for your preferred distribution for guidance on package names. Nonetheless, by following
this process, you have now successfully built yourself a completely bespoke cloud image,
which you should be able to upload to many of the popular cloud and hypervisor
platforms.
From here, we will take a more detailed look at customizing the template with Ansible,
rather than entering commands manually as we did in this section.
Using Ansible to build and standardize the
template
You should, by now, have a base Linux image for deployment in your enterprise. If you
chose to download a ready-made template (or indeed, to make use of one provided by a
public cloud provider), then your image will be very much a blank template, ready for
customization. If you chose to build your own, then you may have already chosen to
perform a small amount of customization such as the installation of cloud-init that we
performed earlier. You will note, however, that we did this by hand, which is hardly along
the line of the scalable, repeatable, auditable processes that we have lauded throughout the
early parts of this book. As we proceed through this section of this chapter, we will take a
look at how to customize a base template, regardless of its origin, using Ansible.
[ 120 ]
Using Ansible to Build Virtual Machine Templates for Deployment Chapter 5
There is no one-size-fits-all Linux image that will suit everyone, and as a result, this chapter
is not definitive. We will, however, look at some of the more common tasks that might be
associated with customizing as an image for deployment, such as the following:
Transferring files into the image
Installing packages
Editing configuration files
Validating the image
Through a combination of these examples, most readers should be able to customize their
own images to their requirements with ease. Let's start exploring this in greater depth with
a look at how to transfer files into the virtual machine image we created previously using
Ansible.
Transferring files into the image
It is commonplace, in the experience of the author, to need to inject files into an operating
system image to ensure it meets a given set of requirements. These files might be a simple
text file, such as an enterprise-standard message of the day, a configuration file for an existing
package, or perhaps even a binary file that is not available in a package. Ansible can handle
all of these with ease, so let's look at some specific examples. As it is generally good practice
to write your Ansible code in roles to support reuse and readability, we will define a role
for our example here. In this example, I am making the following assumptions:
We have downloaded/built our Linux template as outlined in the previous
section of this chapter.
We are running this bare template in a virtual machine.
The IP address of this virtual machine is 192.168.81.141.
The virtual machine has a user account already set up with the following
credentials:
Username: imagebuild.
Password: password.
This account is sudo-enabled.
[ 121 ]
Using Ansible to Build Virtual Machine Templates for Deployment Chapter 5
Naturally, we would not distribute a cloud image with a sudo-enabled account that uses a
weak password like this, so we are assuming we will use this account during the build
phase only and then will remove it during the cleanup phase. Ansible needs to be able to
connect to a remote host to perform its magic, but the account it uses can be transient in
nature and removed after use:
1. Under our example, we would create an inventory file that looks like this—yours
will undoubtedly be different and customizing it for your image and
environment is left as an exercise for you:
[imagesetup]
192.168.81.141
[imagesetup:vars]
ansible_user=imagebuild
ansible_password=password
ansible_sudo_pass=password
This is a very simple example; in many ways, it is the bare minimum needed for
this process when we do not have SSH key authentication configured. Often SSH
keys are the best way to handle SSH authentication as they offer several benefits,
not least that tasks can run without a password prompt.
Although this inventory file is intended to be transient in nature, it is still
best practice to use ansible-vault to store passwords and this is
recommended here. For the sake of simplicity in this chapter and to
reduce the number of steps that you need to complete, we will leave the
passwords unencrypted (in cleartext).
2. Next, we'll create the basic directory structure for our role:
$ mkdir -p roles/filecopyexample/tasks
$ mkdir -p roles/filecopyexample/files
3. Now, let's create a few sample files to copy across. First of all, create a
customized message to append to the message of the day
in roles/filecopyexample/files/motd:
------------------------
Enteprise Linux Template
Created with Ansible
------------------------
[ 122 ]
Using Ansible to Build Virtual Machine Templates for Deployment Chapter 5
4. Let's also create a new configuration file for the chrony service to synchronize
time to our corporate time servers
in roles/filecopyexample/files/chrony.conf:
pool ntp.example.com iburst maxsources 4
keyfile /etc/chrony/chrony.keys
driftfile /var/lib/chrony/chrony.drift
logdir /var/log/chrony
maxupdateskew 100.0
rtcsync
makestep 1 3
We intend to copy these two files across to the remote server. However, Ansible is not
limited to copying files from the Ansible host—it can also download files from a remote
server directly to the target host:
1. Let's suppose your build is going to need docker-compose—we could
download this from an internal server, or even directly from the internet if your
image machine has access to the internet. Suppose we want to install docker-
compose 1.18.0 into our images, we can instruct Ansible to download this
directly from https:/​/​github.​com/​docker/​compose/​releases/​download/​1.​18.
0/​docker-​compose-​Linux-​x86_​64.
2. Now, let's build our role to copy across our two files and download docker-
compose into our image—this must be written
in roles/filecopyexample/tasks/main.yml. The first part of this role is
shown in the following code, and serves to copy across the two configuration
files we discussed earlier:
---
- name: Copy new MOTD file, and backup any existing file if it
exists
copy:
src: files/motd
dest: /etc/motd
owner: root
group: root
mode: '0644'
backup: yes
- name: Copy across new chrony configuration, and backup any
[ 123 ]
Using Ansible to Build Virtual Machine Templates for Deployment Chapter 5
existing file if it exists
copy:
src: files/chrony.conf
dest: /etc/chrony.conf