### 优化后的文本

#### 图3：Wren、H-Cure 和 Cure 在不同条件下的性能比较
- **吞吐量与平均事务延迟** (a) Wren 实现了更低的延迟，因为它从不阻塞读操作。H-Cure 的性能介于 Cure 和 Wren 之间，表明仅使用 HLCs 无法完全解决 TCC 中读操作阻塞的问题。
- **平均阻塞时间** (b) Cure 和 H-Cure 随着负载增加而表现出更长的平均阻塞时间，而 Wren 从不阻塞读操作。

#### 垃圾回收
- 定期地，数据中心内的分区交换它们最旧的快照（对应于活跃事务）。通过聚合最小值确定对当前运行事务可见的最旧快照，并保留该快照及其之前的版本，删除更早的版本。

#### 正确性
- **快照因果关系**：客户端在启动事务时会附带其见过的最新快照，确保客户端看到的快照具有单调性。提交时间戳反映了因果关系，BiST 跟踪每个 DC 内每个分区安装的快照的下界。
- **写操作原子性**：事务写入的项具有相同的提交时间戳和 RST。LST 和 RST 是根据 DC 内所有分区的最小值计算得出的。如果一个事务写入了 X 和 Y，并且某个快照包含 X，则它也包含 Y（反之亦然）。

#### 性能评估
- **实验环境**：
  - **平台**：我们在 Amazon EC2 上部署了一个地理复制系统，最多涉及 5 个数据中心（弗吉尼亚、俄勒冈、爱尔兰、孟买和悉尼）。每个数据中心最多使用 16 台服务器（m4.large 实例，配备 2 个 vCPU 和 8 GB RAM）。
  - **实现**：我们使用相同的 C++ 代码库实现了 Wren、H-Cure 和 Cure，所有协议都实现了最后写入者获胜规则以保证收敛。我们使用 Google Protobufs 进行通信，并使用 NTP 同步物理时钟。
  - **工作负载**：我们使用 95:5、90:10 和 50:50 的读写比工作负载。这些是标准的工作负载，也用于其他 TCC 系统的基准测试。默认工作负载使用 95:5 读写比，在 3 个数据中心和 8 个分区上运行，每笔事务涉及 4 个分区。

- **性能评价**：
  - **延迟和吞吐量**：图 3(a) 显示了 Wren、H-Cure 和 Cure 在默认工作负载下的平均事务延迟与吞吐量。Wren 达到了比 Cure 最多低 2.33 倍的响应时间，因为 Wren 从不因时钟偏移或等待快照安装而阻塞读操作。Wren 的吞吐量也比 Cure 高出多达 25%。
  - **Cure 和 H-Cure 的阻塞统计**：图 3(b) 提供了 Cure 和 H-Cure 中阻塞情况的见解。图中显示了阻塞事务的平均阻塞时间。阻塞时间随着负载的增加而增加，因为更高的负载导致更多的事务被插入到待处理队列和提交队列中，从而增加了事务提交和相应快照安装之间的延迟。

- **变化的工作负载**：
  - **不同读写比的性能**：图 4(a) 和图 4(b) 分别报告了 90:10 和 50:50 读写比下的平均事务延迟。图 5(a) 和图 5(b) 报告了默认读写比为 95:5，但分别涉及 2 个和 8 个分区的情况。这些图表显示，Wren 在广泛的工作负载范围内均优于 Cure 和 H-Cure，实现了最高可达 Cure 的 1.33 倍和 H-Cure 的 1.23 倍的吞吐量。

#### 结论
- Wren 通过非阻塞读操作和高效的垃圾回收机制，在多种工作负载下表现出色，特别是在高负载情况下，能够显著降低延迟并提高吞吐量。