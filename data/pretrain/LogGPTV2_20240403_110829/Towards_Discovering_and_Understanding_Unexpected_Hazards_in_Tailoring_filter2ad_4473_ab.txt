• New Understanding and New Hazards. We reverse-engineer 30
widely-deployed Android AVDs and build a framework to conduct
the ﬁrst empirical study towards a comprehensive understanding of
their design logic. Our study discover new hazards in malScan, en-
gineUpdate and other mission critical operations of Android AVDs.
• Measurements and Implementation. We fully measured vari-
ous types of malScan mechanism on Android and then design and
develop targeted evasions against antivirus based on FFT and sig-
nal steganography techniques. For the hazards in engineUpdate,
besides measuring the length of the null protection window on var-
ious hardware devices, we identify and analyze the Android AOSP
source code for the program logic that creates the vulnerable pe-
riod. We then built a model checker to automatically verify the
existence of the discovered hazard in all Google Android versions
from v1.5–v4.4.4, as well as vendor customized OS images.
•
Industrial Impact. Because of the seriousness of these hazards
and the great impact of current Android AVDs (around one bil-
lion user downloads), we immediately reported our ﬁndings to the
antivirus vendors across 16 countries, and proposed mitigations de-
signs to them. Also, not only can this engineUpdate hazard hurt the
AVD apps, but it will impact other Android apps that require con-
tinuous running/monitoring (e.g. Mobile Device Management apps
(MDMs) or Intrusion Prevention Systems (IPSs)) as well. Hence,
we reported the hazard and proposed feature enhancements to the
security team at Google, and they responded immediately and con-
ﬁrmed our ﬁndings.
2. BACKGROUND
2.1 AVD Background
Android is an operating system built upon the Linux Kernel. On
top of the Linux kernel, Android is loaded with four software lay-
ers, namely System Libraries, Android Runtime, Application Frame-
work and Application.
In addition to the native Linux basic ac-
cess control mechanism, Android provides a ﬁne-grained permis-
sion mechanism for all the apps running on the Application layer,
including all the AVDs from third party vendors.
Generally, Android uses a standard template process, the Zy-
gote, for all the Dalvik Virtual Machine (DVM) processes warm-
up phase. Zygote is the parent process for all the Android DVM
processes, including all the AVDs’ main processes. Each AVD is
assigned its own unique user ID (UID) at install time, and the ac-
cess control bits for the relevant ﬁles and folders in the ﬁle system
are then set accordingly by the system. The dedicated group ID
(GID) numbers are assigned based on the requested permissions
for system resources. For instance, if an AVD wants to perform
scanning operations on the ﬁles in the sdcard, it must ﬁrst request
the READ_EXTERNAL_STORAGE permission. Then, the system
adds a relevant GID number (1028) for it and the process is put
into the AID_SDCARD_R group to enable its access to the sdcard.
In the current Android system, a Binder interprocess commu-
nication (IPC) mechanism is used for more efﬁcient Intents based
message passing. Intents can be used in different purposes. For the
app relevant usages, it can be sent to start an activity, start a service,
deliver/receive a broadcast and so on. The system delivers various
broadcast intents for system events to the apps/services that have
registered to it. An AVD app/system daemon usually listens to spe-
ciﬁc broadcast intents by registering a broadcast receiver in the ﬁle
AndroidManifest.xml or programmatically registering the relevant
receiver in the code. For example, if an AVD app wants to relaunch
automatically after the system boots up, it has to register for the
system-broadcasted intent BOOT_COMPLETED, which is issued
by the system once the boot process is completed. Some AVDs
perform scanning for newly installed apps through registering the
PACKAGE_ADDED events generated from the Package Manager
Service (PMS) component. Listening system-broadcasted intents
enables the AVD to keep track of system events of interest that are
happening and then take appropriate actions.
2.2 AVD Behavior Analyses
Table 1 lists 30 popular AVDs that we selected from Google Play
in Feb. 2014, which enjoy a total user downloads of about one bil-
lion. We pick the top 30 AVDs based on their overall protection
rankings, according to AV Test Reports [6] for the period of Jan.
2014–April. 2014. To better understand the internal design of virus
detectors on the Android platform, we further build a framework to
perform comprehensive analyses of the selected AVDs.
2.2.1 AVD Behavior Analysis Framework
Our framework, illustrated in Figure 1, includes Dynamic Tester,
Static Code Analyzer and Environment Information Collector to
collect relevant virus detectors deployment information from both
Android framework and Linux layer of the system.
The Dynamic Tester is built to interact with the AVDs, so that
we can repetitively test some interesting properties of AVDs’ run-
time behavior. We wrote python and shell scripts to glue together
the ADB tool, the Monkey-Runner tool [4], and the DDMS tool [3]
from Android Studio. Monkey-Runner is a testing program that can
send user and system events for our testing purpose. We leverage
Figure 1: The AVD testing framework for Android platform
DDMS, a common debugger for Android developers, to collect rel-
evant execution traces for particular operations for further analysis.
In the Static Code Analyzer, we ﬁrst decompile the APKs of
AVDs and then conduct analyses on the required permissions and
registered intent actions in the corresponding broadcast receiver
components. To further understand the design logic of AVDs, we
build the control ﬂow graph (CFG) upon the Android Dalvik byte-
code disassembled from baksmali tool [16]. We adapt some of the
analysis modules from Androguard [1] to construct the CFGs. We
notice that most of the AVDs are not highly obfuscated, so the re-
verse engineering process is comparatively straightforward.
We also build an Environment Information Collector to analyze
both the Android framework layer and the underneath Linux layer
with all the AVDs installed, conﬁgured and running on the system.
The purpose is to discover some effective public information leak-
age channels, which can help any third party app infer the AVDs’
running status. For the Linux layer, we parse the information about
the ﬁles and folders (e.g., access control bits) in the ﬁle system
and the information about the running processes (e.g., the UID and
GID numbers and their forking orders). Then we focus particu-
larly on analyzing the information that is relevant to the installed
AVDs. For the Android framework layer, we analyze relevant An-
droid APIs to collect information about AVDs running status. Af-
ter several rounds of automated testing and manual result veriﬁca-
tion, we discover several interesting information leakage channels,
shown in Table 2, which will be especially valuable in determining
the vulnerable periods of the running AVDs. Note that none of the
discovered channels are protected by any Android permission yet.
2.2.2
In Table 3, we list the types and frequencies of the registered
intent actions and claimed permissions of the 30 AVDs collected
based on our reverse engineering result. Our analysis result in-
dicates that current AVDs register lots of interesting permissions
for privileged operations; for instance, the KILL_PROCESSES per-
mission is used to kill suspicious background processes and the
ALERT_WINDOW permission is claimed to help pop up urgent
alert window from the system when suspicious status is identiﬁed.
We also see that the current AVDs emphasize a continuous run-
ning status on the Android system. For instance, all these AVDs
listen to the BOOT_COMPLETED system event to provide com-
plete protection after the system boots up. They also obtain the
WAKE_LOCK permission to periodically wake up the CPU to keep
monitoring the system status. Events like PACKAGE_ADDED and
PACKAGE_REMOVED are mostly registered to help monitor the
newly installed/updated Android application package (APK) ﬁles.
However, we still identify a loophole in its engineUpdate operation
that unexpectedly nulliﬁes the AVDs’ protection.
Intents Registered and Permissions Claimed
Android	
  Framework	
  Layer	
  Na1ve	
  Libs	
  Android	
  Run1me	
  Network	
  File	
  System	
  Process	
  Manager	
  Ac1vity	
  Manager	
  Package	
  Manager	
  Device	
  Hardware	
  Linux	
  Kernel	
  Layer	
  Android	
  AVDs	
  Design	
  and	
  Deployment	
  Logic	
  Environment	
  Informa1on	
  Collector	
  Parsed	
  info	
  of	
  Processes	
  and	
  File	
  system,	
  etc.	
  Iden1ﬁed	
  Hazards	
  Tes1ng	
  events	
  and	
  AVDs	
  conﬁgura1ons	
  Dynamic	
  Tester	
  Sta1c	
  Code	
  Analyzer	
  AVD’s	
  APK	
  ﬁles	
  Hazard	
  Test	
  App	
  Design	
  Tester	
  to	
  Conﬁrm	
  the	
  Hazards	
  Android	
  PlaOorm	
  with	
  AVDs	
  deployed	
  Table 2: Information leakage channels used to infer AVDs’ running status
Explanation
ID Probing Channels
1 ActivityManager.getRunningAppProcesses() Leaks DVM processes meta info (e.g., UID, PID, process name and etc.)
3 ActivityManager.getProcessMemoryInfo()
PackageManager.getInstalledApplications()
4
PackageManager.getPackagesForUid()
5
6
PackageManager.sendBroadcast(Pkg_add)
PackageManager.sendBroadcast(Pkg_rm)
7
8
PackageManager.sendBroadcast(Pkg_updt)
9 Build.MODEL (HARDWARE)
10
11
12
13
14
15
16
Leaks DVM process memory info (e.g., nativePSS, dalvikPrivateDirty and etc.)
Return a List of all the packages of installed applications
Leaks the names of all packages that are associated with a particular UID
Leaks the AVD or other apps’ installation status
Leaks the AVD or other apps’ removal status
Leaks the AVD or other apps’ update status
Leaks device type and hardware speciﬁcations information
Leaks the relevant CPU usage info (e.g. utime, stime and etc.
Leaks tasks CPU usage info of AVD process, used to purify the ﬁngerprinting result
Leaks the memory usage info (e.g. the RSS, virtual memory size, etc.)
Leaks the memory usage info (e.g., the RSS counts in pages)
Leaks all the ﬁles’ meta info (e.g., size, creation date and etc.) in the subfolders
Leaks all the running processes info including the DVM and non-DVM processes.
Leaks the network usage info (e.g., send and received package sizes, etc.)
/proc/[AVD_pid]/stat
/proc/[AVD_pid]/task/[AVD_tid]/stat
/proc/[AVD_pid]/statm
/proc/[AVD_pid]/status
JNI call stat() /data/data/[AVD_package]/*
/system/bin/ps
/proc/uid_stat/[AVD_uid]/snd(rcv)
COARSE_LOCATION
Permissions Requested
SUPERUSER
BATTERY_STATS
google.c2dm.RECEIVE
Table 3: Intents registered and permissions asked by AVDs
Intents Registered
#
1
MEDIA_REMOVED
12
MEDIA_CHECKING
17
PWR_DISCONNECTED
21
WIFI_STATE_CHANGED
DATE_CHANGED
21
22
SERVICE_STATE
22
DIAL
22
MEDIA_UNMOUNTED
23
POWER_CONNECTED
23
net.wiﬁ.STATE_CHANGE
MEDIA_EJECT
25
25
USER_PRESENT
25
ACTION_SHUTDOWN
26
NEW_OUTGOING-CALL
26