title:OMash: enabling secure web mashups via object abstractions
author:Steven Crites and
Francis Hsu and
Hao Chen
OMash: Enabling Secure Web Mashups via Object
Abstractions
Steven Crites
Francis Hsu
Hao Chen
University of California, Davis
PI:EMAIL
University of California, Davis
PI:EMAIL
University of California, Davis
PI:EMAIL
ABSTRACT
The current security model used by web browsers, the Same Ori-
gin Policy (SOP), does not support secure cross-domain communi-
cation desired by web mashup developers. The developers have to
choose between no trust, where no communication is allowed, and
full trust, where third-party content runs with the full privilege of
the integrator. Furthermore, the SOP has its own set of security
vulnerabilities and pitfalls, including Cross-Site Request Forgery,
DNS rebinding and dynamic pharming. To overcome the unfor-
tunate tradeoff between security and functionality forced upon to-
day’s mashup developers, we propose OMash, a simple abstraction
that treats web pages as objects and allows objects to communi-
cate only via their declared public interfaces. Since OMash does
not rely on the SOP for controlling DOM access or cross-domain
data exchange, it does not suffer from the SOP’s vulnerabilities. We
show that OMash satisﬁes the trust relationships desired by mashup
authors and may be conﬁgured to be backward compatible with the
SOP. We implemented a prototype of OMash using Mozilla Firefox
2.0 and demonstrated several proof-of-concept applications.
Categories and Subject Descriptors
D.4.6 [Operating Systems]: Security and Protection
General Terms
Design, Languages, Security.
Keywords
Web, browser, mashup, same origin policy, communication, pro-
tection, security model, object abstraction.
1.
INTRODUCTION
Web browsers are an integral part of everyday computing, with
their uses ranging from accessing simple web pages to accessing
web applications such as online retail, banking, webmail, wikis,
blogs, and discussion boards. The rise of AJAX (Asynchronous
JavaScript and XML) style web applications has given the web dy-
namic, interactive content such as Google Maps [2]. In the case
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’08, October 27–31, 2008, Alexandria, Virginia, USA.
Copyright 2008 ACM 978-1-59593-810-7/08/10 ...$5.00.
of Google Maps, Google has supplied a public API [3] so that
web developers can use Google’s service to create hybrid websites,
such as HousingMaps [4] which takes data from Craigslist [1] and
presents it using Google Maps. This type of hybrid web application
is known as a mashup: a website that combines content from one
or more websites.
Even before the rise of AJAX and mashups, at any given time a
web browser likely contained pages from different domains, whether
they were loaded in different browser windows, tabs, or even frames
within another page. As such, security is extremely important:
without security it would be possible for a script from one web
page to steal or modify critical information from another page. The
solution, ﬁrst presented in Netscape Navigator 2.0, is known as the
Same Origin Policy (SOP)
[24]. It is now the de facto security
model used by web browsers.
1.1 Problems with Same Origin Policy
The Same Origin Policy “prevents document or script loaded
from one origin from getting or setting properties of a document
from a different origin” [24]. Furthermore, “[T]wo pages are con-
sidered to have the same origin if the protocol, port (if given), and
host are the same for both pages.” A “page” refers to a browser
window, , or  (as well as ), as each
can contain a document. Note that a script’s origin is considered
to be the origin of the document that contains it rather than where
the script is hosted. This has important security implications, as a
malicious third-party script will run in the context of the site that
included it via a  tag.
Under this policy, a Domain Name System (DNS) domain is a
principal, much like a user or group is a principal in a multi-user
operating system. While this sufﬁces for mutually distrusting web
pages, it is insufﬁcient for creating web applications with content
from different domains: the only two trust relationships available
between principals are no trust, where third-party content is iso-
lated within a different window or frame, and full trust, where the
third-party content is included as a library via a  tag (this
is the case with Google Maps) and thus has full access to the page
that included it. Faced with this coarse-grained security model, de-
velopers are often forced to make a tradeoff between security and
functionality.
In addition, the SOP suffers from various vulnerabilities due to
either its design limitations or its reliance on insecure services. For
example, it relies on the security of the Domain Name System, and
so where DNS deployment is insecure a dynamic pharming attack
could subvert the SOP [20], and a DNS rebinding attack could leak
information [18]. Furthermore, even though the SOP prevents cer-
tain undesirable cross-domain communication, it is unable to pre-
vent Cross-Site Request Forgery (CSRF) attacks.
MashupOS: To offer a more ﬁne-grained access control model for
mashup applications, MashupOS proposes abstractions for express-
ing various trust relationships between subjects [26]. Our work
is inspired by MashupOS, but we intend to resolve two problems
with MashupOS. First, MashupOS requires different abstractions
for expressing different types of trust relationships.
It proposes
 and CommRequest for access-controlled con-
tent, and  and  for unauthorized con-
tent. By contrast, we propose a single abstraction for expressing all
trust relationships. Second, MashupOS still relies on the SOP for
controlling Document Object Model (DOM) accesses, which has
various vulnerabilities as mentioned. By contrast, our abstraction
does not rely on the SOP for controlling DOM accesses or cross-
domain data exchange, and therefore avoids SOP’s vulnerabilities.
While our model resolves these two problems with MashupOS, our
model can express all the trust relationships described by Mashu-
pOS (Section 3.1).
1.2 OMash
We propose OMash, a new abstraction and access control model
for writing secure yet ﬂexible mashup applications. We draw an
analogue to objects in object-oriented programming languages —
such as Java — where an object represents a principal and objects
can communicate with each other only via public methods. Our
model treats each web page as a principal. By default, all the con-
tents of a web page are private to the page; in other words, private
content is accessible only within the same page. To enable inter-
page communication, a page may declare a public interface, which
all pages can access.
A web page’s private data includes all of the content on the page,
such as DOM objects and JavaScript objects and functions. In addi-
tion, it should also include authentication tokens, such as cookies,
acquired by the page; in other words, only content on that page can
access the authentication tokens, and the tokens will be sent out
only for HTTP connections originating from that page. This mech-
anism reliably defeats CSRF attacks, since a malicious page cannot
access or send authentication tokens held by another page.
OMash does not rely on the SOP. In fact, we advocate abolish-
ing the SOP for controlling DOM accesses and cross-domain data
exchange, since it is inﬂexible, prone to abuse (CSRF attacks), and
vulnerable to DNS attacks. OMash, analogous to the Java object
model, is simple and likely familiar to programmers. We will show
that our simple model can express all the trust relationships dis-
cussed in MashupOS (Section 3.1) and can be conﬁgured to be
backward compatible with the SOP (Section 3.3).
We implemented a prototype of our model using Mozilla Fire-
fox 2.0. We did not need to modify the JavaScript engine. To
implement the public interface, we only need to set a few pref-
erences for Mozilla’s Conﬁgurable Security Policies (CAPS) sys-
tem. To privatize authentication tokens, we used Firefox 2’s Ses-
sion store API. A web page wishing to use our security model to
provide a public interface can simply deﬁne a JavaScript function
getPublicInterface that returns the page’s public interface. We
will show examples in Sections 3 and 4.
2. THE SAME ORIGIN POLICY
The Same Origin Policy is applied to protect three browser re-
sources: documents, cookies, and access to remote services. To
protect documents, sites from one origin cannot access documents
from another origin via the Document Object Model. To protect
cookies, sites can only set their own cookies and cookies are only
sent to their originating site in HTTP requests. Remote services can
be accessed via the XMLHttpRequest (XHR) object, which allows
a script to issue an asynchronous HTTP request to a remote server.
The SOP only permits XHR to issue requests to the origin of the
containing document.
One exception to the SOP permits a script to set its domain to a
sufﬁx of the current domain, and use that newer, shorter domain for
future SOP checks. For example, a script in a document originating
from foo.a.com can perform the assignment document.domain
= "a.com". Thus, its origin is now a.com. Note that a site cannot
set document.domain to a top-level domain (TLD) such as .com.
2.1 Problems
2.1.1 DOM Access
The SOP enforces a single unchangeable security policy on every
site. While in many cases this is ﬁne, since a.com likely does not
want its DOM accessible from a page from b.com also running
in the browser, a.com has no say in the matter; it cannot specify
what resources other sites are allowed to access and let the browser
enforce this policy.
This coarse-grained policy may result in undesired accesses. For
example, documents at http://a.com/foo and http://a.com/bar
are allowed to access each other, even when this is not desired.
Another problem is determining the “public sufﬁx” — previously
known as the effective top-level domain (TLD) — for a given URL.
While a TLD is the last dot-portion of the name (like .com and
.org), many domains are effectively TLDs, such as .co.uk. This
cannot be inferred programmatically, and instead must be deter-
mined via a list [13]. Getting this wrong could allow for a same
origin violation on sites that set their document.domain to .co.uk
or allow a site to get or set a cookie for the entire .co.uk domain.
Another problem with the SOP is that it relies on the security of
the Domain Name System - a system that was not designed with
security in mind. Karlof et al. demonstrated that when an attacker
controls the domain name mapping it is possible to subvert the SOP
using an attack technique called dynamic pharming [20]. Using this
attack, it is possible to bypass all authentication schemes by ﬁrst
mapping the target domain to an attacker’s web page that contains
malicious JavaScript and (for example) an . The attacker
then re-maps the target domain to the actual server and loads the
real web page in the  where authentication takes place as
normal. This results in the attacker having full access to the user’s
session in the , as the origin of the two pages appears to
be the same from the viewpoint of the SOP. In the presence of SSL,
the attack relies on the user accepting the attacker’s self-signed cer-
tiﬁcate in the ﬁrst stage, but as Karlof et al. discuss it is likely that
the user will do so.
2.1.2 Authentication Credentials
One reason that XMLHttpRequest is restricted to communicat-
ing only with its originating page is because of the handling of
authentication credentials in HTTP. When a request is made, cook-
ies matching the destination domain are added to the request, as
well as any other form of HTTP Authentication (e.g. Basic, Di-
gest, NTLM) information for the domain. This is done regardless
of what page caused the browser to initiate this request. Thus, the
web browser can become a confused deputy [16], and this type of
attack is known as Cross-Site Request Forgery (CSRF). CSRF does
not rely on XMLHttpRequest to work, and can be performed in a
variety of ways, e.g. enticing a user to click a URL, using an 
tag, using a  tag, etc. However, in these cases the attacker
can only cause a request that carries the user’s credentials to be ini-
tiated and is unable to view the response (except possibly for the
 tag approach if the targeted URL returns a script). If
XMLHttpRequest was not subject to the same-origin check, view-
ing the response would be possible, and would allow an attacker
to both read and write data on a site for which the user possesses
authentication credentials.
Another reason for restricting XMLHttpRequest is that, even in
the absence of authentication credentials, it could still be used to
read information from an organization’s internal web site that sits
behind a ﬁrewall and then communicate this information back out.
This could occur if the internal web site has no authentication mech-
anism because it relies on the ﬁrewall to keep outsiders from ac-
cessing it, and assumes that no process inside the ﬁrewall can leak
this information back out. However, this leaking of internal infor-
mation is already possible using an attack technique called DNS
rebinding [18], which makes up a portion of the dynamic pharming
attack mentioned above. As described by Jackson et al., an attacker
controlled website (e.g. attacker.com) can change its DNS map-
ping in order to read these unprotected internal documents.
2.2 Trust Levels
Wang et al. in MashupOS [26] enumerate all the possible trust
levels available between integrators and providers in a mashup.
These levels are summarized in Table 1. They identify four types of
content that should be supported: (1) isolated content that should
be isolated from other domains, (2) access-controlled content that
should be isolated but allows for mediated access via, e.g. mes-
sage passing, (3) (and (5)) open content that any domain can ac-
cess and integrate into itself 1, and (4) unauthorized content that
has no privileges of any domain. Isolated content is already pos-
sible via  elements when each document comes from a
different domain, and open content (3 and 5) is possible via the
 tag. Note that, due to the coarse-grained nature of the
SOP, access-controlled content and unauthorized content currently
have no existing abstractions. This leaves mashup developers with
the choice of either no trust using isolated content or full trust us-
ing open content; note that, in order to use an open script library
such as Google Maps, the integrator is forced to trust the provider
as the provider’s library has full access to the domain of the page
that includes it.
3. DESIGN
OMash can provide mashup developers with the ability to allow
safe, controlled communication and interaction between web sites,
and allow for the various trust models they desire.
3.1 Mediate DOM Access
We treat each web page as an object that declares public and
private data and methods. A web page can only access its own
content and the public content of another page. By content, we
mean DOM objects (document, etc.) and JavaScript objects and
functions. Thus, we no longer use the Same Origin Policy for de-
termining whether or not an access on another page is allowed. A
web page in the browser can thus be thought of as analogous to an
OOP language object that has a well-deﬁned public interface.
To achieve this, each page declares a JavaScript function named
getPublicInterface. The name itself is unimportant — all that
matters is that it be a valid JavaScript identiﬁer name and that its use
be standardized. Any page can access the getPublicInterface
function of any other page but cannot modify it; a page can set
1Although in the case of (3), the provider may not wish the inte-
grator to directly access some of its private content, even though
it wishes to provide some public access methods; for example, an
e-mail widget.
var privateVar;
function getPublicInterface()
{
function Interface()
{
this.getHeight = function ()
{
return document.body.clientHeight;
}
this.setVar = function (value)
{
privateVar = value;
}
this.anotherMethod = function (...)
{
...
}
...
}
return new Interface();
}
(a) inner.html, the provider, declares its public interface.
...
// Broken into two steps for clarity
var win =
document.getElementById("inner").contentWindow;
var innerInterface = win.getPublicInterface();
var innerHeight = innerInterface.getHeight();
innerInterface.setVar(10);
...
innerInterface.anotherMethod(...);
...
(b) outer.html, the integrator, calls the public interface declared
in Figure 1(a)
Figure 1: Provider and integrator communicate via the public
interface.
only its own getPublicInterface function. Unless content is
made accessible via the object returned by getPublicInterface,
it cannot be accessed by another page.
An example of its usage is as follows: let a page outer.html
contain an  containing inner.html with an id of inner.
The script in inner.html declares its public interface in Figure 1(a),
and the script in outer.html calls this public interface in Fig-
ure 1(b). Note that the functions getHeight() and setVar() in
Figure 1(a) are closures. A closure is “an expression (typically
a function) that can have free variables together with an environ-
ment that binds those variables (that ‘closes’ the expression).” [10].
Using closures, pages can safely get and set information on other
pages in a controlled manner, as closures allow for the creation of
private members [11]. It might be preferable to only allow basic
types like string and number to be passed around (performing
checking via the typeof operator) for safety reasons.
By using the getPublicInterface function, a page’s creator
can specify what they want other pages to be able to access. Using
this approach, the mashup developer can model a variety of trust
P trusts I to ac-
cess P’s content
I trusts P to access
I’s resources