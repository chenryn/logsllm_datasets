# Automatic Discovery of Parasitic Malware

**Authors:**
- Abhinav Srivastava
- Jonathon T. Giffin

**Affiliation:**
School of Computer Science, Georgia Institute of Technology, USA  
Emails: {abhinav, giffin}@cc.gatech.edu

## Abstract
Malicious software often includes functionality designed to evade detection and analysis by security tools. To prevent the correct attribution of undesirable behaviors to the malware, it frequently subverts the normal execution of benign processes by modifying their in-memory code images to include malicious activities. It is crucial not only to identify maliciously-acting benign processes but also to pinpoint the actual parasitic malware that may have infected these processes. This paper introduces techniques for the automatic discovery of unknown parasitic malware on an infected system. We design and develop a hypervisor-based system, Pyrenée, which aggregates and correlates information from network-level, network-to-host boundary, and host-level sensors to accurately identify the true origin of malicious behavior. Our evaluations on a Windows system demonstrate the effectiveness of our architecture: we successfully identified all malicious binaries in tests with real malware samples, with the tool imposing overheads of only 0%–5% on applications and performance benchmarks.

## 1. Introduction
Malware instances exhibit complex behaviors aimed at evading discovery and analysis by defensive utilities. In addition to file system and registry modifications, malicious software often subverts the normal execution of benign processes by altering their in-memory code images (parasitic behavior). For example, the Conficker worm injects malicious dynamically linked libraries (DLLs) into legitimate software [38]. Similarly, the Storm worm injects code into a user-space network process from a malicious kernel driver to initiate DDoS attacks from infected computers [23]. Parasitic behaviors enable malware to execute actions such as spam generation, denial-of-service attacks, and propagation without raising suspicion. When analyzing a compromised system to identify and eradicate malware, it is essential to both terminate maliciously-acting but benign processes and find other software that may have induced the malicious activity.

The visible effects of current attacks often first manifest as suspicious network traffic, driven by the financial incentives of controlling large networks for botnets, spam, and DDoS attacks [36]. Network intrusion detection systems (NIDSs) can pinpoint the host within a network or enterprise responsible for the malicious traffic [11, 25]. These network sensors can identify the IP address, network ports, and traffic patterns of an infected system. However, this coarse-grained information only allows for coarse-grained responses, such as excising an infected system from the network, which can result in significant data loss. On-host analysis provides a more precise approach by attributing malicious behavior to specific malicious software. Identifying a hijacked benign program requires cooperation between network sensors and on-host execution monitors. By better understanding a malware infection, we can offer opportunities for targeted remediation.

This paper presents techniques and a prototype system, Pyrenée, for the automatic discovery of unknown parasitic malware on an infected system. Pyrenée correlates network-level events with host-level activities, focusing on attacks that generate detectably-suspicious traffic. We design Pyrenée to effectively detect parasitic behavior at both the user and kernel levels. To remain tamper-resistant from kernel-level malware, we utilize hypervisors or virtual machine monitors (VMMs). Pyrenée's architecture includes sensors at the network-to-host boundary (network attribution sensor), the host level (host attribution sensor), and the network level (network sensor), along with a correlation engine that uses the information provided by the sensors to identify likely malware on an infected computer.

The sensors work together to correctly attribute undesirable behaviors to a malicious software infection. Pyrenée uses off-the-shelf network sensors, such as BotHunter [11] or Snort [31], to detect suspicious network traffic and identify hosts with potential malware infections. When a network sensor detects malicious packets, it informs the network-to-host boundary (network attribution) sensor, deployed at the host in a trusted virtual machine (VM). The network attribution sensor then performs secure virtual machine introspection (VMI) to find the process bound to the malicious connection inside the guest VM. While knowing the endpoint of a malicious connection on an infected system significantly reduces the cleaning effort for an administrator, this information is still incomplete. The network attribution sensor cannot determine if the identified process is malicious or if it is a hijacked benign program victim of parasitic behavior.

To find the true origin of malicious parasitic behaviors, Pyrenée uses a host-attribution sensor implanted inside the hypervisor. A process can be affected by parasitic behaviors either from another process or an untrusted kernel driver. The host-attribution sensor monitors the execution of both user-level processes and untrusted kernel drivers. It monitors system calls and their parameters invoked by processes to detect process-to-process parasitic behavior. To detect untrusted drivers' parasitic DLL and thread injection behaviors, we isolate untrusted drivers in a separate address space from the kernel. This design allows the host-attribution sensor to monitor kernel APIs invoked by untrusted drivers and detect parasitic behaviors originating from them.

The correlation engine gathers information from all the sensors to identify the true origin of parasitic behaviors. Correlating network information with host information is a key design feature of our system. Network-based detection can identify an infected system but cannot provide fine-grained process-specific information. Host-based detection can identify occurrences of parasitism but cannot differentiate malicious parasites from benign symbiotes. For example, debugging software and other benign software, such as the Google toolbar, use DLL injection for legitimate purposes. Therefore, a process sending or receiving malicious network traffic may not itself be malware, and a process injecting code into another process may not be malicious. Only by linking injection with subsequent malicious activity observed at the network (or other) layer can we correctly judge the activity at the host.

This paper makes the following contributions:
- We develop a well-reasoned malware detection architecture that finds unknown malware based on its undesirable network use. Our design correlates activity on the network with behaviors at the infected host.
- We correctly attribute observed behaviors to the actual malware responsible for creating those behaviors, even in the presence of parasitic malware that injects code into benign applications. Proper attribution creates the foundation for subsequent surgical remediation of the malware infection.
- Our system works for both user- and kernel-level malware. To monitor parasitic behaviors at the user level, we monitor system calls. For kernel-level parasitism, we securely monitor kernel APIs invoked by untrusted drivers.
- Our design satisfies protection and performance goals. We leverage virtualization to isolate security software from the infected Windows system. Our security evaluation shows that our system can detect the true origin of parasitic behavior occurring at user or kernel levels. The performance evaluation demonstrates that even with runtime on-host monitoring, our performance impact remains only 5% or better.

## 2. Related Work
Pyrenée discovers unknown parasitic malware by identifying the true origin of malicious activities. To achieve its goals, it combines information gathered at both the host and network levels. Previous research in both areas has developed a collection of solutions to aspects of this problem.

Host-based security software generally either scans unknown programs for patterns that match signatures of known malware [17, 2] or continually monitors behaviors of software searching for unusual or suspicious runtime activity [10, 12, 32]. Pyrenée's host attribution sensor is similar to the latter systems. It monitors the execution behavior of processes and untrusted drivers to identify instances of DLL injection or remote thread injection. Unlike traditional host-based utilities, it does not rely on injection alone as evidence of malware, as benign software sometimes uses injection for legitimate purposes. A heuristic-based malware detection system that monitors system calls or kernel APIs and detects code injection attacks may produce false positives. For example, DLL injection is used by the Microsoft Visual Studio debugger to monitor processes under development. Similarly, the Google toolbar injects code into `explorer.exe` (the Windows graphical file browser) to provide Internet search from the desktop. Pyrenée uses system-call information only when a network-sensor provides corroborating evidence of an attack.

Pyrenée uses virtualization to isolate its on-host software from an infected system. Virtualization has been used previously in the development of security software, including intrusion detection systems [8, 14, 20, 15, 28], firewalls [35], protection [26, 30, 40], and other areas [6]. Pyrenée's network attribution sensor is an evolution of the VMwall virtualization-based firewall design [35]. VMwall required packet queuing that introduced delay into network communication; our sensor has no such need and allows network communication to operate at full speed. The sensor makes use of virtual machine introspection (VMI), proposed by Garfinkel and Rosenblum [8], to attribute network communication to processes. Nooks [37] and SIM [33] proposed address space partitioning to isolate drivers and security applications, respectively. Pyrenée also uses address space partitioning to isolate only untrusted drivers from the core kernel and trusted drivers in a different address space.

Backtracker [19] reconstructs the sequence of steps that occurred in an intrusion by using intrusion alerts to initiate construction of event dependency graphs. Similarly, Pyrenée uses NIDS alerts to initiate the discovery of malicious software even in the presence of parasitic behaviors. Technical aspects of Backtracker and Pyrenée differ significantly. Backtracker identifies an attack's point of entry into a system by building dependencies among host-level events. It assumes that operating system kernels are trusted and hence monitors system calls; it stores each individual system call in its log for later dependency construction. Pyrenée identifies software components responsible for post-infection attack behavior visible on the network by correlating behaviors at both the network and host levels. On the host, it monitors and stores only high-level parasitic behaviors. It does not trust the OS kernel and assumes that kernel-level malware may be present, and it monitors both system calls and kernel APIs to detect both user- and kernel-level parasitism. Both Backtracker and Pyrenée are useful for remediation in different ways: Pyrenée's information guides direct removal of malicious processes, while Backtracker's information helps develop patches or filters that may prevent future reinfection at the identified entry point.

Malware analysis tools [41] have also built upon virtualization. Dinaburg et al. [5] developed an analysis system that, among other functionalities, traced the execution of system calls in a manner similar to our host attribution sensor. Martignoni et al. [21] proposed a system that builds a model of high-level malware behavior based on observations of low-level system calls. Like that system, Pyrenée uses a high-level characterization of DLL and thread injection identified via low-level system-call monitoring; however, our system does not employ the performance-costly taint analysis used by Martignoni. In contrast to analysis systems, our goal is to provide malware detection via correct attribution of malicious behavior to parasitic malware. We expect that it could act as a front-end automatically supplying new malware samples to deep analyzers.

## 3. Parasitic Malware
Pyrenée discovers parasitic malware. In this section, we present the threat model under which Pyrenée operates and describe common parasitic behaviors exhibited by malware.

### 3.1 Threat Model
We developed Pyrenée to operate within a realistic threat model. We assume that attackers can install malicious software on a victim computer system at both the user and kernel levels. Installed malware may modify the system to remain stealthy. These facts are demonstrated by recent attacks happening at the user and kernel levels. A preventive approach that does not allow users to load untrusted drivers may not be effective because users sometimes unknowingly install untrusted drivers for various reasons, such as gaming or adding new devices. Due to these reasons, we distinguish between trusted and untrusted drivers and isolate untrusted drivers in a separate address space. We assume that the malware will at some point send or receive network traffic that network-level intrusion detection systems (network sensors) can classify as malicious or suspicious: this may include traffic related to spam, denial-of-service attacks, propagation, data exfiltration, or botnet command-and-control.

Pyrenée uses virtual machine introspection (VMI) in its network attribution sensor. We perform VMI from a high-privilege virtual machine different from the infected system and assume that the high-privilege machine and the underlying hypervisor are within the trusted computing base. VMI requires kernel data structure invariants to hold. Pyrenée does not protect these data structures but assumes that either existing invariant testing solutions protect the structures [27,1,34] or introspection is performed in a secure way [3]. We do not attempt to detect illicit hooking, control data attacks, evasion from hypervisor-based monitors, or modification of binaries on disk, as previous research has already studied those threats [28, 40, 18, 5].

### 3.2 Malware Behaviors
Parasitic malware alters the execution behavior of existing benign processes to evade detection. These malware often abuse both Windows user and kernel API functions to induce parasitic behaviors. We consider malware parasitic if it injects executable code or threads into other running processes. The parasitic behaviors can originate from a malicious user-level process or a malicious kernel driver. Table 1 lists the different cases in which malware can induce parasitic behavior, and the following section explains each of those cases in detail.

| Number | Source   | Target   | Description                          |
|--------|----------|----------|--------------------------------------|
| Case 1A | Process  | Process  | DLL and thread injection              |
| Case 1B | Process  | Process  | Raw code and thread injection         |
| Case 2A | Kernel driver | Process | DLL and thread alteration            |
| Case 2B | Kernel driver | Process | Raw code and thread alteration       |
| Case 2C | Kernel driver | Process | Kernel thread injection              |

- **Case 1A: DLL Injection**  
  Dynamically-linked library (DLL) injection allows one process to inject entire DLLs into the address space of a second process [29]. An attacker can author malicious functionality as a DLL and produce malware that injects the DLL into a victim process opened via the Win32 API call `OpenProcess` or created via `CreateProcess`. These functions return a process handle that allows for subsequent manipulation of the process. The malware next allocates memory inside the victim using the `VirtualAllocEx` API function and writes the name of the malicious DLL into the allocated region using `WriteProcessMemory`. Malware cannot modify an existing thread of execution in the victim process, but it can create a new thread using `CreateRemoteThread`. The malware passes to that function the address of the `LoadLibrary` API function along with the previously written-out name of the malicious DLL.

- **Case 1B: Raw Code Injection**  
  A raw code injection attack is similar to a DLL injection in that user-space malware creates a remote thread of execution, but it does not require a malicious DLL to be stored on the victim’s computer system. The malware allocates memory space as before within the virtual memory region of the victim process and writes binary code to that space. It then calls `CreateRemoteThread`, passing the starting address of the injected code as an argument.

- **Case 2A: Kernel-Level DLL and Thread Alteration**  
  A kernel-level malicious driver can also exhibit parasitic behavior by injecting or altering DLLs and threads in user-space processes. This involves the driver manipulating the kernel's data structures to insert or modify code in the target process. The driver can use kernel APIs to allocate memory, write code, and create threads in the target process, effectively subverting its normal execution.

- **Case 2B: Kernel-Level Raw Code and Thread Alteration**  
  Similar to Case 2A, but instead of injecting or altering DLLs, the malicious kernel driver directly writes raw code into the memory space of a user-space process. This can involve overwriting existing code or inserting new code to change the process's behavior.

- **Case 2C: Kernel Thread Injection**  
  A malicious kernel driver can inject a new thread into a user-space process. This involves the driver creating a new thread context and scheduling it to run in the target process. The new thread can execute arbitrary code, allowing the malware to perform additional malicious activities.

By understanding and detecting these parasitic behaviors, Pyrenée can accurately identify and attribute malicious activities to the true source, enabling more effective and targeted remediation.