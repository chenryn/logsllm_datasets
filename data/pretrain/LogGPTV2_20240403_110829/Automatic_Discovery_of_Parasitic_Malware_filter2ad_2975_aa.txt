title:Automatic Discovery of Parasitic Malware
author:Abhinav Srivastava and
Jonathon T. Giffin
Automatic Discovery of Parasitic Malware
Abhinav Srivastava and Jonathon Giﬃn
School of Computer Science, Georgia Institute of Technology, USA
{abhinav,giffin}@cc.gatech.edu
Abstract. Malicious software includes functionality designed to block
discovery or analysis by defensive utilities. To prevent correct attribution
of undesirable behaviors to the malware, it often subverts the normal ex-
ecution of benign processes by modifying their in-memory code images
to include malicious activity. It is important to ﬁnd not only maliciously-
acting benign processes, but also the actual parasitic malware that may
have infected those processes. In this paper, we present techniques for
automatic discovery of unknown parasitic malware present on an infected
system. We design and develop a hypervisor-based system, Pyren´ee, that
aggregates and correlates information from sensors at the network level,
the network-to-host boundary, and the host level so that we correctly
identify the true origin of malicious behavior. We demonstrate the eﬀec-
tiveness of our architecture with security and performance evaluations
on a Windows system: we identiﬁed all malicious binaries in tests with
real malware samples, and the tool imposed overheads of only 0%–5%
on applications and performance benchmarks.
1 Introduction
Malware instances exhibit complex behaviors designed to prevent discovery or
analysis by defensive utilities. In addition to ﬁle system and registry changes,
malicious software often subverts the normal execution of benign processes by
modifying their in-memory code image (parasitic behavior). For example, the
Conﬁcker worm injects undesirable dynamically linked libraries (DLLs) into le-
gitimate software [38]. In another example, the Storm worm injects code into a
user-space network process from a malicious kernel driver to initiate a DDoS at-
tack from the infected computers [23]. Parasitic behaviors help malware execute
behaviors—such as spam generation, denial-of-service attacks, and propagation—
without themselves raising suspicion. When analyzing a misbehaving system to
identify and eradicate malware, it is important both to terminate maliciously-
acting but benign processes and to ﬁnd other software that may have induced
the malicious activity.
The visible eﬀects of current attacks against software regularly manifest ﬁrst
as suspicious network traﬃc. This is due to the monetary gains involved in
controlling large networks for botnet, spam, and denial of service attacks [36].
After detecting malicious traﬃc, network intrusion detection systems (NIDSs)
can pinpoint a host within a network or enterprise responsible for that traf-
ﬁc [11, 25]. These network sensors can identify an infected system’s IP address,
S. Jha, R. Sommer, and C. Kreibich (Eds.): RAID 2010, LNCS 6307, pp. 97–117, 2010.
c(cid:2) Springer-Verlag Berlin Heidelberg 2010
98
A. Srivastava and J. Giﬃn
network ports, and traﬃc behaviors. This coarse-grained information permits
only coarse-grained responses: an administrator could excise an infected sys-
tem from the network, possibly for reimaging. Unfortunately, in many common
use scenarios, complete disk sanitization results in intolerable losses of critical
data not stored elsewhere, even though that data may not have been aﬀected
by the infection. On-host analysis changes these brutal remediation techniques
by providing a means to appropriately attribute malicious behavior to malicious
software. Realizing that a process sending or receiving attack traﬃc is a hijacked
benign program requires cooperation between network sensors and on-host exe-
cution monitors. By gaining a better understanding of a malware infection on a
system, we can oﬀer opportunities for surgical response.
This paper presents techniques and a prototype system, Pyren´ee, for auto-
matic discovery of unknown parasitic malware present on an infected system.
Pyren´ee correlates network-level events with host-level activities, so it applies
exclusively to attacks that send or receive detectably-suspicious traﬃc. We de-
sign Pyren´ee to eﬀectively detect parasitic behavior occurring both at the user
and kernel level. To remain tamper-resistant from kernel-level malware, we make
use of hypervisors or virtual machine monitors (VMMs). Pyren´ee’s architecture
is comprised of sensors at the network-to-host boundary (network attribution
sensor), the host level (host attribution sensor) and the network level (network
sensor), as well as a correlation engine that uses information provided by the
sensors to identify likely malware on an infected computer.
The sensors cooperate so that Pyren´ee can correctly attribute undesirable
behaviors to a malicious software infection. Pyren´ee uses oﬀ-the-shelf network
sensors, such as BotHunter [11] or Snort [31], to detect suspicious network traﬃc
and identify hosts with possible malware infections. When a network sensor
detects malicious packets, it informs the network-to-host boundary (network
attribution) sensor, deployed at the host in a trusted virtual machine (VM).
On receiving the information, the network attribution sensor performs secure
virtual machine introspection (VMI) to ﬁnd the process bound to the malicious
connection inside the guest VM. Though knowing the end-point of a malicious
connection on an infected system signiﬁcantly reduces the cleaning eﬀort of an
administrator, this information is still not complete. The network attribution
sensor does not know if the identiﬁed process is malicious, or if it is a hijacked
benign program victim of the parasitic behavior.
To ﬁnd the true origin of malicious parasitic behaviors, Pyren´ee uses a host-
attribution sensor implanted inside the hypervisor. A process can suﬀer from
parasitic behaviors either from another process or an untrusted kernel driver.
To counter that, the host-attribution sensor monitors the execution of both
user-level processes and untrusted kernel drivers. The host-attribution sensor
monitors system calls and their parameters invoked by processes to detect the
process-to-process parasitic behavior. To detect untrusted drivers’ parasitic DLL
and thread injection behaviors, we contain untrusted drivers in an isolated ad-
dress space from the kernel. This design provides the host-attribution sensor an
Automatic Discovery of Parasitic Malware
99
ability to monitor kernel APIs invoked by untrusted drivers and enables it to
detect parasitic behaviors originating from the untrusted drivers.
The correlation engine gathers information from all the sensors to identify
the true origin of parasitic behaviors. Correlating network information with host
information is a key design feature of our system. Taken alone, either approach
will have diminished utility in the presence of typical attacks or normal work-
loads. Network-based detection can identify an infected system but cannot pro-
vide ﬁner-grained process-speciﬁc information. Host-based detection can identify
occurrences of parasitism, but it cannot diﬀerentiate malicious parasites from
benign symbiotes. For example, debugging software and other benign software,
such as the Google toolbar, use DLL injection for legitimate purposes. These ob-
servations are critical: A process sending or receiving malicious network traﬃc
may not itself be malware, and a process injecting code into another process may
not be malicious. Only by linking injection with subsequent malicious activity
observed at the network (or other) layer can we correctly judge the activity at
the host.
This paper makes the following contributions:
– We develop a well-reasoned malware detection architecture that ﬁnds un-
known malware based on its undesirable network use. Our design correlates
activity on the network with behaviors at the infected host.
– We correctly attribute observed behaviors to the actual malware responsi-
ble for creating those behaviors, even in the presence of parasitic malware
that injects code into benign applications. Proper attribution creates the
foundation for subsequent surgical remediation of the malware infection.
– Our system works for both the user- and kernel-level malware. To monitor
parasitic behaviors at the user-level, we monitor system calls. For kernel-level
parasitism, we securely monitor kernel APIs invoked by untrusted drivers.
– Our design satisﬁes protection and performance goals. We leverage virtual-
ization to isolate security software from the infected Windows system. Our
security evaluation shows that our system is able to detect the true ori-
gin of parasitic behavior occurring at user or kernel level. The performance
evaluation demonstrates that even with runtime on-host monitoring, our
performance impact remains only 5% or better.
2 Related Work
Pyren´ee discovers unknown parasitic malware by identifying the true origin of
malicious activities. To achieve its goals, it combines information gathered at
both the host and the network level. Previous research in both individual areas
has developed a collection of solutions to aspects of this problem.
Host-based security software generally either scans unknown programs for
patterns that match signatures of known malware [17, 2] or continually mon-
itors behaviors of software searching for unusual or suspicious runtime activ-
ity [10, 12, 32]. Pyren´ee’s host attribution sensor is closest in spirit to the latter
100
A. Srivastava and J. Giﬃn
systems. It monitors the execution behavior of processes and untrusted drivers to
identify instances of DLL injection or remote thread injection. Unlike traditional
host-based utilities, it does not rely on injection alone as evidence of malware,
as benign software sometimes uses injection for benign purposes. A heuristic-
based malware detection system that monitors system calls or kernel APIs and
detects code injection attacks may produce false positives. For example, DLL
injection is used by the Microsoft Visual Studio debugger to monitor processes
under development. Likewise, the Google toolbar injects code into explorer.exe
(the Windows graphical ﬁle browser) to provide Internet search from the desk-
top. Pyren´ee uses system-call information only when a network-sensor provides
corroborating evidence of an attack.
Pyren´ee uses virtualization to isolate its on-host software from an infected
system. Virtualization has been used previously in the development of security
software, including intrusion detection systems [8, 14, 20, 15, 28], ﬁrewalls [35],
protection [26, 30, 40], and other areas [6]. Pyren´ee’s network attribution sensor
is an evolution of the VMwall virtualization-based ﬁrewall design [35]. VMwall
required packet queuing that introduced delay into network communication; our
sensor has no such need and allows network communication to operate at full
speed. The sensor makes use of virtual machine introspection (VMI), proposed
by Garﬁnkel and Rosenblum [8], to attribute network communication to pro-
cesses. Nooks [37] and SIM [33] proposed address space partitioning to isolate
drivers and security applications, respectively. Pyren´ee also uses address space
partitioning to isolate only untrusted drivers from the core kernel and trusted
drivers in a diﬀerent address space.
Backtracker [19] reconstructs the sequence of steps that occurred in an intru-
sion by using intrusion alerts to initiate construction of event dependency graphs.
In a similar way, Pyren´ee uses NIDS alerts to initiate discovery of malicious soft-
ware even in the presence of parasitic behaviors. Technical aspects of Backtracker
and Pyren´ee diﬀer signiﬁcantly. Backtracker identiﬁes an attack’s point of entry
into a system by building dependencies among host-level events. It assumes that
operating system kernels are trusted and hence monitors system calls; it stores
each individual system call in its log for later dependency construction. Pyren´ee
identiﬁes software components responsible for a post-infection attack behavior
visible on the network by correlating behaviors at both the network level and
host level. On the host, it monitors and stores only high-level parasitic behaviors.
It does not trust the OS kernel and assumes that kernel-level malware may be
present, and it monitors both system calls and kernel APIs to detect both user-
and kernel-level parasitism. Both Backtracker and Pyren´ee are useful to remedi-
ation in diﬀerent ways: Pyren´ee’s information guides direct removal of malicious
processes, while Backtracker’s information helps develop patches or ﬁlters that
may prevent future reinfection at the identiﬁed entry point.
Malware analysis tools [41] have also built upon virtualization. Dinaburg et
al. [5] developed an analysis system that, among other functionality, traced the
execution of system calls in a manner similar to our host attribution sensor. Mar-
tignoni et al. [21] proposed a system that builds a model of high-level malware
Automatic Discovery of Parasitic Malware
101
behavior based upon observations of low-level system calls. Like that system,
Pyren´ee uses a high-level characterization of DLL and thread injection identi-
ﬁed via low-level system-call monitoring; however, our system does not employ
the performance-costly taint analysis used by Martignoni. In contrast to analysis
systems, our goal is to provide malware detection via correct attribution of ma-
licious behavior to parasitic malware. We expect that it could act as a front-end
automatically supplying new malware samples to deep analyzers.
3 Parasitic Malware
Pyren´ee discovers parasitic malware. In this section, we present the threat model
under which Pyren´ee operates and describe common parasitic behaviors exhib-
ited by malware.
3.1 Threat Model
We developed Pyren´ee to operate within a realistic threat model. We assume that
attackers are able to install malicious software on a victim computer system
at both the user and kernel levels. Installed malware may modify the system
to remain stealthy. These facts are demonstrated by recent attacks happening
at the user and the kernel level. A preventive approach that does not allow
users to load untrusted drivers may not be eﬀective because users sometimes
unknowingly install untrusted drivers for various reasons, such as gaming or
adding new devices. Due to these reasons, we distinguish between trusted and
untrusted drivers and isolate untrusted drivers in a separate address space. We
assume that the malware will at some point send or receive network traﬃc that
network-level intrusion detection systems (network sensors) are able to classify as
malicious or suspicious: this may include traﬃc related to spam, denial-of-service
attacks, propagation, data exﬁltration, or botnet command-and-control.
Pyren´ee makes use of virtual machine introspection (VMI) in its network at-
tribution sensor. We perform VMI from a high-privilege virtual machine diﬀerent
than the infected system and assume that the high-privilege machine and the un-
derlying hypervisor are within the trusted computing base. VMI requires kernel
data structure invariants to hold. Pyren´ee does not protect these data structures,
but rather assumes that either existing invariant testing solutions protect the
structures [27,1,34] or introspection is performed in a secure way [3]. We do not
attempt to detect illicit hooking, control data attacks, evasion from hypervisor-
based monitors, or modiﬁcation of binaries on disk, as previous research has
already studied those threats [28, 40, 18, 5].
3.2 Malware Behaviors
Parasitic malware alters the execution behavior of existing benign processes as
a way to evade detection. These malware often abuse both Windows user and
102
A. Srivastava and J. Giﬃn
Table 1. Diﬀerent parasitic behavior occurring from user- or kernel-level
Number
Source Target
Description
Process Process
DLL and thread injection
Case 1A
Process Process Raw code and thread injection
Case 1B
Case 2A Kernel driver Process
DLL and thread alteration
Case 2B Kernel driver Process Raw code and thread alteration
Case 2C Kernel driver Process
Kernel thread injection
kernel API functions to induce parasitic behaviors. We consider a malware par-
asitic if it injects either executable code or threads into other running processes.
The parasitic behaviors can originate either from a malicious user-level process
or a malicious kernel driver. Table 1 lists the diﬀerent cases in which malware
can induce parasitic behavior, and the following section explains each of those
cases in detail.
Case 1A: Dynamically-linked library (DLL) injection allows one process to in-
ject entire DLLs into the address space of a second process [29]. An attacker
can author malicious functionality as a DLL and produce malware that injects
the DLL into a victim process opened via the Win32 API call OpenProcess or
created via CreateProcess. These functions return a process handle that allows
for subsequent manipulation of the process. The malware next allocates memory
inside the victim using the VirtualAllocEx API function and writes the name
of the malicious DLL into the allocated region using WriteProcessMemory. Mal-
ware cannot modify an existing thread of execution in the victim process, but it
can create a new thread using CreateRemoteThread. The malware passes to that
function the address of the LoadLibrary API function along with the previously
written-out name of the malicious DLL.
Case 1B: A raw code injection attack is similar to a DLL injection in that
user-space malware creates a remote thread of execution, but it does not require
a malicious DLL to be stored on the victim’s computer system. The malware
allocates memory space as before within the virtual memory region of the victim
process and writes binary code to that space. It then calls CreateRemoteThread,
passing the starting address of the injected code as an argument.
Case 2A: A kernel-level malicious driver also shows parasitic behavior by in-