tures, for that matter), we do not consider these differences
to be germane, so we simply report results in terms of total
memory words used.
6 Results
We now describe the results of the experiments described
in Section 5. We demonstrate the cost of the CRC al-
gorithms in terms of execution time and memory require-
ments. We also analyze the relative error detection capa-
bilities of the various algorithms. Because we have intro-
duced new classes of CRC polynomials (CRC32sub8 and
CRC32sub16), we also present a list of “good” polynomials
in those classes for various Hamming Distances and code
word lengths.
6.1 Performance
Figures 1 and 2 compare the computational speed of
the four algorithms for CRC16, CRC32sub8, CRC24,
CRC32sub16, and CRC32 on each microcontroller. WCET,
AET, and BCET are represented by the narrowing bars.
Bars that do not narrow represent implementations with
ﬁxed execution paths. Figures 3 and 4 compare the memory
requirements for the same set of algorithms. As expected,
there is clearly a tradeoff between memory usage and execu-
tion speed: faster execution can be obtained at the expense
of increased memory usage.
As
expected,
the performance of CRC16 and
CRC32sub8 are roughly comparable, as are CRC24
and CRC32sub16.
6.2 Error Detection Capability
When choosing an algorithm and generator polynomial
for performance, it is important not to overlook the error
detection capability of various design choices. To compare
error detection capabilities, we computed the HD bound for
CRC32sub8, CRC24, and CRC32sub16 according to the
methods described in [14] (see Section 6.3 for a short de-
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:11:24 UTC from IEEE Xplore.  Restrictions apply. 
l
s
e
c
y
C
k
c
o
C
l
l
s
e
c
y
C
k
c
o
C
l
Bit-shift
Virtual Table
Optimized Virtual Table
Table Lookup
Worst case
Avg case
Best case
1200
1000
800
600
400
200
0
crc16
crc32sub8
crc24
crc32sub16
crc32
Figure 1. Execution Time for PIC16F
Bit-shift
Virtual Table
Optimized Virtual Table
Table Lookup
1200
1000
800
600
400
200
0
Worst
case
Avg
case
Best
case
1200
1000
800
600
400
200
0
1200
1000
800
600
400
200
0
s
d
r
o
W
y
r
o
m
e
M
m
a
r
g
o
r
P
s
d
r
o
W
y
r
o
m
e
M
m
a
r
g
o
r
P
Bit Shift
Virtual Table
Optimized Virtual Table
Table Lookup
crc16
crc32sub8
crc24
crc32sub16
crc32
Figure 3. Memory Use for PIC16F
Bit Shift
Virtual Table
Optimized Virtual Table
Table Lookup
crc16
crc32sub8
crc24
crc32sub16
crc32
crc16
crc32sub8
crc24
crc32sub16
crc32
Figure 2. Execution Time for HS08
Figure 4. Memory Use for HS08
scription). The results are shown in Table 4. For each class
of polynomials, the table shows the maximum code word
length for which any polynomial of that class can achieve
the stated HD. For example, there is a CRC16 polynomial
which can provide HD=8 for code words from 36 to 151
bits in length; beyond 151 bits, only HD=5 or less is pos-
sible. The bound for CRC32 is not shown because it is not
known; the computation of this bound is currently consid-
ered intractable. However, 32-bit polynomials are known
that can provide HD=6 out to almost 32K bits [5], so as a
practical matter the tradeoff of using other polynomials is
the maximum length at which HD=6 can be provided.
While CRC16 and CRC32sub8 have roughly equiva-
lent computation and memory cost, CRC32sub8 actually
provides signiﬁcantly better error detection. For 2048 bit
code words (a reasonable maximum size for embedded net-
work messages), CRC32sub8 provides HD=6, while the
best CRC16 polynomial provides only HD=4, an improve-
ment of two additional bits of HD. Because all CRCs pro-
vide burst error detection up to the length of the FCS re-
gardless of polynomial, the CRC32sub8 polynomials also
provide superior burst error detection.
When comparing CRC24 and CRC32sub16, which also
have similar memory and performance costs, it is clear that
CRC32sub16 has superior error performance. In addition,
CRC32sub8, which is faster to compute than CRC24 also
has better error detection properties for code words longer
than 151 bits. As before, CRC32sub8 and CRC32sub16
both provide burst error detection for all bursts up to 32
bits in width. Because a chosen CRC must provide a
given HD for the entire range of possible messages, the
choice of either CRC32sub8 or CRC32sub16 for appropri-
ately sized code words would be an improvement in error
detection over CRC24 with the same or better computa-
tional speed. Another beneﬁt of adopting CRC32sub8 or
CRC32sub16 algorithms to replace CRC24 is future ex-
tensibility. 2048 bits is the maximum code word length at
which CRC24 can provide HD=6, which is required for
most safety-critical applications, so any future expansion
would require a CRC algorithm with HD=6 coverage be-
yond this length. CRC32sub8 can provide HD=6 for code
words of up to 4145 bits (more than double that of CRC24),
and CRC32sub16 up to 8220 bits (more than 4 times that of
CRC24).
6.3 Good CRCksubr Polynomials
The optimal HD bound and optimum polynomials were
obtained according to the method used in [14], which we
describe brieﬂy here. For each HD, the entire space of poly-
nomials meeting the CRCksubr criteria was evaluated to
the longest data length where a polynomial of the given HD
still exists. If there is only one polynomial which reaches
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:11:24 UTC from IEEE Xplore.  Restrictions apply. 
Table 4. Hamming Distance and Maximum
Code Word Length
Hamming Distance (bits)
7
35
CRC16
CRC32sub8
12 11 10
–
–
–
–
–
–
47 –
50
6
8
9
151
31
–
197 270 4145
–
63 129 255 2048
CRC32sub16 62 65 106 116 313 516 8046+
This table shows the maximum code word length (data word +
FCS) for which a given HD can be obtained for a given polyno-
mial class.
CRC24
this length, then it is considered good. If there are multiple
such polynomials, then the one with the lowest Hamming
weight (number of undetected errors at a given HD) is iden-
tiﬁed. All polynomials within 10% of this minimum are
then searched to further identify which ones achieve a still
higher HD for shorter message lengths, and the one which
achieves that higher HD for the longest message length is
considered the best. Other criteria are possible for selecting
good polynomials, but this set of criteria provides a rea-
sonable engineering tradeoff for use on typical embedded
applications.
Table 5 shows a breakdown of the good polynomials for
the CRC32sub8 polynomial class. Table 6 lists the good
polynomials for CRC32sub16 polynomial class. Each poly-
nomial is given as a numeric value (binary representation
with implicit x32 term), as well as a polynomial represen-
tation. The third line of each entry contains a list of the
degrees of the polynomial’s factors, using the notation from
[13]. Each good polynomial provides the stated HD (or bet-
ter) for all code words less than or equal to the stated length.
Although the bound for HD=6 is at code words of 4145 bits,
a good polynomial for code words with a maximum length
of 2048 bits is also given, because it has better error detec-
tion at short data lengths.
7 Correctness of the CRC Algorithm
One of the practical issues in implementing CRCs is en-
suring the correct bit order of computation and placement of
bits into the FCS to preserve burst error properties. While
most network protocols do this properly, it is a tricky area
that is not always implemented correctly.
Suppose that an application implements a standard
which requires the data bits to be processed least signiﬁcant
bit (LSB) ﬁrst, as in the CRC32 standard. Because the bit-
reversal process is slow in most processors, instead of us-
ing a “left-shift” algorithm, implementers might instead de-
velop an equivalent “right-shift” algorithm, which is shown
in Table 7. This algorithm uses the reversed CRC polyno-
mial with implicit x0 term. The reverse of the CCITT-16
polynomial is x16 + x11 + x4 + 1 and should be represented
Table 5. Good CRC32sub8 Polynomials
HD
8
7
6
6
x32+x8+x7+x6+x4+x2+x1+x0
Polynomial