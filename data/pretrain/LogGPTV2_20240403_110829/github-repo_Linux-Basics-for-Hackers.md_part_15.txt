现在我们有一个归档文件，但是这个文件比原始文件的总和还要大。如果您想压缩这些文件以方便传输，该怎么办?Linux有几个命令可以创建压缩文件。我们来看看这些:
-   **gzip**，它使用扩展名*.tar.gz*或*.tgz*
-   **bzip2**，它使用扩展名*.tar.bz2*
-   **compress**，它使用扩展名*.tar.z*
这些都可以压缩我们的文件，但它们使用不同的压缩算法和不同的压缩比。因此，我们将看看每一种方式以及它的能力。
通常，**compress**是最快的，但是生成的文件是更大的；**bzip2**是最慢的，但是生成的文件是最小的；**gzip**介于两者之间。作为一个初出乍到的黑客，您应该了解这三种方法的主要原因是，在访问其他工具时，您将遇到各种类型的压缩。因此，本节将向您展示如何处理压缩的主要方法。
#### *用gzip压缩*
让我们先试试**gzip** (GNU
zip)，因为它是Linux中最常用的压缩实用程序。您可以通过输入以下命令来压缩HackersArise.tar文件(确保您位于保存存档文件的目录中):
kali \>gzip HackersArise.\*
注意，我们对文件扩展名使用了通配符**\***，这告诉Linux该命令应该应用于任何以任何文件扩展名结尾的文件。在下面的例子中，您将使用类似的符号。当我们对目录执行长列表格式查看时，我们可以看到HackersArise.tar已经被HackersArise.tar.gz所取代。文件大小已经压缩到3299字节!
kali \>ls -l
­­snip­­
­rw­r­­r­­ 1 root root 3299 Nov 27 2018 13:32 HackersArise.tar.gz
­­snip­­
然后，我们可以使用**gunzip**命令(GNU unzip的缩写)解压缩该文件。
kali \>gunzip HackersArise.\*
解压后，文件不再使用.tar.gz扩展名保存，而是使用.tar扩展名保存。另外，请注意，它已经返回到原来的大小40,960字节。试着以长列表格式列出来确认这一点。值得注意的是，gzip还可以用于提取.zip文件。
#### *用bzip2压缩*
Linux中另一个广泛使用的压缩实用程序是**bzip2**，它的工作原理类似于**gzip**，但是具有更好的压缩比，这意味着生成的文件将更小。您可以通过输入以下命令来压缩HackersArise.tar文件:
kali \>bzip2 HackersArise.\*
当你以长列表格式列出文件，您可以看到bzip2将文件压缩到了2,081字节！还要注意，文件扩展名现在是*.tar.bz2*。
要解压压缩的文件，使用**bunzip2**，如下所示:
kali \>bunzip2 HackersArise.\*
kali \>
当您这样做时，文件将返回其原始大小，其文件扩展名将返回.tar。
#### *用compress压缩*
最后，可以使用命令**compress**压缩文件。这可能是最不常用的压缩实用程序，但是很容易记住。要使用它，只需输入命令**compress**和文件名，如下:
kali \>compress HackersArise.\*
kali \>ls -l
­­snip­­
­rw­r­­r­­ 1 root root 5476 Nov 27 2018 13:32 HackersArise.tar.Z
注意，**compress**实用程序将文件的大小减少到5,476字节，是**bzip2**的两倍多。还要注意，文件扩展名现在是*.tar.Z*(大写)。
若要解压同一文件，请使用uncompress:
kali \>uncompress HackersArise.\*
还可以对使用**compress**压缩的文件使用**gunzip**命令。
### 创建存储设备的逐位或物理副本
在信息安全和黑客的世界里，一个Linux归档命令在实用性方面胜过其他命令。**dd**命令逐个比特位复制文件、文件系统，甚至整个硬盘驱动器。这意味着即使删除的文件也会被复制(是的，重要的是要知道您删除的文件可能是可恢复的)，以便于发现和恢复。大多数逻辑复制实用程序(如**cp**)不会复制已删除的文件。
一旦黑客拥有目标系统，**dd**命令将允许他们将整个硬盘驱动器或存储设备复制到他们的系统。此外，那些想要抓住黑客的人
- 即调查调查人员 -
可能会使用此命令来制作硬盘驱动器的物理副本，其中包含已删除的文件和其他可能有助于查找针对黑客证据的构件。
需要注意的是，**dd**命令不应该用于典型的文件和存储设备的日常复制，因为它非常慢，其他命令执行起来更快、更有效。但是，当您需要一个没有文件系统或其他逻辑结构的存储设备的副本时(例如在取证调查中)，它是非常好的。
**dd**命令的基本语法如下:
dd if=inputfile of=outputfile
因此，如果您想为您的闪存驱动器创建一个物理副本，假设闪存驱动器是sdb(我们将在第10章中详细讨论这个名称)，您将输入以下内容:
kali \>dd if=/dev/sdb of=/root/flashcopy
1257441=0 records in
1257440+0 records out
7643809280 bytes (7.6 GB) copied, 1220.729 s, 5.2 MB/s
让我们分解这个命令：**dd**是指定输入文件的物理“复制”命令，**/dev/sdb**表示指定输出文件的/dev目录下的闪存驱动器，/root/flashcopy是要将物理副本复制到的文件的名称。(有关/dev目录中驱动器的Linux系统指定的更完整说明，请参见第10章节)。
**dd命**令可以使用许多参数选项，您可以对这些选项进行一些研究，但其中最有用的是**noerror**选项和**bs**(块大小)选项。顾名思义，即使遇到错误，**noerror**选项也会继续复制。**bs**选项允许您确定要复制的数据的块大小(每个块的读/写字节数)。默认情况下，它被设置为512字节，但是可以更改它以加快进度。通常，这将设置为设备的扇区大小，通常为4KB(4096字节)。有了这些选项，您的命令将如下所示:
kali \>dd if=/dev/media of=/root/flashcopy bs=4096 conv:noerror
正如前面提到的，值得您自己多做一些研究，但是这是对该命令及其常见用法的一个很好的介绍。
### 总结
Linux有许多命令可以让您组合和压缩文件，以便更容易地进行传输。对于组合文件，**tar**是首选命令，并且您至少有三个实用程序可以使用不同的压缩比压缩文件——gzip、bzip2和compression。**dd**命令超越了这个范围。它使您能够在没有文件系统等逻辑结构的情况下对存储设备进行物理复制，允许您恢复已删除的文件等工件。
10
--
文件系统和存储设备管理
----------------------
FILESYSTEM AND STORAGE DEVICE MANAGEMENT
![](media/451fdbee142e8cd4684d71b24707d050.jpg)
如果您来自Windows环境，那么Linux表示和管理存储设备的方式在您看来将非常不同。您已经看到，文件系统没有驱动器的物理表示形式，就像Windows中的C:、D:或E:系统一样，而是有一个文件树结构，其顶部或根目录是/。本章将介绍Linux如何表示存储设备，如硬盘驱动器、闪存驱动器和其他存储设备。
我们首先查看附加的驱动器和其他存储设备是如何挂载在文件系统上的，然后是/(根)目录。在这个上下文中挂载仅仅意味着将驱动器或磁盘附加到文件系统，使操作系统能够访问它们。对于黑客来说，有必要了解文件和存储设备管理系统，包括您自己的系统和目标系统。黑客通常使用外部媒介来加载数据、黑客工具，甚至他们的操作系统。在目标系统上之后，您需要了解正在处理的文件、在何处查找机密文件或其他关键文件、如何将驱动器挂载到目标系统，是否以及在何处可以将这些文件放在系统上。本章将介绍所有这些主题，以及如何管理和监视存储设备。
我们从名为/dev的目录开始，您可能已经在目录结构中注意到了：dev是device的缩写，Linux中的每个设备都由/dev目录中的文件表示。让我们从与/dev开始一起工作。
### 设备目录/DEV
Linux有一个特殊的目录，其中包含代表每个附加设备的文件：适当命名的/dev目录。作为第一个介绍，导航到/dev目录，然后在其上执行长列表格式查看。您应该看到类似清单10
- 1的内容。
kali \>cd /dev kali \>ls -l total 0
crw­­­­­­­ 1 root root 10,175 May 16 12:44 agpgart
crw­­­­­­­ 1 root root 10,235 May 16 12:44 autofs
drwxr­xr­x 1 root root 160 May 16 12:44 block
­­snip­­
lrwxrwxrwx 1 root root 3 May 16 12:44 cdrom ­\> sr0
­­snip­­
drwxr­xr­x 2 root root 60 May 16 12:44 cpu
­­snip­­
*清单10-1:/dev目录的内容*
默认情况下，设备是按字母顺序显示的。您可能认识其中一些设备，比如cdrom和cpu，但是其他设备的名称相当神秘。系统上的每个设备都由/dev目录中的一个文件表示，其中包括您可能从未使用过或甚至从未意识到存在的设备。如果您这样做，可能会有一个设备文件等待使用。
如果您向下滚动屏幕一点，您应该会看到更多的设备清单。特别有趣的是设备sda1、sda2、sda3、sdb和sdb1，它们是硬盘驱动器及其分区、USB闪存驱动器及其分区。
­­snip­­
brw­rw­­­­ 1 root root 8, 0 May 16 12:44 sda
brw­rw­­­­ 1 root root 8, 1 May 16 12:44 sda1
brw­rw­­­­ 1 root root 8, 2 May 16 12:44 sda2
brw­rw­­­­ 1 root root 8, 5 May 16 12:44 sda5
brw­rw­­­­ 1 root root 8, 16 May 16 12:44 sdb
brw­rw­­­­ 1 root root 8, 17 May 16 12:44 sdb1
­­snip­­
让我们仔细看看这些内容。
#### *Linux如何表示存储设备*
Linux对随后挂载在文件系统上的驱动器使用逻辑标签。这些逻辑标签将根据驱动器的挂载位置而变化，这意味着相同的硬盘驱动器可能在不同的时间有不同的标签，这取决于它挂载的位置和时间。
最初，Linux将软盘驱动器(还记得吗?)表示为fd0，将硬盘驱动器表示为hda。您仍然会偶尔在遗留Linux系统上看到这些驱动器表示，但是今天大多数软盘驱动器都消失了(谢天谢地)。即使如此，使用IDE或E-IDE接口的旧的遗留硬盘驱动器仍然以hda的形式表示。较新的串行ATA
(SATA)接口驱动器和小型计算机系统接口(SCSI)硬盘驱动器被表示为sda。驱动器有时被分割成称为分区的部分，这些部分在标记系统中用数字表示，您将在下一节中看到。
当系统有多个硬盘驱动器时，Linux通过按字母顺序递增最后一个字母来串行命名它们，因此第一个驱动器是sda，第二个驱动器是sdb，第三个驱动器是sdc，等等(参见表10-1)。sd后的连续字母通常被称为主编号。
表10-1:设备命名系统
| **设备文件描述** |                    |
|------------------|--------------------|
| sda              | 第一个SATA硬盘     |
| sdb              | 第二SATA硬盘驱动器 |
| sdc              | 第三SATA硬盘驱动器 |
| sdd              | 第四SATA硬盘驱动器 |
#### *硬盘分区*
一些驱动器可以划分为多个分区，以便管理和分离信息。例如，您可能想要将硬盘驱动器分开，以便交换文件、主目录和/目录都位于单独的分区上——您这样做可能有很多原因，包括共享资源和放松默认权限。
Linux在每个分区的驱动器名称后面都加上一个次要编号。这样，第一个SATA驱动器上的第一个分区就是sda1。第二个分区是sda2，第三个是sda3，以此类推，如表10-2所示。
表10-2:分区标识
| **设备文件描述** |                                    |
|------------------|------------------------------------|
| sda1             | 第一个SATA驱动器上的第一个分区(1)  |
| sda2             | 在第一个(a)驱动器上的第二个(2)分区 |
| sda3             | 在第一个(a)驱动器上的第三个(3)分区 |
| sda4             | 在第一个(a)驱动器上的第四个(4)分区 |
有时，您可能希望查看Linux系统上的分区，以查看您拥有哪些分区以及每个分区中有多少可用容量。您可以通过使用**fdisk**实用程序来实现这一点。使用带有**fdisk**的**-l**参数列出所有驱动器的所有分区，如清单10-2所示。
kali \>fdisk -l
Disk /dev/sda: 20GiB, 21474836480 bytes, 41943040 sectors
Units: sectors of 1 \* 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x7c06cd70
Device Boot Start End Sectors Size Id Type
/dev/sda1 \* 2048 39174143 39172096 18.7G 83 Linux
/dev/sda2 39176190 41940991 2764802 1.3G 5 Extended
/dev/sda5 39176192 41940991 2764800 1.3G 82 Linux swap / Solaris
Disk /dev/sdb: 29.8 GiB, 31999393792 bytes, 62498816 sectors
Units: sectors of 1 \* 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes Disk label type: dos
Disk identifier: 0xc3072e18
Device Boot Start End Sectors Size Id Type