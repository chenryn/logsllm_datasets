在家里无聊打了 nullcon, 其中有一题用到了 `Meet-in-the-middle` 这种攻击方式,  
在这里分享给大家.
## 题目
    24 bit key space is brute forceable so how about 48 bit key space? flag is hackim19{decrypted flag}
    16 bit plaintext: b'0467a52afa8f15cfb8f0ea40365a6692' flag: b'04b34e5af4a1f5260f6043b8b9abb4f8'
    from hashlib import md5
    from binascii import hexlify, unhexlify
    from secret import key, flag
    BLOCK_LENGTH = 16
    KEY_LENGTH = 3
    ROUND_COUNT = 16
    sbox = [210, 213, 115, 178, 122, 4, 94, 164, 199, 230, 237, 248, 54,
            217, 156, 202, 212, 177, 132, 36, 245, 31, 163, 49, 68, 107,
            91, 251, 134, 242, 59, 46, 37, 124, 185, 25, 41, 184, 221,
            63, 10, 42, 28, 104, 56, 155, 43, 250, 161, 22, 92, 81,
            201, 229, 183, 214, 208, 66, 128, 162, 172, 147, 1, 74, 15,
            151, 227, 247, 114, 47, 53, 203, 170, 228, 226, 239, 44, 119,
            123, 67, 11, 175, 240, 13, 52, 255, 143, 88, 219, 188, 99,
            82, 158, 14, 241, 78, 33, 108, 198, 85, 72, 192, 236, 129,
            131, 220, 96, 71, 98, 75, 127, 3, 120, 243, 109, 23, 48,
            97, 234, 187, 244, 12, 139, 18, 101, 126, 38, 216, 90, 125,
            106, 24, 235, 207, 186, 190, 84, 171, 113, 232, 2, 105, 200,
            70, 137, 152, 165, 19, 166, 154, 112, 142, 180, 167, 57, 153,
            174, 8, 146, 194, 26, 150, 206, 141, 39, 60, 102, 9, 65,
            176, 79, 61, 62, 110, 111, 30, 218, 197, 140, 168, 196, 83,
            223, 144, 55, 58, 157, 173, 133, 191, 145, 27, 103, 40, 246,
            169, 73, 179, 160, 253, 225, 51, 32, 224, 29, 34, 77, 117,
            100, 233, 181, 76, 21, 5, 149, 204, 182, 138, 211, 16, 231,
            0, 238, 254, 252, 6, 195, 89, 69, 136, 87, 209, 118, 222,
            20, 249, 64, 130, 35, 86, 116, 193, 7, 121, 135, 189, 215,
            50, 148, 159, 93, 80, 45, 17, 205, 95]
    p = [3, 9, 0, 1, 8, 7, 15, 2, 5, 6, 13, 10, 4, 12, 11, 14]
    def xor(a, b):
        return bytearray(map(lambda s: s[0] ^ s[1], zip(a, b)))
    def fun(key, pt):
        assert len(pt) == BLOCK_LENGTH
        assert len(key) == KEY_LENGTH
        key = bytearray(unhexlify(md5(key).hexdigest()))
        ct = bytearray(pt)
        for _ in range(ROUND_COUNT):
            ct = xor(ct, key)
            for i in range(BLOCK_LENGTH):
                ct[i] = sbox[ct[i]]
            nct = bytearray(BLOCK_LENGTH)
            for i in range(BLOCK_LENGTH):
                nct[i] = ct[p[i]]
            ct = nct
        return hexlify(ct)
    def toofun(key, pt):
        assert len(key) == 2 * KEY_LENGTH
        key1 = key[:KEY_LENGTH]
        key2 = key[KEY_LENGTH:]
        ct1 = unhexlify(fun(key1, pt))
        ct2 = fun(key2, ct1)
        return ct2
    print("16 bit plaintext: %s" % toofun(key, b"16 bit plaintext"))
    print("flag: %s" % toofun(key, flag))
## 解题思路
我们的目标就是通过给出的明文 `16 bit plaintext` 和对应的密文 `0467a52afa8f15cfb8f0ea40365a6692`  
算出 key, 从而解密 flag 密文 `04b34e5af4a1f5260f6043b8b9abb4f8`
根据加密代码和题目描述, 很显然方法只有爆破一种, 但是爆破 6 位 key 的 `2**48`(281,474,976,710,656)
种可能是不现实的.  
但正如题目中所说, 爆破 `2**24`(16,777,216) 还是非常简单的.
现在我们的问题变成如何简化这个爆破过程, 这里就要用到一开始说的 `Meet-in-the-middle` 攻击,  
加密主要是这两个函数,
    def fun(key, pt):
        assert len(pt) == BLOCK_LENGTH
        assert len(key) == KEY_LENGTH
        key = bytearray(unhexlify(md5(key).hexdigest()))
        ct = bytearray(pt)
        for _ in range(ROUND_COUNT):
            ct = xor(ct, key)
            for i in range(BLOCK_LENGTH):
                ct[i] = sbox[ct[i]]
            nct = bytearray(BLOCK_LENGTH)
            for i in range(BLOCK_LENGTH):
                nct[i] = ct[p[i]]
            ct = nct
        return hexlify(ct)
    def toofun(key, pt):
        assert len(key) == 2 * KEY_LENGTH
        key1 = key[:KEY_LENGTH]
        key2 = key[KEY_LENGTH:]
        ct1 = unhexlify(fun(key1, pt))
        ct2 = fun(key2, ct1)
        return ct2
发现其实真正的加密函数是 `fun`, 在 `toofun` 中调用了两次  
而且这里并没有将 6 位长的 key 一次性使用, 而是将其从中间分开, 先用前 3 位加密一次, 再用后 3 位加密一次.  
也就是说实际的加密过程是用两个 3 位的 key 连续加密二次.  
这就让我们的攻击有了可能性.
虽然也是爆破, 但是与一开始的最先能想到的爆破 6 位 key 不同的是  
我们先遍历所有 3 位长的 key, 算出 `16 bit plaintext` 对应的所有第一次加密结果, 将其保存起来,  
然后再遍历一次 key, 将密文解密, 如果能在第一次加密的结果中找到, 那么对应的两个 3 位 key 拼起来就是一开始的 6 位 key.  
然后用这个 key 就可以解密出 flag 了~  
现在能感觉到这个攻击的名字取的还是非常切题的, 一边加密, 一边解密, 在中间碰头得到秘钥.
与一开始的解法相比, 我们成功的将 `2**48` 降到 `2*2**24`, 不过对应的是需要一个哈希表来保存所有第一次加密的结果,  
相当于用空间换时间了, 好在现在内存都比较大, 应付起来很轻松.
## 题解
因为 python 不太适合这种大量数据的爆破, 所以就用 C++ 写了, 写的比较烂请见谅
    #include "md5.cpp"
    #include 
    #include 
    #include 
    const int BLOCK_LENGTH = 16;
    const int ROUND_COUNT = 16;
    typedef unsigned char uchar;
    uchar sbox[]  = {210, 213, 115, 178, 122, 4, 94, 164, 199, 230, 237, 248, 54,
                     217, 156, 202, 212, 177, 132, 36, 245, 31, 163, 49, 68, 107,
                     91, 251, 134, 242, 59, 46, 37, 124, 185, 25, 41, 184, 221,
                     63, 10, 42, 28, 104, 56, 155, 43, 250, 161, 22, 92, 81,
                     201, 229, 183, 214, 208, 66, 128, 162, 172, 147, 1, 74, 15,
                     151, 227, 247, 114, 47, 53, 203, 170, 228, 226, 239, 44, 119,
                     123, 67, 11, 175, 240, 13, 52, 255, 143, 88, 219, 188, 99,
                     82, 158, 14, 241, 78, 33, 108, 198, 85, 72, 192, 236, 129,
                     131, 220, 96, 71, 98, 75, 127, 3, 120, 243, 109, 23, 48,
                     97, 234, 187, 244, 12, 139, 18, 101, 126, 38, 216, 90, 125,
                     106, 24, 235, 207, 186, 190, 84, 171, 113, 232, 2, 105, 200,
                     70, 137, 152, 165, 19, 166, 154, 112, 142, 180, 167, 57, 153,
                     174, 8, 146, 194, 26, 150, 206, 141, 39, 60, 102, 9, 65,
                     176, 79, 61, 62, 110, 111, 30, 218, 197, 140, 168, 196, 83,
                     223, 144, 55, 58, 157, 173, 133, 191, 145, 27, 103, 40, 246,
                     169, 73, 179, 160, 253, 225, 51, 32, 224, 29, 34, 77, 117,
                     100, 233, 181, 76, 21, 5, 149, 204, 182, 138, 211, 16, 231,
                     0, 238, 254, 252, 6, 195, 89, 69, 136, 87, 209, 118, 222,
                     20, 249, 64, 130, 35, 86, 116, 193, 7, 121, 135, 189, 215,
                     50, 148, 159, 93, 80, 45, 17, 205, 95
                    };
    int p[] = {3, 9, 0, 1, 8, 7, 15, 2, 5, 6, 13, 10, 4, 12, 11, 14};