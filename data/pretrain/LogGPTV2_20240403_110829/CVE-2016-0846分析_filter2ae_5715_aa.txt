# CVE-2016-0846分析
##### 译文声明
本文是翻译文章，文章来源：360安全播报
译文仅供参考，具体内容表达以及含义原文为准。
**0x01 背景介绍 :**
Google在四月份的Android
Bulletin上公布了CVE-2016-0846,这是由IMemory组件OOB所导致的任意地址读写,根据bulletin对该漏洞的描述,恶意应用可以利用IMemory本地接口的特权提升漏洞,通过一个本地的恶意应用,可获取系统应用的上下文并执行任意代码。
当然Bulletin上的描述是最坏情况下的后果,笔者能力只够利用该洞进行越界读导致crash。该漏洞作者是Project Zero的James
Forshaw,十分珍贵的issue也已公开,且网上也有两个已公开的PoC,分别是Forshaw编写的纯java的PoC以及龚广的cpp编写的PoC,参考资料相当丰富。
**0x02 补丁分析 :**
该洞的补丁补在libs/binder/IMemory.cpp文件内的BpMemory::getMemory函数中,该函数通过remote()获取一个BpBinder代理对象,并调用该对象的transact函数给运行在远程的服务端发送一个GET_MEMORY请求,并将请求返回的结果通过Parcel类型的reply返回。
然而,由于对远程返回结果的过于信任,未打补丁前,直接将size与offset赋给了成员变量mOffset与mSize,而这样做会存在潜在的威胁,详情请接着看后文的分析。打补丁之后,在赋值前先调用getSize()函数获取mHeap的真正堆大小,然后检验Binder调用传回的offset与size的合法性,从而在IMemory的Proxy端避免了越界读写的可能。
补丁信息如下:
    @@ -26,6 +26,7 @@
    #include 
    #include 
    +#include 
    #include 
    #include 
    #include 
    @@ -187,15 +188,26 @@
    if (heap != 0) {
    mHeap = interface_cast(heap);
    if (mHeap != 0) {
    - mOffset = o;
    - mSize = s;
    + size_t heapSize = mHeap->getSize();
    + if (s = 0
    + && (static_cast(o)  0) ? mHeap : 0;
    }
    // ---------------------------------------------------------------------------
**0x03 类间关系及程序流程分析**
如上补丁所补的BpMemory实则是一个实现了IMemory接口的Binder代理对象,通常程序通过该代理向运行在服务端的MemoryBase发送请求。Android系统提供了MemoryHeapBase与MemoryBase两个C++类,以方便应用程序使用匿名共享内存。其中MemoryBase类是在MemoryHeapBase的基础上实现的,在MemoryBase内部有一个类型为IMemoryHeap的强指针mHeap,它指向一个MemoryHeapBase服务,MemoryBase类通过mOffset与mSize来维护mHeap的一小块匿名共享内存。
    class MemoryBase : public BnMemory
    {
    public:
    MemoryBase(const sp& heap, ssize_t offset, size_t size);
    virtual ~MemoryBase();
    virtual sp getMemory(ssize_t* offset, size_t* size) const;
    protected:
    size_t getSize() const { return mSize; }
    ssize_t getOffset() const { return mOffset; }
    const sp& getHeap() const { return mHeap; }
    private:
    size_t mSize;
    ssize_t mOffset;
    sp mHeap;
    };
    IMemory接口定义了MemoryBase服务接口,它主要包括五个成员函数,fasterPointer、pointer、size、offset及getMemory,前四者由IMemory自己实现,其中pointer、size、offset三个函数最终都调用getMemory函数获取返回结果,而getMemory是一个纯虚函数,由IMemory的子类(MemoryBase)来实现。IMemory接口定义如下:
    class IMemory : public IInterface
    {
    public:
    DECLARE_META_INTERFACE(Memory);
    virtual sp getMemory(ssize_t* offset=0, size_t* size=0) const = 0;
    // helpers
    void* fastPointer(const sp& heap, ssize_t offset) const;
    void* pointer() const;
    size_t size() const;
    ssize_t offset() const;
    };
BnMemory及BpMemory两个类均实现了IMemory接口,其中BpMemory是一个运行在Client端的Binder代理类,而BnMemory是运行在Server进程中的本地对象类,BnMemory继续派生出MemoryBase,最终由MemoryBase类实现getMemory函数,因而可以理解为,MemoryBase在实例化之后就成了一个Service组件。
IMemory接口通常被media相关的service使用,Android系统允许通过Binder进程间通信机制来传输IMemory对象,通过在Client端调用getMemory,发送一个GET_MEMORY远程请求,即可返回一个IMemoryHeap类型的匿名共享内存缓冲区。当客户端通过pointer()函数获取指向共享内存区域的指针时,pointer函数直接返回heap->base()+offset,而没有对offset进行检查,如果此处offset+base要大于heap的大小,则会造成越界读,那么代码是否在其他地方做了验证?
    void* IMemory::pointer() const {
    ssize_t offset;
    sp heap = getMemory(&offset);
    void* const base = heap!=0 ? heap->base() : MAP_FAILED;
    if (base == MAP_FAILED)
    return 0;
    return static_cast(base) + offset;  BpMemory::getMemory(ssize_t* offset, size_t* size) const
    {
    if (mHeap == 0) {
    Parcel data, reply;
    data.writeInterfaceToken(IMemory::getInterfaceDescriptor());
    if (remote()->transact(GET_MEMORY, data, &reply) == NO_ERROR) {
    sp heap = reply.readStrongBinder();
    ssize_t o = reply.readInt32();
    size_t s = reply.readInt32(); (heap);
    if (mHeap != 0) {
    mOffset = o;
    mSize = s;
    }
    }
    }
    }
    if (offset) *offset = mOffset;
    if (size) *size = mSize;
    return mHeap;
    }
继续跟进,size与offset由remote()->transact(GETMEMORY,data,&reply)的reply中得到,而发送GETMEMORY请求之后,将调用至MemoryBase::onTransact函数,即BnMemory::onTransact函数,其逻辑如下:
    status_t BnMemory::onTransact(
    uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)
    {
    switch(code) {
    case GET_MEMORY: {
    CHECK_INTERFACE(IMemory, data, reply);
    ssize_t offset;
    size_t size;
    reply->writeStrongBinder( IInterface::asBinder(getMemory(&offset, &size)) );
    reply->writeInt32(offset);