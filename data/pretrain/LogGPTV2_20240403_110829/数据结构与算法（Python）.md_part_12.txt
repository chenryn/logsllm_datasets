s.push(8.4) [4,’dog’,True,8.4]
s.pop() [4,’dog’,True] 8.4
s.pop() [4,’dog’] True
s.size() [4,’dog’] 2
表3.1：简单的栈操作
3.4 栈的抽象数据类型
栈的抽象数据类型是由以下结构和操作定义的。堆栈是结构化的，如上面所描述的，栈是一
个有序的项的集，项添加和删除的一端称为“顶”。栈的命令是按后进先出进行的。栈的操作如
下：
Stack()创建一个新的空栈。它不需要参数，并返回一个空栈。
Push(item)将新项添加到堆栈的顶部。它需要参数item 并且没有返回值。
pop()从栈顶删除项目。它不需要参数,返回item。栈被修改。
peek()返回栈顶的项，不删除它。它不需要参数。堆栈不被修改。
isEmpty()测试看栈是否为空。它不需要参数，返回一个布尔值。
size()返回栈的项目数。它不需要参数，返回一个整数。
例如，如果S 是一个已存在的空栈，那么表3.1 展示一些栈操作的结果。在栈中，栈顶的项目
被列在最右边。
3.4．队列
3.4.1．什么是队列
队列（Queue）是一系列有顺序的元素的集合，新元素的加入在队列的一端，这一端叫做“队尾”
（rear），已有元素的移除发生在队列的另一端，叫做“队首”（front）。当一个元素被加入到队列之
后，它就从队尾开始向队首前进，直到它成为下一个即将被移出队列的元素。
最新被加入的元素必须处于队尾，在队列停留最长时间的元素处于队首。这种原则有时候叫做
“先进先出”（FIFO, first-in first-out），有时候也叫做“先到先服务”。
有关队列最简单的例子就是我们每天都在排的队伍。我们排队看电影，在杂货店里排队等着付
钱，在自助餐厅里我们也排队（这样我们就能从盘子组成的“栈（Stack）”里边拿出我们的盘子）。
一个遵守秩序的队伍，或者队列，严格规定进出都只能有一条通道这。不可以插进队列的中间，也
不能在到达队首之前提前离开队列。图3.3 是一个简单的由Python数据对象构成的队列：
图3.3 一个由Python 数据对象构成的队列
计算机科学中也有许多常见的关于队列的例子。例如：假设我们的计算机实验室有30台电脑联
网到一台打印机上。当学生们想要打印时，他们的打印任务就会“进入队伍”，其中有正在等待打印的
其他任务。最先进入队伍的任务就是接下来要完成的。如果你的任务在队伍的最后，那么你就要等
着在你前面的所有任务都完成。稍后我们还会进一步探讨这个有趣的例子的细节。
除了这种打印队列之外，操作系统还会使用一系列的队列对计算机中的进程进行控制，通常会
使用一种能尽量快地执行程序、服务尽量多的用户的排队算法来决定接下来的操作。同样，在我们
打字的时候，有时候键盘的敲击会比字母在屏幕上显示得更快。这是由于电脑那时候也在执行其它
的任务。键盘的敲击信号被储存在一个类似于队列的缓冲区域，这样它们最终就能以正确的顺序显
示在屏幕上。
3.4.2.抽象数据类型 QUEUE（队列）
抽象数据类型队列通过以下的一些结构和操作来定义。如前文所述，一个队列由一系列有序的
元素构成，它们从叫做“队尾”的一端进入队列，再从叫做“队首”的另一端被移出队列。队列保
持“先进先出”的特性。下面是队列的一些操作：
●·Queue()创建一个空队列对象，无需参数，返回空的队列；
●enqueue(item)将数据项添加到队尾，无返回值；
●·dequeue()从队首移除数据项，无需参数，返回值为队首数据项；
●·isEmpty()测试是否为空队列，无需参数，返回值为布尔值；
●size()返回队列中的数据项的个数，无需参数。
举个例子，如果我们申明变量q 是一个已经创建的空队列，表3.2 列出了对队列进行一系列操
作的结果。这个队列中包含的内容也被显示出来，可以看出队列的队首在右边。4 是最早被加进队
列的元素，因此它被最早返回。
队列操作 队列内容 返回值
q=Queue() [] Queue 对象
q.isEmpty() [] True
q.enqueue(4) [4]
q.enqueue(‘dog’) [‘dog’,4]
q.enqueue(True) [True,‘dog’,4]
q.size() [True,‘dog’,4] 3
q.isEmpty() [True,‘dog’,4] False
q.enqueue(8.4) [8.4,True,‘dog’,4]
q.dequeue() [8.4,True,‘dog’] 4
q.dequeue() [8.4,True] ‘dog’
q.size() [8.4,True] 2
表3.2 队列操作示例
3.4.3.在 PYTHON 中实现 QUEUE
为了实现队列这个抽象数据类型，创建一个新的类是最好的方式。就像之前一样，我们还是利
用简单而强大的列表（List）来帮助建立队列的新类。
我们需要决定列表的哪一端做队尾，哪一端用来做队首。下面的一段代码设定队列的队尾在列
表的0 位置。这使得我们能够利用列表的insert 功能来向队列的队尾添加新的元素。而pop 操作则
可以用来移除队首的元素（也就是列表的最后一个元素）。这也意味着enqueue 的复杂度是O(n)，
而dequeue 的复杂度是O(1)。
代码3 展示的对Queue 类型的操作就是表1 中我们进行的一系列操作。
1 class Queue:
2 def __init__(self):
3 self.items = []
4
5 def isEmpty(self):
6 return self.items == []
7
8 def enqueue(self, item):
9 self.items.insert(0,item)
10
11 def dequeue(self):
12 return self.items.pop()
13
14 def size(self):
15 return len(self.items)
16
17 q=Queue()
18
19 q.enqueue(4)
20 q.enqueue('dog')
21 q.enqueue(True)
22 print(q.size())
代码3
对这个队列的进一步操作将会出现下面的结果：
>>> q.size()
3
>>> q.isEmpty()
False
>>> q.enqueue(8.4)
>>> q.dequeue()
4
>>> q.dequeue()
'dog'
>>> q.size()
2
牛刀小试
1. 假设你进行了下面一系列的队列操作：
q = Queue()
q.enqueue('hello')
q.enqueue('dog')
q.enqueue(3)
q.dequeue()
队列里面还剩下什幺元素？
a)‘hello’,‘dog’
b)‘dog’,3
c)‘hello’,3
d)‘hello’,‘dog’,3
3.4.4. 模拟算法：热土豆
提出队列运作方式的一个典型实例也就是模拟出一个需要运用到先进先出（FIFO）数据管理方式
的真实情景。首先，让我们来考虑一个叫做热土豆的儿童游戏。在这个游戏中（见图3.4）小孩子们
围成一个圆圈并以最快的速度接连传递物品，并在游戏的一个特定时刻停止传递，这时手中拿着物
品的小孩就离开圆圈，游戏进行至只剩下一个小孩。
图3.4 六人传土豆游戏
现在，我们也将热土豆问题称作Josephus问题。这个故事是关于公元1世纪著名历史学家
Flavius Josephus 的，传说在犹太民族反抗罗马统治的战争中，Josephus和他的39个同胞在一个洞穴
中与罗马人相对抗。当注定的失败即将来临之时，他们决定宁可死也不投降罗马。于是他们围成一
个圆圈，其中一个人被指定为第一位然后他们按照顺时针进行计数，每数到第七个人就把他杀死。
传说中Josephus除了熟知历史之外还是一个精通于数学的人。他迅速找出了那个能留到最后的位
置。最后一刻，他没有选择自杀而是加入了罗马的阵营。这个故事还有许多不同的版本。有些是以
三为单位进行计数，有些则是让最后一个留下的骑马逃走。但不管是哪个版本，其核心原理都是一
致的。
我们大体上可以实现对于热土豆问题的模拟（Simulation）。我们的程序将要读入一个名字列表
和用作计数的常数“num”。在经过多次基于num的计数后，程序将返回最终剩下的人的姓名。这时
那个人会怎么样就由你所决定了。
为了模拟这个环状结构，我们会用到队列（见图3.5）。假设拿着土豆的孩子位于队首，当开始
传递土豆时，模拟器会将那个孩子从队首移出队列然后立即让他从队尾进入队列。所有在他前面的
人都轮过一遍后才会再次轮到他传土豆。每经过“num”次出队入队的过程后，站在队首的孩子就会永
久离开队列，游戏将在新的圆圈中继续进行。这个过程会一直持续到只有一个名字剩下（即队列规
格为1时）。
图3.5 用队列模拟热土豆问题
from pythonds.basic.queue import Queue
def hotPotato(namelist, num):
simqueue = Queue()
for name in namelist:
simqueue.enqueue(name)
while simqueue.size() > 1:
for i in range(num):
simqueue.enqueue(simqueue.dequeue())
simqueue.dequeue()
return simqueue.dequeue()
print(hotPotato(["Bill","David","Susan","Jane","Kent","Brad"],7))
代码3. 热土豆问题的模拟实现
具体程序展示在代码3.中。当热土豆函数以7为计数常数时被调用会返回Susan。
可以看到在这个例子中给出的传土豆数要大于列表中人名的个数。但这并不是问题，因为队列
像是一个圆圈，当计数到达最后一人的时候就会回到开始，并继续计数直到到达给定值。同时，我
们还注意到列表将按照顺序被读入队列，列表中的第一个名字会在队首出现。在这个例子中，Bill是
列表中的第一个元素，所以就被移入了队列的第一个。这个问题的各种拓展情况会在练习中给出，
比如说随机数热土豆问题。
3.4.5. 模拟算法：打印任务
一种更为有趣的模拟算法可以用来分析本节前面提过的打印任务。回想一下学生们把打印任务
传输给共享打印机，这些任务便被放入一个先进先出的顺序队列。这种结构中蕴含着很多问题。最
重要的问题应该是打印机是否能处理确定数量的任务，如果不能，学生们可能会等太长时间以至于
错过下一堂课。
考虑计算机科学实验室中的以下情况:平均每天任意一个小时有大约10个学生在实验室里,在这
一小时中通常每人发起2次打印任务,每个打印任务的页数从1到20页不等。实验室中的打印机比较
老旧，如果以草稿模式打印，每分钟可以打印10页；打印机可以转换成较高品质的打印模式，但每
分钟只能打印5页。较慢的打印速度可能会使学生等待太长时间。应该采取哪种打印模式?
我们可以通过建立模型模拟这个实验来做决定。我们需要使用相应的量来代表学生、打印任务
和打印机(图4)。每当学生提交打印任务，即将其加入与打印机相连的等待队列。每当打印机完成一
件打印任务，它会检查等待队列里是否还有剩余的打印任务。我们关心的是每个学生等待打印的平
均时长，这等于每个任务在队列里的等待平均时间。
图3.6 关于打印任务队列的计算机科学实验室
为了模拟出这个情景,我们需要使用“概率”的概念。例如，学生可能会打印1-20页长度的文
档，如果每个任务的打印页数是在1到20之间等概率取，那么一次实际打印任务的页数就可以用1
到20之间的随机数来模拟，那意味着1到20之间任意页数出现的概率相等。
如果实验室里有10个学生并且每人打印两次，那么平均每小时就有20个打印任务。如此的
话，在任意一秒，产生一个打印任务的概率有多大呢?可以考虑任务数与时间的比值。每小时打印20
个任务即平均每180秒生成一个打印任务。
每一秒钟我们可以生成1-180之间的随机数来模拟生成一个打印任务的可能性。如果生成的随机
数是180，即认为生成了一个打印任务。注意有时候可能会接连生成很多任务,有时候也可能需要等
待很长时间才出现一个任务,而实际情况就是这样。在知道了一些基本参数之后,我们的目的是尽可能
精确地模拟真实情况。
3.4.6. 主要模拟步骤
以下为主要的模拟过程:
1、创建一个打印任务队列。每个任务在生成时被赋予一个“时间邮戳”。队列在开始时是空的。
2、对于每一秒(打印过程中的当前秒（currentSecond):
(1)是否有新的打印任务生成?如果有，把它加入打印队列，并把当前秒作为其“时间邮戳”。