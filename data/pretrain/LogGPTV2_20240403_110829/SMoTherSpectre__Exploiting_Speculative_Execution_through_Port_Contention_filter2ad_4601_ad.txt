243
95
RSI
RDX
1502
932
400
65
130
47
56
2
85
29
1048
319
239
32
3864
257
869
98
412
29
70
7
138
8
1659
224
376
29
RCX
4256
1029
1399
276
359
110
82
34
338
96
2566
1036
500
239
R8
568
135
97
58
41
6
25
3
66
16
45
239
39
12
R9
615
29
73
14
31
0
8
0
80
5
29
167
21
1
Table 3: SMoTher-gadgets we found in common system libraries,
for the registers used to pass arguments in the System V x86_64
calling convention. First line: number of SMoTher-gadgets that use
the value in the register, second line: number of gadgets that use its
pointee.
SMoTher-gadgets that compare against the registers used in the
x86_64 calling convention and either use the value in the register
directly, or use it as a pointer and compare to a value pointed to in
memory. The rationale behind this is that BTI gadgets are typically
indirect calls that pass a secret, such as a cryptographic key, as a
parameter. The results show that we can find enough SMoTher-
gadgets even in a single common library such as glibc alone. Note
that this method applies irrespective of whether the library is loaded
at runtime or is statically linked into the victim’s binary. However,
none of the gadgets found were formed from instructions decoded
from unintended byte sequences.
One under-approximating limitation of our gadget search al-
gorithm is that it assumes that gadgets start from the latest flag-
setting instruction before the jump. Suppose a sequence in the vic-
tim’s code is shl 8, rax; test 1, rax; jz 0xadd;. Our tool will
find test 1, rax; jz 0xadd; as a SMoTher gadget which leaks the
least significant bit (LSB) of rax. However, the instructions preced-
ing this might perform computations which cause the gadget to leak
different information. The entire sequence is a different SMoTher
gadget which leaks the 9-th least significant bit of rax. The space
of usable SMoTher-gadgets exceeds the ones we have found, and
depend on the particular victim’s code.
6 REAL WORLD ATTACK
We demonstrate real-world attacks on OpenSSH and OpenSSL, two
commonly used programs handling sensitive secrets that have been
extensively hardened against regular and side-channel attacks.
6.1 OpenSSH attack
OpenSSH is widely used to securely and privately connect to servers
over untrusted networks. The confidentiality of the server’s private
key is essential to the security of the overall system. Leaking the
private server key allows an attacker to impersonate the server,
acting as a man in the middle. In the OpenSSH attack, we find a BTI
.rept 8;
addl r8d, r9d;
addl r10d, r11d;
addl r8d, r9d;
addl r10d, r11d;
.endr;
0x6f8dc: testl 0x100, (rdi)
0x6f8e2: je
0x6f8e4: mov
0x6f8e8: sub
0x6f8ec: sub
0x6f8ef: mov
...
6f8ef
0x10(rbx),rax
0x8(rbx),rax
rax,rsi
rbx,rdi
static void (* volatile ssh_bzero)
void explicit_bzero(void *p, size_t n) {
(void *, size_t) = bzero;
...
ssh_bzero(p, n);
...
}
(a) Attacker-timed code
(b) Victim SMoTher gadget (glibc)
(c) Victim BTI gadget (OpenSSH)
Figure 5: Gadgets from real-world libraries used in our SMoTherSpectre exploit for leaking the 7th least significant bit of rdx’s pointee
gadget in the default OpenSSH (version 7.2) SSH server binary avail-
able on Ubuntu 16.04 LTS, together with four SMoTher gadgets
in glibc version 2.23, and leak bits of the host key. As shown by
Heninger and Shacham [17], leaking a small fraction of bits enables
recovery of the entire key.
The threat model for this attack assumes a local attacker that is
able to initiate TCP connections to the ssh daemon. As before, we
assume that ASLR is disabled (or can be bypassed through other
means). Since the target BTI gadget runs pre-authentication, the
attacker only needs to connect and does not need to authenticate
to the server. In our PoC, the local attacker is running on the same
host. However, the same attack can be run from a colocated VM,
assuming the VMM schedules both attacker and victim VMs on
the same physical core. We also assume that the attacker is able
to spawn processes on the same physical core as the victim SSH
process: the assumption is realistic, as shown for example by Zhang
et al. [37].
Our BTI gadget resides in the explicit_bzero function (Figure 5c)
which clears regions of memory. The function is extensively used
to zero out sensitive data before memory is released as a counter-
measure against data leakage if that memory region is reused for
another purpose. To eliminate the possibility of dead-store opti-
mization by the compiler, explicit_bzero calls the standard bzero
function using a volatile function pointer. We exploit the indirect
jump generated for this function pointer call as the BTI gadget,
knowing that the first argument to the function (stored in register
rdi according to the System V calling convention).
In particular, we exploit an invocation of the BTI gadget where
the pointer refers to the server’s private host key (e.g., RSA key).
This invocation is present in the code path handling new connec-
tions, when the server loop forks new processes for each incom-
ing connection and loads the private host key from disk with the
key_load_private function. The cryptographic values (e.g., the ex-
ponents and modulus of the RSA key) are kept in memory to later
perform the ssh handshake but the buffer used to read out the file
from disk is zeroed out and freed. This gadget is particularly con-
venient since the attacker gets an arbitrary number of attempts
at discovering different bits of the same private key. Also, the at-
tacker can control when the victim process is spawned by initiating
connections to the ssh daemon.
An abridged version of the SMoTher gadget is shown in Fig-
ure 5b (see Appendix C for the full assembly listing). Our chosen
SMoTher gadget differs slightly from that described in Section 4.2
in that it compares the value of a memory location pointed to
by a register, not the value of the register itself. The target and
fall-through path differ in utilization of execution ports 0156. This
gadget is taken from glibc and demonstrates the availability of
SMoTher-gadgets in commonly linked libraries. The attacker times
a sequence of add instructions with register operands (port 0156)
shown in Figure 5a to specifically target the same ports.
We ran our attack on a slightly-modified sshd server. The ssh
server is modified to setup relevant performance counters to be
used for statistical and monitoring purposes. These counter values
are ignored by the actual attack. The other modification is to syn-
chronize the attacker with the BTI gadget (as in Section 4.3). For
other targets (i.e., OpenSSL), we have investigated alternate syn-
chronization mechanisms that do not require victim modification
and have good results. The server was compiled using the default
options for Linux on x86_64.
In the PoC of the attack, an orchestrator process randomly sets
the bit to be leaked before launching the server and attacker on
colocated logical cores. The attacker process is responsible for “poi-
soning” the BTB to cause mis-speculation on the victim process
handling the incoming ssh connection. Prior to BTI, the attacker
also performs a series of cache accesses that result in the eviction
of the server’s cache line containing the function pointer ssh_bzero.
This forces the victim’s indirect call instruction to miss in the cache
and speculate for a few cycles, increasing the BTI success rate. The
attacker process is otherwise identical to the victim and follows the
same code path, increasing the probability of the attacker having
the same branching history as the victim at the call site, thereby
increasing the success rate of BTI. The orchestrator launches an
ssh client on a separate physical core to connect to the server and
trigger the creation of the victim and attacker processes. Victim
and attacker process execute and the attacker is able to collect a
SMoTher-timing sample correlated to the value the LSB in byte 1
of the host private key.
The attack can be extended in two ways. First, we can pair our
BTI gadget with other SMoTher gadgets in the victim, enabling
us to leak other bits of the host private key. Second, we can find
other occurrences of the explicit_bzero BTI gadget (or other BTI
gadgets) where different secrets are held in registers or in memory.
In the explicit_bzero BTI gadget, we found that the value of
the register r12 equals the value of rdi, both pointing to the host
key in memory at the point of attack. Therefore, we are able to
use three other SMoTher-gadgets which dereference r12. These
gadgets allow us to leak extra bits from the host key, specifically the
4th LSB in byte 13, the 4th LSB in byte 14 and the 5th LSB in byte 56.
The corresponding assembly listings are shown in Appendix C.2.
Additionally, we can also find other BTI gadgets, or invocations
of explicit_bzero with different secrets. Other secrets erased by
this function include contents of the /etc/shadow file and client
passwords in cleartext received during login attempts.
6.2 OpenSSL attack
For OpenSSL, we target a BTI gadget in the libcrypto library (ver-
sion 1.1.1b, dated 26-Feb-2019) which is widely used for performing
cryptographic functions and a SMoTher gadget from glibc version
2.27.
Over the years, considerable effort was devoted to thwarting po-
tential attackers and to protect OpenSSL from side-channel attacks,
primarily by removing data-dependent memory-access or control
flow. Our attack, however, targets BTI gadgets (indirect jumps or
calls) that are found in code used to choose between encryption
modes, allowing for multiple modes of operation (such as ECB,
CBC, GCM) with the same block cipher. OpenSSL uses a context
variable that stores function pointers for encryption/decryption.
These pointers are set during the initialization phase depending on
the user-specified cipher mode.
As a result, cryptographic applications using libcrypto execute
an indirect call (the BTI gadget) during every block encryption or
decryption. Such gadgets are the result of commonly used coding
practices, and do not directly perform any data-dependent actions
based on the secret value. As in the OpenSSH attack, the use of func-
tion pointers leads to indirect calls in the compiled binary. While
security was the motivating factor for OpenSSH, OpenSSL uses
function pointers to support polymorphic-like behavior, enabling
our transient execution attack.
Our BTI gadget is contained in EVP_EncryptUpdate, and is
shown in Figure 6c. The third argument (in) contains a pointer to
the plaintext to be encrypted (and is therefore a secret). In accor-
dance with the System V calling convention, this pointer is stored
in register rdx prior to the call. The secret in our chosen SMoTher
gadget is the 3rd LSB in byte 1 of the plaintext, referenced through
rdx. An abridged version of the SMoTher gadget is shown in Fig-
ure 6b (see Appendix B for the full assembly listing).
In our attack, we model a victim that encrypts text using
OpenSSL’s EnVeloP (EVP) API. After performing the necessary
initializations, it performs a series of encryptions using calls to
EVP_EncryptUpdate. We have also instrumented the victim to
setup relevant performance counters which are only used for sta-
tistical and monitoring purposes and are not used in the attack.
The victim library does not contain any code to help the attacker
synchronize with the execution of the BTI gadget.
The attacker triggers the encryptions on the victim. It also runs
code that is almost identical to the victim apart from the following
differences. First, it loads the call pointer with the location of the
SMoTher gadget on the victim to trigger BTI on the victim pro-
cess. Second, it replaces the code at the target location by a delay
sequence and the SMoTher timing. The delay sequence consists of
a series of dependent instructions that allows the attacker to delay
for a controlled number of cycles, synchronizing with the victim’s
SMoTher gadget, before measuring the timing sample. Otherwise,
Pointer register
Byte Offset
rdi
r12
r12
r12
0x01
0x38
0x0d
0x0c
Bit mask ∆ SMoTher timing
0.32% ± 0.21%
0.64% ± 0.62%
0.66% ± 0.47%
0.42% ± 0.33%
0x01
0x10
0x08
0x08
Table 4: SMoTherSpectre results leaking the sshd private key.
Four gadgets, each targeting a different key bit identified by its byte
offset and bit mask, were used. We also show the mean timing dif-
ference percentage for the attacker’s SMoTher timing, separated
according to the value of the randomly-set target bit: all show a dif-
ference at 95% confidence.
the attacker runs code that mimics the victim: it performs the same
call to the encryption function where it follows the same sequence
of checks and jumps. It also runs in a loop performing the same
number of iterations, thus maximising the success of BTI. In each
iteration, the attacker gets one timing measurement. Between iter-
ations, the attacker performs a series of memory accesses designed
to evict the victim’s cache line holding the pointer to the encryption
function from the L1 cache to increase the BTI success rate. We
observed that other usual work being performed on the core can
have the same effect.
6.3 Experimental results
We run the OpenSSH attack on a quad-core, hyper-threaded Sky-
lake CPU (i7-6700K) with the server and attacker pinned on logical
cores 0 and 4 respectively (running on physical core 0). For each
connection attempt to the server, the orchestrator randomly sets