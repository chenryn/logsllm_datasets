amples of resources that can be embedded include sim-
ple markup of images or other media (e.g., ), re-
mote scripts (e.g., ), remote stylesheets (e.g.,
), embed-
ded objects and applets (e.g., ),
655challenge is coping with browsers’ limited APIs for conduct-
ing network measurements, particularly when accessing these
resources requires issuing cross-origin requests.
The scope of Web ﬁltering varies in granularity from in-
dividual URLs (e.g., a speciﬁc news article or blog post) to
entire domains. Detecting Web ﬁltering is difﬁcult regardless
of granularity. On one hand, detection becomes more difﬁcult
with increasing speciﬁcity. When speciﬁc Web resources are
ﬁltered (as opposed to, say, entire domains), there are fewer
ways to detect it. Detecting ﬁltering of entire domains is
relatively straightforward because we have the ﬂexibility to
test for such ﬁltering simply by checking accessibility of a
small number of resources hosted on that domain. In contrast,
detecting ﬁltering of a single URL essentially requires an
attempt to access that exact URL. Resource embedding only
works with some types of resources, which further restricts
the Web resources we can test and exacerbates the difﬁculty
of detecting very speciﬁc instances of ﬁltering.
On the other hand, inferring broad ﬁltering is difﬁcult be-
cause Encore can only observe the accessibility of individ-
ual Web resources, and such observations are binary (i.e.,
whether or not the resource was reachable). Any conclusions
we draw about the scope of Web ﬁltering must be inferred
from measurements of individual resources. We take a ﬁrst-
order glimpse at such inferences in Section 4.3 and present a
ﬁltering detection algorithm in Section 7.
4.2 Measurement tasks
Measurement tasks are small, self-contained HTML and
JavaScript snippets that attempt to load a Web resource from
a measurement target. Encore’s measurement tasks must
satisfy four requirements: First, they must be able to suc-
cessfully load a cross-origin resource in locations without
Web ﬁltering. Tasks cannot use XMLHttpRequest (i.e., AJAX
requests), which is the most convenient way to issue cross-
origin requests, because default Cross-origin Resource Shar-
ing settings prevent such requests from loading cross-origin
resources from nearly all domains. Instead, we induce cross-
origin requests by embedding images, style sheets, and scripts
across domains, which browsers typically allow.
Second, they must provide feedback about whether or not
loading a cross-origin resource was successful. Several conve-
nient mechanisms for loading arbitrary cross-origin requests
(e.g., the iframe tag) lack a clear way to detect when re-
sources fail to load, and are hence unsuitable for measurement
tasks.
Third, tasks must not compromise the security of the page
running the task. Tasks face both client- and server-side
security threats. On the client side, because Encore detects
Web ﬁltering by embedding content from other origins (rather
than simply requesting it, as would be possible with an AJAX
request), such embedding can pose a threat as the browser
renders or otherwise evaluates the resource after downloading
it. In some cases, rendering or evaluating the resources is
always innocuous (e.g., image ﬁles); in other cases (e.g.,
JavaScripts), Encore must carefully sandbox the embedded
Figure 1: Encore induces browsers to collect Web ﬁltering mea-
surements by bundling measurement tasks inside pages served by an
origin Web site.
and document embedded frames such as iframes (e.g.,
). Each of these remote resources has different
restrictions on how the origin page can load them and hence
leak different levels of information. For example, images
embedded with the img tag trigger an onload event if the
browser successfully retrieves and renders the image, and an
onerror event otherwise. The ability for the origin page to
see these events allows the origin page to infer whether the
cross-origin request succeeded.
Although cross-origin embedding of media provides the
most explicit feedback to the origin about whether the page
load succeeded, other embedded references can still provide
more limited information, through timing of onload invo-
cation or introspection on a Web page’s style. Additionally,
browsers have different security policies and vulnerabilities;
for example, we discovered that the Chrome browser allows
an origin site to load any cross-origin object via the script
tag, which allows us to conduct a much more liberal set of
measurements from Chrome. One challenge in designing
Encore is determining whether (and how) various embedded
object references can help infer information about whether an
object was retrieved successfully.
4 Measuring Filtering with Encore
This section explains how Encore measures Web ﬁltering
using cross-origin requests.
4.1 Overview
Figure 1 illustrates how Encore measures Web ﬁltering. The
process involves three parties: a Web client that acts as our
measurement vantage point; a measurement target, which is a
server that hosts a Web resource that we suspect is ﬁltered;
and an origin Web server, which serves a Web page to the
Web client instructing the client how to collect measurements.
In each page it serves, the origin includes a measurement task,
which is a small measurement collection program that attempt
to access potentially ﬁltered Web resources (e.g., Web pages,
image ﬁles) from the target and determine whether such ac-
cesses were successful. The client runs this measurement
task after downloading and rendering the page. The greatest
ClientOriginWeb siteMeasurementtarget1. Origin serves page to clientcontaining measurement task3. Task issues a cross-origin requestfor a resource on measurement target4. Censor may filterrequest or response2. Client renders page andexecutes measurement task656content to prevent it from affecting other aspects of Web
browsing. Requesting almost any Web object changes server
state, and measurement tasks must take these possible side
effects into account. In some cases, the server simply logs that
the request happened, but in others, the server might insert
rows into a database, mutate cookies, change a user’s account
settings, etc. Although it is often impossible to predict such
state changes, measurement tasks should try to only test URLs
without obvious server side-effects.
Finally, measurement tasks must not signiﬁcantly affect
perceived performance, appearance, or network usage.
Below is an example of a simple measurement task that
instructs the Web client to load an image hosted by a mea-
surement target censored.com:
This task meets the four requirements because it (1) requests
an image from a remote measurement target using the img
tag, which is allowed by browser security policy; (2) detects
whether the browser successfully loaded the image by listen-
ing for the onload and onerror events; (3) trivially main-
tains security by not executing any code from resources served
by the measurement target; and (4) preserves performance
and appearance by only loading a very small icon (typically
16× 16 pixels) and hiding it using the display: none
style rule. Appendix A presents a longer example of a
measurement task.
4.3 Inferring Web ﬁltering
A measurement task provides a binary indication of whether
a particular resource failed to load, thus implying ﬁltering
of that speciﬁc resource. From collections of these measure-
ments, we can draw more general conclusions about the scope
of ﬁltering, beyond individual resources (e.g., whether an en-
tire domain is ﬁltered, whether an entire portion of a Web site
is ﬁltered, whether certain keywords are ﬁltered). We must
do so with little additional information about the ﬁltering
mechanism. This section describes how we design sets of
measurement tasks to make these inferences.
There are several ways to test accessibility of cross-origin
Web resources; unfortunately, none of them work across all
types of ﬁltering, all Web browsers, and all target sites. In-
stead, we tailor measurement tasks to each measurement
target and Web client. Detecting Web ﬁltering gets harder
as the scope of ﬁltering becomes more speciﬁc, so we start
with techniques for detecting broad-scale ﬁltering and work
toward more speciﬁc ﬁltering schemes. Table 1 summarizes
the measurement tasks we discuss in this section.
4.3.1 Filtering of entire domains
Encore performs collections of measurement tasks that help
infer that a censor is ﬁltering an entire domain. It is pro-
hibitively expensive to check accessibility of every URL
hosted on a given domain. Instead, we assume that if several
auxiliary resources hosted on a domain (e.g., images, style
sheets) are inaccessible, then the entire domain is probably
inaccessible. Our intuition is that rather than ﬁltering many
supporting resources, an adversary will more likely ﬁlter the
entire domain (or at least an entire section of a site). For-
tunately, detecting ﬁltering of some auxiliary resources is
straightforward because pages often embed them even across
origins.
Images. Web pages commonly embed images, even across
origins. Such embedding is essential for enabling Web ser-
vices like online advertising and content distribution networks
to serve content across many domains.
Encore attempts to load and display an image ﬁle from a
remote origin by embedding it using the 
tag. Conveniently, all major browsers invoke an onload
event after the browser fetches and renders the image, and
invoke onerror if either of those steps fails; the requirement
to successfully render the image means that this mechanism
only works for images ﬁles and cannot decide the accessibility
of non-image content. Downloading and rendering an image
does not affect user-perceived performance if the image is
small (e.g., an icon), and measurement tasks can easily hide
images from view. This technique only works if the remote
origin hosts a small image that we can embed.
Style sheets. Web pages also commonly load style sheets
across origins. For example, sites often load common style
sheets (e.g., Bootstrap [4]) from a CDN to boost performance
and increase cache efﬁciency.
Encore attempts to load a style sheet using the  tag and detects success by verifying that the
browser applied the style speciﬁed by the sheet. For exam-
ple, if the sheet speciﬁes that the font color for  tags is
blue, then the task creates a  tag and checks whether its
color is blue using getComputedStyle. To prevent the
sheet’s style rules from colliding with those of the parent
Web page, we load the sheet inside an iframe. Although
some browsers are vulnerable to cross-site scripting attacks
when loading style sheets, these issues have been ﬁxed in all
newer browsers [26]. Style sheets are generally small and
load quickly, resulting in negligible performance overhead.
4.3.2 Filtering of speciﬁc Web pages
Governments sometimes ﬁlter one or two Web pages (e.g.,
blog posts) but leave the remainder of a domain intact, includ-
ing resources embedded by the ﬁltered pages [32]. Detecting
this type of ﬁltering is more difﬁcult because there is less
ﬂexibility in the set of resources that Encore can use for mea-
surement tasks: it must test accessibility of the Web page in
question and cannot generally determine whether the page is
ﬁltered based on the accessibility of other (possibly related)
resources. Testing ﬁltering of Web pages, as opposed to indi-
vidual resources, is signiﬁcantly more expensive, complicated,
and prone to security vulnerabilities because such testing of-
ten involves fetching not only the page itself, but also fetching
657Mechanism
Images
Style sheets
Inline frames
Scripts
Summary
Render an image. Browser ﬁres onload if successful.
Load a style sheet and test its effects.
Load a Web page in an iframe, then load an image embed-
ded on that page. Cached images render quickly, implying
the page was not ﬁltered.
Load and evaluate a resource as a script. Chrome ﬁres
onload iff it fetched the resource with HTTP 200 status.
Limitations
Only small images (e.g., ≤ 1 KB).
Only non-empty style sheets.
Only pages with cacheable images.
Only small pages (e.g., ≤ 100 KB).
Only pages without side effects.
Only with Chrome.
Only with strict MIME type checking.
Table 1: Measurement tasks use several mechanisms to discover whether Web resources are ﬁltered. We empirically evaluate parameters for
images and inline frames in Section 6.
all of that page’s referenced objects and rendering everything.
This means we must be very careful in selecting pages to
test. Many pages are simply too expensive or open too many
vulnerabilities to test. Section 5 discusses the infrastructure
and decision process we use to decide whether a Web page is
suitable for testing.
We present two mechanisms for testing Web ﬁltering of
Web pages, and the limitations of each mechanism:
Inline frames. A Web page can include any other Web page
inside itself using the iframe tag, even across origins. How-
ever, browsers place strict communication barriers between
the inline page and the embedding page for security, and pro-
vide no explicit notiﬁcation about whether an inline frame
loaded successfully.
Instead, the task infers whether the resource loaded suc-
cessfully by observing timing. It ﬁrst attempts to load the
page in an iframe; then, after that iframe ﬁnishes load,the task
records how long it takes to download and render an image
that was embedded on that page. If rendering this image is
fast (e.g., less than a few milliseconds) we assume that the
image was cached from the previous fetch and therefore the
Web page loaded successfully. This approach only works with
pages that embed objects that will be cached by the browser
and are unlikely to have been cached from a prior visit to
another Web page; for example, common images like the
Facebook’s “thumbs up” icon appear on many pages and may
be in the browser cache even if the iframe failed to load. This
approach can be expensive because it requires downloading
and rendering entire Web pages. Additionally, pages can de-
tect when they are rendered in an inline frame and may block
such embedding.
Scripts. Web pages often embed scripts across origins, sim-
ilarly to how they embed style sheets. For example, many
pages embed jQuery and other JavaScript libraries from a con-
tent distribution network or some other third-party host [28].
The Chrome browser handles script embedding in a way
that lets us gauge accessibility of non-script resources from
a remote origin. Chrome invokes an onload event if it can
fetch the resource (i.e., with an HTTP 200 OK response), re-
gardless of whether the resource is valid JavaScript. In partic-
ular, Chrome respects the X-Content-Type-Options:
nosniff header, which servers use to instruct browsers to
Figure 2: An example of observing Web ﬁltering with Encore. The
origin Web page includes Encore’s measurement script, which the
coordinator decides should test ﬁltering of censored.com by
attempting to fetch an image. The request for this image fails so the
client notiﬁes the collection server.
prohibit execution of scripts with an invalid MIME type [2].
Other browsers are not so forgiving, so we use this task type
on Chrome only. This technique is convenient, but it raises
security concerns because other browsers may attempt to exe-
cute the fetched object as JavaScript. Section 5 describes how
we make this decision.
5 Encore Measurement System
This section presents Encore, a distributed platform for mea-
suring Web ﬁltering. Encore selects targets to test for Web
ﬁltering (§ 5.1), generates measurement tasks to measure
those targets (§ 5.2), schedules tasks to run on Web clients
(§ 5.3), delivers these tasks to clients for execution (§ 5.4),
collects the results of each task (§ 5.5), and draws conclu-
sions concerning ﬁltering practices based on the collective
outcomes of these tests using the inference techniques from
Section 4.
Figure 2 shows an example of how Encore induces a client
to collect measurements of Web ﬁltering. The client visits a
Web site http://example.com, whose webmaster has