# 05 \| 面向对象编程：怎样才能写出一个"好"的类？你好，我是 Chrono。如果按照前几节课的惯例，今天应该是讲运行阶段的。但是，运行阶段跟前面的编码、预处理和编译阶段不同，它是动态的、实时的，内外部环境非常复杂，CPU、内存、磁盘、信号、网络套接字......各种资源交织在一起，可谓千变万化（正如我在第 1 节课slate-object="inline"里所说，每一个阶段的差异都非常大）。解决这个阶段面临的问题已经不是编程技术了，更多的是要依靠各种调试、分析、日志工具，比如GDB、Valgrind、Systemtap 等。所以，我觉得把这些运行阶段的工具、技巧放在课程前面不是太合适，咱们还是往后延一延，等把C++的核心知识点都学完了，再来看它比较好。那么，今天要和你聊哪些内容呢？我想了想，还是讲讲"面向对象编程"（Object OrientedProgramming）吧。毕竟，它是 C++ 诞生之初"安身立命"的看家本领，也是 C++的核心编程范式。不管我们是否喜欢，"面向对象"早就已经成为了编程界的共识和主流。C++、Java、Python等流行的语言，无一不支持面向对象编程，而像 Pascal、BASIC、PHP那样早期面向过程的语言，在发展过程中也都增加了对它的支持，新出的Go、Swift、Rust 就更不用说了。毫无疑问，**掌握"面向对象编程"是现在程序员的基本素养**。但落到实际开发时，每个人对它的理解程度却有深有浅，应用的水平也有高有低，有的人设计出的类精致灵活，而有的人设计出来的却是粗糙笨重。细想起来，"面向对象"里面可以研究的地方实在是太多了。那么，到底"面向对象"的精髓是什么？怎样才能用好它？怎样才能写出一个称得上是"好"的类呢？所以，今天我就从设计思想、实现原则和编码准则这几个角度谈谈我对它的体会心得，以及在C++ 里应用的一些经验技巧，帮你写出更高效、更安全、更灵活的类。（在第19、20课，我还会具体讲解，到时候你可以参考下。）设计思想首先要说的是，虽然很多语言都内建语法支持面向对象编程，但它本质上是一种设计思想、方法，与语言细节无关，要点是**抽象**（Abstraction）和**封装**（Encapsulation）。掌握了这种代码之外的思考方式，就可以"高屋建瓴"，站在更高的维度上去设计程序，不会被语言、语法所限制。所以，即使是像 C这样"纯"面向过程的编程语言，也能够应用面向对象的思想，以 struct实现抽象和封装，得到良好的程序结构。面向对象编程的基本出发点是"对现实世界的模拟"，把问题中的实体抽象出来，封装为程序里的类和对象，这样就在计算机里为现实问题建立了一个"虚拟模型"。然后以这个模型为基础不断演化，继续抽象对象之间的关系和通信，再用更多的对象去描述、模拟......直到最后，就形成了一个由许多互相联系的对象构成的系统。把这个系统设计出来、用代码实现出来，就是"面向对象编程"了。不过，因为现实世界非常复杂，"面向对象编程"作为一种工程方法，是不可能完美模拟的，纯粹的面向对象也有一些缺陷，其中最明显的就是"继承"。"继承"的本意是重用代码，表述类型的从属关系（Is-A），但它却不能与现实完全对应，所以用起来就会出现很多意外情况。比如那个著名的长方形的例子。Rectangle 表示长方形，Square 继承Rectangle，表示正方形。现在问题就来了，这个关系在数学中是正确的，但表示为代码却不太正确。长方形可以用成员函数单独变更长宽，但正方形却不行，长和宽必须同时变更。还有那个同样著名的鸟类的例子。基类 Bird 有个 Fly方法，所有的鸟类都应该继承它。但企鹅、鸵鸟这样的鸟类却不会飞，实现它们就必须改写Fly 方法。 各种编程语言为此都加上了一些"补丁"，像 C++就有"多态""虚函数""重载"，虽然解决了"继承"的问题，但也使代码复杂化了，一定程度上扭曲了"面向对象"的本意。实现原则说了些"高大上"的理论，是不是有点犯迷糊？没关系，下面，我就在 C++里细化一下。就像我刚才说的，"面向对象编程"的关键点是"抽象"和"封装"，而"继承""多态"并不是核心，只能算是附加品。所以，我建议你在设计类的时候**尽量少用继承和虚函数**。特别的，如果完全没有继承关系，就可以让对象不必承受"父辈的重担"（父类成员、虚表等额外开销），轻装前行，更小更快。没有隐含的重用代码也会降低耦合度，让类更独立，更容易理解。还有，把"继承"切割出去之后，可以避免去记忆、实施那一大堆难懂的相关规则，比如public/protected/private继承方式的区别、多重继承、纯虚接口类、虚析构函数，还可以绕过动态转型、对象切片、函数重载等很多危险的陷阱，减少冗余代码，提高代码的健壮性。如果非要用继承不可，那么我觉得一定要**控制继承的层次**，用 UML画个类体系的示意图来辅助检查。如果继承深度超过三层，就说明有点"过度设计"了，需要考虑用组合关系替代继承关系，或者改用模板和泛型。![](Images/292d2cd603d348a0b17a99b1cbe086b4.png)savepage-src="https://static001.geekbang.org/resource/image/14/d5/145780476bd0beb148e5e130c2336ed5.jpg"}在设计类接口的时候，我们也要让类尽量简单、"短小精悍"，**只负责单一的功能**。如果很多功能混在了一起，出现了"万能类""意大利面条类"（有时候也叫 GodClass），就要应用设计模式、重构等知识，把大类拆分成多个各负其责的小类。我还看到过很多人有一种不好的习惯，就是喜欢在类内部定义一些嵌套类，美其名曰"高内聚"。但恰恰相反，这些内部类反而与上级类形成了强耦合关系，也是另一种形式的"万能类"。其实，这本来是名字空间该做的事情，用类来实现就有点"越权"了。正确的做法应该是，**定义一个新的名字空间，把内部类都"提"到外面，降低原来类的耦合度和复杂度**。编码准则有了这些实现原则，下面我再来讲几个编码时的细节，从安全和性能方面帮你改善类的代码。C++11新增了一个特殊的标识符"**final**"（注意，它不是关键字），把它用于类定义，就可以显式地禁用继承，防止其他人有意或者无意地产生派生类。无论是对人还是对编译器，效果都非常好，我建议你一定要积极使用。    class DemoClass final    // 禁止任何人继承我    { ... };在必须使用继承的场合，建议你**只使用 public 继承，避免使用virtual、protected**，因为它们会让父类与子类的关系变得难以捉摸，带来很多麻烦。当到达继承体系底层时，也要及时使用"final"，终止继承关系。    class Interface        // 接口类定义，没有final，可以被继承    { ... };               class Implement final : // 实现类，final禁止再被继承          public Interface    // 只用public继承    { ... };C++里类的四大函数你一定知道吧，它们是构造函数、析构函数、拷贝构造函数、拷贝赋值函数。C++11因为引入了右值（Rvalue）和转移（Move），又多出了两大函数：**转移构造函数**和**转移赋值函数**。所以，在现代 C++里，一个类总是会有六大基本函数：**三个构造**、**两个赋值**、**一个析构**。好在 C++编译器会自动为我们生成这些函数的默认实现，省去我们重复编写的时间和精力。但我建议，对于比较重要的构造函数和析构函数，应该用"**= default**"的形式，明确地告诉编译器（和代码阅读者）："应该实现这个函数，但我不想自己写。"这样编译器就得到了明确的指示，可以做更好的优化。    class DemoClass final     {    public:        DemoClass() = default;  // 明确告诉编译器，使用默认实现       ~DemoClass() = default;  // 明确告诉编译器，使用默认实现    };这种"= default"是 C++11新增的专门用于六大基本函数的用法，相似的，还有一种"**= delete**"的形式。它表示**明确地禁用某个函数形式**，而且不限于构造 /析构，可以用于任何函数（成员函数、自由函数）。比如说，如果你想要禁止对象拷贝，就可以用这种语法显式地把拷贝构造和拷贝赋值"delete"掉，让外界无法调用。    class DemoClass final     {    public:        DemoClass(const DemoClass&) = delete;              // 禁止拷贝构造        DemoClass& operator=(const DemoClass&) = delete;  // 禁止拷贝赋值    };因为 C++有隐式构造和隐式转型的规则，如果你的类里有单参数的构造函数，或者是转型操作符函数，为了防止意外的类型转换，保证安全，就要使用"**explicit**"将这些函数标记为"显式"。    class DemoClass final     {    public:        explicit DemoClass(const string_type& str)  // 显式单参构造函数        { ... }        explicit operator bool()                  // 显式转型为bool        { ... }    };常用技巧C++11 里还有很多能够让类更优雅的新特性，这里我从“投入产出比”的角度出发，挑出了三个我最喜欢的特性，给你介绍一下，让你不用花太多力气就能很好地改善代码质量。第一个是"**委托构造**"（delegatingconstructor）。如果你的类有多个不同形式的构造函数，为了初始化成员肯定会有大量的重复代码。为了避免重复，常见的做法是把公共的部分提取出来，放到一个init()函数里，然后构造函数再去调用。这种方法虽然可行，但**效率和可读性较差**，毕竟 init()不是真正的构造函数。在 C++11里，你就可以使用"委托构造"的新特性，一个构造函数直接调用另一个构造函数，把构造工作"委托"出去，既简单又高效。    class DemoDelegating final    {    private:        int a;                              // 成员变量    public:        DemoDelegating(int x) : a(x)        // 基本的构造函数        {}          DemoDelegating() :                 // 无参数的构造函数            DemoDelegating(0)               // 给出默认值，委托给第一个构造函数        {}          DemoDelegating(const string& s) : // 字符串参数构造函数            DemoDelegating(stoi(s))        // 转换成整数，再委托给第一个构造函数        {}      };第二个是"**成员变量初始化**"（In-class memberinitializer）。如果你的类有很多成员变量，那么在写构造函数的时候就比较麻烦，必须写出一长串的名字来逐个初始化，不仅不美观，更危险的是，容易"手抖"，遗漏成员，造成未初始化的隐患。而在 C++11里，你可以在类里声明变量的同时给它赋值，实现初始化，这样**不但简单清晰，也消除了隐患。**    class DemoInit final                  // 有很多成员变量的类    {    private:        int                 a = 0;        // 整数成员，赋值初始化        string              s = "hello";  // 字符串成员，赋值初始化        vector         v{1, 2, 3};   // 容器成员，使用花括号的初始化列表    public:        DemoInit() = default;             // 默认构造函数       ~DemoInit() = default;             // 默认析构函数    public:        DemoInit(int x) : a(x) {}         // 可以单独初始化成员，其他用默认值    };第三个是"**类型别名**"（Type Alias）。C++11 扩展了关键字 using 的用法，增加了 typedef的能力，可以定义类型别名。它的格式与 typedef正好相反，别名在左边，原名在右边，是标准的赋值形式，所以易写易读。    using uint_t = unsigned int;        // using别名    typedef unsigned int uint_t；      // 等价的typedef在写类的时候，我们经常会用到很多外部类型，比如标准库里的string、vector，还有其他的第三方库和自定义类型。这些名字通常都很长（特别是带上名字空间、模板参数），书写起来很不方便，这个时候我们就可以在类里面用using给它们起别名，不仅简化了名字，同时还能增强可读性。    class DemoClass final    {    public:        using this_type         = DemoClass;          // 给自己也起个别名        using kafka_conf_type   = KafkaConfig;        // 外部类起别名    public:        using string_type   = std::string;            // 字符串类型别名        using uint32_type   = uint32_t;              // 整数类型别名        using set_type      = std::set;          // 集合类型别名        using vector_type   = std::vector;// 容器类型别名    private:        string_type     m_name  = "tom";              // 使用类型别名声明变量        uint32_type     m_age   = 23;                  // 使用类型别名声明变量        set_type        m_books;                      // 使用类型别名声明变量    private:        kafka_conf_type m_conf;                       // 使用类型别名声明变量    };类型别名不仅能够让代码规范整齐，而且因为引入了这个"语法层面的宏定义"，将来在维护时还可以随意改换成其他的类型。比如，把字符串改成string_view（C++17 里的字符串只读视图），把集合类型改成unordered_set，只要变动别名定义就行了，原代码不需要做任何改动。小结今天我们谈了"面向对象编程"，这节课的内容也比较多，我划一下重点。1.       "面向对象编程"是一种设计思想，要点是"抽象"和"封装"，"继承""多态"是衍生出的特性，不完全符合现实世界。        2.       在 C++    里应当少用继承和虚函数，降低对象的成本，绕过那些难懂易错的陷阱。        3.       使用特殊标识符"final"可以禁止类被继承，简化类的层次关系。        4.       类有六大基本函数，对于重要的构造 / 析构函数，可以使用"=    default"来显式要求编译器使用默认实现。        5.       "委托构造"和"成员变量初始化"特性可以让创建对象的工作更加轻松。        6.       使用 using 或 typedef    可以为类型起别名，既能够简化代码，还能够适应将来的变化。        所谓"仁者见仁智者见智"，今天我讲的也只能算是我自己的经验、体会。到底要怎么用，你还是要看自己的实际情况，千万不要完全照搬。课下作业这次的课下作业时间，我给你留两个思考题：1.       你对"面向对象编程"有哪些认识，是否赞同这节课的观点？（希望你大胆地说出来，如果意见有分歧，那也很正常，我们一起讨论。）        2.       你觉得应用这节课讲到的准则和技巧能否写出一个"好"的类，还缺什么吗？        欢迎你在留言区写下你的思考和答案，如果觉得今天的内容对你有所帮助，也欢迎分享给你的朋友。我们下节课见。![](Images/357e4b69597dfef228bba8fa61b291fd.png)savepage-src="https://static001.geekbang.org/resource/image/67/b3/6739782414607164bdbe20fca7fd5fb3.jpg"}
# 06 \| auto/decltype：为什么要有自动类型推导？你好，我是 Chrono。前两周我们从宏观的层面上重新认识了C++，从今天开始，我们将进入一个新的"语言特性"单元，"下沉"到微观的层面去观察C++，一起去见一些老朋友、新面孔，比如const、exception、lambda。这次要说的，就是 C++11里引入的一个很重要的语言特性：自动类型推导。自动类型推导如果你有过一些 C++ 的编程经验，了解过C++11，那就一定听说过"**自动类型推导**"（auto typededuction）。它其实是一个非常"老"的特性，C++ 之父 Bjarne Stroustrup（B·S ) 早在C++ 诞生之初就设计并实现了它，但因为与早期 C语言的语义有冲突，所以被"雪藏"了近三十年。直到 C99消除了兼容性问题，C++11才让它再度登场亮相。那为什么要重新引入这个"老特性"呢？为什么非要有"自动类型推导"呢？我觉得，你可以先从字面上去理解，把这个词分解成三个部分："自动""类型"和"推导"。1.  "自动"就是让计算机去做，而不是人去做，相对的是"手动"。        2.  "类型"指的是操作目标，出来的是编译阶段的类型，而不是数值。        3.  "推导"就是演算、运算，把隐含的值给算出来。        好，我们来看一看"自动类型推导"之外的其他几种排列组合，通过对比的方式来帮你理解它。像计算"a = 1 + 1"，你可以在写代码的时候直接填上2，这就是"手动数值推导"。你也可以"偷懒"，只写上表达式，让电脑在运行时自己算，这就是"自动数值推导"。"数值推导"对于人和计算机来说都不算什么难事，所以手动和自动的区别不大，只有快慢的差异。但"类型推导"就不同了。因为 C++是一种静态强类型的语言，任何变量都要有一个确定的类型，否则就不能用。在"自动类型推导"出现之前，我们写代码时只能"手动推导"，也就是说，在声明变量的时候，必须要明确地给出类型。这在变量类型简单的时候还好说，比如int、double，但在泛型编程的时候，麻烦就来了。因为泛型编程里会有很多模板参数，有的类型还有内部子类型，一下子就把C++原本简洁的类型体系给搞复杂了，这就迫使我们去和编译器"斗智斗勇"，只有写对了类型，编译器才会"放行"（编译通过）。    int       i = 0;            // 整数变量，类型很容易知道    double    x = 1.0;          // 浮点数变量，类型很容易知道    std::string str = "hello";  // 字符串变量，有了名字空间，麻烦了一点    std::map m = // 关联数组，名字空间加模板参数，很麻烦            {{1,"a"}, {2,"b"}};    // 使用初始化列表的形式    std::map::const_iterator // 内部子类型，超级麻烦    iter = m.begin();    ？？？ = bind1st(std::less(), 2);  // 根本写不出来虽然你可以用 typedef 或者 using来简化类型名，部分减轻打字的负担，但关键的"手动推导"问题还是没有得到解决，还是要去翻看类型定义，找到正确的声明。这时，C++的静态强类型的优势反而成为了劣势，阻碍了程序员的工作，降低了开发效率。其实编译器是知道（而且也必须知道）这些类型的，但它却没有办法直接告诉你，这就很尴尬了。一边是急切地想知道答案，而另一边却只给判个对错，至于怎么错了、什么是正确答案，"打死了也不说"。但有了"自动类型推导"，问题就迎刃而解了。这就像是在编译器紧闭的大门上开了道小口子，你跟它说一声，它就递过来张小纸条，具体是什么不重要，重要的是里面存了我们想要的类型。这个"小口子"就是关键字 **auto**，在代码里的作用像是个"占位符"（placeholder）。写上它，你就可以让编译器去自动"填上"正确的类型，既省力又省心。    auto  i = 0;          // 自动推导为int类型    auto  x = 1.0;        // 自动推导为double类型    auto  str = "hello";  // 自动推导为const char [6]类型    std::map m = {{1,"a"}, {2,"b"}};  // 自动推导不出来    auto  iter = m.begin();  // 自动推导为map内部的迭代器类型    auto  f = bind1st(std::less(), 2);  // 自动推导出类型，具体是啥不知道不过需要注意的是，因为 C++太复杂，"自动类型推导"有时候可能失效，给不出你想要的结果。比如，在上面的这段代码里，就把字符串的类型推导成了"constchar\[6\]"而不是"std::string"。而有的时候，编译器也理解不了代码的意思，推导不出恰当的类型，还得你自己"亲力亲为"。在这个示例里，你还可以直观感觉到 auto让代码干净整齐了很多，不用去写那些复杂的模板参数了。但如果你把"自动类型推导"理解为仅仅是简化代码、少打几个字，那就实在是浪费了C++ 标准委员会的一番苦心。**除了简化代码，auto还避免了对类型的"硬编码"**，也就是说变量类型不是"写死"的，而是能够"自动"适应表达式的类型。比如，你把map 改为unordered_map，那么后面的代码都不用动。这个效果和类型别名（第 5 讲）有点像，但你不需要写出 typedef或者 using，全由 auto"代劳"。另外，你还应该认识到，"自动类型推导"实际上和"attribute"一样（第 4 讲slate-object="inline"），是编译阶段的特殊指令，指示编译器去计算类型。所以，它在泛型编程和模板元编程里还有更多的用处，后面我会陆续讲到。认识 auto刚才说了，auto有时候会不如你设想的那样工作，因此在使用的时候，有一些需要特别注意的地方，下面我就给你捋一捋。首先，你要知道，auto的"自动推导"能力只能用在"**初始化**"的场合。具体来说，就是**赋值初始化**或者**花括号初始化**（初始化列表、Initializerlist），变量右边必须要有一个表达式（简单、复杂都可以）。这样你才能在左边放上auto，编译器才能找到表达式，帮你自动计算类型。如果不是初始化的形式，只是"纯"变量声明，那就无法使用auto。因为这个时候没有表达式可以让 auto去推导。     auto x = 0L;    // 自动推导为long    auto y = &x;    // 自动推导为long*    auto z {&x};    // 自动推导为long*     auto err;       // 错误，没有赋值表达式，不知道是什么类型这里还有一个特殊情况，在类成员变量初始化的时候（第 5 讲），目前的 C++ 标准不允许使用 auto推导类型（但我个人觉得其实没有必要，也许以后会放开吧）。所以，在类里你还是要老老实实地去"手动推导类型"。    class X final    {        auto a = 10;  // 错误，类里不能使用auto推导类型    };知道了应用场合，你还需要了解 auto的推导规则，保证它能够按照你的意思去工作。虽然标准里规定得很复杂、很细致，但我总结出了两条简单的规则，基本上够用了：1.  **auto    总是推导出"值类型"，绝不会是"引用"；**        2.  **auto 可以附加上 const、volatile、\*、&    这样的类型修饰符，得到新的类型。**        下面我举几个例子，你一看就能明白：    auto        x = 10L;    // auto推导为long，x是long    auto&       x1 = x;      // auto推导为long，x1是long&    auto*       x2 = &x;    // auto推导为long，x2是long*    const auto& x3 = x;        // auto推导为long，x3是const long&    auto        x4 = &x3;    // auto推导为const long*，x4是const long*认识 decltype前面我都在说 auto，其实，C++ 的“自动类型推导”还有另外一个关键字：decltype。刚才你也看到了，auto只能用于"初始化"，而这种"**向编译器索取类型**"的能力非常有价值，把它限制在这么小的场合，实在是有点"屈才"了。"自动类型推导"要求必须从表达式推导，那在没有表达式的时候，该怎么办呢？其实解决思路也很简单，就是"自己动手，丰衣足食"，自己带上表达式，这样就走到哪里都不怕了。decltype 的形式很像函数，后面的圆括号里就是可用于计算类型的表达式（和sizeof 有点类似），其他方面就和 auto 一样了，也能加上 const、\*、&来修饰。 但因为它已经自带表达式，所以不需要变量后面再有表达式，也就是说可以直接声明变量。    int x = 0;          // 整型变量    decltype(x)     x1;      // 推导为int，x1是int    decltype(x)&    x2 = x;    // 推导为int，x2是int&，引用必须赋值    decltype(x)*    x3;      // 推导为int，x3是int*    decltype(&x)    x4;      // 推导为int*，x4是int*    decltype(&x)*   x5;      // 推导为int*，x5是int**    decltype(x2)    x6 = x2;  // 推导为int&，x6是int&，引用必须赋值把 decltype 和 auto比较一下，简单来看，好像就是把表达式改到了左边而已，但实际上，在推导规则上，它们有一点细微且重要的区别：**decltype不仅能够推导出值类型，还能够推导出引用类型，也就是表达式的"原始类型"**。在示例代码中，我们可以看到，除了加上 \* 和 & 修饰，decltype还可以直接从一个引用类型的变量推导出引用类型，而 auto就会把引用去掉，推导出值类型。所以，你完全可以把 decltype看成是一个真正的类型名，用在变量声明、函数参数 /返回值、模板参数等任何类型能出现的地方，只不过这个类型是在编译阶段通过表达式"计算"得到的。如果不信的话，你可以用 using类型别名来试一试。    using int_ptr = decltype(&x);    // int *    using int_ref = decltype(x)&;    // int &既然 decltype 类型推导更精确，那是不是可以替代 auto了呢？ 实际上，它也有个缺点，就是写起来略麻烦，特别在用于初始化的时候，表达式要重复两次（左边的类型计算，右边的初始化），把简化代码的优势完全给抵消了。所以，C++14 就又增加了一个"**decltype(auto)**"的形式，既可以精确推导类型，又能像 auto一样方便使用。    int x = 0;            // 整型变量    decltype(auto)     x1 = (x);  // 推导为int&，因为(expr)是引用类型    decltype(auto)     x2 = &x;   // 推导为int*    decltype(auto)     x3 = x1;   // 推导为int&使用 auto/decltype现在，我已经讲完了“自动类型推导”的两个关键字：auto 和 decltype，那么，该怎么用好它们呢？我觉得，因为 auto写法简单，推导规则也比较好理解，所以，**在变量声明时应该尽量多用auto**。前面已经举了不少例子，这里就不再重复了。auto还有一个"最佳实践"，就是"**range-basedfor**"，不需要关心容器元素类型、迭代器返回值和首末位置，就能非常轻松地完成遍历操作。不过，为了保证效率，最好使用"constauto&"或者"auto&"。     vector v = {2,3,5,7,11};  // vector顺序容器     for(const auto& i : v) {      // 常引用方式访问元素，避免拷贝代价         cout  s = {1,2,3};        return s;    }再来看 decltype怎么用最合适。它是 auto的高级形式，更侧重于编译阶段的类型计算，所以常用在泛型编程里，获取各种类型，配合typedef 或者 using会更加方便。当你感觉"这里我需要一个特殊类型"的时候，选它就对了。比如说，定义函数指针在 C++里一直是个比较头疼的问题，因为传统的写法实在是太怪异了。但现在就简单了，你只要手里有一个函数，就可以用decltype 很容易得到指针类型。    // UNIX信号函数的原型，看着就让人晕，你能手写出函数指针吗？    void (*signal(int signo, void (*func)(int)))(int)    // 使用decltype可以轻松得到函数指针类型    using sig_func_ptr_t = decltype(&signal) ;在定义类的时候，因为 auto 被禁用了，所以这也是 decltype可以"显身手"的地方。它可以搭配别名任意定义类型，再应用到成员变量、成员函数上，变通地实现auto 的功能。    class DemoClass final    {    public:        using set_type      = std::set;  // 集合类型别名    private:        set_type      m_set;                   // 使用别名定义成员变量        // 使用decltype计算表达式的类型，定义别名        using iter_type = decltype(m_set.begin());        iter_type     m_pos;                   // 类型别名定义成员变量    };小结好了，今天我介绍了 C++ 里的“自动类型推导”，简单小结一下今天的内容。1.       "自动类型推导"是给编译器下的指令，让编译器去计算表达式的类型，然后返回给程序员。        2.       auto    用于初始化时的类型推导，总是"值类型"，也可以加上修饰符产生新类型。它的规则比较好理解，用法也简单，应该积极使用。        3.       decltype    使用类似函数调用的形式计算表达式的类型，能够用在任意场合，因为它就是一个编译阶段的类型。        4.       decltype    能够推导出表达式的精确类型，但写起来比较麻烦，在初始化时可以采用    decltype(auto) 的简化形式。        5.       因为 auto 和 decltype    不是"硬编码"的类型，所以用好它们可以让代码更清晰，减少后期维护的成本。        课下作业最后是课下作业时间，给你留两个思考题：1.       auto 和 decltype    虽然很方便，但用多了也确实会"隐藏"真正的类型，增加阅读时的理解难度，你觉得这算是缺点吗？是否有办法克服或者缓解？        2.       说一下你对 auto 和 decltype    的认识。你认为，两者有哪些区别呢？（推导规则、应用场合等）        欢迎你在留言区写下你的思考和答案，如果觉得今天的内容对你有所帮助，也欢迎分享给你的朋友，我们下节课见。![](Images/20b264b5cb27966617a15033aa1279f0.png)savepage-src="https://static001.geekbang.org/resource/image/6e/14/6ec0c53ee9917795c0e2a494cfe70014.png"}