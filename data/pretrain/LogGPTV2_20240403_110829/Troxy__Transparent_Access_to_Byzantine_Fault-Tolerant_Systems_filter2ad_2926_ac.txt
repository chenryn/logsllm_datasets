req
rep
pp
cmt0
cmt2
rep0
rep1
rep2
rep
(a) Message ﬂow in Hybster.
(b) Message ﬂow in Troxy-backed Hybster when
the client is connected to the leader replica.
(c) Message ﬂow in Troxy-backed Hybster when
the client is connected to a follower replica.
Fig. 5. Comparison of the message ﬂows in Hybster and Troxy-backed Hybster.
To enforce the validity of enclaves, Intel provides a remote
attestation service [9]. In a nutshell, a hash of the memory
pages of the enclave is securely computed and sent to the
remote attestation service so that the user can obtain a proof
that the enclave has been initialized correctly. Once the enclave
has been correctly attested it is possible to provision it. Any
cryptographic key and secret, such as the private key used by
Troxy to initialize a secure connection with the clients, can be
securely sent to the enclave during the provisioning phase.
The enclave code and data is stored in the Enclave Page
Cache (EPC), a speciﬁc region of memory protected from
untrusted accesses. In the current implementation of Intel SGX,
this memory area has a maximum size of 128MB. Accessing
memory beyond the size of the EPC results in costly paging, as
the pages need to be encrypted and integrity-protected before
being evicted to main memory. As this operation incurs a high
performance overhead [31], we limit memory allocations to
keep the memory footprint as small as possible. Furthermore,
to avoid additional ocalls and paging [32], the Troxy can store
data in an encrypted manner outside the enclave. When it needs
to be accessed, it is directly read from the untrusted memory
and validated by comparing it against a hash securely stored
inside the Troxy.
Finally, Troxy provides bidirectional TLS authentication to
all messages exchanged between clients and replicas. For this
purpose, Troxy uses the TaLoS [33] library, which exposes a
TLS interface to existing application while securely executing
the TLS logic inside an Intel SGX enclave. Note that we run
it in a completely encapsulated manner: there are no ecalls nor
ocalls between TaLoS and the untrusted environment.
B. Troxy-backed Hybster
To provide fault tolerance, our prototype implementation
relies on Hybster [13], a BFT replication protocol that is based
on a hybrid fault model and therefore only requires 2f + 1 repli-
cas to tolerate f Byzantine faults. Hybster is implemented
in Java and uses Intel SGX to realize a trusted susbsystem
for message authentication. It achieves high performance via
parallelization, where the performance scales well along with
the number of NICs and CPU cores. The trusted subsystem
of Hybster is also used by Troxy for trusted authentication
upon internally exchanged messages during the ordering phase.
In our implementation the interaction between the protocol
running in the untrusted part of the replica and the SGX enclave
is handled via the Java Native Interface (JNI).
Hybster is a leader-based BFT protocol: a special node is in
charge of proposing an ordering on the requests received by
the clients. Figure 5 shows the message ﬂow in the resulting
Troxy-backed system. Compared with the original Hybster (see
Figure 5a), introducing the Troxy adds one message delay
for a client that is connected to Hybster’s leader replica (see
Figure 5b). In this extra phase, the corresponding Troxy collects
and compares the replies to the client’s request in order to
determine the correct result. For clients connected to servers
hosting Hybster followers, an additional phase is necessary to
transmit the request to the leader, as only the leader is able
to initiate the agreement process for requests (see Figure 5c).
Note that for a setting in which the replicas of a system
are hosted in different fault domains inside the same data
center (e.g., different racks with independent power and network
supply [34]), the additional messages only have a minor impact
on the overall latency experienced by the client.
Apart from highlighting individual message ﬂows, Figure 5
also illustrates another important difference between traditional
BFT systems and a Troxy-backed BFT system: with the Troxy
performing reply voting at the server side, the client receives
only a single reply per request. In practice, this approach
has several key advantages: First, in a typical setting where
clients are connected to the service over a wide-area network,
less data has to be sent over long-distance links, which
is especially beneﬁcial for low-bandwidth clients. Second,
during periods of unstable (wide-area) network conditions it
improves the response time of the service due to the latency
experienced by the client no longer depending on the arrival
of the f + 1 slowest (normal request) or 2f + 1 slowest (read
optimization) matching reply. Third, and most important, it
makes the BFT replication system transparent to clients.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:31:39 UTC from IEEE Xplore.  Restrictions apply. 
65
VI. EVALUATION
C. Microbenchmark
In this section we evaluate the performance of Troxy
compared to Hybster using both microbenchmarks and an
HTTP service. The results show that: (1) For ordered small-
payload messages in a local network, Troxy has an overhead of
at most 43% due to its extra communication steps (see Figure 5)
and trusted environment transitions. (2) For larger messages
with network delay, Troxy improves the performance compared
to Hybster by at most 70%. (3) For read-heavy workloads with
network delay, the fast-read cache optimization improves the
throughput by 130% even in the presence of conﬂicting write
requests. (4) When considering an HTTP service with network
delay, Troxy can almost hide the replication cost, allowing
clients to observe similar latency as for a non-replicated service.
A. Experimental Setup
The measurements are conducted on a cluster of ﬁve identical
machines connected via four 1 Gbps Ethernet NICs. Each
machine is equipped with an SGX-capable Intel Core i7-6700
quad-core processor running at 3.4 GHz with Hyper-Threading
activated as well as 24 GB of memory. Three machines are
dedicated to the replicas (hence we consider f = 1 faults)
while the two remaining ones are running as clients. All the
machines are running 64-bit Ubuntu 16.04 with a Linux kernel
4.4.0, OpenJDK 1.8 and the Intel SGX SDK v1.9. We compare
the performance of our Troxy-backed Hybster variant with the
original Hybster protocol, noted as BL (for baseline).
B. Security Analysis
In this section we analyse the security of Troxy.
Performance attacks: A malicious replica could try to return
old cache entries in the case of the fast-read cache optimization.
As a result the fast read would fail, slowing down the protocol.
As discussed in Section IV-B, Troxy selects f random replicas
to reply to a fast-read query and monitors the cache miss ratio
to address such attacks.
Side-channel attacks: We consider side-channel attacks out
of the scope of this paper. However, Troxy can implement
existing technics to limit side-channel attacks inside an SGX
enclave [35], [36], [37].
Bypassing Troxy: A malicious replica could bypass Troxy
in order to break the safety of the system, by directly
communicating with the clients. To prevent this attack the
clients and Troxy initiate secure connections using the TLS
protocol. The session keys are securely stored inside the Troxy,
thus the malicious replica cannot forge correct messages.
Interface attacks: A malicious replica could attack the
enclave interface in order to get access to the secrets stored
inside the Troxy. As discussed in Section V, the enclave
interface has been hardened to prevent such attacks.
Denial-of-Service and ﬂooding: A malicious replica could
decide to perform a Denial-of-Service attack, not executing
the Troxy or following its protocol, or at the opposite ﬂood
the correct replicas or clients with invalid messages. In all
these cases the goal of the malicious replica is to render the
system not usable. Troxy can leverage existing techniques [38]
to prevent such attacks.
We created a microbenchmark to evaluate the full capacity
of Troxy and to investigate the overhead of (1) relocating the
traditional client-side library to the server side and (2) using
the trusted subsystem for protection of the Troxy. A conﬁgured
number of clients are created to constantly issue asynchronous
requests and measure the average throughput and latency for
60 seconds. The ﬁnal results are the average values of three
runs. Batching is not used as it is an orthogonal approach that
has independent inﬂuence to the results.
Secure socket connections are applied to the client-to-replica
communication for both the baseline and Troxy, while the
replica-to-replica communication keeps using plain sockets and
HMACs for message authentication. Clients only connect to the
leader in the baseline system, while Troxy allows connections
to any replica. We created a simple service that accepts requests
and generates a reply message of conﬁgurable size. Read and
write requests can be distinguished by their operation types.
We ran experiments in three different scenarios, where (1) write
requests are totally ordered; (2) read optimizations are applied
to handle read-only requests, and (3) concurrent write requests
cause conﬂicting reads, which leads to the traditional ordering
of conﬂicting read requests.
In addition to the local network conﬁguration, we also
simulate a wide-area network by adding 100± 20 ms (in a
normal distribution model) delay to the NICs of the client
machines. We consider this as the typical usage scenario of
Troxy, that is, data-center-hosted services that are accessed by
remote legacy clients.
1) Totally Ordered Requests: In this scenario, we consider
write requests of different sizes: 256 B, 1 KB, 4 KB and 8 KB.
The size of the reply is always 10 B. Two implementations
of Troxy in C/C++ are compared against the baseline: ctroxy,
running in the untrusted environment without SGX, indicates
the impact of using JNI; while etroxy, running inside an enclave,
adds the overhead of utilizing the trusted subsystem.
Figure 6 shows the measurement result for handling write
requests in the local network. With a small request payload
size (256 B), etroxy shows about 43% of performance loss
due to the transitions between the trusted and untrusted
environments as well as the extra steps in processing ordered
requests (see Figure 5). More precisely, by considering the
performance of ctroxy (without SGX), half of the performance
loss in etroxy is caused by using the trusted subsystem. When
the payload size increases, ctroxy and etroxy start to provide
similar performance and etroxy reaches the baseline at 8 KB.
This is due to the fact that authenticating messages with large
payload is faster in C/C++ than it is in Java.
We also measure the performance with a network delay in
between the clients and replicas. As illustrated in Figure 7,
the server-side reply voter brings a huge advantage to Troxy.
In this case, for each request, the clients wait for only one
reply that is affected by the delay instead of f + 1 replies. This
advantage applies to different request payload sizes, and leads
to up to 60% performance gain.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:31:39 UTC from IEEE Xplore.  Restrictions apply. 
66
)
s
m
(
y
c
n
e
t
a
L
)
s
m
(
y
c
n
e
t
a
L
400
350
300
250
200
150
100
50
0
800
700
600
500
400
300
200
100
0
BL-256B/10B-w
ctroxy-256B/10B-w
etroxy-256B/10B-w
40 60 80 100 120 140 160 180 200 220 240
Throughput (1,000 requests per second)
BL-4KB/10B-w
ctroxy-4KB/10B-w
etroxy-4KB/10B-w
25
30
35
40
45
50
Throughput (1,000 requests per second)
400
350
300
250
200
150
100
50
0
800
700
600
500
400
300
200
100
0
BL-1KB/10B-w
ctroxy-1KB/10B-w
etroxy-1KB/10B-w
40
50
60
70
80
90 100 110 120 130
Throughput (1,000 requests per second)
BL-8KB/10B-w
ctroxy-8KB/10B-w
etroxy-8KB/10B-w
16
24
14
Throughput (1,000 requests per second)
22
18
20
)
s
m
(
y
c
n
e
t
a
L
)
s
m
(
y
c
n
e
t
a
L
600
500
400
300
200
100
0
600
500
400
300
200
100
0
BL-256B/10B-la-w
ctroxy-256B/10B-la-w
etroxy-256B/10B-la-w
20
0
Throughput (1,000 requests per second)
100
120
40
60
80
BL-4KB/10B-la-w
ctroxy-4KB/10B-la-w
etroxy-4KB/10B-la-w
5
40
0
Throughput (1,000 requests per second)
10
15
20
25
30
35
BL-1KB/10B-la-w
ctroxy-1KB/10B-la-w
etroxy-1KB/10B-la-w
10 20 30 40 50 60 70 80 90
0
Throughput (1,000 requests per second)
BL-8KB/10B-la-w
ctroxy-8KB/10B-la-w
etroxy-8KB/10B-la-w
600
500
400
300
200
100
0
1,000
800