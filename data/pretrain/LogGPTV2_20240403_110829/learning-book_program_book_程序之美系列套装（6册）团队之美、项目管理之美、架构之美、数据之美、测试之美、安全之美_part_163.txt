的环境中，机器所有的资源都受游戏程序控制，程序的问题也限于
单个用户玩游戏的情况（实际上，缺陷或奇怪的行为常常会被认为
是游戏本身逻辑的一部分）。
这些游戏和编写、出品、扩展它们的公司，都属于娱乐行业。编写
游戏的团队由一个出品人领导，有剧本和背景故事。游戏的目标是
刺激、打动人，最重要的一点，要好玩。可靠性很好，但不一定必
需。可扩展性是游戏的特性，让游戏在升级时能够加人新的故事情
915
---
## Page 917
节和主题，但可扩展性不是代码的特性，不必让代码能以新的、不
同的方式使用。在线游戏和虚拟世界的兴起将这种文化带入了一个
新的环境，在这个环境中，需求与企业应用并发者所面对的类似。
多个用户通过网络在服务器上交互时，由于一个玩家的意外动作而
导致的服务器崩溃将影响许多其他玩家。随着这些世界发展出自己
的经济（有些经济与现实世界的经济有关系），在线世界的稳定性
和一致性就超出了一个游戏的要求。随着这些世界中玩家或居民的
人数达到百万级，伸缩的能力就成为了任何架构的首要需求。
Darkstar项目（本章后面将简称为Darkstar）是对这些游戏和虚拟世
界创建者的需求挑战的回答。这个项目由Sun公司实验室的一个研
究小组承担，它将在架构的伸缩性领域不断探索。这个项目特别有
趣之处在于，它是针对MIMO和虚拟世界的创建者，这些程序员与
我们（作为系统设计著）所熟悉的那些程序员相比，有着非常不同
的需求。得到的架构看起来似乎很眼熟，但如果你仔细查看，会发
现它的不同之处，它与你的经验有所不同。得到的架构有着属于它
自己的美丽，同时它也是一堂实践课，说明了不同的需求如何改变
你所想到的构建系统的方式。
3.2背景
像一座建筑或一个城市的物理架构一样，系统的架构必须适应环
境，利用该架构创建的工件将存在于该环境之中。对于物理架构来
说，这个环境包括工作的历史环境、它所处位置的气候、本地工人
的技能、可以获得的建筑材料，以及建筑的使用意图。对于软件架
构，这个环境不仅包括使用该架构的应用程序，也包括那些要使用
该架构的程序员，以及由此受到的系统约束。在创建Darkstar架构
时，我们意识到的第一件事就是所有针对伸缩性而设计的架构都
需要包含多台机器。我们不清楚，就算是最大的大主机系统是否能
够满足今天的一些在线游戏的要求（例如《魔兽世界》，据报道它
有500万注册用户，几十万的同时在线用户）。就算单台机器能够
处理这种负载，我们也不能在一开始就假定游戏会取得如此成功，
需要这样的硬件投资。这在经济上是不可行的。这种应用需要能够
从很小的系统并始，然后随着用户数的增长而增加处理能力，最后
随着大家对游戏兴趣的衰退而降低处理能力。这与分布系统的特点
相符，在分布式系统中，我们可以随着请求增长而添加（合理的
小）机器，当请求下降时移走机器。所以我们从一开始就知道，总
体架构必须是一个分布式系统。
916
---
## Page 918
我们也知道系统利用了芯片架构的当前趋势。MMO和虚拟世界
（在较小程度上）曾经针对伸缩性利用过摩尔定律。随着处理器的
速度倍增，可以创造的世界会在复杂度、丰富程度和互动性方面倍
增。没有其他计算领域像游戏世界这样探索过处理器速度的增长所
带来的好处。为游戏而设计的个人计算机总是将CPU速度、内存和
图形性能推向极致。游戏机更激进地将这些方面推向极致，它们包
含的图形系统远远超过了高端工作站上的图形系统，整个机器完全
是为了游戏玩家的特殊需要而打造的。
芯片演进方面最近的变化是从不断增加的时钟速度转为实现多核处
理器，这已经对游戏中能做的事情产生了影响。新芯片的设计目标
不是将一件事做得更快，而是同时做多件事。如果在芯片上运行的
多项任务实际上可以同时执行，那么在芯片层面上引入并发执行将
带来更好的总体性能。在不改变时钟速度的情况下，4核的芯片应
该能比单核的芯片多做3倍的事情。实际上，这种增长不是呈线性
的，因为系统的其他一些部分没有以同样的方式实现并发。但是可
以通过并发来实现系统总体性能的增长，而且制造这种并发的芯片
比制造增加时钟速度的芯片要容易得多。
基于这一事实，MMO和虚拟世界应该是多核芯片和分布式系统的
理想候选者。在MIMO或虚拟世界中发生的大多数事情就像在真实
世界中发生的大多数事情一样，与该世界中发生的其他事情是无关
的。玩家继续他们的搜索或装饰他们的房间。他们与怪物交战或设
计表服。即使他们与该世界中的另一个玩家或居民发生交互，也只
是与该世界的很少一部分居民发生交互。这正是令人为滩的并行计
算任务的特点，也正是多核和多机系统应该擅长处理的那种任务。
尽管这些系统中的任务的并行度让人为滩，但为这样的系统编程的
程序员却没有接受过分布式计算或并发编程方面的训练，也没有这
方面的经验。这是极为微妙的领域，即使是在这个领域接受过训练
的人和对这些技术相当有经验的人也会感到困难。要让大多数游戏
程序员来开发高度并发的、分布式游戏服务器，就是要求他们做超
出自己的专长和经验的事。
3.2.1首要目标
这样的背景为我们确立了该架构的首要目标。对伸缩性的需求表
明，系统应该是分布式的、并发的，但我们需要为游戏开发者提供
简单得多的编程模型。简而言之，目标就是游戏程序员应该把该系
917
---
## Page 919
统视为一台单机，运行着一个线程，所有允许部署到多线程和多计
算机上的机制都应该由Darkstar项目的基础设施来考虑。
在一般的情况下，对应用程序隐藏分布式和并发是不可能的。但
MIMO和虚拟世界不是一般的情况。我们试图实现的这种隐藏，其
代价就是必需一种非常特别的、严格限制的编程模型。幸运的是，
这种模型恰好非常适合游戏服务器和虚拟世界已经采用的编程方
式。Darkstar项目要求的一般编程模型是反应式的，在这种编程模
型中，游戏的服务器端写成了事件监听器，监听客户端生成的事件
（客户端就是游戏玩家使用的机器，通常是一台PC或游戏机）。如
果检测到事件，游戏服务器就应该生成一项任务，这个任务是一个
短期的计算序列，包括操作虚拟世界中的信息，并与最初生成事件
的客户端或其他一些客户端进行通信。任务也可以由游戏服务器自
已生成，要么是响应某些内部的变化，要么是周期性地根据时间来
生成任务。在这种情况下，游戏服务器可以在游戏或虚拟世界中生
成一些角色，这些角色是不受外部玩家控制的。
这种编程模型非常适合游戏和虚拟世界，但它也应用于一些企业级
的架构中，如J2EE和Web服务。之所以需要创建一个不同于这些企
业计算机制的架构，是因为MIMO和虚拟世界存在的环境非常不一
样。这种环境几乎刚好和经典企业环境相反，这意味着如果你接受
过企业环境方面的训练，你知道的所有事情在这个新世界中几乎都
是错的。
经典的企业环境可以描述为一个“瘦”客户端连接到一个“胖"服务器
（这个服务器文常常连接到一个更“胖"的数据库服务器）。服务器
将保存客户端需要的绝大部分信息，在最理想的情况下，客户端内
存不多，没有自己的硬盘，它是服务器的一个称职的显示设备，绝
大多数真正的工作在服务器上完成。
[L].在提到Darkstar项目的架构开发时，我通常会说“我们"做了什
么，而不是“我”做了什么。这不仅是编辑意义上的“我们”。该架构
的设计是一个协作项目，由JeffreyKesselman、SethProctor和James
Megquier发起，并经过Seth、James、Tim Blackman、AnnWollrath、
JaneLoizeaux和我的努力发展到现在的状态。
3.2.2游戏世界
918
---
## Page 920
MIMO和虚拟世界的环境始于一个非常胖的客户端：它通常是顶级
的PC、具有最强劲的CPU、很大的内存，以及本身计算能力就很强
的显卡。它也可以是一台游戏机，专门为图形密集的、高度交互的
任务而设计。只要有可能，数据就会存放在这些客户端，特别是那
些不会改变的信息，如地理信息、材质贴图和规则集。服务器保持
尽可能的简单，通常只保存非常抽象的世界表示和其世界中的实体
的表示。而且，服务器的设计目标是尽可能少地进行计算。绝大部
分的计算留给了客户端。服务器的真正工作是保存共享的世界真实
状态，确保不同客户端对世界的看法差异可以根据需要得到纠正。
真实状态需要由服务器来保存，因为控制客户端的玩家很有兴趣让
他们的表现变成最强，所以可能会受到诱惑，根据他们的喜好修改
共享的真实（如果他们可以）。在一般情况下，如果有可能，玩家
就会作，所以服务器必须是共享真实的最终来源。
MIMO和虚拟世界的数据访问模式也和企业中看到的情况有着很大
的区别。企业中的一般经验法则是90%的数据访问都是只读的，大
多数任务会读取大量数据，然后再改写少量数据。在MIMO和虚拟
世界的环境中，大多数任务只访问服务器上少量的状态数据，但在
它们访问的数据中，大约一半会被改写。
3.2.3延迟是敌人
但是，这两种环境中最大的不同要追溯到用户所做的事情的不同。
在企业环境中，目标是管理业务，如果总吞吐量得到改进，在处理
中有一点延迟是可以接受的。在MIMO和虚拟世界的环境中，目标
是并心，而延迟是并心的敌人。所以MMO或虚拟世界的基础设施
需要围绕着尽可能限定延迟的需求来设计，即使以吞吐量为代价也
在所不惜。
在线游戏和虚拟世界显然已经找到了办法来实现伸缩性，以应对数
量巨大的用户。目前的方法可以分成两大类。第一类实质上是基于
地理位置来实现的。游戏设计成包含一组不同的区域，每个区域运
行在一台服务器上。它可能是虚拟世界的一个岛或房间，也可能是
在线游戏中的一个小镇或山谷。游戏设计试图让每个区域无关，限
定地理区域的大小，这样服务器不会因太多用户进入这个区域而拥
塞。在实践中，这样的区域常常能实现自我限制，因为当服务拥塞
时，游戏就会变得响应比较慢，趣味性下降。因此，玩家就会转向
更有趣的区域，这使得以前拥塞的区域人数减少，响应时间得到改
进。
919
---
## Page 921
将不同地理区域分配给不同服务器来实现伸缩性的方法有一个问
题，即必须在游戏编写时决定哪些区域应该放到一台服务器上。虽
然在游戏或虚拟世界中添加新的区域相当容易，但是改变已经分配
给服务器的区域却可能需要改动代码。决定哪些区域组成一个伸缩
性单位，这必须是开发工作的一部分。
第二种处理游戏或虚拟世界中拥塞区域的方法叫做分区
（sharding）。一个分区是该区域的一份副本，运行在它自己的服务
器上，独立于其他的分区，它代表了游戏中相同的部分，即原来的
区域。这样，分区可能代表了某个房间或村庄的不同副本，允许成
倍的玩家进入到世界的这个部分中。分区的缺点是它们不允许处于
不同分区的玩家彼此之间进行交互。随着游戏和虚拟世界变成更多
的社交体验，而不仅仅是玩游戏，这种缺点就明显了。玩家的目标
不只是要出现在虚拟世界中，而是要和他们的朋发（真实的和虚拟
的）一起进入虚拟世界。分区阻碍了这个目标的实现。
因此，Darkstar架构的另一个主要目标就是支持随时伸缩，同时不
要求游戏逻辑受到伸缩的影响。这个架构应该支持游戏动态地响应
负载，而不是让这种响应成为游戏设计工作的一部分。
3.3架构
Darkstar由一组独立的服务构成，这些服务可以在游戏或虚拟世界
的服务器端的地址空间内获得。每个服务都定义为一个小的编程接
口。尽管不是出于本意，但Darkstar项目提供的一些基本服务很像
经典操作系统的服务，它们支持游戏或虚拟世界的服务器端访问持
久存储，调度并执行任务，与游戏或虚拟世界的客户端进行通信。
用一组相互联系的服务来构建这个系统，显然是并始了“分而治之”
的过程，分而治之是设计所有大型计算机系统的基本方法。每种服
务都可以用一个接口来描述，这让使用该服务的程序不会受到底层
实现变更的影响，同时也支持这些实现可以独立地完成。对一个服
务的实现进行变更不应该影响到另一个服务的实现，即使其他的服
务会利用到这个变更的服务（假定接口和接口的语义没有变更）。
我们采用服务分解的方法还有其他的原因。从一开始，Darkstar项