harness）。在该阶段，Excite通过扫描SMRAM来获取所有的模块注册信息和处理程序，并针对每个处理程序，生成一个用来调用CRETE符号执行引擎的测试框架。CRETE不需要源码，直接作用于二进制文件，当其工作时，每一个测试框架都会将SMRAM映射到应用程序空间中。此外，整个通信缓存（comm
buffer）作为符号执行过程的起点被符号化标记。
CRETE在执行的过程中会遍历每一个SMI处理程序的行为，并为获取到的每一个路径生成一个测试用例。效率上，CRETE能够为一个处理程序提供数以千计的测试用例，每一个测试用例都包含了来自通信缓存的数据集。生成的测试用例在Simics上执行，其功能还包括收集代码覆盖率、非法内存访问、非法调用等数据。
**符号分析和生成测试用例**
符号执行是一个能够系统化遍历一个程序执行全部过程的强大技术，主要采取符号输入的方式来执行一个程序。在执行的过程中，符号执行引擎（symbolic
execution engine）会逐渐形成了一个针对输入符号的约束集（set of
constraints），如果在执行中遇到一个取决于符号变量值的程序分支时，符号执行引擎会生成两个新的约束集，分别对应两个分支。执行到程序过程的末尾时，符号执行引擎会将所有的约束集发给约束解析器（constraint
solver），后者生成实际的输入数据，并接着程序过程继续执行。整个分析过程会持续执行直到遍历完程序的全部执行过程，或者满足测试者设置的终止条件。
Excite使用CRETE作为其符号执行引擎，后者是波兰国立大学的一个开源项目。Excite的测试框架通过调用CRETE提供的资源（如crete_make_symbolic(var,size,name)）符号化函数的输入数据或者特定的内存区域，以开展符号执行工作。CRETE会从程序的入口地址处分析内存快照，并为程序的全部执行过程生成测试用例，测试用例包含了函数的实体输入数据。
在使用CRETE的过程中我们发现，一些输入数据会导致SMI处理程序崩溃，这个问题和我们在使用Simics时发现的问题都会作为将来的研究工作。
**Excite是如何使用Simics虚拟平台的**
在研究的过程中我们需要精准地观测SMRAM，同时还能够跳转到内存的任意位置以运行测试用例，这些需求是物理硬件无法满足的，而这也是我们使用虚拟平台的原因。如前文所述，我们选择Simics主要有以下三个目的：
能够运行UEFI的整个启动过程，以获取SMRAM建立的上下文内容。我们通过Simics的检查点功能（checkpoint）来保存目标机器的内存、寄存器、设备状态等全部信息；
能狗在初始化安装完成后访问SMRAM内存，并将dump下来的数据提供给Excite；
能够运行测试用例；
Simics通过加载启动后保存的检查点来执行测试用例以获取UEFI在启动后的状态，该测试用例非常逼真地构建了处理器和内存的状态，包括将通信缓存中指定的内容复制到相关内存中，以及在寄存器（R8和R9）中构建指针和范围值。
处理器的指令指针（RIP）被设置成指向程序代码的入口点，以直接跳转至SMI处理程序。SMI的中断程序会通过一个调度程序并且最终会在测试初始化时完成相同的工作。这里我们假定SMI调度程序是可信的，同时通过这种方式，测试流程可以被一种简单的方式追踪。
Simics在测试用例运行后，会激活执行跟踪器（Exect：Execution
Tracer）模块。Exect监控测试用例的执行过程，重点检测SMRAM的外部调用和非法内存空间访问（如UEFI启动服务内存），如果发现了相关的非法操作，则向UEFI的开发人员提供一份BUG报告。
此外，Exect同时也负责代码覆盖率信息的搜集工作。通过参考代码覆盖率，我们可以随时掌握有多少SMI代码已经被测试过，或者更多的测试是否增加了代码覆盖率。
**Fuzzing测试**
为提高代码覆盖率，我们在测试用例中使用了类似于AFL
fuzzer[5]的模糊测试，后者先改变测试用例中通信缓存中的输入数据，然后在Simics中再次运行测试用例，并保存提高了代码覆盖率的测试用例。
符号执行方式有自身的局限性，一是不能完全生成所有的测试用例；二是其仅局限于操作通信缓存，无法处理通信缓存之外的状态，相比较而言，模糊测试能够生成更多的测试用例。图3描述了符号执行和模糊测试是如何结合并生成更好的测试用例。
**代码覆盖率结果**
通过查看图5所示的代码覆盖率结果，我们会发现结合符号执行与模糊测试的方法提供了更高的代码覆盖率。
**发现问题后的提示与报告**
当一个BUG被发现后，它会被具体化（因为UEFI的代码也作为测试的一部分被运行），同时会在源码中以错误提示的方式被显示，但与一般的静态分析方法不同，这种错误提示通常与一个特定系统状态下的一行代码相关联。
在调试一个程序问题的时候，通常会对一个非法访问或标注的指令进行完整堆栈跟踪分析利用SMRAM dump出来的二进制文件，其汇编代码可以在Windows
Driver Kit[6] (WDK)以及一些项目数据库文件（如*.pdb）的帮助下还原其C代码。
借助于源码，我们可以直接在代码中定位问题的具体所在，如图6所示。
在虚拟平台上调试一个BUG通常比在物理平台上要容易得多：虚拟平台自身剔除了物理设备的诸多限制，如内存锁保护等机制，从而让我们能够以更深更广的视角研究系统；在没有调试环境的情况下，我们仍然能够很好地观察恶意代码的执行过程；重放执行技术使我们能够不断观察可控的执行过程。Wind
River的白皮书[7]对虚拟化技术在网络安全中的应用做了更为深入的讨论。
**通过并行测试以优化执行时间**
在面对大量的测试用例时，采取并行测试的方式会极大地缩短整个测试周期。例如，假定一个处理程序有20000个测试用例需要运行，总的时间耗费（包括生成用例、在Simics上运行、进行模糊测试等）估计会超过10个小时，如果有10个处理程序的话，时间耗费将达到4天以上。但实际上，所有的处理程序都将以并行的方式进行测试，而属于同一个处理程序的测试用例同样也可以并行执行。图7展示了并行测试在整个测试过程的应用情况。
**总结**
Excite项目，通过将不同的技术、方法和工具整合到一个集成工作流中，最后得到了一个以前任何单一技术都无法企及的结果。Excite利用虚拟平台独特的优势，将数据流导向符号执行并生成测试用例，最终又回到虚拟平台运行测试用例，执行行为检测，同时在模糊测试的协助下扩展了测试用例空间。Excite自推出以来已发现了一些与系统平台相关的安全问题，我们相信在未来其必将促进和加强网络安全防御力量的建设。
**参考文献**
[1] 
[2] 
[3]
[4] 
[5] 
[6] 
[7] 