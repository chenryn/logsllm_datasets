### Optimized Text

By delegating the task of building parallel hash chains for each keyword to the logger, techniques have been developed for performing keyword searches on encrypted logs [60, 61]. A tamper-evident storage mechanism for voting machines has also been proposed, based on append-only signatures [33]. However, the size of these signatures increases with the number of signed messages [6].

Several timestamping services have been proposed in the literature. Haber and Stornetta [27] introduced a timestamping service using hash chains, which influenced the design of Surety, a commercial service that publishes its head commitment in a newspaper weekly. Chronos is a digital timestamping service inspired by skip lists but with a hashing structure similar to our history tree [7]. This and other timestamping designs [9, 10] are round-based. In each round, the logger collects a set of events, stores them in a tree, skip list, or directed acyclic graph (DAG), and at the end of the round, publicly broadcasts the commitment (e.g., in a newspaper). Clients then receive a logarithmically-sized proof that their events are stored within that round and are consistent with the published commitment. Efficient algorithms have been developed for outputting timestamp authentication information for successive events within a round in a streaming fashion, with minimal server storage [37]. Unlike these systems, our history tree allows events to be added to the log, commitments generated, and audits performed at any time.

Maniatis and Baker [43] introduced the concept of timeline entanglement, where every participant in a distributed system maintains a log. Each time a message is received, it is added to the log, and every transmitted message contains the hash of the log head. This process spreads commitments throughout the network, making it difficult for malicious nodes to diverge from the canonical timeline without leaving evidence detectable in an audit. Auditorium [55] leverages this property to create a shared "bulletin board" that can detect tampering even if \(N-1\) systems are faulty.

Secure aggregation has been explored as a distributed protocol in sensor networks for computing sums, medians, and other aggregate values when the host performing the aggregation is untrusted. Techniques include trading off approximate results for sublinear communication complexity [12] or using MAC codes to detect one-hop errors in computing aggregates [30]. Other aggregation protocols use hash tree structures similar to those we developed for Merkle aggregation. These structures combine aggregation and cryptographic hashing and include distributed sensor-network aggregation protocols for computing authenticated sums [13] and generic aggregation [45]. The sensor network aggregation protocols interactively generate a secure aggregate of a set of measurements. In Merkle aggregation, we use intermediate aggregates as a tool for efficient queries. Our Merkle aggregation construction is more efficient than these designs, requiring fewer cryptographic hashes to verify an event.

### Conclusions

In this work, we have demonstrated that regular and continuous auditing is a critical operation for any tamper-evident log system. Without auditing, clients cannot detect if a Byzantine logger is misbehaving by not logging events, removing unaudited events, or forking the log. Based on this requirement, we have developed a new tamper-evident log design using a novel Merkle tree data structure that enables the logger to produce concise proofs of its correct behavior. Our system eliminates the need to trust the logger, allowing clients and auditors to efficiently verify the logger's correct behavior with only a constant amount of local state. By sharing commitments among clients and auditors, our design is resistant to sophisticated forking or rollback attacks, even in cases where a client might change its mind and try to repudiate events it had logged earlier.

We also proposed Merkle aggregation, a flexible mechanism for encoding auxiliary attributes into a Merkle tree, allowing these attributes to be aggregated from the leaves up to the root in a verifiable manner. This technique supports a wide range of efficient, tamper-evident queries and enables verifiable, safe deletion of "expired" events from the log.

Our prototype implementation supports thousands of events per second and can easily scale to very large logs. We also demonstrated the effectiveness of Bloom filters in enabling a broad range of queries. Due to its concise proofs and scalable design, our techniques can be applied in various domains where high volumes of logged events might otherwise preclude the use of tamper-evident logs.

### Acknowledgements

The authors gratefully acknowledge Farinaz Koushanfar, Daniel Sandler, and Moshe Vardi for their helpful comments and discussions on this project. We also thank the anonymous referees and Micah Sherr, our shepherd, for their assistance. This work was supported, in part, by NSF grants CNS-0524211 and CNS-0509297.

### References

[References remain unchanged]

This optimized version aims to improve clarity, coherence, and professionalism while maintaining the original content and references.