### 图15: 有无页取消映射时，隔离区中可成功释放的空间比例

在大多数情况下，无论是否使用页取消映射，都不会产生问题。唯一的例外是xalancbmk，在这种情况下，典型的标记过程只能一次性清空90%的隔离区内存。然而，如果没有页取消映射，即使存在悬空指针，我们也可以释放更大的分配，这时会开始遇到显著的问题。Astar、dealII、gcc、h264ref、perlbench和xalancbmk开始在隔离区中留下更多的空间。特别是dealII，由于其许多大型分配都包含悬空指针，并且这些指针存在很长时间，导致隔离区中的空间反复无法释放。尽管如此，当启用页取消映射时，MarkUs仍然非常有效，这表明悬空指针主要对大型分配造成影响。这是因为指向大型分配窗口的指针更可能偶然存在，而单个指针（如栈上的旧数组指针）可能会造成显著的损害。这些正是页取消映射所针对的分配，因此MarkUs的优化共同作用，掩盖了原本显著的成本。

### I. 覆盖范围

虽然MarkUs在存在隐藏指针的情况下也能正确运行，因为它不能释放程序员未释放的任何内容，但它只能保护具有可见指针的分配免受攻击。为了测量这一点，我们使用MarkUs的逆操作；我们使用标记过程来指示那些程序员未释放但标记表中没有标记位的已分配内存区域。从图16中可以看出，实际应用中隐藏指针的威胁可以忽略不计。尽管每个SPEC CPU2006工作负载都包含一些对MarkUs不可见的指针，从而导致单独的标记过程错误地释放它们（可能会导致应用程序行为异常或崩溃），但这并不常见；没有任何工作负载在其整个运行过程中，隐藏指针占据的地址空间超过0.001%。

### J. 总结

MarkUs在性能和内存开销方面优于其他任何不可绕过的用于低级语言中防止使用后释放攻击的安全机制，并且从未遭受过大的开销（最大为2倍）。通过使用但不信任用户提供的释放信息（以隔离列表的形式），带来的优化使该技术从不可行变为非常低的开销，使其适用于生产环境。

### VI. 相关工作

#### 页保护技术
存在多种利用虚拟内存系统防止使用后释放攻击的技术，例如仅一次使用每个虚拟页，并将一个对象分配到一个页上。Electric Fence [30] 是这种方法的一个例子，Dhurjati 和 Adve [6] 通过重用物理页并将其别名化到多个虚拟页上来减少开销。Dang 等人 [7] 提出了 Oscar，扩展了这一技术以去除源代码分析的需求。虽然这种方法在分配大于一页时效果良好，但在指针密集的工作负载下会导致严重的 TLB 压力 [6]，从而导致严重的性能损失。对于大型分配，MarkUs 的行为类似，即在释放时取消页映射。不同之处在于 MarkUs 更高效地处理小对象，减少了 TLB 压力，并最终在手动释放验证后重新分配虚拟地址空间，防止空间耗尽。

#### 指针置零
另一种方法是在数据释放时将其所有指针置零，以消除悬空指针。DangNull [1] 和 FreeSentry [5] 是这种技术的例子，DangSan [4] 优化了这种方法并处理了多线程工作负载的复杂性。为了实现这一点，每种分配都会存储一个不断扩展的指针位置列表，这在包含大量指针副本的基准测试中会导致较高的性能损失和内存开销。MPChecker [31] 使用指针间接寻址来查找每次内存访问的表格条目，并在释放时将其置零。由于每次内存访问都要支付开销，其开销远高于 MarkUs 观察到的开销。

#### 自动内存管理
垃圾收集器通过在最后一个指向对象的指针被删除时才进行释放，从而防止使用后释放攻击 [14]。然而，垃圾收集可能会导致高开销，并且对于 C 和 C++ 应用程序来说并不安全，因为它们可以隐藏指针 [18]。如果支持手动释放对象（如 Boehm-Demers-Weiser 垃圾收集器 [16]），则仍可能发生使用后释放攻击。Fail-Safe C [32] 和 CCured [33] 是 C 中显式防止使用后释放攻击的垃圾收集器使用的示例，但两者都存在高开销和不兼容性。CRCount [25] 受引用计数垃圾收集器启发，通过在编译器中工具化指针的创建和销毁，并使用影子空间跟踪它们，来确定用户释放的对象何时应该被释放。

#### Project Snowflake
Project Snowflake [15] 解决了与 MarkUs 相反的问题。MarkUs 旨在为垃圾收集不安全的低级语言添加时间安全性，而 Project Snowflake 则旨在为默认采用垃圾收集作为释放策略的高级语言添加时间安全的手动内存管理，以提高性能。

#### 指针标签
一些系统通过给指针及其分配附加唯一标签来防止悬空指针的重用，例如 CETS [34]。这依赖于污点传播来处理指针算术，其中修改后的指针保留相同的标签，但这会导致误报 [1]，并且每次指针访问检查都会导致高开销。

#### 强化技术
强化技术，如 DieHard [8]、DieHarder [9] 和 FreeGuard [10]，提供概率性的重用延迟以减少使用后释放攻击的机会。尽管这些技术可以被绕过 [1] 并可能导致高内存开销，但通常会导致相对较低的性能损失。Cling [35] 是一种延迟一般重用来减少攻击机会的分配器，同时允许来自同一分配调用站点的对象立即重用内存，以防止某些类型的使用后释放漏洞。

#### 检测系统
设计用于在调试条件下检测悬空指针使用情况而不是防止其被有动机的攻击者使用的系统也存在。这些包括硬件标记指针技术，如 SPARC M7 [36] 和最近的 Arm 系统 [37]，它们使用有限数量的位作为 ID 字段，以减少新分配在同一位置使用与旧分配相同的 ID 的可能性。与 MarkUs 不同，这些技术提供了即时的悬空指针中毒，从而在使用时检测使用后释放，而不是防止其被攻击者使用。然而，由于 ID 位数量有限，标签必须快速重用，因此有动机的攻击者可以轻松绕过以恢复漏洞。尽管如此，MarkUs 与这些技术结合得很好。不仅 MarkUs 提供了标记内存缺乏的安全性，而且标记内存提供了 MarkUs 不旨在提供的调试功能，标记内存还可以通过基于递增每次分配的 ID 标签多次重用内存来提高 MarkUs 的效率，然后再将地址空间隔离以确保旧 ID 已被消除并可以重新分配。

#### 软件检测技术
还存在一些更高开销的软件技术来检测悬空指针的使用，如 AddressSanitizer [38]。该技术会对自由区域以及分配边界进行毒化，以检测空间和时间安全性违规，但由于该技术无法检测使用悬空指针访问重新分配的内存，并且开销极高，因此主要用于调试而非生产安全。

### VII. 结论
我们介绍了 MarkUs，这是一种防止 C 和 C++ 等低级语言中使用后释放攻击的分配器。它能够通过标记过程找到活动对象来验证程序员的手动释放尝试，并利用程序员的释放来优化过程并尽早释放大分配的虚拟页，从而使性能和内存开销低于文献中任何其他不可绕过的技术，并且特别低的最坏情况开销。这使得该技术已经足够低开销，可以在生产环境中使用。尽管我们的实现是围绕现有的 Boehm-Demers-Weiser 标记过程和分配器设计的，因此只代表了一组基本的性能优化。我们应该期望从头开始设计用于检查手动释放的实现会表现出更低的开销，从而开启一个新的时代，使程序能够抵御这一日益关键的攻击向量。

### 致谢
这项工作得到了工程和物理科学研究委员会 (EPSRC) 通过资助编号 EP/K026399/1 和 EP/P020011/1 以及 Arm Ltd. 的支持。与此出版物相关的额外数据可在数据存储库中获取：https://doi.org/10.17863/CAM.46535 和 https://github.com/SamAinsworth/MarkUs-sp2020。

### 参考文献
[略]

---

通过上述优化，文本变得更加清晰、连贯和专业。希望这对您有所帮助！