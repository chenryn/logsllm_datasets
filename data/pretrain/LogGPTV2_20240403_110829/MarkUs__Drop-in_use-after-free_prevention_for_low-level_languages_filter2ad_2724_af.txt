10-4
10-5
10-6
10-7
10-8
10-9
t
n
e
c
r
e
P
m k
o
i
t
a
R
 1
 0.8
 0.6
 0.4
 0.2
 0
a star
b zip 2
d e alII
g c c
g o b
h 2 6 4ref
m k
h
m
m
m
er
lb
lib q u a ntu
m
m cf m ilc
n a
o
m
m
p erlb e n c h
n etp p
d
p o vra y
sje n g
s p hin x 3
s o ple x
x ala n c b
Fig. 15: Proportion of space in quarantine that can successfully
be freed, with and without page unmapping.
cause no issue. The only exception is xalancbmk, where a
typical marking procedure only empties 90% of the quarantine
memory at once. However, without page unmapping, which
allows us to free larger allocations even if dangling pointers
exist, we start to hit signiﬁcant issues. Astar, dealII, gcc,
h264ref, perlbench and xalancbmk start to leave signiﬁcantly
more space in quarantine. DealII is particularly affected, as
many of its large allocations have dangling pointers, and they
exist for long periods of time, meaning quarantined space is
repeatedly not freed. Still, that MarkUs is so effective when
page unmapping is enabled tells us that dangling pointers tend
to only cause issues with large allocations. This is because
pointers are more likely to exist by chance to large allocation
windows, and a single pointer, such as on the stack to an old
array, can cause signiﬁcant damage. These are the allocations
that page unmapping targets well, and so the optimisations to
MarkUs work together to hide an otherwise signiﬁcant cost.
I. Coverage
While MarkUs functions correctly in the presence of hidden
pointers, as it cannot deallocate anything the programmer has
not freed, it can only protect allocations that have visible
pointers from attack. To measure this we use the inverse of
MarkUs; we use our marking procedure to indicate regions of
allocated memory that have not been freed by the programmer,
but do not feature marked bits in the mark table. In ﬁgure 16,
we see that hidden pointers are likely to be a negligible threat
in practice. While every SPEC CPU2006 workload features
some pointers that are invisible to MarkUs, and thus a marking
procedure on its own would incorrectly free them (potentially
causing incorrect application behaviour or crashes), this is
m
m
er
lb
lib q u a ntu
m
m cf m ilc
n a
o
m
m
p erlb e n c h
n etp p
p o vra y
d
s p hin x 3
sje n g
s o ple x
x ala n c b
Fig. 16: Maximum address space, and percentage of address
space across entire run, that MarkUs cannot ﬁnd references to
but the programmer has not freed.
uncommon; no workload has more than 0.001% of its address
space, averaged across its entire run, as hidden pointers.
J. Summary
MarkUs has better overheads in performance and memory
than any other non-circumventable security mechanism for
use-after-free attacks in low-level languages, and never suf-
fers from large overheads (maximum 2×). The optimisations
brought about by using, but not trusting, the user-provided
freeing information, in the form of the quarantine list, take
the technique from being infeasible, to very low overhead,
making it suitable for use in production environments.
VI. RELATED WORK
Several
Page Protection
techniques exist
that use the
virtual memory system to prevent use-after-free attacks, by
only ever using each virtual page once, and allocating one
object per page. Electric Fence [30] is an example of this
approach, as is Dhurjati and Adve [6], who reduce overheads
by reusing physical pages, and aliasing them to multiple virtual
pages. Dang et al. [7] present Oscar, which expands this
technique to remove the need for source code analysis. While
this approach can work well if allocations are larger than a
page already, it causes extreme TLB pressure under pointer-
intensive workloads [6], causing severe performance losses.
For large allocations, MarkUs essentially behaves similarly,
in that pages are unmapped on deallocation. The difference is
that MarkUs deals with small objects more efﬁciently, reduc-
ing TLB pressure, and eventually reallocates virtual address
space after a marking has veriﬁed manual frees, preventing
exhaustion of the space.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:38:23 UTC from IEEE Xplore.  Restrictions apply. 
589
Pointer Nulliﬁcation
Another approach is to zero all
pointers to data upon its deallocation. This prevents use-after-
free attacks by removing dangling pointers. DangNull [1]
and FreeSentry [5] are examples of this technique, and Dan-
gSan [4] optimises the approach and deals with the complex-
ity of multithreaded workloads. To achieve this, each stores
an expanding list of pointer locations with each allocation,
resulting in high performance loss and memory overhead in
benchmarks with lots of copies of pointers. MPChecker [31]
uses pointer-indirection to look up every memory access in a
table, nullifying the table entry on a free. As it pays overhead
on every memory access, the overheads are signiﬁcantly higher
than observed with MarkUs.
PSweeper [23] is also a nulliﬁcation-based technique. The
difference is that, instead of zeroing pointers immediately
upon freeing an object, pSweeper zeros them continuously
in the background, using another thread and core to do so.
This ofﬂoads some of the overhead, but still results in high
memory utilisation from storing a live pointer table to ﬁnd
references, high CPU utilisation from the use of additional
resources, and instrumentation overhead. To uniquely identify
pointers, separate data and pointer stacks must be used, with
heap allocation for structs that partially contain pointers.
Automatic Memory Management Garbage collectors pre-
vent use-after-free attacks by causing deallocation to occur
only once the last pointer to an object is deleted [14]. However,
garbage collection can result in high overheads, and is not safe
for C and C++ applications, which can hide pointers [18], and
if manual freeing of objects is supported (as in the Boehm-
Demers-Weiser garbage collector [16]),
then use-after-free
attacks can still occur. Examples of garbage collector usage in
C to explicitly prevent use-after-free attacks include Fail-Safe
C [32] and CCured [33], but both suffer from high overheads
and incompatibility. CRCount [25] is inspired by reference-
counting garbage collectors, in that it uses reference counts to
ﬁnd when objects the user has freed should be deallocated, by
instrumenting pointer creation and destruction in the compiler
and using a shadow space to keep track of them.
Project Snowﬂake [15] tackles the inverse problem to
MarkUs. While MarkUs seeks to add temporal safety to a
low-level language where garbage collection is unsafe, Project
Snowﬂake seeks to add temporally-safe manual memory man-
agement
language where pointers can be
reliably determined, and garbage collection is the default
deallocation strategy, to improve performance.
to a high-level
Pointer Labeling
Some systems attach unique labels to
pointers and their allocations to prevent reuse of dangling
pointers, such as CETS [34]. This relies on taint propagation
to deal with pointer arithmetic, where the modiﬁed pointer
keeps the same label, though this results in false positives [1],
and the checks on every pointer access cause high overheads.
Hardening Hardening techniques, such as DieHard [8],
DieHarder [9], and FreeGuard [10], provide probabilistic reuse
delays to reduce the chances of use-after-free attacks. While
these techniques are circumventable [1], and can result in
high memory overhead, they typically result in relatively-low
performance loss. Cling [35] is an allocator that delays general
reuse to reduce attack chances, while allowing immediate
reuse of memory by objects from the same allocation call
site, deemed to be of the same type, to prevent some classes
of use-after-free vulnerability.
Detection
Systems designed to detect the usage of dan-
gling pointers under debug conditions, rather than prevent
their use by a motivated attacker, are available. These include
hardware tagged pointer techniques such as in the SPARC
M7 [36] and recent Arm systems [37], which use a limited
number of bits as an ID ﬁeld to reduce the likelihood of a
new allocation using the same ID as an old one in the same
location. Unlike MarkUs, these give immediate poisoning of
all dangling pointers, allowing the detection of use-after-frees
at the point of use rather than the prevention of their use by an
attacker. However, tags must quickly be reused due to the small
number of ID bits, and so a motivated attacker can easily wrap
around to restore the vulnerability from a security perspective.
Still, MarkUs composes well with such techniques. Not only
does MarkUs provide the security that tagged memory lacks,
and tagged memory the debug that MarkUs does not aim to
provide, but tagged memory can also make MarkUs more
efﬁcient, by allowing reuse of memory multiple times, based
on incrementing the ID tag of each successive allocation,
before address space must be quarantined to ensure old IDs
have been eliminated and can be reallocated.
Software techniques to detect dangling-pointer use exist at
higher overheads, such as AddressSanitizer [38]. This poisons
free regions, along with the bounds of allocations, for detection
of both spatial and temporal safety violations, but as the
technique does not detect accesses using dangling pointers to
reallocated memory, and suffers extremely high overheads, it
is intended for debug, rather than for in production security.
VII. CONCLUSION
We have introduced MarkUs, an allocator that prevents use-
after-free attacks for low-level languages such as C and C++.
Its ability to verify the manual deallocation attempts of the
programmer, using a marking procedure to ﬁnd live objects,
along with the use of the programmer’s deallocations to
optimise the process and free virtual pages early for large
allocations, allows overheads in performance and memory that
are lower than any other non-circumventable technique in the
literature, along with particularly low worst-case overheads.
This results in a technique that
is already low-enough-
overhead for use in production settings. Still, our implementa-
tion was designed around the existing Boehm-Demers-Weiser
marking procedure and allocator, and as such represents only
a primitive set of optimisations for performance. We should
expect an implementation designed from the ground up for
the checking of manual deallocations to exhibit even lower
overheads, resulting in a new era of programs resilient to this
increasingly critical attack vector.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:38:23 UTC from IEEE Xplore.  Restrictions apply. 
590
ACKNOWLEDGEMENTS
This work was supported by the Engineering and Physical
Sciences Research Council (EPSRC),
through grant refer-
ences EP/K026399/1 and EP/P020011/1, and Arm Ltd. Ad-
ditional data related to this publication is available in the
data repository at https://doi.org/10.17863/CAM.46535 and
https://github.com/SamAinsworth/MarkUs-sp2020.
REFERENCES
[1] B. Lee, C. Song, Y. Jang, T. Wang, T. Kim, L. Lu, and W. Lee,
“Preventing use-after-free with dangling pointers nulliﬁcation.” in NDSS,
2015.
[2] O. Chang,
“Racing MIDI messages
in Chrome,”
https:
//googleprojectzero.blogspot.com/2016/02/racing-midi-messages-
in-chrome.html, 2016.
[3] W. Xu, J. Li, J. Shu, W. Yang, T. Xie, Y. Zhang, and D. Gu, “From
collision to exploitation: Unleashing use-after-free vulnerabilities in
linux kernel,” in CCS, 2015.
[4] E. van der Kouwe, V. Nigade, and C. Giuffrida, “DangSan: Scalable
use-after-free detection,” in EuroSys, 2017.
[5] Y. Younan, “FreeSentry: protecting against use-after-free vulnerabilities
due to dangling pointers,” in NDSS, 2015.
[6] D. Dhurjati and V. Adve, “Efﬁciently detecting all dangling pointer uses
in production servers,” in DSN, 2006.
[7] T. H. Y. Dang, P. Maniatis, and D. Wagner, “Oscar: A practical page-
permissions-based scheme for thwarting dangling pointers,” in USENIX
Security, 2017.
[8] E. D. Berger and B. G. Zorn, “Diehard: Probabilistic memory safety for
unsafe languages,” in PLDI, 2006.
[9] G. Novark and E. D. Berger, “Dieharder: Securing the heap,” in CCS,
2010.
[10] S. Silvestro, H. Liu, C. Crosser, Z. Lin, and T. Liu, “Freeguard: A faster
secure heap allocator,” in CCS, 2017.
[11] H.-J. Boehm and M. Weiser, “Garbage collection in an uncooperative
environment,” Softw. Pract. Exper., vol. 18, no. 9, Sep. 1988.
[12] T. M. Corporation, “Cwe-416: Use after free,” https://cwe.mitre.org/data/
deﬁnitions/416.html, 2018.
[13] L. Szekeres, M. Payer, T. Wei, and D. Song, “Sok: Eternal war in
memory,” in SP, 2013.
[14] P. R. Wilson, “Uniprocessor garbage collection techniques,” in IWMM,
1992.
[15] P. Kedia, M. Costa, M. Parkinson, K. Vaswani, D. Vytiniotis, and
A. Blankstein, “Simple, fast, and safe manual memory management,”
in PLDI, 2017.
[16] H.-J. Boehm, A. J. Demers, and S. Shenker, “Mostly parallel garbage
collection,” in PLDI, 1991.
[17] J. R. Ellis and D. L. Detlefs, “Safe, efﬁcient garbage collection for c++,”
in Proceedings of the 6th Conference on USENIX Sixth C++ Technical
Conference - Volume 6, ser. CTEC’94, 1994.
[25] J. Shin, D. Kwon, J. Seo, Y. Cho, and Y. Paek, “CRCount: Pointer
invalidation with reference counting to mitigate use-after-free in legacy
c/c++,” in NDSS, 2019.
[18] H.-J. Boehm and D. Chase, “A proposal for garbage-collector-safe c
compilation,” Journal of C Language Translation, vol. 4, no. 2, Dec.
1992.
[19] J. Caballero, G. Grieco, M. Marron, and A. Nappa, “Undangle: Early
detection of dangling pointers in use-after-free and double-free vulner-
abilities,” in ISSTA, 2012.
[20] A. Milburn, H. Bos, and C. Giuffrida, “Safeinit: Comprehensive and
practical mitigation of uninitialized read vulnerabilities,” in NDSS, 2017.
[21] H.-J. Boehm, “Simple garbage-collector-safety,” in PLDI, 1996.
[22] B. Davis, R. N. M. Watson, A. Richardson, P. G. Neumann, S. W. Moore,
J. Baldwin, D. Chisnall, J. Clarke, N. W. Filardo, K. Gudka, A. Joannou,
B. Laurie, A. T. Markettos, J. E. Maste, A. Mazzinghi, E. T. Napierala,
R. M. Norton, M. Roe, P. Sewell, S. Son, and J. Woodruff, “Cheriabi:
Enforcing valid pointer provenance and minimizing pointer privilege in
the posix c run-time environment,” in ASPLOS, 2019.
[23] D. Liu, M. Zhang, and H. Wang, “A robust and efﬁcient defense against
use-after-free exploits via concurrent pointer sweeping,” in CCS, 2018.
[24] J. L. Henning, “Spec cpu2006 benchmark descriptions,” SIGARCH
Comput. Archit. News, vol. 34, no. 4, Sep. 2006.
[26] “PSRecord,” https://github.com/astrofrog/psrecord, 2018.
[27] M. C. Carlisle, “Olden: Parallelizing programs with dynamic data struc-
tures on distributed-memory machines,” Ph.D. dissertation, Princeton,
NJ, USA, 1996, uMI Order No. GAX96-27387.
[28] A. Gutierrez, R. G. Dreslinski, T. F. Wenisch, T. Mudge, A. Saidi,
C. Emmons, and N. Paver, “Full-system analysis and characterization
of interactive smartphone applications,” in IISWC, 2011.
[29] “Valgrind
jemalloc
builds
now supports
https:
//blog.mozilla.org/jseward/2012/06/05/valgrind-now-supports-jemalloc-
builds-directly/, 2012.
directly,”
https://elinux.org/index.php?title=Electric\ Fence,
[30] “Electric
fence,”
2015.
[31] W. Qiang, W. Li, H. Jin, and J. Surbiryala, “Mpchecker: Use-after-free
vulnerabilities protection based on multi-level pointers,” IEEE Access,
vol. 7, 2019.
[32] Y. Oiwa, “Implementation of the memory-safe full ansi-c compiler,” in
PLDI, 2009.
[33] G. C. Necula, J. Condit, M. Harren, S. McPeak, and W. Weimer,
“Ccured: Type-safe retroﬁtting of legacy software,” ACM Trans. Pro-
gram. Lang. Syst., vol. 27, no. 3, May 2005.
[34] S. Nagarakatte, J. Zhao, M. M. Martin, and S. Zdancewic, “Cets:
Compiler enforced temporal safety for c,” in ISMM, 2010.
[35] P. Akritidis, “Cling: A memory allocator to mitigate dangling pointers,”
in USENIX Security, 2010.
[36] G. K. Konstadinidis, H. P. Li, F. Schumacher, V. Krishnaswamy, H. Cho,
S. Dash, R. P. Masleid, C. Zheng, Y. D. Lin, P. Loewenstein, H. Park,
V. Srinivasan, D. Huang, C. Hwang, W. Hsu, C. McAllister, J. Brooks,
H. Pham, S. Turullols, Y. Yanggong, R. Golla, A. P. Smith, and
A. Vahidsafa, “Sparc m7: A 20 nm 32-core 64 mb l3 cache processor,”
IEEE Journal of Solid-State Circuits, vol. 51, no. 1, 2016.
[37] M. Gretton-Dann, “Arm A-Proﬁle architecture developments 2018:
https://community.arm.com/processors/b/blog/posts/arm-
Armv8.5-A,”
a-proﬁle-architecture-2018-developments-armv85a, 2018.
[38] K. Serebryany, D. Bruening, A. Potapenko, and D. Vyukov, “Address-
sanitizer: A fast address sanity checker,” in USENIX ATC, 2012.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:38:23 UTC from IEEE Xplore.  Restrictions apply. 
591