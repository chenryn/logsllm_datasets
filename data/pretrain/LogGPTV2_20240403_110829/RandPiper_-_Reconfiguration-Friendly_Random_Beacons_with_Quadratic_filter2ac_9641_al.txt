byzantine leader ğ¿ğ‘’ in some epoch ğ‘’, then all honest nodes commit
ğ‘†ğµ, from the SMR property in Theorem B.5. Therefore during recon-
struction, a Byzantine node ğ‘ ğ‘— âˆˆ P cannot provide incorrect shares
as it cannot generate a valid witness VSS.ğœ‹ğ¿ğ‘’,ğ‘— (except with negl(ğœ…)
probability). If a Byzantine leader does not propose any block, then
all honest nodes agree on âŠ¥, thereby ensuring the commitment
property.
â–¡
Concrete Instantiations. Consider instantiating VSS using the
Pedersen commitment based VSS [32] using the polynomial com-
mitment scheme. This scheme is identical to the Pedersen VSS [38]
which is an information-theoretic VSS scheme except that the poly-
nomial commitment based on ğ‘-SDH is used. The polynomial com-
mitment scheme however is identical to the Pedersen commitment
and is unconditionally hiding. Since our SMR is adaptively secure,
and our VSS scheme is unconditionally hiding, BRandPiper is also
adaptively secure. For the binding part, as shown in [32], one can
show a reduction to an adversary violating the binding property to
an adversary violating the ğ‘-SDH assumption.
Lemma B.23 (Bias-resistance). For any epoch ğ‘’ â‰¥ 1, the probability
that a ğ‘¡-bounded adversary A can fix any ğ‘ bits of the BRandPiper
beacon output Oğ‘’ is negl(ğ‘) + negl(ğœ…).
Proof Sketch. The output in any epoch ğ‘’ is Oğ‘’ â† ğ»(ğ‘…ğ‘’),
where ğ‘…ğ‘’ is the homomorphic sum of secrets from at least ğ‘¡ + 1
honest nodes. From the secrecy guarantee in Theorem B.22, we
know that no adversary A can predict the value of these honest
nodes until reconstruction with probability better than negl(ğœ…). At
Session 12D: Decentralized Cryptographic Protocols CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3522the same time, no adversary A can change the committed value
for any ğ‘ğ‘– during reconstruction due to the commitment guarantee
from Theorem B.22 with probability better than negl(ğœ…). Therefore,
a ğ‘¡-bounded adversary cannot do better than guessing whose prob-
ability is negl(ğ‘) + negl(ğœ…) to fix ğ‘ bits in the output Oğ‘’ for any
epoch ğ‘’ â‰¥ 1.
â–¡
Lemma B.24 (Rushing Adversary Advantage). For any epoch ğ‘’, a
rushing adversary can reconstruct output Oğ‘’ at most 2Î” time before
honest nodes.
The proof remains identical to Lemma B.11.
Lemma B.25 (BRandPiper 1-absolute unpredictability). The BRand-
Piper random beacon protocol is an 1-absolute unpredictable random
beacon.
Proof Sketch. Since our SMR protocol is adaptively secure and
our protocol is as secure as VSS, we can instantiate VSS with Ped-
ersen VSS which is information theoretically secure but at the cost
of communication complexity to prove adaptive security of BRand-
Piper. By instantiating VSS with eVSS [32], we do not know how to
show adaptive security using existing proof techniques. However,
no adaptive attacks against eVSS are known either.
Let ğœ be some time at which all honest nodes are in an epoch
ğ‘’ â‰¥ 1. We show that an adversary A cannot predict Oğ‘’+1. Due to
the secrecy property in Theorem B.22 and the fact that the beacon
output Oğ‘’+1 is derived from the reconstruction of ğ‘…ğ‘’+1, which is
a homomorphic sum of inputs from at least ğ‘› âˆ’ ğ‘¡ > ğ‘¡ nodes, any
adversary A cannot predict Oğ‘’+1. The values from the honest nodes
are guaranteed to be truly random (by definition). Therefore, the
output Oğ‘’+1 is unpredictable for an adversary A.
An adversary A can get a 1 epoch advantage since there can
exists times ğœ where some honest nodes are in epoch ğ‘’ and others
are in epoch ğ‘’ âˆ’ 1. At this point, a rushing adversary knows the
output Oğ‘’ before the honest nodes.
â–¡
Theorem B.26 (BRandPiper Secure Random Beacon). BRand-
Piper protocol is a 1-secure random beacon.
The proofs follow trivially from Lemma B.23, Lemma B.25, and
Lemma B.20.
C CLOCK SYNCHRONIZATION FOR NEW
NODES
In this section, we present a clock synchronization protocol to syn-
chronize some additional nodes when majority of honest nodes
are synchronized. Such a synchronization is useful during recon-
figuration when a new node joins the system. Prior known clock
synchronization protocol [1] can be used to synchronize all nodes
with a communication cost of ğ‘‚(ğœ…ğ‘›3) without threshold signatures.
This holds true even when synchronizing a single node in the sys-
tem where a majority of nodes are already synchronized.
Our clock synchronization protocol to add new nodes (refer Fig-
ure 11) makes use of VSS secret sharing scheme presented in Sec-
tion 4.2.2. Our approach requires a total communication complexity
of ğ‘‚(ğœ…ğ‘›3); however, this can be split over ğ‘‚(ğ‘›) iterations with
ğ‘‚(ğœ…ğ‘›2) communication. This will be useful in our beacon protocol
to maintain quadratic communication complexity in each round.
Our protocol uses the fact that ğ‘‚(ğ‘¡) secret shares can be homo-
morphically combined to a single secret share of size ğ‘‚(1) and
ğ‘¡ + 1 homomorphic secret shares can be be opened to get a ğ‘‚(ğœ…)
sized secret. The opened secret can be broadcast among all nodes
to synchronize the clocks of all honest nodes including the new
joining node within Î” time from each other.
The first honest node to reset epoch-timer for some epoch ğ‘’ will
broadcast sync message containing ğ‘…ğ‘’ which makes all other honest
nodes reset their epoch-timerğ‘’ within Î” time. Observe that since
the size of homomorphic ğ‘…ğ‘’ is ğ‘‚(ğœ…) bits, an all-to-all broadcast has
a cost of ğ‘‚(ğœ…ğ‘›2) bits.
D RECONFIGURATION
In this section, we present reconfiguration mechanisms for our
beacon protocols to restore the resilience of the protocol after re-
moving some Byzantine nodes. We make following modification
to the protocols. Each node maintains a variable ğ‘›ğ‘¡ that records
the number of additional nodes that can be added to the system.
Variable ğ‘›ğ‘¡ is incremented each time a Byzantine node is added to
set Pğ‘Ÿ and is decreased by one when a new node joins the system.
The value of ğ‘›ğ‘¡ can be at most ğ‘¡.
The generic reconfiguration protocol is presented in Figure 12.
The reconfiguration protocol applies to both beacon protocols. Later,
we make appropriate modifications for each beacon protocols.
If ğ‘›ğ‘¡ > 0 at some epoch ğ‘’âˆ— and there are
Lemma D.1 (Liveness).
new nodes intending to join the system in epochs â‰¥ ğ‘’âˆ—, then eventually
a new node will be added to the system.
Proof. Suppose ğ‘›ğ‘¡ > 0 and a new node ğ‘ğ‘– intends to join the
system. Suppose for the sake of contradiction, no new node includ-
ing ğ‘ğ‘– is added to the system. However, since node ğ‘ğ‘– intends to join
the system, it must have sent inquire requests to all nodes in the
system and at least ğ‘¡ + 1 honest nodes will respond to the inquire
request since ğ‘›ğ‘¡ > 0 at the end of some epoch ğ‘’â€² â‰¥ ğ‘’âˆ—.
Let node ğ‘ğ‘– send join request along with an inquire certificate
and nodes receive the request in epoch ğ‘’ â‰¥ ğ‘’â€². The first honest
leader ğ¿ğ‘’â€²â€² of epoch ğ‘’â€²â€² â‰¥ ğ‘’ will include the join request in its
block proposal if no new node has been added to the system since
epoch ğ‘’â€² and there does not exist any block proposal with a join
request in the last ğ‘¡ + 1 epochs in its highest ranked chain and by
Fact B.6, the block proposal with join request will be committed. A
contradiction.
If some node has already been added to the system since epoch ğ‘’â€²,
this trivially satisfies the statement. Thus, we obtain a contradiction.
If there exists a block proposal ğµâ„ with a join request for some node
ğ‘ğ‘˜ in last ğ‘¡ epochs in the highest ranked chain for ğ¿ğ‘’â€²â€², ğµâ„ will be
committed since honest node ğ¿ğ‘’â€²â€² extends it. The lemma holds and
we obtain a contradiction.
â–¡
D.1 Reconfiguration for GRandPiper
Node ğ‘ğ‘˜ generates a PVSS (PVSS.(cid:174)ğ‘†, PVSS.(cid:174)ğ¸, PVSS.ğœ‹) â† PVSS.ShGen(ğ‘…)
of a random value chosen from the input space of PVSS for nodes
P âˆª {ğ‘ğ‘˜} \ Pğ‘Ÿ . During the join phase in the reconfiguration pro-
tocol (refer Figure 12), it sends a join request to all nodes P \ Pğ‘Ÿ
with entity M set to the above PVSS. In addition, all nodes update
22
Session 12D: Decentralized Cryptographic Protocols CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3523Let clock synchronization protocol start in epoch ğ‘’. Node ğ‘ğ‘– âˆˆ P performs the following:
(1) Share secrets. Leaders {ğ¿ğ‘’, . . . , ğ¿ğ‘’+ğ‘¡ } use block validation (refer Figure 8) and the BFT protocol to commit secrets {ğ‘ ğ‘’, . . . , ğ‘ ğ‘’+ğ‘¡ } respectively. e.g.,
Leader ğ¿ğ‘’ uses the block validation protocol while in epoch ğ‘’ âˆ’ 1 to share a single secret ğ‘ ğ‘’ chosen uniformly at random and collect an ack certificate
AC(ğ‘†ğµ) on the commitment ğ‘†ğµ for secret ğ‘ ğ‘’. In epoch ğ‘’, Leader ğ¿ğ‘’ proposes block ğµğ‘˜ := (ğ» (ğ‘†ğµ), AC(ğ‘†ğµ)).
(2) Reconstruct. When epoch-timerğ‘’+2ğ‘¡ expires, perform the following:
â€¢ Build homomorphic sum share ğ‘†ğ‘‰ğ‘–, witness VSS.ğœ‹ğ‘–, and commitment VSS.Cğ‘’ using secret shares for {ğ‘ ğ‘’, . . . , ğ‘ ğ‘’+ğ‘¡ }. Send ğ‘†ğ‘‰ğ‘– and VSS.ğœ‹ğ‘– to all the
â€¢ Upon receiving share ğ‘†ğ‘‰ğ‘— and witness VSS.ğœ‹ ğ‘— for VSS.Cğ‘’, ensure that VSS.ShVrfy(ğ‘†ğ‘‰ğ‘— , VSS.ğœ‹ ğ‘— , VSS.Cğ‘’) = 1.
â€¢ Upon receiving ğ‘¡ + 1 valid homomorphic sum shares in ğ‘†ğ‘‰ , obtain ğ‘…ğ‘’ â† VSS.Recon(ğ‘†ğ‘‰).
(3) Synchronize. The first time node ğ‘ğ‘– receives a valid homomorphic secret ğ‘…ğ‘’ either through reconstruction or on receiving sync message from other
nodes, it (i) resets its epoch-timerğ‘’+2ğ‘¡+1 to the beginning of epoch ğ‘’ + 2ğ‘¡ + 1, and (ii) broadcasts a sync message containing ğ‘…ğ‘’ to all other nodes.
nodes.
Figure 11: Clock synchronization protocol
A new node ğ‘ğ‘˜ that intends to join the system uses following procedure to join the system.
(1) Inquire. Node ğ‘ğ‘˜ inquires all nodes in the system to send the set of active nodes, i.e., P \ Pğ‘Ÿ . Upon receiving the inquire request, an honest node ğ‘ğ‘–
responds to the request only if ğ‘›ğ‘¡ > 0. Node ğ‘ğ‘– sends P \ Pğ‘Ÿ at the end of some epoch ğ‘’â€² in which the inquire request was received. Node ğ‘ğ‘˜ waits for at
least ğ‘¡ + 1 consistent responses from the same epoch ğ‘’â€² and forms an inquire certificate. An inquire certificate is valid if it contains ğ‘¡ + 1 inquire responses
that belong to the same epoch ğ‘’â€² and contains the same set of active nodes.
(2) Join. Node ğ‘ğ‘˜ sends a join request to all nodes P \ Pğ‘Ÿ along with the inquire certificate and an additional entity M specific to the beacon protocols.
(3) Propose. Upon receiving the join request, the leader ğ¿ğ‘’ of current epoch ğ‘’ adds the join request containing inquire certificate and entity M in its block
proposal ğµğ‘˜ if (i) ğ¿ğ‘’ does not observe a block proposal with a join request in last ğ‘¡ + 1 epochs in its highest ranked chain and (ii) no new node has been
added since epoch ğ‘’â€².
(4) Update. If the block ğµğ‘˜ with the join request from node ğ‘ğ‘˜ proposed in epoch ğ‘’ gets committed by epoch ğ‘’ + ğ‘¡, update ğ‘›ğ‘¡ â† ğ‘›ğ‘¡ âˆ’ 1 in epoch ğ‘’ + ğ‘¡ and
send P \ Pğ‘Ÿ to node ğ‘ğ‘˜. Henceforth, node ğ‘ğ‘˜ becomes a passive node and receives all protocol messages from active nodes.
(5) Synchronize. Nodes execute clock synchronization protocol (refer Figure 11) from epoch ğ‘’ + ğ‘¡ + 2 to synchronize node ğ‘ğ‘˜. All nodes including node ğ‘ğ‘˜
are synchronized in epoch ğ‘’ + 3ğ‘¡ + 3. At epoch ğ‘’ + 3ğ‘¡ + 3 update P â† P âˆª {ğ‘ğ‘˜ }. Henceforth, node ğ‘ğ‘˜ becomes an active node and participates in the
protocol. Additionally, node ğ‘ğ‘˜ participates in the reconstruction protocol only if it has required secret shares.
If node ğ‘ğ‘˜ fails to join the system, it restarts reconfiguration process again after some time.
Figure 12: Reconfiguration protocol
Q(ğ‘ğ‘˜) with the PVSS provided by node ğ‘ğ‘˜ once its join request
gets committed.
An adaptive adversary can corrupt any node as long as ğ‘¡ + 1
honest nodes have full queue Q(ğ‘ ğ‘—) â‰  âŠ¥âˆ€ğ‘ ğ‘— âˆˆ P \ Pğ‘Ÿ , i.e., if the
adversary already corrupted ğ‘¡ nodes some of which are removed,
the adversary can corrupt old honest nodes only when node ğ‘ğ‘˜
has full queue (i.e., Q(ğ‘ ğ‘—) â‰  âŠ¥âˆ€ğ‘ ğ‘— âˆˆ P \ Pğ‘Ÿ ). This happens when
all nodes in P \ Pğ‘Ÿ becomes a leader at least once after node ğ‘ğ‘˜
becomes a leader. Due to random leader election, the expected
number of epochs required for all nodes to be selected as leaders is
ğ‘›
ğ‘–=0
Remark. GRandPiper beacon protocol can employ a rotating leader
election for BFT SMR with randomized leaders for reconstruction
phase. With this change, the adaptive resilience of BRandPiper is
restored in ğ‘› + ğ‘¡ + 1 epochs compared to expected ğ‘› log ğ‘› epochs.
Theorem D.2. GRandPiper protocol maintains safety and liveness
ğ‘– = Î˜(ğ‘› log ğ‘›).
1
ğ‘›
after reconfiguration.
Proof. Let node ğ‘ğ‘– be the new joining node. GRandPiper pro-
tocol is safe and live before reconfiguration. Since we assume the
adversary can corrupt a new node as long as ğ‘¡ + 1 honest nodes
have full queue, i.e., Q(ğ‘ ğ‘—) â‰  âŠ¥âˆ€ğ‘ ğ‘— âˆˆ P \ Pğ‘Ÿ , there will always be
ğ‘¡ + 1 honest nodes with correct secret shares. Hence, the protocol
maintains safety and liveness after reconfiguration.
â–¡
23
D.2 Reconfiguration for BRandPiper
Node ğ‘ğ‘˜ that intends to join the system uses the reconfiguration
protocol (Figure 12) to join the system. During the join phase, node
ğ‘ğ‘˜ does not need to send any additional commitment i.e., sets
M := âŠ¥. Once node ğ‘ğ‘˜ becomes the active node, it is then allowed
to become a leader using round-robin leader election and shares
VSS commitments to ğ‘› secrets when it becomes the leader. All
active nodes use the secret shares for node ğ‘ğ‘˜ only when they have
committed the commitment shared by node ğ‘ğ‘˜.
Like the reconfiguration for GRandPiper protocol, an adaptive
adversary can corrupt any node as long as ğ‘¡ + 1 honest nodes have
full queue Q(ğ‘ ğ‘—) â‰  âŠ¥âˆ€ğ‘ ğ‘— âˆˆ P \ Pğ‘Ÿ . I.e., if the adversary already
corrupted ğ‘¡ nodes some of which are removed, the adversary can
corrupt old honest nodes only when node ğ‘ğ‘˜ has full queue (i.e.,
Q(ğ‘ ğ‘—) â‰  âŠ¥âˆ€ğ‘ ğ‘— âˆˆ P \ Pğ‘Ÿ ). This happens when all nodes in P \ Pğ‘Ÿ
becomes a leader at least once after node ğ‘ğ‘˜ becomes a leader. Due
to the round-robin leader election, node ğ‘ğ‘˜ will have full queue
after ğ‘› + ğ‘¡ + 1 epochs after it has become an active node.
Theorem D.3. BRandPiper protocol maintains safety and liveness
after reconfiguration.
The proof remains identical to Theorem D.2.
Session 12D: Decentralized Cryptographic Protocols CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3524