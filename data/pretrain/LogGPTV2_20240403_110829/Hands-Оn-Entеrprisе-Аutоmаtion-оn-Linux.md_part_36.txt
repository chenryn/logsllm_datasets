L1W)
service:
name: chronyd
state: started
This simple code ensures that we both check for and satisfy recommendation 2.2.1.1
without the need for any logic to detect which time service is in use. Of course, we could
choose to be more thorough and check that ntpd is not started, but this is left as an exercise
to you.
[ 389 ]
CIS Hardening with Ansible Chapter 14
Naturally, we cannot fit all the Ansible code that's required for the roughly 400
recommendations in this CIS Benchmark into this book – that would deserve an entire book
to itself! In addition, this example is just for one benchmark – if your enterprise introduces a
new operating system such as RHEL 8, you can be sure there will be a separate CIS
Benchmark for this operating system that will need to be implemented. However, it is
hoped that the development of these examples from the RHEL 7 CIS Benchmark is
sufficient for you to design and build your own policy. Thus, in the next section of this
chapter, we will look at techniques for making this task manageable at enterprise scale.
Application of enterprise-wide policies with
Ansible
Although we have seen the significant benefits that Ansible can bring to CIS Benchmark
implementation, I'm sure it is apparent at this stage that development and maintenance of
these policies could turn into a full-time job, especially when coupled with the need to run
them against the infrastructure and manage the results of each run.
Fortunately, the spirit of open source development brings a solution to this dilemma.
Imagine if someone had already spent a great deal of time and effort developing a high-
quality set of Ansible roles for implementing CIS Benchmarks, and that this was available
as open source code so that you could audit it, ensure it was fit for your environment, and
tailor it easily if required. Further, imagine that they had put a great deal of time and effort
into tagging each task, and adding appropriate variable structure to allow you to easily
specify your choices such as which time synchronization service your enterprise uses.
Thankfully, this work has already been completed by MindPoint Group, and their code has
been made freely available on GitHub at https:/​/​github.​com/​MindPointGroup/​RHEL7-​CIS.
At the time of writing, the latest CIS Benchmark available for EL7 systems
is version 2.2.0, whereas the aforementioned playbooks are written against
version 2.1.1 of the benchmark. It is up to you to ensure you are aware of
the benchmark version you are implementing, as well as any possible
security implications if you implement a slightly older version.
[ 390 ]
CIS Hardening with Ansible Chapter 14
In addition to this, just as users of Ubuntu may choose paid support or to use the free open
source operating system, and EL7 users may choose between Red Hat Enterprise Linux 7 or
CentOS 7, MindPoint Group also offers a commercially supported version of their Ansible
hardening code, available via https:/​/​www.​lockdownenterprise.​com/​. Thus, they offer
support for both ends of the spectrum, respecting that some enterprises will absolutely
require an enterprise support contract, while others will prefer to use freely available open
source software.
Let's explore how we might use the open source code against our CentOS 7 server:
1. First of all, we need to clone the GitHub repository:
$ cd roles
$ git clone https://github.com/MindPointGroup/RHEL7-CIS.git
$ cd ..
2. Once this is complete, we can then proceed to use the code exactly as we would
use any other role. Where appropriate, we should set variables, which can be set
either in the inventory or in the main playbook (more on this in a second).
Thus, the purest and simplest possible implementation of the MindPoint Group
CIS Benchmark in Ansible once the role has been cloned from GitHub is a
playbook that looks like this:
---
- name: Implement EL7 CIS benchmark
hosts: all
become: yes
roles:
- RHEL7-CIS
[ 391 ]
CIS Hardening with Ansible Chapter 14
3. With these steps complete, you can literally begin implementing the EL7
benchmark and its near 400 recommendations on your Linux servers in a matter
of minutes – the playbook is run in the normal manner, and will produce many
pages of output as all the checks are performed and recommendations
implemented (if/when required). The following screenshot shows the playbook
being run and the initial page of output:
Now, a word on variables. As we established in the previous section (Writing Ansible
security policies), there will be occasions where you need to vary your playbook run. The
variables and tags are all documented in the README.md file that accompanies the GitHub
repository we cloned earlier, and for purposes of illustration, let's consider a few examples.
First off, suppose we only want to implement the level 1 recommendations (those that are
less risky to day-to-day operations). This can be achieved by running the playbook and
using the level1 tag:
$ ansible-playbook -i hosts site.yml --tags=level1
[ 392 ]
CIS Hardening with Ansible Chapter 14
Alternatively, you might be running the hardening playbooks against a set of servers that
act as routers. In this instance, we would need to set the rhel7cis_is_router variable to
false to ensure that kernel parameters that disable router functionality are not set.
This could be done on the command line as follows:
$ ansible-playbook -i hosts site.yml -e rhel7cis_is_router=true
However, this is very manual, and it would be far too easy for someone to accidentally run
the playbook without setting this variable, suddenly disabling the router.
It would be far better to set this variable at the inventory level, thus ensuring that it is
always set correctly whenever the playbook is run. Thus, we might create an inventory
such as this:
[routers]
router-testhost
[routers:vars]
rhel7cis_is_router=true
With this inventory in place, running the playbook against the routers is performed using a
command such as the following:
$ ansible-playbook -i routers site.yml
As long as this inventory file is used, there is no danger of someone forgetting to set
the rhel7cis_is_router variable to true.
Of course, this discussion does not mean that you must download and use these playbooks
– it is still entirely possible to develop and maintain your own playbooks to your own
requirements. Indeed, there may be situations in which this strategy is actually preferable.
What is important is that you choose the strategy that is best for your enterprise. When
selecting your strategy for implementing security policy at scale, you should take the
following into account:
Whether you want to own your own code (with all the advantages and
disadvantages that brings)
Whether you want to be responsible for the maintenance of your code base going
forward
That you should standardize on one code base as far as possible to ensure your
code structure remains maintainable
Whether you need third-party support on implementing these benchmarks or
whether you are happy that you have the skills and resources in-house
[ 393 ]
CIS Hardening with Ansible Chapter 14
Once you have made your evaluation, you will be well placed to define your path forward
with creating Ansible playbooks to implement your chosen security standards. It is
intended that the information provided to you in this chapter so far will be sufficient to
support you in whichever path you choose. Although we have focused on EL7 (Red Hat
Enterprise Linux 7 and CentOS 7) in this chapter, everything we have discussed will scale
well to other operating systems for which there exist security benchmarks (for example,
Ubuntu Server 18.04). In fact, if you run through the processes we have discussed within
this chapter using the CIS Benchmark for Ubuntu Server 18.04, you will find a great deal of
similarity can be achieved.
So far, we have dealt almost exclusively with the implementation of CIS Benchmarks. This
chapter would not be complete, however, without providing a method to check levels of
enforcement without the need to make changes. After all, auditing is an important part of
most enterprise policies, especially where security is concerned, yet changes must be made
under an authorized change request window.
Testing security policies with Ansible
As we have discussed so far, it is important to ensure that not only can you implement
security policies in an efficient and repeatable manner, but that it should also be possible to
audit them. There are a variety of tools available for this task, both closed source and open
source. Before we consider any other tools, though, it is worthwhile looking at how Ansible
itself can assist with this task.
Let's return to one of our original examples, where we were implementing two of the
recommendations from section 5 of the CIS Benchmark.
Previously, we ran this with the following command:
$ ansible-playbook -i hosts site.yml
This ran through the two checks, implementing the changes if the system was not already
compliant with the security recommendations. However, Ansible also has a mode of
operation called check mode. In this mode, Ansible does not make any changes to the
remote system(s) – rather, it tries to predict all changes that might be made to the systems
instead.
Not all modules are compatible with check mode, and so some care is advised when using
this mode. For example, Ansible cannot possibly know the output of running a particular
shell command using the shell module, as there are so many possible permutations of
commands. Also, running shell commands might be destructive or cause a change to the
system, and so any tasks that use the shell module are skipped during a check run.
[ 394 ]
CIS Hardening with Ansible Chapter 14
However, many of the core modules we have already used, such as yum, lineinfile, and
sysctl, do support check mode and so can be used quite effectively in this mode.
Thus, if we run our example playbook again, only this time in check mode, we would see
an output similar to what's shown in the following screenshot:
You will notice that this looks exactly like any other playbook run – there are, in fact, no
clues at all that it is running in check mode, other than the -C flag on the command line
invoking this run. However, if you examine the target system, you will see that no changes
were made.
The preceding output is very useful, though, for auditing processes – it demonstrates to us
that the target system does not meet the recommendations for either section 5.2.8 or 5.2.9 of
the benchmark – if these were met, then the result should have been ok. Equally, we know
that the handler only fires in the event that changes are required on the remote system, and
again this tells us that the system is not compliant in some way.
[ 395 ]
CIS Hardening with Ansible Chapter 14
It is accepted that some interpretation of the output is going to be required – however, by
exercising good design practices in your roles when you write them (especially when
putting the benchmark section number and title into the task names), then you can very
quickly start to interpret the output and see which systems are not compliant, and further,
which recommendations specifically they fail on.
Further, the variable structure we put in place to determine which tasks are run and when
still applies in check mode, so if we run this playbook on the legacy hosts that need remote
root logins enabled (but this time in check mode), we can see that this task is skipped,
ensuring that we don't get false positives during an audit. The following screenshot shows
this being run:
In this manner (coupled with good playbook design), Ansible code can be reused not just
for implementation purposes, but for auditing purposes too.
It is hoped that this chapter has given you sufficient knowledge to proceed with confidence
when it comes to implementing security hardening on your Linux servers at enterprise
scale, and even auditing them as part of an ongoing process.
[ 396 ]
CIS Hardening with Ansible Chapter 14
Summary
Ansible is an incredibly powerful tool that lends itself well to the implementation and
auditing of security benchmarks such as the CIS security benchmark. We have
demonstrated through practical example how it can reduce a shell script of nearly 60 lines
down to less than 20, and how the same code can be easily reused in a variety of scenarios,
and even be used to audit security policies across the enterprise.
In this chapter, you learned how to write Ansible playbooks to apply server hardening
benchmarks such as CIS. You then gained hands-on knowledge of applying server
hardening policies across the enterprise using Ansible, and how to make use of publicly
available open source roles to assist you in this. Finally, you learned about how Ansible
supports testing and auditing of successful policy application.
In the next chapter, we will look at an open source tool called OpenSCAP that can be used
to perform effective auditing of security policies across the enterprise.
Questions
1. How do Ansible modules such as lineinfile make security benchmark
implementation code more efficient than shell scripting?
2. How can Ansible tasks be made conditional for a specific server or group of
servers?
3. What are good practices for naming your tasks when writing Ansible tasks to
implement the CIS Benchmark?
4. How might you modify a playbook so that you can easily get the CIS level 1
benchmarks to run without any of the level 2 ones being evaluated?
5. What is the difference between the --tags and --skip-tags options when
running an Ansible playbook?
6. Why would you want to make use of publicly available open source code for
your CIS Benchmark implementation?
7. What does the -C flag do to a playbook run when used with the ansible-
playbook command?
8. Does the shell module support check mode?
[ 397 ]
CIS Hardening with Ansible Chapter 14
Further reading
To review common questions about the CIS Benchmarks, please refer to https:/
/​www.​cisecurity.​org/​cis-​benchmarks/​cis-​benchmarks-​faq/​.
A full list of CIS Benchmarks is available at https:/​/​www.​cisecurity.​org/​cis-
benchmarks/​.
For an in-depth understanding of Ansible, please refer to Mastering Ansible, Third
Edition by James Freeman and Jesse Keating (https:/​/​www.​packtpub.​com/​gb/
virtualization-​and-​cloud/​mastering-​ansible-​third-​edition).
[ 398 ]
15
Auditing Security Policy with
OpenSCAP
Throughout the two chapters that preceded this one, we established the value of applying a
security policy such as the CIS Benchmark to your Enterprise Linux infrastructure. We have
discussed a variety of methods for both applying it and ensuring it remains enforced; the
latter point is especially important in an infrastructure where a wide array of people have
superuser access to your Linux servers. Although we have established ways that both shell
scripting and Ansible can assist with auditing the compliance of your infrastructure with
your chosen security policy, we have also established that neither of these are particularly
suited to providing readable and actionable reports of a large infrastructure. For example, it
is entirely reasonable that an infrastructure security team might want a readable report
showing the compliance of the infrastructure with the security policy, and neither shell
scripting nor Ansible immediately lend themselves to this task.
Although there are a wide variety of infrastructure scanning tools available on the market,
most of these are commercial and the focus of this book is on open source solutions that are
accessible to any enterprise, regardless of their budget. Hence, in this chapter, we will
consider the freely available OpenSCAP tool. SCAP stands for Security Content
Automation Protocol, and it is a standardized solution for checking a Linux infrastructure
for compliance against a given security policy (in our case, CIS). OpenSCAP is hence an
open source implementation of SCAP that has been widely adopted by Enterprise Linux
vendors including Red Hat. We will hence explore the process for setting up your own
OpenSCAP infrastructure for compliance scanning and reporting. This, in turn, will enable
all teams with a vested interest in infrastructure security to get oversight of the levels of
compliance.
Auditing Security Policy with OpenSCAP Chapter 15
Specifically, we will cover the following topics in this chapter:
Installing your OpenSCAP server
Evaluating and selecting policies
Scanning the enterprise with OpenSCAP
Interpreting results
Technical requirements
This chapter includes examples based on the following technologies:
Ubuntu Server 18.04 LTS
CentOS 7.6
Ansible 2.8
To run through these examples, you will need access to two servers or virtual machines
running one each of the operating systems listed previously and Ansible.
All example code discussed in this book is available from GitHub at: https:/​/​github.​com/
PacktPublishing/​Hands-​On-​Enterprise-​Automation-​on-​Linux.
Installing your OpenSCAP server
When it comes to scanning your infrastructure, we have a few decisions to make, as the
OpenSCAP project provides a few tools that have overlapping functions. The reason for
this is that they are targeted at different audiences—some are purely command line-driven
and so lend themselves extremely well to scheduled, scripted tasks such as a monthly
compliance report. At the time of writing, there are a total of five OpenSCAP tools
available, and we will look at each of these in more detail in the following sections to enable
you to make an educated decision as to which tool (or tools) are right for your enterprise.
In the following subsection, we will start by looking at the most fundamental tool,
OpenSCAP Base.
[ 400 ]
Auditing Security Policy with OpenSCAP Chapter 15
Running OpenSCAP Base
The OpenSCAP Base tool provides the very fundamentals required to scan a single Linux
machine and report on its compliance against a given policy. It actually consists of two
components and so is a requirement for some of the other tools we will look at in the
following subsections.
The first component of this tool is a command-line utility called oscap. This tool can be run
on the local machine using an appropriate security policy and profile to produce a report of
compliance. The report is generated in HTML and so although the process of report
creation is very much manual, the final report is very easy to read and so is well suited for
sending to a security or compliance team for audit or evaluation.
The second component of OpenSCAP Base includes a library that is used as a building
block for other OpenSCAP services such as SCAP Workbench and the OpenSCAP
Daemon—we will cover these in greater detail later in this section.
In this book, we will only make use of the library when we use other OpenSCAP tools. We
will see these tools in action later in this chapter in the section entitled Scanning the
enterprise with OpenSCAP. For now, though, we will concern ourselves with the installation
of OpenSCAP Base.
Installing OpenSCAP Base by hand on a single machine is incredibly easy—it already
comes pre-packaged for the two key Linux distributions we have explored in this
book—Ubuntu Server and CentOS (and hence, by extension, Red Hat Enterprise Linux). To
install it on CentOS 7 or RHEL 7, you would simply run the following command:
$ sudo yum -y install openscap-scanner
Similarly, on Ubuntu Server 18.04 LTS, you would run this:
$ sudo apt -y install libopenscap8
It is important to remember that these packages include both the oscap command-line tool