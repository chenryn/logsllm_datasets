tion: all pause times are imperceptible for all versions.
4.3.3
Standard Usage
For our standard usage workload, we used the Boundless
version of Pine intensively for one hour to read e-mail, reply
to e-mails, forward e-mails, and manage e-mail folders. To
test Pine’s ability to successfully execute through errors, we
also periodically sent ourselves an email that triggered the
memory error discussed above in Section 4.3.1. During this
usage period, the Boundless version executed successfully
through all errors to perform all requests ﬂawlessly. We
conﬁgured this version of Pine to generate a memory error
log ﬁle. We logged 129 out of bounds accesses. Of these
out of bounds accesses, 91 modiﬁed the accessed memory
location and 38 did not modify the accessed location. All of
these latter 38 accesses accessed locations previously stored
in the hash table.
4.4 Mutt
Mutt is a customizable, text-based mail user agent that
is widely used in the Unix system administration commu-
nity [6]. It is descended from ELM [2] and supports a variety
of features including email threading and correct NFS mail
spool locking. We used Mutt version 1.4. As described at [5]
and discussed in Section 2, this version is vulnerable to an
attack that exploits a memory error in the conversion from
UTF-8 to UTF-7 string formats. We were able to develop
an attack that exploited this vulnerability.
It is possible
for a remote IMAP server to use this attack to crash Mutt;
it may also be possible for the IMAP server to exploit the
vulnerability to inject and execute arbitrary code.
4.4.1
Security and Resilience
We conﬁgured our security and resilience workload to ex-
ploit the security vulnerability described above. On this
workload, the Standard version of Mutt exits with a segmen-
tation fault before the user interface comes up; the Check
Proceedings of the 20th Annual Computer Security Applications Conference (ACSAC’04) 
1063-9527/04 $ 20.00 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 11:38:47 UTC from IEEE Xplore.  Restrictions apply. 
version exits with a memory error before the user interface
comes up. The memory error is triggered by a carefully
crafted mail folder name; when the Boundless version exe-
cutes, it generates an error message indicating that the mail
folder does not exist, then continues to execute to allow the
user to successfully process mail from other folders.
4.4.2 Performance
Figure 4 presents the request processing times for the
Standard and Boundless versions of Mutt. All times are
given in milliseconds. The Read request reads a selected
empty message and the Move request moves an empty mes-
sage from one folder to another. We performed each request
at least twenty times and report the means and standard
deviations of the request processing times.
Request
Read
Move
Standard
Boundless
.655 ± 4.3% 2.71 ± 2.3%
6.94 ± 6.2% 9.91 ± 5.9%
Slowdown
4.1
1.4
Figure 4: Request Processing Times for Mutt
(milliseconds)
Because Mutt is an interactive program, its performance is
acceptable as long as it feels responsive to its users. These
performance results make it clear that the application of
boundless computing to this program should not degrade
its interactive feel. Our subjective experience conﬁrms this
expectation: all pause times are imperceptible for both the
Standard and Boundless versions.
4.4.3
Standard Usage
For our standard usage workload, we used the Boundless
version of Mutt intensively for half an hour to process email
messages. During this time, we triggered the security vul-
nerability described above twice. Mutt successfully executed
through the resulting memory errors to correctly execute all
of our requests. We were able to read, forward, and com-
pose mail with no problems even after executing through
the memory error.
An examination of the memory error log indicates that
all of the memory errors were caused by the security vulner-
ability. We logged 38 out of bounds accesses, all of which
were writes.
4.5 Midnight Commander
Midnight Commander is an open source ﬁle management
tool that allows users to browse ﬁles and archives, copy ﬁles
from one folder to another, and delete ﬁles [4]. Midnight
Commander is vulnerable to a memory-error attack associ-
ated with accessing an uninitialized buﬀer when processing
symbolic links in tgz archives [3]. We used Midnight Com-
mander version 4.5.55 for our experiments.
4.5.1
Security and Resilience
Our security and resilience workload contains a tgz archive
designed to exploit this vulnerability. On this workload, the
Standard version terminates with a segmentation violation
when the user attempts to open the problematic tgz archive.
The Check version terminates with an error message.
The Boundless version, on the other hand, executes through
the memory errors to correctly display the names of the two
symbolic links in the archive. It continues on to correctly
execute additional user commands; in particular, the user
can continue to use Midnight Commander to browse, copy,
or delete other ﬁles even after processing the problematic
tgz archive.
4.5.2 Performance
Figure 5 presents the request processing times for the
Standard and Boundless versions of Midnight Commander.
All times are given in milliseconds. The Copy request copies
a 31Mbyte directory structure, the Move request moves a
directory of the same size, the MkDir request makes a new
directory, and the Delete request deletes a 3.2 Mbyte ﬁle.
We performed each request at least twenty times and report
the means and standard deviations of the request processing
times.
Request
Copy
Move
MkDir
Delete
Boundless
Standard
556 ± 1.54%
377 ± 0.71%
0.30 ± 2.45 % 0.424 ± 1.69%
0.69 ± 7.05%
1.40 ± 7.78%
2.94 ± 14.6%
2.54 ± 11.26%
Slowdown
1.5
1.4
2.0
1.2
Figure 5: Request Processing Times for Midnight
Commander (milliseconds)
As these numbers indicate, the Boundless version is not
dramatically slower than the Standard version. Moreover,
because Midnight Commander is an interactive program, its
performance is acceptable as long as it feels responsive to
its users, and these performance results make it clear that
the application of boundless memory blocks to this program
should not degrade its interactive feel. Our subjective expe-
rience conﬁrms this expectation: all pause times are imper-
ceptible for both the Standard and Boundless versions.
4.5.3
Standard Usage
For our standard usage workload, we used the Boundless
version of Midnight Commander intensively for one hour.
During this session, we copied, moved, browsed, and searched
ﬁles, and we created and deleted directories. We periodically
triggered the memory error discussed above by entering the
problematic tgz ﬁle. We conﬁgured this version to gener-
ate an error log. This log shows that Midnight Commander
has a memory error that is triggered whenever a blank line
occurs in its conﬁguration ﬁle. We veriﬁed that this error
completely disabled the Check version until we removed the
blank lines. The Boundless version, on the other hand, ex-
ecuted successfully through all memory errors to perform
ﬂawlessly for all requests.
During our one hour session, we logged a total of 16,788
out of bounds accesses, of which 5,462 were reads to unini-
tialized locations. As we will discuss in Section 4.7, Midnight
Commander is the only benchmark that contains reads to lo-
cations that were not previously written by a corresponding
out of bounds write. All of the out of bounds reads in all of
our other benchmarks access locations that were previously
stored in the hash table.
4.6 Apache
The Apache HTTP server is the most widely used web
server in the world; a recent survey found that 64% of the
web sites on the Internet use Apache [7]. The Apache 2.0.47
mod alias implementation contains a vulnerability that, un-
der certain circumstances, allows a remote attacker to trig-
ger a memory error [1].
Proceedings of the 20th Annual Computer Security Applications Conference (ACSAC’04) 
1063-9527/04 $ 20.00 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 11:38:47 UTC from IEEE Xplore.  Restrictions apply. 
4.6.1
Security and Resilience
Our security and resilience workload contains a request
that exploits the security vulnerability described above. The
Apache server maintains a pool of child processes; each re-
quest is handled by a child process assigned to service the
connection carrying the request [35].
With Standard compilation, the child process terminates
with a segmentation violation when presented with the at-
tack. The Apache parent process then creates a new child
process to take its place. The Check version correctly pro-
cesses legitimate requests without memory errors until it is
presented with the attack. At this point the child process
serving the connection detects the error and terminates. The
parent Apache process then creates a new child process to
take its place. In the Boundless version, the child process
executes successfully through the attack to correctly process
subsequent requests.
Because Apache isolates request processing inside a pool
of regenerating processes, the Check version eliminates the
security vulnerability while enabling the server to process
subsequent requests. The overhead of killing and restarting
child processes, however, makes this version vulnerable to
an attack that ties up the server by repeatedly presenting it
with requests that trigger the error.
4.6.2 Performance
Figure 5 presents the request processing times for the
Standard and Boundless versions of Apache. All times are
given in milliseconds. The Small request serves an 5KByte
page (this is the home page for our research project); the
large request serves an 830KByte ﬁle used only for this ex-
periment. Both requests were local — they came from the
same machine on which Apache was running. We performed
each request at least twenty times and report the means and
standard deviations of the request processing times. These
numbers indicate that the use of boundless memory blocks
in this context entails a negligible slowdown, for both small
and large requests.
Request
Small
Large
Standard
Boundless
44.4 ± 1.3% 46.8 ± 1.1%
48.7 ± 1.8% 50.2 ± 3.9%
Slowdown
1.05
1.03
Figure 6: Request Processing Times for Apache
(milliseconds)
4.6.3
Standard Usage
For our standard usage workload, we used the Bound-
less version of Apache to serve the web site of our research
project (www.flexc.csail.mit.edu). For one hour, we re-
quested ﬁles from this web site, periodically presenting the
web server with requests that triggered the vulnerability dis-
cussed above. The Boundless version executed successfully
through all of these attacks to continue to successfully ser-
vice legitimate requests. During our one hour session, we
logged a total of 347 out of bounds accesses. All of the
out of bounds reads retrieved values which were previously
stored in the hash table.
In addition to this workload, we used the Boundless ver-
sion for one week to serve all requests directed to our re-
search project’s web site. This web site was in more or
less steady use throughout this time period; we measured
approximately 400 requests a day from outside our institu-
tion. We also generated tens of thousands of requests from
another local machine, all of which were served correctly.
During this time period we periodically presented the web
server with requests that triggered the vulnerability dis-
cussed above. The Boundless version executed successfully
through all of these attacks to continue to successfully ser-
vice legitimate requests. We observed no anomalous behav-
ior and received no complaints from the users of the web
site.
4.7 Discussion
Our results show that boundless memory blocks enable
our programs to execute through memory-error based at-
tacks to successfully process subsequent requests. Even un-
der very intensive workloads the Boundless versions pro-
vided completely acceptable results. We stress that we chose
the programs in our study largely based on several factors:
the availability of source code, the popularity of the ap-
plication, the presence of known memory errors as docu-
mented on vulnerability-tracking web sites such as Security
Focus [11] and SecuriTeam [10], and our ability to reproduce
the documented memory errors. In all of the programs that
we tested, Boundless computing successfully eliminates the
negative consequences of the error — the programs were,
without exception, invulnerable to known security attacks
and able to execute through the corresponding memory er-
rors to continue to successfully process their normal work-
load. These results provide encouraging evidence that the
use of boundless memory blocks can go a long way towards
eliminating out of bounds accesses as a source of security
vulnerabilities and fatal programming errors.
One interesting aspect of our results is that although our
programs generated out of bounds read accesses, in only one
of these programs did any of these accesses read uninitialized
values that were not previously written by a corresponding
out of bounds write. This result indicates that developers
are apparently more likely to incorrectly calculate a correct
size for an accessed memory block (or fail to include a re-
quired bounds check) than they are to produce a program
that incorrectly reads an uninitialized out of bounds mem-
ory location.
5. RELATED WORK
We discuss related work in the areas of continued execu-