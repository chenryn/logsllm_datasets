the different versions of the Android platform.
• WebView Information Leaks. WebView is an important
gadget in the Android Framework that is responsible for
rendering web contents. In some Android versions, the
WebView component is buggy and may cause information
leaks when programmed in certain patterns (e.g., CVE-
2014-6041). We summarized these potentially vulnerable
code patterns and try to identify them in our data set.
• SSL Hijacking. SSL hijacking has become a common
security ﬂaw in mobile apps in recent years [25]. The
root cause of this ﬂaw is that mobile apps fail to check
the SSL certiﬁcates of the servers they communicate
with, thus vulnerable to man-in-the-middle attacks when
the mobile devices are connected to untrusted networks.
In our evaluation, we focus on detecting inappropriate
implementations of HTTPS communications in Android
apps.
• FileCross. Android browsers support the URI scheme
of file://. FileCross refers to the vulnerabilities that
exploit the ﬁle access URL to inject malicious JavaScript
code into the ﬁle system and steal on-device data [26].
B. Detecting Vulnerable Apps
Again, we employ SmartDroid [17] as the vulnerability
detector to obtain the ground truth about whether an Android
app is vulnerable or not. As previously mentioned, SmartDroid
3http://www.cvedetails.com/product/19997/Google-
Android.html?vendor id=1224
TABLE XIII: Vulnerable Libraries
# types of vulnerabilities
DoS
WebView leaks
SSL Auth Flaw
FileCross
DoS & WebView leaks
DoS & SSL Auth Flaw
DoS & FileCross
SSL Auth Flaw & WebView leaks
SSL Auth Flaw & FileCross
WebView & FileCross
DoS & SSL Auth Flaw & WebView leaks
DoS & SSL Auth Flaw & FileCross
DoS & WebView leaks & FileCross
SSL Auth Flaw & WebView Leaks & FileCross
DoS & WebView Leaks& SSL Auth Flaw & FileCross
Total
# Vulnerable libraries
2,659
2,141
2,020
311
27
865
1,428
23
22
867
12
233
42
35
116
10,801
can only detect vulnerabilities at the granularity of apps but not
third-party libraries. Our modiﬁcation of the original analysis
system improved the situation by narrowing the vulnerable
scope from the entire app to code blocks.
C. Evaluating Vulnerable Library Detection
The result of the modiﬁed vulnerability analysis system
shows that our third-party library detection approach is sen-
sitive to vulnerable libraries. All the vulnerable libraries are
real and may threaten massive apps at the same time.
As is shown in Section IV, we found a considerable number
of different versions of the same library, while only some
of them are indeed vulnerable. In total, we detected 10,801
vulnerable third-party libraries with a clustering threshold of
10 (see §IV-C for threshold selection). The vulnerable libraries
account for 17.7% of all libraries, indicating that third-party
libraries are not as secure as assumed by some previous
research. Threats of defective third-party libraries needs to be
thoroughly considered.
In our case study, we noticed that a library can be affected
by multiple vulnerabilities. Table XIII shows the statistics
about this phenomenon. According to our results, 34.0% of the
vulnerable libraries contains more than one vulnerability. For
these libraries, the most common vulnerability combination
is DoS and FileCross. This is an alarming fact since the two
defects can easily form a realizable attack sequence. Attackers
can ﬁrst exploit FileCross to deploy and execute malicious
JavaScript code on a victim device; the malicious JavaScript
can then easily trigger the DoS attack.
D. Further Analysis
To obtain a deeper understanding on the characteristics of
detected vulnerable libraries, we further manually inspected
the top 200 most popular ones, ranked by the number of apps
affected. Table XIV and Table XV list the separated rankings
of the top 10 most popular obfuscated and unobfuscated
vulnerable libraries, respectively, showing library names, the
count of apps including them, and the types of vulnerabilities
reported. The 200 analyzed libraries cover all those listed in
Table XIV and Table XV. For each manually inspected library,
we randomly picked an instance from each corresponding
cluster.
We designed a systematic protocol to manually inspect the
library instances covered by Table XIV and Table XV. For
15
the obfuscated libraries, the two research questions to answer
are: “what are their identities?” and “what are their main
functionalities?”. We developed the answers mostly through
reverse engineering. The typical procedure for revealing the
true identity of each library instance is to dump all string
literals used by the library code and see if any of them
indicates library name. For example, many libraries produce
logs during execution and prepend their names to each log
entry. Regarding the second research question, for most ob-
fuscated libraries, it is easy to learn their functionalities from
the Internet once the library name is revealed. Rarely, for
those that lacks online information, we needed to additionally
analyze their decompiled code. For unobfuscated libraries, our
primary goal was to conﬁrm their identities and investigate
whether they were ever published by a third-party library
developer and provided to other app vendors. If so, we would
collect all historical versions of that library published by its
developer and see if the instance in our dataset matches any
of these versions.
Two authors participated in the manually analysis. In order
to avoid biases caused by different personal reverse engineer-
ing experiences, the two authors were asked to start with a
small subset of 20 libraries and cross-validate results from
each other. All conﬂicts about the results the were resolved
with face-to-face discussions before the two participants pro-
ceeded to inspect the whole dataset. During the discussion,
we found that for most sampled libraries, the functionality
can be made clear through online information once their
identities were conﬁrmed. The conﬂicts were mostly caused
by the carelessness of one of the manual analysis participants.
Therefore, we did not design a similarity measure for deciding
the functionality but
totally relied on qualitative methods.
More details about the manual analysis process can be found
in Appendix B.
Through the manual analysis, we have summarized two
interesting empirical ﬁndings. The ﬁrst one is that the renamed
libraries are not always constructed by random characters.
Instead, some of the modiﬁcations are manually done. We
found two cases of this phenomenon. The ﬁrst case is a
pair of libraries named /com/wendyapp/wps and /com/
lovepop/flystart. If solely judging from their names,
we consider that they are instances of different libraries that
likely provide different functionalities. But after inspecting
the decompiled code, we found that their code structures are
almost identical. Even the positions and frequencies of the
used APIs are the same. So we conclude that at least one
of the names of the two libraries was obfuscated. In order
to pick out the original library name, we check both their
names with DNS. It turns out that the original name of this
library is /com/lovepop/flystart. This is an ads library
used for recommending magical pop-up greeting cards for
weddings. Based on this knowledge, the other name (/com/
wendyapp/wps) is highly likely to be an obfuscated one and
we do not ﬁnd any results on this name as an web domain.
Indeed, this name does not look like the other obfuscated
library names with random sequence of characters. The second
case is the pair of /com/charry/android and /com/
flurry/android. Note that this pair is among the top 10
most popular obfuscated libraries (Table XIV). This indicates
that although manually renamed libraries are rare, they could
have a considerable impact in the app markets.
The second empirical ﬁnding is that the renaming-based
obfuscations are mostly applied to ﬁnance-related libraries,
such as ads libraries. In particular, we found that 7 of the 10
libraries in Table XIV can be related to Google’s advertising
library, suggesting that Google’s library might be the prototype
of a large number of obfuscated ads libraries in the markets
we analyzed and the vulnerabilities in Google’s library were
inherited by those obfuscated ones.
Typically, an ads library will credit the developer when an
ad is successfully presented by the hosting app and clicked by
a user. For example, the Google ads library will issue Google
money once the ads in the insert app are pressed on the screen.
But not all the obfuscated Google ads libraries, especially the
manually obfuscated libraries, give money to Google as the
original library is designed to. Once the modiﬁcation of a
library has changed the destination of the ﬁnancial ﬂow from
Google to another third-party account, this modiﬁed library
would steal money that was supposed to be sent to Google.
This modiﬁed library should be regarded as malicious. We
manually analyze these libraries in the table and conﬁrm that
Library /com/nainaidu/ads is malicious. As for the other
modiﬁed or obfuscated libraries, we did not ﬁnd clear clues
indicating that they are depositing funds to other account, but
they are still suspicious. In our deduction, the adversary should
have found some DoS or WebView related vulnerabilities in
some speciﬁc versions of the Google ads library and modiﬁed
both the names and corresponding code inside to make sure
that
these modiﬁed versions would not be covered when
Google update its ads library.
Table XV shows the ten most commonly unobfuscated
libraries. All these libraries are developed by large Internet
enterprises. According to our result,
they are pervasively
spread in apps provided by third-party software markets in
China. Once a vulnerability is exploited in any instance of
these libraries, it is likely that the impact will be quickly
radiated to a massive number of apps. It may be surprising
that these libraries are not reported to be obfuscated by LibD,
which means there are no other libraries that share the same
signature with them. With the above analysis results, we
can conclude that these libraries are not tampered with by
malicious parties. Therefore, the vulnerabilities discovered in
Table XV are surely introduced by the original developers of
these libraries.
In Section III-D1, we introduced the RPC vulnerability
residing in the library of Baidu moplus SDK [20], which is
also set as target of the modiﬁed SmartDroid system. After
analyzing all
the libraries and apps, we found that 2,012
different apps in our dataset are tainted by 15 different versions
of the library containing this ﬂaw.
VII. LIMITATIONS OF LIBD
Compared with previously work, LibD has advanced the
state of the art in several aspects. Yet, the technique has
limitations and some of them can be potentially addressed.
16
TABLE XIV: Obfuscated Vulnerable Libraries
Rank
1
2
3
4
5
6
7
8
9
10
#Vul-Library
(Count)
/org/gg/music/
......
/com/google/ydd/
Total Num: 20
/com/tencent/a/
/com/tencent/b/
Total Num: 2
/com/gg/sda/
......
/cof/gootle/adz/
Total Num: 14
/com/baidu/location/
/com/a/a/
Total Num: 2
/com/sdf/ads/
......
/com/google/ads
Total Num: 17
/com/nainaidu/ads
......
/com/go2/ads/
Total Num: 12
/com/xxgg/abs/
/com/google/ads/
......
/com/tgxsw/ads/
Total Num: 8
/com/google/ads/
......
/cn/google/ads/
Total Num: 10
/com/charry/android/
......
/com/ﬂurry/android/
Total Num: 2
/com/cccccc/android/
/com/millennia
lmedia/android/
Total Num: 2
# Number of
affected apps
Vulnerabilities
58,976
DoS, WebView
24,012
DoS, WebView
17,706
DoS, WebView
17,679
DoS, WebView
16,323
DoS, WebView
13,300
DoS, WebView
9,524
DoS, WebView
9,447
DoS, WebView
4,471
DoS, WebView,
SSL Auth Flaw,
FileCross
4,310
DoS, WebView
TABLE XV: Unobfuscated Vulnerable Libraries
Rank
Library Name
1
2
3
4
5
6
7
8
9
10
/com/tencent/mm
/com/tencent/mm
/com/tencent/mm
/m/framework/network
/com/tencent/connect
/com/baidu/location/
/com/tencent/weibo/
/com/amazon/inapp/
/com/tencent/qqconnect/
/com/tencent/mm/
# Number of
affected apps
43,731
33,491
30,100
27,854
20,433
17,973
1,750
17,001
15,057
13,798
Vulnerabilities
DoS, WebView
Dos, WebView
DoS, WebView
SSL Auth
DoS, FileCross
DoS, WebView
DoS, FileCross
DoS, WebView
DoS, WebView
DoS, WebView
A number of these limitations originate from the fundamental
technical challenges in Android app analysis, which we call
the general limitations because they are shared by a large
number of Android app analysis techniques. The others are
more related to the current design and implementation of
LibD, thus called specialist limitations.
A. General Limitations
1) Packers: During our evaluation, we noticed that some
samples cannot be correctly unpacked or decompiled. This
prevents further analysis of LibD since we need the opcodes
to compute the signatures. Investigations showed that these
apps had been processed by the so-called Android “packers”.
17
Generally speaking, packers are tools that can transform APK