tiple AV engines to the same set of samples, an optional list of
AV engines whose labels to use, a set of tagging rules, an optional
set of expansion rules, and a taxonomy. For each input sample, it
outputs a set of tags ranked by the number of AV engines including
the tag’s concept in their label. AVclass2 comprises of three steps:
tokenization, tagging, and expansion. To illustrate them we use the
running example in Figure 3. The inputs are the labels assigned by
four AV engines to the same sample, shown in Figure 3a.
2.VIPRE"Trojan.Win32.CoinMiner.c"3.Agnitum"Bebeg.RiskTool.BitCoinMiner!FwnP7UHRdLc"4.AVG"Skodnab.BitCoinMiner.EQ"(a)InputAVlabels2.VIPRE"trojan","win","coinminer","c"3.Agnitum"bebeg","risktool","bitcoinminer"4.AVG"skodna","bitcoinminer","eq"(b)Aftertokenization2.VIPRE"windows","bitcoinminer"3.Agnitum"bebeg","grayware","tool","bitcoinminer"4.AVG"skodna","bitcoinminer"(c)Aftertagging"CLASS:miner:bitcoinminer","CLASS:miner","BEH:mining:bitcoinmining","BEH:mining"2.VIPRE"FILE:os:windows","CLASS:miner:bitcoinminer","CLASS:miner","BEH:mining:bitcoinmining","BEH:mining"3.Agnitum"FAM:bebeg","CLASS:grayware","CLASS:grayware:tool","CLASS:miner:bitcoinminer","CLASS:miner","BEH:mining:bitcoinmining","BEH:mining"4.AVG"UNK:skodna","CLASS:miner:bitcoinminer","CLASS:miner","BEH:mining:bitcoinmining","BEH:mining"(d)AfterexpansionCLASS:miner:bitcoinminer3CLASS:grayware2BEH:mining6BEH:mining:bitcoinmining3FAM:bebeg2(e)OutputFigure3:Runningexample.evolutionisachallenge.Itrequirestoconstantlyevolvethetax-onomy,taggingrules,andexpansionruleswithnewconceptsandpreviouslyunknownrelations.ThosenewconceptswillappearintheoutputofAVclass2asunknowntokens,notpresentinthetaxonomyandtaggingrules.Manuallycategorizingthoseunknowntokensdoesnotscaletothehugenumbersofnewsamplesasecu-rityvendormayobserveeachday.Weneedautomaticapproachestokeeplabelingandtaggingtoolsup-to-date.Tothisend,AVclass2providesanupdatemoduletoautomati-callyupdatetheinputtaxonomy,taggingrules,andexpansionruleswithnewconceptsandrelations.Theupdatemodulefirstidentifiesco-occurrencerelationsoftokensinAVlabels.Co-occurrenceinAVlabelswasintroducedinVAMO[32]andlaterusedinAVClass[35]andEuphony[9]toidentifyfamilyaliases.But,theupdatemoduleinAVclass2takesthisconceptastepfurtherbyintroducinganovelrecursiveprocessthatfirstidentifiesrelationsbetweenunknowntokensandtagsandthenusesasetoflearningrulestoclassifythoserelationsandproposeupdatestothetaxonomy,taggingrules,andexpansionrules.3LABELINGMODULEThelabelingmoduletakesasinputtheAVlabelsassignedbymul-tipleAVenginestothesamesetofsamples,anoptionallistofAVengineswhoselabelstouse,asetoftaggingrules,anoptionalsetofexpansionrules,andataxonomy.Foreachinputsample,itoutputsasetoftagsrankedbythenumberofAVenginesincludingthetag’sconceptintheirlabel.AVclass2comprisesofthreesteps:tokenization,tagging,andexpansion.ToillustratethemweusetherunningexampleinFigure3.TheinputsarethelabelsassignedbyfourAVenginestothesamesample,showninFigure3a.Tokenization.TakesasinputanAVlabelandoutputsthelistoftokensthelabelcontains.ThetokenizationinAVclass2isalmostidenticaltothatofAVclassandwereferthereadertotheoriginalpaperfordetails[35].TheonlysignificantdifferenceisthatAV-class2doesnotfilteroutshorttokens(lessthanfourcharacters)duringtokenization,butratheraftertagging.ThisenablesAVclasstoextracttagsfromshorttokensthatcorrespondtowell-knownconcepts,e.g.,irc,bot.Figure3bshowsthetokensobtainedinourrunningexample.Tagging.Takesasinputthetokensobtainedfromthetokenizationandtheinputtaggingrules.Foreachinputtoken,ifataggingruleexistsforthetoken,itappliesittoobtainalistoftags.Ifthetokenisgeneric,itisremoved.Ifnotaggingruleexistsforthetoken,itiskept.Itoutputsalistofidentifiedtagsandanyremainingunknowntokens.Figure3cshowsthetaggingoutput.Sometokenshavebeenreplacedbytheirtags,e.g.,tokenwinbytagwindowsandtokenrisktoolbytagsgraywareandtool.Othertokenshavebeendroppedasgeneric(e.g.,trojan)orbecausetheyareshort(e.g.,eq).Expansion.Takesasinputthefilewithexpansionrules,thetax-onomy,andthetagsoutputbythetagging.Foreachtag,ifanexpansionruleexistsforit,itappliestheruletoobtainalargerlistoftargettagsthatreplacesthetag.Unknowntokensarenotaffectedbytheexpansion.Theexpansionfirstappliestheinter-categoryexpansionrulesprovidedasinputtoAVclass2.Next,itappliestheimplicitintra-categoryexpansionrulesduetotheparent-childtagrelationshipsinthetaxonomy.Forexample,inourrunningexampletagbitcoinminerimpliestagCLASS:miner.Output.Foreachtagandunknowntoken,AVclass2countsthenumberofAVlabelswhereitappears.Thiscountcanbeinterpretedasaconfidencescore.TagsandunknowntokensthatappearinthelabelofatmostoneAVengineareremoved.Thisfiltersrandomunknowntokensthatearlierstepsmayhavemissed,asthelikeli-hoodthatthoseappearinlabelsfrommultipleAVenginesislow,aswellasverylowconfidencetags.TheoutputofAVclass2isthelistoftagsandunknowntokensalongwiththeirconfidencescore.Figure3eshowstheoutputofourrunningexamplewhereunknowntokenskodna,aswellastagFILE:os:windows,havebeenremovedbecausetheyonlyappearedinonelabel.AVclass2alsoprovidesacompatibilitymodewithAVclasstooutputthemostlikelyfamilyforeachsample,whichcorrespondstothehighestrankedfamilytagorunknowntoken.i.e.,FAM:bebeginourrunningexample.4UPDATEMODULETheupdateprocesscomprisesoftwosteps.Whenlabelingadataset,AVclass2outputsco-occurrencestatisticsbetweentagsandun-knowntokens.Thelargerthedataset,thehigherconfidenceintheidentifiedco-occurrencestatistics.Theupdatemoduletakesasin-puttheco-occurrencestatistics,thetaxonomy,andthetaggingandexpansionrules.Itperformstwosubsteps:identifyingstrongrela-tionsandconvertingstrongrelationsintoupdatestotheinputfiles.Theprocessofgeneratingco-occurrencestatisticsandidentifyingstrongrelationsissimilartotheoneusedbyAVclasstodetectaliasrelations[35].Thenovelpartoftheupdatemoduleistherecursiveprocessandupdaterulesusedtoautomaticallygenerateupdatestothetaxonomy,taggingrules,andexpansionrules.ACSAC 2020, December 7–11, 2020, Austin, USA
Silvia Sebastián and Juan Caballero
Table 2: Update module rules.
Cat(𝑡𝑖) Cat(𝑡 𝑗 ) Rule
UNK
UNK
UNK
UNK
UNK
FAM
FILE
FAM
FAM
FAM
FAM
CLASS
CLASS
FAM
CLASS
BEH
FILE
UNK
UNK
UNK
FAM
FILE
BEH
CLASS
FILE
BEH
tagging(𝑡𝑖, 𝑡 𝑗 , FAM)
taxonomy(𝑡𝑖, FAM:𝑡𝑖)
taxonomy(𝑡𝑖, FAM:𝑡𝑖)
taxonomy(𝑡𝑖, path(𝑡 𝑗 ):𝑡𝑖)
taxonomy(𝑡𝑖, FAM); taxonomy(𝑡 𝑗 , FAM)
tagging(𝑡𝑖, 𝑡 𝑗 , FAM)
tagging(𝑡𝑖, 𝑡 𝑗 , prefix(𝑡𝑖))
tagging(𝑡𝑖, 𝑡 𝑗 , prefix(𝑡 𝑗 ))
expansion(𝑡𝑖, 𝑡 𝑗 )
expansion(𝑡𝑖, 𝑡 𝑗 )
expansion(𝑡𝑖, 𝑡 𝑗 )
expansion(𝑡𝑖, 𝑡 𝑗 )
expansion(𝑡𝑖, 𝑡 𝑗 )
|𝑡𝑖 |
|(𝑡𝑖,𝑡 𝑗) |
Co-occurrence statistics. The labeler obtains the co-occurrence
statistics after tagging and before expansion. For simplicity, in
this section we call tags to both tags and unknown tokens. We
call relation to each pair of tags that appear in labels for the same
sample and its co-occurrence statistics. For each relation, the labeler
outputs seven values: the tags 𝑡𝑖, 𝑡 𝑗, the number of samples each
tag appears in the dataset being labeled |𝑡𝑖|, |𝑡 𝑗|, the number of
samples where both tags appear |(𝑡𝑖, 𝑡 𝑗)|, and the fraction of times
|(𝑡𝑖,𝑡 𝑗) |
that both tags appear in the same samples 𝑟𝑒𝑙(𝑡𝑖, 𝑡 𝑗) =
and 𝑟𝑒𝑙(𝑡 𝑗 , 𝑡𝑖) =
. The two tags are sorted so that tag 𝑡𝑖 is
|𝑡 𝑗 |
the one that occurs less often, i.e., |𝑡𝑖| ≤ |𝑡 𝑗|, which means that
𝑟𝑒𝑙(𝑡𝑖, 𝑡 𝑗) ≥ 𝑟𝑒𝑙(𝑡 𝑗 , 𝑡𝑖).
Identifying strong relations. Given the set of relations output
by the labeler, the update module first filters out weak relations.
A relation is strong if both tags have been seen in enough number
of samples and appear in the same samples frequently enough.
The first condition keeps only relations where 𝑚𝑖𝑛(|𝑡𝑖|,|𝑡 𝑗|) ≥ 𝑛
where 𝑛 is the minimum number of samples where a tag should
have been observed. The second condition keeps only relations
where 𝑟𝑒𝑙(𝑡𝑖, 𝑡 𝑗) ≥ 𝑇 . Threshold 𝑇 controls the minimum joint
frequency to determine a relation is strong. For strong relations, we
say that 𝑡𝑖 implies 𝑡 𝑗, 𝑡𝑖 ⇒ 𝑡 𝑗, but 𝑡 𝑗 may not imply 𝑡𝑖. For example,
if family tag virut appears in 1M samples and class tag virus in
7M samples, and in every sample virut appears virus also appears
(𝑟𝑒𝑙(𝑣𝑖𝑟𝑢𝑡, 𝑣𝑖𝑟𝑢𝑠) = 1.0), then virut ⇒ virus, but virus ⇏ 𝑣𝑖𝑟𝑢𝑡 as
there are 6M instances were virus is observed without virut, likely
corresponding to other virus families (𝑟𝑒𝑙(𝑣𝑖𝑟𝑢𝑠, 𝑣𝑖𝑟𝑢𝑡) = 0.14). If
both 𝑟𝑒𝑙(𝑡𝑖, 𝑡 𝑗) ≥ 𝑇 and 𝑟𝑒𝑙(𝑡 𝑗 , 𝑡𝑖) ≥ 𝑇 we say the tags are equivalent,
𝑡𝑖 ⇔ 𝑡 𝑗. Parameters 𝑛 and 𝑇 were empirically selected in AVclass
and we use their suggested default values of 𝑛 = 20 and 𝑇 = 0.94.
Weak relations and relations including a OS tag are removed.
The latter avoids that an expansion rule is created for each family
towards its platform, e.g., virut ⇒ windows, droidkungfu ⇒ android.
Updates to taxonomy and tagging. The update module performs
a recursive process where each iteration examines the set of remain-
ing relations. The process starts with the identified strong relations.
At each iteration, every remaining relation is checked against a
set of rules to identify updates to the current taxonomy, tagging,
and expansion rules. Processed relations are removed, the rest are
kept. Once all relations are examined, the process runs into a new
iteration with the remaining relations. Recursion ends when one
iteration does not produce any updates or no relations remain.
Each relation is first checked to see if it is already known. A
relation is known if it is already captured in the current taxonomy,
tagging rules, or expansion rules. For example, adware ⇒ grayware
is implicit in the default taxonomy. This check happens before each
relation is processed because the taxonomy, tagging, and expansion
rules change as relations are processed and a relation that was not
known before may become known once other relations have been
processed. Known relations are removed. If not known, and the tags
are equivalent, a tagging rule is added from 𝑡𝑖 to 𝑡 𝑗 since 𝑡𝑖 is the
least common of the two tags. If not an equivalence, the relation is
processed according to the rules in the top block of Table 2, which
are indexed by the categories of the two tags. UNK is a pseudo-
category for unknown tags not in the taxonomy (i.e., unknown
tokens). All rules, but the last one, handle relations where at least
one tag is unknown. These rules create a tagging rule between the
two tags or add the unknown tag to the taxonomy with a path
prefix indicated by the rule. For example, the top rule captures that
an unknown tag implies a family tag, which creates a tagging rule
capturing that the unknown tag 𝑡𝑖 is an alias for the family tag 𝑡 𝑗.
Adding a tagging rule 𝑡𝑖 ⇒ 𝑡 𝑗 forces 𝑡𝑖 to be removed from the
taxonomy (if present) and 𝑡 𝑗 to be added (if it did not exist). The
last rule in the block creates a tagging rule for a relation between
family tags indicating that 𝑡𝑖 is an alias for 𝑡 𝑗 and thus 𝑡𝑖 does not
need to be in the taxonomy.
Updates to expansions. Since expansions happen between two
tags in the taxonomy it is more efficient to identify them once all
rules for unknown tags have been applied and the taxonomy and
tagging rules are stable. Once the recursion ends, all remaining
rules are examined using the expansion rules in the bottom block
of Table 2. The expansion rules capture properties of a family such
as its class, file properties or behaviors, as well as a class having
specific behaviors or file properties (e.g., using a exploit).
The five categories (including UNK), create 25 distinct category
pairs. However, only 13 pairs are considered in Table 2. There
exist 12 category pairs without a rule. Our evaluation will show
that those pairs constitute less than 1% of relations and when they
happen they indicate some collision that we believe is best resolved
manually by an analyst.
Once the process finishes the update module outputs the up-
dated taxonomy, tagging and expansion rules. Most updates will
be additional tags in the taxonomy and new tagging and expansion
rules, but it is possible that some original taxonomy entries and
tagging rules have been modified or removed.
5 EVALUATION
This section evaluates AVclass2. First, Section 5.1 presents the
datasets used. Then, Section 5.2 details the tagging results and
Section 5.3 demonstrates the update module. Section 5.4 illustrates
the benefits of AVclass2. Finally, Section 5.5 compares AVclass2
with prior family tagging tools AVclass and Euphony.
AVclass2: Massive Malware Tag Extraction from AV Labels
ACSAC 2020, December 7–11, 2020, Austin, USA
Table 3: Datasets used in evaluation.
Plat. GT
Dataset
Superset
Mix
✗
Lever et al. [20] Win
✗
Andropup
And
✗
Miller et al. [26] Win
✗
And
Andrubis [23]
✗
Win
Malsign [19]
✓
AMD [38]
And
✓
Win
Malicia [29]
✓
And
Drebin [1]
✓
Malheur [34]
Win
✓
MalGenome [39] And
✓
Samples Bin. Collection
42,533,619
37,817,328
3,145,283
1,079,783
422,826
142,500
24,553
9,908
5,560
3,131
1,260
08/2008 - 05/2019
01/2011 - 08/2015
05/2019 - 09/2019
01/2012 - 06/2014
06/2012 - 06/2014
06/2012 - 02/2015
11/2010 - 03/2016
03/2012 - 02/2013
08/2010 - 10/2012
08/2009 - 08/2009
08/2008 - 10/2010
✗
✗
✗
✗
✗
✗
✓
✓
✓
✗
✓
Table 4: Percentage of samples for which a tag could be ex-
tracted, as well as percentage of tagged samples with a tag
from each category.
Tagged
Dataset
Superset
Lever
Andropup
Miller
Andrubis
Malsign
All
97%
98%
89%
95%
100%
99%
AMD 100%
100%
100%
100%
100%
Malicia
Drebin
Malheur
MalGen.
VT≥4
100%
100%
99%
99%
100%
99%
100%
100%
100%
100%
100%
FILE CLA BEH FAM UNK
13%
99%
13%
99%
98%
16%
20%
100%
4%