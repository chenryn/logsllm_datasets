rithm coupled inside a reader or card party. In the latter case,
the input has to specify the coupling.
The challenger looks in its list P and if the party exists,
it changes its status to “corrupt”. Otherwise, if the input is
malformed or the checks fail, the challenger discards the call.
• term(E)
This oracle terminates all the running sessions of the party
E. This gets recorded in the list P (where the party E is made
inactive), and in the lists Sess where its sessions are set to
“finished”.
• move(E, loc)
This oracle moves a party E from its location to another
point loc in the metric space. The challenger Ch checks in
P that the party E is of type card and that it is corrupt. In
this case, the challenger calculates the difference between
E’s current location loc1 (found in P) and loc, and in pro-
portional amount of time, it updates11 its records in P to
stipulate that E is at location loc.
• check_prox(sid)
The challenger checks that sid is a valid session for [PC,T ].
If so, it takes its transcript from Sess and passes it to [PC,T ].
From this, the attacker is given: Out[PC,T ] and τ[PC,T ], i.e.,
the public output and the private output of [PC,T ], as well
as the id of the card C and reader R who were measured by
[PC,T ].
• validate_prox(sid)
The challenger checks that sid is a valid session id for W .
If so, it takes its transcript from Sess and passes it to the
coupling [W , X]. From this, the attacker is given: OutW and
τW , i.e., the public output and the private output of W , as
well as the id of the card C and reader R who were measured
by [PC,T ] and revalidated by W .
In Sess, the entry for sid is marked as “finished”.
In Sess, the entry for sid is marked as “finished”.
Other Actions by the Challenger.The list Sess of sessions is
maintained by the challenger Ch also out-of-bound with the oracles
above. Namely, there is a time-keeping aspect that we mentioned in
Subsection 4.2.2 and Subsection 4.2.3: i.e., if certain messages in a
PC or W -linked session take too long to arrive, then that session is
marked as “finished” and the transcript contains OutPC=0, OutW =0
inside the list Sess.
Remarks on the v-DB Security Model. With respect to proximity-
checking, the model introduced above is arguably standard. Notably,
timing and distance-related aspects are explicit as in [14], with the
addition that it extends this to operate over couplings (intra and
across couplings). Of course, this is inherent to the fact that we
lift DB protocols to validated DB protocols; to this end, we also
10Note that this prioritisation mechanism also encapsulates blocking of any messages
by the adversary A.
11Note that “moves” of parties are also subject to same laws of physics as messages,
thus not hindering the latter.
Session 2: Authentication ASIA CCS '20, October 5–9, 2020, Taipei, Taiwan94incorporate the management of the communication (incl. timed as-
pects thereof) with [W , Y] with Y ∈ {C, R, X}. What this model has
that was notably not present in previous DB models is the fact that
the attacker can move (card) parties. Last but not least, our model
enjoys a precise session management, which is rooted primarily on
the fact that there are multiple parties involved in the primitive of
v-DB (compared to a standard “DB” primitive).
4.4 Security Properties for Validated Distance
Bounding
In this section, we define the correctness and security of v − DB
systems.
4.4.1 Correctness of v-DB Protocols. Now, in Def. 4.1, we define
what it means for a v-DB system to terminate and to run correctly.
Concretely, firstly, Def. 4.1 says that the no matter which algorithms
run on the card and reader, eventually PC and W terminate12. Sec-
ondly, Def. 4.1 says that if an arbitrarily fixed, honest card is close
to an arbitrarily fixed honest reader, coupled (in any way) with an
honest proximity-checking algorithm, then the proximity-checking
and the validating algorithms finish successfully with probability p.
Definition 4.1. Correctness of Validated Distance Bounding.
Let Π = (C,R, T , PC,W, B) be a v-DB protocol, and
real =(C, PC,T , R,W , X , B) be a validated DB system. We say that
Π
real are terminating and complete validated distance-bounding
Π and Π
if the following holds, respectively:
(Out sid
(PC,T )
= 1 ∧ Out sid′
= 1) : mid running
Pr
W (τ(PC,T ) )
rC ,rR ,rPC ,rT ,rW
sid, sid′ ∈ mid
for any arbitrarily fixed C, R, PC uncorrupted, for any arbitrarily
fixed T ,W , X, with rC , rR , rPC , rT , rW being the random coins in
the macro-session mid of the algorithms mentioned in the indices.
In practice, p the parameter for correctness (in Def. 4.1) needs
to be tuned with the parameters that will define our security (see
such tuning in e.g. [5]). However, for security to be meaningful we
require that p is always overwhelming in the security parameter.
4.4.2 Security of v-DB Protocols. We give our definition of se-
curity for v-DB systems in terms of a game. Roughly speaking, in
this game, the attacker can play with multiple cards, multiple read-
ers, and validating bodies, in a given coupling: either they are all
card-coupled or all reader-coupled. There is a target card and a
12In our model, this is in part guaranteed implicitly by the conditions mentioned in
Subsection 4.2.2 and Subsection 4.2.3 and incorporated formally in the challenger’s
behaviours.
• Termination:
(∀s)(∀C′ unbounded)(∀R′ unbounded),
for any init[C′, R′, (PC,T ),W , X] call yielding a macro-session
mid, it is the case that (PC,T ) and W halt in poly(s) computa-
tional steps and f inished is recorded in Sess for the sessions
of [PC,T ] and W corresponding to the macro-session mid,
where s is the security parameter;
• p-Completeness: (∀s), if distance (C, R) ≤ B, we have the
following:
for any init[C, R, (PC,T ),W , X] call yielding a macro-session
mid, with sid and sid′ being the respective sessions of [PC,T ]
andW corresponding to the macro-session mid, we have that
(cid:34)
(cid:35)
target reader. The attacker can open multiple sessions with each
such party. He can corrupt cards, readers and PC (at any point),
and he can move (corrupted) cards; some restrictions apply over
the different phases of the game. Indeed, the game has two phases:
(a) a learning phase in which the target parties may be in mutual
proximity but are not corrupt and nor is the PC on board one of
them. (b) an attack phase – in which the target parties are far away
and the one that has PC on board can be corrupted, as can its on-
board PC. As the corrupted PC is made to output 1 (i.e., lie about
the proximity of the target parties), the attacker wins if he manages
to make the validating party [W , X] also output 1. In other words,
the attacker wins if it is able to manipulate a number of parties,
possibly in a concurrent setting, in order to make the validating
algorithm be fooled w.r.t. to a lie by the corrupt PC algorithm, that
W is supposed to audit.
In fact this game-based definition can be split in two: (a) the case
where the PC is on-board the “target” reader; (b) the case where
the PC is on-board the “target” card. In each case, indeed, it yields
different security properties. In the second case, the attacker would
collude with a far-away PC-coupled card to mount a distance-fraud
that is undetected by the validating algorithm. In the first case,
the attacker would collude with a PC-coupled reader so that they
together mount a strong relay attack attack that is undetected by
the validating algorithm.
In our case, we define the case in a generic game, i.e., comprising
both of the above cases together. Then, we simply fork the two cases
for the security definitions. This generic game is captured in Def. 4.2
by the notion of (ℓ, z, n, qC , qR , qT , type)-v-DB experiment, where
type can be “card-coupled” or “reader-coupled”, ℓ are number of
card-parties, z are number of reader-parties, n are number of [PC,T ]
on-board algorithms and X-machines, qC , qR , qT are number of
sessions of type card, reader, and T , respectively.
≥ p,
Definition 4.2. (ℓ, z, n, qC, qR, qT, type)-v-DB Experiment. Let
Π an v-DB protocol. For any security parameter s, an
(ℓ, z, n, qC, qR, qT, type)-v-DB experiment is an interaction between
the Challenger and Adversary as follows:
(1) The Challenger setups a v-DB system with:
• ℓ > m card-parties C1 (·), . . . , Cm (·), . . . , Cℓ (· · · ) and a
card-party C (·);
• z reader-parties R1(·), . . . , Rp (·), . . . , Rz (·) and a reader
party denoted R(·);
• n on-board algorithms [PC1,T1], . . . , [PCn,Tn] and one
other on-board algorithm denoted [PC,T ];
• a n machines X1, . . . , Xn and one X-machine denoted X;
• apart from the cryptographic material used to authenticate
C to R, the other card-parties Cis and reader-parties Rjs
can respectively have the same cryptographic material13
used in the authentication part of the v-DB protocol Π.
13Whilst the devices are different, with different device ids, it is the case that e.g., two
cards are have the same cryptographic credentials. This, together with the corruption
powers described below, entails a powerful attacker model. I.e., in the learning phase
of the experiment, the attacker can corrupt a card-party Ci running on cryptographic
material x, making it behave as he pleases and potentially extracting x out of it. This
means that the attacker gets the capability to, e.g., sign, as a legitimate card based on
x. Moreover, in the attack phase of the experiment, another card-party Cj with the
same cryptographic material x can also be present (alongside the “learned” adversary),
only that this time we do restrict that Cj per se is un-corrupted.
Session 2: Authentication ASIA CCS '20, October 5–9, 2020, Taipei, Taiwan95where values m, ℓ, z, p, n are in poly(s), and all [PC,T ]s are
either coupled with the cards, or all with the readers14 (i.e.,
n=m or n=z). If the coupling of [PC,T ]s is with the cards,
then the type of the experiment is “card-coupled”; we call
this a card-coupled experiment.
If the coupling of [PC,T ]s is with the readers, then the type
of the experiment is “reader-coupled”; we call this a reader-
coupled experiment.
(a) If the experiment is a card-coupled experiment, then
the adversary can call corrupt(. . .) at any point, but the
only on card-parties and PC algorithms. And, not all card/PC
parties can be corrupted in any phase of the experiment.
(b) If the experiment is a reader-coupled experiment, then
the adversary can call corrupt(. . .) at any point, but only
on reader-parties and PC algorithms. And, not all reader/PC
parties can be corrupted in any phase of the experiment.
(c) Before any call by the adversary, the Challenger popu-
lates the P list as follows:
– for parties C1(·), . . . , Cm (·) and parties R1(·), . . . , Rp (·),
the positions are chosen arbitrarily in the Euclidean space;
– for card-parties Cm+1 (·), . . . , Cℓ (·), C (·), the reader-parties
Rp (·), . . . , Rz (·), R(·), the positions are chosen such that
the distance between any of these card and reader parties
are bigger than the bound B.
(2) In the learning phase of the experiment, the adversary is
allowed access to the first m out of ℓ card-parties and C (·),
the first p reader-parties and R(·), the [PC,T ] algorithms and
X machines fitting the coupling made with these card and
reader devices.
(3) The Challenger will reveal the id of C (·) and R(·).
available to the adversary, restricted as per the below.
(a) The entire set v-DB-Orcls of oracles defined above is
–The adversary cannot call corrupt on C (·), R(·) or
–The adversary is allowed a polynomial number of
PC (·).
queries of each type of oracle.
–The experiment starts as soon as at least one macro-
session is running as a result of a call of the type
init(C, R, PC,T ,W , X ), with parameters from the set of
parties available in this phase of the game. We consider
that the Challenger makes this call, for some arbitrarily
picked parties in this stage.
(b) After at least one X-session is marked as “finished” in
the list Sess, the Challenger can stop the learning phase. In
any case, the Challenger stops the learning phase after a
polynomial number of X sessions are marked as “finished”
in the list Sess. This stopping by the Challenger means
that all sessions are terminated.
(4) In the attack phase of the experiment, the adversary is
allowed access to Cm+1 (·), . . . , Cℓ (·), C (·), the reader-parties
14In order words, there is no mixing of card-coupling and reader-coupling in the
system.
Rp (·), . . . , Rz (·), R(·), th [PC,T ] algorithms and X machines
fitting the coupling made with these card/reader devices. The
adversary is allowed access to the set v-DB-Orcls of oracles,
as follows.
(5) The Challenger will reveal the id of C (·) and R(·).
–The Challenger will itself call corrupt on PC on board
–The Challenger will call init([C (·), PC (·),T (·)], R(·),W , X );
(a) If the experiment is card-coupled:
C (·)
this produces a macro-session mid. The challenger gives
the necessary handles of this to A.
–The adversary can also call corrupt on Cm+1 (·), . . . , C (·)
and their PCs. The adversary cannot call corrupt on R(·).
(b) If the experiment is reader-coupled:
–The Challenger will itself call corrupt on PC on board
R(·).
–The Challenger will call init([C (·), C (·),T (·)], R(·), [W , X]);
this produces a macro-session mid. The challenger gives
the necessary handles of this to A.
–The adversary can also call corrupt on Rp (·), . . . , Rz (·), R(·)
and their PCs. The adversary cannot call corrupt on C (·).
(c) The adversary cannot call move(C (·)).
(6) The adversary can make qC, qR, qT queries to init(C, . . .),
init(. . . , R, . . .), init(. . . , [PC,T ], . . .) in total. Of the other
types of oracle, the adversary can make an unspecified by
polynomial number of calls.
(7) The Challenger lets the experiment continue until PC and X
finish their respective session sid and sid′ inside the macro-
session session mid, or until the adversary’s allowed number
of queries is reached.
(PC,T )
(8) The experiment continues if Outsid
= 1 (since PC is cor-
rupted, A gets all details of PC’s session and, to finish the
game, will produce this output.)
(9) The adversary wins if Outsid′
(10) The advantage of the adversary is the Pr
(cid:34)
(W (τ((PC,T )) ))= 1.
Outsid′
= 1
taken over all random coins in parties included in the attack
phase.
W (τ((PC,T )) )
(cid:35)
,
Definition 4.3. Strong Relaying Security. For a given v-DB pro-
tocol Π, the (ℓ, z, n, qC, qR, qT, reader−coupled )-v-DB experiment
gives the game for strong relaying over Π of the same parame-
ters.
If the advantage of the adversary is negligible is this game, then we
say that Π is secure w.r.t. strong relaying.
In this case, A is a strong man-in-the-middle who controls the PC
algorithm onboard a reader R, and may control R itself. It attempts
the make the attester W accept a transcript when the card C was
far from the reader, when the PC algorithm already lied about this
fact (i.e, Outsid
= 1); that is, the adversary and the PC algorithm
(maybe alongside the reader R algorithm) try collude to make it