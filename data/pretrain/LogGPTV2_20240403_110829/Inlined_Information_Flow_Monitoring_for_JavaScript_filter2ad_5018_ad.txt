have an optional optimization for programs that don’t add
properties to the global object and refer to them as vari-
ables. This optimization avoids the use of with and gains a
signiﬁcant increase in performance due to JIT optimization
(section 4.2).
The lockout variables (Listing 3) are locals with the same
names as those of top level API’s: Object, Array, window
etc. They allow to retain transparency in case the ﬁelds of
the global facade exposed via with, are deleted: Without
the lockout variables, the original API’s would have been
exposed. Note that the latter would not jeopardize secu-
rity and isolation, because all the means of accessing the
API’s —ﬁeld access and function calls— are mediated by
the monitor run-time. Mediated operations invoked on na-
tive API’s would fail with an exception due to the violation
of the boxing invariant. While unpleasant, this is not a se-
curity vulnerability. This also takes care of the cases when
the surface of the browser API is larger than expected by
the inliner.
Policy spec
Policy compilation
Monitor options
Monitor core linking
Environment
Facade constructor
Standalone JavaScript
Instrumentation
HTML page
scripts
script
Consolidation
policy
monitor
core
global
facade
+
monitored
program
Figure 2: Inlining algorithm
It is useful to think of the inliner in terms of the tra-
ditional compiler, which has a run-time system (monitor
core and API facades), a front-end, conversion to intermedi-
ate languages (desugaring), a static analysis pass and code-
generation.
Desugaring. We simplify the program slightly to aid es-
tablishing the box invariant.
In particular, rewrite func-
tion statements into function expressions and decouple vari-
able declarations from their initialization. Note that both
transformations follow the hoisting procedure dictated by
the ECMAScript speciﬁcation.
We have chosen not to do more aggressive desugaring in an
attempt to keep the structure of the instrumented program
similar to the original. Moreover it is challenging to correctly
desugar to a small core (see Sec. 5).
Static analysis. We perform control ﬂow and exception
analysis to determine control dependence regions of branch
points. We use the deﬁnition of control dependence regions
due to Barthe et al. [8]. The region inference algorithm
works with the intraprocedural control-ﬂow graphs and is
build on top of [43]. Graphs are at expression granularity
(see Sect. 2 for motivation). For each region we identify the
guards, the entry point and exit points. Those are used to
guide the instrumentation to insert operations that manage
PCLS (the PC label set): enter at the entry, exit at the
exits and update/push at the guards.
These operations allow tracking at the expression level by
interleaving stack operations with subexpression evaluation:
e.g. update takes and returns a box, in addition to updating
the guard label, and exit can return the argument box in
addition to discarding the PCLS record for the region.
Our control-ﬂow analysis is intra-procedural because in
the general case it is impossible to construct a precise call
graph for JS programs.
Instead, we adopt a dynamic ap-
proximation. We know that the control-dependence region
of the exception source extends to the end of the innermost
catch/finally clause. That point is a conservative approxi-
mation of the merge point of any exception source within the
636try block. Hence, we can remove the PCLS records repre-
senting the corresponding implicit ﬂows. The complication
is that we don’t know how many elements we need to re-
move, as the corresponding branch points can be in another
function. The following observation helps: The try state-
ment contains all the implicit ﬂows due to exceptions, so the
aggregate level of the PCLS should be the same before and
after it. This invariant allows us to put an easily enforceable
and sound approximation on the control-dependence regions
of inter-procedural exceptions. To this end, in addition to
the operations for adding, removing and updating PCLS
records we have introduced two new ones:remember(id) and
restore(id), where id is a numeric identiﬁer which is syn-
tactically unique for every try-catch statement. The op-
erations allow to save and restore the state of PCLS. Using
these two operations we can transform a try-catch-finally
statement as shown in the listing below.
try { x x r e m e m b e r ( ) ; /* try body */ }
catch ( x ) { /* catch body */ }
finally { x x re s t o r e ( ) ; /* finally body */ }
Program instrumentation. Fig. 3 shows the instrumenta-
tion algorithm. We show a few transformations to give a
ﬂavor of what an instrumented program looks like. The
code in Listing 4 contains a while statement with a variable
assignment, inﬁx expressions, and a conditional expression.
The transformed version (Listing 5) deals with control ﬂow
within expressions and assignments, using the push and pop
monitor functions which both pass values and have eﬀects
on the level stack. Listing 6 shows function declarations and
calls, transformed to Listing 7.
The rewriting rules, deﬁned as a syntax- and annotation-
directed translation, are presented in tables 1 and 2. The
rules should be read as “if an AST node matches the pro-
duction and has, at least, the annotation, then replace it
with output”. Italic denotes arbitrary sub-statements or ex-
pressions. The rules assume rewriting is done in a bottom-
up fashion, so the sub-expressions/statements are already
rewritten.
Accessor properties. Getters and setters are supported by
the monitor. In order to enforce the boxing invariant we do
not rely on the native accessors. We emulate them explicitly,
so we can bind this in getter and setter functions to the ob-
ject box instead of the object as would have been done by the
native semantics. Refboxes are objects with ﬁelds "t" with
an appropriate ﬂag, "g" and "s" that store the getter and
setter functions respectively. These functions are invoked in
readField and writeField monitor operations. Refboxes
are stored in properties that would have had accessors de-
ﬁned. The facade for Object.defineProperty takes care of
the conversion between property descriptors and refboxes.
Eval. The eval function allows interpreting a string as a JS
program. Precise tracking of information ﬂows in dynamic
code requires performing inlining on the code before evaluat-
ing it [38]. Previous work implemented the inliner in JS [28,
54], which can be used in eval as well. Our inliner is imple-
mented in Haskell. We support inlining of eval’ed code with
the help of an inlining HTTP proxy server. This suﬃces for
two of our deployment scenarios: browser and proxy server.
To support the server-side deployment scenario, the inliner
needs to be added to the monitor core. We could achieve
that using a compiler from Haskell to JS [56].
Declassiﬁcation and upgrade. Another addition to the
environment is a function declassify(e,c), which is al-
lowed in source programs to express policy. In the monitor,
it downgrades the label on e to that of the channel c while
enforcing robust declassiﬁcation [41]: it is a violation if the
PC level is higher than the initial label on e. The explicit
label upgrade operation is also exposed in the API.
4. EXPERIMENTS
We are interested in practical yet sound information ﬂow
enforcement. The two longstanding questions for NSU-based
monitoring are whether it can achieve adequate permissive-
ness and performance without sacriﬁcing soundness or trans-
parency. We believe these questions don’t have a satisfac-
tory answer in the literature. We don’t claim to have the
ultimate answer, but instead oﬀer additional evidence that
this approach is moving towards practicality.
For permissiveness assessment to be conclusive one needs
to study existing applications and provide comprehensive
policies that account for all the legitimate ﬂows. This is a
daunting task, as modern web applications are very large,
often using multiple JS libraries, a wide variety of browser
API’s, and they are often obfuscated. That’s why we have
opted to create our own mashups to serve as case studies,
but inspired by the mashups we have seen “in the wild”. The
mashups we have developed are only mock-ups in a sense
that they include only the bare minimum to demonstrate
the patterns of mashup component interaction (using the
currently recommended APIs) and create possibilities for
both legal and illegal IF.
We have covered a variety of diﬀerent programming idioms
when implementing the mashups. For example, attaching
event handlers by specifying the corresponding attributes
of HTML tags versus using addEventListener in the JS
program itself; diﬀerent ways of mashing up content: using
IFrames or script tags; using inline scripts versus external
scripts (e.g., using the “src” attribute). Every example ap-
plication has one security policy and multiple versions of
components, some of which conform to policy, while others
do not.
4.1 Securing mashup applications
We focus on web applications with interesting IF policies.
Most are mashups combining two or more JS programs from
diﬀerent service providers on one page. From an IF per-
spective mashups are the most interesting: the providers
are often mutually distrusting or have a legal obligation not
to disclose information to a third party —yet certain ﬂows
should be allowed in order for the application to be of use.
Third-party payment processor. This was discussed
in Sec. 1. A malicious version of the merchant page sends
order details together with the ﬁnal price to the processor.
The malicious processor sends payment information to the
merchant.
Advertisements. An Internet radio service, similar to
Grooveshark, Last.fm or Pandora, hosts ads from a ticket
vendor, e.g., Ticketmaster, that list upcoming shows. Sim-
ilar to how most ads are hosted nowadays, the service in-
cludes a third party script. The script crawls the page and
creates a new script tag with a URL that contains keywords.
637Declaration hoisting
Function declaration elimination
Desugaring
Native errors
Label sets
Lexical scope
Control-ﬂow graph
Control-dependence regions
Analysis
Optimization
Implicit ﬂow rewriting
Syntax/annot.-directed rewriting
Rewriting
Production
"abcde"
function f (x, . . . , z) {ss}
x
x
o.f
o[f ]
o[f ](e1, . . . , en)
f (e1, . . . , en)
new C(e1, . . . , en)
void e
!e
e1||e2
Figure 3: Instrumentation algorithm
Annotation Output
xxprimlow("abcde")
xxfunlow(function f (x, . . . , z) {ss})
OuterFunRef xxfunlow(x)
∅
x
xxreadField(o, xxprimlow("f "))
xxreadField(o, f )
xxinvokeMethod(o,f ,[e1, . . . , en]))
xxinvokeFunction(f ,[e1, . . . , en])
xxnewObject(C,[e1, . . . , en])
void e
xxoplnot(e)
(function (x){return
e1&&e2
e1+e2
x++
x = e
x = e
o[f ] = e
e1, . . . , en
xxToBooleanBox(x).v ? x : xxjoin2(e2, x.l);})(e1)
(function (x){return
xxToBooleanBox(x).v ? xxjoin2(e2, x.l) : x;})(e1)
xxopadd(e1, e2)
xxvarpostfixinc(x)
NotDeclared xxassignVar((function () {try {return x}
∅
catch (ex) {return xxglobal.x=xxinitVar()}})) e)
xxassignVar(x, e)
xxassignField(x, f , e)
e1, . . . , en
Table 1: Selected rewriting rules for expressions
Annotation
Production
if (g) t else e GuardIndex(n)
while (g) ss
GuardIndex(n)
for (i; t; p) ss GuardIndex(n)
for (x in o) ss GuardIndex(n)
var x, . . . , z
with (o) ss
s
CDREntry(n)
Output
if (xxToBooleanBox(xxupdate(n, g)).v) t else e
while (xxToBooleanBox(xxupdate(n, g)).v) ss
for (i; (xxupdate(n, t)).v; p) ss
for (xxtemp = (xxupdate(n, o)).v) {x = xxprimlow(xxtemp); ss}
var x=xxinitVar(), . . . , z=xxinitVar()
with (xxadaptForWith(o)) ss
xxenter(n); s
Table 2: Selected rewriting rules for statements
Suite
Benchmark
Mean run-time Mean run-time Optimized
of the original
of the monitored
SunSpider 1.0.2 Access Binary Trees
SunSpider 1.0.2 Access Fannkuch
SunSpider 1.0.2 Bitops 3 Bit Bits in Byte
SunSpider 1.0.2 Math partial sums
Kraken 1.1
SunSpider 1.0.2 Access Binary Trees
Kraken 1.1
JSON Parse Financial
JSON Parse Financial
0.0027s
0.0532s
0.0043s
0.0077s
0.0645s