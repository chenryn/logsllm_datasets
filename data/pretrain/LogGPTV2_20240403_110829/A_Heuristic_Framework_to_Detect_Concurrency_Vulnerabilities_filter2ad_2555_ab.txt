pecially for concurrent programs. To tackle this problem, dynamic
531
analysis has been developed. For example, CTrigger [19] uses a
dynamic method to detect atomicity violations by analyzing in-
terleaving characteristics of synchronization events in concurrent
programs.
Test techniques detect concurrency errors by running target pro-
grams with system scheduling or designated tests to trigger concur-
rency errors. They typically aim at covering as many interleavings
as possible by generating either tests [7, 26, 27] or schedules [3, 34]
to detect concurrency errors. Compared with heuristic techniques,
a test technique usually suers from low eciency and thus needs
signicant amount of time to test. These concurrency error detec-
tors focus mainly on access interleavings of shared memory, with
expensive analysis and complex test or scheduler generation, and
are often used for unit tests instead of system tests due to their
complexity. As a comparison, our interleaving exploring method
for fuzz testing applies a lightweight method to adjust threads’ pri-
orities to explore thread interleavings rather than memory access
interleavings, and is thus scalable to test much larger concurrent
programs.
Since concurrency vulnerabilities are caused by concurrency
errors, a natural thought would be to apply concurrency error de-
tectors to detect concurrency vulnerabilities. This approach does
not work well in general for detecting concurrency vulnerabilities
since these concurrency error detectors focus mainly on detecting
three types of concurrency errors: data races, atomicity violations,
and order violations. As we mentioned in Section 1, concurrency
vulnerabilities may occur even when all the types of concurrency
errors these detectors focus on have been cleared o. Triggering
a concurrency vulnerability normally needs to meet two require-
ments: a specic input and a specic scheduling. These concurrency
error detectors aim at exploring bug-triggering interleavings and
typically will not meet the required input and the required schedul-
ing simultaneously to trigger a concurrency vulnerability.
Our method to detect concurrency vulnerabilities borrows some
ideas from the order violation detection proposed in [21, 36] and
the active testing proposed in [4, 11, 35]. The former focuses on
detecting wrong execution orders that lead to concurrency errors
in a concurrent program. The latter targets at specic bug types
such as data races by applying a static detector to predict buggy
thread interleavings and then executing a suspected buggy thread
interleaving in a real execution to try to trigger the bug. These
methods focus on detecting concurrency errors rather than con-
currency vulnerabilities and, as just mentioned, unlikely eective
in detecting concurrency vulnerabilities. We have extended these
ideas to detect concurrency vulnerabilities.
An interesting yet loosely related work [37] has been proposed
recently to detect concurrency attacks by relying on an attack in-
ference model that models behaviors of concurrency attacks in the
three stages of their life-cycle in launching an attack: a concurrency
bug is rst triggered to corrupt shared memory, then the corrupted
memory propagates across functions and threads, which may go
across memory boundaries (e.g., buer overows) during propaga-
tion, and nally the corrupted memory ows to vulnerable sites
(e.g., eval() and setuid()) to complete an attack. The method has
produced some sound results: it has detected 5 new concurrency
attacks and eliminated 94.1% of the reports generated by existing
concurrency bug detectors as false positive.
ACSAC ’18, December 3–7, 2018, San Juan, PR, USA
Changming Liu, Deqing Zou, Peng Luo, Bin B. Zhu, and Hai Jin
2.3 Logic-Based Methods
A logic-based approach applies model-checking to detect concur-
rency errors. It adopts a constraint solver to check if there is an
error. Logic-based methods such as [9, 24] can produce sound repro-
ducible results, but they have to apply methods such as approxima-
tion, pruning etc. to deal with path explosion and heavy workload
in constraint solving, and thus are not scalable to a large amount
of interleavings. As a comparison, our proposed scheme is light-
weighted and thus is scalable to a large amount of interleavings.
2.4 Fuzz Testing
Fuzz testing has been widely used to detect software vulnerabilities
over the past twenty-some years since Miller et al. [15] introduced
it to test the robustness of UNIX utilities in 1990. Due to its eec-
tiveness in detecting software bugs and vulnerabilities, fuzz testing
has gained popularity since its introduction. The basic idea in fuzz
testing is to feed test programs with many mutated or random
inputs to produce irregular behaviors or to trigger vulnerabilities.
Fuzz testing can be divided into three types in general: black-box
fuzzing, white-box fuzzing, and gray-box fuzzing.
Black-box fuzzing requires neither knowing internal logics of
tested programs nor source code. As a result, many generated test
inputs may be uninteresting or cannot explore any deep path in
program semantics. Many methods [25, 30] have been proposed to
generate eective test inputs and explore deeper paths with the aid
of domain knowledge. To compare eectiveness of dierent black-
box fuzzing methods, Maverick et al. [32] proposed an analytic
framework to evaluate existing black-box fuzzing algorithms by
using a mathematic mutation model.
White-box fuzzing requires complete knowledge of the source
code and behaviors of targeted programs. Generally, it applies heavy
analysis techniques, such as dynamic symbolic execution, to gen-
erate test inputs and explore as many paths as possible. It is very
ecient at exploring new program paths in order to trigger more
bugs and vulnerabilities. A great challenge white-box fuzzing faces
is scalability: it is hard to scale to large programs due to path ex-
plosion [5]. An example of white-box fuzzing methods is presented
in [10].
AFL [13] is a popular gray-box fuzzer to detect software bugs. It
instruments a targeted program at every conditional jump instruc-
tion in compiling time, and then it keeps mutating an input and
running the program in order to explore new branches to nd more
bugs. AFL is well-known to be explore sophisticated programs in a
shallow manner. Recently proposed gray-box fuzzers [6, 14] have
focused on addressing this low code coverage problem.
All existing fuzz testing methods have focused on exploring
more paths. They are unaware of thread scheduling and thus can-
not explore enormous concurrent interleavings as capable as they
explore path changes. As a result, they are ineective in detecting
concurrency errors and vulnerabilities.
3 CASE STUDY OF CONCURRENCY
VULNERABILITIES
In this section, we study examples of real-world concurrency vul-
nerabilities selected from the National Vulnerability Database [16].
The study leads to nding sensitive concurrent operations and dis-
tinct operation patterns for each type of concurrency vulnerability
we study in this paper. We will use these in our static analysis which
is to be described in detail in Section 4.
3.1 Real-World Concurrency Vulnerabilities
We have shown a real-world concurrency use-after-free vulnera-
bility in Section 1. Fig. 2 shows another real-world concurrency
vulnerability, a concurrency buer overow, which is triggered
after computing how many escape characters contained in a NULL-
ended string s with the for-loop in lines 1921-1925 and its length
(including the ending NULL) at line 1928. The string and its length
are then passed to function apr_pmemdup. Meanwhile, if another
thread is allowed to modify the same piece of memory to make s
longer than length bytes, execution of line 119 in apr_pmemdup
will make NULL-ended string res not contain proper ending NULL.
String res is returned at line 120 and again at line 1932 for more
processing. When the content of the string is subsequently used,
such as in a memcpy-like function, the content beyond the allo-
cated memory will be included since the proper NULL ending of
the NULL-ended string has been overwritten by another thread,
resulting in a buer overow. This may lead to information leakage
or even getting total control over the CPU that happened in the
real world [12].
The above concurrency buer overow can be a data race prob-
lem wherein two threads access string str simultaneously and can
be prevented by applying a mutex to lock operations from line
1921 to 1933 to prevent other threads from accessing str during
execution of these lines. However, if a ner lock is applied, such
as the calling function and the called function in Fig. 2 being sepa-
rately locked, i.e., a mutex is used to lock accessing str in the calling
function, i.e., from line 1921 to line 1929, and the mutex is used
to lock accessing str (i.e., m) in function apr_pmemdup to prevent
other threads from accessing str simultaneously, then the program
is race-free, yet the concurrency buer overow can still happen
when another thread modies the content of str after line 1928 has
been executed but before function apr_pmemdup starts to execute.
There are more real-world concurrency vulnerabilities, such as
CVE-2011-0990, CVE-2010-3864, etc. in the National Vulnerability
Database [16], that can still occur even when a program is race-free.
3.2 Characteristics of Concurrency
Vulnerabilities
Let us study the characteristics of concurrency buer overows.
A buer overow is triggered when the input data exceeds the
buer’s boundary and overwrites adjacent memory locations. It
usually occurs in memory replication. Fig. 3 shows an example
of for-loop memory replication. In a concurrent program, source,
dest, or length might be modied in another thread after the correct
values of these three variables have been determined and before
the memory replication process has completed. This may trigger a
concurrency buer overow. Thus concurrency buer overows
have the following characteristics:
• Memory replication is required. Memory replication may
manifest in several ways: calling memory replication func-
tions such as memcpy and strcpy, using memory replication
532
A Heuristic Framework to Detect Concurrency Vulnerabilities
ACSAC ’18, December 3–7, 2018, San Juan, PR, USA
void *res;
112: APR DECLARE(void *) apr pmemdup(apr pool t *a, const void *m, apr size t n)
113:
114:
115:
116:
117:
118:
119:
120:
121:
res = apr palloc(a, n);
memcpy(res, m, n);
return res;
if (m == NULL)
return NULL;
{
}...
1919:
1920:
1921:
1922:
1923:
1924:
1925:
1926:
1927:
1928:
1929:
1930:
1931:
1932:
1933:
/* Compute how many characters need to be escaped */
s = (const unsigned char *)str;
for (; *s; ++s) {
escapes++;
if (TEST CHAR(*s, T ESCAPE LOGITEM)) {
}
}
/* Compute the length of the input string, including NULL*/
length = s - (const unsigned char *)str + 1;
/* Fast path: nothing to escape */
if (escapes == 0) {
}
return apr pmemdup(p, str, length);
Figure 2: An example of concurrency buer overow in
server/util.c in Apache
1:
2:
for(i=0; i<length; i++)
dest[i]=source[i];
Figure 3: An example of memory replication using for-loop
statements such as the for-loop shown in Fig. 3 or a while-
loop.
• At least one of source, dest, or length is a shared variable and
can be modied by other threads.
• The execution order is important to trigger a concurrency
buer overow: modication by another thread must be
executed before the memory replication completes.
Concurrency double-free and concurrency use-after-free can
also be characterized in a similar manner, for example, a shared
variable that can be accessed concurrently, and there are at least two
concurrent free operations on this shared variable for the former
or one free operation on the shared variable in one thread and
accessing the shared variable in another thread that may occur
after the free operation for the latter.
From the above concurrency vulnerabilities we can observe the
following common essential requirements to trigger one of these
concurrency vulnerabilities:
• Concurrent Access to Shared Memory. There must be at
least one shared variable that can be concurrently accessed
from multiple threads.
• Sensitive Concurrent Operations on Shared Memory.
Among concurrent accesses to the shared variable, there
is at least one sensitive operation that is vital to trigger a
concurrency vulnerability. Dierent concurrency vulnerabil-
ity has dierent sensitive operations. For example, sensitive
concurrent operations for a concurrency buer overow
are memory replication and content modication on shared
memory; two free operations on shared memory for con-
currency double-free; and one free operation and another
memory access on shared memory for concurrency use-after-
free.
• Execution in Right Order. A certain execution order of the
sensitive concurrent operations is typically critical in trig-
gering a concurrency vulnerability. For example, the mem-
ory modication must occur before (or during) the memory
replication for a concurrency buer overow, and the free
operation must happen before accessing the shared memory
for concurrency use-after-free. There is no ordering for con-
currency double-free since the two free operations play an
identical operation.
The above sensitive concurrent operations, operation patterns,
and execution orders to trigger concurrency vulnerabilities will be
used in our heuristic framework to detect concurrency vulnerabili-
ties in concurrent programs, as described in detail in the subsequent
two sections.
4 STATIC ANALYSIS
Our heuristic framework consists of static analysis and thread-
aware fuzzing. The static analysis is described in this section, while
the thread-aware fuzzing is described in the next section.
In our framework, static analysis aims at locating sensitive con-
current operations and categorizing each nding into a potential
type of concurrency vulnerability so that the thread-aware fuzzing
would adjust threads’ running priorities to enhance the chance to
trigger the potential concurrency vulnerability in fuzz testing.
Our static analysis consists of four steps: discovering shared
memory, marking sensitive operations, merging data ows, and
categorizing potential concurrency vulnerability type. Fig. 4 shows
the whole procedure of state analysis for concurrency double-free
at line 4 and line 9 in the code shown on the left-most side of the
gure.
4.1 Shared Memory Discovery
As described in Section 3.2, shared variables that can be concur-
rently accessed are essential in triggering a concurrency vulner-
ability. The rst step focuses on nding shared memory that is
passed as a pointer when forking a new thread: whenever a new
thread is forked, we record the pointers that are passed through
pthread_create and potentially point to shared memory that can be
concurrently accessed.
Additionally, global variable access is another major source of
concurrent access. We handle this by recording all pointers that
point to a global variable in following three dierent places:
(1) A parent thread before a fork;
(2) A child thread;
(3) A parent thread after a fork.
Note that pointers that are passed through assignments such as
p2 = p1; p3 = p2; ..., are merely for data propagation rather than
genuine modication. These pointers point to the same memory
and thus should be treated as if an identical pointer. We apply a
lter on pointers to identify redundant pointers that essentially
point to the same piece of memory.
533
ACSAC ’18, December 3–7, 2018, San Juan, PR, USA
Changming Liu, Deqing Zou, Peng Luo, Bin B. Zhu, and Hai Jin