### Configuration and Performance Analysis

#### Initial Configurations
In the first configuration, both modules are registered for the `PKT_IN` event of the TCP Monitor Stack. This results in both Network Functions (NFs) receiving and processing two events per packet: one when the stack updates the client-side state and another when it updates the server-side state. Consequently, this setup yields the lowest throughput due to the high volume of events.

For the second configuration, we deregister events for server-side flows, allowing only events related to the client's packets to pass through. This effectively reduces the number of events by approximately half.

In the third configuration, we further reduce the number of events by deregistering those generated by the client stack and only observing events related to server stack updates caused by client packets. This reduces the number of events by another half. For most Intrusion Detection System (IDS) deployments, this is sufficient, as the IDS only needs to monitor traffic entering from untrusted clients and does not need to track TCP state for both the client and server sides. As shown in Figure 7c, this configuration results in throughput improvements of 1.2x and 2.6x compared to the first configuration.

#### Dynamic Subscriptions
Next, we enable dynamic subscriptions. In the fourth configuration, Deep Packet Inspection (DPI) subscribes to `PKT/TCP` events for the server stack, similar to the third configuration. However, DPI now publishes events based on the identified protocol type, and the `Signature_Match` NF subscribes to `EVENT/DPI_DETECT` messages. When DPI identifies a flow as HTTP, it triggers the event and uses dynamic subscriptions to unsubscribe from `PKT/TCP` events for that flow. Simultaneously, the `Signature_Match` NF begins subscribing to `PKT/TCP` events to perform its analysis, such as scanning for SQL injection attacks. If a specific signature is found, `Signature_Match` will publish an `EVENT/IDS_ALERT` event and deregister the current flow. By using dynamic filtering, we reduce the number of processed events by more than 50%, resulting in nearly a 5x throughput increase compared to the static filtering in the third configuration.

In the final configuration, we enable flow reassembly, allowing DPI and `Signature_Match` to subscribe and publish `DATA_RDY` events. This enables the NFs to detect patterns spanning multiple packets, albeit with about a 15% overhead for reassembling the packet payload and creating the bytestream.

#### Experiment Results
This experiment highlights the value of enabling NFs to tune their subscriptions and use events to communicate information. Prior systems would send many more packets to each NF for processing, similar to configurations 1-3. Our approach, however, allows NFs to be directly alerted to the information they need and adjust their subscriptions accordingly.

### IDS+Mon: Dynamic, Parallel Events
We now evaluate a more complex group of NFs and demonstrate how dynamic subscriptions and parallel processing can improve performance under different configurations. Our setup is based on real-world services evaluated in NFP [28].

#### Sequential and Parallel Chains
First, we configure the five NFs as either a sequential or parallel chain, as shown at the top of Figure 8. In the "Default" configuration, all NFs in the chain subscribe to `PKT/TCP` events. However, since the `Signature_Match` and `Logger` modules are more computationally expensive, they become the performance bottlenecks.

To optimize the chain, we next set up the `DPI_DETECT` event described in the previous section, which causes the DPI and `Signature_Match` NFs to dynamically tune their subscriptions. This reduces the load on the first two NFs, improving the average latency, as shown by the "DPI_DETECT" bars in Figure 8. We then define a `LONG_FLOW` event published by `Flow_Stats` once the average packet length of a flow exceeds a threshold. The `Logger` subscribes to this event and adjusts its subscription to log only long-running flows. Finally, combining both custom events provides a further performance improvement. Compared to the sequential chain, the parallel configuration offers a 3%-13% reduction in latency.

### Related Work
#### TCP Stacks
Several research efforts have focused on high-performance networking stacks [5, 13, 15, 20, 21, 23], but most are specific to end-host applications. Table 4 compares NFV frameworks [6, 12, 22, 26] that support TCP protocol processing. mOS [12] provides a reusable TCP stack for monolithic architecture but focuses on a single NF, not a chain. Replacing each NFâ€™s stack with mOS and hooking them together incurs multiple copies and performance issues. Comb [26] supports both pipelined and monolithic applications, focusing on consolidating applications and managing resources at the network-wide level, without addressing stack or NF configurability at the application level. Bro [22] presents a stack and event management framework specific to Intrusion Detection Systems, but its modules are tightly coupled, making it hard to extend to other applications. FlowOS [6] presents a flow-based platform for middleboxes, but it lacks the flexibility and modularity needed for efficient NFV.

#### Modularity and Parallelism
Click has been a popular platform for building network functions due to its modularity and extensibility. Individual elements are connected via pull or push connections to build complex applications. Click has inspired several modular NFV architectures [4, 8, 17, 26]. However, without native TCP support, these platforms are limited to L2 or L3 NFs. NFP and Parabox [28, 30] focus on NF-level parallelism, automatically analyzing NF dependencies and reconstructing service graphs with parallel NFs to improve performance. P4 [7] is a configuration language for packet processors, enabling parallelism by identifying table dependencies.

Microboxes works along both directions and complements these works. By decomposing a stack into customizable building blocks, Microboxes promotes parallelism. We focus on asynchronous processing, allowing parallelism between NFs and the protocol stack.

### Conclusions
Existing NFV frameworks focus on efficient packet movement and L2/L3 processing, but many key middlebox applications require higher-level protocol processing. The Microboxes architecture balances the goals of consolidating protocol processing and supporting a customizable stack tailored to individual flows. We achieve this by designing a modular, asynchronous TCP stack and efficient, event-based communication mechanisms to link NFs into complex applications. We introduce optimizations such as stack snapshots to ensure stack consistency while maintaining high performance. We believe Microboxes will provide a valuable framework for NF developers to deploy transport-layer-and-above middleboxes or end-services.

### Acknowledgements
We thank our shepherd KyoungSoo Park, the anonymous reviewers, and Jean Tourrilhes and Puneet Sharma from HPE for their detailed comments and valuable feedback. This work was supported in part by NSF grants CNS-1422362 and CNS-1522546.

### References
[References remain unchanged]