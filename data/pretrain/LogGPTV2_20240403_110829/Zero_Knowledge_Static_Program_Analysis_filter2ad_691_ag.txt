whenever the interval of a variable is updated more than a certain
number of times, we expand it to (−∞,∞). In our experiments, we
set this threshold to 5. We set the maximum number of variables
in a function as 50. In addition, we also set the percentage of the
code contained in the loops as 40%. For the control flow analysis,
we set up some identity functions at the beginning, and use some
branches in the main function to adjust possible functions a vari-
able can refer to. We define ‘multiplicity’ as the maximum number
of functions a variable can refer to. We set multiplicity as 8, and
the maximum number of variables in a function as 50. We then
generate the remaining program using random statements.
We plot the size of the circuits produced by our zero-knowledge
abstract interpretation schemes for the three analyses on synthetic
programs with different parameters and sizes in Figure 6 in Ap-
pendix E. We scale all programs to the largest instances that can
be handled on our machine, and we show the performance of the
largest programs in Table 3. As shown in the table, we are able to
perform the tainting analysis on a program with 12,800 lines of
code, the interval analysis with 2,000 lines of code and the control
flow analysis with 4,000 lines of code. The R1CS produced by our
zkAI is 41.3 to 57 million constraints. We are able to run the back-
end of Spartan [61] on these R1CS instances. The prover time for
the tainting analysis for example is 406s, the proof size is 282KB
and the verifier time is 65.8s. The SNARK backend [42] runs out
of memory, but can actually scale to half of these largest instances.
The prover time is estimated to be around 4500s, with a proof size
of 128 bytes and verification time of 1.4ms.
Experimental Results for Proving Absence of Bugs.We pick
two examples from the experiments: the tainting analysis on syn-
thetic programs with 50 variables and the interval analysis on
synthetic programs with 50 variables and 20% of code in the loops.
We implement their corresponding validation algorithms in Algo-
rithm 5 and Figure 5 shows their circuit sizes. As shown in the
Figure 5: Performance of zkAI for proving absence of bugs.
figure, the circuit size is 1.9-2× smaller in the tainting checks, and
2.4-2.8× smaller in the interval analysis. The main reason is that
the validation algorithm only goes through all the flows once, while
the worklist algorithm iterates till convergence. The improvement
is roughly proportional to the ratio of the number of iterations over
the number of flows. The savings on the push operations in the
queue and the join operations in the lattice turn out to be small.
7 CONCLUSION
We have demonstrated an application of zero knowledge proofs to
static analysis of programs, and specifically using the framework of
abstract interpretation. We describe both intra-procedural and inter-
procedural analyses for a core imperative language, implementation
details for efficient execution in zero knowledge, and evaluation
results showing that the approach is practical in real settings.
Although we focus on the scenario where a prover wishes to
demonstrate knowledge that a secret program is free of bugs, there
are broader applications of zero knowledge abstract interpreta-
tion to explore in future work, for example, in accelerating the
performance of demonstrating proof-of-exploit in zero knowledge.
Approaches for proof-of-exploit have been explored in prior work,
and are based in simulating the concrete execution of a program
from a particular input which reaches the exploit. In principle, ap-
plying the abstract interpretation framework to compute sound
under-approximations—as opposed to sound over-approximations,
the focus in our work—could accelerate the efficiency of zero knowl-
edge proof of exploit by orders of magnitude. Such an approach
could be checked efficiently by the verifier without computing
fixpoints (as we show for over-approximations in Section 5) and
provide an irrefutable guarantee that the exploit exists (i.e., no false
positives).
ACKNOWLEDGMENT
We thank Michael Walfish for helpful discussions which inspired
this work. This material is based upon work supported by DARPA
under Contract No. HR001120C0087 and by NSF under awards
CCF-2119939. Any opinions, findings and conclusions or recom-
mendations expressed in this material are those of the author(s)
and do not necessarily reflect the views of DARPA.
501003005008001600Lines215216217218219220221222223224225Circuit SizeTaintingTainting,ValidationIntervalInterval,ValidationSession 11B: Zero Knowledge II CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2963REFERENCES
[1] [n.d.]. Buffet. https://github.com/pepper-project/releases.
[2] [n.d.]. California Consumer Privacy Act (CCPA). https://oag.ca.gov/privacy/ccpa.
[3] [n.d.].
("COPPA").
Children’s Online Privacy Protection Rule
https://www.ftc.gov/enforcement/rules/rulemaking-regulatory-reform-
proceedings/childrens-online-privacy-protection-rule.
[4] [n.d.]. DroidBench 2.0.
https://github.com/secure-software-engineering/
DroidBench. Accessed: 2020-12-03.
[5] [n.d.]. General Data Protection Regulation (GDPR) - Official Legal Text. https:
//gdpr-info.eu/.
lab/libsnark.
[6] [n.d.]. Health Insurance Portability and Accountability Act of 1996.
https:
//www.hhs.gov/hipaa/index.html.
[7] [n.d.]. Pequin: An end-to-end toolchain for verifiable computation, SNARKs,
and probabilistic proofs. https://github.com/pepper-project/pequin. Accessed:
2020-12-03.
[8] [n.d.]. Reachability. https://github.com/ilyasergey/reachability.
[9] [n.d.]. WCET Project Benchmarks. http://www.mrtc.mdh.se/projects/wcet/
benchmarks.html. Accessed: 2020-12-03.
[10] 2014.
libsnark: a C++ library for zkSNARK proofs. https://github.com/scipr-
[17] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. 2014. Scalable
[18] Manuel Blum, Will Evans, Peter Gemmell, Sampath Kannan, and Moni Naor. 1994.
[11] Scott Ames, Carmit Hazay, Yuval Ishai, and Muthuramakrishnan Venkitasubra-
maniam. 2017. Ligero: Lightweight sublinear arguments without a trusted setup.
In Proceedings of the ACM SIGSAC Conference on Computer and Communications
Security.
[12] Stephanie Bayer and Jens Groth. 2012. Efficient zero-knowledge argument for
correctness of a shuffle. In Annual International Conference on the Theory and
Applications of Cryptographic Techniques. Springer, 263–280.
[13] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. 2019. Scal-
able zero knowledge with no trusted setup. In Annual International Cryptology
Conference. Springer, 701–732.
[14] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars
Virza. [n.d.]. SNARKs for C: Verifying program executions succinctly and in zero
knowledge. In CRYPTO 2013.
[15] Eli Ben-Sasson, Alessandro Chiesa, Michael Riabzev, Nicholas Spooner, Madars
Virza, and Nicholas P. Ward. 2019. Aurora: Transparent Succinct Arguments
for R1CS. In Advances in Cryptology – EUROCRYPT 2019. Springer International
Publishing, 103–128. https://doi.org/10.1007/978-3-030-17653-2_4
[16] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. [n.d.]. Suc-
cinct Non-Interactive Zero Knowledge for a von Neumann Architecture. In
Proceedings of the USENIX Security Symposium, 2014.
zero knowledge via cycles of elliptic curves. In CRYPTO 2014. 276–294.
Checking the correctness of memories. Algorithmica 12, 2-3 (1994), 225–244.
[19] Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Jens Groth, and Christophe
Petit. 2016. Efficient zero-knowledge arguments for arithmetic circuits in the
discrete log setting. In International Conference on the Theory and Applications of
Cryptographic Techniques.
[20] Jonathan Bootle, Andrea Cerulli, Essam Ghadafi, Jens Groth, Mohammad Ha-
jiabadi, and Sune K Jakobsen. 2017. Linear-time zero-knowledge proofs for
arithmetic circuit satisfiability. In International Conference on the Theory and
Application of Cryptology and Information Security. Springer, 336–365.
[21] Jonathan Bootle, Andrea Cerulli, Jens Groth, Sune Jakobsen, and Mary Maller.
2018. Arya: Nearly linear-time zero-knowledge proofs for correct program
execution. In International Conference on the Theory and Application of Cryptology
and Information Security. Springer, 595–626.
[22] Benjamin Braun, Ariel J. Feldman, Zuocheng Ren, Srinath T. V. Setty, Andrew J.
Blumberg, and Michael Walfish. [n.d.]. Verifying computations with state. In
ACM SIGOPS 24th Symposium on Operating Systems Principles, SOSP, 2013.
[23] B. Bünz, J. Bootle, D. Boneh, A. Poelstra, P. Wuille, and G. Maxwell. [n.d.]. Bul-
letproofs: Short Proofs for Confidential Transactions and More. In Proceedings of
the Symposium on Security and Privacy (SP), 2018, Vol. 00. 319–338.
[24] Matteo Campanelli, Dario Fiore, and Anaïs Querol. [n.d.]. LegoSNARK: Modular
Design and Composition of Succinct Zero-Knowledge Proofs.. In CCS 2019.
[25] Alessandro Chiesa, Yuncong Hu, Mary Maller, Pratyush Mishra, Noah Vesely,
and Nicholas Ward. 2020. Marlin: Preprocessing zksnarks with universal and
updatable srs. In Annual International Conference on the Theory and Applications
of Cryptographic Techniques. Springer, 738–768.
[26] Byron Cook, Andreas Podelski, and Andrey Rybalchenko. 2006. Terminator:
Beyond Safety. In Computer Aided Verification, Thomas Ball and Robert B. Jones
(Eds.). Springer Berlin Heidelberg, Berlin, Heidelberg, 415–418.
[27] Craig Costello, Cédric Fournet, Jon Howell, Markulf Kohlweiss, Benjamin Kreuter,
Michael Naehrig, Bryan Parno, and Samee Zahur. [n.d.]. Geppetto: Versatile
Verifiable Computation. In S&P 2015.
[28] P. Cousot. 1999. The Calculational Design of a Generic Abstract Interpreter.
In Calculational System Design, M. Broy and R. Steinbrüggen (Eds.). NATO ASI
Series F. IOS Press, Amsterdam.
[29] P. Cousot and R. Cousot. 1976. Static determination of dynamic properties of
programs. In Proceedings of the Second International Symposium on Programming.
Dunod, Paris, France, 106–130.
[30] P. Cousot and R. Cousot. 1977. Abstract interpretation: a unified lattice model
for static analysis of programs by construction or approximation of fixpoints. In
Conference Record of the Fourth Annual ACM SIGPLAN-SIGACT Symposium on
Principles of Programming Languages. ACM Press, New York, NY, Los Angeles,
California, 238–252.
[31] P. Cousot and R. Cousot. 1979. Systematic design of program analysis frameworks.
In Conference Record of the Sixth Annual ACM SIGPLAN-SIGACT Symposium on
Principles of Programming Languages. ACM Press, New York, NY, San Antonio,
Texas, 269–282.
[32] P. Cousot and R. Cousot. 1992. Inductive Definitions, Semantics and Abstract
Interpretation. In Conference Record of the Ninthteenth Annual ACM SIGPLAN-
SIGACT Symposium on Principles of Programming Languages. ACM Press, New
York, NY, Albuquerque, New Mexico, 83–94.
[33] Patrick Cousot and Radhia Cousot. 2014. A Galois connection calculus for
abstract interpretation. In The 41st Annual ACM SIGPLAN-SIGACT Symposium
on Principles of Programming Languages, POPL ’14, San Diego, CA, USA, January
20-21, 2014, Suresh Jagannathan and Peter Sewell (Eds.). ACM, 3–4.
[34] P. Cousot, R. Cousot, J. Feret, L. Mauborgne, A. Miné, D. Monniaux, and X. Rival.
2005. The ASTRÉE Analyser. In Proceedings of the European Symposium on
Programming (ESOP’05) (Lecture Notes in Computer Science, Vol. 3444), M. Sagiv
(Ed.). © Springer, Edinburgh, Scotland, 21–30.
[35] Cynthia Dwork, Frank McSherry, Kobbi Nissim, and Adam Smith. 2006. Cali-
brating noise to sensitivity in private data analysis. In Theory of cryptography
conference. Springer, 265–284.
[36] Christian Ferdinand and Reinhold Heckmann. 2004. aiT: Worst-Case Execution
Time Prediction by Static Program Analysis. In Building the Information Society,
Renè Jacquart (Ed.). Springer US, Boston, MA, 377–383.
[37] Dario Fiore, Cédric Fournet, Esha Ghosh, Markulf Kohlweiss, Olga Ohrimenko,
and Bryan Parno. 2016. Hash first, argue later: Adaptive verifiable computations
on outsourced data. In Proceedings of the ACM SIGSAC Conference on Computer
and Communications Security.
[38] Robert W Floyd. 1993. Assigning meanings to programs. In Program Verification.
Springer, 65–81.
[39] Shafi Goldwasser, Silvio Micali, and Charles Rackoff. 1989. The knowledge
complexity of interactive proof systems. SIAM Journal on computing 18, 1 (1989),
186–208.
[40] Eric Goubault and Sylvie Putot. 2013. Robustness Analysis of Finite Precision
Implementations. In Programming Languages and Systems, Chung-chieh Shan
(Ed.). Springer International Publishing, Cham, 50–57.
[41] Jens Groth. 2009. Linear algebra with sub-linear zero-knowledge arguments. In
Advances in Cryptology-CRYPTO 2009. Springer, 192–208.
[42] Jens Groth. 2016. On the Size of Pairing-Based Non-interactive Arguments. In
Advances in Cryptology - EUROCRYPT 2016 - 35th Annual International Conference
on the Theory and Applications of Cryptographic Techniques, Vienna, Austria, May
8-12, 2016, Proceedings, Part II. 305–326.
[43] David Heath and Vladimir Kolesnikov. 2020. Stacked garbling for disjunctive
zero-knowledge proofs. In Annual International Conference on the Theory and
Applications of Cryptographic Techniques. Springer, 569–598.
[44] Charles Antony Richard Hoare. 1969. An axiomatic basis for computer program-
ming. Commun. ACM 12, 10 (1969), 576–580.
[45] Yungbum Jung, Jaehwang Kim, Jaeho Shin, and Kwangkeun Yi. 2005. Taming
False Alarms from a Domain-Unaware c Analyzer by a Bayesian Statistical Post
Analysis. In Proceedings of the 12th International Conference on Static Analysis
(London, UK) (SAS’05). Springer-Verlag, Berlin, Heidelberg, 203–217. https:
//doi.org/10.1007/11547662_15
[46] John B Kam and Jeffrey D Ullman. 1976. Global data flow analysis and iterative
algorithms. Journal of the ACM (JACM) 23, 1 (1976), 158–171.
Watson Research Division.
[47] Ken Kennedy. 1979. A survey of data flow analysis techniques. IBM Thomas J.
[48] Gary A Kildall. 1973. A unified approach to global program optimization. In
Proceedings of the 1st annual ACM SIGACT-SIGPLAN symposium on Principles of
programming languages. 194–206.
[49] Joe Kilian. 1992. A Note on Efficient Zero-Knowledge Proofs and Arguments (Ex-
tended Abstract). In Proceedings of the ACM Symposium on Theory of Computing.
[50] James C King. 1976. Symbolic execution and program testing. Commun. ACM
19, 7 (1976), 385–394.
[51] Paul Kocher, Jann Horn, Anders Fogh, , Daniel Genkin, Daniel Gruss, Werner
Haas, Mike Hamburg, Moritz Lipp, Stefan Mangard, Thomas Prescher, Michael
Schwarz, and Yuval Yarom. 2019. Spectre Attacks: Exploiting Speculative Execu-
tion. In 40th IEEE Symposium on Security and Privacy (S&P’19).
[52] Moritz Lipp, Michael Schwarz, Daniel Gruss, Thomas Prescher, Werner Haas,
Anders Fogh, Jann Horn, Stefan Mangard, Paul Kocher, Daniel Genkin, Yuval
Yarom, and Mike Hamburg. 2018. Meltdown: Reading Kernel Memory from User
Space. In 27th USENIX Security Symposium (USENIX Security 18).
Session 11B: Zero Knowledge II CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2964[53] Mary Maller, Sean Bowe, Markulf Kohlweiss, and Sarah Meiklejohn. 2019. Sonic:
Zero-knowledge SNARKs from linear-size universal and updatable structured
reference strings. In Proceedings of the 2019 ACM SIGSAC Conference on Computer
and Communications Security. 2111–2128.
[54] Silvio Micali. 2000. Computationally Sound Proofs. SIAM J. Comput. (2000).
[55] Jan Midtgaard and Thomas Jensen. 2008. A Calculational Approach to Control-