account herself and checking whether they match, implying
that
this notion would be too weak in practice for most
purposes. The problem here is that this notion does not yet
consider transcripts that are partially trusted by J . Formally
this manifests itself in the limitation of the challenges to those
that only contain ch- and ar-actions (the later of which are
never used, but are required for is consistent).
A further issue, that is however relatively minor as J is
unbounded, is that she does not receive any session-states as
there are no exp actions, meaning that this model also only
considers corruptions of keys instead of full corruption.
D. Strong Deniability
To protect against these kinds of attacks we consider the
entire system as a whole. The straightforward demand here
would be that the judge receives the real transcript of ev-
erything that happens, except for the interactions in question,
which are either real as well or generated by a simulator. (We
refrain from formalizing this here, as it will be a special case
of our ﬁnal notion.) While extremely powerful, this notion
causes its own problems. Speciﬁcally, we conjecture that it is
incompatible with all efﬁcient protocols, unless other desirable
features are sacriﬁced:
Conjecture 1. There is no chat-protocol that offers post-
compromise secrecy (also known as backward secrecy [7]),
and strong ofﬂine deniability without requiring a trusted party
or an interaction with all members of a group after performing
any non-rcv action in that group.
We introduce this conjecture mostly to justify why we
consider weaker notions desirable. Our rationale for it is as
follows: At ﬁrst consider any protocol that encrypts consec-
utive messages of a user with keys that are in a non-trivial
relation to each other. Let now m0 and m1 be consecutive
messages by the same user, so that they are encrypted with
the keys k0 and k1 and let m1 be part of the challenge that the
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:15:37 UTC from IEEE Xplore.  Restrictions apply. 
1681
judge J receives, but not m0. This allows the following attack:
If J is unbounded, she can extract k0 and k1 with at least high
probability and check whether they are related. If the transcript
is entirely real then they will be related with probability 1. In
contrast, if m1 was encrypted by the simulator, this will likely
not be the case, as the relation is by assumption non-trivial and
the simulator does not know k0.
This attack works in particular for schemes that derive their
keys from states that are derived from each other. Getting rid
of this property is not without downsides: The ﬁrst option
would be to design a protocol that avoids ephemeral secret
states entirely by only using long-term secrets. Such a protocol
is trivially incapable of offering post-compromise secrecy.
The second option would be to remove the possibility of
linking consecutive states. This could be done by distributing
ephemeral public keys amongst all possible senders and have
them use each key only once. This leads to the same problem
as before just with a shorter attack-window, as well as the
possibility to run out of fresh keys. We also are not aware of
other methods that do this without interacting with all parties
in the group – performing essentially a fresh handshake.
Note that this rationale does intentionally not make use of
the session-states that are part of the transcript. We do this
to show that the problem is not caused by our strong notion
of corruption and cannot be circumvented by weakening that
notion.
E. State Disassociation
Attacks like the one outlined in the previous section are a
consequence of correlations between successive group-states.
As such they become impossible, once two group-states be-
come fully disassociated with each other. The precise condition
of when and if that happens in a given group will be the main
parameter to our generic model.
A formal deﬁnition of a state disassociation is strictly
speaking not necessary for the deﬁnition of our model but
we expect that most proofs would end up deﬁning some form
of this notion as a stepping-stone anyways. Because of this we
provide it here, with the hope that it will not only help with
understanding the intentions behind the following sections,
but also to reduce redundant work in proofs and the risk of
multiple incompatible deﬁnitions.
Intuitively a state disassociation in a group gr is any
sequence of actions that transforms a group-state st 0 into a
group-state st 1 in such a way that it ensures that st gr
1 contains
no information about st gr
0 .
A state disassociation predicate sd pred intuitively states
if an instruction list achieves state disassociation for a given
starting state. More precisely, it takes an instruction-list il,
a partial starting-state ps and a group gr and returns true if
the group state in gr that results from executing il on ps is
uncorrelated to ps, and false otherwise. We formalize this, re-
quiring that there is no judge J that can output two consistent
pairs of starting states and instruction-lists which cause state-
disassociations and result in equivalent (Deﬁnition 1) states,
such that J can distinguish those states.
Deﬁnition 10 (State Disassociation Predicate). A predicate
sd pred is a state disassociation predicate if there is no
adversary J that can win Experiment 2 with probability > 1
2:
(cid:0)1λ(cid:1)] = 1] ≤ 1
∀J : Pr[ExpState-Disassoc
sd pred,J
2
. State Disassociation
sd pred,J
Experiment 2: ExpState-Disassoc
Predicate
1 st 0, il 0, st 1, il 1, gr , SK := J (sd pred)
2 for b ∈ {0, 1}:
abort if(¬is consistent(il b, st b))
3
abort if(¬sd pred(il b, st b.ps, gr ))
4
, st(cid:48)
5
b := exec (st b, il bch)
6 abort if(cid:0)st
(cid:48)gr
7 b ←$ {0, 1}
0
(cid:48)gr
8 b(cid:48) := J (st
b
9 return b = b(cid:48)
(cid:1)
(cid:48)gr
1
(cid:54)≡ st
(cid:48)gr
1−b)
, st
F. Disjoined Instruction Lists
To prevent the aforementioned attacks, it is not merely
sufﬁcient to deﬁne what a state disassociation is, but also the
circumstances under which it has to occur. The goal in this
regard is to cause a disassociation between all pairs of longest
consecutive sequences of actions in a group whose type is
either only exp or only ch and all such sequences whose type
is ch and the ﬁnal resulting state.
For this we introduce the notion of disjoined instruction lists
to our framework. It has a parameter sd pred that has to be
ﬁlled with a state-disassociation-predicate. With this we can
now deﬁne that an instruction list il and a partial starting state
ps are disjoined under a given state disassociation predicate
sd pred if:
(cid:48) of il that contains
an action a in gr, where actions a(cid:48), a(cid:48)(cid:48) in gr that directly
precede/follow il have a different type from a and their types
are in {ch, exp},
(cid:48) satisﬁes the state-disassociation
predicate for gr.
For every group gr and every sublist il
then il
We remark that
this bans partial changes to the states
between ch and exp actions. If that ban was dropped, the
simulator would require precise information about which states
have to be updated in what way. While possible, this would
vastly complicate the security notion, while likely not resulting
in a stronger notion (if enough information is given to the
simulator it can simply simulate the hid-actions and remove
them from the output). To give a more formal deﬁnition:
Deﬁnition 11 (Disjoined). We say that an instruction list il
and a partial starting state st are disjoined under a predicate
sd pred if the predicate disjoined, as deﬁned in Algorithm 1,
returns 1 when called with them.
G. Full Interaction
In order to provide a predicate that may work as a state
disassociation predicate in many protocols while also being a
plausible option for use in real-world protocols, we introduce
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:15:37 UTC from IEEE Xplore.  Restrictions apply. 
1682
return n −(cid:12)(cid:12)(cid:8)x ∈ il [0, . . . , n](cid:12)(cid:12)x.type (cid:54)= ar(cid:9)(cid:12)(cid:12)
Algorithm 1: Deﬁnition of disjoined for a state disas-
sociation predicate sd pred.
1 fun c index(il , n):
2
3 fun disjoinedsd pred (il , ps):
4
5
6
7
8
9
ti := il [i].type; tj := il [j].type; tk := il [k].type
g := il [i].group
i(cid:48) := c index(il , i); k(cid:48) := c index(il , k)
ps(cid:48) := partial exec (il ch[0, . . . , i(cid:48)], ps)
if ¬sd pred (il ch[i(cid:48), . . . , k(cid:48)], ps(cid:48), g)
∧ti, tk ∈ {ch, exp} ∧tj /∈ {ti, tk}:
for i, j, k ∈ N3, i < j < k < |il|:
return 0
10
11
return 1
the notion of a hidden full interaction. Intuitively a full inter-
action occurs if every member of a group performs an active
action or is removed from the group. If a full interaction occurs
in hid actions with no other types of actions in between, we
call it a hidden full interaction. For a more formal deﬁnition
we refer to Deﬁnition 21 in Appendix B2.
Our suggestion for the state disassociation predicate is
therefore that the predicate that returns true if and only if
a hidden full interaction occurs. We note that this mirrors the
usual requirements for establishing post-compromise-secrecy,
if we view pure key-updates as sending empty messages. We
note that whether HFI is a secure state disassociation predicate
remains a property of the protocol in question and has to be
proven on a case-by-case basis.
H. Our Deniability Framework
In order to deﬁne the security notions that we actually rec-
ommend, we will use the framework depicted in Experiment 3.
It follows the typical structure of a distinguishing game in
which a judge J has to guess a randomly sampled bit b. The
only ways for her to do this better than just random guessing
are to extract information about the execution-history from the
state and to distinguish whether the transcript of an interaction
of her choice is either real (b = 0) or whether it was (partially)
simulated by a simulator S (b = 1).
The experiment starts with an empty state. This does not
really limit the power of J , since she can always start il with
hid actions that create a state whose partial state is whatever
she likes. It would alternatively have been possible to let J
output the starting state, but since she would then know it,
all groups would have to perform a state-disassociation before
executing ch or ar actions.
We allow J to pick the long-term key pairs of the involved
parties, as we would give that information to her anyways in
the end to deal with corruption and don’t think that we should
allow the existence of weak keys. The only requirements that
we enforce for the operating instruction il that J outputs are
that it is consistent with the empty starting state and properly
disjoined under a state disassociation predicate sd pred that
is left as model-parameter. Only giving the public keys and
sim il,st to S means that all notions deﬁned from this experi-
Experiment 3: ExpOfD
Π,S,J ,sd pred. The Experiment used
to deﬁne our notions of ofﬂine deniability for proto-
cols Π. The speciﬁc notion depends on the parameter
sd pred which speciﬁes the way in which the operating
instructions has to be disjoined.
1 b ←$ {0, 1}
2 P, PK , SK , il := J ()
3 st := (P,∅, PK , SK ,∅)
4 abort if(cid:0)¬is consistent (il , st) ∨ ¬disjoinedsd pred (il , st)(cid:1)
5 if b = 0:
6
7
8 else:
9
10
11
full transcript, st := exec (st, il ch)
judged transcript :=
(msg ∈ full transcript|msg.type ∈ {exp, ch})
full transcript, st := exec (st, il ar)
simulated transcript := S(PK , sim il,st )
judged transcript :=
merge((msg ∈ full transcript|msg.type = exp) ,
simulated transcript)
12 b(cid:48) := J (judged transcript)
13 return b = b(cid:48)
ment provide universal deniability. This could be weakened to
different forms of non-universal deniability by giving further
information such as secret keys to S, but as these notions
are rarely if ever targeted in the literature and by no means
standard we refrain from doing so here.
We note that the transcript that J receives contains all
session states that precede an exposed action in the respective
group, which together with the adversarially chosen key pairs
means that all notions deﬁned in this model consider full
corruption. We choose this notion not because we believe
that
it models anything particularly realistic, but because
security against it implies security against many weaker forms
of corruption and because it does not seem to cause any
signiﬁcant problems for protocol design compared to those
weaker notions.
This entire experiment deﬁnes a family of security-notions
that differ on the used state-disassociation predicate sd pred.
That predicate essentially deﬁnes at what point the commu-
nication in a group becomes deniable. As such the members
of that family will vary substantially with the extreme cases
being a predicate that always returns 1, requiring deniability
after every instruction, and a predicate that always returns 0,
meaning that no group provides deniability if there is ever an
exp action in it. Any other predicate will provide something in
between these two notions. As such sd pred is a customization
point that has a major effect on the practical deniability that a
scheme provides and saying that a protocol provides ofﬂine-
deniability in the sense that no judge can win the above game
better than by random guessing is a statement of very limited
use without specifying sd pred.
We remark that a state disassociation predicate p that
outputs 1 strictly more often than another predicate p(cid:48), does not
necessarily imply a stronger security notion: Consider the case
where both predicates accept the same consistent instruction
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:15:37 UTC from IEEE Xplore.  Restrictions apply. 
1683
lists, but p also accepts all inconsistent ones, which are rejected
by p(cid:48). The difference between p and p(cid:48) has no effect on the
provided security-notion because the security-game performs
a consistency-check anyways and aborts if it fails.
Because of the large effect that sd pred has on our notion
of OfD-security, we will provide three concrete instantiations
of it, namely the extreme cases of strong and weak ofﬂine-
deniability, as well as a notion between the two, that is ef-
ﬁciently instantiable under reasonable requirements (compare
Conjecture 1) while guaranteeing a much stronger form of
deniability than the weak notion.
With this we will now deﬁne our notion of strong ofﬂine
deniability:
Deﬁnition 12 (Strong Ofﬂine Deniability). A protocol Π
offers strong ofﬂine deniability or S-OfD if there is an efﬁcient
simulator S ∈ PPT so that no judge J has a chance of win-
ning the OfD-game (Experiment 3), with sd pred = (x (cid:55)→ 1)
with a probability greater than 1
2:
∃S ∈ PPT : ∀J :
Pr[ExpOfD
(cid:0)1λ(cid:1) = 1] ≤ 1