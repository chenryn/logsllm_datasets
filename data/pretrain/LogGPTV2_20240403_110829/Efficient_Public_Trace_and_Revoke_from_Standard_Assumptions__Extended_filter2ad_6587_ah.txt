Â· exp
âˆ exp
âˆš
Î£
 â
Î£a +
)ï¸
âˆš
.
0
0
)ï¸
This implies this equals to the probability of a being output
âˆ’1,w. To sum up, conditioned on Xğ‘¡ğ‘œğ‘Z, the
by ğ·Z2â„“âˆ’ğ¿â€²
matrix Xğ‘ğ‘œğ‘¡Z is distributed as (ğ·Z2â„“âˆ’ğ¿â€²
âˆ’1,w)ğ‘š.
,ğœ0
âˆš
âˆš
Î£
Î£
,ğœ0
We then consider the joint distribution of (A, u, ZA, Xğ‘ğ‘œğ‘¡Zu)
(conditioned on (Xğ‘¡ğ‘œğ‘, Xğ‘¡ğ‘œğ‘Z)). In the following, let us con-
sider the distribution of XZA instead of ZA. We do not loose
any information by doing this since X is invertible modulo
ğ‘ and the latter distribution can be recovered from the for-
mer by just multiplying Xâˆ’1 from the left. Furthermore, we
observe that XZA is the vertical concatenation of Xğ‘¡ğ‘œğ‘ZA
and Xğ‘ğ‘œğ‘¡ZA. Since the former can be recovered from Xğ‘¡ğ‘œğ‘Z
and A, which are already included in the tuples, we ignore
the former.
Let us denote Y := Xğ‘ğ‘œğ‘¡Z âˆ¼ (ğ·Z2â„“âˆ’ğ¿â€²
âˆ’1,w)ğ‘š. To
complete the proof, we will show that the following distribu-
tions are statistically close:
,ğœ0
âˆš
Î£
(A, u, YA, Yu) â‰ˆ (A, u, B, v)
, and v â†Ë’ Z2â„“âˆ’ğ¿â€²
ğ‘
where B â†Ë’ Z(2â„“âˆ’ğ¿â€²)Ã—ğ‘›
. We first show
that (Y mod ğ‘) is within 2Î©(âˆ’ğœ†) statistical distance from the
uniform distribution over Z(2â„“âˆ’ğ¿â€²)Ã—ğ‘š
. This follows by setting
Î› = Z2â„“âˆ’ğ¿â€²
and applying Lemma 2.4 to
Y in a column-wise manner. We check that the parameters
and Î›â€² = ğ‘ Â· Z2â„“âˆ’ğ¿â€²
ğ‘
ğ‘
satisfy the required condition of Lemma 2.4. We have
)2 Â· â€–Î£â€–âˆ)
âˆ’1/2 â‰¥ ((2â„“ âˆ’ ğ¿
âˆš
Î£
â€²
âˆ’1
ğ‘ 2â„“âˆ’ğ¿â€² (
â‰¥ â„¦((ğœ…1/2â„“ğœ2)
) = ğ‘ 1(Î£)
âˆ’1),
âˆ’1/2
âˆ’1
âˆš
âˆš
Î£
) â‰¥ ğ‘ Â· â„¦(
where the last inequality follows from the upper bound
on the norms of the rows of U. We therefore have ğœ0 Â·
ğ‘ 2â„“âˆ’ğ¿â€² (
ğœ…) by our choice of ğœ0. We then
finally apply Lemma 2.6 in a row-wise manner to obtain
that Y(A|u) is almost uniformly random. We note that the
lemma can be applicable because ğ‘ğ‘›+1/ğ‘ğ‘š â‰¤ 2âˆ’Î©(ğœ…). This
â–¡
completes the proof of Lemma 4.2.
Proof of Lemma 4.3. The reduction works as follows.
Given (A, u, ZA, Xğ‘¡ğ‘œğ‘, Xğ‘¡ğ‘œğ‘Z, v), algorithm â„¬ randomly
guesses indices {ğ‘–ğ‘—}ğ‘—âˆˆğ¿â€² âˆˆ [ğ‘„]ğ¿â€²
for which the adversary
makes key queries. The public key pk = (A, U = Z Â· A)
and the master key msk = Z are determined by the given
problem instance. (Note that Z is not given to â„¬, so it is im-
plicitly chosen.) Then â„¬ chooses {Â¯xğ‘–}ğ‘–âˆˆ[ğ‘„] as follows. When
ğ‘– âˆˆ {ğ‘–ğ‘—}ğ‘—âˆˆ[ğ¿â€²], there exists ğ‘— such that ğ‘– = ğ‘–ğ‘—. Then algo-
rithm â„¬ sets Â¯xğ‘¡
ğ‘– to be the ğ‘—-th row of the given matrix Xğ‘¡ğ‘œğ‘.
Otherwise, it chooses Â¯xğ‘– as in Game 4. The key queries are
handled as follows. Whenever ğ’œ queries key for xğ‘– such that
ğ‘– Ì¸âˆˆ {ğ‘–ğ‘—}ğ‘—âˆˆ[ğ¿â€²], algorithm â„¬ aborts and outputs a random bit.
Other queries can be handled using Xğ‘¡ğ‘œğ‘Z in the problem
instance. To create the challenge ciphertext â„¬ sets
âˆ’1 Â· (Xğ‘¡ğ‘œğ‘Zuâ€–v) + e1 + yğ›½.
c0 = u,
c1 = X
We can observe that when v = Xğ‘ğ‘œğ‘¡Zu, we have c1 = Zu +
e1 + yğ›½ and the distribution of the challenge ciphertext
corresponds to that of Game 4.
We then consider the case of v is random. We will show
that the distribution of X Â· âƒ—ğ‘1 mod ğ‘ is independent of ğ›½. As
the matrix X is independent of ğ›½ âˆˆ {0, 1} and invertible over
Zğ‘, this implies that the distribution of c1 is independent of
ğ›½ as well (recall that X is information theoretically known
to ğ’œ, which means that, if c1 carries any information on ğ›½,
so does X Â· c1 mod ğ‘). The first ğ¿â€² entries of X Â· c1 (namely,
Xğ‘¡ğ‘œğ‘ Â· c1) do not depend on ğ›½ because we have the equality
ğ‘ğ‘˜âˆ’1 Â· Xğ‘¡ğ‘œğ‘ Â· y0 = ğ‘ğ‘˜âˆ’1 Â· Xğ‘¡ğ‘œğ‘ Â· y1 mod ğ‘, by construction of
Xğ‘¡ğ‘œğ‘. The last 2â„“ âˆ’ ğ¿â€² entries are uniformly random, since
they are masked by the random vector v.
At the end of the game, algorithm â„¬ outputs the same bit
as ğ’œ.
It can be seen that â„¬ perfectly simulates Game 4 when
v = Xğ‘ğ‘œğ‘¡Zu and a game that is independent of ğ›½ when v
is random. Therefore, conditioned on â„¬ not aborting, the
distinguishing advantage of â„¬ is the same as ğ’œ. Since â„¬
aborts and outputs a random bit with probability 1/ğ‘„ğ¿â€²
, the
advantage of â„¬ is ğœ–/ğ‘„ğ¿â€²
. This completes the proof of Lemma
â–¡
4.3.
5 TRACE AND REVOKE FROM DDH
AND PAILLIER
In this section, we describe two (near) instantiations of the
generic construction presented in the last section. We are not
Session K1:  Secure ComputationCCSâ€™17, October 30-November 3, 2017, Dallas, TX, USA2290aware of existing IPFE schemes that meet the requirements
for our generic Trace-and-Revoke construction, but some
existing ones can be made to fit the framework.
a plaintext in Zğ‘ âˆ– {0} to a ciphertext of bit-length ğ‘‚((ğ‘¡ +
ğ‘Ÿ) log ğ‘). If we choose the DDH group as an elliptic curve
group (without pairings), we may set log ğ‘ = ğ‘‚(ğœ†).
5.1 Trace and Revoke from DDH
Following the work of Abdalla et al. [1], two DDH-based
adaptively secure IPFEs modulo the group size ğ‘ have been
proposed [4, 8]. However, these schemes enjoy limited cor-
rectness: as decryption involves the computation of a discrete
logarithm, one restricts the set of exponents to be small. For
instance, one may design the schemes so that inner prod-
ucts that are small compared to ğ‘ can be decrypted. This
restriction seems incompatible with the requirements of our
trace-and-revoke scheme, as the inner product ğ‘š Â· âŸ¨xid, vâ„›âŸ©
occurring in the decryption algorithm has no reason to be
small compared to ğ‘, even if the plaintext ğ‘š is small. In the
DDH-based trace-and-revoke scheme below, we circumvent
the issue for the scheme from [4] by removing the âŸ¨xid, vâ„›âŸ©
component before taking the discrete logarithm.
âˆ™ Setup(1ğœ†, 1ğ‘¡, 1ğ‘Ÿ, ğ¿). Choose a cyclic group G of prime
order ğ‘ along with two generators ğ‘”, â„ â†Ë’ G. DDH
in G should be 2ğœ†-hard, but taking base-ğ‘” logarithms
of elements ğ‘”ğ‘¥ with ğ‘¥ âˆˆ {1, . . . , ğ¿} should be tractable.
Set â„“ = ğ‘¡ + ğ‘Ÿ + 1. For each ğ‘– â‰¤ â„“, sample ğ‘ ğ‘–, ğ‘¡ğ‘– â†Ë’ Zğ‘
and compute â„ğ‘– = ğ‘”ğ‘ ğ‘– Â· â„ğ‘¡ğ‘– . Define
msk := (s, t) and pk :=(ï¸€G, ğ‘”, â„,{â„ğ‘–}ğ‘–âˆˆ[â„“]
)ï¸€.
ğ‘ and ğ‘id = xid.
every id âˆˆ â„›.
âˆ™ KeyGen(msk, id). Sample xid â†Ë’ Zâ„“
ğ‘.
Set skğ‘–ğ‘‘ = (âŸ¨xid, sâŸ©,âŸ¨xid, tâŸ©) âˆˆ Z2
âˆ™ Enc(pk,â„›, ğ‘š) proceeds as follows to encrypt ğ‘š âˆˆ
{1, . . . , ğ¿}.
(1) Compute vâ„› âˆˆ Zâ„“
ğ‘ âˆ– {âƒ—0} such that âŸ¨xid, vâ„›âŸ© = 0 for
(2) Set y = ğ‘š Â· vâ„› and sample ğ‘Ÿ â†Ë’ Zğ‘.
(3) Compute ğ·0 = ğ‘”ğ‘Ÿ, ğ·1 = â„ğ‘Ÿ and ğ¸ğ‘– = ğ‘”ğ‘¦ğ‘– Â· â„ğ‘Ÿ
The ciphertext ğ¶ is (ğ·0, ğ·1, ğ¸1, . . . , ğ¸â„“,â„›).
âˆ™ Dec(skid, ğ¶). Write ğ¶ = (ğ·0, ğ·1, ğ¸1, . . . , ğ¸â„“,â„›) and
let xid denote the vector corresponding to skid = (ğ‘ ğ‘¥, ğ‘¡ğ‘¥).
Compute:
all ğ‘– â‰¤ â„“.
ğ‘– for
(ï¸ â„“âˆï¸
)ï¸
ğ¶xid =
ğ¸
ğ‘¥id,ğ‘–
ğ‘–
/(ğ·ğ‘ ğ‘¥
0 Â· ğ·ğ‘¡ğ‘¥
1 ).
ğ‘–=1
.
xid
Then, recover vâ„› from â„› and output the base-ğ‘” loga-
rithm of ğ¶ 1/âŸ¨vâ„›,xidâŸ©
âˆ™ Trace(pd,ğ’®,â„›,ğ’ªğ’Ÿ) proceeds as described in Section 3.
Correctness follows from elementary computations. The
only difference with the direct instantiation of our trace-and-
revoke construction is that the division by âŸ¨vâ„›, xidâŸ© occurs
before the computation of the discrete logarithm, hence en-
abling efficient decryption.
Key and Ciphertext Sizes. Both the public key and master
secret key consist of ğ‘‚((ğ‘¡ + ğ‘Ÿ) log ğ‘) bits. To every user id
corresponds a secret key skid of bit-length ğ‘‚(log ğ‘) and a
vector ğ‘id of bit-length ğ‘‚((ğ‘¡ + ğ‘Ÿ) log ğ‘). Algorithm Enc maps
5.2 Trace and Revoke from Paillier
In [4], Agrawal et al. described two IPFEs relying on the
algebraic framework of Paillierâ€™s encryption scheme [33]. One
scheme handles inner products of short integers vectors, while
the other handles inner products modulo a product ğ‘ =
ğ‘ Â· ğ‘ of two safe primes. Both are proved secure under the
Decision Composite Residuosity (DCR) hardness assumption.
We explain here how to instantiate our trace-and-revoke
construction using this IPFE over Zâ„“
ğ‘ .
A first difficulty is the fact that the Key Generation al-
gorithm is stateful. However, this issue can be handled by
noticing that for random queries, the key generation algo-
rithm can be made stateless (see [4] and Subsection 4.1 for
more details). A further difficulty is the non-primality of ğ‘ :
our transformation requires the modulus to be prime. We
may actually apply the transformation and â€œpretendâ€ that
ğ‘ is prime, both in the scheme and in its security proof. The
non-primality of ğ‘ can be noticed only when finding vec-
tors orthogonal modulo ğ‘ to some specified vectors. When
such a task is performed, either the linear algebra operations
proceed and find such a vector, or they fail. In the latter
case, a non-trivial factor of ğ‘ has been found, which leads to
an algorithm against DCR. Hence, under the DCR hardness
assumption, such an event is unlikely. We now describe the
resulting DCR-based trace-and-revoke scheme.
âˆ™ Setup(1ğœ†, 1ğ‘¡, 1ğ‘Ÿ). Choose safe prime numbers ğ‘ = 2ğ‘â€² +
1, ğ‘ = 2ğ‘â€² + 1 with sufficiently large primes ğ‘â€², ğ‘â€² >
2ğ’«ğ‘œğ‘™ğ‘¦(ğœ†), and compute ğ‘ = ğ‘ğ‘. Then, sample ğ‘”â€² â†Ë’ Z*
and compute ğ‘” = ğ‘”â€²2ğ‘ mod ğ‘ 2, which generates the
subgroup of (2ğ‘ )-th residues in Zâ‹†
ğ‘ 2 with overwhelm-
ing probability. Set â„“ = ğ‘¡ + ğ‘Ÿ + 1 and sample s from
deviation parameter ğœ satisfying ğœ â‰¥ âˆš
the integer Gaussian distribution ğ·Zâ„“,ğœ with standard
â„“ğ‘ğ’«ğ‘œğ‘™ğ‘¦(ğœ†).
msk := s and pk :=(ï¸€ğ‘, ğ‘”,ğ’¢,{â„ğ‘–}ğ‘–âˆˆ[â„“]
)ï¸€.
Compute â„ğ‘– = ğ‘”ğ‘ ğ‘– mod ğ‘ 2 for all ğ‘– â‰¤ â„“. Define
ğ‘ 2
âˆ™ KeyGen(msk, id). Sample xid âˆˆ Zâ„“ with coefficients i.i.d.
uniform in {0, . . . , ğ‘ âˆ’ 1}. Set skğ‘–ğ‘‘ = âŸ¨xid, sâŸ© âˆˆ Z and
ğ‘id = xid.
âˆ™ Enc(pk,â„›, ğ‘š) proceeds as follows to encrypt ğ‘š âˆˆ Zğ‘ âˆ–
{0}.
(1) Compute vâ„› âˆˆ Zâ„“
ğ‘ âˆ– {âƒ—0} such that âŸ¨xid, vâ„›âŸ© = 0 for
(2) Set y = ğ‘š Â· vâ„› and sample ğ‘Ÿ â†Ë’ {0, . . . ,âŒŠğ‘/4âŒ‹}.
(3) Compute ğ¶0 = ğ‘”ğ‘Ÿ mod ğ‘ 2 and ğ¶ğ‘– = (1 + ğ‘¦ğ‘–ğ‘ ) Â·
The ciphertext ğ¶ is (ğ¶0, ğ¶1, . . . , ğ¶â„“,â„›).
ğ‘– mod ğ‘ 2 for all ğ‘– â‰¤ â„“.
â„ğ‘Ÿ