title:A Tale of Two Worlds: Assessing the Vulnerability of Enclave Shielding
Runtimes
author:Jo Van Bulck and
David F. Oswald and
Eduard Marin and
Abdulla Aldoseri and
Flavio D. Garcia and
Frank Piessens
University of Birmingham
A tale of two worlds
Van Bulck, Jo; Oswald, David; Marin, Eduard; Aldoseri, Abdulla; Garcia, Flavio D.; Piessens,
Frank
DOI:
10.1145/3319535.3363206
License:
None: All rights reserved
Document Version
Peer reviewed version
Citation for published version (Harvard):
Van Bulck, J, Oswald, D, Marin, E, Aldoseri, A, Garcia, FD & Piessens, F 2019, A tale of two worlds: assessing
the vulnerability of enclave shielding runtimes. in CCS '19 : Proceedings of the 2019 ACM SIGSAC Conference
on Computer and Communications Security. Association for Computing Machinery (ACM), pp. 1741-1758, 26th
ACM SIGSAC Conference on Computer and Communications Security (CCS 2019), London, United Kingdom,
11/11/19. https://doi.org/10.1145/3319535.3363206
Link to publication on Research at Birmingham portal
General rights
Unless a licence is specified above, all rights (including copyright and moral rights) in this document are retained by the authors and/or the
copyright holders. The express permission of the copyright holder must be obtained for any use of this material other than for purposes
permitted by law.
•(cid:9)Users may freely distribute the URL that is used to identify this publication.
•(cid:9)Users may download and/or print one copy of the publication from the University of Birmingham research portal for the purpose of private
study or non-commercial research.
•(cid:9)User may use extracts from the document in line with the concept of ‘fair dealing’ under the Copyright, Designs and Patents Act 1988 (?)
•(cid:9)Users may not further distribute the material nor use it for the purposes of commercial gain.
Where a licence is displayed above, please note the terms and conditions of the licence govern your use of this document.
When citing, please reference the published version.
Take down policy
While the University of Birmingham exercises care and attention in making items available there are rare occasions when an item has been
uploaded in error or has been deemed to be commercially or otherwise sensitive.
If you believe that this is the case for this document, please contact PI:EMAIL providing details and we will remove access to
the work immediately and investigate.
Download date: 01. Mar. 2020
  A Tale of Two Worlds: Assessing the Vulnerability of Enclave
Shielding Runtimes
Jo Van Bulck
imec-DistriNet, KU Leuven
PI:EMAIL
Abdulla Aldoseri
The University of Birmingham, UK
PI:EMAIL
David Oswald
The University of Birmingham, UK
d.f PI:EMAIL
Eduard Marin
The University of Birmingham, UK
PI:EMAIL
Flavio D. Garcia
The University of Birmingham, UK
f PI:EMAIL
Frank Piessens
imec-DistriNet, KU Leuven
PI:EMAIL
ABSTRACT
This paper analyzes the vulnerability space arising in Trusted Ex-
ecution Environments (TEEs) when interfacing a trusted enclave
application with untrusted, potentially malicious code. Consider-
able research and industry effort has gone into developing TEE
runtime libraries with the purpose of transparently shielding en-
clave application code from an adversarial environment. However,
our analysis reveals that shielding requirements are generally not
well-understood in real-world TEE runtime implementations. We
expose several sanitization vulnerabilities at the level of the Ap-
plication Binary Interface (ABI) and the Application Programming
Interface (API) that can lead to exploitable memory safety and side-
channel vulnerabilities in the compiled enclave. Mitigation of these
vulnerabilities is not as simple as ensuring that pointers are out-
side enclave memory. In fact, we demonstrate that state-of-the-art
mitigation techniques such as Intel’s edger8r, Microsoft’s “deep
copy marshalling”, or even memory-safe languages like Rust fail
to fully eliminate this attack surface. Our analysis reveals 35 en-
clave interface sanitization vulnerabilities in 8 major open-source
shielding frameworks for Intel SGX, RISC-V, and Sancus TEEs. We
practically exploit these vulnerabilities in several attack scenarios
to leak secret keys from the enclave or enable remote code reuse.
We have responsibly disclosed our findings, leading to 5 desig-
nated CVE records and numerous security patches in the vulnerable
open-source projects, including the Intel SGX-SDK, Microsoft Open
Enclave, Google Asylo, and the Rust compiler.
KEYWORDS
Trusted execution, TEE, Intel SGX, memory safety, side-channels
1 INTRODUCTION
Minimization of the Trusted Computing Base (TCB) has always
been one of the key principles underlying the field of computer se-
curity. With an ongoing stream of vulnerabilities in mainstream op-
erating system and privileged hypervisor software layers, Trusted
Execution Environments (TEEs) [28] have been developed as a
promising new security paradigm to establish strong hardware-
backed security guarantees. TEEs such as Intel SGX [8], ARM Trust-
Zone [34], RISC-V Keystone [21], or Sancus [32] realize isolation
and attestation of secure application compartments, called enclaves.
Essentially, TEEs enforce a dual-world view, where even compro-
mised or malicious system software in the normal world cannot
gain access to the memory space of enclaves running in an iso-
lated secure world on the same processor. This property allows
for drastic TCB reduction: only the code running in the secure
world needs to be trusted for enclaved computation results. Nev-
ertheless, TEEs merely offer a relatively coarse-grained memory
isolation primitive at the hardware level, leaving it up to the enclave
developer to maintain useful security properties at the software
level. This can become particularly complex when dealing with
interactions between the untrusted host OS and the secure enclave,
e.g., sending or receiving data to or from the enclave. For this rea-
son, recent research and industry efforts have developed several
TEE runtime libraries that transparently shield enclave applications
by maintaining a secure interface between the normal and secure
worlds. Prominent examples of such runtimes include Intel’s SGX-
SDK [19], Microsoft’s Open Enclave SDK [29], Graphene-SGX [43],
SGX-LKL [35], Google’s Asylo [13], and Fortanix’s Rust-EDP [11].
There are some differences in the way each trusted runtime
handles input/output data to and from the enclave. At the system
level, all TEEs offer some form of ecall/ocall mechanism to switch
from the normal to the secure word (and vice versa). Building on
this hardware-level isolation primitive, TEE runtimes aim to ease
enclave development by offering a higher level of abstraction to
the enclave programmer. Particularly, commonly used production-
quality SDKs [19, 29] offer a secure function call abstraction, where
untrusted code is allowed to only call explicitly annotated ecall
entry points within the enclave. Furthermore, at this level of ab-
straction the enclave application code can call back to the untrusted
world by means of specially crafted ocall functions. It is the TEE
runtime’s responsibility to safeguard the secure function call ab-
straction by sanitizing low-level ABI state and marshalling input
and output buffers when switching to and from enclave mode. How-
ever, the SDK-based approach still leaves it up to the developer to
manually partition secure application logic and design the enclave
interface. As an alternative to such specifically written enclave code,
one line of research [1, 2, 42, 43] has developed dedicated enclave
library OSs that seamlessly enforce the ecall/ocall abstraction at
the system call level. Ultimately, this approach holds the promise
to securely running unmodified executables inside an enclave and
fully transparently applying TEE security guarantees.
Over the last years, security analysis of enclaved execution has
received considerable attention from a microarchitectural side-
channel [24, 26, 30, 45, 46] and more recently also transient execu-
tion perspective [5, 20, 44]. However, in the era where our commu-
nity is focusing on patching enclave software against very advanced
Spectre-type attacks, comparably little effort has gone into explor-
ing how resilient commonly used trusted runtimes are against plain
architectural memory-safety style attacks. Previous research [3, 22]
has mainly focused on developing techniques to efficiently exploit
traditional memory safety vulnerabilities in an enclave setting, but
has not addressed the question how prevalent such vulnerabilities
are across TEE runtimes. More importantly, it remains largely un-
explored whether there are new types of vulnerabilities or attack
surfaces that are specific to the unique enclave protection model
(e.g., ABI-level misbehavior, or API-level pointer poisoning in the
shared address space). Clearly, the enclave interface represents an
important attack surface that so far has not received the necessary
attention and thus is the focus of this paper.
Our contribution. In this paper, we study the question of how
a TEE trusted runtime can securely “bootstrap” from an initial
attacker-controlled machine state to a point where execution can be
safely handed over to the actual application written by the enclave
developer. We start from the observation that TEE runtimes hold
the critical responsibility of shielding an enclave application at
all times to preserve its intended program semantics in a hostile
environment. As part of our analysis, we conclude that the complex
shielding requirement for an enclave runtime can be broken down
into at least two distinct tiers of responsibilities.
In a first ABI-level tier, we consider that upon enclave entry,
the adversary usually controls a significant portion of the low-
level machine state (e.g., CPU registers). This requires sanitization,
typically implemented through a carefully crafted enclave entry
assembly routine to establish a trustworthy ABI state as expected
by the compiled application code. Examples of trusted runtime
responsibilities at this level include switching to a private call stack,
clearing status register flags that may adversely affect program
execution, or scrubbing residual machine state before enclave exit.
Secondly, we consider that the enclaved binary itself makes cer-
tain API-level assumptions. Here we pay particular attention to
pointers and size arguments, because in many TEE designs [8, 21,
32], at least part of the enclave’s address space is shared with un-
trusted adversary-controlled code. Hence, the enclaved binary may
assume that untrusted pointer arguments are properly sanitized to
point outside of trusted memory, or that ocall return values have
been scrutinized. Our main contributions are:
• We categorize enclave interface shielding responsibilities into
10 distinct classes, across the ABI and API tiers (cf. Table 1).
• We analyze 8 widely used enclave runtimes, revealing a recur-
ring vulnerability landscape, ranging from subtle side-channel
leakage to more grave types of memory safety infringements.
• We practically demonstrate according attacks in various ap-
plication scenarios by extracting full cryptographic keys, and
triggering controlled enclave memory corruptions.
• We show that state-of-the-art automated enclave interface san-
itization approaches such as edger8r, or even the use of safe
languages like Rust, fail to fully prevent our attacks, highlight-
ing the need for more principled mitigation strategies.
Responsible disclosure. All of the security vulnerabilities de-
scribed in this work have been responsibly disclosed through the
proper channels for each affected TEE runtime. In each case, the
issues have been verified and acknowledged by the developers. In
the case of Intel, this can be tracked via CVE-2018-3626 and CVE-
2019-14565, and for Microsoft via CVE-2019-0876, CVE-2019-1369,
and CVE-2019-1370. The weakness found in Fortanix-EDP led to a
security patch in the Rust compiler. For other open-source projects,
our reports have been acknowledged in the respective commits or
issues on GitHub. We worked with the maintainers of said projects
to ensure mitigation of the problems reported in this paper.
To ensure the reproducibility of our work, and to provide the
community with a relevant sample of vulnerable enclave programs
for evaluating future attacks and defenses, we published all of our
attack code at https://github.com/jovanbulck/0xbadc0de.
2 BACKGROUND AND RELATED WORK
This section reviews enclave operation and TEE design, introduces
the trusted runtime libraries we analyzed in this work, and finally
summarizes related work on TEE memory corruption attacks.
2.1 Enclave entry and exit
TEE design. The mechanisms to interface with enclaves vary
depending on the underlying TEE being used. Figure 1 shows how,
from an architectural point of view, we distinguish two types of TEE
designs: those that rely on a single-address-space model (e.g., Intel
SGX [8] and Sancus [32]) vs. the ones that follow a two-world view
(e.g., ARM TrustZone [34] and Keystone [21]). In the former case,
enclaves are embedded in the address space of an unprivileged host
application. The processor orchestrates enclave entry/exit events,
and enforces that enclave memory can never be accessed from
outside the enclave. Since the trusted code inside the enclave is
allowed to freely access unprotected memory locations outside the
enclave, bulk input/output data transfers are supported by simply
passing pointers in the shared address space.
In the case of a two-world design, on the other hand, the CPU
is logically divided into a “normal world” and a “secure world”. A
privileged security monitor software layer acts as a bridge between
both worlds. The processor enforces that normal world code cannot
access secure world memory and resources, and may only call a
predefined entry point in the security monitor. Since the security
monitor has unrestricted access to memory of both worlds, an
explicit “world-shared memory” region can typically be setup to
pass data from the untrusted OS into the enclave (and vica versa).
Figure 1: Enclave interactions in a single-address-space TEE
design (left) vs. two-world design (right). The software com-
ponents we study are bold, and the TCB is green (solid lines).
Enclave entry/exit. Given that the runtimes we studied focus
mainly on Intel SGX (cf. Section 3.2), we now describe ecall/ocall
and exception handling following SGX terminology [8]. Note that
other TEEs feature similar mechanisms, the key difference for a two-
world design being that some of the enclave entry/exit functionality
may be implemented in the privileged security monitor software
layer instead of in the processor.
In order to enter the enclave, the untrusted runtime executes the
eenter instruction, which switches the processor into enclave mode
and transfers execution to a predefined entry point in the enclave’s
Trusted Runtime System (TRTS). Any meta data information, in-
cluding the requested ecall interface function to be invoked, can
be passed as untrusted parameters in CPU registers. TRTS first san-
itizes CPU state and untrusted parameters before passing control
to the ecall function to be executed. Subsequently, TRTS issues an
eexit instruction to perform a synchronous enclave exit back to
the untrusted runtime, again passing any parameters through CPU
registers. The process for ocalls takes place in reverse order. When
the enclave application calls into TRTS to perform an ocall, the
trusted CPU context is first stored before switching to the untrusted
world, and restored on subsequent enclave re-entry.
When encountering interrupts or exceptions during enclaved
execution, the processor executes an Asynchronous Enclave eXit
(AEX) procedure. AEX first saves CPU state to a secure Save State
Area (SSA) memory location inside the enclave, before scrubbing
registers and handing control to the untrusted OS. The enclave can
subsequently be resumed through the eresume instruction. Alter-
natively, the untrusted runtime may optionally first call a special
ecall which allows the enclave’s TRTS to internally handle the
exception by inspecting and/or modifying the saved SSA state.
2.2 TEE shielding runtimes
Intel SGX-SDK. With the release of the open-source SGX-SDK,
Intel [19] supports a secure function call abstraction to enable pro-
duction enclave development in C/C++. Apart from pre-built trusted
runtime libraries, a key component of the SDK is the edger8r tool,
which parses a developer-provided Enclave Description Language
(EDL) file in order to automatically generate trusted and untrusted
proxy functions to be executed when crossing enclave boundaries.
only supports Intel SGX applications, but in the future TrustZone-
based TEEs will also be supported through OP-TEE bindings [29].
The OE runtime includes a custom fork of Intel’s edger8r tool.
Google Asylo. Google aims to provide a higher-level, platform-
agnostic C++ API to develop production enclaves in a Remote Pro-
cedure Call (RPC)-like fashion [13]. While the Asylo specification
aims to generalize over multiple TEEs, presently only a single SGX
back-end is supported, which internally uses Intel’s SGX-SDK. From
a practical perspective, the Asylo runtime can thus be regarded as
an additional abstraction layer on top of the Intel SGX-SDK.
Fortanix Rust-EDP. As an alternative to Intel’s and Microsoft’s
SDKs written in C/C++, Fortanix released a production-quality SGX
toolchain to develop enclaves in the safe Rust language [11]. The
combination of SGX’s isolation guarantees with Rust’s type sys-
tem aims to rule out memory safety attacks against the trusted
enclave code. Similar to libOS-based approaches, Rust-EDP hides
the enclave interface completely from the programmer and trans-
parently redirects all outside world interactions in the standard
library through a compact and scrutinized ocall interface.
Graphene-SGX. This open-source library OS approach allows
to run unmodified Linux binaries inside SGX enclaves [43]. The
trusted Graphene-SGX runtime transparently takes care of all en-
clave boundary interactions. For this, the libOS offers a limited
ecall interface to launch the application, and translates all system
calls made by the shielded application binary into untrusted ocalls.
While Graphene was originally developed as a research project, it
is currently meeting increasing industry adaption and thrives to
become a standard solution in the Intel SGX landscape [36].
SGX-LKL. This open-source research project offers a trusted
in-enclave library OS that allows to run unmodified Linux binaries
inside SGX enclaves [35]. Similarly to Graphene-SGX, SGX-LKL
intercepts all system calls in the shielded application binary, but the
libOS layer is internally based on the Linux Kernel Library (LKL).