# A Tale of Two Worlds: Assessing the Vulnerability of Enclave Shielding Runtimes

## Authors
- Jo Van Bulck, imec-DistriNet, KU Leuven
- David F. Oswald, The University of Birmingham, UK
- Eduard Marin, The University of Birmingham, UK
- Abdulla Aldoseri, The University of Birmingham, UK
- Flavio D. Garcia, The University of Birmingham, UK
- Frank Piessens, imec-DistriNet, KU Leuven

## Abstract
This paper examines the vulnerability landscape in Trusted Execution Environments (TEEs) when interfacing a trusted enclave application with untrusted, potentially malicious code. Significant research and industry efforts have been dedicated to developing TEE runtime libraries that aim to transparently shield enclave applications from an adversarial environment. However, our analysis reveals that shielding requirements are often not well-understood in real-world TEE runtime implementations. We identify several sanitization vulnerabilities at the Application Binary Interface (ABI) and Application Programming Interface (API) levels, which can lead to exploitable memory safety and side-channel vulnerabilities in compiled enclaves. Mitigating these vulnerabilities is more complex than simply ensuring pointers are outside enclave memory. In fact, we demonstrate that state-of-the-art mitigation techniques, such as Intel’s edger8r, Microsoft’s “deep copy marshalling,” or even memory-safe languages like Rust, fail to fully eliminate this attack surface. Our analysis uncovers 35 enclave interface sanitization vulnerabilities in 8 major open-source shielding frameworks for Intel SGX, RISC-V, and Sancus TEEs. We practically exploit these vulnerabilities in various attack scenarios to leak secret keys from the enclave or enable remote code reuse. We have responsibly disclosed our findings, leading to 5 designated CVE records and numerous security patches in the affected open-source projects, including the Intel SGX-SDK, Microsoft Open Enclave, Google Asylo, and the Rust compiler.

## Keywords
Trusted execution, TEE, Intel SGX, memory safety, side-channels

## 1. Introduction
Minimizing the Trusted Computing Base (TCB) has always been a key principle in computer security. With the increasing number of vulnerabilities in mainstream operating systems and privileged hypervisor software layers, Trusted Execution Environments (TEEs) have emerged as a promising new security paradigm to establish strong hardware-backed security guarantees. TEEs, such as Intel SGX, ARM TrustZone, RISC-V Keystone, and Sancus, provide isolation and attestation for secure application compartments called enclaves. Essentially, TEEs enforce a dual-world view where even compromised or malicious system software in the normal world cannot access the memory space of enclaves running in an isolated secure world on the same processor. This property allows for a drastic reduction in TCB, as only the code running in the secure world needs to be trusted for enclaved computation results.

However, TEEs offer only coarse-grained memory isolation at the hardware level, leaving it up to the enclave developer to maintain useful security properties at the software level. This can become particularly complex when dealing with interactions between the untrusted host OS and the secure enclave, such as sending or receiving data. For this reason, recent research and industry efforts have developed several TEE runtime libraries that transparently shield enclave applications by maintaining a secure interface between the normal and secure worlds. Prominent examples include Intel’s SGX-SDK, Microsoft’s Open Enclave SDK, Graphene-SGX, SGX-LKL, Google’s Asylo, and Fortanix’s Rust-EDP.

There are differences in how each trusted runtime handles input/output data to and from the enclave. At the system level, all TEEs offer some form of ecall/ocall mechanism to switch between the normal and secure worlds. Building on this hardware-level isolation primitive, TEE runtimes aim to ease enclave development by offering a higher level of abstraction to the enclave programmer. Commonly used production-quality SDKs, such as Intel’s SGX-SDK and Microsoft’s Open Enclave SDK, provide a secure function call abstraction, where untrusted code can only call explicitly annotated ecall entry points within the enclave. Additionally, the enclave application code can call back to the untrusted world using specially crafted ocall functions. It is the TEE runtime's responsibility to safeguard the secure function call abstraction by sanitizing low-level ABI state and marshalling input and output buffers when switching to and from enclave mode. However, the SDK-based approach still leaves it up to the developer to manually partition secure application logic and design the enclave interface.

As an alternative to specifically written enclave code, one line of research has developed dedicated enclave library OSs that seamlessly enforce the ecall/ocall abstraction at the system call level. This approach holds the promise of securely running unmodified executables inside an enclave and fully transparently applying TEE security guarantees.

Over the last few years, security analysis of enclaved execution has received considerable attention from a microarchitectural side-channel and transient execution perspective. However, while the community focuses on patching enclave software against advanced Spectre-type attacks, relatively little effort has gone into exploring the resilience of commonly used trusted runtimes against plain architectural memory-safety style attacks. Previous research has mainly focused on developing techniques to efficiently exploit traditional memory safety vulnerabilities in an enclave setting but has not addressed the prevalence of such vulnerabilities across TEE runtimes. More importantly, it remains largely unexplored whether there are new types of vulnerabilities or attack surfaces specific to the unique enclave protection model, such as ABI-level misbehavior or API-level pointer poisoning in the shared address space. Clearly, the enclave interface represents an important attack surface that has not received the necessary attention, and thus is the focus of this paper.

### Our Contribution
In this paper, we study the question of how a TEE trusted runtime can securely "bootstrap" from an initial attacker-controlled machine state to a point where execution can be safely handed over to the actual application written by the enclave developer. We start from the observation that TEE runtimes hold the critical responsibility of shielding an enclave application at all times to preserve its intended program semantics in a hostile environment. As part of our analysis, we conclude that the complex shielding requirement for an enclave runtime can be broken down into at least two distinct tiers of responsibilities.

At the first ABI-level tier, upon enclave entry, the adversary usually controls a significant portion of the low-level machine state (e.g., CPU registers). This requires sanitization, typically implemented through a carefully crafted enclave entry assembly routine to establish a trustworthy ABI state as expected by the compiled application code. Examples of trusted runtime responsibilities at this level include switching to a private call stack, clearing status register flags that may adversely affect program execution, or scrubbing residual machine state before enclave exit.

Secondly, at the API-level tier, the enclaved binary makes certain assumptions. We pay particular attention to pointers and size arguments because, in many TEE designs, at least part of the enclave’s address space is shared with untrusted, adversary-controlled code. Hence, the enclaved binary may assume that untrusted pointer arguments are properly sanitized to point outside of trusted memory, or that ocall return values have been scrutinized. Our main contributions are:

- **Categorization**: We categorize enclave interface shielding responsibilities into 10 distinct classes, across the ABI and API tiers.
- **Vulnerability Analysis**: We analyze 8 widely used enclave runtimes, revealing a recurring vulnerability landscape, ranging from subtle side-channel leakage to more severe types of memory safety infringements.
- **Practical Demonstrations**: We practically demonstrate attacks in various application scenarios by extracting full cryptographic keys and triggering controlled enclave memory corruptions.
- **Mitigation Evaluation**: We show that state-of-the-art automated enclave interface sanitization approaches, such as edger8r, or even the use of safe languages like Rust, fail to fully prevent our attacks, highlighting the need for more principled mitigation strategies.

### Responsible Disclosure
All of the security vulnerabilities described in this work have been responsibly disclosed through the proper channels for each affected TEE runtime. In each case, the issues have been verified and acknowledged by the developers. For Intel, this can be tracked via CVE-2018-3626 and CVE-2019-14565, and for Microsoft via CVE-2019-0876, CVE-2019-1369, and CVE-2019-1370. The weakness found in Fortanix-EDP led to a security patch in the Rust compiler. For other open-source projects, our reports have been acknowledged in the respective commits or issues on GitHub. We worked with the maintainers of said projects to ensure mitigation of the problems reported in this paper.

To ensure the reproducibility of our work and to provide the community with a relevant sample of vulnerable enclave programs for evaluating future attacks and defenses, we published all of our attack code at [https://github.com/jovanbulck/0xbadc0de](https://github.com/jovanbulck/0xbadc0de).

## 2. Background and Related Work
This section reviews enclave operation and TEE design, introduces the trusted runtime libraries we analyzed in this work, and summarizes related work on TEE memory corruption attacks.

### 2.1 Enclave Entry and Exit
**TEE Design**: The mechanisms to interface with enclaves vary depending on the underlying TEE being used. From an architectural point of view, we distinguish two types of TEE designs: those that rely on a single-address-space model (e.g., Intel SGX and Sancus) and those that follow a two-world view (e.g., ARM TrustZone and Keystone). In the single-address-space model, enclaves are embedded in the address space of an unprivileged host application. The processor orchestrates enclave entry/exit events and enforces that enclave memory can never be accessed from outside the enclave. Since the trusted code inside the enclave is allowed to freely access unprotected memory locations outside the enclave, bulk input/output data transfers are supported by simply passing pointers in the shared address space.

In the two-world design, the CPU is logically divided into a "normal world" and a "secure world." A privileged security monitor software layer acts as a bridge between both worlds. The processor enforces that normal world code cannot access secure world memory and resources and may only call a predefined entry point in the security monitor. Since the security monitor has unrestricted access to memory of both worlds, an explicit "world-shared memory" region can typically be set up to pass data from the untrusted OS into the enclave (and vice versa).

**Enclave Entry/Exit**: Given that the runtimes we studied focus mainly on Intel SGX, we now describe ecall/ocall and exception handling following SGX terminology. Note that other TEEs feature similar mechanisms, with the key difference for a two-world design being that some of the enclave entry/exit functionality may be implemented in the privileged security monitor software layer instead of in the processor.

To enter the enclave, the untrusted runtime executes the `eenter` instruction, which switches the processor into enclave mode and transfers execution to a predefined entry point in the enclave’s Trusted Runtime System (TRTS). Any metadata information, including the requested ecall interface function to be invoked, can be passed as untrusted parameters in CPU registers. TRTS first sanitizes CPU state and untrusted parameters before passing control to the ecall function to be executed. Subsequently, TRTS issues an `eexit` instruction to perform a synchronous enclave exit back to the untrusted runtime, again passing any parameters through CPU registers. The process for ocalls takes place in reverse order. When the enclave application calls into TRTS to perform an ocall, the trusted CPU context is first stored before switching to the untrusted world, and restored on subsequent enclave re-entry.

When encountering interrupts or exceptions during enclaved execution, the processor executes an Asynchronous Enclave eXit (AEX) procedure. AEX first saves CPU state to a secure Save State Area (SSA) memory location inside the enclave, before scrubbing registers and handing control to the untrusted OS. The enclave can subsequently be resumed through the `eresume` instruction. Alternatively, the untrusted runtime may optionally first call a special ecall which allows the enclave’s TRTS to internally handle the exception by inspecting and/or modifying the saved SSA state.

### 2.2 TEE Shielding Runtimes
**Intel SGX-SDK**: With the release of the open-source SGX-SDK, Intel supports a secure function call abstraction to enable production enclave development in C/C++. Apart from pre-built trusted runtime libraries, a key component of the SDK is the edger8r tool, which parses a developer-provided Enclave Description Language (EDL) file to automatically generate trusted and untrusted proxy functions to be executed when crossing enclave boundaries.

**Microsoft Open Enclave SDK**: Microsoft’s Open Enclave SDK (OE) aims to provide a cross-platform, open-source framework for building enclaves. While it currently only supports Intel SGX applications, future support for TrustZone-based TEEs is planned through OP-TEE bindings. The OE runtime includes a custom fork of Intel’s edger8r tool.

**Google Asylo**: Google aims to provide a higher-level, platform-agnostic C++ API to develop production enclaves in a Remote Procedure Call (RPC)-like fashion. While the Asylo specification aims to generalize over multiple TEEs, presently only a single SGX backend is supported, which internally uses Intel’s SGX-SDK. From a practical perspective, the Asylo runtime can be regarded as an additional abstraction layer on top of the Intel SGX-SDK.

**Fortanix Rust-EDP**: As an alternative to Intel’s and Microsoft’s SDKs written in C/C++, Fortanix released a production-quality SGX toolchain to develop enclaves in the safe Rust language. The combination of SGX’s isolation guarantees with Rust’s type system aims to rule out memory safety attacks against the trusted enclave code. Similar to libOS-based approaches, Rust-EDP hides the enclave interface completely from the programmer and transparently redirects all outside world interactions in the standard library through a compact and scrutinized ocall interface.

**Graphene-SGX**: This open-source library OS approach allows running unmodified Linux binaries inside SGX enclaves. The trusted Graphene-SGX runtime transparently takes care of all enclave boundary interactions. For this, the libOS offers a limited ecall interface to launch the application and translates all system calls made by the shielded application binary into untrusted ocalls. While Graphene was originally developed as a research project, it is currently meeting increasing industry adoption and strives to become a standard solution in the Intel SGX landscape.

**SGX-LKL**: This open-source research project offers a trusted in-enclave library OS that allows running unmodified Linux binaries inside SGX enclaves. Similarly to Graphene-SGX, SGX-LKL intercepts all system calls in the shielded application binary, but the libOS layer is internally based on the Linux Kernel Library (LKL).