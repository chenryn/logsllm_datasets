• P → V: x, π ← NIZK(cid:8)crsL; (w) : (x, w) ∈ R(cid:9) and Σcrs
• P → V: crsL and Σcrs
• V → P: ch
L
(r) : Gen
(1)
crs(σbp; r) = crsL(cid:111)
(cid:110)
L
(r) : Gen
(2)
Figure 3: The message structure of the composed 3-move ZK for L.
4.3 Lapidot-Shamir Revisited
Kiayias, Zacharias and Zhang [KZZ15] proposed a technique that allows the EA to prove
the validity of some cryptographic elements on the BB using Sigma protocols. In par-
ticular, the EA posts the commitment messages of Sigma protocols on the BB before
the election starts; During the election, the veriﬁer’s challenge is jointly contributed
by all the voters (1 bit per voter); After the election ends, the EA then completes the
Sigma protocols by posting the corresponding response messages on the BB. However,
this technique has its limitations, namely, the statement to be proven must be ﬁxed
before the election starts. In order to prove a statement that is generated during or
after the election, we need a generic 3-move ZK protocol whose commitment message
is independent of the statement, such as the Lapidot-Shamir protocol3 [LS90]. Unfor-
tunately, one has to convert the original language to Hamiltonian cycle in order to use
the Lapidot-Shamir protocol, so it is very ineﬃcient in practice.
To resolve this issue, we propose a new Lapidot-Shamir like 3-move ZK frame-
work where the prover’s ﬁrst move does not depend on the statement to be proven.
The idea is to combine a 3-move public coin honest-veriﬁer zero-knowledge protocol
with a perfectly sound NIZK proof. For notation simplicity, we will use Sigma pro-
tocol notation for such 3-move public coin honest-veriﬁer zero-knowledge protocols,
but we emphasize that the special soundness and special ZK properties are not nec-
essary for our composition. Let ΓL be a perfectly sound NIZK proof system for some
the given crsL is a perfectly sound CRS. The message structure of the composed 3-
move ZK protocol between the prover P and the veriﬁer V is depicted in Figure 3.
In the ﬁrst move, the prover P generates a NIZK CRS crsL and sends it to the ver-
the second move the veriﬁer V gives the challenge message ch.
In the third move,
the prover V ﬁxes the statement x ∈ L and computes the NIZK proof for x, π ←
crs(σbp; r) = crsL(cid:9) be a Sigma protocol to show
NP language L, and let Σcrs(cid:8)(r) : GenL
crs(σbp; r) = crsL(cid:9).In
iﬁer V together with the commitment message of Σcrs(cid:8)(r) : GenL
NIZK(cid:8)crsL; (w) : (x, w) ∈ R(cid:9). P then sends to V the statement x, the NIZK proof π,
crs(σbp; r) = crsL(cid:9). V accepts the proof if (i)
and the response message of Σcrs(cid:8)(r) : GenL
crs(σbp; r) = crsL(cid:9)) is a valid Sigma
crs(σbp; r) = crsL(cid:9) , ch, Σcrs
(cid:8)(r) : GenL
crs(σbp; r) = crsL(cid:9) be
knowledge NIZK proof system for language L, and let Σcrs(cid:8)(r) : GenL
(Σcrs
(1)
protocol transcript and (ii) VrfyL(crsL; x; π) = 1.
Theorem 3. Let ΓL be a perfectly complete, perfectly sound, and computationally zero-
(cid:8)(r) : GenL
(2)
a 3-move public coin honest veriﬁer zero-knowledge protocol with perfectly completeness,
statistical soundness, and computational zero-knowledge. The above composed 3-move
3NB: Technically, the size of the commitment message of the Lapidot-Shamir protocol still depends
on the statement.
14
public coin honest veriﬁer zero-knowledge protocol for language L is perfectly complete,
statistically sound, and computationally zero-knowledge.
Proof. Perfect completeness. It directly follows from the perfect completeness prop-
erties of both ΓL and Σcrs(cid:8)(r) : GenL
crs(σbp; r) = crsL(cid:9).
Statistical soundness. Since Σcrs(cid:8)(r) : GenL
crs(1λ; r) = crsL(cid:9) is statistically sound,
crsL is a perfectly sound CRS with over-whelming probability. When crsL is a perfectly
sound CRS, no adversary can produce a fake π∗ to make the veriﬁer accept an invalid
x∗ (cid:54)∈ L such that VrfyL(crsL; x∗; π∗) = 1. Hence, the composed ZK is statistically sound.
Computational zero-knowledge. The simulatable CRS crs∗ generated by SimL
tionally zero-knowledge properties of both ΓL and Σcrs(cid:8)(r) : GenL
is computationally indistinguishable from a perfectly sound CRS. From the computa-
crs(σbp; r) = crsL(cid:9), it is
crs(σbp)
easy to see that the simulated composed ZK proof is computationally indistinguishable
(cid:4)
from a real one.
5 System Design
5.1 System Overview
Our system is a single-server web-based system.
In an election, the election server
mainly plays the roles of the EA and BB but may aid the other parties. All the other
parties are realized by Javascripts running at the client side. We assume there is a
secure channel between the election server and each trustee, say, realized by HTTPS.
The system uses homomorphic tally and currently supports x-out-of-m type of option
selection. Let mmin and mmax be the minimum and maximum number of options that
is allowed to choose to vote.
Setup. To create an election, the EA needs to login to the election server and
provides the election deﬁnition. An election deﬁnition consists of question, options,
(mmin, mmax), start/end time, trustee list (including their email addresses), and voter
list (including their voter IDs and email addresses). The election server then creates
a unique election ID, eid, selects a bilinear group parameter for the election, σbp :=
(p, G1, G2, GT , e, g1, g2) ← Genbp(1λ), and posts σbp on BB.
(Note that σbp is hard-
coded in our prototype.) The election server then generates and sends a random 128-bit
credential to each trustee by email, inviting them to setup the election parameters. Upon
receiving the credential, each trustee authenticates himself to the server and executes
the election parameters setup process (cf. Section 5.2). Once all the trustees jointly
setup the election parameters, the EA triggers the server to send an invitation email
(with the voter ID, vid(cid:96) ∈ G2 and a freshly generated random 128-bit credential s(cid:96)) to
each voter V(cid:96), where vid(cid:96) is a random group element in G2 generated by the election
server.
Cast. After the election starts, each voter V(cid:96) uses (vidi, s(cid:96)) to authenticate herself
to the election server. Next, she prepares and casts her vote using the voter supporting
device VSD. The voters’ ballots are prepared locally in the VSD and are posted to the
election server, which will be displayed on the BB. (cf. Section 5.3).
Tally. When the election is ﬁnished, the server computes the tally ciphertexts by
multiplying all the valid submitted ciphertexts for each option on the BB4. The voters’
coins are used to produce the Sigma protocol challenge (cf. Section 5.4.1). The trustees
are then invited by the election server to complete their Sigma protocols and decrypt
4Note that, during this step, any invalid ciphertexts and duplicated ciphertexts are removed.
15
the tally ciphertexts (cf. Section 5.4.2). Note that each trustee should respond to this
invitation (EA) using a secure channel such as HTTPS. Upon receiving such a message
from a trustee, the election server checks the validity of all the Σ proofs and NIZK
proofs, and rejects it in case some of the proofs are invalid. The election server posts
all the received trustees’ messages to the BB only after all the trustees have successfully
completed their Tally protocols.
Result. The election result can be computed according to standard threshold ElGa-
mal decryption using the partial decryption of the tally ciphertexts from each trustees.
Verify. After the Setup protocol, each trustee Ti is able to check the consistency
between the posted election parameters on the BB and its private state sti. After the
election, each voter V(cid:96) is able to fetch the election transcript, info from BB and verify
the integrity of the election with its receipt rec(cid:96). The voter checks if the data in blt(cid:96)
hashes to the rec(cid:96) and the validity of all the Sigma proofs and NIZK proofs.
5.2 Setup
Generating election parameters. The election parameters generation does not re-
quire the interaction between the trustees, and each trustee Ti only needs to interact
with the election server. At ﬁrst, the election server then generates and sends a random
128-bit credential to each trustee inviting them to setup the election parameters. Next,
the interaction is completed two rounds. In particular,
Round 1.
• Each trustee Ti performs the following:
– Pick random αi, βi ← Zq;
– Set h1,i = gαi
– Post/Append h1,i, u0,i to the public election parameters on the BB together
1 and u0,i = gβi
1 ;
with the following Σ commitment messages:
(cid:111)
(cid:110)
1 };
(1) {(αi) : h1,i = gαi
(βi) : u0,i = gβi
;
1
∗ Σdlog
∗ Σdlog
(1)
– pk := (g1, h1 :=(cid:81)k
– u0 :=(cid:81)k
i=1 u0,i;
i=1 h1,i);
• The election server computes and posts on the BB:
Round 2.
• Each trustee Ti performs the following:
– Pick random γi ← Zq;
– Set u1,i = gγi
– Post/Append u1,i, u2,i to the public election parameters on the BB together
1 and u2,i = uγi
0 ;
with the following Σ commitment messages:
∗ Σddh
(1) {(γi) : u1,i = gγi
1 ∧ u2,i = uγi
0 }
Upon termination, each trustee Ti keep its working tape as its private state sti. After
all the trustees have participated in Setup, the election server:
16
• Computes ck := (u0, ((cid:81)k
i=1 u1,i, g1 ·(cid:81)k
i=1 u2,i));
• Posts crsm := (σbp, ck) on the BB;
For every voter V(cid:96), i ∈ [n], the election
Generating Voters’ Private Information.
server generates (i) the voter ID, vid(cid:96) ∈ G2 by selecting a random group element in G2
and (ii) a freshly generated random 128-bit credential s(cid:96). It provides (vid(cid:96), s(cid:96)), (cid:96) ∈ [n]
to all the voters.
5.3 Cast
The VSD fetches election parameters from the BB and works as a “voting booth”. The
VSD shows the election question and a list of options to the voter V(cid:96). The voter V(cid:96)
can select x ∈ [mmin, mmax] options and let the VSD prepare the ballots. Let (cid:126)e =
(e1, e2 . . . , em) be the characteristic vector corresponding to the voter’s selection, where
ej = 1 if the option optj is selected and ej = 0 otherwise. The VSD prepares two versions
of the ballot that encrypts the same option selection as follows
• For j ∈ {1, 2, . . . , m}:
– Pick random rj,(a), rj,(b) ← Zp;
rj,(a)
– Compute c(a)
j,2 ) = (g
1
rj,(b)
j,2) = (g
1
j = (c(a)
j = (c(b)
j,1 , c(a)
j,1, c(b)
– Compute c(b)
);
, gej
, gej
rj,(a)
1 h
1
rj,(b)
1 h
1
);
• Compute two receipts:
– rec(a) = hash(eid, vid(cid:96), ‘A’, c(a)
– rec(b) = hash(eid, vid(cid:96), ‘B’, c(b)
1 , . . . , c(a)
m );
1 , . . . , c(b)
m );
The VSD presents to the voter the receipts for both A and B versions of the bal-
lot, rec(a) and rec(b); meanwhile, it displays two buttons labeled as ‘A’ and ‘B’ re-
spectively. The voter should keep the receipts and then randomly choose one of the