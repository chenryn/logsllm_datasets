### 优化后的文本

#### 方法一：绕过 Win10 的攻击缓解手段

在 Windows 10 中，`_OBJECT_HEADER` 结构中的指向 DS（描述符表）的指针不能为空。如果为空，系统会触发 `BAD_OBJECT_HEADER` 错误（错误代码 189）。具体错误信息如下：

```
BAD_OBJECT_HEADER (189)
The OBJECT_HEADER has been corrupted
Arguments:
Arg1: 8d1d9028, Pointer to bad OBJECT_HEADER
Arg2: 8639b480, Pointer to the resulting OBJECT_TYPE based on the TypeIndex in the OBJECT_HEADER
Arg3: 00000001, The object security descriptor is invalid.
Arg4: 00000000, Reserved.
```

为了绕过这种防护机制，可以参考以下方法：

1. **修改 `winlogon.exe` 的 AECs（访问控制实体）**：
   - 允许任意 SID token 的用户修改 `winlogon.exe` 进程。
   - 注入代码以继续进行攻击。

具体细节可以参考 [这篇文章](https://improsec.com/tech-blog/windows-kernel-shellcode-on-windows-10-part-2)。

#### 方法二：修改 TOKEN 结构体

在 Windows 10 中，`TOKEN` 结构体的定义如下：

```cpp
kd> dt nt!_TOKEN
+0x000 TokenSource      : _TOKEN_SOURCE
+0x010 TokenId          : _LUID
+0x018 AuthenticationId : _LUID
+0x020 ParentTokenId    : _LUID
+0x028 ExpirationTime   : _LARGE_INTEGER
+0x030 TokenLock        : Ptr32 _ERESOURCE
+0x034 ModifiedId       : _LUID
+0x040 Privileges       : _SEP_TOKEN_PRIVILEGES
+0x058 AuditPolicy      : _SEP_AUDIT_POLICY
+0x078 SessionId        : Uint4B
+0x07c UserAndGroupCount : Uint4B
+0x080 RestrictedSidCount : Uint4B
+0x084 VariableLength   : Uint4B
+0x088 DynamicCharged   : Uint4B
+0x08c DynamicAvailable : Uint4B
+0x090 DefaultOwnerIndex : Uint4B
+0x094 UserAndGroups    : Ptr32 _SID_AND_ATTRIBUTES
+0x098 RestrictedSids   : Ptr32 _SID_AND_ATTRIBUTES
+0x09c PrimaryGroup     : Ptr32 Void
+0x0a0 DynamicPart      : Ptr32 Uint4B
+0x0a4 DefaultDacl      : Ptr32 _ACL
+0x0a8 TokenType        : _TOKEN_TYPE
+0x0ac ImpersonationLevel : _SECURITY_IMPERSONATION_LEVEL
+0x0b0 TokenFlags       : Uint4B
+0x0b4 TokenInUse       : UChar
+0x0b8 IntegrityLevelIndex : Uint4B
+0x0bc MandatoryPolicy  : Uint4B
+0x0c0 LogonSession     : Ptr32 _SEP_LOGON_SESSION_REFERENCES
+0x0c4 OriginatingLogonSession : _LUID
+0x0cc SidHash          : _SID_AND_ATTRIBUTES_HASH
+0x154 RestrictedSidHash : _SID_AND_ATTRIBUTES_HASH
+0x1dc pSecurityAttributes : Ptr32 _AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION
+0x1e0 Package          : Ptr32 Void
+0x1e4 Capabilities     : Ptr32 _SID_AND_ATTRIBUTES
+0x1e8 CapabilityCount  : Uint4B
+0x1ec CapabilitiesHash : _SID_AND_ATTRIBUTES_HASH
+0x274 LowboxNumberEntry : Ptr32 _SEP_LOWBOX_NUMBER_ENTRY
+0x278 LowboxHandlesEntry : Ptr32 _SEP_CACHED_HANDLES_ENTRY
+0x27c pClaimAttributes : Ptr32 _AUTHZBASEP_CLAIM_ATTRIBUTES_COLLECTION
+0x280 TrustLevelSid    : Ptr32 Void
+0x284 TrustLinkedToken : Ptr32 _TOKEN
+0x288 IntegrityLevelSidValue : Ptr32 Void
+0x28c TokenSidValues   : Ptr32 _SEP_SID_VALUES_BLOCK
+0x290 IndexEntry       : Ptr32 _SEP_LUID_TO_INDEX_MAP_ENTRY
+0x294 DiagnosticInfo   : Ptr32 _SEP_TOKEN_DIAG_TRACK_ENTRY
+0x298 BnoIsolationHandlesEntry : Ptr32 _SEP_CACHED_HANDLES_ENTRY
+0x29c SessionObject    : Ptr32 Void
+0x2a0 VariablePart     : Uint4B
```

其中最关键的部分是 `_SEP_TOKEN_PRIVILEGES`，它记录了当前进程的特权：

```cpp
nt!_SEP_TOKEN_PRIVILEGES
+0x000 Present          : Uint8B
+0x008 Enabled          : Uint8B
+0x010 EnabledByDefault : Uint8B
```

Windows 在运行过程中会检查 `Enabled` 字段中的特权。如果这些特权被启用，当前进程将获得所有类型的特权。以下是一个示例代码：

```cpp
HANDLE hCurrentProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, GetCurrentProcessId());
if (!hCurrentProcess) {
    std::cout << "Failed to open process" << std::endl;
} else {
    // 修改目标地址
    ULONG_PTR dwTargetOffset = ...; // 目标偏移量
    ULONG_PTR uAllPrivelage = ...; // 特权值
    Vunelrable(dwTargetOffset, uAllPrivelage);

    // 尝试注入代码
    InjectToWinlogon();
}
```

#### 方法三：替换 TOKEN

这是目前最常用的方法，即直接替换 `EPROCESS` 结构中的 `Token` 字段。`EPROCESS` 结构体的部分定义如下：

```cpp
0: kd> dt nt!_EPROCESS
//....
+0x0d8 ProcessQuotaUsage : [2] Uint4B
+0x0e0 ProcessQuotaPeak : [2] Uint4B
+0x0e8 PeakVirtualSize  : Uint4B
+0x0ec VirtualSize      : Uint4B
+0x0f0 SessionProcessLinks : _LIST_ENTRY
+0x0f8 ExceptionPortData : Ptr32 Void
+0x0f8 ExceptionPortValue : Uint4B
+0x0f8 ExceptionPortState : Pos 0, 3 Bits
+0x0fc Token            : _EX_FAST_REF
```

一种常见的利用思路如下：

1. **Hook `NtOpenThreadToken()`**：
   - 截获 `SystemToken`。
   
2. **多次写能力**：
   - 将 `TOKEN-0x18`（即 `PointerCount`）数量加1。
   - 修改当前进程的 `Token` 为截获的 `SystemToken`。

3. **单次写能力**：
   - 选择一个不太可能结束的进程（例如 `system`）。
   - 修改当前进程的 `Token` 之后，从该进程中复制两个 `Token` 句柄。

## 参考链接

- [Windows Kernel Shellcode on Windows 10 Part 2](https://improsec.com/tech-blog/windows-kernel-shellcode-on-windows-10-part-2)