.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ9 1"
.TH PERLFAQ9 7 "2003-11-25" "perl v5.8.3" "Perl Programmers Reference Guide"
.SH "NAME"
perlfaq9 \- 网络 (2003/01/31 17:36:57 )
.SH "DESCRIPTION 描述"
.IX Header "DESCRIPTION"
网络通信，互联网以及少量有关 web 的内容
.Sh "What is the correct form of response from a \s-1CGI\s0 script?"
.IX Subsection "一个 CGI 脚本的回应的正确格式是什么？"
(Alan Flavell  answers...)
.PP
The Common Gateway Interface (\s-1CGI\s0) specifies a software interface between
a program (\*(L"\s-1CGI\s0 script\*(R") and a web server (\s-1HTTPD\s0). It is not specific
to Perl, and has its own FAQs and tutorials, and usenet group,
comp.infosystems.www.authoring.cgi
.PP
The original \s-1CGI\s0 specification is at: http://hoohoo.ncsa.uiuc.edu/cgi/
.PP
Current best-practice \s-1RFC\s0 draft at: http://CGI\-Spec.Golux.Com/
.PP
Other relevant documentation listed in: http://www.perl.org/CGI_MetaFAQ.html
.PP
These Perl FAQs very selectively cover some \s-1CGI\s0 issues. However, Perl
programmers are strongly advised to use the \s-1CGI\s0.pm module, to take care
of the details for them.
.PP
The similarity between \s-1CGI\s0 response headers (defined in the \s-1CGI\s0
specification) and \s-1HTTP\s0 response headers (defined in the \s-1HTTP\s0
specification, \s-1RFC2616\s0) is intentional, but can sometimes be confusing.
.PP
The \s-1CGI\s0 specification defines two kinds of script: the \*(L"Parsed Header\*(R"
script, and the \*(L"Non Parsed Header\*(R" (\s-1NPH\s0) script. Check your server
documentation to see what it supports. \*(L"Parsed Header\*(R" scripts are
simpler in various respects. The \s-1CGI\s0 specification allows any of the
usual newline representations in the \s-1CGI\s0 response (it's the server's
job to create an accurate \s-1HTTP\s0 response based on it). So \*(L"\en\*(R" written in
text mode is technically correct, and recommended. \s-1NPH\s0 scripts are more
tricky: they must put out a complete and accurate set of \s-1HTTP\s0
transaction response headers; the \s-1HTTP\s0 specification calls for records
to be terminated with carriage-return and line\-feed, i.e \s-1ASCII\s0 \e015\e012
written in binary mode.
.PP
Using \s-1CGI\s0.pm gives excellent platform independence, including \s-1EBCDIC\s0
systems. \s-1CGI\s0.pm selects an appropriate newline representation
($CGI::CRLF) and sets binmode as appropriate.
.Sh "我的 CGI 脚本从命令行执行正常，但是在浏览器中不行 (500 Server Error)。"
.IX Subsection "My CGI script runs from the command line but not the browser.  (500 Server Error)"
可能有很多事错了。可以仔细阅读 \*(L"Troubleshooting
Perl \s-1CGI\s0 scripts\*(R" guide, 位置是
.PP
.Vb 1
\&        http://www.perl.org/troubleshooting_CGI.html
.Ve
.PP
如果接下来，你能证明你已阅读了 FAQ 并且你的问题不是那么简单，非叁言两语即可回答的话，那么您 post到 comp.infosystems.www.authoring.cgi上（如果是有关 HTTP 、 HTML ，或 CGI通信协定）的问题可能也会得到口气和缓而有用的答复。表面上看似 Perl，但骨子里是 CGI之类的问题，如果 post到 comp.lang.perl.misc人家可能就不会这么乐意地接受了。
.PP
几个实用的 FAQ，相关文档和查错向导列在 \s-1CGI\s0 Meta \s-1FAQ\s0 中：
.PP
.Vb 1
\&        http://www.perl.org/CGI_MetaFAQ.html
.Ve
.Sh "如何从 CGI 程序中得到好一点的错误提示？"
.IX Subsection "How can I get better error messages from a CGI program?"
Use the CGI::Carp module.  It replaces \f(CW\*(C`warn\*(C'\fR and \f(CW\*(C`die\*(C'\fR, plus the
normal Carp modules \f(CW\*(C`carp\*(C'\fR, \f(CW\*(C`croak\*(C'\fR, and \f(CW\*(C`confess\*(C'\fR functions with
more verbose and safer versions.  It still sends them to the normal
server error log.
.PP
.Vb 3
\&    use CGI::Carp;
\&    warn "This is a complaint";
\&    die "But this one is serious";
.Ve
.PP
The following use of CGI::Carp also redirects errors to a file of your choice,
placed in a \s-1BEGIN\s0 block to catch compile-time warnings as well:
.PP
.Vb 6
\&    BEGIN {
\&        use CGI::Carp qw(carpout);
\&        open(LOG, ">>/var/local/cgi-logs/mycgi-log")
\&            or die "Unable to append to mycgi-log: $!\en";
\&        carpout(*LOG);
\&    }
.Ve
.PP
You can even arrange for fatal errors to go back to the client browser,
which is nice for your own debugging, but might confuse the end user.
.PP
.Vb 2
\&    use CGI::Carp qw(fatalsToBrowser);
\&    die "Bad error here";
.Ve
.PP
Even if the error happens before you get the \s-1HTTP\s0 header out, the module
will try to take care of this to avoid the dreaded server 500 errors.
Normal warnings still go out to the server error log (or wherever
you've sent them with \f(CW\*(C`carpout\*(C'\fR) with the application name and date
stamp prepended.
.Sh "如何将字符串中的 HTML 删除？"
.IX Subsection "How do I remove HTML from a string?"
最正确（尽管不是最快）的方法是使用 HTML::Parse模组（可由 CPAN取得，是所有写 Web程式者必备的 libwww-perl 套件的一部分）。另一中最正确的办法是使用 HTML::FormatText，它不仅删除了 \s-1HTML\s0，同时也试图对结果文本进行简单的格式化。
.PP
许多人尝试用简陋的正规表示式来解决这个问题，譬如说像 \f(CW\*(C`s///g\*(C'\fR，但这个式子在很多情况下会失败，因为要处理的字串可能会跨越断行字元，也可能含有被 quote【跳脱】的箭头号，或有 HTML comment出现；再加上一些疏忽，譬如，人们常忘了转换如 '"]*|(['"]).*?\e1)*>//gs
.Ve
.PP
如果您想要更完整的解法，请看叁部曲的 striphtml 程式，
http://www.cpan.org/authors/Tom_Christiansen/scripts/striphtml.gz
\&.
.PP
Here are some tricky cases that you should think about when picking
a solution:
.PP
.Vb 1
\&     B">
.Ve
.PP
.Vb 2
\&     B">
.Ve