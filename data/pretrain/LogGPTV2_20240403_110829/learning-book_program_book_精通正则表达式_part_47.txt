$~R
reset（308）study（359)
内嵌代码的运行结果（302）
---
## Page 312
286
第7章：Perl
Perl的功能非常强大，但它提供的运算符数量非常少，这样有利也有。
Perl的长处
Perl's Greatest Strength
Perl最大的优势可能在于，Perl的运算符和函数提供了丰富的选项。根据应用场合的不同，
它们的行为也不同，当然，这通常是执行者在那种场合自然想到的操作。O'Reilly的
正则匹配运算符m/regex/提供了许多神奇的功能，会根据应用的场合、方式以及修饰符的
不同而变化。
Perl的短处
Perls Greatest Veakness
表达能力太强，也是Perl最大的毛病之一。哪怕只是进行极小的修改，也有数不清的特殊
情况、条件和场合在你眼皮底下发生变化，但却不会通知你一-不经意之间就切换到另
种应用场合（注2)。在ProgrammingPerl这本书中，上面那句话的下半句是“只是缺乏一
致性（consistency）”。当然，对计算机科学来说，固定、一致而值得依赖的接口是可取的。
Perl的强大功能在有经验的用户手里可能是强大的武器，但情况似乎是，你的Perl技能不
断增长，是以不断地射伤自己的腿脚为代价的。
Perl的正则流派
Perl's Regex Flavor
下一页的表7-2概要描述Perl的正则风格。以前，Perl的许多元字符是其他系统不支持的，
但是经过许多年之后，其他系统接受了许多Perl的创新。这些常见的特性在第3章的概览
里有描述，但是Perl还有专属于自已的元素，会在本章后面讲解（表7-2覆盖了将要讲解
的各个元素）
下面是对表格的补充：
①（b只有在字符组内部才是退格符的简记法。在字符组外部，\b表示单词分界符（133)。
八进制转义接收2到3位的数值。
xnum;十六进制转义接收两位数字（也可以是一位数字，但是会报警）。\x（num）：能
接收任意长度的十六进制数。
注2：虽然应用场合的数目很多，但我还是希望在本章涵盖所有内容。
---
## Page 313
Perl的正则流派
287
表7-2：Perl的正则流派概览
字符组缩略表示法
115 (c)
\a[\b]\e\f\n\r\t\octal\xhexx{hex}\cchar
字符组及相关结构
118
字符组：[·][A….]（可能包括类似POSIX的[：alpha：]表示法，r127）
119
除换行符外的所有字符：点号（使用/s时能匹配所有字符）
120
Unicode组合字符序列：\x
120
单个字节（有危险）：\C
120(c)
字符组缩略表示法：\w\d\s\W\D\S
121(c）
Unicode属性，字母表和区块：\p（Prop）\P（Prop）
锚点及其他零长度断言
129
行/字符串起始位置：^\A
129
行/字符串结束位置：S\z\Z
315
前一次匹配的结束位置：\G
133
单词分界符：\b\B
133
环视：（？=…….）（？！….）（？…）
139
多选结构：1
140
条件判断：（?ifthenlelse）一-if部分可以为内嵌代码、环视，或是（num）
141
匹配优先量词：*+？（n）（n，）（x,y）
141
忽略优先量词：*？+？？？（n}？（n，）？（x，y）？
327
内嵌代码：（？（））
327
动态表达式：（？？（））
专属于正则文字的功能
289 (c)
变量插值：$name@name
290 (c)
大小写转换：\1\u
290(c)
大小写转换范围：\U\L\E
290 (c)
文字文本范围：QE
290(c)
命名的Unicode字符：\N{name}—可选出现，参见第290页
（c）表示可以在字符组内部使用①，参见补充内容
---
## Page 314
288
第7章：Perl
②\w、\d、\s之类完全支持Unicode。
Perl的\s不能匹配ASCll的垂直制表符（115）。
③Perl的Unicode支持针对的是UnicodeVersion4.1.0。
Unicode字母表也能支持。字母表和属性名可以有Is’前缀，但并非必须（125）。
Perl也支持\p（L&）、\p（Any}、\p（A11)、\p{Assigned）和\p（Unassigned)属性。
Perl支持例如\p{Letter）的长属性名。名字的各个单词之间可能是空格、下画线，
或者什么也没有，（例如\p（Lowercase_Letter），也可能写作\p{Lowercase
Letter)）或者是p（Lowercase*Letter)i)，为了前后一致，我推荐使用第123页表
格中的长命名。
p（~…)）等价于P（..）1
③单词分界符完全支持Unicode。
③顺序环视可能包含捕获型括号。
逆序环视中的子表达式必须匹配固定长度的文本。
/x修饰符只能识别ASCII空白字符。/m只对换行符有影响，而且不是所有的Unicode
换行符。
/i能够在Unicode中正常工作。
所有的元字符并不是生而平等的。“正则元字符”没有得到正则引擎的支持，但Perl的正则
文字预处理机制能对付。
正则运算符和正则文字
Regex Operands and Regex Literals
表7-2最下面的条目标注有“专属于正则文字”。正则文字（regexliteral）就是m/regex/部
解析规则。用Perl的行话来说，正则文学就是“表示正则含义的双引l号字符串（regex-aware
double-quotedstring）”，及处理之后传递给正则引I擎的结果。正则文字处理机制提供了特殊
的功能来构建正则表达式。
举例来说，正则文字提供了变直插值功能。如果变量Snum的值是20，代码m/：.（Snum）：/
得到的就是：.（20）：。这样可以根据需要即时构建正则表达式。正则文字的另一功能是大
---
## Page 315
Perl的正则流派
289
小写自动切换展开，\U\E可以保证其中的字母均为大写。比如，m/abc\Uxy2\E/得到正
则表达式abcXYZi。这个例子有点做作，如果需要使用'abcXYZi，应该直接输入m/abcXYz/，
但是这种功能结合变量插值就很有用：如果变量Stag包含字符串“title”，则代码
m{}得到‘le
除正则文字之外还有什么呢？我们可以把字符事（或者任何表达式）当作正则运算元，比
如：
SMatchField="^Subject："；#普通字将事赋值
if (Stext =~ $MatchField)(
当SMatchField用作=~的运算元时，它的值就被解释（interpreted）为正则表达式。这里只
能“解释”普通的正则表达式，所以不支持只作用于正则文字的变量插值和“Q\El。
下面的例子值得思考，如果把：
Stext =~ $MatchField
替换为：
Stext=~m/$MatchField/
结果完全一样。这里的正则文字只包含一个元素一一变量sMatchField。正则文字中插值变
量的值不会被当作正则文字处理，所以变量内的\u\E和svar之类不会被识别（第292页
说明了正则文字的处理细节）。
如果正则表达式在程序的执行期间需要多次用到，那幺正则运算元采用字符串或变量插值
的效率差距就很明显。第348页讨论了这个问题。
正则文字支持的特性
正则文字提供下面的特性：
变量插值正则表达式中以s和e开头的变量会被替换为实际变量的值。$变量插人一个
简单的纯量值（scalarvalue）。以e开头的插入数组或者数组的一部分，以空格分隔各
个元素（其实是以$"变量作分隔符，它的默认值是空格）。
在Perl中，‘’引l人一个散列变量（hashvariable），但是在字符串中插人-个散列变
量并没有太大的意义，所以Perl不支持&插值。
---
## Page 316
290
第7章：Perl
·命名的Unicode字符如果程序中包含“usecharnames'：full'；”，就可以用\N（name）
序列引I用Unicode字符。例如，\N(LATIN SMALL LETTER SHARP S)匹配“s”。在Perl
的unicore目录下的UnicodeData.txt中可以找到Perl支持的Unicode字符列表。下面
的代码能够报告文件的位置：
use Config;
print *SConfig{privlib)/unicore/UnicodeData.txt\n*;
真如此的话，\N（）就不能正常工作。同样，如果使用了下面介绍的正则表达式重载，
AN（.）也不能正常工作。
大小写转换前缀\1和\u能够把后面的字符转换为小写或大写形式。通常我们使用此
功能来转换插值变量的第一个字符。举例来说，如果变量stitle包含“mr.”，m/…
\uStitle/就能生成正则表达式.Mr."。Perl的lcfirst（)和ucfirst（）函数提
供了同样的功能。
大小写转换范圈\L和\能够把后面所有的字符转换为小写或大写，其作用范围一直
到表达式末尾，或是\B为止。同样是stitle，m/\UStitle\E…/会产生正则表达式
.MR.…)。Perl的1c（）和uc（）函数提供了同样的功能。
我们可以把这两者结合起来：无论变量stitle采用怎样的字母组合，m/….
\L\uStitle\E../都会得到..Mr..。
文字文本范图\Q“转义（quote）”正则表达式元字符（也就是在它们之前放一个反斜
线，保证它们只作为普通的字符），其作用范围直到字符串的结尾，或者直到\B。它能
转义正则表达式元字符，但不能转义表示变量插值的正则文字\0，当然也不能转义\B。
奇怪的是，如果反斜线开头的字符序列不能识别-—例如\F或者\H，反斜线也不会被
转义。即使是\Q…\E，这样的序列也会导致“unrecognizedescape”警告。
在实践中，这些限制并不是严重的缺陷，\Q\E通常用于引用插值文本，这样就可
/就会生成正则表达式·Mr\.，我们要的就是这样—希望匹配的是stitle中的字
符，而不是Stitle中的正则表达式。
如果你希望在正则表达式中包含某些用户输入的数据，这非常有用。举例来说，
m/\QSUserInput\E/i能够对sUserInput（作为字符串，而不是正则表达式）中的字
符进行不区分大小写的搜索。
Perl的函数quotemeta（)提供了与\Q\E等价的功能。
---
## Page 317
Perl的正则流派
291
重载借助重载，用户可以使用任何期望的方式预处理正则文字的文字字符。这是概念
值得讨论，但是目前的实现还有诸多限制。关于重载的细节讨论请参见第341页。
使用自己的正则表达式分隔符
统的分隔符是斜线，例如m/…/、s/./…./和qr/…/，不过还可以使用除数字、字母和空
格之外的字符。常用的包括：
m! ..-!
m(...}
m, *"',
m
S i ... | ... |
m[...]
qr#..#
m (...)
右边四个是特殊的分隔符：
右边的四个例子具有不同的开始-结束分隔符，而且可能嵌套（也就是说，如果开始-
结束分隔符匹配恰当，表达式中容许包含与分隔符一样的字符）。因为圆括号和方括号
在正则表达式中经常用到，m()和m[…]可能不如其他更有吸引力。使用/x修饰符时，
可能出现下面的形式：
m (
regex#comments
here
#here
)x;
也可以使用某种组合标记regex，另一组（如果你喜欢，也可以用同样的）标记
replacement。例如：
Ss {..) !...!
S(...)
s[...] /.../
如果这样做了，就可以在两对分隔符之间插人空格和注释。第319页进一步讲解了
substitution运算符的replacement运算元。
对match运算符来说，把问号作为分隔符有其特殊价值（禁止更多的匹配），这一点在
下一节讲解关于match运算符时讨论（308）。
---