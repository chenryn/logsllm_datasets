### VIII. 相关工作

#### A. 以往的认证协议

过去的认证协议，无论是基于软件 [7], [33], [39], [63], [64], [66]、基于密码学 [8], [18], [21], [31], [38], [53] 还是混合型 [43], [78]，其安全目标与本文定义的RoT（Root of Trust）要求不同：有些较弱，有些较强。例如，这些协议无论用于单个设备还是多个设备，通常旨在验证一个较弱的属性，即软件状态的完整性而非系统状态的完整性。然而，它们也满足一个更强的属性：在所有基于密码学和混合型认证协议中，验证可以远程进行，并且可以在启动后重复进行，而不是仅限于预启动时间。

由于这些不同的目标，过去的一些认证协议未能满足第二节中定义的某些RoT建立要求，即使对于有界对手也是如此。此外，这些协议不需要关注系统寄存器的内容（例如，通用处理器和I/O寄存器），因为它们不能包含可执行代码。此外，它们也不需要满足验证者协议中的并发事务顺序和持续时间要求（见II-C节），因为它们不需要建立任何系统状态属性，如多设备系统中的安全初始状态。最后，这些协议都没有旨在无条件地满足安全性属性。除了这些共同的区别之外，过去的协议还表现出一些特定的不同点。

**基于软件的认证**

有些应用程序在使用基于软件的认证时不需要控制流完整性 [58]，自然这种要求并不总是被满足 [11], [42]。在一个多设备系统中，如果使用传统的具有固定时间界限的校验和设计，则会遇到更微妙的挑战，因为可扩展的时间界限非常重要。如II-C节所示，这些校验和不能通过反复调用带有不同随机数的校验和来扩展时间界限并保持最优性。基于软件的认证模型 [7], [33] 也面临这一挑战。

尽管与RoT建立存在差异，基于软件的认证设计仍实现了其目标 [63], [64]，并在如何检测外围控制器 [43]、嵌入式设备 [11], [42]、移动电话 [33] 和特殊处理器（例如TPM [39]）上的恶意软件方面提供了深刻的见解。

**基于密码学的认证**

远程认证的密码学协议通常需要每个设备中的可信硬件模块，这可以简单到ROM模块 [38] 来保护用于计算数字签名或MAC的秘密密钥。如果用于RoT建立，签名或MAC计算必须能够验证地建立控制流完整性。否则，会出现类似于基于软件认证的控制流漏洞。此外，可信硬件模块必须同时保护秘密密钥和签名/MAC生成代码。

更重要的是，基于密码学的认证将信任根转移到安装密码学密钥的第三方以及向验证者分发这些密钥的第三方。然而，这些第三方的信任度可能是不确定的；例如，在可能强制披露秘密的司法管辖区运营的外围控制器供应商无法保证受保护的密码学密钥的机密性。同样，设备供应商/集成商和验证者之间建立的签名验证证书的分发渠道的完整性可能会受到损害，从而启用已知攻击；例如，参见Cuckoo攻击 [55]。因此，这些协议只能提供有条件的安性。

尽管如此，如果管理系统的秘密由第三方带来的风险是可以接受的，并且协议原子性要求得到满足，那么基于密码学的远程认证协议可以用于RoT建立。

#### B. 多项式求值

如果多项式求值只允许加法和乘法操作，Horner法则对d次多项式的2d次操作已被证明在一次性求值中是最优的 [9], [61]。然而，这个界限在有限域中不成立，在有限域中，最小的模加法和乘法次数为Ω(√(d + 1)) [35]。此外，这些界限在任何WRAM模型或任何实际计算机中都不成立，因为ISA中实现的操作更多。

对于具有可变字宽的WRAM模型，多项式求值的下界通常在单元探测模型中获得。在这里，假设多项式已经在内存中初始化。求值包括读取（探测）内存中的若干单元，当所有读操作完成后，必须输出结果。每次读操作探测的单元可以是之前探测的单元和读操作的任意函数，因此对已经读取的数据的所有计算不占用时间。

使用单元探测模型，Gál和Miltersen [22] 表明，评估d次多项式所需的额外数据结构大小r必须满足r · t = Ω(d)，其中t是探测次数，d ≤ p/(1 + ε)，p是一个素数，ε > 0。对于线性空间数据结构（即w位字和内存大小|M| = O(d·log p/w)），Larsen的下界为Ω(log p)是最高的 [40]，但它离已知的最低上界还有一定距离 [36]。这两个界限在cWRAM或实际计算机中均不成立。

### IX. 结论

RoT建立是解决各种基本系统安全问题所必需的原语，包括从安全初始状态启动系统 [24], [25] 和执行可信恢复 [51]。自这些问题几十年前被识别以来，它们一直未被彻底解决。随着持久性恶意软件攻击的出现，这些问题变得更加困难。RoT建立也是可验证启动——比安全和可信启动更强的概念 [23] 所必需的。

在本文中，我们展示了通过适当的理论基础，RoT建立可以既是可证明的又是无条件的。据我们所知，迄今为止还没有其他软件安全问题有这样的解决方案。最后，不受信任系统上的时间测量的安全性一直是一个长期未解决的工程问题 [39], [42], [43], [63]。在这里，我们也展示了这个问题可以通过验证者的协议的可证明原子性轻松解决。

### 致谢

感谢Pompiliu Donescu、Bryan Parno、Adrian Perrig、Vyas Sekar、Gene Tsudik、Osman Yağan和Jun Zhao的评论，使本文的清晰度得到了显著提高。

### 参考文献

[此处列出参考文献]

通过这样的优化，文本更加连贯、专业，并且易于理解。希望这对你有所帮助！