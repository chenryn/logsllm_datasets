# 03 \| 重复代码：简单需求到处修改，怎么办？你好，我是郑晔。前面两讲，我们讨论了命名中的坏味道。今天，我们来讨论另外一个常见的坏味道：重复代码。记得我刚开始工作的时候，有人开玩笑说，编程实际上就是 CVS（CVS是当时流行的一个版本控制工具，相当于今天的 Git），也就是Ctrl+C、Ctrl+V、Ctrl+S，或许你已经听出来了，这是在调侃很多程序员写程序依靠的是复制粘贴。时至今日，很多初级程序员写代码依然规避不了复制粘贴，基本的做法就是把一段代码复制过来，改动几个地方，然后，跑一下没有太大问题就万事大吉了。殊不知，这种做法就是在给未来挖坑。通常情况下，只要这些复制代码其中有一点逻辑要修改，就意味着所有复制粘贴的地方都要修改。所以，我们在实际的项目中，常常看见这样的情况：明明是一个简单的需求，你却需要改很多的地方，需要花费很长的时间，结果无论是项目经理，还是产品经理，对进度都很不满意。更可怕的是，只要你少改了一处，就意味着留下一处潜在的问题。问题会在不经意间爆发出来，让人陷入难堪的境地。复制粘贴是最容易产生重复代码的地方，所以，一个最直白的建议就是，不要使用复制粘贴。**真正应该做的是，先提取出函数，然后，在需要的地方调用这个函数。**其实，复制粘贴的重复代码是相对容易发现的，但有一些代码是有类似的结构，这也是重复代码，有些人对这类坏味道却视而不见。重复的结构我们看一下下面的几段代码：    @Task    public void sendBook() {      try {        this.service.sendBook();      } catch (Throwable t) {        this.notification.send(new SendFailure(t)));        throw t;      }    }    @Task    public void sendChapter() {      try {        this.service.sendChapter();      } catch (Throwable t) {        this.notification.send(new SendFailure(t)));        throw t;      }    }    @Task    public void startTranslation() {      try {        this.service.startTranslation();      } catch (Throwable t) {        this.notification.send(new SendFailure(t)));        throw t;      }    }这三段函数业务的背景是：一个系统要把作品的相关信息发送给翻译引擎。所以，结合着代码，我们就不难理解它们的含义，sendBook是把作品信息发出去，sendChapter 就是把章节发送出去，而 startTranslation则是启动翻译。这几个业务都是以后台的方式在执行，所以，它们的函数签名上增加了一个Task 的Annotation，表明它们是任务调度的入口。然后，实际的代码执行放到了对应的业务方法上，也就是service 里面的方法。这三个函数可能在许多人看来已经写得很简洁了，但是，这段代码的结构上却是有重复的，请把注意力放到catch 语句里。之所以要做一次捕获（catch），是为了防止系统出问题无人发觉。捕获到异常后，我们把出错的信息通过即时通讯工具发给相关人等，代码里的notification.send就是发通知的入口。相比于原来的业务逻辑，这个逻辑是后来加上的，所以，这段代码的作者不厌其烦地在每一处修改了代码。我们可以看到，虽然这三个函数调用的业务代码不同，但它们的结构是一致的，其基本流程可以理解为：1.  调用业务函数；        2.  如果出错，发通知。        当你能够发现结构上的重复，我们就可以把这个结构提取出来。从面向对象的设计来说，就是提出一个接口，就像下面这样：    private void executeTask(final Runnable runnable) {      try {        runnable.run();      } catch (Throwable t) {        this.notification.send(new SendFailure(t)));        throw t;      }    }有了这个结构，前面几个函数就可以用它来改写了。对于支持函数式编程的程序设计语言来说，可以用语言提供的便利写法简化代码的编写，像下面的代码就是用了Java 里的方法引用（MethodReference）：    @Task    public void sendBook() {      executeTask(this.service::sendBook);    }    @Task    public void sendChapter() {      executeTask(this.service::sendChapter);    }    @Task    public void startTranslation() {      executeTask(this.service::startTranslation);    }经过这个例子的改写，如果再有一些通用的结构调整，比如，在任务执行前后要加上一些日志信息，这样的改动就可以放到executeTask这个函数里，而不用四处去改写了。这个例子并不复杂，关键点在于，能不能发现结构上的重复。因为相比于直接复制的代码，结构上的重复看上去会有一些迷惑性。比如，在这个例子里，发送作品信息、发送章节、启动翻译看起来是三件不同的事，很难让人一下反应过来它也是重复代码。一般来说，参数是名词，而函数调用，是动词。我们传统的程序设计教育中，对于名词是极度重视的，但我们必须认识到一点，动词也扮演着重要的角色，尤其是在函数式编程兴起之后。那你就需要知道，动词不同时，并不代表没有重复代码产生。理解到这一点，我们就容易发现结构上的相似之处。比如在上面的例子中，发送作品信息、发送章节、启动翻译之所以看上去是三件不同的事，只是因为它们的动词不同，但是除了这几个动词之外的其它部分是相同的，所以，它们在结构上是重复的。做真正的选择我们再来看一段代码：    if (user.isEditor()) {      service.editChapter(chapterId, title, content, true);    } else {      service.editChapter(chapterId, title, content, false);    }这是一段对章节内容进行编辑的代码。这里有一个业务逻辑，章节只有在审核通过之后，才能去做后续的处理，比如，章节的翻译。所以，这里的editChapter方法最后那个参数表示是否审核通过。在这段代码里面，目前的处理逻辑是，如果这个章节是由作者来编辑的，那么这个章节是需要审核的，如果这个章节是由编辑来编辑的，那么审核就直接通过了，因为编辑本身同时也是审核人。不过，这里的业务逻辑不是重点，只是帮助你理解这段代码。问题来了，这个 if选择的到底是什么呢？相信你和我一样，第一眼看到这段代码的感觉一定是，if选择的一定是两段不同的业务处理。但只要你稍微看一下，就会发现，if 和 else两段代码几乎是一模一样的。在经过仔细地"找茬"之后，才能发现，原来是最后一个参数不一样。只有参数不同，是不是和前面说的重复代码是如出一辙的？没错，这其实也是一种重复代码。只不过，这种重复代码通常情况下是作者自己写出来的，而不是粘贴出来的。因为作者在写这段代码时，**脑子只想到 if 语句判断之后要做什么，而没有想到这个 if语句判断的到底是什么。**但这段代码客观上也造就了重复。写代码要有表达性。把意图准确地表达出来，是写代码过程中非常重要的一环。显然，这里的if判断区分的是参数，而非动作。所以，我们可以把这段代码稍微调整一下，会让代码看上去更容易理解：    boolean approved = user.isEditor();    service.editChapter(chapterId, title, content, approved);请注意，这里我把 user.isEditor() 判断的结果赋值给了一个 approved的变量，而不是直接作为一个参数传给editChapter，这么做也是为了提高这段代码的可读性。因为 editChapter最后一个参数表示的是这个章节是否审核通过。通过引入 approved变量，我们可以清楚地看到，一个章节审核是否通过的判断条件是"用户是否是一个编辑"，这种写法会让代码更清晰。如果将来审核通过的条件改变了，变化的点全都在 approved的这个变量的赋值上面。如果你追求更有表达性的做法，甚至可以提取一个函数出来，这样，就把变化都放到这个函数里了，就像下面这样：    boolean approved = isApproved(user);    service.editChapter(chapterId, title, content, approved);    private boolean isApproved(final User user) {      return user.isEditor();    }为了说明问题，我特意选择了一段简单的代码，if语句的代码块里只有一个语句。在实际的工作中，if语句没有有效地去选择目标是经常出现的，有的是参数列表比较长，有的是在 if的代码块里有多个语句。所以， **只要你看到 if语句出现，而且 if 和 else的代码块长得又比较像，多半就是出现了这个坏味道。**如果你不想所有人都来玩"找茬"游戏，赶紧消灭它。重复是一个泥潭，对于程序员来说，时刻提醒自己不要重复是至关重要的。在软件开发里，有一个重要的原则叫做Don\'t Repeat Yourself（不要重复自己，简称DRY），我在《软件设计之美slate-object="inline"》中也讲到过它，而更经典的叙述在《程序员修炼之道slate-object="inline"》中。>  > 在一个系统中，每一处知识都必须有单一、明确、权威地表述。> > >>>  > Every piece of knowledge must have a single, unambiguous,> authoritative representation within a> system.> >**写代码要想做到DRY，一个关键点是能够发现重复**。发现重复，一种是在泥潭中挣扎后，被动地发现，还有一种是提升自己识别能力，主动地发现重复。这种主动识别的能力，其实背后要有对软件设计更好的理解，尤其是对分离关注点的理解（如果你对"分离关注点"的知识感兴趣，可以参考我在《软件设计之美》中的02slate-object="inline"讲）。总结时刻这一讲我们讲到重复代码，讲到了几个典型的坏味道：1.  复制粘贴的代码；        2.  结构重复的代码；        3.  if 和 else    代码块中的语句高度类似。        很多重复代码的产生通常都是从程序员偷懒开始的，而这些程序员的借口都是为了快，却为后续工作埋下更多地隐患，真正的"欲速而不达"。复制粘贴的代码和结构重复的代码，虽然从观感上有所差异，但本质上都是重复，只不过，一个是名词的微调，一个是动词的微调。程序员千万不要复制粘贴，**如果需要复制粘贴，首先应该做的是提取一个新的函数出来，把公共的部分先统一掉。**if 和 else的代码块中的语句高度类似，通常是程序员不经意造成的，但这也是对于写代码没有高标准要求的结果。让if语句做真正的选择，是提高代码表达准确性的重要一步。作为一个精进中的程序员，我们一定要把 DRY原则记在心中，时时刻刻保持对"重复"的敏感度，把各种重复降到最低。如果今天的内容你只能记住一件事，那请记住：**不要重复自己，不要复制粘贴**。![](Images/d3f143a4790ecb9138cc930277bd69c9.png)savepage-src="https://static001.geekbang.org/resource/image/b1/d0/b191yy7a7dc54572cb7fce85d80f5fd0.jpg"}思考题这一讲的主题是重复代码，你在实际工作中都遇到过什么样的重复代码，你是怎样处理它们的呢？欢迎在留言区分享你的经验。参考资料：slate-object="mark"}分离关注点：软件设计至关重要的第一步简单设计：难道一开始就要把设计做复杂吗？
# 04 \| 长函数：为什么你总是不可避免地写出长函数？你好，我是郑晔。这一讲，我们来讲一个你一定深恶痛绝的坏味道：长函数。有一个关于程序员的段子，说程序员一定要用大屏显示器，而且一定要竖起来用，这样才能看到一个函数的全貌。这显然是在调侃函数很长，小屏甚至横屏都不足以看到整个函数，只有竖起来才行。只要一提到长函数，无论是去被迫理解一个长函数的含义，还是要在一个长函数中，小心翼翼地找出需要的逻辑，按照需求微调一下，几乎所有程序员都会有不愉悦的回忆。可以这么说，没有人喜欢长函数，但在实际工作中，却不得不去与各种长函数打交道。不知道你在实际工作中遇到最长的函数有多长，几百上千行的函数肯定是不足以称霸的。在我的职业生涯中，经常是我以为自己够见多识广了，但只要新接触到一个有悠久历史的代码库，就总会有突破认知的长函数出现。长函数是一个"我一说，你就知道怎么回事"的坏味道，我就不准备用一个典型的长函数来开启这一讲了，否则，这一讲的篇幅都不够了。但是，为了统一认识，我准备先讨论一下多长的函数算是长函数，我们来看一个案例。多长的函数才算"长"？有一次，我在一个团队做分享，讲怎么把一个长函数重构成小函数。现场演示之后，我问了大家一个问题：在你心目中，多长的函数才算长呢？一个现场听众很认真地思考了一下，给出了一个答案：100行。我很尴尬地看了一下自己刚刚重构掉的两个函数，最长的一个都不到 100行。换言之，以他的标准来看，这个函数根本就不是长函数，根本就没有必要重构。**对于函数长度容忍度高，这是导致长函数产生的关键点**。如果一个人认为 100行代码不算长，那在他眼中，很多代码根本就是没有问题的，也就更谈不上看到更多问题了，这其实是一个观察尺度的问题。这就好比，没有电子显微镜之前，人们很难理解疾病的原理，因为看不到病毒，就不可能理解病毒可以致病这个道理。**一个好的程序员面对代码库时要有不同尺度的观察能力，看设计时，要能够高屋建瓴，看代码时，要能细致入微**。这里的要点就是，看具体代码时，一定要能够看到细微之处。我在《10x 程序员工作法slate-object="inline"》专栏中讲到过"任务分解"，关键点就是将任务拆解得越小越好，这个观点对代码同样适用。随着对代码长度容忍度的降低，对代码细节的感知力就会逐渐提升，你才能看到那些原本所谓细枝末节的地方隐藏的各种问题。回到具体的工作中，"越小越好"是一个追求的目标，不过，没有一个具体的数字，就没办法约束所有人的行为。所以，通常情况下，我们还是要定义出一个代码行数的上限，以保证所有人都可以按照这个标准执行。我自己写代码的习惯是这样的。像 Python、Ruby这样表达能力比较强的动态语言，大多数情况下，一行代码（one-linerprogram）  slate-object="inline"可以解决很多问题，所以，我对自己的要求大约是 5行左右，并且能够用一行代码解决的问题，就尽量会用一行代码解决；而像 Java这样表达能力稍弱的静态类型语言，我也争取在 10行代码之内解决问题。当然，这是我对自己的要求，在实际的项目中，可能不是每个人都能做到这一点，所以，我给了一个更为宽松的限制，在自己的标准上翻了番，也就是20 行。 这不是一个说说就算的标准，我们应该把它变成一个可执行的标准。比如，在Java 中，我们就可以把代码行的约束加到 CheckStyle的配置文件中，就像下面这样：                                这样，在我们提交代码之前，执行本地的构建脚本，就可以把长函数检测出来（关于CheckStyle，我在《10x 程序员工作法slate-object="inline"》中讲项目自动化slate-object="inline"时专门做过介绍，你有兴趣不妨了解一下）。如果你用的是其它的程序设计语言，不妨也找一下相应的静态检查工具，看看是否提供类似的配置。我知道，即便是以 20行为上限，这也已经超过很多人的认知，具体的函数行数可以结合团队的实际情况来制定，但是，我非常不建议把这个数字放得很大，就像我前面说的那样，如果你放到100行，这个数字基本上是没有太多意义的，对团队也起不到什么约束作用。我之所以要先讨论多长的函数算是长函数，是因为如果你不能认识到代码行的标准应该很低，那么在接下来的讨论中，有些代码示例可能在你看来，就根本不需要调整了。长函数的产生不过，限制函数长度，是一种简单粗暴的解决方案。最重要的是你要知道，长函数本身是一个结果，如果不理解长函数产生的原因，还是很难写出整洁的代码。接下来，我们就来看看长函数是怎么产生的。1.  **以性能为由**        人们写长函数的历史由来已久。在《软件设计之美》专栏里，我讲过程序设计语言的发展历史。像 C语言这种在今天已经是高性能的程序设计语言，在问世之初，也曾被人质疑性能不彰，尤其是函数调用。在一些写汇编语言的人看来，调用函数涉及到入栈出栈的过程，显然不如直接执行来得性能高。这种想法经过各种演变流传到今天，任何一门新语言出现，还是会以同样的理由被质疑。所以，在很多人看来，把函数写长是为了所谓性能。不过，这个观点在今天是站不住的。**性能优化不应该是写代码的第一考量。**一方面，一门有活力的程序设计语言本身是不断优化的，无论是编译器，还是运行时，性能都会越来越好；另一方面，可维护性比性能优化要优先考虑，当性能不足以满足需要时，我们再来做相应的测量，找到焦点，进行特定的优化。这比在写代码时就考虑所谓性能要更能锁定焦点，优化才是有意义的。1.  **平铺直叙**        除了以性能为由把代码写长，还有一种最常见的原因也会把代码写长，那就是写代码平铺直叙，把自己想到的一点点罗列出来。比如下面这段代码（如果你不想仔细阅读，可以直接跳到后面）：    public void executeTask() {        ObjectMapper mapper = new ObjectMapper();        CloseableHttpClient client = HttpClients.createDefault();        List chapters = this.chapterService.getUntranslatedChapters();        for (Chapter chapter : chapters) {            // Send Chapter            SendChapterRequest sendChapterRequest = new SendChapterRequest();            sendChapterRequest.setTitle(chapter.getTitle());            sendChapterRequest.setContent(chapter.getContent());            HttpPost sendChapterPost = new HttpPost(sendChapterUrl);            CloseableHttpResponse sendChapterHttpResponse = null;            String chapterId = null;            try {                String sendChapterRequestText = mapper.writeValueAsString(sendChapterRequest);                sendChapterPost.setEntity(new StringEntity(sendChapterRequestText));                sendChapterHttpResponse = client.execute(sendChapterPost);                HttpEntity sendChapterEntity = sendChapterPost.getEntity();                SendChapterResponse sendChapterResponse = mapper.readValue(sendChapterEntity.getContent(), SendChapterResponse.class);                chapterId = sendChapterResponse.getChapterId();            } catch (IOException e) {                throw new RuntimeException(e);            } finally {                try {                    if (sendChapterHttpResponse != null) {                        sendChapterHttpResponse.close();                    }                } catch (IOException e) {                    // ignore                }            }            // Translate Chapter            HttpPost translateChapterPost = new HttpPost(translateChapterUrl);            CloseableHttpResponse translateChapterHttpResponse = null;            try {                TranslateChapterRequest translateChapterRequest = new TranslateChapterRequest();                translateChapterRequest.setChapterId(chapterId);                String translateChapterRequestText = mapper.writeValueAsString(translateChapterRequest);                translateChapterPost.setEntity(new StringEntity(translateChapterRequestText));                translateChapterHttpResponse = client.execute(translateChapterPost);                HttpEntity translateChapterEntity = translateChapterHttpResponse.getEntity();                TranslateChapterResponse translateChapterResponse = mapper.readValue(translateChapterEntity.getContent(), TranslateChapterResponse.class);                if (!translateChapterResponse.isSuccess()) {                    logger.warn("Fail to start translate: {}", chapterId);                }            } catch (IOException e) {                throw new RuntimeException(e);            } finally {                if (translateChapterHttpResponse != null) {                    try {                        translateChapterHttpResponse.close();                    } catch (IOException e) {                        // ignore                    }                }            }        }这段代码的逻辑是，把没有翻译过的章节发到翻译引擎，然后，启动翻译过程。在这里翻译引擎是另外一个服务，需要通过HTTP的形式向它发送请求。相对而言，这段代码还算直白，当你知道了我上面所说的逻辑，你是很容易看懂这段代码的。这段代码之所以很长，主要原因就是把前面所说的逻辑全部平铺直叙地摆在那里了，这里既有业务处理的逻辑，比如，把章节发送给翻译引擎，然后，启动翻译过程；又有处理的细节，比如，把对象转成JSON，然后，通过 HTTP客户端发送出去。从这段代码中，我们可以看到平铺直叙的代码存在的两个典型问题：1.  把多个业务处理流程放在一个函数里实现；        2.  把不同层面的细节放到一个函数里实现。        这里发送章节和启动翻译是两个过程，显然，这是可以放到两个不同的函数中去实现的，所以，我们只要做一下提取函数，就可以把这个看似庞大的函数拆开，而拆出来的几个函数规模都会小很多，像下面这样：    public void executeTask() {        ObjectMapper mapper = new ObjectMapper();        CloseableHttpClient client = HttpClients.createDefault();        List chapters = this.chapterService.getUntranslatedChapters();        for (Chapter chapter : chapters) {            String chapterId = sendChapter(mapper, client, chapter);            translateChapter(mapper, client, chapterId);        }    }拆出来的部分，实际上就是把对象打包发送的过程，我们以发送章节为例，先来看拆出来的发送章节部分：    private String sendChapter(final ObjectMapper mapper,                               final CloseableHttpClient client,                               final Chapter chapter) {        SendChapterRequest request = asSendChapterRequest(chapter);        CloseableHttpResponse response = null;        String chapterId = null;        try {            HttpPost post = sendChapterRequest(mapper, request);            response = client.execute(post);            chapterId = asChapterId(mapper, post);        } catch (IOException e) {            throw new RuntimeException(e);        } finally {            try {                if (response != null) {                    response.close();                }            } catch (IOException e) {                // ignore            }        }        return chapterId;    }    private HttpPost sendChapterRequest(final ObjectMapper mapper, final SendChapterRequest sendChapterRequest) throws JsonProcessingException, UnsupportedEncodingException {        HttpPost post = new HttpPost(sendChapterUrl);        String requestText = mapper.writeValueAsString(sendChapterRequest);        post.setEntity(new StringEntity(requestText));        return post;    }    private String asChapterId(final ObjectMapper mapper, final HttpPost sendChapterPost) throws IOException {        String chapterId;        HttpEntity entity = sendChapterPost.getEntity();        SendChapterResponse response = mapper.readValue(entity.getContent(), SendChapterResponse.class);        chapterId = response.getChapterId();        return chapterId;    }    private SendChapterRequest asSendChapterRequest(final Chapter chapter) {        SendChapterRequest request = new SendChapterRequest();        request.setTitle(chapter.getTitle());        request.setContent(chapter.getContent());        return request当然，这个代码还算不上已经处理得很整洁了，但至少同之前相比，已经简洁了一些。我们只用了最简单的**提取函数**这个重构手法，就把一个大函数拆分成了若干的小函数。顺便说一下，**长函数往往还隐含着一个命名问题**。如果你看修改后的sendChapter，其中的变量命名明显比之前要短，理解的成本也相应地会降低。因为变量都是在这个短小的上下文里，也就不会产生那么多的命名冲突，变量名当然就可以写短一些。平铺直叙的代码，一个关键点就是没有把不同的东西分解出来。如果我们用设计的眼光衡量这段代码，这就是"分离关注点"没有做好，把不同层面的东西混在了一起，既有不同业务混在一起，也有不同层次的处理混在了一起。我在《软件设计之美》专栏中，也曾说过，**关注点越多越好，粒度越小越好。**1.  **一次加一点**        有时，一段代码一开始的时候并不长，就像下面这段代码，它根据返回的错误进行相应地错误处理：    if (code == 400 || code == 401) {      // 做一些错误处理    }然后，新的需求来了，增加了新的错误码，它就变成了这个样子：    if (code == 400 || code == 401 || code == 402) {      // 做一些错误处理    }你知道，一个有生命力的项目经常会延续很长时间，于是，这段代码有很多次被修改的机会，日积月累，它就成了让人不忍直视的代码，比如：    if (code == 400 || code == 401 || code == 402 || ...      || code == 500 || ...      || ...      || code == 10000 || ...) {      // 做一些错误处理    }后来人看到这段代码就想骂人了。当他从版本控制的历史中找到这些代码的作者，去询问这些处理的来龙去脉时，每个人其实都很委屈，他们当时也没做太多，只是加了一个判断条件而已。**任何代码都经不起这种无意识的累积，每个人都没做错，但最终的结果很糟糕。**对抗这种逐渐糟糕腐坏的代码，我们需要知道"童子军军规"：>  > 让营地比你来时更干净。> > >>>  > ------ 童子军军规> > >Robert Martin把它借鉴到了编程领域，简言之，我们应该看看自己对于代码的改动是不是让原有的代码变得更糟糕了，如果是，那就改进它。但这一切的前提是，你要能看出自己的代码是不是让原有的代码变得糟糕了，所以，学习代码的坏味道还是很有必要的。至此，我们看到了代码变长的几种常见原因：1.  以性能为由；        2.  平铺直叙；        3.  一次加一点。        你会发现，代码变长根本是一个无意识的问题，写代码的人没有觉得自己把代码破坏了。但只要你认识到长函数是一个坏味道，后面的许多问题就自然而然地会被发掘出来，至于解决方案，你已经看到了，大部分情况下，就是拆分成各种小函数。总结时刻今天我们讲了程序员最深恶痛绝的坏味道：长函数。没有人愿意去阅读长函数，但许多人又会不经意间写出长函数。毫无疑问，长函数是一个坏味道。对于团队而言，一个关键点是要定义出长函数的标准。不过，过于宽泛的标准是没有意义的，想要有效地控制函数规模，几十行的函数已经是标准的上限了，这个标准越低越好。我们还分析了长函数产生的原因：1.  有人以性能为借口；        2.  有人把代码平铺直叙地摊在那里；        3.  有人只是每次增加了一点点。        其中，平铺直叙是把函数写长最常见的原因。之所以会把代码平摊在那里，一方面是把多个业务写到了一起，另一方面是把不同层次的代码写到了一起。究其根因，那是"分离关注点"没有做好。每次增加一点点，是另外一个让代码变长的原因，应对它的主要办法就是要坚守"童子军军规"，但其背后更深层次的支撑就是要对坏味道有着深刻的认识。如果今天的内容你只能记住一件事，那请记住：**把函数写短，越短越好**。![](Images/abea9ad82a18f81978b42d362365defc.png)savepage-src="https://static001.geekbang.org/resource/image/17/bf/17ef4030fb39dc02400f8e03e2547cbf.jpg"}思考题你在实际的工作中遇到过长函数吗？讲讲你和长函数斗争的故事，欢迎在留言区写下你的经历。如果你身边有人正在为"长函数"苦恼，也欢迎你把这节课分享给他。感谢阅读，我们下一讲再见！参考资料：slate-object="mark"}一个好的项目自动化应该是什么样子的？语言的模型：如何打破单一语言局限，让设计更好地落地？分离关注点：软件设计至关重要的第一步