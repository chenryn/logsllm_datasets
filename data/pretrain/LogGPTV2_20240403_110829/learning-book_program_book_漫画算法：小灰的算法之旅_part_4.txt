素，元素数量超过了数组的最大长度，数组岂不是要“撑爆”了？
问得很好，这就是接下来要讲的情况
超范围插入。
超范围插入，又是什么意思呢？
---
## Page 59
假如现在有一个长度为6的数组，已经装满了元素，这时还想插入一个
新元素。
3
6
2
5
4
2
3
5
10
这就涉及数组的扩容
了。可是数组的长度在创建时就已经确定了，无
法像孙悟空的金箍棒那样随意变长或变短。这该如何是好呢？
此时可以创建一个新数组，长度是旧数组的2倍，再把旧数组中的元素
统统复制过去，这样就实现了数组的扩容。
316254
0
2
3
5
y
5
6
91011
1
2
3
5
1011
如此一来，我们的插入元素方法也需要改写了，改写后的代码如下：
1.private int[]array;
2.private int size;
3.
4.public MyArray(int capacity){
5.
this.array = new int[capacity];
6.
size = 0;
---
## Page 60
7.}
8.
9./**
10.
*数组插入元素
11.
★
@param element
插入的元素
12.
*@param index
插入的位置
13.
*/
14.
public void insert(int element, int index) throws Exception
15.
//判断访问下标是否超出范围
16.
if(indexsize){
17.
thrownewIndexOutofBoundsException（"超出数组实际元
素范围！");
18.
19.
//如果实际元素达到数组容量上限，则对数组进行扩容
20.
if(size >= array.length){
21.
resize();
22.
23.
//从右向左循环，将元素逐个向右挪1位
24.
for(int i=size-1; i>=index; i--){
25.
array[i+1] = array[i];
26.
27.
//腾出的位置放入新元素
28.
array[index]= element;
29.
size++;
---
## Page 61
30.}
31.
32./**
33.
*
数组扩容
34.
*/
35.
public void resize(){
36.
37.
//从旧数组复制到新数组
38.
System.arraycopy(array,0，arrayNew,0，array.length);
39.
array = arrayNew;
40. }
41.
42.
/ **
43.
*
输出数组
44.
*/
45.
public void output(){
46.
for(int i=θ;i=size){
---
## Page 63
8.
thrownewIndexOutofBoundsException（"超出数组实际元
素范围！"）；
9.
10.
int deletedElement = array[index];
11.
//从左向右循环，将元素逐个向左挪1位
12.
for(int i=index; iNULL
Head
链表（linkedlist）是一种在物理上非连续、非顺序的数据结构，由若干
节点（node）所组成。
单向链表的每一个节点又包含两部分，一部分是存放数据的变量data，
另一部分是指向下一个节点的指针next。
1. private static class Node {
2.
int data;
Node next;
4.}
链表的第1个节点被称为头节点，最后1个节点被称为尾节点，尾节点的
next指针指向空。
与数组按照下标来随机寻找元素不同，对于链表的其中一个节点A，我
们只能根据节点A的next指针来找到该节点的下一个节点B，再根据节点
B的next指针找到下一个节点C....
这正如地下党的联络方式，一级一级，单线传递。
---
## Page 68
那么，通过链表的一个节点，如
何能快速找到它的前一个节点呢？
要想让每个节点都能回溯到它的前置
节点，我们可以使用双向链表。
什么是双向链表？
双向链表比单向链表稍微复杂一些，它的每
一个节点除了拥有data和
next指针，还拥有指向前置节点的prev指针。
NULL←
Pe dad
NULL
接下来我们看一看链表的存储方式。
如果说数组在内存中的存储方式是顺序存储，那么链表在内存中的存储
方式则是随机存储。
什么叫随机存储呢？
上一节我们讲解了数组的内存分配方式，数组在内存中占用了连续完整
的存储空间。而链表则采用了见缝插针的方式，链表的每一个节点分布
在内存的不同位置，依靠next指针关联起来。这样可以灵活有效地利用
---
## Page 69
零散的碎片空间。
让我们看一看下面两张图，对比一下数组和链表在内存中分配方式的不
同。
3111215
5:4
7:2
数组的内存分配方式
3
1
2
5
1
7→2
链表的内存分配方式
图中的箭头代表链表节点的next指针。
那么，我们怎样来使用一个链表
---
## Page 70
呢？
上一节刚刚讲过数组的增、删、改、
查，这一次来看看链表的相关操作。
2.2.2
链表的基本操作
1.查找节点
在查找元素时，链表不像数组那样可以通过下标快速进行定位，只能从
头节点开始向后一个一个节点逐一查找。
例如给出一个链表，需要查找从头节点开始的第3个节点。
>NULL
Head
第1步，将查找的指针定位到头节点。
>NULL
Head
第2步，根据头节点的next指针，定位到第2个节点。
lata
loto
>NULL
Head
---
## Page 71
第3步，根据第2个节点的next指针，定位到第3个节点，查找完毕。
lat
>NULL
Head
小灰，你说说查找链表节点的时间复
杂度是多少？
链表中的数据只能按顺序进行访
问，最坏的时间复杂度是0(m)。
2.更新节点
如果不考虑查找节点的过程，链表的更新过程会像数组那样简单，直接
把旧数据替换成新数据即可。
NULL
Head
>NULL
Head
---
## Page 72
3.插入节点
与数组类似，链表插入节点时，同样分为3种情况。
·尾部插入
·头部插入
·中间插入
尾部插入，是最简单的情况，把最后一个节点的next指针指向新插入的
节点即可。
>NULL
Head
NULL
Head
头部插入，可以分成两个步骤。
第1步，把新节点的next指针指向原先的头节点。
第2步，把新节点变为链表的头节点。
3
NULI
3N
NUL
NUL
Head
中间插入，同样分为两个步骤。
第1步，新节点的next指针，指向插入位置的节点。
第2步，插入位置前置节点的next指针，指向新节点。
---
## Page 73
NUL
NULL
只要内存空间允许，能够插入链表的元素是无穷无尽的，不需要像数组
那样考虑扩容的问题。
4.删除元素
链表的删除操作同样分为3种情况。
·尾部删除
·头部删除
·中间删除
尾部删除，是最简单的情况，把倒数第2个节点的next指针指向空即
可。
dafa
>NULL
Head
>NULL
Head
头部删除，也很简单，把链表的头节点设为原先头节点的next指针即
---
## Page 74
>NULL
Head
>NULL
Head
中间删除，同样很简单，把要删除节点的前置节点的next指针，指向要
删除元素的下一个节点即可。
>NULL
Head
lato
>NULL
Head
这里需要注意的是，许多高级语言，如Java，拥有自动化的垃圾回收机
制，所以我们不用刻意去释放被删除的节点，只要没有外部引用指向它
们，被删除的节点会被自动回收。