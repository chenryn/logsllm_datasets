表II. (1)NVD数据库中的CVE总数[55](2)收集到的bug数量.
对于开源浏览器，我们从供应商的bug跟踪器中收集了额外的的漏洞信息[48][43]. 对于这些浏览器, 我们忽略了机密漏洞和与bug跟踪器问题无关的漏洞。
对于闭源浏览器，我们使用NVD[55]作为CVE数据的唯一来源. (3)和(4)是用于收集被利用漏洞数据的来源.
`错误和代码库大小`:
图3显示了所有浏览器中，特别是从2010年之后，安全漏洞的急剧增加。我们认为这种漏洞的增加与不断增长的浏览器代码库有关，因为新功能不断添加。此外，2010年之后漏洞挖掘技术的进步发挥了相当大的作用，我们在§VI-C中强调了这一点。
图3. 左y轴: 安全漏洞数量; 右y轴: 两个开源浏览器(Firefox和Chromium)的LoC. LoC是基于每年的首个主要版本更新. 注: LoC
= Lines of Code
`动态攻击向量`:
浏览器的庞大规模和不断变化的特性使得攻击向量不断变化。对于开源浏览器Firefox和Chromium，我们将bug映射到它们各自的主机组件和bug类，如图4所示。对于这两种浏览器，我们使用开发人员分配的特质将bug映射到它们的主机浏览器组件，并使用关键字匹配漏洞描述以对其进行分类。
渲染器错误在Firefox和Chromium中都占主导地位，因为渲染器是浏览器的核心。自2016年以来，Chromium的URL欺骗漏洞的增加凸显了在以前未探索的区域中查找漏洞的容易程度。一般来说，内存错误，特别是UAF错误，仍然是两种浏览器最大的共同点。
另一个大体上的发现是这两个浏览器多年来在两个方面上的漏洞数量不同。例如，对于bug组件，Chromium最近有更多的DOM和HTML漏洞，但Firefox的DOM和HTML漏洞数量正在减少。对于bug类别，2019年Chromium中的大多数bug被归类为UAF、OOB和URL欺骗漏洞，但Firefox多年来对bug分布的描述相对统一。因此，这种差异不仅直观表现出不断变化的攻击向量，还表现了不同浏览器的安全漏洞分类策略的变化。
图4. 将bug映射到Firefox和Chromium中的主机浏览器组件和漏洞类. 该图突出了浏览器攻击面逐年变化的性质. 每个图中的数字都是按最小-最大比例缩放的.
浏览器针对bug的努力也可以在图中体现。Chromium的站点隔离[39]、[186]作为对UXSS漏洞的应对措施，使得2017年实施站点隔离后上述漏洞明显减少（图4b）。某些漏洞类型仍然是bug的主要来源，例如DOM和HTML组件，我们将在§III-C中详细说明。
`内存安全的语言`:
内存安全漏洞在浏览器中至关重要且占主导地位。例如，Chromium将超过70%的高严重性漏洞标记为内存安全问题，其中一半是UAF错误[50]。我们在图5中展示了浏览器中内存安全漏洞的比率。如图所示，尽管有应对措施[212][59]，但过去十年内存安全漏洞仍然占主导地位。最近，有人努力使用内存安全语言（例如
Rust）重写浏览器以减少内存安全漏洞。例如，Mozilla正在一个名为Oxidation[57]的项目中用Rust重写Firefox的部分内容。直到2020年，Oxidation项目已经用Rust(编写的等效模块)替换了12%的Firefox组件。五个被替换的子组件属于渲染器的媒体解析组件。我们也在图5中画出了渲染器的媒体解析组件中的内存安全漏洞数量。很明显，自2015年
Oxidation项目开始以来，Firefox中的内存安全漏洞数量呈现出小幅但稳定的下降，其中在渲染器的媒体组件中的内存安全漏洞明显减少。尽管浏览器供应商多次尝试解决内存安全问题，但都没有像Firefox的Oxidation那样产生显著效果。
图5. Firefox和其他浏览器中内存安全漏洞与其他漏洞的数量。RM-Mem是Firefox渲染器中媒体解析组件中内存安全漏洞的数量，描述了从2015年开始用Rust部分重写后的下降趋势。
    Lession 1: 使用内存安全语言可以有效减少内存安全漏洞。
    如图5所示，在Firefox中使用Rust有效地减少了内存安全漏洞。尽管需要付出很多努力，但它是一种基本的方法，也是最有可能消除内存安全漏洞的方法。我们建议其他浏览器供应商遵循此最佳方法，并逐步将其浏览器转换为内存安全的语言。
`漏洞赏金计划`:
谷歌等主流浏览器厂商为那些帮助他们修复漏洞的安全错误报告提供奖励[116]。在大多数情况下，这些赏金考虑了多种因素，例如漏洞类型、可利用性以及报告者所做的额外有意义的工作。更高的赏金更能激励研究员和白帽去发掘漏洞。我们在图6中将每年的平均支付金额与Chromium中每年的漏洞数量相关联。我们特别展示了内存安全、UXSS和URL欺骗漏洞，因为它们与支付金额的关联模式很有意思。
图6. 平均支付金额(上图)与Chromium中每年的漏洞数量(下图)之间的相关性. 红色区域是所有类别的平均赏金金额.
超过红色区域的漏洞类别表示比平均水平有更高的赏金.
支付金额会影响为各个类别发现的漏洞数量(图6)。平均赏金金额高于总体平均金额的错误类别（例如，2014-2016年的UXSS和2017-2020年的Mem错误）的数量似乎在这些年有所增加。然而，这种相关性也有例外：某个类别的漏洞数量的增加不会带来更高的赏金金额。该图进一步强调了研究人员在挖洞时除了寻求更高回报外的其他重要因素，例如
1) 寻求探索未知攻击向量(URL欺骗)的好处; 2) 瞄准具有更高影响的漏洞(UXSS在2016的增多);
3）避开具有有效应对措施的漏洞类别(2017年发布的站点隔离和2018年减少的UXSS错误)。
    Lession 2: 更高的赏金会激发更多的漏洞报告。
    浏览器厂商尝试增加漏洞赏金计划的覆盖面和预算，这收获了更多的漏洞报告。因此，增加漏洞赏金支出可以有效地吸引安全研究人员的兴趣并减少攻击面。
`漏洞严重性评级的分歧`: 通用漏洞评分系统(CVSS)[46]是作为漏洞严重性评估的免费和开源标准而开发的。 National Vulnerability
Database[55]使用CVSS标准为每个发布的CVE编号提供漏洞严重性基础评分。同样，Firefox和Chromium在其bug跟踪器[43][48]和安全建议[53]中提供了对漏洞严重性的评估，使用的是他们自己的漏洞评级系统。表III比较了NVD的CVSS-V3与Firefox和Chromium的漏洞严重性评估。本研究的目的是衡量使用NVD的CVSS-V3分数作为浏览器中漏洞严重程度的统一度量的有效性。
表III. NVD分配的CVSS-V3分数与供应商的漏洞严重程度分数之间的比较. 错误等级为: 低、中、高和严重.
表中省略了年久而无法获得CVSS-V3分数的bug. 最后一列是用于此比较的漏洞总数, 以及分配了不同漏洞等级的漏洞数.
该表在两个维度上强调了漏洞评级的差异: 1) CVSS分数与供应商分数中分类为低的漏洞数量(加粗); 2) 供应商之间评级为严重的漏洞(下划线).
在表中，我们注意到评级系统（供应商与NVD）之间存在差异。NVD对Firefox一半以上的漏洞进行了不同严重程度的评分，而它在Chromium的bug评分上也仅有58%与Chromium一致。虽然我们预计两个评级系统之间不会完全一致，但评分的巨大差距令人惊讶。这些差异也发生在供应商之间。查看这两种浏览器中严重漏洞的数量，我们可以看到，与Chromium相比，Firefox将其bug评为"严重"的百分比要高得多。我们的分析结果，与之前对使用CVSS分数作为bug分类和优先级的指标的担忧相一致[132][205][156]。
`浏览器漏洞`:
被实际攻击中的浏览器漏洞值得更多关注，因为从攻击者的角度来看，它们表明了已确定的攻击向量。为了研究此类漏洞，我们从仅获取高度可利用漏洞的可靠来源收集信息。对于在野使用的漏洞，我们参考Google定期更新的Project
Zero报告，该报告跟踪自2014年以来所有公开的0day漏洞利用案例[58]。我们还收集了Pwn2Own[40]中利用的漏洞，这是一场由Zero Day
Initiative[61]赞助的real-world黑客竞赛。我们根据漏洞类别和目标浏览器组件，在图7中突出显示过去十年中最常被利用的漏洞。
图7. 被利用的浏览器组件和错误类别的趋势. 数据包括来自所有浏览器的错误. 线上是累积的数量.
JavaScript引擎和UAF错误分别主导了被利用的bug组件和漏洞类型。
如图7所示，对于浏览器组件，DOM漏洞占主导地位，直到2017年被JS引擎漏洞取代。尽管如此，DOM漏洞在今天仍然存在，并且即使在添加了许多缓解措施后仍显示出缓慢而稳定的增长。对于漏洞类型，尽管采取了所有应对措施，实际利用中UAF漏洞等内存安全bug仍然比其他漏洞类型更多。一个有趣的发现是关于出现的漏洞类别和组件的对应趋势。对于图中的大多数线条，我们看到早些年的增长相当陡峭，但之后增长放缓（JavaScript引擎漏洞除外）。这种趋势直观呈现了:
攻击者为寻找和探索新的攻击技术而付出的努力，以及供应商为消除和应对新漏洞而采取的反应性对策。
`本节中包含的漏洞类型`: 基于图7所示的bug趋势，在本节中，我们主要讨论bug的趋势类型，即:  
1\. 解析器bug (§III-B)  
2\. DOM bug (§III-C)  
3\. JavaScript引擎漏洞 (§III-D)  
4\. SOP绕过和UXSS漏洞 (§III-E)
### B. 解析器漏洞
解析器经常遭受内存损坏问题；浏览器中的解析器也不例外。在Web浏览器中，大多数解析器漏洞都出现在媒体解析器或网络协议解析器中。如图4a所示，渲染器（媒体）占据很大份额。这些漏洞更容易在渲染器进程中被利用，因为它们可用于破坏
JS 对象并创建更强大的漏洞利用原语。
`当前状态`:
在强化堆分配器（§IV-B）之后，这种利用变得更加困难或不可行，主要是因为堆上JS对象的划分。不过，像ClusterFuzz[111]这样的大规模模糊器也发现了许多解析器漏洞。浏览器供应商正在研究沙盒化网络代码，并使用Rust[57]等内存安全语言重写浏览器代码。结果，这些漏洞变少且难以利用。尽管如此，在解析数据时仍然存在多个第三方库的依赖关系，因此需要对安全更新进行严格控制。
### C. DOM漏洞
DOM漏洞是攻击者的热门目标；根据图7，2014年大多数被利用的漏洞是DOM漏洞。由于其中大多数是UAF漏洞，因此已部署了应对措施以降低它们的可利用性，例如堆隔离与延迟释放(§IV-B)。
`当前状态`:
虽然fuzzer还在继续识别新的DOM漏洞[111]、[129]、[227]，如图7所示，但由于利用DOM漏洞的难度增加，最近已知的在野全链漏洞利用倾向于使用其他组件中的漏洞。
    Lession 3: UAF应对措施可有效减少DOM漏洞利用。
    由于DOM错误主要依赖于UAF问题，因此它们大多已通过UAF应对措施得到处理。依赖指针类型混淆的常规利用技术已经变得不可行，因为堆按对象类型隔离，并且没有公开的替代技术。 因此，利用DOM漏洞不再是破坏渲染器的首选方法。
### D. JS引擎错误
在最近的浏览器漏洞利用中，JS引擎漏洞是浏览器漏洞利用最流行的目标之一，尤其是优化相关的漏洞。至少34%的被利用漏洞（图7）使用JS引擎漏洞来破坏渲染器进程，这通常是全链浏览器漏洞利用的第一步。JS引擎漏洞可用于生成强大的漏洞利用原语，例如addrof（泄露任何JS对象的地址）和fakeobj（将任意地址作为对象访问）。
如§II-B中所述，JS引擎中的JIT编译器使用推测优化(speculative
optimization)。这些优化机制中的漏洞比传统的内存安全漏洞（例如释放后重用或缓冲区溢出）更为严重，因为它们难以处理，但为攻击者提供了强大的利用原语。从高层次上看，JS引擎的bug主要可以分为四类：
\- JIT分析漏洞：JIT编译器的分析过程或模型中的漏洞。此类漏洞具有最高的可利用性和影响。 \- JIT代码变异/生成漏洞：操作JIT
graphs或生成代码过程中的漏洞。 \- 非JIT副作用漏洞(Non-JIT side-effect
bugs)：JavaScript内置函数中的副作用漏洞，主要与快速路径(fast-path)相关。 \-非JIT传统内存损坏漏洞：不属于上述类别的其他内存损坏漏洞
我们检查了图7中的45个被利用的漏洞；有13个JIT分析漏洞、9个非JIT副作用漏洞和11个传统内存损坏漏洞，但没有JIT代码突变/生成漏洞。我们怀疑这是因为此漏洞很难利用。JIT编译器中的大多数漏洞都是逻辑漏洞。由于它是一个编译器基础设施，逻辑漏洞可以被放大为JIT编译代码中的内存安全漏洞。因此，很难对JIT错误做出一般性的缓解。在这里，我们介绍了三大类防御：`原语消除`、`覆盖保护`和`基于jit的代码重用缓解`。
  * `原语消除(Primitive elimination)`: 原语消除技术旨在防止攻击者 1.将漏洞转换为利用原语; 2.将利用原语升级为更强大的原语(例如, 为了构造可靠和稳定的读/写原语, 攻击者可以利用addrof和fakeobj原语来伪造一个带有完全受控的后备存储指针的ArrayBuffer对象, 这就是原语的升级)。
a. `对象形状认证(Object shape authentication)`:
这种类型的应对旨在防止攻击者使用fakeobj原语伪造有效对象。例如，在JavaScriptCore中，StructureID
Randomization使用7个随机熵位对StructureID进行编码，这使得攻击者很难猜测[121]、[204]。由于StructureID表示JS对象的类型和形状，猜测StructureID错误会导致形状无效，访问它最终会导致进程崩溃[221]。
b. `地址空间隔离(Address space isolation)`: 此类应对措施隔离不同对象，以防止对象被伪造或覆盖。
GigaCage[83]是一个4GB的虚拟内存区域，将不同的对象分成不同的堆（或HeapKinds）。关键思想是防止跨不同堆的内存访问，并使用堆基地址的相对偏移量来定位GigaCaged对象，而不是使用绝对地址。因此，即使指针已损坏，它也不能指向其原始堆之外的任何内容。PACCage[121]用于保护TypedArray的后备存储缓冲区指针，并在GigaCage之上使用指针验证码(PAC)进一步增强安全性。Chrome
V8 Heap Sandbox
[119]是实验性的，其目标类似于GigaCage，但它尝试使用单独的指针表来保护外部指针，之后攻击者无法为外部指针创建任意值。
  * `覆盖保护(Overwrite protection)`: 覆盖保护是防止攻击者引入任意可执行代码的标准保护机制，可以看作是浏览器漏洞利用上下文中的最后一道防线。它们主要包括四种机制: `W ⊕ X` [106]、`强化JIT映射` [139]、`快速权限切换`[128]、[139]和`进程外JIT`[164]。
a. `W ⊕ X`: W ⊕ X
是一个重要的安全原则，它强制内存要么可执行但不可写，要么可写但不可执行。这种应对比传统的shellcode注入攻击更出色，并为许多其他保护技术提供了基础[62]、[232]。令人惊讶的是，由于性能原因，JIT代码页通常不受这种基本缓解的影响，并被映射为rwx
[106]。
b. `仅执行内存(Execute only memory)`: ARMv8设备上的iOS
10获得了对仅执行内存(XOM)[139]的硬件支持，使JIT编译的代码能够将秘密数据作为即时值包含在内。Safari利用XOM向攻击者隐藏可写可执行映射的地址，方法是引入一个仅执行的jit_memcpy函数，该函数内部具有JIT映射的基地址。这使得任意读/写不足以覆盖JIT代码页，并迫使攻击者采取替代路径，例如劫持控制流来调用jit_memcpy。
c. `快速权限切换: APRR & MPK`: 引入对快速权限切换的硬件支持，以减少使用mprotect()切换页面权限的开销。自ARMv8设备上的iOS
11以来，APRR[139]被部署以通过将页面权限(r,w,x)映射到指示线程的实际页面权限的八个专用寄存器来启用每线程权限。类似地，英特尔MPK[128]每页添加一个单独的4位整数，以实施两个额外的保护：禁用访问和禁用写入。因此，JIT区域将始终为r-x，并且仅允许来自专用数据复制线程的写入操作，通过调用解锁函数将权限更改为
rw- 仅适用于目标线程。
d. `进程外JIT`: 在Windows上，Arbitrary Code Guard
(ACG)等缓解措施可确保进程只能将签名代码映射到其内存中。但是，浏览器出于性能目的大量使用JIT编译器，这会在内容进程中生成未签名的本机代码。引入了进程外JIT[164]以启用带有JIT编译器的ACG。因此，JIT功能被转移到一个单独的进程中，该进程在它自己的沙箱中运行，它负责编译JS代码并将其映射到进程中。因此，内容进程将永远不被允许映射或修改其自己的JIT代码页。
  * `基于JIT的代码重用缓解措施(JIT-based code-reuse mitigations)`: JIT Spray [158]是一种将大量攻击者控制的JIT代码（标记为可执行文件）注入内存中可预测的地址以绕过ASLR/DEP的技术，类似于Heap spray [95]。为了缓解JIT Spray，浏览器对JIT代码设置了大小限制，并切换到具有高熵ASLR的64位平台，这使得JIT spray不可行。不过，如果攻击者知道它们的地址，则可以利用JIT code gadgets。这种攻击称为基于JIT的代码重用攻击(JCRA)。在这里，我们简要总结了此类攻击的应对措施。
a. `受控字节消除(Controlled bytes elimination)`:
JCRA有一个基本假设，即通过控制立即操作数和特定操作码，攻击者可以控制在堆内存中生成的JITed代码。因此，应对措施是要消除攻击者控制字节的可预测性，例如混淆大常量[71]、[144]、置换立即操作数和局部变量的寄存器分配[144]、[222]以及在函数的调用帧中混杂指令[144]、[222]。