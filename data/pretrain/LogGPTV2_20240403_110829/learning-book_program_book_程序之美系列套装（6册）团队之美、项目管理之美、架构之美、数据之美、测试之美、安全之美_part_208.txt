本操作。将功能函数名称之后每个“调用"的左括号移到功能函数名
称的左边，然后去除所有的逗号。例如，f（xy，z）将写成
（fxyz）。对于前一个例子，<（*（x,y），z）将写成（<（*xy）
Z）。
将这三个规则组合在一起，如果将用Python编写的代码while
x*y<z:q（）用Lisp写出来，将变成（while（<（*xy）z）
°((b)
这就是正确的EmacsLisp表达式，它和Python的表达式的含义是一样的。
当然Lisp的语法还有很多，不过这是它的本质。Lisp中的主要功能术语（诸
如<和*）和控制结构（诸如while），在上面的例子中都有体现。
下面定义的是一组交互式Emacs命令，用来统计当前选择文本的字
数。如果我告诉你"\<"在Emacs中是用来匹配单词开始的正则表达
式，你或许能够自己读懂这段代码的含义：
(defun count-region-words (start end)
1175
---
## Page 1177
"Count the words in the selected region of text."
(interactive"r")
(save-excursion
（let（（count 0))
(goto-char start)
(while (re-search-forward"\\<"end t)
(setq count (+count 1))
(forward-char 1) )
(message"Region hased words."count) )))
有一种观点认为Lisp为人类读者在阅读代码、理解代码方面提供的
可视化线索太少，以致大家倾向于放弃这种乏味的语法风格，选择
那些对基本操作、函数调用、程序结构控制予以更明显区别的语法
风格。不过，Lisp中有一些十分重要的功能（我们稍后将会谈及）
是依赖于这种一致性的：任何修改这种模式的努力都并不顺利。根
据我的经验，许多Lisp程序员都感觉为让该语言能够如此强大、灵
活，付出这样的代价也是合理的。
在Emacs中，命令就是程序员指定的负责与用户交互的EmacsLisp功
能函数（再加上定义之前的一些简要注释）。命令的名称，也就是
用户在Meta+x之后输入的名称就是xLisp功能函数的名称。keymaps
用来绑定执行该命令按键序列、鼠标点击操作以及菜单项。核心
Emacs代码将会在keymaps中查询与用户按键和鼠标操作相一致的定
义，然后将控制权分发给相应的命令。和Emacs的视图层所提供的
自动显示管理机制类似，keymap分发操作意味着Lisp代码几乎不用
负责对一个事件循环中的事件进行处理，这对于很多用户界面的并
发人员而言大大减轻了工作负担。
Emacs及其Lisp语言有儿个关键的特性：
EmacsLisp的机制是轻量级的。小型的自定义和扩展是很容易的：
在你用户主目录下的.emacs文件中放上一行表达式，那么Emacs在启
动时就会自动载入，可以载入原有的Lisp程序包，设置影响Emacs行
1176
---
## Page 1178
为的变量，重新定义键盘序列等。你可以通过几行代码写出一个有
用的命令，同时添加其在线文档。（要完成一个有用的Emacs命令
的定义，请参见前面的"Lisp的五分钟教程”。）
EmacsLisp是交互式的。你可以在缓冲区中输入函数定义或表达
式，Emacs将立即执行它。对这些定义进行修改，那么Emacs会马上
重新执行它；你无需重新编译或重新启动Emacs。Emacs实际上就是
EmacsLisp程序的一种有效的集成开发环境。
你自己写的EmacsLisp程序将是一等公民。Emacs中每个非凡的编
辑功能都是用Lisp语言开发的，因此在你自己的Lisp程序代码中，
同样可以使用到Emacs本身的基本功能函数和程序库。缓冲区、窗
口和其他与编辑相关的对象，在Lisp代码中就是一个平常的值。它
们可以作为功能函数的参数、返回值，还可以将它们存储到数据结
构等。尽管Emacs的模型层和视图层组件都是硬编码的，Emacs称在
控制器层没有为自已提供任何特权。
EmacsLisp是一种很完善的编程语言，很适合编写大型的程序（包
含成千上万行代码的程序）。
EmacsLisp是很安全的。有很多人揭示了许多将导致错误产生的
Bug成灾的Lisp代码，但它们并不影响Emacs。Bug引发的问题可以
通过其他途径解决。例如，缓冲区中内建的日志机制可以让你撤销
预期外的操作。这些Lisp开发给人留下更舒适、更积极的体验。
·EmacsLisp代码很容易生成文档。在功能函数的定义中可以包含一
个docstring（文档字符串），其中的文字用来说明该功能函数的意
图和使用方法。Emacs提供的所有功能函数都有docstring，意味着对
于指定设施的帮助不会比命令少。当Emacs显示一个功能函数的
docstring时，还将提供一个指向功能函数源代码的超链接，使得
Lisp代码更加容易阅读。（显然，docstring并不适用于大型的Lisp
包，因此这些通常将放在更传统的结构化手册中。）
EmacsLisp不是一个模块化系统。取而代之的是通过内建的命名规
范来实现在同一个Emacs会话中载入不相关的包时避免相互之间的
干扰，因此用户可以相互共用EmacsLisp代码包，不需要Emacs并发
人员进行协调与确认。这也意味着在一个包中的所有功能函数对于
其他包而言都是可见的。如果一个功能函数有足够的价值，就会有
很多包使用它，并且依赖于其行为细节。
1177
---
## Page 1179
奇怪的是，这样的做法并没有产生人们所预期的大量问题。一种猜
测是EmacsLisp包之间独立性很强，不过在Emacs的标准版本中，大
约包括1100个Lisp文件，其中有500个文件使用到了其他包里的功能
函数。我的猜测是这些与Emacs一同发布的包的开发人员仔细地处
理了与其相关包的兼容性，并且这些并发人员形成了一个紧密的小
组，会对那些不兼容的修改进行相互的协商。那些不属于Emacs的
包或许就无法做到这点，这些包的并发人员可能会收到加盟的邀
请。
11.3滋长的特性
Emacs不断滋长的特性是其架构的直接成因。下面是一个典型特性
的生命周期：
1.当你发现一个想拥有的特性时，尝试实现它是很容易的：Emacs的
机制不官僚，从而使进入门槛很低。Emacs为Lisp开发提供了一个舒
适的交互式环境。简单的缓冲区模型和显示自动更新机制，使得你
可以只关注于手头的任务。
2.当你定义了一个可以运行的命令之后，只需将其放在自己
的.emacs文件中就可以使其永久有效。如果你经常使用这个功能，
还可以用代码将其与一组快捷键绑定起来。
3.最初你将从一个简单的命令开始，逐渐将演变成一组相互协作的
命令集，这时你可能希望将它们收集在一起，封装到一个包中分享
给朋友们。
4.最后，有一些比较流行的包将纳入Emacs发行版本中，使其标准功
能得到了扩展。
在内建的代码基线中，采用的处理过程是类似的。当拥有编写自定
义Emacs命令的经历之后，就将更容易理解Emacs本身的代码了，因
此当你发现现有命令中的潜在改进点时，则可以阅读该命令的源代
码（前面说过，在帮助文本中就有相应的链接），然后尝试动手对
其进行改进。当你在Emacs工作时重新定义EmacsLisp功能函数，使
得测试更加容易。当你修改完成之后，可以将修改版本放在自己
的.emacs文件中以供自己使用，也可以为官方源代码提供一个补
丁，以供大家使用。
1178
---
## Page 1180
当然，真正的创新想法是很少的。对于经验丰富的用户可言，对
Emacs的改进想法会有类似的感觉，看看其提供的文档，可能会发
现已经有人实现过了。由于有一群喜欢Lisp的Emacs用户，不断地对
Emacs进行调整和修改，至今已经将近20年了，因此大部分人会发
现自已所需要的各种功能，都已经有人做过相应的开发了。
不过，不管是通过添加新的包，还是打上用户贡献的补丁，Emacs
的发展都是一个民众主导的过程，充分反应了用户的兴趣：存在的
功能，不管是显然需要还是很少使用的，都是因为有人编写了它、
有人认为它很有用。Emacs维护者的职责除了修正bug、认可补丁之
外，还包括添加有用的新操作，换句话说，在社群中已经使用的包
中选择最流行的、开发得不错的，将其添加到官方源代码中。
如果这就是全部，那么滋长的特性也就不成什么问题了。不过，它
通常会带来两个方面的副作用：程序的用户界面将变得复杂、难以
理解，程序本身变得难以维护。Emacs对第一个问题做了一些成功
的处理，但对于后一个问题则彻底不管，相对而言更重视程序的功
效。
11.3.1滋长的特性和用户界面复杂性
在评价一个应用程序的用户界面复杂度时，有两个常见的维度：要
维护的模型的复杂度，以及操作该模型的命令集的复杂度。
模型的复杂度
在用户自认为对应用程序的模型有所需的理解之前，需要花多长时
间来学习？如果模型对用户而言是隐藏的，或者比较隐晦，会影响
其应用吗？
微软的Word文档就拥有一个十分复杂的模型。例如，Word能够自动
编译文档中一个小节或一个子小节的字数，自动对后续的文本片段
进行编号，更新文本中对特定小节的引用。不过，如果需要这些特
性按自己的预期执行，那么就需要对Word样式表有很好的理解。对
于那些不会对文档内容产生可视影响的操作是容易出错的，例如如
何避免对列表进行重编号（另外再举一个例子，你可以问一个文
员，在Word2003中如何“自动更新样式”）。Emacs为了避免此类问
题，采用了十分简单的方法：不支持样式表、自动编号小节、页眉
页脚、表格等在现代字处理软件中很常见的功能。它只是一个纯文
1179
---
## Page 1181
本编辑器，Emacs的缓冲区只是一个字符串。在几乎所有情况下，
缓冲区的所有状态只关心其外观。这样的做法，其带来的结果之一
就是使人容易知道Emacs对其文件内容做了什么修改。
命令集的复杂度
在任何时候，发现相关的和有用的操作是否容易？发现一个还未使
用过的功能是否容易？在这方面，Emacs的用户界面相当复杂。一
个刚启动的不带任何定制的Emacs会话，提供了大约2400个命令和
700个快捷键，并且随看使用过程，会话将载入更多的命令和快捷
键。
幸运的是，新用户并不是突然面对这些东西，就像UNIX用户不需学
习所有的shell命令一样。对于初次尝试Emacs的新用户而言，需要
掌握的操作和使用带有图形用户界面的编辑器类似，用鼠标选择某
段文本，通过键盘上的箭头键移动光标，通过菜单命令载入和保存
文件。不熟悉这些命令，不会影响最基本的、可见的功能的使用。
不过，以这种方式使用Emacs得到的效果肯定不会比选择其他文本
编辑器更好。成为专业的Emacs用户必须阅读操作手册和在线文
档，以及学习如何有效地搜索这些资源。诸如grep、编译缓冲区中
的内容、交互式调试工具、源代码索引等功能是Emacs与其他文本
编辑器的主要区别。但是如果不使用它们，这些功能都是不可见
的；同时如果你不知Emacs提供了这些功能，也就不会使用它们。
为了使这类探索更加容易，Emacs还提供了apropos命令集，你可以
通过输入一个字符事或一个正则表达式来获得一组名字、与名称或
文档字符事匹配的命令列表和自定义变量。尽管它无法取代操作手
册，但在你对要查询的命令有一些基本概念时，apropos命令是十分
有用的。
在此类复杂性方面，Emacs用户界面具有命令行界面的很多共性：
提供了大量可用的命令，用户并不需要全部操作它们（甚至很多都
可以不掌握），并且为用户发现新功能付出了很多努力。
幸运的是，Emacs社区在命令的命名规范的建立方面做出了很大的
努力，因此在不同包之间的一致性方面还是很好的。例如，几乎所
有Emacs命令都是非模态的：对于移动、搜索、切换缓冲区、重新
排列窗口等标准命令在任何时候总是可用的，因此你无需担心如何
1180