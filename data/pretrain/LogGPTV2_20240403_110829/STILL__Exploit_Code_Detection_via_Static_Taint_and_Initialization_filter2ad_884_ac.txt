There are two special cases of variable initialization.
One case is the PC value, which we always consider to be
initialized. The other case is for the instructions whose out-
put is independent of their input. For example, instructions
such as “xor eax, eax” or “sub eax, eax” always set eax to
zero regardless of the value stored in eax. In this work, we
recognize these special instructions and consider the result
variables to be initialized. Note that attackers may evade
our initialization analysis by crafting certain sequence of
instructions to initialize a variable to desired constant with-
out being detected. We will discuss this limitation as well
as the solution in Section 4.
3.3 Detection of Plain Exploit Code
So far, we have described how we prevent attackers from
exploiting either self-modifying or indirect jump obfusca-
tion techniques.
In this section, we detect the plain ex-
ploit code with or without other obfuscation, based on sys-
tem calls and function calls detection. In order to access
system resources, the plain exploit code has to use sys-
tem calls or function calls.
In modern operating systems
such as Windows and Linux, the system call is the only
way to transit from user-mode to kernel-mode to execute
privileged instructions.
In order to talk with kernel, the
plain exploit code has to use either system calls or user-
mode APIs (which eventually use system calls). Hence,
if we ﬁnd code patterns of system calls or function calls
to user-mode API in an instruction sequence, we consider
the instruction sequence as plain exploit code. Previous
work [8, 28] also uses a similar idea to detect exploit code.
However, their schemes are vulnerable to metamorphic ob-
fuscation [28]. Our approach is robust to most obfuscation
techniques such as metamorphism by using static taint and
initialization analyses.
Windows and Linux expose system call
interfaces
through interrupt “int 0x2e” and“int 0x80h” , respectively.
Newer versions of Windows and Linux are capable of us-
ing optimized “sysenter” instruction. Because the length
of these three instructions is only two bytes, even normal
network streams may contain plenty of these byte values.
Therefore, using only these instructions as a detection cri-
terion will cause a high false positive rate. We observed
that before these system call instructions normally several
instructions are used to transfer parameters. System call
number is an obligatory parameter for a system call, which
is stored in the eax register. In addition, most system calls
need at least one additional input parameter stored in the
ebx register. In fact, only 15 of all 190 system calls do not
require the parameter in Linux. Since most of these 15 sys-
tem calls such as sys getpid and sys getuid are merely used
to read system or process information in Linux, we believe
exploit code must use other system calls to achieve its pur-
poses. Accordingly, we detect system call exploit code in
the following way. We ﬁrst check if an instruction sequence
contains system call instructions “int 0x2e”,“int 0x80h” or
sysenter. If the instruction sequence contains one of them,
we will analyze the instruction sequence by initialization
analysis. If the registers eax and ebx are initialized before
system call instructions, we conclude that the instruction
sequence is exploit code.
Note that our detection heuristic works not only for plain
exploit code but also for metamorphic code. Instruction “int
0x2e”,“int 0x80h” and sysenter are the only three instruc-
tions to invoke system calls in Windows and Linux, thus the
only way to obfuscate system calls is to obfuscate the in-
structions for transferring parameters. However, because
the registers eax and ebx need be initialized despite the
metamorphism being used, metamorphic system call code
cannot evade our detection.
Attackers may use an alternative way to talk with operat-
294294
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:00:28 UTC from IEEE Xplore.  Restrictions apply. 
ing system kernel. The only other way is through an existing
user-mode API, which eventually invokes system calls, on
the target machine. STILL can also detect function calls to
these existing user-mode APIs by initialization analysis in
exploit code. Due to page limit, we will not discuss the de-
tails. The experimental results of system call and function
call detection will be showed in Section 5.
4 Security Analysis
In this section, we analyze the strength and limitations of
STILL.
4.1 Strength
Besides detecting non-obfuscated exploit code, STILL is
also robust to most of these obfuscation techniques. Pre-
vious sections showed how STILL detects exploit code
that uses polymorphic, self-modifying, indirect jump and
branch function obfuscation. Next we discuss how STILL
handles the other types of obfuscation techniques.
Metamorphism Metamorphic obfuscation techniques
obfuscate the behaviors of a program; however, an obfus-
cated program still bears the same concrete semantic or ab-
stract semantic of the original one. Since our approach is
based on the detection of these invariable abstract seman-
tics, it is robust to metamorphic obfuscation.
Anti-disassembly is a type of obfuscation techniques
that try to confuse traditional disassembly algorithms such
as linear sweep [18]. It includes junk byte insertion, opaque
predicate, code overlap, indirect jump and branch function
obfuscation techniques.
Junk byte insertion in which junk bytes are inserted at
locations that are not reachable at run-time to hinder dis-
assembly. This insertion may mislead linear sweep algo-
rithms, but it cannot mislead recursive traversal algorithms
[16], which our algorithm is based on.
Opaque predicate is used to transform unconditional
jumps into conditional branches.
It allows an obfuscator
to insert junk bytes either at jump targets or in the place of
the fall-through instruction. We note that opaque predicate
may make our approach mistakenly interpret junk byte as
executable code. However, this mistake will not cause our
approach to miss any real malicious instructions. There-
fore, our approach is also immune to obfuscation based on
opaque predicates.
Code overlap is one obfuscation technique in which sev-
eral instructions share one or more bytes. Code overlap can
also confuse linear sweep algorithms, but it cannot confuse
recursive traversal algorithms [23].
Anti-emulation Since our approach is a static analysis
approach, it is immune to anti-emulation obfuscation tech-
niques.
4.2 Limitations
The present version of our tool has a few limitations.
First, the current implementation does not handle mem-
ory address obfuscation. This limitation can be handled by
treating memory access conservatively [9].
Second, attackers may use special ways to initialize
a variable to a constant as a counterattack to initializa-
tion analysis. For example, the sequence of instructions
(mov eax, ebx; add eax, 0x1; sub ebx,−0x1; xor eax, ebx)
shows a special way to initialize eax to 0. This limitation
can be handled by combining our initialization analysis
with symbolic execution [14]. This combination, however,
may cause some performance overhead.
Fortunately,
this overhead is not always incurred, since initialization
analysis is only used to reduce false positives.
Finally,
like previous work [8, 15, 28], STILL does
not detect return-to-libc attacks which do not contain any
code. One way to alleviate return-to-libc attacks is to map
(through mmap()) the addresses of shared libraries so that
the addresses contain null bytes 1 [11].
5 Experimental Results
We implemented a stand-alone and a proxy-based proto-
type of STILL to evaluate our technique. The stand-alone
prototype consists of the following three parts: (1) loader
to load the input ﬁles from disks; (2) disassembler to distill
instruction sequences from the input; (3) analyzer to ana-
lyze the instruction sequences. The prototype will raise one
of the following four types of detailed warnings for each
input ﬁle that is identiﬁed with exploit code: (Type1) A
function call exploit code is detected; (Type2) A system call
exploit code is detected; (Type3) An indirect jump obfusca-
tion code is detected; and (Type4) A self-modifying obfus-
cation code is detected. Note that polymorphic exploit code
is included in Type4. The proxy-based prototype is similar
except that it operates as a proxy taking its input from the
network.
5.1 Detection Eﬀectiveness
Polymorphic Shellcode To evaluate the detection effec-
tiveness of STILL, we collected 12,000 polymorphic at-
tack messages from 10 publicly available polymorphic en-
gines. Among these ten, seven engines are from the Metas-
ploit framework [4], including Countdown, Alpha2, Jump-
CallAdditive, Pex, PexFnstenvMov, PexFnstenvSub, and
ShikataGaNai. The other three engines are CLET [12],
ADMmutate [19], and JempiScodes [3]. Countdown uses
a decrementing byte as the key for decryption; Pex and
1Null bytes, which are C string terminators, cause attacks terminate
before they overﬂow the entire buffer.
295295
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:00:28 UTC from IEEE Xplore.  Restrictions apply. 
JumpCallAdditive are xor decoders and use call to get PC;
PexFnstenvMov and PexFnstenvSub are xor decoders and
use fnstenv to get PC; Alpha2 generates alphanumeric pay-
load; ShikataGaNai, CLET, ADMmutate, and JempiScodes
are advanced polymorphic engines, which also obfuscate
the decryption routine by metamorphism such as instruc-
tion replacement and garbage insertion. CLET also uses
spectrum analysis to defeat data mining methods.
For JempiScodes, we generated 3,000 different attack
messages, 1,000 per each of its three obfuscation algo-
rithms. We also generate 9,000 different attack messages,
1,000 per each of the other nine engines. We tested the
stand-alone prototype of STILL using these 12,000 attack
messages. All of these messages are successfully detected
and reported as warning Type4. We also use these 12,000
attack messages to test SigFree. SigFree can only detect
4,103 of them, because the other attack messages have only
6 to 10 useful instructions which is much below than the de-
tection threshold 15 used in SigFree. Our result shows that
STILL has much better detection coverage than SigFree.
Plain exploit code from Metasploit framework There
are totally 23 different Windows plain shellcode and 11 dif-
ferent Linux plain shellcode in Metasploit framework v2.5.
We generated 34 attack messages for each of them. Note
that for multi-stage shellcode such as “Linux IA32 Staged
Bind Shell”, we use the loading (ﬁrst) stage code to gener-
ate attack messages to show that we can detect multi-stage
shellcode at its ﬁrst stage. We tested all of them by the
stand-alone prototype. All Linux plain shellcodes are de-
tected as Type2. “Windows Execute Command” and “Win-
dows Execute net user” are detected as Type3, and all other
Windows plain shellcodes are detected as Type1.
Worms We also tested on worms CodeRed I, CodeRed
II, Sasser, Slammer and Blaster. CodeRed I, CodeRed II,
Sasser and Slammer are successfully detected as Type1.
Blaster is successfully detected as Type4, since it exploits
polymorphism obfuscation.
5.2 False Positives
Legitimate HTTP trafﬁc We tested the prototype over
real HTTP trafﬁc shown in Table 1(a). Due to privacy con-
cerns, we were unable to deploy a prototype in a large net-
work to examine real-time trafﬁc. To make our test as re-
alistic as possible, we deployed a client-side proxy under-
neath a web browser. The proxy recorded all the http re-
quests and replies of a user during his/her daily Internet
surﬁng. During a three-week period, 7 people installed the
proxy and helped with collecting totally 378,158 HTTP re-
quests/replies stored in 7 separate datasets. The replies and
requests include various types of multimedia data such as
video/audio and image ﬁles, manually typed urls, clicks
through various web sites, search results from search en-
gines such as Google and Yahoo, secure logins to email
Table 1.
(a) HTTP real-trafﬁc datasets
Name
Dataset1
Dataset2
Dataset3
Dataset4
Dataset5
Dataset6
Dataset7
Total
Requests
5,026
32,666
87,260
17,871
26,759
17,075
46,107
232,764
Replies
3,584
27,253
52,772
16,941
28,028
10,042
6,774
145,394
Size(MB)
317.24
288.53
355.99
320.91
129.41
237.52
158.28
1,807.88
Mime-type
application/x-shockwave-ﬂash
application/octetstream
application/x-mms-framed
(b) False positives classiﬁed by mime-types
Warning Type
2
1
1
2
1
6
2
1
0
0
1
15
audio/mpeg
image/gif
image/jpeg
text/plain
1
10
0
0
0
0
0
0
0
0
0
10
3
0
0