代，而几乎所有的初生代收集算法都是阻塞一切的。所以，一个有
大量对象素流的译码器不仅承受不必要的对象分配的可伶性能，还
承受收集器清除所有对象素流时很多非常短暂的GC暂停。
因为这个原因，降低推动解析执行的译码器内的对象素流显得非常
重要。在真实模式的译码器中，这种最低限度的方式导致一个6500
行代码的类只有42个"new"关键字实例：·在类载入时间有4个new
Boolean[]（static final）。
·用于一个旋转缓冲的3个newOperation（）。
·用于Operation中扩展缓冲的2个newint[]。
1112
---
## Page 1114
用于异常情形的33个newllegalStateException（）。
一旦创建这个译码器的一个实例，唯一必须构建的对象是用于
Operation中int[缓冲的扩展。一旦这些缓冲扩展完成，就不再有对
象构建和垃圾收集，因此，那是较少暂停的译码。
译码器的设计阐述了我们考虑的编程（在这个情形中，是Java的）
重要原则之一：仅仅因为你可以这样做，并不意味着你应该这样
做。
在这个情形中，仅仅因为IVM可以进行自动垃圾收集，并不意味着
将迫使你去运用它。在代码的关键性能部分，慎重地使用对象实
例。小心处理像Iterator、String和varargs调用这样的类的不活跃对象
实例。
技巧#1：创建对象不好
过多的对象实例（尤其是短期的对象）会导致不好的性能。这是因
为大量对象引起频繁的年轻代（younggeneration）垃圾收集，而初
生代垃圾收集算法儿乎是“全部停正"类型的。
微码：少即是多或多即是少
我们已经有了一个用于解析IA-32指令流的GC较少的译码器，但
是，我们还没有讨论这样的一个译码器应该如何译码。IA-32架构不
是一个固定长度的指令系统；指令长度的范围从单个字节到最多15
个字节。指令集的许多复杂性源自于可以用于一个指令的任意特定
操作数的内存-寻址模式过多。
初始最高级别的分解把每个运算分为4个阶段：
输入操作数
从寄存器或内存中载人运算的数据。
运算
对输入操作数进行数据处理。
输出操作数
1113
---
## Page 1115
把运算的结果输出到寄存器或内存。
标记运算
调整标记寄存器的位来表示运算的结果。
数的复杂性分离开。像addeax，[es：ecx*4+ebx+8]这样的一个运算
最初分解为5个运算：
load eax
load[es: ecx*4+ebx+8]
add
store eax
updateflags
立即就可以清楚地知道Load[es：ecx*4+ebx+8]完全不是一个简单的
运算，它可以容易地分解到很多更小的元素。实际上，仅对于这个
寻址格式就有：
·6个可能的内存段
8个可能的索引寄存器
8个可能的基址寄存器
仅对于这个寻址模式就产生了384种可能的组合。显然，对这些地
址计算还需要更多的分解。因此，把这种类型的内存存取进一步分
解，直到我们得到：
load eax
memoryreset
load segment es
1114
---
## Page 1116
inc address ecx *4
inc address ebx
inc address imm 8
load [segment: address]
ppe
store eax
updateflags
为了生成可执行的模拟指令集，我们必须平衡这两方面的优先级：
首先，我们必须平衡译码时间和执行时间以优化整体的执行速度。
我们必须记住，在解析处理器中，我们主要的目标是起始执行的响
应时间短。常规执行的代码应该在随后的优化阶段处理。在这里，
我们最初的目标是使代码编译出来而不要阻塞整个模拟器。随后的
优化可以异步地进行，这里花的时间延迟了一切。所以，我们一直
在寻找一个可以快速译码的相对简单的指令集。
·其次，我们必须平衡指令集的大小和“编译后"代码的长度。小的指
令集自然会产生允长的代码，而较大的指令集应该会使代码更紧
凑。我们说“应该"是因为如果选择不好，大的指令集仍然需要较长
的区域。一个较小指令集的解析器在代码和记录日志上会更小，因
此，执行它的每个运算的速度会快很多，但是，相对地，它有更多
的指令集要执行。所以，我们一直在指令集大小和代码长度之间寻
找一个合理的平衡以使解析器达到接近最优的性能。
在寻找这两个方面的最佳平衡点时，牢记Hoare的格言l1非常重
要：
过早的优化是所有不幸的根源。
C.A.R.Hoare
这些优化的精确平衡是由系统决定的。在一个Java环境中，系统不
仅包括物理硬件，还包括JM。加上在这个环境中的Java组件总是
即时编译这个因素，小范围的性能基准众所周知是不可靠的。说到
1115
---
## Page 1117
底，我们不要过度使用这样的基准来指导编码选择，只有当性能出
现大的改变时依赖基本原理和信任的基准。在一个即时编译的环境
中，最好的情况下，在这些微小基准中的小改变在一个单独的系统
中不可重复。在最坏的情况下，它们如此依赖基准场景以致在同一
个系统上都不一定可重复。
注意：微代码集的一个重要特征是为它设置的整数值常量是连续
的。这个解析器的核心是对这个常量集的一个switch语句，我们必
须确保这个switch语句运行得尽可能快。
牢记了这些因素，在几次试验后，我们推断对于全部整数或浮点的
模拟程序而言，750行左右的代码集表现出很好的平衡效果。这给
我们从x86运算到微代码一个近似10的转换因数。虽然这个集合似
乎有点大，但是，它解析的速度很快，而且运算也相当小。这使得
它们可以成为供给随后的优化阶段的很好的候选。
技巧#3：表切换好，查找切换不好
标签集适度紧凑的switch语句比标签集的值更分散的switch语句要
快。这是因为Java对switch有两个字节码：tableswitch和
lookupswitch。表切换是利用一个间接调用执行的，switch的值把偏
移量提供到一个函数表中。查找切换要慢得多，因为它们按对应关
系进行查找以发现一个匹配的值：函数对。
[11http://en.wikiquote.org/wiki/C._A._R._Hoare.
9.8劫持JVM
“Java很慢”的说法至今仍然困扰着Java开发人员。很多这样的评论
来自于非Java开发人员对20世纪90年代中后期的JVM的体验。自那
以后，使用Java的人们知道它已经获得了大幅的改进。在这改进背
后的驱动力也是加速JIPC的关键：常规Java进程的环境可以非常简
单地划分为程序区域和数据区域。
在图9-6中，我们可以看到数据区域可以进一步划分为静态数据（在
编译期间就可以知道）和动态数据（在编译期间不能知道）。Java
环境中大多数的静态数据是从类路径载入的类字节。虽然这些类字
节作为数据载入，但它们实际上代表的是代码，这非常清楚，它们
会在运行时由JVM进行解析。所以，很明显我们愿意把这些类字节
移动到这张图的另一边。
1116
---
## Page 1118
数据
程序
动态
静态
用户输入
类文件
Java虚拟机
外部数据
程序资源
图9-6：一个Java进程中的程序区域和数据区域
在一个即时编译的环境中，例如SunHotSpot，常用的字节码区域分
解析或动态编译到宿主的本地指令集。这样就把类字节从数据区域
移入了代码区域。然后，这些类就像本地代码一样执行，并把程序
加速到本地的速度（参见图9-7）。
数据
程序
动态
静态
优化的JVM
用户输入
类文件
编译的类
外部数据
程序资源
Java虚拟机
图9-7：Java环境中的即时编译
在IPC中，我们利用这个事实：在IVM启动的时候不必知道所有的
类数据。实际上，用Java的说法，“静态数据"作为"最终数据"来引
用比较好。当一个类加载时，它的类字节将固定并不能修改（为了
方便，让我们忽略JVMTIILL）。这允许我们在运行时定义新的类，
那些使用插件架构、Applet或J2EEWeb容器的人会立即熟悉这个概
念。
1117
---
## Page 1119
接下来我们重复一下IVM执行的即时编译技巧，但仅仅在JPC的级
别。对于JIPC，在Java运行时环境的范围内我们有两层的程序-数据
信息划分。现在，我们的编译有两个阶段：
1.在JPC内，IA-32机器代码在需要时会编译成字节码。这些x86块由
此成为了可以由JVM加载的有效的Java类文件。
2.类由JVM编译成本地代码。由于JVM并不区分由手写代码组成的
原始的“静态"类和自动构建的动态类，两种类型都尽可能地获得最
佳的本地性能。
在这两个编译阶段后，我们最初的IA-32机器代码已经翻译成宿主的
架构（参见图9-8）。幸运的是，新指令的数量与最初的数量相比没
有明显增多，这意味着性能不会比本机慢很多。
JPC类
IA-32机器代码
JPC编译
动态类
HotSp
宿主架构机器