age” curve represents the real-world case
where the storage performance is the bot-
tleneck. The “Cloud-cloud network” curve
emulates the storage with /dev/zero such
that the cloud-cloud network link is the bot-
tleneck.
5.5 Breakdown of Costs
Bandwidth baseline. Our baseline for bandwidth is a
simple cloud storage system that just reads and writes un-
encrypted blocks to storage. For example, reading or writing
a 4 KB block from the baseline system will incur 4 KB of
256bandwidth. When we say that there is kX ORAM band-
width cost, we mean that it takes k times as much band-
width to perform an ORAM read or a write operation.
Client-to-cloud bandwidth. Our construction achieves
about 2.6X bandwidth cost which means it takes about 10,647
bytes to read or write 4096 bytes from our multi-cloud ORAM.
Figure 12 shows the breakdown of the client-cloud band-
width cost. Particularly, about 2X (out of a total of ∼ 2.6X)
of the bandwidth cost is due to hiding whether the block is
being read or written (i.e., fetching one block of data with
1X cost and writing one block of data with 1X cost).
For the SSS partitioning framework (Section 2), we use
a background eviction rate at 0.3 times rate of data access
(in addition to the piggybacked write-back with each oper-
ation). Therefore, background evictions account for 0.3X
client-cloud bandwidth cost. Due to space limitations, the
reader is encouraged to refer to [31] for details about the
background eviction process.
The remaining 0.3X or so bandwidth cost is due to the
background onion removal process and the transfer of (en-
crypted and authenticated) checksums between the client
and cloud – as mentioned in Section 4, these checksums
are necessary to ensure security against one malicious cloud.
The checksum size is independent of the block size therefore
when the block size increases, the checksum fraction of the
bandwidth cost decreases.
Cloud-to-cloud bandwidth. The bandwidth cost of the
entire system, which mostly consists of the cloud-to-cloud
bandwidth is a constant factor smaller than that for the
best known single-cloud construction [30] using the same
amount of client memory. The intuition behind why that
is the case is as follows.
In the single-cloud ORAM by
Stefanov et al. [30], when blocks need to be shuﬄed, the
client downloads the blocks, shuﬄes them locally, and up-
loads them back to the cloud in order to avoid increasing the
the client’s storage. However, in our multi-cloud construc-
tion, one of the clouds just shuﬄes the blocks and sends
them to the other cloud and the other cloud simply stores
them and does not need to send the blocks back to the ﬁrst
cloud.
Cryptographic microbenchmarks. We report micro-
benchmarks for our new checksum function described in Sec-
tion 4.1. Figure 13 shows that our checksum function can be
computed at roughly 250-350 MB/s on our Amazon VM, and
at 150 MB/s on our Azure VM. Using hardware-accelerated
AES-NI in modern processors, decryption can be performed
at 2.5 GB/s per onion layer.
Client computation. The client computation for a 1 TB
ORAM mainly consists of: (1) encrypting and computing
the initial checksum of a block when it is written to the
ORAM, (2) encrypting about 15 checksums (16 bytes each)
per block written using the commutative checksum-encryption
technique described in Section 4.1, and (3) decrypting using
AES about 5-15 onion layers of a fetched block that were
added by the clouds during shuﬄing.
Even without hardware AES available on the client, a
modern laptop or desktop computer can easily perform these
cryptographic operations to sustain several megabytes per
second of ORAM throughput, and most likely saturate its
Internet connection (depending on the connection available
to the client).
Server computation.
In order for a server to sustain
about 1 MB/s per sever of bandwidth for a 1 TB ORAM,
the the server needs to be able to sustain about 30 MB/s
of AES computation and 30 MB/s checksum computation
over 4 KB blocks. As we just mentioned, our cryptographic
microbenchmarks show that the Amazon and Azure servers
we rented can sustain at least 5 to 10 times that rate for
checksums and over 80 times that rate for AES.
Client memory and storage. Our client-side storage
(memory) is less than 1.5 GB for an ORAM of up to 1 TB
capacity (i.e., less than 0.15% of the entire ORAM capacity).
Monetary cost. The monetary cost of our system depends
on several factors such as (1) the desired throughput and re-
sponse time, (2) the size of the ORAM, (3) idle time, and
(4) other factors such as geographic location. At the time
the experiment was run, under full load, it’s cost was about
$3.10/hour + $2.50/GB data transfer for 1-server per cloud.
By using Amazon S3 and cheaper VMs instead of high I/O
VM instances, the hourly cost can likely be reduced signiﬁ-
cantly.
6. RELATED WORK
Oblivious RAM was ﬁrst proposed by Goldreich and Os-
trovsky [11] in the context of protecting software from piracy.
They propose a seminal hierarchical construction with
O((log N )3) amortized bandwidth cost, where N denotes
the storage capacity of the ORAM. Since then, a line of
research in the theory community has been dedicated to
ORAM [7, 9–11, 13–16, 19, 22, 23, 25, 32–34].
Several works have suggested the use of ORAM in cloud
computing applications [13, 15, 16, 30, 32, 34, 35]. Williams,
Sion et al. have signiﬁcantly bridged the theory and prac-
tice of ORAM [32, 34, 35]. Goodrich, Mitzenmacher, Ohri-
menko, Tamassia et al. [15, 16] have also made signiﬁcant
contributions in this space. Backes et al. [6] use a combina-
tion of the binary-tree ORAM [27] and trusted hardware to
build privacy-preserving behavioral advertising applications.
Several recent eﬀorts have made further progress towards
making ORAM practical,
including PrivateFS [35],
Shroud [20], and ObliviStore [30]. PrivateFS and Oblivi-
Store show how to build parallel or asynchronous ORAM
schemes that achieve throughput in the range of hundreds of
kilobytes per second on a single disk-bound server — assum-
ing the client-cloud bandwidth is not the bottleneck. Unless
trusted hardware is deployed in the cloud, these schemes
result in 20X-35X client-cloud bandwidth cost, and is un-
suitable for bandwidth constrained clients. Our multi-cloud
ORAM is able to achieve a lower overall bandwidth cost
than both ObliviStore [30] and PrivateFS [35], and an even
lower client-cloud bandwidth cost. Shroud shows how to
implement ORAM with trusted co-processors such as IBM
4764 [2], and scale it up in a distributed data center setting,
but its performance is severely limited by the trusted co-
processors. In comparison, our goal is to provide an imple-
mentation that is readily deployable today (i.e., not relying
on trusted hardware), and that addresses the client-cloud
bandwidth bottleneck.
As mentioned earlier, Lu and Ostrovsky study multi-server
oblivious RAM from a theoretic perspective [21]. They show
that if there exists two non-colluding servers, the total band-
width cost of oblivious RAM (including messages sent be-
tween the client and the servers, as well as amongst the
257servers themselves) may be reduced to O(log N ) under the
constant client local storage setting. Their work is mostly
theory-minded, and results in a high client-server bandwidth
in practice. Lu and Ostrovsky’s non-collusion model is stronger
than ours, since their two non-colluding servers do not com-
municate with each other.
7. CONCLUSION
In this paper, we described a practical two-cloud Oblivi-
ous RAM protocol that reduces the client-server bandwidth
cost to about 2.6 times that of simply reading or writing the
block from non-oblivious cloud storage. In comparison, for
the same amount of client memory available to the client,
the best-known existing (single-cloud) ORAM constructions
have a bandwidth cost of about 20X–35X.
We proposed a novel commutative checksum-encryption
construction that allows our multi-cloud ORAM protocol
to to eﬃciently protect the privacy of the access pattern
against one malicious cloud (without necessarily knowing
which one).
We implemented a complete end-to-end systemdeployed
on multiple servers across two clouds (Amazon EC2 and
Windows Azure) and demonstrated that it can scale and
achieve several megabytes of throughput, saturating the avail-
able bandwidth of most typical client Internet connections.
Acknowledgments
This work is partially supported2 by an NSF Graduate Re-
search Fellowship under Grant No. DGE-0946797, by a DoD
National Defense Science and Engineering Graduate Fellow-
ship, NSF grant CNS-1314857, a Google Research Award,
and a grant from Amazon Web Services. We would like to
thank Matthew Green for helpful discussions and the anony-
mous reviewers for their insightful feedback.
8. REFERENCES
[1] Amazon web services. http://aws.amazon.com/.
[2] IBM 4764 PCI-X cryptographic coprocessor (PCIXCC).
http://www-03.ibm.com/security/cryptocards/pcixcc/
overview.shtml.
[3] Trusted computing group.
http://www.trustedcomputinggroup.org/.
[4] Windows azure. http://www.windowsazure.com/.
[5] D. Asonov and J.-C. Freytag. Almost optimal private
information retrieval. In PET, 2003.
[6] M. Backes, A. Kate, M. Maﬀe, and K. Pecina. Obliviad:
Provably secure and practical online behavioral advertising.
In S & P, 2012.
[7] D. Boneh, D. Mazieres, and R. A. Popa. Remote oblivious
storage: Making oblivious RAM practical. Manuscript,
2011.
[8] R. Chow, P. Golle, M. Jakobsson, E. Shi, J. Staddon,
R. Masuoka, and J. Molina. Controlling data in the cloud:
outsourcing computation without outsourcing control. In
CCSW, 2009.
[9] I. Damg˚ard, S. Meldgaard, and J. B. Nielsen. Perfectly
secure oblivious RAM without random oracles. In TCC,
2011.
[10] O. Goldreich. Towards a theory of software protection and
simulation by oblivious RAMs. In STOC, 1987.
2Any opinions, ﬁndings, and conclusions or recommenda-
tions expressed in this material are those of the author(s)
and do not necessarily reﬂect the views of the funding agen-
cies.
[11] O. Goldreich and R. Ostrovsky. Software protection and
simulation on oblivious RAMs. J. ACM, 1996.
[12] M. T. Goodrich. Randomized shellsort: A simple
data-oblivious sorting algorithm. J. ACM, 58(6):27:1–27:26,
Dec. 2011.
[13] M. T. Goodrich and M. Mitzenmacher. Privacy-preserving
access of outsourced data via oblivious RAM simulation. In
ICALP, 2011.
[14] M. T. Goodrich, M. Mitzenmacher, O. Ohrimenko, and
R. Tamassia. Oblivious RAM simulation with eﬃcient
worst-case access overhead. In ACM Cloud Computing
Security Workshop (CCSW), 2011.
[15] M. T. Goodrich, M. Mitzenmacher, O. Ohrimenko, and
R. Tamassia. Practical oblivious storage. In CODASPY,
2012.
[16] M. T. Goodrich, M. Mitzenmacher, O. Ohrimenko, and
R. Tamassia. Privacy-preserving group data access via
stateless oblivious RAM simulation. In SODA, 2012.
[17] A. Iliev and S. W. Smith. Protecting client privacy with
trusted computing at the server. IEEE Security and
Privacy, 3(2):20–28, Mar. 2005.
[18] M. Islam, M. Kuzu, and M. Kantarcioglu. Access pattern
disclosure on searchable encryption: Ramiﬁcation, attack
and mitigation. In Network and Distributed System
Security Symposium (NDSS), 2012.
[19] E. Kushilevitz, S. Lu, and R. Ostrovsky. On the
(in)security of hash-based oblivious RAM and a new
balancing scheme. In SODA, 2012.
[20] J. R. Lorch, J. W. Mickens, B. Parno, M. Raykova, and
J. Schiﬀman. Shroud: Enabling private access to large-scale
data in the data center. In FAST, 2013.
[21] S. Lu and R. Ostrovsky. Distributed oblivious ram for
secure two-party computation. Cryptology ePrint Archive,
Report 2011/384, 2011. http://eprint.iacr.org/.
[22] R. Ostrovsky. Eﬃcient computation on oblivious RAMs. In
ACM Symposium on Theory of Computing (STOC), 1990.
[23] R. Ostrovsky and V. Shoup. Private information storage
(extended abstract). In STOC, pages 294–303, 1997.
[24] J. Ousterhout, P. Agrawal, D. Erickson, C. Kozyrakis,
J. Leverich, D. Mazi`eres, S. Mitra, A. Narayanan,
G. Parulkar, M. Rosenblum, S. M. Rumble, E. Stratmann,
and R. Stutsman. The case for ramclouds: scalable
high-performance storage entirely in dram. SIGOPS Oper.
Syst. Rev., 43(4):92–105, Jan. 2010.
[25] B. Pinkas and T. Reinman. Oblivious RAM revisited. In
CRYPTO, 2010.
[26] J. Schiﬀman, T. Moyer, H. Vijayakumar, T. Jaeger, and
P. McDaniel. Seeding clouds with trust anchors. In CCSW,
pages 43–46, 2010.
[27] E. Shi, T.-H. H. Chan, E. Stefanov, and M. Li. Oblivious
RAM with O((log N )3) worst-case cost. In ASIACRYPT,
pages 197–214, 2011.
[28] S. W. Smith and D. Saﬀord. Practical server privacy with
secure coprocessors. IBM Syst. J., 40(3):683–695, Mar.
2001.
[29] E. Stefanov and E. Shi. Multi-cloud oblivious storage.
Technical report.
[30] E. Stefanov and E. Shi. ObliviStore: High performance
oblivious cloud storage. In IEEE Symposium on Security
and Privacy, 2013.
[31] E. Stefanov, E. Shi, and D. Song. Towards practical
oblivious RAM. In NDSS, 2012.
[32] P. Williams and R. Sion. Usable PIR. In NDSS, 2008.
[33] P. Williams and R. Sion. Round-optimal access privacy on
outsourced storage. In CCS, 2012.
[34] P. Williams, R. Sion, and B. Carbunar. Building castles out
of mud: practical access pattern privacy and correctness on
untrusted storage. In CCS, 2008.
[35] P. Williams, R. Sion, and A. Tomescu. Privatefs: A parallel
oblivious ﬁle system. In CCS, 2012.
258