title:The Design and Implementation of an Intrusion Tolerant System
author:James C. Reynolds and
James E. Just and
Ed Lawson and
Larry A. Clough and
Ryan Maglich and
Karl N. Levitt
The Design and Implementation of an Intrusion Tolerant System
James Reynolds, James Just, Ed Lawson, Larry Clough, Ryan Maglich
{reynolds, jjust, elawson, lclough, rmaglich}@teknowledge.com
Teknowledge Corporation
Karl Levitt
University of California Davis
PI:EMAIL
Abstract
or
configuration
implementation,
tolerance: detection,
We describe the implementation of an intrusion
tolerant system for providing Internet services to known
users through secure connections. Network attacks are
treated as maliciously devised conditions to exploit
design,
faults,
intrusions (successful attacks) are treated as failures, and
their effects are mitigated by using the three pillars of
fault
isolation, and recovery.
to our approach is the use of diverse
Fundamental
process pairs, which provides partial
to
detection and isolation problems. The architecture uses
the comparison of outputs from diverse applications to
provide a significant and novel
intrusion detection
capability. The diverse applications also strengthen
isolation by forcing attacks
independent
vulnerabilities. The isolation of
intrusions is mainly
achieved with an out-of-band control system. The control
system not only provides separation between the primary
and backup system,
it also initiates attack diagnosis,
attack blocking, and recovery, which is accelerated by
on-line repair.
to exploit
solutions
1
Introduction
Despite efforts over many years to provide defenses
against computer and network attacks, attacks
still
succeed with painful frequency. Many of the techniques
devised to build more secure systems, for example, at
higher levels of the “Orange Book” [1], were expensive
specialized,
and
proprietary systems. Due to timeliness or cost,
these
techniques are not appropriate for most applications.
time-consuming
resulted
and
in
A promising approach to building more secure but still
affordable and timely systems is to combine Commercial-
Off-The-Shelf
(COTS) hardware and software with
proven techniques from the fault
tolerant community.
COTS software and hardware can provide cheap but
unreliable components to build information systems. Fault
tolerant
techniques can build reliable systems from
unreliable components. In fact, highly available systems
have been built with this approach [2].
and
have
security
network
Fault tolerant techniques usually are designed to work
against faults that are modeled as rare events occurring
independently. The faults that pertain specifically to
computer
different
characteristics. A programming mistake (fault) produces a
latent error (vulnerability), which can be exploited by an
attacker. An attacker can try many exploits against a
system to find its vulnerabilities, and he can repeat
the same system or other
successful exploits against
In addition,
systems with the
successful attacks or
(failures) are often
designed to propagate.
same vulnerability.
intrusions
The specific goal of our project is to enable COTS-
based software to continue providing acceptable service
during several hours of cyber attacks by a determined,
resourceful adversary. We have made significant progress
toward this goal by innovative modifications to proven
methods of achieving detection, isolation, and recovery.
The rest of the introduction briefly describes HACQIT
(Hierarchical Adaptive Control of Quality of service for
Intrusion Tolerance) including its assumptions and failure
model. Most of the paper (sections 2-5) describes the
mechanisms for detection, isolation, and recovery, and a
demonstration of those mechanisms. The last section
describes potential benefits from our work and some
caveats.
1.1 Assumptions
HACQIT is not designed to be a general-purpose
server connected to the Internet. Anonymous users are not
allowed. All connections to the system are through a
Virtual Private Network (VPN). We assume that
the
configuration of the system has been done correctly,
which includes patching of all known vulnerabilities. We
assume the Local Area Network (LAN) is reliable, cannot
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:25:04 UTC from IEEE Xplore.  Restrictions apply. 
be flooded, and is the only means of communication
between users and system.
An attacker can be any agent other than the trusted
users or HACQIT system administrators. Attackers do not
have physical access to HACQIT cluster. An attacker may
be able to take over a trusted user’s machine and launch
attacks against HACQIT.
commercial firewall and additional software for failover
and attack blocking;
two or more servers of critical
applications (one primary, one backup, and one of more
on-line spares); and an Out-Of-Band (OOB) machine
running the overall monitoring and control and fault
diagnosis software. The machines in the cluster are
connected by two separate LANs.
1.2
Failure Model
A failure occurs when observed behavior deviates
from specified behavior. For HACQIT, we are concerned
with software failures. Software failures are either
repeatable or not. The causes of repeatable failures would
include attacks (maliciously devised inputs) that exploit
the same vulnerability (bug) in one of our software
components. Non-repeatable failures may be caused by
intermittent or transient faults. We cannot divine intent,
so all inputs that cause repeated failures are treated the
same. On the other hand, we recognize that the system
may fail intermittently from certain inputs, in which case
we allow retry.
1.3
System Architecture
A u th o r iz e d U s e r
V P N
In te r n e t
A tt a c k e r W o rk s ta tio n
E n c la v e F ire w a l l
V P N
V P N
H ija c k e d L a p t o p
A u t h o riz e d U s e r
E th e rn e t
C o r p o r a te L A N
C lu s te r F ire w a l l
S w it c h 1
P rim a ry
B a c k u p
S w itc h 2
L e g e n d
O u t o f B o u n d
C o n tr o l N e tw o rk
O O B M a c h in e
Figure 1. Intrusion tolerant
hardware architecture
The fundamental building block in our architecture,
which is the focus of this paper, is a HACQIT cluster,
shown in Figure 1. A HACQIT cluster consists of at least
four
a
computers:
computer
gateway
running
a
HACQIT uses primary and backup systems, but they
are unlike ordinary primary and backup systems for fault
tolerance. The two systems are not on the same LAN;
they are isolated by the OOB computer, so no propagation
of faults, for example by a worm or an email virus,
directly from the primary to the backup, is possible. (The
hosts are connected by switches not hubs, and the
switches are configured so that no direct communication
is possible between the primary and backup.) The
for propagation from the primary to the
potential
Mediator/Adaptor/Controller
the OOB
machine
and
monitoring the services and protocols by which the MAC
communicates with the primary. When failure is detected
on the primary (possibly caused by an attack), continued
service to the end user is provided by promoting the
backup to primary. A new process pair is formed with an
on-line spare (if available), and both attack diagnosis and
recovery of the failed primary begins. Depending on
policy,
the MAC can also direct blocking of future
requests from the machine suspected of launching the
attack.
constraining
sharply
(MAC)
limited
by
is
on
1.4
Software Architecture
Most of the software components shown in Figure
2 will be discussed in the next three sections. Here we
will describe the Forensics Agent (FA). After failover, it
performs attack diagnosis by analyzing the “App Log”
containing recent requests to determine which request(s)
caused the failure. “Bad Requests” are put on a list the
Content Filter uses to tell the MAC if a future request
should be blocked. The FA learns attacks from failures,
while
the Content Filter generalizes bad requests
identified by the FA, so that simple variants are also
blocked. In this way, previously unknown attacks (and yet
unseen variants) are automatically and immediately
prevented from repeatedly causing failover. Compare this
with the hours it takes to receive updates to the signature
file of anti-virus software or the days it takes to receive
and apply software patches, which often require reboot.
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:25:04 UTC from IEEE Xplore.  Restrictions apply. 
Snort
Tripwire
Protection Wrapper
Filter/Redirect
Wrapper
IIS/Apache
Event
Logs
Host
Monitor
App
Monitor
Native
Bridge
DLL
Firewall
SAM Client
Firewall
Controller
TCP
Backup not
shown
TCP
RMI
App
Log
Policy
Server
MAC
Policy
Editor
Policy
TCP
Forensics
Agent
Content
Filter
Figure 2. Intrusion tolerant software architecture
2 Detection
components
Duplicate and compare is an old and effective strategy
for hardware error detection [3]. The same input is sent to
identical
from the
components are compared. If the outputs are different, an
error has been detected. If the input is retried and the
outputs are the same, the failure was transient; otherwise,
the components must be repaired or replaced.
outputs
and
the
Typically, the duplicated components are within one
single device, such as a CPU, which,
in the case of
permanent (hard) failure, is the unit repaired or replaced.
If this is not the case, the module or system consisting of
the paired components, must stop. (Following Gray and
Reuter [4], we call this behavior failfast, because the
delay between detecting the error and stopping must
happen as quickly as possible
fault
propagation.) If a system built on paired components
simply stops, then the redundancy has supported error
prevent
to
detection but not failure masking, which is necessary to
provide continued service despite failures.
HACQIT combines redundancy and diversity to both
detect errors and mask failures for software components.
This is a unique innovation for software fault tolerance.
HACQIT uses two software components with identical
functional specifications but different implementations. It
can be seen as combining the benefits of N-version
programming without
its controversial disadvantages,
namely higher cost overall and lower quality components
(versions) [5,6].
We can do this with web servers and other well
known, TCP/IP-based applications like mail servers,
implement a single
because these applications must
specification,
many
implementations. HACQIT uses
two web servers,
Microsoft’s Internet Information Server (IIS) and the
open-source Apache web server, to implement this design
approach.
already
there
and
are
Every HTTP request to the primary is intercepted and
is
to the MAC. After checking that
the request
sent
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:25:04 UTC from IEEE Xplore.  Restrictions apply. 
allowed (see Section 3), the request is sent to both web
servers, one on the primary and one on the backup, one
IIS and one Apache. The HTTP specification defines the
status codes with which a web server must respond. The
MAC compares the responses (analogous to the outputs
from duplicate hardware). If they are the same, the result
indicates that no failure (intrusion) has occurred. If the
status codes are different, the result indicates that a failure
may have occurred.
In the latter case, failfast semantics demands failover
as quickly as possible, especially because the danger from
intrusion propagation is so much greater than the danger
from transient fault propagation. The question, then, is
how to determine which web server was successfully
attacked. An analysis of HTTP status codes makes this
possible.
Status codes lie in five general categories [8]:
•  Status codes 100 – 199: Informational. Request
received, continuing process
•  Status codes 200 – 299: Success. Action was
received, understood and accepted.
•  Status codes 300 – 399: Redirection. Further
action must be taken in order to complete the
request.
•  Status codes 400 – 499: Client Error. The request
contains bad syntax or cannot be fulfilled.
•  Status codes 500 – 599: Server Error. The server
failed to fulfill an apparently valid request.
There are only ten different combinations of two
different status codes. Most are nonsensical, so rare they
have not been observed in our experience, or simply not
indicative of an error. One meaningful combination that
can occur
is 200/400. This means one web server
responded with success while the other responded with