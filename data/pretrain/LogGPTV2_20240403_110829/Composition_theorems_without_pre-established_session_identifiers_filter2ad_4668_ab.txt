Composition Theorems. We restate the composition theorems
from [19], in a slightly simpliﬁed way. The ﬁrst composition theo-
rem handles concurrent composition of a ﬁxed number of protocol
systems. The second one guarantees secure composition of an un-
bounded number of copies of a protocol system.
Theorem 1
([19]). Let P1,P2,F1,F2 be protocol systems such
that P1 and P2 as well as F1 and F2 only connect via their I/O
interfaces and Pi ≤ Fi, for i ∈ {1, 2}. Then, P1 |P2 ≤ F1 |F2.
Let F and P be protocol systems, which, for example, describe
one session of an ideal/real protocol. By F and P we denote the
so-called session versions of F and P, which allow an environment
to address diﬀerent sessions of F and P, respectively, in the multi-
session versions !F and !P of F and P by preﬁxing messages
with session identiﬁers (SIDs); an instance of P/F is accessed via
a unique SID. Conversely, messages output by F and P will be
preﬁxed by their respective SID.
Theorem 2
F . Then, !P ≤ !F .
([19]). Let P,F be protocol systems such that P ≤
These theorems can be applied iteratively to construct more and
more complex systems. For example, using that ≤ is reﬂexive, we
obtain, as a corollary of the above theorems, that for any proto-
col system Q: P ≤ F implies Q| !P ≤ Q| !F , i.e., Q using an
unbounded number of copies of P realizes Q using an unbounded
number of copies of F . This corollary is in the spirit of Canetti’s
universal composition theorem [7].
3. UNIVERSAL COMPOSITION
WITHOUT PRE-ESTABLISHED SIDS
Universal composition theorems, such as Theorem 2 and the
composition theorem by Canetti, allow to obtain security for mul-
tiple sessions of a protocol by analyzing just a single session. Such
theorems can therefore greatly simplify protocol analysis. How-
ever, these theorems rely on the setup assumption that the parties
participating in a protocol session agree upon a unique SID and
that they invoke their instance of the protocol with that SID. This
is due to the way multi-session versions of ideal functionalities are
deﬁned in these composition theorems: A multi-session version of
an ideal functionality F is such that parties which want to access an
instance of F have to agree on a unique SID in order to be able to
all invoke the same instance of F with that SID. As a consequence,
the composition theorems implicitly require that a session of a real
protocol with SID s realizes a session of the ideal functionality with
SID s. (For example, if a session of the real protocol consists of two
instances, e.g., an initiator instance and a responder instance, then
the initiator with SID s and the responder with SID s together have
to realize the ideal functionality with SID s.) This, in turn, implies
that the real protocol has to use the SID s in some way, since other-
wise there is nothing that prevents grouping instances with diﬀerent
SIDs (e.g., an initiator with SID s and a responder with SID s(cid:48)) into
one session. One usage of the SID s is, for example, to access a
resource for the speciﬁc session, e.g., a functionality (with SID s)
that provides the parties with fresh keys or certain communication
channels for that speciﬁc session. In realizations with joint state, s
is typically used in all messages exchanged between parties in or-
der to prevent interference with other sessions (see also Section 4).
Canetti [8] discusses three methods of how such unique SIDs
could be established, including a method proposed by Barak et
al. [2], where parties simply exchange nonces in clear and then
form a unique SID by concatenating these nonces and the party
names. We will refer to such uniquely established SIDs (using
whatever method) by pre-established SIDs. The use of pre-estab-
lished SIDs is certainly a good design principle. However, assum-
ing pre-established SIDs and, as a result, forcing their use in the
protocols greatly limits the scope of the composition theorems for
the analysis of existing protocols. In particular, they cannot be used
for the modular analysis of real-world security protocols since such
protocols typically do not make use of SIDs in this explicit and
speciﬁc way. In other words, the composition theorems could only
be used to analyze idealized/modiﬁed versions of such protocols.
However, this is dangerous: While the idealized/modiﬁed version
of a protocol might be secure, its original version may not be se-
cure (see Section 4). We note that, alternatively, protocols could of
course directly be analyzed in the multi-session settings, instead of
ﬁrst analyzing the single-session setting and then lifting the analy-
sis to the multi-session setting by a composition theorem. But this
kind of analysis would be more involved and would not exploit the
potential of modular analysis, which for the comprehensive analy-
sis of complex protocols, such as real-world security protocols, is
essential.
In this section, we therefore present a general universal compo-
sition theorem that does not assume pre-established SIDs (and their
use in protocols). For this purpose, we ﬁrst provide a new deﬁni-
tion of the multi-session version of an ideal functionality. Our new
multi-session version models the more realistic scenario that a party
accesses an instance of an ideal functionality F simply by a local
SID, which is locally chosen and managed by the party itself. It is
then left to an adversary (simulator) to determine which group of
local sessions may use one instance of F, where the grouping into
what we call a (global) session is subject to certain restrictions (see
below). This seemingly harmless modiﬁcation not only provides
a more realistic and common interface to the functionality (and its
realization), but, as explained above, more importantly frees the re-
alization from the need to use pre-established SIDs and allows for
realizations that faithfully model existing (real-world) protocols.
Before presenting the new multi-session versions of ideal function-
alities and our composition theorem, we ﬁx some notation and ter-
minology for modeling arbitrary real protocols.
3.1 Multi-Session Real Protocols
A multi-session real protocol is an arbitrary real protocol with n
roles, for some n ≥ 2, which may use arbitrary subprotocols/func-
tionalities to perform its tasks. More precisely, a multi-session
(real) protocol P is a protocol system of the form P = !M1 |···| !Mn
for some n ≥ 2 and machines M1, . . . , Mn. Each machine Mr repre-
sents one role in the protocol and, since these machines are under
the scope of a bang operator, there can be multiple instances of each
machine in a run of the system (see below). Every machine Mr has
43i) an I/O input and output tape for communication with the environ-
ment (users), ii) a network input and output tape for communication
with the adversary (modeling the network), and iii) an I/O input and
output tape for communication with a subprotocol/ideal function-
ality F . We require that the I/O interface of F consists of n pairs
of I/O input and output tapes, one for each role. Note that F may
include several subprotocols/functionalities. We say that P uses F .
A machine Mr expects inputs to be preﬁxed with a tuple of the
form (lsid, p) from the environment (user) and the adversary, and
it preﬁxes all messages it outputs with (lsid, p). Intuitively, p is a
party identiﬁer (PID) and lsid a local SID (LSID), locally chosen
and managed by party p. In a run of P there will be at most one
instance of Mr with ID (lsid, p), representing the local session lsid
of party p in role r.
To model corruption, we assume that every (instance of) Mr
stores a ﬂag corrupted ∈ {false, true} in its state, which initially
is false. At some point, Mr might set it to true in which case we
call Mr corrupted. We require that once Mr sets the ﬂag to true,
it stays true. Furthermore, whenever the environment sends the
message (lsid, p, Corrupted?) to Mr (on the I/O tape), Mr replies
with (lsid, p, Corrupted, corrupted). This allows the environment
to know which instances are corrupted. (As usual, this is neces-
sary in simulation-based settings.) However, we do not ﬁx how
Mr behaves when corrupted; we leave this entirely up to the def-
inition of Mr. One possible behavior could be, for example, that
when corrupted, Mr gives complete control to the adversary by for-
warding all messages between the environment and the adversary.
We note that the possibility of corrupting single instances of Mr is
quite ﬁne-grained and allows several forms corruption, including
complete corruption of a party: the adversary can simply corrupt
all instances of that party.
3.2 A New Multi-Session Version of
Ideal Functionalities
Let F be any machine, modeling an ideal functionality, with n
pairs of input and output I/O tapes, one for each role, and one pair
of input and output network tapes. We now deﬁne the new multi-
session version of F, informally explained above. We call this new
multi-session version multi-session local-SID (ideal) functionality
and denote it by F [F] or simply F :
A user of F is identiﬁed within F by the tuple (p, lsid, r), where
p is a party identiﬁer (PID), r ≤ n a role, and lsid a local SID
(LSID), which can be chosen and managed by the party itself. In
particular, on the tape for role r, F expects requests to be preﬁxed
by tuples of the form (lsid, p), and conversely, F preﬁxes answers
sent on that tape with a tuple of the form (lsid, p).
A user of F , say (p, lsid, r), can initiate a session by sending
a session-start message of the form (lsid, p, Start, m) where m is
an optional bit string, which can be used to set parameters of the
session, e.g., the desired partners or the name of a key distribution
server. For example, in the case of two-party key exchange, a user
with PID p who wants to exchange a key with party p(cid:48) could set
m = (p, p(cid:48)). We emphasize that the interpretation of m is left to
F. Upon such a session-start request, F records this request (if it
is the ﬁrst such request from (p, lsid, r)) as a local session for user
(p, lsid, r) and forwards this information to the adversary.
The adversary (simulator) determines to which global session
local sessions belong, by sending a session-create message of the
form (Create, sid) to F where sid = (p1, lsid1, 1), . . . , (pn, lsidn, n)
contains one local session for every role. (We note that F could
easily be extended to deal with multiple local sessions per role.)
The machine F only accepts such a message if it is consistent with
the local sessions: The mentioned local sessions all exist, are not
corrupted (see below), and are not already part of another global
session. If F accepts such a session-create message, F internally
creates a new instance of F identifying it by sid. Then, F sends
the message (Create, m1, . . . , mn) to this instance of F where, for
all r ≤ n, mr is the optional bit string contained in the session-start
message of user (pr, lsidr, r). The adversary can address this in-
stance of F (via the network interface) by preﬁxing messages with
sid; conversely, messages output by F on its network interface are
preﬁxed with sid.
For a message m of a user (p, lsid, r), which is not a session-
start message or a message of the form Corrupted? (see below),
F checks whether (p, lsid, r) is part of a global session. If not, F
drops m, i.e., this message is ignored. Otherwise, F forwards m
to the corresponding instance of F. Conversely, F forwards all
messages from an instance of F on tape r to the corresponding user
in role r.
We model corruption as follows in F . The adversary can send a
corrupt message of the form (Corrupt, (p, lsid, r)) for a local ses-
sion (p, lsid, r) to F . The machine F only accepts this message if
the local session (p, lsid, r) is not already part of a global session,
and in this case records (p, lsid, r) as corrupted. For every cor-
rupted local session, F forwards all messages from a user of that
local session to the adversary (instead of forwarding them to F)
and vice versa. This models that the adversary has full control over
corrupted local sessions. Note that once a local session is part of a
global session, the local session or its corresponding global session
can still be corrupted at any time according to the way corruption
is deﬁned in F, which we do not restrict.
Finally, a user may ask F whether or not a local session was
corrupted before being part of a global session by sending the mes-
sage (lsid, p, Corrupted?). Then, F replies accordingly with true
or false. This, as usual, guarantees that the environment is aware of
who is corrupted, preventing the simulator from simply corrupting
all local sessions. Whether or not a user can ask about the cor-
ruption status of F is completely up to the deﬁnition of F, which,
again, we do not restrict.
We note that the above deﬁnition of a multi-session version of an
ideal functionality applies to any ideal functionality F.
Technically, for a real protocol to realize a multi-session local-
SID functionality the simulator must be able to group instances of
the simulated real protocol into a global session before interaction
with the functionality F is possible. This means that a real protocol
needs to allow for the grouping of instances by whatever mecha-
nism (where the mechanisms is typically intertwined with the rest
of the protocol). In particular, the grouping is part of the protocol,
and hence, can now be precisely modeled and analyzed. For exam-
ple, for authentication, key exchange, secure channel protocols and
the like, being able to tell which instances are grouped together is
an essential part of what these protocols (have to) guarantee and
diﬀerent protocols use diﬀerent mechanisms; these mechanisms
should be part of the analysis. Conversely, before there was one
ﬁxed mechanism for grouping instances, namely pre-established
SIDs. Real protocols needed to make sure that they in fact can be
grouped according to the SID they obtained, and hence, they had to
use the SID in some essential way. Moreover, the SIDs came from
outside of the protocol, and hence, their establishment was not part
of the protocol.
3.3 The Universal Composition Theorem
Without Pre-Established SIDs
We now present our universal composition theorem. Let P be
a multi-session protocol using a multi-session local-SID function-
ality F (cid:48) and let F be a multi-session local-SID functionality. In-
44formally, our theorem states that if P|F (cid:48) realizes F in the single-
session setting, then P|F (cid:48) realizes F in the multi-session setting.
The important point here is that, by the deﬁnition of multi-session
local-SID functionalities, no pre-established SIDs (nor their use in
the protocol) are required.
To formulate this theorem, we consider a machine Fsingle that is
put on top of P|F (cid:48) and F , respectively, and that allows an envi-
ronment to create at most one session, i.e., only one user is allowed
per role. We note that an alternative to using Fsingle would be to
restrict the environment explicitly.
To be able to prove the composition theorem, we need to restrict
the class of simulators used to prove that P|F (cid:48) realizes F in the
single-session case. For this purpose, we deﬁne the following sim-
ulation relation: We say that P|F (cid:48) single-session realizes F (de-
noted by Fsingle |P|F (cid:48) ≤∗ Fsingle |F ) if i) Fsingle |P|F (cid:48) ≤ Fsingle |F ,
i.e., according to Deﬁnition 1, there exists a simulator Sim such
that for all E it holds that E| Fsingle |P|F (cid:48) ≡ E| Sim| Fsingle |F , and