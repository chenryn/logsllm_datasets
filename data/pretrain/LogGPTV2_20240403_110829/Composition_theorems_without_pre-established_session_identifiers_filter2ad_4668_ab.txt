### Composition Theorems

We restate the composition theorems from [19] in a slightly simplified manner. The first theorem addresses the concurrent composition of a fixed number of protocol systems, while the second theorem ensures secure composition for an unbounded number of copies of a protocol system.

**Theorem 1** ([19]): Let \( P_1, P_2, F_1, F_2 \) be protocol systems such that \( P_1 \) and \( P_2 \), as well as \( F_1 \) and \( F_2 \), only connect via their I/O interfaces, and \( P_i \leq F_i \) for \( i \in \{1, 2\} \). Then, \( P_1 | P_2 \leq F_1 | F_2 \).

Let \( F \) and \( P \) be protocol systems that describe one session of an ideal or real protocol. By \( F \) and \( P \), we denote the session versions of these systems, which allow an environment to address different sessions of \( F \) and \( P \) in the multi-session versions \( !F \) and \( !P \) by prefixing messages with session identifiers (SIDs). An instance of \( P \) or \( F \) is accessed via a unique SID. Conversely, messages output by \( F \) and \( P \) will be prefixed by their respective SIDs.

**Theorem 2** ([19]): Let \( P \) and \( F \) be protocol systems such that \( P \leq F \). Then, \( !P \leq !F \).

These theorems can be applied iteratively to construct more complex systems. For example, using the fact that \( \leq \) is reflexive, we obtain, as a corollary of the above theorems, that for any protocol system \( Q \): \( P \leq F \) implies \( Q | !P \leq Q | !F \). This means that \( Q \) using an unbounded number of copies of \( P \) realizes \( Q \) using an unbounded number of copies of \( F \). This corollary aligns with Canetti's universal composition theorem [7].

### Universal Composition Without Pre-Established SIDs

Universal composition theorems, such as Theorem 2 and Canetti's composition theorem, allow for the security analysis of multiple protocol sessions by examining just a single session. These theorems simplify protocol analysis. However, they rely on the assumption that parties participating in a protocol session agree upon a unique SID and invoke their instance of the protocol with that SID. This is due to the way multi-session versions of ideal functionalities are defined: a multi-session version of an ideal functionality \( F \) requires parties to agree on a unique SID to access the same instance of \( F \). Consequently, the composition theorems implicitly require that a session of a real protocol with SID \( s \) realizes a session of the ideal functionality with SID \( s \). This implies that the real protocol must use the SID \( s \) to prevent instances with different SIDs from being grouped into one session.

Canetti [8] discusses three methods for establishing unique SIDs, including a method proposed by Barak et al. [2], where parties exchange nonces in clear and form a unique SID by concatenating these nonces and party names. We refer to such uniquely established SIDs as pre-established SIDs. While the use of pre-established SIDs is a good design principle, assuming their use limits the scope of the composition theorems for analyzing existing protocols. Real-world security protocols typically do not use SIDs in this explicit and specific way, making it dangerous to analyze idealized or modified versions of such protocols. Alternatively, protocols could be directly analyzed in a multi-session setting, but this would be more involved and would not exploit the potential of modular analysis, which is essential for complex protocols.

In this section, we present a general universal composition theorem that does not assume pre-established SIDs. We provide a new definition of the multi-session version of an ideal functionality, modeling a more realistic scenario where a party accesses an instance of an ideal functionality \( F \) by a locally chosen and managed SID. It is then left to an adversary (simulator) to determine which group of local sessions may use one instance of \( F \), subject to certain restrictions. This modification provides a more realistic and common interface to the functionality and frees the realization from the need to use pre-established SIDs, allowing for faithful models of existing protocols.

#### 3.1 Multi-Session Real Protocols

A multi-session real protocol is an arbitrary real protocol with \( n \) roles, for some \( n \geq 2 \), which may use arbitrary subprotocols/functionalities. A multi-session (real) protocol \( P \) is a protocol system of the form \( P = !M_1 | \cdots | !M_n \) for some \( n \geq 2 \) and machines \( M_1, \ldots, M_n \). Each machine \( M_r \) represents one role, and there can be multiple instances of each machine in a run of the system. Every machine \( M_r \) has:
1. An I/O input and output tape for communication with the environment (users).
2. A network input and output tape for communication with the adversary (modeling the network).
3. An I/O input and output tape for communication with a subprotocol/ideal functionality \( F \).

We require that the I/O interface of \( F \) consists of \( n \) pairs of I/O input and output tapes, one for each role. Note that \( F \) may include several subprotocols/functionalities. We say that \( P \) uses \( F \).

A machine \( M_r \) expects inputs to be prefixed with a tuple of the form \( (lsid, p) \) from the environment (user) and the adversary, and it prefixes all messages it outputs with \( (lsid, p) \). Here, \( p \) is a party identifier (PID) and \( lsid \) is a local SID (LSID), locally chosen and managed by party \( p \). In a run of \( P \), there will be at most one instance of \( M_r \) with ID \( (lsid, p) \), representing the local session \( lsid \) of party \( p \) in role \( r \).

To model corruption, every (instance of) \( M_r \) stores a flag \( corrupted \in \{false, true\} \) in its state, initially set to false. When \( M_r \) sets the flag to true, it is considered corrupted, and the flag remains true. Whenever the environment sends the message \( (lsid, p, Corrupted?) \) to \( M_r \), \( M_r \) replies with \( (lsid, p, Corrupted, corrupted) \). This allows the environment to know which instances are corrupted. However, the behavior of \( M_r \) when corrupted is left to the definition of \( M_r \). One possible behavior is that when corrupted, \( M_r \) gives complete control to the adversary by forwarding all messages between the environment and the adversary.

#### 3.2 A New Multi-Session Version of Ideal Functionalities

Let \( F \) be any machine, modeling an ideal functionality, with \( n \) pairs of input and output I/O tapes, one for each role, and one pair of input and output network tapes. We define the new multi-session version of \( F \), called the multi-session local-SID (ideal) functionality, denoted by \( F[F] \) or simply \( F \).

A user of \( F \) is identified within \( F \) by the tuple \( (p, lsid, r) \), where \( p \) is a PID, \( r \leq n \) is a role, and \( lsid \) is a local SID, chosen and managed by the party itself. On the tape for role \( r \), \( F \) expects requests to be prefixed by tuples of the form \( (lsid, p) \), and conversely, \( F \) prefixes answers sent on that tape with a tuple of the form \( (lsid, p) \).

A user of \( F \), say \( (p, lsid, r) \), can initiate a session by sending a session-start message of the form \( (lsid, p, Start, m) \), where \( m \) is an optional bit string used to set parameters of the session. For example, in two-party key exchange, a user with PID \( p \) who wants to exchange a key with party \( p' \) could set \( m = (p, p') \). The interpretation of \( m \) is left to \( F \). Upon such a session-start request, \( F \) records this request (if it is the first such request from \( (p, lsid, r) \)) as a local session for user \( (p, lsid, r) \) and forwards this information to the adversary.

The adversary (simulator) determines to which global session local sessions belong by sending a session-create message of the form \( (Create, sid) \) to \( F \), where \( sid = (p_1, lsid_1, 1), \ldots, (p_n, lsid_n, n) \) contains one local session for every role. \( F \) only accepts such a message if it is consistent with the local sessions: the mentioned local sessions all exist, are not corrupted, and are not already part of another global session. If \( F \) accepts such a session-create message, \( F \) internally creates a new instance of \( F \) identifying it by \( sid \). Then, \( F \) sends the message \( (Create, m_1, \ldots, m_n) \) to this instance of \( F \), where, for all \( r \leq n \), \( m_r \) is the optional bit string contained in the session-start message of user \( (p_r, lsid_r, r) \). The adversary can address this instance of \( F \) (via the network interface) by prefixing messages with \( sid \); conversely, messages output by \( F \) on its network interface are prefixed with \( sid \).

For a message \( m \) of a user \( (p, lsid, r) \), which is not a session-start message or a message of the form \( Corrupted? \), \( F \) checks whether \( (p, lsid, r) \) is part of a global session. If not, \( F \) drops \( m \). Otherwise, \( F \) forwards \( m \) to the corresponding instance of \( F \). Conversely, \( F \) forwards all messages from an instance of \( F \) on tape \( r \) to the corresponding user in role \( r \).

Corruption in \( F \) is modeled as follows: the adversary can send a corrupt message of the form \( (Corrupt, (p, lsid, r)) \) for a local session \( (p, lsid, r) \) to \( F \). \( F \) only accepts this message if the local session \( (p, lsid, r) \) is not already part of a global session, and in this case, records \( (p, lsid, r) \) as corrupted. For every corrupted local session, \( F \) forwards all messages from a user of that local session to the adversary (instead of forwarding them to \( F \)) and vice versa. This models that the adversary has full control over corrupted local sessions. Note that once a local session is part of a global session, the local session or its corresponding global session can still be corrupted at any time according to the way corruption is defined in \( F \), which we do not restrict.

Finally, a user may ask \( F \) whether or not a local session was corrupted before being part of a global session by sending the message \( (lsid, p, Corrupted?) \). \( F \) replies accordingly with true or false. This guarantees that the environment is aware of who is corrupted, preventing the simulator from simply corrupting all local sessions. Whether or not a user can ask about the corruption status of \( F \) is completely up to the definition of \( F \), which we do not restrict.

The above definition of a multi-session version of an ideal functionality applies to any ideal functionality \( F \).

Technically, for a real protocol to realize a multi-session local-SID functionality, the simulator must be able to group instances of the simulated real protocol into a global session before interaction with the functionality \( F \) is possible. This means that a real protocol needs to allow for the grouping of instances by whatever mechanism, which is typically intertwined with the rest of the protocol. The grouping is part of the protocol and can now be precisely modeled and analyzed. For example, for authentication, key exchange, and secure channel protocols, being able to tell which instances are grouped together is an essential part of what these protocols guarantee, and different protocols use different mechanisms. Conversely, before there was one fixed mechanism for grouping instances, namely pre-established SIDs. Real protocols needed to ensure they could be grouped according to the SID they obtained, and hence, they had to use the SID in some essential way. Moreover, the SIDs came from outside the protocol, and their establishment was not part of the protocol.

#### 3.3 The Universal Composition Theorem Without Pre-Established SIDs

We now present our universal composition theorem. Let \( P \) be a multi-session protocol using a multi-session local-SID functionality \( F' \), and let \( F \) be a multi-session local-SID functionality. Informally, our theorem states that if \( P | F' \) realizes \( F \) in the single-session setting, then \( P | F' \) realizes \( F \) in the multi-session setting. The important point here is that, by the definition of multi-session local-SID functionalities, no pre-established SIDs (nor their use in the protocol) are required.

To formulate this theorem, we consider a machine \( F_{\text{single}} \) that is placed on top of \( P | F' \) and \( F \), respectively, and that allows an environment to create at most one session, i.e., only one user is allowed per role. An alternative to using \( F_{\text{single}} \) would be to restrict the environment explicitly.

To prove the composition theorem, we need to restrict the class of simulators used to prove that \( P | F' \) realizes \( F \) in the single-session case. For this purpose, we define the following simulation relation: We say that \( P | F' \) single-session realizes \( F \) (denoted by \( F_{\text{single}} | P | F' \leq^* F_{\text{single}} | F \)) if:
1. \( F_{\text{single}} | P | F' \leq F_{\text{single}} | F \), i.e., according to Definition 1, there exists a simulator \( \text{Sim} \) such that for all environments \( E \), it holds that \( E | F_{\text{single}} | P | F' \equiv E | \text{Sim} | F_{\text{single}} | F \).