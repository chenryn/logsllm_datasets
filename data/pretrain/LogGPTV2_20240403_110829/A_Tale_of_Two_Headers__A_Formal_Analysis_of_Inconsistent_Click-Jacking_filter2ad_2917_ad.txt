ward to write an XFO header which enforces exactly the same
restrictions, hence the adoption of a compatibility-oriented
policy is unjustiﬁed. We observe that this was the case for
105 policies (13%), where protection could be improved with
minimal effort and expertise by the Web developers, i.e., with-
out resorting to Referer snifﬁng. This shows that the bleak
picture given above could be easily improved to some extent,
yet this is not happening in practice.
5.3.3 Unduly Inconsistent Policies
Finally, we focus on the 415 inconsistent policies that are
neither security-oriented nor compatibility-oriented. These
policies are hard to justify as secure, or even as intended, as
explained in Section 3. In particular, we observe the following
distribution of (possibly overlapping) classes:
• 315 policies are interpreted differently by at least two
legacy browsers (76%);
• 289 policies are interpreted differently by at least two
modern browsers (69%);
• 29 policies are given the same interpretation by all legacy
browsers and all modern browsers, yet these two inter-
pretations are incomparable (7%).
What is worse is that 380 of these policies (92%) do not
enforce any form of framing restriction on at least one of the
browsers considered in our study, which conﬁrms that this
class of inconsistencies is particularly dangerous for security.
For example, the Web site https://es.sprint.com sets an
XFO header to ALLOW-FROM https://www.sprint.com,
but does not ship a companion CSP: this leaves browsers
without support for ALLOW-FROM unprotected. As another
example, https://whois.web.com sends two XFO headers,
one set to SAMEORIGIN and one set to DENY, which allows
same-origin framing in some browsers but not others.
It is instructive to have a look at why these undue inconsis-
tencies arise. Table 6 provides the breakdown of the main prac-
tices leading to policy inconsistency (classes partially over-
lap). We observe that the ALLOW-FROM directive is present
in most of the unduly inconsistent policies, which shows that
XFO is not properly coupled with CSP in those cases. Indeed,
322 out of 465 policies that use ALLOW-FROM do not come
with any CSP (69%) and do not offer any protection on most
modern browsers. It is also interesting that we found 53 poli-
cies where both XFO and CSP are syntactically correct, yet
express incomparable policies. For example, we noticed that
https://gfp.sd.gov deploys an XFO header set to SAME-
ORIGIN, while its CSP allows framing from every subdomain
of arcgis.com, soundcloud.com and flipsnack.com. We
do not have deﬁnite explanations for this kind of policies,
but a plausible reason could be that XFO was deployed for a
legacy version of the Web site and never updated later.
5.3.4 Perspective
We summarize here the security impact of our ﬁndings by
computing the number of policies that do not offer any level
of protection to at least one browser. We also present the same
perspective for modern browsers alone. The presence and dis-
tribution of vulnerable policies for these two cases are shown
in Table 7. These numbers conﬁrm our claim that not all in-
consistencies are necessarily dangerous, yet their majority
actually is (64%). In particular, almost every inconsistent pol-
icy that is not security-oriented is completely ineffective on
USENIX Association
29th USENIX Security Symposium    691
Inconsistency Class
Security-Oriented
Compatibility-Oriented
Unduly Inconsistent
Aggregate
Vulnerabilities (Any Browser) Vulnerabilities (Modern Browser)
13 (2%)
758 (95%)
380 (92%)
1,151 (64%)
13 (2%)
3 (<1%)
278 (67%)
294 (16%)
Table 7: Presence and distribution of vulnerable policies
at least one browser. Luckily, our experiments also show that
users of modern browsers enjoy a signiﬁcantly higher level
of protection than users of legacy browsers since only 16%
of the inconsistencies actually void any form of security en-
forcement in a modern browser, where undue inconsistencies
are essentially the only threat.
5.4 The Role of Browsers
Since we assess inconsistencies over a set of popular browsers,
one might wonder to which extent the chosen browsers bias
the results of our study. To understand this point, we decided
to run a second analysis by removing Internet Explorer and
Opera Mini from the set of browsers under test. The rationale
of this choice is that these browsers do not support CSP, and
thus, we might get a picture of how much the current policy
deployment would be inconsistent in a world without legacy
browsers. It turns out that the total number of inconsistent
policies would drop from 1,800 to 289, which is a major im-
provement. However, observe that all such policies fall in the
class of unduly inconsistent policies (since we removed legacy
browsers), and we computed that for 278 of them (96%) there
is at least one modern browser which does not enforce any
form of restriction. This conﬁrms that the adoption of modern
browsers strongly mitigates the problem of inconsistencies,
yet not entirely solved. The main reasons for inconsistency
would still be the use of ALLOW-FROM and the adoption of
a comma-separated list of directives in XFO.
It is also particularly interesting that two of the browsers
that we tested have been undergoing major changes at the
time of writing. The ﬁrst signiﬁcant change was implemented
in Firefox, which dropped support for the ALLOW-FROM
directive in version 70.7 Moreover, Microsoft announced that
Edge will move to the Chromium architecture in 2020, which
likely means that it will drop support for ALLOW-FROM and
ﬁx the problems with XFO headers. These changes go in the
direction of reducing the risk of inconsistencies in modern
browsers, which will eventually be uniformed to Chromium
derivates. Unfortunately, we also showed that 322 out of 465
policies that use ALLOW-FROM do not come with any CSP
(69%), which implies that these changes are weakening the
state of click-jacking protection on the Web.
At the end of the day, we believe that the problem of in-
consistencies in click-jacking protection is far from solved.
Though legacy browsers not supporting CSP are likely go-
ing to disappear in a few years, it is hard to predict a precise
temporal horizon for this: for example, Internet Explorer 11
was launched in 2013, and it still has ∼ 2% of the market
share based on publicly available data, while Opera Mini is
still under active development and extremely popular with
around 15% market share in Africa, where mobile trafﬁc is
still expensive.8 Also, it should be noted that the versions
of Edge and Firefox considered in the present study might
still be around for a while, i.e., the Web platform will still be
accessed by browsers supporting ALLOW-FROM at least in
the near future. Though a full transition from XFO to CSP
for click-jacking protection is the way to go to solve the is-
sue of inconsistencies, the setting is complex and requires
actions at different levels. We discuss recommendations and
countermeasures in the next section.
5.5 Limitations
Though we strived to quantify the security impact of the de-
tected policy inconsistencies, we cannot show that even poli-
cies that do not provide any form of framing control in some
browsers lead to exploitable vulnerabilities in practice. To
overcome this limitation, we would need to identify pages
that are susceptible to framing-based attacks. However, iden-
tifying these in an automated fashion at a large scale requires
accounts of all tested sites as well as an in-depth understand-
ing of the application’s semantics. However, we argue that
it is fair to assume that site operators are deploying framing
control for a reason. In our opinion, the widespread adop-
tion of framing control policies (33% of all crawled URLs,
spread across 58% of the sites we looked at) motivates that
click-jacking is perceived as an important security threat. Our
analysis acts as a cautionary tale aimed at raising awareness
of the potential issues that arise from policy inconsistencies.
In addition to this, we also remark that our study specif-
ically focuses on the 10,000 most popular sites at the time
of writing the paper. Given the diversity of the Web in gen-
eral, this does not necessarily enable us to generalize about
framing control inconsistencies on the entire Web. As prior
7https://developer.mozilla.org/en-US/docs/Mozilla/
8https://blogs.opera.com/mobile/2019/08/
Firefox/Releases/70#HTTP
opera-is-leading-the-digital-revolution-in-africa/
692    29th USENIX Security Symposium
USENIX Association
work has shown [24], though, the popularity of domains often
represents a proxy for security measures, meaning that our
results most likely are a lower bound of the actual problems
discoverable in the wild.
6 Recommendations and Countermeasures
Based on the data gathered in our analysis of both browser
implementations and real-world deployment of framing con-
trol, we discuss lessons learned to improve the situation. In
particular, we ﬁrst present recommendations for both Web
developers and browser vendors, highlighting some room for
improvement which we found. We then discuss our implemen-
tation of a server-side proxy capable of retroﬁtting framing
control policies in existing Web applications for the diverse
set of browsers we considered in our analysis.
6.1 Recommendations for Web Developers
The ﬁrst important recommendation we make is that both
XFO and CSP must be used for effective framing control on
the current Web. XFO alone is insufﬁcient for security because
sites might be prone to double framing attacks (also in modern
browsers like UC Browser) or even not protected at all (most
notably, in the presence of the largely unsupported ALLOW-
FROM directive). On the other hand, just using CSP results
in leaving users of legacy browsers completely unprotected.
Unfortunately, we found that only 8% of the collected policies
use both XFO and CSP. Worse, the combination of the two
mechanisms proved hard to get right for Web developers, as
54% of such policies are inconsistent.
The other crucial recommendations are about the use of
XFO. Web developers should ensure that at most one XFO
header is sent with every Web page because existing browsers
have inconsistent interpretations in the presence of multiple
XFO headers. What is worth noting here is that there is no
good practical reason to deploy more than one XFO header.
In the presence of multiple XFO headers, existing browsers
either enforce the ﬁrst one (thus voiding the others) or simul-
taneously enforce all of them. However, even this is useless,
because any pair of XFO directives always contains either re-
dundant or contradictory information, which can be expressed
with a single XFO directive (see Table 8). For the same rea-
sons we just discussed, Web developers should avoid the use
of comma-separated values in XFO headers. These headers
are parsed as multiple XFO headers in most browsers, while in
other browsers, they are interpreted as non-existing directives
that do not enforce any form of framing control. This latter
observation shows that even the apparently innocuous prac-
tice of repeating the same directive multiple times is actually
insecure because it voids protection on some browsers.
6.2 Recommendations for Browser Vendors
Though the frame-ancestors directive obsoleted XFO back
in 2014, XFO is still very popular in the wild: 88% of the poli-
cies we collected are still based on XFO alone. This means
that this is not the right time to drop support for XFO, and
one might wonder if this will ever be possible without leaving
a signiﬁcant fraction of the Web unprotected. An important
point we would like to stress is the need for more informa-
tional messages for Web developers, e.g., in the JavaScript
console. A prime example of this issue comes from the recent
removal of support for ALLOW-FROM in Firefox. When
visiting a page that sends an XFO header containing such a
directive, Firefox merely notes an invalid header and points
the developer to the generic Mozilla Developer Network page
on XFO. This page does note that ALLOW-FROM is now
obsolete and should not be used, but does not provide an imme-
diately visible and explicit warning that sites using ALLOW-
FROM have suddenly become unprotected. As to Chrome,
the JavaScript console only shows a warning about an unrec-
ognized directive and nothing more.
We argue that browsers should explicitly warn Web de-
velopers about the possibility of using CSP to achieve the
same effect of XFO, which is straightforward considered that
CSP is more expressive than XFO. In particular, XFO poli-
cies which do not contain glaring mistakes can be readily
transformed into corresponding CSPs. We designed one such
solution as part of our server-side proxy (see Section 6.3),
which might be inspiring also for browser vendors since the
same approach could be applied at the client. We understand
that major browser vendors might consider such transforma-
tions dangerous for backward compatibility, yet even simple
transformations might signiﬁcantly increase security in the
wild and are worth testing in our opinion. At the very least,
a candidate value for frame-ancestors combined with a
clear warning about the unprotected state of the site should
be reported in the JavaScript console.
On more general terms, we think that our paper shows the
importance of implementing only client-side security mecha-
nisms that come with a clear and precise speciﬁcation. The
XFO speciﬁcation was put together only after major browsers
already implemented support for the XFO header, which led
to many different implementations. Though the auto-update
feature of modern browsers certainly helps in mitigating the
problem of inconsistencies, real-world market share data show
that legacy browsers are hard to eradicate. Once a client-side
security mechanism has been inconsistently implemented
across browsers, it might be challenging to understand its
long-lasting impact in the wild. For example, without moving
away from CSP, the strict-dynamic source expression has
ﬁrst been implemented in Chrome due to an independent ef-
fort from Google’s engineers and then pushed into the CSP
standard. This kind of practice is dangerous because other
browser vendors might be unwilling to pick up: for example,
USENIX Association
29th USENIX Security Symposium    693
Directive 1
SAMEORIGIN
SAMEORIGIN
Directive 2
SAMEORIGIN
ALLOW-FROM o(cid:48)
Conjunction of Directives
SAMEORIGIN
DENY if o (cid:54)= o(cid:48),
SAMEORIGIN otherwise
DENY
ALLOW-FROM o(cid:48) otherwise
DENY
DENY
DENY
SAMEORIGIN
ALLOW-FROM o(cid:48) ALLOW-FROM o(cid:48)(cid:48) DENY if o(cid:48) (cid:54)= o(cid:48)(cid:48),
ALLOW-FROM o(cid:48) DENY
DENY
DENY
Table 8: Simpliﬁcation of multiple XFO directives into a single one (adoption at origin o)
Safari still lacks support for strict-dynamic. This decision,
however, may well be a good one, given that recent work has
shown the dangers of strict-dynamic through script gad-
gets, and even Google engineers now advocate to instead rely
on explicit passing of nonces [13]. Nevertheless, this feature
is inconsistently implemented across browsers already and
unlikely to be removed in the near future.
6.3 Retroﬁtting Security
As Web developers might not be aware of the intricacies
of the two mechanisms available to control the framing of
their sites, we developed a server-side proxy designed to en-
force consistency in framing control policies, i.e., to ensure
all browsers enforce the same level of protection. The proxy
is a Python script (∼ 800 LoC), which can be run at the server.
It inspects the HTTP trafﬁc to automatically ﬁx the framing
control headers so as to ensure policy consistency. To enable
researchers to build on our work and website administrators
to beneﬁt from the tool, we have made the proxy available at
https://github.com/cispa/framing-control-proxy.
In particular, for any request r, let r stand for the corre-
sponding HTTP response. If r contains XFO headers, but no
CSP header with a frame-ancestors directive, the proxy