Figure 84 
The ransom note is also stored in an encrypted form as a stack string that will be decrypted using 
a custom algorithm: 
Figure 85 
www.LIFARS.com |  23 
Figure 86 
The process creates a registry key called "HKCU\SOFTWARE\2ED873D4E5389C" (0x80000001 = 
HKEY_CURRENT_USER , 0xF003F = KEY_ALL_ACCESS): 
Figure 87 
LockBit is looking for two registry values called “Private” and “Public” under the registry key 
above, which don’t exist at this time: 
Figure 88 
Figure 89 
The malware sends the "[+] Generate session keys" message to the hidden window. It will 
compute a public ECC (Curve25519) key and a private ECC (Curve25519) key. 
The file generates 32 random bytes via a function call to BcryptGenRandom: 
www.LIFARS.com |  24 
Figure 90 
The malicious process implements a Curve25519 wrapper in the sub_4300C0 function. Based on 
the above buffer, it generates a session ECC public key: 
Figure 91 
The above operation of generating random bytes is repeated one more time: 
Figure 92 
www.LIFARS.com |  25 
The same Curve25519 wrapper is used again to transform the above buffer: 
Figure 93 
The executable embedded an ECC public key that we call Master ECC public key (highlighted in 
figure 94). Based on the implementation of the Curve25519 algorithm, it is used to generate a 
shared secret (32-byte value): 
Figure 94 
The Master ECC public key is utilized to encrypt the session ECC private key computed above: 
Figure 95 
We have utilized the capa tool in order to confirm that the above function is used to encrypt data 
using Curve25519: 
Figure 96 
www.LIFARS.com |  26 
LockBit 
stores 
the 
encrypted 
session 
ECC 
private 
key 
in 
the 
“HKCU\Software\2ED873D4E5389C\Private” registry value: 
Figure 97 
LockBit stores the session ECC public key in the “HKCU\Software\2ED873D4E5389C\Public” 
registry value: 
Figure 98 
Figure 99 reveals both registry values with their content: 
Figure 99 
The malware uses I/O completion ports to improve the encryption speed. It creates an I/O 
completion 
object 
by 
calling 
the 
NtCreateIoCompletion 
API 
(0x1F0003 
= 
IO_COMPLETION_ALL_ACCESS): 
Figure 100 
The binary creates 2 (# of processors/cores) that will handle the files encryption: 
www.LIFARS.com |  27 
Figure 101 
The thread affinity mask is set to 1 via a function call to ZwSetInformationThread (0x4 = 
ThreadAffinityMask): 
Figure 102 
GetLogicalDrives is used to retrieve the available disk drives: 
Figure 103 
The malicious binary determines the disk drive type using the GetDriveTypeW routine: 
Figure 104 
The process is looking for type 2 (DRIVE_REMOVABLE), type 3 (DRIVE_FIXED) and type 6 
(DRIVE_RAMDISK) drives: 
www.LIFARS.com |  28 
Figure 105 
For each targeted drive, the malware creates a new thread that will traverse it and locate all files 
selected for encryption: 
Figure 106 
Thread activity – sub_45C960 function 
The file compares the drive name with the tsclient (Terminal Server Client) share: 
Figure 107 
The CreateFileW function is utilized to create a file called “2ED873D4.lock” (0xC0000000 = 
GENERIC_READ 
| 
GENERIC_WRITE, 
0x1 
= 
CREATE_NEW, 
0x04000100 
= 
FILE_FLAG_DELETE_ON_CLOSE | FILE_ATTRIBUTE_TEMPORARY): 
www.LIFARS.com |  29 
Figure 108 
SHEmptyRecycleBinW 
is 
used 
to 
empty 
the 
Recycle 
Bin 
on 
the 
drive 
(0x7 
= 
SHERB_NOCONFIRMATION | SHERB_NOPROGRESSUI | SHERB_NOSOUND): 
Figure 109 
The executable retrieves information about the total amount of space and the total amount of 
free space on the drive by calling the GetDiskFreeSpaceW and GetDiskFreeSpaceExW APIs: 
Figure 110 
Figure 111 
The user interface language for the current thread is set to “English - United States”: 
Figure 112 
The numeric values extracted above are converted into a string that represents the size values in 
bytes, kilobytes, megabytes, or gigabytes, depending on their size: 
www.LIFARS.com |  30 
Figure 113 
The drive name and the information regarding its size are sent to the hidden window via 
SendMessageW. 
The FindFirstFileExW API is utilized to enumerate the drive: 
Figure 114 
The following directories will be skipped: 
• 
system volume information 
• 
windows photo viewer 
• 
windows powershell 
• 
internet explorer 
• 
windows security 
• 
windows defender 
• 
microsoft shared 
• 
application data 
• 
windows journal 
• 
$recycle.bin 
• 
$windows~bt 
• 
windows.old 
The files enumeration is continued via a function call to FindNextFileW: 
www.LIFARS.com |  31 
Figure 115 
File extensions are extracted using the PathFindExtensionW routine: 
Figure 116 
The binary is looking for a “.lockbit” file that would suggest the targeted file has already been 
encrypted: 
Figure 117 
ZwCreateFile is utilized to open the targeted file (0x10003 = 
FILE_READ_DATA | 
FILE_WRITE_DATA | DELETE, 0x80 = FILE_ATTRIBUTE_NORMAL, 0x1 = FILE_OPEN, 0x48 = 
FILE_NON_DIRECTORY_FILE | FILE_NO_INTERMEDIATE_BUFFERING): 
Figure 118 
The targeted file is bound to the I/O completion port created earlier via a function call to 
NtSetInformationFile (0x1E = FileCompletionInformation): 
www.LIFARS.com |  32 
Figure 119 
The 
NtQueryInformationFile 
routine 
is 
used 
to 
query 
file 
information 
(0x5 
= 
FileStandardInformation): 
Figure 120 
NtSetInformationFile 
is 
utilized 
to 
set 
end-of-file 
information 
for 
the 
file 
(0x14 
= 
FileEndOfFileInformation): 
Figure 121 
The following extensions list has been found: 
• 
".rar" ".zip" ".ckp" ".db3" ".dbf" ".dbc" ".dbs" ".dbt" ".dbv" ".frm" ".mdf"  
• 
".mrg" ".mwb" ".myd" ".ndf" ".qry" ".sdb" ".sdf" ".sql" ".tmd" ".wdb" ".bz2"  
• 
".tgz" ".lzo" ".db" ".7z" ".sqlite" ".accdb" ".sqlite3" ".sqlitedb" ".db-shm"  
• 
".db-wal" ".dacpac" ".zipx" ".lzma" 
LockBit only encrypts the first 4KB of the file. It uses the ZwReadFile API in order to read 0x1000 
(4096) bytes: 
www.LIFARS.com |  33 
Figure 122 
The GetFileAttributesW function is used to get file system attributes for the ransom note called 
“Restore-My-Files.txt”: 
Figure 123 
The ransomware creates the ransom note via a call to ZwCreateFile (0x10003 = FILE_READ_DATA 
| FILE_WRITE_DATA | DELETE, 0x80 = FILE_ATTRIBUTE_NORMAL, 0x2 = FILE_CREATE, 0x40 = 
FILE_NON_DIRECTORY_FILE): 
Figure 124 
The ransom note is bound to the I/O completion port previously created via a function call to 
NtSetInformationFile (0x1E = FileCompletionInformation): 
Figure 125 
www.LIFARS.com |  34 
The note is populated using the ZwWriteFile routine: 
Figure 126 
The “.lock” file created earlier is deleted after the drive enumeration is complete: 
Figure 127 
The content of the ransom note is displayed below: 
Figure 128 
The main thread sends the "Scan done, waiting handles…" message to the hidden window. 
Thread activity – sub_497060 function 
The malware retrieves the locally unique identifier (LUID) for the SeDebugPrivilege privilege 
using the LookupPrivilegeValueA routine: 
Figure 129 
The privileges of the access token are adjusted to include the SeDebugPrivilege privilege via a 
function call to ZwAdjustPrivilegesToken: 
www.LIFARS.com |  35 
Figure 130 
OpenSCManagerA is used to establish a connection to the service control manager and to open 
the service control manager database (0xF003F = SC_MANAGER_ALL_ACCESS): 
Figure 131 
A 
targeted 
service 
is 
opened 
using 
the 
OpenServiceA 
API 
(0x2c 
= 
SC_MANAGER_MODIFY_BOOT_CONFIG 
| 
SC_MANAGER_LOCK 
| 
SC_MANAGER_ENUMERATE_SERVICE): 
Figure 132 
QueryServiceStatusEx is used to extract the current status of the service: 
Figure 133 
The EnumDependentServicesA routine is utilized to retrieve the name and status of each service 
that depends on the targeted service (see figure 134). These services will be stopped as well (0x1 
= SERVICE_ACTIVE): 
Figure 134 
www.LIFARS.com |  36 
Every 
chosen 
service 
is 
stopped 
by 
calling 
the 
ControlService 
function 
(0x1 
= 
SERVICE_CONTROL_STOP): 
Figure 135 
A confirmation message that the service was successfully stopped is sent to the hidden window: 
Figure 136 
The ransomware takes a snapshot of all processes in the system (0x2 = TH32CS_SNAPPROCESS): 
Figure 137 
The malicious file retrieves information about the first process from the snapshot via a function 
call to Process32First: 
Figure 138 
Interestingly, the malware removes the extension of the process name (if present) before the 
comparison with the targeted list: 
Figure 139 
An example of such a comparison is shown in figure 140. 
www.LIFARS.com |  37 
Figure 140 
The process enumeration continues by calling the Process32Next routine: 
Figure 141 
OpenProcess is used to open a targeted process (0x1FFFFF = PROCESS_ALL_ACCESS): 
Figure 142 
A process is killed by calling the NtTerminateProcess API: 
Figure 143 
LockBit initializes the COM library for apartment threading using the CoInitializeEx function (0x6 
= COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE): 
Figure 144 
The ransomware deletes all volume shadow copies on the system by calling the ShellExecuteEx 
function and running the commands shown below: 
Figure 145 
www.LIFARS.com |  38 
Figure 146 
The malware also creates multiple processes twice in order to delete (again) all shadow copies 
and Windows logs. An example of process creation is shown in figure 147 (0x08000000 = 
CREATE_NO_WINDOW): 
Figure 147 
The following processes have been spawned: 
• 
cmd.exe /c vssadmin Delete Shadows /All /Quiet – delete all shadow copies 
• 
cmd.exe /c bcdedit /set {default} recoveryenabled No – disable automatic repair 
• 
cmd.exe c bcdedit set {default} bootstatuspolicy ignoreallfailures – ignore errors in the 
case of a failed boot / shutdown / checkpoint 
• 
cmd.exe /c wmic SHADOWCOPY /nointeractive – invalid syntax 
• 
cmd.exe /c wevtutil cl security – clear security log 
• 
cmd.exe /c wevtutil cl system – clear system log 
• 
cmd.exe /c wevtutil cl application – clear application log 
The ransomware forwards the "Volume Shadow Copy & Event log clean" message to the hidden 
window: 
Figure 148 
www.LIFARS.com |  39 
Thread activity – sub_49E730 function 
The NtRemoveIoCompletion function is utilized to wait for at least a file to be available for 
encryption: 
Figure 149 
The following file extensions will be skipped: 
• 
.386 .cmd .ani .adv .msi .msp .com .nls .ocx .mpa .cpl .mod .hta  
• 
.prf .rtp .rdp .bin .hlp .shs .drv .wpx .bat .rom .msc .spl .msu  
• 
.ics .key .exe .dll .lnk .ico .hlp .sys .drv .cur .idx .ini .reg  
• 
.mp3 .mp4 .apk .ttf .otf .fon .fnt .dmp .tmp .pif .wav .wma .dmg  
• 
.iso .app .ipa .xex .wad .msu .icns .lock .lockbit .theme .diagcfg  
• 
.diagcab .diagpkg .msstyles .gadget .woff .part .sfcache .winmd  
The files that can be found in the following directories will not be encrypted: 
• 
"$windows.~bt" "intel"  "$recycle.bin"  "to.msstyles"  "boot"  "msbuild"  "system volume 
information"   
• 
"google"  "application data"  "windows"  "windows.old"  "appdata"  "mozilla"   "microsoft 
shared"  "internet explorer"   
• 
"opera"  "windows journal"  "windows defender" "windowspowershell" "windows security"  
"windows photo viewer"  
The following specific files will also be skipped: 
• 
"iconcache.db" "ntuser.dat.log" "restore-my-files.txt" "autorun.inf" "bootsect.bak" 
"thumbs.db"  
LockBit uses multiple aeskeygenassist operations in order to assist in AES round key generation, 
as we can see below: 
www.LIFARS.com |  40 
Figure 150 
Figure 151 
The file content is encrypted using the AES128 algorithm. Basically, the malware uses aesenc 
instructions to perform one round of an AES encryption flow: 
Figure 152 
www.LIFARS.com |  41 