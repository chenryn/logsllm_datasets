malware.
6.4 Flashing the malware into program
memory
Once the fake stack is injected in the data memory, the
malware needs to be copied in ﬂash memory. As explained
previously, this can be achieved using the Reprogramming
meta-gadget described in Section 6.2. This reprogramming
task can be triggered by a small specially-crafted packet that
overwrites the saved return address of the function with the
address of the Reprogramming meta-gadget. This packet
also needs to inject into the stack the address of the fake
stack and the address of the Gadget2 of the Reprogramming
meta-gadget. The payload of the reprogramming packet is
shown in Figure 5. At the reception of this packet, the tar-
get sensor executes the Reprogramming meta-gadget. The
malware, that is part of the fake stack, is then ﬂashed into
the sensor program memory. When the meta-gadget termi-
nates it returns to the address of the malware, which is then
executed.
6.5 Finalizing the malware installation
Once the malware is injected in the program memory it
must eventually be executed. If the malware is installed at
address 0 it will be executed at each reboot. However, in
this case, the original application would not work anymore
and the infection would easily be noticeable. This is often
not desirable. If the malware is installed in a free area of
program memory, it can be activated by a buﬀer overﬂow
exploit. This option can be used by the attacker to activate
the malware when needed.
This approach has at least two advantages:
• The application will run normally, thereby reducing
chance of detection.
typedef struct {
load r29;
load r28;
load r9;
load r8;
load r7;
load r6;
load r5;
load r4;
load r3;
load r2;
load r17;
load r16;
load r15;
load r14;
load r13;
load r12;
load r11;
load r10;
// To be used by bottom half of gadget 2
// the Frame pointer value 16 bits
uint8 t
uint8 t
// 4 bytes loaded with the address in program
// memory encoded as a uint32 t
uint8 t
uint8 t
uint8 t
uint8 t
// 4 padding values
uint8 t
uint8 t
uint8 t
uint8 t
// Number of pages to write as a uint32 t
// must be set to 0, in order to exit loop
uint8 t
uint8 t
uint8 t
uint8 t
// 4 padding bytes
uint8 t
uint8 t
uint8 t
uint8 t
// address of gadget 3
uint16 t retAddr execFunction;
// bootloader’s fake function frame starts here,
// frame pointer must points here
// 8 padding bytes
uint16 t wordBuf;
uint16 t verify image addr;
uint16 t crcTmp;
uint16 t intAddr;
// buﬀer to data page to write to memory
uint8 t malware buﬀ[256];
// pointer to malware buﬀ
uint16 t buﬀ p;
// 18 padding bytes
uint8 t r29;
uint8 t r28;
uint8 t r17;
uint8 t r16;
uint8 t r15;
uint8 t r14;
uint8 t r13;
uint8 t r12;
uint8 t r11;
uint8 t r10;
uint8 t r9;
uint8 t r8;
uint8 t r7;
uint8 t r6;
uint8 t r5;
uint8 t r4;
uint8 t r3;
uint8 t r2;
// set to the address of the malware or 0 to reboot
uint16 t retAddr;
} fake stack t;
Figure 7: Structure used to build the fake stack.
The total size is 305 bytes out of which up to
256 bytes are used for the malware, 16 for the
meta-gadget parameters. The remaining bytes are
padding, that do not need to be injected.
• The malware can use some of the existing functions of
the application. This reduces the size of the code to
inject.
If the malware needs to be executed periodically or upon
the execution of an internal event it can modify the sen-
sor application in order to insert a hook. This hook can
be installed in a function called by a timer. The malware
will be executed each time the timer ﬁres. This operation
needs to modify the local code (in order to add the hook in
the function). The same fake stack technique presented in
Section 6.3 is used to locally reprogram the page with the
modiﬁed code that contains the hook. The only diﬀerence
is that, instead of loading the malicious code into the fake
stack, the attacker loads the page containing the function to
modify, adds the hook in it, and calls the Reprogramming
meta-gadget.
Note that once the malware is installed it should patch the
exploited vulnerability (in the reception function) to prevent
over-infection.
6.6 Turning the malware into a worm
The previous section has explained how to remotely inject
a malware into a sensor node.
It was assumed that this
injection was achieved by an attacker. However the injected
malware can self-propagate, i.e. be converted into a worm.
The main idea is that once the malware is installed it per-
forms the attack described in Section 6 to all of its neighbors.
It builds a fake stack that contains its own code and injects
it byte-by-byte into its neighbors as explained previously.
The main diﬀerence is that the injected code must not only
contain the malware but also the self-propagating code, i.e.
the code that builds the fake stack and sends the specially-
crafted packets. The injected code is likely to be larger. The
main limitation of the injection technique presented in Sec-
tion 6 is that it can only be used to inject one page (i.e.
256 bytes) of code. If the malware is larger than one page
it needs to be split it into pieces of 256 bytes which should
be injected separately. We were able to implement, in our
experiments, a self-propagating worm that contains all this
functionality in about 1 KByte.
Furthermore, because of the packet size limitation and
the overhead introduced by the byte-injection gadget, only
one byte of the fake stack can be injected per packet. This
results in the transmission of many malicious packets. One
alternative would be to inject an optimal gadget and then
use it to inject the fake stack several bytes at a time. Since
this gadget would be optimized it would have less overhead
and more bytes would be available to inject useful data. This
technique could reduce the number of required packets by a
factor of 10 to 20.
7. POSSIBLE COUNTER-MEASURES
Our attack combines diﬀerent techniques in order to achieve
its goal (code injection). It ﬁrst uses a software vulnerability
in order to perform a buﬀer overﬂow that smashes the stack.
It then injects data, via the execution of gadgets, into the
program memory that is persistent across reboots.
Any solutions that could prevent or complicate any of
these operations could be useful to mitigate our attack. How-
ever, as we will see, all existing solutions have limitations.
// function declaration with proper attributes
void
cleanup memory (void)
attribute
attribute
((naked))
((section (”.init8”)))
@spontaneous() @C();
void
// bss end symbol is provided by the linker
extern volatile void∗ bss end;
cleanup memory(void){
uint8 t ∗dest = & bss end;
uint16 t count=RAMEND − (uint16 t)& bss end;
while (count−−) ∗dest++ = 0;
}
Figure 8: A memory cleanup procedure for TinyOS.
The attribute keyword indicates that this function
should be called during the system initialisation.
Software vulnerability Protection.
Safe TinyOS [5] provides protection against buﬀer over-
ﬂow. Safe TinyOS adds new keywords to the language that
give the programmer the ability to specify the length of an
array. This information is used by the compiler to enforce
memory boundary checks. This solution is useful in prevent-
ing some errors. However, since the code still needs to be
manually instrumented, human errors are possible and this
solution is therefore not foolproof. Furthermore, software
vulnerabilities other than buﬀer overﬂows can be exploited
to gain control of the stack.
Stack-smashing protection.
Stack protections, such as random canaries, are widely
used to secure operating systems [6]. They are usually im-
plemented in the compiler with operating system support.
These solutions prevent return address overwriting. How-
ever, the implementation on a sensor of such techniques
is challenging because of their hardware and software con-
straints. No implementation currently exists for AVR mi-
crocontrollers.
Data injection protection.
A simple solution to protect against our data injection
across reboots is to re-initialize the whole data memory each
time a node reboots. This could be performed by a simple
piece of code as the one shown in the Figure 8. Cleaning
up the memory would prevent storing data across reboots
for future use. This solution comes with a slight overhead.
Furthermore it does not stop attacks which are not relying
on reboots to restore clean state of the sensor as proposed
in [12]. It is likely that our proposed attack can use similar
state restoration mechanisms. In this case such a counter-
measure would have no eﬀect.
Furthermore our attack is quite generic and does not make
any assumptions about the exploited applications. However,
it is plausible that some applications do actually store in
memory data for their own usage (for example an application
might store in memory a buﬀer of data to be sent to the
sink). If such a feature exists it could be exploited in order
to store the fake stack without having to use the Injection
meta-gadget. In this case, only the Reprogramming meta-
gadget would be needed and the presented defense would be
ineﬀective.
Gadget execution protection.
ASLR (Address Space Layout Randomization) [26] is a
solution that randomizes the binary code location in mem-
ory in order to protect against return-into-libc attacks. Since
sensor nodes usually contain only one monolithic program in
memory and the memory space is very small, ASLR would
not be eﬀective.
[16] proposes to improve ASLR by ran-
domising the binary code itself. This scheme would be adapt-
able to wireless sensors. However, since a sensor’s address
space is very limited it would still be vulnerable to brute
force attacks [24].
8. CONCLUSIONS AND FUTURE WORK
This paper describes how an attacker can take control of a
wireless sensor network. This attack can be used to silently
eavesdrop on the data that is being sent by a sensor, to
modify its conﬁguration, or to turn a network into a botnet.
The main contribution of our work is to prove the feasibil-
ity of permanent code injection into Harvard architecture-
based sensors. Our attack combines several techniques, such
as fake frame injection and return-oriented programming, in
order to overcome all the barriers resulting from sensor’s ar-
chitecture and hardware. We also describe how to transform
our attack into a worm, i.e., how to make the injected code
self-replicating.
Even though packet authentication, and cryptography in
general, can make code injection more diﬃcult, it does not
prevent it completely.
If the exploited vulnerability is lo-
cated before the authentication phase, the attack can pro-
ceed simply as described in this paper. Otherwise, the at-
tacker has to corrupt one of the network nodes and use its
keys to propagate the malware to its neighbors. Once the
neighbors are infected they will infect their own neighbors.
After few rounds the whole network will be compromised.
Future work consists of evaluating how the worm prop-
agates on a large scale deployment. We are, for example,
interested in evaluating the potential damage when infec-
tion packets are lost, as this could lead to the injection of
an incomplete image of the malware. Future work will also
explore code injection optimizations and eﬃcient counter-
measures.
9. ACKNOWLEDGMENTS
The authors would like to thank Gene Tsudik, John Solis,
Karim El Defrawy and the members of the INRIA PLAN-
ETE team for their helpful feedback and editorial sugges-
tions. We are also grateful for the comments from the anony-
mous reviewers.
The work presented in this paper was supported in part by
the European Commission within the STREP UbiSec&Sens
project. The views and conclusions contained herein are
those of the authors and should not be interpreted as repre-
senting the oﬃcial policies or endorsement of the UbiSec&Sens
project or the European Commission.
10. REFERENCES
[1] Aleph One. Smashing the stack for fun and proﬁt.
Phrack Magazine 49(14), 1996.
http://www.phrack.org/issues.html?issue=49.
[2] AMD. AMD 64 and Enhanced Virus Protection.
[3] ATMEL. Atmega128(l) datasheet, doc2467: 8-bit
[17] D. H. Kim, R. Gandhi, and P. Narasimhan. Exploring
microcontroller with 128k bytes in-system
programmable ﬂash.
symmetric cryptography for secure network
reprogramming. ICDCSW, 2007.
[4] K. Chang and K. Shin. Distributed authentication of
[18] I. Krontiris and T. Dimitriou. Authenticated
program integrity veriﬁcation in wireless sensor
networks. ACM TISSEC, 11(3), 2008.
[5] N. Cooprider, W. Archer, E. Eide, D. Gay, and
J. Regehr. Eﬃcient memory safety for tinyos. In
SenSys, 2007.
in-network programming for wireless sensor networks.
In ADHOC-NOW, 2006.
[19] P. Lanigan, R. Gandhi, and P. Narasimhan. Sluice:
Secure dissemination of code updates in sensor
networks. ICDCS, 2006.
[6] C. Cowan, C. Pu, D. Maier, H. Hintony, J. Walpole,
[20] G. Montenegro, N. Kushalnagar, J. Hui, and
P. Bakke, S. Beattie, A. Grier, P. Wagle, and
Q. Zhang. Stackguard: automatic adaptive detection
and prevention of buﬀer-overﬂow attacks. In USENIX
Security Symposium, 1998.
[7] Crossbow technology inc. Micaz.
[8] T. DeRaadt. Advances in OpenBSD. In CanSecWest,
2003.
[9] P. Dutta, J. Hui, D. Chu, and D. Culler. Securing the
deluge network programming system. IPSN, 2006.
[10] T. Goodspeed. Exploiting wireless sensor networks
over 802.15.4. In ToorCon 9, San Diego, 2007.
[11] T. Goodspeed. Exploiting wireless sensor networks
over 802.15.4. In Texas Instruments Developper
Conference, 2008.
[12] Q. Gu and R. Noorani. Towards self-propagate
D. Culler. Transmission of ipv6 packets over ieee
802.15.4 networks (rfc 4944). Technical report, IETF,
September 2007.
[21] Riley, Jiang, and Xu. An architectural approach to
preventing code injection attacks. dsn, 2007.
[22] A. Seshadri, A. Perrig, L. van Doorn, and P. K.
Khosla. Swatt: Software-based attestation for
embedded devices. In IEEE S&P, 2004.
[23] H. Shacham. The geometry of innocent ﬂesh on the
bone: return-into-libc without function calls (on the
x86). In CCS. ACM, 2007.
[24] H. Shacham, M. Page, B. Pfaﬀ, E.-J. Goh,
N. Modadugu, and D. Boneh. On the eﬀectiveness of
address-space randomization. In CCS. ACM, 2004.
[25] Solar Designer. return-to-libc attack. Bugtraq mailing
mal-packets in sensor networks. In WiSec. ACM, 2008.
list, August 1997.
[13] J. A. Halderman, S. D. Schoen, N. Heninger,
W. Clarkson, W. Paul, J. A. Calandrino, A. J.
Feldman, J. Appelbaum, and E. W. Felten. Least we
remember: Cold boot attacks on encryption keys. In
USENIX Security Symposium, 2008.
[14] J. W. Hui and D. Culler. The dynamic behavior of a
data dissemination protocol for network programming
at scale. In SenSys. ACM, 2004.
[15] IEEE. Wireless medium access control and physical
layer speciﬁcations for low-rate wireless personal area
networks. IEEE Standard, 802.15.4-2003.
[16] C. Kil, J. Jun, C. Bookholt, J. Xu, and P. Ning.
Address space layout permutation (aslp): Towards
ﬁne-grained randomization of commodity software. In
ACSAC, 2006.
[26] The PaX Team. Pax address space layout
randomization (aslr).
http://pax.grsecurity.net/docs/aslr.txt.
[27] The PaX Team. Pax, 2003. http://pax.grsecurity.net.
[28] B. L. Titzer, D. K. Lee, and J. Palsberg. Avrora:
scalable sensor network simulation with precise
timing. In IPSN, 2005.
[29] Ubisec&sens european project.
http://www.ist-ubisecsens.org/.