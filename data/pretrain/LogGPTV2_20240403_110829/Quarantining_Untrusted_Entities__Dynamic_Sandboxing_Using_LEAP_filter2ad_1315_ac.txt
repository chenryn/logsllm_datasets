implemented an access matrix based enforcement engine
called KernelSec Domains in the Linux Operating System
using Linux Security Modules [48].
3The permissions themselves are stateless, the only state in the high-
level speciﬁcation are the group memberships.
KernelSec domains are
produced
automatically
from a LEAP speciﬁcation
via a algorithm we call
factoring [23]. KernelSec
Domains are designed to
work tightly with LEAP. In
particular, group deﬁnition,
labels, users, and aspects
are essentially identical
in
KernelSec domains as in
LEAP. An overview of our
system is shown in Figure 3.
3.1. KernelSec issues
LEAP
factoring
KernelSec Domains
Figure 3. Factor-
ing LEAP speciﬁ-
cations into Ker-
nelSec domain
Space restrictions preclude a full discussion of the Ker-
nelSec mechanisms. We note here only a few relevant is-
sues.
3.1.1 Aspects
KernelSec has implicit permissions based on aspects which
are extensions of POSIX implicit permissions. For exam-
ple, in POSIX, sending a signal from process p1 to p2 re-
quires that both processes have the same UID (or that the
sender is root). In KernelSec, it requires that p1’s aspect is
greater than or equal to p2’s which reﬁnes the POSIX rules.
(This rule applies not only to signals, but to all communi-
cation between processes which POSIX requires to be on
behalf of the same user.) Hence a sandboxed process op-
erating at a minimum aspect can only send signals to other
processes that share its sandbox (and hence its aspect).
3.1.2 System calls
Only one KernelSec speciﬁc system calls (calls from the
process to the operating system) is need to support the sand-
box semantics.
(The remaining semantics are part of the
KernelSec domains.)
A process performs a relabel on an object, by invoking
the syscall:
relabel(objectName obj, label l)
which relabels an object obj to l. For this call to be al-
lowed, assuming that before the call obj’s label is l0, the
domain must have the permission relabel(l0, l).
3.1.3 Domains
In KernelSec, domains specify the privileges currently as-
sociated with a process.
In addition, KernelSec domains
can specify actions to occur on the exercise of a permission,
which is used to change privileges when reading a MAIL ﬁle
(thus implementing dynamic information ﬂow restrictions)
and to use a minimal aspect when sandboxing a process.
Description
minimum viewer read
minimum viewer invocation
client and minimum viewer invocations
(in clock ticks)
Unix KernelSec Overhead
14.58%
7,017
3.46%
1,115,830
2,272,270
3.21%
8,040
1,154,400
2,345,240
Table 1. Elapse times (in clock ticks).
3.2. Performance
In this section we present the performance results of
executing some micro-benchmarks using the domains de-
scribed in the previous section. We have begun porting
X11 applications to KernelSec. So far these include xpdf,
bash (the bourne again shell), and thunderbird. These
constitute substantially all of the functionality for executa-
bles described here. The performance overhead of Ker-
nelSec is negligible for these applications, so we report only
micro-benchmarks (for which performance can be seen).
We measure the performance of very small executables,
a minimum viewer (corresponding to a PDF viewer) and a
client application (corresponding to a MUA). Because the
executables are small, the overheads are noticeable vs. the
insigniﬁcant one on the PDF viewer and MUA.
We measured the elapse times for the following opera-
tions:
Jailing minimum viewer on read: This
transition hap-
pens on the read operation and involves an aspect re-
duction followed by a domain transition. Since we
only measure the elapse time, and the switch happens
in the kernel as part of the read operation, the time
measured here also includes the time taken to perform
the actual read (of 1K bytes).
minimum viewer invocation: Performs a fork-exec of the
minimum viewer. This requires a domain transition
and various inode permission checks for exec and read-
ing ﬁles as well as transiting directories. All the Ker-
nelSec security checks happen on the exec operation,
the fork does not require any permissions.
client application and minimum viewer invocations:
This starts from the shell and does fork-exec of the
client application followed by a fork-exec of the
minimum viewer. This is essentialy twice the work
of the minimum viewer invocation and also, not
surprisingly takes twice the time.
We did not measure the scrubber or certiﬁer overhead, as
these will be essentially the same as the minim viewer invo-
cation. The measurements taken therefore reﬂect the entire
sandboxing mechanism described in the previous section.
The overhead is fairly modest even in the microbench-
mark, a few percent for the larger operations; even the min-
imum viewer read, which reads 1000 bytes and, in the ker-
nelSec case switches domains is modest at 14.58%. When
compared to executing xpdf on this paper, about .2 seconds
or 400,000,000 ticks, the increased overhead of 40,000 ticks
is insigniﬁcant.
4. Related Work
Sandboxing is a form of isolation. The work on isola-
tion can be viewed as taking place in two parts:
the iso-
lation of execution environments and the isolation of data
(also called information ﬂow). We also address the use of
dynamic mechanisms in authorization models.
Isolation The isolation of execution environments occurs
through address space separation and restricted interfaces
for interacting with the external world. Virtual Machines
(VMs), such as Xen [14], VMware [46] and UML [13],
provide highly isolated environments in which applications
running on different VMs are (ideally) as well isolated as
if the applications were running on different hardware. For
example, such techniques have been used to create a We-
bOS [12]. Thus attacks on VMed applications are limited
to attacks through the network. But VMs are coarse grained,
and the controlled sharing of resources static [36].
Finer grain techniques can either be implemented en-
tirely inside the kernel or via system call interposition. Sys-
tem call interposition techniques [20, 22, 29, 32, 18] are or-
thogonal to the access control model and have been used
to create sandboxes, perform intrusion detection, prevent
harmful side-effects of untrusted code, or selectively elevate
privileges. Such techniques have also been used to prevent
process-subversion attacks which exploit system vulnera-
bilities [25, 28].
In general, kernel-based mechanism are
more efﬁcient while system call interposition mechanisms
are easier to implement and are more extensible.
Sandboxing provides protection at the process (process
group) granularity.
In contrast to VMs, these sandboxes
exist within an operating system, and are designed to re-
strict the address space and interaction of sandboxed ap-
plications (consisting of one or more processes) with the
rest of the system. Sandboxing can (typically) communicate
via networking and, unlike VMs, are asymmetric in that a
sandboxed process has very limited visibility or effect out-
side the sandbox while non-sandboxed processes can access
sandboxed processes (e.g., via signals) and ﬁles.
The earliest OS-based sandboxing technique appears to
be TRON [6], which supports both traditional Unix access
controls and TRON capabilities; an operation is allowed
only if the process has both of the corresponding TRON and
Unix permissions. Tron operates by system call wrappers,
which is entered by discretion, and controls ﬁle access.
Another early sandboxing technique is Janus [20]. Janus
seeks to contain helper applications to browser and mail
user agents using a mailcap ﬁle to initiate these helper ap-
plications. Janus uses system call interposition, is explic-
itly invoked from user space, and enables modules to deﬁne
ﬁle, network, and interprocess communication. MAPbox
[1], built on top of Janus, adds more classes of conﬁnement
mechanisms, essentially replacing Janus’s programmable
module framework with a ﬁxed set of modules. Peterson et
al. [31] has a hybrid sandboxing mechanism using kernel-
level enforcement while relying on the parent process to
conﬁne the child.
WindowBox [3] creates permanent sandboxes which
were associated with workspaces. Each workspace could
have a different set of privileges, and one workspace could
operate on all the others (the one-way property). Window-
Box attenuates privileges by access tokens (containing cre-
dentials) and access control lists; it has been implemented
in the Windows OS kernel.
AppArmor [11] is a sandboxing technique designed to
better protect servers. It implements a notion of sub-process
protections, based on reducing the privileges during execu-
tion of certain code of the process. EVM/SLIM provide ﬁle
integrity mechanisms and are integrated on top of a TPM
mechanism [35]. AppArmor, EVM/SLIM, and KernelSec
domains are all implemented on top of LSM.
Ostia is a system call interposition delegation-based
sandbox in which the most sensitive system calls, rather
than being performed by the application, are delegated to
a user space process [19].
Recursive sandboxes provides privilege attenuation in
the child processes based on calls that the parent makes
[27], thus enabling a process to voluntarily give up privi-
leges.
BSD jails [24] are a sandboxing technique which is clos-
est to VMs. The BSD jails are each allocated their own IP
number, and the visibility from the jail to the outside world
is severely restricted. BSD jails are explicitly invoked from
user space, and provide very little visibility outside the jail.
Many of the sandboxing techniques include resource
limits; these are used to prevent denial of service attacks.
While these are not currently included in LEAP, it would be
trivial to add them.
Another OS-based isolation mechanism is Type Enforce-
ment (TE) [8, 39, 47, 2], based on the access matrix, in
which the privileges are based on the domain of the process.
To support least privilege, it is necessary that monolithic
applications either be broken up into separate processes for
privilege separation to enable the OS to control accesses
[33] (e.g., qmail4, PrivTrans [9], Data Sandboxing [26] or
OKWS [15]) or retroﬁtted with checks into the application
as performed by Ganapathy, Jaeger, and Jha for the X-server
[17].
Information ﬂow The isolation of data implemented by
our dynamic sandboxing is based on information ﬂow tech-
niques. Information ﬂow foundations were established by
Bell-LaPadula [4] and later by Biba [7]. Asbestos [15]
provides a DAC-based mechanism for information ﬂow
based on the decentralized label model [30]. Other models
which can support information ﬂow include RBAC [37] and
EROS’s extended capability model [38]. The above tech-
niques do not change process level labeling, which seems
necessary to implement dynamic sandboxing.
In subOS [21] objects whose content is from remote
sources are tagged with an immutable sub-user ID denot-
ing the source of the object. When an object with remote
content is read, permission is reduced by any permissions
the sub-user doesn’t have.
Dynamic mechanisms The high level speciﬁcation of dy-
namic sandboxes have explicit dynamic mechanisms to re-
duce privileges on use of permissions and implicit mecha-
nisms based on past reads. We note that these mechanisms
take place in the authorization system, not in the user pro-
gram, and hence cannot be bypassed. TE domain transi-
tions, in contrast, occur only on exec and hence are not dy-
namic. We have described elsewhere how KernelSec can be
used to implement groups, information ﬂow, Chinese Wall
[34] and dynamic separation of duty [40].
Many special purpose mechanisms have been used for
dynamic authorization, but they are each (and collectively)
far less general than KernelSec’s dynamic mechanisms. In
POSIX systems, the setuid-bit on ﬁles changes the process’
privileges on an exec [10].
In TE, domains change on