trusted store.
UserGate, WebTitan Gateway, Microsoft TMG, and Untangle
accept external ceritificates signed their own root key. If an attacker
can gain access to the signing keys of these appliances, she can
launch MITM attacks to impersonate any web server. UserGate,
and WebTitan Gateway provide ‘read’ privileges to non-root users
for the private signing key, while Untangle and Microsoft TMG
make it harder for attackers that have compromised the appliances,
requiring root/admin privileges to access the keys.
An attacker can recover authentication cookies from the clients
behind WebTitan Gateway by exploiting the CRIME [34] vulner-
ability, and the clients behind Microsoft TMG by exploiting the
BEAST [33] vulnerability. Attackers could also recover cookies
from clients behind WebTitan Gateway and Microsoft TMG due to
their use of RC4 [48]
We contacted the 6 affected companies and received replies from
three companies; Untangle replied with just an automatic reply,
Entensys confirmed that they have passed the matter to its research
team. Netgate (pfSense) stated that they philosophically oppose TLS
interception, but include it as it is a commonly requested feature.
Netgate also states that the TLS interception is done using the
external package ‘Squid’, which it does not control completely. .
6 CONCLUSION
We present a framework for analyzing TLS interception behaviors
of network appliances to uncover any potential vulnerabilities in-
troduced by them. We tested six network appliances, and found
that all their TLS proxies are vulnerable against the tests under
our framework—at varying levels. Each proxy lacks at least one of
the best practices in terms of protocol and parameters mapping,
patching against known attacks, certificate validation, CA trusted
store maintenance, and private key protection.
We found that the clients behind four appliances are vulnerable
to full server impersonation under an active man-in-the-middle
attack, of which one enables TLS interception by default; and that
attackers can recover authentication cookies with the current mech-
anism of two security appliances. Furthermore, client browsers are
often being misled, as the TLS versions and certificate parameters
displayed have a higher security level than the actual proxy-to-
server TLS connection, similar to client-end TLS proxies [32].
While TLS proxies are mainly deployed in enterprise environ-
ments to decrypt the traffic in order to scan it for malware and
network attacks, the network appliances introduce new intrusion
opportunities and vulnerabilities for attackers. As TLS proxies act
ASIA CCS ’18, June 4–8, 2018, Incheon, Republic of Korea
Louis Waked, Mohammad Mannan, and Amr Youssef
as the client for the proxy-to-web server connections, they should
maintain (at least) the same level of security as modern browsers;
similarly, as they act as a TLS server for the client-to-proxy con-
nections, they should be securely configured like any up-to-date
HTTPS server, by default. Before enabling TLS interception, con-
cerned administrators may use our framework to evaluate their
network appliances, and consider the potential vulnerabilities that
may be introduced by a TLS proxy against its perceived benefits.
ACKNOWLEDGEMENTS
We thank the ASIA CCS 2018 anonymous reviewers for their helpful
comments and suggestions to improve the paper’s presentation, and
Xavier de Carné de Carnavalet for his help during the development
of our framework. This research is supported by NSERC.
REFERENCES
[1] BEAST attack 1/n-1 split patch. Available at https://goo.gl/8MYeqz.
[2] Cisco WSA AsyncOS documentation. Available at https://goo.gl/hkHRbK.
[3] Diginotar ca breach. Available at https://goo.gl/p9ainQ, Sep 2011.
[4] Distrusting new CNNIC certificates. Available at https://goo.gl/yPidqC, Apr 2015.
[5] Distrusting new WoSign and StartCom certificates. Available at https://goo.gl/
[6] Effects of HTTPS and SSL inspection on the client. Available athttps://goo.gl/
zGmf5b, Oct 2016.
q1MVw4, Aug 2017.
2013.
[7] Extended validation OID. Available at https://goo.gl/AmmnXE, Oct 2013.
[8] GRC certificate validation revoked test, note=Available at https://goo.gl/A83vCC.
[9] Heartleech - GitHub. Available at https://goo.gl/JeKcpt.
[10] Howsmyssl - GitHub. Available at https://goo.gl/48gyGd.
[11] Lenovo’s superfish security. Available at https://goo.gl/w2R2y5, Feb 2015.
[12] Microsoft TMG 2010 updates. Available at https://goo.gl/WcykM6.
[13] Microsoft TMG supported OS version. Available at https://goo.gl/SU9LQ8.
[14] Microsoft trusted root certificate program. Available at https://goo.gl/5BT7d8.
[15] Mimikatz - GitHub. Available at https://goo.gl/dUWCmH.
[16] Revoking ANSSI CA. Available at https://goo.gl/rCjwtY, Dec 2013.
[17] The risks of SSL inspection. Available athttps://goo.gl/S3mL5v, Mar 2015.
[18] SSL client test. Available at https://goo.gl/3RdQ1J.
[19] The TÜRKTRUST SSL certificate fiasco. Available at https://goo.gl/8gxCdc, Jan
[20] UFS - Linux Kernel archives. Available at https://goo.gl/yZ3Fty.
[21] Untangle SSL inspector documentation. Available at https://goo.gl/NZghGy.
[22] US-CERT alert on HTTPS interception. Available at https://goo.gl/9oqZ4w.
[23] Volatility. Available at https://goo.gl/LSnbwF.
[24] Windows cryptography API (CNG). Available at https://goo.gl/UrARyq.
[25] ZMap - GitHub. Available at https://goo.gl/1g2UtU.
[26] D. Adrian, K. Bhargavan, Z. Durumeric, P. Gaudry, M. Green, J. A. Halderman,
N. Heninger, D. Springall, E. Thomé, L. Valenta, et al. Imperfect forward secrecy:
How diffie-hellman fails in practice. In Proceedings of the 22nd ACM SIGSAC
Conference on Computer and Communications Security, pages 5–17, Denver, CO,
USA, 2015.
[27] B. Beurdouche, K. Bhargavan, A. Delignat-Lavaud, C. Fournet, M. Kohlweiss,
A. Pironti, P.-Y. Strub, and J. K. Zinzindohoue. A messy state of the union: Taming
the composite state machines of tls. In 2015 IEEE Symposium on Security and
Privacy, pages 535–552, Fairmont, CA, USA, 2015.
[28] K. Bhargavan and G. Leurent. On the practical (in-) security of 64-bit block
ciphers: Collision attacks on HTTP over TLS and OpenVPN. In Proceedings of the
2016 ACM SIGSAC Conference on Computer and Communications Security, pages
456–467, Vienna, Austria, 2016.
[29] E. Biham, O. Dunkelman, N. Keller, and A. Shamir. New attacks on IDEA with at
least 6 rounds. Journal of Cryptology, 28(2):209–239, 2015.
[30] C. Brubaker, S. Jana, B. Ray, S. Khurshid, and V. Shmatikov. Using Frankencerts
for automated adversarial testing of certificate validation in SSL/TLS implementa-
tions. In 2014 IEEE Symposium on Security and Privacy, pages 114–129, Fairmont,
CA, USA, 2014.
[31] S. Y. Chau, O. Chowdhury, E. Hoque, H. Ge, A. Kate, C. Nita-Rotaru, and N. Li.
SymCerts: Practical symbolic execution for exposing noncompliance in x.509
certificate validation implementations. In 2017 IEEE Symposium on Security and
Privacy, pages 61–68, Fairmont, CA, USA, 2017.
[32] X. de Carné de Carnavalet and M. Mannan. Killed by proxy: Analyzing client-end
tls interception software. In Network and Distributed System Security Symposium,
San Diego, CA, USA, 2016.
[33] T. Duong and J. Rizzo. Here come the ⊕ ninjas. Technical Report. Available at
[34] T. Duong and J. Rizzo. The CRIME attack. Presentation at Ekoparty Security
https://goo.gl/DujxQg, May 2011.
Conference, 2012.
[35] Z. Durumeric, Z. Ma, D. Springall, R. Barnes, N. Sullivan, E. Bursztein, M. Bailey,
J. A. Halderman, and V. Paxson. The security impact of HTTPS interception. In
Network and Distributed Systems Symposium, San Diego, CA, USA, 2017.
[36] S. Fahl, M. Harbach, T. Muders, L. Baumgärtner, B. Freisleben, and M. Smith.
Why eve and mallory love android: An analysis of Android SSL (in) security. In
Proceedings of the 2012 ACM conference on Computer and communications security,
pages 50–61, Raleigh, NC, USA, 2012.
[37] M. Georgiev, S. Iyengar, S. Jana, R. Anubhai, D. Boneh, and V. Shmatikov. The most
dangerous code in the world: validating ssl certificates in non-browser software.
In Proceedings of the 2012 ACM conference on Computer and communications
security, pages 38–49, Raleigh, NC, USA, 2012.
[38] B. He, V. Rastogi, Y. Cao, Y. Chen, V. Venkatakrishnan, R. Yang, and Z. Zhang.
Vetting SSL usage in applications with SSLint. In 2015 IEEE Symposium on Security
and Privacy, pages 519–534, Fairmont, CA, USA, 2015.
[39] R. Housley, W. Ford, W. Polk, and D. Solo. RFC 5280: Internet x.509 public key
infrastructure certificate and crl profile, May 2008.
[40] L. S. Huang, A. Rice, E. Ellingsen, and C. Jackson. Analyzing forged SSL certificates
In 2014 IEEE Symposium on Security and Privacy, pages 83–97,
in the wild.
Fairmont, CA, USA, 2014.
[41] J. Jarmoc. SSL/TLS interception proxies and transitive trust. Black Hat Europe,
[42] M. O’Neill, S. Ruoti, K. Seamons, and D. Zappala. TLS proxies: Friend or foe? In
Proceedings of the 2016 ACM on Internet Measurement Conference, pages 551–557,
Santa Monica, CA, USA, 2016.
[43] E. Rescorla, M. Ray, S. Dispensa, and N. Oskov. RFC 5746: Transport layer security
(tls) renegotiation indication extension, Feb 2010.
[44] S. Ruoti, M. O’Neill, D. Zappala, and K. E. Seamons. User attitudes toward the
inspection of encrypted traffic. In Proceedings of the Eleventh Symposium On
Usable Privacy and Security, pages 131–146, Denver, CO, USA, 2016.
[45] S. Sivakorn, G. Argyros, K. Pei, A. D. Keromytis, and S. Jana. HVLearn: Automated
black-box analysis of hostname verification in SSL/TLS implementations. In 2017
IEEE Symposium on Security and Privacy, pages 521–538, Fairmont, CA, USA,
2017.
[46] L. Valenta, S. Cohney, A. Liao, J. Fried, S. Bodduluri, and N. Heninger. Factoring
as a service. In International Conference on Financial Cryptography and Data
Security, pages 321–338, Christ Church, Barbados, 2016.
[47] P. Van De Zande. The day DES died. SANS Institute, Jul 2001.
[48] M. Vanhoef and F. Piessens. All your biases belong to us: Breaking RC4 in WPA-
TKIP and TLS. In USENIX Security Symposium, pages 97–112, Washington D.C.,
USA, 2015.
[49] X. Wang and H. Yu. How to break MD5 and other hash functions.
In 37th
Annual International Conference on the Theory and Applications of Cryptographic
Techniques, pages 19–35, Sofia, Bulgaria, 2005.
Mar 2012.
A CRAFTING INVALID CERTIFICATE
CHAINS
In this section, we detail the methodology used to create each
certificate validation test.
Self-Signed. We generate a standalone certificate using OpenSSL
with regular parameters.
Signature Mismatch. We first generate a regular CA certificate,
and use it to sign a regular leaf certificate. We then modify the
signature of the leaf public key certificate by flipping one of the last
bits in the certificate. The certificate signature is positioned as the
last item inside the certificate. We thus create a certificate with a
mismatching signature, and test if the proxy validates the signature
on the presented certificate.
Fake GeoTrust Global CA. We craft an issuing root certificate
with the same certificate parameters as the GeoTrust Global CA au-
thority. We mimic the Common Name field (CN = GeoTrust Global
CA), the Organization field (O = GeoTrust Inc.), and the Country
field (C = US). Before signing the leaf certificate, we remove the au-
thority key identifier parameter from it. Without the authority key
identifier, the certificate cannot be linked to its issuing certificate.
Analyzing TLS Interception in Network Appliances
ASIA CCS ’18, June 4–8, 2018, Incheon, Republic of Korea
By doing so, we test if the TLS proxy validates the chain of trust
properly, or relies only on the certificate parameters such as the
subject name alone.
Wrong Common Name (CN). We generate a regular root CA
certificate, and use it to sign a regular leaf certificate that does not
have apache.host as the value for Common Name field. If the TLS
proxy accepts such a leaf certificate for the apache.host domain, then
the proxy does not validate that the delivered certificate is for the
exact domain requested, and thus, allows websites to impersonate
other servers by using their valid certificate.
Unknown Issuer. The test relies on a normal issuing certificate
and its normal leaf certificate. However, we do not import the
issuing certificate to the trust store of the network appliance, and
consequently, check if the TLS proxy is vulnerable to MITM attacks,
when an attacker uses untrusted CA certificates as issuers for their
certificate.
Non-CA Intermediate. We generate three certificates that serve
respectively as the root CA, the intermediate certificate and the
leaf certificate. However, we intentionally craft the intermediate
certificate to have the basic constraint extension that identifies
CA certificate as false. Using this methodology, we test if the TLS
proxy ensures that the CA certificates have the ability to issue other
certificates, using the CA flag. If the proxy does not detect such
vulnerabilities, attackers could use any valid leaf certificate to sign
other leaf certificates, and host them on their servers.
X509v1 Intermediate. The first version of x509 does not have
the basic constraint extension, and thus, CA certificates cannot be
differentiated from leaf certificates. As a result, x509v1 certificates
should not be used for issuing certificates. We generate three cer-
tificates that serve respectively as the root CA, the intermediate
certificate and the leaf certificate, while only having the intermedi-
ate certificate of type x509v1. If accepted, the proxy risks potential
consequences that are similar to the Non-CA Intermediate test.
Revoked. We test if the TLS proxy accepts revoked certificates
using Gibson Research Corporation’s special site that hosts a web-
site using a revoked certificate [8]. Digicert provided them with an
intentionally revoked certificate using both a Certificate Revocation
List (CRL) and the Online Certificate Status Protocol (OCSP). If the
revoked certificate is allowed, this implies that the TLS proxy does
not validate the revocation status of the delivered certificates and
their appropriate issuers.
Expired and Not Yet Valid Certificates. We generate three dis-
tinct tests to check the behavior of network appliances when ex-
posed to expired certificate. For the first test, we craft a root CA
certificate with an expired validity date, and use it to sign a reg-
ular leaf certificate. For the second test, we craft a regular root
CA certificate, use it to sign an expired intermediate certificate,
which in turn, signs a regular leaf certificate. For the third test, we
craft a regular root CA certificate, and use it to sign an expired
leaf certificate. Similarly, we generate three similar tests for not
yet valid certificates. The main difference between the two set of
certificates is that, for expired certificates, the ‘valid to’ date is prior
to the current date of testing, while the not yet valid certificates
have the ‘valid from’ date exceeding the date of testing.
Invalid pathLenConstraint. A pathLenConstraint of 1 in a root
CA certificate implies that the issuer can issue one layer of inter-
mediate certificates, which in turn will have a pathLenConstraint
of 0. A pathLenConstraint of 0 implies that this certificate can only
issue leaf certificates. We generate a root CA certificate with a
pathLenConstraint of 1, and issue an intermediate certificate with
a pathLenConstraint of 0 using it, and subsequently issue another
intermediate certificate with a pathLenConstraint of 0 using the
first intermediate certificate. We then use the section intermediate
certificate to issue a leaf certificate. Using this methodology, we
test if the TLS proxies check the pathLenConstraint parameter, as
the first intermediate should issue only leaf certificates, and not
another intermediate certificate.
Bad Name Constraint Intermediate. We test if the TLS proxies
validate the Name Constraint x509v3 certificate extension. We craft
a regular CA certificate, and use it to sign an intermediate certificate
that has a different domain than ‘apache.host’ solely permitted
as a DNS name. We then issue a leaf certificate for the domain
apache.host using that intermediate certificate. The validating proxy
should typically terminate the TLS connection when exposed to
such a case, as the intermediate certificate has an issuing permit
constraint for a domain different than ‘apache.host’.
Malformed X509v3 Extension Value. We generate a regular root
CA certificate and use it to issue a leaf certificate that holds a dummy
random string as a value for its keyUsage parameter (i.e., will not
match any of the names in the list of the permitted key usages).
Unknown Critical X509v3 Extension. We generate a root CA
certificate, and use it to issue a leaf certificate that holds a non-
typical x509v3 extension (unusual OID value), set to critical. We
thus analyze the TLS proxies’ behavior when exposed to unknown
extensions marked as critical.
Wrong keyUsage and extKeyUsage. We rely on two tests for the
keyUsage and extKeyUsage x509v3 extensions, one for leaf certifi-
cates, and the other for root certificates. Regarding the keyUsage, we
craft a regular root certificate, and sign a leaf certificate that holds a
keyUsage value of keyCertSign, omitting the required keyEncipher-
ment value for all leaf certificates. TLS proxies should drop TLS
connection to servers that hold no keyEncipherment keyUsages.
Moreover, we craft a root CA certificate with a keyUsage of nonRe-
pudiation, omitting the required keyCertSign value for all issuing
certificates. TLS proxies should not accept issuing certificates with
a keyUsage value that excludes keyCertSign.
Regarding the extKeyUsage extension, we craft a regular root
certificate and use it to issue a leaf certificate that holds clientAuth
as the extKeyUsage value, implying that this certificate is meant
to be used by TLS clients, and not by TLS servers. TLS proxies
should then drop the TLS connection. We also craft a root certificate
whose extKeyUsage value consists of codeSigning, implying that
this issuing certificate is not meant to be used for TLS connections.
TLS proxies should similarly drop such a connection. Failure of
proper validation of certificate usages allows attackers to abuse
TLS connections by using non-compliant certificates.
Short Key Length Root and Leaf Certificates. We generate RSA-
512 and RSA-1024 root CA certificates, and import them to the
trusted stores (when possible). We host their respective leaf cer-
tificates, and test if the TLS proxy accepts insecure key sizes for
ASIA CCS ’18, June 4–8, 2018, Incheon, Republic of Korea
Louis Waked, Mohammad Mannan, and Amr Youssef
root certificates. On the other hand, we generate regular root cer-
tificates with proper key sizes (e.g., RSA-2048), and craft their leaf
certificates to have short keys (512, 768, 1016 and 1024 as key sizes),
and test if the TLS proxies accept such insecure key sizes for leaf
certificates.
Bad Signature Hashing Algorithms. To check the proxies’ be-
havior when exposed to weak and deprecated signature algorithms,
we modify the signature algorithms in the OpenSSL configuration
file when signing three distinct certificates to use respectively MD4,
MD5 and SHA1.
B PRIVATE KEY EXTRACTION FOR CISCO
IRONPORT WSA
In this section, we discuss the challenges faced while attempting
to extract the private key from the Cisco Ironport Web Security
Appliance.
We performed several attempts to bypass the limited custom
command line interface, and access the filesystem content itself.
We first tried to skip the proprietary command-line interface and
reach operating system’s native command-line. However, Cisco’s
interface is designed to have no escape point out of its custom
command-line interface [2]. We then attempted to mount the net-
work appliance’s drive to our Ubuntu machine. We discovered that
the virtual disk drive is divided into 9 different partitions, with
FreeBSD as the main OS. We subsequently attempted to mount all
partitions, with FreeBSD’s filesystem type UFS, and all UFS type
options, which include: old, default, 44bsd, ufs2, 5xbsd, sun, sunx86,
hp, nextstep, nextstep-cd, and openstep [20].
With all the mentioned UFS types failing and no mounted drive,
we then attempted to explore the content of the disk drive with-
out mounting it. We relied on the Linux strings command, which
extracts printable characters from binary files. We then parsed
the output and saved all private keys found, by searching for
the private key delimiters ‘-----BEGIN PRIVATE KEY-----’ and
‘-----BEGIN RSA PRIVATE KEY-----’. We then compared the
modulus of each key to the appliance’s public key certificate, in
order to attempt to locate the corresponding private key.
With no positive matching, we proceeded to memory analysis.
We dumped the volatile memory of a VM by saving a snapshot
of the running machine, after intercepting the traffic for a not
previously visited website. We ensured that the website visited
has not been visited and proxied earlier, to guarantee that the
private key will be used to sign the intercepted page, and thus,
be located in the appliance’s RAM. Subsequently, we passed the
memory dump to Volatility, a memory forensics tool [23]. Volatility
requires as an input the exact profile of the OS corresponding
to the memory dump. Consequently, we attempted to determine
the profile using Volatility’s ‘imageinfo’ command, which fails to
determine the profile. Without the specific profile, Volatility fails
to execute.
As a result, we attempted to use the collected memory dump
with Heartleech [9]. We fed the tool with Cisco Ironport Web Secu-
rity Appliance’s memory dump, along with the TLS proxy’s public
key certificate to Heartleech, which successfully outputs the corre-
sponding private key.