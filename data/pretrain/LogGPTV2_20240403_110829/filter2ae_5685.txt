打开程序：有几秒的弹窗动画  
主程序：  
查看help：  
大意是：你的任务是禁止开始动画，找到硬编码序列和注册机名称/序列号。这个级别为了确保你理解如何使用工具并且破解程序，这是三个很简单的保护测试。  
祝你好运，技术更上一层楼。  
先找到硬编码序列。随便填，点“check hardcoded”  
弹出失败对话框。  
可以考虑MessageBoxA下手和获取文本的地方下手，这里从获取文本的地方下手。  
Bp GetDlgItemTextA，再次输入错误的，程序没断下，  
删除断点，重新运行程序，bp GetWindowTextA，输入错误的硬编码，断下  
Ctrl+F9，执行到函数结束，F7返回主模块。  
代码分析如下：  
获取输入文本到[403215],与[401353]处字符串比较，相同弹出正确对话框，否则弹出失败对话框  
所以正确hardcoded是”HardCoded”  
验证：  
分析Name/Serial，随便输入：弹出对话框。  
这次我们设置条件断点来分析，先将程序运行（因为消息断点必须是窗口创建之后再能设）  
点击工具栏W按钮  
随便选一个button设置消息断点：  
如图：  
断点设置成功：  
随便输入序列号,点击CHECK，程序断下  
通过堆栈知道断在了消息循环内部，消息是WM_LBUTTONUP  
点击工具栏中的【M】按钮，打开内存窗口，在code段下内存访问断点  
F9运行程序。  
回到主模块，再继续F9，直到定位到处理序列号代码（因为给代码段下了内存访问断点，所以F9是一步一断）,然后删除内存访问断点  
如图，首先获取的是序列号，保存在[403242]：  
获取用户名，保存在[403236]  
根据用户名算出s字符串  
根据序列号算s2  
最后判断：  
根据上面写出注册机：（代码在最下面）  
注意，输入的序列号必须是可见字符，不仅仅是取模10等于是s[i]，就行，所以用了while循环，直到j可见。  
验证：  
重新加载，只剩下启动动画了。  
可以试试下断CreateWindowExA，重新运行程序，断下了。Ctrl +
F9执行到返回，然后F7执行到主模块。可以看到下面有GetTickCount函数，就明白程序GetTickCount函数计时开机动画的启动时间。  
分析：  
所以，可以将jbe 改成jnb，让它第一次就满足条件，不再比较，就可以了。  
改完保存到文件，发现开启动画果然没有了，至此，任务完成。
根据名字算序列号：
    #include 
    #include 
    int main(void)
    {
        int i, j;
        char name[10], s[10];
        printf("please input five chars : ");
        scanf("%s", name);
        for (i = 0; i < 5; i++)
        {
            s[i] = (name[i] % 10) ^ i;
            s[i] = (s[i] + 2) % 10;
        }
        for (i = 0; i < 5; i++)
        {
            j = s[i];
            while (j < 'A')
            {
                j += 10;
            }
            printf("%c", j);
        }
        printf("\n");
        return 0;
    }
直接将附件的后缀改为exe即可 不需要解压