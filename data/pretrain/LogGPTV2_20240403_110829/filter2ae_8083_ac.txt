初步猜测，攻击合约这么设计是为了分散权限和资金，降低出问题或被发现的风险。
上图正是一笔攻击交易的传入参数。第一部分是调用函数哈希 ID，后面跟着三个参数。注意看第一个参数，攻击者传入的明显是一个地址。显然，这个地址正是 LW
游戏合约地址。
原来如此，攻击目标对象可以作为参数传入。“黑客真机智！”，我们不由地感慨。之前的一个困惑被解开，早在 LW 游戏上线前就已部署好的攻击合约
0x5483，其实是一个 **通用型武器** 。
继续研究，接下来合约的复杂程度出乎我们意料。我们沿着生成的控制流程图（CFG）追踪合约函数调用过程，程序指令以及 **分支情况**
非常之多（下图是一小部分截图），让人难以完全跟上。
安比（SECBIT）实验室使用动态追踪调试技术，结合逆向分析结果与攻击交易内部记录，搞清楚了黑客所使用的手法。
其他攻击交易也都是类似的过程，黑客调用攻击合约，攻击合约再调用提前创建好的合约，进而创建新的合约，以新合约的身份参与 LW
游戏，买游戏道具，然后几乎必定获得空投奖励。
**这一过程中不断新建的合约，就是态势感知系统中预警的大量异常合约创建与自毁。**
追踪攻击合约调用历史，发现攻击者在部署完攻击合约后，就立即多次调用特定函数，每次新建 10 个新合约。而函数总共恰好调用了 100 次，因此 **新建了
1000 个新合约** （记住这个细节）。
在攻击交易中，攻击合约最先调用的就是这预先创建好的 1000 个合约之一，似乎是特地从中挑选出来一个地址。
### 十四、智能合约：一切皆可预测
攻击函数控制流程图（CFG）中一个相隔很远的循环引起了我们的注意。
我们恍然大悟。攻击函数所做的就是不断循环地在 1000
个合约中，挑选“合适”的地址来完成下一步新建合约操作。所谓“合适”的地址，就是指能确保每次参与游戏都能获得空投奖励。
前面提到，以太坊智能合约中可以很容易的预测随机数，因为随机数的来源都是区块或者交易中特定的一些公开参数，如交易发起者地址、区块时间戳、区块难度等等。因此空投游戏利用随机数来控制中奖概率是不可行的。
而这里，黑客利用了另一个以太坊的特征，一个地址（账户）创建一个合约，合约地址是可按照特定规则计算得到的，任何人都可以根据已知信息进行推算。
因此，黑客循环利用自己控制的 1000
个合约地址，推算各地址下一次新建的合约地址，而该地址恰恰是空投游戏中奖数字的随机源。攻击合约通过一系列预演推算来筛选出“合适”的地址来完成攻击操作（技术细节后文会详细讨论）。
这才是黑客能够以超高概率获得空投的真正原因！
### 十五、技术流：攻击手法细节披露
类 Fomo3D 游戏空投漏洞的根本原因在于，以太坊智能合约环境中难以生成无法预测的随机数。而 Fomo3D
开发者在其合约中增加了“判断调用者是普通人类还是合约”的逻辑来尝试规避，但此逻辑实现存在漏洞。黑客利用攻击合约提前预测随机数，并通过在构造函数内调用游戏合约的方法来伪装成普通人类（非合约）地址，从而大大增加自身中奖概率。
时间再次回到 7 月 23 日，以太坊基金会开发团队负责人之一 Péter Szilágyi 在 Reddit 上首次公开爆出这个漏洞并给出 1.0 版本的
POC 方案（详细可以参考引文 [3]）。这主要是利用了这些特点：
  * 空投游戏用来控制中奖概率的随机源，可被提前获得
  * 用户能否获得空投奖励以及奖励金额，可在另外一个合约中提前计算出来，从而决定后面的操纵逻辑
  * Fomo3D 空投机制中尝试限制只有非合约地址（普通人类）才能参加游戏以防止上述情况的发生。但该判断方法存在漏洞，在构造合约的过程中（即合约构造方法里）参与游戏即可绕过该限制。
因此攻击者可以部署一个智能合约，并在合约的构造方法中计算出自己是否能够获益，如果能则投入以太币参加游戏空投获利，否则就不参加（参见下图）。
Péter 提出的这个方案只是一个最简单的原型，因为每次部署合约都要消耗不少
Gas，而且工作效率很低且收益率并不高，采用该方案攻击，发起上千笔交易，都不一定能够真正获得空投奖励。
看到这里你可能会有疑问，上文的攻击者似乎手法更高明，而且实际成功攻击的发生时间要早得多。
Zethr 开发者 Etherguy 早在 7 月 8 日就已使用更高明的手法成功获利，解决了上文 1.0 方案中的部分问题，我们姑且称之为 2.0 版本。
这个思路是通过 **合约循环创建子合约** （参见下图），直到子合约满足空投条件可以获利为止。这样做的好处是，在 Gas
充足的情况下，每次调用合约几乎一定可以获得收益，提高了工作效率。然而这种方案和 1.0 版本的攻击成本接近，并没有从本质上提高收益率。
而这次事件的最大获利者 BAPT-LW20 团队，就是在 2.0 版本的思路上进行了进一步优化降低了投入成本，提高了收益率。 3.0
版本则疯狂创建代理合约，通过利用计算下一步新建合约地址的技巧提前预判，筛选出符合条件的代理合约再创建出新的子合约，在子合约的构造函数中再完成上述攻击（见下图）。而且攻击目标地址可配置，可多人同时协作攻击。当游戏奖池金额不足以覆盖攻击成本时，发出的攻击交易会自动提前失败，仅消耗很低的
Gas 费用。
在分析各类攻击合约过程中，我们还见到另外一种更高明的做法：主攻击合约有着良好的设计模型，支持 **核心算法动态替换与升级** 。原理上则是利用了
`delegatecall` 进行操作。安比（SECBIT）实验室会持续关注这批黑客的动向。
### 彩蛋1：空投与挖矿
我们知道在 PoW 挖矿的时候，矿工通常需要进行如下计算：
    BlockHash = Hash(Header+Nonce)
    Check(BlockHash  新合约（尝试攻击）
    用户（地址+nonce1） --------------------> 新合约（尝试攻击）
    用户（地址+nonce2） --------------------> 新合约（尝试攻击）
    用户（地址+nonce3） --------------------> 新合约（尝试攻击）
但是这种方式需要用户持续部署合约，消耗的矿工费代价非常大，且成功率极低，每次都是以 1/1000 的中奖概率在尝试。
由于第 1 代惊人的失败率，显然无法利用，于是有了第 2 代攻击方法：
这种方法的主要思想是，合约创建的新合约地址由 `合约地址+nonce` 确定：
          部署合约    |------------------| hash(caddr, nonce)
    用户 ---------->  |循环创建合约，     | -------> 新合约（尝试攻击）
                     |直到攻击成功或到达终 | -------> 新合约（尝试攻击）
                     |止条件才停止，可能需 | -------> 新合约（尝试攻击）
                     |要部署大量合约。    | -------> 新合约（尝试攻击）
                     |----------------- |
这种方式类似于挖矿，固定区块头部，不断修改 nonce 来试探能否成功获得奖励，但是问题在于，如果在循环第 1000 次才发现合法的
nonce，那么意味着之前部署的 999 个合约都属于浪费 Gas 的操作。
那么如何更高效地寻找合法的 nonce 呢？
我们回想比特币挖矿，一个挖矿任务中，不仅有 nonce，还有 extraNonce [4]。