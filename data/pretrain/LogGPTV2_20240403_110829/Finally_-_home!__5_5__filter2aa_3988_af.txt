      i32.lt_s
      select
    end
    local.set $l262
    local.get $l342
    local.set $l110
    local.get $l110
    local.get $l262
    i32.add
    local.set $l138
    local.get $l138
    local.set $l342
    local.get $l238
    local.set $l111
    local.get $l111
    i32.const -1
    i32.xor
    local.set $l294
    local.get $l294
    i32.const 168
    i32.and
    local.set $l186
    local.get $l238
    local.set $l112
    local.get $l112
    i32.const -169
    i32.and
    local.set $l187
    local.get $l186
    local.get $l187
    i32.or
    local.set $l325
    local.get $l325
    i32.const 144
    i32.sub
    local.set $l357
    block $B28 (result i32)
      local.get $l357
      local.set $l376
      i32.const 0
      local.get $l376
      i32.sub
      local.get $l376
      local.get $l376
      i32.const 0
      i32.lt_s
      select
    end
    local.set $l263
    local.get $l342
    local.set $l113
    local.get $l113
    local.get $l263
    i32.add
    local.set $l139
    local.get $l139
    local.set $l342
    local.get $l239
    local.set $l114
    local.get $l114
    i32.const -1
    i32.xor
    local.set $l295
    local.get $l295
    i32.const 234
    i32.and
    local.set $l188
    local.get $l239
    local.set $l115
    local.get $l115
    i32.const -235
    i32.and
    local.set $l189
    local.get $l188
    local.get $l189
    i32.or
    local.set $l327
    local.get $l327
    i32.const 219
    i32.sub
    local.set $l358
    block $B29 (result i32)
      local.get $l358
      local.set $l376
      i32.const 0
      local.get $l376
      i32.sub
      local.get $l376
      local.get $l376
      i32.const 0
      i32.lt_s
      select
    end
    local.set $l264
    local.get $l342
    local.set $l116
    local.get $l116
    local.get $l264
    i32.add
    local.set $l140
    local.get $l140
    local.set $l342
    local.get $l240
    local.set $l117
    local.get $l117
    i32.const -1
    i32.xor
    local.set $l296
    local.get $l296
    i32.const 173
    i32.and
    local.set $l190
    local.get $l240
    local.set $l118
    local.get $l118
    i32.const -174
    i32.and
    local.set $l191
    local.get $l190
    local.get $l191
    i32.or
    local.set $l328
    local.get $l328
    i32.const 149
    i32.sub
    local.set $l360
    block $B30 (result i32)
      local.get $l360
      local.set $l376
      i32.const 0
      local.get $l376
      i32.sub
      local.get $l376
      local.get $l376
      i32.const 0
      i32.lt_s
      select
    end
    local.set $l265
    local.get $l342
    local.set $l119
    local.get $l119
    local.get $l265
    i32.add
    local.set $l141
    local.get $l141
    local.set $l342
    local.get $l242
    local.set $l121
    local.get $l121
    i32.const -1
    i32.xor
    local.set $l298
    local.get $l298
    i32.const 39
    i32.and
    local.set $l192
    local.get $l242
    local.set $l122
    local.get $l122
    i32.const -40
    i32.and
    local.set $l193
    local.get $l192
    local.get $l193
    i32.or
    local.set $l329
    local.get $l329
    i32.const 18
    i32.sub
    local.set $l361
    block $B31 (result i32)
      local.get $l361
      local.set $l376
      i32.const 0
      local.get $l376
      i32.sub
      local.get $l376
      local.get $l376
      i32.const 0
      i32.lt_s
      select
    end
    local.set $l267
    local.get $l342
    local.set $l123
    local.get $l123
    local.get $l267
    i32.add
    local.set $l142
    local.get $l142
    local.set $l342
    local.get $l342
    local.set $l124
    local.get $l375
    global.set $g2
    local.get $l124
    return)
  (global $g2 (mut i32) (i32.const 2080))
  (global $g3 (mut i32) (i32.const 5244960))
  (global $g4 (mut f32) (f32.const 0x0p+0 (;=0;)))
  (export "_ver" (func $_ver)))
```
Still, not very readable. At least we can identify the (max?) number of characters in the flag, based on the number of parameters that `ver` receives:
```
(func $_ver (type $t1) (param $p0 i32) (param $p1 i32) (param $p2 i32) (param $p3 i32) (param $p4 i32) (param $p5 i32) (param $p6 i32) (param $p7 i32) (param $p8 i32) (param $p9 i32) (param $p10 i32) (param $p11 i32) (param $p12 i32) (param $p13 i32) (param $p14 i32) (param $p15 i32) (param $p16 i32) (param $p17 i32) (param $p18 i32) (param $p19 i32) (param $p20 i32) (param $p21 i32) (param $p22 i32) (param $p23 i32) (param $p24 i32) (param $p25 i32) (param $p26 i32) (param $p27 i32) (param $p28 i32) (param $p29 i32) (param $p30 i32) (result i32)
```
So the next phase would be to convert the `wat` file to good old `c`:
```console
┌──(user@kali)-[/media/sf_CTFs/cyberark/Finally_-_home]
└─$ ~/utils/web/wabt/build/wasm2c  script.wasm -o script.c
```
We get:
  Click to expand!
```c
/* Automically generated by wasm2c */
#include 
#include 
#include "script.h"
#define UNLIKELY(x) __builtin_expect(!!(x), 0)
#define LIKELY(x) __builtin_expect(!!(x), 1)
#define TRAP(x) (wasm_rt_trap(WASM_RT_TRAP_##x), 0)
#define FUNC_PROLOGUE                                            \
  if (++wasm_rt_call_stack_depth > WASM_RT_MAX_CALL_STACK_DEPTH) \
    TRAP(EXHAUSTION)
#define FUNC_EPILOGUE --wasm_rt_call_stack_depth
#define UNREACHABLE TRAP(UNREACHABLE)
#define CALL_INDIRECT(table, t, ft, x, ...)          \
  (LIKELY((x)  mem->size)) TRAP(OOB)
#endif
#if WABT_BIG_ENDIAN
static inline void load_data(void *dest, const void *src, size_t n) {
  size_t i = 0;
  u8 *dest_chars = dest;
  memcpy(dest, src, n);
  for (i = 0; i >1); i++) {
    u8 cursor = dest_chars[i];
    dest_chars[i] = dest_chars[n - i - 1];
    dest_chars[n - i - 1] = cursor;
  }
}
#define LOAD_DATA(m, o, i, s) load_data(&(m.data[m.size - o - s]), i, s)
#define DEFINE_LOAD(name, t1, t2, t3)                                                 \
  static inline t3 name(wasm_rt_memory_t* mem, u64 addr) {                            \
    MEMCHECK(mem, addr, t1);                                                          \
    t1 result;                                                                        \
    __builtin_memcpy(&result, &mem->data[mem->size - addr - sizeof(t1)], sizeof(t1)); \
    return (t3)(t2)result;                                                            \
  }
#define DEFINE_STORE(name, t1, t2)                                                     \
  static inline void name(wasm_rt_memory_t* mem, u64 addr, t2 value) {                 \
    MEMCHECK(mem, addr, t1);                                                           \
    t1 wrapped = (t1)value;                                                            \
    __builtin_memcpy(&mem->data[mem->size - addr - sizeof(t1)], &wrapped, sizeof(t1)); \
  }
#else
static inline void load_data(void *dest, const void *src, size_t n) {
  memcpy(dest, src, n);
}
#define LOAD_DATA(m, o, i, s) load_data(&(m.data[o]), i, s)
#define DEFINE_LOAD(name, t1, t2, t3)                        \
  static inline t3 name(wasm_rt_memory_t* mem, u64 addr) {   \
    MEMCHECK(mem, addr, t1);                                 \