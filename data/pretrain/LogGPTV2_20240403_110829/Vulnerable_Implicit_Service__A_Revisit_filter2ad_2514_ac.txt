In addition, we identify some auxiliary functions that are related
to the a(cid:138)ributes of intents and list them in Table 1. For instance,
the functions in android.content.ComponentName class are used
to construct a new component name, and the results will be used
to set the component name of an intent. As another example, the
functions in java.lang.Class class are used to get the name of a
class, and the results are usually used to set the class name of an
intent. Since most a(cid:138)ributes of the intent is described by a string,
the string processing functions are also considered.
Inter-Method Intent Processing. (cid:140)ere are four cases in
which an Intent’s data (cid:131)ow will come across the method boundary,
marked as bold in Figure 2. First, when an intent in the Tempo-
raryIntentList is passed to another method as a parameter, the data
(cid:131)ow will go into the new method, which will add the intent in
its own TemporaryIntentList. Second, when one method contain-
ing an intent in the TemporaryIntentList is returned from another
method, we insert the corresponding method name and the return
value in a MethodReturnIntentList for each application. In the
meantime, all methods invoking this method will be added into the
intent constructor database. Figure 3 shows a sample code from
an application named “aa.apps.dailyre(cid:131)ections-1”. In code snippet
(a), an intent (we call it Intent1 a(cid:137)erwards) is created and returned
in one method zzqS(). When analyzing the code, Intent1 is in-
serted into method zzqS()’s TemporaryIntentList. In the mean
time,  key value pair is inserted into the app’s
MethodReturnIntentList. Next we will search the smali codes to
(cid:128)nd out all the methods invoking zzqS() and then insert them
into the intent constructor database. As shown in code snippet
(b), zzqS() is invoked in method zzcH(), therefore method zzcH()
is inserted into the intent constructor database. When analyzing
the method zzcH(), Intent1 will be inserted into method zza()’s
TemporaryIntentList, since the return value of method zzcH() is
passed into the method zza(). Finally, in method zza() as shown
in code snippet (c), Intent1 is consumed by the bindService()
function to start a service component. Now Intent1 is inserted into
the intent value database.
Figure 3: Sample Code of Returned Intent.
(a)Intent is constructed and returned in a method zzqS().method public zzqS()Landroid/content/Intent;   ...    // Intent is constructed    new-instance v0, Landroid/content/Intent;                                                           iget-object v1, p0, Lcom/google/android/gms/common/internal/zzm\$zza;->zzSU:Ljava/lang/String;    //Set action of the Intent    invoke-direct {v0, v1}, Landroid/content/Intent;->(Ljava/lang/String;)V       const-string v1, "com.google.android.gms"                   //Set package name    invoke-virtual {v0, v1}, Landroid/content/Intent;->setPackage(Ljava/lang/String;)Landroid/content/Intent;       move-result-object v0    …    // Return the Intent    return-object v0    (b)zzqS() is invoked to fetch the Intent in another method zzcH() .method public zzcH(Ljava/lang/String;)V    …     //Intent is fetched through calling zzqS()     invoke-virtual {v2}, Lcom/google/android/gms/common/internal/zzm\$zza;->zzqS()Landroid/content/Intent;      move-result-object v3   …     //Intent is passed into zza() method     invoke-virtual/range {v0 .. v5},Lcom/google/android/gms/common/stats/zzb;->zza(Landroid/content/Context;Ljava/lang/String;Landroid/content/Intent; Landroid/content/ServiceConnection;I)Z   …(c)In method zza(), the Intent is consumed by the bindService() method   …   //Intent is consumed by the bindService() method    invoke-virtual {v2, v1, v3, v4},         Landroid/content/Context;->bindService(Landroid/content/Intent;Landroid/content/ServiceConnection;I)Z    Session E2:  Securing Mobile AppsCCS’17, October 30-November 3, 2017, Dallas, TX, USA1055(cid:140)ird, when one intent in the TemporaryIntentList is stored
into a global variable, the key and value for this global vari-
able is stored into a key value mapping list named GlobalVal-
ueList for each application.
In the meantime, all methods con-
suming this global variable will be added into the intent construc-
tor database. (cid:140)ere are several ways to create a global variable
in Android application, such as de(cid:128)ning a global static variable
in the class and using the APIs in SharedPreferences [21] for
applications to conveniently store, read, and write a key-values
collection. Figure 4 shows a sample code from an application
named com.tvrsoft.santabiblia-13.
In Figure 4 (a), one in-
tent is created in one method and saved into the global variable
Lcom/google/android/gms/auth/GoogleAuthUtil;->Dp:
Landroid/content/Intent;. In another method, the intent is ob-
tained from the global variable and used by the bindService()
function to start a service component, as shown in Figure 4 (b).
Fourth, when an intent is obtained from a global variable not
included in the GlobalValueList, we search and (cid:128)nd all methods
in which the global variable is put, perform data (cid:131)ow analysis on
each method, and set global variable obtained in each method as a
potential value of the intent.
Figure 4: Sample Code of Storing Intent in a Global Variable.
In all above four cases, if one a(cid:138)ribute of an intent (or the intent
variable) depends on certain input parameter of a callee method, we
need a backward search for the caller method and start the analysis
on the intent from that method again, until we can determine the
a(cid:138)ribute (or intent) values. If one a(cid:138)ribute value of the intent (or
the intent variable) is a return value of an abstract method, the
smali code only depicts the name of the abstract value. In this case,
we need to (cid:128)nd all implementation methods and set return values
of all methods as the potential values of the a(cid:138)ribute (or intent). If
one a(cid:138)ribute value of the intent (or the intent variable) is a return
value of a class inherited from a super class, the smali code only
depicts the name of the inheritance class while the implementation
is in the super class, we need to (cid:128)nd the implementations method
in the super class and set the return values of the method as the
value of the a(cid:138)ribute (or intent).
Figure 2 shows that the data (cid:131)ow analysis is a depth (cid:128)rst re-
cursive algorithm. We set two limits to prevent the analysis from
entering a dead loop and ensure the algorithm can (cid:128)nish in limited
time. First, we empirically set the nesting level to 5 in our imple-
mentation, since through manually verifying applications in the
ANDROID WEAR category, 5 is large enough to analyze the intent
a(cid:138)ributes. Second, when a method is recursively invoked by itself,
we will only analyze the method once.
3.3 Reachability Veri(cid:128)er
Since we only concern about the vulnerable service invocations
that can be truly triggered in the apps, we develop a reachability
veri(cid:128)er to check if the service invocations found by our static intent
analyzer are reachable from certain entry points of the apps. All
intents related to the reachable service invocations are saved into
a Reachable Intent Database. First, we need to (cid:128)nd all the applica-
tion entry points; however, di(cid:130)erent from traditional Java Apps,
Android applications are composed of four types of components
rather than including an entry point method such as main(), and
all the component lifecycle methods and callback methods can
serve as entry-points for Android apps. To solve this problem, sim-
ilar to FlowDroid [4], we generate a dummyMain() for each App,
where the dummyMain() includes all lifecycle methods and callback
methods.
(cid:140)en we build the inter-procedure call-graph for the application
and traverse all call-graph paths to verify the reachability of the
service invocations. If we can (cid:128)nd a path from one entry point to
the position of invoking startService() or bindService(), the service
invocation will be marked as reachable. IC3 [33] provides two
algorithms, spark [26, 37] and CHA [11], to construct the inter-
procedure call graph on Android apps. However, when we run the
two algorithms to build the call graph on 1390 popular applications
from Google Play Store, we (cid:128)nd that they cannot (cid:128)nish or provide
any useful results on 38% applications within 10 hours. Similar
results are also reported in Mud(cid:131)ow [5].
Fortunately, our reachability analysis does not need to build a
full call-graph. By performing depth (cid:128)rst search to traverse the code
directly using CHA algorithm, we do not need to save the edges
and nodes of call-graph. When there is a calling chain from the
entry-point to the service APIs, we consider these APIs as reachable
and they can be triggered at certain points. In this way, we can
(cid:128)lter out the service invocations in the dead code that will never
be triggered.
3.4 Vulnerable Service Invocation Analyzer
(cid:140)e reachable intent database generated by the reachability veri(cid:128)er
includes both explicit and implicit intents, so the vulnerable service
invocation analyzer consists of three modules to (cid:128)lter out explicit
service invocations and provide further analysis on vulnerable
service invocations. First, the Implicit Invocation Finder (cid:128)nds out
the services invoked via implicit intents, i.e., intents without se(cid:138)ing
(a)Intent is constructed and saved into a global variable in method ppbQ().method public ppbQ()V    ......    // Intent is constructed    new-instance v0, Landroid/content/Intent;    invoke-direct {v0}, Landroid/content/Intent;->()V    const-string v1, "com.google.android.gms"    // PackageName is set for the Intent    invoke-virtual {v0, v1}, Landroid/content/Intent;->setPackage(Ljava/lang/String;)Landroid/content/Intent;    move-result-object v0    sget-object v1, Lcom/google/android/gms/auth/GoogleAuthUtil;->Dn:Landroid/content/ComponentName;       // ComponentName is set for the Intent    invoke-virtual {v0, v1}, Landroid/content/Intent;->setComponent(Landroid/content/ComponentName;)Landroid/content/Intent;    move-result-object v0      // Intent is saved into a global variable Lcom/google/android/gms/auth/GoogleAuthUtil;->Dp:Landroid/content/Intent;    sput-object v0, Lcom/google/android/gms/auth/GoogleAuthUtil;->Dp:Landroid/content/Intent;(b)In method ssO(), Intent is obtained from the global variable and consumed by the bindService().method public ssO()V    ......   // Intent is fetched from a global variable   sget-object v3, Lcom/google/android/gms/auth/GoogleAuthUtil;->Dp:Landroid/content/Intent;        const/4 v4, 0x1         invoke-static {v1, v3},     // The fetched intent is consumed by the bindService() method    invoke-virtual {v1, v3, v2, v4}, Landroid/content/Context;->bindService(Landroid/content/Intent;Landroid/content/ServiceConnection;I)Z    Session E2:  Securing Mobile AppsCCS’17, October 30-November 3, 2017, Dallas, TX, USA1056package, class, or component. Second, the Resolved Invocation
Finder (cid:128)nd the service invocation points, which are started through
intents processed by queryIntentServices() and resolveService().
Without being processed correctly, these service invocation points
may introduce service hijacking a(cid:138)acks or DoS a(cid:138)acks. Detail can
be found in Section 4.3. (cid:140)ird, the Invocation Relationship Analyzer
determines if a service invocation is for same origin service or
third-party service by comparing the intent values with the services
de(cid:128)ned in the manifest.xml. If the class or action a(cid:138)ribute of an
intent is de(cid:128)ned in the manifest.xml, it is a Same Origin invocation.
Implicit intents for the same origin services can be easily converted
to explicit ones by the application developers; while the third-
party services may be correctly converted if those services are
well-known, such as services provided by Google.
(cid:140)e vulnerable service invocation analyzer generates three anal-
ysis results including (i) a list of implicit service invocation position
and the corresponding intent value; (ii) a list of service invoca-
tion position and corresponding intent value, where the intent
used to start the service is processed by queryIntentServices() and
resolveService(); and (iii) the relationship of each service invoca-
tion, i.e, if the service invoked is de(cid:128)ned in the same application or
by a third party application.
4 EVALUATION
In this section, we (cid:128)rst depict the application datasets used in our
study. (cid:140)en, we evaluate the e(cid:130)ectiveness of removing vulnerable
service invocation by directly banning implicit invocations. Finally,
we report the unsolved vulnerable service invocations.
4.1 Android Application DataSets
We focus on analyzing the applications in Google Play Store [18].
To study the real impacts of banning implicit service invocations,
we download two datasets, one before the implicit service invoca-
tion was banned and one a(cid:137)er the implicit service invocation had
been banned. First, we downloaded the top 100 applications for all
the 34 application categories from Google Play store in May 2017,
which include 3251 applications in total. A(cid:137)er removing duplicated
applications in more than one categories, we have 3156 apps.
We meet some challenges to collect applications that were up-
loaded to Google Play Store before the implicit invocation is forbid-
den (i.e., November 2014), since Google Play Store only provides the
newest-version application downloads. Fortunately, we (cid:128)nd an on-
line application archive provided by the PlayDrone Project [1, 39],
which includes 1,490,097 Android applications crawled from Google
Play Store in year 2014.
Among the 3156 applications downloaded in 2017, we can (cid:128)nd
1390 applications in the PlayDrone dataset. (cid:140)erefore, we obtain
two datasets containing the same set of 1390 popular applications
with two di(cid:130)erent versions. We denote the application dataset
downloaded from Google Play Store in May 2017 as “New Apps”,
as they are downloaded a(cid:137)er the implicit service invocation has
been banned almost 30 months. 99.4% applications in the “New
Apps” dataset have been updated a(cid:137)er implicit service invocation
was forbidden. We name the application dataset downloaded from
PlayDrone archive as “Old Apps”, as they are downloaded from
Google Play Store between August 2014 and October 2014, i.e., less
than three months before the implicit service forbidden policy is
enforced.
4.2 E(cid:130)ectiveness on Removing Vulnerable
Service Invocations
We call the service invocations vulnerable to hijacking a(cid:138)acks
or DoS a(cid:138)acks as Vulnerable Service Invocation , which includes
implicit service invocations and vulnerable resolved service invoca-
tions. (cid:140)e former ones are services invoked through implicit intents.
(cid:140)e later ones are services invoked via explicit intents converted
by calling queryIntentServices() or resolveService () APIs, where the
developers do not verify the package names when adopting the
return values of these two APIs. Details of the vulnerable service
invocations in the “New Apps” will be discussed in Section 4.3.
In this section, we show how well the forbidden policy reduces
the vulnerable service invocations. In general, the service invoca-
tion could be divided into two categories, the same origin and third
party. (cid:140)e former one represents the invocation of service de(cid:128)ned
in the same app; while the later one describes the invocation of
service de(cid:128)ned in a di(cid:130)erent app, including the well-known Google
third-party services and various other third-party services.
Figure 5: Reduction of Vulnerable Service Invocations
Figure 5 shows that the numbers of vulnerable service invoca-
tions in the 1390 applications are 643 and 112, before and a(cid:137)er the
implicit service invocation is forbidden, respectively. We can see
the forbidden policy successfully reduce 82.58% vulnerable service
invocations. By carrying out a detailed analysis of the vulnerable
invocations, we (cid:128)nd that most reduction is achieved by resolving
the same origin services (from 304 to 18, 94% reduction) and Google
third party services (from 258 to 32, 87.6% reduction). However,
the decreasing in the other third party services is very limited,
only from 81 to 62 with a 23.46% reduction. Intuitively, it is easy
for the developers to convert the same origin implicit service in-
vocation into an explicit one by se(cid:138)ing the package name with
the return value of getPackageName() API. It is also easy for the
developers to determine the package names for the Google ser-
vices, since the number of involved packages is limited and well
Session E2:  Securing Mobile AppsCCS’17, October 30-November 3, 2017, Dallas, TX, USA1057known. Actually, among the original 47.28% vulnerable invocations
targeting at Google services, only 3 packages are involved, which
are Google Play Service ( “com.google.android.gms” ), Google Play
Store ( “com.android.vending” ), and Google Service Framework
( “com.google.android.gsf” ). (cid:140)e challenges are to determine the
package names for the other third party services, since various pack-
ages could be involved in those service invocations. For example,