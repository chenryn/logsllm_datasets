# PHP框架反序列化入门系列（一）
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 0x0 前言
本文面向拥有一定PHP基础的萌新选手,从反序列化的简略原理->实战分析经典tp5.0.x的漏洞->讨论下CTF做题技巧,后面系列就倾向于针对不同PHP框架如何有效地挖掘反序列化漏洞和快速构造POC的技术探讨。
## 0x1 PHP反序列化原理
序列化技术的出现主要是解决抽象数据存储问题,反序列化技术则是解决序列化数据抽象化的。换句话来说, 一个类的对象,
像这种具有层级结构的数据，你没办法直接像文本那样存储，所以我们必须采取某种规则将其文本化(流化)，反序列化的时候再复原它。
这里我们可以举一个例子:
    t1 = 't1';
    var_dump($obj);
    echo serialize($obj);
    ?>
我们不难看到序列化的过程就是将层次的抽象结构变成了可以用流表示的字符串。
`O:1:"A":3:{s:2:"t1";s:2:"t1";s:5:"At2";s:2:"t2";s:5:"*t3";s:2:"t3";}`
我们可以分析下这个字符串
> public的属性在序列化时，直接显示属性名  
>  protected的属性在序列化时，会在属性名前增加`0x00*0x00`，其长度会增加3  
>  private的属性在序列化时，会在属性名前增加`0x00classname0x00`，其长度会增加`类名长度`+2
反序列化的话,就能依次根据规则进行反向复原了。
## 0x2 PHP反序列化攻击
按道理来说,PHP反序列乍看是一个很正常不过的功能, 为什么我们听到反序列化更多的是将其当作一种漏洞呢? 到底存不存在合理安全的反序列化流程?
回答这个问题, 我们得清楚这个反序列过程,其功能就类似于””创建了一个新的对象”(复原一个对象可能更恰当),
并赋予其相应的属性值,在反序列过程中,如果让攻击者任意反序列数据，
那么攻击者就可以实现任意类对象的创建，如果一些类存在一些自动触发的方法(或者代码流中有一些行为会自动触发一些方法)，那么就有可能以此为跳板进而攻击系统应用。
那么什么是自动触发的方法呢?
在PHP中我们称其为[魔术方法](https://www.php.net/manual/zh/language.oop5.magic.php)
通过阅读文档我们可以发现一个有意思的现象:
我们可以将其理解为 **序列化攻击** ,这里我不展开探讨,欢迎读者去研究。
同样我们可以发现,反序列过程中`__wakeup()`魔术方法会被自动触发,我们可以整理下PHP的各种魔术方法及其触发条件。
>
>     __construct()    #类的构造函数
>     __destruct()    #类的析构函数
>     __call()    #在对象中调用一个不可访问方法时调用
>     __callStatic()    #用静态方式中调用一个不可访问方法时调用
>     __get()    #获得一个类的成员变量时调用
>     __set()    #设置一个类的成员变量时调用
>     __isset()    #当对不可访问属性调用isset()或empty()时调用
>     __unset()    #当对不可访问属性调用unset()时被调用。
>     __sleep()    #执行serialize()时，先会调用这个函数
>     __wakeup()    #执行unserialize()时，先会调用这个函数
>     __toString()    #类被当成字符串时的回应方法
>     __invoke()    #调用函数的方式调用一个对象时的回应方法
>     __set_state()    #调用var_export()导出类时，此静态方法会被调用。
>     __clone()    #当对象复制完成时调用
>     __autoload()    #尝试加载未定义的类
>     __debugInfo()    #打印所需调试信息
>  
这里我们着重需要注意的是:
`__construct()`
`__destruct()`
`__wakeup()`
我们可以写代码验证一下这三者的关系。
    t1 = 't1';
    echo "=====serialize=====";
    echo '';
    echo serialize($obj);
    echo '';
    echo "=====unserialize=====";
    unserialize( serialize($obj));
    echo '';
    ?>
所以说反序列化能直接自动触发的函数就是:`__wakeup` `__destruct`
那么为什么`__construct`不能呢? 我们可以这样理解,因为序列化本身就是存储一个已经初始化的的对象的值了,
所以没必要去执行`__construct`,或者说序列化过程本身没有创建对象这一过程,所以说挖掘PHP反序列化最重要的一步就是通读系统所有的`__wakeup`
`__destruct`函数, 然后于此接着挖掘其他点, 这也是目前大多数反序列化的挖掘思路,
更隐蔽的话比较骚的可能就是那些不是很直接的调用魔术方法的挖掘思路了, 这部分比较难实现自动化(规则很难控制,欢迎师傅找我交流)
那么怎么来实现安全反序列化呢?
**反序列化内容不要让用户控制(加密处理等处理方法), 因为组件依赖相当多,黑名单的路子就没办法行得通的**
但是众所周知,PHP的文件处理函数对`phar`协议处理会自动触发反序列化可控内容,从而大大增加了反序列化的攻击面, 所以说想要杜绝此类问题,
对程序猿的安全觉悟要求相当高, 需要严格控制用户操作比如文件相关操作等。
当然像我这种菜B程序猿采取的方案就是:
**暴力直接写死 **destruct and** wakeup 函数**
###  0x2.1 POP链原理简化
    obj));
        }
    }
    class B{
        public $obj;
        function __toString(){
            var_dump("I am __toString of B!");
            // 触发 __call 方法
            $this->obj->getAttr("test", "t2");
            return "ok";
        }
    }
    class C{
        function __call($t1, $t2){
            var_dump($t1);
            var_dump($t2);
            var_dump("I am __call of C");
        }
    }
    $objC = new C();
    $objB = new B();
    $objA = new A;
    // 触发C的__call，将C类的对象$objC给B的$obj属性。
    $objB->obj = $objC;
    // 这里为了触发的__toString, 将B类的对象$objB给A的$obj属性
    $objA->obj = $objB;
其实这种就是类组合的应用, 一个类A中包含另外一个类B的对象, 然后通过该B对象调用其方法,从而将利用链转移到另外一个类B,
只不过这些方法具备了”自动触发”性质,从而能够实现自动POP到具有RCE功能的类中去。
## 0x3 ThinkPHP5.0.x反序列化漏洞
这个漏洞最早是小刀师傅发现的, ，相当赞的挖掘过程, 与其他经典tp链不太一样,所以我就以此展开来学习了, 这里记录下我的复现过程。
###  0x3.1 安装ThinkPHP5.0.24
`composer create-project --prefer-dist topthink/think=5.0.24 tp5024`
等待下载完即可
###  0x3.2 TP框架知识点入门
`thinkphp/tp5024/application/index/controller/Index.php`
我们修改其内容(手工构造一个反序列化的点,方便调试)
     命名空间是在php5.3中加入的, 其实许多语言(java、c#)都有这个功能。
>
> 简单理解就是分类的标签, 更加简单的理解就是我们常见的目录(其作用就是发挥了命名空间的作用)
>
> 用处:
>
> 1.解决用户编码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突
>
> 2.为很长的标识符名称创建一个别名的名称,提高源代码的可行性
这里展示下几个演示命名空间功能的例子:
  * 1.命名空间用法(1)直接使`namespache`命名空间 
        ";
        echo '"', __NAMESPACE__, '"';
        echo "";
    }
    namespace { //全局空间
         echo '"', __NAMESPACE__, '"';
    }
    #输出output:
    "sp1"
    "sp2"
    ""
  * 2.使用命名空间  
>     1. **非限定名称，或不包含前缀的类名称，** 例如 $a=new foo(); 或
> foo::staticmethod();。如果当前命名空间是 currentnamespace，foo 将被解析为
> currentnamespacefoo。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，则 foo 会被解析为foo。
> 警告：如果命名空间中的函数或常量未定义，则该非限定的函数名称或常量名称会被解析为全局函数名称或常量名称。
>     2. **限定名称,或包含前缀的名称，** 例如 $a = new subnamespacefoo(); 或
> subnamespacefoo::staticmethod();。如果当前的命名空间是 currentnamespace，则 foo 会被解析为
> currentnamespacesubnamespacefoo。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，foo
> 会被解析为subnamespacefoo。
>     3. **完全限定名称，或包含了全局前缀操作符的名称，** 例如， $a = new currentnamespacefoo(); 或
> currentnamespacefoo::staticmethod();。在这种情况下，foo 总是被解析为代码中的文字名(literal
> name)currentnamespacefoo。
>  
>     >          namespace FooBar;
>     include 'file1.php';
>
>     const FOO = 2;
>     function foo() {}
>     class foo
>     {
>       static function staticmethod() {}
>     }
>
>     /* 非限定名称 */
>     foo(); // 解析为函数 FooBarfoo
>     foo::staticmethod(); // 解析为类 FooBarfoo ，方法为 staticmethod
>     echo FOO; // 解析为常量 FooBarFOO
>
>     /* 限定名称 */
>     subnamespacefoo(); // 解析为函数 FooBarsubnamespacefoo
>     subnamespacefoo::staticmethod(); // 解析为类 FooBarsubnamespacefoo,
>                                     // 以及类的方法 staticmethod
>     echo subnamespaceFOO; // 解析为常量 FooBarsubnamespaceFOO
>
>     /* 完全限定名称 */
>     FooBarfoo(); // 解析为函数 FooBarfoo
>     FooBarfoo::staticmethod(); // 解析为类 FooBarfoo, 以及类的方法 staticmethod
>     echo FooBarFOO; // 解析为常量 FooBarFOO
>     ?>
>  
  * 3.别名/导入  
> PHP 命名空间支持 有两种使用别名或导入方式：为类名称使用别名，或为命名空间名称使用别名。
>
> 在PHP中，别名是通过操作符 use 来实现的.
>
> 下面是一个使用所有可能的三种导入方式的例子：
>
> 1、使用use操作符导入/使用别名
>  
>     >          namespace foo;
>     use MyFullClassname as Another;
>
>     // 下面的例子与 use MyFullNSname as NSname 相同
>     use MyFullNSname;
>
>     // 导入一个全局类
>     use ArrayObject;
>
>     $obj = new namespaceAnother; // 实例化 fooAnother 对象
>     $obj = new Another; // 实例化 MyFullClassname 对象
>     NSnamesubnsfunc(); // 调用函数 MyFullNSnamesubnsfunc
>     $a = new ArrayObject(array(1)); // 实例化 ArrayObject 对象
>     // 如果不使用 "use ArrayObject" ，则实例化一个 fooArrayObject 对象
>     ?>
>  
**2.tp中的根命名空间**
> 名称 | 描述 | 类库目录  
> ---|---|---  
> think | 系统核心类库 | thinkphp/library/think  
> traits | 系统Trait类库 | thinkphp/library/traits  
> app | 应用类库 | application  