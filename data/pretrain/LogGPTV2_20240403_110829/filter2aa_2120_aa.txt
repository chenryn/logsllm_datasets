The Dark Side of Winsock - Lecture Notes
(C) 2005 Jonathan Levin, All Rights Reserved
1
The Dark Side of Winsock
By Jonathan Levin
DefCon XIII, Las Vegas
Http://www.securicy.net/Talks/dc-spi.pdf
The Dark Side of Winsock - Lecture Notes
(C) 2005 Jonathan Levin, All Rights Reserved
2
Introduction & Nomenclature
You probably already know this but…
IP communications are implemented using the socket API.
A socket is a transport endpoint, used to send/receive data.
The application reads from/writes to the socket, much as it 
would to any other file descriptor
The OS transparently fragments/encapsulates the data.
This talk assumes you’ve seen sockets in action before. Be it in Stevens’
legendary tomes (TCP/IP Illustrated, UNIX Network Programming..) or 
elsewhere. 
The Dark Side of Winsock - Lecture Notes
(C) 2005 Jonathan Levin, All Rights Reserved
3
Introduction & Nomenclature
You probably already know this too, but…
In UNIX, sockets follow the Berkeley (BSD) model closely
Windows adapted the BSD socket API into WinSock:
Winsock 1.x was a close adaptation of the BSD API
Winsock 2.x added new features
- Asynchronous calls & callbacks
- Overlapped I/O
- The layered service provider (LSP) architecture
(more)
The Dark Side of Winsock - Lecture Notes
(C) 2005 Jonathan Levin, All Rights Reserved
4
Introduction & Nomenclature
However, not too many people know that…
Winsock’s Layered Service Provider architecture provides 
powerful hooking functionality enabling interception, 
eavesdropping or rerouting of almost all IP based traffic 
in windows platforms.
(more)
This talk will focus on the LSP, presenting it’s useful 
(legitimate) applications, and even more useful (but less 
legitimate) ones.
The Dark Side of Winsock - Lecture Notes
(C) 2005 Jonathan Levin, All Rights Reserved
5
Winsock 2 Architecture
Windows is designed in a scalable, multi-layered 
architecture:
The Winsock 2 API provides the main 
The Winsock 2 API provides the main 
entry point for applications. The 
entry point for applications. The ““body
body””
is responsible for multiplexing sockets.
is responsible for multiplexing sockets.
The Transport Driver Interface (TDI) bridges
The Transport Driver Interface (TDI) bridges
calls to the levels below
calls to the levels below
The Network Driver Interface Specification 
The Network Driver Interface Specification 
(NDIS) serves to abstract the hardware, so
(NDIS) serves to abstract the hardware, so
Multiple or different interfaces may be used
Multiple or different interfaces may be used
simultaneously.
simultaneously.
NetBT
TDI
NDIS
Hardware
W
K
S
S
R
V
Winsock 2
API
NetBT (The NetBIOS over TCP/IP interface) is “reserved”, and is used by 
windows’ Workstation and Server services (file and print sharing) to bypass 
“traditional” winsock calls (and is out of our scope anyway). 
All other (user mode) applications use winsock to communicate over the network.
The Dark Side of Winsock - Lecture Notes
(C) 2005 Jonathan Levin, All Rights Reserved
6
NetBT
TDI
NDIS
Hardware
W
K
S
S
R
V
Winsock 2
API
Winsock 2 Architecture
Transport SPI
NameSpace SPI
WSock2_32.DLL
Winsock 2 API
Winsock 2 SPI
Base
Prov n
Base
Prov 1
Prov n
Prov
…
…
While exporting the API, Winsock itself is a client of the SPI ,
or service provider interface, exported to it by the 
miscellaneous service providers installed below it.
Providers may be 
Providers may be 
classified as either:
classified as either:
--TRANSPORT
TRANSPORT
-- NAMESPACE  
NAMESPACE  
The Winsock DLL itself serves as a multiplexer for two types of providers:
- Transport Providers: Protocol stacks, that setup connections, and transfer 
data on the network, possibly supplying features such as QoS, error handling, 
etc.
Windows 2000 ships with two transports:
rsvpsp.dll – implementing RSVP QoS
mswsock.dll – implementing the Winsock core.
The provider is chosen upon socket creation, by the parameters to the Socket() 
(or WSASocket()) call.
- NameSpace Providers: Naming services – suppliers of name resolution 
mechanisms (e.g. implementations of getXXXbyYYY functions). 
Winsock 2000 supports the TCP/IP, NT DS and NLA namespaces.
There can be more than one provider of any type. Winsock accesses the 
providers by their interface, which is the Service Provider Interface, or SPI. 
The Dark Side of Winsock - Lecture Notes
(C) 2005 Jonathan Levin, All Rights Reserved
7
Winsock 2 Architecture
Export Goods (ws2_32.dll)
Winsock provides a potent API for installing custom providers, both namespace and 
transport. In ws2spi.h:
int WSPAPI WSCInstallProvider(
IN LPGUID lpProviderId,
IN const WCHAR FAR * lpszProviderDllPath,
IN const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
IN DWORD dwNumberOfEntries,
OUT LPINT lpErrno
);
int WSPAPI WSCDeinstallProvider(
IN LPGUID lpProviderId,
OUT LPINT lpErrno
);
The Dark Side of Winsock - Lecture Notes
(C) 2005 Jonathan Levin, All Rights Reserved
8
And the namespace ones:
INT WSPAPI WSCInstallNameSpace (
IN LPWSTR lpszIdentifier,
IN LPWSTR lpszPathName,
IN DWORD dwNameSpace,
IN DWORD dwVersion,
IN LPGUID lpProviderId
);
INT WSPAPI WSCUnInstallNameSpace (
IN LPGUID lpProviderId
);
The different header definitions (int vs. INT, and “Deinstall” vs. “Uninstall”) are 
like that in the original ws2spi.h.
The Dark Side of Winsock - Lecture Notes
(C) 2005 Jonathan Levin, All Rights Reserved
9
Winsock 2 Providers
sporder.exe
The sporder DLL and EXE, 
from the platform SDK,
enable enumeration of the 
various providers.
The above is a screen shot of the “SPOrder.EXE”, provided as part of the 
platform SDK. This small utility displays the service providers registered under 
winsock. Note both classes – “Service Providers” (i.e. Transport Service 
Providers) and “Name Resolution” (Namespace Service Providers).
Note each provider structure is quite detailed. The one shown here is for the 
AF_INET (0x02) address family protocol # 0x06 – better known as TCP.
The Dark Side of Winsock - Lecture Notes
(C) 2005 Jonathan Levin, All Rights Reserved
10
Sporder.dll
SPOrder.dll is a small DLL with insidious capabilities – it allows the reordering of service 
providers, by exporting two functions: WSCWriteNameSpaceOrder, and 
WSCWriteProviderOrder. And, as one can deduce by the names – these rewrite the order of the 
layered service providers – namespace and transport, respectively. A further look at the import 
table sheds some light as to how that’s done – using the familiar ADVAPI32.DLL registry 
functions.
One needn’t look hard to understand how to use these functions - These functions are part of the 
Platform SDK, and are defined in sporder.h:
int
WSPAPI
WSCWriteProviderOrder (
IN LPDWORD lpwdCatalogEntryId,
IN DWORD dwNumberOfEntries
);
int
WSPAPI
WSCWriteNameSpaceOrder (
IN LPGUID lpProviderId,
IN DWORD dwNumberOfEntries
);
The Dark Side of Winsock - Lecture Notes
(C) 2005 Jonathan Levin, All Rights Reserved
11
Winsock 2 Providers
Transport providers may be enhanced by LAYERING 
additional providers, and chaining them.
The base service provider 
still  handles the actual 
implementation (i.e. sending 
data, etc.) but layered SPs
may be used for QoS, 
encryption,  security, etc.
So long as all providers in
a chain support SPI , any 
number of providers
may be chained.
Transport SPI
NameSpace SPI
WSock2_32.DLL
Winsock 2 API
Winsock 2 SPI
LSP
Base
Prov 1
Prov n
Prov
…
…
Base
Prov 1
SPI
The Dark Side of Winsock - Lecture Notes
(C) 2005 Jonathan Levin, All Rights Reserved
12
Winsock 2 Providers
Enumerating providers
int WSPAPI WSCEnumProtocols ( 
IN
LPINT               lpiProtocols, 
OUT
LPWSAPROTOCOL_INFOW lpProtocolBuffer,
IN OUT
LPDWORD 
lpdwBufferLength,
OUT
LPINT              lpErrno
);
Usage: Retrieve information about available transport protocols.
Parameters:
lpiProtocols – NULL term. Array of iProtocols to enum, or NULL.
lpProtocolBuffer – buffer of WSAPROTOCOL_INFOW structs
lpdwBufferLength – in/out parameter specifying sizeof..
lpErrNo – Out parameter, holding error code, if any.
Returns: Number of enumerated protocols.
ws2spi.h
The following example demonstrates enumeration of the layered service 
providers, and the WSAPROTOCOL_INFOW structs. Essentially, this is a CLI 
version of sporder.exe from the platform SDK.
Note: it gets the job done. It’s not an example of pretty or “right” coding.
/**
* Winsock 2 API Protocol Enumerator - By PI:EMAIL
* (Standards disclaimers apply)
*/
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#define WINSOCK_API_LINKAGE
#include 
#include 
#include 
#include 
#include 
#include 
#include 
The Dark Side of Winsock - Lecture Notes
(C) 2005 Jonathan Levin, All Rights Reserved
13
char *ExpandServiceFlags(DWORD serviceFlags)
{
/* A little utility function to make sense of all those bit flags */
/* The following code leaks. Yeah, I know.. Go find Buffer 0v3rfl0w$ :-) */
char *serviceFlagsText = (char *) malloc (2048);
memset (serviceFlagsText, '\0', 2048);