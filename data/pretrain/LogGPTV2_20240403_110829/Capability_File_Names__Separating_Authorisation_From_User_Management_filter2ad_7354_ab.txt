Trufﬂes
WebFS
YES
NO
NO
NO
NO
NO
YES
NO
NO
NO
YES/NO
YES/NO
FILE
FILE
DIRECTORY
FILE
VOLUME
FILE
Sharing
YES
YES
YES
YES
YES
YES
Table 1: Comparison of the surveyed ﬁle systems
certifying pathname entirely sufﬁces to name and certify
the ﬁle server.
2.7 WebFS
SFS relies on a trusted third party to authenticate the user
and the client machine. This means that collaboration is
only possible if client and server have a common root for
their certiﬁcation authorities.
It is important to note that SFS self-certifying ﬁle names
are used for authentication, not for authorization. Access
control in SFS relies on user and group IDs, so the inter-
vention of a system administrator with special privileges
is required to create an account before a remote user can
access ﬁles on the server. The authentication framework
introduced with self-certifying ﬁle names is complemen-
tary to the authorization framework introduced with ca-
pability ﬁle names.
WebFS [39, 2]
is a global ﬁle system that uses
HTTP [11] as the transport protocol between client and
ﬁle server. The advantage of this approach is that ex-
isting URLs can be used as ﬁle names and accessed
through the ﬁle system.
Authentication of both clients and servers are based on
X.509 certiﬁcates [3]. WebFS maintains an ACL for
each ﬁle consisting of the X.509 certiﬁcate and per-
missions for each authorised user. Users may therefore
share their ﬁles with anyone who has a certiﬁcate from a
certiﬁcation authority (CA) trusted by the local domain.
Managing the set of trusted CAs requires special privi-
leges. Thus, authorisation in WebFS relies on the hier-
archy of certiﬁcation authorities, which places the users
of WebFS under the control of these certiﬁcation author-
ities.
2.6 Trufﬂes
2.8 Summary
Trufﬂes [31] is a distributed ﬁle system that attempts to
make ﬁle sharing between users in different administra-
tive domains both simple and secure. It uses the Ficus
ﬁle system [15] to offer replication and sharing of ﬁles
and Privacy Enhanced Mail (PEM) as a secure trans-
port mechanism. Trufﬂes allows users to share volumes
(subsets of the entire ﬁle system) with little intervention
from the system administrators once the volumes have
been deﬁned. Ficus replicates volumes using an opti-
mistic one-copy policy and all systems sharing the vol-
ume may hold their own replica. However, ﬁle sharing
relationships and ﬁle data transfer rely on Privacy En-
hanced Mail (PEM) which requires a nonempty intersec-
tion between the public key infrastructures that each user
belongs to; the slow adaptation of secure HTTP shows
how this limits collaboration among users.
A summary the surveyed systems is presented in Table 1.
NFS and AFS are very similar. System administrators
are required to enumerate all exported ﬁle systems and
all machines with remote access. With NFS, all ma-
chines form part of the trusted computing base, while
AFS supports sharing among machines in different ad-
ministrative domains. SFS allows free choice of au-
thentication mechanism, but authorization relies on local
ACLs. Both Trufﬂes and WebFS allows dynamic shar-
ing of ﬁles among users who trust the same certiﬁcation
authority, but it is impossible to share ﬁles with users
without a recognized certiﬁcate. All the surveyed ﬁle
systems provide read/write access and ﬁne granularity,
so they appear not to be real issues. However, one of the
most popular media for information sharing, the web,
provides little support for either.
/capafs/        /         /
port number
host name
{path name, access rights}
K
client part
server part
Figure 1: Basic capability ﬁle name
3 Capability File Names
The goal of capability ﬁle names is to allow users be-
longing to one or more organizations, to set up ad-hoc
work groups without limitations imposed by the system
or the intervention of their system administrators. Each
user in the group should be allowed to share selected
ﬁles with other members of the group, without compro-
mising his remaining ﬁles, nor the ﬁles of other users on
his system.
3.1 Basic Capability File Names
The basic capability ﬁle name consists of two parts, the
“client part” that allows the client machine to identify
the server and the “server part” which allows the server
to identify the ﬁle and encodes the access rights. The
server part is encrypted by the server to protect it from
tampering. The structure of a capability ﬁle name is
shown in Figure 1.
The client part of the capability ﬁle name consists of a
preﬁx (“/capafs/”) that identiﬁes it as a capability
ﬁle name.
It also contains the host name of the ma-
chine running the server and the port number used by
the server.
The server part consists of the absolute path name of the
ﬁle on the server and the permissions (-rwx) granted to
the client presenting the capability ﬁlename. The server
part is encrypted (with key K ) to protect it from tamper-
ing.
This design is similar to the sparse capabilities used in
Amoeba (cf. 2.2). However, sparse capabilities are phys-
ical objects that are supported by the system and ma-
nipulated explicitly by programs. Capability ﬁles names
are virtual objects that require no special support from
the underlying system and they are manipulated as or-
dinary ﬁle names by programs. This difference is best
illustrated by analogy with plane tickets. Traditional ca-
pabilities are equivalent to paper tickets (data structures)
that have to be acquired and presented at the check-in
desk (the ﬁle server) in order to grant access to the ﬂight
(the ﬁle). Capability ﬁle names are equivalent to con-
ﬁrmation numbers used when tickets are bought on the
Web. Knowledge of a valid conﬁrmation number (capa-
bility ﬁle name) is proven to the check-in desk in order
to grant access to the ﬂight.2
3.1.1 Creation of a Capability File Name
Capability ﬁle names are created on the server using a
separate program. This program takes the host name
and the port number that the server is using, the path
name of the ﬁle and the permissions to be encoded into
the capability ﬁle name as parameters. It then reads the
encryption key from a ﬁle stored in the user’s home di-
rectory and encrypts the server part with this key. It then
creates a string by concatenating the preﬁx with the host
name, the port number and the server part and returns
it in a string to the remote user. Only the server needs
the ability to decrypt the server part of the capability ﬁle
name, so a fast symmetric cipher may be used. How-
ever, a number of possible extensions rely on public-key
cryptography, so the server part could also be encrypted
using the server’s private-key. This reduces the number
of keys that the server has to maintain, but it also reveals
the contents of the server part of the capability ﬁle name.
3.1.2 Using Capability File Names
Each user, who wishes to share his ﬁles, must start a
server to act as a proxy for remote ﬁle operations. This
server is described in greater detail in section 4.4.
In order to prevent disclosure of the capability ﬁle names
and to ensure the conﬁdentiality and integrity of trans-
ferred ﬁle data, all communication between client and
server must use a secure channel. This channel must en-
crypt all communication, but need not authenticate the
end-points to each other, e.g., a fast symmetric encryp-
tion algorithm may be used with the Difﬁe-Hellman key
exchange [7]. This solution is vulnerable to the man-in-
the-middle attack, an extension that solves this problem
is proposed in Section 3.2.
2This analogy breaks if two people present the same conﬁrmation
number to the check-in desk. The ﬁle server grants both users access
to the ﬁle, while only one person can physically board the plane.
3.1.3 Delegation of a Capability File Name
Secure delegation of capability ﬁle names is orthogonal
to the mechanism described in this paper, however it is
important that the capability ﬁle name is protected from
disclosure while in transit.
3.1.4 Persistence of a Capability File Name
Capability ﬁle names are not persistent in themselves;
they are simply names (i.e., character strings) that are
lost when the client terminates or if the client fails;
server failure does not affect the validity of a capabil-
ity ﬁle name. However, a capability ﬁle name can be
stored on stable storage or serve as the source of a sym-
bolic link, thus making it persistent. Using a symbolic
link to point to a capability ﬁle name allows its holder
to assign a meaningful name to the remote ﬁle, although
this name only has local signiﬁcance.
3.1.5 Revocation of a Capability File Name
In order to allow revocation of capability ﬁle names, the
server must maintain a capability revocation list (CRL)
of all capability ﬁle names that have been revoked. The
CRL grows with time and searching through it may be-
come prohibitive. One solution is to limit the time that a
capability ﬁle name is valid (i.e., include a timeout value
in the server part). As the timeout is only used on the
server, client and server clocks do not have to be syn-
chronized. However, new versions of the capability ﬁle
names must be acquired when the capability ﬁle name
expires.
Another solution is to mark ﬁles that have a revoked
capability ﬁle name associated with them (e.g., chang-
ing the ﬁles meta-data, such as the inode number), the
CRL is only searched if the ﬁle is marked. The CRL is
still needed because there may be number of valid op-
erations that change the meta data, e.g., restoring a ﬁle
from backups changes the inode number.
3.2 Capability File Names with Server Authen-
tication
The secure communication channel discussed in the ba-
sic scheme above suffers from the man-in-the-middle at-
tack, where a third party intercepts the initial message
from the client and sets up connections to both client and
server. The man-in-the-middle relays all messages be-
tween client and server and knows both keys. We there-
fore need an authentication mechanism that escapes the
problems of centralized control. In order to authenticate
the server, its public-key (SPuK) is added to the client
part of the capability ﬁle name. In this case the server’s
private-key (SPrK) is used to encrypt the server part of
the capability ﬁle name. The structure of a capability ﬁle
name with server authentication is shown in Figure 2(a).
The server is authenticated in the following way before
the client sends the capability ﬁle name to the server.
The client selects a session key to be used by the se-
cure channel. The session key is encrypted with the
server’s public-key and sent to the server. The server
responds with a message encoded with the session key,
which proves its possession of the server’s secret key and
thereby authenticates the server. The client is implic-
itly authenticated as belonging to the set of authorized
user, when the server receives the capability ﬁle name.
This authentication protocol is very similar to the proto-
col used in SFS [23].
3.3 Capability File Names with Client Authen-
tication
As mentioned above, the client is implicitly authenti-
cated through the possession of the capability ﬁle name.
However, knowing the identity of the client “enables
the monitoring, mediating, and recording of capability
propagations to enforce security policies including the
  -property in the Bell-LaPadula model” [14]. Moreover,
it introduces accountability into the system. The struc-
ture of a capability ﬁle name with client (and server) au-
thentication is shown in Figure 2(b).
The identity of the client is used on the server side and
should be included in the server part before the capabil-
ity ﬁle name is given to the client.
The authentication of the client follows the scheme de-
scribed in Section 3.2. After the client has received the
ﬁrst message with the session key from the server, it
signs the capability ﬁle name with his private-key and
sends it to the server. It is important to note that the au-
thentication of the client does not necessarily depend on
his physical identity; the key-pair used could be created
explicitly for this capability ﬁle name.
/capafs/        /         /    /
host name port number SPuK {path name, access rights}
SPrK
client part
server part
(a) Capability ﬁle name with server authentication
/capafs/        /         /    /
host name port number
SPuK
{path name, access rights,       }
CPuK
SPrK
client part
server part
(b) Capability ﬁle name with client authentication
/capafs/        /         /    /                             .{          }