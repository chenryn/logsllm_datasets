示“匹配尽可能多的次数，如果实在无法匹配，也不要紧”。+的意思与之类似，也是匹
配尽可能多的次数，但如果连一次匹配都无法完成，就报告失败。问号、加号和星号这3
个元字符，统称为量词（quantifiers），因为它们限定了所作用元素的匹配次数。
与"？一样，正则表达式中的*也是永远不会匹配失败的，区别只在于它们的匹配结果。
而“+在无法进行任何一次匹配时，会报告匹配失败。
举例来说，？能够匹配一个可能出现的空格，但是*能够匹配任意多个空格。我们可以
用这些量词来简化第9页的例子。按照HTML规范（注7），在tag结尾的>字符
之前，可以出现任意长度的空格，例如或者。把"*加人正则表达式中的可能
出现（但不是必须）空格的位置，就得到H[1-6]·*1。它仍然能够匹配，因为空格并不
是必须出现的，但其他形式的tag也能匹配。
注7：即使你不熟悉HTML规范也不必担心。我把它们当作实际的例子，但是我会提供理解其中
的意义所需的细节。熟悉HTMLtag解析的人可能会认识到我未在本书中提及的重要意义。
---
## Page 45
Egrep元字符
19
接下来看类似这样的HTMLtag，它表示一条高度为14像素的穿越屏幕的水
平线。与的例子一样，在最后的尖括号之前可以出现任意多个空格。此外，在等号两
边也容许出现任意多个空格。最后，在HR和SIZE之间必须有至少-一个空格。为了处理更
多的空格，我们可以在·后添加*，不过最好还是改写为+。加号确保至少有个空格
出现，所以它与“*是完全等价的，只不过更简洁。所以我们得到l。
尽管这个表达式不受空格数目的限制，但它仍然受tag中直线尺寸大小的约束。我们要找的
不仅仅是高度为14的tag，而是所有这些tag。所以，我们必须用能匹配普通数值（general
number）的表达式来替换141。在这里，“数值”（number）是由一位或多位数字（digits）
构成的。[0-9]；可以匹配一个数字，因为“至少出现一次”，所以我们使用加号量词，结果
就是用（0-9]+替换14)。（一个字符组是-个“元素”（unit），所以它可以直接加加号、星
号等，而不需要用括号。）
这样我们就得到了，尽管我用了粗体标识元字符，用空格来分
隔各个元素，而且使用了“看得见的空格符”“”，这个表达式仍然不容易看懂（幸好，egrep
提供了-i的参数15，这样我就不需要用[Hh][Rr]来表示HR了）。否则，更令人迷惑。这个表达式之所以看起来有些诡异，是因为星号和加号作用的对
象大都是空格，而人眼习惯于把空格和普通字符区分开来。在阅读正则表达式时，我们必
须改变这种习惯，因为空格符也是普通字符之一，它与或者4这样的字符没有任何差别
（在后面的章节中，我们会看到，某些工具软件支持忽略空格的特殊模式）。
我们继续这个例子，如果尺寸这个属性也是可选的，也就是说就代表默认高度的直
线（同样，在>之前也可能出现空格）。你能修改我们的正则表达式，让它匹配这两种类型
的tag吗？解决问题的关键在于明白表示尺寸的文本是可选出现的（这是个暗示)。请翻
到下一页查看答案。
请仔细观察最后（答案中）的表达式，体会问号、星号和加号之间的差异，以及它们在实
际应用中的真正作用。下一页的表1-2总结了它们的意义。
请注意，每个量词都规定了匹配成功至少需要的次数下限，以及尝试匹配的次数上限。对
某些量词来说，下限是0，对某些量词来说，上限是无穷大。
---
## Page 46
20
第1章：正则表达式入门
把一个子表达式变为可选项
19页问题的答案
在本例中，“可选出现”（optional）的意思是可以但并不必须匹配一次。这需要使用？1。
因为可选项多于一个字符，所以我们必须使用括号：（）？1。把它插入表达式中，就
得到]
请注意，结尾的*在（）？以外。这样就能应付之类的情况。如果我们把它
包含在括号内，则只有在出现“SIZE=”这段文本的情况下才容许在>之前出现空格。
同样请注意SIZE之前的+包含在括号内。如果把它拿到括号之外，HR之后就必须紧
跟至少一个空格，即使SIZE没有出现也是如此。这样‘’就无法匹配了。
表1-2：“表示重复的元字符”含义小结
次数下限
次数上限
含义
？
无
1
可以不出现，也可以只出现一次（单次可选）
无
可以出现无数次，也可以不出现（任意次数均可）
1
无
可以出现无数次，但至少要出现一次（至少一次）
规定重现次数的范围：区间
某些版本的egrep能够使用元字符序列来自定义重现次数的区间：{min，max}。这称为“区
间量词（intervalquantifier）”。例如，（3，12）能够容许的重现次数在3到12之间。有人
可能会用[a-zA-Z]（1，5）来匹配美国的股票代码（1到5个字母）。问号对应的区间量词
是（0,1）。
支持区间表示法的egrep的版本并不多，但有许多另外的工具支持它。在第3章我们会仔细
考察目前经常使用的元字符，那时候会涉及区间的支持问题。
括号及反向引用
Parenthesesand Backreferences
到目前为止，我们已经见过括号的两种用途：限制多选项的范围：将若干字符组合为一个
单元，受问号或星号之类量词的作用。现在我要介绍括号的另一种用途，虽然它在egrep中
并不常见（不过流行的GNU版本确实支持这一功能），但在其他工具软件中很常见。
---
## Page 47
Egrep元字符
21
在许多流派（flavor）的正则表达式中，括号能够“记住”它们包含的子表达式匹配的文本。
在解决本章开始提到的单词重复问题时就会用到这个功能。如果我们确切知道重复单词的
第一个单词（比方说这个单词就是“the"），就能够明确无误地找到它，例如'the"he。这
样或许还是会匹配到the·theory的情况，但如果我们的egrep支持在第15页提到的单词分
界符the·the\>，这个问题就很容易解决。我们可以添加+把这个表达式变得更灵活。
然而，穷举所有可能出现的重复单词显然是不可能完成的任务。如果我们先匹配任意一个
单词，接下来检查“后面的单词是否与它一样”，就好办多了。如果你的egrep支持“反向
引用（backreference）”，就可以这么做。反向引l用是正则表达式的特性之一，它容许我们匹
配与表达式先前部分匹配的同样的文本。
我们先把\中的第一个the替换为能够匹配任意单词的正则表达式
[A-Za-z]+；然后在两端加上括号（原因见下段）；最后把后一个‘the’替换为特殊的元
字符序列\1)，就得到了\l
在支持反向引用的工具软件中，括号能够“记忆”其中的子表达式匹配的文本，不论这些
文本是什么，元字符序列1都能记住它们。
当然，在一个表达式中我们可以使用多个括号。再用1、2、3等来表示第-、第二、
第三组括号匹配的文本。括号是按照并括号·（”从左至右的出现顺序进行的，所以
（[a-z]）（[0-9]）\1\2)中的\1代表[a-z]匹配的内容，而2代表[0-9]匹配的内容。
在“thethe”的例子中，[A-Za-z]+匹配第一个‘the”。因为这个子表达式在括号中，所
以\1i代表的文本就是“the'。如果‘+能够匹配，后面的1i要匹配的文本就是‘the'。
如果\1i也能成功匹配，最后的\>对应单词的结尾（如果文本是‘the*theft'，这一条就
不满足）。如果整个表达式能匹配成功，我们就得到一个重复单词。有的重复单词并不是错
误，例如“thatthat’（译注3)，这并不是正则表达式的错误，真正的判断还得靠人。
我决定使用上面这个例子的时候，已经用这个表达式检查过本书之前的内容了（我使用的
是支持和反向引用的egrep)。我还使用了第15页提到的忽略大小写的参数-i来拓
宽它的适用范围（注8)，所以‘The'the’这样的单词重复也能提取出来。
译注3：在英文中有可能出现两个连续的that，例如Andwethinkthat thatstandardhasbeenmee
here。其中第一个that表示宾语从句的引导词，第二个用于修饰standards。
注8：某些版本的egrep，包括一些流行的GNU版本的egrep在内，它们的-i参数都存在一个
bug，即不会对反向引用的内容忽略大小写，也就是说，它可以找到“thethe”、但找不到
"Thethe”。
---
## Page 48
22
第1章：正则表达式入门
我使用的命令如下：
egrep -i*\'files
结果令我惊奇，居然找到了14组重复单词。我把它们全都改正了，而且把这个表达式添加
到我用来检查本书拼写错误的工具中，保证从此以后全书中不会出现这样的错误。
尽管这个表达式很有用，我们仍然需要重视它的局限。因为egrep把每行文字都当作-个独
立部分来看待，所以如果单词重复的第一个单词在某行末尾，第二个单词在下一行的开头，
这个表达式就无法找到。所以，我们需要更加灵活的工具，下一章我们会看到这方面的例
子。
神奇的转义
Fhe Greot E、1当作元字符序列对待。在后面的章节中我们会看到更
多的例子。
注9：大多数程序设计语言和工具都支持字符组内部的转义，但是大多数版本的egrep不支持，
它们会把反斜线“1当作宇符组内部列出的普通宇符。
---
## Page 49
基础知识拓展
23
基础知识拓展
Expnnding thre Fondation
我希望，前面的例子和解释已经帮助读者牢固地打下了正则表达式的基础，也请读者明白，
这些例子都很浅显，我们需要掌握的还有很多。
语言的差异
Linguistic Dicersification
我已经介绍过大多数版本的egrep支持的正则表达式的特性，这样的特性还有很多，其中一
些并不是所有的版本都支持，这个问题留到后面的章节讲解。
任何语言中都存在不同的方言和口音，很不幸，正则表达式也一样。情况似平是、每一种
支持正则表达式的语言都提供了自己的“改进”。正则表达式不断发展，但多年的变化也造
就了数目众多的正则表达式“流派”（flavor）。我们会在下面的章节中见到各种例子。
正则表达式的目标
The Goal of a Regrlar Expression
从最宏观的角度看，一个正则表达式要么能够匹配给定文本（对egrep来说，就是一行文本）
中的某些字符，要么不能匹配。在编写正则表达式的时候，我们必须进行权衡：匹配符合
要求的文本，同时忽略不符合要求的文本。
重要。如果文本是这样：
.zip is 44272. If you write, send $4.95 to cover postage and
我们只希望找出包含“（0-9】+的那些行，就不需要关心真正匹配的数字。相反，如果我们
需要操作这些数字（例如保存到文件、添加、替换之类一一我们会在下一章看到这样的处
理），就需要关心确切匹配的那些数字。
更多的例子
A Few More Examples
在任何语言中，经验都是非常重要的，所以我会给出更多用正则表达式匹配常用文本结构
的例子。
编写正则表达式时，按照预期获得成功的匹配要花去一半的工夫，另一半的工夫用来考
虑如何忽略那些不符合要求的文本。在实践中，这两方面都非常重要，但是目前我们只关
注“获得成功匹配”的方面。即使我没有对这些例子进行最全面彻底的解释，它们仍然能
够提供有用的启示。
---
## Page 50
24
第1章：正则表达式入门
变量名
许多程序设计语言都有标识符（identifier，例如变量名）的概念，标识符只包含字母、数字
以及下画线，但不能以数字开头。我们可以用[a-zA-Z_][a-2A-Z_0-9]*来匹配标识符。
第一个字符组匹配可能出现的第一个字符，第二个（包括对应的*）匹配余下的字符。如
果标识符的长度有限制，例如最长只能是32个字符，又能使用第20页介绍的区间量词min
max}，我们可以用（0，31）：来替代最后的*1。
引号内的字符串
匹配引号内的字符串最简单的办法是使用这个表达式："[^"]*"1。
两端的引号用来匹配字符串开头和结尾的引号。在这两个引号之间的文本可以包括双引号
之外的任何字符。所以我们用[^"]来匹配除双引号之外的任何字符，用*来表示两个引
号之间可以存在任意数目的非双引号字符。
关于引号字符串，更有用（也更复杂）的定义是，两端的双引号之间可以出现由反斜线转
义的双引号，例如"nail·the·2\"x4\"plank"。在后面的章节讲解匹配实际进行的细节时，
我们会多次遇到这个例子。
美元金额（可能包含小数）
\S[0-9]+（\.[0-9][0-9]）？是一种匹配美元金额的办法。
从整体上看，这个表达式很简单，分为三部分：$、“…+和（）？，可以大致理解为：一
个美元符号，然后是一组字符，最后可能还有另一组字符。这里的“字符”指的是数字（一
从几个方面来看，这个表达式还很简陋。比如，它只能接受$1000，而无法接受$1，000。
它确实能接受可能出现的小数部分，但对于egrep来说意义不大。因为egrep从不关心匹配
文字的内容，而只关心是否存在匹配。处理可能出现的小数部分对整个表达式能否匹配并
没有影响。
但是，如果我们需要找到只包含价格而不含其他字符的行，倒是可以在这个表达式两端加
上$。这样一来，可选的小数部分就变得很重要了，因为在金额数值和换行符之间是否
存在小数部分，决定了整个表达式的匹配结果是否存在差异。
---
## Page 51
基础知识拓展
25
另外，这个正则表达式还无法匹配‘S.49'。你可能认为把加号换成星号能够解决问题，不
过这条路走不通。在这我先卖个关子，答案留待第5章（194）揭晓。
HTTP/HTMLURL
WebURL的形式可能有很多种，所以构造一个能够匹配所有形式的URL的正则表达式颇有
难度。不过，稍微降低一点要求的话，我们能够用一个相当简单的正则表达式来匹配大多
数常见的URL。进行这种检索的原因之一是，我只能大概记得在收到的某封邮件中有一个
URL地址，不过一见到它我就能认出来。
常见的HTTP/HTMLURL是下面这样的：
http://hostname/path.html
当然，.htm的结尾也很常见。
hostname（主机名，例如www.yahoo.com）的规则比较复杂，但是我们知道，跟在‘http：//
之后的就有可能是主机名，所以这个正则表达式就很简单，[-a-z0-9_.]+1。path部分的变
化更多，所以我们需要使用[-a-z0-9_：@&？=+，.!/~*$$]*1。请注意，连字符必须放在字
符组的开头，保证它是一个普通字符，而不是用来表示范围（9）。
综合起来，我们第一次尝试的正则表达式就是：
egrep-i\
files
因为我们降低了对匹配的要求，所以‘http：//..../foo.html’也能匹配，虽然它显然不
是一个合法的URL。我们需要关心这一点吗？这取决于具体的情况。如果我只是需要扫描
自己的E-mail，得到一些错误结果并不算是问题。而且，我没准会用更简单的表达式：
egrep-i\′files
在深人了解如何调校正则表达式之后，读者会明白，要想在复杂性和完整性之间求得平衡，