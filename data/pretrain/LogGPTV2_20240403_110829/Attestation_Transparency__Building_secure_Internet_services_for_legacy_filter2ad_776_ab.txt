set forth below, which includes insider attacks. While we
cannot absolutely prevent insiders from violating security,
the transparency mechanism guarantees that such violations
will be publicly detectable.
Users of a secure service must be able to verify that their
client is connected to a speciﬁc service that is known to pro-
vide those security properties. Legacy clients must be sup-
ported: users must be able to obtain most of the security
beneﬁts without installing special software. Beyond legacy
clients there must be an incremental deployment path. Per-
formance loss compared to insecure services should be min-
imal. Services must also be updateable, and the security
properties must be maintained in the update process.
3.1 Threat model
We assume the server hosting the service uses some secure
enclave technology that prevents the adversary from access-
ing the code and data running in the enclave. We allow
adversaries all the capabilities of an active network attacker
as well as full control over non-enclave software running on
the computer hosting the service (e.g., for SGX enclaves, this
includes control over the operating system). For instance,
an insider might add malicious software, or service provider
personnel might accidentally misconﬁgure the service; these
are included in the threat model. The adversary also has the
ability to run its own servers mimicking real services. We
assume the user’s client is secure and cannot be tampered
with. The threat model is depicted in Figure 1.
Availability is out of scope for this paper. If a malicious
insider wishes to destroy all user data or deny access to the
service, they can do so.
3.2 Design overview
The basic idea is to run all of the service code—including
TLS session establishment, request handling, and storage—
in an enclave on the server. This provides isolation and
ensures that even insiders on the server cannot tamper with
the running code or memory of the service. Also, we use
sealed storage to prevent malicious insiders from reading or
modifying data stored by the service on persistent storage:
eﬀectively, all data is encrypted before it leaves the enclave.
Client
Internet
Secure
enclave
Server
User
Admin
Figure 1: Secure service threat model. The shaded
areas may be controlled by the adversary.
3
The user connects to the server, using TLS to establish a
secure channel between the client and server. We use remote
attestation to allow the user to verify what code is running in
the enclave: secure hardware on the server provides a signed
statement indicating what code has been loaded into the
enclave. A fully attestation-aware client would then use this
attestation to verify that the server is running the expected
code.
We also show how legacy clients can access the server and
gain a subset of the security guarantees. Legacy clients also
connect to the server via TLS. Conveniently, the TLS pro-
tocol is widely supported and provides a secure channel to
the server, while verifying the authenticity of that server.
As is usual for TLS, the client checks that the server’s TLS
certiﬁcate is valid and authenticates the server using the
public key found in this certiﬁcate. Our system extends the
guarantees provided by this authentication step by further
constraining the use of the private key.
In particular, a secure service runs inside a secure enclave
and it will generate its TLS private key there. The TLS
private key will never leave the enclave in unencrypted form;
it is stored using sealed storage, so that only the enclave can
retrieve it. Thus, even insiders cannot learn the service’s
TLS private key.
When the service is ﬁrst created, it publishes its TLS pub-
lic key in an attested statement proving that the enclave was
launched with a certain code and that that code generated
the key. Legacy clients not built with Attestation Trans-
parency in mind won’t be able to verify these attestations,
but the key idea of our system is that another party can
do so on their behalf. Because the attestations are pub-
lic, anyone can check what code the service will run, that
the code is secure, that it will never reveal its TLS private
key, and that it protects itself adequately from malicious
insiders. This allows word to spread through out-of-band
channels that the service is trustworthy. For instance, an
expert might inspect the code published by good.com and
determine that it is trustworthy and will never leak its TLS
private key; inspect the attestation and TLS certiﬁcate and
determine that the TLS keypair was generated by this en-
clave, and the public part is in the TLS certiﬁcate; and then
spread the word that good.com can be trusted.
Of course, a malicious insider at good.com could always
take down the secure service and replace it with malicious
code, running outside an enclave. An attestation-aware
client could detect this (because the attestation will change),
but a legacy client could not. However, this attack is de-
tectable. To mount such an attack, the insider would need
to generate a TLS keypair and get a new certiﬁcate issued
for it (because legacy clients expect to connect over TLS),
and hand the new private key to the malicious code. This
is detectable because it triggers issuance of a new certiﬁcate
for good.com. In particular, we use Certiﬁcate Transparency
to detect issuance of new certiﬁcates. In our design, secure
services publicly commit to always publish a new attestation
any time they update the service or obtain a new certiﬁcate.
Thus, issuance of a new certiﬁcate without a corresponding
published attestation indicates an attack or error. Crucially,
because all of this information is public, anyone can mon-
itor the published information and detect these situations,
providing transparency.
Because our design focuses on transparency about what
code the service will run, we call it Attestation Transparency.
Figure 2: Overview of Attestation Transparency. (1)
The secure service emits the certiﬁcate request and attested
statement. (2) The attested statement and certiﬁcate are
submitted to the Attestation and Certiﬁcate Transparency
logs. (3) The secure service receives the certiﬁcate produced
by the CA. (4) The user can now establish a regular TLS
connection with the secure service. (5) The transparency log
monitor independently monitors the transparency logs for
possible violations.
It extends Certiﬁcate Transparency to allow publishing these
independently-auditable attestations. Legacy clients can
rely on Certiﬁcate Transparency to ensure that attacks will
be publicly detectable, while future attestation-aware clients
can verify attestations themselves.
A diagram of the entire system is shown in Figure 2.
3.3 Policy model
To verify that a secure service will act “as promised”, the
user must verify that (a) the service code correctly imple-
ments the intended behavior and (b) no other program on
the same computer will be able to interfere with the opera-
tion of the service code or observe its memory. The mecha-
nisms described below allow a service to prove to a user what
service code will execute on the server enclave. Thus, in
principle, a user could examine all of the code and convince
themselves that it will act “as expected” and will provide all
the desired security guarantees. However, in practice few
users will be able to do this: code analysis is expensive and
beyond the capabilities of most end users.
To address this challenge, we provide several ﬂexible
mechanisms to enable users to verify that the service code
will meet their needs (§5.3). One option is that the user
may rely on a cryptographically signed statement from the
secure service developer naming both the service identity
and the (user comprehensible) promised behavior. Since the
developer can produce the implementation corresponding to
the identity, it can be veriﬁed by third parties or used as
a basis for legal recourse in the case the service does not,
in fact, conform to the promised behavior. Alternatively, a
user can rely on either an authority (for example, in the case
4
……………...www.www.TLS ConnectionSecure EnclaveServerCertificate request &Attested statementwww.CertificationAuthorityCertificateTransparency logAttestationTransparency logUserTransparencylog monitorTLSCertTLS private key1.2(a)2(b)3.4.5(a)5(b)of an enterprise service, the enterprise “IT” department) or
an auditor to decide which services are trustworthy. The
authority cryptographically signs a statement representing
that the service code conforms with expected behavior in all
respects. These can be securely and automatically checked
if so designated. Alternatively, a user may rely on a set of
reviewers of the secure service code who cryptographically
sign such statements. Reviewers might have diﬀerent mo-
tivations, some altruistic and some self-serving. Further, a
user may employ policy rules to automatically determine
if the speciﬁed behaviors are adequate. For example, the
user may insist that the EFF examine the service and cer-
tify that it meets a designated privacy policy, and that a
consumer agency or a product reviewer also sign a confor-
mance statement, and that the developer be one of a named
set of developers that the user feels comfortable with. There
are other alternatives that ensure compliance with the user’s
needs and relieve the user of the need to conduct extensive
reviews themselves.
Usually, a user will use the same policy model to decide
whether an update meets those same speciﬁed needs and,
if it does, whether user data accessible to previous versions
can be made available to subsequent versions.
4. SECURE SERVICE DESIGN
This section presents the architecture we use to implement
unalterable secure services. Unalterable here means that the
functionality of the service cannot be changed. This allows
a client of the service to view the service as an extension of
the client itself and not just a third-party program subject
to the whims of another entity.
Our architecture runs services inside a secure enclave as
well as to encourage secure software development. To reduce
the attack surface, the architecture presents a limited inter-
face to the programmer that should be suﬃcient for Internet
services, and the interface is implemented in a memory-safe
and type-safe language, Rust.3
4.1 Secure service interface
In our architecture (Figure 3), only the CPU and the code
inside the secure enclave are trusted. The secure enclave
has no input/output capabilities and relies on an untrusted
driver for (insecure) access to the outside world. to commu-
nicate with the outside world. The untrusted driver is part
of the host operating system and provides persistent storage
(e.g., via C Standard I/O Streams), networking (e.g., via
BSD sockets), and inter-process communication (e.g., via
stdin/stdout/stderr). On top of this, the secure enclave li-
brary implements encrypted networking using TLS (e.g., us-
ing a standard TLS library), encrypted and sealed storage,
attestation, and IPC. Software developers use these secure
primitives to write their secure service. The secure enclave
library and application code together form the secure en-
clave.
Secure networking Secure networking is provided us-
ing TLS. The secure client interface allows connecting to an
Internet address using TLS and verifying the connection us-
ing default methods (per RFC 5280 [13] and RFC 6125 [32]).
There is also an option to connect to another secure service
running in an enclave and have it attest to the secure channel
parameters. The client will then verify that the attestation
3Available at https://github.com/jethrogb/secserv/.
Table 1: Secure storage types
Beneﬁt
Protect against blanket access after breach
Protect against oﬄine attack versus weak user key (cid:88)
Recover data after hardware failure
S
K
e
ale
e
y
e
d
d
B
oth
(cid:88) (cid:88)
(cid:88)
(cid:88)
is valid and matches the expected server enclave identity.
The secure server interface will listen on a speciﬁed port
and accept TLS connections from clients. This is the main
communication mechanism for a service using our architec-
ture. There is also an option to accept connections from
clients that are themselves running in an enclave and have
that client identify itself and attest to the secure channel
parameters.
Secure storage The secure storage interface allows the
application to store persistent data safely. The interface
provides access to diﬀerent data objects identiﬁed by their
name or path, while using an encrypted storage backend.
There are three possible keying schemes for encrypting the
data before storage: using the sealing key, a user key, or
both (encrypted with a user key, then sealed). The diﬀerent
schemes have diﬀerent beneﬁts as shown in Table 1. In case
of a breach—e.g., due to a faulty update (see §5.3), or a
code bug—using sealing only, in its simplest form, is inade-
quate. Further, sealing—in its simplest form—is hardware-
dependent and any sealed data is lost after a hardware fail-
ure. Using a per-user key based on the user’s password
enables password-guessing attacks if the password is weak.
This is of particular concern since in addition to online at-
tacks via the normal service authentication mechanism that
all Internet services have to deal with, in our model an ad-
versary can perform oﬄine attacks on the stored data.
Attestation The attestation interface allows a secure
It can also
enclave to have the hardware attest to a key.
verify that attested statements match a certain identity and
extract the key that was attested to.
IPC Services may use inter-process communication,
e.g., for inputting conﬁguration data and logging. Since
this channel is not secure, no sensitive information should
be logged through this channel, and it must not be used
for conﬁguration that changes the security properties of the
service. Instead, such conﬁguration needs to be part of the
enclave measurement.
4.2 Secure server
Secure enclave
Application
code
Untrusted
driver
Enclave
library
Operating system
Network
Storage
CPU
Figure 3: Secure service architecture. The shaded
blocks are not trusted.
5
Using the primitives deﬁned in the previous section, we
can build an unalterable secure service. Keeping the private
key K−1
server of a TLS server in sealed storage and never ex-
porting the key outside the enclave ensures only a particular
secure enclave instance can have access to it. This means
that when one establishes a TLS connection with a server
that uses that Kserver to authenticate its key exchange, the
server endpoint is guaranteed to terminate inside the en-
clave.
Since the private key should never exist outside the en-
clave, it must be generated inside the enclave. The key setup
procedure for the secure service enclave is shown in Figure 4.
Input and output happens through the IPC channel.
All the service’s static content (e.g., for a website, im-
ages and layout elements) must be included in the server
binary that will be measured upon enclave startup. All dy-
namic/user content must be stored in secure storage.
4.2.1 Horizontal scaling
Once one instance of a service is running, another instance
can connect to it and they can both verify that they’re in-
stances of the same program. After the veriﬁcation, sensi-
tive information can be shared (over a secure channel estab-
lished using a secure key-exchange protocol). Any kind of
distributed service can be supported this way.
4.2.2 Multiple enclaves
A service might consist of multiple parts, for example a
database server and an application server. The enclaves
should validate each other’s identity and establish a secure
channel between the two. There are at least two secure ways
to implement this.
Consider an enclave A that accepts connections from
clients and provides controlled access to information based
on the client’s identity. A second enclave B wants to use en-
clave A’s service and has ﬁxed A’s identity in its loaded and
measured code. Enclaves A and B establish a secure channel
and both attest to their parameters. Enclave B can verify
A’s attestation and see that the identity matches what is
expected. Enclave A can verify B’s attestation and provide
B access to the information B is authorized to access.
If both enclaves must verify each other’s identity using em-