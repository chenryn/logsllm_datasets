restrict pt
下⾯例⼦的变量 ，就不能使⽤ 修饰符。
foo restrict
int foo[10];
int* bar = foo;
上⾯示例中，变量 指向的内存，可以⽤ 访问，也可以⽤ 访问，因此就不能将 设为
foo foo bar foo
restrict。
如果编译器知道某块内存只能⽤⼀个⽅式访问，可能可以更好地优化代码，因为不⽤担⼼其他地⽅会修改
值。
⽤于函数参数时，表示参数的内存地址之间没有重叠。
restrict
void swap(int* restrict a, int* restrict b) {
int t;
t = *a;
*a = *b;
*b = t;
}
上⾯示例中，函数参数声明⾥的 表示，参数 和参数 的内存地址没有重叠。
restrict a b
全⽂完
本⽂由 简悦 SimpRead 转码，⽤以提升阅读体验，原⽂地址
多⽂件项⽬ 语⾔教程 ⽹道
- C -
⽹道（WangDoc.com），互联⽹⽂档计划
“
⽹道（WangDoc.com），互联⽹⽂档计划
简介 #
⼀个软件项⽬往往包含多个源码⽂件，编译时需要将这些⽂件⼀起编译，⽣成⼀个可执⾏⽂件。
假定⼀个项⽬有两个源码⽂件 和 ，其中 是主⽂件， 是库⽂件。所谓 “主⽂
foo.c bar.c foo.c bar.c
件”，就是包含了 函数的项⽬⼊⼝⽂件，⾥⾯会引⽤库⽂件定义的各种函数。
main()
#include 
int main(void) {
printf("%d\n", add(2, 3));
}
上⾯代码中，主⽂件 调⽤了函数 ，这个函数是在库⽂件 ⾥⾯定义的。
foo.c add() bar.c
int add(int x, int y) {
return x + y;
}
现在，将这两个⽂件⼀起编译。
$ gcc -o foo foo.c bar.c
$ gcc -o foo *.c
上⾯命令中，gcc 的 参数指定⽣成的⼆进制可执⾏⽂件的⽂件名，本例是 。
-o foo
这个命令运⾏后，编译器会发出警告，原因是在编译 的过程中，编译器发现⼀个不认识的函数
foo.c
， ⾥⾯没有这个函数的原型或者定义。因此，最好修改⼀下 ，在⽂件头部加⼊
add() foo.c foo.c
的原型。
add()
#include 
int add(int, int);
int main(void) {
printf("%d\n", add(2, 3));
}
现在再编译就没有警告了。
你可能⻢上就会想到，如果有多个⽂件都使⽤这个函数 ，那么每个⽂件都需要加⼊函数原型。⼀旦
add()
需要修改函数 （⽐如改变参数的数量），就会⾮常麻烦，需要每个⽂件逐⼀改动。所以，通常的做
add()
法是新建⼀个专⻔的头⽂件 ，放置所有在 ⾥⾯定义的函数的原型。
bar.h bar.c
int add(int, int);
然后使⽤ 命令，在⽤到这个函数的源码⽂件⾥⾯加载这个头⽂件 。
include bar.h
#include 
#include "bar.h"
int main(void) {
printf("%d\n", add(2, 3));
}
上⾯代码中， 表示加⼊头⽂件 。这个⽂件没有放在尖括号⾥⾯，表示它是⽤户提
#include "bar.h" bar.h
供的；它没有写路径，就表示与当前源码⽂件在同⼀个⽬录。
然后，最好在 ⾥⾯也加载这个头⽂件，这样可以让编译器验证，函数原型与函数定义是否⼀致。
bar.c
#include "bar.h"
int add(int a, int b) {
return a + b;
}
现在重新编译，就可以顺利得到⼆进制可执⾏⽂件。
$ gcc -o foo foo.c bar.c
重复加载 #
头⽂件⾥⾯还可以加载其他头⽂件，因此有可能产⽣重复加载。⽐如， 和 都加载了 ，然后
a.h b.h c.h
同时加载了 和 ，这意味着 会编译两次 。
foo.c a.h b.h foo.c c.h
最好避免这种重复加载，虽然多次定义同⼀个函数原型并不会报错，但是有些语句重复使⽤会报错，⽐如
多次重复定义同⼀个 Struct 数据结构。解决重复加载的常⻅⽅法是，在头⽂件⾥⾯设置⼀个专⻔的宏，加
载时⼀旦发现这个宏存在，就不再继续加载当前⽂件了。
#ifndef BAR_H
#define BAR_H
int add(int, int);
#endif
上⾯示例中，头⽂件 使⽤ 和 设置了⼀个条件判断。每当加载这个头⽂件时，就会
bar.h #ifndef #endif
执⾏这个判断，查看有没有设置过宏 。如果设置过了，表明这个头⽂件已经加载过了，就不再重复
BAR_H
加载了，反之就先设置⼀下这个宏，然后加载函数原型。
extern 说明符 #
当前⽂件还可以使⽤其他⽂件定义的变量，这时要使⽤ 说明符，在当前⽂件中声明，这个变量是其
extern
他⽂件定义的。
extern int myVar;
上⾯示例中， 说明符告诉编译器，变量 是其他脚本⽂件声明的，不需要在这⾥为它分配内
extern myvar
存空间。
由于不需要分配内存空间，所以 声明数组时，不需要给出数组⻓度。
extern
extern int a[];
这种共享变量的声明，可以直接写在源码⽂件⾥⾯，也可以放在头⽂件中，通过 指令加载。
#include
static 说明符 #
正常情况下，当前⽂件内部的全局变量，可以被其他⽂件使⽤。有时候，不希望发⽣这种情况，⽽是希望
某个变量只局限在当前⽂件内部使⽤，不要被其他⽂件引⽤。
这时可以在声明变量的时候，使⽤ 关键字，使得该变量变成当前⽂件的私有变量。
static
static int foo = 3;
上⾯示例中，变量 只能在当前⽂件⾥⾯使⽤，其他⽂件不能引⽤。
foo
编译策略 #
多个源码⽂件的项⽬，编译时需要所有⽂件⼀起编译。哪怕只是修改了⼀⾏，也需要从头编译，⾮常耗费
时间。
为了节省时间，通常的做法是将编译拆分成两个步骤。第⼀步，使⽤ GCC 的 参数，将每个源码⽂件单
-c
独编译为对象⽂件（object file）。第⼆步，将所有对象⽂件链接在⼀起，合并⽣成⼀个⼆进制可执⾏⽂
件。
$ gcc -c foo.c
$ gcc -c bar.c
$ gcc -c *.c
上⾯命令为源码⽂件 和 ，分别⽣成对象⽂件 和 。
foo.c bar.c foo.o bar.o
对象⽂件不是可执⾏⽂件，只是编译过程中的⼀个阶段性产物，⽂件名与源码⽂件相同，但是后缀名变成
了 。
.o
得到所有的对象⽂件以后，再次使⽤ 命令，将它们通过链接，合并⽣成⼀个可执⾏⽂件。
gcc
$ gcc -o foo foo.o bar.o
$ gcc -o foo *.o
以后，修改了哪⼀个源⽂件，就将这个⽂件重新编译成对象⽂件，其他⽂件不⽤重新编译，可以继续使⽤
原来的对象⽂件，最后再将所有对象⽂件重新链接⼀次就可以了。由于链接的耗时⼤⼤短于编译，这样做
就节省了⼤量时间。
make 命令 #
⼤型项⽬的编译，如果全部⼿动完成，是⾮常麻烦的，容易出错。⼀般会使⽤专⻔的⾃动化编译⼯具，⽐
如 make。
make 是⼀个命令⾏⼯具，使⽤时会⾃动在当前⽬录下搜索配置⽂件 makefile（也可以写成 Makefile）。
该⽂件定义了所有的编译规则，每个编译规则对应⼀个编译产物。为了得到这个编译产物，它需要知道两
件事。
依赖项（⽣成该编译产物，需要⽤到哪些⽂件）
⽣成命令（⽣成该编译产物的命令）
⽐如，对象⽂件 是⼀个编译产物，它的依赖项是 ，⽣成命令是 。对应的编译规
foo.o foo.c gcc -c foo.c
则如下：
foo.o: foo.c
gcc -c foo.c
上⾯示例中，编译规则由两⾏组成。第⼀⾏⾸先是编译产物，冒号后⾯是它的依赖项，第⼆⾏则是⽣成命
令。
注意，第⼆⾏的缩进必须使⽤ Tab 键，如果使⽤空格键会报错。
完整的配置⽂件 makefile 由多个编译规则组成，可能是下⾯的样⼦。
foo: foo.o bar.o
gcc -o foo foo.o bar.o
foo.o: bar.h foo.c
gcc -c foo.c
bar.o: bar.h bar.c
gcc -c bar.c
上⾯是 makefile 的⼀个示例⽂件。它包含三个编译规则，对应三个编译产物（ 、 和
foo.o bar.o
），每个编译规则之间使⽤空⾏分隔。
foo
有了 makefile，编译时，只要在 make 命令后⾯指定编译⽬标（编译产物的名字），就会⾃动调⽤对应的
编译规则。
$ make foo.o
$ make bar.o
$ make foo
上⾯示例中，make 命令会根据不同的命令，⽣成不同的编译产物。
如果省略了编译⽬标， 命令会执⾏第⼀条编译规则，构建相应的产物。
make
$ make
上⾯示例中， 后⾯没有编译⽬标，所以会执⾏ makefile 的第⼀条编译规则，本例是 。由
make make foo
于⽤户期望执⾏ 后得到最终的可执⾏⽂件，所以建议总是把最终可执⾏⽂件的编译规则，放在
make
makefile ⽂件的第⼀条。makefile 本身对编译规则没有顺序要求。
make 命令的强⼤之处在于，它不是每次执⾏命令，都会进⾏编译，⽽是会检查是否有必要重新编译。具体
⽅法是，通过检查每个源码⽂件的时间戳，确定在上次编译之后，哪些⽂件发⽣过变动。然后，重新编译
那些受到影响的编译产物（即编译产物直接或间接依赖于那些发⽣变动的源码⽂件），不受影响的编译产
物，就不会重新编译。
举例来说，上次编译之后，修改了 ，没有修改 和 。于是，重新运⾏ 命令
foo.c bar.c bar.h make foo
时，Make 就会发现 和 没有变动过，因此不⽤重新编译 ，只需要重新编译 。有
bar.c bar.h bar.o foo.o
了新的 以后，再跟 ⼀起，重新编译成新的可执⾏⽂件 。
foo.o bar.o foo
Make 这样设计的最⼤好处，就是⾃动处理编译过程，只重新编译变动过的⽂件，因此⼤⼤节省了时间。
全⽂完
本⽂由 简悦 SimpRead 转码，⽤以提升阅读体验，原⽂地址
命令⾏环境 语⾔教程 ⽹道
- C -
⽹道（WangDoc.com），互联⽹⽂档计划
“
⽹道（WangDoc.com），互联⽹⽂档计划
命令⾏参数 #
C 语⾔程序可以从命令⾏接收参数。
$ ./foo hello world
上⾯示例中，程序 接收了两个命令⾏参数 和 。
foo hello world
程序内部怎么拿到命令⾏参数呢？C 语⾔会把命令⾏输⼊的内容，放在⼀个数组⾥⾯。 函数的参数
main()
可以接收到这个数组。
#include 
int main(int argc, char* argv[]) {
for (int i = 0; i 
int main(int argc, char** argv) {
if (argc != 3) {
printf("usage: mult x y\n");
return 1;
}
printf("%d\n", atoi(argv[1]) * atoi(argv[2]));
return 0;
}
上⾯示例中， 不等于 就会报错，这样就限定了程序必须有两个参数，才能运⾏。
argc 3
另外， 数组的最后⼀个成员是 NULL 指针（ ）。所以，参数的遍历也可以写成
argv argv[argc] == NULL
下⾯这样。
for (char** p = argv; *p != NULL; p++) {
printf("arg: %s\n", *p);
}
上⾯示例中，指针 依次移动，指向 的每个成员，⼀旦移到空指针 NULL，就表示遍历结束。由于