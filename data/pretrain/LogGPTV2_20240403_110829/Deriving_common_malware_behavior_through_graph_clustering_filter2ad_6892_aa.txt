title:Deriving common malware behavior through graph clustering
author:Young Hee Park and
Douglas S. Reeves
Deriving Common Malware Behavior
through Graph Clustering (cid:3)
Younghee Park, Douglas Reeves
Cyber Defense Laboratory
Department of Computer Science Department
N.C. State University, Raleigh, NC, USA
{ypark3, reeves}@ncsu.edu
ABSTRACT
Detection of malicious software (malware) continues to be a prob-
lem as hackers devise new ways to evade available methods. The
proliferation of malware and malware variants requires methods
that are both powerful, and fast to execute. This paper proposes
a method to derive the common execution behavior of a family of
malware instances. For each instance, a graph is constructed that
represents kernel objects and their attributes, based on system call
traces. The method combines these graphs to develop a supergraph
for the family. This supergraph contains a subgraph, called the
HotPath, which is observed during the execution of all the malware
instances. The proposed method is scalable, identiﬁes previously-
unseen malware instances, shows high malware detection rates, and
false positive rates close to 0%.
1.
INTRODUCTION
Malware (malicious software) continues to be widespread de-
spite the common use of anti-virus software, and the diversity of
malware is increasing. Some anti-virus vendors reported approxi-
mately half a million instances of malware for the ﬁrst half of 2007,
and several thousand new malware variants per day [10, 24]. The
formidable increase in the number of malware samples has been
a turning point in malware research. To reduce the resource and
management costs identifying such large numbers of malware in-
stances, deriving representative malware behavior has become an
important challenge [23, 12].
Previous work for behavior-based malware detection is based on
static analysis (i.e. disassembly), or on dynamic analysis at run-
time. Static analysis relies on disassembly to identify malicious
behavior, and makes use of control ﬂow analysis and data ﬂow anal-
ysis [13, 29, 19]. However, these methods need full disassembly
for analysis, and may have problems with code polymorphism (e.g.
encryption, packing of binaries) and metamorphism (e.g. code ob-
fuscation). Moreover, a single signature or syntactic structure is not
applicable to new threats and new instances.
(cid:3)
This work has been funded by the National Science Foundation
under grant CNS-0831081. The contents do not represent the ofﬁ-
cial position of the U.S. government.
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ASIACCS ’11, March 22–24, 2011, Hong Kong, China.
Copyright 2011 ACM 978-1-4503-0564-8/11/03 ...$10.00.
497
To overcome the drawbacks of static analysis, dynamic behavior-
based analysis has gained much interest [2, 1, 28, 16, 26, 12] since
the runtime behavior of malware cannot be changed dramatically.
Many of these works use advanced techniques such as symbolic
execution and taint analysis, causing major performance overhead,
as discussed in [28, 15, 17, 27]. Kolbitsch et al. [17] proposed a
malware detection method to efﬁciently extract a system call be-
havioral graph for each instance, which includes dependencies be-
tween system calls and their arguments, speciﬁcally, with the usage
of buffers and strings. However, extracting common behavior that
detects any variants of malware, with a low false positive rate, still
remains a demanding problem.
In this paper, we propose a new malware detection method. This
method makes use of one representative common behavioral graph
for all malware instances in a type of malware family, instead of
one behavioral graph per instance. The common behavioral graph
is created from individual behavioral graphs through graph cluster-
ing. Each behavioral graph represents the usage of kernel objects,
the object attributes, and the dependencies between these kernel
objects. Such properties are obtained through monitoring system
calls and their arguments at runtime. The essential observation is
that each malware instance in the same family shows similar run-
time behaviors, and that behavior is distinct from those of benign
applications. The resulting common graph represents common be-
havior in malware instances of a family. The common graph has
a unique subgraph, called the HotPath, which is shared by all the
malware instances in the family. By using the common behavioral
graph and the HotPath, the proposed method detects new variants
of the family with high accuracy.
The proposed method is different from others in the following
ways. There is one common graph per malware family. This graph
is based on usage of kernel objects, rather than on speciﬁc sys-
tem calls. The graph contains a common path, called the HotPath,
which is execution behavior shared by all malware instances in the
family. Obfuscation of malware instruction execution does not alter
the common behavior of the family.
A prototype of the proposed method has been implemented. It
uses the Xen hypervisor to intercept system calls with their argu-
ments on the Windows guest operating system. When evaluated on
well-known data sets, higher detection rates are achieved than by
previous research, with false positive rates close to or at 0%. The
overhead of graph construction and malware identiﬁcation is on the
order of tens of milliseconds.
Our contributions are as follows. First, this method proposes
a method to extract a kernel object behavioral graph (KOBG) for
a malware instance, from system call traces collected during ex-
ecution. Second, from a set of KOBGs, the method constructs a
common behavioral graph that captures representative execution
behavior of a malware family, by using graph clustering. The u-
nique subgraph (HotPath) shared by all of the binaries in the family
is derived automatically. Third, the generated common behavioral
graph is scalable since the common graph is not changed signif-
icantly according to new malware variants added into the family.
Finally, the proposed method of malware detection by matching
with the common behavioral graph is robust against system call at-
tacks.
The paper is organized as follows. Section 2 presents an overview,
and details about the proposed method. Section 3 shows the results
of evaluating the method with actual malware instances. Section 4
compares the method to previous work, and section 5 concludes the
paper.
2. THE PROPOSED METHOD
The new method has two steps for malware detection.
In the
ﬁrst step, a set of malware instances (executables) are processed to
derive kernel object behavioral graphs (one per instance) that rep-
resent their behavior. In the second step, the graphs for malware
instances that are in the same family are then clustered into a sin-
gle graph (a Weighted Common Behavioral Graph) that represents
the behavior of all members of that family. Finally, the clustered
single graph detects new instances of malware with very low over-
head by comparison to the weighted common behavioral graphs for
different malware families.
2.1 Kernel Object Behavioral Graph Genera-
tion
The graph that represents the behavior of a malware instance is a
kernel object behavioral graph. A kernel object is a memory block
in the kernel. This memory block is a data structure whose mem-
bers maintain information about the object. In the Windows operat-
ing system, several kernel objects are deﬁned, including processes,
threads, ﬁles, events, sockets, etc. [20]. Since the kernel object data
structures are accessible only by the kernel, it is not possible for an
application to locate these data structures in memory and directly
alter their contents.
A kernel object behavioral graph is constructed from informa-
tion that is collected from a running program in a virtualized en-
vironment. Based on the intercepted system call traces with the
arguments, the method identiﬁes relationships between kernel ob-
jects. A kernel object behavioral graph (KOBG) is a weighted di-
rected graph described by g = (V; E; (cid:21); (cid:22)). V is a set of vertexes
(vertices, v), and each represents a type of kernel objects. The at-
tributes of a vertex indicate the speciﬁc name of the kernel object.
E (cid:18) V (cid:2) V is a set of edges e, and each edge indicates a depen-
dency between two kernel objects. The dependency is presented by
handle types and handle values. A dependency consists of a handle
type and a handle value for the object. The object handle indicates
an identiﬁer to represent a system resource inside a kernel, which
is allocated by an application. (cid:21) : V ! N + is a function assign-
ing positive weight to the vertexes (initially, (cid:21)(v) = 1 8v 2 V ).
(cid:22) : E ! N + is a function assigning positive weights to the edges
(initially, (cid:22)(e) = 1 8e 2 E).
When kernel objects are accessed via system calls, most such
calls include the handle and the object attributes of kernel object-
s as arguments of the call. The object name is identiﬁed by the
ObjectAtrributes parameter in the intercepted system call. Each k-
ernel object has a creator function and a destructor function. For
instance, NtCreateFile creates a new ﬁle or directory, or opens an
existing ﬁle, directory, device, or volume, while NtClose terminates
the kernel object with the handle created by NtCreateFile. In addi-
tion, NtCreateProcess makes a new process and its primary thread.
The object name is extracted by reading ObjectAttributes parame-
ter values. The kernel object is no longer accessible when NtClose
or NtTerminateProcess is called with this handle.
Once a kernel object is created by a system call, its handle is re-
turned and used in other system calls as an argument. This means
that the kernel object is accessed by other kernel objects associ-
ated with those system calls. For example, when NtCreateThread
is called, it takes a process handle as input, and returns a thread
handle. The dependency between process and thread objects is
represented by an edge between the corresponding vertexes in the
KOBG. The weight of all edges in the KOBG is 1. Figure 2 shows
an example of a kernel object behavioral graph while comparing
to a typical system call behavioral graph. Figure 1 shows an ex-
cerpt of system call traces of one instance of the Netsky worm,
similar to [17]. As shown in Figure 2, this part of the system call
traces generates two different graphs, a typical system call behav-
ioral graph and kernel object behavioral graph. In the ﬁrst trace of
Figure 1, it opens the ﬁle (Netsky.exe). Next, a new ﬁle (AVProtec-
t9.exe) is created to copy its code. Finally, the worm reads its own
program code to copy itself into the new ﬁle.
Figure 1: A Part of System Call Traces for Netsky.
First, for KOBG, each vertex indicates each kernel object and
the object name in Figure 2(a). Each edge indicates a dependen-
cy between two kernel objects. The dependence is derived when
one kernel object affects the use or creation of another kernel ob-
ject. In detail, it is assumed that a kernel object, Process, implic-
itly appears since all the traces are generated by its own process.
From the traces, since NtCreateFile function opens a ﬁle in the C:n
directory, one vertex for this ﬁle (File object) is created and the
object name is C:nNetsky.exe. The vertex from the second trace,
File_C:nWindowsnAVprotect9.exe, is generated by the same pro-
cess. The edge between these two kernel objects is implicitly con-
nected to the Process object because a process opens and creates
the ﬁle. In addition, NtCreateSection assigns a memory block. An-
other vertex for this section is created and the object name is a
memory address in this trace. However, in other traces, the object
name of the section can be DLL names as well. As in this ﬁgure,
an edge is created between the Section object and the File object
because this ﬁle makes this section. For comparison, Figure 2(b)
represents an example of a typical system call behavioral graph,
described in [17]. Note that the ﬁgure of a system call behavioral
graph does not reﬂect on dataﬂow analysis.
In summary, a kernel object behavioral graph represents the us-
ages of kernel objects labeling with their object names. Even if
any kernel objects are generated by attackers, the relationship be-
tween two speciﬁc kernel objects is hard to be broken as shown
in Section 3. In other words, since multiple kernel handle values
can indicate the same kernel object at runtime, we use the kernel
object name rather than original handle values. A handle indicates
an identiﬁer of a kernel object. However, the typical system call
behavioral graph illustrates the usages of system calls based on the
dependency of handle values. The dependency based on handles