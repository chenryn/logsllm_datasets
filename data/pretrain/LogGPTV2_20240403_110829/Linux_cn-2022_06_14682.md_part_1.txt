---
author: Two-bit History
category: 观点
comments_data: []
count:
  commentnum: 0
  favtimes: 0
  likes: 0
  sharetimes: 0
  viewnum: 3059
date: '2022-06-07 11:10:38'
editorchoice: true
excerpt: 我们可能会理所当然地认为，面向对象程序设计的方式千篇一律，即程序就是对事件的一长串记录：某个对象以特定顺序对其他对象产生作用。Simula I 的进程系统表明，面向对象程序设计的方式不止一种。
fromurl: https://twobithistory.org/2019/01/31/simula.html
id: 14682
islctt: true
largepic: /data/attachment/album/202206/07/111039fmwyq0lvqpplvlrx.jpg
permalink: /article-14682-1.html
pic: /data/attachment/album/202206/07/111039fmwyq0lvqpplvlrx.jpg.thumb.jpg
related: []
reviewer: wxy
selector: lujun9972
summary: 我们可能会理所当然地认为，面向对象程序设计的方式千篇一律，即程序就是对事件的一长串记录：某个对象以特定顺序对其他对象产生作用。Simula I 的进程系统表明，面向对象程序设计的方式不止一种。
tags:
- OOP
- 面向对象
thumb: false
title: Simula 诞生之前的面向对象程序设计
titlepic: true
translator: aREversez
updated: '2022-06-07 11:10:38'
---
想象一下，你坐在河边，河岸上如茵绿草，不远处湍急河流；午后的阳光慵懒惬意，使人陷入冥想哲思，不觉开始思考眼前的河流是否真实存在。诚然，几米外确实有河水奔流而下。不过，我们所称为“河流”的存在究竟是什么呢？毕竟，河水奔流不息，一直处于变化之中。似乎，“河流”这个词无法指代任何固定不变的事物。
2009 年，Clojure 的创始人  里奇·希基   Rich Hickey  发表了 [一场精彩的演讲](https://www.infoq.com/presentations/Are-We-There-Yet-Rich-Hickey)，探讨了为什么上文那样的哲学窘境会给面向对象程序的编程范式带来难题。他认为，人们看待计算机程序中的对象与看待河流的逻辑是一样的：我们想象对象是固定不变的，即使对象的许多或者说全部的属性都无时无刻不处于变化之中。所以，这种逻辑并不正确，我们无法区分在不同状态下同一对象实例的不同之处。程序中没有明确的时间的概念。人们只是单纯地用着同一个名字，以期在引用对象时，对象能够处于预期的状态中。这样，我们也就难免会遇到  故障   bug 。
希基总结道，这一难题的应对办法就是人们应该将世界建模成作用于不可变数据的  进程   process  的集合，而不是可变的对象的集合。换句话说，我们应把每个对象看作一条“河流”，因果相连。总结说来，你应该使用 Clojure 等函数式语言。
![](/data/attachment/album/202206/07/111039fmwyq0lvqpplvlrx.jpg)
*作者在远足途中思考面向对象程序设计的本体论问题。*
自从希基发表演讲之后，人们对函数式编程语言的兴趣不断提升，主流的面向对象编程语言也大多都采用了函数式编程语言。尽管如此，大多数程序员依旧沿用自己的老一套，继续将对象实例化，不断改变其状态。这些人长此以往，很难做到用不同的视角看待编程。
我曾经想写一篇关于 Simula 的文章，大概会写到我们今天所熟知的面向对象的理念是何时又是如何应用到程序语言之中的。但是，我觉得写当初的 Simula 与如今的面向对象程序设计的 *迥然不同之处*，会更有趣一些，这我敢打包票。毕竟，我们现在熟知的面向对象程序设计还未完全成型。Simula 有两个主要版本：Simula I 和 Simula 67。Simula 67 为世界带来了  类   class 、  类的继承   class hierarchy  以及  虚拟方法   virtual method ；但 Simula I 是一个初稿，它实验了如何能够将数据和进程捆绑起来的其他设想。Simula I 的模型不是希基提出的函数式模型，不过这一模型关注的是随时间展开的 *进程*，而非有着隐藏状态的对象之间的相互作用。如果 Simula 67 采用了 Simula I 的理念，那么我们如今所知的面向对象程序设计可能会大有不同——这类偶然性启示我们，不要想着现在的程序设计范式会一直占据主导地位。
### 从 Simula 0 到 Simula 67
Simula 是由两位挪威人  克里斯汀·尼加德   Kristen Nygaard  和  奥利-约翰·达尔   Ole-Johan Dahl  创建的。
20 世纪 50 年代末，尼加德受雇于  挪威防务科学研究中心   Norwegian Defense Research Establishment （NDRE），该研究中心隶属于挪威军方。在那里，他负责设计  蒙特卡洛模拟方法   Monte Carlo simulations ，用于核反应堆设计与操作研究。最初，那些模拟实验是由人工完成的；后来，实验在 Ferranti Mercury 电脑    [1]  上编入程序运行。尼加德随后发现，将这些模拟实验输入电脑需要一种更有效的方式。
尼加德设计的这种模拟实验就是人们所知的“ 离散事件模型   discrete event model ”，这种模拟记录了一系列事件随着时间改变系统状态的进程。但是问题的关键在于模拟可以从一个事件跳跃到另一个事件中，因为事件是离散的，事件之间的系统不存在任何变化。根据尼加德和达尔在 1966 年发表的一篇关于 Simula 的论文，这种模型被迅速应用于“神经网络、通信系统、交通流量、生产系统、管理系统、社会系统等”    [2]  领域的分析。因此，尼加德认为，其他人描述模拟实验时，可能也需要更高层级的模型。于是他开始物色人才，帮助他完成他称之为“ 模拟语言   Simulation Language ”或者“ 蒙特卡洛编译器   Monte Carlo Compiler ”的项目    [3] 。
达尔当时也受雇于挪威防务科学研究中心，专攻语言设计，此时也加入了尼加德的项目，扮演“沃兹尼亚克”的角色（LCTT 译注：指苹果公司联合创始人斯蒂夫·盖瑞·沃兹尼亚克）。在接下来一年左右的时间，尼加德和达尔携手开发了 Simula 0 语言。   [4]  这一语言的早期版本仅仅是在 ALGOL 60 基础上进行的较小拓展，当时也只是打算将其用作预处理程序而已。当时的语言要比后来的编程语言抽象得多，其基本语言结构是“ 车站   stations ”与“ 乘客   customers ”，这些结构可以用于针对具体某些离散事件网络建立模型。尼加德和达尔给出了一个模拟飞机离港的例子。   [5]  但是尼加德和达尔最后想出了一个更加通用的语言结构，可以同时表示“车站”和“乘客”，也可以为更广泛的模拟建立模型。这是两个主要的概括，它改变了 Simula 作为 ALGOL 专属包的定位，使其转变为通用编程语言。
Simula I 没有“ 车站   stations ”和“ 乘客   customers ”的语言结构，但它可以通过使用“ 进程   process ”再现这些结构。（LCTT 译注：此处使用的“进程”，与当前计算机中用来指代一个已执行程序的实体的概念不同，大致上，你可以将本文中所说的“进程”理解为一种“对象”。）一个进程包含大量数据属性，这些属性与作为进程的 *操作规程* 的单个行为相联系。你可能会把进程当作是只有单个方法的对象，比如 `run()` 之类的。不过，这种类比并不全面，因为每个进程的操作规程都可以随时暂停、随时恢复，因为这种操作规程属于  协程   coroutine  的一种。Simula I 程序会将系统建立为一套进程的模型，在概念上这些进程并行运行。实际上，一个时间点上能称为“当前进程”的只有一个进程。但是，一旦某个进程暂停运行，那么下一个进程就会自动接替它的位置。随着模拟的运行，Simula 会保持一个 “ 事件通知   event notices ” 的时间线，跟踪记录每个进程恢复的时间。为了恢复暂停运行的进程，Simula 需要记录多个  调用栈   call stacks  的情况。这就意味着 Simula 无法再作为 ALGOL 的预处理程序了，因为 ALGOL 只有一个  调用栈   call stacks 。于是，尼加德和达尔下定决心，开始编写自己的编译器。
尼加德和达尔在介绍该系统的论文中，借助图示，通过模拟一个可用机器数量有限的工厂，阐明了其用法。   [6]  在该案例中，进程就好比订单：通过寻找可用的机器，订单得以发出；如果没有可用的机器，订单就会搁置；而一旦有机器空出来，订单就会执行下去。有一个订单进程的定义，用来实例化若干种不同的订单实例，不过这些实例并未调用任何方法。该程序的主体仅仅是创建进程，并使其运行。
历史上第一个 Simula I 编译器发布于 1965 年。尼加德和达尔在离开挪威防务科学研究中心之后，就进入了  挪威计算机中心   Norwegian Computer Center  工作，Simula I 也是在这里日渐流行起来的。当时，Simula I 在 UNIVAC 公司的计算机和 Burroughs 公司的 B5500 计算机上均可执行。   [7]  尼加德和达尔两人与一家名为 ASEA 的瑞典公司达成了咨询协议，运用 Simula 模拟加工车间。但是，尼加德和达尔随后就意识到 Simula 也可以写一些和模拟完全不搭边的程序。
 奥斯陆大学   University of Oslo 教授  斯坦因·克罗达尔   Stein Krogdahl  曾写过关于 Simula 的发展史，称“真正能够促使新开发的通用语言快速发展的催化剂”就是 [一篇题为 《记录处理》   Record Handling 的论文](https://archive.computerhistory.org/resources/text/algol/ACM_Algol_bulletin/1061032/p39-hoare.pdf)，作者是英国计算机科学家  查尔斯·安东尼·理查德·霍尔   C.A.R. Hoare 。   [8]  假如你现在读霍尔的这篇论文，你就不会怀疑这句话。当人们谈及面向对象语言的发展史时，一定会经常提起霍尔的大名。以下内容摘自霍尔的《记录处理》一文：