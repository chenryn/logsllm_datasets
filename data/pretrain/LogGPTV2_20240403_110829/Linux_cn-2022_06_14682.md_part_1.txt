---

**作者**: Two-bit History  
**类别**: 观点  
**评论数据**: 无  
**计数**:
  - 评论数: 0
  - 收藏次数: 0
  - 点赞数: 0
  - 分享次数: 0
  - 阅读量: 3059
**日期**: 2022-06-07 11:10:38  
**编辑推荐**: 是  
**摘要**: 我们可能会认为面向对象程序设计的方式是单一的，即程序是对事件的一长串记录：某个对象以特定顺序对其他对象产生作用。然而，Simula I 的进程系统表明，面向对象程序设计的方式不止一种。  
**来源网址**: <https://twobithistory.org/2019/01/31/simula.html>  
**ID**: 14682  
**是否为精选文章**: 是  
**大图**: /data/attachment/album/202206/07/111039fmwyq0lvqpplvlrx.jpg  
**永久链接**: /article-14682-1.html  
**图片**: /data/attachment/album/202206/07/111039fmwyq0lvqpplvlrx.jpg.thumb.jpg  
**相关文章**: 无  
**审稿人**: wxy  
**选择者**: lujun9972  
**总结**: 我们可能会认为面向对象程序设计的方式是单一的，即程序是对事件的一长串记录：某个对象以特定顺序对其他对象产生作用。然而，Simula I 的进程系统表明，面向对象程序设计的方式不止一种。  
**标签**:
  - OOP
  - 面向对象
**是否有缩略图**: 否  
**标题**: Simula 诞生之前的面向对象程序设计  
**是否有标题图片**: 是  
**翻译者**: aREversez  
**更新日期**: 2022-06-07 11:10:38

---

想象一下，你坐在河边，河岸上绿草如茵，不远处湍急的河水奔流而下。午后的阳光慵懒惬意，使人陷入冥想和哲思，不觉开始思考眼前的河流是否真实存在。诚然，几米外确实有河水奔流而下。但“河流”这个词究竟指代的是什么呢？毕竟，河水奔流不息，一直处于变化之中。似乎，“河流”无法指代任何固定不变的事物。

2009 年，Clojure 的创始人里奇·希基 (Rich Hickey) 发表了 [一场精彩的演讲](https://www.infoq.com/presentations/Are-We-There-Yet-Rich-Hickey)，探讨了这种哲学困境如何给面向对象编程范式带来难题。他认为，人们看待计算机程序中的对象与看待河流的逻辑是一样的：我们想象对象是固定不变的，即使对象的许多属性都在不断变化。因此，这种逻辑并不正确，我们无法区分不同状态下同一对象实例的不同之处。程序中没有明确的时间概念。人们只是用同一个名字来引用对象，期望它处于预期的状态。这样，我们就难免会遇到故障 (bug)。

希基总结道，应对这一难题的方法是将世界建模成作用于不可变数据的进程集合，而不是可变的对象集合。换句话说，我们应该把每个对象看作一条“河流”，因果相连。简而言之，你应该使用 Clojure 等函数式语言。

![](/data/attachment/album/202206/07/111039fmwyq0lvqpplvlrx.jpg)

*作者在远足途中思考面向对象程序设计的本体论问题。*

自希基发表演讲以来，人们对函数式编程语言的兴趣不断提升，主流的面向对象编程语言也大多采用了函数式编程的特性。尽管如此，大多数程序员仍然沿用自己的老一套，继续将对象实例化并不断改变其状态。这些人很难从不同的视角看待编程。

我曾经打算写一篇关于 Simula 的文章，讨论面向对象的理念是如何应用到程序语言中的。但我认为写 Simula 与当今面向对象程序设计的 *迥然不同之处* 会更有趣。毕竟，我们现在熟知的面向对象程序设计还未完全成型。Simula 有两个主要版本：Simula I 和 Simula 67。Simula 67 引入了类、类继承和虚拟方法；而 Simula I 则是一个实验性的初稿，探索了如何将数据和进程捆绑起来的其他设想。Simula I 的模型不是希基提出的函数式模型，但它关注的是随时间展开的 *进程*，而非有着隐藏状态的对象之间的相互作用。如果 Simula 67 采用了 Simula I 的理念，那么我们如今所知的面向对象程序设计可能会大有不同——这类偶然性启示我们，不要认为当前的程序设计范式会一直占据主导地位。

### 从 Simula 0 到 Simula 67

Simula 是由两位挪威人克里斯汀·尼加德 (Kristen Nygaard) 和奥利-约翰·达尔 (Ole-Johan Dahl) 创建的。

20 世纪 50 年代末，尼加德受雇于挪威防务科学研究中心 (Norwegian Defense Research Establishment, NDRE)，负责设计蒙特卡洛模拟方法，用于核反应堆设计与操作研究。最初，这些模拟是由人工完成的；后来，实验在 Ferranti Mercury 电脑上编入程序运行。尼加德随后发现，需要一种更有效的方式来将这些模拟实验输入电脑。

尼加德设计的这种模拟实验被称为“离散事件模型”，这种模拟记录了一系列事件随着时间改变系统状态的过程。关键在于，模拟可以从一个事件跳跃到另一个事件中，因为事件是离散的，事件之间的系统不存在任何变化。根据尼加德和达尔在 1966 年发表的一篇关于 Simula 的论文，这种模型迅速应用于神经网络、通信系统、交通流量、生产系统、管理系统和社会系统的分析。因此，尼加德认为其他人描述模拟实验时也需要更高层级的模型，并开始寻找人才来帮助他完成他称之为“模拟语言”或“蒙特卡洛编译器”的项目。

达尔当时也受雇于挪威防务科学研究中心，专攻语言设计，加入了尼加德的项目。在接下来的一年左右的时间里，尼加德和达尔携手开发了 Simula 0 语言。早期版本仅是在 ALGOL 60 基础上的较小扩展，主要用于预处理。该语言的基本结构是“车站”与“乘客”，可以用于针对具体某些离散事件网络建立模型。尼加德和达尔给出了一个模拟飞机离港的例子。最终，他们想出了一个更加通用的语言结构，可以同时表示“车站”和“乘客”，并为更广泛的模拟建立模型。这是两个主要的概括，使 Simula 从 ALGOL 专属包转变为通用编程语言。

Simula I 没有“车站”和“乘客”的语言结构，但它可以通过使用“进程”再现这些结构。（注：本文中的“进程”与现代计算机中的进程概念不同，大致可以理解为一种“对象”。）一个进程包含大量数据属性，这些属性与作为进程的操作规程的单个行为相联系。你可以将进程视为只有一个方法（如 `run()`）的对象。不过，这种类比并不全面，因为每个进程的操作规程都可以随时暂停和恢复，属于协程的一种。Simula I 程序将系统建模为一组进程，在概念上这些进程并行运行。实际上，一个时间点上只能有一个“当前进程”。一旦某个进程暂停，下一个进程就会自动接替。随着模拟的运行，Simula 会维护一个“事件通知”的时间线，跟踪每个进程恢复的时间。为了恢复暂停的进程，Simula 需要记录多个调用栈的情况。这意味着 Simula 不能再作为 ALGOL 的预处理程序，因为 ALGOL 只有一个调用栈。于是，尼加德和达尔决定编写自己的编译器。

尼加德和达尔在介绍该系统的论文中，通过图示说明了一个有限机器数量工厂的模拟。在这个案例中，进程类似于订单：通过寻找可用的机器，订单得以发出；如果没有可用的机器，订单就会搁置；一旦有机器空出来，订单就会继续执行。有一个订单进程的定义，用来实例化多种不同的订单实例，但这些实例并未调用任何方法。程序的主体仅仅是创建进程并使其运行。

历史上第一个 Simula I 编译器发布于 1965 年。尼加德和达尔离开挪威防务科学研究中心后，进入了挪威计算机中心工作，Simula I 在那里逐渐流行起来。当时，Simula I 可以在 UNIVAC 公司的计算机和 Burroughs 公司的 B5500 计算机上运行。尼加德和达尔还与一家名为 ASEA 的瑞典公司达成咨询协议，使用 Simula 模拟加工车间。但他们很快意识到，Simula 也可以编写与模拟无关的程序。

奥斯陆大学教授斯坦因·克罗达尔 (Stein Krogdahl) 曾写过关于 Simula 的发展史，称“真正能够促使新开发的通用语言快速发展的催化剂”是英国计算机科学家查尔斯·安东尼·理查德·霍尔 (C.A.R. Hoare) 发表的一篇题为《记录处理》(Record Handling) 的论文。如果你现在读霍尔的这篇论文，你就不会怀疑这句话。当人们谈及面向对象语言的发展史时，一定会经常提到霍尔的大名。以下内容摘自霍尔的《记录处理》一文：

---

通过以上优化，文本变得更加清晰、连贯和专业。希望这对你有所帮助！