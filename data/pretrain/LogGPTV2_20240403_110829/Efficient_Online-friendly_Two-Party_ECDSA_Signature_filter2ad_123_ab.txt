We propose an online-friendly two-party ECDSA, 2ECDSA, such
that its online computation is nearly optimal and its offline phase
just needs a single call of MtA.
(1) The online phase of our protocol is non-interactive and op-
timal. It only requires transmitting a single element, and
its computation cost is dominated by the verification of the
resulting signature. Our offline phase runs in three-pass with
a single MtA, thus has significant improvement over [15]
and the two-party cases of [6, 8, 16, 19, 26, 33]. Two novel
techniques are developed, which may be of independent
interest.
(a) The linear sharing of the nonce ğ‘˜ = ğ‘˜1(ğ‘Ÿ1 + ğ‘˜2), where
ğ‘˜1, ğ‘Ÿ1 are chosen by party ğ‘ƒ1 and ğ‘˜2 is chosen by the other
party, ğ‘ƒ2. It is different from the existing simple additive
or multiplicative sharing of the nonce.
(b) The re-sharing of the secret ğ‘¥ by using ğ‘˜2 in the offline
phase. New share ğ‘¥â€²1 (resp. ğ‘¥â€²2) of the signing key is chosen
by ğ‘ƒ1 (resp. ğ‘ƒ2), such that ğ‘¥ = ğ‘¥â€²1ğ‘˜2 + ğ‘¥â€²2 (which is also a
linear function).
These techniques enable us to construct an online-friendly
2ECDSA with a single MtA. Details are given in Sec. 1.2.
(2) We provide an implementation of our two-party 2ECDSA
protocol in Rust, with instantiation of the MtA functional-
ity from Paillier encryption, CL encryption, and oblivious
transfer. We give an efficiency comparison with all previ-
ous two-party ECDSA and the two-party case of threshold
ECDSA. Details are shown in Table 2. On the premise of
preserving fast online computation, our scheme reduces the
offline cost of Paillier-based protocol to 226 ms and 6.3 KB,
and further to 141 ms and 4.1 KB based on Paillier-EC as-
sumption. For CL-based instantiation, the complexity of the
Session 2D: Secure Multiparty Computation CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea559offline phase is 1386 ms and 1.7 KB. Based on oblivious trans-
fer (OT), the offline cost of our scheme is 2.6 ms and 90.9
KB.
(3) Applying 2-out-of-ğ‘› Shamir secret-sharing [30] to ğ‘›-party
additively shared secret during key generation, our two-
party 2ECDSA could be easily extended to the 2-out-of-ğ‘›
ECDSA. The general schemeâ€™s signing phase has the same
complexity as 2ECDSA.
1.2 Technical Overview
Recall that the main bottleneck of previous schemes is due to the use
of complex protocols for the two parties to compute ğ‘˜âˆ’1(ğ»(ğ‘š)+ğ‘Ÿğ‘¥)
such that ğ‘¥ = ğ‘¥1 + ğ‘¥2 and ğ‘˜ = ğ‘˜1 + ğ‘˜2 (resp. ğ‘¥ = ğ‘¥1ğ‘¥2 and ğ‘˜ = ğ‘˜1ğ‘˜2)
in the case of additive sharing (resp. multiplicative sharing). In
other words, the bottleneck is inherent in the multiple executions
of MtA for these shares.
Starting point. We start from a simple combination of multiplica-
tive sharing of ğ‘˜ (i.e. ğ‘˜ = ğ‘˜1ğ‘˜2) and additive sharing of ğ‘¥ (i.e.
ğ‘¥ = ğ‘¥1 + ğ‘¥2). This has been utilized by Doerner et al. [15] to handle
2-out-of-ğ‘› threshold scheme, albeit, in a rather inefficient way. To
jointly compute ğ‘  = ğ»(ğ‘š)/ğ‘˜1ğ‘˜2 + ğ‘Ÿ(ğ‘¥1 + ğ‘¥2)/ğ‘˜1ğ‘˜2, they adopt three
MtA to export the additive shares of 1/ğ‘˜1 Â· 1/ğ‘˜2, ğ‘¥1/ğ‘˜1 Â· 1/ğ‘˜2, and
1/ğ‘˜1 Â· ğ‘¥2/ğ‘˜2 respectively. Thus, their two-party case of 2-out-of-ğ‘›
scheme is worse than their direct two-party scheme where only
two MtA are required.
The first attempt: Re-sharing of the secret. We resolve this
problem with a re-sharing of secret ğ‘¥ using a share of nonce ğ‘˜2.
Concretely, in the offline phase the secret ğ‘¥ = ğ‘¥1 + ğ‘¥2 is re-shared
to ğ‘¥â€²1, ğ‘¥â€²2 using one MtA such that
ğ‘¥1 + ğ‘¥2 = ğ‘¥â€²1ğ‘˜2 + ğ‘¥â€²2.
In the online phase, ğ‘ƒ2 computes ğ‘ 2 = ğ‘˜âˆ’1
2 (ğ»(ğ‘š) + ğ‘Ÿğ‘¥â€²2), and ğ‘ƒ1
could derive the signature component ğ‘  from ğ‘ 2, ğ‘˜1 and ğ‘¥â€²1 since
(cid:2)ğ»(ğ‘š) + ğ‘Ÿ(ğ‘¥â€²2 + ğ‘˜2ğ‘¥â€²1)
(cid:3)
1 (ğ‘ 2 + ğ‘Ÿğ‘¥â€²1)
1 ğ‘˜âˆ’1
2
ğ‘  = ğ‘˜âˆ’1
= ğ‘˜âˆ’1
= ğ‘˜âˆ’1(ğ»(ğ‘š) + ğ‘Ÿğ‘¥).
The offline phase re-shares the secret ğ‘¥ = ğ‘¥1 + ğ‘¥2 into ğ‘¥ =
ğ‘¥â€²1ğ‘˜2 + ğ‘¥â€²2, with a single MtA. Specifically, ğ‘ƒ1 chooses a random
ğ‘¥â€²1 â† Zğ‘, and then ğ‘ƒ1 and ğ‘ƒ2 invoke MtA with input ğ‘¥â€²1 and ğ‘˜2
respectively, and receive shares ğ‘¡ğ´ and ğ‘¡ğµ such that ğ‘¡ğ´ + ğ‘¡ğµ = ğ‘¥â€²1ğ‘˜2.
Then ğ‘ƒ1 masks ğ‘¥1 with ğ‘¡ğ´ and sends ğ‘ğ‘ = ğ‘¡ğ´ âˆ’ ğ‘¥1 to ğ‘ƒ2. ğ‘ƒ2 could
extract its new share ğ‘¥â€²2 from ğ‘ğ‘, ğ‘¥2, and ğ‘¡ğµ, since
ğ‘¥â€²2 = ğ‘¥1 + ğ‘¥2 âˆ’ ğ‘¥â€²1ğ‘˜2 = (ğ‘¡ğ´ âˆ’ ğ‘ğ‘) + ğ‘¥2 âˆ’ ğ‘¥â€²1ğ‘˜2 = âˆ’ğ‘¡ğµ âˆ’ ğ‘ğ‘ + ğ‘¥2.
The resulting scheme is online-friendly and requires a single MtA
in the offline phase. Unfortunately, this solution is insecure and a
malicious adversary may cheat.
Attack on the first attempt. We show that a malicious ğ‘ƒ2 can
obtain ğ‘¥1 in the previous scheme. Observe that
ğ‘¥1 = ğ‘¡ğ´ âˆ’ ğ‘ğ‘ = ğ‘¥â€²1ğ‘˜2 âˆ’ ğ‘¡ğµ âˆ’ ğ‘ğ‘,
where ğ‘˜2, ğ‘¡ğµ, ğ‘ğ‘ are known to ğ‘ƒ2. The malicious ğ‘ƒ2 can set ğ‘˜2 = 0
as the input of MtA and learn ğ‘ƒ1â€™s secret ğ‘¥1 = âˆ’ğ‘¡ğµ âˆ’ ğ‘ğ‘.
Our solution: Linear sharing of the nonce. A simple solution
to rule out the attack of ğ‘˜2 = 0 is to add a zero-knowledge proof of
ğ‘˜2 â‰  0 for ğ‘ƒ2, but it would be quite expensive. Instead, we apply a re-
randomization method to solve this problem. Now, the re-sharing
of the secret is changed to ğ‘¥ = ğ‘¥â€²1(ğ‘˜2 + ğ‘Ÿ1) + ğ‘¥â€²2, where ğ‘Ÿ1 is chosen
by ğ‘ƒ1 and could be given to ğ‘ƒ2. To achieve that, ğ‘ƒ1 now masks
ğ‘¥1 with ğ‘¡ğ´ and a random ğ‘Ÿ1 by setting ğ‘ğ‘ = ğ‘¡ğ´ + ğ‘Ÿ1ğ‘¥â€²1 âˆ’ ğ‘¥1. Now
ğ‘¥1 = ğ‘¡ğ´ + ğ‘Ÿ1ğ‘¥â€²1 âˆ’ ğ‘ğ‘ = ğ‘¥â€²1(ğ‘˜2 + ğ‘Ÿ1) âˆ’ ğ‘¡ğµ âˆ’ ğ‘ğ‘. If ğ‘Ÿ1 is chosen by ğ‘ƒ1 after
ğ‘˜2 is chosen by the (malicious) ğ‘ƒ2, ğ‘ƒ2 learns nothing about ğ‘¥1 since
ğ‘˜2 + ğ‘Ÿ1 = 0 with probability at most 1/ğ‘.
In order to support this change in the re-sharing of the secret, we
need to view ğ‘ƒ2â€™s share of the nonce as (ğ‘˜2+ğ‘Ÿ1). Interestingly, while
we require ğ‘Ÿ1 to be chosen by ğ‘ƒ1 (in order to withstand the above
attack), (ğ‘˜2 + ğ‘Ÿ1)âˆ’1 can be computed by ğ‘ƒ2 itself (otherwise, we
need another round of MtA). Hence, we change the multiplicative
sharing of the nonce ğ‘˜ into a linear function ğ‘˜1(ğ‘Ÿ1 + ğ‘˜2). In the
offline phase, ğ‘ƒ1 picks random ğ‘Ÿ1 and sends it to ğ‘ƒ2. Later in the
online phase, (ğ‘˜2 + ğ‘Ÿ1)âˆ’1 can be computed by ğ‘ƒ2. This is the reason
why we use a linear sharing of the nonce.
Additional consistency check is needed when setting up ğ‘˜ Â· ğ‘ƒ by
ğ‘ƒ1 and ğ‘ƒ2. Details are given in Sec. 3.
1.3 Extension and Instantiations
Extending to 2-out-of-ğ‘› Access Structures. Our two-party 2ECDSA
is presented using 2-out-of-2 additive share of the private key ğ‘¥.
It could be easily extended to a 2-out-of-ğ‘› protocol using Shamir
secret-sharing, in a way similar to Gennaro and Goldfeder [19]. A
similar approach has been described in [26] and [6]. We also let ğ‘¥ be
the additive share of each partyâ€™s contribution ğ‘¥ğ‘–, i.e. ğ‘¥ = ğ‘¥1+Â· Â· Â·+ğ‘¥ğ‘›.
It is natural to use a 2-out-of-ğ‘› Shamir secret-sharing [30] to convert
it into a 2-out-of-ğ‘› shares of ğ‘¥ in a verifiable manner.
ğ‘–
parties ğ‘ƒğ‘–, ğ‘ƒ ğ‘— could generate ğ›¬ğ‘–ğ‘›
that ğ‘¥ = ğ›¬ğ‘–ğ‘›
signing of 2ECDSA directly with ğ›¬ğ‘–ğ‘›
Here, we give a brief overview. For details, please refer to Ap-
pendix A. Each ğ‘ƒğ‘– chooses a linear function ğ‘“ğ‘– such that ğ‘“ğ‘–(0) = ğ‘¥ğ‘–
and sends ğ‘¥ ( ğ‘—)
= ğ‘“ğ‘–( ğ‘—) to ğ‘ƒ ğ‘— for all ğ‘— âˆˆ [1, ğ‘›]. Then, every two
parties ğ‘ƒğ‘–, ğ‘ƒ ğ‘— could recover ğ‘¥ğ‘˜ (for every ğ‘˜ âˆˆ [1, ğ‘›]) via interpo-
and ğ‘¥ ( ğ‘—)ğ‘˜ , i.e., ğ‘¥ğ‘˜ = ğ›¬ğ‘–ğ‘¥ (ğ‘–)ğ‘˜ + ğ›¬ğ‘— ğ‘¥ ( ğ‘—)ğ‘˜ where ğ›¬ğ‘–, ğ›¬ğ‘—
lating from ğ‘¥ (ğ‘–)ğ‘˜
are Lagrange coefficients. With Shamirâ€™s secret sharing, any two
such
ğ‘˜=1 ğ‘¥ ( ğ‘—)ğ‘˜ . They could further invoke the
as
their additive shares of ğ‘¥. The general 2-out-of-ğ‘› ECDSA has the
same signing protocol with 2ECDSA.
On the instantiations of MtA. Existing constructions of MtA
from OT, Paillier encryption, and CL-encryption can be directly
applied to our 2ECDSA.
and ğ›¬ğ‘—ğ‘›
and ğ›¬ğ‘—ğ‘›
ğ‘˜=1 ğ‘¥ (ğ‘–)ğ‘˜ + ğ›¬ğ‘—ğ‘›
ğ‘˜=1 ğ‘¥ ( ğ‘—)ğ‘˜
ğ‘˜=1 ğ‘¥ ( ğ‘—)ğ‘˜
ğ‘˜=1 ğ‘¥ (ğ‘–)ğ‘˜
ğ‘˜=1 ğ‘¥ (ğ‘–)ğ‘˜
Doerner et al. [15] proposed an OT-based MtA from Simplest
OT [10] and KOS [23] OT-extension protocols. Their MtA is com-
putationally efficient, while the communication cost is rather high
(e.g., 90 KB for 128 bits security). Although improved method was
applied, their two-party ECDSA requires a communication cost of
at least 168 KB. Integrating the OT-based MtA into our scheme, we
obtain the first OT-based two-party signature with communication
cost less than 100 KB at 128-bit security.
Paillier-based MtA is first proposed in [27] and improved by
[6, 19, 26]. The main issue when using Paillier cryptosystem for
MtA is that it operates over Zğ‘ rather than Zğ‘, where ğ‘ is the EC
group order. As a result, expensive zero-knowledge range proofs are
Session 2D: Secure Multiparty Computation CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea560Table 2: Comparison of signing with two-party protocols and two-party case of threshold ECDSA from Paillier, OT and CL
respectively. These concrete numbers are based on computational security parameter ğœ† = 128 and statistical security parameter
80. For those Paillier-based schemes, E represents a Paillier exponentiation over Zğ‘ 2 (we approximately count 3 operations of
mod ğ‘ as one operation of mod ğ‘ 2. Some of E are single â€œshort" exponentiation), while for CL-based schemes E means an
exponentiation over CL group. M refers to elliptic curve point multiplication which is almost free compared with E. In the
communication column, EC points, CL group elements, and ring elements of Paillier are encoded by ğœ…, 7ğœ… (only for ğœ… = 256), and
2â„“ğ‘ bits respectively. Estimating in parentheses includes the constant overhead with the standard security recommendation, i.e.
ğœ… = 256 and â„“ğ‘ = 3072. â€œPaillier-EC" means that Paillier-EC assumption is applied to eliminate a zero-knowledge proof.
Signing Protocols
LNR18 [26]
GG18 [19]
CGGMP20 [6]
2ECDSA (Paillier)
Lin17 [25] (Paillier-EC)
GG18 [19] (Paillier-EC)
2ECDSA (Paillier-EC)
CCLST19 [7]
CCLST20 [8]
YCX21 [33]
2ECDSA (CL)
DKLS18 [15]
DKLS19 [16]
2ECDSA (OT)
offline
28E + 157M (461ms)
42E + 40M (1237ms)
208E + 44M (2037ms)
14E + 11M (226ms)
2E + 8M (34ms)
18E + 40M (360ms)
8E + 14M (141ms)
4E + 8M (475ms)
28E + 8M (3316ms)
28E + 8M (4550ms)
11E + 11M (1386ms)
13M (2.9ms)
13M (3.7ms)
11M (2.6ms)
Computation
online
14E + 121M (302ms)
17M (3ms)
2M (0.2ms)
2M (0.2ms)
1E + 2M (8ms)
17M (3ms)
2M (0.2ms)
1E + 2M (190ms)
17M (3ms)
17M (3ms)
2M (0.2ms)
2M (0.2ms)
2M (0.2ms)
2M (0.2ms)
Communication
online
16â„“ğ‘ + 51ğœ… (6.6KB)
9ğœ… (288B)
ğœ… (32B)
ğœ… (32B)
2â„“ğ‘ (768B)