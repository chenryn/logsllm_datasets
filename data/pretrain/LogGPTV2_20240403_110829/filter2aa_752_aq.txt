许两个没有派生关系的进程之间自由地对话。 
本章介绍的进程间通信机制则完全解除了这些限制。我们将展示供“父子”进程、“无
关”进程甚至是分别运行在不同主机的进程之间进行通信的多种方式。 
进程间通信（Interprocss communication, IPC）是在不同进程之间传递数据的方法。例如，
互联网浏览器可以向服务器发送一个请求，随后服务器会传回 HTML 信息。这样的数据传
递通常是通过一种功能类似电话线路连接的套接字来完成的。另外一个例子，你可以用 ls | 
lpr 这个命令将一个目录下的文件名打印出来。Shell 程序会创建一个 ls 进程和一个 lpr
进程，然后用一个“管道（用 | 符号表示）”将它们连接起来。管道为这两个进程提供了一
种单向通信的渠道。这个例子中，由 ls 进程向管道写入信息，而 lpr 进程则从管道读取。 
在本章中，我们将讨论五种不同的进程间通信机制： 
· 共享内存允许两个进程通过对特定内存地址的简单读写来完成通信过程。 
· 映射内存与共享内存的作用相同，不过它需要关联到文件系统中的一个文件上。 
· 管道允许从一个进程到另一个关联进程之间的顺序数据传输。 
· FIFO 与管道相似，但是因为 FIFO 对应于文件系统中的一个文件，无关的进程也
可以完成通信。 
· 套接字允许无关的进程、甚至是运行在不同主机的进程之间相互通信。 
这些进程间通信机制（IPC）可以按以下标准进行区分： 
· 通信对象是否限制为相互关联的进程（即是否有共同的父进程），或者限制为共享
同一个文件系统的进程，还是可以为连接到同一个网络中的不同主机上的进程。 
· 通信中的一个进程是否限制为仅能读取或者写入数据。 
· 允许参加通信的进程的总数。 
· 通信进程是否直接在通信机制（IPC）中得到同步——例如，读取数据的进程会等
待直到有数据到达时开始读取。 
本章中，我们不再讨论那些只能进行有限次数的进程间通信机制，例如通过子进程的退
出代码进行通信的方式等。 
5.1 共享内存 
共享内存是进程间通信中最简单的方式之一。共享内存允许两个或更多进程访问同一块
内存，就如同 malloc() 函数向不同进程返回了指向同一个物理内存区域的指针。当一个
进程改变了这块地址中的内容的时候，其它进程都会察觉到这个更改。 
5.1.1 快速本地通信 
因为所有进程共享同一块内存，共享内存在各种进程间通信方式中具有最高的效率。访
问共享内存区域和访问进程独有的内存区域一样快，并不需要通过系统调用或者其它需要切
www.AdvancedLinuxProgramming.com 
80
高级 Linux 程序设计·卷一·Linux 平台上的高级 UNIX 编程 
完美废人 译 
入内核的过程来完成。同时它也避免了对数据的各种不必要的复制。 
因为系统内核没有对访问共享内存进行同步，你必须提供自己的同步措施。例如，在数
据被写入之前不允许进程从共享内存中读取信息、不允许两个进程同时向同一个共享内存地
址写入数据等。解决这些问题的常用方法是通过使用信号量进行同步。信号量的使用将在下
一节中介绍。不过，我们的程序中只有一个进程访问了共享内存，因此在集中展示了共享内
存机制的同时，我们避免了让代码被同步逻辑搞得混乱不堪。 
5.1.2 内存模型 
要使用一块共享内存，进程必须首先分配它。随后需要访问这个共享内存块的每一个进
程都必须将这个共享内存绑定到自己的地址空间中。当完成通信之后，所有进程都将脱离共
享内存，并且由一个进程释放该共享内存块。 
理解 Linux 系统内存模型可以有助于解释这个绑定的过程。在 Linux 系统中，每个进程
的虚拟内存是被分为许多页面的。这些内存页面中包含了实际的数据。每个进程都会维护一
个从内存地址到虚拟内存页面之间的映射关系。尽管每个进程都有自己的内存地址，不同的
进程可以同时将同一个内存页面映射到自己的地址空间中，从而达到共享内存的目的。第八
章“Linux 系统调用”中第八节“mlock 族：锁定物理内存”将对内存页面做深入的探讨。 
分配一个新的共享内存块会创建新的内存页面。因为所有进程都希望共享对同一块内存
的访问，只应由一个进程创建一块新的共享内存。再次分配一块已经存在的内存块不会创建
新的页面，而只是会返回一个标识该内存块的标识符。一个进程如需使用这个共享内存块，
则首先需要将它绑定到自己的地址空间中。这样会创建一个从进程本身虚拟地址到共享页面
的映射关系。当对共享内存的使用结束之后，这个映射关系将被删除。当再也没有进程需要
使用这个共享内存块的时候，必须有一个（且只能是一个）进程负责释放这个被共享的内存
页面。 
所有共享内存块的大小都必须是系统页面大小的整数倍。系统页面大小指的是系统中单
个内存页面包含的字节数。在 Linux 系统中，内存页面大小是 4KB，不过你仍然应该通过调
用 getpagesize 获取这个值。 
5.1.3 分配 
进程通过调用 shmget（SHared Memory GET，获取共享内存）来分配一个共享内存块。
该函数的第一个参数是一个用来标识共享内存块的键值。彼此无关的进程可以通过指定同一
个键以获取对同一个共享内存块的访问。不幸的是，其它程序也可能挑选了同样的特定值作
为自己分配共享内存的键值，从而产生冲突。用特殊常量 IPC_PRIVATE 作为键值可以保证
系统建立一个全新的共享内存块。 
该函数的第二个参数指定了所申请的内存块的大小。因为这些内存块是以页面为单位进
行分配的，实际分配的内存块大小将被扩大到页面大小的整数倍。 
第三个参数是一组标志，通过特定常量的按位或操作来 shmget。这些特定常量包括： 
· IPC_CREAT：这个标志表示应创建一个新的共享内存块。通过指定这个标志，我
们可以创建一个具有指定键值的新共享内存块。 
· IPC_EXCL：这个标志只能与 IPC_CREAT 同时使用。当指定这个标志的时候，
如果已有一个具有这个键值的共享内存块存在，则 shmget 会调用失败。也就是说，
这个标志将使线程获得一个“独有”的共享内存块。如果没有指定这个标志而系统
中存在一个具有相通键值的共享内存块，shmget 会返回这个已经建立的共享内存
块，而不是重新创建一个。 
· 模式标志（Mode flags）：这个值由 9 个位组成，分别表示属主、属组和其它用户
www.AdvancedLinuxProgramming.com 
81
高级 Linux 程序设计·卷一·Linux 平台上的高级 UNIX 编程 
完美废人 译 
对该内存块的访问权限。其中表示执行权限的位将被忽略。指明访问权限的一个简
单办法是利用中指定，并且在手册页第二节stat条目中说明了的
常量指定
１。例如，S_IRUSR和S_IWUSR分别指定了该内存块属主的读写权限，
而 S_IROTH和S_IWOTH则指定了其它用户的读写权限。 
下面例子中 shmget 函数创建了一个新的共享内存块（当 shm_key 已被占用时则获取
对一个已经存在共享内存块的访问），且只有属主对该内存块具有读写权限，其它用户不可
读写。 
int segment_id = shmget (shm_key, getpagesize (), 
IPC_CREAT | S_IRUSR| S_IWUSR ); 
如果调用成功，shmget 将返回一个共享内存标识符。如果该共享内存块已经存在，系
统会检查访问权限，同时会检查该内存块是否被标记为等待摧毁状态。 
5.1.4 绑定和脱离 
要让一个进程获取对一块共享内存的访问，这个进程必须先调用 shmat（SHared 
Memory Attach，绑定到共享内存）。将 shmget 返回的共享内存标识符 SHMID 传递给这个
函数作为第一个参数。该函数的第二个参数是一个指针，指向你希望用于映射该共享内存块
的进程内存地址；如果你指定 NULL 则 Linux 会自动选择一个合适的地址用于映射。第三个
参数是一个标志位，包含了以下选项： 
· SHM_RND 表示第二个参数指定的地址应被向下靠拢到内存页面大小的整数倍。
如果你不指定这个标志，你将不得不在调用 shmat 的时候手工将共享内存块的大
小按页面大小对齐。 
· SHM_RDONLY 表示这个内存块将仅允许读取操作而禁止写入。 
如果这个函数调用成功则会返回绑定的共享内存块对应的地址。通过 fork 函数创建的
子进程同时继承这些共享内存块；如果需要，它们可以主动脱离这些共享内存块。 
当一个进程不再使用一个共享内存块的时候应通过调用 shmdt（SHared Memory 
DeTach，脱离共享内存块）函数与该共享内存块脱离。将由 shmat 函数返回的地址传递给
这个函数。如果当释放这个内存块的进程是最后一个使用该内存块的进程，则这个内存块将
被删除。对 exit 或任何 exec 族函数的调用都会自动使进程脱离共享内存块。 
5.1.5 控制和释放共享内存块 
调用 shmctl（"SHared Memory ConTroL"，控制共享内存）函数会返回一个共享内存
块的相关信息。同时 shmctl 允许程序修改这些信息。该函数的第一个参数是一个共享内存
块标识。 
要获取一个共享内存块的相关信息，则为该函数传递 IPC_STAT 作为第二个参数，同
时传递一个指向一个 struct shmid_ds 对象的指针作为第三个参数。 
要删除一个共享内存块，则应将 IPC_RMID 作为第二个参数，而将 NULLL 作为第三
个参数。当最后一个绑定该共享内存块的进程与其脱离时，该共享内存块将被删除。 
你应当在结束使用每个共享内存块的时候都使用 shmctl 进行释放，以防止超过系统所
允许的共享内存块的总数限制。调用 exit 和 exec 会使进程脱离共享内存块，但不会删除
这个内存块。 
www.AdvancedLinuxProgramming.com 
82
１ 这些权限位与用于控制文件权限的相同。10.3 节“文件系统权限”对它们做了更多的介绍。 
高级 Linux 程序设计·卷一·Linux 平台上的高级 UNIX 编程 
完美废人 译 
要查看其它有关共享内存块的操作的描述，请参考 shmctl 函数的手册页。 
5.1.6 示例程序 
代码列表 5.1 中的程序展示了共享内存块的使用。 
代码列表 5.1 (shm.c) 尝试共享内存 
#include  
#include  
#include  
int main () 
{ 
  int segment_id; 
  char* shared_memory; 
  struct shmid_ds shmbuffer; 
  int segment_size; 
  const int shared_segment_size = 0x6400; 
  /* 分配一个共享内存块 */ 
  segment_id 
= 
shmget 
(IPC_PRIVATE, 
shared_segment_size, 
IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR ); 
  /* 绑定到共享内存块 */ 
  shared_memory = (char*) shmat (segment_id, 0, 0); 
  printf 
("shared 
memory 
attached 
at 
address 
%p\n", 
shared_memory); 
  /* 确定共享内存的大小 */ 
  shmctl (segment_id, IPC_STAT, &shmbuffer); 
  segment_size = shmbuffer.shm_segsz; 
  printf ("segment size: %d\n", segment_size); 
  /* 在共享内存中写入一个字符串 */ 
  sprintf (shared_memory, "Hello, world."); 
  /* 脱离该共享内存块 */ 
  shmdt (shared_memory); 
  /* 重新绑定该内存块 */ 
  shared_memory = (char*) shmat (segment_id, (void*) 0x500000, 0); 
  printf 
("shared 
memory 
reattached 
at 
address 
%p\n", 
shared_memory); 
  /* 输出共享内存中的字符串 */ 
  printf ("%s\n", shared_memory); 
  /* 脱离该共享内存块 */ 
  shmdt (shared_memory); 
www.AdvancedLinuxProgramming.com 
83
高级 Linux 程序设计·卷一·Linux 平台上的高级 UNIX 编程 
完美废人 译 
  /* 释放这个共享内存块 */ 
  shmctl (segment_id, IPC_RMID, 0); 
  return 0; 
} 
5.1.7 调试 
使用 ipcs 命令可用于查看系统中包括共享内存在内的进程间通信机制的信息。指定-m
参数以获取有关共享内存的信息。例如，以下的示例表示有一个编号为 1627649 的共享内存
块正在使用中： 
  % ipcs -m 
  ------ Shared Memory Segments -------- 
  key       shmid     owner     perms     bytes    nattch     status 
  0x00000000 1627649   user    640       25600    0 
如果这个共享内存块在程序结束后没有被删除而是被错误地保留下来，你可以用 ipcrm