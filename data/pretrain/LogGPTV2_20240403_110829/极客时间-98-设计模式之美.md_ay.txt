# 34 \| 实战一（上）：通过一段ID生成器代码，学习如何发现代码质量问题在前面几节课中，我们讲了一些跟重构相关的理论知识，比如：持续重构、单元测试、代码的可测试性、解耦、编码规范。用一句话总结一下，重构就是发现代码质量问题，并且对其进行优化的过程。前面的内容相对还是偏理论。今天，我就借助一个大家都很熟悉的 ID生成器代码，给你展示一下重构的大致过程。整个内容分为两节课。这一节课我们讲述如何发现代码质量问题，下一节课讲述如何针对发现的质量问题，对其进行优化，将它从"能用"变得"好用"。话不多说，让我们正式开始今天的学习吧！ID 生成器需求背景介绍"ID"中文翻译为"标识（Identifier）"。这个概念在生活、工作中随处可见，比如身份证、商品条形码、二维码、车牌号、驾照号。聚焦到软件开发中，ID常用来表示一些业务信息的唯一标识，比如订单的单号或者数据库中的唯一主键，比如地址表中的ID字段（实际上是没有业务含义的，对用户来说是透明的，不需要关注）。假设你正在参与一个后端业务系统的开发，为了方便在请求出错时排查问题，我们在编写代码的时候会在关键路径上打印日志。某个请求出错之后，我们希望能搜索出这个请求对应的所有日志，以此来查找问题的原因。而实际情况是，在日志文件中，不同请求的日志会交织在一起。如果没有东西来标识哪些日志属于同一个请求，我们就无法关联同一个请求的所有日志。这听起来有点像微服务中的调用链追踪。不过，微服务中的调用链追踪是服务间的追踪，我们现在要实现的是服务内的追踪。借鉴微服务调用链追踪的实现思路，我们可以给每个请求分配一个唯一ID，并且保存在请求的上下文（Context）中，比如，处理请求的工作线程的局部变量中。在Java 语言中，我们可以将 ID 存储在 Servlet 线程的 ThreadLocal中，或者利用 Slf4j 日志框架的 MDC（Mapped DiagnosticContexts）来实现（实际上底层原理也是基于线程的ThreadLocal）。每次打印日志的时候，我们从请求上下文中取出请求ID，跟日志一块输出。这样，同一个请求的所有日志都包含同样的请求 ID信息，我们就可以通过请求 ID来搜索同一个请求的所有日志了。好了，需求背景我们已经讲清楚了，至于具体如何实现整个需求，我就不展开来讲解了。如果你感兴趣的话，可以自己试着去设计实现一下。我们接下来只关注其中生成请求ID 这部分功能的开发。一份"能用"的代码实现假设 leader 让小王负责这个 ID生成器的开发。对于稍微有点开发经验的程序员来说，实现这样一个简单的 ID生成器，并不是件难事。所以，小王很快就完成了任务，将代码写了出来，具体如下所示：    public class IdGenerator {      private static final Logger logger = LoggerFactory.getLogger(IdGenerator.class);      public static String generate() {        String id = "";        try {          String hostName = InetAddress.getLocalHost().getHostName();          String[] tokens = hostName.split("\\.");          if (tokens.length > 0) {            hostName = tokens[tokens.length - 1];          }          char[] randomChars = new char[8];          int count = 0;          Random random = new Random();          while (count = 48 && randomAscii = 65 && randomAscii = 97 && randomAscii  0) {            hostName = tokens[tokens.length - 1];          }          char[] randomChars = new char[8];          int count = 0;          Random random = new Random();          while (count = 48 && randomAscii = 65 && randomAscii = 97 && randomAscii = '0' && randomAscii = 'A' && randomAscii = 'a' && randomAscii ```    public class RandomIdGenerator implements IdGenerator {      private static final Logger logger = LoggerFactory.getLogger(RandomIdGenerator.class);      @Override      public String generate() {        String substrOfHostName = getLastfieldOfHostName();        long currentTimeMillis = System.currentTimeMillis();        String randomString = generateRandomAlphameric(8);        String id = String.format("%s-%d-%s",                substrOfHostName, currentTimeMillis, randomString);        return id;      }      private String getLastfieldOfHostName() {        String substrOfHostName = null;        try {          String hostName = InetAddress.getLocalHost().getHostName();          substrOfHostName = getLastSubstrSplittedByDot(hostName);        } catch (UnknownHostException e) {          logger.warn("Failed to get the host name.", e);        }        return substrOfHostName;      }      @VisibleForTesting      protected String getLastSubstrSplittedByDot(String hostName) {        String[] tokens = hostName.split("\\.");        String substrOfHostName = tokens[tokens.length - 1];        return substrOfHostName;      }      @VisibleForTesting      protected String generateRandomAlphameric(int length) {        char[] randomChars = new char[length];        int count = 0;        Random random = new Random();        while (count = '0' && randomAscii = 'A' && randomAscii = 'a' && randomAscii  '9') || ('a'  'z') || ('A'      * The IDs generated by this class are not absolutely unique,     * but the probability of duplication is very low.     */    public class RandomIdGenerator implements IdGenerator {      private static final Logger logger = LoggerFactory.getLogger(RandomIdGenerator.class);      /**       * Generate the random ID. The IDs may be duplicated only in extreme situation.       *       * @return an random ID       */      @Override      public String generate() {        //...      }      /**       * Get the local hostname and       * extract the last field of the name string splitted by delimiter '.'.       *       * @return the last field of hostname. Returns null if hostname is not obtained.       */      private String getLastfieldOfHostName() {        //...      }      /**       * Get the last field of {@hostName} splitted by delemiter '.'.       *       * @param hostName should not be null       * @return the last field of {@hostName}. Returns empty string if {@hostName} is empty string.       */      @VisibleForTesting      protected String getLastSubstrSplittedByDot(String hostName) {        //...      }      /**       * Generate random string which       * only contains digits, uppercase letters and lowercase letters.       *       * @param length should not be less than 0       * @return the random string. Returns empty string if {@length} is 0       */      @VisibleForTesting      protected String generateRandomAlphameric(int length) {        //...      }    }重点回顾好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要掌握的重点内容。在这节课中，我带你将小王写的凑活能用的代码，重构成了结构更加清晰、更加易读、更易测试的代码，并且为其补全了单元测试。这其中涉及的知识点都是我们在理论篇中讲过的内容，比较细节和零碎，我就不一一带你回顾了，如果哪里不是很清楚，你可以回到前面章节去复习一下。实际上，通过这节课，我更想传达给你的是下面这样几个开发思想，我觉得这比我给你讲解具体的知识点更加有意义。1.       即便是非常简单的需求，不同水平的人写出来的代码，差别可能会很大。我们要对代码质量有所追求，不能只是凑活能用就好。花点心思写一段高质量的代码，比写    100    段凑活能用的代码，对你的代码能力提高更有帮助。        2.       知其然知其所以然，了解优秀代码设计的演变过程，比学习优秀设计本身更有价值。知道为什么这么做，比单纯地知道怎么做更重要，这样可以避免你过度使用设计模式、思想和原则。        3.       设计思想、原则、模式本身并没有太多"高大上"的东西，都是一些简单的道理，而且知识点也并不多，关键还是锻炼具体代码具体分析的能力，把知识点恰当地用在项目中。        4.       我经常讲，高手之间的竞争都是在细节。大的架构设计、分层、分模块思路实际上都差不多。没有项目是靠一些不为人知的设计来取胜的，即便有，很快也能被学习过去。所以，关键还是看代码细节处理得够不够好。这些细节的差别累积起来，会让代码质量有质的差别。所以，要想提高代码质量，还是要在细节处下功夫。        课堂讨论1.       获取主机名失败的时候，generate() 函数应该返回什么最合适呢？是特殊    ID、null、空字符，还是异常？在小王的代码实现中，获取主机名失败异常在    IdGenerator    内部被吐掉了，打印一条报警日志，并没有继续往上抛出，这样的异常处理是否得当？        2.       为了隐藏代码实现细节，我们把 getLastSubstrSplittedByDot(String    hostName) 函数命名替换成 getLastSubstrByDelimiter(String    hostName)，这样是否更加合理？为什么？        欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。