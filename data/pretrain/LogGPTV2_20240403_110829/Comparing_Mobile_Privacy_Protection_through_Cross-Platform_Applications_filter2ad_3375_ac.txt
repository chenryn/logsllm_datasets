sizes and alignments. Without knowing the starting point of
a method, IDA may treat a code fragment as a data entry by
mistake. Thus, our analysis tool extracts metadata5 from the
application binary to guide IDA’s disassembling process.
After disassembling all methods in IDA, the next step
is to resolve all the API calls in the assembly instructions,
where the key step is to handle the objc msgSend function.
In an Objective-C executable, all accesses to a method or
attribute of an Objective-C object at runtime utilize this
objc msgSend function, which is used to send messages to an
instance of class in memory [15]. To statically determine the
corresponding API call for each observed objc msgSend, we
adopt the backward slicing and forward constant propagation
proposed by [16] in our iOS static analysis tool. The work
ﬂow of our iOS static analysis tool is illustrated in Figure 4.
Figure 4. The work ﬂow of our iOS static analysis tool.
The last step of our static analysis tool
is to output
the set of SS-API types used in an iOS application. The
access to most SS-API types can be directly recognized
through corresponding API classes and methods, for exam-
ple, user contacts are operated through ABPerson and ABAd-
dressBook related APIs. However, some SS-API types like
CALL PHONE and SEND SMS require further analysis of the
parameter value. For example, given an API call [[UIApplica-
tion sharedApplication] openURL:[NSURL URLWithString:[NSString
stringWithFormat:@“tel:123-456-7890”]]],
this will only launch
the phone dialer when the string parameter starts with “tel:”
preﬁx. The SS-API type SEND SMS, however, has two forms
of realizing the SMS functionality – the SMS sending view
can be triggered by openURL with “sms:” preﬁx; an applica-
tion can also call API such as MFMessageComposeViewCon-
troller.setMessageComposeDelegate to send SMS messages. We
carefully handle each of the cases for every resolved API call
and corresponding parameter values in order to detect such
SS-API invocations.
VI. COMPARISON ANALYSIS RESULTS
We applied our static analysis tools to the 1,300 pairs
of selected cross-platform applications (downloaded in June
2012), the basic statistics of these applications are given in
Table V. The direct outputs of our analysis tools are the
5These metadata extracted include the class names, the instance method
list, the class method list, the instance variable list, the property list and
the protocols that classes conform to. For each method, the method name,
method signature string, and the start address of the method body are
collected to guide IDA disassembling process.
lists of SS-API types accessed by these applications. By
obtaining such lists, we are then able to compare the SS-
API usage for each pair of cross-platform applications.
STATISTICS OF DOWNLOADED CROSS-PLATFORM APPLICATIONS
Table V
Parameters
Number of apps
App size range (.apk & .ipa)
Total size of apps
App executable ﬁle size range
(.dex & Objective-C binary)
Total size of executable ﬁles
Android apps
11KB(cid:24)47MB
1,300
7.42 GB
3KB(cid:24)6.2MB
iOS apps
1,300
106KB(cid:24)366MB
14.5 GB
25KB(cid:24)39.5MB
1.10 GB
5.03 GB
A. Comparisons on both-supported SS-API types
Our ﬁrst comparison focuses on the 20 SS-API types that
are both supported on Android and iOS. We are interested
in ﬁnding out how differently these SS-API types are used
on the two platforms for cross-platform applications. Our
results show that the total amount of SS-API types 6 that
are used by 1,300 Android applications is 4,582, which
indicates that each Android application uses 3.5 SS-API
types on average. In comparison, the corresponding 1,300
iOS applications access a total amount of 7,739 SS-API
types, which has on average 5.9 types per iOS application.
948 (73%) of the applications on iOS access additional SS-
API types compared to its Android version.
Among the 20 different SS-API types, some of them
are accessed almost equally by the applications on both
platforms. For example,
INTERNET is required by 1,247
Android applications, and 1,253 iOS applications. However,
some other SS-API types are used much more often by iOS
applications compared to Android applications. The top 10
SS-API types that are accessed more often on iOS compared
to Android are listed in Table VI.
To obtain a detailed understanding of the results provided
in Table VI, we look into typical applications in each SS-
API type. We ﬁnd out that famous applications such as
Twitter and XECurrency [17] do not access READ DEVICE ID
APIs on Android. However, on their corresponding iOS
version, we observe 5 locations in Twitter’s code and 6
locations in XECurrency’s code which read the device ID.
Another typical instance is the famous free game “Words
With Friends” [18] application. Compared to its Android
version, the additional SS-API types accessed by its iOS
version include (but are not limited to):
(cid:15) BATTERY STATS, as API call UIDevice.setBatteryMoni-
toringEnabled is observed;
(cid:15) CALL PHONE, as UIApplication.openURL with “tel:” param-
eter is observed in IMAdView.placeCallTo and two other
locations;
(cid:15) CAMERA, as UIImagePickerController.setSourceType with
argument value 0x1 (which is UIImagePickerCo-
ntrollerSourceTypeCamera) is observed in MobclixRich-
MediaWebAdView.takePhotoAndReturnToWebview;
(cid:15) FLASHLIGHT, as AVCaptureDevice.setTorchMode is ob-
served in MobclixRichMediaWebAdView.turnFlashlight-
OnWithSuccess; etc.
More interestingly, we also check the most popular game
application Angry Birds, although it does not belong to the
1,300 sampling set as it is not free on iOS. The result
shows that compared to its Android version, Angry Birds
on iOS additionally reads the user contacts data, as API
call ABAddressBookGetPersonWithRecordID and ABAddressBook-
CopyArrayOfAllPeople are observed in the code section of
CCPrivateSession.getArrayOfAddressBookEmailAddresses-
NamesAndContactIDs and four other locations7.
As shown in Table VI, our ﬁndings in the comparisons
on the 20 SS-API types both supported on Android and iOS
show that iOS third-party applications turn to access more
often to some devices (such as camera and vibration) and
are more likely to access sensitive data such as device ID,
user contacts and calendar. Thus, our next step of analysis
is to ﬁnd out the underlying reason why such phenomenon
exists. As one may notice from the examples given above,
some of these APIs are actually invoked by the third-party
libraries used in these applications (such as IMAdView and
MobclixRichMediaWebAdView classes in the WordsWithFriends
application). Thus, our next step is to analyze the SS-API
usage of the third-party libraries on both platforms.
B. SS-API Usage of Third-party Libraries
In order to analyze the SS-API usage of third-party
libraries, ﬁrst of all, we need to identify all
the third-
party libraries within each application. As there are no clear
boundaries that an included library or package in a given
application is written by the application developer or belongs
to a third-party library, we ﬁrst process the whole application
set to calculate the number of different package names (on
Android) or class names (on iOS). Then the packages or
classes that appear in more than 10 applications (and at
least belong to two different companies) are automatically
collected. We then manually check this list to identify the
third-party libraries, which include advertisement libraries,
analytic libraries or just third-party development libraries.
Some of the packages or classes are combined because
they belong to the same third-party library. Finally, we
6The set of SS-API types used by an application contains no duplicates,
which indicates that the maximum number of SS-API types used by each
application is 20. When calculating the total amount of SS-API types for
1300 applications, we simply sum the number of SS-API types used by
each application.
7The API calls which access user contacts have been observed in all
previous versions of Angry Birds including version 2.1.0, which was
released in March 2012. However, from Angry Birds version 2.2.0 (released
in August 2012), these API calls have been removed from this game, which
is probably due to the privacy changes of the newly released iOS 6.
SS-API TYPES WITH GREATEST DISPARITY THAT ARE ACCESSED BY THE APPLICATIONS ON ANDROID AND IOS.
Table VI
SS-API type
READ DEVICE ID
CAMERA
VIBRATE
ACCESS NETWORK INFO
READ CONTACTS
SEND SMS
WRITE CONTACTS
ACCESS LOCATION
RECORD AUDIO
READ CALENDAR
Number of
Android apps
Number of
iOS apps
510
172
374
885
151
29
86
553
37
35
925
601
522
1065
388
264
297
728
177
174
Only on
iOS1
469
435
290
269
256
248
219
217
155
141
Only on
Android
On both
platforms
54
6
142
89
19
13
8
42
15
2
456
166
232
796
132
16
78
511
22
33
Lib / App
Ratio2
60% / 64%
38% / 73%
62% / 46%
15% / 96%
52% / 75%
49% / 68%
51% / 80%
48% / 67%
35% / 99%
35% / 67%
Exclusive Lib / App
Ratio3
36% / 40%
27% / 62%
54% / 38%
4% / 86%
25% / 48%
32% / 51%
20% / 49%
33% / 53%
1% / 65%
33% / 65%
1 The number of cross-platform apps which access the corresponding SS-API type only in its iOS version, but not in its Android version. The value of this
column equals to the difference between “Number of iOS apps” and “On both platforms”.
2 A break-down for the sources of SS-API types: Lib – from third-party libs; App – from the app’s own code. The base of the ratio is column “Only on iOS”.
3 The ratio of applications in column “Only on iOS”, where the corresponding SS-API type is exclusively caused by third-party libraries or apps’ own code.
identiﬁed 79 third-party libraries on Android and 72 third-
party libraries on iOS that are commonly used. The 8 most
commonly used advertising and analytic libraries on Android
are listed in Table VII, and the 8 most common libraries on
iOS are listed in Table VIII.
these two tables clearly indicate that libraries on iOS turn
to access more SS-API types compared to Android third-
party libraries. Thus, the SS-API usage difference for those
cross-platform applications is indeed partially caused by the
difference of third-party libraries.
Table VII
App Ratio
MOST COMMON ADVERTISING/ANALYTIC LIBRARIES ON ANDROID
Library Name
com/google/ads
com/ﬂurry/android
com/google/android/apps/analytics
com/tapjoy
com/millennialmedia/android
com/admob/android/ads
com/adwhirl
com/mobclix/android/sdk
* The abbreviations of these SS-API types are given in Table IV.
SS-API types*
ANI, INT
LOC, INT
ANI
INT, RDI
ANI, INT, RDI
LOC, INT
LOC, INT
LOC, ANI, INT, RDI
21.7%
19.1%
12.5%
7.9%
7.3%
4.4%
3.8%
3.2%
MOST COMMON ADVERTISING/ANALYTIC LIBRARIES ON IOS
Table VIII
Library Name
Flurry
GoogleAds
Google Analytics
Millennial Media
TapJoy
AdMob
AdWhirl
Mobclix
App Ratio
19.9%
15.9%
9.8%
9.3%
9.1%
7.2%
6.9%
3.7%
SS-API types*
LOC, INT, RDI
ANI, INT, RDI, SMS, VIB, WAK
INT
LOC, ANI, CAM, INT, CON,
RDI, VIB
ANI, INT, RDI
LOC, INT, CON, RDI
LOC, ANI, INT, RDI
LOC, ANI, BAT, CAM, FLA, INT,
CAL, CON, RDI, SMS, VIB
* The abbreviations of these SS-API types are given in Table IV.
By tracking the code regions of these libraries, our static
analysis tools are able to determine the origin of the SS-API
calls in each application. We can then identify the types of
SS-APIs used in each third-party library on both platforms,
which are shown in Table VII and Table VIII. The data from
To quantify the inﬂuence of the third-party libraries on the
SS-API usage difference between the two versions of cross-
platform applications, for each SS-API type, we ﬁrst identify
those applications which access the corresponding SS-API
type only on its iOS version, but not on Android version
(which is the “Only on iOS” column in Table VI). For
each of these applications, we then track the origins in the
code which access the corresponding SS-APIs – either from
the third-party libraries used in the application, or from the
application’s own code. The results are shown in the last two
columns in Table VI. The two ratios in the “Lib/App Ratio”
column represent the percentage of the applications that: (a)
the third-party libraries used in the application access the
corresponding SS-API type; (b) the application’s own code
access the corresponding SS-API type. As can be seen from
the table, the sum of these two ratios is more than 100%.
This is because in some applications, SS-APIs belong to the
same type are used both in the application’s own code and
in the third-party libraries. Thus, the last column in Table VI
is given, which shows the percentage of applications, where
the corresponding SS-API type is only used by the third-
party libraries or application’s own code.
From the results shown in Table VI, we can see that the
third-party libraries do have certain impacts on the difference
of the SS-API usage for cross-platform applications. For
example, 54% applications which use additional VIBRATE
APIs on iOS is purely because of the third-party libraries
used in these applications. And from Table VIII we can ﬁnd
the exact source – libraries such as GoogleAds, Millennial
Media and Mobclix all use VIBRATE APIs. Thus, any ap-
plication which includes these libraries will in turn use this
SS-API type. Similar links can be drawn from Table VI and
Table VIII for other SS-API types such as READ DEVICE ID
and READ CONTACTS.
Comparing the data in Table VII and Table VIII, the
results show that the most commonly used third-party li-
braries, especially advertisement and analytic libraries on
iOS, access much more SS-APIs compared to the libraries on