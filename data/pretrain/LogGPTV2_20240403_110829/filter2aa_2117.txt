Return to sender
Detecting kernel exploits with eBPF
Guillaume Fournier
August 2022
About me
â— Cloud Workload Security (CWS)
â— Leverage eBPF to detect threats
â— Embedded in the Datadog Agent
Blackhat 2022
Guillaume Fournier
Senior Security Engineer @Datadog
PI:EMAIL
2
â— Context and threat model
â— Why eBPF ?
â— KRIe
â—‹
SMEP & SMAP on a budget
â—‹
Kernel security conï¬guration
â—‹
Kernel runtime alterations
â—‹
Control ï¬‚ow integrity
â—‹
Enforcement
â— Performance
Agenda
3
Context and threat model
â— Critical CVEs are regularly discovered in the Linux Kernel
â— Security administrators worry about:
â—‹ Keeping up with security updates
â—‹ Deploying security patches
â—‹ Monitoring & protecting vulnerable hosts
Blackhat 2022
4
Context and threat model
â— Hundreds of ways to exploit the Linux kernel
â— This talk targets 3 types of vulnerabilities:
â—‹ Execution ï¬‚ow redirections
â—‹ Logic bugs
â—‹ Post compromise kernel runtime alterations
The goal is to detect (and prevent ?) these attacks with eBPF
Blackhat 2022
5
Context and threat model
â— Hundreds of ways to exploit the Linux kernel
â— This talk targets 3 types of vulnerabilities:
â—‹ Execution ï¬‚ow redirection
â—‹ Logic bugs
â—‹ Post compromise kernel runtime alteration
The goal is to detect (and prevent ?) these attacks with eBPF
Make attackersâ€™ lives a living hell
6
Blackhat 2022
What is eBPF ?
â— Run sandboxed programs in the Linux kernel
7
Blackhat 2022
Why eBPF ?
â— Relatively wide kernel support (4.1 +) depending on eBPF 
features
â— System safety and stability insurances
â— Rich feature set with easy to use introspection capabilities
â— Some write access and enforcement capabilities
8
Blackhat 2022
Why eBPF ?
Why is this a terrible idea ?
â— Detecting post compromission is ï¬ghting a lost battle
â— There are dozens of ways to disable an eBPF program
â— eBPF can have a signiï¬cant in kernel performance impact
So whatâ€™s the point ?
â— Script kiddies and OOTB rootkits
â— Make it harder to exploit a ï¬‚aw
â— Detecting & blocking pre-compromission is sometimes 
possible
9
Blackhat 2022
â— Open source project
â— Compile Once Run 
Everywhere
â— Compatible with at least 
kernels 4.15+ to now
â— First version released today !
Kernel 
Runtime 
Integrity 
with eBPF
(KRIe)
https://github.com/Gui774ume/krie
10
KRIe: SMEP & SMAP on a budget 
Scenario 1: the attacker controls the address of the next instruction 
executed by the kernel
â— Textbook use case for Return Object Programming (ROP) 
attacks
â— Supervisor Mode Access Prevention (SMAP)
â— Supervisor Memory Execute Protection (SMEP)
11
Blackhat 2022
KRIe: SMEP & SMAP on a budget 
Scenario 1: the attacker controls the address of the next instruction 
executed by the kernel
Kernel Executable code
User space memory
Addresses
Bytecode
Addresses
Bytecode
12
Blackhat 2022
KRIe: SMEP & SMAP on a budget 
Attacker 
jumps to
Kernel Executable code
User space memory
Addresses
Bytecode
Addresses
Bytecode
[@stack_pivot]
xchg esp, eax ; ret
Scenario 1: the attacker controls the address of the next instruction 
executed by the kernel
13
Blackhat 2022
KRIe: SMEP & SMAP on a budget 
Attacker 
jumps to
Kernel Executable code
User space memory
Addresses
Bytecode
Addresses
Bytecode
[@stack_pivot]
xchg esp, eax ; ret
[@rop_chain]
[@rop_chain+8]
[@rop_chain+16]
@gadget_1
0x42
@kernel_func
Stack pivot
Scenario 1: the attacker controls the address of the next instruction 
executed by the kernel
14
Blackhat 2022
KRIe: SMEP & SMAP on a budget 
Kernel Executable code
User space memory
Addresses
Bytecode
Addresses
Bytecode
[@stack_pivot]
[@kernel_func] 
xchg esp, eax ; ret
push %rbp
[@rop_chain]
[@rop_chain+8]
[@rop_chain+16]
@gadget_1
0x42
@kernel_func
Attacker 
jumps to
Stack pivot
Execute a kernel function with 
attacker controlled parameters
Scenario 1: the attacker controls the address of the next instruction 
executed by the kernel
15
Blackhat 2022
KRIe: SMEP & SMAP on a budget 
Attacker 
jumps to
Kernel Executable code
User space memory
Addresses
Bytecode
Addresses
Bytecode
[@stack_pivot]
[@kernel_func] 
xchg esp, eax ; ret
push %rbp
[@rop_chain]
[@rop_chain+8]
[@rop_chain+16]
@gadget_1
0x42
@kernel_func
Not possible 
with SMAP
Scenario 1: the attacker controls the address of the next instruction 
executed by the kernel
Stack pivot
16
Blackhat 2022
KRIe: SMEP & SMAP on a budget 
â— SMEP would have prevented the CPU from executing code 
in user space executable memory
â— Our example ROP chain will eventually call:
commit_creds(prepare_kernel_cred(0))
What can we do for machines without SMEP / SMAP ?
17
Blackhat 2022
KRIe: SMEP & SMAP on a budget 
â” Place a kprobe on â€œprepare_kernel_credâ€ and check if the 
Stack pointer / Frame pointer / Instruction pointer registers 
point to user space memory
Demo
(Ubuntu Bionic 18.04 - Kernel 4.15.0-189-generic - SMAP disabled)
18
Blackhat 2022
KRIe: SMEP & SMAP on a budget 
â— On a budget because:
â—‹ Need to hook â€œall the functions called by exploitsâ€
â—‹ Blocking mode only works on 5.3+ kernels
â—‹ An attacker will try to prevent our kprobe from ï¬ring â€¦
19
Blackhat 2022
KRIe: SMEP & SMAP on a budget 
â— So â€¦ how can one disable a kprobe ?
â—‹ echo 0 > /sys/kernel/debug/kprobes/enabled
â—‹ sysctl kernel.ftrace_enabled=0
â—‹ Killing the user space process that loaded the kprobe
20
Blackhat 2022
KRIe: SMEP & SMAP on a budget 
â— So â€¦ how can one disable a kprobe ?
â—‹ echo 0 > /sys/kernel/debug/kprobes/enabled
â—‹ sysctl kernel.ftrace_enabled=0
â—‹ By killing the user space process that loaded the kprobe
â” Letâ€™s booby trap everything ğŸ‰
21
Blackhat 2022
KRIe: Kernel security conï¬guration 
1) echo 0 > /sys/kernel/debug/kprobes/enabled
â— Global switch that disarms all kprobes on a machine
â— The ROP chain can be updated to call
write_enabled_file_bool(NULL, â€œ0â€, 1, NULL)
22
Blackhat 2022
KRIe: Kernel security conï¬guration 
â— Global switch that disarms all kprobes on a machine
â— The ROP chain can be updated to call
write_enabled_file_bool(NULL, â€œ0â€, 1, NULL)
â” Letâ€™s put a kprobe on it ğŸ‰
23
Blackhat 2022
1) echo 0 > /sys/kernel/debug/kprobes/enabled
KRIe: Kernel security conï¬guration 
â— Even when enabled, a kprobe can still be bypassed:
@write_enabled_ï¬le_bool - No kprobe
@write_enabled_ï¬le_bool - With a kprobe
0x0: nop dword ptr [...]
0x5: push   %rbp
0x6: mov    %rsp,%rbp
0x9: push   %r14
0xb: push   %r13
0xd: push   %r12
â€¦
0x0: callq  0xffffffff81a01cf0
0x5: push   %rbp
0x6: mov    %rsp,%rbp
0x9: push   %r14
0xb: push   %r13
0xd: push   %r12
â€¦
24
Blackhat 2022
1) echo 0 > /sys/kernel/debug/kprobes/enabled
KRIe: Kernel security conï¬guration 
@write_enabled_ï¬le_bool - No kprobe
@write_enabled_ï¬le_bool - With a kprobe
0x0: nop dword ptr [...]
0x5: push   %rbp
0x6: mov    %rsp,%rbp
0x9: push   %r14
0xb: push   %r13
0xd: push   %r12
â€¦
0x0: callq  0xffffffff81a01cf0
0x5: push   %rbp
0x6: mov    %rsp,%rbp
0x9: push   %r14
0xb: push   %r13
0xd: push   %r12
â€¦
Jump here
with the ROP
chain
â— Even when enabled, a kprobe can still be bypassed:
25
Blackhat 2022
1) echo 0 > /sys/kernel/debug/kprobes/enabled
KRIe: Kernel security conï¬guration 
â” Booby trap the function at random offsets ğŸ‰
@write_enabled_ï¬le_bool - No kprobe
@write_enabled_ï¬le_bool - With kprobe(s)
0x0: nop dword ptr [...]
0x5: push   %rbp
0x6: mov    %rsp,%rbp
0x9: push   %r14
0xb: push   %r13
0xd: push   %r12
â€¦
0x0: callq  0xffffffff81a01cf0
0x5: push   %rbp
0x6: callq  0xffffffff81a01cf0
0xb: push   %r13
0xd: callq  0xffffffff81a01cf0
â€¦
26
Blackhat 2022
1) echo 0 > /sys/kernel/debug/kprobes/enabled
KRIe: Kernel security conï¬guration 
â— â€œwrite_enabled_file_boolâ€ writes 0 or 1 to a global 
variable called â€œkprobes_all_disarmedâ€
â— An attacker could try to write 1 to it directly
27
Blackhat 2022
1) echo 0 > /sys/kernel/debug/kprobes/enabled
KRIe: Kernel security conï¬guration 
â— â€œwrite_enabled_file_boolâ€ writes 0 or 1 to a global 
variable called â€œkprobes_all_disarmedâ€
â— An attacker could try to write 1 to it directly
â” We can use a BPF_PROG_TYPE_PERF_EVENT program to 
periodically check the values of all sensitive kernel 
parameters ğŸ‰
28
Blackhat 2022
1) echo 0 > /sys/kernel/debug/kprobes/enabled
KRIe: Kernel security conï¬guration 
â— There is an eBPF program type dedicated to monitoring and 
enforcing sysctl commands :
BPF_PROG_TYPE_CGROUP_SYSCTL (kernels 5.2+)
â— (Almost) all sysctl parameters are checked by KRIEâ€™s 
periodical check
2) sysctl kernel.ftrace_enabled=0
29
Blackhat 2022
KRIe: Kernel runtime alterations 
â— Insert a rogue kernel module
â— Hook syscalls to hide their tracks
â—‹ Using kprobes
â—‹ By hooking the syscall table directly
â— BPF ï¬lters are used to silently capture network traï¬ƒc
â— eBPF programs can also be used to implement rootkits
Scenario 2: the attacker is root on the machine and wants to persist its 
access by modifying the kernel runtime
30
Blackhat 2022
KRIe: Kernel runtime alterations 
â” KRIE monitors:
â—†
All bpf() operations and insertion of BPF ï¬lters
â—†
Kernel module load / deletion events
â—†
K(ret)probe registration / deletion / enable / disable / disarm events
â—†
Ptrace events
â—†
Sysctl commands
â—†
Execution of hooked syscalls                            â€¦ and more to come !
Scenario 2: the attacker is root on the machine and wants to persist its 
access by modifying the kernel runtime
31
Blackhat 2022
KRIe: Kernel runtime alterations 
â” All syscall tables are checked periodically with the 
BPF_PROG_TYPE_PERF_EVENT program trick
â” KRIE is also able to detect and report when a process 
executes a hooked syscall
Demo
(Ubuntu Jammy 22.04 - Kernel 5.15.0-43-generic)
32
Blackhat 2022
KRIe: Control ï¬‚ow Integrity (CFI)
â— Locks down the execution ï¬‚ows in the kernel by controlling 
call sites at runtime
â— Usually added at compile time or implemented in hardware
â— CFI is a great way to prevent ROP attacks
â— These features arenâ€™t always available; speciï¬cally the 
hardware ones
33
Blackhat 2022
KRIe: Control ï¬‚ow Integrity (CFI)
â” KRIE locks down jumps between control points
â” Both hook points and parameters are checked
34
Blackhat 2022
KRIe: Control ï¬‚ow Integrity (CFI)
Graph generated with utrace: 
https://github.com/Gui774ume/utrace
Kernel stack traces to commit_creds
KRIe: Control ï¬‚ow Integrity (CFI)
The goal:
â— Catch malicious calls to sensitive functions (via ROP)
â— Detect logic bugs
But:
â— Tedious process
â— Hook points limitations
36
Blackhat 2022
KRIe: Enforcement
â— KRIE enables blocking features when available:
â—‹ bpf_override_return helper (4.16+)
â—‹ BPF_PROG_TYPE_CGROUP_SYSCTL programs (5.2+)
â—‹ bpf_send_signal helper (5.3+)
â—‹ LSM programs (5.7+)
â— Every detection is conï¬gurable:
â—‹ Log
â—‹ Block
â—‹ Kill
â—‹ Paranoid
37
Blackhat 2022
Performance
User space CPU time
Kernel space CPU time
Total elapsed time
Without KRIe
4,320s
88%
568s
12%
5:53.14
With KRIe
(all features)
4,517s
68%
2,097s
32%
8:15.76
+4.5%
+270%
+40%
With KRIe
(syscall hook 
check disabled on 
syscall entry)
4,380s
88%
585s
12%
5:58.36
+1%
+3%
+1%
â— 2 parts to consider
â— Linux kernel compilation time
38
Blackhat 2022
(Benchmark run on a 5.15.0 kernel, 11th Gen Intel(R) Core(TM) i9-11950H @ 2.60GHz, 32GB of RAM, average on 10 iterations)
Thanks
â—
Powerful defensive tools can be implemented with eBPF
â—
eBPF is not really the ideal technology to detect kernel 
exploits
â—
KRIe is realistically a last resort, not a bulletproof strategy
https://github.com/Gui774ume/krie
39