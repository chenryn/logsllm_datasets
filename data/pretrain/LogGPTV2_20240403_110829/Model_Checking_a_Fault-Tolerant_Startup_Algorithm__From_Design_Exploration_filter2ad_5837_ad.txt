two nodes. The model-checking studies showed the neces-
sity and correctness of this mechanism.
There is a class of scenarios similar to the one above
that is not directly addressed by the algorithm: this is where
nodes start up on a single faulty guardian (believing the
other guardian to be unavailable), and only a subset of
them achieve synchronous operation. These scenarios are
excluded in practice by arranging the power-on sequence
so that the guardians are running before the nodes: the al-
gorithm is able to deal with a faulty guardian provided the
other guardian is available at the start of its operation.
SAL 2.0 provides both bounded and symbolic model
checkers. Bounded model checkers, which are based on
propositional satisﬁability (SAT) solvers, are specialized
for detecting bugs: they explore models only to a speci-
ﬁed, bounded depth and can be faster than symbolic model
checkers (which effectively explore the entire statespace)
when bugs are present that can be detected within the
bound. Bounded model checking provides algorithm devel-
opers with another analytical “dial”: they can explore to in-
creasing depths with a bounded model checker and switch
to the “unbounded” depth of a symbolic model checker
only when all the “shallow” bugs have been detected and
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 12:29:32 UTC from IEEE Xplore.  Restrictions apply. 
eliminated. In our big-bang experiments, the SAL bounded
model checker was sometimes more efﬁcient than the sym-
bolic one at exposing the failing scenarios. For example, it
found a violation to the Safety 2 property in a 5-node
system at depth 13 in 93 seconds (solving a SAT problem
with 405,398 nodes), whereas the symbolic model checker
required 127 seconds (for a model with 682 BDD variables).
5.3. Worst-Case Startup Scenarios
We deﬁne
the worst-case
τ wcsup
(startup time in the model), as the maximum du-
ration between 2 or more non-faulty nodes entering the
LISTEN or COLDSTART states and 1 or more non-faulty
nodes reaching the ACTIVE state.
startup time,
We explored worst-case startup times by model check-
ing the timeliness property for different values of
@par startuptime, setting it ﬁrst to some small ex-
plicit value (e.g., 12) and increasing it by small steps (e.g.,
1) until counterexamples were no longer produced. By ex-
ploring different cases and different cluster sizes, we were
able to develop an understanding of the worst-case scenar-
ios.
The deduced formula for worst-case startup time τ wcsup
(which occurs when there is a faulty node) is given in the
following equations.
τ wcsup = τ listen
max−1 + τ slot
max−1 + 2 ∗ τ coldstart
= 3 ∗ τ round − 2 ∗ τ slot
+2 ∗ (2 ∗ τ round − 2 ∗ τ slot ) + τ slot
= 7 ∗ τ round − 5 ∗ τ slot .
5.4. Automated Veriﬁcation and Exhaustive Fault
Simulation
During exploration of the algorithm we were content to
consider modest cluster sizes and fault degrees, but for ver-
iﬁcation we wanted to examine larger clusters and “exhaus-
tive” modeling of faults. The term exhaustive fault simula-
tion was chosen in analogy to fault injection and with re-
spect to the nomenclature given in [7]. While fault injec-
tion means actually to insert faults into physical systems,
fault simulation is concerned with modeling faulty behav-
ior in a mathematically model. Exhaustive fault simulation
means that all hypothesized fault modes are modeled and
all their possible scenarios are examined. In our case, this
means model checking our model of the startup algorithm
with the fault degree set to 6. A desirable goal is to be able
to check all properties for a reasonable-sized cluster (say 5
nodes) overnight (say 12 hours, or 43,200 seconds). In this
section we give formulas to estimate the number of scenar-
ios under test for exhaustive fault simulation and report the
performance achieved.
Different startup delays: Given a system of n nodes and 2
guardians, where each of the nodes and one of the guardians
was allowed to startup at an instant during a period of δinit ,
the number of scenarios, |Ssup|, based on these different
startup times is given by |Ssup| = (δinit )n+1 .
Worst-case startup scenarios with a faulty node: Given the
worst-case startup time of the system τ wcsup and the fault
degree of a faulty node δfault, the number of scenarios for
one particular startup pattern of nodes and hubs, |Sf .n.|, is
given by |Sf .n.| = ((δfault)2)τ wcsup . Numerical estimates
for these parameters are given in Figure 5 (δfault = 6).
nodes
#
3
4
5
δinit
(slots)
24
32
40
|Ssup|
3.3 ∗ 105
3.3 ∗ 107
4.1 ∗ 109
τ wcsup
(slots)
16
23
30
|Sf .n.|
8 ∗ 1024
6 ∗ 1035
4.9 ∗ 1046
Figure 5. Number of Scenarios for Different
Fault Degrees
The SAL symbolic model checker is able to count
the number of
reachable states in a model. For the
model used in the big-bang tests, these numbers were
1,084,122,880 states for 3 nodes, 508,573,786,112 for 4,
and 259,220,300,300,290 for 5; these are approximately
227, 235, and 243 states, respectively, in reasonable agree-
ment with Figure 5.
Figures 6(a), 6(b), and 6(c) present the model checker
performance for Lemmas 1, 2, and 3 in presence of a
faulty node with fault degree δfault = 6 and startup-delay
δinit = 8 ∗ τ round . The feedback column indicates whether
the feedback optimization was turned on or off. Figure 6(d)
presents the results for Lemma 4 in presence of a faulty hub
with startup-delay δinit = 8 ∗ τ round . Results are shown
for models with 3, 4, and 5 nodes. The eval column indi-
cates if the respective lemma is satisﬁed.
The cpu time column gives the execution time of the
corresponding model-checking run, while the BDD column
gives the number of BDD variables for the model (this is
equivalent to the number of state bits after eliminating those
that are simple combinations of others). 300 or so state bits
is usually considered the realm of “industrial” model check-
ing, where skilled tinkering may be needed to obtain a re-
sult in reasonable time. Yet all these results were obtained
with no special efforts beyond those described.
6. Conclusion
We have presented the veriﬁcation model and results of
a model-checking study for a new startup algorithm for the
TTA. The startup algorithm guarantees a safe and timely
system startup in the presence of one faulty component. Our
model-checking experiments showed the robustness of the
algorithm in the presence of a faulty node or a faulty hub.
We described modeling concepts for abstracting the
problem to discrete time, and for exhaustive fault simula-
tion. The resulting models have billions or even trillions of
reachable states, yet the symbolic model checker of SAL is
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 12:29:32 UTC from IEEE Xplore.  Restrictions apply. 
nodes
feedback
eval.
cpu time BDD
#
3
4
5
on
on
on
true
true
true
(sec)
62.45
259.53
920.74
#
248
316
422
(a) Results for Lemma safety
nodes
feedback
eval.
cpu time BDD
#
3
4
5
nodes
#
3
4
5
(sec)
228.03
1242.73
41264.08
(b) Results for Lemma liveness
true
true
true
on
on
on
#
250
318
424
feedback wcsup
(slots)
eval.
cpu time BDD
16
23
30
on
on
on
(c) Results for Lemma timeliness
true
true
true
(sec)
47.81
907.61
4480.90
#
268
336
442
nodes
eval.
cpu time BDD
#
3
4
5
(d) Results for Lemma safety 2
(sec)
56.65
82.95
4289.77
true
true
true
#
272
348
462
Figure 6. Performance Results for Model
Checking the Lemmas
able to examine these in a few tens of minutes (for billions
of states) or hours (for trillions). This combination of an ef-
fective modeling approach and an efﬁcient tool allowed us
to use model checking over an exhaustive fault model in the
design loop for the algorithm, and also helped us establish
the worst-case startup times. Thus, this approach extends
previous experiments in model-checking fault-tolerant al-
gorithms such as [14] and [4] by vastly increasing the num-
ber of scenarios considered, while achieving performance
that allows the method to be used in design exploration as
well as for veriﬁcation.
Ongoing design work is concerned with a shift of com-
plexity from the guardian algorithms to the node algorithms
to make the interlink connections unnecessary. In ongoing
formal methods studies, we are exploring the use of the
inﬁnite-bounded model checker of SAL (which combines
a SAT solver with decision procedures for theories includ-
ing real arithmetic) to develop and analyze models that use
continuous time [6], while still allowing rich fault models.
We are also using the PVS theorem prover to formally ver-
ify the algorithm and its fault hypothesis in their most gen-
eral forms.
References
[1] A. Ademaj, G. Bauer, H. Sivencrona, and J. Torin. Evalu-
ation of fault handling of the Time-Triggered Architecture
with bus and star topology. In Proc. of International Con-
ference on Dependable Systems and Networks (DSN 2003),
San Francisco, Jun. 2003.
[2] G. Bauer, H. Kopetz, and P. Puschner. Assumption Coverage
under Different Failure Modes in the Time-Triggered Archi-
tecture. In Proc. of International Conference on Emerging
Technologies and Factory Automation, pages 333–341, Oct.
2001.
[3] G. Bauer, H. Kopetz, and W. Steiner. The central guardian
approach to enforce fault isolation in a time-triggered sys-
tem.
In Proc. of 6th International Symposium on Au-
tonomous Decentralized Systems (ISADS 2003), pages 37 –
44, Pisa, Italy, Apr. 2003.
[4] C. Bernardeschi, A. Fantechi, and S. Gnesi. Model check-
ing fault tolerant systems. Software Testing, Veriﬁcation and
Reliability, 12:251–275, Dec. 2002.
[5] L. de Moura, S. Owre, H. Ruess, J. Rushby, N. Shankar,
M. Sorea, and A. Tiwari. SAL 2. To be presented at CAV
2004, July 2004. Available at http://www.csl.sri.
com/˜rushby/abstracts/sal-tool.
[6] B. Dutertre and M. Sorea. Timed systems in SAL. Techni-
cal report, Computer Science Laboratory, SRI International,
Menlo Park, CA, 2004. In preparation.
[7] J.C.Laprie. Dependability: Basic Concepts and Terminol-
ogy. Springer-Verlag, 1992.
[8] H. Kopetz. Fault containment and error detection in the
Time-Triggered Architecture.
In Proc. of The 6th Inter-
national Symposium on Autonomous Decentralized Systems
(ISADS 2003), pages 139–146, Pisa, Italy, Apr. 2003.
[9] H. L¨onn and P. Pettersson. Formal veriﬁcation of a TDMA
protocol start-up mechanism.
In Paciﬁc Rim Interna-
tional Symposium on Fault-Tolerant Systems, pages 235–
242, Taipei, Taiwan, Dec. 1997. IEEE Computer Society.
[10] H. Pfeifer, D. Schwier, and F. W. von Henke. Formal veriﬁca-
tion for time-triggered clock synchronization. In C. B. We-
instock and J. Rushby, editors, Dependable Computing for
Critical Applications—7, volume 12 of Dependable Com-
puting and Fault Tolerant Systems, pages 207–226, San Jose,
CA, Jan. 1999. IEEE Computer Society.
[11] W. Steiner and M. Paulitsch. The transition from asyn-
chronous to synchronous system operation: An approach for
distributed fault-tolerant systems. In The 22nd International
Conference on Distributed Computing Systems, pages 329–
336, Vienna, Austria, July 2002. IEEE Computer Society.
[12] W. Steiner, M. Paulitsch, and H. Kopetz. Multiple fail-
ure correction in the Time-Triggered Architecture. Proc. of
9th Workshop on Object-oriented Real-time Dependable Sys-
tems (WORDS 2003f), Oct. 2003.
[13] W. Steiner, J. Rushby, M. Sorea, and H. Pfeifer. SAL model
of a TTA startup algorithm. Research Report 52/2003, Tech-
nische Universit¨at Wien, Institut f¨ur Technische Informatik,
Treitlstr. 1-3/182-1, 1040 Vienna, Austria, 2003.
[14] T. Yokogawa, T. Tsuchiya, and T. Kikuno. Automatic veri-
ﬁcation of fault tolerance using model checking. In Proc. of
2001 Paciﬁc Rim International Symposium on Dependable
Computing, page 95, Seoul, Korea, Dec. 2001.
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 12:29:32 UTC from IEEE Xplore.  Restrictions apply.