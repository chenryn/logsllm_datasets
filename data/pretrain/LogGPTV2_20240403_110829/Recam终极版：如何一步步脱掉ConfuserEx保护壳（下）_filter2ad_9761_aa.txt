# Recam终极版：如何一步步脱掉ConfuserEx保护壳（下）
|
##### 译文声明
本文是翻译文章，文章原作者 Holger Unterbrink and Christopher
Marczewski，文章来源：talosintelligence.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
## 传送门
[Recam终极版：如何一步步脱掉ConfuserEx保护壳（上）](https://www.anquanke.com/post/id/89730)
> 在本文中，我们介绍了如何解密经过.NET ConfuserEx保护的恶意软件。我们通过Advanced Malware Protection
> （AMP，高级恶意软件防护）感知数据发现了处于活跃期的这款恶意软件。恶意软件借助恶意Word文档来传播，最终会在内存中执行来自Recam恶意软件家族的一个嵌入式载荷（Recam是一款信息窃取恶意软件）。虽然这款恶意软件已活跃数年之久，但出于各种原因，有关该软件内部工作机理的分析文章少之又少。因为恶意软件作者花了许多精力来延缓安全人员对样本的分析研究，使用了包括多层数据加密、字符串混淆、分段置零以及数据缓冲区构造器等技术。这款恶意软件使用了自定义的C2二进制协议，协议本身及相关数据（传输之前）都经过严格加密处理。
## 技术细节
在本篇文章的下部分，将着重介绍恶意载荷部分。
### 恶意载荷
前面提到过，恶意软件作者花了许多精力来阻拦安全人员对样本的分析，使用了多层混淆技术，包括多层数据加密、字符串混淆、分段置零以及数据缓冲区构造器等技术，也使用了自定义的C2二进制通信协议。所有相关数据在传输前都经过严格加密处理。
释放出的程序经过vanilla UPX加壳处理过。这部分很容易解开，棘手的是下一阶段。当原始的OEP（Original Entry
Point）恢复后，程序开始使用一些自制的加密初始化过程来处理某些值，整个运行周期中会经常用到这些值。初始化过程结束后，这些值中大多数保持不变，但有些会随着时间发生改变。随后不久程序会初步解开某些混淆字符串，其中包括一个硬编码在程序中的命令控制（C2）服务器IP地址。
    call Recam_string_decode2
    mov [esp+12Ch+var_12C], ebx
    mov [esp+12Ch+len], 0FFh
    mov [esp+12Ch+ciphertext], offset decode2_var_len255
    call Recam_string_decode2
    mov [esp+12Ch+var_12C], ebx
    mov [esp+12Ch+len], 20h
    mov [esp+12Ch+ciphertext], offset aPassword ; "Password"
    call Recam_string_decode2
    mov [esp+12Ch+var_12C], ebx
    mov [esp+12Ch+len], 10h
    mov [esp+12Ch+ciphertext], offset HostID_plus_rand ; "HostId-%Rand%Â°Ã¥"
    call Recam_string_decode2
    mov [esp+12Ch+var_12C], ebx
    mov [esp+12Ch+len], 8
    mov [esp+12Ch+ciphertext], offset mutex_name
这个去混淆函数比较少用，主要是通过单字节XOR（异或）循环完成解码任务。另一个解码函数较为常用，该函数使用JIT（Just-In-Time）技术，依赖于硬编码的一个解码密钥。幸运的是，IDA Pro的Appcall功能可以简化这些解码过程。
图18
这些前导函数结束后，我们会到达条件分支语句。尽管经过大量不必要的代码及计算过程，程序总是会跳转到40849B位置，程序中与文件修改及进程创建的代码仅仅是一些诱饵，实际执行过程中会跳过这些代码。
    lea ebx, [esp+83Ch+var_618]
    mov [esp+83Ch+lpValueName], 204h
    mov [esp+83Ch+uExitCode], offset decode2_unk_len128
    mov [esp+83Ch+Mode], ebx
    call Recam_getenv
    mov [esp+83Ch+uExitCode], 1
    call Recam_arg0_AND_constant
    test al, al
    jz loc_40849B ; jmp taken (skip mangling & proc creation)
    Recam_arg0_AND_constant proc near
    var_1C= dword ptr -1Ch
    arg_0= dword ptr 4
    sub esp, 1Ch
    mov [esp+1Ch+var_1C], offset flow_constant3
    call Recam_base10_to_base16
    and eax, [esp+1Ch+arg_0]
    cmp eax, [esp+1Ch+arg_0]
    setz al
    add esp, 1Ch
    retn
继续分析，恶意软件会在注册表中设置一个Run表项，达到系统驻留目的。在函数末尾附近，程序会创建一个额外的线程，启动键盘记录器（keylogger）组件，所记录的数据存放在`%APPDATA%Logs`目录中，文件名使用`--`格式。记录数据以括号作为分隔符，最终数据在将写入磁盘文件之前，程序会先对这些数据做加密处理。
接下来，恶意软件会创建名为`.Identifier`的一个ID文件。如果样本当前目录中已存在这个文件（通过GetModuleFilename这个API获取当前目录），则会直接读取这个文件，不会再次创建。
图19
数据会逐个生成并写入该文件中，格式如下所示：
1、（4字节）静态ID值
2、（13字节）HostId（包含数字字母的6个随机字符，以系统时间为种子）
3、（19字节）19个空（null）字节
4、（19字节）系统时间或者本地时间
5、（13字节）13个空字节
图20
由于用到了一个静态ID，因此文件的前4个字节始终保持一样（但用来加密C2数据的加密方法比这复杂得多）。
图21
图22a
图22b
与`.Identifier`文件一样，初始的C2信令数据长度始终为68个字节。每一个C2消息（客户端及服务端）均使用如下方式：
1、（4字节）数据长度
2、（1字节）C2命令
3、（n字节）与命令对应的具体数据
对于许多恶意软件家族而言，在解密它们所使用的C2信令数据时，解开所使用的指令往往是非常简单的工作。这款工具的开发者选择使用自定义的加密方案，使得每次运行时生成的都是随机化的信令数据（只有长度值及C2命令保持不变），增大加密协议实现方式的复杂度及碎片化程度。
图23
图24
图25
发送信令后，样本会等待服务器的响应数据。我们所分析的C2服务器目前处于离线状态，会重置（reset）连接请求，但我们在沙盒环境中捕捉到了前期的pcap包，从这些包中我们可以猜测出剩余通信数据包的内容。如下所示，这个pcap包中包含信令数据、初始响应数据、一次客户端传输数据以及一系列“保活（keep
alive）”消息（单字节命令）。
图26
此时，代码执行流程取决于某个流状态标签，整个程序中这个标签的值设置了若干次（初始设置为0xFFFFFFFF）。就响应数据长度及C2命令而言，这个标签进一步规定了这些数据中每个属性的具体值。比如，负责检查响应数据长度的函数也会检查流状态标签。如果状态发生改变，函数会检查消息长度是否超过0x30000。如果标签处于默认状态，函数会检查长度值是否为0x41（信令消息及预期响应的长度）。对于命令数据而言，默认状态会检查通信中的信令阶段是否设置了命令字节（0x85）。一旦发生改变，函数会检查命令字节是否小于或等于0xD2。
图27
图28
响应数据及后续数据（如果存在的话）会被送到一个大型跳转表中，跳转表用来检查命令字节，根据服务器发送的指令进一步执行后续动作。
图29
前面提到的那个函数及这个跳转表会再次检查流状态，查看相关参数现在是否等于先前设置的状态值（除0xFFFFFFFF以外）。如果满足这种情况，程序会解密服务器返回的上一个响应数据，解密函数与样本之前加密传输数据所使用的函数为同一个函数。如果处于默认状态，命令字节会传递给LEA（Load
Effective Address，加载有效地址）指令（对应下图中的lea eax, [esi+7Fh]）。这种情况下，由于指令引用了零扩展（zero-extended）的命令字节，因此这里不会使用计算地址，相反，程序会将0x7F加入命令字节中。EAX中存放的是DWORD值，AL存放的是单字节值，程序会将AL存放的值与0x51进行比较，如果两个值相等，则函数处理完毕，不会有其他操作。如果两个值不相等，AL中存放的值会被零扩展到EAX中，乘以4然后传递给跳转表，以确定服务器指定的下一个操作。
图30
从跳转表中可知，服务器可以返回82种命令。然而，这些命令有所重复。比如，下图中高亮标出了一些偏移地址，当没有执行任何操作时，许多跳转地址最终会跳转到同一个地址（RVA
0x227C）。
图31
受时间所限，实际环境中我们无法深入检查每一条跳转路径，但根据沙盒收集到的pcap包，结合我们对命令协议额的理解，我们可以分析服务器发送的命令，自己计算跳转情况。例如，这个Recam变种所具备的部分功能如下所示（前半部分为命令字节）：
0x85（case 4）：处理服务器返回的初始确认消息，设置流状态。
0x81（case 0）：保活消息。
0xBD（case 12）：下载文件至`%TEMP%`目录，或者下载文件至`%TEMP%`目录并创建新线程。
0x87（case 6）：根据参数创建新进程。