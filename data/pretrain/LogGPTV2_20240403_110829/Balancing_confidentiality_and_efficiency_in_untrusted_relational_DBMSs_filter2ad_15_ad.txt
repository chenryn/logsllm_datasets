create confusion with the indexes introduced in Section 2.
0
Elvis
1
Chris
2
Gary
3
Bob
4
Donna
5
Frank
6
Henry
Ian
7
Alice
8
Bob
9
Chris
10
Donna
11
Elvis
12
Frank
13
Gary
14
Henry
15
Ian
John
B+-tree Table
ID
Node
Encrypted B+-tree Table
ID
C
(a)
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(1,Elvis,2, , )
(3,Chris,4, , )
(5,Gary,6, , )
(7,Bob,8, , )
(9,Donna,10, , )
(11,Frank,12, , )
(13,Henry,14, , )
(Alice, ,8)
(Bob, ,9)
(Chris, ,10)
(Donna, ,11)
(Elvis, ,12)
(Frank, ,13)
(Gary, ,14)
(Henry, ,15)
(Ian,John, )
SeCS0U/7ZIY.A
/WKu5y8laqK82
jzKzVi0D1as8E
AXYaqohgyVObU
IUf7R.PK5h5fU
rzaslxohWS2l2
EXITGCUlYTVBc
uOtdm/HDXNSqU
GLDWRnBGIvYBA
a9yl36PA3LeLk
H6GwdJpXiU8MY
uOtdm/HDXNSqU
zj33kVaNvLFVk
V9rMw904cix3w
xTFcWtd6.IE.A
ji.gtDER6Hjis
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(b)
Figure 5: An example of B+-tree on attribute Customer (a) and corresponding tabular and encrypted repre-
sentation (b)
The advantage of this solution is that the content of the
B+-tree nodes is not visible to the untrusted DBMS. The
drawback, however, is that the B+-tree traversal can now
only be performed by the trusted front end. Intuitively, to
execute an interval query, the front end has to perform a
sequence of queries that retrieve tree nodes at progressively
deeper levels; when the leaf is reached, the node IDs in the
leaf can be used to retrieve the tuples belonging to the in-
terval. For instance, if it is necessary to retrieve all the
customers whose name starts with a letter in the interval D-
F using the B+-tree, the front end will produce a sequence
of queries that will access in sequence nodes 0, 1, 4, and 10;
then, other queries will be used to scan the leaves, accessing
nodes 10, 11, and 12. In the Appendix we present a simple
cost model that permits to identify the optimal size for the
tree node.
5. RELATED WORK
Database encryption has been proposed since long as a
fundamental tool for providing strong security for “data at
rest”. Thanks to recent advances in processors’ capabili-
ties and to the development of fast encryption techniques,
the notion of encrypted database is nowadays well recog-
nized, and several commercial products reached the mar-
ket. However, developing a sound security strategy includ-
ing database encryption still involves many open issues. Key
management and security are of paramount importance in
any encryption-based system and were therefore among the
ﬁrst issues to be investigated in the framework of database
encryption [5]. Later, techniques have been developed aimed
at eﬃciently querying encrypted databases [14], some of
them related to parallel eﬀorts by the text retrieval com-
munity [11] for executing hidden queries, that is, queries
where only the ciphertext of the query arguments is made
available to the DBMS. On the other hand, architectural
research investigated optimal sharing of the encryption bur-
den between secure storage, communication channels and
the application where the data originates [10], looking for a
convenient trade-oﬀ between data security and application
performance. Recently, much interest was devoted to secure
handling of database encryption in distributed, Web based
execution scenarios, where data management is outsourced
to external services [1]. The main purpose of this line of
research is ﬁnding techniques for delegating data storage
and the execution of queries to untrusted servers while pre-
serving eﬃciency. The index of range technique proposed
in [8] in the framework of a database-service-provider archi-
tecture relies on partitioning client tables’ attributes’ do-
mains into sets of intervals. The value of each remote table
attribute is stored as the index countersigning the interval to
which the corresponding plain value belongs. Indexes may
be ordered or not, and the intervals may be chosen so that
they have all the same length, or are associated with the
same number of tuples. This representation supports eﬃ-
cient evaluation on the remote server of both equality and
range predicates; however, it makes it awkward to manage
the correspondence between intervals and the actual values
present in the database. A distinct, though related solu-
tion is proposed in [1], where smart cards are used for key
management.
On a diﬀerent line of related work, we note that the pro-
tection/exposure given by hashing can resemble the general-
ization approach for microdata protection; and correspond-
ingly inference attacks exploiting it can resemble record link-
age techniques examined in that context [13]. However,
the two problems are quite diﬀerent as while generalization
maintains information on plaintext values (simply collapsing
more values in a given interval), hashing is not associated
with any semantics.
Also, it is important to note that the problem we consider
diﬀers from existing approaches protecting encrypted data,
which investigated solutions as for the private information
retrieval problem (protecting the query, that is, the infor-
mation on what the user is looking for) or the problem of
limiting the amount of data that users can acquire.
6. CONCLUSIONS
In this paper, we proposed a solution to the problem of
database outsourcing on untrusted servers by providing a
hash-based method for database encryption suitable for se-
lection queries. Also, we gave a quantitative evaluation of
our method’s vulnerability, showing that even straightfor-
ward direct encryption can provide an adequate level of se-
curity against inference attacks, as long as a limited number
of index attributes is used.
In order to execute interval-
based queries, we adapted to the database-service-provider
model the B+-tree structures typically used inside DBMSs.
7. ACKNOWLEDGMENTS
The work reported in this paper was partially supported
by the Italian MURST within the KIWI and MAPS projects.
8. REFERENCES
[1] L. Bouganim and P. Pucheral. Chip-secured data
access: Conﬁdential data on untrusted servers. In
Proc. of the 28th International Conference on Very
Large Data Bases, pages 131–142, Hong Kong, China,
August 2002.
[2] S. Ceri, M. Negri, and G. Pelagatti. Horizontal data
partitioning in database systems. In Proc. of the ACM
SIGMOD International Conference on Management of
Data, Orlando, Florida, 1982.
[3] H. Chao, T.Y. Wu, and J. Chen. Security-enhanced
packet video with dynamic multicast throughput
adjustment. International Journal of Network
Management, 11(3):147–159, 2001.
[4] T.H. Cormen, C.E. Leiserson, and R.L. Rivest.
Introduction to Algorithms. McGraw-Hill, New York,
1990.
[5] G.I. Davida, D.L. Wells, and J.B. Kam. A database
encryption system with subkeys. ACM Transactions
on Database Systems, 6(2):312–328, June 1981.
[6] D.E. Denning. Cryptography and Data Security.
Addison-Wesley, 1982.
[7] S. Ghandeharizadeh and D. DeWitt. A multiuser
performance analysis of alternative declustering
strategies. In Proc. of the 6th Int. Conf. on Data
Engineering, 1990.
[8] H. Hacig¨um¨us, B. Iyer, C. Li, and S. Mehrotra.
Executing SQL over encrypted data in the
database-service-provider model. In Proc. of the ACM
SIGMOD’2002, Madison, Wisconsin, USA, June 2002.
[9] H. Hacig¨um¨us, B. Iyer, and S. Mehrotra. Providing
database as a service. In Proc. of the 18th
International Conference on Data Engineering, San
Jose, California, USA, February 2002.
[10] C.D. Jensen. Cryptocache: a secure sharable ﬁle cache
for roaming users. In Proc. of the 9th Workshop on
ACM SIGOPS European workshop: beyond the PC:
new challenges for the operating system, pages 73–78,
Kolding, Denmark, September 2000.
[11] S.T. Klein, A. Bookstein, and S. Deerwester. Storing
Text retrieval systems on CD-ROM: compression and
encryption considerations. ACM Transactions on
Information Systems, 7(3):230–245, July 1989.
[12] B.D. McKay. Practical graph isomorphism.
Congressus Numerantium, 30:45–87, 1981.
[13] P. Samarati. Protecting respondent’s privacy in
microdata release. IEEE Transactions on Knowledge
and Data Engineering, 13(6):1010–1017,
November/December 2001.
[14] D.X. Song, D. Wagner, and A. Perrig. Practical
techniques for searches on encrypted data. In Proc. of
the 2000 IEEE Symposium on Security and Privacy,
pages 44–55, Oakland, CA, USA, May 2000.
[15] J.P. Walton. Developing an enterprise information
security policy. In Proc. of the 30th annual ACM
SIGUCCS Conference on User Services, Providence,
Rhode Island, USA, 2002.
[16] J. Ward, M. O’Sullivan, T. Shahoumian, and
J. Wilkes. Appia: Automatic storage area network
fabric design. In Proc. of the Conference on File and
Storage Technologies (FAST 2002), Monterey, CA,
January 2002.
[17] E.Y. Yang, J. Xu, and K.H. Bennett. Private
information retrieval in the presence of malicious
failures. In Proc. of the 26th Annual International
Computer Software and Applications Conference,
Oxford, England, August 2002.
APPENDIX
A. B+-TREE NODE SIZE CONFIGURATION
A critical aspect in the design of the B+-tree is the size
of the node. When B+-trees are used to build indexes in a
DBMS, the size of the I/O block typically deﬁnes the size
of the node, as the goal is to minimize the number of I/O
requests. For the B+-trees for this environment we have
greater ﬂexibility and indeed the size of the node becomes
an important conﬁguration parameter.
We build a simpliﬁed cost model that can be used to tune
the node size for a speciﬁc environment. The parameters of
the model are:
• Setup cost of a query that retrieves a single node given
its ID, KQ: there is a cost for every query execution,
due to the fact that the query has to be transferred from
the client to the server, the server has to understand it
and execute it. Since we are interested in the modeling
of accesses to the nodes of an encrypted B+-tree, we
assume that the cost is the same for all queries.
• Size of the node, sn: the size of the node depends on
the number f of key values appearing in the node and
on the size of keys sk and on the size of pointers sp.
• Cost Ct for the transmission and processing of a bit (we
assume the cost to be constant; this is a good approx-
imation for transmission costs and reasonable for the
processing costs associated with the retrieval of data
on the server and parsing on the client).
• The number N of tuples in R.
The above terms can be used to build a formula that es-
timates the cost to access one node:
KQ + Ct × (f × sk + (f + 1) × sp)
When the tree is used to search a value k among N ,
logf (N ) tree nodes will be accessed; the following formula
estimates the cost required to access a tree leaf:
C = logf (N ) × (KQ + Ct × (f × sk + (f + 1) × sp))
The optimal value for f will be one that minimizes the
above cost function. The application of analytical meth-
ods to the function (variable f is replaced by the canonical
analytical variable x) shows that the function can be also
represented by the simpler structure:
C =
α + βx
log x
Parameters α and β are both positive. The function is
continuous and, considering for x the interval 1 − ∞, it
diverges at x = 1 and it also diverges as x → ∞. The
identiﬁcation of the minimum can be based on an analyt-
ical study of the function.
In particular, we compute the
function derivative, obtaining:
(cid:1)
C
=
βx(log x − 1) − α
x log2 x
(cid:1)
Function C
presents a single zero in the interval (1−∞),
that corresponds to the minimum in the cost function C.
To identify the optimal x value in the domain of integers,
it is suﬃcient to compare the two values for C that derive
assigning to f the two integers obtained by rounding with
ﬂoor and ceiling the minimum obtained by the numerical
resolution. For instance, with 1,000,000 tuples, 0,01s query
setup cost, 4 ∗ 10
−7 s/bit transmission cost, 30 bytes for a
key and 2 bytes for a pointer, we obtain the optimum at
f = 38.