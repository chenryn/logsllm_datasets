the rest of this section.
382    27th USENIX Security Symposium
USENIX Association
3.2 Concrete Exploit Generation
To generate the concrete exploits, NAVEX executes
several steps as depicted in Figure 3. First, a dynamic ex-
ecution step creates a navigation graph that captures the
possible sequences in which application modules can be
executed. Next, the navigation graph is used to discover
execution paths to only those modules that contain the
vulnerable sinks uncovered by the vulnerable sink iden-
tiﬁcation step. Finally, the ﬁnal exploits are generated.
We describe each of these steps next.
3.2.1 Dynamic Execution
This step is responsible for building an application-wide
navigation graph, which represents possible sequences of
module executions together with associated constraints.
Previous research [7] has recognized the importance
of building such a graph. However, a key difference with
that work is the approach in which the graph is gener-
ated. In particular, the approach of [7] uses static analy-
sis to discover links and forms and does not deal with the
dynamic features of web applications, whose semantics
are challenging to be captured statically.
In contrast, NAVEX uses a dynamic execution ap-
proach. It executes the web application through a crawler
so that a signiﬁcant portion of those dynamic features be-
come concrete and do not need to be symbolically eval-
uated. However, a common challenge when performing
the dynamic analysis is maximizing the coverage of the
application. To address this challenge, NAVEX uses con-
straint solving and concolic execution to generate a large
number of form inputs that aid the crawler in maximizing
the coverage of the application.
Crawler. The crawler is responsible for uncovering the
navigation structure of the applications. For each ap-
plication, the crawler is initiated with a seed URL and
whenever necessary, valid login credentials. While most
applications have two types of roles (administrator and
regular user), to maximize the crawling coverage, the
crawler does the authentication for each role-type in the
application. Starting from the seed URL, the crawler
extracts HTML links, forms, and JavaScript code. The
links are stored and used as the next URLs to crawl. For
form submissions, the crawler needs to construct values
that comply with the form restrictions (e.g., length of in-
put) and satisfy eventual JavaScript validations. Having
a mechanism that automatically generates valid form in-
puts greatly improves the crawling coverage of web ap-
plications since web forms are common constructs that
inﬂuence the navigation structure.
To address this problem, our crawler extracts the
forms’ input ﬁelds, buttons, and action and method at-
tributes (i.e., GET or POST) using an HTML parser and
generates a set of constraints over the form values im-
plied by the form attributes.
In addition, to deal with
JavaScript code that validates form inputs, the crawler
leverages the techniques used in [12]. Speciﬁcally, the
JavaScript code is extracted and analyzed using concrete-
symbolic execution. The code is ﬁrst executed concretely
and when the execution reaches a conditional statement
that has symbolic variables, the execution forks. Then,
the execution resumes concretely. After the execution
stops for all the forks, a set of constraints that repre-
sent each execution path that returns true is generated.
NAVEX combines the form HTML constraints Fhtml and
the JavaScript constraints Fjs to produce the ﬁnal form
constraints Ff orm. As an example, the constraints for the
form in our running example (Listing 1) are:
Fhtml :
book name=="Intro to Math by author2")
Fjs:
edition > 0
Ff orm: Fhtml ∧ Fjs
(book name=="Intro to CS by author1" ∨
Finally,
to
the
and action ﬁelds
the formula f f orm is sent
form method,
new HTTP request
to the solver
NAVEX uses the solver so-
to is-
application
http:.../selectBooks.php?action=borrow
to ﬁnd a solution.
lution,
sue
a
(i.e.,
POST[book name=Intro to CS by author1,
edition=2]).
Addressing Server-side Constraints. Server-side code
often introduces additional constraints on the values of
the input variables, which can inﬂuence the navigation
structure of an application. Most commonly, these in-
clude constraints over the values submitted via forms.
For instance, in Listing 1, the server-side code intro-
duces an additional check over the string length of
$publisher, which is not present in the JavaScript val-
idation.
Typically, when the server constraints are satisﬁed, the
execution proceeds and the state of the application is
changed, while in the opposite case, the application re-
jects the form inputs and the state of the application does
not change. Therefore, to maximize the coverage of the
application, the crawler must be able to generate form
inputs that are accepted by the application.
While automatically generating form inputs that are
rejected is easier, generating inputs that are accepted is
more challenging. To deal with this challenge, we uti-
lize an execution-tracing engine on the server-side code.
NAVEX uses the produced trace information to determine
whether a request is successful by checking if the appli-
cation is (i) changing its state (i.e., creating a new ses-
sion, setting a new variable and superglobal values, etc.)
and (ii) performing sensitive operations such as querying
the database.
When a request is not successful, NAVEX utilizes the
trace information to perform a concolic execution.
In
particular, it ﬁrst retrieves the executed statements in-
cluding the conditional statements. Then, the collected
USENIX Association
27th USENIX Security Symposium    383
Figure 3: Concrete Exploit Generation (Step II) Components.
conditional statements are transformed automatically to
solver speciﬁcations and negated to uncover new execu-
tion paths. The newly created speciﬁcations are then sent
to the solver to generate new form inputs. This process is
continuously repeated until the form submission is suc-
cessful. As an example, the above inference constructs
the following constraints that yield to a successful form
submission
(book name=="intro to CS by author1" ∨
book name=="intro to Math by author2") ∧
length(publisher)0
Finally, for each accepted form, NAVEX stores the full
HTTP request that led to the successful submission.
3.2.2 Navigation Graph
The Navigation Graph produced by the dynamic exe-
cution step represents the applications’ navigation be-
It is a directed graph G = (N,E) where each
havior.
node n ∈ N represents an HTTP request and each edge
e = (ni,n j) ∈ E represents a navigation from ni to n j,
which can be of type link or form. In particular, for ev-
ery edge e = (ni,n j) ∈ E ni represents the page from
which the request was originated. Each node in the
graph has the following properties id, URL, role, and
form params for nodes representing an HTTP request
generated by a form submission. The id property stores
a unique identiﬁer of the node, the URL property is the
URL in the HTTP request, which is composed of the
module name and HTTP parameters of the request, and
the role property holds the login credentials used as in-
put to the crawler as illustrated in Figure 4. It is impor-
tant to note that the navigation graph can contain multiple
nodes associated with the same PHP module. In partic-
ular, if a PHP module can accept different combinations
of input variables, each such combination is represented
by a corresponding node in the NG.
A partial instance of an NG, related to our running ex-
ample is shown in Figure 4. As an example, one possi-
ble form submission, with form input values generated
by the solver, is represented by the edge between nodes
2 and 3, while the other edges represent link naviga-
tion. Note that hold.php is associated with two different
nodes (id-s 5 and 6), each having a different combination
of input variables (i.e., HTTP parameters). This repre-
sentation will be crucial in the next step when exploring
paths to the exploitable modules.
3.2.3 Final Exploit Generation
To generate the ﬁnal concrete exploits, NAVEX utilizes
the NG along with the vulnerable sinks identiﬁed by the
techniques introduced in Section 3.1. One challenge that
NAVEX must solve in this step is that of combining the
results produced by the step of vulnerable sink identiﬁca-
tion with the Navigation Graph. In particular, when mod-
ules containing vulnerable sinks are included by other
modules using PHP inclusion, the former does not ap-
pear in the NG, because there is no explicit navigation to
them. For instance, the module checkout.php does not
appear in the NG in Figure 4. To execute these vulner-
able modules, the execution must invoke the including
modules.
To address this issue, NAVEX executes a preprocess-
ing inclusion resolution step, which creates an inclusion
map that stores the ﬁle inclusion relationships. The map
is constructed by performing a traversal that searches the
enhanced CPG for nodes that represent calls to ﬁle inclu-
sion PHP functions (e.g., require, include, etc).
Once the inclusion resolution step is completed,
NAVEX uses the NG and the produced inclusion map to
search paths on the NG from public modules to the ex-
ploitable modules (or their including parents). It is im-
portant to note that the previous identiﬁcation of vulner-
able sinks that ‘may’ be exploitable greatly reduces the
cost of such search and increases the likelihood of ﬁnd-
ing executable exploits.
The search method is summarized in Algorithm
2. The ﬁrst input to the search is the set of pairs
{(module,exploit)} from Step I of NAVEX. Module rep-
resents the vulnerable module, and exploit represents the
assignments of malicious values to inputs generated by
the solver. The next input is the InclusionMap and
the SeedURLs, which represent the publicly accessible
modules. For each vulnerable module, using the inclu-
sion map and the parameters in the exploit, the algo-
rithm ﬁrst ﬁnds possible destination nodes, which will
be the targets of the graph search (line 5). These nodes
(DestURLs) represent either the vulnerable module or its
parents (if a parent PHP module includes the vulnerable
module). GetDestURLs returns only those nodes of the
NG, whose parameter names match the parameter names
appearing in the corresponding exploit. The func-
tion ExpSearch ﬁrst identiﬁes the nodes whose URL
matches one of the SeedURLs (i.e., matches the URL
384    27th USENIX Security Symposium
USENIX Association
CrawlerSolverNavigation GraphFinal Exploit GeneratorConstraintsDynamic AnalysisExploitsInputs[Vulnerable Sinks, Exploit Strings]ApplicationFigure 4: The navigation graph (NG) of our running example.
Algorithm 2 Generating Concrete Exploits
1: Input:
{(module,exploit)},InclusionMap,SeedURLs
ModulesAndExploits
2. http://localhost/App/selectBooks.php with
=
POST params:[book name=intro to CS by
author1, edition=2,publisher=aaaaaaa]
3. http://localhost/App/selectBooks.php?action
DestURLs = GETDESTURLS(vm,InclusionMap)
Exploit = EXPSEARCH(SeedURLs,DestURLs,vm)
AllExploits ← Exploit
2: output: Concrete exploits for VulnModule
3:
4: for all vm ∈ ModulesAndExploits do
5:
6:
7:
8: return AllExploits
9:
10: function EXPSEARCH(SeedURLs, DestURLs, vm)
11:
12:
13:
14:
15:
16:
17:
SrcNodes = FINDSRCNODES(SeedURLs)
for all sn ∈ SrcNodes do
paths = GETPATHSTO(sn,DestURLs)
for all path ∈ paths do
exploit = REPLACEVULNPARAMS(path,vm)
ConcreteExploits ← exploit
return ConcreteExploits
as
to
to
yields
Applying
algorithm
property) (line 11). The traversal then explores the NG
for each of the retrieved SrcNodes to ﬁnd paths between
the source node and the DestURLs (line 13). Finally, for
each found path, it replaces the values of the HTTP pa-
rameters in the last edge with the malicious values gen-
erated by the solver.
the
example,
run-
our
considering
ning
a
http://localhost/App/selectBooks.php
SeedURL, and the node with id 6 in Figure 4 as
DestURL, because that node matches the vulnerable
module, whose corresponding (XSS) exploit contains an
assignment of a malicious value to the HTTP variable
msg. Since the exploit string for msg is  (generated by the solver
and stored in exploit), GetPathsTo explores the
following navigation paths between the SeedURL and
DestURL: (1) nodes of [id=2, id=3, id=4, id=5] and (2)
nodes of [id=2, id=3, id=4, id=5, id=6]. However, it
returns only the ﬁrst navigation path because the URL
of node 5 does not contain the HTTP parameter msg.
Finally, ReplaceVulnParams function replaces the
value of the msg with the malicious value of the exploit.
As a result, NAVEX generates the following set of HTTP
requests as a concrete exploit for the vulnerable sink
(line 15) at Listing 3:
1. http://localhost/App/index.php
=borrow
4. http://localhost/App/hold.php
5. http://localhost/App/hold.php?step=checkout
6. http://localhost/App/hold.php?step=checkout
&msg=
Implementation
As can be noted, as a result of our dynamic execution
and of the navigation graph design where nodes repre-
sent HTTP requests, the challenging problem of ﬁnding
sequences of HTTP requests that execute an exploit is
transformed into a simple graph search problem, which
is efﬁcient.
4
The implementation of NAVEX is based on several exist-
ing tools, most of which were extended to deal with our
problem. For Step I of our approach, the PHP extension
[9] of code property graphs [33] was enhanced with addi-
tional tags to enable precise taint tracking and database
constraints reasoning. The enhanced CPG is then im-
ported to the Neo4j [4] graph database, an open source
graph platform to create and query graph databases. The
graph traversals, such as algorithm 1, are written in
Gremlin [1]. Neo4j and Gremlin are also used in Step
II to build and search the navigation graph.
For constraints solving, we leveraged Z3 solver [17]
and its extension Z3-str [35]. In particular, when graph
traversals report a vulnerable path to a sink, NAVEX an-
alyzes the returned path and its nodes. Based on each
node type, a Three-Address Code (TAC) formula that
represents the node is created automatically. The TAC
Formula consists of right operand (rightOp), operator,
and left operand (leftOp), node type, and unique node
id. Then, NAVEX starts analyzing each TAC formula ac-
cording to its type. Based of the operator, leftOp, and
rightOp, NAVEX generates: (1) appropriate Z3 variable
declarations, (2) a set of assertions that replicate the se-
mantics of the PHP operator in Z3 speciﬁcation, and (3)
an assertion that assigns appropriate attack strings from
our attack dictionary to each sink variable in the formula.
NAVEX supports assignment, unary, binary, conditional,
built-in function, and cast statement types. The TAC for-
mula analysis and Z3 translation engine code are approx-
USENIX Association
27th USENIX Security Symposium    385
url:http://localhost/App/select Books.phpid: 2form_params:[book_name= intro to CS by author1, edition=2,publisher=aaaaaaarole: [user, user]formurl:http://localhost/App/ selectBooks.php?action =borrowid: 3role: [user, user]linkurl:http://localhost/App/ hold.phpid: 4role: [user, user]url:http://localhost/App/ hold.php?step= checkoutid: 5role: [user, user]linkurl:http://localhost/App/ hold.php?step =checkout&msg=doneid: 6role: [user, user]linkID: 2URL:http://localhost/App/select Books.phpForm_Params: [book_name= intro to CS by author1, edition=2,publisher=aaaaaaa]Role: [uName, uPass]ID: 3URL:http://localhost/App/ selectBooks.php?action =borrowRole: [uName, uPass]FORMID: 4URL:http://localhost/ App/hold.phpRole: [uName, uPass]LINKID: 5URL:http://localhost/ App/hold.php?step= checkoutRole: [uName, uPass]LINKID: 6URL:http://localhost/App /hold.php?step =checkout&msg=doneRole: [uName, uPass]LINKimately 3600 Java LOC.
For Step II, we extended crawler4j [2] by adding sup-
port for collecting forms and JavaScript code, extract-
ing constraints from the forms, and generating Z3 asser-
tions. To deal with JavaScript, we used an extension of
the Narcissus JavaScript engine [3], which adds the abil-
ity to evaluate JavaScript code symbolically. Then, con-
straints extracted from JavaScript related to form inputs
are transformed and combined with the form constraints