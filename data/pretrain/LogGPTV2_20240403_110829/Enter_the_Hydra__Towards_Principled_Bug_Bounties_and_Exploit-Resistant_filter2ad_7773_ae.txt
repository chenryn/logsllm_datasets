such opcodes would require the library code to be in-
strumented itself, which is possible in principle. We note
however that code delegation is typically at odds with the
multiversion programming philosophy: if all heads call
the same library contract, a library bug could yield an
exploit. We leave Hydra-based libraries to future work.
USENIX Association
27th USENIX Security Symposium    1345
7 Evaluation
This paper’s goal is not to rigorously measure corre-
lations between smart contract faults, but to propose a
novel principled bug bounty framework built upon an
assumed exploit gap. We leave a thorough analysis of
smart contract failure patterns to future work. We evalu-
ate our framework under standard software metrics: TCB
size, soundness, applicability and performance. We con-
clude with a discussion of our development process.
Workloads. To test soundness, applicability and per-
formance of Hydra contracts, we use three workloads:
(1) The ofﬁcial suite of test contracts for the EVM1; (2)
All contracts used in Ethereum between Dec. 7 2017 and
Feb. 7 2018; and (3) two representative smart-contract
applications developed by the authors. Implementations
of Submarine Commitments in Ethereum, and a thor-
ough analysis of the resulting anonymity sets for bounty
claiming transactions are in Appendix B.
We developed a generic ERC20 contract [55] for to-
ken transfers, and a Monty Hall Lottery, wherein two
participants play a multi-round betting game [56].
In
both cases, three authors independently developed one
head in each of Solidity, Serpent, and Vyper, the main
programming languages in Ethereum. These languages
have different design tradeoffs (in terms of ease-of-use,
low-level features or security) and are by themselves a
valuable source of diversity between our Hydra heads.
• The Hydra ERC20 token: The ERC20 token-transfer
API has been thoroughly peer reviewed [55], and is
supported by most of the highest-dollar contracts in
Ethereum (as of February 2018, the combined market
cap of the top ten Ethereum tokens is over 20 billion
USD [1]). Notably, the exploit in the DAO [15] was
partially present in the code managing tokens.
Our three-headed Hydra token is deployed on the
main Ethereum network and can be used as a drop-
in replacement for any ERC20 token, e.g.,
in the
DAO [15] and ether.camp [40] contracts. When a user
submits a token order, the MC delegates to all heads
and validates the order upon agreement. Our initial
bounty is 3000 USD, which we will increase as the
contract undergoes further audit, review, and testing.
• A Hydra Monty-Hall lottery: In this game, one party,
the house, ﬁrst hides a reward behind one of n doors.
The player bets on the winning door, and the house
opens k other non-winning doors. The player may then
change his guess. If he guessed correctly, the player
wins the reward; otherwise the house collects the bet.
A fourth author wrote a speciﬁcation describing the
contract’s API and behavior. The house’s initial door
1https://github.com/ethereum/tests/tree/develop/VMTests
Opcode
CODECOPY
CALLCODE
SELFDESTRUCT
DELEGATECALL
CREATE
Other
None
Contracts
50,147 (14%)
(8%)
30,109
(7%)
24,707
(6%)
19,749
(3%)
11,559
6681
(2%)
268,652 (76%)
Transactions
Difﬁculty
5,646,607 (27%) medium
1,213,064
739,249
(6%)
(4%)
2,695,326 (13%)
(5%)
1,143,961
195,569
(1%)
12,780,929 (61%)
hard
easy
hard
easy
-
supported
Table 2: Frequency of main unsupported opcodes. For
blocks 4690101 to 5049100 on the Ethereum network, we
count how many transactions use an opcode that cannot cur-
rently be handled by our Hydra Framework. We further record
the fraction of unique smart contract codes that contain those
opcodes, and the difﬁculty in adding support for each opcode.
choice takes the form of a cryptographic commitment
that is later opened to reveal the winner. If either party
aborts, the other party can claim both the reward and
bet after a ﬁxed timeout. The speciﬁcation leaves the
internal representation of the game open to developers.
TCB size. Our design from Section 6.1 is generic, and
covers both of our target applications (and the majority
of our other workloads, see below). The instrumenter for
Hydra heads is written in 1500 lines of Haskell, and ap-
plies simple code parsing and rewriting rules. The MC’s
proxy functionality is implemented in EVM assembly.
We also wrote an MC in Solidity (185 lines) that applies
tail-call optimization to callbacks. As the Hydra Frame-
work is application-agnostic, we believe this is a reason-
able TCB. It should also be relatively easy to write a for-
mal speciﬁcation for the simple functionality of the MC
and instrumenter, although we have not attempted this.
Completeness and correctness. To evaluate com-
pleteness of our Hydra instrumenter, we consider all
Ethereum transactions for blocks 4690101 - 5049100
(Dec. 7 2017 to Feb. 7 2018). For each transaction,
we test whether our instrumenter supports the evaluated
code (see Section 6.2 for unsupported opcodes). We
ﬁnd that 61% out of 21M transactions, or 76% of 350K
unique smart contracts, are compatible with Hydra. Ta-
ble 2 breaks down the contracts that Hydra currently can-
not handle. This analysis supports the fact that Hydra
could be usable for the majority of Ethereum contracts,
both by deployed code and transaction volume.
We verify soundness by running the ofﬁcial EVM test
suite1 on Hydra contracts. That is, we replace every con-
tract in the test suite by a Hydra contract, and ensure all
observable side effects (e.g.
logs, external calls, return
values, computation outputs) are unchanged. This test
suite is used to evaluate EVM implementations, includ-
ing executable formal speciﬁcations of the virtual ma-
chine [27]. It is thus critical that the suite be compre-
hensive: any gap in coverage represents a potential con-
1346    27th USENIX Security Symposium
USENIX Association
call optimization still results in savings at the end of the
game, when the winnings are sent to the house or player.
Evaluation of gas costs (and anonymity set sizes) for
Submarine Commitments are in Appendix B. These costs
only affect the transaction that claims the bounty.
Observations on the development process. After
writing three heads independently, we commonly tested
our contracts for discrepancies and found multiple bugs
in each head, none of which impacted all heads simul-
taneously. Examples include a misunderstanding of the
ERC20 API, integer overﬂows, “off-by-one” errors in
the Monty Hall game, and a vulnerability to an only re-
cently discovered EVM anti-pattern that lets a contract
silently increase another contract’s ether balance via the
SUICIDE opcode. Notably, all these bugs could have
been exploited against a single contract, yet none of them
appear useful against all heads simultaneously.
In addition to the exploit gap induced by Hydra, the
NNVP development process itself increased the quality
of our contracts. For the Monty Hall, ensuring compat-
ibility between heads required writing a detailed speci-
ﬁcation, which revealed many blind spots in our origi-
nal design. Moreover, differential testing [42] (verify-
ing agreement between heads on random inputs) was re-
markably simpler for exercising multiple code paths for
the Monty Hall game, compared to a standard test suite.
8 Related Work
Software assurance and fault-tolerance are well-studied
topics with an extensive literature. N-version program-
ming [17, 6, 22] in particular was introduced decades
ago and challenged in inﬂuential studies [21, 33] (see
Section 2). Nagy et al. use N-version programming to
construct honey-pots for detecting web exploits [45].
Bitcoin and, more importantly, Ethereum [14] have
popularized smart contracts [52] and script-enhanced
cryptocurrency [30]. Research on smart contract security
is burgeoning and includes: Analysis of common con-
tract bugs [19, 38, 5], static analysis and enhancements
for Solidity [38], formal veriﬁcation tools [9, 28, 3], de-
sign of “escape hatches” [41], DoS defenses for min-
ers [39], trusted data feeds [58], formal EVM seman-
tics [27, 29], and automated exploitation tools [36].
While promising, none of these tools and techniques
have yet seen mainstream adoption, nor do they relate
directly to our explorations in this paper.
In a closely related work, Tram`er et al. [53] consider
using smart contracts for bug bounties (using SGX), but
not the converse, i.e., bounties for smart contracts.
Bug withholding is related to selﬁsh-mining [25],
where a miner withholds blocks to later nullify other
Figure 6: Gas cost of Hydra contracts with N heads. We
compare the Hydra contract—with and without tail-call opti-
mization for callbacks—to a linear scaling of a single contract
for the ERC20 API (left) and a Monty Hall game (right).
sensus break among ofﬁcial EVM implementations, with
impact far beyond Hydra. Hydra passes all tests for con-
tracts it supports (6% of tests contain unsupported opera-
tions, see Section 6.2). This gives us extremely high con-
ﬁdence in the soundness of our transformation. We are
extending the test suite and completeness of our frame-
work towards maximal assurance for our TCB, including
to all ofﬁcial Ethereum tests beyond VM tests.
Gas costs. Running N copies of a smart contract in-
curs an overhead on gas consumption. Some Ethereum
projects, notably the Vyper language, already trade gas
efﬁciency for security. Moreover, a transaction’s gas cost
can be ofﬂoaded onto the contract owner, thus dispensing
users from Hydra’s gas overhead. In any event, for small
yet common workloads, the main gas cost of a transac-
tion is the ﬁxed “base fee”. As the MC calls all the heads
in a single transaction, this fee is amortized, leading to
sub-linear scaling of the gas-cost for N-headed Hydras.
Figure 6 compares gas costs for Hydra contracts with
1-5 heads to a linear scaling of a single non-instrumented
contract. We show results for the ﬁve non-static calls in
the ERC20 API, and for a full Monty Hall game (ﬁve
transactions), with and without tail-call optimization.
For the ERC20 contract, the main cost is the transac-
tion’s base fee of 21,000 gas. A call to the MC incurs
an overhead of about 8000 gas (independent of the num-
ber of heads) or about 0.08 USD2. Each function call
ends in a LOG callback to the MC (to log an “Approval”
or “Transfer” event, as mandated by the ERC20 speciﬁ-
cation). The withdraw function also sends ether to the
calling party. Applying the tail-call optimization results
in signiﬁcant savings for these callback-heavy functions.
Completing a game of Monty Hall requires long-term
storage of many game parameters which overshadows
the base fee costs (each stored word costs 20,000 gas).
As each head stores the data independently, the scaling
is close to (but still below) linear in this case. The tail
2As of February 2018, 1 ether is worth roughly 1000 USD
and a gas price of 1010 wei) is standard according to https://
ethgasstation.info. A value of 1 ether corresponds to 1018 wei.
USENIX Association
27th USENIX Security Symposium    1347
Numberofheads(1,3,5)50K150K250KgascostofERC20approvaldeposittransfertransferFromwithdrawHydra+tailcallopti.HydraLinearscaling0.5M1.5M2.5MgascostofMontyHallMontyHallminers’ work. As selﬁsh mining operates at the block
level and bug withholding at the application level, they
differ in their mechanisms, analysis, and implications.
Submarine Commitments hide bounty claims among
normal Ethereum transactions and relate to cover trafﬁc
techniques such as anonymity networks (e.g., Tor [20]),
network-based covert channels [44], steganography and
watermarking [32]. Submarine Commitments differ in
that they assume ultimate opening of a hidden value.
Several works [35, 31, 53] model blockchain-level ad-
versaries. They consider an adversary that can reorder
transactions within a given block, however, and not the
much stronger model of chain-rewriting we explore here.
9 Conclusion
We have presented the Hydra Framework, the ﬁrst prin-
cipled approach to administering bug bounties that in-
centivize honest disclosure. The framework relies on a
novel notion of an exploit gap, a program transforma-
tion that enables bug detection at runtime. We have de-
scribed one such strategy, N-of-N-version programming
(NNVP), a variant of N-version programming that de-
tects divergences between multiple program instances.
We have applied our framework to smart contracts,
highly valuable and vulnerable programs that are par-
ticularly well suited for fair and automated bug boun-
ties. We have formally shown that Hydra contracts in-
centivize bug disclosure, for bounties orders of magni-
tude below an exploit’s value. We have modeled strong
bug-withholding attacks against on-chain bounties, and
analyzed Submarine Commitments, a generic defense to
front-running that hides transactions in ordinary trafﬁc.
Finally, we have designed and evaluated a Hydra
Framework for Ethereum, and rigorously tested its
soundness and applicability to the majority of Ethereum
contracts today. We used this framework to construct a
Hydra ERC20 token and Monty Hall game. The former
is live in production on Ethereum, and represents the ﬁrst
principled and trust-free bug bounty offering.
Acknowledgements
We thank Paul Grubbs and Rahul Chatterjee for com-
ments and feedback. This research was supported by
NSF CNS-1330599, CNS-1514163, CNS-1564102, and
CNS-1704615, ARL W911NF-16-1-0145, and IC3 In-
dustry Partners. Philip Daian is supported by the Na-
tional Science Foundation Graduate Research Fellow-
ship DGE-1650441. Lorenz Breidenbach was supported
by the ETH Studio New York scholarship.
References
[1] Cryptocurrency market
coinmarketcap.com/tokens/.