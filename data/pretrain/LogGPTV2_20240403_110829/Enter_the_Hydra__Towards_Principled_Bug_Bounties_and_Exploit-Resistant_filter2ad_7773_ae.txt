### 7. Evaluation

The primary objective of this paper is not to rigorously measure the correlations between smart contract faults, but to propose a novel, principled bug bounty framework based on an assumed exploit gap. A thorough analysis of smart contract failure patterns is left for future work. We evaluate our framework using standard software metrics: TCB (Trusted Computing Base) size, soundness, applicability, and performance. This section concludes with a discussion of our development process.

#### Workloads

To test the soundness, applicability, and performance of Hydra contracts, we use three workloads:
1. The official suite of test contracts for the Ethereum Virtual Machine (EVM).
2. All contracts used in Ethereum between December 7, 2017, and February 7, 2018.
3. Two representative smart-contract applications developed by the authors: implementations of Submarine Commitments in Ethereum and a detailed analysis of the resulting anonymity sets for bounty claiming transactions, which are provided in Appendix B.

We developed a generic ERC20 contract for token transfers and a Monty Hall Lottery, where two participants play a multi-round betting game. Three authors independently developed one head in each of Solidity, Serpent, and Vyper, the main programming languages in Ethereum. These languages have different design trade-offs (ease-of-use, low-level features, or security) and provide valuable diversity among our Hydra heads.

- **Hydra ERC20 Token**: The ERC20 token-transfer API has been thoroughly peer-reviewed and is supported by most high-value contracts in Ethereum. As of February 2018, the combined market cap of the top ten Ethereum tokens exceeds $20 billion. Notably, the exploit in the DAO was partially present in the code managing tokens. Our three-headed Hydra token is deployed on the main Ethereum network and can be used as a drop-in replacement for any ERC20 token. When a user submits a token order, the Master Contract (MC) delegates to all heads and validates the order upon agreement. Our initial bounty is $3,000, which will increase as the contract undergoes further audit, review, and testing.

- **Hydra Monty-Hall Lottery**: In this game, the house hides a reward behind one of \( n \) doors. The player bets on the winning door, and the house opens \( k \) other non-winning doors. The player can then change their guess. If the player guesses correctly, they win the reward; otherwise, the house collects the bet. A fourth author wrote a specification describing the contract’s API and behavior. The house's initial door choice takes the form of a cryptographic commitment that is later revealed. If either party aborts, the other party can claim both the reward and bet after a fixed timeout. The specification leaves the internal representation of the game open to developers.

#### TCB Size

Our design from Section 6.1 is generic and covers both of our target applications and the majority of our other workloads. The instrumenter for Hydra heads is written in 1,500 lines of Haskell, applying simple code parsing and rewriting rules. The MC's proxy functionality is implemented in EVM assembly. We also wrote an MC in Solidity (185 lines) that applies tail-call optimization to callbacks. Given the application-agnostic nature of the Hydra Framework, we believe this is a reasonable TCB. It should also be relatively easy to write a formal specification for the simple functionality of the MC and instrumenter, although we have not attempted this.

#### Completeness and Correctness

To evaluate the completeness of our Hydra instrumenter, we considered all Ethereum transactions for blocks 4,690,101 to 5,049,100 (December 7, 2017, to February 7, 2018). For each transaction, we tested whether our instrumenter supports the evaluated code. We found that 61% out of 21 million transactions, or 76% of 350,000 unique smart contracts, are compatible with Hydra. Table 2 breaks down the contracts that Hydra currently cannot handle. This analysis supports the fact that Hydra could be usable for the majority of Ethereum contracts, both by deployed code and transaction volume.

We verified soundness by running the official EVM test suite on Hydra contracts. We replaced every contract in the test suite with a Hydra contract and ensured all observable side effects (e.g., logs, external calls, return values, computation outputs) were unchanged. This test suite is used to evaluate EVM implementations, including executable formal specifications of the virtual machine. It is critical that the suite be comprehensive, as any gap in coverage represents a potential concern.

#### Gas Costs

Running \( N \) copies of a smart contract incurs an overhead on gas consumption. Some Ethereum projects, notably the Vyper language, already trade gas efficiency for security. Moreover, a transaction’s gas cost can be offloaded onto the contract owner, thus dispensing users from Hydra’s gas overhead. For small yet common workloads, the main gas cost of a transaction is the fixed "base fee." As the MC calls all the heads in a single transaction, this fee is amortized, leading to sub-linear scaling of the gas-cost for \( N \)-headed Hydras.

Figure 6 compares gas costs for Hydra contracts with 1-5 heads to a linear scaling of a single non-instrumented contract. We show results for the five non-static calls in the ERC20 API and for a full Monty Hall game (five transactions), with and without tail-call optimization. For the ERC20 contract, the main cost is the transaction’s base fee of 21,000 gas. A call to the MC incurs an overhead of about 8,000 gas (independent of the number of heads) or about $0.08. Each function call ends in a LOG callback to the MC (to log an “Approval” or “Transfer” event, as mandated by the ERC20 specification). The withdraw function also sends ether to the calling party. Applying the tail-call optimization results in significant savings for these callback-heavy functions.

Completing a game of Monty Hall requires long-term storage of many game parameters, which overshadows the base fee costs (each stored word costs 20,000 gas). As each head stores the data independently, the scaling is close to (but still below) linear in this case. The tail-call optimization still results in savings at the end of the game when the winnings are sent to the house or player. Evaluation of gas costs (and anonymity set sizes) for Submarine Commitments are in Appendix B. These costs only affect the transaction that claims the bounty.

#### Observations on the Development Process

After writing three heads independently, we commonly tested our contracts for discrepancies and found multiple bugs in each head, none of which impacted all heads simultaneously. Examples include a misunderstanding of the ERC20 API, integer overflows, "off-by-one" errors in the Monty Hall game, and a vulnerability to a recently discovered EVM anti-pattern that lets a contract silently increase another contract’s ether balance via the SUICIDE opcode. Notably, all these bugs could have been exploited against a single contract, yet none of them appear useful against all heads simultaneously.

In addition to the exploit gap induced by Hydra, the NNVP development process itself increased the quality of our contracts. For the Monty Hall, ensuring compatibility between heads required writing a detailed specification, which revealed many blind spots in our original design. Differential testing (verifying agreement between heads on random inputs) was remarkably simpler for exercising multiple code paths for the Monty Hall game compared to a standard test suite.

### 8. Related Work

Software assurance and fault-tolerance are well-studied topics with an extensive literature. N-version programming, introduced decades ago, has been challenged in influential studies. Nagy et al. use N-version programming to construct honeypots for detecting web exploits. Bitcoin and, more importantly, Ethereum have popularized smart contracts and script-enhanced cryptocurrency. Research on smart contract security includes analysis of common contract bugs, static analysis and enhancements for Solidity, formal verification tools, design of "escape hatches," DoS defenses for miners, trusted data feeds, formal EVM semantics, and automated exploitation tools.

While promising, none of these tools and techniques have yet seen mainstream adoption, nor do they directly relate to our explorations in this paper. In closely related work, Tramèr et al. consider using smart contracts for bug bounties (using SGX), but not the converse, i.e., bounties for smart contracts. Bug withholding is related to selfish-mining, where a miner withholds blocks to nullify other miners' work. Submarine Commitments hide bounty claims among normal Ethereum transactions and relate to cover traffic techniques such as anonymity networks (e.g., Tor), network-based covert channels, steganography, and watermarking. Submarine Commitments differ in that they assume the ultimate opening of a hidden value. Several works model blockchain-level adversaries, considering an adversary that can reorder transactions within a given block, but not the much stronger model of chain-rewriting we explore here.

### 9. Conclusion

We have presented the Hydra Framework, the first principled approach to administering bug bounties that incentivize honest disclosure. The framework relies on a novel notion of an exploit gap, a program transformation that enables bug detection at runtime. We described one such strategy, N-of-N-version programming (NNVP), a variant of N-version programming that detects divergences between multiple program instances. We applied our framework to smart contracts, highly valuable and vulnerable programs that are particularly well-suited for fair and automated bug bounties. We formally showed that Hydra contracts incentivize bug disclosure, for bounties orders of magnitude below an exploit’s value. We modeled strong bug-withholding attacks against on-chain bounties and analyzed Submarine Commitments, a generic defense to front-running that hides transactions in ordinary traffic. Finally, we designed and evaluated a Hydra Framework for Ethereum, rigorously testing its soundness and applicability to the majority of Ethereum contracts today. We used this framework to construct a Hydra ERC20 token and Monty Hall game. The former is live in production on Ethereum, representing the first principled and trust-free bug bounty offering.

### Acknowledgements

We thank Paul Grubbs and Rahul Chatterjee for comments and feedback. This research was supported by NSF CNS-1330599, CNS-1514163, CNS-1564102, and CNS-1704615, ARL W911NF-16-1-0145, and IC3 Industry Partners. Philip Daian is supported by the National Science Foundation Graduate Research Fellowship DGE-1650441. Lorenz Breidenbach was supported by the ETH Studio New York scholarship.

### References

[1] Cryptocurrency market. [Online]. Available: https://coinmarketcap.com/tokens/