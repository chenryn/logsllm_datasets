OpenBSD Remote Exploit
”Only two remote holes in the default install”
Alfredo Ortega, Gerardo Richarte
Core Security
April 2007
Abstract
OpenBSD is regarded as a very secure Operating System. This
article details one of the few remote exploit against this system. A
kernel shellcode is described, that disables the protections of the OS
and installs a user-mode process. Several other possible techniques of
exploitation are described.
CONTENTS
CONTENTS
Contents
1
Introduction
2
2
Vulnerability
2
2.1
Mbufs
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2
2.2
ICMPV6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3
2.3
Overﬂow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4
2.4
Gaining code execution . . . . . . . . . . . . . . . . . . . . . .
5
2.4.1
4-bytes Mirrored write . . . . . . . . . . . . . . . . . .
5
2.4.2
Pointer to ext free()
. . . . . . . . . . . . . . . . . . .
5
2.4.3
Where to jump? . . . . . . . . . . . . . . . . . . . . . .
6
3
Now, what?
7
3.1
Hooking the system call
. . . . . . . . . . . . . . . . . . . . .
7
4
ShellCode
7
4.1
Pseudo code . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8
4.2
Detailed description of operation
. . . . . . . . . . . . . . . .
8
5
OpenBSD WˆX internals
11
6
Syscall Hook
12
6.1
Pseudo code . . . . . . . . . . . . . . . . . . . . . . . . . . . .
13
6.2
Detailed description of operation
. . . . . . . . . . . . . . . .
13
6.3
context-switch limit . . . . . . . . . . . . . . . . . . . . . . . .
18
7
User ShellCode
18
7.1
Pseudo code . . . . . . . . . . . . . . . . . . . . . . . . . . . .
18
7.2
Detailed description of operation
. . . . . . . . . . . . . . . .
19
8
Failed attempts
20
9
Proposed Protection
21
10 Conclusion
22
References
23
1
2
VULNERABILITY
1
Introduction
OpenBSD is a Unix-derivate Operating system, focused on security and code
correctness. It’s widely used on ﬁrewalls, intrusion-detection systems and
VPN gateways, because of the security enhancements that it implements
by default. Some of the protection technologies that OpenBSD has on the
default installation are:
• WˆX : Nothing writable is executable
• Address layout randomization
• ProPolice stack protection technology
Note that these protection schemes work only on user space applications.
The attack that this article describes is on Kernel space, so it is mostly
unaﬀected by all these protections 1. OpenBSD is freely available and can
be downloaded from here [2, Home page].
2
Vulnerability
OpenBSD was one of the ﬁrst systems to incorporate the KAME IPv6 stack
software, supporting next-generation protocols for network communication.
Some glue logic is needed to adapt this stack to the internal networking mech-
anisms of the OS, and is in some of these functions that a buﬀer overﬂow was
found. Speciﬁcally, the function m dup1() on the ﬁle sys/kern/uipc mbuf2.c
is called every time that a specially crafted fragmented icmpv6 packet is re-
ceived by the IPv6 stack. This function miscalculates the length of the buﬀer
and causes an overﬂow when copying it.
2.1
Mbufs
Mbufs are basic blocks of memory used in chains to describe and store packets
on the BSD kernels. On OpenBSD, mbufs are 256 bytes long; Using ﬁxed-
sized blocks of memory as buﬀers improve the allocation/deallocation speed
and minimize copying.
The m dup1() function should duplicate a mbuf,
asking for a new mbuf and then copying in the original mbuf, but the length
is not checked as a result of the fragmentation, and the whole icmp6 packet
is copied over a single mbuf. If the fragment is longer than 256 bytes, it will
overﬂow the next mbuf headers with controlled data. The only useful section
1OpenBSD has kernel protections on some architectures, but not on i386
2
2.2
ICMPV6
2
VULNERABILITY
mbuf1
mbuf2
mbuf3
mbuf4
End of overflow
Copy direction
Figure 1: mbuf chain overﬂow direction
of a mbuf to overwrite is it’s header, because inside of it there are several
structures that make it possible to exploit the system. The mbuf header
structure is shown on Listing 1. Figure 1 is shows a chain of mbufs and the
copy direction. You can also see that we overﬂow at least two mbuf buﬀers
with our attack. The ideal scenario would be to overﬂow only one mbuf,
because if we overﬂow too much, an unrecoverable kernel crash becomes very
likely to happen.
2.2
ICMPV6
ICMP is a protocol used for error reporting and network probing. It’s easy
to implement because the messages generally consist of a single IP packet.
The IPv6 incarnation is no diﬀerent and we used this protocol as the attack
vector.However, it may be possible to trigger the vulnerability using other
protocols. As we said already, we fragment a common ICMPv6 echo request
packet into two fragments, one of length zero (IPv6 allows this) and one of the
total length of the ICMPv6 message. It’s important that the ICMPv6 packets
be a valid echo request message with correct checksum. Since the attack
requires that the packets be processed by the IPv6 stack invalid ICMPv6
packets will be rejected. The format of the two ICMPv6 packets is detailed
in ﬁg. 3. We can see how the fragment ﬁts in the mbuf chain, overwritting
three mbufs, and the trampoline (JMP ESI on the kernel) lands exactly on
the pointer to ext free(). The header of mbuf2 is specially crafted, activating
Listing 1: mbuf structure deﬁnition
f i l e :
sys / kern / uipc mbuf2 . c
struct
mbuf
{
struct
m hdr
m hdr ;
union
{
struct
{
struct
pkthdr
MH pkthdr ;
/∗ M PKTHDR s e t
∗/
union
{
struct
m ext
MH ext ;
/∗ M EXT
s e t
∗/
char
MH databuf [MHLEN] ;
}
MH dat ;
} MH;
char
M databuf [MLEN] ;
/∗
!M PKTHDR,
!M EXT ∗/
}
M dat ;
} ;
3
2.3
Overﬂow
2
VULNERABILITY
Header
Fragmentation Header
IPv6 Header
Mbuf chain
Fragment 2
Icmpv6
Icmpv6 Header
Trampoline
ShellCode 
SyscallHook
Payload
Header
mbuf 2
mbuf 1
Header
mbuf 3
Hop−by−Hop Header
Fragmentation Header
IPv6 Header
Fragment 1
Figure 2: Detail of ICMPv6 fragments
the M EXT ﬂag, to force a call to ext free() when freed.
We must also
deterministically force a free on mbuf2 and not mbuf1 or mbuf3, or the system
will crash. Empirically we found a combination of IPv6 packets that works,
even on heavy traﬃc conditions:
for i in range(100): # fill mbufs
self.sendpacket(firstFragment)
self.sendpacket(normalIcmp)
time.sleep(0.01)
for i in range(2): # Number of overflow packets to send. Increase if exploit is not reliable
self.sendpacket(secondFragment)
time.sleep(0.1)
self.sendpacket(firstFragment)
self.sendpacket(normalIcmp)
time.sleep(0.1)
This Python code sends fragments, combined with normal ICMPv6 packets,
manipulating the mbuf chains in a way that forces a free exactly on the mbuf
that we need. This is a section of the Original Advisory [1]
2.3
Overﬂow
The overﬂow happens when the m dup1() function calls copydata() (2)over-
writting a newly allocated mbuf with the second fragment. The important
region of memory to overﬂow is the header of the second buﬀer, mbuf2. (Our
attack requires that the next packet, mbuf3 be also overﬂowed, but this is
because our shellcode is too big to use only 256 bytes. A better attack would
overﬂow only mbuf2)
4
2.4
Gaining code execution
2
VULNERABILITY
Listing 2: m dup1() overﬂow instruction
/ kern / uipc mbuf2 . c
s t a t i c
struct
mbuf
∗
m dup1 ( struct
mbuf
∗m,
int
o f f ,
int
len ,
int
wait )
{
.
.
.
i f
( copyhdr )
M DUP PKTHDR(n , m) ;
m copydata (m,
o f f ,
len ,
mtod (n ,
c a d d r t ) ) ;
/∗ OVERFLOW HERE ∗/
n−>m len = l e n ;
return
( n ) ;
}
2.4
Gaining code execution
There are at least two exploit techniques that can be used on this scenario.
On the PoC2 described on this article we used the most simple and likely to
succeed, but both of them are explained.
2.4.1
4-bytes Mirrored write
Because the mbufs are on a linked list, there are a couple of pointers to
the previous and next mbuf’s. When a mbuf is freed, the pointers on the
previous and next mbuf’s are exchanged and because we control both pointers
(we stepped on them with the overﬂow) we can write up to 32 bits anywere
on the kernel memory. This is not much, but enough to overwrite the process
structure and scalate privileges, for example. But this technique is diﬃcult
and a more easy solution is available using a member of the mbuf header,
because it contains directly a pointer to a function.
2.4.2
Pointer to ext free()
There is a structure in the mbuf header called m ext (1), that is used only
when there is need for external storage on the mbuf. This external storage
can be allocated on a variety of ways, but a function must be provided to
free it. As shown in Listing 3, a pointer to this function is stored directly
in the mbuf header. This function, ext free(), is called on the release of the
mbuf if the M EXT ﬂag is set. Since we control the entire mbuf header, if
we set the M EXT ﬂag, set the ext free() pointer and force the mbuf to be
freed, we can redirect the execution to any desired location. This location
can be anywhere in the Kernel memory space, because (this is important
), the OpenBSD kernel-space has no protections like there are in user-space
2Proof of Concept
5
2.4
Gaining code execution
2
VULNERABILITY
Listing 3: m ext structure deﬁnition
/∗
d e s c r i p t i o n
o f
e x t e r n a l
s t o r a g e
mapped
i n t o
mbuf ,
v a l i d
i f
M EXT
s e t
∗/
f i l e :
sys / kern / uipc mbuf2 . c
struct
m ext
{
c a d d r t
e x t b u f ;
/∗
s t a r t
o f
b u f f e r
∗/
/∗
f r e e
r o u t i n e
i f
not
the
usual
∗/
void
(∗ e x t
f r e e ) ( caddr t ,
u int ,
void
∗ ) ;
void
∗ e x t a r g ;
/∗
argument
f o r
e x t
f r e e
∗/
u i n t
e x t
s i z e ;
/∗
s i z e
o f