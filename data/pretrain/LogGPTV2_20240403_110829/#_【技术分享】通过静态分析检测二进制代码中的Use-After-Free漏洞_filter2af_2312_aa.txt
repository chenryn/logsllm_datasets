# 【技术分享】通过静态分析检测二进制代码中的Use-After-Free漏洞
|
##### 译文声明
本文是翻译文章，文章来源：blog.amossys.fr
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
****
**翻译：**[ **shan66**
****](http://bobao.360.cn/member/contribute?uid=2522399780)
**预估稿费：260RMB（不服你也来投稿啊！）**
******投稿方式：发送邮件至**[ **linwei#360.cn**](mailto:PI:EMAIL) **，或登陆**[
**网页版**](http://bobao.360.cn/contribute/index) **在线投稿******
**前言**
Use-After-Free是一种众所周知的漏洞类型，经常被现代的攻击代码所利用（参见Pwn2own
2016）。在研究项目AnaStaSec中，AMOSSYS提供了许多关于如何静态检测二进制代码中的此类漏洞的介绍。在这篇博文中，我们将向读者阐述学术界在如何检测这种类型的漏洞方面提出的各种建议。当然，他们当前的目标是定义一种通用方法，这样的话，我们就可以根据自己的需求来构建相应的概念验证工具了。
**关于Use-After-Free（UAF）漏洞**
UAF的原理很容易理解。当程序尝试访问先前已被释放的内存区时，就会出现“Use-After-Free”漏洞。在这种情况下创建的悬空指针将指向内存中已经释放的对象。
举个例子，下面的代码将导致一个UAF漏洞。如果下面的代码在运行过程中执行了if分支语句的话，由于指针ptr指向无效的存储器区，所以可能发生不确定的行为。
    char * ptr = malloc(SIZE);
    …
    if (error){
        free(ptr);
    }
    …
    printf("%s", ptr);
图 1：Use-After-Free示例代码
换句话说，如果发生如下所示的3个步骤，就会出现UAF漏洞：
分配一个内存区并且让一个指针指向它。
内存区被释放，但原来的指针仍然可用。
使用该指针访问先前释放的内存区。
大多数时候，UAF漏洞会只会导致信息泄漏，但有的时候，它还可能导致代码执行——攻击者对这种情况更感兴趣。导致代码执行通常发生在下列情况下：
程序分配了内存块A，后来将其释放了。
攻击者分配了内存块B，并且该内存块使用的就是之前分配给内存块A的那片内存。
攻击者将数据写入内存块B。
程序使用之前释放的内存块A，访问攻击者留下的数据。
在C++中，当类A被释放后，攻击者立刻在原来A所在的内存区上建立一个类B的时候，就经常出现这种漏洞。这样的话，当调用类A的方法的时候，实际上执行的是攻击者加载到类B中的代码。
现在我们已经掌握了UAF的概念，接下来我们将考察安全社区是如何检测这种漏洞的。
**静态和动态分析的优缺点**
二进制代码的分析方法主要有两种：静态分析和动态分析。就目前来说，动态地分析整个代码是非常困难的，因为要想生成可以覆盖所有二进制代码执行路径的输入的话，绝不是一件容易的事情。因此，当我们专注于代码覆盖问题时，静态分析方法似乎更为适用。
然而，根据论文[Lee15]和[Cab12]的介绍，与Use-After-Free漏洞检测有关的大多数学术论文仍然集中在动态分析方面。这主要是因为。动态分析方法易于检测同一指针的副本，也称为别名。换句话说，使用动态分析方法时，我们可以直接访问内存中的值，这种能力对于代码分析来说是非常重要的。如果使用动态分析的话，我们能够获得更高的准确性，但同时也会失去一些完整性。
然而，本文将专注于静态分析方法。在学术界看来，这种方法仍然面临两大困难：
1)
最大的困难是如何管理程序中的循环。实际上，当计算循环中待处理的变量的所有可能值时，需要知道循环将被执行多少次。这个问题通常被称为停机问题。在可计算性理论中，所谓停机问题就是去判断程序会最终停下来，还是一直运行下去。不幸的是，这个问题已经被证明是无解的。换句话说，没有通用算法可以在给出所有可能输入的情况下解决所有可能程序的停止问题，即不存在一个判定一切程序的程序，因为这个程序本身也是程序。在这种情况下，为了解决这个问题，只好借助于静态分析工具来进行相应的简化了。
2)
另一个困难在于内存的表示方式。一个简单的解决方案是维护一个大数组，其中保存指针的内存值。然而，这不是看起来那么简单。例如，一个内存地址可以具有多个可能的值，或者一些变量可以具有多个可能的地址。此外，如果有太多可能取值，那么将所有的值都单独保存的话是不合理的。因此，必须对这种内存表示进行一些简化。
为了降低静态分析的复杂性，一些论文像[Ye14]或像Polyspace或Frama-C这样的工具，都是在C源代码级别来分析问题的，因为这个级别包含了最大程度的信息。但是，人们在分析应用程序的时候，通常是无法访问源代码的。
**从二进制代码到中间表示**
当我们进行二进制分析的时候，第一步是建立相关的控制流图（CFG）。控制流图是一种有向图，用来表示程序在执行期间可能经过的所有路径。CFG的每个节点代表一条指令。由一条边连接的两个节点表示可以连续执行的两个指令。如果一个节点具有两个延伸到其他节点的边，这表明该节点是一个条件跳转指令。因此，通过CFG我们可以将一个二进制代码组织成一个指令的逻辑序列。在为可执行文件建立CFG的时候，最常见的方法是使用反汇编程序IDA
Pro。
当处理二进制代码方面，学术论文好像都是用相同的方式来处理UAF漏洞的。论文[Gol10]和[Fei14]给出了具体的处理步骤：
事实表明循环似乎对Use-After-Free的存在没有很大的影响。因此，在着手处理二进制代码时，一个强制性的步骤就是利用第一次迭代展开循环。就像我们前面刚刚解释的那样，这个步骤可以避免停机问题。第一次迭代
为了简化前面提到的内存表示问题，我们可以使用中间表示形式（IR），因为这种表示形式可以独立于具体的处理器架构。例如，x86汇编代码就过于复杂，因为它有太多的指令。一个解决办法是对小型的指令集进行分析。使用中间表示形式的时候，每个指令都被转换为几个原子指令。至于选择哪种中间表示形式，则取决于分析的类型。在大多数情况下，我们都会选择逆向工程中间语言（REIL），但是在一些学术文献中也有使用其他IR的，例如BAP（[Bru11]）或Bincoa（[Bar11]）等。
REIL
IR只有17种不同的指令，并且每个指令最多有一个结果值。我们可以使用像BinNavi这样的工具将本机x86汇编代码转换为REIL代码，BinNavi是由Google（以前是Zynamics）开发的一个开源工具。BinNavi可以将IDA
Pro的数据库文件作为输入，这一特性给我们带来了极大的便利。
**符号执行与抽象解释**
一旦将二进制代码转换为中间表示形式，我们就可以通过两种方法来分析这些二进制代码的行为了，即抽象解释（[Gol10]和[Fei14]）或符号执行（[Ye14]）。