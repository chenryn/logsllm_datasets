fact, the trusted OS in the secure world is proprietary property in
all the commercial products. In BoltOS, we only implement the
save and restore services. In Android, the BoltAgent invokes a
customized interface directly to kernel to request these services.
We connect to our i.MX experiment board a programmable flash
board LPC-H3131 [28] through USB interface. The flash board holds
the System and Data partitions of the Android system. BoltFTL
is built based on OpenNFM [8], an open source NAND flash con-
troller framework. In the following, we detail the implementation
of BoltOS and BoltFTL.
4.1 BoltOS
After the proprietary device ROM, BoltOS resumes execution in
the secure world, and initializes itself within iRAM, which is a sep-
arated on-chip memory other than DRAM. In this way, we can
symmetrically allocate the whole DRAM to the Android system
and snapshot image. In particular, BoltOS configures the TZASC so
that the first 512 MB of DRAM is set to be a non-secure resource for
the Android system and the remaining 512 MB of DRAM is set to be
a secure resource for snapshot storage. Finally, it loads the Android
bootloader to the DRAM region assigned to the Android system,
and switches to the normal world to run the Android bootloader,
which further boots the Android OS.
The type of service requested by BoltAgent is indicated by the
r0 register. BoltOS is linked with the newlib C library [46] for em-
bedded systems. Hence, we can readily invoke standard C library
functions such as memcpy to speed up memory saving and restor-
ing. In total, BoltOS consumes less than 30 KB memory in iRAM,
including 16 KB for page tables.
4.2 BoltFTL
We have implemented a prototype of BoltFTL using OpenNFM [8],
an open source NAND flash controller framework. OpenNFM uses
an architecture consisting of three layers. The highest layer mainly
handles mappings between the LPA from upper layer and the PPA
in raw flash, so that the flash-based storage device can provide a
uniform block device interface to file systems. The middle layer
mainly takes care of wear leveling and bad block management. The
lowest layer provides a raw flash abstraction, handling the physical
characteristics of different flash chips. We customized OpenNFM
to work with LPC-H3131 [28], a development board equipped with
180 MHz ARM microcontroller, 512 MB NAND flash, and 32 MB
SDRAM. The flash has 128 KB block size and 2KB page size, thus
the entire NAND flash has 4,096 erase blocks, and each block is
composed of 64 pages. Each mapping entry can be represented by
3 bytes, therefore the mapping table occupies 6 blocks.
In BoltFTL, to receive the save and restore commands from
BoltOS, we take advantage of the reserved operation codes of SCSI
commands [19]. Specially, we adopt an SCSI command with op-
eration code 0x61H to inform BoltFTL to start performing save
operations, and adopt an SCSI command with operation code 0x62H
to inform BoltFTL to start performing restore operations.
5 EVALUATION
In this section, we evaluate the proposed system. First, we mea-
sured the time required to restore the guest Android system. We
also break down the whole process to discover the most time con-
suming stage. Since the restoration time is highly dependent on the
configuration of a real hardware, we also measured the time spent
with different configurations of hardware. Following this, we dis-
sected the time spent on flash restoration. Finally, we measured the
runtime performance of flash access with our modified firmware.
If the performance is severely influenced, the malware may ob-
serve such environmental change and refuse to expose malicious
behaviors.
345World
Switch
Memory 
Restoration
Context
Resotration
World
Switch
Command
Transmission
Flash 
Restoration
Figure 5: Restoration timeline
Table 1: Time breakdown for restoring the guest system (in
μs).
World Switch
Memory
Context
Flash
Restoration
Restoration
Restoration
1.2
2798087
23
433917
Table 2: Memory restoration under different physical mem-
ory sizes.
Memory Size (in MB)
384
448
512
Time (in μs)
2092653
2445271
2798087
5.1 Restoration Performance
We report the device restoring time in this section. As our experi-
ment board has only 1 GB DRAM, we measured the time required
to restore an Android system with 512 MB physical memory. The
flash has 512 MB storage, and BoltFTL is able to recover the entire
contents at a time. All the experiments ware performed for at least
10 times, and the averaged time is reported.
Breakdown measurements. Figure 5 shows the timeline of a
restoration process. After receiving the restoration command,
BoltOS issues the customized SISC command to BoltFTL. This
process is non-blocking, therefore, BoltOS immediately begins to
restore the physical memory and processor context. Finally, BoltOS
transfers control to the guest system to resume execution at the
time snapshot was taken. Note that in our experiments, the time
required to restore the physical memory is far longer than that
required to restore the flash. Hence, only the upper line in Figure 5
accounts for the time spent on system restoration.
To measure the time spent on each stage, we utilized the Per-
formance Monitor Unit (PMU) available in our experiment board,
and counted the CPU cycles spent. The time required was calcu-
lated as the elapsed cycles divided by the processor frequency. We
temporarily disabled the Linux perf support in the normal world
to eliminate its interference with the PMU state. We cannot mea-
sure the exact time spent on command transmission, because the
clocks in BoltOS and BoltFTL are not synchronized. Rather, we
recorded in BoltOS the time spent on command transmission and
flash restoration as a whole. In Table 1, we list a breakdown mea-
surement of time spent on each stage. As shown in the table, most
of time was spent on the memory restoration. Based on the timeline
shown in Figure 5, the total time to recover the system is 2.80s.
Restoration under varying memory sizes. We also assigned
different sizes of physical memory to the guest system. Restricted
)
s
/
B
K
(
t
u
p
h
g
u
o
r
h
T
2000
1800
1600
1400
1200
1000
800
600
400
200
0
OpenNFM
BoltFTL
SR
RR
SW
Access Patterns
RW
Figure 6: Throughput comparison between OpenNFM and
BoltFTL. SR - sequential read, RR - random read, SW - se-
quential write, RW - random write
by the size of DRAM on the device, the maximum tested size is
512 MB. In addition, Android system has minimal requirement for
physical memory. Therefore, we only tested memory sizes between
384 MB and 512 MB. As shown in Table 2, the time consumption
basically follows a linear relationship with the restored memory
size. Note that the time for memory restoration depends on not
only the physical memory size, but also the underlying SoC. A
more advanced chip with a powerful processor and high memory
bandwidth could further reduce the restoration time.
Evaluating the efficiency of flash restoration. To restore a
flash-based block device, BoltFTL simply activates the backup meta-
data to replace the current one in the RAM (equipped with the
flash-based block device). In our evaluation with LPC-H3131, this
takes approximately 0.43s.
5.2 Flash Runtime Performance
BoltFTL is a customized flash firmware incorporating specifically
designed strategies that feature snapshot function for the whole
chip. To figure out how these strategies affect the performance of
the flash, we used the AndroBench storage benchmark to measure
the performance of the default OpenNFM and BoltFTL. We set the
buffer sizes for sequential and random accesses to 32768 KB and 4
KB respectively (default values). As shown in Figure 6, we have the
following observations.
(a) The throughput of read performances measured in BoltFTL is
almost the same as the default OpenNFM. Indeed, read operations
do not make any modification to the flash state, so the logic to
process read operations is the same in BoltFTL and OpenNFM.
(b) The throughput of write operations measured in BoltFTL
is slightly lower (2%) than the default OpenNFM. The introduced
overhead is caused by the following reasons. (1) To increase the
write throughout, FTL prepares a certain number of free blocks for
upcoming writing operations in advance. This means these blocks
need to be reclaimed by GC beforehand. However, when running
with BoltFTL, the firmware does not select the blocks storing the
clean-state data as victim blocks in GC, which inevitably increases
GC frequency slightly to satisfy the demand of free blocks. (2)
346GC in BoltFTL introduces much more uneven P/E cycles among
flash blocks than default OpenNFM. To prolong the lifetime of the
flash-based block device, in BoltFTL, wear leveling is invoked more
frequently to ensure that programmings/erasures distribute evenly
across the entire flash.
6 DISCUSSION AND FUTURE WORK
Decreased flash capacity. To protect the blocks that hold the
clean-state data, BoltFTL never reclaims these blocks for reuse.
Therefore, operations that need new block allocations will be in-
fluenced. For example, if the malware deletes a file that exists in
the snapshot image, the number of available logical blocks is in-
creased accordingly, whereas the number of total reclaimable phys-
ical blocks is not. As a result, the flash capacity is decreased. Fortu-
nately, a clean Android system partition only occupies 268 MB in
our build, indicating that there is at most 268 MB of storage loss.
This will not be a problem for modern commercial flash-based block
devices with high storage capacities.
Ware-and-tear artifacts. Bolt assumes that the malware could
not distinguish it is being analyzed by running it in a bare-metal
hardware without modification to the guest. However, as revealed
by Miramirkhani et al. [29], more sophisticated evasive malware is
able to exploit the “wear and tear” artifacts that inevitably occur on
devices of real users, but not in-lab devices, to identify it is being
analyzed. The authors also developed a statistical model to aid
building system images that exhibit a realistic “wear and tear” state.
Note that their findings do not indicate bare-metal analysis can
be largely detected. Rather, existing solutions, including Bolt, can
improve the fidelity by further taking the “wear and tear” artifacts
into consideration.
Self restoration. In the current prototype, BoltOS in the secure
world is only responsible for taking snapshot and making restora-
tion for the normal-world guest system as required. However, in a
real-world setting, BoltOS should also provide security services for
the commodity guest OS. To exhibit a consistent view for the guest
OS after restoration, the statuses of security services in BoltOS
should be restored as well. Chicken-and-egg problem occurs here
because there is no lower level execution domain than the Trust-
Zone secure world to restore the status of BoltOS. In practice, this
inconsistence would cause exceptions to apps in the guest system.
For example, the security service typically returns a fault code to the
guest if it cannot find a session associated with the guest-provided
session id. Fortunately, the security services can be recovered after
re-establishing the session. Moreover, for BoltOS, we do not need
to restore the entire OS status as is done for the guest OS. Applica-
tion level restoration, which has been well studied [34], could be
employed for the purpose of security service restoration.
Selective restoration. Our prototype takes memory snapshot by
simplify saving the entire physical memory assigned to the guest.
However, there exists a lot of unused pages that do not need to
be restored. As the physical memory becomes large, more time is
wasted on copying unimportant pages. In the future, we plan to
employ VM introspection techniques [22] to analyze the structure
of physical memory, and only take snapshot of the pages in use.
7 RELATED WORK
This section reviews approaches used in malware analysis on both
bare-metal and emulated platforms. We focus on the bare-mental
setting, as it leaves minimal artifacts for the malware. We describe
two fundamental challenges and their solutions in this setting –
system restoration and malware behavior extraction. Finally, we
introduce several works that take advantage of ARM TrustZone or
flash for security purposes.
7.1 Malware Analysis on Bare Metal
System restoration. BareDroid [30] provides a quick restore mech-
anism that makes the bare-metal analysis of Android applications
feasible at scale. However, it only restores the disk state of the sys-
tem, so a reboot is needed to fully recover the system status. Bolt
performs a complete system restoration including both memory and
flash disk. BareBox [25] is a quick restoration system for bare-metal
analysis on x86 machines. Both Bolt and BareBox are rebootless
systems. In addition, they both enable the memory restoration by
splitting the physical memory into two parts, and rely on a separate
OS to take snapshot and make restoration. Regarding disk restora-
tion, BareBox relies on an overlay-based mirror disk, whereas Bolt
relies on a customized flash firmware. The separated OS in Bare-
Box runs with the same privilege as the guest system, so it can
be easily detected by kernel-level malware, and even be disrupted.
In Bolt, we employ ARM TrustZone to implement an isolated OS.
In addition, existing works require in-guest components to assist
restoration, whereas Bolt is completely transparent to the guest.
This is made possible by a non-suspicious agent app that issues
requests for security services that already exist in the system.
Behavior extraction and analysis. LO-PHI [40] leverages addi-
tional hardware sensors to monitor the disk operation and period-
ically poll memory snapshots. It achieves a higher transparency