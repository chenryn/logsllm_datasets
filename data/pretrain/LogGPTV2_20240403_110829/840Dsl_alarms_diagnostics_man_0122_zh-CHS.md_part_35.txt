说明： 在子程序定义中确定了一个形式REF参数(call-by-reference参数)，但在调用时没有分配到实际参数。
子程序调用中的参数分配是根据变量名的定位而不是根据名称来进行的!
例如：
子程序：( 2个call-by-value参数X和Y
1个call-by-reference参数Z)
PROC XYZ (INT X, INT Y, VAR INT Z)
：
M17
ENDPROC
主程序：
N10 DEF INT X
N11 DEF INT Y
N11 DEF INT Z：
：
N50 XYZ (X, Y)；缺少REF参数Z
或
N50 XYZ (X, Z)；缺少REF参数Y!
反应： 重组补偿程序段。
已设置接口信号。
报警显示。
排除方法： 按NC停机键并利用软键设计校正选择功能"校正程序块"。校正指针位置指示在差错块上。
调用时给子程序的所有REF参数(定位参数调用)分配一个变量。不必给"标准的"形式参数(赋值参数)分配变量，因为这些参
数被默认为0。
程序继续： 按下CYCLE START键或RESET键清除报警，继续运行程序。
12310 [通道 %1: ] 程序段 %2 调用子程序 %3 时缺少轴文件
参数： %1 = 通道号
%2 = 程序段号、 标记
%3 = 源字符串
报警
诊断手册, 01/2022, 6FC5398-6BP40-6RA6 173
NC 报警
说明： 调用子程序时，依照EXTERN指令应该表现出来的AXIS参数丢失。
利用EXTERN指令，用户定义子程序(程序)被设置为指出有参数传输过程的"巳知"状态。
无参数传输过程不须EXTERN说明。
例如：
子程序XYZ (利用形式参数)：
PROC XYZ (INT X, VAR INT Y, AXIS A, AXIS B)
EXTERN指令(带变量类型)
EXTERN XYZ (INT, VAR INT, AXIS, AXIS) 子程序调用(带有实际参数) ：
N10 XYZ (, Y1, R_TABLE)
变量X被默认为0
变量Y被赋予了变量值Y1并且在子程序运行后将结果返回到调用程序
变量A被赋予了R_TABLE中的轴
变量B丢失!
反应： 重组补偿程序段。
已设置接口信号。
报警显示。
排除方法： 按NC停机键并利用软键设计校正选择功能"校正程序块"。校正指针位置指示在差错块上。
在调用中设计丢失的AXIS参数。
程序继续： 按下CYCLE START键或RESET键清除报警，继续运行程序。
12320 [通道 %1: ] 程序段 %2 文件 %3 必须是调用参数
参数： %1 = 通道号
%2 = 程序段号、 标记
%3 = 源字符串
说明： 虽然只允许使用变量标识符，但是一个常量或数学表达式结果被分配给REF参数而不是分配给子程序调用时的变量。
例如：
N10 XYZ ( NAME_1 、10、OTTO)或
N10 XYZ (NAME_1, 5 + ANNA, OTTO)
反应： 重组补偿程序段。
已设置接口信号。
报警显示。
排除方法： 按NC停机键并利用软键设计校正选择功能"校正程序块"。校正指针位置指示在差错块上。
从NC程序块中删除常量或数学表达式。
程序继续： 按下CYCLE START键或RESET键清除报警，继续运行程序。
12330 [通道 %1: ] 程序段 %2 文件 %3 类型错误
参数： %1 = 通道号
%2 = 程序段号、 标记
%3 = 源字符串
报警
174 诊断手册, 01/2022, 6FC5398-6BP40-6RA6
NC 报警
说明： 当调用一个程序(一个子程序)时，发现实际参数类型不能转换成形式参数类型。有两种可能情况：
- 通过定位参数调用：实际参数和形式参数必须是严格的相同类型，例如，字符串、字符串。
- 通过值参数调用：实际参数和形式参数可能大体上是不同的类型的，基本可以转换。但是，在目前情况下，类型通常是不
兼容的，例如字符串- >实数。
类型转化概述：
- 从 REAL 到： REAL: 是, INT: 是*, BOOL: 是1), CHAR: 是*, STRING: -, AXIS: -, FRAME: -
- 从 INT 到: REAL: 是, INT: 是, BOOL: 是1), CHAR: if value 0 . . . 255, STRING: -, AXIS: -, FRAME: -
- 从 BOOL 到: REAL: 是, INT: 是, BOOL: 是, CHAR: 是, STRING: -, AXIS: -, FRAME: -
- 从 CHAR 到: REAL: 是, INT: 是, BOOL: 是1), CHAR: 是, STRING: 是, AXIS: -, FRAME: -
- 从 STRING 到: REAL: -, INT: -, BOOL: 是2), CHAR: only if 1 character, STRING: 是, AXIS: -, FRAME: -
- 从 AXIS 到: REAL: -, INT: -, BOOL: -, CHAR: -, STRING: -, AXIS: 是, FRAME: -
- 从 FRAME 到: REAL: -, INT: -, BOOL: -, CHAR: -, STRING: -, AXIS: -, FRAME: 是
1) 值<> 0与真对应，值= = 0与假对应
2)串长度0 =〉假，否则为真。
*) 从REAL到INT的类型转换中，> = 0.5的分数值只入不舍，其它的只舍不入。
反应： 重组补偿程序段。
已设置接口信号。
报警显示。
排除方法： 按下“NC停止”键并按下“程序修正”软键选择功能“修正程序段”。修正指针位置指示在出错的程序段上。
检查子程序调用的传输参数并按照使用情况定义为“call-by-value”或“call-by-reference”参数。
程序继续： 按下CYCLE START键或RESET键清除报警，继续运行程序。
12340 [通道 %1: ] 程序段 %2 在 %3 中文件号超出
参数： %1 = 通道号
%2 = 程序段号、 标记
%3 = 源字符串
说明： 当调用一个函数或程序(预先确定或自定义)时，传输的参数数量要比所定义的数量多。
预定义函数和程序：参数数目已经在NCK中永久设置。
用户定义函数和程序：参数数目是根据定义中的类型和名称确定的。
反应： 重组补偿程序段。
已设置接口信号。
报警显示。
排除方法： 按NC停机键并利用软键设计校正选择功能"校正程序块"。校正指针位置指示在差错块上。检查是否调用了正确的程序/函数。
根据程序/函数设计参数数目。
程序继续： 按下CYCLE START键或RESET键清除报警，继续运行程序。
12350 [通道 %1: ] 程序段 %2 因轴文件不存在，文件 %3 不能接收
参数： %1 = 通道号
%2 = 程序段号、 标记
%3 = 源字符串
说明： 在之前的轴参数尚未赋值的情况下，仍试图传输当前参数。在程序或功能调用中，如果之后不需要传输其他参数，则可以
忽略对非必需的轴参数的赋值。示例：N10 FGROUP(X, Y, Z, A, B) ；最多8根轴。之后的call-by-value参数会预设为零，因
为与刀位相关的赋值由于缺少轴参数而丢失。在预定义程序或功能时，可忽略的轴和后续的参数将不再出现。
反应： 重组补偿程序段。
已设置接口信号。
报警显示。
排除方法： 按NC停机键并利用软键设计校正选择功能"校正程序块"。校正指针位置指示在差错块上。在预定过程和函数中，要么删除
下列参数，要么在轴参数之前传输其它参数。在自定义程序和函数中，参数传输必须根据机床生产商程序设计手册中的说
明来设计。
程序继续： 按下CYCLE START键或RESET键清除报警，继续运行程序。
报警
诊断手册, 01/2022, 6FC5398-6BP40-6RA6 175
NC 报警
12360 [通道 %1: ] 程序段 %2 文件 %3 的尺寸错误
参数： %1 = 通道号
%2 = 程序段号、 标记
%3 = 源字符串
说明： 要检查下面可能出现的错误:
- 当前参数是一个数组但是形式参数是一个变量。
- 当前参数是一个变量但是形式参数是一数组。
- 当前和形式参数是数组，但是不带有要确定的维数。
反应： 重组补偿程序段。
已设置接口信号。
报警显示。
排除方法： 按NC停机键并利用软键设计校正选择功能"校正程序块"。校正指针位置指示在差错块上。根据上列的错误原因校正NC部
件加工程序。
程序继续： 按下CYCLE START键或RESET键清除报警，继续运行程序。
12370 [通道 %1: ] 程序段 %2 %3 的取值范围不允许
参数： %1 = 通道号
%2 = 程序段号、 标记
%3 = 源字符串
说明： 一个变量已经被利用块初始化范围之外的值域赋了初值。程序定义-在特殊的块初始化中只允许使用全局变量。这些变量利
用一个值域来赋初值。
反应： 重组补偿程序段。
已设置接口信号。
报警显示。
排除方法： 按NC停机键并利用软键设计校正选择功能"校正程序块"。校正指针位置指示在差错块上。
删除值域标准(以关键字OF开头)或将变量定义为块初始化中的全局变量并且利用一个值域为其赋初值。
程序继续： 按下CYCLE START键或RESET键清除报警，继续运行程序。
12380 [通道 %1: ] 程序段 %2 超出最大存储容量
参数： %1 = 通道号
%2 = 程序段号、 标记
说明： 这些程序块中的数据定义不能被处理，因为创建数据的最大可用内存已满，或因为数据块不能再接纳更多的数据。
如果连续执行多个子程序调用并且没有生成对机床有意义的程序块(运动、暂停、M功能)，也会出现报警。
反应： 重组补偿程序段。
已设置接口信号。
报警显示。
排除方法： 请通知授权人员/维修部门。减少变量数目、缩短字段、或增加数据管理系统的容量。
- 如果要引入新的宏定义-〉增加机床数据MD 18160 $MN_MM_NUM_USER_MACROS
- 如果要引入新的GUD定义-〉检查机床数据MD 18150 $MN_MM_GUD_VALUES_MEM 、MD18130
$MN_MM_NUM_GUD_NAMES_CHAN 和MD18120 $MN_MM_NUM_GUD_NAMES_NCK 。
- 如果在执行包含LUD定义的NC程序或使用循环程序时出错（参数视作循环程序的LUD变量），请检查下列机床数据：
MD28040 $MC_MM_LUD_VALUES_MEM,
MD18242 $MN_MM_MAX_SIZE_OF_LUD_VALUE,
MD18260 $MN_MM_LUD_HASH_TABLE_SIZE,
MD28020 $MC_MM_NUM_LUD_NAMES_TOTAL,
MD28010 $MC_MM_NUM_REORG_LUD_MODULES
程序继续： 按下CYCLE START键或RESET键清除报警，继续运行程序。
报警
176 诊断手册, 01/2022, 6FC5398-6BP40-6RA6
NC 报警
12390 [通道 %1: ] 程序段 %2 %3 的初始值类型不能修改
参数： %1 = 通道号
%2 = 程序段号、 标记
%3 = 源字符串
说明： 在初始化过程中，已经对一个与变量类型不匹配也不能转换为变量数据类型的变量赋了值。
类型转化概述：
- 从 REAL 到 REAL: 否, INT: 是1), BOOL: 是, CHAR: 是2), STRING: -
- 从 INT 到 REAL: 是, INT: 否, BOOL: 是, CHAR: 是2), STRING: -
- 从 BOOL 到 REAL: 是, INT: 是, BOOL: 否, CHAR: 是, STRING: -
- 从 CHAR 到 REAL: 是, INT: 是, BOOL: 是, CHAR: 否, STRING: 是
- 从 STRING 到 REAL: -, INT: -, BOOL: 是, CHAR: 是3), STRING: 否
1) 值<> 0与真对应，值= = 0与假对应
2)串长度0 =〉假，否则为真。
3)只要一个字符。
既不能从AXIS类型和FRAME类型转换，也不能转换成AXIS类型和设计类型。
反应： 重组补偿程序段。
已设置接口信号。
报警显示。
排除方法： 按NC停机键并利用软键设计校正选择功能"校正程序块"。校正指针位置指示在差错块上。
- 定义变量类型以便可以为其赋初始值，或
- 根据变量定义选择初始值。
程序继续： 按下CYCLE START键或RESET键清除报警，继续运行程序。
12400 [通道 %1: ] 程序段 %2 %3 的元素不存在
参数： %1 = 通道号
%2 = 程序段号、 标记
%3 = 源字符串
说明： 可能有下列原因：
- 不允许的索引表;轴指数丢失
- 数组指数与变量定义不匹配。
- 试图在数组初始状态通过SET或REP访问变量;这些尝试与标准访问不匹配。单字符访问、部分框架访问、不可能省略的
指数。
初始化这些数组时访问了一个不存在的单元。
反应： 重组补偿程序段。
已设置接口信号。
报警显示。
排除方法： 按NC停止键并使用软键‘正确编程’选择功能"校正程序段"。校正指针指示在错误程序段上。
数组初始状态：检查被访问单元的数组指数。第1个数组元素得到的指数为[ 0,0]，第2个数组元素给出的指数为[ 0,1]等。
右边的数组指数(列指数)先增加。
在第2行中，第4单元也被利用指数[ 1,3] (指数起始于零)进行了访问。
数组定义：检查数组长度。第1个数显示第1维(行数)的单元数目，第2个数显示第2维(列数)中的单元数目。
2行3列的数组必须是通过设定[ 2,3]确定的。
程序继续： 按下CYCLE START键或RESET键清除报警，继续运行程序。
12410 [通道 %1: ] 程序段 %2 %3 分度类型错误
参数： %1 = 通道号
%2 = 程序段号、 标记
%3 = 源字符串
报警
诊断手册, 01/2022, 6FC5398-6BP40-6RA6 177
NC 报警
说明： 在给一个数组变量单元中赋值，数组指数是用不允许的方法设定的。
只有下列所示才允许作为数组指数(在方括号中)：
- 轴标识符，条件是数组变量被定义为FRAME数据类型。
- 所有其它数据类型的整数值。