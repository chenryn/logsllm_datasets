as the underlying algorithm for our SecureFL.
5 THE SECUREFL FRAMEWORK
In this section, we show the SecureFL framework that adapts the
proposed crypto-friendly FL protocol in Algorithm 1 to the privacy-
preserving context. At a high level, each party locally trains the
local model and normalizes its gradient before sending it to SP. At
the same time, SP trains the current global model on the seed dataset
to obtain the server gradient, and pre-processes the heavy matrix
multiplication. After receiving local gradients from all selected
parties, SP and CS engage in 2PC to securely evaluate the robust
aggregation protocol utilizing several customized cryptographic
protocols. Our complete SecureFL protocol is shown in Table 2.
5.1 The Detailed SecureFL Framework
Before formally demonstrating our framework, we introduce some
notations. We denote SP’s and CS’s shares of the normalized local
gradient as ⟨дi⟩0 and ⟨дi⟩1, respectively. The servers’ rearranged
share matrices are denoted as ⟨R⟩0 = (⟨д1⟩0, ⟨д2⟩0,· · · , ⟨дn⟩0)T
and ⟨R⟩1 = (⟨д1⟩1, ⟨д2⟩1,· · · , ⟨дn⟩1)T , respectively. Note that R =
(д1, д2,· · · , дn)T . Then, we mainly focus on the robust aggregation
Algorithm 1 Crypto-friendly byzantine-robust FL protocol
Input: Each party Pi, i ∈ [n], with a local dataset Di; SP with a
seed dataset Ds; learning rate η; batch size b; and the number
of training iterations Iter.
// Training at the party side in parallel
for i ∈ [n] do
дi = SGD(ω, Di , b). // Pi computes local gradient.
Submit дi ← дi
to SP. // Local normalization.
∥дi ∥
end for
// Training at the server side
дs = SGD(ω, Ds). // SP computes server gradient.
дs ← дs
∥дs ∥
// Robust aggregation
for i ∈ [n] do
f laдi = 1{|⟨дi , дi⟩ − 1| ](cid:2868)(cid:2189)(cid:3036)+(cid:2183)(cid:3036)[](cid:2869)[(cid:1846)(cid:1845)(cid:3036)(cid:1668)(cid:2189)(cid:3036)](cid:2868)Triplet([(cid:2183)(cid:3036)](cid:2868),[(cid:2183)(cid:3036)](cid:2868),[(cid:1855)(cid:3036)](cid:2868))Triplet([(cid:2183)(cid:3036)](cid:2869),[(cid:2183)(cid:3036)](cid:2869),[(cid:1855)(cid:3036)](cid:2869))Triplet([(cid:1856)(cid:3036)](cid:2868),[(cid:2183)(cid:3036)](cid:2868),[(cid:2188)(cid:3036)](cid:2868))[(cid:1846)(cid:1845)(cid:3036)](cid:2869),[(cid:2189)(cid:3036)](cid:2869)Triplet([(cid:1856)(cid:3036)](cid:2869),[(cid:2183)(cid:3036)](cid:2869),[(cid:2188)(cid:3036)](cid:2869))51ACSAC ’21, December 6–10, 2021, Virtual Event, USA
Meng Hao, et al.
• SP and CS run the DReLU procedure in Algorithm 2 to eval-
uate f laдi = 1{|⟨дi , дi⟩ − 1| < ϵ}. After that, SP holds
⟨f laдi⟩B
0 and CS holds ⟨f laдi⟩B
1 .
Algorithm 2 The protocol of DReLU
Input: SP and CS hold ⟨x⟩0 and ⟨x⟩1, respectively. FMill and FAND
are adopted from [40] (more details in Appendix C).
Output: SP and CS get ⟨DReLU(x)⟩0 and ⟨DReLU(x)⟩1
1: SP and CS invoke an instance of FMill, in which SP’s input is
(p − 1− ⟨x⟩0) and CS’s input is ⟨x⟩1. After that SP and CS learn