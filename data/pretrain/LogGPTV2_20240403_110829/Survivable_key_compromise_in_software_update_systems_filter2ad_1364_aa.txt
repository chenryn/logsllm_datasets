title:Survivable key compromise in software update systems
author:Justin Samuel and
Nick Mathewson and
Justin Cappos and
Roger Dingledine
Survivable Key Compromise in Software Update Systems
(cid:3)
Justin Samuel
UC Berkeley
Berkeley, California, USA
PI:EMAIL
Nick Mathewson
The Tor Project
PI:EMAIL
Justin Cappos
University of Washington
Seattle, Washington, USA
PI:EMAIL
Roger Dingledine
The Tor Project
PI:EMAIL
ABSTRACT
Today’s software update systems have little or no defense
against key compromise. As a result, key compromises have
put millions of software update clients at risk. Here we iden-
tify three classes of information whose authenticity and in-
tegrity are critical for secure software updates. Analyzing
existing software update systems with our framework, we
(cid:12)nd their ability to communicate this information securely
in the event of a key compromise to be weak or nonexistent.
We also (cid:12)nd that the security problems in current software
update systems are compounded by inadequate trust revo-
cation mechanisms. We identify core security principles that
allow software update systems to survive key compromise.
Using these ideas, we design and implement TUF, a software
update framework that increases resilience to key compro-
mise.
Categories and Subject Descriptors
K.6.5 [Management of Computing and Information
Systems]: Security and Protection; D.2.0 [Software En-
gineering]: Protection Mechanisms
General Terms
Security, Design
Keywords
Software updates, authentication, delegation, key manage-
ment, key compromise, revocation, threshold signatures
(cid:3)
Work done while at the University of Washington.
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’10, October 4–8, 2010, Chicago, Illinois, USA.
Copyright 2010 ACM 978-1-4503-0244-9/10/10 ...$10.00.
1.
INTRODUCTION
Software update systems span a wide range of uses and
designs. This includes their use as package managers [4,
59, 60], library managers [16, 20, 44, 48], and application up-
daters [34, 36]. All of these software update systems play
a critical role in computer security. They must discover,
download, verify, and apply updates when security (cid:13)aws are
discovered in installed software. Crucial to the security of
this process is that all downloaded (cid:12)les are ensured to be
authentic. Though some systems do not authenticate up-
dates [2,7,11], many do. In practice, authentication in these
systems requires cryptographic signatures. The security of
software update systems therefore relies heavily on the in-
ability of attackers to obtain private keys that are trusted
to provide updates.
Historically, software update systems have been designed
such that the compromise of a single trusted key is fatal.
With a compromised key, attackers who can respond to
client requests can cause clients to install malicious soft-
ware.
In many systems, even if the developers learn of a
key compromise, there is no secure means of key revoca-
tion. This risk is not theoretical: popular Linux distribu-
tions with tens of millions of users have su(cid:11)ered panics due
to key compromise [23, 46], weak key generation is a con-
tinuing threat [12, 28, 58], and there are many known PKI
vulnerabilities [30, 53]. Recently, attention has focused on
the possibility of government-compelled certi(cid:12)cate issuance,
a tool that governments may use to tamp down on political
dissidents [13, 52]. While that work highlighted the risk of
such attacks to secure web browsing, their threat extends
into software update systems, which commonly rely on PKI
for transport layer security as well as code signing. Having
compromised a key by any of these means, attackers can
impersonate update servers using DNS cache poisoning [19],
BGP pre(cid:12)x hijacking [42], posing as (or compromising) a
legitimate content mirror [11], or any other method of inter-
cepting client requests.
Ideally, software update systems would remain safe even
when some of their keys are under the control of an at-
tacker. This property of survivability|the ability for a
system to function correctly while under attack or partial
compromise|is important for building reliable systems. We
believe a software update system cannot remain secure if
an attacker who can respond to client requests has compro-
mised all its keys. However, with the proper understanding
of software update system vulnerabilities, we (cid:12)nd updaters
can be designed such that speci(cid:12)c attacks requiring partial
61key compromise are less likely to succeed. Additionally, the
severity of many successful attacks can be decreased.
We begin by identifying the information that software
update systems must authenticate in order to perform se-
cure updates. This information is the content of updates,
the availability (timeliness) of updates, and the consistency
of information describing updates. Unfortunately, the keys
that software update systems use to protect this information
are vulnerable to compromise in many ways. We examine
popular software update systems, all of which authenticate
some data, and (cid:12)nd no principled approach to securing this
information in the event of key compromise.
We then de(cid:12)ne a set of design principles that can improve
the resilience of software update systems to key compromise.
We have applied these principles in our design of TUF, an
open source software update framework. TUF is the next
generation of the Thandy [33] design originally developed
for secure updates of Tor [54]. The design of TUF uses re-
sponsibility separation and delegation, multi-signature trust
with threshold signatures and multiple roles, and both im-
plicit and explicit trust revocation. TUF can be integrated
with both new and existing software update systems. We
discuss our experiences integrating TUF with two dissimilar
software update systems: a traditional application updater
and Python’s library management system. Based on our
experiences, we discuss practical implications of our design
and make recommendations for key threshold sizes, meta-
data expiration times, and appropriate use of automated
signing.
Main contributions:
(cid:15) We draw attention to the danger of relying on sin-
gle signing keys and PKI1 in software update systems.
PKI is exceptionally high-risk in update systems as the
software provider does not control the trust chain. We
look at a variety of update systems and (cid:12)nd partial or
complete reliance on PKI in most of these systems.
(cid:15) We identify three fundamental classes of information
that software update systems must authenticate to en-
sure correct and timely updates. This information is
the content of updates, the availability of updates, and
the correct combination of updates.
(cid:15) We show how role separation can be used in software
update systems to reduce the impact of key compro-
mise. Central to this separation is the observation that
an individual key’s manner of use and storage a(cid:11)ects
its likelihood of compromise. We demonstrate how re-
sponsibilities can be divided between roles whose keys
have di(cid:11)erent likelihoods of compromise in order to
reduce the overall risk to clients.
(cid:15) We design and implement a software update system
that uses multiple-signature trust and role separation
without requiring SSL or other protocols that store
keys on public-facing servers.
Paper organization: A threat model is given in Sec-
tion 2. Software updates systems are described along with
their vulnerabilities and information responsibilities in Sec-
tion 3. Threats to key security are discussed in Section 4.
1We use the term PKI to refer to contemporary PKI based
on third-party CAs. Our design includes what is, in fact, a
public key infrastructure. To avoid ambiguity, we will not
refer to it as a PKI.
The security properties of current software update systems
are examined in Section 5. Design principles for securing
software update systems are identi(cid:12)ed in Section 6. We
describe the design of our framework and analyze its key
compromise survivability in Section 7. We discuss our ex-
periences and make recommendations for balancing security
with usability in Section 8. We look at related work and
conclude in Sections 9 and 10.
2. THREAT MODEL
update system’s trusted keys.
once or over a period of time.
Our threat model assumes the following:
(cid:15) Attackers can compromise at least one of a software
(cid:15) Attackers compromising multiple keys may do so at
(cid:15) Attackers can respond to client requests.
We consider the attacker as successful if they can con-
vince the updater to install (or leave installed) something
other than the most up-to-date version of the software it is
updating. If the attacker is preventing the installation of up-
dates, they want the updater to not realize there is anything
wrong.
We deem the ability for an attacker to have arbitrary (cid:12)les
signed by a key to be functionally equivalent to a key com-
promise. To a software update system, the ability to sign
arbitrary (cid:12)les is indistinguishable from possession of the key.
We assume that the internal processes used by project
administrators to manage their codebase and software are
secure. Though important for overall client security, these
processes are out-of-scope for software update systems.
3. SOFTWARE UPDATE SYSTEMS
Software update systems (cid:12)nd, download, and install the
latest versions of software. They usually begin by making
requests to servers that host the updates. The server re-
sponds with information describing available updates and
the update system then decides which updates to download
and install. Often, the servers from which updates are down-
loaded are not owned by the same organization that created
the updates. These third-party repository mirrors may be
provided by volunteers or may be owned by content delivery
networks (CDNs).
Software update systems span a range of purposes. Pack-
age managers such as YUM [60] and APT [4] are responsible
for most of the software installed on an operating system.
Library managers such as Python’s easy install [20] are com-
monly provided with programming environments to install
and update optional libraries. Application updaters are in-
cluded with individual applications such as Firefox so that
the application can update itself without needing, for ex-
ample, a package manager, or manual intervention by the
user.
3.1 Authentication
Software update systems must verify the authenticity of
(cid:12)les they receive. These (cid:12)les may be the actual software up-
dates, may describe available updates, or may provide other
information that the updater uses to make download and
trust decisions. Software update systems that authenticate
none of this information are insecure and exploiting them
has been well studied [2, 7].
62Information
Content of updates
Timeliness of updates Freeze attack
Repository state
Vulnerability
Malicious software
Metadata inconsistency
Table 1: Information responsibilities in software up-
date systems and the corresponding vulnerabilities
that exist when these responsibilities are compro-
mised.
In this work, we are not concerned with systems that o(cid:11)er
no security. Instead, we focus on systems designed for secu-
rity whose architectures are nevertheless dangerously fragile
with respect to key compromise. Among the systems that
do authenticate the information they receive, the two pri-
mary methods of authentication are transport layer security
and cryptographically signed (cid:12)les.
Many software update systems rely on transport layer se-
curity [34, 36]. These systems verify that they are retrieving
trusted (cid:12)les by using an authenticated transport protocol
(such as SSL/TLS), and verifying the public key certi(cid:12)cate
of the server from which they retrieve updates. The secu-
rity of these systems is heavily based on the security of an
underlying PKI. Trust is bootstrapped by the client having
a set of trusted root CA certi(cid:12)cates.
Other software update systems use signed data [4, 59, 60].
In these systems, clients know one or more keys that they
trust to provide updates. When (cid:12)les are downloaded, the
signatures on these (cid:12)les are checked.
A few systems use both transport layer security and signed
(cid:12)les [59, 60]. Of these, some rely on PKI-based (cid:12)le signing.
Thus means that despite the use of code signing, clients are
still vulnerable to compromise as a result of PKI problems
such as those we will discuss in Section 4.
It is common for software update systems to directly au-
thenticate only a single metadata (cid:12)le through either a sig-
nature on the (cid:12)le or transport layer security. This metadata
(cid:12)le includes cryptographic hashes of all other available meta-
data and update (cid:12)les. By comparing the hashes of the (cid:12)les
downloaded over insecure channels with those listed in the
initial signed or SSL-transferred metadata, updaters ensure
the authenticity of these other (cid:12)les. This technique is espe-
cially useful to larger projects that rely on SSL, as SSL has a
signi(cid:12)cant performance impact on servers providing updates
for many clients.
3.2 Information Responsibilities
To address key compromise in software update systems,
we must consider attacks speci(cid:12)cally aimed at them. Vari-
ous attacks on software update systems are described in [11].
Here we classify the underlying vulnerabilities and identify
the information that software update systems must authen-
ticate in order to remain secure. These information respon-
sibilities and the related vulnerabilities are listed in Table 1
and described below.
3.2.1 Content of Updates
For an attacker to compromise clients through the update
process, the easiest approach is to provide malicious soft-
ware to a client downloading updates. To protect against
installation of malicious updates, software update systems
must be able to verify that all updates are authentic.
3.2.2 Timeliness of Updates
If an attacker can prevent a software update system from
learning that updates are available, the attacker can also
prevent the installation of security updates. As a result, at-
tackers gain time to exploit known vulnerabilities in software
installed on client systems. We call this a freeze attack.
To prevent freeze attacks, clients must know when updates
are available. Though a client cannot stop an attacker from
preventing updates altogether, a client should be able to
detect when an attacker is replaying responses to the client’s
previous queries for updates. Thus, clients must be able to
authenticate information that indicates the availability of
updates.
3.2.3 Repository State
In a metadata inconsistency attack, a software update sys-
tem is tricked into using a combination of metadata and up-
date (cid:12)les that never existed together on the repository at
the same time. Depending on the design of the software
update system, the result of this attack varies. For exam-
ple, a metadata inconsistency attack may allow an insecure
version of a dependency to be installed [11].
We call the set of (cid:12)les available from a repository at a
given time the repository state. To remain secure against
metadata inconsistency attacks, software update systems
need access to authenticated information that indicates
whether any subset of downloaded (cid:12)les is from the same
repository state.
4. THREATS TO KEY SECURITY
There are many ways signing keys and transport keys can
be compromised or bypassed. Some of these categories of
risk have been considered before in the context of key com-
promise [27].
4.1 PKI Vulnerabilities
Trust based on a chain of single keys is compromised if any
key in the chain is compromised. Thus, the use of traditional
PKI for trusting a key within an update system, whether
that key is for signing (cid:12)les or for transport layer security,
is problematic. For example, a single trusted CA certi(cid:12)cate
held by a malicious party puts all clients at risk.
Recently, the risk of rogue CA certi(cid:12)cates was shown to be
more than theoretical [53]. As many clients rely on certi(cid:12)-
cates to indicate the location of a revocation server (OCSP
responders or CRLs), rogue CA certi(cid:12)cates may be di(cid:14)cult
to revoke. This risk of rogue CA certi(cid:12)cates is in addition
to the inherent danger of compromise of any CA’s private
key.
With PKI, there is also the risk that one of the certi(cid:12)cate
authorities improperly issues certi(cid:12)cates. A notable case of
a fraudulently issued certi(cid:12)cate is the issuing by VeriSign of
a certi(cid:12)cate in the name of Microsoft Corporation to an at-
tacker claiming to be a Microsoft employee [15]. Incorrectly
issued certi(cid:12)cates are also fundamental to the null pre(cid:12)x at-
tack discovered in 2009 [31]. This attack uses a certi(cid:12)cate
whose common name is formatted as the domain to imper-
sonate, followed by a null byte, followed by a domain owned
by the attacker. Many CAs would sign such a certi(cid:12)cate and
many SSL implementations would consider only the portion
of the common name before the null byte. As a result, an
63attacker could obtain a certi(cid:12)cate that would be trusted for
any domain.
Fraudulently issued certi(cid:12)cates can also be the result of
compelled certi(cid:12)cate creation. In such an attack, a govern-
ment agency compels a CA to issue a certi(cid:12)cate in order to
enable the agency to intercept secure communication [52].
Despite the risks of PKI-based authentication, many soft-
ware update systems rely solely on PKI for authenticating
updates. Examples of such systems include Firefox’s built-
in updater [22] as well as Google’s Windows and Mac up-
daters [24, 25].
4.2 Key Theft
Private keys can be stolen either by an outsider gaining
unauthorized access to a system storing the key or by an
insider with access to the key.
The more easily accessible a key is, the easier it is to steal.
In the case of transport keys, the private key will often ex-
ist unencrypted on disk and will always exist in memory
unencrypted. If the server software is compromised, a pri-