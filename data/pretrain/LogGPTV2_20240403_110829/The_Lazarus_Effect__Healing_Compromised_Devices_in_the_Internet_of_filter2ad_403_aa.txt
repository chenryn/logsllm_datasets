title:The Lazarus Effect: Healing Compromised Devices in the Internet of
Small Things
author:Manuel Huber and
Stefan Hristozov and
Simon Ott and
Vasil Sarafov and
Marcus Peinado
The Lazarus Effect: Healing Compromised Devices in the
Internet of Small Things
Manuel Huber
Fraunhofer AISEC
Garching near Munich, Germany
PI:EMAIL
Stefan Hristozov
Fraunhofer AISEC
Garching near Munich, Germany
PI:EMAIL
Simon Ott
Fraunhofer AISEC
Garching near Munich, Germany
PI:EMAIL
Vasil Sarafov
Fraunhofer AISEC
Garching near Munich, Germany
PI:EMAIL
Marcus Peinado
Microsoft Research
Redmond, United States
PI:EMAIL
ABSTRACT
We live in a time when billions of IoT devices are being deployed
and increasingly relied upon. This makes ensuring their availability
and recoverability in case of a compromise a paramount goal. The
large and rapidly growing number of deployed IoT devices make
manual recovery impractical, especially if the devices are dispersed
over a large area. Thus, there is a need for a reliable and scalable
remote recovery mechanism that works even after attackers have
taken full control over devices, possibly misusing them or trying to
render them useless.
To tackle this problem, we present Lazarus, a system that enables
the remote recovery of compromised IoT devices. With Lazarus,
an IoT administrator can remotely control the code running on
IoT devices unconditionally and within a guaranteed time bound.
This makes recovery possible even in case of severe corruption
of the devices’ software stack. We impose only minimal hardware
requirements, making Lazarus applicable even for low-end con-
strained off-the-shelf IoT devices. We isolate Lazarus’s minimal
recovery trusted computing base from untrusted software both in
time and by using a trusted execution environment. The temporal
isolation prevents secrets from being leaked through side-channels
to untrusted software. Inside the trusted execution environment,
we place minimal functionality that constrains untrusted software
at runtime.
We implement Lazarus on an ARM Cortex-M33-based micro-
controller in a full setup with an IoT hub, device provisioning and
secure update functionality. Our prototype can recover compro-
mised embedded OSs and bare-metal applications and prevents
attackers from bricking devices, for example, through flash wear
out. We show this at the example of FreeRTOS, which requires
no modifications but only a single additional task. Our evaluation
shows negligible runtime performance impact and moderate mem-
ory requirements.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
ASIA CCS ’20, October 5–9, 2020, Taipei, Taiwan
© 2020 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-6750-9/20/10...$15.00
https://doi.org/10.1145/3320269.3384723
CCS CONCEPTS
• Security and privacy→ Embedded systems security; Trusted
computing.
KEYWORDS
trusted computing; cyber resilience; recovery; availability
ACM Reference Format:
Manuel Huber, Stefan Hristozov, Simon Ott, Vasil Sarafov, and Marcus
Peinado. 2020. The Lazarus Effect: Healing Compromised Devices in the
Internet of Small Things. In Proceedings of the 15th ACM Asia Conference on
Computer and Communications Security (ASIA CCS ’20), October 5–9, 2020,
Taipei, Taiwan. ACM, New York, NY, USA, 14 pages. https://doi.org/10.1145/
3320269.3384723
1 INTRODUCTION
With the Internet of Things (IoT) becoming increasingly pervasive
and a focal topic in computing, more and more IoT devices are rolled
out. Driven by cost savings and short product development cycles,
a vast number of IoT business use cases have emerged, making
IoT a disruptive technology. Examples are home automation [12],
farming [42], sensor networks [37], Car2X [9], industrial IoT [48], or
smart devices like tools [18], traffic lights [25] or vending machines
[8], to name only a few. These devices are typically connected
via (wireless) networks to a hub, a back-end server located in the
cloud or managed by an enterprise. The growing importance of
IoT deployments for public safety and business processes makes
them an attractive target for attackers. This has been demonstrated
by a large number of attacks [10, 29], such as the Mirai [30] or the
Hajime botnet [44].
An important property of the IoT domain is that many devices
with identical software stacks and configurations can likely be
found in the field. This makes identified vulnerabilities or mis-
configurations highly scalable, allowing attackers to potentially
compromise a large number of devices. Especially small and cheap
devices, oftentimes poorly secured, can be found in large num-
bers [17]. Even more alarming is the threat of attackers making
such devices refuse communication and updates from the hub or
permanently damaging them. In consequence, devices have to be
manually recovered by replacing them or resetting them with clean
software. As billions of devices (managed by a much smaller number
Session 1: IoT Security and Privacy ASIA CCS '20, October 5–9, 2020, Taipei, Taiwan6of administrators) are deployed (often geographically dispersed),
manual recovery becomes completely impractical.
As a solution to this problem, several cyber-resilient IoT archi-
tectures have been proposed [5, 52, 54]. These architectures enable
remote recovery of infected IoT devices within a time bound re-
gardless of compromise. State-of-the-art architectures [5, 52, 54]
employ a minimal, early-boot recovery Trusted Computing Base
(TCB) and a reset trigger that preempts compromised software. The
recovery TCB ensures that only software authorized by the hub
runs on the device. If no such software is present, the recovery TCB
downloads the software from the hub and replaces the existing
outdated or compromised stack. The reset trigger ensures that a
reset into the recovery TCB will eventually happen even if software
actively refuses the reset. Both the recovery TCB and reset trigger
are isolated from untrusted software at runtime. This prevents mal-
ware from modifying the recovery TCB and from interfering with
the reset trigger. An example of a reset trigger is the Authenticated
Watchdog Timer (AWDT) [54]. After having been initialized, the
AWDT will force a device reset after a certain time period, unless it
is serviced with cryptographically protected “tickets”. These tickets
cannot be forged by software on the device but only be issued by
the hub. As a consequence, as soon as the hub stops issuing tickets,
e.g., when a zero-day vulnerability becomes known, or when the
device behaves suspiciously, the AWDT will eventually time out
and trigger a reset. A similar timer called “latchable WDT” [52]
will power cycle a device within a specified time interval after its
activation.
With resilient IoT architectures, we envision a world of self-
healing IoT deployments where all IoT devices can be reliably re-
covered even if they are compromised. However, existing cyber-
resilient IoT architectures which target primarily higher-end IoT
devices do not address several critical real-world problems which
must be solved to fulfill this vision even for low-cost microcon-
trollers. This includes
1) Hardware requirements. Current designs require hardware
that typically does not exist or would incur additional cost on
weaker, low-cost Commercial Off-The-Shelf (COTS) devices such
as Microcontroller Units (MCUs). Examples are “storage latches”
to write-protect the recovery TCB from untrusted software, or the
AWDT peripheral that was realized previously as a separate MCU
and attached to the main board [54]. For small MCU-based IoT
devices, this makes the AWDT a feature as complex as the class of
devices it is intended to protect. For storage latches, CIDER [54]
relied on eMMC memory chips which are relatively complex and
expensive and typically not available on small MCU-based devices.
2) Preventing attackers from disabling devices. Existing
work neglects attacks in which the adversary tries to make a device
unavailable. Examples include entering low-power or off states in
which the reset trigger becomes inactive, wearing out flash mem-
ory [46], or disabling the networking hardware which is needed to
replace corrupted software on the device.
3) Updates of the recovery TCB. After devices have been de-
ployed, vulnerabilities in the recovery TCB itself may be discovered,
or cryptographic requirements may change. It is essential to patch
such vulnerabilities in a timely manner before they can be exploited
by attackers.
This paper presents the Lazarus system, a cyber-resilient IoT
architecture that solves these three problems. Lazarus targets low-
cost COTS MCUs. We take advantage of the recent addition of a
general-purpose Trusted Execution Environment (TEE) to low-end
ARM MCUs in the ARMv8-M architecture. As the ARMv8-M re-
places earlier models, we expect TEEs to become widely available in
low-end MCUs in the coming years. A key observation in the design
of Lazarus is that the security hardware required by cyber-resilient
architectures can be emulated by software running inside a TEE.
Furthermore, the TEE can mediate access by untrusted software to
critical system state.
In particular, we implement storage write protection latches
and the AWDT in software running in the TEE. We call our reset
trigger “TEETrigger.” With this design, we enable the AWDT to be
realized on existing COTS devices and do not make assumptions on
trusted peripherals for storage latches and reset triggers. Our design
prevents attackers from making devices permanently unavailable
by interposing between untrusted software and peripherals that
are critical for availability. We call these “critical peripherals” and
use the TEE to regulate or block access by untrusted software,
preventing their misuse. Finally, existing IoT architectures use the
Device Identifier Composition Engine (DICE) for authentication
and attestation to verify whether authorized software is present
on the device. This enables the hub to authenticate the deployed
software stack. However, as the hash of the boot code is part of the
DICE attestation identity, an update of the recovery TCB will give
the device a new DICE identity that the hub cannot predict. This
makes it impossible for the hub to recognize device identities after
a TCB update and to verify if an update was actually installed or
not. To overcome this problem, we propose an extension to DICE,
which we call DICE++. Our extension enables devices to provide
proof that a designated update was applied and sustains a device’s
identity across updates of the recovery TCB.
We demonstrate the effectiveness of Lazarus on low-end devices
by implementing a prototype on an existing COTS low-end MCU
based on the new ARMv8-M processor family. We make use of the
isolation capabilities of TrustZone-M to isolate the recovery TCB
from untrusted software and to build an AWDT without requiring
additional hardware. We make the following contributions:
• We design Lazarus, a resilient IoT architecture for off-the-
shelf IoT devices. The design of Lazarus respects even the
weakest class of IoT devices and protects against attackers
actively aiming to render devices useless. With TEETrigger,
Lazarus includes a zero-cost reset trigger, the first of its kind.
Our design relies on a TEE which is provided by modern
processors.
• We design DICE++ which enables updates of the recovery
TCB without loss of device identity.
• We implement a prototype on Lazarus on a recent ARM
Cortex-M33 based MCU, the NXP LPC5500 [33]. We leverage
the new TrustZone-M extension for ARM Cortex-M CPUs
and ensure portability across different ARMv8-M devices.
Our implementation includes a full setup featuring an IoT
hub, device provisioning and update functionality.
• We demonstrate how to protect an embedded OS, FreeRTOS
[39], with our prototype. The OS modifications are limited
Session 1: IoT Security and Privacy ASIA CCS '20, October 5–9, 2020, Taipei, Taiwan7to adding a single supplementary task for extending TEE-
Trigger in coordination with the hub.
• We provide a security discussion and an evaluation of the
runtime and boot time performance impact as well as of the
memory requirements, showing the practicability of Lazarus.
2 BACKGROUND
This section provides background for the rest of the paper.
2.1 Latches
The code and data of Lazarus on storage requires protection while
untrusted software executes. Latches [54] can be used to protect
critical code and data from being overwritten or read out by un-
trusted software. Conceptually, a latch is a state machine with two
states, open and locked. A reset puts the latch into the open state.
Software can put the latch into the locked state (e.g., by writing to
a hardware register). Importantly, the only action or event that can
return the latch to the open state is a reset. A latch has an associated
security function which allows some action (e.g., writing to certain
flash regions) if and only if the latch is in the open state.
Latches allow trusted boot software that runs directly after a
reset to have full access to all hardware resources but to selec-
tively disable access to some of these resources to (less trusted)
software running subsequently on the device. A read-write latch
(RWLatch) can be used to protect secrets, for instance, and a write
latch (WRLatch) to protect the integrity of data.
2.2 DICE
DICE [49, 50] is an industry standard designed to enable attestation
on low-end devices with only minimal hardware support. DICE has
been adopted by major MCU manufacturers such as NXP [34] or
Microchip [26] and cloud providers [38]. DICE is significantly more
light-weight than alternatives such as the TPM [45]. A DICE device
has a unique secret, the Unique Device Secret (UDS) that is protected
by a latch. After a reset, DICE measures the first mutable software
component M (e.g., a boot loader) and uses a one-way function to
derive a symmetric key, called Compound Device Identifier (CDI),
from this measurement and the UDS. Next, DICE makes the UDS
inaccessible until the next reset, discloses the CDI to M and invokes
M. This provides M with an identity that is unique to both M and
the device and that forms the foundation for DICE attestation.
Critically, the DICE standard prescribes that the computation of
the CDI must not be performed by mutable software, i.e., by soft-
ware that can be modified or updated. While a device manufacturer
may choose to implement the computation of the CDI in software,
this software is fixed (e.g., burned into ROM) and not under the
control of the device owner. This fact together with the method by
which the CDI is derived implies that (a) any modification of M
will result in a different CDI and (b) the new CDI is unpredictable,
as the UDS is only known to the device’s DICE component, and the
CDI is derived from the UDS via a one-way function.
DICE can be leveraged for lightweight device attestation, for
instance for IoT devices connecting to a hub [51]. M (or code M
trusts) uses the CDI to derive two asymmetric key pairs, called the
DeviceID and the AliasID, and uses the DeviceID private key to
sign the AliasID certificate. Then, M removes all remnants of the
CDI and the DeviceID private key and provides untrusted software
only with the AliasID key pair and the certificates. This results in
a cryptographic chain from the UDS and the CDI to the DeviceID
and the AliasID based on the state of a device’s software stack.
Untrusted software can use the AliasID as a device identifier for
authentication and attestation.
2.3 MCU Model
Microcontroller units typically combine one or two low-end micro-
processor cores with moderate amounts of RAM and flash memory
and various simple devices such as watchdog timers and security
features such as DICE. With the introduction of ARMv8-M and
TrustZone for Cortex-M, TEEs are rapidly becoming prevalent even
in the low-end MCU market.
This paper is based on an MCU model whose processor(s) sup-
port two privilege levels (privileged and unprivileged) which are
comparable to user and kernel mode and which allow a simple
“operating system kernel” to protect itself from applications. In ad-
dition, our MCU model supports DICE and, more importantly, a
TEE. The assumed DICE support is not critical because, as we will
show, Lazarus can implement DICE in software.
Our model of a TEE is based on TrustZone for Cortex-M, the de