Type compatibility
You may wonder why the cstring and cint types need to be used in the printf proce-
dure. Why can’t you use string and int? Let’s try it and see what happens.
 Modify your ffi.nim file so that the printf procedure returns an int type and takes
a string type as the first argument. Then, recompile and run the program.
 The program will likely show no output. This underlines the unfortunate danger
that comes with using the FFI. In this case, the procedure call does nothing, or at least
it appears that way. In other cases, your program may crash. The compiler trusts you
to specify the types correctly, because it has no way of inferring them.
 Because the cstring type was changed to the string type, your program now
passes a Nim string object to the C printf procedure. C expects to receive a const
char* type, and it always assumes that it receives one. Receiving the wrong type can
lead to all sorts of issues, one of the major ones being memory corruption.
 Nim’s string type isn’t as simple as C’s, but it is similar. A Nim string is an object
that contains two fields: the length of the string and a pointer to an array of chars.
This is why a Nim string can be easily converted to a const char*. In fact, because this
conversion is so easy, it’s done implicitly for you, which is why, even when you pass a
string to printf, which expects a cstring, the example compiles.
CONVERSION FROM CSTRING TO STRING
A conversion in the other direction,
from a cstring to a string, is not implicit because it has some overhead.
That’s why you must do it explicitly using a type conversion or the $ operator.
As for the cint type, it’s very similar to the int type. As you’ll see in the Nim docu-
mentation, it’s actually just an alias for int32: http://nim-lang.org/docs/system
.html#cint. The difference between the int type and the int32 type is that the for-
mer’s bit width depends on the current architecture, whereas the bit width of the lat-
ter type is always 32 bits.
 The system module defines many more compatibility types, many of which are
inspired by C. But there will come a time when you need to import types defined in C
as well. The next section will show you how that can be done. 
8.1.4
Wrapping C types
The vast majority of the work involved in interfacing with C libraries involves wrap-
ping procedures. Second to that is wrapping types, which we’ll look at now.
 In the previous section, I showed you how to wrap the printf procedure. In this sec-
tion, you’ll see how to wrap the time and localtime procedures, which allow you to
retrieve the current system time in seconds and to convert that time into calendar time,
respectively. These procedures return two custom types that need to be wrapped first.
 Let’s start by looking at the time procedure, which returns the number of seconds
since the UNIX epoch (Thursday, 1 January 1970). You can look up its prototype
online. For example, C++ Reference (http://en.cppreference.com/w/c/chrono/time)
specifies that its prototype looks like this:
time_t time( time_t *arg );
Licensed to   
232
CHAPTER 8
Interfacing with other languages
Further research into the type of time_t indicates that it’s a signed integer.1 That’s all
you need to know in order to declare this procedure in Nim. The following listing
shows this declaration.
type
CTime = int64
proc time(arg: ptr CTime): CTime {.importc, header: "".}
In this case, you wrap the time_t type yourself. The procedure declaration has an
interesting new characteristic. It uses the ptr keyword to emulate the time_t * type,
which is a pointer to a time_t type.
 To convert the result of time into the current hour and minute, you’ll need to wrap
the localtime procedure and call it. Again, the specification of the prototype is available
online. The C++ Reference (http://en.cppreference.com/w/c/chrono/localtime)
specifies that the prototype looks like this:
struct tm *localtime( const time_t *time );
The localtime procedure takes a pointer to a time_t value and returns a pointer to a
struct tm value. A struct in Nim is equivalent to an object. Unfortunately, there’s
no way to tell from the return type alone whether the struct that the localtime
returns has been allocated on the stack or on the heap.
 Whenever a C procedure returns a pointer to a data structure, it’s important to
investigate whether that pointer needs to be manually deallocated by your code. The
documentation for this procedure states that the return value is a “pointer to a static
internal tm object.” This means that the object has a static storage duration and so
doesn’t need to be deallocated manually. Every good library will state the storage
duration of an object in its documentation.
 When wrapping code, you’ll undoubtedly run into a procedure that returns an
object with a dynamic storage duration. In that case, the procedure will allocate a new
object every time it’s called, and it’s your job to deallocate it when you no longer need it.
DEALLOCATING C OBJECTS
The way in which objects created by a C library can
be deallocated depends entirely on the C library. A free function will usually
be offered for this purpose, and all you’ll need to do is wrap it and call it.
The struct tm type is much more complex than the time_t type. The documentation
available in the C++ Reference (http://en.cppreference.com/w/c/chrono/tm) shows
1 The type of time_t is described in this Stack Overflow answer: http://stackoverflow.com/a/471287/492186.
Listing 8.1
Wrapping time
The CTime type is the wrapped version 
of time_t, defined as a simple alias for 
a 64-bit signed integer.
The time C procedure is defined in the
 header file. To import it,
the header pragma is necessary.
Licensed to   
233
Nim’s foreign function interface
that it contains nine integer fields. The definition of this type in C would look some-
thing like this:
struct tm {
int tm_sec;
int tm_min;
int tm_hour;
int tm_mday;
int tm_mon;
int tm_year;
int tm_wday;
int tm_yday;
int tm_isdst;
};
Wrapping this type is fairly simple, although a bit mundane. Fortunately, you don’t
have to wrap the full type unless you need to access all the fields. For now, let’s just
wrap the tm_min and tm_hour fields. The following listing shows how you can wrap the
tm type together with the two fields.
type
TM {.importc: "struct tm", header: "".} = object
tm_min: cint
tm_hour: cint
You can then wrap the localtime procedure and use it together with the time proce-
dure as follows.
type
CTime = int64
proc time(arg: ptr CTime): CTime {.importc, header: "".}
type
TM {.importc: "struct tm", header: "".} = object
tm_min: cint
tm_hour: cint
proc localtime(time: ptr CTime): ptr TM {.importc, header: "".}
var seconds = time(nil)
let tm = localtime(addr seconds)
echo(tm.tm_hour, ":", tm.tm_min)
Listing 8.2
Wrapping struct tm
Listing 8.3
A complete time and localtime wrapper
The struct keyword can’t be omitted 
in the argument to the pragma.
The two fields are defined as they 
would be for any Nim data type. The 
cint type is used because it’s 
compatible with C.
The localtime procedure takes a "time_t *" and returns a "struct tm *", 
both of which are pointers. That is why the ptr keyword is used.
Assigns the result of the time call to a new seconds variable. The 
time procedure can also optionally store the return value in the 
specified argument; nil is passed here, as it’s not needed.
Passes the address of 
the seconds variable to 
the localtime procedure
Displays the current time
Licensed to   
234
CHAPTER 8
Interfacing with other languages
Save this code as ffi2.nim, and then compile and run it. You should see the current
time displayed on your screen after execution, such as 18:57.
 The main takeaway from the example in listing 8.3 is that wrapping a type essen-
tially involves copying its structure into a Nim type definition. It’s important to
remember that the field names have to match those of the C type. You can specify the
name of each field in an importc pragma if you wish to rename them. Figure 8.4
demonstrates this.
Another interesting aspect of wrapping the localtime procedure is the need to pass a
pointer to it. You need to account for this in your wrapper. The addr keyword returns
a pointer to the value specified, and that value must be mutable, which is why the
return value of time is assigned to a new seconds variable in listing 8.3. Writing
localtime(addr time(nil)) wouldn’t work because the return value isn’t stored any-
where permanent yet.
 You should now have a pretty good idea of how C types can be wrapped in Nim. It’s
time to wrap something a little more ambitious: an external library. 
8.2
Wrapping an external C library
So far, I’ve shown you how to wrap some very simple procedures that are part of the C
standard library. Most of these procedures have already been wrapped to some extent
by the Nim standard library and are exposed via modules such as times.
 Wrapping an external library is slightly different. In this section you’ll learn about
these differences as you wrap a small bit of the SDL library.
 Simple DirectMedia Layer, or SDL, is a cross-platform multimedia library. It’s one
of the most widely used libraries for writing computer games and other multimedia
applications. SDL manages video, audio, input devices, and much more. Some practi-
cal things that you can use it for are drawing 2D graphics on the screen or playing
sound effects.
 I’ll show you how to draw 2D graphics. By the end of this section, you’ll produce an
application that displays the window shown in figure 8.5.
SDL WRAPPER
The wrapper shown here will be very basic. You’ll find a full
SDL wrapper that’s already been created by the Nim community here:
https://github.com/nim-lang/sdl2.
tm_min: cint
type
TM {.importc: "struct tm", ...} = object
}
struct tm {
int tm_min,
int tm_hour,
...
min: cint
min {.importc: "tm_min".}: cint
Nim
C
Figure 8.4
The mapping between fields in a wrapped type and a C struct
Licensed to   
235
Wrapping an external C library
8.2.1
Downloading the library
Before you begin writing the wrapper for the SDL library, you should download it. For
this chapter’s example, you’ll only need SDL’s runtime binaries, which you can down-
load here: www.libsdl.org/download-2.0.php#source. 
8.2.2
Creating a wrapper for the SDL library
A library, or package, wrapper consists of one or more modules that contain wrapped
procedures and type definitions. The wrapper modules typically mirror the contents
of C header files, which contain multiple declarations of procedure prototypes and
types. But they may also mirror other things, such as the contents of JavaScript API ref-
erence documentation.
 For large libraries like SDL, these header files are very large, containing thousands
of procedure prototypes and hundreds of types. The good news is that you don’t need
to wrap it all completely in order to use the library. A couple of procedures and types
will do. This means you can wrap libraries on demand instead of spending days wrap-
ping the full library, including procedures that you’re never going to use. You can just
wrap the procedures that you need.
AUTOMATIC WRAPPING
An alternative means of wrapping libraries is to use a
tool such as c2nim. This tool takes a C or C++ header file as input and con-
verts it into a wrapper. For more information about c2nim, take a look at its
documentation: http://nim-lang.org/docs/c2nim.html.
Figure 8.5
The application you’ll produce in this section
Licensed to   
236
CHAPTER 8
Interfacing with other languages
As in the previous section, you can go online to look up the definition of the proce-
dure prototypes that you’re wrapping. Be sure to consult the project’s official docu-
mentation and ensure that it has been written for the version of the library that you’re
using. Alternatively, you can look up the desired procedure or type inside the library’s
header files.
 First, though, you need to figure out what needs to be wrapped. The easiest way to
figure that out is to look for examples in C, showing how the library in question can
be used to develop a program that performs your desired actions. In this section, your
objective is to create an application that shows a window of a specified color with the
letter N drawn in the middle, as shown in figure 8.5.
 The SDL library can do a lot more than this, but in the interest of showing you how
to wrap it, we’ll focus on this simple example.
 With that in mind, let’s start. The wrapper itself will be a single module called sdl.
Before moving on to the next section, create this module by creating a new file called
sdl.nim. 
8.2.3
Dynamic linking
Earlier in this chapter, I explained the differences between static and dynamic linking.
The procedures you wrapped in the previous section are part of the C standard
library, and as such, the linking process was automatically chosen for you. The process
by which the C standard library is linked depends on your OS and C compiler.
 When it comes to linking with external C libraries, dynamic linking is recom-
mended. This process involves some trivial initial setup that we’ll look at now.
 Whenever you instruct the Nim compiler to dynamically link with a C library, you
must supply it with the filename of that library. The filenames depend entirely on the
library and the OS that the library has been built for. Table 8.2 shows the filenames of
the SDL libraries for Windows, Linux, and Mac OS.
These files are called shared library files because in many cases, especially on UNIX-like
OSs, they’re shared among multiple applications.
 The SDL wrapper needs to know these filenames, so let’s define them in the sdl
module you just created. The following listing shows how to define these for each OS.
Add this code to your sdl module.
when defined(Windows):
const libName* = "SDL2.dll"
elif defined(Linux):
Table 8.2
The filenames of the SDL library
Windows
Linux
Mac OS
SDL2.dll
libSDL2.so
libSDL2.dylib
Listing 8.4
Defining the shared library filename conditionally
Licensed to   
237
Wrapping an external C library
const libName* = "libSDL2.so"
elif defined(MacOsX):
const libName* = "libSDL2.dylib"
This code is fairly simple. Only one constant, libName, is defined. Its name remains
the same, but its value changes depending on the OS. This allows the wrapper to work
on the three major OSs.
 That’s all the setup that’s required. Strictly speaking, it’s not absolutely necessary
to create these constants, but they will enable you to easily change these filenames at a
later time.
 Now, recall the previous section, where I showed you the header and importc prag-
mas. These were used to import C procedures from a specific header in the C standard
library. In order to instruct the compiler to dynamically link a procedure, you need to
use a new pragma called dynlib to import C procedures from a shared library:
proc init*(flags: uint32): cint {.importc: "SDL_Init", dynlib: libName.}
The dynlib pragma takes one argument: the filename of the shared library where the
imported procedure is defined. Every time your application starts, it will load a shared
library for each unique filename specified by this pragma. If it can’t find the shared
library, or the wrapped procedure doesn’t exist in the shared library, the application
will display an error and terminate.
 The dynlib pragma also supports a simple versioning scheme. For example, if
you’d like to load either libSDL2-2.0.1.so or libSDL2.so, you can specify
"libSDL2(|-2.0.1).so" as the argument to dynlib. More information about the
dynlib pragma is available in the Nim manual: http://nim-lang.org/docs/manual
.html#foreign-function-interface-dynlib-pragma-for-import.
 Now, you’re ready to start wrapping. 
8.2.4
Wrapping the types
Before you can successfully wrap the required procedures, you first need to define four
types. Thankfully, wrapping their internals isn’t necessary. The types will simply act as
stubs to identify some objects. The following listing shows how to define these types.
type
SdlWindow = object
SdlWindowPtr* = ptr SdlWindow
SdlRenderer = object
SdlRendererPtr* = ptr SdlRenderer
Listing 8.5
Wrapping the four necessary types
Defines an object stub. This object likely contains 
fields, but you don’t need to access them in your 
application, so you can omit their definitions.
Many of the procedures in the SDL library work 
on pointers to objects, so it’s convenient to 
give this type a name and export it instead of 
writing “ptr TheType” everywhere.
Licensed to   
238
CHAPTER 8
Interfacing with other languages
The type definitions are fairly simple. The SdlWindow type will represent a single on-
screen SDL window, and the SdlRenderer will represent an object used for rendering
onto the SDL window.
 The pointer types are defined for convenience. They’re exported because the SDL
procedures that you’ll wrap soon return them.
 Let’s look at these procedures now. 
8.2.5
Wrapping the procedures
Only a handful of procedures need to be wrapped in order to show a colored window
on the screen using SDL. The following listing shows the C prototypes that define
those procedures.
int SDL_Init(Uint32 flags)
int SDL_CreateWindowAndRenderer(int
width,
int
height,
Uint32
window_flags,
SDL_Window**
window,
SDL_Renderer** renderer)
int SDL_PollEvent(SDL_Event* event)
int SDL_SetRenderDrawColor(SDL_Renderer* renderer,
Uint8
r,
Uint8
g,
Uint8
b,
Uint8
a)
void SDL_RenderPresent(SDL_Renderer* renderer)
int SDL_RenderClear(SDL_Renderer* renderer)
int SDL_RenderDrawLines(SDL_Renderer*
renderer,
const SDL_Point* points,
int
count)
You’ve already seen how to wrap the SDL_Init procedure:
proc init*(flags: uint32): cint {.importc: "SDL_Init", dynlib: libName.}
The wrapper for this procedure is fairly straightforward. The Uint32 and int types in
the prototype map to the uint32 and cint Nim types, respectively. Notice how the
procedure was renamed to init; this was done because the SDL_ prefixes are redun-
dant in Nim.
 Now consider the rest of the procedures. Each wrapped procedure will need to
specify the same dynlib pragma, but you can remove this repetition with another
pragma called the push pragma. The push pragma allows you to apply a specified
pragma to the procedures defined below it, until a corresponding pop pragma is used.
Listing 8.6
The SDL C prototypes that will be wrapped in this section
Initializes the SDL library
Creates an SDL 
window and 
rendering context 
associated with 
that window
Checks for input events
Sets the current draw color 
on the specified renderer
Updates the screen with any 
rendering that was performed
Clears the specified renderer 
with the drawing color
Draws a series of 
connected lines
Licensed to   
239
Wrapping an external C library
The following listing shows how the rest of the procedures can be wrapped with the
help of the push pragma.
{.push dynlib: libName.}
proc init*(flags: uint32): cint {.importc: "SDL_Init".}
proc createWindowAndRenderer*(width, height: cint, window_flags: cuint,
window: var SdlWindowPtr, renderer: var SdlRendererPtr): cint
{.importc: "SDL_CreateWindowAndRenderer".}
proc pollEvent*(event: pointer): cint {.importc: "SDL_PollEvent".}
proc setDrawColor*(renderer: SdlRendererPtr, r, g, b, a: uint8): cint
{.importc: "SDL_SetRenderDrawColor", discardable.}
proc present*(renderer: SdlRendererPtr) {.importc: "SDL_RenderPresent".}
proc clear*(renderer: SdlRendererPtr) {.importc: "SDL_RenderClear".}
proc drawLines*(renderer: SdlRendererPtr, points: ptr tuple[x, y: cint],
count: cint): cint {.importc: "SDL_RenderDrawLines", discardable.}
{.pop.}
Most of the code here is fairly standard. The createWindowAndRenderer procedure’s
arguments include one pointer to a pointer to an SdlWindow and another pointer to a
pointer to an SdlRenderer, written as SdlWindow** and SdlRenderer**, respectively.
Pointers to SdlWindow and SdlRenderer were already defined in the previous subsec-
tion under the names SdlWindowPtr and SdlRendererPtr, respectively, so you can
define the types of those arguments as ptr SdlWindowPtr and ptr SdlRendererPtr.
This will work well, but using var in place of ptr is also appropriate in this case.
 You may recall var T being used in chapter 6, where it stored a result in a variable
that was passed as a parameter to a procedure. The exact same thing is being done by
the createWindowAndRenderer procedure. Nim implements these var parameters
using pointers, so defining that argument’s type using var is perfectly valid. The
advantage of doing so is that you no longer need to use addr, and Nim also prevents
you from passing nil for that argument.
 For the pollEvent procedure, the argument type was defined as pointer. This type
is equivalent to a void* type in C, essentially a pointer to any type. This was done
because it avoids the need to wrap the SdlEvent type. You may run into C libraries that
declare procedures accepting a void* type, in which case you can use the pointer
Listing 8.7
Wrapping the procedures in the sdl module
This ensures that each proc 
gets the dynlib pragma.
The var keyword is used in place of a ptr. In Nim,
these end up generating equivalent C code.
The pointer type in Nim is equivalent to
a void *, which is a pointer of any type.