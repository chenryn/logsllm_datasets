## 我心目中好的架构是什么样的？现在，我们已经可以从代码内外来分析 App开发的架构设计了，但也只是会分析了而已，脑海中并没有明确好的架构是什么样的，也不知道具体应该怎么设计。接下来，我们就带着这两个问题继续看下面的内容。组件化是解决项目大、人员多的一种很好的手段，这在任何公司或团队都是没有歧义的。组件间关系协调却没有固定的标准，协调的优劣，成为了衡量架构优劣的一个基本标准。所以在实践中，一般分为了**协议式和中间者两种架构**设计方案。**协议式架构设计主要采用的是协议式编程的思路**：在编译层面使用协议定义规范，实现可在不同地方，从而达到分布管理和维护组件的目的。这种方式也遵循了依赖反转原则，是一种很好的面向对象编程的实践。但是，这个方案的缺点也很明显，主要体现在以下两个方面：1.  由于协议式编程缺少统一调度层，导致难于集中管理，特别是项目规模变大、团队变多的情况下，架构管控就会显得越来越重要。2.  协议式编程接口定义模式过于规范，从而使得架构的灵活性不够高。当需要引入一个新的设计模式来开发时，我们就会发现很难融入到当前架构中，缺乏架构的统一性。虽然协议式架构有这两方面的局限性，但由于其简单易用的特点依然被很多公司采用。**另一种常用的架构形式是中间者架构。它采用中间者统一管理的方式，来控制App 的整个生命周期中组件间的调用关系。**同时，iOS对于组件接口的设计也需要保持一致性，方便中间者统一调用。中间者架构如下图所示：![](Images/a965309b40124d7f7d734e38021eca25.png){savepage-src="https://static001.geekbang.org/resource/image/40/69/40a625a0f556aa264eee9fbb212b3469.png"}```{=html}```图 1 中间者架构示意图]{.reference}```{=html}```可以看到，拆分的组件都会依赖于中间者，但是组间之间就不存在相互依赖的关系了。由于其他组件都会依赖于这个中间者，相互间的通信都会通过中间者统一调度，所以组件间的通信也就更容易管理了。在中间者上也能够轻松添加新的设计模式，从而使得架构更容易扩展。在我看来，好的架构一定是健壮的、灵活的。中间者架构的易管控带来的架构更稳固，易扩展带来的灵活性，所以我认为中间者这种架构设计模式是非常值得推荐的。casatwy以前设计了一个 CTMediator就是按照中间者架构思路设计的。你可以在[GitHub](https://github.com/casatwy/CTMediator)上看到它的内容。CTMediator 使用的是运行时解耦，接下来我就通过开源的 CTMediator代码，和你分享下如何使用运行时技术来解耦。解耦核心方法如下所示：    - (id)performTarget:(NSString *)targetName action:(NSString *)actionName params:(NSDictionary *)params shouldCacheTarget:(BOOL)shouldCacheTarget{    NSString *swiftModuleName = params[kCTMediatorParamsKeySwiftTargetModuleName];        // generate target    NSString *targetClassString = nil;    if (swiftModuleName.length > 0) {        targetClassString = [NSString stringWithFormat:@"%@.Target_%@", swiftModuleName, targetName];    } else {        targetClassString = [NSString stringWithFormat:@"Target_%@", targetName];    }    NSObject *target = self.cachedTarget[targetClassString];    if (target == nil) {        Class targetClass = NSClassFromString(targetClassString);        target = [[targetClass alloc] init];    }      // generate action    NSString *actionString = [NSString stringWithFormat:@"Action_%@:", actionName];    SEL action = NSSelectorFromString(actionString);        if (target == nil) {        // 这里是处理无响应请求的地方之一，这个 demo 做得比较简单，如果没有可以响应的 target，就直接 return 了。实际开发过程中是可以事先给一个固定的 target 专门用于在这个时候顶上，然后处理这种请求的        [self NoTargetActionResponseWithTargetString:targetClassString selectorString:actionString originParams:params];        return nil;    }        if (shouldCacheTarget) {        self.cachedTarget[targetClassString] = target;    }      if ([target respondsToSelector:action]) {        return [self safePerformAction:action target:target params:params];    } else {        // 这里是处理无响应请求的地方，如果无响应，则尝试调用对应 target 的 notFound 方法统一处理        SEL action = NSSelectorFromString(@"notFound:");        if ([target respondsToSelector:action]) {            return [self safePerformAction:action target:target params:params];        } else {            // 这里也是处理无响应请求的地方，在 notFound 都没有的时候，这个 demo 是直接 return 了。实际开发过程中，可以用前面提到的固定的 target 顶上的。            [self NoTargetActionResponseWithTargetString:targetClassString selectorString:actionString originParams:params];            [self.cachedTarget removeObjectForKey:targetClassString];            return nil;        }    }performTarget:action:params:shouldCacheTarget: 方法主要是对 targetName和 actionName 进行容错处理，也就是对调用方法无响应的处理。这个方法封装了safePerformAction:target:params 方法，入参 targetName就是调用接口的对象，actionName 是调用的方法名，params 是参数。从代码中同时还能看出只有满足 Target\_ 前缀的对象和 Action 的方法才能被CTMediator使用。这时，我们可以看出中间者架构的优势，也就是利于统一管理，可以轻松管控制定的规则。下面这段代码，是使用 CTMediator 如何调用一个弹窗显示方法的代码示范：    [self performTarget:kCTMediatorTargetA                 action:kCTMediatorActionShowAlert                 params:paramsToSend      shouldCacheTarget:NO];可以看出，指定了对象名和调用方法名，把参数封装成字典传进去就能够直接调用该方法了。但是，这种运行时直接硬编码的调用方式也有些缺点，主要表现在两个方面：1.  直接硬编码的调用方式，参数是以 string    的方法保存在内存里，虽然和将参数保存在 Text    字段里占用的内存差不多，同时还可以避免.h    文件的耦合，但是其对代码编写效率的降低也比较明显。2.  由于是在运行时才确定的调用方法，调用方式由 \[obj method\] 变成 \[obj    performSelector:@\"\"\]。这样的话，在调用时就缺少类型检查，是个很大的缺憾。因为，如果方法和参数比较多的时候，代码编写效率就会比较低。这篇文章发出后 CTMediator 的作者 casatwy 找到了我，指出文章中提到的CTMediator 的硬编码和字典传参这两个缺点，实际上已经被完美解决了。下面是casatwy 的原话，希望可以对你有所帮助。> CTMediator 本质就是一个方法，用来接收 target、action、params。由于> target、action 都是字符串，params> 是字典，对于调用者来说十分不友好，因为调用者要写字符串，而且调用的时候若是不看文档，他也不知道这个字典里该塞什么东西。> 所以实际情况中，调用者是不会直接调用 CTMediator> 的方法的。那调用者怎么发起调用呢？通过响应者给 CTMediator 做的> category 或者 extension 发起调用。> category 或 extension> 以函数声明的方式，解决了参数的问题。调用者看这个函数长什么样子，就知道给哪些参数。在> category 或 extension 的方法实现中，把参数字典化，顺便把> target、action 这俩字符串写死在调用里。> 于是，对于调用者来说，他就不必查文档去看参数怎么给，也不必担心> target、action 字符串是什么了。这个 category 是一个独立的> Pod，由响应者业务的开发给到。> 所以，当一个工程师开发一个业务的时候，他会开发两个 Pod，一个是> category Pod，一个是自己本身的业务 Pod。这样就完美解决了 CTMediator> 它自身的缺点。> 对于调用者来说，他不会直接依赖 CTMediator 去发起调用，而是直接依赖> category Pod 去发起调用的。这么一来，CTMediator 方案就完美了。> 然后还有一点可能需要强调：基于 CTMediator> 方案的工程，每一个组件无所谓是 OC 还是 Swift，Pod 也无所谓是 category> 还是 extension。也就是说，假设一个工程由 100 个组件组成，那可以是 50> 个 OC、50 个 Swift。因为 CTMediator> 抹去了不同语言的组件之间的隔阂，所以大家老的 OC 工程可以先应用> CTMediator，把组件拆出来。然后新的业务来了，用 Swift> 写，等有空的时候再把老的 OC 改成 Swift，或者不改，都是没问题的。不过，解耦的精髓在于业务逻辑能够独立出来，并不是形式上的解除编译上的耦合（编译上解除耦合只能算是解耦的一种手段而已）。所以，在考虑架构设计时，我们**更多的还是需要在功能逻辑和组件划分上做到同层级解耦，上下层依赖清晰，这样的结构才能够使得上层组件易插拔，下层组件更稳固。而中间者架构模式更容易维护这种结构，中间者的易管控和易扩展性，也使得整体架构能够长期保持稳健与活力。所以，中间者架构就是我心目中好的架构。**
## 案例分享明确了中间者架构是我认为的好架构，那么如何体现其易管控和易扩展性呢？我通过一个案例来和你一起分析下。这个例子的代码，在 CTMediator 的基础上进行了扩展，完整代码请点击[这个GitHub 链接](https://github.com/ming1016/ArchitectureDemo) 。这个范例的主要组件类名和方法名，如下图所示：![](Images/8ee51165bae31b1831158113c6507f70.png){savepage-src="https://static001.geekbang.org/resource/image/8f/62/8fe9d2bcbbb6b6f0f7be6e2da5557e62.png"}```{=html}```图 2 主要的组件类名和方法名]{.reference}```{=html}```可以看出，这个范例在中间者架构的基础上增加了对中间件、状态机、观察者、工厂模式的支持。同时，这个案例也在使用上做了些优化，支持了链式调用，代码如下：    self.dispatch(CdntAction.cls(@"PublishCom").mtd(@"viewInVC").pa(dic));代码中的 PublishCom 是组件类名，ViewInVC 是方法名。下面说下**中间件模式。**在添加中间件的时候，我们只需要链式调用addMiddlewareAction 就可以在方法执行之前插入中间件。代码如下：    self.middleware(@"PublishCom showEmergeView").addMiddlewareAction(CdntAction.clsmtd(@"AopLogCom emergeLog").pa(Dic.create.key(@"actionState").val(@"show").done));这行代码对字典参数也使用了链式方便参数的设置，使得字典设置更易于编写。改变状态使用toSt方法即可，状态的维护和管理都在内部实现。同一个方法不同状态的实现只需要在命名规则上做文章即可，这也是得易于中间者架构可以统一处理方法调用规则的特性。比如，confirmEmerge方法在不同状态下的实现代码如下：    // 状态管理- (void)confirmEmerge_state_focusTitle:(NSDictionary *)dic {    NSString *title = dic[@"title"];    [self.fromAddressBt setTitle:title forState:UIControlStateNormal];    self.fromAddressBt.tag = 1;}- (void)confirmEmerge_state_focusContent:(NSDictionary *)dic {    NSString *title = dic[@"title"];    [self.toAddressBt setTitle:title forState:UIControlStateNormal];    self.toAddressBt.tag = 1;}- (void)confirmEmerge_state_focusPrice:(NSDictionary *)dic {    NSString *title = dic[@"title"];    [self.peopleBt setTitle:title forState:UIControlStateNormal];    self.peopleBt.tag = 1;}可以看出，我们只需要在方法名后面加上" \_state \_状态名"，就能够对不同状态进行不同实现了。对于**观察者模式**，使用起来也很简单清晰。比如，发布文章这个事件需要两个观察者，一个执行重置界面，一个检查是否能够发布，代码如下：    // 观察者管理 self.observerWithIdentifier(@"publishOk").addObserver(CdntAction.clsmtd(@"PublishCom reset")).addObserver(CdntAction.clsmtd(@"PublishCom checkPublish"));这样的写法非常简单清晰。在发布时，我们只需要执行如下代码：    [self notifyObservers:@"publishOk"];观察者方法添加后，也会记录在内部，它们的生命周期跟随中间者的生命周期。**工厂模式的思路和状态机类似**，状态机是对方法在不同状态下的实现，而工厂模式是对类在不同设置下的不同实现。由于有了中间者，我就可以在传入类名后对其进行类似状态机中方法名的处理，以便类的不同实现可以通过命名规则来完成。我们先看看中间者处理状态机的代码：    // State action 状态处理if (![self.p_currentState isEqual:@"init"]) {    SEL stateMethod = NSSelectorFromString([NSString stringWithFormat:@"%@_state_%@:", sep[1], self.p_currentState]);    if ([obj respondsToSelector:stateMethod]) {        return [self executeMethod:stateMethod obj:obj parameters:parameters];    }}可以看出当前的状态会记录在 p_currentState属性中，方法调用时方法名会和当前的状态的命名拼接成一个完整的实现方法名来调用。中间者处理工厂模式的思路也类似，代码如下：    // Factory// 由于后面的执行都会用到 class 所以需要优先处理 class 的变形体NSString *factory = [self.factories objectForKey:classStr];if (factory) {    classStr = [NSString stringWithFormat:@"%@_factory_%@", classStr, factory];    classMethod = [NSString stringWithFormat:@"%@ %@", classStr, sep[1]];}可以看出，采用了中间者这种架构设计思想后，架构就具有了很高的扩展性和可管控性。所以，我推崇这种架构设计思路。
## 小结架构的设计绝对不是要等到工程到了燃眉之急之时，再去环顾其他公司或团队在用什么架构，然后拍脑袋拿一个过来，来次大重构。好的架构，需要在业务开发过程中及早发现开发的痛点，进行有针对性的改良，不然就会和实际开发越走越远。比如，某个业务模块的逻辑非常复杂、状态有很多，这时我们就需要在架构层面考虑如何处理会更方便，改动最小的支持状态机模式，又或者在开始架构设计时就多考虑如何将架构设计的具有更高的易用性和可扩展性。好的架构是能够在一定的规范内同时支持高灵活度，这种度的把握是需要架构师长期跟随团队开发，随着实际业务需求的演进进行分析和把控的。在项目大了，人员多了的情况下，好的架构一定是不简单的，不通用的，但一定是接地气的，这样才能更适合自己的团队，才能够用得上。那些大而全，炫技，脱离业务开发需求的架构是没法落地的。最后，我提点建议。我在面试应聘者的时候，通常都会问他所负责项目的整体架构是怎样的。结果呢，很多人都只对自己负责的那摊子事儿说的溜，而回答所在项目整体情况时却支支吾吾，也因此没能面试成功。所以，作为一名普通的开发者，除了日常需求开发和技术方案调研、设计外，你还需要了解自己所在项目的整体架构是怎样的，想想架构上哪些地方是不够好需要改进的，业界有哪些好的架构思想是可以落地到自己项目中的。有了从项目整体上去思考的意识，你才能够站在更高的视角上去思考问题。这，也是对架构师的基本要求。
## 课后作业架构如何设计众说纷纭，请你来说下你们项目目前架构是怎样的，并画出你心中理想的架构图。感谢你的收听，欢迎你在评论区给我留言分享你的观点，也欢迎把它分享给更多的朋友一起阅读。![](Images/0e2ff493da248888e66ed0aa4e0251a2.png){savepage-src="https://static001.geekbang.org/resource/image/f5/27/f5ee90aa0183a4bcc688980bd625eb27.jpg"}
# 05 \| 链接器：符号是怎么绑定到地址上的？你好，我是戴铭。你是不是经常会好奇自己参与的这么些项目，为什么有的编译起来很快，有的却很慢；编译完成后，有的启动得很快，有的却很慢。其实，在理解了编译和启动时链接器所做的事儿之后，你就可以从根儿上找到这些问题的答案了。所以，在今天这篇文章中，我就重点和你讲解一下链接器相关的知识。**简单地说，链接器最主要的作用，就是将符号绑定到地址上。**理解了这其中的原理后，你就可以有针对性地去调整和优化项目了。同时，掌握了链接器的作用，也将有助于你理解后面文章中，关于符号表、加载相关的内容。现在，我们就从 iOS开发的起点，也就是编写代码和编译代码开始说起，看看链接器在这其中到底发挥了什么作用。
## iOS 开发为什么使用的是编译器？我们都知道，iOS 编写的代码是先使用编译器把代码编译成机器码，然后直接在CPU 上执行机器码的。之所以不使用解释器来运行代码，是因为苹果公司希望iPhone 的执行效率更高、运行速度能达到最快。那**为什么说用解释器运行代码的速度不够快呢？**这是因为解释器会在运行时解释执行代码，获取一段代码后就会将其翻译成目标代码（就是字节码（Bytecode）），然后一句一句地执行目标代码。也就是说，解释器，是在运行时才去解析代码，这样就比在运行之前通过编译器生成一份完整的机器码再去执行的效率要低。``{=html}这时你一定会纳闷了，既然编译器效率这么高，那为什么还有人用解释器呢？所谓事有利弊，解释器可以在运行时去执行代码，说明它具有动态性，程序运行后能够随时通过增加和更新代码来改变程序的逻辑。也就是说，你写的程序跑起来后不用重新启动，就可以看到代码修改后的效果，这样就缩短了调试周期。程序发布后，你还可以随时修复问题或者增加新功能，用户也不用一定要等到发布新版本后才可以升级使用。所以说，使用解释器可以帮我们缩短整个程序的开发周期和功能更新周期。那么，使用编译器和解释器执行代码的特点，我们就可以概括如下：-   采用编译器生成机器码执行的好处是效率高，缺点是调试周期长。-   解释器执行的好处是编写调试方便，缺点是执行效率低。编译器和解释器的比较图示如下：![](Images/93b71aaf42ba4b4f9b835fd334861514.png){savepage-src="https://static001.geekbang.org/resource/image/d7/43/d7621cb8232fae96b46a52e1b7fb7643.png"}```{=html}```图 1 编译器和执行器的对比]{.reference}```{=html}```明确了 iOS 开发使用编译器的原因以后，你还需要了解 **iOS开发使用的到底是什么编译器。**现在苹果公司使用的编译器是 LLVM，相比于 Xcode 5 版本前使用的GCC，编译速度提高了 3 倍。同时，苹果公司也反过来主导了 LLVM 的发展，让LLVM 可以针对苹果公司的硬件进行更多的优化。总结来说，LLVM 是编译器工具链技术的一个集合。而其中的 lld项目，就是内置链接器。编译器会对每个文件进行编译，生成Mach-O（可执行文件）；链接器会将项目中的多个 Mach-O 文件合并成一个。LLVM的编译过程非常复杂。如果你有兴趣的话，可以通过[官方手册](http://llvm.org/docs/)查看完整的编译过程。这里，我先简单为你总结下编译的几个主要过程：-   首先，你写好代码后，LLVM    会预处理你的代码，比如把宏嵌入到对应的位置。-   预处理完后，LLVM 会对代码进行词法分析和语法分析，生成 AST 。AST    是抽象语法树，结构上比代码更精简，遍历起来更快，所以使用 AST    能够更快速地进行静态检查，同时还能更快地生成 IR（中间表示）。-   最后 AST 会生成 IR，IR    是一种更接近机器码的语言，区别在于和平台无关，通过 IR    可以生成多份适合不同平台的机器码。对于 iOS 系统，IR    生成的可执行文件就是 Mach-O。下图展示了编译的主要过程。![](Images/c2ff4ef5f1b3c717bb50e2a3e002eb1b.png){savepage-src="https://static001.geekbang.org/resource/image/03/63/03e511d5cc6eb12889d882d6e705ac63.png"}```{=html}```图 2 编译的主要过程]{.reference}```{=html}```