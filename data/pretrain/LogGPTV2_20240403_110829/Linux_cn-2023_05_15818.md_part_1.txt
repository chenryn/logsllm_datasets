---
author: Julia Evans
category: 技术
comments_data:
- date: '2023-05-16 21:57:35'
  message: 既然提到了PHP，鸟哥的博客在几年前有篇文章分析过浮点数精度问题
  postip: 3.112.55.19
  username: 来自美国的 Firefox 112.0|Windows 10 用户
- date: '2023-05-19 00:41:40'
  message: "2**-4 + 2702159776422298 / 2**(52 + 4) = X / (2**52 + 3)\r\n应为\r\n2**-4 + 2702159776422298 / 2**(52 + 4) = X / 2**(52 + 3)"
  postip: 223.104.97.152
  username: 来自223.104.97.152的 MIUI Browser 17.0|Android 13 用户
- date: '2023-05-23 16:18:25'
  message: 非常感谢！您说的对，这一点甚至英文原文都是错误的。
  postip: 153.0.156.56
  username: linux [Chrome 113.0|Mac 10.15]
count:
  commentnum: 3
  favtimes: 0
  likes: 0
  sharetimes: 0
  viewnum: 2776
date: '2023-05-16 16:31:00'
editorchoice: false
excerpt: 我的意思是，我知道浮点计算是不精确的
fromurl: https://jvns.ca/blog/2023/02/08/why-does-0-1-plus-0-2-equal-0-30000000000000004/
id: 15818
islctt: true
largepic: /data/attachment/album/202305/16/162904pp51u5nsemd14pp2.jpg
permalink: /article-15818-1.html
pic: /data/attachment/album/202305/16/162904pp51u5nsemd14pp2.jpg.thumb.jpg
related: []
reviewer: wxy
selector: lkxed
summary: 我的意思是，我知道浮点计算是不精确的
tags:
- 浮点数
thumb: false
title: 为什么 0.1 + 0.2 = 0.30000000000000004？
titlepic: true
translator: MjSeven
updated: '2023-05-16 16:31:00'
---
![](/data/attachment/album/202305/16/162904pp51u5nsemd14pp2.jpg)
嗨！昨天我试着写点关于浮点数的东西，我发现自己对这个 64 位浮点数的计算方法很好奇：
```
>>> 0.1 + 0.2
0.30000000000000004
```
我意识到我并没有完全理解它是如何计算的。我的意思是，我知道浮点计算是不精确的，你不能精确地用二进制表示 `0.1`，但是：肯定有一个浮点数比 `0.30000000000000004` 更接近 0.3！那为什么答案是 `0.30000000000000004` 呢？
如果你不想阅读一大堆计算过程，那么简短的答案是： `0.1000000000000000055511151231257827021181583404541015625 + 0.200000000000000011102230246251565404236316680908203125` 正好位于两个浮点数之间，即 `0.299999999999999988897769753748434595763683319091796875` （通常打印为 `0.3`） 和 `0.3000000000000000444089209850062616169452667236328125`（通常打印为 `0.30000000000000004`）。答案是 `0.30000000000000004`，因为它的尾数是偶数。
#### 浮点加法是如何计算的
以下是浮点加法的简要计算原理：
* 把它们精确的数字加在一起
* 将结果四舍五入到最接近的浮点数
让我们用这些规则来计算 0.1 + 0.2。我昨天才刚了解浮点加法的计算原理，所以在这篇文章中我可能犯了一些错误，但最终我得到了期望的答案。
#### 第一步：0.1 和 0.2 到底是多少
首先，让我们用 Python 计算 `0.1` 和 `0.2` 的 64 位浮点值。
```
>>> f"{0.1:.80f}"
'0.10000000000000000555111512312578270211815834045410156250000000000000000000000000'
>>> f"{0.2:.80f}"
'0.20000000000000001110223024625156540423631668090820312500000000000000000000000000'
```
这确实很精确：因为浮点数是二进制的，你也可以使用十进制来精确的表示。但有时你只是需要一大堆数字:)
#### 第二步：相加
接下来，把它们加起来。我们可以将小数部分作为整数加起来得到确切的答案：
```
>>> 1000000000000000055511151231257827021181583404541015625 + 2000000000000000111022302462515654042363166809082031250
3000000000000000166533453693773481063544750213623046875
```
所以这两个浮点数的和是 `0.3000000000000000166533453693773481063544750213623046875`。
但这并不是最终答案，因为它不是一个 64 位浮点数。
#### 第三步：查找最接近的浮点数
现在，让我们看看接近 `0.3` 的浮点数。下面是最接近 `0.3` 的浮点数（它通常写为 `0.3`，尽管它不是确切值）：
```
>>> f"{0.3:.80f}"
'0.29999999999999998889776975374843459576368331909179687500000000000000000000000000'
```
我们可以通过 `struct.pack` 将 `0.3` 序列化为 8 字节来计算出它之后的下一个浮点数，加上 1，然后使用 `struct.unpack`：
```
>>> struct.pack("!d", 0.3)
b'?\xd3333333'
# 手动加 1
>>> next_float = struct.unpack("!d", b'?\xd3333334')[0]
>>> next_float
0.30000000000000004
>>> f"{next_float:.80f}"
'0.30000000000000004440892098500626161694526672363281250000000000000000000000000000'
```
当然，你也可以用 `math.nextafter`：
```
>>> math.nextafter(0.3, math.inf)
0.30000000000000004
```
所以 `0.3` 附近的两个 64 位浮点数是 `0.299999999999999988897769753748434595763683319091796875` 和 `0.3000000000000000444089209850062616169452667236328125`。
#### 第四步：找出哪一个最接近
结果证明 `0.3000000000000000166533453693773481063544750213623046875` 正好在 `0.299999999999999988897769753748434595763683319091796875` 和 `0.3000000000000000444089209850062616169452667236328125` 的中间。
你可以通过以下计算看到：
```
>>> (3000000000000000444089209850062616169452667236328125000 + 2999999999999999888977697537484345957636833190917968750) // 2 == 3000000000000000166533453693773481063544750213623046875
True
```
所以它们都不是最接近的。
#### 如何知道四舍五入到哪一个？
在浮点数的二进制表示中，有一个数字称为“尾数”。这种情况下（结果正好在两个连续的浮点数之间），它将四舍五入到偶数尾数的那个。
在本例中为 `0.300000000000000044408920985006261616945266723632812500`。
我们之前就见到了这个数字的尾数：
* 0.30000000000000004 是 `struct.unpack('!d', b'?\xd3333334')` 的结果
* 0.3 是 `struct.unpack('!d', b'?\xd3333333')` 的结果
`0.30000000000000004` 的大端十六进制表示的最后一位数字是 `4`，它的尾数是偶数（因为尾数在末尾）。
#### 我们用二进制来算一下
之前我们都是使用十进制来计算的，这样读起来更直观。但是计算机并不会使用十进制，而是用 2 进制，所以我想知道它是如何计算的。
我不认为本文的二进制计算部分特别清晰，但它写出来对我很有帮助。有很多数字，读起来可能很糟糕。
#### 64 位浮点数如何计算：指数和尾数
64 位浮点数由 2 部分整数构成：**指数**和**尾数**，还有 1 比特 **符号位**.
以下是指数和尾数对应于实际数字的方程：
![](/data/attachment/album/202305/16/163100wi02oudy5tkhrot5.jpg)
例如，如果指数是 `1`，尾数是 `2**51`，符号位是正的，那么就可以得到：
![](/data/attachment/album/202305/16/163110yh4o4z94rxk8xols.jpg)
它等于 `2 * (1 + 0.5)`，即 3。
#### 步骤 1：获取 0.1 和 0.2 的指数和尾数
我用 Python 编写了一些低效的函数来获取正浮点数的指数和尾数:
```
def get_exponent(f):
    # 获取前 52 个字节
    bytestring = struct.pack('!d', f)
    return int.from_bytes(bytestring, byteorder='big') >> 52
def get_significand(f):
    # 获取后 52 个字节
    bytestring = struct.pack('!d', f)
    x = int.from_bytes(bytestring, byteorder='big')
    exponent = get_exponent(f)
    return x ^ (exponent << 52)
```
我忽略了符号位（第一位），因为我们只需要处理 0.1 和 0.2，它们都是正数。