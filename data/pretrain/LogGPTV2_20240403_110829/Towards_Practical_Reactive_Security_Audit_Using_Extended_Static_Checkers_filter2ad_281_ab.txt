be
When the user runs HAVOC-LITE with the property and
candidate annotations, the tool infers two annotations: The
func_use_vfield has a precondition
__requires(v->vt == (VT_BYREF | VT_UI1))
and the method func_set_vt has a postcondition
__ensures(v->vt == (VT_BYREF | VT_UI1))
These additional annotations allow the tool to only complain
about the method t1bad, which corresponds to the only true
error. Although for this simple example, it is easier to simply
write the two additional annotations, it is immensely useful
when dealing with modules with several
thousand deeply
nested procedures.
B. Example 2: Object-oriented reasoning
A second example involves the IUnknown interface class
which is responsible for all the reference counting mechanisms
necessary to maintain object consistency in COM applications.
In this example, the class method A::Action performs a call
to QueryInterface which is in charge of retrieving an
instance of the interface given an input interface identiﬁer.
Such a call performs an implicit call
to AddRef which
increases the reference counter for this interface. Success of
this call (when the return status is S_OK) leads to calling
method WebAction which performs the expected operation
on class B. Failure to retrieve the interface methods leads
to early termination, where the IUnknown interface pointer
is released using a call to method ReleaseInterface,
which is in charge of decrementing the reference count for
this interface (provided the interface pointer is non-NULL).
A security vulnerability exists in this example due to the
lack of NULL initialization of the IWebIface pointer, which
leads to corrupting the reference counter of an unknown
location in the program in case the call to QueryInterface
is not successful. Such example requires an accurate object-
oriented awareness from the static checker. We later show how
HAVOC-LITE was used to uncover multiple similar security
vulnerabilities in a critical browser component.
To model this property, the user can introduce a ghost
ﬁeld Queried in every object — the ghost ﬁeld tracks
whether an object has been created by a successful call to
QueryInterface. The value of the ghost ﬁeld for an object
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:54:10 UTC from IEEE Xplore.  Restrictions apply. 
{
B ( ) { } ;
HRESULT Q u e r y I n t e r f a c e ( IID id , void ∗∗p ) ;
ULONG
ULONG
HRESULT WebAction ( ) ;
AddRef ( ) ;
R e l e a s e ( ) ;
( i )
i−>R e l e a s e ( ) ;
} ;
void R e l e a s e I n t e r f a c e ( IUnknown ∗ i ) {
}
i n t main ( i n t ac , char ∗∗ av ) {
A ∗ a = new A ( ) ;
B ∗b = a−>Lookup ( ) ;
a−>A c t i o n ( b ) ;
return ( 0 ) ;
i f
} ;
c l a s s B : p u b l i c IWebIface ,
p u b l i c IUnknown
c l a s s A {
A( ) { } ;
HRESULT A c t i o n ( ) ;
∗Lookup ( ) ;
B
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25 HRESULT A : : A c t i o n (B ∗b ) {
26
27
28
29
30
31
32
33 Cleanup :
34
35
36
R e l e a s e I n t e r f a c e (w ) ;
return ( r ) ;
HRESULT r = S FAIL ;
IWebIface ∗w;
i f
( b == NULL)
goto Cleanup ;
r = b−>Q u e r y I n t e r f a c e ( IID WebIface , &w ) ;
i f
r = b−>WebAction ( ) ;
( r == S OK)
}
}
Fig. 3. Example of analysis requiring precise object-oriented semantics
x is written as __resource(‘‘Queried’’, x). One
can write a precondition for the Release methods of B and
any of its derived classes:
#define QUERIED(x)
__resource(‘‘Queried’’, x) == 1
\
\
__requires(QUERIED(this))
ULONG B::Release();
to indicate that the receiver object of the method Release has
to be created by an earlier call to QueryInterface. This
is in turn modeled by writing the following postcondition for
the method:
__ensures(__return != S_OK || QUERIED(*p))
HRESULT B::QueryInterace(IID id, void **p);
where __return denotes the return value of the procedure.
Finally, one needs to infer annotations such as:
__requires(i == NULL || QUERIED(i))
void ReleaseIface(IUnknown *i);
which can be done with the help of the ﬁrst populating can-
didate annotations on all methods that consume a IUnknown
as an argument (we do not show the instrumentation here),
and then performing inter-procedural annotation inference.
III. BACKGROUND: HAVOC
In this section, we provide a background on HAVOC. We
describe HAVOC-LITE along with the extensions created for
this paper in Section IV.
HAVOC can be best thought of as an extended static checker
for C programs, in the spirit of ESC/Java [8]. It provides an (a)
extensible property checker with the aid of an annotation/con-
tract language, (b) a procedure modular veriﬁer that provides
an accurate depiction of C semantics, (c) an user-guided inter-
procedural annotation inference engine, along with (d) various
instrumentation primitives. Figure 4 shows the overall usage
model of HAVOC (and also of HAVOC-LITE) in the hands
of a user. We describe each of the components brieﬂy in the
next few subsections. More details about these features can be
found in an earlier work [2].
Candidate 
annots 
template 
Source 
code 
Property 
+  
Manual 
annots 
Inferred 
annots 
Warning 
review 
Houdini 
inference 
Concrete program  
     semantics 
Modular 
checker 
Refine 
annots? 
Fig. 4. HAVOC and HAVOC-LITE ﬂow.
A. Contract language
A user can document contracts about the code using an
annotation language. An annotation is an assertion over the
state of the program. There are four classes of assertions (i)
assertions __assert (e), (ii) assumptions __assume (e),
(iii) preconditions __requires (e) and (iv) postconditions
__ensures (e). Here e refers to a side-effect-free C expres-
sion that evaluates to a scalar or pointer value — in other
words, e cannot be a structure value. For example, one can
write __ensures (*x == y->f) to indicate that on exit
from a procedure the value obtained by dereferencing the
variable x is identical to the value stored in a ﬁeld f inside
the structure pointed to by y. In addition to assertions, a user
can specify a __modifies clause that speciﬁes which part
of the heap is modiﬁed by a procedure. For the purpose of
36
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:54:10 UTC from IEEE Xplore.  Restrictions apply. 
Locs
Expr
Command
l
e
c
::= ∗e | e → f
::= x | n | l | &l | e1 op e2 | e1 ⊕n e2
::= skip | c1; c2 | x := e | l := e | if e then c | while e do c
|
f (e, . . . , e)
= x
= n
= Memf [E(e) + Offset(f )]
= Memτ [E(e)]
E(x)
E(n)
E(e → f )
E(∗(e : τ ))
E(&e → f ) = E(e) + Offset(f )
E(& ∗ e)
E(e1 op e2) = E(e1) op E(e2)
E(e1 ⊕n e2) = E(e1) + n ∗ E(e2)
= E(e)
C(skip)
C(c1; c2)
C(x := e)
C(l := e)
C(if e then c)
C(while e do c) = while (E(e)) do C(c)
C(f (e1, . . . , ek))
= skip
= C(c1); C(c2)
= x := E(e);
= E(l) := E(e);
= if (E(e)) C(c)
= call f (E(e1), . . . , E(ek))
Fig. 5. A simpliﬁed subset of C, and translation from C into BoogiePL. E() maps a C expression into BoogiePL expression and C() maps a C statement
into a BoogiePL statement.
this paper, we ignore discussion on loop invariants, which are
also supported in HAVOC.
In addition to the expressions in scope, a user can refer
to the return variable by using the symbol __return in a
postcondition, refer to the value of an expression at entry
to a procedure using __old () in a postcondition. For ex-
ample, __ensures (__return == __old (*x) + 1)
signiﬁes that the value of return variable is one more than the
value stored in *x at the entry to the procedure. The user can
also refer to the state of ghost ﬁelds that augment the state
of the program using a keyword __resource4. The scalar
expression __resource (s, e) where s is a string and e is
a side-effect pointer/scalar expression, refers to the value of a
ghost ﬁeld named “s” inside the structure pointed to by e; i.e.
the value of e->s. The user can modify such ghost ﬁelds in
the program.
The annotation language, along with the presence of ghost
ﬁelds allows user to encode various interesting properties of
the program. Section II provides a few examples of such
properties. Several more examples of properties can be found
in earlier works [2].
HAVOC provides a sufﬁciently accurate memory model
for C programs that provides meaning to constructs such as
pointer arithmetic, casts, yet supports common disambigua-
tion required for scalable reasoning of high level properties.
Figure 5 provides a simpliﬁed subset of C (for illustration
purposes) without nested structures and addresses of variables.
Figure 5 also provides the translation of this subset into an
intermediate veriﬁcation language BoogiePL [9]. BoogiePL
is a simple procedural language, where the set of variables
are restricted to Booleans, integers and arrays over them. The
operator C() maps a C statement to the equivalent BoogiePL
statement in a straightforward manner. In addition, the lan-
guage has support for assertions, assumptions, preconditions
and postconditions — the HAVOC annotations map directly
to them.
4Ghost variables are also supported as a degenerate case of ghost ﬁelds.
The operator E() maps a C expression (present in either a
statement or an annotation) into a BoogiePL expression. The
heap is split into a ﬁnite number of arrays (named Memf [] or
Memτ []), one per scalar ﬁeld or pointer ﬁeld (f) or pointer
type (τ). Dereferencing a pointer is modeled as indexing into
the appropriate array with a suitable offset — the operator
Offset(f ) provides the offset of the ﬁeld f inside its parent
structure. The heap splitting assumes ﬁeld safety [10] that
allows exploiting the types and ﬁelds in the program to get dis-
ambiguation. Under ﬁeld safety, it is (optimistically) assumed
that &x → f can never alias with &y → g for distinct ﬁeld
names f and g. Further, addresses of a ﬁeld &x → f does not
alias with the address & ∗ e. Although HAVOC has an option
to not assume ﬁeld safety, the annotation overhead increases
several fold even for simple examples. In our experience, we
have seldom found this optimistic assumption to limit our
ability to ﬁnd violations of security properties described in
this paper.
B. Modular veriﬁer
An annotated BoogiePL program is checked for correctness
one procedure at a time by the Boogie program veriﬁer. The
veriﬁer uses veriﬁcation condition generation (translation of
the program into a logical formula with near linear size) [11]
and automated theorem proving (namely Satisﬁability Mod-
ulo Theories solvers [3]) to check the satisﬁability of the
formula. HAVOC lifts an intraprocedural counterexample at
the BoogiePL level to display over the C source code. In
our experience, the ability of Boogie to generate a compact
veriﬁcation for the theorem prover is key to the scalability of
HAVOC compared to tools that employ symbolic execution
based path enumeration. The theorem prover can internally
perform complex reasoning to prune parts of a procedure (with
often several thousand paths) that are not relevant towards
proving an assertion.
37
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:54:10 UTC from IEEE Xplore.  Restrictions apply. 
C. User-guided inference
HAVOC uses a variant of
the Houdini algorithm to
inference of procedure annota-
perform inter-procedural
tions
[4]. A user can write a set of candidate pre-
conditions (__cand_requires (e)) and postconditions
(__cand_ensures (e)) in addition to the usual annotations.
The Houdini algorithm performs an inter-procedural greatest
ﬁx-point analysis to retain the (unique) maximum subset of
these candidates that can be proved modularly by the program
veriﬁer, while assuming the non-candidate annotations. The
ﬁx-point proceeds by maintaining a worklist of procedures
to be checked. At each step, a procedure p is checked using
the modular veriﬁer. Any candidate annotation that cannot be
proved is removed from the list of annotations. Depending on
the nature of the removed candidate, either the callers of p (for
candidate postcondtiions), or the callee q (whose candidate
preconditions are removed) are added to the worklist,
in
addition to p. The process is repeated until the worklist is
empty. The simple algorithm terminates in at most n ∗ c
iterations, where n is the total number of procedures in the
module, and c is the total number of candidate annotations.In
practice, it runs almost linear in c, thus guaranteeing a quick
turnaround.
D. Instrumentations
Finally, various syntax-based instrumentation facilities are
provided to avoid manually writing annotations on large code-
bases. For example, an user can instrument all procedures
whose names match a regular expression with a postcondition
on globals, or instrument all procedures that take a parameter
x of type τ∗ by a precondition parameterized by x. Moreover,
these annotations can include candidate annotations as well
— this is crucial to performing the annotation inference. In
addition to procedure annotations, the user can also instrument
reads and writes to speciﬁc ﬁelds, types or globals to insert
an assertion or assumption before or after the source line (as
illustrated in Section II).
IV. HAVOC-LITE
Although HAVOC had earlier been applied to large Win-
dows source modules [2], we found it lacking in terms of us-
ability and applicability for the code bases under investigation.
The principal limitations that we addressed and describe in
this section are: (i) need for modeling common C++ language
constructs, (ii) augmenting the instrumentation mechanisms
to exploit C++ class structure, (iii) scaling the annotation
inference to modules containing hundreds of thousands of
procedures, and several other usability concerns such as the
need to modify source code to insert annotations. In the
process of making the tool more robust, we dropped support
for some of the earlier features in HAVOC (hence the name
HAVOC-LITE) such as checking type-safety of C programs,
using ﬁne-grained modiﬁes clauses, dealing with linked list
invariants and checking for complex modiﬁes clauses in can-
didate annotations described in earlier works [12].
c l a s s D {
p u b l i c :
i n t a , b ;
v i r t u a l void f ( ){}
} ;
c l a s s A : p u b l i c D {
p u b l i c :
i n t c ;
A ( ) ;
void f ( ) ;
} ;
c l a s s B : p u b l i c D {
p u b l i c :
i n t d ;
B ( ) ;
void f ( ) ;
void h ( ) ;
} ;
c l a s s C : p u b l i c A, p u b l i c B {
p u b l i c :
i n t e ;
C ( ) ;
void f ( ) ;
e n s u r e s
} ;
. . .
/∗ p o s t c o n d i t i o n ∗ /
void C : : f ( ){ e ++;}