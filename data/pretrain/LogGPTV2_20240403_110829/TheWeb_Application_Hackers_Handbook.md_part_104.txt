Chapter 21 n A Web Application Hacker’s Methodology 817
5.3.5 If the session ID appears to be custom-written, use the “bit fl ipper”
payload source in Burp Intruder to sequentially modify each bit in the
session token in turn. Grep for a string in the response that indicates
whether modifying the token has not resulted in an invalid session, and
whether the session belongs to a different user.
5.4 Check for Insecure Transmission of Tokens
5.4.1 Walk through the application as normal, starting with unauthenticated
content at the start URL, proceeding through the login process, and
then going through all the application’s functionality. Make a note
of every occasion on which a new session token is issued, and which
portions of your communications use HTTP and which use HTTPS.
You can use the logging function of your intercepting proxy to record
this information.
5.4.2 If HTTP cookies are being used as the transmission mechanism for ses-
sion tokens, verify whether the secure fl ag is set, preventing them from
ever being transmitted over HTTP connections.
5.4.3 Determine whether, in the normal use of the application, session tokens
are ever transmitted over an HTTP connection. If so, they are vulnerable
to interception.
5.4.4 In cases where the application uses HTTP for unauthenticated areas
and switches to HTTPS for the login and/or authenticated areas of
the application, verify whether a new token is issued for the HTTPS
portion of the communications, or whether a token issued during the
HTTP stage remains active when the application switches to HTTPS.
If a token issued during the HTTP stage remains active, the token is
vulnerable to interception.
5.4.5 If the HTTPS area of the application contains any links to HTTP URLs,
follow these and verify whether the session token is submitted. If it is,
determine whether it continues to be valid or is immediately terminated
by the server.
5.5 Check for Disclosure of Tokens in Logs
5.5.1 If your application mapping exercises identifi ed any logging, monitoring,
or diagnostic functionality, review these functions closely to determine
whether any session tokens are disclosed within them. Confi rm who is
normally authorized to access these functions. If they are intended for
administrators only, determine whether any other vulnerabilities exist
that could enable a lower-privileged user to access them.
cc2211..iinndddd 881177 88//1199//22001111 1122::2222::0033 PPMM
Stuttard c21.indd V3 - 08/16/2011 Page 818
818 Chapter 21 n A Web Application Hacker’s Methodology
5.5.2 Identify any instances where session tokens are transmitted within the
URL. It may be that tokens are generally transmitted in a more secure
manner, but that developers have used the URL in specifi c cases to
work around a particular problem. If so, these may be transmitted in
theReferer header when users follow any off-site links. Check for any
functionality that enables you to inject arbitrary off-site links into pages
viewed by other users.
5.5.3 If you fi nd any way to gather valid session tokens issued to other users,
look for a way to test each token to determine whether it belongs to an
administrative user (for example, by attempting to access a privileged
function using the token).
5.6 Check Mapping of Tokens to Sessions
5.6.1 Log in to the application twice using the same user account, either from
different browser processes or from different computers. Determine
whether both sessions remain active concurrently. If they do, the appli-
cation supports concurrent sessions, enabling an attacker who has
compromised another user’s credentials to use these without risk of
detection.
5.6.2 Log in and log out several times using the same user account, either from
different browser processes or from different computers. Determine
whether a new session token is issued each time, or whether the same
token is issued every time the same account logs in. If the latter occurs,
the application is not really employing proper session tokens, but is
using unique persistent strings to reidentify each user. In this situation,
there is no way to protect against concurrent logins or properly enforce
session timeout.
5.6.3 If tokens appear to contain any structure and meaning, attempt to separate
out components that may identify the user from those that appear to be
inscrutable. Try to modify any user-related components of the token so
that they refer to other known users of the application. Verify whether
the application accepts the resulting token and whether it enables you
to masquerade as that user. See Chapter 7 for examples of this kind of
subtle vulnerability.
5.7 Test Session Termination
5.7.1 When testing for session timeout and logout fl aws, focus solely on the
server’s handling of sessions and tokens, rather than any events that occur
on the client. In terms of session termination, nothing much depends on
what happens to the token within the client browser.
cc2211..iinndddd 881188 88//1199//22001111 1122::2222::0033 PPMM
Stuttard c21.indd V3 - 08/16/2011 Page 819
Chapter 21 n A Web Application Hacker’s Methodology 819
5.7.2 Check whether session expiration is implemented on the server:
n Log in to the application to obtain a valid session token.
n Wait for a period without using this token, and then submit a request
for a protected page (such as My Details) using the token.
n If the page is displayed normally, the token is still active.
n Use trial and error to determine how long any session expiration
timeout is, or whether a token can still be used days after the previous
request that used it. Burp Intruder can be configured to increment
the time interval between successive requests to automate this task.
5.7.3 Check whether a logout function exists. If it does, test whether it effec-
tively invalidates the user’s session on the server. After logging out,
attempt to reuse the old token, and determine whether it is still valid by
requesting a protected page using the token. If the session is still active,
users remain vulnerable to some session hijacking attacks even after
they have “logged out.” You can use Burp Repeater to keep sending a
specifi c request from the proxy history to see whether the application
responds differently after you log out.
5.8 Check for Session Fixation
5.8.1 If the application issues session tokens to unauthenticated users, obtain
a token and perform a login. If the application does not issue a fresh
token following a successful login, it is vulnerable to session fi xation.
5.8.2 Even if the application does not issue session tokens to unauthenticated
users, obtain a token by logging in, and then return to the login page. If
the application is willing to return this page even though you are already
authenticated, submit another login as a different user using the same
token. If the application does not issue a fresh token after the second
login, it is vulnerable to session fi xation.
5.8.3 Identify the format of session tokens that the application uses. Modify
your token to an invented value that is validly formed, and attempt to
log in. If the application allows you to create an authenticated session
using an invented token, it is vulnerable to session fi xation.
5.8.4 If the application does not support login, but processes sensitive user
information (such as personal and payment details) and allows this to
be displayed after submission (such as on a Verify My Order page),
carry out the preceding three tests in relation to the pages displaying
sensitive data. If a token set during anonymous usage of the application
can later be used to retrieve sensitive user information, the application
is vulnerable to session fi xation.
cc2211..iinndddd 881199 88//1199//22001111 1122::2222::0033 PPMM
Stuttard c21.indd V3 - 08/16/2011 Page 820
820 Chapter 21 n A Web Application Hacker’s Methodology
5.9 Check for CSRF
5.9.1 If the application relies solely on HTTP cookies as its method of trans-
mitting session tokens, it may be vulnerable to cross-site request forgery
attacks.
5.9.2 Review the application’s key functionality, and identify the specifi c
requests that are used to perform sensitive actions. If an attacker can
fully determine in advance parameters for any of these requests (that
is, they do not contain any session tokens, unpredictable data, or other
secrets), the application is almost certainly vulnerable.
5.9.3 Create an HTML page that will issue the desired request without any
user interaction. For GET requests, you can place an  tag with the
src parameter set to the vulnerable URL. For POST requests, you can
create a form that contains hidden fi elds for all the relevant parameters
required for the attack and that has its target set to the vulnerable
URL. You can use JavaScript to autosubmit the form as soon as the
page loads. While logged in to the application, use the same browser
to load your HTML page. Verify that the desired action is carried out
within the application.
5.9.4 If the application uses additional tokens within requests in an attempt to
prevent CSRF attacks, test the robustness of these in the same manner as
for session tokens. Also test whether the application is vulnerable to UI
redress attacks, in order to defeat the anti-CSRF defenses (see Chapter 13
for more details).
5.10 Check Cookie Scope
5.10.1 If the application uses HTTP cookies to transmit session tokens (or
any other sensitive data), review the relevant Set-Cookie headers, and
check for any domain or path attributes used to control the scope of the
cookies.
5.10.2 If the application explicitly liberalizes its cookies’ scope to a parent
domain or parent directory, it may be leaving itself vulnerable to attacks
via other web applications that are hosted within the parent domain
or directory.
5.10.3 If the application sets its cookies’ domain scope to its own domain
name (or does not specify a domain attribute), it may still be exposed
to attacks via any applications hosted on subdomains. This is a conse-
quence of how cookie scoping works. It cannot be avoided other than
by not hosting any other applications on a subdomain of a security-
sensitive application.
cc2211..iinndddd 882200 88//1199//22001111 1122::2222::0033 PPMM
Stuttard c21.indd V3 - 08/16/2011 Page 821
Chapter 21 n A Web Application Hacker’s Methodology 821
5.10.4 Determine any reliance on segregation by path, such as /site/main and
/site/demo, which can be subverted in the event of a cross-site scripting
attack.
5.10.5 Identify all the possible domain names and paths that will receive the
cookies that the application issues. Establish whether any other web
applications are accessible via these domain names or paths that you
may be able to leverage to capture the cookies issued to users of the
target application.
6 Test Access Controls
6.4. Test for
6.1. Understand the requirements
insecure methods
6.2. Test with 6.3. Test with
multiple accounts limited access
Figure 21-7: Testing access controls
6.1 Understand the Access Control Requirements
6.1.1 Based on the core functionality implemented within the application,
understand the broad requirements for access control in terms of verti-
cal segregation (different levels of users have access to different types
of functionality) and horizontal segregation (users at the same privilege
level have access to different subsets of data). Often, both types of seg-
regation are present. For example, ordinary users may be able to access
their own data, while administrators can access everyone’s data.
6.1.2 Review your application mapping results to identify the areas of func-
tionality and types of data resources that represent the most fruitful
targets for privilege escalation attacks.
6.1.3 To perform the most effective testing for access control vulnerabilities,
you should ideally obtain a number of different accounts with different
vertical and horizontal privileges. If self-registration is possible, you can
probably obtain the latter directly from the application. To obtain the
former, you will probably need the cooperation of the application owner
(or need to exploit some vulnerability to gain access to a high-privileged
account). The availability of different kinds of accounts will affect the
types of testing you can perform, as described next.
cc2211..iinndddd 882211 88//1199//22001111 1122::2222::0033 PPMM
Stuttard c21.indd V3 - 08/16/2011 Page 822
822 Chapter 21 n A Web Application Hacker’s Methodology
6.2 Test with Multiple Accounts
6.2.1 If the application enforces vertical privilege segregation, fi rst use a
powerful account to locate all the functionality it can access. Then
use a less-privileged account and attempt to access each item of this
functionality.
6.2.1.1 Using Burp, browse all the application’s content within one user
context.
6.2.1.2 Review the contents of Burp’s site map to ensure you have
identifi ed all the functionality you want to test. Then, log out
of the application and log back in using a different user context.
Use the context menu to select the “compare site maps” feature
to determine which high-privileged requests may be accessible to
the lower-privileged user. See Chapter 8 for more details on
this technique.
6.2.2 If the application enforces horizontal privilege segregation, perform
the equivalent test using two different accounts at the same privilege
level, attempting to use one account to access data belonging to the
other account. This typically involves replacing an identifi er (such as
a document ID) within a request to specify a resource belonging to the
other user.
6.2.3 Perform manual checking of key access control logic.
6.2.3.1 For each user privilege, review resources available to a user.
Attempt to access those resources from an unauthorized user
account by replaying the request using the unauthorized user’s
session token.
6.2.4 When you perform any kind of access control test, be sure to test every step
of multistage functions individually to confi rm whether access controls
have been properly implemented at each stage, or whether the application
assumes that users who access a later stage must have passed security
checks implemented at the earlier stages. For example, if an administrative
page containing a form is properly protected, check whether the actual
form submission is also subjected to proper access controls.
6.3 Test with Limited Access
6.3.1 If you do not have prior access to accounts at different privilege levels, or
to multiple accounts with access to different data, testing for broken access
controls is not quite as straightforward. Many common vulnerabilities will
be much harder to locate, because you do not know the names of the URLs,
identifi ers, and parameters that are needed to exploit the weaknesses.
cc2211..iinndddd 882222 88//1199//22001111 1122::2222::0033 PPMM
Stuttard c21.indd V3 - 08/16/2011 Page 823
Chapter 21 n A Web Application Hacker’s Methodology 823
6.3.2 In your application mapping exercises that use a low-privileged account,
you may have identifi ed the URLs for privileged functions such as
administrative interfaces. If these are not adequately protected, you will
probably already know about this.
6.3.3 Decompile all compiled clients that are present, and extract any refer-
ences to server-side functionality.
6.3.4 Most data that is subject to horizontal access controls is accessed using
an identifi er, such as an account number or order reference. To test
whether access controls are effective using only a single account, you
must try to guess or discover the identifi ers associated with other users’
data. If possible, generate a series of identifi ers in quick succession
(for example, by creating several new orders). Attempt to identify any
patterns that may enable you to predict the identifi ers issued to other
users. If there is no way to generate new identifi ers, you are probably
restricted to analyzing those you already have and guessing on that
basis.
6.3.5 If you fi nd a way to predict the identifi ers issued to other users, use the
techniques described in Chapter 14 to mount an automated attack to
harvest interesting data belonging to other users. Use the Extract Grep
function in Burp Intruder to capture the relevant information from within
the application’s responses.
6.4 Test for Insecure Access Control Methods
6.4.1 Some applications implement access controls based on request
parameters in an inherently unsafe way. Look for parameters such
asedit=false or access=read in any key requests, and modify these
in line with their apparent role to try to interfere with the application’s
access control logic.
6.4.2 Some applications base access control decisions on the HTTP Referer
header. For example, an application may properly control access to
/admin.jsp and accept any request showing this as its Referer. To test
for this behavior, attempt to perform some privileged actions to which
you are authorized, and submit a missing or modifi ed Referer header.
If this change causes the application to block your request, it may be
using the Referer header in an unsafe way. Try performing the same
action as an unauthorized user, but supply the original Referer header
and see whether the action succeeds.
6.4.3 If HEAD is an allowed method on the site, test for insecure container-
managed access control to URLs. Make a request using the HEAD method
to determine whether the application permits it.
cc2211..iinndddd 882233 88//1199//22001111 1122::2222::0033 PPMM
Stuttard c21.indd V3 - 08/16/2011 Page 824
824 Chapter 21 n A Web Application Hacker’s Methodology
7 Test for Input-Based Vulnerabilities
Many important categories of vulnerabilities are triggered by unexpected user
input and can appear anywhere within the application. An effective way to
probe the application for these vulnerabilities is to fuzz every parameter to
every request with a set of attack strings.
7.1. Fuzz all request parameters
7.3. XSS and 7.4. OS
7.2. SQL 7.5. Path 7.6. Script 7.7. File
response command
injection traversal injection inclusion
injection injection
Figure 21-8: Testing for input-based vulnerabilities
7.1 Fuzz All Request Parameters
7.1.1 Review the results of your application mapping exercises and identify