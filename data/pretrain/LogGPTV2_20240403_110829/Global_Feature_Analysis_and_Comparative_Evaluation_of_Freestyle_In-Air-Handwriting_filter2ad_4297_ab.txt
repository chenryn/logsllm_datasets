be obtained by another user different from the legitimate user of
account A, but these two users happen to choose the same passcode.
Also, R may be obtained by an imposter who knows the passcode
content for account A.
3) c = diff : R and the templates of account A are generated by
writing different passcode content, regardless of whether the same
user generates them or not. For example, R may be obtained by
some attacker guessing the passcode of account A randomly.
Generally, in the first case, δ should be small, and if R is from
the legitimate user, it should be accepted. However, in the other
two cases, δ should be large, and if R is not from the legitimate
user, it should be rejected. In practice, a system does not distinguish
between case 2 and case 3, and they are only defined separately
for analysis purposes. Also, a real-world system cannot see any
signal in the collision class at registration. It may be able to see some
signals in the diff class if there are registration signals of accounts
other than account A.
We collected the following datasets with institutional IRB ap-
proval (ASU STUDY00008279 and ASU STUDY00010539):
Dataset 1): We asked 180 users to write 360 strings, and we use
them as passcodes for 360 accounts, i.e., exactly two accounts per
user. Then, for each string, the user wrote it in the air five times as
registration, and wrote it another five times as login requests. In
total, we have 360 * 5 * 2 signals. The user determines the string
content, and we asked users to avoid reusing any password they
use in daily life for privacy protection. Also, we recommended
that the length of an alphanumerical string should be at least eight
characters, but this was not a strict restriction. A few users still
created simple and short strings like “USA” or “abc123”. Users might
also create strings in non-Latin languages or use symbols that
cannot be directly typed on a keyboard. Among all 180 users, 58
users wrote words in Chinese. The remaining 122 users wrote
alphanumerical strings or strings with individual symbols (e.g., tilde,
triangles, etc.). We did not have any constraints on the writing style.
Most users wrote every character in the same place, like writing
on an invisible vertical plane, and users generally wrote very fast
in an illegible way. We did not pay incentive money to any of the
users.
Dataset 2): We asked 10 impostors to write the passcode of each
account in the first dataset five times. In total, we have 360 * 5 * 10
signals. The impostors are informed of the content of the passcode,
but they did not see the original account owner writing it. We paid
each impostor a small amount of money for the work. Meanwhile,
we collected an additional spoofing attack dataset where the impos-
tors both know the passcode content and see the original account
owner writing it. The details are shown in section 6.2.
We collected data independently using the two devices by asking
the same group of users to write the identical passcode in identical
environment settings. Different devices have a small influence on
the user behavior, for example, the camera device restricts hand
movements within its field of view, but the glove device does not
have such a restriction. Roughly half of the participants are students
from the authors’ institute, and others are from the general public.
The datasets, data collection protocol, and dataset demographical
details are publicly available on our website (the URL is omitted for
anonymity).
We adopt the following experiment protocol for evaluation.
Step 1) We create the templates for each account using the
five registration signals in dataset 1. We also proceed with any
additional steps for registration as needed by an authentication
algorithm (detailed in section 4 and section 5).
Step 2) For each account and for each of the five login request
signals in dataset 1 for testing, we use it as a login request with
class label c = same to that account. Then, we use the signal as
a login request with class label c = diff to all other accounts (we
assume all passcodes in our dataset are distinct).
Step 3) For each account and for each of the fives login request
signals in dataset 1 for testing, use it as a login request with class
label c = same to that account. Then, for each signal generated by
impostors in dataset 2, use it as a login request with class label c =
collision to the target account.
If a request signal with class label c = same is rejected, it is a
False Negative (FN); otherwise, it is a True Positive (TP). If a request
signal with class label c = diff or c = collision is accepted, it is a
False Positive (FP); otherwise, it is a True Negative (TN). The results
generated in this step are denoted as “results without collision”,
471Global Feature Analysis and Comparative Evaluation of Freestyle In-Air-Handwriting Passcode for User Authentication
ACSAC ’21, December 6–10, 2021, Virtual Event, USA
while the results generated in this step are denoted as “results with
collision”. The same user may reuse the same passcode for multiple
accounts in practice, and different users may happen to use the
same passcode. Hence, the actual performance can be estimated
somewhere between these two cases.
3.4 Applicability
The target application scenarios of our framework are mainly
VR/AR headsets and wearable computing platforms that already
have a gesture interface but lack a keyboard or a touchscreen. Other
application scenarios may also benefit from our framework, e.g.,
scenarios that prefer touchless gesture interfaces for a level of clean-
liness. Our framework can be used for two different purposes. The
first one is online user login, where the server is remotely connected
to the client via the Internet. For example, the user can sign into an
online personal account through the gesture interface on a VR head-
set. The second one is local user login, where the client and server
reside on the same machine. For example, the user can unlock his
or her wearable devices through the gesture interface. In addition,
our framework can also be used as a supplementary authentication
factor in a Multi-Factor Authentication (MFA) system.
Our framework can be implemented with similar server infras-
tructures using password-based login because on the server side
only software changes are required. The requirement of the net-
work between the client and the server for the remote user login
scenario is similar to existing web applications through a secure
communication channel over SSL/TSL with Public Key Infrastruc-
ture (PKI).
In this paper, we make the following security assumptions: (1) the
device on the user side is secure(i.e., no sniffing backdoor); (2) the
storage and computing infrastructure of the authentication server is
secure (i.e., the server program will not leak the templates to others.
In reality, server storage leakage should be considered and template
protection mechanisms are discussed in a separate work [18] by
us); and (3) the communication channel between the user and the
server is secure. Based on the assumptions, in this paper we are
mainly interested in random guessing attacks and spoofing attacks
generated by human imposters on the user side. The attacker’s goal
is to sign into the victim’s account or be identified as the victim. If
the attack is successful, the account owner may suffer from loss of
the account or leakage of private information. These two types of
attacks are studied experimentally with the step 2 and step 3 of the
experiment protocol explained in section 3.3.
4 FEATURE ANALYSIS
In this section, we analyze the signal variation in time (section 4.1),
sample magnitude (section 4.2), and statistical features (section 4.3).
4.1 Alignment Analysis
A signal R can be aligned to another signal T by Dynamic Time
Warping (DTW) [4] to generate an aligned signal S. Here T is called
a template. Specifically, we first run DTW on R and T with all sensor
axes and a window constraint of ±50 samples. The distance function
in DTW between two individual samples is the Euclidean distance.
The warping path is shown in Figure 3 (a) as the solid line on the
left image, which indicates the writing behavior variation in time. If
there is no variation between the two signals, it should be a straight
diagonal line as the dashed line. This warping path indicates the
correspondences between samples in R and T . Given the path, we
calculate each sample of the aligned signal Sij by taking the average
of those samples of R which are mapped to Tij on the warping path.
This alignment step can be applied to any pair of signals, regard-
less of whether they are generated by writing the same content
or not. After alignment, S and T will have the same length (de-
noted as l). Examples are shown in Figure 3 (b), where the black
signal is T and the colored signals are R (without alignment) or S
(with alignment). An illustration of the warping path distribution
is shown in Figure 3(c) (d), and (e), which is obtained by overlaying
warping paths of 1,000 pairs of signal and template in different
classes. This indicates signals of different classes are “warped” in
different intensities. Especially, the signals generated by the same
user writing the same content have very similar shapes. With this
observation, the following DTW matching algorithm is designed
as a baseline algorithm.
Template Generation: Given m raw signals at registration for
an account, first preprocess and align them to the first signal to
obtain m aligned signals {S(1), S(2), ..., S(m)}. Then calculate T as
follows (essentially element-wise average),
m
k
Tij = 1
m
(k)
ij
,
S
where T is stored as the template in the account database.
Matching: Given an account with a template T , and an authen-
tication request signal R, first preprocess R and align it to T to
obtain an aligned signal S. Then calculate the element-wise dis-
tance Dij = |Tij − Sij|; finally calculate the distance,
l
d
i
j
Dij .
δDTW = 1
ld
Here, l is the template length, d is the number of sensor axes.
δDTW can be compared with the threshold directly for making a
decision, or it can be considered as a synthesized feature in the
fusion methods.
noted as δAC). Formally, assuming the segment between i′
of R is aligned to the ith sample of T ,
(i − i′
We define another distance score called the alignment cost (de-
s and i′
e
l
δAC = 1
).
s + i′
2
e
l
i =1
The distribution of δAC is shown in Fig 3 (f). This alignment cost is
a synthesized feature with relatively weak discriminative capability
but can be used in the fusion methods.
4.2 Sample Variation Analysis
The DTW matching each sample is treated equally, which is reason-
able for alignment but not necessarily for matching. We propose
the following Threshold-Then-Vote (TTV) algorithm based on the
DTW matching with improvements. This algorithm is originally
designed only for the camera device using a different signal format
in our previous work [19]. In this paper we revise it and show that
it is applicable to signals obtained from both types of sensors.
472ACSAC ’21, December 6–10, 2021, Virtual Event, USA
Duo Lu, Yuli Deng, and Dijiang Huang
round() function means rounding to the nearest integer (either 0
or 1 in our case), which is essentially a majority vote. TTV(x) is
the same as that in our previous work [19], i.e., if Dij ∗ Pij ∗ Qij is
over the threshold th2, it is set to 1; if Dij ∗ Pij ∗ Qij is below the
threshold th1, it is set to 0; Otherwise, it is set to 0.5.
This function maps an element-wise distance to an element-wise
decision as “match” (i.e., 0), “non-match” (i.e., 1), or “unsure” (i.e., 0.5).
Then the element-wise decisions are aggregated, and the portion
of non-match votes is the distance score. Here th1 and th2 are
tunable parameters determined empirically (in our case, th1 = 0.3,
th2 = 0.4, explained later). When S and T are obtained from the
same user writing the same passcode, because of slight handwriting
behavior change or misalignment, such local non-matches exist,
but their votes are only a few. However, when S and T are obtained
from different users or from writing different contents, they are
different in many places along multiple axes, and the non-matches
dominates.
The two scaling factors P and Q are also proposed in our previ-
ous work [19] for only one type of device. In this paper, we show
that it is applicable to the signals obtained from both types of
sensors. The design philosophy is explained as follows. Basically,
the element-wise distance varies differently in different places and
along different sensor axes. The general observation is that Dij is
large when Tij and Cij are large. Rather than varying the thresholds
th1 and th2, the scaling of element-wise distance is introduced to
apply less importance to some samples if the template has a larger
value or a larger variance at those places. Pij and Qij are calculated
as follows (same as that in our previous work [19]):
Pij = 1/(1 + p ∗ Tij), Qij = 1/(1 + q ∗ Cij),
d
i D′
where p and q are tunable parameters determined empirically (in
our experiments, p = 0.5, q = 1.0). Basically, p and q are chosen
such that Dij is roughly constant for most of R with c = same.
Now we provide more analysis on the element-wise distance. For
convenience, we denote Dij ∗ Pij ∗ Qij as D′
ij.
First, in Figure 4, we show the distribution of D′
ij respect to
the sensor axes averaged along the time, i.e., an approximation of
p( 1
ij|c). This shows the signal variation in each sensor axis,
l
and larger overlap indicates more difficulty in distinguishing dif-
ferent classes based on that axis. Since the writing behavior in the
air is similar to writing on an invisible wall, and in the posture nor-
malization preprocessing step, the x-axis is defined as the averaged
pointing direction (i.e. against the wall), the uncertainty in that
direction is larger. Also, the position axes show a larger variation
range, which means users are generally better at keeping the same
pattern in speed and acceleration than maintaining the same trajec-
tory. We believe that hand movement speed and acceleration are
directly related to the force generated by the muscle using “muscle
memory” while maintaining position and trajectory requires visual
feedback and attention from the brain. Since handwriting is an
acquired skill, the “muscle memory” is a behavioral biometric trait
and relatively stable.
Second, in Figure 5, we show the distribution of D′
ij respect
to the time averaged over all sensor axe, i.e., an approximation
of p( 1
ij|c). For those signal and template generated by the
d
same user writing the same content (c = same), the average of D′
ij
d
j D′
l
i D′
Figure 4: ±2σ ranges of the aggregated scaled element-wise
distance 1
ij respect to the sensor axes for different
l
classes and devices. The left figure shows results with c =
same and c = diff, and the right figure shows results with c =
same and c = collision.
d
j D′
Figure 5: Distribution of the scaled element-wise distance
1
ij respect to the time for different classes. The hor-
d
izontal axis is the time and signals are temporally normal-
ized to the same length. The brightness indicates the density.
The two dashed lines are the th1 and th2.
(m)
ij
),
Template Generation: Calculate the template T in the same
way as the DTW matching algorithm. Additionally, calculate the
template uncertainty C as follows,
(1)
ij , S
Cij = var(S
where the var() function calculates the variance. Both T and C are
stored in the account database.
(2)
ij , ..., S
Matching: Given an account with T , C, and request signal R,
first preprocess R and align it to T , and calculate element-wise
distance Dij in the same way as the DTW matching; then multiply
Dij by two scaling factors Pij and Qij derived from the template
value T and variance C (explained later in this subsection); finally
calculate:
l
i
d
j
δTT V = 1
l