(NDSS), San Diego, CA, Feb. 2019.
[20] C. Holler, K. Herzig, and A. Zeller. Fuzzing with code fragments. In
Proceedings of the 21st USENIX Security Symposium (Security), Bellevue,
WA, Aug. 2012.
[21] Honggfuzz. Honggfuzz Found Bugs, 2018. https://github.com/google/
honggfuzz#trophies.
[22] G. Klees, A. Ruef, B. Cooper, S. Wei, and M. Hicks. Evaluating fuzz
testing. In Proceedings of the 25th ACM Conference on Computer and
Communications Security (CCS), Toronto, Canada, Oct. 2018.
[23] V. Le, M. Afshari, and Z. Su. Compiler validation via equivalence
modulo inputs. In Proceedings of the 2013 ACM SIGPLAN Conference on
Programming Language Design and Implementation (PLDI), Edinburgh,
United Kingdom, June 2014.
[24] V. Le, C. Sun, and Z. Su. Finding deep compiler bugs via guided
stochastic program mutation. In Proceedings of the 26th Annual ACM
Conference on Object-Oriented Programming, Systems, Languages, and
Applications (OOPSLA), Pittsburgh, PA, Oct. 2015.
[25] J. Lee. Issue 1438: Microsoft Edge: Chakra: JIT: ImplicitCallFlags checks
bypass. https://bugs.chromium.org/p/project-zero/issues/detail?id=1438,
2018.
[26] J. Lee. Issue 1565: Microsoft Edge: Chakra: JIT: ImplicitCallFlags check
bypass with Intl. https://bugs.chromium.org/p/project-zero/issues/detail?
id=1565, 2018.
[27] C. Lemieux and K. Sen. Fairfuzz: A targeted mutation strategy for
increasing greybox fuzz testing coverage. In Proceedings of the 33rd
ACM/IEEE International Conference on Automated Software Engineering,
pages 475–485. ACM, 2018.
[28] S. McKenzie. Babel, Javascript compiler, 2019. https://babeljs.io/.
[29] Microsoft. ChakraCore, The core part of the Chakra JavaScript engine that
powers Microsoft Edge, 2019. https://github.com/microsoft/ChakraCore.
[30] R. Padhye, C. Lemieux, K. Sen, M. Papadakis, and Y. Le Traon. Semantic
fuzzing with zest. In Proceedings of the International Symposium on
Software Testing and Analysis (ISSTA), Beijing, China, July 2019.
[31] J. Patra and M. Pradel. Learning to fuzz: Application-independent fuzz
testing with probabilistic, generative models of input data. TU Darmstadt,
Department of Computer Science, Tech. Rep. TUD-CS-2016-14664, 2016.
[32] M. Rajpal, W. Blum, and R. Singh. Not all bytes are equal: Neural byte
sieve for fuzzing. arXiv preprint arXiv:1711.04596, 2017.
[33] M. Rash. A Collection of Vulnerabilities Discovered by the AFL Fuzzer,
2017. https://github.com/mrash/aﬂ-cve.
[34] A. Rebert, S. K. Cha, T. Avgerinos, J. Foote, D. Warren, G. Grieco, and
D. Brumley. Optimizing seed selection for fuzzing. In Proceedings of
the 23rd USENIX Security Symposium (Security), San Diego, CA, Aug.
2014.
[35] S. Sanﬁlippo. Redis, Open source in-memory database, cache and
message broker, 2019. https://redis.io/.
[36] K. Serebryany. libfuzzer a library for coverage-guided fuzz testing. LLVM
project, 2015.
[37] K. Serebryany. Sanitize, Fuzz, and Harden Your C++ Code.
In
Proceedings of the 1st USENIX ENIGMA, San Francisco, CA, Jan. 2016.
[38] R. Swiecki. Honggfuzz. Available online a t: http://code. google.
com/p/honggfuzz, 2016.
[39] W. Syndder and M. Shaver. Building and Breaking the Browser. In
Black Hat USA Brieﬁngs (Black Hat USA), Las Vegas, NV, Aug. 2007.
[40] Syzkaller. Syzkaller Found Bugs - Linux Kernel, 2018. https://github.
com/google/syzkaller/blob/master/docs/linux/found_bugs.md.
[41] B. Turner. Random c program generator. Retrieved from, 2007.
[42] S. Veggalam, S. Rawat, I. Haller, and H. Bos. Ifuzzer: An evolutionary
interpreter fuzzer using genetic programming. In Proceedings of the 21th
European Symposium on Research in Computer Security (ESORICS),
Crete, Greece, Sept. 2016.
[43] J. Wang, B. Chen, L. Wei, and Y. Liu. Skyﬁre: Data-driven seed
generation for fuzzing. In Proceedings of the 38th IEEE Symposium on
Security and Privacy (Oakland), San Jose, CA, May 2017.
[44] J. Wang, B. Chen, L. Wei, and Y. Liu. Superion: grammar-aware greybox
fuzzing. In Proceedings of the 41st International Conference on Software
Engineering (ICSE), Montréal, Canada, May 2019.
[45] G. Wen, Y. Zhang, Q. Liu, and D. Yang. Fuzzing the actionscript virtual
machine. In Proceedings of the 8th ACM Symposium on Information,
Computer and Communications Security (ASIACCS), Hangzhou, China,
May 2013.
[46] D. Yang, Y. Zhang, and Q. Liu. Blendfuzz: A model-based framework
for fuzz testing programs with grammatical inputs. In 2012 IEEE 11th
International Conference on Trust, Security and Privacy in Computing
and Communications, pages 1070–1076. IEEE, 2012.
[47] X. Yang, Y. Chen, E. Eide, and J. Regehr. Finding and understanding bugs
in c compilers. In Proceedings of the 2011 ACM SIGPLAN Conference
on Programming Language Design and Implementation (PLDI), San
Jose, CA, June 2011.
[48] H. Yoo and T. Shon. Grammar-based adaptive fuzzing: Evaluation on
scada modbus protocol. In 2016 IEEE International Conference on Smart
Grid Communications (SmartGridComm), pages 557–563. IEEE, 2016.
[49] M. Zalewski. american fuzzy lop, 2019. http://lcamtuf.coredump.cx/aﬂ/.
APPENDIX
A. JavaScript engine bugs found by DIE
Table VIII lists the bugs discovered by DIE in three known JavaScript
engines (i.e., ChakraCore in Microsoft Edge, JavaScriptCore in Apple Webkit
and V8 in Google Chrome) with their aspect description.
Type
Incorrect regular expression parsing
Incorrect regular expression parsing
Use-after-free due to scope escaping
Incorrect proﬁling during JIT compilation
Memory corruption in JavascriptArray
Incorrect proﬁled state during JIT optimization
Inconsistent behavior between negative NaN and positive NaN
Breaking assumption related to the size of inline segment
Inconsistency in helper label annotation during JIT compilation
Writability of read-only property in class
Writability of constant variable
Incorrect behavior when overwriting previously deleted variable
Incorrect behavior when calling getter of previously deleted variable
Type confusion between integer and double
Inconsistency between cached value and real value
Memory corruption while building bytecode
Memory corruption while parsing JS code
Memory corruption in JavascriptArray
Null dereference due to wrong scope analysis
Breaking assumption related to the size of inline segment
Incorrect internal state due to misbehavior of the engine
JS Engine
Ch 1.11.5
Ch 1.11.5
Ch 1.11.5
Ch 1.11.7
Ch 1.11.7
Ch 1.11.7*
Ch 1.11.7*
Ch 1.11.7*
Ch 1.11.8*
Ch 1.11.9
Ch 1.11.9
Ch 1.11.9
Ch 1.11.9
Ch 1.11.9
Ch 1.11.9
Ch 1.11.9
Ch 1.11.9
Ch 1.11.9
Ch 1.11.9
Ch 1.11.9
Ch 1.11.9*
Ch 1.11.9* Wrong no-return annotation for a function which has return
Ch 1.11.9*
Ch 1.11.9*
Ch 1.11.9*
Ch 1.11.9*
Ch 1.11.9*
Ch 1.11.9*
JSC 2.24.0 Wrong proﬁling during JIT optimization
JSC 2.24.1
JSC 2.24.1
JSC 2.24.2
JSC 2.24.2
JSC 2.24.2 Wrongly yielded exception while handling another exception
Inconsistent behavior of garbage collector from JIT proﬁling
JSC 2.24.2
JSC 2.24.2
Invalid state while handling character
JSC 2.24.2 Memory corruption while parsing function
JSC 2.24.2 Memory corruption while handling slow path in JIT code
JSC 2.25.1
JSC 2.25.1
JSC 2.25.1 Memory corruption while handling regular expression
JSC 2.25.1 Memory corruption while creating regular expression
JSC 2.25.1
JSC 2.25.1 Memory corruption due to race condition in concurrent JIT
V8 8.0.0*
V8 8.0.0*
V8 8.0.0*
V8 8.0.0*
#
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
Ch: ChakraCore, JSC: JavaScriptCore
*Canary version † This bug was reported by us but it is still reachable by DIE due to incomplete ﬁx.
(cid:2) The bug is a memory corruption which results in a crash. (cid:2)The bug is conﬁrmed to be exploitable for remote code execution or information leakage.
Aspect
Non-ascii regex
Non-ascii regex
A gigantic object literal in a nested function
Inﬁnite recursion with exception handling
Sorting large arrays w/ custom comparison
Circular function references
Hashing NaN in Set
-
new F() in F()
Overwriting ﬁelds of super
Deleting constant ﬁelds
Manipulating ﬁelds of built-in objects
Manipulating ﬁelds of built-in objects
JIT - Referencing outer vars in a nested function
JIT - Object property binding
-
eval() giant statements
Array.prototype.push()
with on outer variables
JIT - Local variable escape
JIT - Indexing statically declared arrays variably
Error handling in proxy handlers
JIT - Deﬁning small compound objects
JIT - Inlining small functions
JIT - Indexing and redeﬁning TypedArrays
JIT - Incorrect induction variable used for array index
JIT - Indexing and redeﬁning TypedArrays
JIT - Deﬁning and manipulating small objects
JIT - Control ﬂow analysis
JIT - Indexing in TypedArrays
JIT - Type speculation
JIT - Compiling a built-in function
JIT - Type speculation
A gigantic string that causes out-of-memory
JIT - Compiling a built-in function
JIT - switch case statement
eval() gigantic functions
Triggering Yarr that JIT compiles regexps
JIT - Call context analysis
JIT - Garbage collection
Back reference in regex
Non-ascii regex
A gigantic string that cause out-of-memory
asm.js - Storing an object into a number array
JIT - Switch case statement
JIT - controllable loop bound
-
JIT - indexing arrays
Status
Fixed
Fixed
CVE-2019-0609
Fixed
Fixed
Fixed
Fixed
Fixed
Fixed
Reported
Reported
Reported
Reported
Reported
Reported
Reported
Reported
Reported
Fixed
Fixed
Fixed†
Reported
Fixed
CVE-2019-1023
CVE-2019-1300
CVE-2019-0990
CVE-2019-1092
Fixed
WebKit 195991
WebKit 197353
WebKit 197569
Fixed
Fixed
Fixed
Fixed
Fixed
Fixed
Fixed
CVE-2019-8676
CVE-2019-8673
CVE-2019-8811
CVE-2019-8816
Fixed
Fixed
CVE-2019-13730
CVE-2019-13764
Fixed
CVE-2020-6382
OOB write due to wrong JIT optimization
Incorrect emitted IR from JIT compilation
Use-after-free during JIT
OOB read/write due to accessing uninitialized variable during JIT
OOB read/write due to wrong JIT optimization
OOB read/write due to wrong inlining during JIT
Type confusion between heap and internal object in JIT code
Incorrect loop optimization for JIT IR
Integer overﬂow while handling regular expression
Incorrect redundancy elimination in JIT
Invalid indices stored in TypedArrays
Type confusion of induction variable during JIT
Incorrect assumption while compiling JIT IR
Incorrect type speculation during JIT
Type confusion due to accessing uninitialized memory region
Use-after-free due to wrong garbage collection
Null dereference while accessing HashMap
Security
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
TABLE VIII: New bugs found by DIE in ChakraCore, JavaScriptCore, and V8. The latest version affected by each bug is speciﬁed. In the
Status column, Fixed means the bug was also noticed and patched by developers before we reported the bug.