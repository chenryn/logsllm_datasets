            return int(os.urandom(12).encode('hex'), 16)
        def LFSR(self):
            return self.iv >> 1 | (self.parity(self.iv & self.key) > 16
            x ^= x >> 8
            return (x & 255)
    def encrypt(s):
        o = ''
        for x in s:
            o += chr(ord(x) ^ p.next_byte())
        return o.encode('hex')
    p = PRNG()
    with open('flag.enc', 'w') as f:
        f.write(encrypt(flag))
flag.enc:
    ab38abdef046216128f8ea76ccfcd38a4a8649802e95f817a2fc945dc04a966d502ef1e31d0a2d
#### 分析
可以看到程序采用异或方式加密了 flag，而每次与 flag 异或的字节由类中的
`next_byte`方法生成。我们再看一下这个类，发现构造函数初始化了四个变量，其中 `iv、key、mask`都是根据随机字符串生成的 32
位比特流，我们无法得知，aux 这个变量初始化为 0。
我们来从头过一下 `next_byte`这个方法是怎么生成一个字节的：
把 iv 和 mask 进行异或得到 x，进行 `x ^= x >> 16` `x ^= x >> 8` 这两步，把 `x &
255`结果返回，这就是生成的字节。而在这之中调用了 next 方法改变了类的 iv，而 mask 始终不变。
我们不难发现这几步操作：
    x ^= x >> 16
    x ^= x >> 8
    return x & 255
其实就是把 x 的低 32 bit 按顺序分成四组，每组 8 个比特，四组数进行异或就是返回的结果。（不信可以拿个数试试）
我们再来看一下 iv 每次是如何改变的，next 函数就一行语句：
    self.aux, self.iv = self.iv, self.LFSR()
aux我们不管，因为它没有参与任何运算。新的 iv 被 LFSR 函数的返回值赋值，看一下 LFSR 函数：
    return self.iv >> 1 | (self.parity(self.iv & self.key) > 16
    x ^= x >> 8
    x ^= x >> 4
    x ^= x >> 2
    x ^= x >> 1
    return x & 1
和前面 next_byte 的差不多，不难分析出这个 parity 实际就是把 x 的低 32 个比特之间进行异或，返回结果。当然，结果只能是 0 或1。
如果把 `(self.parity(self.iv & self.key) > 1 | (1 > 1 | (0  X-MAS{S4n7a_4lw4ys_g1ve5_n1c3_pr3s3n7s}
### 总结
Crypto 真好玩，滚去学 Web 了，毕竟还是一只 Web 狗。