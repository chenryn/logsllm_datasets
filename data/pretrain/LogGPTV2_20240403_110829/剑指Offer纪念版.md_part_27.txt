我们试着从头到尾逐个累加示例数组中的每个数字。初始化和为0。第
看到这道题，很多人都能想到最直观的方法，即枚举出数组的所有子
例如输入的数组为{1,-2,3,10,-4,7,2,-5}，和最大的子数组为{3,10,-4
我们从第三个数字重新开始累加，此时得到的和是3。接下来第四步加
题目：输入一个整型数组，数组里有正数也有负数。数组中一个或连
如果采用第二种思路，本题考查对堆、红黑树等数据结构的理解
来实现。
叉树是个合适的选择，并能想到用堆或者红黑树等特殊的二叉树
当需要在某数据容器内频繁查找及替换最大值时，我们要想到二
数既是快速排序的基础，也可以用来查找n个数中第k大的数字。
第5章优化时间和空间效率171
---
## Page 186
172
9
5
W
2
步骤
剑指Offer-
int FindGreatestSumOfSubArray(int *pData,int nLength)
boolg_InvalidInput=false;
代码：
2}。整个过程可以用表5.2总结如下：
大的和18，因此最终最大的子数组的和为18，
return nGreatestSum;
g_InvalidInput = false;
if((pData == NULL）1I(nLength nGreatestSum)
else
if(nCurSum
nGreatestSum
return0;
g_InvalidInput=true;
nCurSum +=pData[i];
一名企面试官精讲典型编程题（纪念版）
nGreatestSum = nCurSum;
nCurSum
吕
加-4
加10
抛弃前面的和-1，加3
加-2
加
操作
L
=pData[i];
(strlen(strN));
(0\，==NS116NS11NxSi)T
return NumberOfl(strN);
sprintf(strN,
if(n 0)
"%d"，n);
1）
atoi（strN+1）+1;
PowerBase10(length-1);
=0：
0：
(length-1)
*PowerBase10(length-2);
---
## Page 191
之后能排成一个最小的数字。要确定排序规则，就要比较两个数字，也就
合的知识，n个数字总共有n!个排列。我们再来看一种更快的算法。
和面试题28“字符串的排列”非常类似，这里不再详细介绍。根据排列组
然后把每个排列拼起来，最后求出拼起来的数字的最小值。求数组的排列
印出这3个数字能排成的最小数字321323。
打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打
面试题33：把数组排成最小的数
这道题其实是希望我们能找到一个排序规则，数组根据这个规则排序
这个题目最直接的做法应该是先求出这个数组中所有数字的全排列，
题目：输入一个正整数数组，把数组里所有数字拼接起来排成一个数，
本题考点：
测试用例：
本题完整的源代码详见32_NumberOfl项目。
源代码：
考查应聘者做优化的激情和能力。最原始的方法大部分应聘者都
功能测试（输入5、10、55、99等)。
的时候都非常有用。
子一步步找到通用的规律。这些能力在实际工作中面对复杂问题
应聘者需要有很严密的数学思维能力，并且还要通过分析具体例
考查面应聘者对复杂问题的思维能力。要想找到O(logn)的方法，
求面试官给出提示，但不能轻易说自己想不出来并且放弃努力。
己追求更快算法的激情，多尝试不同的方法，必要的时候可以要
易放弃尝试。虽然想出O(logn)的方法不容易，但应聘者要展示自
能想到。当面试官提示还有更快的方法之后，应聘者千万不要轻
性能测试（输入较大的数字如10000、21235等）。
边界值测试(输入0、1等)。
第5章优化时间和空间效率
177