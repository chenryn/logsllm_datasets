obtains decryption keys.3 Thus, we will replace the GID
with the assumption that each user has unique secret key
as in an anonymous credential system. Guaranteeing that
this secret key is unique involves a number of subtle issues.
Standard techniques can be found from the anonymous cre-
dential literature. Note, however, that anonymous creden-
tials do not immediately solve the privacy issue in an ABE
setting. Consider the following proposal: The user interacts
with the authority via a pseudonym. When the user wants to
obtain decryption keys corresponding to a set of attributes,
he proves (via the anonymous credential system) that he is
the owner of a credential for these attributes. Then he uses
the ABE system to obtain decryption keys. This idea seems
straightforward, but in fact it is unclear how to satisfy our
security and privacy requirements. First, the existing con-
structions for multi-authority ABE schemes (by Chase [5]
and Lin et al. [10]) require that the user presents the GID
in the clear to each authority. The authority then uses this
GID to generate the user’s decryption keys, in order to en-
sure collusion-resistance. This obviously does not provide
any user privacy. On the other hand, if the user was allowed
3Another option would be to allow the user to reveal the
GID to select authorities, but to require that there be some
additional secret information that was known only to the
user, to prevent impersonation.
123to present a diﬀerent anonymized value to each authority,
then we would no longer be able to guarantee the security
of the multi-authority ABE against colluding users.
Instead, we will solve the privacy problem by designing a
protocol by which a user can obtain a set of decryption keys
for his secret GID without revealing any information about
that GID to the authority. At the same time, the authority
is guaranteed that the agreed upon decryption keys are the
only thing that the user learns from the transaction.
Finally, we stress that, although we use several elements
of anonymous credential systems, our solution does not en-
crypt with respect to a user’s secret key. This is still strictly
an attribute-based encryption system, in which decryption
ability is determined only by a user’s attributes. The secret
key/GID is only used in communicating with the various
authorities, and in determining the appropriate decryption
keys.
3. PRELIMINARIES
3.1 Notations and Complexity Assumptions
Let G1 and G2 be two cyclic multiplicative groups of prime
order q generated by g1 and g2 respectively, ˆe : G1 × G2 →
GT be a bilinear map such that ∀x ∈ G1, y ∈ G2 and a,
b ∈ Zq, ˆe(xa, yb) = ˆe(x, y)ab and ˆe(g1, g2) (cid:54)= 1. Let ψ :
G2 → G1 be a computable isomorphism from G2 to G1,
with ψ(g2) = g1. (G1, G2) are said to be admissible bilinear
groups if the group action in G1, G2, the isomorphism ψ and
the bilinear mapping ˆe are all eﬃciently computable.
Definition 1. The Decisional Diﬃe-Hellman (DDH) prob-
lem in prime order group G = (cid:104)g(cid:105) is deﬁned as follows: on
input g, ga, gb, gc ∈ G, decide if c = ab or c is a random
element of Zq.
Definition 2. Let algorithm BDH Gen(1λ) output the pa-
rameters (ˆe(·,·), q, g1, g2, G1, G2, GT ) where there is an eﬃ-
ciently computable isomorphism ψ from G2 to G1. The De-
cisional Bilinear Diﬃe-Hellman (DBDH) problem is deﬁned
as follows: given g1 ∈ G1, g2, ga
2 ∈ G2 and Z ∈ GT as
input, decide if Z = ˆe(g1, g2)abc or ˆe(g1, g2)R for R ∈R Zq.
2 , gb
2, gc
The security of the ABE schemes by Sahai-Waters [13],
Goyal et al. [8], and Chase [5], and of our construction rely
on the intractability of the DBDH problem.
Definition 3. The k-Decisional Diﬃe-Hellman Inversion
(k-DDHI) problem in prime order group G = (cid:104)g(cid:105) is deﬁned
, gu ∈
as follows: On input a (k + 2)-tuple g, gs, gs2
Gk+2, decide if u = 1/s or u is a random element of Zq.
, . . . , gsk
For our key issuing protocol, we will use a modiﬁed version
of the of the Dodis-Yampolskiy PRF [7], suggested in [9],
which relies on the intractability of the k-DDHI problem in
group G1 of a pairing. Note that k-DDHI is solvable when
given a DDH oracle, thus we must also make the following
assumption:
Definition 4. Let BDH Gen(1λ) output the parameters
for a bilinear mapping ˆe : G1 × G2 → GT . The eXternal
Diﬃe-Hellman (XDH) assumption states that, for all proba-
bilistic polynomial time adversaries A, the DDH problem is
hard in G1. This implies that there does not exist an eﬃ-
ciently computable isomorphism ψ(cid:48) : G1 → G2.
3.2 Deﬁnitions of Multi-Authority ABE
We begin by deﬁning a multi-authority ABE scheme with
a trusted setup (but without an online trusted CA), and
without any privacy guarantees. For now, we consider a key-
policy threshold scheme, where the user’s decryption key
corresponds to a set of attributes and a threshold value.
(See Section 6 for an extension to more general policies.) In
Section 4 we will discuss an extension which allows a user
to obtain decryption keys without leaking his GID, and in
Section 5 we will discuss an extension which replaces Setup
with an interactive protocol between the authorities.
In a multi-authority ABE system, we have many attribute
authorities, and many users. There are also a set of system-
wide public parameters available to everyone (either created
by a trusted party, or by a distributed protocol between
the authorities). A user can choose to go to an attribute
authority, prove that it is entitled to some of the attributes
handled by that authority, and request the corresponding
decryption keys. The authority will run the attribute key
generation algorithm, and return the result to the user. Any
party can also choose to encrypt a message, in which case
he uses the public parameters together with an attribute
set of his choice to form the ciphertext. Any user who has
decryption keys corresponding to an appropriate attribute
set can use them for decryption.
In what follows, we use GID to denote the global identity
of a user and A to denote a set of attributes. We use Au and
AC to denote the attribute set of a user and that speciﬁed
by a ciphertext respectively. We assume all the attribute
sets can be partitioned into N disjoint sets, handled by the
N attribute authorities, and we use a subscript k to denote
the attributes handled by the authority k.
Definition 5. An N -authority ABE scheme consists of
four algorithms:
1. via (params, {(apkk, askk)}k∈{1,...N}) $← Setup(1λ, N )
the randomized key generation algorithm takes a secu-
rity parameter λ ∈ N and the number of authorities
N ∈ N, and outputs the system parameters params
and N public/private key pairs (apkk, askk), one for
each attribute authority k ∈ {1, . . . N}. The thresh-
old values {dk}k∈{1,...N} for each authority are also in-
cluded in params. For simplicity, we assume params
and {apkk}k∈{1,...N} are the implicit inputs of the rest
of the algorithms.
2. via uskk[GID, Ak] $← AKeyGen(askk, GID, Ak) the at-
tribute authority k uses its secret key askk to output
a decryption key corresponding to the attribute set Ak
for the user with identity GID.
3. via C $← Enc({Ak}k∈{1,...N}, m) a sender encrypts a
message m for the set of attributes {Ak}, resulting in a
ciphertext C, where Ak denotes a subset of the attribute
domain of the authority k.
4. via m ← Dec({uskk[GID, Ak]}k∈{1,...N}, C) a user GID
who possesses a suﬃcient set of decryption keys
{uskk[GID, Ak]} from each authority k decrypts C to
recover m.
Definition 6. An N -authority ABE scheme satisﬁes the
consistency property if for all λ, N ∈ N, all identities GID
124k } such that |AC
and all messages m, for all {Au
k} and {AC
k| > dk for all authorities k ∈ {1, . . . , N},
Au
Pr[params ← Setup(1λ, N ); C $← Enc({AC
k }k∈{1,...N}, m);
k )}k∈{1,...N}, C) = m] = 1
, where the probability is taken over the random coins of
Dec({AKeyGen(askk, GID, Au
k ∩
all the algorithms in the expressions above.
Definition 7. An N -authority ABE scheme is (t, n, )-
secure against selective-attribute attack if all t-time adver-
saries A compromising at most n authorities have advantage
at most  in making the game below return 1.
N−ABE,A(λ)
N}, Kcorr ⊂ [1, N ]}) ← A;
Experiment Expsaa
(AC = {AC
1 , . . . , AC
if |Kcorr| > n then return 0;
{Uk}k /∈Kcorr ← ∅;
(params,{(apkk, askk)}k∈{1,...N}) $← Setup(1λ, N );
(m∗
0, m∗
params,{apkk}k∈{1,...N},{askk}k∈Kcorr );
b $← {0, 1}; C∗ $← Enc(AC , m∗
b );
b(cid:48) $← AAKeyGenO(·,·,·)(‘guess(cid:48), C∗, st);
if b (cid:54)= b(cid:48) then return 0 else return 1;
1, st) $← AAKeyGenO(·,·,·)(‘ﬁnd(cid:48),
k , k) is deﬁned as:
where st is state information, and the attribute-key genera-
tion oracle AKeyGenO(GID, Au
if (k ∈ Kcorr) return ⊥;
if (∃Au
(cid:48)
(cid:48)
if (|Au
k ∩ AC
∧ {∀j (cid:54)= k, [(j ∈ Kcorr)
∨(∃Au
j s.t. ((GID, Au
return ⊥;
Uk ← Uk∪(GID, Au
k ); return AKeyGen(askk, GID, Au
k ).
s.t. (GID, Au
k | ≥ dk)
) ∈ Uk) return ⊥; 4
j ) ∈ Uj∧|Au
j ∩AC
j | ≥ dj))]}
k
k
4. AUTHORITY-UNLINKABLE ABE
As mentioned before, a multi-authority ABE system which
requires a user to present his unique identiﬁer to every au-
thority would have severe privacy shortcomings. In partic-
ular, it will be trivial for the various authorities to combine
their data and assemble a complete picture of all of a user’s
attributes in all domains. To avoid this we look to related
work on anonymous credentials [3, 4]. We will treat the
GID as the user’s secret key. Then the user can form diﬀer-
ent pseudonyms based on this GID to use when interacting
with diﬀerent authorities. When the user wishes to obtain
decryption keys for certain attributes associated with this
authority, he performs an interactive protocol with the au-
thority. As a result of this protocol, he gets decryption keys
tied to the GID that corresponds to his pseudonym. These
can then be combined with decryption keys obtained from
other authorities using other pseudonyms for the same GID.
However, from the authorities’ point of view the GID is com-
pletely hidden. In fact it is even infeasible for two authorities
to tell that they are talking to the same user.
4As in all ABE schemes to date, users are not allowed to
simply add attributes to their decryption key set. Instead,
a user who wants to update his attribute set must receive
an entirely new set of keys. In the multi-authority case (see
e.g. [5]), this means that a user cannot simply return to an
authority with the same GID – he must obtain new keys
from all authorities.
4.1 Framework and Security Requirements
Our deﬁnition of an authority-unlinkable ABE scheme ex-
tends the deﬁnition in Section 2.2 by adding an interactive
protocol to allow the user to obtain a decryption key from
the authority without revealing his GID.
Definition 8. An N -authority-unlinkable ABE scheme
is an N -authority ABE scheme with three extra algorithms
(params and {apkk}k∈{1,...N} are omitted from the input):
1. (nym, aux) $← FormNym(GID) probabilistically outputs
a pseudonym for identity GID, and some auxiliary in-
formation aux.
2. Obtain(apkk, GID, Ak, nym, aux) ↔ Issue(askk, Ak, nym)
are two interactive algorithms which execute a user se-
cret key issuing protocol between a user and the at-
tribute authority k. The user takes as input the public
key apkk of the attribute authority k, an attribute set
Ak, an identity GID, and the corresponding pseudonym
nym with auxiliary information aux, and gets what
AKeyGen(askk, GID, Ak) outputs, i.e. a decryption key
for identity GID corresponding to the attribute set Ak.
The attribute authority gets the secret key askk, the
set of attributes Ak and the pseudonym nym as input,
and gets nothing as output.
with the following properties
1. (nym, aux) $← FormNym(GID) produces a commitment
nym to the user’s GID with randomness aux,
2. Obtain ↔ Issue form a secure two party computation
(2PC) protocol for the following functionality F , where
({(apkk, askk)}k∈{1,...N}) is as output by Setup(1λ, N ):
F takes as public input the authority’s public key apkk,
the user’s pseudonym nym, and the attribute set Ak. It
also receives as secret input the user’s identity GID and
the corresponding aux, and the authority’s secret key
askk. It outputs the result of AKeyGen(askk, GID, Ak)
to the user.
4.2 Generic Anonymous Key Issuing Protocol
Here we present a “generic” protocol such that a user with
a private value u ∈ Zq and an authority with private keys
α, β, γ ∈ Zq can jointly compute the value (hαg1/(β+u))γ for
commonly known g, h ∈ G5. Only the user gets this output,
and all other information is hidden.
The roles of each private value will be apparent when this
protocol is used as the anonymous key issuing protocol for
the ABE system to be presented in Section 5. The basic
intuition is that the structure of the ﬁnal value (hαg1/(β+u))γ
resembles a product of hα, which corresponds to something
related to the private key of an authority, and a randomizer
computed as P RFβ(u), where β is the secret seed for Dodis-
6 γ
Yampolskiy PRF [7], and u is the GID of the user.
corresponds to some secret related to an attribute.
5We also require that the discrete logarithm between g and
h be unknown to any corrupt user.
6 In order for this to be a valid PRF, we need u to be
chosen from some predeﬁned polynomial-sized domain. Al-
ternatively, we can choose u = H(GID) for hash function H,
and the result will be secure in the random oracle model.
125User u
ρ1 ∈R Zq,
ρ2 ∈R Zq
Y := (X ρ1
1 X2)ρ2
D := Z 1/ρ2
2P C
X1, X2, PoK(α, τ, x)
Attribute Authority
←−−−−−−−−→ x := (β + u)ρ1, τ ∈R Zq
←−−−−−−−−−− X1 := gτ /x, X2 = hατ
−−−−−−−−−−→
Z, PoK(τ, γ)
←−−−−−−−−−−
Z := Y γ/τ
Y, PoK(ρ2)
Figure 1: Our anonymous ABE key issuing protocol
Figure 1 shows our protocol for anonymous key issuing.
In each step, PoK represents a proof of knowledge of the
secret values used in the computation. For simplicity we
have omitted the statement being proved. Here the ﬁrst
step denotes a 2PC protocol which takes (u, ρ1) from the
user and β from the authority and returns x := (β + u)ρ1
mod q to the authority. This can be done via a general 2PC
protocol for a simple arithmetic computation. Alternatively,
we can do this more eﬃciently using the construction in
[1]. The necessary proofs of knowledge (PoK) for the above
statements can be eﬃciently realized, e.g. via a Schnorr
protocol.
Theorem 1. The above protocol is a secure 2PC protocol
for computing (hαg1/(β+u))γ, assuming that the underlying
arithmetic 2PC and zero knowledge proofs are secure, and
(for security against corrupt user) that DDH is hard.
Proof. To see note that Z 1/ρ2 = Y γ/(τ ρ2) = (X ρ1γ/τ
·
) = (hαg1/(β+u))γ. To show security we consider the
X γ/τ