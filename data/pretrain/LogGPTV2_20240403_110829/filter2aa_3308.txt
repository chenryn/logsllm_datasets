云影实验室 
 1 / 17  
.NET 高级代码审计（第二课） Json.Net 反序列化漏洞 
Ivan1ee@360 云影实验室 
2019 年 03 月 01 日 
云影实验室
 2 / 17  
0X00 前言 
Newtonsoft.Json，这是一个开源的 Json.Net 库，官方地址：
https://www.newtonsoft.com/json ，一个读写 Json 效率非常高的.Net 库，在做开
发的时候，很多数据交换都是以 json 格式传输的。而使用 Json 的时候，开发者很多时
候会涉及到几个序列化对象的使用：DataContractJsonSerializer，
JavaScriptSerializer 和 Json.NET 即 Newtonsoft.Json。大多数人都会选择性能以及
通用性较好 Json.NET，这个虽不是微软的类库，但却是一个开源的世界级的 Json 操作
类库，从下面的性能对比就可以看到它的性能优点。 
用它可轻松实现.Net 中所有类型(对象,基本数据类型等)同 Json 之间的转换，在带来便
捷的同时也隐藏了很大的安全隐患，在某些场景下开发者使用 DeserializeObject 方法
序列化不安全的数据，就会造成反序列化漏洞从而实现远程 RCE 攻击，本文笔者从原
理和代码审计的视角做了相关介绍和复现。 
云影实验室 
 3 / 17  
0X01 Json.Net 序列化 
在 Newtonsoft.Json 中使用 JSONSerializer 可以非常方便的实现.NET 对象与 Json 之
间的转化，JSONSerializer 把.NET 对象的属性名转化为 Json 数据中的 Key，把对象的
属性值转化为 Json 数据中的 Value，如下 Demo，定义 TestClass 对象 
并有三个成员，Classname 在序列化的过程中被忽略（JsonIgnore），此外实现了一个
静态方法 ClassMethod 启动进程。 序列化过程通过创建对象实例分别给成员赋值， 
云影实验室
 4 / 17  
用 JsonConvert.SerializeObject 得到序列化后的字符串 
{"Name":"Ivan1ee","Age":18} 
Json 字符串中并没有包含方法 ClassMethod，因为它是静态方法，不参与实例化的过
程，自然在 testClass 这个对象中不存在。这就是一个最简单的序列化 Demo。为了尽
量保证序列化过程不抛出异常，笔者引入 SerializeObject 方法的第二个参数并实例化
创建 JsonSerializerSettings，下面列出属性 
NullValueHandling：如果序列化时需要忽略值为 NULL 的属性，使用
JsonSerializerSettings.NullValueHandling.Ignore 来实现； 
TypeNameAssemblyFormatHandling：默认情况下 Json.NET 只使用类型中的
部分程序集名称，如：System.Data.DataSet，为了避免在一些环境下不兼容的
问题，需要用到完整的程序集名称，包括版本号、公钥等，所以用到
JsonSerializerSettings.TypeNameAssemblyFormatHandling.Full； 
TypeNameHandling：控制 Json.NET 是否在使用$type 属性进行序列化时包
含.NET 类型名称，并从该属性读取.NET 类型名称以确定在反序列化期间要创建
的类型 
修改代码添加 TypeNameAssemblyFormatHandling.Full、TypeNameHandling.ALL 
将代码改成这样后得到的 testString 变量值才是笔者想要的，打印的数据中带有完整的
程序集名等信息。 
{"$type":"WpfApp1.TestClass, WpfApp1, Version=1.0.0.0, Culture=neutral, 
PublicKeyToken=null","Name":"Ivan1ee","Age":18} 
云影实验室 
 5 / 17  
0x02 Json.Net 反序列化 
2.1、反序列化用法 
反序列过程就是将 Json 字符串转换为对象，通过创建一个新对象的方式调用
JsonConvert.DeserializeObject 方法实现的，传入两个参数，第一个参数需要被序列
化的字符串、第二个参数设置序列化配置选项来指定 JsonSerializer 按照指定的类型名
称处理，其中 TypeNameHandling 可选择的成员分为五种 
默认情况下设置为 TypeNameHandling.None，表示 Json.NET 在反序列化期间不读取
或写入类型名称。具体代码可参考以下 
2.2、攻击向量—ObjectDataProvider 
漏洞的触发点也是在于 TypeNameHandling 这个枚举值，如果开发者设置为非空值、
也就是对象（Objects） 、数组（Arrays） 、自动识别 (Auto) 、所有值(ALL) 的时候
都会造成反序列化漏洞，为此官方文档里也标注了警告，当您的应用程序从外部源反序
列化 JSON 时应谨慎使用 TypeNameHandling。 
云影实验室
 6 / 17  
笔者继续选择 ObjectDataProvider 类方便调用任意被引用类中的方法，具体有关此类
的用法可以看一下《.NET 高级代码审计（第一课）XmlSerializer 反序列化漏洞》，首先
来序列化 TestClass  
指定 TypeNameHandling.All、TypeNameAssemblyFormatHandling.Full 后得到序
列化后的 Json 字符串 
{"$type":"System.Windows.Data.ObjectDataProvider, PresentationFramework, 
Version=4.0.0.0, Culture=neutral, 
PublicKeyToken=31bf3856ad364e35","ObjectInstance":{"$type":"WpfApp1.Tes
tClass, WpfApp1, Version=1.0.0.0, Culture=neutral, 
PublicKeyToken=null","Name":null,"Age":0},"MethodName":"ClassMethod","M
ethodParameters":{"$type":"MS.Internal.Data.ParameterCollection, 
PresentationFramework, Version=4.0.0.0, Culture=neutral, 
PublicKeyToken=31bf3856ad364e35","$values":["calc.exe"]},"IsAsynchronous":
false,"IsInitialLoadEnabled":true,"Data":null,"Error":null} 
如何构造 System.Diagnostics.Process 序列化的 Json 字符串呢？笔者需要做的工作替
换掉 ObjectInstance 的$type、MethodName 的值以及 MethodParameters 的$type
值，删除一些不需要的 Member、最终得到的反序列话 Json 字符串如下 
云影实验室 
 7 / 17  
{ 
                '$type':'System.Windows.Data.ObjectDataProvider, 
PresentationFramework, Version=4.0.0.0, Culture=neutral, 
PublicKeyToken=31bf3856ad364e35',  
                'MethodName':'Start', 
                'MethodParameters':{ 
                    '$type':'System.Collections.ArrayList, mscorlib, Version=4.0.0.0, 
Culture=neutral, PublicKeyToken=b77a5c561934e089', 
                    '$values':['cmd','/c calc'] 
                }, 
                'ObjectInstance':{'$type':'System.Diagnostics.Process, System, 
Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'} 
} 
再经过 JsonConvert.DeserializeObject 反序列化（注意一点指定
TypeNameHandling 的值一定不能是 None），成功弹出计算器。 
云影实验室
 8 / 17  
2.3、攻击向量—WindowsIdentity 
WindowsIdentity 类位于 System.Security.Principal 命名空间下。顾名思义，用于表
示基于 Windows 认证的身份，认证是安全体系的第一道屏障肩负着守护着整个应用或
者服务的第一道大门，此类定义了 Windows 身份一系列属性 
对于用于表示认证类型的 AuthenticationType 属性来说，在工作组模式下返回 NTLM。
对于域模式，如果操作系统是 Vista 或者以后的版本，该属性返回 Negotiate，表示采
用 SPNEGO 认证协议。而对于之前的 Windows 版本，则该属性值为 Kerberos。
Groups 属性返回 WindowsIdentity 对应的 Windows 帐号所在的用户组（User 
Group），而 IsGuest 则用于判断Windows帐号是否存在于 Guest 用户组中。IsSystem
属性则表示 Windows 帐号是否是一个系统帐号。对于匿名登录，IIS 实际上会采用一个
预先指定的 Windows 帐号进行登录。而在这里，IsAnonymous 属性就表示该
WindowsIdentity 对应的 Windows 帐号是否是匿名帐号。 
2.3.1、ISerializable 
跟踪定义得知继承于 ClaimsIdentity 类，并且实现了 ISerializable 接口  
查看定义得知，只有一个方法 GetObjectData 
云影实验室 
 9 / 17  
在.NET 运行时序列化的过程中 CLR 提供了控制序列化数据的特性，如：OnSerializing、
OnSerialized、NonSerialized 等。为了对序列化数据进行完全控制，就需要实现
Serialization.ISeralizable 接口，这个接口只有一个方法，即 GetObjectData，第一个
参数 SerializationInfo 包含了要为对象序列化的值的合集，传递两个参数给它：Type
和 IFormatterConverter，其中 Type 参数表示要序列化的对象全名（包括了程序集名、
版本、公钥等），这点对于构造恶意的反序列化字符串至关重要 
另一方面 GetObjectData 又调用 SerializationInfo 类提供的 AddValue 多个重载方法
来指定序列化的信息，AddValue 添加的是一组 ；GetObjectData 负责添
加好所有必要的序列化信息。 
2.3.2、ClaimsIdentity 
ClaimsIdentity（声称标识）位于 System.Security.Claims 命名空间下，首先看下类的
定义 
云影实验室
 10 / 17  
其实就是一个个包含了 claims 构成的单元体，举个栗子：驾照中的“身份证号码：
000000”是一个 claim、持证人的“姓名: Ivan1ee”是另一个 claim、这一组键值对构
成了一个 Identity，具有这些 claims 的 Identity 就是 ClaimsIdentity，通常用在登录
Cookie 验证，如下代码 
一般使用的场景我想已经说明白了，现在来看下类的成员有哪些，能赋值的又有哪些？ 
参考官方文档可以看到 Lable、BootstrapContext、Actor 三个属性具备了 set 
云影实验室 
 11 / 17  
查阅文档可知，这几个属性的原始成员分别为 actor、bootstrapContext、lable 如下 
ClaimsIdentity 类初始化方法有两个重载，并且通过前文介绍的 SerializationInfo 来传
入数据，最后用 Deserialize 反序列化数据。 
云影实验室
 12 / 17  
追 溯 的 过 程 有 点 像 框 架 类 的 代 码 审 计 ， 跟 踪 到 Deserialize 方 法 体 内 ， 查 找
BootstrapContextKey 才知道原来它还需要被外层 base64 解码后带入反序列化 
2.3.3、打造 Poc 
回过头来想一下，如果使用 GetObjectData 类中的 AddValue 方法添加“key : 
System.Security.ClaimsIdentity.bootstrapContext“、”value :  base64 编码后的
payload“，最后实现 System.Security.Principal.WindowsIdentity.ISerializable 接口
就能攻击成功。首先定义 WindowsIdentityTest 类 
笔者用 ysoserial 生成反序列化 Base64 Payload 赋值给 BootstrapContextKey，实现
代码如下 
云影实验室 
 13 / 17  
到这步生成变量 obj1 的值就是一段 poc，但还需改造一下，将$type 值改为
System.Security.Principal.WindowsIdentity 完全限定名 
最后改进后交给反序列化代码执行，抛出异常之前触发计算器，效果如下图 
云影实验室
 14 / 17  
0x03 代码审计视角 
从代码审计的角度其实很容易找到漏洞的污染点，通过前面几个小节的知识能发现需要
满足一个关键条件非 TypeNameHandling.None 的枚举值都可以被反序列化，例如以
下 Json 类 
都设置成 TypeNameHandling.All，攻击者只需要控制传入参数 _in 便可轻松实现反序
列化漏洞攻击。Github 上很多的 json 类存在漏洞，例如下图 
云影实验室 
 15 / 17  
代码中改用了 Auto 这个值，只要不是 None 值在条件许可的情况下都可以触发漏洞，
笔者相信肯定还有更多的漏洞污染点，需要大家在代码审计的过程中一起去发掘。 
0x04 案例复盘 
最后再通过下面案例来复盘整个过程，全程展示在 VS 里调试里通过反序列化漏洞弹出
计算器。 
1. 
输入 http://localhost:5651/Default Post 加载 value 值 
2. 
通过 JsonConvert.DeserializeObject 反序列化 ，并弹出计算器 
云影实验室
 16 / 17  
最后附上动图 
0x05 总结 
Newtonsoft.Json 库在实际开发中使用率还是很高的，攻击场景也较丰富，作为漏洞挖
掘者可以多多关注这个点，攻击向量建议选择 ObjectDataProvider，只因生成的 Poc
体积相对较小。最后.NET 反序列化系列课程笔者会同步到 
https://github.com/Ivan1ee/ 、https://ivan1ee.gitbook.io/ ，后续笔者将陆续推出
高质量的.NET 反序列化漏洞文章，欢迎大伙持续关注，交流，更多的.NET 安全和技巧
可关注实验室公众号或者笔者的小密圈。 
云影实验室 
 17 / 17