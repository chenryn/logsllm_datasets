title:Trust Negotiation with Hidden Credentials, Hidden Policies, and Policy
Cycles
author:Keith B. Frikken and
Jiangtao Li and
Mikhail J. Atallah
Trust Negotiation with Hidden Credentials, Hidden Policies, and Policy Cycles ∗
Keith B. Frikken
Jiangtao Li Mikhail J. Atallah
Department of Computer Science, Purdue University, West Lafayette, Indiana
{kbf, jtli, mja}@cs.purdue.edu
Abstract
a substantial extension of the state-of-the-art in privacy-
preserving trust negotiations.
In an open environment such as the Internet, the decision
to collaborate with a stranger (e.g., by granting access to a
resource) is often based on the characteristics (rather than
the identity) of the requester, via digital credentials: Access
is granted if Alice’s credentials satisfy Bob’s access policy.
The literature contains many examples where protecting the
credentials and the access control policies is useful, and
there are numerous protocols that achieve this. In many of
these schemes, the server does not learn whether the client
obtained access (e.g., to a message, or a service via an e-
ticket). A consequence of this property is that the client can
use all of her credentials without fear of “probing” attacks
by the server, because the server cannot glean information
about which credentials the client has (when this property is
lacking, the literature uses a framework where the very use
of a credential is subject to a policy speciﬁc to that creden-
tial). The main result of this paper is a protocol for negoti-
ating trust between Alice and Bob without revealing either
credentials or policies, when each credential has its own ac-
cess policy associated with it (e.g., “a top-secret clearance
credential can only be used when the other party is a gov-
ernment employee and has a top-secret clearance”). Our
protocol carries out this privacy-preserving trust negotia-
tion between Alice and Bob, while enforcing each creden-
tial’s policy (thereby protecting sensitive credentials). Note
that there can be a deep nesting of dependencies between
credential policies, and that there can be (possibly over-
lapping) policy cycles of these dependencies. Our result
is not achieved through the routine use of standard tech-
niques to implement, in this framework, one of the known
strategies for trust negotiations (such as the “eager strat-
egy”). Rather, this paper uses novel techniques to imple-
ment a non-standard trust negotiation strategy speciﬁcally
suited to this framework (and in fact unusable outside of this
framework, as will become clear). Our work is therefore
∗Portions of this work were supported by Grants IIS-0325345, IIS-
0219560, IIS-0312357, and IIS-0242421 from the National Science Foun-
dation, Contract N00014-02-1-0364 from the Ofﬁce of Naval Research, by
sponsors of the Center for Education and Research in Information Assur-
ance and Security, and by Purdue Discovery Park’s e-enterprise Center.
1
Introduction
Whereas in the past access decisions were based on the
identity of the entity requesting a resource, in open systems
such as the Internet, this approach is ineffective when the re-
source owner and the requester belong to different security
domains that are controlled by different authorities, possi-
bly unknown to each other. One alternative is to use digital
credentials for satisfying access control policies [3, 12, 21].
Digital credentials are digitally signed assertions about the
credential owner by a credential issuer. Each digital cre-
dential contains an attribute (or set of attributes) about the
owner. The decision to grant access to a resource is based on
the attributes in the requester’s credentials, such as citizen-
ship, security clearance, employment, group membership,
credit status, etc.
A typical scenario for accessing a resource using digital
credentials is for the requester, Alice, to send her request to
the resource owner, Bob. Bob then responds with the policy
that governs access to that resource. If Alice’s credentials
satisfy Bob’s policy, she sends the appropriate credentials to
Bob. After Bob receives the credentials and veriﬁes them,
he grants Alice access to the resource. Observe that, in this
scenario, Alice learns Bob’s policy and Bob learns Alice’s
credentials. Such a strategy is straightforward and efﬁcient,
however it is unacceptable if the credentials or the access
control policies are considered to be sensitive information.
Clearly, it is advantageous for the requester to protect her
credentials, as revealing them may violate her personal pri-
vacy. The motivation for hiding the policy is not necessarily
protection from an evil adversary. It could simply be the de-
sire to prevent legitimate users from “gaming” the system
– e.g., changing their behavior based on their knowledge
of the policy (which can render an economically-motivated
policy less effective). This is particularly important for poli-
cies that are not incentive-compatible in economic terms
(e.g., they suffer from perverse incentives in that they re-
1
ward the wrong kinds of behavior, such as free-loading). Or
it could be that the policy is a commercial secret – e.g., Bob
has pioneered a novel way of doing business, and knowl-
edge of the policy would compromise Bob’s strategy and
invite unwelcome imitators. Finally, a process that hides Al-
ice’s credentials from Bob is ultimately not only to Alice’s
advantage but also to Bob’s: Bob no longer needs to worry
about rogue insiders in his organization illicitly leaking or
selling Alice’s private information, and may even lower his
liability insurance rates as a result. Privacy-preservation is
a win-win proposition, one that is appealing even if Alice
and Bob are honest and trustworthy entities.
For these and other similar reasons, there has been a sub-
stantial amount of recent work [17, 6, 14] on performing
this type of attribute-based access control while protect-
ing Alice’s credentials and Bob’s policies. One assump-
tion of these schemes is that the resource owner does not
learn whether the requester obtained access. When this is
the case, the requester can use all of her credentials without
regard to their sensitivity level, as these schemes do not leak
the requester’s credentials to the service provider. However,
this “resource owner does not learn” property may not hold
in practice for the following two reasons:
1. In many scenarios, the server grants access to services
rather than messages. Thus, for certain types of ser-
vices, the server has to know whether the client got
access to the services. In fact there are audit and ac-
counting requirements that cause many organizations
to require learning whether access took place.
2. Even if the server offers messages rather than services,
message requests are not independent in most systems.
For example, suppose a client requests message M1,
which contains a hyperlink to message M2, and that
same client subsequently requests M2 a few minutes
later; although the server does not learn for certain that
the client successfully obtained M1, inferences can be
made.
For the above reasons, the server could learn whether the
client obtained access. This may seem like an insigniﬁcant
bit of information, but since the server can set his policy to
be an arbitrary function, this enables the server to probe the
client for sensitive credentials. For example, the server may
intentionally set his access control policy to be “only people
with top-secret clearance can access the resource”. When
the client obtains access, the server learns immediately that
the client has a top-secret clearance credential.
This Sensitive CredentiAl Leakage Problem (SCALP) is
not due to any ﬂaw or weakness in the previous protocols
(e.g., [17, 6, 14]) but rather exists in any situation where the
server can link transactions to the same client and has ar-
bitrary freedom when creating the access control policy. In
such situations, the client may understandably have legiti-
mate concerns about using credentials that she deems sensi-
tive – in fact the client may be required to protect certain
credentials (e.g., a top-secret clearance credential). This
poses a problem for the previous schemes, which require
the client’s ability to use all of her credential set. There-
fore, there is a need for a trust negotiation system that can
mitigate these concerns.
In traditional trust negotiation [30, 32, 25, 34, 33, 29]
the notion of sensitive credential protection has been well
studied (see Section 3).
In these schemes, each sensitive
credential has an access control policy – a credential is used
(or revealed) only when the other party satisﬁes the policy
for that credential. This does not prevent SCALP, but it does
allow the user to control the potential leakage of her creden-
tials. The schemes in [14, 17, 6] did not reveal credentials
but could not handle policies for credentials (i.e., they dealt
with the easier special case where each credential’s access
control policy was unconditionally “true”). The present pa-
per is the ﬁrst to combine the techniques for hidden cre-
dentials with the notion of policies for sensitive credentials.
These credential policies have to be considered sensitive as
well, because otherwise the server (or client) can game the
system in many ways. For example, if the client knows the
access control policies for the server’s credentials then she
will know the path of least resistance to unlock certain cre-
dentials and thus she will be able to probe more easily.
The rest of this paper is organized as follows. We begin
with a detailed description of our contributions in Section 2.
We review trust negotiation and propose a new deﬁnition of
trust negotiation that supports policy cycles in Section 3.
Next, we formally introduce our approach to trust negotia-
tion in Section 4, and then we review some cryptographic
tools in Section 5. We present our protocol for privacy-
preserving trust negotiation in Section 6. We give efﬁciency
improvements for our base scheme in section 7. We give a
sketch of the proof of security in Section 8. We discuss the
related work in Section 9, and we conclude in Section 10.
2 Our Contributions
We introduce a protocol for privacy-preserving trust ne-
gotiation, where the client and server each input a set of
credentials along with an access control policy for each of
their credentials. The protocol determines the set of usable
credentials between the client and the server, and then will
process the resource or service request based on the client’s
usable credentials. A credential is usable if its access con-
trol policy has been satisﬁed by the other party. Our proto-
col is complicated by the fact that: (1) the policies for sen-
sitive credentials may themselves be sensitive and therefore
cannot be revealed, (2) the client should not learn informa-
tion about which of her credentials or the server’s creden-
tials are usable, and (3) the server should not learn informa-
tion about which of his credentials or the client’s credentials
are usable. The rationale for requirement (1) was given in
the previous section. Requirements (2) and (3) are because,
if the client or server were to learn which of its credentials
are usable, then this would reveal more information about
the other party’s credential set and thus facilitate probing
attacks. The technical contributions of this paper include:
1. We develop a new privacy-preserving trust negotiation
protocol and several novel cryptographic protocols for
carrying it out. One of the challenges is the distinction
between having a credential and being able to use that
credential (when its access control policy has been sat-
isﬁed), while requiring that “not having” a credential
be indistinguishable from “having but being unable to
use” a credential.
2. We propose a reverse eager trust negotiation strat-
egy (denoted as RE strategy) that handles arbitrary
policy cycles, whereas the existing traditional trust-
negotiation strategies (such as the eager strategy [30])
are inherently unable to handle such cycles (even if
these strategies were properly implemented in this
framework).
3 Trust Negotiation: Review and Discussion
In trust negotiation [30, 32, 25, 34, 28, 33, 29], the dis-
closure of a credential s is controlled by an access con-
trol policy ps that speciﬁes the prerequisite conditions that
must be satisﬁed in order for credential s to be disclosed.
Typically, the prerequisite conditions are a set of creden-
tials C ⊆ C, where C is the set of all credentials. As
in [30, 32, 25, 34, 33], the policies in this paper are mod-
eled using propositional formulas. Each policy ps takes
the form s ← φs(c1, . . . , ck) where c1, . . . , ck ∈ C and
φs(c1, . . . , ck) is a normal formula consisting of literals
ci, the Boolean operators ∨ and ∧, and parentheses (if
needed). In this paper, s is referred to as the target of ps,
and φs(c1, . . . , ck) is referred to as the policy function of
ps.
Given a set of credentials C ′ ⊆ C and a policy function
φs(c1, . . . , ck), we denote φs(C ′) as the value of the normal
formula φs(x1, . . . , xk) where xi = 1 if and only if ci ∈ C ′
(otherwise xi = 0). For example, if φs = (c1 ∧ c2) ∨ c3,
then φs({c1, c2, c4}) = 1 and φs({c1, c4}) = 0. Policy
ps is satisﬁed by a set of credentials C ′ ⊆ C if and only
if φs(C ′) = 1. During trust negotiation, one can disclose
credential s if φs(C ′) = 1 where C ′ is the set of credentials
that she has received from the other party.
A trust negotiation protocol is normally initiated by a
client requesting a resource from a server. The negotiation
consists of a sequence of credential exchanges. Trust is es-
tablished if the initially requested resource is granted and
all policies for disclosed credentials are satisﬁed [30, 32].
In this case, the negotiation between the client and server
is a successful negotiation, and otherwise, it is a failed ne-
gotiation. We give the formal deﬁnition for traditional trust
negotiation as follows:
Deﬁnition 1 (Traditional Trust Negotiation) Let CS and
PS (CC and PC) be the sets of credentials and policies pos-
sessed by a negotiating server (client). The negotiation is
1 from the client. The
initiated by a request for s ∈ CS
goal of trust negotiation is to ﬁnd a credential disclosure
sequence (c1, . . . , cn = s), where ci ∈ CS ∪ CC, and such
that for each ci, 1 ≤ i ≤ n, the policy for ci is satisﬁed by
the credentials already disclosed, i.e., φci(Sj<i cj) = 1. If
the client and server ﬁnd a credential disclosure sequence,
the negotiation succeeds, otherwise, it fails.
The sequence of disclosed credentials depends on the
decisions of each party; these decisions are referred to as
a strategy. A strategy controls which credentials are dis-
closed, when to disclose them, and when to terminate a ne-
gotiation [34]. Several negotiation strategies are proposed
in [30, 32, 34]. For example, in the eager strategy [30],
two parties take turns disclosing a credential to the other
side as soon as the access control policy for that credential
is satisﬁed. For the reader unfamiliar with the eager strat-
egy, we describe it in more detail in Appendix A. Although
the cryptographic contributions of this paper will make it
possible to implement the eager strategy in the framework
considered, we do not pursue this approach because it fails
to handle policy cycles. In fact, if there is a policy cycle,
the trust negotiation will fail under Deﬁnition 1. We now
propose a new deﬁnition of trust negotiation that supports
policy cycles.
Deﬁnition 2 (Cycle-Tolerant Trust Negotiation) Let CS
and PS (CC and PC) be the sets of credentials and policies
possessed by a negotiating server (client). The negotiation
is initiated by a request for s ∈ CS from the client. The
negotiation between the client and server succeeds if there
exists usable credential sets US ⊆ CS and UC ⊆ CC for
the server and client respectively, such that (1) s ∈ US, (2)
∀c ∈ US, φc(UC) = 1, and (3) ∀c ∈ UC, φc(US) = 1.
Otherwise, the negotiation fails.
Note that the above deﬁnition allows for many possible
UC, US solution pairs, and does not capture any notion of
minimality for such pairs: Some solution pair may be a
proper subset of some other pair, and either of them is con-
sidered acceptable. This is ﬁne in the framework of this pa-
per, because at the end of the negotiation nothing is revealed