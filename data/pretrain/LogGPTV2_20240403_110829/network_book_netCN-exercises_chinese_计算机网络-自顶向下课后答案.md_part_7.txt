R9、接收机需要序列号来确定到达的数据包是包含新数据还是是重传。
R10、处理通道中的损失。如果在该分组的计时器持续时间内未接收到发送分组的ACK，则假定该分组(或其ACK或NACK)已丢失。因此，分组被重传。
R11、在RDT 3.0协议中仍然需要计时器。如果知道往返时间，那么唯一的优势是，发送方肯定知道数据包或数据包的ACK(或Nack)已经丢失，而实际情况是，在计时器过期后，ACK(或Nack)可能仍在发送方的途中。然而，要检测丢失，对于每个包，一个持续时间不变的定时器仍然需要在发送者。
R12、
a)丢包造成一段时间后，所有五个包都被重传。
b)由于Go-Back-N使用累积数据，ACK的丢失没有触发任何重传承认。
c)发送方无法发送第六个分组，因为发送窗口大小固定为5。
R13、
a)当分组丢失时，接收的4个分组被缓冲接收器。完成后超时，发送方重新发送丢失的数据包，接收方传送缓冲的数据包数据包以正确的顺序应用。
b)接收器为丢失的ACK发送了重复ACK。
c)发送窗口大小固定为5时，发送方无法发送第六数据包当分组丢失时，返回-N重传所有的分组，而选择性地重传所有的分组。仅重发丢失的数据包。在丢失确认的情况下，选择性重复发送重复ACK，并作为返回-N使用的累积确认，不需要重复ACK。
R14、
a)假
b)假
c)真
d)假
e)真
f)假
g)假
R15、
a) 20 bytes 
b) ack number = 90 
R16、3段。第一段：SEQ=43，ack=80；第二段：SEQ=80，ack=44；第三段；seq=44，ack=81
R17、R/2 
R18、false，它设置为拥塞窗口的当前值的一半。
R19、让X=RTTTFE，Y=RTTTBE和ST=搜索时间。考虑以下时序图。
![avater](./img/18.png)
客户端和服务器(后端)之间使用代理(前端)之间的TCP数据包交换图。
从这个图中我们可以看到，总时间是4XYST=4*RTTFE RTTBE搜索时间。
[Back to Index](#目录)
## 问题3 
R1、
||source port numbers | destination port numbers | 
|---|---|---|
|a) A→S| 467 |23 |
|b) B→S |513 |23 |
|c) S→A |23 |467 |
|d) S→B |23| 513 |
e) Yes. 
f) No. 
P2、假设主机A、B和C的IP地址分别为a、b、c。（请注意，a，b， c各不相同）。
主机A：源端口=80，源IP地址=b，DEST端口=26145，DESTIP地址=a 
到主机C，左进程：源端口=80，源IP地址=b，DEST端口=7532，DESTIP 地址=c 
到主机C，右进程：源端口=80，源IP地址=b，DEST端口=26145，DEST IP地址=c。
P3、注意，如果溢出，请绕一圈。
```
   1 0 1 1 1 0 0 1
 + 0 1 1 0 0 1 1 0
------------------
   0 1 0 1 0 0 1 1
   0 1 1 1 0 1 0 0
 + 1 0 1 1 1 0 0 1
 -----------------
   0 0 1 0 1 1 1 0
```
补码为： 1 1 0 1 0 0 0 1
为了检测错误，接收方添加四个单词(三个原始单词和校验和)。如果和包含一个零，接收器知道有一个错误。所有的一位错误都会被检测到，但是两位错误可以不被检测到(例如，如果第一个单词的最后一个数字被转换为0，第二个单词的最后一个数字被转换为1)。
P4、
a)将这两个字节相加得到11000001。取一个人的补给量就等于00111110。
b)把这两个字节相加，等于01000000；补码等于10111111。
c)第一个字节=01010100；第二个字节=01101101。
P5、不，接收方不能完全确定没有发生任何位错误。这是因为计算数据包的校验和的方式。如果包中两个16位字的对应位(相加在一起)是0和1，那么即使这些位分别翻转到1和0，和仍然保持不变。因此，接收方计算的1s补码也将是相同的。这意味着，即使存在传输错误，校验和也将进行验证。
P6、假设发送方处于“从上面等待呼叫1”状态，而接收方(作业问题中显示的接收方)处于“从下面等待1”状态。发送方发送一个序列号为1的数据包，并转换为“等待ACK或NAK 1”，等待ACK或NAK。现在假设接收方正确地接收序列号为1的数据包，发送一个ACK，然后转换为状态“从下面等待0”，等待序列号为0的数据包。但是，ACK已损坏。当rdt2.1发送方获得损坏的ACK时，它用序列号1重新发送数据包。然而，接收方正在等待序列号为0的数据包，并且(如家务问题所示)总是在没有得到序列号为0的数据包时发送NAK。因此，发送方将始终发送一个序列号为1的数据包，而接收方将始终锁定该数据包。也不会从那个州前进。
P7、要想最好地回答这个问题，首先考虑一下为什么我们需要序列号。我们看到发送方需要序列号，以便接收方能够判断数据包是否是已经接收到的数据包的副本。在ACK的情况下，发送方不需要这个信息(即ACK上的序列号)来判断是否检测到重复的ACK。对于rdt3.0接收器来说，一个重复的ACK是显而易见的，因为当它接收到原始ACK时，它会转换到下一个状态。重复的ACK不是发送方需要的ACK，因此被rdt3.0发送方忽略。
P8、协议rdt3.0的发送方与协议2.2的发送方不同，因为已经添加了超时。我们已经看到，超时的引入增加了在发送方到接收方数据流中重复数据包的可能性。然而，协议rdt.2.2中的接收方已经可以处理重复的数据包。(如果接收方发送丢失的ACK，然后发送方重新传输旧数据，则RDT 2.2中的接收方重复出现)。因此，协议rdt2.2中的接收器也将作为协议rdt3.0中的接收器工作。
P9、假设协议已经运行了一段时间。发送方处于“从上等待呼叫”状态(左上角)，接收方处于“从下等待0”的状态。图1显示了损坏的数据和损坏的ACK的场景。
![avater](./img/19.png)
P10、在这里，我们添加一个计时器，它的值大于已知的往返传播延迟.我们将超时事件添加到“等待ACK或NAK 0”和“等待ACK或NAK 1”状态。如果发生超时事件，则重新发送最近发送的数据包。让我们看看为什么这个协议仍将与rdt2.1接收器一起工作。
- 假设超时是由丢失的数据包引起的，即发送方到接收方通道上的数据包。在这种情况下，接收机从未接收到先前的传输，并且从接收机的角度来看，如果接收到超时重传，它看起来与接收到的原始传输完全相同。
- 假设现在一个ACK丢失了。接收器最终会在超时时重新发送数据包。但是，重传与ACK被混淆时的动作完全相同。因此，发送者的反应与损失是一样的，就像混乱的ACK一样。RDT 2.1接收器已经可以处理混淆的ACK的情况。
P11、如果删除了该消息的发送,发送和接收侧将死锁，等待永远不会发生的事件。以下是一种场景：
- sender发送pKT0，输入“等待Ack0状态”，等待数据包返回来自接收机
- 接收器处于“从下面等待0”状态，接收到损坏的数据包来自发送方。假设它不发送任何信息，只需重新输入“等待0”处于“下”状态。
现在,ender正在等待来自接收机的某种类型的ACK,并且接收机等待数据包形成发送方-死锁！
P12、该协议仍在工作，因为如果重新传输将是如果接收到错误的分组实际上已经丢失(并且从接收机的观点来看，它从不知道这些事件中的哪一个发生（如果有的话）。
为了解决这个问题背后的更微妙的问题，一个必须允许过早的发生超时。在这种情况下，如果分组的每个额外副本被确认并且每个副本接收的额外ACK导致要发送的当前分组的另一个额外拷贝，发送分组N的次数将随着N接近无穷大而不受限制地增加。
P13、
![avater](./img/20.png)
P14、在仅NAK协议中，只有当接收到分组x1时，接收方才检测丢包x。也就是说，接收器接收x-1，然后x-1，只有当接收到x 1时，接收器才会意识到x被忽略了。如果x的传输和x1的传输之间存在很长的延迟，那么在只使用NAK协议下，需要很长时间才能恢复x。
另一方面，如果数据经常被发送，那么以NAK为唯一方案的恢复可能会很快发生。此外，如果错误很少发生，那么Naks只是偶尔被发送(当需要时)，并且ACK永远不会被发送--NAK中的反馈大大减少--仅在ACK的情况下才发送。
P15、发送数据包需要12微秒(或0.012毫秒)，作为1500*8/109=12微秒。为了使发送者在98%的时间里忙碌，我们必须使用util=0.98=(0.012n)/30.012或n大约2451个数据包。
P16、是。这实际上会导致发送方向通道发送大量流水线数据。
是。这里有一个潜在的问题。如果数据段丢失在通道中，那么RDT 3.0的发送方将不会重新发送这些段，除非应用程序中有一些从丢失中恢复的额外机制。
P17、
![avater](./img/21.png)
P18、在我们的解决方案中，发送方将等待接收到一对消息(seqnum和seqnum 1)的ACK，然后再转到下一对消息。数据包有一个数据字段，并携带两位序列号.也就是说，有效序列号为0、1、2和3。(注意：您应该考虑为什么1位序列号空间0，1在下面的解决方案中不能工作。)ACK消息携带他们正在确认的数据包的序列号。
发送方和接收方的FSM如图2所示。请注意，发送方状态记录：(I)当前对未收到ACK，(Ii)接收到用于seqnum(仅)的ACK，或接收到用于seqnum 1的ACK(仅)。在这个图中，我们假设seqnum最初为0，并且发送者已经发送了第一个两个数据消息（获取要进行的事情）。发送方和接收方的时间线跟踪从丢失的数据包中恢复如下所示：
![avater](./img/22.png)
![avater](./img/23.png)
图2：问题的发送方和接收方(3.18)
|Sender |Receiver| 
|---|---|
|make pair (0,1) ||
|send packet 0 ||
|Packet 0 drops ||
|send packet 1 ||
||receive packet 1 |
||buffer packet 1 |
||send ACK 1 |
|receive ACK 1 ||
|(timeout) ||
|resend packet 0 ||
||receive packet 0 |
||deliver pair (0,1) |
||send ACK 0 |
|receive ACK 0||
P19、这个问题是简单停止和等待协议(rdt3.0)上的一个变化。由于信道可能丢失消息，并且由于发送方可能重新发送其中一个接收方已经接收到的消息(要么由于过早超时，要么由于另一个接收方尚未正确接收数据)，因此需要序列号。在rdt3.0中，0位序列号在这里就足够了。
发送方和接收方FSM如图3所示。在此问题中，发送方状态指示发送方是否从B(仅)、从C(仅)或从非C或B接收到ACK。接收方状态指示接收方正在等待哪个序列号。
![avater](./img/24.png)
![avater](./img/25.png)
P20、
![avater](./img/26.png)
图4：3.18的接收端FSM
发送方FSM完全相同，如图3.15中的文本所示
P21、由于A-to-B信道可能丢失请求消息,A将需要超时,并且重新发送其请求消息（能够从丢失中恢复）。因为信道延迟是可变的且unknown,可能A将发送重复的请求(即,重新发送已经被b)接收到的请求消息。为了能够检测重复请求消息，协议将使用序列号。1位序列数量将足以用于停止和等待类型的请求/响应协议。A（请求者）有4个状态：
- “从上面等待请求0。”在这里，请求者正在等待一个呼叫以请求数据单元。当接收到上述请求时，它发送一个请求消息R0，到B，启动计时器，并向“等待”过渡D0”状态。当在“等待来自以上“状态”的请求0，A忽略从B收到的任何东西。
- “等D0”在这里，请求者正在等待来自B的D0数据消息。定时器总是在这种状态下运行。如果计时器过期，A将发送另一条R0消息，重新启动定时器并保持此状态。如果从B接收到D0消息，A将停止时间并传输到“从上面等待请求1”状态。如果A在此状态下接收D1数据消息，则忽略它。
- “等待上面的请求1。”在这里，请求者再次等待来自上面的呼叫来请求一个数据单元。当它从上面接收到一个请求时，它向B发送一个请求消息R1，启动一个定时器并转换到“等待D1”状态。当处于“等待上述请求1”状态时，A会忽略从B接收的任何内容。
- “等待D1”。在这里，请求者正在等待来自B的d1数据消息。定时器总是在这种状态下运行。如果计时器过期，A将发送另一条R1消息，重新启动定时器并保持此状态。如果从B接收到D1消息，A将停止定时器并传输到“从上面等待请求0”状态。如果A在此状态下接收到D0数据消息，则忽略它。
数据供应商(B)仅有两种状态:
- 在此状态下的“发送D0。”，B继续响应收到的R0消息。发送D0，然后保持在该状态。如果B收到R1消息，则它知道其D0消息已正确接收。因此它丢弃该D0数据（由于它已在另一侧收到），然后过渡到“发送D1”状态，其中它将使用d1来发送下一个请求的数据块。
- “发送D1”在这种状态下，B继续通过发送D1来响应接收到的R1消息，然后保持这种状态。如果B接收到R1消息，则它知道其D1消息已被正确接收，从而传输到“发送D1”状态。