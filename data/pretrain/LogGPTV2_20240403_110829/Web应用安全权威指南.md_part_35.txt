综上所述，产生 OS 注入漏洞的情况有如下两类。
> -   通过 Shell 调用 OS 命令时，没有转义 Shell 的元字符
>
> -   使用了内部调用 Shell 的函数
下面就让我们来依次看一下这两种情况。
-   **在 Shell 中执行多条命令**
    Shell 提供了通过指定 1 行来启动多个程序的方法。而 OS
    命令注入攻击就是恶意利用了 Shell 能够启动多个程序的特性。比如，在
    Unix 的 Shell 中，能够使用以下写法。
    **执行例 在 Shell 中执行多条命令**
    ![{%}](Image00152.jpg)
    Windows 的 cmd.exe 中能够使用 & 来连续执行多条命令（同 Unix 的
    ;）。另外 \|（管道功能）、&& 或 \|\| 的用法也和 Unix 一样
    [60]{.注释编号} 。
    Shell 中拥有特殊意义的字符（如 ;、\| 等）被称为 Shell
    的元字符。把元字符当作普通字符使用时需要对其进行转义。但由于 Shell
    的元字符的转义方法很复杂，因此此处不做说明，详情可以参考 Shell
    的相关手册。
    而如果在指定 OS 命令参数的字符串中混入了 Shell
    的元字符，就会使得攻击者添加的 OS 命令被执行，这也就是 OS
    命令注入漏洞产生的原因。
-   **使用了内部调用 Shell 的函数**
    Perl 的 `open` 函数，顾名思义，是用于打开文件的函数。然而根据 `open`
    的调用方法的不同，有些情况下会通过 Shell 执行 OS 命令。例如，通过
    `open` 函数启动 Linux 的 pwd
    命令（显示当前目录名的命令）时，只要像下面的 CGI 脚本一样，调用
    `open` 函数时在命令名后面加上管道符号 \| 即可。
    > **代码清单 /4b/4b-003.cgi**
    ``` 代码无行号
    #!/usr/bin/perl
    print "Content-Type: text/plain\n\n";
    open FL, '/bin/pwd|' or die $!;
    print ;
    close FL;
    print "";
    ```
    执行该脚本后，当前目录名就会通过 pwd 命令显示出来。
    在使用了 Perl 的 `open`
    函数的脚本中，如果外界能够指定文件名，就能通过在文件名的前后加上管道符号
    \| 来实施 OS 命令注入攻击。
    接下来我们就来演示如何发动攻击。以下为一段 CGI
    脚本，其作用仅限于打开文件并将其显示。
    > **代码清单 /4b/4b-004.cgi**
    ``` 代码无行号
    #!/usr/bin/perl
    use strict;
    use utf8;
    use open ':utf8';  # 将默认字符编码设为 UTF-8
    use CGI;
    print "Content-Type: text/plain; charset=UTF-8\r\n\r\n";
    my $q = new CGI;
    my $file = $q->param('file');
    open (IN, $file) or die $!;  # 打开文件
    print ;       # 显示文件的全部内容
    close IN;         # 关闭文件
    ```
    如果将查询字符串中的 `file` 指定如下，/sbin
    目录下的文件一览就会被显示在页面上 [61]{.注释编号} 。
    ``` 代码无行号
    file=ls+/sbin|
    ```
    执行结果如下图所示。
    ![{%}](Image00153.jpg)
    **图 4-101 显示了 /sbin 目录的文件一览**
-   **安全隐患的产生原因总结**
    Web 应用的开发语言中，有些函数的内部实现利用了
    Shell。如果开发者使用了这些内部调用 Shell
    的函数，就可能会使得意料之外的 OS 命令被执行。这种状态被称为 OS
    命令注入漏洞。
    OS 命令注入漏洞的形成需要同时满足以下三项条件。
    -   使用了内部调用 Shell 的函数（`system` 、`open` 等）
    -   将外界传入的参数传递给内部调用 Shell 的函数
    -   参数中 Shell 的元字符没有被转义
[60]{.注释编号下}
详情请参考以下链接：
。
[61]{.注释编号下} 该脚本同时也存在目录遍历漏洞。详情请参考 4.10 节。
#### **对策**
为了防范 OS
命令注入漏洞，推荐大家使用下列方法中的任意一项，这里我们将以下四种方法按照推荐度由高到低进行了排序。
> -   选择不调用 OS 命令的实现方法
>
> -   避免使用内部调用 Shell 的函数
>
> -   不将外界输入的字符串传递给命令行参数
>
> -   使用安全的函数对传递给 OS 命令的参数进行转义
-   **在设计阶段决定对策方针**
    具体选择哪一项对策方法，应当在设计阶段就确定下来。为此，建议在各个设计阶段分别探讨以下内容。
    > 基本设计阶段
    >
    > 围绕代码实现方式的设计进行以下讨论。
    >
    > -   决定主要功能的代码实现方针
    >
    > -   尽量利用专门的程序库，迫不得已时再使用 OS 命令来实现
    >
    > 详细设计阶段
    >
    > -   设计各功能的详细的实现方式时，极力避免使用内部调用 Shell
    >     的函数
    >
    > -   只能使用内部调用 Shell
    >     的函数时，讨论决定是将参数固定，还是由标准输入来指定参数
    下面我们就来分别看一下各个方法的详情。
-   **选择不调用 OS 命令的实现方法**
    推荐度最高的方法为不调用 OS 命令，即不利用调用 Shell
    的功能。这样一来，既杜绝了 OS 命令注入漏洞混入的可能性，又消除了调用
    OS 命令的系统开销，能够从多方面提高应用的性能。
    下面是利用 PHP
    程序库重写之前的发送邮件脚本（/4b/4b-002.php）的例子。PHP
    中发送邮件时可以利用 `mb_send_mail` 函数。
    > **代码清单 /4b/4b-002a.php**
    ``` 代码无行号
    提问已受理
    ```
    然而，发送邮件的功能中可能会引入邮件头注入漏洞，详情请参考 4.9
    节。后面的一个示例脚本也有同样问题。
-   **避免使用内部调用 Shell 的函数**
    在不调用 OS 命令就无法实现所需功能的情况下，调用 OS
    命令时最好使用不经过 Shell 的函数。由于 PHP 中没有合适的函数
    [62]{.注释编号} ，因此这里以 Perl 为例进行讲解。而如果只是想了解 PHP
    中的对策方法，则可以跳过本小节而直接阅读下一小节。
    Perl 中也存在名为 `system` 的函数来启动 OS 命令。Perl 的 `system`
    函数有两种指定命令和参数的方法，即既可以在一个参数中将它们用空格相隔，也可以将它们分别指定为函数的不同参数。下面为
    Perl 脚本中启动 grep 命令的示例。
    首先是经过 Shell 的调用方法。此调用方法存在 OS 命令注入漏洞。
    ``` 代码无行号
    my $rtn = system("/bin/grep $keyword /var/data/*.txt");
    ```
    接下来是不经过 Shell 的调用方法。
    ``` 代码无行号
    my $rtn = system('/bin/grep', '--', $keyword, glob('/var/data/*.txt'));
    ```
    像上面这样分别指定命令名和参数时，由于不经过 Shell，因此 Shell
    的元字符（`;` 、`|` 、`` ` ``
    等）就会作为命令的参数被直接传递。也就是说，理论上不会产生 OS
    命令注入漏洞。
    `system` 函数的第 2 个参数中指定的
    \'\--\'，表示选项（Option）的指定已经结束，后面指定的都是选项以外的参数（Parameter）。如果不这样做，外界就可以通过
    -R 等第一个字符为 - 的关键字来任意指定选项。
    另外，`system` 函数的第 4 个参数中用到了 `glob`
    函数，它能通过展开通配符（\*.txt）来取得所有匹配的文件名（与 PHP 的
    `glob` 函数相同）。经过 Shell 调用命令时，Shell
    会展开通配符，而不经过 Shell 时就需要像本例一样自己手动展开通配符。
    在使用之前提到的 Perl 的 `open`
    函数时，可以采用以下任一方法来避免启动 Shell。
    -   使用 `sysopen` 函数来代替 `open` 函数
    -   在 `open` 函数的第 2 个参数中指定访问模式（如下）
        ``` 代码无行号
        open(FL, '\`     读写模式（覆盖）
      \`\>\>\`   读写模式（追加）
      \`\|-\`    打开程序管道
      \`-\|\`    从程序或命令的输出中取得数据
      ---------- ------------------------------
    比如，下面的例子中指定了 \|- 模式。这是 Perl5.8
    以后的版本支持的写法。此调用方法不经过 Shell，因此理论上不会产生 OS
    命令注入漏洞。
    > **代码清单 /4b/4b-002b.cgi**
    ``` 代码无行号
        #!/usr/bin/perl
        use strict;
        use CGI;
        use utf8;
        use Encode;
        my $q = new CGI;
        my $mail = $q->param('mail');
        # 在不经过 Shell 的情况下将 sendmail 命令作为管道打开
        open (my $pipe, '|-', '/usr/sbin/sendmail', $mail) or die $!;
        # 传入邮件内容
        print $pipe encode('UTF-8', <<EndOfMail);
        To: $mail
        From: webmaster\@example.jp
        Subject: =?UTF-8?B?5M+X44GR5LuM44GR44G+44GX44Gf?=
        Content-Type: text/plain; charset="UTF-8"
        Content-Transfer-Encoding: 8bit
        提问已受理
        EndOfMail