 签名（来自/sigs目录），并在这个过程中将501个函数识别为库函数。你不需要对这501个函数进行逆向工程处理。
至少在两种情况下，你需要知道如何对二进制文件应用其他签名。第一种情况：IDA 无法识别用于构建二进制文件的编译器，因而无法选择所需的相应签名。这时，你需要根据自己的初步分析，确认IDA 应尝试使用的签名，并迫使IDA 使用一个或几个签名。第二种情况：IDA 中没有针对某些库的现成签名，这时你需要为这些库创建你自己的签名。例如，为FreeBSD 8.0自带的OpenSSL 静态库创建签名就是如此。DataRescue 提供一个工具包，可用于生成供IDA 的签名匹配引擎使用的自定义签名。我们将在第12 章中讨论如何生成自定义签名。无论你出于什么原因想要应用新签名，在签名窗口中按下INSERT 键或右击窗口，IDA 都会为你提供Apply new signature（应用新签名）选项。这时，你可以从你所安装的IDA 版本包含的所有签名中选择你需要的签名。
5.3.5 类型库窗口
类型库窗口在概念上与签名窗口类似。类型库保存IDA 积累的一些信息，即IDA 从最常用的编译器的头文件中搜集到的有关预定义数据类型和函数原型的信息。通过处理头文件，IDA 可确定常用库函数所需的数据类型，并为反汇编代码提供相应的注释。同样，IDA 还可从这些头文件中了解复杂数据结构的大小和布局。所有这些信息都收集在TIL文件（ ）中，并可在任何时候应用于你分析的二进制文件。与应用签名时一样，在选择加载一组适当的TIL文件之前，IDA 必须首先确定一个程序所使用的库。要请求IDA 加载其他类型库，可以在类型库窗口中按下INSERT 键，或右击窗口并在出现的菜单中选择Load Type Library （加载类型库）。类型库将在第13 章详细讨论。
5.3.6 函数调用窗口
在任何程序中，一个函数可以调用其他函数，也可以被其他函数调用。实际上，建立一个图形来说明调用方与被调用方之间的关系，是一个相当简单的任务。这样的图形叫做函数调用图形或函数调用树（我们将在第9章介绍如何在IDA 中生成这类图形）。有时候，我们并不需要查看程序的完整调用图形，而只对指定函数的“近邻”感兴趣。如果Y直接调用X，或者X直接调用Y，则称Y是X的近邻。
函数调用窗口提供了这类“近邻”的问题的答案。打开函数调用窗口时，IDA 会确定光标所在位置的函数的“近邻”，并生成如图5-10 所示的窗口。
图5-10 函数调用窗口
在这个例子中，我们看到，函数sub_40182C
 被_main
 从6个不同的位置调用，而这个函数又调用了另外15 个函数。双击函数调用窗口中的任何一行，IDA 将立即跳转到反汇编窗口中对应的调用或被调用函数（即调用方或被调用方）。IDA 交叉引用（xrefs ）是用于生成函数调用窗口的机制。我们将在第9章详细讨论xrefs 。
5.3.7 问题窗口
IDA 在问题窗口中显示它在反汇编二进制文件时遇到的困难，以及它如何处理这些困难。有些时候，你可以操纵反汇编代码，帮助IDA 解决问题，但情况并非总是如此。即使在反汇编最简单的二进制文件时，你也可能会遇到问题。许多时候，忽略这些问题并不是坏事。为了处理问题，你需要比IDA 更深入地理解二进制文件，但我们大多数人都无法做到这一点。下面是一组问题：
Address          Type       Instruction
.text:0040104C   BOUNDS     call    eax               
.text:004010B0   BOUNDS     call    eax               
.text:00401108   BOUNDS     call    eax               
.text:00401350   BOUNDS     call    dword ptr [eax]   
.text:004012A0   DECISION   push    ebp               
.text:004012D0   DECISION   push    ebp               
.text:00401560   DECISION   jmp     ds:__set_app_type 
.text:004015F8   DECISION   dd 0FFFFFFFFh             
.text:004015FC   DECISION   dd 0                      
可以看到，每个问题都注明了问题发生的地址、问题的类型以及问题所在位置的指令。在这个例子中，我们看到一个BOUNDS
 问题和一个DECISION
 问题。如果无法确定调用或跳转的目标（例如在上例中，IDA 无法获得eax
 的值），或者该目标明显不在程序的虚拟地址范围内，这时就会发生BOUNDS
 问题。许多时候，DECISION
 问题根本不是问题。DECISION
 问题通常表示IDA 决定将一个地址上的字节作为指令而非数据进行反汇编，即使这个地址在递归下降指令遍历（参见第1章）过程中从未被引用也是如此。有关问题类型及其处理建议的完整内容，请参阅IDA 的内部帮助文档（请查阅Problem List问题列表这一主题）。
5.4 小结
初看起来，IDA 中似乎有太多的窗口。首先熟悉最主要的窗口，然后逐步了解其他窗口，是认识IDA 窗口的最简单方法。无论什么时候，你都没有义务利用IDA 的所有窗口，也并不是每一个窗口都可以为逆向工程任务提供帮助。
除了在本章中介绍的窗口外，在深入学习IDA 的过程中，你还会遇到大量对话框。在本书的剩余部分，我们将在必要时介绍一些主要的对话框。最后，除默认的反汇编视图图形外，这一章并未涉及其他图形。IDA 菜单系统将图形作为一种独立的显示，区别于本章讨论的子窗口，专门介绍图形的第9章将说明这样做的原因。
现在，你已经对IDA 的用户界面相当熟悉。在下一章中，我们将开始讨论各种操纵反汇编代码的方法，以增强你对其行为的了解，同时帮助你进一步熟悉IDA 的用法。
第6章 反汇编导航
在本章和下一章，我们将介绍IDA Pro在交互性
 方面的主要特点，简言之，也就是易于导航和易于操纵。本章的重点是导航，我们将说明如何利用IDA 以符合逻辑的方式迅速浏览反汇编代码。到目前为止，我们已经了解到，IDA 基本上是将许多常用逆向工程工具的功能整合到了一个集成的反汇编窗口中。想要熟练使用IDA ，学会如何在窗口中导航是你需要掌握的一项基本技能。除上下滚动反汇编代码清单外，静态反汇编代码清单并未提供任何固有的导航功能。即使是使用最优秀的文本编辑器，对这类死列表
 导航也非常困难，因为它们最多只提供一个集成的、类似于grep
 的搜索功能。但是，你会发现，IDA 的数据库提供了卓越的导航功能。
6.1 基本IDA 导航
当你开始接触IDA 时，你可能满足于IDA 提供的导航功能。除提供相当标准的查找功能外（在使用文本编辑器或文字处理器时，你已经熟悉这些功能），IDA 还将生成并显示一个完整的交叉引用（其功能类似于Web页面上的超链接）列表。因此，多数情况下，要导航到你感兴趣的位置，只需双击鼠标即可。
6.1.1 双击导航
反汇编程序时，程序的每个位置都分配到了一个虚拟地址。因此，只要提供希望访问的位置的虚拟地址，就可以导航到程序的任何地方。遗憾的是，对我们而言，记住大量地址并非易事。这促使早期的程序员给他们希望引用的程序位置分配符号名称，这大大简化了他们的工作。给程序地址分配符号名称，与给程序操作码分配助记指令名称并无不同。由于程序更易于记忆，读取和写入程序也更加方便。
如前所述，在分析阶段，IDA 会通过检查二进制文件的符号表生成符号名称，或根据二进制文件引用位置的方式自动生成一个名称。除符号用途外，反汇编窗口中显示的任何名称都是一个潜在的导航目标，类似于网页中的超链接。这些名称与标准超链接之间的区别在于：其一，这些名称不像超链接那样突出显示，表示它们可以访问；其次，IDA 中的名称需要双击才能访问，而访问超链接只需单击即可。前面我们已经讨论过如何在各种子窗口（如导入、导出和函数窗口）中使用名称，在这些窗口中，双击一个名称，IDA 将跳转到反汇编窗口中被引用的位置。这只是在双击导航的一个简单例子。如下例所示，每一个标有➊的符号都是一个已命名的导航目标。双击任何一个符号，IDA 将跳转到相应的位置。
.text:0040132B loc_40132B:                   ; CODE XREF: ➋ sub_4012E4+B^j  
.text:0040132B       cmp     edx, 0CDh  
.text:00401331       jg      short  ➊ loc_40134E  
.text:00401333       jz       ➊ loc_4013BF  
.text:00401339       sub     edx, 0Ah  
.text:0040133C       jz      short ➊ loc_4013A7  
.text:0040133E       sub     edx, 0C1h  
.text:00401344       jz      short  ➊ loc_4013AF  
.text:00401346       dec     edx  
.text:00401347       jz      short  ➊ loc_4013B7  
.text:00401349       jmp      ➊ loc_4013DD   ; default  
.text:00401349                               ; jumptable 00401300 case 0  
.text:0040134E ; ----------------------------------------------------------
.text:0040134E  
.text:0040134E loc_40134E:                   ; CODE XREF: ➋ sub_4012E4+4D^j  
为方便导航，IDA 把另外两个显示实体看成是导航目标。首先，交叉引用（如➋所示）被当成导航目标。通常，交叉引用被格式化成一个名称和一个十六进制偏移值。在上面的代码中，loc_40134E
 右边的交叉引用引用了sub_4012E4
 之前的4D
16
 或77
10
 字节的位置。双击交叉引用文本，IDA 将跳转到引用位置（本例中为00401331
 ）。第9章将详细介绍交叉引用。
从导航角度看，第二种需要特别注意的显示实体是使用十六进制值的显示实体。如果窗口中的一个十六进制值是二进制文件中的一个合法虚拟地址，那么，双击这个值，反汇编窗口将显示你选择的虚拟地址。在下面的代码中，双击任何一个标有➌的值，反汇编窗口将跳转到相应的位置，因为它们都属于给定二进制文件中的合法虚拟地址。不过，双击标有➍的值则不会有任何效果。
.data:00409013       db     ➍ 4  
.data:00409014       dd ➌ 4037B0h  
.data:00409018       db     ➍ 0  
.data:00409019       db   ➍ 0Ah  
.data:0040901A       dd ➌ 404590h  
.data:0040901E       db     ➍ 0  
.data:0040901F       db   ➍ 0Ah  
.data:00409020       dd ➌ 404DA8h  
最后，双击导航还与IDA 的输出窗口有关，尽管该窗口常用于显示各种信息性的消息。当一个导航目标（如前所述）出现在一条消息的开头位置时，双击这条消息，反汇编窗口将跳转到相应的位置。
   Propagating type information...  
   Function argument information has been propagated  
   The initial autoanalysis has been finished.  
➎  40134e is an interesting location  
➏  Testing: 40134e  
➎  loc_4013B7  
➏  Testing: loc_4013B7  
在上面的输出窗口中，两条标有➎的消息可用于导航到在消息开头位置指定的地址。双击其他任何消息，包括那些标有➏的消息，将不会有任何效果。
6.1.2 跳转到地址
有时候，你清楚地知道你想要导航的目的地址，但反汇编窗口中并没有可供双击导航的名称。在这种情况下，你有几种选项供选择。第一个是最基本的选项，即使用反汇编窗口滚动条上下滚动窗口，直到看到想要访问的地址。通常，只有知道要导航到的目标地址的虚拟地址时，才能采用这个选项，因为反汇编窗口是按虚拟地址逐行显示的。如果你仅仅知道一个已命名的位置，如一个名为foobar
 的子程序，那么，通过滚动条找目的地址就无异于大海捞针。这时，你可以选择对函数窗口按字母排序，滚动到想要的名称，然后再双击该名称。第三个选项是使用IDA 的Search菜单提供的搜索功能。通常，在要求IDA 搜索前需要指定一些搜索标准。如果你搜索的是一个已知的位置，使用该选项有点小题大做。
最后，到达一个已知的反汇编位置的最简单方法是，利用如图6-1所示的Jump to Address （跳转到地址）对话框。
图6-1 Jump to Address 对话框
使用Jump▶Jump to Address 命令或在处于活动状态的反汇编窗口中按下热键G，均可以打开Jump to Address 对话框。如果把这个对话框看成Go对话框，可能有助于你记住相关的热键。要想导航到二进制文件中的某个位置，只需指定一个地址（名称或十六进制值），然后单击OK，IDA会立即显示你指定的位置。IDA 会记住你在这个对话框中输入的值，并通过一个下拉列表显示，以方便你随后使用。使用这项历史记录功能，你可以迅速返回你之前访问过的位置。
6.1.3 导航历史记录
如果将IDA 的文档导航功能与Web浏览器的相应功能进行比较，我们可能会认为名称和地址等同于超链接，因为可以相对容易地访问它们以查看新地址。IDA 的另一项类似于传统Web浏览器的功能，是它的前进和后退导航功能（基于你浏览反汇编窗口的顺序）。每次你导航到反汇编窗口中的一个新位置，你当前的位置就会添加到位置列表中。有两种菜单操作可用于遍历这个列表。首先，Jump▶Jump to Previous Position （跳转▶跳转到前一个位置）命令可使反汇编窗口立即跳转到当前位置的前一个位置。这项操作在概念上等同于Web浏览器的后退按钮。其次为热键ESC ，它是IDA 中最有用的热键之一（可放入内存）。但是，需要注意的是，在反汇编窗口以外的其他窗口中，使用ESC 键会关闭当前窗口。不过，你可以通过View▶Open Subviews命令重新打开你不小心关闭的窗口。在反汇编窗口中，如果你已经深入到一个函数调用链的几个层次，这时你希望导航到最初的位置，使用后退导航就极其方便。
Jump▶Jump to Next Position （跳转▶跳转到下一位置）类似于Web浏览器中的前进按钮，它可将反汇编窗口移动到列表中的下一个位置。与这项操作对应的热键是CTRL+ENTER，尽管它并不如用于后退导航的ESC 键有用。
最后，工具栏上还有两个更有用的导航按钮，如图6-2所示，它们的作用与浏览器中的前进和后退按钮类似。每个按钮旁边还有一个历史记录下拉列表，你可以迅速访问导航历史记录列表中的任何位置，而不必遍历整个历史记录列表。
图6-2 前进和后退导航按钮
6.2 栈帧
因为IDA Pro 是一种低级分析工具，要利用它的许多功能和显示窗口，需要用户熟悉低级编译语言，其中许多概念与生成机器语言和管理由高级程序使用的内存有关。为了更好地理解IDA中的一些显示，有必要不时介绍一些编译程序理论，以帮助理解相关的IDA 显示
栈帧（stack frame ）就是这样一种低级概念。栈帧
 是在程序的运行时栈中分配的内存块，专门用于特定的函数调用。程序员通常会将可执行语句分组，划分成叫做函数
 （也称过程
 、子例程
 或方法
 ）的单元。有时候，这样做是遵照所使用的语言的要求。多数情况下，以这些函数单元为基础构建程序是一种良好的编程实践。
如果一个函数并未执行，通常它并不需要内存。但是，当函数被调用时，它就可能因为某种原因需要用到内存。这源于几方面的原因。其一，函数的调用方可能希望以参数（实参）的方式向该函数传递信息，这些参数需要存储到函数能够找到它们的位置。其二，在执行任务的过程中，函数可能需要临时的存储空间。程序员通常会通过声明局部变量来分配这类临时空间，这些变量将在函数内部使用，完成函数调用以后，就无法再访问它们。
编译器通过栈帧（也叫做激活记录
 ）使得对函数参数和局部变量进行分配和释放的过程对程序员透明。在将控制权转交给函数之前，编译器会插入代码，将函数参数放入栈帧内，并分配足够的内存，以保存函数的局部变量。鉴于栈帧的结构，该函数的返回地址也存储在新的栈帧内。使用栈帧使得递归成为可能，因为每个递归函数调用都有它自己的栈帧，这恰好将当前调用与前一次调用分隔开来。下面是调用一个函数时的详细操作步骤。
调用方将被调用函数所需的任何参数放入到该函数所采用的调用约定（参见6.2.1节）指定的位置。如果参数被放到运行时栈上，该操作可能导致程序的栈指针发生改变。
调用方将控制权转交给被调用的函数，这个过程常由x86 CALL
 或MIPS JAL
 等指令执行。然后，返回地址被保存到程序栈或CPU 寄存器中。
如有必要，被调用的函数会配置一个栈指针1
 ，并保存调用方希望保持不变的任何寄存器值。
1. 帧指针
 是一个指向栈帧位置的寄存器。通常，栈帧内的变量根据它们与帧指针所指向的位置的相对距离来引用。
被调用的函数为它可能需要的任何局部变量分配空间。一般，通过调整程序栈指针在运行时栈上保留空间来完成这一任务。
被调用的函数执行其操作，可能生成一个结果。在执行操作的过程中，被调用的函数可能会访问调用函数传递给它的参数。如果函数返回一个结果，此结果通常被放置到一个特定的寄存器中，或者放置到函数返回后调用方可立即访问的寄存器中。
函数完成其操作后，任何为局部变量保留的栈空间将被释放。通常，逆向执行第4步中的操作，即可完成这个任务。
如果某个寄存器的值还为调用方保存（第3步）着，那么将其恢复到原始值。这包括恢复调用方的帧指针寄存器。
被调用的函数将控制权返还给调用方。实现这一操作的主要指令包括x86 RET
 和MIPS JR
 。根据所使用的调用约定，这一操作可能还会从程序栈中清除一个或多个参数。
调用方一旦重新获得控制权，它可能需要删除程序栈中的参数。这时可能需要对栈进行调整，以将程序栈指针恢复到第(1)步以前的值。
第3步和第4步通常在进入函数时执行，它们共同称为该函数的序言
 。同样，第6步到第8步一般在函数结束时执行，它们共同构成该函数的尾声
 。而第5步则代表函数的主体，它们是调用一个函数时执行的全部操作。
6.2.1 调用约定
了解栈帧的基本概念后，接下来详细介绍它们的结构。下面的例子涉及x86体系结构和与常见的x86编译器（如Mircosoft Visual C/C++或GNU的gcc/g++）有关的行为。创建栈帧时最重要的步骤是，通过调用函数将函数参数存入栈中。调用函数必须存储被调用函数所需的参数，否则可能导致严重的问题。各个函数会选择并遵照某一特定的调用约定，以表明它们希望以何种方式接收参数。
调用约定
 指定调用方放置函数所需参数的具体位置。调用约定可能要求将参数放置在特定的寄存器、程序栈、或者寄存器和栈中。同样重要的是，在传递参数时，程序栈还要决定：被调用函数完成其操作后，由谁负责从栈中删除这些参数。一些调用约定规定，由调用方负责删除它放置在栈中的参数，而另一些调用约定则要求被调用函数负责删除栈中的参数。遵照指定的调用约定对于维护程序栈指针的完整性尤为重要。
1. C 调用约定
x86体系结构的许多C编译器使用的默认调用约定叫做C调用约定
 。如果默认的调用约定被重写，则C/C++ 程序中常用的_cdecl
 修饰符会迫使编译器利用C 调用约定。自现在开始，我们把这种调用约定叫做cdecl
 调用约定。cdecl
 调用约定规定：调用方按从右到左的顺序将函数参数放入栈中，在被调用的函数完成其操作时，调用方（而不是被调用方）负责从栈中清除参数。
从右到左在栈中放入参数的一个结果是，如果函数被调用，最左边的（第一个）参数将始终位于栈顶。这样，无论该函数需要多少个参数，我们都可轻易找到第一个参数。因此，cdecl
 调用约定非常适用于那些参数数量可变的函数（如printf
 ）。