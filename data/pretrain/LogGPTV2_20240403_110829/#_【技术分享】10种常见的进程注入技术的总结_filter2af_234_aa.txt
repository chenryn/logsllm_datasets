# 【技术分享】10种常见的进程注入技术的总结
|
##### 译文声明
本文是翻译文章，文章来源：www.endgame.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
译者：[myswsun](http://bobao.360.cn/member/contribute?uid=877906634)
预估稿费：300RMB
投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿
**0x00 前言**
进程注入是一种广泛应用于恶意软件和无文件攻击中的逃避技术，这意味着可以将自定义代码运行在另一个进程的地址空间内。进程注入提高了隐蔽性，也实现了持久化。尽管有非常多的进程注入技术，但是本文我只列举了10种常见的技术。我还提供了这些技术的相关截图以便逆向和恶意软件的分析，并帮助防御这些技术。
**0x01 通过CreateRemoteThread和LoadLibrary的DLL注入**
****
这是进程注入最常见的技术。恶意软件将恶意的动态链接库的路径写入另一个进程的虚拟地址空间内，通过在目标进程中创建远程线程来确保远程进程加载它。
恶意软件首先需要选择目标进程（例如svchost.exe）。通常使用API：CreateToolhelp32Snapshot,
Process32First, 和
Process32Next来完成。CreateToolhelp32Snapshot是个用于枚举指定进程或所有进程的堆或模块的状态，并且它返回一个快照。Process32First得到快照中的第一个进程的信息，然后Process32Next来遍历所有的进程。在找到目标进程后，恶意软件调用OpenProcess得到目标进程的句柄。
如上图所示，恶意软件调用VirtualAllocEx得到写入路径的内存空间。然后调用WriteProcessMemory在分配的内存中写入路径（动态链接库）。最后，调用API（如CreateRemoteThread、NtCreateThreadEx、RtlCreateUserThread）使得另一个进程执行代码。后两个API是未文档化的。然而，通常想法是将LoadLibrary的地址传入这些API中的一个，以便远程进程执行DLL。
CreateRemoteThread被许多安全产品跟踪并标记。而且，它在磁盘上面留下了一个恶意的DLL可供检测。考虑到攻击者注入代码最常见的目的是逃避防御，高明的攻击者不会使用这种方式。下面是名为Rebhip（Sha256:
07b8f25e7b536f5b6f686c12d04edc37e11347c8acd5c53f98a174723078c365）的恶意软件使用了这种技术。
**  
**
**0x02 可执行文件注入（PE注入）**
****
恶意软件并不传入LoadLibrary的地址，而是拷贝恶意代码到打开的进程中并执行（通过小段shellcode或者调用CreateRemoteThread）。与LoadLibrary相比，PE注入的优势是恶意软件不需要在磁盘中释放一个恶意的DLL。与上个技术类似，恶意软件在目标进程中分配内存，调用WriteProcessMemory将恶意代码而不是DLL路径写入内存。然而，这种方式的缺陷是被复制的映像的基址的改变。当一个恶意软件注入PE到另一个进程，它的新基址是不可预料的，需要动态重新计算PE的地址。为了完成这个，恶意软件需要找到目标进程的重定位表，并根据它的重定位描述解析被复制映像的绝对地址。
这种技术和其他技术很类似，如反射DLL注入和内存模块加载，因为他们都不释放任何文件到磁盘。但是，内存模块和反射DLL注入更加隐蔽。他们不依赖Windows
API（如CreateRemoteThread或LoadLibrary），因为他们在内存中加载并执行自身。反射DLL注入通过在内存中创建一个DLL映射执行，而不依赖Windows的加载器。内存模块加载和反射DLL注入类似，其不同之处只是在于内存模块加载的注入器或加载器负责映射目标DLL到内存中而不是DLL自身映射。在之前的[博文](https://www.endgame.com/blog/technical-blog/hunting-memory)中，讨论过这两种技术。
当分析PE注入时，在调用CreateRemoteThread之前通常能看见循环（通常是两个for循环，一个嵌套在另一个中）。这种技术在crypter（加密和混淆软件）中非常流行。下图中的样本（Sha256:
ce8d7590182db2e51372a4a04d6a0927a65b2640739f9ec01cfd6c143b1110da）充分利用了这种技术。在调用WriteProcessMemory和CreateRemoteThread之前有两层循环来处理重定位。“and
0x0fff”指令也是一个比较好的表征，它标明了头12位用于得到包含重定位块的虚拟地址的偏移量。现在恶意软件重新计算了所有需要的地址了，只需要将起始地址传入CreateRemoteThread并执行就行了。
**0x03 进程hollow（又名进程替换和RunPE）**
****
恶意软件有一种技术叫进程hollow，而不是注入代码到程序中（如DLL注入）。进程hollow发生在恶意软件unmap目标进程的合法内存代码，并使用恶意的代码覆写目标进程的内存（如svchost.exe）的时候。
恶意软件首先以挂起模式创建一个新进程来容纳恶意代码。如下图（Sha256:
eae72d803bf67df22526f50fc7ab84d838efb2865c27aef1a61592b1c520d144），以CREATE_SUSPENDED
(0x00000004)为参数调用CreateProcess。新进程的主线程创建后就处于挂起状态，直到调用ResumeThread才会继续执行。接下来，恶意软件需要使用恶意的payload来填充合法文件的内容。调用ZwUnmapViewOfSection或者NtUnmapViewOfSection来unmap目标进程的内存。这两个API将释放section指向的所有内存。内存unmap之后，使用WriteProcessMemory将恶意软件的节写入目标进程。调用SetThreadContext将入口点指向它已写入的新的代码节。最后，调用ResumeThread恢复挂起进程的执行。
**0x04 线程执行劫持（又名挂起、注入并恢复）**
****
这种技术类似于进程hollow。在线程执行劫持中，恶意软件的目标是进程中已存在的线程，而且没有创建任何进程或线程。因此，在分析期间你可能看见CreateToolhelp32Snapshot和Thread32First、OpenThread。
在得到目标线程的句柄后，恶意软件调用SuspendThread将线程挂起。调用VirtualAllocEx和WriteProcessMemory来分配内存并执行代码注入。代码包含shellcode，恶意DLL的路径和LoadLibrary的地址。
下图（Sha256:
787cbc8a6d1bc58ea169e51e1ad029a637f22560660cc129ab8a099a745bd50e）描述了一个普通木马是如何使用这种技术的。为了劫持线程的执行，恶意软件调用SetThreadContext修改目标线程的EIP寄存器（包含下条执行指令的地址的寄存器）。随后，恶意软件恢复线程继续执行它已写入到宿主进程的shellcode。从攻击者的角度看，这种方式是有问题的，因为在系统调用的中途挂起并恢复线程可能引起系统崩溃。为了避免这种情况的发生，更复杂的利用技术是，一旦EIP寄存器在NTDLL.dll中就恢复并重试。
**0x05 通过SetWindowsHookEx钩子注入**
****
钩子是用于拦截函数调用的一种技术。恶意软件能利用指定线程中事件触发来加载他们的恶意DLL。通常使用SetWindowsHookEx来安装消息钩子。SetWindowsHookEx有4个参数。第一个参数是事件的类型。事件有很多的[类型](https://msdn.microsoft.com/en-us/library/windows/desktop/ms644959\(v=vs.85\).aspx)，有键盘按键（WH_KEYBOARD）和鼠标输入（WH_MOUSE）等。第二个参数是个函数指针，指向恶意软件想要处理事件的函数。第3个参数是包含函数的模块。因此，通常可以看见LoadLibrary、GetProcAddress、SetWindowsHookEx。最后一个参数是消息钩子关联的线程。如果值为0，则针对所有线程。然而，只针对某个线程的目标会小很多，因此也可能看见CreateToolhelp32Snapshot和Thread32Next。一旦DLL被注入后，恶意软件将执行恶意代码。下图中，勒索软件Locky（Sha256:
5d6ddb8458ee5ab99f3e7d9a21490ff4e5bc9808e18b9e20b6dc2c5b27927ba1）就使用了这种技术。
**  
**
**0x06 通过注册表修改（如AppInit_DLLs，AppCertDlls，IFEO）**
****
Appinit_DLL, AppCertDlls, IFEO（映像劫持）可以用于注入和持久化。完整的路径如下：
**AppInit_DLLs**
恶意软件能在AppInit_DLLs键下插入恶意的DLL的路径，以便其他进程加载。该键下每个DLL会被加载到所有的加载User32.dll的进程中。User32.dll是常见的Windows基础库。因此，当恶意软件修改这个子键时，大量进程将加载恶意的DLL。下图中，木马Ginwui（Sha256:
9f10ec2786a10971eddc919a5e87a927c652e1655ddbbae72d376856d30fa27c）依赖了这种技术。它通过调用RegCreateKeyEx打开AppInit_DLLs键，并调用RegSetValueEx修改它。