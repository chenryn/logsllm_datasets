well. In fact, some of these behaviors are still present in older versions of
Internet Explorer.
This behavior is unlikely to have an impact on mainstream web applica-
tions, because such applications are not meant to be accessed through an IP-
based URL and will often simply fail to function properly. But a handful of
systems, used primarily by technical staff, are meant to be accessed by their IP
addresses; these systems may simply not have DNS records configured at all.
In these cases, the ability for http://1.2.3.4/ to inject cookies for http://123
.234.3.4/ may be an issue. The IP-reachable administrative interfaces of home
routers are of some interest, too.
158 Chapter 9
Hostnames with Extra Periods
At their core, cookie-setting algorithms still depend on counting the number
of periods in a URL to determine whether a particular domain parameter is
acceptable. In order to make the call, the count is typically correlated with a
list of several hundred entries on the vendor-maintained Public Suffix List
(http://publicsuffix.org/).
Unfortunately for this algorithm, it is often possible to put extra periods
in a hostname and still have it resolve correctly. Noncanonical hostname rep-
resentations with excess periods are usually honored by OS-level resolvers
and, if honored, will confuse the browser. Although said browser would not
automatically consider a domain such as www.example.com.pl. (with an extra
trailing period) to be the same as the real www.example.com.pl, the subtle and
seemingly harmless difference in the URL could escape even the most atten-
tive users.
In such a case, interacting with the URL with trailing period can be
unsafe, as other documents sharing the *.com.pl. domain may be able to
inject cross-domain cookies with relative ease.
This period-counting problem was first noticed around 1998.19 About a
decade later, many browser vendors decided to roll out basic mitigations by
adding a yet another special case to the relevant code; as of this writing,
Opera is still susceptible to this trick.
Non–Fully Qualified Hostnames
Many users browse the Web with their DNS resolvers configured to append
local suffixes to all found hostnames, often without knowing. Such settings
are usually sanctioned by ISPs or employers through automatic network con-
figuration data (Dynamic Host Configuration Protocol, DHCP).
For any user browsing with such a setting, the resolution of DNS labels
isambiguous. For example, if the DNS search path includes coredump.cx,
thenwww.example.com may resolve to the real www.example.com website or to
www.example.com.coredump.cx if such a record exists. The outcomes are partly
controlled by configuration settings and, to some extent, can be influenced
by an attacker.
To the browser, both locations appear to be the same, which may have
some interesting side effects. Consider one particularly perverse case: Should
http://com, which actually resolves to http://com.coredump.cx/, be able to set
*.com cookies by simply omitting the domain parameter?
Local Files
Because local resources loaded through the file: protocol do not have an
explicit hostname associated with them, it’s impossible for the browser to
compute a normal origin. For a very long time, the vendors simply decided
that the best course of action in such a case would be to simply ditch the same-
origin policy. Thus, any HTML document saved to disk would automatically
Content Isolation Logic 159
be granted access to any other local files via XMLHttpRequest or DOM and, even
more inexplicably, would be able to access any Internet-originating content
in the same way.
This proved to be a horrible design decision. No one expected that the
mere act of downloading an HTML document would put all of the user’s local
files, and his online credentials, in jeopardy. After all, accessing that same
document over the Web would be perfectly safe.
Many browsers have tried to close this loophole in recent years, with vary-
ing degrees of success:
Chrome (and, by extension, other WebKit browsers)
The Chromebrowser completely disallows any cross-document DOM or
XMLHttpRequest access from file: origins, and it ignores document.cookie
calls or  directives in this setting. Access to
a localStorage container shared by all file: documents is permitted, but this
may change soon.
Firefox
Mozilla’s browser permits access only to files within the directory of the
original document, as well as nearby subdirectories. This policy is pretty
good, but it still poses some risk to documents stored or previously down-
loaded to that location. Access to cookies via document.cookie or  is possible, and all file: cookies are visible to any
other local JavaScript code.* The same holds true for access to storage
mechanisms.
Internet Explorer 7 and above
Unconstrained access to local and Internet content from file: origins is
permitted, but it requires the user to click through a nonspecific warn-
ing to execute JavaScript first. The consequences of this action are not
explained clearly (the help subsystem cryptically states that “Internet
Explorer restricts this content because occasionally these programs can malfunction
or give you content you don’t want”), and many users may well be tricked
into clicking through the prompt.
Internet Explorer’s cookie semantics are similar to those of Firefox.
Web storage is not supported in this origin, however.
Opera and Internet Explorer 6
Both of these browsers permit unconstrained DOM or XMLHttpRequest
access without further checks. Noncompartmentalized file: cookies are
permitted, too.
NOTE Plug-ins live by their own rules in file: land: Flash uses a local-with-filesystem sand-
box model,20 which gives largely unconstrained access to the local filesystem, regardless
of the policy enforced by the browser itself, while executing Java or Windows Presenta-
tion Framework applets from the local filesystem may in some cases be roughly equiva-
lent to running an untrusted binary.
* Because there is no compartmentalization between file: cookies, it is unsafe to rely on them for
legitimate purposes. Some locally installed HTML applications ignore this advice, and conse-
quently, their cookies can be easily tampered with by any downloaded, possibly malicious, HTML
document viewed by the user.
160 Chapter 9
Pseudo-URLs
The behavior of pseudo-URLs such as about:, data:, or javascript: originally
constituted a significant loophole in the implementations of the same-origin
policy. All such URLs would be considered same-origin and would permit
unconstrained cross-domain access from any other resource loaded over the
same scheme. The current behavior, which is very different, will be the topic
of the next chapter of this book; in a nutshell, the status quo reflects several
rounds of hastily implemented improvements and is a complex mix of
browser-specific special cases and origin-inheritance rules.
Browser Extensions and UI
Several browsers permit JavaScript-based UI elements or certain user-installed
browser extensions to run with elevated privileges. These privileges may entail
circumventing specific SOP checks or calling normally unavailable APIs in
order to write files, modify configuration settings, and so on.
Privileged JavaScript is a prominent feature of Firefox, where it is used
with XUL to build large portions of the browser user interface. Chrome also
relies on privileged JavaScript to a smaller but still notable degree.
The same-origin policy does not support privileged contexts in any
specific way. The actual mechanism by which extra privileges are granted
may involve loading the document over a special and normally unreachable
URL scheme, such as chrome: or res:, and then adding special cases for that
scheme in other portions of the browser code. Another option is simply to
toggle a binary flag for a JavaScript context, regardless of its actual origin,
and examine that flag later. In all cases, the behavior of standard APIs such
as localStorage, document.domain, or document.cookie may be difficult to predict
and should not be relied upon: Some browsers attempt to maintain isolation
between the contexts belonging to different extensions, but most don’t.
NOTE Whenever writing browser extensions, any interaction with nonprivileged contexts must
be performed with extreme caution. Examining untrusted contexts can be difficult,
andthe use of mechanisms such as eval(...) or innerHMTL may open up privilege-
escalation paths.
Other Uses of Origins
Well, that’s all to be said about browser-level content isolation logic for now.
It is perhaps worth noting that the concept of origins and host- or domain-
based security mechanisms is not limited to that particular task and makes
many other appearances in the browser world. Other quasi-origin-based pri-
vacy or security features include preferences and cached information related
to per-site cookie handling, pop-up blocking, geolocation sharing, password
management, camera and microphone access (in Flash), and much, much
more. These features tend to interact with the security features described in
this chapter at least to some extent; we explore this topic in more detail soon.
Content Isolation Logic 161
Security Engineering Cheat Sheet
Good Security Policy Hygiene for All Websites
To protect your users, include a top-level crossdomain.xml file with the permitted-cross-domain-
policies parameter set to master-only or by-content-type, even if you do not use Flash anywhere
onyour site. Doing so will prevent unrelated attacker-controlled content from being mis-
interpreted as a secondary crossdomain.xml file, effectively undermining the assurances of
thesame-origin policy in Flash-enabled browsers.
When Relying on HTTP Cookies for Authentication
 Use the httponly flag; design the application so that there is no need for JavaScript to
access authentication cookies directly. Sensitive cookies should be scoped as tightly as
possible, preferably by not specifying domain at all.
 If the application is meant to be HTTPS only, cookies must be marked as secure, and you
must be prepared to handle cookie injection gracefully. (HTTP contexts may overwrite
secure cookies, even though they can’t read them.) Cryptographic cookie signing may
help protect against unconstrained modification, but it does not defend against replacing
a victim’s cookies with another set of legitimately obtained credentials.
When Arranging Cross-Domain Communications in JavaScript
 Do not use document.domain. Rely on postMessage(...) where possible and be sure to
specify the destination origin correctly; then verify the sender’s origin when receiving
thedata on the other end. Beware of naïve substring matches for domain names:
msg.origin.indexOf(".example.com") is very insecure.
 Note that various pre-postMessage SOP bypass tricks, such as relying on window.name, are
not tamper-proof and should not be used for exchanging sensitive data.
When Embedding Plug-in-Handled Active Content from Third Parties
Consult the cheat sheet in Chapter 8 first for general advice.
 Flash: Do not specify allowScriptAccess=always unless you fully trust the owner of the origi-
nating domain and the security of its site. Do not use this setting when embedding HTTP
applets on HTTPS pages. Also, consider restricting allowFullScreen and allowNetworking as
appropriate.
 Silverlight: Do not specify enableHtmlAccess=true unless you trust the originating domain,
as above.
 Java: Java applets can’t be safely embedded from untrusted sources. Omitting mayscript
does not fully prevent access to the embedding page, so do not attempt to do so.
162 Chapter 9
When Hosting Your Own Plug-in-Executed Content
 Note that many cross-domain communication mechanisms provided by browser plug-ins
may have unintended consequences. In particular, avoid crossdomain.xml, clientaccesspolicy
.xml, or allowDomain(...) rules that point to domains you do not fully trust.
When Writing Browser Extensions
 Avoid relying on innerHTML, document.write(...), eval(...), and other error-prone coding
patterns, which can cause code injection on third-party pages or in a privileged JavaScript
context.
 Do not make security-critical decisions by inspecting untrusted JavaScript security con-
texts, as their behavior can be deceptive.
Content Isolation Logic 163
O R I G I N I N H E R I T A N C E
Some web applications rely on pseudo-URLs such as
about:, javascript:, or data: to create HTML documents
that do not contain any server-supplied content and that
are instead populated with the data constructed entirely
on the client side. This approach eliminates the delay
associated with the usual HTTP requests to the server
and results in far more responsive user interfaces.
Unfortunately, the original vision of the same-origin policy did not
account for such a use case. Specifically, a literal application of the protocol-,
host-, and port-matching rules discussed in Chapter 9 would cause every
about:blank document created on the client side to have a different origin
from its parent page, preventing it from being meaningfully manipulated.
Further, all about:blank windows created by completely unrelated websites
would belong to the same origin and, under the right circumstances, would
be able to interfere with each other with no supervision at all.
To address this incompatibility of client-side documents with the same-
origin policy, browsers gradually developed incompatible and sometimes
counterintuitive approaches to computing a synthetic origin and access per-
missions for pseudo-URLs. An understanding of these rules is important on
its own merit, and it will lay the groundwork for the discussion of certain
other SOP exceptions in Chapter 11.
Origin Inheritance for about:blank
The about: scheme is used in modern browsers for a variety of purposes, most
of which are not directly visible to normal web pages. The about:blank docu-
ment is an interesting special case, however: This URL can be used to create
a minimal DOM hierarchy (essentially a valid but empty document) to which
the parent document may write arbitrary data later on.
Here is an example of a typical use of this scheme:
...
frames["test"].document.body.innerHTML = "Hi mom!";
...
NOTE In the HTML markup provided in this example, and when creating new windows or
frames in general, about:blank can be omitted. The value is defaulted to when no
other URL is specified by the creator of the parent document.
In every browser, most types of navigation to about:blank result in the cre-
ation of a new document that inherits its SOP origin from the page that initi-
ated the navigation. The inherited origin is reflected in the document.domain
property of the new JavaScript execution context, and DOM access to or
from any other origins is not permitted.
This simple formula holds true for navigation actions such as clicking a
link, submitting a form, creating a new frame or a window from a script, or
programmatically navigating an existing document. That said, there are excep-
tions, the most notable of which are several special, user-controlled navigation
methods. These include manually entering about:blank in the address bar, fol-
lowing a bookmark, or performing a gesture reserved for opening a link in a
new window or a tab.* These actions will result in a document that occupies a
unique synthetic origin and that can’t be accessed by any other page.
Another special case is the loading of a normal server-supplied docu-
ment that subsequently redirects to about:blank using Location or Refresh. In
Firefox and WebKit-based browsers, such redirection results in a unique, non-
accessible origin, similar to the scenario outlined in the previous paragraph.
In Internet Explorer, on the other hand, the resulting document will be
* This is usually accomplished by holding CTRL or SHIFT while clicking on a link, or by right-
clicking the mouse to access a contextual menu, and then selecting the appropriate option.
166 Chapter 10
accessible by the parent page if the redirection occurs inside an  but
not if it took place in a separate window. Opera’s behavior is the most diffi-
cult to understand: Refresh results in a document that can be accessed by the
parent page, but the Location redirect will give the resulting page the origin
of the site that performed the redirect.
Further, it is possible for a parent document to navigate an existing
document frame to an about:blank URL, even if the existing document shown
in that container has a different origin than the caller.* The newly created
blank document will inherit the origin from the caller in all browsers other
than Internet Explorer. In the case of Internet Explorer, such navigation will
succeed but will result in an inaccessible document. (This behavior is most
likely not intentional.)
If this description makes your head spin, the handling of about:blank doc-
uments is summarized in Table 10-1.
Table 10-1: Origin Inheritance for about:blank URLs
Type of navigation
New page Existing non- Location redirect Refresh redirect URL entry or
same-origin gesture
page
Internet Inherited Unique origin (Denied) Frame: Inherited Unique
Explorer from caller from parent origin
Window:
Unique origin
Firefox Inherited from caller Unique origin
All WebKit Inherited from caller (Denied) Unique origin
Opera Inherited from caller Inherited from Inherited from
redirecting party parent
Inheritance for data: URLs
The data: scheme,1 first outlined in Chapter 2, was designed to permit small
documents, such as icons, to be conveniently encoded and then directly
inlined in an HTML document, saving time on HTTP round-trips. For
example:
When the data: scheme is used in conjunction with type-specific sub-
resources, the only unusual security consideration is that it poses a challenge
for plug-ins that wish to derive permissions for an applet from its originating
* The exact circumstances that make this possible will be the focus of Chapter 11. For now,
suffice it to say that this can be accomplished in many settings in a browser-specific way. For
example, in Firefox, you call window.open(..., 'target'), while in Internet Explorer, calling
target.location.assign(...) is the way to go.
Origin Inheritance 167
URL. The origin can’t be computed by looking at the URL alone, and the
behavior is somewhat unpredictable and highly plug-in specific (for exam-
ple, Adobe Flash currently rejects any attempts to use data: documents).
More important than the case of type-specific content is the use of data:
as a destination for windows and frames. In all browsers but Internet Explorer,
the scheme can be used as an improved variant of about:blank, as in this