（空指针异常）现象。看起来工具每次调用这个方法时都会失败。所以，我们可以来分析一下f.a(int)。
    .method static a(I)Ljava/lang/String;
        .registers 3
        sget-object v0, Lxjmurla/gqscntaej/bfdiays/f;->k:[Ljava/lang/String;
        const v1, 0x320fb1f0
        sub-int v1, p0, v1
        aget-object v0, v0, v1
        return-object v0
    .end method
整个方法非常小巧。这段代码的功能是从一个大的常量中提取出第一个参数，使用该参数作为索引查找一个字符串数组，Lxjmurla/gqscntaej/bfdiays/f;->k:[Ljava/lang/String;。我们可以来看看f;->k的初始化过程。
    $ ag -Q 'Lxjmurla/gqscntaej/bfdiays/f;->k:[Ljava/lang/String;'
    xjmurla/gqscntaej/bfdiays/Ceacabcbf.smali
    169:    sput-object v0, Lxjmurla/gqscntaej/bfdiays/f;->k:[Ljava/lang/String;
    245:    sget-object v0, Lxjmurla/gqscntaej/bfdiays/f;->k:[Ljava/lang/String;
    256:    sget-object v0, Lxjmurla/gqscntaej/bfdiays/f;->k:[Ljava/lang/String;
    xjmurla/gqscntaej/bfdiays/f.smali
    72:    sget-object v0, Lxjmurla/gqscntaej/bfdiays/f;->k:[Ljava/lang/String;
我们只找到一个 **sput-object** ，位于 **xjmurla/gqscntaej/bfdiays/Ceacabcbf.smali**
中。在Ceacabcbf中查找这一行，我们找到了 **private Ceacabcbf;->a()V**。这个方法篇幅很长，也非常复杂，包含一大串字符串，这个字符串经过处理、分解后存放在f;->k中。出错点找到了，正是这个字段没有被初始化，导致我们出现NullPointerException错误。这意味着执行字符串解密方法过程中，Ceacabcbf;->a()V并没有被调用。因此，我们来找找该函数的调用位置。
    $ ag -Q 'Lxjmurla/gqscntaej/bfdiays/Ceacabcbf;->a()V'
    xjmurla/gqscntaej/bfdiays/Ceacabcbf.smali
    1313:    invoke-direct {p0}, Lxjmurla/gqscntaej/bfdiays/Ceacabcbf;->a()V
    看样子该方法仅在Ceacabcbf被调用，具体代码为：
    .method public onCreate()V
        .registers 1
        invoke-super {p0}, Landroid/app/Application;->onCreate()V
        sput-object p0, Lxjmurla/gqscntaej/bfdiays/Ceacabcbf;->a:Lxjmurla/gqscntaej/bfdiays/Ceacabcbf;
        invoke-direct {p0}, Lxjmurla/gqscntaej/bfdiays/Ceacabcbf;->a()V
        return-void
    .end method
该方法的具体调用位置位于Ceacabcbf;->onCreate()V中。这个类是Application的一个子类。不需要看manifest文件，我百分百确定当应用启动时会创建这个组件，然后调用onCreate()V方法，构建解密字符串数组，然后初始化f;->k，初始化也是最重要的一个步骤。那么我该如何重复这个操作，以便dex-oracle在解密字符串时能调用这个函数呢？
我首先想到的是往f;->中的Ceacabcbf;->a()V内添加一个调用方法。这样就能确保当字符串解密类f被加载时，会初始化解密字符串数组。然而，a()V是一种直接（direct）方法，这种情况下怎么办？
我使用了有点笨的一种方法，但某些情况下这种方法能发挥作用。只需要创建一个新的公开的静态方法（Ceacabcbf;->init_decrypt()V），方法内容从Ceacabcbf;->a()V那复制即可。然后，在f;->中添加一行语句来调用这个方法：
    .method static constructor ()V
        .registers 1
        const/4 v0, 0x0
        sput v0, Lxjmurla/gqscntaej/bfdiays/f;->a:I
        sput v0, Lxjmurla/gqscntaej/bfdiays/f;->d:I
        sput v0, Lxjmurla/gqscntaej/bfdiays/f;->e:I
        sput v0, Lxjmurla/gqscntaej/bfdiays/f;->f:I
        const/4 v0, 0x4
        new-array v0, v0, [Ljava/lang/String;
        sput-object v0, Lxjmurla/gqscntaej/bfdiays/f;->h:[Ljava/lang/String;
        const-string v0, ""
        sput-object v0, Lxjmurla/gqscntaej/bfdiays/f;->i:Ljava/lang/Object;
         # LOL MONEY, MONEY LOL
        invoke-static {}, Lxjmurla/gqscntaej/bfdiays/Ceacabcbf;->init_decrypt()V
        return-void
    .end method
**六、修改后的dex-oracle**
做了上述修改后，我们需要根据修改版的Smali重建DEX文件，然后尝试使用dex-oracle来处理这个文件。
    $ smali ass out -o xjmurla_mod1.dex
    $ dex-oracle xjmurla_mod1.dex --disable-plugins bitwiseantiskid,stringdecryptor,undexguard,unreflector,indexedclasslookup -i '/d'
    Optimizing 11 methods over 23 Smali files.
    Optimizations: string_lookups=13
    Time elapsed 2.034493 seconds
没有看到错误提示。来看看反编译结果。
    $ d2j-dex2jar.sh xjmurla_mod1_oracle.dex
    dex2jar xjmurla_mod1_oracle.dex -> ./xjmurla_mod1_oracle-dex2jar.jar
    $ jd xjmurla_mod1_oracle-dex2jar.jar
抓到你了！C&C控制域名！先得瑟一下。
结果不错，但此时类还没有去混淆。听起来令人非常讨厌。为了不让本文过于冗长，这里我直接告诉你处理过程。在对类做去混淆处理时，与处理混淆字符串时的情况一下，dex-oracle依然会出现错误。我们同样需要调用Ceacabcbf;->a()V方法。
我们还是可以使用相同的技巧：只要调用g;->中的Ceacabcbf;->init_decrypt()V即可。然而，g并不包含方法，所以我们需要手动添加一个：
    .method static constructor ()V
        .registers 0
        invoke-static {}, Lxjmurla/gqscntaej/bfdiays/Ceacabcbf;->init_decrypt()V
        return-void
    .end method
现在，重新构建文件，然后使用dex-oracle进行处理：
    $ smali ass out -o xjmurla_mod2.dex
    $ dex-oracle xjmurla_mod2.dex  -i '/d'
    Optimizing 11 methods over 23 Smali files.
    Optimizations: string_decrypts=0, class_lookups=13, string_lookups=13
    Time elapsed 3.099335 seconds
来看看处理后的反编译结果有什么区别。
    $ d2j-dex2jar.sh xjmurla_mod2_oracle.dex
    dex2jar xjmurla_mod1_oracle.dex -> ./xjmurla_mod2_oracle-dex2jar.jar
    $ jd xjmurla_mod1_oracle-dex2jar.jar
经过处理后，这个方法本身变化不大，然而其他方法可以提供更多信息，特别是在Smali中，你可以看到许多const-class。所有都处理完毕后，还有个g.c(int)没有去掉混淆，经过进一步分析，我发现这是因为该方法调用成功，但返回了空值（null）。也许这就是为什么该方法会位于try-catch代码段中。也许该代码正试图加载每个Android API版本中都不存在的类。
最后，让我们来测试一下，使用dex-oracle分析整个DEX文件。
    $ dex-oracle xjmurla_mod2.dex
    Optimizing 125 methods over 23 Smali files.
    Optimizations: string_decrypts=0, class_lookups=354, string_lookups=330
    Time elapsed 3.306326 seconds
成功了，非常酷。现在还有许多事情要处理。经过处理后，再由Simplify处理起来会更加简单，因为此时需要执行的代码更少，出错点也更少。
**七、总结**
希望阅读本文后，你对如何改造dex-oracle以适应具体需求有了更深刻的理解。如果你可以将待运行的代码细化成待运行的某个方法，这种结果会更加灵活也更加优秀。某些时候，我们需要修改Android应用以适配dex-oracle，但修改Smali是相对简单的一种方法，并且许多恶意软件会带有防篡改机制，这种情况下，你可以采用更加明智的选择。