6
for o P irOs do
T Ð T Y tou;
7 return pinex t , T q;
Previous work on automatic unpacking updates the shadow mem-
ory with any memory wri(cid:138)en by instructions already inside of the
shadow memory. By contrast, our approach updates the shadow
memory based on our taint propagation and any output of instruc-
tions that are in the shadow memory. As such, our updates to the
shadow memory includes the same as those of previous work but
also propagations of shadow memory performed by instructions
that are not part of the shadow memory itself. Furthermore, pre-
vious work on automatic unpacking only includes instruction in
the execution trace if the memory making up the instructions are
part of the shadow memory. By contrast, our approach includes in-
struction in the execution trace if they are either part of the shadow
memory or code-reuse a(cid:138)acks. As such, our approach also includes
the same and more instructions in the malware execution trace.
(cid:140)is is easy to show formally and in Appendix A we give a formal
treatment that shows we indeed capture the same instructions and
also more, compared to previous work.
In this section, we have shown how Tartarus achieves one of
its two purposes, namely a general approach to malware execu-
tion tracing in the context of dynamically generated code, code
injections and code-reuse a(cid:138)acks. We now proceed to consider
how Tartarus achieves its second goal of raising the execution into
higher-level semantics.
4 CODE WAVES
(cid:140)e (cid:128)rst abstraction we propose on the malware execution trace is
a novel approach to identify dynamically generated code. (cid:140)e goal
of uncovering dynamically generated code is to identify whenever
memory that was wri(cid:138)en during runtime is also executed. (cid:140)e
approach by previous work is to divide the malware execution into
code waves such that each code wave consists of memory explicitly
wri(cid:138)en by the previous code wave [5, 24, 40] ([40] uses the termi-
nology layers instead of code waves). However, we cannot rely on
this approach because it can not identify malicious code that was
dynamically generated via benign code, i.e. the malware triggered
benign code to do the writing of the dynamically generated code.
Instead, Tartarus takes a di(cid:130)erent approach and raises the malware
execution trace into dynamically generated code waves indepen-
dent of who wrote the code, but on the basis that the wri(cid:138)en code
must originate from the malware.
We model dynamically generated code on a process-level basis
and consider the (cid:128)rst code wave to be the malware module when
(cid:128)rst loaded into memory. To identify code waves we use a per-
process shadow table that is a memory snapshot taken at one point
Session H2:  Code Reuse AttacksCCS’17, October 30-November 3, 2017, Dallas, TX, USA1696of the tainted memory in some process, and each shadow table
corresponds to one code wave. When a malicious instruction exe-
cutes, we can then map the bytes making up the instruction with
the bytes of the shadow table. If we observe any inconsistencies
with the shadow table and the currently executing instruction, we
can conclude this instruction is part of a new wave of dynamically
generated code.
Because the shadow table is composed of tainted memory and
tainted memory is propagated through both benign and malicious
instructions, then we e(cid:130)ectively de(cid:128)ne dynamically generated code
independent of who wrote the code. However, since the tainted
code originates from the malware itself, then we can e(cid:130)ectively
declare the dynamically generated code to be dynamically gener-
ated malicious code. (cid:140)ese are the two aspects that separate our
technique from previous work and allows our technique to be more
general. (cid:140)e ability to identify dynamically generated code in this
way is vital for identifying dynamically generated code across pro-
cesses because in most cases memory wri(cid:138)en from one process
to another is not done by the instructions explicitly part of the
malware but rather by some OS provided APIs or features.
In practice a shadow table is a hashtable where each key is an
address in virtual memory and the corresponding value is the byte
located at that address when the pair was inserted into the hashtable.
Whenever a tainted instruction is executed we have one of four
possible cases:
(1) the instruction is inside a process that does not have a
shadow table assigned;
(2) the instruction is inside a process with a shadow table
assigned, but the address of the instruction is not in the
shadow table;
(3) the instruction is inside a process with a shadow table
and the address of the instruction is inside the shadow
table, but the memory in shadow table is not similar to the
instruction executed;
(4) the instruction is inside a process that has a shadow ta-
ble and the address of the instruction is in the shadow
table, and the memory in the shadow table is similar to the
current instruction.
In all cases but (4), we consider the instruction to be entrypoint
of a new code wave. Further, cases 1-3 each indicate a high-level
feature of the new code wave. In case (1) we have an instance of
code injection, in case (2) we simply have a new code wave and in
case (3) we have a new code wave that has overwri(cid:138)en memory in
a previous code wave.
When an entrypoint of a new code wave is discovered, Tartarus
(cid:128)rst clears the shadow table of the given process, and if a shadow
table does not already exist Tartarus simply initiates one. Next, the
entire process memory is scanned and every byte that is tainted is
put in the new shadow table. A(cid:137)er the scanning, the shadow table
contains the current code wave of the process under execution.
5 CODE INJECTIONS
(cid:140)e second abstraction that we propose is to identify code injec-
tions in the malware execution trace, and also extract essential
insights about these by performing semantics-aware dependency
analysis on the malware execution trace and the taint propagation
log. (cid:140)e procedure consists of the following three steps: (1) from
the malware execution trace, identify where control-(cid:131)ow goes from
one process to another and arrange such (cid:128)ndings into transition
pairs; (2) (cid:128)nd any code-reuse a(cid:138)acks involved in the transition; (3)
perform backward dependency analysis on these two components
and generate a code injection graph; In this section, we detail each
of these steps.
5.1 Transition model
(cid:140)e transition model captures when the malware execution (cid:131)ows
from one process to another. (cid:140)is type of (cid:131)ow is composed of an
initiator instruction in the source process and a target instruction
in the destination process. Together the initiator and target in-
struction make up a transition pair. Identifying the transition pairs
is not trivial because the instructions in the malware execution
trace are ordered according to when they were observed in a single
cored execution environment, and not necessarily the control (cid:131)ow
of the malware execution. In practice, this problem of misalign-
ment between control-(cid:131)ow and observation time occurs because
of asynchronous procedure calls, parallel execution and context
switches.
Previous works have handled the problem of identifying tran-
sition pairs with two di(cid:130)erent solutions. Ugarte et al. [40] create
a transition pair whenever a thread context switch occurs. We
have found that in practice this approach is inaccurate because it
generates too many transition pairs. (cid:140)e reason for this is that a
context-switch does not re(cid:131)ect a control-(cid:131)ow transition from the
process or thread being switched out to the one being switched in.
Bonfante et al. [5] hook a set of function calls which are known
to initiate execution in remote processes. Although this approach
works well in practice when the injection techniques are known,
it lacks generality because it cannot identify unknown code injec-
tions.
Our approach is instead to (cid:128)rst identify all target instructions in
a general manner independent of function hooking, and then trace
backwards in order to identify the initiator instruction. In com-
parison to an approach that (cid:128)rst identi(cid:128)es the initiator instruction
and then the target instruction, our approach is able to identify the
target instruction independently of the initiator instruction exactly
because we rely on taint for tracing the malware execution. When
we trace backwards to identify the initiator instruction, we then
use function hooking to identify if the injection matches an already
known injection technique, and if it does not we then deploy a
general heuristic to identify the initiator instruction.
To identify target instructions we monitor for malware code
execution inside processes where the malware has previously not
executed. When we observe this behaviour, we know (1) this is the
(cid:128)rst instruction in a given code wave and (2) injection of code has
occurred because this is the (cid:128)rst time malware code is executed in
the process. We label each of these instructions as target instruc-
tions. We note here that we only declare an instruction a target
instruction if it is not a code-reuse a(cid:138)ack.
When a target instruction has been found, we proceed to (cid:128)nd
the corresponding initiator. During execution we monitor all API
calls done by instructions in the malware execution trace. (cid:140)is
includes obfuscated calls such as push X; rol [esp], Y; ret.
Session H2:  Code Reuse AttacksCCS’17, October 30-November 3, 2017, Dallas, TX, USA1697We then keep a subset of these calls in a set F, with all the calls to
functions that we know possibly initiate execution in a remote con-
text e.g. CreateRemoteThread, ResumeThread, CreateProcess,
QueuseUserAPC. When a target instruction is observed, we (cid:128)rst
check if there is an element e P F that initiates execution of this
code. If there is, then we declare the element e as the initiator of
the code injection. In is important to note here that the hooking is
only used to identify the injection initiator and not to identify that a
code injection has happened. Our approach to identifying whether
a code injection has happened is completely independent of our
use of hooking. However, if there is no such element, then we have
a code injection that relies on an unknown method for injecting the
code. In this case, we trace back in the malware execution trace to
the (cid:128)rst instruction that branches to something outside of the mal-
ware memory (such as calling a function in a dynamically loaded
module) and is a non-gadget related instruction. (cid:140)is instruction is
then identi(cid:128)ed as the initiator.
5.2 Injection mechanics
When the initiator and the target instruction pair has been found,
we continue to identify if there is any code-reuse in-between them
that are of importance to the injection. Speci(cid:128)cally, we consider
each code injection as a sequence of instructionsxinitiator ,R,G,tar❕ety
where R is a sequence of instructions with pid not equal to the pid
of tar❕et and G is a sequence of instructions that are all code-reuse
pairs and have pid to be the same as the pid of target. Both R and
G may be empty sequences. We call G the catalyst and the tuple
(initiator ,catalyst,tar❕et) the key components of the code injection.
(cid:140)e key components of the code injection make up the control (cid:131)ow
of the code injection: initiator Ñ catalyst Ñ tar❕et.
Figure 2 shows the key components of the code injection col-
lected by Tartarus when matched with the Gapz malware sample.
(cid:140)e initiator instruction here is the instruction call SendNotifyMessage
at address 9b3b00 in the malware process. (cid:140)is call triggers three
indirect call gadgets, that then transfer control to 6 ROP gadgets.
(cid:140)e target instruction is mov ebp, esp at address 77ef48c0.
To identify code injections that purely rely on code-reuse a(cid:138)acks
and not any target instruction, such as the malware proposed by
Vogl et al. [41], we also identify a code injection if we observe a
code-reuse sequence of longer than 10 gadgets.
(cid:140)e key components give valuable insight into a code injection
and the instructions that are part of it. However, on their own, the
key components give li(cid:138)le insight into how the malware established
these components. To give insight about this we construct the code
injection graph. A code injection graph describes the control-(cid:131)ow of
the code injection and the propagation of tainted memory involved
in the code injection. (cid:140)e nodes of the graph are either instructions
in the malware execution trace or taint-propagation instructions.
(cid:140)e edges in the graph therefore show either control-(cid:131)ow or taint-
(cid:131)ow. In practice we also annotate the nodes with several descriptive
elements such as the modules and functions they are part of.
To construct the code injection graph we analyse the taint-
propagation history of the tainted memory in the catalyst and
the target. Speci(cid:128)cally, we trace backwards on the instructions that
have propagated the tainted memory until one of two conditions
is satis(cid:128)ed: (1) the instruction propagating tainted memory is part
P I D Address
Instruction
9b3b00
4d0
call SendNotifyMessage
call [eax] ; KiUserAPCDispatcher
1001b4b
5f0
call [eax + 8]
1001b59
5f0
std
1022599
5f0
ret
5f0
102259a
1001b6e
5f0
call [eax + 4]
7c9ee5be mov ecx, 0x94
5f0
7c9ee5c3
5f0
7c9ee5c5
5f0
5f0
7c9ee5c6
7c9ee5c8
5f0
7c9ee5c9
5f0
7c9ee5ca
5f0
77ec5b26
5f0
5f0
77ec5b27
101179c
5f0
101179d
5f0
7c9015f8
5f0
5f0
7c90160c
7c802213 WriteProcessMemory
5f0
7c802298
5f0
101179c
5f0
101179d
5f0
5f0
1002080
77ef48c0 mov ebp, esp
5f0
rep movsd
pop edi
xor eax, eax
pop esi
pop edi
ret
cld
ret
pop eax
ret
ret
pop eax
ret
jmp eax
alloca probe
ret
Figure 2: Key components of Gapz code injection.
lea edi, [esp + 0x10]
pop eax
call eax
Figure 3: Code of KiUserAPCDispatcher.
of the malware execution trace or (2) the instruction propagating
memory propagates memory from a code wave di(cid:130)erent than the
code wave of which the target instruction belong.
6 IMPLEMENTATION
We have implemented the techniques described in the previous
sections into a practical system called Tartarus. Our implementation
consists of three main parts: (i) a dynamic analysis component that
executes a given sample in our sandbox; (ii) a component that does
analysis on the output of our dynamic analysis and (iii) a manager
component that wraps around the two other components to allow
for analysis of large sample sets.
(cid:140)e dynamic analysis component emulates the malware execu-
tion and is built on top of DECAF [21]. It is in charge of capturing
the malware execution trace described in Section 3 and identifying
code waves described in Section 4. In addition, it performs several
supporting tasks such as dumping memory of code waves, construct
the pair-wise execution order of instructions inside each code wave,
collect obfuscated library calls (like those described in Section 5.1)
and dump taint-logging information. (cid:140)e second component takes
as input the output of our dynamic analysis component and identi-
(cid:128)es and analyses code injections. It also reconstructs control-(cid:131)ow
Session H2:  Code Reuse AttacksCCS’17, October 30-November 3, 2017, Dallas, TX, USA1698within each code wave based on disassembly of the code wave’s
memory dumps and the pair-wise execution order of instructions
in the code wave. Based on the code waves and the code injections
this component then generates a system-wide control-(cid:131)ow graph
that shows the propagation strategy deployed by the malware. An
important aspect to note here is that our implementation will dis-
card malware execution inside a process if this process only has 10