Calling Other Drivers
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
237
Putting it All Together: The Melody Driver . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
239
Client Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
255
Invoking System Services
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
256
Example: Enumerating Processes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
258
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
261
Chapter 9: Process and Thread Notifications . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
262
Process Notifications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
262
Implementing Process Notifications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
265
The DriverEntry Routine . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
269
Handling Process Exit Notifications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
271
Handling Process Create Notifications
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
274
Providing Data to User Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
277
The User Mode Client . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
280
Thread Notifications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
283
Image Load Notifications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
286
Final Client Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
293
Remote Thread Detection
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
296
The Detector Client
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
305
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
306
Introduction
Windows kernel programming is considered by many a dark art, available to select few that manage to
somehow unlock the mysteries of the Windows kernel. Kernel development, however, is no different than
user-mode development, at least in general terms. In both cases, a good understanding of the platform is
essential for producing high quality code.
The book is a guide to programming within the Windows kernel, using the well-known Visual Studio
integrated development environment (IDE). This environment is familiar to many developers in the
Microsoft space, so that the learning curve is restricted to kernel understanding, coding and debugging,
with less friction from the development tools.
The book targets software device drivers, a term I use to refer to drivers that do not deal with hardware.
Software kernel drivers have full access to the kernel, allowing these to perform any operation allowed by
the kernel. Some software drivers are more specific, such as file system mini filters, also described in the
book.
Who Should Read This Book
The book is intended for software developers that target the Windows kernel, and need to write kernel
drivers to achieve their goals. Common scenarios where kernel drivers are employed are in the Cyber
Security space, where kernel drivers are the chief mechanism to get notified of important events, with the
power to intercept certain operations. The book uses C and C++ for code examples, as the kernel API is all
C. C++ is used where it makes sense, where its advantages are obvious in terms of maintenance, clarity,
resource management, or any combination of these. The book does not use complex C++ constructs, such
as template metaprogramming. The book is not about C++, it’s about Windows kernel drivers.
What You Should Know to Use This Book
Readers should be very comfortable with the C programming language, especially with pointers, structures,
and its standard library, as these occur very frequently when working with kernel APIs. Basic C++
knowledge is highly recommended, although it is possible to traverse the book with C proficiency only.
Book Contents
Here is a quick rundown of the chapters in the book:
• Chapter 1 (“Windows Internals Overview) provides the fundamentals of the internal workings of
the Windows OS at a high level, enough to get the fundamentals without being bogged down by
too many details.
Introduction
2
• Chapter 2 (“Getting Started with Kernel Development”) describes the tools and procedures needed
to set up a development environment for developing kernel drivers. A very simple driver is created
to make sure all the tools and procedures are working correctly.
• Chapter 3 (“Kernel Programming Basics) looks at the fundamentals of writing drivers, including
bssic kernel APIs, handling of common programming tasks involving strings, linked lists, dynamic
memory allocations, and more.
• Chapter 4 (“Driver from Start to Finish”) shows how to build a complete driver that performs some
useful functionality, along with a client application to drive it.
If you are new to Windows kernel development, you should read chapters 1 to 7 in order. Chapter 8 contains
some advanced material you may want to go back to after you have built a few simple drivers. Chapters
9 onward describe specialized techniques, and in theory at least, can be read in any order.
Sample Code
All the sample code from the book is freely available on the book’s Github repository at https://github.
com/zodiacon/windowskernelprogrammingbook2e. Updates to the code samples will be pushed to this
repository. It’s recommended the reader clone the repository to the local machine, so it’s easy to experiment
with the code directly.
All code samples have been compiled with Visual Studio 2019. It’s possible to compile most code samples
with earlier versions of Visual Studio if desired. There might be few features of the latest C++ standards
that may not be supported in earlier versions, but these should be easy to fix.
Happy reading!
Pavel Yosifovich
June 2022
Chapter 1: Windows Internals Overview
This chapter describes the most important concepts in the internal workings of Windows. Some of the
topics will be described in greater detail later in the book, where it’s closely related to the topic at hand.
Make sure you understand the concepts in this chapter, as these make the foundations upon any driver
and even user mode low-level code, is built.
In this chapter:
• Processes
• Virtual Memory
• Threads
• System Services
• System Architecture
• Handles and Objects
Processes
A process is a containment and management object that represents a running instance of a program. The
term “process runs” which is used fairly often, is inaccurate. Processes don’t run – processes manage.
Threads are the ones that execute code and technically run. From a high-level perspective, a process owns
the following:
• An executable program, which contains the initial code and data used to execute code within the
process. This is true for most processes, but some special ones don’t have an executable image
(created directly by the kernel).
• A private virtual address space, used for allocating memory for whatever purposes the code within
the process needs it.
• An access token (called primary token), which is an object that stores the security context of the
process, used by threads executing in the process (unless a thread assumes a different token by using
impersonation).
• A private handle table to executive objects, such as events, semaphores, and files.
• One or more threads of execution. A normal user-mode process is created with one thread (executing
the classic main/WinMain function). A user mode process without threads is mostly useless, and
under normal circumstances will be destroyed by the kernel.
Chapter 1: Windows Internals Overview
4
These elements of a process are depicted in figure 1-1.
Figure 1-1: Important ingredients of a process
A process is uniquely identified by its Process ID, which remains unique as long as the kernel process object
exists. Once it’s destroyed, the same ID may be reused for new processes. It’s important to realize that the
executable file itself is not a unique identifier of a process. For example, there may be five instances of
notepad.exe running at the same time. Each of these Notepad instances has its own address space, threads,
handle table, process ID, etc. All those five processes are using the same image file (notepad.exe) as their
initial code and data. Figure 1-2 shows a screenshot of Task Manager’s Details tab showing five instances
of Notepad.exe, each with its own attributes.
Chapter 1: Windows Internals Overview
5
Figure 1-2: Five instances of notepad
Virtual Memory
Every process has its own virtual, private, linear address space. This address space starts out empty (or
close to empty, since the executable image and NtDll.Dll are the first to be mapped, followed by more
subsystem DLLs). Once execution of the main (first) thread begins, memory is likely to be allocated, more
DLLs loaded, etc. This address space is private, which means other processes cannot access it directly.
The address space range starts at zero (technically the first and last 64KB of the address space cannot be
committed), and goes all the way to a maximum which depends on the process “bitness” (32 or 64 bit) and
the operating system “bitness” as follows:
• For 32-bit processes on 32-bit Windows systems, the process address space size is 2 GB by default.
• For 32-bit processes on 32-bit Windows systems that use the increase user virtual address space
setting, can be configured to have up to 3GB of address space per process. To get the extended
address space, the executable from which the process was created must have been marked with the
LARGEADDRESSAWARE linker flag in its PE header. If it was not, it would still be limited to 2 GB.
• For 64-bit processes (on a 64-bit Windows system, naturally), the address space size is 8 TB (Windows
8 and earlier) or 128 TB (Windows 8.1 and later).
• For 32-bit processes on a 64-bit Windows system, the address space size is 4 GB if the executable
image has the LARGEADDRESSAWARE flag in its PE header. Otherwise, the size remains at 2 GB.
The requirement of the LARGEADDRESSAWARE flag stems from the fact that a 2 GB address
range requires 31 bits only, leaving the most significant bit (MSB) free for application use.
Specifying this flag indicates that the program is not using bit 31 for anything and so having
that bit set (which would happen for addresses larger than 2 GB) is not an issue.
Chapter 1: Windows Internals Overview
6
Each process has its own address space, which makes any process address relative, rather than absolute.
For example, when trying to determine what lies in address 0x20000, the address itself is not enough; the
process to which this address relates to must be specified.
The memory itself is called virtual, which means there is an indirect relationship between an address
and the exact location where it’s found in physical memory (RAM). A buffer within a process may be
mapped to physical memory, or it may temporarily reside in a file (such as a page file). The term virtual
refers to the fact that from an execution perspective, there is no need to know if the memory about to be
accessed is in RAM or not; if the memory is indeed mapped to RAM, the CPU will perform the virtual-
to-physical translation before accessing the data. if the memory is not resident (specified by a flag in the
translation table entry), the CPU will raise a page fault exception that causes the memory manager’s page
fault handler to fetch the data from the appropriate file (if indeed it’s a valid page fault), copy it to RAM,
make the required changes in the page table entries that map the buffer, and instruct the CPU to try again.
Figure 1-3 shows this conceptual mapping from virtual to physical memory for two processes.
Figure 1-3: virtual memory mapping
The unit of memory management is called a page. Every attribute related to memory is always at a
page’s granularity, such as its protection or state. The size of a page is determined by CPU type (and on
some processors, may be configurable), and in any case, the memory manager must follow suit. Normal
(sometimes called small) page size is 4 KB on all Windows-supported architectures.
Apart from the normal (small) page size, Windows also supports large pages. The size of a large page is 2
MB (x86/x64/ARM64) or 4 MB (ARM). This is based on using the Page Directory Entry (PDE) to map the
large page without using a page table. This results in quicker translation, but most importantly better use
of the Translation Lookaside Buffer (TLB) – a cache of recently translated pages maintained by the CPU.
Chapter 1: Windows Internals Overview
7
In the case of a large page, a single TLB entry maps significantly more memory than a small page.
The downside of large pages is the need to have the memory contiguous in RAM, which can
fail if memory is tight or very fragmented. Also, large pages are always non-pageable and can
only use read/write protection.
Huge pages
of 1 GB in size are supported on Windows 10 and Server 2016 and later. These are used automatically with
large pages if an allocation is at least 1 GB in size, and that size can be located as contiguous in RAM.
Page States
Each page in virtual memory can be in one of three states:
• Free – the page is not allocated in any way; there is nothing there. Any attempt to access that page
would cause an access violation exception. Most pages in a newly created process are free.
• Committed – the reverse of free; an allocated page that can be accessed successfully (assuming non-
conflicting protection attributes; for example, writing to a read-only page causes an access violation).
Committed pages are mapped to RAM or to a file (such as a page file).
• Reserved – the page is not committed, but the address range is reserved for possible future
commitment. From the CPU’s perspective, it’s the same as Free – any access attempt raises an
access violation exception. However, new allocation attempts using the VirtualAlloc function
(or NtAllocateVirtualMemory, the related native API) that does not specify a specific address
would not allocate in the reserved region. A classic example of using reserved memory to maintain
contiguous virtual address space while conserving committed memory usage is described later in
this chapter in the section “Thread Stacks”.
System Memory
The lower part of the address space is for user-mode processes use. While a particular thread is executing,
its associated process address space is visible from address zero to the upper limit as described in the
previous section. The operating system, however, must also reside somewhere – and that somewhere is
the upper address range that’s supported on the system, as follows:
• On 32-bit systems running without the increase user virtual address space setting, the operating sys-
tem resides in the upper 2 GB of virtual address space, from address 0x80000000 to 0xFFFFFFFF.
• On 32-bit systems configured with the increase user virtual address space setting, the operating
system resides in the address space left. For example, if the system is configured with 3 GB user
address space per process (the maximum), the OS takes the upper 1 GB (from address 0xC0000000
to 0xFFFFFFFF). The component that suffers mostly from this address space reduction is the file
system cache.
• On 64-bit systems running Windows 8, Server 2012 and earlier, the OS takes the upper 8 TB of virtual
address space.
• On 64-bit systems running Windows 8.1, Server 2012 R2 and later, the OS takes the upper 128 TB of
virtual address space.
Chapter 1: Windows Internals Overview
8
Figure 1-4 shows the virtual memory layout for the two “extreme” cases: 32-bit process on a 32-bit system
(left) and a 64-bit process on a 64-bit system (right).
Figure 1-4: virtual memory layout
System space is not process-relative – after all, it’s the same system, the same kernel, the same drivers that
service every process on the system (the exception is some system memory that is on a per-session basis
but is not important for this discussion). It follows that any address in system space is absolute rather than
relative, since it “looks” the same from every process context. Of course, actual access from user mode into
system space results in an access violation exception.
System space is where the kernel itself, the Hardware Abstraction Layer (HAL), and kernel drivers reside
once loaded. Thus, kernel drivers are automatically protected from direct user mode access. It also means
they have a potentially system-wide impact. For example, if a kernel driver leaks memory, that memory
will not be freed even after the driver unloads. User-mode processes, on the other hand, can never leak
anything beyond their lifetime. The kernel is responsible for closing and freeing everything private to a
dead process (all handles are closed and all private memory is freed).
Threads
The actual entities that execute code are threads. A Thread is contained within a process, using the
resources exposed by the process to do work (such as virtual memory and handles to kernel objects).
The most important information a thread owns is the following:
• Current access mode, either user or kernel.
• Execution context, including processor registers and execution state.
• One or two stacks, used for local variable allocations and call management.
• Thread Local Storage (TLS) array, which provides a way to store thread-private data with uniform
access semantics.
• Base priority and a current (dynamic) priority.
• Processor affinity, indicating on which processors the thread is allowed to run on.
Chapter 1: Windows Internals Overview
9
The most common states a thread can be in are:
• Running – currently executing code on a (logical) processor.
• Ready – waiting to be scheduled for execution because all relevant processors are busy or
unavailable.
• Waiting – waiting for some event to occur before proceeding. Once the event occurs, the thread
goes to the Ready state.
Figure 1-5 shows the state diagram for these states. The numbers in parenthesis indicate the state numbers,
as can be viewed by tools such as Performance Monitor. Note that the Ready state has a sibling state called
Deferred Ready, which is similar, and exists to minimize internal locking.
Figure 1-5: Common thread states
Thread Stacks
Each thread has a stack it uses while executing, used to store local variables, parameters passed to functions
(in some cases), and where return addresses are stored prior to making function calls. A thread has at least
one stack residing in system (kernel) space, and it’s pretty small (default is 12 KB on 32-bit systems and 24
KB on 64-bit systems). A user-mode thread has a second stack in its process user-space address range and
is considerably larger (by default can grow to 1 MB). An example with three user-mode threads and their
stacks is shown in figure 1-6. In the figure, threads 1 and 2 are in process A and thread 3 is in process B.
The kernel stack always resides in RAM while the thread is in the Running or Ready states. The reason
for this is subtle and will be discussed later in this chapter. The user-mode stack, on the other hand, may
be paged out, just like any other user-mode memory.
The user-mode stack is handled differently than the kernel-mode stack in terms of its size. It starts out
with a certain amount of committed memory (could be as small as a single page), where the next page is
committed with a PAGE_GUARD attribute. The rest of the stack address space memory is reserved, thus
not wasting memory. The idea is to grow the stack in case the thread’s code needs to use more stack space.
Chapter 1: Windows Internals Overview
10
If the thread needs more stack space it would access the guard page which would throw a page-guard
exception. The memory manager then removes the guard protection, and commits an additional page,
marking it with a PAGE_GUARD attribute. This way, the stack grows as needed, avoiding the entire stack
memory being committed upfront. Figure 1-7 shows this layout.
Figure 1-6: User mode threads and their stacks
Technically, Windows uses 3 guard pages rather than one in most cases.
Chapter 1: Windows Internals Overview
11
Figure 1-7: Thread’s stack in user space
The sizes of a thread’s user-mode stack are determined as follows:
• The executable image has a stack commit and reserved values in its Portable Executable (PE) header.
These are taken as defaults if a thread does not specify alternative values. These are always used for
the first thread in the process.
• When a thread is created with CreateThread (or similar functions), the caller can specify its
required stack size, either the upfront committed size or the reserved size (but not both), depending
on a flag provided to the function; specifying zero uses the defaults set in the PE header.
Curiously enough, the functions CreateThread and CreateRemoteThread(Ex) only
allow specifying a single value for the stack size and can be the committed or the reserved size,
but not both. The native (undocumented) function, NtCreateThreadEx allows specifying
both values.
System Services (a.k.a. System Calls)
Applications need to perform various operations that are not purely computational, such as allocating
memory, opening files, creating threads, etc. These operations can only be ultimately performed by code
running in kernel mode. So how would user-mode code be able to perform such operations?
Let’s take a common (simple) example: a user running a Notepad process uses the File / Open menu to
request opening a file. Notepad’s code responds by calling the CreateFile documented Windows API
function. CreateFile is documented as implemented in kernel32.Dll, one of the Windows subsystem
DLLs. This function still runs in user mode, so there is no way it can directly open a file. After some
error checking, it calls NtCreateFile, a function implemented in NTDLL.dll, a foundational DLL that
implements the API known as the Native API, and is the lowest layer of code which is still in user mode.
This function (documented in the Windows Driver Kit for device driver developers) is the one that makes
the transition to kernel mode. Before the actual transition, it puts a number, called system service number,
into a CPU register (EAX on Intel/AMD architectures). Then it issues a special CPU instruction (syscall
Chapter 1: Windows Internals Overview
12
on x64 or sysenter on x86) that makes the actual transition to kernel mode while jumping to a predefined