2中提供了对该函数的更“隐藏”用法，其中该指令用于计算内存位置。请记住，EVM的存储是单词可寻址内存。固定大小的数据类型具有一个固定的内存插槽。但是，在处理动态数据类型时，即在执行期间其大小可能会增加的类型时，不知道要分配多少个内存插槽。基于实体的智能合约求助于即时计算内存偏移。写入映射时（第3行），相应的内存位置将计算为keccak256（k||p），其中k是映射（映射）的关键，p是在编译时选择的常数。注意，如果可以使用此方案生成有效的哈希冲突，则先前的值将被覆盖。
####  （b）类似内存复制的指令
EVM无法直接访问调用数据，它只能对执行内存中的数据进行操作，即复制输入数据。在List
3中，字符串是无限制的数据类型，导致EVM利用CALLDATACOPY指令将整个输入复制到执行内存。这与具有固定宽度（例如uint256）的数据类型形成对比，该数据类型可以通过从calldata的普通读取中进行访问。
####  （c）合约间通信
Kiffer等人最近的一项调查进一步促进了合约间分析的需要，以太坊当前的合约拓扑。他们指出，大多数合约不是由人部署的，而是由其他合约创建的，从而使这些合约成为合约内交互的一部分。
###  2）奇偶钱包错误
基于这些示例，现在将原始的奇偶校验钱包错误作为真实示例进行检查，在该示例中，需要解决所有以前的问题以获得全面的分析。尽管已经研究了其他类型的智能合约漏洞，但如何以自动化方式检测奇偶校验事件仍然是一个尚未解决的挑战。请注意，本文仅介绍与该分析相关的摘要，对其进行了简化以简化阅读；可以在网上找到完整的源代码清单。
Parity钱包分为两个合约，一个是持有大部分代码库的库合约，另一个是用户部署的客户合约。一旦部署，智能合约就不会改变，因此，当更改（或确定）合约时，必须重新部署并因此偿还整个合约。为了减轻用户的负担，在拆分逻辑时，仅需要重新部署库。
EVM提供DELEGATECALL指令，该指令用于在执行时使用另一个帐户的代码。这些指令在仍然使用原始帐户上下文和存储的同时切换了要执行的代码。考虑List
5，假设用户Alice要使用Parity钱包库。她使用存储变量部署她的客户代码（第15-23行），该存储变量包含库合约的帐户地址（第16行）。稍后调用客户合约时，它将交易委托给库代码（第22行），并转发交易的通话数据（msg.data）。请注意，这还意味着如果攻击者可以将合约的控制流重定向到自己喜欢的地址，那么他们就有能力任意执行代码（例如提取所有资金）。
由于区块链上的每个人都可以调用任何合约，因此智能合约开发人员已经发明了所有者的概念，该变量通常在合约创建过程中设置，用于指定合约所有者的地址。对于奇偶校验多重签名钱包，甚至存在在创建钱包（第7-9行）时初始化的一系列所有者（第2行）。尽管变量是在库代码中定义的，但是由于执行上下文位于原始帐户中，因此变量是在客户合约上设置的。
**分析障碍：**
除合约间通信外，Parity钱包还使用keccak功能，既作为普通调用（第11行），也用作映射数据类型（第3行）。在对msg.data（第11行）进行哈希处理时，由于其（理论上是）无限制的大小，因此会将整个数据复制到执行内存中。因此，静态分析器必须能够推理出合约间的通信以分析所分配的合约以及类似于内存复制的指令和加密散列函数以彻底分析支付函数。
攻击者利用了initWallet函数未标记为私有的事实。在Solidity中，这意味着它默认为public，即任何人都可以调用它。因此，攻击者首先调用initWallet函数，使其成为所有者，然后使用付款函数将钱包的所有资金转移到他的帐户中。请注意，攻击者必须执行两次交易，因此仅分析initWallet是不够的，因为实际的攻击发生在pay函数中。
###  3）最先进的技术
为了对现有方法进行调查，从程序分析领域中基于不同原理选择了各种工具，范围从数据流分析（安全化）到符号执行（Manticore，Mythril，MA
IAN，Oyente和teEther），以抽象解释（Van
dal和MadMax）。本文无法充分介绍每种技术，但是，有兴趣的读者可以参考Nielson等人的出色著作。
在审查中，发现所有工具都使用某种过度逼近的方法，这可能会引入错误的积极因素。因此将“验证”定义为另一个潜在障碍。也就是说，此后是否正确验证了任何过度逼近？上表给出了本文分析结果的概述。请注意，MadMax基于Vandal，因此它继承了其局限性，下面仅详细讨论Vandal。
####  （a） Keccak256函数
由于keccak计算的普遍性，本研究分析的大多数工具都提供了某种策略来在分析过程中对其进行处理，但是所有这些工具都不精确。所有工具都支持在具有恒定参数的恒定执行内存区域上计算keccak值（即，每个内存值都是非符号的）。这使他们可以提取相应的内存区域并计算实际的哈希值。
安全考虑在符号计算期间将每个内存位置都视为潜在的依赖项，即使实际上是不可行的。
Mythril在遇到符号偏移量或内存的符号部分时，会将keccak值与新的不受约束的符号位过分近似。当任何内存值或自变量是符号时，Manticore会使用一个调和策略，并将其值固定为常量。但是，它们保留所有先前计算的哈希的映射，并尝试将当前哈希与已看到的哈希进行匹配。同样，teEther在符号执行期间存储一个占位符对象，然后应用一个策略策略来解析所有可见的占位符。
Vandal不会尝试任何具体的或符号处理，但会忽略指令并将结果视为新的符号变量。上述方案的异常点是Oyente，它仅支持具体的keccak计算，但不花力气计算实际值。它宁愿提取内存区域的字符串表示形式，对其进行压缩和base64编码，然后使用此编码作为映射来匹配以后的哈希计算[37]。
**本文解决方案：**
遇到符号keccak值时，使用特殊编码方案。该方案基于keccak是绑定函数的想法，即，当将相同的输入提供给该函数时，它将产生相同的输出。当它们的输入存储区可以相同时，通过向执行添加约束，将不同的keccak计算编码为相同，来利用这种行为。
####  （b）内存建模
审查显示，没有经过检查的工具完全支持精确的内存模型。一些人采用过分逼近或固执策略来规避关于符号记忆复制式操作，而另一些人则选择不支持它们。更具体地说，MAIAN支持符号读取操作，但会删除任何符号写入或内存复制式操作。
Mythril支持标准的读/写操作，但是在输入复制指令时会遇到麻烦。它正确地处理了具体的问题，但是，例如，当向主题复制操作提供符号偏移量时，它要么删除路径，要么将其大小固定为1。同样，Manticore和teEther完全支持简单的内存操作，但否则请采用concil策略。当遇到任何符号内存写入时，Securify会表现得比较保守，会清除整个内存，因为它不再能推理出具体细节。
Oyente和Vandal都不支持任何基于副本的指令。
**本文解决方案：**
与以前的工作相反，本文采用了完全符号存储模型。将内存表示为图形表示，当从一个内存复制到另一个内存时，连接不同的内存区域。当需要评估给定路径的可行性时，使用众所周知的数组理论以及Falke等人的扩展，将主题图编码为约束解决类似内存复制的操作。
####  （c）合约间分析
Mythril和Manticore是仅有的两个支持合约间分析的工具，但是，两者都以不精确的方式进行。当合约与另一个合约交互时，下一次执行的输入来自被调用者的执行内存。Mythril和Manticore都支持完全具体的合约调用，即，如果用作调用数据的执行内存部分完全对应于具体值，则执行将照常继续。但是，当相关内存区域中的任何值都是符号性的时，两种工具都采用不同的策略来解决该问题。
Mythril忽略了执行内存的内容，并通过创建一个新的不受约束的数组对象来过度逼近调用数据。相比之下，Manticore采用了一种锥度方法，将任何符号值固定为常数。
**本文解决方案：** 利用支持符号复制指令的内存模型来正确地为调用操作建模输入内存。
####  （d）验证
本节中讨论的所有工具都严重依赖于过度逼近。想强调的是，这是一种常见的方法，对于对抗状态爆炸是必不可少的。尽管如此，这些设计选择显然会导致误报。认识到这些问题，MAIAN和teEther都使用私有链来在受控环境中模拟其错误发现。其他方法均未尝试修剪潜在的误报。
**本文解决方案：** 遵循先前的工作，并模拟每个潜在的错误，将其作为具体的脱机执行以清除误报。
## 0x04 Modelling Ethereum
在下文中概述了作为ETHBMC基础的理论模型。从攻击媒介概述和一般介绍入手，进入环境建模，广泛介绍支持内存复制的内存模型，最后描述对call和keccak指令的处理。
###  1）攻击者模型
ETHBMC提供了以太坊生态系统的符号化，多账户功能表示，可用于检查任意模型。为了演示其功能，对认为最关键的三个特定攻击媒介进行了建模：首先，是一个想要从分析的合约中提取以太币的攻击者。其次，想要将分析后的合约的控制流重定向到自己的帐户的攻击者。第三，想要自毁分析后的合约的攻击者。请注意，仅要求攻击者能够参与以太坊协议，从而为她提供网络和区块链的实时视图，包括对合约的存储和字节码级别访问（即对世界状态的访问）。