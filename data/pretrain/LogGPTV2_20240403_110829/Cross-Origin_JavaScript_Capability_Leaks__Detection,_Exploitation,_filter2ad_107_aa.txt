# Cross-Origin JavaScript Capability Leaks: Detection, Exploitation, and Defense

**Authors:**
- Adam Barth
- Joel Weinberger
- Dawn Song

**Affiliations:**
- UC Berkeley

**Contact:**
- PI: EMAIL (for all authors)

## Abstract

We identify a class of Web browser implementation vulnerabilities known as cross-origin JavaScript capability leaks. These occur when a browser leaks a JavaScript pointer from one security origin to another. We have developed an algorithm to detect these vulnerabilities by monitoring the "points-to" relation in the JavaScript heap. Our algorithm has identified several new vulnerabilities in the open-source WebKit browser engine used by Safari. We propose a mitigation approach by adding access control checks to the browser's JavaScript engine. These checks are backward-compatible and do not alter the semantics of the Web platform. Using inline caching, we implement these checks with an overhead of 1–2% on industry-standard benchmarks.

## 1. Introduction

In this paper, we identify a class of Web browser implementation vulnerabilities, referred to as cross-origin JavaScript capability leaks, and develop systematic techniques for detecting, exploiting, and defending against these vulnerabilities. An attacker who exploits such a leak can inject a malicious script into an honest website's security origin. These attacks are more severe than cross-site scripting (XSS) attacks because they affect all websites, including those free of XSS vulnerabilities. Once an attacker can run a script in an arbitrary security origin, they can, for example, issue transactions on the user’s bank account, regardless of SSL encryption, cross-site scripting filters, or Web application firewalls.

### 1.1 Architectural Flaw

These cross-origin JavaScript capability leaks are caused by an architectural flaw shared by most modern Web browsers: the Document Object Model (DOM) and the JavaScript engine enforce the same-origin policy using two different security models.

- **Access Control:** The DOM enforces the same-origin policy using a reference monitor that prevents one website from accessing resources allocated to another. For example, when a script attempts to access the cookie database, the DOM checks whether the script’s security origin has sufficient privileges.
  
- **Object-Capabilities:** The JavaScript engine enforces the same-origin policy using an object-capability discipline, preventing one website from obtaining JavaScript pointers to sensitive objects in a foreign security origin. Without these pointers, malicious scripts cannot interfere with those objects.

Most modern browsers, including Internet Explorer, Firefox, Safari, Google Chrome, and Opera, use this design. However, the mismatch in enforcement paradigms leads to vulnerabilities whenever the browser leaks a JavaScript pointer from one security origin to another. Once a malicious script gets a JavaScript pointer to an honest JavaScript object, it can leverage the object-capability security model to escalate its DOM privileges, potentially compromising the honest security origin.

### 1.2 Contributions

- **Vulnerability Identification:** We identify cross-origin JavaScript capability leaks as a class of vulnerabilities where the browser leaks a JavaScript pointer from one security origin to another.
  
- **Detection Algorithm:** We introduce an algorithm for detecting these leaks by monitoring the "points-to" relation in the JavaScript heap. This algorithm uses a graph-based definition of the security origin of a JavaScript object.
  
- **Exploitation Techniques:** We reveal specific vulnerabilities and demonstrate techniques for exploiting them, highlighting the mismatch between the DOM's access control model and the JavaScript engine's object-capability model.
  
- **Defense Mechanism:** We propose that browsers defend against these leaks by implementing access control checks in the JavaScript engine. This defense is backward-compatible and incurs only a 1–2% overhead on industry-standard benchmarks.

### 1.3 Organization

- **Section 2:** Identifies cross-origin JavaScript capability leaks as a class of vulnerabilities.
- **Section 3:** Presents our algorithm for detecting these leaks.
- **Section 4:** Details the individual vulnerabilities and outlines exploitation techniques.
- **Section 5:** Proposes a defense mechanism by adding access control checks to the JavaScript engine.
- **Section 6:** Relates our work to the existing literature.
- **Section 7:** Concludes the paper.

## 2. Cross-Origin JavaScript Capability Leaks

### 2.1 Object-Capabilities

In modern Web browsers, the JavaScript engine enforces the same-origin policy using an object-capability discipline. A script can obtain pointers only to JavaScript objects created by documents in its security origin. Scripts can access properties of JavaScript objects to which they already have a pointer or conjure certain built-in objects like the global object and `Object.prototype`.

The ability to influence an object is tied to the ability to designate the object. A script can manipulate a JavaScript object only if it has a pointer to the object. Without a pointer to an object in a foreign security origin, a malicious script cannot influence honest JavaScript objects.

One exception is the JavaScript global object, which is visible to foreign security origins. APIs like `contentWindow` allow access to global objects from foreign origins. Unlike most JavaScript objects, the global object is also a DOM object (called `window`) and has a reference monitor to prevent unauthorized access. However, some properties, like `postMessage`, are exposed across origins, complicating the enforcement of the same-origin policy and leading to potential vulnerabilities.

### 2.2 Capability Leaks

Browsers occasionally contain bugs that leak JavaScript pointers from one security origin to another. These vulnerabilities are easy to introduce because the DOM contains pointers to JavaScript objects in multiple security origins, and developers can easily select the wrong pointer to disclose to a script. We identify these vulnerabilities as a class, called cross-origin JavaScript capability leaks, because they follow a common pattern.

JavaScript objects inherit many properties from a prototype object. When a script accesses a property, the JavaScript engine looks up the property on the object or its prototype. If an attacker obtains a pointer to an honest object, they can traverse the prototype chain to the `Object.prototype` object and influence the behavior of other JavaScript objects associated with the honest document.

### 2.3 Laundries

Once an attacker has obtained a pointer to the `Object.prototype` of an honest document, they can compromise the honest security origin. One approach is to abuse powerful functions reachable from `Object.prototype`, which we refer to as laundries. These functions often call one or more DOM APIs, allowing the attacker to call these APIs indirectly. If the attacker calls these functions with unexpected arguments, they might become confused deputies and inadvertently perform the attacker’s misdeeds.

Most websites contain numerous laundries. For example, the `invoke` method in the Prototype JavaScript library can be abused to call functions with unexpected arguments, leading to potential security breaches.

---

This revised version aims to make the text more coherent, professional, and easier to read.