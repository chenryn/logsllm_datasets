title:Cross-Origin JavaScript Capability Leaks: Detection, Exploitation,
and Defense
author:Adam Barth and
Joel Weinberger and
Dawn Song
Cross-Origin JavaScript Capability Leaks:
Detection, Exploitation, and Defense
Joel Weinberger
UC Berkeley
PI:EMAIL
Dawn Song
UC Berkeley
PI:EMAIL
Adam Barth
UC Berkeley
PI:EMAIL
Abstract
We identify a class of Web browser implementation
vulnerabilities, cross-origin JavaScript capability leaks,
which occur when the browser leaks a JavaScript pointer
from one security origin to another. We devise an algo-
rithm for detecting these vulnerabilities by monitoring
the “points-to” relation of the JavaScript heap. Our algo-
rithm ﬁnds a number of new vulnerabilities in the open-
source WebKit browser engine used by Safari. We pro-
pose an approach to mitigate this class of vulnerabilities
by adding access control checks to browser JavaScript
engines. These access control checks are backwards-
compatible because they do not alter semantics of the
Web platform. Through an application of the inline
cache, we implement these checks with an overhead of
1–2% on industry-standard benchmarks.
1
In this paper, we identify a class of Web browser im-
plementation vulnerabilities, which we refer to as cross-
origin JavaScript capabilities leaks, and develop sys-
tematic techniques for detecting, exploiting, and defend-
ing against these vulnerabilities. An attacker who ex-
ploits a cross-origin JavaScript capability leak can in-
ject a malicious script into an honest Web site’s secu-
rity origin. These attacks are more severe than cross-
site scripting (XSS) attacks because they affect all Web
sites, including those free of XSS vulnerabilities. Once
an attacker can run script in an arbitrary security origin,
the attacker can, for example, issue transactions on the
user’s bank account, regardless of any SSL encryption,
cross-site scripting ﬁlter, or Web application ﬁrewall.
Introduction
We observe that these cross-origin JavaScript capa-
bility leaks are caused by an architectural ﬂaw shared
by most modern Web browsers: the Document Object
Model (DOM) and the JavaScript engine enforce the
same-origin policy using two different security models.
The DOM uses an access control model, whereas the
JavaScript engine uses object-capabilities.
• Access Control. The DOM enforces the same-
origin policy using a reference monitor that pre-
vents one Web site from accessing resources allo-
cated to another Web site. For example, whenever
a script attempts to access the cookie database, the
DOM checks whether the script’s security origin
has sufﬁcient privileges to access the cookies.
• Object-Capabilities. The JavaScript engine en-
forces the same-origin policy using an object-
capability discipline that prevents one Web site
from obtaining JavaScript pointers to sensitive ob-
jects that belong to a foreign security origin. With-
out JavaScript pointers to sensitive objects in for-
eign security origins, malicious scripts are unable
to interfere with those objects.
Most modern Web browsers,
including Internet Ex-
plorer, Firefox, Safari, Google Chrome, and Opera, use
this design. However, the design’s mismatch in en-
forcement paradigms leads to vulnerabilities whenever
the browser leaks a JavaScript pointer from one secu-
rity origin to another. Once a malicious script gets a
JavaScript pointer to an honest JavaScript object, the at-
tacker can leverage the object-capability security model
of the JavaScript engine to escalate its DOM privileges.
With escalated DOM privileges, the attacker can com-
pletely compromise the honest security origin by inject-
ing a malicious script into the honest security origin.
To study this class of vulnerabilities, we devise an al-
gorithm for detecting individual cross-origin JavaScript
capability leaks. Using this algorithm, we uncover new
instances of cross-origin JavaScript capability leaks in
the WebKit browser engine used by Safari. We then il-
lustrate how an attack can abuse these leaked JavaScript
pointers by constructing proof-of-concept exploits. We
propose defending against cross-origin JavaScript capa-
bility leaks by harmonizing the security models used by
the DOM and the JavaScript engine.
• Leak Detection. We design an algorithm for au-
tomatically detecting cross-origin JavaScript ca-
pability leaks by monitoring the “points-to” rela-
tion among JavaScript objects in the heap. From
this relation, we deﬁne the security origin of each
JavaScript object by tracing its “prototype chain.”
We then search the graph for edges that connect ob-
jects in one security origin with objects in another
security origin. These suspicious edges likely rep-
resent cross-origin JavaScript capability leaks.
• Vulnerabilities and Exploitation. We implement
our leak detection algorithm and ﬁnd two new high-
severity cross-origin JavaScript capability leaks in
WebKit. Although these vulnerabilities are imple-
mentation errors in WebKit, the presence of the
bugs illustrates the fragility of the general architec-
ture. (Other browsers have historically had similar
vulnerabilities [17, 18, 19].) We detail these vulner-
abilities and construct proof-of-concept exploits to
demonstrate how an attacker can leverage a leaked
JavaScript pointer to inject a malicious script into
an honest security origin.
• Defense. We propose that browser vendors proac-
tively defend against cross-origin JavaScript capa-
bility leaks by implementing access control checks
throughout the JavaScript engine instead of reac-
tively plugging each leak. Adding access control
checks to the JavaScript engine addresses the root
cause of these vulnerabilities (the mismatch be-
tween the security models used by the DOM and
by the JavaScript engine) and provides defense-in-
depth in the sense that both an object-capability
and an access control failure are required to create
an exploitable vulnerability. This defense is per-
fectly backwards-compatible because these access
checks do not alter the semantics of the Web plat-
form. Our implementation of these access control
checks in WebKit incurs an overhead of only 1–2%
on industry-standard benchmarks.
Contributions. We make the following contributions:
• We identify a class of Web browser implementa-
tion vulnerabilities: cross-origin JavaScript capa-
bility leaks. These vulnerabilities arise when the
browser leaks a JavaScript pointer from one secu-
rity origin to another security origin.
• We introduce an algorithm for detecting cross-
origin JavaScript capability leaks by monitoring the
“points-to” relation of the JavaScript heap. Our al-
gorithm uses a graph-based deﬁnition of the secu-
rity origin of a JavaScript object.
• We reveal cross-origin JavaScript capability leaks
and demonstrate techniques for exploiting these
vulnerabilities. These exploits rely on the mis-
match between the DOM’s access control security
model and the JavaScript engine’s object-capability
security model.
• We propose that browsers defend against cross-
origin JavaScript capability leaks by implement-
ing access control checks in the JavaScript engine.
This defense is perfectly backwards-compatible
and achieves a low overhead of 1–2%.
Organization. This paper is organized as follows.
Section 2 identiﬁes cross-origin JavaScript capability
JavaScript Capability Leaks
leaks as a class of vulnerabilities. Section 3 presents our
algorithm for detecting cross-origin JavaScript capabil-
ity leaks. Section 4 details the individual vulnerabili-
ties we uncover with our algorithm and outlines tech-
niques for exploiting these vulnerabilities. Section 5
proposes defending against cross-origin JavaScript ca-
pability leaks by adding access control checks to the
JavaScript engine. Section 6 relates our work to the lit-
erature. Section 7 concludes.
2
In this section, we describe our
interpretation of
JavaScript pointers as object-capabilities and identify
cross-origin JavaScript capability leaks as a class of im-
plementation vulnerabilities in browsers. We then sketch
how these vulnerabilities are exploited and the conse-
quences of a successful exploit.
2.1 Object-Capabilities
In modern Web browsers,
the JavaScript engine en-
forces the browser’s same-origin policy using an object-
capability discipline: a script can obtain pointers only
to JavaScript objects created by documents in its se-
curity origin. A script can obtain JavaScript point-
ers to JavaScript objects either by accessing prop-
erties of JavaScript object
to which the script al-
ready has a JavaScript pointer or by conjuring cer-
tain built-in objects such as the global object and
Object.prototype [14].
As in other object-
capability systems, the ability to inﬂuence an object is
tied to the ability to designate the object. In browsers,
a script can manipulate a JavaScript object only if the
script has a pointer to the object. Without a pointer to
an object in a foreign security origin, a malicious script
cannot inﬂuence honest JavaScript objects and cannot
interfere with honest security origins.
One exception to this object-capability discipline is
the JavaScript global object. According to the HTML 5
speciﬁcation [10], the global object (also known as the
window object) is visible to foreign security origins.
There are a number of APIs for obtaining pointers to
global objects from foreign security origins. For exam-
ple, the contentWindow property of an 
element is the global object of the document contained
in the frame. Unlike most JavaScript objects, the global
object is also a DOM object (called window) and is
equipped with a reference monitor that prevents scripts
in foreign security origins from getting or setting arbi-
trary properties of the object. This reference monitor
does not forbid all accesses because some are desirable.
For example, the postMessage method [10] is ex-
posed across origins to facilitate mashups [1]. These
exposed properties complicate the enforcement of the
same-origin policy, which can lead to vulnerabilities.
2.2 Capability Leaks
Browsers occasionally contain bugs that leak JavaScript
pointers from one security origin to another. These
vulnerabilities are easy for developers to introduce
into browsers because the DOM contains pointers to
JavaScript objects in multiple security origins and de-
velopers can easily select the wrong pointer to disclose
to a script. We identify these vulnerabilities as a class,
which we call cross-origin JavaScript capabilities leaks,
because they follow a common pattern. Identifying this
class lets us analyze the concepts common to these vul-
nerabilities in all browsers.
The JavaScript language makes pointer leaks particu-
larly devastating for security because JavaScript objects
inherit many of their properties from a prototype ob-
ject. When a script accesses a property of an object, the
JavaScript engine uses the following algorithm to look
up the property:
• If the object has the property, return its value.
• Otherwise,
look up the property on the ob-
ject’s prototype (designated by the current object’s
__proto__ property).
in turn,
These prototype objects,
inherit many of
their properties from their prototypes in a chain that
leads back to the Object.prototype object, whose
__proto__ property is null. All the objects associ-
ated with a given document have a prototype chain that
leads back to that document’s Object.prototype
object. Given a JavaScript pointer to an object, a script
can traverse this prototype chain by accessing the ob-
ject’s __proto__ property.
In particular, if an at-
tacker obtains a pointer to an honest object, the at-
tacker can obtain a pointer to the honest document’s
Object.prototype object and can inﬂuence the be-
havior of all the other JavaScript objects associated with
the honest document.
2.3 Laundries
Once the attacker has obtained a pointer
to the
Object.prototype of an honest document, the at-
tacker has several avenues for compromising the hon-
est security origin. One approach is to abuse pow-
erful functions reachable from Object.prototype,
which we refer to as laundries because they let the at-
tacker “wash away” his or her agency (analogous to
laundering money). These functions often call one or
more DOM APIs, letting the attacker call these APIs in-
directly. Because these functions are deﬁned by the hon-
est document, the DOM’s reference monitor allows the
access [10]. However, if the attacker calls these func-
tions with unexpected arguments, the functions might
become confused deputies [9] and inadvertently perform
the attacker’s misdeeds.
Most Web sites contains innumerable laundries. We
illustrate how an attacker can abuse a laundry by ex-
amining a representative laundry from the Prototype
JavaScript library [22]: invoke. The invoke method