### Facebook Contact Sync App: A Malicious Dialer

This application, disguised as a Facebook contact sync tool, covertly dials premium-rate numbers late at night when the mobile device is not in use. The attacker can generate revenue until the user notices these hidden calls. This activity generates detectable, malicious telecom traffic to the premium numbers.

#### Evasive Actions
Our malware instance includes two evasive actions designed to prolong its existence on infected devices:

1. **Call Log Deletion**: The app removes its entries from the device’s call logs, making it difficult for even observant users to detect the malicious activity. This maximizes financial loss for the user and gain for the attacker.
2. **Hidden ARM Executable**: The actual malicious dialer functionality is hidden in an ARM executable (2facedsrv) installed by 2Faced into the device’s local storage. This executable is embedded within the image resources of 2Faced, evading detection via static app analysis. The native process is only 14 lines of code, and its extraction and invocation from 2Faced requires fewer than 100 lines of Java-based code. This delivery method has been observed in the iKee.B iPhone botnet [36].

Native processes are particularly useful for malware authors. 2facedsrv executes its malicious behavior with the same permissions as the Java-based parent 2Faced. It continues running even after the user exits the parent application, only stopping upon device reboot. After a reboot, it restarts when 2Faced is relaunched. Native ARM processes are not listed in Android’s default interface, making them detectable only by the most observant and expert users who review the full process list.

### Thor: A Mobile Bot Client

#### Overview
Our third and final malware instance, Thor, combines:
- **Malicious Functionality**: Bot client.
- **Evasive Functionality**: Persistence across reboots.
- **Benign Host App**: Weather display.

This sample demonstrates how current desktop malware can be equally dangerous in mobile environments. We ported an existing Windows-based botnet client [25] to Android, which we refer to as Thor (1,353 lines of code). Its original functionality included system command execution, local file access, and denial-of-service (DoS) attacks using HTTP, UDP, and TCP SYN floods. For safety reasons, our port removed its propagation functionality and directed its command-and-control (C&C) connection to machines under our control. We integrated the bot client abilities into MyWeather [33], an open-source weather application. When executing, it generates a malicious network footprint containing both C&C and attack traffic.

#### Installation and Operation
Unlike the previous malware instances, Thor is installed as a separate service from MyWeather. The service is immediately active and restarts on every boot of the device. It first connects to two predefined IRC channels used as the main control channel for the botnet. After connecting, Thor waits for one of our commands, including data exfiltration or DoS.

Mobile bot clients can be used for targeted attacks against the cellular network. By using GPS location, the botnet can target specific base stations or regions for attack. Bots with additional capabilities can augment these location-based DoS attacks with voice and text message traffic, making attacks more effective. In large numbers, such compromised devices can bring down significant portions of the cellular network [41].

### Airmid: Automated Remote Repair System

#### Threat Model & Design Principles
Airmid detects and responds to malicious software execution on cellular and mobile devices. The threat model encompasses two primary types of attack:
1. **Installation of Malware**: Attackers install malware via various mechanisms, including drive-by downloads, automated propagation, and distribution on official and third-party app marketplaces.
2. **Subversion of Benign Apps**: Attackers exploit security defects in benign apps to execute malicious code.

Both attacks result in undesirable software execution on the targeted device, possibly with root access. The correct functioning of Airmid depends on several reasonable assumptions:
- **Protected Software Layer**: A layer below the malware execution level, such as a hardened kernel or hypervisor.
- **Communication Channel**: A channel between the network and each device, even if intermittently connected.
- **Detectable Malicious Behavior**: Network-based attack detection to avoid costly on-device detection.

#### High-Level Workflow
1. **Detection**: An infected device sends or receives malicious data or voice communication detected by network sensors.
2. **Notification**: The provider notifies an Airmid server of the offending traffic.
3. **Authenticated Message**: The server transmits an authenticated message to the protected client-side Airmid software on the infected device.
4. **Attribution and Remediation**: The software attributes the malicious network traffic to a responsible process and initiates remediation actions.

#### Remote Repair
Airmid consists of a server-based infection detection system and an on-device attribution and remediation system. The network-based detection system observes behaviors correlated across multiple devices, while the on-device software permits detailed, real-time inspection and restoration of benign operation. Airmid's cooperative design combines broad network perspective, detailed device knowledge, and effective attack response.

#### Authenticated Communication
Airmid authentication extends UMTS authentication, reusing existing network functionality and secret keys. This approach provides mutual authentication and secure communication through the cellular network. The Airmid server and device component verify each other's knowledge of the shared secret key, ensuring a secure channel.

#### Implementation
Our prototype implementation includes:
- **Network Component**: An attack detection system (Snort) and the Airmid server (Python with Scapy).
- **Device Component**: A hardened Linux kernel (version 2.6.29) with disabled module loading. A kernel thread performs infection provenance and remediation.

#### Provenance Mechanism
When a user installs an application, Android generates a unique Linux user ID. The device crawls kernel data structures (inet_hashinfo and task_struct) to map the port number to an open socket and find the process holding the socket. From the task_struct, the user ID of the malicious process is extracted, and all files owned by this application are identified.

#### Remediation Strategies
The following recovery options are employed, ordered from least likely to create side effects to most likely:
- **Process Termination**
- **On-Device Traffic Filtering**
- **App Update**
- **Device Update**
- **File Removal**
- **Factory Reset**

Decision logic within the software component selects an action based on the nature of the offending network traffic, the identity of the attributed process, and that process' privilege level.