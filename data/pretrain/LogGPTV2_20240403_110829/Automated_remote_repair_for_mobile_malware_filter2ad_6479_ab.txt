It is a Facebook contact sync app that dials premium num-
bers late at night when the mobile device is not in use. The
attacker can generate revenue until the user of the device
notices these hidden calls. It creates detectable, malicious
telecom traﬃc to the premium numbers.
Our malware instance includes two evasive actions de-
signed to prolong its existence on infected devices. First,
it evades early detection from a vigilant user by removing
its entries from the device’s call logs. Even observant users
will be unable to detect malicious activity, maximizing both
the ﬁnancial loss for the user and the gain for the attacker.
Second, the actual malicious dialer functionality is hidden
in an ARM executable (2facedsrv) installed by 2Faced into
the device’s local storage. We evade detection via static app
analysis by distributing 2facedsrv inside the image resources
of 2Faced, though the executable could also be retrieved re-
motely. The native process is only 14 lines of code, and its
Table 1: Summary of permissions requested by sample mobile malware.
Loudmouth
(cid:88)
(cid:88)
(cid:88)
Permissions
Network access
Coarse location
GPS location
Read contacts
Write contacts
Call phone
2Faced Thor
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
extraction and invocation from 2Faced requires fewer than
100 lines of code in the Java-based portion of 2Faced. This
delivery method has recently been observed in the iKee.B
iPhone botnet [36].
Native processes are particularly useful to a malware au-
thor. Here, 2facedsrv is able to execute its malicious be-
havior because it is launched with the same permissions as
the Java-based parent 2Faced. Notably, it is not terminated
when the user exits the parent application, but rather runs
until the device reboots. After a reboot, it then restarts
when 2Faced is relaunched. Native ARM processes are not
listed in Android’s default interface, so only the most ob-
servant and expert users might detect it by reviewing a full
process list.
3.2.3 Thor
Our third and ﬁnal malware instance, Thor, combines:
• Malicious mobile functionality: Bot client.
• Evasive functionality: Persistence across reboot.
• Benign host app: Weather display.
Our last malware sample demonstrates how current desktop
malware can become equally dangerous in mobile environ-
ments. We ported to Android an existing Windows-based
botnet client [25], which we refer to as Thor (1,353 lines of
code). Its original functionality included system command
execution, local ﬁle access, and denial-of-service (DoS) at-
tacks using HTTP, UDP, and TCP SYN ﬂoods. For safety
reasons, our port removed its propagation functionality and
pointed its command-and-control (C&C) connection to ma-
chines under our control. We added the bot client abilities to
MyWeather [33], an open-source weather application. When
executing, it generates a malicious network footprint con-
taining both C&C and attack traﬃc.
Unlike the previous malware instances, Thor is installed
as a service separate from MyWeather. The service is im-
mediately active and restarts on every boot of the device. It
ﬁrst connects to two diﬀerent predeﬁned IRC channels used
as the main control channel for the botnet. After connect-
ing, Thor waits for one of our commands, including data
exﬁltration or DoS.
Mobile bot clients can be used for targeted attacks against
the cellular network. By using the GPS location, the botnet
can target speciﬁc base stations or regions for attack. Bot
clients with additional capabilities can potentially augment
these location-based denial-of-service attacks with both voice
and text message traﬃc, making attacks more eﬀective. In
large numbers, such compromised devices can bring down
large portions of the cellular network [41].
4. ARCHITECTURE
mobile devices regardless of protective measures taken to
prevent their spread. Automated remediation provides op-
portunities to repair infected systems. Here, we describe the
design of our proposed remote repair system, Airmid, which
implements the detection, attribution, and remediation of
malware infections in mobile environments.
4.1 Threat model & design principles
Airmid detects and responds to malicious software exe-
cution on cellular and mobile devices. This is a straight-
forward threat model encompassing two primary types of
attack. First, we expect attackers to successfully install mal-
ware on mobile devices via a variety of usual mechanisms,
such as drive-by downloads or automated propagation, and
by mobile-speciﬁc techniques, including distribution on of-
ﬁcial and third-party app marketplaces. Second, attackers
can subvert the correct execution of a benign app by exploit-
ing a security defect in the app’s design or implementation.
Both attacks result in undesirable software execution on the
targeted device, possibly with root access.
In this threat model, the correct functioning of our pro-
posed prototype system then depends on several reasonable
assumptions holding true. We assume the existence of the
following:
• A protected software layer on the device lower than the
level at which the malware executes. Our remediation
design includes on-device software that, if subverted,
will result in unsuccessful recovery. Reasonable candi-
date layers include the kernel (if kernel-level malware
can be prevented) and a hypervisor (if virtualized en-
vironments can be created on a mobile device). For
our prototype implementation, we chose to operate at
the kernel level and harden the kernel appropriately.
• A communication channel between the network and
each device, even if the channel is intermittently con-
nected. Our cooperative design sends signals from net-
work detection systems to software agents on infected
systems, and we expect that these signals will ulti-
mately reach any device. While the permanent ab-
sence of a communication channel prevents remedia-
tion, it likewise prevents malice from spreading beyond
the device.
• Detectable malicious behavior in the network. We
chose to use network-based attack detection rather than
on-device detection to avoid the costly process of tra-
ditional signature-based malware detection. In mobile
environments, the storage, computation, and power
costs of malware detection may be prohibitive, and
moving detection into the network avoids those costs
altogether.
We expect that malware such as that presented in Sec-
tion 3 will ultimately be successfully installed on unwitting
We have no ability to prevent device owners from root-
ing or jailbreaking their devices and then overwriting the
Figure 1: High-level workﬂow of automated remote repair. (1) An infected device sends or receives malicious
data or voice communication detected by network sensors deployed within a provider’s network. (2) The
provider notiﬁes an Airmid server of the oﬀending traﬃc. (3) The server transmits an authenticated message
to the protected client-side Airmid software on the infected device. (4) The software attributes the malicious
network traﬃc to a responsible process, and initiates remediation actions.
Airmid software. Reﬂashed devices simply will not bene-
ﬁt from automated repair of infections and may simply be
denied service by their provider should malicious traﬃc be
detected (as currently happens).
4.2 Remote repair
Our remote repair design consists of a server-based infec-
tion detection system and an on-device attribution and re-
mediation system that cooperate to automatically identify
and repair infected devices. The network-based detection
system has a broad view of a provider’s entire network:
it
can observe behaviors correlated across multiple devices that
would not be meaningful to any single device, such as a dis-
tributed denial-of-service attack or exﬁltrated data all trans-
mitted to the same server. The on-device software permits
detailed, real-time inspection of device state and the ability
to eﬀect changes that restore benign operation. The server
automatically initiates remediation of infected devices via
an authenticated communication channel. Airmid’s cooper-
ative design allows these strengths to be combined: broad
network perspective, detailed device knowledge, and eﬀec-
tive attack response.
During an active infection, Airmid operates as shown in
Figure 1. Depending upon the nature of the speciﬁc infec-
tion, an infected device sends and receives malicious data—
such as propagation traﬃc, command-and-control, and ex-
ﬁltrated data—and generates calls or text messages to high-
cost recipients. A network sensor (which could be using
data sources including DNS blacklists, patterns of known
botnets [23] or other technique) monitoring data and tele-
com networks (1) identiﬁes infected devices based upon these
malicious traﬃc patterns. It notiﬁes (2) the Airmid server
of the oﬀending devices and traﬃc, and the server sends
the alerts across the authenticated channel to each infected
device (3). The on-device software receives the alert (4), in-
spects the kernel’s internal state to attribute the malicious
network traﬃc to a particular process or service, and then
initiates one or more remediation actions against that pro-
cess.
The Airmid on-device software executes from within a
trusted, low layer on the device, such as a hardened kernel
or hypervisor. It has two responsibilities: attribute traﬃc
to malware, and repair the infection. Attribution is closely
tied to a particular mobile operating system’s implementa-
tion, so we defer the presentation of our Android-speciﬁc
analysis to Section 4. Once it has identiﬁed software on a
device responsible for whatever network behaviors triggered
the detection system, the software executes repair actions
to disable malicious activity or to remove malware entirely.
We employ the following recovery options, loosely ordered
from least likely to create side-eﬀects to most likely:
• Process termination.
• On-device traﬃc ﬁltering.
• App update.
• Device update.
• File removal.
• Factory reset.
Decision logic within the software component will select an
action based upon the nature of the oﬀending network traf-
ﬁc, the identity of the attributed process, and that process’
privilege level.
4.3 Authenticated communication
The Airmid software executes attribution and recovery
when signaled by the network intrusion detection system.
The communication channel carrying these signals clearly
must be secured to prevent illicit triggering of operations
that change a device’s state. Airmid authentication aug-
ments initial UMTS authentication in a cellular network,
as shown in Figure 2. It extends the scope of authentica-
tion from the device and network to the Airmid device and
server components, reusing existing network functionality
and secret keys. This has three beneﬁts: ﬁrst, no additional
secrets need to be shared or updated for this authentica-
tion, as one private key manages both authentication types.
Second, the diﬃculty of integration into existing networks
Cellular ProviderNetwork34AirmidServer1Network sensor2Figure 2: Authentication ﬂow: the Airmid authentication extends existing UMTS authentication. The device
and network are mutually authenticated after UMTS authentication and all further traﬃc is encrypted using
a session key. Airmid extends this authentication process to create a secure channel between the Airmid
server and the process running on the mobile phone.
is reduced, as no additional authentication servers are re-
quired. Third, the approach provides the same guarantees
as existing UMTS authentication and can be upgraded at
the same time if needed.
The ﬁnal step of UMTS authentication completes the mu-
tual authentication and sets a session key used for encryp-
tion. Airmid extends this authentication process.2 All traf-
ﬁc is encrypted through the existing session key, which guar-
antees a secure connection through the cellular network. At
this point the Mobile Switching Center (MSC) notiﬁes the
Airmid server of the newly authenticated device. The server
then requests UMTS Authentication Vectors (AV) from the
Home Location Register (HLR), the device storing the long-
term credentials for traditional telephony authentication.
These AVs consist of the RAND, XRES and AUTN val-
ues, which are the randomly generated user challenge, ex-
pected user response, and the authentication token respec-
tively. The Airmid server then forwards its values of RAND
and AUTN to the device. Through these values the device
component veriﬁes the server’s knowledge of the secret key
2We encourage readers interested in more information about
UMTS authentication procedures to read either the stan-
dards document [1] or Traynor et al. [41].
and generates its response based on its key. This response
allows the Airmid server to verify that the device is aware of
the secret key, hence, completing mutual authentication. If
the server or device are unable to prove their knowledge of
the shared secret, then the authentication fails. The session
key K(a), which is never sent over the air, is then used for
encryption. Cryptographic algorithms used in UMTS are
similarly used for Airmid authentication and encryption.
5.
IMPLEMENTATION
Our prototype implementation is separated into two com-
ponents: passive network analysis and signaling within the
network, and remediation logic that responds to these sig-
nals on the device. To emulate sensors within the cellular
network, we built a packet sniﬀer that analyzes network traf-
ﬁc from an HTC Dream mobile phone running Android 1.6.
A secure communication channel is established between the
sensor and the kernel when a sensor needs to issue remedia-
tion commands to an infected device, whereupon the device
performs various actions to remediate the infection.
MSBSMSCHLR1. Sign onK presharedK preshared2. AV request 3. AV response {RAND,  XRES(MSC),  AUTN, K(c)}4. RAND(MSC), AUTN(MSC) 5. Verify AUTN(MSC)6. XRES (MS-MSC)7a. Veriﬁes: XRES(MSC) = XRES(MS-MSC) 7b. If correct: Set K(c) as network key 7c. Set K(c) as device key 8. Notiﬁes Airmid 9. AV request11. RAND(REC), AUTN(AM)12. Verify AUTN(AM)13. XRES (MS-AM)14a. Veriﬁes: XRES(AM)= XRES(MS-AM) 10. AV response {RAND, XRES(MSC),AUTN, K(a)} 15. Conﬁrms to MSC 14b. If correct: Set K(a) as server key 14c. Set K(a) as device component keyAirmid AdditionsAirmidServerMSBSMSCHLRAirmidServerFigure 3: Airmid’s on-device component resides within a hardened Android kernel. In particular, all kernel
extensions are statically linked into the kernel so that its loadable module support can be disabled.
5.1 Network component
Our prototype network component includes both an at-
tack detection system and the Airmid server communicating
with infected devices. For detection, we used Snort, an oﬀ-
the-shelf network intrusion detection system. We wrote our
Airmid server in Python using the packet creation library
Scapy [6]. As a mobile device communicates with foreign
network assets, Snort analyzes incoming and outgoing traf-
ﬁc. When it ﬂags traﬃc as malicious, it notiﬁes the Airmid
server which subsequently initiates authenticated two-way
communication with the suspect device. It sends to the de-
vice a remediation message that provides the device’s port
number from the attack alert. This information is used by
the Airmid on-device software to determine which processes
and applications are acting maliciously. The device’s soft-
ware decides which remediation strategies are appropriate
and relays how the infection was remediated to the sensor.
5.2 Device component
Our threat model considers a device’s kernel to be the
trusted computing base, so provenance and remediation ac-
tions run in kernel-mode. We modiﬁed the Linux kernel
version 2.6.29 to include our prototype implementation. We
hardened the kernel against direct compromise by disabling
its ability to dynamically load kernel modules. Our mod-
iﬁcations required approximately 1,200 lines of C. When
the device is booted, a separate kernel thread is launched
to perform infection provenance and remediation. When a
message is received from an authenticated Airmid server,
the device: determines provenance of the oﬀending traﬃc,
determines and enacts a remediation strategy, and relays
the device’s decision to the network sensor. We now discuss
the implementation of the provenance mechanism that lever-
ages Android’s existing application sandboxing techniques
as well as implementation details for the remediation strate-
gies. Figure 3 oﬀers a high-level overview of this component.
Infection provenance
5.2.1
When a user installs an application on a mobile device,
Android generates a unique Linux user ID that persists for
the application’s lifetime [4]. All ﬁles owned by the appli-
cation are also assigned this user ID. Given a user ID, we
can ﬁnd the Android package ﬁle (.apk) of the application
as well as conﬁguration ﬁles and native binaries dropped by
the application both at install-time and runtime.
When a device receives a remediation signal from a net-
work sensor, the device crawls two kernel data structures:
inet_hashinfo, which contains port usage information, and
task_struct, which contains process information. While
inet_hashinfo contains port information only for TCP con-
nections, the technique itself is general and could be ex-
tended to perform provenance on UDP-based traﬃc. The
port number sent to the device by the network sensor is
mapped to an open socket by iterating through inet_hashinfo.
We then look for this socket in the list of task_structs to
ﬁnd the process that holds said socket. A visualization of
this process is shown in Figure 4. From the task_struct,
we then extract the user ID, u, of the malicious process and
crawl the disk to ﬁnd all ﬁles owned by this application.
5.2.2 Remediation strategies