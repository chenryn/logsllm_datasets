利用者把关注点从用户态的漏洞攻击转移到内核上，以及用户态漏洞利用和内核态漏洞利用
的不同之处。然后会把关注点放在不同内核的区别上，例如Windows内核和UNIX内核的不
同，与此同时，我们也会探索计算机体系架构的变化对内核漏洞利用所产生的重要影响，例
或者在x86机器上是可行的，而在SPARC机器上却是不可行的。最后简单地讨论了在开源操
作系统和闭源操作系统上进行内核漏洞利用的差异。
内核和内核漏洞利用的世界
在踏上通向内核漏洞利用世界的征途之前，有一个需要首先明确的任务：什么是内核，
以及漏洞利用意味着什么。当您看到一台电脑的时候，可能会想到一系列互相连接的物理设
备（如CPU、主板、内存、硬盘、键盘等），可以使用这些物理设备方便快捷地写邮件、看
电影以及网上冲浪等。在硬件和应用软件之间存在着一层软件，它负责使硬件高效地工作，
并建立基础设施，使应用软件运行在基础设施之上。这层软件就是操作系统，它的核心就是
内核。
在现代的操作系统中，内核负责那些常规化的事情，如管理虚拟内存、硬件驱动访问、输
---
## Page 12
第1章从用户态利用到内核态利用3
言（低级机器语言）和C语言混合编写而成。此外，内核通过一些底层的体系架构机制把自
己和其他运行的程序隔离开。事实上，大部分的指令集体系架构（InstructionSetArchitecture，
ISA）至少提供两种执行模式：权限模式和非权限模式，在权限模式下，所有的机器级指令都
是可用的，而在非权限模式下，只有一部分指令是可用的。此外，内核通过在软件级别上实现
与用户程序的隔离来保护自己。当建立虚拟内存子系统时，内核会确保其能够访问任何进程的
地址空间（即虚拟内存的地址范围），而用户进程只能访问用户态内存但不能访问内核态的内
存。我们称只让内核可见的内存为内核态内存，而用户进程可见的内存为用户态内存。内核态
中的代码执行拥有所有权限，并可以访问系统中任何有效的内存地址，而用户态中的代码执行
对内存的访问则会受到如前所述的所有限制。这种基于硬件和软件的隔离是必须的，可以避免
内核受到来自用户态程序的意外破坏、不良行为的篡改或者恶意代码的破坏。
对于一个安全和稳定的系统来说，保护内核免受其他运行程序的干扰是第一步，但这还
远远不够：还应该在不同的用户态程序中设置不同程度的保护。考虑一个典型的多用户系统
环境。每一个用户都希望拥有一个私有的文件系统区域，这样它们就可以在私有的文件系统
里存储自己的数据、运行自己的程序（例如邮件读取软件），而不用担心这些数据和程序被
其他用户关闭、修改和窃取。同样，为了使一个系统可用，必须有某种方法来识别、添加和
有可用空间或者系统互联网连接的所有带宽。因此，内核在软件级别上提供了为不同用户分配
不同权限的功能。
用户由唯一的值来识别，通常是一个数字，称为用户标识（userid）。在所有用户标识
中，有一个用户标识是用来标识特殊用户的，这个特殊用户拥有比普通用户更高的权限，负
责管理其他用户、设置使用权限、配置系统之类的管理任务。在Windows世界中，这个特殊
用户叫做“Administrator”：而在UNIX世界中，这个特殊用户习惯上称为root，它的uid
个特殊用户。
超级用户被授予了修改内核的权力。原因很明显：和其他软件一样，内核也需要升级，例
如要修改潜在的漏洞、支持新设备等。如果得到了超级用户的控制权，就能完全控制这台计算
机。所以，获取超级用户的控制权成为系统攻击者的目标。
注意超级用户通过传统的权限隔离架构与其他没有权限的用户区别开来。所以权限
用户和非权限用户们是非此即彼的关系：如果一个用户需要运行某种权限操作X，它
就必须是权限用户，这样，它就拥有了执行X之外的权限操作的权力。您将会看到，
可以从安全的角度出发通过以下方法改进这个模型，可以把所有权限按类型拆分，然
后只赋予用户所需要的权限以便完成某项特殊任务。这样的话，成为超级用户并不意
味着获取控制整个系统的能力，因为真正控制一个特殊用户态程序可以做什么或不可
以做什么是赋予它的权限。
---
## Page 13
4第一部分内核态
漏洞利用的艺术
“我希望我能设法证明缓冲区溢出漏洞利用应该是一种艺术。”1
Solar设计者
在攻击者能够获取超级用户权限的各种方法中，漏洞利用的成功实施通常是一件最令人兴
奋的事。初学者经常把漏洞利用看成很神奇的过程，然而奇迹是不存在的，所谓的“奇迹”只
不过是创造力、智慧和许多刻苦努力的结果。换句话说，这是一门艺术。其实漏洞利用的原理
非常简单：软件肯定有bug，而这些bug会让软件运行不正常，或者错误地执行它本应正常处
理的任务。利用bug意味着把这种不正常的行为作为攻击者实施攻击的有利手段。并不是所有
的bug都是可利用的，只有那些称为漏洞（vulnerability）的bug才能利用。分析一个应用程序
来确定漏洞的过程称为审计（auditing）。这个过程包含以下儿步：
·读入应用程序源代码（如果有源代码的话）。
·对应用程序的二进制代码实施逆向工程，即读入编译过代码的反汇编码。
·模糊测试应用程序接口，就是将随机或者基于模式自动生成的数据作为输人来测试程序。
审计过程既可以人工执行，也可以用静态或动态的分析工具来辅助进行。介绍审计的过程
已经超出了本书的范围，如果您感兴趣，请参考本章最后“相关阅读”一节，那里介绍了关于
审计方面的书。
漏洞通常分为若干不同类别。如果您曾接触过关于安全方面的邮件、博客或者电子杂志，
应该听说过缓冲区（栈或堆）溢出、整数溢出、格式字符串和竞态条件。
注意针对上述的漏洞类别，我们将在第2章更详细地描述。
本书对大多数术语并没有单独去解释，我们认为您应该已经明确它们的含义，而且在本书
中准确理解它们的含义也不是很重要的。重要的是，所有属于某种类别的漏洞拥有一些相似的
模式和漏洞利用方法。学习这些漏洞模式和漏洞利用方法（通常称为漏洞利用技术）对于漏洞
攻击是非常有帮助的。发现漏洞模式和漏洞利用方法可能会极为简单，也可能会非常具有挑战
性，这实质上就是漏洞利用者的创造力将漏洞利用流程转换为一种艺术形式。首先，一个漏洞
利用方法必须足够可靠，可以应用到足够广泛的目标上。如果一个漏洞利用方法只对一种特定
的场景有效或者仅仅是让程序崩溃，那么这个漏洞利用方法的价值并不大。除了要可靠外，一
个漏洞利用方法必须高效。换句话说，漏洞利用者应该尽量减少使用蛮力，尤其是当这样做可
能引起被攻击机器的警报时。
漏洞利用可以锁定本地或远程的服务：
·本地漏洞利用（localexploit）要求攻击者已经获得访问目标机器的权限，其目的是提升
攻击者的用户权限，直至获得对整个系统的控制权。
·远程漏洞利用（remoteexploit）首先要锁定攻击者没有访问权限的机器，这样他可以通
过网络连接到将要攻击的机器。相比本地攻击，远程攻击是更有挑战性（并且，从某种
程度来说权力更强大）的漏洞利用类型。通过本书您将发现，要想成功地进行漏洞利用，
---
## Page 14
第1章从用户态利用到内核态利用
5
搜集目标机器的信息。所以，远程漏洞利用的目标就是使攻击者有权限访问远程机器。
如果被攻击的应用程序运行在高权限级别状态下，那么攻击者还会获得提升用户权限的
额外收获。
如果仔细分析一个常规的漏洞利用，会发现漏洞利用主要分三个部分：
·准备阶段（preparatoryphase）：搜集目标机器的信息，创建有利的攻击环境。
·编写shellcode：这是一段机器语言指令，当执行时，通常会提升攻击者的权限级别或是
执行命令（如shell的一个新实例）。在接下来的代码段里可以看到，机器指令序列可以
编码成很容易被攻击代码操纵的十六进制代码，并且放置在被攻击机器的内存中。
·触发阶段（triggeringphase）：将shellcode编写好放入目标进程（例如通过输入注入）后，
会触发漏洞并使目标程序执行控制重定向到shellcode。
charkernel_stub[]=
"\xbe\xe8\x031x00\x00"
//mov
$0x3e8，%esi
"x65\x48\x8b\x04\x251x00\x00\x00\x00"//mov
%gs:0x0,%rax
"\x31\xc9"
1/xor
%ecx，%ecx（15
"\x81\xf9\x2c1x011x00\x00"
1/cmp
$0x12c.%ecx
"\x74\x1c
llje
400af0
"\x8b1x10"
1/mov
（%rax）.%edx
"\x39\xf2"
1/cmp
%esi.%edx
"\x751x0e"
//jne
400ae8
"\x8b\x50\x04"
1/mov
0x4（%rax),%edx
"\x39\xf2"
1/cmp
%esi,%edx
"\x751x07"
1/jne
400ae8
"\x31\xd2"
1/xor
%edx.%edx
"\x89\x501x04"
//mov
%edx,0x4（%rax）
"\xeb\x08"
//jmp
400af0
"\x48\x831xc01x04"
//add
$0x4.%rax
"\xff\xc1"
1/inc
%ecx
"\xeb\xdc"
//jmp
400acc
"\x0f\x01\xf8"
//swapgs（54
"\x481xc7\x44\x24\x201x2b1x00\x00\x00//m0vq
$0x2b，0x20（%rsp）
"\x48\xc7\x44\x24\x18\x11\x11\x11\x11"//m0vq
$0x11111111.0x18（%rsp）
"\x48\xc7\x44\x24\x10\x46\x021x00\x00"//m0vq
$0x246,0x10（%rsp）
"\x48\xc7\x44\x24\x08\x23\x00\x00\x00"//movq
$0x23,0x8（%rsp）/*23
32-bit,3364-bitcs*/
"\x48\xc7\x04\×241x22\×221×221×22"
//m0vq$0x22222222.（%rsp）
"\x48\xcf":
//iretq
攻击者的一个目标就是尽可能成功地把代码执行控制重定向到shellcode开始的内存地
址。一种简单却低效的方法是尝试所有可能的内存地址：攻击者一个接一个地尝试，如果所尝
试的地址错误，用户程序将崩溃，然后攻击者再尝试下一个地址；在某一点上攻击者最终触发
shellcode。这种方法称为蛮力法（bruteforcing），蛮力法通常对时间和资源的要求较高，尤其
---
## Page 15
6第一部分内核态
是远程攻击的时候，是一种笨拙的方法。聪明的漏洞利用者只会在需要保证达到最大攻击可靠
性的时候才使用蛮力法，并最大限度地减少尝试触发shellcode的次数。在这种情况下，一个通
用方法是增加攻击者能跳转到的“恰当地址”的数目，攻击者可以在shellcode后面增加空操作
指令（NOP），或是在shellcode之前插入类似的指令。如果攻击者把执行控制重定向到其中的
一个NOP指令，CPU会一个接一个地运行这些NOP，最后执行到shellcode。
提示现代的体系架构都提供了空操作指令（NOP），空操作指令是指不做任何
事。在x86架构中，空操作的十六进制操作码（operationcode）是0X90。一个
类空操作指令是一个即使在shellcode前执行也不会影响到shellcode运行的指令。
例如，如果shellcode在使用前清空了一个通用寄存器，那么可以执行任何改变这
个寄存器内容的指令任意次，而不会影响shellcode的正常执行。如果所有的指令
都是等长的，如精简指令集机器（ReducedInstructionSetComputer，RISC）架构，
那么任何不影响RISC执行的指令都可以用作类空指令。在另一种情况下，如果指
令是不等长的，如复杂指令集机器（ComplexInstructionSetComputer，CISC）
架构，那么只有和NOP指令等长的指令才能用作类空指令（这种指令的长度通常
在CISC指令中是最短的）。类空操作指令在绕过一些安全检查（如一些入侵检查
系统或IDSs）时是很有用的，这些安全检查试图通过对能够到达受保护的应用程
序的数据进行模式匹配来检测漏洞利用。很容易想到，标准的NOP序列是不会通
过这样的检查的。
到目前为止您可能已经注意到，我们在论述时做了一个很大的假设：受攻击程序重新执
行时，它的状态将和攻击前的状态一模一样。如果一个攻击者足够透彻地了解所要攻击的子系
统，那么他确实能够成功地判断用户程序的状态，但是这种情形很少见。攻击高手会想办法在
攻击准备阶段把用户程序引l向一个已知的状态。内存分配表的利用（memoryallocator）就是
一个很好的例子。应用程序中决定内存分配顺序和结果的变量一般来说不受攻击者的控制，然
组特定的请求。通过多次执行这条特定请求序列，攻击者就会搜集足够的信息，一旦攻击者进
人了激活这些指令的阶段，就可以预测内存分配表的准确层次结构。
击，那么可以通过以下的对策实现：
·让攻击者存储shellcode的区域变得不可执行。如果这些区域是用来存储数据的，那么就
没有理由让应用程序执行这里的代码。
·让攻击者难以找到加载的可执行区，因为攻击者总是能让应用程序跳转到程序中的一些
有趣的指令序列中。换句话说，增加攻击者关心的随机变量的数量，会使得蛮力攻击就
变得像抛硬币一样低效了。
程序复位。
·用一些随机值确定敏感结构的边界（如内存分配表所在的内存块、栈结构等），并在使用
---
## Page 16
第1章从用户态利用到内核态利用7
这些随机值之前测试它们的完整性（例如，在栈结构中回退到前一个状态之前）。这样一
来，如果攻击者想获得后面存储的敏感数据，就必须覆盖掉这些随机值。
这只是软件应该做的最起码的事情，但您应该把这个策略部署到哪儿呢？哪个实体才有一
定程度的控制力和影响所有应用程序的能力呢？答案就是：内核。
为什么用户态漏洞利用不再有效
要多）一系列对策，他们发现内核是实施这些对策最有效、最理想的地方之一。为了理
解现在的用户态漏洞利用的门槛多高，我们先简单了解以下这些项目的特性列表：PaX/
grsecurity（www.grsecurity.net）、ExecShield（http://people.redhat.com/mingo/exec-shield/)、针
对Linux内核的Openwall（www.openwall.com）安全增强的内核，如OpenSD（W^X，地址空