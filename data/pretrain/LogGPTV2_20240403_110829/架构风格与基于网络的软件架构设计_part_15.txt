第5章 表述性状态转移（REST） 52
OriginServer
Proxy Gateway
http
http $ $ orb
http
a
UserAgent DNS
b http
$ $
c
Proxy
wais
DNS http $
ClientConnector: Client+Cache: $ ServerConnector: Server+Cache: $
图5-10：一个基于REST的架构的过程视图
一个用户代理正处在三个并行交互（a、b和c）的中途。用户代理的客户端连接器缓存无法满足请求，
因此它根据每个资源标识符的属性和客户端连接器的配置，将每个请求路由到资源的来源。请求(a)被发送到一
个本地代理，代理随后访问一个通过DNS查找发现的缓存网关，该网关将这个请求转发到一个能够满足该请
求的来源服务器，服务器的内部资源由一个封装过的对象请求代理（object request broker）架构来定义。请求
(b)直接发送到一个来源服务器，它能够通过自己的缓存来满足这个请求。请求(c)被发送到一个代理，它能够
直接访问WAIS（一种与Web架构分离的信息服务），并将WAIS的响应翻译为一种通用的连接器接口能够识
别的格式。每一个组件只知道与它们自己的客户端或服务器连接器的交互；整个过程拓扑是我们的视图的产物。
REST的客户-服务器关注点分离简化了组件的实现、降低了连接器语义的复杂性、改善
了性能调优的效率、并且提高了纯服务器组件（pure server components）的可伸缩性。分层
系统的约束允许在通信的不同地点引入中间组件——代理、网关、防火墙——而无须改变组
件之间的接口，从而允许它们来辅助通信的转译（communication translation），或通过大规
模的、共享的缓存来改善性能。REST通过强制消息具有自描述性（请求之间的交互是无状
态的、使用标准的方法和媒体类型来表达语义和交换信息、响应可以明确地表明其可缓存性）
来支持中间组件的处理。
由于组件之间是动态连接的，因此它们对于一个特定的应用动作的排列和功能的性质与
管道和过滤器风格类似。尽管REST组件通过双向的数据流来通信，但是每个方向的处理是
独立的，因此容易受到数据流转换器（过滤器）的影响。通用的连接器接口允许基于每个请
求或响应的属性将组件放置到数据流上。
服务也可以通过使用复杂的中间组件的层次结构和多个分布式来源服务器来实现。
REST的无状态本质允许每个交互独立于其他的交互，使其无须了解整体的组件拓扑结构
（因为这对于一个Internet规模的架构来说是不可能的任务），并且允许组件要么作为目的
地要么作为中间组件，由每个请求的目标来动态决定。连接器只需要在它们的通信范围期间
知道彼此的存在即可，尽管它们可能会出于性能原因而对其他组件的存在和能力进行缓存。
5.3.2 连接器视图（Connector View）
架构的连接器视图集中于组件之间的通信机制。对一个基于REST的架构而言，我们对
定义通用资源接口的约束尤其感兴趣。
客户端连接器检查资源标识符，以便为每个请求选择一个合适的通信机制。例如，一个
客户端可以被配置为当资源的标识符表明其为一个本地资源时，连接到一个特定的代理组件
（或许是作为一个注释过滤器）。同样地，客户端也可以被配置为拒绝对于标识符的某些子
集的请求。
REST并不限制通信只能使用一种特殊的协议，但是它会限制组件之间的接口，因此也
第5章 表述性状态转移（REST） 53
限制了交互的范围和在组件之间可能作出的有关实现的假设（implementation assumption）。
例如，Web的主要转移协议是HTTP，但是REST架构也包括了对来自Web出现之前就已存
在的网络服务器的资源，包括FTP[107]、Gopher[7]和WAIS[36]的无缝地访问。与那些服务
的交互被限制为只能使用REST连接器的语义。为了获得连接器语义的单一的、通用的接口
的好处，这一约束牺牲了其他架构的一些好处，例如像WAIS这样的相关性反馈协议
（relevance feedback protocol）的有状态交互的好处。作为回报，通用的接口使得通过单个
代理访问多个服务成为了可能。如果一个应用需要另一个架构的额外能力，它能够将其作为
一个单独并行运行的系统来实现并调用那些能力，这与Web架构如何使用“telnet”和
“mailto”资源是类似的。
5.3.3 数据视图（Data View）
一个架构的数据视图展示了信息在组件之间流动时的应用状态。因为REST被明确定位
于分布式信息系统，它将一个应用看作是一种信息（information）和控制（control）的聚合
体，用户可以通过这个聚合体执行他们想要完成的任务。例如，在一个在线字典上查找单词
是一个应用、在一个虚拟博物馆里面观光是一个应用、为准备一门考试而复习课堂笔记也是
一个应用。每个应用都定义了其底层系统的目标，可以针对这些目标来测量系统的性能。
组件之间的交互以动态改变尺寸的消息的形式来进行。小粒度的或中等粒度的消息用来
控制交互的语义，但是应用的大部分工作需要通过包含一个完整的资源表述的大粒度消息来
完成。请求的语义的最常见形式是获取资源的一个表述（例如HTTP中的“GET”方法），
通常我们可以对其进行缓存以便以后重用。
REST将所有的控制状态（control state）都浓缩在从交互的响应中接收到的表述之中。
其目的是通过使服务器无须维护当前请求之外的客户端状态，从而改善服务器的可伸缩性。
一个应用状态因此由以下几方面来定义：悬而未决的请求（pending requests）、相连接的组
件（有些可能是过滤被缓冲的数据）的拓扑结构、连接器上活跃的请求、请求响应中表述的
数据流、以及当用户代理接收到这些表述时对表述的处理。
无论何时当没有未完成的请求时（即，没有悬而未决的请求，并且所有当前请求集合的
响应都已经被完全接收到，或者已经接收到了足够的数据，可以将其看作一个表述的数据
流），一个应用就达到了一种稳定的状态。对于一个浏览器应用而言，这种状态对应于一个
“网页”，包括了主要的表述和辅助的表述，例如内嵌的图片、内嵌的applet、以及样式表。
应用的稳定状态的重要性在于，它会同时影响用户可觉察的性能和网络请求流量的峰值。
一个浏览器应用的用户可觉察性能由稳定状态之间的延迟（从选择一个网页上的超媒体
链接到下一个网页的可用信息呈现出来所需的时间）来决定。因此，浏览器性能的优化主要
集中在降低这种通信的延迟上面。
因为基于REST的架构主要通过转移资源的表述来进行通信，所以延迟会同时受到通信
协议的设计和表述数据格式的设计两方面的影响。当响应数据正在被接收时增量地呈现这些
数据的能力，是由媒体类型的设计和每个表述中的布局信息（内嵌对象的视觉尺寸）的有效
性来决定的。
我们观察到的一个有趣的事实是：最高效的网络请求是那些不使用网络的请求。换句话
说，重用已缓存的响应结果的能力能够显著地改善应用的性能。尽管由于查找所带来的开销，
使用一个缓存会为每个单独的请求增加一点延迟，但是请求的平均延迟会大幅降低，即使是
在只有较小百分比的请求命中了缓存的情况下。
应用的下一个控制状态位于第一个被请求的资源的表述之中，因此获得第一个请求是一
件需要优先完成的事情。REST交互能够通过“先响应后思考”的协议来加以改进。换句话
说，假设有两个协议，在第一个协议中，为了在发送一个内容响应之前做一些功能协商之类
第5章 表述性状态转移（REST） 54
的事情 ，每个用户动作都需要多次交互；在第二个协议中，先发送最有可能是最佳响应的
内容，然后如果第一个响应无法满足客户端的需要，再提供一列替代选项给客户端来获取。
第一个协议在感觉上会更慢一些。
用户代理负责控制和保存应用状态，并且这些状态可以由来自多个服务器的表述组成。
除了使服务器免除了存储状态所带来的可伸缩性问题以外，这还允许用户直接操作状态（例
如，Web浏览器的历史信息）、预测状态的变化（例如，链接地图和表述的预先获取）、以
及从一个应用跳转到另一个应用（例如，书签和URI栏目的对话框）。
因此，REST的模型应用是一个引擎，它通过检查和选择当前的表述集合中的状态跃迁
选项，从一个状态移动到下一个状态。毫不奇怪，这与一个超媒体浏览器的用户接口完全匹
配。然而，REST风格并不假设所有应用都是浏览器。事实上，通用的连接器接口对服务器
隐藏了应用的细节，因此各种形式的用户代理都是等价的，无论是为一个索引服务执行信息
获取任务的自动化机器人，还是查找匹配特定查询标准的数据的私人代理，或者是忙于巡视
破损的引用或被修改的内容的维护爬虫（译者注：即执行维护任务的网络爬虫）。
5.4 相关工作
Bass等人[9]在其文献中用了一章篇幅来介绍万维网的架构，但是他们的描述仅包括了
CERN/W3C开发的libwww（客户端和服务器库）和Jigsaw软件中的实现架构。这些实现是
由熟悉Web 架构的设计和基本原理的人们开发出来的，尽管它们反映出了很多REST的设计
约束，但是真正的WWW架构是独立于任何单一实现的。现代Web是由它的标准的接口和
协议来定义的，而不是由在软件的一个特定部分中如何实现这些接口和协议来定义的。
REST风格来源于很多先前存在的分布式处理范例[6, 50]、通信协议、以及软件领域。
虽然REST的组件交互被结构化为一个分层的客户-服务器风格，但是额外添加的通用的资
源接口的约束使得替换中间组件和通过中间组件执行检查成为了可能。虽然请求和响应看上
去像是远程调用风格，但是REST消息的目标是一个概念上的资源，而不是一个实现的标识
符。
有一些研究尝试将Web架构建模为一种分布式文件系统的形式（例如，WebNFS）或者
建模为一种分布式对象系统[83]。然而，他们排除了多种不同的Web资源类型或者实现策略，
仅仅是因为“不感兴趣”，而实际上这些被排除的内容会使得这些模型之下的假设变得无效。
REST运作得很好，因为它并不将资源的实现局限于某些特定的预定义模型中，从而允许每
个应用选择一种与它们自己的需求最匹配的实现，并支持在不影响用户的情况下对实现进行
替换。
将资源的表述发送给消费组件（consuming components），这种交互方法与基于事件的
集成（EBI）风格有些相似。其关键的区别是：EBI风格是基于推模型的。包含状态的组件
（等价于REST中的来源服务器）在状态改变时产生一个事件，无论事实上有没有组件对该
事件感兴趣或在监听该事件。在REST风格中，消费组件通常需要自己去拉表述。尽管当单
个客户端希望监视单个资源时，这种方式的效率要低一些（译者注：因为客户端需要对服务
器做轮询），但是Web的规模使得我们不可能实现一种无节制的推模型。
在Web中有原则地使用包含了清晰的组件、连接器和表述概念的REST风格，这种方
法与C2架构风格[128]有着密切的联系。C2风格通过聚焦于结构化地使用连接器以获得底层
独立性，支持开发分布式的、动态的应用。C2应用依赖于状态改变的异步通知和请求消息。
与其他基于事件的方案一样，C2在名义上是基于推模型的，尽管C2架构也可以通过只在接
收到请求时才发出通知，以REST的拉风格来运作。然而，C2风格缺乏REST的中间组件友
好的约束，例如通用的资源接口、保证无状态的交互，以及对于缓存的内在支持。