split payload approach common for proof-of-concept exploits [11,
8], our techniques equally apply to packing the entire exploit in
a single string buffer. For efﬁciency, we pack each exploit stack
frame into 64 bytes, just providing enough room for the save area
for the 16 local and input registers.
The C exploit wrapper program passes the exploit argv and
envp string arrays to the vulnerable application via an exec().
Our example uses 33 gadgets (note that hidden additional gadgets
and variables are generated by the compiler) for 88 exploit stack
frames total, and the entire exploit payload is 5,572 bytes (with an
extra 336 bytes for the initial overﬂow).
6.3 Results
Our exploit wrapper program (“exploit”) spawns the vulner-
able application with our packed exploit payload, overﬂows the
vulnerable buffer in foo() and takes control. The command line
output from injecting our return-oriented program into the vuln
application is shown in Fig. 18.
sparc@sparc # ./exploit
Shell countdown:
9 8 7 6 5 4 3 2 1 0
$
Figure 18: Exec’ing vuln With Exploit Payload
Our ﬁrst version of the payload took over 12 hours to craft by
hand (manually researching addresses and packing frames). After
ﬁnishing our exploit development framework, we were able to cre-
ate the same exploit (testing and all) in about 15 minutes using the
compiler and API.
7. OTHER DEFENSES ON SPARC
Although there are certain defenses to our approach (like any
buffer overﬂow exploit), none appear to pose an insurmountable
obstacle to return-oriented exploits on W⊕X-protected SPARC sys-
tems.
7.1 Stack-Smashing Protection
Traditional stack-smashing protection, in a line of work starting
with StackGuard [3] and including ProPolice [5], StackShield [29],
and the Microsoft C compiler’s “/GS” ﬂag [12], provides a defense
orthogonal to W⊕X: preventing subversion of a program’s control
ﬂow with typical buffer overﬂows on the stack. Although these
defenses do limit many buffer overﬂow exploits, there are known
circumvention methods [1].
ProPolice is implemented for SPARC by both Solaris [2] and
OpenBSD [19]. Moreover, on SPARC, restoring a register win-
dow from the stack requires a kernel trap, giving an opportunity for
SPARC-speciﬁc defensive measures. A notable example is Stack-
Ghost [6], which implements extra kernel-level stack return address
checks on OpenBSD 2.8 for SPARC (although there is no Solaris
analogue). With these defenses in place, we would have to intro-
duce our return-oriented payload by some other means than stack
overﬂow: heap corruption, format string vulnerability, etc.
7.2 Address-Space Randomization
Address-space layout randomization (ASLR) is another orthog-
onal defense. Typical implementations, such as PaX ASLR for
Linux [22], randomize the base address of each segment in a pro-
gram’s address space, making it difﬁcult to determine the addresses
in libc and elsewhere on which return-into-libc attacks rely. Linux
implements ASLR on SPARC, but Solaris does not. Derandom-
ization and other techniques for bypassing ASLR [24, 4, 14] may
be applicable on the SPARC generally and to return-oriented pro-
gramming on SPARC speciﬁcally.
8. CONCLUSION AND FUTURE WORK
The history of software security is littered with vulnerabilities
deemed too hard to exploit and defenses too difﬁcult to bypass —
only to become staple crops as they were internalized. “What can
you do with a one byte overﬂow after all?” and “Safe unlink-
ing makes it almost impossible to exploit heap corruptions” exem-
plify such refrains. We submit that return-oriented programming is
poised to turn this corner.
Building on Shacham’s original demonstration on Linux / x86,
we have shown that the return-oriented programming problem ex-
tends to Solaris / SPARC and we argue that it portends a universal
issue. Moreover, we have demonstrated that return-oriented ex-
ploits are practical to write, as the complexity of gadget combina-
tion is abstracted behind a programming language and compiler.
Finally, we argue that this approach provides a simple bypass for
the vast majority of exploitation mitigations in use today.
To wit, since a return-oriented exploit relies on existing code and
not injected instructions, it is resilient against code integrity de-
fenses. It is thus undetectable to code signing techniques such as
Tripwire, Authenticode, Intel’s Trusted Execution Technology, or
any “Trusted Computing” technology using cryptographic attesta-
tion. It will similarly circumvent approaches that prevent control
ﬂow diversion outside legitimate regions (such as W⊕X) and most
malicious code scanning techniques (such as anti-virus scanners).
Where then does this leave the defender? Clearly, eliminating
vulnerabilities permitting control ﬂow manipulation remains a high
priority — as it has for twenty years. Beyond this, there are three
obvious design strategies for addressing the problem. First, we
can explore hardware and software support for further constrain-
ing control ﬂow. For example, dynamic taint checking systems can
prevent the transfer of control through stack cells computed from an
input [15]. Similarly, we can investigate hardware support for con-
straining control transfers between functions. A second approach
is to address the power of the return-oriented approach itself. We
speculate that perhaps function epilogues can be sufﬁciently con-
strained to foreclose a Turing-complete set of gadgets. Finally, if
these approaches fail, we may be forced to abandon the convenient
model that code is statically either good or bad, and instead fo-
cus on dynamically distinguishing whether a particular execution
stream exhibits good or bad behavior.
9. ACKNOWLEDGMENTS
We would like to thank Rick Ord for his helpful discussions re-
garding SPARC internals and detailed comments on our manuscript,
Bill Young for providing us with a dedicated SPARC workstation
on short notice and for a long period of time and the anonymous
reviewers for their insightful feedback.
This work was made possible by the National Science Founda-
tion grant NSF-0433668. Any opinions, ﬁndings, and conclusions
or recommendations expressed in this material are those of the au-
thors or originators and do not necessarily reﬂect the views of the
National Science Foundation.
10. REFERENCES
[1] Bulba and Kil3r. Bypassing StackGuard and StackShield.
Phrack Magazine, 56(5), May. 2000.
http://www.phrack.org/archives/56/p56-0x05.
[2] J. Cartwright. Protecting Solaris with ProPolice/SSP. May.
2003. http://www.grok.org.uk/docs/ssp.html.
[3] C. Cowan, C. Pu, D. Maier, J. Walpole, P. Bakke, S. Beattie,
A. Grier, P. Wagle, Q. Zhang, and H. Hinton. StackGuard:
Automatic adaptive detection and prevention of
buffer-overﬂow attacks. In Proc. 7th USENIX Security
Conference, pages 63–78, San Antonio, Texas, Jan. 1998.
[4] T. Durden. Bypassing PaX ASLR protection. Phrack
Magazine, 59(9), June 2002.
http://www.phrack.org/archives/59/p59-0x09.txt.
[5] H. Etoh. GCC extension for protecting applications from
stack-smashing attacks.
http://www.trl.ibm.com/projects/security/ssp/.
[6] M. Frantzen and M. Shuey. StackGhost: Hardware facilitated
stack protection. In SSYM’01: Proceedings of the 10th
conference on USENIX Security Symposium, pages 5–5,
Berkeley, CA, USA, 2001. USENIX Association.
[7] S. Hudson. JFlex - the fast scanner generator for Java.
http://www2.cs.tum.edu/projects/cup/.
[8] M. Ivaldi. Re: Older SPARC return-into-libc exploits.
Penetration Testing, Aug. 2007.
[9] G. Klein. CUP LALR parser generator for Java.
http://jflex.de/.
[10] S. Krahmer. x86-64 buffer overﬂow exploits and the
borrowed code chunks exploitation technique. Sept. 2005.
http://www.suse.de/~krahmer/no-nx.pdf.
[11] J. McDonald. Defeating Solaris/SPARC non-executable
stack protection. Bugtraq, Mar. 1999.
[12] Microsoft. /GS (buffer security check).
[13] Microsoft. KB 875352: A detailed description of the Data
Execution Prevention (DEP) feature in Windows XP Service
Pack 2, Windows XP Tablet PC Edition 2005, and Windows
Server 2003, Sept. 2006. Online:
http://support.microsoft.com/KB/875352.
[14] Nergal. The advanced return-into-lib(c) exploits: PaX case
study. Phrack Magazine, 58(4), Dec. 2001.
http://www.phrack.org/archives/58/p58-0x04.
[15] J. Newsome and D. X. Song. Dynamic taint analysis for
automatic detection, analysis, and signature generation of
exploits on commodity software. In NDSS. The Internet
Society, 2005.
[16] A. Noordergraaf and KeithWatson. SolarisTM operating
environment security. Jan. 2000.
[17] OpenBSD Foundation. OpenBSD 3.3 release. May 2003.
http://www.openbsd.org/33.html.
[18] OpenBSD Foundation. OpenBSD 3.4 release. Nov. 2003.
http://www.openbsd.org/34.html.
[19] OpenBSD Foundation. OpenBSD 3.5 release. May. 2004.
http://www.openbsd.org/35.html.
[20] R. P. Paul. SPARC Architecture, Assembly Language
Programming, and C. Prentice Hall PTR, Upper Saddle
River, NJ, USA, 1999.
[21] PaX Team. Homepage of the PaX Team.
http://pax.grsecurity.net/.
[22] PaX Team. PaX address space layout randomization.
http://pax.grsecurity.net/docs/aslr.txt.
[23] H. Shacham. The geometry of innocent ﬂesh on the bone:
Return-into-libc without function calls (on the x86). In
Proceedings of CCS 2007, pages 552–61. ACM Press, Oct.
2007.
[24] H. Shacham, M. Page, B. Pfaff, E.-J. Goh, N. Modadugu,
and D. Boneh. On the effectiveness of address-space
randomization. In CCS ’04: Proceedings of the 11th ACM
conference on Computer and communications security,
pages 298–307, New York, NY, USA, 2004. ACM.
[25] Solar Designer. Linux kernel patch from the Openwall
project. http://www.openwall.com/linux.
[26] Solar Designer. Getting around non-executable stack (and
ﬁx). Bugtraq, Aug. 1997.
[27] SPARC Int’l, Inc. The SPARC Architecture Manual (Version
9). Prentice-Hall, Inc., Englewood Cliffs, NJ, USA, 1994.
[28] SPARC Int’l, Inc. System V Application Binary Interface,
SPARC Processor Supplement. 1996.
[29] Vendicator. Stack Shield: A "stack smashing" technique
protection tool for linux.
http://www.angelfire.com/sk/stackshield/.
APPENDIX
Our compiler and exploit framework provide an abstraction that is
just a little bit shy of the C language in terms of expressiveness. To
better illustrate the capabilities of our exploit language, we provide
two reasonably complex return-oriented programs, which use dy-
namic memory allocation, multiply-nested loops, and pointer arith-
metic. While both exploit payloads are arguably too large for use in
the wild, these programs demonstrate our ability to quickly create
ﬂexible, powerful, and complex exploit program payloads with the
exploit framework.
A. MATRIX ADDITION
Fig. 19 shows an exploit language program (“MatrixAddition.rc”)
that allocates two 4x4 matrices, ﬁlls them with random values 0-
511, and performs matrix addition. Our compiler produces a C
language ﬁle (“MatrixAddition.c”), that when compiled to (“Ma-
trixAddition”), exec()’s the vulnerable application from Fig. 16
with the program exploit payload. The exploit program prints out
the two matrices and their sum, as shown in Fig. 20. The exploit
payload for the matrix program is 24 kilobytes, using 31 gadget
variables, 145 gadgets, and 376 instruction sequences (including
compiler-added variables and gadgets).
var n = 4;
var* mem, p1, p2;
var matrix, row, col;
// 4x4 matrices
// Pointers
srandom(time(0));
mem = malloc(128);
p1 = mem;
for (matrix = 1; matrix  min
// p1++
p1 = a;
printf(&("\n\nSorted Array:\n"));
for (i = 0; i < len; ++i) {
printf(&("%d, "), *p1);
p1 = p1 + 4;
// p1++
}
printf(&("\n"));
free(a);
// Free Memory
Figure 22: Selection Sort Exploit Code