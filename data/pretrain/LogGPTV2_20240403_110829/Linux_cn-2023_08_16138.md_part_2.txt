这里有些工具可以查看进程的相关信息：
* `pstree` 会展示你的系统中所有进程的树状图
* `cat /proc/PID/stat` 会显示一些关于该进程的信息。你可以在 `man proc` 中找到这个文件的内容说明。例如，第四个字段是父进程的PID。
#### 新进程的继承
新的进程（即将变为 `python3` 的）从 Shell 中继承了很多内容。例如，它继承了：
1. **环境变量**：你可以通过 `cat /proc/PID/environ | tr '\0' '\n'` 查看
2. **标准输出和标准错误的文件描述符**：通过 `ls -l /proc/PID/fd` 查看
3. **工作目录**（也就是当前目录）
4. **命名空间和控制组**（如果它在一个容器内）
5. 运行它的**用户**以及**群组**
6. 还有可能是我此刻未能列举出来的更多东西
### 5、Shell 调用 execve
现在我们准备好启动 Python 解释器了！
**自行验证**：运行 `strace -f -e execve bash`，接着运行 `python3`。其中的 `-f` 参数非常重要，因为我们想要跟踪任何可能产生的子进程。你应该可以看到如下的输出：
```
[pid 3708381] execve("/usr/bin/python3", ["python3"], 0x560397748300 /* 21 vars */) = 0
```
第一个参数是这个二进制文件，而第二个参数是命令行参数列表。这些命令行参数被放置在程序内存的特定位置，以便在运行时可以访问。
那么，`execve` 内部到底发生了什么呢？
### 6、获取该二进制文件的内容
我们首先需要打开 `python3` 的二进制文件并读取其内容。直到目前为止，我们只使用了 `stat` 系统调用来获取其元数据，但现在我们需要获取它的内容。
让我们再次查看 `stat` 的输出：
```
$ stat /usr/bin/python3
  File: /usr/bin/python3 -> python3.9
  Size: 9           Blocks: 0          IO Block: 4096   symbolic link
Device: fe01h/65025d    Inode: 6206        Links: 1
...
```
该文件在磁盘上占用 0 个块的空间。这是因为符号链接（`python3.9`）的内容实际上是存储在 inode 自身中：在下面显示你可以看到（来自上述 inode 的二进制内容，以 `hexdump` 格式分为两行输出）。
```
00000020  00 00 00 00 01 00 00 00  70 79 74 68 6f 6e 33 2e  |........python3.|
00000030  39 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |9...............|
```
因此，我们将需要打开 `/usr/bin/python3.9` 。所有这些操作都在内核内部进行，所以你并不会看到其他的系统调用。
每个文件都由硬盘上的一系列的 **块** 构成。我知道我系统中的每个块是 4096 字节，所以一个文件的最小大小是 4096 字节 —— 甚至如果文件只有 5 字节，它在磁盘上仍然占用 4KB。
**自行验证**：我们可以通过 `debugfs` 找到块号，如下所示：（再次说明，我从 Dmitry Mazin 的《[磁盘就是一堆比特](https://www.cyberdemon.org/2023/07/19/bunch-of-bits.html)》文章中得知这些步骤）。
```
$ debugfs /dev/vda1
debugfs:  blocks /usr/bin/python3.9
145408 145409 145410 145411 145412 145413 145414 145415 145416 145417 145418 145419 145420 145421 145422 145423 145424 145425 145426 145427 145428 145429 145430 145431 145432 145433 145434 145435 145436 145437
```
接下来，我们可以使用 `dd` 来读取文件的第一个块。我们将块大小设定为 4096 字节，跳过 `145408` 个块，然后读取 1 个块。
```
$ dd if=/dev/vda1 bs=4096 skip=145408 count=1 2>/dev/null | hexdump -C | head
00000000  7f 45 4c 46 02 01 01 00  00 00 00 00 00 00 00 00  |.ELF............|
00000010  02 00 3e 00 01 00 00 00  c0 a5 5e 00 00 00 00 00  |..>.......^.....|
00000020  40 00 00 00 00 00 00 00  b8 95 53 00 00 00 00 00  |@.........S.....|
00000030  00 00 00 00 40 00 38 00  0b 00 40 00 1e 00 1d 00  |....@.8...@.....|
00000040  06 00 00 00 04 00 00 00  40 00 00 00 00 00 00 00  |........@.......|
00000050  40 00 40 00 00 00 00 00  40 00 40 00 00 00 00 00  |@.@.....@.@.....|
00000060  68 02 00 00 00 00 00 00  68 02 00 00 00 00 00 00  |h.......h.......|
00000070  08 00 00 00 00 00 00 00  03 00 00 00 04 00 00 00  |................|
00000080  a8 02 00 00 00 00 00 00  a8 02 40 00 00 00 00 00  |..........@.....|
00000090  a8 02 40 00 00 00 00 00  1c 00 00 00 00 00 00 00  |..@.............|
```
你会发现，这样我们得到的输出结果与直接使用 `cat` 读取文件所获得的结果完全一致。
```
$ cat /usr/bin/python3.9 | hexdump -C | head
00000000  7f 45 4c 46 02 01 01 00  00 00 00 00 00 00 00 00  |.ELF............|
00000010  02 00 3e 00 01 00 00 00  c0 a5 5e 00 00 00 00 00  |..>.......^.....|
00000020  40 00 00 00 00 00 00 00  b8 95 53 00 00 00 00 00  |@.........S.....|
00000030  00 00 00 00 40 00 38 00  0b 00 40 00 1e 00 1d 00  |....@.8...@.....|
00000040  06 00 00 00 04 00 00 00  40 00 00 00 00 00 00 00  |........@.......|
00000050  40 00 40 00 00 00 00 00  40 00 40 00 00 00 00 00  |@.@.....@.@.....|
00000060  68 02 00 00 00 00 00 00  68 02 00 00 00 00 00 00  |h.......h.......|
00000070  08 00 00 00 00 00 00 00  03 00 00 00 04 00 00 00  |................|
00000080  a8 02 00 00 00 00 00 00  a8 02 40 00 00 00 00 00  |..........@.....|
00000090  a8 02 40 00 00 00 00 00  1c 00 00 00 00 00 00 00  |..@.............|
```
#### 关于魔术数字的额外说明
这个文件以 `ELF` 开头，这是一个被称为“ 魔术数字   magic number ”的标识符，它是一种字节序列，告诉我们这是一个 ELF 文件。在 Linux 上，ELF 是二进制文件的格式。
不同的文件格式有不同的魔术数字。例如，gzip 的魔数是 `1f8b`。文件开头的魔术数字就是 `file blah.gz` 如何识别出它是一个 gzip 文件的方式。
我认为 `file` 命令使用了各种启发式方法来确定文件的类型，而其中，魔术数字是一个重要的特征。
### 7、寻找解释器
我们来解析这个 ELF 文件，看看里面都有什么内容。
**自行验证**：运行 `readelf -a /usr/bin/python3.9`。我得到的结果是这样的（但是我删减了大量的内容）：
```
$ readelf -a /usr/bin/python3.9
ELF Header:
    Class:                             ELF64
    Machine:                           Advanced Micro Devices X86-64
...
->  Entry point address:               0x5ea5c0
...
Program Headers:
  Type           Offset             VirtAddr           PhysAddr
  INTERP         0x00000000000002a8 0x00000000004002a8 0x00000000004002a8
                 0x000000000000001c 0x000000000000001c  R      0x1
->      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
        ...
->        1238: 00000000005ea5c0    43 FUNC    GLOBAL DEFAULT   13 _start
```
从这段内容中，我理解到：
1. 请求内核运行 `/lib64/ld-linux-x86-64.so.2` 来启动这个程序。这就是所谓的**动态链接器**，我们将在随后的部分对其进行讨论。
2. 该程序制定了一个入口点（位于 `0x5ea5c0`），那里是这个程序代码开始的地方。
接下来，让我们一起来聊聊动态链接器。
### 8、动态链接
好的！我们已从磁盘读取了字节数据，并启动了这个“解释器”。那么，接下来会发生什么呢？如果你执行 `strace -o out.strace python3`，你会在 `execve` 系统调用之后观察到一系列的信息：
```
execve("/usr/bin/python3", ["python3"], 0x560af13472f0 /* 21 vars */) = 0
brk(NULL)                       = 0xfcc000
access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=32091, ...}) = 0
mmap(NULL, 32091, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f718a1e3000
close(3)                        = 0
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libpthread.so.0", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0 l\0\0\0\0\0\0"..., 832) = 832
fstat(3, {st_mode=S_IFREG|0755, st_size=149520, ...}) = 0
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f718a1e1000
...
close(3)                        = 0
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libdl.so.2", O_RDONLY|O_CLOEXEC) = 3
```
这些内容初看可能让人望而生畏，但我希望你能重点关注这一部分：`openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libpthread.so.0" ...`。这里正在打开一个被称为 `pthread` 的 C 语言线程库，运行 Python 解释器时需要这个库。
**自行验证**：如果你想知道一个二进制文件在运行时需要加载哪些库，你可以使用 `ldd` 命令。下面展示的是我运行后的效果：
```
$ ldd /usr/bin/python3.9
    linux-vdso.so.1 (0x00007ffc2aad7000)
    libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f2fd6554000)
    libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f2fd654e000)
    libutil.so.1 => /lib/x86_64-linux-gnu/libutil.so.1 (0x00007f2fd6549000)
    libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007f2fd6405000)
    libexpat.so.1 => /lib/x86_64-linux-gnu/libexpat.so.1 (0x00007f2fd63d6000)
    libz.so.1 => /lib/x86_64-linux-gnu/libz.so.1 (0x00007f2fd63b9000)
    libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f2fd61e3000)
    /lib64/ld-linux-x86-64.so.2 (0x00007f2fd6580000)
```
你可以看到，第一个列出的库就是 `/lib/x86_64-linux-gnu/libpthread.so.0`，这就是它被第一个加载的原因。
#### 关于 LD\_LIBRARY\_PATH
说实话，我关于动态链接的理解还有些模糊，以下是我所了解的一些内容：
* 动态链接发生在用户空间，我的系统上的动态链接器位于 `/lib64/ld-linux-x86-64.so.2`. 如果你缺少动态链接器，可能会遇到一些奇怪的问题，比如这种 [奇怪的“文件未找到”错误](https://jvns.ca/blog/2021/11/17/debugging-a-weird--file-not-found--error/)
* 动态链接器使用 `LD_LIBRARY_PATH` 环境变量来查找库
* 动态链接器也会使用 `LD_PRELOAD` 环境变量来覆盖你想要的任何动态链接函数（你可以使用它来进行 [有趣的魔改](https://jvns.ca/blog/2014/11/27/ld-preload-is-super-fun-and-easy/)，或者使用像 jemalloc 这样的替代品来替换默认内存分配器）