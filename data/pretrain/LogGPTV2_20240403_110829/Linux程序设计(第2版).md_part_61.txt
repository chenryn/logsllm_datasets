CMD
r1ck
nei1
101
6
9 6
018:24tty400:0C:10ytey XOPEN/usr/include/features.h
18 : 24
201
每个进程都会分配到一个独一无二的数字编号，我们称之为“进程标识码”（process
identifier），或者就直接叫它PID。这是一个正整数、取值范围从2到32768。当-个进程被启动
的时候，它会顺序挑选下一个未使用的编号数字做为自已的PID：如果它们已经轮过一圈了，新
的编号重新从2开始。数字1一般是为特殊进程init保留的、它负责管理其他的进程。我们过一会
儿再讨论init进程。现在，我们看到出neiu和rick启动的两个进程分配到的标识码分别是“101”
和“102”。
grep命令将要执行的程序代码保存在一个磁盘文件里。在普通正常操作情况下，一个UNIX
进程是不能对用来存放程序代码的内存区域进行写操作的，也就是说，程序代码是以只读方式
被加载到内存里去的。因为不允许对这个区域做写操作，所以我们可以从示意图中看到：两个
进程安全地共享着一份代码拷贝。
系统库也是可以共享的。举例来说，不管有多少运行中的程序在调用printf函数，内存里只
要有它的一份拷贝就足够了。与微软的Windows使用的动态链接库（dynamiclinklibrary，简称
DLL）相比，UNIX的做法要复杂一些，但原理是相似的。
从示意图里还可以看出，共享带来的好处还有让容纳可执行程序grep的磁盘文件比较小，原
因是它里面少了共享库代码。这对一个程序来说算不上什么，但对一个完整的操作系统来说，
把常用例程提取出来放入（比如说）C语言的标准库将节省大量的空间。
当然，一个程序在运行时所需要的东西并不是都能与其他程序共享的。比如说，它使用的
变量就与其他进程的有明显区别。在这个例子里，我们看到传递给grep命令的搜索字符串是以变
量“s”的形式出现在每个进程的数据区里。它们各有各的去处，通常不能被其他进程读取。两
个grep命令使用的文件也各不相同，进程通过各自的文件描述符访问各自的文件。
除了上面这些东西，进程还有它自己的堆栈空间，函数的局部变量与控制函数调用和返回
的信息就保存在其中。它还有自己的环境空间，其环境变量设置出来的环境是供这个进程专用
的，我们在第4章介绍putenv和getenv的时候已经见到过了。进程还必须有自己的程序计数器、
加入jaVa编程群：524621833
---
## Page 318
300
Linux程序设计
用来记录它自己执行到了什么位置，也就是在执行线程中的位置。我们将在下章里看到：当
我们使用了线程的时候，进程可以有不止一个执行线程。
在许多Linux系统上，也包括一些UNIX系统，在子日录/proc里有一组特殊的文件。它f们是
一些相当特殊的文件，因为它们允许你在进程运行的时候“透视”到进程的内部。
最后，因为UNIX有一个虚拟内存系统，能够把代码和数据以内存页面的形式交换到硬盘上
去，所以它能管理的进程比物理内存所能容纳的要多得多。
10.2.1进程表
UNIX进程表是这样一种数据结构，它把当前加载在内存里的所有进程的有关信息保存在一
个表里，其中包括进程的PID、进程的状态和命令字符串、ps命令输出的各种信息等。系统通过
进程的PID对它们进行管理，这个编号在进程表里被用做一个索引。这个表的长度是有限的，所
现代的版本上，这一限制已放松了许多，只要划分给进程表使用的内存里还有容纳数据项的地
方，就允许继续启动进程。
10.2.2查看进程
ps命令能够列出我们正在运行的进程、其他以后正在运行的进程，或者系统上正在运行的全
部进程。下面是一个输出样本：
S p8 -af
UID
root
433
PID
d1dd
425
C STIME TTY
0 18:12 tty1
00:00:00 [bash]
TIME CMD
445
426
rick
456
427
D
0
18:12
18:12
tty2
tty3
00:00:00 [bash]
00:00: 00
-bash
root
467
433
root
474
467
。
18:12 tty1
00:00:00 sh/usx/x11R6/bin/startx
Q
18:12tty1
18 : 12
tty1
00:00:00 xinit /etc/X11/xinit/xinitrc 
toot
478
474
0
00:00:00/usr/bin/gnome-session
root
487
root
493
18:12
18 : 12
tty1
00:00:01[enlightenment]
00: 00: 00
gnone-snproxy --sm-client-id def
root
506
0
0
18:12
ttyi
00:00:03 panei--sm-elient-id default8
root
508
18 :12
tty]
00:00:0 xscreensaver -no=splash-timeout
rooL
root
OTS
512
018:12ttyl
18 :12
tty1
00:00:01 gmc --sn-client-id default10
root
649
445
0 16 :24
00: 00: 01
root
59
649
018:24
tty2
tty2
00 : 00 : 00
00:00:00 bash
Su
nei1
655
428
018:24tty4
713
218:27 tty1
4sq-00:00:00
root
1
182810
00:00:00 gnome-terninal
root
715
715
1odaqqd-au500:00:00
root
717
716
root
718
018:28 tty2
00:00:01 emacs
653
00:00:00 ps -af
这份输出列出了许多进程的资料，我们可以在表里找到一些与X窗口和Emacs编辑器有关的
进程。“TTY”一栏表示进程是从哪个终端启动的；“TIME”是进程的CPU占用时间；“CMD"
是启动进程时所用的命令。我们来仔细研究几个数据项。
nei1
655
018:24 tty4
00:00:00 -bash
初始化登录操作是在第4个虚拟终端上完成的，它也是这台机器的控制台。它启动运行的程
字是Linux系统的默认shell：bash。
加入java编程群：524621833
---
## Page 319
第10章进程和信号
301
root467433018:12tty1
00:00:00 sh /usr /X11R6, bin/startx
X窗口系统是由命令startx启动的。这是一个用来启动X服务器并运行一些初始化x窗口程序
的shell脚本程序。
root
717
716 13 19:28 ps. 0
00:00:01 emacs
这个进程代表着x窗口系统里一个运行着Emacs编辑器的窗口。它是由窗口管理器响应创建
一个新窗口的请求而启动的。为了让shell能够对窗口进行读写，还分配了一个新的伪终端pts/0。
root
这是由窗口管理器启动的Gnome帮助信息浏览器。
在默认的情况下，ps程序只给出与某个终端、某个控制台、某个申行1或某个伪终端保持着
连接的进程的情况。其他进程在运行时不需要通过终端与用户进行通信。这些基本上都是一些
系统进程，UNIX通过系统进程来管理共享性资源。要想查看全部的进程，就要给ps加上“-a”
选项：要想看到完整的信息、要加比“-f”选项。ps命令的准确语法和它输出内容的格式随系统
的不同会稍有变化。有关ps命令的选项及其输出格式方面的详细资料请查阅它的使用手册页。
10.2.3系统进程
下面是一些这台Linux系统上运行着的其他--些进程。为简洁起见，我们对输出结果做了
删节。
SP8 -ax
PID TTY STAT
TINE COMHAND
0:00 init
0:00update (bdflush)
40
？s
0:00/usr/sbin/pd
0:01/usr/sb1n/syslogd
517S
46
88 v02 S
0:00 sendmail: accepting connections
109？R
0:00 ps -ax
0:41 X :0
192 pp0 R
我们在这里看到了个非常重要的进程。
1？S0:00init
一般说来，每个进程都是由另一个我们称之为“父进程”的进程启动的；被父进程启动的
进程叫做子进程。当UNIX开始运行的时候，它会运行一个名为init的程序，它是一切进程的
“祖先”，它的进程编号是“1"。这就是操作系统的进程管理器。我们将要学习到的其他系统进
程都是电init启动的，或者是由被init启动的进程启动的。
用户登录上机的处理过程就是一个这样的例子。用户登录上机需要使用串行终端或拨号调
制解调器，面init会为每一个登录设备启动一次getty程序。对应的ps命令输出就是下面这个样
子的：
20488
0:00sbin/agetty 38400 tty2
getly进程等待来自终端的操作，向用户显示熟悉的登录提示符，如何把控制移交给登录程
序：登录程序先设置好用户环境，最后启动一个shell。当用户shell退出时，init会再启动另外一
个gety进程。
加入java编程群：524621833
---
## Page 320
302Linux程序设计
内容里将会看到如何从我们的程序里通过系统调用fork、exec和wait完成同样的工作。
10.2.4进程的调度
ps命令的输出结果里还有一个与ps命令本身对应的数据项：
192pp0R
xe.sd00:0
这一行的含义是：进程192处于执行状态（R），正在执行的命令是“ps-ax”，也就是说，进
程出现在它自已的输出里了！状态指示标志只表示程序随时可以运行，并不一定是正在运行。
在一台单处理器计算机上，任一时刻只能有一个进程在运行，所有进是轮流运行的。每个进
行的印象。“R”只表达这样一个意思：这个程序不需要等待其他进程执行完毕，或者它不需要
等待输人输出操作的完成。这就是我们的示例输出里有两个这样的进程的原因（另一个进程是X
显示服务器）
UNIX系统通过一个进程调度器（scheduler）来决定下一个时间片应该分配给哪一个进程。
这就要用到进程的优先级。我们最早是在第4章里遇见优先级概念的。优先级比较高的进程运行
得比较频繁，而包括后台任务在内的低优先级进程运行得就不那么频繁。在UNIX里，进程的运
行时间是不可能超过分配给它们的时间片的。它们是多任务系统中的进程，它们的挂起和继续
运行不需要它们的合作。但早一些的系统，比如微软的Windows3.x，通常要求进程明确地退出
时间片，然后其他进程才能继续运行。
是10。长期不间断运行的程序其优先级一般会低一些。在（比如说）等待输人数据时暂停运行
的程序会得到奖励。这可以使程序及时响应用户的交互操作：当程序等待来自用户的输人数据