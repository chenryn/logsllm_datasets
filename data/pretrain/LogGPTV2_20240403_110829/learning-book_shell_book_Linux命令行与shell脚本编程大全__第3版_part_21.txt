allas 11=′1α -a1F
allas lg=′lα --color=auto
注意，在该UbuntuLinux发行版中，有一个别名取代了标准命令ls。它自动加人了--color
选项，表明终端支持彩色模式的列表。
可以使用alias命令创建属于自己的别名。
S alias 1i=*1s -11'
11
529581 drwxr-Xr-x. 2 Chr1atine Chr1atLne 4096 May 19 18:17 Deaktop
tota1 36
529582 drwxr-xr-x. 2 Chr1at1ne Chr1at.1ne 4096 Apr 25 16:59 Doumloads
529586 dzwxr=xr=x. 2 Chxiat1ne Chziat1ne 4096 Apr 25 16:59 Rua1c
529584 drwxr-xr-x. 2 Chriatlne Chr1atlne 4096 Apr 25 16:59 Pub11c
529587 dzwxr=xr=x. 2 Chxiat1ne Chxiat1ne 4096 Apz 25 16:59 Pictures
532891 -xwxrv-r==, 1 Chxiatlne Chxistlne
36 Kay 30 07 :21 test.ah
529588 dxwxrxrx. 2 Chxiat1ne Chxist1ne 4096 Apx 25 16:59 Video8
在定义好别名之后，你随时都可以在shell中使用它，就算在shell脚本中也没问题。要注意，
因为命令别名属于内部命令，一个别名仅在它所被定义的shell进程中才有效。
S alias 1i=*1s -11'
S bash
11
bash: 1l: command not found
$exit
ex1t
$
不过好在有办法能够让别名在不同的子shell中都奏效。下一章中就会讲到具体的做法，另外
还会介绍环境变量。
5.4小结
本章讨论了复杂的交互式程序：GNU bash shell。其中包括理解shell进程及其关系，如何生
成子shell，以及子shell与父shell的关系。还探究了那些能够创建子进程的命令和不能创建子进程
的命令。
当用户登录终端的时候，通常会启动一个默认的交互式shell。系统究竞启动哪个shell，这取
决于用户ID配置。一般这个shell都是/bin/bash。默认的系统shell（/bin/sh）用于系统shell脚本，如
那些需要在系统启动时运行的脚本。
---
## Page 117
102
第5章理解shell
shell运用在命令行中使得我们能够创造性地高效使用CLI。子shell还可以嵌套，生成子shell的子
shell，子shell的子shell的子shell。创建子shell的代价可不低，因为还必须为子shell创建出一个全
新的环境。
在最后，我们学习了两种不同类型的命令：内建命令和外部命令。外部命令会创建出一个包
含全新环境的子进程，而内建命令则不会。相比之下，外部命令的使用成本更高。内建命令因为
不需要创建新环境，所以更高效，不会受到环境变化的影响。
shell、子shell、进程和衍生进程都会受到环境变量的影响。下一章，我们会探究环境变量的
影响方式以及如何在不同的上下文中使用环境变量。
---
## Page 118
第6章
使用Linux环境变量
本章内容
口什么是环境变量
口创建自己的局部变量
口删除环境变量
口默认shell环境变量
设置PATH环境变量
口定位环境文件
口数组变量
inux环境变量能帮你提升Linux shell体验。很多程序和脚本都通过环境变量来获取系统
信息、存储临时数据和配置信息。在Linux系统上有很多地方可以设置环境变量，了解
去哪里设置相应的环境变量很重要。
本章将带你逐步了解Limux环境变量：它们存储在哪里，怎样使用，以及怎样创建自已的环
境变量。最后以数组变量的用法作结。
6.1
什么是环境变量
bash shell用一个叫作环境变量（environment variable）的特性来存储有关shell会话和工作环
境的信息（这也是它们被称作环境变量的原因）。这项特性允许你在内存中存储数据，以便程序
或shell中运行的脚本能够轻松访问到它们。这也是存储持久数据的一种简便方法。
在bash shell中，环境变量分为两类：
口全局变量
口局部变量
本节将描述以上环境变量，并演示怎么查看和使用它们。
---
## Page 119
104
第6章使用Linux环境变量
说明尽管bash shell使用一致的专有环境变量，但不同的Linux发行版经常会添加其自有的环境
变量。你在本章中看到的环境变量的例子可能会限你安装的发行版中看到的结果略微不
同。如果遇到本书未讲到的环境变量，可以查看你的Linux发行版上的文档。
6.1.1全局坏境变量
全局环境变量对于shell会话和所有生成的子shell都是可见的。局部变量则只对创建它们的
shell可见。这让全局环境变量对那些所创建的子shell需要获取父shell信息的程序来说非常有用。
Linux系统在你开始bash会话时就设置了一些全局环境变量（如想了解此时设置了哪些变量，
请参见6.6节）。系统环境变量基本上都是使用全大写字母，以区别于普通用户的环境变量。
要查看全局变量，可以使用env或printenv命令。
HOSINAME=server01, class edu
$ printenv
SELINUX_ROLIE_REQUESTED=
TERN=xtern
SHELL= /bin/ba.sh
HISTSIZE=1000
HOME=/bome/Christine
[ -.. ]
LOGAMg=Chrietine
G_BROKEN_FILENAMES=1
[ - . . ]
_=/usr/bin/printenv
系统为bashshell设置的全局环境变量数目众多，我们不得不在展示的时候进行删减。其中有
很多是在登录过程中设置的，另外，你的登录方式也会影响到所设置的环境变量。
要显示个别环境变量的值，可以使用printenv命令，但是不要用env命令。
S printenv Bous
/home/Chrietine
S env BOME
env HoME: No such file or directory
$
也可以使用echo显示变量的值。在这种情况下引用某个环境变量的时候，必须在变量前面
加上一个美元符（$）。
S echo $HOMB
/home/Chrietine
在echo命令中，在变量名前加上s可不仅仅是要显示变量当前的值。它能够让变量作为命令
行参数。
S 1s $BOME
---
## Page 120
6.1什么是环境变量
105
Deaktop
Down1oads
Music
Pub1ic
te.st . ah
Documents
Junk, dat
Plctures
TemplatesVideos
Deaktop
S 1s /home/Christine
Down1oada
Mus1c
Pub1ic
test.ah
Documenta
Junk,dat
Plctures
TemplatesVideos
正如前面提到的，全局环境变量可用于进程的所有子shell。
S bash
UID
S p8
=f
PID PPID C STIME TTY
TIKE CKD
501
501
2017
2016
0 16:00 pts/0
00 :00 : 00 bash
501
2082
2017
0/sd εo=9t 0
00 :00: 00 ba.sh
2095
2082
0/sd εo=9t 0
00:00:00 pa -f
S echo SHOME
/home /Chx1atLne
S exit
ex1t
在这个例子中，用bash命令生成一个子shell后，显示了HOME环境变量的当前值，这个值和
父shell中的一模一样，都是/home/Chrisine。
6.1.2局部环境变量
顾名思义，局部环境变量只能在定义它们的进程中可见。尽管它们是局部的，但是和全局环
境变量一样重要。事实上，Linux系统也默认定义了标准的局部环境变量。不过你也可以定义自
已的局部变量，如你所想，这些变量被称为用户定义局部变量。
查看局部环境变量的列表有点复杂。遗憾的是，在Linux系统并没有一个只显示局部环境
变量的命令。Set命令会显示为某个特定进程设置的所有环境变量，包括局部变量、全局变量
以及用户定义变量。
S set
BASH= /bLn/bash
BASH_ALIASES= ()
[ - - . ]
BASH_ARGC= ()
BASH_CNDS= ()
BASH_ARGV= ()
BASH_LINENO= ()
BASH_SOURCE= ()
color&=/ete/DIR_COLORS
[ - - . ]
my_Variable= *He1lo Wor1d '
[· - - ]
---
## Page 121
106第6章使用Linux环境变量
可以看到，所有通过printenv命令能看到的全局环境变量都出现在了set命令的输出中。
但在set命令的输出中还有其他一些环境变量，即局部环境变量和用户定义变量：
说明命令env、printenv和set之间的差异很细微。set命令会显示出全局变量、局部变量以
及用户定义变量。它还会按照宇母顺序对结果进行排序。env和printenv命令同set命
令的区别在于前两个命令不会对变量排序，也不会输出局部变量和用户定义变量。在达
种情况下，env和printenv的输出是重复的。不过env命令有一个printenv没有的功能，
这使得它要更有用一些。
6.2设置用户定义变量
可以在bash shell中直接设置自已的变量。本节将介绍怎样在交互式shell或shell脚本程序中创
建自己的变量并引用它们。
6.2.1设置局部用户定义变量
一旦启动了bash shell（或者执行一个shell脚本），就能创建在这个shell进程内可见的局部变
量了。可以通过等号给环境变量赋值，值可以是数值或字符串。
S ecbo $my_variable
S my_variable=He110
S echo $my_variable
He11o
非常简单！现在每次引用my_variable环境变量的值，只要通过$my_variable引用即可。
如果要给变量赋一个含有空格的字符申值，必须用单引号来界定字符申的首和尾。
S my_variable=Hello World
-bash: Wor1d: command not found
S my_variable=*Bello Wor1d*
S echo $my_variable
Hello Horld
没有单引号的话，bashshell会以为下一个词是另一个要执行的命令。注意，你定义的局部环
境变量用的是小写字母，而到目前为止你所看到的系统环境变量都是大写字母。
窍门所有的环境变量名均使用大写宇母，这是bash shell的标准惯例。如果是你自己创建的局
部变量或是shell脚本，请使用小写字母。变量名区分大小写。在涉及用户定义的局部变量
时坚持使用小写宇母，这能够避免重新定义系统环境变量可能带来的灾难。
---
## Page 122
6.2设置用户定义变量
107
记住，变量名、等号和值之间没有空格，这一点非常重要。如果在赋值表达式中加上了空格，
bashshell就会把值当成一个单独的命令：
 my_variable = "Hello World*
-bash: ny_variable: command not found
设置了局部环境变量后，就能在shell进程的任何地方使用它了。但是，如果生成了另外一个
shell，它在子shell中就不可用。
S my_variable=*Hello World*
S bash
S echo $ay_variab1e
Sexit
ex1t
S echo Say_variable
$
He11o Kox1d
在这个例子中生成了一个子shell。在子shell中无法使用用户定义变量my_variable。通过命
令echo$my_variable所返回的空行就能够证明这一点。当你退出子shell并回到原来的shell时，
这个局部环境变量依然可用。
类似地，如果你在子进程中设置了一个局部变量，那么一旦你退出了子进程，那个局部环境
变量就不可用。
$ echo $ay_child_variable
S bash
 my_chi1d_variable=*8ello Little Wor1d"
S echo $ay_child_variable
Hello Little World
Sexit
ex1t
S echo $ay_child_variable
当我们回到父shell时，子shell中设置的局部变量就不存在了。可以通过将局部的用户定义变
量变成全局变量来改变这种情况。
6.2.2设置全局环境变量
在设定全局环境变量的进程所创建的子进程中，该变量都是可见的。创建全局环境变量的方
---
## Page 123
108
第6章使用Linux环境变量
法是先创建一个局部环境变量，然后再把它导出到全局环境中。
这个过程通过export命令来完成，变量名前面不需要加s。
$ my_variable=*I am Global noua
$ export my_variable
$ echo $my_variable
am Global no
$ bash
$echo $my_variable
I am Global nov
$exit
exit
$ echo $my_variable
$
I am Global now
在定义并导出局部环境变量my_variable后，bash命令启动了一个子shell。在这个子shell
中能够正确的显示出变量my_variable的值。该变量能够保留住它的值是因为export命令使其
变成了全局环境变量。
修改子shell中全局环境变量并不会影响到父shell中该变量的值。
my_variable=*I am Global nou*
S export my_variable
$ echo $my_variable
I am 0lobal nov
$ bash
$echo $my_variable
I am Global no
Smy_variablea*Mull*
ecbo $my_variable
Nul1