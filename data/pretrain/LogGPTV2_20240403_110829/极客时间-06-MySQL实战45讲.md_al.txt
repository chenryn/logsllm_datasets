### 查询过程

假设执行的查询语句是 `SELECT id FROM T WHERE k = 5`。此查询在索引树上查找的过程如下：首先通过 B+ 树从根节点开始，逐层搜索到叶子节点（即图中右下角的数据页），然后利用二分法在数据页内部定位记录。

- 对于普通索引，查找到第一个满足条件的记录 (5, 500) 后，需继续查找下一个记录，直到遇到第一个不满足 `k = 5` 条件的记录。
- 对于唯一索引，由于其定义了唯一性约束，一旦查找到首个符合条件的记录，检索即停止。

那么，这两种索引带来的性能差异有多大呢？实际上，这种差异微乎其微。InnoDB 的数据读写以数据页为单位进行，默认每个数据页大小为 16KB。当找到 `k = 5` 的记录时，整个包含该记录的数据页已被加载至内存。因此，对于普通索引而言，额外的一次“查找并判断下一条记录”的操作仅涉及一次指针移动和一次计算。若 `k = 5` 的记录恰好位于数据页末尾，则需要读取下一个数据页，这将稍显复杂。然而，鉴于一个数据页可容纳近千个整型键值，上述情况发生的概率较低。综上所述，在评估平均性能差异时，可以认为这一操作对现代 CPU 而言几乎无影响。

### 更新过程

为了阐明普通索引与唯一索引对更新语句性能的影响，我们先来了解一下 change buffer。当更新某个不在内存中的数据页时，如果不会破坏数据一致性，InnoDB 会将这些更新缓存在 change buffer 中，从而避免从磁盘读取该页。随后，在下次访问此数据页时，将其载入内存，并执行与之相关的 change buffer 操作，确保数据逻辑正确。值得注意的是，尽管名为 change buffer，但它实际上是持久化数据的一部分，不仅存在于内存中，也会被写入磁盘。将 change buffer 中的操作应用于原始数据页以获取最新结果的过程称为 merge。除数据页访问外，后台线程也会定期执行 merge，且数据库正常关闭过程中亦会触发此操作。

显然，若能先将更新记录在 change buffer 中，减少磁盘读取次数，语句执行速度将显著提升。此外，这种方式还能避免占用过多缓冲池内存，提高内存利用率。然而，**什么条件下可以使用 change buffer 呢？**

对于唯一索引，所有更新前均需验证是否违反唯一性约束。例如，插入 (4, 400) 时，必须先确认表内是否存在 `k = 4` 的记录，而这要求将相关数据页读入内存。既然已读入内存，直接更新则更为高效，无需使用 change buffer。因此，唯一索引的更新无法利用 change buffer，而只有普通索引适用。change buffer 占用 buffer pool 内存，故不能无限扩展。其大小可通过参数 `innodb_change_buffer_max_size` 动态调整，如设为 50 表示 change buffer 最多占 buffer pool 的 50%。

现在，让我们探讨**向表中插入新记录 (4, 400) 时，InnoDB 的处理流程**：

- **目标页已在内存中**：
  - 唯一索引：在 3 和 5 之间定位，确认无冲突后插入；
  - 普通索引：同样在 3 和 5 间插入。

- **目标页不在内存中**：
  - 唯一索引：需先将数据页读入内存，再做相同判断；
  - 普通索引：仅需在 change buffer 记录更新即可完成操作。

由此可见，普通索引与唯一索引对更新性能的主要区别在于前者省去了随机 I/O 访问，这对于大量插入操作尤其有利。曾有一位 DBA 反映，某业务库因将普通索引改为唯一索引而导致内存命中率骤降、系统阻塞。

### change buffer 的使用场景

根据前述分析，我们知道 change buffer 可加速更新过程，但仅适用于普通索引。那么，所有普通索引场景都能从中获益吗？答案取决于具体应用场景。merge 发生时才会真正更新数据，而 change buffer 主要用于缓存变更动作。因此，数据页在 merge 前积累越多变更（即更多更新请求），收益越大。对于写多读少的业务（如账单、日志系统），页面写入后立即被访问的概率较小，此时 change buffer 效果最佳。反之，若业务模式为写入后立刻查询，则 change buffer 可能反而增加开销，因为它仍需触发 merge 过程，未减少随机 I/O 次数。

### 索引选择与实践

回到最初的问题——如何选择普通索引与唯一索引。两者在查询能力上并无差异，关键在于对更新性能的影响。建议优先选用普通索引。若所有更新操作后紧跟着对该记录的查询，则应禁用 change buffer。其他情况下，change buffer 有助于提升更新效率。特别是在使用机械硬盘存储历史数据时，开启大容量 change buffer 可显著加快写入速度。

### change buffer 与 redo log

理解了 change buffer 的工作原理后，你可能会联想到之前介绍过的 redo log 和 Write-Ahead Logging (WAL)。这两个概念都旨在减少随机 I/O，容易混淆。以下通过实例说明它们的区别：

考虑执行如下插入语句：
```sql
INSERT INTO t(id, k) VALUES (id1, k1), (id2, k2);
```
假设当前 k 索引树状态为：k1 所在的数据页位于内存中，而 k2 的不在。更新过程如下：
1. 直接更新内存中的 Page 1；
2. 在 change buffer 区域记录 "向 Page 2 插入一行"；
3. 将以上两个动作记入 redo log。

事务至此完成。此过程仅涉及两次内存写入及一次顺序磁盘写入，响应时间短。后续读请求处理如下：
- 读取 Page 1 时直接返回内存中的结果；
- 读取 Page 2 时，需先将其从磁盘加载到内存，并应用 change buffer 中的操作生成最终版本。

总之，redo log 主要节省随机写 I/O，而 change buffer 则侧重减少随机读 I/O。

### 小结

本文从普通索引与唯一索引的选择入手，探讨了数据查询与更新机制，详细介绍了 change buffer 的运作原理及其适用场景，并结合实际案例展示了其在优化大规模表更新方面的优势。考虑到唯一索引无法利用 change buffer 的优化特性，从性能角度出发，推荐在业务允许的情况下优先采用普通索引。最后提醒一点：虽然 change buffer 存储于内存中，但它是持久化的，重启后不会丢失数据。