the correct operation of another node. Therefore, when a
node relies on information received from or sent to multiple
other nodes, the trustworthiness of that data must account
for the possibility that the remote nodes are colluding.
Sensor networks rely on low power wireless transmis-
sion for data exchange. Therefore an adversary can sup-
press the ﬂow of information by generating radio interfer-
ence. Although the network stack may provide reliable
transport by retransmitting lost data, it can not ensure that
delivery will occur within a ﬁxed timeframe. Unpredictable
delays in the receipt of data must be supported. In partic-
ular, a protocol that relies on receiving cryptographic ma-
terial within ﬁxed temporal windows is untenable in this
setting.
Trust can be built using cryptography and by distribut-
ing the trusted computing base. While sensors are limited
to using symmetric cryptography, base stations have sufﬁ-
cient resources to utilize asymmetric cryptographic primi-
tives. Further, a sensor network consists of a large number
of nodes. Sensors can exploit this by using a distributed
protocol to prevent any one node from becoming a central
point of failure. PAST composes these to provide the requi-
site assurance.
3. Protocol Description
We ﬁrst provide a high level description of PAST in Sec-
tion 3.1. Section 3.2 details how a sensor generates times-
tamped data. Section 3.3 describes how a base station can
probabilistically authenticate the timestamps. Finally, Sec-
tion 3.4 outlines how the base station certiﬁes the data’s
timestamps.
3.1. Overview
PAST has three stages. The ﬁrst occurs at the sensor
where the reading is generated as depicted in Step 1 of Fig-
ure 1. As explained in Section 2.3, using an asymmetric
cryptographic primitive to sign the data would use too much
battery power. In fact, authenticating each reading individ-
ually would also consume a signiﬁcant amount of power.
Instead, readings are batched together in blocks. When
enough readings have been buffered to populate a block, the
data is encrypted with a symmetric cipher. The key used is
not known to the base station to which the block will be
transmitted. Instead it is the key of another base station in
the network. This node will act as a notary by verifying the
block’s timestamp and then certifying it. Every base station
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:34:52 UTC from IEEE Xplore.  Restrictions apply. 
Proceedings of the 22nd Annual Computer Security Applications Conference (ACSAC'06)0-7695-2716-7/06 $20.00  © 20064  Reading verified
    using other data
from same
      sensor
Base
Station
Target
Phenomenon
Sensor
1  Reading
   generated at sensor
2  All
   readings
   sent to closest
   base station
3  Successive
   readings forwarded
   to different base stations
Figure 1. A set of witnesses are generated for each block of sensor readings in Step 1. The reading
includes witnesses for other blocks. A block is sent to the base station closest to the sensor in Step
2. From there it is forwarded to another base station which acts as a notary in Step 3. As a notary,
the base station uses witnesses from other blocks to certify a reading in Step 4.
in the network acts as a notary for some set of sensors dis-
tributed across the network. It will also act as a gateway
for the set of sensors closest to it. The notaries act as im-
partial referees (unless they have been compromised by an
adversary). To prevent a gateway from becoming a central
point of failure, the set of sensors for which it is a notary
is disjoint from the set of sensors for which it serves as a
gateway. The notary stores a hash of the data keyed by the
concatenation of the source sensor’s address and the block’s
timestamp. It then encrypts the block with a storage server’s
public key and forwards it to long term storage. Successive
blocks of sensor readings are forwarded to different notaries
as illustrated in Step 3 of Figure 1. As a result, the stream
of data generated by a sensor is not visible in its entirety
to any other node in the network. PAST exploits this prop-
erty by creating a set of witnesses using hashes of a sensor’s
most recently generated readings. No node other than the
sensor can construct such a set since they do not have ac-
cess to the entire data stream. (We assume that the private
key of the storage server will not be compromised.) Each
block of readings is prepended with such a set of witnesses
and then transmitted to the closest base station in encrypted
form. This completes Step 2 in Figure 1.
When a base station receives a data block from a sensor,
it will be encrypted with a key unknown to it. However,
the block’s header will include the destination address of
the base station that will serve as the notary for that block,
as depicted in Figure 2. The gateway forwards the block
to that base station, as shown in Step 3 of Figure 1, where
the second stage of PAST can commence. When the notary
receives the block, it extracts the source address of the sen-
sor from the header. It uses this to lookup the decryption
key needed to retrieve the sensor readings and the block’s
index, timestamp, hash, and set of witnesses. The hash of
the reading is computed and compared to the one extracted
from the encrypted block. If they do not match, the integrity
of the block is compromised and it is discarded. Next, each
witness must be checked. Since a witness is the hash of
a previous block of data generated by the sensor, the base
station where that block was sent will be able to validate
the witness. The block’s header, as shown in Figure 2, will
include a notary’s address prepended before each witness.
This notary is the base station that can validate the witness.
The index of the block whose hash it is can be calculated
from the location of the witness in the header. The vali-
dating base station is contacted with the source sensor’s ad-
dress, the witness block’s index and a nonce. It retrieves its
record of the witness, combines it with the nonce and replies
with the result. The notary combines its copy of the witness
with the nonce and checks if this matches the result it re-
ceived. As more witnesses are validated, the notary can be
increasingly conﬁdent that the block’s timestamp is authen-
tic. The timestamp included in the block is that of the last
reading. However, if each reading’s timestamp is needed, it
can be prepended before the reading and the timestamp in
the header can be omitted. PAST’s authentication guaran-
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:34:52 UTC from IEEE Xplore.  Restrictions apply. 
Proceedings of the 22nd Annual Computer Security Applications Conference (ACSAC'06)0-7695-2716-7/06 $20.00  © 2006Source
Destination
Index
Timestamp
Hash
3.2. Witness Generation
Notary
1
Witness
Notary
2
1
Witness
2
Reading
1
Reading
2
= Encrypted with key shared by sensor ’Source’
and base station ’Destination’
Figure 2. The format of a PAST block. The
source sensor’s address and destination
base station’s address are unencrypted. The
rest of the data is encrypted. Successive
blocks generated by the same sensor have
consecutive index numbers. A set of wit-
nesses and the notaries where they can be
validated is included. The block includes as
many readings as can be buffered in the sen-
sor’s memory.
tees will hold without any modiﬁcation to the protocol.
In principle, the second stage of PAST sufﬁces for au-
thenticating the timestamps of the sensor readings. How-
ever, nodes running applications using the data may not be
connected to the sensor network. This would prevent them
from querying base stations to perform the second stage of
PAST. The third stage of PAST accounts for this. In this
ﬁnal stage, after a notary has veriﬁed the testimony of mul-
tiple witnesses, it certiﬁes the timestamp included with the
block of readings using a digital signature. Recall that the
base station does not have computational and power con-
straints. Therefore it can utilize asymmetric cryptographic
primitives for this purpose. These signatures can be veriﬁed
using the base station’s public key, either at a node without
connectivity to the sensor network or even ofﬂine. The no-
tary encrypts the source sensor address, the timestamp and
the block of readings in a single message using the public
key of the storage server. This is done so that the data is
not readable by an adversary once it leaves the notary. If
it were, the adversary could use it to generate fraudulent
witnesses for earlier sensor readings. The encrypted data is
then signed with a forward-secure identity-based signature.
If an adversary subsequently compromises the base station,
access to the cryptographic keys will not enable it to gener-
ate a signature for an altered version of the encrypted data
since the signature is forward-secure. Further, when an ap-
plication uses the data, it can verify the signature without
network access. This is because the signature is identity-
based and the veriﬁcation key evolution protocol introduced
in Section 3.4 can operate ofﬂine.
A sensor generates a stream of readings. PAST groups
the data into timestamped blocks. The simplest authenti-
cation a sensor can provide is to include a token with each
block that uses information known only to the sensor and
the veriﬁer. If the veriﬁer is a base station, then when it is
compromised it would be able to generate fraudulent read-
ings. The veriﬁer could claim that they came from the sen-
sor and there would be no means of detecting the decep-
tion. The sensor could generate copies of each reading and
send them to multiple destinations. However, this would
consume proportionately more power and decrease the ﬁeld
life of the sensor. PAST addresses this issue by generating
multiple short witnesses that can testify to the authenticity
of the block.
A witness is a ﬁxed size hash that is signiﬁcantly smaller
than the block it represents. Since it is small, transmitting
copies of it to multiple base stations would only use a small
amount of power. However, if the same witness was sent
to each base station, any group of colluding nodes could
all claim to have received an alternate fraudulent witness.
Therefore, the witnesses must be distinct from each other.
Simultaneously, they must attest to the integrity of the same
block. As a result, they must be all have a veriﬁable rela-
tionship to the block. Composing the hash function multiple
times would generate such witnesses. However, an adver-
sary that has access to the ﬁrst witness would be able to
derive the subsequent ones by repeatedly hashing its wit-
ness. Thus the witnesses for a particular block can not use
the same input value with the hash function composed a dif-
fering number of times.
In addition to the above constraints, the witnesses se-
lected must support forward-secure authentication. Specif-
ically, if a sensor is compromised, access to a current set
of witnesses should not allow fraudulent earlier ones to be
generated. This property is needed as the witnesses will be
used to attest to the integrity of timestamps. Without this
property earlier timestamps could be forged.
We now describe how PAST creates witnesses that sat-
isfy the above constraints. The blocks of readings generated
by a sensor are indexed, starting from 0 when the sensor
is initially deployed. Subsequent blocks are consecutively
numbered. If more witnesses are included in a block, it can
be authenticated with greater certainty. However, as this
number increases, so does the storage overhead and with it
the power consumed to transmit the block. We parametrize
the number of witnesses used for each block, terming it α.
Each sensor maintains a FIFO of current witnesses. (The
ﬁrst-in ﬁrst-out property is implemented as a circular ar-
ray where the successor of the last element is the ﬁrst. A
pointer tracks the location of the current head of the FIFO.)
The ﬁrst entry is h(ri), the hash of ri, the most recently
generated block of sensor readings. (Throughout this paper
h() denotes a one-way hash function.) The second entry
is h2(ri−1) = h(h(ri−1)), the hash of the hash of ri−1,
the previous block of sensor readings. Successive entries
of the FIFO are the result of composing the hash function
an increasing number of times and using sequentially ear-
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:34:52 UTC from IEEE Xplore.  Restrictions apply. 
Proceedings of the 22nd Annual Computer Security Applications Conference (ACSAC'06)0-7695-2716-7/06 $20.00  © 2006wα
w
2
w
1
t
e
S
s
s
e
n
t
i
W
α
Elements
α
  1  rh  (    )
α  rh  ( n−  )
  α−1
α
  r
  α
h  ( n−  )
2
2
  r
  rh  (       ) h  (       )
  α−2
  α−3
2