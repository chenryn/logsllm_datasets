o
i
l
l
i
m
1
x
(
s
e
t
a
g
l
u
m
f
o
r
e
b
m
u
N
60
40
20
0
Auction (25)
Auction (50)
Auction (100)
Fig. 9. Gains after adding each optimization to the finalize auction
circuit, with 25, 50 and 100 Bidders. Opt 1 and Opt 2 are two practical
optimizations detailed in Section V.
852852
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:16:41 UTC from IEEE Xplore.  Restrictions apply. 
is just linearly dependent on the size of the public statement,
which is far smaller than the size of the computation,
resulting into small veriﬁcation time.
• On-chain public parameters: As mentioned in Sec-
tion IV-C, not the entire SNARK common reference string
(CRS) need to be on the blockchain, but only the veriﬁcation
key part of the CRS needs to be on-chain. Our imple-
mentation suggests the following: the private cash protocol
requires a veriﬁcation key of 23KB to be stored on-chain –
this veriﬁcation key is globally shared and there is only a
single instance. Besides the globally shared public param-
eters, each Hawk contract will additionally require 13-114
KB of veriﬁcation key to be stored on-chain, for 10 to 100
users. This per-contract veriﬁcation key is circuit-dependent,
i.e., depends on the contract program. We refer the readers
to Section IV-C for more discussions on techniques for
performing trusted setup.
• Manager computation: Running private auction or crowd-
funding protocols with 100 participants requires under
6.5min proof time for the manager on a single core, and
under 2.85min on 4 cores. This translates to under $0.14 of
EC2 time [2].
• User computation: Users’ proof times for pour, freeze
and compute are under one minute, and independent of the
number of parties. Additionally, in the worst case, the peak
memory usage of the user is less than 4 GB.
Savings from protocol optimizations. Figure 8 illustrates
the performance gains attained by using a SNARK-friendly
implementation for the user-side circuits, i.e. pour, freeze
and compute w.r.t. the naive implementation at the 80-bit
security level. We calculate the naive implementation cost
using conservative estimates for the straightforward implemen-
tation of standard cryptographic primitives. The ﬁgure shows a
gain of 2.0-2.6× compared to the naive implementation. Fur-
thermore, Figure 9 illustrates the performance gains attained
by our protocol optimizations described in Section V The
ﬁgure considers the sealed-bid auction ﬁnalize circuit at dif-
ferent number of bidders. We show that the SNARK-friendly
implementation along with our two optimizations combined
signiﬁcantly reduce the SNARK circuit sizes, and achieve a
gain of 10× relative to a straightforward implementation. The
ﬁgure also illustrates that the manager’s cost is proportional
to the number of participants. (By contrast, the user-side costs
are independent of the number of participants).
VII. ADDITIONAL THEORETICAL RESULTS
Last but not the least, we present additional theoretical
results to fruther illustrate the usefulness of our formal block-
chain model. In the interest of space, we defer details to the
online version [37], and only state the main ﬁndings here.
Fair MPC with public deposits in the generic blockchain
model. As is well-understood, fairness is in general impossible
in plain models of multi-party computation when the majority
can be corrupted. This was ﬁrst observed by Cleve [24]
and later extended in subsequent papers [8]. Assuming a
TABLE III
Additional theoretical results for fair MPC with public deposits. The
table assumes that N parties wish to securely compute 1 bit of output that
will be revealed to all parties at the end. For collateral, we assume that each
aborting party must pay all honest parties 1 unit of currency.
claim-or-refund [17] multi-lock [40]
On-chain cost
# rounds
Total collateral
O(N 2)
O(N )
O(N 2)
O(N 2)
O(1)
O(N 2)
generic
blockchain
O(N)
O(1)
O(N2)
blockchain trusted for correctness and availability (but not
for privacy), an interesting notion of fairness which we refer
to as “ﬁnancial fairness” can be attained as shown by recent
works [7], [17], [40]. In particular, the blockchain can ﬁnan-
cially penalize aborting parties by conﬁscating their deposits.
Earlier works in this space [7], [17], [40], [50] focus on
protocols that retroﬁt the artifacts of Bitcoin’s limited scripting
language. Speciﬁcally, a few works use Bitcoin’s scripting
language to construct intermediate abstractions such as “claim-
or-refund” [17] or “multi-lock” [40], and build atop these
abstractions to construct protocols. Table VII shows that by
assuming a generic blockchain model where the blockchain
can run Turing-complete programs, we can improve the efﬁ-
ciency of ﬁnancially fair MPC protocols.
Fair MPC with private deposits. We further illustrate how to
perform ﬁnancially fair MPC using private deposits, i.e., where
the amount of deposits cannot be observed by the public. The
formal deﬁnitions, constructions, and proofs are supplied in
the online version [37].
ACKNOWLEDGMENTS
We gratefully acknowledge Jonathan Katz, Rafael Pass,
and abhi shelat for helpful technical discussions about the
zero-knowledge proof constructions. We also acknowledge
Ari Juels and Dawn Song for general discussions about
cryptocurrency smart contracts. This research is partially sup-
ported by NSF grants CNS-1314857, CNS-1445887, CNS-
1518765, CNS-1514261, CNS-1526950, a Sloan Fellowship,
three Google Research Awards, Yahoo! Labs through the
Faculty Research Engagement Program (FREP) and a NIST
award.
REFERENCES
[1] http://koinify.com.
[2] Amazon ec2 pricing. http://aws.amazon.com/ec2/pricing/.
[3] Augur. http://www.augur.net/.
[4] bitoinj. https://bitcoinj.github.io/.
[5] The rise and rise of bitcoin. Documentary.
[6] Skuchain. http://www.skuchain.com/.
[7] M. Andrychowicz, S. Dziembowski, D. Malinowski, and L. Mazurek.
Secure Multiparty Computations on Bitcoin. In S&P, 2013.
[8] G. Asharov, A. Beimel, N. Makriyannis, and E. Omri. Complete
characterization of fairness in secure two-party computation of boolean
functions. In TCC, 2015.
[9] M. Bagnoli and B. L. Lipman.
Provision of public goods: Fully
implementing the core through private contributions. The Review of
Economic Studies, 1989.
853853
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:16:41 UTC from IEEE Xplore.  Restrictions apply. 
[41] C. Liu, X. S. Wang, K. Nayak, Y. Huang, and E. Shi. ObliVM: A
programming framework for secure computation. In S&P, 2015.
[42] S. Meiklejohn, M. Pomarole, G. Jordan, K. Levchenko, D. McCoy, G. M.
Voelker, and S. Savage. A ﬁstful of bitcoins: characterizing payments
among men with no names. In IMC, 2013.
[43] I. Miers, C. Garman, M. Green, and A. D. Rubin. Zerocoin: Anonymous
Distributed E-Cash from Bitcoin. In S&P, 2013.
[44] A. Miller, M. Hicks, J. Katz, and E. Shi. Authenticated data structures,
generically. In POPL, 2014.
[45] A. Miller and J. J. LaViola Jr. Anonymous Byzantine Consensus from
Moderately-Hard Puzzles: A Model for Bitcoin, 2014.
[46] M. S. Miller, C. Morningstar, and B. Frantz. Capability-based ﬁnancial
instruments. In FC, 2001.
[47] N. Mouha, B. Mennink, A. Van Herrewege, D. Watanabe, B. Preneel,
and I. Verbauwhede. Chaskey: An efﬁcient mac algorithm for 32-bit
microcontrollers. In Selected Areas in Cryptography–SAC 2014, pages
306–323. Springer, 2014.
[48] S. Nakamoto. Bitcoin: A Peer-to-Peer Electronic Cash System. http:
//bitcoin.org/bitcoin.pdf, 2009.
practical veriﬁable computation. In S&P, 2013.
[50] R. Pass and abhi shelat. Micropayments for peer-to-peer currencies. In
CCS, 2015.
[51] A. Rastogi, M. A. Hammer, and M. Hicks. Wysteria: A programming
In S&P,
language for generic, mixed-mode multiparty computations.
2014.
[52] D. Ron and A. Shamir. Quantitative Analysis of the Full Bitcoin
Transaction Graph. In FC, 2013.
[53] N. Szabo. Formalizing and securing relationships on public networks.
First Monday, 1997.
[54] N. van Saberhagen. Cryptonote v 2.0. https://goo.gl/kfojVZ, 2013.
[55] W. Vickrey.
Counterspeculation, auctions, and competitive sealed
tenders. Journal of ﬁnance, 1961.
[56] R. S. Wahby, S. T. V. Setty, Z. Ren, A. J. Blumberg, and M. Walﬁsh.
Efﬁcient RAM and control ﬂow in veriﬁable outsourced computation.
In NDSS, 2015.
[57] G. Wood. Ethereum: A secure decentralized transaction ledger. http:
//gavwood.com/paper.pdf.
[58] L. Zheng, S. Chong, A. C. Myers, and S. Zdancewic. Using replication
and partitioning to build secure distributed systems. In S&P, 2003.
[59] G. Zyskind, O. Nathan, and A. Pentland.
Enigma: Decentralized
computation platform with guaranteed privacy.
[10] R. Beaulieu, D. Shors, J. Smith, S. Treatman-Clark, B. Weeks, and
L. Wingers. The simon and speck families of lightweight block ciphers.
http://ia.cr/2013/404.
[11] E. Ben-Sasson, A. Chiesa, C. Garman, M. Green, I. Miers, E. Tromer,
and M. Virza. Zerocash: Decentralized anonymous payments from
Bitcoin. In S&P, 2014.
[12] E. Ben-Sasson, A. Chiesa, D. Genkin, E. Tromer, and M. Virza. Snarks
for C: verifying program executions succinctly and in zero knowledge.
In CRYPTO, 2013.
[13] E. Ben-Sasson, A. Chiesa, M. Green, E. Tromer, and M. Virza. Secure
sampling of public parameters for succinct zero knowledge proofs. In
S&P, 2015.
[14] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. Scalable zero
knowledge via cycles of elliptic curves. In CRYPTO, 2014.
[15] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. Succinct non-
interactive zero knowledge for a von neumann architecture. In Security,
2014.
[16] E. Ben-Sasson and M. Sudan. Short pcps with polylog query complexity.
SIAM J. Comput., 2008.
Protocols. In CRYPTO, 2014.
[18] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer. Recursive compo-
sition and bootstrapping for snarks and proof-carrying data. In STOC,
2013.
[19] D. Bogdanov, S. Laur, and J. Willemson. Sharemind: A Framework for
Fast Privacy-Preserving Computations. In ESORICS. 2008.
[20] J. Bonneau, A. Miller, J. Clark, A. Narayanan, J. A. Kroll, and
E. W. Felten. Research Perspectives and Challenges for Bitcoin and
Cryptocurrencies. In S&P, 2015.
[21] R. Canetti. Universally composable security: A new paradigm for
cryptographic protocols. In FOCS, 2001.
[22] R. Canetti. Universally composable signature, certiﬁcation, and authen-
tication. In CSF, 2004.
[23] R. Canetti, Y. Dodis, R. Pass, and S. Walﬁsh. Universally composable
security with global setup. In TCC. 2007.
[24] R. Cleve. Limits on the security of coin ﬂips when half the processors
are faulty. In STOC, 1986.
[25] C. Costello, C. Fournet, J. Howell, M. Kohlweiss, B. Kreuter,
M. Naehrig, B. Parno, and S. Zahur. Geppetto: Versatile veriﬁable
computation. In S & P, 2015.
[26] G. Danezis, C. Fournet, M. Kohlweiss, and B. Parno. Pinocchio Coin:
In
building Zerocoin from a succinct pairing-based proof system.
PETShop, 2013.
[27] C. Decker and R. Wattenhofer. Bitcoin transaction malleability and
mtgox. In ESORICS. Springer, 2014.
[28] A. K. R. Dermody and O. Slama. Counterparty announcement. https:
//bitcointalk.org/index.php?topic=395761.0.
[29] I. Eyal and E. G. Sirer. Majority is not enough: Bitcoin mining is
vulnerable. In FC, 2014.
[30] C. Fournet, M. Kohlweiss, G. Danezis, and Z. Luo. Zql: A compiler for
privacy-preserving data processing. In USENIX Security, 2013.
[31] M. Fredrikson and B. Livshits. Zø: An optimizing distributing zero-
knowledge compiler. In USENIX Security, 2014.
[32] J. A. Garay, A. Kiayias, and N. Leonardos. The bitcoin backbone
protocol: Analysis and applications. In Eurocrypt, 2015.
[33] R. Gennaro, C. Gentry, B. Parno, and M. Raykova. Quadratic span
programs and succinct NIZKs without PCPs. In Eurocrypt, 2013.
[34] E. Heilman, A. Kendler, A. Zohar, and S. Goldberg. Eclipse attacks on
bitcoin’s peer-to-peer network. In USENIX Security, 2015.
[35] A. Juels, A. Kosba, and E. Shi. The ring of gyges: Using smart contracts
for crime. Manuscript, 2015.
[36] A. Kiayias, H.-S. Zhou, and V. Zikas. Fair and robust multi-party
computation using a global transaction ledger. http://ia.cr/2015/574.
[37] A. Kosba, A. Miller, E. Shi, Z. Wen, and C. Papamanthou. Hawk:
The blockchain model of cryptography and privacy-preserving smart
contracts. http://ia.cr/2015/675.
[38] A. Kosba, Z. Zhao, A. Miller, H. Chan, C. Papamanthou, R. Pass,
abhi shelat, and E. Shi. How to use snarks in universally composable
protocols. https://eprint.iacr.org/2015/1093, 2015.
[39] B. Kreuter, B. Mood, A. Shelat, and K. Butler. PCF: A portable circuit
format for scalable two-party secure computation. In Security, 2013.
[40] R. Kumaresan and I. Bentov. How to Use Bitcoin to Incentivize Correct
Computations. In CCS, 2014.
[17] I. Bentov and R. Kumaresan. How to Use Bitcoin to Design Fair
[49] B. Parno, C. Gentry, J. Howell, and M. Raykova. Pinocchio: Nearly
APPENDIX A
FREQUENTLY ASKED QUESTIONS
we address frequently asked questions. Some of this con-
tent repeats what is already stated earlier, but we hope that
addressing these points again in a centralized section will help
reiterate some important points that may be missed by a reader.
A. Motivational
“How does Hawk’s programming model differ from
Ethereum?” Our high-level approach may be superior than
Ethereum: Ethereum’s language deﬁnes the blockchain pro-
gram, where Hawk allows the programmer to write a single
global program, and Hawk auto-generates not only the block-
chain program, but also the protocols for users.
“Why not spin off the formal blockchain modeling into
a separate paper?” The blockchain formal model could be
presented on its own, but we gain evidence of its usefulness
by implementing it and applying it to interesting practical
examples. Likewise our system implementation beneﬁts from
the formalism because we can use our framework to provide
provable security.
854854
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:16:41 UTC from IEEE Xplore.  Restrictions apply. 
B. Technical
“SNARKs do not offer simulation extractability required
for UC.” See Section V-A as well as Kosba et al. [38].
SNARK’s common reference string. See discussions in
Section V-B.
“Why are the recipient pseudonyms P1 and P2 revealed
to the adversary? And what about Zerocash’s persistent
addresses feature?” See discussions in Section IV-C.
“Isn’t the manager a trusted-third party?” No, our man-
ager is not a trusted third party. As we mention upfront
in Sections I-A and I-B, the manager need not be trusted
for correctness and input independence. Due to our use of
zero-knowledge proofs, if the manager deviates from correct
behavior, it will get caught.
Further, each contract instance can choose its own manager,