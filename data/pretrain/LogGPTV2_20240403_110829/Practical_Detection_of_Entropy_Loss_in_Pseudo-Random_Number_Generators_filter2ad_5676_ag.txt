(I1,··· , Iqr) $← ({0, 1}p)qr;
S
i ← 1;
$← {0, 1}
b
proc. ﬁnalize(b∗)
IF b = b∗ RETURN 1
ELSE RETURN 0
proc. getinput
OUTPUT Ii
proc. setinput(I∗)
Ii ← I∗
proc. one-refresh
S ← refresh(S, Ii) ;
i ← i + 1
proc. get-state
OUTPUT S
proc. next-ror
(S0, R0) ← next(S)
(S1, R1) $← {0, 1}‘
OUTPUT (Sb, Rb)
Figure 3.1 – Procedures for Security Games DCA, IBA, SCA
To formalize the security game, we use the procedures described in Figure 3.1. The procedure
initialize allows challenger to set the internal state S of the generator, to generate a sequence of
random inputs (I1,··· , Iqr) and to generate the Boolean parameter b used to challenge adversary
A. After all oracle queries, adversary A outputs a bit b∗, given as input to the procedure ﬁnalize,
which is used by the challenger to compare the response of A to the challenge bit b.
We formalize DCA, IBA and SCA as follow:
• To formalize DCA, we use the procedure named next-ror. This procedure challenges A
on its capability to distinguish the output of the generator from random, where the real
output (R0) of the generator is obtained with a call to algorithm next and the random
string (R1) is generated by the challenger.
• To formalize IBA, we use the procedures named getinput, setinput and one-refresh: proce-
dure getinput allows A to get access to the current input I, procedure setinput allows A to
set the current input to a chosen value I∗. Finally, procedure one-refresh allows challenger
to update the current internal state S with algorithm refresh applied with the current
input I.
• To formalize SCA, we use the procedure named get-state. This procedure gives A access
to the current value of the internal state S.
The security of a pseudo-random number generator with input is given in Deﬁnition 16.
Deﬁnition 16 (Security of a pseudo-random number generator with input [KSWH98,Gut98]).
A pseudo-random number generator with input (refresh, next) is called (t, ε)-secure against Di-
rect Cryptanalytic Attack (resp. Input-Based Attack or State Compromise Attack), if for any
adversary A running in time at most t, the advantage of A in game DCA, (resp. IBA, SCA) is
at most ε, where:
• DCA is the restricted game where A is only allowed to make calls to next-ror.
• IBA is the restricted game where A is not allowed to make any calls to get-state, and is
allowed to make calls to getinput, setinput and next-ror.
• SCA is the restricted game where A is not allowed to make calls to getinput or setinput
and is allowed to make calls to get-state and next-ror.
Comparison Between Notions. Security game DCA is similar to the security game PR.
However, these two security notions can not be compared, as they are not based on the same
deﬁnition of pseudo-random number generator. Note that if one drops procedure get-state in
the security game SCA, we obtain security game DCA and if one drops procedures getinput and
setinput in the security game IBA, we also obtain security game DCA.
— 30 —
3.3. Security Model From [BY03]
3.3 Security Model From [BY03]
3.3.1 Description
In 2003, Bellare and Yee [BY03] generalized the notion of standard pseudo-random number
generators (Deﬁnition 8) where the maximal number of outputs the pseudo-random number
generator is allowed to produce (named qn hereafter) is a parameter of the generator. This
notion is formalized in Deﬁnition 17 and illustrated in Figure 3.2.
key
S0
next
S1
R1
next
. . .
next
Sqn
Rqn
Figure 3.2 – Stateful Pseudo-Random Number Generator [BY03]
Deﬁnition 17 (Stateful Pseudo-Random Number Generator [BY03]). A stateful pseudo-random
number generator is a couple of algorithm (key, next) and an integer qn, where key is a probabilis-
tic algorithm that takes no input and outputs an initial state S ∈ {0, 1}n, next is a deterministic
algorithm that, given the current state S, outputs a pair (S0, R) ← next(S) where S0 is the new
state and R ∈ {0, 1}‘ is the output and qn is the maximal number of outputs the pseudo-random
number generator is allowed to produce.
Bellare and Yee proposed a new security property where a stateful pseudo-random number gen-
erator shall be designed so that it is infeasible to recover any information on previous states or
previous output blocks from the compromise of the current state. To formalize this property,
they proposed a dedicated security model where an adversary A chooses dynamically when to
compromise the current state S. After this compromise, all future outputs are compromised,
as they all deterministically depend on the compromised state, however, the expected security
property (named Forward Security) is that the past outputs are computationally indistinguish-
able from random.
The security game BY-FWD uses procedures described in Figure 3.3. The procedure initialize
sets the ﬁrst internal state S with a call to algorithm key and sets the random parameter b. After
all oracle queries, A outputs a bit b∗, given as input to the procedure ﬁnalize, which compares
the response of A to the challenge bit b. The other procedures are deﬁned below:
• Procedure next-ror: This procedure challenges A on its capability to distinguish the output
of the stateful pseudo-random number generator from random, where the real output (R0)
of the stateful pseudo-random number generator is obtained with a call to algorithm next
and the random string (R1) is picked uniformly at random by the challenger. Attacker A
responds to the challenge with a bit b∗.
• Procedure get-state: This procedure gives A access to the current value of the internal
state S.
Deﬁnition 18 (Forward Security of a Stateful Pseudo-Random Number Generator [BY03]). A
stateful pseudo-random number generator G = (key, next, qn) is called (T = (t, qn), ε)-forward-
secure, if for any adversary A running in time at most t, making at most qn calls to next-ror,
followed by one call to get-state, which is the last oracle call A is allowed to make, the advantage
of A in game BY-FWD is at most ε.
— 31 —
Chapter 3. Security Models for Pseudo-random Number Generators
proc. get-state
OUTPUT S
proc. next-ror
(S, R0) ← next(S)
$← {0, 1}‘
R1
OUTPUT Rb
proc. initialize
S
$← key;
$← {0, 1}
b
proc. ﬁnalize(b∗)
IF b = b∗ RETURN 1
ELSE RETURN 0
Figure 3.3 – Procedures in Security Game BY-FWD
Comparison with previous models. If one drops procedure get-state in the security game
BY-FWD, we come back to the usual security of a stateful standard pseudo-random number
generator SPR. As for the state compromise, BY-FWD has the same objective than the security
game SCA, from [KSWH98,Gut98]. However, the two security models can not be compared, as
one concerns pseudo-random number generator with input and the other stateful pseudo-random
number generator and they do not rely on the same deﬁnition. A stateful pseudo-random number
generator does not contain a refresh algorithm that would be used to periodically refresh its
internal state of twith new inputs. Similarly, there is no relation between BY-FWD and IBA.
3.3.2 A Secure Construction
Let G : {0, 1}n → {0, 1}n+‘ a (t, εG)-secure standard pseudo-random number generator, as
formalized in Deﬁnition 8. Consider the stateful pseudo-random number generator GEN, deﬁned
with the following algorithms:
• GEN.key : returns S
• GEN.next, on input S, returns (S0, R) = G(S).
$← {0, 1}n.
We prove the forward security of GEN by reduction to the standard security of G.
Theorem 4 (Security of GEN [BY03]). Let G : {0, 1}n → {0, 1}n+‘ be a (t, εG)-secure standard
pseudo-random number generator, n ≥ 1 be an integer and let GEN be the stateful generator
associated to G, as described above. Then GEN is ((t0, qn), 2qnεG)-backward secure, with t0 ≈ t.
proc. initialize()
$← key;
S
ctr ← 0;
$← {0, 1}
b
proc. ﬁnalize(b∗)
IF b = b∗ RETURN 1
ELSE RETURN 0
proc. initialize()
$← key;
S
ctr ← 0;
$← {0, 1}
b
proc. ﬁnalize(b∗)
IF b = b∗ RETURN 1
ELSE RETURN 0
proc. get-state
OUTPUT S
Game G1,i
proc. get-state
OUTPUT S
Game G2,i
$← {0, 1}‘;
proc. next-ror
ctr ← ctr + 1;
IF ctr ≤ i
R1
OUTPUT R1
ELSE
(S, R0) ← G(S);
OUTPUT R0
proc. next-ror
ctr ← ctr + 1;
IF ctr ≤ i
(S, R0) ← G(S);
$← {0, 1}‘
R1
OUTPUT R1
Figure 3.4 – Reduction to the Standard Security for BY-FWD
— 32 —
3.3. Security Model From [BY03]
Proof. We adapt the proof from [BY03] in the game playing framework presented in Section 2.4.
Consider two sequences of hybrid security games where G0 is the initial forward security game
BY-FWD, games G1,i are modiﬁcations of game G0 and games G2,i are modiﬁcations of game
G1,qn, for i = 1,··· n, all described in Figure 3.4. The diﬀerences between G0 and G1,i and
between G1,qn and G2,i are explained below:
in game G1,i, procedure initialize is diﬀerent from game
Diﬀerences Between G0 and G1,i:
G0: the challenger sets a new parameter ctr to 0. Procedure next-ror is diﬀerent from G0: ctr is
incremented and if ctr ≤ i, the challenger generates a random output R1 and returns it to A. If
ctr > i, the challenger behaves as in G0.
Diﬀerences Between G1,qn and G2,i: in game G2,i, procedure initialize also sets a new param-
eter ctr to 0, as in G1,i. Procedure next-ror behaves as follow: ctr is incremented and if ctr ≤ i,
the challenger generates the real output couple (S, R0) ← next(S) (this call is used to update
the internal state), then for any value of ctr, a random output R1 is generated and sent to A.
Note that Pr[G0 = 0] = Pr[G1,0 = 0], Pr[G1,qn = 1] = Pr[G2,0 = 1], Pr[G0 = 1] = Pr[G2,qn = 1].
We construct an adversary A0 with advantage εG in game PR, whose objective is to distinguish
between G1,i and G1,i+1 and between G2,i and G2,i+1, for i = 0,··· , qn − 1.
First consider the distance between G1,i and G1,i+1. Consider an adversary A in both games,
that will be used by A0 as a subroutine. The challenger of A0 generates a random state S0 and
a random bit b0, then it generates a couple (S0
1) and
b) to A0. Then A0 challenges A in game G1,i: A0 generates a random bit b and
sends (S0
initializes a counter ctr to 0. Following, A0 responds to oracle queries of A in game G1,i. It
increments ctr and:
0) = GEN(S0), a random couple (S0
0, R0
1, R0
b, R0
• If ctr < i, then A0 generates a random sample R1 and sends it to A.
• If ctr ≥ i, then A0 sets S0 = S0
b, computes the successive couples (S0, R0) ← next(S0) and
sends the output R0 to A.
• Finally, it responds to the get-state query with the last calculated state S0.
Then A answers the bit b∗ to A0 and A0 responds to its challenger the bit b0∗ = 1 if b∗ = b and
the bit b0∗ = 0 elsewhere. Then if b0 = 0, then A0 exactly simulates game G1,i, while if b0 = 1,
then A0 simulates game G1,i+1. Therefore the distance between games G1,i and G1,i+1 is bounded
by εG.
Similarly, consider the distance between G2,i and G2,i+1. The challenger of A0 generates a random
state S0 and a random bit b0, then it generates a couple (S0
0) = GEN(S0), a random couple
b) to A0. Then A0 challenges A in game G2,i: A0 generates a random
(S0
b, R0
bit b and initializes a counter ctr to 0. Following, A0 responds to oracle queries of A in game
G2,i. It increments ctr and:
1) and sends (S0
0, R0
1, R0
• If ctr < i, then A0 sets S0 = S0
b, computes the successive couples (S0, R0) ← next(S0),
generates a random sample R1 and sends it to A.
• If ctr ≥ i, then A0 generates a random sample R1 and sends it to A.
• Finally, it responds to the get-state query with the last calculated state S0.
Then A answers the bit b∗ to A0 and A0 responds to its challenger the bit b0∗ = 1 if b∗ = b and
the bit b0∗ = 0 elsewhere. Then if b0 = 0, then A0 exactly simulates game G2,i, while if b0 = 1,
then A0 simulates game G2,i+1. Therefore the distance between games G2,i and G2,i+1 is bounded
by εG.
Finally, the above reductions show that | Pr[G0 = 0] − Pr][G0 = 1] ≤ 2qnεG.
— 33 —
Chapter 3. Security Models for Pseudo-random Number Generators
3.4 Security Model from [DHY02]
3.4.1 Description
Desai, Hevia and Yin [DHY02] proposed a security model for pseudo-random number generator
with input where the internal state is split into two parts: a ﬁrst part named K (that they
name the key) and second part named S (that they name the state). In their model, a pseudo-
random number generator with input is a stateful and iterative algorithm, that at each invocation
produces some output bits as a function of the current value of K and S, in addition to another
auxiliary input I, then updates the state S, and then deletes the old one. They proposed
diﬀerent security properties, that capture the potential compromise of the state S, the key K
or the auxiliary input I. The generator operations are illustrated in Figure 3.5, in accordance
with Deﬁnition 19.
K
I0
S0
key
next