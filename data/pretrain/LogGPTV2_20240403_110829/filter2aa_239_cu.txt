2．调试器符号
在调试过程中，经常需要查看变量的值，这时使用的是它们在源代码中的名称。问题
是可执行代码一般不包含这些名称——编译器用内存地址代替了变量名称。.NET在一定
程度上改变了这种情况，使程序集中的某些项以名称的形式存储，但是这只适用于少量的
项（例如公有类和方法），而且这些名称在JIT编译程序集后也仍然会被移除。如果让调
试器显示变量HeightInInches的值，但是编译器在查看可执行代码时只看到了地址，而没
有看到任何对名称HeightInInches的引用，自然就得不到期望的结果。
因此，为了正确地调试，需要在可执行文件中提供一些额外的调试信息。这些信息包
含变量名和代码行信息，允许调试器确定可执行机器汇编语言指令与源代码中的哪些指令
对应。但是，不应该在发布版本中包含这些信息，这既是出于专利考虑（提供调试信息会
方便其他人反汇编代码），也是因为包含调试信息会增加可执行文件的大小。
3．其他源代码调试指令
一个相关问题是，在调试时，程序经常包含一些额外的代码行，用于显示关键的调试
信息。显然，在发布软件前，需要从可执行代码中彻底删除这些相关指令。手动删除是可
以的，但是如果能以某种方式标记这些语句，让编译器在编译发布代码时自动忽略它们，
不是更方便吗？本书的第I部分提到，在C#中，定义合适的预处理器指令，再结合使用
Conditional特性（所谓的条件编译），就可以实现这种操作。
所有这些因素综合到一起，决定了几乎所有商业软件的编译调试方式与最终交付产品
的编译方式是稍有区别的。Visual Studio能够处理这种区别，因为Visual Studio在编译代码
时，会存储应传递给编译器的所有编译选项信息。为了支持不同类型的构建版本，Visual
Studio需要存储多组编译选项。这些不同的版本信息集合称为配置。在创建项目时，
Visual Studio会自动提供两种配置：调试和发布。
● 调试： 这种配置通常指定编译器不优化编译过程，可执行文件应该包含额外的调
试信息，编译器假定调试预处理器指令Debug是存在的，除非源代码中显式使用
了#undefined Debug指令。
● 发布： 这种配置指定编译器应优化编译过程，可执行文件不应包含额外的调试信
息，编译器不应假定源代码包含特定的预处理器符号。
还可以定义自己的配置，例如设置软件的专业级版本和企业级版本。过去，由于
Windows 
NT支持Unicode字符编码，但Windows 
95不支持，因此C++项目经常使用
Unicode配置和MBCS（Multi-Byte Character Set，多字节字符集）配置。
17.4.3 选择配置
Visual Studio存储了多个配置的细节，那么在准备生成一个项目时，如何决定使用哪
个配置？答案是，项目总是有一个活动的配置，当要求Visual Studio生成项目时，就使用
这个配置。注意，活动配置是针对每个项目、而不是每个解决方案设置的。
在创建项目时，默认情况下Debug配置是活动配置。如果想修改活动配置，可以单击
Build菜单，选择Configuration Manager菜单项。在Visual Studio主工具栏的下拉菜单中也
可以找到此选项。
17.4.4 编辑配置
除了选择活动配置外，还可以查看及编辑配置。为此，在Solution 
Explorer中选择相
关的项目，然后选择Project菜单中的Properties菜单项，这会打开一个复杂的对话框。打开
该对话框的另一个方法是，在Solution 
Explorer中右击项目名称，然后从上下文菜单中选
择Properties。
这个对话框包含多个选项卡，用于选择要查看或编辑的常规属性类别。由于篇幅原
因，本节不展示所有的属性类别，只介绍其中两个最重要的选项卡。
根据应用程序是MSBuild还是CLI，可用的选项完全不同。首先，图17-34显示了WPF
应用程序的属性，其中显示了可用属性的选项卡式视图。这个屏幕截图显示了常规应用程
序设置。
图17-34
在Application选项卡中，可以选择要生成的程序集的名称及类型。可选的类型包括
Console Application、Windows Application和Class Library。当然，如果愿意，还可以修改
程序集的类型，但是，为什么不在一开始就让Visual Studio生成正确类型的项目呢？
图17-35显示了基于CLI的应用程序的配置。还可以看到Application设置，但选项仅限
于默认名称空间名和运行库部分。在这个屏幕图中，选择了RC 2的特定版本。
图17-35
图17-36显示了WPF应用程序的生成配置属性。注意，在对话框顶部的下拉列表中可
以指定要查看的配置类型。对于Debug配置，编译器假定已经定义了DEBUG和TRACE预
处理器符号。此外，编译器不会优化代码，而且会生成额外的调试信息。
图17-36
图17-37显示了CLI项目的构建配置属性。在这里可以选择构建输出。TypeScript设置
只与包含TypeScript代码的应用程序相关。TypeScript编译为JavaScript。
图17-37
17.5 调试代码
现在，已经准备好运行和调试应用程序了。在C#中调试应用程序与早于.NET的语言
一样，涉及的主要技巧是设置断点，使用断点检查在代码执行到特定位置时发生了什么情
况。
17.5.1 设置断点
在Visual Studio中，可在实际执行的任何代码行上设置断点。最简单的方法是在代码
编辑器中单击文档窗口最左边的灰色区域，或者在选中合适的行后按F9键。这会在该代
码行上设置一个断点，当程序执行到该行时将暂停执行，并把控制权转交给调试器。与
Visual 
Studio以前的版本一样，断点由代码编辑器中代码行左边的红色圆圈表示。Visual
Studio还使用不同的颜色高亮显示该行代码的文本和背景。再次单击红色圆圈将删除断
点。
如果对于特定的问题，每次在特定的代码行暂停执行不足以解决该问题，则还可以设
置条件断点。为此，选择Debug | Windows | Breakpoints。在打开的对话框中，输入想要设
置的断点的细节。例如，在该对话框中可以执行以下操作：
● 指定只有遇到断点超过一定次数时，执行才应该中断。
● 指定只有遇到代码行达到一定次数时，才激活断点。例如，执行代码行每达到20次
时就激活断点。这对于调试大型循环很有帮助。
● 指定只有遇到变量满足一定条件时，执行才应该中断。此时，变量的值将被监视，
一旦该值发生变化，断点就会触发。但是，这个选项可能会显著减慢代码的执
行。在每行代码执行后就检查某个变量的值是否发生变化，会增加大量的处理器
时间。
使用该对话框还可以导出和导入断点设置，如果根据不同的调试场景想要使用不同的
断点设置，那么这些选项十分有用。另外，在该对话框中还可以存储调试设置。
17.5.2 使用数据提示和调试器可视化工具
在断点触发后，通常想要查看变量的值。最简单的方法是在代码编辑器中，在变量名
的上方悬停光标。这将弹出一个很小的数据提示框，其中显示了该变量的值。也可以展开
数据提示框来查看更多细节，如图17-38所示。
图17-38
数据提示中的某些值会带有一个放大镜图标。单击这个放大镜图标时，根据数据的类
型，会显示一个或多个使用调试器可视化工具（debugger visualizer）的选项。对于WPF控
件，使用WPF Visualizer可以更详细地查看控件，如图17-39所示。在此可视化工具中，可
以使用可视化树查看运行期间的变量，包括所有的实际属性设置。通过该可视化树可以预
览在该树中选择的元素。
图17-39
如图17-40所示的JSON 
Visualizer可显示JSON内容。还有其他许多可视化工具，如
HTML、XML和Text可视化工具。
图17-40
17.5.3 Live Visual Tree
Visual Studio 2015为基于XAML的应用程序提供了一个新特性：Live Visual Tree。调
试UWP和WPF应用程序时，可以打开Live 
Visual 
Tree 
（见图17-41）：选择Debug 
|
Windows | Live Visual Tree，就会在Live Property Explorer中打开XAML元素的实时树（包
括其属性）。使用此窗口，可以单击Selection按钮，在UI中选择一个元素，在树中查看它
的元素。在Live Property Explorer中，可以直接改变属性，看看这种改变在运行着的应用
程序上的结果。
图17-41
17.5.4 监视和修改变量
有时候，需要连续查看变量的值。此时，可以使用Autos、Locals和Watch窗口检查变
量的内容。这3个窗口监视不同的变量：
● Autos——监视在程序执行过程中离断点最近的几个变量。
● Locals——监视在程序执行过程中当前断点所在方法内可访问的变量。
● 
Watch——监视在程序执行过程中显式指定名称的任何变量。可以把变量拖放到
Watch窗口中。
只有当使用调试器运行程序时，这些窗口才是可见的。如果看不到它们，则选择
Debug |Windows，然后根据需要选择菜单项。考虑到可能要监视的内容过多，需要进行分
组，Watch窗口提供了4个不同的窗口。在这些窗口中都可以查看和修改变量的值，所以
不必离开调试器就可以尝试改变程序的不同路径。图17-42显示了Locals窗口。
图17-42
另外，还有一个Immediate窗口，虽然它与刚才讨论的其他几个窗口没有直接关系，
但仍然是一个可以监视和修改变量的重要窗口。在该窗口中可以查看变量的值。还可以在
此窗口中输入并运行代码，这样在调试过程中进行测试时就能够关注细节，试用方法，以
及动态修改调试运行。
17.5.5 异常
在准备交付应用程序时，异常是很好的帮手，它们确保错误条件得到了恰当的处理。
如果正确使用，异常就能够确保用户不会看到技术性或者恼人的对话框。但是，在调试应
用程序时，异常就没有那么令人愉快了。它们的问题在于两个方面：
● 如果在调试过程中发生异常，通常不希望自动处理它们，特别是有时自动处理异常
意味着应用程序将终止。调试器应能帮助确定为什么会发生异常。当然，如果编
写了优良、健壮的防御性代码，程序将能够自动处理几乎任何事情，包括想要检
测的bug！
● 
如果发生了某个异常，.NET运行库就会尝试搜索该异常的处理程序，即使没有为
该异常编写处理程序。没有找到异常时，它会终止程序。这时没有了调用栈，意
味着所有的变量将超出作用域，所以将无法查看任何变量的值。
当然，可以在catch块中设置断点，但是这常常没有多大帮助，因为按照定义，当遇
到catch块时，执行流已经退出了对应的try块。这意味着想要通过检查变量值来确定问题
所在时，那些变量已经超出了作用域。甚至不能通过查看栈跟踪来找出在遇到throw语句
时执行的方法，因为控制流已经离开了该方法。在throw语句处设置断点显然可以解决这
个问题，但是对于防御性编码，代码中将存在许多throw语句。如何判断哪条throw语句抛
出了该异常？
Visual Studio为这种问题提供了一个很好的解决方法。可以配置调试器中断处的异常
类型。这在菜单Debug | Windows | Exception Settings中配置。如图17-43所示，在该窗口中
可以指定抛出异常后执行什么操作。例如，可以选择继续执行，或者停止执行并启动调试
——此时程序将停止执行，调试器将在throw语句位置启动。
图17-43
这个对话框的强大之处在于允许根据所抛出异常的类型选择相应的操作。例如，可以
配置为在遇到.NET基类抛出的任何异常时进入调试器，但是对于其他异常类型则不进入
调试器。
Visual Studio知道.NET基类中的所有异常类，以及许多可在.NET环境外抛出的异常。
Visual Studio不会自动知道用户编写的任何自定义异常类，但是可以把自定义异常类手动
添加到Visual Studio的异常列表中，并指定哪些自定义异常类应该导致执行立即停止。为
此，只需要单击Add按钮（在列表中选择一个顶层节点时，将启用该按钮），并输入自定
义异常类的名称即可。
17.5.6 多线程
Visual Studio为调试多线程程序提供了出色的支持。在调试多线程程序时，必须理解
在调试器中运行与不在调试器中运行时，程序的行为会发生变化。遇到断点时，Visual
Studio会停止程序的所有线程，所以此时有机会查看所有线程的当前状态。为了在不同的
线程间切换，可以启用Debug 
Location工具栏。这个工具栏有一个针对所有进程的组合
框，还有另外一个组合框，用于当前运行的应用程序的所有线程。当选择一个不同的线程
时，可以看到该线程在哪一行代码暂停，以及当前可在其他线程中访问的变量。Parallel
Tasks窗口（如图17-44所示）显示了所有正在运行的任务，包括这些任务的状态、位置、
任务名、任务使用的当前线程、所在的应用程序域以及进程标识符。该窗口还显示了不同
的线程在什么时候彼此阻塞，导致死锁。
图17-44
图17-45显示了Parallel Stacks窗口，该窗口以分层视图的形式显示了不同的线程或任
务（取决于所选项）。单击任务或线程可跳转到对应的源代码。
图17-45
17.6 重构工具
许多开发人员在开发应用程序时首先完成功能，然后修改应用程序，使它们更易于管
理和阅读。这个过程称为重构。重构过程包括修改代码来实现更好的性能和可读性，提供
类型安全，以及确保应用程序符合标准的面向对象编程实践。更新应用程序时，也需要重
构。
Visual Studio 2015的C#环境包含一组重构工具，位于Visual Studio菜单的Refactoring
选项中。为了演示这些工具，在Visual Studio中创建一个新类Car：
    public class Car
    {
      public string color;
      public string doors;
      public int Go()
      {
        int speedMph = 100;
        return speedMph;
      }
    }
现在，假设为了进行重构，需要对代码稍作修改，将变量color和door封装到公有
的.NET属性中。Visual Studio 2015的重构功能允许在文档窗口中简单地右击这两个属性，
然后选择Quick Actions，就会看到不同的重构选项，例如生成构造函数，来填充字段，或
者封装字段，如图17-46所示。
图17-46
在该对话框中可以提供属性的名称，然后单击Preview链接，或者直接接受更改。选
择封装字段的按钮时，代码将修改为如下所示：
      public class Car
      {
        private string color;
        public string Color
        {
          get { return color; }
          set { color = value; }
        }
        private string doors;
        public string Doors
        {
          get { return doors; }
          set { doors = value; }
        }
        public int Go()
        {
          int speedMph = 100;
          return speedMph;
        }
      }
可以看到，使用这些向导重构代码很简单，不仅是一页的代码，重构整个应用程序的
代码都一样简单。Visual Studio的重构工具还提供了以下功能：
● 重命名方法、局部变量、字段等
● 从选定代码中提取方法
● 基于一组已有的类型成员提取接口
● 将局部变量提升为参数
● 重命名参数或修改参数的顺序
Visual Studio 2015的重构工具是得到更整洁、可读性更好、结构更合理的代码的一种
优秀方法。
17.7 体系结构工具
在开始编写程序前，应该从体系结构的角度考虑解决方案，分析需求，然后定义解决
方案的体系结构。Visual Studio Ultimate 2015企业版提供了体系结构工具。
图17-47显示了在创建一个建模项目后的Add New Item对话框。使用该对话框中的选
项可创建UML用例图、组件图、类图、序列图和活动图。有不少图书专门介绍标准的
UML关系图，所以这里不讨论它们，而是重点介绍Microsoft提供的两种关系图：依赖项
关系图（或定向关系图文档）和层关系图。
图17-47
  注意： 如何创建和使用UML图在本书中未涉及。它们不是新内容，读者可能
已经很了解它们了。如果不了解，可以阅读介绍UML图的特点的几本书。它们的用法
在Visual Studio中并没有区别。
本节的重点仍是与体系结构工具和分析应用程序相关的Microsoft特定功能。特别是创
建代码地图、层图、使用诊断工具来配置应用程序、代码分析和代码度量。
17.7.1 代码地图
在代码地图中，可以查看程序集、类甚至类成员之间的依赖关系。图17-48显示了第
26章中Calculator示例的代码地图，该示例包含一个计算器宿主应用程序和几个类库，例
如协定程序集以及插件程序集SimpleCalculator、FuelEconomy和TemperatureConversion。
通过选择Architecture | Create Code Map for Solution，可以创建代码地图。这会分析解决方
案中的所有项目，在一个关系图中显示所有程序集，并在程序集之间绘制连线以显示依赖
关系。程序集之间的连线的粗细程度反映了依赖程度。程序集中包含了几个类型和类型的
成员，许多类型及其成员在其他程序集中使用。
图17-48
还可以更深入地查看依赖关系。图17-49显示了一个更详细的关系图，包括Calculator
程序集的类及它们的依赖关系。图中还显示了对CalculatorContract程序集的依赖。在更大
的关系图中，还可以缩放关系图的不同部分。
图17-49
还可以更进一步，显示字段、属性、方法、事件以及它们之间的依赖关系。
17.7.2 层关系图
层关系图与代码地图密切相关。在创建层关系图时，既可以使用依赖项关系图（或者
在Solution Explorer中选择程序集或类），也可以在进行任何开发前从头创建。
在分布式解决方案中可以使用不同的层定义客户端和服务器端，例如，将一个层用于
Windows应用程序，一个层用于服务，一个层用于数据访问库，或者让层基于程序集。层
中还可以包含其他层。
在如图17-50所示的层关系图中，主层包括Calculator UI、CalculatorUtils、Contracts和
AddIns。AddIns层中又包含FuelEconomy、TemperatureConversion和Calculator层。层旁边
显示的数字反映了链接到该层的项数。
图17-50
为了创建层关系图，选择Architecture | New UML or Layer Diagram | Layer Diagram，
这会创建一个空关系图。然后，使用工具箱或者Architecture Explorer，在这个空关系图中
添加层。Architecture Explorer包含一个Solution View和一个Class View，从中可以选择解
决方案中的所有项，并把它们添加到层关系图中。构建层关系图只需要选择项并添加到层
中。选择一个层，然后单击上下文菜单中的View 
Links，可打开如图17-51所示的Layer
Explorer，其中显示了选定层包含的所有项。
图17-51
在应用程序开发期间，可以通过验证层关系图来分析是否所有的依赖关系都正确。如
果某个层的依赖关系的方向相反，或者依赖一个错误的层，体系结构验证就会返回错误。
17.8 分析应用程序
前一节讨论的体系结构关系图（依赖项关系图和层关系图）并不只是在开始编码前考
虑的问题，实际上它们还可以帮助分析应用程序，保持应用程序的开发走在正确的轨道
上，确保不会生成错误的依赖关系。Visual Studio 2015提供了许多有用的工具来帮助分析
应用程序，提前解决应用程序中可能发生的问题。本节将讨论其中的一些分析工具。
与体系结构工具类似，分析工具也在Visual Studio 2015企业版中可用。
17.8.1 诊断工具
为了分析应用程序的完整运行，可以使用诊断工具。诊断工具用于确定调用了什么方