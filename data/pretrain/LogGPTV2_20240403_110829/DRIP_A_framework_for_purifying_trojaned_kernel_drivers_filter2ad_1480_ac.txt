43:
44:
45:
46:
47:
RECOVERCURRFUNCLIST()
if ISEMPTY(FuncStack) then
CurrContextGroup.status ⇐ TESTED
CurrFuncList ⇐ NULL
CurrFuncList ⇐ POPSTACK(FuncStack)
ASSERT(SIZE(CurrFuncList)=1)
CurrFuncList[0].status ⇐ CRITICAL
else
48: procedure RECOVERCURRFUNCLIST(void)
49:
50:
for all Func in CurrFuncList do
RESTOREFUNC(Func)
(cid:46) Recover CurrFuncList
(cid:46) Restore Invocation in Memory
pathname argument and protects its own malicious ﬁles from
being deleted. We highlight 3 function invocations in blue,
which are kmalloc, copy from user and kfree, in the function
body. If we remove these 3 function invocations together in one
Testing Cycle, it is safe and will not cause problem. But other
kernel API invocations located between these 3 invocations
may be marked as CRITICAL.
In this example, o unlink cannot be removed because it
is the function pointer to the original sys unlink. Removing
it can make deletion of ﬁles ineffective. This critical function
invocation splits the current Context Group and forces removal
of these 3 function invocations to occur in different Testing
Cycles. If we do not use reverse chronological order, we
will try to remove kmalloc ﬁrst and assign kbuf with a fake
address. The subsequent function copy from user will write to
an unsafe address and kfree will free a memory block that has
never been allocated. This will probably crash the system. Then
we will mistakenly mark kmalloc as CRITICAL, but in fact it is
not. If we remove backwards in the following order: kfree→
copy from user→ kmalloc, all 3 invocations will be safe to
remove. This greatly reduces the risk of mutual inﬂuences of
function invocations.
In order to accelerate the handling of failing cases, we
add two optimization techniques to handle different failing
scenarios:
1)
2)
Test Suite Halts in the Middle: Removal of some
function invocations will cause the test case to freeze
without progress. We handle this by setting a timer
and the time interval is estimated by proﬁling the
execution time of previous successful cases. If the
timer expires, we consider this Testing Cycle a failure
and proceed to execute the next one.
Test Suite Causes OS Crash and Rebooting: Removal
of a critical function invocation may cause OS crash
and rebooting. In this case we do not have to wait
for the timer to expire. Instead, we add rebooting
detection logic by checking whether the paging bit is
set in the control register. We can determine that it
is a failing case if the system is rebooting after we
remove certain invocations.
To eliminate kernel API invocations in the driver, we patch
them in the driver’s memory. The method of patching varies
according to platforms and ﬁle formats. For ELF under Linux,
the destination address of call instructions is unknown before
loading. The module loader resolves symbols of the kernel
API in the entries of the relocation section and ﬁxes up the
destination in the code section with the absolute address when
loading the kernel module. For Portable Executable (PE) under
Windows, it utilizes the import address table (IAT) to store
the absolute virtual addresses of kernel APIs. The contents
are populated when that driver is loaded into the system. The
kernel API invocations in PE drivers use two calling styles.
The ﬁrst one uses the indirect call generated by the compiler
and retrieves its destination address from IAT. The second one
makes a direct call to an indirect jump and the jump destination
is stored in the IAT. If the return value is not used by the
subsequent instructions or it is a void function, we can simply
replace the call or jmp instruction with a series of nops in
memory. If the return value is used later (e.g., as a predicate
condition) and can determine the control ﬂow, replacing the
instruction with nops will lead to an undeﬁned situation.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:46:27 UTC from IEEE Xplore.  Restrictions apply. 
As we have already recorded the return value of every
kernel API invocation in the proﬁling phase, we can replace the
calling instruction with a mov instruction that ﬁlls the return
value in the EAX register. This kind of replacement can be
applied to the ELF driver and the ﬁrst calling style of PE
drivers. For the second calling style of PE drivers, we replace
the indirect jump with ret to return to the original direct call
to eliminate this invocation.
The other issue we need to consider during memory patch-
ing is the calling convention of the kernel API. If the caller
is responsible for cleaning up the stack, no additional effort
is needed because push and pop operations are performed in
the same function. If the callee is responsible for cleaning
up the stack, the situation becomes more complicated. In this
scenario, arguments are pushed into stack by the caller and
the callee unwinds the stack before returning. We choose to
remove the push operations before the function invocation in
the caller to solve this problem. We can record the number of
stack bytes that need to be unwound. This is determined by
the 16-bit parameter of the last ret instruction in the kernel
function. We then trace back from the kernel API invocation
instruction to search for push instructions and replace these
instructions with nops.
If the patching operation is successful for the current
Testing Cycle, which means the function invocation is tested
to be UNNEC, we record all the modiﬁed content and the
address of this function invocation for the rewriting phase.
After writing new content
into the memory address of a
kernel API invocation, we mark this speciﬁc basic block as
a candidate for memory invalidation. When the snapshot is
reloaded in the next Testing Cycle and the emulator tries to
execute this basic block, we invalidate the cache of this basic
block and force the emulator to perform binary translation on
it because the instructions inside it have been modiﬁed and it
should execute the newly translated code.
D. Rewriting Phase
The last phase of DRIP’s driver puriﬁcation procedure
is to remove kernel API invocations marked as UNNEC in
the binary ﬁle. We have already tested and retrieved the list
of unnecessary API invocations and their addresses in the
memory from previous phases. The procedure of patching the
binary is similar to patching memory in the testing phase.
We need to map the loading addresses of API invocations to
their relative addresses inside the binary and apply the changes
recorded in the testing phase to code sections.
Finishing these steps is not enough for the puriﬁed driver to
work correctly. Every relocatable driver has its own relocation
table consisting of a list of pointers. These pointers point to
addresses in the binary that need to be ﬁxed up after the
driver is loaded into the system. If we remove the function
invocations whose addresses are included in the relocation
table, we also need to remove these relocation entries in the
relocation table. Otherwise the loader of the OS will still ﬁx
up the function address and cause memory corruption. Because
holes are not permitted in the relocation table for both ELF
and PE, we swap the value of each removed entry with the
value of last entry in the relocation table to ﬁll the hole and
adjust the table size in the header accordingly. For PE ﬁles,
we also need to calculate the new checksum value and write
it into its PE header, otherwise Windows will refuse to load
the driver with the wrong checksum.
After ﬁnishing all these steps, we generate a new relocat-
able binary as a puriﬁed driver and it can be loaded into the
system for execution.
E. DRIP Prototype
We have implemented a proof-of-concept prototype of
DRIP. The prototype is built as a component of QEMU. As a
full system emulator, QEMU dynamically translates the guest
VM’s code at the granularity of basic blocks and executes
them on the emulated CPU. Such a platform enables us to
perform binary analysis on the code region of drivers, intercept
dynamic control ﬂow, and patch the memory at runtime to test
effects of our kernel API invocation removal operations. In
addition to processor emulation, QEMU also provides a set
of emulated devices, which provides an alternative to verify
the correctness of test cases through mapping the high-level
program to low-level hardware events. For example, we can
simulate keystrokes in emulated hardware and capture the keys
in the test suite to test the keyboard driver.
To prove the generality of DRIP, We have tested the
prototype on two guest operating systems, Ubuntu 10.04 and
Windows XP SP22. We believe that it is easy to extend our
current system to support more operating systems of different
versions because DRIP does not rely on the semantics of a
guest VM. We support relocatable ﬁle formats for both PE
and ELF, which are standard formats for Windows and Linux
drivers.
IV. EVALUATION
In this section, we present the evaluation results for the
DRIP prototype in two aspects, effectiveness and performance.
The hardware conﬁguration of our testing platform is a Dell
OptiPlex 780 with Intel R(cid:13) CoreTM 2 Duo CPU E8400 3.00GHz
CPU and 4GB memory. We develop and run the DRIP system
on Ubuntu 11.10 (Linux kernel version 3.0.0) to generate the
puriﬁed driver. To prove that changes in the underlying infras-
tructure do not affect the functionality of puriﬁed drivers, we
use VMware Workstation 8.0 as the hypervisor and Windows 7
as the host operating system to perform evaluation on puriﬁed
drivers. We allocate 1GB memory for each guest VM. The
guest OSes are Ubuntu 10.04 (Linux kernel version 2.6.32)
and Windows XP SP2.
A. Evaluation of Effectiveness
In the effectiveness evaluation, we use trojaned drivers
infected by binary driver rewriting tools as input to DRIP
and generate the corresponding puriﬁed drivers. Then we
scrutinize the behavior of the generated driver manually to
validate that the malicious behavior has been eliminated and
the functionality of the benign parts of the driver and the kernel
are not impaired. We present ﬁve representative case studies
on drivers in different categories in detail and present other
results brieﬂy in Table I.
2We use Ubuntu 10.04 and Windows XP SP2 because the trojaned driver
samples we perform evaluation on do not support newer versions yet.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:46:27 UTC from IEEE Xplore.  Restrictions apply. 
Name
E1000+KBeast
E1000+DR
E1000+Adore-ng
E1000+Sebek
E1000+Redir
Kbdevents
Null+SSDT
Kbdclass+SSDT
E1000325+SSDT
Beep+Klog
E1000325+Klog
Platform
Infection Type
Linux
Module injection
Linux
Module injection
Linux
Module injection
Linux
Module injection
Linux
ERESI
Linux
Embedded
Windows
DaMouse
Windows
DaMouse
Windows
DaMouse
Binary Transformaion
Windows
Binary Transformation Windows
Puriﬁed
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
Note
E1000 NIC driver infected with KBeast as payload
Case Study I
E1000 NIC driver infected with Adore-ng 0.56 as payload
E1000 NIC driver infected with Sebek-lin26-3.2.0b as payload
Cast Study II
Case Study III
Null.sys infected by DaMouse
Case Study IV
E1000325.sys infected by DaMouse
Case Study V
E1000325.sys infected with Klog as payload
TABLE I: Results of effectiveness evaluation against a spectrum of trojaned drivers
Case Study I: E1000 NIC driver with DR rootkit implanted
under Linux: In phrack issue 61 [3], truff described a driver
infection technique to hide the rootkit and ensure that it will
be reloaded after rebooting. The basic idea is to rename the
malicious function evil with init in the section .strtab to trick
the system to load it. It only applies to Linux kernel 2.4.x,
so it is no longer valid for the latest Linux kernel because
the module loading procedure has been changed in new kernel
version. From Linux Forum [5], coolq extended this approach
to Linux Kernel 2.6.x by modifying the module init function
entry in the relocation section .rel.gnu.linkonce.this module