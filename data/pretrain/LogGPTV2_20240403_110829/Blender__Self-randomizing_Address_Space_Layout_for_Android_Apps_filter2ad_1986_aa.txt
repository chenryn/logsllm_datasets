title:Blender: Self-randomizing Address Space Layout for Android Apps
author:Mingshen Sun and
John C. S. Lui and
Yajin Zhou
Blender: Self-randomizing Address Space
Layout for Android Apps
Mingshen Sun1(B), John C.S. Lui1, and Yajin Zhou2
1 The Chinese University of Hong Kong, Hong Kong, China
PI:EMAIL
2 Qihoo 360 Technology Co. Ltd., Beijing, China
Abstract. In this paper, we ﬁrst demonstrate that the newly intro-
duced Android RunTime (ART) in latest Android versions (Android
5.0 or above) exposes a new attack surface, namely, the “return-to-art”
(ret2art) attack. Unlike traditional return-to-library attacks, the ret2art
attack abuses Android framework APIs (e.g., the API to send SMS) as
payloads to conveniently perform malicious operations. This new attack
surface, along with the weakened ASLR implementation in the Android
system, makes the successful exploiting of vulnerable apps much easier.
To mitigate this threat and provide self-protection for Android apps,
we propose a user-level solution called Blender, which is able to self-
randomize address space layout for apps. Speciﬁcally, for an app using
our system, Blender randomly rearranges loaded libraries and Android
runtime executable code in the app’s process, achieving much higher
memory entropy compared with the vanilla app. Blender requires no
changes to the Android framework nor the underlying Linux kernel, thus
is a non-invasive and easy-to-deploy solution. Our evaluation shows that
Blender only incurs around 6 MB memory footprint increase for the
app with our system, and does not aﬀect other apps without our system.
It increases 0.3 s of app starting delay, and imposes negligible CPU and
battery overheads.
Keywords: Android · ROP · ASLR · Blender
1 Introduction
Due to the increasing functionalities of applications (apps for short) on mobile
devices, the security and privacy of apps become one major concern. For apps
running on the Android system, they are mainly written in Java. However, to
enhance compatibility and performance, developers often choose to use the native
development kit (NDK) to develop native libraries written in C/C++ and inte-
grate them in their apps. A recent study [14] showed that around 37 % of Android
apps contain at least one native library. These native libraries are not memory
safe and may suﬀer from memory corruption issues [4,5,8]. What is even worse
that the potential vulnerabilities [9] in Android system libraries are loaded into
every app’s process and further expose more attack surfaces, even if the app
c(cid:2) Springer International Publishing Switzerland 2016
F. Monrose et al. (Eds.): RAID 2016, LNCS 9854, pp. 457–480, 2016.
DOI: 10.1007/978-3-319-45719-2 21
458
M. Sun et al.
itself does not contain any native library. Attackers could exploit vulnerabili-
ties in native libraries and execute arbitrary shellcode on stack or launch ROP
attack [39] if the stack is not executable.
To mitigate such threat, Address Space Layout Randomization (ASLR) [47] is
a widely adopted solution in modern operating systems. If properly implemented,
a system with the ASLR protection will randomize the loaded code and data
into diﬀerent locations. Therefore, attackers cannot infer the memory layout
from previous executions or other side channels, raising the bar for successfully
exploiting the system.
Android introduced the ASLR protection since version 4.0 and improved the
implementation in later versions. However, as indicated by previous research [32],
the ASLR support in Android is not complete. First of all, the ASLR protection
in earlier Android versions is only eﬀective for system-related processes started
at device booting stage, e.g., service management and communication-related
processes. Second, the zygote process creation model of Android indirectly weak-
ens the eﬀectiveness of memory layout randomization. System libraries in dif-
ferent apps inherit shared (and same) memory regions from the parent zygote
process. Thus, attackers can infer the memory layout from other running apps.
This memory layout information helps attackers to initiate attacks and exe-
cute any arbitrary code on an Android system. For instance, Lee et al. [32]
demonstrated the possibilities of remotely exploiting vulnerable apps and eas-
ily bypassing the ASLR protection in the Android system to launch an ROP
attack (e.g., return-to-library [23,53] and return-to-linker attacks). They further
proposed a countermeasure called Morula that changes the Android system to
randomize the memory layout for apps. Framework enhancement appears to be
a natural solution. However, the need to change the Android framework could
strongly impair the practical deployment due to the deep fragmentation of the
Android platform.
In this paper, we ﬁrst demonstrate that the newly introduced Android app
RunTime (ART) exposes a new attack surface, namely return-to-art (ret2art
for short). This attack surface increases the predictability of the memory layout
of executable code regions which are the pool of useful ROP gadgets. Then, it
further facilitates the construction of malicious payloads since attackers could
return to the pre-compiled framework libraries and leverage the well-deﬁned
Android framework APIs to perform malicious operations. For instance, attack-
ers could easily construct the payload to send SMS, get GPS locations on behalf
of the vulnerable app if the app has corresponding permissions, without the
need to understand the tedious details of the binder IPC mechanism and bridge
the semantic gaps between the high level framework APIs and low level system
calls. This new attack surface is not just in theory, but it is actually a practi-
cal threat. A recent study [36] leveraged a similar attack surface to exploit the
Android system.
To mitigate this threat, we then propose a user-level solution called
Blender. Our
self-
randomization to (sensitive) Android apps with high security requirement, with-
out waiting for the changes of the Android framework nor the underlying Linux
the capability of memory layout
system provides
Blender: Self-randomizing Address Space Layout for Android Apps
459
kernel. Speciﬁcally, Blender ﬁrst randomizes memory layout of loaded system
libraries which are inherited from the zygote process. Then, to prevent the
ret2art attack, Blender also randomizes the ART executable runtime dynami-
cally at startup time. It ensures that the base addresses of libraries and the ART
runtime are unpredictable.
We implement a prototype of Blender and evaluate its eﬀectiveness and
overhead. Our evaluation shows that apps using our system have a much higher
memory entropy than vanilla apps. This means attackers have to try many times
to successfully bypass the Android ASLR protection, instead of a single attempt.
Blender incurs an increase of 6 MB memory footprint for an app. Note that,
this only aﬀects apps using our system, and does not aﬀect other ones running
on the device, an extra advantage compared with the system-wide solution [32].
Our system increases 0.3 s to the app starting time, and incurs no obvious CPU
and battery overhead.
To summarize, this paper makes following contributions:
– We ﬁrst discover a new attack surface called ret2art attack in recent Android
versions. This attack surface provides a large pool for useful ROP gadgets, and
facilitates the construction of malicious payloads using high-level framework
APIs.
– To mitigate the threat of ret2art attack and weakened ASLR implementation
in the Android system, we propose a user-level solution which could self-
randomize address space layout for both native libraries and the ART runtime
of a running app, without the need of framework modiﬁcation.
– We implement a prototype of the Blender system and evaluate the eﬀective-
ness and performance overheads. Our experiments show that Blender can
gain high randomization entropy with only 300 ms delay of the app’s startup
time, without obvious overhead to the CPU and battery resources.
The paper is organized as follows. In Sect. 2, we discuss the background of
Android and related attack/defense methods. Section 3 explains the weakened
ASLR mechanism in the current Android system, and we also illustrate conven-
tional ROP attacks and propose a novel ret2art attacks on the latest version
of Android. Section 4 presents the design and implementation of Blender. We
present the experimental results which show the eﬀectiveness, performance and
battery overheads of Blender in Sect. 5. Finally, we discuss possible limitations
in Sect. 6, study related work in Sect. 7, and Sect. 8 concludes the paper.
2 Background
In this section, we brieﬂy introduce the new Android runtime (ART runtime)
and the ASLR protection on Android.
2.1 Dalvik VM and ART Runtime
An Android app is a zip ﬁle packaged with Dalvik executable code (i.e., dex ﬁle)
and other resources. In previous Android versions (before Android 5.0), Android
460
M. Sun et al.
utilizes the Dalivk virtual machine (DVM) to interpret the Dalvik bytecode at
runtime. When an app is started, each Dalvik instance is created and system
libraries and app bytecode will be loaded into an individual process. However,
creating a new process and fully loading dependent libraries is a time-consuming
process, especially on resource-limited mobile platforms. Android optimizes this
process by creating the zygote process and pre-loading all the system libraries
into this zygote process when the system is booting. Then all other apps are
forked from this zygote process and inherit the pre-loaded system libraries (and
the Dalvik instance) in the zygote process. This optimization improves an app’s
launch-time, however, defeats the ASLR protection in Android since the system
libraries in diﬀerent apps are shared the same memory layout. Figure 1 shows
that the system libraries like libc.so and libart.so are shared between diﬀer-
ent apps and their addresses could be predicted by attackers. We will illustrate
the way of launching corresponding attacks using the knowledge of predicted
address space layout in Sect. 3.1.
Since Android 5.0, Google optimizes the Android system by introducing a
new Android runtime, i.e., the ART runtime. ART introduces an ahead-of-time
(AOT) compilation strategy to compile the Dalvik bytecode into native machine
code. Due to this optimization, the framework-level APIs in the format of Dalvik
bytecode are now converted into native code, and are shared between diﬀerent
apps. The new executable machine code is internally stored in the oat ﬁle format,
which is nearly same with the traditional ELF format.
Figure 2 illustrates the ﬂow of code execution of an app by the ART run-
time. This runtime introduces three diﬀerent memory regions into the app’s
process space. The ﬁrst one is the classes.dex ﬁle, which contains an app’s
logic. The ﬁle name has a legacy extension which was inherited from the
Dalvik runtime, but it is actual in the oat format. The second region is the
system@PI:EMAIL ﬁle (i.e., “ART boot code” short for boot.oat).
This region contains the compiled executable code of all Android framework
bytecode. The third region is a data area and it does not contain any executable
code. It is mapped with the system@PI:EMAIL ﬁle (i.e., “ART boot
image” internally and is called boot.art for short) which contains all necessary
objects for bootstrapping the ART runtime. Basically, it provides a mapping
table between a framework function and its real address of the executable code.
To invoke a framework function in the app, the code will ﬁrst (1) query the
boot.art mapping table, then (2) call the actual code in the text section in
boot.oat. For the ART runtime, there are class tables and method tables which
maintain information of all loaded classes and methods. The runtime can call
Invoke() of the ArtMethod in the method table to execute the compiled code
through an invocation assembly code stub.
We found that the introduction of the ART runtime exposes a new attack
surface due to two reasons. First, the large chunk of pre-compiled framework
native code are shared between diﬀerent apps, and its memory layout is more
predictable than other system libraries. Thus, this increases the pool of libraries
that could be used as ROP gadgets. Second, the ART runtime exposes all pre-
compiled code of the framework functions at predictable locations. Attackers can
Blender: Self-randomizing Address Space Layout for Android Apps
461
Fig. 1. Android booting and app cre-
ation process.
Fig. 2. Android ART runtime and
memory structure.
utilize this code as payloads and invoke high-level framework APIs more easily
than the previous Dalvik runtime. We will elaborate this form of attack surface
in Sect. 3.2.
2.2 DEP/ASLR Protection on Android
Control ﬂow hijacking is a way to exploit vulnerable program and control the
program’s execution ﬂow. In old days, attackers usually hijacked the control ﬂow
to the data area and executed the prepared shellcode on stack. DEP is a security
feature which intends to defeat this type of attack, by disallowing the memory
page as writable and executable at the same time. This feature is supported in
modern hardware and enabled by default in many operating systems, including
the Android system.
Then researchers proposed the return-oriented programming (ROP) attack
to defeat the eﬀectiveness of the DEP protection. It does not need to inject
shellcode into the data area and then mark the data area as executable. Instead,
it reuses the already loaded code in the process to launch attack. Speciﬁcally,
the ROP attack hijacks the program’s control ﬂow and jumps to existing exe-
cutable instruction sequences which end with return instructions. These instruc-
tion sequences are called “gadgets”. By chaining gadgets together, attackers can
perform arbitrary operations regardless of the DEP protection. There are many
kinds of ROP techniques, e.g., return into binary executable, return into shared
libraries and return into non-randomized memory. The most widely used tech-
nique is the return-into-library technique, due to the fact that libraries such as
libc contain functions (or gadgets) for invoking system calls and other func-
tionalities which are useful to attackers.
To defend against ROP attacks, in conjunction with DEP, Address Space
Layout Randomization (ASLR) was proposed in a probability manner. The basic
idea of ASLR is that addresses of loaded executable, stack, heap and loaded
libraries for each new process are randomized. Therefore, attackers cannot eas-
ily predict the memory address and jump to a ﬁxed executable address of a
462
M. Sun et al.
gadget for an ROP attack. Although there are several techniques [34] to bypass
DEP/ASLR, ASLR indeed makes attacks more diﬃcult and limited.
Android gradually adopted memory layout randomization on stack, library,
heap, and dynamic linker in Android 2.3.4, Android 4.0, Android 4.0.3, and
Android 5.0 respectively. However, ASLR protection on Android is not as eﬀec-
tive as expected due to several reasons. First, only the latest version Android
5.x supports the full ASLR protection, but it only accounts for 12.4 % among
all Android devices [6]. Second, even in the case of the full ASLR protection,
the zygote app creation model still tampers this protection (Sect. 2.1). Third,
the pre-compiled system framework oat ﬁles increase the pool for ROP gadgets
and facilitate the construction of malicious payloads, and introduce a new attack
surface.
3 A New Attack: Ret2art
In this section, we discuss how to circumvent the ASLR protection on Android
and present a new attack surface introduced by the ART runtime.
3.1 ASLR Circumvention
What Went Wrong? As discussed in the previous section, all apps are forked
from the zygote process. This implies that the memory structures of child apps
are identical and duplicated by the parent zygote process. In other words, the
base addresses of stacks, common libraries such as libc.so, and the dynamic
linker are same in every app. Attackers can now easily predict memory layout
information of all apps from one single exploited app. Moreover, even if some
system libraries are not used by the app, they are still mapped into the app’s
process because the zygote process has loaded them. This further increases the
possibility of the success of the ROP attack. In summary, the way that Android
app is created defeats the purpose of ASLR mechanism.
We discover that the loaded libraries of the zygote process provide rich
sources of ROP gadgets which every other app will inherit. To quantify the
attack surface, we measure the size of text section (or executable section) of
system libraries loaded in the zygote process for diﬀerent Android major ver-
sions. Figure 3 shows that the number of loaded libraries increases from 50
to about 100, and the largest size of executable section is about 22 MB. This
exposes a large number of vulnerable executable instructions for attackers. We
then utilize an automatic ROP gadget search tool [7] to ﬁnd out possible gad-
gets (i.e., instruction sequences ended with bx reg, blx reg and pop, pc) in
shared libraries of the zygote process. Table 1 shows the number of unique
ROP gadgets found by the tool in Android 5.1.1. Two common system libraries
libandroid runtime.so and libc.so (highlighted in the table) contain around
a thousand usable gadgets. Because these two libraries provide basic function-
alities for other part of the system, they are stable across diﬀerent Android