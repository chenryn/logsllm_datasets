# Blender: Self-Randomizing Address Space Layout for Android Apps

## Authors
Mingshen Sun<sup>1</sup>, John C. S. Lui<sup>1</sup>, and Yajin Zhou<sup>2</sup>

<sup>1</sup>The Chinese University of Hong Kong, Hong Kong, China  
<sup>2</sup>Qihoo 360 Technology Co. Ltd., Beijing, China

## Abstract
In this paper, we first demonstrate that the newly introduced Android Runtime (ART) in recent Android versions (Android 5.0 and above) exposes a new attack surface, known as the "return-to-ART" (ret2art) attack. Unlike traditional return-to-library attacks, the ret2art attack abuses Android framework APIs (e.g., the API to send SMS) as payloads to perform malicious operations. This new attack surface, combined with the weakened ASLR implementation in the Android system, makes it easier to exploit vulnerable apps. To mitigate this threat and provide self-protection for Android apps, we propose a user-level solution called Blender, which can self-randomize the address space layout for apps. Specifically, Blender randomly rearranges loaded libraries and Android runtime executable code in the app’s process, achieving significantly higher memory entropy compared to the vanilla app. Blender requires no changes to the Android framework or the underlying Linux kernel, making it a non-invasive and easy-to-deploy solution. Our evaluation shows that Blender incurs only a 6 MB increase in memory footprint for the app, does not affect other apps, and introduces a 0.3-second delay in app startup time, with negligible CPU and battery overhead.

## Keywords
Android, ROP, ASLR, Blender

## 1 Introduction
With the increasing functionalities of mobile applications (apps), their security and privacy have become a major concern. For apps running on the Android system, they are primarily written in Java. However, to enhance compatibility and performance, developers often use the Native Development Kit (NDK) to develop native libraries in C/C++ and integrate them into their apps. A recent study [14] showed that around 37% of Android apps contain at least one native library. These native libraries are not memory-safe and may suffer from memory corruption issues [4, 5, 8]. Furthermore, potential vulnerabilities in Android system libraries, which are loaded into every app's process, expose more attack surfaces, even if the app itself does not contain any native library. Attackers can exploit vulnerabilities in native libraries to execute arbitrary shellcode on the stack or launch Return-Oriented Programming (ROP) attacks [39] if the stack is not executable.

To mitigate such threats, Address Space Layout Randomization (ASLR) [47] is a widely adopted solution in modern operating systems. If properly implemented, ASLR randomizes the loaded code and data into different locations, making it difficult for attackers to infer the memory layout from previous executions or other side channels, thus raising the bar for successful exploitation.

Android introduced ASLR protection starting with version 4.0 and improved it in later versions. However, as indicated by previous research [32], the ASLR support in Android is incomplete. First, the ASLR protection in earlier Android versions is effective only for system-related processes started during the device booting stage, such as service management and communication-related processes. Second, the zygote process creation model in Android indirectly weakens the effectiveness of memory layout randomization. System libraries in different apps inherit shared memory regions from the parent zygote process, allowing attackers to infer the memory layout from other running apps. This information helps attackers initiate attacks and execute arbitrary code on the Android system. For instance, Lee et al. [32] demonstrated the possibilities of remotely exploiting vulnerable apps and bypassing the ASLR protection in the Android system to launch ROP attacks (e.g., return-to-library [23, 53] and return-to-linker attacks). They proposed a countermeasure called Morula, which changes the Android system to randomize the memory layout for apps. While framework enhancement seems like a natural solution, the need to change the Android framework could hinder practical deployment due to the deep fragmentation of the Android platform.

In this paper, we first demonstrate that the newly introduced Android ART runtime exposes a new attack surface, namely the return-to-ART (ret2art) attack. This attack surface increases the predictability of the memory layout of executable code regions, which are the pool of useful ROP gadgets. It further facilitates the construction of malicious payloads, as attackers can leverage well-defined Android framework APIs to perform malicious operations, such as sending SMS or getting GPS locations on behalf of the vulnerable app. This new attack surface is not just theoretical but poses a practical threat. A recent study [36] leveraged a similar attack surface to exploit the Android system.

To mitigate this threat, we propose a user-level solution called Blender. Blender provides the capability to self-randomize the memory layout for sensitive Android apps with high security requirements, without waiting for changes in the Android framework or the underlying Linux kernel. Specifically, Blender randomizes the memory layout of loaded system libraries inherited from the zygote process and dynamically randomizes the ART executable runtime at startup time, ensuring that the base addresses of libraries and the ART runtime are unpredictable.

We implement a prototype of Blender and evaluate its effectiveness and overhead. Our evaluation shows that apps using our system have significantly higher memory entropy than vanilla apps, meaning attackers must try many times to successfully bypass the Android ASLR protection. Blender incurs a 6 MB increase in memory footprint for an app, but this only affects apps using our system and does not impact other apps running on the device, an advantage over system-wide solutions [32]. Our system adds a 0.3-second delay to the app's startup time, with no significant CPU and battery overhead.

To summarize, this paper makes the following contributions:
- We discover a new attack surface called the ret2art attack in recent Android versions, which provides a large pool of useful ROP gadgets and facilitates the construction of malicious payloads using high-level framework APIs.
- To mitigate the threat of ret2art attacks and the weakened ASLR implementation in the Android system, we propose a user-level solution that can self-randomize the address space layout for both native libraries and the ART runtime of a running app, without requiring framework modifications.
- We implement a prototype of the Blender system and evaluate its effectiveness and performance overheads. Our experiments show that Blender can achieve high randomization entropy with only a 300 ms delay in the app's startup time, without noticeable overhead to CPU and battery resources.

The paper is organized as follows. In Section 2, we discuss the background of Android and related attack/defense methods. Section 3 explains the weakened ASLR mechanism in the current Android system and illustrates conventional ROP attacks, proposing a novel ret2art attack on the latest version of Android. Section 4 presents the design and implementation of Blender. Section 5 presents the experimental results, showing the effectiveness, performance, and battery overheads of Blender. Finally, we discuss possible limitations in Section 6, review related work in Section 7, and conclude the paper in Section 8.

## 2 Background
In this section, we briefly introduce the new Android runtime (ART runtime) and the ASLR protection on Android.

### 2.1 Dalvik VM and ART Runtime
An Android app is a zip file packaged with Dalvik executable code (i.e., dex file) and other resources. In previous Android versions (before Android 5.0), Android utilized the Dalvik virtual machine (DVM) to interpret the Dalvik bytecode at runtime. When an app is started, each Dalvik instance is created, and system libraries and app bytecode are loaded into an individual process. Creating a new process and fully loading dependent libraries is time-consuming, especially on resource-limited mobile platforms. Android optimizes this process by creating the zygote process and pre-loading all system libraries into this zygote process when the system boots. All other apps are then forked from this zygote process and inherit the pre-loaded system libraries (and the Dalvik instance) in the zygote process. This optimization improves app launch time but defeats the ASLR protection in Android, as the system libraries in different apps share the same memory layout. Figure 1 shows that system libraries like `libc.so` and `libart.so` are shared between different apps, and their addresses can be predicted by attackers. We will illustrate how to launch corresponding attacks using the knowledge of the predicted address space layout in Section 3.1.

Since Android 5.0, Google has optimized the Android system by introducing a new Android runtime, the ART runtime. ART uses an ahead-of-time (AOT) compilation strategy to compile the Dalvik bytecode into native machine code. Due to this optimization, framework-level APIs in the form of Dalvik bytecode are now converted into native code and shared between different apps. The new executable machine code is stored internally in the oat file format, which is similar to the traditional ELF format.

Figure 2 illustrates the flow of code execution of an app by the ART runtime. This runtime introduces three different memory regions into the app’s process space. The first region is the `classes.dex` file, which contains the app’s logic. The file name has a legacy extension inherited from the Dalvik runtime, but it is actually in the oat format. The second region is the `system@PI:EMAIL` file (i.e., "ART boot code," short for `boot.oat`). This region contains the compiled executable code of all Android framework bytecode. The third region is a data area that does not contain any executable code. It is mapped with the `system@PI:EMAIL` file (i.e., "ART boot image," internally called `boot.art`), which contains all necessary objects for bootstrapping the ART runtime. Essentially, it provides a mapping table between a framework function and its real address of the executable code. To invoke a framework function in the app, the code will first query the `boot.art` mapping table, then call the actual code in the text section in `boot.oat`. For the ART runtime, there are class tables and method tables that maintain information about all loaded classes and methods. The runtime can call `Invoke()` of the `ArtMethod` in the method table to execute the compiled code through an invocation assembly code stub.

We found that the introduction of the ART runtime exposes a new attack surface for two reasons. First, the large chunk of pre-compiled framework native code is shared between different apps, and its memory layout is more predictable than other system libraries, increasing the pool of libraries that can be used as ROP gadgets. Second, the ART runtime exposes all pre-compiled code of the framework functions at predictable locations, allowing attackers to utilize this code as payloads and invoke high-level framework APIs more easily than with the previous Dalvik runtime. We will elaborate on this form of attack surface in Section 3.2.

### 2.2 DEP/ASLR Protection on Android
Control flow hijacking is a common method to exploit vulnerable programs and control their execution flow. In the past, attackers typically hijacked the control flow to the data area and executed prepared shellcode on the stack. Data Execution Prevention (DEP) is a security feature that aims to defeat this type of attack by disallowing memory pages from being both writable and executable simultaneously. This feature is supported by modern hardware and is enabled by default in many operating systems, including the Android system.

Researchers then proposed the Return-Oriented Programming (ROP) attack to circumvent DEP. Instead of injecting shellcode into the data area and marking it as executable, ROP reuses existing code in the process to launch attacks. Specifically, the ROP attack hijacks the program’s control flow and jumps to existing executable instruction sequences that end with return instructions, known as "gadgets." By chaining these gadgets together, attackers can perform arbitrary operations, regardless of DEP. There are various ROP techniques, such as return-into-binary executable, return-into-shared libraries, and return-into-non-randomized memory. The most widely used technique is the return-into-library technique, as libraries like `libc` contain functions (or gadgets) for invoking system calls and other functionalities useful to attackers.

To defend against ROP attacks, Address Space Layout Randomization (ASLR) was proposed in conjunction with DEP. The basic idea of ASLR is to randomize the addresses of loaded executables, stack, heap, and loaded libraries for each new process. Therefore, attackers cannot easily predict the memory address and jump to a fixed executable address of a gadget for an ROP attack. Although there are several techniques [34] to bypass DEP/ASLR, ASLR indeed makes attacks more difficult and limited.

Android gradually adopted memory layout randomization for the stack, library, heap, and dynamic linker in Android 2.3.4, Android 4.0, Android 4.0.3, and Android 5.0, respectively. However, ASLR protection on Android is not as effective as expected due to several reasons. First, only the latest version, Android 5.x, supports full ASLR, but it accounts for only 12.4% of all Android devices [6]. Second, even with full ASLR protection, the zygote app creation model still weakens this protection (Section 2.1). Third, the pre-compiled system framework oat files increase the pool of ROP gadgets and facilitate the construction of malicious payloads, introducing a new attack surface.

## 3 A New Attack: Ret2art
In this section, we discuss how to circumvent the ASLR protection on Android and present a new attack surface introduced by the ART runtime.

### 3.1 ASLR Circumvention
**What Went Wrong?** As discussed in the previous section, all apps are forked from the zygote process. This implies that the memory structures of child apps are identical and duplicated by the parent zygote process. In other words, the base addresses of stacks, common libraries like `libc.so`, and the dynamic linker are the same in every app. Attackers can easily predict the memory layout information of all apps from a single exploited app. Moreover, even if some system libraries are not used by the app, they are still mapped into the app’s process because the zygote process has loaded them. This further increases the possibility of a successful ROP attack. In summary, the way Android apps are created defeats the purpose of the ASLR mechanism.

We discovered that the loaded libraries of the zygote process provide a rich source of ROP gadgets that every other app will inherit. To quantify the attack surface, we measured the size of the text section (or executable section) of system libraries loaded in the zygote process for different Android major versions. Figure 3 shows that the number of loaded libraries increased from 50 to about 100, and the largest size of the executable section is about 22 MB. This exposes a large number of vulnerable executable instructions for attackers. We then utilized an automatic ROP gadget search tool [7] to find possible gadgets (i.e., instruction sequences ending with `bx reg`, `blx reg`, and `pop, pc`) in shared libraries of the zygote process. Table 1 shows the number of unique ROP gadgets found by the tool in Android 5.1.1. Two common system libraries, `libandroid_runtime.so` and `libc.so` (highlighted in the table), contain around a thousand usable gadgets. Because these two libraries provide basic functionalities for other parts of the system, they are stable across different Android versions.