作为一种编程语言，少不了变量。我们Linux系统中强大的Shell自然也要支持变量。
【用户变量------信手拈来】
Shell中的变量比较简单、随意。不必声明，随用随写，信手拈来就是一个变量。比如在脚本中有如下语句：
![alt](images/00292.jpeg){.calibre3}
这就获得了一个内容是"128"的变量。那么怎么使用这个变量呢？使用变量的时候需要在变量前加上"\$"符号，以表示这是一个变量。例如我们写这么个脚本：
![alt](images/00293.jpeg){.calibre3}
把这段代码存成一个文本文件（例如myscript.sh）并赋予可执行权限，然后运行，大约会得到如下的结果：
![alt](images/00294.jpeg){.calibre3}
从这个脚本可以看出，要使用一个变量的时候，需要在变量名前加"\$"符号以表示它是一个变量，否则就当作一般的字符处理了。
![alt](images/00011.jpeg){.tpzz}**提示：**[echo是用于向屏幕打印字符的命令。后面可以直接写字符串，也可以使用变量。]{.kai1}
不过有时候我们需要变量紧挨着一个普通字符串，这样可能会产生歧义，例如这个脚本：
![alt](images/00295.jpeg){.calibre3}
运行之后，并不能获得我们想要的结果，而是打印出了：
![alt](images/00296.jpeg){.calibre3}
之所以会这样，是因为Shell将"\$player1vs"看作了一个对player1vs的调用。而我们根本没有这个变量（我们只有player1变量），所以这里是空白，只打印出了player2变量的值"KEN"。如果想让Shell理解我们的意图，也很简单，给变量加上大括号：
![alt](images/00297.jpeg){.calibre3}
这样就可以获得我们想要的结果了：
![alt](images/00298.jpeg){.calibre3}
【变量类型------只有字符串】
有的同学可能注意到了，我们的脚本里并没有给变量明确声明一个类型。这是因为Shell的变量只有一种类型，就是字符串。没有什么整型、浮点型之类的概念。咱们再用一个简单的脚本说明一下：
![alt](images/00299.jpeg){.calibre3}
运行这个脚本，会看到最终打印出来的num的值是"8+1"，而不是"9"。因为bash这家伙压根就没长数学的脑子！他只会把变量的值作为字符串处理。
可是虽然bash没长数学脑子，但是我们的生活不能没有数学啊，遇到需要计算的问题时怎么办呢？没关系，bash不会算，有人会算，就是expr命令。
expr专门用于Shell脚本中，负责对几个字符串变量进行数学计算。比如刚才这个脚本，我们实在是想计算num+1，看看到底得多少。那么就可以这样：
![alt](images/00300.jpeg){.calibre3}
这样就可以如愿看到数字9了。
【环境变量------哪都能用】
刚才我们随手定义的变量，可以叫做用户变量。自己定义自己用就好了。除了用户变量之外，还有一个重要的概念，就是环境变量。比如我们之前遇到过的PATH变量、HOME变量等。
所谓环境变量，有点类似于C语言里面的全局变量，它在整个系统中都有效。用户变量只在这一个脚本内有效，出了这个脚本，这个变量就没了。而全局变量一旦设定，可以在整个系统中的任何时候、任何地方进行访问。要让一个变量成为全局变量很简单，只要在变量赋值语句前加上export，类似这样：
![alt](images/00301.jpeg){.calibre3}
运行这个脚本，你自然会看到输出一个"8"，当然这并不是环境变量的特点。环境变量的特点是你运行完这个脚本以后，再输入命令：
![alt](images/00302.jpeg){.calibre3}
依然会看到这个变量的值还是"8"。
![alt](images/00011.jpeg){.tpzz}**提示：**[环境变量在当前会话结束后失效。]{.kai1}
当然，像这样创建出一个环境变量的需求并不多，一般我们在写Shell脚本的时候，多数是使用或者修改已经存在的环境变量。比如通过\$TZ变量获取本系统所在的时区；通过\$HOME变量获取当前用户的家目录地址等。比如懒蜗牛同学的自动备份脚本，现在每次都是固定往/home/lanwoniu/backup目录下备份，很不灵活。这里就可以应用全局变量，改成这样：
![alt](images/00303.jpeg){.calibre3}
如此一来，就不光是lanwoniu用户可以用这个脚本了，任何用户都可以用这个脚本进行备份，提高了灵活性。
【特殊变量------一堆符号】
除了普通的用户变量和环境变量外，还有一些特殊的变量。这些特殊变量特殊在如下几方面。
![alt](images/00002.jpeg){.tpzz} 长得就特殊。
![alt](images/00002.jpeg){.tpzz} 脚本执行时自动被设定。
![alt](images/00002.jpeg){.tpzz} 不可修改。
下面我们就看看这些变量的样子，主要就是下面这些。
![alt](images/00002.jpeg){.tpzz} \$n------这里，n是一个从0到9的数字。这个变量代表了执行本脚本所加的第n个参数。n=0时代表脚本本身的名称。这个变量跟C语言中的argv\[\]有点类似。
![alt](images/00002.jpeg){.tpzz} \$\*------这个变量代表执行本脚本所加的所有参数（不包括脚本名本身）。
![alt](images/00002.jpeg){.tpzz} \$#------执行本脚本所加的参数个数，类似C语言中的argc。
![alt](images/00002.jpeg){.tpzz} \$\$------这个脚本的PID。
【变量赋值】
变量赋值，除了可以直接写出初值之外，还可以将命令的运行结果赋给变量。比如咱们之前用到过的"\`"符号，可以调用指令并获得该指令的输出。那么同样也可以把这个输出赋值给一个变量。还拿懒蜗牛同学的备份脚本做例子，可以再这样修改一下：
![alt](images/00304.jpeg){.calibre3}
这回我们把当前的日期，存储进了today这个变量，这样如果要多次用到日期，就不必每次都调用date命令了，直接从变量中读取就可以了。
6.3.4 Shell中的条件判断
所有编程语言，都少不了条件判断语句。我们的Shell也是可以支持简单的条件判断的。
【if和fi】
最常见简单的条件判断，就是if语句了。Shell中的if语句比较有个性，if后面的"表达式"部分必须被足够的空格分隔得分崩离析才可以。比如咱们看下面这个脚本（建议把这个脚本命名为kill）：
![alt](images/00305.jpeg){.calibre3}
![alt](images/00011.jpeg){.tpzz}**提示：**[要注意这个脚本中"\["符号前边和后边、"\"\$1\""后边、"="后边、"\]"前边，都要有空格。否则脚本错误。]{.kai1}
这个脚本的运行效果就是这样：
![alt](images/00306.jpeg){.calibre3}
好，我们暂时不去讨论这个脚本中的虐畜及自虐倾向，只讨论里面的if语句。if的工作，就是根据后面命令的返回值，来判断程序应该走哪条分支。另外，if语句一定要有对应的fi作为结尾（相当于endif）。
这里大家可能有点困惑：if后面的命令？if后面不是一个表达式么？哪来的命令呢？
好，那我们写个更简单点的脚本说明一下。
![alt](images/00307.jpeg){.calibre3}
运行这个脚本，可以看到Shell会调用"ls --l
/home"这条命令，列出/home目录下的文件，然后因为if判断到"ls --l
/home"这条命令返回了结果"真"（因为命令执行成功嘛），因此显示出了"ls
return
true！"这个字符串。如果/home这个目录不存在，ls命令就会执行失败，返回"假"，于是if根据这个返回值判断，程序运行else对应的语句，就会打印出"ls
return false！"这个字符串。
这下大家是不是明白些了？if与";"号之间的，就是一条Shell中的命令而已。这个命令返回真，则进入if对应的分支；返回假，则进入else对应的分支（如果有else的话）。那么刚才那个kill脚本里的"\[
\"\$1\" = \"me\" \]"这段难道也是命令么？答对了！这就是命令。
"ls -l home"中，"ls"是命令名，后面是两个参数："-l"和"/home"。