title:Structured Leakage and Applications to Cryptographic Constant-Time
and Cost
author:Gilles Barthe and
Benjamin Gr&apos;egoire and
Vincent Laporte and
Swarn Priya
Structured Leakage and Applications to Cryptographic
Constant-Time and Cost
Gilles Barthe
MPI-SP
Bochum, Germany
IMDEA Software Institute
Pozuelo de Alarc√≥n, Spain
PI:EMAIL
Vincent Laporte
Universit√© de Lorraine, CNRS, Inria, LORIA
F-54000 Nancy, France
PI:EMAIL
Benjamin Gr√©goire
Universit√© C√¥te d‚ÄôAzur, Inria
Sophia Antipolis, France
PI:EMAIL
Swarn Priya
Universit√© C√¥te d‚ÄôAzur, Inria
Sophia Antipolis, France
PI:EMAIL
ABSTRACT
Many security properties of interest are captured by instrumented
semantics that model the functional behavior and the leakage of pro-
grams. For several important properties, including cryptographic
constant-time (CCT), leakage models are sufficiently abstract that
one can define instrumented semantics for high-level and low-level
programs. One important goal is then to relate leakage of source
programs and leakage of their compilation‚Äîthis can be used, e.g.
to prove preservation of CCT. To simplify this task, we put forward
the idea of structured leakage. In contrast to the usual modeling of
leakage as a sequence of observations, structured leakage is tightly
coupled with the operational semantics of programs. This coupling
greatly simplifies the definition of leakage transformers that map
the leakage of source programs to leakage of their compilation and
yields more precise statements about the preservation of security
properties. We illustrate our methods on the Jasmin compiler and
prove preservation results for two policies of interest: CCT and
cost.
CCS CONCEPTS
‚Ä¢ Security and privacy ‚Üí Logic and verification; Formal meth-
ods and theory of security; ‚Ä¢ Theory of computation ‚Üí Se-
mantics and reasoning.
KEYWORDS
Secure Compilation, Cryptographic Constant-Time, Cost
ACM Reference Format:
Gilles Barthe, Benjamin Gr√©goire, Vincent Laporte, and Swarn Priya. 2021.
Structured Leakage and Applications to Cryptographic Constant-Time and
Cost. In Proceedings of the 2021 ACM SIGSAC Conference on Computer and
Communications Security (CCS ‚Äô21), November 15‚Äì19, 2021, Virtual Event,
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
CCS ‚Äô21, November 15‚Äì19, 2021, Virtual Event, Republic of Korea
¬© 2021 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-8454-4/21/11...$15.00
https://doi.org/10.1145/3460120.3484761
Republic of Korea. ACM, New York, NY, USA, 15 pages. https://doi.org/10.
1145/3460120.3484761
1 INTRODUCTION
Modern compilers are designed to carry out an aggressive pro-
gram optimizations while respecting the input-output behavior
of programs. In simple settings, where behaviors are modelled as
execution traces, compiler correctness, is thus stated as an inclu-
sion between the set of traces of the target program and the set
of traces of source programs. However, this approach suffers from
three shortcomings in a security context: first, many common secu-
rity properties are hyperproperties [12], i.e. sets of sets of traces,
rather than properties, i.e. sets of traces; in particular, informa-
tion flow properties, which cover a broad range of applications
are relational properties, i.e. sets of pairs of traces. Second, sev-
eral security properties of interest, including popular notions of
side-channel resistance are modelled by an instrumented semantics
that collects (an abstraction of) the adversarially visible physical
leakage. Third, the inclusion of instrumented traces fail for most
common compiler optimizations, e.g. register allocation and dead
code elimination that may add, modify or remove atomic leakages.
These shortcomings are not purely theoretical, as documented by
multiple security vulnerabilities caused by popular compilers; see,
e.g. [14, 20]. To address these shortcomings; researchers have de-
veloped the foundations of secure compilation, where compilers
are required to preserve both the functional behavior and the se-
curity of programs; these studies often consider broad classes of
security properties and are not tied to specific compiler passes. In
parallel, other works have explored compiler preservation [6, 7]
and compiler-based mitigations [10] for cryptographic constant-
time (CCT), a popular software-based countermeasure to protect
cryptographic implementations against devastating cache-based
timing side-channel attacks.
Contributions. The main contribution of this paper is a novel
approach for proving preservation of non-functional properties,
and in particular CCT. Our approach is based on the following
ideas:
Structured leakage We model leakage using a dedicated data
structure that collects atomic leakages. Our new data structure
Session 2B: Formal Analysis and Verification CCS ‚Äô21, November 15‚Äì19, 2021, Virtual Event, Republic of Korea462is closely aligned with the operational semantics of programs, a
key benefit over the flat list structure used in prior work;
Leakage transformers We define a language of leakage trans-
formers, that transform leakage of source programs into leakage
of target programs. Although our language of leakage transform-
ers is simple; yet we can define leakage transformers for many
common optimizations. A key benefit of leakage transformers is
that they yield an algorithm for computing the leakage of target
programs from leakage of source programs.
Leakage transformers are naturally endowed with a rigorous defi-
nition of correctness: specifically, a leakage transformer ùúè is correct
for a source program, if for every set of inputs, we have ‚ü¶ùúè‚üß‚Ñì = ‚Ñì‚Ä≤,
where ‚Ñì represents the leakage of the source program on the cho-
sen inputs, ‚ü¶ùúè‚üß¬∑ interprets the algorithmic description of the trans-
former ùúè as a function from leakage to leakage, and ‚Ñì‚Ä≤ represents the
leakage of the compiled program on the chosen inputs. Surprisingly,
many leakage transformers achieve this strong notion of correct-
ness. This provides an effective method for proving preservation of
CCT and other non-functional properties.
To illustrate the benefits of our method, we implement our ap-
proach on top of the Jasmin framework [2, 3] for high-assurance
and high-speed cryptography. The Jasmin framework is a natu-
ral target for our approach for three reasons. First, Jasmin puts a
strong emphasis on cryptographic constant-time and efficiency, two
prime examples of non-functional properties. Second, verification
of Jasmin programs (CCT, functional correctness, cryptographic
strength, and cost) is carried out at source-level, to benefit from
the verification-friendly nature of the Jasmin language. Third, the
Jasmin compiler comes with a mechanized proof (in the Coq proof
assistant) that generated assembly programs have the same behav-
ior as their source programs, but there is no mechanized proof of
preservation of CCT, and no prior study of the impact of compila-
tion on cost. Using leakage transformers, we overcome these two
shortcomings: we obtain a formal proof that the Jasmin compiler
preserves CCT, and a certified algorithm to compute the cost of
compiled assembly programs from the cost of source Jasmin pro-
grams1. A surprising aspect of our certified cost transformer is that
it yields an exact cost rather than an upper bound for the generated
programs (for all transformations except loop unrolling, where our
transformer yields an upper bound); to our best knowledge, we are
the first to provide formally verified exact cost transformers for a
realistic compiler.
In summary, our main contributions include:
‚Ä¢ the definition of structured leakage and leakage transformers;
‚Ä¢ formal proofs of correctness of leakage transformers for all the
‚Ä¢ a proof that the Jasmin compiler preserves CCT;
‚Ä¢ a certified algorithm for computing the cost of assembly pro-
passes of the Jasmin compiler;
grams from the cost of Jasmin programs.
All results presented in this paper have been formally verified using
the Coq Proof Assistant. The complete development is provided as
supplementary material2.
1As shall be explained shortly, our cost model is abstract and only provides an estimate
of the efficiency of the generated assembly. In particular, it does not provide cycle-
accurate estimates of the program‚Äôs true execution cost.
2Supplementary material is available for download at: https://github.com/jasmin-
lang/jasmin/tree/constant-time
2 METHODOLOGY
This section outlines our methodology and its applications to cryp-
tographic constant-time and cost.
2.1 Compiler correctness
Certified compilers are high-assurance compilers that come with a
machine-checkable proof that the compiler is correct, i.e. preserves
the behavior of programs. The statement of compiler correctness
relies on operational semantics, which formalizes the execution of
source and assembly programs. For the purpose of this section, we
assume given big-step semantics for source and target programs;
these semantics are expressed by judgments of the form ùëù : ùë† ‚áì ùë†‚Ä≤
(resp. ùëù : ùë† ‚áì ùë†‚Ä≤ ), stating that execution of source program ùëù (resp.
target program ùëù) on initial state ùë† terminates with final state ùë†‚Ä≤.
Using this notation, compiler correctness is informally stated as:
for all source programs ùëù with compilation ùëù, and for all states ùë†
and ùë†‚Ä≤,
ùëù : ùë† ‚áì ùë†‚Ä≤ =‚áí ùëù : ùë† ‚áì ùë†‚Ä≤.
Note that our informal definition assumes that source and target
programs operate over the same state space; the assumption sim-
plifies the discussion, but our approach applies (and is formally
verified) to the more general setting where source and target pro-
grams operate over different state spaces.
2.2 Instrumented semantics
Many properties of interest are expressed relative to an instru-
mented semantics, which tracks visible effects of program execu-
tions ‚Äîsince one main motivation of our work is protection against
side-channel attacks, from now on we use the term leakage generi-
cally to refer to program‚Äôs effects. The instrumented semantics is
based on a leakage model describing what is leaked during program
execution, leading to a judgment of the form ùëù : ùë† ‚áì‚Ñì ùë†‚Ä≤, stating
that executing program ùëù on initial state ùë† yields a final state ùë†‚Ä≤ and
leaks ‚Ñì.
Unfortunately, compiler correctness does not readily extend to
instrumented semantics. Indeed, for most leakage models and com-
pilers of interest, source and target programs have different leakage.
However, one can meaningfully extend the statement of compiler
correctness by requiring the existence of a function ùêπ that trans-
forms leakage of ùëù into leakage of ùëù. There are many ways to
exhibit such a function ùêπ; the approach taken in this paper is that
the function ùêπ is generated by the compiler. Under this approach,
one can define instrumented compiler correctness as: for all source
programs ùëù with compilation ùëù and producing leakage transformer
ùêπ, and for all states ùë† and ùë†‚Ä≤,
ùëù : ùë† ‚áì‚Ñì ùë†‚Ä≤ =‚áí ùëù : ùë† ‚áìùêπ (‚Ñì) ùë†‚Ä≤
Our notion assumes that ùêπ does not depend on the initial state of the
program. This holds for most common compiler passes. However,
in some cases, the definition of the function ùêπ may depend on the
initial state, requiring additional steps. This shall be explained later.
2.3 Cryptographic constant-time
Cryptographic constant-time (CCT) is a software countermeasure
against cache-based timing attacks, an effective class of side-channel
attacks that exploit the latency between cache hits and cache misses
Session 2B: Formal Analysis and Verification CCS ‚Äô21, November 15‚Äì19, 2021, Virtual Event, Republic of Korea463to retrieve cryptographic keys and other secrets from program exe-
cution. The two rules of CCT programming are:
‚Ä¢ do not branch on secrets;
‚Ä¢ do not perform secret-dependent memory accesses.
These rules are very effective: in particular, they guarantee that a
victim program is immune against cache-based timing attacks from
a powerful low-level adversary with control over the cache and the
scheduler, provided the victim program and the adversary execute
in different processes, and memory isolation between processes are
guaranteed [5]. Moreover, it has been proved experimentally that
one can implement efficient cryptographic libraries that follow the
CCT discipline.
CCT is an instance of observational non-interference [7], a gen-
eral class of information flow policies that ensure that programs do
not leak their secrets through observable leakage. As such, the CCT
property is formalized using a leakage model such that control-flow
instructions leak the branch in which they jump, and memory-
accessing instructions leak the address (not the value) being ac-
cessed. In addition to the leakage model, the CCT property is stated
relative to security declarations that tag the memory‚Äôs public and
private parts. The declarations induce an equivalence relation on
states; it is denoted by ‚àº and called indistinguishability: informally,
two states are indistinguishable if they only differ in their private
parts. The CCT property for a program ùëù is then stated as: for all
initial states ùë†1 and ùë†2,
=‚áí ùë†1 ‚àº ùë†2 =‚áí ‚Ñì1 = ‚Ñì2.
(cid:41)
ùëù : ùë†1 ‚áì‚Ñì1 ùë†‚Ä≤
1
ùëù : ùë†2 ‚áì‚Ñì2 ùë†‚Ä≤
2
Under this formalization, preservation of CCT for a program ùëù with
compilation ùëù is stated as: for all initial states ùë†1 and ùë†2,
 =‚áí ùë†1 ‚àº ùë†2 =‚áí ‚Ñì1 = ‚Ñì2 =‚áí ‚Ñì1 = ‚Ñì2.
ùëù : ùë†1 ‚áì‚Ñì1 ùë†‚Ä≤
1
ùëù : ùë†2 ‚áì‚Ñì2 ùë†‚Ä≤
2
ùë†‚Ä≤
ùëù : ùë†1 ‚áì‚Ñì1
1
ùë†‚Ä≤
ùëù : ùë†2 ‚áì‚Ñì2
2
The definition readily extends to instrumented compilers that out-
put leakage transformers.
Theorem 2.1 (Informal). Any compiler that verifies instrumented
correctness preserves constant-time.
2.4 Cost
Programmers often rely, specially in the initial stages of devel-
opment, on a cost model that provides a crude estimate of the
efficiency of their code. Arguably one of the simplest cost models is
the instruction counting model, which tracks how many times each
instruction is executed in a program run. The instruction count-
ing model is the basis of many approaches for computing upper
bounds on the cost of the program. These approaches are generally
developed for source programs. However, our framework offers a
means to transfer the results of the analysis to target programs.
Specifically, note that for many cost models of interest, including
the instruction counting cost model, it is possible to compute the
cost of an execution as a function of its leakage, i.e. ùúÖ = tocost (‚Ñì),
where ùëù : ùë† ‚áì‚Ñì ùë†‚Ä≤. Therefore, any function ùêπ that correctly trans-
forms the leakage of ùëù satisfies ùúÖ = tocost (ùêπ(‚Ñì)). Thanks to the
explicit representation of ùêπ, it is, therefore, possible to compute
the cost of a target Jasmin program from analyzing the source pro-
gram. (Our description suggests a way to compute the cost of the
generated program from the leakage of the source program; we
later explain why the cost, rather than the leakage, of the source
program, suffices for this purpose.)
Theorem 2.2 (Informal). Any compiler that verifies instrumented
correctness correctly transforms cost.
Strikingly, this approach is precise, i.e. for most optimization
passes, one can compute the cost of the target program from the
cost of the source program. In other words, the cost of the target
program is exact if the cost of the source program is exact. Moreover,
the cost of the target program is a sound overapproximation if the
cost of the source program is a sound approximation. Note that in
all cases, the cost is understood in the context of the cost model
rather than a concrete value based on the number of execution
cycles. Nevertheless, and although this is beside the point of this
paper, even a simple model like the instruction counting model
gives a coarse but meaningful estimate of the number of execution
cycles for the class of programs we consider.
3 BACKGROUND ON JASMIN
The Jasmin framework was introduced in [2] and further developed
in [3]. Two of its main components are the Jasmin language and
the Jasmin compiler, which we briefly describe below. Other main
components are the verification tools for functional correctness,
CCT, and cryptographic strength; however, they are not directly
relevant to the work presented here, so we refer the interested
reader to [2, 3].
The Jasmin language is a verification-friendly programming lan-
guage that supports ‚Äúassembly in the head‚Äù. It combines high-level
facilities ‚Äîthat simplify the writing, reading, analysis and verifica-
tion of programs‚Äî with tight control over low-level details of the
generated assembly ‚Äîthat empowers the programmers to construct
aggressively optimized code. For instance, programmers choose
whether values stay in registers or are stored in the stack mem-
ory (through the reg and stack annotations), decide which loops are
unrolled at compile-time, and have direct access to assembly instruc-
tions through the use of intrinsics. High-level constructs include
variables, functions ‚Äîthat are fully inlined‚Äî, structured control