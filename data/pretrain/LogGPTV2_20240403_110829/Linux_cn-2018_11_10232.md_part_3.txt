 s/(.{20}).*/\1/    # 只保留一行的前 20 个字符
 s/.*/| & |/        # 为了输出好看添加竖条
'
```
第二个示例是，如果我想将用户 sonia 的 UID/GID 修改为 1100，我可以这样写：
```
sed -En -e '
  /sonia/{
    s/[0-9]+/1100/g
    p
 }' inputfile
```
注意在替换命令结束部分的 `g` 选项。这个选项改变了它的行为，因此它将查找全部的模式空间并替换，如果没有那个选项，它只替换查找到的第一个。
顺便说一下，这也是使用前面讲过的输出（`p`）命令的好机会，可以在命令运行时输出修改前后的模式空间的内容。因此，为了获得替换前后的内容，我可以这样写：
```
sed -En -e '
  /sonia/{
     p
     s/[0-9]+/1100/g
     p
 }' inputfile
```
事实上，替换后输出一个行是很常见的用法，因此，替换命令也接受 `p` 选项：
```
sed -En -e '/sonia/s/[0-9]+/1100/gp' inputfile
```
最后，我就不详细讲替换命令的 `w` 选项了，我们将在稍后的学习中详细介绍。
### 删除命令
删除命令（`d`）用于清除模式空间的内容，然后立即开始下一个处理循环。这样它将会跳过隐式输出模式空间内容的行为，即便是你设置了自动输出标志（AP）也不会输出。
![The Sed `delete` command](/data/attachment/album/201811/14/190641h144h1mhhxcpcmst.png)
只输出一个文件前五行的一个很低效率的方法将是：
```
sed -e '6,$d' inputfile
```
你猜猜看，我为什么说它很低效率？如果你猜不到，建议你再次去阅读前面的关于退出命令的章节，答案就在那里！
当你组合使用正则表达式和地址，从输出中删除匹配的行时，删除命令将非常有用：
```
sed -e '/systemd/d' inputfile
```
### 次行命令
如果 Sed 命令没有运行在静默模式中，这个命令（`n`）将输出当前模式空间的内容，然后，在任何情况下它将读取下一个输入行到模式空间中，并使用新的模式空间中的内容来运行当前循环中剩余的命令。
![The Sed next command](/data/attachment/album/201811/14/190642cvfwtvwefmvlgr5i.png)
用次行命令去跳过行的一个常见示例：
```
cat -n inputfile | sed -n -e 'n;n;p'
```
在上面的例子中，Sed 将隐式地读取输入文件的第一行。但是次行命令将丢弃对模式空间中的内容的输出（不输出是因为使用了 `-n` 选项），并从输入文件中读取下一行来替换模式空间中的内容。而第二个次行命令做的事情和前一个是一模一样的，这就实现了跳过输入文件 2 行的目的。最后，这个脚本显式地输出包含在模式空间中的输入文件的第三行的内容。然后，Sed 将启动一个新的循环，由于次行命令，它会隐式地读取第 4 行的内容，然后跳过它，同样地也跳过第 5 行，并输出第 6 行。如此循环，直到文件结束。总体来看，这个脚本就是读取输入文件然后每三行输出一行。
使用次行命令，我们也可以找到一些显示输入文件的前五行的几种方法：
```
cat -n inputfile | sed -n -e '1{p;n;p;n;p;n;p;n;p}'
cat -n inputfile | sed -n -e 'p;n;p;n;p;n;p;n;p;q'
cat -n inputfile | sed -e 'n;n;n;n;q'
```
更有趣的是，如果你需要根据一些地址来处理行时，次行命令也非常有用：
```
cat -n inputfile | sed -n '/pulse/p' # 输出包含 “pulse” 的行
cat -n inputfile | sed -n '/pulse/{n;p}' # 输出包含 “pulse” 之后的行
cat -n inputfile | sed -n '/pulse/{n;n;p}'  # 输出包含 “pulse” 的行的下一行的下一行
```
### 使用保持空间
到目前为止，我们所看到的命令都是仅使用了模式空间。但是，我们在文章的开始部分已经提到过，还有第二个缓冲区：保持空间，它完全由用户管理。它就是我们在第二节中描述的目标。
#### 交换命令
正如它的名字所表示的，交换命令（`x`）将交换保持空间和模式空间的内容。记住，你只要没有把任何东西放入到保持空间中，那么保持空间就是空的。
![The Sed exchange command](/data/attachment/album/201811/14/190643lzxd4ndcw79al96w.png)
作为第一个示例，我们可使用交换命令去反序输出一个输入文件的前两行：
```
cat -n inputfile | sed -n -e 'x;n;p;x;p;q'
```
当然，在你设置保持空间之后你并没有立即使用它的内容，因为只要你没有显式地去修改它，保持空间中的内容就保持不变。在下面的例子中，我在输入一个文件的前五行后，使用它去删除第一行：
```
cat -n inputfile | sed -n -e '
 1{x;n} # 交换保持和模式空间
        # 保存第 1 行到保持空间中
        # 然后读取第 2 行
 5{
   p    # 输出第 5 行
   x    # 交换保持和模式空间
        # 去取得第 1 行的内容放回到模式空间
 }
 1,5p   # 输出第 2 到第 5 行
        # (并没有输错！尝试找出这个规则
        # 没有在第 1 行上运行的原因 ;)
'
```
#### 保持命令
保持命令（`h`）是用于将模式空间中的内容保存到保持空间中。但是，与交换命令不同的是，模式空间中的内容不会被改变。保持命令有两种用法：
* `h` 将复制模式空间中的内容到保持空间中，覆盖保持空间中任何已经存在的内容。
* `H` 将模式空间中的内容追加到保持空间中，使用一个新行作为分隔符。
![The Sed hold command](/data/attachment/album/201811/14/190645pp8viir8ipvp8v8i.png)
上面使用交换命令的例子可以使用保持命令重写如下：
```
cat -n inputfile | sed -n -e '
 1{h;n} # 保存第 1 行的内容到保持缓冲区并继续
 5{     # 在第 5 行
   x    # 交换模式和保持空间
        # (现在模式空间包含了第 1 行)
   H    # 在保持空间的第 5 行后追加第 1 行
   x    # 再次交换第 5 行和第 1 行，第 5 行回到模式空间
 }
 1,5p   # 输出第 2 行到第 5 行
        # (没有输错！尝试去找到为什么这个规则
        # 不在第 1 行上运行 ;)
'
```
#### 获取命令
获取命令（`g`）与保持命令恰好相反：它从保持空间中取得内容并将它置入到模式空间中。同样它也有两种方式：
* `g` 将复制保持空间中的内容并将其放入到模式空间，覆盖模式空间中已存在的任何内容
* `G` 将保持空间中的内容追加到模式空间中，并使用一个新行作为分隔符
![The Sed get command](/data/attachment/album/201811/14/190646gb3npiuw8dbw1nz2.png)
将保持命令和获取命令一起使用，可以允许你去存储并调回数据。作为一个小挑战，我让你重写前一节中的示例，将输入文件的第 1 行放置在第 5 行之后，但是这次必须使用获取和保持命令（使用大写或小写命令的版本）而不能使用交换命令。带点小运气，可以更简单！
同时，我可以给你展示另一个示例，它能给你一些灵感。目标是将拥有登录 shell 权限的用户与其它用户分开：
```
cat -n inputfile | sed -En -e '
 \=(/usr/sbin/nologin|/bin/false)$= { H;d; }
            # 追回匹配的行到保持空间
            # 然后继续下一个循环
 p          # 输出其它行
 $ { g;p }  # 在最后一行上
            # 获取并打印保持空间中的内容
'
```
### 复习打印、删除和次行命令
现在你已经更熟悉使用保持空间了，我们回到打印、删除和次行命令。我们已经讨论了小写的 `p`、`d` 和 `n` 命令了。而它们也有大写的版本。因为每个命令都有大小写版本，似乎是 Sed 的习惯，这些命令的大写版本将与多行缓冲区有关：
* `P` 将模式空间中第一个新行之前的内容输出
* `D` 删除模式空间中第一个新行之前的内容（包含新行），然后不读取任何新的输入而是使用剩余的文本去重启一个循环
* `N` 读取输入并追加一个新行到模式空间，用一个新行作为新旧数据的分隔符。继续运行当前的循环。
![The Sed uppercase `Delete` command](/data/attachment/album/201811/14/190647j4o4j42hdpj92jmi.png)
![The Sed uppercase `Next` command](/data/attachment/album/201811/14/190649vsj1vdqhhwqn52kw.png)
这些命令的使用场景主要用于实现队列（[FIFO 列表](https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics))）。从一个输入文件中删除最后 5 行就是一个很权威的例子：
```
cat -n inputfile | sed -En -e '
  1 { N;N;N;N } # 确保模式空间中包含 5 行
  N             # 追加第 6 行到队列中
  P             # 输出队列的第 1 行
  D             # 删除队列的第 1 行
'
```
作为第二个示例，我们可以在两个列上显示输入数据：