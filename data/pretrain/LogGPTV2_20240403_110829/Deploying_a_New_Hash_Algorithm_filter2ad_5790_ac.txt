Section 5.4. As with the digitally-signed element, we rec-
ommend that the transition to a negotiated PRF occur in a
future version of TLS.
5.6 The Finished Message
The TLS Finished message is computed by computing
the TLS PRF over the master secret and the concatena-
tion of two digests over the handshake messages, one us-
ing MD5 and one using SHA-1. The same considerations
apply here as in the PRF. The hash itself is unkeyed al-
though both sides contribute random nonces. This design
modestly reduces memory requirements on the client and
server; HMAC-based MACs require having the key avail-
able at the beginning of the MAC computation, but the key
is only available after the key exchange, so using HMAC
directly would require storing initial handshake messages.
The hash-then-PRF technique only requires storing the hash
state. There is a potential risk in this design in that keyed
hashes are harder to attack than simple hashes. However,
because the attacker cannot control the client messages and
6This has already been an issue with the proposed GOST cipher
suite [5], which for regulatory reasons must use the GOST digest function
in the PRF
can only slightly inﬂuence the server’s messages (by mod-
ifying the client messages in ﬂight to produce a different
negotiation result) the ability to create collisions is insufﬁ-
cient to mount this attack.
The obvious approach to transition is to replace the pair
of hashes with the negotiated hash function used for the
message MAC. However, note that this requires both sides
to store the handshake messages until the MAC algorithm is
decided (in the ServerHello). This requires a modest change
in TLS implementation behavior and a slight increase in
storage requirements. An alternative design would be to
replace the “digest then PRF” construction with a MAC
directly over the handshake messages. This would have
only slightly higher storage requirements and be modestly
more secure in the event of preimage attacks on the under-
lying hash function. We consider either approach adequate,
though we believe that the security considerations outweigh
the memory issue and therefore recommend transitioning to
a simple MAC over the messages.
5.7 Attacks
As with S/MIME, we consider the problem of protect-
ing Switch-hitting implementations during the transition pe-
riod. The general form of the attack is for the enemy to force
one or both sides to believe that the other side is an old im-
plementation and convince them to use weaker algorithms,
thus rendering them susceptible to attack.
We can divide these attacks broadly into two categories.
In the ﬁrst, the attacker has obtained a valid certiﬁcate for
one side of the connection (most likely the server) and
knows the corresponding private key. In this case, no com-
plete defense is possible other than turning off the old algo-
rithm. The attacker can simply intercept the connection and
use its certiﬁcate. As with S/MIME, partial defenses includ-
ing rejecting newer certiﬁcates signed with weak algorithms
and SSH-style ﬁngerprint comparison.
If the attacker does not have a valid certiﬁcate, he must
attack the negotiation more indirectly. However, because
the negotiation is protected by a MAC computed using the
PRF, the attacker must be able to predict PRF output in or-
der to predict the key used for the PRF. As argued in Sec-
tion 5.5, this would require a very serious break of HMAC
and most likely that the attacker can compute preimages,
making a direct attack on certiﬁcates possible.
6 Design Principles for Algorithm Agility
It is clear from our analyses that designing for algorithm
agility is harder than thought. In this section, we present
some suggestions for protocol design that may make future
transitions smoother.
6.1 Avoid the use of hardwired cryptographic al-
gorithms
Any protocol which depends on a single hardwired al-
gorithm is inherently brittle—if that algorithm is broken it
can be very hard to repair the protocol. This is particularly
obvious in the case of DSA; the transition from SHA-1 to
some other digest algorithm is going to be much more dif-
ﬁcult than with RSA, because the hash algorithm and the
signature algorithm will need to be replaced simultaneously.
Similarly, the decision to hardwire MD5 and SHA-1 into the
basic structure of SSL/TLS necessitates far more protocol
re-engineering than if the algorithms had been parametrized
in the ﬁrst place.
6.2 Provide mechanisms for capability discovery
and/or negotiation
Even if a protocol allows for the use of multiple algo-
rithms, algorithm transitions can be difﬁcult to accomplish
if the agents do not have good information about the ca-
pabilities of the peers with which they wish to communi-
cate. In session-oriented protocols such as TLS or IPsec,
this information is easy to exchange by incorporating an al-
gorithm negotiation phase in the session establishment. In
store-and-forward protocols, however, the problem is much
more difﬁcult and generally requires some sort of directory
which can be used by agents to advertise their capabilities.
In both kinds of protocols, it is important to allow for the
advertisement of capabilities for every parameter. S/MIME,
TLS, and IPsec all fail this test.
6.3 Capability discovery should occur as early as
possible
Even protocols which allow negotiation often fail to do
so early enough in the exchange.
In the best case, one
party must try to adapt to whatever is eventually chosen,
possibly resulting in increased computational costs (as with
TLS CertiﬁcateVerify messages or S/MIME multiple sig-
natures). In the worst case, one side must guess about the
other side’s capabilities and a wrong guess results in non-
interoperability or a requirement for manual reconﬁguration
(as with S/MIME single signatures or IPsec hash functions).
In order to avoid this, protocol designers should allow nego-
tiation/capability discovery to happen as early in the com-
munication process as possible.
There is a tradeoff to consider here. If discovery is done
entirely before crypto, it can introduce extra latency (e.g.,
one round trip for the discovery/negotiation, then another
for the crypto). Careful protocol design can mitigate this
to some extent: for instance, the hash negotiation technique
described in Section 5.4 implies some cryptography before
algorithm negotiation but can be implemented with only a
small working buffer.
IKE already includes a capability
discovery exchange in the right place; the problem is that
some necessary capabilities were not negotiated. Another
approach is to design protocols where one peer is optimistic
but can fall back if they guess wrong, as in [35].
6.4 Avoid downgrade attacks
Downgrade attack is a persistent problem with negotia-
tion in security protocols. There are generic techniques for
protecting negotiation in session-oriented protocols (typi-
cally by computing a MAC over the handshake messages)
but they cannot be guaranteed to work if the MAC or key
exchange algorithms are broken. Although TLS and IPsec
do a fairly good job of this via HMAC, which is largely
unaffected by the current level of attacks, they are still at
risk if hash compromises lead to compromise of the cer-
tiﬁcate system used to authenticate the key establishment
phase. The downgrade problem is substantially harder with
store-and-forward protocols. For instance, in the case of
S/MIME multiple signatures the attacker can simply delete
the stronger signature. In general, although defenses against
downgrade are important to incorporate, sufﬁciently pow-
erful attacks on the cryptographic algorithms will require
agents to stop accepting those algorithms.
7 Conclusions
It is clear that new hash functions or new methods of em-
ploying hash functions are necessary. However, as we have
demonstrated, neither the speciﬁcations nor implementa-
tions are ready for the transition. We have presented an
analysis of transition strategies for S/MIME and TLS; anal-
ysis of other protocols, including IPsec and DNSsec, ap-
pears in [1]. We strongly urge the analysis of other proto-
cols that use hash functions. Prominent candidates include
OpenPGP [4], and Secure Shell [38, 39].
For the protocols we analyzed, we present recommen-
dations to implementors and the IETF. These changes are
necessary to prepare for the transition. We suggest that they
be made as quickly as possible, to provide maximum secure
interoperability when new hash functions are ready.
When protocol upgrades are being designed, considera-
tion should be given to signature algorithm agility as well.
In most cases, the signaling will have to be done in the same
place as for hash functions. However, some of the overload-
ing options are inappropriate for signature algorithms. For
example, in IPsec one might use the appearance of a new
hash algorithm in the SA proposal as a signal that one party
supports a new hash algorithm in one context, and hence
presumably in another. There is no obvious way to extend
this to, say, support of ECC signatures.
S/MIME
References
Implementors of S/MIME should ensure that their
product handles multiple signatures properly. In par-
ticular, programs should report success with one sig-
nature while warning about unveriﬁable signatures.
MD5 should never be used for digests, since all con-
forming implementations already support SHA-1.
The IETF should develop a method for indicating
digest function capabilities in certiﬁcates, CA ven-
dors should implement it, and new certiﬁcates should
contain explicit statements about hash functions sup-
ported.
The IETF should deﬁne a TLS extension by which
servers can signal support for newer certiﬁcates.
The IETF should pick one of the two suggested alter-
natives for supporting client side certiﬁcates properly.
The IETF should consider making the PRF depend on
the MAC algorithm in a future version of TLS.
The deﬁnition of the digitally-signed element should
be amended to support new hash functions.
The deﬁnition of the Finished message should be
amended to support new hash functions.
TLS
DSA
DSA presents a special problem, since it may only be
employed with SHA-1. NIST needs to clarify this sit-
uation, either by deﬁning DSA-2 or by describing how
DSA can be used with randomized hashes or truncated
longer hashes.
The problems we have described here are symptomatic
of a more general problem. Most security protocols al-
low for algorithm negotiation at some level. However, it
is clear that this has never been thoroughly tested. Virtually
all of the protocols we have examined have some wired-in
assumptions about a common base of hash functions. It is
a truism in programming that unexercised code paths are
likely to be buggy. The same is true in cryptographic proto-
col design.
Acknowledgments
The authors would like to thank Russ Housley for his de-
tailed review of this paper. We would also like to thank Alex
Alten, Steve Burnett, Hal Finney, Eu-Jin Goh, Peter Gut-
mann, Steve Henson, Charlie Kaufman, John Kelsey, Ben
Laurie, Arjen Lenstra, Blake Ramsdell, Hovav Shacham,
Benne de Weger, and the referees for their advice and com-
ments.
[1] S. M. Bellovin and E. K. Rescorla. Deploying a new hash
algorithm. Technical Report CUCS-036-05, Dept. of Com-
puter Science, Columbia University, October 2005.
[2] E. Biham, R. Chen, A. Joux, P. Carribault, C. Lemuet, and
In
W. Jalby. Collisions of SHA-0 and Reduced SHA-1.
Proceedings of Eurocrypt ’05, 2005.
[3] S. Blake-Wilson, M. Nystrom, D. Hopwood, J. Mikkelsen,
and T. Wright. Transport Layer Security (TLS) Extensions.
RFC 3546, June 2003.
[4] J. Callas, L. Donnerhacke, H. Finney, and R. Thayer.
OpenPGP Message Format. RFC 2440, November 1998.
[5] G. Chudov and S. Leontiev. Addition of GOST ciphersuites
to Transport Layer Security (TLS), May 2004. draft-chudov-
cryptopro-cptls-01.txt.
[6] T. Dierks and C. Allen. The TLS Protocol Version 1.0. RFC
2246, January 1999.
[7] H. Dobbertin. Cryptanalysis of MD4 (Third Workshop
on Cryptographic Algoruthms, Cambridge 1996). Lecture
Notes in Computer Science, pages 55–72, 1996.
[8] H. Dobbertin. The First Two Rounds of MD4 are Not One-
Way. Lecture Notes in Computer Science, 1372, 1998.
[9] P. Gutmann. Personal communication, 2005.
[10] S. Halevi and H. Krawczyk. Strengthening Digital Signa-
tures via Randomized Hashing, May 2005. draft-irtf-cfrg-
rhash-00.txt.
[11] S. Henson. Personal communication, 2005.
[12] R. Housley. Cryptographic Message Syntax (CMS). RFC
3852, July 2004.
[13] R. Housley, W. Polk, W. Ford, and D. Solo. Internet X.509
Public Key Infrastructure Certiﬁcate and Certiﬁcate Revoca-
tion List (CRL) Proﬁle. RFC 3280, April 2002.
[14] J. Jonsson and B. S. Kaliski. Public-key cryptography stan-
dards (PKCS) #1: RSA cryptography speciﬁcations version
2.1. RFC 3447, Internet Engineering Task Force, Feb. 2003.
[15] A. Jøsang, D. Povey, and A. Ho. What you see is not always
what you sign.
[16] K. Kain, S. Smith, and R. Asokan. Digital Signatures and
Electronic Documents: A Cautionary Tale. Kluwer Aca-
demic Publishers, 2002.
[17] J. Klensin. Simple Mail Transfer Protocol. RFC 2821, April
2001.
[18] L. D. Kozaryn. DoD issues time-saving Common Ac-
cess Cards, 10 October 2000.
American Forces In-
formation Service, http://www.defenselink.mil/
news/Oct2000/n10102000_200010107.html.
[19] H. Krawczyk. SIGMA: The ‘SIGn-and-MAc’ Approach
to Authenticaticated Difﬁe-Hellman and its Use in the IKE
Protocol, June 2003.
http://www.ee.technion.
ac.il/˜hugo/sigma.ps.
[20] H. Krawczyk, M. Bellare, and R. Canetti. HMAC: Keyed-
Hashing for Message Authentication. RFC 2104, February
1997.
[21] A. Lenstra, X. Wang, and B. de Weger. Colliding X.509
In Proceedings of ACISP, 2005. To appear.
Certiﬁcates.
Online: http://eprint.iacr.org/2005/067.
[22] National Institute of Standards and Technology, U.S. De-
partment of Commerce. Digital Signature Standard, 2000.
FIPS PUB 186-2.
[23] National Institute of Standards and Technology, U.S. De-
partment of Commerce. Secure Hash Standard, 2002. FIPS
PUB 180-2.
[24] National Institute of Standards and Technology, U.S. De-
partment of Commerce. Personal identity veriﬁcation (PIV)
of federal employees and contractors, 2005. FIPS PUB 201.
[25] B. Ramsdell. Secure/Multipurpose Internet Mail Extensions
(S/MIME) Version 3.1 Certiﬁcate Handling. RFC 3850, July
2004.
[26] B. Ramsdell. Secure/Multipurpose Internet Mail Extensions
(S/MIME) Version 3.1 Message Speciﬁcation. RFC 3851,
July 2004.
[27] B. Ramsdell. Personal communication, 2005.
[28] E. Rescorla. Difﬁe-Hellman Key Agreement Method. RFC
2631, June 1999.
[29] E. Rescorla. HTTP Over TLS. RFC 2818, May 2000.
[30] E. Rescorla.
MD5 Collisions in PostScript Files”,
http://www.educatedguesswork.
June 2005.
org/movabletype/archives/2005/06/md5_
collisions.html.
[31] R. Rivest. MD4 Message Digest Algorithm. RFC 1186,
October 1990.
[32] R. Rivest. The MD5 Message-Digest Algorithm . RFC
1321, April 1992.
[33] J. Rosenberg, H. Schulzrinne, G. Camarillo, A. Johnston,
J. Peterson, R. Sparks, M. Handley, and E. Schooler. SIP:
Session Initiation Protocol. RFC 3261, June 2002.
[34] S. Santesson. X.509 Certiﬁcate Extension for S/MIME Ca-
pabilities, May 2005. draft-ietf-smime-certcapa-05.txt.
[35] H. Shacham, D. Boneh, and E. Rescorla. Client-side caching
for TLS. ACM Transactions on Information and System Se-
curity (TISSEC), 7:553–575, Nov 2004.
[36] X. Wang, Y. Yin, and H. Yu. Collision Search Attacks
on SHA1, 2005. http://theory.csail.mit.edu/
˜yiqun/shanote.pdf.
[37] X. Wang and H. Yu. How to Break MD5 and Other Hash
Functions. In Proceedings of Eurocrypt ’05, 2005.
[38] T. Ylonen. SSH – secure login connections over the Inter-
net. In Proceedings of the Sixth Usenix Unix Security Sym-
posium, pages 37–42, July 1996.
[39] T. Ylonen. SSH protocol architecture, 2005. draft-ietf-
secsh-architecture-22.txt.