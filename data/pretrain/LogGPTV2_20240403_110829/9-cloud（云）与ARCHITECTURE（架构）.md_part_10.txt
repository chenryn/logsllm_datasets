\[root@ansible ansible\]# ansible web1,db2 -m shell -a \"useradd nb;echo
123 \|passwd \--stdin nb;\" -k
SSH password:
web1 \| SUCCESS \| rc=0 \>\>
更改用户 nb 的密码 。
passwd：所有的身份验证令牌已经成功更新。useradd：警告：此主目录已经存在。
不从 skel 目录里向其中复制任何文件。
正在创建信箱文件: 文件已存在
db2 \| SUCCESS \| rc=0 \>\>
更改用户 nb 的密码 。
passwd：所有的身份验证令牌已经成功更新。
\[root@ansible ansible\]# ansible web1,db2 -m shell -a \"chage -d 0 nb\"
-k
SSH password:
db2 \| SUCCESS \| rc=0 \>\>
web1 \| SUCCESS \| rc=0 \>\>
\[root@ansible ansible\]#
## 使用raw模块
用法和shell模块一样,可以执行任意命令,
区别是:raw没有chdir creates removes参数
## 使用script模块调用脚本
在所有web主机组上添加用用户wk,,有nb用户的就不用创建wk用户,
\[root@ansible ansible\]# vim user.sh
#! /bin/bash
id nb &\>/etc/null
if \[ \$? != 0 \];then
useradd wk
echo 456 \|passwd \--stdin wk
chage -d 0 wk
fi
\[root@ansible ansible\]# ansible web -m script -a \"user.sh\" -k
#调用user.sh脚本创建
## copy模块(复制文件到远程主机)
\[root@ansible ansible\]# vim /etc/resolv.conf
#事先将resolv.conf文件修改好
\[root@ansible ansible\]# ansible all -m copy -a \'src=/etc/resolv.conf
dest=/etc/resolv.conf\'
\[root@ansible ansible\]# ansible all -m shell -a \"cat
/etc/resolv.conf\" #查看所有主机的resolv.conf
web1 \| SUCCESS \| rc=0 \>\>
; generated by /usr/sbin/dhclient-script
search vbr
nameserver 114.114.114.114
\...
\....
\[root@nn01 ansible\]# vim elas.yml #查看copy模块在实际中的应用
\-\--
\- hosts: esl1
remote_user: root
tasks:
\- copy:
src: /ansible/elk/local.repo
dest: /etc/yum.repos.d/local.repo
owner: root
group: root
mode: 0644
\- copy:
src: hosts
dest: /etc/hosts
owner: root
group: root
mode: 0644
\- yum:
name: java-1.8.0-openjdk,elasticsearch
state: installed
\- template:
src: elasticsearch.yml
dest: /etc/elasticsearch/elasticsearch.yml
owner: root
group: root
mode: 0644
\- service:
name: elasticsearch
state: started
enabled: yes
## lineinfile 模块(修改单个文件的行)
path 要修改的文件
regexp 要修改的行,正则表达式表示
line 修改后的结果
例如:修改cache组中主机的网关配置为:192.168.1.1
\[root@ansible ansible\]# ansible cache -m lineinfile -a
\'path=/etc/sysconfig/network-scripts/ifcfg-eth0 \\
regexp=\"\^GATEWAY\" line=\"GATEWAY=\\\"192.168.1.1\\\"\"\'
cache \| SUCCESS =\> {
\"backup\": \"\",
\"changed\": true,
\"msg\": \"line replaced\"
}
\[root@cache33 \~\]# cat /etc/sysconfig/network-scripts/ifcfg-eth0
\# Generated by dracut initrd
DEVICE=\"eth0\"
ONBOOT=\"yes\"
TYPE=\"Ethernet\"
BOOTPROTO=\"static\"
IPADDR=\"192.168.1.33\"
NETMASK=\"255.255.255.0\"
GATEWAY=\"192.168.1.1\"
## replace模块(修改单个文件的位置)
path 要修改的文件
regexp 要修改的位置
replace 修改后的结果
例如:修改cache组中主机的网关配置为:192.168.1.254
\[root@ansible ansible\]# ansible cache -m replace -a
\'path=/etc/sysconfig/network-scripts/ifcfg-eth0 \\
regexp=\"1\\.1\"
replace=\"1.254\"\'
cache \| SUCCESS =\> {
\"changed\": true,
\"msg\": \"1 replacements made\"
\[root@cache33 \~\]# cat /etc/sysconfig/network-scripts/ifcfg-eth0
\# Generated by dracut initrd
DEVICE=\"eth0\"
ONBOOT=\"yes\"
TYPE=\"Ethernet\"
BOOTPROTO=\"static\"
IPADDR=\"192.168.1.33\"
NETMASK=\"255.255.255.0\"
GATEWAY=\"192.168.1.254\"
## YUM模块
name 包名.使用逗号分隔
state 动作 两个参数installed(安装软件包) removed(删除软件包)
给db组主机安装mariadb-server httpd
\[root@ansible ansible\]# ansible db -m yum -a
\'name=mariadb-server,httpd state=installed\'
## service 模块
name 服务名
state 动作,started stopped restarted
enabled yes\|no
启动db组主机的mariadb httpd,并设置开机自启动
\[root@ansible ansible\]# ansible db -m service -a \'name=mariadb
state=started\'
\[root@ansible ansible\]# ansible db -m service -a \'name=mariadb
enabled=yes\'
\[root@ansible ansible\]# ansible db -m service -a \'name=httpd
state=started\'
\[root@ansible ansible\]# ansible db -m service -a \'name=httpd
enabled=yes\'
# 案例
1 案例1：环境准备
1.1 问题
本案例要求准备ansible的基础环境：
启动6台虚拟机
禁用selinux和firewalld
编辑/etc/hosts
配置yum扩展源并在管理节点安装ansible
1.2 方案
此方案需要准备六台主机，1台管理主机，5台托管主机，以实现批量程序部署，批量运行命令等功能，具体要求如表-1所示：
表-1
1.3 步骤
实现此案例需要按照如下步骤进行。
步骤一：基础环境准备
1）启动6台虚拟机，由于已经讲过怎么创建，这里不再在案例里体现
2）真机配置yum仓库
\[root@room9pc01 \~\]# tar -xf ansible_soft.tar.xz
\[root@room9pc01 \~\]# cd ansible_soft/
\[root@room9pc01 ansible_soft\]# mkdir /var/ftp/ansible
\[root@room9pc01 ansible_soft\]# cp \* /var/ftp/ansible
\[root@room9pc01 ansible_soft\]# createrepo /var/ftp/ansible
Spawning worker 0 with 1 pkgs
Spawning worker 1 with 1 pkgs
Spawning worker 2 with 1 pkgs
Spawning worker 3 with 1 pkgs
Spawning worker 4 with 1 pkgs
Spawning worker 5 with 1 pkgs
Workers Finished
Saving Primary metadata
Saving file lists metadata
Saving other metadata
Generating sqlite DBs
Sqlite DBs complete
3）修改主机名（容易区分，6台机器都需要修改）这里以ansible主机为例子
\[root@localhost \~\]# echo ansible \> /etc/hostname
\[root@localhost \~\]# hostname ansible
4）配置ip（6台机器都需要配置），这里以ansible主机为例子
\[root@localhost \~\]# vim /etc/sysconfig/network-scripts/ifcfg-eth0
\# Generated by dracut initrd
DEVICE=\"eth0\"
ONBOOT=\"yes\"
IPV6INIT=\"no\"
IPV4_FAILURE_FATAL=\"no\"
NM_CONTROLLED=\"no\"
TYPE=\"Ethernet\"
BOOTPROTO=\"static\"
IPADDR=192.168.1.51
PREFIX=24
GATEWAY=192.168.1.254
\[root@localhost \~\]# systemctl restart network
\[root@localhost \~\]# ifconfig
eth0: flags=4163\ mtu 1500
inet 192.168.1.51 netmask 255.255.255.0 broadcast 192.168.1.255
ether 52:54:00:b2:69:9e txqueuelen 1000 (Ethernet)
RX packets 234 bytes 16379 (15.9 KiB)
RX errors 0 dropped 36 overruns 0 frame 0
TX packets 31 bytes 2618 (2.5 KiB)
TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0
5）配置yum客户端，在管理节点ansible上面配置
\[root@ansible \~\]# vim /etc/yum.repos.d/local.repo
\[local_repo\]
name=CentOS-\$releasever - Base
baseurl=\"ftp://192.168.1.254/system\"
enabled=1
gpgcheck=1
\[local\]
name=local
baseurl=\"ftp://192.168.1.254/ansible\"
enabled=1
gpgcheck=0
\[root@ansible \~\]# yum clean all
\[root@ansible \~\]# yum repolist
\[root@ansible \~\]# yum -y install ansible
\[root@ansible \~\]# ansible \--version
ansible 2.4.2.0 //显示版本说明安装成功
config file = /etc/ansible/ansible.cfg
configured module search path = \[u\'/root/.ansible/plugins/modules\',
u\'/usr/share/ansible/plugins/modules\'\]
ansible python module location =
/usr/lib/python2.7/site-packages/ansible
executable location = /usr/bin/ansible
python version = 2.7.5 (default, Aug 4 2017, 00:39:18) \[GCC 4.8.5
20150623 (Red Hat 4.8.5-16)\]
6）请在6台主机上面配置/etc/hosts，这里以ansible主机为例子
\[root@ansible ansible\]# cat /etc/hosts
192.168.1.51 ansible
192.168.1.52 web1
192.168.1.53 web2
192.168.1.54 db1
192.168.1.55 db2
192.168.1.56 cache
2 案例2：主机定义与分组：
2.1 问题
本案例要求：
熟悉ansible配置文件
定义主机，分组和子组练习
自定义文件，多配置路径练习
2.2 步骤
实现此案例需要按照如下步骤进行。
步骤一：ansible.cfg配置文件
\[root@ansible \~\]# cd /etc/ansible/
\[root@ansible ansible\]# ls
ansible.cfg hosts roles
\[root@ansible ansible\]# vim ansible.cfg
#inventory = /etc/ansible/hosts //指定分组文件路径，主机的分组文件hosts
\[selinux\] //组名称，selinux的相关选项在这个下面配置
\...
\[colors\] //组名称，colors的相关选项在这个下面配置
\...
步骤二：定义主机，分组和子组练习
1）静态主机的定义
\[root@ansible ansible\]# vim hosts
\[web\]
web1
web2
\[db\]
db\[1:2\] //1:2为db1到db2两台主机，1:20为db1到db20多台主机
\[other\]
cache
\[root@ansible ansible\]# ansible web \--list-host //显示web组的主机
hosts (2):
web1
web2
\[root@ansible ansible\]# ansible db \--list-host
hosts (2):
db1
db2
\[root@ansible ansible\]# ansible other \--list-host
hosts (1):
cache
\[root@ansible ansible\]# ansible all \--list-host //显示所有组的主机
hosts (5):
web1
web2
cache
db1
db2
2）直接测试
\[root@ansible ansible\]# ansible cache -m ping
//测试是否可以连接，若失败颜色为红色
cache \| UNREACHABLE! =\> {
\"changed\": false,
\"msg\": \"Failed to connect to the host via ssh: ssh: Could not resolve
hostname cache: Name or service not known\\r\\n\",
\"unreachable\": true