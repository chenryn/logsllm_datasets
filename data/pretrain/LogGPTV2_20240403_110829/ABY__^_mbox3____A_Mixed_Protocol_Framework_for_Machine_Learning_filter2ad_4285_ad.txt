revealing linear combinations. However, due to subsequent randomization and how
x1, x2, x3 are distributed, this operation is secure.
Session 1B: PrivacyCCS’18, October 15-19, 2018, Toronto, ON, Canada41First observe that the computation of x1 + x2 + x3 can be re-
duced to computing 2c + s by executing k independent full adders
FA(x1[i], x2[i], x3[i − 1]) → (c[i], s[i]) for i ∈ {0, ..., k − 1} where
c[i], s[i] denote the ith bit of the bitstrings c and s. It is worth noting
that traditionally, full adders are chained together to compute the
addition of two bits and a carry in, however, here we used them to
reduce 3 operands (i.e. x1, x2, x3) to 2 (i.e. c, s) while using a single
round of communication as opposed to k. The final result can then
tively, in the semi-honest setting Party 2 can provide (x1 + x2) as
In both settings, this results in a total of 1 + log k rounds, which
is significantly better than a factor of two increase in rounds and
communication.
be computed as 2(cid:74)c(cid:75)B +(cid:74)s(cid:75)B using a parallel prefix adder. Alterna-
private input to a 3PC which computes(cid:74)x(cid:75)B :=(cid:74)x1 + x2(cid:75)B +(cid:74)x3(cid:75)B.
Bit Extraction,(cid:74)x(cid:75)A →(cid:74)x[i](cid:75)B. A special case of bit decomposi-
tion is when a single bit of the share(cid:74)x(cid:75)A should be decomposed
into a binary sharing, e.g. the ith bit(cid:74)x[i](cid:75)B. This case can be simpli-
fied such that only O(i) and gates and O(log i) rounds are required.
While relatively simple, this optimization removes all the unnec-
essary gates from the parallel prefix adder. As a result, the circuit
logic only requires 2i and gates. We use this optimization in our
implementation. For brevity, we refer the reader to inspect [33] to
deduce exactly which gates can be removed.
κ1, κ2, κ3 and party 3 hold κ2, κ3. The share is then defined as
of the final arithmetic sharing and therefore the former can be
known to parties 1,2 and the latter can be known to parties 2,3.
vert a k bit value in the binary secret share representation to
an arithmetic secret share representation. Effectively, we use the
same circuit as the bit decomposition with the order of operations
Bit Composition,(cid:74)x(cid:75)B →(cid:74)x(cid:75)A. It can also be required to con-
slightly reversed. First, parties 1,2 input a random share(cid:74)−x2(cid:75)B
and parties 2,3 input a random share(cid:74)−x3(cid:75)B. These will be part
(cid:74)x2(cid:75)B can be generated by having parties 1,2 hold three PRF keys
(cid:74)x2(cid:75)B := (F(κ1, N), F(κ2, N), F(κ3, N)) where N denotes a public
nonce.(cid:74)x3(cid:75)B can be defined in a similar way with the roles shifted.
The parties compute FA((cid:74)x[i](cid:75)B,(cid:74)−x2[i](cid:75)B,(cid:74)−x3[i](cid:75)B) → ((cid:74)c[i](cid:75)B,
(cid:74)s[i](cid:75)B) for i ∈ {1, ..., k − 1} and then using a parallel prefix adder
(cid:74)x1(cid:75)B := 2(cid:74)c(cid:75)B +(cid:74)s(cid:75)B. In the semi-honest setting, this can be further
and compute(cid:74)x1(cid:75)B :=(cid:74)x(cid:75)B +(cid:74)−x2 − x3(cid:75)B using a parallel prefix
is defined as(cid:74)x(cid:75)A := (x1, x2, x3). Overall, the conversion requires
Bit Injection,(cid:74)x(cid:75)B →(cid:74)x(cid:75)A. Another special case can often oc-
promoted to an arithmetic sharing(cid:74)x(cid:75)A. For ease of presentation,
a generalization of it to efficiently compute a(cid:74)x(cid:75)B → (cid:74)ax(cid:75)A is
Joint Yao Input. Recall that in Yao sharing of a bit x, party 1
x ∈ {0, 1}κ
0
(evaluator) holds kx
x ⊕ ∆. A useful
and a global random ∆ ∈ {0, 1}κ such that k
0
primitive for conversions to and from Yao shares is the ability for
two parties to provide an input that is known to both of them. For
optimized by having party 2 provide (−x2 − x3) as private input
adder. Regardless, x1 is revealed to parties 1,3 and the final sharing
cur when a single bit x encoded in a binary sharing needs to be
we defer the explanation of this technique to Section 5.4 where
x while the other two parties hold k
1 + log k rounds and k + k log k gates.
presented.
1
x := k
circuit). However, in the malicious setting party 1 needs to verify
example, parties 1,2 know a bit x and wish to generate a sharing of
(cid:74)x(cid:75)Y. In the semi-honest setting, this is trivial as party 2 can locally
generate and send(cid:74)x(cid:75)Y to party 1 (who uses it to evaluate a garbled
that(cid:74)x(cid:75)Y actually encodes x without learning ∆. In the current ex-
ample, party 3 can be used to allow party 1 to check the correctness
of the sharing by having party 2 and 3 send Comm(k
x)
x), Comm(k
1
0
generated using the same randomness shared between them (party
2 can send a hash of the commitments). Party 1 verifies that both
parties sent the same commitments and that Comm(kx
x ) decommits
x . This interaction requires two commitments, one decommit-
to kx
ment and at most one round per input bit. In the case that x is
known to parties 1,3 the roles of 2,3 above can simply be reversed.
When sharing many input bits (n ≫ λ, for λ a statistical secu-
rity parameter), we show that the number of commitments can be
capped at 2λ. After receiving the input labels k
(without
commitments) and before revealing any secret values which are
dependent on these input labels, party 1 computes λ random linear
in (Z2)λ with coefficients
combinations k
in Z2. Parties 2, 3 receive the combination from party 1 and both
0
. Us-
compute the λ combinations of k
xn
ing the same randomness, parties 2,3 send Comm(k
1
=
ci
⊕ ∆) for i ∈ {1, ..., λ} to party 1 (one party can send hash of the
0
k
ci
commitments instead). Party 1 verifies that the two sets of commit-
ment are the same and that Comm(k
for all i.
The probability that party 1 received an incorrect label and this test
passes is 2−λ.
ci ) decommits to k
to obtain k
0
ci
0
0
c1 , ..., k
cλ
), Comm(k
0
x1 , ..., k
x1
x1 , ..., k
x1
x1 , ..., k
c1
c1 , ..., k
of k
xn
xn
xn
xn
cλ
cλ
ci
ci
ci
0
x := kx
x ⊕ (x∆).
communication.
parties) source of randomness, the parties locally sample kx
{0, 1}κ. Parties 2,3 can then define k
In the other case were 2,3 both know x, it is possible to generate
(cid:74)x(cid:75)Y with no communication. Using a shared (among all three
x ←
Yao to Binary,(cid:74)x(cid:75)Y →(cid:74)x(cid:75)B. As observed in [24], the least sig-
nificant bit of the keys (permutation bit) form a two-party sharing
of x. i.e. x ⊕ px = kx
x[0]. Note that party 3 also
0
x[0]. Parties 1 and 2 locally generate an-
0
knows px since it holds k
x [0] ⊕ r = x ⊕ px ⊕ r to
other random bit r and party 1 sends kx
Party 3. This yields the following three-party replicated sharing
(cid:74)x(cid:75)B = (x ⊕ px ⊕ r , r , px) in a single round and with one bit of
x [0] where px = k
In the malicious setting, the bit x ⊕ b ⊕ r that party 1 sends to
party 3 must be authenticated to ensure that party 1 indeed uses
r ← {0, 1}κ and party 2 sends
b = px. Parties 1 and 2 sample kr
r ⊕ (r ∆) to party 3. Both party 2 and 3 send commitments
0
r := kr
k
C0 = Comm(k
x ⊕ k
y ) to party 1 where k
y ), C1 = Comm(k
0
0
r .
px
px
Party 1 sends kx ⊕r
x ⊕ kr
r to party 3 who verifies that it is in
y}. Party 1 also verifies that the commitment Cpx⊕x ⊕r
the set {k
1
decommits to kx ⊕r
and that both copies of C0, C1 sent from party
2 and 3 are the same. Note that px ⊕ x = kx
x [0]. The parties can
then compute the three-party sharing(cid:74)x(cid:75)B = (x ⊕ px ⊕ r , r , px).
Observe that party 3 computes x ⊕ px ⊕ r as kx ⊕r
[0] ⊕ pr. In total,
final sharing(cid:74)x(cid:75)B is computable after a single round. It is therefore
this conversion takes two rounds of communication, however, the
ok to use(cid:74)x(cid:75)B after the first round so long as dependent values are
not revealed in that round. In the event that the verification steps
fail, the parties should abort.
0
y := k
:= kx
0
y, k
y
y
y
Session 1B: PrivacyCCS’18, October 15-19, 2018, Toronto, ON, Canada42discuss earlier for joint Yao input. The final share can then be com-
puted using a garbled circuit that computes XOR of the three values,
Binary to Yao, (cid:74)x(cid:75)B →(cid:74)x(cid:75)Y. Let (cid:74)x(cid:75)B = (x1, x2, x3). Parties
jointly input the shares(cid:74)x1(cid:75)Y,(cid:74)x2(cid:75)Y,(cid:74)x3(cid:75)Y using the procedure
i.e.(cid:74)x(cid:75)Y :=(cid:74)x1(cid:75)Y ⊕(cid:74)x2(cid:75)Y ⊕(cid:74)x3(cid:75)Y. With the free-XOR technique,
x3. They can therefore locally compute x2 ⊕ x3 and send(cid:74)x2 ⊕ x3(cid:75)Y
to party 1 who locally computes(cid:74)x(cid:75)Y :=(cid:74)x1(cid:75)Y ⊕(cid:74)x2 ⊕ x3(cid:75)Y.
Yao to Arithmetic,(cid:74)x(cid:75)Y →(cid:74)x(cid:75)A. To convert x ∈ Z2k from Yao
this does not require any communication between the parties and
can be computed locally by party 1. In the semi-honest setting, this
can be further optimized by observing that party 2 knows x2 and
arithmetic sharing of x. This requires communicating k joint input
bits (only x2) and 2k garbled gates. In the semi-honest setting this
can be further optimized by having party 3 locally compute x2 + x3
to arithmetic sharing, we could first switch from Yao to Binary and
then perform the bit composition or bit injection (in case of a single
bit) protocol, but since the inputs are in form of Yao sharings, we
choose to use a garbled circuit 3PC for the CRFA addition circuit.
Parties 1, 2 sample x2 ← Z2k and parties 2, 3 sample x3 ← Z2k
and jointly input them using the procedures above. Then, using
a garbled circuit parties compute(cid:74)x1(cid:75)Y :=(cid:74)x(cid:75)Y −(cid:74)x2(cid:75)Y −(cid:74)x3(cid:75)Y
and reveal this to parties 1 and 3.(cid:74)x(cid:75)A = (x1, x2, x3) forms the new
and provide it as private input to(cid:74)x1(cid:75)Y :=(cid:74)x(cid:75)Y −(cid:74)x2 + x3(cid:75)Y. As a
Arithmetic to Yao,(cid:74)x(cid:75)A →(cid:74)x(cid:75)Y. Parties jointly input the shares
of(cid:74)x(cid:75)A = (x1, x2, x3) to generate(cid:74)x1(cid:75)Y,(cid:74)x2(cid:75)Y,(cid:74)x3(cid:75)Y. A garbled
circuit can then be used to generate(cid:74)x(cid:75)Y :=(cid:74)x1(cid:75)Y +(cid:74)x2(cid:75)Y +(cid:74)x3(cid:75)Y.
2 locally compute x2 + x3 and send party 1 the sharing(cid:74)x2 + x3(cid:75)Y
who computes and the final sharing(cid:74)x(cid:75)Y :=(cid:74)x1(cid:75)Y +(cid:74)x2 + x3(cid:75)Y.
5.4 Computing(cid:74)a(cid:75)A(cid:74)b(cid:75)B =(cid:74)ab(cid:75)A
In the semi-honest setting this can be optimized by having party
result, the cost of the garbled circuit is reduced by a factor of 2.
While converting between share representations allows for arbi-
trary combination of shares to be used together, it can be more
efficient to provide custom protocols to directly perform the com-
putation on mixed representation. To this end, we provide a mixed-
protocol for performing(cid:74)a(cid:75)A(cid:74)b(cid:75)B =(cid:74)ab(cid:75)A. This operation is needed
repeatedly to compute piecewise linear or polynomial functions
that are commonly used to approximate non-linear activation func-
tions in training logistic regression and neural network models.
5.4.1
Semi-honest Security.
Three-Party OT. We begin by providing an oblivious transfer
protocol in the three-party honest majority setting. As with the
two-party 1-out-of-2 OT case, we have a sender and a receiver. To
this, we add a third party called a helper who receives no output and
knows the receiver’s choice bit. The functionality for the (sender,
receiver, helper) can be expressed as ((m0, m1), c, c) (cid:55)→ (⊥, mc ,⊥).
Several previous work consider multi-party OT [19, 27, 37, 44],
but to the best of our knowledge we are the first to consider this
particular functionality with an honest majority.
Our approach is extremely efficient with information-theoretic
security. The sender and helper first sample two random strings
w0, w1 ← {0, 1}k known to both of them. The sender masks the
messages as m0 ⊕ w0, m1 ⊕ w1 and sends them to the receiver. The
helper knows that the receiver desires the message mc. As such
the helper sends wc to the receiver who can then recover mc. This
procedure requires sending 3 messages in a single round.
Computing a(cid:74)b(cid:75)B =(cid:74)ab(cid:75)A. The simplest case is the multiplica-
tion of a public value a ∈ Z2k known to party 1 with a shared
bit b ∈ {0, 1}. First, party 3 (the sender) samples r ← Z2k and
:= (i ⊕ b1 ⊕ b3)a − r for i ∈ {0, 1}.
defines two messages, mi
Party 2 (the receiver) defines his input to be b2 in order to learn
the message mb2 = (b2 ⊕ b1 ⊕ b3)a − r = ba − r. Note that party
1 (the helper) also knows the value b2 and therefore the three
party OT protocol above can be used here. The parties then use
locally generated replicated zero sharing (s1, s2, s3) to compute
(cid:74)c(cid:75) = (cid:74)ab(cid:75) = (s1 + r , ab − r + s3, s3). However, to make this a
valid 2-out-of-3 secret sharing, c2 = ab − r + s3 must be sent to
party 1. This would result in a total of two rounds of communica-
tions. Alternatively, the three-party OT procedure can be repeated
(in parallel) with again party 3 playing the sender with inputs
(i + b2 + b3)a − r + s3 for i ∈ {0, 1} so that party 1 (the receiver)
with input bit b2 learns the message c2 (not mb2) in the first round,
totaling 6k bits and 1 round.
5.5 Polynomial Piecewise Functions
This brings us to our final building block, the efficient computation
of polynomial piecewise functions. These functions are constructed
as a series of polynomials. Let f1, ..., fm denote the polynomials
with public coefficients and −∞ = c0 < c1 < ... < cm−1 < cm = ∞
such that, f (x) = fi(x) where ci−1 < x ≤ ci. Our technique for
computing f is to first compute a vector of secret shared values
Computing(cid:74)a(cid:75)A(cid:74)b(cid:75)B =(cid:74)ab(cid:75)A. In the semi-honest setting, it is
sufficient to run the a(cid:74)b(cid:75)B = (cid:74)ab(cid:75)A procedure twice in parallel.
can be written as(cid:74)a(cid:75)(cid:74)b(cid:75)B = a1(cid:74)b(cid:75)B + (a2 + a3)(cid:74)b(cid:75)B. Party 1 acts
Crucial in this technique is to observe that a in the computation
above need not be public. That is, party 1 could have privately
chosen the value of a. Leveraging this, observe that the expression
as the sender for the first term and party 3 for the second term. In
total 4k bits per party are communicated over 1 round.
5.4.2 Malicious Security.