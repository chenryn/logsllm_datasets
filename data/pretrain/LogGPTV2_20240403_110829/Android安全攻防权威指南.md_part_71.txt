的攻击实验了。
下一章将从历史和内部工作原理的角度对Android平台已经采用的各类漏洞利用缓解技术进
行详细介绍。
---
## Page 319
第12章
漏洞利用缓解技术
在漏洞研究社区中，攻防双方的研究者之间随时都在进行军备竞赛。每当成功的攻击方法被
发现或公开，防守方就会努力工作，防止接下来出现类似的攻击。他们为此设计和实现了许多漏
洞利用缓解技术。每当新的缓解技术发布，攻击方的社区就开始忙绿起来。他们必须找出新的漏
洞利用技术，让自己的攻击在新的保护机制下依然有效。面一旦开发出的新技术被公开，其效果
又会逐渐减弱。防守方研究者会又一次忙绿起来，设计出新的保护机制，如此不断反复。
本章将介绍现代漏洞利用缓解技术及其与Android系统的关系。首先从设计和实现的角度。
大致介绍一些主要的缓解技术。然后从历史发展的角度，回顾Android系统对这些缓解技术的支
持情况；一些例子还会给出源代码引用。接下来讨论如何禁用和对抗这些缓解技术。最后面向未
来。讨论哪些缓解技术可能会被加入Android系统。
12.1缓解技术的分类
现代操作系统使用各种漏洞利用缓解技术来增强对抗攻击的能力。一些会直接阻止内存崩溃
型漏润利用，还有一些用于阻止其他类型的攻击，如符号链接攻击。采用缓解技术可以让攻击变
得更为闲难，从而提高攻击成本。
采用某项缓解技术之前，往往需要修改系统的各类组件。有些基于硬件的缓解技术具有非常
好的保护效果，但是一般要求对处理器的硬件设计进行改动。此外，许多缓解技术（包括基于硬
件的）需要额外改动Limux内核，以获得内核级支持。还有一些缓解技术需要修改运行时库或者
编译工具链。
采用这些技术时，其必要的系统修改会带来损失或开销。对基于硬件的缓解技术，修改指令
集架构（Instruction Set Architecture，ISA）或底层处理器的设计会产生极大的开销。部署新的处
理器也需要一定的时间周期。与修改处理器设计相比，改动Linux内核或者运行时库较为容易，
但也需要编译内核并部署升级。第1章介绍过，在Android生态环境下有效地更新操作系统的组
件是一个巨大的挑战。那些需要改动编译工具链的技术可能更麻烦，通常还需要重新编译每个要
保护的程序和共享库，在其中加人一些特殊的标志。相比之下，只需改动操作系统就能实现的技
术更受欢迎，因为它们会直接在整个系统范围内生效；面改动编译工具链则意味着只有用它们编
译的程序才受到保护。
---
## Page 320
304第12章漏润利用缓解技术
此外，性能也是一个要考虑的重要因素。许多安全专家称，为了保护最终用户，产生一些性
能开销是值得的，但也有不少人反对这一观点。许多已知的缓解技术在最初并未被采用，甚至以
后也不会被采用，主要原因就是它们引入的性能开销实在无法令人满意。
先忘掉这些麻烦，来看一些具体的缓解技术以及如何将其用于Android系统。
12.2代码签名
代码签名是一种通过验证密码学签名来防止未授权代码运行的机制。通过公钥密码算法，设
备可以使用一个公钥来验证代码是否被某个特定的私钥（由可信权威机构持有）所签名。尽管
Android并未像iOS和OSX那样严格地实施代码签名，但是它广泛地采用了签名检查，如
TrustZone、bootloader锁、OTA更新和应用程序等方面。由于Android的碎片化特点，在不同的
设备上验证代码的策略可能会有很大的差异。
在Android中，代码签名使用最普遍的是bootloader锁。在bootloader引导设备的各个阶段，
较早一级代码会验证要加载的下一级代码是否来自可信任的源。这个验证过程会构成一条信任
链，将信任归结到最初一级bootloader代码上，这一级通常存储在专用于设备引导的ROM芯片
之中。在有的设备上，bootloader的最后一级还会验证接下来加载的内核和初始化RAM空间。
在极少数设备上（比如GoogleTV），还会进一步验证每个内核模块的签名。除了在引导时验证
代码签名，有的设备还会在刷人固件时进行签名检查。此时，/system分区通常是其中一个校
验目标。再次强调，每种设备实现这些保护机制的策略都不尽相同：有的只在引导时验证签名，
有的只在刷机时验证，还有的对这两个环节都进行验证。
除了设备引导，代码签名验证还被用于OTA升级。OTA升级主要通过一个ZIP文件进行，
其中包含补丁文件、新增文件和一些必要的配置。下载这个文件后，系统重启至恢复模式进行升
级。此时，recovery镜像会对此次升级的内容进行验证并安装。ZIP文件的内容经过可信CA在
密码学意义上的签名，并且进行了有效性验证，从而防止恶意固件被升级到系统中。比如，Nexus
设备的默认recovery镜像就拒绝升级任何非谷歌签名的内容。
Android的应用程序也使用了代码签名，但这里的签名并不能链式地追溯到某个可信的根
CA。在这一点上，草果公司要求所有iOS应用程序都由可信源签名，面谷歌只要求开发者对自
已的软件进行自签名，就可以上传到GooglePlay市场了。由于无法链式追溯到可信CA，普通用
户必须基于签名的社区信誉度来判断其是否可信。当然，是否已经在GooglePlay上架也可以作
为判断软件及其开发者是否可信的一点参考。
Android虽然广泛使用了代码签名，但还是无法达到iOs那样的保护能力。首先，前面介绍
的这些机制在iOS上也都得到了采用。除此之外，苹果公司还基于签名来判断某块内存区域是否
可以作为代码执行，只有经过革果公司自已签名的代码片段才允许被执行，这样就在应用程序通
过官方市场的审核流程后，有效地防止了下载并加载可执行代码或注入代码。在iOS里，唯一的
例外是一块被标记为可读可写可执行的内存，这块区城用于浏览器的JIT编译。通过与其他缓解
技术相结合，草果公司的代码签名机制让传统的内存崩溃型攻击变得极为困难；而Android并未
---
## Page 321
12.4防止整数溢出
305
在此方面启用代码签名，因此无法获得相应的保护能力，无论是内存侵入型攻击还是在软件安装
后下载并执行新的代码都毫无问题。本章之后会介绍其他的缓解技术，它们可以阻止一些漏洞利
用，但并不影响本马的攻击。
12.3加固堆缓冲区
在第一种针对栈缓冲区溢出的缓解技术出现时，堆缓冲区溢出攻击就开始流行起来。1999
年，w00w00安全团队的MatthewConover公开了一份名为heaptut.txt的文件：http:/www.cgsecurity.
org/exploit/heaptuttxt。该文档介绍了堆缓冲区内存崩溃可能带来的后果。随后出现了各类公开文
档，对这个问题的探究越来越深人，包括针对特定堆实现方式和特定应用程序的漏洞利用技术。
尽管有许多资料介绍，堆溢出目前仍是一种常见的漏洞类型。
抽象地来看，堆溢出的利用方法主要有两种。第一种是针对应用程序中特有的数据，导致任
意代码执行。例如，攻击者可能会试图通过溢出改写软件中用于执行shell命令的安全标志位或
者数据。第二种方法则利用底层的堆缓冲区实现机制，通常是针对堆分配器所使用的元数据。经
典的双链表节点删除技术就是一个例子，不过该技术公布后，又陆续出现了许多其他攻击技术。
第二种方法更加流行，因为它对整个操作系统甚至同系列版本操作系统上的每个堆溢出漏洞都有
效，更加通用。如何缓解这类攻击则依堆缓冲区的不同实现而各异。
Android使用DougLea设计的内存分配器的修改版本dlmalloc。Android对其的定制修改非
常少，未涉及安全保护功能。在本书写作时，Android上游源使用的dlmalloc版本是2.8.6，其中
已经包括了许多加固措施。比如，如果不采用额外的技巧，经典的双链表节点删除攻击在这个环
境下是无效的。第8章已经详细介绍了这些缓解技术在Android中的工作原理。第一版发布时，
Android就已经使用了这个加固后的dlmalloc版本。
12.4防止整数溢出
整数溢出（漏洞）可以导致许多类型的非预期行为。目前主流的CPU使用32位或64位的
寄存器来表示整数，大小有限。当算术运算产生的结果超出这个有限的表示范围时，超出的位将
被舍弃，未超出的位则被存到结果寄存器的空间中，这就是所谓的同余算术。例如，当0x8000
和0x20000这两个数相乘时，结果是0x100000000。但是32位寄存器所能表示的最大值是
0xffmmr，因此最高的那一位不会被存储到这个寄存器中，最终的结果是0x00000000。整数溢出
可能导致程序崩溃、价格计算错误或者其他运行时问题，最值得关注的后果是内存出错。例如，
如果将一个这样的值传给内存分配函数，就会分配一个远小于预期的缓冲区。
2002年8月5日，资深安全研究员FlorianWeimer在当时很流行的Bugtrag邮件列表上发布
了多个C运行时库中cal1oc函数的一个严重漏洞。这个函数使用了2个参数：要申请的内存空
12
间单元数量以及每个单元的大小。它会在内部将这两个参数的值相乘，并将结果传递给mal1oc
函数。问题的关键是，有漏洞的C运行时库不会检查相乘时是否出现了整数溢出。因此，如果相
乘的结果大于32位整数，这个函数最终将返回一个远小于调用者预期的内存缓冲区。后来这个
---
## Page 322
306第12章漏洞利用缓解技术
问题得到修复，在发生整数溢出时返回NULL。
Android安全团队在Android第一版发布之前就已经修复了这个漏洞，因此所有Android版本
都不受其影响。Android的安全文档将这个对calloc所作的修改吹嘘为安全加固，但是绝大部
分的安全研究员不认为这是安全加固：只是避免了一个已知的安全漏洞而已。事实上，这个问题
甚至从未被分配CVE编号。我们并不认为Android安全团队的这一工作是漏洞利用缓解，不过
出于完整性考虑顺带提及。
此外，Android还使用了一种更为全局性的方法来防止整数溢出。它引人了GoogleChromeOS
开发者WillDrewry 所开发的一套库，名为 safe_iop（safe intecgeroperations，安全的整数运算）。
该库提供了各种特别编写的算术运算函数，在整数溢出发生时会返回失败。该库可以替代编程语
言中自带的算术运算符，用于对整数运算比较敏感的地方，比如计算一块动态分配的内存大小或
者累加一个引用计数器。从第一个版本开始，Android就加人了这个库。
撰写这本书时，我们仔细调查了Android对safe_iop的使用。此时的最新版本是Android4.2.2，
其中只有5个源文件含有safe_iop库的头文件。进一步观察后发现，该库中safe_add、safe_mul
和safe_sub函数的使用次数分别是5次、2次和0次。使用这些函数的主要是Bionic的libc库、
官方recovery中的 minizip和 Dalvik的 libdex库。Android使用的 safe_iop版本似乎已经过期了。
这个库目前的上游版本是0.4.0，并且包含了许多进入0.5.0的commit。AOSP中的一个commit
指向了版本0.3.1，也就是当前的已发布版本。不过在代码变更日志中，safe_iop.h头文件并未包
含版本0.3.1。总的来说，这个库并未得到广泛面有价值的使用，让人愉借。
12.5阻止数据执行
现代操作系统为了对抗任意代码执行类型的攻击，广泛采用的漏洞利用缓解技术是阻止数据
执行。基于哈佛结构的计算机自带这种保护机制，因为这类系统从物理上将存储代码和存储数据
的内存分离开来。不过，包括基于ARM的设备在内，只有极少系统完全使用这种架构。
现在的计算机系统大都基于一种修改后的哈佛结构或冯·诺依曼结构。这些结构允许代码
和数据在相同的内存中共存，因此可以从磁盘上加载程序并执行，软件升级也变得更为容易。从
通用计算机的便利性要求来看，这个特性是极其重要的，因此这些系统只能部分要求代码和数据
分离。在设计缓解机制时，研究员会特别针对数据段被执行的情况。
2000和 2002年，PaX团队的pipacs 分别创造了两种在i386平台上防止数据执行的技术。i386
平台不支持在页表中将内存标记为不可执行，因此这两种纯软件技术使用了一些平时极少用到的
硬件特性。2000年，PaX发布了名为PAGEEXEC的技术，它使用CPU中的TLB（快表）缓存
机制来阻止对数据的执行。2002年，PaX又发布了名为SEGMEXEC的技术，它使用i386系列
处理器中的段机制，将用户空间内存分为存储数据和存储代码的两类。当CPU从内存的数据存
储区域中取指令时，出现的缺页错误会使内核阻止数据执行。PaX为了让这些技术被广泛采纳而
努力奋斗，但是许多Linux发行版最终还是采用了SEGMEXEC技术的一个变种：exec-shield。
这些技巧都早于现代的数据执行阻止技术，很可能为后者提供了灵感。
---
## Page 323
12.5阻止数据执行
307
支持这个特性，不过各个平台在使用这个技术时的术语有些许差异。ARM在AMD64系列处理
器（例如Athlon 64和Opteron）中首先引人了对NX（Never Execute）的硬件支持。此后，Intel
在奔腾4系列处理器中引人了XD（eXecuteDisable）。ARM则从ARMv6架构起开始支持XN
（eXecuteNever）。HTCDream（也就是众所周知的G1或ADP1）就使用了这种处理器设计
无论是ARM还是x86架构，操作系统内核都必须使用这一特性，将某些内存区域标记为不
应该被执行。如果程序试图执行这些内存区域，就会产生一个处理器执行错误，然后提交给操作
系统内核。内核处理这个错误的方法是向产生问题的进程发送一个信号，这通常会使其终止执行。
对一个程序而言，除非它包含没有设置可执行标志的GNU_STACK程序头，否则Linux内核
就会将其栈所在的内存标记为可执行。编译程序时，如果将-znoexecstack选项传给编译工具
链，编译器就会在生成的可执行文件中插入这个程序头。如果不存在GNU_STACK程序头，或者
存在但可执行标志被置上，那么栈就是可执行的。受此影响，所有其他可读的内存映射也都是可
执行的。
可以使用execstack或者readelf工具来判断某个二进制可执行文件中是否包含这样的
程序头。大部分Linmux发行版上都有这两个工具，在AOSP仓库中也能找到。下面摘录了如何用
这两个工具判断栈的可执行状态：
dev:-/android $ execstack -q cat*
[5-e
X cat-gn-takju-CLEARED
cat -gn-takju
dev:~/android $ readelf -a cat-g1 Igzep GNU_STACK
dev:~/android $ reade1f -a cat-gn-takju 1grep GNU_STACK
GNU_STACK
0x0000000x000000000x000000000x000000x000000
dev:~/android $ readelf -a cat-gn-takju-CLEAR&D 1 grep GNU_STACH
GMU_STACK0x000000 0x000000000x000000000X00000 0x00000 RMZ0
代码例数第3行的RW和倒数第1行的RWE加租
除了这些工具，还可以通过proc文件系统中的maps文件来判断内存映射是否可执行。下面
摘录了在运行Android 4.2.1的Galaxy Nexus和运行Android 2.2.2的Motorola Droid上使用 cat
工具查看映射情况的结果：
shellgandroid:/ $ + on the Galaxy Mexus running Android 4.2.1
409e4000-409ec000 rv-p 00000000 00:000
shelleandroid:/ $ cat /proc/self/maps
(deu|xoe).g-doxb1
bebaf000-bebd0000 rv-p 00000000 00:00 0
[deau]
$ + on the Motorola Droid running Android 2.2.2
12
000:0000000000dx00022000-00001000
S cat /proc/self/maps |grep -E *(stack|heap) '
[deau]
bea13000-bea14000 rwxp 00000000 00:00 0
[stack]
maps文件中的每一行都包括一块内存区域的起止地址、权限、页偏移地址、设备主编号和