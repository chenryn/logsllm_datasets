construction process. Conﬁdential storage of the secret data
is out of the scope of COPRIS and is dealt with in LINCOS
(Section 4).
We now explain the construction of the proof of integrity
and its veriﬁcation. The integrity proof is a pair (E, R),
where E is an evidence record and R is a list of decommit-
ment values. The evidence record is constructed interac-
tively between the document owner and an evidence service
which, in turn, interacts with a timestamp service. The list
of decommitment values is constructed and kept secret by
the document owner. The document owner may decide to
reveal the decommitment values together with the document
to a veriﬁer. In the following we describe the protocols of
COPRIS. For more details see the full paper.
Initial protection. The initial integrity proof is constructed
as follows. The document owner runs algorithm Protect.
Input is the document d and the (initially empty) list of
decommitment values R. He selects a commitment scheme
CS and computes a commitment (c, r) ← CS.Commit(d).
He sets R = (r) and sends the commitment value c to the
evidence service. When the evidence service receives c, it
runs algorithm AddEv. Input is c and the (initially empty)
evidence record E.
It requests a timestamp T on c from
a timestamp service TS using protocol TS.Stamp at time t.
The ﬁrst evidence record is E = (c, T, t).
Timestamp renewal. Before the last timestamp becomes
insecure it must be renewed. In this case, the evidence ser-
vice executes algorithm RenewTs, where the input is the cur-
rent evidence record E. It selects a new timestamp scheme
TS and obtains a timestamp T on E at time t using proto-
col TS.Stamp. Then, it appends (c, T, t) to E, where c is the
last commitment value contained in E.
Time𝑟"𝑟",…,𝑟%&’Document	ownerTimestampservice…𝐶𝑜𝑚𝑚𝑖𝑡"𝐶𝑜𝑚𝑚𝑖𝑡’𝐶𝑜𝑚𝑚𝑖𝑡%𝑐",𝑇",𝑐’𝑐",𝑇",…,𝑐%&’,𝑇%&’,𝑐%𝑇"𝑇’𝑇%…𝑐"Evidenceservice463whenever a connection is established. For integrity proof
construction we use the same notation as in COPRIS, that
is, the document owner maintains a list of decommitment
values R and the evidence service maintains an evidence
record E.
Initial document protection. For initial protection of a
document d, the document owner runs COPRIS.Protect. In-
put is a document d and the (initially empty) list of decom-
mitment values R. The document owner chooses a conﬁ-
dentiality system involving several shareholders. The docu-
ment owner uses protocol Share to distribute (d, R) among
the shareholders.
Renewal of timestamps. COPRIS requires timestamp re-
newal on a regular basis. For this, the evidence service runs
COPRIS.RenewTs.
Renewal of commitments. COPRIS also requires commit-
ment renewal on a regular basis. For this, the document
owner does the following. First, he retrieves d and the se-
quence of decommitment values R from the conﬁdentiality
system by running protocol Retrieve. Then, he runs the
algorithm COPRIS.RenewCom, thereby updating the list of
decommitment values R and the evidence record E. Finally,
the document owner selects a potentially new conﬁdentiality
system and runs protocol Share to distribute the document d
and the updated sequence of decommitment values R among
the shareholders in the conﬁdentiality system.
Renewal of secret shares. The shares stored by the share-
holders are renewed on a regular basis. This prevents a mo-
bile adversary to take advantage of shares he may have been
able to obtain in the past. In this process, the current set
of shareholders of the conﬁdentiality system may also be re-
placed by a new set of shareholders operated by the same
conﬁdentiality system. This resharing is done by running
protocol Reshare.
Veriﬁcation. When the document owner decides to reveal
the document d to a veriﬁer and prove that it existed at time
t, he executes the following steps. He requests the current
evidence record E from the evidence service. He also re-
trieves the document d and the list of decommitment values
R from the conﬁdentiality system by running the protocol
Retrieve. He sends the document d, time t, evidence record
E, and the list of decommitment values R to the veriﬁer over
a private channel. The veriﬁer uses his trust anchor TA and
checks that COPRIS.Verify(TA, d, t, E, R) = 1. This proves
that d existed at time t and has not been changed.
5.
IMPLEMENTATION
In this section we describe our implementation of LINCOS.
LINCOS uses COPRIS for its integrity system and proactive
secret sharing combined with appropriate private channels
for its conﬁdentiality system. One important feature of our
implementation is the possibility of replacing cryptographic
components. This is required because of Assumptions I1
and I2. Another feature is the realization of private channels
using the Tokyo QKD Network [23].
Figure 2: Schematic of LINCOS.
Commitment renewal. Before the last commitment cre-
ated by the document owner becomes insecure, it must be re-
newed. The document owner runs the algorithm RenewCom.
Input is the document d and the decommitment value list
R. The document owner selects a new commitment scheme
CS and computes (c, r) ← CS.Commit(d, R). He appends r
to R and sends c to the evidence service. When the evidence
service receives c, it runs algorithm AddEv. Input is c and
the evidence record E.
Veriﬁcation. When the document owner reveals d to the
veriﬁer, he also transmits the asserted existence time t and
the integrity proof (E, R). Using this information, the veri-
ﬁer can validate the existence of d at time t as follows. Let
R = (r0, . . . , rn) and E = (c0, T0, t0, . . . , cn, Tn, tn).
We describe the veriﬁcation procedure. We deﬁne tn+1 to
be the time of veriﬁcation and for i ∈ {0, . . . , n} we set Ei =
(c0, T0, t0, . . . , ci, Ti, ti) and Ri = (r0, . . . , ri). Furthermore,
for i ∈ {0, . . . , n} let CSi denote the commitment scheme
associated with ci and TSi the timestamp scheme associated
with Ti. The veriﬁer uses his trust anchor TA to verify that
TSi.Verify(TA, (Ei−1, ci), Ti, ti; ti+1) = 1
and
CSi.Verify(TA, (d, Ri−1), ci, ri; ti+1) = 1 ,
for i ∈ {0, . . . , n}. The trust anchor contains the required
root certiﬁcates and commitment scheme parameters.
4. LINCOS: SYSTEM FOR LONG-TERM
INTEGRITY, AUTHENTICITY, AND
CONFIDENTIALITY
In this section we describe our new long-term storage sys-
tem LINCOS which provides information-theoretic conﬁden-
tiality and long-term integrity and authenticity protection.
The security of LINCOS is discussed in Appendix B.
An overview of LINCOS is shown in Figure 2.
It con-
sists of an integrity system, which is based on COPRIS, for
constructing an integrity proof PI, and a conﬁdentiality sys-
tem, which is based on private channels and secret sharing,
for information-theoretic conﬁdential storage of the secret
data. The involved parties are a document owner, an ev-
idence service, a timestamp service, a set of shareholders,
and a veriﬁer. These parties are connected by private or au-
thenticated channels as shown in Figure 2. While LINCOS
is running, the respective channels are instantiated securely
Document ownerTimestamp serviceEvidence servicePrivate channelsShareholder 1Shareholder nVerifierAuthenticated channels...Integrity SystemConfidentiality System4645.1 Implementation of COPRIS
We implemented COPRIS using Java following the speci-
ﬁcation given in Section 3. Here we focus on the selection
of the cryptographic schemes.
Commitment scheme. As commitment scheme we use the
Pedersen commitment scheme [20]. This scheme is compu-
tationally binding and information-theoretically hiding (As-
sumptions I1 and C1). It is parametrized with two prime
numbers p and q and its binding security is based on the
discrete logarithm problem. We use the hash-then-commit
approach to allow for committing to data of arbitrary length.
Our implementation uses the SHA-2 hash function family.
The hash function and the parameters of the commitment
scheme need to be chosen such that computational binding-
ness is achieved for the intended usage period (Assumption
I1). In practice, these choices can be made on the basis of
trustworthy recommendations. For an overview of recom-
mendations see [15].
Timestamp scheme. The timestamp service used by the
evidence service is implemented in accordance with stan-
dard RFC 3161 [1].
Implementing it requires choosing a
hash function and a digital signature scheme. We use the
SHA-2 hash function family and the RSA digital signature
scheme. The security of the used RSA instance depends
on the bitlength of the RSA-modulus. Hash function and
RSA-modulus need to be chosen such that unforgeability is
achieved within the usage period of the timestamp scheme
(Assumption I2).
Authenticated channels. Authenticated channels are real-
ized using TLS [7], instantiated such that computationally
secure mutual authentication is achieved. We do not dis-
cuss parameter choices for TLS because they do not aﬀect
our measurements presented in Section C.
5.2 Secret sharing and private channels
We describe the implementation of the conﬁdentiality sys-
tem of LINCOS that consists of private channels and proac-
tive secret sharing.
Private channels. LINCOS uses private channels to con-
nect the document owner with the shareholders. By As-
sumption C2, these channels are required to provide infor-
mation-theoretic conﬁdentiality and computational authen-
ticity. For establishing such private channels we use the
Tokyo QKD Network [23], which is shown in Figure 3. A
combination of Wegman-Carter authentication, QKD, and
OTP encryption is used to achieve information-theoretic pri-
vate and authenticated channels [24]. The network consists
of three layers; the quantum layer, the key management
layer, and the application layer. Secret sharing is run on
the application layer. Parties on the application layer re-
quest and receive key material from the key management
layer. The key management layer establishes an interface
to the quantum layer where the raw key material is gener-
ated using QKD technology. To improve the capabilities of
the network, keys are relayed on the key management layer
by key management agents. In order to allow for Assump-
tion C2 to hold, further technical protection measures are in
Figure 3: The secret sharing scheme supported by
the Tokyo QKD Network.
place. Further details on the QKD network can be found in
the full paper and [23, 8].
Secret sharing. Our implementation of secret sharing uses
Shamir’s secret sharing [25]. It provides information-theoretic
conﬁdentiality for the stored data (Assumption C3). We use
a (3,4)-threshold secret sharing, suiting the network struc-
ture of the Tokyo QKD Network. This means that the
document owner distributes shares to 4 shareholders and
3 shareholders are needed for the reconstruction of the data.
To allow for sharing data of arbitrary size, these data are
decomposed into parts of appropriate size. Our implemen-
tation supports a basic resharing protocol involving the doc-
ument owner. The document owner ﬁrst retrieves and re-
constructs the data and then generates and distributes new
shares. We assume that resharing happens before the adver-
sary corrupts more than 2 shareholders (Assumption C4). In
the future we plan to implement proactive secret sharing as
suggested in [14] for resharing without the document owner.
6. CONCLUSION
Our experimental evaluation (Appendix C) shows that
the long-term integrity system based on COPRIS has very
good performance,
in particular in view of the expected
growth of computing power; the time and space cost for
time-stamping commitments instead of hash values and for
renewing these commitments is negligible. As expected,
information-theoretic conﬁdentiality protection is expensive.
One limiting factor is the additional space required by secret
sharing. However, it does not exceed the additional storage
space required by cloud storage solutions that use secret
sharing for robustness reasons. The second limiting factor
is QKD. It is technically complex and transmission rates are
not yet fully satisfactory. On the positive side the develop-
ment in this area is promising so that practical solutions can
be expected in the future.
The data that can be protected given that resharing hap-
QKD linkPrivate channelPrivate channelPoint of interface Document ownerKMATrusted node in a vaultSecure key transferAuthenticated classical channelKMSShareholderNEC-0NEC-1NTT-NICTToshibaSeQureNetGakushuin465pens every two years has maximum size sizes = 2 years ∗
keyRateQKD/2 = 1 year ∗ keyRateQKD. For the current key
supply throughput of 40 kb/s we obtain sizes = 158 GB.
This data size approximately corresponds to human genomic
data of 195 persons. In the near future (4 to 5 years), QKD
technology with key rates of 1 Mb/s over 50 km is expected
to be available. Then, data of size up to 3942 GB can be
protected, which is roughly 4 TB or the size of the genomes
of 4926 persons.
If the key supply throughput can be in-
creased to 1 Gb/s, data of size 4 PB can be handled, which
corresponds to human genomic data of 4.9 million persons.
Such a QKD performance can be expected to be realizable
using dense wavelength division multiplexing of 1000 quan-
tum channels as well as fast key distillation processing. This
is a challenge, but will be feasible by employing integrated
photonic technologies and dedicated key distillation engines
on semiconductor chips.
There are two main directions of further research. The
ﬁrst concerns improvement of QKD performance. As men-
tioned, dense wavelength division multiplexing of many quan-
tum channels combined with fast key distillation processing
is promising. The second research direction concerns the
performance of the commitment renewal and resharing pro-
cess. Currently, in both processes the document owner is
required to retrieve the document regularly. However, it is
desirable to take the document owner out of the loop and
let the conﬁdentiality and integrity systems deal with these
issues independently. For proactive secret sharing, we will
use a more advanced resharing protocol, e.g., [12]. It allows
for renewing the shares without the help of the document
owner. We also aim at developing a commitment renewal
protocol that does not involve the document owner.
7. REFERENCES
[1] C. Adams, P. Cain, D. Pinkas, and R. Zuccherato.
Internet X.509 Public Key Infrastructure Time-Stamp
Protocol (TSP). RFC 3161 (Proposed Standard), Aug.
2001. Updated by RFC 5816.
[2] F. Bahr, M. Boehm, J. Franke, and T. Kleinjung.
Factorization of RSA-200. Public announcement on
May 9th, 2005.
[3] M. Bellare and P. Rogaway. Entity authentication and
key distribution. In D. R. Stinson, editor, CRYPTO’
93, pages 232–249, 1994.
[4] G. Brassard, C. Cr´epeau, D. Mayers, and L. Salvail. A
brief review on the impossibility of quantum bit
commitment. arXiv preprint quant-ph/9712023, 1997.
[5] J. Braun, J. Buchmann, C. Mullan, and A. Wiesmaier.
Long term conﬁdentiality: a survey. Designs, Codes
and Cryptography, 71(3):459–478, 2014.
[6] R. Canetti, L. Cheung, D. K. Kaynar, N. A. Lynch,
and O. Pereira. Modeling computational security in
long-lived systems. In CONCUR, 2008.
[7] T. Dierks and E. Rescorla. The Transport Layer
Security (TLS) Protocol Version 1.2. RFC 5246
(Proposed Standard), Aug. 2008. Updated by RFCs
5746, 5878, 6176, 7465, 7507, 7568, 7627, 7685.
[8] M. Fujiwara, A. Waseda, R. Nojima, S. Moriai,
W. Ogata, and M. Sasaki. Unbreakable distributed
storage with quantum key distribution network and
password-authenticated secret sharing. Scientiﬁc
Reports, 6, 2016.
[9] M. Geihs, D. Demirel, and J. Buchmann. A security
analysis of techniques for long-term integrity
protection. In Privacy, Security and Trust 2016, 2016.
[10] O. Goldreich. Foundations of Cryptography – Volume
1, chapter Perfectly Hiding Commitment Schemes.
Cambridge University Press, 2001.