cases from the response set only if there is at least a point in the
middle column. Otherwise, top and bottom are an antipodal pair
(Definition 3.2 and Proposition 2).
In the case of Figure 5a, each region is included in a group of
regions that has a dominance corner and another group of regions
that has an anti-dominance corner. For example, suppose ğ‘ and ğ‘
are in TL, TM, ML, or MM. We have that left is a dominance corner
for the top two rows and bottom in an anti-dominance corner for
the left two rows. Applying our building block method to these two
groups of regions, we determine whether ğ‘ and ğ‘ are in dominance
or anti-dominance relation. In the case of Figure 5a, we can use the
same approach for all regions except MM.
To deal with the remaining case of ğ‘ and ğ‘ within region MM
in the configuration of Figure 5b, we observe that using dominance
corner top or bottom, we can determine if ğ‘ and ğ‘ are in dominance
relation. If so, we are done, else, we find the extreme points of MM
and apply the order reconstruction algorithm recursively to the
points within this region.
4.1 Proof of Theorem 3.5
Now that we have introduced the notion of partitioning the domain,
we present the proof for Theorem 3.5 below.
Proof. Let D be a database and let left, right, top, and bottom
be its four extreme points. Without loss of generality, these points
must take one of the two configurations pictured in Figure 5. Note,
any pointâ€™s relative order can be determined if it is in a dominance
relation with one point and in an anti-dominance relation with
another point. If a point is not in such a relation, then we argue
that the three transformations yield all databases equivalent to D
with respect to the response set.
Case 1: If top and bottom are antipodal, we have the configuration
of Figure 5a or Figure 5b with an empty middle column and the
ordering of all pairs of points is determined with the exception of
the antipodal pair (Transformation 2).
Case 2: If top and bottom are not antipodal, we have two subcases.
Case 2a: If top anti-dominates bottom, we have the configuration
of Figure 5a where the ordering of all pairs of points is determined.
Case 2b: Else, top dominates bottom and we have the configuration
of Figure 5b, where the ordering of all pairs of points is determined
except for pairs in MM. If MM = âˆ… or has a single point, we are
done. Else, let ğ¶ be the subset of points of MM are not in anti-
dominance relation with a point of D not in MM. We have that all
the remaining points of MM have their ordering determined. Also,
ğ¶ comprises one or more components and/or close pairs whose
ordering can be changed by means of Transformations 1 and 3.
Now, let us show that there are no other possible transformations
that change the order of some pair of points ğ‘, ğ‘ in ğ¶, while leav-
ing RS(D) the same. If ğ‘ minimally dominates ğ‘, there exists no
response in RS(D) that contains right and ğ‘ without ğ‘. Any such
transformation would result in one of the following changes: (i) ğ‘
dominates ğ‘, (ii) ğ‘ anti-dominates ğ‘, (iii) ğ‘ anti-dominates ğ‘ and
(iv) ğ‘ and ğ‘ are collinear. If (i), (ii) or (iii), then there would exist a
response in RS(D) that contains right and ğ‘, but not ğ‘, which would
result in a different response set. Thus, the transformation would
make ğ‘ and ğ‘ be collinear. This is possible only if the corresponding
sets ğ‘‹1, ğ‘‹2 and ğ‘‹3 shown in Figure 3c are empty. As ğ‘ minimally
dominates ğ‘, ğ‘‹3 must be empty. Suppose there is some point ğ‘ âˆˆ ğ‘‹1,
then there is a response that contains ğ‘ and ğ‘ without ğ‘ and a re-
sponse that contains ğ‘ and ğ‘ without ğ‘. If ğ‘ and ğ‘ were collinear,
one of those responses becomes impossible, modifying the response
set. A similar argument can be made about ğ‘‹2. We conclude ğ‘ and
ğ‘ are a close pair and that we are applying Transformation 3.
Alternatively, if ğ‘ minimally strictly anti-dominates ğ‘, there ex-
ists a response ğ‘Ÿ1 that contains right and ğ‘ without ğ‘ and a response
ğ‘Ÿ2 that contains right and ğ‘ without ğ‘. The transformations would
result in one of the following: (i) ğ‘ dominates ğ‘, (ii) ğ‘ dominates ğ‘,
(iii) ğ‘ anti-dominates ğ‘ and (iv) ğ‘ and ğ‘ are collinear. In (i), (ii), or
(iv) one of ğ‘Ÿ1 or ğ‘Ÿ2 would not exist, resulting in a different response
set. What is left is case (iii), which implies that the anti-dominance
relationship is flipped by applying Transformation 1.
â–¡
5 Order Reconstruction
We show that the adversary can reconstruct the order of all records
in the database (up to equivalent orders) by using the response set.
The order reconstruction (OR) algorithm has the following steps:
(1) Find the extreme points of the database. (Algorithm 9)
(2) Find the first antichain of the database, which contains all points
that do not dominate any point and generate the dominance
graph of the database. (Algorithm 1)
(3) Find all antichains in the dominance graph. (Algorithm 2)
(4) Build the anti-dominance graph from antichains. (Algorithm 3)
(5) Use the dominance and anti-dominance graphs to find any
antipodal pairs (Proposition 2), close pairs (Proposition 3) and
reflectable components. (Proposition 1). (Algorithm 4)
Note that this attack achieves FDR when the horizontal and
vertical projections of the points are dense.
5.1 Preliminaries
Our OR attack requires computing the IDs of the points dominating
a point in antichain ğ´0. Algorithm 8 (DominanceID), shown in
Appendix A, takes as input the response set RS(D) of a database
D and the ID ğ‘ of some point with height 0, and outputs the set of
identifiers of points that dominate D[ğ‘].
5.2 Find Extreme Points
The first step is to identify at most four identifiers of points with
extreme coordinate values. Specifically, we wish to find identifiers
of points left, right, top and bottom such that for all ğ‘ âˆˆ D the
following hold: (1) left0 â‰¤ ğ‘0 â‰¤ right0 and bottom1 â‰¤ ğ‘1 â‰¤ top1,
and (2) ğ‘ âª¯Ì¸ left, bottom and top, right âª¯Ì¸ ğ‘. Note that since no
points in D are dominated by left and bottom, then their height is
0 and are thus a subset of ğ´0 in the canonical antichain partition of
D. These points give a starting point for computing the rest of ğ´0.
We recover these extremal points by calling Algorithm 7.
Our approach for finding such a subset of identifiers is as follows.
Let ğ¿ and ğ‘†1 be the first and second largest responses in RS(D),
respectively. Then ğ¸1 = ğ¿ âˆ’ ğ‘†1 must correspond to the IDs of points
that are extreme in some coordinate. To find the IDs of points
Session 7C: Database and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2249that are extreme in some other coordinate, find the second largest
response ğ‘†2 that contains ğ¸1, and then compute ğ¸2 = ğ¿ âˆ’ ğ‘†2. By
extending this process, we find all points with extremal coordinates.
It remains to find the correct point within each set ğ¸ğ‘–. Suppose ğ¸1
and ğ¸2 are the left and bottom edges, respectively. By finding ğ‘, ğ‘ âˆˆ
[ğ‘…] such that the smallest response containing ğ‘ and ğ‘ contains no
other edge points, then D[ğ‘] and D[ğ‘] must not be dominating any
other points in D. Hence left = D[ğ‘] and bottom = D[ğ‘]. Similarly
for the identifiers of top and right.
Without loss of generality, we assume that right dominates left.
Algorithm 9, shown in Appendix B, is inspired by [13].
Lemma 5.1. Let D be a database with ğ‘… records and let RS(D) be
its response set. Algorithm 9 (FindExtremePairs) returns all configu-
rations of extreme points (left, right, top, bottom) such that no points
are dominated by left and bottom, and no points dominate right and
top in ğ‘‚(ğ‘…2|RS(D)|) time. [Proof in Appendix C]
5.3 Generate Dominance Graph
This step takes as input the response set RS(D) and some configu-
ration config given by running Algorithm 9 on RS(D), and outputs
a dominance graph ğº of D. We first compute all IDs of points with
height 0. These are the sinks of ğº. Let left, right, and bottom be
given by config. All points not dominated by left and bottom must
be contained in the minimal query containing them.
Then for each ğ‘ âˆˆ ğ´0 we build a subgraph of the dominance
graph on ğ‘ and all IDs that dominate ğ‘. We use Algorithm 8, de-
scribed in Appendix A, to compute this set of IDs. We initialize
subgraph ğºğ‘ = {ğ‘} and then extend the graph by finding the next
smallest response resp containing ğ‘, that also contains some ID
ğ‘£ not yet added to the graph. Since resp is minimal, then ğ‘£ must
dominate everything in the response. Moreover, ğ‘£ must minimally
dominate all IDs that are sinks in the current ğºğ‘ and are contained
in resp. We add (ğ‘¡, ğ‘£) to ğºğ‘ for all sinks ğ‘¡ of ğºğ‘ contained in resp.
Once graphs ğºğ‘ for ğ‘ âˆˆ ğ´0 have been computed, we take their
union, ğº = âˆªğ‘ğºğ‘, as the dominance graph and return ğº and ğ´0.
Lemma 5.2. Let D be a database with ğ‘… records, RS(D) be its re-
sponse set, and config the correct configuration output by Algorithm 9
on RS(D). Given RS(D) and config, Algorithm 1 (DomGraph) re-
turns the dominance graph of the points in D in ğ‘‚(ğ‘…3|RS(D)|) time.
[Proof in Appendix C]
5.4 Construct Antichains
Given ğ´0, we now compute the entire canonical antichain partition
of D. We explain how to find the partition A = (ğ´0, . . . , ğ´ğ¿) such
that ğ¿ is the maximum height of any element in D. Computing each
ğ´ğ‘– is equivalent to finding the set of elements whose maximum
length path in ğº from any ğ‘ âˆˆ ğ´0 has length ğ‘–. Thus, for each
ğ‘ âˆˆ ğº we compute the longest path in ğº from any ğ‘ âˆˆ ğ´0 to ğ‘ and
then add ğ‘ to the correct partition in A. Lastly, order the elements
in each antichain ğ´ âˆˆ A such that, without loss of generality,
for any pair of ordered elements ğ‘ and ğ‘â€², ğ‘â€² antidominates ğ‘ i.e.
ğ‘ âª¯ğ‘ ğ‘â€². If |ğ´| â‰¤ 2 we are done. Else we compute all responses
that contain exactly two elements in ğ´. If such a response exists
for a pair ğ‘, ğ‘â€² âˆˆ ğ´ then we can infer that there exists no ğ‘â€²â€² âˆˆ ğ´
such that ğ‘ âª¯ğ‘ ğ‘â€²â€² âª¯ğ‘ ğ‘â€². Thus we may use these responses to
determine the ordering of the elements in ğ´ such that any element
must anti-dominate all previous elements in the ordering.
Algorithm 1: DomGraph(RS(D), config)
Input: Response set RS(D) of database D; a dictionary config mapping
left, right, top, bottom to IDs.
Let ğ‘† be the smallest response that contains right and ğ‘.
1: // Find antichain-0. We assume right dominates left.
2: Let small be the smallest response containing left and bottom.
3: Let ğ´0 = small
4: for ğ‘ âˆˆ small do
5:
6: ğ‘„ = (ğ‘† âˆ© small) âˆ’ {ğ‘}
7: ğ´0 = ğ´0 âˆ’ ğ‘„
8: // Find dominance graph.
9: Let ğº be an empty graph
10: for each ğ‘ âˆˆ ğ´0 do
11: ğºğ‘ = (ğ‘‰ , ğ¸) such that ğ‘‰ğ‘ = {ğ‘} and ğ¸ğ‘ = âˆ….
ğ‘† = DominanceID(ğ‘, top, left, right, RS(D))
12:
Let ğ‘…ğ‘† âŠ† RS(D) comprise the responses of size at least 2 that
13:
contain ğ‘ and only other IDs in ğ‘†.
for resp âˆˆ ğ‘…ğ‘† by increasing size do
if âˆƒğ‘£ âˆˆ resp such that ğ‘£ âˆ‰ ğºğ‘ then
Add vertex ğ‘£ to ğºğ‘
for each ğ‘¡ of resp such that ğ‘¡ is a sink of subgraph of ğºğ‘ that
contains only points in resp do
Add edge (ğ‘¡, ğ‘£) to ğºğ‘.
18:
19: ğº = âˆªğ‘âˆˆğ´0ğºğ‘, and remove any transitive edges
20: return ğº, ğ´0
14:
15:
16:
17:
Lemma 5.3. Let D be a database and RS(D) be its response set.
Given RS(D), a dominance graph ğº of D, and the minimal antichain
ğ´0, Algorithm 2 (FindAntichains) returns a dictionary Antichains
such that Antichains[ğ‘–] contains an ordered list of all IDs at height ğ‘–
in ğ‘‚(ğ‘…2|RS(D)|) time. [Proof in Appendix C]
Algorithm 2: FindAntichains(RS(D), ğº, ğ´0)
1: // Find antichains.
2: (ğ‘‰ , ğ¸) = ğº, Antichains = {}, Antichains[0] = ğ´0
3: Compute longest pathsâˆˆ ğº from all ğ‘ âˆˆ ğ´0 to all points in D.
4: ğ¿ = 0
5: for each ğ‘ âˆˆ ğ‘‰ do
6:
7: Add ğ‘ to Antichains[â„“]
8:
9: // Order the points of Antichains[ğ‘–].
10: for ğ‘– = 0, Â· Â· Â· , ğ¿ do
11:
12:
Let â„“ be the length of the longest path to ğ‘ from any ğ‘ âˆˆ ğ´0.
ğ¿ = max(ğ¿, â„“)
if |Antichains[ğ‘–]| > 3 then
Let ğ‘† be all responses in RS(D) that contain exactly two elements
of Antichains[ğ‘–] (and perhaps other points)
Remove all ğ‘ âˆ‰ Antichains[ğ‘–] from ğ‘† and make ğ‘† a set.
Order Antichains[ğ‘–] such that pairs of consecutive points are
responses in ğ‘†.
15: return Antichains
13:
14:
5.5 Generate Anti-Dominance Graph
The next step is to take the response set RS(D), the dominance
graph ğº, and the canonical antichain partition Antichains and con-
struct the corresponding anti-dominance graph. There are three
major steps that we must take: (1) fix the antichain orientations so
that they are lined up correctly, (2) add any edges between IDs of
different antichains that are in an anti-dominance relationship, and
(3) identify colinearities.
Session 7C: Database and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea22501, ğ‘â€²