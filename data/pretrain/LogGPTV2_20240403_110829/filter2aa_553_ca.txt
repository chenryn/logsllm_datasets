658
10.2 多维数组
气象研究员Tempest Cloud为完成她的研究项目要分析5年内每个月的降
水量数据，她首先要解决的问题是如何表示数据。一个方案是创建60个变
量，每个变量储存一个数据项（我们曾经提到过这一笨拙的方案，和以前一
样，这个方案并不合适）。使用一个内含60个元素的数组比将建60个变量
好，但是如果能把各年的数据分开储存会更好，即创建5个数组，每个数组
12个元素。然而，这样做也很麻烦，如果Tempest决定研究50年的降水量，
岂不是要创建50个数组。是否能有更好的方案？
处理这种情况应该使用数组的数组。主数组（master array）有5个元素
（每个元素表示一年），每个元素是内含12个元素的数组（每个元素表示一
个月）。下面是该数组的声明：
float rain[5][12]; // 内含5个数组元素的数组，每个数组元素内含12个
float类型的元素
理解该声明的一种方法是，先查看中间部分（粗体部分）：
float rain[5][12]; // rain是一个内含5个元素的数组
这说明数组rain有5个元素，至于每个元素的情况，要查看声明的其余
部分（粗体部分）：
floatrain[5][12] ; // 一个内含12个float类型元素的数组
这说明每个元素的类型是float[12]，也就是说，rain的每个元素本身都
是一个内含12个float类型值的数组。
根据以上分析可知，rain的首元素rain[0]是一个内含12个float类型值的
数组。所以，rain[1]、rain[2]等也是如此。如果 rain[0]是一个数组，那么它
的首元素就是 rain[0][0]，第 2 个元素是rain[0][1]，以此类推。简而言之，
数组rain有5个元素，每个元素都是内含12个float类型元素的数组，rain[0]是
659
内含12个float值的数组，rain[0][0]是一个float类型的值。假设要访问位于2
行3列的值，则使用rain[2][3]（记住，数组元素的编号从0开始，所以2行指
的是第3行）。
图10.1 二维数组
该二维视图有助于帮助读者理解二维数组的两个下标。在计算机内部，
这样的数组是按顺序储存的，从第1个内含12个元素的数组开始，然后是第2
个内含12个元素的数组，以此类推。
我们要在气象分析程序中用到这个二维数组。该程序的目标是，计算每
年的总降水量、年平均降水量和月平均降水量。要计算年总降水量，必须对
一行数据求和；要计算某月份的平均降水量，必须对一列数据求和。二维数
组很直观，实现这些操作也很容易。程序清单10.7演示了这个程序。
程序清单10.7 rain.c程序
/* rain.c -- 计算每年的总降水量、年平均降水量和5年中每月的平均降
水量 */
#include 
660
#define MONTHS 12   // 一年的月份数
#define YEARS  5    // 年数
int main(void)
{
// 用2010～2014年的降水量数据初始化数组
const float rain[YEARS][MONTHS] =
{
{ 4.3, 4.3, 4.3, 3.0, 2.0, 1.2, 0.2, 0.2, 0.4, 2.4, 3.5, 
6.6 },
{ 8.5, 8.2, 1.2, 1.6, 2.4, 0.0, 5.2, 0.9, 0.3, 0.9, 1.4, 
7.3 },
{ 9.1, 8.5, 6.7, 4.3, 2.1, 0.8, 0.2, 0.2, 1.1, 2.3, 6.1, 
8.4 },
{ 7.2, 9.9, 8.4, 3.3, 1.2, 0.8, 0.4, 0.0, 0.6, 1.7, 4.3, 
6.2 },
{ 7.6, 5.6, 3.8, 2.8, 3.8, 0.2, 0.0, 0.0, 0.0, 1.3, 2.6, 
5.2 }
};
int year, month;
float subtot, total;
printf(" YEAR   RAINFALL  (inches)\n");
661
for (year = 0, total = 0; year 
#define SIZE 4
int main(void)
{
short dates[SIZE];
short * pti;
667
short index;
double bills[SIZE];
double * ptf;
pti = dates; // 把数组地址赋给指针
ptf = bills;
printf("%23s %15s\n", "short", "double");
for (index = 0; index < SIZE; index++)
printf("pointers + %d: %10p %10p\n", index, pti + index, 
ptf + index);
return 0;
}
下面是该例的输出示例：
short        double
pointers + 0: 0x7fff5fbff8dc 0x7fff5fbff8a0
pointers + 1: 0x7fff5fbff8de 0x7fff5fbff8a8
pointers + 2: 0x7fff5fbff8e0 0x7fff5fbff8b0
pointers + 3: 0x7fff5fbff8e2 0x7fff5fbff8b8
第2行打印的是两个数组开始的地址，下一行打印的是指针加1后的地
址，以此类推。注意，地址是十六进制的，因此dd比dc大1，a1比a0大1。但
是，显示的地址是怎么回事？
668
0x7fff5fbff8dc + 1是否是0x7fff5fbff8de?
0x7fff5fbff8a0 + 1是否是0x7fff5fbff8a8?
我们的系统中，地址按字节编址，short类型占用2字节，double类型占
用8字节。在C中，指针加1指的是增加一个存储单元。对数组而言，这意味
着把加1后的地址是下一个元素的地址，而不是下一个字节的地址（见图
10.3）。这是为什么必须声明指针所指向对象类型的原因之一。只知道地址
不够，因为计算机要知道储存对象需要多少字节（即使指针指向的是标量变
量，也要知道变量的类型，否则*pt 就无法正确地取回地址上的值）。
图10.3 数组和指针加法
现在可以更清楚地定义指向int的指针、指向float的指针，以及指向其他
数据对象的指针。
指针的值是它所指向对象的地址。地址的表示方式依赖于计算机内部的
669
硬件。许多计算机（包括PC和Macintosh）都是按字节编址，意思是内存中
的每个字节都按顺序编号。这里，一个较大对象的地址（如double类型的变
量）通常是该对象第一个字节的地址。
在指针前面使用*运算符可以得到该指针所指向对象的值。
指针加1，指针的值递增它所指向类型的大小（以字节为单位）。
下面的等式体现了C语言的灵活性：
dates + 2 == &date[2]    // 相同的地址
*(dates + 2) == dates[2]  // 相同的值
以上关系表明了数组和指针的关系十分密切，可以使用指针标识数组的
元素和获得元素的值。从本质上看，同一个对象有两种表示法。实际上，C
语言标准在描述数组表示法时确实借助了指针。也就是说，定义ar[n]的意思
是*(ar + n)。可以认为*(ar + n)的意思是“到内存的ar位置，然后移动n个单
元，检索储存在那里的值”。
顺带一提，不要混淆 *(dates+2)和*dates+2。间接运算符（*）的优先级
高于+，所以*dates+2相当于(*dates)+2：
*(dates + 2) // dates第3个元素的值
*dates + 2  // dates第1个元素的值加2
明白了数组和指针的关系，便可在编写程序时适时使用数组表示法或指
针表示法。运行程序清单 
10.9后输出的结果和程序清单10.1输出的结果相
同。
程序清单10.9 day_mon3.c程序
/* day_mon3.c -- uses pointer notation */
670