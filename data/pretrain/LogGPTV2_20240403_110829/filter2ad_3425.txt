title:Scalable and Secure Concurrent Evaluation of History-based Access
Control Policies
author:Maarten Decat and
Bert Lagaisse and
Wouter Joosen
Scalable and Secure 
Concurrent Evaluation  
of History-based  
Access Control Policies 
Maarten Decat, Bert Lagaisse, Wouter Joosen 
KU Leuven, Belgium 
PI:EMAIL 
Context 
Access control: 
enforce access rules  
Application 
Read 
Subjects 
Resources 
Policies 
2 
Context 
Load balancer 
Application 
Application 
Application 
Application 
Application 
Database 
Database 
Database 
Database 
Database 
Policy 
Decision Point 
3 
Context 
Load balancer 
Application 
Application 
Application 
Application 
Application 
Database 
Policy 
Decision Point 
Database 
Database 
Policy 
Decision Point 
Policy 
Decision Point 
Database 
Policy 
Database  
Policy 
Decision Point 
Decision Point 
4 
Problem 
5 
Problem 
Not all policies are read-only: 
history-based policies 
“a user cannot watch more than 10 movies per month” 
“an article cannot be shared more than 5 times” 
“if a user has had access to documents of Bank A, he or 
she is not allowed to access documents of Bank B” 
(Dynamic SoD) 
6 
Problem 
Subject1 -> doc of Bank A 
Subject1 -> doc of Bank B 
read subj.history  // (= []) 
… // evaluate policy = permit  
append “Bank A” to subj.history 
return permit 
read subj.history  // (= [“Bank A”]) 
… // evaluate policy = deny 
return deny 
7 
Problem 
Subject1 -> doc of Bank A 
Subject1 -> doc of Bank B 
read subj.history  // (= []) 
… // evaluate policy = permit  
append “Bank A” to subj.history 
return permit 
read subj.history  // (= []) 
… // evaluate policy = permit  
append “Bank B” to subj.history 
return permit 
Read-write conflict 
8 
Goal 
 We need concurrency control 
 Possible approach: model policy evaluations as 
transactions on the underlying database 
 However: serial equivalence does not scale   
 E.g., MySQL: single master server for transactions 
 E.g., Cassandra, MongoDB: compare-and-set on single 
database elements 
 we need a domain-specific form of concurrency  
control to achieve both serial equivalence and 
scalability 
9 
Approach 
10 
Approach 
When resource.owner == “Bank B”, 
apply DenyOverrides to 
Deny if 
Permit performing  
“Bank A” in subject.history 
append(“Bank B”, subject.history) 
Attributes 
Obligations 
 Goal: detect and contain read-write conflicts for 
the same attribute in parallel policy evaluations 
11 
Possible tactics 
1.
2.
Locks 
(Multi-version) time-stamp ordering 
3. Optimistic concurrency control 
 Check for conflicts before committing 
 Roll back any updates in case of conflict 
 Reasons: 
• Fits the structure of a policy evaluation: all attribute 
updates are performed after all reads 
• Does not block policy evaluations 
• Does not rely on database functionality 
12 
Basic approach 
Optimistic 
concurrency 
control 
Application 
1 
9 
Coordinator 
3 
5 
Worker 
8 
6 
2 
t
n
o
p
i
n
o
i
s
i
c
e
d
y
c
i
l
o
P
4 
7 
Attribute db 
13 
Centralized coordinator 
Application 
Application 
Application 
Coordinator 
Worker  Worker 
Worker  Worker 
14 
Centralized coordinator 
Application 
Application 
Application 
Coordinator 
Worker  Worker 
Worker  Worker 
Worker  Worker 
Worker  Worker 
Worker  Worker 
Worker  Worker 
15 
Scalable distributed coordinator 
 Observations: 
 Every policy evaluation reasons about exactly  
1 subject and 1 resource 
 Distribute these two parts over  
two collaborating coordinators 
16 
Scalable concurrency control 
Responsible coordinator 
based on hash of id of 
subject/resource 
Application 
Coordinator 
14 
4 
Coordinator 
3 
9 
Worker 
Worker 
2 
10 
12 
8 
13 
11 
Attribute db 
1 
5 
Coordinator 
Coordinator 
6 
Worker 
7 
Worker 
17 
Scalable concurrency control 
Application 
Application 
Application 
Coordinator 
Coordinator 
Coordinator 
Worker  Worker 
Worker  Worker 
Worker  Worker 
Worker  Worker 
Worker  Worker 
Worker  Worker 
18 
Scalable concurrency control 
Application 
Application 
Application 
Coordinator 
Coordinator 
Coordinator 
Worker  Worker 
Worker  Worker 
Worker  Worker 
Worker  Worker 
Worker  Worker 
Worker  Worker 
19 
Scalable concurrency control 
Application 
Application 
Application 
Coordinator 
Coordinator 
Coordinator 
Worker  Worker 
Worker  Worker 
Worker  Worker 
Worker  Worker 
Worker  Worker 
Worker  Worker 
20 
Performance evaluation 
21 
Prototype and test set-up 
 Prototype: 
 STAPL policy language [ https://github.com/stapl-dsl/ ] 
 Akka actor framework for concurrency and 
distributed communication 
 Test set-up: 
 Run tests on VMs until statistically relevant 
 Employ realistic policy from e-health case study 
[ https://people.cs.kuleuven.be/∼maarten.decat/acsac2015/ ] 
22 
Results 
Client 
Client 
Coordinator 
Worker  Worker 
Worker  Worker 
23 
Results 
Client 
Client 
Coordinator 
Worker  Worker 
Worker 
Worker  Worker 
Worker  Worker 
Worker 
Worker  Worker 
Worker  Worker 
Worker 
Worker  Worker 
24 
Results 
Client 
Client 
Coordinator 
Coordinator 
Coordinator 
Worker  Worker 
Worker 
Worker  Worker 
Worker  Worker 
Worker 
Worker  Worker 
Worker  Worker 
Worker 
Worker  Worker 
25 
Results 
Client 
Client 
Coordinator 
Coordinator 
Coordinator 
Worker  Worker 
Worker 
Worker  Worker 
Worker  Worker 
Worker 
Worker  Worker 
Worker  Worker 
Worker 
Worker  Worker 
Asymptotic 
maximal latency 
26 
Conclusions 
27 
Conclusions 
 Goal: applying policy-based access control on 
large-scale distributed systems 
 Focus: address concurrency issues that can arise 
for history-based access control policies 
 Contribution: a domain-specific scheme for 
concurrency control that: 
 prevents incorrect decisions 
 can scale to a large number of machines 
 introduces a limited and asymptotically bounded 
latency overhead 
28 
Scalable and Secure 
Concurrent Evaluation  
of History-based  
Access Control Policies 
Maarten Decat, Bert Lagaisse, Wouter Joosen 
KU Leuven, Belgium 
PI:EMAIL