过程是：
x = FOUR;
1200
变成了：
x = TWO*TWO;
即是：
x = 2*2;
宏展开到此处为止。由于编译器在编译期对所有的常量表达式（只包含
常量的表达式）求值，所以预处理器不会进行实际的乘法运算，这一过程在
编译时进行。预处理器不做计算，不对表达式求值，它只进行替换。
注意，宏定义还可以包含其他宏（一些编译器不支持这种嵌套功能）。
程序中的下一行：
printf (FMT, x);
变成了：
printf("X is %d.\n",x);
相应的字符串替换了 FMT。如果要多次使用某个冗长的字符串，这种
方法比较方便。另外，也可以用下面的方法：
const char * fmt = "X is %d.\n";
然后可以把fmt作为printf()的格式字符串。
下一行中，用相应的字符串替换OW。双引号使替换的字符串成为字符
串常量。编译器把该字符串储存在以空字符结尾的数组中。因此，下面的指
令定义了一个字符常量：
#define HAL 'Z'
而下面的指令则定义了一个字符串（Z\0）：
1201
#define HAP "Z"
在程序示例16.1中，我们在一行的结尾加一个反斜杠字符使该行扩展至
下一行：
#define OW "Consistency is the last refuge of the unimagina\
tive.- Oscar Wilde"
注意，第2行要与第1行左对齐。如果这样做：
#define OW "Consistency is the last refuge of the unimagina\
tive.- Oscar Wilde"
那么输出的内容是：
Consistency is the last refuge of the unimagina tive.- Oscar Wilde
第2行开始到tive之间的空格也算是字符串的一部分。
一般而言，预处理器发现程序中的宏后，会用宏等价的替换文本进行替
换。如果替换的字符串中还包含宏，则继续替换这些宏。唯一例外的是双引
号中的宏。因此，下面的语句：
printf("TWO: OW");
打印的是TWO: OW，而不是打印：
2: Consistency is the last refuge of the unimaginative.- Oscar Wilde
要打印这行，应该这样写：
printf("%d: %s\n", TWO, OW);
这行代码中，宏不在双引号内。
1202
那么，何时使用字符常量？对于绝大部分数字常量，应该使用字符常
量。如果在算式中用字符常量代替数字，常量名能更清楚地表达该数字的含
义。如果是表示数组大小的数字，用符号常量后更容易改变数组的大小和循
环次数。如果数字是系统代码（如，EOF），用符号常量表示的代码更容易
移植（只需改变EOF的定义）。助记、易更改、可移植，这些都是符号常量
很有价值的特性。
C语言现在也支持const关键字，提供了更灵活的方法。用const可以创建
在程序运行过程中不能改变的变量，可具有文件作用域或块作用域。另一方
面，宏常量可用于指定标准数组的大小和const变量的初始值。
#define LIMIT 20
const int LIM = 50;
static int data1[LIMIT];    // 有效
static int data2[LIM];     // 无效
const int LIM2 = 2 * LIMIT;  // 有效
const int LIM3 = 2 * LIM;   // 无效
这里解释一下上面代码中的“无效”注释。在C中，非自动数组的大小应
该是整型常量表达式，这意味着表示数组大小的必须是整型常量的组合（如
5）、枚举常量和sizeof表达式，不包括const声明的值（这也是C++和C的区
别之一，在C++中可以把const值作为常量表达式的一部分）。但是，有的实
现可能接受其他形式的常量表达式。例如，GCC 4.7.3不允许data2的声明，
但是Clang 4.6允许。
16.2.1 记号
从技术角度来看，可以把宏的替换体看作是记号（token）型字符串，
而不是字符型字符串。C预处理器记号是宏定义的替换体中单独的“词”。用
1203
空白把这些词分开。例如：
#define FOUR 2*2
该宏定义有一个记号：2*2序列。但是，下面的宏定义中：
#define SIX 2 * 3
有3个记号：2、*、3。
替换体中有多个空格时，字符型字符串和记号型字符串的处理方式不
同。考虑下面的定义：
#define EIGHT 4 * 8
如果预处理器把该替换体解释为字符型字符串，将用4 * 8替换EIGHT。
即，额外的空格是替换体的一部分。如果预处理器把该替换体解释为记号型
字符串，则用3个的记号4 * 8（分别由单个空格分隔）来替换EIGHT。换而
言之，解释为字符型字符串，把空格视为替换体的一部分；解释为记号型字
符串，把空格视为替换体中各记号的分隔符。在实际应用中，一些C编译器
把宏替换体视为字符串而不是记号。在比这个例子更复杂的情况下，两者的
区别才有实际意义。
顺带一提，C编译器处理记号的方式比预处理器复杂。由于编译器理解
C语言的规则，所以不要求代码中用空格来分隔记号。例如，C编译器可以
把2*2直接视为3个记号，因为它可以识别2是常量，*是运算符。
16.2.2 重定义常量
假设先把LIMIT定义为20，稍后在该文件中又把它定义为25。这个过程
称为重定义常量。不同的实现采用不同的重定义方案。除非新定义与旧定义
相同，否则有些实现会将其视为错误。另外一些实现允许重定义，但会给出
警告。ANSI标准采用第1种方案，只有新定义和旧定义完全相同才允许重定
义。
1204
具有相同的定义意味着替换体中的记号必须相同，且顺序也相同。因
此，下面两个定义相同：
#define SIX 2 * 3
#define SIX 2 * 3
这两条定义都有 3 个相同的记号，额外的空格不算替换体的一部分。而
下面的定义则与上面两条宏定义不同：
#define SIX 2*3
这条宏定义中只有一个记号，因此与前两条定义不同。如果需要重定义
宏，使用#undef 指令（稍后讨论）。
如果确实需要重定义常量，使用const关键字和作用域规则更容易些。
1205
16.3 在#define中使用参数
在#define中使用参数可以创建外形和作用与函数类似的类函数宏。带有
参数的宏看上去很像函数，因为这样的宏也使用圆括号。类函数宏定义的圆
括号中可以有一个或多个参数，随后这些参数出现在替换体中，如图16.2所
示。
图16.2 函数宏定义的组成
下面是一个类函数宏的示例：
#define SQUARE(X) X*X
在程序中可以这样用：
z = SQUARE(2);
这看上去像函数调用，但是它的行为和函数调用完全不同。程序清单
16.2演示了类函数宏和另一个宏的用法。该示例中有一些陷阱，请读者仔细
阅读序。
程序清单16.2 mac_arg.c程序
/* mac_arg.c -- 带参数的宏 */
#include 
#define SQUARE(X) X*X
1206
#define PR(X)  printf("The result is %d.\n", X)
int main(void)
{
int x = 5;
int z;
printf("x = %d\n", x);
z = SQUARE(x);
printf("Evaluating SQUARE(x): ");
PR(z);
z = SQUARE(2);
printf("Evaluating SQUARE(2): ");
PR(z);
printf("Evaluating SQUARE(x+2): ");
PR(SQUARE(x + 2));
printf("Evaluating 100/SQUARE(2): ");
PR(100 / SQUARE(2));
printf("x is %d.\n", x);
printf("Evaluating SQUARE(++x): ");
PR(SQUARE(++x));
1207
printf("After incrementing, x is %x.\n", x);
return 0;
}
SQUARE宏的定义如下：
#define SQUARE(X) X*X
这里，SQUARE 是宏标识符，SQUARE(X)中的 X 是宏参数，X*X 是替
换列表。程序清单 16.2 中出现SQUARE(X)的地方都会被X*X替换。这与前
面的示例不同，使用该宏时，既可以用X，也可以用其他符号。宏定义中的
X由宏调用中的符号代替。因此，SQUARE(2)替换为2*2，X实际上起到参数
的作用。
然而，稍后你将看到，宏参数与函数参数不完全相同。下面是程序的输
出。注意有些内容可能与我们的预期不符。实际上，你的编译器输出甚至与
下面的结果完全不同。
x = 5
Evaluating SQUARE(x): The result is 25.
Evaluating SQUARE(2): The result is 4.
Evaluating SQUARE(x+2): The result is 17.
Evaluating 100/SQUARE(2): The result is 100.
x is 5.
Evaluating SQUARE(++x): The result is 42.
After incrementing, x is 7.
1208
前两行与预期相符，但是接下来的结果有点奇怪。程序中设置x的值为
5，你可能认为SQUARE(x+2)应该是 7*7，即 49。但是，输出的结果是 17，
这不是一个平方值！导致这样结果的原因是，我们前面提到过，预处理器不
做计算、不求值，只替换字符序列。预处理器把出现x的地方都替换成x+2。
因此，x*x变成了x+2*x+2。如果x为5，那么该表达式的值为：
5+2*5+2 = 5 + 10 + 2 = 17
该例演示了函数调用和宏调用的重要区别。函数调用在程序运行时把参
数的值传递给函数。宏调用在编译之前把参数记号传递给程序。这两个不同
的过程发生在不同时期。是否可以修改宏定义让SQUARE(x+2)得36？当然
可以，要多加几个圆括号：
#define SQUARE(x) (x)*(x)
现在SQUARE(x+2)变成了(x+2)*(x+2)，在替换字符串中使用圆括号就得
到符合预期的乘法运算。
但是，这并未解决所有的问题。下面的输出行：
100/SQUARE(2)
将变成：
100/2*2
根据优先级规则，从左往右对表达式求值：(100/2)*2，即50*2，得
100。把SQUARE(x)定义为下面的形式可以解决这种混乱：
#define SQUARE(x) (x*x)
这样修改定义后得100/(2*2)，即100/4，得25。
要处理前面的两种情况，要这样定义：
1209
#define SQUARE(x) ((x)*(x))
因此，必要时要使用足够多的圆括号来确保运算和结合的正确顺序。
尽管如此，这样做还是无法避免程序中最后一种情况的问题。
SQUARE(++x)变成了++x*++x，递增了两次x，一次在乘法运算之前，一次
在乘法运算之后：
++x*++x = 6*7 = 42
由于标准并未对这类运算规定顺序，所以有些编译器得 7*6。而有些编
译器可能在乘法运算之前已经递增了x，所以7*7得49。在C标准中，对该表
达式求值的这种情况称为未定义行为。无论哪种情况，x的开始值都是5，虽
然从代码上看只递增了一次，但是x的最终值是7。
解决这个问题最简单的方法是，避免用++x 作为宏参数。一般而言，不
要在宏中使用递增或递减运算符。但是，++x可作为函数参数，因为编译器
会对++x求值得5后，再把5传递给函数。
16.3.1 用宏参数创建字符串：#运算符
下面是一个类函数宏：
#define PSQR(X) printf("The square of X is %d.\n", ((X)*(X)));
假设这样使用宏：
PSQR(8);
输出为：
The square of X is 64.
注意双引号字符串中的X被视为普通文本，而不是一个可被替换的记
号。
1210
C允许在字符串中包含宏参数。在类函数宏的替换体中，#号作为一个
预处理运算符，可以把记号转换成字符串。例如，如果x是一个宏形参，那
么#x就是转换为字符串"x"的形参名。这个过程称为字符串化
（stringizing）。程序清单16.3演示了该过程的用法。
程序清单16.3 subst.c程序
/* subst.c -- 在字符串中替换 */
#include 
#define PSQR(x) printf("The square of " #x " is %d.\n",((x)*(x)))
int main(void)
{
int y = 5;
PSQR(y);
PSQR(2 + 4);
return 0;
}
该程序的输出如下：
The square of y is 25.
The square of 2 + 4 is 36.
调用第1个宏时，用"y"替换#x。调用第2个宏时，用"2 
+ 
4"替换#x。
ANSI C字符串的串联特性将这些字符串与printf()语句的其他字符串组合，生
成最终的字符串。例如，第1次调用变成：
1211
printf("The square of " "y" " is %d.\n",((y)*(y)));
然后，字符串串联功能将这3个相邻的字符串组合成一个字符串：
"The square of y is %d.\n"
16.3.2 预处理器黏合剂：##运算符
与#运算符类似，##运算符可用于类函数宏的替换部分。而且，##还可
用于对象宏的替换部分。##运算符把两个记号组合成一个记号。例如，可以
这样做：
#define XNAME(n) x ## n
然后，宏XNAME(4)将展开为x4。程序清单16.4演示了##作为记号粘合
剂的用法。
程序清单16.4 glue.c程序
// glue.c -- 使用##运算符
#include 
#define XNAME(n) x ## n
#define PRINT_XN(n) printf("x" #n " = %d\n", x ## n);
int main(void)
{
int XNAME(1) = 14;   // 变成 int x1 = 14;