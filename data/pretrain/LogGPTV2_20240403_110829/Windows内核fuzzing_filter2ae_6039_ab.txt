API之间进行转换。第一个版本于2016年发布，其中包含2个驱动程序：lxcore和lxss。
它是旨在为开发人员运行bash和核心Linux命令而设计的。
WSLv1使用一个称为pico process的轻量级进程来托管Linux二进制文件，并使用称为pico provider的专用驱动程序处理来自pico
process的系统调用（有关更多信息，请参见这里：[1](https://channel9.msdn.com/Blogs/Seth-Juarez/Windows-Subsystem-for-Linux-Architectural-Overview)，[2](https://docs.microsoft.com/en-us/archive/blogs/wsl/windows-subsystem-for-linux-overview)）。
###  为什么选择WSL
由于WSL比较类似于Linux内核，因此我们可以重用Linux的大多数现有语法以及与Linux环境兼容的syz-executor和syz-fuzzer二进制文件。
我们想找到特权提升（PE）的漏洞，但WSL v1默认情况下不提供，而且可能很难从沙箱中利用它，因为它运行在不同类型的进程（PICO
process）中。但是我们认为最好在 Windows 上以最少的改动获得 Syzkaller 的使用经验。
## 移植
首先，我们从Microsoft商店安装Linux发行版，选择Ubuntu系统。使用” _apt install openssh-server_
“命令添加ssh服务器，并配置ssh密钥。接下来，我们想添加覆盖率跟踪支持。不幸的是，Windows内核是闭源的，不提供像Linux中的KCOV这样的编译时插桩。
我们想到了一些可以帮助我们获得覆盖率跟踪的替代方法:
• 使用QEMU/BOCHS之类的模拟器并添加覆盖率检测。
• 使用像[pe-afl](https://github.com/wmliang/pe-afl)中一样的静态二进制插桩。
• 使用像[apple-pie](https://github.com/gamozolabs/applepie)中一样具有覆盖率采样的hypervisor虚拟机管理程序。
• 使用像Intel-PT一样的覆盖率硬件支持。
我们决定使用[Intel-PT](https://software.intel.com/en-us/blogs/2013/09/18/processor-tracing)，因为它提供运行时编译二进制文件的跟踪，而且速度相对较快，并且可以提供完整的覆盖率信息，这意味着我们可以按原始顺序获取访问的每个基本块的起始指令指针（IP）。
从运行目标OS的VM内部使用Intel-PT，需要对KVM进行一些修改。我们使用了大部分的kAFL kvm补丁来支持Intel-PT的覆盖率。
另外，我们通过hypercalls创建了一个类KCOV的接口，因此当executor尝试启动、停止或收集覆盖率时，它会发出hypercalls。
###  符号器＃1
我们需要一个可预见的bug，以使我们能够检测出崩溃。Syzkaller崩溃检测机制读取VM控制台的输出，并依赖于预定义的正则表达式来检测内核错误、警告等。
我们需要一个用于移植的崩溃检测机制，这样我们就可以向输出控制台打印Syzkaller捕捉到的警告。
为了检测BSOD，我们使用了kAFL的技术。我们使用一段shellcode对BugCheck和BugCheckEx进行补丁修补，该shellcode会发出hypercall并通过向QEMU输出控制台写入一条唯一的消息来通知发生了崩溃。
我们在syz-manager中添加了一个正则表达式用来检测来自QEMU输出控制台的崩溃消息。为了改进对内核错误的检测，我们还使用了带有特殊池的[Driver
Verifier](https://docs.microsoft.com/en-us/windows-hardware/drivers/devtest/driver-verifier)来检测池损坏(“verifier /flags 0x1 /driver
lxss.sys lxcore.sys”)。
Fuzzer的一个常见问题是会多次遇到同一bug。为了避免重复的bug，对于每次崩溃Syzkaller都需要唯一的输出。我们的第一种方法是从跟踪的模块范围内的堆栈中提取一些相对地址，并将它们打印到QEMU输出控制台。
图6：符号器1的结果
###  完整性检查
在运行fuzzer之前，我们想确保它确实能够找到一个真实的漏洞，否则我们只是在浪费CPU时间。不幸的是，当时我们还找不到真实漏洞的公开PoC来执行此测试。  
因此，我们决定在其中一个系统调用中为特定的流程打上补丁以模拟漏洞。Fuzzer确实能够找到这个模拟出来的漏洞，这是个好迹象，我们可以运行fuzzer了。
## 第一次fuzzing尝试
启动fuzzer后不久，我们注意到一个崩溃，其错误消息是：CRITICAL_STRUCTURE_CORRUPTION。我们很快发现这是由于内核补丁保护Patch
Guard造成的。我们的崩溃检测机制基于kAFL，在其中我们用shellcode对BugCheck和BugCheckEx进行补丁修补，该shellcode在崩溃时发出hypercall，而这正是PatchGuard的[设计初衷](https://en.wikipedia.org/wiki/Kernel_Patch_Protection#Technical_overview)。
为了解决这个问题，我们添加了一个驱动程序，该驱动程序在系统引导时启动，并使用[KeRegisterBugCheckCallback](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-keregisterbugcheckcallback)向ntos注册错误检查回调函数。现在，当内核崩溃时，它将调用我们的驱动程序，该驱动程序将发出hypercall通知fuzzer产生了崩溃。
再次运行fuzzer，这次得到了一个不同错误代码的新bug。我们尝试重现崩溃以帮助我们理解它，但发现从偏移量和随机无用堆栈中执行根本原因分析很困难。我们决定需要一种更好的方法来获取崩溃信息。
###  符号器＃2
我们试图在安装[Wine](https://www.winehq.org/)的宿主机上运行”kd”来产生调用堆栈，但是效果不佳，因为大约需要5分钟才能生成调用堆栈。
这种方法给我们的fuzzer造成了瓶颈。在复现过程中，Syzkaller尝试尽可能地最小化崩溃程序，并且每次最小化尝试时它都将等待调用堆栈，以确定是否是相同的崩溃。
因此，我们决定使用带有KD（kernel
debug）的远程Windows机器，并在那里建立所有udp连接的隧道。实际效果很好，但是当我们将其扩展到38台机器时，连接断开了，Syzkaller将其解释为“挂起”。
###  符号器＃3
这时我们思考一下，KD和WinDBG是如何能够生成调用堆栈的？
答案是使用DbgHelp.dll中的StackWalk。要生成调用堆栈，我们需要StackFrame、ContextRecord和ReadMemoryRoutine。
图7：符号器架构
图7显示了该架构：
1.通过KVM返回到QEMU，从guest中获取堆栈、寄存器和驱动程序地址。
2.QEMU将其发送到远程Windows机器，机器中的符号器使用所有相关参数调用StackWalk，并获取调用堆栈。
3.将调用堆栈打印回控制台。
该体系架构受到[Bochspwn for
Windows](https://github.com/googleprojectzero/bochspwn)的极大启发。
现在，当我们遇到新的崩溃时，它看起来像这样：
###  符号器＃4
让Windows机器与fuzzer一起运行并不理想，而且我们认为在’go’中实现最小的内核调试器并将其编译为Syzkaller将会非常困难。
我们从PDB解析器和提取器开始，之后，我们使用存储在PE中的展开信息实现了x64堆栈展开器。
最后一部分是实现KD串口通信，它的工作非常缓慢，因此我们开始在KDNET上工作，完成后将其集成到Syzkaller。
这个解决方案比之前的方案好得多。重复数据删除机制现在基于故障框架，我们还得到了BugCheck错误代码、寄存器和调用堆栈。
###  覆盖率稳定性
我们遇到的另一个问题是覆盖率稳定性。
Syzkaller使用多个线程来查找数据竞争。例如，当生成的程序有4个系统调用时，它可以将其分为两个线程，一个线程运行系统调用1和2，另一个线程运行系统调用3和4。
在覆盖率实现中，每个进程使用一个缓冲区。实际上，多次运行同一程序将导致每次运行的覆盖率跟踪不同。
覆盖率的不稳定性会影响fuzzer发现新的、有意思的代码路径和漏洞的能力。
我们希望通过将覆盖率实现方式更改为类似于KCOV的实现来解决此问题。我们知道KCOV跟踪每个线程的覆盖率，因此我们希望能够有这样的机制。
要创建类似KCOV的跟踪，我们需要：
• 跟踪KVM中的线程以交换缓冲区。  
• 将线程句柄感知添加到KCOV hypercall API。
为了跟踪线程，我们需要一个用于上下文切换的hook。我们可以从全局段中获取当前线程：
图8： KeGetCurrentThread函数
我们查看了在上下文切换期间发生的情况，并在处理上下文切换的函数中找到了swapgs指令。当执行swapgs指令时，会引起可被hypervisor捕获的VMExit。
图9： SwapContext函数内部的swapgs
这意味着如果我们可以跟踪swapgs，那么也可以监控KVM中的线程交换。这似乎是监控上下文切换和处理跟踪线程IntelPT的一个很好的hooking位置。
因此，我们删除了MSR_KERNEL_GS_BASE的拦截禁用。
图10： MSR拦截
这使我们可以在每个上下文切换时使用hook并切换ToPa缓冲区，ToPa条目向Intel-PT描述了它可以在其中写入跟踪输出的物理地址。
我们还有一些小问题要处理：
• 禁用服务和自动加载的程序以及不必要的服务，以加快启动速度。  
• Windows更新随机重启机器并消耗大量CPU。  
• Windows defender随机杀死fuzzer。
总的来说，我们[调整](https://support.microsoft.com/en-us/help/15055/windows-7-optimize-windows-better-performance)了guest机器以实现最佳性能。