### 参考文献

[13] G. Hunt 和 D. Brubacher. Detours: Win32 函数的二进制拦截。在 USENIX Windows NT 研讨会论文集, 1999 年。

[14] S. Karanth, S. Laxman, P. Naldurg, R. Venkatesan, J. Lambert, 和 J. Shin. 针对未来攻击的模式挖掘。技术报告 MSR-TR-2010-100, 微软研究院, 2010 年。

[15] A. Moshchuk, T. Bragin, S. D. Gribble, 和 H. M. Levy. 基于爬虫的网络间谍软件研究。在网络和分布式系统安全研讨会论文集中, The Internet Society, 2006 年。

[16] J. Nazario. PhoneyC: 一个虚拟客户端蜜罐。在美国计算机协会大规模漏洞利用和新兴威胁研讨会上, 波士顿, 2009 年。

[17] J. Newsome, B. Karp, 和 D. Song. Polygraph: 自动生成多态蠕虫签名。在 IEEE 安全与隐私研讨会论文集, 2005 年。

[18] M. Polychronakis, K. G. Anagnostakis, 和 E. P. Markatos. 基于模拟的非自包含多态 shellcode 检测。在最近入侵检测进展研讨会论文集, 2007 年。

[19] Praetorian Prefect. "Aurora" IE 漏洞攻击实例。http://praetorianprefect.com/archives/2010/01/the-aurora-ie-exploit-in-action/, 2010 年 1 月。

[20] N. Provos, P. Mavrommatis, M. A. Rajab, 和 F. Monrose. 所有你的 iFRAMEs 都指向我们。在 USENIX 安全研讨会论文集, 2008 年。

[21] P. Ratanaworabhan, B. Livshits, 和 B. Zorn. Nozzle: 一种针对堆喷射代码注入攻击的防御措施。在 USENIX 安全研讨会论文集, 2009 年 8 月。

[22] K. Rieck, T. Krueger, 和 A. Dewald. Cujo: 高效检测和预防 drive-by-download 攻击。在年度计算机安全应用会议论文集, 2010 年。

[23] M. Roesch. Snort – 轻量级网络入侵检测系统。在 USENIX 系统管理会议论文集, 1999 年。

[24] C. Seifert, P. Komisarczuk, 和 I. Welch. 使用静态启发式方法识别恶意网页。在澳大利亚电信网络与应用会议论文集, 2008 年。

[25] C. Seifert, R. Steenson, T. Holz, B. Yuan, 和 M. A. Davis. 了解敌人：恶意 Web 服务器。2007 年。

[26] C. Song, J. Zhuge, X. Han, 和 Z. Ye. 通过模块间通信监控防止 drive-by download。在亚洲计算与通信安全会议论文集, 2010 年。

[27] R. J. Spoor, P. Kijewski, 和 C. Overes. HoneySpider 网络: 对抗客户端威胁。在 FIRST 会议论文集, 2008 年。

[28] T. Stuurman 和 A. Verduin. Honeyclients - 低交互检测方法。技术报告, 阿姆斯特丹大学, 2008 年。

[29] T. Toth 和 C. Krügel. 通过抽象载荷执行实现准确的缓冲区溢出检测。在最近入侵检测进展研讨会论文集, 2002 年。

[30] K. Wang. HoneyClient. http://www.honeyclient.org/trac, 2005 年。

[31] Y.-M. Wang, D. Beck, X. Jiang, R. Roussev, C. Verbowski, S. Chen, 和 S. King. 使用 Strider HoneyMonkeys 进行自动网络巡逻: 发现利用浏览器漏洞的网站。在网络和分布式系统安全研讨会论文集, 2006 年。

[32] J. Zhuge, T. Holz, C. Song, J. Guo, X. Han, 和 W. Zou. 研究中国网络上的恶意网站和地下经济。技术报告, 曼海姆大学, 2007 年。

### Shellcode 混淆策略

| 样本 | 解码方法 | CVE |
| --- | --- | --- |
| 1 | unescape | 2009-0075 |
| 2 | unescape | 2009-1136 |
| 3 | unescape | 2010-0806 |
| 4 | hex, unescape | 2010-0806 |
| 5 | replace, unescape | 无 |
| 6 | unescape | 无 |
| 7 | replace, hex, unescape | 2009-1136 |
| 8 | custom, unescape | 2010-0249 |
| 9 | unescape | 无 |
| 10 | replace, array | 2010-0806 |
| 11 | unescape | 无 |
| 12 | replace, unescape | 无 |
| 13 | unescape | 2009-1136 |
| 14 | unescape, array | 无 |
| 15 | replace, unescape | 2010-0249 |
| 16 | unescape | 无 |
| 17 | replace, unescape | 无 |
| 18 | unescape | 2010-0249 |
| 19 | unescape | 2010-0806 |
| 20 | unescape | 2008-0015 |
| 21 | unescape | 无 |
| 22 | unescape | 无 |
| 23 | unescape | 2010-0249 |
| 24 | unescape | 2010-0806 |
| 25 | unescape | 2010-0806 |

### 图 19: 分析并分类的恶意软件样本
### 图 20: 训练集大小对分类器精度的影响（手选特征和自动选择特征）

### A. 手动分析的样本

在训练 ZOZZLE 分类器的过程中，我们手动分析了一些恶意软件样本。尽管存在大量的重复，但这些样本展示了野外发现的各种不同的恶意软件编写策略。

图 19 提供了每个独特手动分析样本的详细信息。当发现并验证新的漏洞时，会分配 Common Vulnerabilities and Exposures (CVE) 编号，图 19 中列出了所有针对某些漏洞的攻击所使用的 CVE 编号。Shellcode 和 nopsled 类型描述了 JavaScript 或 HTML 值如何转换为喷洒在堆中的二进制数据。大多数 shellcode 和 nopsled 是用 \x 转义序列编写的十六进制字面值。这些情况在图 19 中用“hex”表示。

许多脚本使用 %u 编码，并通过 JavaScript 的 unescape 函数转换为二进制数据。最后，一些样本包含反复插入的短片段（例如字符串 CUTE，在几个示例中出现），这些片段通过调用 JavaScript 的 replace 函数被移除或替换。

在少数情况下，攻击样本不包含堆喷射攻击的一个或多个组件（shellcode、喷射和漏洞）。在这种情况下，脚本与其他样本一起传递，可能提供 shellcode、执行喷射或触发漏洞。

### B. 附加实验数据

**训练集大小**: 为了理解训练集大小对准确性和误报/漏报率的影响，我们使用良性数据集和恶意数据集的 1% 到 25% 来训练分类器。对于每个训练集大小，使用不同的随机子集训练了十个分类器，分别对手选特征和自动选择特征进行了评估。这些分类器的整体准确性如图 20 所示，误报/漏报率如图 21a 所示。

这些图表显示，训练集大小确实对整体准确性和错误率有影响，但相对较小的训练集（< 5% 的总数据集）足以实现大部分收益。使用自动特征选择的分类器从额外的训练数据中受益最多，这是因为该分类器具有更多的特征，并且需要更多的样本来充分训练。

**特征集大小**: 为了理解特征集大小对分类器效果的影响，我们训练了一级自动分类器，按其 χ2 值对选定的特征进行排序，并仅选择前 N 个特征。由于训练集是随机选择的，因此自动选择过程中最初选择了 1,364 个特征。

图 21b 显示了当我们改变特征集大小以包含 500、300、100 和 30 个特征时，误报和漏报率的变化情况。

这些图表显示，随着特征集大小的变化，误报率保持较低（甚至在某些情况下降至 0）。不幸的是，漏报率随着特征集大小的减小而稳步增加。这意味着虽然少量特征可以有效识别某些恶意软件（可能是最常见的恶意软件），但如果特征集太小，许多最隐蔽的恶意软件样本将无法被检测到。

### C. 附加代码示例

图 22 展示了一个被反病毒工具误报的代码解包器。当然，解包器代码本身并不是恶意的，即使它解包的内容可能是恶意的。最后，图 23 展示了一个被反病毒引擎过于积极地判定为恶意的代码示例。

```javascript
function dF(s) {
    t = "";
    var s1 = unescape(s.substr(0, s.length - 1));
    for (i = 0; i < s1.length; i++)
        t += String.fromCharCode(s1.charCodeAt(i) - s.substr(s.length - 1, 1));
    document.write(unescape(t));
}
```

图 23: 反病毒误报。为了避免触发最终 PDF 文件中的反病毒检测，去除了 unescape 后的部分文件内容。

### 图 21: 误报和漏报率
(a) 作为训练集大小的函数。
(b) 作为特征集大小的函数。

希望这些优化后的文本能够更清晰、连贯和专业。如果有更多需要修改的地方，请随时告诉我！