1.操作人员触发手动操作（无自动化）。
，不需要人为干预的自治系统。
外部维护的通用自动化。
操作人员编写，系统特定的自动化。
第7章Google的自动化系统的演进
内部维护，系统特定的自动化。
，集群上线自动化进化遵循这样一个路径：
，自动化系统将给每个负责上线的Admin服务器发送RPC。
、低能力的流程一
一最糟糕的结果。然
---
## Page 115
Google的集群最初与其他人当时的小型网络部署方式很类似：具有特定用途和异构配置
到自动化的成功转变，集群上线流程则体现了不仔细考虑在哪里以及如何实现自动化所
理解我们对自动化的态度的演变，以及何时何地部署自动化是最佳的另一种方式，就是
Borg：仓库规模计算机的诞生
此功能最终使得连续性的、自动的操作系统升级只需要很少的持续注7工作一
任务。
模式，
主体。这从另外一个维度解放了效率、灵活性以及可靠性：对比以前的机器的“独占”
功的核心一
静态的主机/端口／作业分配，到将一系列机器看作受管理的海量资源的创新。Borg成
机紧密相关。我们需要一个新的方法，因此Borg（参见文献[ver15]）诞生了：从相对
但是退一步说，这种自动化是有用的，但是限制非常多，因为该系统的抽象对象与物理
除服务，送去修理并且在它们修好后恢复配置。
着自动化系统的成长，我们现在可以自动管理机器的大部分生命周期：当机器坏了，
自动化最终成长为使用一个数据库来跟踪机器状态，并且采用了更先进的监控工具。
自动化研发开始了。最初的自动化包括简单的Python脚本，执行如下操作。
现在可以使用了”的工单是很普通的。
如）所有的搜索机器。在当时，收到类似“搜索团队已经用完x1这台机器，爬虫团队
名策略将机器编组。这个描述文件，加上一个并行化的SSH，允许我们一次重新启动（例
名称）也变得有必要了。现在就需要一个文件来描述每个机器做了什么，以一些松散命
隐含地假定了位置信息。随着生产环境的增长，我们开始使用多个集群，多个域（集群
进制文件和配置保存在这些主机上。当时我们只有一个托管供应商，大多数的命名逻辑
的很多机柜服务器。工程师将登录到一些知名的“主”机来执行管理任务；“黄金”二
提过的两个例子一样，
带来的不足。集群管理的研发也展示了另一个关于如何实行自动化的教训。和我们之前
我们已经压缩和简化了这段历史来帮助理解。
，Borg 能够让机器来调度任务，例如在同一台机器上同时进行批处理和面向用户的
日志消息解析：SSH进入每一台机器，用正则表达式过滤日志。
）服务管理：保障服务运行（例如，在段错误后重新启动）。
跟踪哪些服务应该运行在哪些机器上。
以及它的核心理念一是把集群管理变成了一个可以发送API的中央协调
一个复杂的东西诞生于简单初始环境的不断演变。
Borg:仓库规模计算机的诞生
这种工<83
移
<2
---
## Page 116
注
Google也经历过自动化在某些条件下是有害的情况，参看下面“自动化：允许大规模故
最后将无法执行，因为允许它们执行的功能已经不存在了。
样一直可用。令人难过的是，随着时间的推移，这一假设终将不再正确：这些手动操作
即，当自动化逐渐取代了手动操作，假设其他的手工操作仍然可能执行，并且如之前一
型不再反映现实中系统“正在进行”的活动注1。这种情况在系统非自主运行时出现得更多，
由于缺乏实践，他们已经丧失了反应的流畅性，他们有关系统“应该”做什么的心理模
自动化系统出现问题时，操作员将无法成功地操作该系统。
用的、直接接触会逐渐减少，因为自动化会覆盖越来越多的日常活动。不可避免的，
业应用中—经常会指出高效的自动化的缺点注9：随着时间的推移，操作员与系统的有
整体系统的操作员。在非计算机领域中对自动化影响的类似讨论一例如，民航注或工
可靠性是最基本的功能
量故障。这意味着，随着系统的层次结构不断上升，从手动触发，到自动触发，到自主化，
长超过了一定规模时，它必须是自我修复的，因为根据统计学来说，每秒它都会发生大
个单一节点的计算机在大量组件出现问题时，是不会继续运行的。一旦全球计算机的增
集群上线仅仅是增加额外的调度能力，有点像在一台电脑上添加磁盘或内存。然而，一
不管怎样，人类的反应速度肯定是不够快。在集群上线这个例子中也类似：在这个比喻中，
从这个视角出发，重新调度看起来像是系统的一个固有特征，而不是可以“自动化”的一
过程十分相似：当然，这些计算资源其实是在网络链接的另一端，但是这又有多重要呢？
这个方法，在另一台机器上重新调度某个程序与进程从一个CPU移动到另一个CPU的
这里有一个有趣的比喻：我们可以将单机环境与集群管理抽象的发展之间直接映射。用
管理领域。
相关的数据分布、API、集中式架构，以及经典的分布式软件系统研发进入了基础设施
给我们争取了足够的时间，把集群管理转化为自治系统，而不是自动化系统。我们通过
Treynor Sloss 曾说过的话：通过将问题看作是一个软件问题的方法，最初的自动化努力
机器加入系统，或者出现问题，被修复，这一切都不需要SRE的任何操作。回应Ben
对SRE来说，机器的损坏和生命周期管理基本上已经不需要任何操作了。成千上万的
作不会根据生产部署的总规模而增加。当机器状态略有偏差时，可以自动进行修补；
当然，为了有效地进行故障调试，自我检查中所依赖的内部运作细节也应该暴露给管理
一些自我检查的能力是必需的。
6
8
具体细节请参看https:/len.wikipedia.org/wiki/Air_France_Flight_447。
具体细节请参看文献[Bai83]和[Sar97]
第7章Google的自动化系统的演进
---
## Page 117
的做法将会有很大的帮助：解耦子系统，引入API，最大限度地减少副作用等。
统。对足够大的系统来说，进行改造时加人自主行为是很难的，但软件工程的良好标准
快地交付和更快地迭代可能会帮助你更快地实现功能，但是却很难形成一个有弹性的系
时间花费和时间节省的计算之外也值得实施。但是，最有效的方法其实在设计阶段：更
这是不正确的，有以下两个原因：自动化提供的不仅仅是对时间的节省，所以在单纯的
读过本章的案例之后，你肯定会觉得在达到Google的规模之前不需要进行任何自动化。
建议
弹性行为是达到这一特征的有效途径。
系统中具有更多自主行为的系统仍然有很多好处。可靠性是最基本的功能，并且自主性、
为不再是可选择的附加项。随着服务规模扩大，肯定是这样的。但是不论系统规模大小，
障发生”补充材料。但是以Google的经验来看，在更多的系统中自动化和自主化的行
系统中添加更多的合理性检查，包括速率限制，以及使整个退役流程具有幂等性。
上的机器；然后我们又将接下来的几周时间用来进行代码审计，在我们的自动化
们这一点做得不错！）。接下来，我们花费了大概两天时间重装受影响的colo机架
增加。据我们所知，由于良好的容量规划，很少有用户注意到这个问题（至少我
据中心来服务全体用户，事实上几分钟后对外部的唯一影响就是会有轻微的延迟
再也不能终止用户连接了（或做任何有用的事情）。我们仍然可以从我们自己的数
几分钟内，高效的磁盘清除程序擦除了我们的CDN上所有机器的磁盘，
有”。这意味着自动化系统几乎将colo中的所有机器都送去进行磁盘清除了。
的机器列表是（正确的）空的。不幸的是，空列表有着特殊含义，它被解释为“所
当该程序试图给磁盘清除系统发送机架中的机器列表时，代码得出需要进行清空
骤已经成功完成。随后，清退过程被重启，以调试为什么失败。在这次操作中
很久以前，负责某个特定机架退役的自动化系统出现了问题，但只有磁盘擦除步
证机器被成功擦除。我们称这个过程为“磁盘擦除”（diskerase）。
步骤包括覆写机架上所有机器的磁盘的全部内容，同时一个独立的系统随后会验
都有很多机架被安装或被退役；这两个过程大部分都是自动化的。拆除中的一个
或是作为自己的内容分发网络的缓存，以降低用户的等待时间。在任何一个时间点
设施（或“colo”）内的机器。这些colo中的机器是用来终止大部分传入的连接的
Google运行十几个自有的大型数据中心，但是我们也依赖很多运行在第三方托管
自动化：允许大规模故障发生
建议
这些机器
5
85
---
## Page 118
87
8
发布工程（ReleaseEngineering）是软件工程内部一个较新、发展较快的学科。简单来说，
编辑：Betsy Beyer、Tim Harvey
作者：DinahMcNutt
发布工程
第8章
工具都是由发布工程师设计和开发的。
度），又比如统计构建配置文件中某个特性的使用率（参见文献[Ada15])。大部分这些
样的数据。例如，从代码修改提交到部署到生产环境一共需要多长时间（也就是发布速
Google是一个数据驱动的公司，发布工程也不例外。我们有各种各样的工具提供各种各
发布工程师的角色
的，构建时是如何执行编译的，如何测试、打包，最终进行部署的。
以及SRE一起定义发布软件过程中的全部步骤一
发布工程是Google内部的一项具体工作。发布工程与产品研发部门的软件工程师（SWE），
有意为之，而不是意外之举。SRE关注从源代码到部署的整个流程。
特的雪花”（俚语，意指没有两片雪花是完全相同的）。对发布流程的任何改变都应该是
种可重现的、自动化的方式构建出来的。这样每一次发布才是可以重复的，而不是“独
为保障服务可靠运行需要可靠的发布流程。SRE需要保证二进制文件和配置文件是以一
用户支持。
面的专家）。他们的技能横跨很多领域：开发、配置管理、测试集成、系统管理，甚至
编译器、构建配置语言、自动化构建工具、包管理器和安装器等非常了解（甚至是这方
这个学科专注于构建和交付软件（参见文献[McN14a]）。发布工程师通常对源代码管理、
一包括软件是如何存储于源代码仓库中
---
## Page 119
注1Google的全部源代码存放于一个单独的代码仓库中（参见文献[Pot16])。
的（hermetic），意味着它们不受构建机器上安装的第三方类库或者其他软件工具所影响。
一个源代码版本构建同一个产品，构建结果应该是相同的。注！我们的构建过程都是密闭
构建工具必须确保一致性和可重复性。如果两个工程师试图在两台不同的机器上基于同
的发布模型，也就是说，部署每个通过所有测试的版本（参见文献[Kle14]）。
含的功能列表共同得出的。还有的团队采用一种“测试通过即发布”（PushOn Green）
然后在所有可用的构建版本中选择某个版本进行发布。选择过程是基于测试结果与所包
版本之间的变更减少。这种方式使得测试和调试变得更简单。有些团队每小时构建一次，
面向用户的软件组件（例如Google搜索服务的很多组件）重新构建非常频繁，因为我
追求速度
程是真正的自动化的，工程师仅仅在发生问题时才会进行干预。
预，很多项目都是利用我们的自动构建工具和部署工具自动构建、自动发布的。发布过
定多久或者什么时候来发布产品的新版本。发布过程可以自动化到基本不需要工程师干
几百个产品，Google仍然能够以很快的速度发布新产品。这是因为每一个团队都可以决
为了应对大规模扩张，每个团队必须能够自给自足。发布工程师开发工具，制定最佳实践。
自服务模型
发布工程师的日常工作是由下列4个主要的工程与服务哲学指导的。
发布工程哲学
无缝发布，以及为变更的顺利回滚等制定策略。
保障软件发布流程能够满足业务需求，发布工程师与SRE紧密协作，为变更的测试进行
Google有很多SRE 负责产品更新的安全部署过程，保障这些服务可以正常运行。为了
密闭性
们的目标是让用户可见的功能越快上线越好。我们同时也认为频繁的发布可以使得每个
而不需要花费时间重新发明软件发布的轮子（经常还是不圆的轮子）。
况下就能正确工作，并且有合理的文档作为辅助，可以让开发团队专注于功能和用户，
译结果中的版本编号的格式、构建过程中必须执行的步骤等。确保我们的工具在默认情
行发布。我们的最佳实践覆盖整个发布过程中的所有元素。例如，编译器功能开关、编
发布工程师利用这些工具定义一些最佳实践，来保障软件项目可以一致地、可重复地进
发布工程哲学
<89
---
## Page 120