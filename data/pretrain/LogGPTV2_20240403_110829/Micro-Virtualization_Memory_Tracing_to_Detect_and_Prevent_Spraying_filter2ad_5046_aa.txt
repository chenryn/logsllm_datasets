title:Micro-Virtualization Memory Tracing to Detect and Prevent Spraying
Attacks
author:Stefano Cristalli and
Mattia Pagnozzi and
Mariano Graziano and
Andrea Lanzi and
Davide Balzarotti
Micro-Virtualization Memory Tracing to Detect and 
Prevent Spraying Attacks
Stefano Cristalli and Mattia Pagnozzi, University of Milan;  
Mariano Graziano, Cisco Systems Inc.; Andrea Lanzi, University of Milan;  
Davide Balzarotti, Eurecom
 https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/stefano
This paper is included in the Proceedings of the 25th USENIX Security SymposiumAugust 10–12, 2016 • Austin, TXISBN 978-1-931971-32-4Open access to the Proceedings of the 25th USENIX Security Symposium is sponsored by USENIX Micro-Virtualization Memory Tracing
to Detect and Prevent Spraying Attacks
Stefano Cristalli
Universit`a degli Studi di Milano
Mattia Pagnozzi
Universit`a degli studi di Milano
Mariano Graziano
Cisco Systems Inc.
Andrea Lanzi
Universita’ degli Studi di Milano
Davide Balzarotti
Eurecom
Abstract
Spraying is a common payload delivery technique
used by attackers to execute arbitrary code in presence
of Address Space Layout Randomisation (ASLR). In
this paper we present Grafﬁti, an efficient hypervisor-
based memory analysis framework for the detection and
prevention of spraying attacks. Compared with previ-
ous solutions, our system is the first to offer an effi-
cient, complete, extensible, and OS independent protec-
tion against all spraying techniques known to date. We
developed a prototype open source framework based on
our approach, and we thoroughly evaluated it against all
known variations of spraying attacks on two operating
systems: Linux and Microsoft Windows. Our tool can
be applied out of the box to protect any application, and
its overhead can be tuned according to the application
behavior and to the desired level of protection.
1
Introduction
Memory corruption vulnerabilities are currently one of
the biggest threat to software and information security.
Education plays a very important role in this area, mak-
ing programmers aware of common threats and teach-
ing them how to avoid mistakes that may lead to ex-
ploitable bugs in their code. However, education alone
is not enough, and a good defense in depth approach re-
quires also to put in place multiple layers of mitigation,
detection, and exploit prevention mechanisms.
In this field, over the past decade we have witnessed a
constant arms race, with the system designers of compil-
ers and operating systems on one side, and the attackers
on the other. Over the years, the former have introduced
many new security features to increase the complexity
of exploiting memory corruption vulnerabilities [31, 6,
41, 9, 40]. This list includes stack canaries [13, 12], data
execution prevention (DEP) [2], Address Space Layout
Randomization (ASLR) [43, 7, 26, 8], Structured Ex-
ception Handling Overwrite Protection (SEHOP) [29],
and Control Flow Integrity [3]—just to name some of
the most popular solutions. Even though the combina-
tion of all these techniques have certainly increased the
security of modern operating systems, no matter how
high the bar was set, attackers have always found a way
to overcome it to take control of a vulnerable system.
ASLR is certainly one of the most common and suc-
cessful techniques adopted by modern operating sys-
tems.
In fact, the objective of the majority of mem-
ory corruption exploits is to allow the attacker to exe-
cute arbitrary code in the context of a vulnerable pro-
cess. The code can be injected by the attacker herself,
or it can be constructed by reusing instructions already
present in memory (e.g., in the case of return-to-libc or
return oriented programming). Either way, the attacker
needs to know where such code is located in memory,
in order to divert the control flow of the application to
that precise address. And here is where ASLR plays its
role: by completely randomizing the layout of the pro-
cess memory, it makes much harder for the attacker to
predict where a certain buffer (or an existing code gad-
get) will be located at run-time. Unfortunately, attackers
found a very simple and effective solution to overcome
this protection: fill the memory with tens of thousands
of identical copies of the same malicious code, and then
jump to a random page1, hoping to land in one of the
pre-loaded areas. This makes this payload delivery tech-
nique, called spraying, one of the key elements used in
most of the recent memory corruption exploits.
Researchers have been looking for ways to mitigate
this technique. Unfortunately, the few solutions pro-
posed so far [36, 16, 21] were all tailored to defend 1)
a particular application (typically the JavaScript inter-
preter in Internet Explorer), 2) using a given memory al-
locator, 3) in a specific operating system, and 4) against
1Often a fixed address located on the process heap.
USENIX Association  
25th USENIX Security Symposium  431
1
a single form of heap spraying. This made these solu-
tions difficult to port to other environments, and unable
to cope with all possible variations of heap spraying at-
tacks. In fact, the original heap spraying attack is now
just the tip of the iceberg. The technique has rapidly
evolved in different directions, for example by taking
advantage of just in time compilers (JIT), by focusing
on the allocation of pools in the OS kernel, or by rely-
ing on stack pivoting to spray data instead of code. We
strongly believe that the increased adoption and sophis-
tication of heap spraying techniques clearly demonstrate
the need for a general and comprehensive solution to this
problem.
In this paper we present Graﬃti, a hypervisor-based
solution for the detection and prevention of all known
variations of spraying attacks. We decided to implement
our solution at the hypervisor level to obtain the first OS-
independent, allocator-agnostic approach to track mem-
ory allocations that does not depend on the knowledge of
the protected process, or system. By leveraging a novel
micro-virtualization technique, Graﬃti proposes an ef-
ficient and OS-agnostic framework to monitor memory
allocations of arbitrary applications. The system is mod-
ular, and relies on a set of plug-ins to detect suspicious
patterns in memory in realtime. For example, we devel-
oped a set of different detection modules based on statis-
tical inference, designed to precisely identify all known
spectrum of spraying attacks known to date. Moreover,
while all the previous techniques [36, 21] focused on the
defense of a particular application or memory allocator
against a single form of heap spraying, our system offers
the first general and portable solution to the problem.
Graﬃti also offers a hot-plugging capability and there-
fore it can be installed on-the-fly without rebooting the
machine and without modifying the native operating
system. Our experiments, conducted both on Linux and
Microsoft Windows, show that Graﬃti has no false neg-
atives and low false positives, with an overhead similar
to the one of previous, much more limited, solutions.
In summary, our work makes the following contribu-
tions:
• We present the principles, design, and implemen-
tation of an effective real-time memory analysis
framework. On top of our framework, we de-
veloped a set of heuristics to detect existing heap
spraying techniques. To the best of our knowledge,
we are the first to present a general, efficient, and
comprehensive framework that can be applied to all
modern operating systems and all existing applica-
tions.
• We propose a novel micro-virtualization technique
that allows Graﬃti to monitor the entire system in
terms of both processes and kernel threads, with
low overhead.
• We have developed a prototype tool, and performed
an experimental evaluation on several existing real-
world spraying techniques. Our experiments show
that the system is able to detect all the classes of
spraying attacks we analyzed with low false posi-
tives and acceptable performance.
• We released the source code of the current Graf-
ﬁti prototype, which is available at
the fol-
lowing link: https://github.com/graffiti-
hypervisor/graffiti-hypervisor
The rest of the paper is organized as follows. Sec-
tion 2 provides background information on spraying at-
tacks. Section 3 provides preliminary notions about In-
tel VT-x technology. Section 4, Section 5, Section 6 de-
scribe our solution from an architectural point of view.
Section 7 reports results on evaluating Graﬃti. Section 8
discusses about the security evaluation of our system.
Section 9 compares our work with other relevant re-
search and Section 10 discusses future directions and
concludes the paper.
2 Spraying Attacks
Heap spraying is a payload delivery technique that
was publicly used for the first time in 2001 in the
telnetd remote root exploit [44] and in the eEye’s
ISS AD20010618 exploit [15]. The technique became
popular in 2004 as a way to circumvent Address Space
Layout Randomization (ASLR) in a number of exploits
against Internet Explorer [46, 47, 38].
Since 2004, spraying attacks have evolved and be-
came more reliable thanks to improvements proposed by
Sotirov [42] and Daniel [14] for a precise heap manipu-
lation. Spraying can now be classified in two main cat-
egories, based on the protection mechanisms in place in
the target machine: Code Spraying and Data Spraying.
If Data Execution Prevention [2] (DEP) is not enabled,
the attacker can perform the exploit by directly spray-
ing the malicious code (e.g., the shellcode) in the victim
process memory. On the other hand, when the system
uses the DEP protection, the attacker would not be able
to execute the injected code. To overcome this problem,
two main approaches have been proposed: (a) perform
the heap spraying by taking advantage of components
that are not subjected to DEP, such as Just in Time Com-
pilers (JITs), or (b) inject plain data that points to Return
Oriented Programming (ROP) gadgets. While the inter-
nal details between the three aforementioned approaches
432  25th USENIX Security Symposium 
USENIX Association
2
2.1 Memory Footprint
The first characteristic of a heap spraying attack that
comes to mind is the large amount of memory that is
suddenly allocated by a process. Therefore we could er-
roneously believe that this unusual behavior alone (i.e.,
many pages allocated in a very short amount of time)
could be sufficient to implement a solution to detect
spraying attacks. For example, a simple approach could
measure the speed of memory allocation and the aver-
age amount of memory usually allocated by the applica-
tion under analysis. The first parameter would react to
a quick memory increase, a common aspect of most of
the existing attacks. The second parameter, once prop-
erly tuned for the application to protect, would act as
a threshold of memory allocation, beyond which the
behavior becomes suspicious and an alert is raised. It
seems reasonable to believe that, by checking these two
parameters, a detector could successfully prevent spray-
ing attacks.
One of the main motivation of our work is to prove
that the use of these two parameters is not sufficient for
designing an effective spraying detection system. To
prove our point, we designed a set of experiments to
show that an attacker can tune the memory allocation
behavior of an exploit to mimic the one of a normal ap-
plication.
In our tests we used as a case study a classic heap
spray attack against Internet Explorer 8 (described in
CVE-2011-1996) but it is possible to replicate similar
results with any applications where the memory alloca-
tion depends on input data. The first test we performed
aimed at measuring the memory allocation curve while
the user was visiting a small set of web sites. Fig-
ure 1 shows that the parallel execution of four common
web applications (using parallel browser’s tabs) boosts
the memory allocation of Internet Explorer to around
200MB. The same graph also shows the allocation curve
of the CVE-2011-1996 exploit launched by Metasploit.
In this case, the malicious behavior is easy to detect
since it produces a huge allocation of memory in a short
period of time – that then drops drastically after the suc-
cess of the exploit. The drop is due to the fact that
the shellcode spawns a process and releases the system
resources of the previous execution thread along with
its own memory. Other spraying attacks exhibit simi-
lar curves, a weakness that could be used to identify an
ongoing malicious activity.
In the second experiment we wanted to answer two
separate questions: i) how the total amount of memory
allocated by the exploit affects the reliability of a spray-
ing attack; and ii) whether it is possible for an attacker
to slow down the attack in order to mimic the slope of
the allocation curve observed on benign web pages. To
Figure 1: Heap Spraying attack
Figure 2: Mimicry attack
may be quite different, what is important for our re-
search is that all these techniques share the same goal,
i.e., to control the target dynamic memory allocation in
order to obtain a memory layout that allows arbitrary
code execution in a reliable way.
It is important to note that spraying is still a valuable
technique also in x86_64-based operating systems. In
particular, this is the case for user-after-free vulnerabili-
ties – but spraying can also be used in conjunction with
vulnerabilities in the ASLR implementation [10], in par-
ticular types of vulnerabilities [20], or because of the
wide adoption of 32bit processes in 64bit operating sys-
tems (as recently shown by Skylined [39]).
3
USENIX Association  
25th USENIX Security Symposium  433
this end, we first modified our exploit to decrease the
amount of sprayed memory. As we expected, reducing
the number of allocated pages also reduces the probabil-
ity of landing on one of them, thus making the exploit
less reliable. We measured this phenomenon by run-
ning each exploit configuration ten consecutive times,
counting in each case the number of successful attacks.
The results of our tests show that the memory used by
the original exploit can be largely reduced maintaining
an acceptable success rate. For instance, the attack was
still successful in 80% of the cases with a total memory
consumption of only 131 MB – that is considerably less
than what IE8 used in our benign scenario.
We then modified again the original exploit, this time
introducing a delay between each memory allocation to
mimic the behavior of a benign application. This change
had no impact on the success rate of the attack. Figure 2
shows the allocation curve of our modified exploit, com-
pared with a base line obtained by running Internet Ex-
plorer with six open tabs. From this experiment, it is
clear that neither the speed nor the amount of memory
can be used as the only criteria to detect a potential heap
spraying exploit. By setting the threshold too low, the
system would generate too many false alarms, and by
raising the threshold too high the system would be vul-
nerable to evasions.
This conclusion motivates our further investigation to
design a better memory monitoring and spraying attacks
detection technique.
3 Preliminary Notions on Intel VT-x
Before we discuss our solution, we need to briefly intro-
duce some virtualization concepts that we will use in the
rest of the paper. Intel VT-x is a technology available in
various Intel CPUs to support virtualization [23, 30].
VT-x defines two particular transitions: vmexit, to
move from the guest to the hypervisor, and vmentry,
to move in the opposite direction. As a result, the hy-