launch the same subset of processes but group them in their
own cgroup [24]. By doing so,
they are prevented from
observing and interacting with processes in another group (i.e.,
processes in the original native Android system). The cgroup
concept greatly facilitates AirBag management. Speciﬁcally,
the set of processes inside AirBag is typically suspended
until one untrusted app is being installed or launched. The
newly installed untrusted app will automatically become a
member of this cgroup. As a result, we can easily suspend the
whole cgroup when no untrusted app is active to minimize the
footprint or reduce the performance and power consumption.
3
Note that cgroup is provided by the OS kernel and is assumed
to be trusted.
3) Context-Aware Device Virtualization: The presence of a
separate AIR and namespace in AirBag unavoidably creates
contentions for underlying system resources, even though
AirBag delineates a boundary and by default disallows any
interaction from inside to outside and vice versa. To resolve
the contention, there is a need to multiplex various system
resources. In our design, we develop a lightweight OS-level
extension to mediate and multiplex the accesses from native
and AirBag runtimes.
As an example, suppose two apps need to update the
screen at the same time. Traditionally, a single service dae-
mon SurfaceFlinger is in charge of synthesizing data from
different sources (including these two apps) and generating
the ﬁnal output to be rendered on the device screen. However,
with AirBag, these two apps run in two different runtimes
and they will not share the same SurfaceFlinger service.
Instead, AirBag has its own SurfaceFlinger service which
will independently update the screen.
Our solution is to virtualize hardware devices in a context-
aware manner. Speciﬁcally, our lightweight OS extension
adds necessary multiplexing and demultiplexing mechanisms
in place when the underlying hardware devices are being
accessed. Also, our extension keeps track of the current
“active” Android runtime (or namespace) and always allows
the active runtime to access the hardware resources. Notice
that an Android runtime is active if an app on it holds the
focus, i.e., the user is currently interacting with the app. To
maintain the same user experience, we disallow an user to
simultaneously interact with two apps in different runtimes.
As a result, in any particular moment, there exists at most one
active runtime. Meanwhile, to gracefully handle contentious
access from inactive runtime, we take different strategies base
on the nature of relevant hardware resources. For example, for
touch-screen and buttons, any press/release event will always
be delivered to the active runtime only. For screen update, as
the framebuffer device driver performs actual DMA operations
from a memory segment to the LCD controller hardware, we
accordingly prepare two separate memory segments such that
each environment can independently render different output
without interfering each other. The framebuffer driver can then
choose the active memory segment to perform DMA and thus
have an actual access to the LCD controller hardware.
C. Additional Capabilities
Beside the above key techniques, we also developed ad-
ditional capabilities to facilitate the conﬁnement and improve
user experience.
1) Incognito/Proﬁling Modes: The decoupled AIR to host
untrusted apps provide unique opportunities for its customiza-
tion. Speciﬁcally, to prevent private information disclosure,
we introduce the incognito mode that essentially instruments
the AIR to exclude any sensitive data such as IMEI num-
ber, phone number, and contacts. For example, the device’s
IMEI number can be normally retrieved by apps through the
services provided by the Android framework. When entering
the incognito mode, such services are conﬁgured to return
faked IMEI number to the calling app. Therefore, the isolated
app transparently proceeds with fake data without additional
risks. Also, AirBag prepares a separate root ﬁlesystem that
allows for convenient “restore to default” to undo damages
from untrusted apps. In addition, we also provide proﬁling
mode that essentially records the execution trace of untrusted
apps. The trace is mainly collected in terms of Android-speciﬁc
logcat, which turns out to be very helpful for malware analysis
(Section IV).
2) User Conﬁrmation for Sensitive Operations: The de-
coupled AIR also provides interesting opportunities to further
limit the capabilities of isolated apps. For example, a malicious
app may attempt to stealthily send SMS text messages to
certain premium-rate numbers or record your phone conver-
sation. When such an app runs inside AirBag, the access to
related phone features (e.g., radio, audio, and camera) will
immediately trigger user attention for approval. In other words,
the stealthy behavior from these apps will now be brought to
user attention and the user also has the option to disallow
it. It is interesting to notice that the latest Android release,
i.e., Jellybean 4.2, introduces a built-in security feature called
premium SMS conﬁrmation [2] to avoid malware to rack up
phone bills. While achieving similar goals, AirBag is different
in restricting the access to certain phone features outside
the AIR environment, thus providing stronger robustness than
any inside solutions (as the internal built-in feature can be
potentially compromised by untrusted apps for circumvention).
3) Seamless Integration: To achieve seamless user experi-
ence, AirBag introduces minimal user interaction when an app
is being installed or launched. Speciﬁcally, when an untrusted
app is being installed (or sideloaded), AirBag will prompt
user with a (default) option to install it inside AirBag. If
chosen, AirBag essentially notiﬁes its own PackageInstaller
to start the installation.2 Note that for an app downloaded
from Internet, the Android DownloadManager will store it in
a speciﬁc directory located in microSD. In our prototype,
we choose to export this directory read-only to AirBag so
that its PackageInstaller can access it for installation. For
improved user experience, AirBag will be installed as the
default PackageInstaller. Inside AirBag, we have a daemon
that listens to the command from it to kick off internal app
installation. In other words, the isolated apps are physically
installed in the AirBag instead of the original Android runtime.
Moreover, for any app being installed inside AirBag, AirBag
will automatically create an app stub that bears the same icon
from the original app. (To indicate the fact that it is actually
inside AirBag, we will attach a lock sign to the icon.) When
the app stub is invoked, AirBag will be notiﬁed to seamlessly
launch the actual app such that the user would feel just like
invoking a normal app (without noticing the fact it is actually
running inside AirBag). By doing so, the AIR becomes active
and the original Android runtime goes to inactive. Once the
user chooses to terminate the app, the original Android runtime
is resumed back to active.
III.
IMPLEMENTATION
We have implemented a proof-of-concept AirBag proto-
type on three different mobile devices, i.e., Google Nexus
2If not chosen, the normal installation procedure will be triggered without
AirBag protection.
4
One, Nexus 7, and Samsung Galaxy S III, running Linux
kernel 2.6.35.7, 3.1.10, and 3.0.8 respectively. Our prototype is
portable without relying on any specialized hardware support.
In the following, we present in detail about our prototype. For
simplicity, unless explicitly mentioned, we will use Google
Nexus One as the reference platform.
A. Namespace/Filesystem Isolation
Our system conﬁnes untrusted apps in a separate names-
pace and ﬁlesystem. In our prototype, we leverage and extend
the namespace isolation feature of cgroups [24] in mainstream
Linux kernels. At the high level, our prototype instantiates a
new namespace and then starts from the very ﬁrst process (i.e.,
airbag_init) inside AirBag. The airbag_init process will
then bootstrap the entire AIR. Speciﬁcally, the new namespace
of AirBag is created by cloning a new process with a few
speciﬁc ﬂags: CLONE_NEWNS, CLONE_NEWPID, CLONE_NEWIPC,
CLONE_NEWUTS, and CLONE_NEWNET. Further, right before switch-
ing the control to the airbag_init program, we initialize
a separate root ﬁlesystem for the newly clone’d process
(and its decedent processes) by invoking pivot_root in the
new root directory that contains essential AIR ﬁles. We then
prepare procfs and sysfs ﬁlesystems inside AirBag so that
subsequent processes inside AirBag can properly interact with
the underlying Linux kernel. After that, we yield the control
by actually executing the airbag_init program that then kicks
off the entire AIR, including various service daemons (e.g.,
SurfaceFlinger and system_server). These service daemons
as well as essential Android framework classes collectively
allow untrusted apps to execute transparently when they are
dispatched to the AIR.
With a new AirBag-speciﬁc namespace, all processes
running inside cannot observe and interact with processes
running outside. However, some features (mainly for im-
proved user experience) may require inter-namespace com-
munication. Speciﬁcally, when installing an untrusted app,
our PackageInstaller needs to notify AirBag for seamless
installation. To achieve that, we virtualize a network device
[17] inside AirBag and connect it to a pre-allocated bridge
interface on the native Android system. By building such
an internal channel for “inter-namespace” communication, we
can naturally enable networking and telephony support inside
AirBag.
By instantiating two different namespaces on the same
kernel, our prototype needs to keep track of the current
active namespace, which is needed to enable context-aware
device virtualization (Section III-B). Speciﬁcally, we need to
export the related namespace information to corresponding
OS components (e.g., framebuffer/GPU drivers) such that they
can properly route or handle hardware device accesses from
different namespaces. For instance, when a user-level process
requests to update the framebuffer, we need to update the
respective memory blocks associated with its namespace in
OS kernel. Fortunately, when a process is clone’d with the
CLONE_NEWNS ﬂag, an instance of struct nsproxy would be
allocated in Linux kernel to store the information such as
utsname and ﬁlesystem layout of the new namespace. Given
that all processes belong to the same namespace share the same
nsproxy data structure, our current prototype simply uses it
as the namespace identiﬁer. When a process accesses system
TABLE I.
SUPPORTED ANDROID HARDWARE DEVICES IN AIRBAG
Hardware Device
Description
Audio
Framebuffer
GPU
Input
IPC
Networking
pmem
Power
RTC
Sensors
Telephony
Audio Playback and Capture
Display Output
Graphics Processor
Touchscreen and Buttons
Binder IPC Framework
WiFi Network Interface
Physical Memory Allocator
Power Management (Suspend/Resume)
Real Time Clock
Temperature, Accelerometer, GPS
Cellular Radio (GSM, CDMA)
resources (e.g., via ioctl), we consult the nsproxy pointer of
its task_struct via the current pointer and use it to guide
proper access to virtualized system resources. For bookkeeping
purpose, we maintain an internal mapping table which records
the related nsproxy pointer for each namespace. In our pro-
totype, we ﬁnd it sufﬁcient to support two namespaces, one
for the native Android runtime and another for AirBag. The
corresponding entry is dynamically created when the respective
ﬁrst process (i.e., init or airbag_init) is launched.
B. Context-Aware Device Virtualization
Our prototype permits contentious accesses from the two
running namespaces. To accommodate that, AirBag effectively
multiplexes their accesses to various system resources in a way
transparent to user-level apps (so that normal user experience
will not be compromised). In Table I, we show the list of
virtualized hardware devices supported in Airbag. Due to page
limit, we will explain the six representative hardware devices
in more details.
the visual content
1) Framebuffer/GPU: In AirBag, one of the most important
devices for virtualization is the device screen, which involves
the respective framebuffer and GPU. Speciﬁcally, in Android,
all
to be shown by running apps are
synthesized by the screen updater (SurfaceFlinger) to the
framebuffer memory, which is allocated from the OS kernel but
mapped to userspace. Any update will trigger the framebuffer
driver to issue DMA operations and display the synthesized
image to the device screen. Since we have only one device
screen and there exist two screen updaters from two different
namespaces, we need to regulate which one will gain actual
access to the screen.
For isolation purposes, our prototype allocates a second
framebuffer memory exclusively for the AIR runtime so that
each updater can update its own framebuffer without affecting
each other. But the underlying hardware driver will only deliver
the framebuffer from the active namespace to the screen. In our
prototype, since the framebuffer memory is mapped into the
GPU’s private page table and the page table can be dynamically
updated at runtime, we choose to only activate the framebuffer
memory in GPU from the active runtime.
Our solution works well in all three experimented mobile
devices. However, the prototype on Nexus One deserves addi-
tional discussions. To efﬁciently manage and allocate physical
memory for GPU, the Android support on Nexus One has a
physical memory allocator called pmem. The user-level screen
updater will request physical memory from the /dev/pmem
device. In order for the GPU and the upper-layer screen
updater to render on the screen, a 32MB contiguous physical
5
Native Runtime
screen updater
update
pmem
AirBag Runtime
screen updater’
update
pmem’
time−sharing
active/inactive
GPU
render
image
framebuffer
memory
render
image
framebuffer
memory’
framebuffer
DMA
driver
Fig. 2. Framebuffer Virtualization in AirBag (Nexus One)
there also exist
memory block has been reserved for /dev/pmem. With two
instantiated runtimes, an intuitive solution will be to double
the memory reservation and dynamically allocate the ﬁrst
half for the original Android runtime and the second half
for AIR. In fact, we indeed implemented this approach but
painfully realized that
lots of other meta
information associated with /dev/pmem, which also need to
be decoupled for namespace awareness. For portability, we
aim to avoid changing the internal logic. We then devise
another solution by creating a separate /dev/pmem device for
each namespace (while still doubling the memory reservation).
From the upper-layer runtime perspective, it is still accessing
the same /dev/pmem device. But in our OS extension, we
dynamically map the device ﬁle to /dev/pmem_native and
/dev/pmem_airbag respectively to maintain transparency and
consistency inside the original pmem driver as well as upper-
layer screen updaters. In Figure 2, we summarize the inter-
action between the screen updaters, decoupled pmem device,
GPU, and framebuffer drivers on our Nexus One prototype.
2) Input Devices: After creating a distinct framebuffer for
each namespace, our next step is to appropriately deliver events
from various input devices (e.g., touchscreen, buttons, and
trackball) to the right namespace. Interestingly, Linux kernel
has designed a generic layer, i.e., evdev (event device), which
connects various input device drivers to upper-layered software
components. The presence of such layer makes our prototype
relatively straightforward. Speciﬁcally, the Android runtime (or
its service daemons) will listen to input events (e.g., touch-
screen and trackball) by registering itself as a client represented
as evdev_client in OS kernel. When the underlying driver is
notiﬁed with a pending input event from hardware (e.g. a tap
on the touchscreen), the event is delivered to all the registered
clients. Therefore, upon the input event registration, we will
record its namespace into the evdev_client data structure.
When an input event occurs, similar to the framebuffer driver,
we deliver it only to the registered clients from the active
namespace. In other words, all other clients from inactive
namespace will not be notiﬁed about the event.
3) IPC: After handling basic input and (screen) output
devices, we ﬁnd they are still
insufﬁcient to properly set
up the AIR environment. It turns out that the problem is
due to the custom IPC mechanism in Android. Speciﬁcally,
unlike the traditional Linux IPC that is already isolated by
different namespaces (or cgroups), a custom IPC driver named
binder is developed in Android. With the binder driver, a
special daemon servicemanager will register itself as the