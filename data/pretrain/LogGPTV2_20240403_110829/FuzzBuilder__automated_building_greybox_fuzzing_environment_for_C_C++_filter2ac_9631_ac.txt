pkcs8
read_pem
server
session
spki
ssl_ctx_api
FA
CBS_init
CBS_init
CBS_init
CBS_init
CBS_init
CBS_init
CBS_init
BIO_new_mem_buf
CBS_init
SSL_SESSION_from_bytes
CBS_init
CBS_init
FA
yr_rules_scan_mem
yr_rules_scan_mem
yr_rules_scan_mem
yr_rules_scan_mem
yr_compiler_add_string
prepared seed in OSS-Fuzz. Thus, we provided an arbitrary seed
to OSS-Fuzz because AFL requires at least one seed file to work.
Therefore, the executables of expat are considered to have 1 seed
in Table 6.
The result shows that seeds generated by FuzzBuilder achieved
higher code coverage for 15 executables and a slightly lower one
for 4 executables when compared to OSS-Fuzz. This result infers
632s
e
n
i
l
d
e
t
i
s
i
v
f
o
#
600
400
200
1,000
500
0
c1 c2
e1 e2 e3 e4 e5 e6
10,000
5,000
0
b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 b12
test programs
2,000
1,000
0
y1 y2 y3 y4 y5
FuzzBuilder
OSS-Fuzz
Figure 6: Line coverage comparison when seed files from FuzzBuilder and OSS-Fuzz are used respectively
Table 6: Comparison of the number of seed files by OSS-Fuzz
and FuzzBuilder
program
c1
c2
e1, e2
e3, e4
e5
e6
b1
b2
b3
b4
b5
b6
b7
b8
b9
b10
b11
b12
y1
y2
y3
y4
y5
# of seed files
OSS-Fuzz
6
25
1
1
1
1
42
57
281
85
84
4
14
41
269
2
8
87
6
3
15
8
3
FuzzBuilder
12
57
14
6
7
13
12
6
7
6
6
60
39
13
8
13
65
153
15
14
15
15
216
that seeds generated by FuzzBuilder can help in efficient fuzzing
while satisfying practicality.
This result is obtained because FuzzBuilder can generate a higher
number of seed files than the number of seeds that prepared in OSS-
Fuzz. Unit tests have been established better than fuzzing in the
field of software testing as Table 2 shows. Thus, developers know
how unit tests work and what has to be done to make unit tests
successful. This implies that developers prepare many test inputs
for unit tests because it is one of the things should be satisfied for
successful unit tests. Table 6 shows the number of seed files that
generated by FuzzBuilder and that prepared in OSS-Fuzz. Because
duplicated seeds were removed, the number of seeds led to higher
line coverage in most cases.
Of course, a large number of seed files do not always achieve
high code coverage like b7, y2 and y4 because paths in AFL are
based on basic blocks [36]. The number of basic blocks is not the
same as the number of code lines.
It is evident that seeds prepared in OSS-Fuzz outperformed in b2,
b3, b4, b5, and b9. This is because of the role of CBS_init. CBS_init,
is only used to store a value in a specific memory structure defined
in a library. There is no other instruction for processing this data.
How this data is used depends on which function is called along
with this data structure. This means that a format of an input value
depends on a function sequence, not FA. Unfortunately, a unit test
did not have the same function sequence that is used in fuzzing of
OSS-Fuzz. Therefore, FuzzBuilder cannot extract test inputs for the
function sequence.
4.2 Automatically generated executables
Additionally, we assigned an ID to each executable that is generated
by FuzzBuilder as shown in Table 7. In this table, executable column
denotes executable names of unit tests. Several executables can be
generated from several unit test executables even if they are based
on the same FA such as fb2 and fb3. Further, several executables
can be generated from one unit test executable, if the executables
are based on different FA such as fb1 and fb3.
Test sets for comparing FuzzBuilder with OSS-Fuzz were grouped
by FA. Table 8 shows executables that were included in each test set.
For evaluation, we did fuzzing each executable for 6 hours. However,
if the number of executables differs between FuzzBuilder and OSS-
Fuzz like T3, more time is allocated to the one with less number of
executables. For example, in the case of T3, total fuzzing time of
OSS-Fuzz is six times more than FuzzBuilder. For fair evaluation,
we should do fuzzing fe1 in T3 for 36 hours. The policy of time
allocation in this experiment is reasonable because several function
sequences exist in one executable in FuzzBuilder, while they are
distributed over several executables in OSS-Fuzz. In this way, each
function sequence is tested under the same condition. Exact fuzzing
633Table 7: Generated executables by FuzzBuilder and their ID
and FA
c-ares
executable
ares_test
ares_test
expat
executable
runtests
boringssl
executable
crypto_test
ssl_test
crypto_test
ssl_test
project
ID
fc1
fc2
project
ID
fe1
project
ID
fb1
fb2
fb3
fb4
project yara
ID
fy1
fy2
executable
test-api
test-api
FA
ares_create_query
ares_parse_*
FA
XML_Parse
FA
CBS_init
BIO_new_mem_buf
BIO_new_mem_buf
SSL_session_from_bytes
FA
yr_rules_scan_mem
yr_compiler_add_string
time is specified in parentheses in Table 8 for executables that are
assigned more than 6 hours.
Table 8: Test sets for line coverage comparison of libraries
by using executables
set
T1
T2
T3
T4
T5
T6
T7
T8
fb1 (60)
fb2, fb3
fb4
fy1 (24)
fy2
FuzzBuilder OSS-Fuzz
fc1
fc2
fe1 (36)
c1
c2
e1, e2, e3
e4, e5, e6
b1, b2, b3
b4, b5, b6
b7, b9, b11
b12
b8 (12)
b10
y1, y2, y3
y4
y5
FA
ares_create_query
ares_parse_*
XML_Parse
CBS_init
BIO_new_mem_buf
SSL_SESSION_from_bytes
yr_rules_scan_mem
yr_compiler_add_string
Fig 7 shows line coverage change during 6 hours of fuzzing for
T1, T2, T6, and T8. Fig 8 shows results for T3, T4, T5, and T7, whose
executables were tested for different time ranges. In these sets, most
of the executables that are generated by FuzzBuilder can do fuzzing
libraries with higher code coverage than OSS-Fuzz.
In T7, line coverage of FuzzBuilder is lower than OSS-Fuzz. How-
ever, this result is acceptable, considering the advantage of FuzzBuil-
der. The result of T4 is because of CBS_init function, which can be
explained in the same way as 4.1.
High coverage of FuzzBuilder is based on high coverage of unit
tests. Table 9 shows how many library API functions were called
during each unit test executable is working. In this table, called
column denotes the number of library API functions that are called
while an executable is working. callable column denotes the number
of all library API functions in the libraries that are specified in the
library column. In the case of c-ares and expat, unit tests called
most of library API functions. Further, at least 44% of library API
functions were called while unit tests are working. This implies
that unit tests can give a chance to explore various parts of library
code.
Table 10 shows how many library API functions were called
during each executable generated by FuzzBuilder is being tested.
The number of library API functions that are called by executa-
bles generated by FuzzBuilder is lower than that by unit tests be-
cause FuzzBuilder deletes test functions that are not related to
FA. Nonetheless, FuzzBuilder still provides an opportunity to call
various library API functions for library fuzzing without in-depth
knowledge of libraries.
Table 9: The number of library API functions that are called
by unit test
project
c-ares
expat
boringssl
yara
library
libcares.so
libexpat.so
libcrypto.so
libssl.so
libyara.so
unit test
executable
ares_test
runtests
crypto_test
ssl_test
test-api
called callable
58
79
1220
47
61
84
2727
79
Table 10: The number of library API functions that are called
by executables generated by FuzzBuilder
project
c-ares
expat
boringssl
yara
library
libcares.so
libexpat.so
libcrypto.so
libssl.so
libyara.so
FuzzBuilder
executable
fc1, fc2
fe1
fb1, fb2
fb3, fb4
fy1, fy2
called callable
23
70
707
44
61
84
2727
79
Naturally, coverage of FuzzBuilder may include coverage that
is not affected by fuzzing directly because a test function may call
library API functions that are not directly related to FA. This is
because FuzzBuilder copies the whole body of test functions that
have FA. However, coverage of FuzzBuilder still provides a valid