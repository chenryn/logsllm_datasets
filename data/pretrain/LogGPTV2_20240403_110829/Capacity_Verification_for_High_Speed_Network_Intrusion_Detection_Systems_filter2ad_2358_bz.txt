Introducing Reference Flow Control
295
range of possible operations, but restrictions are set on whether an operation
is allowed to be combined with another - in other words, whether the latter
operation can exploit some eﬀect of the former.
A security policy deﬁnition consists then in the deﬁnition of reference bags. Of
course, the precise reference requirements of operations are also subject to the se-
curity policy. For instance, it is natural that reading the contents of /etc/shadow
requires appropriate references that should appear only in very speciﬁc reference
bags; however, reading the screen coordinates of the mouse cursor will probably
not be considered as a security-critical operation, so it will not have any par-
ticular requirement and, most certainly, references related to the mouse cursor
object will not even exist at all in the system. In section 4.2, we will see that a
very straightforward reference bags deﬁnition actually allows attacks to be de-
tected; however the problem of implementing any possible security policy using
reference bags remains an open issue.
In addition to requiring references, operations can create new objects or de-
stroy existing ones, along with the corresponding references. The open operation
above, if successful, creates a “ﬁle descriptor” object (fd) with (among others)
read and write methods deﬁned for it that allow the ﬁle contents to be accessed.
By deﬁnition, if an operation is executed in some domain, its consequences
must be allowed to be executed in the same domain. For this reason, it is re-
quired that newly created references are inserted into the same reference bag
that allowed the operation execution2. Thus, any operation depends on a ref-
erence bag to be legal and potentially modiﬁes this bag, by creating references
(as in the open example) and/or by deleting references (for example, when a ﬁle
descriptor is closed). This is expressed using the following notation:
Deﬁnition: Ω being an operation and S a reference bag such that Ω is legal in
S, we note ΩS its execution allowed by references from S. We note Ref(ΩS)
the reference bag that results from ΩS.
Reference requirements of operations and this Ref relation actually specify an
operating system’s model. In the example above:
(cid:1)
(cid:2)
Ref
close(fd)S
= S \ {RS(f d.read), RS(f d.write)}
If close(fd) is executed using references from bag S, then its execution will
remove references RSf d.read and RSf d.write from this bag.
2.2 Reference Flow
As stated above, our focus is on dealing with situations where the attacker aims
at extending his rights to perform operations that raise illegal consequences.
Thus, if an operation Ω2 is a consequence of an operation Ω1(we note Ω1 ⇒ Ω2),
it must obey the same security restrictions as Ω1. The decision whether Ω1 ⇒ Ω2
can rely on the system’s internals knowledge (when such knowledge exists; it is
2 In this paper, we further denote system operation executions simply as “operations”
296
J. Zimmermann, L. M´e, and C. Bidan
known for instance that accessing a special ﬁle under the /dev hierarchy on a
Linux system can involve loading a device driver from /lib/modules), a logical
dependency between these operations (some information ﬂows from Ω1 to Ω2,
i.e. Ω1 has set an object state that is accessed by Ω2) or a combination of both.
In practice, this means that an operation Ω1 transmits the reference bag
that made it possible to its consequence Ω2. If Ω2 is executed by another pro-
cess, references ﬂow to that process, thus allowing it to execute new operations
as consequences of Ω2. This mechanism actually enforces access control rules
throughout sequences of causally dependent operations, which play here the role
of “subjects”.
To be able to enforce security policies against attacks by delegation, one
needs thus to deﬁne Ref rules for such causal dependencies. These rules im-
plement the operation semantics. Let us consider an operation ΩS
2 executing
fd2=open(File,O RDONLY), noted ΩS
2 ::fd2=open(File,O RDONLY), S being
an appropriate reference bag. If the ﬁle writing was created by some operation
ΩQ
1 , then
Ref(ΩS
2 ) = Ref(ΩQ
1 ) ∪ {RQf d2.read}
If File can be opened for reading, then its actual content must be read
within the same domain it was written in (here denoted by the reference bag
Q), to preserve security restrictions across causal dependency.
On the other hand, opening the ﬁle for overwriting is not the consequence of
any previous operation except the opening (as it erases the contents), thus for
ΩS
3 ::fd2=open(File,O WRONLY|O TRUNC), the rule is
3 ) = S ∪ {RS(cid:1)f d2.write}
Ref(ΩS
In most cases, an operation involves actually more than one method call.
Appending to a ﬁle (using O APPEND) means that both reading and writing
are consequences of the latest ﬁle write, while opening in a read-write mode
(O RDWR) is a special case: reading is a consequence of the operation that
wrote the ﬁle (here ΩQ
1 ) while writing is a consequence of the opening. This
requires reference creation in two separate reference bags. Thus, in this case,
open represents actually two independent operations (opening for reading and
opening for writing) that both create references to the same object fd2.
Such rules must be deﬁned for any considered operation. In most cases, they
are trivial (as in the close case). For operations that involve object state access,
they have the form above. This is also true for object creation : for instance in
Unix, this means actually writing into a directory whereas accessing the created
object involves reading the directory.
Implementation on Existing Systems
2.3
It is straightforward to implement discretionary access control using references.
Since access permissions are not granted on a “subject/object” basis, user iden-
tities are used for authentication purposes only. As the authentication process
Introducing Reference Flow Control
297
itself is treated as a separate problem, we represent it here by an unique special
login(u) operation method call that sets the calling process’ default reference
bags conforming to the user’s identity u This is functionally equivalent to the
real Unix model where the authentication procedure sets the new process’ uid
and gid. Since the login operation success relies on correct authentication and
not on execution context, it has no reference requirements.
An Access Control List is then the set of user identities whose default ref-
erence bags include the required references to perform a given object method
call. An ACL change modiﬁes the user’s default reference bags in the authenti-
cation component; furthermore this operation can be broadcast to all processes
if the change is required to be immediately eﬀective (a simple way to do this is
to state that any operation is a logical consequence of an ACL change). There
is no direct equivalent of the Unix “object owner” concept, as “subjects” are
not really represented here, thus there are no “chown” and “chgrp” operations.
If needed, object ownership can be modeled as a special usage of ACLs: upon
process initialization, a reference bag is created that contains only references to
objects owned by the process’ identity.
3 Application to Intrusion Detection
In this section, we present a proof-of-concept intrusion detection scheme for a
generic Unix-like operating system. Our goal is to provide users and applications
with a known environment and some form of backward compatibility.
As we stated in the introduction, we focus speciﬁcally on intrusions where an
attacker aims at gaining some unauthorized privilege. If we suppose the system
implementation is such that it won’t allow any user to perform an operation
without having the required rights, attacks we are interested in consist in com-
plex series of steps that involve possibly more than one subject identity to get
eventually an operation performed, but by deﬁnition each step per-se does not
violate the security policy. We call these “attacks by delegation”.
We describe how a Unix-like security policy can be implemented using the
proposed model. Intrusion detection issues are then discussed.
3.1 A Model of an Unix-Like Operating Environment
We consider that a security policy within the Unix operating environment obeys
the following rules:
– Operation on objects are authorized according to discretionary access con-
trol;
– Subject identities require authentication. We take no hypothesis about the
authentication process itself, though.
For the system to be secure, it must also conform to a third rule that is not met
by current implementations, as experience shows:
298
J. Zimmermann, L. M´e, and C. Bidan
– No Unix subject should be able to exploit a privilege that does not corre-
spond to its identity.
The implementation discussed in this example follows the scheme described in
section 2.3. Moreover, if we consider only the original Unix access control model,
relying solely on “user”, “group” and “other” permissions for three operations
(read, write and execute) with no extended ACLs, we can further simplify the
deﬁnition by considering only these three classes of references. Each user iden-
tity is then simply modeled by a reference bag that contains the corresponding
read, write and execute references, in the same way, there is a reference bag
representing each group and an additional reference bag other. The default ref-
erence bags for each process contain the bag corresponding to the process’ uid,
all reference bags corresponding to groups the user is member of, and the other
bag.
For instance, considering the following ﬁle:
-rw-r--r-- 1 bob users 3275 mar 21 09:14 README
There
exists
a
Ruid:bob(READM E.openread)
a
a Rother(READM E.openread)
reference,
Rgid:bob(READM E.openread)
reference and a Ruid:bob(READM E.openwrite) reference.
reference,
Such a deﬁnition provides actually a coarse view of the system but remains
functionally equivalent to the atomic model. It is usable for a basic implementa-
tion of the model, because it reduces considerably the amount of references and
reference bags to be considered while matching well the default Unix semantics,
but on the other hand, it suﬀers of the same limits as the Unix security policy
itself. It is not possible, for example, to devise a policy such that “ﬁles from
/tmp should not be copied into /etc” using this scheme, although it can be
easily deﬁned by introducing additional reference bags.
We consider that enforcing a security policy on root’s actions is pointless if
root’s privileges are unrestricted and encompass those of all other users. Thus
we take into account only operations performed by regular users. Nevertheless,
in Unix, users can still perform operations that do not ﬁt in their privileges using
sudo. By analogy, the equivalent of the /etc/sudoers ﬁle can be implemented
using speciﬁc reference bags. For example, the operation of editing /etc/shadow
is authorized by a bag editshadow that contains all references required to read
and write this ﬁle.
3.2 Detecting Intrusion Symptoms
Considering the model deﬁned in the previous section, the reference bags created
by login(u) represent the operations the user u is authorized to make use of.
An attacker’s goal is then to execute for his own purpose operations that do
not belong to these bags. The security policy’s purpose is to make such goals
impossible.
For example, if no reference bag S containing RS(/etc/shadow.openread) is
created by login(bob), then on the one hand, no consequence of login(bob)
Introducing Reference Flow Control
299
will involve a reference to open /etc/shadow for reading. On the other hand,
since the reference RS(/etc/shadow.openread) will ﬂow to any consequence of
open(/etc/shadow,O RDONLY), we can say that these two operations are not au-
thorized to have a common consequence, which would be precisely the symptom
of an attempt by bob to read /etc/shadow.
In its simplest form, the intrusion symptom detector can raise an alarm upon
such an intrusion attempt. This provides a particular form of an access control
system. Such an alarm indicates an operation violating the security policy, that
can be dealt with in diﬀerent ways:
– the operation can simply be prohibited, as is done in the default Unix access
– the operation can be purposely authorized in order to catch the attacker in
control model
obvious oﬀense
– the intrusion attempt can be reported along with an execution log, for foren-
sic analysis purposes
Another option is an early warning approach: an alarm is raised as soon as an
illegal combination of references appears (i.e. as soon as diﬀerent reference bags
owned by the same process contain references allowing an operation that could
not be executed otherwise). Such an alarm indicates an operation that cannot
be executed and could be correlated to further actual policy violation alarms,
which would provide valuable forensic information.
In any case, the security policy is expressed using reference bags deﬁnitions.
Intrusions appear to violate this policy, but how an illegal operation is eventually
achieved is not taken into account, thus there is no need for a known attack
scenarii database, neither a learned authorized usage proﬁle.
4 Experimental Implementation
This section describes a prototype we use to implement the proposed approach
on a Linux operating system. We show on two examples how real intrusion
symptoms can be detected. A discussion of some strong points and weaknesses
of this approach follows.
4.1 Prototype
By now, our implementation perform non-runtime security policy checking by
relying on execution logs, like most other intrusion detection systems do. Note
however that this is a pure convenience approach we use to ease development
and testing. These logs represent system execution scenarii that can easily be
replayed by a simulator. Our further goal is to replace the simulator by an in-
core implementation, thus the need for logs will be eliminated to allow runtime
security policy enforcement.
The logs are generated by a speciﬁc Linux kernel module. This module hooks
on the kernel API and a report is transmitted to the system logger each time
300
J. Zimmermann, L. M´e, and C. Bidan
a system call is executed. In its purpose, this is similar to the strace utility,
but has a system-wide eﬀect in that the logs contain all system calls observed
during the period the module is active, with the following properties:
– Local process order of operations is respected;
– Local order of object access operations is respected.
As Linux follows, with a few exceptions, the Unix “everything is a ﬁle” paradigm,
the set of system calls to observe is actually quite restricted:
– Process and thread creation/termination;
– User and/or group modifying;
– Input/output descriptor handling;
– System V IPC access control.
Logs generated by this module are then parsed by a reference propagation sim-
ulator. For each process that existed at the log beginning, a default set of ref-
erence bags is provided, based on the process’ identity and group membership
as described in section 3.1. The simulator itself implements reference propaga-
tion rules that match closely information ﬂow in an Unix system, i.e. reference
ﬂowing from a cause to its eﬀect:
– Opening a ﬁle for reading is a consequence of the last write to that ﬁle,
thus references ﬂow from a write operation to the next read operation, as
described in section 2.2;
– By analogy and to conform with standard Unix semantics, the accept op-
eration creates a reference to the newly created socket. This reference is
deﬁned to belong to the same reference bag as the references used to exe-
cute the corresponding connect operation. At the moment, only local socket
connections are treated.
System V shared buﬀers apart, there are no memory buﬀer access semantics
deﬁned in Unix. The only reference we can deﬁne to handle them are thus simple
memory pointers. The only general rule that we can state is that reading from
a memory buﬀer is causally dependent on writing to that buﬀer. Because this
is obviously a weak rule that can be easily bypassed by a malicious program,
a more accurate solution consists in overloading the malloc and free library
calls so that memory buﬀer allocation is emulated through a mmap operation.
The corresponding temporary ﬁle access can then be monitored.
As stated above, we suppose that authentication is performed through a
supposed login operation. To mimic at best the Unix model, we consider the
operations setuid and setgid, whose eﬀect is to construct reference bags ac-
cording to the new user’s identity. More precisely, current user and group bags
are suppressed and replaced by new ones; the other bag is identical for all users,
thus needs no change. In addition, references to objects that are tied to the pro-
gram’s execution (memory objects, pipes etc...) and thus are not explicitly taken
into account in the default reference bag deﬁnition are transferred to the new
user bag, to remain coherent with Unix semantics (only the “owner” process of
these objects can access them).
Introducing Reference Flow Control
301
For authentication to be enforced, setuid and setgid are authorized only
as a consequence of login. More precisely:
Ref [login(u)] = {Rsetuid:u(setuid.u)}
A setuid(u) operation simply wraps the setuid.u method call and thus re-
quires a RSsetuid.u reference. The login operation creates these references in
the setuid : u bag which never contains any other reference: this isolates these
references from other reference ﬂows.
4.2 Examples of Attack Detections
In this section, we describe two examples of classes of attacks that can be de-
tected using our proposed approach. These are presented as a proof of concept,
a throughout evaluation of the approach and its practical performance will be
subject to a further publication.