bile applications to register custom URI schemes for them-
selves [2, 18]. When a URI with a custom scheme is vis-
ited inside a mobile browser or an embedded browser (e.g.,
WebView), the mobile OS will subsequently launch the ap-
plication registered with the custom scheme. Using this ap-
proach, a service provider application can simulate a browser
redirection by sending the access token to a URI with the
honest relying party’s custom scheme. However, unlike for
web applications, where the Domain Name System (DNS)
maintains a global one-to-one mapping between a host name
and a unique web principal, mobile operating systems al-
low multiple applications to register for the same custom
scheme. This many-to-one mapping between multiple lo-
cally installed applications and a single custom scheme is
fundamentally ﬂawed for redirection.
Lack of application identity – The absence of a proper
redirection mechanism for mobile applications introduces
another complication for mobile service providers – their in-
ability to identify message receivers. The security of OAuth
depends on the service provider’s ability to send conﬁdential
messages (e.g., access tokens) to speciﬁc relying parties.
For web applications, this is accomplished through browser
redirection, where the browser is entrusted to deliver the
message to the web principal given by a host name. Ad-
ditionally, the DNS is responsible for maintaining an asso-
ciation between a host name and a web principal. Hence,
assuming that the DNS and the browser are well-behaved, a
web-based service provider can eﬀectively send conﬁdential
messages to a relying part of its choosing. Unfortunately, the
same concept does not apply to mobile applications. That
is, for both iOS and Android, installed applications do not
have an origin associated with them. It is not immediately
obvious how a mobile service provider could guarantee that
a conﬁdential message is only sent to its intended recipient.
Although in practice, diﬀerent approaches have been used
to facilitate message passing between diﬀerent principals,
most of these methods are incorrect. We demonstrate later
in Section 5 that many developers have ill-conceived notions
of the real recipients for diﬀerent message passing mecha-
nisms on mobile devices.
Client-side protocol logic – Although client-side mes-
sage passing mechanisms such as the Android Intent [17]
are frequently used as a replacement for browser redirection,
there is a clear distinction between using browser redirection
and using a client-side message passing mechanism. When
a browser redirection is used by a web service provider, the
request is directly sent to the relying party’s server and han-
dled by server-side logic. However, when a client-side mes-
sage passing mechanism (such as the Android Intent) is used
by a mobile service provider, the logic that ﬁrst processes the
message is located on the user’s device. Although in theory,
all of the core protocol logic for a mobile relying party could
reside on a server, while the client-side application is only
used to deliver and receive messages to and from the server,
this is diﬃcult to do in practice. From our observations,
many mobile developers incorporate parts of their applica-
tions’ core logic into their client-side applications. The issue
with this practice is that when OAuth is used for authenti-
cation, the user’s device is assumed to be untrusted. Hence,
including security sensitive protocol logic or data with the
client-side application could allow a malicious user to bypass
security checks and steal conﬁdential data (e.g., the relying
party secret).
5. STUDY OF REAL-WORLD MOBILE
APPLICATIONS
In the previous section, we highlighted several portions
of the OAuth speciﬁcations that are critical for security,
and also pointed out several diﬀerences between the mobile
platforms, as compared to the web platform which OAuth
is primarily designed for. Of course, a main concern our
study aims to address is how well real developers are able
to tackle these critical portions in the protocol speciﬁca-
tions, and whether they have suﬃcient awareness about the
platform diﬀerences. As mentioned in Section 3, our study
includes 616 real-world mobile applications. Our selection
was unbiased: the selected applications are the top 300 free
applications in Google Play, the top 200 free social applica-
tions, the top 100 free communication applications, as well
as 16 other clearly popular applications.
We found that 149 out of the 616 applications imple-
ment OAuth. Surprisingly, 89 of them (59.7%) were incor-
rectly implemented, which resulted in vulnerabilities. We
have given our best eﬀort to communicate with the ap-
plication vendors, including Facebook, Twitter, Instagram,
Quora and many others.
In most cases, we have received
their positive acknowledgments.
In this section, we delve into a number of representative
vulnerability cases. The goal is to demonstrate diﬀerent
ways real-world developers interpret the OAuth speciﬁca-
tions, and to provide our study result about the pervasive-
ness of each of these issues.
5.1 Storing relying party secrets locally
One common issue was that many developers fail to un-
derstand the purpose of the relying party secret, and thus
store it locally inside the client application. We believe that
the terminology of OAuth confuses developers signiﬁcantly
– the relying party secret is referred to as the “consumer se-
cret” by OAuth 1.0 and “client secret” by OAuth 2.0, where
the terms consumer and client are used by each speciﬁcation
to describe the relying party. These names are extremely
misleading for developers who have never studied the spec-
iﬁcations. For application developers, it is very reasonable
to believe that the term consumer or client is referred to the
user. Hence, many relying parties believed that it was safe
to bundle their secrets with their mobile applications.
Two notable developers making this mistake were Pin-
terest and Quora. Both Pinterest and Quora used Twitter
Figure 3: Pinterest’s OAuth dialogue forged using a stolen
application secret.
as a service provider for authentication, and both of them
bundled their relying party secrets with their mobile appli-
cations. To make the matter worse, after obtaining their
secrets using simple reverse engineering, we discovered that
the same secrets were used for the Pinterest and the Quora
web applications. Since Twitter mainly used OAuth 1.0, this
gave an adversary the ability to generate arbitrary OAuth
request tokens for Quora and Pinterest. Using these tokens,
we (acting as the attacker) could direct users (both web and
mobile users) to a legitimate Twitter page with the dialogue
box shown in Figure 3. Once the user clicks authorize, Twit-
ter’s access token will be sent to the attacker, giving him/her
full access to the user’s account.
We have reported this problem to Pinterest and Quora,
both of them have acknowledged this issue and revoked their
application secret. Quora also took the extra step of dis-
abling their Twitter authentication mechanism completely
for its Android application.
5.2 Using authorization ﬂows for authentica-
tion
Another common confusion amongst mobile developers is
treating authorization and authentication as the same prob-
lem. Vulnerabilities due to this issue were described in the
literature [7, 43]. As we mentioned in Section 4.1, the use-
case of authentication is not considered in both the OAuth
1.0 and the OAuth 2.0 speciﬁcations. However, the terms
“authenticate” and “authentication” are still used frequently
in both speciﬁcations. For example, Section 3 of OAuth
1.0 [26] and Section 2.3 of OAuth 2.0 [27] describe a method
called “client authentication”.
In actuality, these sections
describe the method for which the relying party proves its
identity to the service provider using its application ID and
secret, not the method to identify the user. However, it is
easy to see that without contexts, this can lead to devel-
oper confusions. Many relying parties using various service
providers fall victim to this misunderstanding. In this sec-
tion, we primarily focus on Facebook’s relying parties, but
the same concept can be applied to others as well.
Facebook advocates its mobile relying parties to use the
implicit grant to access core APIs. The implicit grant is
a simpler method for authorization, and in a way provides
better immunity against developer mistakes since it does
not rely on the secure storage of relying party secrets (since
this secret is not used in the implicit grant). However, as
mentioned previously in Section 4.1, the implicit grant is not
safe to use for authentication. This is because the access
token used in the implicit grant is not bound to its intended
relying party. Hence, an adversary could use a user’s access
token issued to the malicious application to login as the user
for the benign relying party’s application.
Facebook realized this issue, and added an additional step
to enhance its implicit grant for authentication, called the
appsecret proof. This step essentially transformed the im-
plicit grant into a hybrid between itself and the OAuth 1.0
ﬂow. This security-enhanced implicit grant is shown in Fig-
ure 4a. The key diﬀerence between the security-enhanced
implicit grant and the regular OAuth 2.0 implicit grant is the
addition of an appsecret proof parameter. This parameter
is a cryptographic hash of the access token using the relying
party secret as its key that is included with every Facebook
API call. To provide security for authentication, Facebook
veriﬁes during each API call (Step 4 of Figure 4a) that the
principal that provides the appsecret proof is the same prin-
cipal that the access token was issued to (in Step 2). Un-
fortunately, because the use-case of authentication is not
well understood by many mobile developers, the security-
enhanced implicit grant is seldom used in practice by Face-
book’s relying parties.
We now present our observations on the diﬀerent Face-
book protocol ﬂows real-world mobile developer were using
for authentication. Our study included 72 relying parties in
total, all of which were using Facebook for authentication.
Usages of the regular implicit grant. We observed a
large number (61 out of 72, or 84.7%) of the relying parties
using the standard implicit grant for authentication. All of
these applications were vulnerable to the attack previously
described in Section 4.1 against the implicit grant. Some
notable applications included Avast Mobile Security & An-
tivirus and Instagram. We have reported our ﬁndings to all
the vulnerable applications. So far 22 (36%) of them have
acknowledged our reports, of which 11 have ﬁxed their issues
by switching to the security enhanced version of the implicit
grant. Facebook rewarded us with a $5000 bounty for the
vulnerability we discovered in Instagram.
Correct usages of appsecret proof. Of the 11 relying
parties that used the security enhanced implicit grant (i.e.,
using appsecret proof) for authentication, 10 had the correct
implementation (e.g., following the protocol ﬂow described
in Figure 4a). Examples of these applications include Hulu
and airbnb.
Incorrect usage of appsecret proof. Interestingly, we
discovered a diﬀerent interpretation of the appsecret proof
ﬂow by the mobile application Keek (a social video appli-
cation with more than 60 million users), illustrated in Fig-
ure 4b. In Keek’s ﬂow, the appsecret proof was sent from
the user’s mobile device (i.e., Keek’s mobile application) to
Facebook’s server. When this proof was accepted by Face-
book and returned to Keek’s mobile application, Keek in-
formed its server that the appsecret proof was accepted by
Facebook. At this point, Keek fell back to the standard
implicit grant, and chose to complete the user ID exchange
using the standard implicit grant. Unfortunately, the issue
with this ﬂow is that a malicious user launching an attack
against the implicit grant could forge Facebook’s response in
Step 6 of Figure 4b (since the attacker is also the user), and
convince Keek that Facebook accepted the appsecret proof.
This would negate the purpose of the appsecret proof check
and downgrade the protocol into an implicit grant. We have
reported this problem to Keek, but they have not responded.
Our contact in Facebook oﬀered to follow up with all vendors
who are subject to this issue, including Keek.
Although we focused on Facebook’s relying parties in this
section, the problem is universal. For example, 71.4% of
Google relying parties also had the same misconception, and
were using authorization ﬂows for authentication.
5.3 Handling redirection in mobile applications
In Section 4.2, we pointed out that there currently ex-
ist no deﬁnitive, platform-independent mechanism to per-
form redirection for mobile applications. In this section, we
present four methodologies used by real-world developers for
handling redirection:
iOS custom scheme, Android Intent,
mobile browser and WebView. In addition, we analyse the
security of each of these methods.
5.3.1 Custom scheme and Intent
Previously in Section 4.2, we discussed that the custom
scheme mechanism in iOS and the Intent mechanism in An-
droid bear close resemblance to browser redirection.
It is
not immediately obvious whether they can be used securely
for redirection. Recall the issue with these mechanisms is
that it is diﬃcult to determine the true recipients of their
messages. According to Apple, if two iOS applications at-
tempt to register the same custom scheme, behavior regard-
ing which app will be referenced is undeﬁned [1]. As for
Android, we discovered that many mobile service providers
were not directly invoking their relying party applications
(e.g., using Intents), but rather sending data through the
return values of their own applications (e.g., when invoked
by a relying party). However, when passing data through
return values, additional checks are needed to verify that the
caller application matches with the intended recipient of the
data. We investigated several service providers using cus-
tom schemes and Intents, including Google, Facebook and
Foursquare. We present our results below.
For iOS, we concluded that no service provider in our
study was using custom schemes correctly. That is, no
service provider could correctly determine the identity of
its message recipient. When we presented this problem to
Facebook, Facebook acknowledged this issue and added that
“There is unfortunately no completely secure way to trans-
fer an access token from our application to a client appli-
cation.” This problem has severe implications because the
scheme mechanism is used by Facebook’s iOS application to
deliver access tokens to their relying parties. Since Facebook