### Mobile Application Redirection and Security Challenges

#### Custom URI Schemes
Mobile applications can register custom URI schemes for themselves, allowing the mobile operating system (OS) to launch the registered application when a URI with that scheme is accessed. This approach enables service provider applications to simulate browser redirection by sending access tokens to URIs with the honest relying party's custom scheme. However, unlike web applications, where the Domain Name System (DNS) maintains a one-to-one mapping between host names and unique web principals, mobile OSs allow multiple applications to register the same custom scheme. This many-to-one mapping is fundamentally flawed for secure redirection.

#### Lack of Application Identity
The absence of a proper redirection mechanism for mobile applications introduces a significant security challenge: the inability to identify message receivers. OAuth security relies on the service provider's ability to send confidential messages, such as access tokens, to specific relying parties. For web applications, this is achieved through browser redirection, where the browser delivers the message to the web principal specified by the host name, and DNS ensures the association between the host name and the web principal. In contrast, mobile applications do not have an associated origin, making it difficult for a mobile service provider to ensure that a confidential message reaches its intended recipient. Although various methods have been used to facilitate message passing between different principals, many of these are incorrect. We will demonstrate in Section 5 that many developers have misconceptions about the true recipients of different message passing mechanisms on mobile devices.

#### Client-Side Protocol Logic
Client-side message passing mechanisms, such as Android Intents, are often used as alternatives to browser redirection. However, there is a critical difference: browser redirection sends requests directly to the relying party's server, while client-side mechanisms process the message on the user's device. Although theoretically, all core protocol logic could reside on a server, with the client-side application only delivering and receiving messages, this is challenging in practice. Many mobile developers incorporate parts of their core logic into client-side applications, which poses a security risk. When OAuth is used for authentication, the user's device is considered untrusted. Including security-sensitive protocol logic or data in the client-side application could allow a malicious user to bypass security checks and steal confidential data, such as the relying party secret.

### Study of Real-World Mobile Applications

In the previous section, we highlighted several critical aspects of the OAuth specifications and the differences between mobile and web platforms. Our study aims to evaluate how well real-world developers handle these critical aspects and whether they are aware of the platform differences. Our study includes 616 real-world mobile applications, selected from the top 300 free applications in Google Play, the top 200 free social applications, the top 100 free communication applications, and 16 other popular applications.

We found that 149 out of the 616 applications implement OAuth. Surprisingly, 89 of them (59.7%) were incorrectly implemented, leading to vulnerabilities. We have made efforts to communicate with the application vendors, including Facebook, Twitter, Instagram, Quora, and others, and have received positive acknowledgments in most cases.

#### Storing Relying Party Secrets Locally
A common issue is that many developers misunderstand the purpose of the relying party secret and store it locally within the client application. The terminology in OAuth can be confusing; the relying party secret is referred to as the "consumer secret" in OAuth 1.0 and the "client secret" in OAuth 2.0. These terms can mislead developers who have not studied the specifications, leading them to believe it is safe to bundle their secrets with their mobile applications.

Notable examples include Pinterest and Quora, both of which bundled their relying party secrets with their mobile applications and used the same secrets for their web applications. This allowed an adversary to generate arbitrary OAuth request tokens for Quora and Pinterest, potentially gaining full access to users' accounts. We reported this issue to Pinterest and Quora, and both acknowledged and addressed it. Quora also disabled their Twitter authentication mechanism for their Android application.

#### Using Authorization Flows for Authentication
Another common confusion among mobile developers is treating authorization and authentication as the same problem. While the OAuth specifications do not consider the use-case of authentication, the terms "authenticate" and "authentication" are frequently used, leading to misunderstandings. For example, Facebook advocates the use of the implicit grant for accessing core APIs, which is simpler and does not rely on the secure storage of relying party secrets. However, the implicit grant is not safe for authentication because the access token is not bound to the intended relying party.

Facebook introduced an additional step, the appsecret proof, to enhance the implicit grant for authentication. This step transforms the implicit grant into a hybrid flow, adding a cryptographic hash of the access token using the relying party secret as the key. Unfortunately, many mobile developers do not understand the need for this enhanced flow, leading to vulnerabilities. We observed that 61 out of 72 (84.7%) relying parties using Facebook for authentication were using the standard implicit grant, making them vulnerable to attacks. Some notable applications included Avast Mobile Security & Antivirus and Instagram. We reported our findings, and 22 (36%) of the applications acknowledged and fixed the issue, with Facebook rewarding us for the vulnerability discovered in Instagram.

#### Handling Redirection in Mobile Applications
In Section 4.2, we discussed the lack of a definitive, platform-independent mechanism for performing redirection in mobile applications. Here, we present four methodologies used by real-world developers for handling redirection: iOS custom schemes, Android Intents, mobile browsers, and WebViews. We also analyze the security of each method.

- **Custom Scheme and Intent**: The custom scheme mechanism in iOS and the Intent mechanism in Android are similar to browser redirection. However, it is challenging to determine the true recipients of messages. Apple states that if two iOS applications attempt to register the same custom scheme, the behavior is undefined. For Android, many service providers were not directly invoking their relying party applications but instead passing data through return values, requiring additional checks to verify the caller application. We investigated several service providers, including Google, Facebook, and Foursquare. For iOS, no service provider in our study was using custom schemes correctly, as none could correctly determine the identity of the message recipient. Facebook acknowledged this issue, stating, "There is unfortunately no completely secure way to transfer an access token from our application to a client application." This has severe implications, as the scheme mechanism is used by Facebook's iOS application to deliver access tokens to their relying parties.

In conclusion, our study highlights the challenges and misconceptions faced by mobile developers in implementing OAuth securely. Addressing these issues requires a better understanding of the OAuth specifications and the unique challenges of mobile platforms.