Pass
Pass
Pass
Fail
Pass
Pass
Pass
Pass
Fail
Pass
Pass
Pass
Pass
Fail
Pass
Upgrade
Upgrade
Source
Source
Upgrade
Source
Source
Source
Source
Source
Source
Source
Source
Upgrade
Upgrade
Source
Upgrade
Upgrade
Upgrade
Upgrade
Upgrade
Upgrade
Source
Source
Upgrade
Upgrade
Double free
Format string
Buffer overﬂow
Buffer overﬂow
Input checking
Buffer overﬂow
Buffer overﬂow
Buffer overﬂow
Buffer overﬂow
Buffer overﬂow
Buffer overﬂow
Buffer overﬂow
16532
196945
325431
715973
198355
739123
541574
350792
849993
723910
516492
184030
325603
958321
457622
226184
398025
613459
240790
DoS
DoS
DoS
Buffer overﬂow
Operational
Exploit
None
Exploit
Exploit
Exploit
Exploit
Exploit
Exploit
Exploit
Exploit
Testing Type
Load/Exploit
Load/Codepath
Operational
None
Codepath
Operational
Exploit
Exploit
None
Exploit
Codepath
Codepath
Operational
None
Operational
Table 2: Summary of real patches tested with OPUS
forth in developing OPUS.
6.4.2 MySQL password bugs
For our second application experience, we evaluated
MySQL–a service which is more stateful than Apache,
and thus would have a higher cost to shutdown and
patch. We chose two simple vulnerabilities found in the
MySQL database management application. The ﬁrst
allows a local or remote user to bypass authentication
with a zero-length password [30]. The second exploits a
buffer overrun in the password ﬁeld allowing execution
of arbitrary code [31]. We obtained exploits available
on the web for both to help evaluate the success of the
patch [24, 19].
Both patches supplied by
Patch characteristics.
the vendor for these vulnerabilities were very simple
“one-liners” that changed either a single line or a handful
of lines contained within a single function. From our
survey of common vulnerabilities and patches, this is a
very common characteristic of buffer overﬂow patches.
Functional evaluation. We were able to success-
fully patch the running MySQL service while it was
under a simulated load from a simple database perfor-
mance benchmark (sql-bench). Running the ﬁrst attack
on the unpatched process allowed us to gain access to
the DBMS server and running the second attack allowed
us to crash the server. After applying the patch, both
exploits failed to compromise the server, and both were
returned a proper error message.
Because of
Front end and back end experience.
the rather simple nature of the patches themselves and
the fact that we performed this test after our experience
with Apache, these particular patches did not uncover
any new issues in either the front or back end. The
patches were both successfully generated and applied
with little difﬁculty.
The MySQL case study is signiﬁcant
Conclusion.
in that it shows OPUS can work with more stateful
applications (e.g., database servers).
These stateful
applications are most likely to beneﬁt from avoiding
USENIX Association
14th USENIX Security Symposium
299
the restart associated with the application of traditional
patches. Moreover, stateful services such as database
servers offer a high opportunity cost for those seeking to
exploit vulnerabilities. Thus, the ability to successfully
patch services like MySQL is an important validation of
our work.
6.5 Utility of static analysis
Was our static analysis useful in producing safer dynamic
security patches? The short answer is no. The reason is
that only a hand-full of the security patches we examined
modiﬁed non-local program state. For the few patches
that did modify non-local program state, we used our
understanding of program semantics to determine that
the corresponding modiﬁcations were in fact not danger-
ous. As an example, consider the following excerpt from
BIND 8.2’s “nxt bug” patch [28]:
...
if ((*cp & 0x01) == 0) {
/*
The bitmap
* Bit zero is not set; this is an
* ordinary NXT record.
* must be at least 4 octets because
* the NXT bit should be set. It
* should be less than or equal to 16
* octets because this NXT format is
* only defined for types  16) {
hp->rcode = FORMERR;
return (-1);
}
}
...
The above code checks if a ﬁeld in the incoming mes-
sage’s header is properly formed, and if it is not, it writes
an error code (FORMERR) to a memory location on the
heap (hp->rcode) and returns −1 to indicate failure.
We know that the write is benign: upon return from the
patched function, BIND checks the value of hp->rcode
for the error type and outputs a corresponding error mes-
sage. However, the OPUS static analysis issues the fol-
lowing false warning: error: 2089:
writing to
dereferenced tainted pointer (hp). We encoun-
tered similar warnings in our evaluations, but our under-
standing of the source code allowed us to quickly discard
them as false positives.
7 Related work
Dynamic updates: Many existing works in dynamic
software updating make use of strong programming lan-
guage support (e.g., dynamic binding and type-safety
as provided in Lisp, Smalltalk, and Java) [10] [16].
All of these approaches target a wide class of software
updates—not just security patches—and can make strong
guarantees about the safety of a runtime patch. OPUS, in
contrast, does not assume strong language support nor
can it perform arbitrary upgrades. In fact, a fundamen-
tal design criteria of our system is that it must be able
to handle existing, widely-deployed software and conse-
quently, our decision to target C applications reﬂects this
generality vs. practicality tradeoff.
Dynamic update techniques that don’t rely on strong
language support have also been explored. Early work
by Gupta et al. [14], for example, targets C applications
and is the closest to ours in technique, but they neither
target security patches nor do they use static analysis
to estimate patch safety. More recently, Stoyle et
[26] presented a dynamic updating system for a
al.
C-like language that provides strong safety guarantees.
Although more general in the type of patches it admits,
their system requires software updates to be written in
a special-purpose language; true support of C is cited
as future work. While OPUS does not provide strong
safety guarantees, it does not require that applications be
constructed in a custom language.
Shield [32]
Shield:
is a system of vulnerability-
speciﬁc network ﬁlters that examine incoming and
outgoing network trafﬁc of vulnerable applications and
correct malicious trafﬁc en-route. Properly constructed
Shield policies can be more reliable than conventional
patches and like dynamic patches, applying policies in
end hosts is a non-disruptive procedure. To distinguish
our work from Shield, we note the following differences:
• Shield requires the programmer to specify all vul-
nerability approach vectors—a task that involves
signiﬁcant programmer effort and risks introducing
false positives as well as false negatives when deal-
ing with complicated applications. Unlike Shield,
OPUS does not require the programmer to specify
a vulnerability state machine. Little programming
effort beyond what would be required to construct a
conventional patch is necessary.
• While Shield can defend against network-borne
pathogens quite effectively, it cannot defend against
ﬁle-system worms, protocol-independent applica-
tion vulnerabilities (e.g., bugs in a script inter-
preter), or memory allocation problems not tied
with any speciﬁc malicious trafﬁc.
In contrast,
OPUS can defend against most vulnerabilities that
can be ﬁxed via conventional security patching.
• Monitoring network trafﬁc on a per-application ba-
sis induces a performance penalty on Shielded ap-
300
14th USENIX Security Symposium
USENIX Association
plication that is proportional to the amount of net-
work trafﬁc. Dynamic patches result in negligible
performance overhead once applied.
Redundant hardware: Redundant hardware offers
a simple, high-availability patching solution. Visa,
for example, upgrades its 50 million line transaction
processing system by selectively taking machines down
and upgrading them using the on-line computers as a
temporary storage location for relevant program state
[22]. However, Visa’s upgrade strategy is expensive and
as a result precludes use by those with fewer resources.
Perhaps more severe,
it requires that developers and
system administrators engineer application speciﬁc
upgrade strategies, thereby adding to the complexity of
development and online-evolution [16]. Our standpoint
is that ensuring system security should neither be expen-
sive nor require ad-hoc, application-speciﬁc solutions.
Microreboots: Microreboots [7] provide a conve-
nient way to patch applications composed of distinct,
fault-tolerant components—install the new component
and then restart it. While a microreboot approach to
patching may be viable for enterprise web applications,
it cannot serve as a generic non-disruptive patching
mechanism. The reason for this is that a microre-
bootable system must be composed of a set of small,
loosely-coupled components, each maintaining a mini-
mal amount of state. OPUS differs from microreboots
in that it makes no assumptions about the coupling
of software components: a monolithic system can be
patched just as easily as a heavily compartmentalized
system.
8 Future work
8.1 Prototype
In order to perform stack inspection, our current pro-
totype performs a backtrace on the stack using frame
pointers and return addresses. Some functions, however,
are compiled to omit frame pointers (e.g., several func-
tions in GNU libc). Furthermore, stack randomization
tools make it difﬁcult to determine the structure of the
stack. While we have a makeshift solution to deal with
these problems, it insists that applications preload wrap-
per libraries–a requirement that somewhat tars our goal
of “no foresight required”. Thus, we are currently ex-
ploring more transparent mechanisms to deal with these
issues.
Many security patches are targeted at shared libraries.
While the current implementation of OPUS cannot dy-
namically patch libraries, the ability to do so would
be valuable in closing a vulnerability shared by several
applications. Thus, we are working on extending our
ptrace-based stack-inspection mechanism to work with
multiple processes, all of whom share a common vulner-
able library.
Finally, many system administrators choose to turn off
ptrace support, leaving OPUS unable to function. To
deal with this issue, we are currently working on harden-
ing ptrace support for OPUS.
8.2 Static analysis
Assessing the safety of a dynamic patch is undecideable
in the general case, so the burden falls on the static analy-
sis to alert the user of all possible changes that may fault
the application when a patch is applied. With respect to
tracking writes to new non-local data, the current imple-
mentation of static analysis could use a tighter bound on
the taint set. This can be accomplished by implementing
proper support for multi-level pointer variables (one can
think of structs and multi-dimensional arrays as multi-
level pointer variables). A more sophisticated algorithm
to compute pointer aliases and associated taintings is also
being considered. The analysis could also beneﬁt from
better handling of explicit casts and non-straightforward
uses of the C type system.
In addition to the above reﬁnements, we are con-
sidering implementing path-sensitive taint ﬂow analy-
sis which would effectively re-enable warnings for all
blocks (as if they were new to the patch) depending on
some variable being assigned a new value in the patched
code.
Finally, the success of static analysis hinges on our
ability to tell which program fragments are new. Cur-
rently, this is accomplished by diff-ing the source trees, a
method that is too imprecise to arrive at a complete set of
statements being modiﬁed if the correspondence between
statements and line numbers is anything but uniform. We
are currently considering program differencing [17] as an
alternative to shallow diffs.
9 Conclusion
Despite our attempt to alleviate safety concerns through
static analysis, the complexity introduced by dynamic
update, although often negligible when applied to secu-
rity patches, makes the hard problem of ensuring patch
reliability even harder. In the end, the added complexity
may deter developers from adopting the technology or
worse, prevent users from patching their systems more
quickly. However, by looking at a large sample of real
security vulnerabilities, we have shown that a signiﬁcant
number of applications within our problem scope could
have been safely patched with OPUS had OPUS been
available at the time of vulnerability announcement. This
USENIX Association
14th USENIX Security Symposium
301
result strongly supports our claim that dynamic security
patching is safe and useful in practice. To this effect,
we have presented a viable alternative to the traditional
security patching methodology.
10 Acknowledgments
We thank the anonymous reviewers, Nikita Borisov, Eric
Brewer, our shepherd Peter Chen, David Wagner, and the
Berkeley SysLunch and Security reading groups for their
valuable feedback.
References
[1] US-CERT Vulnerability Notes Database.
cert.org/vuls/.
http://www.kb.
[2] Apache security bulletin. http://httpd.apache.org/info/
security_bulletin_20020617.txt, June 2002.
[3] ARBAUGH, W. A., FITHEN, W. L., AND MCHUGH, J. Win-
dows of vulnerability: A case study analysis. In IEEE Computer
(2000).
[4] ARCE, I., AND LEVY, E. An analysis of the slapper worm. IEEE
Security and Privacy 1, 1 (2003), 82–87.
[5] BEATTIE, S., ARNOLD, S., COWAN, C., WAGLE, P., WRIGHT,
C., AND SHOSTACK, A. Timing the application of security
patches for optimal uptime. In LISA (2002), USENIX, pp. 233–
242.
[6] BREWER, E. Lessons from giant-scale services. In IEEE Internet
Computing (Aug. 2001).
[7] CANDEA, G., KAWAMOTO, S., FUJIKI, Y., FRIEDMAN, G.,
AND FOX, A. Microreboot - a technique for cheap recovery. In
Proceedings of the 6th Operating System Design and Implemen-
tation (Dec. 2004), pp. 31–44.
[8] CERT.
CERT Advisory CA-2002-17 Apache Web Server
http://www.cert.org/
Chunk Handling Vulnerability.
advisories/CA-2002-17.html, June 2002.
[9] DTORS.NET.
Apache chunked encoding example exploit.
http://packetstormsecurity.org/0207-exploits/
apache-chunk.c.
[10] DUGGAN, D. Type-based hot swapping of running modules (ex-
tended abstract).
In ICFP ’01: Proceedings of the sixth ACM
SIGPLAN international conference on Functional programming
(2001), ACM Press, pp. 62–73.
[11] DUNAGAN, J., ROUSSEV, R., DANIELS, B., JOHNSON, A.,
VERBOWSKI, C., AND WANG, Y.-M. Towards a self-managing
software patching process using persistent-state manifests. In In-
ternational Conference on Autonomic Computing (ICAC) 2004
(2004).
[12] FREE SOFTWARE FOUNDATION, INC. Using the GNU Compiler
Collection. Boston, MA, USA, 2004.
[13] GOBBLES SECURITY. Apache “scalp” exploit. http://www.
hackindex.org/boletin/0602/apache-scalp.c.
[14] GUPTA, D., AND JALOTE, P. On-line software version change
using state transfer between processes. Softw., Pract. Exper. 23,
9 (1993), 949–964.
[15] GUPTA, D., JALOTE, P., AND BARUA, G. A formal framework
for on-line software version change. IEEE Trans. Softw. Eng. 22,
2 (1996), 120–131.
[16] HICKS, M., MOORE, J. T., AND NETTLES, S. Dynamic soft-
ware updating. In PLDI ’01: Proceedings of the ACM SIGPLAN
2001 conference on Programming language design and imple-
mentation (2001), ACM Press, pp. 13–23.
[17] HORWITZ, S.
Identifying the semantic and textual differences
between two version of a program. In Proceedings of the ACM
SIGPLAN 90 Conference on Programming Language Design and
Implementation (June 1990), pp. 234–245.
[18] INTERNATIONAL ORGANIZATION FOR STANDARDIZATION.
ISO/IEC 9899:1990: Programming languages — C. International
Organization for Standardization, Geneva, Switzerland, 1990.
[19] K-OTIK SECURITY.
Remote MySQL Priviledges Exploit.
http://www.k-otik.com/exploits/09.14.mysql.c.php.
[20] MITUZAS, D. Freebsd scalper worm. http://dammit.lt/
apache-worm/.
[21] NECULA, G. C., MCPEAK, S., RAHUL, S. P., AND WEIMER,
W. Cil: Intermediate language and tools for analysis and transfor-
mations of c programs. In Proceedings of the 11th International
Conference on Compiler Construction (2002), pp. 213–228.
[22] PESCOBITZ, D. Monsters in a box. Wired 8, 12 (2000), 341–347.
[23] RESCORLA, E. Security holes . . . who cares? In 12th Usenix
Security Symposium (Washington, D.C., August 2003), pp. 75–
90.
[24] SECURITEAM.COM. Local and Remote Exploit for MySQL
http://www.securiteam.com/
(password scrambling).
exploits/5OP0G2A8UG.html.
[25] SHANKAR, U., TALWAR, K., FOSTER, J. S., AND WAGNER, D.
Detecting Format String Vulnerabilities with Type Qualiﬁers. In
Proceedings of the 10th Usenix Security Symposium (Washing-
ton, D.C., Aug. 2001).
[26] STOYLE, G., HICKS, M., BIERMAN, G., SEWELL, P., AND
NEAMTIU, L. Mutatis mutandis: Safe and predictable dynamic
software updating. In Proceedings of the 32nd ACM SIGPLAN-
SIGACT Symposium on Principles of Programming Languages
(2005), pp. 183–194.
[27] THE SOFTWARE DEVELOPMENT LIFE CYCLE TASK FORCE,
S. A. Improving security across the software development lifecy-
cle. Tech. rep., National Cyber Security Partnership, April 2004.
[28] US-CERT. Vulnerability Note VU#16532 BIND T NXT record
processing may cause buffer overﬂow. http://www.kb.cert.
org/vuls/id/16532, November 1999.
[29] US-CERT. Vulnerability Note VU#715973 ISC BIND 8.2.2-
P6 vulnerable to DoS via compressed zone transfer, aka the zxfr
bug. http://www.kb.cert.org/vuls/id/715973, Novem-
ber 2000.
[30] US-CERT. Vulnerability Note VU#184030 MySQL fails to
properly evaluate zero-length strings in the check scramble 323()
function. http://www.kb.cert.org/vuls/id/184030, July
2004.
[31] US-CERT. Vulnerability Note VU#516492 MySQL fails to val-
idate length of password ﬁeld. http://www.kb.cert.org/
vuls/id/516492, September 2004.
[32] WANG, H. J., GUO, C., SIMON, D. R., AND ZUGENMAIER,
A. Shield: Vulnerability-driven network ﬁlters for preventing
known vulnerability exploits. In Proceedings of SIGCOMM ’04
(Aug. 2004).
302
14th USENIX Security Symposium
USENIX Association