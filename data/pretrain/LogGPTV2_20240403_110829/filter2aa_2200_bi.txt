}
}
catch( SocketException )
{
string message = "Could not get a port 80 socket.\n"
+ "Make sure the port is not in use.\n"
+ "(IIS uses port 80 on most servers)";
mainFormPtr.Alert( null, message );
}
catch( ThreadAbortException )
{
// Application is shutting down
}
}
/// 
/// Clean up any resources being used.
/// 
public void Stop()
{
// Stop listening for client requests.
listening = false;
Thread.Sleep( 100 );
myServer.Stop();
if( myThread != null )
{
myTarget.Stop();
// Stop the target thread.
myThread.Abort();
myThread.Join();
}
}
}
}
Ghost
Ghost
Ghost
Ghost 跟踪器
GhostTracker 窗体如图 12－2 所示，它包含了一个列出了已连接的所有 rootkit 的 IP 地
址的列表控件。双击列表的任何一个条目都会打开 rootkti 的控制面板。这并不是一个商业
rootkit 控制器的主页面，这只是一个用来展示远程控制器操作的简单例子。
图 12－2
控制窗体
控制窗体如图 12－3 所示，它包含一个实物模型的控制面板来让读者明白设计的原则。
控制面板里的按钮都是不起作用的。
图 12－3
总结
本章所开发的 rootkit 控制器主要是一个学习的工具，但是它的设计方法可以广泛地用
在远程控制器的设计上。即使你的远程控制器的需要很可能有和我这个例子不同，但是有几
个共性是一样的：
一个产生监听线程的主程序
一个产生控制线程的监听线程
一些显示状态的窗体
连接控制器
本书的编码部分就到此结束了。余下的章节包括了更多的关于 rootkti 的检测和 rootkti 防护
的理论性主题。
笫十三章 Rootkit
Rootkit
Rootkit
Rootkit 的检测
概述
到目前为止，本书已经讨论了 rootkti 的实现技术，但是由于 rootkit 检测技术的问题给
我们带来了许多设计上的问题。本章介绍现在流行的 rootkit 检测技术，让 rootkit 设计者们
对影响 rootkit 实现的细节能够有一个深入的了解。
本章包含下面内容：
检测方法
检测软件
如何处理一个被检测到的 rootkit
安全模式
检测方法
下面列出一些检测 rootkit 的方法：
把文件列表和在一个干净环境下生成的文件列表作比较
把文件列表和其相应的 NTFS 主文件作比较
把注册表扫描结果和一个干净环境下生成的注册表扫描结果作比较
把注册表和其相应的磁盘映像作比较
使用不同的系统函数来比较进程和服务
使用 rootkit 注入技术来比较进程和服务
检测交换数据流的使用
把内核系统调用表和其相应 的磁盘映像作比较
确定内核系统调用表入口在内核边界线内
反内核函数和其相应的磁盘映像作比较
把 INT 2E 和相应的 Windows NT 函数作比较
把 SwapContext 的进程和进程链表作比较
把内核内存和已知的 rootkit 特征码作比较
前面的几个比较方法是在 一个已知的正常环境和一个有怀疑的环境之间进行的。一个
已知的正常环境是指任何一个(不一定是 windows)没有和不可信的环境共享软件组件的操
作。这可以是一个从一个 CD 里启动的新操作系统，
一个和不可信的的操作系统在同一磁
盘驱动器上的一个分区操作系统，或者是一个远程连接的操作系统。只要是没有和有怀疑的
操作系统有组件共享的操作系统，列表比较的方法都可以找出隐藏的东西。
把要目标操作系统的文件列表和已知的正常环境下产生的文件列表作比较可以检测到
隐藏的文件。这是检测文件隐藏类 rootkit 的一个非常棒的方法。由主机生成的文件列表并
不会显示被 rootkit 隐藏了的文件，而一个干净的系统生成的文件列表则会显示出所有文件。
通过比较由不同系统调用所生成的文件列表同样能够检测到隐藏文件，或者把一个文件列表
和其相关联的 NTFS 主文件表作比较。在两个这样的文件列表之间有任何一处的不同都表明
了有 rootkit 的存在。
不幸的是，运行一个现代的操作系统需数量巨大的文件和目录,在这么多的文件和目录
隐藏文件是多余的。Rootkit 作者们掌握了许多从不同位置来加载 rootkit 的技术。有了这么
多的文件，目录，注册表项和加载技术，再加上混淆系统服务命名约定技术，就没需要去隐
藏文件了。特别是现在的文件隐藏检测工具都是免费使用的，所以你就不要指望使用文件隐
藏检测工具能够检测出什么新的 rootkit 了。
注册表项的隐藏也可以用目标系统上的注册表扫描列表文件和一个干净系统产生的扫
描文件作比较来检测出来。另外，注册表篡改还可以所注册表和其相应的磁盘文件作比较来
检测出来，你需要的是对注册表文件格式有一定的了解，通过分析注册表文件(Hives)来确定
注册表里包含有哪些内容，然后把结果和实际的注册表扫描结果作比较，这样可以发现一些
使用了简单的注册表项隐藏技术隐藏的注册表项。
不幸的是，由于文件非常多，导致在注册表里有很多的地方可以隐藏。可能需要一些混
淆(不把设备驱动的位置存放在 HKLM\Software\MyRootkit 里)但是随着注册表检测工具的
增多，导致注册表隐藏技术的作用越来越小，因此，别指望使用注册项隐藏检测工具能够发
现现在的 rootkit。
通过检测隐藏的进程和服务也是发现 rootkit 的另一种方法。一些 rootkit 检测工具是使
用 rootkit 技术来检测 rootkit 的。它们通过注入内核的方式来使自己获得检测进程和服务的
能力。把注入内核前的进程和服务列表和注入内核后的进程和服务列表作比较可以发现隐藏
的进程和服务。rootkit 检测工具还可以通过使用不同的操作系统调用或者从干净的系统和目
标系统创建进程和服务列表。总之，在两个列表之间的任何一处的不同都意味着有 rootkit
的存在。
不幸的是，这样还是无有一些隐藏进程法被检测出来，并且许多 rootkit 并不使用服务，
所以这些 rookit 检测方法对现在的许多 rootkit 都不起作用。
使用了交换数据流(ADS)并不能保证有 rootkit 的存在，但在 rootkit 和 ADS 之间存在逻
辑和统计关联，这使得 ADS 检测结果不具有准确性，但一个 rookit 存在的可能性可能会产
生一个最终会揭露使用 ADS 的原因的研究。
一个文件跟踪系统可能会选择使用 ADS 来标记检测到的文件，一个视频游戏制造商可
能会选择使用 ADS 来添加拷贝保护信息到可执行文件里，一个源代码控制系统可能会使用
ADS 来跟踪上系统的版本信息，ADS 技术可以用在许多方面上，但是经过统计，使用 ADS
的很可能是和 rootkit 有关的。
不幸的是，现在的 ADS 检测工具仅仅是测试链接到文件对象的数据流，而忽略了其它
形式的 ADS 链接。另外，通过一些简单的加密或者操作系统上其它的成千上万的小交换数
据流可以混淆尝试对 ADS 的检测。
内核调用表钩子可以通过把系统调用表和在磁盘上相应的映像作比较检测到。用来创建
系统调用表的是系统文件 ntoskrnl.exe。进行系统调用表的比较需要的是了解系统在引导时
是如何分析 ntoskrnl.exe 的。内核调用表钩子也可以通过比较系统调用表条目是否在边界内。
这可以通过调用 ntdll.dll 里导出的 ZwQuerySystemInformation 函数来实现，通过给它传递
SystemModuleInformation 参数来获取 ntoskrnl.exe 的信息。这个函数会返回一个包含的
ntoskrnl.exe 基地址和大小了数据结构。任何一个系统调用表条目超出了这个边界都表明了
当前存在有 rootkit。
不幸的是，正如笫 4 章所提到的，可以使用跳转挂钩的技术来代替系统调用表钩子。而
且，有很多程序由于各种原因也会挂钩系统调用表。要判断哪个钩子是正常的，哪个钩子是
需要移除的是一件非常困难的事情。
内核函数(跳转)钩子可以通过在内核函数的开头或者附近搜索一些特别的跳转来检测
到。这种方法需要 rootkit 检测工具首先要重建系统调用表然后跟踪每个系统调用来检查立
即数型的无条件跳转。也可以把内存中的内核函数和磁盘上的代码作比较，假如是重定位的
地址则要跳过。
不幸的是，跳转钩子的跳转不一定是立即数型的无条件跳转，并且对于 rootkit 对
ntoskrnl.exe 内核映像的修改并没有任何的保护，因为有太多的操作系统版本，太多的服务
包，太多的补丁，所以要检测映像篡改是一件非常困难的事情。但是，正如文件，注册表，
进程和系统调用表篡改一样，终有一天映像篡改也会成为一种 rootkit 检测技术。
使用一个中断门来进行系统操作可以绕过由一些 rootkti 插入的钩子。这是检测用户层
钩子的一个非常好的方法，因为 Windows NT 函数全部都可以通过使用 2E 中断来绕过。文
件列表，目录列表，注册表项和注册表值通过使用或者不使用 Windows NT 函数都可以扫描
到。因为这两种调用方法都是调用的同一个内核函数，这两种扫描技术之间没什么分别。如
果这两个扫描结果有任何的不同都表明系统中存在有 rootkit。
不幸的是，用户层钩子可以因为加入映像的进程的名字不同而不同，它们在进行挂钩时
会有目的地不去挂钩那些检测工具。这种技术会给人一种虚假的安全感。另外，用户模式下
的 Windows NT 函数钩子很难覆盖所有 rootkit 隐藏所需要的函数。这就使得 rootkit 不得不
去使用一些其它的隐藏技术。
把通过 SwapContext 传递的进程块和在双链表结构的进程列表里的进程块作比较可以
检测到本书里所使用的进程隐藏技术的隐藏进程。无论是一个进程被置换出去还是一个进程
被置换进来都会调用 SwapContext。顺着置换进来的进程的 KTHREAD(存在 EDI 里)可以找
到新进程的 EPROCESS 块，这个进程块也可以在双链表进程列表里找到。这里有任何的异
常都可以表明存在有 rootkit。图 13－1 展示了 SwapContext 进程隐藏检测过程
不幸的是，SwapContext 有可能会被 rootkit 挂钩。当 rootkit 所在的进程被置换进来时，
钩子函数可以在调用原函数之前临时性地把 rootkit 进程条目链接到进程列表里，而在调用
原函数后又把 rootkti 进程条目从进程列表里移除。这会给 rootkit 检测工具造成一个错误的
假象是：操作系统的其余部分都能够看到隐藏的进程。
扫描内核内存也可以用来检测已知的 rootkit。这是一个复杂的任务，这需要扫描工具去
置换要扫描的进程的上下文或者进行虚拟－－物理地之间的转换。一旦完成了这一步就可以
通过比较扫描的内存和已知的 rootkit 特征码来检测到存在的 rootkit。
不幸的是，内存扫描不能够检测出新的 rootkit，而且没有办法来避免隐藏进程，内存扫
描甚至可能检测不到有确定特征码的已知 rootkit。
到这里，可能你已经注意到这里的模式：一段讲 rootkit 检测技术，下面一段讲防止被
这个技术检测到的方法。这样形成了一个列表，这个列表在最近几年增长的幅度相当地大。
但是格式却没有变。对天每一种新的检测技术，都会有（或者很快会有）相应的对付方法。
这种能够促进技术发展的 rootkit 和反 rootkit 之间的对抗预计会一直继续下去。
这种争取控制权的对抗的一个副作用是 rootkt 会很快地老下去。我这里所说的“老”是
指“很容易被现成的反 rootkit 软件检测到”。这并不是说这是一个像反病毒软件那样基于特
征码的 rootkit 保护系统，而是一个基于检测器的保护系统，例如由专业团队开发的专业
rootkit，专业 rootkit 保护系统，在不久的将来就会主导着反 rootkit 的市场。这样就保证了能
够很快地对抗到新的 rootkit 隐藏技术，并且已经开发的检测工具马上就可以传送到所有用
户的计算机里。
不幸的是，rootkit 的根本目的我们是不确定的，而病毒的根本目的是进行传播。这就使
得 rootkit 的检测比病毒的检测要困难得多，这大大地增大了从一种新的 rootkit 隐藏技术的
开始使用到最终能够对抗这种隐藏技术的时间。
这种争取控制权的对抗的另一个对 rootkit 设计者有用的副作用是有大量现成的 rootkit
检测工具可以用来验证 rootkit 的强度。通过对 rootkit 对许多 rootkit 检测工具对抗能力的测
试，rootkit 设计者不仅能够保证 rootkit 现在能够隐藏在系统里，还能够保证以后也能够隐
藏在系统里，因为现有的 rootkit 检测工具往往会实现一些在其它 rootkit 检测工具已经实现
的新功能。
检测工具
这节所提到的检测工具在“附录 A：免费软件”里都有介绍，在这里介绍只针对 rootkit
的检测作介绍。要想获取这些工具的更详细信息和本书提到的其余软件的信息可以查看附录
A。
Strider
Strider
Strider
Strider GhostBuster
GhostBuster
GhostBuster
GhostBuster
这个检测工具具有如下功能：
文件列表比较
注册表项比较
进程列表比较
INT 2E 比较
GhostBuster 是一个相当不错的 rootkit 检测工具。更重要的是，它是一个 Microsfot rootkit
检测工具。由于微软在 rootkit 检测这项工作上下了很大的功夫，所以这个软件的使用范围
很可能会迅速地扩大。一旦这个软件流行起来，这个工具快速的开发和定期的升级会使得
GhostBuster 成为检测 rootkit 的标准。如果你正在开发一个新的要发布出去的 rootkit，很快
你就需要测试它对抗 GhostBuster 的能力。
Strider GhostBuster 在现阶段还是一个正在研究的项目，现在是还没有发布出去的。
RootkitRevealer
RootkitRevealer
RootkitRevealer
RootkitRevealer
此工具的网址是 www.sysinternals.com/utilities/rootkitrevealer.html.
些工具具有如下功能：
文件列表比较
注册表项比较
交换数据流检测
RootkitRevealer 在对比较老的 rootkit 的检测方面做得非常好，但是如果 rootkit 没有使
用文件隐藏，注册表条目隐藏和交换数据流这些技术，RootkitRevealer 就没有什么用了。再
说 微 软 最 近 收 购 了 Sysinternals ， RootkitRevealer 已 经 是 算 是 一 个 废 弃 的 项 目 了 。
RootkitRevealer 如图图 13－2 所示
图 13－2 显示了在运行本书笫 9 章所开发的 rootkit 后用 Rootkit Revealer 扫描的结果。
这里开始的两个是误报，误报是对一个 rootkit 存在的错误报告。在这种情况下，如果用非
正常的方法去访问一个注册表项就可能会被标志为 rootkit，即使它们只能从本地系统账户访
问。跟在这两个误报后面的两条信息清楚的表明了我们的 rootkit 隐藏了一个注册表项。不
幸的是，在这两条信息后面是由反病毒软件引起的误报，这就会对其它扫描结果的真实性造
成影响。随后又是一条明确地表明了我们 rootkit 的存在的信息，因为这时扫描到了一个隐
藏的目录。后面的就是由于在扫描期间使用了注册表编辑器而引起的更多的误报。
F-Secure
F-Secure
F-Secure
F-Secure Blacklight
Blacklight
Blacklight
Blacklight
此产品的官方网站是 www.f-secure.com/blacklight.
这个检测工具功能如下：
文件列表比较
目录列表比较
进程列表比较
BlackLight 具有界面非常友好的优点。在下载完后，用户可以通过一个按钮进行一次全
面的扫描。隐藏文件，隐藏目录，隐藏进程的检测不需要在一个正常的系统上进行一次扫描
就能自动完成。BlackLight 不会检测任何形式的进程隐藏，而且现在的 rootkit 都没有使用文
件或者目录隐藏技术，所以不要期望能用这个检测工具来检测到新的比较新的 rootkit。
F-Secure BlackLight 如图 13－3 所示。
图 13－3 显示了一个在运行本书笫 9 章所编写的 rookit 后的扫描结果。这个扫描没有发
现 rootkit 的存在。这更多的是对测试环境的一个反应而不是测试环境，由于我们在进行扫
描时没有运行 HideMe，而我们的隐藏目录里又没有文件在里面，所以当时是没有进程隐藏
的。然而它确实有肋于我们了解通过一些简单的混淆来代替隐藏技术可以很容易地对抗一些
rootkt 检测工具。
RootKit
RootKit
RootKit
RootKit Hook
Hook
Hook
Hook Analyzer
Analyzer
Analyzer
Analyzer
此产品的官方网站是
www.resplendence.com/hookanalyzer.
这个检测工具功能如下：
系统调用表比较
RootKit Hook Analyzer 是一个使用起来非常简单的内核系统调用表条目校验工具。一个
rootkit 使 用 内 核 钩 子 需 要 挂 钩 ZwFileOpen(ntoskrnl.exe) 和 ZwQuerySystemInformaton
（SystemModuleInformation）来误导 RootKit Hook Analyzer。因为这些钩子是其它内核钩子
的前提，RootKit Hook Analyzer 可能无法覆盖掉所有钩子来检测专门进行隐藏内核钩子的
rootkit。
RootKit Hook Analyzer 同时也是一个测试内核钩子的实现的一个非常好的工具。如果一
个内核钩子无法被 RootKit Hook Analyzer 检测到，那么很有可能这个 rootkit 在很长的一段
时间里都不会被检测到。图 13－4 显示了 RootKit Hook Analyzer 的界面。
上图显示了在运行了本书笫 9 章编写的 rootkit 之后的一个扫描结果。结果清楚的显示
出了我们的 rootkit 所安装的所有内核系统调用表钩子。不幸的是，工具不能分辨出钩子具
体是属于哪个软件的，而且没有给我们提供验证和修正这个问题的任何信息。如果我们知道
一点关于 Windows 系统内核的知识，ZwEnumerateKey, ZwOpenKey, 和 ZwQueryKey 被挂
钩都意味着 rootkit 的存在，但如果我们知道得更多一些话我们就会意识到这些钩子同时也
是在基于主机的入侵防御系统中用来虚拟注册表的。不知道钩子是属于哪个软件的，很难决
定如何去处理。
IceSword
IceSword
IceSword
IceSword
IceSwrod 从很多网站都可以下载到。
这个工具具有如下功能：
文件列表比较
注册表项比较
进程列表比较
系统调用表比较
IceSwrod 是一个供专业人员使用的 rootkit 检测工具。它还可以检测后门，反病毒软件，
浏览器工具条和其它和 rookti 不相关的软件。你需要一些时间去学会怎么去使用 IceSword
和如何去辨别正常和非正常测试结果间的差异。但如果你有意投入这些时间去学会 IceSword
的话，它会是一个非常有用的工具。不幸的是，作为一个个人 rootkit 检测工具，由于 IceSword
的复杂性，严重地限制了它的使用数量。图 13－5 显示了 IceSword 对隐藏目录的检测。图
13－6 显示了对内核钩子的检测。图 13－6 显示了一个内核模块列表。图 13－８显示了对隐
藏注册表项的检测。图１３－９显示对通信端口的检测。
图 13－5
图 13－6
图 13－7
图 13－8
图 13－９
像 Rootkit Hook Analyzer 一样，这里清楚的显示了内核钩子但没有表明它们是如何被安
装的。隐藏目录和隐藏注册表项通过是进行内核挂钩的原因。不幸的是 IceSword 没有对这
些异常的条目进行高亮显示或者一些其它的提示。IceSword 并没有提示这些目录和注册表
项在普通软件里是否是隐藏的，这就需要用户自己去检验 IceSword 里显示的目录和注册表
项是否会出现在一般的软件列表里。另外，TDI 通信端口和设备驱动条目成功地从 IceSword
里隐藏了。综上，异常的数据并不会明确地呈现在普通用户面前。
Sophos
Sophos
Sophos
Sophos Anti-Rootkit
Anti-Rootkit
Anti-Rootkit
Anti-Rootkit
些产品的官方网站是 www.sophos.com/products/free-tools/sophos-anti-rootkit.html.
这个工具的功能如下：
文件列表比较
注册表条目比较
进程列表比较
像 BlackLight 一样，Sophos 是一个非常友好的工具。在下载完后，用户可以通过一个
简单的按钮来进程一次完全的扫描。隐藏文件，隐藏表条目和隐藏进程的检测不需要在一个
正常的系统上进行扫描就能自动完成。同时像 BlackLight 一样，Sophos 不会检测隐藏进程，
所以不要期望能用这个检测工具来检测到新的比较新的 rootkit。图 13－10 显示了 Sophos
Anti-Rootkit 的界面。
图 13－2
图 13－2 显示了在运行本书笫 9 章所开发的 rootkit 后用 Sophos Anti-Rootkit 扫描的结
果。结果里包含了 4003 个可疑的调用表项，在这种情况下，即使我们的注册表项真的在这
个列表里面也没有什么所谓的了。无论是否被检测到，我们隐藏的注册表项已经完全地隐藏
在 Sophos version 1.1 大量的误报里了。
如何处理一个被检测到的 rootkit
rootkit
rootkit
rootkit
笫一步要做的就是去验证扫描到的这些 rootkit。你可以选择去信任扫描到这些 rootkit
的工具，也可以信任你自己对 windows 系统的理解，或者再进行进一步的验证。在这三种
做法中，大多数用户都会选择进行进一步的验证，但是我们该如何去验证一个 rookit 呢？
不要期望 rootkit 检测工具会对异常的地方做出详细的描述，如果是一个内核或者用户
模式的钩子，检测工具可能无法找出这个钩子是哪个进程安装的。如果是一个隐藏文件，目
录或者是进程，那么有一些步骤可以判断这些的现象的源头，但是这些步骤通常涉及到一些
安全软件，例如反病毒软件或者基于主机的入侵防御系统。
很多 roorkit 检测机制都不能定位到产生这些异常行为的进程。然而没有进程名，服务
名或者设备驱动名，要进行进一步的验证是非常困难的。如果进行了进一步的验证后还是无