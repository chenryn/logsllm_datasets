of T . We have to further use the lower-layer data structures
to distinguish it from the other data structure. However, it
is possible that T is not distinguishable from another data
structure R if their structures are isomorphic.
Deﬁnition 3. Given two data structures T and R, let the
pointer ﬁeld offsets of T be f1, f2, ..., and fn, pointing to
types t1, t2, ..., and tn, resp.; the pointer ﬁeld offsets of R
be g1, g2, ..., and gm, pointing to types r1, r2, ..., and rm,
resp.
T and R are isomorphic, denoted as T ⊲⊳ R, if and only
if
(1) n ≡ m;
(2) ∀1 ≤ i ≤ n fi ≡ gi
(2.1)
∧ ( ti ⊲⊳ ri
(2.2)
∨ a cycle is formed when deciding ti ⊲⊳ ri
(2.3)
).
Intuitively, two data structures are isomorphic, if they
have the same number of pointer ﬁelds (Condition (1)) at the
same offsets (2.1) and the types of the corresponding pointer
ﬁelds are also isomorphic (2.2) or the recursive deﬁnition
runs into cycles (2.3), e.g., when ti ≡ T ∧ ri ≡ R.
Figure 3(b) (i) shows the deﬁnitions of some data struc-
tures in Figure 3(a). The data structures whose deﬁnitions
are missing from the two ﬁgures do not have pointer ﬁelds.
According to Deﬁnition 3, B ⊲⊳ BB because they both have
two pointers at the same offsets; and the types of the pointer
ﬁelds are isomorphic either by the substructures (E ⊲⊳ EE)
or by the cycles (B ⊲⊳ BB).
Given a data structure, we can now decide if it has a
unique signature. As mentioned earlier, we assume that
pointers are not null and are not of the void* type.
 Assume
is
g1 · r1 · (f2 − f1) · r2 · (f3 − f2) · ... · (fn − fn−1) · rn,
t1 ⊲⊳ r1, t2 ⊲⊳ r2, ... and tn ⊲⊳ rn.
sub-pattern
the
in
IP P (R)
T must have a unique pointer pattern, that is, the pattern
cannot be generated from any other individual data struc-
ture through expansions.
The proof of Theorem 1 is omitted for brevity.
Intu-
itively, the theorem speciﬁes that T must have a unique
pointer pattern (i.e., a signature) as long as there is not an
R such that IP P (T ) is a sub-pattern of IP P (R) and the
corresponding types are isomorphic.
If there is an R satisfying conditions  and  in
the theorem, no matter how many layers we inspect, the
structure of T remains identical to part of the structure of R,
which makes them indistinguishable. In Linux kernels, we
have found a few hundred such cases (about 12% of all data
structures). Fortunately, most of those are data structures
that are rarely used or not widely targeted according to OS
security and forensics literature.
Note that two isomorphic data structures may have dif-
ferent concrete pointer ﬁeld types. But given a memory
image, it is unlikely for us to know the concrete types of
memory cells. Hence, such information cannot be used to
distinguish the two data structures. In fact, concrete type
information is not part of a pointer pattern. Their presence
is only for readability.
Consider the data structures in Figure 3(a) and Fig-
ure 3(b). Note all the data structures whose deﬁnitions are
not shown do not have pointer ﬁelds. IP P (A) is a sub-
pattern of IP P (X), B ⊲⊳ BB and C ⊲⊳ CC. But D is
not isomorphic to DD because of their different immediate
pointer patterns. According to Theorem 1, there must be a
unique signature for A. In this example, pointer pattern (2)
in Equation (8) is a unique signature. If we ﬁnd pointers
that have such structure in memory, they must indicate an
instance of A.
Theorem 1. Given a data structure T , if there does not
exist a data structure R such that
IP P (T ) is a sub-pattern of IP P (R), and
Finding the Minimal Signature. Even though we can de-
cide if a data structure T has a unique signature using The-
orem 1, there may be multiple pointer patterns of T that can
A
C
B
0
B
0
+4
E
+16
+24
G
H
+12
+18
D
B
A
0
C
+18
+12
D
I
+4
Figure 4.
If the offset of ﬁeld e1 (of type
struct G) in E is changed to 16, struct A
will have two possible signatures (detailed
data structure deﬁnitions in Figure 3)
distinguish T from other data structures. Ideally, we want
to ﬁnd the minimal pattern as it incurs the minimal parsing
overhead during brute force scanning. For example, if the
offset of ﬁeld e1 (of type struct G) in E is 16, struct
A will have two possible signatures as shown in Figure 4.
They correspond to the following pointer patterns:
0 · (0 · (16 · G · 8 · H) · 4 · B) · 12 · C · 6 · D
and
0 · B · 12 · C · 6 · (4 · I)
The ﬁrst one is generated by expanding B and then E, and
the second one is generated by expanding D. Either one can
serve as a unique signature of A.
In general, ﬁnding the minimal unique signature is a
combinatorial optimization problem: Given a data struc-
ture T , ﬁnd the minimal pointer pattern of T that cannot be
a sub-pattern of any other data structure R, that is, cannot
be generated by pointer expansions from a sub-pattern of
IP P (R). The complexity of a general solution is likely in
the NP category. In this paper, we propose an approximate
algorithm (Algorithm 1) that guarantees to ﬁnd a unique sig-
nature if one exists, though the generated signature may not
be the minimal one. It is a breadth-ﬁrst search algorithm
that performs expansions for all pointer symbols at the same
layer at one step until the pattern becomes unique.
The algorithm ﬁrst identiﬁes the set of data structures
that may have IP P (T ) as their sub-patterns (lines 3-5).
Such sub-patterns are stored in set distinct. Next, it per-
forms breadth-ﬁrst expansions on the pointer pattern of T ,
stored in s, and the patterns in distinct, until all patterns
can be distinguished. It is easy to infer that the algorithm
will eventually ﬁnd a unique pattern if one exists.
For the data structures in Figures 3(a) and 3(b), the pat-
tern generated for A by the algorithm is
0 · (0 · E · 4 · B) · 12 · C · 6 · (4 · I)
(9)
It is produced by expanding B and D in IP P (A).
Generating Multiple Signatures. In some use scenarios,
it is highly desirable to generate multiple signatures for
the same data structure. A common scenario is that some
Algorithm 1 An approximate algorithm for signature gen-
eration
Input: Data structure T and set K of all kernel data structures considered
Output: The pointer pattern that serves as the signature of T .
1: s= IP P (T )
2: let IP P (T ) be f1 · t1 · (f2 − f1) · t2 · ... · (fn − fn−1) · tn
3: for each sub-pattern p=g1 ·r1 ·(f2 −f1)·r2 ·(f3 −f2)·...·(fn −fn−1)·rn
in IP P (R) of each structure R ∈ (K − {T }) with f1 <= g1 do
p=expand(p)
if p is different from s disregarding type symbols then
distinct= distinct − p
end if
distinct=distinct ∪ {p}
s=expand(s)
for each p ∈ distinct do
4:
5: end for
6: while distinct 6= φ do
7:
8:
9:
10:
11:
12:
13:
end for
14: end while
15: return s
expand(s)
1: for each type symbol t ∈ s do
2:
3: end for
4: return s
s= replace t with “(IP P (t))”
pointer ﬁelds in a signature may not be dependable. For
example, certain kernel malware may corrupt the values of
some pointer ﬁelds and, as a result, the corresponding data
structure instance will not be recognized by a signature that
involves those pointers.
SigGraph mitigates such a problem by generating mul-
tiple unique signatures for the same data structure. In par-
ticular, if certain pointer ﬁelds in a data structure are poten-
tial targets of malicious manipulation, SigGraph will avoid
using such ﬁelds during signature generation in Algorithm
1. For example, if ﬁeld e1’s offset in struct E is 16 and
ﬁeld a3 (of type struct D) in struct A is not depend-
able, Algorithm 1 will adapt (not shown in the pseudo-code)
by pruning the sub-graph rooted at ﬁeld a3 in Figure 4(a).
5 Scanner Generation
Given a data structure signature (i.e., a pointer pattern),
SigGraph will automatically generate the corresponding
memory scanner, which will be shipped to users for brute
force kernel memory scanning. To automatically generate
scanners, we describe all signatures using a context-free
grammar (CFG). Then we leverage yacc to generate the
scanners. The CFG is described as follows.
Signature
P ointer
:= number · P ointer · Signature | ǫ
:= type | (Signature)
(10)
In the above grammar, number and type are terminals
that represent numbers and type symbols, respectively. A
Signature is a sequence of number · P ointer, in which
P ointer describes either the type or the Signature of the
data structure being pointed to.
It is easy to see that the
grammar describes all the pointer patterns in Section 4,
such as the signature of A generated by Algorithm 1 (Equa-
tion (9)).
Scanners can be generated based on the grammar rules.
Intuitively, when a number symbol is encountered, the ﬁeld
offset should be incremented by number. If a type is en-
countered, the scanner asserts that the corresponding mem-
ory contain a pointer.
If a ‘(’ symbol is encountered, a
pointer dereference is performed and the scanner starts to
parse the next-level memory region until the matching ‘)’
is encountered. A sample scanner generated for the sig-
nature in Equation (9) can be found in Figure 5. Func-
tion isInstanceOf A decides if a given address is an
instance of A; assertPointer asserts that the given ad-
dress must contain a pointer value, otherwise an exception
will be thrown and function isInstranceOf A will re-
turn 0. The yacc rules to generate scanners are elided for
brevity.
Considering Non-pointer Fields. So far, a scanner consid-
ers only the positive information from the signature, which
indicates the ﬁelds that are supposed to be pointers. But it
does not consider the implicit negative information, which
indicates the ﬁelds that are supposed to be non-pointers. In
many cases, such negative information is needed to con-
struct robust scanners.
For example, assume that a data structure T has a unique
signature 0 · A · 8 · B · 4 · C. If there is a pointer array
that stores a consecutive sequence of pointers, even though
T ’s signature is unique and has no structural conﬂict with
any other data structures, the scanner of T will mistakenly
identify part of the array as an instance of T .
To handle such cases, the scanner should also assert that
the non-pointer ﬁelds must not contain pointers. Hence the
scanner for T ’s signature becomes the following. Method
assertNonPointer asserts that the given address does
not contain a pointer. As such, the ﬁnal scanner code for
identify data structure T will be:
1 int isInstanceOf_T(void *x){
2
3
4
5
6
7
8
9
10 }
x=x+0;
assertPointer(*x);
x=x+4;
assertNonPointer(*x); // field of non-pointer
x=x+4;
assertPointer(*x);
x=x+4;
assertPointer(*x);
// field of type "C *"
// field of type "A *"
// field of type "B *"
6 Handling Practical Issues
We have so far assumed the ideal case for SigGraph.
However, when applied to large system software such as the
Linux kernel, SigGraph faces a number of practical chal-
lenges. In this section, we present our solutions to the fol-
lowing key problems.
1. Null pointers: It is possible that a pointer ﬁeld have a
null value, which cannot be distinguished from other
non-pointer ﬁelds, such as integer or ﬂoating point
ﬁelds with value 0. If 0 is considered a pointer value,
a memory region with all 0s would satisfy any imme-
diate pointer patterns, which is clearly undesirable.
2. Void pointers: Some of the pointer ﬁelds may have
a void* type and they will be resolved to different
types at runtime. Obviously, our signature generation
algorithm cannot handle such case.
3. User-level pointers:
It is also possible that a ker-
nel pointer point to the user space. For example, the
set child tid and clear child tid ﬁelds in
task struct, and the vdso ﬁeld in mm struct
all point to user space. The difﬁculty is that user space
pointers have a very dynamic value range due to the
larger user space, which makes it hard to distinguish
them from non-pointer ﬁelds.
for
For example,
4. Special pointers: A pointer ﬁeld may have non-
traditional pointer value.
the
widely used list head data structure, Linux kernel
uses LIST POISON1 with value 0x00100100 and
LIST POISON2 with value 0x00200200 as two
special pointers to verify that no one uses un-initialized
list entries. Another special value SPINLOCK MAGIC
(0xdead4ead) also widely exists in some pointer
ﬁelds such as in data structure radix tree.
5. Pointer-like values: Some of the non-pointer ﬁelds
may have values that resemble pointers. For example,
it is not an uncommon coding style to cast a pointer to
an integer ﬁeld and later cast it back to a pointer.
6. Undecided pointers: Union types allow multiple
ﬁelds with different types to share the same memory
location. This creates problems when pointer ﬁelds are
involved.
7. Rarely accessed data structures: Algorithm 1 in Sec-
tion 4 treats all data structures equally and tries to ﬁnd
unique signatures for all kernel data structures. How-
ever, some of the data structures are rarely used and
hence the conﬂicts caused by them may not be so im-
portant.
We ﬁnd that most of the problems above boil down to
the difﬁculty in deciding if a ﬁeld is pointer or non-pointer.
Interestingly, the following observation leads to a simple
solution: Pruning a few noisy pointer ﬁelds does not degen-
erate the uniqueness of the graph-based signatures. Even
though a signature after pruning may conﬂict with some
other data structure signatures, we can often perform a few
more reﬁnement steps to redeem the uniqueness. As such,
we devise a dynamic proﬁling phase to eliminate the unde-
pendable pointer/non-pointer ﬁelds.
Our proﬁler (Figure 2) relies on LiveDM [33], a dynamic
kernel memory mapping system, to keep track of dynamic
kernel data structures at runtime. Based on QEMU [3],
LiveDM tracks kernel memory allocation and dealloca-
tion events. More speciﬁcally, we focus on slab objects
by hooking the allocation and deallocation functions such
as kmem cache alloc and kmem cache free at the
1 int isInstanceOf_A(void *x){
2
3
4
5
6
7
8
9
10
y=*x;
y=y+0’
assertPointer(*y);
y=y+4;
assertPointer(*y);
x=x+0;
{
}
x=x+12;
assertPointer(*x);
x=x+6;
{
y=*x;
y=y+4;
assertPointer(*y);
}
return 1;
11
12
13
14
15
16
17
18
19 }
Figure 5. The generated scanner for struct A’s signature in Equation (9)
VMM level. The function arguments and return values are
retrieved to obtain memory ranges of these objects. Their
types are acquired by mapping allocation call sites to kernel
data types via static analysis. We then track the life time of
these objects and monitor their values.
We monitor the values of a kernel data structure’s ﬁelds
to collect the following information:
(1) How often a
pointer ﬁeld takes on a value different from a regular non-
null pointer value; (2) How often a non-pointer ﬁeld takes
on a non-null pointer-like value; (3) How often a pointer has
a value that points to the user space. In our experiments, we
proﬁle a number of kernel executions for long periods of
time (hours to tens of hours).
Based on the above proﬁles, we revise our signature gen-
eration algorithm with the following reﬁnements: (1) ex-
cluding all the data structures that have never been allo-
cated in our proﬁling runs so that structural conﬂicts caused
by these data structures can be ignored; (2) excluding all
the pointer ﬁelds that have the void* type or ﬁelds of
union types that involve pointers – in other words, these
ﬁelds are declared undependable (Section 4), which is done
by annotating them with a special symbol. Note that they
should not be considered as non-pointer ﬁelds either and
method assertNonPointer discussed in Section 5 will
not be applied to such ﬁelds; (3) excluding all the pointer
ﬁelds that have ever had a null value1 or a non-pointer
value during proﬁling; as well as all non-pointer ﬁelds
that ever have a pointer value during proﬁling. Neither
assertPointer nor assertNonPointer will be ap-
plied to these ﬁelds; (4) allowing pointers to have special
value such as 0x00100100 or 0x00200200.
We point out that dynamic proﬁling and signature reﬁne-
ment is performed only during the production of SigGraph-
based signatures/scanners. It is not performed by end-users,
who will simply run the scanners on memory images. We
do note that the SigGraph signatures/scanners are kernel-
speciﬁc, as different OS kernels may have different data
structure deﬁnitions and runtime access characteristics. In
fact, Section 8.2 shows that different versions of the same
OS kernel may have different signatures for the same data
structure.
1We note that such exclusion will not remove important pointer ﬁelds in
critical kernel data structures such as lists and trees, where non-zero magic
values are used to indicate list/tree termination or initialization.
7 Evaluation
We have implemented a prototype of SigGraph in C and
Python. More speciﬁcally, we instrument gcc-4.2.4 to
traverse ASTs and collect kernel data structure deﬁnitions.
Our scanner generator is lex/yacc based, and the generated
scanners are in C. The entire implementation has around
10K lines of C code and 6K lines of Python code.
7.1 Signature Uniqueness
We ﬁrst test if unique signatures exist for kernel data
structures. We test 5 popular Linux distributions (from Fe-
dora Core 5 and 6; and Ubuntu 7.04, 8.04 and 9.10), with
the corresponding kernel version shown in the ﬁrst column
of Table 1. We compile these kernels using our instru-
mented gcc. Observe that there are quite a large number
of data structures in different kernels, ranged from 8850 to
26799. Overall, we ﬁnd nearly 40% of the data structures
have pointer ﬁelds, and nearly 88% (shown in the 5th col-
umn) of the data structures with pointer ﬁelds have unique
signatures. Because of graph isomorphism, there are data
structures that do not have any unique signature, and the
percentage for these data structures is around 12%. For the
average steps (S) performed in pointer pattern expansion to
generate the unique signatures, the numbers are shown in
the 6th column. Note that these are all static numbers be-
fore the dynamic reﬁnement.
From the 7th to the 20th column in Table 1, we show the
number of unique signatures of various depths, obtained by
taking various number of expansion steps along the points-
to relations. For example, kernel 2.6.15-1 has 1355 data
structures that have unique one-level signatures and 823
data structures that have unique two-level signatures.
7.2 Signature Effectiveness
To test the effectiveness of SigGraph, we take Linux ker-
nel 2.6.18-1 as a working system, and show how the gen-
erated signatures can detect data structure instances. We
choose 23 widely used kernel data structures shown in the
2nd column of Table 2. We choose these data structures
because: (1) They are the most commonly examined data
structures in existing literature [28, 11, 22, 37, 34, 38, 35, 9];
(2) They are important data structures that can represent
Kernel
version
2.6.15-1
2.6.18-1