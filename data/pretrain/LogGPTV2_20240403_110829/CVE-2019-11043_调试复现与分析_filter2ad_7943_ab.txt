    char* fcgi_putenv(fcgi_request *req, char* var, int var_len, char* val)
    {
        if (!req) return NULL;
        if (val == NULL) {
            fcgi_hash_del(&req->env, FCGI_HASH_FUNC(var, var_len), var, var_len);
            return NULL;
        } else {
            return fcgi_hash_set(&req->env, FCGI_HASH_FUNC(var, var_len), var, var_len, val, (unsigned int)strlen(val));  //buckets->data + h->buckets->idx;
        h->buckets->idx++;
        p->next = h->hash_table[idx];
        h->hash_table[idx] = p;
        p->list_next = h->list;
        h->list = p;
        p->hash_value = hash_value;
        p->var_len = var_len;
        p->var = fcgi_hash_strndup(h, var, var_len);    //val_len = val_len;
        p->val = fcgi_hash_strndup(h, val, val_len);    //val;
    }
    static inline char* fcgi_hash_strndup(fcgi_hash *h, char *str, unsigned int str_len)
    {
    ......
        ret = h->data->pos;        //data->pos += str_len + 1;
        return ret;
    }
所以需要将一字节写0的应用到能够修改`fcgi_data_seg`的低位，达到向`fcgi_hash_buckets`写环境变量的进一步操作。
还需要注意的是，后面PHP-FPM在取环境变量的值时，会对`fcgi_hash_buckets`中键值对做哈希值的校验，也就是说如果只是向`fcgi_hash_buckets`写了PHP的环境变量，如果验证过不了还是无效的。
对键的哈希操作如下所示：
    #define FCGI_HASH_FUNC(var, var_len) 
        (UNEXPECTED(var_len '",
        "extension=$_GET[a]",
        "auto_prepend_file=l"
    ]
## 三、总结
主要流程：%0a使得正则获得PATH_INFO为空——》path_info下溢，可控地址一字节写0——》构造写入PHP环境变量——》RCE
1、其中请求query中的大量字符串`Q`是为了让PATH_INFO刚好在fcgi_data_seg的数据段开头；
2、HTTP头中的大量`+`是为了制造偏移，使得后面环境变量写入刚好覆盖HTTP_EBUT；
3、HTTP头中的Ebut是为了`PHP_VALUE`和`HTTP_EBUT`哈希计算一致使得覆盖后能成功被应用。
**对于不同的服务器环境，需要的`Q`和`+`填充不一样，需要爆破尝试**
学习过程中刚好也用Python实现了下此CVE的EXP，可以判断目标服务器work进程数量进行全进程污染：
## 四、引用