title:Cubismo: decloaking server-side malware via cubist program analysis
author:Abbas Naderi-Afooshteh and
Yonghwi Kwon and
Anh Nguyen-Tuong and
Mandana Bagheri-Marzijarani and
Jack W. Davidson
Cubismo: Decloaking Server-side Malware via Cubist Program
Analysis
Abbas Naderi-Afooshteh, Yonghwi Kwon, Anh Nguyen-Tuong, Mandana Bagheri-Marzijarani, and
ABSTRACT
Jack W. Davidson
Department of Computer Science, University of Virginia
{abiusx,yongkwon,nguyen,mb3wz,jwd}@virginia.edu
1 INTRODUCTION
Malware written in dynamic languages such as PHP routinely
employ anti-analysis techniques such as obfuscation schemes and
evasive tricks to avoid detection. On top of that, attackers use
automated malware creation tools to create numerous variants
with little to no manual effort.
This paper presents a system called Cubismo to solve this press-
ing problem. It processes potentially malicious files and decloaks
their obfuscations, exposing the hidden malicious code into multiple
files. The resulting files can be scanned by existing malware detec-
tion tools, leading to a much higher chance of detection. Cubismo
achieves improved detection by exploring all executable statements
of a suspect program counterfactually to see through complicated
polymorphism, metamorphism and, obfuscation techniques and
expose any malware.
Our evaluation on a real-world data set collected from a commer-
cial web hosting company shows that Cubismo is highly effective
in dissecting sophisticated metamorphic malware with multiple
layers of obfuscation. In particular, it enables VirusTotal to detect
53 out of 56 zero-day malware samples in the wild, which were
previously undetectable.
CCS CONCEPTS
• Security and privacy → Malware and its mitigation; Web
application security; Systems security.
KEYWORDS
PHP, Security, Malware, Obfuscation, Evasion, Counterfactual
Execution
ACM Reference Format:
Abbas Naderi-Afooshteh, Yonghwi Kwon, Anh Nguyen-Tuong, Mandana
Bagheri-Marzijarani, and Jack W. Davidson. 2019. Cubismo: Decloaking
Server-side Malware via Cubist Program Analysis. In 2019 Annual Computer
Security Applications Conference (ACSAC ’19),December 9–13, 2019, San Juan,
PR, USA. ACM, New York, NY, USA, 14 pages. https://doi.org/10.1145/
3359789.3359821
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
ACSAC ’19, December 9–13, 2019, San Juan, PR, USA
© 2019 Association for Computing Machinery.
ACM ISBN 978-1-4503-7628-0/19/12...$15.00
https://doi.org/10.1145/3359789.3359821
Web-based malware, particularly server-side malware, is one
of the most prevalent security threats nowadays. Numerous re-
ports describe the prevalence of server-side malware. Sucuri, a firm
specializing in managed security and system protection, analyzed
34,371 infected websites and reported that 71% of those contained
PHP-based, hidden backdoors [52]. Incapsula discovered that out
of 500 infected websites detected on their network, the majority
of them contained PHP malware [27]. Verizon’s 2017 Data Breach
reported that a sizable number of web server compromises are a
means to an end, allowing attackers to set up for other targets [26].
This prevalence is in part because server-side malware is typ-
ically equipped with advanced anti-analysis and anti-debugging
techniques such as obfuscation and metamorphism. These tech-
niques are implemented using dynamic language features such as
dynamic code generation (e.g., eval), creating several challenging
analysis problems [25, 31].
Detecting server-side malware is a hard problem. While there are
a handful of malware detection tools, most of them are signature-
based tools that are ineffective in detecting polymorphic and meta-
morphic malware. Specifically, the signatures are extracted from
known malware samples and the given target malware by aggregat-
ing particular patterns (e.g., byte patterns) and keywords found in
the samples. The detectors then compare the signatures to identify
malware.
To avoid detection, server-side malware uses various obfuscation
techniques, such as polymorphism and dynamic code generation,
to produce malware that has a different signature from the origi-
nal code. Moreover, attackers leverage various tools that generate
malware variants with little to no effort, also making the signature-
based approaches less effective [40, 49, 55].
From our experience in analyzing various real-world malware
samples, we have observed that many malware are equipped with
multiple obfuscation layers (e.g., constructing calls to eval() dy-
namically) and various evasive techniques (e.g., requiring a particu-
lar input to trigger the malware). Obfuscation techniques enable
malware to thwart analysis and detection by static analysis tools,
while evasive techniques hide malicious behaviors behind compli-
cated logic to prevent dynamic analysis.
Moreover, we have observed that many malware samples found
in the wild turn out to be variants of the same family, but with dif-
ferent obfuscation techniques applied. Interestingly, while existing
malware detectors are not able to detect the obfuscated malware
variants, they do recognize deobfuscated malware samples, indicat-
ing that obfuscation techniques are effective at thwarting detection
tools in practice.
ACSAC ’19, December 9–13, 2019, San Juan, PR, USA
A. Naderi et al.
As a result, we hypothesize that revealing malicious code hidden
behind anti-analysis techniques such as obfuscation and metamor-
phism is a key challenge in detection of server-side web malware.
Unfortunately, dynamic analysis or static analysis alone is not able
to handle this challenge. Specifically, dynamic analysis techniques
can handle obfuscations but not evasive techniques. On the other
hand, while static analysis can handle evasive tricks, it has difficulty
handling obfuscation.
We propose a fully automated system, Cubismo, that more effec-
tively uncloaks sophisticated server-side malware by neutralizing
anti-analysis tricks such as obfuscation and metamorphism. Specif-
ically, we aim to resolve parts of malware that hinder analysis and
detection. In particular, we identify blocks of code that are hiding
their original intention (i.e., via obfuscation). We then resolve (i.e.,
counter) evasion tricks to expose hidden malicious logic (e.g., often
by executing the code). The exposed malicious code is then used to
create new malware files by replacing the decoding and dynamic
execution sequence with the deobfuscated code.
Given a program, Cubismo1 analyzes the program to break it
into small pieces, reveals the real intentions of these pieces, then
reassembles the revealed intentions into the original program. The
reassembled program essentially depicts the target program from
multiple perspectives to present diverse aspects of the target. We
call this analysis Cubist Program Analysis as inspired by cubist art
which aims to present a subject from a multitude of viewpoints to
show the piece in a greater context.
Our extensive evaluation results show that Cubismo is highly
effective in revealing malicious code hidden behind sophisticated
obfuscation and evasive techniques, boosting the effectiveness of ex-
isting malware detectors to find 53 new zero-day malware samples.
The major contributions of this research are as follows:
• A fully automated method for decloaking obfuscated code
and exposing evasive malicious behavior, called Cubist Pro-
gram Analysis (CPA).
• Development of a prototype system called Cubismo that
employs CPA and can be integrated into existing malware
detectors, resulting in more accurate malware detection.
• An evaluation of Cubismo using a large corpus of real-world
website deployments that shows Cubismo is effective in
enabling VirusTotal to detect 53 out of 56 zero-day malware
samples found in the dataset, with no false positives.
2 BACKGROUND
In this section, we provide background information on server-
side malware and state-of-the-art malware detection tools, and we
explain the challenges in detecting server-side malware.
2.1 Server-side Malware
Server-side malware aims to infect a server system (e.g., a web
server). PHP malware is the most prevalent form of malware that tar-
gets web servers [26]. A distinctive characteristic of PHP malware
is that it requires intervention, either via a victim user browsing the
infected website to trigger execution or via an attacker manually
1Cubismo is a Spanish word for cubism. This paper is inspired by cubist art which
analyzes multiple aspects of an object, breaks them down, and reassembles them for
presentation.
triggering the malware. PHP malware often checks a handful of con-
ditions (e.g., checking a particular input is provided by an attacker)
to decide whether to expose malicious behavior/logic. Moreover,
PHP malware actively leverages PHP’s dynamic language features
(e.g., eval()) to make analysis difficult. From our study of real-
world malware (§6), we find that the majority of existing malware
detectors is unable to detect obfuscated malware, even if its original
malware itself is already known to be malicious.
2.2 Challenges
In this section, we enumerate three major challenges in detecting
web server-side malware. These challenges motivate Cubismo’s
design.
Challenge 1: Multiple Layers of Obfuscation and Dynamic
Constructs. PHP malware heavily leverages obfuscation techniques,
often using multiple layers of obfuscations to thwart static analy-
sis’s ability to recognize malicious code. As a result, many malware
detectors decide to simply flag obfuscated files as malware. How-
ever, this strategy suffers from false positives as there are benign
applications that use obfuscation techniques to protect intellectual
property (e.g., source code or key algorithms) [29, 62].
PHP also supports various dynamic constructs that can cre-
ate and modify program code introspectively (e.g., Reflection,
eval() or include()). These dynamic constructs are commonly
used in malware to implement obfuscation techniques. Moreover,
PHP also provides methods to alter the current running program
code, such as modifying and removing methods at runtime. This
self-modification allows malware to delete or alter the critical code
under analysis. Furthermore, PHP allows indirect and dynamic call-
ing of functions (or methods) via a string variable that holds their
name. Such features make it further challenging to statically reason
about the code.
In short, static analysis based techniques are ineffective in an-
alyzing malicious code hidden behind obfuscation. Note that 2
and 6 in Fig. 1-(a) are obfuscated. Static analysis techniques fail
to see malicious code through the obfuscated blocks (depicted as
✕ marks) in Fig. 1-(b).
To solve this problem, dynamic analysis based approaches are
proposed. These approaches execute programs and observe their
behavior to determine whether a target program is malicious. How-
ever, they are commonly thwarted by evasive logic in malware
(details in challenge 2 below).
Challenge 2: Evasive Logic in Malware. Malware (including
non-PHP malware) commonly leverages evasive techniques to hide
malicious behaviors. Specifically, they often check host environ-
ment variables and client versions to identify which vulnerability
they want to exploit [54]. In Fig. 1-(a), there are two obfuscated
basic blocks ( 2 and 6 ) and to exercise both of them within an
execution, the execution should satisfy the condition x = 1 ( 1 )
and y != 1 ( 4 ). In addition, note that the obfuscated block 2 ( 6 )
is dependent on the obfuscated block 1 ( 2 ), meaning that without
a proper execution of the block 1, the block 2 would not execute as
intended. While resolving the satisfying condition is trivial in this
example, conditions can be arbitrarily complex in practice, making
analysis challenging. As a result, simple dynamic analysis is often
unable to completely expose hidden malicious code. Fig. 1-(c) and
Cubismo: Decloaking Server-side Malware via Cubist Program Analysis
ACSAC ’19, December 9–13, 2019, San Juan, PR, USA
Figure 1: Limitations of Static and Dynamic Analysis
based techniques syntactically analyze malicious programs without
running malware. Dynamic analysis based techniques run malware
and monitor malicious behaviors exhibited at runtime.
Obfuscation
Evasive Techs Auto. Tools
△
Signature-based
⃝
Static Analysis
Dynamic Analysis
✕
* ✕: Ineffective, △: Partially effective, ⃝: Effective.
✕
✕
△
✕
△
⃝
Table 1: Effectiveness of Malware Detection Techniques.
As shown in Table 1, signature-based techniques are not effective
in handling obfuscation and dynamic constructs (Challenge 1) as
well as malware variant generation tools (Challenge 3) because even
a small change in malware variants may change its signature. Static
analysis based techniques are effective in handling evasive tech-
niques (Challenge 2) (e.g., complex predicates that mask malicious
behaviors at runtime) while they have difficulty handling sophis-
ticated obfuscations and identifying generated malware variants
(Challenge 1 and 3). Dynamic analysis based techniques are effec-
tive in handling malware variant generation tools and obfuscation
(Challenge 1 and 3) while they are often ineffective in analyzing
evasive logic (Challenge 2).
3 SCOPE OF WORK
Cubismo is a system that reveals malicious code in malware
and presents them as multiple files which can then be fed into
existing malware detectors or analysis tools. It is important to
mention that Cubismo itself is not a malware detection technique
and it does not decide whether a given program is malware or not.
Given an unknown malware, even after Cubismo reveals all the
malicious behaviors, it is possible that all existing malware detection
techniques are not able to detect the malware. In such case, it does
not mean Cubismo is ineffective. It rather suggests that the existing
detectors are unable to identify the given malware, indicating that it
might be a completely new malware sample (i.e., zero-day malware).
Given a target program, Cubismo may generate multiple deob-
fuscated files if the target contains multiple layers of obfuscation
or multiple instances of dynamic code generations (e.g., eval()).
To confidently decide whether the given program is malicious or
not, malware detectors need to scan all of the generated files. Hence,
it often requires more time to scan all the files. Note that the goal
of this paper is to create a practical automated system that exposes
malicious code of malware for existing malware detector tools, not
optimizing the detection pipeline. However, it should be obvious
that one could prioritize and parallelize the scanning process to
optimize performance.
4 OVERVIEW
Fig. 2 shows a typical workflow of Cubismo. Given an input PHP
file, Cubismo exposes hidden program code blocks and merges each
discovered hidden code block into the original input program to
create a new output file. Note that it is important to merge deobfus-
cated code back to the original program because deobfuscated code
alone may not form a complete malware. Given N revealed code
blocks, Cubismo generates N output files. The output files are then
(d) illustrate that dynamic analysis techniques can only see the pro-
gram from a specific execution path, missing potentially malicious
code.
Moreover, executing code blocks does not always lead to suc-
cessful analysis. For example, in Fig. 1, block 6 ’s execution is
dependent upon code executed in block 2 , meaning that if block
2 is emitted from a dynamic execution, block 6 will not expose
any malicious behavior (denoted with the yellow exclamation).
Challenge 3: Automated Tools for Malware Creators. Another
challenge in detecting web server malware is that there are many
automated tools used by attackers to create and obfuscate mal-
ware [40, 55]. In practice, attackers can easily generate a number of
malware variants automatically with diverse obfuscations within
the origin malware itself. Detectors often rely on known signatures
of malware and heuristics that detect keywords and patterns of
malicious code which can be easily changed by applying a simple
obfuscation. As even a very small change (e.g., changing a vari-
able/function name) in malware results in a different signature,
such detectors have fundamental difficulty in catching up with the
growing number of new malware variants. Note that our evaluation
results also echo the prevalence of such malware variants. Specif-
ically, we find many malware variants in the wild, are generated
from a few original malware samples (§ 6.4).
Summary. Table 1 summarizes the effectiveness of different anal-
ysis techniques in handling the three challenges. We group exist-
ing malware detection techniques into three categories: signature-
based, static analysis based, and dynamic analysis based. Signature-
based techniques represent tools that utilize signatures (e.g., key-
words and patterns in malware) to detect malware. Static analysis
if	(	x	==	1	)Obfuscated	1Benign	1if	(	y	==	1	)Obfuscated	2Benign	2…(a)	Control	Flow	Graph(c)	Dynamic	Analysis	(x,	y	=	1)if	(	x	==	1	)Debfuscated1if	(	y	==	1	)Benign	2…if	(	x	==	1	)Benign	1if	(	y	==	1	)Deobfuscated2…(d)	Dynamic	Analysis	(x,	y	=	0)(b)	Static	Analysis132456if	(	x	==	1	)Obfuscated	1Benign	1if	(	y	==	1	)Obfuscated	2Benign	2…Depend-encyUnresolved	variablesACSAC ’19, December 9–13, 2019, San Juan, PR, USA
A. Naderi et al.
fed into an existing malware detector such as VirusTotal [1]. If any
of them are flagged as malware, the input file is likely malware.
Figure 2: Workflow of Cubismo
5 DESIGN
Fig. 3 shows the architecture of Cubismo. It consists of three
phases: normalization (§ 5.1), counterfactual execution (§ 5.2), and
code generator (§ 5.3).
Phase 1: Normalization. Cubismo statically parses the given in-
put file to obtain an Abstract Syntax Tree (AST) of the input pro-
gram. The AST is then normalized (e.g., pruning deprecated func-
tionality, removing syntactically invalid statements). This normal-
ized AST is then used in subsequent analyses instead of the original
file, and is the output of this phase.
Phase 2: Counterfactual execution. Cubismo dynamically ex-
ecutes the input program under a controlled environment (i.e., a
sandbox) to reveal malicious code. To enhance the code coverage
that is a fundamental limitation of dynamic analysis, Cubismo lever-
ages a dynamic analysis technique called counterfactual execution
that drives executions into all observable control paths regardless
of the predicate conditions (i.e., without solving the predicate con-
ditions) to discover hidden malicious code and obtain decloaked
ASTs.
Phase 3: Code generator. Cubismo creates multiple output pro-
gram files from decloaked ASTs. The output files can then be fed
into existing malware detection (or analysis) tools.
5.1 Normalization
Cubismo first parses an input program and obtains Abstract
Syntax Tree (AST) of the program. During this process, certain parts
of the code that do not affect the semantics such as deprecated code,
syntactically invalid statements, extra whitespaces, and comments
are pruned out.
Cubismo creates a one-to-one mapping between AST and code
(which is useful when decloaking parts of the code) so that de-
cloaked code can be properly merged back to the original AST to
create multiple decloaked ASTs.
Fig. 4 shows an example of the normalization process. Given a
difficult-to-read original program (Fig. 4-(a)), Cubismo parses it into
an AST which is then used to create a normalized program (Fig. 4-
(b)). Note that each statement is now on a separate line and some of
PHP specific tags such as the closing tag (“?>”) are removed, as they
do not change the semantics of the original program in modern
PHP syntax.
Based on our evaluations, we noticed that the normalization
process in itself sometimes enhances detection results of existing
detectors. Enhanced detect can occur because some malware de-
tectors use subsequences of malware source code as a signature
and some malware variants intentionally insert unnecessary code
snippets (e.g., adding comments and closing tags) to break these
signatures.
Malicious code is typically ill-formatted. More often than not,
malicious code is injected in the middle of a benign file by the
attackers, in a single line of code that constitutes several statements,
using old PHP features to ensure portability. Moreover, maliciously
crafted statements may break specific PHP parsers while they can be
properly executed. For example, Fig. 5-(a) is a PHP program that
contains namespaces. Note that it contains a line of comment outside
of the namespaces (Line 13). The program runs correctly without
any errors. However, PHP-Parser [44], a widely used parser for PHP
programs, fails to parse the program, resulting in an error [16]. The
normalization process removes the comment as shown in Fig. 5-(b),
allowing the parser to parse the program without errors.
5.2 Counterfactual Execution
To expose hidden malicious code effectively, Cubismo system-
atically explores multiple execution paths of the target program
to handle evasive techniques and obfuscation. Traditionally, ex-
ploring various execution paths requires either knowing various
inputs to drive the execution paths or applying symbolic execution
to resolve the predicate conditions [15]. However, due to, in part,
the dynamic nature of PHP language and the sheer complexity of
modern PHP programs including malware (e.g., reliance on sev-
eral external applications and services in control-flow decisions),
it is challenging to identify sufficient inputs or resolve predicate