29(2):198–208, 1983.
[32] P. Fiter˘au-Bro¸stean, R. Janssen, and F. Vaandrager. Com-
bining model learning and model checking to analyze
tcp implementations. In CAV, pages 454–471. Springer,
2016.
[33] P. Fiter˘au-Bro¸stean, T. Lenaerts, E. Poll, J. de Ruiter,
F. Vaandrager, and P. Verleg. Model learning and model
checking of SSH implementations. In SPIN, pages 142–
151, 2017.
[34] S. Hussain, O. Chowdhury, S. Mehnaz, and E. Bertino.
LTEInspector: A systematic approach for adversarial
testing of 4G LTE. In NDSS, 2018.
[35] B. Janes, H. Crawford, and T. Oconnor. Never ending
story: Authentication and access control design ﬂaws in
shared iot devices. In IEEE Workshop on the Internet of
Safe Things, 2020.
[36] Y. Jia, L. Xing, Y. Mao, D. Zhao, X. Wang, S. Zhao, and
Y. Zhang. Burglars’ iot paradise: Understanding and
mitigating security risks of general messaging protocols
In IEEE S&P, pages 465–481. IEEE,
on iot clouds.
2020.
[39] Y. Li, S. Ji, C. Lyu, Y. Chen, J. Chen, Q. Gu, C. Wu,
and R. Beyah. V-fuzz: Vulnerability prediction-assisted
evolutionary fuzzing for binary programs. IEEE Trans-
actions on Cybernetics, 2020.
[40] D. Lie, A. Chou, D. Engler, and D. L. Dill. A simple
method for extracting models from protocol code. In
ISCA, pages 192–203. IEEE, 2001.
[41] Q. liu, S. Ji, C. Liu, and C. Wu. A practical black-box at-
tack on source code authorship identiﬁcation classiﬁers.
TIFS, 2021.
[42] G. Lowe. A hierarchy of authentication speciﬁcations.
In CSFW, pages 31–43. IEEE, 1997.
[43] C. Lyu, S. Ji, C. Zhang, Y. Li, W.-H. Lee, Y. Song, and
R. Beyah. MOPT: Optimized mutation scheduling for
fuzzers. In USENIX Security, pages 1949–1966, Santa
Clara, CA, 2019.
[44] C. D. Manning, M. Surdeanu, J. Bauer, J. R. Finkel,
S. Bethard, and D. McClosky. The stanford corenlp
natural language processing toolkit. In ACL, pages 55–
60, 2014.
[45] I. N. McAteer, M. I. Malik, Z. Baig, and P. Hannay.
Security vulnerabilities and cyber threat analysis of the
AMQP protocol for the internet of things. 2017.
[46] OASIS.
MQTT Version 3.1.1.
http:
//docsss.oasis-open.org/mqtt/mqtt/v3.1.
1/os/mqtt-v3.1.1-os.html.
[47] T. OConnor, W. Enck, and B. Reaves. Blinded and
confused: uncovering systemic ﬂaws in device telemetry
for smart-home internet of things. In WiSec, pages 140–
150, 2019.
[48] T. OConnor, R. Mohamed, M. Miettinen, W. Enck,
B. Reaves, and A.-R. Sadeghi. Homesnitch: behavior
transparency and control for smart home iot devices. In
WiSec, pages 128–138, 2019.
[49] A. Palmieri, P. Prem, S. Ranise, U. Morelli, and T. Ah-
mad. MQTTSA: a tool for automatically assisting the
secure deployments of MQTT brokers. In SERVICES,
volume 2642, pages 47–53. IEEE, 2019.
[37] J. Y. less, R. Holz, W. Hu, and S. Jha. Automated anal-
ysis of secure internet of things protocols. In ACSAC,
pages 238–249, 2017.
[50] E. Ronen, A. Shamir, A.-O. Weingarten, and C. O’Flynn.
Iot goes nuclear: Creating a zigbee chain reaction. In
IEEE S&P, pages 195–212. IEEE, 2017.
[38] Y. Li, S. Ji, Y. Chen, S. Liang, W.-H. Lee, Y. Chen,
C. Lyu, C. Wu, R. Beyah, P. Cheng, et al. Unifuzz:
A holistic and pragmatic metrics-driven platform for
evaluating fuzzers. In USENIX Security, 2021.
[51] S. Sivakorn, G. Argyros, K. Pei, A. D. Keromytis, and
S. Jana. HVLearn: Automated black-box analysis of
hostname veriﬁcation in SSL/TLS implementations. In
IEEE S&P, pages 521–538. IEEE, 2017.
4220    30th USENIX Security Symposium
USENIX Association
[52] Q. Wang, S. Ji, Y. Tian, X. Zhang, B. Zhao, Y. Kan,
Z. Lin, C. Lin, S. Deng, A. X. Liu, and R. Beyah.
MPInspector: a systematic and automatic approach for
evaluating the security of IoT messaging protocols.
https://github.com/wqqqy/MPInspector.
[53] B. Zhao, S. Ji, W.-H. Lee, C. Lin, H. Weng, J. Wu,
P. Zhou, L. Fang, and R. Beyah. A large-scale empir-
ical study on the vulnerability of deployed iot devices.
TDSC, 2020.
[54] W. Zhou, Y. Jia, Y. Yao, L. Zhu, L. Guan, Y. Mao, P. Liu,
and Y. Zhang. Discovering and understanding the se-
curity hazards in the interactions between IoT devices,
mobile apps, and clouds on smart home platforms. In
USENIX Security, pages 1133–1150, 2019.
Appendix
A Security properties.
We present the main evaluated secrecy and authentication
properties (both meta and extended properties) in Table 6 and
Table 7, respectively.
Table 6: Secrecy properties.
Secrecy Property Description
Secrecy on MQTT ClientID
Secrecy on MQTT Secret Key
Secrecy on MQTT Username
Secrecy on MQTT Password
Secrecy on MQTT Topic
Secrecy on MQTT Publish Payload
Secrecy on MQTT User Properties (MQTT V5.0)
Secrecy on MQTT Publish Response Topic (MQTT V5.0)
Secrecy on MQTT Publish CorelationData (MQTT V5.0)
Secrecy on AMQP ContainerId
Secrecy on AMQP Host Name
Secrecy on AMQP Transfer Payload
Secrecy on AMQP Target Node
Secrecy on AMQP Source Node
Secrecy on CoAP Uri
Secrecy on CoAP Token
Secrecy on CoAP MessageId
Secrecy on CoAP ACK payload
Secrecy on CoAP CON_GET Payload (EMQ X)
Secrecy on CoAP CON_PUT Payload (EMQ X)
Secrecy on CoAP Random (Aliyun Cloud)
Secrecy on CoAP Secret Key (Aliyun Cloud)
Secrecy on CoAP AuthToken (Aliyun Cloud)
Secrecy on CoAP CON_POSTAUTH payload (Aliyun Cloud)
Secrecy on CoAP CON_POSTPUBLISH payload (Aliyun Cloud)
ID
MS1
(cid:63) MS2
MS3
MS4
MS5
MS6
MS7
MS8
MS9
AS1
AS2
AS3
AS4
AS5
CS1
CS2
CS3
CS4
(cid:63) CS5
(cid:63) CS6
(cid:63) CS7
(cid:63) CS8
(cid:63) CS9
(cid:63) CS10
(cid:63) CS11
1 The property with (cid:63) is extended property.
2 MS7-MS9 are only supported in MQTTv5.0, CS5-CS6 are only sup-
ported in EMQ X and CS7-CS11 are only supported in Aliyun Cloud
in CoAP protocol.
B A Running Example
We take the MQTT implementation on Bosch IoT platform
as a running example to clarify how the state machine is
generated and how the formal code is translated.
ID
MA1
MA2
MA3
MA4
MA5
MA6
MA7
MA8
MA9
MA10
MA11
AA1
AA2
AA3
AA4
AA5
AA6
AA7
AA8
AA9
AA10
AA11
AA12
AA13
(cid:63) CA1
(cid:63) CA2
(cid:63)CA3
(cid:63) CA4
(cid:63) CA5
(cid:63) CA6
(cid:63) CA7
(cid:63) CA8
Table 7: Authentication properties.
Property Description
Authentication on MQTT CONNECT message (server->client)
Authentication on MQTT CONNACK message (client->server)
Authentication on MQTT SUBSCRIBE message (server->client)
Authentication on MQTT SUBACK message (client->server)
Authentication on MQTT UNSUBSCRIBE message (server->client)
Authentication on MQTT UNSUBACK message (client->server)
Authentication on MQTT PUBLISH message (server->client)
Authentication on MQTT PUBACK message (client->server)
Authentication on MQTT DISCONNECT message (server->client)
Authentication on MQTT Will message PUBLISH message
Authentication on MQTT Retained message PUBLISH message
Authentication on AMQP SASL message (server->client)
Authentication on AMQP SASL message (client->server)
Authentication on AMQP OPEN message (server->client)
Authentication on AMQP OPEN message (client->server)
Authentication on AMQP ATTACH message (server->client)
Authentication on AMQP ATTACH message (client->server)
Authentication on AMQP FLOW message (server->client)
Authentication on AMQP FLOW message (client->server)
Authentication on AMQP TRANSFER message (server->client)
Authentication on AMQP DISPOSITION message (client->server)
Authentication on AMQP DETACH message (server->client)
Authentication on AMQP DETACH message (client->server)
Authentication on AMQP CLOSE message (server->client)
Authentication on CoAP CON_GET message (EMQ X) (server->client)
Authentication on CoAP CON_GET message (EMQ X) (client->server)
Authentication on CoAP CON_PUT message (EMQ X) (server->client)
Authentication on CoAP CON_PUT message (EMQ X) (client->server)
Authentication on CoAP CON_POSTAUTH message (Aliyun Cloud)
(server->client)
Authentication on CoAP CON_POSTAUTH message (Aliyun Cloud))
(client->server)
Authentication on CoAP CON_POSTPUBLISH message (Aliyun Cloud)
(server->client)
Authentication on CoAP CON_POSTPUBLISH message (Aliyun Cloud)
(client->server)
1 The property with (cid:63) is extended property.
2 Authentication properties on both client side and server sides are considered.
CA1-CA4 are only supported in EMQ X and CA6-CA7 are only supported
by Aliyun Cloud in CoAP protocols.
3 A->B means that A authenticates the message from B.
and
property
semantics
generation.
State machine
First,
MPInspector applies message
extraction
from Section 4.3 to identify the parameter semantics for the
key messages speciﬁed in the MQTT standard. In particular,
MPInspector outputs the semantics of nine key MQTT
messages using the JSON encoding, e.g., {"CONNECT":{
"ClientID":"","username":{"composition":["aut
hid","tenantid"]},"password":""}} (an expression
"parameter":"" means that parameter does not have extra
semantics and is consistent with the standard MP).
Second, MPInspector applies interaction logic extrac-
tion from Section 4.3 to the MQTT implementation on the
Bosch IoT platform. It outputs a raw state machine whose
transition messages only contains the message names, e.g.,
CONNECT/CONNACK. Then, it adds the semantics extracted
from Section 4.3 to each transition message. After that, we
have the inferred state machine as shown in Figure 9. Ac-
cording to the property generation method in Section 4.5,
MPInspector outputs the secrecy and authentication proper-
ties as shown in Appendix A.
State machine translation. First, MPInspector generates
USENIX Association
30th USENIX Security Symposium    4221
right part indicates the state that the server sends out the
CONNACK message. The action facts in the rule’s middle
part indicate the behaviors in the transition, which will be
used in the property lemmas for reasoning. For example,
Secret() means that
the password is supposed to be secret on the server side.
r u l e
s e r v _ r e c v _ c o n n e c t _ s n d _ c o n n c a k :
l e t username = 
uername =
connack = s e n c ( ’ 0 ’ , s e s s i o n _ k e y )
c o n n e c t = s e n c { C l i e n t I D , username , password }
s e s s i o n _ k e y
i n [
I n ( c o n n e c t ) , Serv_Tls_Sym ($SERVER ,
t e n a n t i d , password ,
] −−[ C r e a t e ( ’ c o n n e c t ’ , ’ s e r v e r
C l i e n t I D , a u t h i d ,
s e s s i o n _ k e y )
’ , $SERVER) , Commit ($SERVER , username , ) , Commit ($SERVER
, username , ) ,
Commit ($SERVER , username , ) , Running ($SERVER , username ,  >) ,
Honest ( ) , Honest ( ) , S e c r e t ( ) , S e c r e t ( ) , S e c r e t ( ) ] −>[ Out ( connack ) , S t a t e _ 1 _ S e r v (
$SERVER , C l i e n t I D , a u t h i d , t e n a n t i d , password ,
s e s s i o n _ k e y ]
Listing 4: An example of a transition rule in Tamarin code.
Property translation. Finally, the formal code translation
module automatically translates the secrecy properties on
password to Tamarin code using the formula shown in List-
ing 5. MPInspector automatically generates four types of
authentication lemmas for each authentication property based
on the state machine. Taking the injective agreement as an
example, MPInspector generates the formalization of the in-
jective agreement property on a CONNECT message, as shown
in Listing 6. Listing 5 and Listing 6 show the property lem-
mas use the ﬁrst-order logic formulas over time points and
acton facts, based on the standard security property templates
speciﬁed by Tamarin Prover [17].
lemma s e c r e t _ P a s s w o r d _ s e r v :
" A l l n # i . S e c r e t ( ) @i
==> ( n o t
Reveal (A, B) @j & Honest (A) @i ) "
( Ex # j . K( n ) @j ) )
|
( Ex A B # j .
Listing 5: An example of a secrecy lemma in Tamarin code.
lemma injective_agreement_dev_serv_CONNECT :
" A l l a b t # i . Commit ( a , b , ) @i ==> ( Ex # j . Running ( b , a , ) @j & j ) @i2 &
n o t
( Ex C d a t a # r . Reveal (C ,
d a t a )@r & Honest (C) @i ) "
( # i 2 = # i ) ) )
|
Listing 6: An example of an authentication lemma in Tamarin
code.
Figure 9: The inferred state machine of the MQTT implemen-
tation on the Bosch IoT platform.
the special initial rule and session key negotiation rule.
The initial rule deﬁnes the initial states of the broker and
clients, which is concluded from the MQTT speciﬁcation.
MPInspector uses the let-binding expression to specify the
parameter semantics in the initial states, as shown in the sec-
ond line of Listing 2. MPInspector generates the transition
rule for session key negotiation based on the state machine,
which is a simpliﬁed SSL/TLS key negotiation modeling. The
rule is shown in Listing 3.
r u l e
i n i t _ c l i e n t :
!SERVER($SERVER) , Fr (~ C l i e n t I D ) , Fr (~
l e t username =  i n
[
a u t h i d ) , Fr (~ t e n a n t i d ) , Fr (~ password ) ] − −[
] − >[!DEVICE ($SERVER, ~ C l i e n t I D , username , ~
password ) , ! S t a t e _ 0 _ S e r v ($SERVER, ~ C l i e n t I D ,
username , ~ password ) , ! State_0_Dev ($SERVER, ~
C l i e n t I D , username , ~ password ) ]
Listing 2: An example of an initial rule in Tamarin code.
r u l e
c l i e n t _ s e r v _ n e g o t i a t e _ t l s _ k e y :
l e t username =  i n
[ ! S t a t e _ 0 _ S e r v ($SERVER, ~ C l i e n t I D , username , ~
password ) , ! S t a t e _ 0 _ C l i e n t ($SERVER, ~ C l i e n t I D
, username , ~ password ) , Fr (~ s e s s i o n _ k e y ) ]
] − >[ Dev_Tls_Sym ($SERVER, ~ C l i e n t I D ,
username , ~ password , ~ s e s s i o n _ k e y ) ,
Serv_Tls_Sym ($SERVER, ~ C l i e n t I D , username , ~
password , ~ s e s s i o n _ k e y ) ]
−−[
Listing 3: An example of a session key negotiation rule in
Tamarin code.
Second, we translate the transition messages from the
inferred state machine to rules following the principle de-
scribed in Section 4.6. Taking the server side transition C
ONNECT(senc{ClientID,username(V1,V2),password
}session_key/CONNACK(senc(’0’)session_key)) as
an example, we show its translated Tamarin rule in List-
ing 4. As shown in Listing 4, the rule’s left part shows the
state that the server receives the CONNECT message and its
4222    30th USENIX Security Symposium
USENIX Association