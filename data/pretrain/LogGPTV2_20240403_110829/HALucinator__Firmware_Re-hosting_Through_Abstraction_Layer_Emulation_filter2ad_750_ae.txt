0
19,214,779
STM UDP Server
3d:8h
STM UDP Client
0
12,703,448
3d:8h
STM TCP Server
0
16,356,129
0
3d:8h
16,723,950
STM TCP Client
STM ST-PLC
1d:10h
456,368
27
0
14d:0h 218,214,107
NXP TCP Server
0
14d:0h 240,720,229
NXP UDP Server
14d:0h 186,839,871
0
NXP HTTP Server
612
8,081
1,090
23,982
38,788
3,261
3,794
4,848
5,012
772
5164
3032
9710
Table 4: Fuzzing experiments results.
ﬁrmware shown in Table 4, and the ﬁrmware used in the
experiments in WYCINWYC [44]. WYCINWYC investi-
gates the observability of memory corruption on embedded
systems, and provides a vulnerable implementation of
an XML parser on embedded system. Experiments were
performed on a 12-core/24-thread Xeon server, with 96GB
RAM. Table 4 shows the statistics provided by AFL during
the fuzzing sessions. Crucially, we were able to scale these
experiments to the full capacity of this hardware, due to
removing the dependence on the original hardware.
We include the WYCNINWYC example here, as it
provides a benchmark of crash detection in an embedded
environment. This ﬁrmware uses the same STM HAL used
in previous experiments, and no additional handlers were
implemented. We substituted our fuzz model for the serial
port model, and fuzzing was seeded with the non-crashing
XML input included with the binary. We triggered four of
the ﬁve crashes in [44], without the need for additional crash
detection instrumentation, and were able to trigger the ﬁnal
crash by simply adding the ASAN-style sanitizer described
in Section 3.4. The remaining ﬁrmware were re-hosted
as in the interactive experiments, replacing the I/O server
with the fuzz model for network components and adding
fuzzing-related instrumentation. We also provided handlers
for disabling library-provided non-deterministic behaviors
(e.g., rand()), and generated inputs by simply recording
valid interactions performed in the previous experiments, and
1212    29th USENIX Security Symposium
USENIX Association
serializing them into a form that can be mutated by AFL.
These experiments uncovered bugs in the ﬁrmware
samples. The ST-PLC ﬁrmware implements a Programmable
Logic controller that executes uploaded ladder logic programs.
It uses WiFi connectivity to receive the ladder logic programs
from an Android app. This sample is extremely timer-driven,
and made use of the deterministic timer mechanism to ensure
that each input produced the same block information for
AFL. We provided AFL with only a minimal sample ladder
logic program obtained from the STM PLC’s Android app
by capturing network trafﬁc. After only a few minutes, AFL
detected an out-of-bounds memory access; upon further
inspection, we identiﬁed a buffer overﬂow in the ﬁrmware’s
global data section, which could result in arbitrary code
execution. The vulnerability is previously unknown, and we
are working with the vendor on a mitigation.
The Atmel HTTP server ﬁrmware is a small HTML
and AJAX application running on top of the popular lwIP
TCP/IP stack. After nearly 9 days, AFL detected 267 “unique”
crashes, which we disambiguated to 37 crashes using the
included minimization tools. Manual examination revealed
the crashes related to two bugs: a heap double-free in
lwIP itself, and a heap use-after-free caused by the HTTP
server’s erroneous use of lwIP functions that perform heap
management. The ﬁrmware, and the Atmel ASF SDK itself
ships with an outdated version of lwIP (version 1.4.1), and
both issues have since been ﬁxed by the lwIP developers.
However, random mutations in Ethernet frames, even
guided by AFL, are not likely to produce much coverage in the
core application logic of the ﬁrmware. To focus more directly
on the HTTP server, and not the IP stack, we can exploit the
ﬂexibility of high-level emulation, and instead re-host the bi-
nary in terms of the TCP APIs of the lwIP library (discovered
by LibMatch) that the HTTP server itself was written with,
allowing the fuzzed packets to reach deeper into the program.
Fuzzing at the higher level quickly found a buffer over-read
in the HTTP server’s handling of GET request parsing, which
provides an information disclosure in the heap.
The three crashes in the 6LoWPAN sample correspond
to a buffer overﬂow in the handling of the reassembly of
fragmented packets, resulting in overwriting many objects in
the binary’s data section with controlled input, and eventually
remote code execution. The issue relates to the Contiki-OS
platform, and as in the previous example, has been ﬁxed
since the version included in the latest SDK was produced.
However, the ﬁx in the latest version introduced two critical
vulnerabilities, which we reported as CVE-2019-8359 and
CVE-2019-9183 respectively. We worked with the Contiki
authors to patch these bugs.
These experiments show that HALucinator enables
practical security analysis of ﬁrmware without massive re-
engineering effort and without any hardware. The scalability
is in both the types of ﬁrmware that can be emulated, and
the number of instances that can be concurrently emulated.
This enables large parallelization of analyses and testing such
as fuzzing. The discovery of bugs in real ﬁrmware samples
demonstrates that the emulation is useful for dynamic
analysis of complex ﬁrmware.
6 Related Work
HALucinator draws upon related work in function and library
labeling, as well as ﬁrmware emulation.
Function Identiﬁcation and Labeling. Previous work has
explored various aspects of “function identiﬁcation”. As
this term has many over-loaded uses, it is important to
distinguish the problem LibMatch solves (labeling speciﬁc
binary function names in ﬁrmware samples) from others. Bin-
Diff [28, 55], and its open source counterpart Diaphora [21]
use graph-matching techniques to effectively and efﬁciently
compare two programs. While these tools can be effectively
used to label functions, by matching a target binary to each
library object, the tool does not account for collisions.
Multiple previous works have explored the problem of
function labeling, using various combinations of features
extracted from functions, and matching methods, to associate
one set of code from another. Feature extraction techniques
include function preamble-based signatures [31], backward
slices from system calls [35], and traces from symbolic
execution [46, 47]. Matching the extracted features has
been performed through Bayesian networks [15], neural
networks [33], and locality-sensitive hashing [24]. Unfortu-
nately, none of these systems are suited for labeling functions
in ﬁrmware due to several challenges: the inability to analyze
or execute ARM Cortex-M code, the lack of information
available to machine learning approaches due to small size
and close similarity of functions in HALs, and the inability
of some approaches to deal with collisions in an efﬁcient way.
This lack of existing approaches leads us to develop our func-
tion matching approach that is tailored to embedded ﬁrmware.
Firmware Emulation. Many previous works have explored
the challenge of emulating embedded ﬁrmware. The most
prevalent approach employs hardware-in-the-loop execution,
as found in AVATAR [58], AVATAR2 [43], and SURRO-
GATES [36]. In these systems, the physical target device is
tethered to the analysis environment, typically using a debug
port, and its hardware peripherals are used by a standard
emulator during execution. This approach is limited by its
visibility into the hardware; even with full debugger support,
only the state of the processor is accessible to the emulator.
State internal to peripherals is not synchronized with the
emulator, and external events (e.g., timeouts or data reception)
modify the peripheral’s state, causing it to deviate from the
emulator’s state, which may lead to incorrect execution or
faults when the emulator attempts to modify the peripherals
state by read/writing the peripherals registers. In addition,
current hardware-in-the-loop approaches do not support inter-
rupts or direct memory access (DMA). HALucinator handles
USENIX Association
29th USENIX Security Symposium    1213
interrupts and DMA through the same HALs developers use
to perform DMA; enabling emulating ﬁrmware which current
hardware-in-the loop approaches cannot.
Another approach [19, 20] to emulation involves using the
presence of a high-level operating system, such as Linux, as
a point of abstraction, and replacing the ﬁrmware’s version
with one able to be run in an emulator. This could be thought
of as a form of high-level emulation, as it uses the user-kernel
barrier as the modeling boundary. However, it only works
on ﬁrmware with a ﬁle-system image which can be booted
without any device-speciﬁc code being run. In this work, we
speciﬁcally target “blob” ﬁrmware, found in devices without
such an operating system.
All of these systems, including HALucinator, rely on an
underlying emulator to execute code and provide real or
emulated peripherals. The popular open-source QEMU [18]
provides the basis for most, and itself includes support
for a range of chips and the on-board peripheral models
needed to boot some ﬁrmware. SIMICS [38, 57] allows
one to implement cycle-accurate emulators, but requires
tedious manual effort to build the models of any device not
represented in its default distribution. However, as the number
of popular embedded CPUs has exploded, the usefulness of
these emulators in re-hosting a given ﬁrmware is decreasing.
HALucinator draws some inspiration from the work done
in game console emulation [23, 56], which pioneered the idea
of HLE, albeit applied to speciﬁc hardware environments
and software stacks. HALucinator represents a generalization
of this idea, and presents the ﬁrst known application to
embedded ﬁrmware for security.
Firmware can also be re-hosted without full emulation,
if source code is available. Simulators for Contiki [45],
mBed [39] and RIOT-OS [17] allow the developer to compile
their ﬁrmware code into a binary that can run on the host
system. In contrast, HALucinator allows for a similar kind of
re-hosting to be performed, but on the ﬁnal ﬁrmware binary,
and without the availability of source code.
Recently, approaches such as P2IM [12] and Pretender [32],
both concurrent with this work, achieve automated re-hosting
of embedded ﬁrmware by modeling the MMIO peripherals
directly. Pretender accomplishes this by recording the
original device’s MMIO activity, while P2IM instead utilizes
blind fuzzing of the entire MMIO layer. These approaches
themselves have differing utility; P2IM cannot be used as
a generic re-hosting solution, while Pretender requires the
original hardware which must be instrumentable. While
full automation is an important goal, and we expect that
some manual aspects of HALucinator can be automated
in the future, HALucinator’s HLE approach allows it to
handle many cases that neither automated system can.
First, both works list DMA as a major limitation; as DMA
tends to be used with high-performance peripherals, and its
complexity lends itself to being implemented within a library,
HALucinator handles DMA by simply removing it from
the program. We re-host multiple samples containing DMA
in Section 5.3. Second, P2IM only considers sequences of
MMIO interactions as input; when a crash is found, this must
be mapped back to the external stimulus, requiring a deep
understanding of the external peripherals’ MMIO interface.
HLE-based approaches do not suffer from this problem, as
they work only with this external stimulus, and the inputs can
be readily replayed against real and virtualized targets alike.
7 Limitations and Discussion
We believe that LibMatch and HALucinator represent an im-
portant step in the practicality and scalability of the dynamic
analysis of embedded ﬁrmware. However, the problem in
general is not fully solved. Here we will discuss limitations,
and open problems in embedded ﬁrmware analysis.
Use and Availability of HALs. The process of high-level
emulation as described in this work, requires the ﬁrmware use
a HAL, and the HAL must be available to the analyst (e.g.,
either open source, or part of the microcontroller’s SDK). The
compilation environment for the LibMatch database must
be similar to the compilation environment for the ﬁrmware,
and QEMU must support the microcontroller architecture.
Even when these conditions are met, handlers and peripheral
models must be developed for each HAL. Progress on
any of these limitations will increase the applicability of
HALucinator in analyzing ﬁrmware.
We note that microcontroller vendors are investing signiﬁ-
cant resources into the development of HALs and license them
under permissive terms. While we cannot estimate the popula-
tion of devices today that use HALs, we expect these steps on
the part of manufacturers will lead to a rapid increase in HAL
usage. However, if a HAL is not used in a ﬁrmware sample, or
is unavailable to the analyst, then LibMatch cannot be used for
identifying interfaces usable for high-level emulation. This
does not prohibit high-level emulation; as a reverse-engineer
could manually identify useful abstractions in the binary. This
is likely preferable to writing low-level QEMU peripherals.
Library Matching. LibMatch implements extensions on top
of library matching algorithms that allow them to be used
for the purpose of ﬁnding HALs and libraries in ﬁrmware.
However, we note that
the effectiveness of LibMatch,
especially when the compiler or library versions used is
unknown, is limited. This limitation comes from function
matching techniques’ inability to cope with compiler-induced
variations in generated code. While partial techniques
have been proposed, most recently in [24], the problem
is not solved in the general case. High-level emulation
and LibMatch will beneﬁt directly from any advancement
in this orthogonal problem area of function matching in
the future. LibMatch’s primary contribution is the use of
context (callees/callers) of a function to disambiguate binary
equivalent functions, which is necessary to enable correct
interception and replacement of functions by HALucinator.
1214    29th USENIX Security Symposium
USENIX Association
8 Conclusion
References
We explored the concept of high-level emulation to aid
in the practical re-hosting and analysis of embedded
“blob” ﬁrmware. To ﬁnd useful abstractions, we showcased
improvements in binary library matching to enable hardware
abstraction layers and other common libraries to be detected
in binary ﬁrmware images. Implementations were then
broken down into abstract components that are reusable
across ﬁrmware samples and chip models.
HALucinator, is the ﬁrst system to combine these tech-
niques into a system for both interactive dynamic analysis,
as well as fuzzing. We re-hosted 16 ﬁrmware samples,
across CPUs and HALs from three different vendors, and
with a variety of complex peripherals. High-level emulation
made this process simple, allowing for re-hosting to take
place with little human effort, and no invasive access to
the real hardware. Finally, we demonstrated HALucinator’s
applications to security, by using it to detect security bugs
in ﬁrmware samples. We believe that high-level emulation
will enable analysts to broadly explore embedded ﬁrmware
samples for fuzz testing and other analyses. HALuci-
nator is available at https://github.com/embedded-
sec/halucinator, HALucinator-fuzzer is available at
https://github.com/ucsb-seclab/hal-fuzz.
Acknowledgments
We thank Bo Feng and Long Lu for providing us with some
of the ﬁrmware samples used in this paper. We would also
like to thank Michael Bailey for his guidance during the
editing of this paper.
Sandia National Laboratories is a multimission laboratory
managed and operated by National Technology & Engineer-
ing Solutions of Sandia, LLC, a wholly owned subsidiary
of Honeywell International Inc., for the U.S. Department of
Energy’s National Nuclear Security Administration under
contract DE-NA0003525 (SAND2019-14482 C). This mate-
rial is based upon work supported by ONR under Award No.
N00014-17-1-2011 and N00014-17-1-2513, by NSF under
award numbers CNS-1718637, CNS-1704253 and CNS-
1801601, by AFRL and DARPA under agreement number
FA8750-19-C-0003, and by Department of Homeland Secu-
rity under agreement number FA8750-19-2-0005. The U.S.
Government is authorized to reproduce and distribute reprints
for Governmental purposes notwithstanding any copyright
notation thereon. The views and conclusions contained herein
are those of the authors and should not be interpreted as
necessarily representing the ofﬁcial policies or endorsements,
either expressed or implied, of the U.S. Department of Energy,
Department of Homeland Security, Ofﬁce of Naval Research,
AFRL, DARPA or the U.S. Government. This project has
received funding from the European Research Council (ERC)
under the European Union’s Horizon 2020 research and
innovation programme (grant agreement No. 850868).
[1] Amazon FreeRtOS Vendors. https://github.com/
aws/amazon-freertos/tree/master/vendors.
[2] Atmel
studio
7
- microchip
technologies.
https://www.microchip.com/mplab/avr-
support/atmel-studio-7.
[3] Build With Mbed. https://www.mbed.com/built-
with-mbed/.
[4] Code
studio
composer
integrated development
environment. http://www.ti.com/tool/CCSTUDIO.
[5] CSAW Embedded Security Challenge.
//csaw.engineering.nyu.edu/esc.
https:
[6] Halucinator:
rf233.py.
https://github.com/
embedded-sec/halucinator/blob/master/src/
halucinator/bp_handlers/atmel_asf_v3/rf233.
py.
[7] HALucinator:
stm32f4_uart.py.
https:
//github.com/embedded-sec/halucinator/
blob/master/src/halucinator/bp_handlers/
stm32f4/stm32f4_uart.py.
[8] Mbed OS Repo
- ARMmbed/mbed-os/targets.
https://github.com/ARMmbed/mbed-os/tree/
master/targets.
[9] stm32duino
-
Arduino_Core_STM32/system.
https://github.com/stm32duino/Arduino_
Core_STM32/tree/master/system.
[10] System Workbench for STM32.
https://www.st.
com/content/st_com/en/products/development-
tools/software-development-tools/stm32-
software-development-tools/stm32-ides/
sw4stm32.html.
[11] TrustworthyComputing / csaw_esc_2019 - Github.
https://github.com/TrustworthyComputing/
csaw_esc_2019.
[12] P2im: Scalable and hardware-independent ﬁrmware
testing via automatic peripheral interface modeling. In
29th USENIX Security Symposium (USENIX Security
20), Boston, MA, August 2020. USENIX Association.
[13] American Fuzzy Lop. http://lcamtuf.coredump.
cx/afl/.
[14] AFL-Unicorn.
afl-unicorn.