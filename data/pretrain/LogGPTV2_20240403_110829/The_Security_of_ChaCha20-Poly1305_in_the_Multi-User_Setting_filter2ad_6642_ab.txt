the output to ğ‘¦. By convention, the running time of an adversary
is the sum of its running time, the time to answer all of its oracle
queries, and the size of its description.
AEAD Syntax. A nonce-based authenticated encryption scheme
with associated data ğ›± = (K, E, D) is a triple of algorithms:
â€¢ The key generation algorithm K takes no input and returns a
secret key ğ¾. We overload K to also represent the key space
associated to the key generation algorithm.
â€¢ The deterministic encryption algorithm E : K Ã— N Ã— AD Ã—
M â†’ C takes as input a secret key ğ¾ âˆˆ K, a nonce ğ‘ âˆˆ N,
associated data ğ´ğ· âˆˆ AD, and a message ğ‘€ âˆˆ M and returns
a ciphertext ğ¶ âˆˆ C. We require E to have constant expansion,
i.e. for any (ğ¾, ğ‘ , ğ´ğ·, ğ‘€) âˆˆ (K,N, AD,M), the expansion ğ‘¡ =
|E(ğ¾, ğ‘ , ğ´ğ·, ğ‘€)| âˆ’ |ğ‘€| is constant.
â€¢ The deterministic decryption algorithm D : KÃ—N Ã—ADÃ—C â†’
M âˆª {âŠ¥} takes as input a secret key ğ¾ âˆˆ K, a nonce ğ‘ âˆˆ N,
associated data ğ´ğ· âˆˆ AD, and a ciphertext ğ¶ âˆˆ C and returns
either a message ğ‘€ âˆˆ M or the symbol âŠ¥ to indicate an invalid
ciphertext.
We refer to the associated sets K, N, AD, M, and C as the key
space, the nonce space, the associated-data space, the message or
plaintext space and the ciphertext space, respectively. We require
every nonce-based AEAD to satisfy correctness, namely for all
(ğ¾, ğ‘ , ğ´ğ·, ğ‘€) âˆˆ (K,N, AD,M), it must hold that if ğ¶ â† E(ğ¾, ğ‘ ,
ğ´ğ·, ğ‘€) then ğ‘€ â† D(ğ¾, ğ‘ , ğ´ğ·, ğ¶).
AEAD Multi-User Security. We use the multi-user security defi-
nition for authenticated encryption put forward by Bellare and
Tackmann [4] adapted to the ideal permutation model. Here, the
encryption oracle Enc(ğ‘–, ğ‘ , ğ´ğ·, ğ‘€) and the verification oracle
Vf(ğ‘–, ğ‘ , ğ´ğ·, ğ¶) can be queired for distinct users (identified by the
integer ğ‘–). The adversary A is also given access to the ideal permu-
tation ğœ‹ through the oracle Prim(ğ‘‹) and its inverse Primâˆ’1(ğ‘Œ).
An adversary is said to be nonce-respecting if it never repeats a
pair (ğ‘–, ğ‘) across encryption queries. Throughout, we require that
every adversary be nonce-respecting and never asks a verification
query Vf(ğ‘–, ğ‘ , ğ´ğ·, ğ¶) with ğ¶ being the output of a previous en-
cryption query Enc(ğ‘–, ğ‘ , ğ´ğ·, ğ‘€) (since such queries permit trivial
wins). Without loss of generality, we will assume that an adversary
does not repeat any queries.
At points in our analysis, we will require that an adversary A
be ğ‘‘-repeating, meaning that A does not repeat the same nonce
with more than ğ‘‘ users in its encryption queries. A is strongly
ğ‘‘-repeating if it is ğ‘‘-repeating and additionally does not repeat the
same nonce across verification queries for more than ğ‘‘ users.
Definition 2.1 (Multi-user AE advantage).
Let ğ›±[ğœ‹] = (K, E, D) be a nonce-based AEAD scheme constructed
from an ideal permutation ğœ‹ : X â†’ X with expansion ğ‘¡. We define
the multi-user AE advantage of adversary A against ğ›±[ğœ‹] as:
ğ›± [ğœ‹] â‡’ 1
ğ›± [ğœ‹] â‡’ 1
AğºIdeal-muAE
AğºReal-muAE
âˆ’ Pr
(cid:21)
,
Adv
ğ›± [ğœ‹] (A) = Pr
muAE
(cid:20)
(cid:21)
(cid:20)
where games ğºReal-muAE
ğ›± [ğœ‹]
and ğºIdeal-muAE
ğ›± [ğœ‹]
are defined in Figure 1.
procedure Initialize
1 : ğ¾1, ğ¾2, Â· Â· Â· â†$ K
procedure Enc(ğ‘–, ğ‘ , ğ´ğ·, ğ‘€)
1 : ğ¶ â† E(ğ¾ğ‘–, ğ‘ , ğ´ğ·, ğ‘€)
2 :
procedure Prim(ğ‘‹)
1 :
return ğœ‹ (ğ‘‹)
return ğ¶
Game ğºReal-muAE
ğ›± [ğœ‹]
procedure Vf(ğ‘–, ğ‘ , ğ´ğ·, ğ¶)
1 : ğ‘€ â† D(ğ¾ğ‘–, ğ‘ , ğ´ğ·, ğ¶)
2 :
procedure Primâˆ’1(ğ‘Œ)
1 :
return (ğ‘€ â‰  âŠ¥)
return ğœ‹âˆ’1(ğ‘Œ)
procedure Enc(ğ‘–, ğ‘ , ğ´ğ·, ğ‘€)
1 : ğ¶ â†$ {0, 1}|ğ‘€|+ğ‘¡
2 :
procedure Prim(ğ‘‹)
1 :
return ğœ‹ (ğ‘‹)
return ğ¶
Game ğºIdeal-muAE
ğ›± [ğœ‹]
procedure Vf(ğ‘–, ğ‘ , ğ´ğ·, ğ¶)
1 :
return false
procedure Primâˆ’1(ğ‘Œ)
1 :
return ğœ‹âˆ’1(ğ‘Œ)
Figure 1: Games used to define the multi-user AE advantage.
Adversarial Parameters. In the following, for an associated adver-
sary A, we will denote by ğ‘ğ‘’ its maximum number of encryp-
tion queries and by ğœğ‘’ an upper bound on its total number of
encrypted blocks. We denote by ğ‘ğ‘£ the maximum number of de-
cryption/verification queries of A and by ğœğ‘£ an upper bound on its
total number of decrypted/verified blocks. Further, let â„“ğ‘š denote
the maximum size in ğ‘¡-bit blocks (including associated data) that
A is allowed to query to its encryption and decryption/verification
oracles. Finally, for the multi-user setting, ğ‘ denotes the maximum
Session 6D: Authentication and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1983number of ideal permutation queries and ğ‘‘ denotes the maximum
number of users queried with the same nonce during encryption
(i.e. for a ğ‘‘-repeating or strongly ğ‘‘-repeating adversary A).
Î”-Universal Hash Functions. Let ğ» : R Ã—D â†’ {0, 1}ğ‘¡ be a family of
keyed hash functions with key space R, domain D and digest space
{0, 1}ğ‘¡, for some positive integer ğ‘¡. We will consider hash function
families over strings and string pairs. When D = {0, 1}âˆ—, for any
positive real number ğ‘, we say that ğ» is ğ‘-almost Î”-universal if for
all distinct ğ‘€, ğ‘€â€² âˆˆ {0, 1}âˆ— and all ğ‘§ âˆˆ {0, 1}ğ‘¡, it holds that
(cid:104)ğ»ğ‘Ÿ (ğ‘€) = ğ»ğ‘Ÿ (ğ‘€â€²) (ğ‘¡)+ ğ‘§(cid:105) â‰¤ ğ‘ Â· max (|ğ‘€|ğ‘¡ , |ğ‘€â€²|ğ‘¡)
(cid:104)ğ»ğ‘Ÿ (ğ´ğ·, ğ¶) = ğ»ğ‘Ÿ (ğ´ğ·â€², ğ¶â€²) (ğ‘¡)+ ğ‘§(cid:105)
Alternatively, when D = {0, 1}âˆ— Ã— {0, 1}âˆ—, for any distinct (ğ´ğ·, ğ¶),
(ğ´ğ·â€², ğ¶â€²) âˆˆ {0, 1}âˆ— Ã— {0, 1}âˆ— and all ğ‘§ âˆˆ {0, 1}ğ‘¡, we require that
Prğ‘Ÿ â†$ R
Prğ‘Ÿ â†$ R
2ğ‘¡
.
â‰¤ ğ‘ Â· max (|ğ´ğ·|ğ‘¡ + |ğ¶|ğ‘¡ , |ğ´ğ·â€²|ğ‘¡ + |ğ¶â€²|ğ‘¡)
.
2ğ‘¡
of input-output pairs ğœ = (cid:0)(ğ‘¥1, ğ‘¦1), (ğ‘¥2, ğ‘¦2), . . . , (ğ‘¥ğ‘, ğ‘¦ğ‘)(cid:1). We use
H-coefficient Technique. The H-coefficient technique [11, 25] is
a method for bounding the advantage of a computationally un-
bounded adversary A, which wlog can be assumed to be deter-
ministic, attempting to distinguish between a real and an ideal
game. The technique focusses on the transcripts generated when
A interacts with the oracles in these games, namely, the sequence
Tideal to denote the random variable corresponding to the transcript
generated by A in the ideal game. Then, Pideal(ğœ) and Preal(ğœ) de-
note the probabilities that a given transcript ğœ is generated in the
corresponding game when interacting with A. A transcript ğœ is said
to be attainable if there exists an adversary such that the probability
of generating ğœ in the ideal game is strictly greater than 0.
The H-coefficient technique relies on identifying a suitable parti-
tion of attainable transcripts, applying the following theorem, and
then calculating ğœ–1 and ğœ–2 (for a proof, see [11]):
Theorem 2.2 (H-coefficient Techniqe). Let A be a computa-
tionally unbounded adversary trying to distinguish between a real
game ğºReal and an ideal game ğºIdeal. Let ğ‘‡ = ğ‘‡good âŠ” ğ‘‡bad be a
partition of the set of attainable transcripts. If there exist ğœ–1, ğœ–2 â‰¥ 0
such that âˆ€ğœ âˆˆ ğ‘‡good, Preal(ğœ)
Pideal(ğœ) â‰¥ 1 âˆ’ ğœ–1 and Pr[Tideal âˆˆ ğ‘‡bad] â‰¤ ğœ–2,
then
(cid:12)(cid:12)(cid:12)Pr(cid:104)AğºReal â‡’ 1(cid:105) âˆ’ Pr(cid:104)AğºIdeal â‡’ 1(cid:105)(cid:12)(cid:12)(cid:12) â‰¤ ğœ–1 + ğœ–2.
3 THE CHACHA20-POLY1305 SCHEME
In this section, we provide a brief overview of ChaCha20-Poly1305,
as defined in RFC 8439 [23], and lay some of the groundwork for
our security analysis.
The AEAD Composition. Pseudocode for ChaCha20-Poly1305 is
shown in Figure 3, consisting of the encryption algorithm E, the
decryption algorithm D, and their subcomponents: the ChaCha20
stream cipher, the one-time MAC Poly1305_Mac, and the MACâ€™s
key-generation algorithm Poly1305_Key_Gen. In turn, these sub-
components are based on the ChaCha20 block function CC_block
and the Î”-universal hash function family ğ» over string pairs.
The encryption algorithm E is represented in Figure 2. It takes
as input a 256-bit secret key ğ¾, a 96-bit nonce ğ‘ , a variable-length
Associated Data
ğ´ğ·
Key
ğ¾
Nonce
ğ‘
Plaintext
ğ‘€
Counter=0
Counter=1
Counter=â„“
CC_block
CC_block
. . .
CC_block
2ğ‘¡ bits
Poly1305_Key_Gen
Keystream
ChaCha20
ğ´ğ·
pad(ğ´ğ·)
ğ¶
pad(ğ¶)
len(ğ´ğ·)
len(ğ¶)
One-time key (ğ‘Ÿ, ğ‘ )
Poly1305
Authentication tag ğ‘‡
Ciphertext ğ¶
Poly1305_Mac
Figure 2: The encryption procedure in ChaCha20-Poly1305.
byte string of associated data ğ´ğ·, and a variable-length byte-string
message ğ‘€. It returns a ciphertext ğ¶ consisting of the ChaCha20
encryption of ğ‘€, and a 128-bit tag ğ‘‡ , computed over ğ´ğ· and ğ¶ using
Poly1305_Mac with a one-time key (ğ‘Ÿ, ğ‘ ) consisting of two 128-bit
strings. The one-time key (ğ‘Ÿ, ğ‘ ) is derived anew in each encryption
by running the ChaCha20 block function in Poly1305_Key_Gen on
ğ¾, ğ‘ , and the counter value zeroâ€”which is reserved solely for this
purpose. The decryption algorithm D proceeds analogously: it first
derives the one-time key, it recomputes the MAC tag and checks
whether it matches that supplied in the ciphertext. If so, it proceeds
to decrypt the rest of the ciphertext using ChaCha20 and returns
the decrypted message. Otherwise it returns âŠ¥, indicating error.
Chacha20. Designed by Bernstein, the ChaCha20 stream cipher [7]
is a refinement of the Salsa stream cipher [6]. It uses a 256-bit secret
key ğ¾ and a 96-bit nonce ğ‘ to encrypt (or decrypt) an arbitrary-
length message ğ‘€ (or ciphertext ğ¶). As with any stream cipher, it
generates a pseudorandom keystream that is XORed to the mes-
sage. The keystream is generated in blocks of 512 bits through
the ChaCha20 block function CC_block. The CC_block function
is keyed with ğ¾ and is evaluated over an input composed of the
96-bit nonce ğ‘ and a 32-bit block counter ğ‘–. This way, it is em-
ployed as a pseudorandom function, but under the hood it really
consists of a 512-bit permutation ğœ‹ in a Daviesâ€“Meyer-type con-
figuration. More specifically, the key, counter, and nonce are con-
catenated and prepended with a constant to form the input to the
ChaCha20 permutation and then added once again to the permu-
tationâ€™s output using modulo 232 addition on word-by-word basis,
i.e., CC_block(ğ¾, ğ‘ , ğ‘–) = ğœ‹(ğ‘âˆ¥ğ¾âˆ¥ğ‘–âˆ¥ğ‘) (32)+ (ğ‘âˆ¥ğ¾âˆ¥ğ‘–âˆ¥ğ‘), where ğ‘ is a
128-bit constant.
Poly1305. The Poly1305 algorithm [5] is a one-time MAC, also
designed by Bernstein. It takes a key consisting of two 128-bit
strings (ğ‘Ÿ, ğ‘ ); the tag corresponding to a message ğ‘€ is computed as
ğ»ğ‘Ÿ (ğ‘€) (ğ‘¡)+ ğ‘ . Its security relies on the ğ‘-almost Î”-universality of the
hash function ğ», as shown by Bernstein [5]. The hash function ğ»
Session 6D: Authentication and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1984return ğ¶ âˆ¥ğ‘‡
ğ‘Ÿ âˆ¥ğ‘  â† Poly1305_Key_Gen(ğ¾, ğ‘)
if ğ‘‡ â‰  ğ‘‡â€² then return âŠ¥
return ChaCha20(ğ¾, ğ‘ , ğ¶)
procedure E(ğ¾, ğ‘ , ğ´ğ·, ğ‘€)
1 :
2 : ğ¶ â† ChaCha20(ğ¾, ğ‘ , ğ‘€)
3 : ğ‘‡ â† Poly1305_Mac((ğ‘Ÿ, ğ‘ ), ğ´ğ·, ğ¶)
4 :
procedure D(ğ¾, ğ‘ , ğ´ğ·, ğ¶âˆ¥ğ‘‡)