# 【技术分享】详谈WAF与静态统计分析
|
##### 译文声明
本文是翻译文章，文章来源：ptsecurity.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
译者：[blueSky](http://bobao.360.cn/member/contribute?uid=1233662000)
预估稿费：200RMB
投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿
**前言**
****
虚拟补丁（VP）近年来一直是保护应用程序最受欢迎的方法之一，如果在Web应用程序防火墙层级添加VP功能，该功能可用于保护Web应用程序免遭已知漏洞的威胁攻击。简而言之，VP利用静态应用程序安全测试（SAST）的结果并使用它们来创建规则以用来过滤WAF上的HTTP请求。
但问题在于，SAST和WAF依赖于不同的应用程序模型和不同的决策方法。因此，目前可用的解决方案中没有一个能够将SAST与WAF完美的结合起来。SAST基于白盒模型，它采用公式方法来检测代码中的漏洞。然而，WAF将应用程序视为黑盒子，因此它使用启发式方式进行攻击检测。但是如果我们能让SAST和WAF完美的结合在一起使用，我们可以通过SAST获取有关应用程序内部结构的信息，并将这些信息提供给WAF，这样我们就可以以一种“优雅”的方式来检测网络攻击。
**传统VP**
****
一般地，在Web应用程序传统自动化虚拟修补方法中，我们需要向WAF提供SAST检测到的每个漏洞信息，这些信息包括：
**漏洞分类**
**Web应用程序的脆弱点**
**攻击所需的HTTP请求参数值**
**构成攻击向量脆弱点参数的值**
**脆弱点参数中可用于漏洞利用的一组字符或一个单词。**
一般地，我们可以通过定义某些函数来获取HTTP请求中的参数值，例如下面是一段易受XSS攻击的ASP.NET页面的代码片段：
通过分析针对上面页面的攻击向量代码，我们可以生成一组攻击向量值的符号公式：
{condition =“secret”⇒param∈{XSShtml-text}} ，其中XSShtml-text是TEXT上下文中用于XSS攻击的向量集合。在实际的应用场景中，WAF虚拟补丁的描述符可用于生成过滤规则，以阻止所有能够利用相关漏洞的HTTP请求。
虽然这种做法肯定会导致某些攻击，但它有一些很大的缺点：
为了表示任何给定的漏洞，SAST需要发现一个可能的攻击向量。
但为了确保能够真正消除一个漏洞，SAST有必要处理所有可能的攻击向量。但是SAST很难将这些信息传递给WAF，因为由于攻击向量语法的不规则性，矢量集不仅是无穷大的，甚至不能用正则表达式来表达。
对于漏洞利用所需的其他请求参数的值也是如此。
如果入侵点和脆弱执行点之间的攻击向量语法在其上下文中发生了变化，那么有关脆弱参数的信息将变得没有任何的价值。
由于这些设计上的缺陷，对于SAST检测到的漏洞，VP技术不能针对其提供可能的攻击保护。尝试创建这种“全面的”流量过滤规则通常会阻止合法HTTP请求并中断Web应用程序的操作，下面让我们稍微修改漏洞的代码：
与上一个例子的区别是：在对两个请求参数都做了Decode处理，针对该新代码的攻击向量公式如下所示：
    （CustomDecode condition）⊃“secret”⇒param∈（CustomDecode {XSShtml-text}）
。静态分析会在相关计算流程图（ConfiG）节点中为自定义解码函数导出一个公式，以描述Base64-URL-Base64转换链，如下所示：
    (FromBase64Str (UrlDecodeStr (FromBase64Str argument)))
。 针对这样的公式，我们仍然有可能在其基础上构建一个漏洞，但是由于以下原因，生成虚拟补丁的方法不能应用于此：
只有当请求中的“condition”参数包含“secret”子字符串时，才可能利用此漏洞。
然而，该参数的值集是非常大的，并且由于解码功能的不规则性，通过正则表达式表达该集合是不可行的。
事实上，攻击向量的请求参数也被解码。因此，SAST无法将该组危险元素描述为WAF。
由于传统VP的所有问题都源于无法与基于白盒方法的WAF级别的应用程序进行交互，因此明显的解决方案是实现此功能并进一步改进，以便：
SAST向WAF提供有关易受攻击的参数以及从进入点到易受攻击的执行点这整个过程中对攻击变量所做的所有转换信息。
对于攻击检测，启发式方法被公式方法所替换，并且包含任何漏洞的利用条件信息。
因此，运行时虚拟补丁应运而生。
**运行时虚拟补丁**
****
运行时虚拟修补（RVP）的原理是基于PT应用检查器（PT
AI）中的计算流程图模型实现的。与公式符号计算的语义表示类似，该模型是使用应用程序代码的抽象解释构建出来的，模型中的图节点包含了目标语言的生成公式，并且公式产生与相关执行点上的所有数据流相关联的所有合法值的集合，具体如下图所示：
上图中的这些流被称为执行点参数。 由于CompFG是可评估的，因此我们可以根据输入参数的值，在任何执行点上计算所有参数的值。
通常情况下，RVP分为部署（D）和运行（R）两个阶段，这俩个阶段分别对应于应用程序生命周期，具体如下图所示：
**部署阶段**
****