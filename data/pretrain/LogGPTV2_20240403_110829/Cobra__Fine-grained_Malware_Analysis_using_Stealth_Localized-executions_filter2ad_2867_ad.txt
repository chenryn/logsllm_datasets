pop cobra_eflag *
* Implant Executed via an Xfer-Stub
Figure 4. Stealth Implants
result
Localized-executions
in increased latency due
to block creations and the xfer-stubs transferring control
to and from the BCXE during block execution. Such la-
tency is not present during normal execution of the target
code-stream. A malware could use this fact to detect if its be-
ing analyzed. As an example, a malware could use the RDTSC
instruction to obtain the amount of clock-cycles that have
elapsed since system-bootup and obtain a relative measure-
ment of its code fragment execution. A malware could also
use the real-time clock (RTC) to perform a similar latency de-
tection in kernel-mode via the IN and the OUT I/O instruc-
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:50:44 UTC from IEEE Xplore.  Restrictions apply. 
   ...
Block Creation
1. 8d003ff0h: pop ebp
2. 8d003ff1h: mov ebx, [edi+1ah] 
3. 8d003ff4h: mov [ebp+eax], ebx
4. 8d003ff6h: mov esi, ebp
5. 8d003ff8h: call d [edi+0bh]
6. 8d003ffch: jne 8d003ff1h
7. 8d003ffeh: add eax, ebp
8. 8d004001h: call eax
   ...
block-1:
 pop ebp
 mov ebx, [edi+1ah]
 mov [ebp+eax], ebx
 mov esi, ebp
mov PIB, entry1 
 jmp bcxe
block-2:
mov PIB, entry2
 jne bcxe
 mov PIB, entry3
 jmp bcxe
jne 1
block-3:
 add eax, ebp
mov PIB, entry4
 jmp bcxe
call d [edi+0bh] (Skip)
call eax (Skip)
C oalesce
Figure 5. Skipping and Block-Coalescing
block-1-2-3:
 9. pop ebp
10. mov ebx, [edi+1ah]
11. mov [ebp+eax], ebx
12. mov esi, ebp
13. call d [edi+0bh]
14. jne 1
15. add eax, ebp
16. mov PIB, entry4
    jmp bcxe
(Skip)
(Skip)
tions. Figure 4.2.1 shows the stealth-implants corresponding
to such instructions. The RDTSC instruction stores the re-
turn value in the EAX register. The RTC detection makes use
of the RTC I/O ports using the privileged IN instruction. Co-
bra replaces such privileged instructions with xfer-stubs that
transfer control to the BCXE which then locally executes
these instructions at a high privilege level and returns the re-
sult. For example, Cobra replaces the RDTSC instruction
with a regular MOV instruction that stores the value of Co-
bra’s internal processor-counter to the EAX register (Figure
4). A point to note is that not all stealth-implants transfer con-
trol to the BCXE. Most instructions which store a value into a
destination memory operand can have a stealth-implant with-
out an xfer-stub directly replacing the instruction.
Certain malware code streams can employ debugging tech-
niques for their own execution. A malware for example can
employ the POPF instruction to set the processor trap-ﬂag.
This results in a single-step exception being invoked. The mal-
ware can then use the single-step handler to perform the ac-
tual functionality (eg. W32/Ratos). A stealth-implant in this
case will replace the POPF instruction with a xfer-stub that
tranfers control to the BCXE. The BCXE will then examine
the trap-ﬂag and will automatically generate a single-step ex-
ception for every instruction thereafter until the trap-ﬂag is
clear. Some code-streams running in kernel-mode can also em-
ploy the hardware debugging registers for computation (eg.
W32/HIV and W32/Ratos). The debugging registers can also
be used by the malware to set breakpoints within its code-
streams. Cobra handles such issues by replacing access to such
debug registers with stealth-implants and can generate break-
point exceptions by monitoring the values in such registers.
Malware code-streams can also use instructions such as
PUSH, VERW and ARPL in both user- and kernel-mode to ob-
tain the selector for the executing code segment. Since Cobra
executes the blocks at an unprivileged level such instructions
will reﬂect an unprivileged code segment selector and can be
used as a detection mechanism against the framework. How-
ever, Cobra’s stealth-implants replace such instructions to re-
ﬂect the actual value of the executing code segment selectors.
4.2.2. Cloning and Other Issues A malware can access crit-
ical system structures in order to detect that it is being ana-
lyzed using Cobra. For example a malware might try to ob-
tain the PFH address and compare it with the system default
values (which for certain OSes lies within a ﬁxed range re-
gardless of their version) in order to detect the framework.
Similarly it might try to check the page-attributes of certain
memory regions (eg. its code and data) which can be different
due to memory access monitoring by Cobra. Further a mal-
ware can also install its own fault handlers in the IDT for its
functioning. Cobra uses a technique that we call cloning to
hide the framework while at the same time allowing the mal-
ware to access such critical structures. The framework main-
tains a copy of critical memory regions such as the page-
tables/page-directories, IDT, GDT etc. that reﬂect their system
default contents initially. The framework block-monitor tack-
les issues such as reads and/or writes to such critical structures
by presenting the clone of these memory regions, thereby fool-
ing the malware into thinking that it is operating on the original
memory regions. Stealth-Implants for certain instructions in-
volving control registers such as CR3 (used to obtain the page-
directory base address) and instructions such as SIDT, SLDT
and SGDT present the addresses of the cloned memory regions
instead of the original.
Localized-executions lead to a couple of issues a malware
could exploit to detect the framework during runtime. A mal-
ware in a multithreaded fashion can use a thread context cap-
ture function (under Windows OSs the GetThreadcontext API
and under Linux, the ptrace API) to obtain the current program
counter and stack contents for its executing threads. However,
since the thread code-stream is being executed by Cobra, the
values of its program counter and stack pointer will be dif-
ferent than in the normal course of execution. Cobra instru-
ments such APIs using our stealth coarse-grained instrumen-
tation framework, SPiKE [51] and presents the original values
of the thread program counter and stack pointer. A point to be
noted is that Cobra has no effect on the thread stack of the tar-
get code-stream. The framework employs a local stack (differ-
ent from the currently executing thread stack), that is switched
to upon entry from an xfer-stub. Also, the xfer-stubs make use
of the PIB to pass parameters to the BCXE, thereby ensur-
ing that the thread stack is left untouched. This prevents Cobra
from being detected using stack overﬂow mechanisms.
Every instance of Cobra’s deployment is different in the
form of any privileged modules, environment variables, con-
ﬁguration ﬁles and code streams. Thus, no malware can de-
tect the framework by searching these elements for a pattern.
This also allows load/store instructions within blocks that ac-
cess memory regions pertaining to the framework code/data, to
be executed directly without Cobra’s intervention.
4.3. Skipping and Block-Coalescing
A block may contain an instruction that transfers control
to a code-stream following a standard execution semantic (e.g
system calls, standard library calls etc.). Localized-executions
of such standard code-streams result in increased latency and
are in most cases undesirable (since they do not form a part of
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:50:44 UTC from IEEE Xplore.  Restrictions apply. 
the malware being analyzed). For example, consider the code
fragment of the W32/Ratos trojan as shown in Figure 5. The
CALL instruction in line 8, Figure 5 uses an indirect target
address, but is found to transfer control to a standard code-
stream (in this case the VirtualProtect system call). Localized-
execution of the system call in this case is meaningless since
it does not contribute towards the analysis process. Note that
the system call invocation does have a bearing on the malware
functionality at a coarse level, but does not have any implica-
tion on the ﬁne-grained analysis of the malware code-stream.
Cobra can identify such standard code-streams dynamically
and exclude them from localized-executions, thereby reduc-
ing the latency that might occur in trying to execute an OS or
standard code-stream. We call this technique skipping. Skip-
ping can also be applied to non-standard code-streams during
the analysis process. This might be used to exclude already an-
alyzed malware speciﬁc code-streams. As an example, line 5
of Figure 5 shows a CALL instruction which performs an in-
tegrity check over a speciﬁed region of code. The code-stream
concealed behind this CALL never changes in its semantics
and can be thus be skipped after analyzing it once.
Execution of blocks under Cobra involve control transfers
to and from the BCXE. These transfers result in the saving and
restoration of the processor registers which contribute to the
framework latency. This is more important for code-streams
employing loops since every iteration of the loop will involve
invoking the BCXE. The framework employs a technique that
we call block-coalescing to minimize latency due to such code
constructs. In this technique, a group of blocks are brought
together to form a single block, preventing multiple control
transfers to the BCXE. Let us consider the code fragment
shown in Figure 5. Here we see a loop implementing some
form of integrity check. Figure 5 also shows the blocks asso-
ciated with the code fragment. From our analysis session, we
found the loop to execute close to 50 times on an average. Fig-
ure 5 shows the block-coalesced version, where blocks 1–3
have been coalesced, reducing the number of transfers to the
BCXE. Block-coalescing is a powerful mechanism that can
generate blocks which are very similar to the original code-
stream, and can be executed with minimal latency while en-
suring that Cobra is still under control of the executing code-
stream. Block-coalescing is performed by a user-deﬁned call-
back that chooses the blocks to participate in the coalescing
process. With the above example, the ﬁrst few instance of the
loop executes normally producing blocks 1–3, Figure 5. Once
the instructions in the blocks are analyzed the blocks can be co-
alesced together so that future iterations execute with minimal
latency. Note from line 16, Figure 5 that the BCXE gets con-
trol once again after the loop has been executed without any
intervention.
Cobra supports block-coalescing for self-modifying code
by employing a subtle technique involving virtual memory.
The idea is to set the memory page attributes of the executing
code-streams to read-only. Thus, when a write occurs to such
code regions due to self-modiﬁcation, Cobra’s block-monitor
gets control and the blocks corresponding to such code regions
are purged and re-created subsequently — a process we call
block-purging.
4.4. Framework API
Anaylsis tools that employ Cobra are usually written in
C/C++ using the framework API. The API is easy-to-use and
is designed to be platform independent whenever possible al-
lowing tool code to be re-usable while allowing them to acess
platform speciﬁc details when necessary. In Figure 6, we list a
partial code of a plugin for WiLDCAT, our prototype malware
analysis environment employing Cobra. The plugin is speciﬁc
to the analysis of the W32/Ratos trojan and its variants and aids
in gleaning information about the malware internals.
--- w32ratos_plugin.c ---
#include 
#include 
...
// main function for a plugin under WiLDCAT
void plugin_main(){
  ...
  spike_init(); //initialize SPiKE
  cobra_init(); //initialize Cobra
  ...
  //establish overlay point
  addr1= spike_addr("ntoskrnl.exe", "KiSwitchContext");
  spike_insertprobe(addr1, overlaypoint);
  ...
}
...
void actionhandler(ACTIONINFO *a){
  ...
  //process desired event
  switch(a->eventtype){
    case EVENT_IDTWRITE: //write to IDT
      ...   
      //new overlay point on single-step handler
      spike_insertprobe(a->eventparam[0], overlaysshandler);
  ... 
}
...
void overlaypoint(DRIFTERINFO *d){
  ACTIONCHAIN ac.
  ...
  //select events to be processed
  cobra_action(ac, AC_BLOCKCREATE, actionhandler);
  cobra_action(ac, AC_IDTREAD | AC_IDTWRITE, actionhandler);
  ...
  //start localized-execution at overlay point
  spike_cleanupstack(&d);
  cobra_start(d->origfunc, &release, ac);
release:
  spike_longjmp(&d); //resume normal execution
}
...
Figure 6. W32/Ratos Plugin for WiLDCAT, a tool
employing Cobra
The main interface to Cobra is provided in the form of four
APIs: cobra init, cobra action, cobra start and cobra comm.
As seen from Figure 6, an analysis tool using Cobra, ﬁrst ini-
tializes the framework from within its main routine using the
cobra init API. The analysis tool also initializes support frame-
works used by Cobra such as VAMPiRE [50] and/or SPiKE
[51] at this stage and establishes the ﬁrst overlay point using
their API (in our example in Figure 6, SPiKE is used to setup
an overlay point on KiSwitchContext, a Windows internal ker-
nel function). When the overlay point gets control, the tool uses
the cobra action API to setup callbacks for various events to
be handled once localized-executions begin. This is shown in
Figure 6 where events for IDT access (AC IDTREAD and
AC IDTWRITE) and block creation (AC BLOCKCREATE)
are selected. With Cobra, a single callback can handle multiple
events. Finally, the analysis tool invokes the cobra start API to
start localized-executions for the desired analysis range. In our
example in Figure 6, localized-executions being at the param-
eter to the KiSwitchContext function which is the thread ad-
dress the OS switches context to. This parameter is retrieved
from the DRIFTERINFO structure for the instrument under
SPiKE [51]. The release point in the example is the code la-
bel release and is the point where the thread returns. A point
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:50:44 UTC from IEEE Xplore.  Restrictions apply. 
to be noted is that most kernel-mode threads never return, but
the establishing such a release point ensures that the frame-
work stops localized-executions in case the thread returns.
During block execution, Cobra invokes the callback (action-
handler in Figure 6) when the desired events occur. This is
in the form of a single parameter — an ACTIONINFO struc-
ture — to the callback. Among other ﬁelds, the structure con-
tains the event-type, the event parameters and a pointer to a
buffer containing the instructions for the current block. The
callback can then take further steps to process the desired