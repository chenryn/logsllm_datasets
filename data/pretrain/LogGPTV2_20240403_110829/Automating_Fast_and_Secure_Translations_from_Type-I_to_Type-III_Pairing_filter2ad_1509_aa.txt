title:Automating Fast and Secure Translations from Type-I to Type-III Pairing
Schemes
author:Joseph A. Akinyele and
Christina Garman and
Susan Hohenberger
Automating Fast and Secure Translations from
Type-I to Type-III Pairing Schemes
Joseph A. Akinyele∗
Christina Garman†
Susan Hohenberger‡
Johns Hopkins University
Johns Hopkins University
Johns Hopkins University
PI:EMAIL
PI:EMAIL
PI:EMAIL
August 13, 2015
Abstract
Pairing-based cryptography has exploded over the last decade, as this algebraic setting oﬀers
good functionality and eﬃciency. However, there is a huge security gap between how schemes
are usually analyzed in the academic literature and how they are typically implemented. The
issue at play is that there exist multiple types of pairings: Type-I called “symmetric” is typically
how schemes are presented and proven secure in the literature, because it is simpler and the
complexity assumptions can be weaker; however, Type-III called “asymmetric” is typically the
most eﬃcient choice for an implementation in terms of bandwidth and computation time.
There are two main complexities when moving from one pairing type to another. First, the
change in algebraic setting invalidates the original security proof. Second, there are usually
multiple (possibly thousands) of ways to translate from a Type-I to a Type-III scheme, and the
“best” translation may depend on the application.
Our contribution is the design, development and evaluation of a new software tool, Auto-
Group+, that automatically translates from Type-I to Type-III pairings. The output of Au-
toGroup+ is: (1) “secure” provided the input is “secure” and (2) optimal based on the user’s
eﬃciency constraints (excluding software and run-time errors). Prior automation work for pair-
ings was either not guaranteed to be secure or only partially automated and impractically slow.
This work addresses the pairing security gap by realizing a fast and secure translation tool.
∗Supported by Zeutro, LLC and the Oﬃce of Naval Research under contract N00014-14-1-0333.
†Supported by the Oﬃce of Naval Research under contract N00014-14-1-0333.
‡Supported by the National Science Foundation CNS-1228443 and CNS-1414023; the Oﬃce of Naval Research
under contract N00014-14-1-0333, and a Microsoft Faculty Fellowship.
i
Contents
1 Introduction
1.1 Prior Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2 Background
2.1 Pairings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2 The Z3 Satisﬁability Modulo Theories (SMT) Solver . . . . . . . . . . . . . . . . . .
2.3 A Scheme Description Language (SDL) and Toolchain . . . . . . . . . . . . . . . . .
1
3
4
4
5
5
3 The AutoGroup+ System
5
5
3.1 How It Works . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Step 1: Generating Computer-Readable Inputs . . . . . . . . . . . . . . . . .
6
8
Step 2: Extracting Algebraic Dependencies
. . . . . . . . . . . . . . . . . . .
8
Step 3: Merge Dependency Graphs . . . . . . . . . . . . . . . . . . . . . . . .
Step 4: Assign Variables using the SMT Solver . . . . . . . . . . . . . . . . .
8
Step 5: Search for Optimal Solution . . . . . . . . . . . . . . . . . . . . . . .
9
Step 6: Evaluate and Process the Solution . . . . . . . . . . . . . . . . . . . . 10
3.2 Analysis of AutoGroup+ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
3.1.1
3.1.2
3.1.3
3.1.4
3.1.5
3.1.6
4 An Automation Example with BB-HIBE
12
5 AutoGroup+: Experimental Evaluation
15
5.1 Comparison with ACSC/Charm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
5.2 Comparison with Abe et al.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
5.3 Comparison with AutoGroup . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
5.4 Comparison with manual translations
. . . . . . . . . . . . . . . . . . . . . . . . . . 20
6 Conclusions
7 Acknowledgments
A Current Eﬃciency Numbers for Type-I and Type-III Pairings
21
21
22
B SDL Descriptions for Section 4
23
B.1 SDL as Input . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
B.2 Translated Scheme and Assumption SDL Descriptions . . . . . . . . . . . . . . . . . 29
C Camenisch-Lysyanskaya Signature Scheme
31
ii
1
Introduction
Automation is increasingly being explored as a means of assisting in the design or implementation
of a cryptographic scheme. The beneﬁts of using computer assistance include speed, accuracy, and
cost.
Recently, automation for pairing (also called bilinear) cryptographic constructions (e.g., [AGHP12,
AGH13, AGOT14, BFF+14]) has been under exploration. Since the seminal work of Boneh and
Franklin [BF01], interest in pairings is strong: they have become a staple at top cryptography and
security conferences, the open-source Charm library has been downloaded thousands of times world-
wide and recently pairing-commercializer Voltage Security was acquired by a major US company
(HP) [Kri15].
Pairings are algebraic groups with special properties (see Section 2.1), which are often employed
for their functionality and eﬃciency. There are diﬀerent types of pairings: Type-I called “symmet-
ric” is typically how schemes are presented and proven secure in the literature, because it is simpler
and the complexity assumptions can be weaker; however, Type-III called “asymmetric” is typically
the most eﬃcient choice for an implementation in terms of bandwidth and computation time.
Unfortunately, translating a Type-I scheme into the Type-III scheme is complicated. First, there
may be thousands of diﬀerent Type-III translations of a Type-I scheme and the “best” translation
may depend on the application. For instance, one translation might optimize ciphertext size while
another oﬀers the fastest decryption time. Second, each new translation requires a new proof under
Type-III assumptions. Exploring and analyzing all possible translations is clearly a great burden
on a human cryptographer. Indeed a small subset of manual translations of a scheme or particular
set of schemes is regarded as a publishable result in its own right, e.g., [RCS12, CLL+13, CLL+14].
Given this translation hurdle, common practice today is to analyze a Type-I scheme, but then
use ad-hoc means to derive a Type-III translation that is unproven and possibly non-optimal. The
goal of this work is to address this problem by covering new ground in cryptographic automation.
Our Contribution: The AutoGroup+ Tool. Our primary contribution is the design, devel-
opment, and performance evaluation of a new publicly-available1 tool, AutoGroup+, that auto-
matically translates pairing schemes from Type-I to Type-III. The output of AutoGroup+ is: (1)
“secure” provided the input is “secure” (see Section 3.2) and (2) optimal based on the user’s ef-
ﬁciency constraints (see Section 3.1.5).2 The input is a computer-readable format of the Type-I
construction, metadata about its security analysis, and user-speciﬁed eﬃciency constraints. The
output is a translated Type-III construction (in text, C++, Python, or LATEX) with metadata about
its security analysis. (See Figure 1.)
The audience for this tool is: (1) anyone wanting to implement a pairing construction, and (2)
pairing construction designers. We highlight some features.
New Scheme Description Language (SDL) Database. The input to AutoGroup+ requires a computer-
readable format of the Type-I construction, the Type-I complexity assumption(s), and the Type-I
security proof. It was a challenge to create a means of translating human-written security proofs
into SDL. We focused on a common type of proof exhibiting a certain type of black-box reduction.3
We created a new SDL structure for representing assumptions and reductions of this type that
1AutoGroup+ can be downloaded at https://github.com/jhuisi/auto-tools.
2These claims regard the cryptographic transformation and exclude any software or run-time errors.
3The theoretical translation security results of [AGOT14] on which we will base our security are also limited to
this class of proof.
may be of independent interest. Additionally, we did the tedious work of carefully transcribing
ﬁve assumptions, eight reductions and improving the SDLs for nine popular constructions (from
[AGH13]). (See Appendix B for an example of a simple case.) One transcribed, however, these
SDL ﬁles can be reused. We believe the future of cryptographic automation research will involve
processing the assumptions and proofs; thus our database is made public as a testbed for future
automation research.
Speed of Tool. AutoGroup+ took less than 21 seconds to process any of the test set, which included
seven simple schemes (16 or less solutions), three medium schemes (256 to 512 solutions), and three
complex schemes (1024 to 2048 solutions). (The preference for simple schemes was to compare
with prior work.) This measures from SDL input to a C++ (or alternative) output. Speed is very
important here for usage, because we anticipate that designers may iteratively use this tool like a
compiler and implementors may want to try out many diﬀerent eﬃciency optimizations.
In contrast, in CRYPTO 2014, Abe, Groth, Ohkubo and Tango [AGOT14] laid out an elegant
theoretical framework for doing pairing translations in four steps. It left open the issue of whether
their framework was practical to implement for a few reasons: (1) they automated only one of four
steps (code not released), (2) their algorithm for this step was exponential time, and (3) they tested
it on only simple and medium schemes, but their medium scheme took over 1.75 hours for one step.
Our fully automated translation of that scheme took 6.5 seconds, which is much more in line with
the “compiler”-like usage we anticipate.
We attribute our drastic eﬃciency improvement in part to our use of the Z3 SMT Solver. As
described in Section 3, we encode the translation of the scheme, its assumption(s) and its reduction
as a constraint-satisfaction problem and then use Z3 to quickly ﬁnd the satisfying set of solutions.
New Results. We evaluated AutoGroup+ on 9 distinct constructions (plus 4 additional variations
of one scheme), with various optimization priorities, for 48 bandwidth-optimizing translations. In
Figure 8, we report the sizes compared to the symmetric case, which are signiﬁcantly smaller. In
Figure 9, we report on over 140 timing experiments resulting from the translations. Due both to
the asymmetric setting and AutoGroup+’s optimizations, in most cases, the running times were
reduced to less than 10% of the symmetric case. In Figure 10, we report on the eﬀect that diﬀerent
levels of complexity have on translation time for a single scheme.
In Section 5, we compare the performance of AutoGroup+ to prior automation works, published
manual translations, and translations existing as source code in the Advanced Crypto Software
Collection [Con] and Charm library [AGM+13]. We discovered a few things. In fourteen points of
comparison with AutoGroup, AutoGroup+ matches those solutions and provides a security validation
and new assumptions, adding only a few additional seconds of running time. In three points of
comparison with Abe et al. [AGOT14] and subsequent personal communications [AGOT15], our
translated results match.
In the ﬁve points of overlap with ACSC and Charm, we are able to conﬁrm the security and
ciphertext-size optimality of one broadcast encryption and one hierarchical identity-based encryp-
tion implementation. We are also able to conﬁrm the security of two signature implementations,
although only one is signature-size optimal. These conﬁrmations are new results. Our tool was
able to conﬁrm the ciphertext-size optimality, but not the security of the Charm implementation
of Dual System Encryption [Wat09] (meaning it may not be secure). That implementation made
changes to the keys outside the scope of the translations here or in [AGH13, AGOT14]. However,
our tool did ﬁnd a secure translation with the same ciphertext-size.
Overall, our tests show that the tool can produce high-quality solutions in just seconds, demon-
2
strating that pairing translations can be practically and securely performed by computers.
1.1 Prior Work
The desirability of translating Type-I to Type-III pairings is well documented. First, this is an
exercise that cryptographers are still actively doing by hand. In PKC 2012, Ramanna, Chatter-
jee and Sarkar [RCS12] nicely translated the dual system encryption scheme of Waters [Wat09]
from the Type-I pairing setting to a number of diﬀerent Type-III possibilities. Recently, Chen,
Lim, Ling, Wang and Wee [CLL+13, CLL+14] presented an elegant semi-general framework for
(re-)constructing various IBE, Inner-Product Encryption and Key-Policy Functional Encryption
schemes in the Type-III setting, assuming the SXDH assumption holds.4 These works go into
deeper creative detail (changing the scheme or adding assumptions) than our automator, and thus
mainly get better results, but then, these works appear to have taken signiﬁcant human resources.
In contrast, our work oﬀers a computerized translation as a starting point.
The Advanced Crypto Software Collection (ACSC) [Con], including the Charm library [AGM+13],
contains many Type-III implementations of schemes that were published and analyzed in the Type-
I format. To the best of our knowledge, there is no formal analysis of these converted schemes and
thus also no guarantees that the translations are secure or optimal eﬃciency-wise for a user’s spe-
ciﬁc application. (We remark that ACSC/Charm makes no claims that they are secure or optimal.)
The public Github records for Charm show that it has been downloaded thousands of times; thus,
it would be prudent to verify these implementations. (See our results on this in Section 5.)
In ACM CCS 2013, Akinyele, Green and Hohenberger [AGH13] presented a publicly-available
tool called AutoGroup, which oﬀered an automated translation from Type-I to Type-III pairing
schemes. This work employed sophisticated tools, such as the Z3 Satisﬁability Modulo Theories
(SMT) solver produced by Microsoft Research (see Section 2), to quickly ﬁnd a set of possible
assignments of elements into G1 or G2. There was not, however, any guarantee that the resulting
Indeed, Akinyele et al. [AGH13] explicitly framed their results as
translation remained secure.
follows: translation has two parts: (1) the search for an eﬃcient translation, and (2) a security
analysis of it. They automated the ﬁrst part and left the security analysis to a human cryptographer.
Since they made their source code public, we used it as a starting point and thus named our work
after theirs.
While using AutoGroup is certainly faster than a completely manual approach, the lack of a
security guarantee is a real drawback. At that time, there was simply no established theory on how
to generalize these translations.
Fortunately, in CRYPTO 2014, Abe, Groth, Ohkubo and Tango [AGOT14] pushed the theory
forward in this area. They elegantly formalized the notion that if certain dependencies from the
Type-I complexity assumption(s) and the reduction in the security analysis were added to the
dependencies imposed by the scheme itself, then there was a generic way to reason about the
security of the translated scheme. Their main theorem, which we will later use, can informally be
stated as:
Theorem 1.1 (Informal [AGOT14]). Following the conversion method of [AGOT14], if the Type-I
scheme is correct and secure in the generic Type-I group model, then its converted Type-III scheme
is correct and secure in the generic Type-III group model.
4Informally, the SXDH assumption asserts that in a Type-III pairing group, there exist no eﬃcient isomorphisms
from G1 to G2 or from G2 to G1.
3
There are four steps in their translation: (1) build a dependency graph between the group
elements for each algorithm in the construction, the complexity assumption(s) and the security
reduction (In the graph, elements are nodes and a directed edge goes from g to h if h is derived
from g, such as h = gx.), (2) merge all graphs into a single graph, (3) split this graph into two
graphs (where elements of the ﬁrst graph will be assigned to G1 and elements of the second assigned
to G2), and (4) derive the converted scheme.
For the four schemes tested in [AGOT14], steps (1), (2), and (4) were done by hand. The
algorithm for step (3) was exponential in two variables5 and the Java program to handle step (3)
reported taking 1.75 hours on a medium scheme. Thus, this is a great theory advance, but it left
open the question of whether the entire translation could be eﬃciently automated as a “real-time”
tool.
AutoGroup+ in a Nutshell. In short, prior work admitted a public tool that is fast, but possibly
insecure [AGH13], and a cryptographic framework that is slow, but secure [AGOT14]. Our goal was
to realize the best of both worlds. Even though the implementations diﬀered, we discovered that
both works began by tracing generator to pairing dependencies, where [AGH13] did this bottom up
and [AGOT14] used a top down approach. Since both of these representations can be helpful for
diﬀerent optimizations, AutoGroup+ does both. It also traces these dependencies for the complexity
assumptions and reductions. The pairings and hash variables in the combined dependency graph
are translated into a formula and constraints, and then fed into a SMT solver. The output set is
then eﬃciently searched for an optimal solution using the SMT solver again, then veriﬁed as a valid
graph split (as formalized in [AGOT14]). Finally, if the split is valid, then a converted scheme and
complexity assumption(s) are output.
2 Background
2.1 Pairings
Let G1, G2 and GT be groups of prime order p. A map e : G1 × G2 → GT is an admissible pairing
(also called a bilinear map) if it satisﬁes the following three properties:
1. Bilinearity: for all g ∈ G1, h ∈ G2, and a, b ∈ Zp, it holds that e(ga, hb) = e(gb, ha) = e(g, h)ab.
2. Non-degeneracy: if g and h are generators of G1 and G2, resp., then e(g, h) is a generator of
3. Eﬃciency: there exists an eﬃcient method that given any g ∈ G1 and h ∈ G2, computes
GT .
e(g, h).
A pairing generator is an algorithm that on input a security parameter 1λ, outputs the param-
eters for a pairing group (p, g, h, G1, G2, GT , e) such that p is a prime in Θ(2λ), G1, G2 and GT are
groups of order p where g generates G1, h generates G2 and e : G1 × G2 → GT is an admissible
pairing.
The above pairing is called an asymmetric or Type-III pairing. This type of pairing is generally
preferred in implementations for its eﬃciency. We also consider symmetric or Type-I pairings,
where there is an eﬃcient isomorphism ψ : G1 → G2 (and vice versa) such that a symmetric map
5Their splitting algorithm runs exponentially in both the number of pairings and the bottom nodes (without
outgoing edges) of the dependency graph. Thus, scalability is a real concern.
4
is deﬁned as e : G1 × ψ(G1) → GT . We generally treat G = G1 = G2 for simplicity and write
e : G × G → GT . These types of pairings are typically preferred for presenting constructions in
the academic literature for two reasons. First, they are simpler from a presentation perspective,
requiring fewer subscripts and other notations. More importantly, they are sometimes preferred
because the underlying symmetric assumption on which the proof is based may be viewed as simpler
or weaker than the corresponding asymmetric assumption.
We include current eﬃciency numbers for Type-I and Type-III groups in Appendix A, demon-
strating the signiﬁcant advantages of the latter.
2.2 The Z3 Satisﬁability Modulo Theories (SMT) Solver
Our implementation also relies on the power of the state-of-the-art Z3 SMT solver [DMB08] de-
veloped at Microsoft Research. SMT is a generalization of boolean satisﬁability (or SAT) solving
where the goal is to decide whether solutions exist to a given logical formula. The publicly available
Z3 is one such tool that is highly eﬃcient in solving constraint satisfaction problems and used in
many diﬀerent applications.
2.3 A Scheme Description Language (SDL) and Toolchain
This work builds on the eﬀorts of prior automation works [AGHP12, AGH13] which include several
tools such as a scheme description language (or SDL), an accompanying parser for SDL, a code
generator that translates SDL schemes into executable code in either C++ or Python, and a
LATEX generator for SDL descriptions. We obtained all these prior tools from the publicly-available
AutoTools GitHub repository.6 Our code and SDL database will be made public in this repository
as well. The SDL for the constructions are the same in AutoGroup and AutoGroup+; the diﬀerence
is that the latter also includes SDL for assumptions and security reductions. Since we used the
code of AutoGroup as a starting point, we derived our tool name from it.
3 The AutoGroup+ System
As described in Section 1, AutoGroup+ is a new tool built to realize the best of both worlds
from a prior tool called AutoGroup [AGH13] (fast, but no security guarantees) and new theoretical
insights [AGOT14] (secure, but exponential time and no public tool.)
3.1 How It Works
We begin with an illustration of the AutoGroup+ system in Figure 1. This system takes in the
description of a symmetric (Type-I) pairing-based scheme S, together with metadata about its
security and user-desired eﬃciency constraints, and outputs an asymmetric (Type-III) pairing-
based translation S(cid:48), together with metadata about its security. Informally, if S was secure, then
S(cid:48) will be both secure and optimal for the constraints set by the user over the space of “basic”
translations.