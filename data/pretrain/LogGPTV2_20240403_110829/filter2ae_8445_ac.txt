    0000027a`bf2900d8  fff88000`00000002
    0000027a`bf2900e0  fff88000`00000003
    0000027a`bf2900e8  fff88000`00000004
    0000027a`bf2900f0  fff88000`00000005
    0000027a`bf2900f8  4f4f4f4f`4f4f4f4f
此时我们认识到数组的内容：从 1 到 5 的数值，作为 JS :: Value
的五个整数。我们也可以看到哪个位置的数据可能是存放的数组大小和容量，但剩下的数据很难猜到存放的是什么。
    0:000> dt JSObject
       +0x000 group_           : js::GCPtr
       +0x008 shapeOrExpando_  : Ptr64 Void
    0:000> dt js::NativeObject
       +0x000 group_           : js::GCPtr
       +0x008 shapeOrExpando_  : Ptr64 Void
       +0x010 slots_           : Ptr64 js::HeapSlot
       +0x018 elements_        : Ptr64 js::HeapSlot
    0:000> dt js::ArrayObject
       +0x000 group_           : js::GCPtr
       +0x008 shapeOrExpando_  : Ptr64 Void
       +0x010 slots_           : Ptr64 js::HeapSlot
       +0x018 elements_        : Ptr64 js::HeapSlot
JS :: ArrayObject 在 vm / ArrayObject.h 文件中定义，它是 JS :: NativeObject 类的子类（JS ::
NativeObject 子类 JS :: ShapedObject，它自然是 JSObject 的子类）。 请注意，它也基本上是每个其他
JavaScript 对象的子类，如下图所示：
SpiderMonkey 中的本地对象基本上由两个组件组成：
  * 一个形状对象，用于描述属性，所述对象的类，更多的是在下面（由字段 shapeOrExpando_ 指向）。
  * 存储元素或属性值的存储。
让我们看看对象属性如何存储在内存中。
### Shapes
如上所述，shape 对象的作用是描述对象具有的各种属性。从概念上讲，您可以将其视为某种哈希表，其中 Key 是属性名称，值是实际存储属性内容的 slot
。  
在进一步阅读之前，我建议您观看由 [@bmeurer](https://twitter.com/bmeurer "@bmeurer") 和
[@mathias](https://twitter.com/mathias "@mathias") 撰写的非常简短的演示文稿，描述如何在
JavaScript 引擎中存储属性：[JavaScript
引擎基础：形状和内联缓存](https://mathiasbynens.be/notes/shapes-ics "JavaScript
引擎基础：形状和内联缓存")。 他们清楚地解释这方面的事，它应该有助于理解接下来会发生什么，这也意味着我不需要尽可能多地介绍。  
考虑以下 JavaScript 代码：
    'use strict';
    const Address = Math.atan2;
    const A = {
        foo : 1337,
        blah : 'doar-e'
    };
    Address(A);
    const B = {
        foo : 1338,
        blah : 'sup'
    };
    Address(B);
    const C = {
        foo : 1338,
        blah : 'sup'
    };
    C.another = true;
    Address(C);
将它放在您最喜欢的调试器下面的 shell 中，以便仔细查看此 shape 对象：
    0:000> bp js!js::math_atan2
    0:000> g
    Breakpoint 0 hit
    Time Travel Position: D454:D
    js!js::math_atan2:
    00007ff7`76c9e140 56              push    rsi
    0:000> ?? vp[2].asBits_
    unsigned int64 0xfffe01fc`e637e1c0
    0:000> dt js::NativeObject 1fc`e637e1c0 shapeOrExpando_
       +0x008 shapeOrExpando_ : 0x000001fc`e63ae880 Void
    0:000> ?? ((js::shape*)0x000001fc`e63ae880)
    class js::Shape * 0x000001fc`e63ae880
       +0x000 base_            : js::GCPtr
       +0x008 propid_          : js::PreBarriered
       +0x010 immutableFlags   : 0x2000001
       +0x014 attrs            : 0x1 ''
       +0x015 mutableFlags     : 0 ''
       +0x018 parent           : js::GCPtr
       +0x020 kids             : js::KidsPointer
       +0x020 listp            : (null) 
    0:000> ?? ((js::shape*)0x000001fc`e63ae880)->propid_.value
    struct jsid
       +0x000 asBits           : 0x000001fc`e63a7e20
在实现中，JS :: Shape 描述了一个属性；它的名称和 slot 号。为了描述它们中的几个，通过父字段（和其他字段）将 shapes
链接在一起。slot 号（稍后用于查找属性内容）存储在 immutableFlags 字段的低位中。属性名称存储为 propid_ 字段中的 jsid 。  
我知道现在你面前有很多抽象的信息。但是，让我们一层一层的来分析; 从上面的 shape 开始。此 JS :: Shape 对象描述了一个属性，该值存储在
slot 号为 1（0x2000001 和 SLOT_MASK）中。为了得到它的名字，我们转储它的propid_ 字段，即
0x000001fce63a7e20 。  
什么是 jsid ？ jsid 是另一种类型的标记指针，其中类型信息这次以低三位编码。
感谢那些较低的位，我们知道这个地址指向一个字符串，它应该匹配我们的属性名称:)。
    0:000> ?? (char*)((JSString*)0x000001fc`e63a7e20)->d.inlineStorageLatin1
    char * 0x000001fc`e63a7e28
     "blah"
如上所述， shape 对象链接在一起。 如果我们转储其父级，我们希望找到描述我们的第二个属性 foo 的 shape：
    0:000> ?? ((js::shape*)0x000001fc`e63ae880)->parent.value
    class js::Shape * 0x000001fc`e63ae858
       +0x000 base_            : js::GCPtr
       +0x008 propid_          : js::PreBarriered
       +0x010 immutableFlags   : 0x2000000
       +0x014 attrs            : 0x1 ''
       +0x015 mutableFlags     : 0x2 ''
       +0x018 parent           : js::GCPtr
       +0x020 kids             : js::KidsPointer
       +0x020 listp            : 0x000001fc`e63ae880 js::GCPtr
    0:000> ?? ((js::shape*)0x000001fc`e63ae880)->parent.value->propid_.value
    struct jsid
       +0x000 asBits           : 0x000001fc`e633d700
    0:000> ?? (char*)((JSString*)0x000001fc`e633d700)->d.inlineStorageLatin1
    char * 0x000001fc`e633d708
     "foo"
按 g 继续执行并检查第二个对象是否共享相同的形状层次结构（0x000001fce63ae880）:
    0:000> g
    Breakpoint 0 hit
    Time Travel Position: D484:D
    js!js::math_atan2:
    00007ff7`76c9e140 56              push    rsi
    0:000> ?? vp[2].asBits_
    unsigned int64 0xfffe01fc`e637e1f0
    0:000> dt js::NativeObject 1fc`e637e1f0 shapeOrExpando_
       +0x008 shapeOrExpando_ : 0x000001fc`e63ae880 Void
正如预期的那样，B 确实会分享它，即使 A和 B 存储不同的属性值。 关注我们现在向 C 添加另一个属性时会发生什么？ 要查找，请最后按 g 一次：
    0:000> g
    Breakpoint 0 hit
    Time Travel Position: D493:D
    js!js::math_atan2:
    00007ff7`76c9e140 56              push    rsi
    0:000> ?? vp[2].asBits_
    union JS::Value
       +0x000 asBits_          : 0xfffe01e7`c247e1c0
    0:000> dt js::NativeObject 1fc`e637e1f0 shapeOrExpando_
       +0x008 shapeOrExpando_ : 0x000001fc`e63b10d8 Void
    0:000> ?? ((js::shape*)0x000001fc`e63b10d8)
    class js::Shape * 0x000001fc`e63b10d8
       +0x000 base_            : js::GCPtr
       +0x008 propid_          : js::PreBarriered
       +0x010 immutableFlags   : 0x2000002
       +0x014 attrs            : 0x1 ''
       +0x015 mutableFlags     : 0 ''
       +0x018 parent           : js::GCPtr
       +0x020 kids             : js::KidsPointer
       +0x020 listp            : (null) 
    0:000> ?? ((js::shape*)0x000001fc`e63b10d8)->propid_.value
    struct jsid
       +0x000 asBits           : 0x000001fc`e63a7e60
    0:000> ?? (char*)((JSString*)0x000001fc`e63a7e60)->d.inlineStorageLatin1
    char * 0x000001fc`e63a7e68
     "another"
    0:000> ?? ((js::shape*)0x000001fc`e63b10d8)->parent.value
    class js::Shape * 0x000001fc`e63ae880
新的 JS :: Shape 被分配（0x000001e7c24b1150），其父级是前一组形状（0x000001e7c24b1150）。
有点像在链表中添加节点。
### Slots
在上一节中，我们讨论了很多关于属性名称如何存储在内存中的问题。 那属性的值在哪里呢？
为了回答这个问题，我们抛出了我们在调试器中获得的先前 TTD 跟踪，并在第一次调用 Math.atan2 时返回：
    Breakpoint 0 hit
    Time Travel Position: D454:D
    js!js::math_atan2:
    00007ff7`76c9e140 56              push    rsi
    0:000> ?? vp[2].asBits_
    unsigned int64 0xfffe01fc`e637e1c0
因为我们已经 dump 了描述 foo 和 blah 属性的 js :: Shape 对象的过程，所以我们知道它们的属性值分别存储在slot 0 和
slot 1 中。 为了查看这些，我们只是在 js :: NativeObject 之后 dump 内存：
    0:000> ?? vp[2].asBits_
    unsigned int64 0xfffe01fc`e637e1c0
    0:000> dt js::NativeObject 1fce637e1c0
       +0x000 group_           : js::GCPtr
       +0x008 shapeOrExpando_  : 0x000001fc`e63ae880 Void
       +0x010 slots_           : (null) 
       +0x018 elements_        : 0x00007ff7`7707dac0 js::HeapSlot
    0:000> dqs 1fc`e637e1c0
    000001fc`e637e1c0  000001fc`e637a520
    000001fc`e637e1c8  000001fc`e63ae880
    000001fc`e637e1d0  00000000`00000000
    000001fc`e637e1d8  00007ff7`7707dac0 js!emptyElementsHeader+0x10
    000001fc`e637e1e0  fff88000`00000539  ?? (char*)((JSString*)0x1fce63a7e40)->d.inlineStorageLatin1
    char * 0x000001fc`e63a7e48
     "doar-e"
下面是一个描述对象层次结构的图表，以清除任何可能的混淆：
到目前，我想要描述的内容都已经被涵盖的差不多了，它应该足以帮助我们理解接下来的内容。你可以使用此背景检查大多数 JavaScript 对象。我遇到的唯一
“odd-balls” 类型是存储长度属性的 JavaScript 数组，例如在 js :: ObjectElements 对象中; 但这就是它。
    0:000> dt js::ObjectElements
       +0x000 flags            : Uint4B
       +0x004 initializedLength : Uint4B
       +0x008 capacity         : Uint4B
       +0x00c length           : Uint4B