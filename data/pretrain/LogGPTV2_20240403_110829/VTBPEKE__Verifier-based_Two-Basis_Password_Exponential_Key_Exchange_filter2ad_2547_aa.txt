title:VTBPEKE: Verifier-based Two-Basis Password Exponential Key Exchange
author:David Pointcheval and
Guilin Wang
This extended abstract appeared in
Proceedings of the 2017 ACM Symposium on Information, computer and communications security (AsiaCCS ‚Äô17)
(April 4‚Äì6, 2017, Abu Dhabi, United Arab Emirates), ACM Press. DOI: 10.1145/3052973.3053026
David Pointcheval1 and Guilin Wang2
1 CNRS, INRIA, and ENS/PSL Research University, Paris, France
2 Shield Lab, Huawei, #03-31/32, 20 Science Park Road, Singapore 117674
Abstract PAKE protocols, for Password-Authenticated Key Exchange, enable two parties to estab-
lish a shared cryptographically strong key over an insecure network using a short common secret
as authentication means. After the seminal work by Bellovin and Merritt, with the famous EKE,
for Encrypted Key Exchange, various settings and security notions have been deÔ¨Åned, and many
protocols have been proposed.
In this paper, we revisit the promising SPEKE, for Simple Password Exponential Key Exchange,
proposed by Jablon. The only known security analysis works in the random oracle model under
the CDH assumption, but in the multiplicative groups of Ô¨Ånite Ô¨Åelds only (subgroups of Z‚àó
p), which
means the use of large elements and so huge communications and computations. Our new instanti-
ation (TBPEKE, for Two-Basis Password Exponential Key Exchange) applies to any group, and our
security analysis requires a DLin-like assumption to hold. In particular, one can use elliptic curves,
which leads to a better eÔ¨Éciency, at both the communication and computation levels. We addition-
ally consider server corruptions, which immediately leak all the passwords to the adversary with
symmetric PAKE. We thus study an asymmetric variant, also known as VPAKE, for VeriÔ¨Åer-based
Password Authenticated Key Exchange. We then propose a veriÔ¨Åer-based variant of TBPEKE, the
so-called VTBPEKE, which is also quite eÔ¨Écient, and resistant to server-compromise.
Keywords: Password-authenticated key exchange; server compromise; dictionary attacks
2
1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2
1.1 Dictionary Attacks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3
1.2 Previous Constructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5
1.3 Objectives and Contributions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5
2 Security Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6
3 Variants of SPEKE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6
3.1 A Naive Construction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6
3.2 A Secure Construction: TBPEKE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7
4 Security Analysis of TBPEKE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7
4.1 Assumptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9
4.2 Security Results for TBPEKE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9
5 VTBPEKE: VeriÔ¨Åer-based TBPEKE Protocol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.1 Password Hashing Scheme . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9
5.2 Our Password Hashing Scheme . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
5.3 Description of VTBPEKE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
6 Security Analysis of VTBPEKE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
6.1 Discussions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
6.2 Forward-Secrecy & VeriÔ¨Åer-Based . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
6.3 Security Proof . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
7 Parameters and EÔ¨Éciency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
8 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
c(cid:13) Authors 2017. Permission to make digital or hard copies of all or part of this work for personal or classroom
use is granted without fee provided that copies are not made or distributed for proÔ¨Åt or commercial advantage
and that copies bear this notice and the full citation on the Ô¨Årst page. Copyrights for components of this work
owned by others than the author(s) must be honored. Abstracting with credit is permitted. To copy otherwise,
or republish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission and/or a fee. Request
permissions from permissions@acm.org.
V
T
B
P
E
K
E
:
V
e
r
i
f
i
e
r
-
b
a
s
e
d
T
w
o
-
B
a
s
i
s
P
a
s
s
w
o
r
d
E
x
p
o
n
e
n
t
i
a
l
K
e
y
E
x
c
h
a
n
g
e
Global parameters: G = (cid:104)g(cid:105) of prime order p, U, V R‚Üê G, and H a hash function onto {0, 1}(cid:96)
A pw
B pw
2
x R‚Üê Z‚àó
accept ‚Üê false
p, X ‚Üê gx, X(cid:48) ‚Üê X √ó U pw
Y ‚Üê Y (cid:48)/V pw
accept ‚Üê true
Z ‚Üê Y x
accept ‚Üê false
- X ‚Üê X(cid:48)/U pw
p, Y ‚Üê gy, Y (cid:48) ‚Üê Y √ó V pw
(cid:48)
A(cid:107)X
(cid:48)
Y

y R‚Üê Z‚àó
accept ‚Üê true
Z ‚Üê X y
sk ‚Üê H(A(cid:107)B(cid:107)X(cid:48)(cid:107)Y (cid:48)(cid:107)Z)
Figure 1. Simple Password Authenticated Key Exchange
1 Introduction
1.1 Dictionary Attacks
Key exchange protocols are cryptographic primitives used to provide several users (two or more),
communicating over a public unreliable channel, with a secure session key. This allows estab-
lishment of virtual secure channels (i.e., private and authenticated) in any network, even under
the control of adversaries. This is thus one of the main practical applications of cryptography:
it can guarantee privacy to any user, whatever the architectures are and the providers do.
Bellare and Rogaway gave the Ô¨Årst foundations of authenticated key exchange in [10,11],
but password-based authentication requires more work: in this setting, where the authentication
means is a short secret chosen from a small set of possible values (e.g., a four-digit PIN), the
brute-force method, which consists in trying all the possible values in the dictionary, succeeds
after a rather small number of attempts. This attack is called on-line dictionary attack and is
unavoidable, since the adversary just has to check whether the authentication with a tentative
password succeeds or not. But its damages can be limited by a policy that invalidates or blocks
an account, and thus the use of a password, after a Ô¨Åxed number of failures (which is always
possible in the two-party setting, but not necessarily in some other settings where such failures
can be undetectable to the authenticator [26]). The security goal when studying a PAKE protocol
is to show that this on-line dictionary attack is the best one can do, and namely that no one
can guess the correct password without a linear number of interactions.
On the other hand, the classical symmetric PAKE setting, as introduced by Bellovin and
Merritt [12] in 1992, with the famous Encrypted Key Exchange protocol (EKE), requires the
server to know all the passwords in clear, which can be dramatic in case of intrusion into the
server. With the increase of password-controlled accesses, users often use related passwords (if
not the same) for many providers, which ampliÔ¨Åes the damages of a hack of a single server
to many services. To overcome this issue, Bellovin and Merritt proposed the Augmented EKE
protocol [13], where the server just stores a means, called a veriÔ¨Åer, to verify that the client used
the correct password, but not the password itself. In concrete systems, the veriÔ¨Åer is a hash of
the password with a salt. This temporarily limits the impact of leakage of information on the
server side, since it forces the adversary to spend a lot of time to learn many passwords. This
should give enough time for letting the users renew (all) their passwords.
Such an asymmetric PAKE is also known as VPAKE, for VeriÔ¨Åable Password-Authenticated
Key Exchange. In addition to the basic security when there is no server compromise, extract-
ing the password from the veriÔ¨Åer in case of database corruption should take a computation
time linear in the number of possible passwords, for each user, when passwords are uniformly
distributed, without any speed-up taking advantage of the large number of veriÔ¨Åers. This cor-
responds to the time of the trivial oÔ¨Ä-line dictionary attack, which we cannot avoid but which
should be the best: for each veriÔ¨Åer, the adversary tries all the possible passwords. Of course, in
3
such a case, the number of possible passwords should not be too small, and the time to check
a possible candidate to a veriÔ¨Åer should not be too short either (hence the use of slow hash
functions).
Indeed, the same way as the on-line dictionary attack cannot be avoided but is proven to be
the best possible attack against a PAKE (or a VPAKE, before a server compromise), an oÔ¨Ä-line
dictionary attack cannot be avoided in case of server compromise, and one has to prove any new
password-recovery is linear in the size of the dictionary after a server compromise.
As already mentioned, veriÔ¨Åers are usually hash values or transformations V = H(s, pw ) of
the private passwords pw with public extra data s, called salt. For each user, the server thus
stores the pair (s, V ). The salt aims at binding an exhaustive search on the passwords to a
speciÔ¨Åc user, or at least to a small fraction with the same salt. Indeed, after the compromise
of a server, or even several servers, the adversary gets access to many veriÔ¨Åers for many users,
together with any information useful to verify the passwords. If there are many collisions among
the salt values, the adversary can focus on the salt value s‚àó that corresponds to the highest
number of veriÔ¨Åers V ‚àó
k . Then, the exhaustive search on the password, which consists in
computing H(pw , s‚àó) for all the passwords, will fall on one of the V ‚àó
i ‚Äôs with probability k/N
for each test, where N is the size of the dictionary and k the number of veriÔ¨Åers for the tested
salt value s‚àó. The smaller k is, the safer is the system. Hence, one has to limit the collusions
on the salt values: in practice, this is either a random value, but then it must be large enough
to avoid collisions (birthday paradox), or server-user identities, which exclude collisions, have
compact representations, and can even be known in advance by the user. This might depend on
the practical scenario.
1 , . . . , V ‚àó
1.2 Previous Constructions
Bellovin and Merritt [12] proposed the Ô¨Årst scheme, the so-called Encrypted Key Exchange
(EKE), which is essentially a DiÔ¨Ée-Hellman key exchange, where the two Ô¨Çows are encrypted
with a symmetric encryption scheme under the password as the symmetric key. A Ô¨Årst security
analysis has been provided in the indistinguishability-based (or BPR) framework, in the ideal-
cipher model [8], followed by several proofs of variants [18,19,6], trying to reduce the need of
ideal models but still keeping the initial eÔ¨Éciency of EKE. EKE has also been studied in the
simulation-based framework, in the random-oracle model [17], followed by studies in the UC
framework [3] with security against adaptive corruptions, but still in ideal models.
The ‚ÄúSimple Password-Authenticated Key Exchange‚Äù protocols (SPAKE), proposed by Ab-