users are considered distant, the parameters (e.g., ğœ) were chosen
by conducting experiments to obtain appropriate accuracy.
6.2.2 Results on IrisCode and FVC2004. We first investigate the per-
formance of our BAKE protocols on two realistic datasets. For iris,
we transform an IrisCode into 4 cases: a 16-dimensional vector, a 32-
dimensional vector, a 64-dimensional vector, and a 128-dimensional
vector. For fingerprint, we use four databases from the Third In-
ternational Fingerprint Verification Competition (FVC2004) [36],
in which DB1 and DB2 involve a similar size of fingerprint vector
set, while the distorted DB3 and synthetic DB4 are extracted more
noisy points, leading to big size ğ‘›. The fingerprint images are pre-
processed with the OpenCV library and the minutiae points are
Session 10B: Crypto and Protocol Security CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2628PubGen
Enc
Dec
PubGen
Enc
Dec
60
40
20
80
100
140
PubGen 54.057 55.956 55.188 55.013 54.515 55.376 56.227
Enc
111.12 110.27 110.59 110.69 109.58 111.45 112.45
Dec
65.032 74.135 83.149 91.796 102.10 111.90 120.22
The Sizee off Biometricc Vector
120
100 200 300 400 500 600 700 800 900 100
0
81
110 110 112 112 110 110 110 111 110 110
102 155 222 276 369 541 561 664 783 793
58
77
56
60
62
68
68
72
PubGen 55
Enc
Dec
The Sizee off Biometricc Vector
Figure 6: Running time of the AFEM
construction for biometric vector, as
the size of biometric vector increases
from 20 to 140.
Figure 7: Running time of the AFEM
construction for biometric vector, as
the size of biometric vector increases
from 100 to 1000.
Figure 8: Running time of different op-
erations in Dec for biometric vector, as
the size of biometric vector increases
from 20 to 1000.
PubGen
Enc
Dec
PubGen
Enc
Dec
)
s
m
i
(
ee
m
T
g
n
i
n
n
u
R
800
700
600
500
400
300
200
100
0
Decoding Algorithm
ElGamal Decryption
20 100 200 300 400 500 600 700 800 900 1000
The Sizee off Biometricc Vector
)
s
m
i
(
ee
m
T
g
n
i
n
n
u
R
4500
4000
3500
3000
2500
2000
1500
1000
500
0
VSS.ShareGen
Generating Points
Polynomial Interpolation
20 100 200 300 400 500 600 700 800 900 1000
The Sizee off Biometricc Vectorr Set
140
120
100
80
60
40
)
s
m
i
(
ee
m
T
g
n
i
n
n
u
R
700
600
500
400
300
200
100
0
)
s
m
i
(
ee
m
T
g
n
i
n
n
u
R
1000
900
800
700
600
500
400
300
200
100
0
)
s
m
i
(
ee
m
T
g
n
i
n
n
u
R
35
30
25
20
15
10
5
0
i
)
s
(
ee
m
T
g
n
i
n
n
u
R
60
40
20
140
PubGen 6.359 12.723 19.026 25.142 31.630 37.700 43.677
Enc
62.001 78.914 98.905 124.91 154.69 189.50 223.99
Dec
22.619 65.144 126.82 211.93 320.00 446.11 611.70
100
120
80
100 200 300 400 500 600 700 800 900 100
0
PubGen 0.03 0.06 0.09 0.13 0.16 0.19 0.22 0.25 0.28 0.31
Enc
0.15 0.35 0.62 0.99 1.45 2.02 2.69 3.49 4.37 5.35
Dec
0.32 1.25 2.74 4.79 7.24 10.4 14.2 18.7 23.5 29.2
The Sizee off Biometricc Vectorr Set
The Sizee off Biometricc Vectorr Set
Figure 9: Running time of the AFEM
construction for biometric vector set,
as the size of biometric vector set in-
creases from 20 to 140.
Figure 10: Running time of the AFEM
construction for biometric vector set,
as the size of biometric vector set in-
creases from 100 to 1000.
Figure 11: Running time of different
operations in Enc for biometric vector
set, as the size of biometric vector set
increases from 20 to 1000.
extracted as coordinate values. For Algorithm 2, we choose ğœ‡ = 4,
i.e., each fingerprint vector is composed of 50 4-bit values.
The computation cost of each algorithm in our BAKE protocols
is shown in Table 2. Our protocol on IrisCode is more efficient
than that on FVC2004, since there is only one ElGamal-like oper-
ation in the AFEM construction for biometric vector while there
are ğ‘› ElGamal-like operations in the AFEM construction for bio-
metric vector set. However, both protocols are suitable for practical
applications from the view of computation overhead.
The communication cost consists of transmitting the public key
ğ‘ğ‘˜ in the KeyGen phase and transmitting the encapsulated message
ğ‘ in the AKE phase, as shown in Table 3. Again, we can conclude
that the two protocols are efficient in practice, even for the resource-
limited network, in terms of the communication overhead.
Further Results. We then investigate the computation cost
6.2.3
of our BAKE protocols with the size of biometric secret keys.
The time consumption of algorithms in BAKE-1 is illustrated in
Figure 6 and Figure 7. The running time of PubGen is the smallest
and increases slowly and the curve of Enc is smooth as the size of
the biometric vector ğ‘š grows since Enc only involves an ElGamal-
like encryption operation. For Dec, the time consumption grows
substantially as ğ‘š increases and exceeds 0.5 seconds when ğ‘š =
600, which is similar to the general biometric authentication [53].
Figure 8 further depicts the detailed time consumption of Dec, in
which the decoding algorithm is dominated when ğ‘š â‰¥ 200.
The time consumption of algorithms in BAKE-2 is shown in
Figure 9 and Figure 10, which implies that the running time of
these three algorithms increases as the size of biometric vector set
ğ‘› grows. The time consumption of Enc and Dec exceeds 1 second
when ğ‘› = 500 and ğ‘› = 200, respectively, which is more efficient than
existing tow-factor authentication methods (at least 13 seconds on
average) [41]. We also experimented with different operations in
Enc and Dec, as shown in Figure 11 and Figure 12. As ğ‘› increased,
the most time-consuming operation in Enc is the polynomial inter-
polation. In Dec, secret reconstruction and polynomial evaluation
are time-consuming operations when ğ‘› is big.
6.3 Comparison
We compare the computation and communication costs of BAKE-1
and BAKE-2 with the recent fuzzy aPAKE constructions [21], de-
noted as fuzzy aPAKE-1 and fuzzy aPAKE-2. From a practical point
of view, we set ğ‘š = 64 for the irises in BAKE-1 and employ the
average size of fingerprint vector set in DB1, i.e., ğ‘› = 95, in BAKE-2.
Fuzzy aPAKE-1 and fuzzy aPAKE-2 employ an iris as the â€œpass-
wordâ€. Since fuzzy aPAKE-1 and fuzzy aPAKE-2 are designed based
on oblivious transfer protocols and standard asymmetric PAKE,
respectively, different instantiations cause distinct performance. To
make the comparison more convincing, as recommended in [21],
Session 10B: Crypto and Protocol Security CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2629)
s
m
i
(
ee
m
T
g
n
i
n
n
u
R
16000