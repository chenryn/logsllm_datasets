title:Quantitative Network Monitoring with NetQRE
author:Yifei Yuan and
Dong Lin and
Ankit Mishra and
Sajal Marwaha and
Rajeev Alur and
Boon Thau Loo
Quantitative	Network	
Monitoring	with	NetQRE
Yifei	Yuan1,2,	Dong	Lin1,3,	Ankit	Mishra1,	Sajal	Marwaha1,	
Rajeev	Alur1,	and	Boon	Thau	Loo1
1University	of	Pennsylvania
2Carnegie	Mellon	University
3LinkedIn	Inc.
1
Network	Monitoring	is	Important
‚Ä¢ Security	
‚Ä¢ Heavy	hitter
‚Ä¢ Super	spreader
‚Ä¢ Syn	flood
‚Ä¢ Slowloris
‚Ä¢ ‚Ä¶
‚Ä¢ Performance
‚Ä¢ Traffic	matrix
‚Ä¢ Application	usage
‚Ä¢ ‚Ä¶
Monitoring	
query
2
Today‚Äôs	Low-level	Programming	Abstraction
Packet stream
state	s		=	s0;
Upon	receiving	packet	p	{
s	=	update(s,	p);
output	d	=	decide(s);
}
Monitoring	query
Streaming	algorithm
Monitoring	results
3
Motivating	Example:	VoIP	Monitoring
Example	Policy:
1. Monitor	average	number	of	VoIP	calls	per	user
2. Alert	a	user,	if	her/his	number	of	calls	exceeds	a	
threshold
Stateful:	Need	to	maintain	state	to	track	VoIP	sessions	with	
each	incoming	packet
Quantitative:	Need	to	compute	numerical	aggregate	based	
on	metrics	of	past	history	and	across	users
What	low-level	state	to	maintain?
How	to	update	it?
4
NetQRE	Overview
Stream-level	abstraction
Packet stream
Modular	programming
Policy	Specification	in	
NetQRE
NetQRE	
Compiler
‚Ä¢ Automatic	state	inference
‚Ä¢ Efficient	state	update
‚Ä¢ Automatic	optimization
Monitoring	query	
implementation
Monitoring	results
5
Outline
‚Ä¢ Motivation
‚Ä¢ NetQRE	language
‚Ä¢ NetQRE	compiler
‚Ä¢ Implementation
‚Ä¢ Evaluation
6
Outline
‚Ä¢ Motivation
‚Ä¢ NetQRE	language
‚Ä¢ NetQRE	compiler
‚Ä¢ Implementation
‚Ä¢ Evaluation
7
Modular	Programming	of	VoIP	Monitoring
‚Ä¢ Input:	packet	stream	from	all	users
‚Ä¢ Output:	average	number	of	VoIP	calls	per	user
‚Ä¢ Procedure:
‚Ä¢ Step	1:	Focus	on	the	packet	stream	from	an	arbitrary	user	x
‚Ä¢ Step	2:	View	the	stream	as	a	sequence	of	calls,	and	identify	each	call
‚Ä¢ Step	3:	Aggregate	across	all	calls	in	the	stream	of	the	user
‚Ä¢ Step	4:	Aggregate	across	all	users
8
Step	1:	Focus	on	Packet	Stream	of	User	x
‚Ä¶‚Ä¶‚Ä¶‚Ä¶.
filter(usr=x)
‚Ä¶‚Ä¶‚Ä¶‚Ä¶.
Legend
Packets	from	
user	x
Packets	from	
other	users
9
Step	2:	Identify	A	Call
‚Ä¶‚Ä¶‚Ä¶‚Ä¶.
filter(usr=x)
VoIP	Call
VoIP	Call
‚Ä¶‚Ä¶‚Ä¶‚Ä¶.
VoIP	Call
How	to	specify	the	pattern	of	a	VoIP	call?
Legend
Packets	from	
user	x
Packets	from	
other	users
10
Step	2:	Identify	A	Call
‚Ä¶‚Ä¶‚Ä¶‚Ä¶.
filter(usr=x)
VoIP	Call
VoIP	Call
‚Ä¶‚Ä¶‚Ä¶‚Ä¶.
VoIP	Call
Legend
Packets	from	
user	x
Packets	from	
other	users
INIT
200
ACK
Media
BYE
200
regular	pattern
re_call	=	[invite]	[200] [ack]	[data]*	[BYE]	[200]
11
Step	2:	Identify	A	Call
‚Ä¶‚Ä¶‚Ä¶‚Ä¶.
filter(usr=x)
VoIP	Call
VoIP	Call
‚Ä¶‚Ä¶‚Ä¶‚Ä¶.
VoIP	Call
re_call?1
?1
How	to	associate	a	numerical	value	with	each	pattern?
Legend
Packets	from	
user	x
Packets	from	
other	users
12
Step	2:	Identify	A	Call
‚Ä¶‚Ä¶‚Ä¶‚Ä¶.
filter(usr=x)
VoIP	Call
VoIP	Call
‚Ä¶‚Ä¶‚Ä¶‚Ä¶.
VoIP	Call
call = re_call?1
call
call
Legend
Packets	from	
user	x
Packets	from	
other	users
13
Step	3:	Aggregate	over	All	Calls
‚Ä¶‚Ä¶‚Ä¶‚Ä¶.
filter(usr=x)
VoIP	Call
VoIP	Call
‚Ä¶‚Ä¶‚Ä¶‚Ä¶.
VoIP	Call
call = re_call?1
call
call
call_usr(x) = iter(call, sum)
Legend
Packets	from	
user	x
Packets	from	
other	users
14
Stream	Iteration:	iter(f, aggop)
‚Ä¢ f is	a	NetQRE	function
‚Ä¢ aggop is	an	aggregation	operator,	such	as	sum,	avg,	max,	min.
‚Ä¢ Split	the	stream	into	multiple	substreams	s1,	‚Ä¶ ,	sn such	that	f is	defined	
on	each	si
‚Ä¢ Returns	aggop(f(s1),	‚Ä¶ ,	f(sn))
‚Ä¶‚Ä¶ùëì
‚Ä¶‚Ä¶‚Ä¶‚Ä¶..
ùëì
‚Ä¶‚Ä¶‚Ä¶..
ùëì‚Ä¶‚Ä¶‚Ä¶‚Ä¶..
aggop( v1,         v2,       ‚Ä¶‚Ä¶
vn)
15
Step	4:	Aggregation	over	All	Users
‚Ä¶‚Ä¶‚Ä¶‚Ä¶.
filter(usr=x)
VoIP	Call
VoIP	Call
‚Ä¶‚Ä¶‚Ä¶‚Ä¶.
VoIP	Call
call
call
call
call_usr(x) = iter(call, sum)
Legend
Packets	from	
user	x
Packets	from	
other	users
avg{ call_usr(x) | User x }
16
Requirements	&	Key	Ideas
Requirements	
Key	Ideas
Pattern	matching	for	
recognizing	traffic	patterns
Handle	arbitrary	&	unknown	
value
Quantitative	aggregations
Regular	expression	(RE)	for	pattern	
matching
Parametric	extension	to	RE
Quantitative	extension	to	RE
17
NetQRE	Language
Regular	Expression
‚Ä¢ Atoms:	letters	
Parametric	
extension
Quantitative
extension
‚Ä¢ E.g.	a,	b,	‚Ä¶
‚Ä¢ Base	RE:	atoms
‚Ä¢ Union:	ùëì	|	ùëî
‚Ä¢ Concatenation:	ùëì‚àòùëî
‚Ä¢ Kleene	star:	ùëì‚àó
Details	in	the	paper
NetQRE
‚Ä¢ Atoms:	predicate	over	packets
‚Ä¢ E.g.	[srcip==ùë•],	[dstip!=10.0.0.1]‚Ä¶
‚Ä¢ Base	NetQRE:	re ? v
‚Ä¢ Choice:	re ? f : g
‚Ä¢ Split:	split(f, g, aggop)
‚Ä¢ Iteration:	iter(f, aggop)
‚Ä¢ Aggregation	over	parameter:
aggop{ f(x) | Type x}
‚Ä¢ Streaming	composition:		f >> g
18
Stream	Split:	split(f, g, aggop)
‚Ä¢ f and	g are	two	NetQRE	functions
‚Ä¢ aggop is	an	aggregation	operator,	such	as	sum,	avg,	max,	min.
‚Ä¢ Split	the	stream	into	two	substreams	s1 and	s2,	such	that	f is	defined	on	
s1 and	g	is	defined	on	s2
‚Ä¢ Returns	aggop(f(s1),	g(s2))
‚Ä¶‚Ä¶‚Ä¶‚Ä¶..
ùëì
				ùëéùëîùëîùëúùëù	(ùë£1,
ùëî‚Ä¶‚Ä¶‚Ä¶‚Ä¶..
																													ùë£2)
19
Outline
‚Ä¢ Motivation
‚Ä¢ NetQRE	language
‚Ä¢ NetQRE	compiler
‚Ä¢ Implementation
‚Ä¢ Evaluation
20
NetQRE	Compilation
‚Ä¢ Goal:	Evaluating	a	query	online	with	small	state
‚Ä¢ Independent	of	length	of	packet	stream
‚Ä¢ Insight:	Leverage	compilation	of	regular	expression	to	DFA
‚Ä¢ Question	1:	How	to	handle	parameters?
‚Ä¢ Insight:	Lazy	instantiation
‚Ä¢ Question	2:	How	to	evaluate	split(f,g,aggop) and	
iter(f,aggop) online?
‚Ä¢ Insight:	Keep	all	possible	(but	bounded	number	of)	cases
‚Ä¢ Details	in	the	paper
21
Compilation	of	RE	with	Parameters
exist_src(x)
srcip != 0
x=0:
q0
srcip == 0
srcip != x
srcip == x
q0
Eager
Instantiation
*
q1
.
.
.
srcip !=2^32
x=2^32:
q0
srcip ==2^32
*
q1
*
q1
Lazy
Instantiation
x
0
q1
*
q0
22
Implementation
‚Ä¢ Single-node	deployment
‚Ä¢ Compiler	implemented	in	C++
‚Ä¢ Compiled	code	C++
‚Ä¢ pcap	library	for	packet	capturing
Real-time	
response
NetQRE
NetQRE	
Compiler
Query	
Implementation
Traffic
23
Outline
‚Ä¢ Motivation
‚Ä¢ NetQRE	language
‚Ä¢ NetQRE	compiler
‚Ä¢ Implementation
‚Ä¢ Evaluation
24
Evaluation
‚Ä¢ Is	the	NetQRE	language	expressive?
‚Ä¢ Is	the	NetQRE	compiled	implementation	efficient?
25
Evaluation:	Expressiveness
Heavy	hitter
Super	spreader
Entropy	estimation
Flow	size	distribution
Traffic	change	detection	
Count	traffic	
Completed	flows
SYN	flood	detection	
Slowloris	detection	
Connection	lifetime
Newly	opened	connection
#	duplicated	ACKs	
#	VoIP	calls
VolP	usage	
DNS	tunnel	detection	
DNS	amplification	
LoC
6
2
6
8
10
2
6
9
12
8
11
5
7
18
4
4
‚Ä¢ Expressive
‚Ä¢ Concise
‚Ä¢ 100+	LoC	in	manual	implementation
‚Ä¢ 100-1000+	LoC	in	compiled	
implementation	
26
Evaluation:	Throughput
9%	reduction
Baseline
NetQRE
)
S
P
P
M
(
t
u
p
h
g
u
o
r
h
T
25
20
15
10
5
0
heavy	
hitter
super	
spreader
entropy
syn	
flood
flow	
num
slowloris
27
Evaluation:	Memory
)
B
M
(
y
r
o
m
e
M
1000
100
10
1
Baseline
NetQRE
~40%	increase
heavy	
hitter
super	
spreader
entropy
syn	flood flow	num slowloris
28
Conclusion
‚Ä¢ Motivation:	Network	monitoring	needs	high-level	abstractions
‚Ä¢ Contributions:	
‚Ä¢ Stream-level	programming	abstraction
‚Ä¢ Parametric	and	quantitative	extension	to	regular	expressions
‚Ä¢ Expressive	to	capture	a	wide	range	of	monitoring	policies
‚Ä¢ Compiled	implementation	efficient	in	both	throughput	and	memory
‚Ä¢ Future	work:
‚Ä¢ Hardware	implementation	
‚Ä¢ Distributed	deployment	of	NetQRE	programs
29