Index Internals
Heikki Linnakangas / Pivotal
Index Access Methods in
PostgreSQL 9.5
B-tree
●
GiST
●
GIN
●
SP-GiST
●
BRIN
●
(Hash)
●
Heap
… but first, the
Heap
Copenhagen
Stores all tuples in table Amsterdam
●
Berlin
Astana
Unordered
●
Athens
Baku
Zagreb
Andorra la Vella
Bern
Helsinki
Brussels
Bucharest
Budapest
Chișinău
Ljubljana
Dublin
Kiev
Bratislava
Lisbon
Stockholm
Heap
Copenhagen
Divided into 8k blocks Amsterdam
● Blk 0
Berlin
Astana
Athens
Blk 1 Baku
Zagreb
Andorra la Vella
Bern
Blk 2 Helsinki
Brussels
Bucharest
Budapest
Blk 3 Chișinău
Ljubljana
Dublin
Kiev
Bratislava
Blk 4
Lisbon
Stockholm
TID: Physical location of heap tuple
0: Copenhagen
1: Amsterdam
Blk 0
2: Berlin
3:
4: Astana
0: Athens
1:
Blk 1
22: Helsinki
3: Zagreb
4: Andorra la Vella
Example: Helsinki, Block 1, item 2 within block
Item pointer
Example: Helsinki, Block 1, item 2 within block
(1, 2)
Block number and position within page
●
Uniquely identifies a tuple version
●
Indexes in PostgreSQL
Indexes store TIDs of heap tuples
●
– except BRIN
There is no visibility information in indexes
●
– except for a simple “dead” flag, as an optimization
– UPDATE inserts a new index tuple
– Dead tuples are removed by VACUUM
B-tree
Good old B-tree
Default index type
●
Tuples are stored on pages, ordered by key
●
Tree, every branch has same depth
●
B-tree, single page
Amsterdam (0, 12)
Ankara (4, 2)
Astana (1, 9)
Athens (4, 1)
Baku (3, 10)
Belgrade (2, 2)
B-tree, leaf level
Amsterdam (0, 12)
Ankara (4, 2)
Athens (4, 1)
Baku (3, 10)
Belgrade (2, 2)
bbttppoo__nneexxtt bbttppoo__pprreevv
Berlin (3, 9)
Bern (4, 3)
Bratislava (2, 3)
Brussels (0, 4)
Bucharest (0, 2)
B-tree, two levels
Amsterdam (0, 12)
Ankara (4, 2)
Athens (4, 1)
Baku (3, 10)
Belgrade (2, 2)
Berlin (3, 9)
Berlin
Bern (4, 3)
Budapest Bratislava (2, 3)
Brussels (0, 4)
Bucharest (0, 2)
Budapest (0, 3)
Copenhagen (1, 2)
Dublin (3, 2)
Helsinki (0, 1)
Kiev (1, 1)
B-tree that's missing nodes still
works!
Amsterdam (0, 12)
Ankara (4, 2)
Athens (4, 1)
Baku (3, 10)
Belgrade (2, 2)
Berlin (3, 9)
Berlin
Bern (4, 3)
Budapest Bratislava (2, 3)
Brussels (0, 4)
Bucharest (0, 2)
Budapest (0, 3)
Copenhagen (1, 2)
Dublin (3, 2)
Helsinki (0, 1)
Kiev (1, 1)
B-tree details
Lehman & Yao
●
When a page becomes completely empty, it
●
can be removed and recycled
Half-empty pages are never merged
●
Free Space Map to track unused pages
●
B-tree, three levels
Sidenote: Metapage
Most index types in PostgreSQL has a
●
metapage at block 0
– All but GiST
B-tree Metapage
●
– Pointer to root page
– Pointer to “fast root”
Complete B-tree
Metapage
What can you do with a B-tree?
Find key = X
●
Find keys  X
●
ORDER BY
●
LIKE 'foo%'
●
GIN
= Generalized Inverted Index
GIN
Internal structure is basically just a B-tree
●
– Optimized for storing a lot of duplicate keys
– Duplicates are ordered by heap TID
Interface supports indexing more than one key
●
per indexed value
– Full text search: “foo bar” → “foo”, “bar”
Bitmap scans only
●
GIN entry tree
Three ways to store heap TIDs in
entry item
Single heap TID
●
– trivial case, like normal B-tree
Compressed list of heap TIDs
●
– also known as a “posting list”
Pointer (= blk #) to the root of posting tree
●
– TIDs stored on a separate page or tree of pages, in
TID order
GIN
Posting tree
Entry tree
Posting tree
Posting tree
GIN “fast updates”
Insertions to GIN index go to a list of “fast
●
updated” tuple.
– Every search scans the list in addition to index
Moved to index proper by VACUUM
●
– Or by inserts, if grows too big
Can be disabled with FASTUPDATE = off
●
option
Complete GIN
Posting tree
Entry tree
Metapage
Posting tree
Posting tree
Fast update list
GiST
= Generalized Search Tree
GiST
Tree-structure
●
No order within pages
●
Key ranges of pages can overlap
●
– No single “correct” location for a particular tuple
Range types
Find ranges that overlap
Sort by min
Sort by max
Group into clusters
GIST, single page
Stores key + TID
●
[100,150] (1, 10)
One index tuple per [1, 200] (0, 2)
●
[10, 60] (4, 2)
heap tuple
[30, 50] (4, 3)
[20, 70] (5, 1)
[110, 120] (2, 2)
Unordered
●
[15, 30] (2, 1)
[105, 115] (3, 4)
[80, 90] (9, 2)
[25, 45] (8, 1)
[10, 20] (1, 7)
GIST, two levels
[1, 200] (0, 2)
[20, 70] (5, 1)
[30, 50] (4, 3)
[10, 60] (4, 2)
[1, 200]
[100,150] (1, 10)
[80, 150]
[110, 120] (2, 2)
[10, 45]
[105, 115] (3, 4)
[80, 90] (9, 2)
[25, 45] (8, 1)
[15, 30] (2, 1)
[10, 20] (1, 7)
GIST search
[[11,, 220000]] ((00,, 22))
Search key: [[5555,, 6600]]
[[2200,, 7700]] ((55,, 11))
[30, 50] (4, 3)
[[1100,, 6600]] ((44,, 22))
[[11,, 220000]]
[100,150] (1, 10)
[80, 150]
[110, 120] (2, 2)
[10, 45]
[105, 115] (3, 4)
[80, 90] (9, 2)
[25, 45] (8, 1)
[15, 30] (2, 1)
[10, 20] (1, 7)
GiST
Loose ordering
●
Any key can legitimately be stored anywhere in
●
the tree
– As long as the keys in the upper levels are updated
accordingly.
– Performance goes out the window if you do that.
Performance depends on how well the user-
●
defined Picksplit and Choose functions can
group keys
What can you do with GiST?
GIS stuff
●
Find points within a bounding box
●
Nearest Neighbor
●
GiST, not only for geometries
Contrib/intarray
●
Full-text search
●
Upper node “contains” everything below it
●
– For points, a bounding box of all points below it
– For intarray, the OR of all the nodes below it
SP-GiST
= Space-Partitioned GiST
SP-GiST
Space-Partitioned GIST
No overlap between nodes
●
Quite different from GiST
●
Variable depth
●
Multiple nodes per physical page
●
SP-GiST example: Trie
MSTERDAM (4, 9)
A
NKARA (0, 2)
L GRADE (2, 3)
E
LIN (2, 1)
R
B N (0, 4)
CHAREST (1, 8)
U
DAPEST (3, 2)
H ELSINKI (0, 1)
SP-GiST page layout
MSTERDAM (4, 9)
A
NKARA (0, 2)
L GRADE (2, 3)
E
LIN (2, 1)
R
B N (0, 4)
CHAREST (1, 8)
U
DAPEST (3, 2)
H ELSINKI (0, 1)
SP-GiST page layout
MSTERDAM (4, 9)
Metapage
A
NKARA (0, 2)
L GRADE (2, 3)
E
LIN (2, 1)
R
B N (0, 4)
CHAREST (1, 8)
U
DAPEST (3, 2)
H ELSINKI (0, 1)
What can you do with it
Kd-tree
●
– Points only; shapes might overlap
Prefix tree for text
●
BRIN
= Block Range Index
BRIN
Not a tree
●
Contains one entry per heap block (or range of
●
heap blocks)
Very compact
●
Summary information for each block range
●
Approximation #1
BRIN Heap
Index
Amsterdam
Andorra la Vella
Ankara
Astana
Athens
Baku
Belgrade
Berlin
0: Amsterdam – Astana
Bern
1: Athens – Berlin
Bratislava
2: Bern – Bucharest
Brussels
3: Budapest – Dublin Bucharest
4: Helsinki – Ljubljana
Budapest
Chișinău
Copenhagen
Dublin
Helsinki
Kiev
Lisbon
Ljubljana
...
Approximation #2
BRIN Heap
Index
Amsterdam
Andorra la Vella
Ankara
Astana
Athens
Baku
Belgrade
Berlin
3: Budapest – Dublin
Bern
0: Amsterdam – Astana
Bratislava
2: Bern – Bucharest
Brussels
Bucharest
Budapest
4: Helsinki – Ljubljana Chișinău
1: Athens – Berlin Copenhagen
Dublin
Helsinki
Kiev
Lisbon
Ljubljana
...
Approximation #3
BRIN Heap
Index
Amsterdam
Andorra la Vella
Ankara
Blk 0
Astana
Blk 1
Athens
Blk 2
Baku
Blk 3
Belgrade
Blk 4
Berlin
Blk 5
Bern
...
Bratislava
Brussels
Bucharest
3: Budapest – Dublin
0: Amsterdam – Astana
Budapest
2: Bern – Bucharest Chișinău
Copenhagen
Dublin
4: Helsinki – Ljubljana
Helsinki
1: Athens – Berlin
Kiev
Lisbon
Ljubljana
...
...
Complete BRIN
Metapage
Metapage
Blk 0
Blk 1
Revision map
Blk 2
Blk 3
Blk 4 Contains fixed-width slot for each
heap block range, pointing to the
Blk 5 BRIN tuple for that range.
...
3: Budapest – Dublin
0: Amsterdam – Astana
2: Bern – Bucharest
“Regular” BRIN pages
4: Helsinki – Ljubljana
Contain BRIN tuples, in no
1: Athens – Berlin
particular order
...
BRIN: clustering is important!
Amsterdam
Andorra la Vella
Ankara
Astana
Athens
0: Amsterdam – Astana Baku
Belgrade
1: Athens – Berlin
Berlin
2: Bern – Bucharest
3: Budapest – Dublin
Bern
4: Helsinki – Ljubljana Bratislava
Brussels
Bucharest
Budapest
Chișinău
Copenhagen
Dublin
Helsinki
Kiev
Lisbon
Ljubljana
BRIN: clustering is important!
Amsterdam
UPDATE cities SET name='Zagreb' WHERE ...
ZZaaggrreebb
Ankara
Astana
Athens
0: Amsterdam – Zagreb Baku
ZZaaggrreebb
1: Athens – Zagreb
Berlin
2: Bern – Zagreb
3: Budapest – Zagreb
Bern
4: Helsinki – Zagreb ZZaaggrreebb
Brussels
Bucharest
Budapest
ZZaaggrreebb
Copenhagen
Dublin
Helsinki
Kiev
ZZaaggrreebb
Ljubljana
What can you do with BRIN?
Min-max for each block range
●
Allows  searches
●
– Much slower than B-tree lookups
– Always scans the whole index (which is tiny though)
– Always scans the whole heap page (range)
Store bounding box for points, shapes
●
Bloom filters
●
What can you do with BRIN?
Good for large tables with natural or accidental
●
ordering
– Tables loaded in primary key order
– Timestamp columns
A single out-of-order tuple in a page will
●
“pollute” the index, and searches degenerate to
full sequential scans.
Summary
B-tree Sp-GIST
● ●
= 
– Non-overlapping
GIN
●
BRIN
●
– B-tree on steroids
– Containment
– Stores duplicates efficiently
– For clustered data
– Multiple keys per heap
tuple
– Tiny index, slow
GiST
● searches
– “containment” hierarchy