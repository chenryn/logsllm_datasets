这是后端根据日志消息返回的内容：
这个函数有另一个版本叫做`send_data_login_pv`，因为它被修改为记录钱包到后端的私钥，这个版本的格式也可以编码和发送私钥。只有当用户上传私钥访问他们的钱包时，才会调用这个函数，密钥文件内容也被转发到后端。
当受害者通过使用MyEtherWallet提供的方法解密他们的钱包时，ATS功能开始实际运作，该方法触发`PrivateKey_decryptWallet`函数的onclick事件。
这个函数遍历用户可以使用的所有不同的身份验证选项并记录用户使用了什么方法，然后它开始自动传输代码。 下面是一个对每种认证方法重复的功能：
您可以看到MEWKit记录用户使用的认证方法，设置余额并将标志位设置为0并调`check_send_block`函数。
在我们跳转到`check_send_block`函数之前，有一些重要的东西需要理解：这个特定的高亮示例使用`send_data_login_pv`函数，该函数还会发送钱包的私钥到后端。这意味着MEWKit进行攻击后仍然可以访问受害者的钱包。
如果受害者购买更多以太币，攻击者可以继续盗取受害者的资金。
这同样适用于另一种验证方法。 使用keyfile / JSON文件上传方法将文件上传到后端这也允许MEWKit攻击者继续访问受害者的钱包：
函数会将上传的文件发送到后端脚本post.php中由后端路径的js_stat配置变量作为前缀。
函数将通过查看发送功能是否可用来检查受害者是否成功验证：
这个函数会一直调用它自己，但会用标志阻塞，直到受害者可以启动交易。
然后代码跳转到`check_balance_block`函数：
虽然这个功能看起来很复杂，但它所做的只是通过手动解析HTML来检查钱包的余额，一旦它可以确定一个可用余额，就会将其记录到后端，并且调用`check_valid_balance`函数：
`check_valid_balance`函数检查余额是否为正数。 如果不是，它会在后端记录一条消息，申明'Stop
ATS'。如果检查余额为正数，它将通过调用get_address函数来继续执行流程。
这个功能与日志功能类似，它会构建并嵌入一个脚本资源URL，以便将浏览器调用到后端。 这个用于获取收件人地址的URL是静态的，只添加当前时间戳到URL的末尾。
时间戳会附加到URL上，因为浏览器通常会很智能地使用它，并且如果相同的资源被追加两次，只会使用缓存的结果。
通过添加此时间戳会生成独一无二的URL，来确保后端服务器的更新响应：
LoadScript函数创建一个新的脚本元素并将URL设置为由get_address生成的URL。一旦资源被加载，它将调用`get_state_address`函数继续执行流程。
`get_state_address`函数是jsess_msg变量中设置的值的解析器，该变量由后端通过LoadScript函数。 消息的解析如下所示：
`get_state_address`通过剪切和切分字符串值响应来解析变量内容，以解析出将被盗资金转移到的接收地址。
如果消息的响应中包含[EMPTY]，则MEWKit将停止处理并在日志中记录没有接收地址。
如果它能够从响应中获得地址，它将调用set_data函数，这是转移资金的最后一步。
set_data函数将通过设置接收地址来准备一个事务去触发输入。并在`set_get_trans`函数排队延误之前点击传输按钮。点击转移按钮将使用户进入交易概览页面。
然后，`set_get_trans`函数快速按下按钮以生成事务记录，之后它会对`set_yes_mk_trans`函数进行排队，然后再确认事务。
这将启动余额转移，从而窃取受害者钱包中的可用余额。
基本上，这些最后几项功能可以像合法用户那样只需按下按钮便可以自动创建，确认和开始转账。以下是我们上文提到过的MEWKit核心的所有功能：
这种以自动方式窃取以太坊的功能，和我们之前在钓鱼工具包中看到过的不一样。
#### MEWKit服务器端
如上所示，MEWKit的主要功能，如部分ATS，能在JavaScrip客户端中完全运行。MEWKit的后端仅用于：
  * 日志存储：ATS中的每个步骤都会记录下每个受害者，并将其全部报告给后端
  * 私钥和密码存储：如果用户使用助记符或密码登录，则会记录和在C2上提取并存储以供以后访问。
  * 提供接收地址：将参与收件人的地址保留在后端和传送给被钓鱼的客户。
在大多数情况下，MEWKit实例的后端服务器为攻击者提供了他们正在从事的工作的概况。
#### MEWKit的限制：硬件钱包
虽然MyEtherWallet支持各种硬件钱包，如Trezor8，Ledger
Wallet9，Digital，Bitbox10和Secalot11，但却不支持从这些钱包中获取密钥。这意味着那些在使用硬件钱包时被MEWKit钓鱼的人不会受到MEWKit的ATS的影响，但仍然需要在处理之前确认其钱包上的交易。因为硬件钱包的私钥存储在内部，因此不会暴露于MEWKit。
突发的原因不明的的交易是打击MEWKit的一个标志，当然也不会接受交易所需要采取的措施。MEWKit会记录所有尝试使用硬件钱包的登录信息，它只是无法使用其ATS功能自动进行资金转账。
#### 活动的历史概述
以下部分概述了我们在RiskIQ数据库中集中观察到的所有数据攻击。以下各节中提到的AnyIOC也可以在本报告末尾的妥协指标（IOC）部分中找到。
请注意，我们没有描述观察到的每个MEWKit钓鱼网站，只列出了那些因各小节中描述的原因而可以进行钓鱼攻击的钓鱼网站。我们观察到的所有主机的完整列表可以在本报告结尾附近的“妥协指标”部分找到。
#### 权限边缘之亚马逊53
4月24日11:00
UTC过后的一会儿，针对与亚马逊路由5312相关的IP空间执行了边界网关协议（BGP）劫持，该路由是亚马逊DNS供应系统。这意味着未经授权的用户可以重新将路由一部分旨在AmazonRoute
53的流量传输到自身，并将域分辨率重新路由到他们自己选择的端点。
###### 重新路由MyEtherWallet访客
通常在亚马逊的AS16509下宣布（并维护）的以下IP块已由eNet在AS1029713下公布：
205.251.192.0/24  
205.251.193.0/24  
205.251.195.0/24  
205.251.197.0/24  
205.251.199.0/24
这些IP地址是Amazon Route
53为通过此服务维护的任何域执行DNS路由的一部分。驻留在AS10297中的上述IP块的新端点开始路由预定用于路由53的一些流量并回复来自用户的DNS查询。
实际上，我们可以看到这个AS宣布的前缀相对于它通常所宣称的非常固定的一组块而言：
Source: 
最终处理通常用于Route
53的流量的DNS服务器只设置了一个域来解决：myetherwallet.com。任何其他请求的域名都会被SERVFAIL响应，这是人们已经注意到的。新的DNS服务器响应一个新的IP地址MyEtherWallet，46.161.42.42，驻留在AS41995。根据地理位置，这台服务器来自俄罗斯。如果我们提供一些有关此AS的WHOIS信息，会发现它并不是一个好兆头。
在东欧分配一个AS，并在WHOIS中使用Gmail等免费服务的电子邮件地址通常是一个不好的迹象。我们可以从组织WHOISdetails中获得更多有关此地址的信息：
根据WHOIS信息，自2014年底以来，电子邮件地址的域名一直存在，并且其详细信息始终存在于WHOIS隐私服务之后。目前，主网站onweb-shield.biz处于离线状态，但通过查看档案数据，我们可以找到一个旧的托管公司网站：
Webshield对我们行业中的许多人来说都很熟悉，因为在他们的网站中有许多用于恶意目的的网站IP空间，其中一个例子是Rescator15。我们最感兴趣的是拥有这个AS的主机却已经关闭了它的网站托管网站，但仍然提供了托管机会。我们可以将Webshield定义为一个防弹主机。
###### 以太劫持：通过MEWKit实现资金转账自动化
虽然对亚马逊Route 53的攻击非常复杂，但攻击者用于托管在Webshield
AS上的服务器上的钓鱼站点的设置却不复杂。他们在服务器上放置的证书实际上并不是有效的证书，他们使用WHOIS隐私服务背后的myetherwallet
[.]com创建了自己的自签名证书。这里是以太钱包WHOIS：
Source: 
以下是我们在使用MEWKit的Webshield主机上观察到的SSL证书：
Source:
攻击者只需根据WHOIS详细信息生成证书，该证书由几乎任何现代Web浏览器标记。然而，人们好像还是忽略了这些警告选择了点击，即使有人报告资金被MEWKit从他们的以太钱包中撤出。
MEWKit页面本身与任何正确构建钓鱼页面一样，看起来与正常的以太钱包网站完全相同：
然而，我们在这次攻击中看到的设置与我们在正常MEWKitinstall上看到的不同。如果我们看一下文档对象模型（DOM），我们会看到正常的MEWKit脚本（顶部MEWKit，底部MyEtherWallet.com）：
注意，脚本没有以任何方式混淆 ，看起来他们似乎是正确的。如果我们看看wallet.js，其中包含日志记录配置和后端位置，我们得到这个：
第一个变量将报告后端设置为`http://46.161.42.42/pind/`，第二个变量不可用日志记录。如果我们转到sm.js，我们已经可以在脚本的顶部看到添加了附加变量的一些更改：
正如上面MEWKit的功能所解释的，`eth_recipient`变量与被盗资金的接收者有关。如果我们检查`get_state_address`函数通常设置（单个）的`eth_recipient`变量值，我们看到开发者一直在实现多个收件人地址。该代码仍然包含注释部分，开发者忘记将添加的`eth_recipient_n`变量注释掉，因为它们没有被使用。
该函数还包含一个注释掉的console.log调用，该调用会将消息记录到控制台。这让我们更加确定开发者正在测试用于脚本攻击的新功能。
通过这个图表，我们可以找到更多俄文评论的证据。我们翻译了所有评论，并根据所用的措辞，很可能由熟悉财务条款的俄语母语人士撰写（有关下文的更多信息）。我们将逐个评论。在他们不直接翻译成英文的情况下，我们会做出解释。