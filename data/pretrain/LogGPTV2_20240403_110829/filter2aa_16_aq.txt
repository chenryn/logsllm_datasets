yearday •= daytab[leap][i];
*pmonth = i;
*pday = yearday;
}
我们在前面的章节中曾讲过，逻辑表达式的算术运算值只可能是 0(为假时)或者 1(为真时)。 因此，在本例中，可以将逻辑表达式 leap 用做数组 daytab 的下标。
数组 daytab 必须在函数 day_of_year 和 month_day 的外部进行声明，这样，这两 个函数都可以使用该数组。这里之所以将 daytab 的元素声明为 char 类型，是为了说明在 char 类型的变量中存放较小的非字符整数也是合法的。
到目前为止，daytab 是我们遇到的第一个二维数组。在 C 语言中，二维数组实际上是 一种特殊的一维数组，它的每个元素也是一个一维数组。因此，数组下标应该写成
daytab[i][j]              /* [row][col] */
而不能写成
daytab[i,j]              /* WRONG */
除了表示方式的区别外，C 语言中二维数组的使用方式和其它语言一样。数组元素按行存储， 因此，当按存储顺序访问数组时，最右边的数组下标(即列)变化得最快。
数组可以用花括号括起来的初值表进行初始化，二维数组的每一行由相应的子列表进行 初始化。在本例中，我们将数组 daytab 的第一列元素设置为 0，这样，月份的值为 112， 而不是 011。由于在这里存储空间并不是主要问题，所以这种处理方式比在程序中调整数组 的下标更加直观。
如果将二维数组作为参数传递给函数，那么在函数的参数声明中必须指明数组的列数。 数组的行数没有太大关系，因为前面已经讲过，函数调用时传递的是一个指针，它指向由行 向量构成的一维数组，其中每个行向量是具有 13 个整型元素的一维数组。在该例子中，传递
给函数的是一个指向很多对象的指针，其中每个对象是由 13 个整型元素构成的一维数组。因 此，如果将数组 daytab 作为参数传递给函数 f，那么 f 的声明应该写成下列形式:
f(int daytab[2][13]) { ... }
也可以写成
f(int daytab[][13]) { ... }
因为数组的行数无关紧要，所以，该声明还可以写成
f(int (*daytab)[13]) { ... }
这种声明形式表明参数是一个指针，它指向具有 13 个整型元素的一维数组。因为方括号[]的 优先级高于*的优先级，所以上述声明中必须使用圆括号。如果去掉括号，则声明变成
int *daytab[13]
这相当于声明了一个数组，该数组有 13 个元素，其中每个元素都是一个指向整型对象的指针。 一般来说，除数组的第一维(下标)可以不指定大小外，其余各维都必须明确指定大小。
我们将在 5.12 节中进一步讨论更复杂的声明。
练习 5•8             函数 day_of_year 和 month_day 中没有进行错误检查，请解决该问题。
5.8 指针数组的初始化
考虑这样一个问题:编写一个函数 month_name(n)，它返回一个指向第 n 个月名字的 字符串的指针。这是内部 static 类型数组的一种理想的应用。month_name 函数中包含一 个私有的字符串数组，当它被调用时，返回一个指向正确元素的指针。本节将说明如何初始 化该名字数组。
指针数组的初始化语法和前面所讲的其它类型对象的初始化语法类似:
/* month_name:              return name of n•th month */ char *month_name(int n)
{
static char *name[] = { "Illegal month",
"January", "February", "March",
"April", "May", "June",
"July", "August", "September", "October", "November", "December"
};
其中，name 的声明与排序例子中 lineptr 的声明相同，是一个一维数组，数组的元素为字 符指针。name 数组的初始化通过一个字符串列表实现，列表中的每个字符串赋值给数组相应 位置的元素。第 i 个字符串的所有字符存储在存储器中的某个位置，指向它的指针存储在 name[i]中。由于上述声明中没有指明 name 的长度，因此，编译器编译时将对初值个数进 行统计，并将这一准确数字填入数组的长度。
5.9 指针与多维数组
对于 C 语言的初学者来说，很容易混淆二维数组与指针数组之间的区别，比如上面例子 中的  name。假如有下面两个定义:
int a[10][20]; int *b[10];
那么，从语法角度讲，a[3][4]和 b[3][4]都是对一个 int 对象的合法引用。但 a 是一个 真正的二维数组，它分配了 200 个 int 类型长度的存储空间，并且通过常规的矩阵下标计算 公式 20×row+col(其中，row 表示行，col 表示列)计算得到元素 a[row][col]的位置。但是， 对 b 来说，该定义仅仅分配了 10 个指针，并且没有对它们初始化，它们的初始化必须以显式 的方式进行，比如静态初始化或通过代码初始化。假定 b 的每个元素都指向一个具有 20 个元 素的数组，那么编译器就要为它分配 200 个 int 类型长度的存储空间以及 10 个指针的存储空 间。指针数组的一个重要优点在于，数组的每一行长度可以不同，也就是说，b 的每个元素不 必都指向一个具有 20 个元素的向量，某些元素可以指向具有 2 个元素的向量，某些元素可以
指向具有 50 个元素的向量，而某些元素可以不指向任何向量。
尽管我们在上面的讨论中都是借助于整型进行讨论，但到目前为止，指针数组最频繁的 用处是存放具有不同长度的字符串，比如函数 month_name 中的情况。结合下面的声明和图 形化描述，我们可以做一个比较。下面是指针数组的声明和图形化描述(参见图    5•9):
char *name[]={"Illegal manth", "Jan", "Feb", "Mar"};
图 5•9
下面是二维数组的声明和图形化描述(参见图 5•10):
char aname[][15] = { "Illegal month", "Jan", "Feb", "Mar" };
图 5•10
练习 5•9             用指针方式代替数组下标方式改写函数 day_of_year 和 month_day。
5.10 命令行参数
在支持 C 语言的环境中，可以在程序开始执行时将命令行参数传递给程序。调用主函数 main 时，它带有两个参数。第一个参数(习惯上称为 argc，用于参数计数)的值表示运行 程序时命令行中参数的数目;第二个参数(称为 argv，用于参数向量)是一个指向字符串数 组的指针，其中每个字符串对应一个参数。我们通常用多级指针处理这些字符串。
最简单的例子是程序 echo，它将命令行参数回显在屏幕上的一行中，其中命令行中各参 数之间用空格隔开。也就是说，命令
echo hello, world
将打印下列输出:
hello, world
按照 C 语言的约定，argv[0]的值是启动该程序的程序名，因此 argc 的值至少为 1。 如果 argc 的值为 1，则说明程序名后面没有命令行参数。在上面的例子中，argc 的值为 3， argv[0]、argv[1]和 argv[2]的值分别为“  echo"、 “  hello,"，以及“  world"。第一 个可选参数为 argv[1]，而最后一个可选参数为 argv[argc•1]。另外，ANSI 标准要求 argv[argc]的值必须为一空指针(参见图 5•11)。
图 5•11
程序 echo 的第一个版本将 argv 看成是一个字符指针数组:
#include 
/* echo command•line arguments; 1st version */ main(int argc, char *argv[])
{
int i;
for (i = 1; i 
/* echo command•line arguments; 2nd version */ main(int argc, char *argv[])
{
while (••argc > 0)
printf("%s%s", *++argv, (argc > 1) ? " " : ""); printf("\n");
return 0;
}
因为 argv 是一个指向参数字符串数组起始位置的指针，所以，自增运算(++argv)将使得 它在最开始指向 argv[1]而非 argv[0]。每执行一次自增运算，就使得 argv 指向下一个参 数，*argv 就是指向那个参数的指针。与此同时，argc 执行自减运算，当它变成 0 时，就完 成了所有参数的打印。
也可以将 printf 语句写成下列形式:
printf((argc > 1) ? "%s " : "%s”, *++argv);
这就说明，printf 的格式化参数也可以是表达式。 我们来看第二个例子。在该例子中，我们将增强 4.1 节中模式查找程序的功能。在 4.1 节
中，我们将查找模式内置到程序中了，这种解决方法显然不能令人满意。下面我们来效仿 UNIX
程序 grep 的实现方法改写模式查找程序，通过命令行的第一个参数指定待匹配的模式。
#include 
#include 
#define MAXLINE 1000
int getline(char *line, int max);
/* find:              print lines that match pattern from 1st arg */ main(int argc, char *argv[])
{
char line[MAXLINE];
int found = 0;
if (argc != 2)
printf("Usage: find pattern\n"); else
while (getline(line, MAXLINE) > 0)
if (strstr(line, argv[1]) != NULL) { printf("%s", line);
found++;
}
return found;
}
标准库函数 strstr(s, t)返回一个指针，该指针指向字符串 t 在字符串 s 中第一次出现的 位置;如果字符串 t 没有在字符串 s 中出现，函数返回 NULL(空指针)。该函数声明在头文 件中。
为了更进一步地解释指针结构，我们来改进模式查找程序。假定允许程序带两个可选参 数。其中一个参数表示"打印除匹配模式之外的所有行"，另一个参数表示"每个打印的文本 行前面加上相应的行号"。
UNIX 系统中的 C 语言程序有一个公共的约定:以负号开头的参数表示一个可选标志或参 数。假定用•x(代表"除……之外")表示打印所有与模式不匹配的文本行，用•n(代表"行 号")表示打印行号，那么下列命令:
find •x •n 模式 将打印所有与模式不匹配的行，并在每个打印行的前面加上行号。
可选参数应该允许以任意次序出现，同时，程序的其余部分应该与命令行中参数的数目 无关。此外，如果可选参数能够组合使用，将会给使用者带来更大的方便，比如:
find •nx 模式 改写后的模式查找程序如下所示:
#include 
#include 
#define MAXLINE 1000
int getline(char *line, int max);
/* find: print lines that match pattern from 1st arg */ main(int argc, char *argv[])
{
char line[MAXLINE]; long lineno = 0;
int c, except = 0, number = 0, found = 0;
while (••argc > 0 && (*++argv)[0] == '•') while (c = *++argv[0])
switch (c) { case 'x':
except = 1; break;
case 'n':
number = 1;
break; default:
printf("find: illegal option %c\n", c); argc = 0;
found = •1; break;
}
if (argc != 1)
printf("Usage: find •x •n pattern\n"); else
while (getline(line, MAXLINE) > 0) { lineno++;
if ((strstr(line, *argv) != NULL) != except) { if (number)
printf("%ld:", lineno);
printf("%s", line); found++;
}
}
return found;
}
在处理每个可选参数之前，argc 执行自减运算，argv 执行自增运算。循环语句结束时， 如果没有错误，则 argc 的值表示还没有处理的参数数目，而 argv 则指向这些未处理参数中 的第一个参数。因此，这时 argc 的值应为 1，而*argv 应该指向模式。注意，*++argv 是 一个指向参数字符串的指引，因此(*++argv)[0]是它的第一个字符(另一种有效形式是
**++argv)。因为[]与操作数的结合优先级比*和++高，所以在上述表达式中必须使用圆括 号，否则编译器将会把该表达式当做*++(argv[0])。实际上，我们在内层循环中就使用了 表达式*++argv[0]，其目的是遍历一个特定的参数串。在内层循环中，表达式*++argv[0] 对指针 argv[0]进行了自增运算。
很少有人使用比这更复杂的指针表达式。如果遇到这种情况，可以将它们分为两步或三 步来理解，这样会更直观一些。
练习 5•10             编写程序 expr，以计算从命令行输入的逆波兰表达式的值，其中每个运算 符或操作数用一个单独的参数表示。例如，命令
expr 2 3 4 + *
将计算表达式 2 × (3 + 4)的值。
练习 5•11             修改程序 entab 和 decab(第 1 章练习中编写的函数)，使它们接受一组作 为参数的制表符停止位。如果启动程序时不带参数，则使用默认的制表符停止位设置。
练习 5•12             对程序 entab 和 detab 的功能做一些扩充，以接受下列缩写的命令: