Header *bp, *p;
bp = (Header *)ap • 1;              /* point to              block header */
for (p = freep; !(bp > p && bp s.ptr); p = p•>s.ptr) if (p >= p•>s.ptr && (bp > p || bp s.ptr))
break;              /* freed block at start or end of arena */
if (bp + bp•>size == p•>s.ptr) {              /* join to upper nbr */ bp•>s.size += p•>s.ptr•>s.size;
bp•>s.ptr = p•>s.ptr•>s.ptr;
} else
bp•>s.ptr = p•>s.ptr;
if (p + p•>size == bp) {              /* join to lower nbr */ p•>s.size += bp•>s.size;
p•>s.ptr = bp•>s.ptr;
} else
p•>s.ptr = bp; freep = p;
}
虽然存储分配从本质上是与机器相关的，但是，以上的代码说明了如何控制与具体机器 相关的部分，并将这部分程序控制到最少量。typedef 和 union 的使用解决了地址的对齐(假 定 sbrk 返回的是合适的指针)问题。类型的强制转换使得指针的转换是显式进行的，这样做 甚至可以处理设计不够好的系统接口问题。虽然这里所讲的内容只涉及到存储分配，但是， 这种通用方法也适用于其它情况。
练习 8•6 标准库函数 calloc(n, size)返回一个指针，它指向 n 个长度为 size 的对象，且所有分配的存储空间都被初始化为 0。通过调用或修改 malloc 函数来实现 calloc 函数。
练习 8•7             malloc 接收对存储空间的请求时，并不检查请求长度的合理性;而 free
则认为被释放的块包含一个有效的长度字段。改进这些函数，使它们具有错误检查的功能。
练习 8•8    编写函数 bfree(p, n)，释放一个包含 n 个字符的任意块 p，并将它放入 由 malloc 和 free 维护的空闲块链表中。通过使用 bfree，用户可以在任意时刻向空闲块 链表中添加一个静态或外部数组。
附录A 参考手册
A.1 引言
本手册描述的 C 语言是 1988 年 10 月 31 日提交给 ANSI 的草案，批准号为"美国国家信 息系统标准——C 程序设计语言，X3.159•1989"。尽管我们已尽最大努力，力求准确地将该手 册作为 C 语言的指南介绍给读者，但它毕竟不是标准本身，而仅仅只是对标准的一个解释而 已。
该手册的组织与标准基本类似，与本书的第 1 版也类似，但是对细节的组织有些不同。 本手册给出的语法与标准是相同的，但是，其中少量元素的命名可能有些不同，词法记号和 预处理器的定义也没有形式化。
本手册中，说明部分的文字指出了 ANSI 标准 C 语言与本书第 1 版定义的 C 语言或其它 编译器支持的语言之间的差别。
A.2 词法规则
程序由存储在文件中的一个或多个翻译单元(translation unit)组成。程序的翻译分几个 阶段完成，这部分内容将在 A.12 节中介绍。翻译的第一阶段完成低级的词法转换，执行以字 符#开头的行中的指令，并进行宏定义和宏扩展。在预处理(将在 A.12 节中介绍)完成后， 程序被归约成一个记号序列。
A.2.1               记号
C 语言中共有 6 类记号:标识符、关键字、常量、字符串字面值、运算符和其它分隔符。 空格，横向制表符和纵向制表符、换行符，换页符和注释(统称空白符)在程序中仅用来分 隔记号，因此将被忽略。相邻的标识符、关键字和常量之间需要用空白符来分隔。
如果到某一字符为止的输入流被分隔成若干记号，那么，下一个记号就是后续字符序列 中可能构成记号的最长的字符串。
A.2.2              注释
注释以字符/*开始，以*/结束。注释不能够嵌套，也不能够出现在字符串字面值或字符 字面值中。
A.2.3              标识符
标识符是由字母和数字构成的序列。第一个字符必须是字母，下划线“ _"也被看成是字 母。大写字母和小写字母是不同的。标识符可以为任意长度。对于内部标识符来说，至少前 31 个字母是有效的，在某些实现中，有效的字符数可能更多。内部标识符包括预处理器的宏 名和其它所有没有外部连接(参见 A.11.2 节)的名字。带有外部连接的标识符的限制更严格 一些，实现可能只认为这些标识符的前 6 个字符是有效的，而且有可能忽略大小写的不同。
A.2.4              关键宇
下列标识符被保留作为关键字，且不能用于其它用途:
auto break
double else
int long
struct switch
case
enum
register
typedef
char
const
extern
float
return
short
union
unsigned
continue
default
for
goto
signed
sizeof
void
volatile
do
if
static
while
某些实现还把 fortran 和且 asm 保留为关键字。
说明:关键字 const、signed 和 volatile 是 ANSI 标准中新增加的;enum 和 void 是第 1 版后新增加的，现已被广泛应用;entry 曾经被保留为关键字但从未被使用过，现在 已经不是了。
A.2.5              常量
常量有多种类型。每种类型的常量都有一个数据类型。基本数据类型将在 A.4.2 节讨论。 常量:
整型常量 字符常量 浮点常量 枚举常量
1.             整型常量
整型常量由一串数字组成。如果它以数字 0 开头，则为八进制数，否则为十进制数。八 进制常量不包括数字 8 和 9，以 0x 和 0X 开头的数字序列表示十六进制数，十六进制数包含从 a(或 A)到 f(或 F)的字母，它们分别表示数值 10 到 15。
整型常量若以字母 u 或 U 为后缀，则表示它是一个无符号数;若以字母 l 或 L 为后缀， 则表示它是一个长整型数;若以字母 UL 为后缀，则表示它是一个无符号长整型数。
整型常量的类型同它的形式、值和后缀有关(有关类型的讨论，参见 A.4 节)。如果它没 有后缀且是十进制表示，则其类型很可能是 int、long int 或 unsigned long int。如
果它没有后缀且是八进制或十六进制表示，则其类型很可能是 int、unsigned int、long int 或 unsigned long int。如果它的后缀为 u 或 U，则其类型很可能是 unsigned int 或 ungigned long int。如果它的后缀为 l 或 L，则其类型很可能是 long int 或 unsigned long int。
说明:ANSI 标准中，整型常量的类型比第 1 版要复杂得多。在第 1 版中，大的整型常量 仅被看做是 long 类型。U 后级是新增加的。
2.             字符常量
字符常量是用单引号引起来的一个或多个字符构成的序列，如'x'。单字符常量的值是执 行时机器字符集中此字符对应的数值，多字符常量的值由具体实现定义。
字符常量不包括字符'和换行符，可以使用以下转义字符序列表示这些字符以及其它一些 字符:
换行符
NL(LF)
\n
反斜杠
\
\\
横向制表符
HT
\t
问号
?
\?
纵向制表符
VT
\v
单引号
'
\'
回退符
BS
\b
双引号
"
\"
回车符
CR
\r
八进制数
ooo
\ooo
换页符
FF
\f
十六进制数
hh
\xhh
响铃符
BEL
\a
转义序列\ooo 由反斜杠后跟 1 个、2 个或 3 个八进制数字组成，这些八进制数字用来指 定所期望的字符的值。\0(其后没有数字)便是一个常见的例子，它表示字符 NUL。转义序 列\xhh 中，反斜杠后面紧跟 x 以及十六进制数字，这些十六进制数用来指定所期望的字符的 值。数字的个数没有限制，但如果字符值超过最大的字符值，该行为是未定义的。对于八进 制或十六进制转义字符，如果实现中将类型 char 看做是带符号的，则将对字符值进行符号扩 展，就好像它被强制转换为 char 类型一样。如果\后面紧跟的字符不在以上指定的字符中， 则其行为是未定义的。
在 C 语言的某些实现中，还有一个扩展的字符集，它不能用 char 类型表示。扩展集中 的常量要以一个前导符 L 开头(例如 L'x'。)，称为宽字符常量。这种常量的类型为 wchar_t。 这是一种整型类型，定义在标准头文件中。与通常的字符常量一样，宽字符常 量可以使用八进制或十六进制转义字符序列;但是，如果值超过 wchar_t 可以表示的范围， 则结果是未定义的。
说明:某些转义序列是新增加的，特别是十六进制字符的表示。扩展字符也是新增加的。 通常情况下，美国和西欧所用的字符集可以用 char 类型进行编码，增加 wchar _t 的主要目的 是为了表示亚洲的语言。
3.             浮点常量
浮点常量由整数部分、小数点、小数部分、一个 e 或 E、一个可选的带符号整型类型的指 数和一个可选的表示类型的后缀(即 f、F、l 或 L 之一)组成。整数和小数部分均由数字序 列组成。可以没有整数部分或小数部分(但不能两者都没有)，还可以没有小数点或者 e 和指 数部分(但不能两者都没有)。浮点常量的类型由后缀确定，F 或 f 后缀表示它是 float 类型; l 或 L 后缀表明它是 long double 类型;没有后缀则表明是 double 类型。
说明:浮点常量的后级是新增加的。
4.             枚举常量
声明为枚举符的标识符是 int 类型的常量(参见 A.8.4 节)。
A.2.6              字符串字面值
字符串字面值(string    literal)也称为字符串常量，是用双引号引起来的一个字符序列，如 “ …” 。字符串的类型为"字符数组"，存储类为 static(参见 A.4 节)，它使用给定的字符 进行初始化。对相同的字符串字面值是否进行区分取决于具体的实现。如果程序试图修改字 符串字面值，则行为是未定义的。
我们可以把相邻的字符串字面值连接为一个单一的字符串。执行任何连接操作后，都将 在字符串的后面增加一个空字节\0，这样，扫描字符串的程序便可以找到字符串的结束位置。 字符串字面值不包含换行符和双引号字符，但可以用与字符常量相同的转义字符序列表示它 们。
与字符常量一样，扩展字符集中的字符串字面值也以前导符 L 表示，如 L"…"。宽字符 字符串字面值的类型为“ wchar_t 类型的数组"。将普通字符串字面值和宽字符字符串字面值 进行连接的行为是未定义的。
说明:下列规定都是 ANSI 标准中新增加的:字符串字面值不必进行区分、禁止修改字符 串字面值以及允许相邻字符串字面值进行连接。宽字符字符串字面值也是 ANSI 标准中新增加 的。
A.3 语法符号
在本手册用到的语法符号中，语法类别用楷体及斜体字表示。文字和字符以打字型字体 表不。多个候选类别通常列在不同的行中，但在一些情况下，一组字符长度较短的候选页可 以放在一行中，并以短语“ one of"标识。可选的终结符或非终结符带有下标“ opt"。例如:
{ 表达式 
o
p
t 
 }