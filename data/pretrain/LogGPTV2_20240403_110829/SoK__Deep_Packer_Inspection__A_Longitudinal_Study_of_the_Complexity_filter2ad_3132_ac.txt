the unpacked bytes (U state) are transformed into written
bytes (W state), any further write to these bytes will not
transform them into repacked bytes. In contrast, these bytes
will be considered unpacked memory of the next frame. This
is necessary to consider as repacked only the memory which
is overwritten before starting the next frame of execution,
(following strictly the description provided for the shifting
decode frames technique, detailed in Section II). In fact, it
664
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:03:07 UTC from IEEE Xplore.  Restrictions apply. 
is possible for a packer to reuse the same memory region as
destination to contain the unpacked code of the next frame. In
this case, when the code is overwritten it is not repacked, but
just prepared for the next layer of execution.
Following the method we just described, once the execution
is ﬁnished, our system is able to automatically extract the
number of execution frames for each unpacking layer.
D. Packer Visualization
Although it is well known that data visualization techniques
can help humans in the analysis of an unknown binary, few
solutions are focused on the analysis of run-time packers.
Vera [17] allows to represent graphically the execution trace of
a binary at the basic block level. Unfortunately, it is not clear if
this granularity is useful in presence of very complex packers
that
involve multiple unpacking layers and the interaction
between several processes.
To solve this problem, we propose to combine a precise,
ﬁne-grained monitoring with a coarse-grained visualization of
the execution of the binary in order to provide the analyst a
precise but interpretable source of information for the reverse
engineering task. The graph generated by our tool displays
the different processes and execution layers in each process.
Figure 3 shows an example of Obsidium 1.2, a moderately
complex packer. Our approach represents every executed
memory region (nodes in the graph) enriched with different
information such as the memory type ((M)odule, (S)tack,
(H)eap, (N)one) and address (ﬁrst line in each node), size
(second line in each node) and number of unpacking frames
(third line of the node). These nodes are represented with
different colors for a faster identiﬁcation. The nodes containing
instructions that have written some code are displayed in gray.
There is a single node painted in red, and it contains the
last instruction executed in the binary before the end of the
analysis. In case it is part of a system library, we consider the
last caller represented in the trace. Nodes containing memory
written by another process are painted in green. The rest of
the nodes are displayed in yellow.
Also, for each layer we present the total number of frames.
Finally, edges in the graph represent transitions and write
operations: in red for execution transitions to written memory
regions, in green for memory writes to regions that have been
executed (i.e., unpacked), in gray for execution transitions,
and in blue for interprocess transitions occurred just after an
interprocess memory write. While the example in Figure 3 is
still relatively small, a packer like Armadillo generates graphs
containing hundreds of different nodes and transitions.
E. Complexity Analysis
The last step in the analysis of a packer is to measure
its complexity. First, our system extracts the values for all
the features mentioned in Section II. With this information it
is possible to precisely distinguish, in an automated fashion,
between packers of Type-I, Type-II, and Type-III and between
Type-V and Type-VI. However, to properly distinguish Type-
IV from the adjacent complexity classes we need to be able
665
to clearly separate the code of the packer from the code of the
original application. Unfortunately, this task does not always
have a complete and sound solution.
In fact, one may intuitively think that the application code
would always reside in the deepest layer. However, our experi-
ments conﬁrm that this is not necessarily true. There are cases
in which the packer extends the original application code with
some special routines. In this case, both the application and the
packer code reside in the same layer and, if they are mangled
together, it is practically impossible to tell them apart.
For this reason, we implemented a set of heuristics, based
on the assumption that the original application code and the
unpacking routines are not mangled together. It is possible for
them to be co-located in the same layer, but only if they are not
in contiguous areas of memory. In other words, it is possible
for a certain code to unpack part of the original application and
some additional unpacking routine that will later unpack the
remaining parts. However, these two distinct functionalities
cannot be located in adjacent memory pages but need a
minimum distance between one another (a threshold that can
be conﬁgured, and was set to 10 pages in our experiments).
Otherwise, it would be impossible to separate them and our
system would ﬂag both of them as part of the packer. Under
this assumption, we can safely classify any code that performs
write operations to the memory of another layer as belonging
to the packer – while the remaining code is temporarily ﬂagged
as potential candidate for the application code.
Separating Type-III from Type-IV:
Once we discriminate between the original and the packer
code, distinguishing between interleaved and cyclic packers is
simple. Starting from the end of the instruction trace, we move
backward and consider the transitions between the original
code and the packer code. If we only ﬁnd a transition from
the unpacking routine to the original code (i.e., tail transition),
then the packer is considered cyclic (Type-III), otherwise it
is interleaved (Type-IV or higher). The only uncertain case
happens when all the code is ﬂagged as belonging to the
packer. This means that the original code and some unpacking
routine are located at the same layer and stored in memory at
a distance closer than our threshold. In this case, it is not
possible to distinguish if the packer and application code are
interleaved or not. Therefore, for the lack of evidence, we
assume that the packer belongs to Type-III.
Separating Type-IV from Type-V and Type-VI:
If the majority of the code identiﬁed as potentially belonging
to the original application contains multiple frames, we con-
clude that the packer belongs to either Type-V or Type-VI.
To tell the two classes apart, we analyze the unpacked and
repacked regions overlapping the original code. If there are
repacked blocks, we consider the sample as shifting-decode-
frames. Otherwise, we consider it is incremental.
Finally, we consider the size of the memory written on
the unpacking frames. If the majority of the frames present
an unpacked size multiple of 4K (the size of a page), we
consider the packer to have a page-granularity. If the average
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:03:07 UTC from IEEE Xplore.  Restrictions apply. 
Fig. 3. Graph generated for Obsidium 1.2, a Type-IV packer with several threads, interleaved execution, and a multi-frame unpacking routine. The original
code, located at layer L6, starts at address 0x0040400f, is 0x18a5 bytes long and is unpacked in one single frame (i.e., it is fully unpacked before being
executed). The last executed instructions belong to the unpacking routine (red node at layer L5).
666
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:03:07 UTC from IEEE Xplore.  Restrictions apply. 
number of basic blocks in each frame is one, then we assign a
basic-block granularity. In any other case (e.g., when the size
of the unpacked frame is always different) we mark that as
a more generic block granularity. This category includes the
packers that unpack one function at a time, as well as those
that unpack one functionality at a time (for instance, based on
the command they receive from their C&C server).
IV. CASE STUDIES
During our experiments, we found many different types of
packers that attracted our attention. Moreover, the development
of the proposed taxonomy and the described run-time packer
analysis framework are the result of an iterative process of
analysing, representing and understanding packer structures.
In this section we describe the characteristics of three in-
teresting run-time packers that belong to different complexity
classes: UPolyX, ACProtect, and Armadillo.
UPolyX 0.4: A Type-III packer
UPolyX is a well-known UPX scrambler which obfuscates
a binary already packed with UPX1. The decryption engine
of this packer is polymorphic. Part of the unpacking routine
of this packer is located at layer L0, while another part is
decrypted at run-time, and therefore located at layer L1. When
the execution begins, the control ﬂow jumps from layer L0
to layer L1 back and forth while it unpacks the original
code. Interestingly, the different parts of the original code are
decrypted alternatively by the unpacking routines located at
layer L0 and layer L1. As a consequence, the original code
is split in two layers (L1 and L2) generating many transitions
between these two layers at run-time. This packer is classiﬁed
by our taxonomy as a Type-III packer. It presents a cyclic
transition model not only in the unpacking routines, but also
in the original code. Nevertheless, it has a clear tail-transition
– both parts of the code are not interleaved. Also, there is
an interesting aspect about this structure. Layer L1 contains
part of the unpacking routine, and part of the original code.
According to the deﬁnition of unpacking frame in our model,
this layer is unpacked and executed in two different times. At
t0, the packer reveals part of the unpacking routine. At t1, the
unpacking routine, located in layer L0 and layer L1 decrypts
the original code (that will be assigned to layer L1 or layer
L2). At t2, the tail-jump occurs, and the original code starts
executing at layer L1 and layer L2. Consequently, the code
at layer L1 is written at t0, executed and modiﬁed at t1, and
then these last modiﬁcations are executed at t2. Layer L1 is
unpacked in two frames.
Despite of this elaborate behavior, the packer is still a Type-
III packer because (i) there is a clear tail-jump, and (ii) the
unpacking frames do not affect the visibility of the original
code. Furthermore, from an unpacking point of view, it is fairly
easy to ﬁnd the original entry point.
1http://blog.trendmicro.com/trendlabs-security-intelligence/
some-bits-about-upolyx/
ACProtect 1.09: A Type-IV packer
ACProtect is a complex protector that incorporates a meta-
morphic engine, several layers of encryption, and the ability
to interleave the original code with the packer code in order to
achieve a higher degree of protection. All these obfuscations
complicate the task of recovering a clean version of the
original code.
We analyzed a sample protected by this packer using our
framework, and found that it contains up to 216 layers of code.
Surprisingly, the original code is present at the second layer,
while the rest of the layers contain obfuscated self-modifying
routines that belong to the packer code.
In order to interleave the execution of both types of code, the
packer performs IAT hooking. When the original program calls
to certain API functions, it performs an indirect jump through
the Import Address Table. The addresses corresponding to
these functions are replaced by an address pointing to the
packer code. Each time one of these APIs is called,
the
packer will take control of the program executing some anti-
debugging routines. Then, it will redirect the execution to the
called function, ﬁnally returning to the original code.
This is an example of a moderately complex Type-IV packer
that interleaves the execution of the protected code and the
packer code.
To summarize, this protection scheme presents several char-
acteristics: (i) the original code is not located in the last layer,
(ii) the last executed instruction is not part of the original code,
and (iii), the interleaving of both types of code can complicate
the task of ﬁnding the original entry point.
Armadillo 8.0: A Type-VI packer
Armadillo is a well-known protector that implements nu-
merous anti-reverse-engineering techniques. This packer is
commercialized as a tool to protect legitimate software and
allows the user to precisely conﬁgure the desired protection
level. One of the options available is CopyMem-II, which
produces Type-VI protected binaries.
This packer employs two separate processes during the
unpacking procedure. This scheme is implemented both as an
anti-debugger technique (avoiding another process to attach to
the child process) and to intercept the execution of the original
code, unpacking new frames on demand.
When the process starts, it ﬁrst creates a child process
and attaches to it. Then, the child process starts executing
until it reaches the original entry point of the binary. The
permissions of the memory pages in the module address space
of this binary are modiﬁed to trigger an exception when
they are executed. This exception is captured by the parent
process, which writes to the debugged process memory using
the WriteProcessMemory function.
Finally,
the packer resumes the execution of the child
until it reaches another protected page. Using this technique,
Armadillo manages to reveal only one frame of code at a time.
In this multi-process execution, the code of the packer (parent
process) is interleaved with the execution of the original
code (child process). Nevertheless, since the original code is
667
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:03:07 UTC from IEEE Xplore.  Restrictions apply. 
unpacked and executed in different frames (i.e., at different
times), Armadillo is a clear example of a Type-VI packer.
During our experiments, we found samples protected by
Armadillo that expand 2 processes with up to 100 layers (in
the case of the parent process) and 102 layers of code (in the
case of the child process). In both cases, the ﬁrst 99 layers
corresponded to relatively small obfuscation routines. The
original code was located at layer L101 in the child process,
which also contained part of the unpacking routines. Several
of the layers in both processes were unpacked in different
frames. Our approach allowed us to automatically identify the
original code, observing that it was unpacked and repacked in
different frames with a page granularity.
This structure has several implications: (i) the original code
is not contained in the last layer, (ii) the code of the packer and
the original code are interleaved in a multi-process scheme,
and (iii), the original code only presents one visible frame of
code each time.
V. LONGITUDINAL STUDY OF THE COMPLEXITY OF
RUN-TIME PACKERS
Our approach allows us to measure the complexity of run-
time packers based on the information collected in our analysis
platform. In our experiments we use our system to study two
different datasets: (i) a set of off-the-shelf packers, and (ii) a
set of malware samples packed with custom techniques.
The off-the-shelf packers dataset contains 685 samples, cov-
ering 389 unique packers. Some popular packers are present
multiple times with different versions of the tool or conﬁgured
with different parameters/options to obtain different packing
behaviors. The second dataset was instead extracted from the
samples submitted to the Anubis malware analysis sandbox.
It contains malicious samples (recognized as such by at least
three antivirus products) that had at least a PE section with
entropy higher than 7 but that were not recognized as packed
by Sigbuster, PEiD or F-Prot. The idea behind this dataset is
to represent malware binaries which adopt custom unpacking
routines, often as part of a polymorphic engine or of a pro-
tection/obfuscation layer. More concretely, we retrieved over
1000 samples per year, between 2007 and 2014. The samples
are equally distributed for each month of the year, based on
their submission time. Moreover, to avoid biasing the dataset
towards very common polymorphic families such as the Zeus
botnet, we ensured that the dataset did not contain more than
one sample per malware family per month (the monthly-based
time window allows us to catch the evolution of large malware
families that adopted different packing techniques over time).
A. Analysis Infrastructure
We analyzed every sample in our framework using 20 virtual
machines conﬁgured with two CPUs and 4 GB of RAM each.
The analysis of the samples was automated and each sample
was run until one of the following condition was satisﬁed:
• All the processes under analysis terminated their execu-
tion.
SUMMARY OF THE PACKER COMPLEXITY OF THE STUDIED SAMPLES.
TABLE I
Type
Type I
Type II
Type III
Type IV
Type V
Type VI
Off-the-shelf Custom packers
443 (7.3%)
173 (25.3%)
56 (8.2%)
752 (12.4%)
3993 (65.6%)
352 (51.4%)