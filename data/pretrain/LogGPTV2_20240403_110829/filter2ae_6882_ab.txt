    4   message : Message   AbstractLogger.java:1836:51
    5   message : Message   AbstractLogger.java:2139:94
    6   message : Message   AbstractLogger.java:2142:59
    7   message : Message   AbstractLogger.java:2155:43
    8   message : Message   AbstractLogger.java:2159:67
    9   message : Message   AbstractLogger.java:2202:32
    10  message : Message   AbstractLogger.java:2205:48
    11  message : Message   Logger.java:158:9
    12  message : Message   Logger.java:162:17
    13  data : Message  AwaitCompletionReliabilityStrategy.java:78:83
    14  data : Message  AwaitCompletionReliabilityStrategy.java:82:67
    15  data : Message  LoggerConfig.java:430:28
    16  data : Message  LoggerConfig.java:454:17
    17  message : Message   ReusableLogEventFactory.java:78:86
    18  message : Message   ReusableLogEventFactory.java:100:27
    19  msg : Message   MutableLogEvent.java:209:28
    20  (...)... : Message  MutableLogEvent.java:211:46
    21  reusable : Message  MutableLogEvent.java:212:13
    22  parameter this : Message    ReusableObjectMessage.java:47:17
    23  obj : Object    ReusableObjectMessage.java:48:44
    ...
    88  convertJndiName(...) : String   JndiLookup.java:54:33
    89  jndiName : String   JndiLookup.java:56:56
    90  name : String   JndiManager.java:171:25
    91  name    JndiManager.java:172:40
这条链在执行到`MutableLogEvent#setMessage`时和CodeQL的分析结果略有不同。
在CodeQL中`resusable.formatTo`会调用到`ReusableObjectMessage`中。
但是实际运行过程中由于MessgeFactorty创建Message对象时默认创建的是`ResableSimpleMessage`对象，所以会执行到`ResableSimpleMessage#formatTo`方法。
所以似乎目前使用使用CodeQL的规则是发现不了Log4jShell那个漏洞的，既然我们已经知道了这个漏洞的触发链，可以分析下CodeQL为什么没有分析出来。
通过之前对CodeQL检测出的调用链分析，CodeQL已经分析到了createEvent方法。
查看createEvent方法的调用，在`Log4jShell`的触发链中实际上是在对返回LogEvent的处理过程中触发的，所以这里CodeQL可能没有将返回的LogEvent对象再当作污点进行分析，所以导致没有分析成功。
我们可以创建一个`isAdditionalTaintStep`函数，将`ReusableLogEventFactory#createEvent`的第六个参数Message和`LoggerConfig#log`第一个参数`logEvent`连接起来。
    override predicate isAdditionalTaintStep(DataFlow::Node fromNode, DataFlow::Node toNode) {
            exists(MethodAccess ma,MethodAccess ma2 |
                ma.getMethod().getDeclaringType().hasQualifiedName("org.apache.logging.log4j.core.impl", "ReusableLogEventFactory") 
                and ma.getMethod().hasName("createEvent") and fromNode.asExpr()=ma.getArgument(5) and ma2.getMethod().getDeclaringType().hasQualifiedName("org.apache.logging.log4j.core.config", "LoggerConfig")  
                and ma2.getMethod().hasName("log") and ma2.getMethod().getNumberOfParameters() = 2 and toNode.asExpr()=ma2.getArgument(0)
                        )
          }
最后我们就可以通过CodeQL分析到Log4j shell漏洞的调用链。
    1   message : Message   AbstractLogger.java:709:23
    2   message : Message   AbstractLogger.java:710:47
    3   message : Message   AbstractLogger.java:1833:89
    4   message : Message   AbstractLogger.java:1836:51
    5   message : Message   AbstractLogger.java:2139:94
    6   message : Message   AbstractLogger.java:2142:59
    7   message : Message   AbstractLogger.java:2155:43
    8   message : Message   AbstractLogger.java:2159:67
    9   message : Message   AbstractLogger.java:2202:32
    10  message : Message   AbstractLogger.java:2205:48
    11  message : Message   Logger.java:158:9
    12  message : Message   Logger.java:162:17
    13  data : Message  DefaultReliabilityStrategy.java:61:83
    14  data : Message  DefaultReliabilityStrategy.java:63:69
    15  data : Message  LoggerConfig.java:430:28
    16  data : Message  LoggerConfig.java:454:96
    17  message : Message   ReusableLogEventFactory.java:58:47
    18  message : Message   ReusableLogEventFactory.java:60:67
    19  event : LogEvent    LoggerConfig.java:469:13
    20  event : LogEvent    LoggerConfig.java:479:24
    21  event : LogEvent    LoggerConfig.java:481:29
    22  event : LogEvent    LoggerConfig.java:495:34
    23  event : LogEvent    LoggerConfig.java:498:27
    24  event : LogEvent    LoggerConfig.java:536:34
    25  event : LogEvent    LoggerConfig.java:540:38
    26  event : LogEvent    AppenderControl.java:80:30
    27  event : LogEvent    AppenderControl.java:84:38
    28  event : LogEvent    AppenderControl.java:117:47
    29  event : LogEvent    AppenderControl.java:120:27
    30  event : LogEvent    AppenderControl.java:126:32
    31  event : LogEvent    AppenderControl.java:129:29
    32  event : LogEvent    AppenderControl.java:154:34
    33  event : LogEvent    AppenderControl.java:156:29
    34  event : LogEvent    AbstractDatabaseAppender.java:107:30
    35  event : LogEvent    AbstractDatabaseAppender.java:110:37
    36  event : LogEvent    AbstractDatabaseManager.java:260:42
    37  event : LogEvent    AbstractDatabaseManager.java:262:20
    38  event : LogEvent    AbstractDatabaseManager.java:122:27
    39  event : LogEvent    AbstractDatabaseManager.java:123:25
    40  parameter this : LogEvent   Log4jLogEvent.java:530:26
    41  this : LogEvent     Log4jLogEvent.java:534:16
    42  toImmutable(...) : LogEvent     AbstractDatabaseManager.java:123:25
    43  this.buffer [post update] [] : LogEvent    AbstractDatabaseManager.java:123:9
    44  this [post update] [buffer, ] : LogEvent   AbstractDatabaseManager.java:123:9
    45  this  [post update] [buffer, ] : LogEvent     AbstractDatabaseManager.java:262:13
    46  getManager(...) [post update] [buffer, ] : LogEvent    AbstractDatabaseAppender.java:110:13
    47  this [post update] [manager, buffer, ] : LogEvent  AbstractDatabaseAppender.java:110:13
    48  appender [post update] [manager, buffer, ] : LogEvent  AppenderControl.java:156:13
    49  this  [post update] [appender, manager, buffer, ] : LogEvent   AppenderControl.java:156:13
    50  this  [post update] [appender, manager, buffer, ] : LogEvent  AppenderControl.java:129:13
    51  this  [post update] [appender, manager, buffer, ] : LogEvent  AppenderControl.java:120:13
    52  this  [post update] [appender, manager, buffer, ] : LogEvent  AppenderControl.java:84:9
    53  event : LogEvent    AppenderControl.java:80:30
    54  event : LogEvent    AppenderControl.java:84:38
    55  event : LogEvent    AppenderControl.java:117:47
    56  event : LogEvent    AppenderControl.java:120:27
    57  event : LogEvent    AppenderControl.java:126:32
    58  event : LogEvent    AppenderControl.java:129:29
    59  event : LogEvent    AppenderControl.java:154:34
    60  event : LogEvent    AppenderControl.java:156:29
    61  event : LogEvent    AbstractOutputStreamAppender.java:179:24
    62  event : LogEvent    AbstractOutputStreamAppender.java:181:23
    63  event : LogEvent    AbstractOutputStreamAppender.java:188:28
    64  event : LogEvent    AbstractOutputStreamAppender.java:190:31
    65  event : LogEvent    AbstractOutputStreamAppender.java:196:38
    66  event : LogEvent    AbstractOutputStreamAppender.java:197:28
    67  event : LogEvent    GelfLayout.java:433:24
    68  event : LogEvent    GelfLayout.java:438:43
    69  event : LogEvent    GelfLayout.java:471:34
    70  event : LogEvent    GelfLayout.java:496:46
    71  event : LogEvent    StrSubstitutor.java:462:27
    72  event : LogEvent    StrSubstitutor.java:467:25
    73  event : LogEvent    StrSubstitutor.java:911:34
    74  event : LogEvent    StrSubstitutor.java:912:27
    75  event : LogEvent    StrSubstitutor.java:928:28
    76  event : LogEvent    StrSubstitutor.java:978:44
    77  event : LogEvent    StrSubstitutor.java:911:34
    78  event : LogEvent    StrSubstitutor.java:912:27
    79  event : LogEvent    StrSubstitutor.java:928:28
    80  event : LogEvent    StrSubstitutor.java:1033:63
    81  event : LogEvent    StrSubstitutor.java:1104:38
    82  event : LogEvent    StrSubstitutor.java:1110:32
    83  event : LogEvent    StructuredDataLookup.java:46:26
    84  event : LogEvent    StructuredDataLookup.java:50:67
    85  parameter this : LogEvent   RingBufferLogEvent.java:206:20
    86  message : Message   RingBufferLogEvent.java:210:16
    87  getMessage(...) : Message   StructuredDataLookup.java:50:67
    88  (...)... : Message  StructuredDataLookup.java:50:43
    89  msg : Message   StructuredDataLookup.java:54:20
    90  parameter this : Message    StructuredDataMessage.java:239:19
    91  type : String   StructuredDataMessage.java:240:16
    92  getType(...) : String   StructuredDataLookup.java:54:20
    93  lookup(...) : String    StrSubstitutor.java:1110:16
    94  resolveVariable(...) : String   StrSubstitutor.java:1033:47
    95  varValue : String   StrSubstitutor.java:1040:63
    96  buf [post update] : StringBuilder   StrSubstitutor.java:1040:33
    97  buf [post update] : StringBuilder   StrSubstitutor.java:912:34
    98  bufName [post update] : StringBuilder   StrSubstitutor.java:978:51
    99  bufName : StringBuilder     StrSubstitutor.java:979:47
    100 toString(...) : String  StrSubstitutor.java:979:47
    101 varNameExpr : String    StrSubstitutor.java:1010:55
    102 substring(...) : String     StrSubstitutor.java:1010:55
    103 varName : String    StrSubstitutor.java:1033:70
    104 variableName : String   StrSubstitutor.java:1104:60
    105 variableName : String   StrSubstitutor.java:1110:39
    106 key : String    JndiLookup.java:50:48
    107 key : String    JndiLookup.java:54:49
    108 jndiName : String   JndiLookup.java:70:36
    109 ... + ... : String  JndiLookup.java:72:20
    110 convertJndiName(...) : String   JndiLookup.java:54:33
    111 jndiName : String   JndiLookup.java:56:56
    112 name : String   JndiManager.java:171:25
    113 name    JndiManager.java:172:40
## 漏洞挖掘尝试
通过上面的分析可以看到，挖掘到所有的链最终的触发点都是JndiManager，这个点目前的触发已经在新版本中修复了，但是在`DataSourceConnectionSource#createConnectionSource`中也直接调用了lookup方法，我们能否通过某种方式触发呢？
通过注释可以看到DataSource是Core类型插件，因此可以在XML中直接通过标签配置调用。
配置后可以在插件加载的过程中触发漏洞，虽然这种方式也可以造成JNDI注入，但是需要在配置文件中修改参数才能触发，所以价值不大。
最后给出整体的分析Log4j JNDI注入的CodeQL查询代码
    /**
     *@name Tainttrack Context lookup
     *@kind path-problem
     */
    import java
    import semmle.code.java.dataflow.FlowSources
    import DataFlow::PathGraph
    class Context extends  RefType{
        Context(){
            this.hasQualifiedName("javax.naming", "Context")
            or
            this.hasQualifiedName("javax.naming", "InitialContext")
            or
            this.hasQualifiedName("org.springframework.jndi", "JndiCallback")
            or 
            this.hasQualifiedName("org.springframework.jndi", "JndiTemplate")
            or
            this.hasQualifiedName("org.springframework.jndi", "JndiLocatorDelegate")
            or
            this.hasQualifiedName("org.apache.shiro.jndi", "JndiCallback")
            or
            this.getQualifiedName().matches("%JndiCallback")
            or
            this.getQualifiedName().matches("%JndiLocatorDelegate")
            or
            this.getQualifiedName().matches("%JndiTemplate")
        }
    }
    class Logger extends  RefType{
        Logger(){
            this.hasQualifiedName("org.apache.logging.log4j.spi", "AbstractLogger")
        }
    }
    class LoggerInput extends  Method {
        LoggerInput(){
            this.getDeclaringType() instanceof Logger and
            this.hasName("error") and this.getNumberOfParameters() = 1
        }
        Parameter getAnUntrustedParameter() { result = this.getParameter(0) }
    }
    predicate isLookup(Expr arg) {
        exists(MethodAccess ma |
            ma.getMethod().getName() = "lookup"
            and
            ma.getMethod().getDeclaringType() instanceof Context
            and
            arg = ma.getArgument(0)
        )
    }
    class TainttrackLookup  extends TaintTracking::Configuration {
        TainttrackLookup() { 
            this = "TainttrackLookup" 
        }
        override predicate isSource(DataFlow::Node source) {
            exists(LoggerInput LoggerMethod |
                source.asParameter() = LoggerMethod.getAnUntrustedParameter())
        }
        override predicate isAdditionalTaintStep(DataFlow::Node fromNode, DataFlow::Node toNode) {
            exists(MethodAccess ma,MethodAccess ma2 |
                ma.getMethod().getDeclaringType().hasQualifiedName("org.apache.logging.log4j.core.impl", "ReusableLogEventFactory") 
                and ma.getMethod().hasName("createEvent") and fromNode.asExpr()=ma.getArgument(5) and ma2.getMethod().getDeclaringType().hasQualifiedName("org.apache.logging.log4j.core.config", "LoggerConfig")  
                and ma2.getMethod().hasName("log") and ma2.getMethod().getNumberOfParameters() = 2 and toNode.asExpr()=ma2.getArgument(0)
                        )
          }
        override predicate isSink(DataFlow::Node sink) {
            exists(Expr arg |
                isLookup(arg)
                and
                sink.asExpr() = arg
            )
        }
    } 
    from TainttrackLookup config , DataFlow::PathNode source, DataFlow::PathNode sink
    where
        config.hasFlowPath(source, sink)
    select sink.getNode(), source, sink, "unsafe lookup", source.getNode(), "this is user input"
## 总结
通过CodeQL挖洞效率确实比较高，并且在官方也给出了针对很多类型漏洞的审计规则，确实可以高效的辅助挖洞，目前主要解决下面两个问题。
  * 默认的Source应该只是针对HTTP请求，如何针对特定的框架去发现可能作为source的点
  * 分析污点在何时会被打断并进行拼接