A different concept
•
Lightweight, simple and easy – not a WAF
•
Focus on specific (protocol) attacks – HTTP Request Smuggling
•
Secure
•
PoC doesn’t need to be production quality – it just shows that this can be 
applied (e.g. by vendors).
A More Robust Approach
Very strict validation of a small subset of the HTTP “standards”:
•
Anything that affects the request length: 
•
Headers: Content-Length, Transfer-Encoding
•
Unambiguous line ends, header end
•
Request line
•
Unambiguous verb name (GET, OPTIONS, HEAD, DELETE expect no body)
•
Unambiguous protocol designation (HTTP/1.0 or HTTP/1.1)
•
ToDo: more headers? (Connection, Host, etc.)
Design goals
•
Generic – don’t tie to a specific technology/product/platform
•
No dependency on platform-specific technologies e.g. Windows LSP/WFP
•
Nice to have: extensibility (beyond HTTP)
•
HTTPS? (TLS)
•
Other protocols?
•
Secure
•
In-path monitoring (not sniffing based)
Solution: good old function hooking (for sockets, etc.)
Function Hooking
•
“Supported” by major operating systems (Windows, Linux)
•
There are even cross platform function hooking libraries – e.g. FuncHook
(https://github.com/kubo/funchook)
•
Stability and robustness may be an issue – but this is a tech demo
•
Still need to inject code in the first place:
•
Windows – e.g. using standard DLL injection
•
Linux – e.g. LD_PRELOAD
•
So again: stability, etc.
Socket Abstraction Layer (SAL)
•
Abstracts a native socket into standard open-read-close view
•
Cradle-to-death monitoring of native sockets
•
No buffering
•
Maintain a map sockfd → user object
•
Signaling:
•
CTOR – socket open
•
onRead – socket read
•
DTOR – socket close
•
sockfd – allows user object to e.g. send data on the socket
•
Return value – forcibly close socket
SAL – What to Hook? (Windows)
Server
Bitness
WSAAccept
AcceptEx
WSARecv
closesocket
GetQueued
Completion
Status/Ex
Get
Overlapped
Result
Apache
64
Yes
Yes
Yes
Yes
Yes
nginx
64
Yes
Yes
Yes
node.js
64
Yes
Yes
Yes
Yes
Abyss
64
Yes
Yes
Yes
Yes
Tomcat
32
Yes
Yes
Yes
lighttpd
32
Yes
Yes
Yes
SAL – What to Hook (Linux 64bit)
Server
accept
accept4
uv__accept4
(libuv)
recv
read
shutdown
close
Apache
Yes
Yes
Yes
(Yes)
nginx
Yes
Yes
Yes
(Yes)
node.js
Yes
Yes
Yes
(Yes)
Abyss
Yes
Yes
Yes
Tomcat
Yes
Yes
Yes
(Yes)
lighttpd
Yes
(Yes)
Yes
Yes
(Yes)
Squid
Yes
Yes
Yes
HAproxy
Yes
Yes
Yes
Challenges and Lessons Learned
•
Worker processes/forking
•
Locking (socket management table)
•
Preserve the correct error state (errno, LastError, WSALastError)
•
stdout/stderr not always available
•
Squid (Linux) doesn’t like fclose()
•
Statically linked executables with stripped symbols (compiled go)
•
Linux recv() implementation actually invokes recvfrom syscall
•
accept()/accept4() invoked with addr=NULL
•
uvlib (Node.js) – uv__accept4() needs to be hooked
Request Smuggling Firewall (RSFW)
•
Enforce strict RFC 2616 on “relevant” parts of HTTP requests
•
Request line format
•
Header name format
•
Content-Length, Transfer-Encoding – also value format
•
Header end-of-line
•
Chunked body format
•
Default deny policy
•
Single line internal accumulation (data is forwarded to app in real time)
•
Violation handling:
•
Can send a 400 response
•
Connection termination
Demo
Library: https://github.com/SafeBreach-Labs/RSFW
Part 3
New Research 
Challenges
New Research Challenges
•
Promising/suspicious anomalies in an HTTP device
•
I can describe a “matching” behavior that leads to HTTP Request Smuggling
•
No “matching” behavior found (so far)
•
Naïve example (2005…):
•
I notice a web server which takes the first header in a double CL
•
A matching behavior: a proxy which takes the last CL header (but keep both headers)
•
But in my lab, I can only find proxy servers that either take the first header, or reject 
the request
CR in a header name is a hyphen
•
Content\rLength– treated by one web server as “Content-Length”. 
•
Why? I suspect a quick-and-dirty “uppercasing”, using OR with 0x20:
(‘\r’ | 0x20) == ‘-’
•
Sought matching proxy behavior: ignore (forward as-is)
•
Attack: the web server expects a body (but using a GET request, the web server 
will immediately forward the request to the application without a body!, and will 
later discard the body data sent by the proxy)
•
But: All proxy servers I have either reject (400) or modify.
“Signed” Content-Length
•
Content-Length: +1234
•
Non-RFC
•
Some proxy implementations use API a-la atoi() which accepts a sign
•
Sought matching web server behavior: ignore
•
Attack: obvious (the web server has de-facto CL=0)
•
NOTE: doesn’t work if the proxy normalizes the CL header.
•
But: All web servers I have either reject (400) or honor.
•
Vendor status: fixed by Squid (CVE-2020-15049), Abyss, Go.
Content-Length value with SP
•
Content-Length: 12 34
•
Non RFC
•
Nginx (as a web server) ignores the header
•
Sought behavior: a proxy that uses the value (as 1234/12/34) and forwards the 
header as-is
•
Attack: obvious (nginx sees de-facto CL=0)
•
But: all proxy servers I have either reject (400) or remove the header
•
Reported to nginx. WONTFIX (“this doesn't
look like a vulnerability in nginx, as the request in question
cannot be passed through a complaint HTTP proxy with the header
intepreted as a Content-Length header”)
Chunky Monkey Business
•
One web server simply ignores Transfer-Encoding (i.e. doesn’t support 
chunking)
•
Non RFC
•
Sought behavior: a proxy server that prefers TE over CL (but does not modify)
•
Attack: TE+CL. 
•
But: all proxy servers I have normalize the request (either per CL or per TE)
Conclusions
Take-Aways
•
HTTP Request Smuggling is still a thing (in 2020, in COTS SW)
•
Existing open source solutions are lacking
•
There is a more robust approach for defending against HTTP Request 
Smuggling, and it is feasible
•
There are still some interesting challenges in this area!
Thank You!