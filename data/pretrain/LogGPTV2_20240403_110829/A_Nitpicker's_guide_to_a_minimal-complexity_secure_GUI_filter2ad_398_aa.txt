title:A Nitpicker's guide to a minimal-complexity secure GUI
author:Norman Feske and
Christian Helmuth
A Nitpicker’s guide to a minimal-complexity secure GUI
Norman Feske and Christian Helmuth
Technische Universität Dresden
{feske,helmuth}@os.inf.tu-dresden.de
Abstract
Malware such as Trojan Horses and spyware remain to
be persistent security threats that exploit the overly com-
plex graphical user interfaces of today’s commodity oper-
ating systems.
In this paper, we present the design and
implementation of Nitpicker—an extremely minimized se-
cure graphical user interface that addresses these prob-
lems while retaining compatibility to legacy operating sys-
tems. We describe our approach of kernelizing the win-
dow server and present the deployed security mechanisms
and protocols. Our implementation comprises only 1,500
lines of code while supporting commodity software such as
X11 applications alongside protected graphical security ap-
plications. We discuss key techniques such as client-side
window handling, a new ﬂoating-labels mechanism, drag-
and-drop, and denial-of-service-preventing resource man-
agement. Furthermore, we present an application scenario
to evaluate the feasibility, performance, and usability of our
approach.
1
Introduction
Spyware and Trojan Horses are crucial security problems
of today but they are not widely addressed by developers of
operating systems (OS) and graphical user interfaces (GUI),
who are afraid of breaking compatibility with existing com-
modity applications.
In former times, applications behaved friendly and co-
operated with each other to please the user. GUIs designed
twenty years ago do everything to facilitate communication
among applications without bothering application program-
mers with security protocols. Commodity GUIs of today
still expect applications to be nice. Unfortunately, the se-
curity assumptions about the good behavior of applications
do not hold anymore. Today, computers are ubiquitously
connected to networks and it is usual practice to download
applications and applets from untrusted sources. This prac-
tice brings along the risk of falling prey to malware. Once
installed on a system, malicious code can furthermore ex-
ploit the networking facilities to communicate.
In 2004, the overdue discussion about what OS design-
ers can do about GUI security was brought back to life by
J. Shapiro et al. with the presentation of the EROS Trusted
Window System (EWS) [22]. However, the presented ap-
proach supports only a dedicated set of applications com-
piled for the particular platform while the broad range of
mass-market software is not available.
In contrast, current OS and virtualization techniques pro-
vide powerful ways of securing applications while retain-
ing support for legacy software. Xen [11] provides coarse-
grained isolation of concurrently running virtual machines
and heads toward multi-level security. Virtual-machine-
monitor (VMM) technology gets an additional spin by In-
tel’s release of Virtualization Technology [5] and AMD’s
release of the Paciﬁca speciﬁcation. Microsoft’s Next Gen-
eration Secure Computing Base (NGSCB) [20] and its re-
cently announced hypervisor architecture [6] will use these
technologies to separate trusted services from a monolithic
Windows OS by partitioning the underlying platform.
The isolation mechanisms implemented by these plat-
forms enable the safe execution of security applications
aside of a sandboxed legacy OS. With our work, we com-
plement these techniques by an extremely minimized se-
cure GUI to ﬁght security problems such as spyware and
Trojan Horses. Instead of discussing system policies such
as session management, which vary a lot among different
platforms, we focus on low-level mechanisms that are ap-
plicable to a large variety of target platforms. We address
the following classes of malware:
Applications spying on other applications: No appli-
cation should be able to obtain sensitive information from
another application via the GUI, for example by taking a
screen shot. Section 2.2 tells you about our mechanisms
to isolate client applications while still supporting existing
commodity software.
Applications observing the user: Spyware should not
be able to sample key strokes and mouse actions. In Section
2.3, we show how we make applications receive only those
input events that are meant for the particular application.
Applications obtaining data from the user by fraud:
server must be implemented in each client. This does
not mean that each client has to bring along a substantial
amount of overhead. Shared libraries can provide function-
ality that is common among multiple clients and must be
loaded only once.
Let us begin our survey with the discussion of one key
decision leading to the low complexity of Nitpicker.
2.1 Client-side window handling
High complexity of today’s GUI-based applications is
required to manage widgets, which are the basic building
blocks of a GUI. Widget toolkits such as Gtk and Qt offer a
large variety of widgets (e. g., cascaded menus, trees, multi-
column lists) and powerful mechanisms for widget layout.
This comes at the cost of extremely high complexity, for ex-
ample, the Qt toolkit consists of more than 300,000 lines of
C++ code.
There are window systems that implement widget han-
dling on the server side, for example Fresco [3], and DOpE
[14]. While server-side widget handling has advantages
with regard to responsiveness and consistency, the authors
of EWS state that complex widget management should be
implemented on the client side. From the security perspec-
tive, this declaration is valid because widget toolkits do not
enforce security policies at all. Consequently, EWS only
provides windows but no buttons, menus and other widgets.
In DOpE however, a window is implemented as a widget.
This leads to the question of why not implement the win-
dow widget on the client side as well? Should a window
enforce a security policy and provide means to protect ac-
cessibility?
J. Shapiro et al. [22] answer the latter question with yes.
They argument that clients should not decide by themselves
where they are placed on screen and therefore, are not able
to arbitrarily cover other clients. On the other hand, a user
may expect a client to behave exactly like this and to place
its windows in a special way. It does not seem feasible to
lock out those clients. The window system has no informa-
tion about what behavior a user expects from a particular
client. Only the user, not the window system, can classify
misbehaving applications. To protect accessibility against
malicious clients, the user needs a mechanism to freeze and
lock out a client at any time. The policies of window place-
ment, window stacking, and window decoration are no se-
curity mechanisms and therefore should not be attributed to
the server. Client-side window handling is a key point for
achieving exceptionally low complexity of the GUI server.
Note that the X Window System (X11) provides the con-
cept of a window manager, which is one central client that
manages the decorations and policies of all windows of an
X session. From the security perspective, the window man-
ager belongs to the X server because it has unlimited control
Figure 1. General scenario.
Trojan Horses mimic trusted applications to wrest sensitive
information from the user. In Section 2.4, we pull out our
weapon to ﬁght Trojan Horses.
Denial of service of the user interface: Current overly
complex GUIs are prone to denial-of-service attacks driven
by client applications. Such applications can inﬁnitely grab
the mouse pointer or open a full-screen window that cap-
tures all input events to make the user interface inaccessi-
ble. Furthermore, a GUI server that allocates resources on
client request is at the mercy of its clients not to exhaust
the available resources. When relying on high availability,
malicious or faulty applications are an unbearable risk. Our
approach for managing server-side resources is explained in
Section 2.7
After presenting the design of our minimal-complexity
GUI server that we call Nitpicker in Section 2, we outline
its large application space by a selection of potential target
platforms in Section 3. Our implementation for one par-
ticular platform is described in Section 4 and evaluated in
Section 5. After revisiting additional related work in Sec-
tion 6, we conclude the paper with Section 7.
2 Design for Nitpickers
Figure 1 provides an overview about the components that
we discuss. One GUI server exclusively accesses the hard-
ware and serves a number of clients. All clients and the GUI
server are executed within dedicated isolation domains, en-
forced by the underlying OS kernel. In the following, we
refer to these client applications as clients.
High complexity of system software implies a high risk
for the robustness and security of dependent software com-
ponents. The GUI server is a crucial part of system soft-
ware on which end-user applications absolutely need to rely.
Consequently, the design of the GUI server described in this
section follows the principle of minimal complexity. We
only integrate mechanisms for enforcing security and a core
of mandatory GUI functions that cannot be implemented in
another system component. As we will see, this condition
applies for a surprisingly low amount of GUI functionality.
All desired functionality that is not provided by the
GUIServerClientClientClientClientVideo DeviceInput DevicesHardwareover all clients. In contrast, our usage of the term “client-
side window handling” refers to managing windows by each
client itself.
2.2 Buffers and views
In this Section, we describe Nitpicker’s mechanisms
for representing graphical applications on screen while en-
abling the client-side implementation of windows and other
widgets. Nitpicker deals with only two kinds of objects:
buffers and views.
A buffer is a memory region that holds two-dimensional
pixel data. The memory region is provided by the client
and imported into Nitpicker via shared memory. The pixel
format of every buffer is equal to the pixel format of the cur-
rent screen mode. Nitpicker does not perform color-space
conversion because converting color spaces is no security-
relevant functionality. Each client must be aware of the
pixel format provided by Nitpicker.
Nitpicker has no notion of windows. A window is ex-
pected to have window decorations and policies, for exam-
ple a window can be moved by dragging the window title
with the mouse. Nitpicker provides a much simpler ob-
ject type that we call view. A view is a rectangular area on
screen presenting a region of a buffer. Each view has an ar-
bitrary size and position on screen, deﬁned by the client. If
the view’s size on screen is smaller than its assigned buffer,
the client can deﬁne the viewport on the buffer by specify-
ing a vertical and horizontal offset. Note that there may ex-
ist multiple views on one and the same buffer whereas each
view can have an individual size and position on screen and
presents a different region of the buffer. Each time a client
changes the content of a buffer, it informs Nitpicker about
the affected buffer region. Nitpicker then updates all views
that display the speciﬁed buffer region. Views may over-
lap on screen. A client can deﬁne the stacking position of
a view by specifying an immediate neighbor in the view
stack. Each view can optionally be entitled by the client by
specifying a text string.
Each client owns private name spaces of the buffers and
views it created. No client can access the objects of another
client. While each client manages the local stacking order
of its views, the global stacking order of all views is only
known to Nitpicker. This fulﬁlls our initial security goal
that one client can neither obtain information about other
clients nor manipulate other clients.
2.3 Input handling
The buffers and views mechanism presents clients on
screen and let them communicate to the user. For enabling
the save communication in the other direction—from the
user to the client—Nitpicker needs to route mouse and key-
board events to the addressed client while hiding the user
input from other clients (e. g., spyware).
Each client receives input events only if they refer to one
of its views. Among all views, there is one focused view
that represents the keyboard input focus. Only the user se-
lects the focused view by mouse click. No client can deﬁne
the focused view. Nitpicker routes key strokes only to the
focused client—the client that owns the focused view. The
focused view does not need to be the topmost view. It may
be completely covered but it still deﬁnes the routing of input
events.
Input events contain only device-level information. Key
strokes are reported as consecutive press and release events
supplied with the corresponding hardware scancode. There
is no support for high-level information such as the Unicode
of a character, the keyboard layout, and the state of modiﬁer
keys because such functionality is not required to enforce
security. Analogous to the pixel format of buffers, clients
must be aware of the meaning of hardware scancodes.
With the exception that a mouse-press event selects a
new focused view, mouse buttons are handled like other
keys with a deﬁned scancode. Mouse motion and scroll
events are reported to the view under the mouse cursor, but
only if this view belongs to the focused client. This policy
prevents other clients from observing mouse gestures by the
user.
If the user moves the mouse while a mouse button is
pressed, Nitpicker reports all mouse motion events and the
ﬁnishing mouse release event to the view that received the
initial mouse-press event. This clears the way for client-
side window handling. For example, if the user enlarges
a window by dragging a window resize border, the mouse
cursor constantly leaves the view area of this window. We
ensure that the referred window is able to catch all events
that belong to the resize operation.
There are two magic keys that are exclusively in use by
Nitpicker and never can be used by clients. Clients do not
receive events about these keys. The Kill key is used to
freeze the current state of the view layout and let the user
pick a client to lock out from the Nitpicker session. It is
the emergency brake for a misbehaving client. The other
key that we call X-ray will be explained in the following
Section.
2.4 Trusted path
Buffers and views alone are not sufﬁcient to uncover Tro-
jan Horses. The user needs a way to clearly identify the
client with which he is interacting. In the following, we ad-
dress the problems of what textual information should be
used to describe a client and how to present labeling infor-
mation on screen while keeping the user interface ﬂexible
for a broad use.
Commodity window systems such as X11 let clients
choose the text to label a window. This enables nice-
behaving clients to be as expressive as possible. For Tro-
jan Horses however, this policy is an ideal opportunity to
attack. In multi-level secure systems as targeted by Trusted
X [13], labeling information is required to identify the valid
classiﬁcation level in an unforgeable way. On a system
with support for secure booting, a trusted loader could pro-
vide the labeling information for authenticated clients. We
want to support both, expressive textual information pro-
vided by the client (untrusted label) and unforgeable label-
ing that represents underlying policies (trusted label). Con-
sequently, a complete label in Nitpicker is a concatenation
of the trusted label and the untrusted label. Therefore, the
ﬁrst part of the label contains the most sensitive information
and is required to be always visible.
Traditionally, labeling information is displayed in win-
dow titles. EWS also relies on this way while mentioning
that there may be windows without a title at all or a window
title may be covered by other windows.
In [12], Epstein
introduced techniques to maximize the visibility of label-
ing information. One option is to add an additional border
that contains labeling information on all four sides of the
window. While this technique is feasible for targeted multi-
level secure systems, it consumes precious screen space and
limits applications. Windows without the labeling border