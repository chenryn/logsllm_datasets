the stochastic response mechanism based on nondeterministic
programming. Nondeterministic programming is a programming
strategy that does not explicitly specify which further action
would be executed at a certain point, called the choice point;
instead, it allows the program to make a choice among a number
of alternatives based on a selective method at runtime [11].
In our case, each response node is a choice point, and the
alternatives of a response node include whether or not the
candidate variable is to be modiﬁed, and, if it is to be modiﬁed,
the possible values that can be assigned to it.
Several selective methods have been proposed [11]. For
example, one can generate a random number, based on which
one of the alternatives is selected; or read an uninitialized
variable and use its value to determine an alternative; or use the
race condition on concurrent threads, or an unordered iteration,
554
or memory address, or time stamps, etc. We adopt the ﬁrst one
as our selective method.
V. COMMUNICATION CHANNEL
This section presents the system design of the commu-
nication channel. We ﬁrst present the requirements for the
communication channel in our system, and then propose a new
type of communication mediums.
A. Stealth Communication Channel
To support the information transmission between detection
and response nodes, we implement several different commu-
nication channels. Speciﬁcally, we divide all of the detection
and response nodes into several sets, and implement a different
communication channel for each set; this way, the detection
and response nodes within the same set communicate based
on the same communication channel.
We do not implement different communication channels
for each pair of detection and response nodes. Because an app
is an event-driven application, it is difﬁcult to pre-determine
whether both of detection and response nodes of the same
pair will execute at an execution path. If not, there will be no
response even if repackaging is detected, which will decrease
the probability of successfully carrying out responses. We
neither attempt to implement the same channel for all pairs of
detection and response nodes, in order to improve the resilience.
We aim to implement a reliable stealthy communication
channel that is difﬁcult to detect and prevent. Since if the
channel involves transmission errors, an app will still incur
malfunctions even though it has not been repackaged. There
are a few stealthy (covert) channels for Android apps proposed
in the literature [22], [18], [54]. The ﬁrst one is based on
vibration settings; when they are changed, the system sends
a notiﬁcation to interested apps. The second one is based on
volume settings; it is similar to vibration settings. The third
one is based on the mobile phone screen; the changes on the
screen will trigger a notiﬁcation to interested apps. The forth
one is based on Intent; the transmitted data is encoded into
an additional ﬁeld of an Intent. We do not adopt them for
our system. For the ﬁrst three channels, they incur some noise
when a user himself performs some actions on the settings
which cannot be avoided. In addition, they are not stealthy
in the context of apps (few app modiﬁes these settings); thus
they can be easily identiﬁed by attackers. For the last one, the
number of detection and response nodes that can be injected is
restricted by Intent, which limits the feasibility of our system.
B. Communication Medium
We propose a new communication medium which can be
used to implement a reliable stealthy channel that meets our
requirements. The communication medium is a resource (a
ﬁnal variable) in the R class. The R class is a Java class,
automatically generated by aapt (the Android Asset Packaging
Tool), containing the resource IDs for all the resources in the
res directory. For example, R.drawable.icon is a resource; it
has a resource ID which is a static integer and can be used to
retrieve the icon resource. We randomly pick several resources
in the R class as our communication mediums, each of which
is used to implement a reliable stealthy channel. We modify
their resource IDs if repackaging is detected. Because a ﬁnal
variable cannot be modiﬁed once it has been assigned, we use
Reﬂection to achieve it. Since there are usually many places
in the original app that access the resources, the injected code
are stealthy in the context of the app. Moreover, when DVM
(Dalvik Virtual Machine) complies the source code to generate
the Dalvik bytecode, it replaces the references to the resources
everywhere in the code with the actual values, namely, the
resource IDs; thus the modiﬁcation on the resource IDs during
runtime will not change the semantics of the app.
Because our communication channel relies on Reﬂection, it
should be stealthy in apps that involves enough Reﬂection
operations. In fact, Reﬂection is widely used in Android
apps [21], [33], which is also conﬁrmed in our evaluation.
However, there are some apps in which Reﬂection are scarce.
For these apps, one possible attack is to search all Reﬂection in
the app and then disable/remove these Reﬂection one by one. To
counter this attack, we generate decoy Reﬂection. Speciﬁcally,
we deliberately select a few callee methods from the original
code and transform them to utilize Reﬂection to call them;
such generated Reﬂection are called decoy Reﬂection. In this
way, attackers cannot distinguish the Reﬂection used in the
communication channels from the decoy Reﬂection. Moreover,
we apply code obfuscation techniques on the communication
channels to make them difﬁcult to reverse-engineer and improve
the stealthiness. Furthermore, we adopt opaque predicate to
add many instances of Reﬂection, which confuses attackers
and increases their uncertainty as to whether or not they have
successfully disabled/removed the communication channels,
and thus improve the resistance of our system.
VI. SECURITY ANALYSIS
A. Static Analysis
One important issue is that if detection and response nodes
contain ﬁxed code sequences, they may be easily identiﬁed and
removed by attackers through statically scanning (e.g., using
pattern matching and text searching techniques). For detection
nodes, because we construct them based on different predeﬁned
“polymorphic” templates and apply code obfuscation techniques,
the resulted detection nodes are distinct. Moreover, we split
each detection node into several parts and weave these parts
into the original app code. In this way, it is quite difﬁcult to
identify the detection nodes. With regard to response nodes,
because different response nodes target different variables, these
response nodes are distinct. In addition, we also apply code
obfuscation techniques on them, making them more distinct
from each other and improving their stealthiness.
B. Dynamic Analysis
Attackers can also perform dynamic analysis to identify the
detection and response nodes. For the detection nodes, if an
attacker executes and observes the protected app in its dynamic
environment, he may be able to identify the detection nodes
and recognize the hard-coded public key substrings. After that,
the attacker may replace the original public key substrings with
his own one. However, since we inject multiple detection nodes
in terms of the execution paths into the app, the attacker must
iterate this attack for many times to visit all or most of the
execution paths. Although automated test input generators can
be leveraged to generate the possible inputs (e.g., Randoop [44],
Robotium [46]), or directly analyze speciﬁc method calls (e.g.,
Brahmastra [4]), it still requires attackers to inspect the code to
pinpoint the detection nodes and make any code modiﬁcations
necessary so as to disable/remove them. Moreover, because
555
each detection node is obfuscated and then woven into the
surrounding code without identiﬁable boundaries, it greatly
increases the investment cost for attackers.
With respect to the response nodes, because our stealthy-
modiﬁcation mechanism causes the delayed logical malfunc-
tions which leave little noticeable traces behind, it is very
difﬁcult to ﬁnd the failure points (where the malfunctions
explicit), let alone to trace back to the response nodes. Moreover,
to analyze an app, attackers have to feed it with the same
input many times and hopefully can observe the same output.
However, because of our stochastic response mechanism, they
are faced with different delayed malfunctions given the same
input, rendering it a more complicated scenario to investigate.
Attackers may adopt the taint analysis to taint the commu-
nication mediums once identiﬁed, or packages.xml containing
the public key. However, because we utilize string operations
to manipulate the mediums and ﬁle name at runtime and
transform them to Reﬂection for accessing the resources, the
communication channel and protection nodes are difﬁcult to be
identiﬁed by current taint analysis. We examined taint analysis
attacks in our evaluation Section VII-D3.
C. Replay Attacks
The last issue is replay attacks. We assume that attackers
know we use the public key to detect repackaging. Because the
public key is distributed with an app’s apk ﬁle (contained in
the selfsigned X.509 certiﬁcate “META-INF/CERT.RSA”) for
signature veriﬁcation, an attacker can easily obtain it. However,
because he does not know the private key, he has to choose
a new certiﬁcate to sign the repackaged app. To bypass the
repackaging checking of SSN, the attacker’s goal is to provide
the original public key to the detection nodes whenever the
detection nodes ask for Kr . Because Kr is extracted from
packages.xml, one possible way is to substitute the public key
stored in packages.xml with the original one. However, this does
not work. Because packages.xml is owned by the system user
and system group, it cannot be modiﬁed by any app process,
which means that once the public key is stored in packages.xml,
it is protected by the Android system and cannot be modiﬁed
by other processes.
Another possible way is similar to the man-in-the-middle
attack. It refers to an attacker attempts to hijack an essential
function, e.g., getPublicKey, so that whenever it is called, the
original public key will be returned. However, when an app
is launched, Zygote (an Android system service who launch
all apps) creates a clone of itself and initializes a DVM which
preloads the required system classes before the app is started;
this way, the system classes are already loaded and linked
by Zygote. Thus the attacker cannot override the path of the
system class so as to load his own class to substitute the
system class. In addition, because Android runs on Linux whose
kernel implements a strategy called Copy-On-Write (COW),
no memory is actually copied and the memory is shared and
marked as copy-on-write, meaning that the system classes are
read-only and not writable; thus, the attacker either cannot
overwrite the system class after it is loaded.
A more advanced way is to hijack vtable. A vtable is a
virtual function table, pointed by a virtual table pointer (vfptr). A
vtable consists of several virtual function pointers. An attacker
can either overwrite a vfptr to point to an attacker-crafted
vtable, or overwrite a vtable’s contents to manipulate virtual
function pointers, causing further virtual function calls to be
TABLE I.
FEASIBILITY ANALYSIS RESULTS
Category
Avg
LOC Apps use of Detection of Response
Avg #
Avg #
% of
nodes
232
285
344
276
546
423
471
483
503
443
Ofﬁce
Multimedia
Development
5,684
6,268
10,080
6,900
15,170
10,609
14,625
13,938
13,391
Science&Education 9,800
Game
Internet
Security
Reading
Navigation
Phone&SMS
Reﬂection
66.7%
40%
73.3%
43.3%
56.7%
36.7%
46.7%
50%
50%
43.3%
nodes
368
406
658
455
988
685
946
887
859
623
hijacked [55]. For instance, an attacker can swap the pointer of
getPublicKey with his own deﬁned method, such that whenever
getPublicKey is called, the attacker’s method will be executed.
Our work does not deal with such attacks, as it is out of the
scope of this work. Many techniques have been proposed to
address this problem in the literature and can be adopted [55],
[31], [23], [40].
VII. EVALUATION
A. Experimental Settings
We evaluated our tool SSN based on the following four
aspects: feasibility, effectiveness, resilience, and side effects.
We randomly collected 600 apps in 10 categories from F-
Droid [20], which is an catalogue of open source Android apps.
Each category contains 60 apps. We conducted our experiments
on a Nexus 4 ARM emulator with Android 4.1 system. SSN
is ﬂexible to work on different devices with other Android
versions. We choose to use emulator in our experiments as
it is ﬂexible to conﬁgure and does not affect our results and
conclusions compared with using real devices.
B. Feasibility
We begin by studying the feasibility of SSN. We seek to
understand: (1) the percentage of the apps using Reﬂection,
and (2) whether SSN can inject enough detection nodes and
response nodes into the apps. We show the results in Table I.
In Table I, there are ﬁve columns, including the average
lines of code (LOC), the percentage of apps using Reﬂection,
the average numbers of detection nodes and response nodes
injected, with respect to the 10 categories of apps. Note that
the LOC only includes the Java source code of each app.
For each app, the number of the response nodes is deter-
mined by the number of the candidate variables, and the number
of the detection nodes is decided by the number of basic blocks
in the candidate methods; speciﬁcally, for a candidate method
has n basic blocks, we injected (cid:2)n/5(cid:3) detection nodes. Since the
detection nodes are mutually independent, the more detection
nodes are injected, the better resiliency of the repackage-
prooﬁng protection has; however, on the other hand, it results
in more runtime overhead to the protected apps. Thus there is a
trade-off between the number of injected nodes, the resiliency
and the performance overhead. In our experiments, we chose
to inject (cid:2)n/5(cid:3) detection nodes to a candidate method with n
basic blocks, to achieve good resiliency and small overhead.
However, one can easily modify the number for other choices
based on the demand. For example, if he wants to protect a
real-time app, he may choose to inject fewer nodes to attain
smaller overhead. All the detection and response nodes for
each app were divided into eight sets; each set corresponded
556
to an independent communication channel. The number of sets
can also be conﬁgured based on the demand.
Table I also reveals that almost 51% of the 600 apps in
our data set use Reﬂection. For some apps that do not involve
Reﬂection, we generated decoy Reﬂection by selectively picking
a few callee methods and transforming them to use Reﬂection
to call them. For all the 600 apps, we also adopted opaque
predicate to add many instances of spurious Reﬂection to con-
fuse attackers. Moreover, we used proGuard [43], Shilef4J [47],
and yGuard [53] to obfuscate the code, to make it difﬁcult to
reverse-engineer and improve the resistance.
From the results, we can conclude that (1) Reﬂection is
widely used in Android apps, which is also demonstrated in
previous work [21], [33], and (2) SSN can inject many detection
nodes and response nodes into apps, and has good feasibility.
C. Effectiveness