Table 5 shows that Angora outperformed AFL on line
coverage, branch coverage, and found crashes on each pro-
gram. In ﬁle, jhead, nm, objdump, and size, AFL found
0, 19, 12, 4, 6 unique crashes while Angora found 6, 52,
29, 40 and 48 unique crashes, respectively. The contrast is
the most prominent on jhead, where Angora improved the
line coverage by 127.4%, and branch coverage by 144.0%.
Figure 5 compares the cumulative line and branch cover-
age by Angora and AFL over time. It shows that Angora
covers more lines and branches than AFL at all time. The
reason for Angora’s superior coverage is that it can explore
both branches of complicated conditional statements. For
example, Figure 6 shows such a statement in ﬁle, where
Angora successfully explored both branches but AFL could
not explore the true branch.
In the next sections, we will evaluate how each of An-
gora’s key features contributes to its superior performance.
5.3. Context-sensitive branch count
5.3.1. Performance. Section 3.2 introduced context-
sensitive branch count. We believe that distinguishing the
same branch in different function call contexts will ﬁnd
more bugs. To evaluate this hypothesis, we ran Angora
on ﬁle with context-sensitive branch count and context-
insensitive branch count separately. Table 6 shows that
Angora found 6 bugs with context-sensitive branch count,
but no bug without it. Figure 7 shows that starting from 30
minutes into fuzzing, Angora consistently covered more cu-
mulative lines with context-sensitive branch count. We dis-
3. Angora is compatible with aﬂ-cov
720
covered several real world examples where context-sensitive
branch count allowed Angora to explore more paths. For
example, Figure 8 shows a code snippet in the ﬁle readelf.c
in the program ﬁle. The function getu32 is called in
multiple contexts, and it returns different results based on
the swap argument. Without context-sensitive branch count,
Angora would not be able to explore both branches of the
conditional statement in all calling contexts.
5.3.2. Hash collision. Similar to AFL, Angora stores branch
counts in a hash table. When Angora incorporates calling
context when counting branch coverage, it will insert more
unique branches into the hash table, so we have to increase
the size of the hash table to keep the collision rate low.
We evaluated how many more unique branches context
sensitivity brings on the real-world programs described in
Section 5.2. The author of AFL observed that the number of
unique branches (without context) usually ranges between
2k and 10k, and a hash table with 216 buckets should
be enough for common cases [30]. Table 7 shows that
incorporating context sensitivity increases the number of
unique branches by a factor of at most 8, which requires
us to increase the size of the hash table by also a factor of
8 to have the same expected hash collision rate. By default
Angora allocates 220 buckets in its hash table, which is
16 times as large as the hash table in AFL and should be
adequate for most programs. Although growing the hash
table may be harmful when it no longer ﬁts in the cache,
unlike AFL, which traverses the hash table both to ﬁnd new
paths and to prioritize inputs that cover many basic blocks,
for each input Angora traverses the hash table only once
to ﬁnd new paths. Therefore, Angora is less affected by
the growing size of the hash table, as demonstrated by the
execution speed in Section 5.6).
5.4. Search based on gradient descent
Section 3.4 described how to use gradient descent to
solve constraints in conditional statements. We compared
gradient descent with two other strategies: random mutation,
and VUzzer’s magic bytes plus random mutation. To exclude
other variables in the measurement, we ensure that the three
strategies receive the same inputs: we collected the inputs
generated by AFL in Section 5.2, and fed them to Angora
as the only inputs to fuzz. We ran Angora for two hours
using the above three strategies respectively.
Table 8 shows that gradient descent solved more con-
straints than the other two strategies on all the programs. As
explained in the last paragraph of Section 5.1, the “magic
bytes” strategy cannot solve constraints whose values are not
copied directly from the input. For example, the variable
descsz in Figure 6 is used in many constraints in the
program, but it is not copied from the input directly, so the
“magic bytes” strategy did not help.
5.5. Input length exploration
Section 3.6 describes that Angora increases the length of
the input on demand when it observes that a path constraint
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:39:42 UTC from IEEE Xplore.  Restrictions apply. 
TABLE 5: Comparison of Angora and AFL on real world programs
Program
Argument
ﬁle-5.32
jhead-3.00
xmlwf(expat)-2.2.5
djpeg(ijg)-v9b
readpng(libpng)-1.6.34
nm-2.29
objdump-2.29
size-2.29
-C
-x
Size
(kB)
617
120
791
790
972
6252
9063
6207
Line coverage
Branch coverage
AFL
2070
347
1980
5401
1592
6372
3448
2839
Angora
2534
789
2025
5509
1799
7721
6216
4832
Increase
AFL
21.2 % 1462
218
127.4 %
2.3 % 2905
2.0 % 1677
13.0 %
872
21.2 % 4105
80.3 % 2071
70.2 % 1792
Angora
1899
532
3158
1782
1007
4693
3393
2727
Unique crashes
AFL
Angora
Increase
0
29.9 %
144.0 % 19
0
8.7 %
0
6.3 %
15.5 %
0
14.3 % 12
63.8 %
4
6
52.2 %
6
52
0
0
0
29
40
48
 2600
 2400
 2200
 2000
 1800
 1600
 1400
e
g
a
r
e
v
o
c
e
n
i
l
e
v
i
t
l
a
u
m
u
C
 1200
00:00
00:30
01:00
01:30
02:00
02:30
03:00
03:30
04:00
04:30
05:00
AFL
Angora
 2000
 1800
 1600
 1400
 1200
 1000
e
g
a
r
e
v
o
c
h
c
n
a
r
b
e
v
i
t
l
a
u
m
u
C
 800
00:00
00:30
01:00
01:30
02:00
02:30
03:00
03:30
04:00
04:30
05:00
AFL
Angora
Time (HH:MM)
(b) Branch coverage
(a) Line coverage
Figure 5: Line and branch coverage on ﬁle by Angora and AFL in ﬁve hours
Time (HH:MM)
// readelf.c:620
if (namesz == 10 &&
strcmp((char*)&nbuf[noff], "DragonFly")==0
&& type == NT_DRAGONFLY_VERSION
&& descsz == 4) {
...
}
Figure 6: A complicated conditional statement in the ﬁle
readelf.c in the program ﬁle whose true branch Angora
explored successfully but AFL could not
TABLE 6: Comparison of non-context-sensitive branch
count vs. context-sensitive branch count on the program ﬁle
Metric
Line coverage
Branch coverage
Unique crashes
Non-context-sensitive
Context-sensitive
2416
1788
0
2534
1899
6
may depend on the length, while AFL and related fuzzers
increase the input length randomly. We compared these two
strategies based on two criteria:
• How many times does the strategy increase the input
length? Among the inputs created by this strategy, how
many are useful? An input is useful if it explores a new
 2600
 2400
 2200
 2000
 1800
 1600
 1400
e
g
a
r
e
v
o
c
e
n
i
l
e
v
i
t
l
a
u
m
u
C
 1200
00:00
AFL
Angora without context-sensitive branch count
Angora
00:30
01:00
01:30
02:00
02:30
03:00
03:30
04:00
04:30
05:00
Time (HH:MM)
Figure 7: Comparison of non-context-sensitive vs. context-
sensitive branch count on line coverage on the program ﬁle
in ﬁve hours
branch either directly or after some mutation.
• What is the average length of those useful inputs?
We ran Angora with our proposed strategy and the
random strategy for ﬁve hours respectively. Table 9 shows
that Angora’s strategy increased the input length about two
orders of magnitude fewer times than the random strategy,
but it found more useful inputs in all cases except two:
on readpng it found three fewer useful inputs out of a
total of 46, and on jhead neither strategy found any useful
721
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:39:42 UTC from IEEE Xplore.  Restrictions apply. 
// readelf.c:96
uint32_t getu32(int swap, uint32_t value) {
TABLE 8: Percentage of solved constraints in conditional
statements using three strategies
...
if (swap) {
...
return retval.ui;
} else
return value;
}
Figure 8: An example showing that without context sensitive
branch count, Angora would not be able to explore both
branches of the conditional statement, because getu32 is
called from different contexts
TABLE 7: Impact of incorporating context sensitivity on
unique branches
Program
ﬁle
jhead
xmlwf
djpeg
readpng
nm
objdump
size
Unique branches
Context insensitive
Context sensitive
3578
1049
5531
3819
7130
9029
8113
5964
13 554
6914
11 746
13 787
27 577
65 131
40 539
40 148
Ratio
3.79
6.59
2.20
3.61
3.87
7.21
5.00
6.73
input because jhead only parses the header of an image and