本书的第96、99、204、219和237页出现过VB的例子，回顾它们也许有所帮助。
核心对象概览
Core OhjectOverview
在深人细节之前，先来看看.NET的正则对象模型。对象模型是一套类结构，正则表达式的
各种功能通过它们来提供。.NET的正则功能通过7个高度交互的类来提供，实际上你可能
只需要理解其中3个—也就是下一页的图9-1所示的3个类--即可，它们展示了对‘May
16，·1998’重复应用s+（\d+）的过程。
Regex对象
第一步是创建Regex对象，例如：
Dim R as Regex=New Regex("\s+(\d+)*)
在这里，我们用-个Regex对象表示\s+（\d+），将其保存在变量R中。获得Regex对象
之后，我们可以通过Match（texr）方法将其应用到一段文本，返回与第一次匹配结果相关的
信息：
Dim M as Match = R.Match("May 16, 1998*)
---
## Page 443
使用.NET正则表达式
417
\s+（\d+）"
构造函数
Regex
Object
Match("May*16,·1998*)
Match
Match
NextMatch()
Match.Empt
Object
Object
Object
Coun
ndex
ndex
Groups.Count
Success
Value
Gro
Groups(1)
Groups（
Success
Success
false
Group
Group
Group
Group
Object
Object
Object
Object
ndex
ndex
ndex
index
ength
Length
true
·1998*
"1998*
true
true
true
图9-1：.NET正则表达式相关对象模型
Match对象
Regex对象的Match（.）方法通过创建并返回Match对象来提供匹配信息。Match对象有多
个属性，包括Success（一个表示匹配是否成功的Boolean值）和Value（如果匹配成功，
则保存实际匹配文本的副本）。稍后我们会看到Match的所有属性的列表。
Match对象返回的细节中还包括捕获型括号所匹配的文本。前面Perl的例子使用s1保存第
一组捕获型括号匹配的文本。.NET提供了两种办法：如果要取得纯文本，可以按照索引值
访问Match对象的Groups属性，例如Groups（1）.Value，它等价于Perl的s1（请注意，
C#中使用的是Groups[1].Value)。另一个办法是使用Result方法，请参考第429页。
---
## Page 444
418
第9章：.NET
Group对象
前一段中的Groups（1）其实是对Group对象的引l用，后面的.Value引用它的value属性（也
就是此分组对应的文本）。每一组捕获型括号都对应一个Group对象，另外还有一个“虚拟
分组（virtualgroup）”，其编号为0，它保存全局匹配的信息。
因此，MatchObj.Value和MatchObj.Groups（0).Value是等价的一—都是全局匹配的文本
的副本。第一种写法更加简洁方便，但我们必须知道存在编号为0的分组，因为MatchObj.
Groups.Count（也就是Match关联的分组的数目）包含了它。如果s+（\d+）能够匹配成
功，MatchObj.Groups.Count的值就是2（标号为0的全局匹配和s1）。
Capture对象
Capture对象的使用并不频紧，请参考第437页的介绍。
匹配时会计算出所有结果
把正则表达式应用到字符串中，得到一个Match对象，此时所有的结果（匹配的位置，每
个捕获分组匹配的内容等）都会计算出来，封装到Match对象中。访问Match对象的属性
和方法，包括它的Group对象（及其属性和方法）只是取回已经计算好的结果。
核心对象详解
CoreObjectDetails
概览完毕，来看细节。首先，我们来看如何创建Regex对象，然后来看如何将其应用到字
符串，生成Match对象，以及如何处理这个Match对象和它的Group对象。
在实践中，很多时候不必明确创建Regex对象，不过明确创建看起来更顺眼，所以在讲解
核心对象时，每次都会创建它们。稍后我会告诉你.NET提供的简便方法。
在下面的列表中，我会忽略从Object类继承而来的，很少用到的方法。
---
## Page 445
核心对象详解
419
创建Regex对象
Creating Rcgex Objects
Regex的构造函数并不复杂。它可以接收一个参数（作为正则表达式的字符串），或者是两
个参数（一个正则表达式和一组选项）。下面是一个参数的例子：
DimStripTrailwS=newRegex（"\s+S"）’去掉结尾的空白字持
它只是创建Regex，做好应用前的准备；而没有进行任何匹配。
下面是使用两个参数的例子：
Dim GetSubject = new Regex(*^subject:(.*)*，RegexOptions.IgnoreCase)
这里多出了一个RegexOptions选项，不过可以用oR运算符连接多个选项，例如：
Dim GetSubject =new Regex("^subject:（.*)*,-
RegexOptions.IgnoreCase OR RegexOptions.Multiline)
捕获异常
如果正则表达式包含了元字符的非法组合，就会抛出ArgumentException。通常，如果用
户知道所使用的正则表达式能够正常工作，就不需要捕获这个异常，不过如果使用程序“之
外”（例如由用户输人，或者从配置文件读入）的正则表达式，就必须捕获这个异常。
Dim R As Regex
T'ry
R= New Regex(SearchRegex)
Catch e As ArgumentException
Console.WriteLine(**ERROR*bad regex:*& e.ToString)
Exit Sub
End Try
显然，根据情况的不同，在检测到异常之后可能需要不同的处理：你可能需要进行其他的
处理，而不仅仅是向控制台输出报错信息。
Regex选项
在创建Regex对象时，可以使用下面的选项：
RegexOptions.IgnoreCase
此选项表示，在应用正则表达式时，不区分大小写（110）。
RegexOptions.IgnorePatternWhitespace
此选项表示，正则表达式应该按照自由格式和注释模式（111）来解析。如果使用单
纯的#注释，请确认在每一个逻辑行的末尾都有换行符，否则第一处注释会“注释
掉”之后的整个正则表达式。
训
---
## Page 446
420
第9章：.NET
在VB.NET中，我们可以用chr（10）来实现，例如：
Dim R as Regex = New Regex(-
"#匹配一个浮点数..·
*&chr（10）&-
*\d+(？:\.\d*)?
#开头是整数部分.
"&chr（10）&
#或者..
“&chr（10）&
"\.\d+
#开头是小数点”，
RegexOptions.IgnorePatternWhitespace)
这样很累费；VB.NET提供了更简便的（?#）注释：
Dim R as Regex = New Regex(
"（？#匹配一个浮点数...
"\d+(？:\.\d*)?
（？#开头是整数部分..
)&
（？#或者..
）&
"\.\d+
（？#开头是小数点
，
RegexOptions.IgnorePatternWhitespace)
RegexOptions.Multiline
此选项表示，正则表达式在应用时应采用增强的行锚点模式（112）。也就是说，
和$能够匹配字符串内部的换行符，而不仅仅是匹配整个字符串的开头和结尾。
RegexOptions.Singleline
此选项表示，正则表达式使用点号通配模式（111）。此时点号能够匹配任意字符，
也包括换行符。
RegexOptions.ExplicitCapture
此选项表示，普通括号（），在正常情况下是捕获型括号，但此时不捕获文本，而是
与（？："…）一样，只分组，不捕获。此时只有命名捕获括号（？）能够捕获文
本。
如果使用了命名分组，又希望使用非捕获型括号来分组，就可以使用正常的（）括
号和此选项，这样程序看起来更清晰。
RegexOptions.RightroLeft
此选项表示，进行从右向左的匹配（*411）。
RegexOptions.Compiled
此选项表示，正则表达式应该在实际应用时被编译，成为高度优化的格式，这样通常
会大大提高匹配速度。不过这样会增加第一次使用时的编译时间，以及程序执行期间
的内存占用。
如果正则表达式只需要应用一次，或者应用并不是很频繁，就没必要使用RegexOptions，
Compiled，因为即使这个Regex对象已经被回收，多占的内存也不会释放。不过如果
正则表达式在对时间要求很高的场合应用，这个选项可能非常有价值。
---
## Page 447
核心对象详解
421
在第237页的例子中，使用这个选项减少了大约一半的测试时间。还可以参考关于编
译到装配件（assembly）的讨论（434）。
RegexOptions.BCMAScript
此选项表示，正则表达式应该按照ECMAScript（412）兼容方式来解析。如果不清
楚ECMAScript，或者不需要兼容它，可以直接忽略。
RegexOptions.None
它表示“没有额外的选项”，在初始化RegexOptions变量时，如果需要指定选项，可
以使用它。也可以用OR来连接其他希望使用的选项。
使用Regex对象
Using Regex Ohjects
在没有实际应用之前，Regex是没有意义的，下面的程序示范了实际的应用：
RegexObj.IsMatch(target)
Return type:Boolean
RegexObj.IaMatch(target,offset)
IsMatch方法把目标正则表达式应用到目标字符串，返回一个Boolean值，表示匹配尝试
是否成功，这里有个例子：
Dim R as RegexObj = New Regex("^\s*$*)
If R.IsMatch(Line) Then
·如果行为空.·
Endif
如果提供了ofset（一个整数），则第一次尝试会从对应的偏移值开始。
RegexObj.Match (target)
Return type:Match object
RegexObj.Match (target，offset)
RegexObj.Match (target，offset.maxlength)
Match方法把正则表达式应用到目标字符串中，返回一个Match对象。通过这个Match对
象可以查询匹配结果的信息（是否匹配成功，捕获的文本等等），初始化此正则表达式的“下
一次”匹配。Match对象的细节见第427页。
如果提供了ofset（一个整数），则第一次尝试会从对应的偏移值开始。
如果提供了maxlength参数，会进行特殊模式的匹配，从ofset开始的字符开始计算，正则
引擎会把maxlength长度的文本当作整个目标字符事，假设此范围之外的字符都不存在，所
---
## Page 448
422
第9章：.NET
位置。同样，环视结构不能“感觉到”此范围之外的字符。这与提供ofset有很大不同，如
果只提供了ofset，受影响的只是传动装置开始应用正则表达式的位置一一正则引擎仍然能
够“看到”完整的目标字符串。
下面表格中的例子比较了offset和maxlength的意义：
调用方法
以下列表达式RegexObj的结果
rp\P\,
Tala\d
\d\ds
RegexObj.Match(*May 16, 1998")
匹配‘16'
失败
失败
RegexObj.Match(*May 16,1998", 9)
匹配‘99'